uint64_t kek_wrap_key(unsigned __int8 *a1, unint64_t *a2, _BYTE *a3, size_t a4, EVP_CIPHER_CTX *ctx)
{
  int v10;
  uint64_t result;
  unint64_t v12;
  int outl;

  v10 = EVP_CIPHER_CTX_block_size(ctx);
  result = 0;
  if (a4 <= 0xFF)
  {
    v12 = (a4 + v10 + 3) / v10 * v10;
    if (v12 >= 2 * v10)
    {
      if (!a1)
        goto LABEL_8;
      *a1 = a4;
      a1[1] = ~*a3;
      a1[2] = ~a3[1];
      a1[3] = ~a3[2];
      memcpy(a1 + 4, a3, a4);
      if (v12 > a4 + 4)
        arc4random_buf(&a1[a4 + 4], v12 - a4 - 4);
      outl = 0;
      result = EVP_EncryptUpdate(ctx, a1, &outl, a1, v12);
      if ((_DWORD)result)
      {
        result = EVP_EncryptUpdate(ctx, a1, &outl, a1, v12);
        if ((_DWORD)result)
        {
LABEL_8:
          *a2 = v12;
          return 1;
        }
      }
    }
  }
  return result;
}

uint64_t kek_unwrap_key(void *a1, size_t *a2, const unsigned __int8 *a3, unint64_t a4, EVP_CIPHER_CTX *ctx)
{
  int v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unsigned __int8 *v15;
  unsigned __int8 *v16;
  unsigned __int8 *v17;
  size_t v18;
  int outl;

  v10 = EVP_CIPHER_CTX_block_size(ctx);
  v11 = 2 * v10;
  if (v11 > a4)
    return 0;
  v12 = v10;
  if (a4 % v10)
    return 0;
  v15 = (unsigned __int8 *)malloc_type_malloc(a4, 0xD22D1FABuLL);
  if (!v15)
  {
    ERR_put_error(46, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/cms/cms_pwri.c", 239);
    return 0;
  }
  v16 = v15;
  outl = 0;
  v17 = &v15[a4];
  if (EVP_DecryptUpdate(ctx, &v15[a4 - v11], &outl, &a3[a4 - v11], v11)
    && EVP_DecryptUpdate(ctx, v16, &outl, &v17[-v12], v12)
    && EVP_DecryptUpdate(ctx, v16, &outl, a3, a4 - v12)
    && EVP_DecryptInit_ex(ctx, 0, 0, 0, 0)
    && EVP_DecryptUpdate(ctx, v16, &outl, v16, a4)
    && ((v16[5] ^ v16[2]) & (v16[4] ^ v16[1]) & (v16[6] ^ v16[3])) == 0xFF
    && (v18 = *v16, v18 - 4 <= a4))
  {
    *a2 = v18;
    memcpy(a1, v16 + 4, v18);
    v13 = 1;
  }
  else
  {
    v13 = 0;
  }
  freezero(v16, a4);
  return v13;
}

void ERR_load_ENGINE_strings(void)
{
  if (!ERR_func_error_string(ENGINE_str_functs))
  {
    ERR_load_strings(0, (ERR_STRING_DATA *)&ENGINE_str_functs);
    ERR_load_strings(0, (ERR_STRING_DATA *)&ENGINE_str_reasons);
  }
}

const char *DES_options(void)
{
  if ((DES_options_init & 1) == 0)
  {
    snprintf(DES_options_buf, 0x20uLL, "des(%s,%s,%s,%s)", "idx", "cisc", "16", "int");
    DES_options_init = 1;
  }
  return DES_options_buf;
}

void DES_ecb_encrypt(const_DES_cblock *input, DES_cblock *output, DES_key_schedule *ks, int enc)
{
  int v5;
  _QWORD v6[2];

  v6[1] = *MEMORY[0x24BDAC8D0];
  v6[0] = *(_QWORD *)input;
  DES_encrypt1((unsigned int *)v6, ks, enc);
  v5 = HIDWORD(v6[0]);
  *(_DWORD *)output = v6[0];
  *(_DWORD *)&(*output)[4] = v5;
}

time_t x509_verify_asn1_time_to_time_t(int *a1, int a2)
{
  int v3;
  tm v5;

  memset(&v5, 0, sizeof(v5));
  v3 = ASN1_time_parse(*((_QWORD *)a1 + 1), *a1, &v5, a1[1]);
  if (v3 != -1
    && (v3 == 23 || v5.tm_year >= 150)
    && (v3 == 24 || v5.tm_year <= 149)
    && (!a2 || ASN1_time_tm_clamp_notafter()))
  {
    return timegm(&v5);
  }
  else
  {
    return -1;
  }
}

time_t x509_verify_cert_info_populate(uint64_t a1)
{
  int *v2;
  int *v3;
  time_t result;

  v2 = (int *)X509_getm_notBefore(a1);
  *(_QWORD *)(a1 + 208) = x509_verify_asn1_time_to_time_t(v2, 0);
  v3 = (int *)X509_getm_notAfter(a1);
  result = x509_verify_asn1_time_to_time_t(v3, 1);
  *(_QWORD *)(a1 + 216) = result;
  return result;
}

_QWORD *x509_verify_chain_new()
{
  _QWORD *v0;
  STACK *v1;
  void *v2;
  _QWORD *v3;

  v0 = malloc_type_calloc(1uLL, 0x18uLL, 0x30040275E93A9uLL);
  if (!v0
    || (v1 = sk_new_null(), (*v0 = v1) == 0)
    || (v2 = malloc_type_calloc(0x20uLL, 4uLL, 0x100004052888210uLL), (v0[1] = v2) == 0)
    || (v3 = x509_constraints_names_new(512), (v0[2] = v3) == 0))
  {
    x509_verify_chain_free((uint64_t)v0);
    return 0;
  }
  return v0;
}

void x509_verify_chain_free(uint64_t a1)
{
  if (a1)
  {
    sk_pop_free(*(STACK **)a1, (void (__cdecl *)(void *))X509_free);
    *(_QWORD *)a1 = 0;
    free(*(void **)(a1 + 8));
    *(_QWORD *)(a1 + 8) = 0;
    x509_constraints_names_free(*(void **)(a1 + 16));
    free((void *)a1);
  }
}

char *x509_verify_chain_leaf(char **a1)
{
  char *result;

  result = *a1;
  if (result)
    return sk_value((const STACK *)result, 0);
  return result;
}

uint64_t x509_verify_ctx_new_from_xsc(uint64_t a1)
{
  char *v2;
  uint64_t v3;
  STACK *v4;
  STACK *v5;
  uint64_t v6;

  if (!a1)
    return 0;
  v2 = x509_verify_ctx_new(0);
  v3 = (uint64_t)v2;
  if (v2)
  {
    *(_QWORD *)v2 = a1;
    v4 = *(STACK **)(a1 + 24);
    if (!v4 || (v5 = X509_chain_up_ref(v4), (*(_QWORD *)(v3 + 48) = v5) != 0))
    {
      LODWORD(v6) = *(_DWORD *)(*(_QWORD *)(a1 + 48) + 40);
      v6 = (v6 - 1) >= 0x1F ? 32 : v6;
      if ((unint64_t)(v6 - 33) >= 0xFFFFFFFFFFFFFFE0)
      {
        *(_QWORD *)(v3 + 80) = v6;
        return v3;
      }
    }
    x509_verify_ctx_free(v3);
    return 0;
  }
  return v3;
}

char *x509_verify_ctx_new(STACK *a1)
{
  char *v2;
  STACK *v3;
  void *v4;

  v2 = (char *)malloc_type_calloc(1uLL, 0x78uLL, 0x10B0040622242DAuLL);
  if (v2)
  {
    if (a1)
      v3 = X509_chain_up_ref(a1);
    else
      v3 = sk_new_null();
    *((_QWORD *)v2 + 5) = v3;
    if (!v3
      || (*(_OWORD *)(v2 + 72) = xmmword_22D699BF0,
          *((_QWORD *)v2 + 11) = 256,
          v4 = malloc_type_calloc(8uLL, 8uLL, 0x2004093837F09uLL),
          (*((_QWORD *)v2 + 1) = v4) == 0))
    {
      x509_verify_ctx_free((uint64_t)v2);
      return 0;
    }
  }
  return v2;
}

uint64_t x509_verify_ctx_set_max_depth(uint64_t a1, uint64_t a2)
{
  if ((unint64_t)(a2 - 33) < 0xFFFFFFFFFFFFFFE0)
    return 0;
  *(_QWORD *)(a1 + 80) = a2;
  return 1;
}

void x509_verify_ctx_free(uint64_t a1)
{
  unint64_t v2;

  if (a1)
  {
    sk_pop_free(*(STACK **)(a1 + 40), (void (__cdecl *)(void *))X509_free);
    if (*(_QWORD *)(a1 + 32))
    {
      v2 = 0;
      do
        x509_verify_chain_free(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 8 * v2++));
      while (v2 < *(_QWORD *)(a1 + 32));
    }
    sk_pop_free(*(STACK **)(a1 + 16), (void (__cdecl *)(void *))X509_free);
    *(_QWORD *)(a1 + 56) = 0;
    *(_QWORD *)(a1 + 24) = 0;
    *(_QWORD *)(a1 + 32) = 0;
    *(_QWORD *)(a1 + 96) = 0;
    *(_QWORD *)(a1 + 104) = 0;
    *(_DWORD *)(a1 + 112) = 0;
    sk_pop_free(*(STACK **)(a1 + 48), (void (__cdecl *)(void *))X509_free);
    free(*(void **)(a1 + 8));
    free((void *)a1);
  }
}

uint64_t x509_verify_ctx_set_max_chains(uint64_t a1, uint64_t a2)
{
  if ((unint64_t)(a2 - 9) < 0xFFFFFFFFFFFFFFF8)
    return 0;
  *(_QWORD *)(a1 + 72) = a2;
  return 1;
}

uint64_t x509_verify_ctx_set_max_signatures(uint64_t a1, uint64_t a2)
{
  if ((unint64_t)(a2 - 100001) < 0xFFFFFFFFFFFE7960)
    return 0;
  *(_QWORD *)(a1 + 88) = a2;
  return 1;
}

uint64_t x509_verify_ctx_set_purpose(uint64_t a1, int a2)
{
  if ((a2 - 10) < 0xFFFFFFF7)
    return 0;
  *(_DWORD *)(a1 + 64) = a2;
  return 1;
}

BOOL x509_verify_ctx_set_intermediates(uint64_t a1, STACK *a2)
{
  STACK *v3;

  v3 = X509_chain_up_ref(a2);
  *(_QWORD *)(a1 + 48) = v3;
  return v3 != 0;
}

const char *x509_verify_ctx_error_string(uint64_t a1)
{
  return X509_verify_cert_error_string(*(int *)(a1 + 112));
}

uint64_t x509_verify_ctx_error_depth(uint64_t a1)
{
  return *(_QWORD *)(a1 + 104);
}

uint64_t x509_verify_ctx_chain(uint64_t a1, unint64_t a2)
{
  if (*(_QWORD *)(a1 + 32) <= a2)
    return 0;
  else
    return **(_QWORD **)(*(_QWORD *)(a1 + 8) + 8 * a2);
}

uint64_t x509_verify(_QWORD **a1, uint64_t a2, const char *a3)
{
  uint64_t v5;
  char *v6;
  int v7;
  char *v8;
  int v9;
  uint64_t result;
  _BOOL8 v11;
  const STACK **v12;
  int *v13;
  const STACK **v14;
  char *v15;
  int v16;
  char *v17;
  char *v18;
  STACK *v19;
  char *v20;
  STACK *v21;
  char *v22;
  char *v23;
  int v24;

  if (!a1[5] || !a1[10])
    goto LABEL_5;
  v5 = a2;
  v6 = (char *)*a1;
  if (!*a1)
  {
    v11 = 0;
    goto LABEL_14;
  }
  if (a2 | (unint64_t)a3)
  {
LABEL_5:
    v7 = 65;
LABEL_6:
    *((_DWORD *)a1 + 28) = v7;
    goto LABEL_7;
  }
  v5 = *((_QWORD *)v6 + 2);
  v11 = (*(_QWORD *)(*((_QWORD *)v6 + 6) + 24) & 0x80000) == 0;
  v21 = sk_new_null();
  (*a1)[20] = v21;
  if (!v21 || !X509_up_ref(v5))
  {
LABEL_41:
    v7 = 17;
    goto LABEL_6;
  }
  if (!sk_push((STACK *)(*a1)[20], (char *)v5))
  {
    X509_free((X509 *)v5);
    goto LABEL_41;
  }
  v22 = (char *)*a1;
  *((_DWORD *)v22 + 43) = 0;
  *((_QWORD *)v22 + 23) = v5;
LABEL_14:
  v12 = (const STACK **)x509_verify_chain_new();
  v13 = (int *)(a1 + 14);
  if (!v12)
  {
    *v13 = 17;
    goto LABEL_7;
  }
  v14 = v12;
  if (!x509_verify_chain_append((uint64_t)v12, (X509 *)v5, (int *)a1 + 28))
  {
LABEL_48:
    x509_verify_chain_free((uint64_t)v14);
    goto LABEL_7;
  }
  while (1)
  {
    if (!x509v3_cache_extensions(v5))
      goto LABEL_27;
    if (!*a1)
      break;
    v15 = x509_vfy_lookup_cert_match(*a1, (X509 *)v5);
    if (v15)
    {
      X509_free((X509 *)v15);
      goto LABEL_20;
    }
LABEL_27:
    x509_verify_build_chains((uint64_t)a1, v5, v14, v11, a3);
    if (!v11)
      goto LABEL_43;
LABEL_28:
    if (a1[4])
      goto LABEL_43;
    v11 = 0;
    v18 = (char *)*a1;
    *((_DWORD *)v18 + 43) = a1[13];
    if (*((_QWORD *)v18 + 20))
    {
      sk_pop_free((STACK *)a1[2], (void (__cdecl *)(void *))X509_free);
      v19 = X509_chain_up_ref((STACK *)(*a1)[20]);
      a1[2] = &v19->num;
      if (v19)
      {
        v11 = 0;
        a1[3] = (_QWORD *)vrev64_s32(*(int32x2_t *)((char *)*a1 + 172));
      }
      else
      {
        *((_DWORD *)a1 + 28) = 17;
        a1[13] = 0;
        v20 = (char *)*a1;
        if (!*a1)
          goto LABEL_48;
        *(_QWORD *)(v20 + 172) = 0x1100000000;
        *((_QWORD *)v20 + 23) = 0;
        v11 = 0;
        if (!(*((unsigned int (**)(_QWORD))v20 + 8))(0))
          goto LABEL_48;
      }
    }
  }
  if (sk_num((const STACK *)a1[5]) < 1)
    goto LABEL_27;
  v16 = 0;
  while (1)
  {
    v17 = sk_value((const STACK *)a1[5], v16);
    if (!X509_cmp((const X509 *)v17, (const X509 *)v5))
      break;
    if (++v16 >= sk_num((const STACK *)a1[5]))
      goto LABEL_27;
  }
LABEL_20:
  if (v11 && (*(_BYTE *)(v5 + 57) & 0x20) == 0)
  {
    x509_verify_build_chains((uint64_t)a1, v5, v14, v11, a3);
    goto LABEL_28;
  }
  if (!x509_verify_ctx_add_chain(a1, (uint64_t)v14, a3))
    goto LABEL_48;
LABEL_43:
  x509_verify_chain_free((uint64_t)v14);
  result = (uint64_t)a1[4];
  if (!*a1)
  {
    if (result)
    {
      *v13 = 0;
      return result;
    }
    if (!*v13)
    {
      result = 0;
      *v13 = 1;
      return result;
    }
    return 0;
  }
  if (result)
  {
    if (x509_verify_ctx_set_xsc_chain((uint64_t *)a1, *a1[1], 1, 1)
      && x509_vfy_callback_indicate_completion((uint64_t)*a1))
    {
      return 1;
    }
LABEL_7:
    if (!*((_DWORD *)a1 + 28))
      *((_DWORD *)a1 + 28) = 1;
    v8 = (char *)*a1;
    if (*a1)
    {
      v9 = *((_DWORD *)v8 + 44);
      if (!v9)
      {
        v9 = 1;
        *((_DWORD *)v8 + 44) = 1;
      }
      result = 0;
      *((_DWORD *)a1 + 28) = v9;
      return result;
    }
    return 0;
  }
  if (!x509_verify_ctx_restore_xsc_error((uint64_t *)a1))
    goto LABEL_7;
  v23 = (char *)*a1;
  if (!*((_DWORD *)*a1 + 44))
  {
    v24 = *v13;
    if (!*v13)
    {
      v24 = 1;
      *v13 = 1;
    }
    *((_DWORD *)v23 + 44) = v24;
  }
  return (*((int (**)(_QWORD))v23 + 8))(0);
}

uint64_t x509_verify_chain_append(uint64_t a1, X509 *a2, int *a3)
{
  uint64_t v6;
  _BOOL4 v7;
  uint64_t result;
  int v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  int v13;

  v13 = 1;
  v6 = *(_QWORD *)(a1 + 16);
  v7 = sk_num(*(const STACK **)a1) == 0;
  result = x509_constraints_extract_names(v6, (uint64_t)a2, v7, &v13);
  if (!(_DWORD)result)
  {
    v12 = v13;
LABEL_9:
    *a3 = v12;
    return result;
  }
  X509_up_ref((uint64_t)a2);
  if (!sk_push(*(STACK **)a1, (char *)a2))
  {
    X509_free(a2);
    result = 0;
    v12 = 17;
    goto LABEL_9;
  }
  v9 = sk_num(*(const STACK **)a1) - 1;
  v10 = *(_QWORD *)(a1 + 8);
  *(_DWORD *)(v10 + 4 * v9) = *a3;
  if (v9 >= 2)
  {
    v11 = v9 - 1;
    if (*(_DWORD *)(v10 + 4 * v11) == 20)
      *(_DWORD *)(v10 + 4 * v11) = 0;
  }
  return 1;
}

uint64_t x509_verify_ctx_add_chain(_QWORD *a1, uint64_t a2, const char *a3)
{
  char *v6;
  const STACK *v7;
  char *v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unsigned int v19;
  _BOOL4 v20;
  int v21;
  uint64_t v22;
  uint64_t result;
  uint64_t v24;
  int v25;
  uint64_t v26;
  char *v27;
  char *v28;
  size_t v29;
  int v30;
  uint64_t v31;
  int v32;
  _QWORD *v33;
  uint64_t v34;

  v6 = x509_verify_chain_last((const STACK **)a2);
  v7 = *(const STACK **)a2;
  if (*(_QWORD *)a2)
  {
    v8 = sk_value(v7, 0);
    v7 = *(const STACK **)a2;
  }
  else
  {
    v8 = 0;
  }
  v9 = sk_num(v7);
  if (v9)
    v10 = v9 - 1;
  else
    v10 = 0;
  if (a1[4] >= a1[9])
  {
    v21 = 22;
LABEL_22:
    *((_DWORD *)a1 + 28) = v21;
    a1[13] = v10;
    v22 = *a1;
    if (*a1)
    {
      *(_DWORD *)(v22 + 172) = v10;
      *(_DWORD *)(v22 + 176) = v21;
      *(_QWORD *)(v22 + 184) = v6;
      return (*(uint64_t (**)(_QWORD))(v22 + 64))(0);
    }
    return 0;
  }
  v11 = *(_QWORD *)(a2 + 8);
  if (*(_DWORD *)(v11 + 4 * v10) == 20)
    *(_DWORD *)(v11 + 4 * v10) = 0;
  v12 = *a1;
  if (*a1)
  {
    *(_DWORD *)(v12 + 172) = 0;
    *(_DWORD *)(v12 + 176) = 0;
    v20 = x509_verify_ctx_set_xsc_chain(a1, a2, 0, 1)
       && x509_vfy_check_trust(*a1) == 1
       && x509_vfy_check_chain_extensions(*a1)
       && X509v3_asid_validate_path(*a1)
       && X509v3_addr_validate_path(*a1)
       && x509_vfy_check_security_level(*a1)
       && (x509_constraints_chain(*(const STACK **)(*a1 + 160), (int *)(*a1 + 176), (int *)(*a1 + 172))|| (v13 = sk_value(*(const STACK **)(*a1 + 160), v10), v14 = *a1, v15 = *(int *)(*a1 + 172), *((_DWORD *)a1 + 28) = *(_DWORD *)(*a1 + 176), a1[13] = v15, *(_QWORD *)(v14 + 184) = v13, (*(unsigned int (**)(_QWORD))(v14 + 64))(0)))&& x509_vfy_check_revocation(*a1)&& x509_vfy_check_policy(*a1, v16, v17, v18, v19) != 0;
    v24 = *a1;
    v25 = *(_DWORD *)(*a1 + 176);
    if (v25)
    {
      v26 = *(unsigned int *)(v24 + 172);
      if (v26 > 0x1F)
        return 0;
      *(_DWORD *)(*(_QWORD *)(a2 + 8) + 4 * v26) = v25;
      a1[13] = *(int *)(v24 + 172);
    }
    if (!v20)
      return 0;
  }
  result = x509_verify_cert_valid(a1, (uint64_t)v8, 0);
  if (!(_DWORD)result)
    return result;
  if (!a3)
  {
    if (*a1)
    {
      result = x509_vfy_check_id();
      if (!(_DWORD)result)
      {
        *((_DWORD *)a1 + 28) = *(_DWORD *)(*a1 + 176);
        return result;
      }
    }
    goto LABEL_47;
  }
  v27 = strdup(a3);
  v28 = v27;
  if (v27)
  {
    v29 = strlen(v27);
    if (v29)
    {
      if (*v28 == 91 && v28[v29 - 1] == 93)
      {
        v28[v29 - 1] = 0;
        if ((int)X509_check_ip_asc((X509 *)v8, v28 + 1, 0) < 1)
        {
          v30 = 64;
          goto LABEL_45;
        }
        goto LABEL_42;
      }
      if ((int)X509_check_host((X509 *)v8, v28, v29, 32 * (*a1 == 0), 0) >= 1)
      {
LABEL_42:
        free(v28);
LABEL_47:
        if (!a1[13])
        {
          v32 = *((_DWORD *)a1 + 28);
          if (v32 != 20)
            **(_DWORD **)(a2 + 8) = v32;
        }
        v33 = x509_verify_chain_dup(a2);
        v34 = a1[4];
        *(_QWORD *)(a1[1] + 8 * v34) = v33;
        if (v33)
        {
          a1[4] = v34 + 1;
          *((_DWORD *)a1 + 28) = 0;
          a1[13] = v10;
          return 1;
        }
        v21 = 17;
        goto LABEL_22;
      }
      v30 = 62;
    }
    else
    {
      v30 = 1;
    }
  }
  else
  {
    v30 = 17;
  }
LABEL_45:
  *((_DWORD *)a1 + 28) = v30;
  free(v28);
  a1[13] = 0;
  v31 = *a1;
  if (*a1)
  {
    *(_DWORD *)(v31 + 172) = 0;
    *(_DWORD *)(v31 + 176) = v30;
    *(_QWORD *)(v31 + 184) = v8;
    result = (*(uint64_t (**)(_QWORD))(v31 + 64))(0);
    if (!(_DWORD)result)
      return result;
    goto LABEL_47;
  }
  return 0;
}

uint64_t x509_verify_build_chains(uint64_t result, uint64_t a2, const STACK **a3, uint64_t a4, const char *a5)
{
  uint64_t v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  int v17;
  int v18;
  char *v19;
  int v20;
  uint64_t v21;
  int v22;
  uint64_t v23;
  X509 *a;

  v9 = result;
  if (*(_QWORD *)result && *(_QWORD *)(result + 32))
    return result;
  result = sk_num(*a3);
  v10 = result - ((int)result > 0);
  if (*(_QWORD *)(v9 + 80) <= (unint64_t)v10)
  {
    *(_DWORD *)(v9 + 112) = 22;
    *(_QWORD *)(v9 + 104) = v10;
    v11 = *(_QWORD *)v9;
    if (!*(_QWORD *)v9)
      return result;
    *(_DWORD *)(v11 + 172) = v10;
    *(_DWORD *)(v11 + 176) = 22;
    *(_QWORD *)(v11 + 184) = a2;
    result = (*(uint64_t (**)(_QWORD))(v11 + 64))(0);
    if (!(_DWORD)result)
      return result;
  }
  v12 = *(_QWORD *)(v9 + 32);
  *(_DWORD *)(v9 + 112) = 20;
  *(_QWORD *)(v9 + 104) = v10;
  v13 = *(_DWORD *)(v9 + 24);
  if (v13)
    *(_DWORD *)(v9 + 112) = v13;
  v14 = *(int *)(v9 + 28);
  if ((_DWORD)v14)
    *(_QWORD *)(v9 + 104) = v14;
  a = 0;
  v15 = *(_QWORD *)v9;
  if (!*(_QWORD *)v9)
  {
    if (sk_num(*(const STACK **)(v9 + 40)) < 1)
    {
      v19 = 0;
    }
    else
    {
      v18 = 0;
      do
      {
        v19 = sk_value(*(const STACK **)(v9 + 40), v18);
        if (x509_verify_potential_parent((_QWORD *)v9, (X509 *)v19, (X509 *)a2))
        {
          if ((_DWORD)a4)
            v20 = (*((_DWORD *)v19 + 14) >> 13) & 1;
          else
            v20 = 1;
          x509_verify_consider_candidate(v9, a2, v20, (uint64_t)v19, a3, a4, a5);
        }
        ++v18;
      }
      while (v18 < sk_num(*(const STACK **)(v9 + 40)));
    }
    a = (X509 *)v19;
    goto LABEL_37;
  }
  if ((*(_BYTE *)(a2 + 57) & 0x20) != 0)
  {
    if (v10)
      v16 = 19;
    else
      v16 = 18;
    *(_DWORD *)(v9 + 112) = v16;
  }
  result = (*(uint64_t (**)(X509 **))(v15 + 72))(&a);
  if ((result & 0x80000000) == 0)
  {
    if ((_DWORD)result)
    {
      if (x509_verify_potential_parent((_QWORD *)v9, a, (X509 *)a2))
      {
        if ((_DWORD)a4)
          v17 = (LODWORD(a->ex_pathlen) >> 13) & 1;
        else
          v17 = 1;
        x509_verify_consider_candidate(v9, a2, v17, (uint64_t)a, a3, a4, a5);
      }
      X509_free(a);
    }
LABEL_37:
    result = *(_QWORD *)(v9 + 48);
    if (result)
    {
      result = sk_num((const STACK *)result);
      if ((int)result >= 1)
      {
        v22 = 0;
        do
        {
          a = (X509 *)sk_value(*(const STACK **)(v9 + 48), v22);
          if (x509_verify_potential_parent((_QWORD *)v9, a, (X509 *)a2))
            x509_verify_consider_candidate(v9, a2, 0, (uint64_t)a, a3, a4, a5);
          ++v22;
          result = sk_num(*(const STACK **)(v9 + 48));
        }
        while (v22 < (int)result);
      }
    }
    if (*(_QWORD *)(v9 + 32) <= (unint64_t)(int)v12)
    {
      if (*(_QWORD *)(v9 + 104) == v10)
        return x509_verify_ctx_set_xsc_chain((uint64_t *)v9, (uint64_t)a3, 0, 0);
    }
    else
    {
      v23 = *(_QWORD *)v9;
      if (*(_QWORD *)v9)
      {
        *(_DWORD *)(v23 + 172) = v10;
        *(_DWORD *)(v23 + 176) = 0;
        *(_QWORD *)(v23 + 184) = a2;
      }
    }
    return result;
  }
  *(_DWORD *)(v9 + 112) = 66;
  *(_QWORD *)(v9 + 104) = v10;
  v21 = *(_QWORD *)v9;
  if (*(_QWORD *)v9)
  {
    *(_DWORD *)(v21 + 172) = v10;
    *(_DWORD *)(v21 + 176) = 66;
    *(_QWORD *)(v21 + 184) = a2;
    return (*(uint64_t (**)(_QWORD))(v21 + 64))(0);
  }
  return result;
}

uint64_t x509_verify_ctx_set_xsc_chain(uint64_t *a1, uint64_t a2, int a3, int a4)
{
  int v8;
  BOOL v9;
  int v10;
  uint64_t v11;
  STACK *v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  uint64_t v17;

  if (*a1)
  {
    v8 = sk_num(*(const STACK **)a2);
    if (a4)
      v9 = v8 == 0;
    else
      v9 = 1;
    v10 = !v9;
    v11 = *a1;
    *(_DWORD *)(v11 + 156) = v8 - v10;
    sk_pop_free(*(STACK **)(v11 + 160), (void (__cdecl *)(void *))X509_free);
    v12 = X509_chain_up_ref(*(STACK **)a2);
    v13 = *a1;
    *(_QWORD *)(*a1 + 160) = v12;
    if (!v12)
    {
      *((_DWORD *)a1 + 28) = 17;
      a1[13] = 0;
      *(_QWORD *)(v13 + 172) = 0x1100000000;
      *(_QWORD *)(v13 + 184) = 0;
      return (*(uint64_t (**)(void))(v13 + 64))();
    }
    if (a3)
    {
      *(_DWORD *)(v13 + 172) = 0;
      *(_DWORD *)(v13 + 176) = 0;
      if (sk_num(*(const STACK **)a2) >= 1)
      {
        v14 = 0;
        while (1)
        {
          v15 = *(_DWORD *)(*(_QWORD *)(a2 + 8) + 4 * v14);
          if (v15)
            break;
          if (++v14 >= sk_num(*(const STACK **)a2))
            return 1;
        }
        v17 = *a1;
        *(_DWORD *)(v17 + 172) = v14;
        *(_DWORD *)(v17 + 176) = v15;
      }
    }
  }
  return 1;
}

uint64_t x509_verify_ctx_restore_xsc_error(uint64_t *a1)
{
  STACK *v3;
  uint64_t v4;

  if (!*a1 || a1[4] || !a1[2])
    return 1;
  sk_pop_free(*(STACK **)(*a1 + 160), (void (__cdecl *)(void *))X509_free);
  v3 = X509_chain_up_ref((STACK *)a1[2]);
  v4 = *a1;
  *(_QWORD *)(*a1 + 160) = v3;
  if (v3)
  {
    *(int32x2_t *)(v4 + 172) = vrev64_s32((int32x2_t)a1[3]);
    return 1;
  }
  *((_DWORD *)a1 + 28) = 17;
  a1[13] = 0;
  *(_QWORD *)(v4 + 172) = 0x1100000000;
  *(_QWORD *)(v4 + 184) = 0;
  return (*(uint64_t (**)(void))(v4 + 64))();
}

char *x509_verify_chain_last(const STACK **a1)
{
  const STACK *v2;
  int v3;

  v2 = *a1;
  if (v2 && (v3 = sk_num(v2), v3 >= 1))
    return sk_value(*a1, v3 - 1);
  else
    return 0;
}

uint64_t x509_verify_cert_valid(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  _BOOL4 v6;
  uint64_t v7;
  char *v8;
  uint64_t v9;
  uint64_t v10;
  time_t v11;
  int v12;
  time_t v13;
  int v14;
  uint64_t result;
  time_t v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  _QWORD *v20;
  _QWORD *v21;
  int v22;
  uint64_t v23;
  int v24;

  v6 = a3 != 0;
  if (a3)
    v7 = sk_num(*(const STACK **)a3);
  else
    v7 = 0;
  if (!x509v3_cache_extensions(a2))
  {
    v12 = 1;
    goto LABEL_24;
  }
  if (!*a1)
  {
    if ((*(_QWORD *)(a2 + 56) & 0x200) != 0)
    {
      v12 = 34;
    }
    else if (a3 && (*(_QWORD *)(a2 + 56) & 0x11) == 0x10)
    {
      v12 = 24;
    }
    else
    {
      v18 = *((_DWORD *)a1 + 16);
      if (v18 < 1 || !X509_check_purpose((X509 *)a2, v18, v6))
        goto LABEL_6;
      v12 = 26;
    }
LABEL_24:
    result = 0;
    *((_DWORD *)a1 + 28) = v12;
    return result;
  }
LABEL_6:
  if (!a3)
    goto LABEL_52;
  v8 = x509_verify_chain_last((const STACK **)a3);
  if (!v8 || X509_check_issued((X509 *)v8, (X509 *)a2))
    goto LABEL_52;
  *((_DWORD *)a1 + 28) = 29;
  a1[13] = v7;
  v17 = *a1;
  if (!*a1)
    return 0;
  *(_DWORD *)(v17 + 172) = v7;
  *(_DWORD *)(v17 + 176) = 29;
  *(_QWORD *)(v17 + 184) = a2;
  result = (*(uint64_t (**)(_QWORD))(v17 + 64))(0);
  if ((_DWORD)result)
  {
LABEL_52:
    if (*a1)
    {
      v9 = *(_QWORD *)(*a1 + 48);
      v10 = *(_QWORD *)(v9 + 24);
      if ((v10 & 2) != 0)
      {
        v11 = *(_QWORD *)(v9 + 8);
        a1[7] = v9 + 8;
LABEL_19:
        v13 = *(_QWORD *)(a2 + 208);
        if (v13 == -1)
        {
          v14 = 13;
        }
        else if (v11 >= v13)
        {
          v16 = *(_QWORD *)(a2 + 216);
          if (v16 == -1)
          {
            v14 = 14;
          }
          else
          {
            if (v11 <= v16)
              goto LABEL_37;
            v14 = 10;
          }
        }
        else
        {
          v14 = 9;
        }
        *((_DWORD *)a1 + 28) = v14;
        a1[13] = v7;
        v19 = *a1;
        if (*a1)
        {
          *(_DWORD *)(v19 + 172) = v7;
          *(_DWORD *)(v19 + 176) = v14;
          *(_QWORD *)(v19 + 184) = a2;
          result = (*(uint64_t (**)(_QWORD))(v19 + 64))(0);
          if (!(_DWORD)result)
            return result;
LABEL_37:
          v24 = 1;
          if (!a3 || !*(_QWORD *)(a2 + 120))
            return 1;
          v20 = x509_constraints_names_new(512);
          if (v20)
          {
            v21 = x509_constraints_names_new(512);
            if (v21)
            {
              if (x509_constraints_extract_constraints(a2, (uint64_t)v20, (uint64_t)v21, &v24)
                && x509_constraints_check(*(_QWORD **)(a3 + 16), (uint64_t)v20, (uint64_t)v21, &v24))
              {
                x509_constraints_names_free(v21);
                x509_constraints_names_free(v20);
                return 1;
              }
              goto LABEL_46;
            }
          }
          else
          {
            v21 = 0;
          }
          v24 = 17;
LABEL_46:
          *((_DWORD *)a1 + 28) = v24;
          x509_constraints_names_free(v21);
          x509_constraints_names_free(v20);
          v22 = *((_DWORD *)a1 + 28);
          a1[13] = v7;
          v23 = *a1;
          if (*a1)
          {
            *(_DWORD *)(v23 + 172) = v7;
            *(_DWORD *)(v23 + 176) = v22;
            *(_QWORD *)(v23 + 184) = a2;
            result = (*(uint64_t (**)(_QWORD))(v23 + 64))(0);
            if (!(_DWORD)result)
              return result;
            return 1;
          }
        }
        return 0;
      }
      if ((v10 & 0x200000) != 0)
        goto LABEL_37;
    }
    a1[7] = 0;
    v11 = time(0);
    goto LABEL_19;
  }
  return result;
}

_QWORD *x509_verify_chain_dup(uint64_t a1)
{
  _QWORD *v2;
  STACK *v3;
  _OWORD *v4;
  __int128 *v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  void *v12;

  v2 = malloc_type_calloc(1uLL, 0x18uLL, 0x30040275E93A9uLL);
  if (!v2)
    goto LABEL_5;
  v3 = X509_chain_up_ref(*(STACK **)a1);
  *v2 = v3;
  if (!v3)
    goto LABEL_5;
  v4 = malloc_type_calloc(0x20uLL, 4uLL, 0x100004052888210uLL);
  v2[1] = v4;
  if (!v4)
    goto LABEL_5;
  v5 = *(__int128 **)(a1 + 8);
  v6 = *v5;
  v7 = v5[1];
  v8 = v5[3];
  v4[2] = v5[2];
  v4[3] = v8;
  *v4 = v6;
  v4[1] = v7;
  v9 = v5[4];
  v10 = v5[5];
  v11 = v5[7];
  v4[6] = v5[6];
  v4[7] = v11;
  v4[4] = v9;
  v4[5] = v10;
  v12 = x509_constraints_names_dup(*(_QWORD **)(a1 + 16));
  v2[2] = v12;
  if (!v12)
  {
LABEL_5:
    x509_verify_chain_free((uint64_t)v2);
    return 0;
  }
  return v2;
}

uint64_t x509_verify_potential_parent(_QWORD *a1, X509 *a2, X509 *a3)
{
  uint64_t result;

  result = x509v3_cache_extensions((uint64_t)a2);
  if ((_DWORD)result)
  {
    if (*a1)
      return (*(uint64_t (**)(_QWORD, X509 *, X509 *))(*a1 + 80))(*a1, a3, a2);
    else
      return X509_check_issued(a3, a2) != 0;
  }
  return result;
}

void x509_verify_consider_candidate(uint64_t a1, uint64_t a2, int a3, uint64_t a4, const STACK **a5, uint64_t a6, const char *a7)
{
  int v14;
  int v15;
  char *v16;
  unint64_t v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  unsigned int v22;
  EVP_PKEY *pubkey;
  EVP_PKEY *v24;
  int v25;
  uint64_t v26;
  int v27;
  uint64_t v28;
  _QWORD *v29;
  uint64_t v30;
  int v31;
  uint64_t v32;
  const char *v33;
  int *v34;
  int v35;

  v14 = sk_num(*a5);
  if (sk_num(*a5) < 1)
  {
LABEL_5:
    v17 = *(_QWORD *)(a1 + 96);
    *(_QWORD *)(a1 + 96) = v17 + 1;
    if (v17 >= 0x101)
    {
      v18 = v14;
      v19 = 22;
      goto LABEL_7;
    }
    v35 = a3;
    v21 = a6;
    v34 = (int *)(a1 + 112);
    v22 = x509_issuer_cache_find(a4 + 144, a2 + 144);
    if ((v22 & 0x80000000) != 0)
    {
      v33 = a7;
      pubkey = X509_get_pubkey((X509 *)a4);
      if (!pubkey)
      {
        v25 = 6;
        *v34 = 6;
        v26 = v21;
        v27 = v35;
        goto LABEL_18;
      }
      v24 = pubkey;
      if (X509_verify((X509 *)a2, pubkey) <= 0)
      {
        v22 = 0;
        *v34 = 7;
      }
      else
      {
        v22 = 1;
      }
      x509_issuer_cache_add((__int128 *)(a4 + 144), (__int128 *)(a2 + 144), v22);
      EVP_PKEY_free(v24);
      a7 = v33;
    }
    v26 = v21;
    v27 = v35;
    if (v22)
    {
LABEL_20:
      if (!x509_verify_cert_valid((uint64_t *)a1, a4, (uint64_t)a5))
        return;
      v29 = x509_verify_chain_dup((uint64_t)a5);
      if (v29)
      {
        v30 = (uint64_t)v29;
        if (x509_verify_chain_append((uint64_t)v29, (X509 *)a4, v34))
        {
          if (v27)
          {
            if (x509_verify_ctx_set_xsc_chain((uint64_t *)a1, v30, 0, 1))
              x509_verify_ctx_add_chain((_QWORD *)a1, v30, a7);
          }
          else
          {
            x509_verify_build_chains(a1, a4, v30, v26, a7);
          }
        }
        else
        {
          v31 = *(_DWORD *)(a1 + 112);
          *(_QWORD *)(a1 + 104) = v14;
          v32 = *(_QWORD *)a1;
          if (*(_QWORD *)a1)
          {
            *(_DWORD *)(v32 + 172) = v14;
            *(_DWORD *)(v32 + 176) = v31;
            *(_QWORD *)(v32 + 184) = a4;
            (*(void (**)(_QWORD))(v32 + 64))(0);
          }
        }
        x509_verify_chain_free(v30);
        return;
      }
      v18 = v14;
      v19 = 17;
LABEL_7:
      *(_DWORD *)(a1 + 112) = v19;
      *(_QWORD *)(a1 + 104) = v18;
      v20 = *(_QWORD *)a1;
      if (*(_QWORD *)a1)
      {
        *(_DWORD *)(v20 + 172) = v14;
        *(_DWORD *)(v20 + 176) = v19;
        *(_QWORD *)(v20 + 184) = a4;
        (*(void (**)(_QWORD))(v20 + 64))(0);
      }
      return;
    }
    v25 = *v34;
LABEL_18:
    *(_QWORD *)(a1 + 104) = v14;
    v28 = *(_QWORD *)a1;
    if (!*(_QWORD *)a1)
      return;
    *(_DWORD *)(v28 + 172) = v14;
    *(_DWORD *)(v28 + 176) = v25;
    *(_QWORD *)(v28 + 184) = a4;
    if (!(*(unsigned int (**)(_QWORD))(v28 + 64))(0))
      return;
    goto LABEL_20;
  }
  v15 = 0;
  while (1)
  {
    v16 = sk_value(*a5, v15);
    if (!X509_cmp((const X509 *)v16, (const X509 *)a4))
      break;
    if (++v15 >= sk_num(*a5))
      goto LABEL_5;
  }
}

uint64_t Gost2814789_set_sbox(uint64_t a1, int a2)
{
  uint64_t v2;
  int v3;
  uint64_t v4;
  uint64_t v6;
  unsigned __int8 *v7;
  unsigned __int8 *v8;
  unint64_t v9;

  v2 = 0;
  v3 = 824;
  while (v3 != a2)
  {
    v3 = *(_DWORD *)&gost_cipher_list[v2 + 24];
    v2 += 24;
    if (v2 == 192)
      return 0;
  }
  v4 = *(_QWORD *)&gost_cipher_list[v2 + 8];
  *(_BYTE *)(a1 + 4132) = *(_BYTE *)(a1 + 4132) & 0xFE | gost_cipher_list[v2 + 16] & 1;
  v6 = -256;
  do
  {
    v7 = (unsigned __int8 *)(v4 + ((v6 + 256) >> 4));
    v8 = (unsigned __int8 *)(v4 + ((v6 + 256) & 0xF));
    *(_DWORD *)(a1 + 32) = ((v8[16] << 24) | (*v7 << 28)) >> 21;
    HIDWORD(v9) = (v8[48] << 16) | (v7[32] << 20);
    LODWORD(v9) = HIDWORD(v9);
    *(_DWORD *)(a1 + 1056) = v9 >> 21;
    *(_DWORD *)(a1 + 2080) = (v8[80] << 19) | (v7[64] << 23);
    *(_DWORD *)(a1 + 3104) = (v8[112] << 11) | (v7[96] << 15);
    a1 += 4;
  }
  while (!__CFADD__(v6++, 1));
  return 1;
}

uint64_t Gost2814789_set_key(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t i;
  int v4;
  int v5;
  int v6;

  if (a3 != 256)
    return 0;
  for (i = 0; i != 32; i += 4)
  {
    v4 = *(unsigned __int8 *)(a2 + i);
    *(_DWORD *)(a1 + i) = v4;
    v5 = v4 | (*(unsigned __int8 *)(a2 + i + 1) << 8);
    *(_DWORD *)(a1 + i) = v5;
    v6 = v5 | (*(unsigned __int8 *)(a2 + i + 2) << 16);
    *(_DWORD *)(a1 + i) = v6;
    *(_DWORD *)(a1 + i) = v6 | (*(unsigned __int8 *)(a2 + i + 3) << 24);
  }
  *(_DWORD *)(a1 + 4128) = 0;
  return 1;
}

uint64_t Gost2814789_cryptopro_key_mesh(int *a1)
{
  uint64_t result;
  uint64_t i;
  int v4[2];
  int v5;
  int v6;
  int v7;
  uint64_t v8;

  v8 = *MEMORY[0x24BDAC8D0];
  Gost2814789_decrypt(CryptoProKeyMeshingKey, v4, a1);
  Gost2814789_decrypt(&CryptoProKeyMeshingKey[2], &v5, a1);
  Gost2814789_decrypt(&CryptoProKeyMeshingKey[4], &v6, a1);
  result = Gost2814789_decrypt(&CryptoProKeyMeshingKey[6], &v7, a1);
  for (i = 0; i != 8; ++i)
    a1[i] = v4[i];
  a1[1032] = 0;
  return result;
}

STACK *__cdecl i2v_GENERAL_NAMES(X509V3_EXT_METHOD *method, GENERAL_NAMES *gen, STACK *extlist)
{
  STACK *v4;
  STACK *v5;
  int v6;
  char *v7;
  STACK *v8;

  if (extlist)
  {
    v4 = extlist;
    v5 = 0;
  }
  else
  {
    v4 = sk_new_null();
    v5 = v4;
    if (!v4)
      return v4;
  }
  if (sk_num(gen) >= 1)
  {
    v6 = 0;
    while (1)
    {
      v7 = sk_value(gen, v6);
      if (!v7)
        break;
      v8 = i2v_GENERAL_NAME((X509V3_EXT_METHOD *)v7, (GENERAL_NAME *)v7, v4);
      if (!v8)
        break;
      v4 = v8;
      if (++v6 >= sk_num(gen))
        return v4;
    }
    sk_pop_free(v5, (void (__cdecl *)(void *))X509V3_conf_free);
    return 0;
  }
  return v4;
}

STACK *v2i_subject_alt(X509V3_EXT_METHOD *a1, X509V3_CTX *a2, const STACK *a3)
{
  STACK *v6;
  int v7;
  CONF_VALUE *v8;
  char *v9;
  GENERAL_NAME *v10;
  const char *value;
  uint64_t v12;
  STACK *v13;
  int v14;
  const char *v15;

  v6 = sk_new_null();
  if (!v6)
  {
    ERR_put_error(34, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_alt.c", 402);
    return v6;
  }
  if (sk_num(a3) >= 1)
  {
    v7 = 0;
    while (1)
    {
      v8 = (CONF_VALUE *)sk_value(a3, v7);
      if (!name_cmp(v8->name, "email"))
      {
        value = v8->value;
        if (value)
        {
          if (!strcmp(value, "copy"))
            break;
        }
      }
      if (!name_cmp(v8->name, "email"))
      {
        v15 = v8->value;
        if (v15)
        {
          if (!strcmp(v15, "move"))
          {
            v12 = (uint64_t)a2;
            v13 = v6;
            v14 = 1;
LABEL_16:
            if (!copy_email(v12, v13, v14))
              goto LABEL_20;
            goto LABEL_8;
          }
        }
      }
      v9 = (char *)v2i_GENERAL_NAME_ex(0, a1, a2, v8, 0);
      if (!v9)
        goto LABEL_20;
      v10 = (GENERAL_NAME *)v9;
      if (!sk_push(v6, v9))
      {
        GENERAL_NAME_free(v10);
LABEL_20:
        sk_pop_free(v6, (void (__cdecl *)(void *))GENERAL_NAME_free);
        return 0;
      }
LABEL_8:
      if (++v7 >= sk_num(a3))
        return v6;
    }
    v12 = (uint64_t)a2;
    v13 = v6;
    v14 = 0;
    goto LABEL_16;
  }
  return v6;
}

STACK *v2i_issuer_alt(X509V3_EXT_METHOD *a1, X509V3_CTX *a2, const STACK *a3)
{
  STACK *v6;
  int i;
  CONF_VALUE *v8;
  char *v9;
  GENERAL_NAME *v10;
  const char *value;
  X509 *issuer_cert;
  int ext_by_NID;
  X509_EXTENSION *ext;
  const STACK *v15;
  STACK *v16;
  int v17;
  char *v18;
  int v19;
  int v20;

  v6 = sk_new_null();
  if (!v6)
  {
    ERR_put_error(34, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_alt.c", 326);
    return v6;
  }
  if (sk_num(a3) >= 1)
  {
    for (i = 0; i < sk_num(a3); ++i)
    {
      v8 = (CONF_VALUE *)sk_value(a3, i);
      if (!name_cmp(v8->name, "issuer") && (value = v8->value) != 0 && !strcmp(value, "copy"))
      {
        if (!a2)
          goto LABEL_25;
        if (a2->flags != 1)
        {
          issuer_cert = a2->issuer_cert;
          if (!issuer_cert)
          {
LABEL_25:
            v19 = 127;
            v20 = 365;
            goto LABEL_27;
          }
          ext_by_NID = X509_get_ext_by_NID(issuer_cert, 85, -1);
          if ((ext_by_NID & 0x80000000) == 0)
          {
            ext = X509_get_ext(a2->issuer_cert, ext_by_NID);
            if (!ext || (v15 = (const STACK *)X509V3_EXT_d2i(ext)) == 0)
            {
              v19 = 126;
              v20 = 373;
              goto LABEL_27;
            }
            v16 = (STACK *)v15;
            if (sk_num(v15) >= 1)
            {
              v17 = 0;
              while (1)
              {
                v18 = sk_value(v16, v17);
                if (!sk_push(v6, v18))
                  break;
                if (++v17 >= sk_num(v16))
                  goto LABEL_21;
              }
              v19 = 65;
              v20 = 380;
LABEL_27:
              ERR_put_error(34, 4095, v19, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_alt.c", v20);
LABEL_28:
              sk_pop_free(v6, (void (__cdecl *)(void *))GENERAL_NAME_free);
              return 0;
            }
LABEL_21:
            sk_free(v16);
          }
        }
      }
      else
      {
        v9 = (char *)v2i_GENERAL_NAME_ex(0, a1, a2, v8, 0);
        if (!v9)
          goto LABEL_28;
        v10 = (GENERAL_NAME *)v9;
        if (!sk_push(v6, v9))
        {
          GENERAL_NAME_free(v10);
          goto LABEL_28;
        }
      }
    }
  }
  return v6;
}

STACK *__cdecl i2v_GENERAL_NAME(X509V3_EXT_METHOD *method, GENERAL_NAME *gen, STACK *ret)
{
  STACK *v4;
  STACK *result;
  const char *v6;
  const unsigned __int8 *v7;
  const char *v8;
  char *v9;
  char *ptr;
  unsigned __int8 *v11;
  int v12;
  uint64_t v13;
  char __str[5];
  STACK *extlist;
  char buf[256];
  uint64_t v17;

  v17 = *MEMORY[0x24BDAC8D0];
  extlist = ret;
  if (ret)
  {
    v4 = 0;
  }
  else
  {
    result = sk_new_null();
    v4 = result;
    extlist = result;
    if (!result)
      return result;
  }
  switch(gen->type)
  {
    case 0:
      v6 = "othername";
      goto LABEL_12;
    case 1:
      v7 = (const unsigned __int8 *)*((_QWORD *)gen->d.ptr + 1);
      v8 = "email";
      goto LABEL_14;
    case 2:
      v7 = (const unsigned __int8 *)*((_QWORD *)gen->d.ptr + 1);
      v8 = "DNS";
      goto LABEL_14;
    case 3:
      v6 = "X400Name";
      goto LABEL_12;
    case 4:
      if (!X509_NAME_oneline(gen->d.directoryName, buf, 256))
        goto LABEL_27;
      v6 = "DirName";
      goto LABEL_24;
    case 5:
      v6 = "EdiPartyName";
LABEL_12:
      v9 = "<unsupported>";
      goto LABEL_25;
    case 6:
      v7 = (const unsigned __int8 *)*((_QWORD *)gen->d.ptr + 1);
      v8 = "URI";
LABEL_14:
      if (!X509V3_add_value_uchar(v8, v7, &extlist))
        goto LABEL_27;
      goto LABEL_26;
    case 7:
      ptr = gen->d.ptr;
      v11 = (unsigned __int8 *)*((_QWORD *)ptr + 1);
      v12 = *(_DWORD *)ptr;
      if (v12 == 16)
      {
        buf[0] = 0;
        snprintf(__str, 5uLL, "%X", __rev16(*(unsigned __int16 *)v11));
        __strlcat_chk();
        v13 = 0;
        do
        {
          __strlcat_chk();
          snprintf(__str, 5uLL, "%X", __rev16(*(unsigned __int16 *)&v11[v13 + 2]));
          __strlcat_chk();
          v13 += 2;
        }
        while ((_DWORD)v13 != 14);
      }
      else
      {
        if (v12 != 4)
        {
          v6 = "IP Address";
          v9 = "<invalid>";
          goto LABEL_25;
        }
        snprintf(buf, 0x100uLL, "%d.%d.%d.%d", *v11, v11[1], v11[2], v11[3]);
      }
      v6 = "IP Address";
LABEL_24:
      v9 = buf;
LABEL_25:
      if (X509V3_add_value(v6, v9, &extlist))
      {
LABEL_26:
        result = extlist;
      }
      else
      {
LABEL_27:
        sk_pop_free(v4, (void (__cdecl *)(void *))X509V3_conf_free);
        result = 0;
      }
      break;
    case 8:
      if (!i2t_ASN1_OBJECT(buf, 256, gen->d.registeredID))
        goto LABEL_27;
      v6 = "Registered ID";
      goto LABEL_24;
    default:
      goto LABEL_26;
  }
  return result;
}

int GENERAL_NAME_print(BIO *out, GENERAL_NAME *gen)
{
  char *ptr;
  uint64_t v5;
  int v6;
  uint64_t v7;

  switch(gen->type)
  {
    case 0:
      BIO_printf(out, "othername:<unsupported>");
      break;
    case 1:
      BIO_printf(out, "email:%.*s");
      break;
    case 2:
      BIO_printf(out, "DNS:%.*s");
      break;
    case 3:
      BIO_printf(out, "X400Name:<unsupported>");
      break;
    case 4:
      BIO_printf(out, "DirName: ");
      X509_NAME_print_ex(out, gen->d.directoryName, 0, 0x82031FuLL);
      break;
    case 5:
      BIO_printf(out, "EdiPartyName:<unsupported>");
      break;
    case 6:
      BIO_printf(out, "URI:%.*s");
      break;
    case 7:
      ptr = gen->d.ptr;
      v5 = *((_QWORD *)ptr + 1);
      v6 = *(_DWORD *)ptr;
      if (v6 == 16)
      {
        BIO_printf(out, "IP Address");
        v7 = 0;
        do
        {
          BIO_printf(out, ":%X", __rev16(*(unsigned __int16 *)(v5 + v7)));
          v7 += 2;
        }
        while ((_DWORD)v7 != 16);
        BIO_puts(out, "\n");
      }
      else if (v6 == 4)
      {
        BIO_printf(out, "IP Address:%d.%d.%d.%d");
      }
      else
      {
        BIO_printf(out, "IP Address:<invalid>");
      }
      break;
    case 8:
      BIO_printf(out, "Registered ID");
      i2a_ASN1_OBJECT(out, gen->d.registeredID);
      break;
    default:
      return 1;
  }
  return 1;
}

GENERAL_NAMES *__cdecl v2i_GENERAL_NAMES(X509V3_EXT_METHOD *method, X509V3_CTX *ctx, STACK *nval)
{
  STACK *v6;
  int v7;
  char *v8;
  char *v9;
  GENERAL_NAME *v10;

  v6 = sk_new_null();
  if (v6)
  {
    if (sk_num(nval) >= 1)
    {
      v7 = 0;
      while (1)
      {
        v8 = sk_value(nval, v7);
        v9 = (char *)v2i_GENERAL_NAME_ex(0, method, ctx, (CONF_VALUE *)v8, 0);
        if (!v9)
          break;
        v10 = (GENERAL_NAME *)v9;
        if (!sk_push(v6, v9))
        {
          GENERAL_NAME_free(v10);
          break;
        }
        if (++v7 >= sk_num(nval))
          return v6;
      }
      sk_pop_free(v6, (void (__cdecl *)(void *))GENERAL_NAME_free);
      return 0;
    }
  }
  else
  {
    ERR_put_error(34, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_alt.c", 500);
  }
  return v6;
}

GENERAL_NAME *__cdecl v2i_GENERAL_NAME(X509V3_EXT_METHOD *method, X509V3_CTX *ctx, CONF_VALUE *cnf)
{
  return v2i_GENERAL_NAME_ex(0, method, ctx, cnf, 0);
}

GENERAL_NAME *__cdecl v2i_GENERAL_NAME_ex(GENERAL_NAME *out, X509V3_EXT_METHOD *method, X509V3_CTX *ctx, CONF_VALUE *cnf, int is_nc)
{
  char *value;
  char *name;
  int v10;
  GENERAL_NAME *v11;
  int v12;
  GENERAL_NAME *v13;
  int v15;
  int v16;
  void **v17;
  _QWORD v18[3];
  unint64_t v19;
  uint64_t v20;

  v20 = 0;
  v19 = 0;
  value = cnf->value;
  if (!value)
  {
    ERR_put_error(34, 4095, 124, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_alt.c", 634);
    return 0;
  }
  name = cnf->name;
  if (name_cmp(name, "email"))
  {
    if (name_cmp(name, "URI"))
    {
      if (name_cmp(name, "DNS"))
      {
        if (name_cmp(name, "RID"))
        {
          if (name_cmp(name, "IP"))
          {
            if (name_cmp(name, "dirName"))
            {
              if (name_cmp(name, "otherName"))
              {
                ERR_put_error(34, 4095, 117, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_alt.c", 653);
                ERR_asprintf_error_data("name=%s", name);
                return 0;
              }
              v12 = 0;
            }
            else
            {
              v12 = 4;
            }
          }
          else
          {
            v12 = 7;
          }
        }
        else
        {
          v12 = 8;
        }
      }
      else
      {
        v12 = 2;
      }
    }
    else
    {
      v12 = 6;
    }
  }
  else
  {
    v12 = 1;
  }
  v13 = a2i_GENERAL_NAME(out, v10, ctx, v12, value, is_nc);
  v11 = v13;
  if (!v13)
    return v11;
  memset(v18, 0, sizeof(v18));
  if (is_nc)
  {
    v17 = 0;
    if (x509_constraints_validate((unsigned int *)v13, &v17, 0))
    {
      x509_constraints_name_free(v17);
      return v11;
    }
    ERR_put_error(34, 4095, 119, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_alt.c", 670);
    ERR_asprintf_error_data("name=%s");
LABEL_36:
    if (!out)
      GENERAL_NAME_free(v11);
    return 0;
  }
  v15 = x509_constraints_general_to_bytes((unsigned int *)v13, &v20, &v19);
  CBS_init(v18, v20, v19);
  switch(v15)
  {
    case 1:
      if (!x509_constraints_parse_mailbox((uint64_t)v18, 0))
      {
        v16 = 699;
        goto LABEL_32;
      }
      break;
    case 2:
      if (!x509_constraints_valid_sandns(v18))
      {
        v16 = 683;
        goto LABEL_32;
      }
      break;
    case 6:
      if (!x509_constraints_uri_host(v20, v19, 0))
      {
        v16 = 691;
LABEL_32:
        ERR_put_error(34, 4095, 119, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_alt.c", v16);
        ERR_asprintf_error_data("name=%s value='%.*s'");
        goto LABEL_36;
      }
      break;
    case 7:
      if (v19 != 4 && v19 != 16)
      {
        ERR_put_error(34, 4095, 118, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_alt.c", 707);
        ERR_asprintf_error_data("name=%s len=%zu");
        goto LABEL_36;
      }
      break;
    default:
      return v11;
  }
  return v11;
}

GENERAL_NAME *a2i_GENERAL_NAME(GENERAL_NAME *a1, int a2, X509V3_CTX *a3, int a4, char *__s, int a6)
{
  GENERAL_NAME *v11;
  ASN1_IA5STRING *v12;
  ASN1_STRING *v13;
  int v14;
  int v15;
  int v16;
  char *v17;
  char *v18;
  OTHERNAME *v19;
  ASN1_TYPE *v20;
  size_t v21;
  char *v22;
  char *v23;
  X509_NAME *v24;
  X509_NAME *v25;
  STACK *section;
  STACK *v27;
  ASN1_OCTET_STRING *v28;
  ASN1_OBJECT *v29;
  int v30;
  int v31;

  if (!__s)
  {
    ERR_put_error(34, 4095, 124, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_alt.c", 536);
    return 0;
  }
  v11 = a1;
  if (a1 || (v11 = GENERAL_NAME_new()) != 0)
  {
    switch(a4)
    {
      case 0:
        v17 = strchr(__s, 59);
        if (v17)
        {
          v18 = v17;
          v19 = OTHERNAME_new();
          v11->d.ptr = (char *)v19;
          if (v19)
          {
            ASN1_TYPE_free(v19->value);
            v20 = ASN1_generate_v3(v18 + 1, a3);
            *((_QWORD *)v11->d.ptr + 1) = v20;
            if (v20)
            {
              v21 = (int)v18 - (int)__s + 1;
              v22 = (char *)malloc_type_malloc(v21, 0xF907CCF3uLL);
              if (v22)
              {
                v23 = v22;
                strlcpy(v22, __s, v21);
                *(_QWORD *)v11->d.ptr = OBJ_txt2obj(v23, 0);
                free(v23);
              }
              else
              {
                *(_QWORD *)v11->d.ptr = 0;
              }
              if (*(_QWORD *)v11->d.ptr)
                goto LABEL_35;
            }
          }
        }
        v15 = 147;
        v16 = 590;
        goto LABEL_37;
      case 1:
      case 2:
      case 6:
        v12 = ASN1_IA5STRING_new();
        v11->d.ptr = (char *)v12;
        if (v12)
        {
          v13 = v12;
          v14 = strlen(__s);
          if (ASN1_STRING_set(v13, __s, v14))
            goto LABEL_35;
        }
        v15 = 65;
        v16 = 603;
        goto LABEL_37;
      case 4:
        v24 = X509_NAME_new();
        if (!v24)
          goto LABEL_32;
        v25 = v24;
        section = X509V3_get_section(a3, __s);
        if (section)
        {
          v27 = section;
          if (X509V3_NAME_from_section(v25, section, 0x1001uLL))
          {
            v11->d.ptr = (char *)v25;
            X509V3_section_free(a3, v27);
            goto LABEL_35;
          }
          X509_NAME_free(v25);
          v11->d.ptr = (char *)v25;
          X509V3_section_free(a3, v27);
        }
        else
        {
          ERR_put_error(34, 4095, 150, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_alt.c", 763);
          ERR_asprintf_error_data("section=%s", __s);
          X509_NAME_free(v25);
        }
LABEL_32:
        v15 = 149;
        v16 = 583;
LABEL_37:
        ERR_put_error(34, 4095, v15, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_alt.c", v16);
        if (!a1)
          goto LABEL_38;
        return 0;
      case 7:
        if (a6)
          v28 = a2i_IPADDRESS_NC(__s);
        else
          v28 = a2i_IPADDRESS(__s);
        v11->d.ptr = (char *)v28;
        if (v28)
          goto LABEL_35;
        v30 = 118;
        v31 = 575;
        goto LABEL_28;
      case 8:
        v29 = OBJ_txt2obj(__s, 0);
        if (v29)
        {
          v11->d.ptr = (char *)v29;
LABEL_35:
          v11->type = a4;
          return v11;
        }
        v30 = 119;
        v31 = 561;
LABEL_28:
        ERR_put_error(34, 4095, v30, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_alt.c", v31);
        ERR_asprintf_error_data("value=%s", __s);
        if (!a1)
LABEL_38:
          GENERAL_NAME_free(v11);
        break;
      default:
        v15 = 167;
        v16 = 596;
        goto LABEL_37;
    }
    return 0;
  }
  ERR_put_error(34, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_alt.c", 545);
  return v11;
}

uint64_t copy_email(uint64_t a1, STACK *a2, int a3)
{
  uint64_t subject_name;
  uint64_t v7;
  X509_NAME *v8;
  int v9;
  int index_by_NID;
  X509_NAME_ENTRY *entry;
  ASN1_STRING *data;
  ASN1_STRING *v13;
  GENERAL_NAME *v14;
  GENERAL_NAME *v15;

  if (a1)
  {
    if (*(_DWORD *)a1 == 1)
      return 1;
    if (*(_QWORD *)(a1 + 16))
    {
      subject_name = (uint64_t)X509_get_subject_name(*(X509 **)(a1 + 16));
      goto LABEL_8;
    }
    v7 = *(_QWORD *)(a1 + 24);
    if (v7)
    {
      subject_name = X509_REQ_get_subject_name(v7);
LABEL_8:
      v8 = (X509_NAME *)subject_name;
      v9 = -1;
      while (1)
      {
        index_by_NID = X509_NAME_get_index_by_NID(v8, 48, v9);
        if (index_by_NID < 0)
          return 1;
        v9 = index_by_NID;
        entry = X509_NAME_get_entry(v8, index_by_NID);
        data = X509_NAME_ENTRY_get_data(entry);
        v13 = ASN1_STRING_dup(data);
        if (a3)
        {
          X509_NAME_delete_entry(v8, v9);
          X509_NAME_ENTRY_free(entry);
          --v9;
        }
        if (!v13 || (v14 = GENERAL_NAME_new()) == 0)
        {
          ERR_put_error(34, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_alt.c", 469);
          goto LABEL_18;
        }
        v15 = v14;
        v14->d.ptr = (char *)v13;
        v14->type = 1;
        if (!sk_push(a2, (char *)v14))
        {
          ERR_put_error(34, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_alt.c", 476);
          v13 = 0;
          goto LABEL_19;
        }
      }
    }
  }
  ERR_put_error(34, 4095, 125, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_alt.c", 448);
  v13 = 0;
LABEL_18:
  v15 = 0;
LABEL_19:
  GENERAL_NAME_free(v15);
  ASN1_IA5STRING_free(v13);
  return 0;
}

UI *UI_new(void)
{
  return UI_new_method(0);
}

UI *__cdecl UI_new_method(const UI_METHOD *method)
{
  UI_METHOD **v2;
  UI_METHOD **v3;
  UI_METHOD *v4;

  v2 = (UI_METHOD **)malloc_type_calloc(1uLL, 0x28uLL, 0x10E00402F6BC7AFuLL);
  v3 = v2;
  if (v2)
  {
    *v2 = method;
    if (!method)
    {
      v4 = (UI_METHOD *)default_UI_meth;
      if (!default_UI_meth)
      {
        v4 = UI_OpenSSL();
        default_UI_meth = (uint64_t)v4;
      }
      *v3 = v4;
    }
    CRYPTO_new_ex_data(11, v3, (CRYPTO_EX_DATA *)(v3 + 3));
  }
  else
  {
    ERR_put_error(40, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ui/ui_lib.c", 84);
  }
  return (UI *)v3;
}

const UI_METHOD *UI_get_default_method(void)
{
  const UI_METHOD *result;

  result = (const UI_METHOD *)default_UI_meth;
  if (!default_UI_meth)
  {
    result = UI_OpenSSL();
    default_UI_meth = (uint64_t)result;
  }
  return result;
}

void UI_free(UI *ui)
{
  if (ui)
  {
    sk_pop_free(*((STACK **)ui + 1), (void (__cdecl *)(void *))free_string);
    CRYPTO_free_ex_data(11, ui, (CRYPTO_EX_DATA *)((char *)ui + 24));
    free(ui);
  }
}

void free_string(void **a1)
{
  if (a1)
  {
    if (((_BYTE)a1[7] & 1) != 0)
    {
      free(a1[1]);
      if (*(_DWORD *)a1 == 3)
      {
        free(a1[4]);
        free(a1[5]);
        free(a1[6]);
      }
    }
    free(a1);
  }
}

int UI_add_input_string(UI *ui, const char *prompt, int flags, char *result_buf, int minsize, int maxsize)
{
  return general_allocate_string((uint64_t)ui, prompt, 0, 1, flags, (uint64_t)result_buf, minsize, maxsize, 0);
}

uint64_t general_allocate_string(uint64_t a1, const char *a2, int a3, int a4, int a5, uint64_t a6, int a7, int a8, void *a9)
{
  void **prompt;
  void **v13;
  uint64_t result;

  prompt = (void **)general_allocate_prompt(a2, a3, a4, a5, a6);
  v13 = prompt;
  if (!prompt
    || (*((_DWORD *)prompt + 8) = a7,
        *((_DWORD *)prompt + 9) = a8,
        prompt[5] = a9,
        (allocate_string_stack(a1) & 0x80000000) != 0)
    || (result = sk_push(*(STACK **)(a1 + 8), (char *)v13), (int)result <= 0))
  {
    free_string(v13);
    return 0xFFFFFFFFLL;
  }
  return result;
}

int UI_dup_input_string(UI *ui, const char *prompt, int flags, char *result_buf, int minsize, int maxsize)
{
  return general_allocate_string((uint64_t)ui, prompt, 1, 1, flags, (uint64_t)result_buf, minsize, maxsize, 0);
}

int UI_add_verify_string(UI *ui, const char *prompt, int flags, char *result_buf, int minsize, int maxsize, const char *test_buf)
{
  return general_allocate_string((uint64_t)ui, prompt, 0, 2, flags, (uint64_t)result_buf, minsize, maxsize, (void *)test_buf);
}

int UI_dup_verify_string(UI *ui, const char *prompt, int flags, char *result_buf, int minsize, int maxsize, const char *test_buf)
{
  return general_allocate_string((uint64_t)ui, prompt, 1, 2, flags, (uint64_t)result_buf, minsize, maxsize, (void *)test_buf);
}

int UI_add_input_BOOLean(UI *ui, const char *prompt, const char *action_desc, const char *ok_chars, const char *cancel_chars, int flags, char *result_buf)
{
  return general_allocate_BOOLean((uint64_t)ui, prompt, action_desc, (char *)ok_chars, (char *)cancel_chars, 0, flags, (uint64_t)result_buf);
}

uint64_t general_allocate_BOOLean(uint64_t a1, const char *a2, const char *a3, char *__s, char *__charset, int a6, int a7, uint64_t a8)
{
  int v16;
  int v17;
  void **v18;
  uint64_t result;
  void **prompt;
  char *v21;
  char *v22;
  char *v23;
  int v24;

  if (!__s || !__charset)
  {
    v16 = 67;
    v17 = 214;
    goto LABEL_6;
  }
  if (__s[strcspn(__s, __charset)])
  {
    v16 = 104;
    v17 = 218;
LABEL_6:
    ERR_put_error(40, 4095, v16, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ui/ui_lib.c", v17);
    v18 = 0;
LABEL_7:
    free_string(v18);
    return 0xFFFFFFFFLL;
  }
  prompt = (void **)general_allocate_prompt(a2, a6, 3, a7, a8);
  v18 = prompt;
  if (!prompt)
    goto LABEL_7;
  if (a6)
  {
    if (a3)
    {
      v21 = strdup(a3);
      v18[4] = v21;
      if (!v21)
      {
        v24 = 230;
        goto LABEL_22;
      }
    }
    v22 = strdup(__s);
    v18[5] = v22;
    if (!v22)
    {
      v24 = 235;
      goto LABEL_22;
    }
    v23 = strdup(__charset);
    v18[6] = v23;
    if (!v23)
    {
      v24 = 240;
LABEL_22:
      ERR_put_error(40, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ui/ui_lib.c", v24);
      goto LABEL_7;
    }
  }
  else
  {
    prompt[4] = (void *)a3;
    prompt[5] = __s;
    prompt[6] = __charset;
  }
  if ((allocate_string_stack(a1) & 0x80000000) != 0)
    goto LABEL_7;
  result = sk_push(*(STACK **)(a1 + 8), (char *)v18);
  if ((int)result <= 0)
    goto LABEL_7;
  return result;
}

int UI_dup_input_BOOLean(UI *ui, const char *prompt, const char *action_desc, const char *ok_chars, const char *cancel_chars, int flags, char *result_buf)
{
  return general_allocate_BOOLean((uint64_t)ui, prompt, action_desc, (char *)ok_chars, (char *)cancel_chars, 1, flags, (uint64_t)result_buf);
}

int UI_add_info_string(UI *ui, const char *text)
{
  return general_allocate_string((uint64_t)ui, text, 0, 4, 0, 0, 0, 0, 0);
}

int UI_dup_info_string(UI *ui, const char *text)
{
  return general_allocate_string((uint64_t)ui, text, 1, 4, 0, 0, 0, 0, 0);
}

int UI_add_error_string(UI *ui, const char *text)
{
  return general_allocate_string((uint64_t)ui, text, 0, 5, 0, 0, 0, 0, 0);
}

int UI_dup_error_string(UI *ui, const char *text)
{
  return general_allocate_string((uint64_t)ui, text, 1, 5, 0, 0, 0, 0, 0);
}

char *__cdecl UI_construct_prompt(UI *ui_method, const char *object_desc, const char *object_name)
{
  uint64_t (*v3)(void);
  int v5;
  char *v6;

  v3 = *(uint64_t (**)(void))(*(_QWORD *)ui_method + 48);
  if (v3)
    return (char *)v3();
  if (!object_desc)
    return 0;
  v6 = 0;
  v5 = object_name ? asprintf(&v6, "Enter %s for %s:") : asprintf(&v6, "Enter %s:");
  if (v5 == -1)
    return 0;
  return v6;
}

void *__cdecl UI_add_user_data(UI *ui, void *user_data)
{
  void *v2;

  v2 = (void *)*((_QWORD *)ui + 2);
  *((_QWORD *)ui + 2) = user_data;
  return v2;
}

void *__cdecl UI_get0_user_data(UI *ui)
{
  return (void *)*((_QWORD *)ui + 2);
}

const char *__cdecl UI_get0_result(UI *ui, int i)
{
  const char *result;
  int v5;
  int v6;

  if (i < 0)
  {
    v5 = 103;
    v6 = 399;
LABEL_8:
    ERR_put_error(40, 4095, v5, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ui/ui_lib.c", v6);
    return 0;
  }
  if (sk_num(*((const STACK **)ui + 1)) <= i)
  {
    v5 = 102;
    v6 = 403;
    goto LABEL_8;
  }
  result = sk_value(*((const STACK **)ui + 1), i);
  if (!result)
    return result;
  if ((*(_DWORD *)result - 1) <= 1)
    return (const char *)*((_QWORD *)result + 3);
  return 0;
}

const char *__cdecl UI_get0_result_string(const char *uis)
{
  if (uis)
  {
    if ((*(_DWORD *)uis - 1) > 1)
      return 0;
    else
      return (const char *)*((_QWORD *)uis + 3);
  }
  return uis;
}

int UI_process(UI *ui)
{
  unsigned int (*v2)(UI *);
  int v3;
  unsigned int (*v4)(UI *, char *);
  char *v5;
  uint64_t (*v6)(UI *);
  int v7;
  int v8;
  int v9;
  uint64_t (*v10)(UI *, char *);
  char *v11;
  int v12;
  unsigned int (*v13)(UI *);

  v2 = *(unsigned int (**)(UI *))(*(_QWORD *)ui + 8);
  if (v2 && !v2(ui))
    return -1;
  if ((*((_BYTE *)ui + 33) & 1) != 0)
    ERR_print_errors_cb((int (__cdecl *)(const char *, size_t, void *))print_error, ui);
  if (sk_num(*((const STACK **)ui + 1)) >= 1)
  {
    v3 = 0;
    do
    {
      v4 = *(unsigned int (**)(UI *, char *))(*(_QWORD *)ui + 16);
      if (v4)
      {
        v5 = sk_value(*((const STACK **)ui + 1), v3);
        if (!v4(ui, v5))
          goto LABEL_13;
      }
    }
    while (++v3 < sk_num(*((const STACK **)ui + 1)));
  }
  v6 = *(uint64_t (**)(UI *))(*(_QWORD *)ui + 24);
  if (!v6)
    goto LABEL_14;
  v7 = v6(ui);
  if (v7 == -1)
    goto LABEL_22;
  if (v7)
  {
LABEL_14:
    if (sk_num(*((const STACK **)ui + 1)) < 1)
    {
LABEL_20:
      v8 = 0;
      goto LABEL_23;
    }
    v9 = 0;
    while (1)
    {
      v10 = *(uint64_t (**)(UI *, char *))(*(_QWORD *)ui + 32);
      if (v10)
      {
        v11 = sk_value(*((const STACK **)ui + 1), v9);
        v12 = v10(ui, v11);
        if (!v12)
          goto LABEL_13;
        if (v12 == -1)
          break;
      }
      if (++v9 >= sk_num(*((const STACK **)ui + 1)))
        goto LABEL_20;
    }
    *((_DWORD *)ui + 8) &= ~1u;
LABEL_22:
    v8 = -2;
    goto LABEL_23;
  }
LABEL_13:
  v8 = -1;
LABEL_23:
  v13 = *(unsigned int (**)(UI *))(*(_QWORD *)ui + 40);
  if (v13 && !v13(ui))
    return -1;
  return v8;
}

uint64_t print_error(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unsigned int (*v3)(uint64_t, _QWORD *);
  _QWORD v5[2];
  __int128 v6;
  __int128 v7;
  __int128 v8;

  v7 = 0u;
  v8 = 0u;
  v6 = 0u;
  v5[0] = 5;
  v5[1] = a1;
  v3 = *(unsigned int (**)(uint64_t, _QWORD *))(*(_QWORD *)a3 + 16);
  if (v3 && !v3(a3, v5))
    return 0xFFFFFFFFLL;
  else
    return 0;
}

int UI_ctrl(UI *ui, int cmd, uint64_t i, void *p, void (*f)(void))
{
  unsigned int v6;
  int result;
  int v8;
  int v9;

  if (ui)
  {
    if (cmd == 2)
      return *((_DWORD *)ui + 8) & 1;
    if (cmd == 1)
    {
      v6 = *((_DWORD *)ui + 8);
      result = (v6 >> 8) & 1;
      *((_DWORD *)ui + 8) = v6 & 0xFFFFFEFF | ((i != 0) << 8);
      return result;
    }
    v8 = 106;
    v9 = 507;
  }
  else
  {
    v8 = 67;
    v9 = 488;
  }
  ERR_put_error(40, 4095, v8, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ui/ui_lib.c", v9);
  return -1;
}

int UI_get_ex_new_index(uint64_t argl, void *argp, CRYPTO_EX_new *new_func, CRYPTO_EX_dup *dup_func, CRYPTO_EX_free *free_func)
{
  return CRYPTO_get_ex_new_index(11, argl, argp, new_func, dup_func, free_func);
}

int UI_set_ex_data(UI *r, int idx, void *arg)
{
  return CRYPTO_set_ex_data((CRYPTO_EX_DATA *)((char *)r + 24), idx, arg);
}

void *__cdecl UI_get_ex_data(UI *r, int idx)
{
  return CRYPTO_get_ex_data((const CRYPTO_EX_DATA *)((char *)r + 24), idx);
}

void UI_set_default_method(const UI_METHOD *meth)
{
  default_UI_meth = (uint64_t)meth;
}

const UI_METHOD *__cdecl UI_get_method(UI *ui)
{
  return *(const UI_METHOD **)ui;
}

const UI_METHOD *__cdecl UI_set_method(UI *ui, const UI_METHOD *meth)
{
  *(_QWORD *)ui = meth;
  return meth;
}

UI_METHOD *__cdecl UI_create_method(char *name)
{
  UI_METHOD *v2;
  char *v3;

  v2 = (UI_METHOD *)malloc_type_calloc(1uLL, 0x38uLL, 0x90040541F721BuLL);
  if (!v2 || name && (v3 = strdup(name), (*(_QWORD *)v2 = v3) == 0))
  {
    UI_destroy_method(v2);
    return 0;
  }
  return v2;
}

void UI_destroy_method(UI_METHOD *ui_method)
{
  if (ui_method)
  {
    free(*(void **)ui_method);
    free(ui_method);
  }
}

int UI_method_set_opener(UI_METHOD *method, int (__cdecl *opener)(UI *))
{
  int result;

  if (!method)
    return -1;
  result = 0;
  *((_QWORD *)method + 1) = opener;
  return result;
}

int UI_method_set_writer(UI_METHOD *method, int (__cdecl *writer)(UI *, UI_STRING *))
{
  int result;

  if (!method)
    return -1;
  result = 0;
  *((_QWORD *)method + 2) = writer;
  return result;
}

int UI_method_set_flusher(UI_METHOD *method, int (__cdecl *flusher)(UI *))
{
  int result;

  if (!method)
    return -1;
  result = 0;
  *((_QWORD *)method + 3) = flusher;
  return result;
}

int UI_method_set_reader(UI_METHOD *method, int (__cdecl *reader)(UI *, UI_STRING *))
{
  int result;

  if (!method)
    return -1;
  result = 0;
  *((_QWORD *)method + 4) = reader;
  return result;
}

int UI_method_set_closer(UI_METHOD *method, int (__cdecl *closer)(UI *))
{
  int result;

  if (!method)
    return -1;
  result = 0;
  *((_QWORD *)method + 5) = closer;
  return result;
}

uint64_t UI_method_set_prompt_constructor(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  if (!a1)
    return 0xFFFFFFFFLL;
  result = 0;
  *(_QWORD *)(a1 + 48) = a2;
  return result;
}

int (__cdecl *__cdecl UI_method_get_opener(int (__cdecl *method)(UI *)))(UI *)
{
  if (method)
    return (int (__cdecl *)(UI *))*((_QWORD *)method + 1);
  return method;
}

int (__cdecl *__cdecl UI_method_get_writer(int (__cdecl *method)(UI *, UI_STRING *)))(UI *, UI_STRING *)
{
  if (method)
    return (int (__cdecl *)(UI *, UI_STRING *))*((_QWORD *)method + 2);
  return method;
}

int (__cdecl *__cdecl UI_method_get_flusher(int (__cdecl *method)(UI *)))(UI *)
{
  if (method)
    return (int (__cdecl *)(UI *))*((_QWORD *)method + 3);
  return method;
}

int (__cdecl *__cdecl UI_method_get_reader(int (__cdecl *method)(UI *, UI_STRING *)))(UI *, UI_STRING *)
{
  if (method)
    return (int (__cdecl *)(UI *, UI_STRING *))*((_QWORD *)method + 4);
  return method;
}

int (__cdecl *__cdecl UI_method_get_closer(int (__cdecl *method)(UI *)))(UI *)
{
  if (method)
    return (int (__cdecl *)(UI *))*((_QWORD *)method + 5);
  return method;
}

uint64_t UI_method_get_prompt_constructor(uint64_t result)
{
  if (result)
    return *(_QWORD *)(result + 48);
  return result;
}

UI_string_types UI_get_string_type(UI_STRING *uis)
{
  if (uis)
    LODWORD(uis) = *(_DWORD *)uis;
  return uis;
}

int UI_get_input_flags(UI_STRING *uis)
{
  if (uis)
    LODWORD(uis) = *((_DWORD *)uis + 4);
  return (int)uis;
}

const char *__cdecl UI_get0_output_string(const char *uis)
{
  if (uis)
    return (const char *)*((_QWORD *)uis + 1);
  return uis;
}

const char *__cdecl UI_get0_action_string(const char *uis)
{
  if (uis)
  {
    if ((*(_DWORD *)uis | 2) == 3)
      return (const char *)*((_QWORD *)uis + 4);
    else
      return 0;
  }
  return uis;
}

const char *__cdecl UI_get0_test_string(const char *uis)
{
  if (uis)
  {
    if (*(_DWORD *)uis == 2)
      return (const char *)*((_QWORD *)uis + 5);
    else
      return 0;
  }
  return uis;
}

int UI_get_result_minsize(UI_STRING *uis)
{
  if (uis && (*(_DWORD *)uis - 1) <= 1)
    return *((_DWORD *)uis + 8);
  else
    return -1;
}

int UI_get_result_maxsize(UI_STRING *uis)
{
  if (uis && (*(_DWORD *)uis - 1) <= 1)
    return *((_DWORD *)uis + 9);
  else
    return -1;
}

int UI_set_result(UI *ui, UI_STRING *uis, const char *result)
{
  int v6;
  int v7;
  int v8;
  int v9;
  _BYTE *v10;
  char v11;
  char *v12;
  const char *v13;
  int v14;
  char *v15;
  char *v16;
  int v17;
  uint64_t v18;
  char *v19;
  int v20;
  char v21;

  v6 = strlen(result);
  v7 = *((_DWORD *)ui + 8);
  *((_DWORD *)ui + 8) = v7 & 0xFFFFFFFE;
  if (!uis)
    goto LABEL_22;
  if ((*(_DWORD *)uis - 1) < 2)
  {
    if (*((_DWORD *)uis + 8) > v6)
    {
      *((_DWORD *)ui + 8) = v7 | 1;
      v8 = 101;
      v9 = 861;
LABEL_15:
      ERR_put_error(40, 4095, v8, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ui/ui_lib.c", v9);
      ERR_asprintf_error_data("You must type in %d to %d characters", *((_DWORD *)uis + 8), *((_DWORD *)uis + 9));
LABEL_22:
      LODWORD(v16) = -1;
      return (int)v16;
    }
    v18 = *((int *)uis + 9);
    if ((int)v18 < v6)
    {
      *((_DWORD *)ui + 8) = v7 | 1;
      v8 = 100;
      v9 = 870;
      goto LABEL_15;
    }
    v19 = (char *)*((_QWORD *)uis + 3);
    if (v19)
    {
      strlcpy(v19, result, v18 + 1);
      goto LABEL_18;
    }
    v20 = 878;
LABEL_21:
    ERR_put_error(40, 4095, 105, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ui/ui_lib.c", v20);
    goto LABEL_22;
  }
  if (*(_DWORD *)uis != 3)
    goto LABEL_18;
  v10 = (_BYTE *)*((_QWORD *)uis + 3);
  if (!v10)
  {
    v20 = 886;
    goto LABEL_21;
  }
  *v10 = 0;
  v11 = *result;
  if (!*result)
  {
LABEL_18:
    LODWORD(v16) = 0;
    return (int)v16;
  }
  v12 = (char *)*((_QWORD *)uis + 5);
  v13 = result + 1;
  while (1)
  {
    v14 = v11;
    if (strchr(v12, v11))
    {
      LODWORD(v16) = 0;
      v21 = *v12;
      goto LABEL_25;
    }
    v15 = (char *)*((_QWORD *)uis + 6);
    v16 = strchr(v15, v14);
    if (v16)
      break;
    v17 = *(unsigned __int8 *)v13++;
    v11 = v17;
    if (!v17)
      return (int)v16;
  }
  LODWORD(v16) = 0;
  v21 = *v15;
LABEL_25:
  **((_BYTE **)uis + 3) = v21;
  return (int)v16;
}

_QWORD *general_allocate_prompt(const char *a1, int a2, int a3, int a4, uint64_t a5)
{
  int v10;
  int v11;
  _QWORD *v12;
  _QWORD *v14;
  char *v15;
  int v16;

  if (!a1)
  {
    v10 = 67;
    v11 = 146;
    goto LABEL_6;
  }
  if ((a3 - 1) > 2 || a5)
  {
    v14 = malloc_type_calloc(1uLL, 0x40uLL, 0x1052040C0D9DABDuLL);
    v12 = v14;
    if (v14)
    {
      v14[1] = a1;
      if (!a2)
      {
LABEL_13:
        *((_DWORD *)v12 + 4) = a4;
        *(_DWORD *)v12 = a3;
        v12[3] = a5;
        return v12;
      }
      v15 = strdup(a1);
      v12[1] = v15;
      if (v15)
      {
        *((_DWORD *)v12 + 14) = 1;
        goto LABEL_13;
      }
      v16 = 162;
    }
    else
    {
      v16 = 156;
    }
    ERR_put_error(40, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ui/ui_lib.c", v16);
    goto LABEL_7;
  }
  v10 = 105;
  v11 = 151;
LABEL_6:
  ERR_put_error(40, 4095, v10, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ui/ui_lib.c", v11);
  v12 = 0;
LABEL_7:
  free_string((void **)v12);
  return 0;
}

uint64_t allocate_string_stack(uint64_t a1)
{
  STACK *v2;

  if (*(_QWORD *)(a1 + 8))
    return 0;
  v2 = sk_new_null();
  *(_QWORD *)(a1 + 8) = v2;
  if (v2)
    return 0;
  ERR_put_error(40, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ui/ui_lib.c", 132);
  return 0xFFFFFFFFLL;
}

void ERR_load_EC_strings(void)
{
  if (!ERR_func_error_string(EC_str_functs))
  {
    ERR_load_strings(0, (ERR_STRING_DATA *)&EC_str_functs);
    ERR_load_strings(0, (ERR_STRING_DATA *)&EC_str_reasons);
  }
}

BIGNUM *__cdecl EC_POINT_point2bn(const EC_GROUP *a1, const EC_POINT *a2, point_conversion_form_t form, BIGNUM *a4, BN_CTX *a5)
{
  size_t v10;
  size_t v11;
  unsigned __int8 *v12;
  unsigned __int8 *v13;
  BIGNUM *v14;

  v10 = EC_POINT_point2oct(a1, a2, form, 0, 0, a5);
  if (!v10)
    return 0;
  v11 = v10;
  v12 = (unsigned __int8 *)malloc_type_malloc(v10, 0x1115782uLL);
  if (!v12)
    return 0;
  v13 = v12;
  if (EC_POINT_point2oct(a1, a2, form, v12, v11, a5))
    v14 = BN_bin2bn(v13, v11, a4);
  else
    v14 = 0;
  free(v13);
  return v14;
}

EC_POINT *__cdecl EC_POINT_bn2point(const EC_GROUP *a1, const BIGNUM *a2, EC_POINT *a3, BN_CTX *a4)
{
  int v8;
  int v9;
  size_t v10;
  unsigned __int8 *v11;
  unsigned __int8 *v12;

  v8 = BN_num_bits(a2);
  v9 = v8 + 7;
  if (v8 < -7)
    v9 = v8 + 14;
  if ((v8 + 14) >= 0xF)
  {
    v10 = (uint64_t)v9 >> 3;
    v11 = (unsigned __int8 *)malloc_type_malloc(v10, 0xDA6F2E94uLL);
    if (v11)
    {
      v12 = v11;
      if (BN_bn2bin(a2, v11))
      {
        if (a3)
        {
          if (EC_POINT_oct2point(a1, a3, v12, v10, a4))
          {
LABEL_14:
            free(v12);
            return a3;
          }
        }
        else
        {
          a3 = EC_POINT_new(a1);
          if (!a3 || EC_POINT_oct2point(a1, a3, v12, v10, a4))
            goto LABEL_14;
          EC_POINT_free(a3);
        }
      }
      a3 = 0;
      goto LABEL_14;
    }
  }
  return 0;
}

char *__cdecl EC_POINT_point2hex(const EC_GROUP *a1, const EC_POINT *a2, point_conversion_form_t form, BN_CTX *a4)
{
  size_t v8;
  size_t v9;
  unint64_t v10;
  unsigned __int8 *v11;
  unsigned __int8 *v12;
  char *v13;
  char *v14;
  uint64_t v15;
  char *v16;
  unint64_t v17;

  v8 = EC_POINT_point2oct(a1, a2, form, 0, 0, a4);
  if (!v8)
    return 0;
  v9 = v8;
  v10 = v8 + 1;
  if (v8 == -1)
    return 0;
  v11 = (unsigned __int8 *)malloc_type_malloc(v8, 0x76EBF871uLL);
  if (!v11)
    return 0;
  v12 = v11;
  if (!EC_POINT_point2oct(a1, a2, form, v11, v9, a4))
  {
    free(v12);
    return 0;
  }
  v13 = (char *)reallocarray(0, v10, 2uLL);
  v14 = v13;
  if (v13)
  {
    v15 = 0;
    v16 = v13;
    do
    {
      v17 = v12[v15];
      *v16 = a0123456789abcd[v17 >> 4];
      v16[1] = a0123456789abcd[v17 & 0xF];
      v16 += 2;
      ++v15;
    }
    while (v9 != v15);
    *v16 = 0;
  }
  free(v12);
  return v14;
}

EC_POINT *__cdecl EC_POINT_hex2point(const EC_GROUP *a1, const char *a2, EC_POINT *a3, BN_CTX *a4)
{
  EC_POINT *v7;
  BIGNUM *a;

  a = 0;
  if (!BN_hex2bn(&a, a2))
    return 0;
  v7 = EC_POINT_bn2point(a1, a, a3, a4);
  BN_free(a);
  return v7;
}

BIO_METHOD *BIO_f_cipher(void)
{
  return (BIO_METHOD *)&methods_enc;
}

void BIO_set_cipher(BIO *b, const EVP_CIPHER *c, const unsigned __int8 *k, const unsigned __int8 *i, int enc)
{
  uint64_t data;
  uint64_t v11;
  uint64_t (__cdecl *callback)(bio_st *, int, const char *, int, uint64_t, uint64_t);
  int v13;

  if (b)
  {
    data = BIO_get_data((uint64_t)b);
    if (data)
    {
      v11 = data;
      callback = BIO_get_callback(b);
      if (!callback
        || ((uint64_t (*)(BIO *, uint64_t, const EVP_CIPHER *, uint64_t, _QWORD, _QWORD))callback)(b, 6, c, 4, enc, 0) >= 1)
      {
        BIO_set_init((uint64_t)b, 1);
        v13 = EVP_CipherInit_ex((EVP_CIPHER_CTX *)(v11 + 24), c, 0, k, i, enc);
        if (callback)
        {
          if (v13)
            ((void (*)(BIO *, uint64_t, const EVP_CIPHER *, uint64_t, _QWORD, uint64_t))callback)(b, 6, c, 4, enc, 1);
        }
      }
    }
  }
}

uint64_t enc_write(BIO *a1, const unsigned __int8 *a2, uint64_t a3)
{
  bio_st *next_bio;
  int method_high;
  int v8;
  uint64_t v9;
  uint64_t v10;
  BOOL v11;
  int v12;
  uint64_t v13;
  int method;
  int v15;
  int v16;
  unsigned int v17;

  next_bio = a1->next_bio;
  BIO_clear_flags(a1, 15);
  method_high = HIDWORD(next_bio->method);
  v8 = LODWORD(next_bio->method) - method_high;
  if (v8 < 1)
  {
LABEL_5:
    v10 = 0;
    if (a2 && (int)a3 >= 1)
    {
      HIDWORD(next_bio->method) = 0;
      v12 = a3;
      while (1)
      {
        v13 = v12 >= 4096 ? 4096 : v12;
        EVP_CipherUpdate((EVP_CIPHER_CTX *)&next_bio->init, (unsigned __int8 *)&next_bio[1].num_read, (int *)next_bio, a2, v13);
        v12 -= v13;
        HIDWORD(next_bio->method) = 0;
        method = (int)next_bio->method;
        if (SLODWORD(next_bio->method) >= 1)
          break;
LABEL_16:
        a2 += v13;
        next_bio->method = 0;
        if (v12 <= 0)
        {
          BIO_copy_next_retry(a1);
          return a3;
        }
      }
      v15 = 0;
      while (1)
      {
        v16 = BIO_write(a1->prev_bio, (char *)&next_bio[1].num_read + v15, method);
        v17 = v16;
        if (v16 <= 0)
          break;
        v15 = HIDWORD(next_bio->method) + v16;
        HIDWORD(next_bio->method) = v15;
        v11 = __OFSUB__(method, v16);
        method -= v16;
        if ((method < 0) ^ v11 | (method == 0))
          goto LABEL_16;
      }
      BIO_copy_next_retry(a1);
      if ((_DWORD)a3 == v12)
        return v17;
      else
        return (a3 - v12);
    }
  }
  else
  {
    while (1)
    {
      v9 = BIO_write(a1->prev_bio, (char *)&next_bio[1].num_read + method_high, v8);
      v10 = v9;
      if ((int)v9 <= 0)
        break;
      method_high = HIDWORD(next_bio->method) + v9;
      HIDWORD(next_bio->method) = method_high;
      v11 = __OFSUB__(v8, (_DWORD)v9);
      v8 -= v9;
      if ((v8 < 0) ^ v11 | (v8 == 0))
        goto LABEL_5;
    }
    BIO_copy_next_retry(a1);
  }
  return v10;
}

uint64_t enc_read(BIO *a1, char *__dst, int a3)
{
  bio_st *next_bio;
  int v5;
  char *v6;
  uint64_t method_high;
  int v8;
  uint64_t v9;
  int method;
  int v11;
  int callback;
  int v14;
  int v15;
  size_t v16;
  BOOL v17;

  if (!__dst)
    return 0;
  next_bio = a1->next_bio;
  if (!next_bio || !a1->prev_bio)
    return 0;
  v5 = a3;
  v6 = __dst;
  if (SLODWORD(next_bio->method) < 1)
  {
    v9 = 0;
  }
  else
  {
    method_high = SHIDWORD(next_bio->method);
    v8 = LODWORD(next_bio->method) - method_high;
    if (v8 >= a3)
      v9 = a3;
    else
      v9 = v8;
    memcpy(__dst, (char *)&next_bio[1].num_read + method_high, (int)v9);
    v6 += (int)v9;
    v5 -= v9;
    method = (int)next_bio->method;
    v11 = HIDWORD(next_bio->method) + v9;
    HIDWORD(next_bio->method) = v11;
    if (method == v11)
      next_bio->method = 0;
  }
  if (v5 >= 1)
  {
LABEL_14:
    callback = (int)next_bio->callback;
    while (callback >= 1)
    {
      v14 = BIO_read(a1->prev_bio, &next_bio[2].flags, 4096);
      if (v14 <= 0)
      {
        if (BIO_test_flags(a1->prev_bio, 8))
        {
          if ((_DWORD)v9)
            v9 = v9;
          else
            v9 = v14;
          break;
        }
        LODWORD(next_bio->callback) = v14;
        LODWORD(next_bio->cb_arg) = EVP_CipherFinal_ex((EVP_CIPHER_CTX *)&next_bio->init, (unsigned __int8 *)&next_bio[1].num_read, (int *)next_bio);
        HIDWORD(next_bio->method) = 0;
        v15 = (int)next_bio->method;
LABEL_21:
        if (v15 >= v5)
          v16 = v5;
        else
          v16 = v15;
        if ((int)v16 < 1)
          break;
        memcpy(v6, &next_bio[1].num_read, v16);
        v9 = (v16 + v9);
        HIDWORD(next_bio->method) = v16;
        v6 += v16;
        v17 = __OFSUB__(v5, (_DWORD)v16);
        v5 -= v16;
        if ((v5 < 0) ^ v17 | (v5 == 0))
          break;
        goto LABEL_14;
      }
      EVP_CipherUpdate((EVP_CIPHER_CTX *)&next_bio->init, (unsigned __int8 *)&next_bio[1].num_read, (int *)next_bio, (const unsigned __int8 *)&next_bio[2].flags, v14);
      callback = 1;
      LODWORD(next_bio->callback) = 1;
      v15 = (int)next_bio->method;
      if (LODWORD(next_bio->method))
        goto LABEL_21;
    }
  }
  BIO_clear_flags(a1, 15);
  BIO_copy_next_retry(a1);
  if (!(_DWORD)v9)
    return LODWORD(next_bio->callback);
  return v9;
}

uint64_t enc_ctrl(BIO *b, int a2, uint64_t a3, int **a4)
{
  bio_st *next_bio;
  BIO *prev_bio;
  uint64_t result;
  int method_high;
  EVP_CIPHER_CTX *v11;
  int v12;
  uint64_t v13;

  next_bio = b->next_bio;
  if (a2 > 100)
  {
    switch(a2)
    {
      case 101:
        BIO_clear_flags(b, 15);
        v13 = BIO_ctrl(b->prev_bio, 101, a3, a4);
        BIO_copy_next_retry(b);
        return v13;
      case 113:
        return SLODWORD(next_bio->cb_arg);
      case 129:
        *a4 = &next_bio->init;
        result = 1;
        b->flags = 1;
        return result;
    }
LABEL_24:
    prev_bio = b->prev_bio;
  }
  else
  {
    switch(a2)
    {
      case 1:
        *(uint64_t (__cdecl **)(bio_st *, int, const char *, int, uint64_t, uint64_t))((char *)&next_bio->callback + 4) = (uint64_t (__cdecl *)(bio_st *, int, const char *, int, uint64_t, uint64_t))0x100000000;
        EVP_CipherInit_ex((EVP_CIPHER_CTX *)&next_bio->init, 0, 0, 0, 0, next_bio->num);
        prev_bio = b->prev_bio;
        a2 = 1;
        return BIO_ctrl(prev_bio, a2, a3, a4);
      case 2:
        if (SLODWORD(next_bio->callback) >= 1)
        {
          prev_bio = b->prev_bio;
          a2 = 2;
          return BIO_ctrl(prev_bio, a2, a3, a4);
        }
        return 1;
      case 10:
        method_high = HIDWORD(next_bio->method);
        result = (LODWORD(next_bio->method) - method_high);
        if (SLODWORD(next_bio->method) > method_high)
          return result;
        prev_bio = b->prev_bio;
        a2 = 10;
        return BIO_ctrl(prev_bio, a2, a3, a4);
      case 11:
        goto LABEL_12;
      case 12:
        v11 = (EVP_CIPHER_CTX *)(a4[7] + 6);
        EVP_CIPHER_CTX_init(v11);
        LODWORD(result) = EVP_CIPHER_CTX_copy(v11, (uint64_t *)&next_bio->init);
        if (!(_DWORD)result)
          return 0;
        result = (int)result;
        *((_DWORD *)a4 + 8) = 1;
        return result;
      case 13:
        v12 = HIDWORD(next_bio->method);
        result = (LODWORD(next_bio->method) - v12);
        if (SLODWORD(next_bio->method) > v12)
          return result;
        prev_bio = b->prev_bio;
        a2 = 13;
        return BIO_ctrl(prev_bio, a2, a3, a4);
      default:
        goto LABEL_24;
    }
    while (1)
    {
LABEL_12:
      while (LODWORD(next_bio->method) != HIDWORD(next_bio->method))
      {
        LODWORD(result) = enc_write(b, 0, 0);
        if ((result & 0x80000000) != 0)
          return (int)result;
      }
      if (HIDWORD(next_bio->callback))
        break;
      HIDWORD(next_bio->callback) = 1;
      HIDWORD(next_bio->method) = 0;
      LODWORD(result) = EVP_CipherFinal_ex((EVP_CIPHER_CTX *)&next_bio->init, (unsigned __int8 *)&next_bio[1].num_read, (int *)next_bio);
      LODWORD(next_bio->cb_arg) = result;
      if ((int)result < 1)
        return (int)result;
    }
    prev_bio = b->prev_bio;
    a2 = 11;
  }
  return BIO_ctrl(prev_bio, a2, a3, a4);
}

uint64_t enc_new(uint64_t a1)
{
  uint64_t result;
  uint64_t v3;

  result = (uint64_t)malloc_type_malloc(0x1108uLL, 0x10E004092A15CCAuLL);
  if (result)
  {
    v3 = result;
    EVP_CIPHER_CTX_init((EVP_CIPHER_CTX *)(result + 24));
    *(_OWORD *)v3 = xmmword_22D699FE0;
    result = 1;
    *(_DWORD *)(v3 + 16) = 1;
    *(_DWORD *)(a1 + 32) = 0;
    *(_QWORD *)(a1 + 56) = v3;
    *(_DWORD *)(a1 + 40) = 0;
  }
  return result;
}

uint64_t enc_free(uint64_t result)
{
  uint64_t v1;

  if (result)
  {
    v1 = result;
    EVP_CIPHER_CTX_cleanup((EVP_CIPHER_CTX *)(*(_QWORD *)(result + 56) + 24));
    freezero(*(void **)(v1 + 56), 0x1108uLL);
    *(_QWORD *)(v1 + 56) = 0;
    *(_DWORD *)(v1 + 32) = 0;
    result = 1;
    *(_DWORD *)(v1 + 40) = 0;
  }
  return result;
}

BIO *enc_callback_ctrl(uint64_t a1, int a2, void (__cdecl *a3)(bio_st *, int, const char *, int, uint64_t, uint64_t))
{
  BIO *result;

  result = *(BIO **)(a1 + 64);
  if (result)
    return (BIO *)BIO_callback_ctrl(result, a2, a3);
  return result;
}

int ENGINE_set_default(ENGINE *e, unsigned int flags)
{
  __int16 v2;
  int result;

  v2 = flags;
  if (((flags & 0x40) == 0 || (result = ENGINE_set_default_ciphers(e)) != 0)
    && ((v2 & 0x80) == 0 || (result = ENGINE_set_default_digests(e)) != 0)
    && ((v2 & 1) == 0 || (result = ENGINE_set_default_RSA(e)) != 0)
    && ((v2 & 2) == 0 || (result = ENGINE_set_default_DSA(e)) != 0)
    && ((v2 & 4) == 0 || (result = ENGINE_set_default_DH(e)) != 0)
    && ((v2 & 0x10) == 0 || (result = ENGINE_set_default_ECDH(e)) != 0)
    && ((v2 & 0x20) == 0 || (result = ENGINE_set_default_ECDSA(e)) != 0)
    && ((v2 & 0x800) == 0 || (result = ENGINE_set_default_EC((uint64_t)e)) != 0)
    && ((v2 & 8) == 0 || (result = ENGINE_set_default_RAND(e)) != 0)
    && ((v2 & 0x200) == 0 || (result = ENGINE_set_default_pkey_meths((uint64_t)e)) != 0))
  {
    if ((v2 & 0x400) == 0)
      return 1;
    result = ENGINE_set_default_pkey_asn1_meths((uint64_t)e);
    if (result)
      return 1;
  }
  return result;
}

int ENGINE_set_default_string(ENGINE *e, const char *def_list)
{
  unsigned int arg;

  arg = 0;
  if (CONF_parse_list(def_list, 44, 1, (int (__cdecl *)(const char *, int, void *))int_def_cb, &arg))
    return ENGINE_set_default(e, arg);
  ERR_put_error(38, 4095, 150, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/engine/eng_fat.c", 156);
  ERR_asprintf_error_data("str=%s", def_list);
  return 0;
}

uint64_t int_def_cb(const char *a1, int a2, _DWORD *a3)
{
  size_t v5;
  int v7;

  v5 = a2;
  if (!strncmp(a1, "ALL", a2))
  {
    v7 = 0xFFFF;
  }
  else if (!strncmp(a1, "RSA", v5))
  {
    v7 = 1;
  }
  else if (!strncmp(a1, "DSA", v5))
  {
    v7 = 2;
  }
  else if (!strncmp(a1, "ECDH", v5))
  {
    v7 = 16;
  }
  else if (!strncmp(a1, "ECDSA", v5))
  {
    v7 = 32;
  }
  else if (!strncmp(a1, "DH", v5))
  {
    v7 = 4;
  }
  else if (!strncmp(a1, "EC", v5))
  {
    v7 = 2048;
  }
  else if (!strncmp(a1, "RAND", v5))
  {
    v7 = 8;
  }
  else if (!strncmp(a1, "CIPHERS", v5))
  {
    v7 = 64;
  }
  else if (!strncmp(a1, "DIGESTS", v5))
  {
    v7 = 128;
  }
  else if (!strncmp(a1, "PKEY", v5))
  {
    v7 = 1536;
  }
  else if (!strncmp(a1, "PKEY_CRYPTO", v5))
  {
    v7 = 512;
  }
  else
  {
    if (strncmp(a1, "PKEY_ASN1", v5))
      return 0;
    v7 = 1024;
  }
  *a3 |= v7;
  return 1;
}

int ENGINE_register_complete(ENGINE *e)
{
  ENGINE_register_ciphers(e);
  ENGINE_register_digests(e);
  ENGINE_register_RSA(e);
  ENGINE_register_DSA(e);
  ENGINE_register_DH(e);
  ENGINE_register_ECDH(e);
  ENGINE_register_ECDSA(e);
  ENGINE_register_EC((uint64_t)e);
  ENGINE_register_RAND(e);
  ENGINE_register_pkey_meths((uint64_t)e);
  return 1;
}

int ENGINE_register_all_complete(void)
{
  ENGINE *first;
  ENGINE *next;

  first = ENGINE_get_first();
  if (first)
  {
    next = first;
    do
    {
      if ((*((_BYTE *)next + 176) & 8) == 0)
        ENGINE_register_complete(next);
      next = ENGINE_get_next(next);
    }
    while (next);
  }
  return 1;
}

uint64_t check_defer(uint64_t result)
{
  if ((int)result >= 1053 && !obj_cleanup_defer)
    obj_cleanup_defer = 1;
  return result;
}

void OBJ_cleanup(void)
{
  LHASH *v0;

  if (obj_cleanup_defer)
  {
    obj_cleanup_defer = 2;
  }
  else
  {
    v0 = (LHASH *)added;
    if (added)
    {
      *(_QWORD *)(added + 48) = 0;
      lh_doall(v0, (LHASH_DOALL_FN_TYPE)cleanup1_LHASH_DOALL);
      lh_doall((LHASH *)added, (LHASH_DOALL_FN_TYPE)cleanup2_LHASH_DOALL);
      lh_doall((LHASH *)added, (LHASH_DOALL_FN_TYPE)cleanup3_LHASH_DOALL);
      lh_free((LHASH *)added);
      added = 0;
    }
  }
}

uint64_t cleanup1_LHASH_DOALL(uint64_t result)
{
  uint64_t v1;

  v1 = *(_QWORD *)(result + 8);
  *(_DWORD *)(v1 + 16) = 0;
  *(_DWORD *)(v1 + 32) |= 0xDu;
  return result;
}

uint64_t cleanup2_LHASH_DOALL(uint64_t result)
{
  ++*(_DWORD *)(*(_QWORD *)(result + 8) + 16);
  return result;
}

void cleanup3_LHASH_DOALL(_QWORD *a1)
{
  ASN1_OBJECT *v2;
  int v3;

  v2 = (ASN1_OBJECT *)a1[1];
  v3 = v2->nid - 1;
  v2->nid = v3;
  if (!v3)
    ASN1_OBJECT_free(v2);
  free(a1);
}

int OBJ_new_nid(int num)
{
  int v1;

  v1 = new_nid;
  new_nid += num;
  return v1;
}

int OBJ_add_object(const ASN1_OBJECT *obj)
{
  LHASH *v2;
  ASN1_OBJECT *v3;
  uint64_t j;
  _QWORD *v5;
  void *v6;
  uint64_t i;
  __int128 v9;
  __int128 v10;
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  v9 = 0u;
  v10 = 0u;
  if (!added)
  {
    v2 = lh_new((LHASH_HASH_FN_TYPE)added_obj_LHASH_HASH, (LHASH_COMP_FN_TYPE)added_obj_LHASH_COMP);
    added = (uint64_t)v2;
    if (!v2)
      return (int)v2;
  }
  v3 = OBJ_dup(obj);
  if (!v3)
  {
LABEL_18:
    for (i = 0; i != 32; i += 8)
      free(*(void **)((char *)&v9 + i));
    ASN1_OBJECT_free(v3);
    LODWORD(v2) = 0;
    return (int)v2;
  }
  *((_QWORD *)&v10 + 1) = malloc_type_malloc(0x10uLL, 0x1020040D5A9D86FuLL);
  if (!*((_QWORD *)&v10 + 1)
    || v3->length && obj->data && (*(_QWORD *)&v9 = malloc_type_malloc(0x10uLL, 0x1020040D5A9D86FuLL), !(_QWORD)v9)
    || v3->sn && (*((_QWORD *)&v9 + 1) = malloc_type_malloc(0x10uLL, 0x1020040D5A9D86FuLL)) == 0
    || v3->ln && (*(_QWORD *)&v10 = malloc_type_malloc(0x10uLL, 0x1020040D5A9D86FuLL), !(_QWORD)v10))
  {
    ERR_put_error(8, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/objects/obj_dat.c", 334);
    goto LABEL_18;
  }
  for (j = 0; j != 4; ++j)
  {
    v5 = (_QWORD *)*((_QWORD *)&v9 + j);
    if (v5)
    {
      *(_DWORD *)v5 = j;
      v5[1] = v3;
      v6 = lh_insert((LHASH *)added, v5);
      free(v6);
    }
  }
  v3->flags &= 0xFFFFFFF2;
  LODWORD(v2) = v3->nid;
  return (int)v2;
}

ASN1_OBJECT *__cdecl OBJ_nid2obj(int n)
{
  unsigned int v1;
  void *v2;
  int v4;
  __int128 v5;
  __int128 v6;
  uint64_t v7;
  _QWORD data[2];

  if (n <= 0x41C)
  {
    if (!n)
    {
      v1 = 0;
      return (ASN1_OBJECT *)&nid_objs[5 * v1];
    }
    if (LODWORD(nid_objs[5 * n + 2]))
    {
      v1 = n;
      return (ASN1_OBJECT *)&nid_objs[5 * v1];
    }
    v4 = 350;
    goto LABEL_12;
  }
  if (added)
  {
    v5 = 0u;
    v6 = 0u;
    v7 = 0;
    data[0] = 3;
    data[1] = &v5;
    LODWORD(v6) = n;
    v2 = lh_retrieve((LHASH *)added, data);
    if (v2)
      return (ASN1_OBJECT *)*((_QWORD *)v2 + 1);
    v4 = 364;
LABEL_12:
    ERR_put_error(8, 4095, 101, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/objects/obj_dat.c", v4);
  }
  return 0;
}

const char *__cdecl OBJ_nid2sn(int n)
{
  unsigned int v1;
  void *v2;
  int v4;
  __int128 v5;
  __int128 v6;
  uint64_t v7;
  _QWORD data[2];

  if (n <= 0x41C)
  {
    if (!n)
    {
      v1 = 0;
      return nid_objs[5 * v1];
    }
    if (LODWORD(nid_objs[5 * n + 2]))
    {
      v1 = n;
      return nid_objs[5 * v1];
    }
    v4 = 378;
    goto LABEL_12;
  }
  if (added)
  {
    v5 = 0u;
    v6 = 0u;
    v7 = 0;
    data[0] = 3;
    data[1] = &v5;
    LODWORD(v6) = n;
    v2 = lh_retrieve((LHASH *)added, data);
    if (v2)
      return (const char *)**((_QWORD **)v2 + 1);
    v4 = 392;
LABEL_12:
    ERR_put_error(8, 4095, 101, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/objects/obj_dat.c", v4);
  }
  return 0;
}

const char *__cdecl OBJ_nid2ln(int n)
{
  unsigned int v1;
  void *v2;
  char **v3;
  int v5;
  __int128 v6;
  __int128 v7;
  uint64_t v8;
  _QWORD data[2];

  if (n <= 0x41C)
  {
    if (!n)
    {
      v1 = 0;
      goto LABEL_9;
    }
    if (LODWORD(nid_objs[5 * n + 2]))
    {
      v1 = n;
LABEL_9:
      v3 = &nid_objs[5 * v1];
      return v3[1];
    }
    v5 = 406;
    goto LABEL_13;
  }
  if (added)
  {
    v6 = 0u;
    v7 = 0u;
    v8 = 0;
    data[0] = 3;
    data[1] = &v6;
    LODWORD(v7) = n;
    v2 = lh_retrieve((LHASH *)added, data);
    if (v2)
    {
      v3 = (char **)*((_QWORD *)v2 + 1);
      return v3[1];
    }
    v5 = 420;
LABEL_13:
    ERR_put_error(8, 4095, 101, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/objects/obj_dat.c", v5);
  }
  return 0;
}

int OBJ_obj2nid(const ASN1_OBJECT *o)
{
  const ASN1_OBJECT *v1;
  int length;
  void *v3;
  char **v4;
  int v5;
  size_t v6;
  int v7;
  int v8;
  int v9;
  unsigned int v10;
  int v11;
  int v12;
  uint64_t v14;
  const ASN1_OBJECT *v15;

  if (o)
  {
    v1 = o;
    length = o->length;
    if (!length)
    {
LABEL_18:
      LODWORD(o) = 0;
      return (int)o;
    }
    LODWORD(o) = o->nid;
    if (!(_DWORD)o)
    {
      v14 = 0;
      v15 = 0;
      if (added)
      {
        v15 = v1;
        v3 = lh_retrieve((LHASH *)added, &v14);
        if (v3)
        {
          v4 = (char **)*((_QWORD *)v3 + 1);
          goto LABEL_20;
        }
        length = v1->length;
      }
      v5 = 0;
      v6 = length;
      v7 = 975;
      while (1)
      {
        v8 = v5 + v7;
        if (v5 + v7 < 0 != __OFADD__(v5, v7))
          ++v8;
        v9 = v8 >> 1;
        v10 = obj_objs[v8 >> 1];
        v11 = HIDWORD(nid_objs[5 * v10 + 2]);
        v12 = v6 - v11;
        if ((_DWORD)v6 == v11)
        {
          v12 = memcmp(v1->data, nid_objs[5 * v10 + 3], v6);
          if (v12 < 0)
          {
LABEL_16:
            v7 = v9;
            goto LABEL_17;
          }
        }
        else if (v12 < 0)
        {
          goto LABEL_16;
        }
        if (!v12)
        {
          v4 = &nid_objs[5 * v10];
LABEL_20:
          LODWORD(o) = *((_DWORD *)v4 + 4);
          return (int)o;
        }
        v5 = v9 + 1;
LABEL_17:
        if (v5 >= v7)
          goto LABEL_18;
      }
    }
  }
  return (int)o;
}

ASN1_OBJECT *__cdecl OBJ_txt2obj(const char *s, int no_name)
{
  int v4;

  if (!no_name && ((v4 = OBJ_sn2nid(s)) != 0 || (v4 = OBJ_ln2nid(s)) != 0))
    return OBJ_nid2obj(v4);
  else
    return t2i_ASN1_OBJECT_internal(s);
}

int OBJ_sn2nid(const char *s)
{
  const char *v1;
  void *v2;
  char **v3;
  int v4;
  uint64_t v5;
  int v6;
  uint64_t v7;
  unsigned int v8;
  int v9;
  uint64_t data;
  const char **v12;
  const char *v13;
  __int128 v14;
  __int128 v15;

  v1 = s;
  v14 = 0u;
  v15 = 0u;
  data = 0;
  v12 = 0;
  v13 = s;
  if (!added)
    goto LABEL_5;
  LODWORD(data) = 1;
  v12 = &v13;
  v2 = lh_retrieve((LHASH *)added, &data);
  if (!v2)
  {
    v1 = v13;
LABEL_5:
    v4 = 0;
    v5 = 1046;
    while (1)
    {
      v6 = v4 + v5;
      if (v4 + (int)v5 < 0 != __OFADD__(v4, (_DWORD)v5))
        ++v6;
      v7 = (v6 >> 1);
      v8 = sn_objs[(int)v7];
      v9 = strcmp(v1, nid_objs[5 * v8]);
      if ((v9 & 0x80000000) == 0)
      {
        if (!v9)
        {
          v3 = &nid_objs[5 * v8];
          return *((_DWORD *)v3 + 4);
        }
        v4 = v7 + 1;
        v7 = v5;
      }
      v5 = v7;
      if (v4 >= (int)v7)
        return 0;
    }
  }
  v3 = (char **)*((_QWORD *)v2 + 1);
  return *((_DWORD *)v3 + 4);
}

int OBJ_ln2nid(const char *s)
{
  const char *v1;
  void *v2;
  char **v3;
  int v4;
  uint64_t v5;
  int v6;
  uint64_t v7;
  unsigned int v8;
  int v9;
  uint64_t v11;
  uint64_t *v12;
  uint64_t v13;
  const char *v14;
  __int128 v15;
  uint64_t v16;

  v1 = s;
  v13 = 0;
  v15 = 0u;
  v11 = 0;
  v12 = 0;
  v16 = 0;
  v14 = s;
  if (!added)
    goto LABEL_5;
  LODWORD(v11) = 2;
  v12 = &v13;
  v2 = lh_retrieve((LHASH *)added, &v11);
  if (!v2)
  {
    v1 = v14;
LABEL_5:
    v4 = 0;
    v5 = 1046;
    while (1)
    {
      v6 = v4 + v5;
      if (v4 + (int)v5 < 0 != __OFADD__(v4, (_DWORD)v5))
        ++v6;
      v7 = (v6 >> 1);
      v8 = ln_objs[(int)v7];
      v9 = strcmp(v1, nid_objs[5 * v8 + 1]);
      if ((v9 & 0x80000000) == 0)
      {
        if (!v9)
        {
          v3 = &nid_objs[5 * v8];
          return *((_DWORD *)v3 + 4);
        }
        v4 = v7 + 1;
        v7 = v5;
      }
      v5 = v7;
      if (v4 >= (int)v7)
        return 0;
    }
  }
  v3 = (char **)*((_QWORD *)v2 + 1);
  return *((_DWORD *)v3 + 4);
}

int OBJ_obj2txt(char *buf, int buf_len, const ASN1_OBJECT *a, int no_name)
{
  return i2t_ASN1_OBJECT_internal((ASN1_OBJECT *)a, buf, buf_len, no_name);
}

int OBJ_txt2nid(const char *s)
{
  ASN1_OBJECT *v1;
  int v2;

  v1 = OBJ_txt2obj(s, 0);
  v2 = OBJ_obj2nid(v1);
  ASN1_OBJECT_free(v1);
  return v2;
}

const char *__cdecl OBJ_bsearch_(const char *key, const char *base, int num, int size, int (__cdecl *cmp)(const void *, const void *))
{
  int v7;
  int v10;
  int v11;
  int v12;
  const char *v13;
  int v14;

  if (num >= 1)
  {
    v7 = num;
    v10 = 0;
    do
    {
      v11 = v10 + v7;
      if (v10 + v7 < 0 != __OFADD__(v10, v7))
        ++v11;
      v12 = v11 >> 1;
      v13 = &base[(v11 >> 1) * size];
      v14 = ((uint64_t (*)(const char *, const char *))cmp)(key, v13);
      if (v14 < 0)
      {
        v7 = v12;
      }
      else
      {
        if (!v14)
          return v13;
        v10 = v12 + 1;
      }
    }
    while (v10 < v7);
  }
  return 0;
}

const char *__cdecl OBJ_bsearch_ex_(const char *key, const char *base, int num, int size, int (__cdecl *cmp)(const void *, const void *), int flags)
{
  char v6;
  uint64_t v9;
  int v12;
  int v13;
  uint64_t v14;
  const char *v15;
  int v16;
  uint64_t v17;
  char v18;
  uint64_t v19;
  int v20;
  const char *v21;
  int v23;

  if (!num)
    return 0;
  v6 = flags;
  v9 = *(_QWORD *)&num;
  if (num < 1)
  {
    v18 = 0;
    v15 = 0;
    LODWORD(v14) = 0;
    if ((flags & 2) == 0)
      return v15;
  }
  else
  {
    v12 = 0;
    do
    {
      v13 = v9 + v12;
      if ((int)v9 + v12 < 0 != __OFADD__((_DWORD)v9, v12))
        ++v13;
      v14 = (v13 >> 1);
      v15 = &base[(int)v14 * (uint64_t)size];
      v16 = ((uint64_t (*)(const char *, const char *))cmp)(key, v15);
      v17 = v14;
      if ((v16 & 0x80000000) == 0)
      {
        if (!v16)
        {
          v18 = 0;
          if ((v6 & 2) != 0)
            goto LABEL_17;
          return v15;
        }
        v12 = v14 + 1;
        v17 = v9;
      }
      v9 = v17;
    }
    while (v12 < (int)v17);
    if ((v6 & 1) == 0)
      return 0;
    v18 = 1;
    if ((v6 & 2) == 0)
      return v15;
  }
LABEL_17:
  if ((v18 & 1) == 0)
  {
    v19 = (int)v14;
    v20 = v14 & ((int)v14 >> 31);
    v21 = &base[((int)v14 - 1) * (uint64_t)size];
    while (v19-- >= 1)
    {
      v23 = ((uint64_t (*)(const char *, const char *))cmp)(key, v21);
      v21 -= size;
      if (v23)
      {
        v20 = v19 + 1;
        return &base[v20 * (uint64_t)size];
      }
    }
    return &base[v20 * (uint64_t)size];
  }
  return v15;
}

int OBJ_create_objects(BIO *in)
{
  int v2;
  const char *v3;
  int v4;
  uint64_t v5;
  const char *v6;
  int v7;
  int v8;
  unsigned int v9;
  unsigned __int8 v11;
  int v12;
  uint64_t v13;
  unsigned int v14;
  unsigned int v15;
  unsigned __int8 v16;
  int v17;
  uint64_t v18;
  char v20;
  char buf[512];
  uint64_t v22;

  v22 = *MEMORY[0x24BDAC8D0];
  v2 = BIO_gets(in, buf, 512);
  if (v2 < 1)
    return 0;
  v3 = 0;
  v4 = 0;
  v5 = MEMORY[0x24BDAC740];
  do
  {
    buf[v2 - 1] = 0;
    if (buf[0] < 0)
    {
      if (!__maskrune(buf[0], 0x500uLL))
        return v4;
    }
    else if ((*(_DWORD *)(v5 + 4 * buf[0] + 60) & 0x500) == 0)
    {
      return v4;
    }
    v6 = &v20;
    do
    {
      v8 = *(unsigned __int8 *)++v6;
      v7 = v8;
      v9 = v8 - 48;
    }
    while (v8 == 46 || v9 < 0xA);
    if (!v7)
      goto LABEL_28;
    *v6 = 0;
    do
    {
      while (1)
      {
        v12 = *++v6;
        v11 = v12;
        v13 = v12;
        if (v12 < 0)
          break;
        if ((*(_DWORD *)(v5 + 4 * v13 + 60) & 0x4000) == 0)
          goto LABEL_19;
      }
    }
    while (__maskrune(v11, 0x4000uLL));
LABEL_19:
    if (!(_DWORD)v13)
    {
LABEL_28:
      v6 = 0;
      goto LABEL_39;
    }
    v14 = *(unsigned __int8 *)v6;
    if (!*v6)
    {
LABEL_38:
      v3 = 0;
      goto LABEL_39;
    }
    v3 = v6;
    while ((v14 & 0x80) == 0)
    {
      if ((*(_DWORD *)(v5 + 4 * v14 + 60) & 0x4000) != 0)
        goto LABEL_29;
LABEL_26:
      v15 = *(unsigned __int8 *)++v3;
      v14 = v15;
      if (!v15)
        goto LABEL_38;
    }
    if (!__maskrune(v14, 0x4000uLL))
      goto LABEL_26;
LABEL_29:
    if (!*v3)
      goto LABEL_38;
    *v3 = 0;
    do
    {
      while (1)
      {
        v17 = *++v3;
        v16 = v17;
        v18 = v17;
        if (v17 < 0)
          break;
        if ((*(_DWORD *)(v5 + 4 * v18 + 60) & 0x4000) == 0)
          goto LABEL_35;
      }
    }
    while (__maskrune(v16, 0x4000uLL));
LABEL_35:
    if (!(_DWORD)v18)
      v3 = 0;
LABEL_39:
    if (!buf[0])
      break;
    if (!OBJ_create(buf, v6, v3))
      break;
    ++v4;
    v2 = BIO_gets(in, buf, 512);
  }
  while (v2 > 0);
  return v4;
}

int OBJ_create(const char *oid, const char *sn, const char *ln)
{
  int v6;
  int v7;
  unsigned __int8 *v8;
  unsigned __int8 *v9;
  int v10;
  int v11;
  int v12;
  ASN1_OBJECT *v13;
  ASN1_OBJECT *v14;
  int v15;

  v6 = a2d_ASN1_OBJECT(0, 0, oid, -1);
  if (v6 < 1)
    return 0;
  v7 = v6;
  v8 = (unsigned __int8 *)malloc_type_malloc(v6, 0x618C04BBuLL);
  if (!v8)
  {
    ERR_put_error(8, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/objects/obj_dat.c", 663);
    return 0;
  }
  v9 = v8;
  v10 = a2d_ASN1_OBJECT(v8, v7, oid, -1);
  if (v10)
  {
    v11 = v10;
    v12 = new_nid++;
    v13 = ASN1_OBJECT_create(v12, v9, v11, sn, ln);
    v14 = v13;
    if (v13)
      v15 = OBJ_add_object(v13);
    else
      v15 = 0;
  }
  else
  {
    v15 = 0;
    v14 = 0;
  }
  ASN1_OBJECT_free(v14);
  free(v9);
  return v15;
}

uint64_t OBJ_length(uint64_t result)
{
  if (result)
    return *(_DWORD *)(result + 20) & ~(*(int *)(result + 20) >> 31);
  return result;
}

uint64_t OBJ_get0_data(uint64_t result)
{
  if (result)
    return *(_QWORD *)(result + 24);
  return result;
}

unint64_t added_obj_LHASH_HASH(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  int v4;
  unsigned int v5;
  unsigned __int8 *v6;
  int v7;
  unint64_t v8;
  const char *v9;

  v2 = *(_QWORD *)(a1 + 8);
  switch(*(_DWORD *)a1)
  {
    case 0:
      v3 = *(unsigned int *)(v2 + 20);
      v4 = (_DWORD)v3 << 20;
      if ((int)v3 >= 1)
      {
        v5 = 0;
        v6 = *(unsigned __int8 **)(v2 + 24);
        do
        {
          v7 = *v6++;
          v4 ^= v7 << (v5 % 0x18);
          v5 += 3;
          --v3;
        }
        while (v3);
      }
      goto LABEL_11;
    case 1:
      v9 = *(const char **)v2;
      goto LABEL_9;
    case 2:
      v9 = *(const char **)(v2 + 8);
LABEL_9:
      v4 = lh_strhash(v9);
      goto LABEL_11;
    case 3:
      v4 = *(_DWORD *)(v2 + 16);
LABEL_11:
      v8 = (int)(*(_DWORD *)a1 << 30) & 0xFFFFFFFFC0000000 | v4 & 0x3FFFFFFF;
      break;
    default:
      v8 = 0;
      break;
  }
  return v8;
}

uint64_t added_obj_LHASH_COMP(int *a1, uint64_t a2)
{
  int v3;
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  size_t v7;
  int v8;
  const char *v9;
  const char *v10;

  v3 = *a1;
  result = (*a1 - *(_DWORD *)a2);
  if (v3 == *(_DWORD *)a2)
  {
    v5 = *((_QWORD *)a1 + 1);
    v6 = *(_QWORD *)(a2 + 8);
    switch(v3)
    {
      case 0:
        v7 = *(int *)(v5 + 20);
        v8 = *(_DWORD *)(v6 + 20);
        result = (v7 - v8);
        if ((_DWORD)v7 == v8)
          result = memcmp(*(const void **)(v5 + 24), *(const void **)(v6 + 24), v7);
        break;
      case 1:
        v9 = *(const char **)v5;
        if (!*(_QWORD *)v5)
          goto LABEL_14;
        v10 = *(const char **)v6;
        if (!*(_QWORD *)v6)
          goto LABEL_15;
        goto LABEL_9;
      case 2:
        v9 = *(const char **)(v5 + 8);
        if (v9)
        {
          v10 = *(const char **)(v6 + 8);
          if (v10)
LABEL_9:
            result = strcmp(v9, v10);
          else
LABEL_15:
            result = 1;
        }
        else
        {
LABEL_14:
          result = 0xFFFFFFFFLL;
        }
        break;
      case 3:
        result = (*(_DWORD *)(v5 + 16) - *(_DWORD *)(v6 + 16));
        break;
      default:
        result = 0;
        break;
    }
  }
  return result;
}

void RC2_cbc_encrypt(const unsigned __int8 *in, unsigned __int8 *out, uint64_t length, RC2_KEY *ks, unsigned __int8 *iv, int enc)
{
  unsigned __int8 *v6;
  uint64_t v8;
  unint64_t v11;
  unint64_t v12;
  unsigned __int8 *v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  const unsigned __int8 *v18;
  unint64_t v19;
  unsigned int v20;
  unsigned int v21;
  unsigned int v22;
  unsigned int v23;
  unsigned int v24;
  unsigned int v25;
  unint64_t v26;
  unint64_t v27;
  unint64_t v28;
  unint64_t v29;
  unint64_t v30;
  unint64_t v31;
  unsigned __int8 *v32;
  int v33;
  int v34;
  unint64_t v35;
  const unsigned __int8 *v36;
  __int16 v37;
  int v38;
  int v39;
  unint64_t v40;
  int v41;
  int v42;
  unsigned __int8 *v43;
  unint64_t data;
  unint64_t v46;
  uint64_t v47;

  v6 = iv;
  v8 = length;
  v47 = *MEMORY[0x24BDAC8D0];
  v11 = *(unsigned int *)iv;
  v12 = *((unsigned int *)iv + 1);
  if (enc)
  {
    if (length >= 8)
    {
      do
      {
        v13 = out;
        v14 = v8;
        v8 -= 8;
        v15 = *(unsigned int *)in;
        v16 = *((unsigned int *)in + 1);
        in += 8;
        data = v11 ^ v15;
        v46 = v12 ^ v16;
        RC2_encrypt(&data, ks);
        v11 = data;
        v12 = v46;
        out += 8;
        *(_DWORD *)v13 = data;
        *((_DWORD *)v13 + 1) = v12;
      }
      while (v14 > 0xF);
    }
    if (v8)
    {
      v17 = 0;
      v18 = &in[v8];
      v19 = 0;
      switch(v8)
      {
        case 1:
          goto LABEL_12;
        case 2:
          goto LABEL_11;
        case 3:
          goto LABEL_10;
        case 4:
          goto LABEL_9;
        case 5:
          goto LABEL_8;
        case 6:
          goto LABEL_7;
        case 7:
          v20 = *--v18;
          v17 = (unint64_t)v20 << 16;
LABEL_7:
          v21 = *--v18;
          v17 |= (unint64_t)v21 << 8;
LABEL_8:
          v22 = *--v18;
          v17 |= v22;
LABEL_9:
          v19 = v17;
          v23 = *--v18;
          v17 = (unint64_t)v23 << 24;
LABEL_10:
          v24 = *--v18;
          v17 |= (unint64_t)v24 << 16;
LABEL_11:
          v25 = *--v18;
          v17 |= (unint64_t)v25 << 8;
LABEL_12:
          v17 |= *(v18 - 1);
          break;
        default:
          v19 = 0;
          break;
      }
      data = v17 ^ v11;
      v46 = v19 ^ v12;
      RC2_encrypt(&data, ks);
      LOBYTE(v11) = data;
      LODWORD(v12) = v46;
      v26 = data >> 8;
      v27 = data >> 16;
      v28 = data >> 24;
      v29 = v46 >> 8;
      v30 = v46 >> 16;
      v31 = v46 >> 24;
      *(_DWORD *)out = data;
      *((_DWORD *)out + 1) = v12;
    }
    else
    {
      v26 = v11 >> 8;
      v29 = v12 >> 8;
      v30 = v12 >> 16;
      v31 = v12 >> 24;
      v28 = v11 >> 24;
      v27 = v11 >> 16;
    }
    *v6 = v11;
    v6[1] = v26;
    v6[2] = v27;
    v6[3] = v28;
    v6[4] = v12;
    v6[5] = v29;
  }
  else
  {
    if (length >= 8)
    {
      do
      {
        v32 = out;
        v33 = v11;
        v34 = v12;
        LODWORD(v11) = *(_DWORD *)in;
        v12 = *((unsigned int *)in + 1);
        v35 = v8;
        v8 -= 8;
        v36 = in + 8;
        data = *(unsigned int *)in;
        v46 = v12;
        RC2_decrypt(&data, ks);
        v37 = WORD1(data) ^ HIWORD(v33);
        v38 = v46 ^ v34;
        *(_WORD *)v32 = data ^ v33;
        *((_WORD *)v32 + 1) = v37;
        *((_DWORD *)v32 + 1) = v38;
        out = v32 + 8;
        in += 8;
      }
      while (v35 > 0xF);
      in = v36;
      v6 = iv;
    }
    if (v8)
    {
      v39 = *(_DWORD *)in;
      data = *(unsigned int *)in;
      v40 = *((unsigned int *)in + 1);
      v46 = v40;
      RC2_decrypt(&data, ks);
      v41 = data ^ v11;
      v42 = v46 ^ v12;
      v43 = &out[v8];
      switch(v8)
      {
        case 1:
          goto LABEL_25;
        case 2:
          goto LABEL_24;
        case 3:
          goto LABEL_23;
        case 4:
          goto LABEL_22;
        case 5:
          goto LABEL_21;
        case 6:
          goto LABEL_20;
        case 7:
          *--v43 = BYTE2(v42);
LABEL_20:
          *--v43 = BYTE1(v42);
LABEL_21:
          *--v43 = v42;
LABEL_22:
          *--v43 = HIBYTE(v41);
LABEL_23:
          *--v43 = BYTE2(v41);
LABEL_24:
          *--v43 = BYTE1(v41);
LABEL_25:
          *(v43 - 1) = v41;
          break;
        default:
          break;
      }
    }
    else
    {
      v39 = v11;
      v40 = v12;
    }
    *(_DWORD *)v6 = v39;
    *((_WORD *)v6 + 2) = v40;
    v30 = v40 >> 16;
    v31 = v40 >> 24;
  }
  v6[6] = v30;
  v6[7] = v31;
}

void RC2_encrypt(unint64_t *data, RC2_KEY *key)
{
  int v2;
  unint64_t v3;
  unsigned int v4;
  unint64_t v5;
  int v6;
  RC2_KEY *v7;
  int v8;
  unsigned int v9;
  int v10;
  int v11;
  RC2_KEY *v12;

  v2 = (unsigned __int16)*data;
  v3 = *data >> 16;
  v4 = (unsigned __int16)data[1];
  v5 = data[1] >> 16;
  v6 = 3;
  v7 = key;
  v8 = 5;
  while (1)
  {
    do
    {
      v9 = (v3 & ~(_DWORD)v5) + v2 + (v5 & v4) + v7->data[0];
      v2 = (v9 >> 15) & 1 | (2 * (unsigned __int16)v9);
      v10 = v7->data[1] + v3 + (v4 & ~v2) + (v2 & v5);
      LODWORD(v3) = ((unsigned __int16)v10 >> 14) & 0xFFFC0003 | (4 * (unsigned __int16)v10);
      v11 = v7->data[2] + v4 + (v5 & ~(_DWORD)v3) + (v3 & v2);
      v4 = ((unsigned __int16)v11 >> 13) & 0xFFF80007 | (8 * (unsigned __int16)v11);
      v12 = (RC2_KEY *)&v7->data[4];
      LODWORD(v5) = ((unsigned __int16)(v7->data[3] + v5 + (v2 & ~(_WORD)v4) + (v4 & v3)) >> 11) & 0xFFE0001F | (32 * (unsigned __int16)(v7->data[3] + v5 + (v2 & ~(_WORD)v4) + (v4 & v3)));
      v7 = (RC2_KEY *)((char *)v7 + 16);
      --v8;
    }
    while (v8);
    if (!--v6)
      break;
    if (v6 == 2)
      v8 = 6;
    else
      v8 = 5;
    v2 += key->data[v5 & 0x3F];
    LODWORD(v3) = key->data[v2 & 0x3F] + v3;
    v4 += key->data[v3 & 0x3F];
    LODWORD(v5) = key->data[v4 & 0x3F] + v5;
    v7 = v12;
  }
  *data = (unsigned __int16)v2 | ((unsigned __int16)v3 << 16);
  data[1] = (unsigned __int16)v4 | ((unsigned __int16)v5 << 16);
}

void RC2_decrypt(unint64_t *data, RC2_KEY *key)
{
  unsigned int v2;
  unint64_t v3;
  unsigned int v4;
  unint64_t v5;
  unsigned int *v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;

  v2 = (unsigned __int16)*data;
  v3 = *data >> 16;
  v4 = (unsigned __int16)data[1];
  v5 = data[1] >> 16;
  v6 = &key->data[63];
  v7 = 3;
  v8 = 5;
  while (1)
  {
    v9 = (((_DWORD)v5 << 11) | (v5 >> 5)) - (v2 & ~v4 | v4 & v3) - *v6;
    LODWORD(v5) = (unsigned __int16)((((_WORD)v5 << 11) | (v5 >> 5))
                                   - (v2 & ~(_WORD)v4 | v4 & v3)
                                   - *(_WORD *)v6);
    v10 = ((v4 << 13) | (v4 >> 3)) - ((v3 & v2) + *(v6 - 1)) - (v9 & ~(_DWORD)v3);
    v4 = (unsigned __int16)((((_WORD)v4 << 13) | (v4 >> 3)) - ((v3 & v2) + *((_WORD *)v6 - 2)) - (v9 & ~(_WORD)v3));
    v11 = *(v6 - 3);
    LODWORD(v3) = (((_DWORD)v3 << 14) | (v3 >> 2)) - (*(v6 - 2) + (v9 & v2)) - (v10 & ~v2);
    v12 = ((v2 << 15) | (v2 >> 1)) - v11 - (v3 & ~(_DWORD)v5 | v10 & v9);
    v2 = (unsigned __int16)((((_WORD)v2 << 15) | (v2 >> 1)) - v11 - (v3 & ~(_WORD)v5 | v10 & v9));
    if (--v8)
      goto LABEL_8;
    if (!--v7)
      break;
    if (v7 == 2)
      v8 = 6;
    else
      v8 = 5;
    LODWORD(v5) = (unsigned __int16)(v9 - key->data[v10 & 0x3F]);
    v4 = (unsigned __int16)(v10 - key->data[v3 & 0x3F]);
    LODWORD(v3) = v3 - key->data[v12 & 0x3F];
    v2 = (unsigned __int16)(v12 - key->data[((_BYTE)v9 - key->data[v10 & 0x3F]) & 0x3F]);
LABEL_8:
    LODWORD(v3) = (unsigned __int16)v3;
    v6 -= 4;
  }
  *data = v2 | ((_DWORD)v3 << 16);
  data[1] = v4 | (v9 << 16);
}

uint64_t CRYPTO_cfb128_encrypt(uint64_t result, _BYTE *a2, unint64_t a3, uint64_t a4, uint64_t a5, unsigned int *a6, int a7, uint64_t (*a8)(uint64_t, uint64_t, uint64_t))
{
  char *v13;
  unsigned int v14;
  BOOL v15;
  int v16;
  char v17;
  char v18;
  unint64_t v19;
  char v20;
  unint64_t v21;
  unint64_t v22;
  uint64_t v23;
  BOOL v24;
  unsigned int v25;
  char v26;
  unint64_t v27;
  uint64_t v28;
  char v29;

  v13 = (char *)result;
  v14 = *a6;
  if (*a6)
    v15 = a3 == 0;
  else
    v15 = 1;
  v16 = !v15;
  if (a7)
  {
    if (v16)
    {
      do
      {
        v17 = *v13++;
        v18 = *(_BYTE *)(a5 + v14);
        *(_BYTE *)(a5 + v14) = v18 ^ v17;
        *a2++ = v18 ^ v17;
        v19 = a3 - 1;
        v14 = ((_BYTE)v14 + 1) & 0xF;
        if (!v14)
          break;
        --a3;
      }
      while (a3);
    }
    else
    {
      v19 = a3;
    }
    if (v19 < 0x10)
    {
      v25 = v14;
      if (!v19)
        goto LABEL_41;
    }
    else
    {
      do
      {
        result = a8(a5, a5, a4);
        if (v14 <= 0xF)
        {
          v22 = v14;
          do
          {
            v23 = *(_QWORD *)(a5 + v22) ^ *(_QWORD *)&v13[v22];
            *(_QWORD *)(a5 + v22) = v23;
            *(_QWORD *)&a2[v22] = v23;
            v24 = v22 >= 8;
            v22 += 8;
          }
          while (!v24);
        }
        v14 = 0;
        v25 = 0;
        v19 -= 16;
        a2 += 16;
        v13 += 16;
      }
      while (v19 > 0xF);
      if (!v19)
        goto LABEL_41;
    }
    result = a8(a5, a5, a4);
    do
    {
      v26 = *(_BYTE *)(a5 + v25) ^ v13[v25];
      *(_BYTE *)(a5 + v25) = v26;
      a2[v25++] = v26;
      --v19;
    }
    while (v19);
    goto LABEL_41;
  }
  if (v16)
  {
    do
    {
      v20 = *v13++;
      *a2++ = v20 ^ *(_BYTE *)(a5 + v14);
      *(_BYTE *)(a5 + v14) = v20;
      v21 = a3 - 1;
      v14 = ((_BYTE)v14 + 1) & 0xF;
      if (!v14)
        break;
      --a3;
    }
    while (a3);
  }
  else
  {
    v21 = a3;
  }
  if (v21 < 0x10)
  {
    v25 = v14;
    if (!v21)
      goto LABEL_41;
    goto LABEL_39;
  }
  do
  {
    result = a8(a5, a5, a4);
    if (v14 <= 0xF)
    {
      v27 = v14;
      do
      {
        v28 = *(_QWORD *)&v13[v27];
        *(_QWORD *)&a2[v27] = *(_QWORD *)(a5 + v27) ^ v28;
        *(_QWORD *)(a5 + v27) = v28;
        v24 = v27 >= 8;
        v27 += 8;
      }
      while (!v24);
    }
    v14 = 0;
    v25 = 0;
    v21 -= 16;
    a2 += 16;
    v13 += 16;
  }
  while (v21 > 0xF);
  if (v21)
  {
LABEL_39:
    result = a8(a5, a5, a4);
    do
    {
      v29 = v13[v25];
      a2[v25] = v29 ^ *(_BYTE *)(a5 + v25);
      *(_BYTE *)(a5 + v25++) = v29;
      --v21;
    }
    while (v21);
  }
LABEL_41:
  *a6 = v25;
  return result;
}

int8x16_t CRYPTO_cfb128_1_encrypt(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7, void (*a8)(uint64_t, uint64_t, uint64_t))
{
  unint64_t i;
  const char *v16;
  int8x16_t v17;
  char v18;
  char v19;
  __int8 v20;
  uint8x16_t v21;
  int8x16_t v22;
  int8x16_t result;
  int8x16_t v24;
  int8x16_t v25;
  int v26;

  if (a3)
  {
    for (i = 0; i != a3; ++i)
    {
      v26 = 1 << (i & 7 ^ 7);
      v16 = (const char *)a5;
      v17 = vld1q_dup_s8(v16++);
      v25 = v17;
      v18 = (v26 & *(_BYTE *)(a1 + (i >> 3))) != 0;
      v17.i64[0] = *(_QWORD *)v16;
      v17.i32[2] = *(_DWORD *)(a5 + 9);
      v17.i16[6] = *(_WORD *)(a5 + 13);
      v17.i8[14] = *(_BYTE *)(a5 + 15);
      v24 = v17;
      a8(a5, a5, a4);
      v19 = *(_BYTE *)a5 ^ (v18 << 7);
      v20 = v18 << 7;
      if (a7)
        v20 = *(_BYTE *)a5 ^ (v18 << 7);
      v21 = (uint8x16_t)v24;
      v22 = vextq_s8(v25, v24, 0xFuLL);
      v21.i8[15] = v20;
      result = vorrq_s8(vaddq_s8(v22, v22), (int8x16_t)vshrq_n_u8(vshrq_n_u8(v21, 1uLL), 6uLL));
      *(int8x16_t *)a5 = result;
      *(_BYTE *)(a2 + (i >> 3)) = *(_BYTE *)(a2 + (i >> 3)) & ~(_BYTE)v26 | ((v19 & 0x80) >> (i & 7));
    }
  }
  return result;
}

uint64_t CRYPTO_cfb128_8_encrypt(uint64_t result, _BYTE *a2, uint64_t a3, uint64_t a4, __int128 *a5, uint64_t a6, int a7, uint64_t (*a8)(__int128 *, __int128 *, uint64_t))
{
  uint64_t v12;
  char *v14;
  char v15;
  char v16;
  char v17;
  __int128 v18;

  if (a3)
  {
    v12 = a3;
    v14 = (char *)result;
    do
    {
      v18 = *a5;
      result = a8(a5, a5, a4);
      v16 = *v14++;
      v15 = v16;
      v17 = *(_BYTE *)a5 ^ v16;
      if (a7)
        v15 = v17;
      *a2++ = v17;
      *(_QWORD *)a5 = *(_QWORD *)((char *)&v18 + 1);
      *(_QWORD *)((char *)a5 + 7) = *((_QWORD *)&v18 + 1);
      *((_BYTE *)a5 + 15) = v15;
      --v12;
    }
    while (v12);
  }
  return result;
}

void ERR_load_ASN1_strings(void)
{
  if (!ERR_func_error_string(ASN1_str_functs))
  {
    ERR_load_strings(0, (ERR_STRING_DATA *)&ASN1_str_functs);
    ERR_load_strings(0, (ERR_STRING_DATA *)&ASN1_str_reasons);
  }
}

uint64_t CRYPTO_xts128_encrypt(_QWORD *a1, int8x16_t *a2, int8x16_t *a3, __n128 *a4, unint64_t a5, int a6)
{
  unint64_t v6;
  uint64_t result;
  unint64_t v9;
  int8x16_t v13;
  __n128 v14;
  __int128 v16;
  __n128 v17;
  uint64_t v18;
  __int8 v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  __int8 v27;
  int8x16_t v28;
  int8x16_t v29;

  v6 = a5 - 16;
  if (a5 < 0x10)
    return 0xFFFFFFFFLL;
  v9 = a5;
  v13 = *a2;
  v28 = 0u;
  v29 = v13;
  ((void (*)(int8x16_t *, int8x16_t *, _QWORD))a1[3])(&v29, &v29, a1[1]);
  if ((v9 & 0xF) != 0 && a6 == 0)
    v9 = v6;
  if (v9 >= 0x10)
  {
    v14 = (__n128)v29;
    do
    {
      v28 = veorq_s8((int8x16_t)v14, *a3);
      ((void (*)(int8x16_t *, int8x16_t *, _QWORD))a1[2])(&v28, &v28, *a1);
      v16 = (__int128)v29;
      v17 = (__n128)veorq_s8(v28, v29);
      v28 = (int8x16_t)v17;
      *a4 = v17;
      v9 -= 16;
      if (!v9)
        return 0;
      ++a4;
      ++a3;
      v29.i64[0] = (*((uint64_t *)&v16 + 1) >> 63) & 0x87 ^ (2 * v16);
      v29.i64[1] = v16 >> 63;
      v14 = (__n128)v29;
    }
    while (v9 > 0xF);
    if (!a6)
      goto LABEL_20;
    goto LABEL_14;
  }
  v17 = 0uLL;
  if (a6)
  {
LABEL_14:
    if (v9)
    {
      v18 = 0;
      do
      {
        v19 = a3->i8[v18];
        a4->n128_u8[v18] = v28.u8[v18];
        v28.i8[v18++] = v19;
      }
      while (v9 > v18);
      v17 = (__n128)v28;
    }
    v28 = veorq_s8((int8x16_t)v17, v29);
    ((void (*)(int8x16_t *, int8x16_t *, _QWORD))a1[2])(&v28, &v28, *a1);
    result = 0;
    v28 = veorq_s8(v28, v29);
    a4[-1] = (__n128)v28;
    return result;
  }
LABEL_20:
  v20 = 135;
  if (v29.i32[3] >= 0)
    v20 = 0;
  v21 = v20 ^ (2 * v29.i64[0]);
  v22 = *(_OWORD *)&v29 >> 63;
  v23 = a3->i64[1] ^ v22;
  v28.i64[0] = a3->i64[0] ^ v21;
  v28.i64[1] = v23;
  ((void (*)(int8x16_t *, int8x16_t *, _QWORD, __n128, __n128))a1[2])(&v28, &v28, *a1, v14, v17);
  v24 = v28.i64[0] ^ v21;
  v25 = v28.i64[1] ^ v22;
  v28.i64[0] ^= v21;
  v28.i64[1] ^= v22;
  if (v9)
  {
    v26 = 0;
    do
    {
      v27 = a3->i8[(v26 + 16)];
      a4->n128_u8[(v26 + 16)] = v28.u8[v26];
      v28.i8[v26++] = v27;
    }
    while (v9 > v26);
    v25 = v28.i64[1];
    v24 = v28.i64[0];
  }
  v28.i64[0] = v24 ^ v29.i64[0];
  v28.i64[1] = v25 ^ v29.i64[1];
  ((void (*)(int8x16_t *, int8x16_t *, _QWORD))a1[2])(&v28, &v28, *a1);
  result = 0;
  *(int8x16_t *)a4 = veorq_s8(v29, v28);
  return result;
}

int PKCS7_add_attrib_smimecap(PKCS7_SIGNER_INFO *si, STACK *cap)
{
  ASN1_STRING *v4;
  ASN1_STRING *v5;

  v4 = ASN1_STRING_new();
  if (v4)
  {
    v5 = v4;
    v4->length = ASN1_item_i2d((ASN1_VALUE *)cap, &v4->data, &X509_ALGORS_it);
    return PKCS7_add_signed_attribute(si, 167, 16, v5);
  }
  else
  {
    ERR_put_error(33, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/pkcs7/pk7_attr.c", 74);
    return 0;
  }
}

STACK *__cdecl PKCS7_get_smimecap(PKCS7_SIGNER_INFO *si)
{
  STACK *result;
  char **data;
  unsigned __int8 *in;

  result = (STACK *)PKCS7_get_signed_attribute(si, 167);
  if (result)
  {
    if (result->num == 16)
    {
      data = result->data;
      in = (unsigned __int8 *)data[1];
      return (STACK *)ASN1_item_d2i(0, (const unsigned __int8 **)&in, *(int *)data, &X509_ALGORS_it);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

int PKCS7_simple_smimecap(STACK *sk, int nid, int arg)
{
  X509_ALGOR *v6;
  X509_ALGOR *v7;
  ASN1_TYPE *v8;
  ASN1_INTEGER *v9;
  ASN1_INTEGER *v10;

  v6 = X509_ALGOR_new();
  if (v6)
  {
    v7 = v6;
    ASN1_OBJECT_free(v6->algorithm);
    v7->algorithm = OBJ_nid2obj(nid);
    if (arg < 1)
      goto LABEL_7;
    v8 = ASN1_TYPE_new();
    v7->parameter = v8;
    if (v8)
    {
      v9 = ASN1_INTEGER_new();
      if (v9)
      {
        v10 = v9;
        if (ASN1_INTEGER_set(v9, arg))
        {
          v7->parameter->value.ptr = (char *)v10;
          v7->parameter->type = 2;
LABEL_7:
          if (sk_push(sk, (char *)v7))
            return 1;
          goto LABEL_11;
        }
        ASN1_INTEGER_free(v10);
      }
    }
LABEL_11:
    ERR_put_error(33, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/pkcs7/pk7_attr.c", 131);
    X509_ALGOR_free(v7);
    return 0;
  }
  ERR_put_error(33, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/pkcs7/pk7_attr.c", 107);
  return 0;
}

uint64_t PKCS7_add_attrib_content_type(PKCS7_SIGNER_INFO *a1, ASN1_OBJECT *a2)
{
  if (PKCS7_get_signed_attribute(a1, 50))
    return 0;
  if (!a2)
    a2 = OBJ_nid2obj(21);
  return PKCS7_add_signed_attribute(a1, 50, 6, a2);
}

uint64_t PKCS7_add0_attrib_signing_time(PKCS7_SIGNER_INFO *p7si, ASN1_TIME *a2)
{
  ASN1_TIME *v2;

  v2 = a2;
  if (a2)
    return PKCS7_add_signed_attribute(p7si, 52, 23, v2);
  v2 = X509_gmtime_adj(0, 0);
  if (v2)
    return PKCS7_add_signed_attribute(p7si, 52, 23, v2);
  ERR_put_error(33, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/pkcs7/pk7_attr.c", 153);
  return 0;
}

ASN1_OCTET_STRING *PKCS7_add1_attrib_digest(PKCS7_SIGNER_INFO *a1, const void *a2, int a3)
{
  ASN1_OCTET_STRING *result;
  ASN1_OCTET_STRING *v7;

  result = ASN1_OCTET_STRING_new();
  if (result)
  {
    v7 = result;
    if (ASN1_STRING_set(result, a2, a3) && PKCS7_add_signed_attribute(a1, 51, 4, v7))
    {
      return (ASN1_OCTET_STRING *)1;
    }
    else
    {
      ASN1_OCTET_STRING_free(v7);
      return 0;
    }
  }
  return result;
}

X509_SIG *__cdecl d2i_X509_SIG(X509_SIG **a, const unsigned __int8 **in, uint64_t len)
{
  return (X509_SIG *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &X509_SIG_it);
}

int i2d_X509_SIG(X509_SIG *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &X509_SIG_it);
}

X509_SIG *X509_SIG_new(void)
{
  return (X509_SIG *)ASN1_item_new(&X509_SIG_it);
}

void X509_SIG_free(X509_SIG *a)
{
  ASN1_item_free((ASN1_VALUE *)a, &X509_SIG_it);
}

_QWORD *X509_SIG_get0(_QWORD *result, _QWORD *a2, _QWORD *a3)
{
  if (a2)
    *a2 = *result;
  if (a3)
    *a3 = result[1];
  return result;
}

_QWORD *X509_SIG_getm(_QWORD *result, _QWORD *a2, _QWORD *a3)
{
  if (a2)
    *a2 = *result;
  if (a3)
    *a3 = result[1];
  return result;
}

const char *X509_get_default_private_dir(void)
{
  return "/etc/ssl/private";
}

const char *X509_get_default_cert_area(void)
{
  return "/etc/ssl";
}

const char *X509_get_default_cert_dir(void)
{
  return "/etc/ssl/certs";
}

const char *X509_get_default_cert_file(void)
{
  return "/etc/ssl/cert.pem";
}

const char *X509_get_default_cert_dir_env(void)
{
  return "SSL_CERT_DIR";
}

const char *X509_get_default_cert_file_env(void)
{
  return "SSL_CERT_FILE";
}

PKCS8_PRIV_KEY_INFO *__cdecl d2i_PKCS8_PRIV_KEY_INFO(PKCS8_PRIV_KEY_INFO **a, const unsigned __int8 **in, uint64_t len)
{
  return (PKCS8_PRIV_KEY_INFO *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &PKCS8_PRIV_KEY_INFO_it);
}

int i2d_PKCS8_PRIV_KEY_INFO(PKCS8_PRIV_KEY_INFO *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &PKCS8_PRIV_KEY_INFO_it);
}

PKCS8_PRIV_KEY_INFO *PKCS8_PRIV_KEY_INFO_new(void)
{
  return (PKCS8_PRIV_KEY_INFO *)ASN1_item_new(&PKCS8_PRIV_KEY_INFO_it);
}

void PKCS8_PRIV_KEY_INFO_free(PKCS8_PRIV_KEY_INFO *a)
{
  ASN1_item_free((ASN1_VALUE *)a, &PKCS8_PRIV_KEY_INFO_it);
}

uint64_t PKCS8_pkey_set0(uint64_t a1, ASN1_OBJECT *aobj, uint64_t v, int ptype, void *pval, void *a6, int a7)
{
  uint64_t result;

  if ((v & 0x80000000) != 0 || (result = ASN1_INTEGER_set(*(ASN1_INTEGER **)a1, v), (_DWORD)result))
  {
    result = X509_ALGOR_set0(*(X509_ALGOR **)(a1 + 8), aobj, ptype, pval);
    if ((_DWORD)result)
    {
      if (a6)
        ASN1_STRING_set0(*(ASN1_STRING **)(a1 + 16), a6, a7);
      return 1;
    }
  }
  return result;
}

uint64_t PKCS8_pkey_get0(_QWORD *a1, unsigned __int8 **a2, int *a3, _QWORD *a4, uint64_t a5)
{
  if (a1)
    *a1 = **(_QWORD **)(a5 + 8);
  if (a2)
  {
    *a2 = ASN1_STRING_data(*(ASN1_STRING **)(a5 + 16));
    *a3 = ASN1_STRING_length(*(ASN1_STRING **)(a5 + 16));
  }
  if (a4)
    *a4 = *(_QWORD *)(a5 + 8);
  return 1;
}

uint64_t PKCS8_pkey_get0_attrs(uint64_t a1)
{
  return *(_QWORD *)(a1 + 24);
}

BOOL PKCS8_pkey_add1_attr_by_NID(uint64_t a1, int a2, int a3, const unsigned __int8 *a4, int a5)
{
  return X509at_add1_attr_by_NID((STACK **)(a1 + 24), a2, a3, a4, a5) != 0;
}

uint64_t pkey_cb(int a1, uint64_t a2)
{
  void **v2;

  if (a1 == 2)
  {
    v2 = *(void ***)(*(_QWORD *)a2 + 16);
    if (v2)
      explicit_bzero(v2[1], *(int *)v2);
  }
  return 1;
}

void *__cdecl ASN1_dup(i2d_of_void *i2d, d2i_of_void *d2i, char *x)
{
  int v6;
  void *v7;
  void *v8;
  int v9;
  void *v10;
  void *v12;
  void *v13;

  if (!x)
    return 0;
  v6 = ((uint64_t (*)(char *, _QWORD))i2d)(x, 0);
  v7 = malloc_type_malloc(v6 + 10, 0xF23DFE3FuLL);
  if (!v7)
  {
    ERR_put_error(13, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/asn1_old.c", 84);
    return 0;
  }
  v8 = v7;
  v13 = v7;
  v9 = ((uint64_t (*)(char *, void **))i2d)(x, &v13);
  v12 = v8;
  v10 = (void *)((uint64_t (*)(_QWORD, void **, _QWORD))d2i)(0, &v12, v9);
  free(v8);
  return v10;
}

void *__cdecl ASN1_d2i_fp(void *(*xnew)(void), d2i_of_void *d2i, FILE *in, void **x)
{
  BIO_METHOD *v7;
  BIO *v8;
  BIO *v9;
  void *(*v10)(void);
  void *v11;

  v7 = BIO_s_file();
  v8 = BIO_new(v7);
  if (v8)
  {
    v9 = v8;
    v10 = (void *(*)(void))BIO_ctrl(v8, 106, 0, in);
    v11 = ASN1_d2i_bio(v10, d2i, v9, x);
    BIO_free(v9);
    return v11;
  }
  else
  {
    ERR_put_error(13, 4095, 7, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/asn1_old.c", 102);
    return 0;
  }
}

void *__cdecl ASN1_d2i_bio(void *(*xnew)(void), d2i_of_void *d2i, BIO *in, void **x)
{
  unsigned int v6;
  void *v7;
  char *data;
  BUF_MEM *a;

  data = 0;
  a = 0;
  v6 = asn1_d2i_read_bio(in, &a);
  if ((v6 & 0x80000000) != 0)
  {
    v7 = 0;
  }
  else
  {
    data = a->data;
    v7 = (void *)((uint64_t (*)(void **, char **, _QWORD))d2i)(x, &data, v6);
  }
  if (a)
    BUF_MEM_free(a);
  return v7;
}

int ASN1_i2d_fp(i2d_of_void *i2d, FILE *out, void *x)
{
  BIO_METHOD *v6;
  BIO *v7;
  BIO *v8;
  int v9;

  v6 = BIO_s_file();
  v7 = BIO_new(v6);
  if (v7)
  {
    v8 = v7;
    BIO_ctrl(v7, 106, 0, out);
    v9 = ASN1_i2d_bio(i2d, v8, (unsigned __int8 *)x);
    BIO_free(v8);
    return v9;
  }
  else
  {
    ERR_put_error(13, 4095, 7, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/asn1_old.c", 139);
    return 0;
  }
}

int ASN1_i2d_bio(i2d_of_void *i2d, BIO *out, unsigned __int8 *x)
{
  int v6;
  char *v7;
  char *v8;
  int v9;
  int v10;
  int v11;
  char *v13;

  v6 = ((uint64_t (*)(unsigned __int8 *, _QWORD))i2d)(x, 0);
  v7 = (char *)malloc_type_malloc(v6, 0x43814B7FuLL);
  if (v7)
  {
    v8 = v7;
    v13 = v7;
    ((void (*)(unsigned __int8 *, char **))i2d)(x, &v13);
    v9 = BIO_write(out, v8, v6);
    if (v9 == v6)
    {
LABEL_6:
      v11 = 1;
    }
    else
    {
      v10 = 0;
      while (v9 >= 1)
      {
        v10 += v9;
        v6 -= v9;
        v9 = BIO_write(out, &v8[v10], v6);
        if (v9 == v6)
          goto LABEL_6;
      }
      v11 = 0;
    }
    free(v8);
  }
  else
  {
    ERR_put_error(13, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/asn1_old.c", 158);
    return 0;
  }
  return v11;
}

int X509_REQ_set_version(X509_REQ *x, uint64_t version)
{
  X509_REQ_INFO *req_info;

  if (x)
  {
    req_info = x->req_info;
    req_info->enc.modified = 1;
    LODWORD(x) = ASN1_INTEGER_set(req_info->version, version);
  }
  return (int)x;
}

uint64_t X509_REQ_get_version(uint64_t a1)
{
  return ASN1_INTEGER_get(*(ASN1_INTEGER **)(*(_QWORD *)a1 + 24));
}

int X509_REQ_set_subject_name(X509_REQ *req, X509_NAME *name)
{
  X509_REQ_INFO *req_info;

  if (!req)
    return 0;
  req_info = req->req_info;
  if (!req->req_info)
    return 0;
  req_info->enc.modified = 1;
  return X509_NAME_set(&req_info->subject, name);
}

uint64_t X509_REQ_get_subject_name(uint64_t a1)
{
  return *(_QWORD *)(*(_QWORD *)a1 + 32);
}

int X509_REQ_set_pubkey(X509_REQ *x, EVP_PKEY *pkey)
{
  X509_REQ_INFO *req_info;

  if (!x)
    return 0;
  req_info = x->req_info;
  if (!x->req_info)
    return 0;
  req_info->enc.modified = 1;
  return X509_PUBKEY_set(&req_info->pubkey, pkey);
}

X509_NAME_ENTRY *__cdecl d2i_X509_NAME_ENTRY(X509_NAME_ENTRY **a, const unsigned __int8 **in, uint64_t len)
{
  return (X509_NAME_ENTRY *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &X509_NAME_ENTRY_it);
}

int i2d_X509_NAME_ENTRY(X509_NAME_ENTRY *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &X509_NAME_ENTRY_it);
}

X509_NAME_ENTRY *X509_NAME_ENTRY_new(void)
{
  return (X509_NAME_ENTRY *)ASN1_item_new(&X509_NAME_ENTRY_it);
}

void X509_NAME_ENTRY_free(X509_NAME_ENTRY *a)
{
  ASN1_item_free((ASN1_VALUE *)a, &X509_NAME_ENTRY_it);
}

X509_NAME_ENTRY *__cdecl X509_NAME_ENTRY_dup(X509_NAME_ENTRY *ne)
{
  return (X509_NAME_ENTRY *)ASN1_item_dup(&X509_NAME_ENTRY_it, ne);
}

uint64_t x509_name_ex_new(STACK ***a1)
{
  STACK **v2;
  STACK **v3;
  STACK *v4;
  BUF_MEM *v5;
  uint64_t result;

  v2 = (STACK **)malloc_type_malloc(0x28uLL, 0x10300406D22A611uLL);
  if (v2)
  {
    v3 = v2;
    v4 = sk_new_null();
    *v3 = v4;
    if (v4)
    {
      v5 = BUF_MEM_new();
      v3[2] = (STACK *)v5;
      if (v5)
      {
        v3[3] = 0;
        *((_DWORD *)v3 + 8) = 0;
        result = 1;
        *((_DWORD *)v3 + 2) = 1;
        *a1 = v3;
        return result;
      }
    }
    ERR_put_error(13, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/x_name.c", 261);
    if (*v3)
      sk_free(*v3);
    free(v3);
  }
  else
  {
    ERR_put_error(13, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/x_name.c", 261);
  }
  return 0;
}

void x509_name_ex_free(uint64_t *a1)
{
  uint64_t v2;

  if (a1)
  {
    v2 = *a1;
    if (*a1)
    {
      BUF_MEM_free(*(BUF_MEM **)(v2 + 16));
      sk_pop_free(*(STACK **)v2, (void (__cdecl *)(void *))X509_NAME_ENTRY_free);
      free(*(void **)(v2 + 24));
      free((void *)v2);
      *a1 = 0;
    }
  }
}

uint64_t x509_name_ex_d2i(uint64_t *a1, unsigned __int8 **a2, uint64_t a3, uint64_t a4, int a5, int a6, char a7, ASN1_TLC *a8)
{
  unsigned __int8 *v10;
  uint64_t result;
  int v12;
  STACK **v13;
  int v14;
  STACK *v15;
  int v16;
  char *v17;
  STACK **v18;
  ASN1_VALUE *pval;
  unsigned __int8 *in;

  v10 = *a2;
  pval = 0;
  in = v10;
  v18 = 0;
  result = ASN1_item_ex_d2i(&pval, (const unsigned __int8 **)&in, a3, &X509_NAME_INTERNAL_it, a5, a6, a7, a8);
  if ((int)result >= 1)
  {
    if (*a1)
      x509_name_ex_free(a1);
    v12 = x509_name_ex_new(&v18);
    v13 = v18;
    if (v12)
    {
      if (!BUF_MEM_grow((BUF_MEM *)v18[2], (_DWORD)in - (_DWORD)v10))
        goto LABEL_16;
      memcpy(v13[2]->data, v10, in - v10);
      if (sk_num((const STACK *)pval) >= 1)
      {
        v14 = 0;
        while (1)
        {
          v15 = (STACK *)sk_value((const STACK *)pval, v14);
          if (sk_num(v15) >= 1)
            break;
LABEL_12:
          sk_free(v15);
          if (++v14 >= sk_num((const STACK *)pval))
            goto LABEL_13;
        }
        v16 = 0;
        while (1)
        {
          v17 = sk_value(v15, v16);
          *((_DWORD *)v17 + 4) = v14;
          if (!sk_push(*v13, v17))
            goto LABEL_16;
          if (++v16 >= sk_num(v15))
            goto LABEL_12;
        }
      }
LABEL_13:
      sk_free((STACK *)pval);
      if (x509_name_canon((uint64_t)v13))
      {
        *((_DWORD *)v13 + 2) = 0;
        *a1 = (uint64_t)v13;
        *a2 = in;
        return 1;
      }
    }
    if (!v13)
    {
LABEL_17:
      ERR_put_error(13, 4095, 58, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/x_name.c", 343);
      return 0;
    }
LABEL_16:
    ASN1_item_free((ASN1_VALUE *)v13, &X509_NAME_it);
    goto LABEL_17;
  }
  return result;
}

uint64_t x509_name_ex_i2d(uint64_t *a1, void **a2)
{
  uint64_t v3;
  ASN1_VALUE *v4;
  int v5;
  STACK *v6;
  int v7;
  char *v8;
  char *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t *v12;
  unsigned __int8 *v14;
  ASN1_VALUE *pval;

  v3 = *a1;
  if (!*(_DWORD *)(*a1 + 8))
    goto LABEL_16;
  v4 = (ASN1_VALUE *)sk_new_null();
  pval = v4;
  if (!v4)
  {
LABEL_19:
    sk_pop_free((STACK *)v4, (void (__cdecl *)(void *))local_sk_X509_NAME_ENTRY_free);
    ERR_put_error(13, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/x_name.c", 428);
    return 0xFFFFFFFFLL;
  }
  if (sk_num(*(const STACK **)v3) >= 1)
  {
    v5 = 0;
    v6 = 0;
    v7 = -1;
    do
    {
      v8 = sk_value(*(const STACK **)v3, v5);
      if (*((_DWORD *)v8 + 4) == v7)
      {
        if (!v6)
          goto LABEL_19;
      }
      else
      {
        v9 = (char *)sk_new_null();
        if (!v9)
          goto LABEL_19;
        v6 = (STACK *)v9;
        if (!sk_push((STACK *)v4, v9))
          goto LABEL_19;
        v7 = *((_DWORD *)v8 + 4);
      }
      if (!sk_push(v6, v8))
        goto LABEL_19;
      ++v5;
    }
    while (v5 < sk_num(*(const STACK **)v3));
  }
  v10 = ASN1_item_ex_i2d(&pval, 0, &X509_NAME_INTERNAL_it, -1, -1);
  if (!BUF_MEM_grow(*(BUF_MEM **)(v3 + 16), v10))
  {
    v4 = pval;
    goto LABEL_19;
  }
  v14 = *(unsigned __int8 **)(*(_QWORD *)(v3 + 16) + 8);
  ASN1_item_ex_i2d(&pval, &v14, &X509_NAME_INTERNAL_it, -1, -1);
  sk_pop_free((STACK *)pval, (void (__cdecl *)(void *))local_sk_X509_NAME_ENTRY_free);
  *(_DWORD *)(v3 + 8) = 0;
  v11 = v10;
  if ((v10 & 0x80000000) != 0)
    return v11;
  x509_name_canon(v3);
LABEL_16:
  v12 = *(uint64_t **)(v3 + 16);
  v11 = *v12;
  if (a2)
  {
    memcpy(*a2, (const void *)v12[1], (int)v11);
    *a2 = (char *)*a2 + (int)v11;
  }
  return v11;
}

uint64_t x509_name_ex_print(BIO *a1, X509_NAME **a2, int a3, uint64_t a4, uint64_t a5)
{
  return 2 * (X509_NAME_print_ex(a1, *a2, a3, *(_QWORD *)(a5 + 8)) > 0);
}

X509_NAME *__cdecl d2i_X509_NAME(X509_NAME **a, const unsigned __int8 **in, uint64_t len)
{
  return (X509_NAME *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &X509_NAME_it);
}

int i2d_X509_NAME(X509_NAME *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &X509_NAME_it);
}

X509_NAME *X509_NAME_new(void)
{
  return (X509_NAME *)ASN1_item_new(&X509_NAME_it);
}

void X509_NAME_free(X509_NAME *a)
{
  ASN1_item_free((ASN1_VALUE *)a, &X509_NAME_it);
}

X509_NAME *__cdecl X509_NAME_dup(X509_NAME *xn)
{
  return (X509_NAME *)ASN1_item_dup(&X509_NAME_it, xn);
}

int X509_NAME_set(X509_NAME **xn, X509_NAME *name)
{
  X509_NAME *v3;
  X509_NAME *v4;

  if (*xn == name)
  {
    LODWORD(v3) = name != 0;
  }
  else
  {
    v3 = (X509_NAME *)ASN1_item_dup(&X509_NAME_it, name);
    if (v3)
    {
      v4 = v3;
      ASN1_item_free((ASN1_VALUE *)*xn, &X509_NAME_it);
      *xn = v4;
      LODWORD(v3) = 1;
    }
  }
  return (int)v3;
}

uint64_t X509_NAME_get0_der(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  if (ASN1_item_i2d((ASN1_VALUE *)a1, 0, &X509_NAME_it) < 1)
    return 0;
  if (a2)
    *a2 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 8);
  if (a3)
    *a3 = **(_QWORD **)(a1 + 16);
  return 1;
}

uint64_t x509_name_canon(uint64_t a1)
{
  void *v2;
  STACK *v3;
  STACK *v4;
  int v5;
  STACK *v6;
  uint64_t v7;
  char *v8;
  char *v9;
  ASN1_VALUE *v10;
  ASN1_VALUE *v11;
  ASN1_OBJECT *v12;
  ASN1_STRING *v13;
  ASN1_STRING *v14;
  unsigned __int8 **p_data;
  int v16;
  unsigned __int8 *v17;
  uint64_t v18;
  int v19;
  BOOL v20;
  unsigned __int8 *v21;
  _BOOL4 v22;
  unsigned __int8 *v23;
  uint64_t v24;
  int v25;
  int v26;
  unsigned __int8 *v27;
  int v28;
  int v29;
  int v30;
  unsigned int v31;
  unsigned int v32;
  unsigned __int8 *v33;
  uint64_t v34;
  STACK *v36;
  STACK *v37;
  int v38;
  unsigned __int8 *v39;

  v2 = *(void **)(a1 + 24);
  if (v2)
  {
    free(v2);
    *(_QWORD *)(a1 + 24) = 0;
  }
  if (sk_num(*(const STACK **)a1))
  {
    v3 = sk_new_null();
    if (v3)
    {
      v4 = v3;
      v39 = 0;
      if (sk_num(*(const STACK **)a1) >= 1)
      {
        v5 = 0;
        v6 = 0;
        v38 = -1;
        v7 = MEMORY[0x24BDAC740];
        do
        {
          v8 = sk_value(*(const STACK **)a1, v5);
          if (*((_DWORD *)v8 + 4) != v38)
          {
            v9 = (char *)sk_new_null();
            if (!v9)
              goto LABEL_54;
            v6 = (STACK *)v9;
            if (!sk_push(v4, v9))
            {
              sk_free(v6);
              goto LABEL_54;
            }
            v38 = *((_DWORD *)v8 + 4);
          }
          v10 = ASN1_item_new(&X509_NAME_ENTRY_it);
          if (!v10)
            goto LABEL_54;
          v11 = v10;
          v12 = OBJ_dup(*(const ASN1_OBJECT **)v8);
          *(_QWORD *)v11 = v12;
          if (!v12)
            goto LABEL_53;
          v13 = (ASN1_STRING *)*((_QWORD *)v11 + 1);
          v14 = (ASN1_STRING *)*((_QWORD *)v8 + 1);
          if ((ASN1_tag2bit(v14->type) & 0x2956) == 0)
          {
            v22 = ASN1_STRING_copy(v13, (uint64_t)v14) != 0;
            goto LABEL_44;
          }
          v13->type = 12;
          p_data = &v13->data;
          v16 = ASN1_STRING_to_UTF8(&v13->data, v14);
          v13->length = v16;
          if (v16 == -1)
          {
LABEL_53:
            ASN1_item_free(v11, &X509_NAME_ENTRY_it);
            goto LABEL_54;
          }
          v17 = *p_data;
          if (v16 < 1)
          {
            v21 = *p_data;
            goto LABEL_43;
          }
          v18 = 0;
          v19 = v16;
          while (((char)v17[v18] & 0x80000000) == 0 && (*(_DWORD *)(v7 + 4 * v17[v18] + 60) & 0x4000) != 0)
          {
            ++v18;
            v20 = __OFSUB__(v19--, 1);
            if ((v19 < 0) ^ v20 | (v19 == 0))
            {
              v21 = *p_data;
              goto LABEL_43;
            }
          }
          v37 = v6;
          v23 = &v17[v18];
          v24 = v16 - 1;
          while (((char)v17[v24] & 0x80000000) == 0 && (*(_DWORD *)(v7 + 4 * v17[v24] + 60) & 0x4000) != 0)
          {
            --v24;
            v20 = __OFSUB__(v19--, 1);
            if ((v19 < 0) ^ v20 | (v19 == 0))
            {
              LODWORD(v21) = *p_data;
              goto LABEL_42;
            }
          }
          v36 = v4;
          v25 = 0;
          do
          {
            v26 = (char)*v23;
            if (v26 < 0)
            {
              ++v23;
              *v17 = v26;
              goto LABEL_35;
            }
            if ((*(_DWORD *)(v7 + 4 * *v23 + 60) & 0x4000) == 0)
            {
              *v17 = __tolower(*v23++);
LABEL_35:
              ++v25;
              goto LABEL_36;
            }
            *v17 = 32;
            v27 = v23 + 1;
            v28 = v25 + 1;
            do
            {
              v23 = v27;
              v25 = v28;
              v29 = (char)*v27;
              if (v29 < 0)
                break;
              v30 = *(_DWORD *)(v7 + 4 * v29 + 60);
              v27 = v23 + 1;
              ++v28;
            }
            while ((v30 & 0x4000) != 0);
LABEL_36:
            ++v17;
          }
          while (v25 < v19);
          v21 = *p_data;
          v4 = v36;
LABEL_42:
          v6 = v37;
LABEL_43:
          v13->length = (_DWORD)v17 - (_DWORD)v21;
          v22 = 1;
LABEL_44:
          if (!v22 || !v6 || !sk_push(v6, (char *)v11))
            goto LABEL_53;
          ++v5;
        }
        while (v5 < sk_num(*(const STACK **)a1));
      }
      v31 = i2d_name_canon(v4, 0);
      if ((v31 & 0x80000000) != 0
        || (v32 = v31, v33 = (unsigned __int8 *)malloc_type_malloc(v31, 0x8AC01138uLL), (v39 = v33) == 0))
      {
LABEL_54:
        v34 = 0;
      }
      else
      {
        *(_QWORD *)(a1 + 24) = v33;
        *(_DWORD *)(a1 + 32) = v32;
        i2d_name_canon(v4, &v39);
        v34 = 1;
      }
      sk_pop_free(v4, (void (__cdecl *)(void *))local_sk_X509_NAME_ENTRY_pop_free);
    }
    else
    {
      return 0;
    }
  }
  else
  {
    *(_DWORD *)(a1 + 32) = 0;
    return 1;
  }
  return v34;
}

uint64_t i2d_name_canon(const STACK *a1, unsigned __int8 **a2)
{
  uint64_t v4;
  int v5;
  uint64_t v6;
  ASN1_VALUE *pval;

  pval = 0;
  if (sk_num(a1) < 1)
    return 0;
  LODWORD(v4) = 0;
  v5 = 0;
  while (1)
  {
    pval = (ASN1_VALUE *)sk_value(a1, v5);
    v6 = ASN1_item_ex_i2d(&pval, a2, &X509_NAME_ENTRIES_it, -1, -1);
    if ((v6 & 0x80000000) != 0)
      break;
    v4 = (v6 + v4);
    if (++v5 >= sk_num(a1))
      return v4;
  }
  return v6;
}

void local_sk_X509_NAME_ENTRY_pop_free(STACK *a1)
{
  sk_pop_free(a1, (void (__cdecl *)(void *))X509_NAME_ENTRY_free);
}

uint64_t asn1_time_tm_to_time_t(int *a1, _QWORD *a2)
{
  int v2;
  int v3;
  uint64_t result;
  uint64_t v6;

  v2 = a1[5];
  if (v2 > 9999)
    return 0;
  v3 = a1[4];
  if (v3 > 12)
    return 0;
  v6 = 0;
  result = posix_time_from_utc(v2 + 1900, v3 + 1, a1[3], a1[2], a1[1], *a1, &v6);
  if ((_DWORD)result)
  {
    *a2 = v6;
    return 1;
  }
  return result;
}

uint64_t asn1_time_time_t_to_tm(uint64_t *a1, uint64_t a2)
{
  uint64_t v2;
  int32x2_t *v3;
  uint64_t result;

  v2 = *a1;
  *(_QWORD *)(a2 + 48) = 0;
  *(_OWORD *)(a2 + 16) = 0u;
  v3 = (int32x2_t *)(a2 + 16);
  *(_OWORD *)(a2 + 32) = 0u;
  *(_OWORD *)a2 = 0u;
  result = utc_from_posix_time(v2, (_DWORD *)(a2 + 20), (int *)(a2 + 16), (_DWORD *)(a2 + 12), (unsigned int *)(a2 + 8), (unsigned int *)(a2 + 4), (unsigned int *)a2);
  if ((_DWORD)result)
  {
    *v3 = vadd_s32(*v3, (int32x2_t)0xFFFFF894FFFFFFFFLL);
    return 1;
  }
  return result;
}

uint64_t OPENSSL_gmtime_adj(int *a1, int a2, uint64_t a3)
{
  int v3;
  _DWORD *v4;
  int v6;
  int32x2_t *v7;
  uint64_t result;
  uint64_t v11;

  v4 = a1 + 5;
  v3 = a1[5];
  if (v3 > 9999)
    return 0;
  v7 = (int32x2_t *)(a1 + 4);
  v6 = a1[4];
  if (v6 > 12)
    return 0;
  v11 = 0;
  result = posix_time_from_utc(v3 + 1900, v6 + 1, a1[3], a1[2], a1[1], *a1, &v11);
  if ((_DWORD)result)
  {
    result = utc_from_posix_time(a3 + 86400 * a2 + v11, v4, (int *)v7, a1 + 3, (unsigned int *)a1 + 2, (unsigned int *)a1 + 1, (unsigned int *)a1);
    if ((_DWORD)result)
    {
      *v7 = vadd_s32(*v7, (int32x2_t)0xFFFFF894FFFFFFFFLL);
      return 1;
    }
  }
  return result;
}

uint64_t posix_time_from_utc(unsigned int a1, unsigned int a2, int a3, int a4, int a5, int a6, _QWORD *a7)
{
  uint64_t v9;
  unsigned int v10;
  int v12;
  __int16 v13;
  signed int v14;
  uint64_t v15;
  __int16 v16;
  int v17;
  unint64_t v18;
  BOOL v19;
  unsigned int v20;
  unint64_t v21;

  if (a1 >> 4 > 0x270 || (int)a2 < 1 || a3 < 1)
    return 0;
  v9 = 0;
  if (a2 <= 0xC)
  {
    if (((1 << a2) & 0x15AA) != 0)
    {
      v10 = 31;
    }
    else if (((1 << a2) & 0xA50) != 0)
    {
      v10 = 30;
    }
    else
    {
      if (a2 != 2)
        return v9;
      HIDWORD(v18) = -1030792151 * (unsigned __int16)a1;
      LODWORD(v18) = HIDWORD(v18);
      v19 = (v18 >> 2) > 0x28F5C28 && (a1 & 3) == 0;
      HIDWORD(v21) = -1030792151 * (unsigned __int16)a1;
      LODWORD(v21) = HIDWORD(v21);
      v20 = v21 >> 4;
      if (!v19 && v20 >= 0xA3D70B)
        v10 = 28;
      else
        v10 = 29;
    }
    if (v10 < a3)
      return 0;
    v9 = 0;
    if (a6 <= 59 && a5 <= 59 && a4 <= 23 && ((a5 | a4 | a6) & 0x80000000) == 0)
    {
      v12 = (__PAIR64__(a1, a2) - 3) >> 32;
      v13 = v12 - 399;
      if (v12 >= 0)
        v13 = (__PAIR64__(a1, a2) - 3) >> 32;
      v14 = ((5243 * v13) >> 21) + ((5243 * v13) >> 31);
      v15 = v12 - 400 * v14;
      if (a2 <= 2)
        v16 = 9;
      else
        v16 = -3;
      v17 = 26215 * (__int16)(153 * (v16 + a2) + 2);
      *a7 = 60 * a5
          + 3600 * a4
          + a6
          + 86400
          * ((int)(a3 + (v17 >> 17) + (v17 >> 31) - 1)
           + 146097 * v14
           + 365 * v15
           + ((int)(((_DWORD)v15 + (((__int16)v15 >> 29) & 3)) << 16) >> 18)
           + (int)(((-5243 * (__int16)v15) >> 19) + ((-5243 * (__int16)v15) >> 31)))
          - 0xE79256200;
      return 1;
    }
  }
  return v9;
}

uint64_t utc_from_posix_time(uint64_t a1, _DWORD *a2, int *a3, _DWORD *a4, unsigned int *a5, unsigned int *a6, unsigned int *a7)
{
  uint64_t v8;
  uint64_t v9;
  int v10;
  int v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  int v15;
  int v16;
  int v17;
  unsigned __int16 v18;

  if ((unint64_t)(a1 - 0x3AFFF44180) < 0xFFFFFFB686974280)
    return 0;
  v8 = a1 / 86400 + ((a1 % 86400) >> 63);
  if (a1 % 86400 >= 0)
    v9 = a1 % 86400;
  else
    v9 = a1 % 86400 + 86400;
  v10 = v8 + 573372;
  if (v8 > -719468)
    v10 = v8 + 719468;
  v11 = v10 / 146097;
  v12 = v8 + 719468 - 146097 * v11;
  v13 = ((int)(((unint64_t)(1282606671 * (int)v12) >> 32) - v12) >> 10)
      + ((((unint64_t)(1282606671 * (int)v12) >> 32) - v12) >> 31)
      + v12
      + (int)v12 / 36524
      + ((int)(((unint64_t)(441679365 * (int)v12) >> 32) - v12) >> 17)
      + ((((unint64_t)(441679365 * (int)v12) >> 32) - v12) >> 31);
  *a2 = v13 / 365 + 400 * v11;
  v14 = v12
      + (int)(((int)(((unint64_t)(1282606671 * v13) >> 32) - v13) >> 10)
            + ((((unint64_t)(1282606671 * v13) >> 32) - v13) >> 31))
      + v13 / 36500
      - 365 * (v13 / 365);
  v15 = (5 * (int)v14 + 2) / 153;
  if (v14 >= 306)
    v16 = -9;
  else
    v16 = 3;
  v17 = v16 + v15;
  *a3 = v17;
  if (v17 <= 2)
    ++*a2;
  *a4 = (153 * v15 + 2) / -5 + v14 + 1;
  *a5 = v9 / 0xE10;
  v18 = v9 % 0xE10;
  *a6 = v18 / 0x3Cu;
  *a7 = v18 % 0x3Cu;
  return 1;
}

uint64_t OPENSSL_gmtime_diff(_DWORD *a1, _DWORD *a2, int *a3, int *a4)
{
  uint64_t result;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  v10 = 0;
  result = posix_time_from_utc(a4[5] + 1900, a4[4] + 1, a4[3], a4[2], a4[1], *a4, &v10);
  if ((_DWORD)result)
  {
    v9 = 0;
    result = posix_time_from_utc(a3[5] + 1900, a3[4] + 1, a3[3], a3[2], a3[1], *a3, &v9);
    if ((_DWORD)result)
    {
      v8 = v10 - v9;
      if ((unint64_t)(v10 - v9 - 0xA8C000000000) >= 0xFFFEAE7FFFFEAE81)
      {
        *a2 = v8 % 86400;
        *a1 = v8 / 86400;
        return 1;
      }
      else
      {
        return 0;
      }
    }
  }
  return result;
}

int SHA224_Init(SHA256_CTX *c)
{
  *(_OWORD *)&c->data[10] = 0u;
  *(_OWORD *)&c->data[14] = 0u;
  *(_OWORD *)&c->data[2] = 0u;
  *(_OWORD *)&c->data[6] = 0u;
  *(_OWORD *)c->h = xmmword_22D69EB20;
  *(_OWORD *)&c->h[4] = xmmword_22D69EB30;
  *(_OWORD *)&c->Nl = 0u;
  c->md_len = 28;
  return 1;
}

int SHA256_Init(SHA256_CTX *c)
{
  *(_OWORD *)&c->data[10] = 0u;
  *(_OWORD *)&c->data[14] = 0u;
  *(_OWORD *)&c->data[2] = 0u;
  *(_OWORD *)&c->data[6] = 0u;
  *(_OWORD *)c->h = xmmword_22D69EB40;
  *(_OWORD *)&c->h[4] = xmmword_22D69EB50;
  *(_OWORD *)&c->Nl = 0u;
  c->md_len = 32;
  return 1;
}

unsigned __int8 *__cdecl SHA224(const unsigned __int8 *d, size_t n, unsigned __int8 *md)
{
  unsigned __int8 *v3;
  SHA256_CTX v5;

  if (md)
    v3 = md;
  else
    v3 = (unsigned __int8 *)&SHA224_m;
  memset(&v5.Nl, 0, 76);
  *(_OWORD *)v5.h = xmmword_22D69EB20;
  *(_OWORD *)&v5.h[4] = xmmword_22D69EB30;
  v5.md_len = 28;
  SHA256_Update(&v5, d, n);
  SHA256_Final(v3, &v5);
  explicit_bzero(&v5, 0x70uLL);
  return v3;
}

int SHA256_Update(SHA256_CTX *c, const void *data, size_t len)
{
  size_t v3;
  unsigned int *v4;
  uint64_t num;
  unsigned int *v7;
  char *v8;
  uint64_t v9;

  if (len)
  {
    v3 = len;
    v4 = (unsigned int *)data;
    *(_QWORD *)&c->Nl += 8 * len;
    num = c->num;
    if ((_DWORD)num)
    {
      v7 = c->data;
      v8 = (char *)c->data + num;
      if (len <= 0x3F && num + len < 0x40)
      {
        memcpy(v8, data, len);
        c->num += v3;
        return 1;
      }
      v9 = 64 - num;
      memcpy(v8, data, 64 - num);
      sha256_block_data_order((unint64_t)c, c->data, 1);
      v4 = (unsigned int *)((char *)v4 + v9);
      v3 -= v9;
      c->num = 0;
      *(_OWORD *)v7 = 0u;
      *(_OWORD *)&c->data[4] = 0u;
      *(_OWORD *)&c->data[8] = 0u;
      *(_OWORD *)&c->data[12] = 0u;
    }
    if (v3 >= 0x40)
    {
      sha256_block_data_order((unint64_t)c, v4, v3 >> 6);
      v4 = (unsigned int *)((char *)v4 + (v3 & 0xFFFFFFFFFFFFFFC0));
      v3 &= 0x3Fu;
    }
    if (v3)
    {
      c->num = v3;
      memcpy(c->data, v4, v3);
    }
  }
  return 1;
}

int SHA256_Final(unsigned __int8 *md, SHA256_CTX *c)
{
  unsigned int *data;
  uint64_t num;
  uint64_t v6;
  unsigned int v7;
  unsigned int md_len;
  uint64_t j;
  uint64_t i;
  unint64_t v12;

  data = c->data;
  num = c->num;
  *((_BYTE *)c->data + num) = 0x80;
  v6 = num + 1;
  if (num >= 0x38)
  {
    bzero((char *)data + v6, 63 - num);
    sha256_block_data_order((unint64_t)c, data, 1);
    v6 = 0;
  }
  bzero((char *)data + v6, 56 - v6);
  v7 = bswap32(c->Nl);
  c->data[14] = bswap32(c->Nh);
  c->data[15] = v7;
  sha256_block_data_order((unint64_t)c, data, 1);
  c->num = 0;
  *(_OWORD *)data = 0u;
  *((_OWORD *)data + 1) = 0u;
  *((_OWORD *)data + 2) = 0u;
  *((_OWORD *)data + 3) = 0u;
  md_len = c->md_len;
  if (md_len == 28)
  {
    for (i = 0; i != 7; ++i)
      *(_DWORD *)&md[i * 4] = bswap32(c->h[i]);
  }
  else if (md_len == 32)
  {
    for (j = 0; j != 8; ++j)
      *(_DWORD *)&md[j * 4] = bswap32(c->h[j]);
  }
  else
  {
    if (md_len > 0x20)
      return 0;
    if (md_len >= 4)
    {
      v12 = 0;
      do
      {
        *(_DWORD *)md = bswap32(c->h[v12]);
        md += 4;
        ++v12;
      }
      while (v12 < (unint64_t)c->md_len >> 2);
    }
  }
  return 1;
}

unsigned __int8 *__cdecl SHA256(const unsigned __int8 *d, size_t n, unsigned __int8 *md)
{
  unsigned __int8 *v3;
  SHA256_CTX v5;

  if (md)
    v3 = md;
  else
    v3 = (unsigned __int8 *)&SHA256_m;
  memset(&v5.Nl, 0, 76);
  *(_OWORD *)v5.h = xmmword_22D69EB40;
  *(_OWORD *)&v5.h[4] = xmmword_22D69EB50;
  v5.md_len = 32;
  SHA256_Update(&v5, d, n);
  SHA256_Final(v3, &v5);
  explicit_bzero(&v5, 0x70uLL);
  return v3;
}

int SHA224_Update(SHA256_CTX *c, const void *data, size_t len)
{
  SHA256_Update(c, data, len);
  return 1;
}

unint64_t sha256_block_data_order(unint64_t result, unsigned int *a2, uint64_t a3)
{
  unsigned int v3;
  int v4;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  unsigned int v10;
  unint64_t v11;
  int v12;
  unint64_t v13;
  int v14;
  int v15;
  unsigned int v16;
  unsigned int v17;
  int v18;
  unint64_t v19;
  int v20;
  int v21;
  unsigned int v22;
  unsigned int v23;
  int v24;
  int v25;
  unint64_t v26;
  int v27;
  int v28;
  unsigned int v29;
  unsigned int v30;
  int v31;
  unint64_t v32;
  int v33;
  int v34;
  unsigned int v35;
  unsigned int v36;
  int v37;
  unint64_t v38;
  int v39;
  int v40;
  unsigned int v41;
  unsigned int v42;
  int v43;
  unint64_t v44;
  int v45;
  int v46;
  unsigned int v47;
  unsigned int v48;
  int v49;
  int v50;
  unint64_t v51;
  int v52;
  int v53;
  unsigned int v54;
  unsigned int v55;
  int v56;
  unint64_t v57;
  int v58;
  int v59;
  unsigned int v60;
  unsigned int v61;
  int v62;
  unint64_t v63;
  int v64;
  int v65;
  unsigned int v66;
  unsigned int v67;
  int v68;
  unint64_t v69;
  int v70;
  int v71;
  unsigned int v72;
  unsigned int v73;
  int v74;
  int v75;
  unint64_t v76;
  int v77;
  int v78;
  unsigned int v79;
  unsigned int v80;
  int v81;
  unint64_t v82;
  int v83;
  int v84;
  unsigned int v85;
  unsigned int v86;
  int v87;
  unint64_t v88;
  int v89;
  unsigned int v90;
  unsigned int v91;
  unsigned int v92;
  int v93;
  unint64_t v94;
  int v95;
  unsigned int v96;
  unsigned int v97;
  unsigned int v98;
  int v99;
  unint64_t v100;
  int v101;
  unsigned int v102;
  unsigned int v103;
  unsigned int v104;
  int v105;
  unint64_t v106;
  int v107;
  unsigned int v108;
  unsigned int v109;
  int *v110;
  uint64_t v111;
  unint64_t v112;
  uint64_t v113;
  unsigned int v114;
  unsigned int v115;
  int v116;
  unint64_t v117;
  int v118;
  unint64_t v119;
  int v120;
  unint64_t v121;
  uint64_t v122;
  int v123;
  int v124;
  unsigned int v125;
  int v126;
  int v127;
  unint64_t v128;
  int v129;
  int v130;
  int v131;
  unsigned int v132;
  unsigned int v133;
  unsigned int v134;
  int v135;
  int v136;
  unint64_t v137;
  int v138;
  int v139;
  int v140;
  int v141;
  unint64_t v142;
  unint64_t v143;
  int v144;
  int v145;
  unsigned int v146;
  unsigned int v147;
  int v148;
  unint64_t v149;
  int v150;
  uint64_t v151;
  unsigned int v152;
  int v153;
  int v154;
  int v155;
  unint64_t v156;
  int v157;
  int v158;
  unsigned int v159;
  int v160;
  int v161;
  int v162;
  unint64_t v163;
  int v164;
  uint64_t v165;
  int v166;
  int v167;
  unsigned int v168;
  int v169;
  int v170;
  unint64_t v171;
  int v172;
  int v173;
  unsigned int v174;
  unsigned int v175;
  int v176;
  unsigned int v177;
  unint64_t v178;
  uint64_t v179;
  int v180;
  unsigned int v181;
  int v182;
  int v183;
  unint64_t v184;
  int v185;
  unsigned int v186;
  int v187;
  int v188;
  int v189;
  int v190;
  unint64_t v191;
  uint64_t v192;
  unsigned int v193;
  int v194;
  int v195;
  unint64_t v196;
  int v197;
  int v198;
  unsigned int v199;
  unint64_t v200;
  unint64_t v201;
  uint64_t v202;
  int v203;
  int v204;
  unint64_t v205;
  int v206;
  unsigned int v207;
  unsigned int v208;
  int v209;
  unint64_t v210;
  uint64_t v211;
  int v212;
  int v213;
  unint64_t v214;
  int v215;
  int v216;
  _DWORD *v217;
  int v218;
  int v219;
  int v220;
  int v221;
  int v222;
  int v223;
  int v224;
  unsigned int v225;
  unsigned int *v226;
  uint64_t v227;
  _DWORD v228[16];
  uint64_t v229;

  v217 = (_DWORD *)result;
  v229 = *MEMORY[0x24BDAC8D0];
  if (a3)
  {
    v3 = *(_DWORD *)result;
    v4 = *(_DWORD *)(result + 4);
    v6 = *(_DWORD *)(result + 8);
    v5 = *(_DWORD *)(result + 12);
    v8 = *(_DWORD *)(result + 16);
    v7 = *(_DWORD *)(result + 20);
    v9 = *(_DWORD *)(result + 24);
    LODWORD(result) = *(_DWORD *)(result + 28);
    do
    {
      v227 = a3;
      v10 = bswap32(*a2);
      HIDWORD(v11) = v8;
      LODWORD(v11) = v8;
      v12 = (v11 >> 6) ^ __ROR4__(v8, 11);
      v13 = __PAIR64__(v3, __ROR4__(v8, 25));
      v218 = result;
      v14 = (v7 & v8) + result + (v9 & ~v8) + v10 + (v12 ^ v13) + 1116352408;
      LODWORD(v13) = v3;
      v222 = v5;
      v15 = v14 + v5;
      v16 = ((v6 ^ v4) & v3 ^ v6 & v4) + ((v13 >> 2) ^ __ROR4__(v3, 13) ^ __ROR4__(v3, 22)) + v14;
      v17 = bswap32(a2[1]);
      HIDWORD(v13) = v15;
      LODWORD(v13) = v15;
      v228[0] = v10;
      v228[1] = v17;
      v18 = (v13 >> 6) ^ __ROR4__(v15, 11);
      v19 = __PAIR64__(v16, __ROR4__(v15, 25));
      v219 = v9;
      v20 = v9 + (v7 & ~v15) + (v15 & v8) + v17 + 1899447441 + (v18 ^ v19);
      LODWORD(v19) = v16;
      v223 = v6;
      v21 = v20 + v6;
      v22 = ((v19 >> 2) ^ __ROR4__(v16, 13) ^ __ROR4__(v16, 22)) + (v16 & (v4 ^ v3) ^ v4 & v3) + v20;
      v23 = bswap32(a2[2]);
      HIDWORD(v19) = v21;
      LODWORD(v19) = v21;
      v24 = (v19 >> 6) ^ __ROR4__(v21, 11);
      v26 = __PAIR64__(v22, __ROR4__(v21, 25));
      v25 = v24 ^ v26;
      v220 = v7;
      LODWORD(v26) = v22;
      v27 = v7 + v23 + (v8 & ~v21) + (v21 & v15) - 1245643825 + v25;
      v224 = v4;
      v28 = v27 + v4;
      v29 = ((v26 >> 2) ^ __ROR4__(v22, 13) ^ __ROR4__(v22, 22)) + (v22 & (v16 ^ v3) ^ v16 & v3) + v27;
      v30 = bswap32(a2[3]);
      v228[2] = v23;
      v228[3] = v30;
      HIDWORD(v26) = v28;
      LODWORD(v26) = v28;
      v31 = (v26 >> 6) ^ __ROR4__(v28, 11);
      v32 = __PAIR64__(v29, __ROR4__(v28, 25));
      v221 = v8;
      v33 = v8 + v30 + (v15 & ~v28) + (v28 & v21) - 373957723 + (v31 ^ v32);
      LODWORD(v32) = v29;
      v225 = v3;
      v34 = v33 + v3;
      v35 = ((v32 >> 2) ^ __ROR4__(v29, 13) ^ __ROR4__(v29, 22)) + (v29 & (v22 ^ v16) ^ v22 & v16) + v33;
      v36 = bswap32(a2[4]);
      HIDWORD(v32) = v34;
      LODWORD(v32) = v34;
      v37 = (v32 >> 6) ^ __ROR4__(v34, 11);
      v38 = __PAIR64__(v35, __ROR4__(v34, 25));
      v39 = v15 + v36 + (v21 & ~v34) + (v34 & v28) + 961987163 + (v37 ^ v38);
      LODWORD(v38) = v35;
      v40 = v39 + v16;
      v41 = ((v38 >> 2) ^ __ROR4__(v35, 13) ^ __ROR4__(v35, 22)) + (v35 & (v29 ^ v22) ^ v29 & v22) + v39;
      v42 = bswap32(a2[5]);
      v228[4] = v36;
      v228[5] = v42;
      HIDWORD(v38) = v40;
      LODWORD(v38) = v40;
      v43 = (v38 >> 6) ^ __ROR4__(v40, 11);
      v44 = __PAIR64__(v41, __ROR4__(v40, 25));
      v45 = v21 + v42 + (v28 & ~v40) + (v40 & v34) + 1508970993 + (v43 ^ v44);
      LODWORD(v44) = v41;
      v46 = v45 + v22;
      v47 = ((v44 >> 2) ^ __ROR4__(v41, 13) ^ __ROR4__(v41, 22)) + (v41 & (v35 ^ v29) ^ v35 & v29) + v45;
      v48 = bswap32(a2[6]);
      v49 = v28 + v48 + (v34 & ~v46) + (v46 & v40);
      HIDWORD(v44) = v46;
      LODWORD(v44) = v46;
      v50 = (v44 >> 6) ^ __ROR4__(v46, 11);
      v51 = __PAIR64__(v47, __ROR4__(v46, 25));
      v52 = v49 - 1841331548 + (v50 ^ v51);
      LODWORD(v51) = v47;
      v53 = v52 + v29;
      v54 = ((v51 >> 2) ^ __ROR4__(v47, 13) ^ __ROR4__(v47, 22)) + (v47 & (v41 ^ v35) ^ v41 & v35) + v52;
      v55 = bswap32(a2[7]);
      HIDWORD(v51) = v53;
      LODWORD(v51) = v53;
      v228[6] = v48;
      v228[7] = v55;
      v56 = (v51 >> 6) ^ __ROR4__(v53, 11);
      v57 = __PAIR64__(v54, __ROR4__(v53, 25));
      v58 = v34 + v55 + (v40 & ~v53) + (v53 & v46) - 1424204075 + (v56 ^ v57);
      LODWORD(v57) = v54;
      v59 = v58 + v35;
      v60 = ((v57 >> 2) ^ __ROR4__(v54, 13) ^ __ROR4__(v54, 22)) + (v54 & (v47 ^ v41) ^ v47 & v41) + v58;
      HIDWORD(v57) = v59;
      LODWORD(v57) = v59;
      v61 = bswap32(a2[8]);
      v62 = (v57 >> 6) ^ __ROR4__(v59, 11);
      v63 = __PAIR64__(v60, __ROR4__(v59, 25));
      v64 = v40 + v61 + (v46 & ~v59) + (v59 & v53) - 670586216 + (v62 ^ v63);
      LODWORD(v63) = v60;
      v65 = v64 + v41;
      v66 = ((v63 >> 2) ^ __ROR4__(v60, 13) ^ __ROR4__(v60, 22)) + (v60 & (v54 ^ v47) ^ v54 & v47) + v64;
      v67 = bswap32(a2[9]);
      v228[8] = v61;
      v228[9] = v67;
      HIDWORD(v63) = v65;
      LODWORD(v63) = v65;
      v68 = (v63 >> 6) ^ __ROR4__(v65, 11);
      v69 = __PAIR64__(v66, __ROR4__(v65, 25));
      v70 = v46 + v67 + (v53 & ~v65) + (v65 & v59) + 310598401 + (v68 ^ v69);
      LODWORD(v69) = v66;
      v71 = v70 + v47;
      v72 = ((v69 >> 2) ^ __ROR4__(v66, 13) ^ __ROR4__(v66, 22)) + (v66 & (v60 ^ v54) ^ v60 & v54) + v70;
      v73 = bswap32(a2[10]);
      v74 = v53 + v73 + (v59 & ~v71) + (v71 & v65);
      HIDWORD(v69) = v71;
      LODWORD(v69) = v71;
      v75 = (v69 >> 6) ^ __ROR4__(v71, 11);
      v76 = __PAIR64__(v72, __ROR4__(v71, 25));
      v77 = v74 + 607225278 + (v75 ^ v76);
      LODWORD(v76) = v72;
      v78 = v77 + v54;
      v79 = ((v76 >> 2) ^ __ROR4__(v72, 13) ^ __ROR4__(v72, 22)) + (v72 & (v66 ^ v60) ^ v66 & v60) + v77;
      v80 = bswap32(a2[11]);
      v228[10] = v73;
      v228[11] = v80;
      HIDWORD(v76) = v78;
      LODWORD(v76) = v78;
      v81 = (v76 >> 6) ^ __ROR4__(v78, 11);
      v82 = __PAIR64__(v79, __ROR4__(v78, 25));
      v83 = v80 + v59 + (v65 & ~v78) + (v78 & v71) + 1426881987 + (v81 ^ v82);
      LODWORD(v82) = v79;
      v84 = v83 + v60;
      v85 = ((v82 >> 2) ^ __ROR4__(v79, 13) ^ __ROR4__(v79, 22)) + (v79 & (v72 ^ v66) ^ v72 & v66) + v83;
      v86 = bswap32(a2[12]);
      HIDWORD(v82) = v84;
      LODWORD(v82) = v84;
      v87 = (v82 >> 6) ^ __ROR4__(v84, 11);
      v88 = __PAIR64__(v85, __ROR4__(v84, 25));
      v89 = v86 + v65 + (v71 & ~v84) + (v84 & v78) + 1925078388 + (v87 ^ v88);
      LODWORD(v88) = v85;
      v90 = v89 + v66;
      v91 = ((v88 >> 2) ^ __ROR4__(v85, 13) ^ __ROR4__(v85, 22)) + (v85 & (v79 ^ v72) ^ v79 & v72) + v89;
      v92 = bswap32(a2[13]);
      HIDWORD(v88) = v90;
      LODWORD(v88) = v90;
      v228[12] = v86;
      v228[13] = v92;
      v93 = (v88 >> 6) ^ __ROR4__(v90, 11);
      v94 = __PAIR64__(v91, __ROR4__(v90, 25));
      v95 = v92 + v71 + (v78 & ~v90) + (v90 & v84) - 2132889090 + (v93 ^ v94);
      LODWORD(v94) = v91;
      v96 = v95 + v72;
      v97 = ((v94 >> 2) ^ __ROR4__(v91, 13) ^ __ROR4__(v91, 22)) + (v91 & (v85 ^ v79) ^ v85 & v79) + v95;
      HIDWORD(v94) = v96;
      LODWORD(v94) = v95 + v72;
      v226 = a2;
      v98 = bswap32(a2[14]);
      v99 = (v94 >> 6) ^ __ROR4__(v96, 11);
      v100 = __PAIR64__(v97, __ROR4__(v96, 25));
      v101 = v98 + v78 + (v84 & ~v96) + (v96 & v90) - 1680079193 + (v99 ^ v100);
      LODWORD(v100) = v97;
      v102 = v101 + v79;
      v103 = ((v100 >> 2) ^ __ROR4__(v97, 13) ^ __ROR4__(v97, 22)) + (v97 & (v91 ^ v85) ^ v91 & v85) + v101;
      v104 = bswap32(a2[15]);
      v228[14] = v98;
      v228[15] = v104;
      HIDWORD(v100) = v102;
      LODWORD(v100) = v102;
      v105 = (v100 >> 6) ^ __ROR4__(v102, 11);
      v106 = __PAIR64__(v103, __ROR4__(v102, 25));
      v107 = v104 + v84 + (v90 & ~v102) + (v102 & v96) - 1046744716 + (v105 ^ v106);
      LODWORD(v106) = v103;
      v108 = v107 + v85;
      v109 = ((v106 >> 2) ^ __ROR4__(v103, 13) ^ __ROR4__(v103, 22)) + (v103 & (v97 ^ v91) ^ v97 & v91) + v107;
      v110 = &dword_22D69EBBC;
      v111 = 31;
      do
      {
        v112 = v111 - 15;
        v113 = ((int)v111 - 14) & 9;
        v114 = v228[v113];
        v115 = v228[((_BYTE)v111 - 1) & 0xE];
        HIDWORD(v117) = v114;
        LODWORD(v117) = v114;
        v116 = v117 >> 7;
        v119 = __PAIR64__(v115, __ROR4__(v114, 18));
        v118 = v116 ^ v119;
        LODWORD(v119) = v115;
        v120 = v119 >> 17;
        v121 = __PAIR64__(v108, __ROR4__(v115, 19));
        v122 = (v111 - 15) & 8;
        v123 = v120 ^ v121 ^ (v115 >> 10);
        LODWORD(v121) = v108;
        v124 = (v111 - 15) & 8;
        v125 = (v118 ^ (v114 >> 3)) + v228[((int)v111 - 6) & 9] + v228[v122] + v123;
        v126 = (v121 >> 6) ^ __ROR4__(v108, 11);
        v128 = __PAIR64__(v109, __ROR4__(v108, 25));
        v127 = v126 ^ v128;
        LODWORD(v128) = v109;
        v129 = *(v110 - 6);
        v130 = v127 + (v102 & v108) + v90 + (v96 & ~v108) + *(v110 - 7);
        v228[v122] = v125;
        LODWORD(v122) = ((v97 ^ v103) & v109 ^ v97 & v103) + ((v128 >> 2) ^ __ROR4__(v109, 13) ^ __ROR4__(v109, 22));
        v131 = v130 + v125;
        v132 = v131 + v91;
        HIDWORD(v128) = v228[v124 | 2];
        LODWORD(v128) = HIDWORD(v128);
        v133 = v122 + v131;
        v134 = v228[v111 & 0xF];
        v135 = (v128 >> 7) ^ __ROR4__(HIDWORD(v128), 18) ^ (HIDWORD(v128) >> 3);
        HIDWORD(v128) = v134;
        LODWORD(v128) = v134;
        v136 = v128 >> 17;
        v137 = __PAIR64__(v132, __ROR4__(v134, 19));
        v138 = v228[((int)v111 - 5) & 0xALL] + v114 + (v136 ^ v137 ^ (v134 >> 10));
        LODWORD(v137) = v132;
        v139 = v138 + v135;
        v140 = (v137 >> 6) ^ __ROR4__(v132, 11);
        v142 = __PAIR64__(v133, __ROR4__(v132, 25));
        v141 = v140 ^ v142;
        LODWORD(v142) = v133;
        v228[v113] = v139;
        LODWORD(v113) = (v142 >> 2) ^ __ROR4__(v133, 13);
        v143 = __PAIR64__(v125, __ROR4__(v133, 22));
        v144 = (v102 & ~v132) + v96 + (v132 & v108) + v129 + v139 + v141;
        v145 = (v113 ^ v143) + (v133 & (v103 ^ v109) ^ v103 & v109);
        v146 = v144 + v97;
        v147 = v228[v124 | 3];
        LODWORD(v143) = v125;
        v148 = v143 >> 17;
        HIDWORD(v143) = v147;
        LODWORD(v143) = v147;
        LODWORD(v122) = (v143 >> 7) ^ __ROR4__(v147, 18);
        v149 = __PAIR64__(v146, __ROR4__(v125, 19));
        v150 = v148 ^ v149 ^ (v125 >> 10);
        v151 = ((int)v111 - 13) & 0xALL;
        v152 = v145 + v144;
        v153 = v228[((int)v111 - 4) & 0xBLL] + v228[v151] + (v122 ^ (v147 >> 3)) + v150;
        LODWORD(v149) = v146;
        v154 = (v149 >> 6) ^ __ROR4__(v146, 11);
        v156 = __PAIR64__(v152, __ROR4__(v146, 25));
        v155 = v154 ^ v156;
        v228[v151] = v153;
        LODWORD(v151) = *(v110 - 4);
        v157 = *(v110 - 5) + v102 + v153;
        LODWORD(v156) = v152;
        v158 = ((v156 >> 2) ^ __ROR4__(v152, 13) ^ __ROR4__(v152, 22)) + (v152 & (v133 ^ v109) ^ v133 & v109);
        v159 = v228[v124 | 4];
        v160 = v157 + (v108 & ~v146) + (v146 & v132) + v155;
        HIDWORD(v156) = v159;
        LODWORD(v156) = v159;
        v161 = v156 >> 7;
        LODWORD(v122) = v228[v124 | 1];
        v163 = __PAIR64__(v122, __ROR4__(v159, 18));
        v162 = v161 ^ v163;
        LODWORD(v163) = v122;
        v164 = v162 ^ (v159 >> 3);
        v165 = ((int)v111 - 12) & 0xBLL;
        v166 = v160 + v103;
        v167 = v164
             + v228[((_BYTE)v111 - 3) & 0xC]
             + v228[v165]
             + ((v163 >> 17) ^ __ROR4__(v122, 19) ^ (v122 >> 10));
        v168 = v158 + v160;
        HIDWORD(v163) = v166;
        LODWORD(v163) = v166;
        v169 = (v163 >> 6) ^ __ROR4__(v166, 11);
        v171 = __PAIR64__(v168, __ROR4__(v166, 25));
        v170 = v169 ^ v171;
        v228[v165] = v167;
        LODWORD(v171) = v168;
        v172 = v151 + v108 + v167 + (v132 & ~v166) + (v166 & v146) + v170;
        v173 = ((v171 >> 2) ^ __ROR4__(v168, 13) ^ __ROR4__(v168, 22)) + (v168 & (v152 ^ v133) ^ v152 & v133);
        v174 = v172 + v109;
        v175 = v228[v124 | 5];
        HIDWORD(v171) = v175;
        LODWORD(v171) = v175;
        v176 = (v171 >> 7) ^ __ROR4__(v175, 18);
        v177 = v228[v124 | 2];
        HIDWORD(v171) = v177;
        LODWORD(v171) = v177;
        LODWORD(v165) = v171 >> 17;
        v178 = __PAIR64__(v174, __ROR4__(v177, 19));
        v179 = ((_BYTE)v111 - 11) & 0xC;
        v180 = (v176 ^ (v175 >> 3)) + v228[((int)v111 - 2) & 0xDLL] + v228[v179] + (v165 ^ v178 ^ (v177 >> 10));
        v181 = v173 + v172;
        LODWORD(v178) = v174;
        v182 = (v178 >> 6) ^ __ROR4__(v174, 11);
        v184 = __PAIR64__(v181, __ROR4__(v174, 25));
        v183 = v182 ^ v184;
        v228[v179] = v180;
        LODWORD(v165) = *(v110 - 2);
        LODWORD(v184) = v181;
        LODWORD(v151) = ((v184 >> 2) ^ __ROR4__(v181, 13) ^ __ROR4__(v181, 22)) + (v181 & (v168 ^ v152) ^ v168 & v152);
        v185 = *(v110 - 3) + v180 + v132 + (v146 & ~v174) + (v174 & v166) + v183;
        v90 = v185 + v133;
        v186 = v228[v124 | 6];
        HIDWORD(v184) = v186;
        LODWORD(v184) = v186;
        v187 = v184 >> 7;
        LODWORD(v113) = v228[v124 | 3];
        HIDWORD(v184) = v113;
        LODWORD(v184) = v113;
        v188 = v184 >> 17;
        v189 = v187 ^ __ROR4__(v186, 18) ^ (v186 >> 3);
        v191 = __PAIR64__(v90, __ROR4__(v113, 19));
        v190 = v188 ^ v191;
        v192 = ((int)v111 - 10) & 0xDLL;
        v91 = v151 + v185;
        v193 = v228[v192] + v115 + v189 + (v190 ^ (v113 >> 10));
        LODWORD(v191) = v90;
        v194 = (v191 >> 6) ^ __ROR4__(v90, 11);
        v196 = __PAIR64__(v91, __ROR4__(v90, 25));
        v195 = v194 ^ v196;
        v228[v192] = v193;
        LODWORD(v196) = v91;
        v197 = v165 + v193 + v146 + (v166 & ~v90) + (v90 & v174) + v195;
        v198 = ((v196 >> 2) ^ __ROR4__(v91, 13) ^ __ROR4__(v91, 22)) + (v91 & (v181 ^ v168) ^ v181 & v168);
        LODWORD(v179) = v228[v124 | 7];
        v96 = v197 + v152;
        HIDWORD(v196) = v179;
        LODWORD(v196) = v179;
        LODWORD(v113) = v196 >> 7;
        v199 = v228[v124 | 4];
        v200 = __PAIR64__(v199, __ROR4__(v179, 18));
        LODWORD(v179) = v113 ^ v200 ^ (v179 >> 3);
        LODWORD(v200) = v199;
        LODWORD(v113) = v200 >> 17;
        v201 = __PAIR64__(v96, __ROR4__(v199, 19));
        v202 = ((_BYTE)v111 - 9) & 0xE;
        LODWORD(v179) = v228[v202] + v134 + v179 + (v113 ^ v201 ^ (v199 >> 10));
        v97 = v198 + v197;
        LODWORD(v201) = v96;
        v203 = (v201 >> 6) ^ __ROR4__(v96, 11);
        v205 = __PAIR64__(v97, __ROR4__(v96, 25));
        v204 = v203 ^ v205;
        v228[v202] = v179;
        LODWORD(v205) = v97;
        v206 = *(v110 - 1) + v179 + v166 + (v174 & ~v96) + (v96 & v90) + v204;
        v102 = v206 + v168;
        v103 = ((v205 >> 2) ^ __ROR4__(v97, 13) ^ __ROR4__(v97, 22)) + (v97 & (v91 ^ v181) ^ v91 & v181) + v206;
        v207 = v228[v124 ^ 8];
        HIDWORD(v205) = v207;
        LODWORD(v205) = v207;
        LODWORD(v179) = v205 >> 7;
        v208 = v228[v124 | 5];
        HIDWORD(v205) = v208;
        LODWORD(v205) = v208;
        LODWORD(v113) = v205 >> 17;
        v209 = v179 ^ __ROR4__(v207, 18) ^ (v207 >> 3);
        v210 = __PAIR64__(v102, __ROR4__(v208, 19));
        v211 = ((_BYTE)v111 - 8) & 0xF;
        LODWORD(v179) = v113 ^ v210 ^ (v208 >> 10);
        LODWORD(v210) = v102;
        v212 = (v210 >> 6) ^ __ROR4__(v102, 11);
        v213 = v228[v211] + v209 + v125 + v179;
        v214 = __PAIR64__(v103, __ROR4__(v102, 25));
        LODWORD(v179) = v212 ^ v214;
        v215 = *v110;
        v110 += 8;
        v228[v211] = v213;
        LODWORD(v214) = v103;
        v216 = v215 + v213 + v174 + (v90 & ~v102) + (v102 & v96) + v179;
        v108 = v216 + v181;
        v109 = ((v214 >> 2) ^ __ROR4__(v103, 13) ^ __ROR4__(v103, 22)) + (v103 & (v97 ^ v91) ^ v97 & v91) + v216;
        v111 += 8;
      }
      while (v112 < 0x38);
      a2 = v226 + 16;
      v3 = v109 + v225;
      v4 = v103 + v224;
      *v217 = v109 + v225;
      v217[1] = v103 + v224;
      v6 = v97 + v223;
      v5 = v91 + v222;
      v217[2] = v97 + v223;
      v217[3] = v91 + v222;
      v8 = v108 + v221;
      v7 = v102 + v220;
      v217[4] = v108 + v221;
      v217[5] = v102 + v220;
      v9 = v96 + v219;
      result = v90 + v218;
      v217[6] = v96 + v219;
      v217[7] = result;
      a3 = v227 - 1;
    }
    while (v227 != 1);
  }
  return result;
}

void SHA256_Transform(SHA256_CTX *c, const unsigned __int8 *data)
{
  sha256_block_data_order((unint64_t)c, (unsigned int *)data, 1);
}

uint64_t sha3_init(uint64_t a1, unsigned int a2)
{
  uint64_t v2;

  if (a2 > 0x63)
    return 0;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 208) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  v2 = 1;
  *(_QWORD *)(a1 + 208) = 200 - 2 * a2;
  *(_QWORD *)(a1 + 216) = a2;
  return v2;
}

uint64_t sha3_update(_QWORD *a1, char *a2, uint64_t a3)
{
  uint64_t v4;
  uint64_t v5;
  char v7;
  uint64_t v8;

  v4 = a1[25];
  if (a3)
  {
    v5 = a3;
    do
    {
      v7 = *a2++;
      v8 = v4 + 1;
      *((_BYTE *)a1 + v4) ^= v7;
      if ((unint64_t)(v4 + 1) >= a1[26])
      {
        sha3_keccakf(a1);
        v8 = 0;
      }
      v4 = v8;
      --v5;
    }
    while (v5);
  }
  else
  {
    v8 = a1[25];
  }
  a1[25] = v8;
  return 1;
}

_QWORD *sha3_keccakf(_QWORD *result)
{
  uint64_t v1;
  uint64_t i;
  uint64_t v3;
  _QWORD *v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  BOOL v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  _QWORD *v16;
  unint64_t v17;
  _QWORD *v18;
  __int128 v19;
  unint64_t v20;
  uint64_t v21;
  int v22;
  _OWORD v23[2];
  uint64_t v24;
  uint64_t v25;

  v1 = 0;
  v25 = *MEMORY[0x24BDAC8D0];
  do
  {
    for (i = 0; i != 5; ++i)
      *(_QWORD *)((char *)v23 + i * 8) = result[i + 5] ^ result[i] ^ result[i + 10] ^ result[i + 15] ^ result[i + 20];
    v3 = 0;
    v4 = result;
    do
    {
      v5 = 0;
      v6 = (v3 - 1);
      if (!v3)
        v6 = 4;
      v7 = *((_QWORD *)v23 + v6);
      v8 = ++v3;
      if (v3 == 5)
        v8 = 0;
      v9 = v7 ^ __ROR8__(*((_QWORD *)v23 + v8), 63);
      do
      {
        v4[v5] ^= v9;
        v10 = v5 >= 0x14;
        v5 += 5;
      }
      while (!v10);
      ++v4;
    }
    while (v3 != 5);
    v11 = 0;
    v12 = result[1];
    do
    {
      v13 = sha3_keccakf_piln[v11];
      v14 = result[v13];
      result[v13] = __ROR8__(v12, -sha3_keccakf_rotc[v11 * 4]);
      ++v11;
      v12 = v14;
    }
    while (v11 != 24);
    v15 = 0;
    v16 = result;
    do
    {
      v17 = 0;
      v18 = &result[5 * v15];
      v19 = *((_OWORD *)v18 + 1);
      v23[0] = *(_OWORD *)v18;
      v23[1] = v19;
      v24 = v18[4];
      do
      {
        if (v17 == 4)
          v20 = 0;
        else
          v20 = v17 + 1;
        v21 = *((_QWORD *)v23 + v20);
        if (v17 > 2)
          v22 = -3;
        else
          v22 = 2;
        v16[v17] ^= *((_QWORD *)v23 + v22 + (int)v17) & ~v21;
        ++v17;
      }
      while (v17 != 5);
      ++v15;
      v16 += 5;
    }
    while (v15 != 5);
    *result ^= sha3_keccakf_rndc[v1++];
  }
  while (v1 != 24);
  return result;
}

uint64_t sha3_final(uint64_t a1, _QWORD *a2)
{
  unint64_t v4;

  *((_BYTE *)a2 + a2[25]) ^= 6u;
  *((_BYTE *)a2 + a2[26] - 1) ^= 0x80u;
  sha3_keccakf(a2);
  if (a2[27])
  {
    v4 = 0;
    do
    {
      *(_BYTE *)(a1 + v4) = *((_BYTE *)a2 + v4);
      ++v4;
    }
    while (a2[27] > v4);
  }
  return 1;
}

_QWORD *shake_xof(_QWORD *a1)
{
  _QWORD *result;

  *((_BYTE *)a1 + a1[25]) ^= 0x1Fu;
  *((_BYTE *)a1 + a1[26] - 1) ^= 0x80u;
  result = sha3_keccakf(a1);
  a1[25] = 0;
  return result;
}

_QWORD *shake_out(_QWORD *result, _BYTE *a2, uint64_t a3)
{
  _QWORD *v3;
  unint64_t v4;
  uint64_t v5;
  unint64_t v7;

  v3 = result;
  v4 = result[25];
  if (a3)
  {
    v5 = a3;
    do
    {
      if (v4 >= v3[26])
      {
        result = sha3_keccakf(v3);
        v4 = 0;
      }
      v7 = v4 + 1;
      *a2++ = *((_BYTE *)v3 + v4++);
      --v5;
    }
    while (v5);
  }
  else
  {
    v7 = result[25];
  }
  v3[25] = v7;
  return result;
}

UI_METHOD *UI_OpenSSL(void)
{
  return (UI_METHOD *)&ui_openssl;
}

uint64_t open_console()
{
  int v0;

  CRYPTO_lock(9, 31, 0, 0);
  is_a_tty = 1;
  tty_in = (uint64_t)fopen("/dev/tty", "r");
  if (!tty_in)
    tty_in = *MEMORY[0x24BDAC8E0];
  tty_out = (uint64_t)fopen("/dev/tty", "w");
  if (!tty_out)
    tty_out = *MEMORY[0x24BDAC8D8];
  v0 = fileno((FILE *)tty_in);
  if (tcgetattr(v0, (termios *)&tty_orig) != -1)
    return 1;
  if (*__error() == 25 || *__error() == 22)
  {
    is_a_tty = 0;
    return 1;
  }
  return 0;
}

uint64_t write_string(int a1, UI_STRING *uis)
{
  const char *v3;

  if ((UI_get_string_type(uis) & 0xFFFFFFFE) == 4)
  {
    v3 = UI_get0_output_string(uis);
    fputs(v3, (FILE *)tty_out);
    fflush((FILE *)tty_out);
  }
  return 1;
}

uint64_t read_string(UI *a1, UI_STRING *uis)
{
  UI_string_types string_type;
  const char *v5;
  const char *v6;
  int v7;
  UI *v8;
  UI_STRING *v9;
  int v10;
  const char *v11;
  uint64_t result;
  FILE *v13;
  const char *v14;
  char input_flags;
  const char *v16;
  const char *v17;

  string_type = UI_get_string_type(uis);
  switch(string_type)
  {
    case UIT_PROMPT:
      v11 = UI_get0_output_string(uis);
      fputs(v11, (FILE *)tty_out);
      fflush((FILE *)tty_out);
      v7 = UI_get_input_flags(uis) & 1;
      v8 = a1;
      v9 = uis;
      v10 = 1;
      return read_string_inner(v8, v9, v7, v10);
    case UIT_VERIFY:
      v13 = (FILE *)tty_out;
      v14 = UI_get0_output_string(uis);
      fprintf(v13, "Verifying - %s", v14);
      fflush((FILE *)tty_out);
      input_flags = UI_get_input_flags(uis);
      result = read_string_inner(a1, uis, input_flags & 1, 1);
      if ((int)result < 1)
        return result;
      v16 = UI_get0_result_string(uis);
      v17 = UI_get0_test_string(uis);
      if (strcmp(v16, v17))
      {
        fwrite("Verify failure\n", 0xFuLL, 1uLL, (FILE *)tty_out);
        fflush((FILE *)tty_out);
        return 0;
      }
      break;
    case UIT_BOOLEAN:
      v5 = UI_get0_output_string(uis);
      fputs(v5, (FILE *)tty_out);
      v6 = UI_get0_action_string(uis);
      fputs(v6, (FILE *)tty_out);
      fflush((FILE *)tty_out);
      v7 = UI_get_input_flags(uis) & 1;
      v8 = a1;
      v9 = uis;
      v10 = 0;
      return read_string_inner(v8, v9, v7, v10);
  }
  return 1;
}

uint64_t close_console()
{
  if (tty_in != *MEMORY[0x24BDAC8E0])
    fclose((FILE *)tty_in);
  if (tty_out != *MEMORY[0x24BDAC8D8])
    fclose((FILE *)tty_out);
  CRYPTO_lock(10, 31, 0, 0);
  return 1;
}

uint64_t read_string_inner(UI *a1, UI_STRING *a2, int a3, int a4)
{
  uint64_t v8;
  sigaction *v9;
  BOOL v10;
  int v11;
  FILE *v12;
  _BOOL4 v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  const sigaction *v17;
  char *v19;
  int v20;
  char __s[5];
  termios v22[14];
  uint64_t v23;

  v23 = *MEMORY[0x24BDAC8D0];
  intr_signal = 0;
  read_string_inner_ps = 0;
  v22[0].c_iflag = (tcflag_t)recsig;
  v22[0].c_oflag = 0;
  v8 = -31;
  v9 = (sigaction *)&unk_255D8E3F8;
  do
  {
    if (v8 != -23 && (((_DWORD)v8 + 32) & 0x7FFFFFFE) != 0x1E)
      sigaction(v8 + 32, (const sigaction *)v22, v9);
    ++v9;
    v10 = __CFADD__(v8++, 1);
  }
  while (!v10);
  signal(28, 0);
  read_string_inner_ps = 1;
  if (!a3)
  {
    *(_OWORD *)v22[0].c_cc = xmmword_255D8E3B8;
    *(_OWORD *)&v22[0].c_cc[16] = unk_255D8E3C8;
    v22[0].c_ospeed = qword_255D8E3D8;
    *(_OWORD *)&v22[0].c_iflag = tty_orig;
    v22[0].c_cflag = unk_255D8E3A8;
    v22[0].c_lflag = unk_255D8E3B0 & 0xFFFFFFFFFFFFFFF7;
    if (is_a_tty == 1)
    {
      v11 = fileno((FILE *)tty_in);
      if (tcsetattr(v11, 0, v22) == -1)
      {
        if (intr_signal == 2)
          v14 = 0xFFFFFFFFLL;
        else
          v14 = 0;
        goto LABEL_36;
      }
    }
  }
  read_string_inner_ps = 2;
  LOBYTE(v22[0].c_iflag) = 0;
  if (!fgets((char *)v22, 1023, (FILE *)tty_in))
    goto LABEL_13;
  if (feof((FILE *)tty_in))
    goto LABEL_13;
  v12 = (FILE *)tty_in;
  if (ferror((FILE *)tty_in))
    goto LABEL_13;
  v19 = strchr((char *)v22, 10);
  if (!v19)
  {
    while (fgets(__s, 4, v12))
    {
      if (strchr(__s, 10))
        goto LABEL_29;
    }
LABEL_13:
    v13 = 0;
    goto LABEL_14;
  }
  if (a4)
    *v19 = 0;
LABEL_29:
  v13 = UI_set_result(a1, a2, (const char *)v22) >= 0;
LABEL_14:
  if (intr_signal == 2)
    v14 = 0xFFFFFFFFLL;
  else
    v14 = v13;
  if (a3)
    goto LABEL_18;
LABEL_36:
  fputc(10, (FILE *)tty_out);
  v15 = read_string_inner_ps;
  if (read_string_inner_ps <= 1)
  {
LABEL_19:
    if (v15 < 1)
      goto LABEL_25;
    goto LABEL_20;
  }
  if (is_a_tty == 1)
  {
    v20 = fileno((FILE *)tty_in);
    if (tcsetattr(v20, 0, (const termios *)&tty_orig) == -1)
      v14 = 0;
    else
      v14 = v14;
LABEL_18:
    v15 = read_string_inner_ps;
    goto LABEL_19;
  }
LABEL_20:
  v16 = -31;
  v17 = (const sigaction *)&unk_255D8E3F8;
  do
  {
    if ((((_DWORD)v16 + 32) & 0x7FFFFFFE) != 0x1E)
      sigaction(v16 + 32, v17, 0);
    ++v17;
    v10 = __CFADD__(v16++, 1);
  }
  while (!v10);
LABEL_25:
  explicit_bzero(v22, 0x400uLL);
  return v14;
}

uint64_t recsig(uint64_t result)
{
  intr_signal = result;
  return result;
}

int X509_CRL_get_ext_count(X509_CRL *x)
{
  return X509v3_get_ext_count(x->crl->extensions);
}

int X509_CRL_get_ext_by_NID(X509_CRL *x, int nid, int lastpos)
{
  return X509v3_get_ext_by_NID(x->crl->extensions, nid, lastpos);
}

int X509_CRL_get_ext_by_OBJ(X509_CRL *x, ASN1_OBJECT *obj, int lastpos)
{
  return X509v3_get_ext_by_OBJ(x->crl->extensions, obj, lastpos);
}

int X509_CRL_get_ext_by_critical(X509_CRL *x, int crit, int lastpos)
{
  return X509v3_get_ext_by_critical(x->crl->extensions, crit, lastpos);
}

X509_EXTENSION *__cdecl X509_CRL_get_ext(X509_CRL *x, int loc)
{
  return X509v3_get_ext(x->crl->extensions, loc);
}

X509_EXTENSION *__cdecl X509_CRL_delete_ext(X509_CRL *x, int loc)
{
  return X509v3_delete_ext(x->crl->extensions, loc);
}

void *__cdecl X509_CRL_get_ext_d2i(X509_CRL *x, int nid, int *crit, int *idx)
{
  return X509V3_get_d2i(x->crl->extensions, nid, crit, idx);
}

int X509_CRL_add1_ext_i2d(X509_CRL *x, int nid, void *value, int crit, unint64_t flags)
{
  return X509V3_add1_i2d(&x->crl->extensions, nid, value, crit, flags);
}

int X509_CRL_add_ext(X509_CRL *x, X509_EXTENSION *ex, int loc)
{
  return X509v3_add_ext(&x->crl->extensions, ex, loc) != 0;
}

int X509_get_ext_count(X509 *x)
{
  return X509v3_get_ext_count(x->cert_info->extensions);
}

int X509_get_ext_by_NID(X509 *x, int nid, int lastpos)
{
  return X509v3_get_ext_by_NID(x->cert_info->extensions, nid, lastpos);
}

int X509_get_ext_by_OBJ(X509 *x, ASN1_OBJECT *obj, int lastpos)
{
  return X509v3_get_ext_by_OBJ(x->cert_info->extensions, obj, lastpos);
}

int X509_get_ext_by_critical(X509 *x, int crit, int lastpos)
{
  return X509v3_get_ext_by_critical(x->cert_info->extensions, crit, lastpos);
}

X509_EXTENSION *__cdecl X509_get_ext(X509 *x, int loc)
{
  return X509v3_get_ext(x->cert_info->extensions, loc);
}

X509_EXTENSION *__cdecl X509_delete_ext(X509 *x, int loc)
{
  return X509v3_delete_ext(x->cert_info->extensions, loc);
}

int X509_add_ext(X509 *x, X509_EXTENSION *ex, int loc)
{
  return X509v3_add_ext(&x->cert_info->extensions, ex, loc) != 0;
}

void *__cdecl X509_get_ext_d2i(X509 *x, int nid, int *crit, int *idx)
{
  return X509V3_get_d2i(x->cert_info->extensions, nid, crit, idx);
}

int X509_add1_ext_i2d(X509 *x, int nid, void *value, int crit, unint64_t flags)
{
  return X509V3_add1_i2d(&x->cert_info->extensions, nid, value, crit, flags);
}

int X509_REVOKED_get_ext_count(X509_REVOKED *x)
{
  return X509v3_get_ext_count(x->extensions);
}

int X509_REVOKED_get_ext_by_NID(X509_REVOKED *x, int nid, int lastpos)
{
  return X509v3_get_ext_by_NID(x->extensions, nid, lastpos);
}

int X509_REVOKED_get_ext_by_OBJ(X509_REVOKED *x, ASN1_OBJECT *obj, int lastpos)
{
  return X509v3_get_ext_by_OBJ(x->extensions, obj, lastpos);
}

int X509_REVOKED_get_ext_by_critical(X509_REVOKED *x, int crit, int lastpos)
{
  return X509v3_get_ext_by_critical(x->extensions, crit, lastpos);
}

X509_EXTENSION *__cdecl X509_REVOKED_get_ext(X509_REVOKED *x, int loc)
{
  return X509v3_get_ext(x->extensions, loc);
}

X509_EXTENSION *__cdecl X509_REVOKED_delete_ext(X509_REVOKED *x, int loc)
{
  return X509v3_delete_ext(x->extensions, loc);
}

int X509_REVOKED_add_ext(X509_REVOKED *x, X509_EXTENSION *ex, int loc)
{
  return X509v3_add_ext(&x->extensions, ex, loc) != 0;
}

void *__cdecl X509_REVOKED_get_ext_d2i(X509_REVOKED *x, int nid, int *crit, int *idx)
{
  return X509V3_get_d2i(x->extensions, nid, crit, idx);
}

int X509_REVOKED_add1_ext_i2d(X509_REVOKED *x, int nid, void *value, int crit, unint64_t flags)
{
  return X509V3_add1_i2d(&x->extensions, nid, value, crit, flags);
}

BIO *__cdecl BIO_new_file(const char *filename, const char *mode)
{
  FILE *v4;
  FILE *v5;
  BIO *v6;
  BIO *v7;
  int *v8;
  int v9;
  int v10;

  v4 = fopen(filename, mode);
  if (v4)
  {
    v5 = v4;
    v6 = BIO_new(&methods_filep);
    v7 = v6;
    if (v6)
      BIO_ctrl(v6, 106, 1, v5);
    else
      fclose(v5);
  }
  else
  {
    v8 = __error();
    ERR_put_error(2, 4095, *v8, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/bio/bss_file.c", 124);
    ERR_asprintf_error_data("fopen('%s', '%s')", filename, mode);
    if (*__error() == 2)
    {
      v9 = 128;
      v10 = 127;
    }
    else
    {
      v9 = 2;
      v10 = 129;
    }
    ERR_put_error(32, 4095, v9, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/bio/bss_file.c", v10);
    return 0;
  }
  return v7;
}

BIO_METHOD *BIO_s_file(void)
{
  return (BIO_METHOD *)&methods_filep;
}

BIO *__cdecl BIO_new_fp(FILE *stream, int close_flag)
{
  BIO *v4;
  BIO *v5;

  v4 = BIO_new(&methods_filep);
  v5 = v4;
  if (v4)
    BIO_ctrl(v4, 106, close_flag, stream);
  return v5;
}

size_t file_write(uint64_t a1, void *__ptr, int a3)
{
  size_t result;

  result = 0;
  if (__ptr)
  {
    if (*(_DWORD *)(a1 + 32))
      return fwrite(__ptr, 1uLL, a3, *(FILE **)(a1 + 56));
  }
  return result;
}

uint64_t file_read(uint64_t a1, void *__ptr, int a3)
{
  uint64_t result;
  int *v5;

  result = 0;
  if (__ptr)
  {
    if (*(_DWORD *)(a1 + 32))
    {
      result = fread(__ptr, 1uLL, a3, *(FILE **)(a1 + 56));
      if (!(_DWORD)result)
      {
        result = ferror(*(FILE **)(a1 + 56));
        if ((_DWORD)result)
        {
          v5 = __error();
          ERR_put_error(2, 4095, *v5, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/bio/bss_file.c", 193);
          ERR_put_error(32, 4095, 2, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/bio/bss_file.c", 194);
          return 0xFFFFFFFFLL;
        }
      }
    }
  }
  return result;
}

size_t file_puts(uint64_t a1, char *__s)
{
  size_t result;
  int v5;

  result = 0;
  if (__s)
  {
    if (*(_DWORD *)(a1 + 32))
    {
      v5 = strlen(__s);
      return fwrite(__s, 1uLL, v5, *(FILE **)(a1 + 56));
    }
  }
  return result;
}

char *file_gets(uint64_t a1, char *a2, int a3)
{
  char *result;

  *a2 = 0;
  result = fgets(a2, a3, *(FILE **)(a1 + 56));
  if (result)
  {
    if (*a2)
      return (char *)strlen(a2);
    else
      return 0;
  }
  return result;
}

uint64_t file_ctrl(uint64_t a1, int a2, uint64_t a3, char *a4)
{
  char v4;
  FILE *v6;
  uint64_t v7;
  FILE *v10;
  int *v11;
  int v12;
  int v13;
  char __mode[4];

  v4 = a3;
  v6 = *(FILE **)(a1 + 56);
  if (a2 <= 105)
  {
    v7 = 1;
    switch(a2)
    {
      case 1:
        return fseek(v6, a3, 0);
      case 2:
        return feof(v6);
      case 3:
        goto LABEL_31;
      case 8:
        return *(int *)(a1 + 36);
      case 9:
        *(_DWORD *)(a1 + 36) = a3;
        return 1;
      case 11:
        fflush(v6);
        return 1;
      case 12:
        return v7;
      default:
        return 0;
    }
  }
  if (a2 > 107)
  {
    switch(a2)
    {
      case 108:
        file_free(a1);
        *(_DWORD *)(a1 + 36) = v4 & 1;
        if ((v4 & 8) != 0 || (v4 & 6) == 6 || (v4 & 6) != 0)
        {
          __strlcpy_chk();
          v10 = fopen(a4, __mode);
          if (v10)
          {
            *(_QWORD *)(a1 + 56) = v10;
            v7 = 1;
            *(_DWORD *)(a1 + 32) = 1;
            return v7;
          }
          v11 = __error();
          ERR_put_error(2, 4095, *v11, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/bio/bss_file.c", 257);
          ERR_asprintf_error_data("fopen('%s', '%s')", a4, __mode);
          v12 = 2;
          v13 = 259;
        }
        else
        {
          v12 = 101;
          v13 = 251;
        }
        ERR_put_error(32, 4095, v12, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/bio/bss_file.c", v13);
        break;
      case 133:
LABEL_31:
        JUMPOUT(0x22E314F60);
      case 128:
        return fseek(v6, a3, 0);
    }
    return 0;
  }
  if (a2 == 106)
  {
    file_free(a1);
    *(_QWORD *)(a1 + 56) = a4;
    v7 = 1;
    *(_DWORD *)(a1 + 32) = 1;
    *(_DWORD *)(a1 + 36) = v4 & 1;
  }
  else
  {
    if (a4)
      *(_QWORD *)a4 = v6;
    return 1;
  }
  return v7;
}

uint64_t file_new(uint64_t a1)
{
  *(_DWORD *)(a1 + 32) = 0;
  *(_DWORD *)(a1 + 48) = 0;
  *(_QWORD *)(a1 + 56) = 0;
  *(_DWORD *)(a1 + 40) = 0;
  return 1;
}

uint64_t file_free(uint64_t result)
{
  uint64_t v1;
  FILE *v2;

  if (result)
  {
    v1 = result;
    if (*(_DWORD *)(result + 36))
    {
      if (*(_DWORD *)(result + 32))
      {
        v2 = *(FILE **)(result + 56);
        if (v2)
        {
          fclose(v2);
          *(_QWORD *)(v1 + 56) = 0;
          *(_DWORD *)(v1 + 40) = 0;
        }
      }
      *(_DWORD *)(v1 + 32) = 0;
    }
    return 1;
  }
  return result;
}

AUTHORITY_KEYID *__cdecl d2i_AUTHORITY_KEYID(AUTHORITY_KEYID **a, const unsigned __int8 **in, uint64_t len)
{
  return (AUTHORITY_KEYID *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &AUTHORITY_KEYID_it);
}

int i2d_AUTHORITY_KEYID(AUTHORITY_KEYID *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &AUTHORITY_KEYID_it);
}

AUTHORITY_KEYID *AUTHORITY_KEYID_new(void)
{
  return (AUTHORITY_KEYID *)ASN1_item_new(&AUTHORITY_KEYID_it);
}

void AUTHORITY_KEYID_free(AUTHORITY_KEYID *a)
{
  ASN1_item_free((ASN1_VALUE *)a, &AUTHORITY_KEYID_it);
}

uint64_t Camellia_ecb_encrypt(unsigned int *a1, _BYTE *a2, _DWORD *a3, int a4)
{
  if (a4 == 1)
    return Camellia_encrypt(a1, a2, a3);
  else
    return Camellia_decrypt(a1, a2, a3);
}

void HMAC_Init_ex(HMAC_CTX *ctx, const void *key, int len, const EVP_MD *md, ENGINE *impl)
{
  int v6;
  const EVP_MD *v9;
  int v10;
  int v11;
  int v12;
  uint64_t v13;
  int8x16_t v14;
  int v15;
  uint64_t v16;
  int8x16_t v17;
  int v18;
  _BYTE d[144];
  uint64_t v20;

  v6 = len;
  v20 = *MEMORY[0x24BDAC8D0];
  v9 = ctx->md;
  if (md)
  {
    if (v9 != md && (!key || len < 0))
      return;
    ctx->md = md;
    v9 = md;
  }
  else if (!v9)
  {
    return;
  }
  if (key)
  {
    v10 = EVP_MD_block_size(v9);
    if (v10 >= 0x91)
    {
      v11 = 136;
      v12 = 92;
LABEL_27:
      ERR_put_error(6, 4095, v11, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/hmac/hmac.c", v12);
      return;
    }
    if (v10 >= v6)
    {
      if (v6 >= 0x91)
      {
        v11 = 137;
        v12 = 105;
        goto LABEL_27;
      }
      memcpy(&ctx->key[48], key, v6);
      *(_DWORD *)&ctx->key[44] = v6;
    }
    else
    {
      if (!EVP_DigestInit_ex(&ctx->md_ctx, v9, impl)
        || !EVP_DigestUpdate(&ctx->md_ctx, key, v6)
        || !EVP_DigestFinal_ex(&ctx->md_ctx, &ctx->key[48], (unsigned int *)&ctx->key[44]))
      {
        return;
      }
      v6 = *(_DWORD *)&ctx->key[44];
    }
    if (v6 != 144)
      bzero(&ctx->key[v6 + 48], (144 - v6));
  }
  else if (!md)
  {
LABEL_19:
    EVP_MD_CTX_copy_ex(&ctx->md_ctx, (const EVP_MD_CTX *)&ctx->i_ctx.flags);
    return;
  }
  v13 = 0;
  v14.i64[0] = 0x3636363636363636;
  v14.i64[1] = 0x3636363636363636;
  do
  {
    *(int8x16_t *)&d[v13] = veorq_s8(*(int8x16_t *)&ctx->key[v13 + 48], v14);
    v13 += 16;
  }
  while (v13 != 144);
  if (EVP_DigestInit_ex((EVP_MD_CTX *)&ctx->i_ctx.flags, v9, impl))
  {
    v15 = EVP_MD_block_size(v9);
    if (EVP_DigestUpdate((EVP_MD_CTX *)&ctx->i_ctx.flags, d, v15))
    {
      v16 = 0;
      v17.i64[0] = 0x5C5C5C5C5C5C5C5CLL;
      v17.i64[1] = 0x5C5C5C5C5C5C5C5CLL;
      do
      {
        *(int8x16_t *)&d[v16] = veorq_s8(*(int8x16_t *)&ctx->key[v16 + 48], v17);
        v16 += 16;
      }
      while (v16 != 144);
      if (EVP_DigestInit_ex((EVP_MD_CTX *)&ctx->key_length, v9, impl))
      {
        v18 = EVP_MD_block_size(v9);
        if (EVP_DigestUpdate((EVP_MD_CTX *)&ctx->key_length, d, v18))
          goto LABEL_19;
      }
    }
  }
}

void HMAC_Init(HMAC_CTX *ctx, const void *key, int len, const EVP_MD *md)
{
  if (key && md)
    HMAC_CTX_init(ctx);
  HMAC_Init_ex(ctx, key, len, md, 0);
}

void HMAC_CTX_init(HMAC_CTX *ctx)
{
  EVP_MD_CTX_init((EVP_MD_CTX *)&ctx->i_ctx.flags);
  EVP_MD_CTX_init((EVP_MD_CTX *)&ctx->key_length);
  EVP_MD_CTX_init(&ctx->md_ctx);
  ctx->md = 0;
}

void HMAC_Update(HMAC_CTX *ctx, const unsigned __int8 *data, size_t len)
{
  if (ctx->md)
    EVP_DigestUpdate(&ctx->md_ctx, data, len);
}

void HMAC_Final(HMAC_CTX *ctx, unsigned __int8 *md, unsigned int *len)
{
  EVP_MD_CTX *p_md_ctx;
  unsigned int s;
  unsigned __int8 mda[64];
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  if (ctx->md)
  {
    s = 0;
    p_md_ctx = &ctx->md_ctx;
    if (EVP_DigestFinal_ex(&ctx->md_ctx, mda, &s))
    {
      if (EVP_MD_CTX_copy_ex(p_md_ctx, (const EVP_MD_CTX *)&ctx->key_length))
      {
        if (EVP_DigestUpdate(p_md_ctx, mda, s))
          EVP_DigestFinal_ex(p_md_ctx, md, len);
      }
    }
  }
}

HMAC_CTX *HMAC_CTX_new()
{
  HMAC_CTX *v0;
  HMAC_CTX *v1;

  v0 = (HMAC_CTX *)malloc_type_calloc(1uLL, 0x130uLL, 0x10E0040A0318B61uLL);
  v1 = v0;
  if (v0)
    HMAC_CTX_init(v0);
  return v1;
}

void HMAC_CTX_free(HMAC_CTX *a1)
{
  if (a1)
  {
    HMAC_CTX_cleanup(a1);
    free(a1);
  }
}

void HMAC_CTX_cleanup(HMAC_CTX *ctx)
{
  EVP_MD_CTX_cleanup((EVP_MD_CTX *)&ctx->i_ctx.flags);
  EVP_MD_CTX_cleanup((EVP_MD_CTX *)&ctx->key_length);
  EVP_MD_CTX_cleanup(&ctx->md_ctx);
  explicit_bzero(ctx, 0x130uLL);
}

uint64_t HMAC_CTX_reset(HMAC_CTX *a1)
{
  HMAC_CTX_cleanup(a1);
  HMAC_CTX_init(a1);
  return 1;
}

uint64_t HMAC_CTX_copy(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;

  result = EVP_MD_CTX_copy((EVP_MD_CTX *)(a1 + 56), (const EVP_MD_CTX *)(a2 + 56));
  if ((_DWORD)result)
  {
    result = EVP_MD_CTX_copy((EVP_MD_CTX *)(a1 + 104), (const EVP_MD_CTX *)(a2 + 104));
    if ((_DWORD)result)
    {
      result = EVP_MD_CTX_copy((EVP_MD_CTX *)(a1 + 8), (const EVP_MD_CTX *)(a2 + 8));
      if ((_DWORD)result)
      {
        *(_OWORD *)(a1 + 156) = *(_OWORD *)(a2 + 156);
        v5 = *(_OWORD *)(a2 + 172);
        v6 = *(_OWORD *)(a2 + 188);
        v7 = *(_OWORD *)(a2 + 204);
        *(_OWORD *)(a1 + 220) = *(_OWORD *)(a2 + 220);
        *(_OWORD *)(a1 + 204) = v7;
        *(_OWORD *)(a1 + 188) = v6;
        *(_OWORD *)(a1 + 172) = v5;
        v8 = *(_OWORD *)(a2 + 236);
        v9 = *(_OWORD *)(a2 + 252);
        v10 = *(_OWORD *)(a2 + 284);
        *(_OWORD *)(a1 + 268) = *(_OWORD *)(a2 + 268);
        *(_OWORD *)(a1 + 284) = v10;
        *(_OWORD *)(a1 + 252) = v9;
        *(_OWORD *)(a1 + 236) = v8;
        *(_DWORD *)(a1 + 152) = *(_DWORD *)(a2 + 152);
        *(_QWORD *)a1 = *(_QWORD *)a2;
        return 1;
      }
    }
  }
  return result;
}

void HMAC_CTX_set_flags(HMAC_CTX *ctx, unint64_t flags)
{
  int v2;

  v2 = flags;
  EVP_MD_CTX_set_flags((EVP_MD_CTX *)&ctx->i_ctx.flags, flags);
  EVP_MD_CTX_set_flags((EVP_MD_CTX *)&ctx->key_length, v2);
  EVP_MD_CTX_set_flags(&ctx->md_ctx, v2);
}

uint64_t HMAC_CTX_get_md(uint64_t a1)
{
  return *(_QWORD *)a1;
}

unsigned __int8 *__cdecl HMAC(const EVP_MD *evp_md, const void *key, int key_len, const unsigned __int8 *d, size_t n, unsigned __int8 *md, unsigned int *md_len)
{
  unsigned __int8 *v11;
  int v12;
  char *v13;
  int v14;
  int v15;
  char v17;
  HMAC_CTX ctx;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  uint64_t v23;

  v23 = *MEMORY[0x24BDAC8D0];
  v21 = 0u;
  v22 = 0u;
  v19 = 0u;
  v20 = 0u;
  memset(&ctx.md_ctx.md_data, 0, 208);
  if (md)
    v11 = md;
  else
    v11 = (unsigned __int8 *)&HMAC_m;
  memset(&ctx, 0, 32);
  if (key)
    v12 = key_len;
  else
    v12 = 0;
  if (key)
    v13 = (char *)key;
  else
    v13 = &v17;
  v17 = 0;
  HMAC_CTX_init(&ctx);
  HMAC_Init_ex(&ctx, v13, v12, evp_md, 0);
  if (!v14 || !ctx.md || !EVP_DigestUpdate(&ctx.md_ctx, d, n) || (HMAC_Final(&ctx, v11, md_len), !v15))
    v11 = 0;
  HMAC_CTX_cleanup(&ctx);
  return v11;
}

int EC_GROUP_get_basis_type(const EC_GROUP *a1)
{
  const EC_METHOD *v2;
  uint64_t v3;
  int v5;

  v2 = EC_GROUP_method_of(a1);
  if (EC_METHOD_get_field_type(v2) != 407)
    return 0;
  v3 = 0;
  while (*((_DWORD *)a1 + v3++ + 32))
    ;
  if ((_DWORD)v3 == 3)
    v5 = 682;
  else
    v5 = 0;
  if ((_DWORD)v3 == 5)
    return 683;
  else
    return v5;
}

ASN1_VALUE *X9_62_PENTANOMIAL_new()
{
  return ASN1_item_new(&X9_62_PENTANOMIAL_it);
}

void X9_62_PENTANOMIAL_free(ASN1_VALUE *a1)
{
  ASN1_item_free(a1, &X9_62_PENTANOMIAL_it);
}

ASN1_VALUE *X9_62_CHARACTERISTIC_TWO_new()
{
  return ASN1_item_new(&X9_62_CHARACTERISTIC_TWO_it);
}

void X9_62_CHARACTERISTIC_TWO_free(ASN1_VALUE *a1)
{
  ASN1_item_free(a1, &X9_62_CHARACTERISTIC_TWO_it);
}

ASN1_VALUE *ECPARAMETERS_new()
{
  return ASN1_item_new(&ECPARAMETERS_it);
}

void ECPARAMETERS_free(ASN1_VALUE *a1)
{
  ASN1_item_free(a1, &ECPARAMETERS_it);
}

ASN1_VALUE *d2i_ECPKPARAMETERS(ASN1_VALUE **a1, const unsigned __int8 **a2, uint64_t a3)
{
  return ASN1_item_d2i(a1, a2, a3, &ECPKPARAMETERS_it);
}

uint64_t i2d_ECPKPARAMETERS(ASN1_VALUE *a1, unsigned __int8 **a2)
{
  return ASN1_item_i2d(a1, a2, &ECPKPARAMETERS_it);
}

ASN1_VALUE *ECPKPARAMETERS_new()
{
  return ASN1_item_new(&ECPKPARAMETERS_it);
}

void ECPKPARAMETERS_free(ASN1_VALUE *a1)
{
  ASN1_item_free(a1, &ECPKPARAMETERS_it);
}

ASN1_VALUE *d2i_EC_PRIVATEKEY(ASN1_VALUE **a1, const unsigned __int8 **a2, uint64_t a3)
{
  return ASN1_item_d2i(a1, a2, a3, &EC_PRIVATEKEY_it);
}

uint64_t i2d_EC_PRIVATEKEY(ASN1_VALUE *a1, unsigned __int8 **a2)
{
  return ASN1_item_i2d(a1, a2, &EC_PRIVATEKEY_it);
}

ASN1_VALUE *EC_PRIVATEKEY_new()
{
  return ASN1_item_new(&EC_PRIVATEKEY_it);
}

void EC_PRIVATEKEY_free(ASN1_VALUE *a1)
{
  ASN1_item_free(a1, &EC_PRIVATEKEY_it);
}

EC_GROUP *__cdecl d2i_ECPKParameters(EC_GROUP **a1, const unsigned __int8 **in, uint64_t len)
{
  const ASN1_OBJECT **v4;
  ASN1_VALUE *v5;
  EC_GROUP *v6;

  v4 = (const ASN1_OBJECT **)ASN1_item_d2i(0, in, len, &ECPKPARAMETERS_it);
  v5 = (ASN1_VALUE *)v4;
  if (v4)
  {
    v6 = ec_asn1_pkparameters2group(v4);
    if (v6)
    {
      if (a1)
      {
        EC_GROUP_free(*a1);
        *a1 = v6;
      }
    }
    else
    {
      ERR_put_error(16, 4095, 127, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_asn1.c", 1107);
    }
  }
  else
  {
    ERR_put_error(16, 4095, 117, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_asn1.c", 1103);
    v6 = 0;
  }
  ASN1_item_free(v5, &ECPKPARAMETERS_it);
  return v6;
}

EC_GROUP *ec_asn1_pkparameters2group(const ASN1_OBJECT **a1)
{
  int v1;
  int v2;
  EC_GROUP *v3;
  EC_GROUP *v4;
  int v5;
  int v6;
  int v7;
  const ASN1_OBJECT *v8;
  const char *ln;
  uint64_t *v10;
  uint64_t v11;
  const unsigned __int8 *v12;
  uint64_t v13;
  BIGNUM *v14;
  BIGNUM *v15;
  int v16;
  int v17;
  int v18;
  int v19;
  int v20;
  int v21;
  BIGNUM *v22;
  EC_POINT *v23;
  ASN1_INTEGER *v25;
  BIGNUM *v26;
  int v27;
  int v28;
  int v29;
  int v30;
  EC_GROUP *v31;
  void *v32;
  unsigned __int8 *data;
  BIGNUM *v34;
  int v35;
  int v36;
  int v37;
  int v38;
  ASN1_INTEGER *sn;
  const ASN1_OBJECT *v40;

  if (!a1)
  {
    v6 = 124;
    v7 = 1066;
LABEL_22:
    ERR_put_error(16, 4095, v6, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_asn1.c", v7);
    return 0;
  }
  v1 = *(_DWORD *)a1;
  if (*(_DWORD *)a1 != 2)
  {
    if (v1 != 1)
    {
      if (!v1)
      {
        v2 = OBJ_obj2nid(a1[1]);
        v3 = EC_GROUP_new_by_curve_name(v2);
        v4 = v3;
        if (v3)
        {
          v5 = 1;
LABEL_33:
          EC_GROUP_set_asn1_flag(v3, v5);
          return v4;
        }
        v20 = 119;
        v21 = 1072;
        goto LABEL_35;
      }
      v6 = 115;
      v7 = 1087;
      goto LABEL_22;
    }
    v8 = a1[1];
    ln = v8->ln;
    if (ln && *(_QWORD *)ln && *((_QWORD *)ln + 1))
    {
      v10 = *(uint64_t **)&v8->nid;
      if (v10)
      {
        v11 = *v10;
        if (*v10)
        {
          v12 = *(const unsigned __int8 **)(v11 + 8);
          if (v12)
          {
            v13 = v10[1];
            if (v13)
            {
              if (*(_QWORD *)(v13 + 8))
              {
                v14 = BN_bin2bn(v12, *(_DWORD *)v11, 0);
                if (v14)
                {
                  v15 = BN_bin2bn(*(const unsigned __int8 **)(*(_QWORD *)(*(_QWORD *)&v8->nid + 8) + 8), **(_DWORD **)(*(_QWORD *)&v8->nid + 8), 0);
                  if (v15)
                  {
                    v16 = OBJ_obj2nid(*(const ASN1_OBJECT **)v8->ln);
                    if (v16 != 406)
                    {
                      if (v16 == 407)
                      {
                        v17 = 147;
                        v18 = 957;
                      }
                      else
                      {
                        v17 = 103;
                        v18 = 983;
                      }
                      goto LABEL_46;
                    }
                    v25 = (ASN1_INTEGER *)*((_QWORD *)v8->ln + 1);
                    if (v25)
                    {
                      v26 = ASN1_INTEGER_to_BN(v25, 0);
                      v22 = v26;
                      if (!v26)
                      {
                        v27 = 13;
                        v28 = 968;
                        goto LABEL_48;
                      }
                      if (BN_is_negative((uint64_t)v26) || BN_is_zero((uint64_t)v22))
                      {
                        v27 = 103;
                        v28 = 972;
LABEL_48:
                        ERR_put_error(16, 4095, v27, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_asn1.c", v28);
                        v4 = 0;
                        goto LABEL_29;
                      }
                      v40 = v8;
                      v29 = BN_num_bits(v22);
                      if (v29 >= 662)
                      {
                        v27 = 143;
                        v28 = 977;
                        goto LABEL_48;
                      }
                      v30 = v29;
                      v31 = EC_GROUP_new_curve_GFp(v22, v14, v15, 0);
                      v4 = v31;
                      if (v31)
                      {
                        if (*(_QWORD *)(*(_QWORD *)&v40->nid + 16))
                        {
                          free(*((void **)v31 + 10));
                          v32 = malloc_type_malloc(**(int **)(*(_QWORD *)&v40->nid + 16), 0x8DA7DACBuLL);
                          *((_QWORD *)v4 + 10) = v32;
                          if (!v32)
                          {
                            v37 = 65;
                            v38 = 995;
                            goto LABEL_67;
                          }
                          memcpy(v32, *(const void **)(*(_QWORD *)(*(_QWORD *)&v40->nid + 16) + 8), **(int **)(*(_QWORD *)&v40->nid + 16));
                          *((_QWORD *)v4 + 11) = **(int **)(*(_QWORD *)&v40->nid + 16);
                        }
                        if (*(_QWORD *)&v40->flags)
                        {
                          data = v40->data;
                          if (data)
                          {
                            if (*((_QWORD *)data + 1))
                            {
                              v23 = EC_POINT_new(v4);
                              if (!v23)
                                goto LABEL_30;
                              EC_GROUP_set_point_conversion_form(v4, (point_conversion_form_t)(**((_BYTE **)v40->data + 1) & 0xFE));
                              if (EC_POINT_oct2point(v4, v23, *((const unsigned __int8 **)v40->data + 1), *(int *)v40->data, 0))
                              {
                                v34 = ASN1_INTEGER_to_BN(*(ASN1_INTEGER **)&v40->flags, v14);
                                v14 = v34;
                                if (v34)
                                {
                                  if (BN_is_negative((uint64_t)v34) || BN_is_zero((uint64_t)v14))
                                  {
                                    v35 = 122;
                                    v36 = 1025;
                                  }
                                  else
                                  {
                                    if (BN_num_bits(v14) <= v30 + 1)
                                    {
                                      sn = (ASN1_INTEGER *)v40[1].sn;
                                      if (sn)
                                      {
                                        v15 = ASN1_INTEGER_to_BN(sn, v15);
                                        if (!v15)
                                        {
                                          v35 = 13;
                                          v36 = 1037;
                                          goto LABEL_70;
                                        }
                                      }
                                      else
                                      {
                                        BN_free(v15);
                                        v15 = 0;
                                      }
                                      if (EC_GROUP_set_generator(v4, v23, v14, v15))
                                        goto LABEL_31;
                                      v35 = 16;
                                      v36 = 1042;
                                      goto LABEL_70;
                                    }
                                    v35 = 122;
                                    v36 = 1029;
                                  }
                                }
                                else
                                {
                                  v35 = 13;
                                  v36 = 1021;
                                }
                              }
                              else
                              {
                                v35 = 16;
                                v36 = 1016;
                              }
LABEL_70:
                              ERR_put_error(16, 4095, v35, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_asn1.c", v36);
                              goto LABEL_30;
                            }
                          }
                        }
                        v37 = 115;
                        v38 = 1003;
                      }
                      else
                      {
                        v37 = 16;
                        v38 = 988;
                      }
LABEL_67:
                      ERR_put_error(16, 4095, v37, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_asn1.c", v38);
                      goto LABEL_29;
                    }
                    v17 = 115;
                    v18 = 963;
                  }
                  else
                  {
                    v17 = 3;
                    v18 = 951;
                  }
LABEL_46:
                  ERR_put_error(16, 4095, v17, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_asn1.c", v18);
                  v4 = 0;
                  v22 = 0;
                  goto LABEL_29;
                }
                ERR_put_error(16, 4095, 3, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_asn1.c", 946);
                v4 = 0;
                v22 = 0;
LABEL_28:
                v15 = 0;
LABEL_29:
                v23 = 0;
LABEL_30:
                EC_GROUP_free(v4);
                v4 = 0;
LABEL_31:
                BN_free(v22);
                BN_free(v14);
                BN_free(v15);
                EC_POINT_free(v23);
                if (v4)
                {
                  v3 = v4;
                  v5 = 0;
                  goto LABEL_33;
                }
                v20 = 16;
                v21 = 1080;
LABEL_35:
                ERR_put_error(16, 4095, v20, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_asn1.c", v21);
                return v4;
              }
            }
          }
        }
      }
      v19 = 941;
    }
    else
    {
      v19 = 934;
    }
    ERR_put_error(16, 4095, 115, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_asn1.c", v19);
    v4 = 0;
    v22 = 0;
    v14 = 0;
    goto LABEL_28;
  }
  return 0;
}

int i2d_ECPKParameters(const EC_GROUP *a1, unsigned __int8 **out)
{
  ASN1_VALUE *v3;
  ASN1_VALUE *v4;
  int v5;

  v3 = ec_asn1_group2pkparameters(a1, 0);
  if (v3)
  {
    v4 = v3;
    v5 = ASN1_item_i2d(v3, out, &ECPKPARAMETERS_it);
    if (!v5)
      ERR_put_error(16, 4095, 121, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_asn1.c", 1131);
    ASN1_item_free(v4, &ECPKPARAMETERS_it);
  }
  else
  {
    ERR_put_error(16, 4095, 120, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_asn1.c", 1127);
    return 0;
  }
  return v5;
}

ASN1_VALUE *ec_asn1_group2pkparameters(EC_GROUP *a1, uint64_t a2)
{
  ASN1_VALUE *v3;
  ASN1_OBJECT *v4;
  ASN1_VALUE *v5;
  int curve_name;
  ASN1_OBJECT *v7;
  BIGNUM *v9;
  ASN1_VALUE *v10;
  ASN1_VALUE *v11;
  uint64_t v12;
  ASN1_TYPE *v13;
  const EC_METHOD *v14;
  int field_type;
  ASN1_OBJECT *v16;
  BIGNUM *v17;
  ASN1_INTEGER *v18;
  ASN1_STRING **v19;
  BIGNUM *v20;
  BIGNUM *v21;
  BIGNUM *v22;
  int v23;
  int v24;
  unsigned int v25;
  int v26;
  int v27;
  unsigned __int8 *v28;
  int v29;
  unsigned __int8 *v30;
  void *v31;
  int v32;
  int v33;
  int v34;
  int v35;
  int v36;
  int v37;
  void *v38;
  int v39;
  int v40;
  int v41;
  ASN1_BIT_STRING *v42;
  const EC_POINT *v43;
  const EC_POINT *v44;
  point_conversion_form_t point_conversion_form;
  size_t v46;
  size_t v47;
  ASN1_OCTET_STRING *v48;
  ASN1_INTEGER *v49;
  ASN1_INTEGER *v50;
  int v51;
  int v52;
  int v53;
  int v54;
  int v55;
  int v56;
  int len;
  unsigned __int8 *data;
  char *v59;
  char v60;

  if (a2)
  {
    v3 = (ASN1_VALUE *)a2;
    if (*(_DWORD *)a2 == 1)
    {
      v5 = *(ASN1_VALUE **)(a2 + 8);
      if (v5)
        ASN1_item_free(v5, &ECPARAMETERS_it);
    }
    else if (!*(_DWORD *)a2)
    {
      v4 = *(ASN1_OBJECT **)(a2 + 8);
      if (v4)
        ASN1_OBJECT_free(v4);
    }
  }
  else
  {
    v3 = ASN1_item_new(&ECPKPARAMETERS_it);
    if (!v3)
    {
      ERR_put_error(16, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_asn1.c", 885);
      return v3;
    }
  }
  if (!EC_GROUP_get_asn1_flag(a1))
  {
    *(_DWORD *)v3 = 1;
    v9 = BN_new();
    if (!v9)
    {
      ERR_put_error(16, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_asn1.c", 794);
      v31 = 0;
LABEL_52:
      v11 = 0;
      goto LABEL_53;
    }
    v10 = ASN1_item_new(&ECPARAMETERS_it);
    v11 = v10;
    if (!v10)
    {
      ERR_put_error(16, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_asn1.c", 799);
      v31 = 0;
      goto LABEL_53;
    }
    *(_QWORD *)v10 = 1;
    if (!a1)
      goto LABEL_49;
    v12 = *((_QWORD *)v10 + 1);
    if (!v12)
      goto LABEL_49;
    if (*(_QWORD *)v12)
      ASN1_OBJECT_free(*(ASN1_OBJECT **)v12);
    v13 = *(ASN1_TYPE **)(v12 + 8);
    if (v13)
      ASN1_TYPE_free(v13);
    v14 = EC_GROUP_method_of(a1);
    field_type = EC_METHOD_get_field_type(v14);
    v16 = OBJ_nid2obj(field_type);
    *(_QWORD *)v12 = v16;
    if (v16)
    {
      if (field_type == 406)
      {
        v17 = BN_new();
        if (v17)
        {
          if (EC_GROUP_get_curve((uint64_t)a1, (uint64_t)v17, 0, 0, 0))
          {
            v18 = BN_to_ASN1_INTEGER(v17, 0);
            *(_QWORD *)(v12 + 8) = v18;
            if (v18)
            {
              BN_free(v17);
              v19 = (ASN1_STRING **)*((_QWORD *)v11 + 2);
              v60 = 0;
              if (!v19 || !*v19 || !v19[1])
                goto LABEL_59;
              v20 = BN_new();
              if (v20 && (v21 = BN_new()) != 0)
              {
                v22 = v21;
                if (EC_GROUP_get_curve((uint64_t)a1, 0, (uint64_t)v20, (uint64_t)v21, 0))
                {
                  v23 = BN_num_bits(v20);
                  v24 = BN_num_bits(v22);
                  v25 = v24 + 14;
                  if (v24 >= -7)
                    v26 = v24 + 7;
                  else
                    v26 = v24 + 14;
                  v27 = v23 + 14;
                  if ((v23 + 14) < 0xF)
                  {
                    v28 = 0;
                    v29 = 1;
                    v30 = (unsigned __int8 *)&v60;
                    goto LABEL_66;
                  }
                  if (v23 >= -7)
                    v27 = v23 + 7;
                  v28 = (unsigned __int8 *)malloc_type_malloc((uint64_t)v27 >> 3, 0xE0C18CA2uLL);
                  if (v28)
                  {
                    v39 = BN_bn2bin(v20, v28);
                    if (v39)
                    {
                      v29 = v39;
                      v30 = v28;
LABEL_66:
                      if (v25 < 0xF)
                      {
                        v38 = 0;
                        v40 = 1;
                        v59 = &v60;
LABEL_71:
                        if (ASN1_STRING_set(*v19, v30, v29) && ASN1_STRING_set(v19[1], v59, v40))
                        {
                          ASN1_BIT_STRING_free(v19[2]);
                          v19[2] = 0;
                          if (!*((_QWORD *)a1 + 10))
                            goto LABEL_77;
                          v42 = ASN1_BIT_STRING_new();
                          v19[2] = v42;
                          if (v42)
                          {
                            if (ASN1_BIT_STRING_set(v42, *((unsigned __int8 **)a1 + 10), *((_DWORD *)a1 + 22)))
                            {
                              if (asn1_abs_set_unused_bits((uint64_t)v19[2], 0))
                              {
LABEL_77:
                                free(v28);
                                free(v38);
                                BN_free(v20);
                                BN_free(v22);
                                v43 = EC_GROUP_get0_generator(a1);
                                if (v43)
                                {
                                  v44 = v43;
                                  point_conversion_form = EC_GROUP_get_point_conversion_form(a1);
                                  v46 = EC_POINT_point2oct(a1, v44, point_conversion_form, 0, 0, 0);
                                  if (v46)
                                  {
                                    v47 = v46;
                                    v31 = malloc_type_malloc(v46, 0x5CC31266uLL);
                                    if (v31)
                                    {
                                      if (EC_POINT_point2oct(a1, v44, point_conversion_form, (unsigned __int8 *)v31, v47, 0))
                                      {
                                        v48 = (ASN1_OCTET_STRING *)*((_QWORD *)v11 + 3);
                                        if (v48 || (v48 = ASN1_OCTET_STRING_new(), (*((_QWORD *)v11 + 3) = v48) != 0))
                                        {
                                          if (ASN1_OCTET_STRING_set(v48, (const unsigned __int8 *)v31, v47))
                                          {
                                            if (EC_GROUP_get_order(a1, v9, 0))
                                            {
                                              v49 = BN_to_ASN1_INTEGER(v9, *((ASN1_INTEGER **)v11 + 4));
                                              *((_QWORD *)v11 + 4) = v49;
                                              if (v49)
                                              {
                                                if (!EC_GROUP_get_cofactor(a1, v9, 0)
                                                  || (v50 = BN_to_ASN1_INTEGER(v9, *((ASN1_INTEGER **)v11 + 5)),
                                                      (*((_QWORD *)v11 + 5) = v50) != 0))
                                                {
LABEL_53:
                                                  BN_free(v9);
                                                  free(v31);
                                                  *((_QWORD *)v3 + 1) = v11;
                                                  if (v11)
                                                    return v3;
                                                  goto LABEL_13;
                                                }
                                                v51 = 13;
                                                v52 = 860;
                                              }
                                              else
                                              {
                                                v51 = 13;
                                                v52 = 853;
                                              }
                                            }
                                            else
                                            {
                                              v51 = 16;
                                              v52 = 848;
                                            }
                                          }
                                          else
                                          {
                                            v51 = 13;
                                            v52 = 843;
                                          }
                                        }
                                        else
                                        {
                                          v51 = 65;
                                          v52 = 839;
                                        }
                                      }
                                      else
                                      {
                                        v51 = 16;
                                        v52 = 835;
                                      }
                                    }
                                    else
                                    {
                                      v51 = 65;
                                      v52 = 831;
                                    }
                                    ERR_put_error(16, 4095, v51, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_asn1.c", v52);
                                    goto LABEL_51;
                                  }
                                  v36 = 16;
                                  v37 = 827;
                                }
                                else
                                {
                                  v36 = 113;
                                  v37 = 820;
                                }
LABEL_50:
                                ERR_put_error(16, 4095, v36, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_asn1.c", v37);
                                v31 = 0;
LABEL_51:
                                ASN1_item_free(v11, &ECPARAMETERS_it);
                                goto LABEL_52;
                              }
                              v53 = 13;
                              v54 = 767;
                            }
                            else
                            {
                              v53 = 13;
                              v54 = 763;
                            }
                          }
                          else
                          {
                            v53 = 65;
                            v54 = 758;
                          }
                        }
                        else
                        {
                          v53 = 13;
                          v54 = 748;
                        }
                        goto LABEL_100;
                      }
                      data = v30;
                      len = v29;
                      v38 = malloc_type_malloc((uint64_t)v26 >> 3, 0xC4CDE50CuLL);
                      if (v38)
                      {
                        v41 = BN_bn2bin(v22, (unsigned __int8 *)v38);
                        if (v41)
                        {
                          v40 = v41;
                          v59 = (char *)v38;
                          v29 = len;
                          v30 = data;
                          goto LABEL_71;
                        }
                        v53 = 3;
                        v54 = 739;
                      }
                      else
                      {
                        v53 = 65;
                        v54 = 735;
                      }
LABEL_100:
                      ERR_put_error(16, 4095, v53, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_asn1.c", v54);
                      goto LABEL_58;
                    }
                    v55 = 3;
                    v56 = 723;
                  }
                  else
                  {
                    v55 = 65;
                    v56 = 719;
                  }
                  ERR_put_error(16, 4095, v55, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_asn1.c", v56);
LABEL_57:
                  v38 = 0;
LABEL_58:
                  free(v28);
                  free(v38);
                  BN_free(v20);
                  BN_free(v22);
LABEL_59:
                  v36 = 16;
                  v37 = 815;
                  goto LABEL_50;
                }
                ERR_put_error(16, 4095, 16, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_asn1.c", 707);
              }
              else
              {
                ERR_put_error(16, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_asn1.c", 701);
                v22 = 0;
              }
              v28 = 0;
              goto LABEL_57;
            }
            v34 = 13;
            v35 = 672;
          }
          else
          {
            v34 = 16;
            v35 = 666;
          }
        }
        else
        {
          v34 = 65;
          v35 = 661;
        }
        ERR_put_error(16, 4095, v34, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_asn1.c", v35);
        goto LABEL_48;
      }
      v32 = 147;
      v33 = 676;
    }
    else
    {
      v32 = 8;
      v33 = 656;
    }
    ERR_put_error(16, 4095, v32, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_asn1.c", v33);
    v17 = 0;
LABEL_48:
    BN_free(v17);
LABEL_49:
    v36 = 16;
    v37 = 810;
    goto LABEL_50;
  }
  curve_name = EC_GROUP_get_curve_name(a1);
  if (!curve_name || (*(_DWORD *)v3 = 0, v7 = OBJ_nid2obj(curve_name), (*((_QWORD *)v3 + 1) = v7) == 0))
  {
LABEL_13:
    ASN1_item_free(v3, &ECPKPARAMETERS_it);
    return 0;
  }
  return v3;
}

EC_KEY *__cdecl d2i_ECPrivateKey(EC_KEY **a, const unsigned __int8 **in, uint64_t len)
{
  ASN1_VALUE *v4;
  ASN1_VALUE *v5;
  EC_KEY *v6;
  EC_GROUP *v7;
  ASN1_STRING *v8;
  unsigned __int8 *v9;
  int v10;
  BIGNUM *v11;
  EC_POINT *v12;
  EC_POINT *v13;
  EC_POINT *v14;
  ASN1_STRING *v15;
  unsigned __int8 *v16;
  int v17;
  int v18;
  int v19;

  v4 = ASN1_item_d2i(0, in, len, &EC_PRIVATEKEY_it);
  if (!v4)
  {
    ERR_put_error(16, 4095, 16, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_asn1.c", 1148);
    return 0;
  }
  v5 = v4;
  if (!a || (v6 = *a) == 0)
  {
    v6 = EC_KEY_new();
    if (!v6)
    {
      v18 = 65;
      v19 = 1153;
      goto LABEL_30;
    }
  }
  v7 = (EC_GROUP *)*((_QWORD *)v6 + 3);
  if (*((_QWORD *)v5 + 2))
  {
    EC_GROUP_free(v7);
    v7 = ec_asn1_pkparameters2group(*((const ASN1_OBJECT ***)v5 + 2));
    *((_QWORD *)v6 + 3) = v7;
  }
  if (!v7)
  {
    v18 = 16;
    v19 = 1164;
    goto LABEL_30;
  }
  v8 = (ASN1_STRING *)*((_QWORD *)v5 + 1);
  *((_DWORD *)v6 + 4) = *(_QWORD *)v5;
  if (!v8)
  {
    v18 = 125;
    v19 = 1179;
    goto LABEL_30;
  }
  v9 = ASN1_STRING_data(v8);
  v10 = ASN1_STRING_length(*((ASN1_STRING **)v5 + 1));
  v11 = BN_bin2bn(v9, v10, *((BIGNUM **)v6 + 5));
  *((_QWORD *)v6 + 5) = v11;
  if (!v11)
  {
    v18 = 3;
    v19 = 1175;
    goto LABEL_30;
  }
  v12 = (EC_POINT *)*((_QWORD *)v6 + 4);
  if (v12)
    EC_POINT_free(v12);
  v13 = EC_POINT_new(*((const EC_GROUP **)v6 + 3));
  *((_QWORD *)v6 + 4) = v13;
  if (!v13)
  {
    v18 = 16;
    v19 = 1187;
    goto LABEL_30;
  }
  v14 = v13;
  v15 = (ASN1_STRING *)*((_QWORD *)v5 + 3);
  if (!v15)
  {
    if (EC_POINT_mul(*((const EC_GROUP **)v6 + 3), v14, *((const BIGNUM **)v6 + 5), 0, 0, 0))
    {
      *((_DWORD *)v6 + 12) |= 2u;
      goto LABEL_26;
    }
    v18 = 16;
    v19 = 1212;
LABEL_30:
    ERR_put_error(16, 4095, v18, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_asn1.c", v19);
    if (!a || *a != v6)
      EC_KEY_free(v6);
    ASN1_item_free(v5, &EC_PRIVATEKEY_it);
    return 0;
  }
  v16 = ASN1_STRING_data(v15);
  v17 = ASN1_STRING_length(*((ASN1_STRING **)v5 + 3));
  if (!v16 || !v17)
  {
    v18 = 100;
    v19 = 1198;
    goto LABEL_30;
  }
  *((_DWORD *)v6 + 13) = *v16 & 0xFE;
  if (!EC_POINT_oct2point(*((const EC_GROUP **)v6 + 3), *((EC_POINT **)v6 + 4), v16, v17, 0))
  {
    v18 = 16;
    v19 = 1206;
    goto LABEL_30;
  }
LABEL_26:
  ASN1_item_free(v5, &EC_PRIVATEKEY_it);
  if (a)
    *a = v6;
  return v6;
}

int i2d_ECPrivateKey(EC_KEY *a, unsigned __int8 **out)
{
  ASN1_VALUE *v4;
  ASN1_VALUE *v5;
  int v6;
  int v7;
  unint64_t v8;
  unsigned __int8 *v9;
  int v10;
  ASN1_VALUE *v11;
  ASN1_BIT_STRING *v12;
  size_t v13;
  size_t v14;
  unsigned __int8 *v15;
  int v16;
  int v17;
  int v18;
  int v19;
  int v20;
  int v22;
  int v23;

  if (a && *((_QWORD *)a + 3) && *((_QWORD *)a + 5) && ((*((_BYTE *)a + 48) & 2) != 0 || *((_QWORD *)a + 4)))
  {
    v4 = ASN1_item_new(&EC_PRIVATEKEY_it);
    if (v4)
    {
      v5 = v4;
      *(_QWORD *)v4 = *((int *)a + 4);
      v6 = BN_num_bits(*((const BIGNUM **)a + 5));
      v7 = v6 + 7;
      if (v6 < -7)
        v7 = v6 + 14;
      v8 = (uint64_t)v7 >> 3;
      v9 = (unsigned __int8 *)malloc_type_malloc(v8, 0xE62F4307uLL);
      if (!v9)
      {
        v16 = 65;
        v17 = 1255;
        goto LABEL_30;
      }
      if (!BN_bn2bin(*((const BIGNUM **)a + 5), v9))
      {
        v16 = 3;
        v17 = 1259;
        goto LABEL_30;
      }
      if (!ASN1_STRING_set(*((ASN1_STRING **)v5 + 1), v9, v8))
      {
        v16 = 13;
        v17 = 1263;
        goto LABEL_30;
      }
      v10 = *((_DWORD *)a + 12);
      if ((v10 & 1) == 0)
      {
        v11 = ec_asn1_group2pkparameters(*((EC_GROUP **)a + 3), *((_QWORD *)v5 + 2));
        *((_QWORD *)v5 + 2) = v11;
        if (!v11)
        {
          v16 = 16;
          v17 = 1269;
          goto LABEL_30;
        }
        v10 = *((_DWORD *)a + 12);
      }
      if ((v10 & 2) == 0 && *((_QWORD *)a + 4))
      {
        v12 = ASN1_BIT_STRING_new();
        *((_QWORD *)v5 + 3) = v12;
        if (!v12)
        {
          v16 = 65;
          v17 = 1276;
          goto LABEL_30;
        }
        v13 = EC_POINT_point2oct(*((const EC_GROUP **)a + 3), *((const EC_POINT **)a + 4), (point_conversion_form_t)*((_DWORD *)a + 13), 0, 0, 0);
        if (v13 <= v8)
        {
          v15 = v9;
        }
        else
        {
          v14 = v13;
          v15 = (unsigned __int8 *)malloc_type_realloc(v9, v13, 0x8CC09097uLL);
          v8 = v14;
          if (!v15)
          {
            v16 = 65;
            v17 = 1285;
LABEL_30:
            ERR_put_error(16, 4095, v16, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_asn1.c", v17);
            v20 = 0;
LABEL_31:
            free(v9);
            ASN1_item_free(v5, &EC_PRIVATEKEY_it);
            return v20;
          }
        }
        if (EC_POINT_point2oct(*((const EC_GROUP **)a + 3), *((const EC_POINT **)a + 4), (point_conversion_form_t)*((_DWORD *)a + 13), v15, v8, 0))
        {
          if (ASN1_STRING_set(*((ASN1_STRING **)v5 + 3), v15, v8))
          {
            if (asn1_abs_set_unused_bits(*((_QWORD *)v5 + 3), 0))
            {
              v9 = v15;
              goto LABEL_37;
            }
            v22 = 13;
            v23 = 1301;
          }
          else
          {
            v22 = 13;
            v23 = 1297;
          }
        }
        else
        {
          v22 = 16;
          v23 = 1293;
        }
        ERR_put_error(16, 4095, v22, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_asn1.c", v23);
        v20 = 0;
        v9 = v15;
        goto LABEL_31;
      }
LABEL_37:
      v20 = ASN1_item_i2d(v5, out, &EC_PRIVATEKEY_it);
      if (!v20)
        ERR_put_error(16, 4095, 16, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_asn1.c", 1306);
      goto LABEL_31;
    }
    v18 = 65;
    v19 = 1247;
  }
  else
  {
    v18 = 67;
    v19 = 1243;
  }
  ERR_put_error(16, 4095, v18, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_asn1.c", v19);
  return 0;
}

int i2d_ECParameters(EC_KEY *a, unsigned __int8 **out)
{
  if (a)
    return i2d_ECPKParameters(*((const EC_GROUP **)a + 3), out);
  ERR_put_error(16, 4095, 67, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_asn1.c", 1321);
  return 0;
}

EC_KEY *__cdecl d2i_ECParameters(EC_KEY **a, const unsigned __int8 **in, uint64_t len)
{
  EC_KEY *v6;
  EC_KEY *v8;

  if (!in || !*in)
  {
    ERR_put_error(16, 4095, 67, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_asn1.c", 1333);
    return 0;
  }
  if (!a || (v6 = *a) == 0)
  {
    v8 = EC_KEY_new();
    v6 = v8;
    if (!v8)
    {
      ERR_put_error(16, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_asn1.c", 1338);
      return v6;
    }
    if (!d2i_ECPKParameters((EC_GROUP **)v8 + 3, in, len))
    {
      ERR_put_error(16, 4095, 16, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_asn1.c", 1345);
      if (!a)
      {
LABEL_17:
        EC_KEY_free(v6);
        return 0;
      }
      goto LABEL_16;
    }
    if (!a)
      return v6;
LABEL_13:
    *a = v6;
    return v6;
  }
  if (d2i_ECPKParameters((EC_GROUP **)v6 + 3, in, len))
    goto LABEL_13;
  ERR_put_error(16, 4095, 16, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_asn1.c", 1345);
LABEL_16:
  if (*a != v6)
    goto LABEL_17;
  return 0;
}

EC_KEY *__cdecl o2i_ECPublicKey(EC_KEY **a, const unsigned __int8 **in, uint64_t len)
{
  EC_KEY *v3;
  const EC_GROUP *v4;
  EC_POINT *v7;
  EC_POINT *v8;
  const unsigned __int8 *v9;
  int v10;
  int v11;

  if (!a || (v3 = *a) == 0 || (v4 = (const EC_GROUP *)*((_QWORD *)v3 + 3)) == 0)
  {
    v10 = 67;
    v11 = 1363;
LABEL_10:
    ERR_put_error(16, 4095, v10, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_asn1.c", v11);
    return 0;
  }
  v7 = (EC_POINT *)*((_QWORD *)v3 + 4);
  if (!v7)
  {
    v8 = EC_POINT_new(v4);
    *((_QWORD *)v3 + 4) = v8;
    if (!v8)
    {
      v10 = 65;
      v11 = 1369;
      goto LABEL_10;
    }
    v7 = v8;
    v4 = (const EC_GROUP *)*((_QWORD *)v3 + 3);
  }
  if (!EC_POINT_oct2point(v4, v7, *in, len, 0))
  {
    v10 = 16;
    v11 = 1373;
    goto LABEL_10;
  }
  v9 = *in;
  *((_DWORD *)v3 + 13) = **in & 0xFE;
  *in = &v9[len];
  return v3;
}

int i2o_ECPublicKey(EC_KEY *a, unsigned __int8 **out)
{
  size_t v4;
  size_t v5;
  unsigned __int8 *v6;
  unsigned __int8 *v7;
  int v8;
  int v9;

  if (!a)
  {
    v8 = 67;
    v9 = 1389;
LABEL_10:
    ERR_put_error(16, 4095, v8, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_asn1.c", v9);
LABEL_11:
    LODWORD(v5) = 0;
    return v5;
  }
  v4 = EC_POINT_point2oct(*((const EC_GROUP **)a + 3), *((const EC_POINT **)a + 4), (point_conversion_form_t)*((_DWORD *)a + 13), 0, 0, 0);
  v5 = v4;
  if (!out || !v4)
    return v5;
  v6 = *out;
  v7 = *out;
  if (!*out)
  {
    v7 = (unsigned __int8 *)malloc_type_malloc(v4, 0xDFAC327DuLL);
    *out = v7;
    if (!v7)
    {
      v8 = 65;
      v9 = 1401;
      goto LABEL_10;
    }
  }
  if (!EC_POINT_point2oct(*((const EC_GROUP **)a + 3), *((const EC_POINT **)a + 4), (point_conversion_form_t)*((_DWORD *)a + 13), v7, v5, 0))
  {
    ERR_put_error(16, 4095, 16, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_asn1.c", 1408);
    if (!v6)
    {
      free(*out);
      LODWORD(v5) = 0;
      *out = 0;
      return v5;
    }
    goto LABEL_11;
  }
  if (v6)
    *out += v5;
  return v5;
}

ASN1_BIT_STRING *ASN1_BIT_STRING_new(void)
{
  return (ASN1_BIT_STRING *)ASN1_item_new(&ASN1_BIT_STRING_it);
}

void ASN1_BIT_STRING_free(ASN1_BIT_STRING *a)
{
  ASN1_item_free((ASN1_VALUE *)a, &ASN1_BIT_STRING_it);
}

uint64_t asn1_abs_set_unused_bits(uint64_t a1, unsigned int a2)
{
  if (a2 > 7)
    return 0;
  *(_QWORD *)(a1 + 16) = *(_QWORD *)(a1 + 16) & 0xFFFFFFFFFFFFFFF0 | a2 | 8;
  return 1;
}

int ASN1_BIT_STRING_set_bit(ASN1_BIT_STRING *a, int n, int value)
{
  int v3;
  int v4;
  char v5;
  ASN1_BIT_STRING *v6;
  int v7;
  unint64_t length;
  unsigned __int8 *data;
  uint64_t v10;
  unsigned __int8 *v11;
  uint64_t v12;

  v3 = n + 7;
  if (n >= 0)
    v3 = n;
  v4 = 1 << (~(_BYTE)n & 7);
  if (value)
    v5 = 1 << (~(_BYTE)n & 7);
  else
    v5 = 0;
  if (a)
  {
    v6 = a;
    v7 = v3 >> 3;
    a->flags &= 0xFFFFFFFFFFFFFFF0;
    length = a->length;
    if ((int)length > v3 >> 3)
    {
      data = a->data;
      if (data)
      {
LABEL_12:
        data[v7] = data[v7] & ~(_BYTE)v4 | v5;
        v10 = v6->length;
        if ((int)v10 >= 1)
        {
          v11 = v6->data;
          do
          {
            v12 = v10 - 1;
            if (v11[(v10 - 1)])
              break;
            v6->length = --v10;
          }
          while ((unint64_t)(v12 + 1) > 1);
        }
        goto LABEL_16;
      }
    }
    if (!value)
    {
LABEL_16:
      LODWORD(a) = 1;
      return (int)a;
    }
    data = (unsigned __int8 *)recallocarray((char *)v6->data, length, v7 + 1, 1uLL);
    if (data)
    {
      v6->data = data;
      v6->length = v7 + 1;
      goto LABEL_12;
    }
    ERR_put_error(13, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/a_bitstr.c", 135);
    LODWORD(a) = 0;
  }
  return (int)a;
}

int ASN1_BIT_STRING_get_bit(ASN1_BIT_STRING *a, int n)
{
  int v2;
  int v3;
  unsigned __int8 *data;

  v2 = n + 7;
  if (n >= 0)
    v2 = n;
  if (a)
  {
    v3 = v2 >> 3;
    if (a->length > v3 && (data = a->data) != 0)
      LODWORD(a) = (data[v3] >> (~(_BYTE)n & 7)) & 1;
    else
      LODWORD(a) = 0;
  }
  return (int)a;
}

BOOL ASN1_BIT_STRING_check(unsigned int *a1, uint64_t a2, int a3)
{
  uint64_t v3;
  unint64_t v4;
  unint64_t v5;
  char v6;
  int v7;

  if (!a1)
    return 1;
  v3 = *((_QWORD *)a1 + 1);
  if (!v3)
    return 1;
  v4 = *a1;
  if ((int)v4 < 1)
    return 1;
  v5 = 0;
  do
  {
    if ((uint64_t)v5 >= a3)
      v6 = -1;
    else
      v6 = ~*(_BYTE *)(a2 + v5);
    v7 = (*(_BYTE *)(v3 + v5++) & v6);
  }
  while (v5 < v4 && !v7);
  return v7 == 0;
}

int ASN1_BIT_STRING_name_print(BIO *out, ASN1_BIT_STRING *bs, BIT_STRING_BITNAME *tbl, int indent)
{
  const char *lname;
  int v8;
  int bitnum;
  int v10;
  unsigned __int8 *data;

  BIO_printf(out, "%*s", indent, "");
  lname = tbl->lname;
  if (lname)
  {
    v8 = 1;
    do
    {
      bitnum = tbl->bitnum + 7;
      if (tbl->bitnum >= 0)
        bitnum = tbl->bitnum;
      if (bs)
      {
        v10 = bitnum >> 3;
        if (bs->length > v10)
        {
          data = bs->data;
          if (data)
          {
            if (((data[v10] >> (~tbl->bitnum & 7)) & 1) != 0)
            {
              if (!v8)
              {
                BIO_puts(out, ", ");
                lname = tbl->lname;
              }
              BIO_puts(out, lname);
              v8 = 0;
            }
          }
        }
      }
      lname = tbl[1].lname;
      ++tbl;
    }
    while (lname);
  }
  BIO_puts(out, "\n");
  return 1;
}

int ASN1_BIT_STRING_set_asc(ASN1_BIT_STRING *bs, char *name, int value, BIT_STRING_BITNAME *tbl)
{
  int v6;
  int result;

  v6 = ASN1_BIT_STRING_num_asc(name, tbl);
  if (v6 < 0)
    return 0;
  if (!bs)
    return 1;
  result = ASN1_BIT_STRING_set_bit(bs, v6, value);
  if (result)
    return 1;
  return result;
}

int ASN1_BIT_STRING_num_asc(char *name, BIT_STRING_BITNAME *tbl)
{
  const char *lname;
  const char **i;
  const char *v5;

  lname = tbl->lname;
  if (!lname)
    return -1;
  for (i = &tbl[1].lname; strcmp(*(i - 2), name) && strcmp(lname, name); i += 3)
  {
    v5 = *i;
    lname = v5;
    if (!v5)
      return -1;
  }
  return *((_DWORD *)i - 8);
}

int i2c_ASN1_BIT_STRING(ASN1_BIT_STRING *a, unsigned __int8 **pp)
{
  uint64_t length;
  int v3;
  uint64_t flags;
  unsigned int v6;
  signed __int8 v7;
  unsigned __int8 v8;
  unsigned __int8 *v9;
  unsigned __int8 *v10;
  unsigned __int8 *v11;
  unsigned __int8 *v12;

  if (a)
  {
    length = a->length;
    if ((_DWORD)length != 0x7FFFFFFF)
    {
      v3 = length + 1;
      if (!pp)
        return v3;
      if ((int)length > 0)
      {
        flags = a->flags;
        if ((flags & 8) != 0)
        {
          v8 = flags & 7;
          v6 = a->length;
LABEL_21:
          v9 = *pp;
          **pp = v8;
LABEL_22:
          v12 = v9 + 1;
          memcpy(v9 + 1, a->data, v6);
          v11 = &v12[v6];
          *(v11 - 1) &= -1 << v8;
          goto LABEL_23;
        }
        v6 = length + 1;
        while (length >= 1)
        {
          v7 = a->data[length - 1];
          --v6;
          --length;
          if (v7)
          {
            if ((v7 & 1) != 0)
            {
              v8 = 0;
            }
            else if ((v7 & 2) != 0)
            {
              v8 = 1;
            }
            else if ((v7 & 4) != 0)
            {
              v8 = 2;
            }
            else if ((v7 & 8) != 0)
            {
              v8 = 3;
            }
            else if ((v7 & 0x10) != 0)
            {
              v8 = 4;
            }
            else if ((v7 & 0x20) != 0)
            {
              v8 = 5;
            }
            else if ((v7 & 0x40) != 0)
            {
              v8 = 6;
            }
            else
            {
              if ((v7 & 0x80000000) == 0)
              {
                v8 = 0;
                v9 = *pp;
                **pp = 0;
                goto LABEL_22;
              }
              v8 = 7;
            }
            goto LABEL_21;
          }
        }
      }
      v10 = *pp;
      *v10 = 0;
      v11 = v10 + 1;
LABEL_23:
      *pp = v11;
      return v3;
    }
  }
  return 0;
}

uint64_t c2i_ASN1_BIT_STRING_cbs(ASN1_VALUE **a1, _QWORD *a2)
{
  ASN1_VALUE *v4;
  int v5;
  uint64_t v6;
  ASN1_VALUE *v7;
  ASN1_VALUE *v8;
  _BYTE *v9;
  int v10;
  unsigned __int8 v11;
  unsigned __int8 v13;
  size_t v14;
  _BYTE *v15;

  v14 = 0;
  v15 = 0;
  v13 = 0;
  if (!a1)
    goto LABEL_11;
  v4 = *a1;
  if (v4)
  {
    ASN1_item_free(v4, &ASN1_BIT_STRING_it);
    *a1 = 0;
  }
  if (!CBS_get_u8(a2, &v13))
  {
    ERR_put_error(13, 4095, 152, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/a_bitstr.c", 318);
LABEL_11:
    v7 = 0;
    goto LABEL_12;
  }
  v5 = CBS_stow((uint64_t)a2, (void **)&v15, &v14);
  v6 = 0;
  v7 = 0;
  if (v5 && !(v14 >> 31))
  {
    v8 = ASN1_item_new(&ASN1_BIT_STRING_it);
    v7 = v8;
    if (!v8)
    {
LABEL_12:
      v6 = 0;
      goto LABEL_13;
    }
    v10 = v14;
    v9 = v15;
    *((_QWORD *)v8 + 1) = v15;
    *(_DWORD *)v8 = v10;
    v15 = 0;
    v11 = v13;
    if (v13 >= 8u)
    {
      ERR_put_error(13, 4095, 220, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/a_bitstr.c", 339);
      goto LABEL_12;
    }
    *((_QWORD *)v8 + 2) = v13 | *((_QWORD *)v8 + 2) & 0xFFFFFFFFFFFFFFF0 | 8;
    if (v10 >= 1)
      v9[v10 - 1] &= -1 << v11;
    *a1 = v8;
    v6 = 1;
    v7 = 0;
  }
LABEL_13:
  ASN1_item_free(v7, &ASN1_BIT_STRING_it);
  freezero(v15, v14);
  return v6;
}

ASN1_BIT_STRING *__cdecl c2i_ASN1_BIT_STRING(ASN1_BIT_STRING **a, const unsigned __int8 **pp, uint64_t length)
{
  ASN1_BIT_STRING *result;
  _QWORD v7[3];
  ASN1_BIT_STRING *v8;

  v8 = 0;
  if (a)
  {
    ASN1_item_free((ASN1_VALUE *)*a, &ASN1_BIT_STRING_it);
    *a = 0;
  }
  if (length < 0)
  {
    ERR_put_error(13, 4095, 136, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/a_bitstr.c", 369);
    return 0;
  }
  memset(v7, 0, sizeof(v7));
  CBS_init(v7, (uint64_t)*pp, length);
  if (!c2i_ASN1_BIT_STRING_cbs((ASN1_VALUE **)&v8, v7))
    return 0;
  *pp = (const unsigned __int8 *)CBS_data((uint64_t)v7);
  result = v8;
  if (a)
    *a = v8;
  return result;
}

int i2d_ASN1_BIT_STRING(ASN1_BIT_STRING *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &ASN1_BIT_STRING_it);
}

ASN1_BIT_STRING *__cdecl d2i_ASN1_BIT_STRING(ASN1_BIT_STRING **a, const unsigned __int8 **in, uint64_t len)
{
  return (ASN1_BIT_STRING *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &ASN1_BIT_STRING_it);
}

void ERR_load_RAND_strings(void)
{
  if (!ERR_func_error_string(RAND_str_functs))
  {
    ERR_load_strings(0, (ERR_STRING_DATA *)&RAND_str_functs);
    ERR_load_strings(0, (ERR_STRING_DATA *)&RAND_str_reasons);
  }
}

void ERR_load_PKCS7_strings(void)
{
  if (!ERR_func_error_string(PKCS7_str_functs))
  {
    ERR_load_strings(0, (ERR_STRING_DATA *)&PKCS7_str_functs);
    ERR_load_strings(0, (ERR_STRING_DATA *)&PKCS7_str_reasons);
  }
}

NETSCAPE_SPKAC *__cdecl d2i_NETSCAPE_SPKAC(NETSCAPE_SPKAC **a, const unsigned __int8 **in, uint64_t len)
{
  return (NETSCAPE_SPKAC *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &NETSCAPE_SPKAC_it);
}

int i2d_NETSCAPE_SPKAC(NETSCAPE_SPKAC *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &NETSCAPE_SPKAC_it);
}

NETSCAPE_SPKAC *NETSCAPE_SPKAC_new(void)
{
  return (NETSCAPE_SPKAC *)ASN1_item_new(&NETSCAPE_SPKAC_it);
}

void NETSCAPE_SPKAC_free(NETSCAPE_SPKAC *a)
{
  ASN1_item_free((ASN1_VALUE *)a, &NETSCAPE_SPKAC_it);
}

NETSCAPE_SPKI *__cdecl d2i_NETSCAPE_SPKI(NETSCAPE_SPKI **a, const unsigned __int8 **in, uint64_t len)
{
  return (NETSCAPE_SPKI *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &NETSCAPE_SPKI_it);
}

int i2d_NETSCAPE_SPKI(NETSCAPE_SPKI *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &NETSCAPE_SPKI_it);
}

NETSCAPE_SPKI *NETSCAPE_SPKI_new(void)
{
  return (NETSCAPE_SPKI *)ASN1_item_new(&NETSCAPE_SPKI_it);
}

void NETSCAPE_SPKI_free(NETSCAPE_SPKI *a)
{
  ASN1_item_free((ASN1_VALUE *)a, &NETSCAPE_SPKI_it);
}

ASN1_NULL *__cdecl d2i_ASN1_NULL(ASN1_NULL **a, const unsigned __int8 **in, uint64_t len)
{
  return (ASN1_NULL *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &ASN1_NULL_it);
}

int i2d_ASN1_NULL(ASN1_NULL *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &ASN1_NULL_it);
}

ASN1_NULL *ASN1_NULL_new(void)
{
  return (ASN1_NULL *)ASN1_item_new(&ASN1_NULL_it);
}

void ASN1_NULL_free(ASN1_NULL *a)
{
  ASN1_item_free((ASN1_VALUE *)a, &ASN1_NULL_it);
}

ASN1_UTF8STRING *__cdecl d2i_ASN1_UTF8STRING(ASN1_UTF8STRING **a, const unsigned __int8 **in, uint64_t len)
{
  return (ASN1_UTF8STRING *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &ASN1_UTF8STRING_it);
}

int i2d_ASN1_UTF8STRING(ASN1_UTF8STRING *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &ASN1_UTF8STRING_it);
}

ASN1_UTF8STRING *ASN1_UTF8STRING_new(void)
{
  return (ASN1_UTF8STRING *)ASN1_item_new(&ASN1_UTF8STRING_it);
}

void ASN1_UTF8STRING_free(ASN1_UTF8STRING *a)
{
  ASN1_item_free((ASN1_VALUE *)a, &ASN1_UTF8STRING_it);
}

ASN1_PRINTABLESTRING *__cdecl d2i_ASN1_PRINTABLESTRING(ASN1_PRINTABLESTRING **a, const unsigned __int8 **in, uint64_t len)
{
  return (ASN1_PRINTABLESTRING *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &ASN1_PRINTABLESTRING_it);
}

int i2d_ASN1_PRINTABLESTRING(ASN1_PRINTABLESTRING *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &ASN1_PRINTABLESTRING_it);
}

ASN1_PRINTABLESTRING *ASN1_PRINTABLESTRING_new(void)
{
  return (ASN1_PRINTABLESTRING *)ASN1_item_new(&ASN1_PRINTABLESTRING_it);
}

void ASN1_PRINTABLESTRING_free(ASN1_PRINTABLESTRING *a)
{
  ASN1_item_free((ASN1_VALUE *)a, &ASN1_PRINTABLESTRING_it);
}

ASN1_T61STRING *__cdecl d2i_ASN1_T61STRING(ASN1_T61STRING **a, const unsigned __int8 **in, uint64_t len)
{
  return (ASN1_T61STRING *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &ASN1_T61STRING_it);
}

int i2d_ASN1_T61STRING(ASN1_T61STRING *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &ASN1_T61STRING_it);
}

ASN1_T61STRING *ASN1_T61STRING_new(void)
{
  return (ASN1_T61STRING *)ASN1_item_new(&ASN1_T61STRING_it);
}

void ASN1_T61STRING_free(ASN1_T61STRING *a)
{
  ASN1_item_free((ASN1_VALUE *)a, &ASN1_T61STRING_it);
}

ASN1_IA5STRING *__cdecl d2i_ASN1_IA5STRING(ASN1_IA5STRING **a, const unsigned __int8 **in, uint64_t len)
{
  return (ASN1_IA5STRING *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &ASN1_IA5STRING_it);
}

int i2d_ASN1_IA5STRING(ASN1_IA5STRING *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &ASN1_IA5STRING_it);
}

ASN1_IA5STRING *ASN1_IA5STRING_new(void)
{
  return (ASN1_IA5STRING *)ASN1_item_new(&ASN1_IA5STRING_it);
}

void ASN1_IA5STRING_free(ASN1_IA5STRING *a)
{
  ASN1_item_free((ASN1_VALUE *)a, &ASN1_IA5STRING_it);
}

ASN1_GENERALSTRING *__cdecl d2i_ASN1_GENERALSTRING(ASN1_GENERALSTRING **a, const unsigned __int8 **in, uint64_t len)
{
  return (ASN1_GENERALSTRING *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &ASN1_GENERALSTRING_it);
}

int i2d_ASN1_GENERALSTRING(ASN1_GENERALSTRING *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &ASN1_GENERALSTRING_it);
}

ASN1_GENERALSTRING *ASN1_GENERALSTRING_new(void)
{
  return (ASN1_GENERALSTRING *)ASN1_item_new(&ASN1_GENERALSTRING_it);
}

void ASN1_GENERALSTRING_free(ASN1_GENERALSTRING *a)
{
  ASN1_item_free((ASN1_VALUE *)a, &ASN1_GENERALSTRING_it);
}

ASN1_UTCTIME *__cdecl d2i_ASN1_UTCTIME(ASN1_UTCTIME **a, const unsigned __int8 **in, uint64_t len)
{
  return (ASN1_UTCTIME *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &ASN1_UTCTIME_it);
}

int i2d_ASN1_UTCTIME(ASN1_UTCTIME *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &ASN1_UTCTIME_it);
}

ASN1_UTCTIME *ASN1_UTCTIME_new(void)
{
  return (ASN1_UTCTIME *)ASN1_item_new(&ASN1_UTCTIME_it);
}

void ASN1_UTCTIME_free(ASN1_UTCTIME *a)
{
  ASN1_item_free((ASN1_VALUE *)a, &ASN1_UTCTIME_it);
}

ASN1_GENERALIZEDTIME *__cdecl d2i_ASN1_GENERALIZEDTIME(ASN1_GENERALIZEDTIME **a, const unsigned __int8 **in, uint64_t len)
{
  return (ASN1_GENERALIZEDTIME *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &ASN1_GENERALIZEDTIME_it);
}

int i2d_ASN1_GENERALIZEDTIME(ASN1_GENERALIZEDTIME *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &ASN1_GENERALIZEDTIME_it);
}

ASN1_GENERALIZEDTIME *ASN1_GENERALIZEDTIME_new(void)
{
  return (ASN1_GENERALIZEDTIME *)ASN1_item_new(&ASN1_GENERALIZEDTIME_it);
}

void ASN1_GENERALIZEDTIME_free(ASN1_GENERALIZEDTIME *a)
{
  ASN1_item_free((ASN1_VALUE *)a, &ASN1_GENERALIZEDTIME_it);
}

ASN1_VISIBLESTRING *__cdecl d2i_ASN1_VISIBLESTRING(ASN1_VISIBLESTRING **a, const unsigned __int8 **in, uint64_t len)
{
  return (ASN1_VISIBLESTRING *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &ASN1_VISIBLESTRING_it);
}

int i2d_ASN1_VISIBLESTRING(ASN1_VISIBLESTRING *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &ASN1_VISIBLESTRING_it);
}

ASN1_VISIBLESTRING *ASN1_VISIBLESTRING_new(void)
{
  return (ASN1_VISIBLESTRING *)ASN1_item_new(&ASN1_VISIBLESTRING_it);
}

void ASN1_VISIBLESTRING_free(ASN1_VISIBLESTRING *a)
{
  ASN1_item_free((ASN1_VALUE *)a, &ASN1_VISIBLESTRING_it);
}

ASN1_UNIVERSALSTRING *__cdecl d2i_ASN1_UNIVERSALSTRING(ASN1_UNIVERSALSTRING **a, const unsigned __int8 **in, uint64_t len)
{
  return (ASN1_UNIVERSALSTRING *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &ASN1_UNIVERSALSTRING_it);
}

int i2d_ASN1_UNIVERSALSTRING(ASN1_UNIVERSALSTRING *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &ASN1_UNIVERSALSTRING_it);
}

ASN1_UNIVERSALSTRING *ASN1_UNIVERSALSTRING_new(void)
{
  return (ASN1_UNIVERSALSTRING *)ASN1_item_new(&ASN1_UNIVERSALSTRING_it);
}

void ASN1_UNIVERSALSTRING_free(ASN1_UNIVERSALSTRING *a)
{
  ASN1_item_free((ASN1_VALUE *)a, &ASN1_UNIVERSALSTRING_it);
}

ASN1_BMPSTRING *__cdecl d2i_ASN1_BMPSTRING(ASN1_BMPSTRING **a, const unsigned __int8 **in, uint64_t len)
{
  return (ASN1_BMPSTRING *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &ASN1_BMPSTRING_it);
}

int i2d_ASN1_BMPSTRING(ASN1_BMPSTRING *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &ASN1_BMPSTRING_it);
}

ASN1_BMPSTRING *ASN1_BMPSTRING_new(void)
{
  return (ASN1_BMPSTRING *)ASN1_item_new(&ASN1_BMPSTRING_it);
}

void ASN1_BMPSTRING_free(ASN1_BMPSTRING *a)
{
  ASN1_item_free((ASN1_VALUE *)a, &ASN1_BMPSTRING_it);
}

ASN1_STRING *__cdecl d2i_ASN1_PRINTABLE(ASN1_STRING **a, const unsigned __int8 **in, uint64_t len)
{
  return (ASN1_STRING *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &ASN1_PRINTABLE_it);
}

int i2d_ASN1_PRINTABLE(ASN1_STRING *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &ASN1_PRINTABLE_it);
}

ASN1_STRING *ASN1_PRINTABLE_new(void)
{
  return (ASN1_STRING *)ASN1_item_new(&ASN1_PRINTABLE_it);
}

void ASN1_PRINTABLE_free(ASN1_STRING *a)
{
  ASN1_item_free((ASN1_VALUE *)a, &ASN1_PRINTABLE_it);
}

ASN1_STRING *__cdecl d2i_DISPLAYTEXT(ASN1_STRING **a, const unsigned __int8 **in, uint64_t len)
{
  return (ASN1_STRING *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &DISPLAYTEXT_it);
}

int i2d_DISPLAYTEXT(ASN1_STRING *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &DISPLAYTEXT_it);
}

ASN1_STRING *DISPLAYTEXT_new(void)
{
  return (ASN1_STRING *)ASN1_item_new(&DISPLAYTEXT_it);
}

void DISPLAYTEXT_free(ASN1_STRING *a)
{
  ASN1_item_free((ASN1_VALUE *)a, &DISPLAYTEXT_it);
}

ASN1_STRING *__cdecl d2i_DIRECTORYSTRING(ASN1_STRING **a, const unsigned __int8 **in, uint64_t len)
{
  return (ASN1_STRING *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &DIRECTORYSTRING_it);
}

int i2d_DIRECTORYSTRING(ASN1_STRING *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &DIRECTORYSTRING_it);
}

ASN1_STRING *DIRECTORYSTRING_new(void)
{
  return (ASN1_STRING *)ASN1_item_new(&DIRECTORYSTRING_it);
}

void DIRECTORYSTRING_free(ASN1_STRING *a)
{
  ASN1_item_free((ASN1_VALUE *)a, &DIRECTORYSTRING_it);
}

int i2d_ASN1_BOOLEAN(int a, unsigned __int8 **pp)
{
  ASN1_VALUE *pval;

  LODWORD(pval) = a;
  return ASN1_item_ex_i2d(&pval, pp, &ASN1_BOOLEAN_it, -1, 0);
}

int d2i_ASN1_BOOLEAN(int *a, const unsigned __int8 **pp, uint64_t length)
{
  int v4;
  ASN1_VALUE *pval;

  LODWORD(pval) = 0;
  v4 = -1;
  if (ASN1_item_ex_d2i(&pval, pp, length, &ASN1_BOOLEAN_it, -1, 0, 0, 0) >= 1)
  {
    v4 = (int)pval;
    if (a)
      *a = (int)pval;
  }
  return v4;
}

ASN1_VALUE *d2i_ASN1_SEQUENCE_ANY(ASN1_VALUE **a1, const unsigned __int8 **a2, uint64_t a3)
{
  return ASN1_item_d2i(a1, a2, a3, &ASN1_SEQUENCE_ANY_it);
}

uint64_t i2d_ASN1_SEQUENCE_ANY(ASN1_VALUE *a1, unsigned __int8 **a2)
{
  return ASN1_item_i2d(a1, a2, &ASN1_SEQUENCE_ANY_it);
}

ASN1_VALUE *d2i_ASN1_SET_ANY(ASN1_VALUE **a1, const unsigned __int8 **a2, uint64_t a3)
{
  return ASN1_item_d2i(a1, a2, a3, &ASN1_SET_ANY_it);
}

uint64_t i2d_ASN1_SET_ANY(ASN1_VALUE *a1, unsigned __int8 **a2)
{
  return ASN1_item_i2d(a1, a2, &ASN1_SET_ANY_it);
}

uint64_t pkey_hmac_init(uint64_t a1)
{
  uint64_t result;
  uint64_t v3;

  result = (uint64_t)malloc_type_calloc(1uLL, 0x150uLL, 0x10F00401018A6D6uLL);
  if (result)
  {
    v3 = result;
    *(_DWORD *)(result + 12) = 4;
    HMAC_CTX_init((HMAC_CTX *)(result + 32));
    *(_QWORD *)(a1 + 40) = v3;
    *(_DWORD *)(a1 + 72) = 0;
    return 1;
  }
  return result;
}

uint64_t pkey_hmac_copy(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  const unsigned __int8 *v7;

  result = pkey_hmac_init(a1);
  if ((_DWORD)result)
  {
    v5 = *(_QWORD *)(a2 + 40);
    v6 = *(_QWORD *)(a1 + 40);
    *(_QWORD *)v6 = *(_QWORD *)v5;
    HMAC_CTX_init((HMAC_CTX *)(v6 + 32));
    result = HMAC_CTX_copy(v6 + 32, v5 + 32);
    if ((_DWORD)result)
    {
      v7 = *(const unsigned __int8 **)(v5 + 16);
      if (!v7)
        return 1;
      result = ASN1_OCTET_STRING_set((ASN1_OCTET_STRING *)(v6 + 8), v7, *(_DWORD *)(v5 + 8));
      if ((_DWORD)result)
        return 1;
    }
  }
  return result;
}

void pkey_hmac_cleanup(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 40);
  if (v1)
  {
    HMAC_CTX_cleanup((HMAC_CTX *)(v1 + 32));
    freezero(*(void **)(v1 + 16), *(int *)(v1 + 8));
    free((void *)v1);
  }
}

char *pkey_hmac_keygen(uint64_t a1, EVP_PKEY *a2)
{
  uint64_t v2;
  char *result;

  v2 = *(_QWORD *)(a1 + 40);
  if (!*(_QWORD *)(v2 + 16))
    return 0;
  result = (char *)ASN1_OCTET_STRING_dup((ASN1_OCTET_STRING *)(v2 + 8));
  if (result)
  {
    EVP_PKEY_assign(a2, 855, result);
    return (char *)1;
  }
  return result;
}

uint64_t hmac_signctx_init(uint64_t a1, EVP_MD_CTX *a2)
{
  HMAC_CTX_set_flags((HMAC_CTX *)(*(_QWORD *)(a1 + 40) + 32), a2->flags & 0xFFFFFFFFFFFFFEFFLL);
  EVP_MD_CTX_set_flags(a2, 256);
  a2[1].engine = (ENGINE *)int_update_0;
  return 1;
}

void hmac_signctx(uint64_t a1, unsigned __int8 *a2, _QWORD *a3, EVP_MD_CTX *ctx)
{
  uint64_t v6;
  const EVP_MD *v7;
  unsigned int v8;
  int v9;
  unsigned int len;

  v6 = *(_QWORD *)(a1 + 40);
  v7 = EVP_MD_CTX_md(ctx);
  v8 = EVP_MD_size(v7);
  if ((v8 & 0x80000000) == 0)
  {
    *a3 = v8;
    if (a2)
    {
      len = 0;
      HMAC_Final((HMAC_CTX *)(v6 + 32), a2, &len);
      if (v9)
        *a3 = len;
    }
  }
}

uint64_t pkey_hmac_ctrl(uint64_t a1, int a2, int a3, unsigned __int8 *data)
{
  uint64_t v5;
  uint64_t v6;
  BOOL v8;
  int v9;

  v5 = *(_QWORD *)(a1 + 40);
  if (a2 == 1)
  {
    *(_QWORD *)v5 = data;
    return 1;
  }
  if (a2 == 7)
  {
    HMAC_Init_ex((HMAC_CTX *)(v5 + 32), *(const void **)(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32) + 8), **(_DWORD **)(*(_QWORD *)(a1 + 16) + 32), *(const EVP_MD **)v5, *(ENGINE **)(a1 + 8));
    return v9 != 0;
  }
  if (a2 != 6)
    return 4294967294;
  v6 = 0;
  v8 = a3 > 0 && data == 0;
  if (a3 >= -1 && !v8)
    return ASN1_OCTET_STRING_set((ASN1_OCTET_STRING *)(v5 + 8), data, a3) != 0;
  return v6;
}

uint64_t pkey_hmac_ctrl_str(uint64_t a1, char *__s1, unsigned __int8 *a3)
{
  _BOOL8 v6;
  unsigned __int8 *v7;
  unsigned __int8 *v8;
  uint64_t len;

  if (!a3)
    return 0;
  if (!strcmp(__s1, "key"))
    return ASN1_OCTET_STRING_set((ASN1_OCTET_STRING *)(*(_QWORD *)(a1 + 40) + 8), a3, -1) != 0;
  if (strcmp(__s1, "hexkey"))
    return 4294967294;
  len = 0;
  v7 = string_to_hex((char *)a3, &len);
  if (!v7)
    return 0;
  v8 = v7;
  v6 = (int)len >= -1 && ASN1_OCTET_STRING_set((ASN1_OCTET_STRING *)(*(_QWORD *)(a1 + 40) + 8), v7, len) != 0;
  free(v8);
  return v6;
}

BOOL int_update_0(uint64_t a1, const unsigned __int8 *a2, size_t a3)
{
  int v3;

  HMAC_Update((HMAC_CTX *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 40) + 32), a2, a3);
  return v3 != 0;
}

void DES_ede3_ofb64_encrypt(const unsigned __int8 *in, unsigned __int8 *out, uint64_t length, DES_key_schedule *ks1, DES_key_schedule *ks2, DES_key_schedule *ks3, DES_cblock *ivec, int *num)
{
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  unsigned int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  int v18;
  uint64_t v23;
  int v26;
  char v27;
  int *v28;
  unsigned int data;
  int v30;
  unsigned int v31;
  int v32;
  uint64_t v33;

  v33 = *MEMORY[0x24BDAC8D0];
  v8 = *num;
  v9 = (*ivec)[0];
  v10 = (*ivec)[1];
  v11 = (*ivec)[2];
  v12 = (*ivec)[3];
  v13 = v9 | (v10 << 8) | (v11 << 16) | (v12 << 24);
  v14 = (*ivec)[4];
  v15 = (*ivec)[5];
  v16 = (*ivec)[6];
  v17 = (*ivec)[7];
  v18 = v14 | (v15 << 8) | (v16 << 16) | (v17 << 24);
  data = v13;
  v30 = v18;
  LOBYTE(v31) = v9;
  BYTE1(v31) = v10;
  BYTE2(v31) = v11;
  HIBYTE(v31) = v12;
  LOBYTE(v32) = v14;
  BYTE1(v32) = v15;
  BYTE2(v32) = v16;
  HIBYTE(v32) = v17;
  if (length)
  {
    v23 = length;
    v28 = num;
    v26 = 0;
    do
    {
      if (!v8)
      {
        DES_encrypt3(&data, ks1, ks2, ks3);
        v13 = data;
        v18 = v30;
        v31 = data;
        v32 = v30;
        ++v26;
      }
      v27 = *in++;
      *out++ = *((_BYTE *)&v31 + v8) ^ v27;
      v8 = (v8 + 1) & 7;
      --v23;
    }
    while (v23);
    if (v26)
    {
      *(_DWORD *)ivec = v13;
      *(_DWORD *)&(*ivec)[4] = v18;
    }
    num = v28;
  }
  *num = v8;
}

char *recallocarray(char *a1, unint64_t a2, size_t count, size_t size)
{
  char *v4;
  int *v5;
  int v6;
  size_t v8;
  size_t v9;
  size_t v10;
  char *v11;
  char *v12;
  char *v13;

  if (!a1)
    return (char *)malloc_type_calloc(count, size, 0xA14FC9F3uLL);
  v4 = a1;
  if (!count || !((size | count) >> 32) || is_mul_ok(count, size))
  {
    if (a2 && (size | a2) >> 32 && !is_mul_ok(a2, size))
    {
      v5 = __error();
      v4 = 0;
      v6 = 22;
      goto LABEL_10;
    }
    v8 = size * count;
    v9 = size * a2;
    v10 = size * count - size * a2;
    if (size * count <= size * a2)
    {
      if (v9 - v8 < v9 >> 1 && v9 - v8 < getpagesize())
      {
        bzero(&v4[v8], v9 - v8);
        return v4;
      }
      v13 = (char *)malloc_type_malloc(v8, 0xCA6BA60AuLL);
      if (v13)
      {
        v12 = v13;
        memcpy(v13, v4, v8);
        goto LABEL_20;
      }
    }
    else
    {
      v11 = (char *)malloc_type_malloc(size * count, 0xCA6BA60AuLL);
      if (v11)
      {
        v12 = v11;
        memcpy(v11, v4, v9);
        bzero(&v12[v9], v10);
LABEL_20:
        explicit_bzero(v4, v9);
        free(v4);
        return v12;
      }
    }
    return 0;
  }
  v5 = __error();
  v4 = 0;
  v6 = 12;
LABEL_10:
  *v5 = v6;
  return v4;
}

BIO_METHOD *BIO_f_base64(void)
{
  return (BIO_METHOD *)&methods_b64;
}

uint64_t b64_write(BIO *a1, char *a2, int a3)
{
  bio_st *next_bio;
  int method;
  int method_high;
  int v9;
  uint64_t v10;
  uint64_t v11;
  BOOL v12;
  int v13;
  uint64_t v14;
  int v15;
  int callback;
  int v17;
  int v18;
  int v19;
  int v20;
  int v21;
  unsigned int v22;
  int v23;
  BOOL v24;
  unsigned __int8 *f;
  unsigned __int8 *v27;

  next_bio = a1->next_bio;
  BIO_clear_flags(a1, 15);
  if (LODWORD(next_bio->cb_arg) != 1)
  {
    LODWORD(next_bio->cb_arg) = 1;
    next_bio->method = 0;
    LODWORD(next_bio->callback) = 0;
    EVP_EncodeInit((EVP_ENCODE_CTX *)&next_bio->shutdown);
  }
  if (SHIDWORD(next_bio->method) >= 1502)
    OpenSSLDie("/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/bio_b64.c", 372, "ctx->buf_off < (int)sizeof(ctx->buf)");
  method = (int)next_bio->method;
  if (SLODWORD(next_bio->method) > 1502)
    OpenSSLDie("/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/bio_b64.c", 373, "ctx->buf_len <= (int)sizeof(ctx->buf)");
  method_high = HIDWORD(next_bio->method);
  if (method < method_high)
    OpenSSLDie("/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/bio_b64.c", 374, "ctx->buf_len >= ctx->buf_off");
  v9 = method - method_high;
  if (method - method_high < 1)
  {
LABEL_18:
    v11 = 0;
    next_bio->method = 0;
    if (a2 && a3 >= 1)
    {
      LODWORD(v11) = 0;
      f = (unsigned __int8 *)&next_bio[14].next_bio + 2;
      v27 = (unsigned __int8 *)&next_bio[1].callback + 4;
      while (1)
      {
        v14 = a3 >= 1024 ? 1024 : a3;
        if ((BIO_test_flags(a1, -1) & 0x100) != 0)
        {
          callback = (int)next_bio->callback;
          if (callback < 1)
          {
            if (v14 <= 2)
            {
              memcpy(f, a2, v14);
              LODWORD(next_bio->callback) = v14;
              return (v11 + v14);
            }
            LODWORD(v14) = v14 - (unsigned __int16)v14 % 3u;
            v19 = EVP_EncodeBlock(v27, (const unsigned __int8 *)a2, v14);
            LODWORD(next_bio->method) = v19;
            if (v19 >= 1503)
              OpenSSLDie("/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/bio_b64.c", 431, "ctx->buf_len <= (int)sizeof(ctx->buf)");
            if (v19 < SHIDWORD(next_bio->method))
              OpenSSLDie("/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/bio_b64.c", 432, "ctx->buf_len >= ctx->buf_off");
            v11 = (v14 + v11);
          }
          else
          {
            if (callback >= 4)
              OpenSSLDie("/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/bio_b64.c", 400, "ctx->tmp_len <= 3");
            if (3 - callback >= a3)
              LODWORD(v14) = a3;
            else
              LODWORD(v14) = 3 - callback;
            memcpy((char *)&next_bio[14].next_bio + callback + 2, a2, (int)v14);
            v17 = LODWORD(next_bio->callback) + v14;
            LODWORD(next_bio->callback) = v17;
            v11 = (v14 + v11);
            if (v17 < 3)
              return v11;
            v18 = EVP_EncodeBlock(v27, f, v17);
            LODWORD(next_bio->method) = v18;
            if (v18 >= 1503)
              OpenSSLDie("/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/bio_b64.c", 414, "ctx->buf_len <= (int)sizeof(ctx->buf)");
            if (v18 < SHIDWORD(next_bio->method))
              OpenSSLDie("/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/bio_b64.c", 415, "ctx->buf_len >= ctx->buf_off");
            LODWORD(next_bio->callback) = 0;
          }
        }
        else
        {
          EVP_EncodeUpdate((EVP_ENCODE_CTX *)&next_bio->shutdown, v27, (int *)next_bio, (const unsigned __int8 *)a2, v14);
          if (!v15)
          {
            if ((_DWORD)v11)
              return v11;
            else
              return 0xFFFFFFFFLL;
          }
          if (SLODWORD(next_bio->method) >= 1503)
            OpenSSLDie("/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/bio_b64.c", 440, "ctx->buf_len <= (int)sizeof(ctx->buf)");
          if (SLODWORD(next_bio->method) < SHIDWORD(next_bio->method))
            OpenSSLDie("/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/bio_b64.c", 441, "ctx->buf_len >= ctx->buf_off");
          v11 = (v11 + v14);
        }
        HIDWORD(next_bio->method) = 0;
        v20 = (int)next_bio->method;
        if (SLODWORD(next_bio->method) >= 1)
          break;
LABEL_58:
        a2 += (int)v14;
        next_bio->method = 0;
        v24 = __OFSUB__(a3, (_DWORD)v14);
        a3 -= v14;
        if ((a3 < 0) ^ v24 | (a3 == 0))
          return v11;
      }
      while (1)
      {
        v21 = BIO_write(a1->prev_bio, (char *)&next_bio[1].callback + SHIDWORD(next_bio->method) + 4, v20);
        v22 = v21;
        if (v21 <= 0)
          break;
        v12 = v20 >= v21;
        v20 -= v21;
        if (!v12)
          OpenSSLDie("/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/bio_b64.c", 455, "i <= n");
        v23 = HIDWORD(next_bio->method) + v21;
        HIDWORD(next_bio->method) = v23;
        if (v23 >= 1503)
          OpenSSLDie("/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/bio_b64.c", 458, "ctx->buf_off <= (int)sizeof(ctx->buf)");
        if (SLODWORD(next_bio->method) < v23)
          OpenSSLDie("/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/bio_b64.c", 459, "ctx->buf_len >= ctx->buf_off");
        if (v20 <= 0)
          goto LABEL_58;
      }
      BIO_copy_next_retry(a1);
      if ((_DWORD)v11)
        return v11;
      else
        return v22;
    }
  }
  else
  {
    while (1)
    {
      v10 = BIO_write(a1->prev_bio, (char *)&next_bio[1].callback + SHIDWORD(next_bio->method) + 4, v9);
      v11 = v10;
      if ((int)v10 <= 0)
        break;
      v12 = v9 >= v10;
      v9 -= v10;
      if (!v12)
        OpenSSLDie("/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/bio_b64.c", 382, "i <= n");
      v13 = HIDWORD(next_bio->method) + v10;
      HIDWORD(next_bio->method) = v13;
      if (v13 >= 1503)
        OpenSSLDie("/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/bio_b64.c", 384, "ctx->buf_off <= (int)sizeof(ctx->buf)");
      if (SLODWORD(next_bio->method) < v13)
        OpenSSLDie("/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/bio_b64.c", 385, "ctx->buf_len >= ctx->buf_off");
      if (v9 <= 0)
        goto LABEL_18;
    }
    BIO_copy_next_retry(a1);
  }
  return v11;
}

uint64_t b64_read(BIO *b, char *a2, int a3)
{
  bio_st *next_bio;
  char *v6;
  int method;
  int method_high;
  int v9;
  int v10;
  int v11;
  int v12;
  unsigned int v14;
  const unsigned __int8 *v15;
  int v16;
  int callback;
  int v18;
  unint64_t v19;
  uint64_t v20;
  const unsigned __int8 *v21;
  uint64_t v22;
  char *v23;
  const unsigned __int8 *v24;
  uint64_t v25;
  unint64_t i;
  int v27;
  uint64_t v28;
  _BYTE *v29;
  char v30;
  int v31;
  int v32;
  unint64_t v33;
  int v34;
  int v35;
  size_t v36;
  int v37;
  int v38;
  int v39;
  BOOL v40;
  int v41;
  unsigned int v42;
  unsigned int v43;
  int outl;

  if (!a2)
    return 0;
  next_bio = b->next_bio;
  if (!next_bio || !b->prev_bio)
    return 0;
  v6 = a2;
  outl = 0;
  BIO_clear_flags(b, 15);
  if (LODWORD(next_bio->cb_arg) != 2)
  {
    LODWORD(next_bio->cb_arg) = 2;
    next_bio->method = 0;
    LODWORD(next_bio->callback) = 0;
    EVP_DecodeInit((EVP_ENCODE_CTX *)&next_bio->shutdown);
  }
  method = (int)next_bio->method;
  if (SLODWORD(next_bio->method) < 1)
  {
    v10 = 0;
  }
  else
  {
    method_high = HIDWORD(next_bio->method);
    if (method < method_high)
      OpenSSLDie("/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/bio_b64.c", 177, "ctx->buf_len >= ctx->buf_off");
    v9 = method - method_high;
    if (v9 >= a3)
      v10 = a3;
    else
      v10 = v9;
    if (v10 + method_high >= 1502)
      OpenSSLDie("/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/bio_b64.c", 181, "ctx->buf_off + i < (int)sizeof(ctx->buf)");
    memcpy(v6, (char *)&next_bio[1].callback + method_high + 4, v10);
    v6 += v10;
    a3 -= v10;
    v11 = (int)next_bio->method;
    v12 = HIDWORD(next_bio->method) + v10;
    HIDWORD(next_bio->method) = v12;
    if (v11 == v12)
      next_bio->method = 0;
  }
  v42 = v10;
  v14 = 0;
  if (a3 >= 1)
  {
    v15 = (const unsigned __int8 *)&next_bio[14].next_bio + 2;
    while (1)
    {
      if (next_bio->init < 1)
        goto LABEL_85;
      v43 = v14;
      v41 = a3;
LABEL_23:
      v16 = BIO_read(b->prev_bio, (char *)&next_bio[14].next_bio + SLODWORD(next_bio->callback) + 2, 1024 - LODWORD(next_bio->callback));
      v14 = v16;
      if (v16 < 1)
      {
        if (BIO_test_flags(b->prev_bio, 8))
          goto LABEL_85;
        next_bio->init = v14;
        callback = (int)next_bio->callback;
        if (!callback)
          goto LABEL_85;
        v18 = 0;
        v43 = v14;
      }
      else
      {
        callback = (int)next_bio->callback;
        v18 = v16;
      }
      LODWORD(v19) = callback + v18;
      LODWORD(next_bio->callback) = callback + v18;
      if (HIDWORD(next_bio->cb_arg))
      {
        if ((BIO_test_flags(b, -1) & 0x100) != 0)
          goto LABEL_65;
        if (HIDWORD(next_bio->cb_arg))
          break;
      }
      if ((int)v19 <= 1023 && next_bio->init > 0)
        goto LABEL_63;
LABEL_66:
      if ((BIO_test_flags(b, -1) & 0x100) != 0)
      {
        v33 = (int)v19 & 0xFFFFFFFFFFFFFFFCLL;
        v34 = EVP_DecodeBlock((unsigned __int8 *)&next_bio[1].callback + 4, (const unsigned __int8 *)&next_bio[14].next_bio + 2, v19 & 0xFFFFFFFC);
        v31 = v34;
        if ((int)v33 >= 3 && *((_BYTE *)&next_bio[14].next_bio + (v33 - 1) + 2) == 61)
        {
          if (*((_BYTE *)&next_bio[14].next_bio + (v33 - 2) + 2) == 61)
            v35 = -2;
          else
            v35 = -1;
          v31 = v35 + v34;
        }
        if ((_DWORD)v33 != (_DWORD)v19)
        {
          v36 = v19 & 3;
          memmove((char *)&next_bio[14].next_bio + 2, (char *)&next_bio[14].next_bio + v33 + 2, v36);
          LODWORD(next_bio->callback) = v36;
        }
        LODWORD(next_bio->method) = v31 & ~(v31 >> 31);
        v32 = v41;
      }
      else
      {
        v31 = EVP_DecodeUpdate((EVP_ENCODE_CTX *)&next_bio->shutdown, (unsigned __int8 *)&next_bio[1].callback + 4, (int *)next_bio, (const unsigned __int8 *)&next_bio[14].next_bio + 2, v19);
        LODWORD(next_bio->callback) = 0;
        v32 = v41;
      }
      HIDWORD(next_bio->method) = 0;
      if (v31 < 0)
      {
        v14 = 0;
        LODWORD(next_bio->method) = 0;
        goto LABEL_85;
      }
      if (SLODWORD(next_bio->method) >= v32)
        v37 = v32;
      else
        v37 = (int)next_bio->method;
      v38 = v32;
      v39 = v37;
      memcpy(v6, (char *)&next_bio[1].callback + 4, v37);
      HIDWORD(next_bio->method) = v37;
      if (v37 == LODWORD(next_bio->method))
        next_bio->method = 0;
      v42 += v37;
      v6 += v37;
      a3 = v38 - v37;
      v40 = v38 <= v39;
      v14 = v43;
      if (v40)
        goto LABEL_85;
    }
    outl = 0;
    if ((int)v19 < 1)
    {
      LODWORD(v22) = 0;
      v21 = (const unsigned __int8 *)&next_bio[14].next_bio + 2;
      v25 = (uint64_t)&next_bio[14].next_bio + 2;
      goto LABEL_52;
    }
    v20 = 0;
    v21 = (const unsigned __int8 *)&next_bio[14].next_bio + 2;
    while (1)
    {
      v22 = v20;
      v23 = (char *)next_bio + v20;
      if (v23[1626] == 10)
      {
        v24 = (const unsigned __int8 *)(v23 + 1627);
        if (HIDWORD(next_bio->callback))
        {
          HIDWORD(next_bio->callback) = 0;
        }
        else
        {
          if (EVP_DecodeUpdate((EVP_ENCODE_CTX *)&next_bio->shutdown, (unsigned __int8 *)&next_bio[1].callback + 4, &outl, v21, (_DWORD)next_bio + 1627 + v22 - (_DWORD)v21) > 0|| outl|| !HIDWORD(next_bio->cb_arg))
          {
            if (v21 != v15)
            {
              v19 = (v19 + (_DWORD)v15 - (_DWORD)v21);
              if ((int)v19 >= 1)
              {
                for (i = 0; i < v19; ++i)
                  v15[i] = v21[i];
              }
            }
            v25 = (uint64_t)&next_bio[14].next_bio + v22 + 3;
            EVP_DecodeInit((EVP_ENCODE_CTX *)&next_bio->shutdown);
            HIDWORD(next_bio->cb_arg) = 0;
LABEL_52:
            if ((_DWORD)v22 != (_DWORD)v19 || outl)
            {
LABEL_65:
              LODWORD(next_bio->callback) = 0;
              goto LABEL_66;
            }
            if (v21 == v15)
            {
              if ((_DWORD)v22 == 1024)
              {
                v27 = 0;
                HIDWORD(next_bio->callback) = 1;
                goto LABEL_62;
              }
            }
            else if (v21 != (const unsigned __int8 *)v25)
            {
              v27 = v25 - (_DWORD)v21;
              if ((int)v25 - (int)v21 >= 1)
              {
                v28 = (v25 - (_DWORD)v21);
                v29 = (char *)&next_bio[14].next_bio + 2;
                do
                {
                  v30 = *v21++;
                  *v29++ = v30;
                  --v28;
                }
                while (v28);
              }
LABEL_62:
              LODWORD(next_bio->callback) = v27;
            }
LABEL_63:
            if (next_bio->init < 1)
            {
              v14 = v43;
              break;
            }
            goto LABEL_23;
          }
          EVP_DecodeInit((EVP_ENCODE_CTX *)&next_bio->shutdown);
        }
        v21 = v24;
      }
      v20 = v22 + 1;
      if ((_DWORD)v19 == (_DWORD)v22 + 1)
      {
        v25 = (uint64_t)&next_bio[14].next_bio + v22 + 3;
        LODWORD(v22) = v19;
        goto LABEL_52;
      }
    }
  }
LABEL_85:
  BIO_copy_next_retry(b);
  if (v42)
    return v42;
  else
    return v14;
}

uint64_t b64_puts(BIO *a1, char *__s)
{
  int v4;

  v4 = strlen(__s);
  return b64_write(a1, __s, v4);
}

uint64_t b64_ctrl(BIO *b, int a2, uint64_t larg, void *parg)
{
  bio_st *next_bio;
  uint64_t result;
  BIO *prev_bio;
  uint64_t v10;
  int method;
  int method_high;
  int callback;
  int v14;
  int v15;
  int v16;

  next_bio = b->next_bio;
  result = 1;
  switch(a2)
  {
    case 1:
      next_bio->init = 1;
      next_bio->cb_arg = (char *)0x100000000;
      prev_bio = b->prev_bio;
      a2 = 1;
      return BIO_ctrl(prev_bio, a2, larg, parg);
    case 2:
      if (next_bio->init < 1)
        return 1;
      prev_bio = b->prev_bio;
      a2 = 2;
      return BIO_ctrl(prev_bio, a2, larg, parg);
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
      goto LABEL_5;
    case 10:
      method = (int)next_bio->method;
      method_high = HIDWORD(next_bio->method);
      if (SLODWORD(next_bio->method) < method_high)
        OpenSSLDie("/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/bio_b64.c", 499, "ctx->buf_len >= ctx->buf_off");
      result = (method - method_high);
      if (method > method_high)
        return result;
      prev_bio = b->prev_bio;
      a2 = 10;
      return BIO_ctrl(prev_bio, a2, larg, parg);
    case 11:
      break;
    case 12:
      return result;
    case 13:
      v15 = (int)next_bio->method;
      v16 = HIDWORD(next_bio->method);
      if (SLODWORD(next_bio->method) < v16)
        OpenSSLDie("/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/bio_b64.c", 490, "ctx->buf_len >= ctx->buf_off");
      result = (v15 - v16);
      if (v15 == v16 && LODWORD(next_bio->cb_arg) && next_bio->shutdown)
        return 1;
      if ((int)result > 0)
        return result;
      prev_bio = b->prev_bio;
      a2 = 13;
      return BIO_ctrl(prev_bio, a2, larg, parg);
    default:
      if (a2 == 101)
      {
        BIO_clear_flags(b, 15);
        v10 = BIO_ctrl(b->prev_bio, 101, larg, parg);
        BIO_copy_next_retry(b);
        return v10;
      }
LABEL_5:
      prev_bio = b->prev_bio;
      return BIO_ctrl(prev_bio, a2, larg, parg);
  }
  while (2)
  {
    while (LODWORD(next_bio->method) != HIDWORD(next_bio->method))
    {
      LODWORD(result) = b64_write(b, 0, 0);
      if ((result & 0x80000000) != 0)
        return (int)result;
    }
    if ((BIO_test_flags(b, -1) & 0x100) != 0)
    {
      callback = (int)next_bio->callback;
      if (callback)
      {
        v14 = EVP_EncodeBlock((unsigned __int8 *)&next_bio[1].callback + 4, (const unsigned __int8 *)&next_bio[14].next_bio + 2, callback);
        HIDWORD(next_bio->method) = 0;
        LODWORD(next_bio->callback) = 0;
        LODWORD(next_bio->method) = v14;
        continue;
      }
    }
    else if (LODWORD(next_bio->cb_arg) && next_bio->shutdown)
    {
      HIDWORD(next_bio->method) = 0;
      EVP_EncodeFinal((EVP_ENCODE_CTX *)&next_bio->shutdown, (unsigned __int8 *)&next_bio[1].callback + 4, (int *)next_bio);
      continue;
    }
    break;
  }
  prev_bio = b->prev_bio;
  a2 = 11;
  return BIO_ctrl(prev_bio, a2, larg, parg);
}

double b64_new(uint64_t a1)
{
  _QWORD *v2;
  double result;

  v2 = malloc_type_malloc(0xA5CuLL, 0x10000407E11CA4CuLL);
  if (v2)
  {
    *v2 = 0;
    v2[1] = 0;
    *((_DWORD *)v2 + 6) = 1;
    *(_QWORD *)&result = 0x100000000;
    v2[2] = 0x100000000;
    *(_DWORD *)(a1 + 32) = 1;
    *(_QWORD *)(a1 + 56) = v2;
    *(_DWORD *)(a1 + 40) = 0;
    *(_DWORD *)(a1 + 48) = 0;
  }
  return result;
}

uint64_t b64_free(uint64_t result)
{
  uint64_t v1;

  if (result)
  {
    v1 = result;
    free(*(void **)(result + 56));
    *(_QWORD *)(v1 + 56) = 0;
    *(_DWORD *)(v1 + 32) = 0;
    result = 1;
    *(_DWORD *)(v1 + 40) = 0;
  }
  return result;
}

BIO *b64_callback_ctrl(uint64_t a1, int a2, void (__cdecl *a3)(bio_st *, int, const char *, int, uint64_t, uint64_t))
{
  BIO *result;

  result = *(BIO **)(a1 + 64);
  if (result)
    return (BIO *)BIO_callback_ctrl(result, a2, a3);
  return result;
}

void ENGINE_unregister_ECDH(ENGINE *e)
{
  engine_table_unregister(&ecdh_table, e);
}

int ENGINE_register_ECDH(ENGINE *e)
{
  if (*((_QWORD *)e + 5))
    return engine_table_register(&ecdh_table, (uint64_t)engine_unregister_all_ECDH, (char *)e, &dummy_nid_2, 1, 0);
  else
    return 1;
}

void engine_unregister_all_ECDH()
{
  engine_table_cleanup(&ecdh_table);
}

void ENGINE_register_all_ECDH(void)
{
  ENGINE *first;
  ENGINE *next;

  first = ENGINE_get_first();
  if (first)
  {
    next = first;
    do
    {
      if (*((_QWORD *)next + 5))
        engine_table_register(&ecdh_table, (uint64_t)engine_unregister_all_ECDH, (char *)next, &dummy_nid_2, 1, 0);
      next = ENGINE_get_next(next);
    }
    while (next);
  }
}

int ENGINE_set_default_ECDH(ENGINE *e)
{
  if (*((_QWORD *)e + 5))
    return engine_table_register(&ecdh_table, (uint64_t)engine_unregister_all_ECDH, (char *)e, &dummy_nid_2, 1, 1);
  else
    return 1;
}

ENGINE *ENGINE_get_default_ECDH(void)
{
  return (ENGINE *)engine_table_select(&ecdh_table, 1);
}

const ECDH_METHOD *__cdecl ENGINE_get_ECDH(const ENGINE *e)
{
  return (const ECDH_METHOD *)*((_QWORD *)e + 5);
}

int ENGINE_set_ECDH(ENGINE *e, const ECDH_METHOD *ecdh_meth)
{
  *((_QWORD *)e + 5) = ecdh_meth;
  return 1;
}

int DH_generate_key(DH *dh)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)&dh->ex_data.dummy + 8))();
}

int DH_compute_key(unsigned __int8 *key, const BIGNUM *pub_key, DH *dh)
{
  return (*(uint64_t (**)(unsigned __int8 *, const BIGNUM *))(*(_QWORD *)&dh->ex_data.dummy + 16))(key, pub_key);
}

const DH_METHOD *DH_OpenSSL(void)
{
  return (const DH_METHOD *)&dh_ossl;
}

uint64_t generate_key(uint64_t a1)
{
  uint64_t v2;
  BN_CTX *v3;
  BIGNUM *v4;
  BIGNUM *v5;
  BN_MONT_CTX *v6;
  BIGNUM *v7;
  const BIGNUM *v9;
  const BIGNUM *v10;
  uint64_t v11;

  if (BN_num_bits(*(const BIGNUM **)(a1 + 8)) >= 10001)
  {
    ERR_put_error(5, 4095, 103, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/dh/dh_key.c", 112);
    return 0;
  }
  v3 = BN_CTX_new();
  if (!v3)
  {
    v5 = 0;
    v4 = 0;
    goto LABEL_11;
  }
  v4 = *(BIGNUM **)(a1 + 40);
  if (!v4)
  {
    v4 = BN_new();
    if (!v4)
    {
      v5 = 0;
      goto LABEL_11;
    }
  }
  v5 = *(BIGNUM **)(a1 + 32);
  if (!v5)
  {
    v5 = BN_new();
    if (!v5)
      goto LABEL_11;
  }
  if ((*(_BYTE *)(a1 + 48) & 1) == 0)
  {
    v6 = 0;
    goto LABEL_20;
  }
  v6 = BN_MONT_CTX_set_locked((BN_MONT_CTX **)(a1 + 56), 26, *(const BIGNUM **)(a1 + 8), v3);
  if (!v6)
  {
LABEL_11:
    v7 = 0;
    goto LABEL_12;
  }
LABEL_20:
  if (*(_QWORD *)(a1 + 40))
  {
    v7 = 0;
  }
  else if (*(_QWORD *)(a1 + 64))
  {
    v7 = BN_new();
    if (!v7)
      goto LABEL_12;
    v9 = BN_value_one();
    v10 = BN_value_one();
    if (!BN_add(v7, v9, v10) || !bn_rand_interval(v4, v7, *(BIGNUM **)(a1 + 64)))
      goto LABEL_12;
  }
  else
  {
    v11 = *(_QWORD *)(a1 + 24);
    if (!v11)
      LODWORD(v11) = BN_num_bits(*(const BIGNUM **)(a1 + 8)) - 1;
    v7 = 0;
    if (!BN_rand(v4, v11, 0, 0))
      goto LABEL_12;
  }
  if (!(*(unsigned int (**)(uint64_t, BIGNUM *, _QWORD, BIGNUM *, _QWORD, BN_CTX *, BN_MONT_CTX *))(*(_QWORD *)(a1 + 120) + 24))(a1, v5, *(_QWORD *)(a1 + 16), v4, *(_QWORD *)(a1 + 8), v3, v6))
  {
LABEL_12:
    ERR_put_error(5, 4095, 3, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/dh/dh_key.c", 162);
    if (!*(_QWORD *)(a1 + 32))
      BN_free(v5);
    v2 = 0;
    goto LABEL_15;
  }
  *(_QWORD *)(a1 + 32) = v5;
  *(_QWORD *)(a1 + 40) = v4;
  v2 = 1;
LABEL_15:
  if (!*(_QWORD *)(a1 + 40))
    BN_free(v4);
  BN_CTX_free(v3);
  BN_free(v7);
  return v2;
}

uint64_t compute_key(unsigned __int8 *a1, const BIGNUM *a2, uint64_t a3)
{
  BN_CTX *v6;
  BN_CTX *v7;
  BIGNUM *v8;
  const BIGNUM *v9;
  BN_MONT_CTX *v10;
  uint64_t v11;
  int v12;
  int v13;
  int codes;

  if (BN_num_bits(*(const BIGNUM **)(a3 + 8)) < 10001)
  {
    v6 = BN_CTX_new();
    if (!v6)
      return 0xFFFFFFFFLL;
    v7 = v6;
    codes = 0;
    BN_CTX_start(v6);
    v8 = BN_CTX_get(v7);
    if (!v8)
      goto LABEL_18;
    if (*(_QWORD *)(a3 + 40))
    {
      v9 = v8;
      if ((*(_BYTE *)(a3 + 48) & 1) != 0)
      {
        v10 = BN_MONT_CTX_set_locked((BN_MONT_CTX **)(a3 + 56), 26, *(const BIGNUM **)(a3 + 8), v7);
        BN_set_flags(*(_QWORD *)(a3 + 40), 4);
        if (!v10)
        {
LABEL_18:
          v11 = 0xFFFFFFFFLL;
          goto LABEL_19;
        }
      }
      else
      {
        v10 = 0;
      }
      if (!DH_check_pub_key((const DH *)a3, a2, &codes) || codes)
      {
        v12 = 102;
        v13 = 210;
      }
      else
      {
        if ((*(unsigned int (**)(uint64_t, const BIGNUM *, const BIGNUM *, _QWORD, _QWORD, BN_CTX *, BN_MONT_CTX *))(*(_QWORD *)(a3 + 120) + 24))(a3, v9, a2, *(_QWORD *)(a3 + 40), *(_QWORD *)(a3 + 8), v7, v10))
        {
          v11 = BN_bn2bin(v9, a1);
LABEL_19:
          BN_CTX_end(v7);
          BN_CTX_free(v7);
          return v11;
        }
        v12 = 3;
        v13 = 216;
      }
    }
    else
    {
      v12 = 100;
      v13 = 195;
    }
    ERR_put_error(5, 4095, v12, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/dh/dh_key.c", v13);
    goto LABEL_18;
  }
  ERR_put_error(5, 4095, 103, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/dh/dh_key.c", 183);
  return 0xFFFFFFFFLL;
}

uint64_t dh_bn_mod_exp(int a1, BIGNUM *rr, BIGNUM *a, BIGNUM *p, BIGNUM *m, BN_CTX *ctx, BN_MONT_CTX *in_mont)
{
  return BN_mod_exp_mont_ct(rr, a, p, m, ctx, in_mont);
}

uint64_t dh_init(uint64_t a1)
{
  *(_DWORD *)(a1 + 48) |= 1u;
  return 1;
}

uint64_t dh_finish(uint64_t a1)
{
  BN_MONT_CTX_free(*(BN_MONT_CTX **)(a1 + 56));
  return 1;
}

int EVP_PBE_CipherInit(ASN1_OBJECT *pbe_obj, const char *pass, int passlen, ASN1_TYPE *param, EVP_CIPHER_CTX *ctx, int en_de)
{
  uint64_t v6;
  size_t v9;
  int v12;
  const char *v13;
  const EVP_CIPHER *cipherbyname;
  int v15;
  int v16;
  const char *v17;
  const EVP_MD *digestbyname;
  unsigned int (*v20)(EVP_CIPHER_CTX *, const char *, size_t, ASN1_TYPE *, const EVP_CIPHER *, const EVP_MD *, uint64_t);
  int n[2];
  char buf[80];
  uint64_t v23;

  v6 = *(_QWORD *)&en_de;
  v9 = *(_QWORD *)&passlen;
  v23 = *MEMORY[0x24BDAC8D0];
  v20 = 0;
  *(_QWORD *)n = 0;
  v12 = OBJ_obj2nid(pbe_obj);
  if (!EVP_PBE_find(0, v12, &n[1], n, &v20))
  {
    ERR_put_error(6, 4095, 121, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/evp_pbe.c", 133);
    if (pbe_obj)
      i2t_ASN1_OBJECT(buf, 80, pbe_obj);
    else
      __strlcpy_chk();
    ERR_asprintf_error_data("TYPE=%s", buf);
    return 0;
  }
  if (pass)
  {
    if ((_DWORD)v9 == -1)
      v9 = strlen(pass);
  }
  else
  {
    v9 = 0;
  }
  if (n[1] == -1)
  {
    cipherbyname = 0;
LABEL_12:
    if (n[0] == -1)
    {
      digestbyname = 0;
    }
    else
    {
      v17 = OBJ_nid2sn(n[0]);
      digestbyname = EVP_get_digestbyname(v17);
      if (!digestbyname)
      {
        v15 = 161;
        v16 = 162;
        goto LABEL_21;
      }
    }
    if (v20(ctx, pass, v9, param, cipherbyname, digestbyname, v6))
      return 1;
    v15 = 120;
    v16 = 168;
    goto LABEL_21;
  }
  v13 = OBJ_nid2sn(n[1]);
  cipherbyname = EVP_get_cipherbyname(v13);
  if (cipherbyname)
    goto LABEL_12;
  v15 = 160;
  v16 = 152;
LABEL_21:
  ERR_put_error(6, 4095, v15, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/evp_pbe.c", v16);
  return 0;
}

uint64_t EVP_PBE_find(int a1, int a2, _DWORD *a3, _DWORD *a4, _QWORD *a5)
{
  int v8;
  uint64_t result;
  char data[4];
  int v11;
  uint64_t v12;
  uint64_t v13;

  if (!a2)
    return 0;
  v12 = 0;
  v13 = 0;
  *(_DWORD *)data = a1;
  v11 = a2;
  if (pbe_algs
    && (v8 = sk_find((STACK *)pbe_algs, data), v8 != -1)
    && (result = (uint64_t)sk_value((const STACK *)pbe_algs, v8)) != 0
    || (result = (uint64_t)OBJ_bsearch_(data, builtin_pbe, 23, 24, (int (__cdecl *)(const void *, const void *))pbe2_cmp_BSEARCH_CMP_FN)) != 0)
  {
    if (a3)
      *a3 = *(_DWORD *)(result + 8);
    if (a4)
      *a4 = *(_DWORD *)(result + 12);
    if (a5)
      *a5 = *(_QWORD *)(result + 16);
    return 1;
  }
  return result;
}

uint64_t EVP_PBE_alg_add_type(int a1, int a2, int a3, int a4, uint64_t a5)
{
  _DWORD *v10;
  void *v11;
  int v13;

  if (pbe_algs || (pbe_algs = (uint64_t)sk_new((int (__cdecl *)(const char *const *, const char *const *))pbe_cmp)) != 0)
  {
    v10 = malloc_type_malloc(0x18uLL, 0x108004098BBCF0FuLL);
    if (v10)
    {
      v11 = v10;
      *v10 = a1;
      v10[1] = a2;
      v10[2] = a3;
      v10[3] = a4;
      *((_QWORD *)v10 + 2) = a5;
      if (sk_push((STACK *)pbe_algs, (char *)v10))
        return 1;
      free(v11);
      v13 = 244;
    }
    else
    {
      v13 = 233;
    }
  }
  else
  {
    v13 = 227;
  }
  ERR_put_error(6, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/evp_pbe.c", v13);
  return 0;
}

uint64_t pbe_cmp(int **a1, int **a2)
{
  int *v2;
  int v3;
  int v4;
  uint64_t result;

  v2 = *a1;
  v3 = **a1;
  v4 = **a2;
  result = (v3 - v4);
  if (v3 == v4)
    return (v2[1] - (*a2)[1]);
  return result;
}

int EVP_PBE_alg_add(int nid, const EVP_CIPHER *cipher, const EVP_MD *md, EVP_PBE_KEYGEN *keygen)
{
  int v7;
  int v8;

  if (!cipher)
  {
    v7 = -1;
    if (md)
      goto LABEL_3;
LABEL_5:
    v8 = -1;
    return EVP_PBE_alg_add_type(0, nid, v7, v8, (uint64_t)keygen);
  }
  v7 = EVP_CIPHER_nid(cipher);
  if (!md)
    goto LABEL_5;
LABEL_3:
  v8 = EVP_MD_type(md);
  return EVP_PBE_alg_add_type(0, nid, v7, v8, (uint64_t)keygen);
}

void EVP_PBE_cleanup(void)
{
  sk_pop_free((STACK *)pbe_algs, free_evp_pbe_ctl);
  pbe_algs = 0;
}

uint64_t pbe2_cmp_BSEARCH_CMP_FN(int *a1, _DWORD *a2)
{
  int v3;
  uint64_t result;

  v3 = *a1;
  result = (*a1 - *a2);
  if (v3 == *a2)
    return (a1[1] - a2[1]);
  return result;
}

void DES_set_odd_parity(DES_cblock *key)
{
  uint64_t i;

  for (i = 0; i != 8; ++i)
    (*key)[i] = odd_parity[(*key)[i]];
}

int DES_check_key_parity(const_DES_cblock *key)
{
  uint64_t v1;

  v1 = 0;
  while ((*key)[v1] == odd_parity[(*key)[v1]])
  {
    if (++v1 == 8)
      return 1;
  }
  return 0;
}

int DES_is_weak_key(const_DES_cblock *key)
{
  uint64_t v1;

  v1 = 0;
  while (weak_keys[v1] != *(_QWORD *)key)
  {
    if (++v1 == 16)
      return 0;
  }
  return 1;
}

int DES_set_key(const_DES_cblock *key, DES_key_schedule *schedule)
{
  if (DES_check_key)
    return DES_set_key_checked(key, schedule);
  DES_set_key_unchecked(key, schedule);
  return 0;
}

int DES_set_key_checked(const_DES_cblock *key, DES_key_schedule *schedule)
{
  uint64_t i;
  uint64_t v3;

  for (i = 0; i != 8; ++i)
  {
    if ((*key)[i] != odd_parity[(*key)[i]])
      return -1;
  }
  v3 = 0;
  while (weak_keys[v3] != *(_QWORD *)key)
  {
    if (++v3 == 16)
    {
      DES_set_key_unchecked(key, schedule);
      return 0;
    }
  }
  return -2;
}

void DES_set_key_unchecked(const_DES_cblock *key, DES_key_schedule *schedule)
{
  uint64_t v2;
  unsigned int v3;
  int v4;
  unsigned int v5;
  unsigned int v6;
  int v7;
  unsigned int v8;
  int v9;
  int v10;
  unsigned int v11;
  int v12;
  int v13;
  unsigned int v14;
  unsigned int v15;
  char v16;
  unsigned int v17;
  char v18;
  unsigned int v19;
  unsigned int v20;
  int v21;
  int v22;
  int v23;
  unint64_t v24;

  v2 = 0;
  v3 = *(_DWORD *)&(*key)[4];
  v4 = (*(_DWORD *)key ^ (v3 >> 4)) & 0xF0F0F0F;
  v5 = ((v4 ^ *(_DWORD *)key ^ ((v4 ^ *(_DWORD *)key) << 18)) & 0xCCCC0000 | (((v4 ^ *(_DWORD *)key ^ ((v4 ^ *(_DWORD *)key) << 18)) & 0xCCCC0000) >> 18)) ^ v4 ^ *(_DWORD *)key;
  v6 = ((v3 ^ (16 * v4) ^ ((v3 ^ (16 * v4)) << 18)) & 0xCCCC0000 | (((v3 ^ (16 * v4) ^ ((v3 ^ (16 * v4)) << 18)) & 0xCCCC0000) >> 18)) ^ v3 ^ (16 * v4);
  v7 = (v5 ^ (v6 >> 1)) & 0x55555555;
  v8 = v7 ^ v5;
  v9 = v6 ^ (2 * v7);
  v10 = (v9 ^ (v8 >> 8)) & 0xFF00FF;
  v11 = v10 ^ v9;
  v12 = v8 ^ (v10 << 8);
  v13 = (v12 ^ (v11 >> 1)) & 0x55555555;
  v14 = v13 ^ v12;
  v15 = (v14 >> 4) & 0xF000000 | (v11 ^ (2 * v13)) & 0xFF00 | ((v11 ^ (2 * v13)) << 16) | ((v11 ^ (2 * v13)) >> 16);
  do
  {
    if (((0x8103uLL >> v2) & 1) != 0)
      v16 = 1;
    else
      v16 = 2;
    v17 = (v14 & 0xFFFFFFF) >> v16;
    if (((0x8103uLL >> v2) & 1) != 0)
      v18 = 27;
    else
      v18 = 26;
    v19 = v15 >> v16;
    v14 = v17 | (v14 << v18);
    v20 = v19 | (v15 << v18);
    v15 = v20 & 0xFFFFFFF;
    v21 = des_skb[((v17 >> 7) & 0x3C | (v17 >> 6)) + 64] | des_skb[v17 & 0x3F] | des_skb[((v17 >> 14) & 0x30 | (v17 >> 13) & 0xF) + 128] | des_skb[((v17 >> 21) & 6 | (v17 >> 20) & 1 | (v14 >> 22) & 0x38) + 192];
    v22 = des_skb[((v19 >> 8) & 0x3C | (v19 >> 7) & 3) + 320] | des_skb[(v19 & 0x3F) + 256] | des_skb[((v19 >> 15) & 0x3F) + 384] | des_skb[((v20 >> 22) & 0x30 | (v19 >> 21) & 0xF) + 448];
    HIDWORD(v24) = v22 << 16;
    LODWORD(v24) = v22 << 16;
    v23 = v24 >> 30;
    HIDWORD(v24) = v22 & 0x3FF0000 | HIWORD(v21);
    LODWORD(v24) = v22;
    schedule->ks[0].deslong[0] = v23 | (4 * (unsigned __int16)v21);
    schedule->ks[0].deslong[1] = v24 >> 26;
    schedule = (DES_key_schedule *)((char *)schedule + 8);
    ++v2;
  }
  while (v2 != 16);
}

int BN_bn2bin(const BIGNUM *a, unsigned __int8 *to)
{
  return bn2binpad(a, (char *)to, 0xFFFFFFFFLL, 0);
}

uint64_t bn2binpad(const BIGNUM *a1, char *a2, uint64_t a3, int a4)
{
  int v8;
  int v9;
  uint64_t v10;
  int v11;
  int v12;
  uint64_t dmax;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  uint64_t v18;
  uint64_t v19;
  char *v20;
  BIGNUM v22;

  v8 = BN_num_bits(a1);
  v9 = v8 + 7;
  if (v8 < -7)
    v9 = v8 + 14;
  v10 = (v9 >> 3);
  if ((_DWORD)a3 == -1)
  {
    a3 = v10;
  }
  else if ((int)v10 > (int)a3)
  {
    v22 = *a1;
    bn_correct_top((uint64_t *)&v22);
    v11 = BN_num_bits(&v22);
    v12 = v11 + 7;
    if (v11 < -7)
      v12 = v11 + 14;
    if ((int)a3 < v12 >> 3)
      return 0xFFFFFFFFLL;
  }
  dmax = a1->dmax;
  if ((_DWORD)dmax)
  {
    if ((_DWORD)a3)
    {
      v14 = 0;
      v15 = (int)a3;
      if (a4)
        v16 = 0;
      else
        v16 = (int)a3;
      v17 = &a2[v16];
      v18 = 8 * dmax;
      v19 = -8 * a1->top;
      do
      {
        if (a4)
          v20 = v17;
        else
          v20 = v17 - 1;
        if (a4)
          ++v17;
        else
          --v17;
        *v20 = (v19 >> 63) & (*(unint64_t *)((char *)a1->d + (v14 & 0xFFFFFFFFFFFFFFF8)) >> (8 * (v14 & 7u)));
        v14 += (unint64_t)(v14 - v18 + 1) >> 63;
        ++v19;
        --v15;
      }
      while (v15);
    }
  }
  else
  {
    explicit_bzero(a2, (int)a3);
  }
  return a3;
}

uint64_t BN_bn2binpad(const BIGNUM *a1, char *a2, uint64_t a3)
{
  if ((a3 & 0x80000000) != 0)
    return 0xFFFFFFFFLL;
  else
    return bn2binpad(a1, a2, a3, 0);
}

BIGNUM *__cdecl BN_bin2bn(const unsigned __int8 *s, int len, BIGNUM *ret)
{
  BIGNUM *v3;
  int v4;
  BIGNUM *v6;
  unsigned int v7;
  unint64_t v8;
  int v9;
  unsigned int v10;

  if (len < 0)
    return 0;
  v3 = ret;
  v4 = len;
  if (ret)
  {
    v6 = 0;
  }
  else
  {
    v6 = BN_new();
    v3 = v6;
    if (!v6)
      return v3;
  }
  if (!v4)
  {
    v3->top = 0;
    return v3;
  }
  v7 = ((v4 - 1) >> 3) + 1;
  if (!bn_wexpand((uint64_t)v3, v7))
  {
    BN_free(v6);
    return 0;
  }
  v8 = 0;
  v9 = ((_BYTE)v4 - 1) & 7;
  v3->top = v7;
  v3->neg = 0;
  do
  {
    v10 = *s++;
    v8 = v10 | (v8 << 8);
    if (v9)
    {
      --v9;
    }
    else
    {
      v3->d[--v7] = v8;
      v9 = 7;
      v8 = 0;
    }
    --v4;
  }
  while (v4);
  bn_correct_top((uint64_t *)v3);
  return v3;
}

uint64_t BN_bn2lebinpad(const BIGNUM *a1, char *a2, uint64_t a3)
{
  if ((a3 & 0x80000000) != 0)
    return 0xFFFFFFFFLL;
  else
    return bn2binpad(a1, a2, a3, 1);
}

uint64_t BN_lebin2bn(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v5;
  BIGNUM *v6;
  uint64_t v7;
  uint64_t v8;
  BOOL v10;
  unsigned int v11;
  unint64_t v12;
  int v13;
  unsigned __int8 *v14;
  unsigned int v15;

  if (a3)
  {
    v5 = a3;
    v6 = 0;
  }
  else
  {
    v6 = BN_new();
    v5 = (uint64_t)v6;
    if (!v6)
      return v5;
  }
  v7 = a1 + a2;
  if (a2 < 1)
  {
    if (!a2)
    {
LABEL_18:
      *(_DWORD *)(v5 + 8) = 0;
      return v5;
    }
  }
  else
  {
    v8 = a1 + a2;
    while (!*(unsigned __int8 *)--v8)
    {
      v7 = v8;
      v10 = __OFSUB__(a2--, 1);
      if ((a2 < 0) ^ v10 | (a2 == 0))
        goto LABEL_18;
    }
  }
  v11 = ((a2 - 1) >> 3) + 1;
  if (bn_wexpand(v5, v11))
  {
    v12 = 0;
    *(_DWORD *)(v5 + 8) = v11;
    *(_DWORD *)(v5 + 16) = 0;
    v13 = ((_BYTE)a2 - 1) & 7;
    v14 = (unsigned __int8 *)(v7 - 1);
    do
    {
      v15 = *v14--;
      v12 = v15 | (v12 << 8);
      if (v13)
      {
        --v13;
      }
      else
      {
        *(_QWORD *)(*(_QWORD *)v5 + 8 * --v11) = v12;
        v13 = 7;
        v12 = 0;
      }
      --a2;
    }
    while (a2);
    bn_correct_top((uint64_t *)v5);
  }
  else
  {
    BN_free(v6);
    return 0;
  }
  return v5;
}

uint64_t BN_asc2bn(BIGNUM **a, uint64_t a2)
{
  _BYTE *v2;
  uint64_t v4;
  BIGNUM *v5;

  v2 = (_BYTE *)a2;
  if (*(_BYTE *)a2 == 45)
    ++a2;
  if (*(_BYTE *)a2 == 48 && (*(unsigned __int8 *)(a2 + 1) | 0x20) == 0x78)
  {
    if (!BN_hex2bn(a, (const char *)(a2 + 2)))
      return 0;
  }
  else if (!BN_dec2bn(a, (const char *)a2))
  {
    return 0;
  }
  if (*v2 != 45)
    return 1;
  v5 = *a;
  v4 = 1;
  BN_set_negative(v5, 1);
  return v4;
}

int BN_hex2bn(BIGNUM **a, const char *str)
{
  int v2;
  unsigned int v4;
  uint64_t v5;
  const char *v6;
  _BOOL4 v7;
  BIGNUM *v9;
  uint64_t v10;
  const char *v11;
  uint64_t d;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  const char *v17;
  int v18;
  int v19;
  unsigned int v20;
  unsigned int v21;
  int v22;
  int v23;
  uint64_t v24;

  if (!str)
    return 0;
  v2 = *(unsigned __int8 *)str;
  if (*str)
  {
    v4 = 0;
    v5 = 0;
    v6 = v2 == 45 ? str + 1 : str;
    v7 = v2 == 45;
    while ((*(_DWORD *)(MEMORY[0x24BDAC740] + 4 * v6[v5] + 60) & 0x10000) != 0)
    {
      ++v5;
      v4 += 4;
      if (v5 == 0x20000000)
        return 0;
    }
    v2 = v7 + v5;
    if (a)
    {
      v9 = *a;
      if (*a)
      {
        BN_zero((uint64_t)*a);
      }
      else
      {
        v9 = BN_new();
        if (!v9)
          return 0;
      }
      if (bn_expand((uint64_t)v9, v4))
      {
        if ((_DWORD)v5)
        {
          v10 = 0;
          v11 = &v6[v5];
          d = (uint64_t)v9->d;
          v13 = ((v5 - 1) >> 4) + 1;
          do
          {
            v14 = 0;
            if (v5 >= 16)
              v15 = 16;
            else
              v15 = v5;
            v16 = v15 + 1;
            v17 = &v11[-v15];
            do
            {
              v19 = *v17++;
              v18 = v19;
              v20 = v19 - 48;
              v21 = v19 - 97;
              v22 = v19 - 55;
              if ((v19 - 65) >= 6)
                v23 = 0;
              else
                v23 = v22;
              LODWORD(v24) = v18 - 87;
              if (v21 > 5)
                LODWORD(v24) = v23;
              if (v20 <= 9)
                v24 = v20;
              else
                v24 = v24;
              v14 = v24 | (16 * v14);
              --v16;
            }
            while (v16 > 1);
            *(_QWORD *)(d + 8 * v10) = v14;
            v11 -= 16;
            ++v10;
            v5 -= 16;
          }
          while (v10 != v13);
        }
        else
        {
          LODWORD(v13) = 0;
        }
        v9->top = v13;
        bn_correct_top((uint64_t *)v9);
        BN_set_negative(v9, v7);
        *a = v9;
        return v2;
      }
      if (!*a)
        BN_free(v9);
      return 0;
    }
  }
  return v2;
}

int BN_dec2bn(BIGNUM **a, const char *str)
{
  int v2;
  unsigned int v4;
  unint64_t v5;
  const char *v6;
  _BOOL4 v7;
  BIGNUM *v9;
  char v10;
  unint64_t v11;
  int v12;
  unsigned __int8 *v13;
  int v14;

  if (!str)
    return 0;
  v2 = *(unsigned __int8 *)str;
  if (*str)
  {
    v4 = 0;
    v5 = 0;
    v6 = v2 == 45 ? str + 1 : str;
    v7 = v2 == 45;
    while (v6[v5] - 48 <= 9)
    {
      ++v5;
      v4 += 4;
      if (v5 == 0x20000000)
        return 0;
    }
    v2 = v7 + v5;
    if (a)
    {
      v9 = *a;
      if (*a)
      {
        BN_zero((uint64_t)*a);
      }
      else
      {
        v9 = BN_new();
        if (!v9)
          return 0;
      }
      if (bn_expand((uint64_t)v9, v4))
      {
        v10 = *v6;
        if (*v6)
        {
          v11 = 0;
          v12 = 19 * (v5 / 0x13) - v5 + 19;
          if (19 * (v5 / 0x13) == (_DWORD)v5)
            v12 = 0;
          v13 = (unsigned __int8 *)(v6 + 1);
          do
          {
            v11 = 10 * v11 + v10 - 48;
            if (++v12 == 19)
            {
              if (!BN_mul_word(v9, 0x8AC7230489E80000) || !BN_add_word(v9, v11))
                goto LABEL_26;
              v11 = 0;
              v12 = 0;
            }
            v14 = *v13++;
            v10 = v14;
          }
          while (v14);
        }
        bn_correct_top((uint64_t *)v9);
        BN_set_negative(v9, v7);
        *a = v9;
        return v2;
      }
LABEL_26:
      if (!*a)
        BN_free(v9);
      return 0;
    }
  }
  return v2;
}

char *__cdecl BN_bn2dec(const BIGNUM *a)
{
  BIGNUM *v2;
  BIGNUM *v3;
  int v4;
  unint64_t v6;
  int v7;
  unint64_t v8;
  _QWORD v9[3];
  _OWORD v10[2];
  unsigned __int8 v11;
  uint64_t v12;
  char *v13;
  unint64_t v14;
  void *v15;

  v14 = 0;
  v15 = 0;
  v13 = 0;
  v12 = 0;
  v11 = 0;
  memset(v10, 0, sizeof(v10));
  memset(v9, 0, sizeof(v9));
  if (CBB_init((uint64_t)v10, 0))
  {
    v2 = BN_dup(a);
    v3 = v2;
    if (v2)
    {
      if (BN_is_zero((uint64_t)v2))
      {
LABEL_4:
        if (CBB_finish((uint64_t *)v10, &v15, &v14)
          && v14 <= 0xFFFFFFFFFFFFFFFCLL
          && CBB_init((uint64_t)v10, v14 + 3)
          && (!BN_is_negative((uint64_t)a) || CBB_add_u8((char **)v10, 0x2DuLL)))
        {
          CBS_init(v9, (uint64_t)v15, v14);
          if (CBS_len((uint64_t)v9))
          {
            if (CBS_get_last_u8(v9, &v11))
            {
              LOBYTE(v4) = 1;
              do
              {
                v4 = v4 & (v11 == 48);
                if (v4 == 1)
                {
                  if (!CBS_len((uint64_t)v9))
                    goto LABEL_27;
                }
                else
                {
                  if (!CBB_add_u8((char **)v10, v11))
                    break;
                  if (!CBS_len((uint64_t)v9))
                    goto LABEL_28;
                }
              }
              while (CBS_get_last_u8(v9, &v11));
            }
          }
          else
          {
LABEL_27:
            if (CBB_add_u8((char **)v10, 0x30uLL))
            {
LABEL_28:
              if (CBB_add_u8((char **)v10, 0))
                CBB_finish((uint64_t *)v10, &v13, &v12);
            }
          }
        }
      }
      else
      {
LABEL_21:
        v6 = BN_div_word(v3, 0x8AC7230489E80000);
        if (v6 != -1)
        {
          v7 = 19;
          while (1)
          {
            v8 = v6 / 0xA;
            if (!CBB_add_u8((char **)v10, (v6 % 0xA) | 0x30))
              break;
            v6 = v8;
            if (!--v7)
            {
              if (!BN_is_zero((uint64_t)v3))
                goto LABEL_21;
              goto LABEL_4;
            }
          }
        }
      }
    }
  }
  else
  {
    v3 = 0;
  }
  BN_free(v3);
  CBB_cleanup((uint64_t *)v10);
  freezero(v15, v14);
  return v13;
}

char *__cdecl BN_bn2hex(const BIGNUM *a)
{
  uint64_t top;
  int v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t i;
  _OWORD v8[2];
  uint64_t v9;
  char *v10;

  v9 = 0;
  v10 = 0;
  memset(v8, 0, sizeof(v8));
  if (CBB_init((uint64_t)v8, 0)
    && (!BN_is_negative((uint64_t)a) || CBB_add_u8((char **)v8, 0x2DuLL))
    && (!BN_is_zero((uint64_t)a) || CBB_add_u8((char **)v8, 0x30uLL)))
  {
    top = a->top;
    if ((int)top >= 1)
    {
      v3 = 0;
      do
      {
        v4 = top--;
        v5 = a->d[top];
        for (i = 56; i != -8; i -= 8)
        {
          if (v3 || (v5 >> i))
          {
            if (!CBB_add_u8((char **)v8, hex_digits[(unint64_t)(v5 >> i) >> 4])
              || !CBB_add_u8((char **)v8, hex_digits[(v5 >> i) & 0xF]))
            {
              goto LABEL_19;
            }
            v3 = 1;
          }
          else
          {
            v3 = 0;
          }
        }
      }
      while (v4 >= 2);
    }
    if (CBB_add_u8((char **)v8, 0))
      CBB_finish((uint64_t *)v8, &v10, &v9);
  }
LABEL_19:
  CBB_cleanup((uint64_t *)v8);
  return v10;
}

int BN_bn2mpi(const BIGNUM *a, unsigned __int8 *to)
{
  int v4;
  int v5;
  int v6;
  _BOOL4 v8;
  int v9;

  v4 = BN_num_bits(a);
  v5 = v4 + 7;
  if (v4 < -7)
    v5 = v4 + 14;
  v6 = v5 >> 3;
  v8 = (v4 & 7) == 0 && v4 > 0;
  if (to)
  {
    *(_DWORD *)to = bswap32(v6 + v8);
    if (v8)
      to[4] = 0;
    v6 = bn2binpad(a, (char *)&to[v8 | 4], 0xFFFFFFFFLL, 0);
    if (a->neg)
      to[4] |= 0x80u;
  }
  if (v8)
    v9 = 5;
  else
    v9 = 4;
  return v9 + v6;
}

BIGNUM *__cdecl BN_mpi2bn(const unsigned __int8 *s, int len, BIGNUM *ret)
{
  int v3;
  int v4;
  uint64_t v6;
  BIGNUM *v8;
  unsigned int v9;
  int v10;

  if (len <= 3)
  {
    v3 = 106;
    v4 = 580;
LABEL_11:
    ERR_put_error(3, 4095, v3, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/bn/bn_convert.c", v4);
    return 0;
  }
  v6 = bswap32(*(_DWORD *)s);
  if (v6 + 4 != len)
  {
    v3 = 104;
    v4 = 586;
    goto LABEL_11;
  }
  v8 = ret;
  if (ret || (v8 = BN_new()) != 0)
  {
    if (!v6)
    {
      v8->neg = 0;
      v8->top = 0;
      return v8;
    }
    v9 = s[4];
    if (!BN_bin2bn(s + 4, v6, v8))
    {
      if (!ret)
        BN_free(v8);
      return 0;
    }
    BN_set_negative(v8, v9 >> 7);
    if ((v9 & 0x80) != 0)
    {
      v10 = BN_num_bits(v8);
      BN_clear_bit(v8, v10 - 1);
    }
  }
  return v8;
}

int BN_print_fp(FILE *fp, const BIGNUM *a)
{
  BIO_METHOD *v4;
  BIO *v5;
  BIO *v6;
  int v7;

  v4 = BIO_s_file();
  v5 = BIO_new(v4);
  if (v5)
  {
    v6 = v5;
    BIO_ctrl(v5, 106, 0, fp);
    v7 = BN_print(v6, a);
    BIO_free(v6);
    LODWORD(v5) = v7;
  }
  return (int)v5;
}

int BN_print(BIO *fp, const BIGNUM *a)
{
  uint64_t top;
  int v5;
  uint64_t v6;
  uint64_t i;
  unint64_t v8;
  int result;

  if (a->neg && BIO_write(fp, "-", 1) != 1 || BN_is_zero((uint64_t)a) && BIO_write(fp, "0", 1) != 1)
    return 0;
  top = a->top;
  if ((int)top < 1)
    return 1;
  v5 = 0;
  do
  {
    v6 = top--;
    for (i = 60; i != -4; i -= 4)
    {
      v8 = (a->d[top] >> i) & 0xF;
      if (v5 || v8)
      {
        v5 = 1;
        if (BIO_write(fp, &hex_digits[v8], 1) != 1)
          return 0;
      }
      else
      {
        v5 = 0;
      }
    }
    result = 1;
  }
  while (v6 >= 2);
  return result;
}

uint64_t bn_isqrt(BIGNUM *a1, _BOOL4 *a2, const BIGNUM *a3, BN_CTX *a4)
{
  int v5;
  int v6;
  BN_CTX *v10;
  uint64_t v11;
  BIGNUM *v13;
  BIGNUM *v14;
  BIGNUM *v15;
  BIGNUM *v16;
  _BOOL4 v17;
  int v18;
  int v19;
  int v20;
  int v21;
  int v22;
  BOOL v23;
  int v24;

  if (!((unint64_t)a1 | (unint64_t)a2))
  {
    v5 = 67;
    v6 = 54;
LABEL_5:
    ERR_put_error(3, 4095, v5, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/bn/bn_isqrt.c", v6);
    v10 = 0;
LABEL_6:
    v11 = 0;
    goto LABEL_7;
  }
  if (BN_is_negative((uint64_t)a3))
  {
    v5 = 115;
    v6 = 59;
    goto LABEL_5;
  }
  v10 = a4;
  if (!a4)
  {
    v10 = BN_CTX_new();
    if (!v10)
      goto LABEL_6;
  }
  BN_CTX_start(v10);
  v13 = BN_CTX_get(v10);
  if (!v13)
    goto LABEL_6;
  v14 = v13;
  v15 = BN_CTX_get(v10);
  if (!v15)
    goto LABEL_6;
  v16 = v15;
  if (BN_is_zero((uint64_t)a3))
  {
    BN_zero((uint64_t)v14);
    v17 = 1;
    if (a2)
LABEL_16:
      *a2 = v17;
  }
  else
  {
    if (!BN_one((uint64_t)v14))
      goto LABEL_6;
    v18 = BN_num_bits(a3);
    v19 = v18 >= 1 ? v18 - 1 : v18;
    if (!BN_set_word(v16, (uint64_t)v19 >> 1))
      goto LABEL_6;
    v20 = v19 >> 1;
    v21 = BN_num_bits(v16);
    v22 = 0;
    while (1)
    {
      v23 = __OFSUB__(v21--, 1);
      if (v21 < 0 != v23)
        break;
      if (BN_rshift(v16, a3, ((2 * v20) | 1) - v22 - (v20 >> v21)))
      {
        if (BN_div_ct((uint64_t)v16, 0, v16, v14, v10))
        {
          if (BN_lshift(v14, v14, (v20 >> v21) + ~v22))
          {
            v22 = v20 >> v21;
            if (BN_add(v14, v14, v16))
              continue;
          }
        }
      }
      goto LABEL_6;
    }
    if (!BN_sqr(v16, v14, v10))
      goto LABEL_6;
    v24 = BN_cmp(v16, a3);
    if (v24 >= 1 && !BN_sub_word(v14, 1uLL))
      goto LABEL_6;
    v17 = v24 == 0;
    if (a2)
      goto LABEL_16;
  }
  if (a1 && !bn_copy(a1, v14))
    goto LABEL_6;
  v11 = 1;
LABEL_7:
  BN_CTX_end(v10);
  if (v10 != a4)
    BN_CTX_free(v10);
  return v11;
}

uint64_t bn_is_perfect_square(_BOOL4 *a1, const BIGNUM *a2, BN_CTX *a3)
{
  uint64_t v6;
  unint64_t v7;

  *a1 = 0;
  if (BN_is_negative((uint64_t)a2))
    return 1;
  if (a2->top)
    v6 = *a2->d & 0x3F;
  else
    LOBYTE(v6) = 0;
  if (((0xFDFDFDEDFDFCFDECLL >> v6) & 1) != 0)
    return 1;
  v7 = BN_mod_word(a2, 0xAFF5uLL);
  if (v7 != -1)
  {
    if (((0x7BFDB7CFEDBAFD6CuLL >> (v7 % 0x3F)) & 1) == 0
      && is_square_mod_65[v7 % 0x41]
      && ((0x5C4uLL >> (v7 % 0xB)) & 1) == 0)
    {
      return bn_isqrt(0, a1, a2, a3);
    }
    return 1;
  }
  return 0;
}

uint64_t ERR_load_CMS_strings()
{
  if (!ERR_func_error_string(CMS_str_functs))
  {
    ERR_load_strings(46, (ERR_STRING_DATA *)&CMS_str_functs);
    ERR_load_strings(46, (ERR_STRING_DATA *)&CMS_str_reasons);
  }
  return 1;
}

int SHA1_Update(SHA_CTX *c, const void *data, size_t len)
{
  size_t v3;
  unsigned int *v4;
  uint64_t num;
  unsigned int *v7;
  char *v8;
  uint64_t v9;

  if (len)
  {
    v3 = len;
    v4 = (unsigned int *)data;
    *(_QWORD *)&c->Nl += 8 * len;
    num = c->num;
    if ((_DWORD)num)
    {
      v7 = c->data;
      v8 = (char *)c->data + num;
      if (len <= 0x3F && num + len < 0x40)
      {
        memcpy(v8, data, len);
        c->num += v3;
        return 1;
      }
      v9 = 64 - num;
      memcpy(v8, data, 64 - num);
      sha1_block_data_order((int *)c, c->data, 1);
      v4 = (unsigned int *)((char *)v4 + v9);
      v3 -= v9;
      c->num = 0;
      *(_OWORD *)v7 = 0u;
      *(_OWORD *)&c->data[4] = 0u;
      *(_OWORD *)&c->data[8] = 0u;
      *(_OWORD *)&c->data[12] = 0u;
    }
    if (v3 >= 0x40)
    {
      sha1_block_data_order((int *)c, v4, v3 >> 6);
      v4 = (unsigned int *)((char *)v4 + (v3 & 0xFFFFFFFFFFFFFFC0));
      v3 &= 0x3Fu;
    }
    if (v3)
    {
      c->num = v3;
      memcpy(c->data, v4, v3);
    }
  }
  return 1;
}

uint64_t sha1_block_data_order(int *a1, unsigned int *a2, uint64_t a3)
{
  int v3;
  int v4;
  int v5;
  int v6;
  int v7;
  int v8;
  unint64_t v9;
  int v10;
  unsigned int v11;
  int v12;
  int v13;
  int v14;
  int v15;
  int v16;
  unsigned int v17;
  unsigned int v18;
  int v19;
  int v20;
  int v21;
  unsigned int v22;
  int v23;
  int v24;
  unsigned int v25;
  unsigned int v26;
  int v27;
  unint64_t v28;
  int v29;
  unsigned int v30;
  int v31;
  int v32;
  unint64_t v33;
  int v34;
  unsigned int v35;
  unsigned int v36;
  int v37;
  int v38;
  unint64_t v39;
  int v40;
  int v41;
  unint64_t v42;
  unsigned int v43;
  int v44;
  int v45;
  int v46;
  int v47;
  int v48;
  unsigned int v49;
  int v50;
  unint64_t v51;
  int v52;
  int v53;
  unsigned int v54;
  int v55;
  int v56;
  unint64_t v57;
  int v58;
  unsigned int v59;
  unsigned int v60;
  int v61;
  int v62;
  int v63;
  int v64;
  unint64_t v65;
  unsigned int v66;
  int v67;
  int v68;
  int v69;
  int v70;
  unsigned int v71;
  int v72;
  unsigned int v73;
  int v74;
  unint64_t v75;
  unsigned int v76;
  int v77;
  int v78;
  unsigned int v79;
  int v80;
  unint64_t v81;
  int v82;
  int v83;
  unsigned int v84;
  int v85;
  int v86;
  unsigned int v87;
  unsigned int v88;
  int v89;
  int v90;
  unint64_t v91;
  unsigned int v92;
  int v93;
  int v94;
  int v95;
  int v96;
  int v97;
  int v98;
  int v99;
  int v100;
  unsigned int v101;
  int v102;
  int v103;
  unint64_t v104;
  int v105;
  int v106;
  unsigned int v107;
  int v108;
  int v109;
  unint64_t v110;
  int v111;
  unsigned int v112;
  int v113;
  int v114;
  int v115;
  int v116;
  int v117;
  unint64_t v118;
  int v119;
  unsigned int v120;
  int v121;
  unsigned int v122;
  int v123;
  int v124;
  unint64_t v125;
  int v126;
  int v127;
  int v128;
  int v129;
  int v130;
  int v131;
  int v132;
  int v133;
  int v134;
  int v135;
  int v136;
  int v137;
  int v138;
  unsigned int v139;
  int v140;
  int v141;
  unint64_t v142;
  int v143;
  unsigned int v144;
  int v145;
  unint64_t v146;
  int v147;
  int v148;
  int v149;
  int v150;
  int v151;
  unsigned int v152;
  int v153;
  int v154;
  int v155;
  int v156;
  unint64_t v157;
  unsigned int v158;
  int v159;
  int v160;
  int v161;
  unint64_t v162;
  int v163;
  int v164;
  int v165;
  unint64_t v166;
  int v167;
  int v168;
  int v169;
  int v170;
  unsigned int v171;
  int v172;
  unint64_t v173;
  unsigned int v174;
  int v175;
  unsigned int v176;
  int v177;
  int v178;
  unint64_t v179;
  int v180;
  unsigned int v181;
  int v182;
  int v183;
  int v184;
  unint64_t v185;
  int v186;
  int v187;
  unsigned int v188;
  int v189;
  int v190;
  unint64_t v191;
  int v192;
  unsigned int v193;
  int v194;
  int v195;
  int v196;
  int v197;
  int v198;
  unint64_t v199;
  int v200;
  unsigned int v201;
  int v202;
  int v203;
  unint64_t v204;
  int v205;
  unsigned int v206;
  int v207;
  int v208;
  unint64_t v209;
  int v210;
  int v211;
  unsigned int v212;
  int v213;
  int v214;
  unint64_t v215;
  int v216;
  unsigned int v217;
  int v218;
  int v219;
  int v220;
  unint64_t v221;
  int v222;
  int v223;
  unsigned int v224;
  int v225;
  int v226;
  unint64_t v227;
  int v228;
  unsigned int v229;
  int v230;
  int v231;
  int v232;
  int v233;
  unint64_t v234;
  int v235;
  unsigned int v236;
  int v237;
  int v238;
  unint64_t v239;
  int v240;
  unsigned int v241;
  int v242;
  int v243;
  unint64_t v244;
  int v245;
  int v246;
  unsigned int v247;
  int v248;
  int v249;
  int v250;
  unint64_t v251;
  int v252;
  unsigned int v253;
  int v254;
  unint64_t v255;
  int v256;
  int v257;
  int v258;
  int v259;
  unint64_t v260;
  int v261;
  int v262;
  int v263;
  unint64_t v264;
  unsigned int v265;
  unint64_t v266;
  int v267;
  int v268;
  int v269;
  int v270;
  unint64_t v271;
  int v272;
  int v273;
  int v274;
  int v275;
  int v276;
  unint64_t v277;
  int v278;
  int v279;
  int v280;
  int v281;
  int v282;
  int v283;
  int v284;
  unint64_t v285;
  int v286;
  int v287;
  int v288;
  int v289;
  unint64_t v290;
  int v291;
  int v292;
  int v293;
  unsigned int v294;
  int v295;
  int v296;
  unint64_t v297;
  int v298;
  int v299;
  int v300;
  int v301;
  int v302;
  unint64_t v303;
  int v304;
  int v305;
  int v306;
  unint64_t v307;
  unsigned int v308;
  unint64_t v309;
  int v310;
  int v311;
  int v312;
  unint64_t v313;
  int v314;
  int v315;
  int v316;
  int v317;
  int v318;
  unint64_t v319;
  int v320;
  int v321;
  int v322;
  int v323;
  int v324;
  int v325;
  int v326;
  int v327;
  unint64_t v328;
  int v329;
  int v330;
  int v331;
  int v332;
  unint64_t v333;
  int v334;
  int v335;
  unsigned int v336;
  int v337;
  int v338;
  unint64_t v339;
  int v340;
  int v341;
  int v342;
  int v343;
  int v344;
  unint64_t v345;
  int v346;
  int v347;
  int v348;
  int v349;
  unint64_t v350;
  unsigned int v351;
  unint64_t v352;
  int v353;
  int v354;
  int v355;
  int v356;
  unint64_t v357;
  int v358;
  int v359;
  int v360;
  int v361;
  int v362;
  unint64_t v363;
  int v364;
  int v365;
  int v366;
  int v367;
  int v368;
  int v369;
  int v370;
  unint64_t v371;
  int v372;
  int v373;
  int v374;
  int v375;
  unint64_t v376;
  int v377;
  int v378;
  unsigned int v379;
  int v380;
  int v381;
  unint64_t v382;
  int v383;
  int v384;
  int v385;
  int v386;
  unint64_t v387;
  int v388;
  int v389;
  int v390;
  int v391;
  unint64_t v392;
  int v393;
  int v394;
  int v395;
  int v396;
  int v397;
  unsigned int v398;
  int v399;
  int v400;
  unint64_t v401;
  unsigned int v402;
  int v403;
  int v404;
  int v405;
  int v406;
  unint64_t v407;
  int v408;
  unsigned int v409;
  int v410;
  int v411;
  int v412;
  unint64_t v413;
  int v414;
  unsigned int v415;
  int v416;
  unsigned int v417;
  int v418;
  int v419;
  unint64_t v420;
  unsigned int v421;
  int v422;
  int v423;
  int v424;
  unint64_t v425;
  int v426;
  int v427;
  int v428;
  unint64_t v429;
  int v430;
  int v431;
  int v432;
  int v433;
  unsigned int v434;
  int v435;
  int v436;
  int v437;
  unint64_t v438;
  int v439;
  unsigned int v440;
  int v441;
  int v442;
  int v443;
  unint64_t v444;
  int v445;
  unsigned int v446;
  int v447;
  int v448;
  int v449;
  unint64_t v450;
  int v451;
  unsigned int v452;
  int v453;
  int v454;
  int v455;
  unint64_t v456;
  int v457;
  unsigned int v458;
  int v459;
  int v460;
  int v461;
  unint64_t v462;
  int v463;
  int v464;
  int v465;
  unint64_t v466;
  int v467;
  int v468;
  int v469;
  int v470;
  int v471;
  unsigned int v472;
  int v473;
  int v474;
  int v475;
  unint64_t v476;
  int v477;
  unsigned int v478;
  int v479;
  int v480;
  int v481;
  unint64_t v482;
  int v483;
  int v484;
  unsigned int v485;
  int v486;
  int v487;
  int v488;
  unint64_t v489;
  int v490;
  unsigned int v491;
  int v492;
  int v493;
  int v494;
  int v495;
  unint64_t v496;
  unsigned int v497;
  int v498;
  int v499;
  int v500;
  unint64_t v501;
  int v502;
  unsigned int v503;
  uint64_t result;
  int v505;
  int v506;
  int v507;
  unint64_t v508;
  unsigned int v509;
  int v510;
  int v511;
  unint64_t v512;
  int v513;
  unsigned int v514;
  int v515;
  int v516;
  unint64_t v517;
  int v518;
  int v520;
  unsigned int v521;
  int v522;
  int v523;
  int v524;
  int v525;
  unsigned int v526;
  int v527;
  int v528;
  int v529;
  int v530;
  int v531;
  unsigned int v532;
  int v533;
  int v534;
  int v535;
  int v536;
  int v537;
  unsigned int v538;
  int v539;
  int v540;
  int v541;
  unsigned int v542;
  int v543;
  int v544;
  int v545;
  int v546;
  unsigned int *v547;
  uint64_t v548;
  int v549;
  int v550;
  int v551;

  v3 = a1[3];
  v4 = a1[4];
  v5 = a1[1];
  v6 = a1[2];
  v7 = *a1;
  do
  {
    v550 = v3;
    v551 = v5;
    v549 = v6;
    v545 = v7;
    v546 = v4;
    v547 = a2;
    v548 = a3;
    HIDWORD(v9) = v7;
    LODWORD(v9) = v7;
    v8 = v9 >> 27;
    v10 = v3 & ~v5;
    v11 = bswap32(*a2);
    v12 = v6 & v5;
    HIDWORD(v9) = v5;
    LODWORD(v9) = v5;
    v13 = v9 >> 2;
    v14 = v12 | v10;
    v15 = v7;
    v16 = v7 & __ROR4__(v5, 2);
    v17 = bswap32(a2[1]);
    v18 = v4 + 1518500249 + v8 + v14 + v11;
    HIDWORD(v9) = v18;
    LODWORD(v9) = v18;
    v19 = v9 >> 27;
    HIDWORD(v9) = v15;
    LODWORD(v9) = v15;
    v20 = v9 >> 2;
    v21 = v18 & __ROR4__(v15, 2);
    v22 = v550 + 1518500249 + (v16 | v549 & ~v15) + v17 + v19;
    HIDWORD(v9) = v22;
    LODWORD(v9) = v22;
    v23 = v9 >> 27;
    HIDWORD(v9) = v18;
    LODWORD(v9) = v18;
    v24 = v9 >> 2;
    v25 = bswap32(a2[2]);
    v26 = bswap32(a2[3]);
    v28 = __PAIR64__(v22, __ROR4__(v18, 2));
    v27 = v22 & v28;
    LODWORD(v28) = v22;
    v29 = v28 >> 2;
    v30 = v549 + 1518500249 + v25 + (v21 | v13 & ~v18) + v23;
    HIDWORD(v28) = v30;
    LODWORD(v28) = v30;
    v31 = v28 >> 27;
    v33 = __PAIR64__(v30, __ROR4__(v22, 2));
    v32 = v30 & v33;
    v542 = bswap32(a2[4]);
    LODWORD(v33) = v30;
    v34 = v33 >> 2;
    v35 = v13 + 1518500249 + v26 + (v27 | v20 & ~v22) + v31;
    HIDWORD(v33) = v35;
    LODWORD(v33) = v35;
    v36 = v20 + 1518500249 + v542 + (v32 | v24 & ~v30) + (v33 >> 27);
    HIDWORD(v33) = v36;
    LODWORD(v33) = v36;
    v37 = v33 >> 27;
    v39 = __PAIR64__(v35, __ROR4__(v30, 2));
    v38 = v35 & v39;
    LODWORD(v39) = v35;
    v40 = v39 >> 2;
    v42 = __PAIR64__(v36, __ROR4__(v35, 2));
    v41 = v36 & v42;
    v43 = bswap32(a2[5]);
    v44 = v38 | v29 & ~v35;
    LODWORD(v42) = v36;
    v45 = v42 >> 2;
    v46 = v24 + 1518500249 + v43 + v44 + v37;
    HIDWORD(v42) = v46;
    LODWORD(v42) = v46;
    v47 = v42 >> 27;
    v532 = bswap32(a2[6]);
    HIDWORD(v42) = v46;
    LODWORD(v42) = v46;
    v48 = v42 >> 2;
    v49 = v29 + 1518500249 + v532 + (v41 | v34 & ~v36) + v47;
    HIDWORD(v42) = v49;
    LODWORD(v42) = v49;
    v50 = v42 >> 27;
    v51 = __PAIR64__(v49, __ROR4__(v36, 2));
    v538 = bswap32(a2[7]);
    v52 = v46 & v51 | v40 & ~v46;
    LODWORD(v51) = v49;
    v53 = v51 >> 2;
    v54 = v34 + 1518500249 + v538 + v52 + v50;
    HIDWORD(v51) = v54;
    LODWORD(v51) = v54;
    v55 = v51 >> 27;
    v57 = __PAIR64__(v54, __ROR4__(v49, 2));
    v56 = v54 & v57;
    LODWORD(v57) = v54;
    v58 = v57 >> 2;
    v526 = bswap32(a2[8]);
    v59 = v40 + 1518500249 + v526 + (v49 & __ROR4__(v46, 2) | v45 & ~v49) + v55;
    v60 = bswap32(a2[13]);
    HIDWORD(v57) = v59;
    LODWORD(v57) = v59;
    v61 = v57 >> 27;
    HIDWORD(v57) = v25 ^ v11 ^ v526 ^ v60;
    LODWORD(v57) = HIDWORD(v57);
    v62 = v57 >> 31;
    v63 = HIDWORD(v57);
    v520 = HIDWORD(v57);
    v65 = __PAIR64__(v59, __ROR4__(v54, 2));
    v64 = v59 & v65;
    v66 = bswap32(a2[9]);
    v67 = v56 | v48 & ~v54;
    LODWORD(v65) = v59;
    v68 = v65 >> 2;
    v69 = v45 + 1518500249 + v66 + v67 + v61;
    HIDWORD(v65) = v69;
    LODWORD(v65) = v69;
    v70 = v65 >> 27;
    v71 = bswap32(a2[10]);
    HIDWORD(v65) = v69;
    LODWORD(v65) = v69;
    v72 = v65 >> 2;
    v73 = v48 + 1518500249 + v71 + (v64 | v53 & ~v59) + v70;
    HIDWORD(v65) = v73;
    LODWORD(v65) = v73;
    v74 = v65 >> 27;
    v75 = __PAIR64__(v73, __ROR4__(v59, 2));
    v76 = bswap32(a2[11]);
    v77 = v69 & v75 | v58 & ~v69;
    LODWORD(v75) = v73;
    v78 = v75 >> 2;
    v79 = v53 + 1518500249 + v76 + v77 + v74;
    HIDWORD(v75) = v79;
    LODWORD(v75) = v79;
    v80 = v75 >> 27;
    v81 = __PAIR64__(v79, __ROR4__(v69, 2));
    v82 = v73 & v81 | v68 & ~v73;
    LODWORD(v81) = v79;
    v83 = v81 >> 2;
    v521 = bswap32(a2[12]);
    v84 = v58 + 1518500249 + v521 + v82 + v80;
    HIDWORD(v81) = v84;
    LODWORD(v81) = v84;
    v85 = v81 >> 27;
    v86 = v79 & __ROR4__(v73, 2);
    v87 = a2[15];
    v88 = bswap32(a2[14]);
    v89 = v72 & ~v79;
    v91 = __PAIR64__(v84, __ROR4__(v79, 2));
    v90 = v84 & v91;
    v92 = v60;
    v93 = v68 + 1518500249 + v60 + (v86 | v89);
    LODWORD(v91) = v84;
    v94 = v91 >> 2;
    v95 = v93 + v85;
    v96 = v26 ^ v17 ^ v66 ^ v88;
    HIDWORD(v91) = v95;
    LODWORD(v91) = v95;
    v97 = v91 >> 27;
    HIDWORD(v91) = v96;
    LODWORD(v91) = v96;
    v529 = v91 >> 31;
    HIDWORD(v91) = v95;
    LODWORD(v91) = v95;
    v98 = v91 >> 2;
    v99 = v72 + 1518500249 + v88 + (v90 | v78 & ~v84) + v97;
    HIDWORD(v91) = v99;
    LODWORD(v91) = v99;
    v100 = v91 >> 27;
    v101 = bswap32(v87);
    v102 = v542 ^ v25 ^ v71 ^ v101;
    v104 = __PAIR64__(v102, __ROR4__(v95, 2));
    v103 = v99 & v104;
    LODWORD(v104) = v102;
    v524 = v104 >> 31;
    v105 = v95 & __ROR4__(v84, 2) | v83 & ~v95;
    HIDWORD(v104) = v99;
    LODWORD(v104) = v99;
    v106 = v104 >> 2;
    v107 = v78 + 1518500249 + v101 + v105 + v100;
    HIDWORD(v104) = v107;
    LODWORD(v104) = v107;
    v108 = v104 >> 27;
    v110 = __PAIR64__(v107, __ROR4__(v99, 2));
    v109 = v107 & v110;
    LODWORD(v110) = v107;
    v111 = v110 >> 2;
    v112 = v83 + v62 + 1518500249 + (v103 | v94 & ~v99) + v108;
    HIDWORD(v110) = v112;
    LODWORD(v110) = v112;
    v113 = v110 >> 27;
    LODWORD(v110) = v43 ^ v26 ^ v76 ^ __ROR4__(v63, 31);
    v114 = v110;
    HIDWORD(v110) = v110;
    v115 = v110 >> 31;
    v116 = v112 & __ROR4__(v107, 2);
    v118 = __PAIR64__(v112, __ROR4__(v96, 31));
    v117 = v532 ^ v542 ^ v521 ^ v118;
    LODWORD(v118) = v112;
    v119 = v118 >> 2;
    v120 = v94 + v529 + 1518500249 + (v109 | v98 & ~v107) + v113;
    HIDWORD(v118) = v120;
    LODWORD(v118) = v120;
    v121 = v118 >> 27;
    HIDWORD(v118) = v117;
    LODWORD(v118) = v117;
    v535 = v118 >> 31;
    v122 = v92;
    v123 = v538 ^ v43 ^ v92 ^ __ROR4__(v102, 31);
    v125 = __PAIR64__(v120, __ROR4__(v112, 2));
    v124 = v120 & v125;
    LODWORD(v125) = v120;
    v126 = v125 >> 2;
    v127 = v98 + v524 + 1518500249 + (v116 | v106 & ~v112) + v121;
    v128 = v124 | v111 & ~v120;
    HIDWORD(v125) = v127;
    LODWORD(v125) = v127;
    v129 = v125 >> 27;
    HIDWORD(v125) = v123;
    LODWORD(v125) = v123;
    v522 = v125 >> 31;
    v130 = v115 + 1518500249 + v106;
    HIDWORD(v125) = v127;
    LODWORD(v125) = v127;
    v131 = v125 >> 2;
    v132 = v130 + v128 + v129;
    HIDWORD(v125) = v132;
    LODWORD(v125) = v132;
    v133 = v125 >> 27;
    HIDWORD(v125) = v132;
    LODWORD(v125) = v132;
    v134 = v125 >> 2;
    v136 = v535 + 1859775393 + v111 + (v126 ^ __ROR4__(v112, 2) ^ v127);
    LODWORD(v125) = v526 ^ v532 ^ v88 ^ __ROR4__(v114, 31);
    v135 = v125;
    HIDWORD(v125) = v125;
    v137 = v125 >> 31;
    v138 = v134 ^ __ROR4__(v127, 2);
    v139 = v136 + v133;
    HIDWORD(v125) = v139;
    LODWORD(v125) = v139;
    v140 = v125 >> 27;
    v142 = __PAIR64__(v139, __ROR4__(v117, 31));
    v141 = v66 ^ v538 ^ v101 ^ v142;
    LODWORD(v142) = v139;
    v143 = v142 >> 2;
    v144 = v522 + 1859775393 + v119 + (v131 ^ __ROR4__(v120, 2) ^ v132) + v140;
    HIDWORD(v142) = v141;
    LODWORD(v142) = v141;
    v539 = v142 >> 31;
    v146 = __PAIR64__(v144, __ROR4__(v132, 2));
    v145 = v143 ^ v146;
    v147 = v137 + 1859775393 + v126 + (v138 ^ v139);
    v148 = v539 + 1859775393 + v131;
    LODWORD(v146) = v144;
    v149 = v146 >> 27;
    HIDWORD(v146) = v144;
    LODWORD(v146) = v144;
    v150 = v146 >> 2;
    v152 = v147 + v149;
    LODWORD(v146) = v71 ^ v526 ^ __ROR4__(v520, 31) ^ __ROR4__(v123, 31);
    v151 = v146;
    HIDWORD(v146) = v146;
    v153 = v146 >> 31;
    v154 = v148 + (v145 ^ v144);
    HIDWORD(v146) = v152;
    LODWORD(v146) = v152;
    v155 = v146 >> 27;
    v157 = __PAIR64__(v152, __ROR4__(v139, 2));
    v156 = v150 ^ v157;
    v158 = v154 + v155;
    v159 = v153 + 1859775393 + v134;
    LODWORD(v157) = v152;
    v160 = v157 >> 2;
    v162 = __PAIR64__(v158, __ROR4__(v96, 31));
    v161 = v76 ^ v66 ^ v162;
    LODWORD(v162) = v158;
    v163 = v159 + (v156 ^ v152) + (v162 >> 27);
    LODWORD(v162) = v161 ^ __ROR4__(v135, 31);
    v164 = v162;
    HIDWORD(v162) = v162;
    v165 = v162 >> 31;
    v166 = __PAIR64__(v158, __ROR4__(v144, 2));
    v167 = v160 ^ v166 ^ v158;
    v168 = v165 + 1859775393 + v143;
    LODWORD(v166) = v158;
    v169 = v166 >> 2;
    LODWORD(v166) = v521 ^ v71 ^ __ROR4__(v102, 31) ^ __ROR4__(v141, 31);
    v170 = v166;
    HIDWORD(v166) = v166;
    v543 = v166 >> 31;
    HIDWORD(v166) = v163;
    LODWORD(v166) = v163;
    v171 = v168 + v167 + (v166 >> 27);
    v173 = __PAIR64__(v171, __ROR4__(v152, 2));
    v172 = v169 ^ v173;
    LODWORD(v173) = v171;
    v174 = v122;
    v176 = v543 + 1859775393 + v150 + (v172 ^ v163) + (v173 >> 27);
    LODWORD(v173) = v122 ^ v76 ^ __ROR4__(v114, 31) ^ __ROR4__(v151, 31);
    v175 = v173;
    HIDWORD(v173) = v173;
    v177 = v173 >> 31;
    HIDWORD(v173) = v163;
    LODWORD(v173) = v163;
    v178 = v173 >> 2;
    v179 = __PAIR64__(v176, __ROR4__(v158, 2));
    v180 = v177 + 1859775393 + v160 + (v178 ^ v179 ^ v171);
    LODWORD(v179) = v176;
    v181 = v180 + (v179 >> 27);
    LODWORD(v179) = v88 ^ v521 ^ __ROR4__(v117, 31) ^ __ROR4__(v164, 31);
    v182 = v179;
    HIDWORD(v179) = v179;
    v183 = (v179 >> 31) + 1859775393 + v169;
    HIDWORD(v179) = v171;
    LODWORD(v179) = v171;
    v184 = v179 >> 2;
    v185 = __PAIR64__(v181, __ROR4__(v163, 2));
    v186 = v183 + (v184 ^ v185 ^ v176);
    LODWORD(v185) = v181;
    v187 = v101 ^ v174 ^ __ROR4__(v123, 31) ^ __ROR4__(v170, 31);
    v188 = v186 + (v185 >> 27);
    HIDWORD(v185) = v187;
    LODWORD(v185) = v187;
    v533 = v185 >> 31;
    v189 = v533 + 1859775393 + v178;
    HIDWORD(v185) = v176;
    LODWORD(v185) = v176;
    v190 = v185 >> 2;
    v191 = __PAIR64__(v188, __ROR4__(v171, 2));
    v192 = v189 + (v190 ^ v191 ^ v181);
    LODWORD(v191) = v188;
    v193 = v192 + (v191 >> 27);
    v194 = v88 ^ __ROR4__(v520, 31) ^ __ROR4__(v135, 31) ^ __ROR4__(v175, 31);
    HIDWORD(v191) = v194;
    LODWORD(v191) = v194;
    v195 = v191 >> 31;
    HIDWORD(v191) = v181;
    LODWORD(v191) = v181;
    v196 = v191 >> 2;
    v197 = v195 + 1859775393 + v184 + (v196 ^ __ROR4__(v176, 2) ^ v188);
    v199 = __PAIR64__(v193, __ROR4__(v96, 31));
    v198 = v101 ^ v199;
    LODWORD(v199) = v193;
    v200 = v198 ^ __ROR4__(v141, 31) ^ __ROR4__(v182, 31);
    v201 = v197 + (v199 >> 27);
    HIDWORD(v199) = v200;
    LODWORD(v199) = v200;
    v202 = (v199 >> 31) + 1859775393 + v190;
    HIDWORD(v199) = v188;
    LODWORD(v199) = v188;
    v203 = v199 >> 2;
    v204 = __PAIR64__(v201, __ROR4__(v181, 2));
    v205 = v202 + (v203 ^ v204 ^ v193);
    LODWORD(v204) = v201;
    v206 = v205 + (v204 >> 27);
    LODWORD(v204) = v524 ^ __ROR4__(v520, 31) ^ __ROR4__(v151, 31) ^ __ROR4__(v187, 31);
    v207 = v204;
    HIDWORD(v204) = v204;
    v527 = v204 >> 31;
    HIDWORD(v204) = v193;
    LODWORD(v204) = v193;
    v208 = v204 >> 2;
    v209 = __PAIR64__(v206, __ROR4__(v188, 2));
    v210 = v527 + 1859775393 + v196 + (v208 ^ v209 ^ v201);
    LODWORD(v209) = v206;
    v211 = v529 ^ __ROR4__(v114, 31) ^ __ROR4__(v164, 31) ^ __ROR4__(v194, 31);
    v212 = v210 + (v209 >> 27);
    HIDWORD(v209) = v211;
    LODWORD(v209) = v211;
    v213 = v209 >> 31;
    HIDWORD(v209) = v201;
    LODWORD(v209) = v201;
    v214 = v209 >> 2;
    v215 = __PAIR64__(v212, __ROR4__(v193, 2));
    v216 = v213 + 1859775393 + v203 + (v214 ^ v215 ^ v206);
    LODWORD(v215) = v212;
    v217 = v216 + (v215 >> 27);
    LODWORD(v215) = v524 ^ __ROR4__(v117, 31) ^ __ROR4__(v170, 31) ^ __ROR4__(v200, 31);
    v218 = v215;
    HIDWORD(v215) = v215;
    v219 = (v215 >> 31) + 1859775393 + v208;
    HIDWORD(v215) = v206;
    LODWORD(v215) = v206;
    v220 = v215 >> 2;
    v221 = __PAIR64__(v217, __ROR4__(v201, 2));
    v222 = v219 + (v220 ^ v221 ^ v212);
    LODWORD(v221) = v217;
    v223 = v522 ^ __ROR4__(v114, 31) ^ __ROR4__(v175, 31) ^ __ROR4__(v207, 31);
    v224 = v222 + (v221 >> 27);
    HIDWORD(v221) = v223;
    LODWORD(v221) = v223;
    v530 = v221 >> 31;
    v225 = v530 + 1859775393 + v214;
    HIDWORD(v221) = v212;
    LODWORD(v221) = v212;
    v226 = v221 >> 2;
    v227 = __PAIR64__(v224, __ROR4__(v206, 2));
    v228 = v225 + (v226 ^ v227 ^ v217);
    LODWORD(v227) = v224;
    v229 = v228 + (v227 >> 27);
    v230 = v535 ^ __ROR4__(v135, 31) ^ __ROR4__(v182, 31) ^ __ROR4__(v211, 31);
    HIDWORD(v227) = v230;
    LODWORD(v227) = v230;
    v525 = v227 >> 31;
    v231 = v525 + 1859775393 + v220;
    HIDWORD(v227) = v217;
    LODWORD(v227) = v217;
    v232 = v227 >> 2;
    v234 = __PAIR64__(v229, __ROR4__(v141, 31));
    v233 = v522 ^ v234;
    LODWORD(v234) = v229;
    v236 = v231 + (v232 ^ __ROR4__(v212, 2) ^ v224) + (v234 >> 27);
    LODWORD(v234) = v233 ^ __ROR4__(v187, 31) ^ __ROR4__(v218, 31);
    v235 = v234;
    HIDWORD(v234) = v234;
    v237 = (v234 >> 31) + 1859775393 + v226;
    HIDWORD(v234) = v224;
    LODWORD(v234) = v224;
    v238 = v234 >> 2;
    v239 = __PAIR64__(v236, __ROR4__(v217, 2));
    v240 = v237 + (v238 ^ v239 ^ v229);
    LODWORD(v239) = v236;
    v241 = v240 + (v239 >> 27);
    LODWORD(v239) = v153 ^ __ROR4__(v135, 31) ^ __ROR4__(v194, 31) ^ __ROR4__(v223, 31);
    v242 = v239;
    HIDWORD(v239) = v239;
    v536 = v239 >> 31;
    HIDWORD(v239) = v229;
    LODWORD(v239) = v229;
    v243 = v239 >> 2;
    v244 = __PAIR64__(v241, __ROR4__(v224, 2));
    v245 = v536 + 1859775393 + v232 + (v243 ^ v244 ^ v236);
    LODWORD(v244) = v241;
    v246 = v539 ^ __ROR4__(v164, 31) ^ __ROR4__(v200, 31) ^ __ROR4__(v230, 31);
    v247 = v245 + (v244 >> 27);
    HIDWORD(v244) = v246;
    LODWORD(v244) = v246;
    v248 = v244 >> 31;
    v249 = v248 + 1859775393 + v238;
    HIDWORD(v244) = v236;
    LODWORD(v244) = v236;
    v250 = v244 >> 2;
    v251 = __PAIR64__(v247, __ROR4__(v229, 2));
    v252 = v249 + (v250 ^ v251 ^ v241);
    LODWORD(v251) = v247;
    v253 = v252 + (v251 >> 27);
    v254 = v153 ^ __ROR4__(v170, 31) ^ __ROR4__(v207, 31) ^ __ROR4__(v235, 31);
    v255 = __PAIR64__(v254, __ROR4__(v241, 2));
    v256 = (v247 | __ROR4__(v241, 2)) & __ROR4__(v236, 2) | v247 & v255;
    LODWORD(v255) = v254;
    v257 = (v255 >> 31) - 1894007588;
    HIDWORD(v255) = v241;
    LODWORD(v255) = v241;
    v258 = v255 >> 2;
    v260 = __PAIR64__(v253, __ROR4__(v211, 31));
    v259 = v177 ^ __ROR4__(v164, 31) ^ v260;
    LODWORD(v260) = v253;
    v261 = v260 >> 27;
    v262 = v259 ^ __ROR4__(v242, 31);
    v264 = __PAIR64__(v262, __ROR4__(v241, 2));
    v263 = (v253 | __ROR4__(v247, 2)) & v264;
    LODWORD(v264) = v262;
    v540 = v264 >> 31;
    v265 = v257 + v243 + v256 + v261;
    v266 = __PAIR64__(v265, __ROR4__(v247, 2));
    v267 = v263 | v253 & v266;
    LODWORD(v266) = v265;
    v268 = v540 - 1894007588 + v250 + v267;
    v269 = v543 ^ __ROR4__(v182, 31) ^ __ROR4__(v218, 31) ^ __ROR4__(v246, 31);
    v270 = v268 + (v266 >> 27);
    v271 = __PAIR64__(v269, __ROR4__(v247, 2));
    v272 = (v265 | __ROR4__(v253, 2)) & v271 | v265 & __ROR4__(v253, 2);
    LODWORD(v271) = v269;
    v273 = v271 >> 31;
    HIDWORD(v271) = v247;
    LODWORD(v271) = v247;
    v274 = v271 >> 2;
    HIDWORD(v271) = v270;
    LODWORD(v271) = v270;
    v275 = v273 - 1894007588 + v258 + v272 + (v271 >> 27);
    v276 = v177 ^ __ROR4__(v187, 31) ^ __ROR4__(v223, 31) ^ __ROR4__(v254, 31);
    v277 = __PAIR64__(v276, __ROR4__(v253, 2));
    v278 = (v270 | __ROR4__(v265, 2)) & v277 | v270 & __ROR4__(v265, 2);
    LODWORD(v277) = v276;
    v279 = v277 >> 31;
    HIDWORD(v277) = v253;
    LODWORD(v277) = v253;
    v280 = v277 >> 2;
    v281 = v279 - 1894007588 + v274;
    HIDWORD(v277) = v275;
    LODWORD(v277) = v275;
    v282 = v277 >> 27;
    LODWORD(v277) = v195 ^ __ROR4__(v182, 31) ^ __ROR4__(v230, 31) ^ __ROR4__(v262, 31);
    v283 = v277;
    HIDWORD(v277) = v277;
    v544 = v277 >> 31;
    v284 = v281 + v278 + v282;
    v285 = __PAIR64__(v265, __ROR4__(v265, 2));
    v286 = (v275 | __ROR4__(v270, 2)) & v285 | v275 & __ROR4__(v270, 2);
    LODWORD(v285) = v265;
    v287 = v285 >> 2;
    HIDWORD(v285) = v284;
    LODWORD(v285) = v284;
    v288 = v544 - 1894007588 + v280 + v286 + (v285 >> 27);
    v289 = v533 ^ __ROR4__(v200, 31) ^ __ROR4__(v235, 31) ^ __ROR4__(v269, 31);
    v290 = __PAIR64__(v289, __ROR4__(v270, 2));
    v291 = (v284 | __ROR4__(v275, 2)) & v290 | v284 & __ROR4__(v275, 2);
    LODWORD(v290) = v289;
    v292 = v290 >> 31;
    HIDWORD(v290) = v270;
    LODWORD(v290) = v270;
    v293 = v290 >> 2;
    HIDWORD(v290) = v288;
    LODWORD(v290) = v288;
    v294 = v292 - 1894007588 + v287 + v291 + (v290 >> 27);
    HIDWORD(v290) = v275;
    LODWORD(v290) = v275;
    v295 = v290 >> 2;
    v296 = v195 ^ __ROR4__(v207, 31) ^ __ROR4__(v242, 31) ^ __ROR4__(v276, 31);
    v297 = __PAIR64__(v296, __ROR4__(v284, 2));
    v298 = (v288 | __ROR4__(v284, 2)) & __ROR4__(v275, 2) | v288 & v297;
    LODWORD(v297) = v296;
    v299 = (v297 >> 31) - 1894007588;
    HIDWORD(v297) = v284;
    LODWORD(v297) = v284;
    v300 = v297 >> 2;
    v301 = v299 + v293;
    v303 = __PAIR64__(v294, __ROR4__(v246, 31));
    v302 = v213 ^ __ROR4__(v200, 31) ^ v303;
    LODWORD(v303) = v294;
    v304 = v303 >> 27;
    v305 = v302 ^ __ROR4__(v283, 31);
    v307 = __PAIR64__(v305, __ROR4__(v284, 2));
    v306 = (v294 | __ROR4__(v288, 2)) & v307;
    LODWORD(v307) = v305;
    v534 = v307 >> 31;
    v308 = v301 + v298 + v304;
    v309 = __PAIR64__(v308, __ROR4__(v288, 2));
    v310 = v306 | v294 & v309;
    LODWORD(v309) = v308;
    v311 = v527 ^ __ROR4__(v218, 31) ^ __ROR4__(v254, 31) ^ __ROR4__(v289, 31);
    v312 = v534 - 1894007588 + v295 + v310 + (v309 >> 27);
    v313 = __PAIR64__(v311, __ROR4__(v288, 2));
    v314 = (v308 | __ROR4__(v294, 2)) & v313 | v308 & __ROR4__(v294, 2);
    LODWORD(v313) = v311;
    v315 = v313 >> 31;
    HIDWORD(v313) = v288;
    LODWORD(v313) = v288;
    v316 = v313 >> 2;
    HIDWORD(v313) = v312;
    LODWORD(v313) = v312;
    v317 = v315 - 1894007588 + v300 + v314 + (v313 >> 27);
    v318 = v213 ^ __ROR4__(v223, 31) ^ __ROR4__(v262, 31) ^ __ROR4__(v296, 31);
    v319 = __PAIR64__(v318, __ROR4__(v294, 2));
    v320 = (v312 | __ROR4__(v308, 2)) & v319 | v312 & __ROR4__(v308, 2);
    LODWORD(v319) = v318;
    v321 = v319 >> 31;
    HIDWORD(v319) = v294;
    LODWORD(v319) = v294;
    v322 = v319 >> 2;
    v323 = v321 - 1894007588 + v316;
    HIDWORD(v319) = v317;
    LODWORD(v319) = v317;
    v324 = v319 >> 27;
    v325 = v323 + v320;
    LODWORD(v319) = v525 ^ __ROR4__(v218, 31) ^ __ROR4__(v269, 31) ^ __ROR4__(v305, 31);
    v326 = v319;
    HIDWORD(v319) = v319;
    v528 = v319 >> 31;
    v327 = v325 + v324;
    v328 = __PAIR64__(v308, __ROR4__(v308, 2));
    v329 = (v317 | __ROR4__(v312, 2)) & v328 | v317 & __ROR4__(v312, 2);
    LODWORD(v328) = v308;
    v330 = v328 >> 2;
    HIDWORD(v328) = v327;
    LODWORD(v328) = v327;
    v331 = v528 - 1894007588 + v322 + v329 + (v328 >> 27);
    v332 = v530 ^ __ROR4__(v235, 31) ^ __ROR4__(v276, 31) ^ __ROR4__(v311, 31);
    v333 = __PAIR64__(v332, __ROR4__(v312, 2));
    v334 = (v327 | __ROR4__(v317, 2)) & v333 | v327 & __ROR4__(v317, 2);
    LODWORD(v333) = v332;
    v523 = v333 >> 31;
    HIDWORD(v333) = v312;
    LODWORD(v333) = v312;
    v335 = v333 >> 2;
    HIDWORD(v333) = v331;
    LODWORD(v333) = v331;
    v336 = v523 - 1894007588 + v330 + v334 + (v333 >> 27);
    HIDWORD(v333) = v317;
    LODWORD(v333) = v317;
    v337 = v333 >> 2;
    v338 = v525 ^ __ROR4__(v242, 31) ^ __ROR4__(v283, 31) ^ __ROR4__(v318, 31);
    v339 = __PAIR64__(v338, __ROR4__(v327, 2));
    v340 = (v331 | __ROR4__(v327, 2)) & __ROR4__(v317, 2) | v331 & v339;
    LODWORD(v339) = v338;
    v341 = (v339 >> 31) - 1894007588;
    HIDWORD(v339) = v327;
    LODWORD(v339) = v327;
    v342 = v339 >> 2;
    v343 = v341 + v335;
    v345 = __PAIR64__(v336, __ROR4__(v289, 31));
    v344 = v248 ^ __ROR4__(v235, 31) ^ v345;
    LODWORD(v345) = v336;
    v346 = v345 >> 27;
    v347 = v343 + v340;
    v348 = v344 ^ __ROR4__(v326, 31);
    v350 = __PAIR64__(v348, __ROR4__(v327, 2));
    v349 = (v336 | __ROR4__(v331, 2)) & v350;
    LODWORD(v350) = v348;
    v531 = v350 >> 31;
    v351 = v347 + v346;
    v352 = __PAIR64__(v351, __ROR4__(v331, 2));
    v353 = v349 | v336 & v352;
    LODWORD(v352) = v351;
    v354 = v531 - 1894007588 + v337 + v353;
    v355 = v536 ^ __ROR4__(v254, 31) ^ __ROR4__(v296, 31) ^ __ROR4__(v332, 31);
    v356 = v354 + (v352 >> 27);
    v357 = __PAIR64__(v355, __ROR4__(v331, 2));
    v358 = (v351 | __ROR4__(v336, 2)) & v357 | v351 & __ROR4__(v336, 2);
    LODWORD(v357) = v355;
    v359 = v357 >> 31;
    HIDWORD(v357) = v331;
    LODWORD(v357) = v331;
    v360 = v357 >> 2;
    HIDWORD(v357) = v356;
    LODWORD(v357) = v356;
    v361 = v359 - 1894007588 + v342 + v358 + (v357 >> 27);
    v362 = v248 ^ __ROR4__(v262, 31) ^ __ROR4__(v305, 31) ^ __ROR4__(v338, 31);
    v363 = __PAIR64__(v362, __ROR4__(v336, 2));
    v364 = (v356 | __ROR4__(v351, 2)) & v363 | v356 & __ROR4__(v351, 2);
    LODWORD(v363) = v362;
    v365 = v363 >> 31;
    HIDWORD(v363) = v336;
    LODWORD(v363) = v336;
    v366 = v363 >> 2;
    v367 = v365 - 1894007588 + v360;
    HIDWORD(v363) = v361;
    LODWORD(v363) = v361;
    v368 = v363 >> 27;
    LODWORD(v363) = v273 ^ __ROR4__(v254, 31) ^ __ROR4__(v311, 31) ^ __ROR4__(v348, 31);
    v369 = v363;
    HIDWORD(v363) = v363;
    v537 = v363 >> 31;
    v370 = v367 + v364 + v368;
    v371 = __PAIR64__(v351, __ROR4__(v351, 2));
    v372 = (v361 | __ROR4__(v356, 2)) & v371 | v361 & __ROR4__(v356, 2);
    LODWORD(v371) = v351;
    v373 = v371 >> 2;
    HIDWORD(v371) = v370;
    LODWORD(v371) = v370;
    v374 = v537 - 1894007588 + v366 + v372 + (v371 >> 27);
    v375 = v540 ^ __ROR4__(v276, 31) ^ __ROR4__(v318, 31) ^ __ROR4__(v355, 31);
    v376 = __PAIR64__(v375, __ROR4__(v356, 2));
    v377 = (v370 | __ROR4__(v361, 2)) & v376 | v370 & __ROR4__(v361, 2);
    LODWORD(v376) = v375;
    v541 = v376 >> 31;
    HIDWORD(v376) = v356;
    LODWORD(v376) = v356;
    v378 = v376 >> 2;
    HIDWORD(v376) = v374;
    LODWORD(v376) = v374;
    v379 = v541 - 1894007588 + v373 + v377 + (v376 >> 27);
    HIDWORD(v376) = v361;
    LODWORD(v376) = v361;
    v380 = v376 >> 2;
    v381 = v273 ^ __ROR4__(v283, 31) ^ __ROR4__(v326, 31) ^ __ROR4__(v362, 31);
    v382 = __PAIR64__(v381, __ROR4__(v370, 2));
    v383 = (v374 | __ROR4__(v370, 2)) & __ROR4__(v361, 2) | v374 & v382;
    LODWORD(v382) = v381;
    v384 = (v382 >> 31) - 1894007588;
    HIDWORD(v382) = v370;
    LODWORD(v382) = v370;
    v385 = v382 >> 2;
    v387 = __PAIR64__(v379, __ROR4__(v332, 31));
    v386 = v292 ^ __ROR4__(v276, 31) ^ v387;
    LODWORD(v387) = v379;
    v388 = v387 >> 27;
    v389 = v384 + v378 + v383;
    v390 = v386 ^ __ROR4__(v369, 31);
    v392 = __PAIR64__(v390, __ROR4__(v370, 2));
    v391 = (v379 | __ROR4__(v374, 2)) & v392;
    LODWORD(v392) = v390;
    v393 = v392 >> 31;
    v394 = v389 + v388;
    v395 = v393 - 1894007588 + v380 + (v391 | v379 & __ROR4__(v374, 2));
    v396 = v544 ^ __ROR4__(v296, 31) ^ __ROR4__(v338, 31) ^ __ROR4__(v375, 31);
    HIDWORD(v392) = v396;
    LODWORD(v392) = v396;
    v397 = v392 >> 31;
    HIDWORD(v392) = v394;
    LODWORD(v392) = v394;
    v398 = v395 + (v392 >> 27);
    HIDWORD(v392) = v379;
    LODWORD(v392) = v379;
    v399 = v392 >> 2;
    v401 = __PAIR64__(v398, __ROR4__(v305, 31));
    v400 = v292 ^ v401;
    LODWORD(v401) = v398;
    v402 = v397 - 899497514 + v385 + (v399 ^ __ROR4__(v374, 2) ^ v394) + (v401 >> 27);
    v403 = v400 ^ __ROR4__(v348, 31) ^ __ROR4__(v381, 31);
    HIDWORD(v401) = v403;
    LODWORD(v401) = v403;
    v404 = v401 >> 31;
    HIDWORD(v401) = v374;
    LODWORD(v401) = v374;
    v405 = v404 - 899497514 + (v401 >> 2);
    HIDWORD(v401) = v394;
    LODWORD(v401) = v394;
    v406 = v401 >> 2;
    v407 = __PAIR64__(v402, __ROR4__(v379, 2));
    v408 = v405 + (v406 ^ v407 ^ v398);
    LODWORD(v407) = v402;
    v409 = v408 + (v407 >> 27);
    LODWORD(v407) = v315 ^ __ROR4__(v296, 31) ^ __ROR4__(v355, 31) ^ __ROR4__(v390, 31);
    v410 = v407;
    HIDWORD(v407) = v407;
    v411 = v407 >> 31;
    HIDWORD(v407) = v398;
    LODWORD(v407) = v398;
    v412 = v407 >> 2;
    v413 = __PAIR64__(v409, __ROR4__(v394, 2));
    v414 = v411 - 899497514 + v399 + (v412 ^ v413 ^ v402);
    LODWORD(v413) = v409;
    v415 = v414 + (v413 >> 27);
    v416 = v534 ^ __ROR4__(v318, 31) ^ __ROR4__(v362, 31) ^ __ROR4__(v396, 31);
    HIDWORD(v413) = v416;
    LODWORD(v413) = v416;
    v417 = v413 >> 31;
    HIDWORD(v413) = v402;
    LODWORD(v413) = v402;
    v418 = v413 >> 2;
    v420 = __PAIR64__(v415, __ROR4__(v326, 31));
    v419 = v315 ^ v420;
    LODWORD(v420) = v415;
    v421 = v417 - 899497514 + v406 + (v418 ^ __ROR4__(v398, 2) ^ v409) + (v420 >> 27);
    v422 = v419 ^ __ROR4__(v369, 31) ^ __ROR4__(v403, 31);
    HIDWORD(v420) = v422;
    LODWORD(v420) = v422;
    v423 = (v420 >> 31) - 899497514;
    HIDWORD(v420) = v409;
    LODWORD(v420) = v409;
    v424 = v420 >> 2;
    v425 = __PAIR64__(v421, __ROR4__(v402, 2));
    v426 = v423 + v412 + (v424 ^ v425 ^ v415);
    LODWORD(v425) = v421;
    v427 = v425 >> 27;
    v429 = __PAIR64__(v415, __ROR4__(v375, 31));
    v428 = v523 ^ __ROR4__(v318, 31) ^ v429;
    LODWORD(v429) = v415;
    v430 = v429 >> 2;
    v432 = v426 + v427;
    LODWORD(v429) = v428 ^ __ROR4__(v410, 31);
    v431 = v429;
    HIDWORD(v429) = v429;
    v433 = (v429 >> 31) - 899497514 + v418;
    HIDWORD(v429) = v432;
    LODWORD(v429) = v432;
    v434 = v433 + (v430 ^ __ROR4__(v409, 2) ^ v421) + (v429 >> 27);
    LODWORD(v429) = v528 ^ __ROR4__(v338, 31) ^ __ROR4__(v381, 31) ^ __ROR4__(v416, 31);
    v435 = v429;
    HIDWORD(v429) = v429;
    v436 = (v429 >> 31) - 899497514;
    HIDWORD(v429) = v421;
    LODWORD(v429) = v421;
    v437 = v429 >> 2;
    v438 = __PAIR64__(v434, __ROR4__(v415, 2));
    v439 = v436 + v424 + (v437 ^ v438 ^ v432);
    LODWORD(v438) = v434;
    v440 = v439 + (v438 >> 27);
    v441 = v523 ^ __ROR4__(v348, 31) ^ __ROR4__(v390, 31) ^ __ROR4__(v422, 31);
    HIDWORD(v438) = v441;
    LODWORD(v438) = v441;
    v442 = (v438 >> 31) - 899497514 + v430;
    HIDWORD(v438) = v432;
    LODWORD(v438) = v432;
    v443 = v438 >> 2;
    v444 = __PAIR64__(v440, __ROR4__(v421, 2));
    v445 = v442 + (v443 ^ v444 ^ v434);
    LODWORD(v444) = v440;
    v446 = v445 + (v444 >> 27);
    v447 = v359 ^ __ROR4__(v338, 31) ^ __ROR4__(v396, 31) ^ __ROR4__(v431, 31);
    HIDWORD(v444) = v447;
    LODWORD(v444) = v447;
    v448 = (v444 >> 31) - 899497514;
    HIDWORD(v444) = v434;
    LODWORD(v444) = v434;
    v449 = v444 >> 2;
    v450 = __PAIR64__(v446, __ROR4__(v432, 2));
    v451 = v448 + v437 + (v449 ^ v450 ^ v440);
    LODWORD(v450) = v446;
    v452 = v451 + (v450 >> 27);
    LODWORD(v450) = v531 ^ __ROR4__(v362, 31) ^ __ROR4__(v403, 31) ^ __ROR4__(v435, 31);
    v453 = v450;
    HIDWORD(v450) = v450;
    v454 = (v450 >> 31) - 899497514 + v443;
    HIDWORD(v450) = v440;
    LODWORD(v450) = v440;
    v455 = v450 >> 2;
    v456 = __PAIR64__(v452, __ROR4__(v434, 2));
    v457 = v454 + (v455 ^ v456 ^ v446);
    LODWORD(v456) = v452;
    v458 = v457 + (v456 >> 27);
    LODWORD(v456) = v359 ^ __ROR4__(v369, 31) ^ __ROR4__(v410, 31) ^ __ROR4__(v441, 31);
    v459 = v456;
    HIDWORD(v456) = v456;
    v460 = (v456 >> 31) - 899497514;
    HIDWORD(v456) = v446;
    LODWORD(v456) = v446;
    v461 = v456 >> 2;
    v462 = __PAIR64__(v458, __ROR4__(v440, 2));
    v463 = v460 + v449 + (v461 ^ v462 ^ v452);
    LODWORD(v462) = v458;
    v464 = v462 >> 27;
    v466 = __PAIR64__(v452, __ROR4__(v416, 31));
    v465 = v541 ^ __ROR4__(v362, 31) ^ v466;
    LODWORD(v466) = v452;
    v467 = v466 >> 2;
    v468 = v465 ^ __ROR4__(v447, 31);
    v469 = v463 + v464;
    HIDWORD(v466) = v468;
    LODWORD(v466) = v468;
    v470 = (v466 >> 31) - 899497514 + v455;
    HIDWORD(v466) = v469;
    LODWORD(v466) = v469;
    v471 = v381;
    v472 = v470 + (v467 ^ __ROR4__(v446, 2) ^ v458) + (v466 >> 27);
    v473 = v537 ^ __ROR4__(v381, 31) ^ __ROR4__(v422, 31) ^ __ROR4__(v453, 31);
    HIDWORD(v466) = v473;
    LODWORD(v466) = v473;
    v474 = (v466 >> 31) - 899497514;
    HIDWORD(v466) = v458;
    LODWORD(v466) = v458;
    v475 = v466 >> 2;
    v476 = __PAIR64__(v472, __ROR4__(v452, 2));
    v477 = v474 + v461 + (v475 ^ v476 ^ v469);
    LODWORD(v476) = v472;
    v478 = v477 + (v476 >> 27);
    v479 = v541 ^ __ROR4__(v390, 31) ^ __ROR4__(v431, 31) ^ __ROR4__(v459, 31);
    HIDWORD(v476) = v479;
    LODWORD(v476) = v479;
    v480 = (v476 >> 31) - 899497514 + v467;
    HIDWORD(v476) = v469;
    LODWORD(v476) = v469;
    v481 = v476 >> 2;
    v482 = __PAIR64__(v478, __ROR4__(v458, 2));
    v483 = v480 + (v481 ^ v482 ^ v472);
    LODWORD(v482) = v478;
    v484 = v397 ^ __ROR4__(v471, 31) ^ __ROR4__(v435, 31);
    v485 = v483 + (v482 >> 27);
    v486 = v484 ^ __ROR4__(v468, 31);
    HIDWORD(v482) = v486;
    LODWORD(v482) = v486;
    v487 = (v482 >> 31) - 899497514;
    HIDWORD(v482) = v472;
    LODWORD(v482) = v472;
    v488 = v482 >> 2;
    v489 = __PAIR64__(v485, __ROR4__(v469, 2));
    v490 = v487 + v475 + (v488 ^ v489 ^ v478);
    LODWORD(v489) = v485;
    v491 = v490 + (v489 >> 27);
    v492 = v393 ^ __ROR4__(v403, 31) ^ __ROR4__(v441, 31) ^ __ROR4__(v473, 31);
    HIDWORD(v489) = v492;
    LODWORD(v489) = v492;
    v493 = (v489 >> 31) - 899497514 + v481;
    HIDWORD(v489) = v478;
    LODWORD(v489) = v478;
    v494 = v489 >> 2;
    v496 = __PAIR64__(v491, __ROR4__(v447, 31));
    v495 = v397 ^ __ROR4__(v410, 31) ^ v496;
    LODWORD(v496) = v491;
    v497 = v493 + (v494 ^ __ROR4__(v472, 2) ^ v485) + (v496 >> 27);
    v498 = v495 ^ __ROR4__(v479, 31);
    HIDWORD(v496) = v498;
    LODWORD(v496) = v498;
    v499 = (v496 >> 31) - 899497514;
    HIDWORD(v496) = v485;
    LODWORD(v496) = v485;
    v500 = v496 >> 2;
    v501 = __PAIR64__(v497, __ROR4__(v478, 2));
    v502 = v499 + v488 + (v500 ^ v501 ^ v491);
    LODWORD(v501) = v497;
    v503 = v502 + (v501 >> 27);
    result = v417 ^ __ROR4__(v403, 31);
    LODWORD(v501) = result ^ __ROR4__(v453, 31) ^ __ROR4__(v486, 31);
    HIDWORD(v501) = v501;
    v505 = (v501 >> 31) - 899497514 + v494;
    HIDWORD(v501) = v491;
    LODWORD(v501) = v491;
    v506 = v501 >> 2;
    v508 = __PAIR64__(v503, __ROR4__(v459, 31));
    v507 = v411 ^ __ROR4__(v422, 31) ^ v508;
    LODWORD(v508) = v503;
    v509 = v505 + (v506 ^ __ROR4__(v485, 2) ^ v497) + (v508 >> 27);
    LODWORD(v508) = v507 ^ __ROR4__(v492, 31);
    HIDWORD(v508) = v508;
    v510 = (v508 >> 31) - 899497514;
    HIDWORD(v508) = v497;
    LODWORD(v508) = v497;
    v511 = v508 >> 2;
    v512 = __PAIR64__(v509, __ROR4__(v491, 2));
    v513 = v510 + v500 + (v511 ^ v512 ^ v503);
    LODWORD(v512) = v509;
    v514 = v513 + (v512 >> 27);
    LODWORD(v512) = v417 ^ __ROR4__(v431, 31) ^ __ROR4__(v468, 31) ^ __ROR4__(v498, 31);
    HIDWORD(v512) = v512;
    v515 = v545 - 899497514 + (v512 >> 31) + v506;
    HIDWORD(v512) = v503;
    LODWORD(v512) = v503;
    v516 = v512 >> 2;
    v517 = __PAIR64__(v514, __ROR4__(v497, 2));
    v518 = v515 + (v516 ^ v517 ^ v509);
    LODWORD(v517) = v514;
    v7 = v518 + (v517 >> 27);
    HIDWORD(v517) = v509;
    LODWORD(v517) = v509;
    v6 = (v517 >> 2) + v549;
    v5 = v514 + v551;
    v4 = v511 + v546;
    v3 = v516 + v550;
    *a1 = v7;
    a1[1] = v514 + v551;
    a1[2] = v6;
    a1[3] = v516 + v550;
    a1[4] = v4;
    a2 = v547 + 16;
    a3 = v548 - 1;
  }
  while (v548 != 1);
  return result;
}

void SHA1_Transform(SHA_CTX *c, const unsigned __int8 *data)
{
  sha1_block_data_order((int *)c, (unsigned int *)data, 1);
}

int SHA1_Final(unsigned __int8 *md, SHA_CTX *c)
{
  unsigned int *data;
  uint64_t num;
  uint64_t v6;
  unsigned int v7;

  data = c->data;
  num = c->num;
  *((_BYTE *)c->data + num) = 0x80;
  v6 = num + 1;
  if (num >= 0x38)
  {
    bzero((char *)data + v6, 63 - num);
    sha1_block_data_order((int *)c, data, 1);
    v6 = 0;
  }
  bzero((char *)data + v6, 56 - v6);
  v7 = bswap32(c->Nl);
  c->data[14] = bswap32(c->Nh);
  c->data[15] = v7;
  sha1_block_data_order((int *)c, data, 1);
  c->num = 0;
  *(_OWORD *)data = 0u;
  *((_OWORD *)data + 1) = 0u;
  *((_OWORD *)data + 2) = 0u;
  *((_OWORD *)data + 3) = 0u;
  *(_DWORD *)md = bswap32(c->h0);
  *((_DWORD *)md + 1) = bswap32(c->h1);
  *((_DWORD *)md + 2) = bswap32(c->h2);
  *((_DWORD *)md + 3) = bswap32(c->h3);
  *((_DWORD *)md + 4) = bswap32(c->h4);
  return 1;
}

int SHA1_Init(SHA_CTX *c)
{
  *(_OWORD *)&c->data[9] = 0u;
  *(_OWORD *)&c->data[13] = 0u;
  *(_OWORD *)&c->data[1] = 0u;
  *(_OWORD *)&c->data[5] = 0u;
  *(_OWORD *)&c->h0 = xmmword_22D69F860;
  *(_OWORD *)&c->h4 = 0u;
  c->h4 = -1009589776;
  return 1;
}

unsigned __int8 *__cdecl SHA1(const unsigned __int8 *d, size_t n, unsigned __int8 *md)
{
  unsigned __int8 *v3;
  SHA_CTX v5;

  if (md)
    v3 = md;
  else
    v3 = (unsigned __int8 *)&SHA1_m;
  memset(&v5.Nl, 0, 76);
  *(_OWORD *)&v5.h0 = xmmword_22D69F860;
  v5.h4 = -1009589776;
  SHA1_Update(&v5, d, n);
  SHA1_Final(v3, &v5);
  explicit_bzero(&v5, 0x60uLL);
  return v3;
}

void *ASN1_PCTX_new()
{
  void *v0;

  v0 = malloc_type_calloc(1uLL, 0x28uLL, 0x10000400A747E1EuLL);
  if (!v0)
    ERR_put_error(13, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/tasn_prn.c", 85);
  return v0;
}

uint64_t ASN1_PCTX_get_flags(uint64_t a1)
{
  return *(_QWORD *)a1;
}

_QWORD *ASN1_PCTX_set_flags(_QWORD *result, uint64_t a2)
{
  *result = a2;
  return result;
}

uint64_t ASN1_PCTX_get_nm_flags(uint64_t a1)
{
  return *(_QWORD *)(a1 + 8);
}

uint64_t ASN1_PCTX_set_nm_flags(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 8) = a2;
  return result;
}

uint64_t ASN1_PCTX_get_cert_flags(uint64_t a1)
{
  return *(_QWORD *)(a1 + 16);
}

uint64_t ASN1_PCTX_set_cert_flags(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 16) = a2;
  return result;
}

uint64_t ASN1_PCTX_get_oid_flags(uint64_t a1)
{
  return *(_QWORD *)(a1 + 24);
}

uint64_t ASN1_PCTX_set_oid_flags(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 24) = a2;
  return result;
}

uint64_t ASN1_PCTX_get_str_flags(uint64_t a1)
{
  return *(_QWORD *)(a1 + 32);
}

uint64_t ASN1_PCTX_set_str_flags(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 32) = a2;
  return result;
}

uint64_t ASN1_item_print(BIO *a1, ASN1_VALUE *a2, uint64_t a3, ASN1_ITEM *a4, uint64_t *a5)
{
  uint64_t *v5;
  const char *sname;
  ASN1_VALUE *pval;

  pval = a2;
  if (a5)
    v5 = a5;
  else
    v5 = (uint64_t *)&default_pctx;
  if ((*((_BYTE *)v5 + 1) & 1) != 0)
    sname = 0;
  else
    sname = a4->sname;
  return asn1_item_print_ctx(a1, (ASN1_OBJECT **)&pval, a3, a4, 0, sname, 0, v5);
}

uint64_t asn1_item_print_ctx(BIO *b, ASN1_OBJECT **pval, uint64_t a3, ASN1_ITEM *it, const char *a5, const char *a6, int a7, uint64_t *a8)
{
  ASN1_OBJECT **p_data;
  _QWORD *funcs;
  uint64_t (*v16)(uint64_t, ASN1_OBJECT **, ASN1_ITEM *, BIO **);
  uint64_t result;
  const char *v18;
  const char *v19;
  int v20;
  int *templates;
  _QWORD *v22;
  uint64_t (*v23)(BIO *, ASN1_OBJECT **, ASN1_ITEM *, uint64_t, uint64_t *);
  unsigned int choice_selector;
  ASN1_TEMPLATE *v25;
  ASN1_VALUE **field_ptr;
  uint64_t (*v27)(BIO *, ASN1_OBJECT **, uint64_t, const char *, uint64_t *);
  ASN1_STRING *v28;
  unint64_t utype;
  uint64_t v30;
  const ASN1_TEMPLATE *v31;
  int *v32;
  ASN1_VALUE **v33;
  int length;
  const char *v35;
  int size;
  const char *v37;
  const char *v38;
  BIO *v39;
  uint64_t v40;
  uint64_t *v41;

  p_data = pval;
  funcs = it->funcs;
  v39 = 0;
  v40 = 0;
  v41 = 0;
  if (funcs)
  {
    v16 = (uint64_t (*)(uint64_t, ASN1_OBJECT **, ASN1_ITEM *, BIO **))funcs[3];
    if (v16)
    {
      v39 = b;
      LODWORD(v40) = a3;
      v41 = a8;
    }
  }
  else
  {
    v16 = 0;
  }
  if (!it->itype && it->utype == 1)
  {
LABEL_21:
    templates = (int *)it->templates;
    if (templates)
    {
      result = asn1_template_print_ctx(b, (ASN1_VALUE **)pval, a3, templates, a8);
      if (!(_DWORD)result)
        return result;
    }
LABEL_23:
    result = asn1_print_fsname(b, a3, a5, a6, a8);
    if (!(_DWORD)result)
      return result;
    v22 = it->funcs;
    if (v22)
    {
      v23 = (uint64_t (*)(BIO *, ASN1_OBJECT **, ASN1_ITEM *, uint64_t, uint64_t *))v22[7];
      if (v23)
      {
        result = v23(b, p_data, it, a3, a8);
        if (!(_DWORD)result)
          return result;
        return 1;
      }
      return 0;
    }
    if (it->itype == 5)
    {
      v28 = (ASN1_STRING *)*p_data;
      utype = SHIDWORD((*p_data)->sn) & 0xFFFFFFFFFFFFFEFFLL;
    }
    else
    {
      utype = it->utype;
      if (utype == 1)
      {
        v28 = 0;
      }
      else
      {
        v28 = (ASN1_STRING *)*p_data;
        if (utype == -4)
        {
          length = v28->length;
          utype = v28->length;
          p_data = (ASN1_OBJECT **)&v28->data;
          v28 = (ASN1_STRING *)v28->data;
          if ((*(_BYTE *)a8 & 0x10) != 0)
          {
LABEL_67:
            v35 = 0;
            goto LABEL_70;
          }
LABEL_69:
          v35 = ASN1_tag2str(length);
LABEL_70:
          if (utype == 5)
          {
            result = BIO_puts(b, "NULL\n") > 0;
            if (!(_DWORD)result)
              return result;
            return 1;
          }
          if (!v35 || BIO_puts(b, v35) >= 1 && BIO_puts(b, ":") >= 1)
          {
            switch(utype)
            {
              case 1uLL:
                size = *(_DWORD *)p_data;
                if (*(_DWORD *)p_data == -1)
                  size = it->size;
                v37 = "TRUE";
                if (!size)
                  v37 = "FALSE";
                if (size == -1)
                  v38 = "BOOL ABSENT";
                else
                  v38 = v37;
                result = BIO_puts(b, v38) > 0;
                goto LABEL_97;
              case 2uLL:
              case 0xAuLL:
                result = asn1_print_integer_ctx(b, v28);
                goto LABEL_97;
              case 3uLL:
              case 4uLL:
                result = asn1_print_obstring_ctx(b, (uint64_t)v28, a3);
                if ((_DWORD)result)
                  return 1;
                return result;
              case 5uLL:
              case 7uLL:
              case 8uLL:
              case 9uLL:
              case 0xBuLL:
              case 0xCuLL:
              case 0xDuLL:
              case 0xEuLL:
              case 0xFuLL:
              case 0x12uLL:
              case 0x13uLL:
              case 0x14uLL:
              case 0x15uLL:
              case 0x16uLL:
                goto LABEL_85;
              case 6uLL:
                result = asn1_print_oid_ctx(b, *p_data);
                goto LABEL_97;
              case 0x10uLL:
              case 0x11uLL:
                goto LABEL_81;
              case 0x17uLL:
                result = ASN1_UTCTIME_print(b, v28);
                goto LABEL_97;
              case 0x18uLL:
                result = ASN1_GENERALIZEDTIME_print(b, v28);
                goto LABEL_97;
              default:
                if (utype == -3)
                {
LABEL_81:
                  if (BIO_puts(b, "\n") < 1)
                    return 0;
                  v20 = ASN1_parse_dump(b, v28->data, v28->length, a3, 0);
                  return v20 >= 1;
                }
LABEL_85:
                result = ASN1_STRING_print_ex(b, v28, a8[4]);
LABEL_97:
                if (!(_DWORD)result)
                  return result;
                break;
            }
LABEL_98:
            v19 = "\n";
LABEL_18:
            v20 = BIO_puts(b, v19);
            return v20 >= 1;
          }
          return 0;
        }
      }
    }
    if ((*(_BYTE *)a8 & 8) == 0)
      goto LABEL_67;
    length = utype;
    goto LABEL_69;
  }
  if (!*pval)
  {
    if ((*(_BYTE *)a8 & 1) == 0)
      return 1;
    if (!a7)
    {
      result = asn1_print_fsname(b, a3, a5, a6, a8);
      if (!(_DWORD)result)
        return result;
    }
    v19 = "<ABSENT>\n";
    goto LABEL_18;
  }
  switch(it->itype)
  {
    case 0:
      goto LABEL_21;
    case 1:
    case 6:
      if (!a7)
      {
        result = asn1_print_fsname(b, a3, a5, a6, a8);
        if (!(_DWORD)result)
          return result;
      }
      if ((unint64_t)a5 | (unint64_t)a6)
      {
        v18 = (*(_BYTE *)a8 & 2) != 0 ? " {\n" : "\n";
        if (BIO_puts(b, v18) < 1)
          return 0;
      }
      if (!v16)
        goto LABEL_53;
      result = v16(8, p_data, it, &v39);
      if (!(_DWORD)result)
        return result;
      if ((_DWORD)result == 2)
        return 1;
LABEL_53:
      if (it->tcount < 1)
        goto LABEL_58;
      v30 = 0;
      v31 = it->templates;
      break;
    case 2:
      choice_selector = asn1_get_choice_selector((ASN1_VALUE **)pval, it);
      if ((choice_selector & 0x80000000) != 0 || it->tcount <= choice_selector)
        return BIO_printf(b, "ERROR: selector [%d] invalid\n", choice_selector) > 0;
      v25 = (ASN1_TEMPLATE *)&it->templates[choice_selector];
      field_ptr = asn1_get_field_ptr((ASN1_VALUE **)p_data, v25);
      result = asn1_template_print_ctx(b, field_ptr, a3, (int *)v25, a8);
      if ((_DWORD)result)
        return 1;
      return result;
    case 4:
      if (a7)
        goto LABEL_36;
      result = asn1_print_fsname(b, a3, a5, a6, a8);
      if (!(_DWORD)result)
        return result;
      funcs = it->funcs;
LABEL_36:
      if (!funcs
        || (v27 = (uint64_t (*)(BIO *, ASN1_OBJECT **, uint64_t, const char *, uint64_t *))funcs[6]) == 0)
      {
        if (!a6)
          return 1;
        v20 = BIO_printf(b, ":EXTERNAL TYPE %s\n", a6);
        return v20 >= 1;
      }
      result = v27(b, p_data, a3, "", a8);
      if (!(_DWORD)result)
        return result;
      if ((_DWORD)result == 2)
        goto LABEL_98;
      return 1;
    case 5:
      goto LABEL_23;
    default:
      BIO_printf(b, "Unprocessed type %d\n", it->itype);
      return 0;
  }
  while (1)
  {
    result = (uint64_t)asn1_do_adb((ASN1_VALUE **)p_data, v31, 1);
    if (!result)
      break;
    v32 = (int *)result;
    v33 = asn1_get_field_ptr((ASN1_VALUE **)p_data, (const ASN1_TEMPLATE *)result);
    result = asn1_template_print_ctx(b, v33, (int)a3 + 2, v32, a8);
    if (!(_DWORD)result)
      break;
    ++v30;
    ++v31;
    if (it->tcount <= v30)
    {
LABEL_58:
      if ((*(_BYTE *)a8 & 2) != 0 && BIO_printf(b, "%*s}\n", a3, "") < 0)
        return 0;
      if (!v16)
        return 1;
      result = v16(9, p_data, it, &v39);
      if ((_DWORD)result)
        return 1;
      return result;
    }
  }
  return result;
}

uint64_t asn1_template_print_ctx(BIO *b, ASN1_VALUE **pval, int a3, int *a4, uint64_t *a5)
{
  uint64_t v10;
  int v11;
  uint64_t v12;
  int v13;
  uint64_t result;
  ASN1_VALUE *v15;
  int v16;
  ASN1_VALUE *pvala;

  v10 = *a5;
  v11 = *a4;
  if ((*a5 & 0x40) == 0)
  {
    v12 = *((_QWORD *)a4 + 3);
    if ((v11 & 6) != 0)
    {
      pvala = 0;
      if (v12)
      {
        v13 = (v10 & 4) != 0 ? BIO_printf(b, "%*s%s OF %s {\n") : BIO_printf(b, "%*s%s:\n");
        if (v13 < 1)
          return 0;
      }
      goto LABEL_11;
    }
    return asn1_item_print_ctx(b, pval, a3, *((ASN1_ITEM **)a4 + 4));
  }
  if ((v11 & 6) == 0)
    return asn1_item_print_ctx(b, pval, a3, *((ASN1_ITEM **)a4 + 4));
  pvala = 0;
LABEL_11:
  v15 = *pval;
  if (sk_num((const STACK *)*pval) < 1)
  {
    if (BIO_printf(b, "%*s<EMPTY>\n", a3 + 2, "") >= 1)
    {
LABEL_19:
      if ((*(_BYTE *)a5 & 2) == 0 || BIO_printf(b, "%*s}\n", a3, "") >= 1)
        return 1;
    }
  }
  else
  {
    v16 = 0;
    while (!v16 || BIO_puts(b, "\n") >= 1)
    {
      pvala = (ASN1_VALUE *)sk_value((const STACK *)v15, v16);
      result = asn1_item_print_ctx(b, &pvala, a3 + 2, *((ASN1_ITEM **)a4 + 4));
      if (!(_DWORD)result)
        return result;
      if (++v16 >= sk_num((const STACK *)v15))
        goto LABEL_19;
    }
  }
  return 0;
}

BOOL asn1_print_fsname(BIO *b, int a2, const char *a3, const char *a4, _QWORD *a5)
{
  int v8;
  int v10;
  BOOL v11;
  const char *v12;
  int v13;

  v8 = a2;
  if (a2 >= 21)
  {
    while (BIO_write(b, asn1_print_fsname_spaces, 20) == 20)
    {
      v10 = v8 - 20;
      v11 = v8 <= 40;
      v8 -= 20;
      if (v11)
        goto LABEL_7;
    }
    return 0;
  }
  v10 = a2;
LABEL_7:
  if (BIO_write(b, asn1_print_fsname_spaces, v10) != v10)
    return 0;
  if ((*a5 & 0x100) != 0)
    a4 = 0;
  if ((*a5 & 0x40) != 0)
    v12 = 0;
  else
    v12 = a3;
  if (!((unint64_t)a4 | (unint64_t)v12))
    return 1;
  if (v12)
  {
    if (BIO_puts(b, v12) < 1)
      return 0;
    if (a4)
    {
      v13 = BIO_printf(b, " (%s)", a4);
      goto LABEL_21;
    }
    return BIO_write(b, ": ", 2) == 2;
  }
  if (!a4)
    return BIO_write(b, ": ", 2) == 2;
  v13 = BIO_puts(b, a4);
LABEL_21:
  if (v13 >= 1)
    return BIO_write(b, ": ", 2) == 2;
  return 0;
}

BOOL asn1_print_integer_ctx(BIO *a1, ASN1_INTEGER *a2)
{
  char *v3;
  char *v4;
  _BOOL8 v5;

  v3 = i2s_ASN1_INTEGER(0, a2);
  if (!v3)
    return 0;
  v4 = v3;
  v5 = BIO_puts(a1, v3) > 0;
  free(v4);
  return v5;
}

BOOL asn1_print_oid_ctx(BIO *a1, ASN1_OBJECT *o)
{
  int v4;
  const char *v5;
  const char *v6;
  char buf[80];
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v4 = OBJ_obj2nid(o);
  v5 = OBJ_nid2ln(v4);
  if (v5)
    v6 = v5;
  else
    v6 = "";
  OBJ_obj2txt(buf, 80, o, 1);
  return BIO_printf(a1, "%s (%s)", v6, buf) > 0;
}

BOOL asn1_print_obstring_ctx(BIO *bp, uint64_t a2, int a3)
{
  int v6;

  if (*(_DWORD *)(a2 + 4) == 3)
    v6 = BIO_printf(bp, " (%ld unused bits)\n", *(_QWORD *)(a2 + 16) & 7);
  else
    v6 = BIO_puts(bp, "\n");
  return v6 >= 1 && (*(int *)a2 < 1 || BIO_dump_indent(bp, *(const char **)(a2 + 8), *(_DWORD *)a2, a3 + 2) >= 1);
}

int RSA_check_key(const RSA *a1)
{
  BIGNUM *v2;
  BIGNUM *v3;
  BIGNUM *v4;
  BIGNUM *v5;
  BIGNUM *v6;
  BN_CTX *v7;
  BN_CTX *v8;
  int v9;
  int is_prime;
  int v12;
  BIGNUM *p;
  const BIGNUM *v14;
  BIGNUM *q;
  const BIGNUM *v16;
  BIGNUM *v17;
  const BIGNUM *v18;
  BIGNUM *v19;
  const BIGNUM *v20;

  if (a1->p && a1->q && a1->n && a1->e && a1->d)
  {
    v2 = BN_new();
    v3 = BN_new();
    v4 = BN_new();
    v5 = BN_new();
    v6 = BN_new();
    v7 = BN_CTX_new();
    v8 = v7;
    if (v2 && v3 && v4 && v5 && v6 && v7)
    {
      if (BN_is_one((uint64_t)a1->e))
      {
        ERR_put_error(4, 4095, 101, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/rsa/rsa_chk.c", 86);
        v9 = 0;
      }
      else
      {
        v9 = 1;
      }
      if (!BN_is_odd((uint64_t)a1->e))
      {
        ERR_put_error(4, 4095, 101, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/rsa/rsa_chk.c", 90);
        v9 = 0;
      }
      is_prime = BN_is_prime_ex(a1->p, 0, 0, 0);
      if (is_prime != 1)
      {
        v9 = is_prime;
        if (is_prime)
          goto LABEL_18;
        ERR_put_error(4, 4095, 128, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/rsa/rsa_chk.c", 99);
      }
      v12 = BN_is_prime_ex(a1->q, 0, 0, 0);
      if (v12 != 1)
      {
        v9 = v12;
        if (v12)
          goto LABEL_18;
        ERR_put_error(4, 4095, 129, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/rsa/rsa_chk.c", 108);
      }
      if (BN_mul(v2, a1->p, a1->q, v8))
      {
        if (BN_cmp(v2, a1->n))
        {
          ERR_put_error(4, 4095, 127, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/rsa/rsa_chk.c", 120);
          v9 = 0;
        }
        p = a1->p;
        v14 = BN_value_one();
        if (BN_sub(v2, p, v14))
        {
          q = a1->q;
          v16 = BN_value_one();
          if (BN_sub(v3, q, v16))
          {
            if (BN_mul(v5, v2, v3, v8)
              && BN_gcd_ct((unint64_t)v6, v2, v3, v8)
              && BN_div_ct((uint64_t)v4, 0, v5, v6, v8)
              && BN_mod_mul(v2, a1->d, a1->e, v4, v8))
            {
              if (!BN_is_one((uint64_t)v2))
              {
                ERR_put_error(4, 4095, 123, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/rsa/rsa_chk.c", 161);
                v9 = 0;
              }
              if (!a1->dmp1 || !a1->dmq1 || !a1->iqmp)
                goto LABEL_18;
              v17 = a1->p;
              v18 = BN_value_one();
              if (BN_sub(v2, v17, v18))
              {
                if (BN_mod_ct(v3, a1->d, v2, v8))
                {
                  if (BN_cmp(v3, a1->dmp1))
                  {
                    ERR_put_error(4, 4095, 124, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/rsa/rsa_chk.c", 180);
                    v9 = 0;
                  }
                  v19 = a1->q;
                  v20 = BN_value_one();
                  if (BN_sub(v2, v19, v20))
                  {
                    if (BN_mod_ct(v3, a1->d, v2, v8))
                    {
                      if (BN_cmp(v3, a1->dmq1))
                      {
                        ERR_put_error(4, 4095, 125, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/rsa/rsa_chk.c", 198);
                        v9 = 0;
                      }
                      if (BN_mod_inverse_ct(v2, a1->q, a1->p, v8))
                      {
                        if (BN_cmp(v2, a1->iqmp))
                        {
                          ERR_put_error(4, 4095, 126, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/rsa/rsa_chk.c", 209);
                          v9 = 0;
                        }
                        goto LABEL_18;
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    else
    {
      ERR_put_error(4, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/rsa/rsa_chk.c", 80);
    }
    v9 = -1;
LABEL_18:
    BN_free(v2);
    BN_free(v3);
    BN_free(v4);
    BN_free(v5);
    BN_free(v6);
    BN_CTX_free(v8);
    return v9;
  }
  ERR_put_error(4, 4095, 147, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/rsa/rsa_chk.c", 67);
  return 0;
}

X509_VAL *__cdecl d2i_X509_VAL(X509_VAL **a, const unsigned __int8 **in, uint64_t len)
{
  return (X509_VAL *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &X509_VAL_it);
}

int i2d_X509_VAL(X509_VAL *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &X509_VAL_it);
}

X509_VAL *X509_VAL_new(void)
{
  return (X509_VAL *)ASN1_item_new(&X509_VAL_it);
}

void X509_VAL_free(X509_VAL *a)
{
  ASN1_item_free((ASN1_VALUE *)a, &X509_VAL_it);
}

int MD5_Update(_MD5_CTX *c, const void *data, size_t len)
{
  size_t v3;
  _DWORD *v4;
  uint64_t num;
  unsigned int *v7;
  char *v8;
  uint64_t v9;

  if (len)
  {
    v3 = len;
    v4 = data;
    *(_QWORD *)&c->Nl += 8 * len;
    num = c->num;
    if ((_DWORD)num)
    {
      v7 = c->data;
      v8 = (char *)c->data + num;
      if (len <= 0x3F && num + len < 0x40)
      {
        memcpy(v8, data, len);
        c->num += v3;
        return 1;
      }
      v9 = 64 - num;
      memcpy(v8, data, 64 - num);
      md5_block_data_order((unint64_t)c, c->data, 1);
      v4 = (_DWORD *)((char *)v4 + v9);
      v3 -= v9;
      c->num = 0;
      *(_OWORD *)v7 = 0u;
      *(_OWORD *)&c->data[4] = 0u;
      *(_OWORD *)&c->data[8] = 0u;
      *(_OWORD *)&c->data[12] = 0u;
    }
    if (v3 >= 0x40)
    {
      md5_block_data_order((unint64_t)c, v4, v3 >> 6);
      v4 = (_DWORD *)((char *)v4 + (v3 & 0xFFFFFFFFFFFFFFC0));
      v3 &= 0x3Fu;
    }
    if (v3)
    {
      c->num = v3;
      memcpy(c->data, v4, v3);
    }
  }
  return 1;
}

unint64_t md5_block_data_order(unint64_t result, _DWORD *a2, uint64_t a3)
{
  int v3;
  int v4;
  int v5;
  int v6;
  int v7;
  unint64_t v8;
  int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  int v18;
  int v19;
  int v20;
  int v21;
  int v22;
  int v23;
  int v24;
  int v25;
  int v26;
  int v27;
  int v28;
  int v29;
  int v30;
  int v31;
  int v32;
  int v33;
  int v34;
  int v35;
  int v36;
  int v37;
  int v38;
  int v39;
  int v40;
  int v41;
  int v42;
  int v43;
  int v44;
  int v45;
  int v46;
  int v47;
  int v48;
  int v49;
  int v50;
  int v51;
  int v52;
  int v53;
  int v54;
  int v55;
  int v56;
  int v57;
  int v58;
  int v59;
  int v60;
  int v61;
  int v62;
  int v63;
  int v64;
  int v65;
  int v66;
  int v67;
  int v68;
  int v69;
  int v70;
  int v71;
  int v72;
  int v73;
  int v74;
  int v75;
  int v76;
  int v77;
  int v78;
  int v79;
  int v80;
  int v81;
  int v82;
  int v83;
  int v84;
  _DWORD *v85;

  v85 = (_DWORD *)result;
  if (a3)
  {
    v4 = *(_DWORD *)(result + 8);
    v3 = *(_DWORD *)(result + 12);
    v5 = *(_DWORD *)result;
    v6 = *(_DWORD *)(result + 4);
    do
    {
      v7 = a2[1];
      HIDWORD(v8) = v5 + (v4 & v6 | v3 & ~v6) - 680876936 + *a2;
      LODWORD(v8) = HIDWORD(v8);
      v9 = (v8 >> 25) + v6;
      HIDWORD(v8) = v3 + v7 - 389564586 + (v6 & v9 | v4 & ~v9);
      LODWORD(v8) = HIDWORD(v8);
      v10 = (v8 >> 20) + v9;
      result = a2[2];
      v11 = a2[3];
      HIDWORD(v8) = v4 + result + 606105819 + (v9 & v10 | v6 & ~v10);
      LODWORD(v8) = HIDWORD(v8);
      v12 = (v8 >> 15) + v10;
      HIDWORD(v8) = v6 + v11 - 1044525330 + (v10 & v12 | v9 & ~v12);
      LODWORD(v8) = HIDWORD(v8);
      v13 = (v8 >> 10) + v12;
      v14 = a2[4];
      v15 = a2[5];
      HIDWORD(v8) = v9 + v14 - 176418897 + (v12 & v13 | v10 & ~v13);
      LODWORD(v8) = HIDWORD(v8);
      v16 = (v8 >> 25) + v13;
      HIDWORD(v8) = v10 + v15 + 1200080426 + (v13 & v16 | v12 & ~v16);
      LODWORD(v8) = HIDWORD(v8);
      v17 = (v8 >> 20) + v16;
      v19 = a2[6];
      v18 = a2[7];
      HIDWORD(v8) = v12 + v19 - 1473231341 + (v16 & v17 | v13 & ~v17);
      LODWORD(v8) = HIDWORD(v8);
      v20 = (v8 >> 15) + v17;
      HIDWORD(v8) = v13 + v18 - 45705983 + (v17 & v20 | v16 & ~v20);
      LODWORD(v8) = HIDWORD(v8);
      v21 = (v8 >> 10) + v20;
      v23 = a2[8];
      v22 = a2[9];
      HIDWORD(v8) = v16 + v23 + 1770035416 + (v20 & v21 | v17 & ~v21);
      LODWORD(v8) = HIDWORD(v8);
      v24 = (v8 >> 25) + v21;
      HIDWORD(v8) = v17 + v22 - 1958414417 + (v21 & v24 | v20 & ~v24);
      LODWORD(v8) = HIDWORD(v8);
      v25 = (v8 >> 20) + v24;
      v26 = a2[10];
      v27 = a2[11];
      HIDWORD(v8) = v26 + v20 - 42063 + (v24 & v25 | v21 & ~v25);
      LODWORD(v8) = HIDWORD(v8);
      v28 = (v8 >> 15) + v25;
      HIDWORD(v8) = v27 + v21 - 1990404162 + (v25 & v28 | v24 & ~v28);
      LODWORD(v8) = HIDWORD(v8);
      v29 = (v8 >> 10) + v28;
      v31 = a2[12];
      v30 = a2[13];
      HIDWORD(v8) = v31 + v24 + 1804603682 + (v28 & v29 | v25 & ~v29);
      LODWORD(v8) = HIDWORD(v8);
      v32 = (v8 >> 25) + v29;
      HIDWORD(v8) = v30 + v25 - 40341101 + (v29 & v32 | v28 & ~v32);
      LODWORD(v8) = HIDWORD(v8);
      v33 = (v8 >> 20) + v32;
      v35 = a2[14];
      v34 = a2[15];
      HIDWORD(v8) = v35 + v28 - 1502002290 + (v32 & v33 | v29 & ~v33);
      LODWORD(v8) = HIDWORD(v8);
      v36 = (v8 >> 15) + v33;
      HIDWORD(v8) = v34 + v29 + 1236535329 + (v33 & v36 | v32 & ~v36);
      LODWORD(v8) = HIDWORD(v8);
      v37 = (v8 >> 10) + v36;
      HIDWORD(v8) = v7 + v32 - 165796510 + (v37 & v33 | v36 & ~v33);
      LODWORD(v8) = HIDWORD(v8);
      v38 = (v8 >> 27) + v37;
      HIDWORD(v8) = v19 + v33 - 1069501632 + (v38 & v36 | v37 & ~v36);
      LODWORD(v8) = HIDWORD(v8);
      v39 = (v8 >> 23) + v38;
      HIDWORD(v8) = v27 + v36 + 643717713 + (v39 & v37 | v38 & ~v37);
      LODWORD(v8) = HIDWORD(v8);
      v40 = (v8 >> 18) + v39;
      HIDWORD(v8) = *a2 + v37 - 373897302 + (v40 & v38 | v39 & ~v38);
      LODWORD(v8) = HIDWORD(v8);
      v41 = (v8 >> 12) + v40;
      HIDWORD(v8) = v15 + v38 - 701558691 + (v41 & v39 | v40 & ~v39);
      LODWORD(v8) = HIDWORD(v8);
      v42 = (v8 >> 27) + v41;
      HIDWORD(v8) = v26 + v39 + 38016083 + (v42 & v40 | v41 & ~v40);
      LODWORD(v8) = HIDWORD(v8);
      v43 = (v8 >> 23) + v42;
      HIDWORD(v8) = v34 + v40 - 660478335 + (v43 & v41 | v42 & ~v41);
      LODWORD(v8) = HIDWORD(v8);
      v44 = (v8 >> 18) + v43;
      HIDWORD(v8) = v14 + v41 - 405537848 + (v44 & v42 | v43 & ~v42);
      LODWORD(v8) = HIDWORD(v8);
      v45 = (v8 >> 12) + v44;
      HIDWORD(v8) = v22 + v42 + 568446438 + (v45 & v43 | v44 & ~v43);
      LODWORD(v8) = HIDWORD(v8);
      v46 = (v8 >> 27) + v45;
      HIDWORD(v8) = v35 + v43 - 1019803690 + (v46 & v44 | v45 & ~v44);
      LODWORD(v8) = HIDWORD(v8);
      v47 = (v8 >> 23) + v46;
      HIDWORD(v8) = v11 + v44 - 187363961 + (v47 & v45 | v46 & ~v45);
      LODWORD(v8) = HIDWORD(v8);
      v48 = (v8 >> 18) + v47;
      HIDWORD(v8) = v23 + v45 + 1163531501 + (v48 & v46 | v47 & ~v46);
      LODWORD(v8) = HIDWORD(v8);
      v49 = (v8 >> 12) + v48;
      HIDWORD(v8) = v30 + v46 - 1444681467 + (v49 & v47 | v48 & ~v47);
      LODWORD(v8) = HIDWORD(v8);
      v50 = (v8 >> 27) + v49;
      HIDWORD(v8) = result + v47 - 51403784 + (v50 & v48 | v49 & ~v48);
      LODWORD(v8) = HIDWORD(v8);
      v51 = (v8 >> 23) + v50;
      HIDWORD(v8) = v18 + v48 + 1735328473 + (v51 & v49 | v50 & ~v49);
      LODWORD(v8) = HIDWORD(v8);
      v52 = (v8 >> 18) + v51;
      HIDWORD(v8) = v31 + v49 - 1926607734 + ((v52 ^ v51) & v50 ^ v51);
      LODWORD(v8) = HIDWORD(v8);
      v53 = (v8 >> 12) + v52;
      HIDWORD(v8) = v15 + v50 - 378558 + (v52 ^ v51 ^ v53);
      LODWORD(v8) = HIDWORD(v8);
      v54 = (v8 >> 28) + v53;
      HIDWORD(v8) = v23 + v51 - 2022574463 + (v53 ^ v52 ^ v54);
      LODWORD(v8) = HIDWORD(v8);
      v55 = (v8 >> 21) + v54;
      HIDWORD(v8) = v27 + v52 + 1839030562 + (v54 ^ v53 ^ v55);
      LODWORD(v8) = HIDWORD(v8);
      v56 = (v8 >> 16) + v55;
      HIDWORD(v8) = v35 + v53 - 35309556 + (v55 ^ v54 ^ v56);
      LODWORD(v8) = HIDWORD(v8);
      v57 = (v8 >> 9) + v56;
      HIDWORD(v8) = v7 + v54 - 1530992060 + (v56 ^ v55 ^ v57);
      LODWORD(v8) = HIDWORD(v8);
      v58 = (v8 >> 28) + v57;
      HIDWORD(v8) = v14 + v55 + 1272893353 + (v57 ^ v56 ^ v58);
      LODWORD(v8) = HIDWORD(v8);
      v59 = (v8 >> 21) + v58;
      HIDWORD(v8) = v18 + v56 - 155497632 + (v58 ^ v57 ^ v59);
      LODWORD(v8) = HIDWORD(v8);
      v60 = (v8 >> 16) + v59;
      HIDWORD(v8) = v26 + v57 - 1094730640 + (v59 ^ v58 ^ v60);
      LODWORD(v8) = HIDWORD(v8);
      v61 = (v8 >> 9) + v60;
      HIDWORD(v8) = v30 + v58 + 681279174 + (v60 ^ v59 ^ v61);
      LODWORD(v8) = HIDWORD(v8);
      v62 = (v8 >> 28) + v61;
      HIDWORD(v8) = *a2 + v59 - 358537222 + (v61 ^ v60 ^ v62);
      LODWORD(v8) = HIDWORD(v8);
      v63 = (v8 >> 21) + v62;
      HIDWORD(v8) = v11 + v60 - 722521979 + (v62 ^ v61 ^ v63);
      LODWORD(v8) = HIDWORD(v8);
      v64 = (v8 >> 16) + v63;
      HIDWORD(v8) = v19 + v61 + 76029189 + (v63 ^ v62 ^ v64);
      LODWORD(v8) = HIDWORD(v8);
      v65 = (v8 >> 9) + v64;
      HIDWORD(v8) = v22 + v62 - 640364487 + (v64 ^ v63 ^ v65);
      LODWORD(v8) = HIDWORD(v8);
      v66 = (v8 >> 28) + v65;
      HIDWORD(v8) = v31 + v63 - 421815835 + (v65 ^ v64 ^ v66);
      LODWORD(v8) = HIDWORD(v8);
      v67 = (v8 >> 21) + v66;
      HIDWORD(v8) = v34 + v64 + 530742520 + (v66 ^ v65 ^ v67);
      LODWORD(v8) = HIDWORD(v8);
      v68 = (v8 >> 16) + v67;
      HIDWORD(v8) = result + v65 - 995338651 + (v67 ^ v66 ^ v68);
      LODWORD(v8) = HIDWORD(v8);
      v69 = (v8 >> 9) + v68;
      HIDWORD(v8) = *a2 + v66 - 198630844 + ((v69 | ~v67) ^ v68);
      LODWORD(v8) = HIDWORD(v8);
      v70 = (v8 >> 26) + v69;
      HIDWORD(v8) = v18 + v67 + 1126891415 + ((v70 | ~v68) ^ v69);
      LODWORD(v8) = HIDWORD(v8);
      v71 = (v8 >> 22) + v70;
      HIDWORD(v8) = v35 + v68 - 1416354905 + ((v71 | ~v69) ^ v70);
      LODWORD(v8) = HIDWORD(v8);
      v72 = (v8 >> 17) + v71;
      HIDWORD(v8) = v15 + v69 - 57434055 + ((v72 | ~v70) ^ v71);
      LODWORD(v8) = HIDWORD(v8);
      v73 = (v8 >> 11) + v72;
      HIDWORD(v8) = v31 + v70 + 1700485571 + ((v73 | ~v71) ^ v72);
      LODWORD(v8) = HIDWORD(v8);
      v74 = (v8 >> 26) + v73;
      HIDWORD(v8) = v11 + v71 - 1894986606 + ((v74 | ~v72) ^ v73);
      LODWORD(v8) = HIDWORD(v8);
      v75 = (v8 >> 22) + v74;
      HIDWORD(v8) = v26 + v72 - 1051523 + ((v75 | ~v73) ^ v74);
      LODWORD(v8) = HIDWORD(v8);
      v76 = (v8 >> 17) + v75;
      HIDWORD(v8) = v7 + v73 - 2054922799 + ((v76 | ~v74) ^ v75);
      LODWORD(v8) = HIDWORD(v8);
      v77 = (v8 >> 11) + v76;
      HIDWORD(v8) = v23 + v74 + 1873313359 + ((v77 | ~v75) ^ v76);
      LODWORD(v8) = HIDWORD(v8);
      v78 = (v8 >> 26) + v77;
      HIDWORD(v8) = v34 + v75 - 30611744 + ((v78 | ~v76) ^ v77);
      LODWORD(v8) = HIDWORD(v8);
      v79 = (v8 >> 22) + v78;
      HIDWORD(v8) = v19 + v76 - 1560198380 + ((v79 | ~v77) ^ v78);
      LODWORD(v8) = HIDWORD(v8);
      v80 = (v8 >> 17) + v79;
      HIDWORD(v8) = v30 + v77 + 1309151649 + ((v80 | ~v78) ^ v79);
      LODWORD(v8) = HIDWORD(v8);
      v81 = (v8 >> 11) + v80;
      HIDWORD(v8) = v14 + v78 - 145523070 + ((v81 | ~v79) ^ v80);
      LODWORD(v8) = HIDWORD(v8);
      v82 = (v8 >> 26) + v81;
      HIDWORD(v8) = v27 + v79 - 1120210379 + ((v82 | ~v80) ^ v81);
      LODWORD(v8) = HIDWORD(v8);
      v83 = (v8 >> 22) + v82;
      HIDWORD(v8) = result + v80 + 718787259 + ((v83 | ~v81) ^ v82);
      LODWORD(v8) = HIDWORD(v8);
      v84 = (v8 >> 17) + v83;
      v5 += v82;
      HIDWORD(v8) = v22 + v81 - 343485551 + ((v84 | ~v82) ^ v83);
      LODWORD(v8) = HIDWORD(v8);
      v6 += v84 + (v8 >> 11);
      v4 += v84;
      v3 += v83;
      *v85 = v5;
      v85[1] = v6;
      v85[2] = v4;
      v85[3] = v3;
      a2 += 16;
      --a3;
    }
    while (a3);
  }
  return result;
}

void MD5_Transform(_MD5_CTX *c, const unsigned __int8 *b)
{
  md5_block_data_order((unint64_t)c, b, 1);
}

int MD5_Final(unsigned __int8 *md, _MD5_CTX *c)
{
  unsigned int *data;
  uint64_t num;
  uint64_t v6;
  unsigned int Nh;

  data = c->data;
  num = c->num;
  *((_BYTE *)c->data + num) = 0x80;
  v6 = num + 1;
  if (num >= 0x38)
  {
    bzero((char *)data + v6, 63 - num);
    md5_block_data_order((unint64_t)c, data, 1);
    v6 = 0;
  }
  bzero((char *)data + v6, 56 - v6);
  Nh = c->Nh;
  c->data[14] = c->Nl;
  c->data[15] = Nh;
  md5_block_data_order((unint64_t)c, data, 1);
  c->num = 0;
  *(_OWORD *)data = 0u;
  *((_OWORD *)data + 1) = 0u;
  *((_OWORD *)data + 2) = 0u;
  *((_OWORD *)data + 3) = 0u;
  *(_DWORD *)md = c->A;
  *((_DWORD *)md + 1) = c->B;
  *((_DWORD *)md + 2) = c->C;
  *((_DWORD *)md + 3) = c->D;
  return 1;
}

int MD5_Init(_MD5_CTX *c)
{
  *(_OWORD *)&c->data[13] = 0u;
  *(_OWORD *)&c->data[6] = 0u;
  *(_OWORD *)&c->data[10] = 0u;
  *(_OWORD *)&c->Nl = 0u;
  *(_OWORD *)&c->data[2] = 0u;
  *(_OWORD *)&c->A = xmmword_22D69F860;
  return 1;
}

void RC2_set_key(RC2_KEY *key, int len, const unsigned __int8 *data, int bits)
{
  int v4;
  int v5;
  uint64_t v6;
  RC2_KEY *v7;
  char v8;
  char v9;
  uint64_t v10;
  RC2_KEY *v11;
  int v12;
  char v13;
  uint64_t v14;
  uint64_t v15;
  char *v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;

  LOBYTE(key->data[0]) = 0;
  if (len >= 128)
    v4 = 128;
  else
    v4 = len;
  if (bits >= 1024)
    v5 = 1024;
  else
    v5 = bits;
  if (bits < 1)
    v5 = 1024;
  if (len < 1)
    goto LABEL_16;
  v6 = v4 <= 1 ? 1 : v4;
  v7 = key;
  do
  {
    v8 = *data++;
    LOBYTE(v7->data[0]) = v8;
    v7 = (RC2_KEY *)((char *)v7 + 1);
    --v6;
  }
  while (v6);
  if (len <= 127)
  {
LABEL_16:
    v9 = *((_BYTE *)key->data + v4 - 1);
    v10 = (128 - v4);
    v11 = key;
    do
    {
      v9 = key_table[(LOBYTE(v11->data[0]) + v9)];
      *((_BYTE *)v11->data + len) = v9;
      v11 = (RC2_KEY *)((char *)v11 + 1);
      --v10;
    }
    while (v10);
  }
  v12 = (v5 + 7) >> 3;
  v13 = key_table[(0xFFu >> (-(char)v5 & 7)) & (unint64_t)*((unsigned __int8 *)key->data
                                                                 + (128 - v12))];
  *((_BYTE *)key->data + (128 - v12)) = v13;
  if (v12 != 128)
  {
    v14 = 0;
    v15 = -(uint64_t)v12;
    v16 = (char *)&key->data[31] - v12 + 3;
    do
    {
      v13 = key_table[(*((_BYTE *)&key->data[31] + v14 + 3) ^ v13)];
      v16[v14--] = v13;
    }
    while (v15 + v14 != -128);
  }
  v17 = 0;
  v18 = 63;
  do
  {
    key->data[v18] = *(unsigned __int16 *)((char *)&key->data[31] + v17 + 2);
    v19 = v17 + 127;
    v17 -= 2;
    --v18;
  }
  while (v19 > 1);
}

ASN1_OBJECT *ASN1_OBJECT_new(void)
{
  ASN1_OBJECT *v0;
  ASN1_OBJECT *v1;

  v0 = (ASN1_OBJECT *)malloc_type_calloc(1uLL, 0x28uLL, 0x10500408E18043EuLL);
  v1 = v0;
  if (v0)
    v0->flags = 1;
  else
    ERR_put_error(13, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/a_object.c", 83);
  return v1;
}

void ASN1_OBJECT_free(ASN1_OBJECT *a)
{
  int flags;

  if (a)
  {
    flags = a->flags;
    if ((flags & 4) != 0)
    {
      free((void *)a->sn);
      free((void *)a->ln);
      a->sn = 0;
      a->ln = 0;
      flags = a->flags;
      if ((flags & 8) == 0)
      {
LABEL_4:
        if ((flags & 1) == 0)
          return;
LABEL_8:
        free(a);
        return;
      }
    }
    else if ((flags & 8) == 0)
    {
      goto LABEL_4;
    }
    freezero(a->data, a->length);
    a->data = 0;
    a->length = 0;
    if ((a->flags & 1) != 0)
      goto LABEL_8;
  }
}

ASN1_OBJECT *__cdecl ASN1_OBJECT_create(int nid, unsigned __int8 *data, int len, const char *sn, const char *ln)
{
  ASN1_OBJECT o;

  o.sn = sn;
  o.ln = ln;
  o.data = data;
  *(&o.flags + 1) = 0;
  o.nid = nid;
  o.length = len;
  o.flags = 13;
  return OBJ_dup(&o);
}

int a2d_ASN1_OBJECT(unsigned __int8 *out, int olen, const char *buf, int num)
{
  int v7;
  int v8;
  _OWORD v10[2];
  _QWORD v11[3];
  size_t v12;
  void *v13;

  v13 = 0;
  memset(v10, 0, sizeof(v10));
  if (num == -1)
    num = strlen(buf);
  v12 = 0;
  memset(v11, 0, sizeof(v11));
  if (num < 1)
    goto LABEL_14;
  CBS_init(v11, (uint64_t)buf, num);
  if (!CBB_init((uint64_t)v10, 0) || !a2c_ASN1_OBJECT_internal((char **)v10, v11))
    goto LABEL_14;
  v7 = 0;
  if (CBB_finish((uint64_t *)v10, &v13, &v12))
  {
    v8 = v12;
    if (!(v12 >> 31))
    {
      if (!out)
      {
LABEL_12:
        v7 = v8;
        goto LABEL_15;
      }
      if (olen >= 1 && v12 <= olen)
      {
        memcpy(out, v13, v12);
        goto LABEL_12;
      }
      ERR_put_error(13, 4095, 107, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/a_object.c", 356);
LABEL_14:
      v7 = 0;
    }
  }
LABEL_15:
  CBB_cleanup((uint64_t *)v10);
  free(v13);
  return v7;
}

uint64_t a2c_ASN1_OBJECT_internal(char **a1, _QWORD *a2)
{
  uint64_t result;
  int v5;
  int v6;
  int v7;
  unsigned __int8 v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;

  v10 = 0;
  v8 = 0;
  result = oid_parse_arc_txt(a2, &v10, &v8, 1);
  if ((_DWORD)result)
  {
    if (!CBS_len((uint64_t)a2))
    {
      v5 = 138;
      v6 = 257;
      goto LABEL_12;
    }
    v9 = 0;
    result = oid_parse_arc_txt(a2, &v9, &v8, 0);
    if (!(_DWORD)result)
      return result;
    if (v10 >= 3)
    {
      v5 = 122;
      v6 = 270;
LABEL_12:
      ERR_put_error(13, 4095, v5, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/a_object.c", v6);
      return 0;
    }
    if (v10 != 2 && v9 > 0x27 || __CFADD__(v9, 40 * v10))
    {
      v5 = 147;
      v6 = 274;
      goto LABEL_12;
    }
    v11 = v9 + 40 * v10;
    result = oid_add_arc(a1, v11);
    if ((_DWORD)result)
    {
      while (CBS_len((uint64_t)a2))
      {
        result = oid_parse_arc_txt(a2, &v11, &v8, 0);
        if ((_DWORD)result)
        {
          v7 = oid_add_arc(a1, v11);
          result = 0;
          if (v7)
            continue;
        }
        return result;
      }
      return 1;
    }
  }
  return result;
}

size_t i2t_ASN1_OBJECT_internal(ASN1_OBJECT *a1, char *a2, unsigned int a3, int a4)
{
  size_t v8;
  _OWORD v10[2];
  uint64_t v11;
  char *__source;

  __source = 0;
  if ((a3 & 0x80000000) != 0)
    return 0;
  if (a3)
    *a2 = 0;
  if (!a1 || !a1->data)
    return 0;
  v11 = 0;
  memset(v10, 0, sizeof(v10));
  if (CBB_init((uint64_t)v10, 0)
    && i2t_ASN1_OBJECT_cbb(a1, (char **)v10, a4)
    && CBB_finish((uint64_t *)v10, &__source, &v11))
  {
    v8 = strlcpy(a2, __source, a3);
  }
  else
  {
    v8 = 0;
  }
  CBB_cleanup((uint64_t *)v10);
  free(__source);
  return v8;
}

uint64_t i2t_ASN1_OBJECT_cbb(ASN1_OBJECT *o, char **a2, int a3)
{
  uint64_t result;
  unint64_t v6;
  uint64_t v7;
  uint64_t i;
  int v9;
  int v10;
  const char *v11;
  size_t v12;
  _QWORD v13[3];
  unint64_t v14;

  if (!a3
    && (v9 = OBJ_obj2nid(o)) != 0
    && ((v10 = v9, (v11 = OBJ_nid2ln(v9)) != 0) || (v11 = OBJ_nid2sn(v10)) != 0))
  {
    v12 = strlen(v11);
    result = CBB_add_bytes(a2, v11, v12);
    if ((_DWORD)result)
      return CBB_add_u8(a2, 0) != 0;
  }
  else
  {
    memset(v13, 0, sizeof(v13));
    CBS_init(v13, (uint64_t)o->data, o->length);
    v14 = 0;
    result = oid_parse_arc(v13, &v14);
    if ((_DWORD)result)
    {
      v6 = v14;
      v7 = v14 / 0x28 >= 2 ? 2 : v14 / 0x28;
      result = oid_add_arc_txt(a2, v7, 1);
      if ((_DWORD)result)
      {
        for (i = v6 - 40 * v7; ; i = v14)
        {
          result = oid_add_arc_txt(a2, i, 0);
          if (!(_DWORD)result)
            break;
          if (!CBS_len((uint64_t)v13))
            return CBB_add_u8(a2, 0) != 0;
          result = oid_parse_arc(v13, &v14);
          if (!(_DWORD)result)
            break;
        }
      }
    }
  }
  return result;
}

int i2t_ASN1_OBJECT(char *buf, int buf_len, ASN1_OBJECT *a)
{
  return i2t_ASN1_OBJECT_internal(a, buf, buf_len, 0);
}

ASN1_OBJECT *t2i_ASN1_OBJECT_internal(const char *a1)
{
  size_t v2;
  ASN1_OBJECT *v3;
  ASN1_OBJECT *v4;
  _QWORD v6[3];
  _OWORD v7[2];
  unint64_t v8;
  unsigned __int8 *v9;

  v8 = 0;
  v9 = 0;
  memset(v6, 0, sizeof(v6));
  memset(v7, 0, sizeof(v7));
  v2 = strlen(a1);
  CBS_init(v6, (uint64_t)a1, v2);
  if (CBB_init((uint64_t)v7, 0) && a2c_ASN1_OBJECT_internal((char **)v7, v6))
  {
    v3 = 0;
    if (CBB_finish((uint64_t *)v7, &v9, &v8))
    {
      if (!(v8 >> 31))
      {
        v4 = ASN1_OBJECT_new();
        v3 = v4;
        if (v4)
        {
          v4->data = v9;
          v4->length = v8;
          v4->flags |= 8u;
          v9 = 0;
        }
      }
    }
  }
  else
  {
    v3 = 0;
  }
  CBB_cleanup((uint64_t *)v7);
  free(v9);
  return v3;
}

int i2a_ASN1_OBJECT(BIO *bp, ASN1_OBJECT *a)
{
  int v4;
  BIO *v5;
  const char *v6;
  int v8;
  _OWORD v9[2];
  uint64_t v10;
  char *v11;

  v11 = 0;
  if (!a || !a->data)
    return BIO_write(bp, "NULL", 4);
  v10 = 0;
  memset(v9, 0, sizeof(v9));
  if (CBB_init((uint64_t)v9, 0))
  {
    if (!i2t_ASN1_OBJECT_cbb(a, (char **)v9, 0))
    {
      v6 = "<INVALID>";
      v5 = bp;
      v4 = 9;
      goto LABEL_10;
    }
    if (CBB_finish((uint64_t *)v9, &v11, &v10))
    {
      v4 = strlen(v11);
      v5 = bp;
      v6 = v11;
LABEL_10:
      v8 = BIO_write(v5, v6, v4);
      goto LABEL_11;
    }
  }
  v8 = -1;
LABEL_11:
  CBB_cleanup((uint64_t *)v9);
  free(v11);
  return v8;
}

uint64_t c2i_ASN1_OBJECT_cbs(ASN1_OBJECT **a1, _QWORD *a2)
{
  ASN1_OBJECT **v3;
  ASN1_OBJECT *v4;
  int v5;
  ASN1_OBJECT *v7;
  _QWORD v8[3];
  unint64_t v9;
  ASN1_OBJECT **v10;

  v10 = 0;
  v9 = 0;
  memset(v8, 0, sizeof(v8));
  if (a1)
  {
    v3 = a1;
    v4 = *a1;
    if (v4)
    {
      ASN1_OBJECT_free(v4);
      *v3 = 0;
    }
    CBS_dup(a2, v8);
    if (CBS_len((uint64_t)v8))
    {
      while (CBS_len((uint64_t)v8))
      {
        if (!oid_parse_arc(v8, 0))
        {
          v5 = 551;
          goto LABEL_9;
        }
      }
      if (!CBS_stow((uint64_t)a2, (void **)&v10, &v9) || v9 >> 31)
      {
        a1 = v10;
      }
      else
      {
        v7 = ASN1_OBJECT_new();
        a1 = v10;
        if (v7)
        {
          v7->data = (unsigned __int8 *)v10;
          v7->length = v9;
          v7->flags |= 8u;
          *v3 = v7;
          return 1;
        }
      }
    }
    else
    {
      v5 = 546;
LABEL_9:
      ERR_put_error(13, 4095, 216, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/a_object.c", v5);
      a1 = 0;
    }
  }
  free(a1);
  return 0;
}

uint64_t oid_parse_arc(_QWORD *a1, unint64_t *a2)
{
  unint64_t v4;
  uint64_t result;
  BOOL v6;
  BOOL v7;
  BOOL v8;
  unint64_t v9;
  unsigned __int8 v10;

  v4 = 0;
  v10 = 0;
  while (1)
  {
    result = CBS_get_u8(a1, &v10);
    if (!(_DWORD)result)
      break;
    result = 0;
    v6 = !a2 || v4 >> 57 == 0;
    v7 = !v6;
    v8 = v10 == 128 && v4 == 0;
    if (v8 || v7)
      break;
    v9 = v10 & 0x7F | (v4 << 7);
    v4 = v9;
    if ((v10 & 0x80) == 0)
    {
      if (a2)
        *a2 = v9;
      return 1;
    }
  }
  return result;
}

ASN1_OBJECT *__cdecl c2i_ASN1_OBJECT(ASN1_OBJECT **a, const unsigned __int8 **pp, uint64_t length)
{
  ASN1_OBJECT *result;
  _QWORD v7[3];
  ASN1_OBJECT *v8;

  v8 = 0;
  if (a)
  {
    ASN1_OBJECT_free(*a);
    *a = 0;
  }
  if (length < 0)
  {
    ERR_put_error(13, 4095, 136, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/a_object.c", 592);
    return 0;
  }
  memset(v7, 0, sizeof(v7));
  CBS_init(v7, (uint64_t)*pp, length);
  if (!c2i_ASN1_OBJECT_cbs(&v8, v7))
    return 0;
  *pp = (const unsigned __int8 *)CBS_data((uint64_t)v7);
  result = v8;
  if (a)
    *a = v8;
  return result;
}

int i2d_ASN1_OBJECT(ASN1_OBJECT *a, unsigned __int8 **pp)
{
  int v4;
  unsigned __int8 *ppa;

  if (!a || !a->data)
    return 0;
  v4 = ASN1_object_size(0, a->length, 6);
  if (pp)
  {
    ppa = *pp;
    ASN1_put_object(&ppa, 0, a->length, 6, 0);
    memcpy(ppa, a->data, a->length);
    *pp = &ppa[a->length];
  }
  return v4;
}

ASN1_OBJECT *__cdecl d2i_ASN1_OBJECT(ASN1_OBJECT **a, const unsigned __int8 **pp, uint64_t length)
{
  ASN1_OBJECT *result;
  int v7;
  int v8;
  _QWORD v9[3];
  uint64_t v10[3];
  int v11;
  ASN1_OBJECT *v12;

  v12 = 0;
  if (a)
  {
    ASN1_OBJECT_free(*a);
    *a = 0;
  }
  if (length < 0)
  {
    v7 = 136;
    v8 = 644;
LABEL_12:
    ERR_put_error(13, 4095, v7, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/a_object.c", v8);
    return 0;
  }
  v11 = 0;
  memset(v10, 0, sizeof(v10));
  memset(v9, 0, sizeof(v9));
  CBS_init(v10, (uint64_t)*pp, length);
  if (!asn1_get_primitive(v10, 0, &v11, v9))
  {
    v7 = 102;
    v8 = 651;
    goto LABEL_12;
  }
  if (v11 != 6)
  {
    v7 = 116;
    v8 = 655;
    goto LABEL_12;
  }
  if (!c2i_ASN1_OBJECT_cbs(&v12, v9))
    return 0;
  *pp = (const unsigned __int8 *)CBS_data((uint64_t)v10);
  result = v12;
  if (a)
    *a = v12;
  return result;
}

uint64_t oid_parse_arc_txt(_QWORD *a1, unint64_t *a2, unsigned __int8 *a3, int a4)
{
  int v7;
  unint64_t v8;
  uint64_t result;
  unsigned __int8 v10;
  BOOL v11;
  int v13;
  int v14;
  unsigned __int8 v15;

  v15 = 0;
  if (!a4)
  {
    result = CBS_get_u8(a1, &v15);
    if (!(_DWORD)result)
      return result;
    if (*a3)
    {
      if (v15 != (char)*a3)
      {
LABEL_26:
        v13 = 131;
        v14 = 199;
        goto LABEL_32;
      }
    }
    else if (v15 != 32 && v15 != 46)
    {
      goto LABEL_26;
    }
    *a3 = v15;
  }
  if (!CBS_len((uint64_t)a1))
  {
LABEL_22:
    v13 = 187;
    v14 = 238;
LABEL_32:
    ERR_put_error(13, 4095, v13, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/a_object.c", v14);
    return 0;
  }
  v7 = 0;
  v8 = 0;
  while (1)
  {
    result = CBS_peek_u8((uint64_t)a1, &v15);
    if (!(_DWORD)result)
      return result;
    if (v15 == 32 || v15 == 46)
    {
      if (!v7)
        goto LABEL_22;
LABEL_21:
      *a2 = v8;
      return 1;
    }
    result = CBS_get_u8(a1, &v15);
    if (!(_DWORD)result)
      return result;
    if ((v15 - 58) <= 0xF5u)
    {
      if (a4)
      {
        v13 = 131;
        v14 = 216;
      }
      else
      {
        v13 = 130;
        v14 = 219;
      }
      goto LABEL_32;
    }
    v10 = v15 - 48;
    v15 -= 48;
    v11 = v7-- != 0;
    if (v11 && !v8 && !v10)
    {
      v13 = 187;
      v14 = 225;
      goto LABEL_32;
    }
    if (v8 >= 0x199999999999999ALL)
    {
      v13 = 155;
      v14 = 231;
      goto LABEL_32;
    }
    v8 = 10 * v8 + v10;
    if (!CBS_len((uint64_t)a1))
      goto LABEL_21;
  }
}

uint64_t oid_add_arc(char **a1, unint64_t a2)
{
  int v4;
  uint64_t i;
  uint64_t v6;
  uint64_t result;

  v4 = 0;
  for (i = 63; i != -7; i -= 7)
  {
    v6 = (a2 >> i) & 0x7F;
    if (v4 || !i || (_DWORD)v6)
    {
      result = CBB_add_u8(a1, v6 | ((i != 0) << 7));
      if (!(_DWORD)result)
        return result;
      v4 = 1;
    }
    else
    {
      v4 = 0;
    }
  }
  return 1;
}

BOOL oid_add_arc_txt(char **a1, uint64_t a2, int a3)
{
  unsigned int v4;
  char __str[22];
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  if (a3)
    v4 = snprintf(__str, 0x16uLL, "%llu");
  else
    v4 = snprintf(__str, 0x16uLL, ".%llu");
  return v4 <= 0x15 && CBB_add_bytes(a1, __str, v4) != 0;
}

uint64_t PKCS7_ctrl(PKCS7 *p7, int cmd, uint64_t larg, char *parg)
{
  int v7;
  char *ptr;
  int v9;
  int v10;

  v7 = OBJ_obj2nid(p7->type);
  if (cmd != 2)
  {
    if (cmd == 1)
    {
      if (v7 == 22)
      {
        p7->detached = larg;
        if (larg << 32)
        {
          larg = (int)larg;
          if (OBJ_obj2nid(*(const ASN1_OBJECT **)(*((_QWORD *)p7->d.ptr + 5) + 24)) == 21)
          {
            ASN1_OCTET_STRING_free(*(ASN1_OCTET_STRING **)(*((_QWORD *)p7->d.ptr + 5) + 32));
            *(_QWORD *)(*((_QWORD *)p7->d.ptr + 5) + 32) = 0;
          }
          return larg;
        }
        return 0;
      }
      v9 = 104;
      v10 = 88;
    }
    else
    {
      v9 = 110;
      v10 = 107;
    }
LABEL_13:
    ERR_put_error(33, 4095, v9, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/pkcs7/pk7_lib.c", v10);
    return 0;
  }
  if (v7 != 22)
  {
    v9 = 104;
    v10 = 101;
    goto LABEL_13;
  }
  ptr = p7->d.ptr;
  if (ptr)
    larg = *(_QWORD *)(*((_QWORD *)ptr + 5) + 32) == 0;
  else
    larg = 1;
  p7->detached = larg;
  return larg;
}

int PKCS7_content_new(PKCS7 *p7, int nid)
{
  PKCS7 *v4;
  PKCS7 *v5;

  v4 = PKCS7_new();
  if (v4)
  {
    v5 = v4;
    if (PKCS7_set_type(v4, nid) && PKCS7_set_content(p7, v5))
    {
      LODWORD(v4) = 1;
    }
    else
    {
      PKCS7_free(v5);
      LODWORD(v4) = 0;
    }
  }
  return (int)v4;
}

int PKCS7_set_type(PKCS7 *p7, int type)
{
  ASN1_OBJECT *v4;
  char *v5;
  char *v6;
  int v7;
  char *v8;
  ASN1_OBJECT *v9;
  ASN1_OBJECT **v10;
  char *v11;
  char *v12;
  char *v13;

  v4 = OBJ_nid2obj(type);
  switch(type)
  {
    case 21:
      p7->type = v4;
      v5 = (char *)ASN1_OCTET_STRING_new();
      p7->d.ptr = v5;
      return v5 != 0;
    case 22:
      p7->type = v4;
      v6 = (char *)PKCS7_SIGNED_new();
      p7->d.ptr = v6;
      if (!v6)
        return 0;
      v7 = 1;
      if (!ASN1_INTEGER_set(*(ASN1_INTEGER **)v6, 1))
      {
        PKCS7_SIGNED_free(p7->d.sign);
        p7->d.ptr = 0;
        return 0;
      }
      return v7;
    case 23:
      p7->type = v4;
      v8 = (char *)PKCS7_ENVELOPE_new();
      p7->d.ptr = v8;
      if (!v8 || !ASN1_INTEGER_set(*(ASN1_INTEGER **)v8, 0))
        return 0;
      v9 = OBJ_nid2obj(21);
      v10 = (ASN1_OBJECT **)*((_QWORD *)p7->d.ptr + 2);
      goto LABEL_20;
    case 24:
      p7->type = v4;
      v11 = (char *)PKCS7_SIGN_ENVELOPE_new();
      p7->d.ptr = v11;
      if (!v11 || !ASN1_INTEGER_set(*(ASN1_INTEGER **)v11, 1))
        return 0;
      v9 = OBJ_nid2obj(21);
      v10 = (ASN1_OBJECT **)*((_QWORD *)p7->d.ptr + 5);
      goto LABEL_20;
    case 25:
      p7->type = v4;
      v12 = (char *)PKCS7_DIGEST_new();
      p7->d.ptr = v12;
      return v12 && ASN1_INTEGER_set(*(ASN1_INTEGER **)v12, 0);
    case 26:
      p7->type = v4;
      v13 = (char *)PKCS7_ENCRYPT_new();
      p7->d.ptr = v13;
      if (!v13 || !ASN1_INTEGER_set(*(ASN1_INTEGER **)v13, 0))
        return 0;
      v9 = OBJ_nid2obj(21);
      v10 = (ASN1_OBJECT **)*((_QWORD *)p7->d.ptr + 1);
LABEL_20:
      *v10 = v9;
      return 1;
    default:
      ERR_put_error(33, 4095, 112, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/pkcs7/pk7_lib.c", 226);
      return 0;
  }
}

int PKCS7_set_content(PKCS7 *p7, PKCS7 *p7_data)
{
  int v4;
  char *v5;
  PKCS7 *v6;
  char *ptr;
  PKCS7 *v8;

  v4 = OBJ_obj2nid(p7->type);
  if (v4 == 25)
  {
    ptr = p7->d.ptr;
    v8 = (PKCS7 *)*((_QWORD *)ptr + 2);
    if (v8)
    {
      PKCS7_free(v8);
      ptr = p7->d.ptr;
    }
    *((_QWORD *)ptr + 2) = p7_data;
    return 1;
  }
  if (v4 == 22)
  {
    v5 = p7->d.ptr;
    v6 = (PKCS7 *)*((_QWORD *)v5 + 5);
    if (v6)
    {
      PKCS7_free(v6);
      v5 = p7->d.ptr;
    }
    *((_QWORD *)v5 + 5) = p7_data;
    return 1;
  }
  ERR_put_error(33, 4095, 112, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/pkcs7/pk7_lib.c", 156);
  return 0;
}

int PKCS7_set0_type_other(PKCS7 *p7, int type, ASN1_TYPE *other)
{
  p7->type = OBJ_nid2obj(type);
  p7->d.ptr = (char *)other;
  return 1;
}

int PKCS7_add_signer(PKCS7 *p7, PKCS7_SIGNER_INFO *p7i)
{
  int v4;
  char *ptr;
  STACK *v6;
  STACK *v7;
  int v8;
  int v9;
  char *v10;
  X509_ALGOR *v11;
  ASN1_TYPE *v12;
  int v14;
  int v15;

  v4 = OBJ_obj2nid(p7->type);
  if (v4 != 24 && v4 != 22)
  {
    v14 = 113;
    v15 = 263;
LABEL_13:
    ERR_put_error(33, 4095, v14, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/pkcs7/pk7_lib.c", v15);
    return 0;
  }
  ptr = p7->d.ptr;
  v6 = (STACK *)*((_QWORD *)ptr + 1);
  v7 = (STACK *)*((_QWORD *)ptr + 4);
  v8 = OBJ_obj2nid(p7i->digest_alg->algorithm);
  if (sk_num(v6) >= 1)
  {
    v9 = 0;
    do
    {
      v10 = sk_value(v6, v9);
      if (OBJ_obj2nid(*(const ASN1_OBJECT **)v10) == v8)
        return sk_push(v7, (char *)p7i) != 0;
    }
    while (++v9 < sk_num(v6));
  }
  v11 = X509_ALGOR_new();
  if (!v11 || (v12 = ASN1_TYPE_new(), (v11->parameter = v12) == 0))
  {
    X509_ALGOR_free(v11);
    v14 = 65;
    v15 = 283;
    goto LABEL_13;
  }
  v11->algorithm = OBJ_nid2obj(v8);
  v11->parameter->type = 5;
  if (sk_push(v6, (char *)v11))
    return sk_push(v7, (char *)p7i) != 0;
  X509_ALGOR_free(v11);
  return 0;
}

int PKCS7_add_certificate(PKCS7 *p7, X509 *x509)
{
  int v4;
  STACK **v5;
  STACK *v6;
  int v7;
  int v8;
  int v9;

  v4 = OBJ_obj2nid(p7->type);
  if (v4 != 24 && v4 != 22)
  {
    v8 = 113;
    v9 = 315;
LABEL_9:
    ERR_put_error(33, 4095, v8, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/pkcs7/pk7_lib.c", v9);
    return 0;
  }
  v5 = (STACK **)(p7->d.ptr + 16);
  if (!*v5)
  {
    v6 = sk_new_null();
    *v5 = v6;
    if (!v6)
    {
      v8 = 65;
      v9 = 322;
      goto LABEL_9;
    }
  }
  v7 = 1;
  CRYPTO_add_lock(&x509->references, 1, 3, 0, 0);
  if (!sk_push(*v5, (char *)x509))
  {
    X509_free(x509);
    return 0;
  }
  return v7;
}

int PKCS7_add_crl(PKCS7 *p7, X509_CRL *x509)
{
  int v4;
  STACK **v5;
  STACK *v6;
  int v7;
  int v8;
  int v9;

  v4 = OBJ_obj2nid(p7->type);
  if (v4 != 24 && v4 != 22)
  {
    v8 = 113;
    v9 = 349;
LABEL_9:
    ERR_put_error(33, 4095, v8, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/pkcs7/pk7_lib.c", v9);
    return 0;
  }
  v5 = (STACK **)(p7->d.ptr + 24);
  if (!*v5)
  {
    v6 = sk_new_null();
    *v5 = v6;
    if (!v6)
    {
      v8 = 65;
      v9 = 356;
      goto LABEL_9;
    }
  }
  v7 = 1;
  CRYPTO_add_lock(&x509->references, 1, 6, 0, 0);
  if (!sk_push(*v5, (char *)x509))
  {
    X509_CRL_free(x509);
    return 0;
  }
  return v7;
}

int PKCS7_SIGNER_INFO_set(PKCS7_SIGNER_INFO *p7i, X509 *x509, EVP_PKEY *pkey, const EVP_MD *dgst)
{
  PKCS7_ISSUER_AND_SERIAL *issuer_and_serial;
  X509_NAME *issuer_name;
  ASN1_INTEGER *serialNumber;
  ASN1_INTEGER *v11;
  X509_ALGOR *digest_alg;
  int v13;
  ASN1_OBJECT *v14;
  char *ptr;
  uint64_t (*v16)(EVP_PKEY *, uint64_t, _QWORD, PKCS7_SIGNER_INFO *);
  int v17;
  int v18;
  int v19;
  int v20;

  if (!ASN1_INTEGER_set(p7i->version, 1))
    return 0;
  issuer_and_serial = p7i->issuer_and_serial;
  issuer_name = X509_get_issuer_name(x509);
  if (!X509_NAME_set(&issuer_and_serial->issuer, issuer_name))
    return 0;
  ASN1_INTEGER_free(p7i->issuer_and_serial->serial);
  serialNumber = X509_get_serialNumber(x509);
  v11 = ASN1_INTEGER_dup(serialNumber);
  p7i->issuer_and_serial->serial = v11;
  if (!v11)
    return 0;
  CRYPTO_add_lock(&pkey->references, 1, 10, 0, 0);
  p7i->pkey = pkey;
  digest_alg = p7i->digest_alg;
  v13 = EVP_MD_type(dgst);
  v14 = OBJ_nid2obj(v13);
  X509_ALGOR_set0(digest_alg, v14, 5, 0);
  ptr = pkey->pkey.ptr;
  if (!ptr)
    goto LABEL_8;
  v16 = (uint64_t (*)(EVP_PKEY *, uint64_t, _QWORD, PKCS7_SIGNER_INFO *))*((_QWORD *)ptr + 22);
  if (!v16)
    goto LABEL_8;
  v17 = 1;
  v18 = v16(pkey, 1, 0, p7i);
  if (v18 <= 0)
  {
    if (v18 != -2)
    {
      v19 = 147;
      v20 = 404;
      goto LABEL_9;
    }
LABEL_8:
    v19 = 148;
    v20 = 408;
LABEL_9:
    ERR_put_error(33, 4095, v19, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/pkcs7/pk7_lib.c", v20);
    return 0;
  }
  return v17;
}

PKCS7_SIGNER_INFO *__cdecl PKCS7_add_signature(PKCS7 *p7, X509 *x509, EVP_PKEY *pkey, const EVP_MD *dgst)
{
  const EVP_MD *v4;
  PKCS7_SIGNER_INFO *v8;
  PKCS7_SIGNER_INFO *v9;
  const char *v10;
  const EVP_MD *digestbyname;

  v4 = dgst;
  if (!dgst)
  {
    if ((int)EVP_PKEY_get_default_digest_nid((uint64_t)pkey) < 1)
      return 0;
    v10 = OBJ_nid2sn(0);
    digestbyname = EVP_get_digestbyname(v10);
    if (!digestbyname)
    {
      ERR_put_error(33, 4095, 151, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/pkcs7/pk7_lib.c", 425);
      return 0;
    }
    v4 = digestbyname;
  }
  v8 = PKCS7_SIGNER_INFO_new();
  v9 = v8;
  if (v8 && (!PKCS7_SIGNER_INFO_set(v8, x509, pkey, v4) || !PKCS7_add_signer(p7, v9)))
  {
    PKCS7_SIGNER_INFO_free(v9);
    return 0;
  }
  return v9;
}

int PKCS7_set_digest(PKCS7 *p7, const EVP_MD *md)
{
  ASN1_TYPE *v4;
  int v5;

  if (OBJ_obj2nid(p7->type) != 25)
  {
    ERR_put_error(33, 4095, 113, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/pkcs7/pk7_lib.c", 457);
    return 1;
  }
  v4 = ASN1_TYPE_new();
  *(_QWORD *)(*((_QWORD *)p7->d.ptr + 1) + 8) = v4;
  if (v4)
  {
    **(_DWORD **)(*((_QWORD *)p7->d.ptr + 1) + 8) = 5;
    v5 = EVP_MD_type(md);
    **((_QWORD **)p7->d.ptr + 1) = OBJ_nid2obj(v5);
    return 1;
  }
  ERR_put_error(33, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/pkcs7/pk7_lib.c", 449);
  return 0;
}

STACK *__cdecl PKCS7_get_signer_info(STACK *p7)
{
  STACK *v1;

  if (p7)
  {
    v1 = p7;
    if (*(_QWORD *)&p7[1].num
      && (OBJ_obj2nid((const ASN1_OBJECT *)p7->comp) == 22 || OBJ_obj2nid((const ASN1_OBJECT *)v1->comp) == 24))
    {
      return *(STACK **)(*(_QWORD *)&v1[1].num + 32);
    }
    else
    {
      return 0;
    }
  }
  return p7;
}

_QWORD *PKCS7_SIGNER_INFO_get0_algs(_QWORD *result, _QWORD *a2, _QWORD *a3, _QWORD *a4)
{
  if (a2)
    *a2 = result[7];
  if (a3)
    *a3 = result[2];
  if (a4)
    *a4 = result[4];
  return result;
}

uint64_t PKCS7_RECIP_INFO_get0_alg(uint64_t result, _QWORD *a2)
{
  if (a2)
    *a2 = *(_QWORD *)(result + 16);
  return result;
}

PKCS7_RECIP_INFO *__cdecl PKCS7_add_recipient(PKCS7 *p7, X509 *x509)
{
  PKCS7_RECIP_INFO *v4;
  PKCS7_RECIP_INFO *v5;

  v4 = PKCS7_RECIP_INFO_new();
  v5 = v4;
  if (v4 && (!PKCS7_RECIP_INFO_set(v4, x509) || !PKCS7_add_recipient_info(p7, v5)))
  {
    PKCS7_RECIP_INFO_free(v5);
    return 0;
  }
  return v5;
}

int PKCS7_RECIP_INFO_set(PKCS7_RECIP_INFO *p7i, X509 *x509)
{
  PKCS7_ISSUER_AND_SERIAL *issuer_and_serial;
  X509_NAME *issuer_name;
  ASN1_INTEGER *serialNumber;
  ASN1_INTEGER *v7;
  EVP_PKEY *pubkey;
  EVP_PKEY *v9;
  char *ptr;
  uint64_t (*v11)(EVP_PKEY *, uint64_t, _QWORD, PKCS7_RECIP_INFO *);
  int v12;
  int v13;
  int v14;
  int v15;

  if (ASN1_INTEGER_set(p7i->version, 0))
  {
    issuer_and_serial = p7i->issuer_and_serial;
    issuer_name = X509_get_issuer_name(x509);
    if (X509_NAME_set(&issuer_and_serial->issuer, issuer_name))
    {
      ASN1_INTEGER_free(p7i->issuer_and_serial->serial);
      serialNumber = X509_get_serialNumber(x509);
      v7 = ASN1_INTEGER_dup(serialNumber);
      p7i->issuer_and_serial->serial = v7;
      if (v7)
      {
        pubkey = X509_get_pubkey(x509);
        v9 = pubkey;
        if (pubkey
          && (ptr = pubkey->pkey.ptr) != 0
          && (v11 = (uint64_t (*)(EVP_PKEY *, uint64_t, _QWORD, PKCS7_RECIP_INFO *))*((_QWORD *)ptr + 22)) != 0)
        {
          v12 = v11(pubkey, 2, 0, p7i);
          if (v12 == -2)
          {
            v13 = 150;
            v14 = 567;
          }
          else
          {
            if (v12 > 0)
            {
              EVP_PKEY_free(v9);
              v15 = 1;
              CRYPTO_add_lock(&x509->references, 1, 3, 0, 0);
              p7i->cert = x509;
              return v15;
            }
            v13 = 149;
            v14 = 571;
          }
        }
        else
        {
          v13 = 150;
          v14 = 560;
        }
        ERR_put_error(33, 4095, v13, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/pkcs7/pk7_lib.c", v14);
        EVP_PKEY_free(v9);
      }
    }
  }
  return 0;
}

int PKCS7_add_recipient_info(PKCS7 *p7, PKCS7_RECIP_INFO *ri)
{
  int v4;
  char *v5;

  v4 = OBJ_obj2nid(p7->type);
  if (v4 == 23)
  {
    v5 = p7->d.ptr + 8;
    return sk_push(*(STACK **)v5, (char *)ri) != 0;
  }
  if (v4 == 24)
  {
    v5 = p7->d.ptr + 48;
    return sk_push(*(STACK **)v5, (char *)ri) != 0;
  }
  ERR_put_error(33, 4095, 113, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/pkcs7/pk7_lib.c", 531);
  return 0;
}

X509 *__cdecl PKCS7_cert_from_signer_info(PKCS7 *p7, PKCS7_SIGNER_INFO *si)
{
  if (OBJ_obj2nid(p7->type) == 22)
    return X509_find_by_issuer_and_serial(*((STACK **)p7->d.ptr + 2), si->issuer_and_serial->issuer, si->issuer_and_serial->serial);
  else
    return 0;
}

int PKCS7_set_cipher(PKCS7 *p7, const EVP_CIPHER *cipher)
{
  int v4;
  char *v5;
  uint64_t v6;
  int v8;
  int v9;

  v4 = OBJ_obj2nid(p7->type);
  if (v4 == 23)
  {
    v5 = p7->d.ptr + 16;
  }
  else
  {
    if (v4 != 24)
    {
      v8 = 113;
      v9 = 615;
      goto LABEL_9;
    }
    v5 = p7->d.ptr + 40;
  }
  v6 = *(_QWORD *)v5;
  if (EVP_CIPHER_type(cipher))
  {
    *(_QWORD *)(v6 + 24) = cipher;
    return 1;
  }
  v8 = 144;
  v9 = 622;
LABEL_9:
  ERR_put_error(33, 4095, v8, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/pkcs7/pk7_lib.c", v9);
  return 0;
}

uint64_t PKCS7_stream(_QWORD *a1, uint64_t a2)
{
  uint64_t result;
  uint64_t v5;

  switch(OBJ_obj2nid(*(const ASN1_OBJECT **)(a2 + 24)))
  {
    case 21:
      result = *(_QWORD *)(a2 + 32);
      if (result)
        goto LABEL_12;
      break;
    case 22:
      result = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 32) + 40) + 32);
      if (result)
        goto LABEL_12;
      break;
    case 23:
      result = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 32) + 16) + 16);
      if (result)
        goto LABEL_12;
      result = (uint64_t)ASN1_OCTET_STRING_new();
      v5 = *(_QWORD *)(*(_QWORD *)(a2 + 32) + 16);
      goto LABEL_11;
    case 24:
      result = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 32) + 40) + 16);
      if (result)
        goto LABEL_12;
      result = (uint64_t)ASN1_OCTET_STRING_new();
      v5 = *(_QWORD *)(*(_QWORD *)(a2 + 32) + 40);
LABEL_11:
      *(_QWORD *)(v5 + 16) = result;
      if (result)
      {
LABEL_12:
        *(_QWORD *)(result + 16) |= 0x10uLL;
        *a1 = result + 8;
        result = 1;
      }
      break;
    default:
      result = 0;
      break;
  }
  return result;
}

uint64_t Camellia_set_key(unsigned __int8 *a1, int a2, unsigned int *a3)
{
  uint64_t result;
  unsigned int v6;

  result = 0xFFFFFFFFLL;
  if (a1 && a3)
  {
    if (a2 == 128 || a2 == 256 || a2 == 192)
    {
      v6 = Camellia_Ekeygen(a2, a1, a3);
      result = 0;
      a3[68] = v6;
    }
    else
    {
      return 4294967294;
    }
  }
  return result;
}

uint64_t Camellia_encrypt(unsigned int *a1, _BYTE *a2, _DWORD *a3)
{
  return Camellia_EncryptBlock_Rounds(a3[68], a1, a3, a2);
}

uint64_t Camellia_decrypt(unsigned int *a1, _BYTE *a2, _DWORD *a3)
{
  return Camellia_DecryptBlock_Rounds(a3[68], a1, a3, a2);
}

BN_BLINDING *__cdecl BN_BLINDING_new(const BIGNUM *A, const BIGNUM *Ai, BIGNUM *mod)
{
  _QWORD *v6;
  BIGNUM *v7;
  BIGNUM *v8;
  BIGNUM *v9;

  v6 = malloc_type_calloc(1uLL, 0x50uLL, 0x10A0040DBBD1971uLL);
  if (v6)
  {
    if ((!A || (v7 = BN_dup(A), (*v6 = v7) != 0))
      && (!Ai || (v8 = BN_dup(Ai), (v6[1] = v8) != 0))
      && (v9 = BN_dup(mod), (v6[3] = v9) != 0))
    {
      if (BN_get_flags((uint64_t)mod, 4u))
        BN_set_flags(v6[3], 4);
      *((_DWORD *)v6 + 12) = -1;
      CRYPTO_THREADID_current(v6 + 4);
    }
    else
    {
      BN_BLINDING_free((BN_BLINDING *)v6);
      return 0;
    }
  }
  else
  {
    ERR_put_error(3, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/bn/bn_blind.c", 142);
  }
  return (BN_BLINDING *)v6;
}

void BN_BLINDING_free(BN_BLINDING *b)
{
  if (b)
  {
    BN_free(*(BIGNUM **)b);
    BN_free(*((BIGNUM **)b + 1));
    BN_free(*((BIGNUM **)b + 2));
    BN_free(*((BIGNUM **)b + 3));
    free(b);
  }
}

int BN_BLINDING_update(BN_BLINDING *b, BN_CTX *ctx)
{
  BIGNUM *v3;
  int v5;
  int v6;
  BN_BLINDING *param;

  v3 = *(BIGNUM **)b;
  if (!v3 || !*((_QWORD *)b + 1))
  {
    ERR_put_error(3, 4095, 107, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/bn/bn_blind.c", 192);
    LODWORD(param) = 0;
    goto LABEL_15;
  }
  v5 = *((_DWORD *)b + 12);
  if (v5 == -1)
  {
    *((_DWORD *)b + 12) = 1;
  }
  else
  {
    v6 = v5 + 1;
    *((_DWORD *)b + 12) = v6;
    if (v6 == 32 && *((_QWORD *)b + 2) && (*((_BYTE *)b + 56) & 2) == 0)
    {
      param = BN_BLINDING_create_param(b, 0, 0, ctx, 0, 0);
      if (!param)
        goto LABEL_15;
LABEL_14:
      LODWORD(param) = 1;
      goto LABEL_15;
    }
  }
  if ((*((_BYTE *)b + 56) & 1) != 0)
    goto LABEL_14;
  LODWORD(param) = BN_mod_mul(v3, v3, v3, *((const BIGNUM **)b + 3), ctx);
  if ((_DWORD)param)
  {
    LODWORD(param) = BN_mod_mul(*((BIGNUM **)b + 1), *((const BIGNUM **)b + 1), *((const BIGNUM **)b + 1), *((const BIGNUM **)b + 3), ctx);
    if ((_DWORD)param)
      goto LABEL_14;
  }
LABEL_15:
  if (*((_DWORD *)b + 12) == 32)
    *((_DWORD *)b + 12) = 0;
  return (int)param;
}

BN_BLINDING *__cdecl BN_BLINDING_create_param(BN_BLINDING *b, const BIGNUM *e, BIGNUM *m, BN_CTX *ctx, int (__cdecl *bn_mod_exp)(BIGNUM *, const BIGNUM *, const BIGNUM *, const BIGNUM *, BN_CTX *, BN_MONT_CTX *), BN_MONT_CTX *m_ctx)
{
  BN_BLINDING *v11;
  BIGNUM *v12;
  BIGNUM *v13;
  BIGNUM *v14;
  int v15;
  uint64_t (*v18)(_QWORD, _QWORD, _QWORD, _QWORD, BN_CTX *);
  int v19;

  v11 = b;
  if (!b)
  {
    v11 = BN_BLINDING_new(0, 0, m);
    if (!v11)
      return v11;
  }
  if (!*(_QWORD *)v11)
  {
    v12 = BN_new();
    *(_QWORD *)v11 = v12;
    if (!v12)
      goto LABEL_20;
  }
  if (!*((_QWORD *)v11 + 1))
  {
    v13 = BN_new();
    *((_QWORD *)v11 + 1) = v13;
    if (!v13)
      goto LABEL_20;
  }
  v14 = (BIGNUM *)*((_QWORD *)v11 + 2);
  if (e)
  {
    BN_free(v14);
    v14 = BN_dup(e);
    *((_QWORD *)v11 + 2) = v14;
  }
  if (!v14)
    goto LABEL_20;
  if (bn_mod_exp)
    *((_QWORD *)v11 + 9) = bn_mod_exp;
  if (m_ctx)
    *((_QWORD *)v11 + 8) = m_ctx;
  if (!BN_rand_range(*(BIGNUM **)v11, *((const BIGNUM **)v11 + 3)))
  {
LABEL_20:
    if (b)
      return v11;
LABEL_21:
    BN_BLINDING_free(v11);
    return 0;
  }
  v15 = -33;
  while (!BN_mod_inverse_ct(*((BIGNUM **)v11 + 1), *(const BIGNUM **)v11, *((const BIGNUM **)v11 + 3), ctx))
  {
    if ((ERR_peek_last_error() & 0xFFF) != 0x6C)
      goto LABEL_20;
    if (__CFADD__(v15++, 1))
    {
      ERR_put_error(3, 4095, 113, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/bn/bn_blind.c", 337);
      if (b)
        return v11;
      goto LABEL_21;
    }
    ERR_clear_error();
    if (!BN_rand_range(*(BIGNUM **)v11, *((const BIGNUM **)v11 + 3)))
      goto LABEL_20;
  }
  v18 = (uint64_t (*)(_QWORD, _QWORD, _QWORD, _QWORD, BN_CTX *))*((_QWORD *)v11 + 9);
  if (v18 && *((_QWORD *)v11 + 8))
  {
    v19 = v18(*(_QWORD *)v11, *(_QWORD *)v11, *((_QWORD *)v11 + 2), *((_QWORD *)v11 + 3), ctx);
    if (b)
      return v11;
  }
  else
  {
    v19 = BN_mod_exp_ct(*(BIGNUM **)v11, *(const BIGNUM **)v11, *((const BIGNUM **)v11 + 2), *((const BIGNUM **)v11 + 3), ctx);
    if (b)
      return v11;
  }
  if (!v19)
    goto LABEL_21;
  return v11;
}

int BN_BLINDING_convert(BIGNUM *n, BN_BLINDING *b, BN_CTX *ctx)
{
  return BN_BLINDING_convert_ex(n, 0, b, ctx);
}

int BN_BLINDING_convert_ex(BIGNUM *n, BIGNUM *r, BN_BLINDING *b, BN_CTX *a4)
{
  int result;
  _BOOL4 v9;

  if (!*(_QWORD *)b || !*((_QWORD *)b + 1))
  {
    ERR_put_error(3, 4095, 107, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/bn/bn_blind.c", 232);
    return 0;
  }
  if (*((_DWORD *)b + 12) == -1)
  {
    *((_DWORD *)b + 12) = 0;
    if (r)
    {
LABEL_6:
      v9 = bn_copy(r, *((const BIGNUM **)b + 1));
      return BN_mod_mul(n, n, *(const BIGNUM **)b, *((const BIGNUM **)b + 3), a4) && v9;
    }
  }
  else
  {
    result = BN_BLINDING_update(b, a4);
    if (!result)
      return result;
    if (r)
      goto LABEL_6;
  }
  v9 = 1;
  return BN_mod_mul(n, n, *(const BIGNUM **)b, *((const BIGNUM **)b + 3), a4) && v9;
}

int BN_BLINDING_invert(BIGNUM *n, BN_BLINDING *b, BN_CTX *ctx)
{
  return BN_BLINDING_invert_ex(n, 0, b, ctx);
}

int BN_BLINDING_invert_ex(BIGNUM *n, const BIGNUM *r, BN_BLINDING *b, BN_CTX *a4)
{
  const BIGNUM *v4;

  if (r)
  {
    v4 = r;
    return BN_mod_mul(n, n, v4, *((const BIGNUM **)b + 3), a4);
  }
  v4 = (const BIGNUM *)*((_QWORD *)b + 1);
  if (v4)
    return BN_mod_mul(n, n, v4, *((const BIGNUM **)b + 3), a4);
  ERR_put_error(3, 4095, 107, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/bn/bn_blind.c", 269);
  return 0;
}

uint64_t BN_BLINDING_thread_id(uint64_t a1)
{
  return a1 + 32;
}

unint64_t BN_BLINDING_get_flags(const BN_BLINDING *a1)
{
  return *((_QWORD *)a1 + 7);
}

void BN_BLINDING_set_flags(BN_BLINDING *a1, unint64_t a2)
{
  *((_QWORD *)a1 + 7) = a2;
}

void *EVP_rc4_hmac_md5()
{
  return &r4_hmac_md5_cipher;
}

uint64_t rc4_hmac_md5_init_key(const EVP_CIPHER_CTX *a1, const unsigned __int8 *a2)
{
  char *cipher_data;
  int v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;

  cipher_data = (char *)a1->cipher_data;
  v4 = EVP_CIPHER_CTX_key_length(a1);
  RC4_set_key((RC4_KEY *)cipher_data, v4, a2);
  MD5_Init((_MD5_CTX *)(cipher_data + 1032));
  v5 = *(_OWORD *)(cipher_data + 1064);
  v6 = *(_OWORD *)(cipher_data + 1080);
  *(_OWORD *)(cipher_data + 1156) = v5;
  *(_OWORD *)(cipher_data + 1172) = v6;
  v7 = *(_OWORD *)(cipher_data + 1096);
  *(_OWORD *)(cipher_data + 1188) = v7;
  v8 = *(_OWORD *)(cipher_data + 1108);
  *((_OWORD *)cipher_data + 75) = v8;
  v9 = *(_OWORD *)(cipher_data + 1032);
  v10 = *(_OWORD *)(cipher_data + 1048);
  *(_OWORD *)(cipher_data + 1124) = v9;
  *(_OWORD *)(cipher_data + 1140) = v10;
  *((_OWORD *)cipher_data + 78) = v5;
  *((_OWORD *)cipher_data + 79) = v6;
  *((_OWORD *)cipher_data + 80) = v7;
  *(_OWORD *)(cipher_data + 1292) = v8;
  *((_OWORD *)cipher_data + 76) = v9;
  *((_OWORD *)cipher_data + 77) = v10;
  *((_QWORD *)cipher_data + 164) = -1;
  return 1;
}

uint64_t rc4_hmac_md5_cipher(uint64_t a1, unsigned __int8 *outdata, unsigned __int8 *indata, size_t len)
{
  uint64_t v4;
  size_t v5;
  size_t v10;
  RC4_KEY *v11;
  unint64_t v12;
  const unsigned __int8 *v13;
  __int128 v14;
  __int128 v15;
  __int128 v18;
  __int128 v19;
  unsigned __int8 md[8];
  uint64_t v21;
  uint64_t v22;

  v22 = *MEMORY[0x24BDAC8D0];
  v4 = *(_QWORD *)(a1 + 120);
  v5 = *(_QWORD *)(v4 + 1312);
  if (v5 != -1 && v5 + 16 != len)
    return 0;
  if (*(_DWORD *)(a1 + 16))
  {
    if (v5 == -1)
      v10 = len;
    else
      v10 = *(_QWORD *)(v4 + 1312);
    MD5_Update((_MD5_CTX *)(v4 + 1216), indata, v10);
    if (v10 == len)
    {
      v11 = (RC4_KEY *)v4;
      v12 = len;
      v13 = indata;
    }
    else
    {
      if (indata != outdata)
        memcpy(outdata, indata, v10);
      MD5_Final(&outdata[v10], (_MD5_CTX *)(v4 + 1216));
      v18 = *(_OWORD *)(v4 + 1172);
      *(_OWORD *)(v4 + 1248) = *(_OWORD *)(v4 + 1156);
      *(_OWORD *)(v4 + 1264) = v18;
      *(_OWORD *)(v4 + 1280) = *(_OWORD *)(v4 + 1188);
      *(_OWORD *)(v4 + 1292) = *(_OWORD *)(v4 + 1200);
      v19 = *(_OWORD *)(v4 + 1140);
      *(_OWORD *)(v4 + 1216) = *(_OWORD *)(v4 + 1124);
      *(_OWORD *)(v4 + 1232) = v19;
      MD5_Update((_MD5_CTX *)(v4 + 1216), &outdata[v10], 0x10uLL);
      MD5_Final(&outdata[v10], (_MD5_CTX *)(v4 + 1216));
      v11 = (RC4_KEY *)v4;
      v12 = len;
      v13 = outdata;
    }
    RC4(v11, v12, v13, outdata);
  }
  else
  {
    RC4(*(RC4_KEY **)(a1 + 120), len, indata, outdata);
    if (v5 == -1)
    {
      MD5_Update((_MD5_CTX *)(v4 + 1216), outdata, len);
    }
    else
    {
      MD5_Update((_MD5_CTX *)(v4 + 1216), outdata, v5);
      MD5_Final(md, (_MD5_CTX *)(v4 + 1216));
      v14 = *(_OWORD *)(v4 + 1172);
      *(_OWORD *)(v4 + 1248) = *(_OWORD *)(v4 + 1156);
      *(_OWORD *)(v4 + 1264) = v14;
      *(_OWORD *)(v4 + 1280) = *(_OWORD *)(v4 + 1188);
      *(_OWORD *)(v4 + 1292) = *(_OWORD *)(v4 + 1200);
      v15 = *(_OWORD *)(v4 + 1140);
      *(_OWORD *)(v4 + 1216) = *(_OWORD *)(v4 + 1124);
      *(_OWORD *)(v4 + 1232) = v15;
      MD5_Update((_MD5_CTX *)(v4 + 1216), md, 0x10uLL);
      MD5_Final(md, (_MD5_CTX *)(v4 + 1216));
      if (*(_QWORD *)&outdata[v5] != *(_QWORD *)md || *(_QWORD *)&outdata[v5 + 8] != v21)
        return 0;
    }
  }
  *(_QWORD *)(v4 + 1312) = -1;
  return 1;
}

uint64_t rc4_hmac_md5_ctrl(uint64_t a1, int a2, int a3, _BYTE *data)
{
  uint64_t v6;
  uint64_t v7;
  unsigned int v8;
  BOOL v9;
  uint64_t v11;
  int8x16_t v12;
  uint64_t v13;
  int8x16_t v14;
  __int128 v15;
  __int128 v16;
  _OWORD v17[4];
  uint64_t v18;

  v18 = *MEMORY[0x24BDAC8D0];
  v6 = *(_QWORD *)(a1 + 120);
  if (a2 == 22)
  {
    v7 = a3 - 2;
    v8 = __rev16(*(unsigned __int16 *)&data[v7]);
    if (!*(_DWORD *)(a1 + 16))
    {
      v9 = v8 >= 0x10;
      v8 -= 16;
      if (!v9)
        return 0xFFFFFFFFLL;
      data[v7] = BYTE1(v8);
      data[a3 - 1] = v8;
    }
    v15 = *(_OWORD *)(v6 + 1080);
    *(_OWORD *)(v6 + 1248) = *(_OWORD *)(v6 + 1064);
    *(_OWORD *)(v6 + 1264) = v15;
    *(_OWORD *)(v6 + 1280) = *(_OWORD *)(v6 + 1096);
    *(_OWORD *)(v6 + 1292) = *(_OWORD *)(v6 + 1108);
    v16 = *(_OWORD *)(v6 + 1048);
    *(_OWORD *)(v6 + 1216) = *(_OWORD *)(v6 + 1032);
    *(_QWORD *)(v6 + 1312) = v8;
    *(_OWORD *)(v6 + 1232) = v16;
    MD5_Update((_MD5_CTX *)(v6 + 1216), data, a3);
    return 16;
  }
  if (a2 != 23)
    return 0xFFFFFFFFLL;
  memset(v17, 0, sizeof(v17));
  if (a3 < 65)
  {
    __memcpy_chk();
  }
  else
  {
    MD5_Init((_MD5_CTX *)(v6 + 1032));
    MD5_Update((_MD5_CTX *)(v6 + 1032), data, a3);
    MD5_Final((unsigned __int8 *)v17, (_MD5_CTX *)(v6 + 1032));
  }
  v11 = 0;
  v12.i64[0] = 0x3636363636363636;
  v12.i64[1] = 0x3636363636363636;
  do
  {
    v17[v11] = veorq_s8((int8x16_t)v17[v11], v12);
    ++v11;
  }
  while (v11 != 4);
  MD5_Init((_MD5_CTX *)(v6 + 1032));
  MD5_Update((_MD5_CTX *)(v6 + 1032), v17, 0x40uLL);
  v13 = 0;
  v14.i64[0] = 0x6A6A6A6A6A6A6A6ALL;
  v14.i64[1] = 0x6A6A6A6A6A6A6A6ALL;
  do
  {
    v17[v13] = veorq_s8((int8x16_t)v17[v13], v14);
    ++v13;
  }
  while (v13 != 4);
  MD5_Init((_MD5_CTX *)(v6 + 1124));
  MD5_Update((_MD5_CTX *)(v6 + 1124), v17, 0x40uLL);
  return 1;
}

void *EVP_ENCODE_CTX_new()
{
  return malloc_type_calloc(1uLL, 0x60uLL, 0x1000040565EDBD2uLL);
}

void EVP_EncodeInit(EVP_ENCODE_CTX *ctx)
{
  *(_QWORD *)&ctx->num = 0x3000000000;
  ctx->line_num = 0;
}

void EVP_EncodeUpdate(EVP_ENCODE_CTX *ctx, unsigned __int8 *out, int *outl, const unsigned __int8 *in, int inl)
{
  int v5;
  const unsigned __int8 *v6;
  int length;
  uint64_t num;
  uint64_t v12;
  int v13;
  int v14;
  unsigned __int8 *v15;
  unint64_t v16;
  int v17;
  uint64_t v18;
  unsigned __int8 *v19;

  *outl = 0;
  if (inl >= 1)
  {
    v5 = inl;
    v6 = in;
    length = ctx->length;
    if (length >= 81)
      OpenSSLDie("/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/encode.c", 156, "ctx->length <= (int)sizeof(ctx->enc_data)");
    num = ctx->num;
    v12 = length - num;
    v13 = inl - v12;
    if (inl >= (int)v12)
    {
      if ((_DWORD)num)
      {
        memcpy(&ctx->enc_data[num], in, length - num);
        v6 += v12;
        v14 = EVP_EncodeBlock(out, ctx->enc_data, ctx->length);
        ctx->num = 0;
        v15 = &out[v14];
        *(_WORD *)v15 = 10;
        out = v15 + 1;
        v16 = v14 + 1;
        length = ctx->length;
        v5 = v13;
      }
      else
      {
        v16 = 0;
      }
      if (v5 >= length && !(v16 >> 31))
      {
        do
        {
          v17 = EVP_EncodeBlock(out, v6, length);
          v18 = ctx->length;
          v6 += v18;
          v5 -= v18;
          v19 = &out[v17];
          *(_WORD *)v19 = 10;
          out = v19 + 1;
          v16 += v17 + 1;
          length = ctx->length;
        }
        while (v5 >= length && v16 >> 31 == 0);
      }
      if (v16 >> 31)
      {
        *outl = 0;
      }
      else
      {
        if (v5)
          memcpy(ctx->enc_data, v6, v5);
        ctx->num = v5;
        *outl = v16;
      }
    }
    else
    {
      memcpy(&ctx->enc_data[num], in, inl);
      ctx->num += v5;
    }
  }
}

int EVP_EncodeBlock(unsigned __int8 *t, const unsigned __int8 *f, int n)
{
  uint64_t v4;
  const unsigned __int8 *v5;
  unint64_t v6;
  unint64_t v7;
  int v8;
  int v9;
  unint64_t v10;
  unint64_t v11;
  unsigned __int8 *v12;
  unsigned __int8 *v13;
  char v14;

  if (n < 1)
  {
    LODWORD(v4) = 0;
  }
  else
  {
    v4 = 0;
    v5 = f + 1;
    while (1)
    {
      v6 = *(v5 - 1);
      v7 = v6 << 16;
      if (n <= 2)
        break;
      v8 = *v5;
      v9 = v5[1];
      v10 = v9 | (v8 << 8);
      v11 = v7 | (v8 << 8);
      v12 = &t[v4];
      *v12 = data_bin2ascii[v6 >> 2];
      v12[1] = data_bin2ascii[(v11 >> 12) & 0x3F];
      v12[2] = data_bin2ascii[(v10 >> 6) & 0x3F];
      v12[3] = data_bin2ascii[v9 & 0x3F];
      v4 += 4;
      v5 += 3;
      n -= 3;
      if (!n)
      {
        t += v4;
        goto LABEL_12;
      }
    }
    if (n == 2)
      v7 |= (unint64_t)*v5 << 8;
    v13 = &t[v4];
    *v13 = data_bin2ascii[v7 >> 18];
    v13[1] = data_bin2ascii[(v7 >> 12) & 0x3F];
    v14 = 61;
    if (n != 1)
      v14 = data_bin2ascii[(v7 >> 6) & 0x3F];
    v13[2] = v14;
    v13[3] = 61;
    t = v13 + 4;
    LODWORD(v4) = v4 + 4;
  }
LABEL_12:
  *t = 0;
  return v4;
}

void EVP_EncodeFinal(EVP_ENCODE_CTX *ctx, unsigned __int8 *out, int *outl)
{
  int v6;
  int v7;

  if (ctx->num)
  {
    v6 = EVP_EncodeBlock(out, ctx->enc_data, ctx->num);
    out[v6] = 10;
    v7 = v6 + 1;
    out[v6 + 1] = 0;
    ctx->num = 0;
  }
  else
  {
    v7 = 0;
  }
  *outl = v7;
}

void EVP_DecodeInit(EVP_ENCODE_CTX *ctx)
{
  *(_QWORD *)&ctx->num = 0;
  *(_QWORD *)&ctx->line_num = 0;
}

int EVP_DecodeUpdate(EVP_ENCODE_CTX *ctx, unsigned __int8 *out, int *outl, const unsigned __int8 *in, int inl)
{
  EVP_ENCODE_CTX *v9;
  int num;
  unsigned __int8 *enc_data;
  int v12;
  uint64_t v13;
  _BOOL4 v14;
  int v15;
  unsigned __int8 *v17;
  int v18;
  int v19;
  unsigned __int8 *v20;
  int v21;
  int result;
  BOOL v23;
  int v24;
  int v25;
  BOOL v26;
  int v27;
  int *v29;

  v9 = ctx;
  enc_data = ctx->enc_data;
  num = ctx->num;
  if (ctx->num < 1 || enc_data[ctx->num - 1] != 61)
  {
    v12 = 0;
    if (inl)
      goto LABEL_8;
LABEL_29:
    result = 0;
    v15 = 0;
    goto LABEL_48;
  }
  v12 = 1;
  if (num >= 2)
  {
    if (enc_data[num - 2] == 61)
      v12 = 2;
    else
      v12 = 1;
  }
  if (!inl)
    goto LABEL_29;
LABEL_8:
  v29 = outl;
  if (inl >= 1)
  {
    v13 = 0;
    v14 = 0;
    v15 = 0;
    v17 = data_ascii2bin;
    while (1)
    {
      if ((char)in[v13] < 0 || (v18 = v17[in[v13]], v18 == 255))
      {
LABEL_30:
        result = -1;
        goto LABEL_31;
      }
      v19 = in[v13];
      if (v19 == 61)
      {
        ++v12;
      }
      else
      {
        if (v12 < 1)
        {
          v12 = 0;
          goto LABEL_17;
        }
        if ((v18 & 0xEC) != 0xE0)
          goto LABEL_30;
      }
      if (v12 > 2)
        goto LABEL_30;
LABEL_17:
      if (v19 == 45)
        goto LABEL_33;
      if ((v18 & 0xEC) != 0xE0)
      {
        if (num > 63)
          goto LABEL_30;
        enc_data[num++] = v19;
      }
      if (num == 64)
      {
        v20 = v17;
        v21 = EVP_DecodeBlock(out, enc_data, 64);
        result = -1;
        if (v21 < 0 || (v23 = __OFSUB__(v21, v12), v24 = v21 - v12, (v24 < 0) ^ v23))
        {
          num = 0;
LABEL_31:
          v9 = ctx;
          outl = v29;
          goto LABEL_48;
        }
        num = 0;
        v15 += v24;
        out += v24;
        v17 = v20;
      }
      v14 = (int)++v13 >= inl;
      if (inl == (_DWORD)v13)
        goto LABEL_33;
    }
  }
  v15 = 0;
  v14 = 1;
LABEL_33:
  if (num < 1)
  {
    v9 = ctx;
    outl = v29;
  }
  else
  {
    v9 = ctx;
    outl = v29;
    if ((num & 3) != 0)
    {
      if (!v14)
      {
        result = -1;
        goto LABEL_48;
      }
    }
    else
    {
      v25 = EVP_DecodeBlock(out, enc_data, num);
      num = 0;
      result = -1;
      if (v25 < 0 || v12 > v25)
        goto LABEL_48;
      num = 0;
      v15 = v15 - v12 + v25;
    }
  }
  if (v12)
    v26 = num == 0;
  else
    v26 = 0;
  v27 = !v26;
  result = v14 & v27;
LABEL_48:
  *outl = v15;
  v9->num = num;
  return result;
}

int EVP_DecodeBlock(unsigned __int8 *t, const unsigned __int8 *f, int n)
{
  uint64_t v3;
  int v4;
  int v7;
  const unsigned __int8 *v8;
  int v9;
  int v10;
  int v11;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  int v16;
  int v17;
  __int16 v18;
  int v19;
  char v20;
  unsigned __int8 *v21;

  v3 = n;
  if ((*(char *)f & 0x80000000) == 0)
  {
    v4 = *f;
    do
    {
      if (v4 != 32 && v4 != 9 || (int)v3 <= 0)
        break;
      v7 = *(char *)++f;
      --v3;
      v4 = v7;
    }
    while ((v7 & 0x80000000) == 0);
  }
  v8 = &f[v3 - 1];
  do
  {
    v9 = v3;
    if ((int)v3 < 4)
      break;
    if (*(char *)v8 < 0)
      break;
    v10 = data_ascii2bin[*v8--] & 0xEC;
    LODWORD(v3) = v3 - 1;
  }
  while (v10 == 224);
  if ((v9 & 3) != 0)
    return -1;
  if (v9 < 1)
    return 0;
  v13 = 0;
  v14 = 0;
  while (1)
  {
    v15 = (char *)&f[v13];
    v16 = (char)f[v13] < 0 ? 255 : data_ascii2bin[f[v13]];
    v17 = v15[1] < 0 ? 255 : data_ascii2bin[v15[1]];
    v18 = v15[2] < 0 ? 255 : data_ascii2bin[v15[2]];
    v19 = v15[3];
    v20 = v19 < 0 ? -1 : data_ascii2bin[v19];
    v11 = -1;
    if ((v16 & 0x80) != 0 || (char)v17 < 0 || (char)v18 < 0 || v20 < 0)
      break;
    v21 = &t[v14];
    *v21 = ((v17 << 12) | (v16 << 18)) >> 16;
    v21[1] = (unsigned __int16)((v18 << 6) | ((_WORD)v17 << 12)) >> 8;
    v21[2] = v20 | ((_BYTE)v18 << 6);
    v14 += 3;
    v13 += 4;
    if ((int)v13 >= v9)
      return v14;
  }
  return v11;
}

int EVP_DecodeFinal(EVP_ENCODE_CTX *ctx, unsigned __int8 *out, int *outl)
{
  int v5;

  *outl = 0;
  if (!ctx->num)
    return 1;
  v5 = EVP_DecodeBlock(out, ctx->enc_data, ctx->num);
  if ((v5 & 0x80000000) == 0)
  {
    ctx->num = 0;
    *outl = v5;
    return 1;
  }
  return -1;
}

void CAST_cfb64_encrypt(const unsigned __int8 *in, unsigned __int8 *out, uint64_t length, const CAST_KEY *schedule, unsigned __int8 *ivec, int *num, int enc)
{
  uint64_t v10;
  int v13;
  unsigned int v14;
  char v15;
  unsigned __int8 v16;
  unsigned int v17;
  unsigned __int8 v18;
  unsigned __int8 v19;
  unint64_t v20[2];

  v10 = length;
  v20[1] = *MEMORY[0x24BDAC8D0];
  v13 = *num;
  if (enc)
  {
    if (length)
    {
      do
      {
        if (!v13)
        {
          v20[0] = __PAIR64__(bswap32(*((_DWORD *)ivec + 1)), bswap32(*(_DWORD *)ivec));
          CAST_encrypt(v20, schedule);
          v14 = bswap32(HIDWORD(v20[0]));
          *(_DWORD *)ivec = bswap32(v20[0]);
          *((_DWORD *)ivec + 1) = v14;
        }
        v15 = *in++;
        v16 = ivec[v13];
        *out++ = v16 ^ v15;
        ivec[v13] = v16 ^ v15;
        v13 = (v13 + 1) & 7;
        --v10;
      }
      while (v10);
    }
  }
  else if (length)
  {
    do
    {
      if (!v13)
      {
        v20[0] = __PAIR64__(bswap32(*((_DWORD *)ivec + 1)), bswap32(*(_DWORD *)ivec));
        CAST_encrypt(v20, schedule);
        v17 = bswap32(HIDWORD(v20[0]));
        *(_DWORD *)ivec = bswap32(v20[0]);
        *((_DWORD *)ivec + 1) = v17;
      }
      v18 = *in++;
      v19 = ivec[v13];
      ivec[v13] = v18;
      *out++ = v19 ^ v18;
      v13 = (v13 + 1) & 7;
      --v10;
    }
    while (v10);
  }
  *num = v13;
}

uint64_t pkey_rsa_init(uint64_t a1)
{
  uint64_t result;
  int v3;

  result = (uint64_t)malloc_type_calloc(1uLL, 0x50uLL, 0x107004004B23913uLL);
  if (result)
  {
    *(_DWORD *)result = 2048;
    if (**(_DWORD **)a1 == 912)
      v3 = 6;
    else
      v3 = 1;
    *(_DWORD *)(result + 24) = v3;
    *(_QWORD *)(result + 48) = -2;
    *(_QWORD *)(a1 + 40) = result;
    *(_QWORD *)(a1 + 64) = result + 16;
    *(_DWORD *)(a1 + 72) = 2;
    return 1;
  }
  return result;
}

uint64_t pkey_rsa_copy(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;

  result = pkey_rsa_init(a1);
  if ((_DWORD)result)
  {
    v5 = *(_QWORD *)(a2 + 40);
    v6 = *(_QWORD *)(a1 + 40);
    *(_DWORD *)v6 = *(_DWORD *)v5;
    if (!*(_QWORD *)(v5 + 8)
      || (BN_free(*(BIGNUM **)(v6 + 8)),
          result = (uint64_t)BN_dup(*(const BIGNUM **)(v5 + 8)),
          (*(_QWORD *)(v6 + 8) = result) != 0))
    {
      *(_DWORD *)(v6 + 24) = *(_DWORD *)(v5 + 24);
      *(_OWORD *)(v6 + 32) = *(_OWORD *)(v5 + 32);
      if (*(_QWORD *)(v5 + 64))
      {
        free(*(void **)(v6 + 64));
        result = (uint64_t)malloc_type_calloc(1uLL, *(_QWORD *)(v5 + 72), 0x12A371CAuLL);
        *(_QWORD *)(v6 + 64) = result;
        if (!result)
          return result;
        memcpy((void *)result, *(const void **)(v5 + 64), *(_QWORD *)(v5 + 72));
        *(_QWORD *)(v6 + 72) = *(_QWORD *)(v5 + 72);
      }
      return 1;
    }
  }
  return result;
}

void pkey_rsa_cleanup(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 40);
  if (v1)
  {
    BN_free(*(BIGNUM **)(v1 + 8));
    free(*(void **)(v1 + 56));
    free(*(void **)(v1 + 64));
    free((void *)v1);
  }
}

uint64_t pkey_rsa_keygen(uint64_t a1, EVP_PKEY *a2)
{
  uint64_t v4;
  RSA *v5;
  RSA *v6;
  BN_GENCB *v7;
  BIGNUM *v8;
  uint64_t key;
  int v10;
  uint64_t v11;
  EVP_MD *v12;
  EVP_MD *v13;
  int v14;
  int v15;
  ASN1_VALUE *v16;
  _QWORD v18[3];

  v4 = *(_QWORD *)(a1 + 40);
  memset(v18, 0, sizeof(v18));
  if (!*(_QWORD *)(v4 + 8))
  {
    v8 = BN_new();
    *(_QWORD *)(v4 + 8) = v8;
    if (!v8 || !BN_set_word(v8, 0x10001uLL))
      return 0;
  }
  v5 = RSA_new();
  if (!v5)
    return 0;
  v6 = v5;
  if (*(_QWORD *)(a1 + 56))
  {
    v7 = (BN_GENCB *)v18;
    evp_pkey_set_cb_translate((uint64_t)v18, a1);
  }
  else
  {
    v7 = 0;
  }
  key = RSA_generate_key_ex(v6, *(_DWORD *)v4, *(BIGNUM **)(v4 + 8), v7);
  if ((int)key >= 1)
  {
    v10 = **(_DWORD **)a1;
    if (v10 != 912)
    {
LABEL_21:
      EVP_PKEY_assign(a2, v10, (char *)v6);
      return key;
    }
    v11 = *(_QWORD *)(a1 + 40);
    v12 = *(EVP_MD **)(v11 + 32);
    v13 = *(EVP_MD **)(v11 + 40);
    v14 = *(_DWORD *)(v11 + 48);
    if (!((unint64_t)v12 | (unint64_t)v13))
    {
      if (v14 == -2)
      {
        v10 = 912;
        goto LABEL_21;
      }
      v13 = 0;
    }
    if (v14 == -2)
      v15 = 0;
    else
      v15 = v14;
    v16 = rsa_pss_params_create(v12, v13, v15);
    v6->ex_data.sk = (STACK *)v16;
    if (v16)
    {
      v10 = **(_DWORD **)a1;
      goto LABEL_21;
    }
    RSA_free(v6);
    return 0;
  }
  RSA_free(v6);
  return key;
}

uint64_t pkey_rsa_sign(uint64_t a1, unsigned __int8 *to, _QWORD *a3, unsigned __int8 *from, size_t flen)
{
  uint64_t v10;
  uint64_t v11;
  RSA *v12;
  const EVP_MD *v13;
  int v14;
  int v15;
  int v16;
  int v17;
  int v18;
  const unsigned __int8 *v19;
  unsigned __int8 *v20;
  RSA *v21;
  uint64_t result;
  int v23;
  int v24;
  unsigned int siglen;

  v10 = *(_QWORD *)(a1 + 40);
  v11 = *(_QWORD *)(a1 + 16);
  v12 = *(RSA **)(v11 + 32);
  v13 = *(const EVP_MD **)(v10 + 32);
  if (!v13)
  {
    v17 = *(_DWORD *)(v10 + 24);
    v18 = flen;
    v19 = from;
    v20 = to;
    v21 = *(RSA **)(v11 + 32);
LABEL_9:
    result = RSA_private_encrypt(v18, v19, v20, v21, v17);
    if ((result & 0x80000000) != 0)
      return result;
LABEL_10:
    *a3 = result;
    return 1;
  }
  if (EVP_MD_size(v13) != flen)
  {
    v15 = 143;
    v16 = 196;
    goto LABEL_12;
  }
  v14 = *(_DWORD *)(v10 + 24);
  if (v14 != 1)
  {
    if (v14 == 6)
    {
      if (!setup_tbuf(v10, a1)
        || !RSA_padding_add_PKCS1_PSS_mgf1(v12, *(unsigned __int8 **)(v10 + 56), from, *(const EVP_MD **)(v10 + 32), *(const EVP_MD **)(v10 + 40), *(_DWORD *)(v10 + 48)))
      {
        return 0xFFFFFFFFLL;
      }
      v18 = RSA_size(v12);
      v19 = *(const unsigned __int8 **)(v10 + 56);
      v20 = to;
      v21 = v12;
      v17 = 3;
    }
    else
    {
      if (v14 != 5)
        return 0xFFFFFFFFLL;
      if (flen + 1 > EVP_PKEY_size(*(EVP_PKEY **)(a1 + 16)))
      {
        v15 = 120;
        v16 = 202;
LABEL_12:
        ERR_put_error(4, 4095, v15, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/rsa/rsa_pmeth.c", v16);
        return 0xFFFFFFFFLL;
      }
      if (!setup_tbuf(v10, a1))
      {
        v15 = 65;
        v16 = 206;
        goto LABEL_12;
      }
      memcpy(*(void **)(v10 + 56), from, flen);
      v24 = EVP_MD_type(*(const EVP_MD **)(v10 + 32));
      *(_BYTE *)(*(_QWORD *)(v10 + 56) + flen) = RSA_X931_hash_id(v24);
      v19 = *(const unsigned __int8 **)(v10 + 56);
      v18 = flen + 1;
      v20 = to;
      v21 = v12;
      v17 = 5;
    }
    goto LABEL_9;
  }
  siglen = 0;
  v23 = EVP_MD_type(*(const EVP_MD **)(v10 + 32));
  result = RSA_sign(v23, from, flen, to, &siglen, v12);
  if ((int)result > 0)
  {
    result = siglen;
    if ((siglen & 0x80000000) == 0)
      goto LABEL_10;
  }
  return result;
}

uint64_t pkey_rsa_verify(uint64_t a1, unsigned __int8 *a2, size_t a3, const unsigned __int8 *a4, size_t a5)
{
  uint64_t v10;
  RSA *v11;
  const EVP_MD *v12;
  int v13;
  int v15;
  size_t v16;
  int v17;
  size_t v18;

  v10 = *(_QWORD *)(a1 + 40);
  v11 = *(RSA **)(*(_QWORD *)(a1 + 16) + 32);
  v12 = *(const EVP_MD **)(v10 + 32);
  if (v12)
  {
    if (*(_DWORD *)(v10 + 24) == 1)
    {
      v13 = EVP_MD_type(v12);
      return RSA_verify(v13, a4, a5, a2, a3, v11);
    }
    if (EVP_MD_size(v12) == a5)
    {
      v17 = *(_DWORD *)(v10 + 24);
      if (v17 == 6)
      {
        if (setup_tbuf(v10, a1))
        {
          if (RSA_public_decrypt(a3, a2, *(unsigned __int8 **)(v10 + 56), v11, 3) >= 1)
            return (int)RSA_verify_PKCS1_PSS_mgf1(v11, a4, *(const EVP_MD **)(v10 + 32), *(const EVP_MD **)(v10 + 40), *(char **)(v10 + 56), *(_DWORD *)(v10 + 48)) > 0;
          return 0;
        }
      }
      else if (v17 == 5)
      {
        v18 = 0;
        if ((int)pkey_rsa_verifyrecover(a1, 0, &v18, a2, a3) >= 1)
        {
          v16 = v18;
LABEL_7:
          if (v16 == a5)
            return timingsafe_bcmp(a4, *(const void **)(v10 + 56), a5) == 0;
          return 0;
        }
        return 0;
      }
    }
    else
    {
      ERR_put_error(4, 4095, 143, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/rsa/rsa_pmeth.c", 304);
    }
    return 0xFFFFFFFFLL;
  }
  if (!setup_tbuf(v10, a1))
    return 0xFFFFFFFFLL;
  v15 = RSA_public_decrypt(a3, a2, *(unsigned __int8 **)(v10 + 56), v11, *(_DWORD *)(v10 + 24));
  if (v15 >= 1)
  {
    v16 = v15;
    goto LABEL_7;
  }
  return 0;
}

uint64_t pkey_rsa_verifyrecover(uint64_t a1, unsigned __int8 *to, size_t *a3, unsigned __int8 *from, size_t flen)
{
  uint64_t v10;
  const EVP_MD *v11;
  int v12;
  int v13;
  size_t v14;
  int v15;
  int v16;
  uint64_t result;
  int v18;
  int v19;
  int v20;
  uint64_t v21;

  v10 = *(_QWORD *)(a1 + 40);
  v11 = *(const EVP_MD **)(v10 + 32);
  if (v11)
  {
    v12 = *(_DWORD *)(v10 + 24);
    if (v12 != 1)
    {
      if (v12 != 5 || !setup_tbuf(v10, a1))
        return 0xFFFFFFFFLL;
      v13 = RSA_public_decrypt(flen, from, *(unsigned __int8 **)(v10 + 56), *(RSA **)(*(_QWORD *)(a1 + 16) + 32), 5);
      v14 = (v13 - 1);
      if (v13 >= 1)
      {
        v15 = *(unsigned __int8 *)(*(_QWORD *)(v10 + 56) + v14);
        v16 = EVP_MD_type(*(const EVP_MD **)(v10 + 32));
        if (RSA_X931_hash_id(v16) == v15)
        {
          if ((_DWORD)v14 == EVP_MD_size(*(const EVP_MD **)(v10 + 32)))
          {
            if (to)
              memcpy(to, *(const void **)(v10 + 56), v14);
            goto LABEL_16;
          }
          v19 = 143;
          v20 = 265;
        }
        else
        {
          v19 = 100;
          v20 = 261;
        }
        ERR_put_error(4, 4095, v19, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/rsa/rsa_pmeth.c", v20);
      }
      return 0;
    }
    v21 = 0;
    v18 = EVP_MD_type(v11);
    if ((int)int_rsa_verify(v18, 0, 0, to, &v21, from, flen, *(RSA **)(*(_QWORD *)(a1 + 16) + 32)) <= 0)
      return 0;
    result = v21;
    if ((v21 & 0x80000000) != 0)
      return result;
LABEL_15:
    v14 = result;
LABEL_16:
    *a3 = v14;
    return 1;
  }
  result = RSA_public_decrypt(flen, from, to, *(RSA **)(*(_QWORD *)(a1 + 16) + 32), *(_DWORD *)(v10 + 24));
  if ((result & 0x80000000) == 0)
    goto LABEL_15;
  return result;
}

uint64_t pkey_rsa_encrypt(uint64_t a1, unsigned __int8 *to, _QWORD *a3, unsigned __int8 *from, int flen)
{
  uint64_t v10;
  int v11;
  int v12;
  const unsigned __int8 *v13;
  RSA *v14;
  int v15;
  unsigned __int8 *v16;
  uint64_t result;

  v10 = *(_QWORD *)(a1 + 40);
  v11 = *(_DWORD *)(v10 + 24);
  if (v11 == 4)
  {
    v12 = RSA_size(*(const RSA **)(*(_QWORD *)(a1 + 16) + 32));
    if (!setup_tbuf(v10, a1)
      || !RSA_padding_add_PKCS1_OAEP_mgf1(*(_BYTE **)(v10 + 56), v12, from, flen, *(const void **)(v10 + 64), *(_DWORD *)(v10 + 72), *(EVP_MD **)(v10 + 32), *(EVP_MD **)(v10 + 40)))
    {
      return 0xFFFFFFFFLL;
    }
    v13 = *(const unsigned __int8 **)(v10 + 56);
    v14 = *(RSA **)(*(_QWORD *)(a1 + 16) + 32);
    v15 = v12;
    v16 = to;
    v11 = 3;
  }
  else
  {
    v14 = *(RSA **)(*(_QWORD *)(a1 + 16) + 32);
    v15 = flen;
    v13 = from;
    v16 = to;
  }
  result = RSA_public_encrypt(v15, v13, v16, v14, v11);
  if ((result & 0x80000000) == 0)
  {
    *a3 = result;
    return 1;
  }
  return result;
}

uint64_t pkey_rsa_decrypt(uint64_t a1, unsigned __int8 *to, _QWORD *a3, unsigned __int8 *from, int flen)
{
  uint64_t v10;
  int v11;
  uint64_t v12;
  uint64_t v13;

  v10 = *(_QWORD *)(a1 + 40);
  v11 = *(_DWORD *)(v10 + 24);
  if (v11 != 4)
  {
    v13 = RSA_private_decrypt(flen, from, to, *(RSA **)(*(_QWORD *)(a1 + 16) + 32), v11);
LABEL_6:
    v12 = v13;
    if ((v13 & 0x80000000) == 0)
    {
      *a3 = v13;
      return 1;
    }
    return v12;
  }
  if (!setup_tbuf(*(_QWORD *)(a1 + 40), a1))
    return 0xFFFFFFFFLL;
  v12 = RSA_private_decrypt(flen, from, *(unsigned __int8 **)(v10 + 56), *(RSA **)(*(_QWORD *)(a1 + 16) + 32), 3);
  if ((int)v12 >= 1)
  {
    v13 = RSA_padding_check_PKCS1_OAEP_mgf1(to, v12, *(_QWORD *)(v10 + 56), v12, v12, *(const void **)(v10 + 64), *(_DWORD *)(v10 + 72), *(EVP_MD **)(v10 + 32), *(const EVP_MD **)(v10 + 40));
    goto LABEL_6;
  }
  return v12;
}

uint64_t pkey_rsa_ctrl(uint64_t a1, int a2, int a3, EVP_MD *a4)
{
  uint64_t v6;
  int v8;
  uint64_t result;
  int v10;
  int v11;
  uint64_t v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;

  v6 = *(_QWORD *)(a1 + 40);
  switch(a2)
  {
    case 4097:
      if ((a3 - 1) > 5)
        goto LABEL_61;
      result = check_padding_md(*(const EVP_MD **)(v6 + 32), a3);
      if (!(_DWORD)result)
        return result;
      if (a3 == 6)
      {
        if ((*(_BYTE *)(a1 + 32) & 0x18) != 0)
          goto LABEL_25;
        goto LABEL_61;
      }
      if (**(_DWORD **)a1 == 912)
        goto LABEL_61;
      if (a3 == 4)
      {
        if ((*(_BYTE *)(a1 + 33) & 3) != 0)
        {
LABEL_25:
          if (!*(_QWORD *)(v6 + 32))
            *(_QWORD *)(v6 + 32) = EVP_sha1();
          goto LABEL_68;
        }
LABEL_61:
        v10 = 144;
        v11 = 476;
        goto LABEL_62;
      }
LABEL_68:
      *(_DWORD *)(v6 + 24) = a3;
      return 1;
    case 4098:
    case 4103:
      if (*(_DWORD *)(v6 + 24) != 6)
      {
        v10 = 146;
        v11 = 486;
        goto LABEL_62;
      }
      if (a2 == 4103)
      {
        v8 = *(_DWORD *)(v6 + 48);
LABEL_34:
        a4->type = v8;
        return 1;
      }
      if (a3 < -3)
        return 4294967294;
      v17 = *(_DWORD *)(v6 + 52);
      if (v17 == -1)
        goto LABEL_74;
      if (a3 == -1)
      {
        if (v17 > EVP_MD_size(*(const EVP_MD **)(v6 + 32)))
          goto LABEL_73;
      }
      else
      {
        if (a3 == -2)
        {
          if (*(_DWORD *)(a1 + 32) == 16)
          {
            v10 = 146;
            v11 = 497;
            goto LABEL_62;
          }
          goto LABEL_74;
        }
        if ((a3 & 0x80000000) == 0 && v17 > a3)
        {
LABEL_73:
          v14 = 164;
          v15 = 503;
          goto LABEL_48;
        }
      }
LABEL_74:
      *(_DWORD *)(v6 + 48) = a3;
      return 1;
    case 4099:
      if (a3 <= 511)
      {
        v10 = 120;
        v11 = 513;
        goto LABEL_62;
      }
      *(_DWORD *)v6 = a3;
      return 1;
    case 4100:
      if (!a4 || !BN_is_odd((uint64_t)a4) || BN_is_one((uint64_t)a4))
      {
        v10 = 101;
        v11 = 522;
        goto LABEL_62;
      }
      BN_free(*(BIGNUM **)(v6 + 8));
      *(_QWORD *)(v6 + 8) = a4;
      return 1;
    case 4101:
    case 4104:
      if ((*(_DWORD *)(v6 + 24) | 2) != 6)
      {
        v10 = 156;
        v11 = 561;
        goto LABEL_62;
      }
      if (a2 == 4104)
      {
        v12 = *(_QWORD *)(v6 + 40);
        if (v12)
          goto LABEL_15;
        goto LABEL_14;
      }
      if (*(_DWORD *)(v6 + 52) == -1)
      {
        *(_QWORD *)(v6 + 40) = a4;
        return 1;
      }
      v16 = EVP_MD_type(*(const EVP_MD **)(v6 + 40));
      if (v16 == EVP_MD_type(a4))
        return 1;
      v14 = 152;
      v15 = 573;
LABEL_48:
      ERR_put_error(4, 4095, v14, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/rsa/rsa_pmeth.c", v15);
      return 0;
    case 4102:
      v8 = *(_DWORD *)(v6 + 24);
      goto LABEL_34;
    case 4105:
    case 4107:
      if (*(_DWORD *)(v6 + 24) != 4)
      {
        v10 = 141;
        v11 = 532;
        goto LABEL_62;
      }
      if (a2 == 4107)
      {
LABEL_14:
        v12 = *(_QWORD *)(v6 + 32);
LABEL_15:
        *(_QWORD *)&a4->type = v12;
      }
      else
      {
LABEL_43:
        *(_QWORD *)(v6 + 32) = a4;
      }
      return 1;
    case 4106:
      if (*(_DWORD *)(v6 + 24) != 4)
      {
        v10 = 141;
        v11 = 582;
        goto LABEL_62;
      }
      free(*(void **)(v6 + 64));
      if (a3 >= 1 && a4)
      {
        *(_QWORD *)(v6 + 64) = a4;
        *(_QWORD *)(v6 + 72) = a3;
      }
      else
      {
        *(_QWORD *)(v6 + 64) = 0;
        *(_QWORD *)(v6 + 72) = 0;
      }
      return 1;
    case 4108:
      if (*(_DWORD *)(v6 + 24) == 4)
      {
        *(_QWORD *)&a4->type = *(_QWORD *)(v6 + 64);
        return *(unsigned int *)(v6 + 72);
      }
      else
      {
        v10 = 141;
        v11 = 597;
LABEL_62:
        ERR_put_error(4, 4095, v10, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/rsa/rsa_pmeth.c", v11);
        return 4294967294;
      }
    default:
      result = 1;
      switch(a2)
      {
        case 1:
          result = check_padding_md(a4, *(_DWORD *)(v6 + 24));
          if (!(_DWORD)result)
            return result;
          if (*(_DWORD *)(v6 + 52) == -1)
            goto LABEL_43;
          v13 = EVP_MD_type(*(const EVP_MD **)(v6 + 32));
          if (v13 == EVP_MD_type(a4))
            return 1;
          v14 = 145;
          v15 = 547;
          break;
        case 2:
          goto LABEL_7;
        case 3:
        case 4:
        case 9:
        case 10:
          if (**(_DWORD **)a1 != 912)
            return result;
LABEL_7:
          v10 = 148;
          v11 = 621;
          goto LABEL_62;
        case 5:
        case 7:
        case 11:
          return result;
        case 13:
          *(_QWORD *)&a4->type = *(_QWORD *)(v6 + 32);
          return result;
        default:
          return 4294967294;
      }
      goto LABEL_48;
  }
}

uint64_t pkey_rsa_ctrl_str(uint64_t *a1, char *__s1, char *a3)
{
  unsigned __int8 *v6;
  unsigned __int8 *v7;
  uint64_t v8;
  uint64_t *v10;
  int v11;
  int v12;
  uint64_t len;

  if (!a3)
  {
    ERR_put_error(4, 4095, 147, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/rsa/rsa_pmeth.c", 634);
    return 0;
  }
  if (!strcmp(__s1, "rsa_padding_mode"))
  {
    if (strcmp(a3, "pkcs1")
      && strcmp(a3, "none")
      && strcmp(a3, "oeap")
      && strcmp(a3, "oaep")
      && strcmp(a3, "x931")
      && strcmp(a3, "pss"))
    {
      ERR_put_error(4, 4095, 118, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/rsa/rsa_pmeth.c", 652);
      return 4294967294;
    }
    return RSA_pkey_ctx_ctrl(a1, -1);
  }
  if (!strcmp(__s1, "rsa_pss_saltlen"))
  {
    if (strcmp(a3, "digest") && strcmp(a3, "max") && strcmp(a3, "auto"))
      atoi(a3);
    return RSA_pkey_ctx_ctrl(a1, 24);
  }
  if (!strcmp(__s1, "rsa_keygen_bits"))
  {
    atoi(a3);
    return RSA_pkey_ctx_ctrl(a1, 4);
  }
  if (!strcmp(__s1, "rsa_keygen_pubexp"))
  {
    len = 0;
    if (BN_asc2bn((BIGNUM **)&len, (uint64_t)a3))
    {
      v8 = RSA_pkey_ctx_ctrl(a1, 4);
      if ((int)v8 <= 0)
        BN_free((BIGNUM *)len);
      return v8;
    }
    return 0;
  }
  if (!strcmp(__s1, "rsa_mgf1_md"))
  {
    v10 = a1;
    v11 = 1016;
LABEL_43:
    v12 = 4101;
    return EVP_PKEY_CTX_md(v10, v11, v12, a3);
  }
  if (*(_DWORD *)*a1 != 912)
  {
LABEL_11:
    if (strcmp(__s1, "rsa_oaep_md"))
    {
      if (!strcmp(__s1, "rsa_oaep_label"))
      {
        len = 0;
        v6 = string_to_hex(a3, &len);
        if (v6)
        {
          v7 = v6;
          v8 = EVP_PKEY_CTX_ctrl(a1, 6, 768);
          if ((int)v8 <= 0)
            free(v7);
          return v8;
        }
        return 0;
      }
      return 4294967294;
    }
    v10 = a1;
    v11 = 768;
    v12 = 4105;
    return EVP_PKEY_CTX_md(v10, v11, v12, a3);
  }
  if (!strcmp(__s1, "rsa_pss_keygen_mgf1_md"))
  {
    v10 = a1;
    v11 = 4;
    goto LABEL_43;
  }
  if (!strcmp(__s1, "rsa_pss_keygen_md"))
  {
    v10 = a1;
    v11 = 4;
    v12 = 1;
    return EVP_PKEY_CTX_md(v10, v11, v12, a3);
  }
  if (strcmp(__s1, "rsa_pss_keygen_saltlen"))
    goto LABEL_11;
  atoi(a3);
  return EVP_PKEY_CTX_ctrl(a1, 912, 4);
}

uint64_t pkey_pss_init(uint64_t a1)
{
  uint64_t result;
  uint64_t v3;
  const RSA *v4;
  uint64_t sk;
  int v6;
  int v7;
  int v8;
  int v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  EVP_MD *md;

  result = 0;
  v3 = *(_QWORD *)(a1 + 40);
  v12 = 0;
  md = 0;
  v11 = 0;
  if (**(_DWORD **)a1 == 912)
  {
    v4 = *(const RSA **)(*(_QWORD *)(a1 + 16) + 32);
    sk = (uint64_t)v4->ex_data.sk;
    if (sk)
    {
      result = rsa_pss_get_param(sk, (uint64_t *)&md, &v12, &v11);
      if (!(_DWORD)result)
        return result;
      v6 = RSA_size(v4);
      v7 = v6 - EVP_MD_size(md);
      v8 = v7 - ((RSA_bits((uint64_t)v4) & 7) == 1);
      v9 = v11;
      if (v11 > v8)
      {
        ERR_put_error(4, 4095, 150, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/rsa/rsa_pmeth.c", 844);
        return 0;
      }
      v10 = v12;
      *(_QWORD *)(v3 + 32) = md;
      *(_QWORD *)(v3 + 40) = v10;
      *(_DWORD *)(v3 + 48) = v9;
      *(_DWORD *)(v3 + 52) = v9;
    }
    return 1;
  }
  return result;
}

uint64_t setup_tbuf(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  int v4;
  void *v5;

  if (*(_QWORD *)(a1 + 56))
    return 1;
  v4 = EVP_PKEY_size(*(EVP_PKEY **)(a2 + 16));
  v2 = 1;
  v5 = malloc_type_calloc(1uLL, v4, 0x434431A6uLL);
  *(_QWORD *)(a1 + 56) = v5;
  if (!v5)
  {
    ERR_put_error(4, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/rsa/rsa_pmeth.c", 167);
    return 0;
  }
  return v2;
}

uint64_t check_padding_md(const EVP_MD *a1, int a2)
{
  int v2;
  int v3;
  uint64_t result;
  int v5;
  int v6;

  if (!a1)
    return 1;
  if (a2 == 5)
  {
    v5 = EVP_MD_type(a1);
    if (RSA_X931_hash_id(v5) != -1)
      return 1;
    v2 = 142;
    v3 = 414;
    goto LABEL_18;
  }
  if (a2 == 3)
  {
    v2 = 141;
    v3 = 408;
LABEL_18:
    ERR_put_error(4, 4095, v2, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/rsa/rsa_pmeth.c", v3);
    return 0;
  }
  v6 = EVP_MD_type(a1);
  result = 1;
  if (v6 > 1028)
  {
    if ((v6 - 1029) < 6)
      return result;
    goto LABEL_21;
  }
  if (v6 > 671)
  {
    if ((v6 - 672) >= 4)
    {
LABEL_21:
      v2 = 157;
      v3 = 439;
      goto LABEL_18;
    }
  }
  else if (((v6 - 64) > 0x35 || ((1 << (v6 - 64)) & 0x24000000000001) == 0)
         && v6 != 4
         && v6 != 257)
  {
    goto LABEL_21;
  }
  return result;
}

uint64_t Camellia_ofb128_encrypt(uint64_t a1, _BYTE *a2, unint64_t a3, uint64_t a4, uint64_t a5, unsigned int *a6)
{
  return CRYPTO_ofb128_encrypt(a1, a2, a3, a4, a5, a6, (uint64_t (*)(uint64_t, uint64_t, uint64_t))Camellia_encrypt);
}

EC_KEY *EC_KEY_new(void)
{
  return (EC_KEY *)EC_KEY_new_method(0);
}

EC_KEY *__cdecl EC_KEY_new_by_curve_name(int nid)
{
  uint64_t *v2;
  EC_GROUP *v3;
  unsigned int (*v4)(uint64_t *, EC_GROUP *);

  v2 = EC_KEY_new_method(0);
  if (v2)
  {
    v3 = EC_GROUP_new_by_curve_name(nid);
    v2[3] = (uint64_t)v3;
    if (!v3 || (v4 = *(unsigned int (**)(uint64_t *, EC_GROUP *))(*v2 + 40)) != 0 && !v4(v2, v3))
    {
      EC_KEY_free((EC_KEY *)v2);
      return 0;
    }
  }
  return (EC_KEY *)v2;
}

void EC_KEY_free(EC_KEY *a1)
{
  void (*v2)(EC_KEY *);

  if (a1 && CRYPTO_add_lock((int *)a1 + 14, -1, 33, 0, 0) <= 0)
  {
    if (*(_QWORD *)a1)
    {
      v2 = *(void (**)(EC_KEY *))(*(_QWORD *)a1 + 24);
      if (v2)
        v2(a1);
    }
    ENGINE_finish(*((ENGINE **)a1 + 1));
    CRYPTO_free_ex_data(16, a1, (CRYPTO_EX_DATA *)((char *)a1 + 72));
    EC_GROUP_free(*((EC_GROUP **)a1 + 3));
    EC_POINT_free(*((EC_POINT **)a1 + 4));
    BN_free(*((BIGNUM **)a1 + 5));
    EC_EX_DATA_free_all_data((void **)a1 + 8);
    freezero(a1, 0x50uLL);
  }
}

EC_KEY *__cdecl EC_KEY_copy(EC_KEY *a1, const EC_KEY *a2)
{
  EC_KEY *v3;
  uint64_t v4;
  void (*v5)(EC_KEY *);
  const EC_GROUP *v6;
  const EC_METHOD *v7;
  EC_GROUP *v8;
  EC_POINT *v9;
  const BIGNUM *v10;
  BIGNUM *v11;
  _QWORD *v12;
  uint64_t v13;
  uint64_t v15;
  ENGINE *v16;
  __int128 v17;
  unsigned int (*v18)(EC_KEY *, const EC_KEY *);

  if (!a1 || !a2)
  {
    ERR_put_error(16, 4095, 67, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_key.c", 136);
    return 0;
  }
  v3 = a1;
  v4 = *(_QWORD *)a1;
  if (*(_QWORD *)a2 != *(_QWORD *)a1)
  {
    if (v4)
    {
      v5 = *(void (**)(EC_KEY *))(v4 + 24);
      if (v5)
        v5(a1);
    }
    if (!ENGINE_finish(*((ENGINE **)v3 + 1)))
      return 0;
    *((_QWORD *)v3 + 1) = 0;
  }
  v6 = (const EC_GROUP *)*((_QWORD *)a2 + 3);
  if (v6)
  {
    v7 = EC_GROUP_method_of(v6);
    EC_GROUP_free(*((EC_GROUP **)v3 + 3));
    v8 = EC_GROUP_new(v7);
    *((_QWORD *)v3 + 3) = v8;
    if (!v8 || !EC_GROUP_copy(v8, *((const EC_GROUP **)a2 + 3)))
      return 0;
  }
  if (*((_QWORD *)a2 + 4))
  {
    if (*((_QWORD *)a2 + 3))
    {
      EC_POINT_free(*((EC_POINT **)v3 + 4));
      v9 = EC_POINT_new(*((const EC_GROUP **)a2 + 3));
      *((_QWORD *)v3 + 4) = v9;
      if (!v9 || !EC_POINT_copy(v9, *((const EC_POINT **)a2 + 4)))
        return 0;
    }
  }
  v10 = (const BIGNUM *)*((_QWORD *)a2 + 5);
  if (v10)
  {
    v11 = (BIGNUM *)*((_QWORD *)v3 + 5);
    if (!v11)
    {
      v11 = BN_new();
      *((_QWORD *)v3 + 5) = v11;
      if (!v11)
        return 0;
      v10 = (const BIGNUM *)*((_QWORD *)a2 + 5);
    }
    if (!bn_copy(v11, v10))
      return 0;
  }
  EC_EX_DATA_free_all_data((void **)v3 + 8);
  v12 = (_QWORD *)((char *)a2 + 64);
  while (1)
  {
    v12 = (_QWORD *)*v12;
    if (!v12)
      break;
    v13 = ((uint64_t (*)(_QWORD))v12[2])(v12[1]);
    if (!v13 || !EC_EX_DATA_set_data((uint64_t)v3 + 64, v13, v12[2], v12[3], v12[4]))
      return 0;
  }
  *((_QWORD *)v3 + 6) = *((_QWORD *)a2 + 6);
  *((_DWORD *)v3 + 4) = *((_DWORD *)a2 + 4);
  *((_DWORD *)v3 + 15) = *((_DWORD *)a2 + 15);
  if (!CRYPTO_dup_ex_data(16, (CRYPTO_EX_DATA *)((char *)v3 + 72), (CRYPTO_EX_DATA *)((char *)a2 + 72)))
    return 0;
  v15 = *(_QWORD *)a2;
  if (*(_QWORD *)a2 != *(_QWORD *)v3)
  {
    v16 = (ENGINE *)*((_QWORD *)a2 + 1);
    if (!v16)
    {
      v17 = *(unint64_t *)a2;
      goto LABEL_35;
    }
    if (ENGINE_init(v16))
    {
      v17 = *(_OWORD *)a2;
LABEL_35:
      *(_OWORD *)v3 = v17;
      v15 = *(_QWORD *)a2;
      goto LABEL_36;
    }
    return 0;
  }
LABEL_36:
  if (v15)
  {
    v18 = *(unsigned int (**)(EC_KEY *, const EC_KEY *))(v15 + 32);
    if (v18)
    {
      if (!v18(v3, a2))
        return 0;
    }
  }
  return v3;
}

EC_KEY *__cdecl EC_KEY_dup(const EC_KEY *a1)
{
  uint64_t *v2;
  EC_KEY *v3;

  v2 = EC_KEY_new_method(*((ENGINE **)a1 + 1));
  v3 = (EC_KEY *)v2;
  if (v2 && !EC_KEY_copy((EC_KEY *)v2, a1))
  {
    EC_KEY_free(v3);
    return 0;
  }
  return v3;
}

int EC_KEY_up_ref(EC_KEY *a1)
{
  return CRYPTO_add_lock((int *)a1 + 14, 1, 33, 0, 0) > 1;
}

uint64_t EC_KEY_set_ex_data(uint64_t a1, int a2, void *a3)
{
  return CRYPTO_set_ex_data((CRYPTO_EX_DATA *)(a1 + 72), a2, a3);
}

void *EC_KEY_get_ex_data(uint64_t a1, int a2)
{
  return CRYPTO_get_ex_data((const CRYPTO_EX_DATA *)(a1 + 72), a2);
}

int EC_KEY_generate_key(EC_KEY *a1)
{
  uint64_t (*v1)(void);

  v1 = *(uint64_t (**)(void))(*(_QWORD *)a1 + 64);
  if (v1)
    return v1();
  ERR_put_error(16, 4095, 126, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_key.c", 255);
  return 0;
}

uint64_t ossl_ec_key_gen(uint64_t a1)
{
  BIGNUM *v2;
  EC_POINT *v3;
  BN_CTX *v4;
  BN_CTX *v5;
  BIGNUM *v6;
  BIGNUM *v7;
  BIGNUM *v8;
  uint64_t v9;

  if (!a1 || !*(_QWORD *)(a1 + 24))
  {
    ERR_put_error(16, 4095, 67, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_key.c", 269);
    v5 = 0;
    v2 = 0;
LABEL_12:
    v3 = 0;
LABEL_13:
    v9 = 0;
    goto LABEL_14;
  }
  v2 = BN_new();
  if (!v2)
  {
    v5 = 0;
    goto LABEL_12;
  }
  v3 = EC_POINT_new(*(const EC_GROUP **)(a1 + 24));
  if (!v3)
  {
    v5 = 0;
    goto LABEL_13;
  }
  v4 = BN_CTX_new();
  v5 = v4;
  if (!v4)
    goto LABEL_13;
  BN_CTX_start(v4);
  v6 = BN_CTX_get(v5);
  if (!v6)
    goto LABEL_13;
  v7 = v6;
  if (!EC_GROUP_get_order(*(const EC_GROUP **)(a1 + 24), v6, v5))
    goto LABEL_13;
  v8 = (BIGNUM *)BN_value_one();
  if (!bn_rand_interval(v2, v8, v7) || !EC_POINT_mul(*(const EC_GROUP **)(a1 + 24), v3, v2, 0, 0, v5))
    goto LABEL_13;
  BN_free(*(BIGNUM **)(a1 + 40));
  *(_QWORD *)(a1 + 40) = v2;
  EC_POINT_free(*(EC_POINT **)(a1 + 32));
  v2 = 0;
  *(_QWORD *)(a1 + 32) = v3;
  v9 = 1;
  v3 = 0;
LABEL_14:
  EC_POINT_free(v3);
  BN_free(v2);
  BN_CTX_end(v5);
  BN_CTX_free(v5);
  return v9;
}

int EC_KEY_check_key(const EC_KEY *a1)
{
  const EC_GROUP *v2;
  const EC_POINT *v3;
  int v4;
  int v5;
  BN_CTX *v6;
  EC_POINT *v7;
  int v8;
  BN_CTX *v10;
  BIGNUM *v11;
  BIGNUM *v12;
  const BIGNUM *v13;
  int v14;
  int v15;

  if (!a1 || (v2 = (const EC_GROUP *)*((_QWORD *)a1 + 3)) == 0 || (v3 = (const EC_POINT *)*((_QWORD *)a1 + 4)) == 0)
  {
    v4 = 67;
    v5 = 321;
    goto LABEL_7;
  }
  if (EC_POINT_is_at_infinity(v2, v3) < 1)
  {
    v10 = BN_CTX_new();
    v6 = v10;
    if (!v10)
      goto LABEL_8;
    BN_CTX_start(v10);
    v11 = BN_CTX_get(v6);
    if (!v11)
      goto LABEL_8;
    v12 = v11;
    v7 = EC_POINT_new(*((const EC_GROUP **)a1 + 3));
    if (!v7)
      goto LABEL_9;
    if (EC_POINT_is_on_curve(*((const EC_GROUP **)a1 + 3), *((const EC_POINT **)a1 + 4), v6) > 0)
    {
      if (!EC_GROUP_get_order(*((const EC_GROUP **)a1 + 3), v12, v6))
      {
        v14 = 122;
        v15 = 349;
        goto LABEL_25;
      }
      if (!EC_POINT_mul(*((const EC_GROUP **)a1 + 3), v7, 0, *((const EC_POINT **)a1 + 4), v12, v6))
      {
        v14 = 16;
        v15 = 353;
        goto LABEL_25;
      }
      if (EC_POINT_is_at_infinity(*((const EC_GROUP **)a1 + 3), v7) <= 0)
      {
        v14 = 130;
        v15 = 357;
        goto LABEL_25;
      }
      v13 = (const BIGNUM *)*((_QWORD *)a1 + 5);
      if (v13)
      {
        if ((BN_cmp(v13, v12) & 0x80000000) == 0)
        {
          v14 = 130;
          v15 = 367;
LABEL_25:
          ERR_put_error(16, 4095, v14, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_key.c", v15);
          goto LABEL_9;
        }
        if (!EC_POINT_mul(*((const EC_GROUP **)a1 + 3), v7, *((const BIGNUM **)a1 + 5), 0, 0, v6))
        {
          v14 = 16;
          v15 = 372;
          goto LABEL_25;
        }
        if (EC_POINT_cmp(*((const EC_GROUP **)a1 + 3), v7, *((const EC_POINT **)a1 + 4), v6))
        {
          v14 = 123;
          v15 = 377;
          goto LABEL_25;
        }
      }
      v8 = 1;
      goto LABEL_10;
    }
    v14 = 107;
    v15 = 343;
    goto LABEL_25;
  }
  v4 = 106;
  v5 = 326;
LABEL_7:
  ERR_put_error(16, 4095, v4, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_key.c", v5);
  v6 = 0;
LABEL_8:
  v7 = 0;
LABEL_9:
  v8 = 0;
LABEL_10:
  BN_CTX_end(v6);
  BN_CTX_free(v6);
  EC_POINT_free(v7);
  return v8;
}

uint64_t EC_KEY_set_public_key_affine_coordinates(uint64_t a1, const BIGNUM *a2, const BIGNUM *a3)
{
  BN_CTX *v6;
  BN_CTX *v7;
  BIGNUM *v8;
  const BIGNUM *v9;
  BIGNUM *v10;
  const BIGNUM *v11;
  EC_POINT *v12;
  uint64_t v13;

  if (!a1 || !a3 || !a2 || !*(_QWORD *)(a1 + 24))
  {
    ERR_put_error(16, 4095, 67, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_key.c", 401);
    v7 = 0;
LABEL_15:
    v12 = 0;
    goto LABEL_16;
  }
  v6 = BN_CTX_new();
  v7 = v6;
  if (!v6)
    goto LABEL_15;
  BN_CTX_start(v6);
  v8 = BN_CTX_get(v7);
  if (!v8)
    goto LABEL_15;
  v9 = v8;
  v10 = BN_CTX_get(v7);
  if (!v10)
    goto LABEL_15;
  v11 = v10;
  v12 = EC_POINT_new(*(const EC_GROUP **)(a1 + 24));
  if (v12
    && EC_POINT_set_affine_coordinates(*(const EC_GROUP **)(a1 + 24), v12, (uint64_t)a2, (uint64_t)a3, v7)
    && EC_POINT_get_affine_coordinates(*(_QWORD *)(a1 + 24), v12, (uint64_t)v9, (uint64_t)v11, v7))
  {
    if (BN_cmp(a2, v9) || BN_cmp(a3, v11))
    {
      ERR_put_error(16, 4095, 146, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_key.c", 428);
    }
    else if (EC_KEY_set_public_key((EC_KEY *)a1, v12))
    {
      v13 = EC_KEY_check_key((const EC_KEY *)a1);
      goto LABEL_17;
    }
  }
LABEL_16:
  v13 = 0;
LABEL_17:
  BN_CTX_end(v7);
  BN_CTX_free(v7);
  EC_POINT_free(v12);
  return v13;
}

int EC_KEY_set_public_key(EC_KEY *a1, const EC_POINT *a2)
{
  uint64_t (*v4)(EC_KEY *, const EC_POINT *);
  int result;
  EC_POINT *v6;

  v4 = *(uint64_t (**)(EC_KEY *, const EC_POINT *))(*(_QWORD *)a1 + 56);
  if (!v4 || (result = v4(a1, a2)) != 0)
  {
    EC_POINT_free(*((EC_POINT **)a1 + 4));
    v6 = EC_POINT_dup(a2, *((const EC_GROUP **)a1 + 3));
    *((_QWORD *)a1 + 4) = v6;
    return v6 != 0;
  }
  return result;
}

const EC_GROUP *__cdecl EC_KEY_get0_group(const EC_KEY *a1)
{
  return (const EC_GROUP *)*((_QWORD *)a1 + 3);
}

int EC_KEY_set_group(EC_KEY *a1, const EC_GROUP *a2)
{
  uint64_t (*v4)(EC_KEY *, const EC_GROUP *);
  int result;
  EC_GROUP *v6;

  v4 = *(uint64_t (**)(EC_KEY *, const EC_GROUP *))(*(_QWORD *)a1 + 40);
  if (!v4 || (result = v4(a1, a2)) != 0)
  {
    EC_GROUP_free(*((EC_GROUP **)a1 + 3));
    v6 = EC_GROUP_dup(a2);
    *((_QWORD *)a1 + 3) = v6;
    return v6 != 0;
  }
  return result;
}

const BIGNUM *__cdecl EC_KEY_get0_private_key(const EC_KEY *a1)
{
  return (const BIGNUM *)*((_QWORD *)a1 + 5);
}

int EC_KEY_set_private_key(EC_KEY *a1, const BIGNUM *a2)
{
  uint64_t (*v4)(EC_KEY *, const BIGNUM *);
  int result;
  BIGNUM *v6;

  v4 = *(uint64_t (**)(EC_KEY *, const BIGNUM *))(*(_QWORD *)a1 + 48);
  if (!v4 || (result = v4(a1, a2)) != 0)
  {
    BN_free(*((BIGNUM **)a1 + 5));
    v6 = BN_dup(a2);
    *((_QWORD *)a1 + 5) = v6;
    return v6 != 0;
  }
  return result;
}

const EC_POINT *__cdecl EC_KEY_get0_public_key(const EC_KEY *a1)
{
  return (const EC_POINT *)*((_QWORD *)a1 + 4);
}

unsigned int EC_KEY_get_enc_flags(const EC_KEY *a1)
{
  return *((_DWORD *)a1 + 12);
}

void EC_KEY_set_enc_flags(EC_KEY *a1, unsigned int a2)
{
  *((_DWORD *)a1 + 12) = a2;
}

point_conversion_form_t EC_KEY_get_conv_form(const EC_KEY *a1)
{
  return *((_DWORD *)a1 + 13);
}

void EC_KEY_set_conv_form(EC_KEY *a1, point_conversion_form_t a2)
{
  EC_GROUP *v2;

  *((_DWORD *)a1 + 13) = a2;
  v2 = (EC_GROUP *)*((_QWORD *)a1 + 3);
  if (v2)
    EC_GROUP_set_point_conversion_form(v2, a2);
}

void *__cdecl EC_KEY_get_key_method_data(EC_KEY *a1, void *(__cdecl *dup_func)(void *), void (__cdecl *free_func)(void *), void (__cdecl *clear_free_func)(void *))
{
  _QWORD *data;

  CRYPTO_lock(5, 33, 0, 0);
  data = EC_EX_DATA_get_data(*((_QWORD **)a1 + 8), (uint64_t)dup_func, (uint64_t)free_func, (uint64_t)clear_free_func);
  CRYPTO_lock(6, 33, 0, 0);
  return data;
}

void EC_KEY_insert_key_method_data(EC_KEY *a1, void *data, void *(__cdecl *dup_func)(void *), void (__cdecl *free_func)(void *), void (__cdecl *clear_free_func)(void *))
{
  char *v10;
  _QWORD *v11;

  CRYPTO_lock(9, 33, 0, 0);
  v11 = (_QWORD *)*((_QWORD *)a1 + 8);
  v10 = (char *)a1 + 64;
  if (!EC_EX_DATA_get_data(v11, (uint64_t)dup_func, (uint64_t)free_func, (uint64_t)clear_free_func))
    EC_EX_DATA_set_data((uint64_t)v10, (uint64_t)data, (uint64_t)dup_func, (uint64_t)free_func, (uint64_t)clear_free_func);
  CRYPTO_lock(10, 33, 0, 0);
}

void EC_KEY_set_asn1_flag(EC_KEY *a1, int a2)
{
  EC_GROUP *v2;

  v2 = (EC_GROUP *)*((_QWORD *)a1 + 3);
  if (v2)
    EC_GROUP_set_asn1_flag(v2, a2);
}

int EC_KEY_precompute_mult(EC_KEY *a1, BN_CTX *ctx)
{
  EC_GROUP *v2;

  v2 = (EC_GROUP *)*((_QWORD *)a1 + 3);
  if (v2)
    LODWORD(v2) = EC_GROUP_precompute_mult(v2, ctx);
  return (int)v2;
}

uint64_t EC_KEY_get_flags(uint64_t a1)
{
  return *(unsigned int *)(a1 + 60);
}

uint64_t EC_KEY_set_flags(uint64_t result, int a2)
{
  *(_DWORD *)(result + 60) |= a2;
  return result;
}

uint64_t EC_KEY_clear_flags(uint64_t result, int a2)
{
  *(_DWORD *)(result + 60) &= ~a2;
  return result;
}

void ENGINE_unregister_pkey_asn1_meths(void *a1)
{
  engine_table_unregister((LHASH **)&pkey_asn1_meth_table, a1);
}

uint64_t ENGINE_register_pkey_asn1_meths(uint64_t a1)
{
  uint64_t (*v1)(void);
  int v3;

  v1 = *(uint64_t (**)(void))(a1 + 104);
  if (v1 && (v3 = v1(), v3 > 0))
    return engine_table_register((LHASH **)&pkey_asn1_meth_table, (uint64_t)engine_unregister_all_pkey_asn1_meths, (char *)a1, 0, v3, 0);
  else
    return 1;
}

void engine_unregister_all_pkey_asn1_meths()
{
  engine_table_cleanup((LHASH **)&pkey_asn1_meth_table);
}

ENGINE *ENGINE_register_all_pkey_asn1_meths()
{
  ENGINE *result;
  ENGINE *v1;

  result = ENGINE_get_first();
  if (result)
  {
    v1 = result;
    do
    {
      ENGINE_register_pkey_asn1_meths((uint64_t)v1);
      result = ENGINE_get_next(v1);
      v1 = result;
    }
    while (result);
  }
  return result;
}

uint64_t ENGINE_set_default_pkey_asn1_meths(uint64_t a1)
{
  uint64_t (*v1)(void);
  int v3;

  v1 = *(uint64_t (**)(void))(a1 + 104);
  if (v1 && (v3 = v1(), v3 > 0))
    return engine_table_register((LHASH **)&pkey_asn1_meth_table, (uint64_t)engine_unregister_all_pkey_asn1_meths, (char *)a1, 0, v3, 1);
  else
    return 1;
}

uint64_t ENGINE_get_pkey_asn1_meth_engine(int a1)
{
  return engine_table_select((LHASH **)&pkey_asn1_meth_table, a1);
}

uint64_t ENGINE_get_pkey_asn1_meth(uint64_t a1)
{
  unsigned int (*v1)(void);
  uint64_t v3;

  v3 = 0;
  v1 = *(unsigned int (**)(void))(a1 + 104);
  if (v1 && v1())
    return v3;
  ERR_put_error(38, 4095, 101, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/engine/tb_asnmth.c", 138);
  return 0;
}

uint64_t ENGINE_get_pkey_asn1_meths(uint64_t a1)
{
  return *(_QWORD *)(a1 + 104);
}

uint64_t ENGINE_set_pkey_asn1_meths(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)(a1 + 104) = a2;
  return 1;
}

void engine_pkey_asn1_meths_free(uint64_t a1)
{
  uint64_t (*v1)(void);
  int v3;
  unsigned int *v4;
  uint64_t v5;
  uint64_t v6;

  v1 = *(uint64_t (**)(void))(a1 + 104);
  if (v1)
  {
    v6 = 0;
    v3 = v1();
    if (v3 >= 1)
    {
      v4 = 0;
      v5 = 4 * v3;
      do
      {
        if ((*(unsigned int (**)(uint64_t, uint64_t *, _QWORD, _QWORD))(a1 + 104))(a1, &v6, 0, *v4))
          EVP_PKEY_asn1_free(v6);
        ++v4;
      }
      while ((unsigned int *)v5 != v4);
    }
  }
}

uint64_t (*ENGINE_get_pkey_asn1_meth_str(uint64_t a1, char *__s, int a3))(uint64_t, _QWORD, uint64_t *, _QWORD)
{
  uint64_t (*v3)(uint64_t, _QWORD, uint64_t *, _QWORD);
  int v4;
  int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v11;
  uint64_t v12;

  v3 = *(uint64_t (**)(uint64_t, _QWORD, uint64_t *, _QWORD))(a1 + 104);
  if (v3)
  {
    v4 = a3;
    if (a3 == -1)
      v4 = strlen(__s);
    v11 = 0;
    v12 = 0;
    v7 = v3(a1, 0, &v12, 0);
    if (v7 < 1)
    {
      return 0;
    }
    else
    {
      v8 = 0;
      v9 = 4 * v7;
      while (1)
      {
        (*(void (**)(uint64_t, uint64_t *, _QWORD, _QWORD))(a1 + 104))(a1, &v11, 0, *(unsigned int *)(v12 + v8));
        v3 = (uint64_t (*)(uint64_t, _QWORD, uint64_t *, _QWORD))v11;
        if (v4 == strlen(*(const char **)(v11 + 16)) && !strncasecmp(*(const char **)(v11 + 16), __s, v4))
          break;
        v8 += 4;
        if (v9 == v8)
          return 0;
      }
    }
  }
  return v3;
}

uint64_t ENGINE_pkey_asn1_find_str(_QWORD *a1, uint64_t a2, unsigned int a3)
{
  uint64_t v4;
  __int128 v6;
  uint64_t v7;
  uint64_t v8;

  v6 = 0u;
  v7 = a2;
  v8 = a3;
  CRYPTO_lock(9, 30, 0, 0);
  engine_table_doall((LHASH *)pkey_asn1_meth_table, (uint64_t)look_str_cb, (uint64_t)&v6);
  v4 = v6;
  if ((_QWORD)v6)
    ++*(_DWORD *)(v6 + 180);
  *a1 = v4;
  CRYPTO_lock(10, 30, 0, 0);
  return *((_QWORD *)&v6 + 1);
}

uint64_t look_str_cb(uint64_t result, STACK *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6;
  int v7;
  char *v8;
  uint64_t v9;
  int v10;
  uint64_t v11;

  if (!*(_QWORD *)(a4 + 8))
  {
    v6 = result;
    result = sk_num(a2);
    if ((int)result >= 1)
    {
      v7 = 0;
      while (1)
      {
        v8 = sk_value(a2, v7);
        v11 = 0;
        (*((void (**)(char *, uint64_t *, _QWORD, uint64_t))v8 + 13))(v8, &v11, 0, v6);
        v9 = v11;
        v10 = strlen(*(const char **)(v11 + 16));
        if (*(_DWORD *)(a4 + 24) == v10)
        {
          result = strncasecmp(*(const char **)(v11 + 16), *(const char **)(a4 + 16), v10);
          if (!(_DWORD)result)
            break;
        }
        ++v7;
        result = sk_num(a2);
        if (v7 >= (int)result)
          return result;
      }
      *(_QWORD *)a4 = v8;
      *(_QWORD *)(a4 + 8) = v9;
    }
  }
  return result;
}

uint64_t OpenSSL_config(uint64_t a1)
{
  uint64_t result;

  if (a1)
    openssl_config_name = a1;
  result = OPENSSL_init_crypto(0, 0);
  if ((_DWORD)result)
    return pthread_once(&openssl_configured, (void (*)(void))OPENSSL_config_internal) == 0;
  return result;
}

uint64_t OPENSSL_config_internal()
{
  uint64_t result;
  BIO *v1;
  BIO *v2;

  OPENSSL_load_builtin_modules();
  ENGINE_load_builtin_engines();
  ERR_clear_error();
  result = CONF_modules_load_file(0, (const char *)openssl_config_name, 0x30uLL);
  if ((int)result <= 0)
  {
    ERR_load_crypto_strings();
    v1 = BIO_new_fp((FILE *)*MEMORY[0x24BDAC8D8], 0);
    if (v1)
    {
      v2 = v1;
      BIO_printf(v1, "Auto configuration failed\n");
      ERR_print_errors(v2);
      BIO_free(v2);
    }
    exit(1);
  }
  return result;
}

BOOL OpenSSL_no_config()
{
  return pthread_once(&openssl_configured, (void (*)(void))OPENSSL_no_config_internal) == 0;
}

void OPENSSL_no_config(void)
{
  pthread_once(&openssl_configured, (void (*)(void))OPENSSL_no_config_internal);
}

int BIO_dump_cb(int (__cdecl *cb)(const void *, size_t, void *), void *u, const char *s, int len)
{
  return BIO_dump_indent_cb(cb, u, s, len, 0);
}

int BIO_dump_indent_cb(int (__cdecl *cb)(const void *, size_t, void *), void *u, const char *s, int len, int indent)
{
  int v5;
  const char *v6;
  int v9;
  int v10;
  int v11;
  unsigned int v12;
  int v13;
  int v14;
  int v15;
  int v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  int v25;
  int v26;
  size_t v27;
  int v28;
  size_t v29;
  int v30;
  int v32;
  const char *v33;
  void *v34;
  int (__cdecl *v35)(const void *, size_t, void *);
  int v36;
  uint64_t v37;
  int v38;
  char v39[129];
  char __str[20];
  char __s[289];
  uint64_t v42;

  v5 = len;
  v6 = s;
  v42 = *MEMORY[0x24BDAC8D0];
  if (len < 1)
  {
    v11 = len;
    v5 = 0;
  }
  else
  {
    v9 = 0;
    v10 = len - 1;
    while ((s[v10] | 0x20) == 0x20)
    {
      ++v9;
      --v10;
      if (len == v9)
      {
        v11 = 0;
        goto LABEL_8;
      }
    }
    v11 = len - v9;
    v5 = v9;
  }
LABEL_8:
  v12 = indent & ~(indent >> 31);
  if (v12 >= 0x40)
    v13 = 64;
  else
    v13 = indent & ~(indent >> 31);
  __memset_chk();
  v39[v13] = 0;
  if (v12 >= 6)
    v14 = 6;
  else
    v14 = v12;
  v15 = v13 - v14;
  if (v15 > 60)
    return -1;
  v32 = v5;
  v17 = (16 - ((char)(v15 + 3 + (((char)(v15 + 3) >> 13) & 3)) >> 2));
  LODWORD(v18) = v11 / (int)v17;
  if (v11 / (int)v17 * (int)v17 >= v11)
    v18 = v18;
  else
    v18 = (v18 + 1);
  v37 = v18;
  if ((int)v18 >= 1)
  {
    v19 = 0;
    v20 = 0;
    v16 = 0;
    if ((16 - ((char)(v15 + 3 + (((char)(v15 + 3) >> 13) & 3)) >> 2)) <= 1u)
      v21 = 1;
    else
      v21 = (16 - ((char)(v15 + 3 + (((char)(v15 + 3) >> 13) & 3)) >> 2));
    v36 = (char)v15;
    v33 = v6;
    v34 = u;
    v35 = cb;
    while (1)
    {
      v38 = v16;
      __strlcpy_chk();
      snprintf(__str, 0x14uLL, "%04x - ", v20 * v17);
      __strlcat_chk();
      if (v36 >= 61)
      {
        __strlcat_chk();
      }
      else
      {
        v22 = 0;
        do
        {
          if (v19 + v22 < v11)
          {
            v23 = 32;
            if (v22 == 7)
              v23 = 45;
            snprintf(__str, 0x14uLL, "%02x%c", v33[v19 + v22], v23);
          }
          __strlcat_chk();
          ++v22;
        }
        while (v21 != v22);
        __strlcat_chk();
        cb = v35;
        u = v34;
        if ((uint64_t)(v20 * v17) < v11)
        {
          v24 = 0;
          do
          {
            v25 = v6[v24];
            if ((v25 - 32) >= 0x5F)
              LOBYTE(v25) = 46;
            __str[0] = v25;
            __str[1] = 0;
            __strlcat_chk();
            if (v24 + 1 >= v17)
              break;
            v26 = v19 + v24++ + 1;
          }
          while (v26 < v11);
        }
      }
      __strlcat_chk();
      v27 = strlen(__s);
      v28 = ((uint64_t (*)(char *, size_t, void *))cb)(__s, v27, u);
      if (v28 < 0)
        return -1;
      v16 = v28 + v38;
      ++v20;
      v19 += v17;
      v6 += v17;
      if (v20 == v37)
        goto LABEL_43;
    }
  }
  v16 = 0;
LABEL_43:
  if (v32)
  {
    snprintf(__s, 0x121uLL, "%s%04x - <SPACES/NULS>\n", v39, v32 + v11);
    v29 = strlen(__s);
    v30 = ((uint64_t (*)(char *, size_t, void *))cb)(__s, v29, u);
    if (v30 < 0)
      return -1;
    else
      v16 += v30;
  }
  return v16;
}

int BIO_dump_fp(FILE *fp, const char *s, int len)
{
  return BIO_dump_indent_cb((int (__cdecl *)(const void *, size_t, void *))write_fp, fp, s, len, 0);
}

size_t write_fp(const void *a1, size_t __nitems, FILE *__stream)
{
  return fwrite(a1, 1uLL, __nitems, __stream);
}

int BIO_dump_indent_fp(FILE *fp, const char *s, int len, int indent)
{
  return BIO_dump_indent_cb((int (__cdecl *)(const void *, size_t, void *))write_fp, fp, s, len, indent);
}

int BIO_dump(BIO *b, const char *bytes, int len)
{
  return BIO_dump_indent_cb((int (__cdecl *)(const void *, size_t, void *))write_bio, b, bytes, len, 0);
}

uint64_t write_bio(void *data, int len, BIO *b)
{
  return BIO_write(b, data, len);
}

int BIO_dump_indent(BIO *b, const char *bytes, int len, int indent)
{
  return BIO_dump_indent_cb((int (__cdecl *)(const void *, size_t, void *))write_bio, b, bytes, len, indent);
}

int (__cdecl *__cdecl X509_TRUST_set_default(int (__cdecl *trust)(int, X509 *, int)))(int, X509 *, int)
{
  int (__cdecl *v1)(int, X509 *, int);

  v1 = (int (__cdecl *)(int, X509 *, int))default_trust;
  default_trust = (uint64_t (*)())trust;
  return v1;
}

int X509_check_trust(X509 *x, int id, int flags)
{
  int result;
  uint64_t v6;
  unsigned int v7;
  char *v8;

  if (id == -1)
    return 1;
  if (id)
  {
    v6 = *(_QWORD *)&flags;
    v7 = X509_TRUST_get_by_id(id);
    if (v7 == -1)
    {
      return default_trust(id, (uint64_t)x);
    }
    else
    {
      if (v7 > 7)
        v8 = sk_value((const STACK *)trtable, v7 - 8);
      else
        v8 = (char *)&trstandard + 40 * v7;
      return (*((uint64_t (**)(char *, X509 *, uint64_t))v8 + 1))(v8, x, v6);
    }
  }
  else
  {
    result = obj_trust(910, (uint64_t)x);
    if (result == 3)
    {
      X509_check_purpose(x, -1, 0);
      if ((x->ex_pathlen & 0x2000) != 0)
        return 1;
      else
        return 3;
    }
  }
  return result;
}

uint64_t obj_trust(int a1, uint64_t a2)
{
  const STACK **v2;
  const STACK *v4;
  int v5;
  char *v6;
  int v7;
  uint64_t result;
  int v9;
  char *v10;
  int v11;

  v2 = *(const STACK ***)(a2 + 224);
  if (!v2)
    return 3;
  v4 = v2[1];
  if (!v4 || sk_num(v4) < 1)
  {
LABEL_8:
    if (*v2 && sk_num(*v2) >= 1)
    {
      v9 = 0;
      while (1)
      {
        v10 = sk_value(*v2, v9);
        v11 = OBJ_obj2nid((const ASN1_OBJECT *)v10);
        result = 1;
        if (v11 == a1 || v11 == 910)
          break;
        if (++v9 >= sk_num(*v2))
          return 3;
      }
      return result;
    }
    return 3;
  }
  v5 = 0;
  while (1)
  {
    v6 = sk_value(v2[1], v5);
    v7 = OBJ_obj2nid((const ASN1_OBJECT *)v6);
    result = 2;
    if (v7 == a1 || v7 == 910)
      return result;
    if (++v5 >= sk_num(v2[1]))
      goto LABEL_8;
  }
}

uint64_t trust_compat(int a1, X509 *x)
{
  X509_check_purpose(x, -1, 0);
  if ((x->ex_pathlen & 0x2000) != 0)
    return 1;
  else
    return 3;
}

int X509_TRUST_get_by_id(int id)
{
  uint64_t v1;
  uint64_t v2;
  int result;
  int v5;
  _OWORD v6[2];
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  result = id - 1;
  if (result >= 8)
  {
    v8 = v1;
    v9 = v2;
    v7 = 0;
    memset(v6, 0, sizeof(v6));
    LODWORD(v6[0]) = id;
    if (trtable)
    {
      v5 = sk_find((STACK *)trtable, (char *)v6);
      if (v5 == -1)
        return -1;
      else
        return v5 + 8;
    }
    else
    {
      return -1;
    }
  }
  return result;
}

X509_TRUST *__cdecl X509_TRUST_get0(int idx)
{
  if (idx < 0)
    return 0;
  if (idx > 7)
    return (X509_TRUST *)sk_value((const STACK *)trtable, idx - 8);
  return (X509_TRUST *)((char *)&trstandard + 40 * idx);
}

int X509_TRUST_get_count(void)
{
  if (trtable)
    return sk_num((const STACK *)trtable) + 8;
  else
    return 8;
}

int X509_TRUST_set(int *t, int trust)
{
  if (X509_TRUST_get_by_id(trust) == -1)
  {
    ERR_put_error(11, 4095, 123, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_trs.c", 188);
    return 0;
  }
  else
  {
    *t = trust;
    return 1;
  }
}

int X509_TRUST_add(int id, int flags, int (__cdecl *ck)(X509_TRUST *, X509 *, int), char *name, int arg1, void *arg2)
{
  unsigned int v12;
  unsigned int v13;
  char *v14;
  char *v15;
  char *v16;
  unsigned int v17;
  int v18;
  STACK *v19;
  int v21;
  int v22;

  v12 = X509_TRUST_get_by_id(id);
  v13 = v12;
  if (v12 == -1)
  {
    v15 = (char *)malloc_type_malloc(0x28uLL, 0x10900403507AD87uLL);
    if (v15)
    {
      v14 = v15;
      *((_DWORD *)v15 + 1) = 1;
      v16 = strdup(name);
      if (!v16)
      {
LABEL_20:
        free(v14);
        goto LABEL_21;
      }
LABEL_10:
      v17 = flags & 0xFFFFFFFC;
      v18 = *((_DWORD *)v14 + 1);
      if ((v18 & 2) != 0)
      {
        free(*((void **)v14 + 2));
        v18 = *((_DWORD *)v14 + 1);
      }
      *(_DWORD *)v14 = id;
      *((_DWORD *)v14 + 1) = v17 | v18 & 1 | 2;
      *((_QWORD *)v14 + 1) = ck;
      *((_QWORD *)v14 + 2) = v16;
      *((_DWORD *)v14 + 6) = arg1;
      *((_QWORD *)v14 + 4) = arg2;
      if (v13 != -1)
        return 1;
      v19 = (STACK *)trtable;
      if (trtable
        || (v19 = sk_new((int (__cdecl *)(const char *const *, const char *const *))tr_cmp),
            (trtable = (uint64_t)v19) != 0))
      {
        if (sk_push(v19, v14))
          return 1;
      }
      free(v16);
      goto LABEL_20;
    }
    v21 = 65;
    v22 = 213;
  }
  else
  {
    if ((v12 & 0x80000000) == 0)
    {
      if (v12 <= 7)
      {
        v14 = (char *)&trstandard + 40 * v12;
        goto LABEL_9;
      }
      v14 = sk_value((const STACK *)trtable, v12 - 8);
      if (v14)
      {
LABEL_9:
        v16 = strdup(name);
        if (!v16)
        {
LABEL_21:
          v21 = 65;
          v22 = 257;
          goto LABEL_22;
        }
        goto LABEL_10;
      }
    }
    v21 = 123;
    v22 = 220;
  }
LABEL_22:
  ERR_put_error(11, 4095, v21, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_trs.c", v22);
  return 0;
}

uint64_t tr_cmp(_DWORD **a1, _DWORD **a2)
{
  return (**a1 - **a2);
}

void X509_TRUST_cleanup(void)
{
  sk_pop_free((STACK *)trtable, (void (__cdecl *)(void *))trtable_free);
  trtable = 0;
}

void trtable_free(void *a1)
{
  int v2;

  if (a1)
  {
    v2 = *((_DWORD *)a1 + 1);
    if ((v2 & 1) != 0)
    {
      if ((v2 & 2) != 0)
        free(*((void **)a1 + 2));
      free(a1);
    }
  }
}

int X509_TRUST_get_flags(X509_TRUST *xp)
{
  return xp->flags;
}

char *__cdecl X509_TRUST_get0_name(X509_TRUST *xp)
{
  return xp->name;
}

int X509_TRUST_get_trust(X509_TRUST *xp)
{
  return xp->trust;
}

uint64_t trust_1oidany(uint64_t a1, X509 *x)
{
  _QWORD *ex_pcpathlen;

  ex_pcpathlen = (_QWORD *)x[1].ex_pcpathlen;
  if (ex_pcpathlen && (*ex_pcpathlen || ex_pcpathlen[1]))
    return obj_trust(*(_DWORD *)(a1 + 24), (uint64_t)x);
  X509_check_purpose(x, -1, 0);
  if ((x->ex_pathlen & 0x2000) != 0)
    return 1;
  else
    return 3;
}

uint64_t trust_1oid(uint64_t a1, uint64_t a2)
{
  if (*(_QWORD *)(a2 + 224))
    return obj_trust(*(_DWORD *)(a1 + 24), a2);
  else
    return 3;
}

uint64_t pub_decode_gost01(uint64_t a1, uint64_t a2)
{
  ASN1_OCTET_STRING *v3;
  ASN1_OCTET_STRING *v4;
  int v5;
  unint64_t v6;
  BIGNUM *v7;
  BIGNUM *v8;
  uint64_t v9;
  int v10;
  int v11;
  _QWORD *v13;
  int pptype;
  _DWORD len[3];
  const unsigned __int8 *v16;
  unsigned __int8 *in;
  X509_ALGOR *algor;

  in = 0;
  algor = 0;
  pptype = -1;
  memset(len, 0, sizeof(len));
  v13 = 0;
  if (!X509_PUBKEY_get0_param(&len[1], &in, len, &algor, a2))
    return 0;
  EVP_PKEY_assign((EVP_PKEY *)a1, 811, 0);
  X509_ALGOR_get0(0, &pptype, (void **)&v13, algor);
  if (pptype != 16)
  {
    v10 = 104;
    v11 = 211;
LABEL_11:
    ERR_put_error(50, 4095, v10, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/gost/gostr341001_ameth.c", v11);
    return 0;
  }
  v16 = (const unsigned __int8 *)v13[1];
  if (!decode_gost01_algor_params((EVP_PKEY *)a1, &v16, *(_DWORD *)v13))
  {
    v10 = 104;
    v11 = 216;
    goto LABEL_11;
  }
  v3 = d2i_ASN1_OCTET_STRING(0, (const unsigned __int8 **)&in, len[0]);
  if (!v3)
  {
    v10 = 65;
    v11 = 222;
    goto LABEL_11;
  }
  v4 = v3;
  v5 = v3->length / 2;
  v6 = (uint64_t)(v3->length + (v3->length < 0)) >> 1;
  v7 = GOST_le2bn(v3->data, v6, 0);
  v8 = GOST_le2bn(&v4->data[v5], v6, 0);
  ASN1_OCTET_STRING_free(v4);
  v9 = GOST_KEY_set_public_key_affine_coordinates(*(const EC_GROUP ***)(a1 + 32), v7, v8);
  if (!(_DWORD)v9)
    ERR_put_error(50, 4095, 16, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/gost/gostr341001_ameth.c", 234);
  BN_free(v7);
  BN_free(v8);
  return v9;
}

ASN1_STRING *pub_encode_gost01(uint64_t a1, uint64_t a2)
{
  BIGNUM *v4;
  int digest;
  int pk_digest;
  ASN1_OBJECT *v7;
  ASN1_STRING *result;
  ASN1_STRING *v9;
  int v10;
  int size;
  uint64_t v12;
  _QWORD *v13;
  ASN1_OCTET_STRING *v14;
  ASN1_BIT_STRING *v15;
  BIGNUM *v16;
  BIGNUM *v17;
  BIGNUM *v18;
  uint64_t v19;
  int v20;
  int v21;
  int v22;
  int v23;
  int v24;
  unsigned __int8 *v25;
  unsigned __int8 *out;

  out = 0;
  v4 = *(BIGNUM **)(a2 + 32);
  digest = GOST_KEY_get_digest((uint64_t)v4);
  pk_digest = GostR3410_get_pk_digest(digest);
  v7 = OBJ_nid2obj(pk_digest);
  if (*(_DWORD *)(a2 + 40))
  {
    result = encode_gost01_algor_params(a2);
    if (!result)
      return result;
    v9 = result;
    v10 = 16;
  }
  else
  {
    v9 = 0;
    v10 = -1;
  }
  size = GOST_KEY_get_size(v4);
  v12 = GOST_KEY_get0_public_key((uint64_t)v4);
  if (!v12)
  {
    ERR_put_error(50, 4095, 118, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/gost/gostr341001_ameth.c", 269);
    v15 = 0;
LABEL_17:
    v16 = 0;
    v18 = 0;
    goto LABEL_18;
  }
  v13 = (_QWORD *)v12;
  v14 = ASN1_OCTET_STRING_new();
  v15 = v14;
  if (!v14)
  {
    v21 = 65;
    v22 = 275;
LABEL_16:
    ERR_put_error(50, 4095, v21, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/gost/gostr341001_ameth.c", v22);
    goto LABEL_17;
  }
  if (!ASN1_STRING_set(v14, 0, 2 * size))
  {
    v21 = 68;
    v22 = 281;
    goto LABEL_16;
  }
  v25 = ASN1_STRING_data(v15);
  v16 = BN_new();
  v17 = BN_new();
  v18 = v17;
  if (v16 && v17)
  {
    v19 = GOST_KEY_get0_group((uint64_t)v4);
    if (EC_POINT_get_affine_coordinates(v19, v13, (uint64_t)v16, (uint64_t)v18, 0))
    {
      GOST_bn2le(v16, (uint64_t)v25, size);
      GOST_bn2le(v18, (uint64_t)&v25[size], size);
      BN_free(v18);
      BN_free(v16);
      v20 = i2d_ASN1_OCTET_STRING(v15, &out);
      ASN1_BIT_STRING_free(v15);
      if ((v20 & 0x80000000) == 0)
        return (ASN1_STRING *)X509_PUBKEY_set0_param(a1, v7, v10, v9, out, v20);
      return 0;
    }
    v23 = 16;
    v24 = 296;
  }
  else
  {
    v23 = 65;
    v24 = 290;
  }
  ERR_put_error(50, 4095, v23, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/gost/gostr341001_ameth.c", v24);
LABEL_18:
  BN_free(v18);
  BN_free(v16);
  ASN1_BIT_STRING_free(v15);
  ASN1_STRING_free(v9);
  return 0;
}

BOOL pub_cmp_gost01(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  BOOL v4;
  const EC_POINT *v5;
  uint64_t v6;
  const EC_POINT *v8;
  const EC_GROUP *v9;

  v2 = *(_QWORD *)(a1 + 32);
  v3 = *(_QWORD *)(a2 + 32);
  if (v2)
    v4 = v3 == 0;
  else
    v4 = 1;
  if (v4)
    return 0;
  v5 = (const EC_POINT *)GOST_KEY_get0_public_key(*(_QWORD *)(a1 + 32));
  v6 = GOST_KEY_get0_public_key(v3);
  if (!v5 || v6 == 0)
    return 0;
  v8 = (const EC_POINT *)v6;
  v9 = (const EC_GROUP *)GOST_KEY_get0_group(v2);
  return EC_POINT_cmp(v9, v5, v8, 0) == 0;
}

uint64_t pub_print_gost01(BIO *a1, uint64_t a2, int a3)
{
  BN_CTX *v6;
  BN_CTX *v7;
  BIGNUM *v8;
  const BIGNUM *v9;
  BIGNUM *v10;
  const BIGNUM *v11;
  _QWORD *v12;
  uint64_t v13;

  v6 = BN_CTX_new();
  if (v6)
  {
    v7 = v6;
    BN_CTX_start(v6);
    v8 = BN_CTX_get(v7);
    if (v8)
    {
      v9 = v8;
      v10 = BN_CTX_get(v7);
      if (v10)
      {
        v11 = v10;
        v12 = (_QWORD *)GOST_KEY_get0_public_key(*(_QWORD *)(a2 + 32));
        v13 = GOST_KEY_get0_group(*(_QWORD *)(a2 + 32));
        if (EC_POINT_get_affine_coordinates(v13, v12, (uint64_t)v9, (uint64_t)v11, v7))
        {
          if (BIO_indent(a1, a3, 128))
          {
            BIO_printf(a1, "Public key:\n");
            if (BIO_indent(a1, a3 + 3, 128))
            {
              BIO_printf(a1, "X:");
              BN_print(a1, v9);
              BIO_printf(a1, "\n");
              if (BIO_indent(a1, a3 + 3, 128))
              {
                BIO_printf(a1, "Y:");
                BN_print(a1, v11);
                BIO_printf(a1, "\n");
                BN_CTX_end(v7);
                BN_CTX_free(v7);
                return param_print_gost01(a1, a2, a3);
              }
            }
          }
        }
        else
        {
          ERR_put_error(50, 4095, 16, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/gost/gostr341001_ameth.c", 357);
        }
      }
    }
    BN_CTX_end(v7);
    BN_CTX_free(v7);
  }
  else
  {
    ERR_put_error(50, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/gost/gostr341001_ameth.c", 346);
  }
  return 0;
}

BOOL priv_decode_gost01(EVP_PKEY *a1, uint64_t a2)
{
  ASN1_OCTET_STRING *v3;
  ASN1_STRING *v4;
  BIGNUM *v5;
  int v6;
  int v7;
  _BOOL8 v8;
  ASN1_INTEGER *v10;
  ASN1_INTEGER *v11;
  const EC_GROUP **attributes;
  char *v13;
  void *ppval;
  int pptype;
  uint64_t v16;
  X509_ALGOR *algor;
  int len[3];
  unsigned __int8 *v19;

  v19 = 0;
  len[0] = 0;
  v16 = 0;
  algor = 0;
  pptype = -1;
  ppval = 0;
  if (!PKCS8_pkey_get0(&v16, &v19, len, &algor, a2))
  {
    v6 = 104;
    v7 = 418;
LABEL_10:
    ERR_put_error(50, 4095, v6, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/gost/gostr341001_ameth.c", v7);
    return 0;
  }
  EVP_PKEY_assign(a1, 811, 0);
  X509_ALGOR_get0(0, &pptype, &ppval, algor);
  if (pptype != 16)
  {
    v6 = 104;
    v7 = 424;
    goto LABEL_10;
  }
  *(_QWORD *)&len[1] = *((_QWORD *)ppval + 1);
  if (!decode_gost01_algor_params(a1, (const unsigned __int8 **)&len[1], *(_DWORD *)ppval))
  {
    v6 = 104;
    v7 = 429;
    goto LABEL_10;
  }
  *(_QWORD *)&len[1] = v19;
  if (*v19 == 4)
  {
    v3 = d2i_ASN1_OCTET_STRING(0, (const unsigned __int8 **)&len[1], len[0]);
    if (!v3)
    {
      ERR_put_error(50, 4095, 114, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/gost/gostr341001_ameth.c", 439);
      ASN1_STRING_free(0);
      return 0;
    }
    v4 = v3;
    v5 = GOST_le2bn(v3->data, v3->length, 0);
    ASN1_STRING_free(v4);
    goto LABEL_15;
  }
  v10 = d2i_ASN1_INTEGER(0, (const unsigned __int8 **)&len[1], len[0]);
  if (!v10)
    return 0;
  v11 = v10;
  v5 = ASN1_INTEGER_to_BN(v10, 0);
  ASN1_INTEGER_free(v11);
  if (!v5)
  {
    v6 = 114;
    v7 = 453;
    goto LABEL_10;
  }
LABEL_15:
  attributes = (const EC_GROUP **)a1->attributes;
  if (!attributes)
  {
    v13 = (char *)GOST_KEY_new();
    if (!v13)
      goto LABEL_22;
    attributes = (const EC_GROUP **)v13;
    if (!EVP_PKEY_assign(a1, 811, v13))
    {
      BN_free(v5);
      GOST_KEY_free((uint64_t)attributes);
      return 0;
    }
  }
  if (!GOST_KEY_set_private_key((uint64_t)attributes, v5))
  {
LABEL_22:
    BN_free(v5);
    return 0;
  }
  if (EVP_PKEY_missing_parameters(a1))
    v8 = 0;
  else
    v8 = gost2001_compute_public(attributes) != 0;
  BN_free(v5);
  return v8;
}

ASN1_STRING *priv_encode_gost01(uint64_t a1, uint64_t a2)
{
  int digest;
  int pk_digest;
  ASN1_OBJECT *v6;
  ASN1_STRING *result;
  ASN1_STRING *v8;
  BIGNUM *v9;
  ASN1_INTEGER *v10;
  ASN1_INTEGER *v11;
  int v12;
  unsigned __int8 *out;

  digest = GOST_KEY_get_digest(*(_QWORD *)(a2 + 32));
  pk_digest = GostR3410_get_pk_digest(digest);
  v6 = OBJ_nid2obj(pk_digest);
  result = encode_gost01_algor_params(a2);
  out = 0;
  if (result)
  {
    v8 = result;
    v9 = (BIGNUM *)GOST_KEY_get0_private_key(*(_QWORD *)(a2 + 32));
    v10 = BN_to_ASN1_INTEGER(v9, 0);
    if (v10)
    {
      v11 = v10;
      v12 = i2d_ASN1_INTEGER(v10, &out);
      ASN1_INTEGER_free(v11);
      return (ASN1_STRING *)PKCS8_pkey_set0(a1, v6, 0, 16, v8, out, v12);
    }
    else
    {
      ASN1_STRING_free(v8);
      return 0;
    }
  }
  return result;
}

uint64_t priv_print_gost01(BIO *a1, uint64_t a2, int indent)
{
  uint64_t result;
  const BIGNUM *v7;

  result = BIO_indent(a1, indent, 128);
  if ((_DWORD)result)
  {
    BIO_printf(a1, "Private key: ");
    v7 = (const BIGNUM *)GOST_KEY_get0_private_key(*(_QWORD *)(a2 + 32));
    if (v7)
      BN_print(a1, v7);
    else
      BIO_printf(a1, "<undefined)");
    BIO_printf(a1, "\n");
    return pub_print_gost01(a1, a2, indent);
  }
  return result;
}

uint64_t pkey_size_gost01(uint64_t a1)
{
  if (GOST_KEY_get_digest(*(_QWORD *)(a1 + 32)) == 942)
    return 128;
  else
    return 64;
}

uint64_t pkey_bits_gost01(uint64_t a1)
{
  if (GOST_KEY_get_digest(*(_QWORD *)(a1 + 32)) == 942)
    return 512;
  else
    return 256;
}

uint64_t param_decode_gost01(EVP_PKEY *a1, const unsigned __int8 **a2, int a3)
{
  uint64_t result;
  int v5;
  EC_GROUP **v6;
  EC_GROUP **v7;
  EC_GROUP *v8;
  EC_GROUP *v9;
  int v10;
  int v11;
  int v12;
  ASN1_OBJECT *a;

  a = 0;
  if (**a2 == 48)
    return decode_gost01_algor_params(a1, a2, a3);
  if (d2i_ASN1_OBJECT(&a, a2, a3))
  {
    v5 = OBJ_obj2nid(a);
    ASN1_OBJECT_free(a);
    v6 = (EC_GROUP **)GOST_KEY_new();
    if (v6)
    {
      v7 = v6;
      v8 = EC_GROUP_new_by_curve_name(v5);
      if (v8)
      {
        v9 = v8;
        EC_GROUP_set_asn1_flag(v8, 1);
        if (!GOST_KEY_set_group(v7, v9))
        {
          ERR_put_error(50, 4095, 16, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/gost/gostr341001_ameth.c", 558);
          EC_GROUP_free(v9);
LABEL_17:
          GOST_KEY_free((uint64_t)v7);
          return 0;
        }
        EC_GROUP_free(v9);
        if (GOST_KEY_set_digest((uint64_t)v7, 822))
        {
          result = EVP_PKEY_assign(a1, 811, (char *)v7);
          if ((_DWORD)result)
            return result;
          goto LABEL_17;
        }
        v11 = 100;
        v12 = 566;
      }
      else
      {
        v11 = 119;
        v12 = 551;
      }
      ERR_put_error(50, 4095, v11, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/gost/gostr341001_ameth.c", v12);
      goto LABEL_17;
    }
    v10 = 546;
  }
  else
  {
    v10 = 538;
  }
  ERR_put_error(50, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/gost/gostr341001_ameth.c", v10);
  return 0;
}

uint64_t param_encode_gost01(uint64_t a1, void **a2)
{
  ASN1_STRING *v3;
  ASN1_STRING *v4;
  uint64_t length;

  v3 = encode_gost01_algor_params(a1);
  if (!v3)
    return 0;
  v4 = v3;
  length = v3->length;
  if (a2)
    memcpy(*a2, v3->data, (int)length);
  ASN1_STRING_free(v4);
  return length;
}

BOOL param_missing_gost01(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 32);
  return !v1 || !GOST_KEY_get0_group(*(_QWORD *)(a1 + 32)) || GOST_KEY_get_digest(v1) == 0;
}

uint64_t param_copy_gost01(EVP_PKEY *a1, uint64_t a2)
{
  char *attributes;
  uint64_t v5;
  int v6;
  const EC_GROUP *v7;
  int digest;
  int v10;
  int v11;
  char *v12;
  int v13;

  attributes = (char *)a1->attributes;
  v5 = *(_QWORD *)(a2 + 32);
  v6 = EVP_PKEY_base_id((int *)a2);
  if (v6 != EVP_PKEY_base_id(&a1->type))
  {
    v10 = 110;
    v11 = 598;
LABEL_8:
    ERR_put_error(50, 4095, v10, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/gost/gostr341001_ameth.c", v11);
    return 0;
  }
  if (!v5)
  {
    v10 = 113;
    v11 = 602;
    goto LABEL_8;
  }
  if (attributes)
    goto LABEL_4;
  v12 = (char *)GOST_KEY_new();
  if (!v12)
  {
    v10 = 65;
    v11 = 608;
    goto LABEL_8;
  }
  attributes = v12;
  v13 = EVP_PKEY_base_id((int *)a2);
  if (!EVP_PKEY_assign(a1, v13, attributes))
  {
    GOST_KEY_free((uint64_t)attributes);
    return 0;
  }
LABEL_4:
  v7 = (const EC_GROUP *)GOST_KEY_get0_group(v5);
  GOST_KEY_set_group((EC_GROUP **)attributes, v7);
  digest = GOST_KEY_get_digest(v5);
  GOST_KEY_set_digest((uint64_t)attributes, digest);
  if (GOST_KEY_get0_private_key((uint64_t)attributes))
    return gost2001_compute_public((const EC_GROUP **)attributes);
  else
    return 1;
}

BOOL param_cmp_gost01(uint64_t a1, uint64_t a2)
{
  const EC_GROUP *v4;
  int curve_name;
  const EC_GROUP *v6;
  int digest;

  v4 = (const EC_GROUP *)GOST_KEY_get0_group(*(_QWORD *)(a1 + 32));
  curve_name = EC_GROUP_get_curve_name(v4);
  v6 = (const EC_GROUP *)GOST_KEY_get0_group(*(_QWORD *)(a2 + 32));
  if (curve_name != EC_GROUP_get_curve_name(v6))
    return 0;
  digest = GOST_KEY_get_digest(*(_QWORD *)(a1 + 32));
  return digest == GOST_KEY_get_digest(*(_QWORD *)(a2 + 32));
}

uint64_t param_print_gost01(BIO *a1, uint64_t a2, int a3)
{
  const EC_GROUP *v6;
  int curve_name;
  uint64_t result;
  const char *v9;
  int digest;
  const char *v11;

  v6 = (const EC_GROUP *)GOST_KEY_get0_group(*(_QWORD *)(a2 + 32));
  curve_name = EC_GROUP_get_curve_name(v6);
  result = BIO_indent(a1, a3, 128);
  if ((_DWORD)result)
  {
    v9 = OBJ_nid2ln(curve_name);
    BIO_printf(a1, "Parameter set: %s\n", v9);
    result = BIO_indent(a1, a3, 128);
    if ((_DWORD)result)
    {
      digest = GOST_KEY_get_digest(*(_QWORD *)(a2 + 32));
      v11 = OBJ_nid2ln(digest);
      BIO_printf(a1, "Digest Algorithm: %s\n", v11);
      return 1;
    }
  }
  return result;
}

void pkey_free_gost01(uint64_t a1)
{
  GOST_KEY_free(*(_QWORD *)(a1 + 32));
}

uint64_t pkey_ctrl_gost01(uint64_t a1, int a2, uint64_t a3, _QWORD *a4)
{
  uint64_t digest;
  uint64_t v9;
  X509_ALGOR *v10;
  int md_digest;
  ASN1_OBJECT *v12;
  X509_ALGOR *v14;
  int pk_digest;
  ASN1_OBJECT *v16;
  ASN1_STRING *v17;
  ASN1_STRING *v18;
  X509_ALGOR *v19;
  int v20;
  ASN1_OBJECT *v21;
  X509_ALGOR *v22;
  X509_ALGOR *v23;
  X509_ALGOR *v24;

  v23 = 0;
  v24 = 0;
  v22 = 0;
  digest = GOST_KEY_get_digest(*(_QWORD *)(a1 + 32));
  v9 = digest;
  switch(a2)
  {
    case 3:
      *(_DWORD *)a4 = GostR3410_get_md_digest(digest);
      return 2;
    case 2:
      if (!a3)
        PKCS7_RECIP_INFO_get0_alg((uint64_t)a4, &v22);
      break;
    case 1:
      if (!a3)
      {
        PKCS7_SIGNER_INFO_get0_algs(a4, 0, &v24, &v23);
        v10 = v24;
        if (v24)
        {
          md_digest = GostR3410_get_md_digest(v9);
          v12 = OBJ_nid2obj(md_digest);
          X509_ALGOR_set0(v10, v12, 5, 0);
        }
      }
      break;
    default:
      return 4294967294;
  }
  v14 = v23;
  if (v23)
  {
    pk_digest = GostR3410_get_pk_digest(v9);
    v16 = OBJ_nid2obj(pk_digest);
    X509_ALGOR_set0(v14, v16, 5, 0);
  }
  if (!v22)
    return 1;
  v17 = encode_gost01_algor_params(a1);
  if (v17)
  {
    v18 = v17;
    v19 = v22;
    v20 = GostR3410_get_pk_digest(v9);
    v21 = OBJ_nid2obj(v20);
    X509_ALGOR_set0(v19, v21, 16, v18);
    return 1;
  }
  return 0xFFFFFFFFLL;
}

uint64_t decode_gost01_algor_params(EVP_PKEY *a1, const unsigned __int8 **a2, int a3)
{
  const ASN1_OBJECT **v4;
  const ASN1_OBJECT **v5;
  int v6;
  int v7;
  EC_GROUP **attributes;
  EC_GROUP *v9;
  const EC_GROUP *v10;
  _BOOL4 v11;
  uint64_t result;
  int v13;
  int v14;
  char *v15;

  v4 = (const ASN1_OBJECT **)d2i_GOST_KEY_PARAMS(0, a2, a3);
  if (!v4)
  {
    v13 = 105;
    v14 = 90;
    goto LABEL_12;
  }
  v5 = v4;
  v6 = OBJ_obj2nid(*v4);
  v7 = OBJ_obj2nid(v5[1]);
  GOST_KEY_PARAMS_free((ASN1_VALUE *)v5);
  attributes = (EC_GROUP **)a1->attributes;
  if (attributes)
    goto LABEL_3;
  v15 = (char *)GOST_KEY_new();
  if (!v15)
  {
    v13 = 65;
    v14 = 101;
    goto LABEL_12;
  }
  attributes = (EC_GROUP **)v15;
  result = EVP_PKEY_assign(a1, 811, v15);
  if ((_DWORD)result)
  {
LABEL_3:
    v9 = EC_GROUP_new_by_curve_name(v6);
    if (v9)
    {
      v10 = v9;
      EC_GROUP_set_asn1_flag(v9, 1);
      v11 = GOST_KEY_set_group(attributes, v10);
      EC_GROUP_free(v10);
      if (v11)
        return GOST_KEY_set_digest((uint64_t)attributes, v7) != 0;
      return 0;
    }
    v13 = 119;
    v14 = 110;
LABEL_12:
    ERR_put_error(50, 4095, v13, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/gost/gostr341001_ameth.c", v14);
    return 0;
  }
  return result;
}

ASN1_STRING *encode_gost01_algor_params(uint64_t a1)
{
  ASN1_STRING *v2;
  ASN1_VALUE *v3;
  ASN1_VALUE *v4;
  const EC_GROUP *v5;
  int curve_name;
  int digest;
  int v8;
  int v9;

  v2 = ASN1_STRING_new();
  v3 = GOST_KEY_PARAMS_new();
  v4 = v3;
  if (!v2 || !v3)
  {
    v9 = 132;
LABEL_7:
    ERR_put_error(50, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/gost/gostr341001_ameth.c", v9);
    ASN1_STRING_free(v2);
    v2 = 0;
    goto LABEL_8;
  }
  v5 = (const EC_GROUP *)GOST_KEY_get0_group(*(_QWORD *)(a1 + 32));
  curve_name = EC_GROUP_get_curve_name(v5);
  *(_QWORD *)v4 = OBJ_nid2obj(curve_name);
  digest = GOST_KEY_get_digest(*(_QWORD *)(a1 + 32));
  *((_QWORD *)v4 + 1) = OBJ_nid2obj(digest);
  v8 = i2d_GOST_KEY_PARAMS(v4, &v2->data);
  v2->length = v8;
  if (v8 <= 0)
  {
    v9 = 145;
    goto LABEL_7;
  }
  v2->type = 16;
LABEL_8:
  GOST_KEY_PARAMS_free(v4);
  return v2;
}

int PEM_def_callback(char *buf, int num, int w, void *key)
{
  size_t v5;
  size_t v7;
  char *pw_prompt;
  char *v10;
  FILE **v11;
  size_t v12;

  if (num < 0)
    goto LABEL_15;
  LODWORD(v5) = num;
  if (key)
  {
    v7 = strlen((const char *)key);
    if (v7 >= v5)
      v5 = v5;
    else
      v5 = v7;
    memcpy(buf, key, v5);
    return v5;
  }
  pw_prompt = EVP_get_pw_prompt();
  if (pw_prompt)
    v10 = pw_prompt;
  else
    v10 = "Enter PEM pass phrase:";
  if (EVP_read_pw_string_min(buf, 4, v5, v10, w))
  {
LABEL_14:
    ERR_put_error(9, 4095, 109, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/pem/pem_lib.c", 116);
    bzero(buf, v5);
LABEL_15:
    LODWORD(v5) = -1;
    return v5;
  }
  v11 = (FILE **)MEMORY[0x24BDAC8D8];
  while (1)
  {
    v12 = strlen(buf);
    if (v12 > 3)
      break;
    fprintf(*v11, "phrase is too short, needs to be at least %zu chars\n", 4uLL);
    if (EVP_read_pw_string_min(buf, 4, v5, v10, w))
      goto LABEL_14;
  }
  LODWORD(v5) = v12;
  return v5;
}

void PEM_proc_type(char *buf, int type)
{
  const char *v3;
  const char *v4;
  const char *v5;

  v3 = "MIC-ONLY";
  v4 = "BAD-TYPE";
  if (type == 30)
    v4 = "MIC-CLEAR";
  if (type != 20)
    v3 = v4;
  if (type == 10)
    v5 = "ENCRYPTED";
  else
    v5 = v3;
  strlcat(buf, "Proc-Type: 4,", 0x400uLL);
  strlcat(buf, v5, 0x400uLL);
  strlcat(buf, "\n", 0x400uLL);
}

void PEM_dek_info(char *buf, const char *type, int len, char *str)
{
  int v8;
  char *v9;
  uint64_t v10;
  char v11;
  uint64_t v12;

  strlcat(buf, "DEK-Info: ", 0x400uLL);
  strlcat(buf, type, 0x400uLL);
  strlcat(buf, ",", 0x400uLL);
  v8 = strlen(buf);
  if (v8 + 2 * len <= 1023)
  {
    if (len < 1)
    {
      v12 = 0;
    }
    else
    {
      v9 = &buf[v8 + 1];
      v10 = len;
      do
      {
        *(v9 - 1) = PEM_dek_info_map[(unint64_t)*str >> 4];
        v11 = *str++;
        *v9 = PEM_dek_info_map[v11 & 0xF];
        v9 += 2;
        --v10;
      }
      while (v10);
      v12 = 2 * len;
    }
    *(_WORD *)&buf[v12 + v8] = 10;
  }
}

void *__cdecl PEM_ASN1_read(d2i_of_void *d2i, const char *name, FILE *fp, void **x, pem_password_cb *cb, void *u)
{
  BIO_METHOD *v12;
  BIO *v13;
  BIO *v14;
  void *bio;

  v12 = BIO_s_file();
  v13 = BIO_new(v12);
  if (v13)
  {
    v14 = v13;
    BIO_ctrl(v13, 106, 0, fp);
    bio = PEM_ASN1_read_bio(d2i, name, v14, x, cb, u);
    BIO_free(v14);
    return bio;
  }
  else
  {
    ERR_put_error(9, 4095, 7, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/pem/pem_lib.c", 179);
    return 0;
  }
}

int PEM_bytes_read_bio(unsigned __int8 **pdata, uint64_t *plen, char **pnm, const char *name, BIO *bp, pem_password_cb *cb, void *u)
{
  char *v9;
  int v10;
  int v11;
  signed int v12;
  char *str;
  signed int v14;
  char *v15;
  uint64_t v16;
  int v17;
  char *v18;
  unsigned __int8 *v19;
  uint64_t len;
  unsigned __int8 *data;
  char *header;
  char *namea;
  ENGINE *e;
  EVP_CIPHER_INFO cipher;
  uint64_t v32;

  v32 = *MEMORY[0x24BDAC8D0];
  memset(&cipher, 0, sizeof(cipher));
  header = 0;
  namea = 0;
  len = 0;
  data = 0;
  if (PEM_read_bio(bp, &namea, &header, &data, &len))
  {
    while (1)
    {
      v9 = namea;
      if (!strcmp(namea, name))
        break;
      if (!strcmp(name, "ANY PRIVATE KEY"))
      {
        if (!strcmp(v9, "ENCRYPTED PRIVATE KEY"))
          break;
        if (!strcmp(v9, "PRIVATE KEY"))
          break;
        v12 = pem_check_suffix(v9, "PRIVATE KEY");
        if (v12 >= 1)
        {
          str = EVP_PKEY_asn1_find_str(0, v9, v12);
          if (str)
          {
            if (*((_QWORD *)str + 23))
              break;
          }
        }
      }
      else if (!strcmp(name, "PARAMETERS"))
      {
        v14 = pem_check_suffix(v9, "PARAMETERS");
        if (v14 >= 1)
        {
          e = 0;
          v15 = EVP_PKEY_asn1_find_str(&e, v9, v14);
          if (v15)
          {
            v16 = *((_QWORD *)v15 + 14);
            ENGINE_finish(e);
            if (v16)
              break;
          }
        }
      }
      else
      {
        v10 = strcmp(v9, "X509 CERTIFICATE");
        if (!v10 && !strcmp(name, "CERTIFICATE"))
          break;
        if (!strcmp(v9, "NEW CERTIFICATE REQUEST") && !strcmp(name, "CERTIFICATE REQUEST"))
          break;
        v11 = strcmp(v9, "CERTIFICATE");
        if (!v11 && !strcmp(name, "TRUSTED CERTIFICATE"))
          break;
        if (!v10 && !strcmp(name, "TRUSTED CERTIFICATE")
          || !v11 && !strcmp(name, "PKCS7")
          || !strcmp(v9, "PKCS #7 SIGNED DATA") && !strcmp(name, "PKCS7")
          || !v11 && !strcmp(name, "CMS")
          || !strcmp(v9, "PKCS7") && !strcmp(name, "CMS"))
        {
          break;
        }
      }
      free(v9);
      free(header);
      free(data);
      if (!PEM_read_bio(bp, &namea, &header, &data, &len))
        goto LABEL_32;
    }
    v18 = header;
    if (PEM_get_EVP_CIPHER_INFO(header, &cipher) && (v19 = data, PEM_do_header(&cipher, data, &len, cb, u)))
    {
      *pdata = v19;
      *plen = len;
      if (pnm)
      {
        *pnm = v9;
        free(v18);
        return 1;
      }
      v17 = 1;
    }
    else
    {
      v17 = 0;
    }
    free(v9);
    free(v18);
    if ((v17 & 1) == 0)
      free(data);
  }
  else
  {
LABEL_32:
    if ((ERR_peek_error() & 0xFFF) == 0x6C)
      ERR_asprintf_error_data("Expecting: %s", name);
    return 0;
  }
  return v17;
}

int PEM_read_bio(BIO *bp, char **name, char **header, unsigned __int8 **data, uint64_t *len)
{
  BUF_MEM *v10;
  BUF_MEM *v11;
  BUF_MEM *v12;
  BUF_MEM *v13;
  BUF_MEM *v14;
  int v15;
  BOOL v16;
  size_t v18;
  BUF_MEM *v19;
  BUF_MEM *v20;
  BUF_MEM *v21;
  size_t v23;
  int v24;
  int v25;
  size_t v26;
  uint64_t v27;
  int v29;
  int v30;
  uint64_t v31;
  int v32;
  size_t v33;
  BOOL v34;
  _BOOL4 v35;
  int v36;
  int v37;
  BOOL v38;
  size_t v39;
  int v40;
  int v41;
  uint64_t v42;
  char **v43;
  unsigned __int8 **v44;
  uint64_t *v45;
  BUF_MEM *str;
  BUF_MEM *v47;
  int outl;
  int v49;
  _BYTE buf[11];
  char v51[245];
  EVP_ENCODE_CTX ctx;
  uint64_t v53;

  v53 = *MEMORY[0x24BDAC8D0];
  outl = 0;
  v10 = BUF_MEM_new();
  v11 = BUF_MEM_new();
  v12 = BUF_MEM_new();
  v13 = v12;
  if (!v10 || !v11 || !v12)
  {
    BUF_MEM_free(v10);
    BUF_MEM_free(v11);
    BUF_MEM_free(v13);
    ERR_put_error(9, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/pem/pem_lib.c", 685);
    return 0;
  }
  v45 = len;
  str = v11;
  v43 = header;
  v44 = data;
  v14 = v10;
  v47 = v12;
  memset(&ctx, 0, sizeof(ctx));
  v49 = 0;
  v51[243] = 0;
  v15 = BIO_gets(bp, buf, 254);
  if (v15 < 1)
  {
LABEL_16:
    ERR_put_error(9, 4095, 108, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/pem/pem_lib.c", 694);
    v20 = str;
    v19 = v47;
    v21 = v10;
    goto LABEL_17;
  }
  while (1)
  {
    do
    {
      if ((char)buf[v15] > 32)
        goto LABEL_9;
      v16 = v15-- <= 0;
    }
    while (!v16);
    v15 = -1;
LABEL_9:
    *(_WORD *)&buf[v15 + 1] = 10;
    if (*(_QWORD *)buf == 0x4745422D2D2D2D2DLL && *(_QWORD *)&buf[3] == 0x204E494745422D2DLL)
    {
      v18 = strlen(v51);
      if (!strncmp(&buf[(uint64_t)((v18 << 32) + 0x500000000) >> 32], "-----\n", 6uLL))
        break;
    }
    v15 = BIO_gets(bp, buf, 254);
    if (v15 < 1)
      goto LABEL_16;
  }
  v23 = v18 << 32;
  v21 = v10;
  if (!BUF_MEM_grow(v10, ((v18 << 32) + 0x900000000) >> 32))
  {
    ERR_put_error(9, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/pem/pem_lib.c", 709);
    v20 = str;
    v19 = v47;
    goto LABEL_17;
  }
  memcpy(v10->data, v51, (uint64_t)(v23 - 0x600000000) >> 32);
  v10->data[(uint64_t)(v23 - 0x600000000) >> 32] = 0;
  v19 = v47;
  if (!BUF_MEM_grow(str, 256))
  {
    v30 = 719;
    goto LABEL_69;
  }
  *str->data = 0;
  v24 = BIO_gets(bp, buf, 254);
  if (v24 >= 1)
  {
    v25 = 0;
    while (1)
    {
      if ((char)buf[v24] > 32)
        goto LABEL_29;
      v16 = v24-- <= 0;
      if (v16)
      {
        v24 = -1;
LABEL_29:
        *(_WORD *)&buf[v24 + 1] = 10;
        if (buf[0] == 10)
          goto LABEL_40;
        v26 = v24 + 2;
        v27 = v24 + 2 + (uint64_t)v25;
        if (!BUF_MEM_grow(str, v27 + 9))
        {
          v30 = 736;
          goto LABEL_69;
        }
        if (*(_QWORD *)buf == 0x444E452D2D2D2D2DLL && buf[8] == 32)
        {
          v29 = 0;
          goto LABEL_43;
        }
        memcpy(&str->data[v25], buf, v26);
        str->data[v27] = 0;
        v24 = BIO_gets(bp, buf, 254);
        v25 = v27;
        if (v24 <= 0)
        {
          v29 = 1;
          v25 = v27;
          goto LABEL_43;
        }
      }
    }
  }
  v25 = 0;
LABEL_40:
  v29 = 1;
LABEL_43:
  outl = 0;
  if (!BUF_MEM_grow(v47, 1024))
  {
    v30 = 750;
    goto LABEL_69;
  }
  *v47->data = 0;
  if (!v29)
  {
    outl = v25;
    LODWORD(v31) = v25;
    v20 = v47;
    v19 = str;
LABEL_71:
    v38 = *(_QWORD *)buf == 0x444E452D2D2D2D2DLL && buf[8] == 32;
    if (v38
      && (v39 = strlen(v14->data), !strncmp(v21->data, &buf[9], (int)v39))
      && !strncmp(&buf[(uint64_t)((v39 << 32) + 0x900000000) >> 32], "-----\n", 6uLL))
    {
      EVP_DecodeInit(&ctx);
      if (EVP_DecodeUpdate(&ctx, (unsigned __int8 *)v19->data, &outl, (const unsigned __int8 *)v19->data, v31) < 0)
      {
        v40 = 100;
        v41 = 811;
      }
      else
      {
        if ((EVP_DecodeFinal(&ctx, (unsigned __int8 *)&v19->data[outl], &v49) & 0x80000000) == 0)
        {
          v42 = outl + (uint64_t)v49;
          outl = v42;
          if (!(_DWORD)v42)
            goto LABEL_17;
          *name = v21->data;
          *v43 = v20->data;
          *v44 = (unsigned __int8 *)v19->data;
          *v45 = v42;
          free(v21);
          free(v20);
          free(v19);
          return 1;
        }
        v40 = 100;
        v41 = 816;
      }
    }
    else
    {
      v40 = 102;
      v41 = 802;
    }
    ERR_put_error(9, 4095, v40, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/pem/pem_lib.c", v41);
    goto LABEL_17;
  }
  LODWORD(v31) = 0;
  while (1)
  {
    v32 = BIO_gets(bp, buf, 254);
    if (v32 < 1)
      goto LABEL_67;
    while ((char)buf[v32] <= 32)
    {
      v16 = v32-- <= 0;
      if (v16)
      {
        v32 = -1;
        break;
      }
    }
    buf[v32 + 1] = 10;
    v33 = (v32 + 2);
    buf[v33] = 0;
    v34 = *(_QWORD *)buf == 0x444E452D2D2D2D2DLL && buf[8] == 32;
    v35 = !v34;
    if (v32 > 63 || !v35)
      goto LABEL_67;
    if (!BUF_MEM_grow_clean(v47, v32 + v31 + 11))
      break;
    v36 = v31;
    memcpy(&v47->data[(int)v31], buf, v33);
    v31 = (int)v31 + (uint64_t)(int)v33;
    v47->data[v31] = 0;
    outl = v36 + v33;
    if ((_DWORD)v33 != 65)
    {
      buf[0] = 0;
      v37 = BIO_gets(bp, buf, 254);
      if (v37 >= 1)
      {
        while ((char)buf[v37] <= 32)
        {
          v16 = v37-- <= 0;
          if (v16)
          {
            v37 = -1;
            break;
          }
        }
        buf[v37 + 1] = 10;
        buf[v37 + 2] = 0;
      }
LABEL_67:
      v20 = str;
      goto LABEL_71;
    }
  }
  v30 = 772;
LABEL_69:
  ERR_put_error(9, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/pem/pem_lib.c", v30);
  v20 = str;
LABEL_17:
  BUF_MEM_free(v21);
  BUF_MEM_free(v20);
  BUF_MEM_free(v19);
  return 0;
}

int PEM_get_EVP_CIPHER_INFO(char *header, EVP_CIPHER_INFO *cipher)
{
  int v6;
  int v7;
  const char *i;
  const char *v9;
  int v10;
  int v11;
  const EVP_CIPHER *cipherbyname;
  const char *v14;

  cipher->cipher = 0;
  if (!header)
    return 1;
  if (!*header || *header == 10)
    return 1;
  if (!strncmp(header, "Proc-Type: ", 0xBuLL))
  {
    if (header[11] != 52 || header[12] != 44)
      return 0;
    if (!strncmp(header + 13, "ENCRYPTED", 9uLL))
    {
      for (i = header + 24; ; ++i)
      {
        if (!*(i - 11))
        {
          v6 = 112;
          v7 = 515;
          goto LABEL_10;
        }
        if (*(i - 11) == 10)
          break;
      }
      if (!strncmp(i - 10, "DEK-Info: ", 0xAuLL))
      {
        v9 = i;
        do
        {
          do
          {
            v14 = v9;
            v11 = *(unsigned __int8 *)v9++;
            v10 = v11;
          }
          while ((v11 - 48) < 0xA);
        }
        while (v10 == 45 || (v10 - 65) < 0x1A);
        *((_BYTE *)v9 - 1) = 0;
        cipherbyname = EVP_get_cipherbyname(i);
        cipher->cipher = cipherbyname;
        *((_BYTE *)v9 - 1) = v10;
        v14 = v9;
        if (cipherbyname)
          return load_iv((uint64_t *)&v14, cipher->iv, cipherbyname->iv_len);
        v6 = 114;
        v7 = 539;
      }
      else
      {
        v6 = 105;
        v7 = 520;
      }
    }
    else
    {
      v6 = 106;
      v7 = 509;
    }
  }
  else
  {
    v6 = 107;
    v7 = 498;
  }
LABEL_10:
  ERR_put_error(9, 4095, v6, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/pem/pem_lib.c", v7);
  return 0;
}

int PEM_do_header(EVP_CIPHER_INFO *cipher, unsigned __int8 *data, uint64_t *len, pem_password_cb *callback, void *u)
{
  uint64_t v8;
  int v9;
  int v10;
  const EVP_CIPHER *v11;
  const EVP_MD *v12;
  int result;
  int v14;
  int v15;
  int v16;
  int v17;
  int outl;
  char buf[1024];
  unsigned __int8 key[64];
  EVP_CIPHER_CTX a;
  uint64_t v22;

  v22 = *MEMORY[0x24BDAC8D0];
  if (!cipher->cipher)
    return 1;
  v8 = *len;
  outl = 0;
  memset(&a, 0, sizeof(a));
  if (callback)
    v9 = ((uint64_t (*)(char *, uint64_t, _QWORD, void *))callback)(buf, 1024, 0, u);
  else
    v9 = PEM_def_callback(buf, 1024, 0, u);
  v10 = v9;
  if (v9 <= 0)
  {
    v15 = 104;
    v16 = 461;
  }
  else
  {
    v11 = cipher->cipher;
    v12 = EVP_md5();
    result = EVP_BytesToKey(v11, v12, cipher->iv, (const unsigned __int8 *)buf, v10, 1, key, 0);
    if (!result)
      return result;
    v17 = v8;
    EVP_CIPHER_CTX_init(&a);
    if (EVP_DecryptInit_ex(&a, cipher->cipher, 0, key, cipher->iv) && EVP_DecryptUpdate(&a, data, &outl, data, v8))
    {
      v14 = EVP_DecryptFinal_ex(&a, &data[outl], &v17);
      EVP_CIPHER_CTX_cleanup(&a);
      explicit_bzero(buf, 0x400uLL);
      explicit_bzero(key, 0x40uLL);
      if (v14)
      {
        *len = outl + (uint64_t)v17;
        return 1;
      }
    }
    else
    {
      EVP_CIPHER_CTX_cleanup(&a);
      explicit_bzero(buf, 0x400uLL);
      explicit_bzero(key, 0x40uLL);
    }
    v15 = 101;
    v16 = 480;
  }
  ERR_put_error(9, 4095, v15, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/pem/pem_lib.c", v16);
  return 0;
}

int PEM_ASN1_write(i2d_of_void *i2d, const char *name, FILE *fp, char *x, const EVP_CIPHER *enc, unsigned __int8 *kstr, int klen, pem_password_cb *callback, void *u)
{
  BIO_METHOD *v17;
  BIO *v18;
  BIO *v19;
  int v20;

  v17 = BIO_s_file();
  v18 = BIO_new(v17);
  if (v18)
  {
    v19 = v18;
    BIO_ctrl(v18, 106, 0, fp);
    v20 = PEM_ASN1_write_bio(i2d, name, v19, x, enc, kstr, klen, callback, u);
    BIO_free(v19);
    return v20;
  }
  else
  {
    ERR_put_error(9, 4095, 7, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/pem/pem_lib.c", 335);
    return 0;
  }
}

int PEM_ASN1_write_bio(i2d_of_void *i2d, const char *name, BIO *bp, char *x, const EVP_CIPHER *enc, unsigned __int8 *kstr, int klen, pem_password_cb *cb, void *u)
{
  int v17;
  const char *v18;
  int v19;
  int v20;
  unsigned int v21;
  unsigned int v22;
  unsigned __int8 *v23;
  unsigned __int8 *v24;
  int v25;
  int v26;
  _BOOL4 v27;
  int v28;
  int v29;
  size_t iv_len;
  const EVP_MD *v31;
  BIO *bpa;
  unsigned __int8 *v34;
  int outl[2];
  char __buf[16];
  unsigned __int8 key[64];
  char hdr[1024];
  EVP_CIPHER_CTX a;
  uint64_t v40;

  v40 = *MEMORY[0x24BDAC8D0];
  memset(&a, 0, sizeof(a));
  v34 = 0;
  *(_QWORD *)outl = 0;
  if (!enc)
  {
    v18 = 0;
LABEL_5:
    v21 = ((uint64_t (*)(char *, _QWORD))i2d)(x, 0);
    if ((v21 & 0x80000000) != 0)
    {
      v19 = 13;
      v20 = 366;
      goto LABEL_12;
    }
    v22 = v21;
    bpa = bp;
    v23 = (unsigned __int8 *)malloc_type_malloc(v21 + 20, 0xEA451B8DuLL);
    v24 = v23;
    if (v23)
    {
      v34 = v23;
      v25 = ((uint64_t (*)(char *, unsigned __int8 **))i2d)(x, &v34);
      outl[1] = v25;
      if (enc)
      {
        if (!kstr)
        {
          if (cb)
            v26 = ((uint64_t (*)(char *, uint64_t, uint64_t, void *))cb)(hdr, 1024, 1, u);
          else
            v26 = PEM_def_callback(hdr, 1024, 1, u);
          klen = v26;
          if (v26 <= 0)
          {
            v28 = 111;
            v29 = 387;
            goto LABEL_27;
          }
          kstr = (unsigned __int8 *)hdr;
        }
        iv_len = enc->iv_len;
        if (iv_len >= 0x11)
        {
          v28 = 102;
          v29 = 393;
          goto LABEL_27;
        }
        arc4random_buf(__buf, iv_len);
        v31 = EVP_md5();
        if (!EVP_BytesToKey(enc, v31, (const unsigned __int8 *)__buf, kstr, klen, 1, key, 0))
        {
LABEL_28:
          v27 = 0;
          goto LABEL_29;
        }
        if (kstr == (unsigned __int8 *)hdr)
          explicit_bzero(hdr, 0x400uLL);
        if (strlen(v18) + 2 * enc->iv_len - 989 <= 0xFFFFFFFFFFFFFBFELL)
        {
          v28 = 107;
          v29 = 407;
          goto LABEL_27;
        }
        hdr[0] = 0;
        PEM_proc_type(hdr, 10);
        PEM_dek_info(hdr, v18, enc->iv_len, __buf);
        EVP_CIPHER_CTX_init(&a);
        if (!EVP_EncryptInit_ex(&a, enc, 0, key, (const unsigned __int8 *)__buf)
          || !EVP_EncryptUpdate(&a, v24, outl, v24, v25)
          || !EVP_EncryptFinal_ex(&a, &v24[outl[0]], &outl[1]))
        {
          EVP_CIPHER_CTX_cleanup(&a);
          goto LABEL_28;
        }
        EVP_CIPHER_CTX_cleanup(&a);
        v25 = outl[1] + outl[0];
        outl[1] += outl[0];
      }
      else
      {
        hdr[0] = 0;
      }
      outl[1] = PEM_write_bio(bpa, name, hdr, v24, v25);
      v27 = outl[1] > 0;
      goto LABEL_29;
    }
    v28 = 65;
    v29 = 374;
LABEL_27:
    ERR_put_error(9, 4095, v28, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/pem/pem_lib.c", v29);
    goto LABEL_28;
  }
  v17 = EVP_CIPHER_nid(enc);
  v18 = OBJ_nid2sn(v17);
  if (v18)
    goto LABEL_5;
  v19 = 113;
  v20 = 360;
LABEL_12:
  ERR_put_error(9, 4095, v19, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/pem/pem_lib.c", v20);
  v22 = 0;
  v27 = 0;
  v24 = 0;
LABEL_29:
  explicit_bzero(key, 0x40uLL);
  explicit_bzero(__buf, 0x10uLL);
  explicit_bzero(&a, 0xA8uLL);
  explicit_bzero(hdr, 0x400uLL);
  freezero(v24, v22);
  return v27;
}

int PEM_write_bio(BIO *bp, const char *name, char *hdr, unsigned __int8 *data, uint64_t len)
{
  int v10;
  int v11;
  unsigned __int8 *v12;
  int v13;
  int v14;
  uint64_t v15;
  int v16;
  int v17;
  BOOL v18;
  int v19;
  int v20;
  int outl;
  EVP_ENCODE_CTX ctx;
  uint64_t v24;

  v24 = *MEMORY[0x24BDAC8D0];
  outl = 0;
  memset(&ctx, 0, sizeof(ctx));
  EVP_EncodeInit(&ctx);
  v10 = strlen(name);
  if (BIO_write(bp, "-----BEGIN ", 11) != 11)
    goto LABEL_30;
  if (BIO_write(bp, name, v10) != v10)
    goto LABEL_30;
  if (BIO_write(bp, "-----\n", 6) != 6)
    goto LABEL_30;
  if (hdr)
  {
    v11 = strlen(hdr);
    if (v11 >= 1 && (BIO_write(bp, hdr, v11) != v11 || BIO_write(bp, "\n", 1) != 1))
      goto LABEL_30;
  }
  v12 = (unsigned __int8 *)reallocarray(0, 0x400uLL, 8uLL);
  if (v12)
  {
    if (len >= 1)
    {
      v13 = 0;
      v14 = 0;
      while (1)
      {
        v15 = len >= 5120 ? 5120 : len;
        EVP_EncodeUpdate(&ctx, v12, &outl, &data[v13], v15);
        if (!v16)
          goto LABEL_31;
        if (outl)
        {
          v17 = BIO_write(bp, v12, outl);
          if (v17 != outl)
            goto LABEL_31;
        }
        else
        {
          v17 = 0;
        }
        v14 += v17;
        v13 += v15;
        v18 = len <= v15;
        len -= v15;
        if (v18)
          goto LABEL_24;
      }
    }
    v14 = 0;
LABEL_24:
    EVP_EncodeFinal(&ctx, v12, &outl);
    if (outl >= 1)
    {
      v20 = BIO_write(bp, v12, outl);
      if (v20 != outl)
        goto LABEL_31;
    }
    freezero(v12, 0x2000uLL);
    if (BIO_write(bp, "-----END ", 9) == 9 && BIO_write(bp, name, v10) == v10 && BIO_write(bp, "-----\n", 6) == 6)
      return outl + v14;
LABEL_30:
    v12 = 0;
LABEL_31:
    v19 = 7;
    goto LABEL_32;
  }
  v19 = 65;
LABEL_32:
  freezero(v12, 0x2000uLL);
  ERR_put_error(9, 4095, v19, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/pem/pem_lib.c", 647);
  return 0;
}

uint64_t load_iv(uint64_t *a1, void *a2, int a3)
{
  uint64_t v4;
  int v7;
  uint64_t v8;
  int v9;
  int v10;
  int v11;

  v4 = *a1;
  if (a3 < 1)
  {
LABEL_12:
    *a1 = v4;
    return 1;
  }
  bzero(a2, a3);
  v7 = 0;
  v8 = 0;
  v9 = 2 * a3;
  if (2 * a3 <= 1)
    v9 = 1;
  while (1)
  {
    v10 = *(unsigned __int8 *)(v4 + v8);
    if ((v10 - 48) >= 0xA)
      break;
    v11 = -48;
LABEL_10:
    *((_BYTE *)a2 + (v8++ >> 1)) |= (v11 + v10) << (~(_BYTE)v7 & 4);
    v7 += 4;
    if (v9 == (_DWORD)v8)
    {
      v4 += v8;
      goto LABEL_12;
    }
  }
  if ((v10 - 65) < 6)
  {
    v11 = -55;
    goto LABEL_10;
  }
  if ((v10 - 97) < 6)
  {
    v11 = -87;
    goto LABEL_10;
  }
  ERR_put_error(9, 4095, 103, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/pem/pem_lib.c", 566);
  return 0;
}

int PEM_write(FILE *fp, char *name, char *hdr, unsigned __int8 *data, uint64_t len)
{
  BIO_METHOD *v10;
  BIO *v11;
  BIO *v12;
  int v13;

  v10 = BIO_s_file();
  v11 = BIO_new(v10);
  if (v11)
  {
    v12 = v11;
    BIO_ctrl(v11, 106, 0, fp);
    v13 = PEM_write_bio(v12, name, hdr, data, len);
    BIO_free(v12);
    return v13;
  }
  else
  {
    ERR_put_error(9, 4095, 7, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/pem/pem_lib.c", 585);
    return 0;
  }
}

int PEM_read(FILE *fp, char **name, char **header, unsigned __int8 **data, uint64_t *len)
{
  BIO_METHOD *v10;
  BIO *v11;
  BIO *v12;
  int bio;

  v10 = BIO_s_file();
  v11 = BIO_new(v10);
  if (v11)
  {
    v12 = v11;
    BIO_ctrl(v11, 106, 0, fp);
    bio = PEM_read_bio(v12, name, header, data, len);
    BIO_free(v12);
    return bio;
  }
  else
  {
    ERR_put_error(9, 4095, 7, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/pem/pem_lib.c", 658);
    return 0;
  }
}

uint64_t pem_check_suffix(const char *a1, const char *a2)
{
  int v4;
  int v5;
  const char *v6;
  int v7;
  int v8;

  v4 = strlen(a1);
  v5 = strlen(a2);
  if (v5 + 1 < v4
    && (v6 = &a1[v4 - v5], !strcmp(v6, a2))
    && (v8 = *((unsigned __int8 *)v6 - 1), v7 = (_DWORD)v6 - 1, v8 == 32))
  {
    return (v7 - (_DWORD)a1);
  }
  else
  {
    return 0;
  }
}

uint64_t asn1_get_identifier_cbs(_QWORD *a1, int a2, _BYTE *a3, int *a4, int *a5)
{
  uint64_t result;
  unsigned int v11;
  int v12;
  unsigned int v13;
  unsigned __int8 v17;

  v17 = 0;
  *a3 = 0;
  *a4 = 0;
  *a5 = 0;
  result = CBS_get_u8(a1, &v17);
  if ((_DWORD)result)
  {
    v11 = v17;
    v12 = v17 & 0x1F;
    if (v12 == 31)
    {
      v13 = 0;
      while (1)
      {
        result = CBS_get_u8(a1, &v17);
        if (!(_DWORD)result)
          break;
        if (v17 == 128 && v13 == 0 && a2 != 0 || v13 >> 25 != 0)
          return 0;
        v12 = v17 & 0x7F | (v13 << 7);
        v13 = v12;
        if ((v17 & 0x80) == 0)
          goto LABEL_17;
      }
    }
    else
    {
LABEL_17:
      *a3 = v11 >> 6;
      *a4 = (v11 >> 5) & 1;
      *a5 = v12;
      return 1;
    }
  }
  return result;
}

uint64_t asn1_get_length_cbs(_QWORD *a1, int a2, _DWORD *a3, unint64_t *a4)
{
  uint64_t result;
  int v9;
  unint64_t v10;
  BOOL v11;
  unsigned __int8 v14;

  v14 = 0;
  *a4 = 0;
  *a3 = 0;
  result = CBS_get_u8(a1, &v14);
  if ((_DWORD)result)
  {
    if (((char)v14 & 0x80000000) == 0)
    {
      *a4 = v14;
      return 1;
    }
    if (v14 == 128)
    {
      result = 1;
      *a3 = 1;
    }
    else
    {
      v9 = v14 & 0x7F;
      if ((v14 & 0x7F) == 0)
      {
        v10 = v14 & 0x7F;
LABEL_26:
        *a4 = v10;
        return 1;
      }
      if (v9 == 127)
      {
        return 0;
      }
      else
      {
        v10 = 0;
        while (1)
        {
          result = CBS_get_u8(a1, &v14);
          if (!(_DWORD)result)
            break;
          if (v14)
            v11 = 0;
          else
            v11 = v10 == 0;
          if (v11 && a2 != 0 || HIBYTE(v10) != 0)
            return 0;
          --v9;
          v10 = v14 | (v10 << 8);
          if (!(_BYTE)v9)
            goto LABEL_26;
        }
      }
    }
  }
  return result;
}

uint64_t asn1_get_object_cbs(_QWORD *a1, int a2, _BYTE *a3, int *a4, _DWORD *a5, _DWORD *a6, _QWORD *a7)
{
  uint64_t result;
  int v15;
  int v16;
  unint64_t v17;
  char v18;
  int v19;
  int v20;
  int v21;

  v21 = 0;
  v19 = 0;
  v18 = 0;
  *a3 = 0;
  *a4 = 0;
  *a5 = 0;
  *a6 = 0;
  *a7 = 0;
  result = asn1_get_identifier_cbs(a1, a2, &v18, &v21, &v19);
  if ((_DWORD)result)
  {
    v20 = 0;
    v17 = 0;
    result = asn1_get_length_cbs(a1, a2, &v20, &v17);
    if ((_DWORD)result)
    {
      v15 = v20;
      v16 = v21;
      if (!v20 || v21)
      {
        *a3 = v18;
        *a4 = v16;
        *a5 = v19;
        *a6 = v15;
        *a7 = v17;
        return 1;
      }
      else
      {
        return 0;
      }
    }
  }
  return result;
}

uint64_t asn1_get_primitive(uint64_t *a1, int a2, _DWORD *a3, _QWORD *a4)
{
  uint64_t result;
  unint64_t v9;
  char v10;
  int v11;
  uint64_t v12;

  HIDWORD(v12) = 0;
  v11 = 0;
  *a3 = 0;
  CBS_init(a4, 0, 0);
  result = asn1_get_identifier_cbs(a1, a2, &v10, (int *)&v12 + 1, &v11);
  if ((_DWORD)result)
  {
    LODWORD(v12) = 0;
    v9 = 0;
    result = asn1_get_length_cbs(a1, a2, &v12, &v9);
    if ((_DWORD)result)
    {
      if (v12)
      {
        return 0;
      }
      else
      {
        result = CBS_get_bytes(a1, a4, v9);
        if ((_DWORD)result)
        {
          *a3 = v11;
          return 1;
        }
      }
    }
  }
  return result;
}

int DSA_generate_key(DSA *a)
{
  int (__cdecl *comp)(const char *const *, const char *const *);
  BIGNUM *v4;
  BIGNUM *v5;
  BN_CTX *v6;
  BIGNUM *v7;
  int v8;

  comp = a->ex_data.sk[2].comp;
  if (comp)
    return ((uint64_t (*)(DSA *))comp)(a);
  v4 = BN_new();
  if (!v4)
  {
    v5 = 0;
    goto LABEL_10;
  }
  v5 = BN_new();
  if (!v5)
  {
LABEL_10:
    v6 = 0;
LABEL_11:
    v8 = 0;
    goto LABEL_12;
  }
  v6 = BN_CTX_new();
  if (!v6)
    goto LABEL_11;
  v7 = (BIGNUM *)BN_value_one();
  if (!bn_rand_interval(v4, v7, a->p)
    || !BN_mod_exp_ct(v5, a->q, v4, *(const BIGNUM **)&a->write_params, v6))
  {
    goto LABEL_11;
  }
  BN_free(a->pub_key);
  a->pub_key = v4;
  BN_free(a->g);
  v4 = 0;
  a->g = v5;
  v8 = 1;
  v5 = 0;
LABEL_12:
  BN_free(v5);
  BN_free(v4);
  BN_CTX_free(v6);
  return v8;
}

const EVP_CIPHER *EVP_des_cbc(void)
{
  return (const EVP_CIPHER *)&des_cbc;
}

const EVP_CIPHER *EVP_des_cfb64(void)
{
  return (const EVP_CIPHER *)&des_cfb64;
}

const EVP_CIPHER *EVP_des_ofb(void)
{
  return (const EVP_CIPHER *)&des_ofb;
}

const EVP_CIPHER *EVP_des_ecb(void)
{
  return (const EVP_CIPHER *)&des_ecb;
}

const EVP_CIPHER *EVP_des_cfb1(void)
{
  return (const EVP_CIPHER *)&des_cfb1;
}

const EVP_CIPHER *EVP_des_cfb8(void)
{
  return (const EVP_CIPHER *)&des_cfb8;
}

uint64_t des_init_key(uint64_t a1, const_DES_cblock *key)
{
  DES_set_key_unchecked(key, *(DES_key_schedule **)(a1 + 120));
  return 1;
}

uint64_t des_cbc_cipher(uint64_t a1, unsigned __int8 *output, unsigned __int8 *input, unint64_t length)
{
  unint64_t i;

  for (i = length; i > 0x7FFFFFFFFFFFFEFFLL; output += 0x7FFFFFFFFFFFFF00)
  {
    DES_ncbc_encrypt(input, output, 0x7FFFFFFFFFFFFF00, *(DES_key_schedule **)(a1 + 120), (DES_cblock *)(a1 + 40), *(_DWORD *)(a1 + 16));
    i -= 0x7FFFFFFFFFFFFF00;
    input += 0x7FFFFFFFFFFFFF00;
  }
  if (i)
    DES_ncbc_encrypt(input, output, i, *(DES_key_schedule **)(a1 + 120), (DES_cblock *)(a1 + 40), *(_DWORD *)(a1 + 16));
  return 1;
}

uint64_t des_ctrl(int a1, int a2, int a3, DES_cblock *ret)
{
  if (a2 == 6)
    return DES_random_key(ret) != 0;
  else
    return 0xFFFFFFFFLL;
}

uint64_t des_cfb64_cipher(uint64_t a1, unsigned __int8 *out, unsigned __int8 *in, unint64_t length)
{
  unint64_t i;

  for (i = length; i > 0x7FFFFFFFFFFFFEFFLL; out += 0x7FFFFFFFFFFFFF00)
  {
    DES_cfb64_encrypt(in, out, 0x7FFFFFFFFFFFFF00, *(DES_key_schedule **)(a1 + 120), (DES_cblock *)(a1 + 40), (int *)(a1 + 88), *(_DWORD *)(a1 + 16));
    i -= 0x7FFFFFFFFFFFFF00;
    in += 0x7FFFFFFFFFFFFF00;
  }
  if (i)
    DES_cfb64_encrypt(in, out, i, *(DES_key_schedule **)(a1 + 120), (DES_cblock *)(a1 + 40), (int *)(a1 + 88), *(_DWORD *)(a1 + 16));
  return 1;
}

uint64_t des_ofb_cipher(uint64_t a1, unsigned __int8 *out, unsigned __int8 *in, unint64_t length)
{
  unint64_t i;

  for (i = length; i > 0x7FFFFFFFFFFFFEFFLL; out += 0x7FFFFFFFFFFFFF00)
  {
    DES_ofb64_encrypt(in, out, 0x7FFFFFFFFFFFFF00, *(DES_key_schedule **)(a1 + 120), (DES_cblock *)(a1 + 40), (int *)(a1 + 88));
    i -= 0x7FFFFFFFFFFFFF00;
    in += 0x7FFFFFFFFFFFFF00;
  }
  if (i)
    DES_ofb64_encrypt(in, out, i, *(DES_key_schedule **)(a1 + 120), (DES_cblock *)(a1 + 40), (int *)(a1 + 88));
  return 1;
}

uint64_t des_ecb_cipher(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  unint64_t v4;
  unint64_t v5;
  unint64_t v9;

  v4 = *(int *)(*(_QWORD *)a1 + 4);
  v5 = a4 - v4;
  if (a4 >= v4)
  {
    v9 = 0;
    do
    {
      DES_ecb_encrypt((const_DES_cblock *)(a3 + v9), (DES_cblock *)(a2 + v9), *(DES_key_schedule **)(a1 + 120), *(_DWORD *)(a1 + 16));
      v9 += v4;
    }
    while (v9 <= v5);
  }
  return 1;
}

uint64_t des_cfb1_cipher(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  unint64_t v7;
  DES_cblock *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v12;
  unsigned __int8 out;
  unsigned __int8 in;

  if (a4)
  {
    if (a4 >= 0xFFFFFFFFFFFFFFFLL)
      v7 = 0xFFFFFFFFFFFFFFFLL;
    else
      v7 = a4;
    v8 = (DES_cblock *)(a1 + 40);
    do
    {
      v12 = a4;
      if (v7)
      {
        v9 = 0;
        if (8 * v7 <= 1)
          v10 = 1;
        else
          v10 = 8 * v7;
        do
        {
          in = *(unsigned __int8 *)(a3 + (v9 >> 3)) >> (v9 & 7 ^ 7) << 7;
          DES_cfb_encrypt(&in, &out, 1, 1, *(DES_key_schedule **)(a1 + 120), v8, *(_DWORD *)(a1 + 16));
          *(_BYTE *)(a2 + (v9 >> 3)) = ((out & 0x80) >> (v9 & 7)) | (-129 >> (v9 & 7)) & *(_BYTE *)(a2 + (v9 >> 3));
          ++v9;
        }
        while (v10 != v9);
      }
      a3 += v7;
      a2 += v7;
      a4 = v12 - v7;
      if (v12 - v7 < v7)
        v7 = v12 - v7;
    }
    while (a4);
  }
  return 1;
}

uint64_t des_cfb8_cipher(uint64_t a1, unsigned __int8 *out, unsigned __int8 *in, unint64_t length)
{
  unint64_t i;

  for (i = length; i > 0x7FFFFFFFFFFFFEFFLL; out += 0x7FFFFFFFFFFFFF00)
  {
    DES_cfb_encrypt(in, out, 8, 0x7FFFFFFFFFFFFF00, *(DES_key_schedule **)(a1 + 120), (DES_cblock *)(a1 + 40), *(_DWORD *)(a1 + 16));
    i -= 0x7FFFFFFFFFFFFF00;
    in += 0x7FFFFFFFFFFFFF00;
  }
  if (i)
    DES_cfb_encrypt(in, out, 8, i, *(DES_key_schedule **)(a1 + 120), (DES_cblock *)(a1 + 40), *(_DWORD *)(a1 + 16));
  return 1;
}

uint64_t PKCS5_PBKDF2_HMAC(const char *a1, int a2, const unsigned __int8 *a3, int a4, int a5, EVP_MD *md, int a7, char *a8)
{
  int v16;
  int v17;
  uint64_t v18;
  HMAC_CTX *p_ctx;
  int v20;
  unsigned int v21;
  uint64_t v22;
  const unsigned __int8 *v23;
  int v24;
  int v25;
  int v26;
  int v27;
  int v28;
  int v29;
  unsigned __int8 *v30;
  uint64_t v31;
  _BYTE *v32;
  char v33;
  size_t len;
  unsigned __int8 data[4];
  HMAC_CTX v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  HMAC_CTX ctx;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  unsigned __int8 mda[64];
  uint64_t v48;

  v48 = *MEMORY[0x24BDAC8D0];
  v16 = EVP_MD_size(md);
  if ((v16 & 0x80000000) == 0)
  {
    v17 = v16;
    v45 = 0u;
    v46 = 0u;
    v43 = 0u;
    v44 = 0u;
    v41 = 0u;
    memset(&ctx, 0, sizeof(ctx));
    v39 = 0u;
    v40 = 0u;
    v38 = 0u;
    memset(&v37, 0, sizeof(v37));
    HMAC_CTX_init(&ctx);
    if (a1)
    {
      if (a2 == -1)
        a2 = strlen(a1);
    }
    else
    {
      a2 = 0;
    }
    p_ctx = &ctx;
    HMAC_Init_ex(&ctx, a1, a2, md, 0);
    if (v20)
    {
      if (!a7)
      {
        v18 = 1;
        p_ctx = &ctx;
        goto LABEL_31;
      }
      v21 = 1;
      len = a4;
      while (1)
      {
        v22 = a7 >= v17 ? v17 : a7;
        *(_DWORD *)data = bswap32(v21);
        p_ctx = &ctx;
        if (!HMAC_CTX_copy((uint64_t)&v37, (uint64_t)&ctx))
          break;
        v23 = a3;
        HMAC_Update(&v37, a3, len);
        if (!v24 || (HMAC_Update(&v37, data, 4uLL), !v25) || (HMAC_Final(&v37, mda, 0), !v26))
        {
LABEL_29:
          HMAC_CTX_cleanup(&ctx);
          v18 = 0;
          p_ctx = &v37;
          goto LABEL_31;
        }
        HMAC_CTX_cleanup(&v37);
        memcpy(a8, mda, (int)v22);
        if (a5 >= 2)
        {
          v27 = 1;
          do
          {
            p_ctx = &ctx;
            if (!HMAC_CTX_copy((uint64_t)&v37, (uint64_t)&ctx))
              goto LABEL_28;
            HMAC_Update(&v37, mda, v17);
            if (!v28)
              goto LABEL_29;
            HMAC_Final(&v37, mda, 0);
            if (!v29)
              goto LABEL_29;
            HMAC_CTX_cleanup(&v37);
            if ((int)v22 >= 1)
            {
              v30 = mda;
              v31 = v22;
              v32 = a8;
              do
              {
                v33 = *v30++;
                *v32++ ^= v33;
                --v31;
              }
              while (v31);
            }
          }
          while (++v27 != a5);
        }
        ++v21;
        a8 += (int)v22;
        v18 = 1;
        p_ctx = &ctx;
        a7 -= v22;
        a3 = v23;
        if (!a7)
          goto LABEL_31;
      }
    }
LABEL_28:
    v18 = 0;
LABEL_31:
    HMAC_CTX_cleanup(p_ctx);
    return v18;
  }
  return 0;
}

int PKCS5_PBKDF2_HMAC_SHA1(const char *pass, int passlen, const unsigned __int8 *salt, int saltlen, int iter, int keylen, unsigned __int8 *out)
{
  EVP_MD *v14;

  v14 = (EVP_MD *)EVP_sha1();
  return PKCS5_PBKDF2_HMAC(pass, passlen, salt, saltlen, iter, v14, keylen, (char *)out);
}

int PKCS5_v2_PBE_keyivgen(EVP_CIPHER_CTX *ctx, const char *pass, int passlen, ASN1_TYPE *param, const EVP_CIPHER *cipher, const EVP_MD *md, int en_de)
{
  char *ptr;
  PBE2PARAM *v12;
  PBE2PARAM *v13;
  int v14;
  const char *v15;
  const EVP_CIPHER *cipherbyname;
  uint64_t v17;
  uint64_t v18;
  int v19;
  int v21;
  int v22;
  unsigned __int8 *in;

  in = 0;
  if (!param || param->type != 16 || (ptr = param->value.ptr) == 0)
  {
    ERR_put_error(6, 4095, 114, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/p5_crpt2.c", 179);
    v13 = 0;
    goto LABEL_11;
  }
  in = (unsigned __int8 *)*((_QWORD *)ptr + 1);
  v12 = d2i_PBE2PARAM(0, (const unsigned __int8 **)&in, *(int *)ptr);
  v13 = v12;
  if (!v12)
  {
    v21 = 114;
    v22 = 186;
LABEL_17:
    ERR_put_error(6, 4095, v21, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/p5_crpt2.c", v22);
    goto LABEL_11;
  }
  if (OBJ_obj2nid(v12->keyfunc->algorithm) != 69)
  {
    v21 = 124;
    v22 = 193;
    goto LABEL_17;
  }
  v14 = OBJ_obj2nid(v13->encryption->algorithm);
  v15 = OBJ_nid2sn(v14);
  cipherbyname = EVP_get_cipherbyname(v15);
  if (!cipherbyname)
  {
    v21 = 107;
    v22 = 203;
    goto LABEL_17;
  }
  if (!EVP_CipherInit_ex(ctx, cipherbyname, 0, 0, 0, en_de))
  {
LABEL_11:
    v19 = 0;
    goto LABEL_12;
  }
  if (EVP_CIPHER_asn1_to_param(ctx, v13->encryption->parameter) < 0)
  {
    v21 = 122;
    v22 = 211;
    goto LABEL_17;
  }
  v19 = PKCS5_v2_PBKDF2_keyivgen(ctx, pass, passlen, (uint64_t)v13->keyfunc->parameter, v17, v18, en_de);
LABEL_12:
  PBE2PARAM_free(v13);
  return v19;
}

uint64_t PKCS5_v2_PBKDF2_keyivgen(EVP_CIPHER_CTX *a1, const char *a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7)
{
  unsigned int v12;
  int v13;
  int v14;
  unsigned int v15;
  int *v16;
  PBKDF2PARAM *v17;
  PBKDF2PARAM *v18;
  ASN1_INTEGER *keylength;
  const ASN1_OBJECT **p_algorithm;
  int v21;
  uint64_t v22;
  int v24;
  int v25;
  const char *v26;
  const EVP_MD *digestbyname;
  EVP_MD *v28;
  char *ptr;
  const unsigned __int8 *v30;
  int v31;
  int v32;
  int n;
  unsigned __int8 *in;
  unsigned __int8 key[64];
  uint64_t v36;

  v36 = *MEMORY[0x24BDAC8D0];
  if (!EVP_CIPHER_CTX_cipher(a1))
  {
    v13 = 131;
    v14 = 236;
    goto LABEL_13;
  }
  v12 = EVP_CIPHER_CTX_key_length(a1);
  if (v12 < 0x41)
  {
    if (!a4 || *(_DWORD *)a4 != 16)
    {
      v13 = 114;
      v14 = 248;
      goto LABEL_13;
    }
    v15 = v12;
    n = 0;
    v16 = *(int **)(a4 + 8);
    in = (unsigned __int8 *)*((_QWORD *)v16 + 1);
    v17 = d2i_PBKDF2PARAM(0, (const unsigned __int8 **)&in, *v16);
    if (!v17)
    {
      v13 = 114;
      v14 = 256;
      goto LABEL_13;
    }
    v18 = v17;
    keylength = v17->keylength;
    if (keylength && ASN1_INTEGER_get(keylength) != v15)
    {
      v24 = 123;
      v25 = 264;
    }
    else
    {
      p_algorithm = (const ASN1_OBJECT **)&v18->prf->algorithm;
      if (p_algorithm)
        v21 = OBJ_obj2nid(*p_algorithm);
      else
        v21 = 163;
      if (EVP_PBE_find(1, v21, 0, &n, 0))
      {
        v26 = OBJ_nid2sn(n);
        digestbyname = EVP_get_digestbyname(v26);
        if (digestbyname)
        {
          if (v18->salt->type == 4)
          {
            v28 = (EVP_MD *)digestbyname;
            ptr = v18->salt->value.ptr;
            v30 = (const unsigned __int8 *)*((_QWORD *)ptr + 1);
            v31 = *(_DWORD *)ptr;
            v32 = ASN1_INTEGER_get(v18->iter);
            if (v32 > 0)
            {
              if (PKCS5_PBKDF2_HMAC(a2, a3, v30, v31, v32, v28, v15, (char *)key))
              {
                v22 = EVP_CipherInit_ex(a1, 0, 0, key, 0, a7);
LABEL_30:
                explicit_bzero(key, v15);
                PBKDF2PARAM_free(v18);
                return v22;
              }
LABEL_29:
              v22 = 0;
              goto LABEL_30;
            }
            v24 = 135;
            v25 = 293;
          }
          else
          {
            v24 = 126;
            v25 = 285;
          }
        }
        else
        {
          v24 = 125;
          v25 = 280;
        }
      }
      else
      {
        v24 = 125;
        v25 = 274;
      }
    }
    ERR_put_error(6, 4095, v24, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/p5_crpt2.c", v25);
    goto LABEL_29;
  }
  v13 = 137;
  v14 = 241;
LABEL_13:
  ERR_put_error(6, 4095, v13, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/p5_crpt2.c", v14);
  return 0;
}

STACK *i2v_POLICY_MAPPINGS(int a1, STACK *a2, STACK *a3)
{
  STACK *v4;
  STACK *v5;
  int v6;
  char *v7;
  char *v8;
  STACK *v10;
  char value[80];
  char buf[80];
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  v10 = a3;
  if (a3)
  {
    v4 = a3;
    v5 = 0;
  }
  else
  {
    v4 = sk_new_null();
    v10 = v4;
    v5 = v4;
    if (!v4)
      return v4;
  }
  if (sk_num(a2) >= 1)
  {
    v6 = 0;
    while (1)
    {
      v7 = sk_value(a2, v6);
      if (!v7)
        break;
      v8 = v7;
      if (!i2t_ASN1_OBJECT(buf, 80, *(ASN1_OBJECT **)v7)
        || !i2t_ASN1_OBJECT(value, 80, *((ASN1_OBJECT **)v8 + 1))
        || !X509V3_add_value(buf, value, &v10))
      {
        break;
      }
      if (++v6 >= sk_num(a2))
        return v10;
    }
    sk_pop_free(v5, (void (__cdecl *)(void *))X509V3_conf_free);
    return 0;
  }
  return v4;
}

STACK *v2i_POLICY_MAPPINGS(uint64_t a1, uint64_t a2, const STACK *a3)
{
  STACK *v4;
  int v5;
  char *v6;
  const char **v7;
  const char *v8;
  ASN1_OBJECT *v9;
  ASN1_OBJECT *v10;
  ASN1_OBJECT *v11;
  BOOL v12;
  ASN1_VALUE *v13;
  ASN1_VALUE *v14;
  int v15;
  int v16;

  v4 = sk_new_null();
  if (!v4)
  {
    ERR_put_error(34, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_pmaps.c", 196);
    return v4;
  }
  if (sk_num(a3) >= 1)
  {
    v5 = 0;
    while (1)
    {
      v6 = sk_value(a3, v5);
      v7 = (const char **)v6;
      if (!*((_QWORD *)v6 + 2))
        break;
      v8 = (const char *)*((_QWORD *)v6 + 1);
      if (!v8)
        break;
      v9 = OBJ_txt2obj(v8, 0);
      v10 = OBJ_txt2obj(v7[2], 0);
      v11 = v10;
      if (v9)
        v12 = v10 == 0;
      else
        v12 = 1;
      if (v12)
      {
        v14 = 0;
        goto LABEL_17;
      }
      v13 = ASN1_item_new(&POLICY_MAPPING_it);
      v14 = v13;
      if (!v13)
        goto LABEL_19;
      *(_QWORD *)v13 = v9;
      *((_QWORD *)v13 + 1) = v11;
      if (!sk_push(v4, (char *)v13))
      {
        v9 = 0;
        v11 = 0;
LABEL_19:
        v16 = 0;
        v15 = 65;
LABEL_20:
        sk_pop_free(v4, (void (__cdecl *)(void *))POLICY_MAPPING_free);
        ERR_put_error(34, 4095, v15, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_pmaps.c", 230);
        if (v16)
          ERR_asprintf_error_data("section:%s,name:%s,value:%s", *v7, v7[1], v7[2]);
        ASN1_OBJECT_free(v9);
        ASN1_OBJECT_free(v11);
        ASN1_item_free(v14, &POLICY_MAPPING_it);
        return 0;
      }
      if (++v5 >= sk_num(a3))
        return v4;
    }
    v14 = 0;
    v9 = 0;
    v11 = 0;
LABEL_17:
    v15 = 110;
    v16 = 1;
    goto LABEL_20;
  }
  return v4;
}

POLICY_MAPPING *POLICY_MAPPING_new(void)
{
  return (POLICY_MAPPING *)ASN1_item_new(&POLICY_MAPPING_it);
}

void POLICY_MAPPING_free(POLICY_MAPPING *a)
{
  ASN1_item_free((ASN1_VALUE *)a, &POLICY_MAPPING_it);
}

int SHA384_Init(SHA512_CTX *c)
{
  *(_QWORD *)&c->num = 0;
  *(_OWORD *)&c->u.p[96] = 0u;
  *(_OWORD *)&c->u.p[112] = 0u;
  *(_OWORD *)&c->u.p[64] = 0u;
  *(_OWORD *)&c->u.p[80] = 0u;
  *(_OWORD *)&c->u.p[32] = 0u;
  *(_OWORD *)&c->u.p[48] = 0u;
  *(_OWORD *)c->u.d = 0u;
  *(_OWORD *)&c->u.p[16] = 0u;
  *(_OWORD *)c->h = xmmword_22D69FA80;
  *(_OWORD *)&c->h[2] = xmmword_22D69FA90;
  *(_OWORD *)&c->h[4] = xmmword_22D69FAA0;
  *(_OWORD *)&c->h[6] = xmmword_22D69FAB0;
  *(_OWORD *)&c->Nl = 0u;
  c->md_len = 48;
  return 1;
}

int SHA384_Update(SHA512_CTX *c, const void *data, size_t len)
{
  SHA512_Update(c, data, len);
  return 1;
}

int SHA512_Update(SHA512_CTX *c, const void *data, size_t len)
{
  size_t v3;
  unint64_t *v4;
  SHA512state_st::$61765161EF95A25BF6D9F15268D2C4E6 *p_u;
  uint64_t num;
  uint64_t v8;
  char *v9;
  size_t v10;
  char *v11;

  if (len)
  {
    v3 = len;
    v4 = (unint64_t *)data;
    p_u = &c->u;
    *(_OWORD *)&c->Nl += __PAIR128__(len >> 61, 8 * len);
    num = c->num;
    if ((_DWORD)num)
    {
      v8 = 128 - num;
      v9 = (char *)p_u + num;
      v10 = len - (128 - num);
      if (len < 128 - num)
      {
        memcpy(v9, data, len);
        LODWORD(v3) = c->num + v3;
LABEL_10:
        c->num = v3;
        return 1;
      }
      memcpy(v9, data, 128 - num);
      c->num = 0;
      v4 = (unint64_t *)((char *)v4 + v8);
      sha512_block_data_order((unint64_t)c, p_u->d, 1);
      v3 = v10;
    }
    if (v3 >= 0x80)
    {
      sha512_block_data_order((unint64_t)c, v4, v3 >> 7);
      v11 = (char *)v4 + v3;
      v3 &= 0x7Fu;
      v4 = (unint64_t *)&v11[-v3];
    }
    if (v3)
    {
      memcpy(p_u, v4, v3);
      goto LABEL_10;
    }
  }
  return 1;
}

int SHA512_Final(unsigned __int8 *md, SHA512_CTX *c)
{
  SHA512state_st::$61765161EF95A25BF6D9F15268D2C4E6 *p_u;
  uint64_t num;
  uint64_t v6;
  int8x16_t v7;
  int result;
  unint64_t v9;
  uint64_t i;
  uint64_t j;
  uint64_t k;
  uint64_t m;

  p_u = &c->u;
  num = c->num;
  c->u.p[num] = 0x80;
  v6 = num + 1;
  if (num >= 0x70)
  {
    bzero((char *)p_u + v6, 127 - num);
    sha512_block_data_order((unint64_t)c, p_u->d, 1);
    v6 = 0;
  }
  bzero((char *)p_u + v6, 112 - v6);
  v7 = vrev64q_s8(*(int8x16_t *)&c->Nl);
  *(int8x16_t *)&c->u.p[112] = vextq_s8(v7, v7, 8uLL);
  sha512_block_data_order((unint64_t)c, p_u->d, 1);
  result = 0;
  if (md)
  {
    HIDWORD(v9) = c->md_len;
    LODWORD(v9) = HIDWORD(v9) - 28;
    switch((v9 >> 2))
    {
      case 0u:
        for (i = 0; i != 3; ++i)
          *(_QWORD *)&md[i * 8] = bswap64(c->h[i]);
        *((_DWORD *)md + 6) = bswap32(HIDWORD(c->h[3]));
        goto LABEL_16;
      case 1u:
        for (j = 0; j != 4; ++j)
          *(_QWORD *)&md[j * 8] = bswap64(c->h[j]);
        goto LABEL_16;
      case 5u:
        for (k = 0; k != 6; ++k)
          *(_QWORD *)&md[k * 8] = bswap64(c->h[k]);
        goto LABEL_16;
      case 9u:
        for (m = 0; m != 8; ++m)
          *(_QWORD *)&md[m * 8] = bswap64(c->h[m]);
LABEL_16:
        result = 1;
        break;
      default:
        return result;
    }
  }
  return result;
}

unsigned __int8 *__cdecl SHA384(const unsigned __int8 *d, size_t n, unsigned __int8 *md)
{
  unsigned __int8 *v3;
  SHA512_CTX v5;

  memset(&v5.u.p[64], 0, 72);
  if (md)
    v3 = md;
  else
    v3 = (unsigned __int8 *)&SHA384_m;
  *(_OWORD *)v5.h = xmmword_22D69FA80;
  *(_OWORD *)&v5.h[2] = xmmword_22D69FA90;
  *(_OWORD *)&v5.h[4] = xmmword_22D69FAA0;
  *(_OWORD *)&v5.h[6] = xmmword_22D69FAB0;
  memset(&v5.Nl, 0, 80);
  v5.md_len = 48;
  SHA512_Update(&v5, d, n);
  SHA512_Final(v3, &v5);
  explicit_bzero(&v5, 0xD8uLL);
  return v3;
}

int SHA512_Init(SHA512_CTX *c)
{
  *(_QWORD *)&c->num = 0;
  *(_OWORD *)&c->u.p[96] = 0u;
  *(_OWORD *)&c->u.p[112] = 0u;
  *(_OWORD *)&c->u.p[64] = 0u;
  *(_OWORD *)&c->u.p[80] = 0u;
  *(_OWORD *)&c->u.p[32] = 0u;
  *(_OWORD *)&c->u.p[48] = 0u;
  *(_OWORD *)c->u.d = 0u;
  *(_OWORD *)&c->u.p[16] = 0u;
  *(_OWORD *)c->h = xmmword_22D69FAC0;
  *(_OWORD *)&c->h[2] = xmmword_22D69FAD0;
  *(_OWORD *)&c->h[4] = xmmword_22D69FAE0;
  *(_OWORD *)&c->h[6] = xmmword_22D69FAF0;
  *(_OWORD *)&c->Nl = 0u;
  c->md_len = 64;
  return 1;
}

void SHA512_Transform(SHA512_CTX *c, const unsigned __int8 *data)
{
  sha512_block_data_order((unint64_t)c, (unint64_t *)data, 1);
}

unint64_t sha512_block_data_order(unint64_t result, unint64_t *a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  unint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  unint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  unint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  unint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  unint64_t v62;
  uint64_t v63;
  uint64_t v64;
  unint64_t v65;
  uint64_t v66;
  unint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t *v70;
  unint64_t v71;
  unint64_t v72;
  unint64_t v73;
  unint64_t v74;
  unint64_t v75;
  unint64_t v76;
  unint64_t v77;
  unint64_t v78;
  unint64_t v79;
  unint64_t v80;
  char *v81;
  char *v82;
  char *v83;
  unint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  unint64_t v88;
  unint64_t v89;
  unint64_t v90;
  unint64_t v91;
  unint64_t v92;
  unint64_t v93;
  unint64_t v94;
  char *v95;
  unint64_t v96;
  unint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  unint64_t v101;
  uint64_t v102;
  unint64_t v103;
  uint64_t v104;
  unint64_t v105;
  uint64_t v106;
  unint64_t v107;
  uint64_t v108;
  unint64_t v109;
  uint64_t v110;
  unint64_t v111;
  uint64_t v112;
  unint64_t v113;
  unint64_t v114;
  unint64_t v115;
  unint64_t v116;
  unint64_t v117;
  unint64_t v118;
  unint64_t v119;
  unint64_t v120;
  uint64_t v121;
  unint64_t v122;
  _QWORD *v123;
  uint64_t v124;
  uint64_t v125;
  unint64_t v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  unint64_t v133;
  unint64_t v134;
  unint64_t v135;
  unint64_t v136;
  unint64_t v137;
  unint64_t v138;
  unint64_t v139;
  unint64_t v140;

  v123 = (_QWORD *)result;
  if (a3)
  {
    v4 = *(_QWORD *)result;
    v3 = *(_QWORD *)(result + 8);
    v6 = *(_QWORD *)(result + 16);
    v5 = *(_QWORD *)(result + 24);
    v8 = *(_QWORD *)(result + 32);
    v7 = *(_QWORD *)(result + 40);
    v10 = *(_QWORD *)(result + 48);
    v9 = *(_QWORD *)(result + 56);
    do
    {
      v132 = a3;
      v138 = 0;
      v139 = bswap64(*a2);
      v124 = v9;
      v11 = (v7 & v8)
          + v9
          + (v10 & ~v8)
          + v139
          + (__ROR8__(v8, 14) ^ __ROR8__(v8, 18) ^ __ROR8__(v8, 41))
          + 0x428A2F98D728AE22;
      v128 = v5;
      v12 = v11 + v5;
      v13 = ((v6 ^ v3) & v4 ^ v6 & v3) + (__ROR8__(v4, 28) ^ __ROR8__(v4, 34) ^ __ROR8__(v4, 39)) + v11;
      v14 = bswap64(a2[1]);
      v125 = v10;
      v15 = v10
          + (v7 & ~v12)
          + (v12 & v8)
          + v14
          + 0x7137449123EF65CDLL
          + (__ROR8__(v12, 14) ^ __ROR8__(v12, 18) ^ __ROR8__(v12, 41));
      v129 = v6;
      v16 = v15 + v6;
      v17 = (__ROR8__(v13, 28) ^ __ROR8__(v13, 34) ^ __ROR8__(v13, 39)) + (v13 & (v3 ^ v4) ^ v3 & v4) + v15;
      v18 = bswap64(a2[2]);
      v126 = v7;
      v19 = v7
          + (v8 & ~v16)
          + (v16 & v12)
          + v18
          - 0x4A3F043013B2C4D1
          + (__ROR8__(v15 + v6, 14) ^ __ROR8__(v15 + v6, 18) ^ __ROR8__(v16, 41));
      v130 = v3;
      v20 = v19 + v3;
      v21 = (__ROR8__(v17, 28) ^ __ROR8__(v17, 34) ^ __ROR8__(v17, 39)) + (v17 & (v13 ^ v4) ^ v13 & v4) + v19;
      v22 = bswap64(a2[3]);
      v127 = v8;
      v23 = v8
          + (v12 & ~v20)
          + (v20 & v16)
          + v22
          - 0x164A245A7E762444
          + (__ROR8__(v20, 14) ^ __ROR8__(v20, 18) ^ __ROR8__(v20, 41));
      v131 = v4;
      v24 = v23 + v4;
      v25 = (__ROR8__(v21, 28) ^ __ROR8__(v21, 34) ^ __ROR8__(v21, 39)) + (v21 & (v17 ^ v13) ^ v17 & v13) + v23;
      v26 = bswap64(a2[4]);
      v27 = v12
          + (v16 & ~v24)
          + (v24 & v20)
          + v26
          + 0x3956C25BF348B538
          + (__ROR8__(v24, 14) ^ __ROR8__(v24, 18) ^ __ROR8__(v24, 41));
      v28 = v27 + v13;
      v29 = (__ROR8__(v25, 28) ^ __ROR8__(v25, 34) ^ __ROR8__(v25, 39)) + (v25 & (v21 ^ v17) ^ v21 & v17) + v27;
      v30 = bswap64(a2[5]);
      v31 = v16
          + (v20 & ~v28)
          + (v28 & v24)
          + v30
          + 0x59F111F1B605D019
          + (__ROR8__(v28, 14) ^ __ROR8__(v28, 18) ^ __ROR8__(v28, 41));
      v32 = v31 + v17;
      v33 = (__ROR8__(v29, 28) ^ __ROR8__(v29, 34) ^ __ROR8__(v29, 39)) + (v29 & (v25 ^ v21) ^ v25 & v21) + v31;
      v34 = bswap64(a2[6]);
      v35 = v20
          + (v24 & ~v32)
          + (v32 & v28)
          + v34
          - 0x6DC07D5B50E6B065
          + (__ROR8__(v32, 14) ^ __ROR8__(v32, 18) ^ __ROR8__(v32, 41));
      v36 = v35 + v21;
      v37 = (__ROR8__(v33, 28) ^ __ROR8__(v33, 34) ^ __ROR8__(v33, 39)) + (v33 & (v29 ^ v25) ^ v29 & v25) + v35;
      v137 = bswap64(a2[7]);
      v38 = v24
          + (v28 & ~v36)
          + (v36 & v32)
          + v137
          - 0x54E3A12A25927EE8
          + (__ROR8__(v36, 14) ^ __ROR8__(v36, 18) ^ __ROR8__(v36, 41));
      v39 = v38 + v25;
      v40 = (__ROR8__(v37, 28) ^ __ROR8__(v37, 34) ^ __ROR8__(v37, 39)) + (v37 & (v33 ^ v29) ^ v33 & v29) + v38;
      v136 = bswap64(a2[8]);
      v41 = v28
          + (v32 & ~v39)
          + (v39 & v36)
          + v136
          - 0x27F855675CFCFDBELL
          + (__ROR8__(v39, 14) ^ __ROR8__(v39, 18) ^ __ROR8__(v39, 41));
      v42 = v41 + v29;
      v43 = (__ROR8__(v40, 28) ^ __ROR8__(v40, 34) ^ __ROR8__(v40, 39)) + (v40 & (v37 ^ v33) ^ v37 & v33) + v41;
      v135 = bswap64(a2[9]);
      v44 = v32
          + (v36 & ~v42)
          + (v42 & v39)
          + v135
          + 0x12835B0145706FBELL
          + (__ROR8__(v42, 14) ^ __ROR8__(v42, 18) ^ __ROR8__(v42, 41));
      v45 = v44 + v33;
      v46 = (__ROR8__(v43, 28) ^ __ROR8__(v43, 34) ^ __ROR8__(v43, 39)) + (v43 & (v40 ^ v37) ^ v40 & v37) + v44;
      v134 = bswap64(a2[10]);
      v47 = v36
          + (v39 & ~v45)
          + (v45 & v42)
          + v134
          + 0x243185BE4EE4B28CLL
          + (__ROR8__(v45, 14) ^ __ROR8__(v45, 18) ^ __ROR8__(v45, 41));
      v48 = v47 + v37;
      v49 = (__ROR8__(v46, 28) ^ __ROR8__(v46, 34) ^ __ROR8__(v46, 39)) + (v46 & (v43 ^ v40) ^ v43 & v40) + v47;
      v50 = bswap64(a2[11]);
      v51 = v39
          + (v42 & ~v48)
          + (v48 & v45)
          + v50
          + 0x550C7DC3D5FFB4E2
          + (__ROR8__(v48, 14) ^ __ROR8__(v48, 18) ^ __ROR8__(v48, 41));
      v52 = v51 + v40;
      v53 = (__ROR8__(v49, 28) ^ __ROR8__(v49, 34) ^ __ROR8__(v49, 39)) + (v49 & (v46 ^ v43) ^ v46 & v43) + v51;
      v54 = bswap64(a2[12]);
      v55 = v42
          + (v45 & ~v52)
          + (v52 & v48)
          + v54
          + 0x72BE5D74F27B896FLL
          + (__ROR8__(v52, 14) ^ __ROR8__(v52, 18) ^ __ROR8__(v52, 41));
      v56 = v55 + v43;
      v57 = (__ROR8__(v53, 28) ^ __ROR8__(v53, 34) ^ __ROR8__(v53, 39)) + (v53 & (v49 ^ v46) ^ v49 & v46) + v55;
      v58 = bswap64(a2[13]);
      v59 = v45
          + (v48 & ~v56)
          + (v56 & v52)
          + v58
          - 0x7F214E01C4E9694FLL
          + (__ROR8__(v55 + v43, 14) ^ __ROR8__(v55 + v43, 18) ^ __ROR8__(v56, 41));
      v60 = v59 + v46;
      v61 = (__ROR8__(v57, 28) ^ __ROR8__(v57, 34) ^ __ROR8__(v57, 39)) + (v57 & (v53 ^ v49) ^ v53 & v49) + v59;
      v62 = bswap64(a2[14]);
      v63 = v48
          + (v52 & ~v60)
          + (v60 & v56)
          + v62
          - 0x6423F958DA38EDCBLL
          + (__ROR8__(v59 + v46, 14) ^ __ROR8__(v59 + v46, 18) ^ __ROR8__(v60, 41));
      result = v63 + v49;
      v64 = (__ROR8__(v61, 28) ^ __ROR8__(v61, 34) ^ __ROR8__(v61, 39)) + (v61 & (v57 ^ v53) ^ v57 & v53) + v63;
      v65 = bswap64(a2[15]);
      v66 = v52
          + (v56 & ~result)
          + (result & v60)
          + v65
          - 0x3E640E8B3096D96CLL
          + (__ROR8__(result, 14) ^ __ROR8__(result, 18) ^ __ROR8__(result, 41));
      v67 = v139;
      v68 = v66 + v53;
      v69 = (__ROR8__(v64, 28) ^ __ROR8__(v64, 34) ^ __ROR8__(v64, 39)) + (v64 & (v61 ^ v57) ^ v61 & v57) + v66;
      v70 = &qword_22D69FC88;
      do
      {
        v133 = v50;
        v71 = v135
            + v67
            + (__ROR8__(v62, 19) ^ __ROR8__(v62, 61) ^ (v62 >> 6))
            + (__ROR8__(v14, 1) ^ __ROR8__(v14, 8) ^ (v14 >> 7));
        v72 = (__ROR8__(v68, 14) ^ __ROR8__(v68, 18) ^ __ROR8__(v68, 41))
            + (result & v68)
            + v56
            + (v60 & ~v68)
            + *(v70 - 15)
            + v71;
        v73 = v72 + v57;
        v74 = ((v61 ^ v64) & v69 ^ v61 & v64) + (__ROR8__(v69, 28) ^ __ROR8__(v69, 34) ^ __ROR8__(v69, 39)) + v72;
        v75 = v54;
        v76 = v134
            + v14
            + (__ROR8__(v65, 19) ^ __ROR8__(v65, 61) ^ (v65 >> 6))
            + (__ROR8__(v18, 1) ^ __ROR8__(v18, 8) ^ (v18 >> 7));
        v77 = v76
            + v60
            + *(v70 - 14)
            + (result & ~v73)
            + (v73 & v68)
            + (__ROR8__(v73, 14) ^ __ROR8__(v73, 18) ^ __ROR8__(v73, 41));
        v78 = v77 + v61;
        v79 = (__ROR8__(v74, 28) ^ __ROR8__(v74, 34) ^ __ROR8__(v74, 39)) + (v74 & (v64 ^ v69) ^ v64 & v69) + v77;
        v140 = v71;
        v80 = v18
            + v50
            + (__ROR8__(v22, 1) ^ __ROR8__(v22, 8) ^ (v22 >> 7))
            + (__ROR8__(v71, 19) ^ __ROR8__(v71, 61) ^ (v71 >> 6));
        v81 = (char *)(v80
                     + result
                     + *(v70 - 13)
                     + (v68 & ~v78)
                     + (v78 & v73)
                     + (__ROR8__(v77 + v61, 14) ^ __ROR8__(v77 + v61, 18) ^ __ROR8__(v78, 41)));
        v82 = &v81[v64];
        v83 = &v81[(__ROR8__(v79, 28) ^ __ROR8__(v79, 34) ^ __ROR8__(v79, 39)) + (v79 & (v74 ^ v69) ^ v74 & v69)];
        v84 = v22
            + v54
            + (__ROR8__(v26, 1) ^ __ROR8__(v26, 8) ^ (v26 >> 7))
            + (__ROR8__(v76, 19) ^ __ROR8__(v76, 61) ^ (v76 >> 6));
        v85 = v84
            + v68
            + *(v70 - 12)
            + (v73 & ~(unint64_t)v82)
            + ((unint64_t)v82 & v78)
            + (__ROR8__(&v81[v64], 14) ^ __ROR8__(&v81[v64], 18) ^ __ROR8__(&v81[v64], 41));
        v86 = v85 + v69;
        v87 = (__ROR8__(v83, 28) ^ __ROR8__(v83, 34) ^ __ROR8__(v83, 39))
            + ((unint64_t)v83 & (v79 ^ v74) ^ v79 & v74)
            + v85;
        v26 += v58
             + (__ROR8__(v30, 1) ^ __ROR8__(v30, 8) ^ (v30 >> 7))
             + (__ROR8__(v80, 19) ^ __ROR8__(v80, 61) ^ (v80 >> 6));
        v88 = v73
            + *(v70 - 11)
            + v26
            + (v78 & ~v86)
            + (v86 & (unint64_t)v82)
            + (__ROR8__(v85 + v69, 14) ^ __ROR8__(v85 + v69, 18) ^ __ROR8__(v86, 41));
        v89 = v88 + v74;
        v90 = (__ROR8__(v87, 28) ^ __ROR8__(v87, 34) ^ __ROR8__(v87, 39))
            + (v87 & ((unint64_t)v83 ^ v79) ^ (unint64_t)v83 & v79)
            + v88;
        v30 += v62
             + (__ROR8__(v34, 1) ^ __ROR8__(v34, 8) ^ (v34 >> 7))
             + (__ROR8__(v84, 19) ^ __ROR8__(v84, 61) ^ (v84 >> 6));
        v91 = *(v70 - 10)
            + v78
            + v30
            + ((unint64_t)v82 & ~v89)
            + (v89 & v86)
            + (__ROR8__(v89, 14) ^ __ROR8__(v89, 18) ^ __ROR8__(v89, 41));
        v92 = v91 + v79;
        v93 = (__ROR8__(v90, 28) ^ __ROR8__(v90, 34) ^ __ROR8__(v90, 39))
            + (v90 & (v87 ^ (unint64_t)v83) ^ v87 & (unint64_t)v83)
            + v91;
        v34 += v65
             + (__ROR8__(v137, 1) ^ __ROR8__(v137, 8) ^ (v137 >> 7))
             + (__ROR8__(v26, 19) ^ __ROR8__(v26, 61) ^ (v26 >> 6));
        v94 = (unint64_t)&v82[*(v70 - 9)
                                   + v34
                                   + (v86 & ~v92)
                                   + (v92 & v89)
                                   + (__ROR8__(v92, 14) ^ __ROR8__(v92, 18) ^ __ROR8__(v92, 41))];
        v95 = &v83[v94];
        v96 = (__ROR8__(v93, 28) ^ __ROR8__(v93, 34) ^ __ROR8__(v93, 39)) + (v93 & (v90 ^ v87) ^ v90 & v87) + v94;
        v97 = (__ROR8__(v136, 1) ^ __ROR8__(v136, 8) ^ (v136 >> 7))
            + v137
            + v140
            + (__ROR8__(v30, 19) ^ __ROR8__(v30, 61) ^ (v30 >> 6));
        v98 = *(v70 - 8)
            + v97
            + v86
            + (v89 & ~(unint64_t)v95)
            + ((unint64_t)v95 & v92)
            + (__ROR8__(&v83[v94], 14) ^ __ROR8__(&v83[v94], 18) ^ __ROR8__(v95, 41));
        v99 = v98 + v87;
        v100 = (__ROR8__(v96, 28) ^ __ROR8__(v96, 34) ^ __ROR8__(v96, 39)) + (v96 & (v93 ^ v90) ^ v93 & v90) + v98;
        v101 = (__ROR8__(v135, 1) ^ __ROR8__(v135, 8) ^ (v135 >> 7))
             + v136
             + v76
             + (__ROR8__(v34, 19) ^ __ROR8__(v34, 61) ^ (v34 >> 6));
        v102 = *(v70 - 7)
             + v101
             + v89
             + (v92 & ~v99)
             + (v99 & (unint64_t)v95)
             + (__ROR8__(v99, 14) ^ __ROR8__(v99, 18) ^ __ROR8__(v99, 41));
        v103 = v102 + v90;
        v104 = (__ROR8__(v100, 28) ^ __ROR8__(v100, 34) ^ __ROR8__(v100, 39)) + (v100 & (v96 ^ v93) ^ v96 & v93) + v102;
        v105 = (__ROR8__(v134, 1) ^ __ROR8__(v134, 8) ^ (v134 >> 7))
             + v135
             + v80
             + (__ROR8__(v97, 19) ^ __ROR8__(v97, 61) ^ (v97 >> 6));
        v106 = *(v70 - 6)
             + v105
             + v92
             + ((unint64_t)v95 & ~v103)
             + (v103 & v99)
             + (__ROR8__(v103, 14) ^ __ROR8__(v103, 18) ^ __ROR8__(v103, 41));
        v107 = v106 + v93;
        v108 = (__ROR8__(v104, 28) ^ __ROR8__(v104, 34) ^ __ROR8__(v104, 39))
             + (v104 & (v100 ^ v96) ^ v100 & v96)
             + v106;
        v109 = (__ROR8__(v133, 1) ^ __ROR8__(v133, 8) ^ (v133 >> 7))
             + v134
             + v84
             + (__ROR8__(v101, 19) ^ __ROR8__(v101, 61) ^ (v101 >> 6));
        v110 = (uint64_t)&v95[*(v70 - 5)
                           + v109
                           + (v99 & ~v107)
                           + (v107 & v103)
                           + (__ROR8__(v107, 14) ^ __ROR8__(v107, 18) ^ __ROR8__(v107, 41))];
        v111 = v110 + v96;
        v112 = (__ROR8__(v108, 28) ^ __ROR8__(v108, 34) ^ __ROR8__(v108, 39))
             + (v108 & (v104 ^ v100) ^ v104 & v100)
             + v110;
        v135 = v105;
        v50 = (__ROR8__(v75, 1) ^ __ROR8__(v75, 8) ^ (v75 >> 7))
            + v133
            + v26
            + (__ROR8__(v105, 19) ^ __ROR8__(v105, 61) ^ (v105 >> 6));
        v113 = *(v70 - 4)
             + v50
             + v99
             + (v103 & ~v111)
             + (v111 & v107)
             + (__ROR8__(v110 + v96, 14) ^ __ROR8__(v110 + v96, 18) ^ __ROR8__(v111, 41));
        v114 = v113 + v100;
        v115 = (__ROR8__(v112, 28) ^ __ROR8__(v112, 34) ^ __ROR8__(v112, 39))
             + (v112 & (v108 ^ v104) ^ v108 & v104)
             + v113;
        v134 = v109;
        v54 = (__ROR8__(v58, 1) ^ __ROR8__(v58, 8) ^ (v58 >> 7))
            + v75
            + v30
            + (__ROR8__(v109, 19) ^ __ROR8__(v109, 61) ^ (v109 >> 6));
        v116 = *(v70 - 3)
             + v54
             + v103
             + (v107 & ~v114)
             + (v114 & v111)
             + (__ROR8__(v114, 14) ^ __ROR8__(v114, 18) ^ __ROR8__(v114, 41));
        v56 = v116 + v104;
        v57 = (__ROR8__(v115, 28) ^ __ROR8__(v115, 34) ^ __ROR8__(v115, 39))
            + (v115 & (v112 ^ v108) ^ v112 & v108)
            + v116;
        v58 += (__ROR8__(v62, 1) ^ __ROR8__(v62, 8) ^ (v62 >> 7))
             + v34
             + (__ROR8__(v50, 19) ^ __ROR8__(v50, 61) ^ (v50 >> 6));
        v117 = *(v70 - 2)
             + v58
             + v107
             + (v111 & ~v56)
             + (v56 & v114)
             + (__ROR8__(v116 + v104, 14) ^ __ROR8__(v116 + v104, 18) ^ __ROR8__(v56, 41));
        v60 = v117 + v108;
        v61 = (__ROR8__(v57, 28) ^ __ROR8__(v57, 34) ^ __ROR8__(v57, 39)) + (v57 & (v115 ^ v112) ^ v115 & v112) + v117;
        v137 = v97;
        v118 = (__ROR8__(v65, 1) ^ __ROR8__(v65, 8) ^ (v65 >> 7)) + v62 + v97;
        v18 = v80;
        v62 = v118 + (__ROR8__(v54, 19) ^ __ROR8__(v54, 61) ^ (v54 >> 6));
        v67 = v140;
        v119 = *(v70 - 1)
             + v62
             + v111
             + (v114 & ~v60)
             + (v60 & v56)
             + (__ROR8__(v60, 14) ^ __ROR8__(v60, 18) ^ __ROR8__(v60, 41));
        result = v119 + v112;
        v64 = (__ROR8__(v61, 28) ^ __ROR8__(v61, 34) ^ __ROR8__(v61, 39)) + (v61 & (v57 ^ v115) ^ v57 & v115) + v119;
        v136 = v101;
        v120 = (__ROR8__(v140, 1) ^ __ROR8__(v140, 8) ^ (v140 >> 7)) + v65 + v101;
        v22 = v84;
        v65 = v120 + (__ROR8__(v58, 19) ^ __ROR8__(v58, 61) ^ (v58 >> 6));
        v121 = *v70;
        v70 += 16;
        v122 = v121
             + v65
             + v114
             + (v56 & ~result)
             + (result & v60)
             + (__ROR8__(result, 14) ^ __ROR8__(result, 18) ^ __ROR8__(result, 41));
        v68 = v122 + v115;
        v69 = (__ROR8__(v64, 28) ^ __ROR8__(v64, 34) ^ __ROR8__(v64, 39)) + (v64 & (v61 ^ v57) ^ v61 & v57) + v122;
        v14 = v76;
        v138 += 16;
      }
      while (v138 < 0x40);
      v4 = v69 + v131;
      v3 = v64 + v130;
      *v123 = v69 + v131;
      v123[1] = v64 + v130;
      v6 = v61 + v129;
      v5 = v57 + v128;
      v123[2] = v61 + v129;
      v123[3] = v57 + v128;
      v8 = v68 + v127;
      v7 = result + v126;
      v123[4] = v68 + v127;
      v123[5] = result + v126;
      v10 = v60 + v125;
      v9 = v56 + v124;
      a2 += 16;
      v123[6] = v60 + v125;
      v123[7] = v56 + v124;
      a3 = v132 - 1;
    }
    while (v132 != 1);
  }
  return result;
}

unsigned __int8 *__cdecl SHA512(const unsigned __int8 *d, size_t n, unsigned __int8 *md)
{
  unsigned __int8 *v3;
  SHA512_CTX v5;

  memset(&v5.u.p[64], 0, 72);
  if (md)
    v3 = md;
  else
    v3 = (unsigned __int8 *)&SHA512_m;
  *(_OWORD *)v5.h = xmmword_22D69FAC0;
  *(_OWORD *)&v5.h[2] = xmmword_22D69FAD0;
  *(_OWORD *)&v5.h[4] = xmmword_22D69FAE0;
  *(_OWORD *)&v5.h[6] = xmmword_22D69FAF0;
  memset(&v5.Nl, 0, 80);
  v5.md_len = 64;
  SHA512_Update(&v5, d, n);
  SHA512_Final(v3, &v5);
  explicit_bzero(&v5, 0xD8uLL);
  return v3;
}

uint64_t SHA512_224_Init(uint64_t a1)
{
  *(_QWORD *)(a1 + 208) = 0;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)a1 = xmmword_22D69FB00;
  *(_OWORD *)(a1 + 16) = xmmword_22D69FB10;
  *(_OWORD *)(a1 + 32) = xmmword_22D69FB20;
  *(_OWORD *)(a1 + 48) = xmmword_22D69FB30;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_DWORD *)(a1 + 212) = 28;
  return 1;
}

uint64_t SHA512_224_Update(SHA512_CTX *a1, const void *a2, size_t a3)
{
  SHA512_Update(a1, a2, a3);
  return 1;
}

uint64_t SHA512_256_Init(uint64_t a1)
{
  *(_QWORD *)(a1 + 208) = 0;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)a1 = xmmword_22D69FB40;
  *(_OWORD *)(a1 + 16) = xmmword_22D69FB50;
  *(_OWORD *)(a1 + 32) = xmmword_22D69FB60;
  *(_OWORD *)(a1 + 48) = xmmword_22D69FB70;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_DWORD *)(a1 + 212) = 32;
  return 1;
}

uint64_t SHA512_256_Update(SHA512_CTX *a1, const void *a2, size_t a3)
{
  SHA512_Update(a1, a2, a3);
  return 1;
}

void BF_encrypt(unsigned int *data, const BF_KEY *key)
{
  unsigned int v2;
  unsigned int v3;
  unsigned int v4;
  unsigned int v5;
  unsigned int v6;
  unsigned int v7;
  unsigned int v8;
  unsigned int v9;
  unsigned int v10;
  unsigned int v11;
  unsigned int v12;
  unsigned int v13;
  unsigned int v14;
  unsigned int v15;
  unsigned int v16;
  unsigned int v17;
  unsigned int v18;

  v2 = key->P[0] ^ *data;
  v3 = key->P[1] ^ data[1] ^ (((key->S[BYTE2(v2) | 0x100] + key->S[HIBYTE(v2)]) ^ key->S[BYTE1(v2) | 0x200])
                            + key->S[(LOBYTE(key->P[0]) ^ *(_BYTE *)data) | 0x300]);
  v4 = key->P[2] ^ v2 ^ (((key->S[BYTE2(v3) | 0x100] + key->S[HIBYTE(v3)]) ^ key->S[BYTE1(v3) | 0x200])
                       + key->S[(LOBYTE(key->P[1]) ^ *((_BYTE *)data + 4) ^ (((LOBYTE(key->S[BYTE2(v2) | 0x100])
                                                                                              + LOBYTE(key->S[HIBYTE(v2)])) ^ LOBYTE(key->S[BYTE1(v2) | 0x200]))
                                                                                            + LOBYTE(key->S[(LOBYTE(key->P[0]) ^ *(_BYTE *)data) | 0x300]))) | 0x300]);
  v5 = key->P[3] ^ v3 ^ (((key->S[BYTE2(v4) | 0x100] + key->S[HIBYTE(v4)]) ^ key->S[BYTE1(v4) | 0x200])
                       + key->S[v4 | 0x300]);
  v6 = key->P[4] ^ v4 ^ (((key->S[BYTE2(v5) | 0x100] + key->S[HIBYTE(v5)]) ^ key->S[BYTE1(v5) | 0x200])
                       + key->S[v5 | 0x300]);
  v7 = key->P[5] ^ v5 ^ (((key->S[BYTE2(v6) | 0x100] + key->S[HIBYTE(v6)]) ^ key->S[BYTE1(v6) | 0x200])
                       + key->S[v6 | 0x300]);
  v8 = key->P[6] ^ v6 ^ (((key->S[BYTE2(v7) | 0x100] + key->S[HIBYTE(v7)]) ^ key->S[BYTE1(v7) | 0x200])
                       + key->S[v7 | 0x300]);
  v9 = key->P[7] ^ v7 ^ (((key->S[BYTE2(v8) | 0x100] + key->S[HIBYTE(v8)]) ^ key->S[BYTE1(v8) | 0x200])
                       + key->S[v8 | 0x300]);
  v10 = key->P[8] ^ v8 ^ (((key->S[BYTE2(v9) | 0x100] + key->S[HIBYTE(v9)]) ^ key->S[BYTE1(v9) | 0x200])
                        + key->S[v9 | 0x300]);
  v11 = key->P[9] ^ v9 ^ (((key->S[BYTE2(v10) | 0x100] + key->S[HIBYTE(v10)]) ^ key->S[BYTE1(v10) | 0x200])
                        + key->S[v10 | 0x300]);
  v12 = key->P[10] ^ v10 ^ (((key->S[BYTE2(v11) | 0x100] + key->S[HIBYTE(v11)]) ^ key->S[BYTE1(v11) | 0x200])
                          + key->S[v11 | 0x300]);
  v13 = key->P[11] ^ v11 ^ (((key->S[BYTE2(v12) | 0x100] + key->S[HIBYTE(v12)]) ^ key->S[BYTE1(v12) | 0x200])
                          + key->S[v12 | 0x300]);
  v14 = key->P[12] ^ v12 ^ (((key->S[BYTE2(v13) | 0x100] + key->S[HIBYTE(v13)]) ^ key->S[BYTE1(v13) | 0x200])
                          + key->S[v13 | 0x300]);
  v15 = key->P[13] ^ v13 ^ (((key->S[BYTE2(v14) | 0x100] + key->S[HIBYTE(v14)]) ^ key->S[BYTE1(v14) | 0x200])
                          + key->S[v14 | 0x300]);
  v16 = key->P[14] ^ v14 ^ (((key->S[BYTE2(v15) | 0x100] + key->S[HIBYTE(v15)]) ^ key->S[BYTE1(v15) | 0x200])
                          + key->S[v15 | 0x300]);
  v17 = key->P[15] ^ v15 ^ (((key->S[BYTE2(v16) | 0x100] + key->S[HIBYTE(v16)]) ^ key->S[BYTE1(v16) | 0x200])
                          + key->S[v16 | 0x300]);
  v18 = key->P[16] ^ v16 ^ (((key->S[BYTE2(v17) | 0x100] + key->S[HIBYTE(v17)]) ^ key->S[BYTE1(v17) | 0x200])
                          + key->S[v17 | 0x300]);
  *data = key->P[17] ^ v17;
  data[1] = v18;
}

void BF_decrypt(unsigned int *data, const BF_KEY *key)
{
  unsigned int v2;
  unsigned int v3;
  unsigned int v4;
  unsigned int v5;
  unsigned int v6;
  unsigned int v7;
  unsigned int v8;
  unsigned int v9;
  unsigned int v10;
  unsigned int v11;
  unsigned int v12;
  unsigned int v13;
  unsigned int v14;
  unsigned int v15;
  unsigned int v16;
  unsigned int v17;
  unsigned int v18;

  v2 = key->P[17] ^ *data;
  v3 = key->P[16] ^ data[1] ^ (((key->S[BYTE2(v2) | 0x100] + key->S[HIBYTE(v2)]) ^ key->S[BYTE1(v2) | 0x200])
                             + key->S[(LOBYTE(key->P[17]) ^ *(_BYTE *)data) | 0x300]);
  v4 = key->P[15] ^ v2 ^ (((key->S[BYTE2(v3) | 0x100] + key->S[HIBYTE(v3)]) ^ key->S[BYTE1(v3) | 0x200])
                        + key->S[(LOBYTE(key->P[16]) ^ *((_BYTE *)data + 4) ^ (((LOBYTE(key->S[BYTE2(v2) | 0x100])
                                                                                                + LOBYTE(key->S[HIBYTE(v2)])) ^ LOBYTE(key->S[BYTE1(v2) | 0x200]))
                                                                                              + LOBYTE(key->S[(LOBYTE(key->P[17]) ^ *(_BYTE *)data) | 0x300]))) | 0x300]);
  v5 = key->P[14] ^ v3 ^ (((key->S[BYTE2(v4) | 0x100] + key->S[HIBYTE(v4)]) ^ key->S[BYTE1(v4) | 0x200])
                        + key->S[v4 | 0x300]);
  v6 = key->P[13] ^ v4 ^ (((key->S[BYTE2(v5) | 0x100] + key->S[HIBYTE(v5)]) ^ key->S[BYTE1(v5) | 0x200])
                        + key->S[v5 | 0x300]);
  v7 = key->P[12] ^ v5 ^ (((key->S[BYTE2(v6) | 0x100] + key->S[HIBYTE(v6)]) ^ key->S[BYTE1(v6) | 0x200])
                        + key->S[v6 | 0x300]);
  v8 = key->P[11] ^ v6 ^ (((key->S[BYTE2(v7) | 0x100] + key->S[HIBYTE(v7)]) ^ key->S[BYTE1(v7) | 0x200])
                        + key->S[v7 | 0x300]);
  v9 = key->P[10] ^ v7 ^ (((key->S[BYTE2(v8) | 0x100] + key->S[HIBYTE(v8)]) ^ key->S[BYTE1(v8) | 0x200])
                        + key->S[v8 | 0x300]);
  v10 = key->P[9] ^ v8 ^ (((key->S[BYTE2(v9) | 0x100] + key->S[HIBYTE(v9)]) ^ key->S[BYTE1(v9) | 0x200])
                        + key->S[v9 | 0x300]);
  v11 = key->P[8] ^ v9 ^ (((key->S[BYTE2(v10) | 0x100] + key->S[HIBYTE(v10)]) ^ key->S[BYTE1(v10) | 0x200])
                        + key->S[v10 | 0x300]);
  v12 = key->P[7] ^ v10 ^ (((key->S[BYTE2(v11) | 0x100] + key->S[HIBYTE(v11)]) ^ key->S[BYTE1(v11) | 0x200])
                         + key->S[v11 | 0x300]);
  v13 = key->P[6] ^ v11 ^ (((key->S[BYTE2(v12) | 0x100] + key->S[HIBYTE(v12)]) ^ key->S[BYTE1(v12) | 0x200])
                         + key->S[v12 | 0x300]);
  v14 = key->P[5] ^ v12 ^ (((key->S[BYTE2(v13) | 0x100] + key->S[HIBYTE(v13)]) ^ key->S[BYTE1(v13) | 0x200])
                         + key->S[v13 | 0x300]);
  v15 = key->P[4] ^ v13 ^ (((key->S[BYTE2(v14) | 0x100] + key->S[HIBYTE(v14)]) ^ key->S[BYTE1(v14) | 0x200])
                         + key->S[v14 | 0x300]);
  v16 = key->P[3] ^ v14 ^ (((key->S[BYTE2(v15) | 0x100] + key->S[HIBYTE(v15)]) ^ key->S[BYTE1(v15) | 0x200])
                         + key->S[v15 | 0x300]);
  v17 = key->P[2] ^ v15 ^ (((key->S[BYTE2(v16) | 0x100] + key->S[HIBYTE(v16)]) ^ key->S[BYTE1(v16) | 0x200])
                         + key->S[v16 | 0x300]);
  v18 = key->P[1] ^ v16 ^ (((key->S[BYTE2(v17) | 0x100] + key->S[HIBYTE(v17)]) ^ key->S[BYTE1(v17) | 0x200])
                         + key->S[v17 | 0x300]);
  *data = key->P[0] ^ v17;
  data[1] = v18;
}

void BF_cbc_encrypt(const unsigned __int8 *in, unsigned __int8 *out, uint64_t length, const BF_KEY *schedule, unsigned __int8 *ivec, int enc)
{
  uint64_t v8;
  unsigned int v10;
  unsigned int v11;
  unsigned __int8 *v12;
  unint64_t v13;
  const unsigned __int8 *v14;
  unsigned int v15;
  int v16;
  const unsigned __int8 *v17;
  int v18;
  int v19;
  int v20;
  int v21;
  int v22;
  int v23;
  int v24;
  unsigned int v25;
  unsigned int v26;
  unsigned int v27;
  unsigned int v28;
  unsigned int v29;
  unsigned int v30;
  unsigned int v31;
  unsigned __int8 *v32;
  unsigned int v33;
  unsigned int v34;
  unint64_t v35;
  const unsigned __int8 *v36;
  unsigned int v37;
  int v38;
  unsigned int v39;
  unsigned int v40;
  int v41;
  unsigned __int8 *v42;
  unsigned int v43;
  int v44;
  uint64_t v45;

  v8 = length;
  v45 = *MEMORY[0x24BDAC8D0];
  v10 = bswap32(*(_DWORD *)ivec);
  v11 = bswap32(*((_DWORD *)ivec + 1));
  if (enc)
  {
    if (length >= 8)
    {
      do
      {
        v12 = out;
        v13 = v8;
        v8 -= 8;
        v14 = in + 8;
        v15 = bswap32(*((_DWORD *)in + 1));
        v43 = bswap32(*(_DWORD *)in) ^ v10;
        v44 = v15 ^ v11;
        BF_encrypt(&v43, schedule);
        v10 = v43;
        v11 = v44;
        *out = HIBYTE(v43);
        out[1] = BYTE2(v10);
        out[2] = BYTE1(v10);
        out[3] = v10;
        out[4] = HIBYTE(v11);
        out[5] = BYTE2(v11);
        out[6] = BYTE1(v11);
        out += 8;
        v12[7] = v11;
        in = v14;
      }
      while (v13 > 0xF);
      in = v14;
    }
    if (v8)
    {
      v16 = 0;
      v17 = &in[v8];
      v18 = 0;
      switch(v8)
      {
        case 1:
          goto LABEL_13;
        case 2:
          goto LABEL_12;
        case 3:
          goto LABEL_11;
        case 4:
          goto LABEL_10;
        case 5:
          goto LABEL_9;
        case 6:
          goto LABEL_8;
        case 7:
          v19 = *--v17;
          v16 = v19 << 8;
LABEL_8:
          v20 = *--v17;
          v16 |= v20 << 16;
LABEL_9:
          v21 = *--v17;
          v16 |= v21 << 24;
LABEL_10:
          v18 = v16;
          v22 = *--v17;
          v16 = v22;
LABEL_11:
          v23 = *--v17;
          v16 |= v23 << 8;
LABEL_12:
          v24 = *--v17;
          v16 |= v24 << 16;
LABEL_13:
          v16 |= *(v17 - 1) << 24;
          break;
        default:
          v18 = 0;
          break;
      }
      v43 = v16 ^ v10;
      v44 = v18 ^ v11;
      BF_encrypt(&v43, schedule);
      v10 = v43;
      v25 = v44;
      v26 = HIBYTE(v43);
      *out = HIBYTE(v43);
      v27 = HIWORD(v10);
      out[1] = BYTE2(v10);
      v28 = v10 >> 8;
      out[2] = BYTE1(v10);
      out[3] = v10;
      v29 = HIBYTE(v25);
      out[4] = HIBYTE(v25);
      v30 = HIWORD(v25);
      out[5] = BYTE2(v25);
      v31 = v25 >> 8;
      out[6] = BYTE1(v25);
      out[7] = v25;
    }
    else
    {
      v26 = HIBYTE(v10);
      v27 = HIWORD(v10);
      v28 = v10 >> 8;
      v29 = HIBYTE(v11);
      v30 = HIWORD(v11);
      LOBYTE(v25) = v11;
      v31 = v11 >> 8;
    }
    *ivec = v26;
    ivec[1] = v27;
    ivec[2] = v28;
    ivec[3] = v10;
    ivec[4] = v29;
    ivec[5] = v30;
    ivec[6] = v31;
  }
  else
  {
    if (length >= 8)
    {
      do
      {
        v32 = out;
        v33 = v10;
        v34 = v11;
        v35 = v8;
        v8 -= 8;
        v10 = bswap32(*(_DWORD *)in);
        v36 = in + 8;
        v11 = bswap32(*((_DWORD *)in + 1));
        v43 = v10;
        v44 = v11;
        BF_decrypt(&v43, schedule);
        v37 = v43 ^ v33;
        v38 = v44 ^ v34;
        *v32 = (v43 ^ v33) >> 24;
        v32[1] = BYTE2(v37);
        v32[2] = BYTE1(v37);
        v32[3] = v37;
        v32[4] = HIBYTE(v38);
        v32[5] = BYTE2(v38);
        v32[6] = BYTE1(v38);
        out = v32 + 8;
        v32[7] = v38;
        in = v36;
      }
      while (v35 > 0xF);
      in = v36;
    }
    if (v8)
    {
      v39 = bswap32(*(_DWORD *)in);
      v25 = bswap32(*((_DWORD *)in + 1));
      v43 = v39;
      v44 = v25;
      BF_decrypt(&v43, schedule);
      v40 = v43 ^ v10;
      v41 = v44 ^ v11;
      v42 = &out[v8];
      switch(v8)
      {
        case 1:
          goto LABEL_26;
        case 2:
          goto LABEL_25;
        case 3:
          goto LABEL_24;
        case 4:
          goto LABEL_23;
        case 5:
          goto LABEL_22;
        case 6:
          goto LABEL_21;
        case 7:
          *--v42 = BYTE1(v41);
LABEL_21:
          *--v42 = BYTE2(v41);
LABEL_22:
          *--v42 = HIBYTE(v41);
LABEL_23:
          *--v42 = v40;
LABEL_24:
          *--v42 = BYTE1(v40);
LABEL_25:
          *--v42 = BYTE2(v40);
LABEL_26:
          *(v42 - 1) = HIBYTE(v40);
          break;
        default:
          break;
      }
    }
    else
    {
      v39 = v10;
      v25 = v11;
    }
    *ivec = HIBYTE(v39);
    ivec[1] = BYTE2(v39);
    ivec[2] = BYTE1(v39);
    ivec[3] = v39;
    ivec[4] = HIBYTE(v25);
    ivec[5] = BYTE2(v25);
    ivec[6] = BYTE1(v25);
  }
  ivec[7] = v25;
}

const ECDSA_METHOD *ECDSA_OpenSSL(void)
{
  return (const ECDSA_METHOD *)&openssl_ecdsa_meth;
}

BOOL ossl_ecdsa_sign(int a1, unsigned __int8 *dgst, int dgstlen, unsigned __int8 *a4, int *a5, BIGNUM *kinv, BIGNUM *rp, EC_KEY *eckey)
{
  ECDSA_SIG *v9;
  ECDSA_SIG *v10;
  int v11;
  int v12;
  _BOOL8 v13;
  unsigned __int8 *pp;

  pp = a4;
  v9 = ECDSA_do_sign_ex(dgst, dgstlen, kinv, rp, eckey);
  v10 = v9;
  if (v9)
  {
    v11 = i2d_ECDSA_SIG(v9, &pp);
    v12 = v11 & ~(v11 >> 31);
    v13 = v11 >= 0;
  }
  else
  {
    v12 = 0;
    v13 = 0;
  }
  *a5 = v12;
  ECDSA_SIG_free(v10);
  return v13;
}

ECDSA_SIG *__cdecl ECDSA_do_sign_ex(const unsigned __int8 *dgst, int dgstlen, const BIGNUM *kinv, const BIGNUM *rp, EC_KEY *eckey)
{
  uint64_t (*v5)(const unsigned __int8 *, _QWORD, const BIGNUM *, const BIGNUM *);

  v5 = *(uint64_t (**)(const unsigned __int8 *, _QWORD, const BIGNUM *, const BIGNUM *))(*(_QWORD *)eckey
                                                                                                 + 96);
  if (v5)
    return (ECDSA_SIG *)v5(dgst, *(_QWORD *)&dgstlen, kinv, rp);
  ERR_put_error(42, 4095, 144, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ecdsa/ecs_ossl.c", 590);
  return 0;
}

_QWORD *ossl_ecdsa_sign_setup(EC_KEY *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD *result;

  result = ecdsa_check(a1);
  if (result)
    return (_QWORD *)(*(uint64_t (**)(EC_KEY *, uint64_t, uint64_t, uint64_t))(result[3] + 16))(a1, a2, a3, a4);
  return result;
}

_QWORD *ossl_ecdsa_sign_sig(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, EC_KEY *a5)
{
  _QWORD *result;

  result = ecdsa_check(a5);
  if (result)
    return (_QWORD *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, EC_KEY *))(result[3] + 8))(a1, a2, a3, a4, a5);
  return result;
}

uint64_t ossl_ecdsa_verify(uint64_t a1, const unsigned __int8 *a2, int a3, unsigned __int8 *a4, int a5, EC_KEY *a6)
{
  int v11;
  unsigned __int8 *v12;
  uint64_t v13;
  unsigned __int8 *pp;
  unsigned __int8 *v16;
  ECDSA_SIG *v;

  pp = a4;
  v16 = 0;
  v = ECDSA_SIG_new();
  if (v)
  {
    if (d2i_ECDSA_SIG(&v, (const unsigned __int8 **)&pp, a5))
    {
      v11 = i2d_ECDSA_SIG(v, &v16);
      v12 = v16;
      if (v11 != a5)
      {
        v13 = 0xFFFFFFFFLL;
        a5 = v11;
        goto LABEL_10;
      }
      if (!memcmp(a4, v16, a5))
      {
        v13 = ECDSA_do_verify(a2, a3, v, a6);
        v12 = v16;
LABEL_10:
        freezero(v12, a5);
        ECDSA_SIG_free(v);
        return v13;
      }
    }
    else
    {
      v12 = 0;
      a5 = -1;
    }
    v13 = 0xFFFFFFFFLL;
    goto LABEL_10;
  }
  return 0xFFFFFFFFLL;
}

int ECDSA_do_verify(const unsigned __int8 *dgst, int dgst_len, const ECDSA_SIG *sig, EC_KEY *eckey)
{
  uint64_t (*v4)(const unsigned __int8 *, _QWORD, const ECDSA_SIG *);

  v4 = *(uint64_t (**)(const unsigned __int8 *, _QWORD, const ECDSA_SIG *))(*(_QWORD *)eckey + 112);
  if (v4)
    return v4(dgst, *(_QWORD *)&dgst_len, sig);
  ERR_put_error(42, 4095, 144, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ecdsa/ecs_ossl.c", 626);
  return 0;
}

_QWORD *ossl_ecdsa_verify_sig(uint64_t a1, uint64_t a2, uint64_t a3, EC_KEY *a4)
{
  _QWORD *result;

  result = ecdsa_check(a4);
  if (result)
    return (_QWORD *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t, EC_KEY *))(result[3] + 24))(a1, a2, a3, a4);
  return result;
}

ECDSA_SIG *__cdecl ECDSA_do_sign(const unsigned __int8 *dgst, int dgst_len, EC_KEY *eckey)
{
  return ECDSA_do_sign_ex(dgst, dgst_len, 0, 0, eckey);
}

int ECDSA_sign(int type, const unsigned __int8 *dgst, int dgstlen, unsigned __int8 *sig, unsigned int *siglen, EC_KEY *eckey)
{
  return ECDSA_sign_ex(type, dgst, dgstlen, sig, siglen, 0, 0, eckey);
}

int ECDSA_sign_ex(int type, const unsigned __int8 *dgst, int dgstlen, unsigned __int8 *sig, unsigned int *siglen, const BIGNUM *kinv, const BIGNUM *rp, EC_KEY *eckey)
{
  uint64_t (*v8)(_QWORD, const unsigned __int8 *, _QWORD, unsigned __int8 *, unsigned int *, const BIGNUM *, const BIGNUM *);

  v8 = *(uint64_t (**)(_QWORD, const unsigned __int8 *, _QWORD, unsigned __int8 *, unsigned int *, const BIGNUM *, const BIGNUM *))(*(_QWORD *)eckey + 80);
  if (v8)
    return v8(*(_QWORD *)&type, dgst, *(_QWORD *)&dgstlen, sig, siglen, kinv, rp);
  ERR_put_error(42, 4095, 144, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ecdsa/ecs_ossl.c", 607);
  return 0;
}

int ECDSA_sign_setup(EC_KEY *eckey, BN_CTX *ctx, BIGNUM **kinv, BIGNUM **rp)
{
  uint64_t (*v4)(void);

  v4 = *(uint64_t (**)(void))(*(_QWORD *)eckey + 88);
  if (v4)
    return v4();
  ERR_put_error(42, 4095, 144, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ecdsa/ecs_ossl.c", 616);
  return 0;
}

int ECDSA_verify(int type, const unsigned __int8 *dgst, int dgstlen, const unsigned __int8 *sig, int siglen, EC_KEY *eckey)
{
  uint64_t (*v6)(_QWORD, const unsigned __int8 *, _QWORD, const unsigned __int8 *, _QWORD);

  v6 = *(uint64_t (**)(_QWORD, const unsigned __int8 *, _QWORD, const unsigned __int8 *, _QWORD))(*(_QWORD *)eckey + 104);
  if (v6)
    return v6(*(_QWORD *)&type, dgst, *(_QWORD *)&dgstlen, sig, *(_QWORD *)&siglen);
  ERR_put_error(42, 4095, 144, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ecdsa/ecs_ossl.c", 637);
  return 0;
}

ECDSA_SIG *ecdsa_do_sign(const unsigned __int8 *a1, int a2, const BIGNUM *a3, const BIGNUM *a4, EC_KEY *a5)
{
  void *v10;
  const EC_GROUP *v11;
  const BIGNUM *v12;
  const BIGNUM *v13;
  ECDSA_SIG *v14;
  ECDSA_SIG *v15;
  BIGNUM *s;
  BN_CTX *v17;
  BIGNUM *v18;
  _BOOL4 v19;
  _BOOL4 v20;
  int v21;
  BIGNUM *v22;
  const BIGNUM *v23;
  BIGNUM *v24;
  BIGNUM *v25;
  const BIGNUM *v26;
  int v27;
  int v28;
  BIGNUM *v29;
  BIGNUM *v30;
  BIGNUM *v31;
  int v33;
  _BOOL4 v34;
  _BOOL4 v35;
  int v36;
  const BIGNUM *v37;
  BIGNUM *b;
  const BIGNUM *v39;
  BIGNUM *v40;
  BIGNUM *v41;
  BIGNUM *rnd;
  BIGNUM *v43;
  BIGNUM *r;
  BIGNUM *kinv;

  kinv = 0;
  v10 = ecdsa_check(a5);
  v11 = EC_KEY_get0_group(a5);
  v12 = EC_KEY_get0_private_key(a5);
  if (!v11 || (v13 = v12) == 0 || !v10)
  {
    ERR_put_error(42, 4095, 67, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ecdsa/ecs_ossl.c", 301);
    return 0;
  }
  v14 = ECDSA_SIG_new();
  v15 = v14;
  if (!v14)
  {
    ERR_put_error(42, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ecdsa/ecs_ossl.c", 306);
    return v15;
  }
  s = v14->s;
  v17 = BN_CTX_new();
  if (!v17)
  {
    v25 = 0;
    v29 = 0;
    v30 = 0;
    v22 = 0;
    v18 = 0;
    goto LABEL_44;
  }
  v43 = s;
  v18 = BN_new();
  if (!v18 || (r = BN_new()) == 0)
  {
    v25 = 0;
    v29 = 0;
    v30 = 0;
    v22 = 0;
LABEL_44:
    v24 = 0;
LABEL_45:
    ERR_put_error(42, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ecdsa/ecs_ossl.c", 315);
    v31 = 0;
    goto LABEL_46;
  }
  rnd = BN_new();
  if (!rnd)
  {
    v25 = 0;
    v29 = 0;
    v30 = 0;
    v22 = 0;
    v24 = r;
    goto LABEL_45;
  }
  v41 = BN_new();
  if (!v41)
  {
    v29 = 0;
    v30 = 0;
    v22 = 0;
    v24 = r;
    v25 = rnd;
    goto LABEL_45;
  }
  v40 = BN_new();
  if (!v40)
  {
    v30 = 0;
    v22 = 0;
    v24 = r;
    v29 = v41;
    v25 = rnd;
    goto LABEL_45;
  }
  v39 = BN_new();
  if (!v39)
  {
    v22 = 0;
    v24 = r;
    v29 = v41;
    v25 = rnd;
    v30 = v40;
    goto LABEL_45;
  }
  b = BN_new();
  if (!b)
  {
    v24 = r;
    v29 = v41;
    v25 = rnd;
    v22 = (BIGNUM *)v39;
    v30 = v40;
    goto LABEL_45;
  }
  if (!EC_GROUP_get_order(v11, v18, v17))
  {
    ERR_put_error(42, 4095, 16, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ecdsa/ecs_ossl.c", 320);
LABEL_55:
    v24 = r;
    v29 = v41;
    v25 = rnd;
    v30 = v40;
LABEL_56:
    v22 = (BIGNUM *)v39;
    goto LABEL_75;
  }
  if (!ecdsa_prepare_digest(a1, a2, v18, b))
    goto LABEL_55;
  if (a4)
    v19 = a3 == 0;
  else
    v19 = 1;
  if (a4)
    v20 = a3 != 0;
  else
    v20 = 0;
  v34 = v19;
  v35 = v20;
  v21 = 33;
  v22 = (BIGNUM *)v39;
  while (1)
  {
    v36 = v21;
    if (!v19)
      break;
    if (!ECDSA_sign_setup(a5, v17, &kinv, &v15->r))
    {
      v27 = 42;
      v28 = 330;
      goto LABEL_72;
    }
    v37 = kinv;
LABEL_26:
    v23 = BN_value_one();
    v24 = r;
    if (!BN_sub(r, v18, v23))
    {
      ERR_put_error(42, 4095, 3, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ecdsa/ecs_ossl.c", 357);
      goto LABEL_73;
    }
    v25 = rnd;
    if (!BN_rand_range(rnd, r))
    {
      v33 = 361;
LABEL_61:
      ERR_put_error(42, 4095, 3, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ecdsa/ecs_ossl.c", v33);
      v24 = r;
      goto LABEL_74;
    }
    v26 = BN_value_one();
    if (!BN_add(rnd, rnd, v26))
    {
      v33 = 365;
      goto LABEL_61;
    }
    if (!BN_mod_inverse_ct(v41, rnd, v18, v17))
    {
      v33 = 370;
      goto LABEL_61;
    }
    if (!BN_mod_mul(v22, rnd, v13, v18, v17))
    {
      v27 = 3;
      v28 = 375;
      goto LABEL_72;
    }
    if (!BN_mod_mul(v22, v22, v15->r, v18, v17))
    {
      v27 = 3;
      v28 = 379;
      goto LABEL_72;
    }
    if (!BN_mod_mul(v40, rnd, b, v18, v17))
    {
      ERR_put_error(42, 4095, 3, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ecdsa/ecs_ossl.c", 383);
      v24 = r;
      v29 = v41;
      v25 = rnd;
      v30 = v40;
      goto LABEL_56;
    }
    v22 = (BIGNUM *)v39;
    if (!BN_mod_add(v43, v40, v39, v18, v17))
    {
      v27 = 3;
      v28 = 387;
      goto LABEL_72;
    }
    if (!BN_mod_mul(v43, v43, v37, v18, v17))
    {
      v27 = 3;
      v28 = 391;
      goto LABEL_72;
    }
    if (!BN_mod_mul(v43, v43, v41, v18, v17))
    {
      v27 = 3;
      v28 = 395;
      goto LABEL_72;
    }
    if (!BN_is_zero((uint64_t)v43))
    {
      v24 = r;
      v29 = v41;
      v25 = rnd;
      v30 = v40;
      v31 = b;
      goto LABEL_47;
    }
    if (v35)
    {
      v27 = 106;
      v28 = 405;
      goto LABEL_72;
    }
    v21 = v36 - 1;
    v19 = v34;
    if (v36 == 1)
    {
      v27 = 145;
      v28 = 410;
      goto LABEL_72;
    }
  }
  v37 = a3;
  if (bn_copy(v15->r, a4))
    goto LABEL_26;
  v27 = 65;
  v28 = 337;
LABEL_72:
  ERR_put_error(42, 4095, v27, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ecdsa/ecs_ossl.c", v28);
  v24 = r;
LABEL_73:
  v25 = rnd;
LABEL_74:
  v30 = v40;
  v29 = v41;
LABEL_75:
  v31 = b;
LABEL_46:
  ECDSA_SIG_free(v15);
  v15 = 0;
LABEL_47:
  BN_CTX_free(v17);
  BN_free(v25);
  BN_free(v29);
  BN_free(v30);
  BN_free(v22);
  BN_free(kinv);
  BN_free(v31);
  BN_free(v18);
  BN_free(v24);
  return v15;
}

uint64_t ecdsa_sign_setup(const EC_KEY *a1, BN_CTX *a2, BIGNUM **a3, BIGNUM **a4)
{
  const EC_GROUP *v7;
  const EC_GROUP *v8;
  BN_CTX *v9;
  BIGNUM *v10;
  BIGNUM *v11;
  BIGNUM *v12;
  BIGNUM *v13;
  BIGNUM *v14;
  EC_POINT *v15;
  const BIGNUM *v16;
  int v17;
  int v18;
  int v19;
  int v20;
  int v21;
  uint64_t v22;
  const BIGNUM *v24;
  int n;

  if (a1 && (v7 = EC_KEY_get0_group(a1)) != 0)
  {
    v8 = v7;
    v9 = a2;
    if (a2 || (v9 = BN_CTX_new()) != 0)
    {
      v10 = BN_new();
      if (v10)
      {
        v11 = BN_new();
        if (v11)
        {
          v12 = BN_new();
          if (v12)
          {
            v13 = BN_new();
            if (v13)
            {
              v14 = v13;
              v15 = EC_POINT_new(v8);
              if (v15)
              {
                if (EC_GROUP_get_order(v8, v12, v9))
                {
                  v16 = BN_value_one();
                  if (BN_cmp(v12, v16) <= 0)
                  {
                    v18 = 122;
                    v19 = 178;
                  }
                  else
                  {
                    v17 = BN_num_bits(v12);
                    if (v17 > 79)
                    {
                      n = v17;
                      if (!BN_set_bit(v10, v17) || !BN_set_bit(v11, n) || !BN_set_bit(v14, n))
                      {
LABEL_19:
                        BN_free(v10);
                        BN_free(v11);
                        v22 = 0;
                        if (a2)
                        {
LABEL_21:
                          BN_free(v12);
                          EC_POINT_free(v15);
                          BN_free(v14);
                          return v22;
                        }
LABEL_20:
                        BN_CTX_free(v9);
                        goto LABEL_21;
                      }
                      do
                      {
                        do
                        {
                          if (!BN_rand_range(v10, v12))
                          {
                            v18 = 104;
                            v19 = 198;
                            goto LABEL_27;
                          }
                        }
                        while (BN_is_zero((uint64_t)v10));
                        if (!BN_add(v11, v10, v12) || !BN_add(v14, v11, v12))
                          goto LABEL_19;
                        v24 = BN_num_bits(v11) <= n ? v14 : v11;
                        if (!bn_copy(v10, v24))
                          goto LABEL_19;
                        BN_set_flags((uint64_t)v10, 4);
                        if (!EC_POINT_mul(v8, v15, v10, 0, 0, v9))
                        {
                          v18 = 16;
                          v19 = 226;
                          goto LABEL_27;
                        }
                        if (!EC_POINT_get_affine_coordinates((uint64_t)v8, v15, (uint64_t)v14, 0, v9))
                        {
                          v18 = 16;
                          v19 = 231;
                          goto LABEL_27;
                        }
                        if (!BN_nnmod(v11, v14, v12, v9))
                        {
                          v18 = 3;
                          v19 = 235;
                          goto LABEL_27;
                        }
                      }
                      while (BN_is_zero((uint64_t)v11));
                      if (BN_mod_inverse_ct(v10, v10, v12, v9))
                      {
                        BN_free(*a4);
                        BN_free(*a3);
                        *a4 = v11;
                        *a3 = v10;
                        v22 = 1;
                        if (a2)
                          goto LABEL_21;
                        goto LABEL_20;
                      }
                      v18 = 3;
                      v19 = 241;
                    }
                    else
                    {
                      v18 = 122;
                      v19 = 184;
                    }
                  }
                }
                else
                {
                  v18 = 16;
                  v19 = 173;
                }
              }
              else
              {
                v18 = 16;
                v19 = 169;
              }
LABEL_27:
              ERR_put_error(42, 4095, v18, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ecdsa/ecs_ossl.c", v19);
              goto LABEL_19;
            }
          }
LABEL_18:
          ERR_put_error(42, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ecdsa/ecs_ossl.c", 165);
          v14 = 0;
          v15 = 0;
          goto LABEL_19;
        }
      }
      else
      {
        v11 = 0;
      }
      v12 = 0;
      goto LABEL_18;
    }
    v20 = 65;
    v21 = 158;
  }
  else
  {
    v20 = 67;
    v21 = 152;
  }
  ERR_put_error(42, 4095, v20, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ecdsa/ecs_ossl.c", v21);
  return 0;
}

uint64_t ecdsa_do_verify(const unsigned __int8 *a1, int a2, uint64_t *a3, EC_KEY *a4)
{
  const EC_GROUP *v8;
  const EC_GROUP *v9;
  const EC_POINT *v10;
  const EC_POINT *v11;
  BN_CTX *v12;
  BN_CTX *v13;
  BIGNUM *v14;
  BIGNUM *v15;
  BIGNUM *v16;
  BIGNUM *v17;
  const BIGNUM *v18;
  EC_POINT *v19;
  uint64_t v20;
  int v21;
  int v22;
  int v24;
  int v25;
  int v26;
  int v27;
  BIGNUM *r;

  if (a4
    && (v8 = EC_KEY_get0_group(a4)) != 0
    && (v9 = v8, v10 = EC_KEY_get0_public_key(a4), a3)
    && (v11 = v10) != 0)
  {
    v12 = BN_CTX_new();
    if (v12)
    {
      v13 = v12;
      BN_CTX_start(v12);
      v14 = BN_CTX_get(v13);
      r = BN_CTX_get(v13);
      v15 = BN_CTX_get(v13);
      v16 = BN_CTX_get(v13);
      v17 = BN_CTX_get(v13);
      if (v17)
      {
        v18 = v17;
        if (EC_GROUP_get_order(v9, v14, v13))
        {
          if (BN_is_zero(*a3)
            || BN_is_negative(*a3)
            || (BN_ucmp((const BIGNUM *)*a3, v14) & 0x80000000) == 0
            || BN_is_zero(a3[1])
            || BN_is_negative(a3[1])
            || (BN_ucmp((const BIGNUM *)a3[1], v14) & 0x80000000) == 0)
          {
            ERR_put_error(42, 4095, 100, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ecdsa/ecs_ossl.c", 517);
            v19 = 0;
            v20 = 0;
LABEL_24:
            BN_CTX_end(v13);
            BN_CTX_free(v13);
            EC_POINT_free(v19);
            return v20;
          }
          if (!ecdsa_prepare_digest(a1, a2, v14, v16))
            goto LABEL_22;
          if (BN_mod_inverse_ct(v15, (const BIGNUM *)a3[1], v14, v13))
          {
            if (BN_mod_mul(r, v16, v15, v14, v13))
            {
              if (BN_mod_mul(v15, (const BIGNUM *)*a3, v15, v14, v13))
              {
                v19 = EC_POINT_new(v9);
                if (v19)
                {
                  if (EC_POINT_mul(v9, v19, r, v11, v15, v13))
                  {
                    if (EC_POINT_get_affine_coordinates((uint64_t)v9, v19, (uint64_t)v18, 0, v13))
                    {
                      if (BN_nnmod(r, v18, v14, v13))
                      {
                        v20 = BN_ucmp(r, (const BIGNUM *)*a3) == 0;
                        goto LABEL_24;
                      }
                      v26 = 3;
                      v27 = 552;
                    }
                    else
                    {
                      v26 = 16;
                      v27 = 548;
                    }
                  }
                  else
                  {
                    v26 = 16;
                    v27 = 544;
                  }
                }
                else
                {
                  v26 = 65;
                  v27 = 540;
                }
                ERR_put_error(42, 4095, v26, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ecdsa/ecs_ossl.c", v27);
                goto LABEL_23;
              }
              v24 = 3;
              v25 = 534;
            }
            else
            {
              v24 = 3;
              v25 = 530;
            }
          }
          else
          {
            v24 = 3;
            v25 = 526;
          }
        }
        else
        {
          v24 = 16;
          v25 = 508;
        }
      }
      else
      {
        v24 = 3;
        v25 = 503;
      }
      ERR_put_error(42, 4095, v24, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ecdsa/ecs_ossl.c", v25);
LABEL_22:
      v19 = 0;
LABEL_23:
      v20 = 0xFFFFFFFFLL;
      goto LABEL_24;
    }
    v21 = 65;
    v22 = 493;
  }
  else
  {
    v21 = 103;
    v22 = 488;
  }
  ERR_put_error(42, 4095, v21, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ecdsa/ecs_ossl.c", v22);
  return 0xFFFFFFFFLL;
}

uint64_t ecdsa_prepare_digest(const unsigned __int8 *a1, int a2, const BIGNUM *a3, BIGNUM *ret)
{
  int v7;
  int v8;
  int v10;

  if (BN_bin2bn(a1, a2, ret))
  {
    v7 = 8 * a2;
    v8 = BN_num_bits(a3);
    if (v7 <= v8 || BN_rshift(ret, ret, v7 - v8))
      return 1;
    v10 = 110;
  }
  else
  {
    v10 = 101;
  }
  ERR_put_error(42, 4095, 3, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ecdsa/ecs_ossl.c", v10);
  return 0;
}

BOOL ecx_pub_decode(uint64_t a1, uint64_t a2)
{
  int v3;
  int v4;
  char *v5;
  char *v6;
  int v7;
  _BOOL8 v8;
  int v10;
  uint64_t v11;
  int pptype;
  X509_ALGOR *algor;

  algor = 0;
  pptype = 0;
  v11 = 0;
  v10 = 0;
  if (!X509_PUBKEY_get0_param(0, &v11, &v10, &algor, a2))
    goto LABEL_14;
  if (algor)
  {
    X509_ALGOR_get0(0, &pptype, 0, algor);
    if (pptype != -1)
    {
      v3 = 215;
LABEL_13:
      ERR_put_error(16, 4095, 102, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ecx_methods.c", v3);
LABEL_14:
      v6 = 0;
LABEL_15:
      v8 = 0;
      goto LABEL_16;
    }
  }
  if (!v11 || (v4 = **(_DWORD **)(a1 + 16), v10 != 32 * (((v4 - 950) & 0xFFFFFFFD) == 0)))
  {
    v3 = 221;
    goto LABEL_13;
  }
  v5 = (char *)ecx_key_new(v4);
  v6 = v5;
  if (!v5 || !ecx_key_set_pub((uint64_t)v5, v11, v10))
    goto LABEL_15;
  v7 = EVP_PKEY_assign((EVP_PKEY *)a1, **(_DWORD **)(a1 + 16), v6);
  v8 = v7 != 0;
  if (v7)
    v6 = 0;
LABEL_16:
  ecx_key_free(v6);
  return v8;
}

uint64_t ecx_pub_encode(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  ASN1_OBJECT *v4;
  ASN1_OBJECT *v5;
  int v6;
  void *v7;
  uint64_t v8;
  _QWORD v10[3];
  uint64_t v11;
  void *v12;

  v2 = *(_QWORD *)(a2 + 32);
  v11 = 0;
  v12 = 0;
  memset(v10, 0, sizeof(v10));
  if (!v2)
  {
    ERR_put_error(16, 4095, 165, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ecx_methods.c", 252);
LABEL_8:
    v7 = 0;
    goto LABEL_9;
  }
  if (*(_QWORD *)(v2 + 32) != *(_DWORD *)(v2 + 4))
    goto LABEL_8;
  v4 = OBJ_nid2obj(**(_DWORD **)(a2 + 16));
  if (!v4)
    goto LABEL_8;
  v5 = v4;
  CBS_init(v10, *(_QWORD *)(v2 + 24), *(_QWORD *)(v2 + 32));
  v6 = CBS_stow((uint64_t)v10, &v12, &v11);
  v7 = v12;
  if (!v6)
  {
LABEL_9:
    v8 = 0;
    goto LABEL_10;
  }
  if (X509_PUBKEY_set0_param(a1, v5, -1, 0, v12, v11))
  {
    v7 = 0;
    v11 = 0;
    v12 = 0;
    v8 = 1;
  }
  else
  {
    v8 = 0;
    v7 = v12;
  }
LABEL_10:
  free(v7);
  return v8;
}

uint64_t ecx_pub_cmp(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  unsigned __int8 *v3;
  uint64_t v4;
  unsigned __int8 *v5;
  uint64_t v6;

  v2 = *(_QWORD *)(a1 + 32);
  if (v2
    && (v3 = *(unsigned __int8 **)(v2 + 24)) != 0
    && (v4 = *(_QWORD *)(a2 + 32)) != 0
    && (v5 = *(unsigned __int8 **)(v4 + 24)) != 0
    && (v6 = *(_QWORD *)(v2 + 32), v6 == *(_QWORD *)(v4 + 32)))
  {
    return timingsafe_memcmp(v3, v5, v6) == 0;
  }
  else
  {
    return 4294967294;
  }
}

const char *ecx_pub_print(BIO *a1, uint64_t a2, int a3)
{
  uint64_t v5;
  const char *result;

  v5 = *(_QWORD *)(a2 + 32);
  result = OBJ_nid2ln(**(_DWORD **)(a2 + 16));
  if (result)
  {
    if (v5 && *(_QWORD *)(v5 + 24))
    {
      if (BIO_printf(a1, "%*s%s Public-Key:\n", a3, "", result) < 1 || BIO_printf(a1, "%*spub:\n", a3, "") < 1)
        return 0;
      else
        return (const char *)(ASN1_buf_print(a1, *(_QWORD *)(v5 + 24), *(_QWORD *)(v5 + 32), a3 + 4) != 0);
    }
    else
    {
      return (const char *)(BIO_printf(a1, "%*s<INVALID PUBLIC KEY>\n", a3, "") > 0);
    }
  }
  return result;
}

BOOL ecx_priv_decode(uint64_t a1, uint64_t a2)
{
  ASN1_OCTET_STRING *v3;
  int v4;
  char *v5;
  int v6;
  int v7;
  char *v8;
  char *v9;
  unsigned __int8 *v10;
  int v11;
  int v12;
  _BOOL8 v13;
  int len;
  unsigned __int8 *len_4;
  int pptype;
  X509_ALGOR *algor;

  algor = 0;
  pptype = 0;
  len_4 = 0;
  len = 0;
  if (!PKCS8_pkey_get0(0, &len_4, &len, &algor, a2))
  {
    v5 = 0;
    v3 = 0;
LABEL_16:
    v13 = 0;
    goto LABEL_17;
  }
  v3 = d2i_ASN1_OCTET_STRING(0, (const unsigned __int8 **)&len_4, len);
  if (!v3)
    goto LABEL_15;
  if (algor)
  {
    X509_ALGOR_get0(0, &pptype, 0, algor);
    if (pptype != -1)
    {
      v4 = 339;
LABEL_14:
      ERR_put_error(16, 4095, 102, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ecx_methods.c", v4);
      goto LABEL_15;
    }
  }
  if (!ASN1_STRING_get0_data((uint64_t)v3)
    || (v6 = ASN1_STRING_length(v3), v7 = **(_DWORD **)(a1 + 16), v6 != 32 * (((v7 - 950) & 0xFFFFFFFD) == 0)))
  {
    v4 = 346;
    goto LABEL_14;
  }
  v8 = (char *)ecx_key_new(v7);
  if (!v8)
  {
LABEL_15:
    v5 = 0;
    goto LABEL_16;
  }
  v9 = v8;
  v10 = (unsigned __int8 *)ASN1_STRING_get0_data((uint64_t)v3);
  v11 = ASN1_STRING_length(v3);
  ecx_key_set_priv((uint64_t)v9, v10, v11);
  v12 = EVP_PKEY_assign((EVP_PKEY *)a1, **(_DWORD **)(a1 + 16), v9);
  v13 = v12 != 0;
  if (v12)
    v5 = 0;
  else
    v5 = v9;
LABEL_17:
  ASN1_OCTET_STRING_free(v3);
  ecx_key_free(v5);
  return v13;
}

uint64_t ecx_priv_encode(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  ASN1_OBJECT *v4;
  ASN1_OBJECT *v5;
  ASN1_OCTET_STRING *v6;
  ASN1_OCTET_STRING *v7;
  int v8;
  unsigned __int8 *v9;
  uint64_t v10;
  unsigned __int8 *out;

  v2 = *(_QWORD *)(a2 + 32);
  out = 0;
  if (!v2 || !*(_QWORD *)(v2 + 8))
  {
    ERR_put_error(16, 4095, 123, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ecx_methods.c", 379);
    goto LABEL_10;
  }
  v4 = OBJ_nid2obj(**(_DWORD **)(a2 + 16));
  if (!v4)
  {
LABEL_10:
    v9 = 0;
    v7 = 0;
LABEL_11:
    v8 = 0;
    goto LABEL_12;
  }
  v5 = v4;
  v6 = ASN1_OCTET_STRING_new();
  v7 = v6;
  if (!v6 || !ASN1_OCTET_STRING_set(v6, *(const unsigned __int8 **)(v2 + 8), *(_DWORD *)(v2 + 16)))
  {
    v9 = 0;
    goto LABEL_11;
  }
  v8 = i2d_ASN1_OCTET_STRING(v7, &out);
  v9 = out;
  if (v8 < 0)
  {
LABEL_12:
    v10 = 0;
    goto LABEL_13;
  }
  if (PKCS8_pkey_set0(a1, v5, 0, -1, 0, out, v8))
  {
    v9 = 0;
    v8 = 0;
    out = 0;
    v10 = 1;
  }
  else
  {
    v10 = 0;
    v9 = out;
  }
LABEL_13:
  freezero(v9, v8);
  ASN1_OCTET_STRING_free(v7);
  return v10;
}

const char *ecx_priv_print(BIO *a1, uint64_t a2, int a3)
{
  uint64_t *v5;
  const char *result;

  v5 = *(uint64_t **)(a2 + 32);
  result = OBJ_nid2ln(**(_DWORD **)(a2 + 16));
  if (result)
  {
    if (v5 && v5[1])
    {
      if (BIO_printf(a1, "%*s%s Private-Key:\n", a3, "", result) < 1 || BIO_printf(a1, "%*spriv:\n", a3, "") < 1)
        return 0;
      result = (const char *)ASN1_buf_print(a1, v5[1], v5[2], a3 + 4);
      if (!(_DWORD)result)
        return result;
      if (BIO_printf(a1, "%*spub:\n", a3, "") < 1)
        return 0;
      else
        return (const char *)(ASN1_buf_print(a1, v5[3], v5[4], a3 + 4) != 0);
    }
    else
    {
      return (const char *)(BIO_printf(a1, "%*s<INVALID PRIVATE KEY>\n", a3, "") > 0);
    }
  }
  return result;
}

uint64_t ecx_size(uint64_t a1)
{
  return 32 * (((**(_DWORD **)(a1 + 16) - 950) & 0xFFFFFFFD) == 0);
}

uint64_t ecx_bits(uint64_t a1)
{
  if (((**(_DWORD **)(a1 + 16) - 950) & 0xFFFFFFFD) != 0)
    return 0;
  else
    return 253;
}

uint64_t ecx_security_bits(uint64_t a1)
{
  return (((**(_DWORD **)(a1 + 16) - 950) & 0xFFFFFFFD) == 0) << 7;
}

uint64_t ecx_param_cmp()
{
  return 1;
}

void ecx_free(uint64_t a1)
{
  ecx_key_free(*(void **)(a1 + 32));
}

uint64_t ecx_ctrl()
{
  return 4294967294;
}

BOOL ecx_set_priv_key(uint64_t a1, unsigned __int8 *a2, size_t a3)
{
  int v5;
  char *v7;
  char *v8;
  int v9;
  _BOOL8 v10;

  if (!a2 || (v5 = **(_DWORD **)(a1 + 16), a3 != 32 * (((v5 - 950) & 0xFFFFFFFD) == 0)))
  {
    ERR_put_error(16, 4095, 102, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ecx_methods.c", 518);
    v7 = 0;
    goto LABEL_8;
  }
  v7 = (char *)ecx_key_new(v5);
  if (!v7)
  {
LABEL_8:
    v10 = 0;
    goto LABEL_9;
  }
  v8 = v7;
  ecx_key_set_priv((uint64_t)v7, a2, a3);
  v9 = EVP_PKEY_assign((EVP_PKEY *)a1, **(_DWORD **)(a1 + 16), v8);
  v10 = v9 != 0;
  if (v9)
    v7 = 0;
  else
    v7 = v8;
LABEL_9:
  ecx_key_free(v7);
  return v10;
}

BOOL ecx_set_pub_key(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v5;
  char *v7;
  char *v8;
  int v9;
  _BOOL8 v10;

  if (!a2 || (v5 = **(_DWORD **)(a1 + 16), a3 != 32 * (((v5 - 950) & 0xFFFFFFFD) == 0)))
  {
    ERR_put_error(16, 4095, 102, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ecx_methods.c", 545);
    v8 = 0;
LABEL_9:
    v10 = 0;
    goto LABEL_10;
  }
  v7 = (char *)ecx_key_new(v5);
  v8 = v7;
  if (!v7 || !ecx_key_set_pub((uint64_t)v7, a2, a3))
    goto LABEL_9;
  v9 = EVP_PKEY_assign((EVP_PKEY *)a1, **(_DWORD **)(a1 + 16), v8);
  v10 = v9 != 0;
  if (v9)
    v8 = 0;
LABEL_10:
  ecx_key_free(v8);
  return v10;
}

BOOL ecx_get_priv_key(uint64_t a1, void *a2, size_t *a3)
{
  uint64_t v4;
  uint64_t v6;
  _QWORD v8[3];

  v4 = *(_QWORD *)(a1 + 32);
  memset(v8, 0, sizeof(v8));
  if (a2)
  {
    if (v4 && (v6 = *(_QWORD *)(v4 + 8)) != 0)
    {
      CBS_init(v8, v6, *(_QWORD *)(v4 + 16));
      return CBS_write_bytes((uint64_t)v8, a2, *a3, a3) != 0;
    }
    else
    {
      return 0;
    }
  }
  else
  {
    *a3 = 32 * (((**(_DWORD **)(a1 + 16) - 950) & 0xFFFFFFFD) == 0);
    return 1;
  }
}

BOOL ecx_get_pub_key(uint64_t a1, void *a2, size_t *a3)
{
  uint64_t v4;
  uint64_t v6;
  _QWORD v8[3];

  v4 = *(_QWORD *)(a1 + 32);
  memset(v8, 0, sizeof(v8));
  if (a2)
  {
    if (v4 && (v6 = *(_QWORD *)(v4 + 24)) != 0)
    {
      CBS_init(v8, v6, *(_QWORD *)(v4 + 32));
      return CBS_write_bytes((uint64_t)v8, a2, *a3, a3) != 0;
    }
    else
    {
      return 0;
    }
  }
  else
  {
    *a3 = 32 * (((**(_DWORD **)(a1 + 16) - 950) & 0xFFFFFFFD) == 0);
    return 1;
  }
}

BOOL pkey_ecx_keygen(int **a1, EVP_PKEY *a2)
{
  _DWORD *v4;
  _DWORD *v5;
  void *v6;
  _BYTE *v7;
  _BOOL8 v8;
  size_t v10;
  int v11;

  v4 = ecx_key_new(**a1);
  v5 = v4;
  if (!v4)
    goto LABEL_9;
  ecx_key_clear((uint64_t)v4);
  v6 = malloc_type_calloc(1uLL, (int)v5[1], 0x3DB11B7DuLL);
  if (!v6)
  {
    v7 = 0;
    goto LABEL_8;
  }
  v7 = malloc_type_calloc(1uLL, (int)v5[1], 0xD6AAD79EuLL);
  if (!v7)
  {
LABEL_8:
    freezero(v6, (int)v5[1]);
    freezero(v7, (int)v5[1]);
LABEL_9:
    v8 = 0;
    goto LABEL_10;
  }
  if (*v5 != 950)
  {
    if (*v5 == 952)
    {
      ED25519_keypair((uint64_t)v6, v7);
      goto LABEL_12;
    }
    goto LABEL_8;
  }
  X25519_keypair((uint64_t)v6, v7);
LABEL_12:
  v10 = (int)v5[1];
  *((_QWORD *)v5 + 1) = v7;
  *((_QWORD *)v5 + 2) = v10;
  *((_QWORD *)v5 + 3) = v6;
  *((_QWORD *)v5 + 4) = v10;
  freezero(0, v10);
  freezero(0, (int)v5[1]);
  v11 = EVP_PKEY_assign(a2, **a1, (char *)v5);
  v8 = v11 != 0;
  if (v11)
    v5 = 0;
LABEL_10:
  ecx_key_free(v5);
  return v8;
}

BOOL pkey_ecx_derive(uint64_t a1, unsigned __int8 *a2, _QWORD *a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  _BOOL8 result;
  int v10;
  int v11;

  v3 = *(_QWORD *)(a1 + 16);
  if (!v3 || (v4 = *(_QWORD *)(a1 + 24)) == 0)
  {
    v10 = 140;
    v11 = 636;
LABEL_10:
    ERR_put_error(16, 4095, v10, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ecx_methods.c", v11);
    return 0;
  }
  v5 = *(_QWORD *)(v3 + 32);
  if (!v5)
  {
    v10 = 123;
    v11 = 641;
    goto LABEL_10;
  }
  v6 = *(_QWORD *)(v5 + 8);
  if (!v6)
  {
    v10 = 123;
    v11 = 645;
    goto LABEL_10;
  }
  v7 = *(_QWORD *)(v4 + 32);
  if (!v7)
  {
    v10 = 152;
    v11 = 650;
    goto LABEL_10;
  }
  if (!a2 || (result = X25519(a2, v6, *(_QWORD *)(v7 + 24))))
  {
    *a3 = 32;
    return 1;
  }
  return result;
}

uint64_t pkey_ecx_ctrl(uint64_t a1, int a2)
{
  if (a2 == 2)
    return 1;
  else
    return 4294967294;
}

uint64_t ecx_sig_size(uint64_t a1)
{
  return (**(_DWORD **)(a1 + 16) == 952) << 6;
}

uint64_t ecx_sign_ctrl(uint64_t a1, int a2, uint64_t a3, _DWORD *a4)
{
  if (a2 != 3)
    return 4294967294;
  *a4 = 0;
  return 2;
}

uint64_t ecx_item_verify(uint64_t a1, uint64_t a2, uint64_t a3, X509_ALGOR *a4, uint64_t a5, uint64_t a6)
{
  int pptype;
  ASN1_OBJECT *paobj;

  paobj = 0;
  pptype = 0;
  X509_ALGOR_get0(&paobj, &pptype, 0, a4);
  if (OBJ_obj2nid(paobj) == 952 && pptype == -1)
    return 2 * (EVP_DigestVerifyInit(a1, 0, 0, 0, a6) != 0);
  ERR_put_error(16, 4095, 102, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ecx_methods.c", 685);
  return 0;
}

ASN1_OBJECT *ecx_item_sign(uint64_t a1, uint64_t a2, uint64_t a3, X509_ALGOR *a4, X509_ALGOR *a5)
{
  ASN1_OBJECT *result;
  ASN1_OBJECT *v8;

  result = OBJ_nid2obj(952);
  if (result)
  {
    v8 = result;
    result = (ASN1_OBJECT *)X509_ALGOR_set0(a4, result, -1, 0);
    if ((_DWORD)result)
    {
      if (!a5)
        return (ASN1_OBJECT *)3;
      result = (ASN1_OBJECT *)X509_ALGOR_set0(a5, v8, -1, 0);
      if ((_DWORD)result)
        return (ASN1_OBJECT *)3;
    }
  }
  return result;
}

uint64_t pkey_ecx_ed_ctrl(uint64_t a1, int a2, uint64_t a3, const EVP_MD *a4)
{
  if (a2 == 7)
    return 1;
  if (a2 != 1)
    return 4294967294;
  if (!a4 || EVP_md_null() == a4)
    return 1;
  ERR_put_error(16, 4095, 138, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ecx_methods.c", 774);
  return 0;
}

uint64_t pkey_ecx_digestsign(uint64_t a1, _BYTE *a2, _QWORD *a3, const void *a4, size_t a5)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _DWORD *v13;
  uint64_t result;
  unsigned __int8 *v15;
  const void *v16;

  v9 = EVP_MD_CTX_pkey_ctx(a1);
  v10 = *(_QWORD *)(v9 + 16);
  if (!a2)
  {
    v13 = *(_DWORD **)(v10 + 16);
    goto LABEL_6;
  }
  v11 = v9;
  v12 = *(_QWORD *)(v10 + 32);
  if (**(_DWORD **)(v10 + 16) != 952 || *a3 > 0x3FuLL)
  {
    if (!v12)
      return 0;
    v15 = *(unsigned __int8 **)(v12 + 8);
    if (!v15)
      return 0;
    v16 = *(const void **)(v12 + 24);
    if (!v16)
      return 0;
    result = ED25519_sign(a2, a4, a5, v16, v15);
    if (!(_DWORD)result)
      return result;
    v13 = *(_DWORD **)(*(_QWORD *)(v11 + 16) + 16);
LABEL_6:
    *a3 = (unint64_t)(*v13 == 952) << 6;
    return 1;
  }
  ERR_put_error(16, 4095, 100, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ecx_methods.c", 731);
  return 0;
}

BOOL pkey_ecx_digestverify(uint64_t a1, unsigned __int8 *a2, uint64_t a3, const void *a4, size_t a5)
{
  uint64_t v9;
  uint64_t v10;
  const void *v11;

  v9 = *(_QWORD *)(EVP_MD_CTX_pkey_ctx(a1) + 16);
  v10 = *(_QWORD *)(v9 + 32);
  return v10
      && (v11 = *(const void **)(v10 + 24)) != 0
      && a3 == (unint64_t)(**(_DWORD **)(v9 + 16) == 952) << 6
      && ED25519_verify(a4, a5, a2, v11);
}

_DWORD *ecx_key_new(int a1)
{
  _DWORD *result;

  if (((a1 - 950) & 0xFFFFFFFD) != 0)
    return 0;
  result = malloc_type_calloc(1uLL, 0x28uLL, 0x101004019361378uLL);
  if (result)
  {
    *result = a1;
    result[1] = 32;
  }
  return result;
}

BOOL ecx_key_set_pub(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD v7[3];

  ecx_key_clear(a1);
  if (*(_DWORD *)(a1 + 4) != a3)
    return 0;
  memset(v7, 0, sizeof(v7));
  CBS_init(v7, a2, a3);
  return CBS_stow((uint64_t)v7, (void **)(a1 + 24), (_QWORD *)(a1 + 32)) != 0;
}

void ecx_key_free(void *a1)
{
  if (a1)
  {
    ecx_key_clear((uint64_t)a1);
    freezero(a1, 0x28uLL);
  }
}

void ecx_key_clear(uint64_t a1)
{
  freezero(*(void **)(a1 + 8), *(_QWORD *)(a1 + 16));
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  freezero(*(void **)(a1 + 24), *(_QWORD *)(a1 + 32));
  *(_QWORD *)(a1 + 24) = 0;
  *(_QWORD *)(a1 + 32) = 0;
}

void ecx_key_set_priv(uint64_t a1, unsigned __int8 *a2, size_t a3)
{
  void *v6;
  void *v7;
  uint64_t v8;
  _QWORD v9[3];

  memset(v9, 0, sizeof(v9));
  ecx_key_clear(a1);
  v6 = 0;
  if (*(_DWORD *)(a1 + 4) == a3)
  {
    v7 = malloc_type_calloc(1uLL, a3, 0xA5D9D1B3uLL);
    v6 = v7;
    if (v7)
    {
      if (*(_DWORD *)a1 == 950)
      {
        X25519_public_from_private((uint64_t)v7, (uint64_t)a2);
      }
      else
      {
        if (*(_DWORD *)a1 != 952)
          goto LABEL_9;
        ED25519_public_from_private((uint64_t)v7, a2);
      }
      CBS_init(v9, (uint64_t)a2, a3);
      if (CBS_stow((uint64_t)v9, (void **)(a1 + 8), (_QWORD *)(a1 + 16)))
      {
        v8 = *(int *)(a1 + 4);
        *(_QWORD *)(a1 + 24) = v6;
        *(_QWORD *)(a1 + 32) = v8;
        v6 = 0;
      }
    }
  }
LABEL_9:
  freezero(v6, *(int *)(a1 + 4));
}

int X509V3_add_value(const char *name, const char *value, STACK **extlist)
{
  CONF_VALUE *v6;
  char *v7;
  char *v8;
  STACK *v9;
  STACK *v10;
  int result;

  v6 = (CONF_VALUE *)malloc_type_calloc(1uLL, 0x18uLL, 0x100402FEFCB83uLL);
  if (!v6
    || name && (v7 = strdup(name), (v6->name = v7) == 0)
    || value && (v8 = strdup(value), (v6->value = v8) == 0))
  {
    v10 = 0;
    goto LABEL_9;
  }
  v9 = *extlist;
  if (*extlist)
  {
    v10 = 0;
  }
  else
  {
    v9 = sk_new_null();
    *extlist = v9;
    v10 = v9;
    if (!v9)
      goto LABEL_9;
  }
  if (sk_push(v9, (char *)v6))
    return 1;
LABEL_9:
  ERR_put_error(34, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_utl.c", 115);
  X509V3_conf_free(v6);
  if (!v10)
    return 0;
  sk_free(*extlist);
  result = 0;
  *extlist = 0;
  return result;
}

void X509V3_conf_free(CONF_VALUE *val)
{
  if (val)
  {
    free(val->name);
    free(val->value);
    free(val->section);
    free(val);
  }
}

int X509V3_add_value_BOOL(const char *name, int asn1_BOOL, STACK **extlist)
{
  const char *v3;

  if (asn1_BOOL)
    v3 = "TRUE";
  else
    v3 = "FALSE";
  return X509V3_add_value(name, v3, extlist);
}

int X509V3_add_value_BOOL_nf(char *name, int asn1_BOOL, STACK **extlist)
{
  if (asn1_BOOL)
    return X509V3_add_value(name, "TRUE", extlist);
  else
    return 1;
}

char *__cdecl i2s_ASN1_ENUMERATED(X509V3_EXT_METHOD *meth, ASN1_ENUMERATED *aint)
{
  BIGNUM *v2;
  BIGNUM *v3;
  char *v4;

  if (!aint)
    return 0;
  v2 = ASN1_ENUMERATED_to_BN(aint, 0);
  v3 = v2;
  if (!v2 || (v4 = bn_to_string(v2)) == 0)
  {
    ERR_put_error(34, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_utl.c", 204);
    v4 = 0;
  }
  BN_free(v3);
  return v4;
}

char *bn_to_string(const BIGNUM *a1)
{
  char *v3;
  _BOOL4 is_negative;
  const char *v5;
  const char *v6;
  char *v7;
  char *v8;

  v8 = 0;
  if (BN_num_bits(a1) <= 127)
    return BN_bn2dec(a1);
  v3 = BN_bn2hex(a1);
  if (v3)
  {
    is_negative = BN_is_negative((uint64_t)a1);
    v5 = "";
    if (is_negative)
    {
      v5 = "-";
      v6 = v3 + 1;
    }
    else
    {
      v6 = v3;
    }
    if (asprintf(&v8, "%s0x%s", v5, v6) == -1)
      v7 = 0;
    else
      v7 = v8;
  }
  else
  {
    v7 = 0;
  }
  free(v3);
  return v7;
}

char *__cdecl i2s_ASN1_ENUMERATED_TABLE(X509V3_EXT_METHOD *meth, ASN1_ENUMERATED *aint)
{
  X509V3_EXT_METHOD *v4;
  char *usr_data;
  const char *v6;
  const char **i;
  X509V3_EXT_METHOD *v8;

  v4 = (X509V3_EXT_METHOD *)ASN1_ENUMERATED_get(aint);
  usr_data = (char *)meth->usr_data;
  v6 = (const char *)*((_QWORD *)usr_data + 1);
  if (v6)
  {
    if (v4 == (X509V3_EXT_METHOD *)*(int *)usr_data)
      return strdup(v6);
    for (i = (const char **)(usr_data + 32); ; i += 3)
    {
      v6 = *i;
      if (!*i)
        break;
      v8 = (X509V3_EXT_METHOD *)*((int *)i - 2);
      if (v4 == v8)
        return strdup(v6);
    }
  }
  return i2s_ASN1_ENUMERATED(v4, aint);
}

char *__cdecl i2s_ASN1_INTEGER(X509V3_EXT_METHOD *meth, ASN1_INTEGER *aint)
{
  BIGNUM *v2;
  BIGNUM *v3;
  char *v4;

  if (!aint)
    return 0;
  v2 = ASN1_INTEGER_to_BN(aint, 0);
  v3 = v2;
  if (!v2 || (v4 = bn_to_string(v2)) == 0)
  {
    ERR_put_error(34, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_utl.c", 235);
    v4 = 0;
  }
  BN_free(v3);
  return v4;
}

ASN1_INTEGER *__cdecl s2i_ASN1_INTEGER(X509V3_EXT_METHOD *meth, char *value)
{
  ASN1_INTEGER *v2;
  int length_low;
  int v4;
  int v5;
  int v6;
  int v7;
  int v8;
  _BOOL4 is_zero;
  BIGNUM *a;

  v2 = (ASN1_INTEGER *)value;
  if (!value)
  {
    v5 = 109;
    v6 = 250;
LABEL_10:
    ERR_put_error(34, 4095, v5, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_utl.c", v6);
    return v2;
  }
  a = BN_new();
  if (!a)
  {
    v7 = 65;
    v8 = 254;
    goto LABEL_15;
  }
  length_low = LOBYTE(v2->length);
  if (length_low == 45)
    v2 = (ASN1_INTEGER *)((char *)v2 + 1);
  if (LOBYTE(v2->length) == 48 && (BYTE1(v2->length) | 0x20) == 0x78)
  {
    v2 = (ASN1_INTEGER *)((char *)v2 + 2);
    v4 = BN_hex2bn(&a, (const char *)v2);
    if (!v4)
      goto LABEL_13;
  }
  else
  {
    v4 = BN_dec2bn(&a, (const char *)v2);
    if (!v4)
    {
LABEL_13:
      BN_free(a);
      v7 = 100;
      v8 = 274;
LABEL_15:
      ERR_put_error(34, 4095, v7, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_utl.c", v8);
      return 0;
    }
  }
  if (*((_BYTE *)&v2->length + v4))
    goto LABEL_13;
  is_zero = BN_is_zero((uint64_t)a);
  v2 = BN_to_ASN1_INTEGER(a, 0);
  BN_free(a);
  if (!v2)
  {
    v5 = 101;
    v6 = 284;
    goto LABEL_10;
  }
  if (length_low == 45 && !is_zero)
    v2->type |= 0x100u;
  return v2;
}

int X509V3_add_value_int(const char *name, ASN1_INTEGER *aint, STACK **extlist)
{
  char *v5;
  char *v6;
  int v7;

  if (aint)
  {
    v5 = i2s_ASN1_INTEGER((X509V3_EXT_METHOD *)name, aint);
    if (v5)
    {
      v6 = v5;
      v7 = X509V3_add_value(name, v5, extlist);
      free(v6);
      LODWORD(v5) = v7;
    }
  }
  else
  {
    LODWORD(v5) = 1;
  }
  return (int)v5;
}

int X509V3_get_value_BOOL(CONF_VALUE *value, int *asn1_BOOL)
{
  char *v3;

  v3 = value->value;
  if (!v3)
    goto LABEL_14;
  if (!strcmp(value->value, "TRUE")
    || !strcmp(v3, "true")
    || !strcmp(v3, "Y")
    || !strcmp(v3, "y")
    || !strcmp(v3, "YES")
    || !strcmp(v3, "yes"))
  {
    *asn1_BOOL = 255;
  }
  else
  {
    if (strcmp(v3, "FALSE")
      && strcmp(v3, "false")
      && strcmp(v3, "N")
      && strcmp(v3, "n")
      && strcmp(v3, "NO")
      && strcmp(v3, "no"))
    {
LABEL_14:
      ERR_put_error(34, 4095, 104, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_utl.c", 330);
      ERR_asprintf_error_data("section:%s,name:%s,value:%s", value->section, value->name, value->value);
      return 0;
    }
    *asn1_BOOL = 0;
  }
  return 1;
}

int X509V3_get_value_int(CONF_VALUE *value, ASN1_INTEGER **aint)
{
  ASN1_INTEGER *v4;

  v4 = s2i_ASN1_INTEGER((X509V3_EXT_METHOD *)value, value->value);
  if (v4)
  {
    *aint = v4;
    return 1;
  }
  else
  {
    ERR_asprintf_error_data("section:%s,name:%s,value:%s", value->section, value->name, value->value);
    return 0;
  }
}

STACK *__cdecl X509V3_parse_list(const char *line)
{
  char *v1;
  char *v2;
  const char *v3;
  char *v4;
  char *v5;
  int v6;
  unsigned int v7;
  char *v9;
  char *v10;
  char *v11;
  char *v12;
  const char *v13;
  int v14;
  int v15;
  STACK *extlist;

  extlist = 0;
  v1 = strdup(line);
  v2 = v1;
  if (!v1)
  {
    v14 = 65;
    v15 = 366;
    goto LABEL_33;
  }
  v3 = 0;
  v4 = v1 + 1;
  v5 = v1;
  v6 = 1;
  while (1)
  {
    v7 = *(v4 - 1);
    if (v7 <= 0xD && ((1 << v7) & 0x2401) != 0)
      break;
    if (v6 == 2)
    {
      if (v7 == 44)
      {
        *(v4 - 1) = 0;
        v10 = strip_spaces(v1);
        if (!v10)
        {
          v14 = 109;
          v15 = 405;
          goto LABEL_33;
        }
        X509V3_add_value(v3, v10, &extlist);
        v3 = 0;
        v1 = v5 + 1;
LABEL_16:
        v6 = 1;
        goto LABEL_20;
      }
      goto LABEL_17;
    }
    if (v7 != 44)
    {
      if (v7 != 58)
        goto LABEL_16;
      *(v4 - 1) = 0;
      v9 = strip_spaces(v1);
      if (!v9)
      {
        v14 = 108;
        v15 = 383;
        goto LABEL_33;
      }
      v3 = v9;
      v1 = v5 + 1;
LABEL_17:
      v6 = 2;
      goto LABEL_20;
    }
    *(v4 - 1) = 0;
    v11 = strip_spaces(v1);
    if (!v11)
    {
      v14 = 108;
      v15 = 392;
      goto LABEL_33;
    }
    v3 = v11;
    X509V3_add_value(v11, 0, &extlist);
    v6 = 1;
    v1 = v4;
LABEL_20:
    ++v5;
    ++v4;
  }
  v12 = strip_spaces(v1);
  v13 = v12;
  if (v6 == 2)
  {
    if (v12)
    {
      v12 = (char *)v3;
LABEL_27:
      X509V3_add_value(v12, v13, &extlist);
      free(v2);
      return extlist;
    }
    v14 = 109;
    v15 = 419;
  }
  else
  {
    if (v12)
    {
      v13 = 0;
      goto LABEL_27;
    }
    v14 = 108;
    v15 = 426;
  }
LABEL_33:
  ERR_put_error(34, 4095, v14, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_utl.c", v15);
  free(v2);
  sk_pop_free(extlist, (void (__cdecl *)(void *))X509V3_conf_free);
  return 0;
}

char *strip_spaces(char *__s)
{
  char *v1;
  unsigned int v2;
  uint64_t v3;
  unsigned int v4;
  size_t v5;
  size_t v6;
  int v7;
  uint64_t v8;
  int v9;

  v1 = __s;
  v2 = *__s;
  if (!v2)
    return 0;
  v3 = MEMORY[0x24BDAC740];
  while ((v2 & 0x80) == 0)
  {
    if ((*(_DWORD *)(v3 + 4 * v2 + 60) & 0x4000) == 0)
      goto LABEL_9;
LABEL_7:
    v4 = *++v1;
    v2 = v4;
    if (!v4)
      return 0;
  }
  if (__maskrune(v2, 0x4000uLL))
    goto LABEL_7;
LABEL_9:
  if (!*v1)
    return 0;
  v5 = strlen(v1);
  while (1)
  {
    v6 = v5 - 1;
    if (v5 == 1)
      break;
    v7 = v1[v5 - 1];
    v8 = v1[v5 - 1];
    if (v7 < 0)
      v9 = __maskrune(v8, 0x4000uLL);
    else
      v9 = *(_DWORD *)(v3 + 4 * v8 + 60) & 0x4000;
    v5 = v6;
    if (!v9)
    {
      v1[v6 + 1] = 0;
      break;
    }
  }
  if (*v1)
    return v1;
  else
    return 0;
}

char *__cdecl hex_to_string(unsigned __int8 *buffer, uint64_t len)
{
  int v4;
  uint64_t v6;
  unsigned __int8 v7;
  char *v8;
  _QWORD v9[3];
  _OWORD v10[2];

  memset(v10, 0, sizeof(v10));
  memset(v9, 0, sizeof(v9));
  v8 = 0;
  v7 = 0;
  v6 = 0;
  v4 = CBB_init((uint64_t)v10, 0);
  if ((len & 0x8000000000000000) == 0 && v4)
  {
    CBS_init(v9, (uint64_t)buffer, len);
    if (CBS_len((uint64_t)v9))
    {
      while (CBS_get_u8(v9, &v7)
           && CBB_add_u8((char **)v10, hex_digits_0[(unint64_t)v7 >> 4])
           && CBB_add_u8((char **)v10, hex_digits_0[v7 & 0xF])
           && (!CBS_len((uint64_t)v9) || CBB_add_u8((char **)v10, 0x3AuLL)))
      {
        if (!CBS_len((uint64_t)v9))
          goto LABEL_10;
      }
    }
    else
    {
LABEL_10:
      if (CBB_add_u8((char **)v10, 0))
        CBB_finish((uint64_t *)v10, &v8, &v6);
    }
  }
  CBB_cleanup((uint64_t *)v10);
  return v8;
}

unsigned __int8 *__cdecl string_to_hex(char *str, uint64_t *len)
{
  size_t v4;
  int v5;
  int v6;
  __int16 v8;
  size_t v9;
  void *v10;
  _QWORD v11[3];
  _OWORD v12[2];
  char v13;

  memset(v12, 0, sizeof(v12));
  memset(v11, 0, sizeof(v11));
  v9 = 0;
  v10 = 0;
  v8 = 0;
  *len = 0;
  if (CBB_init((uint64_t)v12, 0))
  {
    if (str)
    {
      v4 = strlen(str);
      CBS_init(v11, (uint64_t)str, v4);
      while (CBS_len((uint64_t)v11))
      {
        v13 = 0;
        while (CBS_len((uint64_t)v11))
        {
          if (!CBS_peek_u8((uint64_t)v11, &v13))
            goto LABEL_19;
          if (v13 != 58)
            break;
          if (!CBS_get_u8(v11, &v13))
            goto LABEL_19;
        }
        if (!CBS_len((uint64_t)v11))
          break;
        if (!x509_get_xdigit_nibble_cbs(v11, (_BYTE *)&v8 + 1))
          goto LABEL_19;
        if (!CBS_len((uint64_t)v11))
        {
          v5 = 112;
          v6 = 583;
          goto LABEL_18;
        }
        if (!x509_get_xdigit_nibble_cbs(v11, &v8)
          || !CBB_add_u8((char **)v12, v8 | (16 * HIBYTE(v8))))
        {
          goto LABEL_19;
        }
      }
      if (CBB_finish((uint64_t *)v12, &v10, &v9))
      {
        if ((v9 & 0x8000000000000000) != 0)
        {
          freezero(v10, v9);
          v10 = 0;
        }
        else
        {
          *len = v9;
        }
      }
    }
    else
    {
      v5 = 107;
      v6 = 565;
LABEL_18:
      ERR_put_error(34, 4095, v5, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_utl.c", v6);
    }
  }
LABEL_19:
  CBB_cleanup((uint64_t *)v12);
  return (unsigned __int8 *)v10;
}

uint64_t x509_get_xdigit_nibble_cbs(_QWORD *a1, _BYTE *a2)
{
  uint64_t result;
  unsigned int v4;
  char v5;
  unsigned __int8 v6;

  v6 = 0;
  result = CBS_get_u8(a1, &v6);
  if ((_DWORD)result)
  {
    v4 = v6 - 48;
    if (v4 > 9)
    {
      if (v6 - 97 > 5)
      {
        if (v6 - 65 > 5)
        {
          ERR_put_error(34, 4095, 113, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_utl.c", 546);
          return 0;
        }
        v5 = v6 - 55;
      }
      else
      {
        v5 = v6 - 87;
      }
      *a2 = v5;
    }
    else
    {
      *a2 = v4;
    }
    return 1;
  }
  return result;
}

int name_cmp(const char *name, const char *cmp)
{
  size_t v4;
  int result;
  int v6;

  v4 = (int)strlen(cmp);
  result = strncmp(name, cmp, v4);
  if (!result)
  {
    v6 = name[v4];
    return v6 != 46 && v6 != 0;
  }
  return result;
}

STACK *__cdecl X509_get1_email(X509 *x)
{
  STACK *ext_d2i;
  X509_NAME *subject_name;
  STACK *email;

  ext_d2i = (STACK *)X509_get_ext_d2i(x, 85, 0, 0);
  subject_name = X509_get_subject_name(x);
  email = get_email(subject_name, ext_d2i);
  sk_pop_free(ext_d2i, (void (__cdecl *)(void *))GENERAL_NAME_free);
  return email;
}

STACK *get_email(X509_NAME *name, const STACK *a2)
{
  int v4;
  int index_by_NID;
  X509_NAME_ENTRY *entry;
  ASN1_STRING *data;
  int v9;
  char *v10;
  STACK *v11;

  v11 = 0;
  v4 = -1;
  while (1)
  {
    index_by_NID = X509_NAME_get_index_by_NID(name, 48, v4);
    if (index_by_NID < 0)
      break;
    v4 = index_by_NID;
    entry = X509_NAME_get_entry(name, index_by_NID);
    data = X509_NAME_ENTRY_get_data(entry);
    if (!append_ia5(&v11, (uint64_t)data))
      return 0;
  }
  if (sk_num(a2) >= 1)
  {
    v9 = 0;
    while (1)
    {
      v10 = sk_value(a2, v9);
      if (*(_DWORD *)v10 == 1 && !append_ia5(&v11, *((_QWORD *)v10 + 1)))
        break;
      if (++v9 >= sk_num(a2))
        return v11;
    }
    return 0;
  }
  return v11;
}

STACK *__cdecl X509_get1_ocsp(X509 *x)
{
  const STACK *ext_d2i;
  AUTHORITY_INFO_ACCESS *v2;
  int v3;
  char *v4;
  uint64_t v5;
  STACK *v6;
  STACK *v8;

  v8 = 0;
  ext_d2i = (const STACK *)X509_get_ext_d2i(x, 177, 0, 0);
  if (!ext_d2i)
    return 0;
  v2 = (AUTHORITY_INFO_ACCESS *)ext_d2i;
  if (sk_num(ext_d2i) < 1)
  {
    v6 = 0;
  }
  else
  {
    v3 = 0;
    do
    {
      v4 = sk_value(v2, v3);
      if (OBJ_obj2nid(*(const ASN1_OBJECT **)v4) == 178)
      {
        v5 = *((_QWORD *)v4 + 1);
        if (*(_DWORD *)v5 == 6 && !append_ia5(&v8, *(_QWORD *)(v5 + 8)))
          break;
      }
      ++v3;
    }
    while (v3 < sk_num(v2));
    v6 = v8;
  }
  AUTHORITY_INFO_ACCESS_free(v2);
  return v6;
}

STACK *append_ia5(STACK **a1, uint64_t a2)
{
  char *v3;
  STACK *result;
  char *v6;

  if (*(_DWORD *)(a2 + 4) == 22)
  {
    v3 = *(char **)(a2 + 8);
    if (v3)
    {
      if (*(_DWORD *)a2)
      {
        result = *a1;
        if (!result)
        {
          result = sk_new((int (__cdecl *)(const char *const *, const char *const *))sk_strcmp);
          *a1 = result;
          if (!result)
            return result;
          v3 = *(char **)(a2 + 8);
        }
        if (sk_find(result, v3) == -1)
        {
          v6 = strdup(*(const char **)(a2 + 8));
          if (!v6 || !sk_push(*a1, v6))
          {
            sk_pop_free(*a1, str_free_0);
            result = 0;
            *a1 = 0;
            return result;
          }
        }
      }
    }
  }
  return (STACK *)1;
}

STACK *__cdecl X509_REQ_get1_email(X509_REQ *x)
{
  STACK *extensions;
  STACK *d2i;
  X509_NAME *subject_name;
  STACK *email;

  extensions = X509_REQ_get_extensions(x);
  d2i = (STACK *)X509V3_get_d2i(extensions, 85, 0, 0);
  subject_name = (X509_NAME *)X509_REQ_get_subject_name((uint64_t)x);
  email = get_email(subject_name, d2i);
  sk_pop_free(d2i, (void (__cdecl *)(void *))GENERAL_NAME_free);
  sk_pop_free(extensions, (void (__cdecl *)(void *))X509_EXTENSION_free);
  return email;
}

void X509_email_free(STACK *sk)
{
  sk_pop_free(sk, str_free_0);
}

uint64_t X509_check_host(X509 *a1, char *__s, size_t __n, int a4, char **a5)
{
  size_t v7;

  if (!__s)
    return 4294967294;
  v7 = __n;
  if (__n)
  {
    if (memchr(__s, 0, __n))
      return 4294967294;
  }
  else
  {
    v7 = strlen(__s);
  }
  return do_x509_check(a1, __s, v7, a4, 2, a5);
}

uint64_t do_x509_check(X509 *x, _BYTE *a2, size_t a3, int a4, int a5, char **a6)
{
  X509 *v10;
  uint64_t v11;
  char v12;
  int v13;
  uint64_t (*v14)(void);
  GENERAL_NAMES *ext_d2i;
  int v16;
  GENERAL_NAMES *v17;
  int v18;
  GENERAL_NAMES *v19;
  int v20;
  unint64_t i;
  char *v22;
  uint64_t v23;
  uint64_t result;
  X509_NAME *subject_name;
  int v26;
  int index_by_NID;
  X509_NAME_ENTRY *entry;
  ASN1_STRING *data;
  uint64_t v30;
  X509 *v31;
  int v32;

  v10 = x;
  v11 = a4 & 0xFFFF7FFF;
  if (a5 == 1)
  {
    ext_d2i = (GENERAL_NAMES *)X509_get_ext_d2i(x, 85, 0, 0);
    v32 = 48;
    v14 = (uint64_t (*)(void))equal_email;
    if (!ext_d2i)
    {
      v16 = 48;
      goto LABEL_29;
    }
LABEL_15:
    v17 = ext_d2i;
    v18 = 22;
    goto LABEL_18;
  }
  if (a5 == 2)
  {
    v12 = a4;
    if ((a4 & 0x20) != 0)
      v13 = 0;
    else
      v13 = 13;
    v32 = v13;
    if (a3 >= 2)
      v11 = v11 | ((*a2 == 46) << 15);
    if ((v11 & 2) != 0)
      v14 = (uint64_t (*)(void))equal_nocase;
    else
      v14 = (uint64_t (*)(void))equal_wildcard;
    ext_d2i = (GENERAL_NAMES *)X509_get_ext_d2i(x, 85, 0, 0);
    if (!ext_d2i)
    {
      v16 = v32;
      if ((v12 & 0x20) == 0)
      {
LABEL_29:
        subject_name = X509_get_subject_name(v10);
        v26 = -1;
        while (1)
        {
          index_by_NID = X509_NAME_get_index_by_NID(subject_name, v16, v26);
          if (index_by_NID < 0)
            break;
          v26 = index_by_NID;
          entry = X509_NAME_get_entry(subject_name, index_by_NID);
          if (!entry)
            return 0xFFFFFFFFLL;
          data = X509_NAME_ENTRY_get_data(entry);
          if (!data)
            return 0xFFFFFFFFLL;
          result = do_check_string(data, -1, v14, v11, a2, a3, a6);
          if ((_DWORD)result)
            return result;
        }
      }
      return 0;
    }
    goto LABEL_15;
  }
  v19 = (GENERAL_NAMES *)X509_get_ext_d2i(x, 85, 0, 0);
  v32 = 0;
  if (v19)
  {
    v17 = v19;
    v18 = 4;
    v14 = (uint64_t (*)(void))equal_case;
LABEL_18:
    v31 = v10;
    v20 = 0;
    if (sk_num(v17))
    {
      for (i = 0; i < sk_num(v17); ++i)
      {
        v22 = sk_value(v17, i);
        if (*(_DWORD *)v22 == a5)
        {
          v23 = do_check_string(*((ASN1_STRING **)v22 + 1), v18, v14, v11, a2, a3, a6);
          if ((_DWORD)v23)
          {
            v30 = v23;
            GENERAL_NAMES_free(v17);
            return v30;
          }
          v20 = 1;
        }
      }
    }
    GENERAL_NAMES_free(v17);
    v16 = v32;
    v10 = v31;
    if (v32 && ((v11 & 1) != 0 || !v20))
      goto LABEL_29;
    return 0;
  }
  return 0;
}

uint64_t X509_check_email(X509 *a1, char *__s, size_t __n, int a4)
{
  size_t v5;

  if (!__s)
    return 4294967294;
  v5 = __n;
  if (__n)
  {
    if (memchr(__s, 0, __n))
      return 4294967294;
  }
  else
  {
    v5 = strlen(__s);
  }
  return do_x509_check(a1, __s, v5, a4, 1, 0);
}

uint64_t X509_check_ip(X509 *a1, _BYTE *a2, size_t a3, int a4)
{
  if (a2)
    return do_x509_check(a1, a2, a3, a4, 7, 0);
  else
    return 4294967294;
}

uint64_t X509_check_ip_asc(X509 *a1, const char *a2, int a3)
{
  unsigned int v5;
  unsigned __int8 ipout[16];
  uint64_t v8;

  v8 = *MEMORY[0x24BDAC8D0];
  if (a2 && (v5 = a2i_ipadd(ipout, a2)) != 0)
    return do_x509_check(a1, ipout, v5, a3, 7, 0);
  else
    return 4294967294;
}

int a2i_ipadd(unsigned __int8 *ipout, const char *ipasc)
{
  uint64_t v4;
  uint64_t v5;
  unsigned __int8 *v7;
  __int128 arg;
  int v9;
  uint64_t v10;
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  if (!strchr((char *)ipasc, 58))
    return 4 * (ipv4_from_asc(ipout, (char *)ipasc) != 0);
  arg = 0uLL;
  v9 = 0;
  v10 = 0xFFFFFFFFLL;
  if (!CONF_parse_list(ipasc, 58, 0, (int (__cdecl *)(const char *, int, void *))ipv6_cb, &arg))
    return 0;
  v4 = v10;
  v5 = v9;
  if ((_DWORD)v10 == -1)
  {
    if (v9 == 16)
      goto LABEL_12;
    return 0;
  }
  if (v9 == 16 || SHIDWORD(v10) > 3)
    return 0;
  if (HIDWORD(v10) == 2)
  {
    if ((_DWORD)v10 && v9 != (_DWORD)v10)
      return 0;
    goto LABEL_19;
  }
  if (HIDWORD(v10) != 3)
  {
    if (!(_DWORD)v10 || v9 == (_DWORD)v10)
      return 0;
LABEL_19:
    if ((v10 & 0x80000000) == 0)
    {
      memcpy(ipout, &arg, v10);
      v7 = &ipout[v4];
      bzero(v7, 16 - v5);
      if ((_DWORD)v5 != (_DWORD)v4)
        memcpy(&v7[-v5 + 16], (char *)&arg + v4, (int)v5 - (int)v4);
      return 16;
    }
LABEL_12:
    *(_OWORD *)ipout = arg;
    return 16;
  }
  if (v9 <= 0)
    goto LABEL_19;
  return 0;
}

ASN1_OCTET_STRING *__cdecl a2i_IPADDRESS(const char *ipasc)
{
  int v1;
  int v2;
  ASN1_OCTET_STRING *v3;
  ASN1_OCTET_STRING *v4;
  unsigned __int8 ipout[16];
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v1 = a2i_ipadd(ipout, ipasc);
  if (!v1)
    return 0;
  v2 = v1;
  v3 = ASN1_OCTET_STRING_new();
  v4 = v3;
  if (v3 && !ASN1_OCTET_STRING_set(v3, ipout, v2))
  {
    ASN1_OCTET_STRING_free(v4);
    return 0;
  }
  return v4;
}

ASN1_OCTET_STRING *__cdecl a2i_IPADDRESS_NC(const char *ipasc)
{
  char *v2;
  char *v3;
  char *v4;
  ASN1_OCTET_STRING *v5;
  char *v6;
  int v7;
  int v8;
  int v9;
  ASN1_OCTET_STRING *v10;
  unsigned __int8 ipout[32];
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  v2 = strchr((char *)ipasc, 47);
  if (!v2)
    return 0;
  v3 = v2;
  v4 = strdup(ipasc);
  v5 = (ASN1_OCTET_STRING *)v4;
  if (v4)
  {
    v6 = &v4[v3 - ipasc];
    *v6 = 0;
    v7 = a2i_ipadd(ipout, v4);
    if (!v7
      || (v8 = v7, v9 = a2i_ipadd(&ipout[v7], v6 + 1), free(v5), v5 = 0, !v9)
      || v8 != v9
      || (v10 = ASN1_OCTET_STRING_new(), (v5 = v10) == 0))
    {
      free(v5);
      return 0;
    }
    if (!ASN1_OCTET_STRING_set(v10, ipout, 2 * v8))
    {
      ASN1_OCTET_STRING_free(v5);
      return 0;
    }
  }
  return v5;
}

uint64_t ipv4_from_asc(_BYTE *a1, char *a2)
{
  int v3;
  uint64_t result;
  char v5;
  char v6;
  char v7;
  int v8;
  int v9;
  uint64_t v10;

  v10 = 0;
  v9 = 0;
  v8 = 0;
  v3 = sscanf(a2, "%d.%d.%d.%d", (char *)&v10 + 4, &v10, &v9, &v8);
  result = 0;
  if (v3 == 4)
  {
    result = 0;
    if (HIDWORD(v10) <= 0xFF)
    {
      v5 = v10;
      if ((v10 & 0x80000000) == 0 && (int)v10 <= 255)
      {
        v6 = v9;
        if ((v9 & 0x80000000) == 0 && v9 <= 255)
        {
          v7 = v8;
          if ((v8 & 0x80000000) == 0 && v8 <= 255)
          {
            *a1 = BYTE4(v10);
            a1[1] = v5;
            a1[2] = v6;
            result = 1;
            a1[3] = v7;
          }
        }
      }
    }
  }
  return result;
}

int X509V3_NAME_from_section(X509_NAME *nm, STACK *dn_sk, unint64_t chtype)
{
  int v3;
  X509_NAME *v5;
  int v6;
  char *v7;
  unsigned __int8 *v8;
  unsigned __int8 *i;
  unsigned int v10;
  int v11;
  int v12;
  const char *v13;

  if (!nm)
    return (int)nm;
  v3 = chtype;
  v5 = nm;
  if (sk_num(dn_sk) < 1)
    goto LABEL_22;
  v6 = 0;
  while (2)
  {
    v7 = sk_value(dn_sk, v6);
    v8 = (unsigned __int8 *)*((_QWORD *)v7 + 1);
    for (i = v8 + 1; ; ++i)
    {
      v10 = *(i - 1);
      if (v10 <= 0x2D)
        break;
      if (v10 == 58 || v10 == 46)
        goto LABEL_12;
LABEL_11:
      ;
    }
    if (!*(i - 1))
      goto LABEL_14;
    if (v10 != 44)
      goto LABEL_11;
LABEL_12:
    if (*i)
      v8 = i;
LABEL_14:
    v11 = *v8;
    if (v11 == 43)
      v12 = -1;
    else
      v12 = 0;
    if (v11 == 43)
      v13 = (const char *)(v8 + 1);
    else
      v13 = (const char *)v8;
    LODWORD(nm) = X509_NAME_add_entry_by_txt(v5, v13, v3, *((const unsigned __int8 **)v7 + 2), -1, -1, v12);
    if ((_DWORD)nm)
    {
      if (++v6 >= sk_num(dn_sk))
      {
LABEL_22:
        LODWORD(nm) = 1;
        return (int)nm;
      }
      continue;
    }
    return (int)nm;
  }
}

uint64_t sk_strcmp(const char **a1, const char **a2)
{
  return strcmp(*a1, *a2);
}

BOOL equal_email(char *a1, size_t __n, char *a3, uint64_t a4)
{
  size_t v5;
  uint64_t v7;
  char *v8;
  char *v9;
  uint64_t v10;
  char *v11;
  char *v12;
  int v13;

  if (__n != a4)
    return 0;
  v5 = __n;
  v7 = 0;
  v8 = a3 - 1;
  v9 = a1 - 1;
  while (__n != v7)
  {
    v10 = v7;
    v11 = v8;
    v12 = v9;
    if (v9[__n] != 64)
    {
      v13 = v8[__n];
      ++v7;
      --v8;
      --v9;
      if (v13 != 64)
        continue;
    }
    if (!equal_nocase(&v12[__n], v10 + 1, &v11[__n], v10 + 1, 0))
      return 0;
    if (v5 - 1 != v10)
      v5 += ~v10;
    return equal_case(a1, v5, a3, v5, 0);
  }
  return equal_case(a1, v5, a3, v5, 0);
}

BOOL equal_nocase(char *a1, size_t __n, void *a3, size_t a4, unsigned int a5)
{
  size_t v8;
  const char *v9;
  void *v10;
  _BOOL8 result;
  void *v12;
  const char *i;
  size_t v14;
  const char *v15;

  v8 = __n;
  v9 = a1;
  v10 = memchr(a1, 0, __n);
  result = 0;
  if (!v10)
  {
    v12 = memchr(a3, 0, a4);
    result = 0;
    if (!v12)
    {
      if ((a5 & 0x8000) != 0)
      {
        i = v9;
        v14 = v8;
        if (v8 > a4)
        {
          v15 = &v9[v8 - a4];
          v14 = v8;
          for (i = v9; *i && ((*i == 46) & (a5 >> 4)) == 0; ++i)
          {
            if (--v14 <= a4)
            {
              v8 = a4;
              v9 = v15;
              return strncasecmp(v9, (const char *)a3, v8) == 0;
            }
          }
        }
        if (v14 == a4)
        {
          v8 = a4;
          v9 = i;
          return strncasecmp(v9, (const char *)a3, v8) == 0;
        }
      }
      if (v8 == a4)
        return strncasecmp(v9, (const char *)a3, v8) == 0;
      return 0;
    }
  }
  return result;
}

uint64_t equal_wildcard(char *a1, size_t __n, char *a3, size_t a4, unsigned int a5)
{
  int v9;
  size_t v10;
  unint64_t v11;
  size_t v12;
  int v13;
  int v14;
  _BOOL4 v15;
  int v17;
  int v18;
  unint64_t v21;
  size_t v22;
  uint64_t result;
  char *v24;
  char *v25;
  int v26;
  char *v27;
  char *v28;
  size_t v29;
  int v30;
  char v32;
  size_t v34;
  char *v35;

  if (a4 < 2)
  {
    if (!__n)
      return equal_nocase(a1, __n, a3, a4, a5);
  }
  else if (!__n || *a3 == 46)
  {
    return equal_nocase(a1, __n, a3, a4, a5);
  }
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = __n - 1;
  v13 = 1;
  v35 = a3;
  do
  {
    v14 = a1[v10];
    if (v14 == 42)
    {
      if (v10 == v12)
      {
        v15 = 1;
        if (v11)
          return equal_nocase(a1, __n, a3, a4, a5);
      }
      else
      {
        v15 = a1[v10 + 1] == 46;
        if (v11)
          return equal_nocase(a1, __n, a3, a4, a5);
      }
      if (v13 & 8 | v9)
        return equal_nocase(a1, __n, a3, a4, a5);
      v17 = v13 & v15;
      if ((a5 & 4) == 0)
        v17 = 1;
      if (v17 != 1 || ((v13 | v15) & 1) == 0)
        return equal_nocase(a1, __n, a3, a4, a5);
      v9 = 0;
      v13 &= ~1u;
      v11 = (unint64_t)&a1[v10];
    }
    else if ((v13 & 1) != 0)
    {
      if ((v13 & 8) != 0 || __n - v10 < 4 || (v18 = strncasecmp(&a1[v10], "xn--", 4uLL), a3 = v35, v18))
      {
        if ((v14 - 48) >= 0xA && (v14 & 0xFFFFFFDF) - 65 >= 0x1A)
          return equal_nocase(a1, __n, a3, a4, a5);
        v13 &= ~1u;
      }
      else
      {
        v10 += 3;
        v13 |= 8u;
      }
    }
    else if ((v14 - 48) >= 0xA && (v14 & 0xFFFFFFDF) - 65 > 0x19)
    {
      if (v14 == 45)
      {
        v13 |= 4u;
      }
      else
      {
        if (v14 != 46 || (v13 & 5) != 0)
          return equal_nocase(a1, __n, a3, a4, a5);
        ++v9;
        v13 = 1;
      }
    }
    else
    {
      v13 &= 8u;
    }
    ++v10;
  }
  while (v10 < __n);
  if ((v13 & 5) != 0 || v9 < 2 || !v11)
    return equal_nocase(a1, __n, a3, a4, a5);
  v21 = v11 - (_QWORD)a1;
  v22 = (size_t)&a1[__n + ~v11];
  if (~v11 + __n + v11 > a4)
    return 0;
  v24 = a3;
  result = equal_nocase(a1, v11 - (_QWORD)a1, a3, v11 - (_QWORD)a1, a5);
  if (!(_DWORD)result)
    return result;
  v34 = a4 - v22;
  v25 = &v24[a4 - v22];
  result = equal_nocase(v25, (size_t)&a1[__n + ~v11], (void *)(v11 + 1), (size_t)&a1[__n + ~v11], a5);
  if (!(_DWORD)result)
    return result;
  if ((char *)v11 == a1 && *(_BYTE *)(v11 + 1) == 46)
  {
    if (a4 == v22)
      return 0;
    v26 = (a5 >> 3) & 1;
  }
  else
  {
    if (a4 >= 4)
    {
      v27 = v35;
      result = strncasecmp(v35, "xn--", 4uLL);
      LOBYTE(v26) = 0;
      if (!(_DWORD)result)
        return result;
      goto LABEL_59;
    }
    LOBYTE(v26) = 0;
  }
  v27 = v35;
LABEL_59:
  v28 = &v27[v21];
  if (v25 != &v27[v21 + 1])
  {
    if (v34 == v21)
      return 1;
LABEL_64:
    v29 = a4 - __n + 1;
    while (1)
    {
      v30 = *v28;
      if ((v30 - 48) >= 0xA && (v30 - 65) >= 0x1A)
      {
        v32 = v30 == 46 ? v26 : 0;
        if ((v32 & 1) == 0 && v30 != 45 && (v30 - 97) > 0x19)
          break;
      }
      ++v28;
      if (!--v29)
        return 1;
    }
    return 0;
  }
  result = 1;
  if (v34 != v21 && *v28 != 42)
    goto LABEL_64;
  return result;
}

BOOL equal_case(char *a1, size_t __n, void *a3, size_t a4, unsigned int a5)
{
  size_t v8;
  const char *v9;
  void *v10;
  _BOOL8 result;
  void *v12;
  const char *i;
  size_t v14;
  const char *v15;

  v8 = __n;
  v9 = a1;
  v10 = memchr(a1, 0, __n);
  result = 0;
  if (!v10)
  {
    v12 = memchr(a3, 0, a4);
    result = 0;
    if (!v12)
    {
      if ((a5 & 0x8000) != 0)
      {
        i = v9;
        v14 = v8;
        if (v8 > a4)
        {
          v15 = &v9[v8 - a4];
          v14 = v8;
          for (i = v9; *i && ((*i == 46) & (a5 >> 4)) == 0; ++i)
          {
            if (--v14 <= a4)
            {
              v8 = a4;
              v9 = v15;
              return strncmp(v9, (const char *)a3, v8) == 0;
            }
          }
        }
        if (v14 == a4)
        {
          v8 = a4;
          v9 = i;
          return strncmp(v9, (const char *)a3, v8) == 0;
        }
      }
      if (v8 == a4)
        return strncmp(v9, (const char *)a3, v8) == 0;
      return 0;
    }
  }
  return result;
}

uint64_t do_check_string(ASN1_STRING *in, int a2, uint64_t (*a3)(void), uint64_t a4, void *__s2, size_t __n, char **a7)
{
  unsigned __int8 *data;
  uint64_t v14;
  unsigned int v15;
  size_t v16;
  uint64_t v17;
  unsigned __int8 *v18;
  char *v19;
  char *v20;
  unsigned __int8 *out;

  data = in->data;
  if (!data || !in->length)
    return 0;
  if (a2 >= 1)
  {
    if (in->type == a2)
    {
      if (a2 == 22)
      {
        v14 = a3();
        if (!a7)
          return v14;
LABEL_17:
        if ((int)v14 >= 1)
        {
          v20 = strndup((const char *)in->data, in->length);
          *a7 = v20;
          if (v20)
            return v14;
          else
            return 0xFFFFFFFFLL;
        }
        return v14;
      }
      if (in->length == (_DWORD)__n)
      {
        v14 = memcmp(data, __s2, __n) == 0;
        if (!a7)
          return v14;
        goto LABEL_17;
      }
    }
    return 0;
  }
  out = 0;
  v15 = ASN1_STRING_to_UTF8(&out, in);
  if ((v15 & 0x80000000) != 0)
    return 0xFFFFFFFFLL;
  v16 = v15;
  v17 = ((uint64_t (*)(unsigned __int8 *, _QWORD, void *, size_t, uint64_t))a3)(out, v15, __s2, __n, a4);
  v14 = v17;
  v18 = out;
  if (a7 && (int)v17 >= 1)
  {
    v19 = strndup((const char *)out, v16);
    *a7 = v19;
    if (v19)
      v14 = v14;
    else
      v14 = 0xFFFFFFFFLL;
  }
  free(v18);
  return v14;
}

uint64_t ipv6_cb(char *a1, int a2, _DWORD *a3)
{
  int v3;
  _DWORD *v4;
  uint64_t result;
  char *v6;
  int v7;
  int v8;
  unsigned int v9;
  _WORD *v10;
  int v11;
  int v12;
  int v13;

  v4 = a3 + 4;
  v3 = a3[4];
  if (v3 == 16)
    return 0;
  if (!a2)
  {
    v8 = a3[5];
    if (v8 == -1)
    {
      a3[5] = v3;
    }
    else if (v8 != v3)
    {
      return 0;
    }
    v4 = a3 + 6;
    v7 = 1;
    goto LABEL_23;
  }
  v6 = a1;
  if (a2 < 5)
  {
    v9 = 0;
    v10 = (_WORD *)((char *)a3 + v3);
    do
    {
      v12 = *v6++;
      v11 = v12;
      if ((v12 - 48) >= 0xA)
      {
        if ((v11 - 65) >= 6)
        {
          if ((v11 - 97) > 5)
            return 0;
          v13 = -87;
        }
        else
        {
          v13 = -55;
        }
      }
      else
      {
        v13 = -48;
      }
      v9 = (v13 + v11) | (16 * v9);
      --a2;
    }
    while (a2);
    *v10 = bswap32(v9) >> 16;
    v7 = 2;
    goto LABEL_23;
  }
  if (v3 > 12 || a1[a2])
    return 0;
  result = ipv4_from_asc((_BYTE *)a3 + v3, a1);
  if (!(_DWORD)result)
    return result;
  v7 = 4;
LABEL_23:
  *v4 += v7;
  return 1;
}

uint64_t Gost2814789_encrypt(int *a1, int *a2, int *a3)
{
  int v3;
  int v4;
  int v5;
  int v6;
  unsigned int v7;
  _DWORD *v8;
  int v9;
  _DWORD *v10;
  int v11;
  _DWORD *v12;
  int v13;
  int v14;
  _DWORD *v15;
  int v16;
  int v17;
  int v18;
  int v19;
  int v20;
  int v21;
  int v22;
  int v23;
  int v24;
  int v25;
  int v26;
  int v27;
  int v28;
  int v29;
  int v30;
  int v31;
  int v32;
  int v33;
  int v34;
  int v35;
  int v36;
  int v37;
  int v38;
  int v39;
  int v40;
  int v41;
  int v42;
  int v43;
  int v44;
  int v45;
  int v46;
  int v47;
  int v48;
  int v49;
  int v50;
  unsigned int v51;
  uint64_t result;
  int v53;
  int v54;
  unsigned int v55;
  int v56;

  v3 = *a1;
  v4 = a1[1];
  v5 = *a3;
  v6 = a3[1];
  v7 = *a1 + *a3;
  v8 = a3 + 8;
  v9 = a3[HIBYTE(v7) + 8];
  v10 = a3 + 264;
  v11 = a3[BYTE2(v7) + 264];
  v12 = a3 + 520;
  v13 = a3[BYTE1(v7) + 520];
  v14 = v7;
  v15 = a3 + 776;
  v16 = (v11 | v9 | v13 | a3[v14 + 776]) ^ v4;
  v17 = (a3[((v16 + v6) >> 16) + 264] | a3[((v16 + v6) >> 24) + 8] | a3[((unsigned __int16)(v16 + v6) >> 8) + 520] | a3[(v16 + v6) + 776]) ^ v3;
  v18 = a3[2];
  v19 = a3[3];
  v20 = (a3[((v17 + v18) >> 16) + 264] | a3[((v17 + v18) >> 24) + 8] | a3[((unsigned __int16)(v17 + v18) >> 8) + 520] | a3[(v17 + v18) + 776]) ^ v16;
  v21 = (a3[((v20 + v19) >> 16) + 264] | a3[((v20 + v19) >> 24) + 8] | a3[((unsigned __int16)(v20 + v19) >> 8) + 520] | a3[(v20 + v19) + 776]) ^ v17;
  v22 = a3[4];
  v23 = a3[5];
  v24 = (a3[((v21 + v22) >> 16) + 264] | a3[((v21 + v22) >> 24) + 8] | a3[((unsigned __int16)(v21 + v22) >> 8) + 520] | a3[(v21 + v22) + 776]) ^ v20;
  v25 = (a3[((v24 + v23) >> 16) + 264] | a3[((v24 + v23) >> 24) + 8] | a3[((unsigned __int16)(v24 + v23) >> 8) + 520] | a3[(v24 + v23) + 776]) ^ v21;
  v26 = a3[6];
  v27 = a3[7];
  v28 = (v10[((v25 + v26) >> 16)] | v8[(v25 + v26) >> 24] | v12[((unsigned __int16)(v25 + v26) >> 8)] | v15[(v25 + v26)]) ^ v24;
  v29 = (v10[((v28 + v27) >> 16)] | v8[(v28 + v27) >> 24] | v12[((unsigned __int16)(v28 + v27) >> 8)] | v15[(v28 + v27)]) ^ v25;
  v30 = (v10[((v29 + v5) >> 16)] | v8[(v29 + v5) >> 24] | v12[((unsigned __int16)(v29 + v5) >> 8)] | v15[(v29 + v5)]) ^ v28;
  v31 = (v10[((v30 + v6) >> 16)] | v8[(v30 + v6) >> 24] | v12[((unsigned __int16)(v30 + v6) >> 8)] | v15[(v30 + v6)]) ^ v29;
  v32 = (v10[((v31 + v18) >> 16)] | v8[(v31 + v18) >> 24] | v12[((unsigned __int16)(v31 + v18) >> 8)] | v15[(v31 + v18)]) ^ v30;
  v33 = (v10[((v32 + v19) >> 16)] | v8[(v32 + v19) >> 24] | v12[((unsigned __int16)(v32 + v19) >> 8)] | v15[(v32 + v19)]) ^ v31;
  v34 = (v10[((v33 + v22) >> 16)] | v8[(v33 + v22) >> 24] | v12[((unsigned __int16)(v33 + v22) >> 8)] | v15[(v33 + v22)]) ^ v32;
  v35 = (v10[((v34 + v23) >> 16)] | v8[(v34 + v23) >> 24] | v12[((unsigned __int16)(v34 + v23) >> 8)] | v15[(v34 + v23)]) ^ v33;
  v36 = (v10[((v35 + v26) >> 16)] | v8[(v35 + v26) >> 24] | v12[((unsigned __int16)(v35 + v26) >> 8)] | v15[(v35 + v26)]) ^ v34;
  v37 = (v10[((v36 + v27) >> 16)] | v8[(v36 + v27) >> 24] | v12[((unsigned __int16)(v36 + v27) >> 8)] | v15[(v36 + v27)]) ^ v35;
  v38 = (v10[((v37 + v5) >> 16)] | v8[(v37 + v5) >> 24] | v12[((unsigned __int16)(v37 + v5) >> 8)] | v15[(v37 + v5)]) ^ v36;
  v39 = (v10[((v38 + v6) >> 16)] | v8[(v38 + v6) >> 24] | v12[((unsigned __int16)(v38 + v6) >> 8)] | v15[(v38 + v6)]) ^ v37;
  v40 = (v10[((v39 + v18) >> 16)] | v8[(v39 + v18) >> 24] | v12[((unsigned __int16)(v39 + v18) >> 8)] | v15[(v39 + v18)]) ^ v38;
  v41 = (v10[((v40 + v19) >> 16)] | v8[(v40 + v19) >> 24] | v12[((unsigned __int16)(v40 + v19) >> 8)] | v15[(v40 + v19)]) ^ v39;
  v42 = (v10[((v41 + v22) >> 16)] | v8[(v41 + v22) >> 24] | v12[((unsigned __int16)(v41 + v22) >> 8)] | v15[(v41 + v22)]) ^ v40;
  v43 = (v10[((v42 + v23) >> 16)] | v8[(v42 + v23) >> 24] | v12[((unsigned __int16)(v42 + v23) >> 8)] | v15[(v42 + v23)]) ^ v41;
  v44 = (v10[((v43 + v26) >> 16)] | v8[(v43 + v26) >> 24] | v12[((unsigned __int16)(v43 + v26) >> 8)] | v15[(v43 + v26)]) ^ v42;
  v45 = (v10[((v44 + v27) >> 16)] | v8[(v44 + v27) >> 24] | v12[((unsigned __int16)(v44 + v27) >> 8)] | v15[(v44 + v27)]) ^ v43;
  v46 = (v10[((v45 + v27) >> 16)] | v8[(v45 + v27) >> 24] | v12[((unsigned __int16)(v45 + v27) >> 8)] | v15[(v45 + v27)]) ^ v44;
  v47 = (v10[((v46 + v26) >> 16)] | v8[(v46 + v26) >> 24] | v12[((unsigned __int16)(v46 + v26) >> 8)] | v15[(v46 + v26)]) ^ v45;
  v48 = (v10[((v47 + v23) >> 16)] | v8[(v47 + v23) >> 24] | v12[((unsigned __int16)(v47 + v23) >> 8)] | v15[(v47 + v23)]) ^ v46;
  v49 = (v10[((v48 + v22) >> 16)] | v8[(v48 + v22) >> 24] | v12[((unsigned __int16)(v48 + v22) >> 8)] | v15[(v48 + v22)]) ^ v47;
  v50 = (v10[((v49 + v19) >> 16)] | v8[(v49 + v19) >> 24] | v12[((unsigned __int16)(v49 + v19) >> 8)] | v15[(v49 + v19)]) ^ v48;
  v51 = v50 + v18;
  result = v12[BYTE1(v51)];
  v53 = (v10[BYTE2(v51)] | v8[HIBYTE(v51)] | result | v15[v51]) ^ v49;
  v54 = (v10[((v53 + v6) >> 16)] | v8[(v53 + v6) >> 24] | v12[((unsigned __int16)(v53 + v6) >> 8)] | v15[(v53 + v6)]) ^ v50;
  v55 = v54 + v5;
  LODWORD(v8) = v8[HIBYTE(v55)];
  LODWORD(v10) = v10[BYTE2(v55)];
  v56 = v12[BYTE1(v55)] | v15[v55];
  *a2 = v54;
  a2[1] = (v10 | v8 | v56) ^ v53;
  return result;
}

uint64_t Gost2814789_decrypt(int *a1, int *a2, int *a3)
{
  int v3;
  int v4;
  int v5;
  int v6;
  unsigned int v7;
  _DWORD *v8;
  int v9;
  _DWORD *v10;
  int v11;
  _DWORD *v12;
  int v13;
  int v14;
  _DWORD *v15;
  int v16;
  int v17;
  int v18;
  int v19;
  int v20;
  int v21;
  int v22;
  int v23;
  int v24;
  int v25;
  int v26;
  int v27;
  int v28;
  int v29;
  int v30;
  int v31;
  int v32;
  int v33;
  int v34;
  int v35;
  int v36;
  int v37;
  int v38;
  int v39;
  int v40;
  int v41;
  int v42;
  int v43;
  int v44;
  int v45;
  int v46;
  int v47;
  int v48;
  int v49;
  int v50;
  unsigned int v51;
  uint64_t result;
  int v53;
  int v54;
  unsigned int v55;
  int v56;

  v3 = *a1;
  v4 = a1[1];
  v5 = *a3;
  v6 = a3[1];
  v7 = *a1 + *a3;
  v8 = a3 + 8;
  v9 = a3[HIBYTE(v7) + 8];
  v10 = a3 + 264;
  v11 = a3[BYTE2(v7) + 264];
  v12 = a3 + 520;
  v13 = a3[BYTE1(v7) + 520];
  v14 = v7;
  v15 = a3 + 776;
  v16 = (v11 | v9 | v13 | a3[v14 + 776]) ^ v4;
  v17 = (a3[((v16 + v6) >> 16) + 264] | a3[((v16 + v6) >> 24) + 8] | a3[((unsigned __int16)(v16 + v6) >> 8) + 520] | a3[(v16 + v6) + 776]) ^ v3;
  v18 = a3[2];
  v19 = a3[3];
  v20 = (a3[((v17 + v18) >> 16) + 264] | a3[((v17 + v18) >> 24) + 8] | a3[((unsigned __int16)(v17 + v18) >> 8) + 520] | a3[(v17 + v18) + 776]) ^ v16;
  v21 = (a3[((v20 + v19) >> 16) + 264] | a3[((v20 + v19) >> 24) + 8] | a3[((unsigned __int16)(v20 + v19) >> 8) + 520] | a3[(v20 + v19) + 776]) ^ v17;
  v22 = a3[4];
  v23 = a3[5];
  v24 = (a3[((v21 + v22) >> 16) + 264] | a3[((v21 + v22) >> 24) + 8] | a3[((unsigned __int16)(v21 + v22) >> 8) + 520] | a3[(v21 + v22) + 776]) ^ v20;
  v25 = (a3[((v24 + v23) >> 16) + 264] | a3[((v24 + v23) >> 24) + 8] | a3[((unsigned __int16)(v24 + v23) >> 8) + 520] | a3[(v24 + v23) + 776]) ^ v21;
  v26 = a3[6];
  v27 = a3[7];
  v28 = (v10[((v25 + v26) >> 16)] | v8[(v25 + v26) >> 24] | v12[((unsigned __int16)(v25 + v26) >> 8)] | v15[(v25 + v26)]) ^ v24;
  v29 = (v10[((v28 + v27) >> 16)] | v8[(v28 + v27) >> 24] | v12[((unsigned __int16)(v28 + v27) >> 8)] | v15[(v28 + v27)]) ^ v25;
  v30 = (v10[((v29 + v27) >> 16)] | v8[(v29 + v27) >> 24] | v12[((unsigned __int16)(v29 + v27) >> 8)] | v15[(v29 + v27)]) ^ v28;
  v31 = (v10[((v30 + v26) >> 16)] | v8[(v30 + v26) >> 24] | v12[((unsigned __int16)(v30 + v26) >> 8)] | v15[(v30 + v26)]) ^ v29;
  v32 = (v10[((v31 + v23) >> 16)] | v8[(v31 + v23) >> 24] | v12[((unsigned __int16)(v31 + v23) >> 8)] | v15[(v31 + v23)]) ^ v30;
  v33 = (v10[((v32 + v22) >> 16)] | v8[(v32 + v22) >> 24] | v12[((unsigned __int16)(v32 + v22) >> 8)] | v15[(v32 + v22)]) ^ v31;
  v34 = (v10[((v33 + v19) >> 16)] | v8[(v33 + v19) >> 24] | v12[((unsigned __int16)(v33 + v19) >> 8)] | v15[(v33 + v19)]) ^ v32;
  v35 = (v10[((v34 + v18) >> 16)] | v8[(v34 + v18) >> 24] | v12[((unsigned __int16)(v34 + v18) >> 8)] | v15[(v34 + v18)]) ^ v33;
  v36 = (v10[((v35 + v6) >> 16)] | v8[(v35 + v6) >> 24] | v12[((unsigned __int16)(v35 + v6) >> 8)] | v15[(v35 + v6)]) ^ v34;
  v37 = (v10[((v36 + v5) >> 16)] | v8[(v36 + v5) >> 24] | v12[((unsigned __int16)(v36 + v5) >> 8)] | v15[(v36 + v5)]) ^ v35;
  v38 = (v10[((v37 + v27) >> 16)] | v8[(v37 + v27) >> 24] | v12[((unsigned __int16)(v37 + v27) >> 8)] | v15[(v37 + v27)]) ^ v36;
  v39 = (v10[((v38 + v26) >> 16)] | v8[(v38 + v26) >> 24] | v12[((unsigned __int16)(v38 + v26) >> 8)] | v15[(v38 + v26)]) ^ v37;
  v40 = (v10[((v39 + v23) >> 16)] | v8[(v39 + v23) >> 24] | v12[((unsigned __int16)(v39 + v23) >> 8)] | v15[(v39 + v23)]) ^ v38;
  v41 = (v10[((v40 + v22) >> 16)] | v8[(v40 + v22) >> 24] | v12[((unsigned __int16)(v40 + v22) >> 8)] | v15[(v40 + v22)]) ^ v39;
  v42 = (v10[((v41 + v19) >> 16)] | v8[(v41 + v19) >> 24] | v12[((unsigned __int16)(v41 + v19) >> 8)] | v15[(v41 + v19)]) ^ v40;
  v43 = (v10[((v42 + v18) >> 16)] | v8[(v42 + v18) >> 24] | v12[((unsigned __int16)(v42 + v18) >> 8)] | v15[(v42 + v18)]) ^ v41;
  v44 = (v10[((v43 + v6) >> 16)] | v8[(v43 + v6) >> 24] | v12[((unsigned __int16)(v43 + v6) >> 8)] | v15[(v43 + v6)]) ^ v42;
  v45 = (v10[((v44 + v5) >> 16)] | v8[(v44 + v5) >> 24] | v12[((unsigned __int16)(v44 + v5) >> 8)] | v15[(v44 + v5)]) ^ v43;
  v46 = (v10[((v45 + v27) >> 16)] | v8[(v45 + v27) >> 24] | v12[((unsigned __int16)(v45 + v27) >> 8)] | v15[(v45 + v27)]) ^ v44;
  v47 = (v10[((v46 + v26) >> 16)] | v8[(v46 + v26) >> 24] | v12[((unsigned __int16)(v46 + v26) >> 8)] | v15[(v46 + v26)]) ^ v45;
  v48 = (v10[((v47 + v23) >> 16)] | v8[(v47 + v23) >> 24] | v12[((unsigned __int16)(v47 + v23) >> 8)] | v15[(v47 + v23)]) ^ v46;
  v49 = (v10[((v48 + v22) >> 16)] | v8[(v48 + v22) >> 24] | v12[((unsigned __int16)(v48 + v22) >> 8)] | v15[(v48 + v22)]) ^ v47;
  v50 = (v10[((v49 + v19) >> 16)] | v8[(v49 + v19) >> 24] | v12[((unsigned __int16)(v49 + v19) >> 8)] | v15[(v49 + v19)]) ^ v48;
  v51 = v50 + v18;
  result = v12[BYTE1(v51)];
  v53 = (v10[BYTE2(v51)] | v8[HIBYTE(v51)] | result | v15[v51]) ^ v49;
  v54 = (v10[((v53 + v6) >> 16)] | v8[(v53 + v6) >> 24] | v12[((unsigned __int16)(v53 + v6) >> 8)] | v15[(v53 + v6)]) ^ v50;
  v55 = v54 + v5;
  LODWORD(v8) = v8[HIBYTE(v55)];
  LODWORD(v10) = v10[BYTE2(v55)];
  v56 = v12[BYTE1(v55)] | v15[v55];
  *a2 = v54;
  a2[1] = (v10 | v8 | v56) ^ v53;
  return result;
}

uint64_t Gost2814789_ecb_encrypt(int *a1, int *a2, uint64_t a3, int a4)
{
  if ((*(_BYTE *)(a3 + 4132) & 1) != 0 && *(_DWORD *)(a3 + 4128) == 1024)
  {
    Gost2814789_cryptopro_key_mesh((int *)a3);
    *(_DWORD *)(a3 + 4128) = 0;
  }
  if (a4)
    return Gost2814789_encrypt(a1, a2, (int *)a3);
  else
    return Gost2814789_decrypt(a1, a2, (int *)a3);
}

uint64_t Gost2814789_cfb64_encrypt(uint64_t result, _BYTE *a2, unint64_t a3, uint64_t a4, int *a5, unsigned int *a6, int a7)
{
  char *v11;
  unsigned int v12;
  BOOL v13;
  int v14;
  char v15;
  char v16;
  unint64_t v17;
  char v18;
  char v19;
  unint64_t v20;
  char v21;
  uint64_t v22;
  unsigned int v23;
  char v24;
  uint64_t v25;
  char v26;

  v11 = (char *)result;
  v12 = *a6;
  if (*a6)
    v13 = a3 == 0;
  else
    v13 = 1;
  v14 = !v13;
  if (a7)
  {
    if (v14)
    {
      do
      {
        v15 = *v11++;
        v16 = *((_BYTE *)a5 + v12);
        *((_BYTE *)a5 + v12) = v16 ^ v15;
        *a2++ = v16 ^ v15;
        v17 = a3 - 1;
        v18 = v12 + 1;
        v12 = ((_BYTE)v12 + 1) & 7;
        if ((v18 & 7) == 0)
          break;
        --a3;
      }
      while (a3);
    }
    else
    {
      v17 = a3;
    }
    if (v17 < 8)
    {
      v23 = v12;
      if (!v17)
        goto LABEL_49;
    }
    else
    {
      do
      {
        if ((*(_BYTE *)(a4 + 4132) & 1) != 0 && *(_DWORD *)(a4 + 4128) == 1024)
        {
          Gost2814789_cryptopro_key_mesh((int *)a4);
          Gost2814789_encrypt(a5, a5, (int *)a4);
          *(_DWORD *)(a4 + 4128) = 0;
        }
        result = Gost2814789_encrypt(a5, a5, (int *)a4);
        *(_DWORD *)(a4 + 4128) += 8;
        if (v12 <= 7)
        {
          v22 = *(_QWORD *)((char *)a5 + v12) ^ *(_QWORD *)&v11[v12];
          *(_QWORD *)((char *)a5 + v12) = v22;
          *(_QWORD *)&a2[v12] = v22;
        }
        v12 = 0;
        v23 = 0;
        v17 -= 8;
        a2 += 8;
        v11 += 8;
      }
      while (v17 > 7);
      if (!v17)
        goto LABEL_49;
    }
    if ((*(_BYTE *)(a4 + 4132) & 1) != 0 && *(_DWORD *)(a4 + 4128) == 1024)
    {
      Gost2814789_cryptopro_key_mesh((int *)a4);
      Gost2814789_encrypt(a5, a5, (int *)a4);
      *(_DWORD *)(a4 + 4128) = 0;
    }
    result = Gost2814789_encrypt(a5, a5, (int *)a4);
    *(_DWORD *)(a4 + 4128) += 8;
    do
    {
      v24 = *((_BYTE *)a5 + v23) ^ v11[v23];
      *((_BYTE *)a5 + v23) = v24;
      a2[v23++] = v24;
      --v17;
    }
    while (v17);
    goto LABEL_49;
  }
  if (v14)
  {
    do
    {
      v19 = *v11++;
      *a2++ = v19 ^ *((_BYTE *)a5 + v12);
      *((_BYTE *)a5 + v12) = v19;
      v20 = a3 - 1;
      v21 = v12 + 1;
      v12 = ((_BYTE)v12 + 1) & 7;
      if ((v21 & 7) == 0)
        break;
      --a3;
    }
    while (a3);
  }
  else
  {
    v20 = a3;
  }
  if (v20 < 8)
  {
    v23 = v12;
    if (!v20)
      goto LABEL_49;
    goto LABEL_44;
  }
  do
  {
    if ((*(_BYTE *)(a4 + 4132) & 1) != 0 && *(_DWORD *)(a4 + 4128) == 1024)
    {
      Gost2814789_cryptopro_key_mesh((int *)a4);
      Gost2814789_encrypt(a5, a5, (int *)a4);
      *(_DWORD *)(a4 + 4128) = 0;
    }
    result = Gost2814789_encrypt(a5, a5, (int *)a4);
    *(_DWORD *)(a4 + 4128) += 8;
    if (v12 <= 7)
    {
      v25 = *(_QWORD *)&v11[v12];
      *(_QWORD *)&a2[v12] = *(_QWORD *)((char *)a5 + v12) ^ v25;
      *(_QWORD *)((char *)a5 + v12) = v25;
    }
    v12 = 0;
    v23 = 0;
    v20 -= 8;
    a2 += 8;
    v11 += 8;
  }
  while (v20 > 7);
  if (v20)
  {
LABEL_44:
    if ((*(_BYTE *)(a4 + 4132) & 1) != 0 && *(_DWORD *)(a4 + 4128) == 1024)
    {
      Gost2814789_cryptopro_key_mesh((int *)a4);
      Gost2814789_encrypt(a5, a5, (int *)a4);
      *(_DWORD *)(a4 + 4128) = 0;
    }
    result = Gost2814789_encrypt(a5, a5, (int *)a4);
    *(_DWORD *)(a4 + 4128) += 8;
    do
    {
      v26 = v11[v23];
      a2[v23] = v26 ^ *((_BYTE *)a5 + v23);
      *((_BYTE *)a5 + v23++) = v26;
      --v20;
    }
    while (v20);
  }
LABEL_49:
  *a6 = v23;
  return result;
}

uint64_t Gost2814789_cnt_encrypt(uint64_t result, _BYTE *a2, unint64_t a3, uint64_t a4, int *a5, int *a6, unsigned int *a7)
{
  char *v12;
  unsigned int v13;
  BOOL v14;
  unint64_t v15;
  char v16;
  char v17;
  unsigned int v18;

  v12 = (char *)result;
  v13 = *a7;
  if (*a7)
    v14 = a3 == 0;
  else
    v14 = 1;
  if (v14)
  {
    v15 = a3;
  }
  else
  {
    do
    {
      v16 = *v12++;
      *a2++ = *((_BYTE *)a6 + v13) ^ v16;
      v15 = a3 - 1;
      v17 = v13 + 1;
      v13 = ((_BYTE)v13 + 1) & 7;
      if ((v17 & 7) == 0)
        break;
      --a3;
    }
    while (a3);
  }
  if (v15 < 8)
  {
    v18 = v13;
    if (!v15)
      goto LABEL_18;
    goto LABEL_16;
  }
  do
  {
    result = Gost2814789_cnt_next(a5, a6, a4);
    if (v13 <= 7)
      *(_QWORD *)&a2[v13] = *(_QWORD *)((char *)a6 + v13) ^ *(_QWORD *)&v12[v13];
    v13 = 0;
    v18 = 0;
    v15 -= 8;
    a2 += 8;
    v12 += 8;
  }
  while (v15 > 7);
  if (v15)
  {
LABEL_16:
    result = Gost2814789_cnt_next(a5, a6, a4);
    do
    {
      a2[v18] = *((_BYTE *)a6 + v18) ^ v12[v18];
      ++v18;
      --v15;
    }
    while (v15);
  }
LABEL_18:
  *a7 = v18;
  return result;
}

uint64_t Gost2814789_cnt_next(int *a1, int *a2, uint64_t a3)
{
  unsigned int v6;
  int v7;
  uint64_t result;

  if (!*(_DWORD *)(a3 + 4128))
    Gost2814789_encrypt(a1, a1, (int *)a3);
  if ((*(_BYTE *)(a3 + 4132) & 1) != 0 && *(_DWORD *)(a3 + 4128) == 1024)
  {
    Gost2814789_cryptopro_key_mesh((int *)a3);
    Gost2814789_encrypt(a1, a1, (int *)a3);
    *(_DWORD *)(a3 + 4128) = 0;
  }
  v6 = a1[1];
  if (v6 <= 0xFEFEFEFB)
    v7 = 16843012;
  else
    v7 = 16843013;
  *a1 += 16843009;
  a1[1] = v7 + v6;
  result = Gost2814789_encrypt(a1, a2, (int *)a3);
  *(_DWORD *)(a3 + 4128) += 8;
  return result;
}

uint64_t GOST2814789IMIT_Init(uint64_t a1, int a2)
{
  *(_DWORD *)(a1 + 16) = 0;
  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 4156) = 0;
  return Gost2814789_set_sbox(a1 + 20, a2);
}

uint64_t GOST2814789IMIT_Update(uint64_t a1, char *__src, size_t __n)
{
  size_t v3;
  char *v4;
  uint64_t v6;
  void *v7;
  uint64_t v8;
  size_t v9;
  uint64_t v10;

  if (__n)
  {
    v3 = __n;
    v4 = __src;
    *(_QWORD *)a1 += 8 * __n;
    v6 = *(unsigned int *)(a1 + 16);
    if ((_DWORD)v6)
    {
      v7 = (void *)(a1 + 8 + v6);
      if (__n <= 7 && v6 + __n < 8)
      {
        memcpy(v7, __src, __n);
        *(_DWORD *)(a1 + 16) += v3;
        return 1;
      }
      v8 = 8 - v6;
      memcpy(v7, __src, 8 - v6);
      Gost2814789_mac_mesh(a1 + 8, (int *)(a1 + 4156), a1 + 20);
      v4 += v8;
      v3 -= v8;
      *(_DWORD *)(a1 + 16) = 0;
      *(_QWORD *)(a1 + 8) = 0;
    }
    if (v3 >= 8)
    {
      v9 = v3 >> 3;
      v10 = (uint64_t)v4;
      do
      {
        Gost2814789_mac_mesh(v10, (int *)(a1 + 4156), a1 + 20);
        v10 += 8;
        --v9;
      }
      while (v9);
      v4 += v3 & 0xFFFFFFFFFFFFFFF8;
      v3 &= 7u;
    }
    if (v3)
    {
      *(_DWORD *)(a1 + 16) = v3;
      memcpy((void *)(a1 + 8), v4, v3);
    }
  }
  return 1;
}

uint64_t GOST2814789IMIT_Transform(uint64_t a1, uint64_t a2)
{
  return Gost2814789_mac_mesh(a2, (int *)(a1 + 4156), a1 + 20);
}

uint64_t GOST2814789IMIT_Final(_DWORD *a1, uint64_t a2)
{
  uint64_t v4;

  v4 = *(unsigned int *)(a2 + 16);
  if ((_DWORD)v4)
  {
    bzero((void *)(a2 + 8 + v4), (8 - v4));
    Gost2814789_mac_mesh(a2 + 8, (int *)(a2 + 4156), a2 + 20);
  }
  if ((*(_DWORD *)a2 - 65) >= 0xFFFFFFC0 && !*(_DWORD *)(a2 + 4))
  {
    *(_QWORD *)(a2 + 8) = 0;
    Gost2814789_mac_mesh(a2 + 8, (int *)(a2 + 4156), a2 + 20);
  }
  *a1 = *(_DWORD *)(a2 + 4156);
  return 1;
}

uint64_t Gost2814789_mac_mesh(uint64_t a1, int *a2, uint64_t a3)
{
  uint64_t i;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  uint64_t result;
  int v19;
  int v20;
  int v21;
  int v22;
  int v23;
  int v24;
  int v25;
  int v26;
  int v27;
  int v28;

  if ((*(_BYTE *)(a3 + 4132) & 1) != 0 && *(_DWORD *)(a3 + 4128) == 1024)
  {
    Gost2814789_cryptopro_key_mesh((int *)a3);
    *(_DWORD *)(a3 + 4128) = 0;
  }
  for (i = 0; i != 8; ++i)
    *((_BYTE *)a2 + i) ^= *(_BYTE *)(a1 + i);
  v7 = *(_DWORD *)(a3 + 4);
  v8 = (*(_DWORD *)(a3 + 1056 + 4 * ((*a2 + *(_DWORD *)a3) >> 16)) | *(_DWORD *)(a3 + 32 + 4 * ((*a2 + *(_DWORD *)a3) >> 24)) | *(_DWORD *)(a3 + 2080 + 4 * ((unsigned __int16)(*(_WORD *)a2 + *(_WORD *)a3) >> 8)) | *(_DWORD *)(a3 + 3104 + 4 * (*(_BYTE *)a2 + *(_BYTE *)a3))) ^ a2[1];
  v9 = (*(_DWORD *)(a3 + 1056 + 4 * ((v8 + v7) >> 16)) | *(_DWORD *)(a3 + 32 + 4 * ((v8 + v7) >> 24)) | *(_DWORD *)(a3 + 2080 + 4 * ((unsigned __int16)(v8 + v7) >> 8)) | *(_DWORD *)(a3 + 3104 + 4 * (v8 + v7))) ^ *a2;
  v11 = *(_DWORD *)(a3 + 8);
  v10 = *(_DWORD *)(a3 + 12);
  v12 = (*(_DWORD *)(a3 + 1056 + 4 * ((v9 + v11) >> 16)) | *(_DWORD *)(a3 + 32 + 4 * ((v9 + v11) >> 24)) | *(_DWORD *)(a3 + 2080 + 4 * ((unsigned __int16)(v9 + v11) >> 8)) | *(_DWORD *)(a3 + 3104 + 4 * (v9 + v11))) ^ v8;
  v13 = (*(_DWORD *)(a3 + 1056 + 4 * ((v12 + v10) >> 16)) | *(_DWORD *)(a3 + 32 + 4 * ((v12 + v10) >> 24)) | *(_DWORD *)(a3 + 2080 + 4 * ((unsigned __int16)(v12 + v10) >> 8)) | *(_DWORD *)(a3 + 3104 + 4 * (v12 + v10))) ^ v9;
  v14 = *(_DWORD *)(a3 + 16);
  v15 = *(_DWORD *)(a3 + 20);
  v16 = (*(_DWORD *)(a3 + 1056 + 4 * ((v13 + v14) >> 16)) | *(_DWORD *)(a3 + 32 + 4 * ((v13 + v14) >> 24)) | *(_DWORD *)(a3 + 2080 + 4 * ((unsigned __int16)(v13 + v14) >> 8)) | *(_DWORD *)(a3 + 3104 + 4 * (v13 + v14))) ^ v12;
  v17 = (*(_DWORD *)(a3 + 1056 + 4 * ((v16 + v15) >> 16)) | *(_DWORD *)(a3 + 32 + 4 * ((v16 + v15) >> 24)) | *(_DWORD *)(a3 + 2080 + 4 * ((unsigned __int16)(v16 + v15) >> 8)) | *(_DWORD *)(a3 + 3104 + 4 * (v16 + v15))) ^ v13;
  result = *(unsigned int *)(a3 + 24);
  v19 = *(_DWORD *)(a3 + 28);
  v20 = (*(_DWORD *)(a3 + 1056 + 4 * ((v17 + result) >> 16)) | *(_DWORD *)(a3 + 32 + 4 * ((v17 + result) >> 24)) | *(_DWORD *)(a3 + 2080 + 4 * ((unsigned __int16)(v17 + result) >> 8)) | *(_DWORD *)(a3 + 3104 + 4 * (v17 + result))) ^ v16;
  v21 = (*(_DWORD *)(a3 + 1056 + 4 * ((v20 + v19) >> 16)) | *(_DWORD *)(a3 + 32 + 4 * ((v20 + v19) >> 24)) | *(_DWORD *)(a3 + 2080 + 4 * ((unsigned __int16)(v20 + v19) >> 8)) | *(_DWORD *)(a3 + 3104 + 4 * (v20 + v19))) ^ v17;
  v22 = (*(_DWORD *)(a3 + 1056 + 4 * ((v21 + *(_DWORD *)a3) >> 16)) | *(_DWORD *)(a3 + 32 + 4 * ((v21 + *(_DWORD *)a3) >> 24)) | *(_DWORD *)(a3 + 2080 + 4 * ((unsigned __int16)(v21 + *(_WORD *)a3) >> 8)) | *(_DWORD *)(a3 + 3104 + 4 * (v21 + *(_BYTE *)a3))) ^ v20;
  v23 = (*(_DWORD *)(a3 + 1056 + 4 * ((v22 + v7) >> 16)) | *(_DWORD *)(a3 + 32 + 4 * ((v22 + v7) >> 24)) | *(_DWORD *)(a3 + 2080 + 4 * ((unsigned __int16)(v22 + v7) >> 8)) | *(_DWORD *)(a3 + 3104 + 4 * (v22 + v7))) ^ v21;
  v24 = (*(_DWORD *)(a3 + 1056 + 4 * ((v23 + v11) >> 16)) | *(_DWORD *)(a3 + 32 + 4 * ((v23 + v11) >> 24)) | *(_DWORD *)(a3 + 2080 + 4 * ((unsigned __int16)(v23 + v11) >> 8)) | *(_DWORD *)(a3 + 3104 + 4 * (v23 + v11))) ^ v22;
  v25 = (*(_DWORD *)(a3 + 1056 + 4 * ((v24 + v10) >> 16)) | *(_DWORD *)(a3 + 32 + 4 * ((v24 + v10) >> 24)) | *(_DWORD *)(a3 + 2080 + 4 * ((unsigned __int16)(v24 + v10) >> 8)) | *(_DWORD *)(a3 + 3104 + 4 * (v24 + v10))) ^ v23;
  v26 = (*(_DWORD *)(a3 + 1056 + 4 * ((v25 + v14) >> 16)) | *(_DWORD *)(a3 + 32 + 4 * ((v25 + v14) >> 24)) | *(_DWORD *)(a3 + 2080 + 4 * ((unsigned __int16)(v25 + v14) >> 8)) | *(_DWORD *)(a3 + 3104 + 4 * (v25 + v14))) ^ v24;
  v27 = (*(_DWORD *)(a3 + 1056 + 4 * ((v26 + v15) >> 16)) | *(_DWORD *)(a3 + 32 + 4 * ((v26 + v15) >> 24)) | *(_DWORD *)(a3 + 2080 + 4 * ((unsigned __int16)(v26 + v15) >> 8)) | *(_DWORD *)(a3 + 3104 + 4 * (v26 + v15))) ^ v25;
  v28 = (*(_DWORD *)(a3 + 1056 + 4 * ((v27 + result) >> 16)) | *(_DWORD *)(a3 + 32 + 4 * ((v27 + result) >> 24)) | *(_DWORD *)(a3 + 2080 + 4 * ((unsigned __int16)(v27 + result) >> 8)) | *(_DWORD *)(a3 + 3104 + 4 * (v27 + result))) ^ v26;
  *a2 = (*(_DWORD *)(a3 + 1056 + 4 * ((v28 + v19) >> 16)) | *(_DWORD *)(a3 + 32 + 4 * ((v28 + v19) >> 24)) | *(_DWORD *)(a3 + 2080 + 4 * ((unsigned __int16)(v28 + v19) >> 8)) | *(_DWORD *)(a3 + 3104 + 4 * (v28 + v19))) ^ v27;
  a2[1] = v28;
  *(_DWORD *)(a3 + 4128) += 8;
  return result;
}

_DWORD *GOST2814789IMIT(uint64_t a1)
{
  uint64_t v1;
  _DWORD *v2;
  int v3;
  uint64_t *v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;
  size_t v8;
  size_t v9;
  char *v10;
  _DWORD *v11;
  _OWORD v13[259];
  uint64_t v14;
  uint64_t v15;

  v1 = MEMORY[0x24BDAC7A8](a1);
  v5 = v4;
  v7 = v6;
  v9 = v8;
  v10 = (char *)v1;
  v15 = *MEMORY[0x24BDAC8D0];
  v14 = 0;
  memset(v13, 0, 64);
  if (v2)
    v11 = v2;
  else
    v11 = &GOST2814789IMIT_m;
  memset(&v13[4], 0, 448);
  Gost2814789_set_sbox((uint64_t)&v13[1] + 4, v3);
  v14 = *v5;
  Gost2814789_set_key((uint64_t)&v13[1] + 4, v7, 256);
  GOST2814789IMIT_Update((uint64_t)v13, v10, v9);
  GOST2814789IMIT_Final(v11, (uint64_t)v13);
  explicit_bzero(v13, 0x1044uLL);
  return v11;
}

ECDSA_SIG *__cdecl d2i_ECDSA_SIG(ECDSA_SIG **v, const unsigned __int8 **pp, uint64_t len)
{
  return (ECDSA_SIG *)ASN1_item_d2i((ASN1_VALUE **)v, pp, len, &ECDSA_SIG_it);
}

int i2d_ECDSA_SIG(const ECDSA_SIG *a, unsigned __int8 **pp)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, pp, &ECDSA_SIG_it);
}

ECDSA_SIG *ECDSA_SIG_new(void)
{
  return (ECDSA_SIG *)ASN1_item_new(&ECDSA_SIG_it);
}

void ECDSA_SIG_free(ECDSA_SIG *a)
{
  ASN1_item_free((ASN1_VALUE *)a, &ECDSA_SIG_it);
}

_QWORD *ECDSA_SIG_get0(_QWORD *result, _QWORD *a2, _QWORD *a3)
{
  if (a2)
    *a2 = *result;
  if (a3)
    *a3 = result[1];
  return result;
}

uint64_t ECDSA_SIG_get0_r(uint64_t a1)
{
  return *(_QWORD *)a1;
}

uint64_t ECDSA_SIG_get0_s(uint64_t a1)
{
  return *(_QWORD *)(a1 + 8);
}

uint64_t ECDSA_SIG_set0(BIGNUM **a1, BIGNUM *a2, BIGNUM *a3)
{
  uint64_t result;

  result = 0;
  if (a2)
  {
    if (a3)
    {
      BN_free(*a1);
      BN_free(a1[1]);
      *a1 = a2;
      a1[1] = a3;
      return 1;
    }
  }
  return result;
}

uint64_t EC_POINT_set_compressed_coordinates(uint64_t a1, _QWORD *a2, uint64_t a3, uint64_t a4, BN_CTX *a5)
{
  BN_CTX *v10;
  uint64_t (*v11)(uint64_t, _QWORD *, uint64_t, uint64_t, BN_CTX *);
  int v12;
  int v13;
  uint64_t v14;

  v10 = a5;
  if (!a5)
  {
    v10 = BN_CTX_new();
    if (!v10)
      goto LABEL_8;
  }
  v11 = *(uint64_t (**)(uint64_t, _QWORD *, uint64_t, uint64_t, BN_CTX *))(*(_QWORD *)a1 + 136);
  if (!v11)
  {
    v12 = 66;
    v13 = 86;
    goto LABEL_7;
  }
  if (*(_QWORD *)a1 != *a2)
  {
    v12 = 101;
    v13 = 90;
LABEL_7:
    ERR_put_error(16, 4095, v12, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_oct.c", v13);
LABEL_8:
    v14 = 0;
    goto LABEL_10;
  }
  v14 = v11(a1, a2, a3, a4, v10);
LABEL_10:
  if (v10 != a5)
    BN_CTX_free(v10);
  return v14;
}

size_t EC_POINT_point2oct(const EC_GROUP *a1, const EC_POINT *a2, point_conversion_form_t form, unsigned __int8 *buf, size_t len, BN_CTX *a6)
{
  uint64_t v9;
  BN_CTX *v12;
  uint64_t (*v13)(const EC_GROUP *, const EC_POINT *, uint64_t, unsigned __int8 *, size_t, BN_CTX *);
  int v14;
  int v15;
  size_t v16;

  v9 = *(_QWORD *)&form;
  v12 = a6;
  if (!a6)
  {
    v12 = BN_CTX_new();
    if (!v12)
      goto LABEL_8;
  }
  v13 = *(uint64_t (**)(const EC_GROUP *, const EC_POINT *, uint64_t, unsigned __int8 *, size_t, BN_CTX *))(*(_QWORD *)a1 + 144);
  if (!v13)
  {
    v14 = 66;
    v15 = 124;
    goto LABEL_7;
  }
  if (*(_QWORD *)a1 != *(_QWORD *)a2)
  {
    v14 = 101;
    v15 = 128;
LABEL_7:
    ERR_put_error(16, 4095, v14, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_oct.c", v15);
LABEL_8:
    v16 = 0;
    goto LABEL_10;
  }
  v16 = v13(a1, a2, v9, buf, len, v12);
LABEL_10:
  if (v12 != a6)
    BN_CTX_free(v12);
  return v16;
}

int EC_POINT_oct2point(const EC_GROUP *a1, EC_POINT *a2, const unsigned __int8 *buf, size_t len, BN_CTX *a5)
{
  BN_CTX *v10;
  uint64_t (*v11)(const EC_GROUP *, EC_POINT *, const unsigned __int8 *, size_t, BN_CTX *);
  int v12;
  int v13;
  int v14;

  v10 = a5;
  if (!a5)
  {
    v10 = BN_CTX_new();
    if (!v10)
      goto LABEL_8;
  }
  v11 = *(uint64_t (**)(const EC_GROUP *, EC_POINT *, const unsigned __int8 *, size_t, BN_CTX *))(*(_QWORD *)a1 + 152);
  if (!v11)
  {
    v12 = 66;
    v13 = 153;
    goto LABEL_7;
  }
  if (*(_QWORD *)a1 != *(_QWORD *)a2)
  {
    v12 = 101;
    v13 = 157;
LABEL_7:
    ERR_put_error(16, 4095, v12, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_oct.c", v13);
LABEL_8:
    v14 = 0;
    goto LABEL_10;
  }
  v14 = v11(a1, a2, buf, len, v10);
LABEL_10:
  if (v10 != a5)
    BN_CTX_free(v10);
  return v14;
}

uint64_t cmac_size()
{
  return 32;
}

void cmac_key_free(uint64_t a1)
{
  CMAC_CTX_free(*(EVP_CIPHER_CTX **)(a1 + 32));
}

void *EVP_gostr341194()
{
  return &gostr341194_md;
}

uint64_t gostr341194_init(uint64_t a1)
{
  return GOSTR341194_Init(*(void **)(a1 + 24), 822);
}

uint64_t gostr341194_update(uint64_t a1, char *a2, size_t a3)
{
  return GOSTR341194_Update(*(_QWORD *)(a1 + 24), a2, a3);
}

uint64_t gostr341194_final(uint64_t a1, _OWORD *a2)
{
  return GOSTR341194_Final(a2, *(_QWORD *)(a1 + 24));
}

void *EVP_sm3()
{
  return &sm3_md;
}

uint64_t sm3_init(uint64_t a1)
{
  return SM3_Init(*(_OWORD **)(a1 + 24));
}

uint64_t sm3_update(uint64_t a1, char *a2, size_t a3)
{
  return SM3_Update(*(_QWORD *)(a1 + 24), a2, a3);
}

uint64_t sm3_final(uint64_t a1, _DWORD *a2)
{
  return SM3_Final(a2, *(unsigned int **)(a1 + 24));
}

X509_ALGOR *__cdecl d2i_X509_ALGOR(X509_ALGOR **a, const unsigned __int8 **in, uint64_t len)
{
  return (X509_ALGOR *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &X509_ALGOR_it);
}

int i2d_X509_ALGOR(X509_ALGOR *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &X509_ALGOR_it);
}

X509_ALGOR *X509_ALGOR_new(void)
{
  return (X509_ALGOR *)ASN1_item_new(&X509_ALGOR_it);
}

void X509_ALGOR_free(X509_ALGOR *a)
{
  ASN1_item_free((ASN1_VALUE *)a, &X509_ALGOR_it);
}

X509_ALGORS *__cdecl d2i_X509_ALGORS(X509_ALGORS **a, const unsigned __int8 **in, uint64_t len)
{
  return (X509_ALGORS *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &X509_ALGORS_it);
}

int i2d_X509_ALGORS(X509_ALGORS *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &X509_ALGORS_it);
}

X509_ALGOR *__cdecl X509_ALGOR_dup(X509_ALGOR *xn)
{
  return (X509_ALGOR *)ASN1_item_dup(&X509_ALGOR_it, xn);
}

int X509_ALGOR_set0(X509_ALGOR *alg, ASN1_OBJECT *aobj, int ptype, void *pval)
{
  X509_ALGOR *v7;
  ASN1_TYPE *parameter;

  if (alg)
  {
    v7 = alg;
    if (ptype == -1
      || alg->parameter
      || (alg = (X509_ALGOR *)ASN1_TYPE_new(), (v7->parameter = (ASN1_TYPE *)alg) != 0))
    {
      if (v7->algorithm)
        ASN1_OBJECT_free(v7->algorithm);
      v7->algorithm = aobj;
      if (ptype)
      {
        if (ptype == -1)
        {
          parameter = v7->parameter;
          if (parameter)
          {
            ASN1_TYPE_free(parameter);
            v7->parameter = 0;
          }
        }
        else
        {
          ASN1_TYPE_set(v7->parameter, ptype, pval);
        }
      }
      LODWORD(alg) = 1;
    }
  }
  return (int)alg;
}

void X509_ALGOR_get0(ASN1_OBJECT **paobj, int *pptype, void **ppval, X509_ALGOR *algor)
{
  ASN1_TYPE *parameter;

  if (paobj)
    *paobj = algor->algorithm;
  if (pptype)
  {
    parameter = algor->parameter;
    if (parameter)
    {
      *pptype = parameter->type;
      if (ppval)
        *ppval = parameter->value.ptr;
    }
    else
    {
      *pptype = -1;
    }
  }
}

uint64_t X509_ALGOR_set_md(X509_ALGOR *a1, const EVP_MD *a2)
{
  int v4;
  int v5;
  ASN1_OBJECT *v6;

  if ((EVP_MD_flags((uint64_t)a2) & 8) != 0)
    v4 = -1;
  else
    v4 = 5;
  v5 = EVP_MD_type(a2);
  v6 = OBJ_nid2obj(v5);
  return X509_ALGOR_set0(a1, v6, v4, 0);
}

uint64_t X509_ALGOR_cmp(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  const ASN1_OBJECT **v5;
  uint64_t v6;

  result = OBJ_cmp(*(const ASN1_OBJECT **)a1, *(const ASN1_OBJECT **)a2);
  if (!(_DWORD)result)
  {
    v5 = *(const ASN1_OBJECT ***)(a1 + 8);
    v6 = *(_QWORD *)(a2 + 8);
    if ((unint64_t)v5 | v6)
      return ASN1_TYPE_cmp(v5, v6);
    else
      return 0;
  }
  return result;
}

void CAST_ecb_encrypt(const unsigned __int8 *in, unsigned __int8 *out, const CAST_KEY *key, int enc)
{
  unsigned int v5;
  unint64_t v6[2];

  v6[1] = *MEMORY[0x24BDAC8D0];
  v6[0] = __PAIR64__(bswap32(*((_DWORD *)in + 1)), bswap32(*(_DWORD *)in));
  if (enc)
    CAST_encrypt(v6, key);
  else
    CAST_decrypt(v6, key);
  v5 = bswap32(HIDWORD(v6[0]));
  *(_DWORD *)out = bswap32(v6[0]);
  *((_DWORD *)out + 1) = v5;
}

uint64_t GostR3410_get_md_digest(uint64_t result)
{
  if ((_DWORD)result == 822)
    return 809;
  else
    return result;
}

uint64_t GostR3410_get_pk_digest(int a1)
{
  int v1;
  unsigned int v2;

  if (a1 == 941)
    v1 = 946;
  else
    v1 = 0;
  if (a1 == 942)
    v2 = 947;
  else
    v2 = v1;
  if (a1 == 822)
    return 811;
  else
    return v2;
}

uint64_t GostR3410_256_param_id(char *a1)
{
  uint64_t v2;

  v2 = 0;
  while (strcasecmp((&GostR3410_256_params)[v2], a1))
  {
    v2 += 2;
    if (v2 == 12)
      return 0;
  }
  return LODWORD((&GostR3410_256_params)[v2 + 1]);
}

uint64_t GostR3410_512_param_id(char *a1)
{
  uint64_t v2;

  v2 = 0;
  while (strcasecmp((&GostR3410_512_params)[v2], a1))
  {
    v2 += 2;
    if (v2 == 4)
      return 0;
  }
  return LODWORD((&GostR3410_512_params)[v2 + 1]);
}

unint64_t *idea_cfb64_encrypt(unint64_t *result, _BYTE *a2, uint64_t a3, unsigned int *a4, unsigned int *a5, int *a6, int a7)
{
  uint64_t v10;
  unint64_t *v12;
  int v13;
  uint64_t v14;
  unsigned int v15;
  char v16;
  char v17;
  uint64_t v18;
  unsigned int v19;
  char v20;
  char v21;
  unint64_t v22;
  uint64_t v23;
  uint64_t v24;

  v10 = a3;
  v12 = result;
  v24 = *MEMORY[0x24BDAC8D0];
  v13 = *a6;
  if (a7)
  {
    if (a3)
    {
      do
      {
        if (!v13)
        {
          v14 = bswap32(a5[1]);
          v22 = bswap32(*a5);
          v23 = v14;
          result = idea_encrypt(&v22, a4);
          v15 = bswap32(v23);
          *a5 = bswap32(v22);
          a5[1] = v15;
        }
        v16 = *(_BYTE *)v12;
        v12 = (unint64_t *)((char *)v12 + 1);
        v17 = *((_BYTE *)a5 + v13);
        *a2++ = v17 ^ v16;
        *((_BYTE *)a5 + v13) = v17 ^ v16;
        v13 = (v13 + 1) & 7;
        --v10;
      }
      while (v10);
    }
  }
  else if (a3)
  {
    do
    {
      if (!v13)
      {
        v18 = bswap32(a5[1]);
        v22 = bswap32(*a5);
        v23 = v18;
        result = idea_encrypt(&v22, a4);
        v19 = bswap32(v23);
        *a5 = bswap32(v22);
        a5[1] = v19;
      }
      v20 = *(_BYTE *)v12;
      v12 = (unint64_t *)((char *)v12 + 1);
      v21 = *((_BYTE *)a5 + v13);
      *((_BYTE *)a5 + v13) = v20;
      *a2++ = v21 ^ v20;
      v13 = (v13 + 1) & 7;
      --v10;
    }
    while (v10);
  }
  *a6 = v13;
  return result;
}

void DH_set_default_method(const DH_METHOD *meth)
{
  default_DH_method = (uint64_t)meth;
}

const DH_METHOD *DH_get_default_method(void)
{
  const DH_METHOD *result;

  result = (const DH_METHOD *)default_DH_method;
  if (!default_DH_method)
  {
    result = DH_OpenSSL();
    default_DH_method = (uint64_t)result;
  }
  return result;
}

int DH_set_method(DH *dh, const DH_METHOD *meth)
{
  void (*v4)(DH *);
  int (__cdecl *init)(DH *);

  v4 = *(void (**)(DH *))(*(_QWORD *)&dh->ex_data.dummy + 40);
  if (v4)
    v4(dh);
  ENGINE_finish((ENGINE *)dh->meth);
  *(_QWORD *)&dh->ex_data.dummy = meth;
  dh->meth = 0;
  init = meth->init;
  if (init)
    ((void (*)(DH *))init)(dh);
  return 1;
}

DH *DH_new(void)
{
  return DH_new_method(0);
}

DH *__cdecl DH_new_method(ENGINE *engine)
{
  char *v2;
  const DH_METHOD *v3;
  const DH_METHOD *DH;
  unsigned int (*v5)(char *);

  v2 = (char *)malloc_type_malloc(0x88uLL, 0x1070040C1BEA720uLL);
  if (!v2)
  {
    ERR_put_error(5, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/dh/dh_lib.c", 125);
    return (DH *)v2;
  }
  v3 = (const DH_METHOD *)default_DH_method;
  if (!default_DH_method)
  {
    v3 = DH_OpenSSL();
    default_DH_method = (uint64_t)v3;
  }
  *((_QWORD *)v2 + 15) = v3;
  if (engine)
  {
    if (!ENGINE_init(engine))
    {
      ERR_put_error(5, 4095, 38, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/dh/dh_lib.c", 133);
      goto LABEL_16;
    }
    *((_QWORD *)v2 + 16) = engine;
    goto LABEL_9;
  }
  engine = ENGINE_get_default_DH();
  *((_QWORD *)v2 + 16) = engine;
  if (engine)
  {
LABEL_9:
    DH = ENGINE_get_DH(engine);
    *((_QWORD *)v2 + 15) = DH;
    if (!DH)
    {
      ERR_put_error(5, 4095, 38, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/dh/dh_lib.c", 143);
      ENGINE_finish(*((ENGINE **)v2 + 16));
LABEL_16:
      free(v2);
      return 0;
    }
    goto LABEL_13;
  }
  DH = (const DH_METHOD *)*((_QWORD *)v2 + 15);
LABEL_13:
  *((_QWORD *)v2 + 12) = 0;
  *(_OWORD *)v2 = 0u;
  *((_OWORD *)v2 + 1) = 0u;
  *((_OWORD *)v2 + 2) = 0u;
  *(_OWORD *)(v2 + 56) = 0u;
  *(_OWORD *)(v2 + 72) = 0u;
  *((_DWORD *)v2 + 22) = 0;
  *((_DWORD *)v2 + 26) = 1;
  *((_DWORD *)v2 + 12) = DH->flags & 0xFFFFFBFF;
  CRYPTO_new_ex_data(8, v2, (CRYPTO_EX_DATA *)v2 + 7);
  v5 = *(unsigned int (**)(char *))(*((_QWORD *)v2 + 15) + 32);
  if (v5 && !v5(v2))
  {
    ENGINE_finish(*((ENGINE **)v2 + 16));
    CRYPTO_free_ex_data(8, v2, (CRYPTO_EX_DATA *)v2 + 7);
    goto LABEL_16;
  }
  return (DH *)v2;
}

void DH_free(DH *dh)
{
  void (*v2)(DH *);

  if (dh && CRYPTO_add_lock(&dh->references, -1, 26, 0, 0) <= 0)
  {
    v2 = *(void (**)(DH *))(*(_QWORD *)&dh->ex_data.dummy + 40);
    if (v2)
      v2(dh);
    ENGINE_finish((ENGINE *)dh->meth);
    CRYPTO_free_ex_data(8, dh, &dh->ex_data);
    BN_free(dh->p);
    BN_free(dh->g);
    BN_free(dh->q);
    BN_free(dh->j);
    free(dh->seed);
    BN_free(dh->counter);
    BN_free(dh->pub_key);
    BN_free(dh->priv_key);
    free(dh);
  }
}

int DH_up_ref(DH *dh)
{
  return CRYPTO_add_lock(&dh->references, 1, 26, 0, 0) > 1;
}

int DH_get_ex_new_index(uint64_t argl, void *argp, CRYPTO_EX_new *new_func, CRYPTO_EX_dup *dup_func, CRYPTO_EX_free *free_func)
{
  return CRYPTO_get_ex_new_index(8, argl, argp, new_func, dup_func, free_func);
}

int DH_set_ex_data(DH *d, int idx, void *arg)
{
  return CRYPTO_set_ex_data(&d->ex_data, idx, arg);
}

void *__cdecl DH_get_ex_data(DH *d, int idx)
{
  return CRYPTO_get_ex_data(&d->ex_data, idx);
}

int DH_size(const DH *dh)
{
  int v1;
  int v2;

  v1 = BN_num_bits(dh->p);
  v2 = v1 + 7;
  if (v1 < -7)
    v2 = v1 + 14;
  return v2 >> 3;
}

uint64_t DH_bits(uint64_t a1)
{
  return BN_num_bits(*(const BIGNUM **)(a1 + 8));
}

uint64_t DH_security_bits(uint64_t a1)
{
  const BIGNUM *v2;
  int v3;
  int v4;

  v2 = *(const BIGNUM **)(a1 + 64);
  if (v2)
  {
    v3 = BN_num_bits(v2);
  }
  else if (*(uint64_t *)(a1 + 24) <= 0)
  {
    v3 = -1;
  }
  else
  {
    v3 = *(_QWORD *)(a1 + 24);
  }
  v4 = BN_num_bits(*(const BIGNUM **)(a1 + 8));
  return BN_security_bits(v4, v3);
}

uint64_t DH_get0_engine(uint64_t a1)
{
  return *(_QWORD *)(a1 + 128);
}

_QWORD *DH_get0_pqg(_QWORD *result, _QWORD *a2, _QWORD *a3, _QWORD *a4)
{
  if (a2)
    *a2 = result[1];
  if (a3)
    *a3 = result[8];
  if (a4)
    *a4 = result[2];
  return result;
}

uint64_t DH_set0_pqg(uint64_t a1, uint64_t a2, const BIGNUM *a3, uint64_t a4)
{
  BIGNUM *v5;

  v5 = *(BIGNUM **)(a1 + 8);
  if (!(a2 | (unint64_t)v5) || !(a4 | *(_QWORD *)(a1 + 16)))
    return 0;
  if (a2)
  {
    BN_free(v5);
    *(_QWORD *)(a1 + 8) = a2;
  }
  if (a3)
  {
    BN_free(*(BIGNUM **)(a1 + 64));
    *(_QWORD *)(a1 + 64) = a3;
    *(_QWORD *)(a1 + 24) = BN_num_bits(a3);
  }
  if (a4)
  {
    BN_free(*(BIGNUM **)(a1 + 16));
    *(_QWORD *)(a1 + 16) = a4;
  }
  return 1;
}

uint64_t DH_get0_key(uint64_t result, _QWORD *a2, _QWORD *a3)
{
  if (a2)
    *a2 = *(_QWORD *)(result + 32);
  if (a3)
    *a3 = *(_QWORD *)(result + 40);
  return result;
}

uint64_t DH_set0_key(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a2)
  {
    BN_free(*(BIGNUM **)(a1 + 32));
    *(_QWORD *)(a1 + 32) = a2;
  }
  if (a3)
  {
    BN_free(*(BIGNUM **)(a1 + 40));
    *(_QWORD *)(a1 + 40) = a3;
  }
  return 1;
}

uint64_t DH_get0_p(uint64_t a1)
{
  return *(_QWORD *)(a1 + 8);
}

uint64_t DH_get0_q(uint64_t a1)
{
  return *(_QWORD *)(a1 + 64);
}

uint64_t DH_get0_g(uint64_t a1)
{
  return *(_QWORD *)(a1 + 16);
}

uint64_t DH_get0_priv_key(uint64_t a1)
{
  return *(_QWORD *)(a1 + 40);
}

uint64_t DH_get0_pub_key(uint64_t a1)
{
  return *(_QWORD *)(a1 + 32);
}

uint64_t DH_clear_flags(uint64_t result, int a2)
{
  *(_DWORD *)(result + 48) &= ~a2;
  return result;
}

uint64_t DH_test_flags(uint64_t a1, unsigned int a2)
{
  return *(_DWORD *)(a1 + 48) & a2;
}

uint64_t DH_set_flags(uint64_t result, int a2)
{
  *(_DWORD *)(result + 48) |= a2;
  return result;
}

uint64_t DH_get_length(uint64_t a1)
{
  return *(_QWORD *)(a1 + 24);
}

uint64_t DH_set_length(uint64_t a1, unint64_t a2)
{
  if (a2 >> 31)
    return 0;
  *(_QWORD *)(a1 + 24) = a2;
  return 1;
}

int EVP_add_cipher(const EVP_CIPHER *cipher)
{
  const char *v2;
  const char *v3;

  if (!cipher)
    return 0;
  v2 = OBJ_nid2sn(cipher->nid);
  if (!OBJ_NAME_add(v2, 2, (const char *)cipher))
    return 0;
  check_defer(cipher->nid);
  v3 = OBJ_nid2ln(cipher->nid);
  return OBJ_NAME_add(v3, 2, (const char *)cipher);
}

int EVP_add_digest(const EVP_MD *digest)
{
  const char *v2;
  int result;
  const char *v4;
  int pkey_type;
  const char *v6;
  const char *v7;

  v2 = OBJ_nid2sn(digest->type);
  result = OBJ_NAME_add(v2, 1, (const char *)digest);
  if (result)
  {
    check_defer(digest->type);
    v4 = OBJ_nid2ln(digest->type);
    result = OBJ_NAME_add(v4, 1, (const char *)digest);
    if (result)
    {
      pkey_type = digest->pkey_type;
      if (pkey_type)
      {
        if (digest->type != pkey_type)
        {
          v6 = OBJ_nid2sn(digest->pkey_type);
          result = OBJ_NAME_add(v6, 32769, v2);
          if (result)
          {
            check_defer(digest->pkey_type);
            v7 = OBJ_nid2ln(digest->pkey_type);
            return OBJ_NAME_add(v7, 32769, v2);
          }
        }
      }
    }
  }
  return result;
}

const EVP_CIPHER *__cdecl EVP_get_cipherbyname(const char *name)
{
  if (OPENSSL_init_crypto(0))
    return (const EVP_CIPHER *)OBJ_NAME_get(name, 2);
  else
    return 0;
}

const EVP_MD *__cdecl EVP_get_digestbyname(const char *name)
{
  if (OPENSSL_init_crypto(0))
    return (const EVP_MD *)OBJ_NAME_get(name, 1);
  else
    return 0;
}

void EVP_cleanup(void)
{
  OBJ_NAME_cleanup(2);
  OBJ_NAME_cleanup(1);
  OBJ_NAME_cleanup(-1);
  EVP_PBE_cleanup();
  if (obj_cleanup_defer == 2)
  {
    obj_cleanup_defer = 0;
    OBJ_cleanup();
  }
  OBJ_sigid_free();
}

void EVP_CIPHER_do_all(uint64_t a1, uint64_t a2)
{
  _QWORD v4[2];

  OPENSSL_init_crypto(0);
  v4[0] = a2;
  v4[1] = a1;
  OBJ_NAME_do_all(2, (void (__cdecl *)(const OBJ_NAME *, void *))do_all_cipher_fn, v4);
}

uint64_t do_all_cipher_fn(uint64_t a1, uint64_t *a2)
{
  uint64_t v2;
  uint64_t (*v3)(_QWORD, _QWORD, _QWORD, uint64_t);

  v2 = *a2;
  v3 = (uint64_t (*)(_QWORD, _QWORD, _QWORD, uint64_t))a2[1];
  if (*(_DWORD *)(a1 + 4))
    return v3(0, *(_QWORD *)(a1 + 8), *(_QWORD *)(a1 + 16), v2);
  else
    return v3(*(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 8), 0, v2);
}

void EVP_CIPHER_do_all_sorted(uint64_t a1, uint64_t a2)
{
  _QWORD v4[2];

  OPENSSL_init_crypto(0);
  v4[0] = a2;
  v4[1] = a1;
  OBJ_NAME_do_all_sorted(2, (void (__cdecl *)(const OBJ_NAME *, void *))do_all_cipher_fn, v4);
}

void EVP_MD_do_all(uint64_t a1, uint64_t a2)
{
  _QWORD v4[2];

  OPENSSL_init_crypto(0);
  v4[0] = a2;
  v4[1] = a1;
  OBJ_NAME_do_all(1, (void (__cdecl *)(const OBJ_NAME *, void *))do_all_md_fn, v4);
}

uint64_t do_all_md_fn(uint64_t a1, uint64_t *a2)
{
  uint64_t v2;
  uint64_t (*v3)(_QWORD, _QWORD, _QWORD, uint64_t);

  v2 = *a2;
  v3 = (uint64_t (*)(_QWORD, _QWORD, _QWORD, uint64_t))a2[1];
  if (*(_DWORD *)(a1 + 4))
    return v3(0, *(_QWORD *)(a1 + 8), *(_QWORD *)(a1 + 16), v2);
  else
    return v3(*(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 8), 0, v2);
}

void EVP_MD_do_all_sorted(uint64_t a1, uint64_t a2)
{
  _QWORD v4[2];

  OPENSSL_init_crypto(0);
  v4[0] = a2;
  v4[1] = a1;
  OBJ_NAME_do_all_sorted(1, (void (__cdecl *)(const OBJ_NAME *, void *))do_all_md_fn, v4);
}

void ERR_load_OCSP_strings(void)
{
  if (!ERR_func_error_string(OCSP_str_functs))
  {
    ERR_load_strings(0, (ERR_STRING_DATA *)&OCSP_str_functs);
    ERR_load_strings(0, (ERR_STRING_DATA *)&OCSP_str_reasons);
  }
}

int PKCS12_key_gen_asc(const char *pass, int passlen, unsigned __int8 *salt, int saltlen, int id, int iter, int n, unsigned __int8 *out, const EVP_MD *md_type)
{
  int v15;
  int result;
  int v17;
  unsigned __int8 *passa;

  passa = 0;
  v17 = 0;
  if (pass)
  {
    if (!OPENSSL_asc2uni((char *)pass, passlen, &passa, &v17))
    {
      ERR_put_error(35, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/pkcs12/p12_key.c", 86);
      return 0;
    }
    pass = (const char *)passa;
    v15 = v17;
  }
  else
  {
    v15 = 0;
    passa = 0;
    v17 = 0;
  }
  result = PKCS12_key_gen_uni((unsigned __int8 *)pass, v15, salt, saltlen, id, iter, n, out, md_type);
  if (result)
  {
    freezero(passa, v17);
    return 1;
  }
  return result;
}

int PKCS12_key_gen_uni(unsigned __int8 *pass, int passlen, unsigned __int8 *salt, int saltlen, int id, int iter, int n, unsigned __int8 *out, const EVP_MD *md_type)
{
  EVP_MD_CTX *v17;
  int v18;
  int v19;
  int v20;
  int v21;
  void *v22;
  void *v23;
  int v24;
  int v25;
  char *v26;
  char *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  void *v31;
  const EVP_MD *v32;
  int v33;
  int v34;
  BOOL v35;
  uint64_t v36;
  int64_t v37;
  char *v38;
  __int16 v39;
  uint64_t v40;
  __int16 v41;
  int v42;
  EVP_MD_CTX *ctx;
  int64_t cnt;
  char *v46;
  void *__b;
  unsigned __int8 *__dst;
  int v49;
  size_t __len;
  int v51;
  int __c;

  v17 = (EVP_MD_CTX *)EVP_MD_CTX_new();
  if (!v17
    || (__c = id, v18 = EVP_MD_block_size(md_type), v18 < 1)
    || (v19 = v18, v51 = iter, v20 = EVP_MD_size(md_type), v20 < 1))
  {
    v31 = 0;
    v22 = 0;
LABEL_43:
    v26 = 0;
    v23 = 0;
    goto LABEL_44;
  }
  v21 = v20;
  v49 = n;
  __len = v19;
  v22 = malloc_type_malloc(v19, 0x5D2391B5uLL);
  if (!v22)
  {
    v31 = 0;
    goto LABEL_43;
  }
  __dst = out;
  v23 = malloc_type_malloc(v21, 0x5604AAD5uLL);
  if (!v23 || (v46 = (char *)malloc_type_malloc((v19 + 1), 0xB4D0AFD2uLL)) == 0)
  {
    v31 = 0;
    v26 = 0;
    goto LABEL_44;
  }
  __b = v22;
  ctx = v17;
  v24 = (saltlen + v19 - 1) / v19 * v19;
  if (passlen)
    v25 = (passlen + v19 - 1) / v19 * v19;
  else
    v25 = 0;
  cnt = v25 + v24;
  v26 = (char *)malloc_type_malloc(cnt, 0xC0C787ECuLL);
  if (!v26)
  {
    v17 = ctx;
LABEL_49:
    v31 = v46;
    v22 = __b;
    goto LABEL_44;
  }
  memset(__b, __c, v19);
  v27 = v26;
  if (v24 >= 1)
  {
    v28 = 0;
    do
    {
      v26[v28] = salt[(int)v28 % saltlen];
      ++v28;
    }
    while (v24 != (_DWORD)v28);
    v27 = &v26[v28];
  }
  if (v25 >= 1)
  {
    v29 = 0;
    do
    {
      v27[v29] = pass[(int)v29 % passlen];
      ++v29;
    }
    while (v25 != (_DWORD)v29);
  }
  v17 = ctx;
  if (!EVP_DigestInit_ex(ctx, md_type, 0))
    goto LABEL_49;
  v30 = v19;
  v31 = v46;
  v22 = __b;
  v32 = md_type;
  while (EVP_DigestUpdate(ctx, v22, __len)
       && EVP_DigestUpdate(ctx, v26, cnt)
       && EVP_DigestFinal_ex(ctx, (unsigned __int8 *)v23, 0))
  {
    v33 = v51 - 1;
    if (v51 >= 2)
    {
      while (EVP_DigestInit_ex(ctx, v32, 0)
           && EVP_DigestUpdate(ctx, v23, v21)
           && EVP_DigestFinal_ex(ctx, (unsigned __int8 *)v23, 0))
      {
        if (!--v33)
          goto LABEL_28;
      }
      v22 = __b;
      break;
    }
LABEL_28:
    if (v49 >= v21)
      v34 = v21;
    else
      v34 = v49;
    memcpy(__dst, v23, v34);
    v35 = v49 <= v21;
    v49 -= v21;
    v22 = __b;
    if (v35)
    {
      v42 = 1;
      goto LABEL_45;
    }
    v36 = 0;
    __dst += v21;
    do
    {
      v46[v36] = *((_BYTE *)v23 + ((int)v36 % v21));
      ++v36;
    }
    while (__len != v36);
    v32 = md_type;
    if ((int)cnt >= 1)
    {
      v37 = 0;
      v38 = v26 - 1;
      do
      {
        v39 = 1;
        v40 = v30;
        do
        {
          v41 = v39 + v38[v40] + v46[v40 - 1];
          v38[v40] = v41;
          v39 = HIBYTE(v41);
          v35 = v40-- <= 1;
        }
        while (!v35);
        v37 += v30;
        v38 += v30;
      }
      while (v37 < cnt);
    }
    if (!EVP_DigestInit_ex(ctx, md_type, 0))
      break;
  }
LABEL_44:
  ERR_put_error(35, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/pkcs12/p12_key.c", 186);
  v42 = 0;
LABEL_45:
  free(v23);
  free(v31);
  free(v22);
  free(v26);
  EVP_MD_CTX_free(v17);
  return v42;
}

void AES_cbc_encrypt(const unsigned __int8 *in, unsigned __int8 *out, const unint64_t length, const AES_KEY *key, unsigned __int8 *ivec, const int enc)
{
  if (enc)
    CRYPTO_cbc128_encrypt(in, out, length, (uint64_t)key, ivec, (void (*)(_QWORD *, _QWORD *, uint64_t))AES_encrypt);
  else
    CRYPTO_cbc128_decrypt((uint64_t)in, (uint64_t *)out, length, (uint64_t)key, ivec, (uint64_t (*)(_QWORD *, uint64_t *, uint64_t))AES_decrypt);
}

EVP_CIPHER_CTX *CMAC_CTX_new()
{
  EVP_CIPHER_CTX *v0;
  EVP_CIPHER_CTX *v1;

  v0 = (EVP_CIPHER_CTX *)malloc_type_malloc(0x130uLL, 0x10E0040F7627181uLL);
  v1 = v0;
  if (v0)
  {
    EVP_CIPHER_CTX_init(v0);
    v1[1].final_used = -1;
  }
  return v1;
}

uint64_t CMAC_CTX_cleanup(EVP_CIPHER_CTX *a1)
{
  uint64_t result;

  EVP_CIPHER_CTX_cleanup(a1);
  explicit_bzero(&a1[1].buf[8], 0x20uLL);
  explicit_bzero(&a1[1], 0x20uLL);
  explicit_bzero(&a1[1].oiv[8], 0x20uLL);
  result = explicit_bzero(&a1[1].app_data, 0x20uLL);
  a1[1].final_used = -1;
  return result;
}

void CMAC_CTX_free(EVP_CIPHER_CTX *a1)
{
  if (a1)
  {
    CMAC_CTX_cleanup(a1);
    free(a1);
  }
}

uint64_t CMAC_CTX_copy(EVP_CIPHER_CTX *a1, EVP_CIPHER_CTX *a2)
{
  uint64_t result;
  size_t v5;

  if (a2[1].final_used == -1)
    return 0;
  result = EVP_CIPHER_CTX_copy(a1, (uint64_t *)a2);
  if ((_DWORD)result)
  {
    v5 = EVP_CIPHER_CTX_block_size(a2);
    memcpy(&a1[1], &a2[1], v5);
    memcpy(&a1[1].oiv[8], &a2[1].oiv[8], v5);
    memcpy(&a1[1].buf[8], &a2[1].buf[8], v5);
    memcpy(&a1[1].app_data, &a2[1].app_data, v5);
    a1[1].final_used = a2[1].final_used;
    return 1;
  }
  return result;
}

const EVP_CIPHER *CMAC_Init(EVP_CIPHER_CTX *ctx, const unsigned __int8 *a2, uint64_t a3, EVP_CIPHER *cipher, ENGINE *impl)
{
  int v5;
  const EVP_CIPHER *result;
  int *p_final_used;
  int v10;
  int v11;
  int v12;

  v5 = a3;
  if (!a2 && !cipher && !a3 && !impl)
  {
    if (ctx[1].final_used == -1)
      return 0;
    result = (const EVP_CIPHER *)EVP_EncryptInit_ex(ctx, 0, 0, 0, CMAC_Init_zero_iv);
    if (!(_DWORD)result)
      return result;
    p_final_used = &ctx[1].final_used;
    v10 = EVP_CIPHER_CTX_block_size(ctx);
    bzero(&ctx[1].buf[8], v10);
    goto LABEL_8;
  }
  if (cipher)
  {
    v11 = EVP_EncryptInit_ex(ctx, cipher, impl, 0, 0);
    result = (const EVP_CIPHER *)(v11 != 0);
    if (!a2 || !v11)
      return result;
  }
  else if (!a2)
  {
    return (const EVP_CIPHER *)1;
  }
  result = EVP_CIPHER_CTX_cipher(ctx);
  if (result)
  {
    result = (const EVP_CIPHER *)EVP_CIPHER_CTX_set_key_length(ctx, v5);
    if ((_DWORD)result)
    {
      result = (const EVP_CIPHER *)EVP_EncryptInit_ex(ctx, 0, 0, a2, CMAC_Init_zero_iv);
      if ((_DWORD)result)
      {
        v12 = EVP_CIPHER_CTX_block_size(ctx);
        result = (const EVP_CIPHER *)EVP_Cipher(ctx, &ctx[1].buf[8], CMAC_Init_zero_iv, v12);
        if ((_DWORD)result)
        {
          make_kn((uint64_t)&ctx[1], (char *)&ctx[1].buf[8], v12);
          make_kn((uint64_t)&ctx[1].oiv[8], (char *)&ctx[1], v12);
          explicit_bzero(&ctx[1].buf[8], v12);
          result = (const EVP_CIPHER *)EVP_EncryptInit_ex(ctx, 0, 0, 0, CMAC_Init_zero_iv);
          if ((_DWORD)result)
          {
            bzero(&ctx[1].buf[8], v12);
            p_final_used = &ctx[1].final_used;
LABEL_8:
            *p_final_used = 0;
            return (const EVP_CIPHER *)1;
          }
        }
      }
    }
  }
  return result;
}

uint64_t make_kn(uint64_t result, char *a2, int a3)
{
  unint64_t i;
  char v4;
  char v5;

  if (a3 >= 1)
  {
    for (i = 0; i != a3; ++i)
    {
      v4 = 2 * a2[i];
      *(_BYTE *)(result + i) = v4;
      if (i < (a3 - 1) && a2[i + 1] < 0)
        *(_BYTE *)(result + i) = v4 | 1;
    }
  }
  if (*a2 < 0)
  {
    if (a3 == 16)
      v5 = -121;
    else
      v5 = 27;
    *(_BYTE *)(result + a3 - 1) ^= v5;
  }
  return result;
}

uint64_t CMAC_Update(uint64_t a1, char *a2, size_t a3)
{
  size_t v3;
  int v6;
  size_t v7;
  uint64_t v8;
  size_t v9;
  uint64_t result;

  if (*(_DWORD *)(a1 + 296) == -1)
    return 0;
  v3 = a3;
  if (!a3)
    return 1;
  v6 = EVP_CIPHER_CTX_block_size((const EVP_CIPHER_CTX *)a1);
  v7 = v6;
  v8 = *(unsigned int *)(a1 + 296);
  if ((int)v8 >= 1)
  {
    if (v6 - v8 >= v3)
      v9 = v3;
    else
      v9 = v6 - v8;
    memcpy((void *)(a1 + 264 + v8), a2, v9);
    *(_DWORD *)(a1 + 296) += v9;
    v3 -= v9;
    if (!v3)
      return 1;
    result = EVP_Cipher((EVP_CIPHER_CTX *)a1, (unsigned __int8 *)(a1 + 232), (const unsigned __int8 *)(a1 + 264), v7);
    if (!(_DWORD)result)
      return result;
    a2 += v9;
  }
  if (v3 <= v7)
  {
LABEL_13:
    memcpy((void *)(a1 + 264), a2, v3);
    *(_DWORD *)(a1 + 296) = v3;
    return 1;
  }
  while (1)
  {
    result = EVP_Cipher((EVP_CIPHER_CTX *)a1, (unsigned __int8 *)(a1 + 232), (const unsigned __int8 *)a2, v7);
    if (!(_DWORD)result)
      return result;
    v3 -= v7;
    a2 += v7;
    if (v3 <= v7)
      goto LABEL_13;
  }
}

uint64_t CMAC_Final(EVP_CIPHER_CTX *a1, unsigned __int8 *a2, size_t *a3)
{
  size_t v6;
  uint64_t final_used;
  uint64_t v8;
  _BYTE *p_app_data;
  unsigned __int8 *v10;
  char *v11;
  int v12;
  uint64_t v13;
  _BYTE *v14;
  unsigned __int8 *v15;

  if (a1[1].final_used != -1)
  {
    v6 = EVP_CIPHER_CTX_block_size(a1);
    *a3 = v6;
    if (!a2)
      return 1;
    final_used = a1[1].final_used;
    if ((_DWORD)v6 == (_DWORD)final_used)
    {
      if ((int)v6 >= 1)
      {
        v8 = v6;
        p_app_data = &a1[1].app_data;
        v10 = a2;
        do
        {
          *v10++ = *(p_app_data - 96) ^ *p_app_data;
          ++p_app_data;
          --v8;
        }
        while (v8);
      }
    }
    else
    {
      v11 = (char *)a1 + final_used;
      *((_BYTE *)&a1[1].app_data + final_used) = 0x80;
      v12 = v6 - final_used;
      if (v12 > 1)
        bzero(v11 + 265, (v12 - 1));
      if ((int)v6 >= 1)
      {
        v13 = v6;
        v14 = &a1[1].app_data;
        v15 = a2;
        do
        {
          *v15++ = *(v14 - 64) ^ *v14;
          ++v14;
          --v13;
        }
        while (v13);
      }
    }
    if (EVP_Cipher(a1, a2, a2, v6))
      return 1;
    explicit_bzero(a2, v6);
  }
  return 0;
}

uint64_t CMAC_resume(EVP_CIPHER_CTX *a1)
{
  if (a1[1].final_used == -1)
    return 0;
  else
    return EVP_EncryptInit_ex(a1, 0, 0, 0, &a1[1].buf[8]);
}

ASN1_STRING *ASN1_STRING_new(void)
{
  return ASN1_STRING_type_new(4);
}

ASN1_STRING *__cdecl ASN1_STRING_type_new(int type)
{
  ASN1_STRING *v2;
  ASN1_STRING *v3;

  v2 = (ASN1_STRING *)malloc_type_calloc(1uLL, 0x18uLL, 0x1010040A500212DuLL);
  v3 = v2;
  if (v2)
    v2->type = type;
  else
    ERR_put_error(13, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/a_string.c", 80);
  return v3;
}

void ASN1_STRING_free(ASN1_STRING *a)
{
  if (a)
  {
    ASN1_STRING_clear(&a->length);
    free(a);
  }
}

void ASN1_STRING_clear(int *a1)
{
  uint64_t v2;

  v2 = *((_QWORD *)a1 + 2);
  if ((v2 & 0x10) == 0)
  {
    freezero(*((void **)a1 + 1), *a1);
    v2 = *((_QWORD *)a1 + 2);
  }
  *((_QWORD *)a1 + 1) = 0;
  *((_QWORD *)a1 + 2) = v2 & 0xFFFFFFFFFFFFFFEFLL;
  *a1 = 0;
}

int ASN1_STRING_cmp(ASN1_STRING *a, ASN1_STRING *b)
{
  int result;
  size_t length;

  result = -1;
  if (a)
  {
    if (b)
    {
      length = a->length;
      result = length - b->length;
      if ((_DWORD)length == b->length)
      {
        result = memcmp(a->data, b->data, length);
        if (!result)
          return a->type - b->type;
      }
    }
  }
  return result;
}

uint64_t ASN1_STRING_copy(ASN1_STRING *a1, uint64_t a2)
{
  uint64_t result;

  if (!a2)
    return 0;
  result = ASN1_STRING_set(a1, *(const void **)(a2 + 8), *(_DWORD *)a2);
  if ((_DWORD)result)
  {
    a1->type = *(_DWORD *)(a2 + 4);
    a1->flags = *(_QWORD *)(a2 + 16) & 0xFFFFFFFFFFFFFFEFLL;
    return 1;
  }
  return result;
}

int ASN1_STRING_set(ASN1_STRING *str, const void *data, int len)
{
  unsigned int v3;
  unsigned __int8 *v6;
  size_t v8;

  v3 = len;
  if (len == -1)
  {
    if (!data)
      return 0;
    v8 = strlen((const char *)data);
    v3 = v8;
    if (v8 >> 31)
      return 0;
  }
  ASN1_STRING_clear(&str->length);
  if (v3 > 0x7FFFFFFE)
    return 0;
  v6 = (unsigned __int8 *)malloc_type_calloc(1uLL, v3 + 1, 0x7D32741AuLL);
  str->data = v6;
  if (!v6)
  {
    ERR_put_error(13, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/a_string.c", 180);
    return 0;
  }
  str->length = v3;
  if (data)
  {
    memcpy(v6, data, v3);
    str->data[v3] = 0;
  }
  return 1;
}

ASN1_STRING *__cdecl ASN1_STRING_dup(ASN1_STRING *a)
{
  ASN1_STRING *v2;
  ASN1_STRING *v3;

  if (!a)
    return 0;
  v2 = ASN1_STRING_type_new(4);
  v3 = v2;
  if (v2 && !ASN1_STRING_copy(v2, (uint64_t)a))
  {
    ASN1_STRING_clear(&v3->length);
    free(v3);
    return 0;
  }
  return v3;
}

void ASN1_STRING_set0(ASN1_STRING *str, void *data, int len)
{
  ASN1_STRING_clear(&str->length);
  str->data = (unsigned __int8 *)data;
  str->length = len;
}

int ASN1_STRING_length(ASN1_STRING *x)
{
  return x->length;
}

void ASN1_STRING_length_set(ASN1_STRING *x, int n)
{
  x->length = n;
}

int ASN1_STRING_type(ASN1_STRING *x)
{
  return x->type;
}

unsigned __int8 *__cdecl ASN1_STRING_data(ASN1_STRING *x)
{
  return x->data;
}

uint64_t ASN1_STRING_get0_data(uint64_t a1)
{
  return *(_QWORD *)(a1 + 8);
}

int ASN1_STRING_print(BIO *bp, ASN1_STRING *v)
{
  int length;
  uint64_t v5;
  int v6;
  unsigned __int8 *v7;
  char v8;
  char v9;
  _BYTE data[80];
  uint64_t v12;

  v12 = *MEMORY[0x24BDAC8D0];
  if (!v)
    return 0;
  length = v->length;
  if (v->length < 1)
    return 1;
  v5 = 0;
  v6 = 0;
  v7 = v->data;
  do
  {
    v8 = v7[v5];
    if (v8 == 127)
    {
      v8 = 46;
    }
    else
    {
      if (v8 == 10)
        v9 = 10;
      else
        v9 = 46;
      if (v8 == 13)
        v9 = 13;
      if (v8 <= 31)
        v8 = v9;
    }
    data[v6] = v8;
    if (v6 < 79)
    {
      ++v6;
    }
    else
    {
      if (BIO_write(bp, data, v6 + 1) < 1)
        return 0;
      v6 = 0;
      length = v->length;
    }
    ++v5;
  }
  while (v5 < length);
  return v6 < 1 || BIO_write(bp, data, v6) >= 1;
}

int ASN1_STRING_to_UTF8(unsigned __int8 **out, ASN1_STRING *in)
{
  int length;
  int v5;
  int v6;
  ASN1_STRING *v7;
  ASN1_STRING *outa;

  outa = 0;
  length = -1;
  if (out)
  {
    if (in)
    {
      v5 = asn1_tag2charwidth(in->type);
      if (v5 != -1)
      {
        v6 = ASN1_mbstring_copy(&outa, in->data, in->length, v5 | 0x1000, 0x2000uLL);
        v7 = outa;
        if ((v6 & 0x80000000) == 0)
        {
          *out = outa->data;
          length = v7->length;
          v7->data = 0;
          v7->length = 0;
LABEL_7:
          ASN1_STRING_clear(&v7->length);
          free(v7);
          return length;
        }
        length = v6;
        if (outa)
          goto LABEL_7;
      }
    }
  }
  return length;
}

int i2a_ASN1_STRING(BIO *bp, ASN1_STRING *a, int type)
{
  uint64_t v5;
  int v6;
  unsigned __int8 *v7;
  _BYTE data[2];

  if (!a)
    return 0;
  if (a->length)
  {
    if (a->length >= 1)
    {
      v5 = 0;
      v6 = 0;
      while (1)
      {
        if (v5 && !(v5 % 0x23))
        {
          if (BIO_write(bp, "\\\n", 2) != 2)
            return -1;
          v6 += 2;
        }
        v7 = a->data;
        data[0] = i2a_ASN1_STRING_h[(unint64_t)v7[v5] >> 4];
        data[1] = i2a_ASN1_STRING_h[v7[v5] & 0xF];
        if (BIO_write(bp, data, 2) != 2)
          break;
        v6 += 2;
        if (++v5 >= a->length)
          return v6;
      }
      return -1;
    }
    return 0;
  }
  v6 = 1;
  if (BIO_write(bp, "0", 1) != 1)
    return -1;
  return v6;
}

int a2i_ASN1_STRING(BIO *bp, ASN1_STRING *bs, char *buf, int size)
{
  int v8;
  unint64_t v9;
  uint64_t v10;
  unsigned __int8 *v11;
  uint64_t v12;
  int v13;
  unsigned int v14;
  unsigned int v15;
  int v16;
  unsigned int v17;
  uint64_t v18;
  int v19;
  unsigned __int8 *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  char v24;
  char v25;
  int v26;
  char v27;
  int v28;
  int v29;
  int v31;
  int v32;
  ASN1_STRING *v33;
  int sizea;

  v8 = BIO_gets(bp, buf, size);
  if (v8 < 1)
  {
    v20 = 0;
    v19 = 0;
    goto LABEL_36;
  }
  v33 = bs;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  sizea = size;
  while (2)
  {
    v12 = (v8 - 1);
    v13 = v12;
    if (buf[v12] == 10)
    {
      buf[v12] = 0;
      if (v8 == 1)
        goto LABEL_37;
      v12 = (v8 - 2);
      v14 = v8 - 2;
    }
    else
    {
      v14 = v8 - 1;
      v13 = v8;
    }
    if (buf[v12] == 13)
    {
      buf[v12] = 0;
      if (v14)
      {
        v12 = v14 - 1;
        v15 = v14 - 1;
        goto LABEL_11;
      }
LABEL_37:
      v20 = v11;
      goto LABEL_38;
    }
    v15 = v14;
    v14 = v13;
LABEL_11:
    v16 = buf[v12];
    if (v16 == 92)
      v17 = v15;
    else
      v17 = v14;
    buf[v17] = 0;
    if (v17 < 2)
      goto LABEL_37;
    if ((v17 & 1) != 0)
    {
      v31 = 145;
      v32 = 384;
      goto LABEL_40;
    }
    v18 = v17 >> 1;
    v19 = v10 + v18;
    if (v10 + v18 <= v9)
    {
      v20 = v11;
    }
    else
    {
      v20 = (unsigned __int8 *)malloc_type_realloc(v11, v10 + v18, 0xAA819642uLL);
      v9 = v10 + v18;
      if (!v20)
      {
        v31 = 65;
        v32 = 391;
LABEL_40:
        ERR_put_error(13, 4095, v31, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/a_string.c", v32);
LABEL_34:
        free(v11);
        return 0;
      }
    }
    v21 = 0;
    v22 = 0;
    while (2)
    {
      v23 = 0;
      v24 = 1;
      do
      {
        v25 = v24;
        v26 = buf[v23 | v22];
        v27 = v26 - 48;
        if ((v26 - 48) >= 0xA)
        {
          if ((v26 - 97) > 5)
          {
            if ((v26 - 65) > 5)
            {
              v28 = 141;
              v29 = 407;
              goto LABEL_33;
            }
            v27 = v26 - 55;
          }
          else
          {
            v27 = v26 - 87;
          }
        }
        v24 = 0;
        v20[v10 + v21] = v27 | (16 * v20[v10 + v21]);
        v23 = 1;
      }
      while ((v25 & 1) != 0);
      ++v21;
      v22 += 2;
      if (v21 != v18)
        continue;
      break;
    }
    if (v16 == 92)
    {
      v8 = BIO_gets(bp, buf, sizea);
      v10 += v18;
      v11 = v20;
      if (v8 >= 1)
        continue;
LABEL_38:
      v28 = 150;
      v29 = 426;
LABEL_33:
      ERR_put_error(13, 4095, v28, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/a_string.c", v29);
      v11 = v20;
      goto LABEL_34;
    }
    break;
  }
  bs = v33;
LABEL_36:
  bs->length = v19;
  bs->data = v20;
  return 1;
}

DSA_SIG *__cdecl d2i_DSA_SIG(DSA_SIG **v, const unsigned __int8 **pp, uint64_t length)
{
  return (DSA_SIG *)ASN1_item_d2i((ASN1_VALUE **)v, pp, length, &DSA_SIG_it);
}

int i2d_DSA_SIG(const DSA_SIG *a, unsigned __int8 **pp)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, pp, &DSA_SIG_it);
}

_QWORD *DSA_SIG_get0(_QWORD *result, _QWORD *a2, _QWORD *a3)
{
  if (a2)
    *a2 = *result;
  if (a3)
    *a3 = result[1];
  return result;
}

uint64_t DSA_SIG_set0(BIGNUM **a1, BIGNUM *a2, BIGNUM *a3)
{
  uint64_t result;

  result = 0;
  if (a2)
  {
    if (a3)
    {
      BN_free(*a1);
      *a1 = a2;
      BN_free(a1[1]);
      a1[1] = a3;
      return 1;
    }
  }
  return result;
}

DSA *__cdecl d2i_DSAPrivateKey(DSA **a, const unsigned __int8 **pp, uint64_t length)
{
  return (DSA *)ASN1_item_d2i((ASN1_VALUE **)a, pp, length, &DSAPrivateKey_it);
}

int i2d_DSAPrivateKey(const DSA *a, unsigned __int8 **pp)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, pp, &DSAPrivateKey_it);
}

DSA *__cdecl d2i_DSAparams(DSA **a, const unsigned __int8 **pp, uint64_t length)
{
  return (DSA *)ASN1_item_d2i((ASN1_VALUE **)a, pp, length, &DSAparams_it);
}

int i2d_DSAparams(const DSA *a, unsigned __int8 **pp)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, pp, &DSAparams_it);
}

void *d2i_DSAparams_bio(BIO *in, void *x)
{
  return ASN1_item_d2i_bio(&DSAparams_it, in, x);
}

uint64_t i2d_DSAparams_bio(BIO *out, void *x)
{
  return ASN1_item_i2d_bio(&DSAparams_it, out, x);
}

void *d2i_DSAparams_fp(FILE *in, void *x)
{
  return ASN1_item_d2i_fp(&DSAparams_it, in, x);
}

uint64_t i2d_DSAparams_fp(FILE *out, void *x)
{
  return ASN1_item_i2d_fp(&DSAparams_it, out, x);
}

DSA *__cdecl d2i_DSAPublicKey(DSA **a, const unsigned __int8 **pp, uint64_t length)
{
  return (DSA *)ASN1_item_d2i((ASN1_VALUE **)a, pp, length, &DSAPublicKey_it);
}

int i2d_DSAPublicKey(const DSA *a, unsigned __int8 **pp)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, pp, &DSAPublicKey_it);
}

void *DSAparams_dup(void *x)
{
  return ASN1_item_dup(&DSAparams_it, x);
}

int DSA_sign(int type, const unsigned __int8 *dgst, int dlen, unsigned __int8 *sig, unsigned int *siglen, DSA *dsa)
{
  ASN1_VALUE *v7;
  DSA_SIG *v8;
  unsigned int v9;
  int v10;
  unsigned __int8 *out;

  out = sig;
  *siglen = 0;
  v7 = (ASN1_VALUE *)DSA_do_sign(dgst, dlen, dsa);
  v8 = (DSA_SIG *)v7;
  if (!v7 || (v9 = ASN1_item_i2d(v7, &out, &DSA_SIG_it), (v9 & 0x80000000) != 0))
  {
    v10 = 0;
  }
  else
  {
    *siglen = v9;
    v10 = 1;
  }
  DSA_SIG_free(v8);
  return v10;
}

int DSA_verify(int type, const unsigned __int8 *dgst, int dgst_len, const unsigned __int8 *sigbuf, int siglen, DSA *dsa)
{
  size_t v11;
  ASN1_VALUE *v12;
  DSA_SIG *v13;
  int v14;
  unsigned __int8 *v15;
  int v16;
  const unsigned __int8 *v18;
  unsigned __int8 *out;

  v18 = sigbuf;
  out = 0;
  v11 = siglen;
  v12 = ASN1_item_d2i(0, &v18, siglen, &DSA_SIG_it);
  v13 = (DSA_SIG *)v12;
  if (!v12)
  {
    v15 = 0;
LABEL_6:
    v16 = -1;
    goto LABEL_7;
  }
  v14 = ASN1_item_i2d(v12, &out, &DSA_SIG_it);
  v15 = out;
  if (v14 != siglen || memcmp(out, sigbuf, v11))
    goto LABEL_6;
  v16 = DSA_do_verify(dgst, dgst_len, v13, dsa);
  v15 = out;
LABEL_7:
  free(v15);
  DSA_SIG_free(v13);
  return v16;
}

uint64_t sig_cb(int a1, DSA_SIG **a2)
{
  DSA_SIG *v4;

  if (a1)
    return 1;
  v4 = DSA_SIG_new();
  if (v4)
  {
    *a2 = v4;
    return 2;
  }
  else
  {
    ERR_put_error(10, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/dsa/dsa_asn1.c", 78);
    return 0;
  }
}

uint64_t dsa_cb(int a1, DSA **a2)
{
  DSA *v3;

  if (a1 == 2)
  {
    DSA_free(*a2);
    *a2 = 0;
    return 2;
  }
  else if (a1)
  {
    return 1;
  }
  else
  {
    v3 = DSA_new();
    *a2 = v3;
    return 2 * (v3 != 0);
  }
}

const ERR_FNS *ERR_get_implementation(void)
{
  err_fns_check();
  return (const ERR_FNS *)err_fns;
}

void err_fns_check()
{
  if (!err_fns)
  {
    CRYPTO_lock(9, 1, 0, 0);
    if (!err_fns)
      err_fns = (uint64_t)err_defaults;
    CRYPTO_lock(10, 1, 0, 0);
  }
}

int ERR_set_implementation(const ERR_FNS *fns)
{
  int v2;

  CRYPTO_lock(9, 1, 0, 0);
  v2 = 0;
  if (!err_fns)
  {
    err_fns = (uint64_t)fns;
    v2 = 1;
  }
  CRYPTO_lock(10, 1, 0, 0);
  return v2;
}

void ERR_load_ERR_strings_internal()
{
  uint64_t *v0;
  uint64_t v1;
  uint64_t *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  char v7;
  char *v8;
  int v9;
  uint64_t *v10;
  uint64_t i;
  char *v12;
  const char *v13;
  uint64_t v14;
  uint64_t *v15;
  uint64_t v16;

  err_init_thread = (uint64_t)pthread_self();
  err_fns_check();
  if (ERR_str_libraries)
  {
    v0 = &ERR_str_libraries;
    do
    {
      (*(void (**)(uint64_t *))(err_fns + 24))(v0);
      v1 = v0[2];
      v0 += 2;
    }
    while (v1);
  }
  if (ERR_str_reasons)
  {
    v2 = &ERR_str_reasons;
    do
    {
      (*(void (**)(uint64_t *))(err_fns + 24))(v2);
      v3 = v2[2];
      v2 += 2;
    }
    while (v3);
  }
  v4 = ERR_str_functs;
  if (ERR_str_functs)
  {
    v5 = &ERR_str_functs;
    do
    {
      *v5 = v4 | 0x2000000;
      (*(void (**)(uint64_t *))(err_fns + 24))(v5);
      v6 = v5[2];
      v5 += 2;
      v4 = v6;
    }
    while (v6);
  }
  CRYPTO_lock(5, 1, 0, 0);
  v7 = build_SYS_str_reasons_init;
  CRYPTO_lock(6, 1, 0, 0);
  if ((v7 & 1) != 0)
    goto LABEL_22;
  CRYPTO_lock(9, 1, 0, 0);
  if ((build_SYS_str_reasons_init & 1) != 0)
    goto LABEL_21;
  v8 = (char *)&build_SYS_str_reasons_strerror_tab;
  v9 = *__error();
  v10 = &qword_255D8E720;
  for (i = 1; i != 128; ++i)
  {
    *(v10 - 1) = i;
    if (*v10)
      goto LABEL_18;
    v12 = strerror(i);
    if (v12)
    {
      strlcpy(v8, v12, 0x20uLL);
      v13 = v8;
LABEL_16:
      *v10 = (uint64_t)v13;
      goto LABEL_18;
    }
    if (!*v10)
    {
      v13 = "unknown";
      goto LABEL_16;
    }
LABEL_18:
    v8 += 32;
    v10 += 2;
  }
  *__error() = v9;
  build_SYS_str_reasons_init = 1;
LABEL_21:
  CRYPTO_lock(10, 1, 0, 0);
LABEL_22:
  v14 = SYS_str_reasons;
  if (SYS_str_reasons)
  {
    v15 = &SYS_str_reasons;
    do
    {
      *v15 = v14 | 0x2000000;
      (*(void (**)(uint64_t *))(err_fns + 24))(v15);
      v16 = v15[2];
      v15 += 2;
      v14 = v16;
    }
    while (v16);
  }
}

void ERR_load_ERR_strings(void)
{
  _opaque_pthread_t *v0;

  v0 = pthread_self();
  if (!pthread_equal(v0, (pthread_t)err_init_thread))
  {
    OPENSSL_init_crypto(0, 0);
    pthread_once(&ERR_load_ERR_strings_once, ERR_load_ERR_strings_internal);
  }
}

void ERR_load_strings(int lib, ERR_STRING_DATA str[])
{
  unint64_t error;
  unint64_t v5;

  ERR_load_ERR_strings();
  error = str->error;
  if (str->error)
  {
    do
    {
      if (lib)
        str->error = error | (lib << 24);
      (*(void (**)(ERR_STRING_DATA *__attribute__((__org_arrdim(0,0)))))(err_fns + 24))(str);
      v5 = str[1].error;
      ++str;
      error = v5;
    }
    while (v5);
  }
}

void ERR_unload_strings(int lib, ERR_STRING_DATA str[])
{
  unint64_t error;
  unint64_t v5;

  OPENSSL_init_crypto(0);
  error = str->error;
  if (str->error)
  {
    do
    {
      if (lib)
        str->error = error | (lib << 24);
      (*(void (**)(ERR_STRING_DATA *__attribute__((__org_arrdim(0,0)))))(err_fns + 32))(str);
      v5 = str[1].error;
      ++str;
      error = v5;
    }
    while (v5);
  }
}

void ERR_free_strings(void)
{
  OPENSSL_init_crypto(0);
  err_fns_check();
  (*(void (**)(void))(err_fns + 8))();
}

void ERR_put_error(int lib, int func, int reason, const char *file, int line)
{
  __int16 v7;
  __int16 v8;
  int v10;
  ERR_STATE *state;
  ERR_STATE *v12;
  int v13;
  BOOL v14;
  int v15;
  int v16;
  int v17;
  uint64_t pid_low;
  char *v19;
  unint64_t *v20;
  void *v21;

  v7 = reason;
  v8 = func;
  v10 = *__error();
  state = ERR_get_state();
  v12 = state;
  v13 = LODWORD(state[1].pid) + 1;
  v14 = -v13 < 0;
  v15 = -v13 & 0xF;
  v16 = v13 & 0xF;
  if (v14)
    v17 = v16;
  else
    v17 = -v15;
  LODWORD(state[1].pid) = v17;
  if (v17 == HIDWORD(state[1].pid))
    HIDWORD(state[1].pid) = (char)(v17 + 1 - ((v17 + 1 + (((char)(v17 + 1) >> 11) & 0xF)) & 0xF0));
  pid_low = v17;
  v19 = (char *)state + 4 * v17;
  *((_DWORD *)v19 + 4) = 0;
  v20 = &state->pid + v17;
  v20[10] = (lib << 24) | ((v8 & 0xFFF) << 12) | v7 & 0xFFFu;
  v20[50] = (unint64_t)file;
  *((_DWORD *)v19 + 132) = line;
  v21 = (void *)v20[26];
  if (v21 && (v12->err_data_flags[pid_low + 2] & 1) != 0)
  {
    free(v21);
    pid_low = SLODWORD(v12[1].pid);
    v12->err_data[pid_low + 1] = 0;
  }
  v12->err_data_flags[pid_low + 2] = 0;
  *__error() = v10;
}

ERR_STATE *ERR_get_state(void)
{
  __n128 v0;
  ERR_STATE *v1;
  __n128 *v2;
  ERR_STATE *v3;
  __n128 v5;
  __n128 v6[38];

  memset(v6, 0, 512);
  v5 = 0uLL;
  err_fns_check();
  CRYPTO_THREADID_current(&v5);
  v0 = CRYPTO_THREADID_cpy(v6, &v5);
  v1 = (ERR_STATE *)(*(uint64_t (**)(__n128 *, __n128))(err_fns + 56))(v6, v0);
  if (!v1)
  {
    v2 = (__n128 *)malloc_type_malloc(0x258uLL, 0x10D004035475690uLL);
    if (v2)
    {
      v1 = (ERR_STATE *)v2;
      CRYPTO_THREADID_cpy(v2, &v5);
      v1[1].pid = 0;
      *(_OWORD *)&v1->err_data[1] = 0u;
      *(_OWORD *)&v1->err_data[3] = 0u;
      *(_OWORD *)&v1->err_data[5] = 0u;
      *(_OWORD *)&v1->err_data[7] = 0u;
      *(_OWORD *)&v1->err_data[9] = 0u;
      *(_OWORD *)&v1->err_data[11] = 0u;
      *(_OWORD *)&v1->err_data[13] = 0u;
      *(_OWORD *)&v1->err_data[15] = 0u;
      *(_OWORD *)&v1->err_data_flags[2] = 0u;
      *(_OWORD *)&v1->err_data_flags[6] = 0u;
      *(_OWORD *)&v1->err_data_flags[10] = 0u;
      *(_OWORD *)&v1->err_data_flags[14] = 0u;
      v3 = (ERR_STATE *)(*(uint64_t (**)(ERR_STATE *))(err_fns + 64))(v1);
      if ((ERR_STATE *)(*(uint64_t (**)(ERR_STATE *))(err_fns + 56))(v1) != v1)
      {
        v3 = v1;
        v1 = (ERR_STATE *)&ERR_get_state_fallback;
LABEL_7:
        ERR_STATE_free(v3);
        return v1;
      }
      if (v3)
        goto LABEL_7;
    }
    else
    {
      return (ERR_STATE *)&ERR_get_state_fallback;
    }
  }
  return v1;
}

void ERR_clear_error(void)
{
  ERR_STATE *state;
  uint64_t v1;
  ERR_STATE *v2;
  char *v3;
  char *v4;

  state = ERR_get_state();
  v1 = 0;
  v2 = state;
  do
  {
    v2->err_flags[2] = 0;
    v3 = (char *)state + v1 * 8;
    state->err_buffer[v1 + 1] = 0;
    v4 = state->err_data[v1 + 1];
    if (v4 && (v2->err_data_flags[2] & 1) != 0)
    {
      free(v4);
      *((_QWORD *)v3 + 26) = 0;
    }
    v2->err_data_flags[2] = 0;
    *((_QWORD *)v3 + 50) = 0;
    v2->err_line[2] = -1;
    v2 = (ERR_STATE *)((char *)v2 + 4);
    ++v1;
  }
  while (v1 != 16);
  state[1].pid = 0;
}

unint64_t ERR_get_error(void)
{
  return get_error_values(1, 0, 0, 0, 0, 0);
}

uint64_t get_error_values(int a1, int a2, const char **a3, _DWORD *a4, char **a5, _DWORD *a6)
{
  ERR_STATE *state;
  ERR_STATE *v13;
  unint64_t v14;
  int pid_high;
  int pid;
  int v18;
  BOOL v19;
  int v20;
  int v21;
  unint64_t *v22;
  _QWORD *v23;
  unint64_t v24;
  uint64_t v25;
  const char *v26;
  char *v27;
  unint64_t *v28;
  void *v29;
  _QWORD *v30;
  void *v31;

  state = ERR_get_state();
  v13 = state;
  if (a1 && a2)
  {
    if (a3)
      *a3 = "";
    if (a4)
      *a4 = 0;
    if (a5)
      *a5 = "";
    if (a6)
      *a6 = 0;
    return 68;
  }
  else
  {
    pid_high = HIDWORD(state[1].pid);
    pid = state[1].pid;
    if (pid_high == pid)
    {
      return 0;
    }
    else
    {
      v18 = pid_high + 1;
      v19 = -v18 < 0;
      v20 = -v18 & 0xF;
      v21 = v18 & 0xF;
      if (!v19)
        v21 = -v20;
      if (!a2)
        pid = v21;
      v22 = &state->pid + pid;
      v24 = v22[10];
      v23 = v22 + 10;
      v14 = v24;
      if (a1)
      {
        HIDWORD(state[1].pid) = pid;
        *v23 = 0;
      }
      v25 = pid;
      if (a3 && a4)
      {
        v26 = state->err_file[pid + 1];
        if (v26)
        {
          *a3 = v26;
          LODWORD(v26) = state->err_line[v25 + 2];
        }
        else
        {
          *a3 = "NA";
        }
        *a4 = (_DWORD)v26;
      }
      if (a5)
      {
        v27 = state->err_data[v25 + 1];
        if (v27)
        {
          *a5 = v27;
          if (a6)
            *a6 = state->err_data_flags[v25 + 2];
        }
        else
        {
          *a5 = "";
          if (a6)
            *a6 = 0;
        }
      }
      else if (a1)
      {
        v28 = &state->pid + v25;
        v31 = (void *)v28[26];
        v30 = v28 + 26;
        v29 = v31;
        if (v31 && (v13->err_data_flags[v25 + 2] & 1) != 0)
        {
          free(v29);
          *v30 = 0;
        }
        v13->err_data_flags[v25 + 2] = 0;
      }
    }
  }
  return v14;
}

unint64_t ERR_get_error_line(const char **file, int *line)
{
  return get_error_values(1, 0, file, line, 0, 0);
}

unint64_t ERR_get_error_line_data(const char **file, int *line, const char **data, int *flags)
{
  return get_error_values(1, 0, file, line, (char **)data, flags);
}

unint64_t ERR_peek_error(void)
{
  ERR_STATE *state;
  int pid_high;
  int v3;
  BOOL v4;
  int v5;
  int v6;

  state = ERR_get_state();
  pid_high = HIDWORD(state[1].pid);
  if (pid_high == LODWORD(state[1].pid))
    return 0;
  v3 = pid_high + 1;
  v4 = -v3 < 0;
  v5 = -v3 & 0xF;
  v6 = v3 & 0xF;
  if (!v4)
    v6 = -v5;
  return state->err_buffer[v6 + 1];
}

unint64_t ERR_peek_error_line(const char **file, int *line)
{
  return get_error_values(0, 0, file, line, 0, 0);
}

unint64_t ERR_peek_error_line_data(const char **file, int *line, const char **data, int *flags)
{
  return get_error_values(0, 0, file, line, (char **)data, flags);
}

unint64_t ERR_peek_last_error(void)
{
  ERR_STATE *state;
  uint64_t pid_low;

  state = ERR_get_state();
  pid_low = SLODWORD(state[1].pid);
  if (HIDWORD(state[1].pid) == (_DWORD)pid_low)
    return 0;
  else
    return state->err_buffer[pid_low + 1];
}

unint64_t ERR_peek_last_error_line(const char **file, int *line)
{
  return get_error_values(0, 1, file, line, 0, 0);
}

unint64_t ERR_peek_last_error_line_data(const char **file, int *line, const char **data, int *flags)
{
  return get_error_values(0, 1, file, line, (char **)data, flags);
}

void ERR_error_string_n(unint64_t e, char *buf, size_t len)
{
  const char *v6;
  const char *v7;
  const char *v8;
  int v9;
  char *v10;
  uint64_t i;
  char *v12;
  char *v13;
  char v14[30];
  char v15[30];
  char __str[30];
  uint64_t v17;

  v17 = *MEMORY[0x24BDAC8D0];
  v6 = ERR_lib_error_string(e);
  v7 = ERR_func_error_string(e);
  v8 = ERR_reason_error_string(e);
  if (v6)
  {
    if (v7)
      goto LABEL_3;
LABEL_14:
    v7 = v15;
    snprintf(v15, 0x1EuLL, "func(%d)", (e >> 12) & 0xFFF);
    if (v8)
      goto LABEL_4;
LABEL_15:
    v8 = v14;
    snprintf(v14, 0x1EuLL, "reason(%d)", e & 0xFFF);
    goto LABEL_4;
  }
  v6 = __str;
  snprintf(__str, 0x1EuLL, "lib(%d)", BYTE3(e));
  if (!v7)
    goto LABEL_14;
LABEL_3:
  if (!v8)
    goto LABEL_15;
LABEL_4:
  v9 = snprintf(buf, len, "error:%08lX:%s:%s:%s", e, v6, v7, v8);
  if (v9 != -1 && len >= 5 && v9 >= len)
  {
    v10 = &buf[len];
    for (i = -5; i != -1; ++i)
    {
      v12 = strchr(buf, 58);
      v13 = &v10[i];
      if (!v12 || v12 > v13)
      {
        *v13 = 58;
        v12 = &v10[i];
      }
      buf = v12 + 1;
    }
  }
}

const char *__cdecl ERR_lib_error_string(unint64_t e)
{
  int v1;
  const char *result;
  _QWORD v3[2];

  v1 = e;
  if (!OPENSSL_init_crypto(0, 0))
    return 0;
  v3[1] = 0;
  err_fns_check();
  v3[0] = v1 & 0xFF000000;
  result = (const char *)(*(uint64_t (**)(_QWORD *))(err_fns + 16))(v3);
  if (result)
    return (const char *)*((_QWORD *)result + 1);
  return result;
}

const char *__cdecl ERR_func_error_string(unint64_t e)
{
  int v1;
  const char *result;
  _QWORD v3[2];

  v1 = e;
  v3[1] = 0;
  err_fns_check();
  v3[0] = v1 & 0xFFFFF000;
  result = (const char *)(*(uint64_t (**)(_QWORD *))(err_fns + 16))(v3);
  if (result)
    return (const char *)*((_QWORD *)result + 1);
  return result;
}

const char *__cdecl ERR_reason_error_string(unint64_t e)
{
  int v1;
  const char *result;
  _QWORD v3[2];

  v1 = e;
  v3[1] = 0;
  err_fns_check();
  v3[0] = v1 & 0xFF000FFF;
  result = (const char *)(*(uint64_t (**)(_QWORD *))(err_fns + 16))(v3);
  if (result)
    return (const char *)*((_QWORD *)result + 1);
  v3[0] = v1 & 0xFFF;
  result = (const char *)(*(uint64_t (**)(_QWORD *))(err_fns + 16))(v3);
  if (result)
    return (const char *)*((_QWORD *)result + 1);
  return result;
}

char *__cdecl ERR_error_string(unint64_t e, char *buf)
{
  char *v2;

  if (buf)
    v2 = buf;
  else
    v2 = (char *)&ERR_error_string_buf;
  ERR_error_string_n(e, v2, 0x100uLL);
  return v2;
}

LHASH *ERR_get_string_table(void)
{
  err_fns_check();
  return (LHASH *)(*(uint64_t (**)(_QWORD))err_fns)(0);
}

LHASH *ERR_get_err_state_table(void)
{
  err_fns_check();
  return (LHASH *)(*(uint64_t (**)(_QWORD))(err_fns + 40))(0);
}

void ERR_release_err_state_table(LHASH **hash)
{
  err_fns_check();
  (*(void (**)(LHASH **))(err_fns + 48))(hash);
}

uint64_t ERR_remove_thread_state(__n128 *a1)
{
  __n128 v2[38];

  memset(v2, 0, 512);
  if (a1)
    CRYPTO_THREADID_cpy(v2, a1);
  else
    CRYPTO_THREADID_current(v2);
  err_fns_check();
  return (*(uint64_t (**)(__n128 *))(err_fns + 72))(v2);
}

void ERR_remove_state(unint64_t pid)
{
  _OWORD v1[38];

  memset(v1, 0, 512);
  CRYPTO_THREADID_current(v1);
  err_fns_check();
  (*(void (**)(_OWORD *))(err_fns + 72))(v1);
}

void ERR_STATE_free(_BYTE *a1)
{
  uint64_t i;
  char *v3;
  void *v4;

  for (i = 0; i != 16; ++i)
  {
    v3 = &a1[8 * i];
    v4 = (void *)*((_QWORD *)v3 + 26);
    if (v4 && (a1[4 * i + 336] & 1) != 0)
    {
      free(v4);
      *((_QWORD *)v3 + 26) = 0;
    }
    *(_DWORD *)&a1[4 * i + 336] = 0;
  }
  free(a1);
}

int ERR_get_next_error_library(void)
{
  err_fns_check();
  return (*(uint64_t (**)(void))(err_fns + 80))();
}

void ERR_set_error_data(char *data, int flags)
{
  ERR_STATE *state;
  ERR_STATE *v5;
  int pid;
  uint64_t v7;
  unint64_t *v8;
  void *v9;
  char **v10;
  void *v11;

  state = ERR_get_state();
  v5 = state;
  pid = state[1].pid;
  if (!pid)
    pid = 15;
  v7 = pid;
  v8 = &state->pid + pid;
  v11 = (void *)v8[26];
  v10 = (char **)(v8 + 26);
  v9 = v11;
  if (v11 && (v5->err_data_flags[pid + 2] & 1) != 0)
    free(v9);
  *v10 = data;
  v5->err_data_flags[v7 + 2] = flags;
}

void ERR_asprintf_error_data(char *a1, ...)
{
  char *v1;
  int v2;
  char *v3;
  va_list va;

  va_start(va, a1);
  v3 = 0;
  if (vasprintf(&v3, a1, va) == -1)
  {
    v1 = "malloc failed";
    v2 = 2;
  }
  else
  {
    v1 = v3;
    v2 = 3;
  }
  ERR_set_error_data(v1, v2);
}

void ERR_add_error_vdata(int a1, va_list a2)
{
  int v3;
  char *v4;
  int v5;
  char *v6;
  char v7[129];
  uint64_t v8;

  v8 = *MEMORY[0x24BDAC8D0];
  v6 = 0;
  v7[0] = 0;
  if (a1 >= 1)
  {
    v3 = a1;
    while ((unint64_t)__strlcat_chk() < 0x81)
    {
      if (!--v3)
        goto LABEL_5;
    }
    v4 = "too many errors";
    goto LABEL_9;
  }
LABEL_5:
  if (vasprintf(&v6, v7, a2) == -1)
  {
    v4 = "malloc failed";
LABEL_9:
    v5 = 2;
    goto LABEL_10;
  }
  v4 = v6;
  v5 = 3;
LABEL_10:
  ERR_set_error_data(v4, v5);
}

void ERR_add_error_data(int num, ...)
{
  va_list va;

  va_start(va, num);
  ERR_add_error_vdata(num, va);
}

int ERR_set_mark(void)
{
  ERR_STATE *state;
  uint64_t pid_low;

  state = ERR_get_state();
  pid_low = SLODWORD(state[1].pid);
  if (HIDWORD(state[1].pid) == (_DWORD)pid_low)
    return 0;
  state->err_flags[pid_low + 2] |= 1u;
  return 1;
}

int ERR_pop_to_mark(void)
{
  ERR_STATE *state;
  int pid;
  ERR_STATE *v2;
  char *v3;
  unsigned int *v4;
  int v5;
  int v6;
  uint64_t pid_low;
  unint64_t *v8;
  void *v9;
  uint64_t v10;
  int v11;

  state = ERR_get_state();
  pid = state[1].pid;
  if (HIDWORD(state[1].pid) == pid)
    return 0;
  v2 = state;
  while (1)
  {
    v3 = (char *)v2 + 4 * pid;
    v6 = *((_DWORD *)v3 + 4);
    v4 = (unsigned int *)(v3 + 16);
    v5 = v6;
    if ((v6 & 1) != 0)
      break;
    *v4 = 0;
    pid_low = SLODWORD(v2[1].pid);
    v8 = &v2->pid + pid_low;
    v8[10] = 0;
    v9 = (void *)v8[26];
    if (v9 && (v2->err_data_flags[pid_low + 2] & 1) != 0)
    {
      free(v9);
      pid_low = SLODWORD(v2[1].pid);
      v2->err_data[pid_low + 1] = 0;
    }
    v2->err_data_flags[pid_low + 2] = 0;
    v10 = SLODWORD(v2[1].pid);
    v2->err_file[v10 + 1] = 0;
    v2->err_line[v10 + 2] = -1;
    v11 = v2[1].pid;
    if (v11)
      pid = v11 - 1;
    else
      pid = 15;
    LODWORD(v2[1].pid) = pid;
    if (HIDWORD(v2[1].pid) == pid)
      return 0;
  }
  *v4 = v5 & 0xFFFFFFFE;
  return 1;
}

ERR_STATE *err_clear_last_constant_time(int a1)
{
  ERR_STATE *result;
  uint64_t pid_low;
  char *v4;
  uint64_t v5;
  unint64_t *v6;
  int v7;
  int v8;
  BOOL v9;
  int v10;
  int v11;
  int v12;

  result = ERR_get_state();
  if (result)
  {
    pid_low = SLODWORD(result[1].pid);
    v4 = (char *)result + 4 * pid_low;
    *((_DWORD *)v4 + 4) &= a1 - 1;
    v5 = a1 - 1;
    v6 = &result->pid + pid_low;
    v6[10] &= v5;
    v6[50] &= v5;
    *((_DWORD *)v4 + 132) |= -a1;
    v7 = pid_low - a1 + 16;
    v8 = v7 & 0xF;
    v10 = -v7;
    v9 = v10 < 0;
    v11 = v10 & 0xF;
    if (v9)
      v12 = v8;
    else
      v12 = -v11;
    LODWORD(result[1].pid) = v12;
  }
  return result;
}

uint64_t int_err_get(int a1)
{
  uint64_t v2;

  CRYPTO_lock(9, 1, 0, 0);
  v2 = int_error_hash;
  if (a1 && !int_error_hash)
  {
    CRYPTO_push_info_("int_err_get (err.c)", 0, 0);
    int_error_hash = (uint64_t)lh_new((LHASH_HASH_FN_TYPE)err_string_data_LHASH_HASH, (LHASH_COMP_FN_TYPE)err_string_data_LHASH_COMP);
    CRYPTO_pop_info();
    v2 = int_error_hash;
  }
  CRYPTO_lock(10, 1, 0, 0);
  return v2;
}

void int_err_del()
{
  CRYPTO_lock(9, 1, 0, 0);
  if (int_error_hash)
  {
    lh_free((LHASH *)int_error_hash);
    int_error_hash = 0;
  }
  CRYPTO_lock(10, 1, 0, 0);
}

uint64_t int_err_get_item(const void *a1)
{
  uint64_t result;
  LHASH *v3;
  void *v4;

  err_fns_check();
  result = (*(uint64_t (**)(_QWORD))err_fns)(0);
  if (result)
  {
    v3 = (LHASH *)result;
    CRYPTO_lock(5, 1, 0, 0);
    v4 = lh_retrieve(v3, a1);
    CRYPTO_lock(6, 1, 0, 0);
    return (uint64_t)v4;
  }
  return result;
}

uint64_t int_err_set_item(void *a1)
{
  uint64_t result;
  LHASH *v3;
  void *v4;

  err_fns_check();
  result = (*(uint64_t (**)(uint64_t))err_fns)(1);
  if (result)
  {
    v3 = (LHASH *)result;
    CRYPTO_lock(9, 1, 0, 0);
    v4 = lh_insert(v3, a1);
    CRYPTO_lock(10, 1, 0, 0);
    return (uint64_t)v4;
  }
  return result;
}

uint64_t int_err_del_item(const void *a1)
{
  uint64_t result;
  LHASH *v3;
  void *v4;

  err_fns_check();
  result = (*(uint64_t (**)(_QWORD))err_fns)(0);
  if (result)
  {
    v3 = (LHASH *)result;
    CRYPTO_lock(9, 1, 0, 0);
    v4 = lh_delete(v3, a1);
    CRYPTO_lock(10, 1, 0, 0);
    return (uint64_t)v4;
  }
  return result;
}

uint64_t int_thread_get(int a1)
{
  uint64_t v2;

  CRYPTO_lock(9, 1, 0, 0);
  v2 = int_thread_hash;
  if (a1 && !int_thread_hash)
  {
    CRYPTO_push_info_("int_thread_get (err.c)", 0, 0);
    int_thread_hash = (uint64_t)lh_new((LHASH_HASH_FN_TYPE)err_state_LHASH_HASH, (LHASH_COMP_FN_TYPE)err_state_LHASH_COMP);
    CRYPTO_pop_info();
    v2 = int_thread_hash;
  }
  if (v2)
    ++int_thread_hash_references;
  CRYPTO_lock(10, 1, 0, 0);
  return v2;
}

_QWORD *int_thread_release(_QWORD *result)
{
  _QWORD *v1;

  if (result)
  {
    v1 = result;
    if (*result)
    {
      result = (_QWORD *)CRYPTO_add_lock(&int_thread_hash_references, -1, 1, 0, 0);
      if ((int)result <= 0)
        *v1 = 0;
    }
  }
  return result;
}

uint64_t int_thread_get_item(const void *a1)
{
  uint64_t result;
  LHASH *v3;
  void *v4;
  uint64_t v5;

  err_fns_check();
  result = (*(uint64_t (**)(_QWORD))(err_fns + 40))(0);
  v5 = result;
  if (result)
  {
    v3 = (LHASH *)result;
    CRYPTO_lock(5, 1, 0, 0);
    v4 = lh_retrieve(v3, a1);
    CRYPTO_lock(6, 1, 0, 0);
    (*(void (**)(uint64_t *))(err_fns + 48))(&v5);
    return (uint64_t)v4;
  }
  return result;
}

uint64_t int_thread_set_item(void *a1)
{
  uint64_t result;
  LHASH *v3;
  void *v4;
  uint64_t v5;

  err_fns_check();
  result = (*(uint64_t (**)(uint64_t))(err_fns + 40))(1);
  v5 = result;
  if (result)
  {
    v3 = (LHASH *)result;
    CRYPTO_lock(9, 1, 0, 0);
    v4 = lh_insert(v3, a1);
    CRYPTO_lock(10, 1, 0, 0);
    (*(void (**)(uint64_t *))(err_fns + 48))(&v5);
    return (uint64_t)v4;
  }
  return result;
}

void int_thread_del_item(const void *a1)
{
  uint64_t v2;
  LHASH *v3;
  _BYTE *v4;
  BOOL v5;
  uint64_t v6;

  err_fns_check();
  v2 = (*(uint64_t (**)(_QWORD))(err_fns + 40))(0);
  v6 = v2;
  if (v2)
  {
    v3 = (LHASH *)v2;
    CRYPTO_lock(9, 1, 0, 0);
    v4 = lh_delete(v3, a1);
    v5 = int_thread_hash_references != 1 || int_thread_hash == 0;
    if (!v5 && !lh_num_items((const LHASH *)int_thread_hash))
    {
      lh_free((LHASH *)int_thread_hash);
      int_thread_hash = 0;
    }
    CRYPTO_lock(10, 1, 0, 0);
    (*(void (**)(uint64_t *))(err_fns + 48))(&v6);
    if (v4)
      ERR_STATE_free(v4);
  }
}

uint64_t int_err_get_next_lib()
{
  uint64_t v0;

  CRYPTO_lock(9, 1, 0, 0);
  v0 = int_err_library_number++;
  CRYPTO_lock(10, 1, 0, 0);
  return v0;
}

unint64_t err_string_data_LHASH_HASH(_QWORD *a1)
{
  unint64_t v1;

  v1 = BYTE3(*a1) ^ (*a1 >> 12) & 0xFFFLL ^ *a1;
  return (13 * (v1 % 0x13)) ^ v1;
}

uint64_t err_string_data_LHASH_COMP(_DWORD *a1, _DWORD *a2)
{
  return (*a1 - *a2);
}

uint64_t err_state_LHASH_HASH(uint64_t a1)
{
  return 13 * CRYPTO_THREADID_hash(a1);
}

int BN_GENCB_call(BN_GENCB *cb, int a, int b)
{
  void (__cdecl *cb_1)(int, int, void *);

  if (!cb)
    return 1;
  if (cb->ver == 2)
    return ((uint64_t (*)(_QWORD, _QWORD, BN_GENCB *))cb->cb.cb_1)(*(_QWORD *)&a, *(_QWORD *)&b, cb);
  if (cb->ver == 1)
  {
    cb_1 = cb->cb.cb_1;
    if (cb_1)
      ((void (*)(_QWORD, _QWORD, void *))cb_1)(*(_QWORD *)&a, *(_QWORD *)&b, cb->arg);
    return 1;
  }
  return 0;
}

int BN_generate_prime_ex(BIGNUM *ret, int bits, int safe, const BIGNUM *add, const BIGNUM *rem, BN_GENCB *cb)
{
  uint64_t v6;
  int v7;
  int v8;
  const BIGNUM *v9;
  BIGNUM *v10;
  BN_GENCB *v11;
  BN_GENCB *v12;
  BIGNUM *v13;
  const BIGNUM *v14;
  int v15;
  int v16;
  BIGNUM *v17;
  int v18;
  BN_CTX *v19;
  BN_CTX *v20;
  BIGNUM *v21;
  BIGNUM *v22;
  int v23;
  BIGNUM *v24;
  BIGNUM *v25;
  BIGNUM *v26;
  BIGNUM *v27;
  BIGNUM *v28;
  const BIGNUM *v29;
  uint64_t v30;
  unint64_t v31;
  unint64_t v32;
  int v33;
  uint64_t i;
  uint64_t v35;
  unint64_t v36;
  unint64_t v37;
  unint64_t v38;
  BOOL v40;
  uint64_t v41;
  int64_t v42;
  int is_prime_bpsw;
  BIGNUM *v45;
  int v46;
  BN_GENCB *v47;
  BIGNUM *a;
  int b;
  int v50[4097];
  uint64_t v51;

  v6 = MEMORY[0x24BDAC7A8](ret);
  v51 = *MEMORY[0x24BDAC8D0];
  if (v7 < 2 || (v12 = v11, v13 = v10, v14 = v9, v15 = v8, v16 = v7, v17 = (BIGNUM *)v6, v7 == 2) && v8)
  {
    ERR_put_error(3, 4095, 117, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/bn/bn_prime.c", 169);
    return 0;
  }
  v50[0] = 0;
  v19 = BN_CTX_new();
  v20 = v19;
  if (v19)
  {
    BN_CTX_start(v19);
    v21 = BN_CTX_get(v20);
    if (v21)
    {
      v22 = v21;
      a = v13;
      v23 = 0;
      v47 = v12;
      v46 = v15;
      v45 = v21;
LABEL_8:
      b = v23;
      if (!v14)
      {
        if (BN_rand(v17, v16, 1, 1))
        {
          v30 = 1;
LABEL_23:
          while (1)
          {
            v31 = BN_mod_word(v17, (unsigned __int16)primes[v30]);
            if (v31 == -1)
              break;
            *(_QWORD *)&v50[2 * v30++ + 1] = v31;
            if (v30 == 2048)
            {
              v32 = 0;
              v33 = b;
LABEL_26:
              for (i = 1; i != 2048; ++i)
              {
                if ((*(_QWORD *)&v50[2 * i + 1] + v32) % (unsigned __int16)primes[i] <= 1)
                {
                  v32 += 2;
                  if (v32 <= 0xFFFFFFFFFFFFBA38)
                    goto LABEL_26;
                  v30 = 1;
                  if (BN_rand(v17, v16, 1, 1))
                    goto LABEL_23;
                  goto LABEL_80;
                }
              }
              if (!BN_add_word(v17, v32))
                goto LABEL_80;
LABEL_68:
              if (!BN_GENCB_call(v12, 0, v33))
                goto LABEL_80;
              v23 = v33 + 1;
              is_prime_bpsw = bn_is_prime_bpsw(v50, v17, v20, 1);
              if (!v15)
              {
                if (!is_prime_bpsw)
                  goto LABEL_80;
                if (v50[0])
                  goto LABEL_84;
                goto LABEL_8;
              }
              if (!is_prime_bpsw)
                goto LABEL_80;
              if (!v50[0])
                goto LABEL_8;
              if (BN_rshift1(v22, v17) && bn_is_prime_bpsw(v50, v22, v20, 1))
              {
                if (!v50[0])
                  goto LABEL_8;
                if (BN_GENCB_call(v12, 2, b))
                {
LABEL_84:
                  v18 = 1;
                  goto LABEL_81;
                }
              }
              goto LABEL_80;
            }
          }
        }
        goto LABEL_80;
      }
      BN_CTX_start(v20);
      v24 = BN_CTX_get(v20);
      v25 = v24;
      if (v15)
      {
        if (!v24)
          goto LABEL_79;
        v26 = BN_CTX_get(v20);
        if (!v26)
          goto LABEL_79;
        v27 = v26;
        v28 = BN_CTX_get(v20);
        if (!v28)
          goto LABEL_79;
        v29 = v28;
        if (!BN_rshift1(v28, v14)
          || !BN_rand(v27, v16 - 1, 0, 1)
          || !BN_mod_ct(v25, v27, v29, v20)
          || !BN_sub(v27, v27, v25))
        {
          goto LABEL_79;
        }
        if (a)
        {
          if (!BN_rshift1(v25, a) || !BN_add(v27, v27, v25))
            goto LABEL_79;
LABEL_43:
          if (BN_lshift1(v17, v27) && BN_add_word(v17, 1uLL))
          {
            v35 = 1;
            while (1)
            {
              v36 = (unsigned __int16)primes[v35];
              v37 = BN_mod_word(v17, v36);
              v38 = BN_mod_word(v27, v36);
              if (v37 == -1 || v38 == -1)
                break;
              if (v37)
                v40 = v38 == 0;
              else
                v40 = 1;
              if (v40)
              {
                if (!BN_add(v17, v17, v14))
                  goto LABEL_79;
                v35 = 1;
                if (!BN_add(v27, v27, v29))
                  goto LABEL_79;
              }
              else if (++v35 == 2048)
              {
                goto LABEL_67;
              }
            }
          }
          goto LABEL_79;
        }
        if (BN_add_word(v27, 1uLL))
          goto LABEL_43;
LABEL_79:
        BN_CTX_end(v20);
        goto LABEL_80;
      }
      if (!v24 || !BN_rand(v17, v16, 0, 1) || !BN_mod_ct(v25, v17, v14, v20) || !BN_sub(v17, v17, v25))
        goto LABEL_79;
      if (a)
      {
        if (!BN_add(v17, v17, a))
          goto LABEL_79;
      }
      else if (!BN_add_word(v17, 1uLL))
      {
        goto LABEL_79;
      }
      v41 = 1;
      while (1)
      {
        v42 = BN_mod_word(v17, (unsigned __int16)primes[v41]);
        if (v42 == -1)
          goto LABEL_79;
        if (v42 > 1)
        {
          if (++v41 == 2048)
          {
LABEL_67:
            BN_CTX_end(v20);
            v12 = v47;
            v15 = v46;
            v22 = v45;
            v33 = b;
            goto LABEL_68;
          }
        }
        else
        {
          v41 = 1;
          if (!BN_add(v17, v17, v14))
            goto LABEL_79;
        }
      }
    }
  }
LABEL_80:
  v18 = 0;
LABEL_81:
  BN_CTX_end(v20);
  BN_CTX_free(v20);
  return v18;
}

int BN_is_prime_fasttest_ex(const BIGNUM *p, int nchecks, BN_CTX *ctx, int do_trial_division, BN_GENCB *cb)
{
  int v8;

  if (nchecks < 0)
    return -1;
  if (!nchecks)
  {
    if (BN_num_bits(p) <= 3746)
    {
      if (BN_num_bits(p) <= 1344)
      {
        if (BN_num_bits(p) <= 475)
        {
          if (BN_num_bits(p) <= 399)
          {
            if (BN_num_bits(p) <= 346)
            {
              if (BN_num_bits(p) <= 307)
              {
                if (BN_num_bits(p) <= 54)
                  nchecks = 34;
                else
                  nchecks = 27;
              }
              else
              {
                nchecks = 8;
              }
            }
            else
            {
              nchecks = 7;
            }
          }
          else
          {
            nchecks = 6;
          }
        }
        else
        {
          nchecks = 5;
        }
      }
      else
      {
        nchecks = 4;
      }
    }
    else
    {
      nchecks = 3;
    }
  }
  v8 = 0;
  if (bn_is_prime_bpsw(&v8, p, ctx, nchecks))
    return v8;
  else
    return -1;
}

int OBJ_NAME_init(void)
{
  if (names_lh)
    return 1;
  names_lh = (uint64_t)lh_new((LHASH_HASH_FN_TYPE)obj_name_LHASH_HASH, (LHASH_COMP_FN_TYPE)obj_name_LHASH_COMP);
  return names_lh != 0;
}

unint64_t obj_name_LHASH_HASH(int *a1)
{
  char *v2;
  unint64_t v3;

  if (name_funcs_stack && sk_num((const STACK *)name_funcs_stack) > *a1)
  {
    v2 = sk_value((const STACK *)name_funcs_stack, *a1);
    v3 = (*(uint64_t (**)(_QWORD))v2)(*((_QWORD *)a1 + 1));
  }
  else
  {
    v3 = lh_strhash(*((const char **)a1 + 1));
  }
  return v3 ^ *a1;
}

uint64_t obj_name_LHASH_COMP(uint64_t a1, uint64_t a2)
{
  int v3;
  uint64_t result;
  uint64_t (*v6)(_QWORD, _QWORD);

  v3 = *(_DWORD *)a1;
  result = (*(_DWORD *)a1 - *(_DWORD *)a2);
  if (v3 == *(_DWORD *)a2)
  {
    if (name_funcs_stack && sk_num((const STACK *)name_funcs_stack) > *(_DWORD *)a1)
    {
      v6 = (uint64_t (*)(_QWORD, _QWORD))*((_QWORD *)sk_value((const STACK *)name_funcs_stack, *(_DWORD *)a1)
                                                   + 1);
      return v6(*(_QWORD *)(a1 + 8), *(_QWORD *)(a2 + 8));
    }
    else
    {
      return strcmp(*(const char **)(a1 + 8), *(const char **)(a2 + 8));
    }
  }
  return result;
}

int OBJ_NAME_new_index(unint64_t (__cdecl *hash_func)(const char *), int (__cdecl *cmp_func)(const char *, const char *), void (__cdecl *free_func)(const char *, int, const char *))
{
  STACK *v6;
  int v7;
  int v8;
  int v9;
  uint64_t (*v10)(_QWORD, _QWORD);
  _QWORD *v11;
  void *v12;
  char *v13;
  int v14;

  v6 = (STACK *)name_funcs_stack;
  if (!name_funcs_stack)
  {
    v6 = sk_new_null();
    name_funcs_stack = (uint64_t)v6;
    if (!v6)
      return 0;
  }
  v7 = names_type_num++;
  v8 = sk_num(v6);
  if (v8 < names_type_num)
  {
    v9 = v8;
    v10 = MEMORY[0x24BDAFEF0];
    while (1)
    {
      v11 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
      if (!v11)
      {
        v14 = 70;
        goto LABEL_16;
      }
      v12 = v11;
      *v11 = lh_strhash;
      v11[1] = v10;
      v11[2] = 0;
      if (!sk_push((STACK *)name_funcs_stack, (char *)v11))
        break;
      if (++v9 >= names_type_num)
        goto LABEL_8;
    }
    free(v12);
    v14 = 78;
LABEL_16:
    ERR_put_error(8, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/objects/o_names.c", v14);
    return 0;
  }
LABEL_8:
  v13 = sk_value((const STACK *)name_funcs_stack, v7);
  if (hash_func)
    *(_QWORD *)v13 = hash_func;
  if (cmp_func)
    *((_QWORD *)v13 + 1) = cmp_func;
  if (free_func)
    *((_QWORD *)v13 + 2) = free_func;
  return v7;
}

const char *__cdecl OBJ_NAME_get(const char *name, int type)
{
  const char *v3;
  int v4;
  uint64_t data;
  const char *v6;
  uint64_t v7;

  if (name)
  {
    v3 = name;
    name = (const char *)names_lh;
    if (names_lh
      || (name = (const char *)lh_new((LHASH_HASH_FN_TYPE)obj_name_LHASH_HASH, (LHASH_COMP_FN_TYPE)obj_name_LHASH_COMP),
          (names_lh = (uint64_t)name) != 0))
    {
      v6 = v3;
      v7 = 0;
      data = type & 0xFFFF7FFF;
      name = (const char *)lh_retrieve((LHASH *)name, &data);
      if (name)
      {
        v4 = 11;
        while (1)
        {
          if ((type & 0x8000) != 0 || !*((_DWORD *)name + 1))
            return (const char *)*((_QWORD *)name + 2);
          if (!--v4)
            break;
          v6 = (const char *)*((_QWORD *)name + 2);
          name = (const char *)lh_retrieve((LHASH *)names_lh, &data);
          if (!name)
            return name;
        }
        return 0;
      }
    }
  }
  return name;
}

int OBJ_NAME_add(const char *name, int type, const char *data)
{
  int8x8_t *v6;
  int8x8_t *v7;
  int *v8;
  int *v9;
  char *v10;
  int v11;

  if (!names_lh)
  {
    names_lh = (uint64_t)lh_new((LHASH_HASH_FN_TYPE)obj_name_LHASH_HASH, (LHASH_COMP_FN_TYPE)obj_name_LHASH_COMP);
    if (!names_lh)
      return 0;
  }
  v6 = (int8x8_t *)malloc_type_malloc(0x18uLL, 0x105004015D6E50FuLL);
  if (!v6)
    return 0;
  v7 = v6;
  *v6 = vand_s8((int8x8_t)vdup_n_s32(type), (int8x8_t)0x8000FFFF7FFFLL);
  v6[1] = (int8x8_t)name;
  v6[2] = (int8x8_t)data;
  v8 = (int *)lh_insert((LHASH *)names_lh, v6);
  if (v8)
  {
    v9 = v8;
    if (name_funcs_stack && sk_num((const STACK *)name_funcs_stack) > *v8)
    {
      v10 = sk_value((const STACK *)name_funcs_stack, *v9);
      (*((void (**)(_QWORD, _QWORD, _QWORD))v10 + 2))(*((_QWORD *)v9 + 1), *v9, *((_QWORD *)v9 + 2));
    }
    v11 = 1;
  }
  else
  {
    if (!*(_DWORD *)(names_lh + 168))
      return 1;
    v11 = 0;
    v9 = (int *)v7;
  }
  free(v9);
  return v11;
}

int OBJ_NAME_remove(const char *name, int type)
{
  const char *v2;
  char *v3;
  char *v4;
  _QWORD data[3];

  v2 = name;
  LODWORD(name) = names_lh;
  if (names_lh)
  {
    data[1] = v2;
    data[2] = 0;
    data[0] = type & 0xFFFF7FFF;
    name = (const char *)lh_delete((LHASH *)names_lh, data);
    if (name)
    {
      v3 = (char *)name;
      if (name_funcs_stack && sk_num((const STACK *)name_funcs_stack) > *(_DWORD *)name)
      {
        v4 = sk_value((const STACK *)name_funcs_stack, *(_DWORD *)v3);
        (*((void (**)(_QWORD, _QWORD, _QWORD))v4 + 2))(*((_QWORD *)v3 + 1), *(unsigned int *)v3, *((_QWORD *)v3 + 2));
      }
      free(v3);
      LODWORD(name) = 1;
    }
  }
  return (int)name;
}

void OBJ_NAME_do_all(int type, void (__cdecl *fn)(const OBJ_NAME *, void *), void *arg)
{
  _QWORD arga[3];

  arga[1] = fn;
  arga[0] = type;
  arga[2] = arg;
  lh_doall_arg((LHASH *)names_lh, (LHASH_DOALL_ARG_FN_TYPE)do_all_fn_LHASH_DOALL_ARG, arga);
}

_DWORD *do_all_fn_LHASH_DOALL_ARG(_DWORD *result, uint64_t a2)
{
  if (*result == *(_DWORD *)a2)
    return (_DWORD *)(*(uint64_t (**)(void))(a2 + 8))();
  return result;
}

void OBJ_NAME_do_all_sorted(int type, void (__cdecl *fn)(const OBJ_NAME *, void *), void *arg)
{
  unint64_t v6;
  uint64_t v7;
  int v8;
  _DWORD __nel[3];
  _QWORD arga[3];

  v8 = type;
  v6 = lh_num_items((const LHASH *)names_lh);
  *(_QWORD *)&__nel[1] = reallocarray(0, v6, 8uLL);
  __nel[0] = 0;
  if (*(_QWORD *)&__nel[1])
  {
    arga[1] = do_all_sorted_fn;
    arga[0] = type;
    arga[2] = &v8;
    lh_doall_arg((LHASH *)names_lh, (LHASH_DOALL_ARG_FN_TYPE)do_all_fn_LHASH_DOALL_ARG, arga);
    qsort(*(void **)&__nel[1], __nel[0], 8uLL, (int (__cdecl *)(const void *, const void *))do_all_sorted_cmp);
    if (__nel[0] >= 1)
    {
      v7 = 0;
      do
        ((void (*)(_QWORD, void *))fn)(*(_QWORD *)(*(_QWORD *)&__nel[1] + 8 * v7++), arg);
      while (v7 < __nel[0]);
    }
    free(*(void **)&__nel[1]);
  }
}

_DWORD *do_all_sorted_fn(_DWORD *result, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;

  if (*result == *(_DWORD *)a2)
  {
    v2 = *(_QWORD *)(a2 + 8);
    v3 = *(int *)(a2 + 4);
    *(_DWORD *)(a2 + 4) = v3 + 1;
    *(_QWORD *)(v2 + 8 * v3) = result;
  }
  return result;
}

uint64_t do_all_sorted_cmp(uint64_t a1, uint64_t a2)
{
  return strcmp(*(const char **)(*(_QWORD *)a1 + 8), *(const char **)(*(_QWORD *)a2 + 8));
}

void OBJ_NAME_cleanup(int type)
{
  LHASH *v2;
  uint64_t v3;

  v2 = (LHASH *)names_lh;
  if (names_lh)
  {
    free_type = type;
    v3 = *(_QWORD *)(names_lh + 48);
    *(_QWORD *)(names_lh + 48) = 0;
    lh_doall(v2, (LHASH_DOALL_FN_TYPE)names_lh_free_LHASH_DOALL);
    if (type < 0)
    {
      lh_free((LHASH *)names_lh);
      sk_pop_free((STACK *)name_funcs_stack, name_funcs_free);
      names_lh = 0;
      name_funcs_stack = 0;
    }
    else
    {
      *(_QWORD *)(names_lh + 48) = v3;
    }
  }
}

uint64_t names_lh_free_LHASH_DOALL(uint64_t result)
{
  int v1;

  if (result)
  {
    v1 = *(_DWORD *)result;
    if (free_type < 0 || free_type == v1)
      return OBJ_NAME_remove(*(const char **)(result + 8), v1);
  }
  return result;
}

const char *__cdecl X509_verify_cert_error_string(uint64_t n)
{
  if (n > 0x45)
    return "Unknown certificate verification error";
  else
    return off_24F8A7C60[(int)n];
}

const EVP_CIPHER *EVP_aes_128_cbc(void)
{
  return (const EVP_CIPHER *)&aes_128_cbc;
}

const EVP_CIPHER *EVP_aes_128_ecb(void)
{
  return (const EVP_CIPHER *)&aes_128_ecb;
}

const EVP_CIPHER *EVP_aes_128_ofb(void)
{
  return (const EVP_CIPHER *)&aes_128_ofb;
}

const EVP_CIPHER *EVP_aes_128_cfb128(void)
{
  return (const EVP_CIPHER *)&aes_128_cfb;
}

const EVP_CIPHER *EVP_aes_128_cfb1(void)
{
  return (const EVP_CIPHER *)&aes_128_cfb1;
}

const EVP_CIPHER *EVP_aes_128_cfb8(void)
{
  return (const EVP_CIPHER *)&aes_128_cfb8;
}

void *EVP_aes_128_ctr()
{
  return &aes_128_ctr;
}

const EVP_CIPHER *EVP_aes_192_cbc(void)
{
  return (const EVP_CIPHER *)&aes_192_cbc;
}

const EVP_CIPHER *EVP_aes_192_ecb(void)
{
  return (const EVP_CIPHER *)&aes_192_ecb;
}

const EVP_CIPHER *EVP_aes_192_ofb(void)
{
  return (const EVP_CIPHER *)&aes_192_ofb;
}

const EVP_CIPHER *EVP_aes_192_cfb128(void)
{
  return (const EVP_CIPHER *)&aes_192_cfb;
}

const EVP_CIPHER *EVP_aes_192_cfb1(void)
{
  return (const EVP_CIPHER *)&aes_192_cfb1;
}

const EVP_CIPHER *EVP_aes_192_cfb8(void)
{
  return (const EVP_CIPHER *)&aes_192_cfb8;
}

void *EVP_aes_192_ctr()
{
  return &aes_192_ctr;
}

const EVP_CIPHER *EVP_aes_256_cbc(void)
{
  return (const EVP_CIPHER *)&aes_256_cbc;
}

const EVP_CIPHER *EVP_aes_256_ecb(void)
{
  return (const EVP_CIPHER *)&aes_256_ecb;
}

const EVP_CIPHER *EVP_aes_256_ofb(void)
{
  return (const EVP_CIPHER *)&aes_256_ofb;
}

const EVP_CIPHER *EVP_aes_256_cfb128(void)
{
  return (const EVP_CIPHER *)&aes_256_cfb;
}

const EVP_CIPHER *EVP_aes_256_cfb1(void)
{
  return (const EVP_CIPHER *)&aes_256_cfb1;
}

const EVP_CIPHER *EVP_aes_256_cfb8(void)
{
  return (const EVP_CIPHER *)&aes_256_cfb8;
}

void *EVP_aes_256_ctr()
{
  return &aes_256_ctr;
}

void *EVP_aes_128_gcm()
{
  return &aes_128_gcm;
}

void *EVP_aes_192_gcm()
{
  return &aes_192_gcm;
}

void *EVP_aes_256_gcm()
{
  return &aes_256_gcm;
}

void *EVP_aes_128_xts()
{
  return &aes_128_xts;
}

void *EVP_aes_256_xts()
{
  return &aes_256_xts;
}

void *EVP_aes_128_ccm()
{
  return &aes_128_ccm;
}

void *EVP_aes_192_ccm()
{
  return &aes_192_ccm;
}

void *EVP_aes_256_ccm()
{
  return &aes_256_ccm;
}

void *EVP_aead_aes_128_gcm()
{
  return &aead_aes_128_gcm;
}

void *EVP_aead_aes_256_gcm()
{
  return &aead_aes_256_gcm;
}

void *EVP_aes_128_wrap()
{
  return &aes_128_wrap;
}

void *EVP_aes_192_wrap()
{
  return &aes_192_wrap;
}

void *EVP_aes_256_wrap()
{
  return &aes_256_wrap;
}

uint64_t aes_init_key(uint64_t a1, unsigned __int8 *userKey, uint64_t a3, int a4)
{
  uint64_t v4;
  int v5;
  int v6;
  void (__cdecl *v7)(const unsigned __int8 *, unsigned __int8 *, const unint64_t, const AES_KEY *, unsigned __int8 *, const int);
  int v8;
  void (__cdecl *v9)(const unsigned __int8 *, unsigned __int8 *, const AES_KEY *);

  v4 = *(_QWORD *)(a1 + 120);
  v5 = *(_DWORD *)(*(_QWORD *)a1 + 16) & 0xF0007;
  v6 = 8 * *(_DWORD *)(a1 + 104);
  if (v5 == 2)
    v7 = AES_cbc_encrypt;
  else
    v7 = 0;
  if (a4 || (v5 - 3) < 0xFFFFFFFE)
  {
    v8 = AES_set_encrypt_key(userKey, v6, (AES_KEY *)v4);
    v9 = AES_encrypt;
  }
  else
  {
    v8 = AES_set_decrypt_key(userKey, v6, (AES_KEY *)v4);
    v9 = AES_decrypt;
  }
  *(_QWORD *)(v4 + 248) = v9;
  *(_QWORD *)(v4 + 256) = v7;
  if ((v8 & 0x80000000) == 0)
    return 1;
  ERR_put_error(6, 4095, 143, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/e_aes.c", 422);
  return 0;
}

uint64_t aes_cbc_cipher(uint64_t a1, uint64_t *a2, _QWORD *a3, unint64_t a4)
{
  uint64_t v5;
  void (*v6)(_QWORD *, uint64_t *, unint64_t);
  _OWORD *v7;
  uint64_t (*v8)(_QWORD *, uint64_t *, uint64_t);

  v5 = *(_QWORD *)(a1 + 120);
  v6 = *(void (**)(_QWORD *, uint64_t *, unint64_t))(v5 + 256);
  if (v6)
  {
    v6(a3, a2, a4);
  }
  else
  {
    v7 = (_OWORD *)(a1 + 40);
    v8 = *(uint64_t (**)(_QWORD *, uint64_t *, uint64_t))(v5 + 248);
    if (*(_DWORD *)(a1 + 16))
      CRYPTO_cbc128_encrypt(a3, a2, a4, v5, v7, (void (*)(_QWORD *, _QWORD *, uint64_t))v8);
    else
      CRYPTO_cbc128_decrypt((uint64_t)a3, a2, a4, v5, v7, v8);
  }
  return 1;
}

uint64_t aes_ecb_cipher(_QWORD *a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  unint64_t v4;
  unint64_t v5;
  unint64_t v8;
  uint64_t v9;

  v4 = *(int *)(*a1 + 4);
  v5 = a4 - v4;
  if (a4 >= v4)
  {
    v8 = 0;
    v9 = a1[15];
    do
    {
      (*(void (**)(unint64_t, unint64_t, uint64_t))(v9 + 248))(a3 + v8, a2 + v8, v9);
      v8 += v4;
    }
    while (v8 <= v5);
  }
  return 1;
}

uint64_t aes_ofb_cipher(uint64_t a1, _BYTE *a2, uint64_t a3, unint64_t a4)
{
  CRYPTO_ofb128_encrypt(a3, a2, a4, *(_QWORD *)(a1 + 120), a1 + 40, (unsigned int *)(a1 + 88), *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(a1 + 120) + 248));
  return 1;
}

uint64_t aes_cfb_cipher(uint64_t a1, _BYTE *a2, uint64_t a3, unint64_t a4)
{
  CRYPTO_cfb128_encrypt(a3, a2, a4, *(_QWORD *)(a1 + 120), a1 + 40, (unsigned int *)(a1 + 88), *(_DWORD *)(a1 + 16), *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(a1 + 120) + 248));
  return 1;
}

uint64_t aes_cfb1_cipher(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  void (*v13)(uint64_t, uint64_t, uint64_t);
  uint64_t v14;

  v4 = a4;
  v5 = a3;
  v6 = a2;
  v8 = *(_QWORD *)(a1 + 120);
  if ((*(_BYTE *)(a1 + 113) & 0x20) != 0)
  {
    v10 = a1 + 40;
    v11 = a1 + 88;
    v12 = *(_DWORD *)(a1 + 16);
    v13 = *(void (**)(uint64_t, uint64_t, uint64_t))(v8 + 248);
    v14 = a3;
    v9 = a4;
    goto LABEL_7;
  }
  if (a4 >> 60)
  {
    do
    {
      CRYPTO_cfb128_1_encrypt(v5, v6, 0x8000000000000000, v8, a1 + 40, a1 + 88, *(_DWORD *)(a1 + 16), *(void (**)(uint64_t, uint64_t, uint64_t))(v8 + 248));
      v4 -= 0x1000000000000000;
      v5 += 0x1000000000000000;
      v6 += 0x1000000000000000;
    }
    while (v4 >> 60);
  }
  if (v4)
  {
    v9 = 8 * v4;
    v10 = a1 + 40;
    v11 = a1 + 88;
    v12 = *(_DWORD *)(a1 + 16);
    v13 = *(void (**)(uint64_t, uint64_t, uint64_t))(v8 + 248);
    v14 = v5;
    a2 = v6;
LABEL_7:
    CRYPTO_cfb128_1_encrypt(v14, a2, v9, v8, v10, v11, v12, v13);
  }
  return 1;
}

uint64_t aes_cfb8_cipher(uint64_t a1, _BYTE *a2, uint64_t a3, uint64_t a4)
{
  CRYPTO_cfb128_8_encrypt(a3, a2, a4, *(_QWORD *)(a1 + 120), (__int128 *)(a1 + 40), a1 + 88, *(_DWORD *)(a1 + 16), *(uint64_t (**)(__int128 *, __int128 *, uint64_t))(*(_QWORD *)(a1 + 120) + 248));
  return 1;
}

uint64_t aes_ctr_cipher(uint64_t a1, _BYTE *a2, uint64_t a3, unint64_t a4)
{
  uint64_t v6;
  uint64_t (*v7)(char *, _BYTE *, unint64_t, uint64_t, uint64_t);
  uint64_t v8;
  _QWORD *v9;
  unsigned int v11;

  v11 = *(_DWORD *)(a1 + 88);
  v6 = *(_QWORD *)(a1 + 120);
  v7 = *(uint64_t (**)(char *, _BYTE *, unint64_t, uint64_t, uint64_t))(v6 + 256);
  v8 = a1 + 40;
  v9 = (_QWORD *)(a1 + 56);
  if (v7)
    CRYPTO_ctr128_encrypt_ctr32(a3, a2, a4, v6, v8, v9, &v11, v7);
  else
    CRYPTO_ctr128_encrypt(a3, a2, a4, v6, v8, (uint64_t)v9, &v11, *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v6 + 248));
  *(_DWORD *)(a1 + 88) = v11;
  return 1;
}

uint64_t aes_gcm_init_key(uint64_t a1, unsigned __int8 *userKey, void *__src)
{
  uint64_t *v3;
  uint64_t v4;

  if ((unint64_t)userKey | (unint64_t)__src)
  {
    v3 = (uint64_t *)__src;
    v4 = *(_QWORD *)(a1 + 120);
    if (userKey)
    {
      AES_set_encrypt_key(userKey, 8 * *(_DWORD *)(a1 + 104), (AES_KEY *)v4);
      CRYPTO_gcm128_init(v4 + 256, v4, (void (*)(unsigned int *, unsigned int *, uint64_t))AES_encrypt);
      *(_QWORD *)(v4 + 672) = 0;
      if (v3 || *(_DWORD *)(v4 + 248) && (v3 = *(uint64_t **)(v4 + 648)) != 0)
      {
        CRYPTO_gcm128_setiv(v4 + 256, v3, *(int *)(v4 + 656));
        *(_DWORD *)(v4 + 248) = 1;
      }
      *(_DWORD *)(v4 + 244) = 1;
    }
    else
    {
      if (*(_DWORD *)(v4 + 244))
        CRYPTO_gcm128_setiv(v4 + 256, (uint64_t *)__src, *(int *)(v4 + 656));
      else
        memcpy(*(void **)(v4 + 648), __src, *(int *)(v4 + 656));
      *(_DWORD *)(v4 + 248) = 1;
      *(_DWORD *)(v4 + 664) = 0;
    }
  }
  return 1;
}

unint64_t aes_gcm_cipher(EVP_CIPHER_CTX *ctx, char *a2, char *ptr, unint64_t a4)
{
  _DWORD *cipher_data;
  unint64_t result;
  unint64_t v9;
  int v10;
  int encrypt;
  void (*v12)(char *, _BYTE *, uint64_t, uint64_t, uint64_t);
  uint64_t v13;
  char *v14;
  void (*v15)(char *, _BYTE *, uint64_t, uint64_t, uint64_t);
  uint64_t v16;
  unint64_t v17;
  size_t v18;

  cipher_data = ctx->cipher_data;
  if (!cipher_data[61])
    return 0xFFFFFFFFLL;
  if ((cipher_data[167] & 0x80000000) != 0)
  {
    if (!cipher_data[62])
      return 0xFFFFFFFFLL;
    if (!ptr)
    {
      if (ctx->encrypt)
      {
        CRYPTO_gcm128_tag((uint64_t)(cipher_data + 64), ctx->buf, 0x10uLL);
        result = 0;
        cipher_data[165] = 16;
      }
      else
      {
        v18 = cipher_data[165];
        if ((v18 & 0x80000000) != 0)
          return 0xFFFFFFFFLL;
        result = CRYPTO_gcm128_finish((uint64_t)(cipher_data + 64), ctx->buf, v18);
        if ((_DWORD)result)
          return 0xFFFFFFFFLL;
      }
      cipher_data[62] = 0;
      return result;
    }
    if (a2)
    {
      encrypt = ctx->encrypt;
      v12 = (void (*)(char *, _BYTE *, uint64_t, uint64_t, uint64_t))*((_QWORD *)cipher_data + 84);
      v13 = (uint64_t)(cipher_data + 64);
      if (encrypt)
      {
        if (v12)
        {
          if (!CRYPTO_gcm128_encrypt_ctr32(v13, ptr, a2, a4, v12))
            return a4;
          return 0xFFFFFFFFLL;
        }
        if (CRYPTO_gcm128_encrypt(v13, ptr, a2, a4))
          return 0xFFFFFFFFLL;
      }
      else
      {
        if (v12)
        {
          if (!CRYPTO_gcm128_decrypt_ctr32(v13, ptr, a2, a4, v12))
            return a4;
          return 0xFFFFFFFFLL;
        }
        if (CRYPTO_gcm128_decrypt(v13, ptr, a2, a4))
          return 0xFFFFFFFFLL;
      }
      return a4;
    }
    if (!CRYPTO_gcm128_aad((uint64_t)(cipher_data + 64), ptr, a4))
      return a4;
    return 0xFFFFFFFFLL;
  }
  result = 0xFFFFFFFFLL;
  if (a2 == ptr)
  {
    v9 = a4 - 24;
    if (a4 >= 0x18)
    {
      if (ctx->encrypt)
        v10 = 19;
      else
        v10 = 24;
      if (EVP_CIPHER_CTX_ctrl(ctx, v10, 8, ptr) < 1
        || CRYPTO_gcm128_aad((uint64_t)(cipher_data + 64), (char *)ctx->buf, (int)cipher_data[167]))
      {
        goto LABEL_10;
      }
      v14 = ptr + 8;
      v15 = (void (*)(char *, _BYTE *, uint64_t, uint64_t, uint64_t))*((_QWORD *)cipher_data + 84);
      v16 = (uint64_t)(cipher_data + 64);
      v17 = a4 - 24;
      if (ctx->encrypt)
      {
        if (v15)
        {
          if (!CRYPTO_gcm128_encrypt_ctr32(v16, v14, v14, v17, v15))
            goto LABEL_41;
        }
        else if (!CRYPTO_gcm128_encrypt(v16, v14, v14, v17))
        {
LABEL_41:
          CRYPTO_gcm128_tag((uint64_t)(cipher_data + 64), &v14[v9], 0x10uLL);
          result = a4;
          goto LABEL_11;
        }
LABEL_10:
        result = 0xFFFFFFFFLL;
LABEL_11:
        cipher_data[62] = 0;
        cipher_data[167] = -1;
        return result;
      }
      if (v15)
      {
        if (CRYPTO_gcm128_decrypt_ctr32(v16, v14, v14, v17, v15))
          goto LABEL_10;
      }
      else if (CRYPTO_gcm128_decrypt(v16, v14, v14, v17))
      {
        goto LABEL_10;
      }
      CRYPTO_gcm128_tag((uint64_t)(cipher_data + 64), ctx->buf, 0x10uLL);
      if (*(_QWORD *)ctx->buf == *(_QWORD *)&v14[v9] && *(_QWORD *)&ctx->buf[8] == *(_QWORD *)&v14[v9 + 8])
      {
        result = a4 - 24;
        goto LABEL_11;
      }
      explicit_bzero(v14, a4 - 24);
      goto LABEL_10;
    }
  }
  return result;
}

uint64_t aes_gcm_cleanup(uint64_t a1)
{
  _QWORD *v2;
  void *v3;

  v2 = *(_QWORD **)(a1 + 120);
  v3 = (void *)v2[81];
  if (v3 != (void *)(a1 + 40))
    free(v3);
  explicit_bzero(v2, 0x2A8uLL);
  return 1;
}

uint64_t aes_gcm_ctrl(uint64_t a1, int a2, size_t __n, uint64_t *__src)
{
  uint64_t v5;
  uint64_t result;
  int v8;
  uint64_t v9;
  uint64_t v10;
  const void *v11;
  int v12;
  void *v13;
  uint64_t v14;
  int v16;
  uint64_t v17;
  uint64_t v18;
  char v19;
  uint64_t v20;
  unsigned int v21;
  unsigned int v22;

  v5 = *(_QWORD *)(a1 + 120);
  result = 0xFFFFFFFFLL;
  v8 = __n;
  switch(a2)
  {
    case 8:
      v9 = __src[15];
      v10 = *(_QWORD *)(v5 + 640);
      if (v10)
      {
        if (v10 != v5)
          return 0;
        *(_QWORD *)(v9 + 640) = v9;
      }
      if (*(_QWORD *)(v5 + 648) == a1 + 40)
      {
        *(_QWORD *)(v9 + 648) = __src + 5;
        return 1;
      }
      result = (uint64_t)malloc_type_calloc(1uLL, *(int *)(v5 + 656), 0x5934C551uLL);
      *(_QWORD *)(v9 + 648) = result;
      if (result)
      {
        v11 = *(const void **)(v5 + 648);
        __n = *(int *)(v5 + 656);
        goto LABEL_22;
      }
      return result;
    case 9:
      if ((int)__n < 1)
        return 0;
      if (__n < 0x11 || *(_DWORD *)(v5 + 656) >= (int)__n)
        goto LABEL_17;
      v13 = *(void **)(v5 + 648);
      if (v13 != (void *)(a1 + 40))
        free(v13);
      result = (uint64_t)malloc_type_malloc(v8, 0xDDFE345BuLL);
      *(_QWORD *)(v5 + 648) = result;
      if (result)
      {
LABEL_17:
        *(_DWORD *)(v5 + 656) = v8;
        return 1;
      }
      return result;
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 20:
    case 21:
    case 23:
      return result;
    case 16:
      if ((__n - 17) < 0xFFFFFFF0 || !*(_DWORD *)(a1 + 16) || (*(_DWORD *)(v5 + 660) & 0x80000000) != 0)
        return 0;
      v11 = (const void *)(a1 + 56);
      __n = __n;
      result = (uint64_t)__src;
LABEL_22:
      memcpy((void *)result, v11, __n);
      return 1;
    case 17:
      if ((__n - 17) < 0xFFFFFFF0 || *(_DWORD *)(a1 + 16))
        return 0;
      memcpy((void *)(a1 + 56), __src, __n);
      *(_DWORD *)(v5 + 660) = v8;
      return 1;
    case 18:
      if ((_DWORD)__n == -1)
      {
        memcpy(*(void **)(v5 + 648), __src, *(int *)(v5 + 656));
LABEL_55:
        result = 1;
        *(_DWORD *)(v5 + 664) = 1;
        return result;
      }
      if ((int)__n >= 4 && *(_DWORD *)(v5 + 656) - (int)__n >= 8)
      {
        memcpy(*(void **)(v5 + 648), __src, __n);
        if (*(_DWORD *)(a1 + 16))
          arc4random_buf((void *)(*(_QWORD *)(v5 + 648) + v8), *(int *)(v5 + 656) - (uint64_t)v8);
        goto LABEL_55;
      }
      return 0;
    case 19:
      if (!*(_DWORD *)(v5 + 664) || !*(_DWORD *)(v5 + 244))
        return 0;
      CRYPTO_gcm128_setiv(v5 + 256, *(uint64_t **)(v5 + 648), *(int *)(v5 + 656));
      v14 = *(int *)(v5 + 656);
      if ((int)v14 < v8 || v8 < 1)
        v16 = *(_DWORD *)(v5 + 656);
      else
        v16 = v8;
      memcpy(__src, (const void *)(*(_QWORD *)(v5 + 648) + v14 - v16), v16);
      v17 = 0;
      v18 = *(int *)(v5 + 656) + *(_QWORD *)(v5 + 648) - 1;
      do
      {
        v19 = *(_BYTE *)(v18 + v17) + 1;
        *(_BYTE *)(v18 + v17) = v19;
        if (v17 == -7)
          break;
        --v17;
      }
      while (!v19);
      goto LABEL_53;
    case 22:
      if ((_DWORD)__n != 13)
        return 0;
      v20 = *__src;
      *(_QWORD *)(a1 + 61) = *(uint64_t *)((char *)__src + 5);
      *(_QWORD *)(a1 + 56) = v20;
      *(_DWORD *)(v5 + 668) = 13;
      v21 = __rev16(*(unsigned __int16 *)(a1 + 67));
      v22 = v21 - 8;
      if (v21 < 8)
        return 0;
      if (*(_DWORD *)(a1 + 16))
        goto LABEL_48;
      if (v22 < 0x10)
        return 0;
      v22 = v21 - 24;
LABEL_48:
      *(_WORD *)(a1 + 67) = bswap32(v22) >> 16;
      return 16;
    case 24:
      if (!*(_DWORD *)(v5 + 664) || !*(_DWORD *)(v5 + 244) || *(_DWORD *)(a1 + 16))
        return 0;
      memcpy((void *)(*(_QWORD *)(v5 + 648) + *(int *)(v5 + 656) - (int)__n), __src, (int)__n);
      CRYPTO_gcm128_setiv(v5 + 256, *(uint64_t **)(v5 + 648), *(int *)(v5 + 656));
LABEL_53:
      result = 1;
      *(_DWORD *)(v5 + 248) = 1;
      return result;
    default:
      if (a2)
        return result;
      *(_DWORD *)(v5 + 244) = 0;
      *(_DWORD *)(v5 + 248) = 0;
      v12 = *(_DWORD *)(*(_QWORD *)a1 + 12);
      if (!v12)
      {
        ERR_put_error(6, 4095, 194, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/e_aes.c", 1298);
        return 0;
      }
      *(_DWORD *)(v5 + 656) = v12;
      *(_QWORD *)(v5 + 648) = a1 + 40;
      *(_DWORD *)(v5 + 660) = -1;
      *(_QWORD *)(v5 + 664) = 0xFFFFFFFF00000000;
      return 1;
  }
}

uint64_t aes_xts_init_key(uint64_t a1, unsigned __int8 *userKey, unint64_t a3, int a4)
{
  uint64_t v7;
  int v8;
  void (__cdecl *v9)(const unsigned __int8 *, unsigned __int8 *, const AES_KEY *);
  int v10;
  int v11;

  if ((unint64_t)userKey | a3)
  {
    v7 = *(_QWORD *)(a1 + 120);
    if (userKey)
    {
      *(_QWORD *)(v7 + 520) = 0;
      v8 = 4 * *(_DWORD *)(a1 + 104);
      if (a4)
      {
        AES_set_encrypt_key(userKey, v8, (AES_KEY *)v7);
        v9 = AES_encrypt;
      }
      else
      {
        AES_set_decrypt_key(userKey, v8, (AES_KEY *)v7);
        v9 = AES_decrypt;
      }
      *(_QWORD *)(v7 + 504) = v9;
      v10 = *(_DWORD *)(a1 + 104);
      if (v10 >= 0)
        v11 = *(_DWORD *)(a1 + 104);
      else
        v11 = v10 + 1;
      AES_set_encrypt_key(&userKey[v11 >> 1], 4 * v10, (AES_KEY *)(v7 + 244));
      *(_QWORD *)(v7 + 512) = AES_encrypt;
      *(_QWORD *)(v7 + 488) = v7;
    }
    if (a3)
    {
      *(_QWORD *)(v7 + 496) = v7 + 244;
      *(_OWORD *)(a1 + 40) = *(_OWORD *)a3;
    }
  }
  return 1;
}

BOOL aes_xts_cipher(uint64_t a1, __n128 *a2, int8x16_t *a3, unint64_t a4)
{
  _QWORD *v4;
  uint64_t v5;
  void (*v6)(int8x16_t *, __n128 *, unint64_t);

  v4 = *(_QWORD **)(a1 + 120);
  if (!v4[61] || !v4[62])
    return 0;
  v5 = 0;
  if (a2 && a3 && a4 >= 0x10)
  {
    v6 = (void (*)(int8x16_t *, __n128 *, unint64_t))v4[65];
    if (v6)
    {
      v6(a3, a2, a4);
      return 1;
    }
    return !CRYPTO_xts128_encrypt(v4 + 61, (int8x16_t *)(a1 + 40), a3, a2, a4, *(_DWORD *)(a1 + 16));
  }
  return v5;
}

uint64_t aes_xts_ctrl(uint64_t a1, int a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  v4 = *(_QWORD *)(a1 + 120);
  if (a2 == 8)
  {
    v6 = *(_QWORD *)(a4 + 120);
    v7 = *(_QWORD *)(v4 + 488);
    if (v7)
    {
      if (v7 != v4)
        return 0;
      *(_QWORD *)(v6 + 488) = v6;
    }
    v8 = *(_QWORD *)(v4 + 496);
    if (!v8)
      return 1;
    if (v8 == v4 + 244)
    {
      *(_QWORD *)(v6 + 496) = v6 + 244;
      return 1;
    }
    return 0;
  }
  if (!a2)
  {
    *(_QWORD *)(v4 + 488) = 0;
    *(_QWORD *)(v4 + 496) = 0;
    return 1;
  }
  return 0xFFFFFFFFLL;
}

uint64_t aes_ccm_init_key(uint64_t a1, unsigned __int8 *userKey, unint64_t __src)
{
  uint64_t v5;

  if ((unint64_t)userKey | __src)
  {
    v5 = *(_QWORD *)(a1 + 120);
    if (userKey)
    {
      AES_set_encrypt_key(userKey, 8 * *(_DWORD *)(a1 + 104), (AES_KEY *)v5);
      CRYPTO_ccm128_init((_QWORD *)(v5 + 272), *(_DWORD *)(v5 + 264), *(_DWORD *)(v5 + 260), v5, (uint64_t)AES_encrypt);
      *(_QWORD *)(v5 + 328) = 0;
      *(_DWORD *)(v5 + 244) = 1;
    }
    if (__src)
    {
      memcpy((void *)(a1 + 40), (const void *)__src, 15 - *(int *)(v5 + 260));
      *(_DWORD *)(v5 + 248) = 1;
    }
  }
  return 1;
}

uint64_t aes_ccm_cipher(uint64_t a1, uint64_t *a2, char *a3, unint64_t a4)
{
  unint64_t v4;
  int8x16_t *v8;
  int v9;
  void (*v10)(char *, _BYTE *, unint64_t, uint64_t, int8x16_t *, int8x16_t *);
  int8x16_t *v11;
  int v12;
  int8x16_t *v13;
  int v14;
  _BYTE __s1[16];
  uint64_t v17;

  v4 = a4;
  v17 = *MEMORY[0x24BDAC8D0];
  v8 = *(int8x16_t **)(a1 + 120);
  if (!v8[15].i32[2] && !v8[15].i32[1])
    return 0xFFFFFFFFLL;
  v9 = *(_DWORD *)(a1 + 16);
  if (!v9 && !v8[15].i32[3])
    return 0xFFFFFFFFLL;
  if (a2)
  {
    if (a3)
    {
      if (v8[16].i32[0])
        goto LABEL_8;
      if (!CRYPTO_ccm128_setiv(v8[17].i8, (const void *)(a1 + 40), 15 - v8[16].i32[1], a4))
      {
        v8[16].i32[0] = 1;
        v9 = *(_DWORD *)(a1 + 16);
LABEL_8:
        v10 = (void (*)(char *, _BYTE *, unint64_t, uint64_t, int8x16_t *, int8x16_t *))v8[20].i64[1];
        if (v9)
        {
          v11 = v8 + 17;
          if (v10)
          {
            CRYPTO_ccm128_encrypt_ccm64(v11, a3, a2, v4, v10);
            if (!v12)
              goto LABEL_27;
          }
          else
          {
            CRYPTO_ccm128_encrypt(v11, a3, a2, v4);
            if (!v14)
            {
LABEL_27:
              v8[15].i32[3] = 1;
              return v4;
            }
          }
          return 0xFFFFFFFFLL;
        }
        v13 = v8 + 17;
        if (v10)
        {
          if (!CRYPTO_ccm128_decrypt_ccm64(v13, a3, a2, v4, v10))
            goto LABEL_29;
        }
        else if (!CRYPTO_ccm128_decrypt(v13, a3, a2, v4))
        {
LABEL_29:
          if (CRYPTO_ccm128_tag((unsigned __int8 *)&v8[17], __s1, v8[16].i32[2])
            && !memcmp(__s1, (const void *)(a1 + 56), v8[16].i32[2])
            && (_DWORD)v4 != -1)
          {
            goto LABEL_32;
          }
        }
        explicit_bzero(a2, v4);
        v4 = 0xFFFFFFFFLL;
LABEL_32:
        v8[15].i64[1] = 0;
        v8[16].i32[0] = 0;
        return v4;
      }
      return 0xFFFFFFFFLL;
    }
    return 0;
  }
  else if (a3)
  {
    if (a4 && !v8[16].i32[0])
      return 0xFFFFFFFFLL;
    CRYPTO_ccm128_aad((uint64_t)v8[17].i64, a3, a4);
  }
  else
  {
    if (CRYPTO_ccm128_setiv(v8[17].i8, (const void *)(a1 + 40), 15 - v8[16].i32[1], a4))
      return 0xFFFFFFFFLL;
    v8[16].i32[0] = 1;
  }
  return v4;
}

size_t aes_ccm_ctrl(uint64_t a1, int a2, size_t __n, _QWORD *__dst)
{
  int v4;
  uint64_t v6;
  size_t result;
  uint64_t v8;

  v4 = __n;
  v6 = *(_QWORD *)(a1 + 120);
  result = 0xFFFFFFFFLL;
  switch(a2)
  {
    case 8:
      v8 = *(_QWORD *)(v6 + 320);
      if (!v8)
        return 1;
      if (v8 != v6)
        return 0;
      *(_QWORD *)(__dst[15] + 320) = __dst[15];
      return 1;
    case 9:
      v4 = 15 - __n;
      goto LABEL_9;
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
      return result;
    case 16:
      if (!*(_DWORD *)(a1 + 16) || !*(_DWORD *)(v6 + 252))
        return 0;
      result = CRYPTO_ccm128_tag((unsigned __int8 *)(v6 + 272), __dst, (int)__n);
      if (result)
      {
        *(_QWORD *)(v6 + 248) = 0;
        result = 1;
        *(_DWORD *)(v6 + 256) = 0;
      }
      return result;
    case 17:
      result = 0;
      if ((__n & 1) != 0 || (__n - 17) < 0xFFFFFFF3)
        return result;
      if ((__dst != 0) == (*(_DWORD *)(a1 + 16) != 0))
        return 0;
      if (__dst)
      {
        *(_DWORD *)(v6 + 252) = 1;
        memcpy((void *)(a1 + 56), __dst, __n);
      }
      *(_DWORD *)(v6 + 264) = v4;
      return 1;
    default:
      if (a2 == 20)
      {
LABEL_9:
        if ((v4 - 9) < 0xFFFFFFF9)
        {
          return 0;
        }
        else
        {
          *(_DWORD *)(v6 + 260) = v4;
          return 1;
        }
      }
      else if (!a2)
      {
        *(_QWORD *)(v6 + 260) = 0xC00000008;
        *(_DWORD *)(v6 + 256) = 0;
        *(_QWORD *)(v6 + 248) = 0;
        result = 1;
        *(_DWORD *)(v6 + 244) = 0;
      }
      return result;
  }
}

uint64_t aead_aes_gcm_init(uint64_t a1, const unsigned __int8 *a2, uint64_t a3, unint64_t a4)
{
  int v4;
  unint64_t v7;
  int v8;
  int v9;
  uint64_t result;
  uint64_t v11;
  uint64_t v12;

  v4 = a3;
  if (8 * a3 != 128 && 8 * a3 != 256)
  {
    v8 = 137;
    v9 = 2249;
    goto LABEL_9;
  }
  if (a4)
    v7 = a4;
  else
    v7 = 16;
  if (v7 >= 0x11)
  {
    v8 = 171;
    v9 = 2257;
LABEL_9:
    ERR_put_error(6, 4095, v8, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/e_aes.c", v9);
    return 0;
  }
  result = (uint64_t)malloc_type_calloc(1uLL, 0x290uLL, 0x1080040FF578D95uLL);
  if (result)
  {
    v11 = result;
    v12 = result + 248;
    AES_set_encrypt_key(a2, 8 * v4, (AES_KEY *)result);
    CRYPTO_gcm128_init(v12, v11, (void (*)(unsigned int *, unsigned int *, uint64_t))AES_encrypt);
    *(_QWORD *)(v11 + 640) = 0;
    *(_BYTE *)(v11 + 648) = v7;
    result = 1;
    *(_QWORD *)(a1 + 8) = v11;
  }
  return result;
}

void aead_aes_gcm_cleanup(uint64_t a1)
{
  freezero(*(void **)(a1 + 8), 0x290uLL);
}

uint64_t aead_aes_gcm_seal(uint64_t a1, _BYTE *a2, _QWORD *a3, unint64_t a4, uint64_t *a5, unint64_t a6, char *a7, unint64_t a8, char *a9, uint64_t a10)
{
  uint64_t v10;
  int v11;
  int v12;
  void (*v19)(char *, _BYTE *, uint64_t, uint64_t, uint64_t);
  _BYTE __dst[392];

  v10 = *(_QWORD *)(a1 + 8);
  if (*(unsigned __int8 *)(v10 + 648) + a8 > a4)
  {
    v11 = 155;
    v12 = 2301;
LABEL_10:
    ERR_put_error(6, 4095, v11, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/e_aes.c", v12);
    return 0;
  }
  memcpy(__dst, (const void *)(v10 + 248), sizeof(__dst));
  if (!a6)
  {
    v11 = 194;
    v12 = 2308;
    goto LABEL_10;
  }
  CRYPTO_gcm128_setiv((uint64_t)__dst, a5, a6);
  if (a10 && CRYPTO_gcm128_aad((uint64_t)__dst, a9, a10))
    return 0;
  v19 = *(void (**)(char *, _BYTE *, uint64_t, uint64_t, uint64_t))(v10 + 640);
  if (v19)
  {
    if (CRYPTO_gcm128_encrypt_ctr32((uint64_t)__dst, a7, a2, a8, v19))
      return 0;
  }
  else if (CRYPTO_gcm128_encrypt((uint64_t)__dst, a7, a2, a8))
  {
    return 0;
  }
  CRYPTO_gcm128_tag((uint64_t)__dst, &a2[a8], *(unsigned __int8 *)(v10 + 648));
  *a3 = *(unsigned __int8 *)(v10 + 648) + a8;
  return 1;
}

uint64_t aead_aes_gcm_open(uint64_t a1, _BYTE *a2, unint64_t *a3, unint64_t a4, uint64_t *a5, unint64_t a6, char *a7, unint64_t a8, char *a9, uint64_t a10)
{
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  int v13;
  int v14;
  void (*v21)(char *, _BYTE *, uint64_t, uint64_t, uint64_t);
  unint64_t v22;
  _BYTE __dst[392];
  unsigned __int8 v25[16];
  uint64_t v26;

  v26 = *MEMORY[0x24BDAC8D0];
  v10 = *(_QWORD *)(a1 + 8);
  v11 = *(unsigned __int8 *)(v10 + 648);
  v12 = a8 - v11;
  if (a8 < v11)
  {
    v13 = 100;
    v14 = 2345;
LABEL_11:
    ERR_put_error(6, 4095, v13, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/e_aes.c", v14);
    return 0;
  }
  if (v12 > a4)
  {
    v13 = 155;
    v14 = 2352;
    goto LABEL_11;
  }
  memcpy(__dst, (const void *)(v10 + 248), sizeof(__dst));
  if (!a6)
  {
    v13 = 194;
    v14 = 2359;
    goto LABEL_11;
  }
  CRYPTO_gcm128_setiv((uint64_t)__dst, a5, a6);
  if (CRYPTO_gcm128_aad((uint64_t)__dst, a9, a10))
    return 0;
  v21 = *(void (**)(char *, _BYTE *, uint64_t, uint64_t, uint64_t))(v10 + 640);
  v22 = a8 - *(unsigned __int8 *)(v10 + 648);
  if (v21)
  {
    if (!CRYPTO_gcm128_decrypt_ctr32((uint64_t)__dst, a7, a2, v22, v21))
      goto LABEL_14;
    return 0;
  }
  if (CRYPTO_gcm128_decrypt((uint64_t)__dst, a7, a2, v22))
    return 0;
LABEL_14:
  CRYPTO_gcm128_tag((uint64_t)__dst, v25, *(unsigned __int8 *)(v10 + 648));
  if (timingsafe_memcmp(v25, (unsigned __int8 *)&a7[v12], *(unsigned __int8 *)(v10 + 648)))
  {
    v13 = 100;
    v14 = 2379;
    goto LABEL_11;
  }
  *a3 = v12;
  return 1;
}

uint64_t aes_wrap_init_key(const EVP_CIPHER_CTX *a1, unsigned __int8 *userKey, unint64_t a3)
{
  AES_KEY *cipher_data;
  int encrypt;
  int v8;
  unsigned __int8 *iv;
  int v10;

  if ((unint64_t)userKey | a3)
  {
    cipher_data = (AES_KEY *)a1->cipher_data;
    if (userKey)
    {
      encrypt = a1->encrypt;
      v8 = 8 * a1->key_len;
      if (encrypt)
      {
        AES_set_encrypt_key(userKey, v8, cipher_data);
        if (!a3)
          goto LABEL_10;
      }
      else
      {
        AES_set_decrypt_key(userKey, v8, cipher_data);
        if (!a3)
        {
LABEL_10:
          iv = 0;
          goto LABEL_11;
        }
      }
    }
    else if (!a3)
    {
      return 1;
    }
    iv = a1->iv;
    v10 = EVP_CIPHER_CTX_iv_length(a1);
    memcpy(a1->iv, (const void *)a3, v10);
LABEL_11:
    *(_QWORD *)&cipher_data[1].rd_key[1] = iv;
  }
  return 1;
}

uint64_t aes_wrap_cipher(uint64_t a1, unsigned __int8 *out, unsigned __int8 *in, unint64_t inlen)
{
  uint64_t v6;
  uint64_t v9;
  int v10;
  BOOL v12;
  const unsigned __int8 *v13;
  unsigned int v14;

  if (!in)
    return 0;
  if ((inlen & 7) != 0)
    return 0xFFFFFFFFLL;
  v9 = *(_QWORD *)(a1 + 120);
  v10 = *(_DWORD *)(a1 + 16);
  if (inlen <= 7 && v10)
    return 0xFFFFFFFFLL;
  v12 = inlen < 0x10 && v10 == 0;
  v6 = 0xFFFFFFFFLL;
  if (!(inlen >> 31) && !v12)
  {
    if (out)
    {
      v13 = *(const unsigned __int8 **)(v9 + 248);
      if (v10)
        v14 = AES_wrap_key((AES_KEY *)v9, v13, out, in, inlen);
      else
        v14 = AES_unwrap_key((AES_KEY *)v9, v13, out, in, inlen);
      if (v14)
        return v14;
      else
        return 0xFFFFFFFFLL;
    }
    else
    {
      LODWORD(v6) = inlen - 8;
      if (v10)
        return (inlen + 8);
      else
        return v6;
    }
  }
  return v6;
}

uint64_t aes_wrap_ctrl(uint64_t a1, int a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;

  if (a2 != 8)
    return 0xFFFFFFFFLL;
  v4 = *(_QWORD *)(*(_QWORD *)(a1 + 120) + 248);
  if (v4)
  {
    if (a1 + 40 != v4)
      return 0;
    *(_QWORD *)(*(_QWORD *)(a4 + 120) + 248) = a4 + 40;
  }
  return 1;
}

void ENGINE_load_builtin_engines(void)
{
  OPENSSL_init_crypto(0);
  pthread_once(&ENGINE_load_builtin_engines_once, (void (*)(void))ENGINE_load_builtin_engines_internal);
}

uint64_t EVP_aes_128_cbc_hmac_sha1()
{
  return 0;
}

uint64_t EVP_aes_256_cbc_hmac_sha1()
{
  return 0;
}

const EC_METHOD *EC_GFp_mont_method(void)
{
  return (const EC_METHOD *)&ec_GFp_mont_method;
}

uint64_t ec_GFp_mont_group_init(uint64_t a1)
{
  uint64_t result;

  result = ec_GFp_simple_group_init(a1);
  *(_QWORD *)(a1 + 208) = 0;
  *(_QWORD *)(a1 + 216) = 0;
  return result;
}

void ec_GFp_mont_group_finish(uint64_t a1)
{
  BN_MONT_CTX_free(*(BN_MONT_CTX **)(a1 + 208));
  *(_QWORD *)(a1 + 208) = 0;
  BN_free(*(BIGNUM **)(a1 + 216));
  *(_QWORD *)(a1 + 216) = 0;
  ec_GFp_simple_group_finish(a1);
}

BN_MONT_CTX *ec_GFp_mont_group_copy(uint64_t a1, uint64_t a2)
{
  BN_MONT_CTX *result;
  const BIGNUM *v5;
  BIGNUM *v6;

  BN_MONT_CTX_free(*(BN_MONT_CTX **)(a1 + 208));
  *(_QWORD *)(a1 + 208) = 0;
  BN_free(*(BIGNUM **)(a1 + 216));
  *(_QWORD *)(a1 + 216) = 0;
  result = (BN_MONT_CTX *)ec_GFp_simple_group_copy(a1, a2);
  if ((_DWORD)result)
  {
    if (*(_QWORD *)(a2 + 208))
    {
      result = BN_MONT_CTX_new();
      *(_QWORD *)(a1 + 208) = result;
      if (!result)
        return result;
      if (!BN_MONT_CTX_copy(result, *(BN_MONT_CTX **)(a2 + 208)))
        goto LABEL_8;
    }
    v5 = *(const BIGNUM **)(a2 + 216);
    if (v5 && (v6 = BN_dup(v5), (*(_QWORD *)(a1 + 216) = v6) == 0))
    {
LABEL_8:
      result = *(BN_MONT_CTX **)(a1 + 208);
      if (result)
      {
        BN_MONT_CTX_free(result);
        result = 0;
        *(_QWORD *)(a1 + 208) = 0;
      }
    }
    else
    {
      return (BN_MONT_CTX *)1;
    }
  }
  return result;
}

uint64_t ec_GFp_mont_group_set_curve(uint64_t a1, BIGNUM *a2, const BIGNUM *a3, const BIGNUM *a4, BN_CTX *a5)
{
  BN_MONT_CTX *v10;
  BN_MONT_CTX *v11;
  BIGNUM *v12;
  const BIGNUM *v13;
  uint64_t v14;

  BN_MONT_CTX_free(*(BN_MONT_CTX **)(a1 + 208));
  *(_QWORD *)(a1 + 208) = 0;
  BN_free(*(BIGNUM **)(a1 + 216));
  *(_QWORD *)(a1 + 216) = 0;
  v10 = BN_MONT_CTX_new();
  v11 = v10;
  if (!v10)
    goto LABEL_8;
  if (!BN_MONT_CTX_set(v10, a2, a5))
  {
    ERR_put_error(16, 4095, 3, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ecp_mont.c", 140);
LABEL_8:
    v12 = 0;
LABEL_9:
    v14 = 0;
    goto LABEL_10;
  }
  v12 = BN_new();
  if (!v12)
    goto LABEL_9;
  v13 = BN_value_one();
  if (!BN_to_montgomery(v12, v13, (uint64_t)v11, a5))
    goto LABEL_9;
  *(_QWORD *)(a1 + 208) = v11;
  *(_QWORD *)(a1 + 216) = v12;
  v14 = ec_GFp_simple_group_set_curve(a1, a2, a3, a4, a5);
  if ((_DWORD)v14)
  {
    v11 = 0;
    v12 = 0;
  }
  else
  {
    BN_MONT_CTX_free(*(BN_MONT_CTX **)(a1 + 208));
    *(_QWORD *)(a1 + 208) = 0;
    BN_free(*(BIGNUM **)(a1 + 216));
    v11 = 0;
    v12 = 0;
    *(_QWORD *)(a1 + 216) = 0;
  }
LABEL_10:
  BN_MONT_CTX_free(v11);
  BN_free(v12);
  return v14;
}

uint64_t ec_GFp_mont_field_mul(uint64_t a1, BIGNUM *r, BIGNUM *a, BIGNUM *b, BN_CTX *a5)
{
  BN_MONT_CTX *v5;

  v5 = *(BN_MONT_CTX **)(a1 + 208);
  if (v5)
    return BN_mod_mul_montgomery(r, a, b, v5, a5);
  ERR_put_error(16, 4095, 111, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ecp_mont.c", 170);
  return 0;
}

uint64_t ec_GFp_mont_field_sqr(uint64_t a1, BIGNUM *r, BIGNUM *a, BN_CTX *ctx)
{
  BN_MONT_CTX *v5;

  v5 = *(BN_MONT_CTX **)(a1 + 208);
  if (v5)
    return BN_mod_mul_montgomery(r, a, a, v5, ctx);
  ERR_put_error(16, 4095, 111, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ecp_mont.c", 181);
  return 0;
}

uint64_t ec_GFp_mont_field_encode(uint64_t a1, BIGNUM *a2, const BIGNUM *a3, BN_CTX *a4)
{
  uint64_t v4;

  v4 = *(_QWORD *)(a1 + 208);
  if (v4)
    return BN_to_montgomery(a2, a3, v4, a4);
  ERR_put_error(16, 4095, 111, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ecp_mont.c", 192);
  return 0;
}

uint64_t ec_GFp_mont_field_decode(uint64_t a1, BIGNUM *r, BIGNUM *a, BN_CTX *a4)
{
  BN_MONT_CTX *v4;

  v4 = *(BN_MONT_CTX **)(a1 + 208);
  if (v4)
    return BN_from_montgomery(r, a, v4, a4);
  ERR_put_error(16, 4095, 111, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ecp_mont.c", 203);
  return 0;
}

BOOL ec_GFp_mont_field_set_to_one(uint64_t a1, BIGNUM *a2)
{
  const BIGNUM *v2;

  v2 = *(const BIGNUM **)(a1 + 216);
  if (v2)
    return bn_copy(a2, v2);
  ERR_put_error(16, 4095, 111, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ecp_mont.c", 213);
  return 0;
}

int ASN1_item_ndef_i2d(ASN1_VALUE *val, unsigned __int8 **out, const ASN1_ITEM *it)
{
  return asn1_item_flags_i2d(val, out, (ASN1_ITEM *)it, 2048);
}

uint64_t asn1_item_flags_i2d(ASN1_VALUE *a1, unsigned __int8 **out, ASN1_ITEM *it, int aclass)
{
  uint64_t v7;
  unsigned __int8 *v9;
  unsigned __int8 *v10;
  unsigned __int8 *v11;
  ASN1_VALUE *pval;

  pval = a1;
  if (!out || *out)
    return ASN1_item_ex_i2d(&pval, out, it, -1, aclass);
  v7 = ASN1_item_ex_i2d(&pval, 0, it, -1, aclass);
  if ((int)v7 >= 1)
  {
    v9 = (unsigned __int8 *)malloc_type_calloc(1uLL, v7, 0x9799F1EFuLL);
    if (v9)
    {
      v10 = v9;
      v11 = v9;
      if (ASN1_item_ex_i2d(&pval, &v11, it, -1, aclass) == (_DWORD)v7)
      {
        *out = v10;
        return v7;
      }
      freezero(v10, v7);
      ERR_put_error(13, 4095, 136, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/tasn_enc.c", 124);
    }
    return 0xFFFFFFFFLL;
  }
  return v7;
}

int ASN1_item_i2d(ASN1_VALUE *val, unsigned __int8 **out, const ASN1_ITEM *it)
{
  return asn1_item_flags_i2d(val, out, (ASN1_ITEM *)it, 0);
}

int ASN1_item_ex_i2d(ASN1_VALUE **pval, unsigned __int8 **out, const ASN1_ITEM *it, int tag, int aclass)
{
  int v5;
  int v6;
  const ASN1_ITEM *v7;
  unsigned __int8 **v8;
  ASN1_VALUE **v9;
  _QWORD *funcs;
  int itype;
  unsigned int (*v12)(uint64_t, ASN1_VALUE **, const ASN1_ITEM *, _QWORD);
  int v13;
  int v14;
  int *templates;
  int v17;
  int v18;
  uint64_t v19;
  const ASN1_TEMPLATE *v20;
  const ASN1_TEMPLATE *v21;
  int *v22;
  STACK **field_ptr;
  int v24;
  int v25;
  unsigned int choice_selector;
  const ASN1_TEMPLATE *v27;
  uint64_t v28;
  const ASN1_TEMPLATE *v29;
  const ASN1_TEMPLATE *v30;
  int *v31;
  STACK **v32;
  int taga;
  int len;

  v5 = aclass;
  v6 = tag;
  v7 = it;
  v8 = out;
  v9 = pval;
  funcs = it->funcs;
  itype = it->itype;
  if (!it->itype || *pval)
  {
    if (funcs)
      v12 = (unsigned int (*)(uint64_t, ASN1_VALUE **, const ASN1_ITEM *, _QWORD))funcs[3];
    else
      v12 = 0;
    v13 = 0;
    LOBYTE(v14) = 0;
    switch(it->itype)
    {
      case 0:
        templates = (int *)it->templates;
        if (templates)
          return asn1_template_ex_i2d((STACK **)pval, out, templates, tag, v5);
        it = v7;
        return asn1_i2d_ex_primitive(pval, out, (ASN1_ITEM *)it, tag, aclass);
      case 1:
        goto LABEL_18;
      case 2:
        if (tag != -1)
        {
          v17 = 182;
          goto LABEL_14;
        }
        if (v12 && !v12(6, pval, it, 0))
          return 0;
        choice_selector = asn1_get_choice_selector(v9, v7);
        if ((choice_selector & 0x80000000) != 0 || v7->tcount <= choice_selector)
        {
          if (v12)
            v12(7, v9, v7, 0);
          return 0;
        }
        v27 = &v7->templates[choice_selector];
        pval = asn1_get_field_ptr(v9, v27);
        out = v8;
        templates = (int *)v27;
        tag = -1;
        return asn1_template_ex_i2d((STACK **)pval, out, templates, tag, v5);
      case 4:
        return ((uint64_t (*)(ASN1_VALUE **, unsigned __int8 **, const ASN1_ITEM *, _QWORD, _QWORD))funcs[5])(pval, out, it, *(_QWORD *)&tag, *(_QWORD *)&aclass);
      case 5:
        if (tag == -1)
        {
          tag = -1;
          return asn1_i2d_ex_primitive(pval, out, (ASN1_ITEM *)it, tag, aclass);
        }
        v17 = 170;
LABEL_14:
        ERR_put_error(13, 4095, 230, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/tasn_enc.c", v17);
        return 0;
      case 6:
        v14 = (unsigned __int16)(aclass & 0x800) >> 11;
        if ((aclass & 0x800) != 0)
          itype = 2;
        else
          itype = 1;
LABEL_18:
        len = 0;
        v18 = asn1_enc_restore(&len, out, pval, it);
        if (v18 < 0)
          return 0;
        if (v18)
          return len;
        len = 0;
        if (v6 == -1)
        {
          v5 &= 0xFFFFFF3F;
          v6 = 16;
        }
        if (v12 && !v12(6, v9, v7, 0))
          return 0;
        if (v7->tcount <= 0)
        {
          v25 = len;
        }
        else
        {
          taga = v6;
          v19 = 0;
          v20 = v7->templates;
          do
          {
            v21 = asn1_do_adb(v9, v20, 1);
            if (!v21)
              return 0;
            v22 = (int *)v21;
            field_ptr = (STACK **)asn1_get_field_ptr(v9, v21);
            v24 = asn1_template_ex_i2d(field_ptr, 0, v22, -1, v5);
            v25 = len + v24;
            len += v24;
            ++v20;
            ++v19;
          }
          while (v7->tcount > v19);
          v6 = taga;
        }
        v13 = ASN1_object_size(itype, v25, v6);
        if (!v8)
          return v13;
        ASN1_put_object(v8, itype, len, v6, v5);
        if (v7->tcount < 1)
          goto LABEL_48;
        v28 = 0;
        v29 = v7->templates;
        break;
      default:
        return v13;
    }
    while (1)
    {
      v30 = asn1_do_adb(v9, v29, 1);
      if (!v30)
        break;
      v31 = (int *)v30;
      v32 = (STACK **)asn1_get_field_ptr(v9, v30);
      asn1_template_ex_i2d(v32, v8, v31, -1, v5);
      ++v29;
      if (v7->tcount <= ++v28)
      {
LABEL_48:
        if ((v14 & 1) != 0)
          ASN1_put_eoc(v8);
        if (!v12 || v12(7, v9, v7, 0))
          return v13;
        return 0;
      }
    }
  }
  return 0;
}

uint64_t asn1_template_ex_i2d(STACK **pval, unsigned __int8 **out, int *a3, int tag, int a5)
{
  int v5;
  int v9;
  uint64_t v10;
  int v11;
  unsigned int v12;
  int v13;
  int v14;
  STACK *v15;
  _BOOL4 v16;
  _BOOL4 v17;
  int v18;
  BOOL v19;
  int v20;
  int v21;
  int v22;
  int v23;
  const ASN1_ITEM *v24;
  uint64_t v26;
  int v27;
  const ASN1_ITEM *v28;
  int v29;
  int v30;
  int v31;
  uint64_t v32;
  int v33;
  char **v34;
  unsigned __int8 *v35;
  unsigned __int8 *v36;
  int v37;
  char **v38;
  int v39;
  int v40;
  char **v41;
  int v42;
  char **v43;
  char *v44;
  int xclass;
  int v46;
  int taga;
  unsigned int tagb;
  ASN1_VALUE *pvala;
  unsigned __int8 *outa;
  ASN1_VALUE *v51;

  v5 = tag;
  v9 = *a3;
  if ((*a3 & 0x18) == 0)
  {
    if (tag == -1)
      v11 = 0;
    else
      v11 = a5 & 0xC0;
    goto LABEL_8;
  }
  if (tag == -1)
  {
    v5 = a3[2];
    v11 = *a3 & 0xC0;
LABEL_8:
    v12 = a5 & 0xFFFFFF3F;
    v13 = (unsigned __int16)a5 & (unsigned __int16)v9 & 0x800;
    if (((unsigned __int16)a5 & (unsigned __int16)v9 & 0x800) != 0)
      v14 = 2;
    else
      v14 = 1;
    if ((v9 & 6) != 0)
    {
      v15 = *pval;
      pvala = 0;
      if (v15)
      {
        v16 = v5 != -1;
        v17 = (v9 & 0x10) == 0;
        if ((v9 & 2) != 0)
          v18 = 17;
        else
          v18 = 16;
        v19 = !v17 || !v16;
        if (v17 && v16)
          v20 = v5;
        else
          v20 = v18;
        taga = v20;
        if (v19)
          v21 = 0;
        else
          v21 = v11;
        xclass = v21;
        v46 = (unsigned __int16)a5 & (unsigned __int16)v9 & 0x800;
        v22 = 0;
        if (sk_num(v15) >= 1)
        {
          v23 = 0;
          do
          {
            pvala = (ASN1_VALUE *)sk_value(v15, v23);
            v22 += ASN1_item_ex_i2d(&pvala, 0, *((const ASN1_ITEM **)a3 + 4), -1, v12);
            ++v23;
          }
          while (v23 < sk_num(v15));
        }
        v10 = ASN1_object_size(v14, v22, taga);
        if ((v9 & 0x10) != 0)
        {
          v26 = ASN1_object_size(v14, v10, v5);
          v27 = v10;
          v10 = v26;
          if (!out)
            return v10;
          ASN1_put_object(out, v14, v27, v5, v11);
        }
        else if (!out)
        {
          return v10;
        }
        ASN1_put_object(out, v14, v22, taga, xclass);
        v28 = (const ASN1_ITEM *)*((_QWORD *)a3 + 4);
        v51 = 0;
        if ((v9 & 2) != 0 && sk_num(v15) > 1)
        {
          tagb = v10;
          v33 = sk_num(v15);
          v34 = (char **)reallocarray(0, v33, 0x18uLL);
          v35 = (unsigned __int8 *)malloc_type_malloc(v22, 0x52712E22uLL);
          v36 = v35;
          if (v34 && v35)
          {
            outa = v35;
            if (sk_num(v15) >= 1)
            {
              v37 = 0;
              v38 = v34;
              do
              {
                v51 = (ASN1_VALUE *)sk_value(v15, v37);
                *v38 = (char *)outa;
                *((_DWORD *)v38 + 2) = ASN1_item_ex_i2d(&v51, &outa, v28, -1, v12);
                v38[2] = (char *)v51;
                ++v37;
                v38 += 3;
              }
              while (v37 < sk_num(v15));
            }
            v39 = sk_num(v15);
            qsort(v34, v39, 0x18uLL, (int (__cdecl *)(const void *, const void *))der_cmp);
            outa = *out;
            if (sk_num(v15) >= 1)
            {
              v40 = 0;
              v41 = v34;
              do
              {
                memcpy(outa, *v41, *((int *)v41 + 2));
                outa += *((int *)v41 + 2);
                ++v40;
                v41 += 3;
              }
              while (v40 < sk_num(v15));
            }
            *out = outa;
            if ((v9 & 4) != 0 && sk_num(v15) >= 1)
            {
              v42 = 0;
              v43 = v34 + 2;
              do
              {
                v44 = *v43;
                v43 += 3;
                sk_set(v15, v42++, v44);
              }
              while (v42 < sk_num(v15));
            }
          }
          free(v34);
          free(v36);
          v10 = tagb;
        }
        else if (sk_num(v15) >= 1)
        {
          v29 = 0;
          do
          {
            v51 = (ASN1_VALUE *)sk_value(v15, v29);
            ASN1_item_ex_i2d(&v51, out, v28, -1, v12);
            ++v29;
          }
          while (v29 < sk_num(v15));
        }
        if (v46)
        {
          ASN1_put_eoc(out);
          if ((v9 & 0x10) != 0)
            ASN1_put_eoc(out);
        }
        return v10;
      }
    }
    else
    {
      v24 = (const ASN1_ITEM *)*((_QWORD *)a3 + 4);
      if ((v9 & 0x10) == 0)
        return ASN1_item_ex_i2d((ASN1_VALUE **)pval, out, v24, v5, v11 | v12);
      v30 = ASN1_item_ex_i2d((ASN1_VALUE **)pval, 0, v24, -1, a5 & 0xFFFFFF3F);
      if (v30)
      {
        v31 = v30;
        v32 = ASN1_object_size(v14, v30, v5);
        if (out)
        {
          ASN1_put_object(out, v14, v31, v5, v11);
          ASN1_item_ex_i2d((ASN1_VALUE **)pval, out, *((const ASN1_ITEM **)a3 + 4), -1, v12);
          if (v13)
            ASN1_put_eoc(out);
        }
        return v32;
      }
    }
    return 0;
  }
  return 0xFFFFFFFFLL;
}

uint64_t asn1_i2d_ex_primitive(ASN1_VALUE **a1, unsigned __int8 **a2, ASN1_ITEM *it, int a4, int a5)
{
  unsigned int v10;
  unsigned int v11;
  uint64_t v12;
  int v13;
  int v14;
  int putype;

  putype = it->utype;
  v10 = asn1_ex_i2c(a1, 0, &putype, it);
  if (v10 == -1)
    return 0;
  v11 = v10;
  if (v10 == -2)
    v12 = 0;
  else
    v12 = v10;
  if ((v12 & 0x80000000) != 0)
    return 0xFFFFFFFFLL;
  v13 = putype;
  v14 = 2 * (v10 == -2);
  if (a4 == -1)
    a4 = putype;
  if (!a2)
    goto LABEL_21;
  if ((putype + 3) > 0x14 || ((1 << (putype + 3)) & 0x180001) == 0)
    ASN1_put_object(a2, v14, v12, a4, a5);
  if (asn1_ex_i2c(a1, *a2, &putype, it) != v11)
    return 0xFFFFFFFFLL;
  if (v11 == -2)
    ASN1_put_eoc(a2);
  else
    *a2 += v11;
LABEL_21:
  if ((v13 + 3) > 0x14 || ((1 << (v13 + 3)) & 0x180001) == 0)
    return ASN1_object_size(v14, v12, a4);
  return v12;
}

int ASN1_template_i2d(ASN1_VALUE **pval, unsigned __int8 **out, const ASN1_TEMPLATE *tt)
{
  return asn1_template_ex_i2d((STACK **)pval, out, (int *)tt, -1, 0);
}

uint64_t der_cmp(uint64_t a1, uint64_t a2)
{
  int v2;
  int v3;
  unsigned int v4;
  uint64_t result;

  v2 = *(_DWORD *)(a1 + 8);
  v3 = *(_DWORD *)(a2 + 8);
  v4 = v2 - v3;
  if (v2 >= v3)
    v2 = *(_DWORD *)(a2 + 8);
  LODWORD(result) = memcmp(*(const void **)a1, *(const void **)a2, v2);
  if ((_DWORD)result)
    return result;
  else
    return v4;
}

int asn1_ex_i2c(ASN1_VALUE **pval, unsigned __int8 *cont, int *putype, const ASN1_ITEM *it)
{
  _QWORD *funcs;
  uint64_t (*v5)(ASN1_VALUE **, unsigned __int8 *, int *);
  int v7;
  uint64_t utype;
  ASN1_VALUE *v9;
  int v10;
  int v11;
  ASN1_INTEGER *v12;
  unsigned __int8 **v13;
  char *p_src;
  ASN1_BIT_STRING *v16;
  unsigned __int8 **v17;
  ASN1_VALUE *v18;
  uint64_t size;
  char __src;
  unsigned __int8 *v21;

  v21 = cont;
  funcs = it->funcs;
  if (!funcs)
  {
    if (it->itype)
    {
      if (!*pval)
        return -1;
      if (it->itype == 5)
      {
        v7 = *((_DWORD *)*pval + 1);
LABEL_14:
        *putype = v7;
LABEL_16:
        __src = 0;
        v11 = 0;
        switch(v7)
        {
          case 1:
            if (*(_DWORD *)pval == -1)
              return -1;
            if (it->utype == -4)
              goto LABEL_23;
            size = it->size;
            if (*(_DWORD *)pval)
            {
              if (size > 0)
                return -1;
            }
            else if (!size)
            {
              return -1;
            }
LABEL_23:
            __src = *(_DWORD *)pval;
            v11 = 1;
            p_src = &__src;
            goto LABEL_33;
          case 2:
          case 10:
            v12 = (ASN1_INTEGER *)*pval;
            if (cont)
              v13 = &v21;
            else
              v13 = 0;
            return i2c_ASN1_INTEGER(v12, v13);
          case 3:
            v16 = (ASN1_BIT_STRING *)*pval;
            if (cont)
              v17 = &v21;
            else
              v17 = 0;
            return i2c_ASN1_BIT_STRING(v16, v17);
          case 5:
            return v11;
          case 6:
            p_src = (char *)*((_QWORD *)*pval + 3);
            v11 = *((_DWORD *)*pval + 5);
            goto LABEL_33;
          default:
            v18 = *pval;
            if (it->size == 2048 && (*((_BYTE *)v18 + 16) & 0x10) != 0)
            {
              if (cont)
              {
                *((_QWORD *)v18 + 1) = cont;
                *(_DWORD *)v18 = 0;
              }
              return -2;
            }
            else
            {
              p_src = (char *)*((_QWORD *)v18 + 1);
              v11 = *(_DWORD *)v18;
LABEL_33:
              if (cont)
              {
                if (v11)
                  memcpy(cont, p_src, v11);
              }
            }
            return v11;
        }
      }
      utype = it->utype;
    }
    else
    {
      utype = it->utype;
      if (utype == 1)
        goto LABEL_15;
      if (!*pval)
        return -1;
    }
    if (utype == -4)
    {
      v9 = *pval;
      v10 = *(_DWORD *)v9;
      pval = (ASN1_VALUE **)((char *)v9 + 8);
      v7 = v10;
      goto LABEL_14;
    }
LABEL_15:
    v7 = *putype;
    goto LABEL_16;
  }
  v5 = (uint64_t (*)(ASN1_VALUE **, unsigned __int8 *, int *))funcs[6];
  if (v5)
    return v5(pval, cont, putype);
  return -1;
}

void Camellia_cbc_encrypt(_QWORD *a1, uint64_t *a2, unint64_t a3, uint64_t a4, _OWORD *a5, int a6)
{
  if (a6)
    CRYPTO_cbc128_encrypt(a1, a2, a3, a4, a5, (void (*)(_QWORD *, _QWORD *, uint64_t))Camellia_encrypt);
  else
    CRYPTO_cbc128_decrypt((uint64_t)a1, a2, a3, a4, a5, (uint64_t (*)(_QWORD *, uint64_t *, uint64_t))Camellia_decrypt);
}

BUF_MEM *BUF_MEM_new(void)
{
  BUF_MEM *v0;

  v0 = (BUF_MEM *)malloc_type_calloc(1uLL, 0x18uLL, 0x1010040A500212DuLL);
  if (!v0)
    ERR_put_error(7, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/buffer/buffer.c", 79);
  return v0;
}

void BUF_MEM_free(BUF_MEM *a)
{
  if (a)
  {
    freezero(a->data, *(_QWORD *)&a->max);
    free(a);
  }
}

int BUF_MEM_grow_clean(BUF_MEM *str, int len)
{
  unint64_t v2;
  unint64_t v4;
  int v5;
  char *v6;

  v2 = *(_QWORD *)&len;
  v4 = *(_QWORD *)&str->max;
  if (v4 >= v2)
  {
    if (*(_QWORD *)&str->length >= v2)
      bzero(&str->data[v2], *(_QWORD *)&str->length - v2);
  }
  else
  {
    if (v2 >= 0x5FFFFFFD)
    {
      v5 = 116;
LABEL_10:
      ERR_put_error(7, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/buffer/buffer.c", v5);
      LODWORD(v2) = 0;
      return v2;
    }
    v6 = recallocarray(str->data, v4, ((2863311531u * (unint64_t)(v2 + 3)) >> 31) & 0x1FFFFFFFCLL, 1uLL);
    if (!v6)
    {
      v5 = 122;
      goto LABEL_10;
    }
    str->data = v6;
    *(_QWORD *)&str->max = ((2863311531u * (unint64_t)(v2 + 3)) >> 31) & 0x1FFFFFFFCLL;
  }
  *(_QWORD *)&str->length = v2;
  return v2;
}

char *BUF_reverse(char *result, char *a2, unint64_t a3)
{
  char v3;
  unint64_t v4;
  char *v5;
  char v6;

  if (a2)
  {
    for (; a3; --a3)
    {
      v3 = *a2++;
      result[a3 - 1] = v3;
    }
  }
  else if (a3 >= 2)
  {
    v4 = a3 >> 1;
    v5 = &result[a3 - 1];
    do
    {
      v6 = *v5;
      *v5-- = *result;
      *result++ = v6;
      --v4;
    }
    while (v4);
  }
  return result;
}

unsigned int ENGINE_get_table_flags(void)
{
  return table_flags;
}

void ENGINE_set_table_flags(unsigned int flags)
{
  table_flags = flags;
}

uint64_t engine_table_register(LHASH **a1, uint64_t a2, char *a3, _DWORD *a4, int a5, int a6)
{
  LHASH *v12;
  uint64_t v13;
  void *v14;
  _DWORD *v15;
  STACK *v16;
  uint64_t v17;
  _OWORD v19[2];

  memset(v19, 0, sizeof(v19));
  CRYPTO_lock(9, 30, 0, 0);
  if (!*a1)
  {
    v12 = lh_new((LHASH_HASH_FN_TYPE)engine_pile_LHASH_HASH, (LHASH_COMP_FN_TYPE)engine_pile_LHASH_COMP);
    if (!v12)
      goto LABEL_19;
    *a1 = v12;
    engine_cleanup_add_first(a2);
  }
  v13 = 1;
  if (a5)
  {
    while (1)
    {
      LODWORD(v19[0]) = *a4;
      v14 = lh_retrieve(*a1, v19);
      if (!v14)
      {
        v15 = malloc_type_malloc(0x20uLL, 0x10200406A377A34uLL);
        if (!v15)
          goto LABEL_19;
        v14 = v15;
        v15[6] = 1;
        *v15 = *a4;
        v16 = sk_new_null();
        *((_QWORD *)v14 + 1) = v16;
        if (!v16)
        {
          free(v14);
LABEL_19:
          v13 = 0;
          break;
        }
        *((_QWORD *)v14 + 2) = 0;
        lh_insert(*a1, v14);
      }
      sk_delete_ptr(*((STACK **)v14 + 1), a3);
      if (!sk_push(*((STACK **)v14 + 1), a3))
        goto LABEL_19;
      *((_DWORD *)v14 + 6) = 0;
      if (a6)
      {
        if (!engine_unlocked_init((uint64_t)a3))
        {
          ERR_put_error(38, 4095, 109, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/engine/eng_table.c", 175);
          goto LABEL_19;
        }
        v17 = *((_QWORD *)v14 + 2);
        if (v17)
          engine_unlocked_finish(v17, 0);
        *((_QWORD *)v14 + 2) = a3;
        *((_DWORD *)v14 + 6) = 1;
      }
      ++a4;
      if (!--a5)
      {
        v13 = 1;
        break;
      }
    }
  }
  CRYPTO_lock(10, 30, 0, 0);
  return v13;
}

void engine_table_unregister(LHASH **a1, void *a2)
{
  CRYPTO_lock(9, 30, 0, 0);
  if (*a1)
    lh_doall_arg(*a1, (LHASH_DOALL_ARG_FN_TYPE)int_unregister_cb_LHASH_DOALL_ARG, a2);
  CRYPTO_lock(10, 30, 0, 0);
}

uint64_t int_unregister_cb_LHASH_DOALL_ARG(uint64_t a1, char *a2)
{
  uint64_t result;
  int v5;

  result = sk_find(*(STACK **)(a1 + 8), a2);
  if ((result & 0x80000000) == 0)
  {
    v5 = result;
    do
    {
      sk_delete(*(STACK **)(a1 + 8), v5);
      *(_DWORD *)(a1 + 24) = 0;
      result = sk_find(*(STACK **)(a1 + 8), a2);
      v5 = result;
    }
    while ((result & 0x80000000) == 0);
  }
  if (*(char **)(a1 + 16) == a2)
  {
    result = engine_unlocked_finish((uint64_t)a2, 0);
    *(_QWORD *)(a1 + 16) = 0;
  }
  return result;
}

void engine_table_cleanup(LHASH **a1)
{
  CRYPTO_lock(9, 30, 0, 0);
  if (*a1)
  {
    lh_doall(*a1, (LHASH_DOALL_FN_TYPE)int_cleanup_cb_LHASH_DOALL);
    lh_free(*a1);
    *a1 = 0;
  }
  CRYPTO_lock(10, 30, 0, 0);
}

void int_cleanup_cb_LHASH_DOALL(uint64_t a1)
{
  uint64_t v2;

  sk_free(*(STACK **)(a1 + 8));
  v2 = *(_QWORD *)(a1 + 16);
  if (v2)
    engine_unlocked_finish(v2, 0);
  free((void *)a1);
}

uint64_t engine_table_select(LHASH **a1, int a2)
{
  LHASH *v4;
  _QWORD *v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  int v10;
  char *v11;
  int v12;
  uint64_t v13;
  _OWORD v14[2];

  if (!*a1)
    return 0;
  memset(v14, 0, sizeof(v14));
  ERR_set_mark();
  CRYPTO_lock(9, 30, 0, 0);
  v4 = *a1;
  if (*a1 && (LODWORD(v14[0]) = a2, (v5 = lh_retrieve(v4, v14)) != 0))
  {
    v6 = v5;
    v7 = v5[2];
    if (v7 && engine_unlocked_init(v7) || *((_DWORD *)v6 + 6))
    {
      v8 = v6[2];
    }
    else
    {
      v10 = 0;
      while (1)
      {
        v11 = sk_value((const STACK *)v6[1], v10);
        v8 = (uint64_t)v11;
        if (!v11)
          break;
        if (*((int *)v11 + 46) <= 0 && (table_flags & 1) != 0)
          v12 = 0;
        else
          v12 = engine_unlocked_init((uint64_t)v11);
        ++v10;
        if (v12)
        {
          if (v6[2] != v8 && engine_unlocked_init(v8))
          {
            v13 = v6[2];
            if (v13)
              engine_unlocked_finish(v13, 0);
            v6[2] = v8;
          }
          break;
        }
      }
    }
    *((_DWORD *)v6 + 6) = 1;
  }
  else
  {
    v8 = 0;
  }
  CRYPTO_lock(10, 30, 0, 0);
  ERR_pop_to_mark();
  return v8;
}

void engine_table_doall(LHASH *a1, uint64_t a2, uint64_t a3)
{
  _QWORD v3[2];

  v3[0] = a2;
  v3[1] = a3;
  lh_doall_arg(a1, (LHASH_DOALL_ARG_FN_TYPE)int_cb_LHASH_DOALL_ARG, v3);
}

uint64_t int_cb_LHASH_DOALL_ARG(unsigned int *a1, uint64_t a2)
{
  return (*(uint64_t (**)(_QWORD, _QWORD, _QWORD, _QWORD))a2)(*a1, *((_QWORD *)a1 + 1), *((_QWORD *)a1 + 2), *(_QWORD *)(a2 + 8));
}

uint64_t engine_pile_LHASH_HASH(int *a1)
{
  return *a1;
}

uint64_t engine_pile_LHASH_COMP(_DWORD *a1, _DWORD *a2)
{
  return (*a1 - *a2);
}

int RSA_padding_add_PKCS1_OAEP(unsigned __int8 *to, int tlen, const unsigned __int8 *f, int fl, const unsigned __int8 *p, int pl)
{
  return RSA_padding_add_PKCS1_OAEP_mgf1(to, tlen, f, fl, p, pl, 0, 0);
}

uint64_t RSA_padding_add_PKCS1_OAEP_mgf1(_BYTE *a1, int a2, const void *a3, int a4, const void *a5, int a6, EVP_MD *md, EVP_MD *a8)
{
  EVP_MD *v9;
  int v16;
  unsigned int v17;
  int v18;
  int v19;
  int v20;
  int v21;
  _BYTE *v22;
  unsigned __int8 *v23;
  uint64_t v24;
  uint64_t v25;
  unsigned __int8 *v26;
  unsigned __int8 *v27;
  uint64_t v28;
  unsigned __int8 *v29;
  unsigned __int8 *v30;
  char v31;
  unsigned __int8 *v32;
  uint64_t v33;
  char v34;
  EVP_MD *dgst;
  unsigned __int8 mask[64];
  uint64_t v38;

  v9 = md;
  v38 = *MEMORY[0x24BDAC8D0];
  if (!md)
    v9 = (EVP_MD *)EVP_sha1();
  if (!a8)
    a8 = v9;
  v16 = EVP_MD_size(v9);
  if (v16 < 1)
    goto LABEL_21;
  v17 = v16;
  dgst = a8;
  v18 = a2 - 1;
  v19 = ~(2 * v16);
  if (a2 - 1 + v19 < a4)
  {
    v20 = 110;
    v21 = 115;
LABEL_20:
    ERR_put_error(4, 4095, v20, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/rsa/rsa_oaep.c", v21);
    goto LABEL_21;
  }
  if (((2 * v16) | 1) >= a2)
  {
    v20 = 120;
    v21 = 120;
    goto LABEL_20;
  }
  *a1 = 0;
  v22 = a1 + 1;
  v23 = &v22[v16];
  if (!EVP_Digest(a5, a6, v23, 0, v9, 0))
  {
LABEL_21:
    v27 = 0;
    LODWORD(v25) = 0;
LABEL_22:
    v33 = 0;
    goto LABEL_23;
  }
  v24 = v17;
  bzero(&v23[v17], v18 - a4 + v19);
  v23[v18 - a4 + ~v17] = 1;
  memcpy(&v23[v18 - a4 - v17], a3, a4);
  arc4random_buf(v22, v17);
  v25 = v18 - v17;
  v26 = (unsigned __int8 *)malloc_type_malloc((int)v25, 0xABE65EDCuLL);
  v27 = v26;
  if (!v26)
  {
    ERR_put_error(4, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/rsa/rsa_oaep.c", 138);
    goto LABEL_22;
  }
  if (PKCS1_MGF1(v26, (int)v25, v22, v24, dgst) < 0)
    goto LABEL_22;
  if ((int)v25 >= 1)
  {
    v28 = v25;
    v29 = v27;
    v30 = v23;
    do
    {
      v31 = *v29++;
      *v30++ ^= v31;
      --v28;
    }
    while (v28);
  }
  if (PKCS1_MGF1(mask, v24, v23, (int)v25, dgst) < 0)
    goto LABEL_22;
  v32 = mask;
  v33 = 1;
  do
  {
    v34 = *v32++;
    *v22++ ^= v34;
    --v24;
  }
  while (v24);
LABEL_23:
  explicit_bzero(mask, 0x40uLL);
  freezero(v27, (int)v25);
  return v33;
}

int PKCS1_MGF1(unsigned __int8 *mask, uint64_t len, const unsigned __int8 *seed, uint64_t seedlen, const EVP_MD *dgst)
{
  unsigned int v10;
  uint64_t v11;
  unsigned int v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  EVP_MD_CTX v17;
  __int128 v18;
  unsigned int d;
  unsigned __int8 md[64];
  uint64_t v21;

  v21 = *MEMORY[0x24BDAC8D0];
  v18 = 0u;
  memset(&v17, 0, sizeof(v17));
  EVP_MD_CTX_init(&v17);
  v10 = EVP_MD_size(dgst);
  if ((v10 & 0x80000000) != 0)
  {
LABEL_14:
    v15 = -1;
    goto LABEL_15;
  }
  if (len >= 1)
  {
    v11 = 0;
    v12 = 0;
    v13 = v10;
    do
    {
      d = bswap32(v12);
      if (!EVP_DigestInit_ex(&v17, dgst, 0)
        || !EVP_DigestUpdate(&v17, seed, seedlen)
        || !EVP_DigestUpdate(&v17, &d, 4uLL))
      {
        goto LABEL_14;
      }
      v14 = v11 + v13;
      if (v11 + v13 > len)
      {
        if (!EVP_DigestFinal_ex(&v17, md, 0))
          goto LABEL_14;
        memcpy(&mask[v11], md, len - v11);
        break;
      }
      if (!EVP_DigestFinal_ex(&v17, &mask[v11], 0))
        goto LABEL_14;
      ++v12;
      v11 += v13;
    }
    while (v14 < len);
  }
  v15 = 0;
LABEL_15:
  EVP_MD_CTX_cleanup(&v17);
  return v15;
}

int RSA_padding_check_PKCS1_OAEP(unsigned __int8 *to, int tlen, const unsigned __int8 *f, int fl, int rsa_len, const unsigned __int8 *p, int pl)
{
  return RSA_padding_check_PKCS1_OAEP_mgf1(to, tlen, (uint64_t)f, fl, rsa_len, p, pl, 0, 0);
}

uint64_t RSA_padding_check_PKCS1_OAEP_mgf1(_BYTE *a1, int a2, uint64_t a3, int a4, unsigned int a5, const void *a6, int a7, EVP_MD *md, const EVP_MD *a9)
{
  EVP_MD *v9;
  const EVP_MD *v17;
  int v18;
  unsigned int v19;
  uint64_t result;
  char *v21;
  int v22;
  char *v23;
  unsigned __int8 *v24;
  char *v25;
  uint64_t v26;
  unsigned __int8 v27;
  int v28;
  int v29;
  size_t v30;
  int v31;
  size_t v32;
  unsigned __int8 *v33;
  uint64_t i;
  uint64_t v35;
  uint64_t v36;
  unsigned __int8 *v37;
  int v38;
  int v39;
  int v40;
  int v41;
  unsigned __int8 *v42;
  int v43;
  int v44;
  int v45;
  int v46;
  uint64_t v47;
  int v48;
  _BYTE *v49;
  uint64_t v50;
  char v51;
  int v52;
  int v53;
  _BYTE *v54;
  size_t v55;
  unsigned __int8 *v56;
  uint64_t seedlen;
  unsigned __int8 mda[64];
  unsigned __int8 mask[64];
  uint64_t v60;

  v9 = md;
  v17 = a9;
  v60 = *MEMORY[0x24BDAC8D0];
  if (!md)
    v9 = (EVP_MD *)EVP_sha1();
  if (!a9)
    v17 = v9;
  v18 = EVP_MD_size(v9);
  if (v18 < 1)
    return 0xFFFFFFFFLL;
  v19 = v18;
  result = 0xFFFFFFFFLL;
  if (a2 >= 1 && a4 >= 1)
  {
    if ((int)a5 < a4 || (int)(2 * v19 + 2) > (int)a5)
    {
      ERR_put_error(4, 4095, 121, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/rsa/rsa_oaep.c", 201);
      return 0xFFFFFFFFLL;
    }
    seedlen = (int)(~v19 + a5);
    v56 = (unsigned __int8 *)malloc_type_malloc(seedlen, 0x20011BAFuLL);
    if (v56)
    {
      v54 = a1;
      v21 = (char *)malloc_type_malloc(a5, 0xC0B13CBAuLL);
      if (v21)
      {
        v22 = 0;
        v55 = a5;
        v23 = &v21[a5];
        v24 = (unsigned __int8 *)(a3 + a4);
        do
        {
          v25 = v23;
          v26 = a4 != 0;
          v24 -= v26;
          v27 = *v24;
          if (!a4)
            v27 = 0;
          a4 -= v26;
          *--v23 = v27;
          ++v22;
        }
        while (v22 != a5);
        v28 = v27 - 1;
        if (PKCS1_MGF1(mask, v19, (const unsigned __int8 *)&v25[v19], seedlen, v17))
        {
          v29 = -1;
          v30 = (int)(~v19 + a5);
        }
        else
        {
          for (i = 0; i != v19; ++i)
            mask[i] ^= v23[i + 1];
          v30 = (int)(~v19 + a5);
          if (!PKCS1_MGF1(v56, seedlen, mask, v19, v17))
          {
            v33 = v56;
            if ((int)seedlen >= 1)
            {
              v35 = seedlen;
              v36 = v19 + 1;
              v37 = v56;
              do
              {
                *v37++ ^= v23[v36++];
                --v35;
              }
              while (v35);
            }
            if (EVP_Digest(a6, a7, mda, 0, v9, 0))
            {
              v38 = timingsafe_memcmp(v56, mda, v19);
              v39 = ((v38 - 1) & ~v38 & v28) >> 31;
              if ((int)v19 >= (int)seedlen)
              {
                v40 = 0;
                v46 = 1;
                v43 = ~v19;
              }
              else
              {
                v40 = 0;
                v41 = 0;
                v42 = &v56[v19];
                v43 = ~v19;
                do
                {
                  v44 = *v42++;
                  v45 = (v44 ^ 1) - 1;
                  v41 = v41 & ~((v45 >> 31) & ~v40) | (v45 >> 31) & ~v40 & v19;
                  v40 |= v45 >> 31;
                  v39 &= v40 | ((v44 - 1) >> 31);
                  ++v19;
                }
                while ((int)seedlen > (int)v19);
                v46 = v41 + 1;
              }
              if ((int)(((a2 - (seedlen - v46)) ^ (seedlen - v46) | (seedlen - v46) ^ a2) ^ a2) < 0)
                v40 = 0;
              v31 = v40 & v39;
              LODWORD(v47) = seedlen + v43;
              if ((int)(((v47 - a2) ^ a2 | v47 ^ a2) ^ v47) >= 0)
                v47 = a2;
              else
                v47 = v47;
              v48 = (seedlen - v47) & ~v31 | v31 & v46;
              v29 = seedlen - v48;
              v49 = v54;
              if ((int)v47 >= 1)
              {
                v50 = v47;
                v51 = v31;
                do
                {
                  if (v48 == (_DWORD)seedlen)
                    v52 = v47;
                  else
                    v52 = 0;
                  if (v48 == (_DWORD)seedlen)
                    v51 = 0;
                  v53 = v48 - v52;
                  v48 = v53 + 1;
                  *v49 = *v49 & ~v51 | v56[v53] & v51;
                  ++v49;
                  --v50;
                }
                while (v50);
              }
              ERR_put_error(4, 4095, 121, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/rsa/rsa_oaep.c", 308);
              err_clear_last_constant_time(v31 & 1);
              v32 = v55;
              goto LABEL_30;
            }
            v29 = -1;
            goto LABEL_29;
          }
          v29 = -1;
        }
        v33 = v56;
LABEL_29:
        v32 = v55;
        v31 = v28 >> 31;
        goto LABEL_30;
      }
      ERR_put_error(4, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/rsa/rsa_oaep.c", 211);
      v31 = 0;
      v32 = a5;
      v23 = 0;
      v29 = -1;
    }
    else
    {
      ERR_put_error(4, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/rsa/rsa_oaep.c", 207);
      v31 = 0;
      v23 = 0;
      v29 = -1;
      v32 = a5;
    }
    v33 = v56;
    v30 = (int)(~v19 + a5);
LABEL_30:
    explicit_bzero(mask, 0x40uLL);
    freezero(v33, v30);
    freezero(v23, v32);
    return v29 | ~v31;
  }
  return result;
}

int DSA_generate_parameters_ex(DSA *dsa, int bits, unsigned __int8 *seed, int seed_len, int *counter_ret, unint64_t *h_ret, BN_GENCB *cb)
{
  uint64_t (*v14)(DSA *, _QWORD, unsigned __int8 *, _QWORD, int *, unint64_t *, BN_GENCB *);
  unint64_t v16;
  const EVP_MD *v17;

  v14 = *(uint64_t (**)(DSA *, _QWORD, unsigned __int8 *, _QWORD, int *, unint64_t *, BN_GENCB *))&dsa->ex_data.sk[2].sorted;
  if (v14)
    return v14(dsa, *(_QWORD *)&bits, seed, *(_QWORD *)&seed_len, counter_ret, h_ret, cb);
  if (bits < 2048)
  {
    v16 = 160;
    v17 = EVP_sha1();
  }
  else
  {
    v16 = 256;
    v17 = EVP_sha256();
  }
  return dsa_builtin_paramgen((BIGNUM **)dsa, bits, v16, v17, (uint64_t)seed, seed_len, 0, counter_ret, h_ret, cb);
}

BOOL dsa_builtin_paramgen(BIGNUM **a1, unint64_t a2, unint64_t a3, const EVP_MD *a4, uint64_t a5, unint64_t a6, void *a7, int *a8, _QWORD *a9, BN_GENCB *a10)
{
  _BOOL8 v10;
  unint64_t v11;
  uint64_t v12;
  const EVP_MD *v16;
  uint64_t v19;
  size_t v20;
  unint64_t v21;
  unint64_t v22;
  BN_CTX *v23;
  BN_MONT_CTX *v24;
  BN_CTX *v25;
  BIGNUM *v26;
  BIGNUM *v27;
  BIGNUM *v28;
  BIGNUM *v29;
  BIGNUM *v30;
  BIGNUM *v31;
  BIGNUM *v32;
  BIGNUM *v33;
  const BIGNUM *v34;
  int v35;
  BN_GENCB *v36;
  int v37;
  int v38;
  __int16 v39;
  uint64_t v41;
  int is_prime_fasttest;
  int v43;
  uint64_t v44;
  int v45;
  int v46;
  uint64_t v47;
  unsigned __int8 *v48;
  __int16 v49;
  const BIGNUM *v51;
  int v52;
  const BIGNUM *v54;
  unsigned int v55;
  const BIGNUM *v56;
  int v57;
  BIGNUM *v58;
  int n;
  int v60;
  BIGNUM *b;
  BIGNUM *r;
  BIGNUM *v63;
  int v64;
  int v65;
  unint64_t v66;
  unint64_t v67;
  BIGNUM *v68;
  BIGNUM *ret;
  BIGNUM *a;
  BIGNUM *v71;
  BIGNUM *v72;
  unsigned __int8 v74[32];
  unsigned __int8 data[32];
  unsigned __int8 md[32];
  _BYTE __buf[32];
  uint64_t v78;

  v10 = 0;
  v78 = *MEMORY[0x24BDAC8D0];
  v11 = a3 >> 3;
  if ((a3 >> 3) > 0x20)
    return v10;
  v12 = (a3 >> 3);
  if (((1 << (a3 >> 3)) & 0x110100000) == 0)
    return v10;
  v16 = a4;
  if (!a4)
    v16 = EVP_sha1();
  if (a2 <= 0x200)
    v19 = 512;
  else
    v19 = a2;
  v20 = (int)v11;
  if ((int)v11 <= a6)
    v21 = a6;
  else
    v21 = 0;
  if (v21 >= (int)v11)
    v22 = (int)v11;
  else
    v22 = v21;
  if (a5 && (int)v11 <= a6)
  {
    __memcpy_chk();
    goto LABEL_19;
  }
  if (!v22)
  {
LABEL_19:
    v24 = BN_MONT_CTX_new();
    if (v24)
    {
      v25 = BN_CTX_new();
      v23 = v25;
      if (v25)
      {
        BN_CTX_start(v25);
        v72 = BN_CTX_get(v23);
        if (v72)
        {
          v26 = BN_CTX_get(v23);
          if (v26)
          {
            v71 = v26;
            v27 = BN_CTX_get(v23);
            if (v27)
            {
              a = v27;
              v28 = BN_CTX_get(v23);
              if (v28)
              {
                ret = v28;
                v29 = BN_CTX_get(v23);
                if (v29)
                {
                  v68 = v29;
                  v30 = BN_CTX_get(v23);
                  if (v30)
                  {
                    v63 = v30;
                    v31 = BN_CTX_get(v23);
                    if (v31)
                    {
                      r = v31;
                      v32 = BN_CTX_get(v23);
                      if (v32)
                      {
                        v66 = (v19 + 63) & 0xFFFFFFFFFFFFFFC0;
                        v33 = v32;
                        v34 = BN_value_one();
                        b = v33;
                        if (BN_lshift(v33, v34, v66 - 1))
                        {
                          v35 = 0;
                          n = v66 - 1;
                          v36 = a10;
                          v67 = (v66 - 1) / 0xA0;
LABEL_31:
                          while (1)
                          {
                            v64 = v35;
                            if (!BN_GENCB_call(v36, 0, v35))
                              break;
                            if (v22)
                            {
                              v37 = 0;
                            }
                            else
                            {
                              arc4random_buf(__buf, (int)v11);
                              v37 = 1;
                            }
                            v65 = v64 + 1;
                            __memcpy_chk();
                            __memcpy_chk();
                            v38 = v11 - 1;
                            do
                            {
                              v39 = ++data[v38];
                              if ((v39 & 0x100) == 0)
                                break;
                            }
                            while (v38-- > 0);
                            if (!EVP_Digest(__buf, (int)v11, md, 0, v16, 0))
                              break;
                            if (!EVP_Digest(data, (int)v11, v74, 0, v16, 0))
                              break;
                            v41 = 0;
                            do
                            {
                              md[v41] ^= v74[v41];
                              ++v41;
                            }
                            while (v12 != v41);
                            md[0] |= 0x80u;
                            md[(v11 - 1)] |= 1u;
                            if (!BN_bin2bn(md, v11, ret))
                              break;
                            v36 = a10;
                            is_prime_fasttest = BN_is_prime_fasttest_ex(ret, 64, v23, v37, a10);
                            if (is_prime_fasttest > 0)
                            {
                              if (BN_GENCB_call(a10, 2, 0) && BN_GENCB_call(a10, 3, 0))
                              {
                                v43 = 0;
                                v44 = (uint64_t)a;
                                while (1)
                                {
                                  if (v43)
                                  {
                                    v45 = BN_GENCB_call(a10, 0, v43);
                                    v44 = (uint64_t)a;
                                    if (!v45)
                                      break;
                                  }
                                  v60 = v43;
                                  BN_zero(v44);
                                  if ((v67 & 0x80000000) == 0)
                                  {
                                    v46 = 0;
                                    do
                                    {
                                      v47 = v12;
                                      do
                                      {
                                        if ((int)v47 < 1)
                                          break;
                                        v48 = &data[v47--];
                                        v49 = ++*(v48 - 1);
                                      }
                                      while ((v49 & 0x100) != 0);
                                      if (!EVP_Digest(data, (int)v11, md, 0, v16, 0)
                                        || !BN_bin2bn(md, v11, v72)
                                        || !BN_lshift(v72, v72, 8 * v11 * v46)
                                        || !BN_add(a, a, v72))
                                      {
                                        goto LABEL_76;
                                      }
                                    }
                                    while (v46++ != (_DWORD)v67);
                                  }
                                  if (!BN_mask_bits(a, n))
                                    goto LABEL_76;
                                  if (!bn_copy(v68, a))
                                    goto LABEL_76;
                                  if (!BN_add(v68, v68, b))
                                    goto LABEL_76;
                                  if (!BN_lshift1(v72, ret))
                                    goto LABEL_76;
                                  if (!BN_mod_ct(v63, v68, v72, v23))
                                    goto LABEL_76;
                                  v51 = BN_value_one();
                                  if (!BN_sub(v72, v63, v51) || !BN_sub(r, v68, v72))
                                    goto LABEL_76;
                                  if ((BN_cmp(r, b) & 0x80000000) == 0)
                                  {
                                    v52 = BN_is_prime_fasttest_ex(r, 64, v23, 1, a10);
                                    if (v52 > 0)
                                    {
                                      if (!BN_GENCB_call(a10, 2, 1))
                                        goto LABEL_76;
                                      v54 = BN_value_one();
                                      if (!BN_sub(b, r, v54)
                                        || !BN_div_ct((uint64_t)v72, 0, b, ret, v23)
                                        || !BN_set_word(b, 2uLL)
                                        || !BN_MONT_CTX_set(v24, r, v23)
                                        || !BN_mod_exp_mont_ct(v71, b, v72, r, v23, v24))
                                      {
                                        goto LABEL_76;
                                      }
                                      v55 = 2;
                                      while (BN_is_one((uint64_t)v71))
                                      {
                                        v56 = BN_value_one();
                                        if (BN_add(b, b, v56))
                                        {
                                          ++v55;
                                          if (BN_mod_exp_mont_ct(v71, b, v72, r, v23, v24))
                                            continue;
                                        }
                                        goto LABEL_76;
                                      }
                                      v57 = BN_GENCB_call(a10, 3, 1);
                                      v10 = v57 != 0;
                                      if (v57)
                                      {
                                        BN_free(a1[2]);
                                        BN_free(a1[3]);
                                        BN_free(a1[4]);
                                        a1[2] = BN_dup(r);
                                        a1[3] = BN_dup(ret);
                                        v58 = BN_dup(v71);
                                        a1[4] = v58;
                                        if (!a1[2])
                                          goto LABEL_76;
                                        v10 = 0;
                                        if (a1[3] && v58)
                                        {
                                          if (a8)
                                            *a8 = v60;
                                          if (a9)
                                            *a9 = v55;
                                          if (a7)
                                            memcpy(a7, __buf, v20);
                                          v10 = 1;
                                        }
                                      }
                                      goto LABEL_77;
                                    }
                                    if (v52)
                                      goto LABEL_76;
                                  }
                                  v43 = v60 + 1;
                                  v44 = (uint64_t)a;
                                  if (v60 == 4095)
                                  {
                                    v22 = 0;
                                    v35 = v65;
                                    v36 = a10;
                                    goto LABEL_31;
                                  }
                                }
                              }
                              goto LABEL_76;
                            }
                            v22 = 0;
                            v35 = v65;
                            if (is_prime_fasttest)
                              goto LABEL_76;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    else
    {
      v23 = 0;
    }
    goto LABEL_76;
  }
  v23 = 0;
  v24 = 0;
LABEL_76:
  v10 = 0;
LABEL_77:
  BN_CTX_end(v23);
  BN_CTX_free(v23);
  BN_MONT_CTX_free(v24);
  return v10;
}

DSA *__cdecl DSA_generate_parameters(int bits, unsigned __int8 *seed, int seed_len, int *counter_ret, unint64_t *h_ret, void (__cdecl *callback)(int, int, void *), void *cb_arg)
{
  DSA *v14;
  BN_GENCB cb;

  v14 = DSA_new();
  if (v14)
  {
    memset(&cb, 0, sizeof(cb));
    BN_GENCB_set_old((uint64_t)&cb, (uint64_t)callback, (uint64_t)cb_arg);
    if (!DSA_generate_parameters_ex(v14, bits, seed, seed_len, counter_ret, h_ret, &cb))
    {
      DSA_free(v14);
      return 0;
    }
  }
  return v14;
}

int EVP_PKEY_bits(EVP_PKEY *pkey)
{
  char *ptr;
  uint64_t (*v2)(void);

  if (pkey && (ptr = pkey->pkey.ptr) != 0 && (v2 = (uint64_t (*)(void))*((_QWORD *)ptr + 12)) != 0)
    return v2();
  else
    return 0;
}

uint64_t EVP_PKEY_security_bits(uint64_t result)
{
  uint64_t v1;
  uint64_t (*v2)(void);

  if (result)
  {
    v1 = *(_QWORD *)(result + 16);
    if (v1 && (v2 = *(uint64_t (**)(void))(v1 + 104)) != 0)
      return v2();
    else
      return 4294967294;
  }
  return result;
}

int EVP_PKEY_size(EVP_PKEY *pkey)
{
  char *ptr;
  uint64_t (*v2)(void);

  if (pkey && (ptr = pkey->pkey.ptr) != 0 && (v2 = (uint64_t (*)(void))*((_QWORD *)ptr + 11)) != 0)
    return v2();
  else
    return 0;
}

int EVP_PKEY_save_parameters(EVP_PKEY *pkey, int mode)
{
  EVP_PKEY *v2;
  int v3;
  int type;

  if (pkey->type != 408 && pkey->type != 116)
    return 0;
  type = pkey[1].type;
  v2 = pkey + 1;
  v3 = type;
  if ((mode & 0x80000000) == 0)
    v2->type = mode;
  return v3;
}

int EVP_PKEY_copy_parameters(EVP_PKEY *to, const EVP_PKEY *from)
{
  char *ptr;
  unsigned int (*v5)(const EVP_PKEY *);
  int v6;
  int v7;
  uint64_t (*v9)(EVP_PKEY *, const EVP_PKEY *);

  if (to->type != from->type)
  {
    v6 = 101;
    v7 = 144;
    goto LABEL_7;
  }
  ptr = from->pkey.ptr;
  if (!ptr)
    return 0;
  v5 = (unsigned int (*)(const EVP_PKEY *))*((_QWORD *)ptr + 16);
  if (v5)
  {
    if (v5(from))
    {
      v6 = 103;
      v7 = 149;
LABEL_7:
      ERR_put_error(6, 4095, v6, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/p_lib.c", v7);
      return 0;
    }
    ptr = from->pkey.ptr;
    if (!ptr)
      return 0;
  }
  v9 = (uint64_t (*)(EVP_PKEY *, const EVP_PKEY *))*((_QWORD *)ptr + 17);
  if (!v9)
    return 0;
  return v9(to, from);
}

int EVP_PKEY_missing_parameters(const EVP_PKEY *pkey)
{
  char *ptr;
  uint64_t (*v2)(void);

  ptr = pkey->pkey.ptr;
  if (ptr && (v2 = (uint64_t (*)(void))*((_QWORD *)ptr + 16)) != 0)
    return v2();
  else
    return 0;
}

int EVP_PKEY_cmp_parameters(const EVP_PKEY *a, const EVP_PKEY *b)
{
  char *ptr;
  uint64_t (*v3)(void);

  if (a->type != b->type)
    return -1;
  ptr = a->pkey.ptr;
  if (ptr && (v3 = (uint64_t (*)(void))*((_QWORD *)ptr + 18)) != 0)
    return v3();
  else
    return -2;
}

int EVP_PKEY_cmp(const EVP_PKEY *a, const EVP_PKEY *b)
{
  char *ptr;
  uint64_t (*v5)(const EVP_PKEY *, const EVP_PKEY *);
  int result;
  uint64_t (*v7)(const EVP_PKEY *, const EVP_PKEY *);

  if (a->type != b->type)
    return -1;
  ptr = a->pkey.ptr;
  if (!ptr)
    return -2;
  v5 = (uint64_t (*)(const EVP_PKEY *, const EVP_PKEY *))*((_QWORD *)ptr + 18);
  if (v5)
  {
    result = v5(a, b);
    if (result < 1)
      return result;
    ptr = a->pkey.ptr;
  }
  v7 = (uint64_t (*)(const EVP_PKEY *, const EVP_PKEY *))*((_QWORD *)ptr + 6);
  if (v7)
    return v7(a, b);
  else
    return -2;
}

EVP_PKEY *EVP_PKEY_new(void)
{
  EVP_PKEY *v0;
  EVP_PKEY *v1;

  v0 = (EVP_PKEY *)malloc_type_malloc(0x38uLL, 0x10E20405E855B9FuLL);
  v1 = v0;
  if (v0)
  {
    *(_QWORD *)&v0->type = 0;
    v0->references = 1;
    *(_QWORD *)&v0[1].references = 0;
    *(_QWORD *)&v0->save_parameters = 0;
    v0->attributes = 0;
    v0->pkey.ptr = 0;
    v0[1].type = 1;
  }
  else
  {
    ERR_put_error(6, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/p_lib.c", 206);
  }
  return v1;
}

BOOL EVP_PKEY_up_ref(uint64_t a1)
{
  return CRYPTO_add_lock((int *)(a1 + 8), 1, 10, 0, 0) > 1;
}

uint64_t EVP_PKEY_set_type(uint64_t a1, int a2)
{
  return pkey_set_type(a1, 0, a2, 0, -1);
}

uint64_t pkey_set_type(uint64_t a1, ENGINE *a2, int a3, char *__s, signed int a5)
{
  ENGINE **p_e;
  uint64_t str;
  _DWORD *v12;
  ENGINE *v13;
  ENGINE *e;

  e = a2;
  if (a2)
    p_e = 0;
  else
    p_e = &e;
  if (a1)
  {
    if (*(_QWORD *)(a1 + 32))
      EVP_PKEY_free_it(a1);
    if (*(_DWORD *)(a1 + 4) == a3 && *(_QWORD *)(a1 + 16))
      return 1;
    ENGINE_finish(*(ENGINE **)(a1 + 24));
    *(_QWORD *)(a1 + 24) = 0;
  }
  if (__s)
    str = (uint64_t)EVP_PKEY_asn1_find_str(p_e, __s, a5);
  else
    str = EVP_PKEY_asn1_find((uint64_t *)p_e, a3);
  v12 = (_DWORD *)str;
  if (!(a1 | (unint64_t)a2))
    ENGINE_finish(e);
  if (v12)
  {
    if (a1)
    {
      v13 = e;
      *(_QWORD *)(a1 + 16) = v12;
      *(_QWORD *)(a1 + 24) = v13;
      *(_DWORD *)a1 = *v12;
      *(_DWORD *)(a1 + 4) = a3;
    }
    return 1;
  }
  ERR_put_error(6, 4095, 156, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/p_lib.c", 262);
  return 0;
}

EVP_PKEY *EVP_PKEY_new_raw_private_key(int a1, ENGINE *a2, uint64_t a3, uint64_t a4)
{
  EVP_PKEY *v8;
  EVP_PKEY *v9;
  unsigned int (*v10)(EVP_PKEY *, uint64_t, uint64_t);
  int v11;
  int v12;

  v8 = EVP_PKEY_new();
  v9 = v8;
  if (!v8 || !pkey_set_type((uint64_t)v8, a2, a1, 0, -1))
    goto LABEL_8;
  v10 = (unsigned int (*)(EVP_PKEY *, uint64_t, uint64_t))*((_QWORD *)v9->pkey.ptr + 30);
  if (!v10)
  {
    v11 = 150;
    v12 = 294;
    goto LABEL_7;
  }
  if (!v10(v9, a3, a4))
  {
    v11 = 180;
    v12 = 298;
LABEL_7:
    ERR_put_error(6, 4095, v11, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/p_lib.c", v12);
LABEL_8:
    EVP_PKEY_free(v9);
    return 0;
  }
  return v9;
}

void EVP_PKEY_free(EVP_PKEY *pkey)
{
  STACK *v2;

  if (pkey && CRYPTO_add_lock(&pkey->references, -1, 10, 0, 0) <= 0)
  {
    EVP_PKEY_free_it((uint64_t)pkey);
    v2 = *(STACK **)&pkey[1].references;
    if (v2)
      sk_pop_free(v2, (void (__cdecl *)(void *))X509_ATTRIBUTE_free);
    free(pkey);
  }
}

EVP_PKEY *EVP_PKEY_new_raw_public_key(int a1, ENGINE *a2, uint64_t a3, uint64_t a4)
{
  EVP_PKEY *v8;
  EVP_PKEY *v9;
  unsigned int (*v10)(EVP_PKEY *, uint64_t, uint64_t);
  int v11;
  int v12;

  v8 = EVP_PKEY_new();
  v9 = v8;
  if (!v8 || !pkey_set_type((uint64_t)v8, a2, a1, 0, -1))
    goto LABEL_8;
  v10 = (unsigned int (*)(EVP_PKEY *, uint64_t, uint64_t))*((_QWORD *)v9->pkey.ptr + 31);
  if (!v10)
  {
    v11 = 150;
    v12 = 323;
    goto LABEL_7;
  }
  if (!v10(v9, a3, a4))
  {
    v11 = 180;
    v12 = 327;
LABEL_7:
    ERR_put_error(6, 4095, v11, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/p_lib.c", v12);
LABEL_8:
    EVP_PKEY_free(v9);
    return 0;
  }
  return v9;
}

uint64_t EVP_PKEY_get_raw_private_key(uint64_t a1)
{
  unsigned int (*v1)(void);
  int v3;
  int v4;

  v1 = *(unsigned int (**)(void))(*(_QWORD *)(a1 + 16) + 256);
  if (v1)
  {
    if (v1())
      return 1;
    v3 = 182;
    v4 = 348;
  }
  else
  {
    v3 = 150;
    v4 = 344;
  }
  ERR_put_error(6, 4095, v3, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/p_lib.c", v4);
  return 0;
}

uint64_t EVP_PKEY_get_raw_public_key(uint64_t a1)
{
  unsigned int (*v1)(void);
  int v3;
  int v4;

  v1 = *(unsigned int (**)(void))(*(_QWORD *)(a1 + 16) + 264);
  if (v1)
  {
    if (v1())
      return 1;
    v3 = 182;
    v4 = 364;
  }
  else
  {
    v3 = 150;
    v4 = 360;
  }
  ERR_put_error(6, 4095, v3, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/p_lib.c", v4);
  return 0;
}

EVP_PKEY *EVP_PKEY_new_CMAC_key(ENGINE *a1, const unsigned __int8 *a2, uint64_t a3, EVP_CIPHER *a4)
{
  EVP_PKEY *v8;
  EVP_CIPHER_CTX *v9;

  v8 = EVP_PKEY_new();
  if (!v8)
  {
    v9 = 0;
LABEL_8:
    EVP_PKEY_free(v8);
    CMAC_CTX_free(v9);
    return 0;
  }
  v9 = CMAC_CTX_new();
  if (!v9 || !pkey_set_type((uint64_t)v8, a1, 894, 0, -1))
    goto LABEL_8;
  if (!CMAC_Init(v9, a2, a3, a4, a1))
  {
    ERR_put_error(6, 4095, 180, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/p_lib.c", 387);
    goto LABEL_8;
  }
  v8->attributes = (STACK *)v9;
  return v8;
}

uint64_t EVP_PKEY_set_type_str(uint64_t a1, char *__s, signed int a3)
{
  return pkey_set_type(a1, 0, 0, __s, a3);
}

int EVP_PKEY_assign(EVP_PKEY *pkey, int type, char *key)
{
  int result;

  result = pkey_set_type((uint64_t)pkey, 0, type, 0, -1);
  if (result)
  {
    pkey->attributes = (STACK *)key;
    return key != 0;
  }
  return result;
}

uint64_t EVP_PKEY_get0(uint64_t a1)
{
  return *(_QWORD *)(a1 + 32);
}

uint64_t EVP_PKEY_get0_hmac(uint64_t a1, _QWORD *a2)
{
  int *v2;

  if (*(_DWORD *)a1 == 855)
  {
    v2 = *(int **)(a1 + 32);
    *a2 = *v2;
    return *((_QWORD *)v2 + 1);
  }
  else
  {
    ERR_put_error(6, 4095, 174, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/p_lib.c", 428);
    return 0;
  }
}

uint64_t EVP_PKEY_get0_RSA(uint64_t a1)
{
  if (*(_DWORD *)a1 == 6)
    return *(_QWORD *)(a1 + 32);
  ERR_put_error(6, 4095, 127, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/p_lib.c", 443);
  return 0;
}

rsa_st *__cdecl EVP_PKEY_get1_RSA(EVP_PKEY *pkey)
{
  if (pkey->type == 6)
  {
    RSA_up_ref((RSA *)pkey->attributes);
    return (rsa_st *)pkey->attributes;
  }
  else
  {
    ERR_put_error(6, 4095, 127, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/p_lib.c", 453);
    return 0;
  }
}

int EVP_PKEY_set1_RSA(EVP_PKEY *pkey, rsa_st *key)
{
  int result;

  result = pkey_set_type((uint64_t)pkey, 0, 6, 0, -1);
  if (result)
  {
    pkey->attributes = (STACK *)key;
    if (key)
    {
      RSA_up_ref(key);
      return 1;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t EVP_PKEY_get0_DSA(uint64_t a1)
{
  if (*(_DWORD *)a1 == 116)
    return *(_QWORD *)(a1 + 32);
  ERR_put_error(6, 4095, 129, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/p_lib.c", 475);
  return 0;
}

dsa_st *__cdecl EVP_PKEY_get1_DSA(EVP_PKEY *pkey)
{
  if (pkey->type == 116)
  {
    DSA_up_ref((DSA *)pkey->attributes);
    return (dsa_st *)pkey->attributes;
  }
  else
  {
    ERR_put_error(6, 4095, 129, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/p_lib.c", 485);
    return 0;
  }
}

int EVP_PKEY_set1_DSA(EVP_PKEY *pkey, dsa_st *key)
{
  int result;

  result = pkey_set_type((uint64_t)pkey, 0, 116, 0, -1);
  if (result)
  {
    pkey->attributes = (STACK *)key;
    if (key)
    {
      DSA_up_ref(key);
      return 1;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t EVP_PKEY_get0_EC_KEY(uint64_t a1)
{
  if (*(_DWORD *)a1 == 408)
    return *(_QWORD *)(a1 + 32);
  ERR_put_error(6, 4095, 142, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/p_lib.c", 507);
  return 0;
}

ec_key_st *__cdecl EVP_PKEY_get1_EC_KEY(EVP_PKEY *pkey)
{
  if (pkey->type == 408)
  {
    EC_KEY_up_ref((EC_KEY *)pkey->attributes);
    return (ec_key_st *)pkey->attributes;
  }
  else
  {
    ERR_put_error(6, 4095, 142, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/p_lib.c", 517);
    return 0;
  }
}

int EVP_PKEY_set1_EC_KEY(EVP_PKEY *pkey, ec_key_st *key)
{
  int result;

  result = pkey_set_type((uint64_t)pkey, 0, 408, 0, -1);
  if (result)
  {
    pkey->attributes = (STACK *)key;
    if (key)
    {
      EC_KEY_up_ref(key);
      return 1;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t EVP_PKEY_get0_DH(uint64_t a1)
{
  if (*(_DWORD *)a1 == 28)
    return *(_QWORD *)(a1 + 32);
  ERR_put_error(6, 4095, 128, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/p_lib.c", 540);
  return 0;
}

dh_st *__cdecl EVP_PKEY_get1_DH(EVP_PKEY *pkey)
{
  if (pkey->type == 28)
  {
    DH_up_ref((DH *)pkey->attributes);
    return (dh_st *)pkey->attributes;
  }
  else
  {
    ERR_put_error(6, 4095, 128, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/p_lib.c", 550);
    return 0;
  }
}

int EVP_PKEY_set1_DH(EVP_PKEY *pkey, dh_st *key)
{
  int result;

  result = pkey_set_type((uint64_t)pkey, 0, 28, 0, -1);
  if (result)
  {
    pkey->attributes = (STACK *)key;
    if (key)
    {
      DH_up_ref(key);
      return 1;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

int EVP_PKEY_type(int type)
{
  int *v1;
  int v2;
  ENGINE *e;

  e = 0;
  v1 = (int *)EVP_PKEY_asn1_find((uint64_t *)&e, type);
  if (v1)
    v2 = *v1;
  else
    v2 = 0;
  ENGINE_finish(e);
  return v2;
}

uint64_t EVP_PKEY_id(unsigned int *a1)
{
  return *a1;
}

uint64_t EVP_PKEY_base_id(int *a1)
{
  return EVP_PKEY_type(*a1);
}

uint64_t EVP_PKEY_free_it(uint64_t a1)
{
  uint64_t v2;
  void (*v3)(uint64_t);
  uint64_t result;

  v2 = *(_QWORD *)(a1 + 16);
  if (v2)
  {
    v3 = *(void (**)(uint64_t))(v2 + 168);
    if (v3)
    {
      v3(a1);
      *(_QWORD *)(a1 + 32) = 0;
    }
  }
  result = ENGINE_finish(*(ENGINE **)(a1 + 24));
  *(_QWORD *)(a1 + 24) = 0;
  return result;
}

uint64_t EVP_PKEY_print_public(BIO *a1, uint64_t a2, int a3)
{
  uint64_t v3;
  uint64_t (*v4)(void);

  v3 = *(_QWORD *)(a2 + 16);
  if (v3 && (v4 = *(uint64_t (**)(void))(v3 + 56)) != 0)
    return v4();
  else
    return unsup_alg(a1, (int *)a2, a3, "Public Key");
}

uint64_t unsup_alg(BIO *a1, int *a2, int indent, const char *a4)
{
  uint64_t result;
  const char *v8;

  result = BIO_indent(a1, indent, 128);
  if ((_DWORD)result)
  {
    v8 = OBJ_nid2ln(*a2);
    BIO_printf(a1, "%s algorithm \"%s\" unsupported\n", a4, v8);
    return 1;
  }
  return result;
}

uint64_t EVP_PKEY_print_private(BIO *a1, uint64_t a2, int a3)
{
  uint64_t v3;
  uint64_t (*v4)(void);

  v3 = *(_QWORD *)(a2 + 16);
  if (v3 && (v4 = *(uint64_t (**)(void))(v3 + 80)) != 0)
    return v4();
  else
    return unsup_alg(a1, (int *)a2, a3, "Private Key");
}

uint64_t EVP_PKEY_print_params(BIO *a1, uint64_t a2, int a3)
{
  uint64_t v3;
  uint64_t (*v4)(void);

  v3 = *(_QWORD *)(a2 + 16);
  if (v3 && (v4 = *(uint64_t (**)(void))(v3 + 152)) != 0)
    return v4();
  else
    return unsup_alg(a1, (int *)a2, a3, "Parameters");
}

uint64_t EVP_PKEY_get_default_digest_nid(uint64_t a1)
{
  uint64_t v1;
  uint64_t (*v2)(void);

  v1 = *(_QWORD *)(a1 + 16);
  if (v1 && (v2 = *(uint64_t (**)(void))(v1 + 176)) != 0)
    return v2();
  else
    return 4294967294;
}

BIO_METHOD *BIO_f_buffer(void)
{
  return (BIO_METHOD *)&methods_buffer;
}

uint64_t buffer_write(BIO *b, char *a2, int a3)
{
  uint64_t v3;
  int v4;
  bio_st *next_bio;
  char *v7;
  int flags;
  int retry_reason;
  int v10;
  int v11;
  int v12;
  unsigned int v13;
  int v14;
  int method_high;
  int v16;
  int v17;
  unsigned int v18;

  v3 = 0;
  if (!a2)
    return v3;
  v4 = a3;
  if (a3 < 1)
    return v3;
  next_bio = b->next_bio;
  if (!next_bio || !b->prev_bio)
    return 0;
  v7 = a2;
  BIO_clear_flags(b, 15);
  flags = next_bio->flags;
  retry_reason = next_bio->retry_reason;
  v10 = retry_reason + flags;
  v11 = HIDWORD(next_bio->method) - (retry_reason + flags);
  if (v11 >= v4)
  {
    LODWORD(v3) = 0;
LABEL_21:
    memcpy((void *)(*(_QWORD *)&next_bio->init + v10), v7, v4);
    next_bio->flags += v4;
    return (v3 + v4);
  }
  v3 = 0;
  while (2)
  {
    if (!flags)
    {
LABEL_12:
      next_bio->retry_reason = 0;
      while (1)
      {
        method_high = HIDWORD(next_bio->method);
        if (v4 < method_high)
          break;
        v16 = BIO_write(b->prev_bio, v7, v4);
        v17 = v16;
        if (v16 <= 0)
        {
          BIO_copy_next_retry(b);
          if ((int)v3 <= 0)
            v18 = v17;
          else
            v18 = v3;
          if (v17 < 0)
            return v18;
          else
            return v3;
        }
        v3 = (v16 + v3);
        v7 += v16;
        v4 -= v16;
        if (!v4)
          return v3;
      }
      flags = next_bio->flags;
      retry_reason = next_bio->retry_reason;
      v10 = retry_reason + flags;
      v11 = method_high - (retry_reason + flags);
      if (v11 < v4)
        continue;
      goto LABEL_21;
    }
    break;
  }
  if (v11 >= 1)
  {
    memcpy((void *)(*(_QWORD *)&next_bio->init + v10), v7, v11);
    v7 += v11;
    v4 -= v11;
    v3 = (v11 + v3);
    retry_reason = next_bio->retry_reason;
    flags = next_bio->flags + v11;
    next_bio->flags = flags;
  }
  while (1)
  {
    v12 = BIO_write(b->prev_bio, (const void *)(*(_QWORD *)&next_bio->init + retry_reason), flags);
    v13 = v12;
    if (v12 <= 0)
      break;
    v14 = next_bio->flags;
    retry_reason = next_bio->retry_reason + v12;
    flags = v14 - v12;
    next_bio->flags = v14 - v12;
    next_bio->retry_reason = retry_reason;
    if (v14 == v12)
      goto LABEL_12;
  }
  BIO_copy_next_retry(b);
  if ((v13 & 0x80000000) != 0)
  {
    if ((int)v3 <= 0)
      return v13;
    else
      return v3;
  }
  return v3;
}

uint64_t buffer_read(BIO *b, char *a2, int a3)
{
  bio_st *next_bio;
  char *v6;
  uint64_t v7;
  int cb_arg;
  int v9;
  int v10;
  BIO *prev_bio;
  int v12;
  unsigned int v13;

  if (!a2)
    return 0;
  next_bio = b->next_bio;
  if (!next_bio || !b->prev_bio)
    return 0;
  v6 = a2;
  BIO_clear_flags(b, 15);
  LODWORD(v7) = 0;
  cb_arg = (int)next_bio->cb_arg;
  if (!cb_arg)
    goto LABEL_10;
  while (1)
  {
    v9 = cb_arg >= a3 ? a3 : cb_arg;
    memcpy(v6, (char *)next_bio->callback + SHIDWORD(next_bio->cb_arg), v9);
    v10 = HIDWORD(next_bio->cb_arg) + v9;
    LODWORD(next_bio->cb_arg) -= v9;
    HIDWORD(next_bio->cb_arg) = v10;
    v7 = (v9 + v7);
    if (a3 <= cb_arg)
      return v7;
    a3 -= v9;
    v6 += v9;
LABEL_10:
    prev_bio = b->prev_bio;
    if (a3 > SLODWORD(next_bio->method))
    {
      while (1)
      {
        v12 = BIO_read(prev_bio, v6, a3);
        cb_arg = v12;
        if (v12 < 1)
          break;
        v7 = (v12 + v7);
        a3 -= v12;
        if (!a3)
          return v7;
        v6 += v12;
        prev_bio = b->prev_bio;
      }
LABEL_16:
      BIO_copy_next_retry(b);
      if ((int)v7 <= 0)
        v13 = cb_arg;
      else
        v13 = v7;
      if (cb_arg < 0)
        return v13;
      else
        return v7;
    }
    cb_arg = BIO_read(prev_bio, next_bio->callback, (int)next_bio->method);
    if (cb_arg <= 0)
      goto LABEL_16;
    next_bio->cb_arg = (char *)cb_arg;
  }
}

uint64_t buffer_puts(BIO *a1, char *__s)
{
  int v4;

  v4 = strlen(__s);
  return buffer_write(a1, __s, v4);
}

uint64_t buffer_gets(BIO *a1, _BYTE *a2, int a3)
{
  bio_st *next_bio;
  int v6;
  uint64_t v7;
  int64_t cb_arg_low;
  unint64_t v9;
  char *v10;
  unint64_t v11;
  char v13;
  int v14;
  unsigned int v15;

  next_bio = a1->next_bio;
  v6 = a3 - 1;
  BIO_clear_flags(a1, 15);
  LODWORD(v7) = 0;
  LODWORD(cb_arg_low) = next_bio->cb_arg;
  while (1)
  {
    while ((int)cb_arg_low >= 1)
    {
      if (v6 < 1)
      {
        v13 = 0;
        LODWORD(v9) = 0;
      }
      else
      {
        v9 = 0;
        v10 = (char *)next_bio->callback + SHIDWORD(next_bio->cb_arg);
        while (1)
        {
          v11 = v9;
          a2[v9] = v10[v9];
          if (v10[v9] == 10)
            break;
          ++v9;
          cb_arg_low = SLODWORD(next_bio->cb_arg);
          if ((uint64_t)(v11 + 1) >= cb_arg_low || v9 >= v6)
          {
            v13 = 0;
            a2 += v11 + 1;
            goto LABEL_16;
          }
        }
        LODWORD(v9) = v9 + 1;
        LODWORD(cb_arg_low) = next_bio->cb_arg;
        a2 += v11 + 1;
        v13 = 1;
      }
LABEL_16:
      v7 = (v9 + v7);
      LODWORD(cb_arg_low) = cb_arg_low - v9;
      v14 = HIDWORD(next_bio->cb_arg) + v9;
      LODWORD(next_bio->cb_arg) = cb_arg_low;
      HIDWORD(next_bio->cb_arg) = v14;
      if ((v13 & 1) == 0)
      {
        v6 -= v9;
        if (v6)
          continue;
      }
      *a2 = 0;
      return v7;
    }
    LODWORD(cb_arg_low) = BIO_read(a1->prev_bio, next_bio->callback, (int)next_bio->method);
    if ((int)cb_arg_low <= 0)
      break;
    next_bio->cb_arg = (char *)cb_arg_low;
  }
  BIO_copy_next_retry(a1);
  *a2 = 0;
  if ((int)v7 <= 0)
    v15 = cb_arg_low;
  else
    v15 = v7;
  if ((int)cb_arg_low < 0)
    return v15;
  else
    return v7;
}

uint64_t buffer_ctrl(BIO *b, int a2, uint64_t size, BIO *parg)
{
  bio_st *next_bio;
  BIO *prev_bio;
  uint64_t v9;
  uint64_t cb_arg_low;
  unsigned __int8 *v11;
  int v12;
  uint64_t (__cdecl *v13)(bio_st *, int, const char *, int, uint64_t, uint64_t);
  uint64_t (__cdecl *callback)(bio_st *, int, const char *, int, uint64_t, uint64_t);
  int flags;
  int v16;
  uint64_t v17;
  int method;
  int method_high;
  uint64_t (__cdecl *v21)(bio_st *, int, const char *, int, uint64_t, uint64_t);
  void *v22;
  uint64_t (__cdecl *v23)(bio_st *, int, const char *, int, uint64_t, uint64_t);
  void *v24;

  next_bio = b->next_bio;
  if (a2 <= 100)
  {
    switch(a2)
    {
      case 1:
        next_bio->cb_arg = 0;
        *(_QWORD *)&next_bio->flags = 0;
        prev_bio = b->prev_bio;
        if (!prev_bio)
          return 0;
        a2 = 1;
        return BIO_ctrl(prev_bio, a2, size, parg);
      case 3:
        return next_bio->flags;
      case 10:
        cb_arg_low = SLODWORD(next_bio->cb_arg);
        if ((_DWORD)cb_arg_low)
          return cb_arg_low;
        prev_bio = b->prev_bio;
        if (!prev_bio)
          return 0;
        a2 = 10;
        return BIO_ctrl(prev_bio, a2, size, parg);
      case 11:
        prev_bio = b->prev_bio;
        if (!prev_bio)
          return 0;
        if (next_bio->flags < 1)
          goto LABEL_29;
        BIO_clear_flags(b, 15);
        flags = next_bio->flags;
        if (flags < 1)
          goto LABEL_28;
        break;
      case 12:
        if (!BIO_int_ctrl(parg, 117, SLODWORD(next_bio->method), 0))
          return 0;
        cb_arg_low = 1;
        if (!BIO_int_ctrl(parg, 117, SHIDWORD(next_bio->method), 1))
          return 0;
        return cb_arg_low;
      case 13:
        cb_arg_low = next_bio->flags;
        if ((_DWORD)cb_arg_low)
          return cb_arg_low;
        prev_bio = b->prev_bio;
        if (!prev_bio)
          return 0;
        a2 = 13;
        return BIO_ctrl(prev_bio, a2, size, parg);
      default:
        goto LABEL_41;
    }
    do
    {
      LODWORD(cb_arg_low) = BIO_write(b->prev_bio, (const void *)(*(_QWORD *)&next_bio->init + next_bio->retry_reason), flags);
      BIO_copy_next_retry(b);
      if ((int)cb_arg_low <= 0)
        return (int)cb_arg_low;
      v16 = next_bio->retry_reason + cb_arg_low;
      next_bio->flags -= cb_arg_low;
      next_bio->retry_reason = v16;
      BIO_clear_flags(b, 15);
      flags = next_bio->flags;
    }
    while (flags > 0);
LABEL_28:
    *(_QWORD *)&next_bio->flags = 0;
    prev_bio = b->prev_bio;
LABEL_29:
    a2 = 11;
    return BIO_ctrl(prev_bio, a2, size, parg);
  }
  if (a2 <= 116)
  {
    if (a2 != 101)
    {
      if (a2 == 116)
      {
        v9 = LODWORD(next_bio->cb_arg);
        if ((int)v9 >= 1)
        {
          cb_arg_low = 0;
          v11 = (unsigned __int8 *)next_bio->callback + SHIDWORD(next_bio->cb_arg);
          do
          {
            v12 = *v11++;
            if (v12 == 10)
              ++cb_arg_low;
            --v9;
          }
          while (v9);
          return cb_arg_low;
        }
        return 0;
      }
      goto LABEL_41;
    }
    if (b->prev_bio)
    {
      BIO_clear_flags(b, 15);
      v17 = BIO_ctrl(b->prev_bio, 101, size, parg);
      BIO_copy_next_retry(b);
      return v17;
    }
    return 0;
  }
  if (a2 != 117)
  {
    if (a2 != 122)
    {
LABEL_41:
      prev_bio = b->prev_bio;
      if (prev_bio)
        return BIO_ctrl(prev_bio, a2, size, parg);
      return 0;
    }
    if (SLODWORD(next_bio->method) >= size)
    {
      callback = next_bio->callback;
      goto LABEL_44;
    }
    v13 = (uint64_t (__cdecl *)(bio_st *, int, const char *, int, uint64_t, uint64_t))malloc_type_malloc(size, 0x89B49EC2uLL);
    if (v13)
    {
      callback = v13;
      free(next_bio->callback);
      next_bio->callback = callback;
LABEL_44:
      LODWORD(next_bio->cb_arg) = size;
      HIDWORD(next_bio->cb_arg) = 0;
      memcpy(callback, parg, size);
      return 1;
    }
LABEL_62:
    ERR_put_error(32, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/bio/bf_buff.c", 450);
    return 0;
  }
  if (parg)
  {
    if (!LODWORD(parg->method))
    {
      method_high = HIDWORD(next_bio->method);
      method = size;
      goto LABEL_48;
    }
    method = (int)next_bio->method;
  }
  else
  {
    method = size;
  }
  method_high = size;
LABEL_48:
  v21 = next_bio->callback;
  v22 = *(void **)&next_bio->init;
  if (method > 4096 && method != LODWORD(next_bio->method))
  {
    v21 = (uint64_t (__cdecl *)(bio_st *, int, const char *, int, uint64_t, uint64_t))malloc_type_malloc(size, 0x4CF0AF09uLL);
    if (!v21)
      goto LABEL_62;
  }
  if (method_high > 4096 && method_high != HIDWORD(next_bio->method))
  {
    v22 = malloc_type_malloc(size, 0x16909226uLL);
    if (!v22)
    {
      if (v21 != next_bio->callback)
        free(v21);
      goto LABEL_62;
    }
  }
  v23 = next_bio->callback;
  if (v23 != v21)
  {
    free(v23);
    next_bio->callback = v21;
    next_bio->cb_arg = 0;
    LODWORD(next_bio->method) = method;
  }
  v24 = *(void **)&next_bio->init;
  if (v24 == v22)
    return 1;
  free(v24);
  *(_QWORD *)&next_bio->init = v22;
  *(_QWORD *)&next_bio->flags = 0;
  cb_arg_low = 1;
  HIDWORD(next_bio->method) = method_high;
  return cb_arg_low;
}

uint64_t buffer_new(uint64_t a1)
{
  uint64_t result;
  uint64_t v3;
  void *v4;
  void *v5;

  result = (uint64_t)malloc_type_malloc(0x28uLL, 0x101004019361378uLL);
  if (result)
  {
    v3 = result;
    v4 = malloc_type_malloc(0x1000uLL, 0x9E55FA89uLL);
    *(_QWORD *)(v3 + 8) = v4;
    if (v4)
    {
      v5 = malloc_type_malloc(0x1000uLL, 0x865A550FuLL);
      *(_QWORD *)(v3 + 24) = v5;
      if (v5)
      {
        *(_QWORD *)v3 = 0x100000001000;
        *(_QWORD *)(v3 + 16) = 0;
        *(_QWORD *)(v3 + 32) = 0;
        result = 1;
        *(_DWORD *)(a1 + 32) = 1;
        *(_QWORD *)(a1 + 56) = v3;
        *(_DWORD *)(a1 + 40) = 0;
        return result;
      }
      free(*(void **)(v3 + 8));
    }
    free((void *)v3);
    return 0;
  }
  return result;
}

uint64_t buffer_free(uint64_t result)
{
  uint64_t v1;
  uint64_t v2;

  if (result)
  {
    v1 = result;
    v2 = *(_QWORD *)(result + 56);
    free(*(void **)(v2 + 8));
    free(*(void **)(v2 + 24));
    free(*(void **)(v1 + 56));
    *(_QWORD *)(v1 + 56) = 0;
    *(_DWORD *)(v1 + 32) = 0;
    result = 1;
    *(_DWORD *)(v1 + 40) = 0;
  }
  return result;
}

BIO *buffer_callback_ctrl(uint64_t a1, int a2, void (__cdecl *a3)(bio_st *, int, const char *, int, uint64_t, uint64_t))
{
  BIO *result;

  result = *(BIO **)(a1 + 64);
  if (result)
    return (BIO *)BIO_callback_ctrl(result, a2, a3);
  return result;
}

void ERR_load_ECDH_strings(void)
{
  if (!ERR_func_error_string(ECDH_str_functs))
  {
    ERR_load_strings(0, (ERR_STRING_DATA *)&ECDH_str_functs);
    ERR_load_strings(0, (ERR_STRING_DATA *)&ECDH_str_reasons);
  }
}

void X509V3_EXT_val_prn(BIO *out, STACK *val, int indent, int ml)
{
  int i;
  char *v9;
  const char *v10;
  const char *v11;
  BIO *v12;

  if (val)
  {
    if (!ml || !sk_num(val))
    {
      BIO_printf(out, "%*s", indent, "");
      if (!sk_num(val))
        BIO_puts(out, "<EMPTY>\n");
    }
    if (sk_num(val) >= 1)
    {
      for (i = 0; i < sk_num(val); ++i)
      {
        if (ml)
        {
          BIO_printf(out, "%*s");
        }
        else if (i)
        {
          BIO_printf(out, ", ");
        }
        v9 = sk_value(val, i);
        v10 = (const char *)*((_QWORD *)v9 + 1);
        v11 = (const char *)*((_QWORD *)v9 + 2);
        if (v10)
        {
          if (v11)
          {
            BIO_printf(out, "%s:%s", *((const char **)v9 + 1), v11);
            if (!ml)
              continue;
LABEL_19:
            BIO_puts(out, "\n");
            continue;
          }
          v12 = out;
        }
        else
        {
          v12 = out;
          v10 = v11;
        }
        BIO_puts(v12, v10);
        if (ml)
          goto LABEL_19;
      }
    }
  }
}

int X509V3_EXT_print(BIO *out, X509_EXTENSION *ext, unint64_t flag, int indent)
{
  uint64_t v4;
  X509V3_EXT_METHOD *v8;
  X509V3_EXT_METHOD *v9;
  ASN1_OCTET_STRING *value;
  const ASN1_ITEM *it;
  ASN1_VALUE *v12;
  ASN1_VALUE *v14;
  uint64_t (*i2s)(X509V3_EXT_METHOD *, ASN1_VALUE *);
  const char *v16;
  char *v17;
  STACK *v18;
  _BOOL4 v19;
  uint64_t (*i2v)(_QWORD, _QWORD, _QWORD);
  uint64_t (*i2r)(X509V3_EXT_METHOD *, ASN1_VALUE *, BIO *, uint64_t);
  const ASN1_ITEM *v22;
  unsigned __int8 *in;

  v4 = *(_QWORD *)&indent;
  v8 = X509V3_EXT_get(ext);
  if (!v8)
    return unknown_ext_print(out, (uint64_t)ext, flag, v4, 0);
  v9 = v8;
  value = ext->value;
  in = value->data;
  it = v8->it;
  if (it)
    v12 = ASN1_item_d2i(0, (const unsigned __int8 **)&in, value->length, it);
  else
    v12 = (ASN1_VALUE *)((uint64_t (*)(_QWORD, unsigned __int8 **, _QWORD))v8->d2i)(0, &in, value->length);
  v14 = v12;
  if (v12)
  {
    i2s = (uint64_t (*)(X509V3_EXT_METHOD *, ASN1_VALUE *))v9->i2s;
    if (i2s)
    {
      v16 = (const char *)i2s(v9, v12);
      v17 = (char *)v16;
      if (v16)
      {
        BIO_printf(out, "%*s%s", v4, "", v16);
        v18 = 0;
LABEL_14:
        v19 = 1;
        goto LABEL_21;
      }
    }
    else
    {
      i2v = (uint64_t (*)(_QWORD, _QWORD, _QWORD))v9->i2v;
      if (i2v)
      {
        v18 = (STACK *)i2v(v9, v12, 0);
        if (v18)
        {
          X509V3_EXT_val_prn(out, v18, v4, v9->ext_flags & 4);
          v17 = 0;
          goto LABEL_14;
        }
        v17 = 0;
        goto LABEL_20;
      }
      i2r = (uint64_t (*)(X509V3_EXT_METHOD *, ASN1_VALUE *, BIO *, uint64_t))v9->i2r;
      if (i2r)
      {
        v17 = 0;
        v18 = 0;
        v19 = i2r(v9, v12, out, v4) != 0;
        goto LABEL_21;
      }
      v17 = 0;
    }
    v18 = 0;
LABEL_20:
    v19 = 0;
LABEL_21:
    sk_pop_free(v18, (void (__cdecl *)(void *))X509V3_conf_free);
    free(v17);
    v22 = v9->it;
    if (v22)
      ASN1_item_free(v14, v22);
    else
      ((void (*)(ASN1_VALUE *))v9->ext_free)(v14);
    return v19;
  }
  return unknown_ext_print(out, (uint64_t)ext, flag, v4, 1);
}

uint64_t unknown_ext_print(BIO *a1, uint64_t a2, unint64_t a3, int a4, int a5)
{
  uint64_t v5;

  v5 = 0;
  switch((a3 >> 16) & 0xF)
  {
    case 0uLL:
      return v5;
    case 1uLL:
      if (a5)
        BIO_printf(a1, "%*s<Parse Error>");
      else
        BIO_printf(a1, "%*s<Not Supported>");
      return 1;
    case 2uLL:
      return ASN1_parse_dump(a1, *(const unsigned __int8 **)(*(_QWORD *)(a2 + 16) + 8), **(int **)(a2 + 16), a4, -1);
    case 3uLL:
      return BIO_dump_indent(a1, *(const char **)(*(_QWORD *)(a2 + 16) + 8), **(_DWORD **)(a2 + 16), a4);
    default:
      return 1;
  }
}

int X509V3_extensions_print(BIO *out, char *title, STACK *exts, unint64_t flag, int indent)
{
  int v10;
  X509_EXTENSION *v11;
  ASN1_OBJECT *object;
  int critical;
  const char *v14;

  if (sk_num(exts) < 1)
    return 1;
  if (title)
  {
    BIO_printf(out, "%*s%s:\n", indent, "", title);
    indent += 4;
  }
  if (sk_num(exts) < 1)
    return 1;
  v10 = 0;
  while (1)
  {
    v11 = (X509_EXTENSION *)sk_value(exts, v10);
    if (indent)
    {
      if (BIO_printf(out, "%*s", indent, "") < 1)
        break;
    }
    object = X509_EXTENSION_get_object(v11);
    i2a_ASN1_OBJECT(out, object);
    critical = X509_EXTENSION_get_critical(v11);
    v14 = " critical";
    if (!critical)
      v14 = "";
    if (BIO_printf(out, ":%s\n", v14) < 1)
      break;
    if (!X509V3_EXT_print(out, v11, flag, indent + 4))
    {
      BIO_printf(out, "%*s", indent + 4, "");
      ASN1_STRING_print(out, v11->value);
    }
    if (BIO_write(out, "\n", 1) <= 0)
      break;
    if (++v10 >= sk_num(exts))
      return 1;
  }
  return 0;
}

int X509V3_EXT_print_fp(FILE *out, X509_EXTENSION *ext, int flag, int indent)
{
  BIO *v7;
  BIO *v8;
  int v9;

  v7 = BIO_new_fp(out, 0);
  if (v7)
  {
    v8 = v7;
    v9 = X509V3_EXT_print(v7, ext, flag, indent);
    BIO_free(v8);
    LODWORD(v7) = v9;
  }
  return (int)v7;
}

void CAST_set_key(CAST_KEY *key, int len, const unsigned __int8 *data)
{
  int v3;
  uint64_t v4;
  __int128 *v5;
  int v6;
  int v7;
  int v8;
  unsigned int v9;
  unsigned int v10;
  int v11;
  int v12;
  int v13;
  unsigned int v14;
  unsigned int v15;
  int v16;
  int v17;
  unsigned int v18;
  int v19;
  int *v20;
  int v21;
  unsigned int v22;
  int v23;
  int v24;
  unsigned int v25;
  int v26;
  int v27;
  unsigned int v28;
  int v29;
  int v30;
  unsigned int v31;
  int v32;
  int v33;
  int v34;
  int v35;
  int v36;
  unsigned int v37;
  int v38;
  int v39;
  unsigned int v40;
  int v41;
  int v42;
  unsigned int v43;
  int v44;
  int v45;
  int v46;
  unsigned int v47;
  int v48;
  int v49;
  int v50;
  int v51;
  int v52;
  int v53;
  int v54;
  int v55;
  int v56;
  int v57;
  unsigned int v58;
  int v59;
  int v60;
  unsigned int v61;
  int v62;
  unsigned int v63;
  unsigned int v64;
  int v65;
  int v66;
  int v67;
  int v68;
  int v69;
  int v70;
  int v71;
  int v72;
  int v73;
  int v74;
  int v75;
  int v76;
  int v77;
  int v78;
  int v79;
  int v80;
  int v81;
  int v82;
  int v83;
  BOOL v84;
  uint64_t v85;
  int32x4_t v86;
  int8x16_t v87;
  _BYTE v88[128];
  __int128 v89;
  __int128 v90;
  __int128 v91;
  __int128 v92;
  uint64_t v93;
  float32x4x2_t v94;

  v93 = *MEMORY[0x24BDAC8D0];
  v89 = 0u;
  v90 = 0u;
  v91 = 0u;
  v92 = 0u;
  if (len >= 16)
    v3 = 16;
  else
    v3 = len;
  if (len >= 1)
  {
    if (v3 <= 1)
      v4 = 1;
    else
      v4 = v3;
    v5 = &v89;
    do
    {
      v6 = *data++;
      *(_DWORD *)v5 = v6;
      v5 = (__int128 *)((char *)v5 + 4);
      --v4;
    }
    while (v4);
  }
  v7 = v89;
  v8 = DWORD1(v89) << 16;
  LODWORD(key->data[16]) = v3 < 11;
  v9 = v8 | (v7 << 24) | (DWORD2(v89) << 8) | HIDWORD(v89);
  v10 = (DWORD1(v90) << 16) | ((_DWORD)v90 << 24) | (DWORD2(v90) << 8) | HIDWORD(v90);
  v11 = DWORD1(v91);
  v12 = DWORD2(v91);
  v13 = HIDWORD(v91);
  v14 = (DWORD1(v91) << 16) | ((_DWORD)v91 << 24) | (DWORD2(v91) << 8) | HIDWORD(v91);
  v15 = v92;
  v16 = DWORD1(v92);
  v17 = DWORD2(v92);
  v18 = (DWORD1(v92) << 16) | ((_DWORD)v92 << 24) | (DWORD2(v92) << 8) | HIDWORD(v92);
  v19 = CAST_S_table5[HIDWORD(v92)];
  v20 = (int *)v88;
  v21 = CAST_S_table6[v91];
  do
  {
    v22 = CAST_S_table4[v16] ^ v9 ^ v19 ^ CAST_S_table6[v15] ^ CAST_S_table7[v17] ^ v21;
    v23 = CAST_S_table6[BYTE2(v22)];
    v24 = v22;
    v25 = CAST_S_table4[HIBYTE(v22)] ^ v14 ^ CAST_S_table5[BYTE1(v22)] ^ CAST_S_table7[v22] ^ CAST_S_table7[v12] ^ v23;
    v26 = CAST_S_table7[HIBYTE(v25)];
    v27 = CAST_S_table5[BYTE1(v25)] ^ CAST_S_table6[BYTE2(v25)];
    v28 = v18 ^ CAST_S_table4[v11] ^ CAST_S_table4[v25] ^ v27 ^ v26;
    v29 = CAST_S_table4[BYTE1(v28)];
    v30 = CAST_S_table5[BYTE2(v28)];
    v31 = v10 ^ CAST_S_table6[v28] ^ CAST_S_table7[HIBYTE(v28)] ^ CAST_S_table5[v13] ^ v29 ^ v30;
    v32 = CAST_S_table7[BYTE1(v25)];
    v33 = v27 ^ v26 ^ CAST_S_table5[v28] ^ v29;
    v34 = CAST_S_table6[v22];
    v35 = CAST_S_table7[BYTE1(v22)];
    v36 = CAST_S_table6[BYTE2(v28)];
    *v20 = CAST_S_table4[HIBYTE(v28)] ^ CAST_S_table6[v25] ^ CAST_S_table4[BYTE1(v22)] ^ v30 ^ v32;
    v20[1] = v33;
    v37 = CAST_S_table4[BYTE2(v25)] ^ CAST_S_table5[v25] ^ CAST_S_table6[HIBYTE(v25)] ^ CAST_S_table6[HIBYTE(v22)] ^ v32 ^ v28;
    v38 = (LOBYTE(CAST_S_table4[BYTE2(v25)]) ^ LOBYTE(CAST_S_table5[v25]) ^ LOBYTE(CAST_S_table6[HIBYTE(v25)]) ^ LOBYTE(CAST_S_table6[HIBYTE(v22)]) ^ v32 ^ v28);
    v39 = CAST_S_table5[BYTE1(v37)];
    v40 = CAST_S_table4[HIBYTE(v37)] ^ CAST_S_table6[BYTE2(v37)] ^ CAST_S_table7[v38] ^ v22 ^ v35 ^ v39;
    v41 = CAST_S_table5[BYTE1(v40)] ^ CAST_S_table4[v40];
    v42 = CAST_S_table4[BYTE1(v31)] ^ CAST_S_table5[v31] ^ CAST_S_table7[HIBYTE(v22)] ^ CAST_S_table7[HIBYTE(v31)] ^ v23;
    v43 = CAST_S_table6[BYTE2(v40)] ^ CAST_S_table7[HIBYTE(v40)] ^ CAST_S_table4[BYTE2(v22)] ^ v25 ^ v41;
    v44 = v43;
    v45 = BYTE2(v43);
    v46 = CAST_S_table7[HIBYTE(v43)];
    v47 = CAST_S_table4[BYTE1(v43)] ^ CAST_S_table5[BYTE2(v43)] ^ CAST_S_table6[v43] ^ v46 ^ CAST_S_table5[v24] ^ v31;
    v48 = (LOBYTE(CAST_S_table4[BYTE1(v43)]) ^ LOBYTE(CAST_S_table5[BYTE2(v43)]) ^ LOBYTE(CAST_S_table6[v43]) ^ v46 ^ LOBYTE(CAST_S_table5[v24]) ^ v31);
    v49 = CAST_S_table4[v38];
    v20[2] = CAST_S_table5[BYTE2(v31)] ^ CAST_S_table4[HIBYTE(v31)] ^ v34 ^ v36 ^ v35;
    v20[3] = v42;
    v50 = CAST_S_table6[HIBYTE(v47)];
    v51 = CAST_S_table6[HIBYTE(v43)];
    v52 = v49 ^ CAST_S_table4[HIBYTE(v43)] ^ v39 ^ CAST_S_table7[BYTE2(v47)];
    v53 = CAST_S_table5[HIBYTE(v37)] ^ CAST_S_table4[BYTE2(v37)] ^ CAST_S_table6[BYTE1(v47)];
    v54 = CAST_S_table7[v48] ^ CAST_S_table5[BYTE2(v47)];
    v55 = CAST_S_table5[HIBYTE(v40)] ^ CAST_S_table4[BYTE2(v40)] ^ CAST_S_table6[BYTE1(v43)] ^ CAST_S_table7[v43] ^ CAST_S_table7[v40];
    v20[6] = CAST_S_table7[BYTE2(v43)] ^ CAST_S_table6[v38] ^ v41 ^ v51;
    v20[7] = v55;
    v56 = CAST_S_table4[BYTE2(v47)] ^ CAST_S_table5[v48];
    v57 = CAST_S_table7[BYTE1(v47)] ^ v37;
    v20[4] = v52 ^ v50;
    v20[5] = v53 ^ v54;
    v58 = v56 ^ v57 ^ v50 ^ v51;
    v59 = CAST_S_table5[BYTE1(v58)];
    v60 = v58;
    v61 = CAST_S_table4[HIBYTE(v58)] ^ CAST_S_table6[BYTE2(v58)] ^ CAST_S_table7[v58] ^ CAST_S_table7[BYTE1(v43)] ^ v43 ^ v59;
    v62 = CAST_S_table5[BYTE1(v61)] ^ CAST_S_table4[v61];
    v63 = CAST_S_table6[BYTE2(v61)] ^ CAST_S_table7[HIBYTE(v61)] ^ CAST_S_table4[v45] ^ v47 ^ v62;
    v64 = CAST_S_table4[BYTE1(v63)] ^ CAST_S_table5[BYTE2(v63)] ^ CAST_S_table6[v63] ^ CAST_S_table7[HIBYTE(v63)] ^ CAST_S_table5[v44] ^ v40;
    v65 = CAST_S_table4[BYTE2(v61)];
    v66 = CAST_S_table4[BYTE2(v58)];
    v67 = CAST_S_table7[BYTE1(v61)];
    v68 = CAST_S_table5[HIBYTE(v61)] ^ CAST_S_table6[BYTE1(v63)] ^ CAST_S_table7[v63] ^ v65 ^ v67;
    v9 = CAST_S_table5[v61] ^ CAST_S_table6[HIBYTE(v61)] ^ CAST_S_table6[HIBYTE(v58)] ^ v65 ^ v67 ^ v63;
    v69 = CAST_S_table6[BYTE2(v9)];
    v70 = CAST_S_table4[v58] ^ CAST_S_table6[HIBYTE(v64)] ^ CAST_S_table7[BYTE2(v64)] ^ CAST_S_table4[BYTE2(v63)];
    v10 = CAST_S_table4[HIBYTE(v9)] ^ CAST_S_table5[BYTE1(v9)] ^ CAST_S_table7[v9] ^ CAST_S_table7[BYTE1(v58)] ^ v58 ^ v69;
    v71 = (LOBYTE(CAST_S_table4[HIBYTE(v9)]) ^ LOBYTE(CAST_S_table5[BYTE1(v9)]) ^ LOBYTE(CAST_S_table7[v9]) ^ LOBYTE(CAST_S_table7[BYTE1(v58)]) ^ v58 ^ v69);
    v72 = CAST_S_table5[HIBYTE(v58)] ^ CAST_S_table6[BYTE1(v64)] ^ CAST_S_table7[v64] ^ CAST_S_table5[HIBYTE(v64)];
    v73 = CAST_S_table4[(LOBYTE(CAST_S_table4[HIBYTE(v9)]) ^ LOBYTE(CAST_S_table5[BYTE1(v9)]) ^ LOBYTE(CAST_S_table7[v9]) ^ LOBYTE(CAST_S_table7[BYTE1(v58)]) ^ v58 ^ v69)];
    v20[10] = CAST_S_table6[HIBYTE(v63)] ^ CAST_S_table7[BYTE2(v63)] ^ CAST_S_table6[BYTE1(v58)] ^ v62;
    v20[11] = v68;
    v74 = v70 ^ v59;
    v75 = CAST_S_table6[BYTE2(v10)];
    v76 = CAST_S_table7[HIBYTE(v10)];
    v77 = v73 ^ CAST_S_table5[BYTE1(v10)] ^ v75 ^ v76;
    v20[8] = v74;
    v20[9] = v72 ^ v66;
    v14 = v77 ^ v61 ^ v66;
    v13 = (v77 ^ v61 ^ v66);
    v12 = BYTE1(v14);
    v78 = CAST_S_table4[BYTE1(v14)];
    v11 = BYTE2(v14);
    v79 = CAST_S_table5[v60] ^ v64;
    v80 = CAST_S_table5[BYTE2(v14)];
    v18 = CAST_S_table6[v13] ^ CAST_S_table7[HIBYTE(v14)] ^ v79 ^ v78 ^ v80;
    v81 = CAST_S_table4[HIBYTE(v14)] ^ CAST_S_table6[v71] ^ CAST_S_table7[BYTE1(v10)] ^ CAST_S_table4[v9] ^ v80;
    v17 = BYTE1(v18);
    v16 = BYTE2(v18);
    v82 = CAST_S_table5[v13] ^ CAST_S_table5[v71] ^ v75 ^ v76 ^ v78;
    v15 = HIBYTE(v18);
    v20[12] = v81;
    v20[13] = v82;
    v19 = CAST_S_table5[v18];
    v21 = CAST_S_table6[HIBYTE(v14)];
    v83 = CAST_S_table4[BYTE1(v18)] ^ CAST_S_table7[HIBYTE(v9)] ^ CAST_S_table7[BYTE2(v18)] ^ v19 ^ v69;
    v20[14] = CAST_S_table5[BYTE2(v18)] ^ CAST_S_table4[HIBYTE(v18)] ^ CAST_S_table6[v9] ^ CAST_S_table7[BYTE1(v9)] ^ v21;
    v20[15] = v83;
    v84 = v20 == (int *)v88;
    v20 += 16;
  }
  while (v84);
  v85 = 0;
  v86.i64[0] = 0x1000000010;
  v86.i64[1] = 0x1000000010;
  v87.i64[0] = 0x1F0000001FLL;
  v87.i64[1] = 0x1F0000001FLL;
  do
  {
    v94.val[0] = *(float32x4_t *)&v88[v85];
    v94.val[1] = (float32x4_t)vandq_s8((int8x16_t)vaddq_s32(*(int32x4_t *)&v88[v85 + 64], v86), v87);
    vst2q_f32((float *)key, v94);
    key = (CAST_KEY *)((char *)key + 32);
    v85 += 16;
  }
  while (v85 != 64);
}

void ERR_load_CONF_strings(void)
{
  if (!ERR_func_error_string(CONF_str_functs))
  {
    ERR_load_strings(0, (ERR_STRING_DATA *)&CONF_str_functs);
    ERR_load_strings(0, (ERR_STRING_DATA *)&CONF_str_reasons);
  }
}

uint64_t pkey_ec_init(uint64_t a1)
{
  _WORD *v2;

  v2 = malloc_type_calloc(1uLL, 0x40uLL, 0x1070040E3D958DBuLL);
  if (v2)
  {
    v2[12] = 511;
    *(_QWORD *)(a1 + 40) = v2;
    return 1;
  }
  else
  {
    ERR_put_error(16, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_pmeth.c", 102);
    return 0;
  }
}

uint64_t pkey_ec_copy(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  const EC_KEY *v7;
  uint64_t v8;

  result = pkey_ec_init(a1);
  if ((_DWORD)result)
  {
    v5 = *(_QWORD *)(a2 + 40);
    v6 = *(_QWORD *)(a1 + 40);
    if (!*(_QWORD *)v5 || (result = (uint64_t)EC_GROUP_dup(*(const EC_GROUP **)v5), (*(_QWORD *)v6 = result) != 0))
    {
      v7 = *(const EC_KEY **)(v5 + 16);
      *(_QWORD *)(v6 + 8) = *(_QWORD *)(v5 + 8);
      if (!v7 || (result = (uint64_t)EC_KEY_dup(v7), (*(_QWORD *)(v6 + 16) = result) != 0))
      {
        *(_BYTE *)(v6 + 25) = *(_BYTE *)(v5 + 25);
        v8 = *(_QWORD *)(v5 + 40);
        *(_QWORD *)(v6 + 32) = *(_QWORD *)(v5 + 32);
        *(_QWORD *)(v6 + 56) = *(_QWORD *)(v5 + 56);
        if (v8)
        {
          result = (uint64_t)malloc_type_calloc(1uLL, *(_QWORD *)(v5 + 48), 0x94AC5A2BuLL);
          *(_QWORD *)(v6 + 40) = result;
          if (!result)
            return result;
          memcpy((void *)result, *(const void **)(v5 + 40), *(_QWORD *)(v5 + 48));
        }
        else
        {
          *(_QWORD *)(v6 + 40) = 0;
        }
        *(_QWORD *)(v6 + 48) = *(_QWORD *)(v5 + 48);
        return 1;
      }
    }
  }
  return result;
}

void pkey_ec_cleanup(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 40);
  if (v1)
  {
    EC_GROUP_free(*(EC_GROUP **)v1);
    EC_KEY_free(*(EC_KEY **)(v1 + 16));
    free(*(void **)(v1 + 40));
    free((void *)v1);
    *(_QWORD *)(a1 + 40) = 0;
  }
}

uint64_t pkey_ec_paramgen(uint64_t a1, EVP_PKEY *a2)
{
  const EC_GROUP **v2;
  EC_KEY *v4;
  char *v5;
  uint64_t v6;

  v2 = *(const EC_GROUP ***)(a1 + 40);
  if (!*v2)
  {
    ERR_put_error(16, 4095, 139, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_pmeth.c", 464);
    return 0;
  }
  v4 = EC_KEY_new();
  if (!v4)
    return 0;
  v5 = (char *)v4;
  v6 = EC_KEY_set_group(v4, *v2);
  if ((_DWORD)v6)
    EVP_PKEY_assign(a2, 408, v5);
  else
    EC_KEY_free((EC_KEY *)v5);
  return v6;
}

uint64_t pkey_ec_keygen(uint64_t a1, EVP_PKEY *a2)
{
  const EC_GROUP **v4;
  char *v5;
  EC_KEY *v6;
  const EVP_PKEY *v7;

  v4 = *(const EC_GROUP ***)(a1 + 40);
  if (*(_QWORD *)(a1 + 16) || *v4)
  {
    v5 = (char *)EC_KEY_new();
    if (v5)
    {
      v6 = (EC_KEY *)v5;
      if (EVP_PKEY_assign(a2, 408, v5))
      {
        v7 = *(const EVP_PKEY **)(a1 + 16);
        if (v7)
        {
          if (!EVP_PKEY_copy_parameters(a2, v7))
            return 0;
          return EC_KEY_generate_key(v6);
        }
        if (EC_KEY_set_group(v6, *v4))
          return EC_KEY_generate_key(v6);
      }
      else
      {
        EC_KEY_free(v6);
      }
    }
  }
  else
  {
    ERR_put_error(16, 4095, 139, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_pmeth.c", 485);
  }
  return 0;
}

uint64_t pkey_ec_sign(uint64_t a1, unsigned __int8 *a2, unint64_t *a3, const unsigned __int8 *a4, int a5)
{
  uint64_t v6;
  EC_KEY *v7;
  uint64_t v11;
  unint64_t v12;
  uint64_t result;
  unint64_t v14;
  const EVP_MD *v15;
  int v16;
  unsigned int siglen;

  v6 = *(_QWORD *)(a1 + 16);
  v7 = *(EC_KEY **)(v6 + 32);
  if (!a2)
  {
    v14 = ECDSA_size(*(const EC_KEY **)(v6 + 32));
LABEL_10:
    *a3 = v14;
    return 1;
  }
  v11 = *(_QWORD *)(a1 + 40);
  v12 = *a3;
  if (v12 < ECDSA_size(*(const EC_KEY **)(v6 + 32)))
  {
    ERR_put_error(16, 4095, 100, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_pmeth.c", 176);
    return 0;
  }
  v15 = *(const EVP_MD **)(v11 + 8);
  if (v15)
    v16 = EVP_MD_type(v15);
  else
    v16 = 64;
  siglen = 0;
  result = ECDSA_sign(v16, a4, a5, a2, &siglen, v7);
  if ((int)result >= 1)
  {
    v14 = siglen;
    goto LABEL_10;
  }
  return result;
}

uint64_t pkey_ec_verify(uint64_t a1, const unsigned __int8 *a2, int a3, const unsigned __int8 *a4, int a5)
{
  EC_KEY *v9;
  const EVP_MD *v10;
  int v11;

  v9 = *(EC_KEY **)(*(_QWORD *)(a1 + 16) + 32);
  v10 = *(const EVP_MD **)(*(_QWORD *)(a1 + 40) + 8);
  if (v10)
    v11 = EVP_MD_type(v10);
  else
    v11 = 64;
  return ECDSA_verify(v11, a4, a5, a2, a3, v9);
}

uint64_t pkey_ec_kdf_derive(_QWORD *a1, void *a2, size_t *a3)
{
  uint64_t v6;
  void *v8;
  void *v9;
  int v10;
  size_t v11;
  _BOOL8 v12;
  size_t size;

  v6 = a1[5];
  if (*(_BYTE *)(v6 + 25) == 1)
    return pkey_ec_derive(a1, a2, a3);
  if (a2)
  {
    if (*a3 == *(_QWORD *)(v6 + 56))
    {
      size = 0;
      if (pkey_ec_derive(a1, 0, &size))
      {
        v8 = malloc_type_calloc(1uLL, size, 0x109F10A0uLL);
        if (v8)
        {
          v9 = v8;
          v10 = pkey_ec_derive(a1, v8, &size);
          v11 = size;
          if (v10)
            v12 = ecdh_KDF_X9_63((char *)a2, *a3, v9, size, *(const void **)(v6 + 40), *(_QWORD *)(v6 + 48), *(const EVP_MD **)(v6 + 32)) != 0;
          else
            v12 = 0;
          freezero(v9, v11);
          return v12;
        }
        ERR_put_error(16, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_pmeth.c", 269);
      }
    }
    return 0;
  }
  else
  {
    *a3 = *(_QWORD *)(v6 + 56);
    return 1;
  }
}

uint64_t pkey_ec_ctrl(uint64_t a1, unsigned int a2, int nid, EVP_MD *md)
{
  uint64_t v5;
  EC_GROUP *v7;
  EC_GROUP *v8;
  uint64_t v9;
  uint64_t result;
  uint64_t v12;
  uint64_t v13;
  int v14;
  int v15;

  v5 = *(_QWORD *)(a1 + 40);
  switch(a2)
  {
    case 0x1001u:
      v7 = EC_GROUP_new_by_curve_name(nid);
      if (v7)
      {
        v8 = v7;
        EC_GROUP_free(*(EC_GROUP **)v5);
        *(_QWORD *)v5 = v8;
        return 1;
      }
      v14 = 141;
      v15 = 296;
      goto LABEL_48;
    case 0x1002u:
      if (*(_QWORD *)v5)
      {
        EC_GROUP_set_asn1_flag(*(EC_GROUP **)v5, nid);
        return 1;
      }
      v14 = 139;
      v15 = 305;
      goto LABEL_48;
    case 0x1003u:
      if (nid == -2)
      {
        result = *(char *)(v5 + 24);
        if ((_DWORD)result == -1)
          return (EC_KEY_get_flags(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 32)) >> 12) & 1;
        return result;
      }
      if ((nid - 2) < 0xFFFFFFFD)
        return 4294967294;
      *(_BYTE *)(v5 + 24) = nid;
      if (nid == -1)
      {
        EC_KEY_free(*(EC_KEY **)(v5 + 16));
        *(_QWORD *)(v5 + 16) = 0;
        return 1;
      }
      v12 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32);
      v13 = *(_QWORD *)(v12 + 24);
      if (!v13)
        return 4294967294;
      if (BN_is_one(v13 + 40))
        return 1;
      result = *(_QWORD *)(v5 + 16);
      if (!result)
      {
        result = (uint64_t)EC_KEY_dup((const EC_KEY *)v12);
        *(_QWORD *)(v5 + 16) = result;
        if (!result)
          return result;
      }
      if (nid)
        EC_KEY_set_flags(result, 4096);
      else
        EC_KEY_clear_flags(result, 4096);
      return 1;
    case 0x1004u:
      if (nid == -2)
        return *(char *)(v5 + 25);
      if ((nid - 3) < 0xFFFFFFFE)
        return 4294967294;
      *(_BYTE *)(v5 + 25) = nid;
      return 1;
    case 0x1005u:
      *(_QWORD *)(v5 + 32) = md;
      return 1;
    case 0x1006u:
      v9 = *(_QWORD *)(v5 + 32);
      goto LABEL_20;
    case 0x1007u:
      if (nid < 1)
        return 4294967294;
      *(_QWORD *)(v5 + 56) = nid;
      return 1;
    case 0x1008u:
      md->type = *(_QWORD *)(v5 + 56);
      return 1;
    case 0x1009u:
      free(*(void **)(v5 + 40));
      *(_QWORD *)(v5 + 40) = md;
      if (md)
        *(_QWORD *)(v5 + 48) = nid;
      else
        *(_QWORD *)(v5 + 48) = 0;
      return 1;
    case 0x100Au:
      *(_QWORD *)&md->type = *(_QWORD *)(v5 + 40);
      return *(unsigned int *)(v5 + 48);
    default:
      if (a2 > 0xD)
        return 4294967294;
      if (((1 << a2) & 0x8A4) != 0)
        return 1;
      if (a2 != 1)
      {
        if (a2 != 13)
          return 4294967294;
        v9 = *(_QWORD *)(v5 + 8);
LABEL_20:
        *(_QWORD *)&md->type = v9;
        return 1;
      }
      if (EVP_MD_type(md) == 64
        || EVP_MD_type(md) == 416
        || EVP_MD_type(md) == 675
        || EVP_MD_type(md) == 672
        || EVP_MD_type(md) == 673
        || EVP_MD_type(md) == 674
        || EVP_MD_type(md) == 1031
        || EVP_MD_type(md) == 1032
        || EVP_MD_type(md) == 1033
        || EVP_MD_type(md) == 1034)
      {
        *(_QWORD *)(v5 + 8) = md;
        return 1;
      }
      v14 = 138;
      v15 = 395;
LABEL_48:
      ERR_put_error(16, 4095, v14, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_pmeth.c", v15);
      return 0;
  }
}

uint64_t pkey_ec_ctrl_str(uint64_t *a1, char *__s1, char *a3)
{
  uint64_t *v6;
  int v7;
  int v9;
  int v10;

  if (!strcmp(__s1, "ec_paramgen_curve"))
  {
    if (EC_curve_nist2nid(a3) || OBJ_sn2nid(a3) || OBJ_ln2nid(a3))
    {
      v6 = a1;
      v7 = 6;
      return EVP_PKEY_CTX_ctrl(v6, 408, v7);
    }
    v9 = 141;
    v10 = 429;
  }
  else
  {
    if (!strcmp(__s1, "ec_param_enc"))
    {
      if (!strcmp(a3, "explicit") || !strcmp(a3, "named_curve"))
      {
        v6 = a1;
        v7 = 6;
        return EVP_PKEY_CTX_ctrl(v6, 408, v7);
      }
      return 4294967294;
    }
    if (strcmp(__s1, "ecdh_kdf_md"))
    {
      if (!strcmp(__s1, "ecdh_cofactor_mode"))
      {
        atoi(a3);
        v6 = a1;
        v7 = 1024;
        return EVP_PKEY_CTX_ctrl(v6, 408, v7);
      }
      return 4294967294;
    }
    if (EVP_get_digestbyname(a3))
    {
      v6 = a1;
      v7 = 1024;
      return EVP_PKEY_CTX_ctrl(v6, 408, v7);
    }
    v9 = 151;
    v10 = 445;
  }
  ERR_put_error(16, 4095, v9, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_pmeth.c", v10);
  return 0;
}

uint64_t pkey_ec_derive(_QWORD *a1, void *a2, size_t *a3)
{
  uint64_t v3;
  uint64_t v4;
  const EC_KEY *v7;
  const EC_POINT *v8;
  int v9;
  uint64_t v10;
  const EC_GROUP *v12;
  int degree;
  int v14;

  v3 = a1[2];
  if (!v3 || (v4 = a1[3]) == 0)
  {
    ERR_put_error(16, 4095, 140, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_pmeth.c", 220);
    return 0;
  }
  v7 = *(const EC_KEY **)(a1[5] + 16);
  if (v7)
  {
    if (a2)
      goto LABEL_5;
LABEL_10:
    v12 = EC_KEY_get0_group(v7);
    degree = EC_GROUP_get_degree(v12);
    v14 = degree + 7;
    if (degree < -7)
      v14 = degree + 14;
    v10 = (uint64_t)v14 >> 3;
    goto LABEL_13;
  }
  v7 = *(const EC_KEY **)(v3 + 32);
  if (!a2)
    goto LABEL_10;
LABEL_5:
  v8 = EC_KEY_get0_public_key(*(const EC_KEY **)(v4 + 32));
  v9 = ECDH_compute_key(a2, *a3, v8, v7, 0);
  if (v9 < 1)
    return 0;
  v10 = v9;
LABEL_13:
  *a3 = v10;
  return 1;
}

int X509_NAME_print_ex(BIO *out, X509_NAME *nm, int indent, unint64_t flags)
{
  if (flags)
    return do_name_ex((unsigned int (*)(uint64_t, char *, uint64_t))send_bio_chars, (uint64_t)out, nm, indent, flags);
  else
    return X509_NAME_print(out, nm, indent);
}

uint64_t do_name_ex(unsigned int (*a1)(uint64_t, char *, uint64_t), uint64_t a2, X509_NAME *name, int a4, int a5)
{
  uint64_t v9;
  int v10;
  int v11;
  const char *v12;
  const char *v13;
  int v14;
  const char *v15;
  int v16;
  int v17;
  int v18;
  int v19;
  int v20;
  int v21;
  X509_NAME_ENTRY *entry;
  X509_NAME_ENTRY *v23;
  int v24;
  ASN1_OBJECT *object;
  int v26;
  int v27;
  const char *v28;
  int v29;
  size_t v30;
  int v31;
  int v32;
  BOOL v33;
  __int16 v34;
  int v35;
  int v37;
  const char *v38;
  const char *v39;
  int v40;
  unsigned int v41;
  int v42;
  X509_NAME *v43;
  unsigned int v44;
  const char *v45;
  unsigned int v46;
  int v47;
  ASN1_STRING *data;
  char buf[80];
  uint64_t v50;

  v50 = *MEMORY[0x24BDAC8D0];
  v9 = a4 & ~(a4 >> 31);
  if (a4 >= 1)
  {
    v10 = a4 & ~(a4 >> 31);
    do
    {
      if (!a1(a2, " ", 1))
        return 0xFFFFFFFFLL;
      --v10;
    }
    while (v10);
  }
  v46 = 3;
  v11 = 1;
  v12 = " + ";
  v13 = "\n";
  v14 = v9;
  switch(((*(_QWORD *)&a5 & 0xF0000uLL) - 0x10000) >> 16)
  {
    case 0uLL:
      v14 = 0;
      v12 = "+";
      v46 = 1;
      v13 = ",";
      break;
    case 1uLL:
      v14 = 0;
      v46 = 3;
      v11 = 2;
      v13 = ", ";
      break;
    case 2uLL:
      v14 = 0;
      v46 = 3;
      v11 = 2;
      v13 = "; ";
      break;
    case 3uLL:
      break;
    default:
      return 0xFFFFFFFFLL;
  }
  v15 = " = ";
  if ((*(_QWORD *)&a5 & 0x800000) == 0)
    v15 = "=";
  v45 = v15;
  if ((*(_QWORD *)&a5 & 0x800000) != 0)
    v16 = 3;
  else
    v16 = 1;
  v44 = v16;
  v17 = X509_NAME_entry_count(name);
  if (v17 >= 1)
  {
    v18 = v17;
    v38 = v13;
    v39 = v12;
    v19 = 0;
    v47 = a5 & 0x600000;
    v40 = v14;
    v41 = v11;
    v37 = v11 + v14;
    v20 = -1;
    v43 = name;
    v42 = v17;
    do
    {
      if ((*(_QWORD *)&a5 & 0x100000) != 0)
        v21 = v18 + ~v19;
      else
        v21 = v19;
      entry = X509_NAME_get_entry(name, v21);
      v23 = entry;
      if (v20 != -1)
      {
        if (v20 == X509_NAME_ENTRY_set((uint64_t)entry))
        {
          if (!a1(a2, (char *)v39, v46))
            return 0xFFFFFFFFLL;
          LODWORD(v9) = v9 + v46;
        }
        else
        {
          if (!a1(a2, (char *)v38, v41))
            return 0xFFFFFFFFLL;
          v24 = v40;
          if (v40)
          {
            while (a1(a2, " ", 1))
            {
              if (!--v24)
                goto LABEL_27;
            }
            return 0xFFFFFFFFLL;
          }
LABEL_27:
          LODWORD(v9) = v37 + v9;
        }
      }
      v20 = X509_NAME_ENTRY_set((uint64_t)v23);
      object = X509_NAME_ENTRY_get_object(v23);
      data = X509_NAME_ENTRY_get_data(v23);
      v26 = OBJ_obj2nid(object);
      v27 = v26;
      if (v47 != 6291456)
      {
        if (v47 == 0x400000 || !v26)
        {
          v28 = buf;
          OBJ_obj2txt(buf, 80, object, 1);
          v29 = 0;
        }
        else if (v47 == 0x200000)
        {
          v28 = OBJ_nid2ln(v26);
          v29 = 25;
        }
        else if (v47)
        {
          v29 = 0;
          v28 = "";
        }
        else
        {
          v28 = OBJ_nid2sn(v26);
          v29 = 10;
        }
        v30 = strlen(v28);
        if (!a1(a2, (char *)v28, v30))
          return 0xFFFFFFFFLL;
        if ((a5 & 0x2000000) != 0)
        {
          v31 = v29 - v30;
          if (v29 > (int)v30)
          {
            v32 = v29 - v30;
            if (v31 >= 1)
            {
              while (a1(a2, " ", 1))
              {
                if (!--v32)
                  goto LABEL_43;
              }
              return 0xFFFFFFFFLL;
            }
LABEL_43:
            LODWORD(v9) = v31 + v9;
          }
        }
        name = v43;
        if (!a1(a2, (char *)v45, v44))
          return 0xFFFFFFFFLL;
        LODWORD(v9) = v44 + v30 + v9;
        v18 = v42;
      }
      if (v27)
        v33 = 1;
      else
        v33 = (a5 & 0x1000000) == 0;
      v34 = 128;
      if (v33)
        v34 = 0;
      v35 = do_print_ex(a1, a2, v34 | (unsigned __int16)a5, (uint64_t)data);
      if (v35 < 0)
        return 0xFFFFFFFFLL;
      v9 = (v35 + v9);
      ++v19;
    }
    while (v19 != v18);
  }
  return v9;
}

BOOL send_bio_chars(BIO *a1, const void *a2, int a3)
{
  return !a1 || BIO_write(a1, a2, a3) == a3;
}

int X509_NAME_print_ex_fp(FILE *fp, X509_NAME *nm, int indent, unint64_t flags)
{
  BIO *v7;
  BIO *v8;
  int v9;

  if (flags)
    return do_name_ex((unsigned int (*)(uint64_t, char *, uint64_t))send_fp_chars, (uint64_t)fp, nm, indent, flags);
  v7 = BIO_new_fp(fp, 0);
  if (!v7)
    return -1;
  v8 = v7;
  v9 = X509_NAME_print(v7, nm, indent);
  BIO_free(v8);
  return v9;
}

BOOL send_fp_chars(FILE *__stream, void *__ptr, int a3)
{
  return !__stream || fwrite(__ptr, 1uLL, a3, __stream) == a3;
}

int ASN1_STRING_print_ex(BIO *out, ASN1_STRING *str, unint64_t flags)
{
  return do_print_ex((unsigned int (*)(uint64_t, char *, uint64_t))send_bio_chars, (uint64_t)out, flags, (uint64_t)str);
}

uint64_t do_print_ex(unsigned int (*a1)(uint64_t, char *, uint64_t), uint64_t a2, __int16 a3, uint64_t a4)
{
  int v8;
  unsigned int v9;
  const char *v10;
  size_t v11;
  unsigned int v12;
  unsigned int v13;
  unsigned int v14;
  char v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  int v19;
  int v20;
  int v21;
  unsigned __int8 *v22;
  unsigned __int8 *v23;
  char v25;
  unsigned __int8 *out;
  ASN1_TYPE a;

  v8 = 0;
  v25 = 0;
  v9 = *(_DWORD *)(a4 + 4);
  if ((a3 & 0x40) != 0)
  {
    v10 = ASN1_tag2str(*(_DWORD *)(a4 + 4));
    v11 = strlen(v10);
    if (!a1(a2, (char *)v10, v11))
      return 0xFFFFFFFFLL;
    v12 = a1(a2, ":", 1);
    v8 = v12 ? v11 + 1 : v11;
    if (!v12)
      return 0xFFFFFFFFLL;
  }
  if ((a3 & 0x80) != 0)
    goto LABEL_28;
  if ((a3 & 0x20) != 0)
  {
LABEL_13:
    v14 = 9;
    v13 = 1;
    goto LABEL_14;
  }
  v13 = asn1_tag2charwidth(v9);
  if (v13 == -1)
  {
    if ((a3 & 0x100) == 0)
      goto LABEL_13;
LABEL_28:
    if (a1(a2, "#", 1))
    {
      if ((a3 & 0x200) != 0)
      {
        v20 = *(_DWORD *)(a4 + 4);
        *(&a.type + 1) = 0;
        a.value.ptr = (char *)a4;
        a.type = v20;
        v21 = i2d_ASN1_TYPE(&a, 0);
        v22 = (unsigned __int8 *)malloc_type_malloc(v21, 0x6B9AAD46uLL);
        if (!v22)
          return 0xFFFFFFFFLL;
        v23 = v22;
        out = v22;
        i2d_ASN1_TYPE(&a, &out);
        v19 = do_hex_dump(a1, a2, v23, v21);
        free(v23);
        if (v19 < 0)
          return 0xFFFFFFFFLL;
      }
      else
      {
        v19 = do_hex_dump(a1, a2, *(unsigned __int8 **)(a4 + 8), *(_DWORD *)a4);
        if (v19 < 0)
          return 0xFFFFFFFFLL;
      }
      if (v19 > -2)
        return (v8 + v19 + 1);
    }
    return 0xFFFFFFFFLL;
  }
  v14 = v13 | 8;
  if (!v13)
    v14 = 1;
LABEL_14:
  v15 = a3 & 0xF;
  if ((a3 & 0x10) != 0)
    v16 = v14;
  else
    v16 = v13;
  v17 = do_buf(*(unsigned __int8 **)(a4 + 8), *(_DWORD *)a4, v16, a3 & 0xF, &v25, a1, 0);
  if (v17 < 0)
    return 0xFFFFFFFFLL;
  v18 = v25 ? (v17 + v8 + 2) : (v17 + v8);
  if (a2
    && (v25 && !a1(a2, "\"", 1)
     || (do_buf(*(unsigned __int8 **)(a4 + 8), *(_DWORD *)a4, v16, v15, 0, a1, a2) & 0x80000000) != 0
     || v25 && !a1(a2, "\"", 1)))
  {
    return 0xFFFFFFFFLL;
  }
  return v18;
}

int ASN1_STRING_print_ex_fp(FILE *fp, ASN1_STRING *str, unint64_t flags)
{
  return do_print_ex((unsigned int (*)(uint64_t, char *, uint64_t))send_fp_chars, (uint64_t)fp, flags, (uint64_t)str);
}

uint64_t do_buf(unsigned __int8 *str, int a2, uint64_t a3, char a4, _BYTE *a5, unsigned int (*a6)(uint64_t, char *, uint64_t), uint64_t a7)
{
  uint64_t v7;
  unsigned int v8;
  uint64_t v9;
  unsigned __int8 *v14;
  unsigned __int8 *v15;
  unsigned __int8 *v16;
  char v18;
  unint64_t v19;
  unint64_t v20;
  uint64_t v21;
  unsigned int v23;
  uint64_t v24;
  unsigned int v25;
  char v27;
  int v28;
  uint64_t v29;
  unsigned int v30;
  char v31;
  uint64_t v32;
  unsigned __int8 *v33;
  unsigned int v34;
  int v35;
  unsigned __int8 *v38;
  unsigned int v39;
  unsigned __int8 stra[6];
  unint64_t val;

  if (!a2)
    return 0;
  v7 = a3;
  v8 = a3 & 7;
  v9 = 0xFFFFFFFFLL;
  if (v8 <= 4 && v8 != 3)
  {
    v14 = str;
    v9 = 0;
    val = 0;
    v15 = str;
    v16 = &str[a2];
    v39 = a3 & 7;
    v38 = v16;
    do
    {
      if (v15 != v14 || (a4 & 1) == 0)
        v18 = 0;
      else
        v18 = 32;
      switch(v8)
      {
        case 1u:
          v23 = *v15++;
          val = v23;
          break;
        case 2u:
          v24 = *v15;
          val = v24 << 8;
          val = v15[1] | ((unint64_t)v24 << 8);
          if ((v24 & 0xF8) == 0xD8)
            return 0xFFFFFFFFLL;
          v15 += 2;
          break;
        case 4u:
          val = (unint64_t)*v15 << 24;
          v19 = val | ((unint64_t)v15[1] << 16);
          val = v19;
          v20 = v19 | ((unint64_t)v15[2] << 8);
          val = v20;
          val = v20 | v15[3];
          v21 = v20 & 0xFFFFF800;
          if (v19 >> 16 > 0x10 || v21 == 55296)
            return 0xFFFFFFFFLL;
          v15 += 4;
          break;
        default:
          v25 = UTF8_getc(v15, (_DWORD)v16 - (_DWORD)v15, &val);
          if ((v25 & 0x80000000) != 0)
            return 0xFFFFFFFFLL;
          v15 += v25;
          break;
      }
      if (v15 != v16 || (a4 & 1) == 0)
        v27 = v18;
      else
        v27 = 64;
      if ((v7 & 8) != 0)
      {
        v29 = v7;
        v30 = UTF8_putc(stra, 6, val);
        if ((v30 & 0x80000000) != 0)
          return 0xFFFFFFFFLL;
        if (v30)
        {
          v31 = v27 | a4;
          v32 = v30;
          v33 = stra;
          do
          {
            v34 = *v33++;
            v35 = do_esc_char(v34, v31, a5, a6, a7);
            if (v35 < 0)
              return 0xFFFFFFFFLL;
            v9 = (v35 + v9);
          }
          while (--v32);
        }
        v7 = v29;
        v14 = str;
      }
      else
      {
        v28 = do_esc_char(val, v27 | a4, a5, a6, a7);
        if (v28 < 0)
          return 0xFFFFFFFFLL;
        v9 = (v28 + v9);
      }
      v16 = v38;
      v8 = v39;
    }
    while (v15 != v38);
  }
  return v9;
}

uint64_t do_hex_dump(unsigned int (*a1)(uint64_t, _BYTE *, uint64_t), uint64_t a2, unsigned __int8 *a3, int a4)
{
  uint64_t v8;
  unint64_t v9;
  _BYTE v11[2];

  if (!a2 || !a4)
    return (2 * a4);
  v8 = a4;
  while (1)
  {
    v9 = *a3;
    v11[0] = do_hex_dump_hexdig[v9 >> 4];
    v11[1] = do_hex_dump_hexdig[v9 & 0xF];
    if (!a1(a2, v11, 2))
      break;
    ++a3;
    if (!--v8)
      return (2 * a4);
  }
  return 0xFFFFFFFFLL;
}

uint64_t do_esc_char(unint64_t a1, char a2, _BYTE *a3, unsigned int (*a4)(uint64_t, char *, uint64_t), uint64_t a5)
{
  unsigned int v8;
  char *v9;
  uint64_t v10;
  uint64_t v11;
  char v12;
  char v13;
  char __str[19];
  uint64_t v15;

  v15 = *MEMORY[0x24BDAC8D0];
  if (HIDWORD(a1))
    return 0xFFFFFFFFLL;
  if (a1 >= 0x10000)
  {
    snprintf(__str, 0x13uLL, "\\W%08lX", a1);
    v8 = 10;
    v9 = __str;
    v10 = a5;
    v11 = 10;
    goto LABEL_7;
  }
  if (a1 >= 0x100)
  {
    snprintf(__str, 0x13uLL, "\\U%04lX", a1);
    v8 = 6;
    v9 = __str;
    v10 = a5;
    v11 = 6;
    goto LABEL_7;
  }
  v13 = a1;
  if ((a1 & 0x80) != 0)
    v12 = a2 & 4;
  else
    v12 = char_type[a1] & a2;
  if ((v12 & 0x61) == 0)
  {
    if ((v12 & 6) != 0)
    {
      snprintf(__str, 0x13uLL, "\\%02X", a1);
      v8 = 3;
      v9 = __str;
      v10 = a5;
      v11 = 3;
    }
    else
    {
      if (a1 != 92 || (a2 & 0xF) == 0)
      {
LABEL_24:
        if (a4(a5, &v13, 1))
          return 1;
        else
          return 0xFFFFFFFFLL;
      }
      v9 = "\\\\";
      v8 = 2;
      v10 = a5;
      v11 = 2;
    }
LABEL_7:
    if (a4(v10, v9, v11))
      return v8;
    else
      return 0xFFFFFFFFLL;
  }
  if ((v12 & 8) != 0)
  {
    if (a3)
      *a3 = 1;
    goto LABEL_24;
  }
  if (!a4(a5, "\\", 1))
    return 0xFFFFFFFFLL;
  if (a4(a5, &v13, 1))
    return 2;
  else
    return 0xFFFFFFFFLL;
}

uint64_t CRYPTO_ctr128_encrypt(uint64_t result, _BYTE *a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, unsigned int *a7, uint64_t (*a8)(uint64_t, uint64_t, uint64_t))
{
  char *v14;
  unsigned int v15;
  BOOL v16;
  unint64_t v17;
  char v18;
  uint64_t v19;
  char v20;
  unint64_t v21;
  BOOL v22;
  unsigned int v23;
  uint64_t v24;
  char v25;

  v14 = (char *)result;
  v15 = *a7;
  if (*a7)
    v16 = a3 == 0;
  else
    v16 = 1;
  if (v16)
  {
    v17 = a3;
  }
  else
  {
    do
    {
      v18 = *v14++;
      *a2++ = *(_BYTE *)(a6 + v15) ^ v18;
      v17 = a3 - 1;
      v15 = ((_BYTE)v15 + 1) & 0xF;
      if (!v15)
        break;
      --a3;
    }
    while (a3);
  }
  if (v17 < 0x10)
  {
    v23 = v15;
    if (!v17)
      goto LABEL_25;
    goto LABEL_21;
  }
  do
  {
    result = a8(a5, a6, a4);
    v19 = 15;
    do
    {
      v20 = *(_BYTE *)(a5 + v19) + 1;
      *(_BYTE *)(a5 + v19) = v20;
      if (!v19)
        break;
      --v19;
    }
    while (!v20);
    if (v15 <= 0xF)
    {
      v21 = v15;
      do
      {
        *(_QWORD *)&a2[v21] = *(_QWORD *)(a6 + v21) ^ *(_QWORD *)&v14[v21];
        v22 = v21 >= 8;
        v21 += 8;
      }
      while (!v22);
    }
    v15 = 0;
    v23 = 0;
    v17 -= 16;
    a2 += 16;
    v14 += 16;
  }
  while (v17 > 0xF);
  if (v17)
  {
LABEL_21:
    result = a8(a5, a6, a4);
    v24 = 15;
    do
    {
      v25 = *(_BYTE *)(a5 + v24) + 1;
      *(_BYTE *)(a5 + v24) = v25;
      if (!v24)
        break;
      --v24;
    }
    while (!v25);
    do
    {
      a2[v23] = *(_BYTE *)(a6 + v23) ^ v14[v23];
      ++v23;
      --v17;
    }
    while (v17);
  }
LABEL_25:
  *a7 = v23;
  return result;
}

uint64_t CRYPTO_ctr128_encrypt_ctr32(uint64_t result, _BYTE *a2, unint64_t a3, uint64_t a4, uint64_t a5, _QWORD *a6, unsigned int *a7, uint64_t (*a8)(char *, _BYTE *, unint64_t, uint64_t, uint64_t))
{
  char *v12;
  unsigned int v13;
  BOOL v14;
  unint64_t v15;
  char v16;
  unsigned int v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t v20;
  uint64_t v21;
  char v22;
  uint64_t v23;
  char v24;
  unsigned int *v25;

  v12 = (char *)result;
  v13 = *a7;
  if (*a7)
    v14 = a3 == 0;
  else
    v14 = 1;
  if (v14)
  {
    v15 = a3;
  }
  else
  {
    do
    {
      v16 = *v12++;
      *a2++ = *((_BYTE *)a6 + v13) ^ v16;
      v15 = a3 - 1;
      v13 = ((_BYTE)v13 + 1) & 0xF;
      if (!v13)
        break;
      --a3;
    }
    while (a3);
  }
  v17 = bswap32(*(_DWORD *)(a5 + 12));
  if (v15 >= 0x10)
  {
    do
    {
      v18 = v15 >> 4;
      if (v15 >> 4 >= 0x10000000)
        v18 = 0x10000000;
      v19 = v17 + v18;
      if (v18 <= v19)
        v17 += v18;
      else
        v17 = 0;
      if (v18 <= v19)
        v19 = 0;
      v20 = v18 - v19;
      result = a8(v12, a2, v18 - v19, a4, a5);
      *(_DWORD *)(a5 + 12) = bswap32(v17);
      if (!v17)
      {
        v21 = 11;
        do
        {
          v22 = *(_BYTE *)(a5 + v21) + 1;
          *(_BYTE *)(a5 + v21) = v22;
          if (!v21)
            break;
          --v21;
        }
        while (!v22);
      }
      v15 -= 16 * v20;
      a2 += 16 * v20;
      v12 += 16 * v20;
    }
    while (v15 > 0xF);
  }
  if (v15)
  {
    *a6 = 0;
    a6[1] = 0;
    result = a8((char *)a6, a6, 1uLL, a4, a5);
    *(_DWORD *)(a5 + 12) = bswap32(v17 + 1);
    if (v17 == -1)
    {
      v23 = 11;
      do
      {
        v24 = *(_BYTE *)(a5 + v23) + 1;
        *(_BYTE *)(a5 + v23) = v24;
        if (!v23)
          break;
        --v23;
      }
      while (!v24);
    }
    v25 = a7;
    do
    {
      a2[v13] = *((_BYTE *)a6 + v13) ^ v12[v13];
      ++v13;
      --v15;
    }
    while (v15);
  }
  else
  {
    v25 = a7;
  }
  *v25 = v13;
  return result;
}

void ERR_load_GOST_strings()
{
  if (!ERR_func_error_string(GOST_str_functs))
  {
    ERR_load_strings(0, (ERR_STRING_DATA *)&GOST_str_functs);
    ERR_load_strings(0, (ERR_STRING_DATA *)&GOST_str_reasons);
  }
}

void *x509_constraints_name_new()
{
  return malloc_type_calloc(1uLL, 0x50uLL, 0x1010040B88FB30EuLL);
}

double x509_constraints_name_clear(uint64_t a1)
{
  double result;

  free(*(void **)(a1 + 8));
  free(*(void **)(a1 + 16));
  free(*(void **)(a1 + 24));
  result = 0.0;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)a1 = 0u;
  return result;
}

void x509_constraints_name_free(void *a1)
{
  if (a1)
  {
    x509_constraints_name_clear((uint64_t)a1);
    free(a1);
  }
}

uint64_t x509_constraints_name_dup(uint64_t a1)
{
  _DWORD *v2;
  uint64_t v3;
  size_t v4;
  void *v5;
  const char *v6;
  char *v7;
  const char *v8;
  char *v9;
  __int128 v10;

  v2 = malloc_type_calloc(1uLL, 0x50uLL, 0x1010040B88FB30EuLL);
  v3 = (uint64_t)v2;
  if (v2)
  {
    *v2 = *(_DWORD *)a1;
    v2[10] = *(_DWORD *)(a1 + 40);
    *((_QWORD *)v2 + 4) = *(_QWORD *)(a1 + 32);
    v4 = *(_QWORD *)(a1 + 32);
    if (v4)
    {
      v5 = malloc_type_malloc(v4, 0x41EC30A9uLL);
      *(_QWORD *)(v3 + 24) = v5;
      if (!v5)
        goto LABEL_10;
      memcpy(v5, *(const void **)(a1 + 24), *(_QWORD *)(a1 + 32));
    }
    v6 = *(const char **)(a1 + 8);
    if (!v6 || (v7 = strdup(v6), (*(_QWORD *)(v3 + 8) = v7) != 0))
    {
      v8 = *(const char **)(a1 + 16);
      if (!v8 || (v9 = strdup(v8), (*(_QWORD *)(v3 + 16) = v9) != 0))
      {
        v10 = *(_OWORD *)(a1 + 44);
        *(_OWORD *)(v3 + 60) = *(_OWORD *)(a1 + 60);
        *(_OWORD *)(v3 + 44) = v10;
        return v3;
      }
    }
LABEL_10:
    x509_constraints_name_clear(v3);
    free((void *)v3);
    return 0;
  }
  return v3;
}

_QWORD *x509_constraints_names_new(uint64_t a1)
{
  _QWORD *result;

  result = malloc_type_calloc(1uLL, 0x20uLL, 0x1080040ABB4582EuLL);
  if (result)
    result[3] = a1;
  return result;
}

double x509_constraints_names_clear(uint64_t a1)
{
  unint64_t v2;
  unint64_t i;
  void *v4;
  double result;

  v2 = *(_QWORD *)(a1 + 8);
  if (v2)
  {
    for (i = 0; i < v2; ++i)
    {
      v4 = *(void **)(*(_QWORD *)a1 + 8 * i);
      if (v4)
      {
        x509_constraints_name_clear(*(_QWORD *)(*(_QWORD *)a1 + 8 * i));
        free(v4);
        v2 = *(_QWORD *)(a1 + 8);
      }
    }
  }
  free(*(void **)a1);
  result = 0.0;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  return result;
}

void x509_constraints_names_free(void *a1)
{
  if (a1)
  {
    x509_constraints_names_clear((uint64_t)a1);
    free(a1);
  }
}

char *x509_constraints_names_add(uint64_t a1, uint64_t a2)
{
  unint64_t v3;
  uint64_t v5;
  char *result;

  v3 = *(_QWORD *)(a1 + 8);
  if (v3 >= *(_QWORD *)(a1 + 24))
    return 0;
  v5 = *(_QWORD *)(a1 + 16);
  result = *(char **)a1;
  if (v3 == v5)
  {
    result = recallocarray(result, v3, v3 + 32, 8uLL);
    if (!result)
      return result;
    v3 = *(_QWORD *)(a1 + 8);
    *(_QWORD *)(a1 + 16) += 32;
    *(_QWORD *)a1 = result;
  }
  *(_QWORD *)&result[8 * v3] = a2;
  *(_QWORD *)(a1 + 8) = v3 + 1;
  return (char *)1;
}

void *x509_constraints_names_dup(_QWORD *a1)
{
  uint64_t v2;
  void *v3;
  void *v4;
  uint64_t v5;
  uint64_t v6;
  void *v7;

  if (!a1)
    return 0;
  v2 = a1[3];
  v3 = malloc_type_calloc(1uLL, 0x20uLL, 0x1080040ABB4582EuLL);
  v4 = v3;
  if (v3)
  {
    *((_QWORD *)v3 + 3) = v2;
    if (a1[1])
    {
      v5 = 0;
      while (1)
      {
        v6 = x509_constraints_name_dup(*(_QWORD *)(*a1 + 8 * v5));
        if (!v6)
        {
          x509_constraints_names_clear((uint64_t)v4);
          v7 = v4;
          goto LABEL_12;
        }
        v7 = (void *)v6;
        if (!x509_constraints_names_add((uint64_t)v4, v6))
          break;
        if ((unint64_t)++v5 >= a1[1])
          return v4;
      }
      x509_constraints_names_clear((uint64_t)v4);
      free(v4);
      x509_constraints_name_clear((uint64_t)v7);
LABEL_12:
      free(v7);
      return 0;
    }
  }
  return v4;
}

uint64_t x509_constraints_valid_host(_QWORD *a1)
{
  int v2;
  uint64_t result;
  char v4;
  char *v5;
  _QWORD v6[3];
  int v7;
  _QWORD v8[3];

  v8[2] = *MEMORY[0x24BDAC8D0];
  v4 = 0;
  v2 = CBS_peek_u8((uint64_t)a1, &v4);
  result = 0;
  if (v2 && v4 != 46)
  {
    v5 = 0;
    if ((unint64_t)CBS_len((uint64_t)a1) <= 0x2E)
    {
      memset(v6, 0, sizeof(v6));
      v7 = 0;
      v8[0] = 0;
      v8[1] = 0;
      if (CBS_strdup((uint64_t)a1, (void **)&v5))
      {
        if (inet_pton(2, v5, v8) == 1 || inet_pton(30, v5, v6) == 1)
        {
          free(v5);
          return 0;
        }
        free(v5);
      }
    }
    return x509_constraints_valid_domain_internal(a1, 0);
  }
  return result;
}

uint64_t x509_constraints_valid_domain_internal(_QWORD *a1, int a2)
{
  unint64_t v4;
  uint64_t result;
  int v6;
  uint64_t v7;
  int v8;
  unint64_t v9;
  uint64_t v10;
  BOOL v12;
  _QWORD v13[3];
  unsigned __int8 v14;

  v14 = 0;
  memset(v13, 0, sizeof(v13));
  CBS_dup(a1, v13);
  v4 = CBS_len((uint64_t)a1);
  result = 0;
  if (v4 <= 0xFF)
  {
    if (v4)
    {
      v6 = 0;
      v7 = 0;
      v8 = 0;
      v9 = v4 - 1;
      v10 = MEMORY[0x24BDAC740];
      while (1)
      {
        result = CBS_get_u8(v13, &v14);
        if (!(_DWORD)result)
          break;
        if ((char)v14 < 1)
          return 0;
        if ((*(_DWORD *)(v10 + 4 * v14 + 60) & 0x500) == 0
          && (v14 - 42 > 0x35 || ((1 << (v14 - 42)) & 0x20000000000019) == 0))
        {
          return 0;
        }
        if (!a2 && v14 == 42)
          return 0;
        if (v14 == 46)
        {
          result = 0;
          if (v7)
            v12 = v8 == 0;
          else
            v12 = 0;
          if (v12 || v9 == v7 || v6 == 45)
            return result;
        }
        else
        {
          if (v14 == 45)
          {
            result = 0;
            if (!v8 || v9 == v7)
              return result;
          }
          result = 0;
          if (v6 == 42 || v8 > 62)
            return result;
          LODWORD(result) = v8 + 1;
        }
        ++v7;
        v6 = v14;
        v8 = result;
        if (v4 == v7)
          return 1;
      }
    }
    else
    {
      return 1;
    }
  }
  return result;
}

uint64_t x509_constraints_valid_sandns(_QWORD *a1)
{
  int v2;
  uint64_t result;
  char v4;

  v4 = 0;
  v2 = CBS_peek_u8((uint64_t)a1, &v4);
  result = 0;
  if (v2 && v4 != 46)
  {
    if ((unint64_t)CBS_len((uint64_t)a1) <= 3 && v4 == 42)
      return 0;
    else
      return x509_constraints_valid_domain_internal(a1, 1);
  }
  return result;
}

uint64_t x509_constraints_parse_mailbox(uint64_t result, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  int v5;
  int v6;
  unint64_t v7;
  uint64_t v8;
  char *v9;
  char *v10;
  unsigned __int8 v11;
  unint64_t v13;
  size_t v14;
  uint64_t v15;
  uint64_t v16;
  unsigned __int8 v17;
  char v18;
  _QWORD v19[3];
  _QWORD v20[3];
  char __s1[16];
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  uint64_t v37;

  v37 = *MEMORY[0x24BDAC8D0];
  v35 = 0u;
  v36 = 0u;
  v33 = 0u;
  v34 = 0u;
  v31 = 0u;
  v32 = 0u;
  v29 = 0u;
  v30 = 0u;
  v27 = 0u;
  v28 = 0u;
  v26 = 0u;
  v24 = 0u;
  v25 = 0u;
  v22 = 0u;
  v23 = 0u;
  *(_OWORD *)__s1 = 0u;
  if (!result)
    return result;
  memset(v20, 0, sizeof(v20));
  memset(v19, 0, sizeof(v19));
  CBS_dup((_QWORD *)result, v19);
  v3 = CBS_len((uint64_t)v19);
  if ((unint64_t)(v3 - 321) < 0xFFFFFFFFFFFFFEC0)
    return 0;
  v4 = v3;
  v15 = a2;
  v5 = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v16 = v3 - 1;
  do
  {
    v18 = 0;
    if (!CBS_get_u8(v19, &v18) || v18 < 0)
      goto LABEL_55;
    v11 = v18;
    if (v18 <= 0xD && ((1 << v18) & 0x2401) != 0)
      goto LABEL_55;
    if (!v8)
    {
      if (v18 == 34)
        v5 = 1;
      if (v18 == 46)
        goto LABEL_55;
    }
    if (v6)
    {
      if (v7 > 0xFE)
        goto LABEL_55;
LABEL_17:
      v6 = 0;
      goto LABEL_18;
    }
    if (v10)
    {
      if (v7 > 0xFE)
        goto LABEL_55;
      v13 = v7 + 1;
      __s1[v7] = v18;
      if (v16 == v8)
      {
        if (v9)
          goto LABEL_55;
        v9 = strdup(__s1);
        if (!v9)
          goto LABEL_55;
      }
      v6 = 0;
    }
    else
    {
      if (v7 >= 0x40)
        goto LABEL_54;
      if (v5)
      {
        if (v18 != 92)
        {
          v5 = 1;
          if (v8 && v18 == 34)
          {
            v17 = 0;
            if (!CBS_peek_u8((uint64_t)v19, &v17) || v17 != 64)
              goto LABEL_54;
            v5 = 0;
            v11 = v18;
          }
          if (v11 == 9)
            goto LABEL_54;
          v10 = 0;
          goto LABEL_17;
        }
        v10 = 0;
        v6 = 1;
        v13 = v7;
        v5 = 1;
      }
      else
      {
        if (v18 == 92)
        {
          v17 = 0;
          if (!CBS_peek_u8((uint64_t)v19, &v17) || !local_part_ok(v17))
          {
LABEL_54:
            v10 = 0;
LABEL_55:
            free(v10);
            free(v9);
            return 0;
          }
          v6 = 1;
          v11 = v18;
LABEL_47:
          if (!local_part_ok(v11))
            goto LABEL_54;
          v10 = 0;
          v5 = 0;
LABEL_18:
          v13 = v7 + 1;
          __s1[v7] = v11;
          goto LABEL_25;
        }
        if (v18 != 64)
        {
          v6 = 0;
          goto LABEL_47;
        }
        if (!v7)
          goto LABEL_54;
        v10 = strdup(__s1);
        if (!v10)
          goto LABEL_55;
        v13 = 0;
        v6 = 0;
        v5 = 0;
        v35 = 0u;
        v36 = 0u;
        v33 = 0u;
        v34 = 0u;
        v31 = 0u;
        v32 = 0u;
        v29 = 0u;
        v30 = 0u;
        v27 = 0u;
        v28 = 0u;
        v26 = 0u;
        v24 = 0u;
        v25 = 0u;
        v22 = 0u;
        v23 = 0u;
        *(_OWORD *)__s1 = 0u;
      }
    }
LABEL_25:
    ++v8;
    v7 = v13;
  }
  while (v4 != v8);
  if (!v10)
    goto LABEL_55;
  if (!v9)
    goto LABEL_55;
  v14 = strlen(v9);
  CBS_init(v20, (uint64_t)v9, v14);
  if (!x509_constraints_valid_host(v20))
    goto LABEL_55;
  if (v15)
  {
    *(_QWORD *)(v15 + 8) = v9;
    *(_QWORD *)(v15 + 16) = v10;
    result = 1;
    *(_DWORD *)v15 = 1;
  }
  else
  {
    free(v10);
    free(v9);
    return 1;
  }
  return result;
}

uint64_t local_part_ok(unsigned __int8 a1)
{
  int v1;
  unsigned int v2;
  unsigned int v3;
  uint64_t result;
  BOOL v5;
  unsigned int v6;
  _BOOL4 v7;

  v1 = a1;
  v2 = a1 - 48;
  v3 = (a1 & 0xDF) - 65;
  result = 1;
  v5 = v2 >= 0xA && v3 >= 0x1A;
  if (v5 && ((v1 - 33) > 0x3F || ((1 << (v1 - 33)) & 0xE00000005000567DLL) == 0))
  {
    v6 = v1 - 123;
    v7 = v1 == 46;
    return v6 < 4 || v7;
  }
  return result;
}

uint64_t x509_constraints_valid_domain_constraint(_QWORD *a1)
{
  int v2;
  uint64_t result;
  char v4;

  if (!CBS_len((uint64_t)a1))
    return 1;
  v4 = 0;
  if ((unint64_t)CBS_len((uint64_t)a1) > 2)
    return x509_constraints_valid_domain_internal(a1, 0);
  v2 = CBS_peek_u8((uint64_t)a1, &v4);
  result = 0;
  if (v2)
  {
    if (v4 != 46)
      return x509_constraints_valid_domain_internal(a1, 0);
  }
  return result;
}

uint64_t x509_constraints_uri_host(uint64_t a1, unint64_t a2, void **a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t result;
  uint64_t v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unsigned int v15;
  uint64_t v16;
  _QWORD v17[7];

  if (a2 < 3)
    return 0;
  v17[5] = v3;
  v17[6] = v4;
  v7 = 0;
  do
  {
    v8 = *(char *)(a1 + v7);
    if (v8 < 0)
      return 0;
    if (v8 == 47)
    {
      v9 = a1 + v7;
      if (*(_BYTE *)(a1 + v7 + 1) == 47)
      {
        if (v7 + 2 >= a2)
          return 0;
        v10 = 0;
        v11 = 0;
        v12 = v9 + 2;
        v13 = v9 + 3;
        v14 = a2 - v7 - 2;
        while (1)
        {
          if (*(char *)(v13 - 1) < 0)
            return 0;
          v15 = *(unsigned __int8 *)(v13 - 1) - 35;
          if (v15 <= 0x1D)
          {
            if (*(_BYTE *)(v13 - 1) == 64)
            {
              if (v10)
                return 0;
              v11 = 0;
              v10 = v13;
              goto LABEL_20;
            }
            if (((1 << v15) & 0x10801001) != 0)
              goto LABEL_21;
          }
          ++v11;
LABEL_20:
          ++v13;
          if (!--v14)
          {
LABEL_21:
            if (!v11)
              return 0;
            memset(v17, 0, 24);
            if (v10)
              v16 = v10;
            else
              v16 = v12;
            CBS_init(v17, v16, v11);
            result = x509_constraints_valid_host(v17);
            if ((_DWORD)result)
            {
              if (!a3)
                return 1;
              result = CBS_strdup((uint64_t)v17, a3);
              if ((_DWORD)result)
                return 1;
            }
            return result;
          }
        }
      }
    }
    ++v7;
  }
  while (a2 - 1 != v7);
  if (a3)
    *a3 = strdup("");
  return 1;
}

BOOL x509_constraints_sandns(uint64_t a1, unint64_t a2, char *a3, size_t a4)
{
  if (!a4)
    return 1;
  if (a2 >= a4)
    return strncasecmp((const char *)(a1 + a2 - a4), a3, a4) == 0;
  return 0;
}

BOOL x509_constraints_domain(char *a1, size_t a2, char *a3, size_t a4)
{
  const char *v5;
  BOOL v6;
  size_t v7;
  size_t v9;

  if (!a4)
    return 1;
  v5 = a1;
  if (*a3 == 46)
  {
    v6 = a2 >= a4;
    v7 = a2 - a4;
    if (!v6)
      return 0;
    a1 += v7;
    goto LABEL_11;
  }
  if (*a1 == 46)
  {
    if (a4 >= a2)
    {
      a1 = &a3[a4 - a2];
      v9 = a2;
      return strncasecmp(a1, v5, v9) == 0;
    }
  }
  else if (a2 == a4)
  {
LABEL_11:
    v5 = a3;
    v9 = a4;
    return strncasecmp(a1, v5, v9) == 0;
  }
  return 0;
}

BOOL x509_constraints_uri(uint64_t a1, unint64_t a2, char *a3, size_t a4, int *a5)
{
  size_t v10;
  _BOOL8 v11;
  int v12;
  char *v14[3];
  char *__s;

  __s = 0;
  memset(v14, 0, sizeof(v14));
  CBS_init(v14, (uint64_t)a3, a4);
  if (!x509_constraints_uri_host(a1, a2, (void **)&__s))
  {
    v11 = 0;
    v12 = 53;
LABEL_8:
    *a5 = v12;
    goto LABEL_9;
  }
  if (!__s)
  {
    v11 = 0;
    v12 = 17;
    goto LABEL_8;
  }
  if (!x509_constraints_valid_domain_constraint(v14))
  {
    v11 = 0;
    v12 = 52;
    goto LABEL_8;
  }
  v10 = strlen(__s);
  v11 = x509_constraints_domain(__s, v10, a3, a4);
LABEL_9:
  free(__s);
  return v11;
}

uint64_t x509_constraints_ipaddr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;

  if (a4 == 2 * a2)
  {
    if (!a2)
      return 1;
    v4 = 0;
    while (((*(unsigned __int8 *)(a3 + v4) ^ *(unsigned __int8 *)(a1 + v4)) & *(unsigned __int8 *)(a3 + a2 + v4)) == 0)
    {
      if (a2 == ++v4)
        return 1;
    }
  }
  return 0;
}

BOOL x509_constraints_dirname(void *__s2, size_t a2, void *__s1, size_t __n)
{
  return __n <= a2 && memcmp(__s1, __s2, __n) == 0;
}

uint64_t x509_constraints_general_to_bytes(unsigned int *a1, _QWORD *a2, _QWORD *a3)
{
  uint64_t result;
  int *v7;
  uint64_t v8;
  int v9;

  *a2 = 0;
  *a3 = 0;
  result = *a1;
  switch((int)result)
  {
    case 1:
      v7 = (int *)*((_QWORD *)a1 + 1);
      *a2 = *((_QWORD *)v7 + 1);
      result = 1;
      goto LABEL_12;
    case 2:
      v7 = (int *)*((_QWORD *)a1 + 1);
      *a2 = *((_QWORD *)v7 + 1);
      result = 2;
      goto LABEL_12;
    case 4:
      v8 = *((_QWORD *)a1 + 1);
      if (!*(_DWORD *)(v8 + 8))
      {
        result = 4;
        goto LABEL_11;
      }
      v9 = i2d_X509_NAME(*((X509_NAME **)a1 + 1), 0);
      result = *a1;
      if ((v9 & 0x80000000) == 0)
      {
LABEL_11:
        *a2 = *(_QWORD *)(v8 + 24);
        v7 = (int *)(v8 + 32);
        goto LABEL_12;
      }
LABEL_6:
      if ((_DWORD)result != 7)
        return 0;
      *a2 = *(_QWORD *)(*((_QWORD *)a1 + 1) + 8);
      v7 = (int *)*((_QWORD *)a1 + 1);
LABEL_12:
      *a3 = *v7;
      return result;
    case 6:
      v7 = (int *)*((_QWORD *)a1 + 1);
      *a2 = *((_QWORD *)v7 + 1);
      result = 6;
      goto LABEL_12;
    default:
      goto LABEL_6;
  }
}

uint64_t x509_constraints_extract_names(uint64_t a1, uint64_t a2, int a3, int *a4)
{
  char *v8;
  unsigned int *v9;
  uint64_t v10;
  int v11;
  _DWORD *v12;
  int v13;
  size_t v14;
  const void *v15;
  void *v16;
  int v17;
  int v18;
  int v19;
  int v20;
  X509_NAME *subject_name;
  void *v22;
  int i;
  X509_NAME_ENTRY *entry;
  ASN1_STRING *data;
  int index_by_NID;
  int v27;
  X509_NAME_ENTRY *v28;
  ASN1_STRING *v29;
  void *v30;
  uint64_t result;
  int *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  size_t v36;
  const void *v37;

  v8 = sk_value(*(const STACK **)(a2 + 112), 0);
  if (!v8)
  {
    v18 = 1;
    v11 = a3;
LABEL_31:
    subject_name = X509_get_subject_name((X509 *)a2);
    if (X509_NAME_entry_count(subject_name) >= 1)
    {
      if (subject_name->modified && i2d_X509_NAME(subject_name, 0) < 0)
      {
LABEL_58:
        v12 = 0;
LABEL_59:
        v20 = 17;
        goto LABEL_60;
      }
      v12 = malloc_type_calloc(1uLL, 0x50uLL, 0x1010040B88FB30EuLL);
      if (!v12)
        goto LABEL_59;
      v22 = malloc_type_malloc(SLODWORD(subject_name[1].entries), 0x9E8C541uLL);
      *((_QWORD *)v12 + 3) = v22;
      if (!v22)
        goto LABEL_59;
      memcpy(v22, (const void *)subject_name->hash, SLODWORD(subject_name[1].entries));
      *((_QWORD *)v12 + 4) = SLODWORD(subject_name[1].entries);
      *v12 = 4;
      if (!x509_constraints_names_add(a1, (uint64_t)v12))
      {
        *a4 = 17;
        goto LABEL_61;
      }
      if (v11)
      {
        for (i = X509_NAME_get_index_by_NID(subject_name, 48, v18);
              (i & 0x80000000) == 0;
              i = X509_NAME_get_index_by_NID(subject_name, 48, i))
        {
          v33 = 0;
          v34 = 0;
          v35 = 0;
          entry = X509_NAME_get_entry(subject_name, i);
          if (!entry)
            goto LABEL_58;
          data = X509_NAME_ENTRY_get_data(entry);
          if (!data)
            goto LABEL_58;
          CBS_init(&v33, (uint64_t)data->data, data->length);
          v12 = malloc_type_calloc(1uLL, 0x50uLL, 0x1010040B88FB30EuLL);
          if (!v12)
            goto LABEL_59;
          if (!x509_constraints_parse_mailbox((uint64_t)&v33, (uint64_t)v12))
            goto LABEL_29;
          *v12 = 1;
          if (!x509_constraints_names_add(a1, (uint64_t)v12))
            goto LABEL_59;
        }
        v18 = i;
      }
      if (a3)
      {
        index_by_NID = X509_NAME_get_index_by_NID(subject_name, 13, v18);
        if ((index_by_NID & 0x80000000) == 0)
        {
          v27 = index_by_NID;
          while (1)
          {
            v33 = 0;
            v34 = 0;
            v35 = 0;
            v28 = X509_NAME_get_entry(subject_name, v27);
            if (!v28)
              goto LABEL_58;
            v29 = X509_NAME_ENTRY_get_data(v28);
            if (!v29)
              goto LABEL_58;
            CBS_init(&v33, (uint64_t)v29->data, v29->length);
            if (x509_constraints_valid_host(&v33))
            {
              v30 = malloc_type_calloc(1uLL, 0x50uLL, 0x1010040B88FB30EuLL);
              v12 = v30;
              if (!v30)
                goto LABEL_59;
              if (!CBS_strdup((uint64_t)&v33, (void **)v30 + 1))
                goto LABEL_59;
              *v12 = 2;
              if (!x509_constraints_names_add(a1, (uint64_t)v12))
                goto LABEL_59;
            }
            v27 = X509_NAME_get_index_by_NID(subject_name, 13, v27);
            result = 1;
            if (v27 < 0)
              return result;
          }
        }
      }
    }
    return 1;
  }
  v9 = (unsigned int *)v8;
  v10 = 1;
  v11 = a3;
  v32 = a4;
  while (2)
  {
    v36 = 0;
    v37 = 0;
    v33 = 0;
    v34 = 0;
    v35 = 0;
    v12 = malloc_type_calloc(1uLL, 0x50uLL, 0x1010040B88FB30EuLL);
    if (!v12)
      goto LABEL_59;
    v13 = x509_constraints_general_to_bytes(v9, &v37, &v36);
    v14 = v36;
    v15 = v37;
    CBS_init(&v33, (uint64_t)v37, v36);
    switch(v13)
    {
      case 1:
        if (!x509_constraints_parse_mailbox((uint64_t)&v33, (uint64_t)v12))
          goto LABEL_29;
        v11 = 0;
        goto LABEL_24;
      case 2:
        if (!x509_constraints_valid_sandns(&v33))
          goto LABEL_29;
        if (!CBS_strdup((uint64_t)&v33, (void **)v12 + 1))
          goto LABEL_59;
        a3 = 0;
        goto LABEL_24;
      case 4:
        if (!v14)
          goto LABEL_29;
        if (!v15)
          goto LABEL_59;
        v16 = malloc_type_malloc(v14, 0x64E6E4BAuLL);
        *((_QWORD *)v12 + 3) = v16;
        if (!v16)
          goto LABEL_59;
        memcpy(v16, v15, v14);
        *((_QWORD *)v12 + 4) = v14;
        goto LABEL_24;
      case 6:
        if (x509_constraints_uri_host((uint64_t)v15, v14, (void **)v12 + 1))
        {
          a4 = v32;
          if (!*((_QWORD *)v12 + 1))
            goto LABEL_59;
LABEL_24:
          *v12 = v13;
          if (!x509_constraints_names_add(a1, (uint64_t)v12))
            goto LABEL_59;
LABEL_25:
          v18 = v10 + 1;
          v9 = (unsigned int *)sk_value(*(const STACK **)(a2 + 112), v10++);
          if (!v9)
            goto LABEL_31;
          continue;
        }
        v20 = 53;
        a4 = v32;
LABEL_60:
        *a4 = v20;
        if (v12)
        {
LABEL_61:
          x509_constraints_name_clear((uint64_t)v12);
          free(v12);
        }
        return 0;
      case 7:
        if (v14 == 4)
        {
          v17 = 2;
          goto LABEL_22;
        }
        if (v14 == 16)
        {
          v17 = 30;
LABEL_22:
          v12[10] = v17;
          goto LABEL_23;
        }
        v19 = v12[10];
        if (v19 != 2 && v19 != 30)
        {
LABEL_29:
          v20 = 53;
          goto LABEL_60;
        }
LABEL_23:
        __memcpy_chk();
        goto LABEL_24;
      default:
        x509_constraints_name_clear((uint64_t)v12);
        free(v12);
        goto LABEL_25;
    }
  }
}

uint64_t x509_constraints_validate(unsigned int *a1, void ***a2, int *a3)
{
  uint64_t result;
  void **v7;
  void **v8;
  int v9;
  size_t v10;
  const char *v11;
  char *v12;
  int v13;
  void *v14;
  int v15;
  _QWORD v16[3];
  size_t v17;
  const char *v18;
  char v19;

  v17 = 0;
  v18 = 0;
  if (!a2 || *a2)
    return 0;
  if (a3)
    *a3 = 0;
  v7 = (void **)malloc_type_calloc(1uLL, 0x50uLL, 0x1010040B88FB30EuLL);
  if (v7)
  {
    v8 = v7;
    v19 = 0;
    memset(v16, 0, sizeof(v16));
    v9 = x509_constraints_general_to_bytes(a1, &v18, &v17);
    v10 = v17;
    v11 = v18;
    CBS_init(v16, (uint64_t)v18, v17);
    switch(v9)
    {
      case 1:
        if (v10 && memchr((void *)(v11 + 1), 64, v10 - 1))
        {
          if (x509_constraints_parse_mailbox((uint64_t)v16, (uint64_t)v8))
            goto LABEL_37;
          goto LABEL_31;
        }
        if (CBS_len((uint64_t)v16)
          && (!CBS_peek_u8((uint64_t)v16, &v19) || v19 == 64 && !CBS_skip(v16, 1uLL))
          || !x509_constraints_valid_domain_constraint(v16))
        {
          goto LABEL_31;
        }
        if (CBS_strdup((uint64_t)v16, v8 + 1))
          goto LABEL_36;
        goto LABEL_30;
      case 2:
      case 6:
        if (!x509_constraints_valid_domain_constraint(v16))
          goto LABEL_31;
        v12 = strndup(v11, v10);
        v8[1] = v12;
        if (!v12)
          goto LABEL_30;
        goto LABEL_36;
      case 4:
        if (!v10)
          goto LABEL_31;
        if (v11)
        {
          v14 = malloc_type_malloc(v10, 0xDCEF90EAuLL);
          v8[3] = v14;
          if (v14)
          {
            memcpy(v14, v11, v10);
            v8[4] = (void *)v10;
            goto LABEL_36;
          }
        }
LABEL_30:
        v13 = 17;
        goto LABEL_32;
      case 7:
        if (v10 == 8)
        {
          v15 = 2;
LABEL_35:
          *((_DWORD *)v8 + 10) = v15;
          __memcpy_chk();
LABEL_36:
          *(_DWORD *)v8 = v9;
LABEL_37:
          *a2 = v8;
          return 1;
        }
        if (v10 == 32)
        {
          v15 = 30;
          goto LABEL_35;
        }
LABEL_31:
        v13 = 52;
LABEL_32:
        x509_constraints_name_clear((uint64_t)v8);
        free(v8);
        if (!a3)
          return 0;
        break;
      default:
        goto LABEL_37;
    }
  }
  else
  {
    v13 = 17;
    if (!a3)
      return 0;
  }
  result = 0;
  *a3 = v13;
  return result;
}

uint64_t x509_constraints_extract_constraints(uint64_t a1, uint64_t a2, uint64_t a3, int *a4)
{
  const STACK **v4;
  int v8;
  char *v9;
  uint64_t result;
  void **v11;
  int v12;
  char *v13;
  void **v14;
  int v15;
  void **v16;
  void **v17;

  v17 = 0;
  v4 = *(const STACK ***)(a1 + 120);
  if (!v4)
    return 1;
  if (sk_num(*v4) >= 1)
  {
    v8 = 0;
    do
    {
      v9 = sk_value(*v4, v8);
      if (*((_QWORD *)v9 + 1) || *((_QWORD *)v9 + 2))
        goto LABEL_23;
      result = x509_constraints_validate(*(unsigned int **)v9, &v17, a4);
      if (!(_DWORD)result)
        return result;
      v11 = v17;
      if (*(_DWORD *)v17)
      {
        if (!x509_constraints_names_add(a2, (uint64_t)v17))
        {
LABEL_24:
          v16 = v17;
          if (v17)
          {
            x509_constraints_name_clear((uint64_t)v17);
            free(v16);
          }
          v15 = 17;
          goto LABEL_27;
        }
      }
      else
      {
        x509_constraints_name_clear((uint64_t)v17);
        free(v11);
      }
      v17 = 0;
    }
    while (++v8 < sk_num(*v4));
  }
  if (sk_num(v4[1]) < 1)
    return 1;
  v12 = 0;
  while (1)
  {
    v13 = sk_value(v4[1], v12);
    if (*((_QWORD *)v13 + 1) || *((_QWORD *)v13 + 2))
      break;
    result = x509_constraints_validate(*(unsigned int **)v13, &v17, a4);
    if (!(_DWORD)result)
      return result;
    v14 = v17;
    if (*(_DWORD *)v17)
    {
      if (!x509_constraints_names_add(a3, (uint64_t)v17))
        goto LABEL_24;
    }
    else
    {
      x509_constraints_name_clear((uint64_t)v17);
      free(v14);
    }
    v17 = 0;
    if (++v12 >= sk_num(v4[1]))
      return 1;
  }
LABEL_23:
  v15 = 49;
LABEL_27:
  result = 0;
  *a4 = v15;
  return result;
}

uint64_t x509_constraints_match(int *a1, uint64_t a2)
{
  int v2;
  uint64_t result;
  const char *v6;
  int v7;
  char *v8;
  size_t v9;
  char *v10;
  size_t v11;
  const char *v12;
  size_t v13;
  const char *v14;
  size_t v15;
  size_t v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  uint64_t v21;

  v2 = *a1;
  if (*a1 == *(_DWORD *)a2)
  {
    result = 0;
    switch(v2)
    {
      case 1:
        v6 = *(const char **)(a2 + 16);
        if (!v6)
          goto LABEL_6;
        if (strcmp(*((const char **)a1 + 2), v6))
          return 0;
        v7 = strcmp(*((const char **)a1 + 1), *(const char **)(a2 + 8));
        return v7 == 0;
      case 2:
        v12 = (const char *)*((_QWORD *)a1 + 1);
        v13 = strlen(v12);
        v14 = *(const char **)(a2 + 8);
        v15 = strlen(v14);
        if (!v15)
          return 1;
        if (v13 < v15)
          return 0;
        v7 = strncasecmp(&v12[v13 - v15], v14, v15);
        return v7 == 0;
      case 4:
        v16 = *(_QWORD *)(a2 + 32);
        if (v16 > *((_QWORD *)a1 + 4))
          return 0;
        v7 = memcmp(*(const void **)(a2 + 24), *((const void **)a1 + 3), v16);
        return v7 == 0;
      case 6:
LABEL_6:
        v8 = (char *)*((_QWORD *)a1 + 1);
        v9 = strlen(v8);
        v10 = *(char **)(a2 + 8);
        v11 = strlen(v10);
        return x509_constraints_domain(v8, v9, v10, v11);
      case 7:
        v17 = a1[10];
        v18 = 16;
        if (v17 == 2)
          v18 = 4;
        v19 = 32;
        if (v17 == 2)
          v19 = 8;
        if (v17 != 30 && v17 != 2)
          return 0;
        v20 = *(_DWORD *)(a2 + 40);
        if (v20 != 30 && v20 != 2)
          return 0;
        if (v17 != v20 || v19 != 2 * v18)
          return 0;
        v21 = 0;
        result = 1;
        break;
      default:
        return result;
    }
    while (((*(unsigned __int8 *)(a2 + 44 + v21) ^ *((unsigned __int8 *)a1 + v21 + 44)) & *(unsigned __int8 *)(a2 + 44 + v18 + v21)) == 0)
    {
      if (v18 == ++v21)
        return result;
    }
  }
  return 0;
}

uint64_t x509_constraints_check(_QWORD *a1, uint64_t a2, uint64_t a3, int *a4)
{
  uint64_t v4;
  uint64_t v7;
  uint64_t v8;
  int *v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  uint64_t *v14;
  int *v15;
  _DWORD *v16;
  uint64_t result;
  int v18;

  v4 = a1[1];
  if (!v4)
    return 1;
  v7 = 0;
  v8 = *(_QWORD *)(a3 + 8);
  while (!v8)
  {
LABEL_7:
    v12 = *(_QWORD *)(a2 + 8);
    if (v12)
    {
      v13 = 0;
      v14 = *(uint64_t **)a2;
      v15 = *(int **)(*a1 + 8 * v7);
      while (1)
      {
        v16 = (_DWORD *)*v14;
        if (x509_constraints_match(v15, *v14))
          break;
        if (*v16 == *v15)
          ++v13;
        ++v14;
        if (!--v12)
        {
          if (!v13)
            break;
          v18 = 47;
          goto LABEL_17;
        }
      }
    }
    if (++v7 == v4)
      return 1;
  }
  v9 = *(int **)(*a1 + 8 * v7);
  v10 = *(uint64_t **)a3;
  v11 = v8;
  while (!x509_constraints_match(v9, *v10))
  {
    ++v10;
    if (!--v11)
      goto LABEL_7;
  }
  v18 = 48;
LABEL_17:
  result = 0;
  *a4 = v18;
  return result;
}

uint64_t x509_constraints_chain(const STACK *a1, int *a2, int *a3)
{
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  _QWORD *v9;
  char *v10;
  unint64_t v11;
  int v12;
  char *v13;
  uint64_t v14;
  _QWORD *v15;
  _QWORD *v16;
  _QWORD *v17;
  _QWORD *v18;
  uint64_t v19;
  int v21;
  int v22;

  v22 = 1;
  if (!a1)
  {
    LODWORD(v7) = 0;
    goto LABEL_21;
  }
  v6 = sk_num(a1);
  v7 = v6;
  if (!(_DWORD)v6)
  {
LABEL_21:
    v9 = 0;
LABEL_22:
    *a2 = v22;
    *a3 = v7;
    goto LABEL_23;
  }
  if ((_DWORD)v6 == 1)
    return v7;
  v8 = malloc_type_calloc(1uLL, 0x20uLL, 0x1080040ABB4582EuLL);
  v9 = v8;
  if (!v8)
  {
    LODWORD(v7) = 0;
    v22 = 17;
    goto LABEL_22;
  }
  v8[3] = 512;
  v10 = sk_value(a1, 0);
  if (!v10 || !x509_constraints_extract_names((uint64_t)v9, (uint64_t)v10, 1, &v22))
  {
    LODWORD(v7) = 0;
    goto LABEL_22;
  }
  if ((int)v7 < 2)
  {
    v19 = 1;
    goto LABEL_24;
  }
  v11 = 0;
  v12 = 1;
  while (1)
  {
    v13 = sk_value(a1, v12);
    if (!v13)
      goto LABEL_31;
    v14 = (uint64_t)v13;
    if (!*((_QWORD *)v13 + 15))
      goto LABEL_17;
    v15 = malloc_type_calloc(1uLL, 0x20uLL, 0x1080040ABB4582EuLL);
    if (!v15)
    {
      v22 = 17;
LABEL_31:
      LODWORD(v7) = v12;
      goto LABEL_22;
    }
    v16 = v15;
    v15[3] = 512;
    v17 = malloc_type_calloc(1uLL, 0x20uLL, 0x1080040ABB4582EuLL);
    if (!v17)
    {
      v22 = 17;
      *a2 = 17;
      *a3 = v12;
      goto LABEL_35;
    }
    v18 = v17;
    v17[3] = 512;
    if (!x509_constraints_extract_constraints(v14, (uint64_t)v16, (uint64_t)v17, &v22))
      goto LABEL_29;
    v11 += v16[1] + v18[1];
    if (v11 >= 0x201)
      break;
    if (!x509_constraints_check(v9, (uint64_t)v16, (uint64_t)v18, &v22))
    {
LABEL_29:
      v21 = v22;
      goto LABEL_34;
    }
    x509_constraints_names_clear((uint64_t)v18);
    free(v18);
    x509_constraints_names_clear((uint64_t)v16);
    free(v16);
LABEL_17:
    if (!x509_constraints_extract_names((uint64_t)v9, v14, 0, &v22))
      goto LABEL_31;
    ++v12;
    v19 = 1;
    if ((_DWORD)v7 == v12)
      goto LABEL_24;
  }
  v21 = 17;
  v22 = 17;
LABEL_34:
  *a2 = v21;
  *a3 = v12;
  x509_constraints_names_clear((uint64_t)v18);
  free(v18);
LABEL_35:
  x509_constraints_names_clear((uint64_t)v16);
  free(v16);
LABEL_23:
  v19 = 0;
  v7 = 0;
  if (v9)
  {
LABEL_24:
    x509_constraints_names_clear((uint64_t)v9);
    free(v9);
    return v19;
  }
  return v7;
}

uint64_t sk_X509_POLICY_NODE_delete_if (STACK *a1, unsigned int (*a2)(char *, uint64_t), uint64_t a3)
{
  uint64_t result;
  int v7;
  int v8;
  char *v9;

  result = sk_num(a1);
  if ((int)result < 1)
  {
    v8 = 0;
  }
  else
  {
    v7 = 0;
    v8 = 0;
    do
    {
      v9 = sk_value(a1, v7);
      if (!a2(v9, a3))
        a1->data[v8++] = v9;
      ++v7;
      result = sk_num(a1);
    }
    while (v7 < (int)result);
  }
  a1->num = v8;
  return result;
}

int X509_policy_check(X509_POLICY_TREE **ptree, int *pexplicit_policy, STACK *certs, STACK *policy_oids, unsigned int flags)
{
  STACK *v5;
  __int16 v6;
  X509_POLICY_TREE **v8;
  int v9;
  int v10;
  int v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  STACK *v15;
  STACK **v16;
  int v17;
  X509 *v18;
  uint64_t ex_pathlen;
  STACK **v20;
  BOOL v21;
  const STACK *ext_d2i;
  CERTIFICATEPOLICIES *v23;
  X509_POLICY_TREE **v24;
  STACK *v25;
  STACK *v26;
  int v27;
  int v28;
  char *v29;
  char *v30;
  int v31;
  BOOL v32;
  STACK *v33;
  char v34;
  int v35;
  char *v36;
  char *v37;
  int v38;
  char *v39;
  int v40;
  unint64_t v41;
  const STACK *v42;
  STACK *v43;
  STACK *v44;
  STACK **v45;
  int v46;
  const ASN1_OBJECT **v47;
  int v48;
  const ASN1_OBJECT *v49;
  char *v50;
  uint64_t *v51;
  char *v52;
  int v53;
  char *v54;
  const ASN1_OBJECT **v55;
  POLICY_MAPPING *v56;
  POLICY_MAPPING *v57;
  ASN1_OBJECT *v58;
  STACK **v59;
  char *v60;
  int v61;
  char *v62;
  uint64_t *v63;
  uint64_t *v64;
  uint64_t v65;
  int v66;
  ASN1_INTEGER *v67;
  ASN1_INTEGER *v68;
  int v69;
  BOOL v70;
  STACK *v71;
  STACK *v73;
  STACK *v74;
  STACK *v75;
  char v76;
  char v77;
  int v78;
  STACK *st;
  int v80;
  unint64_t v81;
  unint64_t v82;
  unint64_t v83;
  int crit;

  v5 = policy_oids;
  v6 = (__int16)certs;
  v8 = ptree;
  *(_QWORD *)&policy_oids->num = 0;
  v9 = sk_num((const STACK *)ptree);
  v10 = v9 - 2;
  if (v9 < 2)
    return 0;
  v12 = (v9 + 1);
  if ((v6 & 0x100) != 0)
    v13 = 0;
  else
    v13 = (v9 + 1);
  if ((v6 & 0x200) != 0)
    v14 = 0;
  else
    v14 = (v9 + 1);
  v82 = v14;
  v83 = v13;
  if ((v6 & 0x400) != 0)
    v12 = 0;
  v81 = v12;
  v15 = sk_new_null();
  if (!v15)
  {
LABEL_144:
    v16 = 0;
LABEL_145:
    v71 = 0;
    goto LABEL_146;
  }
  v74 = (STACK *)pexplicit_policy;
  v16 = 0;
  v17 = v10;
  v78 = v10;
  while (2)
  {
    v18 = (X509 *)sk_value((const STACK *)v8, v17);
    if (!x509v3_cache_extensions((uint64_t)v18))
      goto LABEL_145;
    ex_pathlen = v18->ex_pathlen;
    if (!v16)
    {
      if (v17 != v10)
        goto LABEL_144;
      v20 = x509_policy_level_new();
      v16 = v20;
      if (!v20)
        goto LABEL_145;
      *((_DWORD *)v20 + 2) = 1;
    }
    v80 = v17;
    if (v82)
    {
      v21 = 1;
    }
    else if (v17)
    {
      v21 = (ex_pathlen & 0x20) != 0;
    }
    else
    {
      v21 = 0;
    }
    crit = 0;
    ext_d2i = (const STACK *)X509_get_ext_d2i(v18, 89, &crit, 0);
    if (!ext_d2i)
    {
      if (crit == -1)
      {
        *((_DWORD *)v16 + 2) = 0;
        if (sk_num(*v16) >= 1)
        {
          v38 = 0;
          do
          {
            v39 = sk_value(*v16, v38);
            x509_policy_node_free((uint64_t)v39);
            ++v38;
          }
          while (v38 < sk_num(*v16));
        }
        sk_zero(*v16);
        goto LABEL_58;
      }
      goto LABEL_149;
    }
    v23 = (CERTIFICATEPOLICIES *)ext_d2i;
    if (!sk_num(ext_d2i))
    {
      ERR_put_error(11, 4095, 201, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_policy.c", 377);
LABEL_154:
      v33 = 0;
      goto LABEL_148;
    }
    sk_set_cmp_func(v23, (int (__cdecl *)(const char *const *, const char *const *))policyinfo_cmp);
    sk_sort(v23);
    if (sk_num(v23) < 1)
    {
      v31 = *((_DWORD *)v16 + 2);
LABEL_54:
      if (sk_is_sorted(v23))
      {
        sk_X509_POLICY_NODE_delete_if (*v16, (unsigned int (*)(char *, uint64_t))delete_if_not_in_policies, (uint64_t)v23);
        *((_DWORD *)v16 + 2) = 0;
        if (!v31)
          goto LABEL_56;
LABEL_37:
        v33 = sk_new_null();
        if (v33)
        {
          v34 = ex_pathlen;
          if (sk_num(v23) < 1)
          {
LABEL_46:
            LOBYTE(ex_pathlen) = v34;
            v10 = v78;
            if (x509_policy_level_add_nodes(v16, v33))
              goto LABEL_57;
          }
          else
          {
            v35 = 0;
            while (1)
            {
              v36 = sk_value(v23, v35);
              if (OBJ_obj2nid(*(const ASN1_OBJECT **)v36) != 746)
              {
                if (!sk_is_sorted(*v16))
                  goto LABEL_148;
                if (!x509_policy_level_find(v16, *(_QWORD *)v36))
                {
                  v37 = (char *)x509_policy_node_new(*(const ASN1_OBJECT **)v36);
                  if (!v37 || !sk_push(v33, v37))
                    break;
                }
              }
              if (++v35 >= sk_num(v23))
                goto LABEL_46;
            }
            x509_policy_node_free((uint64_t)v37);
          }
        }
        goto LABEL_148;
      }
      goto LABEL_154;
    }
    v76 = ex_pathlen;
    v24 = v8;
    v25 = v5;
    v26 = v15;
    v27 = 0;
    v28 = 0;
    do
    {
      v29 = sk_value(v23, v27);
      if (OBJ_obj2nid(*(const ASN1_OBJECT **)v29) == 746)
        v28 = 1;
      if (v27)
      {
        v30 = sk_value(v23, v27 - 1);
        if (!OBJ_cmp(*(const ASN1_OBJECT **)v30, *(const ASN1_OBJECT **)v29))
        {
          ERR_put_error(11, 4095, 201, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_policy.c", 395);
          v33 = 0;
          v15 = v26;
          v5 = v25;
LABEL_148:
          sk_pop_free(v33, (void (__cdecl *)(void *))x509_policy_node_free);
          CERTIFICATEPOLICIES_free(v23);
LABEL_149:
          v71 = 0;
          *(_QWORD *)&v5->num = v18;
          v11 = 42;
          goto LABEL_150;
        }
      }
      ++v27;
    }
    while (v27 < sk_num(v23));
    v31 = *((_DWORD *)v16 + 2);
    if (v28)
      v32 = v21;
    else
      v32 = 0;
    v15 = v26;
    v5 = v25;
    v8 = v24;
    v10 = v78;
    LOBYTE(ex_pathlen) = v76;
    if (!v32)
      goto LABEL_54;
    if (v31)
      goto LABEL_37;
LABEL_56:
    v33 = 0;
LABEL_57:
    sk_pop_free(v33, (void (__cdecl *)(void *))x509_policy_node_free);
    CERTIFICATEPOLICIES_free(v23);
LABEL_58:
    v40 = v80;
    if (!v83 && !*((_DWORD *)v16 + 2) && !sk_num(*v16))
    {
      v71 = 0;
LABEL_167:
      v11 = 43;
      goto LABEL_150;
    }
    if (!sk_push(v15, (char *)v16))
      goto LABEL_145;
    if (!v80)
    {
      v45 = 0;
      goto LABEL_122;
    }
    v75 = v15;
    v41 = v81;
    crit = 0;
    v42 = (const STACK *)X509_get_ext_d2i(v18, 747, &crit, 0);
    v43 = (STACK *)v42;
    if (!v42)
    {
      st = 0;
      v44 = 0;
      v45 = 0;
      if (crit != -1)
        goto LABEL_119;
    }
    if (!v42)
    {
LABEL_93:
      v43 = sk_new_null();
      st = 0;
      v44 = 0;
      v45 = 0;
      if (!v43)
        goto LABEL_119;
      goto LABEL_94;
    }
    if (!sk_num(v42))
    {
      ERR_put_error(11, 4095, 201, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_policy.c", 532);
LABEL_89:
      st = 0;
      v45 = 0;
      v44 = v43;
      goto LABEL_119;
    }
    v77 = ex_pathlen;
    if (sk_num(v43) >= 1)
    {
      v46 = 0;
      while (1)
      {
        v47 = (const ASN1_OBJECT **)sk_value(v43, v46);
        if (OBJ_obj2nid(*v47) == 746 || OBJ_obj2nid(v47[1]) == 746)
          break;
        if (++v46 >= sk_num(v43))
          goto LABEL_72;
      }
LABEL_90:
      st = 0;
LABEL_117:
      v45 = 0;
      goto LABEL_118;
    }
LABEL_72:
    sk_set_cmp_func(v43, (int (__cdecl *)(const char *const *, const char *const *))compare_issuer_policy);
    sk_sort(v43);
    if (!v41)
    {
      LOBYTE(ex_pathlen) = v77;
      if (!sk_is_sorted(v43))
        goto LABEL_89;
      sk_X509_POLICY_NODE_delete_if (*v16, (unsigned int (*)(char *, uint64_t))delete_if_mapped, (uint64_t)v43);
      sk_pop_free(v43, (void (__cdecl *)(void *))POLICY_MAPPING_free);
      goto LABEL_93;
    }
    st = sk_new_null();
    if (!st)
      goto LABEL_90;
    if (sk_num(v43) >= 1)
    {
      v48 = 0;
      v49 = 0;
      while (1)
      {
        v50 = sk_value(v43, v48);
        v51 = (uint64_t *)v50;
        if (v49 && !OBJ_cmp(*(const ASN1_OBJECT **)v50, v49))
          goto LABEL_84;
        v49 = (const ASN1_OBJECT *)*v51;
        if (!sk_is_sorted(*v16))
          goto LABEL_117;
        v52 = x509_policy_level_find(v16, *v51);
        if (v52)
          goto LABEL_83;
        if (*((_DWORD *)v16 + 2))
          break;
LABEL_84:
        if (++v48 >= sk_num(v43))
          goto LABEL_85;
      }
      v52 = (char *)x509_policy_node_new((const ASN1_OBJECT *)*v51);
      if (!v52 || !sk_push(st, v52))
      {
        x509_policy_node_free((uint64_t)v52);
        goto LABEL_117;
      }
LABEL_83:
      *((_DWORD *)v52 + 4) = 1;
      goto LABEL_84;
    }
LABEL_85:
    if (!x509_policy_level_add_nodes(v16, st))
      goto LABEL_117;
    LOBYTE(ex_pathlen) = v77;
LABEL_94:
    v77 = ex_pathlen;
    if (sk_num(*v16) >= 1)
    {
      v53 = 0;
      while (1)
      {
        v54 = sk_value(*v16, v53);
        if (!*((_DWORD *)v54 + 4))
        {
          v55 = (const ASN1_OBJECT **)v54;
          v56 = POLICY_MAPPING_new();
          if (!v56)
            goto LABEL_117;
          v57 = v56;
          v56->issuerDomainPolicy = OBJ_dup(*v55);
          v58 = OBJ_dup(*v55);
          v57->subjectDomainPolicy = v58;
          if (!v57->issuerDomainPolicy || !v58 || !sk_push(v43, (char *)v57))
            break;
        }
        if (++v53 >= sk_num(*v16))
          goto LABEL_102;
      }
      POLICY_MAPPING_free(v57);
      goto LABEL_117;
    }
LABEL_102:
    sk_set_cmp_func(v43, (int (__cdecl *)(const char *const *, const char *const *))compare_subject_policy);
    sk_sort(v43);
    v59 = x509_policy_level_new();
    v45 = v59;
    if (!v59)
      goto LABEL_118;
    *((_DWORD *)v59 + 2) = *((_DWORD *)v16 + 2);
    if (sk_num(v43) < 1)
    {
LABEL_115:
      sk_sort(*v45);
      LOBYTE(ex_pathlen) = v77;
      goto LABEL_120;
    }
    v60 = 0;
    v61 = 0;
    while (2)
    {
      v62 = sk_value(v43, v61);
      if (!*((_DWORD *)v16 + 2))
      {
        if (!sk_is_sorted(*v16))
          goto LABEL_118;
        if (!x509_policy_level_find(v16, *(_QWORD *)v62))
        {
LABEL_114:
          if (++v61 >= sk_num(v43))
            goto LABEL_115;
          continue;
        }
      }
      break;
    }
    if (v60 && !OBJ_cmp(*(const ASN1_OBJECT **)v60, *((const ASN1_OBJECT **)v62 + 1))
      || (v60 = (char *)x509_policy_node_new(*((const ASN1_OBJECT **)v62 + 1))) != 0 && sk_push(*v45, v60))
    {
      if (!sk_push(*((STACK **)v60 + 1), *(char **)v62))
        goto LABEL_118;
      *(_QWORD *)v62 = 0;
      goto LABEL_114;
    }
    x509_policy_node_free((uint64_t)v60);
LABEL_118:
    v44 = v43;
    LOBYTE(ex_pathlen) = v77;
LABEL_119:
    x509_policy_level_free(v45);
    v45 = 0;
    v43 = v44;
LABEL_120:
    sk_pop_free(v43, (void (__cdecl *)(void *))POLICY_MAPPING_free);
    sk_pop_free(st, (void (__cdecl *)(void *))x509_policy_node_free);
    v15 = v75;
    if (!v45)
    {
      v16 = 0;
      goto LABEL_149;
    }
    v16 = v45;
    v40 = v80;
    if ((ex_pathlen & 0x20) == 0)
    {
LABEL_122:
      if (v83)
        --v83;
      if (v81)
        --v81;
      if (v82)
        --v82;
      v16 = v45;
    }
    crit = 0;
    v63 = (uint64_t *)X509_get_ext_d2i(v18, 401, &crit, 0);
    v64 = v63;
    if (!v63 && crit != -1)
      goto LABEL_149;
    if (!v63)
      goto LABEL_136;
    v65 = *v63;
    if (!*v64 && !v64[1])
    {
      ERR_put_error(11, 4095, 201, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_policy.c", 741);
LABEL_162:
      POLICY_CONSTRAINTS_free((POLICY_CONSTRAINTS *)v64);
      goto LABEL_149;
    }
    if (!apply_skip_certs(v65, &v83))
      goto LABEL_162;
    v66 = apply_skip_certs(v64[1], &v81);
    POLICY_CONSTRAINTS_free((POLICY_CONSTRAINTS *)v64);
    if (!v66)
      goto LABEL_149;
LABEL_136:
    v67 = (ASN1_INTEGER *)X509_get_ext_d2i(v18, 748, &crit, 0);
    v68 = v67;
    if (!v67 && crit != -1)
      goto LABEL_149;
    v69 = apply_skip_certs((uint64_t)v67, &v82);
    ASN1_INTEGER_free(v68);
    if (!v69)
      goto LABEL_149;
    v70 = __OFSUB__(v40, 1);
    v17 = v40 - 1;
    if (v17 < 0 == v70)
      continue;
    break;
  }
  if (v83)
  {
    v71 = 0;
    goto LABEL_166;
  }
  if (!v74)
  {
    v71 = 0;
LABEL_165:
    if (has_explicit_policy(v15, v71))
    {
LABEL_166:
      v11 = 0;
      goto LABEL_150;
    }
    goto LABEL_167;
  }
  v73 = sk_dup(v74);
  v71 = v73;
  if (v73)
  {
    sk_set_cmp_func(v73, (int (__cdecl *)(const char *const *, const char *const *))asn1_object_cmp);
    sk_sort(v71);
    goto LABEL_165;
  }
LABEL_146:
  v11 = 17;
LABEL_150:
  x509_policy_level_free(v16);
  sk_free(v71);
  sk_pop_free(v15, (void (__cdecl *)(void *))x509_policy_level_free);
  return v11;
}

STACK **x509_policy_level_new()
{
  STACK **v0;
  STACK *v1;

  v0 = (STACK **)malloc_type_calloc(1uLL, 0x10uLL, 0x10200403A5D3213uLL);
  if (!v0
    || (v1 = sk_new((int (__cdecl *)(const char *const *, const char *const *))x509_policy_node_cmp), (*v0 = v1) == 0))
  {
    x509_policy_level_free(v0);
    return 0;
  }
  return v0;
}

uint64_t asn1_object_cmp(const ASN1_OBJECT **a1, const ASN1_OBJECT **a2)
{
  return OBJ_cmp(*a1, *a2);
}

uint64_t has_explicit_policy(const STACK *a1, STACK *st)
{
  uint64_t result;
  int v5;
  int v6;
  char *v7;
  char *v8;
  int v9;
  int v10;
  char *v11;
  int v12;
  char *v13;
  int v14;
  char *v15;
  char *v16;
  int v17;
  char *v18;
  const STACK **v19;
  int v20;
  char *v21;
  char *v22;
  int v23;
  BOOL v24;

  result = sk_is_sorted(st);
  if (!(_DWORD)result)
    return result;
  v5 = sk_num(a1);
  v6 = v5 - 1;
  v7 = sk_value(a1, v5 - 1);
  v8 = v7;
  if (!*((_DWORD *)v7 + 2))
  {
    result = sk_num(*(const STACK **)v7);
    if (!(_DWORD)result)
      return result;
  }
  v9 = sk_num(st);
  if (sk_num(st) >= 1)
  {
    v10 = 0;
    do
    {
      v11 = sk_value(st, v10);
      if (OBJ_obj2nid((const ASN1_OBJECT *)v11) == 746)
        return 1;
    }
    while (++v10 < sk_num(st));
  }
  if (v9 < 1 || *((_DWORD *)v8 + 2))
    return 1;
  if (sk_num(*(const STACK **)v8) >= 1)
  {
    v12 = 0;
    do
      *((_DWORD *)sk_value(*(const STACK **)v8, v12++) + 5) = 1;
    while (v12 < sk_num(*(const STACK **)v8));
  }
  if (v5 < 1)
    return 0;
  do
  {
    v13 = sk_value(a1, v6);
    if (sk_num(*(const STACK **)v13) > 0)
    {
      v14 = 0;
      while (1)
      {
        v15 = sk_value(*(const STACK **)v13, v14);
        if (*((_DWORD *)v15 + 5))
        {
          v16 = v15;
          if (sk_num(*((const STACK **)v15 + 1)))
          {
            if (v6 >= 1)
            {
              v17 = sk_num(*((const STACK **)v16 + 1));
              v18 = sk_value(a1, v6 - 1);
              if (v17 >= 1)
              {
                v19 = (const STACK **)v18;
                v20 = 0;
                do
                {
                  result = sk_is_sorted(*v19);
                  if (!(_DWORD)result)
                    return result;
                  v21 = sk_value(*((const STACK **)v16 + 1), v20);
                  v22 = x509_policy_level_find((STACK **)v19, (uint64_t)v21);
                  if (v22)
                    *((_DWORD *)v22 + 5) = 1;
                }
                while (v17 != ++v20);
              }
            }
          }
          else if ((sk_find(st, *(char **)v16) & 0x80000000) == 0)
          {
            return 1;
          }
        }
        if (++v14 >= sk_num(*(const STACK **)v13))
        {
          v23 = v6 - 1;
          goto LABEL_32;
        }
      }
    }
    v23 = v6 - 1;
LABEL_32:
    result = 0;
    v24 = v6 <= 0;
    v6 = v23;
  }
  while (!v24);
  return result;
}

void x509_policy_level_free(STACK **a1)
{
  if (a1)
  {
    sk_pop_free(*a1, (void (__cdecl *)(void *))x509_policy_node_free);
    free(a1);
  }
}

uint64_t x509_policy_node_cmp(const ASN1_OBJECT ***a1, const ASN1_OBJECT ***a2)
{
  return OBJ_cmp(**a1, **a2);
}

uint64_t policyinfo_cmp(const ASN1_OBJECT ***a1, const ASN1_OBJECT ***a2)
{
  return OBJ_cmp(**a1, **a2);
}

uint64_t delete_if_not_in_policies(_QWORD *a1, STACK *st)
{
  _QWORD v4[2];

  v4[0] = *a1;
  v4[1] = 0;
  if ((sk_find(st, (char *)v4) & 0x80000000) == 0)
    return 0;
  x509_policy_node_free((uint64_t)a1);
  return 1;
}

char *x509_policy_level_find(STACK **a1, uint64_t a2)
{
  int v3;
  char data[8];
  uint64_t v6;
  uint64_t v7;

  v6 = 0;
  v7 = 0;
  *(_QWORD *)data = a2;
  v3 = sk_find(*a1, data);
  if (v3 < 0)
    return 0;
  else
    return sk_value(*a1, v3);
}

_QWORD *x509_policy_node_new(const ASN1_OBJECT *a1)
{
  _QWORD *v2;
  ASN1_OBJECT *v3;
  STACK *v4;

  if (OBJ_obj2nid(a1) == 746)
  {
    v2 = 0;
LABEL_6:
    x509_policy_node_free((uint64_t)v2);
    return 0;
  }
  v2 = malloc_type_calloc(1uLL, 0x18uLL, 0x102004062D53EE8uLL);
  if (!v2)
    goto LABEL_6;
  v3 = OBJ_dup(a1);
  *v2 = v3;
  if (!v3)
    goto LABEL_6;
  v4 = sk_new_null();
  v2[1] = v4;
  if (!v4)
    goto LABEL_6;
  return v2;
}

void x509_policy_node_free(uint64_t a1)
{
  if (a1)
  {
    ASN1_OBJECT_free(*(ASN1_OBJECT **)a1);
    sk_pop_free(*(STACK **)(a1 + 8), (void (__cdecl *)(void *))ASN1_OBJECT_free);
    free((void *)a1);
  }
}

uint64_t x509_policy_level_add_nodes(STACK **a1, STACK *a2)
{
  int v4;
  char *v5;
  uint64_t result;

  if (sk_num(a2) < 1)
  {
LABEL_5:
    sk_sort(*a1);
    return 1;
  }
  else
  {
    v4 = 0;
    while (1)
    {
      v5 = sk_value(a2, v4);
      result = sk_push(*a1, v5);
      if (!(_DWORD)result)
        break;
      sk_set(a2, v4++, 0);
      if (v4 >= sk_num(a2))
        goto LABEL_5;
    }
  }
  return result;
}

uint64_t compare_issuer_policy(const ASN1_OBJECT ***a1, const ASN1_OBJECT ***a2)
{
  return OBJ_cmp(**a1, **a2);
}

uint64_t delete_if_mapped(_QWORD *a1, STACK *st)
{
  _QWORD v4[2];

  v4[0] = *a1;
  v4[1] = 0;
  if (sk_find(st, (char *)v4) < 0)
    return 0;
  x509_policy_node_free((uint64_t)a1);
  return 1;
}

uint64_t compare_subject_policy(uint64_t a1, uint64_t a2)
{
  return OBJ_cmp(*(const ASN1_OBJECT **)(*(_QWORD *)a1 + 8), *(const ASN1_OBJECT **)(*(_QWORD *)a2 + 8));
}

uint64_t apply_skip_certs(uint64_t a1, unint64_t *a2)
{
  unint64_t v4;

  if (!a1)
    return 1;
  if ((*(_BYTE *)(a1 + 5) & 1) != 0)
  {
    ERR_put_error(11, 4095, 201, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_policy.c", 702);
    return 0;
  }
  else
  {
    v4 = 0;
    if (ASN1_INTEGER_get_uint64(&v4, (unsigned int *)a1))
    {
      if (v4 < *a2)
        *a2 = v4;
    }
    ERR_clear_error();
    return 1;
  }
}

BIO *cms_EncryptedContent_init_bio(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  BIO_METHOD *v4;
  BIO *v5;
  BIO *v6;
  const unsigned __int8 **v7;
  const EVP_CIPHER *v8;
  const EVP_CIPHER *v9;
  int v10;
  int v11;
  const unsigned __int8 *v12;
  int v13;
  const char *v14;
  const EVP_CIPHER *cipherbyname;
  size_t v16;
  int v17;
  int v18;
  void *v19;
  char v20;
  uint64_t v21;
  ASN1_TYPE *v22;
  ASN1_TYPE *v23;
  int v24;
  int v25;
  EVP_CIPHER_CTX *ctx;
  _BYTE __buf[16];
  uint64_t v29;

  v29 = *MEMORY[0x24BDAC8D0];
  v2 = *(_QWORD *)(a1 + 8);
  v3 = *(_QWORD *)(a1 + 24);
  v4 = BIO_f_cipher();
  v5 = BIO_new(v4);
  v6 = v5;
  if (!v5)
  {
    ERR_put_error(46, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/cms/cms_enc.c", 89);
    return v6;
  }
  ctx = 0;
  BIO_ctrl(v5, 129, 0, &ctx);
  if (!v3)
  {
    v13 = OBJ_obj2nid(*(const ASN1_OBJECT **)v2);
    v14 = OBJ_nid2sn(v13);
    cipherbyname = EVP_get_cipherbyname(v14);
    if (!cipherbyname)
    {
      v17 = 148;
      v18 = 106;
      goto LABEL_41;
    }
    if (EVP_CipherInit_ex(ctx, cipherbyname, 0, 0, 0, 0) > 0)
    {
      if (EVP_CIPHER_asn1_to_param(ctx, *(ASN1_TYPE **)(v2 + 8)) > 0)
      {
        v12 = 0;
        v16 = EVP_CIPHER_CTX_key_length(ctx);
        goto LABEL_29;
      }
      v17 = 102;
      v18 = 126;
LABEL_41:
      ERR_put_error(46, 4095, v17, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/cms/cms_enc.c", v18);
      v16 = 0;
      v19 = 0;
      goto LABEL_45;
    }
LABEL_13:
    v17 = 101;
    v18 = 112;
    goto LABEL_41;
  }
  v7 = (const unsigned __int8 **)(a1 + 32);
  v8 = *(const EVP_CIPHER **)(a1 + 24);
  if (*(_QWORD *)(a1 + 32))
    *(_QWORD *)(a1 + 24) = 0;
  if (EVP_CipherInit_ex(ctx, v8, 0, 0, 0, v3 != 0) < 1)
    goto LABEL_13;
  v9 = EVP_CIPHER_CTX_cipher(ctx);
  v10 = EVP_CIPHER_type(v9);
  *(_QWORD *)v2 = OBJ_nid2obj(v10);
  v11 = EVP_CIPHER_CTX_iv_length(ctx);
  if (v11 < 1)
  {
    v12 = 0;
  }
  else
  {
    v12 = __buf;
    arc4random_buf(__buf, v11);
  }
  v16 = EVP_CIPHER_CTX_key_length(ctx);
  if (*v7)
    goto LABEL_16;
LABEL_29:
  v19 = malloc_type_malloc(v16, 0xC30DF115uLL);
  if (!v19)
  {
    v24 = 65;
    v25 = 134;
    goto LABEL_44;
  }
  if (EVP_CIPHER_CTX_rand_key(ctx, (unsigned __int8 *)v19) < 1)
  {
LABEL_45:
    freezero(*(void **)(a1 + 32), *(_QWORD *)(a1 + 40));
    *(_QWORD *)(a1 + 32) = 0;
    freezero(v19, v16);
    BIO_free(v6);
    return 0;
  }
  v7 = (const unsigned __int8 **)(a1 + 32);
  if (*(_QWORD *)(a1 + 32))
    goto LABEL_17;
  *(_QWORD *)(a1 + 32) = v19;
  *(_QWORD *)(a1 + 40) = v16;
  if (v3)
  {
    v19 = 0;
    v20 = 0;
    goto LABEL_18;
  }
  ERR_clear_error();
LABEL_16:
  v19 = 0;
LABEL_17:
  v20 = 1;
LABEL_18:
  v21 = *(_QWORD *)(a1 + 40);
  if (v21 != v16 && !EVP_CIPHER_CTX_set_key_length(ctx, v21))
  {
    if (v3 || *(_DWORD *)(a1 + 48))
    {
      v24 = 118;
      v25 = 160;
      goto LABEL_44;
    }
    freezero(*(void **)(a1 + 32), *(_QWORD *)(a1 + 40));
    *(_QWORD *)(a1 + 32) = v19;
    *(_QWORD *)(a1 + 40) = v16;
    ERR_clear_error();
    v19 = 0;
  }
  if (EVP_CipherInit_ex(ctx, 0, 0, *v7, v12, v3 != 0) <= 0)
  {
    v24 = 101;
    v25 = 174;
LABEL_44:
    ERR_put_error(46, 4095, v24, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/cms/cms_enc.c", v25);
    goto LABEL_45;
  }
  if (v3)
  {
    v22 = ASN1_TYPE_new();
    *(_QWORD *)(v2 + 8) = v22;
    if (v22)
    {
      if (EVP_CIPHER_param_to_asn1(ctx, v22) > 0)
      {
        v23 = *(ASN1_TYPE **)(v2 + 8);
        if (v23->type == -1)
        {
          ASN1_TYPE_free(v23);
          *(_QWORD *)(v2 + 8) = 0;
        }
        goto LABEL_26;
      }
      v24 = 102;
      v25 = 184;
    }
    else
    {
      v24 = 65;
      v25 = 180;
    }
    goto LABEL_44;
  }
LABEL_26:
  if ((v20 & 1) != 0)
  {
    freezero(*(void **)(a1 + 32), *(_QWORD *)(a1 + 40));
    *(_QWORD *)(a1 + 32) = 0;
  }
  freezero(v19, v16);
  return v6;
}

uint64_t cms_EncryptedContent_init(ASN1_OBJECT **a1, ASN1_OBJECT *a2, const void *a3, ASN1_OBJECT *size)
{
  ASN1_OBJECT *v8;

  a1[3] = a2;
  if (a3)
  {
    v8 = (ASN1_OBJECT *)malloc_type_malloc((size_t)size, 0x87629521uLL);
    a1[4] = v8;
    if (!v8)
    {
      ERR_put_error(46, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/cms/cms_enc.c", 214);
      return 0;
    }
    memcpy(v8, a3, (size_t)size);
  }
  a1[5] = size;
  if (a2)
    *a1 = OBJ_nid2obj(21);
  return 1;
}

uint64_t CMS_EncryptedData_set1_key(uint64_t a1, ASN1_OBJECT *a2, const void *a3, ASN1_OBJECT *a4)
{
  ASN1_VALUE *v8;
  int v9;
  int v10;

  if (!a3 || !a4)
  {
    v9 = 130;
    v10 = 233;
    goto LABEL_7;
  }
  if (!a2)
  {
    if (OBJ_obj2nid(*(const ASN1_OBJECT **)a1) == 26)
      return cms_EncryptedContent_init(*(ASN1_OBJECT ***)(*(_QWORD *)(a1 + 8) + 8), a2, a3, a4);
    v9 = 122;
    v10 = 245;
LABEL_7:
    ERR_put_error(46, 4095, v9, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/cms/cms_enc.c", v10);
    return 0;
  }
  v8 = ASN1_item_new(&CMS_EncryptedData_it);
  *(_QWORD *)(a1 + 8) = v8;
  if (!v8)
  {
    v9 = 65;
    v10 = 239;
    goto LABEL_7;
  }
  *(_QWORD *)a1 = OBJ_nid2obj(26);
  **(_QWORD **)(a1 + 8) = 0;
  return cms_EncryptedContent_init(*(ASN1_OBJECT ***)(*(_QWORD *)(a1 + 8) + 8), a2, a3, a4);
}

BIO *cms_EncryptedData_init_bio(uint64_t a1)
{
  _QWORD *v1;
  uint64_t v2;

  v1 = *(_QWORD **)(a1 + 8);
  v2 = v1[1];
  if (*(_QWORD *)(v2 + 24) && v1[2])
    *v1 = 2;
  return cms_EncryptedContent_init_bio(v2);
}

uint64_t i2r_ocsp_crlid(int a1, ASN1_STRING **a2, BIO *bio, int a4)
{
  uint64_t v7;

  if (*a2
    && (BIO_printf(bio, "%*scrlUrl: ", a4, "") < 1 || !ASN1_STRING_print(bio, *a2) || BIO_write(bio, "\n", 1) < 1)
    || a2[1]
    && (BIO_printf(bio, "%*scrlNum: ", a4, "") < 1 || i2a_ASN1_INTEGER(bio, a2[1]) < 1 || BIO_write(bio, "\n", 1) < 1))
  {
    return 0;
  }
  if (!a2[2])
    return 1;
  if (BIO_printf(bio, "%*scrlTime: ", a4, "") < 1)
    return 0;
  if (!ASN1_GENERALIZEDTIME_print(bio, a2[2]))
    return 0;
  v7 = 1;
  if (BIO_write(bio, "\n", 1) <= 0)
    return 0;
  return v7;
}

BOOL i2r_ocsp_acutoff(int a1, ASN1_GENERALIZEDTIME *a2, BIO *bio, int a4)
{
  return BIO_printf(bio, "%*s", a4, "") >= 1 && ASN1_GENERALIZEDTIME_print(bio, a2) != 0;
}

BOOL i2r_object(int a1, ASN1_OBJECT *a2, BIO *bio, int a4)
{
  return BIO_printf(bio, "%*s", a4, "") >= 1 && i2a_ASN1_OBJECT(bio, a2) > 0;
}

ASN1_OCTET_STRING *d2i_ocsp_nonce(ASN1_OCTET_STRING **a1, const unsigned __int8 **a2, uint64_t len)
{
  ASN1_OCTET_STRING *v6;

  if ((a1 && (v6 = *a1) != 0 || (v6 = ASN1_OCTET_STRING_new()) != 0) && ASN1_OCTET_STRING_set(v6, *a2, len))
  {
    *a2 += len;
    if (a1)
      *a1 = v6;
  }
  else
  {
    if (!a1 || *a1 != v6)
      ASN1_OCTET_STRING_free(v6);
    ERR_put_error(39, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_ocsp.c", 318);
    return 0;
  }
  return v6;
}

uint64_t i2d_ocsp_nonce(const void **a1, void **a2)
{
  uint64_t result;

  result = *(unsigned int *)a1;
  if (a2)
  {
    memcpy(*a2, a1[1], (int)result);
    result = *(int *)a1;
    *a2 = (char *)*a2 + result;
  }
  return result;
}

BOOL i2r_ocsp_nonce(int a1, ASN1_STRING *a2, BIO *bio, int a4)
{
  return BIO_printf(bio, "%*s", a4, "") >= 1 && i2a_ASN1_STRING(bio, a2, 4) > 0;
}

uint64_t i2r_ocsp_nocheck()
{
  return 1;
}

uint64_t i2r_ocsp_serviceloc(int a1, uint64_t a2, BIO *bio, int a4)
{
  int v7;
  char *v8;

  if (BIO_printf(bio, "%*sIssuer: ", a4, "") >= 1 && X509_NAME_print_ex(bio, *(X509_NAME **)a2, 0, 0x82031FuLL) >= 1)
  {
    if (sk_num(*(const STACK **)(a2 + 8)) < 1)
      return 1;
    v7 = 0;
    while (1)
    {
      v8 = sk_value(*(const STACK **)(a2 + 8), v7);
      if (BIO_printf(bio, "\n%*s", 2 * a4, "") < 1
        || i2a_ASN1_OBJECT(bio, *(ASN1_OBJECT **)v8) < 1
        || BIO_puts(bio, " - ") < 1
        || GENERAL_NAME_print(bio, *((GENERAL_NAME **)v8 + 1)) <= 0)
      {
        break;
      }
      if (++v7 >= sk_num(*(const STACK **)(a2 + 8)))
        return 1;
    }
  }
  return 0;
}

unint64_t *idea_ofb64_encrypt(unint64_t *result, _BYTE *a2, uint64_t a3, unsigned int *a4, unsigned __int8 *a5, int *a6)
{
  int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  uint64_t v20;
  unint64_t *v22;
  int v23;
  char v24;
  uint64_t v25;
  uint64_t v26;
  unsigned int v27;
  unsigned int v28;
  uint64_t v29;

  v29 = *MEMORY[0x24BDAC8D0];
  v7 = *a6;
  v8 = *a5;
  v9 = a5[1];
  v10 = a5[2];
  v11 = a5[3];
  v12 = ((_DWORD)v8 << 24) | ((_DWORD)v9 << 16) | ((_DWORD)v10 << 8) | v11;
  v13 = a5[4];
  v14 = a5[5];
  v15 = a5[6];
  v16 = a5[7];
  v17 = ((_DWORD)v13 << 24) | ((_DWORD)v14 << 16) | ((_DWORD)v15 << 8) | v16;
  v25 = (v8 << 24) | (v9 << 16) | (v10 << 8) | v11;
  v26 = (v13 << 24) | (v14 << 16) | (v15 << 8) | v16;
  LOBYTE(v27) = v8;
  BYTE1(v27) = v9;
  BYTE2(v27) = v10;
  HIBYTE(v27) = v11;
  LOBYTE(v28) = v13;
  BYTE1(v28) = v14;
  BYTE2(v28) = v15;
  HIBYTE(v28) = v16;
  if (a3)
  {
    v20 = a3;
    v22 = result;
    v23 = 0;
    do
    {
      if (!v7)
      {
        result = idea_encrypt((unint64_t *)&v25, a4);
        v12 = v25;
        v17 = v26;
        v27 = bswap32(v25);
        v28 = bswap32(v26);
        ++v23;
      }
      v24 = *(_BYTE *)v22;
      v22 = (unint64_t *)((char *)v22 + 1);
      *a2++ = *((_BYTE *)&v27 + v7) ^ v24;
      v7 = (v7 + 1) & 7;
      --v20;
    }
    while (v20);
    if (v23)
    {
      *a5 = HIBYTE(v12);
      a5[1] = BYTE2(v12);
      a5[2] = BYTE1(v12);
      a5[3] = v12;
      a5[4] = HIBYTE(v17);
      a5[5] = BYTE2(v17);
      a5[6] = BYTE1(v17);
      a5[7] = v17;
    }
  }
  *a6 = v7;
  return result;
}

void ASN1_STRING_set_default_mask(unint64_t mask)
{
  global_mask = mask;
}

unint64_t ASN1_STRING_get_default_mask(void)
{
  return global_mask;
}

int ASN1_STRING_set_default_mask_asc(const char *p)
{
  unint64_t v2;
  const char *v3;
  int v4;
  int v5;
  int result;
  char *__endptr;

  if (strncmp(p, "MASK:", 5uLL))
  {
    if (!strcmp(p, "nombstr"))
    {
      v2 = -10241;
      goto LABEL_15;
    }
    if (!strcmp(p, "pkix"))
    {
      v2 = -5;
      goto LABEL_15;
    }
    if (!strcmp(p, "utf8only"))
    {
      v2 = 0x2000;
      goto LABEL_15;
    }
    if (!strcmp(p, "default"))
    {
      v2 = 0xFFFFFFFFLL;
LABEL_15:
      global_mask = v2;
      return 1;
    }
    return 0;
  }
  v4 = *((unsigned __int8 *)p + 5);
  v3 = p + 5;
  if (!v4)
    return 0;
  __endptr = 0;
  v5 = *__error();
  *__error() = 0;
  v2 = strtoul(v3, &__endptr, 0);
  if (*__error() != 34 || (result = 0, v2 != -1))
  {
    *__error() = v5;
    if (!*__endptr)
      goto LABEL_15;
    return 0;
  }
  return result;
}

ASN1_STRING *__cdecl ASN1_STRING_set_by_NID(ASN1_STRING **out, const unsigned __int8 *in, int inlen, int inform, int nid)
{
  ASN1_STRING **v8;
  ASN1_STRING_TABLE *v9;
  uint64_t v10;
  int v11;
  uint64_t v13;

  v13 = 0;
  if (out)
    v8 = out;
  else
    v8 = (ASN1_STRING **)&v13;
  v9 = ASN1_STRING_TABLE_get(nid);
  if (v9)
  {
    if ((v9->flags & 2) != 0)
      v10 = -1;
    else
      v10 = global_mask;
    v11 = ASN1_mbstring_ncopy(v8, in, inlen, inform, v10 & v9->mask, v9->minsize, v9->maxsize);
  }
  else
  {
    v11 = ASN1_mbstring_copy(v8, in, inlen, inform, global_mask & 0x2806);
  }
  if (v11 < 1)
    return 0;
  else
    return *v8;
}

ASN1_STRING_TABLE *__cdecl ASN1_STRING_TABLE_get(int nid)
{
  int v1;
  _OWORD v3[2];
  uint64_t v4;

  v4 = 0;
  memset(v3, 0, sizeof(v3));
  LODWORD(v3[0]) = nid;
  if (!stable)
    return (ASN1_STRING_TABLE *)OBJ_bsearch_((const char *)v3, "\r", 19, 40, (int (__cdecl *)(const void *, const void *))table_cmp_BSEARCH_CMP_FN);
  v1 = sk_find((STACK *)stable, (char *)v3);
  if (v1 < 0)
    return (ASN1_STRING_TABLE *)OBJ_bsearch_((const char *)v3, "\r", 19, 40, (int (__cdecl *)(const void *, const void *))table_cmp_BSEARCH_CMP_FN);
  else
    return (ASN1_STRING_TABLE *)sk_value((const STACK *)stable, v1);
}

int ASN1_STRING_TABLE_add(int a1, uint64_t a2, uint64_t a3, unint64_t a4, unint64_t a5)
{
  ASN1_STRING_TABLE *v10;
  ASN1_STRING_TABLE *v11;
  char *v12;
  _QWORD *p_nid;
  uint64_t v14;

  if (!stable)
  {
    stable = (uint64_t)sk_new((int (__cdecl *)(const char *const *, const char *const *))sk_table_cmp);
    if (!stable)
      goto LABEL_21;
  }
  v10 = ASN1_STRING_TABLE_get(a1);
  v11 = v10;
  if (!v10 || (v10->flags & 1) == 0)
  {
    v12 = (char *)malloc_type_calloc(1uLL, 0x28uLL, 0x1000040B4E0BC51uLL);
    if (v12)
    {
      p_nid = v12;
      if (sk_push((STACK *)stable, v12))
      {
        if (v11)
        {
          *(_DWORD *)p_nid = v11->nid;
          *(_OWORD *)(p_nid + 1) = *(_OWORD *)&v11->minsize;
          v14 = v11->flags | 1;
          p_nid[3] = v11->mask;
          p_nid[4] = v14;
          if (a2 < 0)
            goto LABEL_12;
        }
        else
        {
          *(_DWORD *)p_nid = a1;
          p_nid[1] = -1;
          p_nid[2] = -1;
          p_nid[4] = 1;
          if (a2 < 0)
            goto LABEL_12;
        }
        goto LABEL_11;
      }
      free(p_nid);
    }
    else
    {
      ERR_put_error(13, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/a_strnid.c", 281);
    }
LABEL_21:
    ERR_put_error(13, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/a_strnid.c", 310);
    return 0;
  }
  p_nid = &v10->nid;
  if ((a2 & 0x8000000000000000) == 0)
LABEL_11:
    p_nid[1] = a2;
LABEL_12:
  if ((a3 & 0x8000000000000000) == 0)
    p_nid[2] = a3;
  if (a4)
    p_nid[3] = a4;
  if (a5)
    p_nid[4] = a5 | 1;
  return 1;
}

void ASN1_STRING_TABLE_cleanup(void)
{
  STACK *v0;

  v0 = (STACK *)stable;
  if (stable)
  {
    stable = 0;
    sk_pop_free(v0, (void (__cdecl *)(void *))st_free);
  }
}

void st_free(void *a1)
{
  if ((*((_BYTE *)a1 + 32) & 1) != 0)
    free(a1);
}

uint64_t table_cmp_BSEARCH_CMP_FN(_DWORD *a1, _DWORD *a2)
{
  return (*a1 - *a2);
}

uint64_t sk_table_cmp(_DWORD **a1, _DWORD **a2)
{
  return (**a1 - **a2);
}

uint64_t ASN1_time_tm_cmp(_DWORD *a1, _DWORD *a2)
{
  int v2;
  int v3;
  int v4;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;

  v2 = a1[5];
  v3 = a2[5];
  if (v2 < v3)
    return 0xFFFFFFFFLL;
  if (v2 > v3)
    return 1;
  v4 = a1[4];
  v5 = a2[4];
  if (v4 < v5)
    return 0xFFFFFFFFLL;
  if (v4 > v5)
    return 1;
  v6 = a1[3];
  v7 = a2[3];
  if (v6 < v7)
    return 0xFFFFFFFFLL;
  if (v6 > v7)
    return 1;
  v8 = a1[2];
  v9 = a2[2];
  if (v8 < v9)
    return 0xFFFFFFFFLL;
  if (v8 > v9)
    return 1;
  v10 = a1[1];
  v11 = a2[1];
  if (v10 < v11)
    return 0xFFFFFFFFLL;
  if (v10 > v11)
    return 1;
  if (*a1 >= *a2)
    return *a1 > *a2;
  else
    return 0xFFFFFFFFLL;
}

uint64_t ASN1_time_tm_clamp_notafter()
{
  return 1;
}

ASN1_TIME *tm_to_gentime(_DWORD *a1, ASN1_TIME *a2)
{
  int v2;
  int v3;
  int v4;
  char *v7;

  v7 = 0;
  v2 = a1[5];
  if ((v2 - 8100) <= 0xFFFFD8EF)
  {
    v3 = 184;
    v4 = 89;
LABEL_9:
    ERR_put_error(13, 4095, v3, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/a_time_tm.c", v4);
    free(v7);
    return 0;
  }
  if (asprintf(&v7, "%04u%02u%02u%02u%02u%02uZ", v2 + 1900, a1[4] + 1, a1[3], a1[2], a1[1], *a1) == -1)
  {
    v7 = 0;
    v3 = 65;
    v4 = 97;
    goto LABEL_9;
  }
  if (!a2)
  {
    a2 = ASN1_TIME_new();
    if (!a2)
    {
      v3 = 65;
      v4 = 104;
      goto LABEL_9;
    }
  }
  free(a2->data);
  a2->data = (unsigned __int8 *)v7;
  *(_QWORD *)&a2->length = 0x180000000FLL;
  return a2;
}

ASN1_TIME *tm_to_utctime(_DWORD *a1, ASN1_TIME *a2)
{
  unsigned int v2;
  int v3;
  int v4;
  char *v7;

  v7 = 0;
  v2 = a1[5];
  if (v2 - 150 <= 0xFFFFFF9B)
  {
    v3 = 184;
    v4 = 128;
LABEL_11:
    ERR_put_error(13, 4095, v3, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/a_time_tm.c", v4);
    free(v7);
    return 0;
  }
  if (v2 >= 0x64)
    v2 -= 100;
  if (asprintf(&v7, "%02u%02u%02u%02u%02u%02uZ", v2, a1[4] + 1, a1[3], a1[2], a1[1], *a1) == -1)
  {
    v7 = 0;
    v3 = 65;
    v4 = 136;
    goto LABEL_11;
  }
  if (!a2)
  {
    a2 = ASN1_TIME_new();
    if (!a2)
    {
      v3 = 65;
      v4 = 143;
      goto LABEL_11;
    }
  }
  free(a2->data);
  a2->data = (unsigned __int8 *)v7;
  *(_QWORD *)&a2->length = 0x170000000DLL;
  return a2;
}

ASN1_TIME *tm_to_rfc5280_time(_DWORD *a1, ASN1_TIME *a2)
{
  unsigned int v2;

  v2 = a1[5];
  if (v2 - 8100 > 0xFFFFE08D)
  {
    if (v2 > 0x95)
      return tm_to_gentime(a1, a2);
    else
      return tm_to_utctime(a1, a2);
  }
  else
  {
    ERR_put_error(13, 4095, 184, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/a_time_tm.c", 167);
    return 0;
  }
}

uint64_t asn1_time_parse_cbs(_QWORD *a1, int a2, uint64_t a3)
{
  uint64_t result;
  int v6;
  int v7;
  int v8;
  unsigned int v9;
  unsigned int v10;
  int two_digit_value;
  int v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int u8;
  unsigned int v18;
  unint64_t v19;
  _BOOL4 v21;
  unint64_t v22;
  char v23;
  _QWORD v24[3];
  int v25;
  int v26;
  int v27;
  int v28;
  unsigned int v29;
  unsigned int v30;

  v25 = 0;
  memset(v24, 0, sizeof(v24));
  v23 = 0;
  CBS_dup(a1, v24);
  result = cbs_get_two_digit_value(v24, &v25);
  if (a2)
  {
    if (!(_DWORD)result)
      return result;
    v6 = v25;
    result = cbs_get_two_digit_value(v24, &v25);
    if (!(_DWORD)result)
      return result;
    v7 = v25 + 100 * v6;
  }
  else
  {
    if (!(_DWORD)result)
      return result;
    if (v25 >= 50)
      v8 = 1900;
    else
      v8 = 2000;
    v7 = v8 + v25;
    if (v8 + v25 > 2049)
      return 0;
  }
  v30 = 0;
  result = cbs_get_two_digit_value(v24, &v30);
  if (!(_DWORD)result)
    return result;
  v9 = v30;
  if (v30 - 13 < 0xFFFFFFF4)
    return 0;
  v29 = 0;
  result = cbs_get_two_digit_value(v24, &v29);
  if ((_DWORD)result)
  {
    v10 = v29;
    if ((int)v29 < 1)
      return 0;
    result = 0;
    if (v9 > 0xC)
      return result;
    if (((1 << v9) & 0x15AA) != 0)
    {
      if (v29 > 0x1F)
        return 0;
    }
    else if (((1 << v9) & 0xA50) != 0)
    {
      if (v29 >= 0x1F)
        return 0;
    }
    else
    {
      if (v9 != 2)
        return result;
      HIDWORD(v19) = -1030792151 * v7 + 85899344;
      LODWORD(v19) = HIDWORD(v19);
      v18 = v19 >> 2;
      v21 = (v7 & 3) == 0 && v18 > 0x28F5C28;
      HIDWORD(v22) = -1030792151 * v7 + 85899344;
      LODWORD(v22) = HIDWORD(v22);
      if ((v22 >> 4) < 0xA3D70B || v21)
      {
        if (v29 >= 0x1E)
          return 0;
      }
      else if (v29 >= 0x1D)
      {
        return 0;
      }
    }
    v28 = 0;
    two_digit_value = cbs_get_two_digit_value(v24, &v28);
    result = 0;
    if (two_digit_value)
    {
      v12 = v28;
      if (v28 <= 23)
      {
        v27 = 0;
        v13 = cbs_get_two_digit_value(v24, &v27);
        result = 0;
        if (v13)
        {
          v14 = v27;
          if (v27 <= 59)
          {
            v26 = 0;
            v15 = cbs_get_two_digit_value(v24, &v26);
            result = 0;
            if (v15)
            {
              v16 = v26;
              if (v26 <= 59)
              {
                u8 = CBS_get_u8(v24, &v23);
                result = 0;
                if (u8)
                {
                  if (v23 == 90)
                  {
                    if (!CBS_len((uint64_t)v24))
                    {
                      if (!a3)
                        return 1;
                      *(_OWORD *)a3 = 0u;
                      *(_OWORD *)(a3 + 16) = 0u;
                      *(_QWORD *)(a3 + 48) = 0;
                      *(_OWORD *)(a3 + 32) = 0u;
                      *(_DWORD *)(a3 + 16) = v9 - 1;
                      *(_DWORD *)(a3 + 20) = v7 - 1900;
                      *(_DWORD *)(a3 + 8) = v12;
                      *(_DWORD *)(a3 + 12) = v10;
                      result = 1;
                      *(_DWORD *)a3 = v16;
                      *(_DWORD *)(a3 + 4) = v14;
                      return result;
                    }
                    return 0;
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t cbs_get_two_digit_value(_QWORD *a1, _DWORD *a2)
{
  uint64_t result;
  __int16 v5;

  v5 = 0;
  result = CBS_get_u8(a1, (_BYTE *)&v5 + 1);
  if ((_DWORD)result)
  {
    if (HIBYTE(v5) - 48 > 9)
      return 0;
    result = CBS_get_u8(a1, &v5);
    if (!(_DWORD)result)
      return result;
    if (v5 - 48 > 9)
    {
      return 0;
    }
    else
    {
      *a2 = v5 + 10 * HIBYTE(v5) - 528;
      return 1;
    }
  }
  return result;
}

uint64_t ASN1_time_parse(uint64_t a1, uint64_t a2, _OWORD *a3, int a4)
{
  _OWORD *v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  unsigned int v9;
  _QWORD v12[3];
  _OWORD v13[3];
  uint64_t v14;

  if (!a1)
    return 0xFFFFFFFFLL;
  v14 = 0;
  memset(v13, 0, sizeof(v13));
  v12[1] = 0;
  v12[2] = 0;
  if (a3)
    v5 = a3;
  else
    v5 = v13;
  v12[0] = 0;
  CBS_init(v12, a1, a2);
  v6 = CBS_len((uint64_t)v12);
  v7 = CBS_len((uint64_t)v12);
  v8 = asn1_time_parse_cbs(v12, v7 == 15, (uint64_t)v5);
  if (v6 == 13)
    v9 = 23;
  else
    v9 = 0;
  if (v7 == 15)
    v9 = 24;
  if (v9 != a4 && a4 != 0)
    v9 = -1;
  if (v8)
    return v9;
  else
    return 0xFFFFFFFFLL;
}

ASN1_TIME *__cdecl ASN1_TIME_set(ASN1_TIME *s, time_t t)
{
  return ASN1_TIME_adj_internal(s, t, 0, 0, 0);
}

ASN1_TIME *ASN1_TIME_adj(ASN1_TIME *a1, uint64_t a2, int a3, uint64_t a4)
{
  return ASN1_TIME_adj_internal(a1, a2, a3, a4, 0);
}

ASN1_TIME *ASN1_TIME_set_tm(ASN1_TIME *a1, int *a2)
{
  uint64_t v4;

  v4 = 0;
  if (asn1_time_tm_to_time_t(a2, &v4))
    return ASN1_TIME_adj_internal(a1, v4, 0, 0, 0);
  else
    return 0;
}

ASN1_TIME *ASN1_TIME_adj_internal(ASN1_TIME *a1, uint64_t a2, int a3, uint64_t a4, int a5)
{
  _OWORD v10[3];
  uint64_t v11;
  uint64_t v12;

  v12 = a2;
  v11 = 0;
  memset(v10, 0, sizeof(v10));
  if (asn1_time_time_t_to_tm(&v12, (uint64_t)v10)
    && (!a3 && !a4 || OPENSSL_gmtime_adj((int *)v10, a3, a4)))
  {
    switch(a5)
    {
      case 0:
        return tm_to_rfc5280_time(v10, a1);
      case 24:
        return tm_to_gentime(v10, a1);
      case 23:
        return tm_to_utctime(v10, a1);
    }
  }
  return 0;
}

int ASN1_TIME_check(ASN1_TIME *t)
{
  int type;

  type = t->type;
  return (type - 23) <= 1 && type == ASN1_time_parse((uint64_t)t->data, t->length, 0, type);
}

ASN1_GENERALIZEDTIME *__cdecl ASN1_TIME_to_generalizedtime(ASN1_TIME *t, ASN1_GENERALIZEDTIME **out)
{
  int type;
  int v4;
  ASN1_GENERALIZEDTIME *result;
  _OWORD v6[3];
  uint64_t v7;

  type = t->type;
  if ((type - 23) > 1)
    return 0;
  v7 = 0;
  memset(v6, 0, sizeof(v6));
  v4 = ASN1_time_parse((uint64_t)t->data, t->length, v6, type);
  result = 0;
  if (type == v4)
  {
    if (out)
    {
      result = tm_to_gentime(v6, *out);
      if (result)
        *out = result;
    }
    else
    {
      return tm_to_gentime(v6, 0);
    }
  }
  return result;
}

char *ASN1_TIME_set_string(uint64_t a1, char *a2)
{
  return ASN1_TIME_set_string_internal(a1, a2, 0);
}

char *ASN1_TIME_set_string_internal(uint64_t a1, char *__s, int a3)
{
  size_t v6;
  int v7;
  int v8;
  char *result;
  const char *v10;

  v6 = strlen(__s);
  v7 = ASN1_time_parse((uint64_t)__s, v6, 0, a3);
  if (v7 == -1)
    return 0;
  v8 = v7;
  if (a3)
  {
    if (v7 != a3)
      return 0;
  }
  if (a1)
  {
    result = strdup(__s);
    if (!result)
      return result;
    v10 = result;
    free(*(void **)(a1 + 8));
    *(_QWORD *)(a1 + 8) = v10;
    *(_DWORD *)a1 = strlen(v10);
    *(_DWORD *)(a1 + 4) = v8;
  }
  return (char *)1;
}

uint64_t ASN1_TIME_compare(int *a1, int *a2)
{
  int v2;
  _OWORD v6[3];
  uint64_t v7;
  _OWORD v8[3];
  uint64_t v9;

  v2 = a1[1];
  if ((v2 - 23) > 1)
    return 4294967294;
  if ((a2[1] - 23) > 1)
    return 4294967294;
  v9 = 0;
  memset(v8, 0, sizeof(v8));
  memset(v6, 0, sizeof(v6));
  v7 = 0;
  if (ASN1_time_parse(*((_QWORD *)a1 + 1), *a1, v8, v2) == -1
    || ASN1_time_parse(*((_QWORD *)a1 + 1), *a2, v6, a2[1]) == -1)
  {
    return 4294967294;
  }
  else
  {
    return ASN1_time_tm_cmp(v8, v6);
  }
}

uint64_t ASN1_TIME_cmp_time_t(int *a1, uint64_t a2)
{
  int v2;

  v2 = a1[1];
  if ((v2 - 23) > 1)
    return 4294967294;
  else
    return ASN1_TIME_cmp_time_t_internal(a1, a2, v2);
}

uint64_t ASN1_TIME_cmp_time_t_internal(int *a1, uint64_t a2, int a3)
{
  _OWORD v4[3];
  uint64_t v5;
  _OWORD v6[3];
  uint64_t v7;
  uint64_t v8;

  v8 = a2;
  v7 = 0;
  memset(v6, 0, sizeof(v6));
  v5 = 0;
  memset(v4, 0, sizeof(v4));
  if (ASN1_time_parse(*((_QWORD *)a1 + 1), *a1, v6, a3) == -1
    || !asn1_time_time_t_to_tm(&v8, (uint64_t)v4))
  {
    return 4294967294;
  }
  else
  {
    return ASN1_time_tm_cmp(v6, v4);
  }
}

int ASN1_UTCTIME_check(ASN1_UTCTIME *a)
{
  return a->type == 23 && ASN1_time_parse((uint64_t)a->data, a->length, 0, 23) == 23;
}

int ASN1_UTCTIME_set_string(ASN1_UTCTIME *s, const char *str)
{
  if (s && s->type != 23)
    return 0;
  else
    return ASN1_TIME_set_string_internal((uint64_t)s, (char *)str, 23);
}

ASN1_UTCTIME *__cdecl ASN1_UTCTIME_set(ASN1_UTCTIME *s, time_t t)
{
  return ASN1_TIME_adj_internal(s, t, 0, 0, 23);
}

ASN1_TIME *ASN1_UTCTIME_adj(ASN1_TIME *a1, uint64_t a2, int a3, uint64_t a4)
{
  return ASN1_TIME_adj_internal(a1, a2, a3, a4, 23);
}

int ASN1_UTCTIME_cmp_time_t(const ASN1_UTCTIME *s, time_t t)
{
  if (s->type == 23)
    return ASN1_TIME_cmp_time_t_internal(&s->length, t, 23);
  else
    return -2;
}

int ASN1_GENERALIZEDTIME_check(ASN1_GENERALIZEDTIME *a)
{
  return a->type == 24 && ASN1_time_parse((uint64_t)a->data, a->length, 0, 24) == 24;
}

int ASN1_GENERALIZEDTIME_set_string(ASN1_GENERALIZEDTIME *s, const char *str)
{
  if (s && s->type != 24)
    return 0;
  else
    return ASN1_TIME_set_string_internal((uint64_t)s, (char *)str, 24);
}

ASN1_GENERALIZEDTIME *__cdecl ASN1_GENERALIZEDTIME_set(ASN1_GENERALIZEDTIME *s, time_t t)
{
  return ASN1_TIME_adj_internal(s, t, 0, 0, 24);
}

ASN1_TIME *ASN1_GENERALIZEDTIME_adj(ASN1_TIME *a1, uint64_t a2, int a3, uint64_t a4)
{
  return ASN1_TIME_adj_internal(a1, a2, a3, a4, 24);
}

uint64_t ASN1_TIME_normalize(ASN1_TIME *a1)
{
  uint64_t result;
  _OWORD v3[3];
  uint64_t v4;

  v4 = 0;
  memset(v3, 0, sizeof(v3));
  result = ASN1_TIME_to_tm(&a1->length, (uint64_t)v3);
  if ((_DWORD)result)
    return tm_to_rfc5280_time(v3, a1) != 0;
  return result;
}

char *ASN1_TIME_set_string_X509(uint64_t a1, char *a2)
{
  return ASN1_TIME_set_string_internal(a1, a2, 0);
}

void ERR_load_TS_strings()
{
  if (!ERR_func_error_string(TS_str_functs))
  {
    ERR_load_strings(0, (ERR_STRING_DATA *)&TS_str_functs);
    ERR_load_strings(0, (ERR_STRING_DATA *)&TS_str_reasons);
  }
}

BOOL asn1_must_be_constructed(unsigned int a1)
{
  unsigned int v1;
  BOOL v2;
  unsigned int v3;

  if ((a1 & 0xFFFFFFF7) == 0x102)
    v1 = a1 & 0xFFFFFEFF;
  else
    v1 = a1;
  v2 = v1 >= 0x1F;
  v3 = v1 & 0xFFFFFFFE;
  return !v2 && v3 == 16;
}

unint64_t asn1_must_be_primitive(unsigned int a1)
{
  unsigned int v1;

  if ((a1 & 0xFFFFFFF7) == 0x102)
    v1 = a1 & 0xFFFFFEFF;
  else
    v1 = a1;
  if (v1 <= 0x1E)
    return (0x6666uLL >> v1) & 1;
  else
    return 0;
}

uint64_t asn1_tag2charwidth(unsigned int a1)
{
  if (a1 <= 0x1E)
    return *((unsigned int *)&asn1_types + 6 * a1 + 3);
  else
    return 0xFFFFFFFFLL;
}

unint64_t ASN1_tag2bit(int tag)
{
  if (tag <= 0x1E)
    return LODWORD((&asn1_types)[3 * tag + 1]);
  else
    return 0;
}

const char *__cdecl ASN1_tag2str(int tag)
{
  unsigned int v1;

  if ((tag & 0xFFFFFFF7) == 0x102)
    v1 = tag & 0xFFFFFEFF;
  else
    v1 = tag;
  if (v1 <= 0x1E)
    return (&asn1_types)[3 * v1];
  else
    return "(unknown)";
}

void syslog_r(int a1, uint64_t a2, char *a3, ...)
{
  va_list va;

  va_start(va, a3);
  vsyslog(a1, a3, va);
}

void vsyslog_r(int a1, int a2, char *a3, __darwin_va_list a4)
{
  vsyslog(a1, a3, a4);
}

uint64_t X509_get0_extensions(uint64_t a1)
{
  return *(_QWORD *)(*(_QWORD *)a1 + 72);
}

uint64_t X509_get0_tbs_sigalg(uint64_t a1)
{
  return *(_QWORD *)(*(_QWORD *)a1 + 16);
}

int X509_set_version(X509 *x, uint64_t version)
{
  X509_CINF *cert_info;
  ASN1_INTEGER *v5;

  if (!x)
    return 0;
  cert_info = x->cert_info;
  v5 = x->cert_info->version;
  if (!v5)
  {
    v5 = ASN1_INTEGER_new();
    cert_info = x->cert_info;
    x->cert_info->version = v5;
    if (!v5)
      return 0;
  }
  cert_info->enc.modified = 1;
  return ASN1_INTEGER_set(v5, version);
}

uint64_t X509_get_version(ASN1_INTEGER ***a1)
{
  return ASN1_INTEGER_get(**a1);
}

int X509_set_serialNumber(X509 *x, ASN1_INTEGER *serial)
{
  ASN1_INTEGER *v2;
  X509 *v3;
  X509_CINF *cert_info;

  if (x)
  {
    v2 = serial;
    v3 = x;
    if (x->cert_info->serialNumber != serial)
    {
      v2 = ASN1_INTEGER_dup(serial);
      if (v2)
      {
        cert_info = v3->cert_info;
        cert_info->enc.modified = 1;
        ASN1_INTEGER_free(cert_info->serialNumber);
        v3->cert_info->serialNumber = v2;
      }
    }
    LODWORD(x) = v2 != 0;
  }
  return (int)x;
}

int X509_set_issuer_name(X509 *x, X509_NAME *name)
{
  X509_CINF *cert_info;

  if (!x)
    return 0;
  cert_info = x->cert_info;
  if (!x->cert_info)
    return 0;
  cert_info->enc.modified = 1;
  return X509_NAME_set(&cert_info->issuer, name);
}

int X509_set_subject_name(X509 *x, X509_NAME *name)
{
  X509_CINF *cert_info;

  if (!x)
    return 0;
  cert_info = x->cert_info;
  if (!x->cert_info)
    return 0;
  cert_info->enc.modified = 1;
  return X509_NAME_set(&cert_info->subject, name);
}

uint64_t X509_get0_notBefore(uint64_t result)
{
  uint64_t v1;

  if (result)
  {
    if (*(_QWORD *)result && (v1 = *(_QWORD *)(*(_QWORD *)result + 32)) != 0)
      return *(_QWORD *)v1;
    else
      return 0;
  }
  return result;
}

uint64_t X509_getm_notBefore(uint64_t result)
{
  uint64_t v1;

  if (result)
  {
    if (*(_QWORD *)result && (v1 = *(_QWORD *)(*(_QWORD *)result + 32)) != 0)
      return *(_QWORD *)v1;
    else
      return 0;
  }
  return result;
}

int X509_set_notBefore(X509 *x, ASN1_TIME *tm)
{
  X509 *v2;
  X509_VAL *validity;
  ASN1_TIME *v4;
  X509_CINF *cert_info;

  if (x)
  {
    v2 = x;
    validity = x->cert_info->validity;
    if (validity)
    {
      v4 = tm;
      if (validity->notBefore != tm)
      {
        v4 = ASN1_STRING_dup(tm);
        if (v4)
        {
          cert_info = v2->cert_info;
          cert_info->enc.modified = 1;
          ASN1_TIME_free(cert_info->validity->notBefore);
          v2->cert_info->validity->notBefore = v4;
        }
      }
      LODWORD(x) = v4 != 0;
    }
    else
    {
      LODWORD(x) = 0;
    }
  }
  return (int)x;
}

uint64_t X509_get0_notAfter(uint64_t result)
{
  uint64_t v1;

  if (result)
  {
    if (*(_QWORD *)result && (v1 = *(_QWORD *)(*(_QWORD *)result + 32)) != 0)
      return *(_QWORD *)(v1 + 8);
    else
      return 0;
  }
  return result;
}

uint64_t X509_getm_notAfter(uint64_t result)
{
  uint64_t v1;

  if (result)
  {
    if (*(_QWORD *)result && (v1 = *(_QWORD *)(*(_QWORD *)result + 32)) != 0)
      return *(_QWORD *)(v1 + 8);
    else
      return 0;
  }
  return result;
}

int X509_set_notAfter(X509 *x, ASN1_TIME *tm)
{
  X509 *v2;
  X509_VAL *validity;
  ASN1_TIME *v4;
  X509_CINF *cert_info;

  if (x)
  {
    v2 = x;
    validity = x->cert_info->validity;
    if (validity)
    {
      v4 = tm;
      if (validity->notAfter != tm)
      {
        v4 = ASN1_STRING_dup(tm);
        if (v4)
        {
          cert_info = v2->cert_info;
          cert_info->enc.modified = 1;
          ASN1_TIME_free(cert_info->validity->notAfter);
          v2->cert_info->validity->notAfter = v4;
        }
      }
      LODWORD(x) = v4 != 0;
    }
    else
    {
      LODWORD(x) = 0;
    }
  }
  return (int)x;
}

int X509_set_pubkey(X509 *x, EVP_PKEY *pkey)
{
  X509_CINF *cert_info;

  if (!x)
    return 0;
  cert_info = x->cert_info;
  if (!x->cert_info)
    return 0;
  cert_info->enc.modified = 1;
  return X509_PUBKEY_set(&cert_info->key, pkey);
}

uint64_t X509_get_signature_type(uint64_t a1)
{
  int v1;

  v1 = OBJ_obj2nid(**(const ASN1_OBJECT ***)(a1 + 8));
  return EVP_PKEY_type(v1);
}

uint64_t X509_get_X509_PUBKEY(uint64_t a1)
{
  return *(_QWORD *)(*(_QWORD *)a1 + 48);
}

uint64_t X509_get0_uids(uint64_t result, _QWORD *a2, _QWORD *a3)
{
  if (a2)
    *a2 = *(_QWORD *)(*(_QWORD *)result + 56);
  if (a3)
    *a3 = *(_QWORD *)(*(_QWORD *)result + 64);
  return result;
}

ENGINE *ENGINE_new(void)
{
  CRYPTO_EX_DATA *v0;
  ENGINE *v1;

  if (!OPENSSL_init_crypto(0, 0))
    return 0;
  v0 = (CRYPTO_EX_DATA *)malloc_type_malloc(0xD8uLL, 0x10F0040B12B0AC7uLL);
  v1 = (ENGINE *)v0;
  if (v0)
  {
    v0[13].sk = 0;
    v0[10] = 0u;
    v0[11] = 0u;
    v0[8] = 0u;
    v0[9] = 0u;
    v0[6] = 0u;
    v0[7] = 0u;
    v0[4] = 0u;
    v0[5] = 0u;
    v0[2] = 0u;
    v0[3] = 0u;
    *v0 = 0u;
    v0[1] = 0u;
    v0[12] = 0u;
    HIDWORD(v0[11].sk) = 1;
    CRYPTO_new_ex_data(9, v0, v0 + 12);
  }
  else
  {
    ERR_put_error(38, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/engine/eng_lib.c", 78);
  }
  return v1;
}

double engine_set_all_null(uint64_t a1)
{
  double result;

  *(_QWORD *)(a1 + 168) = 0;
  *(_DWORD *)(a1 + 176) = 0;
  result = 0.0;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_QWORD *)(a1 + 32) = 0;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  return result;
}

uint64_t engine_free_util(CRYPTO_EX_DATA *a1, int a2)
{
  int *v3;
  int v4;
  STACK *sk;

  if (a1)
  {
    v3 = (int *)&a1[11].sk + 1;
    if (a2)
    {
      v4 = CRYPTO_add_lock(v3, -1, 30, 0, 0);
    }
    else
    {
      v4 = *v3 - 1;
      *v3 = v4;
    }
    if (v4 <= 0)
    {
      engine_pkey_meths_free((uint64_t)a1);
      engine_pkey_asn1_meths_free((uint64_t)a1);
      sk = a1[7].sk;
      if (sk)
        ((void (*)(CRYPTO_EX_DATA *))sk)(a1);
      CRYPTO_free_ex_data(9, a1, a1 + 12);
      free(a1);
    }
  }
  return 1;
}

int ENGINE_free(ENGINE *e)
{
  engine_free_util((CRYPTO_EX_DATA *)e, 1);
  return 1;
}

char *engine_cleanup_add_first(uint64_t a1)
{
  char *result;

  if (cleanup_stack || (result = (char *)sk_new_null(), (cleanup_stack = (uint64_t)result) != 0))
  {
    result = (char *)malloc_type_malloc(8uLL, 0x80040B8603338uLL);
    if (result)
    {
      *(_QWORD *)result = a1;
      return (char *)sk_insert((STACK *)cleanup_stack, result, 0);
    }
  }
  return result;
}

char *engine_cleanup_add_last(uint64_t a1)
{
  char *result;

  if (cleanup_stack || (result = (char *)sk_new_null(), (cleanup_stack = (uint64_t)result) != 0))
  {
    result = (char *)malloc_type_malloc(8uLL, 0x80040B8603338uLL);
    if (result)
    {
      *(_QWORD *)result = a1;
      return (char *)sk_push((STACK *)cleanup_stack, result);
    }
  }
  return result;
}

void ENGINE_cleanup(void)
{
  if (cleanup_stack)
  {
    sk_pop_free((STACK *)cleanup_stack, (void (__cdecl *)(void *))engine_cleanup_cb_free);
    cleanup_stack = 0;
  }
  RAND_set_rand_method(0);
}

void engine_cleanup_cb_free(void (**a1)(void))
{
  (*a1)();
  free(a1);
}

int ENGINE_get_ex_new_index(uint64_t argl, void *argp, CRYPTO_EX_new *new_func, CRYPTO_EX_dup *dup_func, CRYPTO_EX_free *free_func)
{
  return CRYPTO_get_ex_new_index(9, argl, argp, new_func, dup_func, free_func);
}

int ENGINE_set_ex_data(ENGINE *e, int idx, void *arg)
{
  return CRYPTO_set_ex_data((CRYPTO_EX_DATA *)e + 12, idx, arg);
}

void *__cdecl ENGINE_get_ex_data(const ENGINE *e, int idx)
{
  return CRYPTO_get_ex_data((const CRYPTO_EX_DATA *)e + 12, idx);
}

int ENGINE_set_id(ENGINE *e, const char *id)
{
  if (id)
  {
    *(_QWORD *)e = id;
    return 1;
  }
  else
  {
    ERR_put_error(38, 4095, 67, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/engine/eng_lib.c", 248);
    return 0;
  }
}

int ENGINE_set_name(ENGINE *e, const char *name)
{
  if (name)
  {
    *((_QWORD *)e + 1) = name;
    return 1;
  }
  else
  {
    ERR_put_error(38, 4095, 67, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/engine/eng_lib.c", 259);
    return 0;
  }
}

int ENGINE_set_destroy_function(ENGINE *e, ENGINE_GEN_INT_FUNC_PTR destroy_f)
{
  *((_QWORD *)e + 14) = destroy_f;
  return 1;
}

int ENGINE_set_init_function(ENGINE *e, ENGINE_GEN_INT_FUNC_PTR init_f)
{
  *((_QWORD *)e + 15) = init_f;
  return 1;
}

int ENGINE_set_finish_function(ENGINE *e, ENGINE_GEN_INT_FUNC_PTR finish_f)
{
  *((_QWORD *)e + 16) = finish_f;
  return 1;
}

int ENGINE_set_ctrl_function(ENGINE *e, ENGINE_CTRL_FUNC_PTR ctrl_f)
{
  *((_QWORD *)e + 17) = ctrl_f;
  return 1;
}

int ENGINE_set_flags(ENGINE *e, int flags)
{
  *((_DWORD *)e + 44) = flags;
  return 1;
}

int ENGINE_set_cmd_defns(ENGINE *e, const ENGINE_CMD_DEFN *defns)
{
  *((_QWORD *)e + 21) = defns;
  return 1;
}

const char *__cdecl ENGINE_get_id(const ENGINE *e)
{
  return *(const char **)e;
}

const char *__cdecl ENGINE_get_name(const ENGINE *e)
{
  return (const char *)*((_QWORD *)e + 1);
}

ENGINE_GEN_INT_FUNC_PTR ENGINE_get_destroy_function(const ENGINE *e)
{
  return (ENGINE_GEN_INT_FUNC_PTR)*((_QWORD *)e + 14);
}

ENGINE_GEN_INT_FUNC_PTR ENGINE_get_init_function(const ENGINE *e)
{
  return (ENGINE_GEN_INT_FUNC_PTR)*((_QWORD *)e + 15);
}

ENGINE_GEN_INT_FUNC_PTR ENGINE_get_finish_function(const ENGINE *e)
{
  return (ENGINE_GEN_INT_FUNC_PTR)*((_QWORD *)e + 16);
}

ENGINE_CTRL_FUNC_PTR ENGINE_get_ctrl_function(const ENGINE *e)
{
  return (ENGINE_CTRL_FUNC_PTR)*((_QWORD *)e + 17);
}

int ENGINE_get_flags(const ENGINE *e)
{
  return *((_DWORD *)e + 44);
}

const ENGINE_CMD_DEFN *__cdecl ENGINE_get_cmd_defns(const ENGINE *e)
{
  return (const ENGINE_CMD_DEFN *)*((_QWORD *)e + 21);
}

void *ENGINE_get_static_state(void)
{
  return &internal_static_hack;
}

ASN1_VALUE *d2i_GOST_KEY_TRANSPORT(ASN1_VALUE **a1, const unsigned __int8 **a2, uint64_t a3)
{
  return ASN1_item_d2i(a1, a2, a3, &GOST_KEY_TRANSPORT_it);
}

uint64_t i2d_GOST_KEY_TRANSPORT(ASN1_VALUE *a1, unsigned __int8 **a2)
{
  return ASN1_item_i2d(a1, a2, &GOST_KEY_TRANSPORT_it);
}

ASN1_VALUE *GOST_KEY_TRANSPORT_new()
{
  return ASN1_item_new(&GOST_KEY_TRANSPORT_it);
}

void GOST_KEY_TRANSPORT_free(ASN1_VALUE *a1)
{
  ASN1_item_free(a1, &GOST_KEY_TRANSPORT_it);
}

ASN1_VALUE *d2i_GOST_KEY_INFO(ASN1_VALUE **a1, const unsigned __int8 **a2, uint64_t a3)
{
  return ASN1_item_d2i(a1, a2, a3, &GOST_KEY_INFO_it);
}

uint64_t i2d_GOST_KEY_INFO(ASN1_VALUE *a1, unsigned __int8 **a2)
{
  return ASN1_item_i2d(a1, a2, &GOST_KEY_INFO_it);
}

ASN1_VALUE *GOST_KEY_INFO_new()
{
  return ASN1_item_new(&GOST_KEY_INFO_it);
}

void GOST_KEY_INFO_free(ASN1_VALUE *a1)
{
  ASN1_item_free(a1, &GOST_KEY_INFO_it);
}

ASN1_VALUE *d2i_GOST_KEY_AGREEMENT_INFO(ASN1_VALUE **a1, const unsigned __int8 **a2, uint64_t a3)
{
  return ASN1_item_d2i(a1, a2, a3, &GOST_KEY_AGREEMENT_INFO_it);
}

uint64_t i2d_GOST_KEY_AGREEMENT_INFO(ASN1_VALUE *a1, unsigned __int8 **a2)
{
  return ASN1_item_i2d(a1, a2, &GOST_KEY_AGREEMENT_INFO_it);
}

ASN1_VALUE *GOST_KEY_AGREEMENT_INFO_new()
{
  return ASN1_item_new(&GOST_KEY_AGREEMENT_INFO_it);
}

void GOST_KEY_AGREEMENT_INFO_free(ASN1_VALUE *a1)
{
  ASN1_item_free(a1, &GOST_KEY_AGREEMENT_INFO_it);
}

ASN1_VALUE *d2i_GOST_KEY_PARAMS(ASN1_VALUE **a1, const unsigned __int8 **a2, uint64_t a3)
{
  return ASN1_item_d2i(a1, a2, a3, &GOST_KEY_PARAMS_it);
}

uint64_t i2d_GOST_KEY_PARAMS(ASN1_VALUE *a1, unsigned __int8 **a2)
{
  return ASN1_item_i2d(a1, a2, &GOST_KEY_PARAMS_it);
}

ASN1_VALUE *GOST_KEY_PARAMS_new()
{
  return ASN1_item_new(&GOST_KEY_PARAMS_it);
}

void GOST_KEY_PARAMS_free(ASN1_VALUE *a1)
{
  ASN1_item_free(a1, &GOST_KEY_PARAMS_it);
}

ASN1_VALUE *d2i_GOST_CIPHER_PARAMS(ASN1_VALUE **a1, const unsigned __int8 **a2, uint64_t a3)
{
  return ASN1_item_d2i(a1, a2, a3, &GOST_CIPHER_PARAMS_it);
}

uint64_t i2d_GOST_CIPHER_PARAMS(ASN1_VALUE *a1, unsigned __int8 **a2)
{
  return ASN1_item_i2d(a1, a2, &GOST_CIPHER_PARAMS_it);
}

ASN1_VALUE *GOST_CIPHER_PARAMS_new()
{
  return ASN1_item_new(&GOST_CIPHER_PARAMS_it);
}

void GOST_CIPHER_PARAMS_free(ASN1_VALUE *a1)
{
  ASN1_item_free(a1, &GOST_CIPHER_PARAMS_it);
}

void ERR_load_BUF_strings(void)
{
  if (!ERR_func_error_string(BUF_str_functs))
  {
    ERR_load_strings(0, (ERR_STRING_DATA *)&BUF_str_functs);
    ERR_load_strings(0, &BUF_str_reasons);
  }
}

unsigned __int8 *__cdecl PKCS12_pbe_crypt(X509_ALGOR *algor, const char *pass, int passlen, unsigned __int8 *in, int inlen, unsigned __int8 **data, int *datalen, int en_de)
{
  int v16;
  void *v17;
  int v18;
  int v19;
  int v20;
  int outl;
  EVP_CIPHER_CTX a;
  uint64_t v24;

  v24 = *MEMORY[0x24BDAC8D0];
  outl = 0;
  memset(&a, 0, sizeof(a));
  EVP_CIPHER_CTX_init(&a);
  if (!EVP_PBE_CipherInit(algor->algorithm, pass, passlen, algor->parameter, &a, en_de))
  {
    v19 = 115;
    v20 = 85;
LABEL_13:
    ERR_put_error(35, 4095, v19, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/pkcs12/p12_decr.c", v20);
    v17 = 0;
    goto LABEL_14;
  }
  v16 = EVP_CIPHER_CTX_block_size(&a);
  v17 = malloc_type_malloc(v16 + inlen, 0xEDB6E310uLL);
  if (!v17)
  {
    ERR_put_error(35, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/pkcs12/p12_decr.c", 90);
    goto LABEL_14;
  }
  if (!EVP_CipherUpdate(&a, (unsigned __int8 *)v17, &outl, in, inlen))
  {
    free(v17);
    v19 = 6;
    v20 = 97;
    goto LABEL_13;
  }
  v18 = outl;
  if (!EVP_CipherFinal_ex(&a, (unsigned __int8 *)v17 + outl, &outl))
  {
    free(v17);
    v19 = 116;
    v20 = 105;
    goto LABEL_13;
  }
  if (datalen)
    *datalen = outl + v18;
  if (data)
    *data = (unsigned __int8 *)v17;
LABEL_14:
  EVP_CIPHER_CTX_cleanup(&a);
  return (unsigned __int8 *)v17;
}

void *__cdecl PKCS12_item_decrypt_d2i(X509_ALGOR *algor, const ASN1_ITEM *it, const char *pass, int passlen, ASN1_OCTET_STRING *oct, int zbuf)
{
  ASN1_VALUE *v8;
  int datalen;
  unsigned __int8 *in;
  unsigned __int8 *data;

  data = 0;
  datalen = 0;
  if (PKCS12_pbe_crypt(algor, pass, passlen, oct->data, oct->length, &data, &datalen, 0))
  {
    in = data;
    v8 = ASN1_item_d2i(0, (const unsigned __int8 **)&in, datalen, it);
    if (zbuf)
      explicit_bzero(data, datalen);
    if (!v8)
      ERR_put_error(35, 4095, 101, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/pkcs12/p12_decr.c", 144);
    free(data);
  }
  else
  {
    ERR_put_error(35, 4095, 117, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/pkcs12/p12_decr.c", 136);
    return 0;
  }
  return v8;
}

ASN1_OCTET_STRING *__cdecl PKCS12_item_i2d_encrypt(X509_ALGOR *algor, const ASN1_ITEM *it, const char *pass, int passlen, void *obj, int zbuf)
{
  ASN1_OCTET_STRING *v12;
  int v13;
  int v14;
  int v15;
  int v16;
  unsigned __int8 *out;

  out = 0;
  v12 = ASN1_OCTET_STRING_new();
  if (!v12)
  {
    ERR_put_error(35, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/pkcs12/p12_decr.c", 164);
    return v12;
  }
  v13 = ASN1_item_i2d((ASN1_VALUE *)obj, &out, it);
  if (!out)
  {
    v15 = 102;
    v16 = 169;
LABEL_10:
    ERR_put_error(35, 4095, v15, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/pkcs12/p12_decr.c", v16);
    free(out);
    ASN1_OCTET_STRING_free(v12);
    return 0;
  }
  v14 = v13;
  if (!PKCS12_pbe_crypt(algor, pass, passlen, out, v13, &v12->data, &v12->length, 1))
  {
    v15 = 103;
    v16 = 174;
    goto LABEL_10;
  }
  if (zbuf)
    explicit_bzero(out, v14);
  free(out);
  return v12;
}

void ENGINE_unregister_DSA(ENGINE *e)
{
  engine_table_unregister(&dsa_table, e);
}

int ENGINE_register_DSA(ENGINE *e)
{
  if (*((_QWORD *)e + 3))
    return engine_table_register(&dsa_table, (uint64_t)engine_unregister_all_DSA, (char *)e, dummy_nid_3, 1, 0);
  else
    return 1;
}

void engine_unregister_all_DSA()
{
  engine_table_cleanup(&dsa_table);
}

void ENGINE_register_all_DSA(void)
{
  ENGINE *first;
  ENGINE *next;

  first = ENGINE_get_first();
  if (first)
  {
    next = first;
    do
    {
      if (*((_QWORD *)next + 3))
        engine_table_register(&dsa_table, (uint64_t)engine_unregister_all_DSA, (char *)next, dummy_nid_3, 1, 0);
      next = ENGINE_get_next(next);
    }
    while (next);
  }
}

int ENGINE_set_default_DSA(ENGINE *e)
{
  if (*((_QWORD *)e + 3))
    return engine_table_register(&dsa_table, (uint64_t)engine_unregister_all_DSA, (char *)e, dummy_nid_3, 1, 1);
  else
    return 1;
}

ENGINE *ENGINE_get_default_DSA(void)
{
  return (ENGINE *)engine_table_select(&dsa_table, 1);
}

const DSA_METHOD *__cdecl ENGINE_get_DSA(const ENGINE *e)
{
  return (const DSA_METHOD *)*((_QWORD *)e + 3);
}

int ENGINE_set_DSA(ENGINE *e, const DSA_METHOD *dsa_meth)
{
  *((_QWORD *)e + 3) = dsa_meth;
  return 1;
}

EVP_PKEY *__cdecl d2i_PrivateKey(int type, EVP_PKEY **a, const unsigned __int8 **pp, uint64_t length)
{
  const unsigned __int8 *v8;
  EVP_PKEY *v9;
  char *ptr;
  unsigned int (*v11)(EVP_PKEY *, const unsigned __int8 **, uint64_t);
  PKCS8_PRIV_KEY_INFO *v12;
  PKCS8_PRIV_KEY_INFO *v13;
  int v14;
  int v15;

  v8 = *pp;
  if (a && (v9 = *a) != 0)
  {
    ENGINE_finish(*(ENGINE **)&v9->save_parameters);
    *(_QWORD *)&v9->save_parameters = 0;
  }
  else
  {
    v9 = EVP_PKEY_new();
    if (!v9)
    {
      ERR_put_error(13, 4095, 6, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/a_pkey.c", 85);
      return v9;
    }
  }
  if (!EVP_PKEY_set_type((uint64_t)v9, type))
  {
    v14 = 163;
    v15 = 97;
LABEL_17:
    ERR_put_error(13, 4095, v14, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/a_pkey.c", v15);
    goto LABEL_18;
  }
  ptr = v9->pkey.ptr;
  v11 = (unsigned int (*)(EVP_PKEY *, const unsigned __int8 **, uint64_t))*((_QWORD *)ptr + 23);
  if (v11)
  {
    if (v11(v9, pp, length))
      goto LABEL_12;
    ptr = v9->pkey.ptr;
  }
  if (!*((_QWORD *)ptr + 8))
  {
    v14 = 13;
    v15 = 113;
    goto LABEL_17;
  }
  *pp = v8;
  v12 = d2i_PKCS8_PRIV_KEY_INFO(0, pp, length);
  if (v12)
  {
    v13 = v12;
    EVP_PKEY_free(v9);
    v9 = EVP_PKCS82PKEY(v13);
    PKCS8_PRIV_KEY_INFO_free(v13);
LABEL_12:
    if (a)
      *a = v9;
    return v9;
  }
LABEL_18:
  if (!a || *a != v9)
    EVP_PKEY_free(v9);
  return 0;
}

int i2d_PrivateKey(EVP_PKEY *a, unsigned __int8 **pp)
{
  char *ptr;
  uint64_t (*v4)(void);
  PKCS8_PRIV_KEY_INFO *v6;
  int v7;

  ptr = a->pkey.ptr;
  if (!ptr)
    goto LABEL_6;
  v4 = (uint64_t (*)(void))*((_QWORD *)ptr + 24);
  if (v4)
    return v4();
  if (*((_QWORD *)ptr + 9))
  {
    v6 = EVP_PKEY2PKCS8(a);
    v7 = i2d_PKCS8_PRIV_KEY_INFO(v6, pp);
    PKCS8_PRIV_KEY_INFO_free(v6);
    return v7;
  }
  else
  {
LABEL_6:
    ERR_put_error(13, 4095, 167, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/a_pkey.c", 139);
    return -1;
  }
}

EVP_PKEY *__cdecl d2i_AutoPrivateKey(EVP_PKEY **a, const unsigned __int8 **pp, uint64_t length)
{
  STACK *v6;
  int v7;
  PKCS8_PRIV_KEY_INFO *v8;
  EVP_PKEY *v9;
  const unsigned __int8 *v11;

  v11 = *pp;
  v6 = (STACK *)d2i_ASN1_SEQUENCE_ANY(0, &v11, length);
  if (sk_num(v6) == 6)
  {
    v7 = 116;
LABEL_10:
    sk_pop_free(v6, (void (__cdecl *)(void *))ASN1_TYPE_free);
    return d2i_PrivateKey(v7, a, pp, length);
  }
  if (sk_num(v6) == 4)
  {
    v7 = 408;
    goto LABEL_10;
  }
  if (sk_num(v6) != 3)
  {
    v7 = 6;
    goto LABEL_10;
  }
  v8 = d2i_PKCS8_PRIV_KEY_INFO(0, pp, length);
  sk_pop_free(v6, (void (__cdecl *)(void *))ASN1_TYPE_free);
  if (v8)
  {
    v9 = EVP_PKCS82PKEY(v8);
    PKCS8_PRIV_KEY_INFO_free(v8);
    if (a)
      *a = v9;
  }
  else
  {
    ERR_put_error(13, 4095, 167, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/a_pkey.c", 173);
    return 0;
  }
  return v9;
}

uint64_t Camellia_cfb128_encrypt(uint64_t a1, _BYTE *a2, unint64_t a3, uint64_t a4, uint64_t a5, unsigned int *a6, int a7)
{
  return CRYPTO_cfb128_encrypt(a1, a2, a3, a4, a5, a6, a7, (uint64_t (*)(uint64_t, uint64_t, uint64_t))Camellia_encrypt);
}

double Camellia_cfb1_encrypt(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7)
{
  double result;

  *(_QWORD *)&result = CRYPTO_cfb128_1_encrypt(a1, a2, a3, a4, a5, a6, a7, (void (*)(uint64_t, uint64_t, uint64_t))Camellia_encrypt).u64[0];
  return result;
}

uint64_t Camellia_cfb8_encrypt(uint64_t a1, _BYTE *a2, uint64_t a3, uint64_t a4, __int128 *a5, uint64_t a6, int a7)
{
  return CRYPTO_cfb128_8_encrypt(a1, a2, a3, a4, a5, a6, a7, (uint64_t (*)(__int128 *, __int128 *, uint64_t))Camellia_encrypt);
}

int CRYPTO_num_locks(void)
{
  return 1;
}

unint64_t (*CRYPTO_get_id_callback(void))(void)
{
  return 0;
}

void CRYPTO_set_locking_callback(void (__cdecl *func)(int, int, const char *, int))
{
  locking_callback = (uint64_t)func;
}

void (__cdecl *CRYPTO_get_locking_callback(void))(int, int, const char *, int)
{
  return (void (__cdecl *)(int, int, const char *, int))locking_callback;
}

void CRYPTO_set_add_lock_callback(int (__cdecl *func)(int *, int, int, const char *, int))
{
  add_lock_callback = (uint64_t)func;
}

int (__cdecl *CRYPTO_get_add_lock_callback(void))(int *, int, int, const char *, int)
{
  return (int (__cdecl *)(int *, int, int, const char *, int))add_lock_callback;
}

const char *__cdecl CRYPTO_get_lock_name(int type)
{
  return "";
}

CRYPTO_dynlock_value *__cdecl CRYPTO_get_dynlock_value(int i)
{
  return 0;
}

int CRYPTO_get_new_dynlockid(void)
{
  return 0;
}

int CRYPTO_get_new_lockid(char *name)
{
  return 0;
}

uint64_t CRYPTO_THREADID_set_callback()
{
  return 1;
}

uint64_t CRYPTO_THREADID_get_callback()
{
  return 0;
}

CRYPTO_dynlock_value *(__cdecl *CRYPTO_get_dynlock_create_callback(void))(const char *, int)
{
  return 0;
}

void (__cdecl *CRYPTO_get_dynlock_lock_callback(void))(int, CRYPTO_dynlock_value *, const char *, int)
{
  return 0;
}

void (__cdecl *CRYPTO_get_dynlock_destroy_callback(void))(CRYPTO_dynlock_value *, const char *, int)
{
  return 0;
}

pthread_t CRYPTO_THREADID_current(_QWORD *a1)
{
  pthread_t result;

  *a1 = 0;
  a1[1] = 0;
  result = pthread_self();
  a1[1] = result;
  return result;
}

uint64_t CRYPTO_THREADID_cmp(unint64_t *a1, unint64_t *a2)
{
  unint64_t v2;
  unint64_t v3;

  v2 = bswap64(*a1);
  v3 = bswap64(*a2);
  if (v2 == v3)
  {
    v2 = bswap64(a1[1]);
    v3 = bswap64(a2[1]);
    if (v2 == v3)
      return 0;
  }
  if (v2 < v3)
    return 0xFFFFFFFFLL;
  return 1;
}

__n128 CRYPTO_THREADID_cpy(__n128 *a1, __n128 *a2)
{
  __n128 result;

  result = *a2;
  *a1 = *a2;
  return result;
}

uint64_t CRYPTO_THREADID_hash(uint64_t a1)
{
  return *(_QWORD *)(a1 + 8);
}

uint64_t OPENSSL_cpu_caps()
{
  return 0;
}

void OpenSSLDie(const char *file, int line, const char *assertion)
{
  char v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  const char *v11;

  v3 = getuid();
  v11 = getprogname();
  OPENSSL_showfatal((uint64_t)v11, v4, v5, v6, v7, v8, v9, v10, v3);
  _exit(1);
}

void OPENSSL_showfatal(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  __int128 v9;
  uint64_t v10;

  v9 = xmmword_22D6A3228;
  v10 = 0xFF00000008;
  vsyslog_r(150, (int)&v9, "uid %u cmd %s %s(%d): OpenSSL internal error, assertion failed: %s\n", &a9);
}

uint64_t CRYPTO_memcmp(char *a1, char *a2, uint64_t a3)
{
  unsigned __int8 v3;
  char v4;
  char v5;
  char v6;

  if (!a3)
    return 0;
  v3 = 0;
  do
  {
    v5 = *a1++;
    v4 = v5;
    v6 = *a2++;
    v3 |= v6 ^ v4;
    --a3;
  }
  while (a3);
  return v3;
}

int AES_set_encrypt_key(const unsigned __int8 *userKey, const int bits, AES_KEY *key)
{
  int v3;
  int v4;
  unsigned int v5;
  unsigned int v6;
  unsigned int v7;
  unsigned int v8;
  uint64_t v9;
  unsigned int *v10;
  unint64_t v11;
  int v12;
  int v13;
  int v14;
  unsigned int v16;
  uint64_t v17;
  unsigned int *i;
  int v19;
  unsigned int v20;
  uint64_t v21;
  unsigned int *j;
  int v23;
  int v24;
  int v25;

  v3 = -1;
  if (userKey && key)
  {
    if (bits == 128 || bits == 256 || bits == 192)
    {
      if (bits == 128)
      {
        v4 = 10;
      }
      else if (bits == 192)
      {
        v4 = 12;
      }
      else
      {
        v4 = 14;
      }
      key->rounds = v4;
      v5 = bswap32(*(_DWORD *)userKey);
      key->rd_key[0] = v5;
      v6 = bswap32(*((_DWORD *)userKey + 1));
      key->rd_key[1] = v6;
      v7 = bswap32(*((_DWORD *)userKey + 2));
      key->rd_key[2] = v7;
      v8 = bswap32(*((_DWORD *)userKey + 3));
      key->rd_key[3] = v8;
      if (bits == 128)
      {
        v9 = 0;
        v10 = &key->rd_key[4];
        do
        {
          v11 = *(v10 - 1);
          v5 ^= (Te2[4 * BYTE2(v11) + 3] << 24) ^ (Te3[4 * BYTE1(v11) + 2] << 16) ^ (Te0[4 * v11 + 1] << 8) ^ Te1[(v11 >> 22) & 0x3FC] ^ rcon[v9];
          v12 = *(v10 - 2);
          v13 = *(v10 - 3) ^ v5;
          *v10 = v5;
          v10[1] = v13;
          v14 = v12 ^ v13;
          v10[2] = v14;
          v10[3] = v14 ^ v11;
          ++v9;
          v10 += 4;
        }
        while (v9 != 10);
      }
      else
      {
        key->rd_key[4] = bswap32(*((_DWORD *)userKey + 4));
        v16 = bswap32(*((_DWORD *)userKey + 5));
        key->rd_key[5] = v16;
        if (bits == 192)
        {
          v17 = 0;
          for (i = &key->rd_key[11]; ; i += 6)
          {
            v5 ^= (Te2[4 * BYTE2(v16) + 3] << 24) ^ (Te3[4 * BYTE1(v16) + 2] << 16) ^ (Te0[4 * v16 + 1] << 8) ^ Te1[4 * HIBYTE(v16)] ^ rcon[v17];
            v6 ^= v5;
            *(i - 5) = v5;
            *(i - 4) = v6;
            v7 ^= v6;
            v8 ^= v7;
            *(i - 3) = v7;
            *(i - 2) = v8;
            if (v17 == 7)
              break;
            v19 = *(i - 7) ^ v8;
            v16 ^= v19;
            *(i - 1) = v19;
            *i = v16;
            ++v17;
          }
        }
        else
        {
          key->rd_key[6] = bswap32(*((_DWORD *)userKey + 6));
          v20 = bswap32(*((_DWORD *)userKey + 7));
          key->rd_key[7] = v20;
          v21 = 0;
          for (j = &key->rd_key[8]; ; j += 8)
          {
            v5 ^= (Te2[4 * BYTE2(v20) + 3] << 24) ^ (Te3[4 * BYTE1(v20) + 2] << 16) ^ (Te0[4 * v20 + 1] << 8) ^ Te1[4 * HIBYTE(v20)] ^ rcon[v21];
            v6 ^= v5;
            *j = v5;
            j[1] = v6;
            v7 ^= v6;
            v8 ^= v7;
            j[2] = v7;
            j[3] = v8;
            if (v21 == 6)
              break;
            v23 = *(j - 4) ^ (Te2[4 * HIBYTE(v8) + 3] << 24) ^ (Te3[4 * BYTE2(v8) + 2] << 16) ^ (Te0[4 * BYTE1(v8) + 1] << 8) ^ Te1[4 * v8];
            v24 = *(j - 3) ^ v23;
            j[4] = v23;
            j[5] = v24;
            v25 = *(j - 2) ^ v24;
            v20 ^= v25;
            j[6] = v25;
            j[7] = v20;
            ++v21;
          }
        }
      }
      return 0;
    }
    else
    {
      return -2;
    }
  }
  return v3;
}

int AES_set_decrypt_key(const unsigned __int8 *userKey, const int bits, AES_KEY *key)
{
  int result;
  int rounds;
  uint64_t v6;
  int v7;
  uint64_t v8;
  unsigned int *v9;
  unsigned int *v10;
  unsigned int v11;
  unsigned int v12;
  unsigned int v13;
  unsigned int v14;
  BOOL v15;
  unsigned int *v16;
  int v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t v20;
  unint64_t v21;

  result = AES_set_encrypt_key(userKey, bits, key);
  if ((result & 0x80000000) == 0)
  {
    rounds = key->rounds;
    if (rounds >= 1)
    {
      v6 = 0;
      v7 = 4 * rounds;
      v8 = 4 * rounds - 4;
      v9 = &key->rd_key[2];
      v10 = &key->rd_key[v7 + 2];
      do
      {
        v11 = *(v9 - 2);
        *(v9 - 2) = *(v10 - 2);
        *(v10 - 2) = v11;
        v12 = *(v9 - 1);
        *(v9 - 1) = *(v10 - 1);
        *(v10 - 1) = v12;
        v13 = *v9;
        *v9 = *v10;
        *v10 = v13;
        v14 = v9[1];
        v9[1] = v10[1];
        v10[1] = v14;
        v6 += 4;
        v10 -= 4;
        v9 += 4;
        v15 = v6 < v8;
        v8 -= 4;
      }
      while (v15);
      if (key->rounds >= 2)
      {
        v16 = &key->rd_key[7];
        v17 = 1;
        do
        {
          v18 = *(v16 - 3);
          v19 = *(v16 - 2);
          *(v16 - 3) = Td1[Te1[4 * BYTE2(v18)]] ^ Td0[Te1[(v18 >> 22) & 0x3FC]] ^ Td2[Te1[4 * BYTE1(v18)]] ^ Td3[Te1[4 * *(v16 - 3)]];
          *(v16 - 2) = Td1[Te1[4 * BYTE2(v19)]] ^ Td0[Te1[(v19 >> 22) & 0x3FC]] ^ Td2[Te1[4 * BYTE1(v19)]] ^ Td3[Te1[4 * v19]];
          v20 = *(v16 - 1);
          *(v16 - 1) = Td1[Te1[4 * BYTE2(v20)]] ^ Td0[Te1[(v20 >> 22) & 0x3FC]] ^ Td2[Te1[4 * BYTE1(v20)]] ^ Td3[Te1[4 * *(v16 - 1)]];
          v21 = *v16;
          *v16 = Td1[Te1[4 * BYTE2(v21)]] ^ Td0[Te1[(v21 >> 22) & 0x3FC]] ^ Td2[Te1[4 * BYTE1(v21)]] ^ Td3[Te1[4 * *v16]];
          v16 += 4;
          ++v17;
        }
        while (v17 < key->rounds);
      }
    }
    return 0;
  }
  return result;
}

void AES_encrypt(const unsigned __int8 *in, unsigned __int8 *out, const AES_KEY *key)
{
  unsigned int v3;
  unsigned int v4;
  unsigned int v5;
  unsigned int v6;
  unsigned int *v7;
  int i;
  unsigned int v9;
  unsigned int v10;
  unsigned int v11;
  unsigned int v12;
  unsigned int v13;
  unsigned int v14;
  int v15;
  unsigned int v16;
  int v17;
  int v18;
  unsigned int v19;
  int v20;
  int v21;
  unsigned int v22;
  unsigned int v23;
  unsigned int v24;
  unsigned int v25;
  int v26;
  int v27;
  unsigned int *v28;

  v3 = bswap32(*(_DWORD *)in) ^ key->rd_key[0];
  v4 = bswap32(*((_DWORD *)in + 1)) ^ key->rd_key[1];
  v5 = bswap32(*((_DWORD *)in + 2)) ^ key->rd_key[2];
  v6 = bswap32(*((_DWORD *)in + 3)) ^ key->rd_key[3];
  v7 = &key->rd_key[6];
  for (i = (key->rounds >> 1) - 1; ; --i)
  {
    v9 = *(_DWORD *)&Te1[4 * BYTE2(v4)] ^ *(_DWORD *)&Te0[4 * HIBYTE(v3)] ^ *(_DWORD *)&Te2[4 * BYTE1(v5)] ^ *(_DWORD *)&Te3[4 * v6] ^ *(v7 - 2);
    v10 = *(_DWORD *)&Te1[4 * BYTE2(v5)] ^ *(_DWORD *)&Te0[4 * HIBYTE(v4)] ^ *(_DWORD *)&Te2[4 * BYTE1(v6)] ^ *(_DWORD *)&Te3[4 * v3] ^ *(v7 - 1);
    v11 = *(_DWORD *)&Te1[4 * BYTE2(v6)] ^ *(_DWORD *)&Te0[4 * HIBYTE(v5)] ^ *(_DWORD *)&Te2[4 * BYTE1(v3)] ^ *(_DWORD *)&Te3[4 * v4] ^ *v7;
    v12 = *(_DWORD *)&Te1[4 * BYTE2(v3)] ^ *(_DWORD *)&Te0[4 * HIBYTE(v6)] ^ *(_DWORD *)&Te2[4 * BYTE1(v4)] ^ *(_DWORD *)&Te3[4 * v5] ^ v7[1];
    v13 = HIBYTE(v9);
    v14 = HIBYTE(v10);
    v15 = BYTE1(v12);
    v16 = HIBYTE(v11);
    v17 = BYTE2(v12);
    v18 = BYTE1(v9);
    v19 = HIBYTE(v12);
    v20 = BYTE2(v9);
    if (!i)
      break;
    v21 = *(_DWORD *)&Te1[4 * BYTE2(v10)] ^ *(_DWORD *)&Te0[4 * v13] ^ *(_DWORD *)&Te2[4 * BYTE1(v11)] ^ *(_DWORD *)&Te3[4 * v12];
    v22 = v7[2];
    v23 = v7[3];
    v24 = v7[4];
    v25 = v7[5];
    v7 += 8;
    v3 = v21 ^ v22;
    v4 = *(_DWORD *)&Te1[4 * BYTE2(v11)] ^ *(_DWORD *)&Te0[4 * v14] ^ *(_DWORD *)&Te2[4 * v15] ^ *(_DWORD *)&Te3[4 * v9] ^ v23;
    v26 = *(_DWORD *)&Te0[4 * v19];
    v27 = *(_DWORD *)&Te1[4 * v20];
    v5 = *(_DWORD *)&Te1[4 * v17] ^ *(_DWORD *)&Te0[4 * v16] ^ *(_DWORD *)&Te2[4 * v18] ^ *(_DWORD *)&Te3[4 * v10] ^ v24;
    v6 = v27 ^ v26 ^ *(_DWORD *)&Te2[4 * BYTE1(v10)] ^ *(_DWORD *)&Te3[4 * v11] ^ v25;
  }
  v28 = &key->rd_key[8 * ((key->rounds >> 1) - 1)];
  *(_DWORD *)out = bswap32(((Te2[4 * v13 + 3] << 24) | (Te3[4 * BYTE2(v10) + 2] << 16) | (Te0[4 * BYTE1(v11) + 1] << 8) | Te1[4 * v12]) ^ v28[8]);
  *((_DWORD *)out + 1) = bswap32(((Te2[4 * v14 + 3] << 24) | (Te3[4 * BYTE2(v11) + 2] << 16) | (Te0[4 * BYTE1(v12) + 1] << 8) | Te1[4 * v9]) ^ v28[9]);
  *((_DWORD *)out + 2) = bswap32(((Te2[4 * v16 + 3] << 24) | (Te3[4 * BYTE2(v12) + 2] << 16) | (Te0[4 * BYTE1(v9) + 1] << 8) | Te1[4 * v10]) ^ v28[10]);
  *((_DWORD *)out + 3) = bswap32(((Te2[4 * v19 + 3] << 24) | (Te3[4 * BYTE2(v9) + 2] << 16) | (Te0[4 * BYTE1(v10) + 1] << 8) | Te1[4 * v11]) ^ v28[11]);
}

void AES_decrypt(const unsigned __int8 *in, unsigned __int8 *out, const AES_KEY *key)
{
  unsigned int v3;
  unsigned int v4;
  unsigned int v5;
  unsigned int v6;
  unsigned int *v7;
  int i;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unsigned int v13;
  unsigned int v14;
  unsigned int *v15;

  v3 = bswap32(*(_DWORD *)in) ^ key->rd_key[0];
  v4 = bswap32(*((_DWORD *)in + 1)) ^ key->rd_key[1];
  v5 = bswap32(*((_DWORD *)in + 2)) ^ key->rd_key[2];
  v6 = bswap32(*((_DWORD *)in + 3)) ^ key->rd_key[3];
  v7 = &key->rd_key[6];
  for (i = (key->rounds >> 1) - 1; ; --i)
  {
    v9 = Td1[BYTE2(v6)] ^ Td0[HIBYTE(v3)] ^ Td2[BYTE1(v5)] ^ Td3[v4] ^ *(v7 - 2);
    v10 = Td1[BYTE2(v3)] ^ Td0[HIBYTE(v4)] ^ Td2[BYTE1(v6)] ^ Td3[v5] ^ *(v7 - 1);
    v11 = Td1[BYTE2(v4)] ^ Td0[HIBYTE(v5)] ^ Td2[BYTE1(v3)] ^ Td3[v6] ^ *v7;
    v12 = Td1[BYTE2(v5)] ^ Td0[HIBYTE(v6)] ^ Td2[BYTE1(v4)] ^ Td3[v3] ^ v7[1];
    if (!i)
      break;
    v3 = Td1[BYTE2(v12)] ^ Td0[BYTE3(v9)] ^ Td2[BYTE1(v11)] ^ Td3[v10] ^ v7[2];
    v4 = Td1[BYTE2(v9)] ^ Td0[BYTE3(v10)] ^ Td2[BYTE1(v12)] ^ Td3[v11] ^ v7[3];
    v13 = v7[4];
    v14 = v7[5];
    v7 += 8;
    v5 = Td1[BYTE2(v10)] ^ Td0[BYTE3(v11)] ^ Td2[BYTE1(v9)] ^ Td3[v12] ^ v13;
    v6 = Td1[BYTE2(v11)] ^ Td0[BYTE3(v12)] ^ Td2[BYTE1(v10)] ^ Td3[v9] ^ v14;
  }
  v15 = &key->rd_key[8 * ((key->rounds >> 1) - 1)];
  *(_DWORD *)out = bswap32(((Td4[v9 >> 24] << 24) | (Td4[BYTE2(v12)] << 16) | (Td4[BYTE1(v11)] << 8) | Td4[v10]) ^ v15[8]);
  *((_DWORD *)out + 1) = bswap32(((Td4[v10 >> 24] << 24) | (Td4[BYTE2(v9)] << 16) | (Td4[BYTE1(v12)] << 8) | Td4[v11]) ^ v15[9]);
  *((_DWORD *)out + 2) = bswap32(((Td4[v11 >> 24] << 24) | (Td4[BYTE2(v10)] << 16) | (Td4[BYTE1(v9)] << 8) | Td4[v12]) ^ v15[10]);
  *((_DWORD *)out + 3) = bswap32(((Td4[v12 >> 24] << 24) | (Td4[BYTE2(v11)] << 16) | (Td4[BYTE1(v10)] << 8) | Td4[v9]) ^ v15[11]);
}

char **RSA_PKCS1_OpenSSL()
{
  return &rsa_pkcs1_eay_meth;
}

const RSA_METHOD *RSA_PKCS1_SSLeay(void)
{
  return (const RSA_METHOD *)&rsa_pkcs1_eay_meth;
}

uint64_t RSA_eay_public_encrypt(int a1, const unsigned __int8 *a2, unsigned __int8 *a3, uint64_t a4, int a5)
{
  int v10;
  int v11;
  BN_CTX *v12;
  BN_CTX *v13;
  BIGNUM *v14;
  BIGNUM *v15;
  int v16;
  int v17;
  unsigned __int8 *v18;
  unsigned __int8 *v19;
  uint64_t v20;
  int v21;
  size_t v22;
  int v23;
  int v24;
  int v26;
  int v27;
  int v28;
  size_t v29;

  if (BN_num_bits(*(const BIGNUM **)(a4 + 32)) <= 0x4000)
  {
    if (BN_ucmp(*(const BIGNUM **)(a4 + 32), *(const BIGNUM **)(a4 + 40)) <= 0)
    {
      v10 = 101;
      v11 = 175;
      goto LABEL_19;
    }
    if (BN_num_bits(*(const BIGNUM **)(a4 + 32)) >= 3073 && BN_num_bits(*(const BIGNUM **)(a4 + 40)) >= 65)
    {
      v10 = 101;
      v11 = 182;
      goto LABEL_19;
    }
    v12 = BN_CTX_new();
    if (!v12)
    {
      v19 = 0;
      v22 = 0;
      v20 = 0xFFFFFFFFLL;
LABEL_25:
      freezero(v19, v22);
      return v20;
    }
    v13 = v12;
    BN_CTX_start(v12);
    v14 = BN_CTX_get(v13);
    v15 = BN_CTX_get(v13);
    v16 = BN_num_bits(*(const BIGNUM **)(a4 + 32));
    if (v16 >= -7)
      v17 = v16 + 7;
    else
      v17 = v16 + 14;
    v29 = (uint64_t)v17 >> 3;
    v18 = (unsigned __int8 *)malloc_type_malloc(v29, 0x416763EAuLL);
    v19 = v18;
    if (v14 && v15 && v18)
    {
      v20 = (v17 >> 3);
      switch(a5)
      {
        case 4:
          v21 = RSA_padding_add_PKCS1_OAEP(v18, v20, a2, a1, 0, 0);
          break;
        case 3:
          v21 = RSA_padding_add_none(v18, v20, a2, a1);
          break;
        case 1:
          v21 = RSA_padding_add_PKCS1_type_2(v18, v20, a2, a1);
          break;
        default:
          v23 = 118;
          v24 = 214;
          goto LABEL_22;
      }
      if (v21 < 1 || !BN_bin2bn(v19, v20, v14))
        goto LABEL_23;
      if (BN_ucmp(v14, *(const BIGNUM **)(a4 + 32)) < 0)
      {
        if (((*(_BYTE *)(a4 + 116) & 2) == 0
           || BN_MONT_CTX_set_locked((BN_MONT_CTX **)(a4 + 120), 9, *(const BIGNUM **)(a4 + 32), v13))
          && (*(unsigned int (**)(BIGNUM *, BIGNUM *, _QWORD, _QWORD, BN_CTX *, _QWORD))(*(_QWORD *)(a4 + 16)
                                                                                                  + 48))(v15, v14, *(_QWORD *)(a4 + 40), *(_QWORD *)(a4 + 32), v13, *(_QWORD *)(a4 + 120)))
        {
          v26 = BN_num_bits(v15);
          v27 = v26 + 7;
          if (v26 < -7)
            v27 = v26 + 14;
          v28 = BN_bn2bin(v15, &a3[(int)v20 - (v27 >> 3)]);
          if ((int)v20 > v28)
            bzero(a3, (v20 + ~v28) + 1);
          goto LABEL_24;
        }
LABEL_23:
        v20 = 0xFFFFFFFFLL;
LABEL_24:
        v22 = v29;
        BN_CTX_end(v13);
        BN_CTX_free(v13);
        goto LABEL_25;
      }
      v23 = 132;
      v24 = 225;
    }
    else
    {
      v23 = 65;
      v24 = 197;
    }
LABEL_22:
    ERR_put_error(4, 4095, v23, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/rsa/rsa_eay.c", v24);
    goto LABEL_23;
  }
  v10 = 105;
  v11 = 170;
LABEL_19:
  ERR_put_error(4, 4095, v10, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/rsa/rsa_eay.c", v11);
  return 0xFFFFFFFFLL;
}

uint64_t RSA_eay_public_decrypt(int a1, const unsigned __int8 *a2, unsigned __int8 *a3, uint64_t a4, int a5)
{
  int v10;
  int v11;
  BN_CTX *v12;
  BN_CTX *v13;
  BIGNUM *v14;
  BIGNUM *v15;
  int v16;
  int v17;
  uint64_t v18;
  void *v19;
  void *v20;
  int v21;
  int v22;
  uint64_t v23;
  int v25;
  uint64_t v26;
  int v27;

  if (BN_num_bits(*(const BIGNUM **)(a4 + 32)) <= 0x4000)
  {
    if (BN_ucmp(*(const BIGNUM **)(a4 + 32), *(const BIGNUM **)(a4 + 40)) <= 0)
    {
      v10 = 101;
      v11 = 619;
      goto LABEL_16;
    }
    if (BN_num_bits(*(const BIGNUM **)(a4 + 32)) >= 3073 && BN_num_bits(*(const BIGNUM **)(a4 + 40)) >= 65)
    {
      v10 = 101;
      v11 = 626;
      goto LABEL_16;
    }
    v12 = BN_CTX_new();
    if (!v12)
    {
      v20 = 0;
      v18 = 0;
      v23 = 0xFFFFFFFFLL;
LABEL_22:
      freezero(v20, v18);
      return v23;
    }
    v13 = v12;
    BN_CTX_start(v12);
    v14 = BN_CTX_get(v13);
    v15 = BN_CTX_get(v13);
    v16 = BN_num_bits(*(const BIGNUM **)(a4 + 32));
    v17 = v16 + 7;
    if (v16 < -7)
      v17 = v16 + 14;
    v18 = (uint64_t)v17 >> 3;
    v19 = malloc_type_malloc(v18, 0xA03CDE1uLL);
    v20 = v19;
    if (v14 && v15 && v19)
    {
      if ((int)v18 >= a1)
      {
        if (!BN_bin2bn(a2, a1, v14))
          goto LABEL_20;
        if (BN_ucmp(v14, *(const BIGNUM **)(a4 + 32)) < 0)
        {
          if ((*(_BYTE *)(a4 + 116) & 2) != 0
            && !BN_MONT_CTX_set_locked((BN_MONT_CTX **)(a4 + 120), 9, *(const BIGNUM **)(a4 + 32), v13)
            || !(*(unsigned int (**)(BIGNUM *, BIGNUM *, _QWORD, _QWORD, BN_CTX *, _QWORD))(*(_QWORD *)(a4 + 16) + 48))(v15, v14, *(_QWORD *)(a4 + 40), *(_QWORD *)(a4 + 32), v13, *(_QWORD *)(a4 + 120)))
          {
            goto LABEL_20;
          }
          if (a5 == 5)
          {
            if ((*v15->d & 0xF) != 0xC && !BN_sub(v15, *(const BIGNUM **)(a4 + 32), v15))
              goto LABEL_20;
            v25 = BN_bn2bin(v15, (unsigned __int8 *)v20);
            v26 = RSA_padding_check_X931(a3, v18, (const unsigned __int8 *)v20, v25, v18);
          }
          else
          {
            v27 = BN_bn2bin(v15, (unsigned __int8 *)v20);
            if (a5 == 3)
            {
              v26 = RSA_padding_check_none(a3, v18, (const unsigned __int8 *)v20, v27, v18);
            }
            else
            {
              if (a5 != 1)
              {
                v21 = 118;
                v22 = 688;
                goto LABEL_19;
              }
              v26 = RSA_padding_check_PKCS1_type_1(a3, v18, (const unsigned __int8 *)v20, v27, v18);
            }
          }
          v23 = v26;
          if ((v26 & 0x80000000) != 0)
            ERR_put_error(4, 4095, 114, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/rsa/rsa_eay.c", 692);
          goto LABEL_21;
        }
        v21 = 132;
        v22 = 656;
      }
      else
      {
        v21 = 108;
        v22 = 648;
      }
    }
    else
    {
      v21 = 65;
      v22 = 641;
    }
LABEL_19:
    ERR_put_error(4, 4095, v21, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/rsa/rsa_eay.c", v22);
LABEL_20:
    v23 = 0xFFFFFFFFLL;
LABEL_21:
    BN_CTX_end(v13);
    BN_CTX_free(v13);
    goto LABEL_22;
  }
  v10 = 105;
  v11 = 614;
LABEL_16:
  ERR_put_error(4, 4095, v10, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/rsa/rsa_eay.c", v11);
  return 0xFFFFFFFFLL;
}

uint64_t RSA_eay_private_encrypt(int a1, const unsigned __int8 *a2, unsigned __int8 *a3, RSA *a4, int a5)
{
  BN_CTX *v10;
  BN_CTX *v11;
  BIGNUM *v12;
  BIGNUM *v13;
  int v14;
  int v15;
  size_t v16;
  unsigned __int8 *v17;
  unsigned __int8 *v18;
  uint64_t v19;
  int v20;
  int v21;
  int v22;
  int flags;
  BN_BLINDING *blinding;
  BN_BLINDING *v26;
  BIGNUM *v27;
  int v28;
  __n128 v29;
  int v30;
  int v31;
  int v32;
  BIGNUM *r;
  unsigned __int8 *v34;
  BIGNUM v35;
  int v36;

  v36 = 0;
  v10 = BN_CTX_new();
  if (v10)
  {
    v11 = v10;
    v34 = a3;
    BN_CTX_start(v10);
    v12 = BN_CTX_get(v11);
    v13 = BN_CTX_get(v11);
    v14 = BN_num_bits(a4->n);
    if (v14 >= -7)
      v15 = v14 + 7;
    else
      v15 = v14 + 14;
    v16 = (uint64_t)v15 >> 3;
    v17 = (unsigned __int8 *)malloc_type_malloc(v16, 0x6D86A53EuLL);
    v18 = v17;
    if (v12 && v13 && v17)
    {
      v19 = (v15 >> 3);
      switch(a5)
      {
        case 5:
          v20 = RSA_padding_add_X931(v17, v19, a2, a1);
          break;
        case 3:
          v20 = RSA_padding_add_none(v17, v19, a2, a1);
          break;
        case 1:
          v20 = RSA_padding_add_PKCS1_type_1(v17, v19, a2, a1);
          break;
        default:
          v21 = 118;
          v22 = 392;
          goto LABEL_21;
      }
      if (v20 < 1 || !BN_bin2bn(v18, v19, v12))
        goto LABEL_22;
      if (BN_ucmp(v12, a4->n) < 0)
      {
        flags = a4->flags;
        if ((flags & 2) != 0)
        {
          if (!BN_MONT_CTX_set_locked(&a4->_method_mod_n, 9, a4->n, v11))
            goto LABEL_22;
          flags = a4->flags;
        }
        if ((flags & 0x80) != 0)
        {
          v26 = 0;
          r = 0;
          LOBYTE(v28) = flags;
        }
        else
        {
          blinding = rsa_get_blinding(a4, &v36, v11);
          if (!blinding)
          {
            v21 = 68;
            v22 = 416;
            goto LABEL_21;
          }
          v26 = blinding;
          if (v36)
          {
            v27 = 0;
          }
          else
          {
            v27 = BN_CTX_get(v11);
            if (!v27)
            {
              v21 = 65;
              v22 = 423;
              goto LABEL_21;
            }
          }
          r = v27;
          if (!rsa_blinding_convert(v26, v12, v27, v11))
            goto LABEL_22;
          v28 = a4->flags;
        }
        if ((v28 & 0x20) != 0 || a4->p && a4->q && a4->dmp1 && a4->dmq1 && a4->iqmp)
        {
          if (!((unsigned int (*)(BIGNUM *, BIGNUM *, RSA *, BN_CTX *))a4->meth->rsa_mod_exp)(v13, v12, a4, v11))goto LABEL_22;
        }
        else
        {
          memset(&v35, 0, sizeof(v35));
          BN_init(&v35);
          v29 = BN_with_flags((__n128 *)&v35, (__n128 *)a4->d, 4);
          if (!((unsigned int (*)(BIGNUM *, BIGNUM *, BIGNUM *, BIGNUM *, BN_CTX *, BN_MONT_CTX *, __n128))a4->meth->bn_mod_exp)(v13, v12, &v35, a4->n, v11, a4->_method_mod_n, v29))goto LABEL_22;
        }
        if ((flags & 0x80) == 0 && !BN_BLINDING_invert_ex(v13, r, v26, v11))
          goto LABEL_22;
        if (a5 == 5)
        {
          if (!BN_sub(v12, a4->n, v13))
            goto LABEL_22;
          if (BN_cmp(v13, v12) > 0)
            v13 = v12;
        }
        v30 = BN_num_bits(v13);
        v31 = v30 + 7;
        if (v30 < -7)
          v31 = v30 + 14;
        v32 = BN_bn2bin(v13, &v34[(int)v19 - (v31 >> 3)]);
        if ((int)v19 > v32)
          bzero(v34, (v19 + ~v32) + 1);
        goto LABEL_23;
      }
      v21 = 132;
      v22 = 403;
    }
    else
    {
      v21 = 65;
      v22 = 377;
    }
LABEL_21:
    ERR_put_error(4, 4095, v21, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/rsa/rsa_eay.c", v22);
LABEL_22:
    v19 = 0xFFFFFFFFLL;
LABEL_23:
    BN_CTX_end(v11);
    BN_CTX_free(v11);
    goto LABEL_24;
  }
  v18 = 0;
  v16 = 0;
  v19 = 0xFFFFFFFFLL;
LABEL_24:
  freezero(v18, v16);
  return v19;
}

uint64_t RSA_eay_private_decrypt(int a1, const unsigned __int8 *a2, unsigned __int8 *a3, RSA *a4, int a5)
{
  BN_CTX *v10;
  BN_CTX *v11;
  BIGNUM *v12;
  BIGNUM *v13;
  int v14;
  int v15;
  uint64_t v16;
  unsigned __int8 *v17;
  unsigned __int8 *v18;
  int v19;
  int v20;
  uint64_t v21;
  int flags;
  BN_BLINDING *blinding;
  BN_BLINDING *v25;
  BIGNUM *v26;
  int v27;
  __n128 v28;
  int v29;
  uint64_t v30;
  BIGNUM *r;
  BIGNUM v32;
  int v33;

  v33 = 0;
  v10 = BN_CTX_new();
  if (v10)
  {
    v11 = v10;
    BN_CTX_start(v10);
    v12 = BN_CTX_get(v11);
    v13 = BN_CTX_get(v11);
    v14 = BN_num_bits(a4->n);
    v15 = v14 + 7;
    if (v14 < -7)
      v15 = v14 + 14;
    v16 = (uint64_t)v15 >> 3;
    v17 = (unsigned __int8 *)malloc_type_malloc(v16, 0x82DCF202uLL);
    v18 = v17;
    if (v12 && v13 && v17)
    {
      if ((int)v16 >= a1)
      {
        if (!BN_bin2bn(a2, a1, v12))
          goto LABEL_12;
        if (BN_ucmp(v12, a4->n) < 0)
        {
          flags = a4->flags;
          if ((flags & 2) != 0)
          {
            if (!BN_MONT_CTX_set_locked(&a4->_method_mod_n, 9, a4->n, v11))
              goto LABEL_12;
            flags = a4->flags;
          }
          if ((flags & 0x80) != 0)
          {
            v25 = 0;
            r = 0;
            LOBYTE(v27) = flags;
          }
          else
          {
            blinding = rsa_get_blinding(a4, &v33, v11);
            if (!blinding)
            {
              v19 = 68;
              v20 = 535;
              goto LABEL_11;
            }
            v25 = blinding;
            if (v33)
            {
              v26 = 0;
            }
            else
            {
              v26 = BN_CTX_get(v11);
              if (!v26)
              {
                v19 = 65;
                v20 = 542;
                goto LABEL_11;
              }
            }
            r = v26;
            if (!rsa_blinding_convert(v25, v12, v26, v11))
              goto LABEL_12;
            v27 = a4->flags;
          }
          if ((v27 & 0x20) != 0 || a4->p && a4->q && a4->dmp1 && a4->dmq1 && a4->iqmp)
          {
            if (!((unsigned int (*)(BIGNUM *, BIGNUM *, RSA *, BN_CTX *))a4->meth->rsa_mod_exp)(v13, v12, a4, v11))goto LABEL_12;
          }
          else
          {
            memset(&v32, 0, sizeof(v32));
            BN_init(&v32);
            v28 = BN_with_flags((__n128 *)&v32, (__n128 *)a4->d, 4);
            if (!((unsigned int (*)(BIGNUM *, BIGNUM *, BIGNUM *, BIGNUM *, BN_CTX *, BN_MONT_CTX *, __n128))a4->meth->bn_mod_exp)(v13, v12, &v32, a4->n, v11, a4->_method_mod_n, v28))goto LABEL_12;
          }
          if ((flags & 0x80) == 0 && !BN_BLINDING_invert_ex(v13, r, v25, v11))
            goto LABEL_12;
          v29 = BN_bn2bin(v13, v18);
          switch(a5)
          {
            case 4:
              v30 = RSA_padding_check_PKCS1_OAEP(a3, v16, v18, v29, v16, 0, 0);
              break;
            case 3:
              v30 = RSA_padding_check_none(a3, v16, v18, v29, v16);
              break;
            case 1:
              v30 = RSA_padding_check_PKCS1_type_2(a3, v16, v18, v29, v16);
              break;
            default:
              v19 = 118;
              v20 = 587;
              goto LABEL_11;
          }
          v21 = v30;
          if ((v30 & 0x80000000) != 0)
            ERR_put_error(4, 4095, 114, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/rsa/rsa_eay.c", 591);
          goto LABEL_13;
        }
        v19 = 132;
        v20 = 522;
      }
      else
      {
        v19 = 108;
        v20 = 513;
      }
    }
    else
    {
      v19 = 65;
      v20 = 506;
    }
LABEL_11:
    ERR_put_error(4, 4095, v19, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/rsa/rsa_eay.c", v20);
LABEL_12:
    v21 = 0xFFFFFFFFLL;
LABEL_13:
    BN_CTX_end(v11);
    BN_CTX_free(v11);
    goto LABEL_14;
  }
  v18 = 0;
  v16 = 0;
  v21 = 0xFFFFFFFFLL;
LABEL_14:
  freezero(v18, v16);
  return v21;
}

uint64_t RSA_eay_mod_exp(BIGNUM *a1, __n128 *a2, uint64_t a3, BN_CTX *ctx)
{
  BIGNUM *v8;
  BIGNUM *v9;
  BIGNUM *v10;
  BIGNUM *v11;
  int v12;
  __n128 v13;
  __n128 v14;
  __n128 v15;
  uint64_t v16;
  BIGNUM v18;
  BIGNUM mod;
  BIGNUM v20;
  BIGNUM v21;
  BIGNUM v22;
  BIGNUM v23;

  memset(&v23, 0, sizeof(v23));
  memset(&v22, 0, sizeof(v22));
  memset(&v21, 0, sizeof(v21));
  memset(&v20, 0, sizeof(v20));
  BN_CTX_start(ctx);
  v8 = BN_CTX_get(ctx);
  v9 = BN_CTX_get(ctx);
  v10 = BN_CTX_get(ctx);
  if (!v8 || !v9 || (v11 = v10) == 0)
  {
    ERR_put_error(4, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/rsa/rsa_eay.c", 715);
    goto LABEL_34;
  }
  memset(&mod, 0, sizeof(mod));
  memset(&v18, 0, sizeof(v18));
  BN_init(&mod);
  BN_init(&v18);
  BN_with_flags((__n128 *)&mod, *(__n128 **)(a3 + 56), 4);
  BN_with_flags((__n128 *)&v18, *(__n128 **)(a3 + 64), 4);
  v12 = *(_DWORD *)(a3 + 116);
  if ((v12 & 4) == 0)
    goto LABEL_8;
  if (!BN_MONT_CTX_set_locked((BN_MONT_CTX **)(a3 + 128), 9, &mod, ctx)
    || !BN_MONT_CTX_set_locked((BN_MONT_CTX **)(a3 + 136), 9, &v18, ctx))
  {
LABEL_34:
    v16 = 0;
    goto LABEL_35;
  }
  v12 = *(_DWORD *)(a3 + 116);
LABEL_8:
  if ((v12 & 2) != 0 && !BN_MONT_CTX_set_locked((BN_MONT_CTX **)(a3 + 120), 9, *(const BIGNUM **)(a3 + 32), ctx))
    goto LABEL_34;
  BN_init(&v21);
  BN_with_flags((__n128 *)&v21, a2, 4);
  if (!BN_mod_ct(v8, &v21, *(const BIGNUM **)(a3 + 64), ctx))
    goto LABEL_34;
  BN_init(&v22);
  v13 = BN_with_flags((__n128 *)&v22, (__n128 *)*(_QWORD *)(a3 + 80), 4);
  if (!(*(unsigned int (**)(BIGNUM *, BIGNUM *, BIGNUM *, _QWORD, BN_CTX *, _QWORD, __n128))(*(_QWORD *)(a3 + 16) + 48))(v9, v8, &v22, *(_QWORD *)(a3 + 64), ctx, *(_QWORD *)(a3 + 136), v13))goto LABEL_34;
  BN_init(&v21);
  BN_with_flags((__n128 *)&v21, a2, 4);
  if (!BN_mod_ct(v8, &v21, *(const BIGNUM **)(a3 + 56), ctx))
    goto LABEL_34;
  BN_init(&v23);
  v14 = BN_with_flags((__n128 *)&v23, (__n128 *)*(_QWORD *)(a3 + 72), 4);
  if (!(*(unsigned int (**)(BIGNUM *, BIGNUM *, BIGNUM *, _QWORD, BN_CTX *, _QWORD, __n128))(*(_QWORD *)(a3 + 16) + 48))(a1, v8, &v23, *(_QWORD *)(a3 + 56), ctx, *(_QWORD *)(a3 + 128), v14)|| !BN_sub(a1, a1, v9)|| BN_is_negative((uint64_t)a1) && !BN_add(a1, a1, *(const BIGNUM **)(a3 + 56)))
  {
    goto LABEL_34;
  }
  if (!BN_mul(v8, a1, *(const BIGNUM **)(a3 + 88), ctx))
    goto LABEL_34;
  BN_init(&v20);
  BN_with_flags((__n128 *)&v20, (__n128 *)v8, 4);
  if (!BN_mod_ct(a1, &v20, *(const BIGNUM **)(a3 + 56), ctx)
    || BN_is_negative((uint64_t)a1) && !BN_add(a1, a1, *(const BIGNUM **)(a3 + 56)))
  {
    goto LABEL_34;
  }
  if (!BN_mul(v8, a1, *(const BIGNUM **)(a3 + 64), ctx) || !BN_add(a1, v8, v9))
    goto LABEL_34;
  if (*(_QWORD *)(a3 + 40) && *(_QWORD *)(a3 + 32))
  {
    if (!(*(unsigned int (**)(BIGNUM *, BIGNUM *))(*(_QWORD *)(a3 + 16) + 48))(v11, a1)
      || !BN_sub(v11, v11, (const BIGNUM *)a2)
      || !BN_mod_ct(v11, v11, *(const BIGNUM **)(a3 + 32), ctx)
      || BN_is_negative((uint64_t)v11) && !BN_add(v11, v11, *(const BIGNUM **)(a3 + 32)))
    {
      goto LABEL_34;
    }
    if (!BN_is_zero((uint64_t)v11))
    {
      memset(&mod, 0, sizeof(mod));
      BN_init(&mod);
      v15 = BN_with_flags((__n128 *)&mod, (__n128 *)*(_QWORD *)(a3 + 48), 4);
      if (!(*(unsigned int (**)(BIGNUM *, __n128 *, BIGNUM *, _QWORD, BN_CTX *, _QWORD, __n128))(*(_QWORD *)(a3 + 16) + 48))(a1, a2, &mod, *(_QWORD *)(a3 + 32), ctx, *(_QWORD *)(a3 + 120), v15))goto LABEL_34;
    }
  }
  v16 = 1;
LABEL_35:
  BN_CTX_end(ctx);
  return v16;
}

uint64_t RSA_eay_init(uint64_t a1)
{
  *(_DWORD *)(a1 + 116) |= 6u;
  return 1;
}

uint64_t RSA_eay_finish(BN_MONT_CTX **a1)
{
  BN_MONT_CTX_free(a1[15]);
  BN_MONT_CTX_free(a1[16]);
  BN_MONT_CTX_free(a1[17]);
  return 1;
}

BN_BLINDING *rsa_get_blinding(RSA *a1, _DWORD *a2, BN_CTX *a3)
{
  char *bignum_data;
  BN_BLINDING *blinding;
  unint64_t *v8;
  int v9;
  unint64_t v11[2];

  v11[0] = 0;
  v11[1] = 0;
  CRYPTO_lock(5, 9, 0, 0);
  bignum_data = a1->bignum_data;
  blinding = (BN_BLINDING *)bignum_data;
  if (!bignum_data)
  {
    CRYPTO_lock(6, 9, 0, 0);
    CRYPTO_lock(9, 9, 0, 0);
    blinding = (BN_BLINDING *)a1->bignum_data;
    if (!blinding)
    {
      blinding = RSA_setup_blinding(a1, a3);
      a1->bignum_data = (char *)blinding;
      if (!blinding)
      {
LABEL_9:
        v9 = 10;
        goto LABEL_14;
      }
    }
  }
  CRYPTO_THREADID_current(v11);
  v8 = (unint64_t *)BN_BLINDING_thread_id((uint64_t)blinding);
  if (CRYPTO_THREADID_cmp(v11, v8))
  {
    *a2 = 0;
    blinding = a1->blinding;
    if (!blinding)
    {
      if (!bignum_data || (CRYPTO_lock(6, 9, 0, 0), CRYPTO_lock(9, 9, 0, 0), (blinding = a1->blinding) == 0))
      {
        blinding = RSA_setup_blinding(a1, a3);
        a1->blinding = blinding;
      }
      goto LABEL_9;
    }
  }
  else
  {
    *a2 = 1;
  }
  if (bignum_data)
    v9 = 6;
  else
    v9 = 10;
LABEL_14:
  CRYPTO_lock(v9, 9, 0, 0);
  return blinding;
}

uint64_t rsa_blinding_convert(BN_BLINDING *b, BIGNUM *n, BIGNUM *a3, BN_CTX *a4)
{
  uint64_t v8;

  if (!a3)
    return BN_BLINDING_convert_ex(n, 0, b, a4);
  CRYPTO_lock(9, 25, 0, 0);
  v8 = BN_BLINDING_convert_ex(n, a3, b, a4);
  CRYPTO_lock(10, 25, 0, 0);
  return v8;
}

EVP_PKEY **EVP_DigestSignInit(uint64_t a1, _QWORD *a2, const EVP_MD *a3, ENGINE *a4, uint64_t a5)
{
  return do_sigver_init(a1, a2, a3, a4, a5, 0);
}

EVP_PKEY **do_sigver_init(uint64_t a1, _QWORD *a2, const EVP_MD *digestbyname, ENGINE *a4, uint64_t a5, int a6)
{
  EVP_PKEY **result;
  const char *v13;
  uint64_t v14;
  _QWORD *v15;
  int (*v16)(void);
  uint64_t v17;
  int v18;
  int (*v19)(void);
  int v20;
  int v21;

  result = *(EVP_PKEY ***)(a1 + 32);
  if (!result)
  {
    result = EVP_PKEY_CTX_new(a5, a4);
    *(_QWORD *)(a1 + 32) = result;
    if (!result)
      return result;
  }
  if (!digestbyname && ((*result)->save_type & 4) == 0)
  {
    if ((int)EVP_PKEY_get_default_digest_nid(a5) <= 0
      || (v13 = OBJ_nid2sn(0), (digestbyname = EVP_get_digestbyname(v13)) == 0))
    {
      ERR_put_error(6, 4095, 158, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/m_sigver.c", 92);
      return 0;
    }
  }
  v14 = *(_QWORD *)(a1 + 32);
  v15 = *(_QWORD **)v14;
  if (a6)
  {
    v16 = (int (*)(void))v15[16];
    if (v16)
    {
      if (v16() >= 1)
      {
        v17 = *(_QWORD *)(a1 + 32);
        v18 = 128;
LABEL_15:
        *(_DWORD *)(v17 + 32) = v18;
        goto LABEL_24;
      }
      return 0;
    }
    if (v15[27])
    {
      v20 = 16;
LABEL_20:
      *(_DWORD *)(v14 + 32) = v20;
      *(_QWORD *)(a1 + 40) = update_oneshot_only;
      goto LABEL_24;
    }
    v21 = EVP_PKEY_verify_init((uint64_t *)v14);
  }
  else
  {
    v19 = (int (*)(void))v15[14];
    if (v19)
    {
      if (v19() >= 1)
      {
        v17 = *(_QWORD *)(a1 + 32);
        v18 = 64;
        goto LABEL_15;
      }
      return 0;
    }
    if (v15[26])
    {
      v20 = 8;
      goto LABEL_20;
    }
    v21 = EVP_PKEY_sign_init((uint64_t *)v14);
  }
  if (v21 < 1)
    return 0;
LABEL_24:
  if ((int)EVP_PKEY_CTX_ctrl(*(uint64_t **)(a1 + 32), -1, 248) < 1)
    return 0;
  if (a2)
    *a2 = *(_QWORD *)(a1 + 32);
  if ((*(_BYTE *)(**(_QWORD **)(a1 + 32) + 4) & 4) != 0)
    return (EVP_PKEY **)1;
  else
    return (EVP_PKEY **)(EVP_DigestInit_ex((EVP_MD_CTX *)a1, digestbyname, a4) != 0);
}

EVP_PKEY **EVP_DigestVerifyInit(uint64_t a1, _QWORD *a2, const EVP_MD *a3, ENGINE *a4, uint64_t a5)
{
  return do_sigver_init(a1, a2, a3, a4, a5, 1);
}

uint64_t EVP_DigestSignFinal(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t (*v8)(void);
  uint64_t v9;
  EVP_PKEY **v10;
  EVP_PKEY **v11;
  int v12;
  int v14;
  unsigned int v15;
  unsigned int s;
  EVP_MD_CTX ctx;
  __int128 v18;
  unsigned __int8 md[64];
  uint64_t v20;

  v20 = *MEMORY[0x24BDAC8D0];
  v6 = *(_QWORD *)(a1 + 32);
  v7 = *(_QWORD *)v6;
  if ((*(_BYTE *)(*(_QWORD *)v6 + 4) & 4) != 0)
  {
    if (!a2)
      return (*(uint64_t (**)(void))(v7 + 120))();
    v10 = (EVP_PKEY **)EVP_PKEY_CTX_dup(v6);
    if (v10)
    {
      v11 = v10;
      v9 = (*(uint64_t (**)(EVP_PKEY **, uint64_t, _QWORD *, uint64_t))&(*v10)[3].type)(v10, a2, a3, a1);
      EVP_PKEY_CTX_free(v11);
      return v9;
    }
    return 0;
  }
  v8 = *(uint64_t (**)(void))(v7 + 120);
  if (!a2)
  {
    if (v8)
    {
      v12 = v8();
    }
    else
    {
      v15 = EVP_MD_size(*(const EVP_MD **)a1);
      if ((v15 & 0x80000000) != 0)
        return 0;
      v12 = EVP_PKEY_sign(*(uint64_t **)(a1 + 32), 0, a3, 0, v15);
    }
    return v12 >= 1;
  }
  v18 = 0u;
  memset(&ctx, 0, sizeof(ctx));
  s = 0;
  EVP_MD_CTX_init(&ctx);
  if (!EVP_MD_CTX_copy_ex(&ctx, (const EVP_MD_CTX *)a1))
    return 0;
  if (!v8)
  {
    v14 = EVP_DigestFinal_ex(&ctx, md, &s);
    EVP_MD_CTX_cleanup(&ctx);
    return v14 && (int)EVP_PKEY_sign(*(uint64_t **)(a1 + 32), a2, a3, (uint64_t)md, s) > 0;
  }
  v9 = (*(uint64_t (**)(_QWORD, uint64_t, _QWORD *, EVP_MD_CTX *))(*(_QWORD *)v18 + 120))(v18, a2, a3, &ctx);
  EVP_MD_CTX_cleanup(&ctx);
  return v9;
}

uint64_t EVP_DigestSign(EVP_MD_CTX *ctx, uint64_t a2, _QWORD *a3, void *d, size_t cnt)
{
  uint64_t (*v8)(EVP_MD_CTX *, uint64_t, _QWORD *, void *, size_t);

  v8 = *(uint64_t (**)(EVP_MD_CTX *, uint64_t, _QWORD *, void *, size_t))(*(_QWORD *)ctx[1].digest + 208);
  if (v8)
    return v8(ctx, a2, a3, d, cnt);
  if (a2 && EVP_DigestUpdate(ctx, d, cnt) < 1)
    return 0;
  return EVP_DigestSignFinal((uint64_t)ctx, a2, a3);
}

uint64_t EVP_DigestVerifyFinal(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  int v8;
  unsigned int s;
  EVP_MD_CTX ctx;
  __int128 v12;
  unsigned __int8 md[64];
  uint64_t v14;

  v14 = *MEMORY[0x24BDAC8D0];
  v12 = 0u;
  memset(&ctx, 0, sizeof(ctx));
  s = 0;
  v6 = *(_QWORD *)(**(_QWORD **)(a1 + 32) + 136);
  EVP_MD_CTX_init(&ctx);
  if (!EVP_MD_CTX_copy_ex(&ctx, (const EVP_MD_CTX *)a1))
    return 0xFFFFFFFFLL;
  if (v6)
  {
    v7 = (*(uint64_t (**)(_QWORD, uint64_t, uint64_t, EVP_MD_CTX *))(*(_QWORD *)v12 + 136))(v12, a2, a3, &ctx);
    EVP_MD_CTX_cleanup(&ctx);
  }
  else
  {
    v8 = EVP_DigestFinal_ex(&ctx, md, &s);
    EVP_MD_CTX_cleanup(&ctx);
    if (v8)
      return EVP_PKEY_verify(*(_DWORD **)(a1 + 32));
    else
      return 0;
  }
  return v7;
}

uint64_t EVP_DigestVerify(EVP_MD_CTX *ctx, uint64_t a2, uint64_t a3, void *d, size_t cnt)
{
  uint64_t (*v8)(EVP_MD_CTX *, uint64_t, uint64_t, void *, size_t);

  v8 = *(uint64_t (**)(EVP_MD_CTX *, uint64_t, uint64_t, void *, size_t))(*(_QWORD *)ctx[1].digest + 216);
  if (v8)
    return v8(ctx, a2, a3, d, cnt);
  if (EVP_DigestUpdate(ctx, d, cnt) < 1)
    return 0xFFFFFFFFLL;
  return EVP_DigestVerifyFinal((uint64_t)ctx, a2, a3);
}

uint64_t update_oneshot_only()
{
  ERR_put_error(6, 4095, 177, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/m_sigver.c", 71);
  return 0;
}

__n128 CRYPTO_cbc128_encrypt(_QWORD *a1, _QWORD *a2, unint64_t a3, uint64_t a4, _OWORD *a5, void (*a6)(_QWORD *, _QWORD *, uint64_t))
{
  unint64_t v9;
  _QWORD *v12;
  _QWORD *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  _BYTE *v17;
  char *v18;
  char v19;
  __n128 result;

  v9 = a3;
  v12 = a5;
  if (a3 >= 0x10)
  {
    do
    {
      v13 = a2;
      *a2 = *v12 ^ *a1;
      a2[1] = v12[1] ^ a1[1];
      a6(a2, a2, a4);
      v9 -= 16;
      a1 += 2;
      a2 += 2;
      v12 = v13;
    }
    while (v9 > 0xF);
    v12 = a2 - 2;
  }
  if (v9)
  {
    v14 = 0;
    v15 = 15;
    if (v9 > 0xF)
      v15 = v9;
    do
    {
      *((_BYTE *)a2 + v14) = *((_BYTE *)v12 + v14) ^ *((_BYTE *)a1 + v14);
      ++v14;
    }
    while (v9 != v14);
    if ((unint64_t)(v14 - 1) <= 0xE)
    {
      v16 = v15 - 2 * v9 + v14 + 1;
      v17 = (char *)a2 + v9;
      v18 = (char *)v12 + v9;
      do
      {
        v19 = *v18++;
        *v17++ = v19;
        --v16;
      }
      while (v16);
    }
    a6(a2, a2, a4);
  }
  else
  {
    a2 = v12;
  }
  result = *(__n128 *)a2;
  *a5 = *(_OWORD *)a2;
  return result;
}

uint64_t CRYPTO_cbc128_decrypt(uint64_t result, uint64_t *a2, unint64_t a3, uint64_t a4, _QWORD *a5, uint64_t (*a6)(_QWORD *, uint64_t *, uint64_t))
{
  unint64_t v9;
  _QWORD *v10;
  uint64_t *v11;
  _QWORD *v12;
  _QWORD *v13;
  uint64_t v14;
  _OWORD *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  _QWORD *v19;
  uint64_t v20;
  uint64_t v21;
  char v22;
  uint64_t v23;
  _BYTE *v24;
  char *v25;
  char v26;
  uint64_t v27;
  uint64_t v28;

  v9 = a3;
  v10 = (_QWORD *)result;
  v27 = 0;
  v28 = 0;
  if ((uint64_t *)result == a2)
  {
    if (a3 < 0x10)
    {
      v19 = (_QWORD *)result;
      if (!a3)
        return result;
      goto LABEL_12;
    }
    do
    {
      result = a6(v10, &v27, a4);
      v16 = v28;
      v17 = *v10;
      *v10 = *a5 ^ v27;
      *a5 = v17;
      v18 = v10[1];
      v10[1] = a5[1] ^ v16;
      a5[1] = v18;
      v9 -= 16;
      v10 += 2;
      v19 = v10;
    }
    while (v9 > 0xF);
  }
  else
  {
    v11 = a2;
    if (a3 < 0x10)
    {
      v15 = a5;
    }
    else
    {
      v12 = a5;
      do
      {
        v13 = v10;
        result = a6(v10, v11, a4);
        v14 = v11[1];
        *v11 ^= *v12;
        v9 -= 16;
        v11[1] = v14 ^ v12[1];
        v10 += 2;
        v11 += 2;
        v12 = v13;
      }
      while (v9 > 0xF);
      v15 = v10 - 2;
    }
    v19 = v10;
    *(_OWORD *)a5 = *v15;
    v10 = v11;
  }
  if (!v9)
    return result;
LABEL_12:
  result = a6(v19, &v27, a4);
  v20 = 0;
  v21 = 15;
  if (v9 > 0xF)
    v21 = v9;
  do
  {
    v22 = *((_BYTE *)v19 + v20);
    *((_BYTE *)v10 + v20) = *((_BYTE *)a5 + v20) ^ *((_BYTE *)&v27 + v20);
    *((_BYTE *)a5 + v20++) = v22;
  }
  while (v9 != v20);
  if ((unint64_t)(v20 - 1) <= 0xE)
  {
    v23 = v21 - 2 * v9 + v20 + 1;
    v24 = (char *)a5 + v9;
    v25 = (char *)v19 + v9;
    do
    {
      v26 = *v25++;
      *v24++ = v26;
      --v23;
    }
    while (v23);
  }
  return result;
}

void ECDH_set_default_method(const ECDH_METHOD *a1)
{
  default_ECDH_method = (uint64_t)a1;
}

const ECDH_METHOD *ECDH_get_default_method(void)
{
  const ECDH_METHOD *result;

  result = (const ECDH_METHOD *)default_ECDH_method;
  if (!default_ECDH_method)
  {
    result = ECDH_OpenSSL();
    default_ECDH_method = (uint64_t)result;
  }
  return result;
}

int ECDH_set_method(EC_KEY *a1, const ECDH_METHOD *a2)
{
  ENGINE **v3;
  ENGINE **v4;

  v3 = (ENGINE **)ecdh_check(a1);
  if (v3)
  {
    v4 = v3;
    ENGINE_finish(v3[1]);
    v4[1] = 0;
    v4[3] = a2;
    LODWORD(v3) = 1;
  }
  return (int)v3;
}

void *ecdh_check(EC_KEY *a1)
{
  void *key_method_data;
  uint64_t v3;
  uint64_t v4;

  key_method_data = EC_KEY_get_key_method_data(a1, (void *(__cdecl *)(void *))ecdh_data_dup, (void (__cdecl *)(void *))ecdh_data_free, (void (__cdecl *)(void *))ecdh_data_free);
  if (!key_method_data)
  {
    key_method_data = ecdh_data_new();
    if (key_method_data)
    {
      EC_KEY_insert_key_method_data(a1, key_method_data, (void *(__cdecl *)(void *))ecdh_data_dup, (void (__cdecl *)(void *))ecdh_data_free, (void (__cdecl *)(void *))ecdh_data_free);
      if (v3)
      {
        v4 = v3;
        ecdh_data_free((uint64_t)key_method_data);
        return (void *)v4;
      }
    }
  }
  return key_method_data;
}

CRYPTO_EX_DATA *ecdh_data_dup(CRYPTO_EX_DATA *result)
{
  if (result)
    return ecdh_data_new();
  return result;
}

void ecdh_data_free(uint64_t a1)
{
  ENGINE_finish(*(ENGINE **)(a1 + 8));
  CRYPTO_free_ex_data(13, (void *)a1, (CRYPTO_EX_DATA *)(a1 + 32));
  freezero((void *)a1, 0x28uLL);
}

CRYPTO_EX_DATA *ecdh_data_new()
{
  CRYPTO_EX_DATA *v0;
  CRYPTO_EX_DATA *v1;
  const ECDH_METHOD *v2;
  ENGINE *default_ECDH;
  const ECDH_METHOD *ECDH;

  v0 = (CRYPTO_EX_DATA *)malloc_type_malloc(0x28uLL, 0x10E00407A09E776uLL);
  v1 = v0;
  if (!v0)
  {
    ERR_put_error(43, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ecdh/ech_lib.c", 128);
    return v1;
  }
  v0->sk = 0;
  v2 = (const ECDH_METHOD *)default_ECDH_method;
  if (!default_ECDH_method)
  {
    v2 = ECDH_OpenSSL();
    default_ECDH_method = (uint64_t)v2;
  }
  *(_QWORD *)&v1[1].dummy = v2;
  *(_QWORD *)&v1->dummy = 0;
  default_ECDH = ENGINE_get_default_ECDH();
  *(_QWORD *)&v1->dummy = default_ECDH;
  if (!default_ECDH)
  {
    ECDH = *(const ECDH_METHOD **)&v1[1].dummy;
    goto LABEL_9;
  }
  ECDH = ENGINE_get_ECDH(default_ECDH);
  *(_QWORD *)&v1[1].dummy = ECDH;
  if (ECDH)
  {
LABEL_9:
    LODWORD(v1[1].sk) = *((_DWORD *)ECDH + 4);
    CRYPTO_new_ex_data(13, v1, v1 + 2);
    return v1;
  }
  ERR_put_error(43, 4095, 38, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ecdh/ech_lib.c", 142);
  ENGINE_finish(*(ENGINE **)&v1->dummy);
  free(v1);
  return 0;
}

int ECDH_get_ex_new_index(uint64_t argl, void *argp, CRYPTO_EX_new *new_func, CRYPTO_EX_dup *dup_func, CRYPTO_EX_free *free_func)
{
  return CRYPTO_get_ex_new_index(13, argl, argp, new_func, dup_func, free_func);
}

int ECDH_set_ex_data(EC_KEY *d, int idx, void *arg)
{
  CRYPTO_EX_DATA *v5;

  v5 = (CRYPTO_EX_DATA *)ecdh_check(d);
  if (v5)
    LODWORD(v5) = CRYPTO_set_ex_data(v5 + 2, idx, arg);
  return (int)v5;
}

void *__cdecl ECDH_get_ex_data(EC_KEY *d, int idx)
{
  void *result;

  result = ecdh_check(d);
  if (result)
    return CRYPTO_get_ex_data((const CRYPTO_EX_DATA *)result + 2, idx);
  return result;
}

uint64_t ECDH_size(const EC_KEY *a1)
{
  const EC_GROUP *v1;
  int degree;
  int v3;

  v1 = EC_KEY_get0_group(a1);
  degree = EC_GROUP_get_degree(v1);
  v3 = degree + 7;
  if (degree < -7)
    v3 = degree + 14;
  return (v3 >> 3);
}

void RC2_ofb64_encrypt(const unsigned __int8 *in, unsigned __int8 *out, uint64_t length, RC2_KEY *schedule, unsigned __int8 *ivec, int *num)
{
  int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  uint64_t v20;
  int v23;
  char v24;
  uint64_t v25;
  uint64_t v26;
  int v27;
  int v28;
  uint64_t v29;

  v29 = *MEMORY[0x24BDAC8D0];
  v7 = *num;
  v8 = *ivec;
  v9 = ivec[1];
  v10 = ivec[2];
  v11 = ivec[3];
  v12 = v8 | ((_DWORD)v9 << 8) | ((_DWORD)v10 << 16) | ((_DWORD)v11 << 24);
  v13 = ivec[4];
  v14 = ivec[5];
  v15 = ivec[6];
  v16 = ivec[7];
  v17 = v13 | ((_DWORD)v14 << 8) | ((_DWORD)v15 << 16) | ((_DWORD)v16 << 24);
  v25 = v8 | (v9 << 8) | (v10 << 16) | (v11 << 24);
  v26 = v13 | (v14 << 8) | (v15 << 16) | (v16 << 24);
  LOBYTE(v27) = v8;
  BYTE1(v27) = v9;
  BYTE2(v27) = v10;
  HIBYTE(v27) = v11;
  LOBYTE(v28) = v13;
  BYTE1(v28) = v14;
  BYTE2(v28) = v15;
  HIBYTE(v28) = v16;
  if (length)
  {
    v20 = length;
    v23 = 0;
    do
    {
      if (!v7)
      {
        RC2_encrypt((unint64_t *)&v25, schedule);
        v12 = v25;
        v17 = v26;
        v27 = v25;
        v28 = v26;
        ++v23;
      }
      v24 = *in++;
      *out++ = *((_BYTE *)&v27 + v7) ^ v24;
      v7 = (v7 + 1) & 7;
      --v20;
    }
    while (v20);
    if (v23)
    {
      *(_DWORD *)ivec = v12;
      *((_DWORD *)ivec + 1) = v17;
    }
  }
  *num = v7;
}

int BN_rand(BIGNUM *rnd, int bits, int top, int bottom)
{
  return bnrand(0, (uint64_t)rnd, bits, top, bottom);
}

uint64_t bnrand(int a1, uint64_t a2, int a3, int a4, int a5)
{
  _BOOL8 v5;
  char v9;
  size_t v10;
  unsigned __int8 *v11;
  unsigned __int8 *v12;
  int v13;
  uint64_t v14;
  char v15;
  int v16;
  unsigned __int8 __buf;

  v5 = a2;
  if (!a2)
  {
    ERR_put_error(3, 4095, 67, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/bn/bn_rand.c", 128);
    return v5;
  }
  if ((a3 & 0x80000000) == 0 && (a3 != 1 || a4 < 1))
  {
    if (!a3)
    {
      BN_zero(a2);
      return 1;
    }
    v9 = a3 + 7;
    v10 = (a3 + 7) >> 3;
    v11 = (unsigned __int8 *)malloc_type_malloc(v10, 0x30A95773uLL);
    v12 = v11;
    if (v11)
    {
      v13 = v9 & 7;
      arc4random_buf(v11, v10);
      if (a1 == 2)
      {
        v14 = 0;
        __buf = 0;
        while (1)
        {
          arc4random_buf(&__buf, 1uLL);
          if (v14)
          {
            if ((char)__buf < 0)
              break;
          }
          if (__buf < 0x2Au)
          {
            v15 = 0;
            goto LABEL_18;
          }
          if (__buf <= 0x53u)
          {
            v15 = -1;
            goto LABEL_18;
          }
LABEL_19:
          if (v10 == ++v14)
            goto LABEL_20;
        }
        v15 = v12[(v14 - 1)];
LABEL_18:
        v12[v14] = v15;
        goto LABEL_19;
      }
LABEL_20:
      if (a4 < 1)
      {
        LOBYTE(v16) = *v12;
        if (!a4)
          LOBYTE(v16) = v16 | (1 << v13);
      }
      else if (v13)
      {
        v16 = *v12 | (3 << (v13 - 1));
      }
      else
      {
        v12[1] |= 0x80u;
        LOBYTE(v16) = 1;
      }
      *v12 = v16 & ~(510 << v13);
      if (a5)
        v12[v10 - 1] |= 1u;
      v5 = BN_bin2bn(v12, v10, (BIGNUM *)v5) != 0;
    }
    else
    {
      ERR_put_error(3, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/bn/bn_rand.c", 148);
      v5 = 0;
    }
    freezero(v12, v10);
    return v5;
  }
  ERR_put_error(3, 4095, 117, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/bn/bn_rand.c", 133);
  return 0;
}

int BN_pseudo_rand(BIGNUM *rnd, int bits, int top, int bottom)
{
  return bnrand(1, (uint64_t)rnd, bits, top, bottom);
}

int BN_bntest_rand(BIGNUM *rnd, int bits, int top, int bottom)
{
  return bnrand(2, (uint64_t)rnd, bits, top, bottom);
}

int BN_rand_range(BIGNUM *rnd, const BIGNUM *range)
{
  return bn_rand_range(0, rnd, range);
}

uint64_t bn_rand_range(int a1, BIGNUM *a2, const BIGNUM *a3)
{
  int (__cdecl *v3)(BIGNUM *, int, int, int);
  int v6;
  int v7;
  uint64_t result;
  uint64_t v9;
  uint64_t v10;
  int v11;
  BOOL v12;
  int v13;
  uint64_t v14;
  int v15;
  int v16;

  if (a1)
    v3 = BN_pseudo_rand;
  else
    v3 = BN_rand;
  if (a3->neg || BN_is_zero((uint64_t)a3))
  {
    v6 = 115;
    v7 = 226;
LABEL_7:
    ERR_put_error(3, 4095, v6, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/bn/bn_rand.c", v7);
    return 0;
  }
  else
  {
    v9 = BN_num_bits(a3);
    if ((_DWORD)v9 == 1)
    {
      BN_zero((uint64_t)a2);
      return 1;
    }
    else
    {
      v10 = v9;
      if (BN_is_bit_set(a3, v9 - 2) || BN_is_bit_set(a3, v10 - 3))
      {
        v11 = -100;
        do
        {
          result = ((uint64_t (*)(BIGNUM *, uint64_t, uint64_t, _QWORD))v3)(a2, v10, 0xFFFFFFFFLL, 0);
          if (!(_DWORD)result)
            break;
          v12 = __CFADD__(v11++, 1);
          if (v12)
          {
            v6 = 113;
            v7 = 268;
            goto LABEL_7;
          }
          v13 = BN_cmp(a2, a3);
          result = 1;
        }
        while ((v13 & 0x80000000) == 0);
      }
      else
      {
        v14 = (v10 + 1);
        v15 = -100;
        do
        {
          result = ((uint64_t (*)(BIGNUM *, uint64_t, uint64_t, _QWORD))v3)(a2, v14, 0xFFFFFFFFLL, 0);
          if (!(_DWORD)result)
            break;
          if ((BN_cmp(a2, a3) & 0x80000000) == 0)
          {
            result = BN_sub(a2, a2, a3);
            if (!(_DWORD)result)
              break;
            if ((BN_cmp(a2, a3) & 0x80000000) == 0)
            {
              result = BN_sub(a2, a2, a3);
              if (!(_DWORD)result)
                break;
            }
          }
          v12 = __CFADD__(v15++, 1);
          if (v12)
          {
            v6 = 113;
            v7 = 256;
            goto LABEL_7;
          }
          v16 = BN_cmp(a2, a3);
          result = 1;
        }
        while ((v16 & 0x80000000) == 0);
      }
    }
  }
  return result;
}

BOOL bn_rand_interval(BIGNUM *a1, BIGNUM *a, BIGNUM *b)
{
  BIGNUM *v6;
  _BOOL8 v7;
  BIGNUM *v9;

  if (BN_cmp(a, b) < 0)
  {
    v9 = BN_new();
    v6 = v9;
    if (v9 && BN_sub(v9, b, a) && bn_rand_range(0, a1, v6))
    {
      v7 = BN_add(a1, a1, a) != 0;
      goto LABEL_4;
    }
  }
  else
  {
    v6 = 0;
  }
  v7 = 0;
LABEL_4:
  BN_free(v6);
  return v7;
}

int BN_pseudo_rand_range(BIGNUM *rnd, const BIGNUM *range)
{
  return bn_rand_range(1, rnd, range);
}

int BN_gcd(BIGNUM *r, const BIGNUM *a, const BIGNUM *b, BN_CTX *ctx)
{
  BIGNUM *v8;
  BIGNUM *v9;
  BIGNUM *v10;
  int v11;
  BIGNUM *v12;
  BIGNUM *v13;
  BIGNUM *v14;
  int v15;
  BIGNUM *v16;
  const BIGNUM *v17;
  int v18;
  int v19;

  BN_CTX_start(ctx);
  v8 = BN_CTX_get(ctx);
  if (!v8)
    goto LABEL_40;
  v9 = BN_CTX_get(ctx);
  if (!v9 || (v10 = v9, !bn_copy(v8, a)) || !bn_copy(v10, b))
  {
LABEL_39:
    LODWORD(v8) = 0;
    goto LABEL_40;
  }
  v8->neg = 0;
  v10->neg = 0;
  v11 = BN_cmp(v8, v10);
  if (v11 >= 0)
    v12 = v8;
  else
    v12 = v10;
  if (v11 >= 0)
    v13 = v10;
  else
    v13 = v8;
  if (BN_is_zero((uint64_t)v13))
  {
    v14 = v12;
LABEL_13:
    LODWORD(v8) = bn_copy(r, v14);
    goto LABEL_40;
  }
  v15 = 0;
  do
  {
    while (1)
    {
      if (BN_is_odd((uint64_t)v12) && BN_is_odd((uint64_t)v13))
      {
        if (!BN_sub(v12, v12, v13))
          goto LABEL_39;
        goto LABEL_26;
      }
      if (BN_is_odd((uint64_t)v12) && !BN_is_odd((uint64_t)v13))
      {
        v16 = v13;
        v17 = v13;
        goto LABEL_28;
      }
      if (BN_is_odd((uint64_t)v12) || !BN_is_odd((uint64_t)v13))
        break;
LABEL_26:
      v16 = v12;
      v17 = v12;
LABEL_28:
      if (!BN_rshift1(v16, v17))
        goto LABEL_39;
      v18 = BN_cmp(v12, v13);
      if (v18 >= 0)
        v14 = v12;
      else
        v14 = v13;
      if (v18 < 0)
        v13 = v12;
      v12 = v14;
      if (BN_is_zero((uint64_t)v13))
        goto LABEL_35;
    }
    if (!BN_rshift1(v12, v12) || !BN_rshift1(v13, v13))
      goto LABEL_39;
    ++v15;
  }
  while (!BN_is_zero((uint64_t)v13));
  v14 = v12;
LABEL_35:
  if (!v15)
    goto LABEL_13;
  v19 = BN_lshift(v14, v14, v15);
  LODWORD(v8) = 0;
  if (v19)
    goto LABEL_13;
LABEL_40:
  BN_CTX_end(ctx);
  return (int)v8;
}

BOOL BN_gcd_ct(unint64_t a1, const BIGNUM *a2, const BIGNUM *a3, BN_CTX *a4)
{
  BIGNUM *v8;
  BIGNUM *v9;
  BIGNUM *v10;
  BIGNUM *v11;
  BIGNUM *v12;
  uint64_t v13;
  BIGNUM *v14;
  const BIGNUM *v15;
  BIGNUM *v16;
  BIGNUM *v17;
  BIGNUM *v18;
  const BIGNUM *v19;
  unint64_t v20;
  const BIGNUM *v21;
  int v22;
  BIGNUM v24;
  BIGNUM v25;

  memset(&v25, 0, sizeof(v25));
  memset(&v24, 0, sizeof(v24));
  if (a1)
  {
    BN_init(&v25);
    BN_init(&v24);
    BN_CTX_start(a4);
    v8 = BN_CTX_get(a4);
    if (!v8)
      goto LABEL_24;
    v9 = v8;
    v10 = BN_CTX_get(a4);
    if (!v10)
      goto LABEL_24;
    v11 = v10;
    v12 = BN_CTX_get(a4);
    if (!v12)
      goto LABEL_24;
    v13 = (uint64_t)v12;
    v14 = BN_CTX_get(a4);
    if (!v14)
      goto LABEL_24;
    v15 = v14;
    v16 = BN_CTX_get(a4);
    if (!v16)
      goto LABEL_24;
    v17 = v16;
    v18 = BN_CTX_get(a4);
    if (!v18)
      goto LABEL_24;
    v19 = v18;
    if (!BN_CTX_get(a4))
      goto LABEL_24;
    if (!BN_one(v13))
      goto LABEL_24;
    BN_zero((uint64_t)v19);
    if (!bn_copy(v11, a2) || !bn_copy(v9, a3))
      goto LABEL_24;
    v9->neg = 0;
    if (v11->neg || (BN_ucmp(v11, v9) & 0x80000000) == 0)
    {
      BN_with_flags((__n128 *)&v24, (__n128 *)v11, 4);
      if (!BN_nnmod(v11, &v24, v9, a4))
        goto LABEL_24;
    }
    v20 = 0;
    while (1)
    {
      v21 = v19;
      v19 = (const BIGNUM *)v13;
      v13 = (uint64_t)v9;
      if (BN_is_zero((uint64_t)v11))
        break;
      BN_with_flags((__n128 *)&v25, (__n128 *)v9, 4);
      if (!BN_div_ct((uint64_t)v15, v17, &v25, v11, a4) || !BN_mul(v9, v15, v19, a4))
        goto LABEL_21;
      v22 = BN_add(v9, v9, v21);
      v9 = v11;
      v11 = v17;
      v17 = (BIGNUM *)v21;
      if (!v22)
        goto LABEL_22;
    }
    if (bn_copy((BIGNUM *)a1, v9))
      v20 = a1;
    else
      v20 = 0;
  }
  else
  {
LABEL_21:
    v20 = 0;
  }
LABEL_22:
  if (!(a1 | v20))
  {
    BN_free(0);
LABEL_24:
    v20 = 0;
  }
  BN_CTX_end(a4);
  return v20 != 0;
}

BIGNUM *__cdecl BN_mod_inverse(BIGNUM *ret, const BIGNUM *a, const BIGNUM *n, BN_CTX *ctx)
{
  _BOOL4 v8;

  if (BN_get_flags((uint64_t)a, 4u))
    v8 = 1;
  else
    v8 = BN_get_flags((uint64_t)n, 4u) != 0;
  return BN_mod_inverse_internal(ret, a, n, ctx, v8);
}

BIGNUM *BN_mod_inverse_internal(BIGNUM *a1, const BIGNUM *a2, const BIGNUM *a3, BN_CTX *ctx, int a5)
{
  BIGNUM *v9;
  BIGNUM *v10;
  BIGNUM *v11;
  BIGNUM *v12;
  BIGNUM *v13;
  const BIGNUM *v14;
  BIGNUM *v15;
  const BIGNUM *v16;
  BIGNUM *v17;
  BIGNUM *v18;
  BIGNUM *v19;
  BIGNUM *v20;
  int v21;
  BIGNUM *v22;
  BIGNUM *v23;
  BIGNUM *v24;
  BIGNUM *v25;
  BIGNUM *v26;
  BIGNUM *v27;
  BIGNUM *v28;
  BIGNUM *v29;
  BIGNUM *v30;
  BIGNUM *v31;
  BIGNUM *v32;
  int v33;
  int v34;
  BIGNUM *v35;
  const BIGNUM *v36;
  const BIGNUM *v37;
  BIGNUM *v38;
  int v40;
  int v41;
  const BIGNUM *v42;
  _BOOL4 is_zero;
  BIGNUM *v44;
  int v45;
  const BIGNUM *v46;
  int v47;
  BIGNUM *v48;
  const BIGNUM *v49;
  int v50;
  BIGNUM *v51;
  const BIGNUM *v52;
  _BOOL4 v53;
  BIGNUM *v54;
  int v55;
  int v56;
  int v57;
  int v58;
  BIGNUM *r;
  BIGNUM *ra;
  BIGNUM *b;
  BIGNUM *ba;
  BIGNUM m;
  BIGNUM v64;

  if (a5)
  {
    memset(&v64, 0, sizeof(v64));
    memset(&m, 0, sizeof(m));
    BN_init(&v64);
    BN_init(&m);
    BN_CTX_start(ctx);
    v9 = BN_CTX_get(ctx);
    if (v9)
    {
      v10 = v9;
      v11 = BN_CTX_get(ctx);
      if (v11)
      {
        v12 = v11;
        v13 = BN_CTX_get(ctx);
        if (v13)
        {
          v14 = v13;
          v15 = BN_CTX_get(ctx);
          if (v15)
          {
            v16 = v15;
            v17 = BN_CTX_get(ctx);
            if (v17)
            {
              v18 = v17;
              v19 = BN_CTX_get(ctx);
              if (!v19)
                goto LABEL_65;
              if (BN_CTX_get(ctx))
              {
                b = v19;
                v19 = a1;
                if (!a1)
                {
                  v19 = BN_new();
                  if (!v19)
                    goto LABEL_65;
                }
                if (!BN_one((uint64_t)v14))
                  goto LABEL_65;
                BN_zero((uint64_t)b);
                if (!bn_copy(v12, a2) || !bn_copy(v10, a3))
                  goto LABEL_65;
                v10->neg = 0;
                if (v12->neg || (BN_ucmp(v12, v10) & 0x80000000) == 0)
                {
                  BN_with_flags((__n128 *)&m, (__n128 *)v12, 4);
                  if (!BN_nnmod(v12, &m, v10, ctx))
                    goto LABEL_65;
                }
                if (!BN_is_zero((uint64_t)v12))
                {
                  v40 = -1;
                  v41 = 1;
                  while (1)
                  {
                    v56 = v41;
                    v58 = v40;
                    v42 = v12;
                    v12 = v18;
                    BN_with_flags((__n128 *)&v64, (__n128 *)v10, 4);
                    r = (BIGNUM *)v42;
                    if (!BN_div_ct((uint64_t)v16, v18, &v64, v42, ctx))
                      goto LABEL_65;
                    if (!BN_mul(v10, v16, v14, ctx))
                      goto LABEL_65;
                    v18 = b;
                    if (!BN_add(v10, v10, b))
                      goto LABEL_65;
                    is_zero = BN_is_zero((uint64_t)v12);
                    v41 = v58;
                    v40 = v56;
                    b = (BIGNUM *)v14;
                    v44 = (BIGNUM *)v14;
                    v14 = v10;
                    v10 = (BIGNUM *)v42;
                    if (is_zero)
                    {
                      v20 = v44;
                      if ((v56 & 0x80000000) == 0)
                        goto LABEL_20;
                      goto LABEL_19;
                    }
                  }
                }
                v20 = b;
                r = v10;
LABEL_19:
                if (!BN_sub(v20, a3, v20))
                  goto LABEL_65;
LABEL_20:
                if (!BN_is_one((uint64_t)r))
                {
                  v21 = 510;
LABEL_120:
                  ERR_put_error(3, 4095, 108, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/bn/bn_gcd.c", v21);
                  goto LABEL_65;
                }
                goto LABEL_73;
              }
            }
          }
        }
      }
    }
LABEL_64:
    v19 = 0;
    goto LABEL_65;
  }
  BN_CTX_start(ctx);
  v22 = BN_CTX_get(ctx);
  if (!v22)
    goto LABEL_64;
  v23 = v22;
  v24 = BN_CTX_get(ctx);
  if (!v24)
    goto LABEL_64;
  v25 = v24;
  v26 = BN_CTX_get(ctx);
  if (!v26)
    goto LABEL_64;
  v27 = v26;
  v28 = BN_CTX_get(ctx);
  if (!v28)
    goto LABEL_64;
  v29 = v28;
  v30 = BN_CTX_get(ctx);
  if (!v30)
    goto LABEL_64;
  v31 = v30;
  v19 = BN_CTX_get(ctx);
  if (!v19)
    goto LABEL_65;
  v32 = BN_CTX_get(ctx);
  if (!v32)
    goto LABEL_64;
  ra = v32;
  ba = v19;
  v19 = a1;
  if (!a1)
  {
    v19 = BN_new();
    if (!v19)
      goto LABEL_65;
  }
  if (!BN_one((uint64_t)v27))
    goto LABEL_65;
  BN_zero((uint64_t)ba);
  if (!bn_copy(v25, a2) || !bn_copy(v23, a3))
    goto LABEL_65;
  v23->neg = 0;
  if ((v25->neg || (BN_ucmp(v25, v23) & 0x80000000) == 0) && !BN_nnmod(v25, v25, v23, ctx))
    goto LABEL_65;
  if (BN_is_odd((uint64_t)a3) && BN_num_bits(a3) <= 2048)
  {
    if (!BN_is_zero((uint64_t)v25))
    {
      v33 = 0;
      while (1)
      {
        while (!BN_is_bit_set(v25, v33))
        {
          if (!BN_is_odd((uint64_t)v27) || BN_uadd(v27, v27, a3))
          {
            ++v33;
            if (BN_rshift1(v27, v27))
              continue;
          }
          goto LABEL_65;
        }
        if (v33 && !BN_rshift(v25, v25, v33))
          goto LABEL_65;
        v34 = 0;
        while (!BN_is_bit_set(v23, v34))
        {
          if (!BN_is_odd((uint64_t)ba) || BN_uadd(ba, ba, a3))
          {
            ++v34;
            if (BN_rshift1(ba, ba))
              continue;
          }
          goto LABEL_65;
        }
        if (v34 && !BN_rshift(v23, v23, v34))
          goto LABEL_65;
        if (BN_ucmp(v25, v23) < 0)
        {
          if (!BN_uadd(ba, ba, v27))
            goto LABEL_65;
          v35 = v23;
          v36 = v23;
          v37 = v25;
        }
        else
        {
          if (!BN_uadd(v27, v27, ba))
            goto LABEL_65;
          v35 = v25;
          v36 = v25;
          v37 = v23;
        }
        if (!BN_usub(v35, v36, v37))
          goto LABEL_65;
        v33 = 0;
        if (BN_is_zero((uint64_t)v25))
          break;
      }
    }
LABEL_70:
    v20 = ba;
    goto LABEL_71;
  }
  if (BN_is_zero((uint64_t)v25))
    goto LABEL_70;
  v57 = -1;
  v45 = 1;
  do
  {
    v46 = v25;
    v25 = v31;
    v55 = v45;
    v47 = BN_num_bits(v23);
    if (v47 == BN_num_bits(v46))
    {
LABEL_86:
      if (!BN_one((uint64_t)v29))
        goto LABEL_65;
      v48 = v25;
      v49 = v23;
LABEL_88:
      if (!BN_sub(v48, v49, v46))
        goto LABEL_65;
      goto LABEL_99;
    }
    v50 = BN_num_bits(v23);
    if (v50 == BN_num_bits(v46) + 1)
    {
      if (!BN_lshift1(ra, v46))
        goto LABEL_65;
      if (BN_ucmp(v23, ra) < 0)
        goto LABEL_86;
      if (!BN_sub(v25, v23, ra) || !BN_add(v29, ra, v46))
        goto LABEL_65;
      if ((BN_ucmp(v23, v29) & 0x80000000) == 0)
      {
        if (!BN_set_word(v29, 3uLL))
          goto LABEL_65;
        v48 = v25;
        v49 = v25;
        goto LABEL_88;
      }
      if (!BN_set_word(v29, 2uLL))
        goto LABEL_65;
    }
    else if (!BN_div_nonct((uint64_t)v29, v25, v23, v46, ctx))
    {
      goto LABEL_65;
    }
LABEL_99:
    if (BN_is_one((uint64_t)v29))
    {
      v51 = v23;
      v52 = v27;
    }
    else
    {
      if (BN_is_word((uint64_t)v29, 2))
      {
        if (!BN_lshift1(v23, v27))
          goto LABEL_65;
      }
      else if (BN_is_word((uint64_t)v29, 4))
      {
        if (!BN_lshift(v23, v27, 2))
          goto LABEL_65;
      }
      else if (v29->top == 1)
      {
        if (!bn_copy(v23, v27) || !BN_mul_word(v23, *v29->d))
          goto LABEL_65;
      }
      else if (!BN_mul(v23, v29, v27, ctx))
      {
        goto LABEL_65;
      }
      v51 = v23;
      v52 = v23;
    }
    v31 = ba;
    if (!BN_add(v51, v52, ba))
      goto LABEL_65;
    v53 = BN_is_zero((uint64_t)v25);
    v45 = v57;
    v57 = v55;
    ba = v27;
    v54 = v27;
    v27 = v23;
    v23 = (BIGNUM *)v46;
  }
  while (!v53);
  v23 = (BIGNUM *)v46;
  v20 = v54;
  if ((v55 & 0x80000000) == 0)
  {
LABEL_72:
    if (!BN_is_one((uint64_t)v23))
    {
      v21 = 798;
      goto LABEL_120;
    }
LABEL_73:
    if (!v20->neg && BN_ucmp(v20, a3) < 0)
    {
      if (!bn_copy(v19, v20))
        goto LABEL_65;
    }
    else if (!BN_nnmod(v19, v20, a3, ctx))
    {
      goto LABEL_65;
    }
    v38 = v19;
    goto LABEL_66;
  }
LABEL_71:
  if (BN_sub(v20, a3, v20))
    goto LABEL_72;
LABEL_65:
  v38 = 0;
LABEL_66:
  if (!((unint64_t)a1 | (unint64_t)v38))
    BN_free(v19);
  BN_CTX_end(ctx);
  return v38;
}

BIGNUM *BN_mod_inverse_nonct(BIGNUM *a1, const BIGNUM *a2, const BIGNUM *a3, BN_CTX *a4)
{
  return BN_mod_inverse_internal(a1, a2, a3, a4, 0);
}

BIGNUM *BN_mod_inverse_ct(BIGNUM *a1, const BIGNUM *a2, const BIGNUM *a3, BN_CTX *a4)
{
  return BN_mod_inverse_internal(a1, a2, a3, a4, 1);
}

unint64_t bn_add_words(unint64_t *rp, const unint64_t *ap, const unint64_t *bp, int num)
{
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t v20;
  unint64_t v21;
  unint64_t v22;
  unint64_t v23;
  unint64_t v24;
  unint64_t v25;
  unint64_t v26;
  unint64_t v27;
  unint64_t v28;
  unint64_t v29;
  unint64_t v30;
  unint64_t v31;
  unint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  unint64_t v39;
  unint64_t v40;
  unint64_t v41;
  unint64_t v42;

  if (num < 0)
    bn_add_words_cold_1();
  if (!num)
    return 0;
  if (num < 4)
  {
    v4 = 0;
    do
    {
LABEL_9:
      v34 = *ap++;
      v33 = v34;
      v35 = *bp++;
      v36 = v35 | v33;
      v37 = v35 & v33;
      v38 = v35 + v33;
      v39 = v36 & ~v38 | v37;
      v40 = v38 | v4;
      v41 = v38 & v4;
      v42 = v38 + v4;
      v4 = ((v40 & ~v42 | v41) >> 63) + (v39 >> 63);
      *rp++ = v42;
      --num;
    }
    while (num);
    return v4;
  }
  v4 = 0;
  do
  {
    v5 = *bp + *ap;
    v6 = (*bp | *ap) & ~v5 | *bp & *ap;
    v7 = v5 | v4;
    v8 = v5 & v4;
    v9 = v5 + v4;
    v10 = v7 & ~v9 | v8;
    *rp = v9;
    v11 = ap[1];
    v12 = bp[1];
    v13 = v12 | v11;
    v14 = v12 & v11;
    v15 = v12 + v11;
    v16 = v13 & ~v15 | v14;
    v17 = v15 + (v6 >> 63) + (v10 >> 63);
    v18 = v15 & ~v17;
    rp[1] = v17;
    v19 = ap[2];
    v20 = bp[2];
    v21 = v20 | v19;
    v22 = v20 & v19;
    v23 = v20 + v19;
    v24 = v21 & ~v23 | v22;
    v25 = v23 + (v16 >> 63) + (v18 >> 63);
    v26 = v23 & ~v25;
    rp[2] = v25;
    v27 = ap[3];
    v28 = bp[3];
    v29 = v28 | v27;
    v30 = v28 & v27;
    v31 = v28 + v27;
    v32 = v31 + (v24 >> 63) + (v26 >> 63);
    v4 = ((v31 & ~v32) >> 63) + ((v29 & ~v31 | v30) >> 63);
    rp[3] = v32;
    ap += 4;
    bp += 4;
    rp += 4;
    num -= 4;
  }
  while (num >= 4);
  if (num)
    goto LABEL_9;
  return v4;
}

unint64_t bn_add(unint64_t *a1, int a2, unint64_t *ap, int a4, unint64_t *bp, int a6)
{
  int v11;
  int v12;
  unint64_t result;
  unint64_t *v14;
  unint64_t *v15;
  unsigned int v16;
  uint64_t v17;
  unint64_t v18;
  unint64_t *v19;
  int v20;
  uint64_t v21;
  unint64_t v22;

  v11 = a4 - a6;
  if (a4 >= a6)
    v12 = a6;
  else
    v12 = a4;
  result = bn_add_words(a1, ap, bp, v12);
  v14 = &a1[v12];
  if (v11 < 0)
  {
    v19 = &bp[v12];
    v20 = a6 - a4;
    do
    {
      v21 = *v19++;
      v22 = v21 + result;
      result = ((v21 | result) & ~(v21 + result) | v21 & result) >> 63;
      *v14++ = v22;
      --v20;
    }
    while (v20);
  }
  else if (v11)
  {
    v15 = &ap[v12];
    v16 = v11 + 1;
    do
    {
      v17 = *v15++;
      v18 = v17 + result;
      result = ((v17 | result) & ~(v17 + result) | v17 & result) >> 63;
      *v14++ = v18;
      --v16;
    }
    while (v16 > 1);
  }
  return result;
}

unint64_t bn_sub_words(unint64_t *rp, const unint64_t *ap, const unint64_t *bp, int num)
{
  unint64_t v4;
  unint64_t v5;
  int64_t v6;
  unint64_t v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  unint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  unint64_t v27;

  if (num < 0)
    bn_sub_words_cold_1();
  if (!num)
    return 0;
  if (num < 4)
  {
    v4 = 0;
    do
    {
LABEL_9:
      v25 = *ap++;
      v24 = v25;
      v26 = *bp++;
      v27 = v24 - v26 - v4;
      v4 = (((v27 | v4 & ~(v24 - v26)) & (v4 | ~(v24 - v26))) >> 63)
         + ((((v24 - v26) | v26 & ~v24) & (v26 | (unint64_t)~v24)) >> 63);
      *rp++ = v27;
      --num;
    }
    while (num);
    return v4;
  }
  v4 = 0;
  do
  {
    v5 = *ap - *bp;
    v6 = (v5 | *bp & ~*ap) & (*bp | ~*ap);
    v7 = v5 - v4;
    v8 = ((v5 - v4) | v4 & ~v5) & (v4 | ~v5);
    *rp = v7;
    v9 = ap[1];
    v10 = bp[1];
    v11 = v9 - v10;
    v12 = ((v9 - v10) | v10 & ~v9) & (v10 | ~v9);
    v13 = v11 + (v6 >> 63) + (v8 >> 63);
    v14 = v13 & ~v11;
    rp[1] = v13;
    v15 = ap[2];
    v16 = bp[2];
    v17 = v15 - v16;
    v18 = ((v15 - v16) | v16 & ~v15) & (v16 | ~v15);
    v19 = v17 + (v12 >> 63) + (v14 >> 63);
    v20 = v19 & ~v17;
    rp[2] = v19;
    v21 = ap[3];
    v22 = bp[3];
    v23 = v21 - v22 + (v18 >> 63) + (v20 >> 63);
    v4 = ((v23 & ~(v21 - v22)) >> 63) + ((((v21 - v22) | v22 & ~v21) & (v22 | ~v21)) >> 63);
    rp[3] = v23;
    ap += 4;
    bp += 4;
    rp += 4;
    num -= 4;
  }
  while (num >= 4);
  if (num)
    goto LABEL_9;
  return v4;
}

unint64_t bn_sub(unint64_t *a1, int a2, unint64_t *ap, int a4, unint64_t *bp, int a6)
{
  int v11;
  int v12;
  unint64_t result;
  unint64_t *v14;
  unint64_t *v15;
  unsigned int v16;
  uint64_t v17;
  unint64_t v18;
  unint64_t *v19;
  int v20;
  uint64_t v21;
  unint64_t v22;

  v11 = a4 - a6;
  if (a4 >= a6)
    v12 = a6;
  else
    v12 = a4;
  result = bn_sub_words(a1, ap, bp, v12);
  v14 = &a1[v12];
  if (v11 < 0)
  {
    v19 = &bp[v12];
    v20 = a6 - a4;
    do
    {
      v21 = *v19++;
      v22 = -(uint64_t)result - v21;
      result = (((v21 - 1) & result | v22) & ((v21 - 1) | result)) >> 63;
      *v14++ = v22;
      --v20;
    }
    while (v20);
  }
  else if (v11)
  {
    v15 = &ap[v12];
    v16 = v11 + 1;
    do
    {
      v17 = *v15++;
      v18 = v17 - result;
      result = (((v17 - result) | result & ~v17) & (result | ~v17)) >> 63;
      *v14++ = v18;
      --v16;
    }
    while (v16 > 1);
  }
  return result;
}

int BN_uadd(BIGNUM *r, const BIGNUM *a, const BIGNUM *b)
{
  int top;
  int result;
  int v8;
  unint64_t v9;

  if (a->top <= b->top)
    top = b->top;
  else
    top = a->top;
  if (top == 0x7FFFFFFF)
    return 0;
  result = bn_wexpand((uint64_t)r, (top + 1));
  if (result)
  {
    v9 = bn_add(r->d, v8, a->d, a->top, b->d, b->top);
    r->d[top] = v9;
    r->top = (v9 & 1) + top;
    r->neg = 0;
    return 1;
  }
  return result;
}

int BN_usub(BIGNUM *r, const BIGNUM *a, const BIGNUM *b)
{
  int top;
  int v4;
  int result;
  int v9;

  top = a->top;
  if (top >= b->top)
  {
    result = bn_wexpand((uint64_t)r, a->top);
    if (!result)
      return result;
    if (!bn_sub(r->d, v9, a->d, a->top, b->d, b->top))
    {
      r->top = top;
      r->neg = 0;
      bn_correct_top((uint64_t *)r);
      return 1;
    }
    v4 = 277;
  }
  else
  {
    v4 = 267;
  }
  ERR_put_error(3, 4095, 100, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/bn/bn_add.c", v4);
  return 0;
}

int BN_add(BIGNUM *r, const BIGNUM *a, const BIGNUM *b)
{
  int neg;
  int v7;
  int v8;
  BIGNUM *v9;
  const BIGNUM *v10;
  const BIGNUM *v11;
  int v12;

  neg = a->neg;
  if (neg == b->neg)
  {
    v7 = BN_uadd(r, a, b);
  }
  else
  {
    v8 = BN_ucmp(a, b);
    if (v8 < 1)
    {
      if ((v8 & 0x80000000) == 0)
      {
        BN_zero((uint64_t)r);
        neg = 0;
        v12 = 1;
        goto LABEL_7;
      }
      neg = b->neg;
      v9 = r;
      v10 = b;
      v11 = a;
    }
    else
    {
      neg = a->neg;
      v9 = r;
      v10 = a;
      v11 = b;
    }
    v7 = BN_usub(v9, v10, v11);
  }
  v12 = v7;
LABEL_7:
  BN_set_negative(r, neg);
  return v12;
}

int BN_sub(BIGNUM *r, const BIGNUM *a, const BIGNUM *b)
{
  int neg;
  int v7;
  BIGNUM *v8;
  const BIGNUM *v9;
  const BIGNUM *v10;
  int v11;
  int v12;

  neg = a->neg;
  if (neg == b->neg)
  {
    v7 = BN_ucmp(a, b);
    if (v7 < 1)
    {
      if ((v7 & 0x80000000) == 0)
      {
        BN_zero((uint64_t)r);
        neg = 0;
        v12 = 1;
        goto LABEL_7;
      }
      neg = b->neg == 0;
      v8 = r;
      v9 = b;
      v10 = a;
    }
    else
    {
      neg = a->neg;
      v8 = r;
      v9 = a;
      v10 = b;
    }
    v11 = BN_usub(v8, v9, v10);
  }
  else
  {
    v11 = BN_uadd(r, a, b);
  }
  v12 = v11;
LABEL_7:
  BN_set_negative(r, neg);
  return v12;
}

void bn_add_words_cold_1()
{
  __assert_rtn("bn_add_words", "bn_add.c", 79, "n >= 0");
}

void bn_sub_words_cold_1()
{
  __assert_rtn("bn_sub_words", "bn_add.c", 164, "n >= 0");
}

OTHERNAME *__cdecl d2i_OTHERNAME(OTHERNAME **a, const unsigned __int8 **in, uint64_t len)
{
  return (OTHERNAME *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &OTHERNAME_it);
}

int i2d_OTHERNAME(OTHERNAME *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &OTHERNAME_it);
}

OTHERNAME *OTHERNAME_new(void)
{
  return (OTHERNAME *)ASN1_item_new(&OTHERNAME_it);
}

void OTHERNAME_free(OTHERNAME *a)
{
  ASN1_item_free((ASN1_VALUE *)a, &OTHERNAME_it);
}

EDIPARTYNAME *__cdecl d2i_EDIPARTYNAME(EDIPARTYNAME **a, const unsigned __int8 **in, uint64_t len)
{
  return (EDIPARTYNAME *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &EDIPARTYNAME_it);
}

int i2d_EDIPARTYNAME(EDIPARTYNAME *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &EDIPARTYNAME_it);
}

EDIPARTYNAME *EDIPARTYNAME_new(void)
{
  return (EDIPARTYNAME *)ASN1_item_new(&EDIPARTYNAME_it);
}

void EDIPARTYNAME_free(EDIPARTYNAME *a)
{
  ASN1_item_free((ASN1_VALUE *)a, &EDIPARTYNAME_it);
}

GENERAL_NAME *__cdecl d2i_GENERAL_NAME(GENERAL_NAME **a, const unsigned __int8 **in, uint64_t len)
{
  return (GENERAL_NAME *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &GENERAL_NAME_it);
}

int i2d_GENERAL_NAME(GENERAL_NAME *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &GENERAL_NAME_it);
}

GENERAL_NAME *GENERAL_NAME_new(void)
{
  return (GENERAL_NAME *)ASN1_item_new(&GENERAL_NAME_it);
}

void GENERAL_NAME_free(GENERAL_NAME *a)
{
  ASN1_item_free((ASN1_VALUE *)a, &GENERAL_NAME_it);
}

GENERAL_NAMES *__cdecl d2i_GENERAL_NAMES(GENERAL_NAMES **a, const unsigned __int8 **in, uint64_t len)
{
  return (GENERAL_NAMES *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &GENERAL_NAMES_it);
}

int i2d_GENERAL_NAMES(GENERAL_NAMES *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &GENERAL_NAMES_it);
}

GENERAL_NAMES *GENERAL_NAMES_new(void)
{
  return (GENERAL_NAMES *)ASN1_item_new(&GENERAL_NAMES_it);
}

void GENERAL_NAMES_free(GENERAL_NAMES *a)
{
  ASN1_item_free((ASN1_VALUE *)a, &GENERAL_NAMES_it);
}

void *GENERAL_NAME_dup(void *x)
{
  return ASN1_item_dup(&GENERAL_NAME_it, x);
}

uint64_t GENERAL_NAME_cmp(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  ASN1_STRING *v4;
  ASN1_STRING *v5;
  ASN1_STRING **v6;
  ASN1_STRING **v7;
  ASN1_STRING *v8;

  result = 0xFFFFFFFFLL;
  if (a1 && a2 && *(_DWORD *)a1 == *(_DWORD *)a2)
  {
    switch(*(_DWORD *)a1)
    {
      case 0:
        return OTHERNAME_cmp(*(_QWORD *)(a1 + 8), *(_QWORD *)(a2 + 8));
      case 1:
      case 2:
      case 3:
      case 6:
        v4 = *(ASN1_STRING **)(a1 + 8);
        v5 = *(ASN1_STRING **)(a2 + 8);
        return ASN1_STRING_cmp(v4, v5);
      case 4:
        return X509_NAME_cmp(*(const X509_NAME **)(a1 + 8), *(const X509_NAME **)(a2 + 8));
      case 5:
        v6 = *(ASN1_STRING ***)(a1 + 8);
        if (!v6)
          return result;
        v7 = *(ASN1_STRING ***)(a2 + 8);
        if (!v7)
          return result;
        v8 = *v7;
        if (!*v6)
        {
          if (v8)
            return 0xFFFFFFFFLL;
LABEL_18:
          v4 = v6[1];
          if (v4)
          {
            v5 = v7[1];
            if (v5)
              return ASN1_STRING_cmp(v4, v5);
          }
          return 0xFFFFFFFFLL;
        }
        if (v8)
        {
          result = ASN1_STRING_cmp(*v6, v8);
          if ((_DWORD)result)
            return result;
          goto LABEL_18;
        }
        result = 1;
        break;
      case 7:
        return ASN1_OCTET_STRING_cmp(*(ASN1_OCTET_STRING **)(a1 + 8), *(ASN1_OCTET_STRING **)(a2 + 8));
      case 8:
        return OBJ_cmp(*(const ASN1_OBJECT **)(a1 + 8), *(const ASN1_OBJECT **)(a2 + 8));
      default:
        return result;
    }
  }
  return result;
}

uint64_t OTHERNAME_cmp(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  result = 0xFFFFFFFFLL;
  if (a1 && a2)
  {
    result = OBJ_cmp(*(const ASN1_OBJECT **)a1, *(const ASN1_OBJECT **)a2);
    if (!(_DWORD)result)
      return ASN1_TYPE_cmp(*(const ASN1_OBJECT ***)(a1 + 8), *(_QWORD *)(a2 + 8));
  }
  return result;
}

uint64_t GENERAL_NAME_set0_value(uint64_t result, unsigned int a2, uint64_t a3)
{
  if (a2 <= 8)
    *(_QWORD *)(result + 8) = a3;
  *(_DWORD *)result = a2;
  return result;
}

uint64_t GENERAL_NAME_get0_value(uint64_t a1, _DWORD *a2)
{
  if (a2)
    *a2 = *(_DWORD *)a1;
  if (*(_DWORD *)a1 > 8u)
    return 0;
  else
    return *(_QWORD *)(a1 + 8);
}

uint64_t GENERAL_NAME_set0_othername(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;

  result = (uint64_t)ASN1_item_new(&OTHERNAME_it);
  if (result)
  {
    *(_QWORD *)result = a2;
    *(_QWORD *)(result + 8) = a3;
    *(_QWORD *)(a1 + 8) = result;
    result = 1;
    *(_DWORD *)a1 = 0;
  }
  return result;
}

uint64_t GENERAL_NAME_get0_otherName(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  if (*(_DWORD *)a1)
    return 0;
  if (a2)
    *a2 = **(_QWORD **)(a1 + 8);
  if (a3)
    *a3 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8);
  return 1;
}

int X509_check_purpose(X509 *x, int id, int ca)
{
  uint64_t v3;
  int result;
  char *v7;

  v3 = *(_QWORD *)&ca;
  if (!x509v3_cache_extensions((uint64_t)x))
    return -1;
  if (id == -1)
    return 1;
  result = X509_PURPOSE_get_by_id(id);
  if (result != -1)
  {
    if (result > 8)
      v7 = sk_value((const STACK *)xptable, result - 9);
    else
      v7 = (char *)&xstandard + 48 * result;
    return (*((uint64_t (**)(char *, X509 *, uint64_t))v7 + 2))(v7, x, v3);
  }
  return result;
}

BOOL x509v3_cache_extensions(uint64_t a1)
{
  uint64_t v1;
  const EVP_MD *v3;
  BASIC_CONSTRAINTS *ext_d2i;
  BASIC_CONSTRAINTS *v5;
  int ca;
  ASN1_INTEGER *pathlen;
  uint64_t v8;
  uint64_t v9;
  ASN1_BIT_STRING *v10;
  int length;
  unsigned __int8 *data;
  uint64_t v13;
  const STACK *v14;
  STACK *v15;
  char *v16;
  int v17;
  uint64_t v18;
  int v19;
  ASN1_BIT_STRING *v20;
  uint64_t v21;
  void *v22;
  void *v23;
  X509_NAME *subject_name;
  X509_NAME *issuer_name;
  uint64_t v26;
  void *v27;
  void *v28;
  const STACK *v29;
  char *v30;
  char *v31;
  uint64_t v32;
  int v33;
  unsigned __int8 *v34;
  int v35;
  int v36;
  char *v37;
  X509_NAME *v38;
  int v39;
  STACK *v40;
  uint64_t *v41;
  X509_EXTENSION *ext;
  ASN1_OBJECT *object;
  int v44;
  int crit;
  int v47;

  v1 = *(_QWORD *)(a1 + 56);
  if ((v1 & 0x100) == 0)
  {
    CRYPTO_lock(9, 3, 0, 0);
    if ((*(_BYTE *)(a1 + 57) & 1) != 0)
    {
LABEL_112:
      CRYPTO_lock(10, 3, 0, 0);
      v1 = *(_QWORD *)(a1 + 56);
      return (v1 & 0x80) == 0;
    }
    v3 = EVP_sha512();
    X509_digest((const X509 *)a1, v3, (unsigned __int8 *)(a1 + 144), 0);
    if (!X509_get_version((ASN1_INTEGER ***)a1))
    {
      *(_QWORD *)(a1 + 56) |= 0x40uLL;
      if (X509_get_ext_count((X509 *)a1))
        *(_QWORD *)(a1 + 56) |= 0x80uLL;
    }
    crit = 0;
    ext_d2i = (BASIC_CONSTRAINTS *)X509_get_ext_d2i((X509 *)a1, 87, &crit, 0);
    if (ext_d2i)
    {
      v5 = ext_d2i;
      ca = ext_d2i->ca;
      if (ext_d2i->ca)
        *(_QWORD *)(a1 + 56) |= 0x10uLL;
      pathlen = ext_d2i->pathlen;
      if (pathlen)
      {
        if (!ca || pathlen->type == 258)
        {
          v8 = 0;
          *(_QWORD *)(a1 + 56) |= 0x80uLL;
        }
        else
        {
          v8 = ASN1_INTEGER_get(pathlen);
        }
      }
      else
      {
        v8 = -1;
      }
      *(_QWORD *)(a1 + 48) = v8;
      BASIC_CONSTRAINTS_free(v5);
      v9 = 1;
    }
    else
    {
      if (crit == -1)
      {
LABEL_19:
        v10 = (ASN1_BIT_STRING *)X509_get_ext_d2i((X509 *)a1, 83, &crit, 0);
        if (v10)
        {
          length = v10->length;
          if (v10->length < 1)
          {
            *(_QWORD *)(a1 + 64) = 0;
          }
          else
          {
            data = v10->data;
            v13 = *data;
            *(_QWORD *)(a1 + 64) = v13;
            if (length != 1)
              *(_QWORD *)(a1 + 64) = v13 | ((unint64_t)data[1] << 8);
          }
          *(_QWORD *)(a1 + 56) |= 2uLL;
          ASN1_BIT_STRING_free(v10);
        }
        else if (crit != -1)
        {
          *(_QWORD *)(a1 + 56) |= 0x80uLL;
        }
        *(_QWORD *)(a1 + 72) = 0;
        v14 = (const STACK *)X509_get_ext_d2i((X509 *)a1, 126, &crit, 0);
        if (v14)
        {
          v15 = (STACK *)v14;
          *(_QWORD *)(a1 + 56) |= 4uLL;
          crit = 0;
          if (sk_num(v14) >= 1)
          {
            while (1)
            {
              v16 = sk_value(v15, crit);
              v17 = OBJ_obj2nid((const ASN1_OBJECT *)v16);
              if (v17 <= 179)
              {
                v18 = 1;
                switch(v17)
                {
                  case 129:
                    goto LABEL_42;
                  case 130:
                    v18 = 2;
                    goto LABEL_42;
                  case 131:
                    v18 = 8;
                    goto LABEL_42;
                  case 132:
                    v18 = 4;
                    goto LABEL_42;
                  case 133:
                    v18 = 64;
                    goto LABEL_42;
                  case 137:
                  case 139:
                    v18 = 16;
                    goto LABEL_42;
                  default:
                    goto LABEL_43;
                }
                goto LABEL_43;
              }
              if (v17 == 180)
                break;
              if (v17 == 297)
              {
                v18 = 128;
                goto LABEL_42;
              }
              if (v17 == 910)
              {
                v18 = 256;
LABEL_42:
                *(_QWORD *)(a1 + 72) |= v18;
              }
LABEL_43:
              v19 = ++crit;
              if (v19 >= sk_num(v15))
                goto LABEL_44;
            }
            v18 = 32;
            goto LABEL_42;
          }
LABEL_44:
          sk_pop_free(v15, (void (__cdecl *)(void *))ASN1_OBJECT_free);
        }
        else if (crit != -1)
        {
          *(_QWORD *)(a1 + 56) |= 0x80uLL;
        }
        v20 = (ASN1_BIT_STRING *)X509_get_ext_d2i((X509 *)a1, 71, &crit, 0);
        if (v20)
        {
          if (v20->length < 1)
            v21 = 0;
          else
            v21 = *v20->data;
          *(_QWORD *)(a1 + 80) = v21;
          *(_QWORD *)(a1 + 56) |= 8uLL;
          ASN1_BIT_STRING_free(v20);
        }
        else if (crit != -1)
        {
          *(_QWORD *)(a1 + 56) |= 0x80uLL;
        }
        v22 = X509_get_ext_d2i((X509 *)a1, 82, &crit, 0);
        *(_QWORD *)(a1 + 88) = v22;
        if (!v22 && crit != -1)
          *(_QWORD *)(a1 + 56) |= 0x80uLL;
        v23 = X509_get_ext_d2i((X509 *)a1, 90, &crit, 0);
        *(_QWORD *)(a1 + 96) = v23;
        if (!v23 && crit != -1)
          *(_QWORD *)(a1 + 56) |= 0x80uLL;
        subject_name = X509_get_subject_name((X509 *)a1);
        issuer_name = X509_get_issuer_name((X509 *)a1);
        if (!X509_NAME_cmp(subject_name, issuer_name))
        {
          *(_QWORD *)(a1 + 56) |= 0x20uLL;
          if (!X509_check_akid((X509 *)a1, *(_QWORD *)(a1 + 96)))
          {
            v26 = *(_QWORD *)(a1 + 56);
            if ((v26 & 2) == 0 || (*(_BYTE *)(a1 + 64) & 4) != 0)
              *(_QWORD *)(a1 + 56) = v26 | 0x2000;
          }
        }
        v27 = X509_get_ext_d2i((X509 *)a1, 85, &crit, 0);
        *(_QWORD *)(a1 + 112) = v27;
        if (!v27 && crit != -1)
          *(_QWORD *)(a1 + 56) |= 0x80uLL;
        v28 = X509_get_ext_d2i((X509 *)a1, 666, &crit, 0);
        *(_QWORD *)(a1 + 120) = v28;
        if (!v28 && crit != -1)
          *(_QWORD *)(a1 + 56) |= 0x80uLL;
        v47 = 0;
        v29 = (const STACK *)X509_get_ext_d2i((X509 *)a1, 103, &v47, 0);
        *(_QWORD *)(a1 + 104) = v29;
        if (v29 || v47 == -1)
        {
          v47 = 0;
          if (sk_num(v29) >= 1)
          {
            do
            {
              v30 = sk_value(*(const STACK **)(a1 + 104), v47);
              v31 = v30;
              v32 = *((_QWORD *)v30 + 1);
              if (v32)
              {
                v33 = *(_DWORD *)v32;
                if (*(int *)v32 <= 0)
                {
                  v35 = *((_DWORD *)v30 + 6);
                }
                else
                {
                  v34 = *(unsigned __int8 **)(v32 + 8);
                  v35 = *v34;
                  *((_DWORD *)v30 + 6) = v35;
                  if (v33 != 1)
                    LOWORD(v35) = v35 | (v34[1] << 8);
                }
                *((_DWORD *)v30 + 6) = v35 & 0x807F;
              }
              else
              {
                *((_DWORD *)v30 + 6) = 32895;
              }
              if (*(_QWORD *)v30 && **(_DWORD **)v30 == 1)
              {
                if (sk_num(*((const STACK **)v30 + 2)) < 1)
                  goto LABEL_90;
                v36 = 0;
                while (1)
                {
                  v37 = sk_value(*((const STACK **)v31 + 2), v36);
                  if (*(_DWORD *)v37 == 4)
                    break;
                  if (++v36 >= sk_num(*((const STACK **)v31 + 2)))
                    goto LABEL_90;
                }
                v38 = (X509_NAME *)*((_QWORD *)v37 + 1);
                if (!v38)
LABEL_90:
                  v38 = X509_get_issuer_name((X509 *)a1);
                DIST_POINT_set_dpname(*(_QWORD *)v31, v38);
              }
              v39 = ++v47;
            }
            while (v39 < sk_num(*(const STACK **)(a1 + 104)));
          }
        }
        else
        {
          *(_QWORD *)(a1 + 56) |= 0x80uLL;
        }
        v40 = (STACK *)X509_get_ext_d2i((X509 *)a1, 290, &crit, 0);
        *(_QWORD *)(a1 + 128) = v40;
        if (!v40 && crit != -1)
          *(_QWORD *)(a1 + 56) |= 0x80uLL;
        if (!X509v3_addr_is_canonical(v40))
          *(_QWORD *)(a1 + 56) |= 0x80uLL;
        v41 = (uint64_t *)X509_get_ext_d2i((X509 *)a1, 291, &crit, 0);
        *(_QWORD *)(a1 + 136) = v41;
        if (!v41 && crit != -1)
          *(_QWORD *)(a1 + 56) |= 0x80uLL;
        if (!X509v3_asid_is_canonical(v41))
          *(_QWORD *)(a1 + 56) |= 0x80uLL;
        crit = 0;
        if (X509_get_ext_count((X509 *)a1) >= 1)
        {
          while (1)
          {
            ext = X509_get_ext((X509 *)a1, crit);
            object = X509_EXTENSION_get_object(ext);
            if (OBJ_obj2nid(object) == 857)
              *(_QWORD *)(a1 + 56) |= 0x1000uLL;
            if (X509_EXTENSION_get_critical(ext) && !X509_supported_extension(ext))
              break;
            v44 = ++crit;
            if (v44 >= X509_get_ext_count((X509 *)a1))
              goto LABEL_111;
          }
          *(_QWORD *)(a1 + 56) |= 0x200uLL;
        }
LABEL_111:
        x509_verify_cert_info_populate(a1);
        *(_QWORD *)(a1 + 56) |= 0x100uLL;
        goto LABEL_112;
      }
      v9 = 128;
    }
    *(_QWORD *)(a1 + 56) |= v9;
    goto LABEL_19;
  }
  return (v1 & 0x80) == 0;
}

int X509_PURPOSE_get_by_id(int id)
{
  uint64_t v1;
  uint64_t v2;
  int result;
  int v5;
  _OWORD v6[3];
  uint64_t v7;
  uint64_t v8;

  result = id - 1;
  if (result >= 9)
  {
    v7 = v1;
    v8 = v2;
    memset(v6, 0, sizeof(v6));
    LODWORD(v6[0]) = id;
    if (xptable)
    {
      v5 = sk_find((STACK *)xptable, (char *)v6);
      if (v5 == -1)
        return -1;
      else
        return v5 + 9;
    }
    else
    {
      return -1;
    }
  }
  return result;
}

X509_PURPOSE *__cdecl X509_PURPOSE_get0(int idx)
{
  if (idx < 0)
    return 0;
  if (idx > 8)
    return (X509_PURPOSE *)sk_value((const STACK *)xptable, idx - 9);
  return (X509_PURPOSE *)((char *)&xstandard + 48 * idx);
}

int X509_PURPOSE_set(int *p, int purpose)
{
  if (X509_PURPOSE_get_by_id(purpose) == -1)
  {
    ERR_put_error(34, 4095, 146, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_purp.c", 149);
    return 0;
  }
  else
  {
    *p = purpose;
    return 1;
  }
}

int X509_PURPOSE_get_count(void)
{
  if (xptable)
    return sk_num((const STACK *)xptable) + 9;
  else
    return 9;
}

int X509_PURPOSE_get_by_sname(char *sname)
{
  unint64_t v2;
  char *i;
  int v4;
  char *v5;

  v2 = 0;
  for (i = (char *)&xstandard; ; i += 48)
  {
    v4 = xptable ? sk_num((const STACK *)xptable) + 9 : 9;
    if ((uint64_t)v2 >= v4)
      break;
    v5 = i;
    if (v2 >= 9)
      v5 = sk_value((const STACK *)xptable, (int)v2 - 9);
    if (!strcmp(*((const char **)v5 + 4), sname))
      return v2;
    ++v2;
  }
  LODWORD(v2) = -1;
  return v2;
}

int X509_PURPOSE_add(int id, int trust, int flags, int (__cdecl *ck)(const X509_PURPOSE *, const X509 *, int), char *name, char *sname, void *arg)
{
  unsigned int v14;
  unsigned int v15;
  char *v16;
  int v17;
  int v18;
  char *v19;
  char *v20;
  char *v21;
  unsigned int v22;
  int v23;
  STACK *v24;

  if (name && sname)
  {
    v14 = X509_PURPOSE_get_by_id(id);
    v15 = v14;
    if (v14 == -1)
    {
      v19 = (char *)malloc_type_malloc(0x30uLL, 0x109004064E8B8A4uLL);
      if (!v19)
      {
        v17 = 65;
        v18 = 235;
        goto LABEL_25;
      }
      v16 = v19;
      *((_DWORD *)v19 + 2) = 1;
    }
    else if ((v14 & 0x80000000) != 0)
    {
      v16 = 0;
    }
    else if (v14 > 8)
    {
      v16 = sk_value((const STACK *)xptable, v14 - 9);
    }
    else
    {
      v16 = (char *)&xstandard + 48 * v14;
    }
    v20 = strdup(name);
    if (v20)
    {
      v21 = strdup(sname);
      if (v21)
      {
        v22 = flags & 0xFFFFFFFC;
        v23 = *((_DWORD *)v16 + 2);
        if ((v23 & 2) != 0)
        {
          free(*((void **)v16 + 3));
          free(*((void **)v16 + 4));
          v23 = *((_DWORD *)v16 + 2);
        }
        *((_DWORD *)v16 + 1) = trust;
        *((_DWORD *)v16 + 2) = v22 | v23 & 1 | 2;
        *(_DWORD *)v16 = id;
        *((_QWORD *)v16 + 2) = ck;
        *((_QWORD *)v16 + 3) = v20;
        *((_QWORD *)v16 + 4) = v21;
        *((_QWORD *)v16 + 5) = arg;
        if (v15 != -1)
          return 1;
        v24 = (STACK *)xptable;
        if (xptable
          || (v24 = sk_new((int (__cdecl *)(const char *const *, const char *const *))xp_cmp),
              (xptable = (uint64_t)v24) != 0))
        {
          if (sk_push(v24, v16))
            return 1;
        }
      }
    }
    else
    {
      v21 = 0;
    }
    free(v20);
    free(v21);
    if (v15 == -1)
      free(v16);
    v17 = 65;
    v18 = 280;
  }
  else
  {
    v17 = 107;
    v18 = 222;
  }
LABEL_25:
  ERR_put_error(34, 4095, v17, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_purp.c", v18);
  return 0;
}

uint64_t xp_cmp(_DWORD **a1, _DWORD **a2)
{
  return (**a1 - **a2);
}

void X509_PURPOSE_cleanup(void)
{
  sk_pop_free((STACK *)xptable, (void (__cdecl *)(void *))xptable_free);
  xptable = 0;
}

void xptable_free(void *a1)
{
  int v2;

  if (a1)
  {
    v2 = *((_DWORD *)a1 + 2);
    if ((v2 & 1) != 0)
    {
      if ((v2 & 2) != 0)
      {
        free(*((void **)a1 + 3));
        free(*((void **)a1 + 4));
      }
      free(a1);
    }
  }
}

int X509_PURPOSE_get_id(X509_PURPOSE *a1)
{
  return a1->purpose;
}

char *__cdecl X509_PURPOSE_get0_name(X509_PURPOSE *xp)
{
  return xp->name;
}

char *__cdecl X509_PURPOSE_get0_sname(X509_PURPOSE *xp)
{
  return xp->sname;
}

int X509_PURPOSE_get_trust(X509_PURPOSE *xp)
{
  return xp->trust;
}

int X509_supported_extension(X509_EXTENSION *ex)
{
  ASN1_OBJECT *object;
  int result;
  char key[4];

  object = X509_EXTENSION_get_object(ex);
  result = OBJ_obj2nid(object);
  *(_DWORD *)key = result;
  if (result)
    return OBJ_bsearch_(key, "G", 12, 4, (int (__cdecl *)(const void *, const void *))nid_cmp_BSEARCH_CMP_FN) != 0;
  return result;
}

int X509_check_ca(X509 *x)
{
  x509v3_cache_extensions((uint64_t)x);
  return check_ca((uint64_t)x);
}

uint64_t check_ca(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;

  v1 = *(_QWORD *)(a1 + 56);
  if ((v1 & 2) != 0 && (*(_BYTE *)(a1 + 64) & 4) == 0)
    return 0;
  if ((v1 & 1) != 0)
    return (v1 >> 4) & 1;
  if ((*(_QWORD *)(a1 + 56) & 0x2040) == 0x2040)
    v2 = 3;
  else
    v2 = 4;
  if ((*(_QWORD *)(a1 + 56) & 0x2040) != 0x2040 && (*(_QWORD *)(a1 + 56) & 2) == 0)
  {
    if ((v1 & 8) != 0 && (*(_BYTE *)(a1 + 80) & 7) != 0)
      return 5;
    return 0;
  }
  return v2;
}

int X509_check_issued(X509 *issuer, X509 *subject)
{
  X509_NAME *subject_name;
  X509_NAME *issuer_name;
  int result;
  unint64_t ex_nscert;

  subject_name = X509_get_subject_name(issuer);
  issuer_name = X509_get_issuer_name(subject);
  if (X509_NAME_cmp(subject_name, issuer_name))
    return 29;
  if (!x509v3_cache_extensions((uint64_t)issuer) || !x509v3_cache_extensions((uint64_t)subject))
    return 1;
  ex_nscert = subject->ex_nscert;
  if (!ex_nscert || (result = X509_check_akid(issuer, ex_nscert)) == 0)
  {
    if ((issuer->ex_pathlen & 2) == 0 || (issuer->ex_pcpathlen & 4) != 0)
      return 0;
    else
      return 32;
  }
  return result;
}

uint64_t X509_check_akid(X509 *x, uint64_t a2)
{
  ASN1_OCTET_STRING *v4;
  ASN1_OCTET_STRING *ex_xkusage;
  ASN1_INTEGER *serialNumber;
  const STACK *v8;
  int v9;
  char *v10;
  const X509_NAME *v11;
  X509_NAME *issuer_name;

  if (!a2)
    return 0;
  v4 = *(ASN1_OCTET_STRING **)a2;
  if (*(_QWORD *)a2)
  {
    ex_xkusage = (ASN1_OCTET_STRING *)x->ex_xkusage;
    if (ex_xkusage)
    {
      if (ASN1_OCTET_STRING_cmp(v4, ex_xkusage))
        return 30;
    }
  }
  if (*(_QWORD *)(a2 + 16))
  {
    serialNumber = X509_get_serialNumber(x);
    if (ASN1_INTEGER_cmp(serialNumber, *(ASN1_INTEGER **)(a2 + 16)))
      return 31;
  }
  v8 = *(const STACK **)(a2 + 8);
  if (v8 && sk_num(v8) >= 1)
  {
    v9 = 0;
    while (1)
    {
      v10 = sk_value(v8, v9);
      if (*(_DWORD *)v10 == 4)
        break;
      if (++v9 >= sk_num(v8))
        return 0;
    }
    v11 = (const X509_NAME *)*((_QWORD *)v10 + 1);
    if (v11)
    {
      issuer_name = X509_get_issuer_name(x);
      if (X509_NAME_cmp(v11, issuer_name))
        return 31;
    }
  }
  return 0;
}

uint64_t X509_get_extension_flags(uint64_t a1)
{
  if (x509v3_cache_extensions(a1))
    return *(unsigned int *)(a1 + 56);
  else
    return 128;
}

uint64_t X509_get_key_usage(uint64_t a1)
{
  uint64_t result;

  result = x509v3_cache_extensions(a1);
  if ((_DWORD)result)
  {
    if ((*(_BYTE *)(a1 + 56) & 2) != 0)
      return *(unsigned int *)(a1 + 64);
    else
      return 0xFFFFFFFFLL;
  }
  return result;
}

uint64_t X509_get_extended_key_usage(uint64_t a1)
{
  uint64_t result;

  result = x509v3_cache_extensions(a1);
  if ((_DWORD)result)
  {
    if ((*(_BYTE *)(a1 + 56) & 4) != 0)
      return *(unsigned int *)(a1 + 72);
    else
      return 0xFFFFFFFFLL;
  }
  return result;
}

uint64_t check_purpose_ssl_client(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v4;
  uint64_t result;

  v4 = *(_QWORD *)(a2 + 56);
  if ((v4 & 4) != 0 && (*(_BYTE *)(a2 + 72) & 2) == 0)
    return 0;
  if (!a3)
    return ((v4 & 2) == 0 || (*(_BYTE *)(a2 + 64) & 0x80) != 0) && ((v4 & 8) == 0 || (*(_BYTE *)(a2 + 80) & 0x80) != 0);
  result = check_ca(a2);
  if ((_DWORD)result == 5)
  {
    if ((*(_BYTE *)(a2 + 80) & 4) != 0)
      return 5;
    else
      return 0;
  }
  return result;
}

uint64_t check_purpose_ssl_server(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v4;
  uint64_t result;

  v4 = *(_QWORD *)(a2 + 56);
  if ((v4 & 4) != 0 && (*(_BYTE *)(a2 + 72) & 0x11) == 0)
    return 0;
  if (!a3)
    return ((v4 & 8) == 0 || (*(_BYTE *)(a2 + 80) & 0x40) != 0) && ((v4 & 2) == 0 || (*(_BYTE *)(a2 + 64) & 0xA0) != 0);
  result = check_ca(a2);
  if ((_DWORD)result == 5)
  {
    if ((*(_BYTE *)(a2 + 80) & 4) != 0)
      return 5;
    else
      return 0;
  }
  return result;
}

uint64_t check_purpose_ns_ssl_server(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t result;

  result = check_purpose_ssl_server(a1, a2, a3);
  if (!a3 && (_DWORD)result && (*(_BYTE *)(a2 + 56) & 2) != 0 && (*(_BYTE *)(a2 + 64) & 0x20) == 0)
    return 0;
  return result;
}

uint64_t check_purpose_smime_sign(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t result;

  result = purpose_smime(a2, a3);
  if (!a3 && (_DWORD)result && (*(_BYTE *)(a2 + 56) & 2) != 0 && (*(_BYTE *)(a2 + 64) & 0xC0) == 0)
    return 0;
  return result;
}

uint64_t check_purpose_smime_encrypt(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t result;

  result = purpose_smime(a2, a3);
  if (!a3 && (_DWORD)result && (*(_BYTE *)(a2 + 56) & 2) != 0 && (*(_BYTE *)(a2 + 64) & 0x20) == 0)
    return 0;
  return result;
}

uint64_t check_purpose_crl_sign(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t result;

  if (!a3)
    return (*(_BYTE *)(a2 + 56) & 2) == 0 || (*(_BYTE *)(a2 + 64) & 2) != 0;
  LODWORD(result) = check_ca(a2);
  if ((_DWORD)result == 2)
    return 0;
  else
    return result;
}

uint64_t no_check()
{
  return 1;
}

uint64_t ocsp_helper(uint64_t a1, uint64_t a2, int a3)
{
  if (a3)
    return check_ca(a2);
  else
    return 1;
}

uint64_t check_purpose_timestamp_sign(int a1, X509 *x, int a3)
{
  uint64_t result;
  uint64_t ex_pathlen;
  int ext_by_NID;
  X509_EXTENSION *ext;

  if (a3)
    return check_ca((uint64_t)x);
  ex_pathlen = x->ex_pathlen;
  if ((ex_pathlen & 2) != 0)
  {
    result = 0;
    if ((ex_pathlen & 4) == 0)
      return result;
    if ((x->ex_pcpathlen & 0xFFFFFFFFFFFFFF3FLL) != 0 || (x->ex_pcpathlen & 0xC0) == 0)
      return result;
  }
  else if ((ex_pathlen & 4) == 0)
  {
    return 0;
  }
  if (x->ex_flags != 64)
    return 0;
  ext_by_NID = X509_get_ext_by_NID(x, 126, -1);
  if (ext_by_NID < 0)
    return 1;
  ext = X509_get_ext(x, ext_by_NID);
  result = X509_EXTENSION_get_critical(ext);
  if ((_DWORD)result)
    return 1;
  return result;
}

uint64_t purpose_smime(uint64_t a1, int a2)
{
  uint64_t v3;
  uint64_t result;
  uint64_t v5;

  v3 = *(_QWORD *)(a1 + 56);
  if ((v3 & 4) != 0 && (*(_BYTE *)(a1 + 72) & 4) == 0)
    return 0;
  if (a2)
  {
    result = check_ca(a1);
    if ((_DWORD)result == 5)
    {
      if ((*(_BYTE *)(a1 + 80) & 2) != 0)
        return 5;
      else
        return 0;
    }
  }
  else if ((v3 & 8) != 0)
  {
    v5 = *(_QWORD *)(a1 + 80);
    if ((v5 & 0x20) != 0)
      return 1;
    else
      return (v5 >> 6) & 2;
  }
  else
  {
    return 1;
  }
  return result;
}

uint64_t nid_cmp_BSEARCH_CMP_FN(_DWORD *a1, _DWORD *a2)
{
  return (*a1 - *a2);
}

char **EC_KEY_OpenSSL()
{
  return &openssl_ec_key_method;
}

uint64_t EC_KEY_get_default_method()
{
  return default_ec_key_meth;
}

char **EC_KEY_set_default_method(char **result)
{
  char **v1;

  v1 = &openssl_ec_key_method;
  if (result)
    v1 = result;
  default_ec_key_meth = (uint64_t)v1;
  return result;
}

uint64_t EC_KEY_get_method(uint64_t a1)
{
  return *(_QWORD *)a1;
}

uint64_t EC_KEY_set_method(ENGINE **a1, uint64_t a2)
{
  void (*v4)(ENGINE **);
  uint64_t (*v5)(ENGINE **);

  v4 = (void (*)(ENGINE **))*((_QWORD *)*a1 + 3);
  if (v4)
    v4(a1);
  ENGINE_finish(a1[1]);
  *a1 = (ENGINE *)a2;
  a1[1] = 0;
  v5 = *(uint64_t (**)(ENGINE **))(a2 + 16);
  if (v5)
    return v5(a1);
  else
    return 1;
}

uint64_t *EC_KEY_new_method(ENGINE *default_EC)
{
  uint64_t *v2;
  uint64_t *v3;
  uint64_t EC;
  unsigned int (*v5)(uint64_t *);
  int v6;

  v2 = (uint64_t *)malloc_type_calloc(1uLL, 0x50uLL, 0x1060040AF32F034uLL);
  v3 = v2;
  if (!v2)
  {
    ERR_put_error(16, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_kmeth.c", 142);
    return v3;
  }
  *v2 = default_ec_key_meth;
  if (default_EC)
  {
    if (!ENGINE_init(default_EC))
    {
      v6 = 149;
      goto LABEL_14;
    }
    v3[1] = (uint64_t)default_EC;
LABEL_7:
    EC = ENGINE_get_EC((uint64_t)default_EC);
    *v3 = EC;
    if (EC)
      goto LABEL_8;
    v6 = 158;
LABEL_14:
    ERR_put_error(16, 4095, 38, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_kmeth.c", v6);
LABEL_15:
    EC_KEY_free((EC_KEY *)v3);
    return 0;
  }
  default_EC = (ENGINE *)ENGINE_get_default_EC();
  v3[1] = (uint64_t)default_EC;
  if (default_EC)
    goto LABEL_7;
LABEL_8:
  *((_DWORD *)v3 + 4) = 1;
  *((_DWORD *)v3 + 15) = 0;
  v3[4] = 0;
  v3[5] = 0;
  v3[3] = 0;
  *((_DWORD *)v3 + 12) = 0;
  *(uint64_t *)((char *)v3 + 52) = 0x100000004;
  v3[8] = 0;
  if (!CRYPTO_new_ex_data(6, v3, (CRYPTO_EX_DATA *)(v3 + 9)))
    goto LABEL_15;
  v5 = *(unsigned int (**)(uint64_t *))(*v3 + 16);
  if (v5)
  {
    if (!v5(v3))
      goto LABEL_15;
  }
  return v3;
}

_OWORD *EC_KEY_METHOD_new(__int128 *a1)
{
  _OWORD *result;
  __int128 v3;
  __int128 v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;

  result = malloc_type_calloc(1uLL, 0x78uLL, 0x10D0040F56C2D54uLL);
  if (result)
  {
    if (a1)
    {
      v3 = *a1;
      v4 = a1[1];
      v5 = a1[3];
      result[2] = a1[2];
      result[3] = v5;
      *result = v3;
      result[1] = v4;
      v6 = a1[4];
      v7 = a1[5];
      v8 = a1[6];
      *((_QWORD *)result + 14) = *((_QWORD *)a1 + 14);
      result[5] = v7;
      result[6] = v8;
      result[4] = v6;
    }
    *((_DWORD *)result + 2) |= 1u;
  }
  return result;
}

void EC_KEY_METHOD_free(void *a1)
{
  if (a1)
  {
    if ((*((_BYTE *)a1 + 8) & 1) != 0)
      free(a1);
  }
}

_QWORD *EC_KEY_METHOD_set_init(_QWORD *result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  result[2] = a2;
  result[3] = a3;
  result[4] = a4;
  result[5] = a5;
  result[6] = a6;
  result[7] = a7;
  return result;
}

uint64_t EC_KEY_METHOD_set_keygen(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 64) = a2;
  return result;
}

uint64_t EC_KEY_METHOD_set_compute_key(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 72) = a2;
  return result;
}

_QWORD *EC_KEY_METHOD_set_sign(_QWORD *result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  result[10] = a2;
  result[11] = a3;
  result[12] = a4;
  return result;
}

uint64_t EC_KEY_METHOD_set_verify(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 104) = a2;
  *(_QWORD *)(result + 112) = a3;
  return result;
}

_QWORD *EC_KEY_METHOD_get_init(_QWORD *result, _QWORD *a2, _QWORD *a3, _QWORD *a4, _QWORD *a5, _QWORD *a6, _QWORD *a7)
{
  if (a2)
    *a2 = result[2];
  if (a3)
    *a3 = result[3];
  if (a4)
    *a4 = result[4];
  if (a5)
    *a5 = result[5];
  if (a6)
    *a6 = result[6];
  if (a7)
    *a7 = result[7];
  return result;
}

uint64_t EC_KEY_METHOD_get_keygen(uint64_t result, _QWORD *a2)
{
  if (a2)
    *a2 = *(_QWORD *)(result + 64);
  return result;
}

uint64_t EC_KEY_METHOD_get_compute_key(uint64_t result, _QWORD *a2)
{
  if (a2)
    *a2 = *(_QWORD *)(result + 72);
  return result;
}

_QWORD *EC_KEY_METHOD_get_sign(_QWORD *result, _QWORD *a2, _QWORD *a3, _QWORD *a4)
{
  if (a2)
    *a2 = result[10];
  if (a3)
    *a3 = result[11];
  if (a4)
    *a4 = result[12];
  return result;
}

uint64_t EC_KEY_METHOD_get_verify(uint64_t result, _QWORD *a2, _QWORD *a3)
{
  if (a2)
    *a2 = *(_QWORD *)(result + 104);
  if (a3)
    *a3 = *(_QWORD *)(result + 112);
  return result;
}

void BF_ofb64_encrypt(const unsigned __int8 *in, unsigned __int8 *out, uint64_t length, const BF_KEY *schedule, unsigned __int8 *ivec, int *num)
{
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  unsigned int v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  uint64_t v20;
  int v23;
  char v24;
  unsigned int data;
  int v26;
  unsigned int v27;
  unsigned int v28;
  uint64_t v29;

  v29 = *MEMORY[0x24BDAC8D0];
  v7 = *num;
  v8 = *ivec;
  v9 = ivec[1];
  v10 = ivec[2];
  v11 = ivec[3];
  v12 = (v8 << 24) | (v9 << 16) | (v10 << 8) | v11;
  v13 = ivec[4];
  v14 = ivec[5];
  v15 = ivec[6];
  v16 = ivec[7];
  v17 = (v13 << 24) | (v14 << 16) | (v15 << 8) | v16;
  data = v12;
  v26 = v17;
  LOBYTE(v27) = v8;
  BYTE1(v27) = v9;
  BYTE2(v27) = v10;
  HIBYTE(v27) = v11;
  LOBYTE(v28) = v13;
  BYTE1(v28) = v14;
  BYTE2(v28) = v15;
  HIBYTE(v28) = v16;
  if (length)
  {
    v20 = length;
    v23 = 0;
    do
    {
      if (!v7)
      {
        BF_encrypt(&data, schedule);
        v12 = data;
        v17 = v26;
        v27 = bswap32(data);
        v28 = bswap32(v26);
        ++v23;
      }
      v24 = *in++;
      *out++ = *((_BYTE *)&v27 + v7) ^ v24;
      v7 = (v7 + 1) & 7;
      --v20;
    }
    while (v20);
    if (v23)
    {
      *ivec = HIBYTE(v12);
      ivec[1] = BYTE2(v12);
      ivec[2] = BYTE1(v12);
      ivec[3] = v12;
      ivec[4] = HIBYTE(v17);
      ivec[5] = BYTE2(v17);
      ivec[6] = BYTE1(v17);
      ivec[7] = v17;
    }
  }
  *num = v7;
}

const EVP_CIPHER *EVP_bf_cbc(void)
{
  return (const EVP_CIPHER *)&bf_cbc;
}

const EVP_CIPHER *EVP_bf_cfb64(void)
{
  return (const EVP_CIPHER *)&bf_cfb64;
}

const EVP_CIPHER *EVP_bf_ofb(void)
{
  return (const EVP_CIPHER *)&bf_ofb;
}

const EVP_CIPHER *EVP_bf_ecb(void)
{
  return (const EVP_CIPHER *)&bf_ecb;
}

uint64_t bf_init_key(const EVP_CIPHER_CTX *a1, const unsigned __int8 *a2)
{
  BF_KEY *cipher_data;
  int v4;

  cipher_data = (BF_KEY *)a1->cipher_data;
  v4 = EVP_CIPHER_CTX_key_length(a1);
  BF_set_key(cipher_data, v4, a2);
  return 1;
}

uint64_t bf_cbc_cipher(uint64_t a1, unsigned __int8 *out, unsigned __int8 *in, unint64_t length)
{
  unint64_t i;

  for (i = length; i > 0x7FFFFFFFFFFFFEFFLL; out += 0x7FFFFFFFFFFFFF00)
  {
    BF_cbc_encrypt(in, out, 0x7FFFFFFFFFFFFF00, *(const BF_KEY **)(a1 + 120), (unsigned __int8 *)(a1 + 40), *(_DWORD *)(a1 + 16));
    i -= 0x7FFFFFFFFFFFFF00;
    in += 0x7FFFFFFFFFFFFF00;
  }
  if (i)
    BF_cbc_encrypt(in, out, i, *(const BF_KEY **)(a1 + 120), (unsigned __int8 *)(a1 + 40), *(_DWORD *)(a1 + 16));
  return 1;
}

uint64_t bf_cfb64_cipher(uint64_t a1, unsigned __int8 *out, unsigned __int8 *in, unint64_t a4)
{
  unint64_t v4;
  unint64_t v8;
  unsigned __int8 *v9;
  int *v10;

  if (a4)
  {
    v4 = a4;
    if (a4 >= 0x7FFFFFFFFFFFFF00)
      v8 = 0x7FFFFFFFFFFFFF00;
    else
      v8 = a4;
    v9 = (unsigned __int8 *)(a1 + 40);
    v10 = (int *)(a1 + 88);
    do
    {
      BF_cfb64_encrypt(in, out, v8, *(const BF_KEY **)(a1 + 120), v9, v10, *(_DWORD *)(a1 + 16));
      in += v8;
      out += v8;
      v4 -= v8;
      if (v4 < v8)
        v8 = v4;
    }
    while (v4);
  }
  return 1;
}

uint64_t bf_ofb_cipher(uint64_t a1, unsigned __int8 *out, unsigned __int8 *in, unint64_t length)
{
  unint64_t i;

  for (i = length; i > 0x7FFFFFFFFFFFFEFFLL; out += 0x7FFFFFFFFFFFFF00)
  {
    BF_ofb64_encrypt(in, out, 0x7FFFFFFFFFFFFF00, *(const BF_KEY **)(a1 + 120), (unsigned __int8 *)(a1 + 40), (int *)(a1 + 88));
    i -= 0x7FFFFFFFFFFFFF00;
    in += 0x7FFFFFFFFFFFFF00;
  }
  if (i)
    BF_ofb64_encrypt(in, out, i, *(const BF_KEY **)(a1 + 120), (unsigned __int8 *)(a1 + 40), (int *)(a1 + 88));
  return 1;
}

uint64_t bf_ecb_cipher(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  unint64_t v4;
  unint64_t v5;
  unint64_t v9;

  v4 = *(int *)(*(_QWORD *)a1 + 4);
  v5 = a4 - v4;
  if (a4 >= v4)
  {
    v9 = 0;
    do
    {
      BF_ecb_encrypt((const unsigned __int8 *)(a3 + v9), (unsigned __int8 *)(a2 + v9), *(const BF_KEY **)(a1 + 120), *(_DWORD *)(a1 + 16));
      v9 += v4;
    }
    while (v9 <= v5);
  }
  return 1;
}

void ERR_load_DH_strings(void)
{
  if (!ERR_func_error_string(DH_str_functs))
  {
    ERR_load_strings(0, (ERR_STRING_DATA *)&DH_str_functs);
    ERR_load_strings(0, (ERR_STRING_DATA *)&DH_str_reasons);
  }
}

int DH_generate_parameters_ex(DH *dh, int prime_len, int generator, BN_GENCB *cb)
{
  unint64_t v5;
  uint64_t (*v8)(DH *, _QWORD, _QWORD, BN_GENCB *);
  BN_CTX *v10;
  BN_CTX *v11;
  BIGNUM *v12;
  BIGNUM *v13;
  BIGNUM *v14;
  BIGNUM *v15;
  BIGNUM *v16;
  BIGNUM *v17;
  int v18;

  LODWORD(v5) = generator;
  v8 = *(uint64_t (**)(DH *, _QWORD, _QWORD, BN_GENCB *))(*(_QWORD *)&dh->ex_data.dummy + 64);
  if (v8)
    return v8(dh, *(_QWORD *)&prime_len, *(_QWORD *)&generator, cb);
  v10 = BN_CTX_new();
  if (!v10)
  {
    ERR_put_error(5, 4095, 3, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/dh/dh_gen.c", 168);
    return 0;
  }
  v11 = v10;
  BN_CTX_start(v10);
  v12 = BN_CTX_get(v11);
  if (!v12)
    goto LABEL_12;
  v13 = v12;
  v14 = BN_CTX_get(v11);
  if (!v14)
    goto LABEL_12;
  v15 = v14;
  if (!dh->p)
  {
    v16 = BN_new();
    dh->p = v16;
    if (!v16)
      goto LABEL_12;
  }
  if (!dh->g)
  {
    v17 = BN_new();
    dh->g = v17;
    if (!v17)
      goto LABEL_12;
  }
  if ((int)v5 > 1)
  {
    if ((_DWORD)v5 == 5)
    {
      if (!BN_set_word(v13, 0xAuLL) || !BN_set_word(v15, 3uLL))
        goto LABEL_12;
      v5 = 5;
    }
    else if ((_DWORD)v5 == 2)
    {
      if (!BN_set_word(v13, 0x18uLL) || !BN_set_word(v15, 0xBuLL))
        goto LABEL_12;
      v5 = 2;
    }
    else
    {
      if (!BN_set_word(v13, 2uLL) || !BN_set_word(v15, 1uLL))
        goto LABEL_12;
      v5 = v5;
    }
    if (BN_generate_prime_ex(dh->p, prime_len, 1, v13, v15, cb) && BN_GENCB_call(cb, 3, 0) && BN_set_word(dh->g, v5))
    {
      v18 = 1;
      goto LABEL_13;
    }
  }
  else
  {
    ERR_put_error(5, 4095, 101, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/dh/dh_gen.c", 128);
  }
LABEL_12:
  ERR_put_error(5, 4095, 3, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/dh/dh_gen.c", 168);
  v18 = 0;
LABEL_13:
  BN_CTX_end(v11);
  BN_CTX_free(v11);
  return v18;
}

DH *__cdecl DH_generate_parameters(int prime_len, int generator, void (__cdecl *callback)(int, int, void *), void *cb_arg)
{
  DH *v8;
  BN_GENCB cb;

  v8 = DH_new();
  if (v8)
  {
    memset(&cb, 0, sizeof(cb));
    BN_GENCB_set_old((uint64_t)&cb, (uint64_t)callback, (uint64_t)cb_arg);
    if (!DH_generate_parameters_ex(v8, prime_len, generator, &cb))
    {
      DH_free(v8);
      return 0;
    }
  }
  return v8;
}

const CRYPTO_EX_DATA_IMPL *CRYPTO_get_ex_data_implementation(void)
{
  const CRYPTO_EX_DATA_IMPL *result;

  result = (const CRYPTO_EX_DATA_IMPL *)impl;
  if (!impl)
  {
    impl_check();
    return (const CRYPTO_EX_DATA_IMPL *)impl;
  }
  return result;
}

void impl_check()
{
  CRYPTO_lock(9, 2, 0, 0);
  if (!impl)
    impl = (uint64_t)impl_default;
  CRYPTO_lock(10, 2, 0, 0);
}

int CRYPTO_set_ex_data_implementation(const CRYPTO_EX_DATA_IMPL *i)
{
  int v2;

  CRYPTO_lock(9, 2, 0, 0);
  v2 = 0;
  if (!impl)
  {
    impl = (uint64_t)i;
    v2 = 1;
  }
  CRYPTO_lock(10, 2, 0, 0);
  return v2;
}

int CRYPTO_ex_data_new_class(void)
{
  uint64_t (**v0)(void);

  v0 = (uint64_t (**)(void))impl;
  if (!impl)
  {
    impl_check();
    v0 = (uint64_t (**)(void))impl;
  }
  return (*v0)();
}

void CRYPTO_cleanup_all_ex_data(void)
{
  uint64_t v0;

  v0 = impl;
  if (!impl)
  {
    impl_check();
    v0 = impl;
  }
  (*(void (**)(void))(v0 + 8))();
}

int CRYPTO_get_ex_new_index(int class_index, uint64_t argl, void *argp, CRYPTO_EX_new *new_func, CRYPTO_EX_dup *dup_func, CRYPTO_EX_free *free_func)
{
  uint64_t v11;
  uint64_t v12;

  v11 = *(_QWORD *)&class_index;
  v12 = impl;
  if (!impl)
  {
    impl_check();
    v12 = impl;
  }
  return (*(uint64_t (**)(uint64_t, uint64_t, void *, CRYPTO_EX_new *, CRYPTO_EX_dup *, CRYPTO_EX_free *))(v12 + 16))(v11, argl, argp, new_func, dup_func, free_func);
}

int CRYPTO_new_ex_data(int class_index, void *obj, CRYPTO_EX_DATA *ad)
{
  uint64_t v5;
  uint64_t v6;

  v5 = *(_QWORD *)&class_index;
  v6 = impl;
  if (!impl)
  {
    impl_check();
    v6 = impl;
  }
  return (*(uint64_t (**)(uint64_t, void *, CRYPTO_EX_DATA *))(v6 + 24))(v5, obj, ad);
}

int CRYPTO_dup_ex_data(int class_index, CRYPTO_EX_DATA *to, CRYPTO_EX_DATA *from)
{
  uint64_t v5;
  uint64_t v6;

  v5 = *(_QWORD *)&class_index;
  v6 = impl;
  if (!impl)
  {
    impl_check();
    v6 = impl;
  }
  return (*(uint64_t (**)(uint64_t, CRYPTO_EX_DATA *, CRYPTO_EX_DATA *))(v6 + 32))(v5, to, from);
}

void CRYPTO_free_ex_data(int class_index, void *obj, CRYPTO_EX_DATA *ad)
{
  uint64_t v5;
  uint64_t v6;

  v5 = *(_QWORD *)&class_index;
  v6 = impl;
  if (!impl)
  {
    impl_check();
    v6 = impl;
  }
  (*(void (**)(uint64_t, void *, CRYPTO_EX_DATA *))(v6 + 40))(v5, obj, ad);
}

int CRYPTO_set_ex_data(CRYPTO_EX_DATA *ad, int idx, void *val)
{
  STACK *sk;
  int v7;
  int v8;
  int v10;

  sk = ad->sk;
  if (sk || (sk = sk_new_null(), (ad->sk = sk) != 0))
  {
    v7 = sk_num(sk);
    if (v7 > idx)
    {
LABEL_7:
      sk_set(ad->sk, idx, (char *)val);
      return 1;
    }
    v8 = idx - v7 + 1;
    while (sk_push(ad->sk, 0))
    {
      if (!--v8)
        goto LABEL_7;
    }
    v10 = 619;
  }
  else
  {
    v10 = 611;
  }
  ERR_put_error(15, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ex_data.c", v10);
  return 0;
}

void *__cdecl CRYPTO_get_ex_data(const CRYPTO_EX_DATA *ad, int idx)
{
  STACK *sk;

  sk = ad->sk;
  if (sk && sk_num(sk) > idx)
    return sk_value(ad->sk, idx);
  else
    return 0;
}

uint64_t int_new_class()
{
  uint64_t v0;

  CRYPTO_lock(9, 2, 0, 0);
  v0 = ex_class++;
  CRYPTO_lock(10, 2, 0, 0);
  return v0;
}

void int_cleanup()
{
  LHASH *v0;

  v0 = (LHASH *)ex_data;
  if (!ex_data)
  {
    if (!ex_data_check())
      return;
    v0 = (LHASH *)ex_data;
  }
  lh_doall(v0, (LHASH_DOALL_FN_TYPE)def_cleanup_cb);
  lh_free((LHASH *)ex_data);
  ex_data = 0;
  impl = 0;
}

uint64_t int_get_new_index(unsigned int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  _QWORD *v11;
  _QWORD *v12;
  _QWORD *v13;
  void *v14;
  int v15;
  uint64_t v16;

  v11 = def_get_class(a1);
  if (!v11)
    return 0xFFFFFFFFLL;
  v12 = v11;
  v13 = malloc_type_malloc(0x28uLL, 0x1080040EC4B14DAuLL);
  if (!v13)
  {
    ERR_put_error(15, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ex_data.c", 351);
    return 0xFFFFFFFFLL;
  }
  v14 = v13;
  *v13 = a2;
  v13[1] = a3;
  v13[3] = a6;
  v13[4] = a5;
  v13[2] = a4;
  CRYPTO_lock(9, 2, 0, 0);
  while (1)
  {
    v15 = sk_num((const STACK *)v12[1]);
    v16 = *((unsigned int *)v12 + 4);
    if (v15 > (int)v16)
      break;
    if (!sk_push((STACK *)v12[1], 0))
    {
      ERR_put_error(15, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ex_data.c", 362);
      free(v14);
      v16 = 0xFFFFFFFFLL;
      goto LABEL_10;
    }
  }
  *((_DWORD *)v12 + 4) = v16 + 1;
  sk_set((STACK *)v12[1], v16, (char *)v14);
LABEL_10:
  CRYPTO_lock(10, 2, 0, 0);
  return v16;
}

uint64_t int_new_ex_data(unsigned int a1, uint64_t a2, const CRYPTO_EX_DATA *a3)
{
  uint64_t result;
  uint64_t v6;
  int v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t i;
  uint64_t v11;
  void *v12;

  result = (uint64_t)def_get_class(a1);
  if (result)
  {
    v6 = result;
    a3->sk = 0;
    CRYPTO_lock(5, 2, 0, 0);
    v7 = sk_num(*(const STACK **)(v6 + 8));
    if (v7 < 1)
    {
      v8 = 0;
    }
    else
    {
      v8 = reallocarray(0, v7, 8uLL);
      if (v8)
      {
        v9 = 0;
        do
        {
          v8[v9] = sk_value(*(const STACK **)(v6 + 8), v9);
          ++v9;
        }
        while (v7 != v9);
      }
    }
    CRYPTO_lock(6, 2, 0, 0);
    if (v7 < 1 || v8)
    {
      if (v7 >= 1)
      {
        for (i = 0; i != v7; ++i)
        {
          v11 = v8[i];
          if (v11)
          {
            if (*(_QWORD *)(v11 + 16))
            {
              v12 = CRYPTO_get_ex_data(a3, i);
              (*(void (**)(uint64_t, void *, const CRYPTO_EX_DATA *, uint64_t, _QWORD, _QWORD))(v8[i] + 16))(a2, v12, a3, i, *(_QWORD *)v8[i], *(_QWORD *)(v8[i] + 8));
            }
          }
        }
      }
      free(v8);
      return 1;
    }
    else
    {
      ERR_put_error(15, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ex_data.c", 439);
      return 0;
    }
  }
  return result;
}

uint64_t int_dup_ex_data(unsigned int a1, CRYPTO_EX_DATA *a2, const CRYPTO_EX_DATA *a3)
{
  uint64_t result;
  uint64_t v6;
  unint64_t v7;
  int v8;
  _QWORD *v9;
  uint64_t i;
  uint64_t j;
  void *v12;
  _QWORD *v13;
  void (*v14)(CRYPTO_EX_DATA *, const CRYPTO_EX_DATA *, void **, uint64_t, _QWORD, _QWORD);
  void *val;

  if (a3->sk)
  {
    result = (uint64_t)def_get_class(a1);
    if (!result)
      return result;
    v6 = result;
    val = 0;
    CRYPTO_lock(5, 2, 0, 0);
    LODWORD(v7) = sk_num(*(const STACK **)(v6 + 8));
    v8 = sk_num(a3->sk);
    if (v8 >= (int)v7)
      v7 = v7;
    else
      v7 = v8;
    if ((int)v7 < 1)
    {
      v9 = 0;
    }
    else
    {
      v9 = reallocarray(0, v7, 8uLL);
      if (v9)
      {
        for (i = 0; i != v7; ++i)
          v9[i] = sk_value(*(const STACK **)(v6 + 8), i);
      }
    }
    CRYPTO_lock(6, 2, 0, 0);
    if ((int)v7 >= 1 && !v9)
    {
      ERR_put_error(15, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ex_data.c", 483);
      return 0;
    }
    if ((int)v7 >= 1)
    {
      for (j = 0; j != v7; ++j)
      {
        v12 = CRYPTO_get_ex_data(a3, j);
        val = v12;
        v13 = (_QWORD *)v9[j];
        if (v13)
        {
          v14 = (void (*)(CRYPTO_EX_DATA *, const CRYPTO_EX_DATA *, void **, uint64_t, _QWORD, _QWORD))v13[4];
          if (v14)
          {
            v14(a2, a3, &val, j, *v13, v13[1]);
            v12 = val;
          }
        }
        CRYPTO_set_ex_data(a2, j, v12);
      }
    }
    free(v9);
  }
  return 1;
}

void int_free_ex_data(unsigned int a1, uint64_t a2, const CRYPTO_EX_DATA *a3)
{
  _QWORD *v5;
  _QWORD *v6;
  int v7;
  _QWORD *v8;
  uint64_t i;
  uint64_t j;
  uint64_t v11;
  void *v12;

  v5 = def_get_class(a1);
  if (v5)
  {
    v6 = v5;
    CRYPTO_lock(5, 2, 0, 0);
    v7 = sk_num((const STACK *)v6[1]);
    if (v7 < 1)
    {
      v8 = 0;
    }
    else
    {
      v8 = reallocarray(0, v7, 8uLL);
      if (v8)
      {
        for (i = 0; i != v7; ++i)
          v8[i] = sk_value((const STACK *)v6[1], i);
      }
    }
    CRYPTO_lock(6, 2, 0, 0);
    if (v7 < 1 || v8)
    {
      if (v7 >= 1)
      {
        for (j = 0; j != v7; ++j)
        {
          v11 = v8[j];
          if (v11 && *(_QWORD *)(v11 + 24))
          {
            v12 = CRYPTO_get_ex_data(a3, j);
            (*(void (**)(uint64_t, void *, const CRYPTO_EX_DATA *, uint64_t, _QWORD, _QWORD))(v8[j] + 24))(a2, v12, a3, j, *(_QWORD *)v8[j], *(_QWORD *)(v8[j] + 8));
          }
        }
      }
      free(v8);
      if (a3->sk)
      {
        sk_free(a3->sk);
        a3->sk = 0;
      }
    }
    else
    {
      ERR_put_error(15, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ex_data.c", 521);
    }
  }
}

BOOL ex_data_check()
{
  _BOOL8 v0;

  CRYPTO_lock(9, 2, 0, 0);
  if (ex_data)
  {
    v0 = 1;
  }
  else
  {
    ex_data = (uint64_t)lh_new((LHASH_HASH_FN_TYPE)ex_class_item_LHASH_HASH, (LHASH_COMP_FN_TYPE)ex_class_item_LHASH_COMP);
    v0 = ex_data != 0;
  }
  CRYPTO_lock(10, 2, 0, 0);
  return v0;
}

void def_cleanup_cb(STACK **a1)
{
  sk_pop_free(a1[1], def_cleanup_util_cb);
  free(a1);
}

uint64_t ex_class_item_LHASH_HASH(int *a1)
{
  return *a1;
}

uint64_t ex_class_item_LHASH_COMP(_DWORD *a1, _DWORD *a2)
{
  return (*a1 - *a2);
}

_QWORD *def_get_class(unsigned int a1)
{
  _QWORD *v2;
  _DWORD *v3;
  STACK *v4;
  _QWORD data[3];

  if (!ex_data && !ex_data_check())
    return 0;
  data[1] = 0;
  data[2] = 0;
  data[0] = a1;
  if (!OPENSSL_init_crypto(0))
    return 0;
  CRYPTO_lock(9, 2, 0, 0);
  v2 = lh_retrieve((LHASH *)ex_data, data);
  if (!v2)
  {
    v3 = malloc_type_malloc(0x18uLL, 0x1020040903548AEuLL);
    if (v3)
    {
      v2 = v3;
      *v3 = a1;
      v3[4] = 0;
      v4 = sk_new_null();
      v2[1] = v4;
      if (v4)
      {
        lh_insert((LHASH *)ex_data, v2);
        goto LABEL_5;
      }
      free(v2);
    }
    CRYPTO_lock(10, 2, 0, 0);
    ERR_put_error(15, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ex_data.c", 337);
    return 0;
  }
LABEL_5:
  CRYPTO_lock(10, 2, 0, 0);
  return v2;
}

void DES_ede3_cfb64_encrypt(const unsigned __int8 *in, unsigned __int8 *out, uint64_t length, DES_key_schedule *ks1, DES_key_schedule *ks2, DES_key_schedule *ks3, DES_cblock *ivec, int *num, int enc)
{
  uint64_t v14;
  int v17;
  __int16 v18;
  int v19;
  char v20;
  unsigned __int8 v21;
  __int16 v22;
  int v23;
  unsigned __int8 v24;
  unsigned __int8 v25;
  _QWORD v26[2];

  v14 = length;
  v26[1] = *MEMORY[0x24BDAC8D0];
  v17 = *num;
  if (enc)
  {
    if (length)
    {
      do
      {
        if (!v17)
        {
          v26[0] = *(_QWORD *)ivec;
          DES_encrypt3((unsigned int *)v26, ks1, ks2, ks3);
          v18 = WORD1(v26[0]);
          v19 = HIDWORD(v26[0]);
          *(_WORD *)ivec = v26[0];
          *(_WORD *)&(*ivec)[2] = v18;
          *(_DWORD *)&(*ivec)[4] = v19;
        }
        v20 = *in++;
        v21 = (*ivec)[v17];
        *out++ = v21 ^ v20;
        (*ivec)[v17] = v21 ^ v20;
        v17 = (v17 + 1) & 7;
        --v14;
      }
      while (v14);
    }
  }
  else if (length)
  {
    do
    {
      if (!v17)
      {
        v26[0] = *(_QWORD *)ivec;
        DES_encrypt3((unsigned int *)v26, ks1, ks2, ks3);
        v22 = WORD1(v26[0]);
        v23 = HIDWORD(v26[0]);
        *(_WORD *)ivec = v26[0];
        *(_WORD *)&(*ivec)[2] = v22;
        *(_DWORD *)&(*ivec)[4] = v23;
      }
      v24 = *in++;
      v25 = (*ivec)[v17];
      (*ivec)[v17] = v24;
      *out++ = v25 ^ v24;
      v17 = (v17 + 1) & 7;
      --v14;
    }
    while (v14);
  }
  *num = v17;
}

void DES_ede3_cfb_encrypt(const unsigned __int8 *in, unsigned __int8 *out, int numbits, uint64_t length, DES_key_schedule *ks1, DES_key_schedule *ks2, DES_key_schedule *ks3, DES_cblock *ivec, int enc)
{
  int v9;
  DES_key_schedule *v10;
  unint64_t v11;
  unint64_t v14;
  unsigned int v15;
  unsigned int v16;
  unsigned int v17;
  int v18;
  const unsigned __int8 *v19;
  int v20;
  int v21;
  int v22;
  int v23;
  int v24;
  int v25;
  int v26;
  int v27;
  int v28;
  int v29;
  unsigned int v30;
  int v31;
  unsigned __int8 *v32;
  const char *v33;
  int8x8_t v34;
  uint16x8_t v35;
  uint16x8_t v36;
  unsigned int v37;
  unsigned int v38;
  const unsigned __int8 *v39;
  unsigned int v40;
  int v41;
  int v42;
  int v43;
  int v44;
  int v45;
  int v46;
  int v47;
  int v48;
  const char *v49;
  int8x8_t v50;
  uint16x8_t v51;
  uint16x8_t v52;
  unsigned __int8 *v53;
  unsigned int v54;
  int v55;
  uint32x4_t v56;
  uint32x4_t v58;
  uint32x4_t v59;
  uint32x4_t v60;
  unsigned int v61;
  _BYTE v66[12];
  int v67;
  unsigned int data;
  unsigned int v69;
  uint64_t v70;

  v70 = *MEMORY[0x24BDAC8D0];
  if (numbits <= 64)
  {
    v10 = ks3;
    v11 = length;
    v14 = (numbits + 7) >> 3;
    v15 = *(_DWORD *)ivec;
    v16 = *(_DWORD *)&(*ivec)[4];
    if (enc)
    {
      if (v14 <= length)
      {
        v17 = numbits - (v9 & 0xFFFFFFF8);
        v58 = (uint32x4_t)vnegq_s32(vdupq_n_s32(8 - v17));
        v60 = (uint32x4_t)vdupq_n_s32(v17);
        do
        {
          data = v15;
          v69 = v16;
          DES_encrypt3(&data, ks1, ks2, v10);
          v18 = 0;
          v19 = &in[v14];
          v20 = 0;
          v21 = numbits;
          switch(v14)
          {
            case 1uLL:
              goto LABEL_13;
            case 2uLL:
              goto LABEL_12;
            case 3uLL:
              goto LABEL_11;
            case 4uLL:
              goto LABEL_10;
            case 5uLL:
              goto LABEL_9;
            case 6uLL:
              goto LABEL_8;
            case 7uLL:
              goto LABEL_7;
            case 8uLL:
              v22 = *--v19;
              v18 = v22 << 24;
LABEL_7:
              v23 = *--v19;
              v18 |= v23 << 16;
LABEL_8:
              v24 = *--v19;
              v18 |= v24 << 8;
LABEL_9:
              v25 = *--v19;
              v18 |= v25;
LABEL_10:
              v20 = v18;
              v26 = *--v19;
              v18 = v26 << 24;
LABEL_11:
              v27 = *--v19;
              v18 |= v27 << 16;
LABEL_12:
              v28 = *--v19;
              v18 |= v28 << 8;
LABEL_13:
              v29 = *--v19;
              v18 |= v29;
              break;
            default:
              v20 = 0;
              v21 = numbits;
              break;
          }
          v30 = data ^ v18;
          v31 = v69 ^ v20;
          v32 = &out[v14];
          switch(v14)
          {
            case 1uLL:
              goto LABEL_22;
            case 2uLL:
              goto LABEL_21;
            case 3uLL:
              goto LABEL_20;
            case 4uLL:
              goto LABEL_19;
            case 5uLL:
              goto LABEL_18;
            case 6uLL:
              goto LABEL_17;
            case 7uLL:
              goto LABEL_16;
            case 8uLL:
              *--v32 = HIBYTE(v31);
LABEL_16:
              *--v32 = BYTE2(v31);
LABEL_17:
              *--v32 = BYTE1(v31);
LABEL_18:
              *--v32 = v31;
LABEL_19:
              *--v32 = HIBYTE(v30);
LABEL_20:
              *--v32 = BYTE2(v30);
LABEL_21:
              *--v32 = BYTE1(v30);
LABEL_22:
              *--v32 = v30;
              break;
            default:
              break;
          }
          if (v21 != 32)
          {
            if (v21 == 64)
            {
              v16 = v30;
              v30 = v31;
            }
            else
            {
              *(_DWORD *)v66 = v15;
              *(_DWORD *)&v66[4] = v16;
              *(_DWORD *)&v66[8] = v30;
              v67 = v31;
              __memmove_chk();
              if (v17)
              {
                v33 = v66;
                v34 = vld1_dup_s8(v33);
                v35 = vmovl_u8((uint8x8_t)vext_s8(v34, *(int8x8_t *)&v66[1], 7uLL));
                v36 = vmovl_u8(*(uint8x8_t *)&v66[1]);
                *(int8x8_t *)v66 = vmovn_s16(vuzp1q_s16((int16x8_t)vorrq_s8((int8x16_t)vshlq_u32(vmovl_u16(*(uint16x4_t *)v36.i8), v58), (int8x16_t)vshlq_u32(vmovl_u16(*(uint16x4_t *)v35.i8), v60)), (int16x8_t)vorrq_s8((int8x16_t)vshlq_u32(vmovl_high_u16(v36), v58), (int8x16_t)vshlq_u32(vmovl_high_u16(v35), v60))));
              }
              v16 = *(_DWORD *)v66;
              v30 = *(_DWORD *)&v66[4];
            }
          }
          v15 = v16;
          v11 -= v14;
          in = &v19[v14];
          out = &v32[v14];
          v16 = v30;
        }
        while (v11 >= v14);
        goto LABEL_34;
      }
    }
    else if (v14 <= length)
    {
      v61 = numbits - (v9 & 0xFFFFFFF8);
      v59 = (uint32x4_t)vdupq_n_s32(v61);
      v56 = (uint32x4_t)vnegq_s32(vdupq_n_s32(8 - v61));
      v37 = *(_DWORD *)ivec;
      do
      {
        data = v37;
        v69 = v16;
        DES_encrypt3(&data, ks1, ks2, v10);
        v38 = 0;
        v39 = &in[v14];
        v40 = 0;
        switch(v14)
        {
          case 1uLL:
            goto LABEL_45;
          case 2uLL:
            goto LABEL_44;
          case 3uLL:
            goto LABEL_43;
          case 4uLL:
            goto LABEL_42;
          case 5uLL:
            goto LABEL_41;
          case 6uLL:
            goto LABEL_40;
          case 7uLL:
            goto LABEL_39;
          case 8uLL:
            v41 = *--v39;
            v38 = v41 << 24;
LABEL_39:
            v42 = *--v39;
            v38 |= v42 << 16;
LABEL_40:
            v43 = *--v39;
            v38 |= v43 << 8;
LABEL_41:
            v44 = *--v39;
            v38 |= v44;
LABEL_42:
            v40 = v38;
            v45 = *--v39;
            v38 = v45 << 24;
LABEL_43:
            v46 = *--v39;
            v38 |= v46 << 16;
LABEL_44:
            v47 = *--v39;
            v38 |= v47 << 8;
LABEL_45:
            v48 = *--v39;
            v38 |= v48;
            break;
          default:
            v40 = 0;
            break;
        }
        if (numbits == 32)
        {
          v15 = v16;
          v30 = v38;
        }
        else
        {
          v15 = v38;
          v30 = v40;
          if (numbits != 64)
          {
            *(_DWORD *)v66 = v37;
            *(_DWORD *)&v66[4] = v16;
            *(_DWORD *)&v66[8] = v38;
            v67 = v40;
            __memmove_chk();
            if (v61)
            {
              v49 = v66;
              v50 = vld1_dup_s8(v49);
              v51 = vmovl_u8((uint8x8_t)vext_s8(v50, *(int8x8_t *)&v66[1], 7uLL));
              v52 = vmovl_u8(*(uint8x8_t *)&v66[1]);
              *(int8x8_t *)v66 = vmovn_s16(vuzp1q_s16((int16x8_t)vorrq_s8((int8x16_t)vshlq_u32(vmovl_u16(*(uint16x4_t *)v52.i8), v56), (int8x16_t)vshlq_u32(vmovl_u16(*(uint16x4_t *)v51.i8), v59)), (int16x8_t)vorrq_s8((int8x16_t)vshlq_u32(vmovl_high_u16(v52), v56), (int8x16_t)vshlq_u32(vmovl_high_u16(v51), v59))));
            }
            v15 = *(_DWORD *)v66;
            v30 = *(_DWORD *)&v66[4];
          }
        }
        v53 = &out[v14];
        v54 = data ^ v38;
        v55 = v69 ^ v40;
        switch(v14)
        {
          case 1uLL:
            goto LABEL_60;
          case 2uLL:
            goto LABEL_59;
          case 3uLL:
            goto LABEL_58;
          case 4uLL:
            goto LABEL_57;
          case 5uLL:
            goto LABEL_56;
          case 6uLL:
            goto LABEL_55;
          case 7uLL:
            goto LABEL_54;
          case 8uLL:
            *--v53 = HIBYTE(v55);
LABEL_54:
            *--v53 = BYTE2(v55);
LABEL_55:
            *--v53 = BYTE1(v55);
LABEL_56:
            *--v53 = v55;
LABEL_57:
            *--v53 = HIBYTE(v54);
LABEL_58:
            *--v53 = BYTE2(v54);
LABEL_59:
            *--v53 = BYTE1(v54);
LABEL_60:
            *--v53 = v54;
            break;
          default:
            break;
        }
        v10 = ks3;
        v11 -= v14;
        in = &v39[v14];
        out = &v53[v14];
        v16 = v30;
        v37 = v15;
      }
      while (v11 >= v14);
      goto LABEL_34;
    }
    v30 = *(_DWORD *)&(*ivec)[4];
LABEL_34:
    *(_DWORD *)ivec = v15;
    *(_DWORD *)&(*ivec)[4] = v30;
  }
}

uint64_t BIO_new_NDEF(BIO *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  BIO_METHOD *v6;
  BIO *v7;
  BIO *v8;
  _QWORD *v9;
  _QWORD *v10;
  uint64_t result;
  uint64_t v12;
  BIO *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;

  v15 = 0;
  v16 = a2;
  v3 = *(_QWORD *)(a3 + 32);
  v13 = 0;
  v14 = 0;
  if (v3 && *(_QWORD *)(v3 + 24))
  {
    v6 = (BIO_METHOD *)BIO_f_asn1();
    v7 = BIO_new(v6);
    v8 = v7;
    if (v7)
    {
      v7 = BIO_push(v7, a1);
      if (v7)
      {
        if ((int)BIO_asn1_set_prefix(v8, (uint64_t)ndef_prefix, (uint64_t)ndef_prefix_free) >= 1
          && (int)BIO_asn1_set_suffix(v8, (uint64_t)ndef_suffix, (uint64_t)ndef_suffix_free) >= 1)
        {
          v9 = malloc_type_calloc(1uLL, 0x30uLL, 0xF004056C54A40uLL);
          if (v9)
          {
            v10 = v9;
            if (BIO_ctrl(v8, 153, 0, v9) <= 0)
            {
              free(v10);
            }
            else
            {
              v14 = 0;
              v15 = 0;
              v13 = v8;
              if ((*(int (**)(uint64_t, uint64_t *, uint64_t, BIO **))(v3 + 24))(10, &v16, a3, &v13) >= 1)
              {
                *v10 = v16;
                v10[1] = a3;
                result = v14;
                v12 = v15;
                v10[3] = v8;
                v10[4] = v12;
                v10[2] = result;
                return result;
              }
            }
          }
        }
        v7 = v8;
      }
    }
  }
  else
  {
    ERR_put_error(13, 4095, 202, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/bio_ndef.c", 111);
    v8 = 0;
    v7 = 0;
  }
  BIO_pop(v7);
  BIO_free(v8);
  return 0;
}

uint64_t ndef_prefix(uint64_t a1, unsigned __int8 **a2, _DWORD *a3, ASN1_VALUE ***a4)
{
  ASN1_VALUE **v6;
  int v7;
  unsigned __int8 *v8;
  uint64_t v9;
  unsigned __int8 *out;

  if (!a4)
    return 0;
  v6 = *a4;
  v7 = ASN1_item_ndef_i2d(**a4, 0, (const ASN1_ITEM *)(*a4)[1]);
  v8 = (unsigned __int8 *)malloc_type_malloc(v7, 0x47FF4798uLL);
  out = v8;
  v6[5] = (ASN1_VALUE *)v8;
  *a2 = v8;
  ASN1_item_ndef_i2d(*v6, &out, (const ASN1_ITEM *)v6[1]);
  v9 = *(_QWORD *)v6[4];
  if (!v9)
    return 0;
  *a3 = v9 - *(_DWORD *)a2;
  return 1;
}

uint64_t ndef_prefix_free(uint64_t a1, _QWORD *a2, _DWORD *a3, uint64_t a4)
{
  if (!a4)
    return 0;
  if (!*(_QWORD *)a4)
    return 0;
  free(*(void **)(*(_QWORD *)a4 + 40));
  *(_QWORD *)(*(_QWORD *)a4 + 40) = 0;
  *a2 = 0;
  *a3 = 0;
  return 1;
}

uint64_t ndef_suffix(uint64_t a1, unsigned __int8 **a2, _DWORD *a3, int8x16_t **a4)
{
  int8x16_t *v6;
  uint64_t v7;
  int v8;
  unsigned __int8 *v9;
  int v10;
  unsigned __int8 *v11;
  int8x16_t v13;
  uint64_t v14;
  unsigned __int8 *out;

  if (!a4)
    return 0;
  v6 = *a4;
  v7 = *(_QWORD *)((*a4)->i64[1] + 32);
  v13 = vextq_s8((*a4)[1], (*a4)[1], 8uLL);
  v14 = v6[2].i64[0];
  if ((*(int (**)(uint64_t, int8x16_t *))(v7 + 24))(11, v6) < 1)
    return 0;
  v8 = ASN1_item_ndef_i2d((ASN1_VALUE *)v6->i64[0], 0, (const ASN1_ITEM *)v6->i64[1]);
  v9 = (unsigned __int8 *)malloc_type_malloc(v8, 0x8B324E2EuLL);
  out = v9;
  v6[2].i64[1] = (uint64_t)v9;
  *a2 = v9;
  v10 = ASN1_item_ndef_i2d((ASN1_VALUE *)v6->i64[0], &out, (const ASN1_ITEM *)v6->i64[1]);
  v11 = *(unsigned __int8 **)v6[2].i64[0];
  if (!v11)
    return 0;
  *a2 = v11;
  *a3 = v10 + v6[2].i32[2] - *(_DWORD *)v6[2].i64[0];
  return 1;
}

uint64_t ndef_suffix_free(uint64_t a1, _QWORD *a2, _DWORD *a3, void **a4)
{
  if (!a4)
    return 0;
  if (!*a4)
    return 0;
  free(*((void **)*a4 + 5));
  *((_QWORD *)*a4 + 5) = 0;
  *a2 = 0;
  *a3 = 0;
  free(*a4);
  *a4 = 0;
  return 1;
}

EC_GROUP *__cdecl EC_GROUP_new_curve_GFp(const BIGNUM *p, const BIGNUM *a, const BIGNUM *b, BN_CTX *a4)
{
  const EC_METHOD *v8;
  EC_GROUP *v9;
  EC_GROUP *v10;

  v8 = EC_GFp_mont_method();
  v9 = EC_GROUP_new(v8);
  v10 = v9;
  if (!v9 || !EC_GROUP_set_curve((uint64_t)v9, (uint64_t)p, (uint64_t)a, (uint64_t)b, a4))
  {
    EC_GROUP_free(v10);
    return 0;
  }
  return v10;
}

char *OPENSSL_asc2uni(char *__s, unsigned int a2, _QWORD *a3, _DWORD *a4)
{
  char *v6;
  size_t v7;
  unint64_t v8;
  char *result;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  char *v13;
  char v14;

  v6 = __s;
  if ((a2 & 0x80000000) != 0)
    v7 = strlen(__s);
  else
    v7 = a2;
  v8 = v7 + 1;
  if (v7 == -1)
    return 0;
  result = (char *)reallocarray(0, v8, 2uLL);
  if (!result)
    return result;
  if (((v8 >> 30) & 0x1FFFFFFFFLL) != 0)
  {
    free(result);
    return 0;
  }
  v10 = 2 * v8;
  v11 = 2 * v8 - 2;
  if (2 * v8 != 2)
  {
    v12 = 0;
    do
    {
      v13 = &result[v12];
      *v13 = 0;
      v14 = *v6++;
      v13[1] = v14;
      v12 += 2;
    }
    while (v12 < v11);
  }
  result[v11] = 0;
  result[v10 - 1] = 0;
  if (a4)
    *a4 = v10;
  if (a3)
    *a3 = result;
  return result;
}

_BYTE *OPENSSL_uni2asc(uint64_t a1, unsigned int a2)
{
  unint64_t v4;
  size_t v5;
  _BYTE *result;
  char *v7;
  uint64_t v8;
  _BYTE *v9;
  char v10;

  if ((a2 & 0x80000000) != 0)
    return 0;
  v4 = a2 >> 1;
  if (!a2 || (v5 = a2 >> 1, *(_BYTE *)(a1 + a2 - 1)))
    v5 = v4 + 1;
  result = malloc_type_malloc(v5, 0xAD3C9D9CuLL);
  if (result)
  {
    if (a2 >= 2)
    {
      v7 = (char *)(a1 + 1);
      if (v4 <= 1)
        v8 = 1;
      else
        v8 = v4;
      v9 = result;
      do
      {
        v10 = *v7;
        v7 += 2;
        *v9++ = v10;
        --v8;
      }
      while (v8);
    }
    result[v5 - 1] = 0;
  }
  return result;
}

int i2d_PKCS12_bio(BIO *bp, PKCS12 *p12)
{
  return ASN1_item_i2d_bio(&PKCS12_it, bp, p12);
}

int i2d_PKCS12_fp(FILE *fp, PKCS12 *p12)
{
  return ASN1_item_i2d_fp(&PKCS12_it, fp, p12);
}

PKCS12 *__cdecl d2i_PKCS12_bio(BIO *bp, PKCS12 **p12)
{
  return (PKCS12 *)ASN1_item_d2i_bio(&PKCS12_it, bp, p12);
}

PKCS12 *__cdecl d2i_PKCS12_fp(FILE *fp, PKCS12 **p12)
{
  return (PKCS12 *)ASN1_item_d2i_fp(&PKCS12_it, fp, p12);
}

uint64_t gost_key_wrap_crypto_pro(uint64_t a1)
{
  int v1;
  uint64_t v2;
  uint64_t v3;
  int *v4;
  int *v5;
  _QWORD *v6;
  _QWORD *v7;
  _OWORD *v8;
  _OWORD *v9;
  _OWORD v11[258];
  _BYTE v12[32];
  uint64_t v13;

  v1 = MEMORY[0x24BDAC7A8](a1);
  v3 = v2;
  v5 = v4;
  v7 = v6;
  v9 = v8;
  v13 = *MEMORY[0x24BDAC8D0];
  memset(v11, 0, 512);
  Gost2814789_set_sbox((uint64_t)v11, v1);
  key_diversify_crypto_pro((uint64_t)v11, v9, (uint64_t)v7, (uint64_t)v12);
  Gost2814789_set_key((uint64_t)v11, (uint64_t)v12, 256);
  *(_QWORD *)v3 = *v7;
  Gost2814789_encrypt(v5, (int *)(v3 + 8), (int *)v11);
  Gost2814789_encrypt(v5 + 2, (int *)(v3 + 16), (int *)v11);
  Gost2814789_encrypt(v5 + 4, (int *)(v3 + 24), (int *)v11);
  Gost2814789_encrypt(v5 + 6, (int *)(v3 + 32), (int *)v11);
  GOST2814789IMIT((uint64_t)v5);
  return 1;
}

uint64_t key_diversify_crypto_pro(uint64_t a1, _OWORD *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7;
  __int128 v8;
  int v9;
  int v10;
  int v11;
  int v12;
  int *v13;
  int v14;
  int v15;
  int v16;
  uint64_t result;
  unsigned int v18;
  int v19[2];
  uint64_t v20;

  v7 = 0;
  v20 = *MEMORY[0x24BDAC8D0];
  v8 = a2[1];
  *(_OWORD *)a4 = *a2;
  *(_OWORD *)(a4 + 16) = v8;
  do
  {
    v9 = 0;
    v10 = 0;
    v11 = *(unsigned __int8 *)(a3 + v7);
    v12 = 1;
    v13 = (int *)a4;
    do
    {
      v15 = *v13++;
      v14 = v15;
      if ((v12 & v11) != 0)
        v16 = v14;
      else
        v16 = 0;
      v10 += v16;
      if ((v12 & v11) != 0)
        v14 = 0;
      v9 += v14;
      v12 *= 2;
    }
    while (v12 < 256);
    v18 = 256;
    v19[0] = v10;
    v19[1] = v9;
    Gost2814789_set_key(a1, a4, 256);
    v18 = 0;
    result = Gost2814789_cfb64_encrypt(a4, (_BYTE *)a4, 0x20uLL, a1, v19, &v18, 1);
    ++v7;
  }
  while (v7 != 8);
  return result;
}

BOOL gost_key_unwrap_crypto_pro(uint64_t a1)
{
  int v1;
  int *v2;
  int *v3;
  int *v4;
  int *v5;
  _OWORD *v6;
  _OWORD *v7;
  _OWORD v9[259];
  int v10;
  _BYTE v11[32];
  uint64_t v12;

  v1 = MEMORY[0x24BDAC7A8](a1);
  v3 = v2;
  v5 = v4;
  v7 = v6;
  v12 = *MEMORY[0x24BDAC8D0];
  memset(v9, 0, 512);
  Gost2814789_set_sbox((uint64_t)v9, v1);
  key_diversify_crypto_pro((uint64_t)v9, v7, (uint64_t)v5, (uint64_t)v11);
  Gost2814789_set_key((uint64_t)v9, (uint64_t)v11, 256);
  Gost2814789_decrypt(v5 + 2, v3, (int *)v9);
  Gost2814789_decrypt(v5 + 4, v3 + 2, (int *)v9);
  Gost2814789_decrypt(v5 + 6, v3 + 4, (int *)v9);
  Gost2814789_decrypt(v5 + 8, v3 + 6, (int *)v9);
  GOST2814789IMIT((uint64_t)v3);
  return v10 == v5[10];
}

void DES_xcbc_encrypt(const unsigned __int8 *input, unsigned __int8 *output, uint64_t length, DES_key_schedule *schedule, DES_cblock *ivec, const_DES_cblock *inw, const_DES_cblock *outw, int enc)
{
  DES_cblock *v8;
  DES_key_schedule *v9;
  uint64_t v10;
  int v13;
  int v14;
  int v15;
  unsigned int v16;
  unsigned int v17;
  unsigned int v18;
  int v19;
  unsigned __int8 *v20;
  unint64_t v21;
  unsigned int v22;
  int v23;
  int v24;
  const unsigned __int8 *v25;
  int v26;
  int v27;
  int v28;
  int v29;
  int v30;
  int v31;
  int v32;
  unsigned int v33;
  unsigned int v34;
  unsigned int v35;
  unsigned int v36;
  unsigned int v37;
  unsigned int v38;
  unsigned __int8 *v39;
  unsigned int v40;
  unsigned int v41;
  unint64_t v42;
  const unsigned __int8 *v43;
  int v44;
  unsigned int v45;
  unsigned int v46;
  unsigned int v47;
  int v48;
  unsigned __int8 *v49;
  unsigned int v52;
  int v54;
  int v55;
  unsigned int data;
  int v57;
  uint64_t v58;

  v8 = ivec;
  v9 = schedule;
  v10 = length;
  v58 = *MEMORY[0x24BDAC8D0];
  v14 = *(_DWORD *)inw;
  v13 = *(_DWORD *)&(*inw)[4];
  v15 = *(_DWORD *)outw;
  v16 = *(_DWORD *)&(*outw)[4];
  v17 = *(_DWORD *)ivec;
  v18 = *(_DWORD *)&(*ivec)[4];
  v54 = v13;
  v55 = *(_DWORD *)outw;
  v19 = *(_DWORD *)inw;
  if (!enc)
  {
    if (length < 9)
    {
      if (!length)
      {
LABEL_32:
        *(_DWORD *)v8 = v17;
        *(_WORD *)&(*v8)[4] = v18;
        v38 = HIBYTE(v18);
        (*v8)[6] = BYTE2(v18);
        goto LABEL_33;
      }
    }
    else
    {
      v52 = *(_DWORD *)&(*outw)[4];
      do
      {
        v39 = output;
        v40 = v17;
        v41 = v18;
        v42 = v10;
        v10 -= 8;
        v17 = *(_DWORD *)input;
        v18 = *((_DWORD *)input + 1);
        v43 = input + 8;
        data = *(_DWORD *)input ^ v55;
        v57 = v18 ^ v52;
        DES_encrypt1(&data, schedule, 0);
        v44 = v41 ^ v54 ^ v57;
        *(_DWORD *)v39 = v40 ^ v19 ^ data;
        *((_DWORD *)v39 + 1) = v44;
        output = v39 + 8;
        v15 = v55;
        input += 8;
      }
      while (v42 > 0x10);
      input = v43;
      v8 = ivec;
      v16 = v52;
      v9 = schedule;
    }
    v46 = *(_DWORD *)input;
    v45 = *((_DWORD *)input + 1);
    data = v46 ^ v15;
    v57 = v45 ^ v16;
    DES_encrypt1(&data, v9, 0);
    v47 = data ^ v17 ^ v19;
    v48 = v57 ^ v18 ^ v54;
    v49 = &output[v10];
    switch(v10)
    {
      case 1:
        goto LABEL_30;
      case 2:
        goto LABEL_29;
      case 3:
        goto LABEL_28;
      case 4:
        goto LABEL_27;
      case 5:
        goto LABEL_26;
      case 6:
        goto LABEL_25;
      case 7:
        goto LABEL_24;
      case 8:
        *--v49 = HIBYTE(v48);
LABEL_24:
        *--v49 = BYTE2(v48);
LABEL_25:
        *--v49 = BYTE1(v48);
LABEL_26:
        *--v49 = v48;
LABEL_27:
        *--v49 = HIBYTE(v47);
LABEL_28:
        *--v49 = BYTE2(v47);
LABEL_29:
        *--v49 = BYTE1(v47);
LABEL_30:
        *(v49 - 1) = v47;
        break;
      default:
        break;
    }
    v17 = v46;
    v18 = v45;
    goto LABEL_32;
  }
  if (length >= 8)
  {
    do
    {
      v20 = output;
      v21 = v10;
      v10 -= 8;
      v22 = *(_DWORD *)input;
      v23 = *((_DWORD *)input + 1);
      input += 8;
      data = v17 ^ v14 ^ v22;
      v57 = v18 ^ v13 ^ v23;
      DES_encrypt1(&data, v9, 1);
      v14 = v19;
      v13 = v54;
      v17 = data ^ v55;
      v18 = v57 ^ v16;
      output += 8;
      *(_DWORD *)v20 = data ^ v55;
      *((_DWORD *)v20 + 1) = v18;
    }
    while (v21 > 0xF);
    v8 = ivec;
  }
  if (v10)
  {
    v24 = 0;
    v25 = &input[v10];
    v26 = 0;
    switch(v10)
    {
      case 1:
        goto LABEL_13;
      case 2:
        goto LABEL_12;
      case 3:
        goto LABEL_11;
      case 4:
        goto LABEL_10;
      case 5:
        goto LABEL_9;
      case 6:
        goto LABEL_8;
      case 7:
        v27 = *--v25;
        v24 = v27 << 16;
LABEL_8:
        v28 = *--v25;
        v24 |= v28 << 8;
LABEL_9:
        v29 = *--v25;
        v24 |= v29;
LABEL_10:
        v26 = v24;
        v30 = *--v25;
        v24 = v30 << 24;
LABEL_11:
        v31 = *--v25;
        v24 |= v31 << 16;
LABEL_12:
        v32 = *--v25;
        v24 |= v32 << 8;
LABEL_13:
        v24 |= *(v25 - 1);
        break;
      default:
        v26 = 0;
        break;
    }
    data = v14 ^ v24 ^ v17;
    v57 = v13 ^ v26 ^ v18;
    DES_encrypt1(&data, v9, 1);
    LOBYTE(v17) = data ^ v55;
    v33 = (data ^ v55) >> 8;
    v34 = (data ^ v55) >> 16;
    v35 = (data ^ v55) >> 24;
    v18 = v57 ^ v16;
    v36 = (v57 ^ v16) >> 8;
    v37 = (v57 ^ v16) >> 16;
    v38 = (v57 ^ v16) >> 24;
    *(_DWORD *)output = data ^ v55;
    *((_DWORD *)output + 1) = v18;
  }
  else
  {
    v33 = v17 >> 8;
    v34 = HIWORD(v17);
    v35 = HIBYTE(v17);
    v36 = v18 >> 8;
    v37 = HIWORD(v18);
    v38 = HIBYTE(v18);
  }
  *(_BYTE *)v8 = v17;
  (*v8)[1] = v33;
  (*v8)[2] = v34;
  (*v8)[3] = v35;
  (*v8)[4] = v18;
  (*v8)[5] = v36;
  (*v8)[6] = v37;
LABEL_33:
  (*v8)[7] = v38;
}

X509_REQ *__cdecl PEM_read_X509_REQ(FILE *fp, X509_REQ **x, pem_password_cb *cb, void *u)
{
  return (X509_REQ *)PEM_ASN1_read((d2i_of_void *)d2i_X509_REQ, "CERTIFICATE REQUEST", fp, (void **)x, cb, u);
}

int PEM_write_X509_REQ(FILE *fp, X509_REQ *x)
{
  return PEM_ASN1_write((i2d_of_void *)i2d_X509_REQ, "CERTIFICATE REQUEST", fp, (char *)x, 0, 0, 0, 0, 0);
}

X509_REQ *__cdecl PEM_read_bio_X509_REQ(BIO *bp, X509_REQ **x, pem_password_cb *cb, void *u)
{
  return (X509_REQ *)PEM_ASN1_read_bio((d2i_of_void *)d2i_X509_REQ, "CERTIFICATE REQUEST", bp, (void **)x, cb, u);
}

int PEM_write_bio_X509_REQ(BIO *bp, X509_REQ *x)
{
  return PEM_ASN1_write_bio((i2d_of_void *)i2d_X509_REQ, "CERTIFICATE REQUEST", bp, (char *)x, 0, 0, 0, 0, 0);
}

int PEM_write_X509_REQ_NEW(FILE *fp, X509_REQ *x)
{
  return PEM_ASN1_write((i2d_of_void *)i2d_X509_REQ, "NEW CERTIFICATE REQUEST", fp, (char *)x, 0, 0, 0, 0, 0);
}

int PEM_write_bio_X509_REQ_NEW(BIO *bp, X509_REQ *x)
{
  return PEM_ASN1_write_bio((i2d_of_void *)i2d_X509_REQ, "NEW CERTIFICATE REQUEST", bp, (char *)x, 0, 0, 0, 0, 0);
}

X509_CRL *__cdecl PEM_read_X509_CRL(FILE *fp, X509_CRL **x, pem_password_cb *cb, void *u)
{
  return (X509_CRL *)PEM_ASN1_read((d2i_of_void *)d2i_X509_CRL, "X509 CRL", fp, (void **)x, cb, u);
}

int PEM_write_X509_CRL(FILE *fp, X509_CRL *x)
{
  return PEM_ASN1_write((i2d_of_void *)i2d_X509_CRL, "X509 CRL", fp, (char *)x, 0, 0, 0, 0, 0);
}

X509_CRL *__cdecl PEM_read_bio_X509_CRL(BIO *bp, X509_CRL **x, pem_password_cb *cb, void *u)
{
  return (X509_CRL *)PEM_ASN1_read_bio((d2i_of_void *)d2i_X509_CRL, "X509 CRL", bp, (void **)x, cb, u);
}

int PEM_write_bio_X509_CRL(BIO *bp, X509_CRL *x)
{
  return PEM_ASN1_write_bio((i2d_of_void *)i2d_X509_CRL, "X509 CRL", bp, (char *)x, 0, 0, 0, 0, 0);
}

PKCS7 *__cdecl PEM_read_PKCS7(FILE *fp, PKCS7 **x, pem_password_cb *cb, void *u)
{
  return (PKCS7 *)PEM_ASN1_read((d2i_of_void *)d2i_PKCS7, "PKCS7", fp, (void **)x, cb, u);
}

int PEM_write_PKCS7(FILE *fp, PKCS7 *x)
{
  return PEM_ASN1_write((i2d_of_void *)i2d_PKCS7, "PKCS7", fp, (char *)x, 0, 0, 0, 0, 0);
}

PKCS7 *__cdecl PEM_read_bio_PKCS7(BIO *bp, PKCS7 **x, pem_password_cb *cb, void *u)
{
  return (PKCS7 *)PEM_ASN1_read_bio((d2i_of_void *)d2i_PKCS7, "PKCS7", bp, (void **)x, cb, u);
}

int PEM_write_bio_PKCS7(BIO *bp, PKCS7 *x)
{
  return PEM_ASN1_write_bio((i2d_of_void *)i2d_PKCS7, "PKCS7", bp, (char *)x, 0, 0, 0, 0, 0);
}

RSA *__cdecl PEM_read_RSAPrivateKey(FILE *fp, RSA **x, pem_password_cb *cb, void *u)
{
  EVP_PKEY *PrivateKey;

  PrivateKey = PEM_read_PrivateKey(fp, 0, cb, u);
  return pkey_get_rsa(PrivateKey, x);
}

rsa_st *pkey_get_rsa(EVP_PKEY *a1, RSA **a2)
{
  rsa_st *v4;

  if (!a1)
    return 0;
  v4 = EVP_PKEY_get1_RSA(a1);
  EVP_PKEY_free(a1);
  if (v4 && a2)
  {
    RSA_free(*a2);
    *a2 = v4;
  }
  return v4;
}

int PEM_write_RSAPrivateKey(FILE *fp, RSA *x, const EVP_CIPHER *enc, unsigned __int8 *kstr, int klen, pem_password_cb *cb, void *u)
{
  return PEM_ASN1_write((i2d_of_void *)i2d_RSAPrivateKey, "RSA PRIVATE KEY", fp, (char *)x, enc, kstr, klen, cb, u);
}

RSA *__cdecl PEM_read_bio_RSAPrivateKey(BIO *bp, RSA **x, pem_password_cb *cb, void *u)
{
  EVP_PKEY *bio_PrivateKey;

  bio_PrivateKey = PEM_read_bio_PrivateKey(bp, 0, cb, u);
  return pkey_get_rsa(bio_PrivateKey, x);
}

int PEM_write_bio_RSAPrivateKey(BIO *bp, RSA *x, const EVP_CIPHER *enc, unsigned __int8 *kstr, int klen, pem_password_cb *cb, void *u)
{
  return PEM_ASN1_write_bio((i2d_of_void *)i2d_RSAPrivateKey, "RSA PRIVATE KEY", bp, (char *)x, enc, kstr, klen, cb, u);
}

RSA *__cdecl PEM_read_RSAPublicKey(FILE *fp, RSA **x, pem_password_cb *cb, void *u)
{
  return (RSA *)PEM_ASN1_read((d2i_of_void *)d2i_RSAPublicKey, "RSA PUBLIC KEY", fp, (void **)x, cb, u);
}

int PEM_write_RSAPublicKey(FILE *fp, const RSA *x)
{
  return PEM_ASN1_write((i2d_of_void *)i2d_RSAPublicKey, "RSA PUBLIC KEY", fp, (char *)x, 0, 0, 0, 0, 0);
}

RSA *__cdecl PEM_read_bio_RSAPublicKey(BIO *bp, RSA **x, pem_password_cb *cb, void *u)
{
  return (RSA *)PEM_ASN1_read_bio((d2i_of_void *)d2i_RSAPublicKey, "RSA PUBLIC KEY", bp, (void **)x, cb, u);
}

int PEM_write_bio_RSAPublicKey(BIO *bp, const RSA *x)
{
  return PEM_ASN1_write_bio((i2d_of_void *)i2d_RSAPublicKey, "RSA PUBLIC KEY", bp, (char *)x, 0, 0, 0, 0, 0);
}

RSA *__cdecl PEM_read_RSA_PUBKEY(FILE *fp, RSA **x, pem_password_cb *cb, void *u)
{
  return (RSA *)PEM_ASN1_read((d2i_of_void *)d2i_RSA_PUBKEY, "PUBLIC KEY", fp, (void **)x, cb, u);
}

int PEM_write_RSA_PUBKEY(FILE *fp, RSA *x)
{
  return PEM_ASN1_write((i2d_of_void *)i2d_RSA_PUBKEY, "PUBLIC KEY", fp, (char *)x, 0, 0, 0, 0, 0);
}

RSA *__cdecl PEM_read_bio_RSA_PUBKEY(BIO *bp, RSA **x, pem_password_cb *cb, void *u)
{
  return (RSA *)PEM_ASN1_read_bio((d2i_of_void *)d2i_RSA_PUBKEY, "PUBLIC KEY", bp, (void **)x, cb, u);
}

int PEM_write_bio_RSA_PUBKEY(BIO *bp, RSA *x)
{
  return PEM_ASN1_write_bio((i2d_of_void *)i2d_RSA_PUBKEY, "PUBLIC KEY", bp, (char *)x, 0, 0, 0, 0, 0);
}

DSA *__cdecl PEM_read_DSAPrivateKey(FILE *fp, DSA **x, pem_password_cb *cb, void *u)
{
  EVP_PKEY *PrivateKey;

  PrivateKey = PEM_read_PrivateKey(fp, 0, cb, u);
  return pkey_get_dsa(PrivateKey, x);
}

dsa_st *pkey_get_dsa(EVP_PKEY *a1, DSA **a2)
{
  dsa_st *v4;

  if (!a1)
    return 0;
  v4 = EVP_PKEY_get1_DSA(a1);
  EVP_PKEY_free(a1);
  if (v4 && a2)
  {
    DSA_free(*a2);
    *a2 = v4;
  }
  return v4;
}

int PEM_write_DSAPrivateKey(FILE *fp, DSA *x, const EVP_CIPHER *enc, unsigned __int8 *kstr, int klen, pem_password_cb *cb, void *u)
{
  return PEM_ASN1_write((i2d_of_void *)i2d_DSAPrivateKey, "DSA PRIVATE KEY", fp, (char *)x, enc, kstr, klen, cb, u);
}

DSA *__cdecl PEM_read_bio_DSAPrivateKey(BIO *bp, DSA **x, pem_password_cb *cb, void *u)
{
  EVP_PKEY *bio_PrivateKey;

  bio_PrivateKey = PEM_read_bio_PrivateKey(bp, 0, cb, u);
  return pkey_get_dsa(bio_PrivateKey, x);
}

int PEM_write_bio_DSAPrivateKey(BIO *bp, DSA *x, const EVP_CIPHER *enc, unsigned __int8 *kstr, int klen, pem_password_cb *cb, void *u)
{
  return PEM_ASN1_write_bio((i2d_of_void *)i2d_DSAPrivateKey, "DSA PRIVATE KEY", bp, (char *)x, enc, kstr, klen, cb, u);
}

DSA *__cdecl PEM_read_DSA_PUBKEY(FILE *fp, DSA **x, pem_password_cb *cb, void *u)
{
  return (DSA *)PEM_ASN1_read((d2i_of_void *)d2i_DSA_PUBKEY, "PUBLIC KEY", fp, (void **)x, cb, u);
}

int PEM_write_DSA_PUBKEY(FILE *fp, DSA *x)
{
  return PEM_ASN1_write((i2d_of_void *)i2d_DSA_PUBKEY, "PUBLIC KEY", fp, (char *)x, 0, 0, 0, 0, 0);
}

int PEM_write_bio_DSA_PUBKEY(BIO *bp, DSA *x)
{
  return PEM_ASN1_write_bio((i2d_of_void *)i2d_DSA_PUBKEY, "PUBLIC KEY", bp, (char *)x, 0, 0, 0, 0, 0);
}

DSA *__cdecl PEM_read_bio_DSA_PUBKEY(BIO *bp, DSA **x, pem_password_cb *cb, void *u)
{
  return (DSA *)PEM_ASN1_read_bio((d2i_of_void *)d2i_DSA_PUBKEY, "PUBLIC KEY", bp, (void **)x, cb, u);
}

DSA *__cdecl PEM_read_DSAparams(FILE *fp, DSA **x, pem_password_cb *cb, void *u)
{
  return (DSA *)PEM_ASN1_read((d2i_of_void *)d2i_DSAparams, "DSA PARAMETERS", fp, (void **)x, cb, u);
}

int PEM_write_DSAparams(FILE *fp, const DSA *x)
{
  return PEM_ASN1_write((i2d_of_void *)i2d_DSAparams, "DSA PARAMETERS", fp, (char *)x, 0, 0, 0, 0, 0);
}

DSA *__cdecl PEM_read_bio_DSAparams(BIO *bp, DSA **x, pem_password_cb *cb, void *u)
{
  return (DSA *)PEM_ASN1_read_bio((d2i_of_void *)d2i_DSAparams, "DSA PARAMETERS", bp, (void **)x, cb, u);
}

int PEM_write_bio_DSAparams(BIO *bp, const DSA *x)
{
  return PEM_ASN1_write_bio((i2d_of_void *)i2d_DSAparams, "DSA PARAMETERS", bp, (char *)x, 0, 0, 0, 0, 0);
}

EC_GROUP *__cdecl PEM_read_ECPKParameters(FILE *fp, EC_GROUP **x, pem_password_cb *cb, void *u)
{
  return (EC_GROUP *)PEM_ASN1_read((d2i_of_void *)d2i_ECPKParameters, "EC PARAMETERS", fp, (void **)x, cb, u);
}

int PEM_write_ECPKParameters(FILE *fp, const EC_GROUP *x)
{
  return PEM_ASN1_write((i2d_of_void *)i2d_ECPKParameters, "EC PARAMETERS", fp, (char *)x, 0, 0, 0, 0, 0);
}

EC_GROUP *__cdecl PEM_read_bio_ECPKParameters(BIO *bp, EC_GROUP **x, pem_password_cb *cb, void *u)
{
  return (EC_GROUP *)PEM_ASN1_read_bio((d2i_of_void *)d2i_ECPKParameters, "EC PARAMETERS", bp, (void **)x, cb, u);
}

int PEM_write_bio_ECPKParameters(BIO *bp, const EC_GROUP *x)
{
  return PEM_ASN1_write_bio((i2d_of_void *)i2d_ECPKParameters, "EC PARAMETERS", bp, (char *)x, 0, 0, 0, 0, 0);
}

EC_KEY *__cdecl PEM_read_ECPrivateKey(FILE *fp, EC_KEY **x, pem_password_cb *cb, void *u)
{
  EVP_PKEY *PrivateKey;

  PrivateKey = PEM_read_PrivateKey(fp, 0, cb, u);
  return pkey_get_eckey(PrivateKey, x);
}

ec_key_st *pkey_get_eckey(EVP_PKEY *a1, EC_KEY **a2)
{
  ec_key_st *v4;

  if (!a1)
    return 0;
  v4 = EVP_PKEY_get1_EC_KEY(a1);
  EVP_PKEY_free(a1);
  if (v4 && a2)
  {
    EC_KEY_free(*a2);
    *a2 = v4;
  }
  return v4;
}

int PEM_write_ECPrivateKey(FILE *fp, EC_KEY *x, const EVP_CIPHER *enc, unsigned __int8 *kstr, int klen, pem_password_cb *cb, void *u)
{
  return PEM_ASN1_write((i2d_of_void *)i2d_ECPrivateKey, "EC PRIVATE KEY", fp, (char *)x, enc, kstr, klen, cb, u);
}

EC_KEY *__cdecl PEM_read_bio_ECPrivateKey(BIO *bp, EC_KEY **x, pem_password_cb *cb, void *u)
{
  EVP_PKEY *bio_PrivateKey;

  bio_PrivateKey = PEM_read_bio_PrivateKey(bp, 0, cb, u);
  return pkey_get_eckey(bio_PrivateKey, x);
}

int PEM_write_bio_ECPrivateKey(BIO *bp, EC_KEY *x, const EVP_CIPHER *enc, unsigned __int8 *kstr, int klen, pem_password_cb *cb, void *u)
{
  return PEM_ASN1_write_bio((i2d_of_void *)i2d_ECPrivateKey, "EC PRIVATE KEY", bp, (char *)x, enc, kstr, klen, cb, u);
}

EC_KEY *__cdecl PEM_read_EC_PUBKEY(FILE *fp, EC_KEY **x, pem_password_cb *cb, void *u)
{
  return (EC_KEY *)PEM_ASN1_read((d2i_of_void *)d2i_EC_PUBKEY, "PUBLIC KEY", fp, (void **)x, cb, u);
}

int PEM_write_EC_PUBKEY(FILE *fp, EC_KEY *x)
{
  return PEM_ASN1_write((i2d_of_void *)i2d_EC_PUBKEY, "PUBLIC KEY", fp, (char *)x, 0, 0, 0, 0, 0);
}

EC_KEY *__cdecl PEM_read_bio_EC_PUBKEY(BIO *bp, EC_KEY **x, pem_password_cb *cb, void *u)
{
  return (EC_KEY *)PEM_ASN1_read_bio((d2i_of_void *)d2i_EC_PUBKEY, "PUBLIC KEY", bp, (void **)x, cb, u);
}

int PEM_write_bio_EC_PUBKEY(BIO *bp, EC_KEY *x)
{
  return PEM_ASN1_write_bio((i2d_of_void *)i2d_EC_PUBKEY, "PUBLIC KEY", bp, (char *)x, 0, 0, 0, 0, 0);
}

DH *__cdecl PEM_read_DHparams(FILE *fp, DH **x, pem_password_cb *cb, void *u)
{
  return (DH *)PEM_ASN1_read((d2i_of_void *)d2i_DHparams, "DH PARAMETERS", fp, (void **)x, cb, u);
}

int PEM_write_DHparams(FILE *fp, const DH *x)
{
  return PEM_ASN1_write((i2d_of_void *)i2d_DHparams, "DH PARAMETERS", fp, (char *)x, 0, 0, 0, 0, 0);
}

DH *__cdecl PEM_read_bio_DHparams(BIO *bp, DH **x, pem_password_cb *cb, void *u)
{
  return (DH *)PEM_ASN1_read_bio((d2i_of_void *)d2i_DHparams, "DH PARAMETERS", bp, (void **)x, cb, u);
}

int PEM_write_bio_DHparams(BIO *bp, const DH *x)
{
  return PEM_ASN1_write_bio((i2d_of_void *)i2d_DHparams, "DH PARAMETERS", bp, (char *)x, 0, 0, 0, 0, 0);
}

EVP_PKEY *__cdecl PEM_read_PUBKEY(FILE *fp, EVP_PKEY **x, pem_password_cb *cb, void *u)
{
  return (EVP_PKEY *)PEM_ASN1_read((d2i_of_void *)d2i_PUBKEY, "PUBLIC KEY", fp, (void **)x, cb, u);
}

int PEM_write_PUBKEY(FILE *fp, EVP_PKEY *x)
{
  return PEM_ASN1_write((i2d_of_void *)i2d_PUBKEY, "PUBLIC KEY", fp, (char *)x, 0, 0, 0, 0, 0);
}

EVP_PKEY *__cdecl PEM_read_bio_PUBKEY(BIO *bp, EVP_PKEY **x, pem_password_cb *cb, void *u)
{
  return (EVP_PKEY *)PEM_ASN1_read_bio((d2i_of_void *)d2i_PUBKEY, "PUBLIC KEY", bp, (void **)x, cb, u);
}

int PEM_write_bio_PUBKEY(BIO *bp, EVP_PKEY *x)
{
  return PEM_ASN1_write_bio((i2d_of_void *)i2d_PUBKEY, "PUBLIC KEY", bp, (char *)x, 0, 0, 0, 0, 0);
}

uint64_t pkey_dh_init(uint64_t a1)
{
  uint64_t result;

  result = (uint64_t)malloc_type_malloc(0x14uLL, 0x1000040A86A77D5uLL);
  if (result)
  {
    *(_QWORD *)result = 0x200000400;
    *(_DWORD *)(result + 8) = 0;
    *(_QWORD *)(a1 + 40) = result;
    *(_QWORD *)(a1 + 64) = result + 12;
    *(_DWORD *)(a1 + 72) = 2;
    return 1;
  }
  return result;
}

uint64_t pkey_dh_copy(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  uint64_t v5;

  result = (uint64_t)malloc_type_malloc(0x14uLL, 0x1000040A86A77D5uLL);
  if (result)
  {
    *(_QWORD *)result = 0x200000400;
    *(_DWORD *)(result + 8) = 0;
    *(_QWORD *)(a1 + 40) = result;
    *(_QWORD *)(a1 + 64) = result + 12;
    *(_DWORD *)(a1 + 72) = 2;
    v5 = *(_QWORD *)(a2 + 40);
    *(_QWORD *)result = *(_QWORD *)v5;
    *(_DWORD *)(result + 8) = *(_DWORD *)(v5 + 8);
    return 1;
  }
  return result;
}

void pkey_dh_cleanup(uint64_t a1)
{
  free(*(void **)(a1 + 40));
}

uint64_t pkey_dh_paramgen(uint64_t a1, EVP_PKEY *a2)
{
  int *v3;
  BN_GENCB *v4;
  DH *v5;
  char *v6;
  uint64_t parameters;
  _QWORD v9[3];

  v3 = *(int **)(a1 + 40);
  memset(v9, 0, sizeof(v9));
  if (*(_QWORD *)(a1 + 56))
  {
    v4 = (BN_GENCB *)v9;
    evp_pkey_set_cb_translate((uint64_t)v9, a1);
  }
  else
  {
    v4 = 0;
  }
  v5 = DH_new();
  if (!v5)
    return 0;
  v6 = (char *)v5;
  parameters = DH_generate_parameters_ex(v5, *v3, v3[1], v4);
  if ((_DWORD)parameters)
    EVP_PKEY_assign(a2, 28, v6);
  else
    DH_free((DH *)v6);
  return parameters;
}

uint64_t pkey_dh_keygen(uint64_t a1, uint64_t a2)
{
  char *v4;

  if (*(_QWORD *)(a1 + 16))
  {
    v4 = (char *)DH_new();
    if (v4)
    {
      EVP_PKEY_assign((EVP_PKEY *)a2, 28, v4);
      if (EVP_PKEY_copy_parameters((EVP_PKEY *)a2, *(const EVP_PKEY **)(a1 + 16)))
        return DH_generate_key(*(DH **)(a2 + 32));
    }
  }
  else
  {
    ERR_put_error(5, 4095, 107, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/dh/dh_pmeth.c", 220);
  }
  return 0;
}

uint64_t pkey_dh_derive(uint64_t a1, unsigned __int8 *key, _QWORD *a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t result;

  v3 = *(_QWORD *)(a1 + 16);
  if (v3 && (v4 = *(_QWORD *)(a1 + 24)) != 0)
  {
    result = DH_compute_key(key, *(const BIGNUM **)(*(_QWORD *)(v4 + 32) + 32), *(DH **)(v3 + 32));
    if ((result & 0x80000000) == 0)
    {
      *a3 = result;
      return 1;
    }
  }
  else
  {
    ERR_put_error(5, 4095, 108, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/dh/dh_pmeth.c", 239);
    return 0;
  }
  return result;
}

uint64_t pkey_dh_ctrl(uint64_t a1, int a2, int a3)
{
  int *v3;

  if (a2 != 2)
  {
    v3 = *(int **)(a1 + 40);
    if (a2 == 4098)
    {
      v3[1] = a3;
    }
    else
    {
      if (a2 != 4097 || a3 < 256)
        return 4294967294;
      *v3 = a3;
    }
  }
  return 1;
}

uint64_t pkey_dh_ctrl_str(uint64_t *a1, char *__s1, const char *a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char *__endptr;

  __endptr = 0;
  if (!strcmp(__s1, "dh_paramgen_prime_len"))
  {
    *__error() = 0;
    v8 = strtol(a3, &__endptr, 10);
    if (*a3)
    {
      if (!*__endptr)
      {
        v9 = v8;
        __error();
        if (v9 == (int)v9)
          return EVP_PKEY_CTX_ctrl(a1, 28, 2);
      }
    }
    return 4294967294;
  }
  if (strcmp(__s1, "dh_paramgen_generator"))
    return 4294967294;
  *__error() = 0;
  v6 = strtol(a3, &__endptr, 10);
  if (!*a3)
    return 4294967294;
  if (*__endptr)
    return 4294967294;
  v7 = v6;
  __error();
  if (v7 != (int)v7)
    return 4294967294;
  return EVP_PKEY_CTX_ctrl(a1, 28, 2);
}

BIGNUM *GOST_le2bn(unsigned __int8 *a1, unint64_t a2, BIGNUM *a3)
{
  unint64_t v4;
  unsigned __int8 v5;
  unsigned __int8 s[64];
  uint64_t v8;

  v8 = *MEMORY[0x24BDAC8D0];
  if (a2 > 0x40)
    return 0;
  if (a2)
  {
    v4 = a2;
    do
    {
      v5 = *a1++;
      s[--v4] = v5;
    }
    while (v4);
  }
  return BN_bin2bn(s, a2, a3);
}

uint64_t GOST_bn2le(const BIGNUM *a1, uint64_t a2, int a3)
{
  int v6;
  uint64_t result;
  int v8;
  int v9;
  BOOL v10;
  int v11;
  uint64_t v12;
  _BYTE *v13;
  unsigned __int8 *v14;
  char v15;
  unsigned __int8 to[64];
  uint64_t v17;

  v17 = *MEMORY[0x24BDAC8D0];
  v6 = BN_num_bits(a1);
  result = 0;
  v8 = v6 + 7;
  if (v6 < -7)
    v8 = v6 + 14;
  if (a3 <= 64)
  {
    v9 = v8 >> 3;
    v10 = __OFSUB__(a3, v8 >> 3);
    v11 = a3 - (v8 >> 3);
    if (v11 < 0 == v10)
    {
      BN_bn2bin(a1, to);
      if (v6 >= 1)
      {
        if (v9 <= 1)
          v12 = 1;
        else
          v12 = v9;
        v13 = (_BYTE *)(v9 + a2 - 1);
        v14 = to;
        do
        {
          v15 = *v14++;
          *v13-- = v15;
          --v12;
        }
        while (v12);
      }
      bzero((void *)(a2 + v9), v11);
      return 1;
    }
  }
  return result;
}

uint64_t gost2001_compute_public(const EC_GROUP **a1)
{
  uint64_t v2;
  const EC_GROUP *v3;
  BN_CTX *v4;
  BN_CTX *v5;
  uint64_t v6;
  const BIGNUM *v7;
  EC_POINT *v8;
  uint64_t v9;
  int v10;
  int v11;

  v2 = GOST_KEY_get0_group((uint64_t)a1);
  if (v2)
  {
    v3 = (const EC_GROUP *)v2;
    v4 = BN_CTX_new();
    if (v4)
    {
      v5 = v4;
      BN_CTX_start(v4);
      v6 = GOST_KEY_get0_private_key((uint64_t)a1);
      if (v6)
      {
        v7 = (const BIGNUM *)v6;
        v8 = EC_POINT_new(v3);
        if (v8 && EC_POINT_mul(v3, v8, v7, 0, 0, v5) && GOST_KEY_set_public_key(a1, v8))
        {
          v9 = 1;
LABEL_13:
          EC_POINT_free(v8);
          BN_CTX_end(v5);
          BN_CTX_free(v5);
          return v9;
        }
      }
      else
      {
        v8 = 0;
      }
      ERR_put_error(50, 4095, 16, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/gost/gostr341001.c", 136);
      v9 = 0;
      goto LABEL_13;
    }
    v10 = 65;
    v11 = 118;
  }
  else
  {
    v10 = 112;
    v11 = 113;
  }
  ERR_put_error(50, 4095, v10, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/gost/gostr341001.c", v11);
  return 0;
}

ECDSA_SIG *gost2001_do_sign(const BIGNUM *a1, uint64_t a2)
{
  BN_CTX *v4;
  BN_CTX *v5;
  ECDSA_SIG *v6;
  ECDSA_SIG *v7;
  BIGNUM *s;
  BIGNUM *v9;
  const EC_GROUP *v10;
  BIGNUM *v11;
  const BIGNUM *v12;
  uint64_t v13;
  BIGNUM *v14;
  const BIGNUM *v15;
  BIGNUM *v16;
  BIGNUM *v17;
  BIGNUM *v18;
  const BIGNUM *v19;
  EC_POINT *v20;
  const BIGNUM *v21;
  int v22;
  BIGNUM *v23;
  BIGNUM *v24;
  int v26;
  int v27;
  BIGNUM *r;
  BIGNUM *v29;
  BIGNUM *a;
  BIGNUM *v31;

  v4 = BN_CTX_new();
  if (v4)
  {
    v5 = v4;
    BN_CTX_start(v4);
    v6 = ECDSA_SIG_new();
    v7 = v6;
    if (v6)
    {
      v9 = v6->r;
      s = v6->s;
      v10 = (const EC_GROUP *)GOST_KEY_get0_group(a2);
      v11 = BN_CTX_get(v5);
      if (v11)
      {
        v12 = v11;
        if (EC_GROUP_get_order(v10, v11, v5))
        {
          v13 = GOST_KEY_get0_private_key(a2);
          v14 = BN_CTX_get(v5);
          if (v14)
          {
            v15 = v14;
            if (BN_mod_ct(v14, a1, v12, v5))
            {
              if (!BN_is_zero((uint64_t)v15) || BN_one((uint64_t)v15))
              {
                a = (BIGNUM *)v13;
                v31 = s;
                v16 = BN_CTX_get(v5);
                if (v16)
                {
                  v17 = v16;
                  v18 = BN_CTX_get(v5);
                  if (v18)
                  {
                    v19 = v18;
                    v20 = EC_POINT_new(v10);
                    if (v20)
                    {
                      r = 0;
                      v29 = 0;
                      while (1)
                      {
                        if (!BN_rand_range(v17, v12))
                        {
                          v26 = 120;
                          v27 = 194;
                          goto LABEL_39;
                        }
                        if (!BN_add(v17, v17, v12))
                          goto LABEL_33;
                        v21 = v19;
                        v22 = BN_num_bits(v17);
                        if (v22 <= BN_num_bits(v12) && !BN_add(v17, v17, v12))
                          goto LABEL_33;
                        if (!EC_POINT_mul(v10, v20, v17, 0, 0, v5))
                        {
                          v26 = 16;
                          v27 = 209;
                          goto LABEL_39;
                        }
                        v19 = v21;
                        if (!EC_POINT_get_affine_coordinates((uint64_t)v10, v20, (uint64_t)v21, 0, v5))
                          break;
                        if (!BN_nnmod(v9, v21, v12, v5))
                          goto LABEL_33;
                        if (!BN_is_zero((uint64_t)v9))
                        {
                          v23 = v29;
                          if (!v29)
                          {
                            v23 = BN_CTX_get(v5);
                            if (!v23)
                              goto LABEL_33;
                          }
                          v29 = v23;
                          if (!BN_mod_mul(v23, a, v9, v12, v5))
                            goto LABEL_33;
                          v24 = r;
                          if (!r)
                          {
                            v24 = BN_CTX_get(v5);
                            if (!v24)
                              goto LABEL_33;
                          }
                          if (!BN_mod_mul(v24, v17, v15, v12, v5))
                            goto LABEL_33;
                          r = v24;
                          if (!BN_mod_add(v31, v29, v24, v12, v5))
                            goto LABEL_33;
                          if (!BN_is_zero((uint64_t)v31))
                          {
                            EC_POINT_free(v20);
                            BN_CTX_end(v5);
                            BN_CTX_free(v5);
                            return v7;
                          }
                        }
                      }
                      v26 = 16;
                      v27 = 214;
LABEL_39:
                      ERR_put_error(50, 4095, v26, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/gost/gostr341001.c", v27);
                    }
                    goto LABEL_33;
                  }
                }
              }
            }
          }
        }
      }
    }
    else
    {
      ERR_put_error(50, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/gost/gostr341001.c", 166);
    }
    v20 = 0;
LABEL_33:
    EC_POINT_free(v20);
    BN_CTX_end(v5);
    BN_CTX_free(v5);
    ECDSA_SIG_free(v7);
    return 0;
  }
  ERR_put_error(50, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/gost/gostr341001.c", 160);
  return 0;
}

uint64_t gost2001_do_verify(const BIGNUM *a1, uint64_t *a2, uint64_t a3)
{
  BN_CTX *v6;
  uint64_t v7;
  const EC_GROUP *v8;
  EC_POINT *v9;
  BIGNUM *v10;
  BIGNUM *v11;
  BIGNUM *v12;
  BIGNUM *v13;
  BIGNUM *v14;
  const EC_POINT *v15;
  uint64_t v16;
  const BIGNUM *v18;
  EC_POINT *v19;
  int v20;
  int v21;
  BIGNUM *v22;
  BIGNUM *a;
  const BIGNUM *v24;

  v6 = BN_CTX_new();
  v7 = GOST_KEY_get0_group(a3);
  if (!v6)
  {
    EC_POINT_free(0);
    return 0;
  }
  v8 = (const EC_GROUP *)v7;
  BN_CTX_start(v6);
  v9 = (EC_POINT *)BN_CTX_get(v6);
  if (!v9)
    goto LABEL_17;
  v10 = (BIGNUM *)v9;
  v9 = (EC_POINT *)BN_CTX_get(v6);
  if (!v9)
    goto LABEL_17;
  v11 = (BIGNUM *)v9;
  v9 = (EC_POINT *)BN_CTX_get(v6);
  if (!v9)
    goto LABEL_17;
  v12 = (BIGNUM *)v9;
  v9 = (EC_POINT *)BN_CTX_get(v6);
  if (!v9)
    goto LABEL_17;
  v13 = (BIGNUM *)v9;
  v9 = (EC_POINT *)BN_CTX_get(v6);
  if (!v9)
    goto LABEL_17;
  v14 = (BIGNUM *)v9;
  v9 = (EC_POINT *)BN_CTX_get(v6);
  if (!v9)
    goto LABEL_17;
  v24 = (const BIGNUM *)v9;
  v9 = (EC_POINT *)BN_CTX_get(v6);
  if (!v9)
    goto LABEL_17;
  a = (BIGNUM *)v9;
  v9 = (EC_POINT *)BN_CTX_get(v6);
  if (!v9)
    goto LABEL_17;
  v22 = (BIGNUM *)v9;
  if (!EC_GROUP_get_order(v8, v10, v6))
    goto LABEL_16;
  v15 = (const EC_POINT *)GOST_KEY_get0_public_key(a3);
  if (BN_is_zero(a2[1])
    || BN_is_zero(*a2)
    || BN_cmp((const BIGNUM *)a2[1], v10) > 0
    || BN_cmp((const BIGNUM *)*a2, v10) >= 1)
  {
    ERR_put_error(50, 4095, 122, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/gost/gostr341001.c", 288);
    goto LABEL_16;
  }
  if (BN_mod_ct(v11, a1, v10, v6) && (!BN_is_zero((uint64_t)v11) || BN_one((uint64_t)v11)))
  {
    v9 = (EC_POINT *)BN_mod_inverse_ct(v22, v11, v10, v6);
    if (!v9)
      goto LABEL_17;
    v18 = (const BIGNUM *)v9;
    if (BN_mod_mul(v12, (const BIGNUM *)a2[1], (const BIGNUM *)v9, v10, v6))
    {
      if (BN_sub(v14, v10, (const BIGNUM *)*a2) && BN_mod_mul(v13, v14, v18, v10, v6))
      {
        v9 = EC_POINT_new(v8);
        if (!v9)
          goto LABEL_17;
        v19 = v9;
        if (EC_POINT_mul(v8, v9, v12, v15, v13, v6))
        {
          if (EC_POINT_get_affine_coordinates((uint64_t)v8, v19, (uint64_t)v24, 0, v6))
          {
            if (!BN_mod_ct(a, v24, v10, v6))
            {
LABEL_37:
              v16 = 0;
LABEL_38:
              v9 = v19;
              goto LABEL_18;
            }
            if (!BN_cmp(a, (const BIGNUM *)*a2))
            {
              v16 = 1;
              goto LABEL_38;
            }
            v20 = 121;
            v21 = 319;
          }
          else
          {
            v20 = 16;
            v21 = 313;
          }
        }
        else
        {
          v20 = 16;
          v21 = 309;
        }
        ERR_put_error(50, 4095, v20, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/gost/gostr341001.c", v21);
        goto LABEL_37;
      }
    }
  }
LABEL_16:
  v9 = 0;
LABEL_17:
  v16 = 0;
LABEL_18:
  EC_POINT_free(v9);
  BN_CTX_end(v6);
  BN_CTX_free(v6);
  return v16;
}

BOOL VKO_compute_key(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, const BIGNUM *a5)
{
  const BIGNUM *v10;
  const EC_GROUP *v11;
  const EC_POINT *v12;
  EC_POINT *v13;
  BN_CTX *v14;
  BN_CTX *v15;
  BIGNUM *v16;
  BIGNUM *v17;
  BIGNUM *v18;
  const BIGNUM *v19;
  _BOOL8 v20;

  v10 = (const BIGNUM *)GOST_KEY_get0_private_key(a4);
  v11 = (const EC_GROUP *)GOST_KEY_get0_group(a4);
  v12 = (const EC_POINT *)GOST_KEY_get0_public_key(a3);
  v13 = EC_POINT_new(v11);
  if (v13 && (v14 = BN_CTX_new()) != 0)
  {
    v15 = v14;
    BN_CTX_start(v14);
    v16 = BN_CTX_get(v15);
    v20 = v16
       && (v17 = v16, (v18 = BN_CTX_get(v15)) != 0)
       && (v19 = v18, EC_GROUP_get_order(v11, v18, v15))
       && BN_mod_mul(v17, v10, a5, v19, v15)
       && EC_POINT_mul(v11, v13, 0, v12, v17, v15)
       && EC_POINT_get_affine_coordinates((uint64_t)v11, v13, a1, a2, v15) != 0;
    BN_CTX_end(v15);
    BN_CTX_free(v15);
  }
  else
  {
    v20 = 0;
  }
  EC_POINT_free(v13);
  return v20;
}

uint64_t gost2001_keygen(const EC_GROUP **a1)
{
  BIGNUM *v2;
  BIGNUM *v3;
  const EC_GROUP *v4;
  uint64_t v5;

  v2 = BN_new();
  v3 = BN_new();
  v4 = (const EC_GROUP *)GOST_KEY_get0_group((uint64_t)a1);
  v5 = 0;
  if (v2 && v3)
  {
    if (EC_GROUP_get_order(v4, v2, 0))
    {
      do
      {
        if (!BN_rand_range(v3, v2))
        {
          ERR_put_error(50, 4095, 120, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/gost/gostr341001.c", 389);
          goto LABEL_9;
        }
      }
      while (BN_is_zero((uint64_t)v3));
      if (!GOST_KEY_set_private_key((uint64_t)a1, v3))
        goto LABEL_9;
      v5 = gost2001_compute_public(a1);
    }
    else
    {
LABEL_9:
      v5 = 0;
    }
  }
  BN_free(v3);
  BN_free(v2);
  return v5;
}

const EVP_MD *EVP_ripemd160(void)
{
  return (const EVP_MD *)&ripemd160_md;
}

uint64_t init_2(uint64_t a1)
{
  return RIPEMD160_Init(*(RIPEMD160_CTX **)(a1 + 24));
}

uint64_t update_2(uint64_t a1, const void *a2, size_t a3)
{
  return RIPEMD160_Update(*(RIPEMD160_CTX **)(a1 + 24), a2, a3);
}

uint64_t final_2(uint64_t a1, unsigned __int8 *md)
{
  return RIPEMD160_Final(md, *(RIPEMD160_CTX **)(a1 + 24));
}

uint64_t pkey_gost_mac_init(uint64_t a1)
{
  uint64_t result;

  result = (uint64_t)malloc_type_calloc(1uLL, 0x30uLL, 0x102004094E2EAF5uLL);
  if (result)
  {
    EVP_PKEY_CTX_set_data(a1, result);
    return 1;
  }
  return result;
}

uint64_t pkey_gost_mac_copy(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  _OWORD *data;
  _OWORD *v6;
  __int128 v7;
  __int128 v8;

  result = pkey_gost_mac_init(a1);
  if ((_DWORD)result)
  {
    data = (_OWORD *)EVP_PKEY_CTX_get_data(a2);
    v6 = (_OWORD *)EVP_PKEY_CTX_get_data(a1);
    v8 = data[1];
    v7 = data[2];
    *v6 = *data;
    v6[1] = v8;
    v6[2] = v7;
    return 1;
  }
  return result;
}

void pkey_gost_mac_cleanup(uint64_t a1)
{
  void *data;

  data = (void *)EVP_PKEY_CTX_get_data(a1);
  free(data);
}

uint64_t pkey_gost_mac_keygen(uint64_t a1, EVP_PKEY *a2)
{
  uint64_t data;
  int v4;
  int v5;
  uint64_t v6;
  char *v7;
  __int128 v8;

  data = EVP_PKEY_CTX_get_data(a1);
  if ((*(_BYTE *)(data + 40) & 1) != 0)
  {
    v6 = data;
    v7 = (char *)malloc_type_malloc(0x20uLL, 0x5F953470uLL);
    if (v7)
    {
      v8 = *(_OWORD *)(v6 + 24);
      *(_OWORD *)v7 = *(_OWORD *)(v6 + 8);
      *((_OWORD *)v7 + 1) = v8;
      EVP_PKEY_assign(a2, 815, v7);
      return 1;
    }
    v4 = 65;
    v5 = 119;
  }
  else
  {
    v4 = 102;
    v5 = 113;
  }
  ERR_put_error(50, 4095, v4, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/gost/gost89imit_pmeth.c", v5);
  return 0;
}

uint64_t pkey_gost_mac_signctx_init()
{
  return 1;
}

uint64_t pkey_gost_mac_signctx(int a1, unsigned __int8 *a2, uint64_t *a3, EVP_MD_CTX *ctx)
{
  uint64_t result;
  uint64_t v6;
  unsigned int s;

  s = *a3;
  if (a2)
  {
    result = EVP_DigestFinal_ex(ctx, a2, &s);
    v6 = s;
  }
  else
  {
    result = 1;
    v6 = 4;
  }
  *a3 = v6;
  return result;
}

uint64_t pkey_gost_mac_ctrl(uint64_t a1, int a2, int a3, const EVP_MD *a4)
{
  uint64_t data;
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  int v13;
  __int128 v14;
  uint64_t (*v16)(const EVP_MD *, uint64_t, uint64_t, uint64_t);

  data = EVP_PKEY_CTX_get_data(a1);
  v9 = (_QWORD *)data;
  if (a2 != 7)
  {
    if (a2 == 6)
    {
      if (a3 == 32)
      {
        v14 = *(_OWORD *)&a4->type;
        *(_OWORD *)(data + 24) = *(_OWORD *)&a4->flags;
        *(_OWORD *)(data + 8) = v14;
        *(_BYTE *)(data + 40) |= 1u;
        return 1;
      }
      v12 = 101;
      v13 = 144;
    }
    else
    {
      if (a2 != 1)
        return 4294967294;
      if (EVP_MD_type(a4) == 815)
      {
        *v9 = a4;
        return 1;
      }
      v12 = 100;
      v13 = 136;
    }
    goto LABEL_20;
  }
  if ((*(_BYTE *)(data + 40) & 1) != 0)
  {
    v11 = data + 8;
  }
  else
  {
    v10 = EVP_PKEY_CTX_get0_pkey(a1);
    if (!v10)
    {
      v12 = 102;
      v13 = 160;
      goto LABEL_20;
    }
    v11 = EVP_PKEY_get0(v10);
    if (!v11)
    {
      v12 = 102;
      v13 = 165;
LABEL_20:
      ERR_put_error(50, 4095, v12, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/gost/gost89imit_pmeth.c", v13);
      return 0;
    }
  }
  v16 = *(uint64_t (**)(const EVP_MD *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)&a4->type + 72);
  if (v16)
    return v16(a4, 3, 256, v11);
  return 0;
}

uint64_t pkey_gost_mac_ctrl_str(uint64_t a1, char *__s1, char *a3)
{
  uint64_t v6;
  int v7;
  unsigned __int8 *v9;
  unsigned __int8 *v10;
  uint64_t len;

  if (!a3)
    return 0;
  if (!strcmp(__s1, "key"))
  {
    v7 = strlen(a3);
    return pkey_gost_mac_ctrl(a1, 6, v7, (const EVP_MD *)a3);
  }
  if (!strcmp(__s1, "hexkey"))
  {
    len = 0;
    v9 = string_to_hex(a3, &len);
    if (v9)
    {
      v10 = v9;
      v6 = pkey_gost_mac_ctrl(a1, 6, len, (const EVP_MD *)v9);
      free(v10);
      return v6;
    }
    return 0;
  }
  return 4294967294;
}

int RSA_verify_PKCS1_PSS(RSA *rsa, const unsigned __int8 *mHash, const EVP_MD *Hash, const unsigned __int8 *EM, int sLen)
{
  return RSA_verify_PKCS1_PSS_mgf1(rsa, mHash, Hash, 0, (char *)EM, sLen);
}

uint64_t RSA_verify_PKCS1_PSS_mgf1(const RSA *a1, const void *a2, const EVP_MD *a3, const EVP_MD *a4, char *a5, int a6)
{
  const EVP_MD *v12;
  int v13;
  unsigned int v14;
  int v15;
  int v16;
  int v17;
  int v18;
  int v19;
  char *v20;
  int v21;
  int v22;
  int v23;
  unsigned __int8 *v24;
  unsigned __int8 *v25;
  const unsigned __int8 *v26;
  uint64_t v27;
  unsigned __int8 *v28;
  char v29;
  uint64_t v30;
  int v31;
  BOOL v32;
  int v33;
  int v34;
  uint64_t v35;
  int v37;
  uint64_t len;
  EVP_MD_CTX ctx;
  __int128 v40;
  unsigned __int8 md[64];
  uint64_t v42;

  v42 = *MEMORY[0x24BDAC8D0];
  v40 = 0u;
  memset(&ctx, 0, sizeof(ctx));
  EVP_MD_CTX_init(&ctx);
  if (a4)
    v12 = a4;
  else
    v12 = a3;
  v13 = EVP_MD_size(a3);
  if (v13 < 0)
    goto LABEL_38;
  v14 = v13;
  if (a6 == -1)
  {
    a6 = v13;
LABEL_9:
    v17 = (BN_num_bits(a1->n) - 1) & 7;
    v18 = RSA_size(a1);
    if (*a5 >> v17)
    {
      v15 = 133;
      v16 = 120;
      goto LABEL_37;
    }
    v19 = v18;
    if (v17)
      v20 = a5;
    else
      v20 = a5 + 1;
    if (v17)
      v21 = 0;
    else
      v21 = -1;
    v22 = (__PAIR64__(v18, v17) - 1) >> 32;
    if (v22 < (int)(v14 + a6 + 2))
    {
      v15 = 109;
      v16 = 129;
      goto LABEL_37;
    }
    if (v20[v22 - 1] != 188)
    {
      v15 = 134;
      v16 = 133;
      goto LABEL_37;
    }
    v37 = v21;
    v23 = v22 + ~v14;
    len = v23;
    v24 = (unsigned __int8 *)malloc_type_malloc(v23, 0x2AA7D4E2uLL);
    v25 = v24;
    if (v24)
    {
      v26 = (const unsigned __int8 *)&v20[v23];
      if (PKCS1_MGF1(v24, len, v26, v14, v12) < 0)
      {
LABEL_43:
        v35 = 0;
        goto LABEL_39;
      }
      if ((int)len >= 1)
      {
        v27 = len;
        v28 = v25;
        do
        {
          v29 = *v20++;
          *v28++ ^= v29;
          --v27;
        }
        while (v27);
      }
      if (v17)
        *v25 &= 0xFFu >> (8 - v17);
      v30 = 0;
      do
      {
        v31 = v25[v30];
        if (v25[v30])
          v32 = 0;
        else
          v32 = v30 < (int)len - 1;
        ++v30;
      }
      while (v32);
      if (v31 == 1)
      {
        if (a6 < 0 || ~v14 + v19 + v37 - a6 == (_DWORD)v30)
        {
          if (!EVP_DigestInit_ex(&ctx, a3, 0)
            || !EVP_DigestUpdate(&ctx, &zeroes, 8uLL)
            || !EVP_DigestUpdate(&ctx, a2, v14)
            || (_DWORD)len != (_DWORD)v30 && !EVP_DigestUpdate(&ctx, &v25[v30], (int)len - (int)v30)
            || !EVP_DigestFinal_ex(&ctx, md, 0))
          {
            goto LABEL_43;
          }
          if (!timingsafe_bcmp(md, v26, v14))
          {
            v35 = 1;
            goto LABEL_39;
          }
          v33 = 104;
          v34 = 170;
        }
        else
        {
          v33 = 136;
          v34 = 156;
        }
      }
      else
      {
        v33 = 135;
        v34 = 152;
      }
    }
    else
    {
      v33 = 65;
      v34 = 140;
    }
    ERR_put_error(4, 4095, v33, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/rsa/rsa_pss.c", v34);
    goto LABEL_43;
  }
  if (a6 > -3)
    goto LABEL_9;
  v15 = 136;
  v16 = 113;
LABEL_37:
  ERR_put_error(4, 4095, v15, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/rsa/rsa_pss.c", v16);
LABEL_38:
  v35 = 0;
  v25 = 0;
LABEL_39:
  free(v25);
  EVP_MD_CTX_cleanup(&ctx);
  return v35;
}

int RSA_padding_add_PKCS1_PSS(RSA *rsa, unsigned __int8 *EM, const unsigned __int8 *mHash, const EVP_MD *Hash, int sLen)
{
  return RSA_padding_add_PKCS1_PSS_mgf1(rsa, EM, mHash, Hash, 0, sLen);
}

uint64_t RSA_padding_add_PKCS1_PSS_mgf1(const RSA *a1, unsigned __int8 *a2, const void *a3, const EVP_MD *a4, const EVP_MD *a5, int a6)
{
  const EVP_MD *v12;
  int v13;
  unsigned int v14;
  int v15;
  int v16;
  int v17;
  int v18;
  int v19;
  uint64_t v20;
  void *v21;
  void *v22;
  int v23;
  int v24;
  uint64_t v25;
  uint64_t v26;
  unsigned __int8 *v27;
  char *v28;
  char v29;
  EVP_MD_CTX v31;
  __int128 v32;

  v32 = 0u;
  memset(&v31, 0, sizeof(v31));
  EVP_MD_CTX_init(&v31);
  if (a5)
    v12 = a5;
  else
    v12 = a4;
  v13 = EVP_MD_size(a4);
  if (v13 < 0)
    goto LABEL_18;
  v14 = v13;
  if (a6 == -1)
  {
    a6 = v13;
  }
  else if (a6 == -2)
  {
    a6 = -2;
  }
  else if (a6 <= -3)
  {
    v15 = 136;
    v16 = 219;
LABEL_17:
    ERR_put_error(4, 4095, v15, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/rsa/rsa_pss.c", v16);
LABEL_18:
    v20 = 0;
    v21 = 0;
    goto LABEL_38;
  }
  v17 = (BN_num_bits(a1->n) - 1) & 7;
  v18 = RSA_size(a1);
  v19 = v18;
  if (!v17)
  {
    *a2++ = 0;
    v19 = v18 - 1;
  }
  if (a6 == -2)
  {
    a6 = v19 - v14 - 2;
    goto LABEL_19;
  }
  if (v19 < (int)(v14 + a6 + 2))
  {
    v15 = 110;
    v16 = 232;
    goto LABEL_17;
  }
LABEL_19:
  if (a6 < 1)
  {
    v21 = 0;
  }
  else
  {
    v22 = malloc_type_malloc(a6, 0x2133C23DuLL);
    v21 = v22;
    if (!v22)
    {
      ERR_put_error(4, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/rsa/rsa_pss.c", 238);
LABEL_37:
      v20 = 0;
      goto LABEL_38;
    }
    arc4random_buf(v22, a6);
  }
  if (!EVP_DigestInit_ex(&v31, a4, 0)
    || !EVP_DigestUpdate(&v31, &zeroes, 8uLL)
    || !EVP_DigestUpdate(&v31, a3, v14)
    || a6 && !EVP_DigestUpdate(&v31, v21, a6))
  {
    goto LABEL_37;
  }
  v23 = v19 + ~v14;
  if (!EVP_DigestFinal_ex(&v31, &a2[v23], 0) || PKCS1_MGF1(a2, v23, &a2[v23], v14, v12))
    goto LABEL_37;
  v24 = v19 - a6 - v14 - 2;
  a2[v24] ^= 1u;
  if (a6 >= 1)
  {
    v25 = v24;
    v26 = a6;
    v27 = &a2[v25 + 1];
    v28 = (char *)v21;
    do
    {
      v29 = *v28++;
      *v27++ ^= v29;
      --v26;
    }
    while (v26);
  }
  if (v17)
    *a2 &= 0xFFu >> (8 - v17);
  a2[v19 - 1] = -68;
  v20 = 1;
LABEL_38:
  free(v21);
  EVP_MD_CTX_cleanup(&v31);
  return v20;
}

uint64_t EVP_PKEY_sign_init(uint64_t *a1)
{
  uint64_t v2;
  uint64_t (*v3)(uint64_t *);
  uint64_t result;

  if (a1 && (v2 = *a1) != 0 && *(_QWORD *)(v2 + 72))
  {
    *((_DWORD *)a1 + 8) = 8;
    v3 = *(uint64_t (**)(uint64_t *))(v2 + 64);
    if (v3)
    {
      result = v3(a1);
      if ((int)result <= 0)
        *((_DWORD *)a1 + 8) = 0;
    }
    else
    {
      return 1;
    }
  }
  else
  {
    ERR_put_error(6, 4095, 150, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/pmeth_fn.c", 90);
    return 4294967294;
  }
  return result;
}

uint64_t EVP_PKEY_sign(uint64_t *a1, uint64_t a2, _QWORD *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v6;
  uint64_t (*v7)(uint64_t *, uint64_t, _QWORD *, uint64_t, uint64_t);
  int v12;

  if (!a1
    || (v6 = *a1) == 0
    || (v7 = *(uint64_t (**)(uint64_t *, uint64_t, _QWORD *, uint64_t, uint64_t))(v6 + 72)) == 0)
  {
    ERR_put_error(6, 4095, 150, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/pmeth_fn.c", 107);
    return 4294967294;
  }
  if (*((_DWORD *)a1 + 8) != 8)
  {
    ERR_put_error(6, 4095, 151, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/pmeth_fn.c", 111);
    return 0xFFFFFFFFLL;
  }
  if ((*(_BYTE *)(v6 + 4) & 2) != 0)
  {
    v12 = EVP_PKEY_size((EVP_PKEY *)a1[2]);
    if (!a2)
    {
      *a3 = v12;
      return 1;
    }
    if (*a3 < (unint64_t)v12)
    {
      ERR_put_error(6, 4095, 155, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/pmeth_fn.c", 114);
      return 0;
    }
    v7 = *(uint64_t (**)(uint64_t *, uint64_t, _QWORD *, uint64_t, uint64_t))(*a1 + 72);
  }
  return v7(a1, a2, a3, a4, a5);
}

uint64_t EVP_PKEY_verify_init(uint64_t *a1)
{
  uint64_t v2;
  uint64_t (*v3)(uint64_t *);
  uint64_t result;

  if (a1 && (v2 = *a1) != 0 && *(_QWORD *)(v2 + 88))
  {
    *((_DWORD *)a1 + 8) = 16;
    v3 = *(uint64_t (**)(uint64_t *))(v2 + 80);
    if (v3)
    {
      result = v3(a1);
      if ((int)result <= 0)
        *((_DWORD *)a1 + 8) = 0;
    }
    else
    {
      return 1;
    }
  }
  else
  {
    ERR_put_error(6, 4095, 150, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/pmeth_fn.c", 124);
    return 4294967294;
  }
  return result;
}

uint64_t EVP_PKEY_verify(_DWORD *a1)
{
  uint64_t (*v1)(void);

  if (a1 && *(_QWORD *)a1 && (v1 = *(uint64_t (**)(void))(*(_QWORD *)a1 + 88)) != 0)
  {
    if (a1[8] == 16)
    {
      return v1();
    }
    else
    {
      ERR_put_error(6, 4095, 151, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/pmeth_fn.c", 145);
      return 0xFFFFFFFFLL;
    }
  }
  else
  {
    ERR_put_error(6, 4095, 150, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/pmeth_fn.c", 141);
    return 4294967294;
  }
}

uint64_t EVP_PKEY_verify_recover_init(uint64_t *a1)
{
  uint64_t v2;
  uint64_t (*v3)(uint64_t *);
  uint64_t result;

  if (a1 && (v2 = *a1) != 0 && *(_QWORD *)(v2 + 104))
  {
    *((_DWORD *)a1 + 8) = 32;
    v3 = *(uint64_t (**)(uint64_t *))(v2 + 96);
    if (v3)
    {
      result = v3(a1);
      if ((int)result <= 0)
        *((_DWORD *)a1 + 8) = 0;
    }
    else
    {
      return 1;
    }
  }
  else
  {
    ERR_put_error(6, 4095, 150, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/pmeth_fn.c", 157);
    return 4294967294;
  }
  return result;
}

uint64_t EVP_PKEY_verify_recover(uint64_t *a1, uint64_t a2, _QWORD *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v6;
  uint64_t (*v7)(uint64_t *, uint64_t, _QWORD *, uint64_t, uint64_t);
  int v12;

  if (!a1
    || (v6 = *a1) == 0
    || (v7 = *(uint64_t (**)(uint64_t *, uint64_t, _QWORD *, uint64_t, uint64_t))(v6 + 104)) == 0)
  {
    ERR_put_error(6, 4095, 150, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/pmeth_fn.c", 174);
    return 4294967294;
  }
  if (*((_DWORD *)a1 + 8) != 32)
  {
    ERR_put_error(6, 4095, 151, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/pmeth_fn.c", 178);
    return 0xFFFFFFFFLL;
  }
  if ((*(_BYTE *)(v6 + 4) & 2) != 0)
  {
    v12 = EVP_PKEY_size((EVP_PKEY *)a1[2]);
    if (!a2)
    {
      *a3 = v12;
      return 1;
    }
    if (*a3 < (unint64_t)v12)
    {
      ERR_put_error(6, 4095, 155, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/pmeth_fn.c", 181);
      return 0;
    }
    v7 = *(uint64_t (**)(uint64_t *, uint64_t, _QWORD *, uint64_t, uint64_t))(*a1 + 104);
  }
  return v7(a1, a2, a3, a4, a5);
}

uint64_t EVP_PKEY_encrypt_init(uint64_t *a1)
{
  uint64_t v2;
  uint64_t (*v3)(uint64_t *);
  uint64_t result;

  if (a1 && (v2 = *a1) != 0 && *(_QWORD *)(v2 + 152))
  {
    *((_DWORD *)a1 + 8) = 256;
    v3 = *(uint64_t (**)(uint64_t *))(v2 + 144);
    if (v3)
    {
      result = v3(a1);
      if ((int)result <= 0)
        *((_DWORD *)a1 + 8) = 0;
    }
    else
    {
      return 1;
    }
  }
  else
  {
    ERR_put_error(6, 4095, 150, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/pmeth_fn.c", 191);
    return 4294967294;
  }
  return result;
}

int EVP_PKEY_encrypt(unsigned __int8 *enc_key, const unsigned __int8 *key, int key_len, EVP_PKEY *pub_key)
{
  uint64_t v4;
  uint64_t v6;
  uint64_t (*v7)(unsigned __int8 *, const unsigned __int8 *, _QWORD *, EVP_PKEY *, uint64_t);
  uint64_t v8;
  _QWORD *v10;
  int v12;

  if (!enc_key
    || (v6 = *(_QWORD *)enc_key) == 0
    || (v7 = *(uint64_t (**)(unsigned __int8 *, const unsigned __int8 *, _QWORD *, EVP_PKEY *, uint64_t))(v6 + 152)) == 0)
  {
    ERR_put_error(6, 4095, 150, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/pmeth_fn.c", 208);
    return -2;
  }
  if (*((_DWORD *)enc_key + 8) != 256)
  {
    ERR_put_error(6, 4095, 151, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/pmeth_fn.c", 212);
    return -1;
  }
  v8 = v4;
  v10 = *(_QWORD **)&key_len;
  if ((*(_BYTE *)(v6 + 4) & 2) != 0)
  {
    v12 = EVP_PKEY_size(*((EVP_PKEY **)enc_key + 2));
    if (!key)
    {
      *v10 = v12;
      return 1;
    }
    if (*v10 < (unint64_t)v12)
    {
      ERR_put_error(6, 4095, 155, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/pmeth_fn.c", 215);
      return 0;
    }
    v7 = *(uint64_t (**)(unsigned __int8 *, const unsigned __int8 *, _QWORD *, EVP_PKEY *, uint64_t))(*(_QWORD *)enc_key + 152);
  }
  return v7(enc_key, key, v10, pub_key, v8);
}

uint64_t EVP_PKEY_decrypt_init(uint64_t *a1)
{
  uint64_t v2;
  uint64_t (*v3)(uint64_t *);
  uint64_t result;

  if (a1 && (v2 = *a1) != 0 && *(_QWORD *)(v2 + 168))
  {
    *((_DWORD *)a1 + 8) = 512;
    v3 = *(uint64_t (**)(uint64_t *))(v2 + 160);
    if (v3)
    {
      result = v3(a1);
      if ((int)result <= 0)
        *((_DWORD *)a1 + 8) = 0;
    }
    else
    {
      return 1;
    }
  }
  else
  {
    ERR_put_error(6, 4095, 150, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/pmeth_fn.c", 225);
    return 4294967294;
  }
  return result;
}

int EVP_PKEY_decrypt(unsigned __int8 *dec_key, const unsigned __int8 *enc_key, int enc_key_len, EVP_PKEY *private_key)
{
  uint64_t v4;
  uint64_t v6;
  uint64_t (*v7)(unsigned __int8 *, const unsigned __int8 *, _QWORD *, EVP_PKEY *, uint64_t);
  uint64_t v8;
  _QWORD *v10;
  int v12;

  if (!dec_key
    || (v6 = *(_QWORD *)dec_key) == 0
    || (v7 = *(uint64_t (**)(unsigned __int8 *, const unsigned __int8 *, _QWORD *, EVP_PKEY *, uint64_t))(v6 + 168)) == 0)
  {
    ERR_put_error(6, 4095, 150, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/pmeth_fn.c", 242);
    return -2;
  }
  if (*((_DWORD *)dec_key + 8) != 512)
  {
    ERR_put_error(6, 4095, 151, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/pmeth_fn.c", 246);
    return -1;
  }
  v8 = v4;
  v10 = *(_QWORD **)&enc_key_len;
  if ((*(_BYTE *)(v6 + 4) & 2) != 0)
  {
    v12 = EVP_PKEY_size(*((EVP_PKEY **)dec_key + 2));
    if (!enc_key)
    {
      *v10 = v12;
      return 1;
    }
    if (*v10 < (unint64_t)v12)
    {
      ERR_put_error(6, 4095, 155, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/pmeth_fn.c", 249);
      return 0;
    }
    v7 = *(uint64_t (**)(unsigned __int8 *, const unsigned __int8 *, _QWORD *, EVP_PKEY *, uint64_t))(*(_QWORD *)dec_key + 168);
  }
  return v7(dec_key, enc_key, v10, private_key, v8);
}

uint64_t EVP_PKEY_derive_init(uint64_t *a1)
{
  uint64_t v2;
  uint64_t (*v3)(uint64_t *);
  uint64_t result;

  if (a1 && (v2 = *a1) != 0 && *(_QWORD *)(v2 + 184))
  {
    *((_DWORD *)a1 + 8) = 1024;
    v3 = *(uint64_t (**)(uint64_t *))(v2 + 176);
    if (v3)
    {
      result = v3(a1);
      if ((int)result <= 0)
        *((_DWORD *)a1 + 8) = 0;
    }
    else
    {
      return 1;
    }
  }
  else
  {
    ERR_put_error(6, 4095, 150, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/pmeth_fn.c", 259);
    return 4294967294;
  }
  return result;
}

uint64_t EVP_PKEY_derive_set_peer(uint64_t a1, const EVP_PKEY *a2)
{
  _QWORD *v3;
  uint64_t (*v5)(uint64_t, uint64_t, _QWORD, const EVP_PKEY *);
  int v6;
  uint64_t v7;
  uint64_t v8;
  int v10;
  int v11;
  _DWORD *v12;
  uint64_t v13;

  if (!a1
    || (v3 = *(_QWORD **)a1) == 0
    || !v3[23] && !v3[19] && !v3[21]
    || (v5 = (uint64_t (*)(uint64_t, uint64_t, _QWORD, const EVP_PKEY *))v3[24]) == 0)
  {
    ERR_put_error(6, 4095, 150, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/pmeth_fn.c", 279);
    return 4294967294;
  }
  v6 = *(_DWORD *)(a1 + 32);
  if (v6 != 256 && v6 != 512 && v6 != 1024)
  {
    v10 = 151;
    v11 = 285;
LABEL_24:
    ERR_put_error(6, 4095, v10, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/pmeth_fn.c", v11);
    return 0xFFFFFFFFLL;
  }
  v7 = v5(a1, 2, 0, a2);
  v8 = v7;
  if ((int)v7 < 1)
    return v8;
  if ((_DWORD)v7 == 2)
    return 1;
  v12 = *(_DWORD **)(a1 + 16);
  if (!v12)
  {
    v10 = 154;
    v11 = 298;
    goto LABEL_24;
  }
  if (*v12 != a2->type)
  {
    v10 = 101;
    v11 = 303;
    goto LABEL_24;
  }
  if (!EVP_PKEY_missing_parameters(a2) && !EVP_PKEY_cmp_parameters(*(const EVP_PKEY **)(a1 + 16), a2))
  {
    v10 = 153;
    v11 = 314;
    goto LABEL_24;
  }
  EVP_PKEY_free(*(EVP_PKEY **)(a1 + 24));
  *(_QWORD *)(a1 + 24) = a2;
  v13 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, const EVP_PKEY *))(*(_QWORD *)a1 + 192))(a1, 2, 1, a2);
  if ((int)v13 <= 0)
  {
    v8 = v13;
    *(_QWORD *)(a1 + 24) = 0;
  }
  else
  {
    v8 = 1;
    CRYPTO_add_lock(&a2->references, 1, 10, 0, 0);
  }
  return v8;
}

uint64_t EVP_PKEY_derive(uint64_t *a1, uint64_t a2, _QWORD *a3)
{
  uint64_t v4;
  uint64_t (*v5)(uint64_t *, uint64_t, _QWORD *);
  int v8;

  if (!a1 || (v4 = *a1) == 0 || (v5 = *(uint64_t (**)(uint64_t *, uint64_t, _QWORD *))(v4 + 184)) == 0)
  {
    ERR_put_error(6, 4095, 150, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/pmeth_fn.c", 336);
    return 4294967294;
  }
  if (*((_DWORD *)a1 + 8) != 1024)
  {
    ERR_put_error(6, 4095, 151, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/pmeth_fn.c", 340);
    return 0xFFFFFFFFLL;
  }
  if ((*(_BYTE *)(v4 + 4) & 2) != 0)
  {
    v8 = EVP_PKEY_size((EVP_PKEY *)a1[2]);
    if (!a2)
    {
      *a3 = v8;
      return 1;
    }
    if (*a3 < (unint64_t)v8)
    {
      ERR_put_error(6, 4095, 155, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/pmeth_fn.c", 343);
      return 0;
    }
    v5 = *(uint64_t (**)(uint64_t *, uint64_t, _QWORD *))(*a1 + 184);
  }
  return v5(a1, a2, a3);
}

uint64_t RSA_bits(uint64_t a1)
{
  return BN_num_bits(*(const BIGNUM **)(a1 + 32));
}

int RSA_size(const RSA *a1)
{
  int v1;
  int v2;

  v1 = BN_num_bits(a1->n);
  v2 = v1 + 7;
  if (v1 < -7)
    v2 = v1 + 14;
  return v2 >> 3;
}

int RSA_public_encrypt(int flen, const unsigned __int8 *from, unsigned __int8 *to, RSA *rsa, int padding)
{
  return ((uint64_t (*)(_QWORD, const unsigned __int8 *, unsigned __int8 *))rsa->meth->rsa_pub_enc)(*(_QWORD *)&flen, from, to);
}

int RSA_private_encrypt(int flen, const unsigned __int8 *from, unsigned __int8 *to, RSA *rsa, int padding)
{
  return ((uint64_t (*)(_QWORD, const unsigned __int8 *, unsigned __int8 *))rsa->meth->rsa_priv_enc)(*(_QWORD *)&flen, from, to);
}

int RSA_private_decrypt(int flen, const unsigned __int8 *from, unsigned __int8 *to, RSA *rsa, int padding)
{
  return ((uint64_t (*)(_QWORD, const unsigned __int8 *, unsigned __int8 *))rsa->meth->rsa_priv_dec)(*(_QWORD *)&flen, from, to);
}

int RSA_public_decrypt(int flen, const unsigned __int8 *from, unsigned __int8 *to, RSA *rsa, int padding)
{
  return ((uint64_t (*)(_QWORD, const unsigned __int8 *, unsigned __int8 *))rsa->meth->rsa_pub_dec)(*(_QWORD *)&flen, from, to);
}

int RSA_flags(const RSA *r)
{
  if (r)
    LODWORD(r) = r->meth->flags;
  return (int)r;
}

void RSA_blinding_off(RSA *rsa)
{
  BN_BLINDING_free((BN_BLINDING *)rsa->bignum_data);
  rsa->bignum_data = 0;
  rsa->flags |= 0x80u;
}

int RSA_blinding_on(RSA *rsa, BN_CTX *ctx)
{
  char *bignum_data;
  char *v5;

  bignum_data = rsa->bignum_data;
  if (bignum_data)
  {
    BN_BLINDING_free((BN_BLINDING *)bignum_data);
    rsa->bignum_data = 0;
    rsa->flags |= 0x80u;
  }
  v5 = (char *)RSA_setup_blinding(rsa, ctx);
  rsa->bignum_data = v5;
  if (v5)
  {
    rsa->flags &= ~0x80u;
    LODWORD(v5) = 1;
  }
  return (int)v5;
}

BN_BLINDING *__cdecl RSA_setup_blinding(RSA *rsa, BN_CTX *ctx)
{
  BN_CTX *v4;
  BIGNUM *e;
  BN_BLINDING *v6;
  BN_BLINDING *v7;
  _QWORD *v8;
  BIGNUM *d;
  BIGNUM *p;
  BIGNUM *q;
  BIGNUM *v12;
  BIGNUM *v13;
  BIGNUM *v14;
  BIGNUM *v15;
  BIGNUM *v16;
  BIGNUM *v17;
  const BIGNUM *v18;
  const BIGNUM *v19;
  BIGNUM m;

  v4 = ctx;
  if (!ctx)
  {
    v4 = BN_CTX_new();
    if (!v4)
      return 0;
  }
  memset(&m, 0, sizeof(m));
  BN_CTX_start(v4);
  e = rsa->e;
  if (e)
    goto LABEL_4;
  d = rsa->d;
  if (d)
  {
    p = rsa->p;
    if (p)
    {
      q = rsa->q;
      if (q)
      {
        BN_CTX_start(v4);
        v12 = BN_CTX_get(v4);
        if (v12
          && (v13 = v12, (v14 = BN_CTX_get(v4)) != 0)
          && (v15 = v14, (v16 = BN_CTX_get(v4)) != 0)
          && (v17 = v16, v18 = BN_value_one(), BN_sub(v15, p, v18))
          && (v19 = BN_value_one(), BN_sub(v17, q, v19))
          && BN_mul(v13, v15, v17, v4))
        {
          e = BN_mod_inverse_ct(0, d, v13, v4);
          BN_CTX_end(v4);
          if (e)
          {
LABEL_4:
            BN_init(&m);
            BN_with_flags((__n128 *)&m, (__n128 *)rsa->n, 4);
            v6 = BN_BLINDING_create_param(0, e, &m, v4, rsa->meth->bn_mod_exp, rsa->_method_mod_n);
            v7 = v6;
            if (v6)
            {
              v8 = (_QWORD *)BN_BLINDING_thread_id((uint64_t)v6);
              CRYPTO_THREADID_current(v8);
            }
            else
            {
              ERR_put_error(4, 4095, 3, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/rsa/rsa_crpt.c", 210);
            }
            goto LABEL_20;
          }
        }
        else
        {
          BN_CTX_end(v4);
        }
      }
    }
  }
  ERR_put_error(4, 4095, 140, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/rsa/rsa_crpt.c", 197);
  e = 0;
  v7 = 0;
LABEL_20:
  BN_CTX_end(v4);
  if (!ctx)
    BN_CTX_free(v4);
  if (!rsa->e)
    BN_free(e);
  return v7;
}

ASN1_VALUE *rsa_pss_params_create(EVP_MD *a1, EVP_MD *a2, int a3)
{
  ASN1_VALUE *v6;
  ASN1_INTEGER *v7;

  v6 = RSA_PSS_PARAMS_new();
  if (!v6)
    goto LABEL_10;
  if (a3 != 20)
  {
    v7 = ASN1_INTEGER_new();
    *((_QWORD *)v6 + 2) = v7;
    if (!v7 || !ASN1_INTEGER_set(v7, a3))
      goto LABEL_10;
  }
  if (!rsa_md_to_algor(v6, a1))
    goto LABEL_10;
  if (!a2)
    a2 = a1;
  if (!rsa_md_to_mgf1((X509_ALGOR **)v6 + 1, a2) || !rsa_md_to_algor((_QWORD *)v6 + 4, a2))
  {
LABEL_10:
    RSA_PSS_PARAMS_free(v6);
    return 0;
  }
  return v6;
}

uint64_t rsa_md_to_algor(_QWORD *a1, EVP_MD *md)
{
  uint64_t result;

  if (!md)
    return 1;
  if (EVP_MD_type(md) != 64)
  {
    result = (uint64_t)X509_ALGOR_new();
    *a1 = result;
    if (!result)
      return result;
    X509_ALGOR_set_md((X509_ALGOR *)result, md);
  }
  return 1;
}

BOOL rsa_md_to_mgf1(X509_ALGOR **a1, EVP_MD *md)
{
  int v5;
  X509_ALGOR *v6;
  X509_ALGOR *v7;
  X509_ALGOR *v8;
  ASN1_OBJECT *v9;
  void *pval;
  void *obj;

  pval = 0;
  obj = 0;
  *a1 = 0;
  if (!md || EVP_MD_type(md) == 64)
    return 1;
  v5 = rsa_md_to_algor(&obj, md);
  v6 = (X509_ALGOR *)obj;
  if (v5 && ASN1_item_pack(obj, &X509_ALGOR_it, (ASN1_OCTET_STRING **)&pval))
  {
    v7 = X509_ALGOR_new();
    *a1 = v7;
    if (v7)
    {
      v8 = v7;
      v9 = OBJ_nid2obj(911);
      X509_ALGOR_set0(v8, v9, 16, pval);
      pval = 0;
    }
  }
  ASN1_STRING_free((ASN1_STRING *)pval);
  X509_ALGOR_free(v6);
  return *a1 != 0;
}

uint64_t rsa_pss_get_param(uint64_t result, uint64_t *a2, uint64_t *a3, _DWORD *a4)
{
  uint64_t v7;
  ASN1_INTEGER *v8;
  int v9;
  int v10;
  int v11;
  ASN1_INTEGER *v12;

  if (result)
  {
    v7 = result;
    result = (uint64_t)rsa_algor_to_md(*(const ASN1_OBJECT ***)result);
    *a2 = result;
    if (result)
    {
      result = (uint64_t)rsa_algor_to_md(*(const ASN1_OBJECT ***)(v7 + 32));
      *a3 = result;
      if (result)
      {
        v8 = *(ASN1_INTEGER **)(v7 + 16);
        if (v8)
        {
          v9 = ASN1_INTEGER_get(v8);
          *a4 = v9;
          if (v9 < 0)
          {
            v10 = 150;
            v11 = 797;
LABEL_11:
            ERR_put_error(4, 4095, v10, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/rsa/rsa_ameth.c", v11);
            return 0;
          }
        }
        else
        {
          *a4 = 20;
        }
        v12 = *(ASN1_INTEGER **)(v7 + 24);
        if (v12)
        {
          result = ASN1_INTEGER_get(v12);
          if (result == 1)
            return result;
          v10 = 139;
          v11 = 809;
          goto LABEL_11;
        }
        return 1;
      }
    }
  }
  return result;
}

const EVP_MD *rsa_algor_to_md(const ASN1_OBJECT **a1)
{
  int v1;
  const char *v2;
  const EVP_MD *result;

  if (!a1)
    return EVP_sha1();
  v1 = OBJ_obj2nid(*a1);
  v2 = OBJ_nid2sn(v1);
  result = EVP_get_digestbyname(v2);
  if (!result)
  {
    ERR_put_error(4, 4095, 166, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/rsa/rsa_ameth.c", 648);
    return 0;
  }
  return result;
}

uint64_t rsa_pub_decode(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  RSA *v4;
  char *v5;
  X509_ALGOR *algor;
  _DWORD len[3];

  memset(len, 0, sizeof(len));
  algor = 0;
  result = X509_PUBKEY_get0_param(0, &len[1], len, &algor, a2);
  if ((_DWORD)result)
  {
    v4 = d2i_RSAPublicKey(0, (const unsigned __int8 **)&len[1], len[0]);
    if (v4)
    {
      v5 = (char *)v4;
      if (rsa_param_decode((uint64_t)v4, algor) && EVP_PKEY_assign((EVP_PKEY *)a1, **(_DWORD **)(a1 + 16), v5))
        return 1;
      RSA_free((RSA *)v5);
    }
    else
    {
      ERR_put_error(4, 4095, 4, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/rsa/rsa_ameth.c", 168);
    }
    return 0;
  }
  return result;
}

uint64_t rsa_pub_encode(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  int v5;
  int v6;
  ASN1_OBJECT *v7;
  int v8;
  ASN1_OCTET_STRING *oct;
  unsigned __int8 *out;

  oct = 0;
  out = 0;
  v8 = 0;
  result = rsa_param_encode(a2, &oct, &v8);
  if ((_DWORD)result)
  {
    v5 = i2d_RSAPublicKey(*(const RSA **)(a2 + 32), &out);
    if (v5 >= 1)
    {
      v6 = v5;
      v7 = OBJ_nid2obj(**(_DWORD **)(a2 + 16));
      if (X509_PUBKEY_set0_param(a1, v7, v8, oct, out, v6))
        return 1;
      free(out);
    }
    return 0;
  }
  return result;
}

BOOL rsa_pub_cmp(uint64_t a1, uint64_t a2)
{
  return !BN_cmp(*(const BIGNUM **)(*(_QWORD *)(a2 + 32) + 32), *(const BIGNUM **)(*(_QWORD *)(a1 + 32) + 32))
      && BN_cmp(*(const BIGNUM **)(*(_QWORD *)(a2 + 32) + 40), *(const BIGNUM **)(*(_QWORD *)(a1 + 32) + 40)) == 0;
}

uint64_t rsa_pub_print(BIO *a1, uint64_t a2, int a3)
{
  return pkey_rsa_print(a1, a2, a3, 0);
}

uint64_t rsa_priv_decode(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  RSA *v4;
  char *v5;
  X509_ALGOR *algor;
  int len[3];

  memset(len, 0, sizeof(len));
  algor = 0;
  result = PKCS8_pkey_get0(0, (unsigned __int8 **)&len[1], len, &algor, a2);
  if ((_DWORD)result)
  {
    v4 = d2i_RSAPrivateKey(0, (const unsigned __int8 **)&len[1], len[0]);
    if (v4)
    {
      v5 = (char *)v4;
      if (rsa_param_decode((uint64_t)v4, algor))
      {
        EVP_PKEY_assign((EVP_PKEY *)a1, **(_DWORD **)(a1 + 16), v5);
        return 1;
      }
      RSA_free((RSA *)v5);
    }
    else
    {
      ERR_put_error(4, 4095, 4, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/rsa/rsa_ameth.c", 251);
    }
    return 0;
  }
  return result;
}

uint64_t rsa_priv_encode(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  int v5;
  int v6;
  ASN1_OBJECT *v7;
  int v8;
  int ptype;
  ASN1_STRING *a;
  unsigned __int8 *out;

  a = 0;
  out = 0;
  ptype = 0;
  result = rsa_param_encode(a2, &a, &ptype);
  if ((_DWORD)result)
  {
    v5 = i2d_RSAPrivateKey(*(const RSA **)(a2 + 32), &out);
    if (v5 < 1)
    {
      v8 = 224;
    }
    else
    {
      v6 = v5;
      v7 = OBJ_nid2obj(**(_DWORD **)(a2 + 16));
      if (PKCS8_pkey_set0(a1, v7, 0, ptype, a, out, v6))
        return 1;
      v8 = 231;
    }
    ERR_put_error(4, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/rsa/rsa_ameth.c", v8);
    ASN1_STRING_free(a);
    return 0;
  }
  return result;
}

uint64_t rsa_priv_print(BIO *a1, uint64_t a2, int a3)
{
  return pkey_rsa_print(a1, a2, a3, 1);
}

uint64_t int_rsa_size(uint64_t a1)
{
  return RSA_size(*(const RSA **)(a1 + 32));
}

uint64_t rsa_bits(uint64_t a1)
{
  return BN_num_bits(*(const BIGNUM **)(*(_QWORD *)(a1 + 32) + 32));
}

uint64_t rsa_security_bits(uint64_t a1)
{
  return RSA_security_bits(*(_QWORD *)(a1 + 32));
}

uint64_t rsa_sig_print(BIO *a1, const ASN1_OBJECT **a2, unsigned int *a3, int a4)
{
  ASN1_VALUE *v8;
  _BOOL4 v9;

  if (OBJ_obj2nid(*a2) == 912)
  {
    v8 = rsa_pss_decode((uint64_t)a2);
    v9 = rsa_pss_param_print(a1, 0, (uint64_t)v8, a4);
    RSA_PSS_PARAMS_free(v8);
    if (v9)
    {
      if (!a3)
        return 1;
      return X509_signature_dump(a1, a3, a4);
    }
    return 0;
  }
  else
  {
    if (a3)
      return X509_signature_dump(a1, a3, a4);
    return BIO_puts(a1, "\n") > 0;
  }
}

void int_rsa_free(uint64_t a1)
{
  RSA_free(*(RSA **)(a1 + 32));
}

uint64_t rsa_pkey_ctrl(uint64_t a1, int a2, uint64_t a3, _QWORD *a4)
{
  uint64_t v4;
  uint64_t v6;
  uint64_t *v7;
  EVP_MD *v8;
  uint64_t *v9;
  ASN1_OBJECT *v10;
  uint64_t *v12;
  int v13;
  int v14;
  int v15;
  uint64_t v16;
  uint64_t *v17;
  int v18;
  ASN1_VALUE *v19;
  ASN1_VALUE *v20;
  uint64_t v21;
  const ASN1_OBJECT **v22;
  uint64_t v24;
  uint64_t v25;
  int v26;
  int v27;
  int v28;
  uint64_t v29;
  EVP_MD *md;
  _QWORD v31[2];
  int v32;
  _QWORD v33[2];
  EVP_MD *v34;
  EVP_MD *v35;

  md = 0;
  v31[0] = 0;
  v29 = 0;
  v28 = 0;
  v4 = 4294967294;
  switch(a2)
  {
    case 1:
      if (!a3)
        PKCS7_SIGNER_INFO_get0_algs(a4, 0, 0, v31);
      goto LABEL_22;
    case 2:
      if (**(_DWORD **)(a1 + 16) == 912)
        return v4;
      if (!a3)
        PKCS7_RECIP_INFO_get0_alg((uint64_t)a4, v31);
      goto LABEL_22;
    case 3:
      v6 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 96);
      if (!v6)
      {
        *(_DWORD *)a4 = 672;
        return 1;
      }
      if (rsa_pss_get_param(v6, (uint64_t *)&md, &v29, &v28))
      {
        *(_DWORD *)a4 = EVP_MD_type(md);
        return 2;
      }
      v14 = 68;
      v15 = 576;
      goto LABEL_43;
    case 5:
      if (a3 != 1)
      {
        if (a3)
          goto LABEL_22;
        LODWORD(v34) = 1;
        v35 = 0;
        v7 = (uint64_t *)CMS_SignerInfo_get0_pkey_ctx((uint64_t)a4);
        CMS_SignerInfo_get0_algs(a4, 0, 0, 0, &v35);
        if (!v7 || (int)RSA_pkey_ctx_ctrl(v7, -1) >= 1)
        {
          v8 = v35;
          goto LABEL_23;
        }
        return 0;
      }
      LODWORD(v34) = 0;
      v35 = 0;
      v12 = (uint64_t *)CMS_SignerInfo_get0_pkey_ctx((uint64_t)a4);
      CMS_SignerInfo_get0_algs(a4, 0, 0, 0, &v35);
      v13 = OBJ_obj2nid(*(const ASN1_OBJECT **)&v35->type);
      if (v13 == 912)
        return rsa_pss_to_ctx(0, v12, (const ASN1_OBJECT **)v35, 0);
      if (*(_DWORD *)*v12 == 912)
      {
        v14 = 144;
        v15 = 830;
LABEL_43:
        ERR_put_error(4, 4095, v14, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/rsa/rsa_ameth.c", v15);
        return 0;
      }
      if (v13 == 6)
        return 1;
      return OBJ_find_sigid_algs(v13, 0, &v34) && (_DWORD)v34 == 6;
    case 7:
      if (**(_DWORD **)(a1 + 16) == 912)
        return v4;
      if (a3 != 1)
      {
        if (a3)
        {
LABEL_22:
          v8 = (EVP_MD *)v31[0];
          if (!v31[0])
            return 1;
LABEL_23:
          v10 = OBJ_nid2obj(6);
          X509_ALGOR_set0((X509_ALGOR *)v8, v10, 5, 0);
          return 1;
        }
        v34 = 0;
        v35 = 0;
        v33[0] = 0;
        v33[1] = 0;
        v9 = (uint64_t *)CMS_RecipientInfo_get0_pkey_ctx((uint64_t)a4);
        v32 = 1;
        v31[1] = 0;
        if ((int)CMS_RecipientInfo_ktri_get0_algs((uint64_t)a4, 0, 0, v33) >= 1
          && (!v9 || (int)RSA_pkey_ctx_ctrl(v9, -1) >= 1))
        {
          v8 = (EVP_MD *)v33[0];
          goto LABEL_23;
        }
        return 0;
      }
      v16 = CMS_RecipientInfo_get0_pkey_ctx((uint64_t)a4);
      if (!v16)
        return 0;
      v17 = (uint64_t *)v16;
      v35 = 0;
      if (!CMS_RecipientInfo_ktri_get0_algs((uint64_t)a4, 0, 0, &v35))
        return 0xFFFFFFFFLL;
      v18 = OBJ_obj2nid(*(const ASN1_OBJECT **)&v35->type);
      if (v18 == 6)
        return 1;
      if (v18 == 919)
      {
        v19 = (ASN1_VALUE *)ASN1_TYPE_unpack_sequence(&RSA_OAEP_PARAMS_it, *(_QWORD *)&v35->md_size);
        if (!v19)
        {
LABEL_40:
          ERR_put_error(4, 4095, 161, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/rsa/rsa_ameth.c", 980);
          v20 = 0;
LABEL_70:
          v4 = 0xFFFFFFFFLL;
LABEL_71:
          RSA_OAEP_PARAMS_free(v20);
          return v4;
        }
        v20 = v19;
        v21 = *((_QWORD *)v19 + 1);
        if (v21)
        {
          v22 = (const ASN1_OBJECT **)rsa_mgf1_decode(v21);
          *((_QWORD *)v20 + 3) = v22;
          if (!v22)
          {
            RSA_OAEP_PARAMS_free(v20);
            goto LABEL_40;
          }
        }
        else
        {
          v22 = (const ASN1_OBJECT **)*((_QWORD *)v20 + 3);
        }
        if (!rsa_algor_to_md(v22) || !rsa_algor_to_md(*(const ASN1_OBJECT ***)v20))
          goto LABEL_70;
        v24 = *((_QWORD *)v20 + 2);
        if (v24)
        {
          if (OBJ_obj2nid(*(const ASN1_OBJECT **)v24) == 992)
          {
            v25 = *(_QWORD *)(v24 + 8);
            if (*(_DWORD *)v25 == 4)
            {
              *(_QWORD *)(*(_QWORD *)(v25 + 8) + 8) = 0;
              goto LABEL_61;
            }
            v26 = 160;
            v27 = 999;
          }
          else
          {
            v26 = 163;
            v27 = 995;
          }
          ERR_put_error(4, 4095, v26, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/rsa/rsa_ameth.c", v27);
          goto LABEL_70;
        }
LABEL_61:
        v4 = 0xFFFFFFFFLL;
        if ((int)RSA_pkey_ctx_ctrl(v17, -1) >= 1
          && (int)EVP_PKEY_CTX_ctrl(v17, 6, 768) >= 1
          && (int)RSA_pkey_ctx_ctrl(v17, 1016) >= 1)
        {
          if ((int)EVP_PKEY_CTX_ctrl(v17, 6, 768) < 1)
            v4 = 0xFFFFFFFFLL;
          else
            v4 = 1;
        }
        goto LABEL_71;
      }
      ERR_put_error(4, 4095, 162, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/rsa/rsa_ameth.c", 973);
      return 0xFFFFFFFFLL;
    case 8:
      if (**(_DWORD **)(a1 + 16) == 912)
        return v4;
      *(_DWORD *)a4 = 0;
      return 1;
    default:
      return v4;
  }
}

uint64_t old_rsa_priv_decode(uint64_t a1, const unsigned __int8 **a2, int a3)
{
  char *v4;

  v4 = (char *)d2i_RSAPrivateKey(0, a2, a3);
  if (v4)
  {
    EVP_PKEY_assign((EVP_PKEY *)a1, **(_DWORD **)(a1 + 16), v4);
    return 1;
  }
  else
  {
    ERR_put_error(4, 4095, 4, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/rsa/rsa_ameth.c", 198);
    return 0;
  }
}

uint64_t old_rsa_priv_encode(uint64_t a1, unsigned __int8 **a2)
{
  return i2d_RSAPrivateKey(*(const RSA **)(a1 + 32), a2);
}

uint64_t rsa_item_verify(uint64_t a1, uint64_t a2, uint64_t a3, const ASN1_OBJECT **a4, uint64_t a5, uint64_t a6)
{
  if (OBJ_obj2nid(*a4) == 912)
  {
    if ((int)rsa_pss_to_ctx(a1, 0, a4, a6) <= 0)
      return 0xFFFFFFFFLL;
    else
      return 2;
  }
  else
  {
    ERR_put_error(4, 4095, 155, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/rsa/rsa_ameth.c", 854);
    return 0xFFFFFFFFLL;
  }
}

uint64_t rsa_item_sign(uint64_t a1)
{
  if ((int)RSA_pkey_ctx_ctrl(*(uint64_t **)(a1 + 32), -1) < 1)
    return 0;
  else
    return 2;
}

uint64_t rsa_pkey_check(uint64_t a1)
{
  return RSA_check_key(*(const RSA **)(a1 + 32));
}

BOOL rsa_param_decode(uint64_t a1, X509_ALGOR *algor)
{
  ASN1_VALUE *v4;
  int pptype;
  void *ppval;
  ASN1_OBJECT *paobj;

  ppval = 0;
  paobj = 0;
  pptype = 0;
  X509_ALGOR_get0(&paobj, &pptype, &ppval, algor);
  if (OBJ_obj2nid(paobj) != 912 || pptype == -1)
    return 1;
  if (pptype == 16)
  {
    v4 = rsa_pss_decode((uint64_t)algor);
    *(_QWORD *)(a1 + 96) = v4;
    return v4 != 0;
  }
  else
  {
    ERR_put_error(4, 4095, 149, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/rsa/rsa_ameth.c", 126);
    return 0;
  }
}

ASN1_VALUE *rsa_pss_decode(uint64_t a1)
{
  ASN1_VALUE *v1;
  ASN1_VALUE *v2;
  uint64_t v3;
  void *v4;

  v1 = (ASN1_VALUE *)ASN1_TYPE_unpack_sequence(&RSA_PSS_PARAMS_it, *(_QWORD *)(a1 + 8));
  v2 = v1;
  if (v1)
  {
    v3 = *((_QWORD *)v1 + 1);
    if (v3)
    {
      v4 = rsa_mgf1_decode(v3);
      *((_QWORD *)v2 + 4) = v4;
      if (!v4)
      {
        RSA_PSS_PARAMS_free(v2);
        return 0;
      }
    }
  }
  return v2;
}

void *rsa_mgf1_decode(uint64_t a1)
{
  if (OBJ_obj2nid(*(const ASN1_OBJECT **)a1) == 911)
    return ASN1_TYPE_unpack_sequence((ASN1_ITEM *)&X509_ALGOR_it, *(_QWORD *)(a1 + 8));
  else
    return 0;
}

uint64_t rsa_param_encode(uint64_t a1, ASN1_OCTET_STRING **oct, int *a3)
{
  uint64_t v4;
  void *v5;
  uint64_t result;
  int v7;

  v4 = *(_QWORD *)(a1 + 32);
  *oct = 0;
  if (**(_DWORD **)(a1 + 16) == 912)
  {
    v5 = *(void **)(v4 + 96);
    if (v5)
    {
      result = (uint64_t)ASN1_item_pack(v5, &RSA_PSS_PARAMS_it, oct);
      if (!result)
        return result;
      v7 = 16;
    }
    else
    {
      v7 = -1;
    }
  }
  else
  {
    v7 = 5;
  }
  *a3 = v7;
  return 1;
}

uint64_t pkey_rsa_print(BIO *a1, uint64_t a2, int a3, int a4)
{
  uint64_t v8;
  const BIGNUM *v9;
  int v10;
  int v11;
  int v12;
  unint64_t v13;
  const BIGNUM *v14;
  int v15;
  int v16;
  int v17;
  uint64_t v18;
  const BIGNUM *v19;
  int v20;
  int v21;
  int v22;
  uint64_t v23;
  const BIGNUM *v24;
  int v25;
  int v26;
  int v27;
  uint64_t v28;
  const BIGNUM *v29;
  int v30;
  int v31;
  int v32;
  uint64_t v33;
  const BIGNUM *v34;
  int v35;
  int v36;
  int v37;
  uint64_t v38;
  const BIGNUM *v39;
  int v40;
  int v41;
  int v42;
  uint64_t v43;
  const BIGNUM *v44;
  int v45;
  int v46;
  int v47;
  uint64_t v48;
  unsigned __int8 *v49;
  const BIGNUM *v50;
  int v51;
  const char *v52;
  const char *v53;
  const char *v54;
  uint64_t v55;

  v8 = *(_QWORD *)(a2 + 32);
  v9 = *(const BIGNUM **)(v8 + 32);
  if (v9)
  {
    v10 = BN_num_bits(v9);
    v11 = v10 + 7;
    if (v10 < -7)
      v11 = v10 + 14;
    v12 = v11 >> 3;
    if ((v10 + 14) < 0xF)
      v12 = 0;
    v13 = v12;
  }
  else
  {
    v13 = 0;
  }
  v14 = *(const BIGNUM **)(v8 + 40);
  if (v14)
  {
    v15 = BN_num_bits(v14);
    v16 = v15 + 7;
    if (v15 < -7)
      v16 = v15 + 14;
    v17 = v16 >> 3;
    v18 = (uint64_t)v16 >> 3;
    if (v13 <= v17)
      v13 = v18;
  }
  if (a4)
  {
    v19 = *(const BIGNUM **)(v8 + 48);
    if (v19)
    {
      v20 = BN_num_bits(v19);
      v21 = v20 + 7;
      if (v20 < -7)
        v21 = v20 + 14;
      v22 = v21 >> 3;
      v23 = (uint64_t)v21 >> 3;
      if (v13 <= v22)
        v13 = v23;
    }
    v24 = *(const BIGNUM **)(v8 + 56);
    if (v24)
    {
      v25 = BN_num_bits(v24);
      v26 = v25 + 7;
      if (v25 < -7)
        v26 = v25 + 14;
      v27 = v26 >> 3;
      v28 = (uint64_t)v26 >> 3;
      if (v13 <= v27)
        v13 = v28;
    }
    v29 = *(const BIGNUM **)(v8 + 64);
    if (v29)
    {
      v30 = BN_num_bits(v29);
      v31 = v30 + 7;
      if (v30 < -7)
        v31 = v30 + 14;
      v32 = v31 >> 3;
      v33 = (uint64_t)v31 >> 3;
      if (v13 <= v32)
        v13 = v33;
    }
    v34 = *(const BIGNUM **)(v8 + 72);
    if (v34)
    {
      v35 = BN_num_bits(v34);
      v36 = v35 + 7;
      if (v35 < -7)
        v36 = v35 + 14;
      v37 = v36 >> 3;
      v38 = (uint64_t)v36 >> 3;
      if (v13 <= v37)
        v13 = v38;
    }
    v39 = *(const BIGNUM **)(v8 + 80);
    if (v39)
    {
      v40 = BN_num_bits(v39);
      v41 = v40 + 7;
      if (v40 < -7)
        v41 = v40 + 14;
      v42 = v41 >> 3;
      v43 = (uint64_t)v41 >> 3;
      if (v13 <= v42)
        v13 = v43;
    }
    v44 = *(const BIGNUM **)(v8 + 88);
    if (v44)
    {
      v45 = BN_num_bits(v44);
      v46 = v45 + 7;
      if (v45 < -7)
        v46 = v45 + 14;
      v47 = v46 >> 3;
      v48 = (uint64_t)v46 >> 3;
      if (v13 <= v47)
        v13 = v48;
    }
  }
  v49 = (unsigned __int8 *)malloc_type_malloc(v13 + 10, 0xD5BF1E8EuLL);
  if (!v49)
  {
    ERR_put_error(4, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/rsa/rsa_ameth.c", 446);
    goto LABEL_72;
  }
  v50 = *(const BIGNUM **)(v8 + 32);
  if (v50)
    v51 = BN_num_bits(v50);
  else
    v51 = 0;
  if (!BIO_indent(a1, a3, 128))
    goto LABEL_72;
  v52 = **(_DWORD **)(a2 + 16) == 912 ? "RSA-PSS" : "RSA";
  if (BIO_printf(a1, "%s ", v52) < 1)
    goto LABEL_72;
  if (a4 && *(_QWORD *)(v8 + 48))
  {
    if (BIO_printf(a1, "Private-Key: (%d bit)\n", v51) >= 1)
    {
      v53 = "publicExponent:";
      v54 = "modulus:";
      goto LABEL_60;
    }
LABEL_72:
    v55 = 0;
    goto LABEL_73;
  }
  if (BIO_printf(a1, "Public-Key: (%d bit)\n", v51) < 1)
    goto LABEL_72;
  v53 = "Exponent:";
  v54 = "Modulus:";
LABEL_60:
  if (!ASN1_bn_print(a1, v54, *(const BIGNUM **)(v8 + 32), v49, a3)
    || !ASN1_bn_print(a1, v53, *(const BIGNUM **)(v8 + 40), v49, a3)
    || a4
    && (!ASN1_bn_print(a1, "privateExponent:", *(const BIGNUM **)(v8 + 48), v49, a3)
     || !ASN1_bn_print(a1, "prime1:", *(const BIGNUM **)(v8 + 56), v49, a3)
     || !ASN1_bn_print(a1, "prime2:", *(const BIGNUM **)(v8 + 64), v49, a3)
     || !ASN1_bn_print(a1, "exponent1:", *(const BIGNUM **)(v8 + 72), v49, a3)
     || !ASN1_bn_print(a1, "exponent2:", *(const BIGNUM **)(v8 + 80), v49, a3)
     || !ASN1_bn_print(a1, "coefficient:", *(const BIGNUM **)(v8 + 88), v49, a3))
    || **(_DWORD **)(a2 + 16) == 912 && !rsa_pss_param_print(a1, 1, *(_QWORD *)(v8 + 96), a3))
  {
    goto LABEL_72;
  }
  v55 = 1;
LABEL_73:
  free(v49);
  return v55;
}

BOOL rsa_pss_param_print(BIO *a1, int a2, uint64_t a3, int indent)
{
  uint64_t v8;
  int v9;
  int v10;
  const char *v11;
  ASN1_OBJECT **v12;
  ASN1_OBJECT **v13;
  X509_ALGOR *v14;
  int v15;
  const char *v17;
  ASN1_INTEGER *v18;
  int v19;
  ASN1_INTEGER *v20;
  int v21;

  if (!BIO_indent(a1, indent, 128))
    goto LABEL_28;
  if (!a2)
  {
    if (a3)
      goto LABEL_7;
    v11 = "(INVALID PSS PARAMETERS)\n";
    return BIO_puts(a1, v11) > 0;
  }
  if (!a3)
  {
    v11 = "No PSS parameter restrictions\n";
    return BIO_puts(a1, v11) > 0;
  }
  if (BIO_puts(a1, "PSS parameter restrictions:") >= 1)
  {
LABEL_7:
    if (BIO_puts(a1, "\n") >= 1)
    {
      v9 = a2 ? indent + 2 : indent;
      if (BIO_indent(a1, v9, 128) && BIO_puts(a1, "Hash Algorithm: ") >= 1)
      {
        v10 = *(_QWORD *)a3 ? i2a_ASN1_OBJECT(a1, **(ASN1_OBJECT ***)a3) : BIO_puts(a1, "sha1 (default)");
        if (v10 >= 1 && BIO_puts(a1, "\n") >= 1 && BIO_indent(a1, v9, 128) && BIO_puts(a1, "Mask Algorithm: ") >= 1)
        {
          v12 = *(ASN1_OBJECT ***)(a3 + 8);
          if (!v12)
          {
            v15 = BIO_puts(a1, "mgf1 with sha1 (default)");
            v14 = 0;
            if (v15 < 1)
              goto LABEL_49;
            BIO_puts(a1, "\n");
            if (!BIO_indent(a1, v9, 128))
              goto LABEL_49;
LABEL_32:
            v17 = "Minimum";
            if (!a2)
              v17 = "";
            if (BIO_printf(a1, "%s Salt Length: 0x", v17) >= 1
              && ((v18 = *(ASN1_INTEGER **)(a3 + 16)) == 0
                ? (v19 = BIO_puts(a1, "14 (default)"))
                : (v19 = i2a_ASN1_INTEGER(a1, v18)),
                  v19 >= 1
               && (BIO_puts(a1, "\n"), BIO_indent(a1, v9, 128))
               && BIO_puts(a1, "Trailer Field: 0x") >= 1
               && ((v20 = *(ASN1_INTEGER **)(a3 + 24)) == 0
                 ? (v21 = BIO_puts(a1, "BC (default)"))
                 : (v21 = i2a_ASN1_INTEGER(a1, v20)),
                   v21 >= 1)))
            {
              BIO_puts(a1, "\n");
              v8 = 1;
            }
            else
            {
LABEL_49:
              v8 = 0;
            }
            goto LABEL_29;
          }
          if (i2a_ASN1_OBJECT(a1, *v12) >= 1 && BIO_puts(a1, " with ") >= 1)
          {
            v13 = (ASN1_OBJECT **)rsa_mgf1_decode(*(_QWORD *)(a3 + 8));
            v14 = (X509_ALGOR *)v13;
            if (v13)
              v15 = i2a_ASN1_OBJECT(a1, *v13);
            else
              v15 = BIO_puts(a1, "INVALID");
            goto LABEL_32;
          }
        }
      }
    }
LABEL_28:
    v8 = 0;
    v14 = 0;
LABEL_29:
    X509_ALGOR_free(v14);
    return v8;
  }
  return 0;
}

ASN1_STRING *rsa_ctx_to_pss_string(uint64_t *a1)
{
  ASN1_VALUE *v2;
  ASN1_VALUE *v3;
  ASN1_STRING *v4;

  EVP_PKEY_CTX_get0_pkey((uint64_t)a1);
  if ((int)EVP_PKEY_CTX_ctrl(a1, -1, 248) < 1)
    return 0;
  if ((int)RSA_pkey_ctx_ctrl(a1, 1016) < 1)
    return 0;
  if (!RSA_pkey_ctx_ctrl(a1, 24))
    return 0;
  v2 = rsa_pss_params_create(0, 0, 0);
  if (!v2)
    return 0;
  v3 = v2;
  v4 = ASN1_item_pack(v2, &RSA_PSS_PARAMS_it, 0);
  RSA_PSS_PARAMS_free(v3);
  return v4;
}

uint64_t rsa_pss_to_ctx(uint64_t a1, uint64_t *a2, const ASN1_OBJECT **a3, uint64_t a4)
{
  uint64_t *v6;
  ASN1_VALUE *v8;
  uint64_t v9;
  int v10;
  int v11;
  int v13;
  EVP_MD *md;
  uint64_t v15;
  int v16;
  uint64_t *v17;

  v6 = a2;
  v17 = a2;
  md = 0;
  v15 = 0;
  if (OBJ_obj2nid(*a3) == 912)
  {
    v16 = 0;
    v8 = rsa_pss_decode((uint64_t)a3);
    if (rsa_pss_get_param((uint64_t)v8, (uint64_t *)&md, &v15, &v16))
    {
      if (a4)
      {
        if (EVP_DigestVerifyInit(a1, &v17, md, 0, a4))
        {
          v6 = v17;
LABEL_14:
          v9 = 0xFFFFFFFFLL;
          if ((int)RSA_pkey_ctx_ctrl(v6, -1) >= 1 && (int)RSA_pkey_ctx_ctrl(v17, 24) >= 1)
          {
            if ((int)RSA_pkey_ctx_ctrl(v17, 1016) < 1)
              v9 = 0xFFFFFFFFLL;
            else
              v9 = 1;
          }
          goto LABEL_10;
        }
LABEL_9:
        v9 = 0xFFFFFFFFLL;
LABEL_10:
        RSA_PSS_PARAMS_free(v8);
        return v9;
      }
      if ((int)EVP_PKEY_CTX_ctrl(v6, -1, 248) < 1)
        goto LABEL_9;
      v13 = EVP_MD_type(md);
      if (v13 == EVP_MD_type(0))
        goto LABEL_14;
      v10 = 158;
      v11 = 761;
    }
    else
    {
      v10 = 149;
      v11 = 748;
    }
    ERR_put_error(4, 4095, v10, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/rsa/rsa_ameth.c", v11);
    goto LABEL_9;
  }
  ERR_put_error(4, 4095, 155, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/rsa/rsa_ameth.c", 741);
  return 0xFFFFFFFFLL;
}

ASN1_VALUE *d2i_CMS_ContentInfo(ASN1_VALUE **a1, const unsigned __int8 **a2, uint64_t a3)
{
  return ASN1_item_d2i(a1, a2, a3, &CMS_ContentInfo_it);
}

uint64_t i2d_CMS_ContentInfo(ASN1_VALUE *a1, unsigned __int8 **a2)
{
  return ASN1_item_i2d(a1, a2, &CMS_ContentInfo_it);
}

ASN1_VALUE *CMS_ContentInfo_new()
{
  return ASN1_item_new(&CMS_ContentInfo_it);
}

void CMS_ContentInfo_free(ASN1_VALUE *a1)
{
  ASN1_item_free(a1, &CMS_ContentInfo_it);
}

uint64_t CMS_ContentInfo_print_ctx(BIO *a1, ASN1_VALUE *a2, uint64_t a3, uint64_t *a4)
{
  return ASN1_item_print(a1, a2, a3, &CMS_ContentInfo_it, a4);
}

uint64_t CMS_get0_type(uint64_t a1)
{
  return *(_QWORD *)a1;
}

ASN1_VALUE *cms_Data_create()
{
  ASN1_VALUE *v0;

  v0 = ASN1_item_new(&CMS_ContentInfo_it);
  if (v0)
  {
    *(_QWORD *)v0 = OBJ_nid2obj(21);
    CMS_set_detached((uint64_t)v0, 0);
  }
  return v0;
}

uint64_t CMS_set_detached(uint64_t a1, int a2)
{
  uint64_t result;
  ASN1_OCTET_STRING **v4;
  ASN1_OCTET_STRING *v5;

  result = (uint64_t)CMS_get0_content(a1);
  if (result)
  {
    v4 = (ASN1_OCTET_STRING **)result;
    v5 = *(ASN1_OCTET_STRING **)result;
    if (a2)
    {
      ASN1_OCTET_STRING_free(v5);
      *v4 = 0;
    }
    else
    {
      if (!v5)
      {
        v5 = ASN1_OCTET_STRING_new();
        *v4 = v5;
        if (!v5)
        {
          ERR_put_error(46, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/cms/cms_lib.c", 375);
          return 0;
        }
      }
      v5->flags |= 0x20uLL;
    }
    return 1;
  }
  return result;
}

BIO *cms_content_bio(uint64_t a1)
{
  BIO *result;
  BIO_METHOD *method;
  BIO_METHOD *v3;

  result = (BIO *)CMS_get0_content(a1);
  if (result)
  {
    method = result->method;
    if (!result->method)
    {
      v3 = BIO_s_null();
      return BIO_new(v3);
    }
    if (method->bwrite == (int (__cdecl *)(BIO *, const char *, int))32)
    {
      v3 = BIO_s_mem();
      return BIO_new(v3);
    }
    return BIO_new_mem_buf((void *)method->name, method->type);
  }
  return result;
}

_DWORD *CMS_get0_content(uint64_t a1)
{
  int v2;
  _DWORD *v3;
  uint64_t v5;

  v2 = OBJ_obj2nid(*(const ASN1_OBJECT **)a1);
  switch(v2)
  {
    case 21:
      return (_DWORD *)(a1 + 8);
    case 22:
    case 25:
      v3 = *(_DWORD **)(*(_QWORD *)(a1 + 8) + 16);
      return v3 + 2;
    case 23:
      v5 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 24);
      return (_DWORD *)(v5 + 16);
    case 24:
      goto LABEL_6;
    case 26:
      v5 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8);
      return (_DWORD *)(v5 + 16);
    default:
      if (v2 == 205)
      {
        v3 = *(_DWORD **)(*(_QWORD *)(a1 + 8) + 40);
      }
      else if (v2 == 786)
      {
        v3 = *(_DWORD **)(*(_QWORD *)(a1 + 8) + 24);
      }
      else
      {
LABEL_6:
        v3 = *(_DWORD **)(a1 + 8);
        if (*v3 != 4)
        {
          ERR_put_error(46, 4095, 152, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/cms/cms_lib.c", 270);
          return 0;
        }
      }
      return v3 + 2;
  }
}

BIO *CMS_dataInit(const ASN1_OBJECT **a1, BIO *a2)
{
  BIO *v4;
  BIO *inited;

  v4 = a2;
  if (a2 || (v4 = cms_content_bio((uint64_t)a1)) != 0)
  {
    switch(OBJ_obj2nid(*a1))
    {
      case 21:
        return v4;
      case 22:
        inited = cms_SignedData_init_bio((uint64_t)a1);
        if (!inited)
          goto LABEL_12;
        return BIO_push(inited, v4);
      case 23:
        inited = cms_EnvelopedData_init_bio((uint64_t)a1);
        if (!inited)
          goto LABEL_12;
        return BIO_push(inited, v4);
      case 25:
        inited = cms_DigestedData_init_bio((uint64_t)a1);
        if (inited)
          return BIO_push(inited, v4);
        goto LABEL_12;
      case 26:
        inited = cms_EncryptedData_init_bio((uint64_t)a1);
        if (inited)
          return BIO_push(inited, v4);
LABEL_12:
        if (!a2)
          BIO_free(v4);
LABEL_14:
        v4 = 0;
        break;
      default:
        ERR_put_error(46, 4095, 156, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/cms/cms_lib.c", 178);
        goto LABEL_14;
    }
  }
  else
  {
    ERR_put_error(46, 4095, 127, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/cms/cms_lib.c", 148);
  }
  return v4;
}

uint64_t CMS_dataFinal(const ASN1_OBJECT **a1, BIO *a2)
{
  uint64_t result;
  ASN1_STRING **v5;
  BIO *type;
  BIO *v7;
  int v8;
  int v9;
  int v10;
  int v11;
  void *parg;

  result = (uint64_t)CMS_get0_content((uint64_t)a1);
  if (result)
  {
    v5 = (ASN1_STRING **)result;
    if (*(_QWORD *)result && (*(_BYTE *)(*(_QWORD *)result + 16) & 0x20) != 0)
    {
      parg = 0;
      type = BIO_find_type(a2, 1025);
      if (!type)
      {
        v10 = 105;
        v11 = 205;
LABEL_11:
        ERR_put_error(46, 4095, v10, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/cms/cms_lib.c", v11);
        return 0;
      }
      v7 = type;
      v8 = BIO_ctrl(type, 3, 0, &parg);
      BIO_set_flags(v7, 512);
      BIO_ctrl(v7, 130, 0, 0);
      ASN1_STRING_set0(*v5, parg, v8);
      (*v5)->flags &= ~0x20uLL;
    }
    v9 = OBJ_obj2nid(*a1);
    result = 1;
    switch(v9)
    {
      case 21:
      case 23:
      case 26:
        return result;
      case 22:
        return cms_SignedData_final((uint64_t)a1, a2);
      case 24:
        goto LABEL_9;
      case 25:
        return cms_DigestedData_do_final((uint64_t)a1, a2, 0);
      default:
        if (v9 == 786)
          return result;
LABEL_9:
        v10 = 156;
        v11 = 232;
        break;
    }
    goto LABEL_11;
  }
  return result;
}

uint64_t CMS_get0_eContentType(uint64_t a1)
{
  uint64_t result;

  result = cms_get0_econtent_type(a1);
  if (result)
    return *(_QWORD *)result;
  return result;
}

uint64_t cms_get0_econtent_type(uint64_t a1)
{
  int v2;

  v2 = OBJ_obj2nid(*(const ASN1_OBJECT **)a1);
  switch(v2)
  {
    case 22:
    case 25:
      return *(_QWORD *)(*(_QWORD *)(a1 + 8) + 16);
    case 23:
      return *(_QWORD *)(*(_QWORD *)(a1 + 8) + 24);
    case 24:
      goto LABEL_6;
    case 26:
      return *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8);
    default:
      if (v2 == 205)
        return *(_QWORD *)(*(_QWORD *)(a1 + 8) + 40);
      if (v2 == 786)
        return *(_QWORD *)(*(_QWORD *)(a1 + 8) + 24);
LABEL_6:
      ERR_put_error(46, 4095, 152, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/cms/cms_lib.c", 303);
      return 0;
  }
}

uint64_t CMS_set1_eContentType(uint64_t a1, const ASN1_OBJECT *a2)
{
  uint64_t result;
  ASN1_OBJECT **v4;
  ASN1_OBJECT *v5;

  result = cms_get0_econtent_type(a1);
  if (result)
  {
    if (a2)
    {
      v4 = (ASN1_OBJECT **)result;
      result = (uint64_t)OBJ_dup(a2);
      if (!result)
        return result;
      v5 = (ASN1_OBJECT *)result;
      ASN1_OBJECT_free(*v4);
      *v4 = v5;
    }
    return 1;
  }
  return result;
}

uint64_t CMS_is_detached(uint64_t a1)
{
  _DWORD *v1;

  v1 = CMS_get0_content(a1);
  if (v1)
    return *(_QWORD *)v1 == 0;
  else
    return 0xFFFFFFFFLL;
}

BIO *cms_DigestAlgorithm_init_bio(X509_ALGOR *algor)
{
  int v1;
  const char *v2;
  const EVP_MD *digestbyname;
  EVP_MD *v4;
  BIO_METHOD *v5;
  BIO *v6;
  BIO *v7;
  ASN1_OBJECT *paobj;

  paobj = 0;
  X509_ALGOR_get0(&paobj, 0, 0, algor);
  v1 = OBJ_obj2nid(paobj);
  v2 = OBJ_nid2sn(v1);
  digestbyname = EVP_get_digestbyname(v2);
  if (!digestbyname)
  {
    ERR_put_error(46, 4095, 149, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/cms/cms_lib.c", 392);
    v7 = 0;
    goto LABEL_6;
  }
  v4 = (EVP_MD *)digestbyname;
  v5 = BIO_f_md();
  v6 = BIO_new(v5);
  v7 = v6;
  if (!v6 || !BIO_ctrl(v6, 111, 0, v4))
  {
    ERR_put_error(46, 4095, 119, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/cms/cms_lib.c", 397);
LABEL_6:
    BIO_free(v7);
    return 0;
  }
  return v7;
}

uint64_t cms_DigestAlgorithm_find_ctx(EVP_MD_CTX *a1, BIO *a2, X509_ALGOR *algor)
{
  int v5;
  BIO *type;
  BIO *v7;
  const EVP_MD *v8;
  const EVP_MD *v9;
  BIO *v10;
  EVP_MD_CTX *ctx;
  ASN1_OBJECT *paobj;

  paobj = 0;
  X509_ALGOR_get0(&paobj, 0, 0, algor);
  v5 = OBJ_obj2nid(paobj);
  ctx = 0;
  type = BIO_find_type(a2, 520);
  if (type)
  {
    v7 = type;
    while (1)
    {
      BIO_ctrl(v7, 120, 0, &ctx);
      v8 = EVP_MD_CTX_md(ctx);
      if (EVP_MD_type(v8) == v5)
        break;
      v9 = EVP_MD_CTX_md(ctx);
      if (EVP_MD_pkey_type(v9) == v5)
        break;
      v10 = BIO_next(v7);
      ctx = 0;
      v7 = BIO_find_type(v10, 520);
      if (!v7)
        goto LABEL_6;
    }
    return EVP_MD_CTX_copy_ex(a1, ctx);
  }
  else
  {
LABEL_6:
    ERR_put_error(46, 4095, 131, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/cms/cms_lib.c", 423);
    return 0;
  }
}

ASN1_VALUE *CMS_add0_CertificateChoices(uint64_t a1)
{
  STACK **v1;
  STACK **v2;
  STACK *v3;
  ASN1_VALUE *v4;

  v1 = (STACK **)cms_get0_certificate_choices(a1);
  if (!v1)
    return 0;
  v2 = v1;
  if (!*v1)
  {
    v3 = sk_new_null();
    *v2 = v3;
    if (!v3)
      return 0;
  }
  v4 = ASN1_item_new(&CMS_CertificateChoices_it);
  if (v4 && !sk_push(*v2, (char *)v4))
  {
    ASN1_item_free(v4, &CMS_CertificateChoices_it);
    return 0;
  }
  return v4;
}

uint64_t cms_get0_certificate_choices(uint64_t a1)
{
  int v2;

  v2 = OBJ_obj2nid(*(const ASN1_OBJECT **)a1);
  if (v2 == 23)
    return *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8);
  if (v2 == 22)
    return *(_QWORD *)(a1 + 8) + 24;
  ERR_put_error(46, 4095, 152, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/cms/cms_lib.c", 451);
  return 0;
}

uint64_t CMS_add0_cert(uint64_t a1, const X509 *a2)
{
  uint64_t result;
  const STACK **v5;
  int v6;
  char *v7;

  result = cms_get0_certificate_choices(a1);
  if (result)
  {
    v5 = (const STACK **)result;
    if (sk_num(*(const STACK **)result) < 1)
    {
LABEL_7:
      result = (uint64_t)CMS_add0_CertificateChoices(a1);
      if (result)
      {
        *(_DWORD *)result = 0;
        *(_QWORD *)(result + 8) = a2;
        return 1;
      }
    }
    else
    {
      v6 = 0;
      while (1)
      {
        v7 = sk_value(*v5, v6);
        if (!*(_DWORD *)v7 && !X509_cmp(*((const X509 **)v7 + 1), a2))
          break;
        if (++v6 >= sk_num(*v5))
          goto LABEL_7;
      }
      ERR_put_error(46, 4095, 175, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/cms/cms_lib.c", 494);
      return 0;
    }
  }
  return result;
}

uint64_t CMS_add1_cert(uint64_t a1, const X509 *a2)
{
  uint64_t v3;

  v3 = CMS_add0_cert(a1, a2);
  if ((_DWORD)v3)
    X509_up_ref((uint64_t)a2);
  return v3;
}

ASN1_VALUE *CMS_add0_RevocationInfoChoice(uint64_t a1)
{
  STACK **v1;
  STACK **v2;
  STACK *v3;
  ASN1_VALUE *v4;

  v1 = (STACK **)cms_get0_revocation_choices(a1);
  if (!v1)
    return 0;
  v2 = v1;
  if (!*v1)
  {
    v3 = sk_new_null();
    *v2 = v3;
    if (!v3)
      return 0;
  }
  v4 = ASN1_item_new(&CMS_RevocationInfoChoice_it);
  if (v4 && !sk_push(*v2, (char *)v4))
  {
    ASN1_item_free(v4, &CMS_RevocationInfoChoice_it);
    return 0;
  }
  return v4;
}

uint64_t cms_get0_revocation_choices(uint64_t a1)
{
  int v2;
  uint64_t v4;

  v2 = OBJ_obj2nid(*(const ASN1_OBJECT **)a1);
  if (v2 == 23)
  {
    v4 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8);
    if (v4)
      return v4 + 8;
    else
      return 0;
  }
  else if (v2 == 22)
  {
    return *(_QWORD *)(a1 + 8) + 32;
  }
  else
  {
    ERR_put_error(46, 4095, 152, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/cms/cms_lib.c", 533);
    return 0;
  }
}

ASN1_VALUE *CMS_add0_crl(uint64_t a1, uint64_t a2)
{
  ASN1_VALUE *result;

  result = CMS_add0_RevocationInfoChoice(a1);
  if (result)
  {
    *(_DWORD *)result = 0;
    *((_QWORD *)result + 1) = a2;
    return (ASN1_VALUE *)1;
  }
  return result;
}

ASN1_VALUE *CMS_add1_crl(uint64_t a1, uint64_t a2)
{
  ASN1_VALUE *result;

  result = CMS_add0_RevocationInfoChoice(a1);
  if (result)
  {
    *(_DWORD *)result = 0;
    *((_QWORD *)result + 1) = a2;
    X509_CRL_up_ref(a2);
    return (ASN1_VALUE *)1;
  }
  return result;
}

STACK *CMS_get1_certs(uint64_t a1)
{
  const STACK **v1;
  const STACK **v2;
  int v3;
  STACK *v4;
  char *v5;
  char *v6;

  v1 = (const STACK **)cms_get0_certificate_choices(a1);
  if (!v1)
    return 0;
  v2 = v1;
  if (sk_num(*v1) < 1)
    return 0;
  v3 = 0;
  v4 = 0;
  while (1)
  {
    v5 = sk_value(*v2, v3);
    if (!*(_DWORD *)v5)
      break;
LABEL_9:
    if (++v3 >= sk_num(*v2))
      return v4;
  }
  v6 = v5;
  if (!v4)
  {
    v4 = sk_new_null();
    if (!v4)
      return v4;
  }
  if (sk_push(v4, *((char **)v6 + 1)))
  {
    X509_up_ref(*((_QWORD *)v6 + 1));
    goto LABEL_9;
  }
  sk_pop_free(v4, (void (__cdecl *)(void *))X509_free);
  return 0;
}

STACK *CMS_get1_crls(uint64_t a1)
{
  const STACK **v1;
  const STACK **v2;
  int v3;
  STACK *v4;
  char *v5;
  char *v6;

  v1 = (const STACK **)cms_get0_revocation_choices(a1);
  if (!v1)
    return 0;
  v2 = v1;
  if (sk_num(*v1) < 1)
    return 0;
  v3 = 0;
  v4 = 0;
  while (1)
  {
    v5 = sk_value(*v2, v3);
    if (!*(_DWORD *)v5)
      break;
LABEL_9:
    if (++v3 >= sk_num(*v2))
      return v4;
  }
  v6 = v5;
  if (!v4)
  {
    v4 = sk_new_null();
    if (!v4)
      return v4;
  }
  if (sk_push(v4, *((char **)v6 + 1)))
  {
    X509_CRL_up_ref(*((_QWORD *)v6 + 1));
    goto LABEL_9;
  }
  sk_pop_free(v4, (void (__cdecl *)(void *))X509_CRL_free);
  return 0;
}

uint64_t cms_ias_cert_cmp(uint64_t a1, X509 *a)
{
  const X509_NAME *v4;
  X509_NAME *issuer_name;
  uint64_t result;
  ASN1_INTEGER *v7;
  ASN1_INTEGER *serialNumber;

  v4 = *(const X509_NAME **)a1;
  issuer_name = X509_get_issuer_name(a);
  result = X509_NAME_cmp(v4, issuer_name);
  if (!(_DWORD)result)
  {
    v7 = *(ASN1_INTEGER **)(a1 + 8);
    serialNumber = X509_get_serialNumber(a);
    return ASN1_INTEGER_cmp(v7, serialNumber);
  }
  return result;
}

uint64_t cms_keyid_cert_cmp(ASN1_OCTET_STRING *a1, X509 *x)
{
  ASN1_OCTET_STRING *ex_xkusage;

  X509_check_purpose(x, -1, -1);
  ex_xkusage = (ASN1_OCTET_STRING *)x->ex_xkusage;
  if (ex_xkusage)
    return ASN1_OCTET_STRING_cmp(a1, ex_xkusage);
  else
    return 0xFFFFFFFFLL;
}

uint64_t cms_set1_ias(ASN1_VALUE **a1, X509 *a2)
{
  ASN1_VALUE *v4;
  X509_NAME *issuer_name;
  ASN1_STRING *v6;
  ASN1_INTEGER *serialNumber;

  v4 = ASN1_item_new(&CMS_IssuerAndSerialNumber_it);
  if (v4
    && (issuer_name = X509_get_issuer_name(a2), X509_NAME_set((X509_NAME **)v4, issuer_name))
    && (v6 = (ASN1_STRING *)*((_QWORD *)v4 + 1),
        serialNumber = X509_get_serialNumber(a2),
        ASN1_STRING_copy(v6, (uint64_t)serialNumber)))
  {
    ASN1_item_free(*a1, &CMS_IssuerAndSerialNumber_it);
    *a1 = v4;
    return 1;
  }
  else
  {
    ASN1_item_free(v4, &CMS_IssuerAndSerialNumber_it);
    ERR_put_error(46, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/cms/cms_lib.c", 696);
    return 0;
  }
}

uint64_t cms_set1_keyid(ASN1_OCTET_STRING **a1, X509 *x)
{
  ASN1_STRING *ex_xkusage;
  ASN1_STRING *v5;
  ASN1_OCTET_STRING *v6;
  int v8;
  int v9;

  X509_check_purpose(x, -1, -1);
  ex_xkusage = (ASN1_STRING *)x->ex_xkusage;
  if (ex_xkusage)
  {
    v5 = ASN1_STRING_dup(ex_xkusage);
    if (v5)
    {
      v6 = v5;
      ASN1_OCTET_STRING_free(*a1);
      *a1 = v6;
      return 1;
    }
    v8 = 65;
    v9 = 714;
  }
  else
  {
    v8 = 160;
    v9 = 709;
  }
  ERR_put_error(46, 4095, v8, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/cms/cms_lib.c", v9);
  return 0;
}

char *__cdecl X509_NAME_oneline(X509_NAME *a, char *buf, int size)
{
  char *data;
  X509_NAME *v4;
  int v5;
  int v6;
  char *v7;
  int v8;
  const char *v9;
  int v10;
  int v11;
  unsigned int *v12;
  unsigned int v13;
  uint64_t v14;
  uint64_t v15;
  __int128 v17;
  BUF_MEM *v18;
  uint64_t i;
  __int128 v20;
  uint64_t v21;
  int v22;
  int v23;
  char *v24;
  char *v25;
  char *v26;
  _BYTE *v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t v30;
  BUF_MEM *v31;
  BUF_MEM *v32;
  const STACK **p_entries;
  BUF_MEM *str;
  char bufa[80];
  __int128 v38;
  uint64_t v39;

  data = buf;
  v4 = a;
  v39 = *MEMORY[0x24BDAC8D0];
  if (buf)
  {
    if (a)
    {
      str = 0;
      goto LABEL_4;
    }
LABEL_60:
    strlcpy(data, "NO X509_NAME", size);
    return data;
  }
  v31 = BUF_MEM_new();
  if (!v31)
  {
    ERR_put_error(11, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_obj.c", 177);
    return 0;
  }
  v32 = v31;
  if (!BUF_MEM_grow(v31, 200))
  {
    str = v32;
LABEL_57:
    ERR_put_error(11, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_obj.c", 177);
    BUF_MEM_free(str);
    return 0;
  }
  *v32->data = 0;
  if (!v4)
  {
    data = v32->data;
    free(v32);
    size = 200;
    goto LABEL_60;
  }
  str = v32;
  size = 200;
LABEL_4:
  if (sk_num(v4->entries) < 1)
  {
    v6 = 0;
  }
  else
  {
    v5 = 0;
    v6 = 0;
    p_entries = (const STACK **)&v4->entries;
    do
    {
      v7 = sk_value(v4->entries, v6);
      v8 = OBJ_obj2nid(*(const ASN1_OBJECT **)v7);
      if (!v8 || (v9 = OBJ_nid2sn(v8)) == 0)
      {
        v9 = bufa;
        i2t_ASN1_OBJECT(bufa, 80, *(ASN1_OBJECT **)v7);
      }
      v10 = strlen(v9);
      v11 = v10;
      v12 = (unsigned int *)*((_QWORD *)v7 + 1);
      v14 = *v12;
      v13 = v12[1];
      v15 = *((_QWORD *)v12 + 1);
      if (v13 == 27 && (v14 & 3) == 0)
      {
        v38 = 0uLL;
        v18 = str;
        if ((int)v14 < 1)
          goto LABEL_21;
        for (i = 0; i != v14; ++i)
        {
          if (*(_BYTE *)(v15 + i))
            *(_DWORD *)((unint64_t)&v38 & 0xFFFFFFFFFFFFFFF3 | (4 * (i & 3))) = 1;
        }
        if (DWORD1(v38) | v38 | DWORD2(v38))
        {
          *(_QWORD *)&v20 = 0x100000001;
          *((_QWORD *)&v20 + 1) = 0x100000001;
        }
        else
        {
LABEL_21:
          v20 = xmmword_22D6A5420;
        }
        v38 = v20;
      }
      else
      {
        *(_QWORD *)&v17 = 0x100000001;
        *((_QWORD *)&v17 + 1) = 0x100000001;
        v38 = v17;
        v18 = str;
      }
      if ((int)v14 < 1)
      {
        v22 = 0;
      }
      else
      {
        v21 = 0;
        v22 = 0;
        do
        {
          if (*(_DWORD *)((unint64_t)&v38 & 0xFFFFFFFFFFFFFFF3 | (4 * (v21 & 3))))
          {
            if (*(unsigned __int8 *)(v15 + v21) - 127 >= 0xFFFFFFA1)
              ++v22;
            else
              v22 += 4;
          }
          ++v21;
        }
        while (v14 != v21);
      }
      v23 = v5 + v10 + v22 + 2;
      if (v18)
      {
        if (!BUF_MEM_grow(v18, v5 + v10 + v22 + 3))
          goto LABEL_57;
        v24 = v18->data;
      }
      else
      {
        v24 = data;
        if (v23 >= size)
          goto LABEL_53;
      }
      v25 = &v24[v5];
      *v25++ = 47;
      memcpy(v25, v9, v11);
      v26 = &v25[v11];
      *v26 = 61;
      v27 = v26 + 1;
      if ((int)v14 >= 1)
      {
        v28 = 0;
        v29 = *(_QWORD *)(*((_QWORD *)v7 + 1) + 8);
        do
        {
          if (*(_DWORD *)((unint64_t)&v38 & 0xFFFFFFFFFFFFFFF3 | (4 * (v28 & 3))))
          {
            v30 = *(unsigned __int8 *)(v29 + v28);
            if ((v30 - 127) > 0xFFFFFFA0)
            {
              *v27++ = v30;
            }
            else
            {
              *(_WORD *)v27 = 30812;
              v27[2] = X509_NAME_oneline_hex[v30 >> 4];
              v27[3] = X509_NAME_oneline_hex[v30 & 0xF];
              v27 += 4;
            }
          }
          ++v28;
        }
        while (v14 != v28);
      }
      *v27 = 0;
      ++v6;
      v4 = (X509_NAME *)p_entries;
      v5 = v23;
    }
    while (v6 < sk_num(*p_entries));
  }
  if (str)
  {
    data = str->data;
    free(str);
    if (!v6)
      goto LABEL_54;
  }
  else
  {
LABEL_53:
    if (!v6)
LABEL_54:
      *data = 0;
  }
  return data;
}

ASN1_TYPE *__cdecl ASN1_generate_nconf(char *str, CONF *nconf)
{
  X509V3_CTX v4;

  if (!nconf)
    return ASN1_generate_v3(str, 0);
  memset(&v4, 0, sizeof(v4));
  X509V3_set_nconf(&v4, nconf);
  return ASN1_generate_v3(str, &v4);
}

ASN1_TYPE *__cdecl ASN1_generate_v3(char *str, X509V3_CTX *cnf)
{
  ASN1_TYPE *v3;
  int v5;
  char *v6;
  STACK *v7;
  STACK *v8;
  STACK *section;
  STACK *v10;
  int v11;
  char *v12;
  char *v13;
  char *v14;
  int v15;
  ASN1_TYPE *v16;
  int v17;
  int v18;
  int v19;
  ASN1_STRING *v20;
  unint64_t v21;
  int v22;
  int v23;
  int v24;
  int v25;
  ASN1_INTEGER *v26;
  ASN1_STRING *v27;
  unsigned __int8 *v28;
  ASN1_STRING *v29;
  ASN1_OBJECT *v30;
  int v31;
  char object;
  int v33;
  int v34;
  int v35;
  int v36;
  unsigned __int8 *v37;
  int v38;
  uint64_t *v39;
  uint64_t v40;
  uint64_t v41;
  unsigned __int8 *v42;
  int v43;
  int *v44;
  unsigned __int8 *v45;
  BOOL v46;
  int v47;
  int pclass[2];
  uint64_t plength;
  unsigned __int8 *in;
  unsigned __int8 *v51;
  unsigned __int8 *pp;
  unsigned __int8 *out;
  _QWORD arg[5];
  _OWORD v55[29];
  uint64_t v56;
  uint64_t len;
  CONF_VALUE value;

  memset(v55, 0, sizeof(v55));
  memset(&arg[1], 0, 32);
  pp = 0;
  out = 0;
  in = 0;
  v51 = 0;
  *(_QWORD *)pclass = 0;
  plength = 0;
  arg[0] = -1;
  HIDWORD(arg[1]) = 1;
  v56 = 0;
  v3 = 0;
  if (!CONF_parse_list(str, 44, 1, (int (__cdecl *)(const char *, int, void *))asn1_cb, arg))
  {
    v5 = arg[1];
    if ((arg[1] & 0xFFFFFFFE) == 0x10)
    {
      if (!cnf)
      {
        ERR_put_error(13, 4095, 192, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/asn1_gen.c", 165);
        return 0;
      }
      v6 = (char *)arg[2];
      value.section = 0;
      v7 = sk_new_null();
      if (v7)
      {
        v8 = v7;
        if (!v6)
        {
          v10 = 0;
          goto LABEL_25;
        }
        section = X509V3_get_section(cnf, v6);
        if (section)
        {
          v10 = section;
          if (sk_num(section) >= 1)
          {
            v11 = 0;
            do
            {
              v12 = sk_value(v10, v11);
              v13 = (char *)ASN1_generate_v3(*((char **)v12 + 2), cnf);
              if (!v13 || !sk_push(v8, v13))
                goto LABEL_32;
            }
            while (++v11 < sk_num(v10));
          }
LABEL_25:
          if (v5 == 17)
            v18 = i2d_ASN1_SET_ANY((ASN1_VALUE *)v8, (unsigned __int8 **)&value);
          else
            v18 = i2d_ASN1_SEQUENCE_ANY((ASN1_VALUE *)v8, (unsigned __int8 **)&value);
          v19 = v18;
          if ((v18 & 0x80000000) == 0)
          {
            v3 = ASN1_TYPE_new();
            if (v3)
            {
              v20 = ASN1_STRING_type_new(v5);
              v3->value.ptr = (char *)v20;
              if (v20)
              {
                v3->type = v5;
                v20->data = (unsigned __int8 *)value.section;
                *(_DWORD *)v3->value.ptr = v19;
                value.section = 0;
              }
            }
            goto LABEL_33;
          }
LABEL_32:
          v3 = 0;
LABEL_33:
          free(value.section);
          sk_pop_free(v8, (void (__cdecl *)(void *))ASN1_TYPE_free);
          if (v10)
            X509V3_section_free(cnf, v10);
LABEL_86:
          if (!v3 || LODWORD(arg[0]) == -1 && !(_DWORD)v56)
            return v3;
          v31 = i2d_ASN1_TYPE(v3, &out);
          ASN1_TYPE_free(v3);
          pp = out;
          if (LODWORD(arg[0]) == -1)
          {
            v34 = 0;
            v36 = v31;
            v33 = v31;
          }
          else
          {
            object = ASN1_get_object((const unsigned __int8 **)&pp, &plength, &pclass[1], pclass, v31);
            if (object < 0)
            {
              v3 = 0;
              v37 = 0;
LABEL_116:
              free(out);
              free(v37);
              return v3;
            }
            v33 = v31 + (_DWORD)out - (_DWORD)pp;
            if ((object & 1) != 0)
            {
              v35 = 0;
              plength = 0;
              v34 = 2;
            }
            else
            {
              v34 = object & 0x20;
              v35 = plength;
            }
            v36 = ASN1_object_size(0, v35, arg[0]);
          }
          if ((int)v56 >= 1)
          {
            v38 = 0;
            v39 = &arg[3 * v56 + 2];
            do
            {
              v40 = *((int *)v39 - 1) + (uint64_t)v36;
              *v39 = v40;
              v36 = ASN1_object_size(0, v40, *((_DWORD *)v39 - 4));
              ++v38;
              v39 -= 3;
            }
            while (v38 < (int)v56);
          }
          v41 = v36;
          v42 = (unsigned __int8 *)malloc_type_malloc(v36, 0xB672B555uLL);
          v37 = v42;
          if (v42)
          {
            v51 = v42;
            if ((int)v56 >= 1)
            {
              v43 = 0;
              v44 = (int *)v55;
              do
              {
                ASN1_put_object(&v51, *(v44 - 2), *v44, *(v44 - 4), *(v44 - 3));
                if (*(v44 - 1))
                {
                  v45 = v51++;
                  *v45 = 0;
                }
                v44 += 6;
                ++v43;
              }
              while (v43 < (int)v56);
            }
            if (LODWORD(arg[0]) != -1)
            {
              if (HIDWORD(arg[0]))
                v46 = 0;
              else
                v46 = (arg[0] & 0xFFFFFFFE) == 16;
              if (v46)
                v47 = 32;
              else
                v47 = v34;
              ASN1_put_object(&v51, v47, plength, arg[0], SHIDWORD(arg[0]));
            }
            memcpy(v51, pp, v33);
            in = v37;
            v3 = d2i_ASN1_TYPE(0, (const unsigned __int8 **)&in, v41);
          }
          else
          {
            v3 = 0;
          }
          goto LABEL_116;
        }
        free(value.section);
        sk_pop_free(v8, (void (__cdecl *)(void *))ASN1_TYPE_free);
      }
      else
      {
        free(value.section);
      }
    }
    else
    {
      v14 = (char *)arg[2];
      v15 = HIDWORD(arg[1]);
      v16 = ASN1_TYPE_new();
      v3 = v16;
      if (!v16)
      {
        ERR_put_error(13, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/asn1_gen.c", 618);
        goto LABEL_86;
      }
      memset(&value, 0, sizeof(value));
      len = 0;
      if (!v14)
        v14 = "";
      switch(v5)
      {
        case 1:
          if (v15 != 1)
          {
            v22 = 190;
            v23 = 636;
            goto LABEL_79;
          }
          value.section = 0;
          value.name = 0;
          value.value = v14;
          if (X509V3_get_value_BOOL(&value, (int *)&v16->value))
            goto LABEL_37;
          v24 = 176;
          v25 = 643;
          goto LABEL_82;
        case 2:
        case 10:
          if (v15 != 1)
          {
            v22 = 185;
            v23 = 651;
            goto LABEL_79;
          }
          v26 = s2i_ASN1_INTEGER(0, v14);
          v3->value.ptr = (char *)v26;
          if (v26)
            goto LABEL_37;
          v24 = 180;
          v25 = 656;
          goto LABEL_82;
        case 3:
        case 4:
          v27 = ASN1_STRING_new();
          v3->value.ptr = (char *)v27;
          if (!v27)
          {
            v22 = 65;
            v23 = 723;
            goto LABEL_79;
          }
          if (v15 == 1)
          {
            if (!ASN1_STRING_set(v27, v14, -1))
            {
              v24 = 65;
              v25 = 741;
              goto LABEL_82;
            }
          }
          else
          {
            if (v15 != 3)
            {
              if (v5 != 3 || v15 != 4)
              {
                v22 = 175;
                v23 = 754;
                goto LABEL_79;
              }
              if (CONF_parse_list(v14, 44, 1, (int (__cdecl *)(const char *, int, void *))bitstr_cb, v27))
                goto LABEL_37;
              v24 = 188;
              v25 = 748;
              goto LABEL_82;
            }
            v28 = string_to_hex(v14, &len);
            if (!v28)
            {
              v24 = 178;
              v25 = 730;
              goto LABEL_82;
            }
            *((_QWORD *)v3->value.ptr + 1) = v28;
            *(_DWORD *)v3->value.ptr = len;
            *((_DWORD *)v3->value.ptr + 1) = v5;
          }
          if (v5 != 3 || asn1_abs_set_unused_bits((uint64_t)v3->value.ptr, 0))
            goto LABEL_37;
          goto LABEL_83;
        case 5:
          if (!*v14)
            goto LABEL_37;
          v22 = 182;
          v23 = 629;
          goto LABEL_79;
        case 6:
          if (v15 != 1)
          {
            v22 = 191;
            v23 = 663;
            goto LABEL_79;
          }
          v30 = OBJ_txt2obj(v14, 0);
          v3->value.ptr = (char *)v30;
          if (v30)
            goto LABEL_37;
          v24 = 183;
          v25 = 667;
          goto LABEL_82;
        case 12:
        case 18:
        case 19:
        case 20:
        case 22:
        case 26:
        case 27:
        case 28:
        case 30:
          if (v15 == 1)
          {
            v17 = 4097;
          }
          else
          {
            if (v15 != 2)
            {
              v22 = 177;
              v23 = 708;
              goto LABEL_79;
            }
            v17 = 4096;
          }
          v21 = ASN1_tag2bit(v5);
          if (ASN1_mbstring_copy((ASN1_STRING **)&v3->value, (const unsigned __int8 *)v14, -1, v17, v21) > 0)
            goto LABEL_37;
          v24 = 65;
          v25 = 715;
          goto LABEL_82;
        case 23:
        case 24:
          if (v15 == 1)
          {
            v29 = ASN1_STRING_new();
            v3->value.ptr = (char *)v29;
            if (v29)
            {
              if (ASN1_STRING_set(v29, v14, -1))
              {
                *((_DWORD *)v3->value.ptr + 1) = v5;
                if (ASN1_TIME_check(v3->value.asn1_string))
                {
LABEL_37:
                  v3->type = v5;
                  goto LABEL_86;
                }
                v24 = 184;
                v25 = 688;
              }
              else
              {
                v24 = 65;
                v25 = 683;
              }
            }
            else
            {
              v24 = 65;
              v25 = 679;
            }
LABEL_82:
            ERR_put_error(13, 4095, v24, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/asn1_gen.c", v25);
LABEL_83:
            ERR_asprintf_error_data("string=%s", v14);
          }
          else
          {
            v22 = 193;
            v23 = 675;
LABEL_79:
            ERR_put_error(13, 4095, v22, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/asn1_gen.c", v23);
          }
          ASN1_TYPE_free(v3);
          break;
        default:
          v24 = 196;
          v25 = 767;
          goto LABEL_82;
      }
    }
    v3 = 0;
    goto LABEL_86;
  }
  return v3;
}

uint64_t asn1_cb(char *__s2, int a2, uint64_t a3)
{
  int v5;
  uint64_t v6;
  int v7;
  const char *v8;
  int v9;
  uint64_t v10;
  size_t v11;
  uint64_t result;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  int *v18;
  int v19;
  int v20;
  int v21;
  int v22;
  uint64_t v23;

  v5 = a2;
  if (a2 <= 0)
  {
LABEL_5:
    v7 = 0;
    v8 = 0;
  }
  else
  {
    v6 = 0;
    while (__s2[v6] != 58)
    {
      if (a2 == (_DWORD)++v6)
        goto LABEL_5;
    }
    v7 = ~(_DWORD)v6 + a2;
    v8 = &__s2[v6 + 1];
    v5 = v6;
  }
  v9 = v5;
  if (v5 == -1)
    v9 = strlen(__s2);
  v10 = 0;
  v11 = v9;
  while ((_DWORD)v11 != LODWORD((&asn1_str2tag_tnst)[v10 + 1]) || strncmp((&asn1_str2tag_tnst)[v10], __s2, v11))
  {
    v10 += 2;
    if ((_DWORD)(v10 * 8) == 784)
      goto LABEL_13;
  }
  asn1_str2tag_tntmp = (uint64_t)&(&asn1_str2tag_tnst)[v10];
  v13 = *((_DWORD *)&asn1_str2tag_tnst + 2 * v10 + 3);
  if (v13 == -1)
  {
LABEL_13:
    ERR_put_error(13, 4095, 194, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/asn1_gen.c", 294);
    ERR_asprintf_error_data("tag=%s", __s2);
    return 0xFFFFFFFFLL;
  }
  if ((v13 & 0x10000) != 0)
  {
    switch(v13)
    {
      case 65537:
        if (*(_DWORD *)a3 != -1)
        {
          v14 = 181;
          v15 = 316;
          goto LABEL_24;
        }
        if (!parse_tagging((uint64_t)v8, v7, (_DWORD *)a3, (int *)(a3 + 4)))
          return 0xFFFFFFFFLL;
        goto LABEL_35;
      case 65538:
        v23 = 0;
        if (!parse_tagging((uint64_t)v8, v7, (_DWORD *)&v23 + 1, (int *)&v23))
          return 0xFFFFFFFFLL;
        v17 = v23;
        v16 = HIDWORD(v23);
        v18 = (int *)a3;
        v19 = 1;
        v20 = 0;
        v21 = 0;
        goto LABEL_34;
      case 65540:
        v18 = (int *)a3;
        v16 = 3;
        v17 = 0;
        v19 = 0;
        v20 = 1;
        goto LABEL_33;
      case 65541:
        v18 = (int *)a3;
        v16 = 4;
        v17 = 0;
        v19 = 0;
        goto LABEL_32;
      case 65542:
        v18 = (int *)a3;
        v16 = 16;
        goto LABEL_31;
      case 65543:
        v18 = (int *)a3;
        v16 = 17;
LABEL_31:
        v17 = 0;
        v19 = 1;
LABEL_32:
        v20 = 0;
LABEL_33:
        v21 = 1;
LABEL_34:
        if (append_exp(v18, v16, v17, v19, v20, v21))
          goto LABEL_35;
        return 0xFFFFFFFFLL;
      case 65544:
        if (!v8)
        {
          v14 = 177;
          v15 = 353;
          goto LABEL_24;
        }
        if (!strncmp(v8, "ASCII", 5uLL))
        {
          v22 = 1;
        }
        else if (!strncmp(v8, "UTF8", 4uLL))
        {
          v22 = 2;
        }
        else
        {
          v22 = 3;
          if (strncmp(v8, "HEX", 3uLL))
          {
            if (strncmp(v8, "BITLIST", 7uLL))
            {
              v14 = 195;
              v15 = 365;
              goto LABEL_24;
            }
            v22 = 4;
          }
        }
        *(_DWORD *)(a3 + 12) = v22;
LABEL_35:
        result = 1;
        break;
      default:
        goto LABEL_35;
    }
  }
  else
  {
    *(_DWORD *)(a3 + 8) = v13;
    *(_QWORD *)(a3 + 16) = v8;
    if (!v8 && __s2[v5])
    {
      v14 = 189;
      v15 = 305;
LABEL_24:
      ERR_put_error(13, 4095, v14, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/asn1_gen.c", v15);
      return 0xFFFFFFFFLL;
    }
    return 0;
  }
  return result;
}

uint64_t parse_tagging(uint64_t result, int a2, _DWORD *a3, int *a4)
{
  uint64_t v7;
  unint64_t v8;
  char *v9;
  BOOL v10;
  int v11;
  int v12;
  char *__endptr;

  if (result)
  {
    v7 = result;
    __endptr = 0;
    v8 = strtoul((const char *)result, &__endptr, 10);
    v9 = __endptr;
    if (!__endptr || (*__endptr ? (v10 = (unint64_t)__endptr > v7 + a2) : (v10 = 0), !v10))
    {
      if ((v8 & 0x8000000000000000) != 0)
      {
        ERR_put_error(13, 4095, 187, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/asn1_gen.c", 388);
      }
      else
      {
        *a3 = v8;
        if (!v9 || (_DWORD)v7 - (_DWORD)v9 == -a2)
          goto LABEL_13;
        v11 = *v9;
        if (v11 > 79)
        {
          if (v11 == 80)
          {
            v12 = 192;
            goto LABEL_14;
          }
          if (v11 == 85)
          {
            *a4 = 0;
            return 1;
          }
        }
        else
        {
          if (v11 == 65)
          {
            v12 = 64;
            goto LABEL_14;
          }
          if (v11 == 67)
          {
LABEL_13:
            v12 = 128;
LABEL_14:
            *a4 = v12;
            return 1;
          }
        }
        ERR_put_error(13, 4095, 186, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/asn1_gen.c", 417);
        ERR_asprintf_error_data("Char=%c", *v9);
      }
    }
    return 0;
  }
  return result;
}

uint64_t append_exp(int *a1, int a2, int a3, int a4, int a5, int a6)
{
  int v6;
  int v7;
  int v8;
  int v9;
  int *v11;

  v6 = *a1;
  if (!a6 && v6 != -1)
  {
    v7 = 179;
    v8 = 501;
LABEL_6:
    ERR_put_error(13, 4095, v7, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/asn1_gen.c", v8);
    return 0;
  }
  v9 = a1[126];
  if (v9 == 20)
  {
    v7 = 174;
    v8 = 506;
    goto LABEL_6;
  }
  a1[126] = v9 + 1;
  if (v6 != -1)
  {
    a3 = a1[1];
    *(_QWORD *)a1 = -1;
    a2 = v6;
  }
  a1[6 * v9 + 6] = a2;
  v11 = &a1[6 * v9];
  v11[7] = a3;
  v11[8] = a4;
  v11[9] = a5;
  return 1;
}

uint64_t bitstr_cb(const char *a1, int a2, ASN1_BIT_STRING *a3)
{
  unint64_t v6;
  uint64_t v8;
  int v9;
  int v10;
  char *__endptr;

  if (!a1)
    return 0;
  __endptr = 0;
  v6 = strtoul(a1, &__endptr, 10);
  if (__endptr)
  {
    if (*__endptr && __endptr != &a1[a2])
      return 0;
  }
  if ((v6 & 0x8000000000000000) != 0)
  {
    v9 = 187;
    v10 = 794;
    goto LABEL_12;
  }
  v8 = 1;
  if (!ASN1_BIT_STRING_set_bit(a3, v6, 1))
  {
    v9 = 65;
    v10 = 798;
LABEL_12:
    ERR_put_error(13, 4095, v9, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/asn1_gen.c", v10);
    return 0;
  }
  return v8;
}

int MD4_Update(MD4_CTX *c, const void *data, size_t len)
{
  size_t v3;
  _DWORD *v4;
  uint64_t num;
  unsigned int *v7;
  char *v8;
  uint64_t v9;

  if (len)
  {
    v3 = len;
    v4 = data;
    *(_QWORD *)&c->Nl += 8 * len;
    num = c->num;
    if ((_DWORD)num)
    {
      v7 = c->data;
      v8 = (char *)c->data + num;
      if (len <= 0x3F && num + len < 0x40)
      {
        memcpy(v8, data, len);
        c->num += v3;
        return 1;
      }
      v9 = 64 - num;
      memcpy(v8, data, 64 - num);
      md4_block_data_order((unint64_t)c, c->data, 1);
      v4 = (_DWORD *)((char *)v4 + v9);
      v3 -= v9;
      c->num = 0;
      *(_OWORD *)v7 = 0u;
      *(_OWORD *)&c->data[4] = 0u;
      *(_OWORD *)&c->data[8] = 0u;
      *(_OWORD *)&c->data[12] = 0u;
    }
    if (v3 >= 0x40)
    {
      md4_block_data_order((unint64_t)c, v4, v3 >> 6);
      v4 = (_DWORD *)((char *)v4 + (v3 & 0xFFFFFFFFFFFFFFC0));
      v3 &= 0x3Fu;
    }
    if (v3)
    {
      c->num = v3;
      memcpy(c->data, v4, v3);
    }
  }
  return 1;
}

unint64_t md4_block_data_order(unint64_t result, _DWORD *a2, uint64_t a3)
{
  int v3;
  int v4;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  unint64_t v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  int v18;
  int v19;
  int v20;
  int v21;
  int v22;
  int v23;
  int v24;
  unint64_t v25;
  int v26;
  int v27;
  int v28;
  int v29;
  int v30;
  int v31;
  int v32;
  unint64_t v33;
  int v34;
  int v35;
  int v36;
  int v37;
  int v38;
  int v39;
  int v40;
  int v41;
  int v42;
  int v43;
  int v44;
  int v45;
  int v46;
  int v47;
  int v48;
  int v49;
  unint64_t v50;
  unsigned int v51;
  int v52;
  unint64_t v53;
  int v54;
  int v55;
  unsigned int v56;
  int v57;
  unint64_t v58;
  int v59;
  int v60;
  unsigned int v61;
  unint64_t v62;
  int v63;
  int v64;
  unsigned int v65;
  int v66;
  unint64_t v67;
  int v68;
  int v69;
  unsigned int v70;
  unint64_t v71;
  int v72;
  int v73;
  int v74;
  unsigned int v75;
  int v76;
  unint64_t v77;
  int v78;
  int v79;
  unsigned int v80;
  unint64_t v81;
  int v82;
  int v83;
  int v84;
  unsigned int v85;
  int v86;
  unint64_t v87;
  int v88;
  int v89;
  unsigned int v90;
  unint64_t v91;
  int v92;
  int v93;
  int v94;
  unsigned int v95;
  int v96;
  unint64_t v97;
  int v98;
  int v99;
  unsigned int v100;
  unint64_t v101;
  int v102;
  int v103;
  int v104;
  unsigned int v105;
  int v106;
  unint64_t v107;
  int v108;
  int v109;
  unsigned int v110;
  unint64_t v111;
  int v112;
  int v113;
  int v114;
  unsigned int v115;
  int v116;
  unint64_t v117;
  int v118;
  int v119;
  unsigned int v120;
  unint64_t v121;
  int v122;
  int v123;
  int v124;
  unsigned int v125;
  int v126;
  int v127;
  int v128;
  int v129;
  int v130;
  unint64_t v131;
  unsigned int v132;
  int v133;
  int v134;
  unint64_t v135;
  unsigned int v136;
  int v137;
  int v138;
  unint64_t v139;
  unsigned int v140;
  int v141;
  unint64_t v142;
  unsigned int v143;
  int v144;
  int v145;
  unint64_t v146;
  unsigned int v147;
  int v148;
  int v149;
  unint64_t v150;
  unsigned int v151;
  int v152;
  unint64_t v153;
  unsigned int v154;
  int v155;
  int v156;
  unint64_t v157;
  unsigned int v158;
  int v159;
  int v160;
  unint64_t v161;
  unsigned int v162;
  int v163;
  unint64_t v164;
  unsigned int v165;
  int v166;
  int v167;
  unint64_t v168;
  unsigned int v169;
  int v170;
  unint64_t v171;
  unsigned int v172;
  int v173;
  int v174;
  unint64_t v175;
  unsigned int v176;
  int v177;
  unint64_t v178;
  unsigned int v179;
  int v180;
  unint64_t v181;
  int v182;
  _DWORD *v183;
  uint64_t v184;

  v183 = (_DWORD *)result;
  if (a3)
  {
    v4 = *(_DWORD *)(result + 8);
    v3 = *(_DWORD *)(result + 12);
    v6 = *(_DWORD *)result;
    v5 = *(_DWORD *)(result + 4);
    do
    {
      v184 = a3;
      v7 = a2[1];
      v9 = __ROR4__((v4 & v5 | v3 & ~v5) + v6 + *a2, 29);
      v8 = v4 & ~v9;
      v10 = v5 & v9;
      HIDWORD(v12) = (v4 & v5 | v3 & ~v5) + v6 + *a2;
      LODWORD(v12) = HIDWORD(v12);
      v11 = v12 >> 29;
      v14 = a2[2];
      v13 = a2[3];
      HIDWORD(v12) = v7 + v3 + (v10 | v8);
      LODWORD(v12) = HIDWORD(v12);
      v15 = v12 >> 25;
      LODWORD(v12) = v14 + v4 + (v11 & __ROR4__(HIDWORD(v12), 25) | v5 & ~__ROR4__(HIDWORD(v12), 25));
      HIDWORD(v12) = v12;
      v16 = v12 >> 21;
      LODWORD(v12) = v13 + v5 + (v15 & __ROR4__(v12, 21) | v11 & ~__ROR4__(v12, 21));
      HIDWORD(v12) = v12;
      v17 = v12 >> 13;
      v19 = a2[4];
      v18 = a2[5];
      LODWORD(v12) = v19 + v11 + (v16 & __ROR4__(v12, 13) | v15 & ~__ROR4__(v12, 13));
      HIDWORD(v12) = v12;
      v20 = v12 >> 29;
      v21 = v18 + v15 + (v17 & __ROR4__(v12, 29) | v16 & ~__ROR4__(v12, 29));
      v22 = a2[6];
      v23 = a2[7];
      v25 = __PAIR64__(v21, __ROR4__(v21, 25));
      v24 = v20 & v25;
      LODWORD(v25) = v21;
      v26 = v25 >> 25;
      HIDWORD(v25) = v22 + v16 + (v24 | v17 & ~__ROR4__(v21, 25));
      LODWORD(v25) = HIDWORD(v25);
      v27 = v25 >> 21;
      LODWORD(v25) = v23 + v17 + (v26 & __ROR4__(HIDWORD(v25), 21) | v20 & ~__ROR4__(HIDWORD(v25), 21));
      HIDWORD(v25) = v25;
      v28 = v25 >> 13;
      v30 = a2[8];
      v29 = a2[9];
      v31 = v30 + v20 + (v27 & __ROR4__(v25, 13) | v26 & ~__ROR4__(v25, 13));
      v33 = __PAIR64__(v31, __ROR4__(v31, 29));
      v32 = v28 & v33;
      LODWORD(v33) = v31;
      v34 = v33 >> 29;
      v35 = v29 + v26 + (v32 | v27 & ~__ROR4__(v31, 29));
      v37 = a2[10];
      v36 = a2[11];
      HIDWORD(v33) = v35;
      LODWORD(v33) = v35;
      v38 = v33 >> 25;
      LODWORD(v33) = v37 + v27 + (v34 & __ROR4__(v35, 25) | v28 & ~__ROR4__(v35, 25));
      HIDWORD(v33) = v33;
      v39 = v33 >> 21;
      LODWORD(v33) = v36 + v28 + (v38 & __ROR4__(v33, 21) | v34 & ~__ROR4__(v33, 21));
      HIDWORD(v33) = v33;
      v40 = v33 >> 13;
      v42 = a2[12];
      v41 = a2[13];
      LODWORD(v33) = v42 + v34 + (v39 & __ROR4__(v33, 13) | v38 & ~__ROR4__(v33, 13));
      HIDWORD(v33) = v33;
      v43 = v33 >> 29;
      v44 = v41 + v38 + (v40 & __ROR4__(v33, 29) | v39 & ~__ROR4__(v33, 29));
      v46 = a2[14];
      v45 = a2[15];
      v47 = v46 + v39 + (v43 & __ROR4__(v44, 25) | v40 & ~__ROR4__(v44, 25));
      HIDWORD(v33) = v47;
      LODWORD(v33) = v47;
      v48 = v33 >> 21;
      v50 = __PAIR64__(v44, __ROR4__(v44, 25));
      v49 = v48 & v50;
      v51 = v45 + v40 + (v48 & v50 | v43 & ~__ROR4__(v47, 21));
      LODWORD(v50) = v44;
      v52 = v50 >> 25;
      v53 = __PAIR64__(v51, __ROR4__(v51, 13));
      v54 = (v48 | __ROR4__(v44, 25)) & v53 | v49;
      LODWORD(v53) = v51;
      v55 = v53 >> 13;
      v56 = *a2 + 1518500249 + v43 + v54;
      v57 = v19 + 1518500249 + v52;
      v58 = __PAIR64__(v56, __ROR4__(v56, 29));
      v59 = (v55 | __ROR4__(v47, 21)) & v58 | v55 & __ROR4__(v47, 21);
      LODWORD(v58) = v56;
      v60 = v58 >> 29;
      v61 = v57 + v59;
      v62 = __PAIR64__(v61, __ROR4__(v61, 27));
      v63 = (v60 | __ROR4__(v51, 13)) & v62 | v60 & __ROR4__(v51, 13);
      LODWORD(v62) = v61;
      v64 = v62 >> 27;
      v65 = v30 + 1518500249 + v48 + v63;
      v66 = v42 + 1518500249 + v55;
      v67 = __PAIR64__(v65, __ROR4__(v65, 23));
      v68 = (v64 | __ROR4__(v56, 29)) & v67 | v64 & __ROR4__(v56, 29);
      LODWORD(v67) = v65;
      v69 = v67 >> 23;
      v70 = v66 + v68;
      v71 = __PAIR64__(v70, __ROR4__(v70, 19));
      v72 = (v69 | __ROR4__(v61, 27)) & v71 | v69 & __ROR4__(v61, 27);
      v73 = v7 + 1518500249 + v60;
      LODWORD(v71) = v70;
      v74 = v71 >> 19;
      v75 = v73 + v72;
      v76 = v18 + 1518500249 + v64;
      v77 = __PAIR64__(v75, __ROR4__(v75, 29));
      v78 = (v74 | __ROR4__(v65, 23)) & v77 | v74 & __ROR4__(v65, 23);
      LODWORD(v77) = v75;
      v79 = v77 >> 29;
      v80 = v76 + v78;
      v81 = __PAIR64__(v80, __ROR4__(v80, 27));
      v82 = (v79 | __ROR4__(v70, 19)) & v81 | v79 & __ROR4__(v70, 19);
      v83 = v29 + 1518500249 + v69;
      LODWORD(v81) = v80;
      v84 = v81 >> 27;
      v85 = v83 + v82;
      v86 = v41 + 1518500249 + v74;
      v87 = __PAIR64__(v85, __ROR4__(v85, 23));
      v88 = (v84 | __ROR4__(v75, 29)) & v87 | v84 & __ROR4__(v75, 29);
      LODWORD(v87) = v85;
      v89 = v87 >> 23;
      v90 = v86 + v88;
      v91 = __PAIR64__(v90, __ROR4__(v90, 19));
      v92 = (v89 | __ROR4__(v80, 27)) & v91 | v89 & __ROR4__(v80, 27);
      v93 = v14 + 1518500249 + v79;
      LODWORD(v91) = v90;
      v94 = v91 >> 19;
      v95 = v93 + v92;
      v96 = v22 + 1518500249 + v84;
      v97 = __PAIR64__(v95, __ROR4__(v95, 29));
      v98 = (v94 | __ROR4__(v85, 23)) & v97 | v94 & __ROR4__(v85, 23);
      LODWORD(v97) = v95;
      v99 = v97 >> 29;
      v100 = v96 + v98;
      v101 = __PAIR64__(v100, __ROR4__(v100, 27));
      v102 = (v99 | __ROR4__(v90, 19)) & v101 | v99 & __ROR4__(v90, 19);
      v103 = v37 + 1518500249 + v89;
      LODWORD(v101) = v100;
      v104 = v101 >> 27;
      v105 = v103 + v102;
      v106 = v46 + 1518500249 + v94;
      v107 = __PAIR64__(v105, __ROR4__(v105, 23));
      v108 = (v104 | __ROR4__(v95, 29)) & v107 | v104 & __ROR4__(v95, 29);
      LODWORD(v107) = v105;
      v109 = v107 >> 23;
      v110 = v106 + v108;
      v111 = __PAIR64__(v110, __ROR4__(v110, 19));
      v112 = (v109 | __ROR4__(v100, 27)) & v111 | v109 & __ROR4__(v100, 27);
      v113 = v13 + 1518500249 + v99;
      LODWORD(v111) = v110;
      v114 = v111 >> 19;
      v115 = v113 + v112;
      v116 = v23 + 1518500249 + v104;
      v117 = __PAIR64__(v115, __ROR4__(v115, 29));
      v118 = (v114 | __ROR4__(v105, 23)) & v117 | v114 & __ROR4__(v105, 23);
      LODWORD(v117) = v115;
      v119 = v117 >> 29;
      v120 = v116 + v118;
      v121 = __PAIR64__(v120, __ROR4__(v120, 27));
      v122 = (v119 | __ROR4__(v110, 19)) & v121 | v119 & __ROR4__(v110, 19);
      v123 = v36 + 1518500249 + v109;
      LODWORD(v121) = v120;
      v124 = v121 >> 27;
      v125 = v123 + v122;
      v126 = v45 + 1518500249 + v114 + ((v124 | __ROR4__(v115, 29)) & __ROR4__(v125, 23) | v124 & __ROR4__(v115, 29));
      HIDWORD(v121) = v126;
      LODWORD(v121) = v126;
      v127 = v121 >> 19;
      v128 = *a2 + 1859775393 + v119;
      v129 = v127 ^ __ROR4__(v125, 23);
      v130 = v128 + (v129 ^ __ROR4__(v120, 27));
      v131 = __PAIR64__(v125, __ROR4__(v130, 29));
      v132 = v30 + 1859775393 + v124 + (v129 ^ v131);
      LODWORD(v131) = v125;
      v133 = v19 + 1859775393 + (v131 >> 23);
      HIDWORD(v131) = v130;
      LODWORD(v131) = v130;
      v134 = v131 >> 29;
      v135 = __PAIR64__(v132, __ROR4__(v132, 23));
      v136 = v133 + (v134 ^ __ROR4__(v126, 19) ^ v135);
      v137 = v14 + 1859775393 + v134;
      LODWORD(v135) = v132;
      v138 = v135 >> 23;
      v139 = __PAIR64__(v136, __ROR4__(v136, 21));
      v140 = v42 + 1859775393 + v127 + (v138 ^ __ROR4__(v130, 29) ^ v139);
      LODWORD(v139) = v136;
      v141 = v139 >> 21;
      v142 = __PAIR64__(v140, __ROR4__(v140, 17));
      v143 = v137 + (v141 ^ __ROR4__(v132, 23) ^ v142);
      v144 = v37 + 1859775393 + v138;
      LODWORD(v142) = v140;
      v145 = v142 >> 17;
      v146 = __PAIR64__(v143, __ROR4__(v143, 29));
      v147 = v144 + (v145 ^ __ROR4__(v136, 21) ^ v146);
      v148 = v22 + 1859775393 + v141;
      LODWORD(v146) = v143;
      v149 = v146 >> 29;
      v150 = __PAIR64__(v147, __ROR4__(v147, 23));
      v151 = v148 + (v149 ^ __ROR4__(v140, 17) ^ v150);
      LODWORD(v150) = v147;
      v152 = v150 >> 23;
      v153 = __PAIR64__(v151, __ROR4__(v151, 21));
      v154 = v46 + 1859775393 + v145 + (v152 ^ __ROR4__(v143, 29) ^ v153);
      v155 = v7 + 1859775393 + v149;
      LODWORD(v153) = v151;
      v156 = v153 >> 21;
      v157 = __PAIR64__(v154, __ROR4__(v154, 17));
      v158 = v155 + (v156 ^ __ROR4__(v147, 23) ^ v157);
      v159 = v18 + 1859775393 + v156;
      LODWORD(v157) = v154;
      v160 = v157 >> 17;
      v161 = __PAIR64__(v158, __ROR4__(v158, 29));
      v162 = v29 + 1859775393 + v152 + (v160 ^ __ROR4__(v151, 21) ^ v161);
      LODWORD(v161) = v158;
      v163 = v161 >> 29;
      v164 = __PAIR64__(v162, __ROR4__(v162, 23));
      v165 = v159 + (v163 ^ __ROR4__(v154, 17) ^ v164);
      v166 = v41 + 1859775393 + v160;
      LODWORD(v164) = v162;
      v167 = v164 >> 23;
      v168 = __PAIR64__(v165, __ROR4__(v165, 21));
      v169 = v166 + (v167 ^ __ROR4__(v158, 29) ^ v168);
      v170 = v13 + 1859775393 + v163;
      LODWORD(v168) = v165;
      result = (v168 >> 21);
      v171 = __PAIR64__(v169, __ROR4__(v169, 17));
      v172 = v170 + (result ^ __ROR4__(v162, 23) ^ v171);
      v173 = v36 + 1859775393 + v167;
      LODWORD(v171) = v169;
      v174 = v171 >> 17;
      v175 = __PAIR64__(v172, __ROR4__(v172, 29));
      v176 = v173 + (v174 ^ __ROR4__(v165, 21) ^ v175);
      LODWORD(v175) = v172;
      v177 = v175 >> 29;
      v178 = __PAIR64__(v176, __ROR4__(v176, 23));
      v179 = v23 + 1859775393 + result + (v177 ^ __ROR4__(v169, 17) ^ v178);
      LODWORD(v178) = v176;
      v180 = v178 >> 23;
      v181 = __PAIR64__(v179, __ROR4__(v179, 21));
      v182 = v45 + 1859775393 + v174 + (v180 ^ __ROR4__(v172, 29) ^ v181);
      LODWORD(v181) = v179;
      v6 += v177;
      v4 += v181 >> 21;
      v3 += v180;
      HIDWORD(v181) = v182;
      LODWORD(v181) = v182;
      v5 += v181 >> 17;
      *v183 = v6;
      v183[1] = v5;
      v183[2] = v4;
      v183[3] = v3;
      a2 += 16;
      a3 = v184 - 1;
    }
    while (v184 != 1);
  }
  return result;
}

void MD4_Transform(MD4_CTX *c, const unsigned __int8 *b)
{
  md4_block_data_order((unint64_t)c, b, 1);
}

int MD4_Final(unsigned __int8 *md, MD4_CTX *c)
{
  unsigned int *data;
  uint64_t num;
  uint64_t v6;
  unsigned int Nh;

  data = c->data;
  num = c->num;
  *((_BYTE *)c->data + num) = 0x80;
  v6 = num + 1;
  if (num >= 0x38)
  {
    bzero((char *)data + v6, 63 - num);
    md4_block_data_order((unint64_t)c, data, 1);
    v6 = 0;
  }
  bzero((char *)data + v6, 56 - v6);
  Nh = c->Nh;
  c->data[14] = c->Nl;
  c->data[15] = Nh;
  md4_block_data_order((unint64_t)c, data, 1);
  c->num = 0;
  *(_OWORD *)data = 0u;
  *((_OWORD *)data + 1) = 0u;
  *((_OWORD *)data + 2) = 0u;
  *((_OWORD *)data + 3) = 0u;
  *(_DWORD *)md = c->A;
  *((_DWORD *)md + 1) = c->B;
  *((_DWORD *)md + 2) = c->C;
  *((_DWORD *)md + 3) = c->D;
  return 1;
}

int MD4_Init(MD4_CTX *c)
{
  *(_OWORD *)&c->data[13] = 0u;
  *(_OWORD *)&c->data[6] = 0u;
  *(_OWORD *)&c->data[10] = 0u;
  *(_OWORD *)&c->Nl = 0u;
  *(_OWORD *)&c->data[2] = 0u;
  *(_OWORD *)&c->A = xmmword_22D69F860;
  return 1;
}

uint64_t ecdh_KDF_X9_63(char *a1, unint64_t a2, const void *a3, size_t a4, const void *a5, size_t a6, const EVP_MD *a7)
{
  size_t v14;
  EVP_MD_CTX *v16;
  EVP_MD_CTX *v17;
  int v18;
  unsigned int v19;
  uint64_t v20;
  unsigned int d;
  unsigned __int8 md[64];
  uint64_t v24;

  v24 = *MEMORY[0x24BDAC8D0];
  if (a4 > 0x40000000 || a2 > 0x40000000 || a6 > 0x40000000)
    return 0;
  v14 = a2;
  v16 = (EVP_MD_CTX *)EVP_MD_CTX_new();
  if (!v16)
    return 0;
  v17 = v16;
  v18 = EVP_MD_size(a7);
  if (EVP_DigestInit_ex(v17, a7, 0))
  {
    v19 = 1;
    do
    {
      d = bswap32(v19);
      if (!EVP_DigestUpdate(v17, a3, a4) || !EVP_DigestUpdate(v17, &d, 4uLL) || !EVP_DigestUpdate(v17, a5, a6))
        break;
      if (v14 < v18)
      {
        if (!EVP_DigestFinal(v17, md, 0))
          break;
        memcpy(a1, md, v14);
        explicit_bzero(md, v18);
LABEL_22:
        v20 = 1;
        goto LABEL_24;
      }
      if (!EVP_DigestFinal(v17, (unsigned __int8 *)a1, 0))
        break;
      v14 -= v18;
      if (!v14)
        goto LABEL_22;
      a1 += v18;
      ++v19;
    }
    while (EVP_DigestInit_ex(v17, a7, 0));
  }
  v20 = 0;
LABEL_24:
  EVP_MD_CTX_free(v17);
  return v20;
}

void DES_cfb_encrypt(const unsigned __int8 *in, unsigned __int8 *out, int numbits, uint64_t length, DES_key_schedule *schedule, DES_cblock *ivec, int enc)
{
  int v7;
  int v8;
  unint64_t v9;
  int v12;
  int v13;
  unsigned int v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t *v18;
  int v19;
  int v20;
  const unsigned __int8 *v21;
  int v22;
  int v23;
  int v24;
  int v25;
  int v26;
  int v27;
  int v28;
  int v29;
  int v30;
  unint64_t v31;
  int v32;
  unsigned __int8 *v33;
  uint64_t i;
  unint64_t *v35;
  uint64_t v36;
  unsigned int v37;
  uint64_t v38;
  int v39;
  const unsigned __int8 *v40;
  int v41;
  int v42;
  int v43;
  int v44;
  int v45;
  int v46;
  int v47;
  int v48;
  int v49;
  int v50;
  uint64_t j;
  unsigned __int8 *v52;
  unsigned int v53;
  int v54;
  unint64_t v58;
  int v59;
  int v60;
  unsigned int data;
  int v62;
  uint64_t v63;

  v63 = *MEMORY[0x24BDAC8D0];
  v7 = numbits + 7;
  if (numbits >= 0)
    v8 = numbits;
  else
    v8 = numbits + 7;
  if (v7 < 0)
    v7 = numbits + 14;
  if ((numbits - 65) >= 0xFFFFFFC0)
  {
    v9 = length;
    v12 = v8 >> 3;
    v13 = v7 >> 3;
    v14 = numbits - (v8 & 0xFFFFFFF8);
    LODWORD(v16) = *(_DWORD *)ivec;
    LODWORD(v15) = *(_DWORD *)&(*ivec)[4];
    v17 = v13;
    if (enc)
    {
      if (v13 <= (unint64_t)length)
      {
        v18 = (unint64_t *)((char *)&v58 + v12);
        v19 = v13 - 1;
        do
        {
          data = v16;
          v62 = v15;
          DES_encrypt1(&data, schedule, 1);
          v20 = 0;
          v21 = &in[v17];
          v22 = 0;
          switch(v19)
          {
            case 0:
              goto LABEL_18;
            case 1:
              goto LABEL_17;
            case 2:
              goto LABEL_16;
            case 3:
              goto LABEL_15;
            case 4:
              goto LABEL_14;
            case 5:
              goto LABEL_13;
            case 6:
              goto LABEL_12;
            case 7:
              v23 = *--v21;
              v20 = v23 << 24;
LABEL_12:
              v24 = *--v21;
              v20 |= v24 << 16;
LABEL_13:
              v25 = *--v21;
              v20 |= v25 << 8;
LABEL_14:
              v26 = *--v21;
              v20 |= v26;
LABEL_15:
              v22 = v20;
              v27 = *--v21;
              v20 = v27 << 24;
LABEL_16:
              v28 = *--v21;
              v20 |= v28 << 16;
LABEL_17:
              v29 = *--v21;
              v20 |= v29 << 8;
LABEL_18:
              v30 = *--v21;
              v20 |= v30;
              break;
            default:
              v22 = 0;
              break;
          }
          LODWORD(v31) = data ^ v20;
          v32 = v62 ^ v22;
          v33 = &out[v17];
          switch(v19)
          {
            case 0:
              goto LABEL_27;
            case 1:
              goto LABEL_26;
            case 2:
              goto LABEL_25;
            case 3:
              goto LABEL_24;
            case 4:
              goto LABEL_23;
            case 5:
              goto LABEL_22;
            case 6:
              goto LABEL_21;
            case 7:
              *--v33 = HIBYTE(v32);
LABEL_21:
              *--v33 = BYTE2(v32);
LABEL_22:
              *--v33 = BYTE1(v32);
LABEL_23:
              *--v33 = v32;
LABEL_24:
              *--v33 = BYTE3(v31);
LABEL_25:
              *--v33 = BYTE2(v31);
LABEL_26:
              *--v33 = BYTE1(v31);
LABEL_27:
              *--v33 = v31;
              break;
            default:
              break;
          }
          if (numbits != 32)
          {
            if (numbits == 64)
            {
              LODWORD(v15) = v31;
              LODWORD(v31) = v32;
            }
            else
            {
              v58 = __PAIR64__(v15, v16);
              v59 = v31;
              v60 = v32;
              if (v14)
              {
                for (i = 0; i != 8; ++i)
                  *((_BYTE *)&v58 + i) = (*((unsigned __int8 *)v18 + i + 1) >> (8 - v14)) | (*((unsigned __int8 *)v18 + i) << v14);
                LODWORD(v15) = v58;
                LODWORD(v31) = HIDWORD(v58);
              }
              else
              {
                v15 = *v18;
                v58 = v15;
                v31 = HIDWORD(v15);
              }
            }
          }
          LODWORD(v16) = v15;
          v9 -= v17;
          in = &v21[v17];
          out = &v33[v17];
          LODWORD(v15) = v31;
        }
        while (v9 >= v17);
        goto LABEL_42;
      }
    }
    else if (v13 <= (unint64_t)length)
    {
      v35 = (unint64_t *)((char *)&v58 + v12);
      v36 = (v13 - 1);
      v37 = *(_DWORD *)ivec;
      do
      {
        data = v37;
        v62 = v15;
        v38 = v36;
        DES_encrypt1(&data, schedule, 1);
        v36 = v38;
        v39 = 0;
        v40 = &in[v17];
        v41 = 0;
        v42 = numbits;
        switch((int)v38)
        {
          case 0:
            goto LABEL_52;
          case 1:
            goto LABEL_51;
          case 2:
            goto LABEL_50;
          case 3:
            goto LABEL_49;
          case 4:
            goto LABEL_48;
          case 5:
            goto LABEL_47;
          case 6:
            goto LABEL_46;
          case 7:
            v43 = *--v40;
            v39 = v43 << 24;
LABEL_46:
            v44 = *--v40;
            v39 |= v44 << 16;
LABEL_47:
            v45 = *--v40;
            v39 |= v45 << 8;
LABEL_48:
            v46 = *--v40;
            v39 |= v46;
LABEL_49:
            v41 = v39;
            v47 = *--v40;
            v39 = v47 << 24;
LABEL_50:
            v48 = *--v40;
            v39 |= v48 << 16;
LABEL_51:
            v49 = *--v40;
            v39 |= v49 << 8;
LABEL_52:
            v50 = *--v40;
            v39 |= v50;
            break;
          default:
            v41 = 0;
            v42 = numbits;
            break;
        }
        if (v42 == 32)
        {
          LODWORD(v16) = v15;
          LODWORD(v31) = v39;
        }
        else
        {
          LODWORD(v16) = v39;
          LODWORD(v31) = v41;
          if (v42 != 64)
          {
            v58 = __PAIR64__(v15, v37);
            v59 = v39;
            v60 = v41;
            if (v14)
            {
              for (j = 0; j != 8; ++j)
                *((_BYTE *)&v58 + j) = (*((unsigned __int8 *)v35 + j + 1) >> (8 - v14)) | (*((unsigned __int8 *)v35 + j) << v14);
              LODWORD(v16) = v58;
              LODWORD(v31) = HIDWORD(v58);
            }
            else
            {
              v16 = *v35;
              v58 = v16;
              v31 = HIDWORD(v16);
            }
          }
        }
        v52 = &out[v17];
        v53 = data ^ v39;
        v54 = v62 ^ v41;
        switch((int)v36)
        {
          case 0:
            goto LABEL_69;
          case 1:
            goto LABEL_68;
          case 2:
            goto LABEL_67;
          case 3:
            goto LABEL_66;
          case 4:
            goto LABEL_65;
          case 5:
            goto LABEL_64;
          case 6:
            goto LABEL_63;
          case 7:
            *--v52 = HIBYTE(v54);
LABEL_63:
            *--v52 = BYTE2(v54);
LABEL_64:
            *--v52 = BYTE1(v54);
LABEL_65:
            *--v52 = v54;
LABEL_66:
            *--v52 = HIBYTE(v53);
LABEL_67:
            *--v52 = BYTE2(v53);
LABEL_68:
            *--v52 = BYTE1(v53);
LABEL_69:
            *--v52 = v53;
            break;
          default:
            break;
        }
        v9 -= v17;
        in = &v40[v17];
        out = &v52[v17];
        LODWORD(v15) = v31;
        v37 = v16;
      }
      while (v9 >= v17);
      goto LABEL_42;
    }
    LODWORD(v31) = *(_DWORD *)&(*ivec)[4];
LABEL_42:
    *(_WORD *)ivec = v16;
    (*ivec)[2] = BYTE2(v16);
    (*ivec)[3] = BYTE3(v16);
    *(_WORD *)&(*ivec)[4] = v31;
    (*ivec)[6] = BYTE2(v31);
    (*ivec)[7] = BYTE3(v31);
  }
}

int ENGINE_ctrl(ENGINE *e, int cmd, uint64_t i, void *p, void (*f)(void))
{
  uint64_t v8;
  int v10;
  uint64_t (*v11)(ENGINE *, uint64_t, uint64_t, void *, void (*)(void));
  const char *v12;
  uint64_t v13;
  int v14;
  int v15;
  int v16;
  int v17;
  BOOL v19;
  uint64_t v20;
  const char *v21;
  int v22;
  unsigned int v23;
  unsigned int v24;
  _DWORD *v25;
  unsigned int v26;
  uint64_t v27;
  uint64_t v28;
  const char *v29;
  size_t v30;
  int v31;
  const char *v32;
  uint64_t v33;
  uint64_t v34;
  const char *v35;
  size_t v36;

  if (!e)
  {
    v14 = 67;
    v15 = 198;
    goto LABEL_14;
  }
  v8 = *(_QWORD *)&cmd;
  CRYPTO_lock(9, 30, 0, 0);
  v10 = *((_DWORD *)e + 45);
  CRYPTO_lock(10, 30, 0, 0);
  if (v10 <= 0)
  {
    v14 = 130;
    v15 = 206;
    goto LABEL_14;
  }
  v11 = (uint64_t (*)(ENGINE *, uint64_t, uint64_t, void *, void (*)(void)))*((_QWORD *)e + 17);
  LODWORD(v12) = v11 != 0;
  if ((v8 - 11) >= 8)
  {
    if ((_DWORD)v8 == 10)
      return (int)v12;
    if (v11)
      goto LABEL_21;
    v14 = 120;
    v15 = 236;
LABEL_14:
    ERR_put_error(38, 4095, v14, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/engine/eng_ctrl.c", v15);
    goto LABEL_15;
  }
  if (!v11)
  {
    v16 = 120;
    v17 = 225;
LABEL_18:
    ERR_put_error(38, 4095, v16, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/engine/eng_ctrl.c", v17);
    LODWORD(v12) = -1;
    return (int)v12;
  }
  if ((*((_BYTE *)e + 176) & 2) != 0)
  {
LABEL_21:
    LODWORD(v12) = v11(e, v8, i, p, f);
    return (int)v12;
  }
  if ((_DWORD)v8 == 11)
  {
    v13 = *((_QWORD *)e + 21);
    if (v13 && *(_DWORD *)v13)
    {
      if (*(_QWORD *)(v13 + 8))
        LODWORD(v12) = *(_DWORD *)v13;
      else
        LODWORD(v12) = 0;
      return (int)v12;
    }
LABEL_15:
    LODWORD(v12) = 0;
    return (int)v12;
  }
  v19 = (_DWORD)v8 == 17 || (_DWORD)v8 == 15 || (_DWORD)v8 == 13;
  if (v19 && !p)
  {
    v16 = 67;
    v17 = 128;
    goto LABEL_18;
  }
  v20 = *((_QWORD *)e + 21);
  if ((_DWORD)v8 == 13)
  {
    if (v20 && *(_DWORD *)v20)
    {
      do
      {
        v21 = *(const char **)(v20 + 8);
        if (!v21)
          break;
        if (!strcmp(v21, (const char *)p))
        {
          LODWORD(v12) = *(_DWORD *)v20;
          return (int)v12;
        }
        v22 = *(_DWORD *)(v20 + 32);
        v20 += 32;
      }
      while (v22);
    }
    v16 = 137;
    v17 = 136;
    goto LABEL_18;
  }
  if (!v20)
    goto LABEL_54;
  v23 = *(_DWORD *)v20;
  if (*(_DWORD *)v20)
  {
    v24 = 0;
    v25 = (_DWORD *)(v20 + 32);
    do
    {
      if (v23 >= i)
        break;
      if (!*((_QWORD *)v25 - 3))
        break;
      ++v24;
      v26 = *v25;
      v25 += 8;
      v23 = v26;
    }
    while (v26);
  }
  else
  {
    v24 = 0;
  }
  if (v23 != (_DWORD)i)
  {
LABEL_54:
    v16 = 138;
    v17 = 145;
    goto LABEL_18;
  }
  switch((int)v8)
  {
    case 12:
      v27 = v24 + 1;
      if (!*(_DWORD *)(v20 + 32 * v27))
        goto LABEL_15;
      if (*(_QWORD *)(v20 + 32 * v27 + 8))
        LODWORD(v12) = *(_DWORD *)(v20 + 32 * v27);
      else
        LODWORD(v12) = 0;
      return (int)v12;
    case 14:
      LODWORD(v12) = strlen(*(const char **)(v20 + 32 * v24 + 8));
      return (int)v12;
    case 15:
      v28 = v24;
      v29 = *(const char **)(v20 + 32 * v24 + 8);
      v30 = strlen(v29);
      v31 = snprintf((char *)p, v30 + 1, "%s", v29);
      v32 = *(const char **)(*((_QWORD *)e + 21) + 32 * v28 + 8);
      goto LABEL_63;
    case 16:
      v12 = *(const char **)(v20 + 32 * v24 + 16);
      if (v12)
        LODWORD(v12) = strlen(v12);
      return (int)v12;
    case 17:
      v33 = v24;
      v34 = v20 + 32 * v24;
      v35 = *(const char **)(v34 + 16);
      if (v35)
      {
        v36 = strlen(*(const char **)(v34 + 16));
        v31 = snprintf((char *)p, v36 + 1, "%s", v35);
        v32 = *(const char **)(*((_QWORD *)e + 21) + 32 * v33 + 16);
LABEL_63:
        if (strlen(v32) + 1 <= v31)
          LODWORD(v12) = -1;
        else
          LODWORD(v12) = v31;
      }
      else
      {
        LODWORD(v12) = 0;
        *(_BYTE *)p = 0;
      }
      break;
    case 18:
      LODWORD(v12) = *(_DWORD *)(v20 + 32 * v24 + 24);
      return (int)v12;
    default:
      v16 = 110;
      v17 = 188;
      goto LABEL_18;
  }
  return (int)v12;
}

int ENGINE_cmd_is_executable(ENGINE *e, int cmd)
{
  int v2;

  v2 = ENGINE_ctrl(e, 18, cmd, 0, 0);
  if ((v2 & 0x80000000) == 0)
    return (v2 & 7) != 0;
  ERR_put_error(38, 4095, 138, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/engine/eng_ctrl.c", 249);
  return 0;
}

int ENGINE_ctrl_cmd(ENGINE *e, const char *cmd_name, uint64_t i, void *p, void (*f)(void), int cmd_optional)
{
  int v11;
  int v13;
  int v14;

  if (!e || !cmd_name)
  {
    v13 = 67;
    v14 = 266;
LABEL_7:
    ERR_put_error(38, 4095, v13, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/engine/eng_ctrl.c", v14);
    return 0;
  }
  if (*((_QWORD *)e + 17))
  {
    v11 = ENGINE_ctrl(e, 13, 0, (void *)cmd_name, 0);
    if (v11 > 0)
      return ENGINE_ctrl(e, v11, i, p, f) > 0;
  }
  if (!cmd_optional)
  {
    v13 = 137;
    v14 = 282;
    goto LABEL_7;
  }
  ERR_clear_error();
  return 1;
}

int ENGINE_ctrl_cmd_string(ENGINE *e, const char *cmd_name, const char *arg, int cmd_optional)
{
  int v7;
  unsigned int v8;
  int v9;
  int v10;
  int v11;
  ENGINE *v13;
  int v14;
  uint64_t v15;
  char *v16;
  uint64_t v17;
  char *__endptr;

  if (!e || !cmd_name)
  {
    v10 = 67;
    v11 = 303;
    goto LABEL_13;
  }
  if (!*((_QWORD *)e + 17) || (v7 = ENGINE_ctrl(e, 13, 0, (void *)cmd_name, 0), v7 <= 0))
  {
    if (cmd_optional)
    {
      ERR_clear_error();
      return 1;
    }
    v10 = 137;
    v11 = 319;
    goto LABEL_13;
  }
  v8 = v7;
  if (!ENGINE_cmd_is_executable(e, v7))
  {
    v10 = 134;
    v11 = 323;
    goto LABEL_13;
  }
  v9 = ENGINE_ctrl(e, 18, v8, 0, 0);
  if (v9 < 0)
  {
    v10 = 110;
    v11 = 330;
    goto LABEL_13;
  }
  if ((v9 & 4) != 0)
  {
    if (arg)
    {
      v10 = 136;
      v11 = 337;
      goto LABEL_13;
    }
    v13 = e;
    v14 = v8;
    v15 = 0;
    goto LABEL_24;
  }
  if (!arg)
  {
    v10 = 135;
    v11 = 351;
    goto LABEL_13;
  }
  if ((v9 & 2) != 0)
  {
    v13 = e;
    v14 = v8;
    v15 = 0;
    v16 = (char *)arg;
    return ENGINE_ctrl(v13, v14, v15, v16, 0) > 0;
  }
  if ((v9 & 1) != 0)
  {
    __endptr = 0;
    v17 = strtol(arg, &__endptr, 10);
    if (__endptr == arg || *__endptr)
    {
      v10 = 133;
      v11 = 371;
      goto LABEL_13;
    }
    v15 = v17;
    v13 = e;
    v14 = v8;
LABEL_24:
    v16 = 0;
    return ENGINE_ctrl(v13, v14, v15, v16, 0) > 0;
  }
  v10 = 110;
  v11 = 366;
LABEL_13:
  ERR_put_error(38, 4095, v10, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/engine/eng_ctrl.c", v11);
  return 0;
}

int ASN1_PRINTABLE_type(const unsigned __int8 *s, int max)
{
  int v2;
  int v3;
  unsigned int v4;
  signed __int8 v5;
  BOOL v6;

  if (!s || max < 1)
    return 19;
  v2 = 0;
  v3 = 0;
  v4 = max + 1;
  do
  {
    v5 = *s;
    if (!*s)
      break;
    if ((v5 - 97) >= 0x1A && (v5 - 43) >= 0x10u)
    {
      v6 = v5 != 32 && (v5 - 65) >= 0x1Au;
      if (v6 && (v5 > 0x3F || ((1 << v5) & 0xA000038000000000) == 0))
        v3 = 1;
    }
    ++s;
    if (v5 < 0)
      v2 = 1;
    --v4;
  }
  while (v4 > 1);
  if (v2)
    return 20;
  if (v3)
    return 22;
  else
    return 19;
}

int ASN1_UNIVERSALSTRING_to_string(ASN1_UNIVERSALSTRING *s)
{
  int length;
  unsigned __int8 *data;
  uint64_t v4;
  unsigned __int8 *v5;
  uint64_t v6;
  int v7;

  if (s->type != 28)
    return 0;
  length = s->length;
  if ((s->length & 3) != 0)
    return 0;
  data = s->data;
  if (length >= 1)
  {
    v4 = 0;
    while (1)
    {
      v5 = &data[v4];
      if (data[v4] || v5[1] || v5[2])
        return 0;
      v4 += 4;
      if ((int)v4 >= length)
      {
        if (length >= 4)
        {
          v6 = 3;
          do
          {
            *data++ = s->data[v6];
            v6 += 4;
          }
          while (v6 < s->length);
        }
        break;
      }
    }
  }
  *data = 0;
  v7 = s->length;
  s->length /= 4;
  s->type = ASN1_PRINTABLE_type(s->data, v7 / 4);
  return 1;
}

ASN1_TYPE *ASN1_TYPE_new(void)
{
  return (ASN1_TYPE *)ASN1_item_new(&ASN1_ANY_it);
}

void ASN1_TYPE_free(ASN1_TYPE *a)
{
  ASN1_item_free((ASN1_VALUE *)a, &ASN1_ANY_it);
}

int ASN1_TYPE_get(ASN1_TYPE *a)
{
  int result;

  result = a->type;
  if ((result | 4) != 5 && !a->value.ptr)
    return 0;
  return result;
}

void ASN1_TYPE_set(ASN1_TYPE *a, int type, void *value)
{
  ASN1_BOOLEAN v5;
  ASN1_VALUE *pval;

  pval = (ASN1_VALUE *)a;
  if (a->value.ptr)
  {
    ASN1_primitive_free(&pval, 0);
    a = (ASN1_TYPE *)pval;
  }
  a->type = type;
  if (type == 1)
  {
    if (value)
      v5 = 255;
    else
      v5 = 0;
    a->value.BOOLean = v5;
  }
  else
  {
    a->value.ptr = (char *)value;
  }
}

int ASN1_TYPE_set1(ASN1_TYPE *a, int type, const void *value)
{
  void *v5;
  char *v6;
  ASN1_VALUE *pval;

  if (type == 1 || !value)
    goto LABEL_10;
  if (type != 6)
  {
    v5 = ASN1_STRING_dup((ASN1_STRING *)value);
    if (!v5)
      return (int)v5;
    value = v5;
LABEL_10:
    ASN1_TYPE_set(a, type, (void *)value);
LABEL_11:
    LODWORD(v5) = 1;
    return (int)v5;
  }
  v5 = OBJ_dup((const ASN1_OBJECT *)value);
  if (v5)
  {
    v6 = (char *)v5;
    pval = (ASN1_VALUE *)a;
    if (a->value.ptr)
    {
      ASN1_primitive_free(&pval, 0);
      a = (ASN1_TYPE *)pval;
    }
    a->type = 6;
    a->value.ptr = v6;
    goto LABEL_11;
  }
  return (int)v5;
}

uint64_t ASN1_TYPE_cmp(const ASN1_OBJECT **a1, uint64_t a2)
{
  uint64_t v2;
  int v3;

  v2 = 0xFFFFFFFFLL;
  if (!a1 || !a2)
    return v2;
  v3 = *(_DWORD *)a1;
  if (*(_DWORD *)a1 != *(_DWORD *)a2)
    return 0xFFFFFFFFLL;
  switch(v3)
  {
    case 1:
      return (*((_DWORD *)a1 + 2) - *(_DWORD *)(a2 + 8));
    case 5:
      return 0;
    case 6:
      return OBJ_cmp(a1[1], *(const ASN1_OBJECT **)(a2 + 8));
    default:
      return ASN1_STRING_cmp((ASN1_STRING *)a1[1], *(ASN1_STRING **)(a2 + 8));
  }
}

int ASN1_TYPE_set_octetstring(ASN1_TYPE *a, unsigned __int8 *data, int len)
{
  ASN1_OCTET_STRING *v6;
  char *v7;
  ASN1_VALUE *pval;

  v6 = ASN1_OCTET_STRING_new();
  if (v6)
  {
    v7 = (char *)v6;
    if (ASN1_STRING_set(v6, data, len))
    {
      pval = (ASN1_VALUE *)a;
      if (a->value.ptr)
      {
        ASN1_primitive_free(&pval, 0);
        a = (ASN1_TYPE *)pval;
      }
      a->type = 4;
      a->value.ptr = v7;
      LODWORD(v6) = 1;
    }
    else
    {
      ASN1_OCTET_STRING_free((ASN1_OCTET_STRING *)v7);
      LODWORD(v6) = 0;
    }
  }
  return (int)v6;
}

int ASN1_TYPE_get_octetstring(ASN1_TYPE *a, unsigned __int8 *data, int max_len)
{
  char *ptr;
  unsigned __int8 *v7;
  int v8;
  int v9;
  int v10;

  if (a->type == 4 && (ptr = a->value.ptr) != 0)
  {
    v7 = ASN1_STRING_data((ASN1_STRING *)ptr);
    v8 = ASN1_STRING_length(a->value.asn1_string);
    v9 = v8;
    if (v8 >= max_len)
      v10 = max_len;
    else
      v10 = v8;
    memcpy(data, v7, v10);
  }
  else
  {
    ERR_put_error(13, 4095, 109, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/a_type.c", 225);
    return -1;
  }
  return v9;
}

int ASN1_TYPE_set_int_octetstring(ASN1_TYPE *a, uint64_t num, unsigned __int8 *data, int len)
{
  ASN1_INTEGER **v8;
  ASN1_OCTET_STRING **v9;
  ASN1_STRING *v10;
  char *v11;
  int v12;
  ASN1_VALUE *pval;

  v8 = (ASN1_INTEGER **)ASN1_item_new(&ASN1_INT_OCTETSTRING_it);
  v9 = v8;
  if (v8
    && ASN1_INTEGER_set(*v8, num)
    && ASN1_OCTET_STRING_set(v9[1], data, len)
    && (v10 = ASN1_item_pack(v9, &ASN1_INT_OCTETSTRING_it, 0)) != 0)
  {
    v11 = (char *)v10;
    pval = (ASN1_VALUE *)a;
    if (a->value.ptr)
    {
      ASN1_primitive_free(&pval, 0);
      a = (ASN1_TYPE *)pval;
    }
    a->type = 16;
    a->value.ptr = v11;
    v12 = 1;
  }
  else
  {
    v12 = 0;
  }
  ASN1_item_free((ASN1_VALUE *)v9, &ASN1_INT_OCTETSTRING_it);
  ASN1_STRING_free(0);
  return v12;
}

int ASN1_TYPE_get_int_octetstring(ASN1_TYPE *a, uint64_t *num, unsigned __int8 *data, int max_len)
{
  char *ptr;
  BOOL v6;
  ASN1_INTEGER **v10;
  ASN1_INTEGER **v11;
  int v12;
  unsigned __int8 *v13;
  int v14;

  ptr = a->value.ptr;
  v6 = a->type != 16 || ptr == 0;
  if (v6 || (v10 = (ASN1_INTEGER **)ASN1_item_unpack((ASN1_STRING *)ptr, &ASN1_INT_OCTETSTRING_it)) == 0)
  {
    ASN1_item_free(0, &ASN1_INT_OCTETSTRING_it);
LABEL_15:
    ERR_put_error(13, 4095, 109, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/a_type.c", 299);
    return -1;
  }
  v11 = v10;
  if (num)
    *num = ASN1_INTEGER_get(*v10);
  if (data)
  {
    v12 = ASN1_STRING_length(v11[1]);
    if (v12 < max_len)
      max_len = v12;
    v13 = ASN1_STRING_data(v11[1]);
    memcpy(data, v13, max_len);
  }
  v14 = ASN1_STRING_length(v11[1]);
  ASN1_item_free((ASN1_VALUE *)v11, &ASN1_INT_OCTETSTRING_it);
  if (v14 == -1)
    goto LABEL_15;
  return v14;
}

ASN1_VALUE *ASN1_TYPE_pack_sequence(ASN1_ITEM *it, void *obj, ASN1_VALUE **a3)
{
  ASN1_STRING *v4;
  ASN1_OCTET_STRING *v5;
  ASN1_VALUE *v6;
  ASN1_VALUE *v7;
  ASN1_VALUE *v8;
  ASN1_VALUE *pval;

  v4 = ASN1_item_pack(obj, it, 0);
  if (!v4)
    return 0;
  v5 = v4;
  if (!a3)
  {
    v6 = ASN1_item_new(&ASN1_ANY_it);
    if (v6)
      goto LABEL_7;
LABEL_10:
    ASN1_OCTET_STRING_free(v5);
    return 0;
  }
  v6 = *a3;
  if (!*a3)
  {
    v7 = ASN1_item_new(&ASN1_ANY_it);
    if (v7)
    {
      v6 = v7;
      *a3 = v7;
      goto LABEL_7;
    }
    goto LABEL_10;
  }
LABEL_7:
  pval = v6;
  v8 = v6;
  if (*((_QWORD *)v6 + 1))
  {
    ASN1_primitive_free(&pval, 0);
    v8 = pval;
  }
  *(_DWORD *)v8 = 16;
  *((_QWORD *)v8 + 1) = v5;
  return v6;
}

void *ASN1_TYPE_unpack_sequence(ASN1_ITEM *it, uint64_t a2)
{
  ASN1_STRING *v3;

  if (a2 && *(_DWORD *)a2 == 16 && (v3 = *(ASN1_STRING **)(a2 + 8)) != 0)
    return ASN1_item_unpack(v3, it);
  else
    return 0;
}

int i2d_ASN1_TYPE(ASN1_TYPE *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &ASN1_ANY_it);
}

ASN1_TYPE *__cdecl d2i_ASN1_TYPE(ASN1_TYPE **a, const unsigned __int8 **in, uint64_t len)
{
  return (ASN1_TYPE *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &ASN1_ANY_it);
}

BN_MONT_CTX *BN_MONT_CTX_new(void)
{
  BN_MONT_CTX *v0;
  BN_MONT_CTX *v1;

  v0 = (BN_MONT_CTX *)malloc_type_calloc(1uLL, 0x50uLL, 0x1010040E9A11DBBuLL);
  v1 = v0;
  if (v0)
  {
    v0->Ni.neg = 1;
    BN_init(&v0->RR);
    BN_init(&v1->N);
  }
  return v1;
}

void BN_MONT_CTX_free(BN_MONT_CTX *mont)
{
  if (mont)
  {
    BN_free(&mont->RR);
    BN_free(&mont->N);
    if ((mont->Ni.neg & 1) != 0)
      free(mont);
  }
}

BN_MONT_CTX *__cdecl BN_MONT_CTX_copy(BN_MONT_CTX *to, BN_MONT_CTX *from)
{
  BN_MONT_CTX *v2;

  v2 = to;
  if (to != from)
  {
    if (bn_copy(&to->RR, &from->RR) && bn_copy(&v2->N, &from->N))
    {
      v2->ri = from->ri;
      v2->Ni.d = from->Ni.d;
      *(_QWORD *)&v2->Ni.top = *(_QWORD *)&from->Ni.top;
    }
    else
    {
      return 0;
    }
  }
  return v2;
}

int BN_MONT_CTX_set(BN_MONT_CTX *mont, const BIGNUM *mod, BN_CTX *ctx)
{
  BIGNUM *v6;
  BIGNUM *v7;
  BIGNUM *v8;
  uint64_t v9;
  BIGNUM *v10;
  BIGNUM *v11;
  BIGNUM *v12;
  BIGNUM *v13;
  _BOOL4 v14;
  int v16;
  unsigned int v17;

  BN_CTX_start(ctx);
  v6 = BN_CTX_get(ctx);
  if (!v6
    || (v7 = v6, (v8 = BN_CTX_get(ctx)) == 0)
    || (v9 = (uint64_t)v8, (v10 = BN_CTX_get(ctx)) == 0)
    || (v11 = v10, (v12 = BN_CTX_get(ctx)) == 0)
    || (v13 = v12, BN_is_zero((uint64_t)mod))
    || !bn_copy(&mont->N, mod))
  {
LABEL_6:
    v14 = 0;
    goto LABEL_7;
  }
  mont->N.neg = 0;
  v16 = BN_num_bits(mod);
  v14 = 0;
  v17 = v16 + 63;
  if (v16 < -63)
    v17 = v16 + 126;
  mont->ri = v17 & 0xFFFFFFC0;
  if ((int)(v17 & 0xFFFFFFC0) <= (int)(v17 >> 6 << 7))
  {
    BN_zero((uint64_t)v11);
    if (BN_set_bit(v11, 64)
      && bn_wexpand((uint64_t)v7, 2uLL)
      && BN_set_word(v7, *mod->d)
      && BN_mod_inverse_ct(v13, v11, v7, ctx)
      && BN_lshift((BIGNUM *)v9, v13, 64)
      && (!BN_is_zero(v9) || BN_set_bit((BIGNUM *)v9, 64))
      && BN_sub_word((BIGNUM *)v9, 1uLL)
      && BN_div_ct(v9, 0, (const BIGNUM *)v9, v7, ctx))
    {
      mont->Ni.d = 0;
      *(_QWORD *)&mont->Ni.top = 0;
      if (*(int *)(v9 + 8) >= 1)
        mont->Ni.d = **(unint64_t ***)v9;
      BN_zero((uint64_t)&mont->RR);
      if (BN_set_bit(&mont->RR, 2 * mont->ri))
      {
        v14 = BN_mod_ct(&mont->RR, &mont->RR, &mont->N, ctx) != 0;
        goto LABEL_7;
      }
    }
    goto LABEL_6;
  }
LABEL_7:
  BN_CTX_end(ctx);
  return v14;
}

BN_MONT_CTX *__cdecl BN_MONT_CTX_set_locked(BN_MONT_CTX **pmont, int lock, const BIGNUM *mod, BN_CTX *ctx)
{
  BN_MONT_CTX *v8;
  BN_MONT_CTX *v9;

  CRYPTO_lock(5, lock, 0, 0);
  v8 = *pmont;
  CRYPTO_lock(6, lock, 0, 0);
  if (!v8)
  {
    v9 = BN_MONT_CTX_new();
    v8 = v9;
    if (v9 && BN_MONT_CTX_set(v9, mod, ctx))
    {
      CRYPTO_lock(9, lock, 0, 0);
      if (*pmont)
      {
        BN_MONT_CTX_free(v8);
        v8 = *pmont;
      }
      else
      {
        *pmont = v8;
      }
      CRYPTO_lock(10, lock, 0, 0);
    }
    else
    {
      BN_MONT_CTX_free(v8);
      return 0;
    }
  }
  return v8;
}

unint64_t bn_montgomery_multiply_words(unint64_t *a1, uint64_t *a2, uint64_t a3, const unint64_t *a4, unint64_t *a5, uint64_t a6, int a7)
{
  int v7;
  const unint64_t *v8;
  uint64_t v14;
  size_t v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  unint64_t v19;
  unint64_t v20;
  unint64_t v21;
  uint64_t v22;
  unint64_t v23;
  uint64_t v24;
  unint64_t v25;
  unint64_t v26;
  unint64_t v27;
  unint64_t v28;
  unint64_t v29;
  unint64_t v30;
  unint64_t v31;
  unint64_t v32;
  unint64_t v33;
  unint64_t v34;
  unint64_t v35;
  unint64_t v36;
  unint64_t v37;
  unint64_t v38;
  unint64_t v39;
  unint64_t v40;
  unint64_t v41;
  unint64_t v42;
  unint64_t v43;
  unint64_t v44;
  unint64_t v45;
  unint64_t v46;
  unint64_t v47;
  unint64_t v48;
  unint64_t v49;
  unint64_t v50;
  unint64_t v51;
  unint64_t v52;
  unint64_t v53;
  unint64_t v54;
  unint64_t v55;
  unint64_t v56;
  unint64_t v57;
  unint64_t v58;
  unint64_t v59;
  unint64_t v60;
  unint64_t v61;
  uint64_t v62;
  uint64_t v63;
  unint64_t v64;
  uint64_t v65;
  uint64_t v66;
  unint64_t v67;
  unint64_t v68;
  unint64_t v69;
  unint64_t v70;
  unint64_t v71;
  _BOOL8 v72;
  unint64_t result;
  unint64_t v74;

  v7 = a7;
  v8 = a5;
  if (a7 <= 0)
  {
    v17 = 0;
    v14 = a7;
  }
  else
  {
    v14 = a7;
    v15 = 8 * a7;
    bzero(a5, v15);
    v16 = 0;
    v17 = 0;
    v18 = *a2;
    do
    {
      v19 = 0;
      v20 = 0;
      v21 = 0;
      v22 = *(_QWORD *)(a3 + 8 * v16);
      v23 = (*v8 + v22 * v18) * a6;
      do
      {
        v24 = a2[v19 / 8];
        v25 = v8[v19 / 8];
        v26 = v24 * (unint64_t)v22;
        v27 = HIDWORD(v24) * (unint64_t)v22;
        v28 = HIDWORD(v27) + HIDWORD(v24) * (unint64_t)HIDWORD(v22);
        v29 = v26 | (v27 << 32);
        v30 = v26 & (v27 << 32);
        v31 = (v27 << 32) + v24 * (unint64_t)v22;
        v32 = v29 & ~v31 | v30;
        v33 = v24 * (unint64_t)HIDWORD(v22);
        v34 = v31 | (v33 << 32);
        v35 = v31 & (v33 << 32);
        v36 = v31 + (v33 << 32);
        v37 = v28 + HIDWORD(v33) + (v32 >> 63) + ((v34 & ~v36 | v35) >> 63);
        v38 = v36 | v25;
        v39 = v36 & v25;
        v40 = v36 + v25;
        v41 = v37 + ((v38 & ~v40 | v39) >> 63);
        v42 = v40 | v21;
        v43 = v40 & v21;
        v44 = v40 + v21;
        v21 = v41 + ((v42 & ~v44 | v43) >> 63);
        v45 = a4[v19 / 8];
        v46 = v45 * (unint64_t)v23;
        v47 = HIDWORD(v45) * (unint64_t)v23;
        v48 = HIDWORD(v47) + HIDWORD(v45) * (unint64_t)HIDWORD(v23);
        v49 = v46 | (v47 << 32);
        v50 = v46 & (v47 << 32);
        v51 = (v47 << 32) + v45 * (unint64_t)v23;
        v52 = v49 & ~v51 | v50;
        v53 = v45 * (unint64_t)HIDWORD(v23);
        v54 = v51 | (v53 << 32);
        v55 = v51 & (v53 << 32);
        v56 = v51 + (v53 << 32);
        v57 = v48 + HIDWORD(v53) + (v52 >> 63) + ((v54 & ~v56 | v55) >> 63);
        v58 = v56 | v44;
        v59 = v56 & v44;
        v60 = v56 + v44;
        v61 = v57 + ((v58 & ~v60 | v59) >> 63);
        v62 = v60 | v20;
        v63 = v60 & v20;
        v64 = v60 + v20;
        v20 = v61 + ((v62 & ~v64 | v63) >> 63);
        v8[v19 / 8] = v64;
        v19 += 8;
      }
      while (v15 != v19);
      v65 = v20 | v21;
      v66 = v20 & v21;
      v67 = v20 + v21;
      v68 = v65 & ~v67 | v66;
      v69 = v67 | v17;
      v70 = v67 & v17;
      v71 = v67 + v17;
      v17 = ((v69 & ~v71 | v70) >> 63) + (v68 >> 63);
      v8[v7] = v71;
      ++v8;
      ++v16;
    }
    while (v16 != v7);
  }
  v8[v14] = v17;
  v72 = v17 != 0;
  result = bn_sub_words(a1, v8, a4, v7);
  if (v7 >= 1)
  {
    do
    {
      v74 = *v8++;
      *a1 = v74 & (v72 - result) | *a1 & ~(v72 - result);
      ++a1;
      --v7;
    }
    while (v7);
  }
  return result;
}

uint64_t bn_montgomery_multiply(BIGNUM *a1, uint64_t a2, uint64_t a3, uint64_t a4, BN_CTX *ctx)
{
  size_t v10;
  BIGNUM *v11;
  unint64_t **p_d;
  uint64_t v13;

  BN_CTX_start(ctx);
  v10 = *(unsigned int *)(a4 + 40);
  if ((int)v10 >= 2
    && *(_DWORD *)(a2 + 8) == (_DWORD)v10
    && *(_DWORD *)(a3 + 8) == (_DWORD)v10
    && bn_wexpand((uint64_t)a1, v10)
    && (v11 = BN_CTX_get(ctx)) != 0
    && (p_d = &v11->d, bn_wexpand((uint64_t)v11, (2 * *(_DWORD *)(a4 + 40) + 2))))
  {
    bn_montgomery_multiply_words(a1->d, *(uint64_t **)a2, *(_QWORD *)a3, *(const unint64_t **)(a4 + 32), *p_d, *(_QWORD *)(a4 + 56), *(_DWORD *)(a4 + 40));
    a1->top = *(_DWORD *)(a4 + 40);
    bn_correct_top((uint64_t *)a1);
    BN_set_negative(a1, *(_DWORD *)(a3 + 16) ^ *(_DWORD *)(a2 + 16));
    v13 = 1;
  }
  else
  {
    v13 = 0;
  }
  BN_CTX_end(ctx);
  return v13;
}

uint64_t bn_mod_mul_montgomery(BIGNUM *a1, const BIGNUM *a2, const BIGNUM *a3, uint64_t a4, BN_CTX *ctx)
{
  int v10;
  BIGNUM *v12;
  uint64_t v13;
  uint64_t v14;

  v10 = *(_DWORD *)(a4 + 40);
  if (v10 >= 2 && a2->top == v10 && a3->top == v10)
    return bn_montgomery_multiply(a1, (uint64_t)a2, (uint64_t)a3, a4, ctx);
  BN_CTX_start(ctx);
  v12 = BN_CTX_get(ctx);
  if (!v12)
    goto LABEL_10;
  v13 = (uint64_t)v12;
  if (a2 == a3)
  {
    if (BN_sqr(v12, a2, ctx))
      goto LABEL_8;
LABEL_10:
    v14 = 0;
    goto LABEL_11;
  }
  if (!BN_mul(v12, a2, a3, ctx))
    goto LABEL_10;
LABEL_8:
  v14 = bn_montgomery_reduce(a1, v13, a4);
LABEL_11:
  BN_CTX_end(ctx);
  return v14;
}

uint64_t BN_to_montgomery(BIGNUM *a1, const BIGNUM *a2, uint64_t a3, BN_CTX *ctx)
{
  return bn_mod_mul_montgomery(a1, a2, (const BIGNUM *)(a3 + 8), a3, ctx);
}

int BN_from_montgomery(BIGNUM *r, const BIGNUM *a, BN_MONT_CTX *mont, BN_CTX *ctx)
{
  BIGNUM *v8;
  uint64_t v9;
  int v10;

  BN_CTX_start(ctx);
  v8 = BN_CTX_get(ctx);
  if (v8 && (v9 = (uint64_t)v8, bn_copy(v8, a)))
    v10 = bn_montgomery_reduce(r, v9, (uint64_t)mont);
  else
    v10 = 0;
  BN_CTX_end(ctx);
  return v10;
}

uint64_t bn_montgomery_reduce(BIGNUM *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;
  uint64_t result;
  int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  unint64_t v19;
  uint64_t v20;
  unint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  const unint64_t *v26;
  unint64_t v27;
  unint64_t *d;
  int v29;
  unint64_t v30;

  v4 = *(unsigned int *)(a3 + 40);
  if (!(_DWORD)v4)
  {
    BN_zero((uint64_t)a1);
    return 1;
  }
  result = bn_wexpand((uint64_t)a1, *(unsigned int *)(a3 + 40));
  if (!(_DWORD)result)
    return result;
  v8 = 2 * v4;
  if (2 * (int)v4 < (int)v4)
    return 0;
  result = bn_wexpand(a2, (2 * v4));
  if ((_DWORD)result)
  {
    v9 = *(int *)(a2 + 8);
    v10 = *(_QWORD *)a2;
    if ((int)v9 < v8)
      bzero((void *)(v10 + 8 * v9), 8 * (v8 + ~(_DWORD)v9) + 8);
    if ((int)v4 <= 0)
    {
      v12 = 0;
      v25 = (int)v4;
    }
    else
    {
      v11 = 0;
      v12 = 0;
      v13 = *(_QWORD *)(a3 + 56);
      v14 = 8 * v4;
      do
      {
        v15 = bn_mul_add_words((unint64_t *)(v10 + v11), *(const unint64_t **)(a3 + 32), v4, *(_QWORD *)(v10 + v11) * v13);
        v10 = *(_QWORD *)a2;
        v16 = *(_QWORD *)a2 + v14;
        v17 = *(_QWORD *)(v16 + v11);
        v18 = v17 | v15;
        v19 = v17 & v15;
        v20 = v17 + v15;
        v21 = v18 & ~v20 | v19;
        v22 = v20 | v12;
        v23 = v20 & v12;
        v24 = v20 + v12;
        v12 = ((v22 & ~v24 | (unint64_t)v23) >> 63) + (v21 >> 63);
        *(_QWORD *)(v16 + v11) = v24;
        v11 += 8;
      }
      while (v14 != v11);
      v25 = v4;
    }
    v26 = (const unint64_t *)(v10 + 8 * v25);
    v27 = bn_sub_words(a1->d, v26, *(const unint64_t **)(a3 + 32), v4);
    if ((int)v4 >= 1)
    {
      d = a1->d;
      v29 = v4;
      do
      {
        v30 = *v26++;
        *d = v30 & (v12 - v27) | *d & ~(v12 - v27);
        ++d;
        --v29;
      }
      while (v29);
    }
    a1->top = v4;
    bn_correct_top((uint64_t *)a1);
    BN_set_negative(a1, *(_DWORD *)(a3 + 48) ^ *(_DWORD *)(a2 + 16));
    return 1;
  }
  return result;
}

int DHparams_print(BIO *bp, const DH *x)
{
  return do_dh_print(bp, (uint64_t)x, 4, 0);
}

uint64_t do_dh_print(BIO *a1, uint64_t a2, int a3, int a4)
{
  const BIGNUM *v8;
  const BIGNUM *v9;
  const BIGNUM *v10;
  const BIGNUM *v11;
  int v12;
  int v13;
  unsigned __int8 *v14;
  int v15;
  unsigned int v16;
  const BIGNUM *v17;
  int v18;
  int v19;
  int v20;
  int v21;
  int v22;
  int v23;
  uint64_t v24;
  const char *v25;
  const char *v26;
  int v27;
  int v28;
  uint64_t v29;

  if (a4 == 2)
  {
    v8 = *(const BIGNUM **)(a2 + 40);
LABEL_4:
    v10 = *(const BIGNUM **)(a2 + 32);
    v9 = v8;
    goto LABEL_5;
  }
  v8 = 0;
  v9 = 0;
  v10 = 0;
  if (a4 >= 1)
    goto LABEL_4;
LABEL_5:
  v11 = *(const BIGNUM **)(a2 + 8);
  if (!v11)
    goto LABEL_9;
  v12 = BN_num_bits(v11);
  v13 = v12 + 7;
  if (v12 < -7)
    v13 = v12 + 14;
  if ((v12 + 14) < 0xF)
  {
LABEL_9:
    v14 = 0;
    v15 = 67;
LABEL_43:
    ERR_put_error(5, 4095, v15, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/dh/dh_ameth.c", 382);
    v29 = 0;
    goto LABEL_44;
  }
  v16 = v13 >> 3;
  v17 = *(const BIGNUM **)(a2 + 16);
  if (v17)
  {
    v18 = BN_num_bits(v17);
    v19 = v18 + 7;
    if (v18 < -7)
      v19 = v18 + 14;
    if (v16 <= v19 >> 3)
      v16 = v19 >> 3;
  }
  if (v10)
  {
    v20 = BN_num_bits(v10);
    v21 = v20 + 7;
    if (v20 < -7)
      v21 = v20 + 14;
    if (v16 <= v21 >> 3)
      v16 = v21 >> 3;
  }
  if (v9)
  {
    v22 = BN_num_bits(v9);
    v23 = v22 + 7;
    if (v22 < -7)
      v23 = v22 + 14;
    if (v16 <= v23 >> 3)
      v16 = v23 >> 3;
  }
  v24 = (int)v16;
  v25 = "PKCS#3 DH Parameters";
  if (a4 == 1)
    v25 = "PKCS#3 DH Public-Key";
  if (a4 == 2)
    v26 = "PKCS#3 DH Private-Key";
  else
    v26 = v25;
  v14 = (unsigned __int8 *)malloc_type_malloc(v24 + 10, 0x5C59B9FuLL);
  if (!v14)
  {
    v15 = 65;
    goto LABEL_43;
  }
  if (!BIO_indent(a1, a3, 128)
    || (v27 = BN_num_bits(*(const BIGNUM **)(a2 + 8)), BIO_printf(a1, "%s: (%d bit)\n", v26, v27) < 1)
    || (v28 = a3 + 4, !ASN1_bn_print(a1, "private-key:", v9, v14, v28))
    || !ASN1_bn_print(a1, "public-key:", v10, v14, v28)
    || !ASN1_bn_print(a1, "prime:", *(const BIGNUM **)(a2 + 8), v14, v28)
    || !ASN1_bn_print(a1, "generator:", *(const BIGNUM **)(a2 + 16), v14, v28)
    || *(_QWORD *)(a2 + 24)
    && (!BIO_indent(a1, v28, 128) || BIO_printf(a1, "recommended-private-length: %d bits\n", *(_QWORD *)(a2 + 24)) <= 0))
  {
    v15 = 7;
    goto LABEL_43;
  }
  v29 = 1;
LABEL_44:
  free(v14);
  return v29;
}

int DHparams_print_fp(FILE *fp, const DH *x)
{
  BIO_METHOD *v4;
  BIO *v5;
  BIO *v6;
  int v7;

  v4 = BIO_s_file();
  v5 = BIO_new(v4);
  if (v5)
  {
    v6 = v5;
    BIO_ctrl(v5, 106, 0, fp);
    v7 = do_dh_print(v6, (uint64_t)x, 4, 0);
    BIO_free(v6);
    return v7;
  }
  else
  {
    ERR_put_error(5, 4095, 7, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/dh/dh_ameth.c", 484);
    return 0;
  }
}

uint64_t dh_pub_decode(EVP_PKEY *a1, uint64_t a2)
{
  uint64_t result;
  DH *v4;
  ASN1_INTEGER *v5;
  ASN1_INTEGER *v6;
  BIGNUM *v7;
  int v8;
  X509_ALGOR *algor;
  void *ppval;
  int pptype[2];
  unsigned __int8 *pp;
  unsigned __int8 *in;

  pp = 0;
  in = 0;
  ppval = 0;
  *(_QWORD *)pptype = 0;
  algor = 0;
  result = X509_PUBKEY_get0_param(0, &in, &pptype[1], &algor, a2);
  if ((_DWORD)result)
  {
    X509_ALGOR_get0(0, pptype, &ppval, algor);
    if (pptype[0] == 16)
    {
      pp = (unsigned __int8 *)*((_QWORD *)ppval + 1);
      v4 = d2i_DHparams(0, (const unsigned __int8 **)&pp, *(int *)ppval);
      if (v4)
      {
        v5 = d2i_ASN1_INTEGER(0, (const unsigned __int8 **)&in, pptype[1]);
        if (v5)
        {
          v6 = v5;
          v7 = ASN1_INTEGER_to_BN(v5, 0);
          v4->pub_key = v7;
          if (v7)
          {
            ASN1_INTEGER_free(v6);
            EVP_PKEY_assign(a1, 28, (char *)v4);
            return 1;
          }
          ERR_put_error(5, 4095, 109, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/dh/dh_ameth.c", 114);
          ASN1_INTEGER_free(v6);
          goto LABEL_12;
        }
        v8 = 108;
      }
      else
      {
        v8 = 103;
      }
      ERR_put_error(5, 4095, 104, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/dh/dh_ameth.c", v8);
    }
    else
    {
      ERR_put_error(5, 4095, 105, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/dh/dh_ameth.c", 94);
      v4 = 0;
    }
LABEL_12:
    DH_free(v4);
    return 0;
  }
  return result;
}

uint64_t dh_pub_encode(uint64_t a1, uint64_t a2)
{
  const DH *v3;
  ASN1_STRING *v4;
  ASN1_STRING *v5;
  int v6;
  ASN1_INTEGER *v7;
  ASN1_INTEGER *v8;
  int v9;
  ASN1_OBJECT *v10;
  int v12;
  unsigned __int8 *out;

  out = 0;
  v3 = *(const DH **)(a2 + 32);
  v4 = ASN1_STRING_new();
  v5 = v4;
  if (!v4)
  {
    v12 = 143;
LABEL_10:
    ERR_put_error(5, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/dh/dh_ameth.c", v12);
    goto LABEL_11;
  }
  v6 = i2d_DHparams(v3, &v4->data);
  v5->length = v6;
  if (v6 <= 0)
  {
    v12 = 149;
    goto LABEL_10;
  }
  v7 = BN_to_ASN1_INTEGER(v3->pub_key, 0);
  if (!v7)
    goto LABEL_11;
  v8 = v7;
  v9 = i2d_ASN1_INTEGER(v7, &out);
  ASN1_INTEGER_free(v8);
  if (v9 <= 0)
  {
    v12 = 163;
    goto LABEL_10;
  }
  v10 = OBJ_nid2obj(28);
  if (X509_PUBKEY_set0_param(a1, v10, 16, v5, out, v9))
    return 1;
LABEL_11:
  free(out);
  ASN1_STRING_free(v5);
  return 0;
}

BOOL dh_pub_cmp(uint64_t a1, uint64_t a2)
{
  _BOOL8 result;

  result = dh_cmp_parameters(a1, a2);
  if (result)
    return BN_cmp(*(const BIGNUM **)(*(_QWORD *)(a2 + 32) + 32), *(const BIGNUM **)(*(_QWORD *)(a1 + 32) + 32)) == 0;
  return result;
}

uint64_t dh_public_print(BIO *a1, uint64_t a2, int a3)
{
  return do_dh_print(a1, *(_QWORD *)(a2 + 32), a3, 1);
}

uint64_t dh_priv_decode(EVP_PKEY *a1, uint64_t a2)
{
  uint64_t result;
  ASN1_INTEGER *v4;
  DH *v5;
  DH *v6;
  BIGNUM *v7;
  X509_ALGOR *algor;
  void *ppval;
  int pptype[2];
  unsigned __int8 *pp;
  unsigned __int8 *in;

  pp = 0;
  in = 0;
  ppval = 0;
  *(_QWORD *)pptype = 0;
  algor = 0;
  result = PKCS8_pkey_get0(0, &in, &pptype[1], &algor, a2);
  if ((_DWORD)result)
  {
    X509_ALGOR_get0(0, pptype, &ppval, algor);
    v4 = 0;
    if (pptype[0] == 16
      && (v4 = d2i_ASN1_INTEGER(0, (const unsigned __int8 **)&in, pptype[1])) != 0
      && (pp = (unsigned __int8 *)*((_QWORD *)ppval + 1),
          (v5 = d2i_DHparams(0, (const unsigned __int8 **)&pp, *(int *)ppval)) != 0))
    {
      v6 = v5;
      v7 = ASN1_INTEGER_to_BN(v4, 0);
      v6->priv_key = v7;
      if (v7)
      {
        if (DH_generate_key(v6))
        {
          EVP_PKEY_assign(a1, 28, (char *)v6);
          ASN1_INTEGER_free(v4);
          return 1;
        }
      }
      else
      {
        ERR_put_error(5, 4095, 106, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/dh/dh_ameth.c", 214);
      }
    }
    else
    {
      ERR_put_error(5, 4095, 114, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/dh/dh_ameth.c", 228);
      v6 = 0;
    }
    ASN1_INTEGER_free(v4);
    DH_free(v6);
    return 0;
  }
  return result;
}

uint64_t dh_priv_encode(uint64_t a1, uint64_t a2)
{
  ASN1_STRING *v4;
  int v5;
  ASN1_INTEGER *v6;
  ASN1_INTEGER *v7;
  int v8;
  ASN1_OBJECT *v9;
  int v11;
  int v12;
  unsigned __int8 *v13;
  unsigned __int8 *out;

  out = 0;
  v4 = ASN1_STRING_new();
  if (!v4)
  {
    v11 = 65;
    v12 = 246;
LABEL_9:
    ERR_put_error(5, 4095, v11, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/dh/dh_ameth.c", v12);
    v13 = 0;
    goto LABEL_10;
  }
  v5 = i2d_DHparams(*(const DH **)(a2 + 32), &v4->data);
  v4->length = v5;
  if (v5 <= 0)
  {
    v11 = 65;
    v12 = 252;
    goto LABEL_9;
  }
  v4->type = 16;
  v6 = BN_to_ASN1_INTEGER(*(BIGNUM **)(*(_QWORD *)(a2 + 32) + 40), 0);
  if (!v6)
  {
    v11 = 106;
    v12 = 261;
    goto LABEL_9;
  }
  v7 = v6;
  v8 = i2d_ASN1_INTEGER(v6, &out);
  ASN1_INTEGER_free(v7);
  v9 = OBJ_nid2obj(28);
  if (PKCS8_pkey_set0(a1, v9, 0, 16, v4, out, v8))
    return 1;
  v13 = out;
LABEL_10:
  free(v13);
  ASN1_STRING_free(v4);
  ASN1_INTEGER_free(0);
  return 0;
}

uint64_t dh_private_print(BIO *a1, uint64_t a2, int a3)
{
  return do_dh_print(a1, *(_QWORD *)(a2 + 32), a3, 2);
}

uint64_t int_dh_size(uint64_t a1)
{
  return DH_size(*(const DH **)(a1 + 32));
}

uint64_t dh_bits(uint64_t a1)
{
  return BN_num_bits(*(const BIGNUM **)(*(_QWORD *)(a1 + 32) + 8));
}

uint64_t dh_security_bits(uint64_t a1)
{
  return DH_security_bits(*(_QWORD *)(a1 + 32));
}

uint64_t dh_param_decode(EVP_PKEY *a1, const unsigned __int8 **a2, int a3)
{
  char *v4;

  v4 = (char *)d2i_DHparams(0, a2, a3);
  if (v4)
  {
    EVP_PKEY_assign(a1, 28, v4);
    return 1;
  }
  else
  {
    ERR_put_error(5, 4095, 5, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/dh/dh_ameth.c", 300);
    return 0;
  }
}

uint64_t dh_param_encode(uint64_t a1, unsigned __int8 **a2)
{
  return i2d_DHparams(*(const DH **)(a1 + 32), a2);
}

BOOL dh_missing_parameters(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 32);
  return !*(_QWORD *)(v1 + 8) || *(_QWORD *)(v1 + 16) == 0;
}

BIGNUM *dh_copy_parameters(uint64_t a1, uint64_t a2)
{
  BIGNUM *result;
  BIGNUM *v5;
  BIGNUM *v6;

  result = BN_dup(*(const BIGNUM **)(*(_QWORD *)(a2 + 32) + 8));
  if (result)
  {
    v5 = result;
    BN_free(*(BIGNUM **)(*(_QWORD *)(a1 + 32) + 8));
    *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) = v5;
    result = BN_dup(*(const BIGNUM **)(*(_QWORD *)(a2 + 32) + 16));
    if (result)
    {
      v6 = result;
      BN_free(*(BIGNUM **)(*(_QWORD *)(a1 + 32) + 16));
      *(_QWORD *)(*(_QWORD *)(a1 + 32) + 16) = v6;
      return (BIGNUM *)1;
    }
  }
  return result;
}

BOOL dh_cmp_parameters(uint64_t a1, uint64_t a2)
{
  return !BN_cmp(*(const BIGNUM **)(*(_QWORD *)(a1 + 32) + 8), *(const BIGNUM **)(*(_QWORD *)(a2 + 32) + 8))
      && BN_cmp(*(const BIGNUM **)(*(_QWORD *)(a1 + 32) + 16), *(const BIGNUM **)(*(_QWORD *)(a2 + 32) + 16)) == 0;
}

uint64_t dh_param_print(BIO *a1, uint64_t a2, int a3)
{
  return do_dh_print(a1, *(_QWORD *)(a2 + 32), a3, 0);
}

void int_dh_free(uint64_t a1)
{
  DH_free(*(DH **)(a1 + 32));
}

uint64_t dh_pkey_public_check(uint64_t a1)
{
  const DH *v1;
  const BIGNUM *pub_key;

  v1 = *(const DH **)(a1 + 32);
  pub_key = v1->pub_key;
  if (pub_key)
    return DH_check_pub_key_ex(v1, pub_key);
  ERR_put_error(5, 4095, 125, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/dh/dh_ameth.c", 501);
  return 0;
}

uint64_t dh_pkey_param_check(uint64_t a1)
{
  return DH_check_ex(*(const DH **)(a1 + 32));
}

void ENGINE_unregister_pkey_meths(void *a1)
{
  engine_table_unregister(&pkey_meth_table, a1);
}

uint64_t ENGINE_register_pkey_meths(uint64_t a1)
{
  uint64_t (*v1)(void);
  int v3;

  v1 = *(uint64_t (**)(void))(a1 + 96);
  if (v1 && (v3 = v1(), v3 > 0))
    return engine_table_register(&pkey_meth_table, (uint64_t)engine_unregister_all_pkey_meths, (char *)a1, 0, v3, 0);
  else
    return 1;
}

void engine_unregister_all_pkey_meths()
{
  engine_table_cleanup(&pkey_meth_table);
}

ENGINE *ENGINE_register_all_pkey_meths()
{
  ENGINE *result;
  ENGINE *v1;

  result = ENGINE_get_first();
  if (result)
  {
    v1 = result;
    do
    {
      ENGINE_register_pkey_meths((uint64_t)v1);
      result = ENGINE_get_next(v1);
      v1 = result;
    }
    while (result);
  }
  return result;
}

uint64_t ENGINE_set_default_pkey_meths(uint64_t a1)
{
  uint64_t (*v1)(void);
  int v3;

  v1 = *(uint64_t (**)(void))(a1 + 96);
  if (v1 && (v3 = v1(), v3 > 0))
    return engine_table_register(&pkey_meth_table, (uint64_t)engine_unregister_all_pkey_meths, (char *)a1, 0, v3, 1);
  else
    return 1;
}

uint64_t ENGINE_get_pkey_meth_engine(int a1)
{
  return engine_table_select(&pkey_meth_table, a1);
}

uint64_t ENGINE_get_pkey_meth(uint64_t a1)
{
  unsigned int (*v1)(void);
  uint64_t v3;

  v3 = 0;
  v1 = *(unsigned int (**)(void))(a1 + 96);
  if (v1 && v1())
    return v3;
  ERR_put_error(38, 4095, 101, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/engine/tb_pkmeth.c", 134);
  return 0;
}

uint64_t ENGINE_get_pkey_meths(uint64_t a1)
{
  return *(_QWORD *)(a1 + 96);
}

uint64_t ENGINE_set_pkey_meths(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)(a1 + 96) = a2;
  return 1;
}

void engine_pkey_meths_free(uint64_t a1)
{
  uint64_t (*v1)(void);
  int v3;
  unsigned int *v4;
  uint64_t v5;
  void *v6;

  v1 = *(uint64_t (**)(void))(a1 + 96);
  if (v1)
  {
    v6 = 0;
    v3 = v1();
    if (v3 >= 1)
    {
      v4 = 0;
      v5 = 4 * v3;
      do
      {
        if ((*(unsigned int (**)(uint64_t, void **, _QWORD, _QWORD))(a1 + 96))(a1, &v6, 0, *v4))
          EVP_PKEY_meth_free(v6);
        ++v4;
      }
      while ((unsigned int *)v5 != v4);
    }
  }
}

int RSA_padding_add_none(unsigned __int8 *to, int tlen, const unsigned __int8 *f, int fl)
{
  int v4;
  int v5;

  if (fl <= tlen)
  {
    if (fl >= tlen)
    {
      memcpy(to, f, fl);
      return 1;
    }
    v4 = 122;
    v5 = 76;
  }
  else
  {
    v4 = 110;
    v5 = 71;
  }
  ERR_put_error(4, 4095, v4, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/rsa/rsa_none.c", v5);
  return 0;
}

int RSA_padding_check_none(unsigned __int8 *to, int tlen, const unsigned __int8 *f, int fl, int rsa_len)
{
  int v5;

  if (tlen >= fl)
  {
    v5 = tlen;
    bzero(to, tlen - fl);
    memcpy(&to[v5 - fl], f, fl);
  }
  else
  {
    ERR_put_error(4, 4095, 109, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/rsa/rsa_none.c", 89);
    return -1;
  }
  return v5;
}

BN_CTX *BN_CTX_new(void)
{
  return (BN_CTX *)malloc_type_calloc(1uLL, 0x30uLL, 0x1090040EFEC1FD7uLL);
}

void BN_CTX_free(BN_CTX *c)
{
  unint64_t v2;

  if (c)
  {
    if (*((_QWORD *)c + 4))
    {
      v2 = 0;
      do
      {
        BN_free(*(BIGNUM **)(*(_QWORD *)c + 8 * v2));
        *(_QWORD *)(*(_QWORD *)c + 8 * v2++) = 0;
      }
      while (v2 < *((_QWORD *)c + 4));
    }
    free(*(void **)c);
    free(*((void **)c + 1));
    freezero(c, 0x30uLL);
  }
}

void BN_CTX_start(BN_CTX *ctx)
{
  __int16 v1;

  v1 = (*((_BYTE *)ctx + 16))++ + 1;
  if ((v1 & 0x100) != 0)
  {
    ERR_put_error(3, 4095, 109, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/bn/bn_ctx.c", 99);
    *((_DWORD *)ctx + 10) = 1;
  }
}

BIGNUM *__cdecl BN_CTX_get(BN_CTX *ctx)
{
  BIGNUM *v1;
  unint64_t v3;
  size_t v4;
  int v5;
  int v6;
  char *v7;
  void *v8;
  BIGNUM *v9;

  if (!*((_DWORD *)ctx + 10))
  {
    if (!*((_BYTE *)ctx + 16))
    {
      v5 = 66;
      v6 = 114;
LABEL_18:
      ERR_put_error(3, 4095, v5, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/bn/bn_ctx.c", v6);
      v1 = 0;
      goto LABEL_19;
    }
    v3 = *((_QWORD *)ctx + 3);
    if (v3 != *((_QWORD *)ctx + 4))
    {
LABEL_13:
      v1 = *(BIGNUM **)(*(_QWORD *)ctx + 8 * v3);
      if (v1)
      {
LABEL_16:
        *(_BYTE *)(*((_QWORD *)ctx + 1) + v3) = *((_BYTE *)ctx + 16);
        ++*((_QWORD *)ctx + 3);
        BN_zero((uint64_t)v1);
        return v1;
      }
      v9 = BN_new();
      v1 = v9;
      if (v9)
      {
        v3 = *((_QWORD *)ctx + 3);
        *(_QWORD *)(*(_QWORD *)ctx + 8 * v3) = v9;
        goto LABEL_16;
      }
      ERR_put_error(3, 4095, 109, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/bn/bn_ctx.c", 129);
LABEL_19:
      *((_DWORD *)ctx + 10) = 1;
      return v1;
    }
    if (v3)
    {
      if (__CFADD__(v3, v3))
      {
LABEL_17:
        v5 = 109;
        v6 = 121;
        goto LABEL_18;
      }
      v4 = 2 * v3;
    }
    else
    {
      v4 = 8;
    }
    v7 = recallocarray(*(char **)ctx, v3, v4, 8uLL);
    if (v7)
    {
      *(_QWORD *)ctx = v7;
      v8 = reallocarray(*((void **)ctx + 1), v4, 1uLL);
      if (v8)
      {
        *((_QWORD *)ctx + 1) = v8;
        *((_QWORD *)ctx + 4) = v4;
        v3 = *((_QWORD *)ctx + 3);
        goto LABEL_13;
      }
    }
    goto LABEL_17;
  }
  return 0;
}

void BN_CTX_end(BN_CTX *ctx)
{
  int v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  if (ctx)
  {
    if (!*((_DWORD *)ctx + 10))
    {
      LOBYTE(v2) = *((_BYTE *)ctx + 16);
      if ((_BYTE)v2)
      {
        v3 = *((_QWORD *)ctx + 3);
        if (v3)
        {
          while (1)
          {
            v4 = v3 - 1;
            v2 = *((unsigned __int8 *)ctx + 16);
            if (*(unsigned __int8 *)(*((_QWORD *)ctx + 1) + v4) != v2)
              break;
            BN_zero(*(_QWORD *)(*(_QWORD *)ctx + 8 * v4));
            *(_BYTE *)(*((_QWORD *)ctx + 3) + *((_QWORD *)ctx + 1) - 1) = 0;
            v5 = *((_QWORD *)ctx + 3);
            v3 = v5 - 1;
            *((_QWORD *)ctx + 3) = v5 - 1;
            if (v5 == 1)
            {
              LOBYTE(v2) = *((_BYTE *)ctx + 16);
              break;
            }
          }
        }
        *((_BYTE *)ctx + 16) = v2 - 1;
      }
    }
  }
}

void ERR_load_CRYPTO_strings(void)
{
  if (!ERR_func_error_string(CRYPTO_str_functs))
  {
    ERR_load_strings(0, (ERR_STRING_DATA *)&CRYPTO_str_functs);
    ERR_load_strings(0, (ERR_STRING_DATA *)&CRYPTO_str_reasons);
  }
}

uint64_t GOSTR341194_Init(void *a1, int a2)
{
  bzero(a1, 0x1094uLL);
  return Gost2814789_set_sbox((uint64_t)a1 + 44, a2);
}

uint64_t GOSTR341194_Update(uint64_t a1, char *__src, size_t __n)
{
  size_t v3;
  char *v4;
  uint64_t v6;
  _OWORD *v7;
  void *v8;
  uint64_t v9;

  if (__n)
  {
    v3 = __n;
    v4 = __src;
    *(_QWORD *)a1 += 8 * __n;
    v6 = *(unsigned int *)(a1 + 40);
    if ((_DWORD)v6)
    {
      v7 = (_OWORD *)(a1 + 8);
      v8 = (void *)(a1 + 8 + v6);
      if (__n <= 0x1F && v6 + __n < 0x20)
      {
        memcpy(v8, __src, __n);
        *(_DWORD *)(a1 + 40) += v3;
        return 1;
      }
      v9 = 32 - v6;
      memcpy(v8, __src, 32 - v6);
      GOSTR341194_block_data_order(a1, a1 + 8, 1);
      v4 += v9;
      v3 -= v9;
      *(_DWORD *)(a1 + 40) = 0;
      *v7 = 0u;
      *(_OWORD *)(a1 + 24) = 0u;
    }
    if (v3 >= 0x20)
    {
      GOSTR341194_block_data_order(a1, (uint64_t)v4, v3 >> 5);
      v4 += v3 & 0xFFFFFFFFFFFFFFE0;
      v3 &= 0x1Fu;
    }
    if (v3)
    {
      *(_DWORD *)(a1 + 40) = v3;
      memcpy((void *)(a1 + 8), v4, v3);
    }
  }
  return 1;
}

void GOSTR341194_block_data_order(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  int *v7;
  uint64_t v8;
  uint64_t v9;
  unsigned int v10;
  unsigned int v11;

  if (a3)
  {
    v6 = 0;
    v7 = (int *)(a1 + 4180);
    v8 = a1 + 4212;
    do
    {
      hash_step(a1, v7, a2);
      v9 = 0;
      v10 = 0;
      do
      {
        v11 = v10 + *(unsigned __int8 *)(v8 + v9) + *(unsigned __int8 *)(a2 + v9);
        *(_BYTE *)(v8 + v9) = v11;
        v10 = v11 >> 8;
        ++v9;
      }
      while (v9 != 32);
      a2 += 32;
      ++v6;
    }
    while (v6 != a3);
  }
}

void GOSTR341194_Transform(uint64_t a1, uint64_t a2)
{
  GOSTR341194_block_data_order(a1, a2, 1);
}

uint64_t GOSTR341194_Final(_OWORD *a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unsigned int v7;
  uint64_t v8;
  unsigned int v9;
  int v10;
  __int128 v11;
  _DWORD v13[2];
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x24BDAC8D0];
  v4 = *(unsigned int *)(a2 + 40);
  if ((_DWORD)v4)
  {
    v5 = a2 + 8;
    bzero((void *)(a2 + 8 + v4), (32 - v4));
    hash_step(a2, (int *)(a2 + 4180), a2 + 8);
    v6 = 0;
    v7 = 0;
    v8 = a2 + 4212;
    do
    {
      v9 = v7 + *(unsigned __int8 *)(v8 + v6) + *(unsigned __int8 *)(v5 + v6);
      *(_BYTE *)(v8 + v6) = v9;
      v7 = v9 >> 8;
      ++v6;
    }
    while (v6 != 32);
  }
  v10 = *(_DWORD *)(a2 + 4);
  v13[0] = *(_DWORD *)a2;
  v13[1] = v10;
  v15 = 0;
  v16 = 0;
  v14 = 0;
  hash_step(a2, (int *)(a2 + 4180), (uint64_t)v13);
  hash_step(a2, (int *)(a2 + 4180), a2 + 4212);
  v11 = *(_OWORD *)(a2 + 4196);
  *a1 = *(_OWORD *)(a2 + 4180);
  a1[1] = v11;
  return 1;
}

double hash_step(uint64_t a1, int *a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;
  char *v7;
  uint64_t v8;
  char *v9;
  char v10;
  int *v11;
  uint64_t i;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  char *v16;
  char v17;
  uint64_t j;
  uint64_t v19;
  char *v20;
  uint64_t v21;
  char *v22;
  char v23;
  uint64_t k;
  uint64_t v25;
  char *v26;
  uint64_t v27;
  char *v28;
  char v29;
  int v30;
  uint64_t m;
  uint64_t n;
  int v33;
  double result;
  __int128 v35;
  _BYTE v36[32];
  __int128 v37;
  __int128 v38;
  int8x8_t v39[4];
  _BYTE v40[32];
  int8x8_t v41;
  char v42;
  char v43;
  char v44;
  char v45;
  char v46;
  char v47;
  char v48;
  char v49;
  char v50;
  char v51;
  char v52;
  char v53;
  uint64_t v54;

  v5 = 0;
  v54 = *MEMORY[0x24BDAC8D0];
  do
  {
    *(int8x16_t *)&v40[v5 * 4] = veorq_s8(*(int8x16_t *)(a3 + v5 * 4), *(int8x16_t *)&a2[v5]);
    v5 += 4;
  }
  while (v5 != 8);
  v6 = 0;
  v7 = v40;
  do
  {
    v8 = 0;
    v9 = v7;
    do
    {
      v10 = *v9++;
      v36[v6 + v8] = v10;
      v8 += 4;
    }
    while (v8 != 32);
    ++v6;
    v7 += 8;
  }
  while (v6 != 4);
  v11 = (int *)(a1 + 44);
  Gost2814789_set_key(a1 + 44, (uint64_t)v36, 256);
  Gost2814789_encrypt(a2, (int *)&v37, v11);
  circle_xor8((uint64_t)a2, &v41);
  circle_xor8(a3, v39);
  circle_xor8((uint64_t)v39, v39);
  for (i = 0; i != 4; i += 2)
    *(int8x16_t *)&v40[i * 8] = veorq_s8(*(int8x16_t *)v39[i].i8, *(int8x16_t *)&v41.i8[i * 8]);
  v13 = 0;
  v14 = v40;
  do
  {
    v15 = 0;
    v16 = v14;
    do
    {
      v17 = *v16++;
      v36[v13 + v15] = v17;
      v15 += 4;
    }
    while (v15 != 32);
    ++v13;
    v14 += 8;
  }
  while (v13 != 4);
  Gost2814789_set_key((uint64_t)v11, (uint64_t)v36, 256);
  Gost2814789_encrypt(a2 + 2, (int *)&v37 + 2, v11);
  circle_xor8((uint64_t)&v41, &v41);
  v53 = ~v53;
  v52 = ~v52;
  v51 = ~v51;
  v50 = ~v50;
  v49 = ~v49;
  v48 = ~v48;
  v47 = ~v47;
  v46 = ~v46;
  v45 = ~v45;
  v44 = ~v44;
  v43 = ~v43;
  v42 = ~v42;
  v41.i8[7] = ~v41.i8[7];
  v41.i8[5] = ~v41.i8[5];
  v41.i8[3] = ~v41.i8[3];
  v41.i8[1] = ~v41.i8[1];
  circle_xor8((uint64_t)v39, v39);
  circle_xor8((uint64_t)v39, v39);
  for (j = 0; j != 4; j += 2)
    *(int8x16_t *)&v40[j * 8] = veorq_s8(*(int8x16_t *)v39[j].i8, *(int8x16_t *)&v41.i8[j * 8]);
  v19 = 0;
  v20 = v40;
  do
  {
    v21 = 0;
    v22 = v20;
    do
    {
      v23 = *v22++;
      v36[v19 + v21] = v23;
      v21 += 4;
    }
    while (v21 != 32);
    ++v19;
    v20 += 8;
  }
  while (v19 != 4);
  Gost2814789_set_key((uint64_t)v11, (uint64_t)v36, 256);
  Gost2814789_encrypt(a2 + 4, (int *)&v38, v11);
  circle_xor8((uint64_t)&v41, &v41);
  circle_xor8((uint64_t)v39, v39);
  circle_xor8((uint64_t)v39, v39);
  for (k = 0; k != 4; k += 2)
    *(int8x16_t *)&v40[k * 8] = veorq_s8(*(int8x16_t *)v39[k].i8, *(int8x16_t *)&v41.i8[k * 8]);
  v25 = 0;
  v26 = v40;
  do
  {
    v27 = 0;
    v28 = v26;
    do
    {
      v29 = *v28++;
      v36[v25 + v27] = v29;
      v27 += 4;
    }
    while (v27 != 32);
    ++v25;
    v26 += 8;
  }
  while (v25 != 4);
  Gost2814789_set_key((uint64_t)v11, (uint64_t)v36, 256);
  Gost2814789_encrypt(a2 + 6, (int *)&v38 + 2, v11);
  v30 = 12;
  do
  {
    transform_3((uint64_t)&v37);
    --v30;
  }
  while (v30);
  for (m = 0; m != 32; m += 16)
    *(__int128 *)((char *)&v37 + m) = (__int128)veorq_s8(*(int8x16_t *)(a3 + m), *(int8x16_t *)((char *)&v37 + m));
  transform_3((uint64_t)&v37);
  for (n = 0; n != 8; n += 4)
    *(__int128 *)((char *)&v37 + n * 4) = (__int128)veorq_s8(*(int8x16_t *)&a2[n], *(int8x16_t *)((char *)&v37 + n * 4));
  v33 = 61;
  do
  {
    transform_3((uint64_t)&v37);
    --v33;
  }
  while (v33);
  result = *(double *)&v37;
  v35 = v38;
  *(_OWORD *)a2 = v37;
  *((_OWORD *)a2 + 1) = v35;
  return result;
}

_OWORD *GOSTR341194(uint64_t a1)
{
  uint64_t v1;
  int v2;
  int v3;
  _OWORD *v4;
  _OWORD *v5;
  size_t v6;
  size_t v7;
  char *v8;
  _BYTE v10[44];
  _QWORD v11[526];

  v1 = MEMORY[0x24BDAC7A8](a1);
  v3 = v2;
  v5 = v4;
  v7 = v6;
  v8 = (char *)v1;
  v11[525] = *MEMORY[0x24BDAC8D0];
  bzero(v10, 0x1094uLL);
  if (!Gost2814789_set_sbox((uint64_t)v11, v3))
    return 0;
  if (!v5)
    v5 = &GOSTR341194_m;
  GOSTR341194_Update((uint64_t)v10, v8, v7);
  GOSTR341194_Final(v5, (uint64_t)v10);
  explicit_bzero(v10, 0x1094uLL);
  return v5;
}

int8x8_t circle_xor8(uint64_t a1, int8x8_t *a2)
{
  int8x8_t v2;
  int8x8_t v3;
  int8x8_t result;

  v2 = *(int8x8_t *)a1;
  v3 = *(int8x8_t *)(a1 + 24);
  *(_OWORD *)a2->i8 = *(_OWORD *)(a1 + 8);
  a2[2] = v3;
  result = veor_s8(*a2, v2);
  a2[3] = result;
  return result;
}

__n128 transform_3(uint64_t a1)
{
  char v1;
  char v2;
  __n128 result;

  v1 = *(_BYTE *)(a1 + 2) ^ *(_BYTE *)a1 ^ *(_BYTE *)(a1 + 4) ^ *(_BYTE *)(a1 + 6) ^ *(_BYTE *)(a1 + 24) ^ *(_BYTE *)(a1 + 30);
  v2 = *(_BYTE *)(a1 + 3) ^ *(_BYTE *)(a1 + 1) ^ *(_BYTE *)(a1 + 5) ^ *(_BYTE *)(a1 + 7) ^ *(_BYTE *)(a1 + 25) ^ *(_BYTE *)(a1 + 31);
  result = *(__n128 *)(a1 + 2);
  *(_QWORD *)(a1 + 16) = *(_QWORD *)(a1 + 18);
  *(__n128 *)a1 = result;
  *(_DWORD *)(a1 + 24) = *(_DWORD *)(a1 + 26);
  *(_WORD *)(a1 + 28) = *(_WORD *)(a1 + 30);
  *(_BYTE *)(a1 + 30) = v1;
  *(_BYTE *)(a1 + 31) = v2;
  return result;
}

uint64_t OBJ_find_sigid_algs(int a1, _DWORD *a2, _DWORD *a3)
{
  int v5;
  uint64_t result;
  char data[4];
  uint64_t v8;

  v8 = 0;
  *(_DWORD *)data = a1;
  if (sig_app
    && (v5 = sk_find((STACK *)sig_app, data), (v5 & 0x80000000) == 0)
    && (result = (uint64_t)sk_value((const STACK *)sig_app, v5)) != 0
    || (result = (uint64_t)OBJ_bsearch_(data, "\a", 42, 12, (int (__cdecl *)(const void *, const void *))sig_cmp_BSEARCH_CMP_FN)) != 0)
  {
    if (a2)
      *a2 = *(_DWORD *)(result + 4);
    if (a3)
      *a3 = *(_DWORD *)(result + 8);
    return 1;
  }
  return result;
}

uint64_t OBJ_find_sigid_by_algs(_DWORD *a1, int a2, int a3)
{
  int v4;
  uint64_t result;
  char key[12];
  char data[4];
  int v8;
  int v9;

  *(_QWORD *)key = data;
  *(_DWORD *)data = 0;
  v8 = a2;
  v9 = a3;
  if (!sigx_app || (v4 = sk_find((STACK *)sigx_app, data), v4 < 0))
  {
    result = (uint64_t)OBJ_bsearch_(key, (const char *)&sigoid_srt_xref, 42, 8, (int (__cdecl *)(const void *, const void *))sigx_cmp_BSEARCH_CMP_FN);
    if (!result)
      return result;
  }
  else
  {
    *(_QWORD *)key = sk_value((const STACK *)sigx_app, v4);
    result = (uint64_t)key;
  }
  if (a1)
    *a1 = **(_DWORD **)result;
  return 1;
}

uint64_t OBJ_add_sigid(int a1, int a2, int a3)
{
  uint64_t result;
  char *v7;

  if (sig_app
    || (result = (uint64_t)sk_new((int (__cdecl *)(const char *const *, const char *const *))sig_sk_cmp),
        (sig_app = result) != 0))
  {
    if (sigx_app
      || (result = (uint64_t)sk_new((int (__cdecl *)(const char *const *, const char *const *))sigx_cmp),
          (sigx_app = result) != 0))
    {
      result = (uint64_t)reallocarray(0, 3uLL, 4uLL);
      if (result)
      {
        v7 = (char *)result;
        *(_DWORD *)result = a1;
        *(_DWORD *)(result + 4) = a2;
        *(_DWORD *)(result + 8) = a3;
        if (sk_push((STACK *)sig_app, (char *)result))
        {
          result = sk_push((STACK *)sigx_app, v7);
          if ((_DWORD)result)
          {
            sk_sort((STACK *)sig_app);
            sk_sort((STACK *)sigx_app);
            return 1;
          }
        }
        else
        {
          free(v7);
          return 0;
        }
      }
    }
  }
  return result;
}

uint64_t sig_sk_cmp(_DWORD **a1, _DWORD **a2)
{
  return (**a1 - **a2);
}

uint64_t sigx_cmp(uint64_t *a1, uint64_t a2)
{
  uint64_t v2;
  int v3;
  int v4;
  uint64_t result;

  v2 = *a1;
  v3 = *(_DWORD *)(*a1 + 4);
  v4 = *(_DWORD *)(*(_QWORD *)a2 + 4);
  result = (v3 - v4);
  if (v3 == v4)
    return (*(_DWORD *)(v2 + 8) - *(_DWORD *)(*(_QWORD *)a2 + 8));
  return result;
}

void OBJ_sigid_free()
{
  if (sig_app)
  {
    sk_pop_free((STACK *)sig_app, sid_free);
    sig_app = 0;
  }
  if (sigx_app)
  {
    sk_free((STACK *)sigx_app);
    sigx_app = 0;
  }
}

uint64_t sig_cmp_BSEARCH_CMP_FN(_DWORD *a1, _DWORD *a2)
{
  return (*a1 - *a2);
}

uint64_t sigx_cmp_BSEARCH_CMP_FN(uint64_t *a1, uint64_t a2)
{
  uint64_t v2;
  int v3;
  int v4;
  uint64_t result;

  v2 = *a1;
  v3 = *(_DWORD *)(*a1 + 4);
  v4 = *(_DWORD *)(*(_QWORD *)a2 + 4);
  result = (v3 - v4);
  if (v3 == v4)
    return (*(_DWORD *)(v2 + 8) - *(_DWORD *)(*(_QWORD *)a2 + 8));
  return result;
}

void ENGINE_unregister_ciphers(ENGINE *e)
{
  engine_table_unregister(&cipher_table, e);
}

int ENGINE_register_ciphers(ENGINE *e)
{
  uint64_t (*v1)(void);
  int v3;

  v1 = (uint64_t (*)(void))*((_QWORD *)e + 10);
  if (v1 && (v3 = v1(), v3 > 0))
    return engine_table_register(&cipher_table, (uint64_t)engine_unregister_all_ciphers, (char *)e, 0, v3, 0);
  else
    return 1;
}

void engine_unregister_all_ciphers()
{
  engine_table_cleanup(&cipher_table);
}

void ENGINE_register_all_ciphers(void)
{
  ENGINE *first;
  ENGINE *next;

  first = ENGINE_get_first();
  if (first)
  {
    next = first;
    do
    {
      ENGINE_register_ciphers(next);
      next = ENGINE_get_next(next);
    }
    while (next);
  }
}

int ENGINE_set_default_ciphers(ENGINE *e)
{
  uint64_t (*v1)(void);
  int v3;

  v1 = (uint64_t (*)(void))*((_QWORD *)e + 10);
  if (v1 && (v3 = v1(), v3 > 0))
    return engine_table_register(&cipher_table, (uint64_t)engine_unregister_all_ciphers, (char *)e, 0, v3, 1);
  else
    return 1;
}

ENGINE *__cdecl ENGINE_get_cipher_engine(int nid)
{
  return (ENGINE *)engine_table_select(&cipher_table, nid);
}

const EVP_CIPHER *__cdecl ENGINE_get_cipher(ENGINE *e, int nid)
{
  unsigned int (*v2)(void);
  const EVP_CIPHER *v4;

  v4 = 0;
  v2 = (unsigned int (*)(void))*((_QWORD *)e + 10);
  if (v2 && v2())
    return v4;
  ERR_put_error(38, 4095, 146, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/engine/tb_cipher.c", 133);
  return 0;
}

ENGINE_CIPHERS_PTR ENGINE_get_ciphers(const ENGINE *e)
{
  return (ENGINE_CIPHERS_PTR)*((_QWORD *)e + 10);
}

int ENGINE_set_ciphers(ENGINE *e, ENGINE_CIPHERS_PTR f)
{
  *((_QWORD *)e + 10) = f;
  return 1;
}

int EVP_CIPHER_param_to_asn1(EVP_CIPHER_CTX *c, ASN1_TYPE *type)
{
  uint64_t (*set_asn1_parameters)(void);

  set_asn1_parameters = (uint64_t (*)(void))c->cipher->set_asn1_parameters;
  if (set_asn1_parameters)
    return set_asn1_parameters();
  if ((c->cipher->flags & 0x1000) != 0)
    return EVP_CIPHER_set_asn1_iv(c, type);
  return -1;
}

int EVP_CIPHER_set_asn1_iv(EVP_CIPHER_CTX *c, ASN1_TYPE *type)
{
  unsigned int iv_len;

  if (!type)
    return 0;
  iv_len = c->cipher->iv_len;
  if (iv_len >= 0x11)
  {
    ERR_put_error(6, 4095, 102, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/evp_lib.c", 127);
    return 0;
  }
  return ASN1_TYPE_set_octetstring(type, c->oiv, iv_len);
}

int EVP_CIPHER_asn1_to_param(EVP_CIPHER_CTX *c, ASN1_TYPE *type)
{
  uint64_t (*get_asn1_parameters)(void);

  get_asn1_parameters = (uint64_t (*)(void))c->cipher->get_asn1_parameters;
  if (get_asn1_parameters)
    return get_asn1_parameters();
  if ((c->cipher->flags & 0x1000) != 0)
    return EVP_CIPHER_get_asn1_iv(c, type);
  return -1;
}

int EVP_CIPHER_get_asn1_iv(EVP_CIPHER_CTX *c, ASN1_TYPE *type)
{
  size_t iv_len;

  if (!type)
    goto LABEL_4;
  iv_len = c->cipher->iv_len;
  if (iv_len >= 0x11)
  {
    ERR_put_error(6, 4095, 102, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/evp_lib.c", 106);
LABEL_4:
    LODWORD(iv_len) = 0;
    return iv_len;
  }
  if (ASN1_TYPE_get_octetstring(type, c->oiv, iv_len) == (_DWORD)iv_len)
  {
    if ((_DWORD)iv_len)
      memcpy(c->iv, c->oiv, iv_len);
  }
  else
  {
    LODWORD(iv_len) = -1;
  }
  return iv_len;
}

int EVP_CIPHER_CTX_iv_length(const EVP_CIPHER_CTX *ctx)
{
  return ctx->cipher->iv_len;
}

int EVP_CIPHER_type(const EVP_CIPHER *ctx)
{
  int nid;
  int result;
  ASN1_OBJECT *v3;

  nid = ctx->nid;
  if (ctx->nid <= 424)
  {
    result = 37;
    if (nid > 96)
    {
      if (nid > 165)
      {
        if (nid == 166)
          return result;
        if (nid == 421)
          return 421;
        goto LABEL_23;
      }
      if (nid != 97)
      {
        if (nid == 98)
          return result;
        goto LABEL_23;
      }
    }
    else
    {
      if (nid > 36)
      {
        if (nid == 37)
          return result;
        if (nid != 61)
          goto LABEL_23;
        return 30;
      }
      if (nid != 5)
      {
        if (nid != 30)
        {
LABEL_23:
          v3 = OBJ_nid2obj(nid);
          if (!v3 || !v3->data)
            nid = 0;
          ASN1_OBJECT_free(v3);
          return nid;
        }
        return 30;
      }
    }
    return 5;
  }
  switch(nid)
  {
    case 650:
    case 653:
      return 421;
    case 651:
    case 654:
      goto LABEL_22;
    case 652:
    case 655:
      goto LABEL_21;
    case 656:
    case 657:
    case 658:
    case 659:
      return 30;
    default:
      if (nid == 425)
      {
LABEL_22:
        result = 425;
      }
      else
      {
        if (nid != 429)
          goto LABEL_23;
LABEL_21:
        result = 429;
      }
      break;
  }
  return result;
}

int EVP_CIPHER_nid(const EVP_CIPHER *cipher)
{
  return cipher->nid;
}

int EVP_CIPHER_block_size(const EVP_CIPHER *cipher)
{
  return cipher->block_size;
}

int EVP_CIPHER_CTX_block_size(const EVP_CIPHER_CTX *ctx)
{
  return ctx->cipher->block_size;
}

int EVP_Cipher(EVP_CIPHER_CTX *c, unsigned __int8 *out, const unsigned __int8 *in, unsigned int inl)
{
  return ((uint64_t (*)(EVP_CIPHER_CTX *, unsigned __int8 *, const unsigned __int8 *, _QWORD))c->cipher->do_cipher)(c, out, in, inl);
}

const EVP_CIPHER *__cdecl EVP_CIPHER_CTX_cipher(const EVP_CIPHER_CTX *ctx)
{
  return ctx->cipher;
}

uint64_t EVP_CIPHER_CTX_encrypting(uint64_t a1)
{
  return *(unsigned int *)(a1 + 16);
}

unint64_t EVP_CIPHER_flags(const EVP_CIPHER *cipher)
{
  return cipher->flags;
}

unint64_t EVP_CIPHER_CTX_flags(const EVP_CIPHER_CTX *ctx)
{
  return ctx->cipher->flags;
}

void *__cdecl EVP_CIPHER_CTX_get_app_data(const EVP_CIPHER_CTX *ctx)
{
  return ctx->app_data;
}

void EVP_CIPHER_CTX_set_app_data(EVP_CIPHER_CTX *ctx, void *data)
{
  ctx->app_data = data;
}

uint64_t EVP_CIPHER_CTX_get_cipher_data(uint64_t a1)
{
  return *(_QWORD *)(a1 + 120);
}

uint64_t EVP_CIPHER_CTX_set_cipher_data(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 120);
  *(_QWORD *)(a1 + 120) = a2;
  return v2;
}

int EVP_CIPHER_iv_length(const EVP_CIPHER *cipher)
{
  return cipher->iv_len;
}

uint64_t EVP_CIPHER_CTX_buf_noconst(uint64_t a1)
{
  return a1 + 56;
}

int EVP_CIPHER_key_length(const EVP_CIPHER *cipher)
{
  return cipher->key_len;
}

int EVP_CIPHER_CTX_key_length(const EVP_CIPHER_CTX *ctx)
{
  return ctx->key_len;
}

int EVP_CIPHER_CTX_nid(const EVP_CIPHER_CTX *ctx)
{
  return ctx->cipher->nid;
}

uint64_t EVP_CIPHER_CTX_get_iv(uint64_t result, void *__dst, size_t a3)
{
  uint64_t v3;

  if (result)
  {
    v3 = result;
    result = 0;
    if (a3 <= 0x10 && *(_DWORD *)(*(_QWORD *)v3 + 12) == a3)
    {
      if (!a3)
        return 1;
      if (__dst)
      {
        memcpy(__dst, (const void *)(v3 + 40), a3);
        return 1;
      }
      return 0;
    }
  }
  return result;
}

uint64_t EVP_CIPHER_CTX_set_iv(uint64_t result, const void *a2, size_t a3)
{
  uint64_t v3;

  if (result)
  {
    v3 = result;
    result = 0;
    if (a3 <= 0x10 && *(_DWORD *)(*(_QWORD *)v3 + 12) == a3)
    {
      if (!a3)
        return 1;
      if (a2)
      {
        memcpy((void *)(v3 + 40), a2, a3);
        return 1;
      }
      return 0;
    }
  }
  return result;
}

int EVP_MD_block_size(const EVP_MD *md)
{
  return (int)md->sign;
}

int EVP_MD_type(const EVP_MD *md)
{
  return md->type;
}

int EVP_MD_pkey_type(const EVP_MD *md)
{
  return md->pkey_type;
}

int EVP_MD_size(const EVP_MD *md)
{
  if (md)
    return md->md_size;
  ERR_put_error(6, 4095, 159, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/evp_lib.c", 362);
  return -1;
}

uint64_t EVP_MD_flags(uint64_t a1)
{
  return *(_QWORD *)(a1 + 16);
}

_DWORD *EVP_MD_meth_new(int a1, int a2)
{
  _DWORD *result;

  result = malloc_type_calloc(1uLL, 0x50uLL, 0x1080040DE93153CuLL);
  if (result)
  {
    *result = a1;
    result[1] = a2;
  }
  return result;
}

_OWORD *EVP_MD_meth_dup(uint64_t *a1)
{
  uint64_t v2;
  _OWORD *result;
  __int128 v4;
  __int128 v5;
  __int128 v6;

  v2 = *a1;
  result = malloc_type_calloc(1uLL, 0x50uLL, 0x1080040DE93153CuLL);
  if (result)
  {
    *(_QWORD *)result = v2;
    *result = *(_OWORD *)a1;
    v4 = *((_OWORD *)a1 + 1);
    v5 = *((_OWORD *)a1 + 2);
    v6 = *((_OWORD *)a1 + 4);
    result[3] = *((_OWORD *)a1 + 3);
    result[4] = v6;
    result[1] = v4;
    result[2] = v5;
  }
  return result;
}

void EVP_MD_meth_free(void *a1)
{
  freezero(a1, 0x50uLL);
}

uint64_t EVP_MD_meth_set_input_blocksize(uint64_t a1, int a2)
{
  *(_DWORD *)(a1 + 64) = a2;
  return 1;
}

uint64_t EVP_MD_meth_set_result_size(uint64_t a1, int a2)
{
  *(_DWORD *)(a1 + 8) = a2;
  return 1;
}

uint64_t EVP_MD_meth_set_app_datasize(uint64_t a1, int a2)
{
  *(_DWORD *)(a1 + 68) = a2;
  return 1;
}

uint64_t EVP_MD_meth_set_flags(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)(a1 + 16) = a2;
  return 1;
}

uint64_t EVP_MD_meth_set_init(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)(a1 + 24) = a2;
  return 1;
}

uint64_t EVP_MD_meth_set_update(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)(a1 + 32) = a2;
  return 1;
}

uint64_t EVP_MD_meth_set_final(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)(a1 + 40) = a2;
  return 1;
}

uint64_t EVP_MD_meth_set_copy(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)(a1 + 48) = a2;
  return 1;
}

uint64_t EVP_MD_meth_set_cleanup(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)(a1 + 56) = a2;
  return 1;
}

uint64_t EVP_MD_meth_set_ctrl(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)(a1 + 72) = a2;
  return 1;
}

const EVP_MD *__cdecl EVP_MD_CTX_md(const EVP_MD *ctx)
{
  if (ctx)
    return *(const EVP_MD **)&ctx->type;
  return ctx;
}

uint64_t EVP_MD_CTX_md_data(uint64_t a1)
{
  return *(_QWORD *)(a1 + 24);
}

uint64_t EVP_MD_CTX_pkey_ctx(uint64_t a1)
{
  return *(_QWORD *)(a1 + 32);
}

void EVP_MD_CTX_set_pkey_ctx(uint64_t a1, uint64_t a2)
{
  uint64_t v4;

  v4 = *(_QWORD *)(a1 + 16);
  if ((v4 & 0x400) != 0)
    *(_QWORD *)(a1 + 16) = v4 & 0xFFFFFFFFFFFFFBFFLL;
  else
    EVP_PKEY_CTX_free(*(EVP_PKEY ***)(a1 + 32));
  *(_QWORD *)(a1 + 32) = a2;
  if (a2)
    *(_QWORD *)(a1 + 16) |= 0x400uLL;
}

int EVP_MD_CTX_test_flags(const EVP_MD_CTX *ctx, int flags)
{
  return ctx->flags & flags;
}

void EVP_MD_CTX_clear_flags(EVP_MD_CTX *ctx, int flags)
{
  ctx->flags &= ~flags;
}

void EVP_MD_CTX_set_flags(EVP_MD_CTX *ctx, int flags)
{
  ctx->flags |= flags;
}

void EVP_CIPHER_CTX_set_flags(EVP_CIPHER_CTX *ctx, int flags)
{
  ctx->flags |= flags;
}

void EVP_CIPHER_CTX_clear_flags(EVP_CIPHER_CTX *ctx, int flags)
{
  ctx->flags &= ~flags;
}

int EVP_CIPHER_CTX_test_flags(const EVP_CIPHER_CTX *ctx, int flags)
{
  return ctx->flags & flags;
}

_BYTE *i2s_ASN1_IA5STRING(uint64_t a1, const void **a2)
{
  uint64_t v3;
  _BYTE *v4;
  _BYTE *v5;

  if (!a2)
    return 0;
  v3 = *(int *)a2;
  if (!(_DWORD)v3)
    return 0;
  v4 = malloc_type_malloc(v3 + 1, 0x20A82302uLL);
  v5 = v4;
  if (v4)
  {
    memcpy(v4, a2[1], *(int *)a2);
    v5[*(int *)a2] = 0;
  }
  else
  {
    ERR_put_error(34, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_ia5.c", 210);
  }
  return v5;
}

ASN1_STRING *s2i_ASN1_IA5STRING(uint64_t a1, uint64_t a2, const char *a3)
{
  ASN1_IA5STRING *v4;
  ASN1_STRING *v5;
  int v6;
  int v7;
  int v8;

  if (!a3)
  {
    v7 = 107;
    v8 = 223;
    goto LABEL_7;
  }
  v4 = ASN1_IA5STRING_new();
  if (!v4)
  {
LABEL_5:
    v7 = 65;
    v8 = 236;
LABEL_7:
    ERR_put_error(34, 4095, v7, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_ia5.c", v8);
    return 0;
  }
  v5 = v4;
  v6 = strlen(a3);
  if (!ASN1_STRING_set(v5, a3, v6))
  {
    ASN1_IA5STRING_free(v5);
    goto LABEL_5;
  }
  return v5;
}

uint64_t Camellia_Ekeygen(int a1, unsigned __int8 *a2, unsigned int *a3)
{
  int v3;
  unsigned int v4;
  int v5;
  unsigned int v6;
  int v7;
  unsigned int v8;
  int v9;
  unsigned int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  unsigned int v15;
  unsigned int v16;
  int v17;
  int v18;
  int v19;
  int v20;
  int v21;
  int v22;
  int v23;
  int v24;
  int v25;
  int v26;
  int v27;
  int v28;
  int v29;
  int v30;
  int v31;
  int v32;
  int v33;
  int v34;
  int v35;
  int v36;
  int v37;
  int v38;
  int v39;
  unsigned int v40;
  unsigned int v41;
  unsigned int v42;
  unsigned int v43;
  unsigned int v44;
  unsigned int v45;
  unsigned int v46;
  unsigned int v47;
  unsigned int v48;
  unsigned int v49;
  unint64_t v50;
  unsigned int v51;
  unsigned int v52;
  unsigned int v53;
  unsigned int v54;
  unsigned int v55;
  unsigned int v56;
  unsigned int v57;
  unsigned int v58;
  unsigned int v59;
  unsigned int v60;
  unsigned int v61;
  unsigned int v62;
  unsigned int v63;
  unsigned int v64;
  unsigned int v65;
  unsigned int v66;
  unsigned int v67;
  unsigned int v68;
  unsigned int v69;
  unsigned int v70;
  unsigned int v71;
  unsigned int v72;
  unsigned int v73;
  unsigned int v74;
  unsigned int v75;
  unsigned int v76;
  uint64_t result;
  unsigned int v78;
  unsigned int v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  unsigned int v84;
  unsigned int v85;
  unsigned int v86;
  unsigned int v87;
  unsigned int v88;
  int v89;
  int v90;
  int v91;
  int v92;
  int v93;
  unint64_t v94;
  int v95;
  int v96;
  unsigned int v97;
  unsigned int v98;
  unsigned int v99;
  unsigned int v100;
  unsigned int v101;
  unsigned int v102;
  unsigned int v103;
  unsigned int v104;
  unsigned int v105;
  unint64_t v106;
  unsigned int v107;
  unsigned int v108;
  unsigned int v109;
  unsigned int v110;
  unsigned int v111;
  unsigned int v112;
  unsigned int v113;
  unsigned int v114;
  unsigned int v115;
  unsigned int v116;
  unint64_t v117;
  unsigned int v118;
  unsigned int v119;
  unsigned int v120;
  unsigned int v121;
  unsigned int v122;
  unsigned int v123;
  unsigned int v124;
  unsigned int v125;
  unsigned int v126;
  unint64_t v127;
  unsigned int v128;
  unsigned int v129;
  unsigned int v130;
  unsigned int v131;
  unsigned int v132;
  unsigned int v133;
  unsigned int v134;
  unsigned int v135;
  unsigned int v136;
  unsigned int v137;
  int v138;
  int v139;

  v3 = (*a2 << 24) | (a2[1] << 16);
  v4 = v3 | (bswap32(*((unsigned __int16 *)a2 + 1)) >> 16);
  *a3 = v4;
  v5 = (a2[4] << 24) | (a2[5] << 16);
  v6 = v5 | (bswap32(*((unsigned __int16 *)a2 + 3)) >> 16);
  a3[1] = v6;
  v7 = (a2[8] << 24) | (a2[9] << 16);
  v8 = v7 | (bswap32(*((unsigned __int16 *)a2 + 5)) >> 16);
  a3[2] = v8;
  v9 = (a2[12] << 24) | (a2[13] << 16);
  v10 = v9 | (bswap32(*((unsigned __int16 *)a2 + 7)) >> 16);
  a3[3] = v10;
  if (a1 == 128)
  {
    v11 = v10;
    v12 = v8;
    v13 = v6;
    v14 = v4;
  }
  else
  {
    v15 = bswap32(*((_DWORD *)a2 + 4));
    a3[8] = v15;
    v16 = bswap32(*((_DWORD *)a2 + 5));
    a3[9] = v16;
    if (a1 == 192)
    {
      v17 = ~v15;
      a3[10] = ~v15;
      v18 = ~v16;
    }
    else
    {
      v17 = bswap32(*((_DWORD *)a2 + 6));
      a3[10] = v17;
      v18 = bswap32(*((_DWORD *)a2 + 7));
    }
    a3[11] = v18;
    v14 = v15 ^ v4;
    v13 = v16 ^ v6;
    v12 = v17 ^ v8;
    v11 = v18 ^ v10;
  }
  v19 = Camellia_SBOX[((unsigned __int16)(v14 ^ 0x667F) >> 8) + 768] ^ Camellia_SBOX[(v14 ^ 0x7F) + 256] ^ Camellia_SBOX[((v14 ^ 0xA09E667F) >> 16) + 512] ^ Camellia_SBOX[(v14 ^ 0xA09E667F) >> 24];
  v20 = __ROR4__(v19, 8);
  v21 = Camellia_SBOX[((unsigned __int16)(v13 ^ 0x908B) >> 8) + 256] ^ Camellia_SBOX[v13 ^ 0x8B] ^ Camellia_SBOX[((v13 ^ 0x3BCC908Bu) >> 16) + 768] ^ Camellia_SBOX[((v13 ^ 0x3BCC908Bu) >> 24) + 512] ^ v19;
  v22 = v21 ^ v12;
  v23 = v11 ^ v20 ^ v21;
  v24 = Camellia_SBOX[((unsigned __int16)(v21 ^ v12 ^ 0xE858) >> 8) + 768] ^ Camellia_SBOX[((v21 ^ v12) ^ 0x58) + 256] ^ Camellia_SBOX[((v21 ^ v12 ^ 0xB67AE858) >> 16) + 512] ^ Camellia_SBOX[(v21 ^ v12 ^ 0xB67AE858) >> 24];
  v25 = Camellia_SBOX[((unsigned __int16)(v23 ^ 0x73B2) >> 8) + 256] ^ Camellia_SBOX[v23 ^ 0xB2] ^ Camellia_SBOX[((v23 ^ 0x4CAA73B2u) >> 16) + 768] ^ Camellia_SBOX[((v23 ^ 0x4CAA73B2u) >> 24) + 512] ^ v24;
  v26 = v14 ^ v4 ^ v25;
  v27 = v6 ^ __ROR4__(v24, 8) ^ v13 ^ v25;
  v28 = v22 ^ v8;
  v29 = Camellia_SBOX[((unsigned __int16)(v26 ^ 0x372F) >> 8) + 768] ^ Camellia_SBOX[(v26 ^ 0x2F) + 256] ^ Camellia_SBOX[((v26 ^ 0xC6EF372F) >> 16) + 512] ^ Camellia_SBOX[(v26 ^ 0xC6EF372F) >> 24];
  v30 = Camellia_SBOX[((unsigned __int16)(v27 ^ 0x82BE) >> 8) + 256] ^ Camellia_SBOX[v27 ^ 0xBE] ^ Camellia_SBOX[((v27 ^ 0xE94F82BE) >> 16) + 768] ^ Camellia_SBOX[((v27 ^ 0xE94F82BE) >> 24) + 512] ^ v29;
  v31 = v28 ^ v30;
  v32 = __ROR4__(v29, 8);
  v33 = v10 ^ v32 ^ v23 ^ v30;
  v34 = Camellia_SBOX[((unsigned __int16)(v10 ^ v32 ^ v23 ^ v30 ^ 0x6F1C) >> 8) + 256] ^ Camellia_SBOX[(v10 ^ v32 ^ v23 ^ v30) ^ 0x1C];
  v35 = Camellia_SBOX[((unsigned __int16)(v31 ^ 0x53A5) >> 8) + 768] ^ Camellia_SBOX[(v31 ^ 0xA5) + 256] ^ Camellia_SBOX[((v31 ^ 0x54FF53A5u) >> 16) + 512] ^ Camellia_SBOX[(v31 ^ 0x54FF53A5u) >> 24];
  v36 = __ROR4__(v35, 8);
  v37 = v34 ^ Camellia_SBOX[((v33 ^ 0xF1D36F1C) >> 16) + 768] ^ Camellia_SBOX[((v33 ^ 0xF1D36F1C) >> 24)
                                                                                             + 512] ^ v35;
  v38 = v37 ^ v26;
  v39 = v27 ^ v36 ^ v37;
  if (a1 == 128)
  {
    v40 = __PAIR64__(v38, v39) >> 17;
    v41 = __PAIR64__(v39, v31) >> 17;
    v42 = __PAIR64__(v31, v33) >> 17;
    v43 = __PAIR64__(v33, v38) >> 17;
    v44 = __PAIR64__(v40, v41) >> 17;
    v45 = __PAIR64__(v41, v42) >> 17;
    a3[4] = v38;
    a3[5] = v39;
    v46 = __PAIR64__(v42, v43) >> 17;
    v47 = __PAIR64__(v43, v40) >> 17;
    a3[6] = v31;
    a3[7] = v33;
    v48 = __PAIR64__(__PAIR64__(v40, v41) >> 17, v45) >> 17;
    a3[12] = v40;
    a3[13] = v41;
    a3[14] = v42;
    a3[15] = v43;
    HIDWORD(v50) = v48;
    LODWORD(v50) = __PAIR64__(__PAIR64__(v41, v42) >> 17, v46) >> 17;
    v49 = v50 >> 17;
    HIDWORD(v50) = v50;
    LODWORD(v50) = __PAIR64__(v46, v47) >> 17;
    v51 = v50 >> 17;
    a3[16] = v44;
    a3[17] = v45;
    HIDWORD(v50) = v50;
    LODWORD(v50) = __PAIR64__(v47, v44) >> 17;
    v52 = v50 >> 17;
    a3[18] = v46;
    a3[19] = v47;
    v54 = __PAIR64__(v51, v52) >> 30;
    a3[24] = v48;
    a3[25] = __PAIR64__(v45, v46) >> 17;
    HIDWORD(v50) = __PAIR64__(v50, v48) >> 17;
    v53 = HIDWORD(v50);
    LODWORD(v50) = v49;
    v55 = v50 >> 30;
    v56 = __PAIR64__(v49, v51) >> 30;
    a3[28] = v49;
    a3[29] = v51;
    HIDWORD(v50) = v54;
    LODWORD(v50) = __PAIR64__(v52, v53) >> 30;
    a3[30] = v52;
    a3[31] = v53;
    v57 = __PAIR64__(v4, v5) >> 17;
    a3[40] = v54;
    a3[41] = v50;
    v58 = __PAIR64__(v6, v7) >> 17;
    a3[42] = v55;
    a3[43] = v56;
    v59 = __PAIR64__(v8, v9) >> 17;
    v60 = __PAIR64__(v10, v3) >> 17;
    a3[48] = v50 >> 15;
    a3[49] = __PAIR64__(v50, v55) >> 15;
    v61 = __PAIR64__(v57, v58) >> 2;
    v62 = __PAIR64__(v58, v59) >> 2;
    a3[50] = __PAIR64__(v55, v56) >> 15;
    a3[51] = __PAIR64__(__PAIR64__(v49, v51) >> 30, v54) >> 15;
    v63 = __PAIR64__(v59, v60) >> 2;
    v64 = __PAIR64__(v60, v57) >> 2;
    a3[8] = v57;
    a3[9] = v58;
    v65 = __PAIR64__(v61, v62) >> 17;
    a3[10] = v59;
    a3[11] = v60;
    v66 = __PAIR64__(v63, v64) >> 17;
    v67 = __PAIR64__(v64, v61) >> 17;
    a3[20] = v61;
    a3[21] = v62;
    v68 = __PAIR64__(__PAIR64__(v61, v62) >> 17, __PAIR64__(v62, v63) >> 17) >> 15;
    v69 = __PAIR64__(__PAIR64__(v62, v63) >> 17, v66) >> 15;
    a3[22] = v63;
    a3[23] = v64;
    v70 = __PAIR64__(v66, v67) >> 15;
    v71 = __PAIR64__(v67, v65) >> 15;
    a3[26] = v66;
    a3[27] = v67;
    v72 = __PAIR64__(v68, v69) >> 15;
    v73 = __PAIR64__(v69, v70) >> 15;
    a3[32] = v68;
    a3[33] = v69;
    v74 = __PAIR64__(v70, v71) >> 15;
    v75 = __PAIR64__(v71, v68) >> 15;
    a3[34] = v70;
    a3[35] = v71;
    v76 = __PAIR64__(v72, v73) >> 15;
    result = 3;
    v78 = __PAIR64__(v73, v74) >> 15;
    a3[36] = v72;
    a3[37] = v73;
    a3[38] = v74;
    a3[39] = v75;
    v79 = __PAIR64__(v74, v75) >> 15;
    v80 = 47;
    v81 = 46;
    v82 = 45;
    v83 = 44;
    v84 = __PAIR64__(v75, v72) >> 15;
  }
  else
  {
    v85 = a3[8];
    v86 = a3[9];
    v138 = v5;
    v139 = v3;
    v88 = a3[10];
    v87 = a3[11];
    v89 = Camellia_SBOX[((unsigned __int16)(v85 ^ v38 ^ 0x27FA) >> 8) + 768] ^ Camellia_SBOX[((v85 ^ v38) ^ 0xFA) + 256] ^ Camellia_SBOX[((v85 ^ v38 ^ 0x10E527FA) >> 16) + 512] ^ Camellia_SBOX[(v85 ^ v38 ^ 0x10E527FA) >> 24];
    v90 = Camellia_SBOX[((unsigned __int16)(v86 ^ v39 ^ 0x2D1D) >> 8) + 256] ^ Camellia_SBOX[(v86 ^ v39) ^ 0x1D] ^ Camellia_SBOX[((v86 ^ v39 ^ 0xDE682D1D) >> 16) + 768] ^ Camellia_SBOX[((v86 ^ v39 ^ 0xDE682D1D) >> 24) + 512] ^ v89;
    v91 = v88 ^ v31 ^ v90;
    v92 = v33 ^ __ROR4__(v89, 8) ^ v87 ^ v90;
    v93 = Camellia_SBOX[((unsigned __int16)(v91 ^ 0x88C2) >> 8) + 768] ^ Camellia_SBOX[(v91 ^ 0xC2) + 256] ^ Camellia_SBOX[((v91 ^ 0xB05688C2) >> 16) + 512] ^ Camellia_SBOX[(v91 ^ 0xB05688C2) >> 24];
    v94 = __PAIR64__(v91, __ROR4__(v93, 8));
    v95 = Camellia_SBOX[((unsigned __int16)(v92 ^ 0xC1FD) >> 8) + 256] ^ Camellia_SBOX[v92 ^ 0xFD] ^ Camellia_SBOX[((v92 ^ 0xB3E6C1FD) >> 16) + 768] ^ Camellia_SBOX[((v92 ^ 0xB3E6C1FD) >> 24) + 512] ^ v93;
    v96 = v95 ^ v85 ^ v38;
    v97 = v86 ^ v39 ^ v94 ^ v95;
    v98 = __PAIR64__(v96, v97) >> 2;
    a3[4] = v96;
    a3[5] = v97;
    v99 = __PAIR64__(v97, v91) >> 2;
    LODWORD(v94) = v92;
    v100 = v94 >> 2;
    a3[6] = v91;
    a3[7] = v92;
    v101 = __PAIR64__(v92, v96) >> 2;
    v102 = __PAIR64__(v98, v99) >> 2;
    a3[20] = v98;
    a3[21] = v99;
    v103 = __PAIR64__(v99, v100) >> 2;
    v104 = __PAIR64__(v100, v101) >> 2;
    a3[22] = v100;
    a3[23] = v101;
    v105 = __PAIR64__(v101, v98) >> 2;
    a3[40] = v102;
    a3[41] = v103;
    v106 = __PAIR64__(v104, v105);
    v107 = __PAIR64__(v105, v102) >> 13;
    a3[42] = v104;
    a3[43] = v105;
    v108 = __PAIR64__(v102, v103) >> 13;
    a3[64] = __PAIR64__(v103, v104) >> 13;
    a3[65] = v106 >> 13;
    a3[66] = v107;
    v109 = __PAIR64__(v85, v86) >> 17;
    a3[67] = v108;
    v110 = __PAIR64__(v87, v85) >> 17;
    HIDWORD(v106) = v109;
    LODWORD(v106) = __PAIR64__(v86, v88) >> 17;
    v111 = v106 >> 17;
    a3[8] = v109;
    a3[9] = v106;
    HIDWORD(v106) = v106;
    LODWORD(v106) = __PAIR64__(v88, v87) >> 17;
    v112 = v106 >> 17;
    v113 = __PAIR64__(v106, v110) >> 17;
    a3[10] = v106;
    a3[11] = v110;
    v114 = __PAIR64__(v110, v109) >> 17;
    v115 = __PAIR64__(v111, v112) >> 2;
    a3[16] = v111;
    a3[17] = v112;
    v116 = __PAIR64__(v106 >> 17, v113) >> 2;
    v117 = __PAIR64__(v113, v114);
    a3[18] = v113;
    a3[19] = v114;
    v118 = __PAIR64__(v114, v111) >> 2;
    a3[36] = v115;
    a3[37] = v116;
    HIDWORD(v117) = v117 >> 2;
    LODWORD(v117) = v118;
    a3[38] = HIDWORD(v117);
    a3[39] = v118;
    a3[52] = __PAIR64__(v116, HIDWORD(v117)) >> 30;
    a3[53] = v117 >> 30;
    v119 = __PAIR64__(v39, v31) >> 17;
    v120 = __PAIR64__(v31, v33) >> 17;
    a3[54] = __PAIR64__(v118, v115) >> 30;
    a3[55] = __PAIR64__(v115, v116) >> 30;
    v121 = __PAIR64__(v33, v38) >> 17;
    HIDWORD(v117) = __PAIR64__(v38, v39) >> 17;
    LODWORD(v117) = v119;
    v122 = v117 >> 2;
    a3[12] = HIDWORD(v117);
    a3[13] = v119;
    v123 = __PAIR64__(v119, v120) >> 2;
    v124 = __PAIR64__(v120, v121) >> 2;
    a3[14] = v120;
    a3[15] = v121;
    HIDWORD(v117) = v121;
    LODWORD(v117) = __PAIR64__(v38, v39) >> 17;
    v125 = v117 >> 2;
    a3[28] = v122;
    a3[29] = v123;
    a3[30] = v124;
    a3[31] = v125;
    v126 = __PAIR64__(v124, v125) >> 15;
    a3[48] = v123;
    a3[49] = v124;
    v127 = __PAIR64__(v125, v122);
    a3[50] = v125;
    a3[51] = v122;
    v128 = __PAIR64__(v6, v7) >> 19;
    v129 = __PAIR64__(v8, v9) >> 19;
    a3[56] = __PAIR64__(v123, v124) >> 15;
    a3[57] = v126;
    v130 = __PAIR64__(v4, v138) >> 19;
    a3[58] = v127 >> 15;
    a3[59] = __PAIR64__(v122, v123) >> 15;
    v131 = __PAIR64__(v128, v129) >> 17;
    HIDWORD(v127) = v129;
    LODWORD(v127) = __PAIR64__(v10, v139) >> 19;
    v132 = v127 >> 17;
    a3[24] = v128;
    a3[25] = v129;
    v133 = __PAIR64__(v130, v128) >> 17;
    a3[26] = v127;
    a3[27] = v130;
    v134 = __PAIR64__(v131, v132) >> 15;
    HIDWORD(v127) = v132;
    LODWORD(v127) = __PAIR64__(__PAIR64__(v10, v139) >> 19, v130) >> 17;
    v135 = v127 >> 15;
    a3[32] = v131;
    a3[33] = v132;
    v136 = __PAIR64__(v127, v133) >> 15;
    v137 = __PAIR64__(v133, v131) >> 15;
    a3[34] = v127;
    a3[35] = v133;
    v76 = __PAIR64__(v127 >> 15, v136) >> 30;
    result = 4;
    v78 = __PAIR64__(v136, v137) >> 30;
    a3[44] = v134;
    a3[45] = v135;
    a3[46] = v136;
    a3[47] = v137;
    v79 = __PAIR64__(v137, v134) >> 30;
    v80 = 63;
    v81 = 62;
    v82 = 61;
    v83 = 60;
    v84 = __PAIR64__(v134, v135) >> 30;
  }
  a3[v83] = v76;
  a3[v82] = v78;
  a3[v81] = v79;
  a3[v80] = v84;
  return result;
}

uint64_t Camellia_EncryptBlock_Rounds(int a1, unsigned int *a2, _DWORD *a3, _BYTE *a4)
{
  uint64_t v4;
  unsigned int v5;
  unsigned int v6;
  unsigned int v7;
  unsigned int v8;
  _DWORD *v9;
  uint64_t i;
  int v11;
  int v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  int v18;
  int v19;
  int v20;
  int v21;
  int v22;
  int v23;
  int v24;
  int v25;
  int v26;
  int v27;
  int v28;
  int v29;
  int v30;
  int v31;
  int v32;
  int v33;
  int v34;
  uint64_t result;
  int v36;
  int v37;
  int v38;
  int v39;
  int v40;
  int v41;
  int v42;
  int v43;
  int v44;
  int v45;

  v4 = 16 * a1;
  v5 = bswap32(*a2) ^ *a3;
  v6 = bswap32(a2[1]) ^ a3[1];
  v7 = bswap32(a2[2]) ^ a3[2];
  v8 = bswap32(a2[3]) ^ a3[3];
  v9 = a3 + 19;
  for (i = 4 * v4 - 64; ; i -= 64)
  {
    v11 = Camellia_SBOX[((unsigned __int16)(*((_WORD *)v9 - 30) ^ v5) >> 8) + 768] ^ Camellia_SBOX[(*((_BYTE *)v9 - 60) ^ v5) + 256] ^ Camellia_SBOX[((*(v9 - 15) ^ v5) >> 16) + 512] ^ Camellia_SBOX[(*(v9 - 15) ^ v5) >> 24];
    v12 = __ROR4__(v11, 8);
    v13 = Camellia_SBOX[((unsigned __int16)(*((_WORD *)v9 - 28) ^ v6) >> 8) + 256] ^ Camellia_SBOX[(*((_BYTE *)v9 - 56) ^ v6)] ^ Camellia_SBOX[((*(v9 - 14) ^ v6) >> 16) + 768] ^ Camellia_SBOX[((*(v9 - 14) ^ v6) >> 24) + 512] ^ v11;
    v14 = v13 ^ v7;
    v15 = v8 ^ v12 ^ v13;
    v16 = Camellia_SBOX[((unsigned __int16)(v14 ^ *((_WORD *)v9 - 26)) >> 8) + 768] ^ Camellia_SBOX[(v14 ^ *((_BYTE *)v9 - 52)) + 256] ^ Camellia_SBOX[((v14 ^ *(v9 - 13)) >> 16) + 512] ^ Camellia_SBOX[(v14 ^ *(v9 - 13)) >> 24];
    v17 = __ROR4__(v16, 8);
    v18 = Camellia_SBOX[((unsigned __int16)(v15 ^ *((_WORD *)v9 - 24)) >> 8) + 256] ^ Camellia_SBOX[(v15 ^ *((_BYTE *)v9 - 48))] ^ Camellia_SBOX[((v15 ^ *(v9 - 12)) >> 16) + 768] ^ Camellia_SBOX[((v15 ^ *(v9 - 12)) >> 24) + 512] ^ v16;
    v19 = v18 ^ v5;
    v20 = v6 ^ v17 ^ v18;
    v21 = Camellia_SBOX[((unsigned __int16)(v19 ^ *((_WORD *)v9 - 22)) >> 8) + 768] ^ Camellia_SBOX[(v19 ^ *((_BYTE *)v9 - 44)) + 256] ^ Camellia_SBOX[((v19 ^ *(v9 - 11)) >> 16) + 512] ^ Camellia_SBOX[(v19 ^ *(v9 - 11)) >> 24];
    v22 = __ROR4__(v21, 8);
    v23 = Camellia_SBOX[((unsigned __int16)(v20 ^ *((_WORD *)v9 - 20)) >> 8) + 256] ^ Camellia_SBOX[(v20 ^ *((_BYTE *)v9 - 40))] ^ Camellia_SBOX[((v20 ^ *(v9 - 10)) >> 16) + 768] ^ Camellia_SBOX[((v20 ^ *(v9 - 10)) >> 24) + 512] ^ v21;
    v24 = v23 ^ v14;
    v25 = v15 ^ v22 ^ v23;
    v26 = Camellia_SBOX[((unsigned __int16)(v24 ^ *((_WORD *)v9 - 18)) >> 8) + 768] ^ Camellia_SBOX[(v24 ^ *((_BYTE *)v9 - 36)) + 256] ^ Camellia_SBOX[((v24 ^ *(v9 - 9)) >> 16) + 512] ^ Camellia_SBOX[(v24 ^ *(v9 - 9)) >> 24];
    v27 = __ROR4__(v26, 8);
    v28 = Camellia_SBOX[((unsigned __int16)(v25 ^ *((_WORD *)v9 - 16)) >> 8) + 256] ^ Camellia_SBOX[(v25 ^ *((_BYTE *)v9 - 32))] ^ Camellia_SBOX[((v25 ^ *(v9 - 8)) >> 16) + 768] ^ Camellia_SBOX[((v25 ^ *(v9 - 8)) >> 24) + 512] ^ v26;
    v29 = v28 ^ v19;
    v30 = v20 ^ v27 ^ v28;
    v31 = Camellia_SBOX[((unsigned __int16)(v29 ^ *((_WORD *)v9 - 14)) >> 8) + 768] ^ Camellia_SBOX[(v29 ^ *((_BYTE *)v9 - 28)) + 256] ^ Camellia_SBOX[((v29 ^ *(v9 - 7)) >> 16) + 512] ^ Camellia_SBOX[(v29 ^ *(v9 - 7)) >> 24];
    v32 = v25 ^ __ROR4__(v31, 8);
    v33 = Camellia_SBOX[((unsigned __int16)(v30 ^ *((_WORD *)v9 - 12)) >> 8) + 256] ^ Camellia_SBOX[(v30 ^ *((_BYTE *)v9 - 24))] ^ Camellia_SBOX[((v30 ^ *(v9 - 6)) >> 16) + 768] ^ Camellia_SBOX[((v30 ^ *(v9 - 6)) >> 24) + 512] ^ v31;
    v34 = v33 ^ v24;
    result = v32 ^ v33;
    v36 = Camellia_SBOX[((unsigned __int16)(v34 ^ *((_WORD *)v9 - 10)) >> 8) + 768] ^ Camellia_SBOX[(v34 ^ *((_BYTE *)v9 - 20)) + 256] ^ Camellia_SBOX[((v34 ^ *(v9 - 5)) >> 16) + 512] ^ Camellia_SBOX[(v34 ^ *(v9 - 5)) >> 24];
    v37 = Camellia_SBOX[((unsigned __int16)(result ^ *((_WORD *)v9 - 8)) >> 8) + 256] ^ Camellia_SBOX[(result ^ *((_BYTE *)v9 - 16))] ^ Camellia_SBOX[((result ^ *(v9 - 4)) >> 16) + 768] ^ Camellia_SBOX[((result ^ *(v9 - 4)) >> 24) + 512] ^ v36;
    v38 = v37 ^ v29;
    v39 = v30 ^ __ROR4__(v36, 8) ^ v37;
    if (!i)
      break;
    v40 = *(v9 - 2);
    v6 = v39 ^ __ROR4__(*(v9 - 3) & v38, 31);
    v7 = (*v9 | result) ^ v34;
    v41 = *(v9 - 1);
    v9 += 16;
    v5 = (v6 | v40) ^ v38;
    v8 = result ^ __ROR4__(v7 & v41, 31);
  }
  v42 = a3[v4] ^ v34;
  v43 = *(v9 - 2) ^ result;
  v44 = *(v9 - 1) ^ v38;
  v45 = *v9 ^ v39;
  *a4 = HIBYTE(v42);
  a4[1] = BYTE2(v42);
  a4[2] = BYTE1(v42);
  a4[3] = v42;
  a4[4] = HIBYTE(v43);
  a4[5] = BYTE2(v43);
  a4[6] = BYTE1(v43);
  a4[7] = v43;
  a4[8] = HIBYTE(v44);
  a4[9] = BYTE2(v44);
  a4[10] = BYTE1(v44);
  a4[11] = v44;
  a4[12] = HIBYTE(v45);
  a4[13] = BYTE2(v45);
  a4[14] = BYTE1(v45);
  a4[15] = v45;
  return result;
}

uint64_t Camellia_EncryptBlock(int a1, unsigned int *a2, _DWORD *a3, _BYTE *a4)
{
  int v4;

  if (a1 == 128)
    v4 = 3;
  else
    v4 = 4;
  return Camellia_EncryptBlock_Rounds(v4, a2, a3, a4);
}

uint64_t Camellia_DecryptBlock_Rounds(int a1, unsigned int *a2, _DWORD *a3, _BYTE *a4)
{
  _DWORD *v4;
  unsigned int v5;
  unsigned int v6;
  unsigned int v7;
  unsigned int v8;
  uint64_t v9;
  _WORD *i;
  int v11;
  int v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  int v18;
  int v19;
  int v20;
  int v21;
  int v22;
  int v23;
  int v24;
  int v25;
  int v26;
  int v27;
  int v28;
  int v29;
  int v30;
  int v31;
  int v32;
  int v33;
  int v34;
  int v35;
  int v36;
  uint64_t result;
  int v38;
  int v39;
  int v40;
  int v41;
  int v42;
  int v43;
  int v44;

  v4 = &a3[16 * a1];
  v5 = bswap32(*a2) ^ *v4;
  v6 = bswap32(a2[1]) ^ v4[1];
  v7 = bswap32(a2[2]) ^ v4[2];
  v8 = bswap32(a2[3]) ^ v4[3];
  v9 = 16 * a1 - 16;
  for (i = v4 - 8; ; i -= 32)
  {
    v11 = Camellia_SBOX[((unsigned __int16)(i[12] ^ v5) >> 8) + 768] ^ Camellia_SBOX[(*((_BYTE *)i + 24) ^ v5) + 256] ^ Camellia_SBOX[((*((_DWORD *)i + 6) ^ v5) >> 16) + 512] ^ Camellia_SBOX[(*((_DWORD *)i + 6) ^ v5) >> 24];
    v12 = __ROR4__(v11, 8);
    v13 = Camellia_SBOX[((unsigned __int16)(i[14] ^ v6) >> 8) + 256] ^ Camellia_SBOX[(*((_BYTE *)i + 28) ^ v6)] ^ Camellia_SBOX[((*((_DWORD *)i + 7) ^ v6) >> 16) + 768] ^ Camellia_SBOX[((*((_DWORD *)i + 7) ^ v6) >> 24) + 512] ^ v11;
    v14 = v13 ^ v7;
    v15 = v8 ^ v12 ^ v13;
    v16 = Camellia_SBOX[((unsigned __int16)(v14 ^ i[8]) >> 8) + 768] ^ Camellia_SBOX[(v14 ^ *((_BYTE *)i + 16)) + 256] ^ Camellia_SBOX[((v14 ^ *((_DWORD *)i + 4)) >> 16) + 512] ^ Camellia_SBOX[(v14 ^ *((_DWORD *)i + 4)) >> 24];
    v17 = __ROR4__(v16, 8);
    v18 = Camellia_SBOX[((unsigned __int16)(v15 ^ i[10]) >> 8) + 256] ^ Camellia_SBOX[(v15 ^ *((_BYTE *)i + 20))] ^ Camellia_SBOX[((v15 ^ *((_DWORD *)i + 5)) >> 16) + 768] ^ Camellia_SBOX[((v15 ^ *((_DWORD *)i + 5)) >> 24) + 512] ^ v16;
    v19 = v18 ^ v5;
    v20 = v6 ^ v17 ^ v18;
    v21 = Camellia_SBOX[((unsigned __int16)(v19 ^ i[4]) >> 8) + 768] ^ Camellia_SBOX[(v19 ^ *((_BYTE *)i + 8)) + 256] ^ Camellia_SBOX[((v19 ^ *((_DWORD *)i + 2)) >> 16) + 512] ^ Camellia_SBOX[(v19 ^ *((_DWORD *)i + 2)) >> 24];
    v22 = __ROR4__(v21, 8);
    v23 = Camellia_SBOX[((unsigned __int16)(v20 ^ i[6]) >> 8) + 256] ^ Camellia_SBOX[(v20 ^ *((_BYTE *)i + 12))] ^ Camellia_SBOX[((v20 ^ *((_DWORD *)i + 3)) >> 16) + 768] ^ Camellia_SBOX[((v20 ^ *((_DWORD *)i + 3)) >> 24) + 512] ^ v21;
    v24 = v23 ^ v14;
    v25 = v15 ^ v22 ^ v23;
    v26 = Camellia_SBOX[((unsigned __int16)(v24 ^ *i) >> 8) + 768] ^ Camellia_SBOX[(v24 ^ *(_BYTE *)i) + 256] ^ Camellia_SBOX[((v24 ^ *(_DWORD *)i) >> 16) + 512] ^ Camellia_SBOX[(v24 ^ *(_DWORD *)i) >> 24];
    v27 = __ROR4__(v26, 8);
    v28 = Camellia_SBOX[((unsigned __int16)(v25 ^ i[2]) >> 8) + 256] ^ Camellia_SBOX[(v25 ^ *((_BYTE *)i + 4))] ^ Camellia_SBOX[((v25 ^ *((_DWORD *)i + 1)) >> 16) + 768] ^ Camellia_SBOX[((v25 ^ *((_DWORD *)i + 1)) >> 24) + 512] ^ v26;
    v29 = v28 ^ v19;
    v30 = v20 ^ v27 ^ v28;
    v31 = Camellia_SBOX[((unsigned __int16)(v29 ^ *(i - 4)) >> 8) + 768] ^ Camellia_SBOX[(v29 ^ *((_BYTE *)i - 8)) + 256] ^ Camellia_SBOX[((v29 ^ *((_DWORD *)i - 2)) >> 16) + 512] ^ Camellia_SBOX[(v29 ^ *((_DWORD *)i - 2)) >> 24];
    v32 = v25 ^ __ROR4__(v31, 8);
    v33 = Camellia_SBOX[((unsigned __int16)(v30 ^ *(i - 2)) >> 8) + 256] ^ Camellia_SBOX[(v30 ^ *((_BYTE *)i - 4))] ^ Camellia_SBOX[((v30 ^ *((_DWORD *)i - 1)) >> 16) + 768] ^ Camellia_SBOX[((v30 ^ *((_DWORD *)i - 1)) >> 24) + 512] ^ v31;
    v34 = v33 ^ v24;
    v35 = v32 ^ v33;
    v36 = Camellia_SBOX[((unsigned __int16)(v34 ^ *(i - 8)) >> 8) + 768] ^ Camellia_SBOX[(v34 ^ *((_BYTE *)i - 16)) + 256] ^ Camellia_SBOX[((v34 ^ *((_DWORD *)i - 4)) >> 16) + 512] ^ Camellia_SBOX[(v34 ^ *((_DWORD *)i - 4)) >> 24];
    result = v30 ^ __ROR4__(v36, 8);
    v38 = Camellia_SBOX[((unsigned __int16)(v35 ^ *(i - 6)) >> 8) + 256] ^ Camellia_SBOX[(v35 ^ *((_BYTE *)i - 12))] ^ Camellia_SBOX[((v35 ^ *((_DWORD *)i - 3)) >> 16) + 768] ^ Camellia_SBOX[((v35 ^ *((_DWORD *)i - 3)) >> 24) + 512] ^ v36;
    v39 = v38 ^ v29;
    v40 = result ^ v38;
    if (!v9)
      break;
    v6 = v40 ^ __ROR4__(*((_DWORD *)i - 6) & v39, 31);
    v7 = (*((_DWORD *)i - 7) | v35) ^ v34;
    v5 = (v6 | *((_DWORD *)i - 5)) ^ v39;
    v8 = v35 ^ __ROR4__(v7 & *((_DWORD *)i - 8), 31);
    v9 -= 16;
  }
  v41 = *a3 ^ v34;
  v42 = a3[1] ^ v35;
  v43 = a3[2] ^ v39;
  v44 = a3[3] ^ v40;
  *a4 = HIBYTE(v41);
  a4[1] = BYTE2(v41);
  a4[2] = BYTE1(v41);
  a4[3] = v41;
  a4[4] = HIBYTE(v42);
  a4[5] = BYTE2(v42);
  a4[6] = BYTE1(v42);
  a4[7] = v42;
  a4[8] = HIBYTE(v43);
  a4[9] = BYTE2(v43);
  a4[10] = BYTE1(v43);
  a4[11] = v43;
  a4[12] = HIBYTE(v44);
  a4[13] = BYTE2(v44);
  a4[14] = BYTE1(v44);
  a4[15] = v44;
  return result;
}

uint64_t Camellia_DecryptBlock(int a1, unsigned int *a2, _DWORD *a3, _BYTE *a4)
{
  int v4;

  if (a1 == 128)
    v4 = 3;
  else
    v4 = 4;
  return Camellia_DecryptBlock_Rounds(v4, a2, a3, a4);
}

int RSA_sign(int type, const unsigned __int8 *m, unsigned int m_length, unsigned __int8 *sigret, unsigned int *siglen, RSA *rsa)
{
  const unsigned __int8 *v9;
  int (__cdecl *rsa_sign)(int, const unsigned __int8 *, unsigned int, unsigned __int8 *, unsigned int *, const RSA *);
  void *v12;
  int v13;
  int v14;
  signed int v15;
  int v16;
  int v17;
  void *v18;

  v9 = m;
  v18 = 0;
  v17 = 0;
  if ((rsa->flags & 0x40) != 0)
  {
    rsa_sign = rsa->meth->rsa_sign;
    if (rsa_sign)
      return ((uint64_t (*)(_QWORD, const unsigned __int8 *, _QWORD, unsigned __int8 *, unsigned int *, RSA *))rsa_sign)(*(_QWORD *)&type, m, *(_QWORD *)&m_length, sigret, siglen, rsa);
  }
  if (type == 114)
  {
    if (m_length != 36)
    {
      ERR_put_error(4, 4095, 143, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/rsa/rsa_sign.c", 144);
      return 0;
    }
    v12 = 0;
    v13 = 36;
  }
  else
  {
    v14 = encode_pkcs1(&v18, &v17, type, (uint64_t)m, m_length);
    v12 = v18;
    v13 = v17;
    if (!v14)
    {
LABEL_13:
      v16 = 0;
      goto LABEL_14;
    }
    v9 = (const unsigned __int8 *)v18;
  }
  if (v13 > RSA_size(rsa) - 11)
  {
    ERR_put_error(4, 4095, 112, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/rsa/rsa_sign.c", 155);
    goto LABEL_13;
  }
  v15 = RSA_private_encrypt(v13, v9, sigret, rsa, 1);
  if (v15 < 1)
    goto LABEL_13;
  *siglen = v15;
  v16 = 1;
LABEL_14:
  freezero(v12, v13);
  return v16;
}

uint64_t encode_pkcs1(_QWORD *a1, int *a2, int n, uint64_t a4, int a5)
{
  ASN1_OBJECT *v9;
  int v10;
  int v12;
  int v13;
  unsigned __int8 *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  _QWORD v18[2];
  ASN1_OBJECT *v19;
  _QWORD *v20;
  X509_SIG a;

  v19 = 0;
  v20 = 0;
  v17 = 0;
  v18[0] = 0;
  v15 = 0;
  v16 = 0;
  v14 = 0;
  a.algor = (X509_ALGOR *)&v19;
  v9 = OBJ_nid2obj(n);
  v19 = v9;
  if (!v9)
  {
    v12 = 117;
    v13 = 100;
LABEL_7:
    ERR_put_error(4, 4095, v12, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/rsa/rsa_sign.c", v13);
    return 0;
  }
  if (!v9->length)
  {
    v12 = 116;
    v13 = 105;
    goto LABEL_7;
  }
  LODWORD(v18[0]) = 5;
  v18[1] = 0;
  v20 = v18;
  a.digest = (ASN1_OCTET_STRING *)&v15;
  v16 = a4;
  LODWORD(v15) = a5;
  v10 = i2d_X509_SIG(&a, &v14);
  if ((v10 & 0x80000000) == 0)
  {
    *a1 = v14;
    *a2 = v10;
    return 1;
  }
  return 0;
}

uint64_t int_rsa_verify(int a1, unsigned __int8 *a2, unsigned int a3, _DWORD *a4, _QWORD *a5, const unsigned __int8 *a6, size_t a7, RSA *a8)
{
  unsigned __int8 *v16;
  int v17;
  unsigned int v18;
  int v19;
  __int128 v20;
  __int128 v21;
  uint64_t v22;
  int v23;
  int v24;
  const char *v25;
  const EVP_MD *digestbyname;
  unsigned int v27;
  int v28;
  int v30;
  void *__b1;

  __b1 = 0;
  v30 = 0;
  if (RSA_size(a8) == a7)
  {
    v16 = (unsigned __int8 *)malloc_type_malloc(a7, 0x653958A5uLL);
    if (v16)
    {
      v17 = RSA_public_decrypt(a7, a6, v16, a8, 1);
      if (v17 < 1)
      {
LABEL_27:
        v19 = 0;
LABEL_28:
        v22 = 0;
        goto LABEL_29;
      }
      v18 = v17;
      if (a1 == 114)
      {
        if (v17 == 36)
        {
          if (a4)
          {
            v19 = 0;
            v20 = *(_OWORD *)v16;
            v21 = *((_OWORD *)v16 + 1);
            a4[8] = *((_DWORD *)v16 + 8);
            *(_OWORD *)a4 = v20;
            *((_OWORD *)a4 + 1) = v21;
            *a5 = 36;
LABEL_8:
            v22 = 1;
LABEL_29:
            freezero(__b1, v19);
            freezero(v16, a7);
            return v22;
          }
          if (a3 == 36)
          {
            if (!timingsafe_bcmp(v16, a2, 0x24uLL))
            {
              v19 = 0;
              goto LABEL_8;
            }
            v23 = 104;
            v24 = 221;
          }
          else
          {
            v23 = 131;
            v24 = 216;
          }
        }
        else
        {
          v23 = 143;
          v24 = 207;
        }
        goto LABEL_26;
      }
      if (a4)
      {
        v25 = OBJ_nid2sn(a1);
        digestbyname = EVP_get_digestbyname(v25);
        if (!digestbyname)
        {
          v23 = 117;
          v24 = 235;
          goto LABEL_26;
        }
        v27 = EVP_MD_size(digestbyname);
        if (v27 > v18)
        {
          v23 = 143;
          v24 = 239;
          goto LABEL_26;
        }
        a3 = v27;
        a2 = &v16[v18 - v27];
      }
      v28 = encode_pkcs1(&__b1, &v30, a1, (uint64_t)a2, a3);
      v19 = v30;
      if (v28)
      {
        if (v30 == v18 && !timingsafe_bcmp(__b1, v16, v18))
        {
          if (a4)
          {
            memcpy(a4, a2, a3);
            *a5 = a3;
          }
          v22 = 1;
          v19 = v18;
          goto LABEL_29;
        }
        ERR_put_error(4, 4095, 104, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/rsa/rsa_sign.c", 251);
      }
      goto LABEL_28;
    }
    v23 = 65;
    v24 = 193;
LABEL_26:
    ERR_put_error(4, 4095, v23, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/rsa/rsa_sign.c", v24);
    goto LABEL_27;
  }
  ERR_put_error(4, 4095, 119, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/rsa/rsa_sign.c", 187);
  return 0;
}

int RSA_verify(int type, const unsigned __int8 *m, unsigned int m_length, unsigned __int8 *sigbuf, unsigned int siglen, RSA *rsa)
{
  int (__cdecl *rsa_verify)(int, const unsigned __int8 *, unsigned int, unsigned __int8 *, unsigned int, const RSA *);

  if ((rsa->flags & 0x40) != 0 && (rsa_verify = rsa->meth->rsa_verify) != 0)
    return ((uint64_t (*)(_QWORD, const unsigned __int8 *, _QWORD, unsigned __int8 *, _QWORD, RSA *))rsa_verify)(*(_QWORD *)&type, m, *(_QWORD *)&m_length, sigbuf, *(_QWORD *)&siglen, rsa);
  else
    return int_rsa_verify(type, (unsigned __int8 *)m, m_length, 0, 0, sigbuf, siglen, rsa);
}

void ERR_load_DSA_strings(void)
{
  if (!ERR_func_error_string(DSA_str_functs))
  {
    ERR_load_strings(0, (ERR_STRING_DATA *)&DSA_str_functs);
    ERR_load_strings(0, (ERR_STRING_DATA *)&DSA_str_reasons);
  }
}

void ENGINE_unregister_digests(ENGINE *e)
{
  engine_table_unregister(&digest_table, e);
}

int ENGINE_register_digests(ENGINE *e)
{
  uint64_t (*v1)(void);
  int v3;

  v1 = (uint64_t (*)(void))*((_QWORD *)e + 11);
  if (v1 && (v3 = v1(), v3 > 0))
    return engine_table_register(&digest_table, (uint64_t)engine_unregister_all_digests, (char *)e, 0, v3, 0);
  else
    return 1;
}

void engine_unregister_all_digests()
{
  engine_table_cleanup(&digest_table);
}

void ENGINE_register_all_digests(void)
{
  ENGINE *first;
  ENGINE *next;

  first = ENGINE_get_first();
  if (first)
  {
    next = first;
    do
    {
      ENGINE_register_digests(next);
      next = ENGINE_get_next(next);
    }
    while (next);
  }
}

int ENGINE_set_default_digests(ENGINE *e)
{
  uint64_t (*v1)(void);
  int v3;

  v1 = (uint64_t (*)(void))*((_QWORD *)e + 11);
  if (v1 && (v3 = v1(), v3 > 0))
    return engine_table_register(&digest_table, (uint64_t)engine_unregister_all_digests, (char *)e, 0, v3, 1);
  else
    return 1;
}

ENGINE *__cdecl ENGINE_get_digest_engine(int nid)
{
  return (ENGINE *)engine_table_select(&digest_table, nid);
}

const EVP_MD *__cdecl ENGINE_get_digest(ENGINE *e, int nid)
{
  unsigned int (*v2)(void);
  const EVP_MD *v4;

  v4 = 0;
  v2 = (unsigned int (*)(void))*((_QWORD *)e + 11);
  if (v2 && v2())
    return v4;
  ERR_put_error(38, 4095, 147, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/engine/tb_digest.c", 133);
  return 0;
}

ENGINE_DIGESTS_PTR ENGINE_get_digests(const ENGINE *e)
{
  return (ENGINE_DIGESTS_PTR)*((_QWORD *)e + 11);
}

int ENGINE_set_digests(ENGINE *e, ENGINE_DIGESTS_PTR f)
{
  *((_QWORD *)e + 11) = f;
  return 1;
}

uint64_t bn_is_prime_bpsw(int *a1, const BIGNUM *a2, BN_CTX *a3, uint64_t a4)
{
  int is_odd;
  BN_CTX *v9;
  uint64_t v10;
  const BIGNUM *v12;
  uint64_t i;
  unint64_t v14;
  unint64_t v15;
  BIGNUM *v16;
  BIGNUM *v17;
  BIGNUM *v18;
  BIGNUM *v19;
  BIGNUM *v20;
  BIGNUM *v21;
  BIGNUM *v22;
  BIGNUM *v23;
  BN_MONT_CTX *v24;
  int v25;
  const BIGNUM *v26;
  const BIGNUM *v27;
  int v28;
  BN_MONT_CTX *v29;
  BIGNUM *a;

  if (BN_is_word((uint64_t)a2, 2))
  {
    is_odd = 1;
    goto LABEL_3;
  }
  v12 = BN_value_one();
  if (BN_cmp(a2, v12) < 1)
  {
    is_odd = 0;
    goto LABEL_3;
  }
  is_odd = BN_is_odd((uint64_t)a2);
  if (!is_odd)
  {
LABEL_3:
    v9 = 0;
    *a1 = is_odd;
    goto LABEL_4;
  }
  for (i = 0; i != 2048; ++i)
  {
    v14 = (unsigned __int16)primes[i];
    v15 = BN_mod_word(a2, v14);
    if (v15 == -1)
    {
      v9 = 0;
      goto LABEL_51;
    }
    if (!v15)
    {
      is_odd = BN_is_word((uint64_t)a2, v14);
      goto LABEL_3;
    }
  }
  v9 = a3;
  if (!a3)
  {
    v9 = BN_CTX_new();
    if (!v9)
      goto LABEL_51;
  }
  BN_CTX_start(v9);
  v16 = BN_CTX_get(v9);
  if (!v16)
    goto LABEL_49;
  v17 = v16;
  v18 = BN_CTX_get(v9);
  if (!v18)
    goto LABEL_49;
  v19 = v18;
  v20 = BN_CTX_get(v9);
  if (!v20)
    goto LABEL_49;
  v21 = v20;
  v22 = BN_CTX_get(v9);
  if (!v22)
    goto LABEL_49;
  v23 = v22;
  if (BN_is_word((uint64_t)a2, 2) || BN_is_word((uint64_t)a2, 3))
  {
    v24 = 0;
    goto LABEL_23;
  }
  v26 = BN_value_one();
  if (BN_cmp(a2, v26) < 1 || !BN_is_odd((uint64_t)a2))
  {
    v25 = 0;
    v24 = 0;
LABEL_24:
    *a1 = v25;
    goto LABEL_25;
  }
  v27 = BN_value_one();
  if (!BN_sub(v21, a2, v27))
    goto LABEL_49;
  a = v23;
  v28 = -1;
  do
    ++v28;
  while (!BN_is_bit_set(v21, v28));
  if (!BN_rshift(v19, v21, v28))
  {
LABEL_49:
    v24 = 0;
    goto LABEL_50;
  }
  v29 = BN_MONT_CTX_new();
  v24 = v29;
  if (!v29
    || !BN_MONT_CTX_set(v29, a2, v9)
    || !BN_set_word(v17, 2uLL)
    || !bn_fermat(a1, a2, v21, v19, v28, v17, v9, v24))
  {
    goto LABEL_50;
  }
  if (*a1)
  {
    if (!BN_set_word(a, 3uLL))
      goto LABEL_50;
    if (a4)
    {
      while (bn_rand_interval(v17, a, v21) && bn_fermat(a1, a2, v21, v19, v28, v17, v9, v24))
      {
        if (!*a1)
          goto LABEL_25;
        v25 = 1;
        if (!--a4)
          goto LABEL_24;
      }
LABEL_50:
      BN_MONT_CTX_free(v24);
      BN_CTX_end(v9);
LABEL_51:
      v10 = 0;
      goto LABEL_5;
    }
LABEL_23:
    v25 = 1;
    goto LABEL_24;
  }
LABEL_25:
  BN_MONT_CTX_free(v24);
  BN_CTX_end(v9);
  if (*a1 && !bn_strong_lucas_selfridge(a1, a2, v9))
    goto LABEL_51;
LABEL_4:
  v10 = 1;
LABEL_5:
  if (v9 != a3)
    BN_CTX_free(v9);
  return v10;
}

uint64_t bn_strong_lucas_selfridge(int *a1, const BIGNUM *a2, BN_CTX *ctx)
{
  uint64_t v6;
  BIGNUM *v7;
  BIGNUM *v8;
  BIGNUM *v9;
  BIGNUM *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  _BOOL4 v16;

  v16 = 0;
  BN_CTX_start(ctx);
  if (!bn_is_perfect_square(&v16, a2, ctx))
  {
LABEL_16:
    v6 = 0;
    goto LABEL_17;
  }
  if (!v16)
  {
    v7 = BN_CTX_get(ctx);
    if (v7)
    {
      v8 = v7;
      v9 = BN_CTX_get(ctx);
      if (v9)
      {
        v10 = v9;
        if (BN_set_word(v8, 5uLL))
        {
          if (BN_set_word(v10, 2uLL))
          {
            v11 = 1;
            v12 = 0xFFFFFFFFLL;
            while (1)
            {
              v13 = v12;
              v14 = BN_kronecker(v8, a2, ctx);
              if (v14 == -2)
                break;
              if (v14 == -1)
              {
                if (bn_strong_lucas_test(a1, a2, v8, ctx))
                  goto LABEL_4;
                goto LABEL_16;
              }
              if (!v14)
                goto LABEL_3;
              if (!BN_uadd(v8, v8, v10))
                goto LABEL_16;
              BN_set_negative(v8, v13 == -1);
              v12 = v11;
              v11 = v13;
            }
          }
        }
      }
    }
    goto LABEL_16;
  }
LABEL_3:
  *a1 = 0;
LABEL_4:
  v6 = 1;
LABEL_17:
  BN_CTX_end(ctx);
  return v6;
}

uint64_t bn_fermat(int *a1, const BIGNUM *a2, const BIGNUM *a3, const BIGNUM *a4, int a5, const BIGNUM *a6, BN_CTX *ctx, BN_MONT_CTX *a8)
{
  BIGNUM *v16;
  BIGNUM *v17;
  const BIGNUM *v18;
  uint64_t v19;
  int v21;
  int v22;
  int v23;
  _BOOL4 is_one;

  BN_CTX_start(ctx);
  v16 = BN_CTX_get(ctx);
  if (v16)
  {
    v17 = v16;
    v18 = BN_value_one();
    if (BN_cmp(a6, v18) >= 1 && BN_cmp(a6, a3) < 0 && BN_mod_exp_mont_ct(v17, a6, a4, a2, ctx, a8))
    {
      if (BN_is_one((uint64_t)v17) || !BN_cmp(v17, a3))
      {
LABEL_8:
        v21 = 1;
      }
      else
      {
        v22 = a5 - 2;
        if (a5 >= 2)
        {
          while (1)
          {
            v23 = v22;
            if (!BN_mod_sqr(v17, v17, a2, ctx))
              goto LABEL_4;
            if (!BN_cmp(v17, a3))
              goto LABEL_8;
            is_one = BN_is_one((uint64_t)v17);
            v21 = 0;
            if (!is_one)
            {
              v22 = v23 - 1;
              if (v23)
                continue;
            }
            goto LABEL_9;
          }
        }
        v21 = 0;
      }
LABEL_9:
      *a1 = v21;
      v19 = 1;
      goto LABEL_5;
    }
  }
LABEL_4:
  v19 = 0;
LABEL_5:
  BN_CTX_end(ctx);
  return v19;
}

uint64_t bn_strong_lucas_test(int *a1, const BIGNUM *a2, const BIGNUM *a3, BN_CTX *ctx)
{
  BIGNUM *v8;
  BIGNUM *v9;
  BIGNUM *v10;
  BIGNUM *v11;
  BIGNUM *v12;
  BIGNUM *v13;
  int v14;
  int is_bit_set;
  int v16;
  int v17;
  int v18;
  int v19;
  uint64_t v20;

  BN_CTX_start(ctx);
  v8 = BN_CTX_get(ctx);
  if (!v8)
    goto LABEL_23;
  v9 = v8;
  v10 = BN_CTX_get(ctx);
  if (!v10)
    goto LABEL_23;
  v11 = v10;
  v12 = BN_CTX_get(ctx);
  if (!v12)
    goto LABEL_23;
  v13 = v12;
  v14 = -2;
  do
  {
    is_bit_set = BN_is_bit_set(a2, v14 + 2);
    ++v14;
  }
  while (is_bit_set);
  if (!BN_rshift(v9, a2, v14 + 1)
    || !BN_set_bit(v9, 0)
    || !BN_one((uint64_t)v11)
    || !BN_one((uint64_t)v13))
  {
    goto LABEL_23;
  }
  v16 = BN_num_bits(v9);
  if (v16 >= 2)
  {
    v17 = v16 - 1;
    do
    {
      v18 = BN_is_bit_set(v9, --v17);
      if (!bn_lucas_step(v11, v13, v18, a3, a2, ctx))
        goto LABEL_23;
    }
    while (v17 >= 1);
  }
  if (!BN_is_zero((uint64_t)v11) && !BN_is_zero((uint64_t)v13))
  {
    if ((v14 + 1) < 2)
    {
      v19 = 0;
      goto LABEL_17;
    }
    while (bn_lucas_step(v11, v13, 0, a3, a2, ctx))
    {
      if (BN_is_zero((uint64_t)v13))
        goto LABEL_16;
      v19 = 0;
      if (!--v14)
        goto LABEL_17;
    }
LABEL_23:
    v20 = 0;
    goto LABEL_24;
  }
LABEL_16:
  v19 = 1;
LABEL_17:
  *a1 = v19;
  v20 = 1;
LABEL_24:
  BN_CTX_end(ctx);
  return v20;
}

BOOL bn_lucas_step(BIGNUM *a1, BIGNUM *a2, int a3, const BIGNUM *a4, const BIGNUM *a5, BN_CTX *ctx)
{
  BIGNUM *v12;
  BIGNUM *v13;
  _BOOL8 v14;

  BN_CTX_start(ctx);
  v12 = BN_CTX_get(ctx);
  v14 = 0;
  if (v12)
  {
    v13 = v12;
    if (BN_sqr(v12, a1, ctx))
    {
      if (BN_mul(v13, a4, v13, ctx)
        && BN_mod_mul(a1, a1, a2, a5, ctx)
        && BN_sqr(a2, a2, ctx)
        && BN_add(a2, a2, v13)
        && bn_div_by_two_mod_odd_n(a2, a5, ctx)
        && (a3 != 1
         || BN_mul(v13, a4, a1, ctx)
         && BN_add(a1, a1, a2)
         && bn_div_by_two_mod_odd_n(a1, a5, ctx)
         && BN_add(a2, a2, v13)
         && bn_div_by_two_mod_odd_n(a2, a5, ctx)))
      {
        v14 = 1;
      }
    }
  }
  BN_CTX_end(ctx);
  return v14;
}

uint64_t bn_div_by_two_mod_odd_n(BIGNUM *a1, const BIGNUM *a2, BN_CTX *a3)
{
  uint64_t result;

  result = BN_is_odd((uint64_t)a2);
  if ((_DWORD)result)
  {
    if (!BN_is_odd((uint64_t)a1) || (result = BN_add(a1, a1, a2), (_DWORD)result))
    {
      result = BN_rshift1(a1, a1);
      if ((_DWORD)result)
        return BN_mod_ct(a1, a1, a2, a3) != 0;
    }
  }
  return result;
}

void ERR_load_BIO_strings(void)
{
  if (!ERR_func_error_string(BIO_str_functs))
  {
    ERR_load_strings(0, (ERR_STRING_DATA *)&BIO_str_functs);
    ERR_load_strings(0, (ERR_STRING_DATA *)&BIO_str_reasons);
  }
}

void *EVP_gost2814789imit()
{
  return &gost2814789imit_md;
}

uint64_t gost2814789_init(uint64_t a1)
{
  return GOST2814789IMIT_Init(*(_QWORD *)(a1 + 24), 824);
}

uint64_t gost2814789_update(uint64_t a1, char *a2, size_t a3)
{
  return GOST2814789IMIT_Update(*(_QWORD *)(a1 + 24), a2, a3);
}

uint64_t gost2814789_final(uint64_t a1, _DWORD *a2)
{
  return GOST2814789IMIT_Final(a2, *(_QWORD *)(a1 + 24));
}

uint64_t gost2814789_md_ctrl(uint64_t a1, int a2, int a3, uint64_t a4)
{
  uint64_t v4;

  v4 = *(_QWORD *)(a1 + 24);
  if (a2 == 4)
    return Gost2814789_set_sbox(v4 + 20, a3);
  if (a2 == 3)
    return Gost2814789_set_key(v4 + 20, a4, a3);
  return 4294967294;
}

EVP_PKEY *__cdecl PEM_read_bio_PrivateKey(BIO *bp, EVP_PKEY **x, pem_password_cb *cb, void *u)
{
  char *v7;
  signed int v8;
  char *str;
  EVP_PKEY *v10;
  PKCS8_PRIV_KEY_INFO *v11;
  PKCS8_PRIV_KEY_INFO *v12;
  X509_SIG *v13;
  X509_SIG *v14;
  int v15;
  uint64_t plen;
  unsigned __int8 *pdata;
  unsigned __int8 *pp;
  char *pnm;
  char buf[1024];
  uint64_t v22;

  v22 = *MEMORY[0x24BDAC8D0];
  pnm = 0;
  plen = 0;
  pdata = 0;
  if (PEM_bytes_read_bio(&pdata, &plen, &pnm, "ANY PRIVATE KEY", bp, cb, u))
  {
    pp = pdata;
    v7 = pnm;
    if (!strcmp(pnm, "PRIVATE KEY"))
    {
      v11 = d2i_PKCS8_PRIV_KEY_INFO(0, (const unsigned __int8 **)&pp, plen);
      if (!v11)
        goto LABEL_22;
      v12 = v11;
    }
    else
    {
      if (strcmp(v7, "ENCRYPTED PRIVATE KEY"))
      {
        v8 = pem_check_suffix(v7, "PRIVATE KEY");
        if (v8 >= 1)
        {
          str = EVP_PKEY_asn1_find_str(0, pnm, v8);
          if (str)
          {
            if (*((_QWORD *)str + 23))
            {
              v10 = d2i_PrivateKey(*(_DWORD *)str, x, (const unsigned __int8 **)&pp, plen);
              if (v10)
                goto LABEL_24;
            }
          }
        }
        goto LABEL_22;
      }
      v13 = d2i_X509_SIG(0, (const unsigned __int8 **)&pp, plen);
      if (!v13)
        goto LABEL_22;
      v14 = v13;
      if (cb)
        v15 = ((uint64_t (*)(char *, uint64_t, _QWORD, void *))cb)(buf, 1024, 0, u);
      else
        v15 = PEM_def_callback(buf, 1024, 0, u);
      if (v15 < 1)
      {
        ERR_put_error(9, 4095, 104, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/pem/pem_pkey.c", 120);
        X509_SIG_free(v14);
        goto LABEL_23;
      }
      v12 = PKCS8_decrypt(v14, buf, v15);
      X509_SIG_free(v14);
      if (!v12)
      {
LABEL_22:
        ERR_put_error(9, 4095, 13, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/pem/pem_pkey.c", 144);
LABEL_23:
        v10 = 0;
LABEL_24:
        free(pnm);
        freezero(pdata, plen);
        return v10;
      }
    }
    v10 = EVP_PKCS82PKEY(v12);
    if (x)
    {
      EVP_PKEY_free(*x);
      *x = v10;
    }
    PKCS8_PRIV_KEY_INFO_free(v12);
    if (v10)
      goto LABEL_24;
    goto LABEL_22;
  }
  return 0;
}

int PEM_write_bio_PrivateKey(BIO *bp, EVP_PKEY *x, const EVP_CIPHER *enc, unsigned __int8 *kstr, int klen, pem_password_cb *cb, void *u)
{
  char *ptr;

  ptr = x->pkey.ptr;
  if (ptr && !*((_QWORD *)ptr + 9))
    return PEM_write_bio_PrivateKey_traditional(bp, (uint64_t)x, enc, kstr, klen, cb, u);
  else
    return PEM_write_bio_PKCS8PrivateKey(bp, x, enc, (char *)kstr, klen, cb, u);
}

uint64_t PEM_write_bio_PrivateKey_traditional(BIO *a1, uint64_t a2, const EVP_CIPHER *a3, unsigned __int8 *a4, int a5, pem_password_cb *a6, void *a7)
{
  char __str[80];
  uint64_t v16;

  v16 = *MEMORY[0x24BDAC8D0];
  snprintf(__str, 0x50uLL, "%s PRIVATE KEY", *(const char **)(*(_QWORD *)(a2 + 16) + 16));
  return PEM_ASN1_write_bio((i2d_of_void *)i2d_PrivateKey, __str, a1, (char *)a2, a3, a4, a5, a6, a7);
}

EVP_PKEY *PEM_read_bio_Parameters(BIO *bp, EVP_PKEY **a2)
{
  int v3;
  signed int v4;
  EVP_PKEY *v5;
  EVP_PKEY *v6;
  unsigned int (*v7)(EVP_PKEY *, unsigned __int8 **, _QWORD);
  uint64_t v9;
  unsigned __int8 *pdata;
  unsigned __int8 *v11;
  char *pnm;

  pnm = 0;
  v9 = 0;
  pdata = 0;
  if (PEM_bytes_read_bio(&pdata, &v9, &pnm, "PARAMETERS", bp, 0, 0))
  {
    v11 = pdata;
    v3 = pem_check_suffix(pnm, "PARAMETERS");
    if (v3 >= 1)
    {
      v4 = v3;
      v5 = EVP_PKEY_new();
      if (v5)
      {
        v6 = v5;
        if (EVP_PKEY_set_type_str((uint64_t)v5, pnm, v4))
        {
          v7 = (unsigned int (*)(EVP_PKEY *, unsigned __int8 **, _QWORD))*((_QWORD *)v6->pkey.ptr + 14);
          if (v7)
          {
            if (v7(v6, &v11, v9))
            {
              if (a2)
              {
                EVP_PKEY_free(*a2);
                *a2 = v6;
              }
              goto LABEL_12;
            }
          }
        }
        EVP_PKEY_free(v6);
      }
    }
    ERR_put_error(9, 4095, 13, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/pem/pem_pkey.c", 210);
    v6 = 0;
LABEL_12:
    free(pnm);
    free(pdata);
    return v6;
  }
  return 0;
}

uint64_t PEM_write_bio_Parameters(BIO *a1, uint64_t a2)
{
  uint64_t v2;
  char __str[80];
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v2 = *(_QWORD *)(a2 + 16);
  if (!v2 || !*(_QWORD *)(v2 + 120))
    return 0;
  snprintf(__str, 0x50uLL, "%s PARAMETERS", *(const char **)(v2 + 16));
  return PEM_ASN1_write_bio(*(i2d_of_void **)(*(_QWORD *)(a2 + 16) + 120), __str, a1, (char *)a2, 0, 0, 0, 0, 0);
}

EVP_PKEY *__cdecl PEM_read_PrivateKey(FILE *fp, EVP_PKEY **x, pem_password_cb *cb, void *u)
{
  BIO_METHOD *v8;
  BIO *v9;
  BIO *v10;
  EVP_PKEY *bio_PrivateKey;

  v8 = BIO_s_file();
  v9 = BIO_new(v8);
  if (v9)
  {
    v10 = v9;
    BIO_ctrl(v9, 106, 0, fp);
    bio_PrivateKey = PEM_read_bio_PrivateKey(v10, x, cb, u);
    BIO_free(v10);
    return bio_PrivateKey;
  }
  else
  {
    ERR_put_error(9, 4095, 7, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/pem/pem_pkey.c", 237);
    return 0;
  }
}

int PEM_write_PrivateKey(FILE *fp, EVP_PKEY *x, const EVP_CIPHER *enc, unsigned __int8 *kstr, int klen, pem_password_cb *cb, void *u)
{
  BIO *v13;
  BIO *v14;
  int v15;

  v13 = BIO_new_fp(fp, 0);
  if (v13)
  {
    v14 = v13;
    v15 = PEM_write_bio_PrivateKey(v13, x, enc, kstr, klen, cb, u);
    BIO_free(v14);
    return v15;
  }
  else
  {
    ERR_put_error(9, 4095, 7, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/pem/pem_pkey.c", 254);
    return 0;
  }
}

uint64_t explicit_bzero(void *a1, size_t a2)
{
  bzero(a1, a2);
  return j____explicit_bzero_hook();
}

const EVP_CIPHER *EVP_rc4(void)
{
  return (const EVP_CIPHER *)&r4_cipher;
}

const EVP_CIPHER *EVP_rc4_40(void)
{
  return (const EVP_CIPHER *)&r4_40_cipher;
}

uint64_t rc4_init_key(const EVP_CIPHER_CTX *a1, const unsigned __int8 *a2)
{
  RC4_KEY *cipher_data;
  int v4;

  cipher_data = (RC4_KEY *)a1->cipher_data;
  v4 = EVP_CIPHER_CTX_key_length(a1);
  RC4_set_key(cipher_data, v4, a2);
  return 1;
}

uint64_t rc4_cipher(uint64_t a1, unsigned __int8 *outdata, const unsigned __int8 *a3, unint64_t len)
{
  RC4(*(RC4_KEY **)(a1 + 120), len, a3, outdata);
  return 1;
}

void ENGINE_unregister_RAND(ENGINE *e)
{
  engine_table_unregister(&rand_table, e);
}

int ENGINE_register_RAND(ENGINE *e)
{
  if (*((_QWORD *)e + 8))
    return engine_table_register(&rand_table, (uint64_t)engine_unregister_all_RAND, (char *)e, &dummy_nid_4, 1, 0);
  else
    return 1;
}

void engine_unregister_all_RAND()
{
  engine_table_cleanup(&rand_table);
}

void ENGINE_register_all_RAND(void)
{
  ENGINE *first;
  ENGINE *next;

  first = ENGINE_get_first();
  if (first)
  {
    next = first;
    do
    {
      if (*((_QWORD *)next + 8))
        engine_table_register(&rand_table, (uint64_t)engine_unregister_all_RAND, (char *)next, &dummy_nid_4, 1, 0);
      next = ENGINE_get_next(next);
    }
    while (next);
  }
}

int ENGINE_set_default_RAND(ENGINE *e)
{
  if (*((_QWORD *)e + 8))
    return engine_table_register(&rand_table, (uint64_t)engine_unregister_all_RAND, (char *)e, &dummy_nid_4, 1, 1);
  else
    return 1;
}

ENGINE *ENGINE_get_default_RAND(void)
{
  return (ENGINE *)engine_table_select(&rand_table, 1);
}

const RAND_METHOD *__cdecl ENGINE_get_RAND(const ENGINE *e)
{
  return (const RAND_METHOD *)*((_QWORD *)e + 8);
}

int ENGINE_set_RAND(ENGINE *e, const RAND_METHOD *rand_meth)
{
  *((_QWORD *)e + 8) = rand_meth;
  return 1;
}

void *EVP_sm4_cbc()
{
  return &sm4_cbc;
}

void *EVP_sm4_cfb128()
{
  return &sm4_cfb128;
}

void *EVP_sm4_ofb()
{
  return &sm4_ofb;
}

void *EVP_sm4_ecb()
{
  return &sm4_ecb;
}

void *EVP_sm4_ctr()
{
  return &sm4_ctr_mode;
}

uint64_t sm4_init_key(uint64_t a1, unsigned int *a2)
{
  SM4_set_key(a2, *(_QWORD *)(a1 + 120));
  return 1;
}

uint64_t sm4_cbc_cipher(uint64_t a1, uint64_t *a2, _QWORD *a3, unint64_t a4)
{
  uint64_t v4;
  unint64_t v8;
  BOOL v9;

  v4 = a4;
  if (!(a4 >> 62))
  {
    v8 = a4;
    if (!a4)
      return 1;
    goto LABEL_4;
  }
  do
  {
    sm4_cbc_encrypt(a3, a2, 0x4000000000000000uLL, *(_QWORD *)(a1 + 120), (_OWORD *)(a1 + 40), *(_DWORD *)(a1 + 16));
    v8 = v4 - 0x4000000000000000;
    a3 += 0x800000000000000;
    a2 += 0x800000000000000;
    v9 = v4 < 0x4000000000000000;
    v4 -= 0x4000000000000000;
  }
  while (v9);
  if (v8)
LABEL_4:
    sm4_cbc_encrypt(a3, a2, v8, *(_QWORD *)(a1 + 120), (_OWORD *)(a1 + 40), *(_DWORD *)(a1 + 16));
  return 1;
}

void sm4_cbc_encrypt(_QWORD *a1, uint64_t *a2, unint64_t a3, uint64_t a4, _OWORD *a5, int a6)
{
  if (a6)
    CRYPTO_cbc128_encrypt(a1, a2, a3, a4, a5, (void (*)(_QWORD *, _QWORD *, uint64_t))SM4_encrypt);
  else
    CRYPTO_cbc128_decrypt((uint64_t)a1, a2, a3, a4, a5, (uint64_t (*)(_QWORD *, uint64_t *, uint64_t))SM4_decrypt);
}

uint64_t sm4_cfb128_cipher(uint64_t a1, _BYTE *a2, uint64_t a3, unint64_t a4)
{
  unint64_t v4;
  unint64_t v8;
  uint64_t v9;
  unsigned int *v10;

  if (a4)
  {
    v4 = a4;
    if (a4 >= 0x4000000000000000)
      v8 = 0x4000000000000000;
    else
      v8 = a4;
    v9 = a1 + 40;
    v10 = (unsigned int *)(a1 + 88);
    do
    {
      CRYPTO_cfb128_encrypt(a3, a2, v8, *(_QWORD *)(a1 + 120), v9, v10, *(_DWORD *)(a1 + 16), (uint64_t (*)(uint64_t, uint64_t, uint64_t))SM4_encrypt);
      a3 += v8;
      a2 += v8;
      v4 -= v8;
      if (v4 < v8)
        v8 = v4;
    }
    while (v4);
  }
  return 1;
}

uint64_t sm4_ofb_cipher(uint64_t a1, _BYTE *a2, uint64_t a3, unint64_t a4)
{
  uint64_t v4;
  unint64_t v8;
  BOOL v9;

  v4 = a4;
  if (!(a4 >> 62))
  {
    v8 = a4;
    if (!a4)
      return 1;
    goto LABEL_4;
  }
  do
  {
    CRYPTO_ofb128_encrypt(a3, a2, 0x4000000000000000uLL, *(_QWORD *)(a1 + 120), a1 + 40, (unsigned int *)(a1 + 88), (uint64_t (*)(uint64_t, uint64_t, uint64_t))SM4_encrypt);
    v8 = v4 - 0x4000000000000000;
    a3 += 0x4000000000000000;
    a2 += 0x4000000000000000;
    v9 = v4 < 0x4000000000000000;
    v4 -= 0x4000000000000000;
  }
  while (v9);
  if (v8)
LABEL_4:
    CRYPTO_ofb128_encrypt(a3, a2, v8, *(_QWORD *)(a1 + 120), a1 + 40, (unsigned int *)(a1 + 88), (uint64_t (*)(uint64_t, uint64_t, uint64_t))SM4_encrypt);
  return 1;
}

uint64_t sm4_ecb_cipher(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  unint64_t v4;
  unint64_t v5;
  unint64_t v9;
  unsigned int *v10;
  _BYTE *v11;
  _DWORD *v12;

  v4 = *(int *)(*(_QWORD *)a1 + 4);
  v5 = a4 - v4;
  if (a4 >= v4)
  {
    v9 = 0;
    do
    {
      v10 = (unsigned int *)(a3 + v9);
      v11 = (_BYTE *)(a2 + v9);
      v12 = *(_DWORD **)(a1 + 120);
      if (*(_DWORD *)(a1 + 16))
        SM4_encrypt(v10, v11, v12);
      else
        SM4_decrypt(v10, v11, v12);
      v9 += v4;
    }
    while (v9 <= v5);
  }
  return 1;
}

uint64_t sm4_ctr_cipher(uint64_t a1, _BYTE *a2, uint64_t a3, unint64_t a4)
{
  CRYPTO_ctr128_encrypt(a3, a2, a4, *(_QWORD *)(a1 + 120), a1 + 40, a1 + 56, (unsigned int *)(a1 + 88), (uint64_t (*)(uint64_t, uint64_t, uint64_t))SM4_encrypt);
  return 1;
}

const char *idea_options()
{
  return "idea(int)";
}

unint64_t *idea_ecb_encrypt(unsigned int *a1, _DWORD *a2, unsigned int *a3)
{
  uint64_t v4;
  unint64_t *result;
  unsigned int v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v4 = bswap32(a1[1]);
  v7 = bswap32(*a1);
  v8 = v4;
  result = idea_encrypt(&v7, a3);
  v6 = bswap32(v8);
  *a2 = bswap32(v7);
  a2[1] = v6;
  return result;
}

uint64_t pkey_hkdf_init(uint64_t a1)
{
  void *v2;

  v2 = malloc_type_calloc(1uLL, 0x438uLL, 0x10700401EDF281CuLL);
  if (v2)
  {
    *(_QWORD *)(a1 + 40) = v2;
    return 1;
  }
  else
  {
    ERR_put_error(52, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/kdf/hkdf_evp.c", 80);
    return 0;
  }
}

void pkey_hkdf_cleanup(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 40);
  freezero(*(void **)(v1 + 16), *(_QWORD *)(v1 + 24));
  freezero(*(void **)(v1 + 32), *(_QWORD *)(v1 + 40));
  freezero((void *)v1, 0x438uLL);
}

uint64_t pkey_hkdf_derive_init(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 40);
  freezero(*(void **)(v1 + 32), *(_QWORD *)(v1 + 40));
  freezero(*(void **)(v1 + 16), *(_QWORD *)(v1 + 24));
  explicit_bzero((void *)v1, 0x438uLL);
  return 1;
}

uint64_t pkey_hkdf_derive(uint64_t a1, unsigned __int8 *a2, size_t *a3)
{
  int *v4;
  EVP_MD *v5;
  const void *v6;
  int v7;
  int v9;
  int v10;

  v4 = *(int **)(a1 + 40);
  v5 = (EVP_MD *)*((_QWORD *)v4 + 1);
  if (!v5)
  {
    v9 = 105;
    v10 = 227;
LABEL_9:
    ERR_put_error(52, 4095, v9, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/kdf/hkdf_evp.c", v10);
    return 0;
  }
  v6 = (const void *)*((_QWORD *)v4 + 4);
  if (!v6)
  {
    v9 = 104;
    v10 = 231;
    goto LABEL_9;
  }
  v7 = *v4;
  if (*v4 == 2)
    return HKDF_expand((uint64_t)a2, *a3, v5, v6, *((_QWORD *)v4 + 5), (const unsigned __int8 *)v4 + 48, *((_QWORD *)v4 + 134));
  if (v7 != 1)
  {
    if (!v7)
      return HKDF((uint64_t)a2, *a3, v5, (const unsigned __int8 *)v6, *((_QWORD *)v4 + 5), *((void **)v4 + 2), *((_QWORD *)v4 + 3), (const unsigned __int8 *)v4 + 48, *((_QWORD *)v4 + 134));
    return 0;
  }
  if (a2)
    return HKDF_extract(a2, a3, v5, (const unsigned __int8 *)v6, *((_QWORD *)v4 + 5), *((void **)v4 + 2), *((_QWORD *)v4 + 3));
  *a3 = EVP_MD_size(*((const EVP_MD **)v4 + 1));
  return 1;
}

uint64_t pkey_hkdf_ctrl(uint64_t a1, int a2, size_t __n, void *__src)
{
  unsigned int v5;
  uint64_t v6;
  uint64_t result;
  uint64_t v8;

  v5 = __n;
  v6 = *(_QWORD *)(a1 + 40);
  switch(a2)
  {
    case 4099:
      if (!__src)
        return 0;
      *(_QWORD *)(v6 + 8) = __src;
      return 1;
    case 4100:
      result = 1;
      if (!(_DWORD)__n || !__src)
        return result;
      if ((__n & 0x80000000) != 0)
        return 0;
      freezero(*(void **)(v6 + 16), *(_QWORD *)(v6 + 24));
      result = (uint64_t)malloc_type_malloc(v5, 0xE46B6C7uLL);
      *(_QWORD *)(v6 + 16) = result;
      if (!result)
        return result;
      memcpy((void *)result, __src, v5);
      *(_QWORD *)(v6 + 24) = v5;
      return 1;
    case 4101:
      if ((int)__n < 1)
        return 0;
      freezero(*(void **)(v6 + 32), *(_QWORD *)(v6 + 40));
      result = (uint64_t)malloc_type_malloc(v5, 0xB1C071E9uLL);
      *(_QWORD *)(v6 + 32) = result;
      if (!result)
        return result;
      memcpy((void *)result, __src, v5);
      *(_QWORD *)(v6 + 40) = v5;
      return 1;
    case 4102:
      result = 1;
      if (!(_DWORD)__n || !__src)
        return result;
      if ((__n & 0x80000000) != 0)
        return 0;
      v8 = *(_QWORD *)(v6 + 1072);
      if (1024 - (int)v8 < (int)__n)
        return 0;
      memcpy((void *)(v6 + v8 + 48), __src, __n);
      *(_QWORD *)(v6 + 1072) += v5;
      return 1;
    case 4103:
      *(_DWORD *)v6 = __n;
      return 1;
    default:
      return 4294967294;
  }
}

uint64_t pkey_hkdf_ctrl_str(uint64_t *a1, char *__s1, char *a3)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  if (strcmp(__s1, "mode"))
  {
    if (!strcmp(__s1, "md"))
      return EVP_PKEY_CTX_md(a1, 1024, 4099, a3);
    if (strcmp(__s1, "salt"))
    {
      if (!strcmp(__s1, "hexsalt"))
      {
        v9 = (uint64_t)a1;
        v10 = 4100;
      }
      else
      {
        if (!strcmp(__s1, "key"))
        {
          v7 = (uint64_t)a1;
          v8 = 4101;
          return EVP_PKEY_CTX_str2ctrl(v7, v8, a3);
        }
        if (strcmp(__s1, "hexkey"))
        {
          if (strcmp(__s1, "info"))
          {
            if (strcmp(__s1, "hexinfo"))
            {
              ERR_put_error(52, 4095, 103, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/kdf/hkdf_evp.c", 204);
              return 4294967294;
            }
            v9 = (uint64_t)a1;
            v10 = 4102;
            return EVP_PKEY_CTX_hex2ctrl(v9, v10, a3);
          }
          v7 = (uint64_t)a1;
          v8 = 4102;
          return EVP_PKEY_CTX_str2ctrl(v7, v8, a3);
        }
        v9 = (uint64_t)a1;
        v10 = 4101;
      }
      return EVP_PKEY_CTX_hex2ctrl(v9, v10, a3);
    }
    v7 = (uint64_t)a1;
    v8 = 4100;
    return EVP_PKEY_CTX_str2ctrl(v7, v8, a3);
  }
  if (!strcmp(a3, "EXTRACT_AND_EXPAND") || !strcmp(a3, "EXTRACT_ONLY") || !strcmp(a3, "EXPAND_ONLY"))
    return EVP_PKEY_CTX_ctrl(a1, -1, 1024);
  else
    return 0;
}

int CRYPTO_mem_ctrl(int mode)
{
  return 0;
}

int CRYPTO_is_mem_check_on(void)
{
  return 0;
}

uint64_t CRYPTO_dbg_get_options(void)
{
  return 0;
}

int CRYPTO_push_info_(const char *info, const char *file, int line)
{
  return 0;
}

int CRYPTO_pop_info(void)
{
  return 0;
}

int CRYPTO_remove_all_info(void)
{
  return 0;
}

BOOL ec_GFp_simple_set_compressed_coordinates(const EC_GROUP *a1, const EC_POINT *a2, const BIGNUM *a3, int a4, BN_CTX *a5)
{
  int v10;
  BIGNUM *v11;
  BIGNUM *v12;
  BIGNUM *v13;
  BIGNUM *v14;
  BIGNUM *v15;
  BIGNUM *v16;
  BIGNUM *v17;
  BIGNUM *v18;
  unsigned int (*v19)(const EC_GROUP *, BIGNUM *, char *, BN_CTX *);
  const BIGNUM *v20;
  unsigned int (*v21)(const EC_GROUP *, BIGNUM *, const BIGNUM *, BN_CTX *);
  BIGNUM *v22;
  const BIGNUM *v23;
  _BOOL8 v24;
  int v25;
  int v26;

  ERR_clear_error();
  v10 = a4 != 0;
  BN_CTX_start(a5);
  v11 = BN_CTX_get(a5);
  if (!v11)
    goto LABEL_37;
  v12 = v11;
  v13 = BN_CTX_get(a5);
  if (!v13)
    goto LABEL_37;
  v14 = v13;
  v15 = BN_CTX_get(a5);
  if (!v15)
    goto LABEL_37;
  v16 = v15;
  v17 = BN_CTX_get(a5);
  if (!v17)
    goto LABEL_37;
  v18 = v17;
  if (!BN_nnmod(v16, a3, (const BIGNUM *)((char *)a1 + 104), a5))
    goto LABEL_37;
  if (*(_QWORD *)(*(_QWORD *)a1 + 296))
  {
    if (!BN_mod_sqr(v14, a3, (const BIGNUM *)((char *)a1 + 104), a5)
      || !BN_mod_mul(v12, v14, a3, (const BIGNUM *)((char *)a1 + 104), a5))
    {
      goto LABEL_37;
    }
  }
  else if (!(*(unsigned int (**)(const EC_GROUP *, BIGNUM *, const BIGNUM *, BN_CTX *))(*(_QWORD *)a1 + 272))(a1, v14, a3, a5)|| !(*(unsigned int (**)(const EC_GROUP *, BIGNUM *, BIGNUM *, const BIGNUM *, BN_CTX *))(*(_QWORD *)a1 + 264))(a1, v12, v14, a3, a5))
  {
    goto LABEL_37;
  }
  if (*((_DWORD *)a1 + 50))
  {
    if (!BN_mod_lshift1_quick(v14, v16, (const BIGNUM *)((char *)a1 + 104))
      || !BN_mod_add_quick(v14, v14, v16, (const BIGNUM *)((char *)a1 + 104))
      || !BN_mod_sub_quick(v12, v12, v14, (const BIGNUM *)((char *)a1 + 104)))
    {
      goto LABEL_37;
    }
  }
  else
  {
    v19 = *(unsigned int (**)(const EC_GROUP *, BIGNUM *, char *, BN_CTX *))(*(_QWORD *)a1 + 296);
    if (v19)
    {
      if (!v19(a1, v14, (char *)a1 + 152, a5) || !BN_mod_mul(v14, v14, v16, (const BIGNUM *)((char *)a1 + 104), a5))
        goto LABEL_37;
    }
    else if (!(*(unsigned int (**)(const EC_GROUP *, BIGNUM *, uint64_t, BIGNUM *, BN_CTX *))(*(_QWORD *)a1 + 264))(a1, v14, (uint64_t)a1 + 152, v16, a5))
    {
      goto LABEL_37;
    }
    if (!BN_mod_add_quick(v12, v12, v14, (const BIGNUM *)((char *)a1 + 104)))
      goto LABEL_37;
  }
  v20 = (const BIGNUM *)((char *)a1 + 176);
  v21 = *(unsigned int (**)(const EC_GROUP *, BIGNUM *, const BIGNUM *, BN_CTX *))(*(_QWORD *)a1 + 296);
  if (v21)
  {
    if (v21(a1, v14, v20, a5))
    {
      v22 = v12;
      v23 = v12;
      v20 = v14;
      goto LABEL_27;
    }
LABEL_37:
    v24 = 0;
    goto LABEL_38;
  }
  v22 = v12;
  v23 = v12;
LABEL_27:
  if (!BN_mod_add_quick(v22, v23, v20, (const BIGNUM *)((char *)a1 + 104)))
    goto LABEL_37;
  if (!BN_mod_sqrt(v18, v12, (const BIGNUM *)((char *)a1 + 104), a5))
  {
    if ((ERR_peek_last_error() & 0xFF000FFF) == 0x300006F)
    {
      ERR_clear_error();
      v25 = 110;
      v26 = 153;
    }
    else
    {
      v25 = 3;
      v26 = 155;
    }
LABEL_36:
    ERR_put_error(16, 4095, v25, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ecp_oct.c", v26);
    goto LABEL_37;
  }
  if (BN_is_odd((uint64_t)v18) != v10)
  {
    if (BN_is_zero((uint64_t)v18))
    {
      v25 = 109;
      v26 = 160;
    }
    else
    {
      if (!BN_usub(v18, (const BIGNUM *)((char *)a1 + 104), v18))
        goto LABEL_37;
      if (BN_is_odd((uint64_t)v18) == v10)
        goto LABEL_30;
      v25 = 68;
      v26 = 166;
    }
    goto LABEL_36;
  }
LABEL_30:
  v24 = EC_POINT_set_affine_coordinates(a1, a2, (uint64_t)v16, (uint64_t)v18, a5) != 0;
LABEL_38:
  BN_CTX_end(a5);
  return v24;
}

uint64_t ec_GFp_simple_point2oct(uint64_t a1, const EC_POINT *a2, unsigned int a3, _BYTE *a4, unint64_t a5, BN_CTX *a6)
{
  unint64_t v12;
  int v13;
  int v14;
  uint64_t v15;
  int v16;
  int v17;
  int v18;
  int v19;
  BIGNUM *v20;
  const BIGNUM *v21;
  BIGNUM *v22;
  const BIGNUM *v23;
  char v24;
  int v25;
  int v26;
  signed int v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  int v31;
  int v32;
  unsigned int v33;
  int v34;

  if (a3 > 6 || ((1 << a3) & 0x54) == 0)
  {
    v18 = 104;
    v19 = 192;
    goto LABEL_19;
  }
  if (EC_POINT_is_at_infinity((const EC_GROUP *)a1, a2) < 1)
  {
    v13 = BN_num_bits((const BIGNUM *)(a1 + 104));
    v14 = v13 + 7;
    if (v13 < -7)
      v14 = v13 + 14;
    v15 = (uint64_t)v14 >> 3;
    if (a3 == 2)
      v12 = v15 + 1;
    else
      v12 = (2 * v15) | 1;
    BN_CTX_start(a6);
    if (!a4)
      goto LABEL_45;
    if (v12 <= a5)
    {
      v20 = BN_CTX_get(a6);
      if (!v20)
        goto LABEL_45;
      v21 = v20;
      v22 = BN_CTX_get(a6);
      if (!v22)
        goto LABEL_45;
      v23 = v22;
      if (!EC_POINT_get_affine_coordinates(a1, a2, (uint64_t)v21, (uint64_t)v22, a6))
        goto LABEL_45;
      v24 = a3;
      if ((a3 | 4) == 6)
      {
        if (BN_is_odd((uint64_t)v23))
          v24 = a3 + 1;
        else
          v24 = a3;
      }
      *a4 = v24;
      v25 = BN_num_bits(v21);
      v26 = v25 + 7;
      if (v25 < -7)
        v26 = v25 + 14;
      v27 = v15 - (v26 >> 3);
      if (v27 <= v15)
      {
        v28 = v15 + 1;
        if (v27)
        {
          v29 = v27;
          bzero(a4 + 1, v27);
          v30 = v29 + 1;
        }
        else
        {
          v30 = 1;
        }
        if (v30 + BN_bn2bin(v21, &a4[v30]) != v28)
        {
          v16 = 68;
          v17 = 248;
          goto LABEL_16;
        }
        if ((a3 | 2) == 6)
        {
          v31 = BN_num_bits(v23);
          v32 = v31 + 7;
          if (v31 < -7)
            v32 = v31 + 14;
          v33 = v15 - (v32 >> 3);
          if (v33 > v15)
          {
            v16 = 68;
            v17 = 254;
            goto LABEL_16;
          }
          if (v33)
          {
            v34 = -(v32 >> 3);
            bzero(&a4[v28], (int)v33);
            v28 += v15 + v34;
          }
          v28 += BN_bn2bin(v23, &a4[v28]);
        }
        if (v28 == v12)
          goto LABEL_45;
        v16 = 68;
        v17 = 265;
      }
      else
      {
        v16 = 68;
        v17 = 238;
      }
    }
    else
    {
      v16 = 100;
      v17 = 217;
    }
LABEL_16:
    ERR_put_error(16, 4095, v16, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ecp_oct.c", v17);
LABEL_45:
    BN_CTX_end(a6);
    return v12;
  }
  if (a4)
  {
    if (a5)
    {
      *a4 = 0;
      return 1;
    }
    v18 = 100;
    v19 = 200;
LABEL_19:
    ERR_put_error(16, 4095, v18, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ecp_oct.c", v19);
    return 0;
  }
  return 1;
}

uint64_t ec_GFp_simple_oct2point(EC_GROUP *a1, EC_POINT *a2, unsigned __int8 *a3, uint64_t a4, BN_CTX *a5)
{
  unsigned int v6;
  uint64_t v8;
  int v9;
  _BOOL4 v11;
  BOOL v12;
  int v17;
  int v18;
  uint64_t v19;
  uint64_t v20;
  BIGNUM *v21;
  BIGNUM *v22;
  BIGNUM *v23;
  BIGNUM *v24;
  const unsigned __int8 *v25;
  int v26;
  uint64_t v27;
  int v28;
  int v29;

  if (!a4)
  {
    v28 = 100;
    v29 = 287;
    goto LABEL_37;
  }
  v6 = *a3;
  if (v6 >= 4 && (v6 & 0xFC) != 4)
  {
    v28 = 102;
    v29 = 296;
LABEL_37:
    ERR_put_error(16, 4095, v28, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ecp_oct.c", v29);
    return 0;
  }
  v8 = v6 & 1;
  v9 = v6 & 0xFE;
  v11 = (v6 & 0xFE) == 0 || v9 == 4;
  if ((_DWORD)v8)
    v12 = !v11;
  else
    v12 = 1;
  if (!v12)
  {
    v28 = 102;
    v29 = 300;
    goto LABEL_37;
  }
  if (!v9)
  {
    if (a4 == 1)
      return EC_POINT_set_to_infinity(a1, a2);
    v28 = 102;
    v29 = 305;
    goto LABEL_37;
  }
  v17 = BN_num_bits((const BIGNUM *)((char *)a1 + 104));
  v18 = v17 + 7;
  if (v17 < -7)
    v18 = v17 + 14;
  v19 = (uint64_t)v18 >> 3;
  v20 = (2 * v19) | 1;
  if (v9 == 2)
    v20 = v19 + 1;
  if (v20 != a4)
  {
    v28 = 102;
    v29 = 314;
    goto LABEL_37;
  }
  BN_CTX_start(a5);
  v21 = BN_CTX_get(a5);
  if (!v21)
    goto LABEL_30;
  v22 = v21;
  v23 = BN_CTX_get(a5);
  if (!v23)
    goto LABEL_30;
  v24 = v23;
  v25 = a3 + 1;
  if (!BN_bin2bn(v25, v19, v22))
    goto LABEL_30;
  if (BN_ucmp(v22, (const BIGNUM *)((char *)a1 + 104)) < 0)
  {
    if (v9 == 2)
    {
      if (!EC_POINT_set_compressed_coordinates((uint64_t)a1, a2, (uint64_t)v22, v8, a5))
        goto LABEL_30;
    }
    else
    {
      if (!BN_bin2bn(&v25[v19], v19, v24))
        goto LABEL_30;
      if ((BN_ucmp(v24, (const BIGNUM *)((char *)a1 + 104)) & 0x80000000) == 0)
      {
        v26 = 342;
        goto LABEL_29;
      }
      if (v9 == 6 && (_DWORD)v8 != BN_is_odd((uint64_t)v24))
      {
        v26 = 347;
        goto LABEL_29;
      }
      if (!EC_POINT_set_affine_coordinates(a1, a2, (uint64_t)v22, (uint64_t)v24, a5))
        goto LABEL_30;
    }
    v27 = 1;
    goto LABEL_31;
  }
  v26 = 328;
LABEL_29:
  ERR_put_error(16, 4095, 102, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ecp_oct.c", v26);
LABEL_30:
  v27 = 0;
LABEL_31:
  BN_CTX_end(a5);
  return v27;
}

void *EVP_whirlpool()
{
  return &whirlpool_md;
}

uint64_t init_3(uint64_t a1)
{
  return WHIRLPOOL_Init(*(_QWORD *)(a1 + 24));
}

uint64_t update_3(uint64_t a1, unsigned __int8 *a2, unint64_t a3)
{
  return WHIRLPOOL_Update(*(_QWORD *)(a1 + 24), a2, a3);
}

uint64_t final_3(uint64_t a1, _OWORD *a2)
{
  return WHIRLPOOL_Final(a2, *(__int128 **)(a1 + 24));
}

DSO *DSO_new(void)
{
  return DSO_new_method(0);
}

DSO *__cdecl DSO_new_method(DSO_METHOD *method)
{
  DSO *v2;
  STACK *v3;
  DSO_METHOD *v4;
  int (__cdecl *init)(DSO *);

  if (!default_DSO_meth)
    default_DSO_meth = (uint64_t)DSO_METHOD_openssl();
  v2 = (DSO *)malloc_type_calloc(1uLL, 0x40uLL, 0x10B0040507EF262uLL);
  if (v2)
  {
    v3 = sk_new_null();
    v2->meth_data = v3;
    if (!v3)
    {
      ERR_put_error(37, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/dso/dso_lib.c", 120);
LABEL_12:
      free(v2);
      return 0;
    }
    v4 = (DSO_METHOD *)default_DSO_meth;
    if (method)
      v4 = method;
    v2->meth = v4;
    v2->references = 1;
    init = v4->init;
    if (init && !((unsigned int (*)(DSO *))init)(v2))
      goto LABEL_12;
  }
  else
  {
    ERR_put_error(37, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/dso/dso_lib.c", 114);
  }
  return v2;
}

void DSO_set_default_method(DSO_METHOD *meth)
{
  default_DSO_meth = (uint64_t)meth;
}

DSO_METHOD *DSO_get_default_method(void)
{
  return (DSO_METHOD *)default_DSO_meth;
}

DSO_METHOD *__cdecl DSO_get_method(DSO *dso)
{
  return dso->meth;
}

DSO_METHOD *__cdecl DSO_set_method(DSO *dso, DSO_METHOD *meth)
{
  DSO_METHOD *v2;

  v2 = dso->meth;
  dso->meth = meth;
  return v2;
}

int DSO_free(DSO *dso)
{
  DSO_METHOD *meth;
  int (__cdecl *dso_unload)(DSO *);
  int (__cdecl *finish)(DSO *);
  int v6;
  int v7;

  if (dso)
  {
    if (CRYPTO_add_lock(&dso->references, -1, 28, 0, 0) > 0)
      return 1;
    meth = dso->meth;
    dso_unload = dso->meth->dso_unload;
    if (dso_unload)
    {
      if (!((unsigned int (*)(DSO *))dso_unload)(dso))
      {
        v6 = 107;
        v7 = 151;
        goto LABEL_11;
      }
      meth = dso->meth;
    }
    finish = meth->finish;
    if (!finish || ((unsigned int (*)(DSO *))finish)(dso))
    {
      sk_free(dso->meth_data);
      free(dso->merger);
      free(dso->filename);
      free(dso);
      return 1;
    }
    v6 = 102;
    v7 = 156;
  }
  else
  {
    v6 = 67;
    v7 = 142;
  }
LABEL_11:
  ERR_put_error(37, 4095, v6, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/dso/dso_lib.c", v7);
  return 0;
}

int DSO_flags(DSO *dso)
{
  if (dso)
    LODWORD(dso) = dso->flags;
  return (int)dso;
}

int DSO_up_ref(DSO *dso)
{
  if (dso)
    return CRYPTO_add_lock(&dso->references, 1, 28, 0, 0) > 1;
  ERR_put_error(37, 4095, 67, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/dso/dso_lib.c", 180);
  return 0;
}

DSO *__cdecl DSO_load(DSO *dso, const char *filename, DSO_METHOD *meth, int flags)
{
  DSO *v6;
  DSO *v8;
  int v9;
  int v10;
  int (__cdecl *dso_load)(DSO *);

  v6 = dso;
  if (!dso)
  {
    v8 = DSO_new_method(meth);
    v6 = v8;
    if (!v8)
    {
      ERR_put_error(37, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/dso/dso_lib.c", 197);
      return v6;
    }
    v8->flags = flags;
  }
  if (v6->merger)
  {
    v9 = 110;
    v10 = 210;
  }
  else
  {
    if (!filename)
      goto LABEL_12;
    if (!DSO_set_filename(v6, filename))
    {
      v9 = 112;
      v10 = 217;
      goto LABEL_16;
    }
    if (v6->merger)
    {
      dso_load = v6->meth->dso_load;
      if (dso_load)
      {
        if (((unsigned int (*)(DSO *))dso_load)(v6))
          return v6;
        v9 = 103;
        v10 = 230;
      }
      else
      {
        v9 = 108;
        v10 = 226;
      }
    }
    else
    {
LABEL_12:
      v9 = 111;
      v10 = 222;
    }
  }
LABEL_16:
  ERR_put_error(37, 4095, v9, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/dso/dso_lib.c", v10);
  if (!dso)
    DSO_free(v6);
  return 0;
}

uint64_t DSO_ctrl(DSO *dso, int cmd, uint64_t larg, void *parg)
{
  uint64_t v4;
  int v5;
  int v6;
  uint64_t (*dso_ctrl)(void);

  if (!dso)
  {
    v5 = 67;
    v6 = 296;
LABEL_13:
    ERR_put_error(37, 4095, v5, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/dso/dso_lib.c", v6);
    return -1;
  }
  if (cmd == 3)
  {
    v4 = 0;
    dso->flags |= larg;
    return v4;
  }
  if (cmd == 2)
  {
    v4 = 0;
    dso->flags = larg;
    return v4;
  }
  if (cmd != 1)
  {
    if (dso->meth)
    {
      dso_ctrl = (uint64_t (*)(void))dso->meth->dso_ctrl;
      if (dso_ctrl)
        return dso_ctrl();
    }
    v5 = 108;
    v6 = 315;
    goto LABEL_13;
  }
  return dso->flags;
}

int DSO_set_filename(DSO *dso, const char *filename)
{
  int v3;
  int v4;
  char *v6;
  char *(__cdecl *v7)(DSO *, const char *, const char *);

  if (!dso || !filename)
  {
    v3 = 67;
    v4 = 351;
    goto LABEL_6;
  }
  if (dso->filename)
  {
    v3 = 110;
    v4 = 355;
LABEL_6:
    ERR_put_error(37, 4095, v3, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/dso/dso_lib.c", v4);
    return 0;
  }
  v6 = strdup(filename);
  if (!v6)
  {
    v3 = 65;
    v4 = 361;
    goto LABEL_6;
  }
  v7 = (char *(__cdecl *)(DSO *, const char *, const char *))v6;
  free(dso->merger);
  dso->merger = v7;
  return 1;
}

void *__cdecl DSO_bind_var(DSO *dso, const char *symname)
{
  uint64_t (*dso_bind_var)(void);
  void *result;
  int v4;
  int v5;

  if (dso && symname)
  {
    dso_bind_var = (uint64_t (*)(void))dso->meth->dso_bind_var;
    if (dso_bind_var)
    {
      result = (void *)dso_bind_var();
      if (result)
        return result;
      v4 = 106;
      v5 = 256;
    }
    else
    {
      v4 = 108;
      v5 = 252;
    }
  }
  else
  {
    v4 = 67;
    v5 = 248;
  }
  ERR_put_error(37, 4095, v4, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/dso/dso_lib.c", v5);
  return 0;
}

DSO_FUNC_TYPE DSO_bind_func(DSO *dso, const char *symname)
{
  uint64_t (*dso_bind_func)(void);
  DSO_FUNC_TYPE result;
  int v4;
  int v5;

  if (dso && symname)
  {
    dso_bind_func = (uint64_t (*)(void))dso->meth->dso_bind_func;
    if (dso_bind_func)
    {
      result = (DSO_FUNC_TYPE)dso_bind_func();
      if (result)
        return result;
      v4 = 106;
      v5 = 277;
    }
    else
    {
      v4 = 108;
      v5 = 273;
    }
  }
  else
  {
    v4 = 67;
    v5 = 269;
  }
  ERR_put_error(37, 4095, v4, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/dso/dso_lib.c", v5);
  return 0;
}

int DSO_set_name_converter(DSO *dso, DSO_NAME_CONVERTER_FUNC cb, DSO_NAME_CONVERTER_FUNC *oldcb)
{
  if (dso)
  {
    if (oldcb)
      *oldcb = *(DSO_NAME_CONVERTER_FUNC *)&dso->ex_data.dummy;
    *(_QWORD *)&dso->ex_data.dummy = cb;
    return 1;
  }
  else
  {
    ERR_put_error(37, 4095, 67, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/dso/dso_lib.c", 326);
    return 0;
  }
}

const char *__cdecl DSO_get_filename(DSO *dso)
{
  if (dso)
    return (const char *)dso->merger;
  ERR_put_error(37, 4095, 67, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/dso/dso_lib.c", 339);
  return 0;
}

char *__cdecl DSO_merge(DSO *dso, const char *filespec1, const char *filespec2)
{
  uint64_t (*name_converter)(void);

  if (dso && filespec1)
  {
    if ((dso->flags & 1) == 0)
    {
      name_converter = (uint64_t (*)(void))dso->name_converter;
      if (name_converter)
        return (char *)name_converter();
      name_converter = (uint64_t (*)(void))dso->meth->dso_merger;
      if (name_converter)
        return (char *)name_converter();
    }
  }
  else
  {
    ERR_put_error(37, 4095, 67, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/dso/dso_lib.c", 375);
  }
  return 0;
}

char *__cdecl DSO_convert_filename(DSO *dso, const char *filename)
{
  const char *merger;
  uint64_t (*dso_name_converter)(void);
  char *result;
  int v5;
  int v6;

  if (!dso)
  {
    v5 = 67;
    v6 = 394;
    goto LABEL_12;
  }
  merger = filename;
  if (!filename)
  {
    merger = (const char *)dso->merger;
    if (!merger)
    {
      v5 = 111;
      v6 = 400;
      goto LABEL_12;
    }
  }
  if ((dso->flags & 1) != 0
    || (dso_name_converter = *(uint64_t (**)(void))&dso->ex_data.dummy) == 0
    && (dso_name_converter = (uint64_t (*)(void))dso->meth->dso_name_converter) == 0
    || (result = (char *)dso_name_converter()) == 0)
  {
    result = strdup(merger);
    if (!result)
    {
      v5 = 65;
      v6 = 412;
LABEL_12:
      ERR_put_error(37, 4095, v5, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/dso/dso_lib.c", v6);
      return 0;
    }
  }
  return result;
}

const char *__cdecl DSO_get_loaded_filename(DSO *dso)
{
  if (dso)
    return dso->filename;
  ERR_put_error(37, 4095, 67, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/dso/dso_lib.c", 423);
  return 0;
}

uint64_t DSO_pathbyaddr(uint64_t a1, uint64_t a2, uint64_t a3)
{
  DSO_METHOD *v6;
  const char *name;

  v6 = (DSO_METHOD *)default_DSO_meth;
  if (!default_DSO_meth)
    v6 = DSO_METHOD_openssl();
  name = v6[1].name;
  if (name)
    return ((uint64_t (*)(uint64_t, uint64_t, uint64_t))name)(a1, a2, a3);
  ERR_put_error(37, 4095, 108, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/dso/dso_lib.c", 436);
  return 0xFFFFFFFFLL;
}

uint64_t DSO_global_lookup(uint64_t a1)
{
  DSO_METHOD *v2;
  int (__cdecl *dso_load)(DSO *);

  v2 = (DSO_METHOD *)default_DSO_meth;
  if (!default_DSO_meth)
    v2 = DSO_METHOD_openssl();
  dso_load = v2[1].dso_load;
  if (dso_load)
    return ((uint64_t (*)(uint64_t))dso_load)(a1);
  ERR_put_error(37, 4095, 108, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/dso/dso_lib.c", 449);
  return 0;
}

int ECPKParameters_print_fp(FILE *fp, const EC_GROUP *x, int off)
{
  BIO_METHOD *v6;
  BIO *v7;
  BIO *v8;
  int v9;

  v6 = BIO_s_file();
  v7 = BIO_new(v6);
  if (v7)
  {
    v8 = v7;
    BIO_ctrl(v7, 106, 0, fp);
    v9 = ECPKParameters_print(v8, x, off);
    BIO_free(v8);
    return v9;
  }
  else
  {
    ERR_put_error(16, 4095, 7, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/eck_prn.c", 79);
    return 0;
  }
}

int ECPKParameters_print(BIO *bp, const EC_GROUP *x, int off)
{
  BN_CTX *v6;
  int curve_name;
  int v8;
  const char *v9;
  BIGNUM *v10;
  int v11;
  BIGNUM *v12;
  int v13;
  BIGNUM *v14;
  const EC_POINT *v15;
  BIGNUM *v16;
  BIGNUM *v17;
  unsigned __int8 *v18;
  BIGNUM *v19;
  int v20;
  const EC_METHOD *v22;
  int field_type;
  point_conversion_form_t point_conversion_form;
  int v25;
  int v26;
  unsigned int v27;
  int v28;
  int v29;
  int v30;
  int v31;
  int v32;
  int v33;
  int v34;
  int v35;
  int v36;
  int v37;
  unsigned __int8 *v38;
  const char *v39;
  int basis_type;
  int v41;
  const char *v42;
  const char *v43;
  const char *v44;
  size_t seed_len;
  unsigned __int8 *v46;
  point_conversion_form_t v47;
  int n;
  BIGNUM *order;

  if (!x)
  {
    v12 = 0;
    v6 = 0;
    v10 = 0;
    v17 = 0;
    v16 = 0;
    v15 = 0;
    v14 = 0;
    v19 = 0;
    v20 = 67;
LABEL_18:
    v18 = (unsigned __int8 *)v12;
    ERR_put_error(16, 4095, v20, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/eck_prn.c", 324);
    v13 = 0;
    v12 = v19;
    goto LABEL_19;
  }
  v6 = BN_CTX_new();
  if (!v6)
  {
    v12 = 0;
    v10 = 0;
    goto LABEL_14;
  }
  if (!EC_GROUP_get_asn1_flag(x))
  {
    v22 = EC_GROUP_method_of(x);
    field_type = EC_METHOD_get_field_type(v22);
    v10 = BN_new();
    if (v10)
    {
      v17 = BN_new();
      if (v17)
      {
        v16 = BN_new();
        if (v16)
        {
          order = BN_new();
          if (order)
          {
            v19 = BN_new();
            if (!v19)
            {
              v12 = 0;
              v15 = 0;
LABEL_60:
              v20 = 65;
LABEL_64:
              v14 = order;
              goto LABEL_18;
            }
            if (EC_GROUP_get_curve((uint64_t)x, (uint64_t)v10, (uint64_t)v17, (uint64_t)v16, v6))
            {
              v15 = EC_GROUP_get0_generator(x);
              if (!v15)
              {
LABEL_62:
                v12 = 0;
                goto LABEL_63;
              }
              if (EC_GROUP_get_order(x, order, 0) && EC_GROUP_get_cofactor(x, v19, 0))
              {
                n = field_type;
                point_conversion_form = EC_GROUP_get_point_conversion_form(x);
                v15 = (const EC_POINT *)EC_POINT_point2bn(x, v15, point_conversion_form, 0, v6);
                if (v15)
                {
                  v47 = point_conversion_form;
                  v25 = BN_num_bits(v10);
                  v26 = v25 + 7;
                  if (v25 < -7)
                    v26 = v25 + 14;
                  v27 = v26 >> 3;
                  v28 = BN_num_bits(v17);
                  v29 = v28 + 7;
                  if (v28 < -7)
                    v29 = v28 + 14;
                  if (v27 <= v29 >> 3)
                    v27 = v29 >> 3;
                  v30 = BN_num_bits(v16);
                  v31 = v30 + 7;
                  if (v30 < -7)
                    v31 = v30 + 14;
                  if (v27 <= v31 >> 3)
                    v27 = v31 >> 3;
                  v32 = BN_num_bits((const BIGNUM *)v15);
                  v33 = v32 + 7;
                  if (v32 < -7)
                    v33 = v32 + 14;
                  if (v27 <= v33 >> 3)
                    v27 = v33 >> 3;
                  v34 = BN_num_bits(order);
                  v35 = v34 + 7;
                  if (v34 < -7)
                    v35 = v34 + 14;
                  if (v27 <= v35 >> 3)
                    v27 = v35 >> 3;
                  v36 = BN_num_bits(v19);
                  v37 = v36 + 7;
                  if (v36 < -7)
                    v37 = v36 + 14;
                  if (v27 <= v37 >> 3)
                    v27 = v37 >> 3;
                  v46 = EC_GROUP_get0_seed(x);
                  if (v46)
                    seed_len = EC_GROUP_get_seed_len(x);
                  else
                    seed_len = 0;
                  v38 = (unsigned __int8 *)malloc_type_malloc((int)(v27 + 10), 0xA629628CuLL);
                  if (v38)
                  {
                    v18 = v38;
                    if (BIO_indent(bp, off, 128))
                    {
                      v39 = OBJ_nid2sn(n);
                      if (BIO_printf(bp, "Field Type: %s\n", v39) >= 1)
                      {
                        if (n != 407)
                        {
                          v43 = "Prime:";
LABEL_76:
                          if (ASN1_bn_print(bp, v43, v10, v18, off)
                            && ASN1_bn_print(bp, "A:   ", v17, v18, off)
                            && ASN1_bn_print(bp, "B:   ", v16, v18, off))
                          {
                            if (v47 == POINT_CONVERSION_UNCOMPRESSED)
                              v44 = "Generator (uncompressed):";
                            else
                              v44 = v47 == POINT_CONVERSION_COMPRESSED
                                  ? "Generator (compressed):"
                                  : "Generator (hybrid):";
                            if (ASN1_bn_print(bp, v44, (const BIGNUM *)v15, v18, off)
                              && ASN1_bn_print(bp, "Order: ", order, v18, off)
                              && ASN1_bn_print(bp, "Cofactor: ", v19, v18, off)
                              && (!v46 || print_bin(bp, v46, seed_len, off)))
                            {
                              v13 = 1;
                              v12 = v19;
                              v14 = order;
                              goto LABEL_19;
                            }
                          }
                          goto LABEL_90;
                        }
                        basis_type = EC_GROUP_get_basis_type(x);
                        if (basis_type)
                        {
                          v41 = basis_type;
                          if (BIO_indent(bp, off, 128))
                          {
                            v42 = OBJ_nid2sn(v41);
                            if (BIO_printf(bp, "Basis Type: %s\n", v42) >= 1)
                            {
                              v43 = "Polynomial:";
                              goto LABEL_76;
                            }
                          }
                        }
                      }
                    }
LABEL_90:
                    v20 = 32;
                    v12 = (BIGNUM *)v18;
                    goto LABEL_64;
                  }
                  v12 = 0;
                  goto LABEL_60;
                }
                goto LABEL_62;
              }
            }
            v12 = 0;
            v15 = 0;
LABEL_63:
            v20 = 16;
            goto LABEL_64;
          }
        }
        v12 = 0;
        goto LABEL_16;
      }
      v12 = 0;
LABEL_15:
      v16 = 0;
LABEL_16:
      v15 = 0;
      v14 = 0;
      v19 = 0;
      v20 = 65;
      goto LABEL_18;
    }
    v12 = 0;
LABEL_14:
    v17 = 0;
    goto LABEL_15;
  }
  if (!BIO_indent(bp, off, 128))
    goto LABEL_17;
  curve_name = EC_GROUP_get_curve_name(x);
  if (!curve_name)
    goto LABEL_17;
  v8 = curve_name;
  v9 = OBJ_nid2sn(curve_name);
  if (BIO_printf(bp, "ASN1 OID: %s", v9) < 1 || BIO_printf(bp, "\n") < 1)
    goto LABEL_17;
  v10 = (BIGNUM *)EC_curve_nid2nist(v8);
  if (!v10)
  {
    v12 = 0;
    v14 = 0;
    v15 = 0;
    v16 = 0;
    v17 = 0;
    v18 = 0;
    v13 = 1;
    goto LABEL_19;
  }
  if (!BIO_indent(bp, off, 128))
  {
LABEL_17:
    v12 = 0;
    v10 = 0;
    v17 = 0;
    v16 = 0;
    v15 = 0;
    v14 = 0;
    v19 = 0;
    v20 = 32;
    goto LABEL_18;
  }
  v11 = BIO_printf(bp, "NIST CURVE: %s\n", (const char *)v10);
  v12 = 0;
  if (v11 < 1)
  {
    v20 = 32;
    v10 = 0;
    v17 = 0;
    v16 = 0;
    v15 = 0;
    v14 = 0;
    v19 = 0;
    goto LABEL_18;
  }
  v13 = 1;
  v14 = 0;
  v15 = 0;
  v16 = 0;
  v17 = 0;
  v10 = 0;
  v18 = 0;
LABEL_19:
  BN_free(v10);
  BN_free(v17);
  BN_free(v16);
  BN_free((BIGNUM *)v15);
  BN_free(v14);
  BN_free(v12);
  BN_CTX_free(v6);
  free(v18);
  return v13;
}

int EC_KEY_print_fp(FILE *fp, const EC_KEY *x, int off)
{
  BIO_METHOD *v6;
  BIO *v7;
  BIO *v8;
  int v9;

  v6 = BIO_s_file();
  v7 = BIO_new(v6);
  if (v7)
  {
    v8 = v7;
    BIO_ctrl(v7, 106, 0, fp);
    v9 = EC_KEY_print(v8, x, off);
    BIO_free(v8);
    return v9;
  }
  else
  {
    ERR_put_error(16, 4095, 32, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/eck_prn.c", 95);
    return 0;
  }
}

int EC_KEY_print(BIO *bp, const EC_KEY *x, int off)
{
  EVP_PKEY *v6;
  EVP_PKEY *v7;
  int v8;

  v6 = EVP_PKEY_new();
  v7 = v6;
  if (v6 && EVP_PKEY_set1_EC_KEY(v6, x))
    v8 = EVP_PKEY_print_private(bp, (uint64_t)v7, off);
  else
    v8 = 0;
  EVP_PKEY_free(v7);
  return v8;
}

int ECParameters_print_fp(FILE *fp, const EC_KEY *x)
{
  BIO_METHOD *v4;
  BIO *v5;
  BIO *v6;
  int v7;

  v4 = BIO_s_file();
  v5 = BIO_new(v4);
  if (v5)
  {
    v6 = v5;
    BIO_ctrl(v5, 106, 0, fp);
    v7 = ECParameters_print(v6, x);
    BIO_free(v6);
    return v7;
  }
  else
  {
    ERR_put_error(16, 4095, 32, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/eck_prn.c", 111);
    return 0;
  }
}

int ECParameters_print(BIO *bp, const EC_KEY *x)
{
  EVP_PKEY *v4;
  EVP_PKEY *v5;
  int v6;

  v4 = EVP_PKEY_new();
  v5 = v4;
  if (v4 && EVP_PKEY_set1_EC_KEY(v4, x))
    v6 = EVP_PKEY_print_params(bp, (uint64_t)v5, 4);
  else
    v6 = 0;
  EVP_PKEY_free(v5);
  return v6;
}

BOOL print_bin(BIO *a1, unsigned __int8 *a2, uint64_t a3, int a4)
{
  int v7;
  uint64_t v8;
  unint64_t v9;
  int v10;
  int v11;
  int v12;
  const char *v13;
  _BYTE data[128];
  uint64_t v16;

  v16 = *MEMORY[0x24BDAC8D0];
  if (a4)
  {
    if (a4 >= 128)
      v7 = 128;
    else
      v7 = a4;
    __memset_chk();
    if (BIO_write(a1, data, v7) < 1)
      return 0;
  }
  else
  {
    v7 = 0;
  }
  if (BIO_printf(a1, "%s", "Seed:") < 1)
    return 0;
  v8 = 0;
  v9 = 0;
  v10 = v7 + 5;
  while (a3)
  {
    if (v8 - v9 / 0xF + 16 * (v9 / 0xF) || (data[0] = 10, __memset_chk(), BIO_write(a1, data, v10) >= 1))
    {
      v12 = *a2++;
      v11 = v12;
      ++v9;
      v13 = --a3 ? ":" : "";
      --v8;
      if (BIO_printf(a1, "%02x%s", v11, v13) >= 1)
        continue;
    }
    return 0;
  }
  return BIO_write(a1, "\n", 1) > 0;
}

STACK *i2v_BASIC_CONSTRAINTS(uint64_t a1, uint64_t a2, STACK *a3)
{
  STACK *v4;
  STACK *result;
  STACK *extlist;

  extlist = a3;
  if (a3)
  {
    v4 = 0;
  }
  else
  {
    result = sk_new_null();
    v4 = result;
    extlist = result;
    if (!result)
      return result;
  }
  if (X509V3_add_value_BOOL("CA", *(_DWORD *)a2, &extlist)
    && X509V3_add_value_int("pathlen", *(ASN1_INTEGER **)(a2 + 8), &extlist))
  {
    return extlist;
  }
  sk_pop_free(v4, (void (__cdecl *)(void *))X509V3_conf_free);
  return 0;
}

ASN1_VALUE *v2i_BASIC_CONSTRAINTS(uint64_t a1, uint64_t a2, const STACK *a3)
{
  ASN1_VALUE *v4;
  int i;
  CONF_VALUE *v6;
  const char *name;

  v4 = ASN1_item_new(&BASIC_CONSTRAINTS_it);
  if (!v4)
  {
    ERR_put_error(34, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_bcons.c", 181);
    return v4;
  }
  if (sk_num(a3) >= 1)
  {
    for (i = 0; i < sk_num(a3); ++i)
    {
      v6 = (CONF_VALUE *)sk_value(a3, i);
      name = v6->name;
      if (!strcmp(name, "CA"))
      {
        if (!X509V3_get_value_BOOL(v6, (int *)v4))
          goto LABEL_13;
      }
      else
      {
        if (strcmp(name, "pathlen"))
        {
          ERR_put_error(34, 4095, 106, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_bcons.c", 193);
          ERR_asprintf_error_data("section:%s,name:%s,value:%s", v6->section, v6->name, v6->value);
LABEL_13:
          ASN1_item_free(v4, &BASIC_CONSTRAINTS_it);
          return 0;
        }
        if (!X509V3_get_value_int(v6, (ASN1_INTEGER **)v4 + 1))
          goto LABEL_13;
      }
    }
  }
  return v4;
}

BASIC_CONSTRAINTS *__cdecl d2i_BASIC_CONSTRAINTS(BASIC_CONSTRAINTS **a, const unsigned __int8 **in, uint64_t len)
{
  return (BASIC_CONSTRAINTS *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &BASIC_CONSTRAINTS_it);
}

int i2d_BASIC_CONSTRAINTS(BASIC_CONSTRAINTS *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &BASIC_CONSTRAINTS_it);
}

BASIC_CONSTRAINTS *BASIC_CONSTRAINTS_new(void)
{
  return (BASIC_CONSTRAINTS *)ASN1_item_new(&BASIC_CONSTRAINTS_it);
}

void BASIC_CONSTRAINTS_free(BASIC_CONSTRAINTS *a)
{
  ASN1_item_free((ASN1_VALUE *)a, &BASIC_CONSTRAINTS_it);
}

_QWORD *CRYPTO_ccm128_init(_QWORD *result, char a2, char a3, uint64_t a4, uint64_t a5)
{
  *result = 0;
  result[1] = 0;
  *(_BYTE *)result = (4 * a2 + 56) & 0x38 | (a3 - 1) & 7;
  result[4] = 0;
  result[5] = a5;
  result[6] = a4;
  return result;
}

uint64_t CRYPTO_ccm128_setiv(char *a1, const void *a2, size_t a3, uint64_t a4)
{
  char v5;
  size_t v6;

  v5 = *a1;
  v6 = 14 - (*a1 & 7);
  if (v6 > a3)
    return 0xFFFFFFFFLL;
  if ((*a1 & 7u) < 3)
  {
    *((_QWORD *)a1 + 1) = 0;
  }
  else
  {
    a1[8] = HIBYTE(a4);
    a1[9] = BYTE6(a4);
    a1[10] = BYTE5(a4);
    a1[11] = BYTE4(a4);
  }
  *((_DWORD *)a1 + 3) = bswap32(a4);
  *a1 = v5 & 0xBF;
  memcpy(a1 + 1, a2, v6);
  return 0;
}

uint64_t CRYPTO_ccm128_aad(uint64_t result, char *a2, unint64_t a3)
{
  unint64_t v3;
  uint64_t v5;
  _BYTE *v6;
  void (*v7)(uint64_t, uint64_t, _QWORD);
  unint64_t v8;
  uint64_t v9;
  char v10;
  uint64x2_t v11;
  int32x4_t v12;
  int16x8_t v13;
  char v14;
  unint64_t v15;
  BOOL v16;

  if (a3)
  {
    v3 = a3;
    v5 = result;
    *(_BYTE *)result |= 0x40u;
    v6 = (_BYTE *)(result + 16);
    v7 = *(void (**)(uint64_t, uint64_t, _QWORD))(result + 40);
    v7(result, result + 16, *(_QWORD *)(result + 48));
    ++*(_QWORD *)(v5 + 32);
    if (v3 >> 8 > 0xFE)
    {
      *(_BYTE *)(v5 + 16) = ~*(_BYTE *)(v5 + 16);
      v10 = *(_BYTE *)(v5 + 17);
      if (HIDWORD(v3))
      {
        *(_BYTE *)(v5 + 17) = ~v10;
        v11 = (uint64x2_t)vdupq_n_s64(v3);
        v12 = (int32x4_t)vshlq_u64(v11, (uint64x2_t)xmmword_22D6916C0);
        v13 = (int16x8_t)vuzp1q_s32((int32x4_t)vshlq_u64(v11, (uint64x2_t)xmmword_22D6916D0), v12);
        v12.i32[0] = *(_DWORD *)(v5 + 18);
        *(int8x8_t *)v13.i8 = veor_s8((int8x8_t)*(_OWORD *)&vmovl_u8(*(uint8x8_t *)v12.i8), (int8x8_t)vmovn_s32((int32x4_t)v13));
        *(_DWORD *)(v5 + 18) = vmovn_s16(v13).u32[0];
        *(_BYTE *)(v5 + 22) ^= BYTE3(v3);
        *(_BYTE *)(v5 + 23) ^= BYTE2(v3);
        *(_BYTE *)(v5 + 24) ^= BYTE1(v3);
        v8 = 10;
        v9 = 25;
      }
      else
      {
        *(_BYTE *)(v5 + 17) = v10 ^ 0xFE;
        *(_BYTE *)(v5 + 18) ^= BYTE3(v3);
        *(_BYTE *)(v5 + 19) ^= BYTE2(v3);
        *(_BYTE *)(v5 + 20) ^= BYTE1(v3);
        v8 = 6;
        v9 = 21;
      }
    }
    else
    {
      *v6 ^= BYTE1(v3);
      v8 = 2;
      v9 = 17;
    }
    *(_BYTE *)(v5 + v9) ^= v3;
    do
    {
      if (v3)
      {
        do
        {
          v14 = *a2++;
          v6[v8] ^= v14;
          v15 = v3 - 1;
          v16 = v3 != 1;
          if (v8 > 0xE)
            break;
          ++v8;
          --v3;
        }
        while (v3);
      }
      else
      {
        v15 = 0;
        v16 = 0;
      }
      result = ((uint64_t (*)(_BYTE *, _BYTE *, _QWORD))v7)(v6, v6, *(_QWORD *)(v5 + 48));
      v8 = 0;
      ++*(_QWORD *)(v5 + 32);
      v3 = v15;
    }
    while (v16);
  }
  return result;
}

int8x16_t CRYPTO_ccm128_encrypt(int8x16_t *a1, _QWORD *a2, uint64_t *a3, unint64_t a4)
{
  __int8 v8;
  uint64_t v9;
  void (*v10)(int8x16_t *, int8x16_t *, uint64_t);
  int8x16_t result;
  unint64_t v12;
  uint64_t v13;
  unsigned __int8 *v14;
  unint64_t v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  __int8 v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  int8x16_t v26;

  v8 = a1->i8[0];
  v10 = (void (*)(int8x16_t *, int8x16_t *, uint64_t))a1[2].i64[1];
  v9 = a1[3].i64[0];
  if ((a1->i8[0] & 0x40) == 0)
  {
    v10(a1, a1 + 1, a1[3].i64[0]);
    ++a1[2].i64[0];
  }
  a1->i8[0] = v8 & 7;
  v12 = v8 & 7 ^ 0xFLL;
  if ((v8 & 7) != 0)
  {
    v13 = 0;
    v14 = &a1->u8[v12];
    v15 = 14 - v12;
    if (v12 > 0xE)
      v15 = 0;
    v16 = v15 + 1;
    do
    {
      v17 = *v14;
      *v14++ = 0;
      v13 = (v13 | v17) << 8;
      --v16;
    }
    while (v16);
  }
  else
  {
    v13 = 0;
  }
  v18 = v13 | a1->u8[15];
  a1->i8[15] = 1;
  if (v18 == a4)
  {
    v19 = a1[2].i64[0] + (((a4 + 15) >> 3) | 1);
    a1[2].i64[0] = v19;
    if (v19 <= 0x2000000000000000)
    {
      v26 = 0uLL;
      if (a4 >= 0x10)
      {
        do
        {
          v20 = a1[1].i64[1];
          a1[1].i64[0] ^= *a2;
          a1[1].i64[1] = v20 ^ a2[1];
          v10(a1 + 1, a1 + 1, v9);
          v10(a1, &v26, v9);
          v21 = 15;
          do
          {
            v22 = a1->i8[v21] + 1;
            a1->i8[v21] = v22;
            if (v21 == 8)
              break;
            --v21;
          }
          while (!v22);
          v23 = v26.i64[1];
          *a3 = *a2 ^ v26.i64[0];
          a3[1] = a2[1] ^ v23;
          a2 += 2;
          a3 += 2;
          a4 -= 16;
        }
        while (a4 > 0xF);
      }
      if (a4)
      {
        v24 = 0;
        do
        {
          a1[1].i8[v24] ^= *((_BYTE *)a2 + v24);
          ++v24;
        }
        while (a4 > v24);
        v10(a1 + 1, a1 + 1, v9);
        v10(a1, &v26, v9);
        v25 = 0;
        do
        {
          *((_BYTE *)a3 + v25) = *((_BYTE *)a2 + v25) ^ v26.i8[v25];
          ++v25;
        }
        while (a4 > v25);
      }
      bzero(&a1->i8[v12], (16 - v12));
      v10(a1, &v26, v9);
      result = veorq_s8(a1[1], v26);
      a1[1] = result;
      a1->i8[0] = v8;
    }
  }
  return result;
}

uint64_t CRYPTO_ccm128_decrypt(int8x16_t *a1, _QWORD *a2, uint64_t *a3, unint64_t a4)
{
  __int8 v8;
  uint64_t v9;
  void (*v10)(int8x16_t *, int8x16_t *, uint64_t);
  unint64_t v11;
  uint64_t v12;
  unsigned __int8 *v13;
  unint64_t v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  __int8 v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  int8x16_t *v24;
  char v25;
  uint64_t result;
  int8x16_t v27;

  v8 = a1->i8[0];
  v10 = (void (*)(int8x16_t *, int8x16_t *, uint64_t))a1[2].i64[1];
  v9 = a1[3].i64[0];
  if ((a1->i8[0] & 0x40) == 0)
    v10(a1, a1 + 1, a1[3].i64[0]);
  a1->i8[0] = v8 & 7;
  v11 = v8 & 7 ^ 0xFLL;
  if ((v8 & 7) != 0)
  {
    v12 = 0;
    v13 = &a1->u8[v11];
    v14 = 14 - v11;
    if (v11 > 0xE)
      v14 = 0;
    v15 = v14 + 1;
    do
    {
      v16 = *v13;
      *v13++ = 0;
      v12 = (v12 | v16) << 8;
      --v15;
    }
    while (v15);
  }
  else
  {
    v12 = 0;
  }
  v17 = v12 | a1->u8[15];
  a1->i8[15] = 1;
  if (v17 != a4)
    return 0xFFFFFFFFLL;
  v27 = 0uLL;
  if (a4 >= 0x10)
  {
    do
    {
      v10(a1, &v27, v9);
      v18 = 15;
      do
      {
        v19 = a1->i8[v18] + 1;
        a1->i8[v18] = v19;
        if (v18 == 8)
          break;
        --v18;
      }
      while (!v19);
      v20 = v27.i64[1];
      v21 = *a2 ^ v27.i64[0];
      *a3 = v21;
      a1[1].i64[0] ^= v21;
      v22 = a2[1] ^ v20;
      a3[1] = v22;
      a1[1].i64[1] ^= v22;
      v10(a1 + 1, a1 + 1, v9);
      a2 += 2;
      a3 += 2;
      a4 -= 16;
    }
    while (a4 > 0xF);
  }
  if (a4)
  {
    v10(a1, &v27, v9);
    v23 = 0;
    v24 = a1 + 1;
    do
    {
      v25 = *((_BYTE *)a2 + v23) ^ v27.i8[v23];
      *((_BYTE *)a3 + v23) = v25;
      v24->i8[v23++] ^= v25;
    }
    while (a4 > v23);
    v10(v24, a1 + 1, v9);
  }
  bzero(&a1->i8[v11], (16 - v11));
  v10(a1, &v27, v9);
  result = 0;
  a1[1] = veorq_s8(a1[1], v27);
  a1->i8[0] = v8;
  return result;
}

int8x16_t CRYPTO_ccm128_encrypt_ccm64(int8x16_t *a1, char *a2, _BYTE *a3, unint64_t a4, void (*a5)(char *, _BYTE *, unint64_t, uint64_t, int8x16_t *, int8x16_t *))
{
  __int8 v10;
  uint64_t v11;
  void (*v12)(int8x16_t *, int8x16_t *, uint64_t);
  int8x16_t result;
  unint64_t v14;
  uint64_t v15;
  unsigned __int8 *v16;
  unint64_t v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  unint64_t v22;
  unint64_t v23;
  uint64_t v24;
  unint64_t v25;
  unint64_t v26;
  BOOL v27;
  uint64_t v28;
  int8x16_t *v29;
  __int8 v30;
  __int8 v31;
  char v32;
  int8x16_t v33;

  v10 = a1->i8[0];
  v12 = (void (*)(int8x16_t *, int8x16_t *, uint64_t))a1[2].i64[1];
  v11 = a1[3].i64[0];
  if ((a1->i8[0] & 0x40) == 0)
  {
    v12(a1, a1 + 1, a1[3].i64[0]);
    ++a1[2].i64[0];
  }
  a1->i8[0] = v10 & 7;
  v14 = v10 & 7 ^ 0xFLL;
  if ((v10 & 7) != 0)
  {
    v15 = 0;
    v16 = &a1->u8[v14];
    v17 = 14 - v14;
    if (v14 > 0xE)
      v17 = 0;
    v18 = v17 + 1;
    do
    {
      v19 = *v16;
      *v16++ = 0;
      v15 = (v15 | v19) << 8;
      --v18;
    }
    while (v18);
  }
  else
  {
    v15 = 0;
  }
  v20 = v15 | a1->u8[15];
  a1->i8[15] = 1;
  if (v20 == a4)
  {
    v21 = a1[2].i64[0] + (((a4 + 15) >> 3) | 1);
    a1[2].i64[0] = v21;
    if (v21 <= 0x2000000000000000)
    {
      v33 = 0uLL;
      if (a4 >= 0x10)
      {
        v22 = a4 >> 4;
        a5(a2, a3, a4 >> 4, v11, a1, a1 + 1);
        if ((a4 & 0xF) == 0)
        {
LABEL_26:
          bzero(&a1->i8[v14], (16 - v14));
          v12(a1, &v33, v11);
          result = veorq_s8(a1[1], v33);
          a1[1] = result;
          a1->i8[0] = v10;
          return result;
        }
        v23 = 0;
        a2 += a4 & 0xFFFFFFFFFFFFFFF0;
        a3 += a4 & 0xFFFFFFFFFFFFFFF0;
        v24 = 15;
        while (1)
        {
          v25 = v23 + v22 + a1->u8[v24];
          a1->i8[v24] = v25;
          if (v24 == 8)
            break;
          v26 = v22 >> 8;
          v23 = v25 >> 8;
          --v24;
          v27 = v22 > 0xFF;
          v22 >>= 8;
          if (!v27)
          {
            v22 = v26;
            if (v25 <= 0xFF)
              break;
          }
        }
        a4 &= 0xFu;
      }
      if (a4)
      {
        v28 = 0;
        do
        {
          a1[1].i8[v28] ^= a2[v28];
          ++v28;
        }
        while (a4 != v28);
        v12(a1 + 1, a1 + 1, v11);
        v29 = &v33;
        v12(a1, &v33, v11);
        do
        {
          v31 = v29->i8[0];
          v29 = (int8x16_t *)((char *)v29 + 1);
          v30 = v31;
          v32 = *a2++;
          *a3++ = v32 ^ v30;
          --a4;
        }
        while (a4);
      }
      goto LABEL_26;
    }
  }
  return result;
}

uint64_t CRYPTO_ccm128_decrypt_ccm64(int8x16_t *a1, char *a2, _BYTE *a3, unint64_t a4, void (*a5)(char *, _BYTE *, unint64_t, uint64_t, int8x16_t *, int8x16_t *))
{
  __int8 v10;
  uint64_t v11;
  void (*v12)(int8x16_t *, int8x16_t *, uint64_t);
  unint64_t v13;
  uint64_t v14;
  unsigned __int8 *v15;
  unint64_t v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  unint64_t v21;
  uint64_t v22;
  unint64_t v23;
  unint64_t v24;
  BOOL v25;
  int8x16_t *v26;
  int8x16_t *v27;
  __int8 v28;
  __int8 v29;
  char v30;
  char v31;
  uint64_t result;
  int8x16_t v33;

  v10 = a1->i8[0];
  v12 = (void (*)(int8x16_t *, int8x16_t *, uint64_t))a1[2].i64[1];
  v11 = a1[3].i64[0];
  if ((a1->i8[0] & 0x40) == 0)
    v12(a1, a1 + 1, a1[3].i64[0]);
  a1->i8[0] = v10 & 7;
  v13 = v10 & 7 ^ 0xFLL;
  if ((v10 & 7) != 0)
  {
    v14 = 0;
    v15 = &a1->u8[v13];
    v16 = 14 - v13;
    if (v13 > 0xE)
      v16 = 0;
    v17 = v16 + 1;
    do
    {
      v18 = *v15;
      *v15++ = 0;
      v14 = (v14 | v18) << 8;
      --v17;
    }
    while (v17);
  }
  else
  {
    v14 = 0;
  }
  v19 = v14 | a1->u8[15];
  a1->i8[15] = 1;
  if (v19 == a4)
  {
    v33 = 0uLL;
    if (a4 >= 0x10)
    {
      v20 = a4 >> 4;
      a5(a2, a3, a4 >> 4, v11, a1, a1 + 1);
      if ((a4 & 0xF) == 0)
      {
LABEL_22:
        bzero(&a1->i8[v13], (16 - v13));
        v12(a1, &v33, v11);
        result = 0;
        a1[1] = veorq_s8(a1[1], v33);
        a1->i8[0] = v10;
        return result;
      }
      v21 = 0;
      a2 += a4 & 0xFFFFFFFFFFFFFFF0;
      a3 += a4 & 0xFFFFFFFFFFFFFFF0;
      v22 = 15;
      while (1)
      {
        v23 = v21 + v20 + a1->u8[v22];
        a1->i8[v22] = v23;
        if (v22 == 8)
          break;
        v24 = v20 >> 8;
        v21 = v23 >> 8;
        --v22;
        v25 = v20 > 0xFF;
        v20 >>= 8;
        if (!v25)
        {
          v20 = v24;
          if (v23 <= 0xFF)
            break;
        }
      }
      a4 &= 0xFu;
    }
    if (a4)
    {
      v26 = &v33;
      v12(a1, &v33, v11);
      v27 = a1 + 1;
      do
      {
        v29 = v26->i8[0];
        v26 = (int8x16_t *)((char *)v26 + 1);
        v28 = v29;
        v30 = *a2++;
        v31 = v30 ^ v28;
        *a3++ = v31;
        v27->i8[0] ^= v31;
        v27 = (int8x16_t *)((char *)v27 + 1);
        --a4;
      }
      while (a4);
      v12(a1 + 1, a1 + 1, v11);
    }
    goto LABEL_22;
  }
  return 0xFFFFFFFFLL;
}

size_t CRYPTO_ccm128_tag(unsigned __int8 *a1, void *__dst, size_t a3)
{
  size_t v3;

  if ((((unint64_t)*a1 >> 2) & 0xE) + 2 != a3)
    return 0;
  v3 = a3;
  memcpy(__dst, a1 + 16, a3);
  return v3;
}

ASN1_ENUMERATED *ASN1_ENUMERATED_new(void)
{
  return (ASN1_ENUMERATED *)ASN1_item_new(&ASN1_ENUMERATED_it);
}

void ASN1_ENUMERATED_free(ASN1_ENUMERATED *a)
{
  ASN1_item_free((ASN1_VALUE *)a, &ASN1_ENUMERATED_it);
}

uint64_t ASN1_ENUMERATED_get_int64(uint64_t *a1, unsigned int *a2)
{
  uint64_t v3;
  _QWORD v6[3];

  *a1 = 0;
  if (a2)
  {
    v3 = *a2;
    if ((v3 & 0x80000000) == 0)
    {
      if ((a2[1] | 0x100) == 0x10A)
      {
        memset(v6, 0, sizeof(v6));
        CBS_init(v6, *((_QWORD *)a2 + 1), v3);
        return asn1_aint_get_int64(v6, a2[1] == 266, a1);
      }
      ERR_put_error(13, 4095, 225, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/a_enum.c", 116);
    }
  }
  return 0;
}

uint64_t ASN1_ENUMERATED_set_int64(int *a1, unint64_t a2)
{
  _QWORD *v4;

  v4 = a1 + 2;
  freezero(*((void **)a1 + 1), *a1);
  *(_QWORD *)a1 = 0;
  *v4 = 0;
  *((_QWORD *)a1 + 2) = 0;
  a1[1] = 10;
  if ((a2 & 0x8000000000000000) != 0)
  {
    a1[1] = 266;
    a2 = -(uint64_t)a2;
  }
  return asn1_aint_set_uint64(a2, v4, a1);
}

uint64_t ASN1_ENUMERATED_get(uint64_t a)
{
  uint64_t v1;

  if (a)
  {
    v1 = 0;
    if (ASN1_ENUMERATED_get_int64(&v1, (unsigned int *)a))
      return v1;
    else
      return -1;
  }
  return a;
}

ASN1_ENUMERATED *__cdecl BN_to_ASN1_ENUMERATED(BIGNUM *bn, ASN1_ENUMERATED *ai)
{
  ASN1_ENUMERATED *v4;
  int v5;
  int v6;
  int v7;
  unsigned __int8 *data;
  unsigned __int8 *v9;
  int v10;
  int v11;
  int v12;

  v4 = ai;
  if (ai || (v4 = (ASN1_ENUMERATED *)ASN1_item_new(&ASN1_ENUMERATED_it)) != 0)
  {
    if (BN_is_negative((uint64_t)bn))
      v5 = 266;
    else
      v5 = 10;
    v4->type = v5;
    v6 = BN_num_bits(bn);
    v7 = v6 / 8 + 5;
    if (!v6)
      v7 = 4;
    data = v4->data;
    if (v4->length >= v7)
      goto LABEL_11;
    v9 = (unsigned __int8 *)malloc_type_realloc(v4->data, v7, 0x20ECF1CEuLL);
    if (v9)
    {
      data = v9;
      v4->data = v9;
LABEL_11:
      v10 = BN_bn2bin(bn, data);
      v4->length = v10;
      if (!v10)
      {
        *v4->data = 0;
        v4->length = 1;
      }
      return v4;
    }
    v11 = 65;
    v12 = 189;
  }
  else
  {
    v11 = 58;
    v12 = 177;
  }
  ERR_put_error(13, 4095, v11, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/a_enum.c", v12);
  if (v4 != ai)
    ASN1_item_free((ASN1_VALUE *)v4, &ASN1_ENUMERATED_it);
  return 0;
}

BIGNUM *__cdecl ASN1_ENUMERATED_to_BN(ASN1_ENUMERATED *ai, BIGNUM *bn)
{
  BIGNUM *v3;
  BIGNUM *v4;

  v3 = BN_bin2bn(ai->data, ai->length, bn);
  v4 = v3;
  if (v3)
  {
    if (ai->type == 266)
      BN_set_negative(v3, 1);
  }
  else
  {
    ERR_put_error(13, 4095, 105, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/a_enum.c", 215);
  }
  return v4;
}

int i2a_ASN1_ENUMERATED(BIO *bp, ASN1_ENUMERATED *a)
{
  uint64_t v4;
  int v5;
  unsigned __int8 *v6;
  _BYTE data[2];

  if (!a)
    return 0;
  if (a->length)
  {
    if (a->length >= 1)
    {
      v4 = 0;
      v5 = 0;
      while (1)
      {
        if (v4 && !(v4 % 0x23))
        {
          if (BIO_write(bp, "\\\n", 2) != 2)
            return -1;
          v5 += 2;
        }
        v6 = a->data;
        data[0] = i2a_ASN1_ENUMERATED_h[(unint64_t)v6[v4] >> 4];
        data[1] = i2a_ASN1_ENUMERATED_h[v6[v4] & 0xF];
        if (BIO_write(bp, data, 2) != 2)
          break;
        v5 += 2;
        if (++v4 >= a->length)
          return v5;
      }
      return -1;
    }
    return 0;
  }
  v5 = 2;
  if (BIO_write(bp, "00", 2) != 2)
    return -1;
  return v5;
}

int a2i_ASN1_ENUMERATED(BIO *bp, ASN1_ENUMERATED *bs, char *buf, int size)
{
  int v6;
  unint64_t v7;
  uint64_t v8;
  char v9;
  unsigned __int8 *v10;
  uint64_t v11;
  int v12;
  unsigned int v13;
  unsigned int v14;
  int v15;
  unsigned int v16;
  char *v17;
  uint64_t v18;
  unsigned __int8 *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  char v24;
  char v25;
  int v26;
  char v27;
  int v28;
  int v29;
  int v31;
  int v32;
  ASN1_ENUMERATED *v33;

  bs->type = 10;
  v6 = BIO_gets(bp, buf, size);
  if (v6 >= 1)
  {
    v33 = bs;
    v7 = 0;
    v8 = 0;
    v9 = 0;
    v10 = 0;
    while (1)
    {
      v11 = (v6 - 1);
      v12 = v11;
      if (buf[v11] == 10)
      {
        buf[v11] = 0;
        if (v6 == 1)
          goto LABEL_47;
        v11 = (v6 - 2);
        v13 = v6 - 2;
      }
      else
      {
        v13 = v6 - 1;
        v12 = v6;
      }
      if (buf[v11] == 13)
      {
        buf[v11] = 0;
        if (!v13)
          goto LABEL_47;
        v11 = v13 - 1;
        v14 = v13 - 1;
      }
      else
      {
        v14 = v13;
        v13 = v12;
      }
      v15 = buf[v11];
      if (v15 == 92)
        v16 = v14;
      else
        v16 = v13;
      buf[v16] = 0;
      if (v16 < 2)
      {
LABEL_47:
        v19 = v10;
        goto LABEL_44;
      }
      if ((v9 & 1) != 0)
      {
        v17 = buf;
      }
      else
      {
        v17 = buf;
        if (*buf == 48)
        {
          if (buf[1] == 48)
            v16 -= 2;
          v17 = &buf[2 * (buf[1] == 48)];
        }
      }
      if ((v16 & 1) != 0)
        break;
      v18 = v16 >> 1;
      if (v8 + v18 <= v7)
      {
        v19 = v10;
      }
      else
      {
        v19 = (unsigned __int8 *)malloc_type_realloc(v10, v8 + v18, 0x9E905177uLL);
        v7 = v8 + v18;
        if (!v19)
        {
          v31 = 65;
          v32 = 308;
LABEL_49:
          ERR_put_error(13, 4095, v31, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/a_enum.c", v32);
          goto LABEL_46;
        }
      }
      if (v16 >= 2)
      {
        v20 = 0;
        v21 = 0;
        if (v18 <= 1)
          v22 = 1;
        else
          v22 = v18;
        while (2)
        {
          v23 = 0;
          v24 = 1;
          do
          {
            v25 = v24;
            v26 = v17[v23 | v21];
            v27 = v26 - 48;
            if ((v26 - 48) >= 0xA)
            {
              if ((v26 - 97) > 5)
              {
                if ((v26 - 65) > 5)
                {
                  v28 = 141;
                  v29 = 324;
                  goto LABEL_45;
                }
                v27 = v26 - 55;
              }
              else
              {
                v27 = v26 - 87;
              }
            }
            v24 = 0;
            v19[v8 + v20] = v27 | (16 * v19[v8 + v20]);
            v23 = 1;
          }
          while ((v25 & 1) != 0);
          ++v20;
          v21 += 2;
          if (v20 != v22)
            continue;
          break;
        }
      }
      if (v15 != 92)
      {
        v33->length = v8 + v18;
        v33->data = v19;
        return 1;
      }
      v6 = BIO_gets(bp, buf, size);
      v9 = 1;
      v8 += v18;
      v10 = v19;
      if (v6 < 1)
        goto LABEL_44;
    }
    v31 = 145;
    v32 = 301;
    goto LABEL_49;
  }
  v19 = 0;
LABEL_44:
  v28 = 150;
  v29 = 342;
LABEL_45:
  ERR_put_error(13, 4095, v28, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/a_enum.c", v29);
  v10 = v19;
LABEL_46:
  free(v10);
  return 0;
}

uint64_t c2i_ASN1_ENUMERATED_cbs(uint64_t result, _QWORD *a2)
{
  _QWORD *v3;
  ASN1_INTEGER *v4;
  ASN1_VALUE *v5;
  ASN1_VALUE *v6;

  v6 = 0;
  if (result)
  {
    v3 = (_QWORD *)result;
    v4 = *(ASN1_INTEGER **)result;
    if (v4)
    {
      ASN1_INTEGER_free(v4);
      *v3 = 0;
    }
    result = c2i_ASN1_INTEGER_cbs(&v6, a2);
    if ((_DWORD)result)
    {
      v5 = v6;
      *((_DWORD *)v6 + 1) = *((_DWORD *)v6 + 1) & 0x100 | 0xA;
      *v3 = v5;
      return 1;
    }
  }
  return result;
}

int i2d_ASN1_ENUMERATED(ASN1_ENUMERATED *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &ASN1_ENUMERATED_it);
}

ASN1_ENUMERATED *__cdecl d2i_ASN1_ENUMERATED(ASN1_ENUMERATED **a, const unsigned __int8 **in, uint64_t len)
{
  return (ASN1_ENUMERATED *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &ASN1_ENUMERATED_it);
}

const EVP_CIPHER *EVP_rc2_cbc(void)
{
  return (const EVP_CIPHER *)&rc2_cbc;
}

const EVP_CIPHER *EVP_rc2_cfb64(void)
{
  return (const EVP_CIPHER *)&rc2_cfb64;
}

const EVP_CIPHER *EVP_rc2_ofb(void)
{
  return (const EVP_CIPHER *)&rc2_ofb;
}

const EVP_CIPHER *EVP_rc2_ecb(void)
{
  return (const EVP_CIPHER *)&rc2_ecb;
}

const EVP_CIPHER *EVP_rc2_64_cbc(void)
{
  return (const EVP_CIPHER *)&r2_64_cbc_cipher;
}

const EVP_CIPHER *EVP_rc2_40_cbc(void)
{
  return (const EVP_CIPHER *)&r2_40_cbc_cipher;
}

uint64_t rc2_init_key(uint64_t a1, const unsigned __int8 *a2)
{
  RC2_KEY *v4;
  int v5;

  v4 = (RC2_KEY *)(*(_QWORD *)(a1 + 120) + 4);
  v5 = EVP_CIPHER_CTX_key_length((const EVP_CIPHER_CTX *)a1);
  RC2_set_key(v4, v5, a2, **(_DWORD **)(a1 + 120));
  return 1;
}

uint64_t rc2_cbc_cipher(uint64_t a1, unsigned __int8 *out, unsigned __int8 *in, unint64_t length)
{
  unint64_t i;

  for (i = length; i > 0x7FFFFFFFFFFFFEFFLL; out += 0x7FFFFFFFFFFFFF00)
  {
    RC2_cbc_encrypt(in, out, 0x7FFFFFFFFFFFFF00, (RC2_KEY *)(*(_QWORD *)(a1 + 120) + 4), (unsigned __int8 *)(a1 + 40), *(_DWORD *)(a1 + 16));
    i -= 0x7FFFFFFFFFFFFF00;
    in += 0x7FFFFFFFFFFFFF00;
  }
  if (i)
    RC2_cbc_encrypt(in, out, i, (RC2_KEY *)(*(_QWORD *)(a1 + 120) + 4), (unsigned __int8 *)(a1 + 40), *(_DWORD *)(a1 + 16));
  return 1;
}

uint64_t rc2_set_asn1_type_and_iv(EVP_CIPHER_CTX *a1, ASN1_TYPE *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int v8;
  int ptr;

  if (!a2)
    return 0;
  ptr = 0;
  if (EVP_CIPHER_CTX_ctrl(a1, 2, 0, &ptr) < 1)
  {
    v6 = 0;
  }
  else
  {
    v4 = 58;
    v5 = 120;
    if (ptr != 64)
      v5 = 0;
    if (ptr != 128)
      v4 = v5;
    if (ptr == 40)
      v6 = 160;
    else
      v6 = v4;
  }
  v8 = EVP_CIPHER_CTX_iv_length(a1);
  return ASN1_TYPE_set_int_octetstring(a2, v6, a1->oiv, v8);
}

uint64_t rc2_get_asn1_type_and_iv(EVP_CIPHER_CTX *a1, ASN1_TYPE *a2)
{
  uint64_t v4;
  int v5;
  int v6;
  uint64_t v7;
  unsigned int v8;
  uint64_t v10;
  unsigned __int8 data[16];
  uint64_t v12;

  v12 = *MEMORY[0x24BDAC8D0];
  v10 = 0;
  if (!a2)
    return 0;
  v4 = EVP_CIPHER_CTX_iv_length(a1);
  if (v4 >= 0x11)
  {
    v5 = 102;
    v6 = 347;
LABEL_4:
    ERR_put_error(6, 4095, v5, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/e_rc2.c", v6);
    return 0xFFFFFFFFLL;
  }
  v7 = v4;
  if (ASN1_TYPE_get_int_octetstring(a2, &v10, data, v4) != (_DWORD)v4)
    return 0xFFFFFFFFLL;
  switch((_DWORD)v10)
  {
    case 0x3A:
      v8 = 128;
      if ((_DWORD)v7)
        goto LABEL_15;
      break;
    case 0xA0:
      v8 = 40;
      if ((_DWORD)v7)
      {
LABEL_15:
        if (!EVP_CipherInit_ex(a1, 0, 0, 0, data, -1))
          return 0xFFFFFFFFLL;
      }
      break;
    case 0x78:
      v8 = 64;
      if (!(_DWORD)v7)
        break;
      goto LABEL_15;
    default:
      v5 = 108;
      v6 = 330;
      goto LABEL_4;
  }
  if (EVP_CIPHER_CTX_ctrl(a1, 3, v8, 0) < 1 || !EVP_CIPHER_CTX_set_key_length(a1, v8 >> 3))
    return 0xFFFFFFFFLL;
  return v7;
}

uint64_t rc2_ctrl(EVP_CIPHER_CTX *ctx, int a2, int a3, _DWORD *a4)
{
  switch(a2)
  {
    case 3:
      if (a3 >= 1)
      {
        *(_DWORD *)ctx->cipher_data = a3;
        return 1;
      }
      return 0;
    case 2:
      *a4 = *(_DWORD *)ctx->cipher_data;
      return 1;
    case 0:
      *(_DWORD *)ctx->cipher_data = 8 * EVP_CIPHER_CTX_key_length(ctx);
      return 1;
    default:
      return 0xFFFFFFFFLL;
  }
}

uint64_t rc2_cfb64_cipher(uint64_t a1, unsigned __int8 *out, unsigned __int8 *in, unint64_t a4)
{
  unint64_t v4;
  unint64_t v8;
  unsigned __int8 *v9;
  int *v10;

  if (a4)
  {
    v4 = a4;
    if (a4 >= 0x7FFFFFFFFFFFFF00)
      v8 = 0x7FFFFFFFFFFFFF00;
    else
      v8 = a4;
    v9 = (unsigned __int8 *)(a1 + 40);
    v10 = (int *)(a1 + 88);
    do
    {
      RC2_cfb64_encrypt(in, out, v8, (RC2_KEY *)(*(_QWORD *)(a1 + 120) + 4), v9, v10, *(_DWORD *)(a1 + 16));
      in += v8;
      out += v8;
      v4 -= v8;
      if (v4 < v8)
        v8 = v4;
    }
    while (v4);
  }
  return 1;
}

uint64_t rc2_ofb_cipher(uint64_t a1, unsigned __int8 *out, unsigned __int8 *in, unint64_t length)
{
  unint64_t i;

  for (i = length; i > 0x7FFFFFFFFFFFFEFFLL; out += 0x7FFFFFFFFFFFFF00)
  {
    RC2_ofb64_encrypt(in, out, 0x7FFFFFFFFFFFFF00, (RC2_KEY *)(*(_QWORD *)(a1 + 120) + 4), (unsigned __int8 *)(a1 + 40), (int *)(a1 + 88));
    i -= 0x7FFFFFFFFFFFFF00;
    in += 0x7FFFFFFFFFFFFF00;
  }
  if (i)
    RC2_ofb64_encrypt(in, out, i, (RC2_KEY *)(*(_QWORD *)(a1 + 120) + 4), (unsigned __int8 *)(a1 + 40), (int *)(a1 + 88));
  return 1;
}

uint64_t rc2_ecb_cipher(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  unint64_t v4;
  unint64_t v5;
  unint64_t v9;

  v4 = *(int *)(*(_QWORD *)a1 + 4);
  v5 = a4 - v4;
  if (a4 >= v4)
  {
    v9 = 0;
    do
    {
      RC2_ecb_encrypt((const unsigned __int8 *)(a3 + v9), (unsigned __int8 *)(a2 + v9), (RC2_KEY *)(*(_QWORD *)(a1 + 120) + 4), *(_DWORD *)(a1 + 16));
      v9 += v4;
    }
    while (v9 <= v5);
  }
  return 1;
}

void DES_ecb3_encrypt(const_DES_cblock *input, DES_cblock *output, DES_key_schedule *ks1, DES_key_schedule *ks2, DES_key_schedule *ks3, int enc)
{
  __int16 v7;
  int v8;
  _QWORD v9[2];

  v9[1] = *MEMORY[0x24BDAC8D0];
  v9[0] = *(_QWORD *)input;
  if (enc)
    DES_encrypt3((unsigned int *)v9, ks1, ks2, ks3);
  else
    DES_decrypt3((unsigned int *)v9, ks1, ks2, ks3);
  v7 = WORD1(v9[0]);
  v8 = HIDWORD(v9[0]);
  *(_WORD *)output = v9[0];
  *(_WORD *)&(*output)[2] = v7;
  *(_DWORD *)&(*output)[4] = v8;
}

void *EVP_chacha20()
{
  return &chacha20_cipher;
}

uint64_t chacha_init(EVP_CIPHER_CTX *ctx, _DWORD *a2, _DWORD *a3)
{
  void *cipher_data;
  int v7;

  if (a2)
  {
    cipher_data = ctx->cipher_data;
    v7 = EVP_CIPHER_CTX_key_length(ctx);
    ChaCha_set_key((uint64_t)cipher_data, a2, 8 * v7);
  }
  if (a3)
    ChaCha_set_iv((uint64_t)ctx->cipher_data, a3 + 2, a3);
  return 1;
}

uint64_t chacha_cipher(uint64_t a1, int *a2, char *a3, unint64_t a4)
{
  ChaCha(*(int **)(a1 + 120), a2, a3, a4);
  return 1;
}

ENGINE *ENGINE_get_first(void)
{
  ENGINE *v0;

  CRYPTO_lock(9, 30, 0, 0);
  v0 = (ENGINE *)engine_list_head;
  if (engine_list_head)
    ++*(_DWORD *)(engine_list_head + 180);
  CRYPTO_lock(10, 30, 0, 0);
  return v0;
}

ENGINE *ENGINE_get_last(void)
{
  ENGINE *v0;

  CRYPTO_lock(9, 30, 0, 0);
  v0 = (ENGINE *)engine_list_tail;
  if (engine_list_tail)
    ++*(_DWORD *)(engine_list_tail + 180);
  CRYPTO_lock(10, 30, 0, 0);
  return v0;
}

ENGINE *__cdecl ENGINE_get_next(ENGINE *e)
{
  uint64_t v2;

  if (e)
  {
    CRYPTO_lock(9, 30, 0, 0);
    v2 = *((_QWORD *)e + 26);
    if (v2)
      ++*(_DWORD *)(v2 + 180);
    CRYPTO_lock(10, 30, 0, 0);
    ENGINE_free(e);
  }
  else
  {
    ERR_put_error(38, 4095, 67, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/engine/eng_list.c", 220);
    return 0;
  }
  return (ENGINE *)v2;
}

ENGINE *__cdecl ENGINE_get_prev(ENGINE *e)
{
  uint64_t v2;

  if (e)
  {
    CRYPTO_lock(9, 30, 0, 0);
    v2 = *((_QWORD *)e + 25);
    if (v2)
      ++*(_DWORD *)(v2 + 180);
    CRYPTO_lock(10, 30, 0, 0);
    ENGINE_free(e);
  }
  else
  {
    ERR_put_error(38, 4095, 67, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/engine/eng_list.c", 242);
    return 0;
  }
  return (ENGINE *)v2;
}

int ENGINE_add(ENGINE *e)
{
  ENGINE *v1;
  uint64_t v2;
  const char *v3;
  int v4;
  BOOL v5;
  uint64_t v6;
  int v7;
  int v8;

  v1 = e;
  if (e)
  {
    if (!*(_QWORD *)e || !*((_QWORD *)e + 1))
      ERR_put_error(38, 4095, 108, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/engine/eng_list.c", 269);
    CRYPTO_lock(9, 30, 0, 0);
    v2 = engine_list_head;
    if (engine_list_head)
    {
      v3 = *(const char **)v1;
      do
      {
        v4 = strcmp(*(const char **)v2, v3);
        v2 = *(_QWORD *)(v2 + 208);
        if (v2)
          v5 = v4 == 0;
        else
          v5 = 1;
      }
      while (!v5);
      if (!v4)
      {
        v7 = 103;
        v8 = 117;
        goto LABEL_20;
      }
      v6 = engine_list_tail;
      if (!engine_list_tail || *(_QWORD *)(engine_list_tail + 208))
      {
        v7 = 110;
        v8 = 135;
LABEL_20:
        ERR_put_error(38, 4095, v7, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/engine/eng_list.c", v8);
        ERR_put_error(38, 4095, 110, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/engine/eng_list.c", 273);
        LODWORD(v1) = 0;
LABEL_24:
        CRYPTO_lock(10, 30, 0, 0);
        return (int)v1;
      }
      *(_QWORD *)(engine_list_tail + 208) = v1;
      *((_QWORD *)v1 + 25) = v6;
    }
    else
    {
      if (engine_list_tail)
      {
        v7 = 110;
        v8 = 123;
        goto LABEL_20;
      }
      engine_list_head = (uint64_t)v1;
      *((_QWORD *)v1 + 25) = 0;
      engine_cleanup_add_last((uint64_t)engine_list_cleanup);
    }
    ++*((_DWORD *)v1 + 45);
    engine_list_tail = (uint64_t)v1;
    *((_QWORD *)v1 + 26) = 0;
    LODWORD(v1) = 1;
    goto LABEL_24;
  }
  ERR_put_error(38, 4095, 67, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/engine/eng_list.c", 265);
  return (int)v1;
}

int ENGINE_remove(ENGINE *e)
{
  ENGINE *v1;
  uint64_t *v2;
  ENGINE *v3;
  BOOL v4;
  uint64_t v5;
  uint64_t v6;

  v1 = e;
  if (e)
  {
    CRYPTO_lock(9, 30, 0, 0);
    v2 = &engine_list_head;
    do
    {
      v3 = (ENGINE *)*v2;
      v2 = (uint64_t *)(*v2 + 208);
      if (v3)
        v4 = v3 == v1;
      else
        v4 = 1;
    }
    while (!v4);
    if (v3)
    {
      v5 = *((_QWORD *)v1 + 26);
      if (v5)
        *(_QWORD *)(v5 + 200) = *((_QWORD *)v1 + 25);
      v6 = *((_QWORD *)v1 + 25);
      if (v6)
        *(_QWORD *)(v6 + 208) = v5;
      if ((ENGINE *)engine_list_head == v1)
        engine_list_head = *((_QWORD *)v1 + 26);
      if ((ENGINE *)engine_list_tail == v1)
        engine_list_tail = v6;
      engine_free_util((CRYPTO_EX_DATA *)v1, 0);
      LODWORD(v1) = 1;
    }
    else
    {
      ERR_put_error(38, 4095, 105, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/engine/eng_list.c", 165);
      ERR_put_error(38, 4095, 110, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/engine/eng_list.c", 292);
      LODWORD(v1) = 0;
    }
    CRYPTO_lock(10, 30, 0, 0);
  }
  else
  {
    ERR_put_error(38, 4095, 67, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/engine/eng_list.c", 287);
  }
  return (int)v1;
}

ENGINE *__cdecl ENGINE_by_id(const char *id)
{
  uint64_t v2;
  ENGINE *v4;

  if (id)
  {
    CRYPTO_lock(9, 30, 0, 0);
    v2 = engine_list_head;
    if (engine_list_head)
    {
      while (strcmp(id, *(const char **)v2))
      {
        v2 = *(_QWORD *)(v2 + 208);
        if (!v2)
          goto LABEL_5;
      }
      if ((*(_BYTE *)(v2 + 176) & 4) == 0)
      {
        ++*(_DWORD *)(v2 + 180);
LABEL_13:
        CRYPTO_lock(10, 30, 0, 0);
        return (ENGINE *)v2;
      }
      v4 = ENGINE_new();
      if (v4)
      {
        *(_OWORD *)v4 = *(_OWORD *)v2;
        *((_OWORD *)v4 + 1) = *(_OWORD *)(v2 + 16);
        *((_OWORD *)v4 + 2) = *(_OWORD *)(v2 + 32);
        *((_OWORD *)v4 + 3) = *(_OWORD *)(v2 + 48);
        *((_OWORD *)v4 + 4) = *(_OWORD *)(v2 + 64);
        *((_OWORD *)v4 + 5) = *(_OWORD *)(v2 + 80);
        *((_QWORD *)v4 + 12) = *(_QWORD *)(v2 + 96);
        *((_OWORD *)v4 + 7) = *(_OWORD *)(v2 + 112);
        *((_OWORD *)v4 + 8) = *(_OWORD *)(v2 + 128);
        *((_OWORD *)v4 + 9) = *(_OWORD *)(v2 + 144);
        *((_QWORD *)v4 + 21) = *(_QWORD *)(v2 + 168);
        *((_DWORD *)v4 + 44) = *(_DWORD *)(v2 + 176);
        v2 = (uint64_t)v4;
        goto LABEL_13;
      }
    }
LABEL_5:
    CRYPTO_lock(10, 30, 0, 0);
    ERR_put_error(38, 4095, 116, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/engine/eng_list.c", 370);
    ERR_asprintf_error_data("id=%s", id);
  }
  else
  {
    ERR_put_error(38, 4095, 67, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/engine/eng_list.c", 343);
  }
  return 0;
}

int ENGINE_up_ref(ENGINE *e)
{
  if (e)
    return CRYPTO_add_lock((int *)e + 45, 1, 30, 0, 0) > 1;
  ERR_put_error(38, 4095, 67, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/engine/eng_list.c", 382);
  return 0;
}

uint64_t engine_list_cleanup()
{
  uint64_t result;

  do
  {
    result = engine_list_head;
    if (!engine_list_head)
      break;
    result = ENGINE_remove((ENGINE *)engine_list_head);
  }
  while ((_DWORD)result);
  return result;
}

X509_ATTRIBUTE *__cdecl d2i_X509_ATTRIBUTE(X509_ATTRIBUTE **a, const unsigned __int8 **in, uint64_t len)
{
  return (X509_ATTRIBUTE *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &X509_ATTRIBUTE_it);
}

int i2d_X509_ATTRIBUTE(X509_ATTRIBUTE *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &X509_ATTRIBUTE_it);
}

X509_ATTRIBUTE *X509_ATTRIBUTE_new(void)
{
  return (X509_ATTRIBUTE *)ASN1_item_new(&X509_ATTRIBUTE_it);
}

void X509_ATTRIBUTE_free(X509_ATTRIBUTE *a)
{
  ASN1_item_free((ASN1_VALUE *)a, &X509_ATTRIBUTE_it);
}

X509_ATTRIBUTE *__cdecl X509_ATTRIBUTE_dup(X509_ATTRIBUTE *xa)
{
  return (X509_ATTRIBUTE *)ASN1_item_dup(&X509_ATTRIBUTE_it, xa);
}

X509_ATTRIBUTE *__cdecl X509_ATTRIBUTE_create(int nid, int atrtype, void *value)
{
  ASN1_OBJECT *v5;
  ASN1_OBJECT *v6;
  ASN1_VALUE *v7;
  ASN1_VALUE *v8;
  char *v9;
  ASN1_TYPE *v10;

  v5 = OBJ_nid2obj(nid);
  if (!v5)
    return 0;
  v6 = v5;
  v7 = ASN1_item_new(&X509_ATTRIBUTE_it);
  v8 = v7;
  if (v7)
  {
    *(_QWORD *)v7 = v6;
    v9 = (char *)ASN1_TYPE_new();
    if (v9)
    {
      v10 = (ASN1_TYPE *)v9;
      if (sk_push(*((STACK **)v8 + 1), v9))
      {
        ASN1_TYPE_set(v10, atrtype, value);
        return (X509_ATTRIBUTE *)v8;
      }
      ASN1_item_free(v8, &X509_ATTRIBUTE_it);
      ASN1_TYPE_free(v10);
    }
    else
    {
      ASN1_item_free(v8, &X509_ATTRIBUTE_it);
    }
    return 0;
  }
  return (X509_ATTRIBUTE *)v8;
}

const char *RC4_options(void)
{
  return "rc4(ptr,int)";
}

void RC4_set_key(RC4_KEY *key, int len, const unsigned __int8 *data)
{
  uint64_t v3;
  unsigned __int8 *v4;
  int32x4_t v5;
  int32x4_t v6;
  unint64_t v7;
  unsigned __int8 v8;
  int v9;
  unsigned __int8 *v10;
  int v11;
  unsigned __int8 v12;
  int v13;
  int v14;
  unsigned __int8 v15;
  int v16;
  int v17;
  unsigned __int8 v18;
  int v19;
  int v20;
  unsigned __int8 v21;
  BOOL v22;

  v3 = 0;
  v4 = &key->data[6];
  *(_QWORD *)&key->x = 0;
  v5 = (int32x4_t)xmmword_22D6A6690;
  v6.i64[0] = 0x400000004;
  v6.i64[1] = 0x400000004;
  do
  {
    *(int32x4_t *)&v4[v3] = v5;
    v5 = vaddq_s32(v5, v6);
    v3 += 16;
  }
  while (v3 != 1024);
  v7 = 0;
  v8 = 0;
  v9 = 0;
  do
  {
    v10 = &key->x + 4 * v7;
    v11 = *((_DWORD *)v10 + 2);
    v12 = v11 + v8 + data[v9];
    if (v9 + 1 == len)
      v13 = 0;
    else
      v13 = v9 + 1;
    *((_DWORD *)v10 + 2) = *(_DWORD *)&v4[4 * v12];
    *(_DWORD *)&v4[4 * v12] = v11;
    v14 = *((_DWORD *)v10 + 3);
    v15 = v14 + v12 + data[v13];
    if (v13 + 1 == len)
      v16 = 0;
    else
      v16 = v13 + 1;
    *((_DWORD *)v10 + 3) = *(_DWORD *)&v4[4 * v15];
    *(_DWORD *)&v4[4 * v15] = v14;
    v17 = *((_DWORD *)v10 + 4);
    v18 = v17 + v15 + data[v16];
    if (v16 + 1 == len)
      v19 = 0;
    else
      v19 = v16 + 1;
    *((_DWORD *)v10 + 4) = *(_DWORD *)&v4[4 * v18];
    *(_DWORD *)&v4[4 * v18] = v17;
    v20 = *((_DWORD *)v10 + 5);
    v21 = data[v19] + v20 + v18;
    v8 = v21;
    if (v19 + 1 == len)
      v9 = 0;
    else
      v9 = v19 + 1;
    *((_DWORD *)v10 + 5) = *(_DWORD *)&v4[4 * v21];
    *(_DWORD *)&v4[4 * v21] = v20;
    v22 = v7 >= 0xFC;
    v7 += 4;
  }
  while (!v22);
}

int DES_random_key(DES_cblock *ret)
{
  do
  {
    arc4random_buf(ret, 8uLL);
    DES_set_odd_parity(ret);
  }
  while (DES_is_weak_key(ret));
  return 1;
}

uint64_t OPENSSL_init_crypto(char a1)
{
  uint64_t result;
  _opaque_pthread_t *v3;

  if (crypto_init_cleaned_up == 1)
  {
    ERR_put_error(15, 4095, 70, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/crypto_init.c", 54);
    return 0;
  }
  v3 = pthread_self();
  if (pthread_equal(v3, (pthread_t)crypto_init_thread))
    return 1;
  if (pthread_once(&crypto_init_once, OPENSSL_init_crypto_internal))
    return 0;
  if ((a1 & 1) == 0 || (result = OpenSSL_no_config(), (_DWORD)result))
  {
    if ((a1 & 2) == 0)
      return 1;
    result = OpenSSL_config(0);
    if ((_DWORD)result)
      return 1;
  }
  return result;
}

void OPENSSL_init_crypto_internal()
{
  crypto_init_thread = (uint64_t)pthread_self();
  OPENSSL_cpuid_setup();
  ERR_load_crypto_strings();
  OpenSSL_add_all_ciphers();
  OpenSSL_add_all_digests();
}

uint64_t OPENSSL_cleanup()
{
  uint64_t result;

  ERR_free_strings();
  CRYPTO_cleanup_all_ex_data();
  ENGINE_cleanup();
  EVP_cleanup();
  result = x509_issuer_cache_free();
  crypto_init_cleaned_up = 1;
  return result;
}

void DES_ofb64_encrypt(const unsigned __int8 *in, unsigned __int8 *out, uint64_t length, DES_key_schedule *schedule, DES_cblock *ivec, int *num)
{
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  unsigned int v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  uint64_t v20;
  int v23;
  char v24;
  unsigned int data;
  int v26;
  unsigned int v27;
  int v28;
  uint64_t v29;

  v29 = *MEMORY[0x24BDAC8D0];
  v7 = *num;
  v8 = (*ivec)[0];
  v9 = (*ivec)[1];
  v10 = (*ivec)[2];
  v11 = (*ivec)[3];
  v12 = v8 | (v9 << 8) | (v10 << 16) | (v11 << 24);
  v13 = (*ivec)[4];
  v14 = (*ivec)[5];
  v15 = (*ivec)[6];
  v16 = (*ivec)[7];
  v17 = v13 | (v14 << 8) | (v15 << 16) | (v16 << 24);
  data = v12;
  v26 = v17;
  LOBYTE(v27) = v8;
  BYTE1(v27) = v9;
  BYTE2(v27) = v10;
  HIBYTE(v27) = v11;
  LOBYTE(v28) = v13;
  BYTE1(v28) = v14;
  BYTE2(v28) = v15;
  HIBYTE(v28) = v16;
  if (length)
  {
    v20 = length;
    v23 = 0;
    do
    {
      if (!v7)
      {
        DES_encrypt1(&data, schedule, 1);
        v12 = data;
        v17 = v26;
        v27 = data;
        v28 = v26;
        ++v23;
      }
      v24 = *in++;
      *out++ = *((_BYTE *)&v27 + v7) ^ v24;
      v7 = (v7 + 1) & 7;
      --v20;
    }
    while (v20);
    if (v23)
    {
      *(_DWORD *)ivec = v12;
      *(_DWORD *)&(*ivec)[4] = v17;
    }
  }
  *num = v7;
}

unsigned int *idea_cbc_encrypt(unsigned int *result, _DWORD *a2, uint64_t a3, unsigned int *a4, uint64_t a5, int a6)
{
  unint64_t v8;
  unint64_t v10;
  unint64_t v11;
  _DWORD *v12;
  unint64_t v13;
  unsigned int *v14;
  uint64_t v15;
  unsigned int v16;
  unint64_t v17;
  char *v18;
  unint64_t v19;
  unsigned int v20;
  unsigned int v21;
  unsigned int v22;
  unsigned int v23;
  unsigned int v24;
  unsigned int v25;
  char v26;
  unint64_t v27;
  unint64_t v28;
  unint64_t v29;
  unint64_t v30;
  unint64_t v31;
  unint64_t v32;
  unint64_t v33;
  unsigned int v34;
  _BYTE *v35;
  int v36;
  int v37;
  unint64_t v38;
  unsigned int *v39;
  int v40;
  int v41;
  unint64_t v42;
  int v43;
  int v44;
  char *v45;
  unint64_t v46;
  unint64_t v47;
  uint64_t v48;

  v8 = a3;
  v48 = *MEMORY[0x24BDAC8D0];
  v10 = bswap32(*(_DWORD *)a5);
  v11 = bswap32(*(_DWORD *)(a5 + 4));
  if (a6)
  {
    if (a3 >= 8)
    {
      do
      {
        v12 = a2;
        v13 = v8;
        v8 -= 8;
        v14 = result + 2;
        v15 = bswap32(result[1]);
        v46 = bswap32(*result) ^ v10;
        v47 = v15 ^ v11;
        idea_encrypt(&v46, a4);
        v10 = v46;
        v11 = v47;
        a2 += 2;
        v16 = bswap32(v47);
        *v12 = bswap32(v46);
        v12[1] = v16;
        result = v14;
      }
      while (v13 > 0xF);
      result = v14;
    }
    if (v8)
    {
      v17 = 0;
      v18 = (char *)result + v8;
      v19 = 0;
      switch(v8)
      {
        case 1uLL:
          goto LABEL_13;
        case 2uLL:
          goto LABEL_12;
        case 3uLL:
          goto LABEL_11;
        case 4uLL:
          goto LABEL_10;
        case 5uLL:
          goto LABEL_9;
        case 6uLL:
          goto LABEL_8;
        case 7uLL:
          v20 = *--v18;
          v17 = (unint64_t)v20 << 8;
LABEL_8:
          v21 = *--v18;
          v17 |= (unint64_t)v21 << 16;
LABEL_9:
          v22 = *--v18;
          v17 |= (unint64_t)v22 << 24;
LABEL_10:
          v19 = v17;
          v23 = *--v18;
          v17 = v23;
LABEL_11:
          v24 = *--v18;
          v17 |= (unint64_t)v24 << 8;
LABEL_12:
          v25 = *--v18;
          v17 |= (unint64_t)v25 << 16;
LABEL_13:
          v17 |= (unint64_t)*(v18 - 1) << 24;
          break;
        default:
          v19 = 0;
          break;
      }
      v46 = v17 ^ v10;
      v47 = v19 ^ v11;
      result = (unsigned int *)idea_encrypt(&v46, a4);
      v26 = v46;
      LOBYTE(v27) = v47;
      v28 = v46 >> 24;
      v29 = v46 >> 16;
      v30 = v46 >> 8;
      v31 = v47 >> 24;
      v32 = v47 >> 16;
      v33 = v47 >> 8;
      v34 = bswap32(v47);
      *a2 = bswap32(v46);
      a2[1] = v34;
    }
    else
    {
      v28 = v10 >> 24;
      v31 = v11 >> 24;
      v32 = v11 >> 16;
      v33 = v11 >> 8;
      LOBYTE(v27) = v11;
      v29 = v10 >> 16;
      v26 = v10;
      v30 = v10 >> 8;
    }
    *(_BYTE *)a5 = v28;
    *(_BYTE *)(a5 + 1) = v29;
    *(_BYTE *)(a5 + 2) = v30;
    *(_BYTE *)(a5 + 3) = v26;
    *(_BYTE *)(a5 + 4) = v31;
    *(_BYTE *)(a5 + 5) = v32;
    *(_BYTE *)(a5 + 6) = v33;
  }
  else
  {
    if (a3 >= 8)
    {
      do
      {
        v35 = a2;
        v36 = v10;
        v37 = v11;
        v38 = v8;
        v8 -= 8;
        v10 = bswap32(*result);
        v39 = result + 2;
        v11 = bswap32(result[1]);
        v46 = v10;
        v47 = v11;
        idea_encrypt(&v46, a4);
        v40 = v46 ^ v36;
        v41 = v47 ^ v37;
        *v35 = (v46 ^ v36) >> 24;
        v35[1] = BYTE2(v40);
        v35[2] = BYTE1(v40);
        v35[3] = v40;
        v35[4] = HIBYTE(v41);
        v35[5] = BYTE2(v41);
        v35[6] = BYTE1(v41);
        a2 = v35 + 8;
        v35[7] = v41;
        result = v39;
      }
      while (v38 > 0xF);
      result = v39;
    }
    if (v8)
    {
      v42 = bswap32(*result);
      v46 = v42;
      v27 = bswap32(result[1]);
      v47 = v27;
      result = (unsigned int *)idea_encrypt(&v46, a4);
      v43 = v46 ^ v10;
      v44 = v47 ^ v11;
      v45 = (char *)a2 + v8;
      switch(v8)
      {
        case 1uLL:
          goto LABEL_26;
        case 2uLL:
          goto LABEL_25;
        case 3uLL:
          goto LABEL_24;
        case 4uLL:
          goto LABEL_23;
        case 5uLL:
          goto LABEL_22;
        case 6uLL:
          goto LABEL_21;
        case 7uLL:
          *--v45 = BYTE1(v44);
LABEL_21:
          *--v45 = BYTE2(v44);
LABEL_22:
          *--v45 = HIBYTE(v44);
LABEL_23:
          *--v45 = v43;
LABEL_24:
          *--v45 = BYTE1(v43);
LABEL_25:
          *--v45 = BYTE2(v43);
LABEL_26:
          *(v45 - 1) = HIBYTE(v43);
          break;
        default:
          break;
      }
    }
    else
    {
      LODWORD(v42) = v10;
      LODWORD(v27) = v11;
    }
    *(_BYTE *)a5 = BYTE3(v42);
    *(_BYTE *)(a5 + 1) = BYTE2(v42);
    *(_BYTE *)(a5 + 2) = BYTE1(v42);
    *(_BYTE *)(a5 + 3) = v42;
    *(_BYTE *)(a5 + 4) = BYTE3(v27);
    *(_BYTE *)(a5 + 5) = BYTE2(v27);
    *(_BYTE *)(a5 + 6) = BYTE1(v27);
  }
  *(_BYTE *)(a5 + 7) = v27;
  return result;
}

unint64_t *idea_encrypt(unint64_t *result, unsigned int *a2)
{
  unint64_t v2;
  unsigned int v3;
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unsigned int v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unsigned int v11;
  unsigned int v12;
  unint64_t v13;
  int v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  int v18;
  unint64_t v19;
  unint64_t v20;
  int v21;
  unsigned __int16 v22;
  int v23;
  int v24;
  unsigned int v25;
  unint64_t v26;
  unint64_t v27;
  int v28;
  unsigned int v29;
  int v30;
  unint64_t v31;
  unint64_t v32;
  unsigned int v33;
  unsigned int v34;
  unint64_t v35;
  int v36;
  unint64_t v37;
  unint64_t v38;
  unint64_t v39;
  int v40;
  unint64_t v41;
  unint64_t v42;
  int v43;
  unsigned __int16 v44;
  int v45;
  int v46;
  unsigned int v47;
  unint64_t v48;
  unsigned int v49;
  unsigned int v50;
  unsigned int v51;
  unint64_t v52;
  unint64_t v53;
  unsigned int v54;
  unsigned int v55;
  unint64_t v56;
  int v57;
  unint64_t v58;
  unint64_t v59;
  unint64_t v60;
  int v61;
  unint64_t v62;
  unint64_t v63;
  int v64;
  unsigned __int16 v65;
  int v66;
  int v67;
  unsigned int v68;
  unint64_t v69;
  unsigned int v70;
  unsigned int v71;
  unsigned int v72;
  unint64_t v73;
  unint64_t v74;
  unsigned int v75;
  unsigned int v76;
  unint64_t v77;
  int v78;
  unint64_t v79;
  unint64_t v80;
  unint64_t v81;
  int v82;
  unint64_t v83;
  unint64_t v84;
  int v85;
  unsigned __int16 v86;
  int v87;
  int v88;
  unsigned int v89;
  unint64_t v90;
  unsigned int v91;
  unsigned int v92;
  unsigned int v93;
  unint64_t v94;
  unint64_t v95;
  unsigned int v96;
  unsigned int v97;
  unint64_t v98;
  int v99;
  unint64_t v100;
  unint64_t v101;
  unint64_t v102;
  int v103;
  unint64_t v104;
  unint64_t v105;
  int v106;
  unsigned __int16 v107;
  int v108;
  int v109;
  unsigned int v110;
  unint64_t v111;
  unsigned int v112;
  unsigned int v113;
  unsigned int v114;
  unint64_t v115;
  unint64_t v116;
  unsigned int v117;
  unsigned int v118;
  unint64_t v119;
  int v120;
  unint64_t v121;
  unint64_t v122;
  unint64_t v123;
  int v124;
  unint64_t v125;
  unint64_t v126;
  int v127;
  unsigned __int16 v128;
  int v129;
  int v130;
  unsigned int v131;
  unint64_t v132;
  unsigned int v133;
  unsigned int v134;
  unsigned int v135;
  unint64_t v136;
  unint64_t v137;
  unsigned int v138;
  unsigned int v139;
  unint64_t v140;
  int v141;
  unint64_t v142;
  unint64_t v143;
  unint64_t v144;
  int v145;
  unint64_t v146;
  unint64_t v147;
  int v148;
  unsigned __int16 v149;
  int v150;
  int v151;
  unsigned int v152;
  unsigned int v153;
  unint64_t v154;
  __int16 v155;
  unint64_t v156;
  unsigned int v157;
  unsigned int v158;
  unsigned int v159;
  unint64_t v160;
  unint64_t v161;
  unsigned int v162;
  unsigned int v163;
  unint64_t v164;
  __int16 v165;
  unint64_t v166;
  unint64_t v167;
  unint64_t v168;
  int v169;
  unint64_t v170;
  unint64_t v171;
  __int16 v172;
  unsigned __int16 v173;
  unsigned int v174;
  unsigned int v175;
  unsigned int v176;
  unint64_t v177;
  unsigned int v178;
  unsigned int v179;
  unint64_t v180;
  unsigned __int16 v181;
  unint64_t v182;

  v2 = WORD1(*result) * (unint64_t)*a2;
  v3 = 1 - *a2 - WORD1(*result);
  v4 = (unsigned __int16)(WORD1(*result) * *a2) - (v2 >> 16);
  v5 = v4 - (v4 >> 16);
  if (v2)
    LOWORD(v3) = v5;
  v6 = *result + a2[1];
  v7 = a2[3];
  v8 = (result[1] >> 16) + a2[2];
  v9 = (unsigned __int16)result[1] * (unint64_t)v7;
  LOWORD(v10) = 1 - v7 - result[1];
  if (v9)
    v10 = (unsigned __int16)v9 - (v9 >> 16) - (((unsigned __int16)v9 - (v9 >> 16)) >> 16);
  v11 = a2[4];
  v12 = a2[5];
  v13 = (unsigned __int16)(v8 ^ v3) * (unint64_t)v11;
  v14 = 1 - v11 - (unsigned __int16)(v8 ^ v3);
  v15 = (unsigned __int16)((v8 ^ v3) * v11) - (v13 >> 16);
  v16 = v15 - (v15 >> 16);
  if (v13)
    v14 = v16;
  v17 = (unsigned __int16)(v14 + (v10 ^ v6)) * (unint64_t)v12;
  v18 = 1 - v12 - (unsigned __int16)(v14 + (v10 ^ v6));
  v19 = (unsigned __int16)((v14 + (v10 ^ v6)) * v12) - (v17 >> 16);
  v20 = v19 - (v19 >> 16);
  if (v17)
    v18 = v20;
  v21 = v18 + v14;
  v22 = v21 ^ v10;
  v23 = v21 ^ v6;
  v24 = v18 ^ v8;
  LODWORD(v27) = (unsigned __int16)(v18 ^ v3);
  v25 = a2[6];
  v26 = v27 * (unint64_t)v25;
  LOWORD(v27) = 1 - v25 - v27;
  if (v26)
    v27 = (unsigned __int16)v26 - (v26 >> 16) - (((unsigned __int16)v26 - (v26 >> 16)) >> 16);
  v28 = v24 + a2[7];
  v29 = a2[9];
  v30 = v23 + a2[8];
  v31 = v22 * (unint64_t)v29;
  LOWORD(v32) = 1 - v29 - v22;
  if (v31)
    v32 = (unsigned __int16)v31 - (v31 >> 16) - (((unsigned __int16)v31 - (v31 >> 16)) >> 16);
  v33 = a2[10];
  v34 = a2[11];
  v35 = (unsigned __int16)(v30 ^ v27) * (unint64_t)v33;
  v36 = 1 - v33 - (unsigned __int16)(v30 ^ v27);
  v37 = (unsigned __int16)((v30 ^ v27) * v33) - (v35 >> 16);
  v38 = v37 - (v37 >> 16);
  if (v35)
    v36 = v38;
  v39 = (unsigned __int16)(v36 + (v32 ^ v28)) * (unint64_t)v34;
  v40 = 1 - v34 - (unsigned __int16)(v36 + (v32 ^ v28));
  v41 = (unsigned __int16)((v36 + (v32 ^ v28)) * v34) - (v39 >> 16);
  v42 = v41 - (v41 >> 16);
  if (v39)
    v40 = v42;
  v43 = v40 + v36;
  v44 = v43 ^ v32;
  v45 = v43 ^ v28;
  v46 = v40 ^ v30;
  LODWORD(v27) = (unsigned __int16)(v40 ^ v27);
  v47 = a2[12];
  v48 = v27 * (unint64_t)v47;
  LOWORD(v27) = 1 - v47 - v27;
  if (v48)
    v27 = (unsigned __int16)v48 - (v48 >> 16) - (((unsigned __int16)v48 - (v48 >> 16)) >> 16);
  v49 = v46 + a2[13];
  v50 = a2[15];
  v51 = v45 + a2[14];
  v52 = v44 * (unint64_t)v50;
  LOWORD(v53) = 1 - v50 - v44;
  if (v52)
    v53 = (unsigned __int16)v52 - (v52 >> 16) - (((unsigned __int16)v52 - (v52 >> 16)) >> 16);
  v54 = a2[16];
  v55 = a2[17];
  v56 = (unsigned __int16)(v51 ^ v27) * (unint64_t)v54;
  v57 = 1 - v54 - (unsigned __int16)(v51 ^ v27);
  v58 = (unsigned __int16)((v51 ^ v27) * v54) - (v56 >> 16);
  v59 = v58 - (v58 >> 16);
  if (v56)
    v57 = v59;
  v60 = (unsigned __int16)(v57 + (v53 ^ v49)) * (unint64_t)v55;
  v61 = 1 - v55 - (unsigned __int16)(v57 + (v53 ^ v49));
  v62 = (unsigned __int16)((v57 + (v53 ^ v49)) * v55) - (v60 >> 16);
  v63 = v62 - (v62 >> 16);
  if (v60)
    v61 = v63;
  v64 = v61 + v57;
  v65 = v64 ^ v53;
  v66 = v64 ^ v49;
  v67 = v61 ^ v51;
  LODWORD(v27) = (unsigned __int16)(v61 ^ v27);
  v68 = a2[18];
  v69 = v27 * (unint64_t)v68;
  LOWORD(v27) = 1 - v68 - v27;
  if (v69)
    v27 = (unsigned __int16)v69 - (v69 >> 16) - (((unsigned __int16)v69 - (v69 >> 16)) >> 16);
  v70 = v67 + a2[19];
  v71 = a2[21];
  v72 = v66 + a2[20];
  v73 = v65 * (unint64_t)v71;
  LOWORD(v74) = 1 - v71 - v65;
  if (v73)
    v74 = (unsigned __int16)v73 - (v73 >> 16) - (((unsigned __int16)v73 - (v73 >> 16)) >> 16);
  v75 = a2[22];
  v76 = a2[23];
  v77 = (unsigned __int16)(v72 ^ v27) * (unint64_t)v75;
  v78 = 1 - v75 - (unsigned __int16)(v72 ^ v27);
  v79 = (unsigned __int16)((v72 ^ v27) * v75) - (v77 >> 16);
  v80 = v79 - (v79 >> 16);
  if (v77)
    v78 = v80;
  v81 = (unsigned __int16)(v78 + (v74 ^ v70)) * (unint64_t)v76;
  v82 = 1 - v76 - (unsigned __int16)(v78 + (v74 ^ v70));
  v83 = (unsigned __int16)((v78 + (v74 ^ v70)) * v76) - (v81 >> 16);
  v84 = v83 - (v83 >> 16);
  if (v81)
    v82 = v84;
  v85 = v82 + v78;
  v86 = v85 ^ v74;
  v87 = v85 ^ v70;
  v88 = v82 ^ v72;
  LODWORD(v27) = (unsigned __int16)(v82 ^ v27);
  v89 = a2[24];
  v90 = v27 * (unint64_t)v89;
  LOWORD(v27) = 1 - v89 - v27;
  if (v90)
    v27 = (unsigned __int16)v90 - (v90 >> 16) - (((unsigned __int16)v90 - (v90 >> 16)) >> 16);
  v91 = v88 + a2[25];
  v92 = a2[27];
  v93 = v87 + a2[26];
  v94 = v86 * (unint64_t)v92;
  LOWORD(v95) = 1 - v92 - v86;
  if (v94)
    v95 = (unsigned __int16)v94 - (v94 >> 16) - (((unsigned __int16)v94 - (v94 >> 16)) >> 16);
  v96 = a2[28];
  v97 = a2[29];
  v98 = (unsigned __int16)(v93 ^ v27) * (unint64_t)v96;
  v99 = 1 - v96 - (unsigned __int16)(v93 ^ v27);
  v100 = (unsigned __int16)((v93 ^ v27) * v96) - (v98 >> 16);
  v101 = v100 - (v100 >> 16);
  if (v98)
    v99 = v101;
  v102 = (unsigned __int16)(v99 + (v95 ^ v91)) * (unint64_t)v97;
  v103 = 1 - v97 - (unsigned __int16)(v99 + (v95 ^ v91));
  v104 = (unsigned __int16)((v99 + (v95 ^ v91)) * v97) - (v102 >> 16);
  v105 = v104 - (v104 >> 16);
  if (v102)
    v103 = v105;
  v106 = v103 + v99;
  v107 = v106 ^ v95;
  v108 = v106 ^ v91;
  v109 = v103 ^ v93;
  LODWORD(v27) = (unsigned __int16)(v103 ^ v27);
  v110 = a2[30];
  v111 = v27 * (unint64_t)v110;
  LOWORD(v27) = 1 - v110 - v27;
  if (v111)
    v27 = (unsigned __int16)v111 - (v111 >> 16) - (((unsigned __int16)v111 - (v111 >> 16)) >> 16);
  v112 = v109 + a2[31];
  v113 = a2[33];
  v114 = v108 + a2[32];
  v115 = v107 * (unint64_t)v113;
  LOWORD(v116) = 1 - v113 - v107;
  if (v115)
    v116 = (unsigned __int16)v115 - (v115 >> 16) - (((unsigned __int16)v115 - (v115 >> 16)) >> 16);
  v117 = a2[34];
  v118 = a2[35];
  v119 = (unsigned __int16)(v114 ^ v27) * (unint64_t)v117;
  v120 = 1 - v117 - (unsigned __int16)(v114 ^ v27);
  v121 = (unsigned __int16)((v114 ^ v27) * v117) - (v119 >> 16);
  v122 = v121 - (v121 >> 16);
  if (v119)
    v120 = v122;
  v123 = (unsigned __int16)(v120 + (v116 ^ v112)) * (unint64_t)v118;
  v124 = 1 - v118 - (unsigned __int16)(v120 + (v116 ^ v112));
  v125 = (unsigned __int16)((v120 + (v116 ^ v112)) * v118) - (v123 >> 16);
  v126 = v125 - (v125 >> 16);
  if (v123)
    v124 = v126;
  v127 = v124 + v120;
  v128 = v127 ^ v116;
  v129 = v127 ^ v112;
  v130 = v124 ^ v114;
  LODWORD(v27) = (unsigned __int16)(v124 ^ v27);
  v131 = a2[36];
  v132 = v27 * (unint64_t)v131;
  LOWORD(v27) = 1 - v131 - v27;
  if (v132)
    v27 = (unsigned __int16)v132 - (v132 >> 16) - (((unsigned __int16)v132 - (v132 >> 16)) >> 16);
  v133 = v130 + a2[37];
  v134 = a2[39];
  v135 = v129 + a2[38];
  v136 = v128 * (unint64_t)v134;
  LOWORD(v137) = 1 - v134 - v128;
  if (v136)
    v137 = (unsigned __int16)v136 - (v136 >> 16) - (((unsigned __int16)v136 - (v136 >> 16)) >> 16);
  v138 = a2[40];
  v139 = a2[41];
  v140 = (unsigned __int16)(v135 ^ v27) * (unint64_t)v138;
  v141 = 1 - v138 - (unsigned __int16)(v135 ^ v27);
  v142 = (unsigned __int16)((v135 ^ v27) * v138) - (v140 >> 16);
  v143 = v142 - (v142 >> 16);
  if (v140)
    v141 = v143;
  v144 = (unsigned __int16)(v141 + (v137 ^ v133)) * (unint64_t)v139;
  v145 = 1 - v139 - (unsigned __int16)(v141 + (v137 ^ v133));
  v146 = (unsigned __int16)((v141 + (v137 ^ v133)) * v139) - (v144 >> 16);
  v147 = v146 - (v146 >> 16);
  if (v144)
    v145 = v147;
  v148 = v145 + v141;
  v149 = v148 ^ v137;
  v150 = v148 ^ v133;
  v151 = v145 ^ v135;
  v152 = (unsigned __int16)(v145 ^ v27);
  v153 = a2[42];
  v154 = v152 * (unint64_t)v153;
  v155 = 1 - v153 - v152;
  v156 = (unsigned __int16)v154 - (v154 >> 16) - (((unsigned __int16)v154 - (v154 >> 16)) >> 16);
  if (!v154)
    LOWORD(v156) = v155;
  v157 = v151 + a2[43];
  v158 = a2[45];
  v159 = v150 + a2[44];
  v160 = v149 * (unint64_t)v158;
  LOWORD(v161) = 1 - v158 - v149;
  if (v160)
    v161 = (unsigned __int16)v160 - (v160 >> 16) - (((unsigned __int16)v160 - (v160 >> 16)) >> 16);
  v162 = a2[46];
  v163 = a2[47];
  v164 = (unsigned __int16)(v159 ^ v156) * (unint64_t)v162;
  v165 = 1 - v162 - (v159 ^ v156);
  v166 = (unsigned __int16)((v159 ^ v156) * v162) - (v164 >> 16);
  v167 = v166 - (v166 >> 16);
  if (v164)
    v165 = v167;
  v168 = (unsigned __int16)(v165 + (v161 ^ v157)) * (unint64_t)v163;
  v169 = 1 - v163 - (unsigned __int16)(v165 + (v161 ^ v157));
  v170 = (unsigned __int16)((v165 + (v161 ^ v157)) * v163) - (v168 >> 16);
  v171 = v170 - (v170 >> 16);
  if (v168)
    v169 = v171;
  v172 = v169 + v165;
  v173 = v172 ^ v161;
  v174 = (unsigned __int16)(v169 ^ v156);
  v175 = a2[48];
  v176 = a2[49];
  v177 = v174 * (unint64_t)v175;
  LODWORD(v156) = 1 - v175 - v174;
  if (v177)
    v156 = (unsigned __int16)v177 - (v177 >> 16) - (((unsigned __int16)v177 - (v177 >> 16)) >> 16);
  v178 = a2[50];
  v179 = a2[51];
  v180 = v173 * (unint64_t)v179;
  v181 = 1 - v179 - v173;
  v182 = (unsigned __int16)(v173 * v179) - (v180 >> 16) - (((unsigned __int16)(v173 * v179) - (v180 >> 16)) >> 16);
  if (v180)
    v181 = v182;
  *result = ((_DWORD)v156 << 16) | (unint64_t)(unsigned __int16)((v172 ^ v157) + v176);
  result[1] = (((v169 ^ v159) + v178) << 16) | (unint64_t)v181;
  return result;
}

void DSA_set_default_method(const DSA_METHOD *a1)
{
  default_DSA_method = (uint64_t)a1;
}

const DSA_METHOD *DSA_get_default_method(void)
{
  const DSA_METHOD *result;

  result = (const DSA_METHOD *)default_DSA_method;
  if (!default_DSA_method)
  {
    result = DSA_OpenSSL();
    default_DSA_method = (uint64_t)result;
  }
  return result;
}

DSA *DSA_new(void)
{
  return DSA_new_method(0);
}

DSA *__cdecl DSA_new_method(ENGINE *engine)
{
  char *v2;
  const DSA_METHOD *v3;
  const DSA_METHOD *DSA;
  unsigned int (*v5)(char *);

  v2 = (char *)malloc_type_malloc(0x78uLL, 0x106004072515E81uLL);
  if (!v2)
  {
    ERR_put_error(10, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/dsa/dsa_lib.c", 130);
    return (DSA *)v2;
  }
  v3 = (const DSA_METHOD *)default_DSA_method;
  if (!default_DSA_method)
  {
    v3 = DSA_OpenSSL();
    default_DSA_method = (uint64_t)v3;
  }
  *((_QWORD *)v2 + 13) = v3;
  if (engine)
  {
    if (!ENGINE_init(engine))
    {
      ERR_put_error(10, 4095, 38, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/dsa/dsa_lib.c", 137);
      goto LABEL_16;
    }
    *((_QWORD *)v2 + 14) = engine;
    goto LABEL_9;
  }
  engine = ENGINE_get_default_DSA();
  *((_QWORD *)v2 + 14) = engine;
  if (engine)
  {
LABEL_9:
    DSA = ENGINE_get_DSA(engine);
    *((_QWORD *)v2 + 13) = DSA;
    if (!DSA)
    {
      ERR_put_error(10, 4095, 38, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/dsa/dsa_lib.c", 147);
      ENGINE_finish(*((ENGINE **)v2 + 14));
LABEL_16:
      free(v2);
      return 0;
    }
    goto LABEL_13;
  }
  DSA = (const DSA_METHOD *)*((_QWORD *)v2 + 13);
LABEL_13:
  *(_DWORD *)v2 = 0;
  *((_QWORD *)v2 + 10) = 0;
  *(_OWORD *)(v2 + 8) = 0u;
  *(_OWORD *)(v2 + 24) = 0u;
  *(_OWORD *)(v2 + 40) = 0u;
  *(_OWORD *)(v2 + 56) = 0u;
  *((_DWORD *)v2 + 22) = 1;
  *((_DWORD *)v2 + 18) = DSA->flags & 0xFFFFFBFF;
  CRYPTO_new_ex_data(7, v2, (CRYPTO_EX_DATA *)v2 + 6);
  v5 = *(unsigned int (**)(char *))(*((_QWORD *)v2 + 13) + 48);
  if (v5 && !v5(v2))
  {
    ENGINE_finish(*((ENGINE **)v2 + 14));
    CRYPTO_free_ex_data(7, v2, (CRYPTO_EX_DATA *)v2 + 6);
    goto LABEL_16;
  }
  return (DSA *)v2;
}

int DSA_set_method(DSA *dsa, const DSA_METHOD *a2)
{
  int (__cdecl *comp)(const char *const *, const char *const *);
  int (__cdecl *init)(DSA *);

  comp = dsa->ex_data.sk[1].comp;
  if (comp)
    ((void (*)(DSA *))comp)(dsa);
  ENGINE_finish(*(ENGINE **)&dsa->ex_data.dummy);
  dsa->ex_data.sk = (STACK *)a2;
  *(_QWORD *)&dsa->ex_data.dummy = 0;
  init = a2->init;
  if (init)
    ((void (*)(DSA *))init)(dsa);
  return 1;
}

void DSA_free(DSA *r)
{
  int (__cdecl *comp)(const char *const *, const char *const *);

  if (r && CRYPTO_add_lock((int *)&r->method_mont_p, -1, 8, 0, 0) <= 0)
  {
    comp = r->ex_data.sk[1].comp;
    if (comp)
      ((void (*)(DSA *))comp)(r);
    ENGINE_finish(*(ENGINE **)&r->ex_data.dummy);
    CRYPTO_free_ex_data(7, r, (CRYPTO_EX_DATA *)&r->references);
    BN_free(*(BIGNUM **)&r->write_params);
    BN_free(r->p);
    BN_free(r->q);
    BN_free(r->g);
    BN_free(r->pub_key);
    BN_free(r->priv_key);
    BN_free(r->kinv);
    free(r);
  }
}

int DSA_up_ref(DSA *r)
{
  return CRYPTO_add_lock((int *)&r->method_mont_p, 1, 8, 0, 0) > 1;
}

int DSA_size(const DSA *a1)
{
  int v1;
  DSA_SIG v3;

  v3.r = a1->p;
  v3.s = v3.r;
  v1 = i2d_DSA_SIG(&v3, 0);
  return v1 & ~(v1 >> 31);
}

int DSA_get_ex_new_index(uint64_t argl, void *argp, CRYPTO_EX_new *new_func, CRYPTO_EX_dup *dup_func, CRYPTO_EX_free *free_func)
{
  return CRYPTO_get_ex_new_index(7, argl, argp, new_func, dup_func, free_func);
}

int DSA_set_ex_data(DSA *d, int idx, void *arg)
{
  return CRYPTO_set_ex_data((CRYPTO_EX_DATA *)&d->references, idx, arg);
}

void *__cdecl DSA_get_ex_data(DSA *d, int idx)
{
  return CRYPTO_get_ex_data((const CRYPTO_EX_DATA *)&d->references, idx);
}

uint64_t DSA_security_bits(uint64_t a1)
{
  const BIGNUM *v2;
  int v3;
  int v4;

  v2 = *(const BIGNUM **)(a1 + 16);
  if (!v2 || !*(_QWORD *)(a1 + 24))
    return 0xFFFFFFFFLL;
  v3 = BN_num_bits(v2);
  v4 = BN_num_bits(*(const BIGNUM **)(a1 + 24));
  return BN_security_bits(v3, v4);
}

DH *__cdecl DSA_dup_DH(const DSA *r)
{
  DH *v2;
  const BIGNUM *v3;
  BIGNUM *v4;
  BIGNUM *p;
  BIGNUM *v6;
  BIGNUM *q;
  BIGNUM *v8;
  BIGNUM *g;
  BIGNUM *v10;
  BIGNUM *pub_key;
  BIGNUM *v12;

  if (!r)
  {
    v2 = 0;
LABEL_15:
    DH_free(v2);
    return 0;
  }
  v2 = DH_new();
  if (!v2)
    goto LABEL_15;
  v3 = *(const BIGNUM **)&r->write_params;
  if (v3)
  {
    v4 = BN_dup(v3);
    v2->p = v4;
    if (!v4)
      goto LABEL_15;
  }
  p = r->p;
  if (p)
  {
    v2->length = BN_num_bits(p);
    v6 = BN_dup(r->p);
    v2->q = v6;
    if (!v6)
      goto LABEL_15;
  }
  q = r->q;
  if (q)
  {
    v8 = BN_dup(q);
    v2->g = v8;
    if (!v8)
      goto LABEL_15;
  }
  g = r->g;
  if (g)
  {
    v10 = BN_dup(g);
    v2->pub_key = v10;
    if (!v10)
      goto LABEL_15;
  }
  pub_key = r->pub_key;
  if (pub_key)
  {
    v12 = BN_dup(pub_key);
    v2->priv_key = v12;
    if (!v12)
      goto LABEL_15;
  }
  return v2;
}

_QWORD *DSA_get0_pqg(_QWORD *result, _QWORD *a2, _QWORD *a3, _QWORD *a4)
{
  if (a2)
    *a2 = result[2];
  if (a3)
    *a3 = result[3];
  if (a4)
    *a4 = result[4];
  return result;
}

uint64_t DSA_set0_pqg(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  BIGNUM *v5;

  v5 = *(BIGNUM **)(a1 + 16);
  if (!(a2 | (unint64_t)v5) || !(a3 | *(_QWORD *)(a1 + 24)) || !(a4 | *(_QWORD *)(a1 + 32)))
    return 0;
  if (a2)
  {
    BN_free(v5);
    *(_QWORD *)(a1 + 16) = a2;
  }
  if (a3)
  {
    BN_free(*(BIGNUM **)(a1 + 24));
    *(_QWORD *)(a1 + 24) = a3;
  }
  if (a4)
  {
    BN_free(*(BIGNUM **)(a1 + 32));
    *(_QWORD *)(a1 + 32) = a4;
  }
  return 1;
}

uint64_t DSA_get0_key(uint64_t result, _QWORD *a2, _QWORD *a3)
{
  if (a2)
    *a2 = *(_QWORD *)(result + 40);
  if (a3)
    *a3 = *(_QWORD *)(result + 48);
  return result;
}

uint64_t DSA_set0_key(uint64_t a1, uint64_t a2, uint64_t a3)
{
  BIGNUM *v4;

  v4 = *(BIGNUM **)(a1 + 40);
  if (!(a2 | (unint64_t)v4))
    return 0;
  if (a2)
  {
    BN_free(v4);
    *(_QWORD *)(a1 + 40) = a2;
  }
  if (a3)
  {
    BN_free(*(BIGNUM **)(a1 + 48));
    *(_QWORD *)(a1 + 48) = a3;
  }
  return 1;
}

uint64_t DSA_get0_p(uint64_t a1)
{
  return *(_QWORD *)(a1 + 16);
}

uint64_t DSA_get0_q(uint64_t a1)
{
  return *(_QWORD *)(a1 + 24);
}

uint64_t DSA_get0_g(uint64_t a1)
{
  return *(_QWORD *)(a1 + 32);
}

uint64_t DSA_get0_pub_key(uint64_t a1)
{
  return *(_QWORD *)(a1 + 40);
}

uint64_t DSA_get0_priv_key(uint64_t a1)
{
  return *(_QWORD *)(a1 + 48);
}

uint64_t DSA_clear_flags(uint64_t result, int a2)
{
  *(_DWORD *)(result + 72) &= ~a2;
  return result;
}

uint64_t DSA_test_flags(uint64_t a1, unsigned int a2)
{
  return *(_DWORD *)(a1 + 72) & a2;
}

uint64_t DSA_set_flags(uint64_t result, int a2)
{
  *(_DWORD *)(result + 72) |= a2;
  return result;
}

uint64_t DSA_get0_engine(uint64_t a1)
{
  return *(_QWORD *)(a1 + 112);
}

uint64_t DSA_bits(uint64_t a1)
{
  return BN_num_bits(*(const BIGNUM **)(a1 + 16));
}

uint64_t dsa_check_key(uint64_t a1)
{
  uint64_t v2;
  const BIGNUM *v3;
  const BIGNUM *v4;
  int v5;
  int v6;
  int v8;
  int v9;
  const BIGNUM *v10;
  const BIGNUM *v11;
  const BIGNUM *v12;
  const BIGNUM *v13;

  v2 = *(_QWORD *)(a1 + 16);
  if (!v2 || !*(_QWORD *)(a1 + 24) || !*(_QWORD *)(a1 + 32))
  {
    v5 = 101;
    v6 = 433;
    goto LABEL_10;
  }
  if (!BN_is_odd(v2) || !BN_is_odd(*(_QWORD *)(a1 + 24)))
  {
    v5 = 112;
    v6 = 439;
    goto LABEL_10;
  }
  v3 = *(const BIGNUM **)(a1 + 32);
  v4 = BN_value_one();
  if (BN_cmp(v3, v4) < 1 || (BN_cmp(*(const BIGNUM **)(a1 + 32), *(const BIGNUM **)(a1 + 16)) & 0x80000000) == 0)
  {
    v5 = 112;
    v6 = 446;
LABEL_10:
    ERR_put_error(10, 4095, v5, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/dsa/dsa_lib.c", v6);
    return 0;
  }
  if (BN_is_negative(*(_QWORD *)(a1 + 24)))
  {
    v5 = 102;
    v6 = 452;
    goto LABEL_10;
  }
  v8 = BN_num_bits(*(const BIGNUM **)(a1 + 24));
  if (v8 != 160 && v8 != 224 && v8 != 256)
  {
    v5 = 102;
    v6 = 459;
    goto LABEL_10;
  }
  v9 = BN_num_bits(*(const BIGNUM **)(a1 + 16));
  if (v9 >= 10001)
  {
    v5 = 103;
    v6 = 471;
    goto LABEL_10;
  }
  if (v9 <= 511)
  {
    v5 = 112;
    v6 = 475;
    goto LABEL_10;
  }
  v10 = *(const BIGNUM **)(a1 + 40);
  if (v10)
  {
    v11 = BN_value_one();
    if (BN_cmp(v10, v11) < 1 || (BN_cmp(*(const BIGNUM **)(a1 + 40), *(const BIGNUM **)(a1 + 16)) & 0x80000000) == 0)
    {
      v5 = 112;
      v6 = 483;
      goto LABEL_10;
    }
  }
  v12 = *(const BIGNUM **)(a1 + 48);
  if (v12)
  {
    v13 = BN_value_one();
    if (BN_cmp(v12, v13) < 0 || (BN_cmp(*(const BIGNUM **)(a1 + 48), *(const BIGNUM **)(a1 + 24)) & 0x80000000) == 0)
    {
      v5 = 112;
      v6 = 492;
      goto LABEL_10;
    }
  }
  return 1;
}

PKCS12 *__cdecl d2i_PKCS12(PKCS12 **a, const unsigned __int8 **in, uint64_t len)
{
  return (PKCS12 *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &PKCS12_it);
}

int i2d_PKCS12(PKCS12 *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &PKCS12_it);
}

PKCS12 *PKCS12_new(void)
{
  return (PKCS12 *)ASN1_item_new(&PKCS12_it);
}

void PKCS12_free(PKCS12 *a)
{
  ASN1_item_free((ASN1_VALUE *)a, &PKCS12_it);
}

PKCS12_MAC_DATA *__cdecl d2i_PKCS12_MAC_DATA(PKCS12_MAC_DATA **a, const unsigned __int8 **in, uint64_t len)
{
  return (PKCS12_MAC_DATA *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &PKCS12_MAC_DATA_it);
}

int i2d_PKCS12_MAC_DATA(PKCS12_MAC_DATA *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &PKCS12_MAC_DATA_it);
}

PKCS12_MAC_DATA *PKCS12_MAC_DATA_new(void)
{
  return (PKCS12_MAC_DATA *)ASN1_item_new(&PKCS12_MAC_DATA_it);
}

void PKCS12_MAC_DATA_free(PKCS12_MAC_DATA *a)
{
  ASN1_item_free((ASN1_VALUE *)a, &PKCS12_MAC_DATA_it);
}

PKCS12_BAGS *__cdecl d2i_PKCS12_BAGS(PKCS12_BAGS **a, const unsigned __int8 **in, uint64_t len)
{
  return (PKCS12_BAGS *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &PKCS12_BAGS_it);
}

int i2d_PKCS12_BAGS(PKCS12_BAGS *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &PKCS12_BAGS_it);
}

PKCS12_BAGS *PKCS12_BAGS_new(void)
{
  return (PKCS12_BAGS *)ASN1_item_new(&PKCS12_BAGS_it);
}

void PKCS12_BAGS_free(PKCS12_BAGS *a)
{
  ASN1_item_free((ASN1_VALUE *)a, &PKCS12_BAGS_it);
}

PKCS12_SAFEBAG *__cdecl d2i_PKCS12_SAFEBAG(PKCS12_SAFEBAG **a, const unsigned __int8 **in, uint64_t len)
{
  return (PKCS12_SAFEBAG *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &PKCS12_SAFEBAG_it);
}

int i2d_PKCS12_SAFEBAG(PKCS12_SAFEBAG *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &PKCS12_SAFEBAG_it);
}

PKCS12_SAFEBAG *PKCS12_SAFEBAG_new(void)
{
  return (PKCS12_SAFEBAG *)ASN1_item_new(&PKCS12_SAFEBAG_it);
}

void PKCS12_SAFEBAG_free(PKCS12_SAFEBAG *a)
{
  ASN1_item_free((ASN1_VALUE *)a, &PKCS12_SAFEBAG_it);
}

void CAST_encrypt(unint64_t *data, const CAST_KEY *key)
{
  int v2;
  unsigned int v3;
  int v4;
  unsigned int v5;
  int v6;
  unsigned int v7;
  int v8;
  unsigned int v9;
  int v10;
  unsigned int v11;
  int v12;
  unsigned int v13;
  int v14;
  unsigned int v15;
  int v16;
  unsigned int v17;
  int v18;
  unsigned int v19;
  int v20;
  unsigned int v21;
  int v22;
  unsigned int v23;
  int v24;
  unsigned int v25;
  int v26;
  unsigned int v27;
  int v28;
  unsigned int v29;
  int v30;
  unsigned int v31;
  unsigned int v32;

  v2 = *((_DWORD *)data + 1);
  v3 = __ROR4__(LODWORD(key->data[0]) + v2, -BYTE4(key->data[0]));
  v4 = ((CAST_S_table1[v3] ^ CAST_S_table0[BYTE1(v3)])
      - CAST_S_table2[HIBYTE(v3)]
      + CAST_S_table3[BYTE2(v3)]) ^ *(_DWORD *)data;
  v5 = __ROR4__(v4 ^ LODWORD(key->data[1]), -BYTE4(key->data[1]));
  v6 = CAST_S_table3[BYTE2(v5)] ^ v2 ^ (CAST_S_table0[BYTE1(v5)]
                                      - CAST_S_table1[v5]
                                      + CAST_S_table2[HIBYTE(v5)]);
  v7 = __ROR4__(LODWORD(key->data[2]) - v6, -BYTE4(key->data[2]));
  v8 = (((CAST_S_table1[v7] + CAST_S_table0[BYTE1(v7)]) ^ CAST_S_table2[HIBYTE(v7)])
      - CAST_S_table3[BYTE2(v7)]) ^ v4;
  v9 = __ROR4__(v8 + LODWORD(key->data[3]), -BYTE4(key->data[3]));
  v10 = ((CAST_S_table1[v9] ^ CAST_S_table0[BYTE1(v9)])
       - CAST_S_table2[HIBYTE(v9)]
       + CAST_S_table3[BYTE2(v9)]) ^ v6;
  v11 = __ROR4__(v10 ^ LODWORD(key->data[4]), -BYTE4(key->data[4]));
  v12 = CAST_S_table3[BYTE2(v11)] ^ v8 ^ (CAST_S_table0[BYTE1(v11)]
                                        - CAST_S_table1[v11]
                                        + CAST_S_table2[HIBYTE(v11)]);
  v13 = __ROR4__(LODWORD(key->data[5]) - v12, -BYTE4(key->data[5]));
  v14 = (((CAST_S_table1[v13] + CAST_S_table0[BYTE1(v13)]) ^ CAST_S_table2[HIBYTE(v13)])
       - CAST_S_table3[BYTE2(v13)]) ^ v10;
  v15 = __ROR4__(v14 + LODWORD(key->data[6]), -BYTE4(key->data[6]));
  v16 = ((CAST_S_table1[v15] ^ CAST_S_table0[BYTE1(v15)])
       - CAST_S_table2[HIBYTE(v15)]
       + CAST_S_table3[BYTE2(v15)]) ^ v12;
  v17 = __ROR4__(v16 ^ LODWORD(key->data[7]), -BYTE4(key->data[7]));
  v18 = CAST_S_table3[BYTE2(v17)] ^ v14 ^ (CAST_S_table0[BYTE1(v17)]
                                         - CAST_S_table1[v17]
                                         + CAST_S_table2[HIBYTE(v17)]);
  v19 = __ROR4__(LODWORD(key->data[8]) - v18, -BYTE4(key->data[8]));
  v20 = (((CAST_S_table1[v19] + CAST_S_table0[BYTE1(v19)]) ^ CAST_S_table2[HIBYTE(v19)])
       - CAST_S_table3[BYTE2(v19)]) ^ v16;
  v21 = __ROR4__(v20 + LODWORD(key->data[9]), -BYTE4(key->data[9]));
  v22 = ((CAST_S_table1[v21] ^ CAST_S_table0[BYTE1(v21)])
       - CAST_S_table2[HIBYTE(v21)]
       + CAST_S_table3[BYTE2(v21)]) ^ v18;
  v23 = __ROR4__(v22 ^ LODWORD(key->data[10]), -BYTE4(key->data[10]));
  v24 = CAST_S_table3[BYTE2(v23)] ^ v20 ^ (CAST_S_table0[BYTE1(v23)]
                                         - CAST_S_table1[v23]
                                         + CAST_S_table2[HIBYTE(v23)]);
  v25 = __ROR4__(LODWORD(key->data[11]) - v24, -BYTE4(key->data[11]));
  v26 = (((CAST_S_table1[v25] + CAST_S_table0[BYTE1(v25)]) ^ CAST_S_table2[HIBYTE(v25)])
       - CAST_S_table3[BYTE2(v25)]) ^ v22;
  if (!LODWORD(key->data[16]))
  {
    v27 = __ROR4__(LODWORD(key->data[12]) + v26, -BYTE4(key->data[12]));
    v28 = ((CAST_S_table1[v27] ^ CAST_S_table0[BYTE1(v27)])
         - CAST_S_table2[HIBYTE(v27)]
         + CAST_S_table3[BYTE2(v27)]) ^ v24;
    v29 = __ROR4__(v28 ^ LODWORD(key->data[13]), -BYTE4(key->data[13]));
    v30 = CAST_S_table3[BYTE2(v29)] ^ v26 ^ (CAST_S_table0[BYTE1(v29)]
                                           - CAST_S_table1[v29]
                                           + CAST_S_table2[HIBYTE(v29)]);
    v31 = __ROR4__(LODWORD(key->data[14]) - v30, -BYTE4(key->data[14]));
    v24 = (((CAST_S_table1[v31] + CAST_S_table0[BYTE1(v31)]) ^ CAST_S_table2[HIBYTE(v31)])
         - CAST_S_table3[BYTE2(v31)]) ^ v28;
    v32 = __ROR4__(v24 + LODWORD(key->data[15]), -BYTE4(key->data[15]));
    v26 = ((CAST_S_table1[v32] ^ CAST_S_table0[BYTE1(v32)])
         - CAST_S_table2[HIBYTE(v32)]
         + CAST_S_table3[BYTE2(v32)]) ^ v30;
  }
  *(_DWORD *)data = v26;
  *((_DWORD *)data + 1) = v24;
}

void CAST_decrypt(unint64_t *data, const CAST_KEY *key)
{
  int v2;
  int v3;
  unsigned int v4;
  int v5;
  unsigned int v6;
  int v7;
  unsigned int v8;
  unsigned int v9;
  unsigned int v10;
  int v11;
  unsigned int v12;
  int v13;
  unsigned int v14;
  int v15;
  unsigned int v16;
  int v17;
  unsigned int v18;
  int v19;
  unsigned int v20;
  int v21;
  unsigned int v22;
  int v23;
  unsigned int v24;
  int v25;
  unsigned int v26;
  int v27;
  unsigned int v28;
  int v29;
  unsigned int v30;
  int v31;
  unsigned int v32;

  v3 = *(_DWORD *)data;
  v2 = *((_DWORD *)data + 1);
  if (!LODWORD(key->data[16]))
  {
    v4 = __ROR4__(LODWORD(key->data[15]) + v2, -BYTE4(key->data[15]));
    v5 = ((CAST_S_table1[v4] ^ CAST_S_table0[BYTE1(v4)])
        - CAST_S_table2[HIBYTE(v4)]
        + CAST_S_table3[BYTE2(v4)]) ^ v3;
    v6 = __ROR4__(LODWORD(key->data[14]) - v5, -BYTE4(key->data[14]));
    v7 = (((CAST_S_table1[v6] + CAST_S_table0[BYTE1(v6)]) ^ CAST_S_table2[HIBYTE(v6)])
        - CAST_S_table3[BYTE2(v6)]) ^ v2;
    v8 = __ROR4__(v7 ^ LODWORD(key->data[13]), -BYTE4(key->data[13]));
    v3 = CAST_S_table3[BYTE2(v8)] ^ v5 ^ (CAST_S_table0[BYTE1(v8)]
                                        - CAST_S_table1[v8]
                                        + CAST_S_table2[HIBYTE(v8)]);
    v9 = __ROR4__(v3 + LODWORD(key->data[12]), -BYTE4(key->data[12]));
    v2 = ((CAST_S_table1[v9] ^ CAST_S_table0[BYTE1(v9)])
        - CAST_S_table2[HIBYTE(v9)]
        + CAST_S_table3[BYTE2(v9)]) ^ v7;
  }
  v10 = __ROR4__(LODWORD(key->data[11]) - v2, -BYTE4(key->data[11]));
  v11 = (((CAST_S_table1[v10] + CAST_S_table0[BYTE1(v10)]) ^ CAST_S_table2[HIBYTE(v10)])
       - CAST_S_table3[BYTE2(v10)]) ^ v3;
  v12 = __ROR4__(v11 ^ LODWORD(key->data[10]), -BYTE4(key->data[10]));
  v13 = CAST_S_table3[BYTE2(v12)] ^ v2 ^ (CAST_S_table0[BYTE1(v12)]
                                        - CAST_S_table1[v12]
                                        + CAST_S_table2[HIBYTE(v12)]);
  v14 = __ROR4__(v13 + LODWORD(key->data[9]), -BYTE4(key->data[9]));
  v15 = ((CAST_S_table1[v14] ^ CAST_S_table0[BYTE1(v14)])
       - CAST_S_table2[HIBYTE(v14)]
       + CAST_S_table3[BYTE2(v14)]) ^ v11;
  v16 = __ROR4__(LODWORD(key->data[8]) - v15, -BYTE4(key->data[8]));
  v17 = (((CAST_S_table1[v16] + CAST_S_table0[BYTE1(v16)]) ^ CAST_S_table2[HIBYTE(v16)])
       - CAST_S_table3[BYTE2(v16)]) ^ v13;
  v18 = __ROR4__(v17 ^ LODWORD(key->data[7]), -BYTE4(key->data[7]));
  v19 = CAST_S_table3[BYTE2(v18)] ^ v15 ^ (CAST_S_table0[BYTE1(v18)]
                                         - CAST_S_table1[v18]
                                         + CAST_S_table2[HIBYTE(v18)]);
  v20 = __ROR4__(v19 + LODWORD(key->data[6]), -BYTE4(key->data[6]));
  v21 = ((CAST_S_table1[v20] ^ CAST_S_table0[BYTE1(v20)])
       - CAST_S_table2[HIBYTE(v20)]
       + CAST_S_table3[BYTE2(v20)]) ^ v17;
  v22 = __ROR4__(LODWORD(key->data[5]) - v21, -BYTE4(key->data[5]));
  v23 = (((CAST_S_table1[v22] + CAST_S_table0[BYTE1(v22)]) ^ CAST_S_table2[HIBYTE(v22)])
       - CAST_S_table3[BYTE2(v22)]) ^ v19;
  v24 = __ROR4__(v23 ^ LODWORD(key->data[4]), -BYTE4(key->data[4]));
  v25 = CAST_S_table3[BYTE2(v24)] ^ v21 ^ (CAST_S_table0[BYTE1(v24)]
                                         - CAST_S_table1[v24]
                                         + CAST_S_table2[HIBYTE(v24)]);
  v26 = __ROR4__(v25 + LODWORD(key->data[3]), -BYTE4(key->data[3]));
  v27 = ((CAST_S_table1[v26] ^ CAST_S_table0[BYTE1(v26)])
       - CAST_S_table2[HIBYTE(v26)]
       + CAST_S_table3[BYTE2(v26)]) ^ v23;
  v28 = __ROR4__(LODWORD(key->data[2]) - v27, -BYTE4(key->data[2]));
  v29 = (((CAST_S_table1[v28] + CAST_S_table0[BYTE1(v28)]) ^ CAST_S_table2[HIBYTE(v28)])
       - CAST_S_table3[BYTE2(v28)]) ^ v25;
  v30 = __ROR4__(v29 ^ LODWORD(key->data[1]), -BYTE4(key->data[1]));
  v31 = CAST_S_table3[BYTE2(v30)] ^ v27 ^ (CAST_S_table0[BYTE1(v30)]
                                         - CAST_S_table1[v30]
                                         + CAST_S_table2[HIBYTE(v30)]);
  v32 = __ROR4__(v31 + LODWORD(key->data[0]), -BYTE4(key->data[0]));
  *(_DWORD *)data = ((CAST_S_table1[v32] ^ CAST_S_table0[BYTE1(v32)])
                   - CAST_S_table2[HIBYTE(v32)]
                   + CAST_S_table3[BYTE2(v32)]) ^ v29;
  *((_DWORD *)data + 1) = v31;
}

void CAST_cbc_encrypt(const unsigned __int8 *in, unsigned __int8 *out, uint64_t length, const CAST_KEY *ks, unsigned __int8 *iv, int enc)
{
  uint64_t v8;
  unsigned int v10;
  unsigned int v11;
  unsigned __int8 *v12;
  unint64_t v13;
  const unsigned __int8 *v14;
  unsigned int v15;
  int v16;
  const unsigned __int8 *v17;
  int v18;
  int v19;
  int v20;
  int v21;
  int v22;
  int v23;
  int v24;
  unsigned int v25;
  int v26;
  unsigned int v27;
  unsigned int v28;
  unsigned int v29;
  unsigned int v30;
  unsigned int v31;
  unsigned __int8 *v32;
  unsigned int v33;
  unsigned int v34;
  unint64_t v35;
  const unsigned __int8 *v36;
  int v37;
  int v38;
  unsigned int v39;
  int v40;
  int v41;
  unsigned __int8 *v42;
  unint64_t v43[2];

  v8 = length;
  v43[1] = *MEMORY[0x24BDAC8D0];
  v10 = bswap32(*(_DWORD *)iv);
  v11 = bswap32(*((_DWORD *)iv + 1));
  if (enc)
  {
    if (length >= 8)
    {
      do
      {
        v12 = out;
        v13 = v8;
        v8 -= 8;
        v14 = in + 8;
        v15 = bswap32(*((_DWORD *)in + 1));
        LODWORD(v43[0]) = bswap32(*(_DWORD *)in) ^ v10;
        HIDWORD(v43[0]) = v15 ^ v11;
        CAST_encrypt(v43, ks);
        v10 = v43[0];
        v11 = HIDWORD(v43[0]);
        *out = BYTE3(v43[0]);
        out[1] = BYTE2(v10);
        out[2] = BYTE1(v10);
        out[3] = v10;
        out[4] = HIBYTE(v11);
        out[5] = BYTE2(v11);
        out[6] = BYTE1(v11);
        out += 8;
        v12[7] = v11;
        in = v14;
      }
      while (v13 > 0xF);
      in = v14;
    }
    if (v8)
    {
      v16 = 0;
      v17 = &in[v8];
      v18 = 0;
      switch(v8)
      {
        case 1:
          goto LABEL_13;
        case 2:
          goto LABEL_12;
        case 3:
          goto LABEL_11;
        case 4:
          goto LABEL_10;
        case 5:
          goto LABEL_9;
        case 6:
          goto LABEL_8;
        case 7:
          v19 = *--v17;
          v16 = v19 << 8;
LABEL_8:
          v20 = *--v17;
          v16 |= v20 << 16;
LABEL_9:
          v21 = *--v17;
          v16 |= v21 << 24;
LABEL_10:
          v18 = v16;
          v22 = *--v17;
          v16 = v22;
LABEL_11:
          v23 = *--v17;
          v16 |= v23 << 8;
LABEL_12:
          v24 = *--v17;
          v16 |= v24 << 16;
LABEL_13:
          v16 |= *(v17 - 1) << 24;
          break;
        default:
          v18 = 0;
          break;
      }
      LODWORD(v43[0]) = v16 ^ v10;
      HIDWORD(v43[0]) = v18 ^ v11;
      CAST_encrypt(v43, ks);
      v10 = v43[0];
      v25 = HIDWORD(v43[0]);
      v26 = HIBYTE(LODWORD(v43[0]));
      *out = BYTE3(v43[0]);
      v27 = HIWORD(v10);
      out[1] = BYTE2(v10);
      v28 = v10 >> 8;
      out[2] = BYTE1(v10);
      out[3] = v10;
      v29 = HIBYTE(v25);
      out[4] = HIBYTE(v25);
      v30 = HIWORD(v25);
      out[5] = BYTE2(v25);
      v31 = v25 >> 8;
      out[6] = BYTE1(v25);
      out[7] = v25;
    }
    else
    {
      v26 = HIBYTE(v10);
      v27 = HIWORD(v10);
      v28 = v10 >> 8;
      v29 = HIBYTE(v11);
      v30 = HIWORD(v11);
      LOBYTE(v25) = v11;
      v31 = v11 >> 8;
    }
    *iv = v26;
    iv[1] = v27;
    iv[2] = v28;
    iv[3] = v10;
    iv[4] = v29;
    iv[5] = v30;
    iv[6] = v31;
  }
  else
  {
    if (length >= 8)
    {
      do
      {
        v32 = out;
        v33 = v10;
        v34 = v11;
        v35 = v8;
        v8 -= 8;
        v10 = bswap32(*(_DWORD *)in);
        v36 = in + 8;
        v11 = bswap32(*((_DWORD *)in + 1));
        v43[0] = __PAIR64__(v11, v10);
        CAST_decrypt(v43, ks);
        v37 = LODWORD(v43[0]) ^ v33;
        v38 = HIDWORD(v43[0]) ^ v34;
        *v32 = (LODWORD(v43[0]) ^ v33) >> 24;
        v32[1] = BYTE2(v37);
        v32[2] = BYTE1(v37);
        v32[3] = v37;
        v32[4] = HIBYTE(v38);
        v32[5] = BYTE2(v38);
        v32[6] = BYTE1(v38);
        out = v32 + 8;
        v32[7] = v38;
        in = v36;
      }
      while (v35 > 0xF);
      in = v36;
    }
    if (v8)
    {
      v39 = bswap32(*(_DWORD *)in);
      v25 = bswap32(*((_DWORD *)in + 1));
      v43[0] = __PAIR64__(v25, v39);
      CAST_decrypt(v43, ks);
      v40 = LODWORD(v43[0]) ^ v10;
      v41 = HIDWORD(v43[0]) ^ v11;
      v42 = &out[v8];
      switch(v8)
      {
        case 1:
          goto LABEL_26;
        case 2:
          goto LABEL_25;
        case 3:
          goto LABEL_24;
        case 4:
          goto LABEL_23;
        case 5:
          goto LABEL_22;
        case 6:
          goto LABEL_21;
        case 7:
          *--v42 = BYTE1(v41);
LABEL_21:
          *--v42 = BYTE2(v41);
LABEL_22:
          *--v42 = HIBYTE(v41);
LABEL_23:
          *--v42 = v40;
LABEL_24:
          *--v42 = BYTE1(v40);
LABEL_25:
          *--v42 = BYTE2(v40);
LABEL_26:
          *(v42 - 1) = HIBYTE(v40);
          break;
        default:
          break;
      }
    }
    else
    {
      v39 = v10;
      v25 = v11;
    }
    *iv = HIBYTE(v39);
    iv[1] = BYTE2(v39);
    iv[2] = BYTE1(v39);
    iv[3] = v39;
    iv[4] = HIBYTE(v25);
    iv[5] = BYTE2(v25);
    iv[6] = BYTE1(v25);
  }
  iv[7] = v25;
}

int PKCS12_PBE_keyivgen(EVP_CIPHER_CTX *ctx, const char *pass, int passlen, ASN1_TYPE *param, const EVP_CIPHER *cipher, const EVP_MD *md_type, int en_de)
{
  char *ptr;
  PBEPARAM *v14;
  PBEPARAM *v15;
  ASN1_INTEGER *iter;
  int v17;
  int v18;
  int v19;
  int v20;
  int v21;
  unsigned __int8 *data;
  int length;
  int v25;
  int v26;
  unsigned __int8 *in;
  unsigned __int8 iv[16];
  unsigned __int8 out[64];
  uint64_t v30;

  v30 = *MEMORY[0x24BDAC8D0];
  if (param && param->type == 16 && (ptr = param->value.ptr) != 0)
  {
    in = (unsigned __int8 *)*((_QWORD *)ptr + 1);
    v14 = d2i_PBEPARAM(0, (const unsigned __int8 **)&in, *(int *)ptr);
    if (v14)
    {
      v15 = v14;
      iter = v14->iter;
      if (iter)
      {
        v17 = ASN1_INTEGER_get(iter);
        if (v17 <= 0)
        {
          v18 = 101;
          v19 = 99;
LABEL_19:
          ERR_put_error(35, 4095, v18, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/pkcs12/p12_crpt.c", v19);
          PBEPARAM_free(v15);
          return 0;
        }
      }
      else
      {
        v17 = 1;
      }
      data = v15->salt->data;
      length = v15->salt->length;
      v25 = EVP_CIPHER_key_length(cipher);
      if (PKCS12_key_gen_asc(pass, passlen, data, length, 1, v17, v25, out, md_type))
      {
        v26 = EVP_CIPHER_iv_length(cipher);
        if (PKCS12_key_gen_asc(pass, passlen, data, length, 2, v17, v26, iv, md_type))
        {
          PBEPARAM_free(v15);
          v21 = EVP_CipherInit_ex(ctx, cipher, 0, out, iv, en_de);
          explicit_bzero(out, 0x40uLL);
          explicit_bzero(iv, 0x10uLL);
          return v21;
        }
        v18 = 106;
        v19 = 113;
      }
      else
      {
        v18 = 107;
        v19 = 107;
      }
      goto LABEL_19;
    }
    v20 = 92;
  }
  else
  {
    v20 = 86;
  }
  ERR_put_error(35, 4095, 101, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/pkcs12/p12_crpt.c", v20);
  return 0;
}

uint64_t pkey_gost01_decrypt(uint64_t *a1, uint64_t a2, _QWORD *a3, const unsigned __int8 *a4, uint64_t a5)
{
  uint64_t v9;
  uint64_t v10;
  ASN1_VALUE *v11;
  ASN1_VALUE *v12;
  EVP_PKEY *v13;
  int v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t *v21;
  uint64_t v22;
  __int128 *v23;
  __int128 v24;
  uint64_t v25;
  uint64_t v26;
  const unsigned __int8 *v28;
  _BYTE v29[32];
  uint64_t v30;
  __int128 v31;
  __int128 v32;
  int v33;
  uint64_t v34;

  v34 = *MEMORY[0x24BDAC8D0];
  v28 = a4;
  v9 = EVP_PKEY_CTX_get0_pkey((uint64_t)a1);
  if (a2)
  {
    v10 = v9;
    v11 = d2i_GOST_KEY_TRANSPORT(0, &v28, a5);
    if (v11)
    {
      v12 = v11;
      v13 = X509_PUBKEY_get(*(X509_PUBKEY **)(*((_QWORD *)v11 + 1) + 8));
      if (v13)
      {
        if ((int)EVP_PKEY_derive_set_peer((uint64_t)a1, v13) <= 0)
        {
          v14 = 111;
          v15 = 401;
          goto LABEL_21;
        }
      }
      else if ((int)EVP_PKEY_CTX_ctrl(a1, -1, -1) <= 0)
      {
        v14 = 107;
        v15 = 408;
        goto LABEL_21;
      }
      v17 = EVP_PKEY_CTX_get0_peerkey((uint64_t)a1);
      if (v17)
      {
        v18 = v17;
        v19 = OBJ_obj2nid(**((const ASN1_OBJECT ***)v12 + 1));
        v20 = *(_QWORD *)(*((_QWORD *)v12 + 1) + 16);
        if (*(_DWORD *)v20 == 8)
        {
          v30 = **(_QWORD **)(v20 + 8);
          v21 = *(uint64_t **)v12;
          v22 = **(_QWORD **)v12;
          if (*(_DWORD *)v22 == 32)
          {
            v23 = *(__int128 **)(v22 + 8);
            v24 = v23[1];
            v31 = *v23;
            v32 = v24;
            v25 = v21[1];
            if (*(_DWORD *)v25 == 4)
            {
              v26 = v19;
              v33 = **(_DWORD **)(v25 + 8);
              if ((int)gost01_VKO_key(v18, v10, (unsigned __int8 *)&v30, v29) < 1)
              {
LABEL_22:
                v16 = 0;
                goto LABEL_23;
              }
              if (gost_key_unwrap_crypto_pro(v26))
              {
                v16 = 1;
LABEL_23:
                EVP_PKEY_free(v13);
                GOST_KEY_TRANSPORT_free(v12);
                return v16;
              }
              v14 = 108;
              v15 = 438;
            }
            else
            {
              v14 = 68;
              v15 = 431;
            }
          }
          else
          {
            v14 = 137;
            v15 = 426;
          }
        }
        else
        {
          v14 = 103;
          v15 = 421;
        }
      }
      else
      {
        v14 = 116;
        v15 = 414;
      }
LABEL_21:
      ERR_put_error(50, 4095, v14, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/gost/gostr341001_pmeth.c", v15);
      goto LABEL_22;
    }
    ERR_put_error(50, 4095, 109, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/gost/gostr341001_pmeth.c", 393);
    return 0xFFFFFFFFLL;
  }
  else
  {
    *a3 = 32;
    return 1;
  }
}

uint64_t gost01_VKO_key(uint64_t a1, uint64_t a2, unsigned __int8 *a3, void *a4)
{
  BN_CTX *v8;
  BN_CTX *v9;
  BIGNUM *v10;
  BIGNUM *v11;
  BIGNUM *v12;
  const BIGNUM *v13;
  BIGNUM *v14;
  const BIGNUM *v15;
  int digest;
  uint64_t v17;
  size_t v19;
  char __src[32];
  _BYTE v21[32];
  _QWORD v22[9];

  v22[8] = *MEMORY[0x24BDAC8D0];
  v8 = BN_CTX_new();
  if (!v8)
    return 0;
  v9 = v8;
  BN_CTX_start(v8);
  v10 = BN_CTX_get(v9);
  if (v10)
  {
    v11 = v10;
    v12 = BN_CTX_get(v9);
    if (v12)
    {
      v13 = v12;
      v14 = BN_CTX_get(v9);
      if (v14)
      {
        v15 = v14;
        GOST_le2bn(a3, 8uLL, v11);
        digest = GOST_KEY_get_digest(*(_QWORD *)(a2 + 32));
        if (VKO_compute_key((uint64_t)v13, (uint64_t)v15, *(_QWORD *)(a1 + 32), *(_QWORD *)(a2 + 32), v11))
        {
          switch(digest)
          {
            case 942:
              GOST_bn2le(v13, (uint64_t)__src, 64);
              GOST_bn2le(v15, (uint64_t)v22, 64);
              v19 = 128;
              break;
            case 941:
              GOST_bn2le(v13, (uint64_t)__src, 32);
              GOST_bn2le(v15, (uint64_t)v21, 32);
              v19 = 64;
              break;
            case 822:
              GOST_bn2le(v13, (uint64_t)__src, 32);
              GOST_bn2le(v15, (uint64_t)v21, 32);
              GOSTR341194((uint64_t)__src);
              goto LABEL_17;
            default:
              v17 = 4294967294;
              goto LABEL_11;
          }
          STREEBOG256(__src, v19, a4);
LABEL_17:
          v17 = 1;
          goto LABEL_11;
        }
      }
    }
  }
  v17 = 0;
LABEL_11:
  BN_CTX_end(v9);
  BN_CTX_free(v9);
  return v17;
}

uint64_t pkey_gost01_derive(uint64_t a1, void *a2, _QWORD *a3)
{
  uint64_t v6;
  uint64_t v7;
  unsigned __int8 *v8;
  uint64_t result;

  v6 = EVP_PKEY_CTX_get0_pkey(a1);
  v7 = EVP_PKEY_CTX_get0_peerkey(a1);
  v8 = *(unsigned __int8 **)(EVP_PKEY_CTX_get_data(a1) + 16);
  if (!v8)
  {
    ERR_put_error(50, 4095, 123, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/gost/gostr341001_pmeth.c", 462);
    return 0;
  }
  if (a2)
  {
    if ((int)gost01_VKO_key(v7, v6, v8, a2) >= 1)
    {
      *a3 = 32;
      return 1;
    }
    return 0;
  }
  result = 32;
  *a3 = 32;
  return result;
}

uint64_t pkey_gost01_encrypt(uint64_t *a1, uint64_t a2, _QWORD *a3)
{
  uint64_t v4;
  EVP_PKEY *v6;
  uint64_t data;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  int v11;
  EVP_PKEY *v12;
  char *v13;
  char *v14;
  int v15;
  ASN1_VALUE *v16;
  ASN1_VALUE *v17;
  uint64_t v18;
  _BOOL8 v19;
  EVP_PKEY *v21;
  unsigned __int8 **v22;
  int v23;
  uint64_t v24;
  unsigned __int8 v25[32];
  unsigned __int8 v26[4];
  _BYTE v27[32];
  _QWORD __buf[2];

  v4 = a2;
  __buf[1] = *MEMORY[0x24BDAC8D0];
  v24 = a2;
  v6 = (EVP_PKEY *)EVP_PKEY_CTX_get0_pkey((uint64_t)a1);
  data = EVP_PKEY_CTX_get_data((uint64_t)a1);
  v8 = EVP_PKEY_CTX_get0_peerkey((uint64_t)a1);
  v9 = v8;
  v10 = *(_QWORD **)(data + 16);
  if (v10)
  {
    __buf[0] = *v10;
    if (v8)
      goto LABEL_3;
  }
  else
  {
    arc4random_buf(__buf, 8uLL);
    if (v9)
    {
LABEL_3:
      if (!GOST_KEY_get0_private_key(*(_QWORD *)(v9 + 32)))
      {
        ERR_put_error(50, 4095, 117, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/gost/gostr341001_pmeth.c", 500);
        v16 = 0;
LABEL_30:
        GOST_KEY_TRANSPORT_free(v16);
        return 0xFFFFFFFFLL;
      }
      v11 = 0;
      v12 = (EVP_PKEY *)v9;
      if (!v4)
        goto LABEL_17;
      goto LABEL_5;
    }
  }
  if (!v4)
  {
    v12 = 0;
    v11 = 1;
    goto LABEL_17;
  }
  v12 = EVP_PKEY_new();
  if (!v12 || (v13 = (char *)GOST_KEY_new()) == 0)
  {
LABEL_28:
    v16 = 0;
    goto LABEL_29;
  }
  v14 = v13;
  v15 = EVP_PKEY_base_id(&v6->type);
  if (!EVP_PKEY_assign(v12, v15, v14))
  {
    GOST_KEY_free((uint64_t)v14);
    goto LABEL_28;
  }
  if (!EVP_PKEY_copy_parameters(v12, v6) || !gost2001_keygen((const EC_GROUP **)v12->attributes))
    goto LABEL_28;
  v11 = 1;
LABEL_5:
  if ((int)gost01_VKO_key((uint64_t)v6, (uint64_t)v12, (unsigned __int8 *)__buf, v27) < 1)
  {
    v16 = 0;
    goto LABEL_25;
  }
  gost_key_wrap_crypto_pro(824);
LABEL_17:
  v17 = GOST_KEY_TRANSPORT_new();
  v16 = v17;
  if (!v17
    || !ASN1_OCTET_STRING_set(*(ASN1_OCTET_STRING **)(*((_QWORD *)v17 + 1) + 16), (const unsigned __int8 *)__buf, 8)
    || !ASN1_OCTET_STRING_set(*(ASN1_OCTET_STRING **)(*(_QWORD *)v16 + 8), v26, 4)
    || !ASN1_OCTET_STRING_set(**(ASN1_OCTET_STRING ***)v16, v25, 32))
  {
LABEL_25:
    if (!v11)
      goto LABEL_30;
    goto LABEL_29;
  }
  v18 = *((_QWORD *)v16 + 1);
  if (!v9)
  {
    if (v4)
      v21 = v12;
    else
      v21 = v6;
    if (X509_PUBKEY_set((X509_PUBKEY **)(v18 + 8), v21))
    {
      ASN1_OBJECT_free(**((ASN1_OBJECT ***)v16 + 1));
      **((_QWORD **)v16 + 1) = OBJ_nid2obj(824);
      EVP_PKEY_free(v12);
      v4 = v24;
      goto LABEL_37;
    }
    ERR_put_error(50, 4095, 106, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/gost/gostr341001_pmeth.c", 547);
LABEL_29:
    EVP_PKEY_free(v12);
    goto LABEL_30;
  }
  ASN1_OBJECT_free(*(ASN1_OBJECT **)v18);
  **((_QWORD **)v16 + 1) = OBJ_nid2obj(824);
  if ((int)EVP_PKEY_CTX_ctrl(a1, -1, -1) <= 0)
  {
    ERR_put_error(50, 4095, 107, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/gost/gostr341001_pmeth.c", 559);
    goto LABEL_30;
  }
LABEL_37:
  if (v4)
    v22 = (unsigned __int8 **)&v24;
  else
    v22 = 0;
  v23 = i2d_GOST_KEY_TRANSPORT(v16, v22);
  *a3 = v23;
  v19 = v23 != 0;
  GOST_KEY_TRANSPORT_free(v16);
  return v19;
}

uint64_t pkey_gost01_init(uint64_t a1)
{
  uint64_t v2;
  uint64_t result;
  _DWORD *v4;
  uint64_t v5;
  const EC_GROUP *v6;

  v2 = EVP_PKEY_CTX_get0_pkey(a1);
  result = (uint64_t)malloc_type_calloc(1uLL, 0x20uLL, 0x103004075AECAACuLL);
  if (result)
  {
    v4 = (_DWORD *)result;
    if (v2)
    {
      v5 = *(_QWORD *)(v2 + 32);
      if (v5)
      {
        v6 = (const EC_GROUP *)GOST_KEY_get0_group(v5);
        *v4 = EC_GROUP_get_curve_name(v6);
        v4[1] = GOST_KEY_get_digest(*(_QWORD *)(v2 + 32));
      }
    }
    EVP_PKEY_CTX_set_data(a1, (uint64_t)v4);
    return 1;
  }
  return result;
}

uint64_t pkey_gost01_copy(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  _OWORD *data;
  _OWORD *v6;
  __int128 v7;

  result = pkey_gost01_init(a1);
  if ((_DWORD)result)
  {
    data = (_OWORD *)EVP_PKEY_CTX_get_data(a2);
    v6 = (_OWORD *)EVP_PKEY_CTX_get_data(a1);
    v7 = data[1];
    *v6 = *data;
    v6[1] = v7;
    if (*((_QWORD *)data + 2))
      *((_QWORD *)v6 + 2) = 0;
    return 1;
  }
  return result;
}

void pkey_gost01_cleanup(uint64_t a1)
{
  uint64_t data;
  void *v2;

  data = EVP_PKEY_CTX_get_data(a1);
  if (data)
  {
    v2 = (void *)data;
    free(*(void **)(data + 16));
    free(v2);
  }
}

uint64_t pkey_gost01_paramgen(uint64_t a1, EVP_PKEY *a2)
{
  int *data;
  EC_GROUP *v4;
  const EC_GROUP *v5;
  char *v6;
  char *v7;
  uint64_t v8;

  data = (int *)EVP_PKEY_CTX_get_data(a1);
  if (*data && data[1])
  {
    v4 = EC_GROUP_new_by_curve_name(*data);
    v5 = v4;
    if (v4)
    {
      EC_GROUP_set_asn1_flag(v4, 1);
      v6 = (char *)GOST_KEY_new();
      v7 = v6;
      if (v6)
      {
        if (GOST_KEY_set_digest((uint64_t)v6, data[1]))
        {
          if (GOST_KEY_set_group((EC_GROUP **)v7, v5))
          {
            v8 = EVP_PKEY_assign(a2, 811, v7);
            if ((_DWORD)v8)
              goto LABEL_12;
          }
        }
      }
    }
    else
    {
      v7 = 0;
    }
    GOST_KEY_free((uint64_t)v7);
    v8 = 0;
LABEL_12:
    EC_GROUP_free(v5);
    return v8;
  }
  ERR_put_error(50, 4095, 115, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/gost/gostr341001_pmeth.c", 197);
  return 0;
}

uint64_t pkey_gost01_keygen(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  result = pkey_gost01_paramgen(a1, (EVP_PKEY *)a2);
  if ((_DWORD)result)
    return gost2001_keygen(*(const EC_GROUP ***)(a2 + 32)) != 0;
  return result;
}

uint64_t pkey_gost01_sign(uint64_t a1, void *a2, uint64_t a3, unsigned __int8 *a4, unint64_t a5)
{
  uint64_t v10;
  uint64_t data;
  uint64_t v12;
  BIGNUM *v13;
  BIGNUM *size;
  int v15;
  int v16;
  int v17;
  BIGNUM *v18;
  BIGNUM *v19;
  ECDSA_SIG *v20;
  int v21;

  v10 = EVP_PKEY_CTX_get0_pkey(a1);
  data = EVP_PKEY_CTX_get_data(a1);
  if (!v10)
    return 0;
  v12 = data;
  v13 = *(BIGNUM **)(v10 + 32);
  if (!v13)
    return 0;
  size = GOST_KEY_get_size(v13);
  if (a3)
  {
    v15 = (int)size;
    if (a2)
    {
      if (*(_QWORD *)a3 < (unint64_t)(2 * (_QWORD)size))
      {
        v16 = 100;
        v17 = 253;
LABEL_17:
        ERR_put_error(50, 4095, v16, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/gost/gostr341001_pmeth.c", v17);
        return 0;
      }
      if (a5 != 32 && a5 != 64)
      {
        v16 = 136;
        v17 = 257;
        goto LABEL_17;
      }
      v18 = GOST_le2bn(a4, a5, 0);
      if (!v18)
        return 0;
      v19 = v18;
      v20 = gost2001_do_sign(v18, *(_QWORD *)(v10 + 32));
      BN_free(v19);
      if (!v20)
        return 0;
      v21 = *(_DWORD *)(v12 + 28);
      if (v21)
      {
        if (v21 == 1)
        {
          pack_signature_le(v20, v15, a2, (size_t *)a3);
          return 1;
        }
        a3 = 0xFFFFFFFFLL;
      }
      else
      {
        if (pack_signature_cp(v20, v15, a2, (size_t *)a3))
          return 1;
        a3 = 0;
      }
      ECDSA_SIG_free(v20);
      return a3;
    }
    *(_QWORD *)a3 = 2 * (_QWORD)size;
    return 1;
  }
  return a3;
}

uint64_t pkey_gost01_verify(uint64_t a1, unsigned __int8 *a2, unint64_t a3, unsigned __int8 *a4, unint64_t a5)
{
  uint64_t v10;
  uint64_t data;
  int v12;
  ECDSA_SIG *v13;
  ECDSA_SIG *v14;
  ECDSA_SIG *v15;
  BIGNUM *v16;
  BIGNUM *v17;
  uint64_t v18;
  int v19;

  v10 = EVP_PKEY_CTX_get0_pkey(a1);
  data = EVP_PKEY_CTX_get_data(a1);
  if (!v10)
    return 0;
  v12 = *(_DWORD *)(data + 28);
  if (v12 == 1)
  {
    v15 = ECDSA_SIG_new();
    if (v15)
    {
      v14 = v15;
      GOST_le2bn(a2, a3 >> 1, v15->r);
      GOST_le2bn(&a2[a3 >> 1], a3 >> 1, v14->s);
      goto LABEL_8;
    }
    v19 = 110;
    goto LABEL_14;
  }
  if (v12)
    return 0;
  v13 = ECDSA_SIG_new();
  if (!v13)
  {
    v19 = 77;
LABEL_14:
    ERR_put_error(50, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/gost/gostr341001_pmeth.c", v19);
    return 0;
  }
  v14 = v13;
  BN_bin2bn(a2, a3 >> 1, v13->s);
  BN_bin2bn(&a2[a3 >> 1], a3 >> 1, v14->r);
LABEL_8:
  v16 = GOST_le2bn(a4, a5, 0);
  v17 = v16;
  if (v16)
    v18 = gost2001_do_verify(v16, (uint64_t *)v14, *(_QWORD *)(v10 + 32));
  else
    v18 = 0;
  BN_free(v17);
  ECDSA_SIG_free(v14);
  return v18;
}

uint64_t pkey_gost01_ctrl(uint64_t a1, int a2, unsigned int a3, EVP_MD *a4)
{
  uint64_t data;
  uint64_t result;
  int v9;
  void *v10;
  void *v11;
  int v12;
  int v13;

  data = EVP_PKEY_CTX_get_data(a1);
  result = 1;
  switch(a2)
  {
    case 1:
      v9 = EVP_MD_type(a4);
      if (v9 == GostR3410_get_md_digest(*(unsigned int *)(data + 4)))
      {
        *(_QWORD *)(data + 8) = a4;
        goto LABEL_17;
      }
      v12 = 100;
      v13 = 585;
      goto LABEL_20;
    case 2:
      if (a3 < 2)
        return result;
      if (a3 == 3)
      {
        *(_DWORD *)(data + 24) = 1;
      }
      else if (a3 == 2)
      {
        result = *(unsigned int *)(data + 24);
      }
      else
      {
LABEL_10:
        result = 4294967294;
      }
      break;
    case 3:
    case 4:
    case 5:
    case 7:
      return result;
    case 6:
      goto LABEL_10;
    case 8:
      v10 = malloc_type_malloc((int)a3, 0xB322FC91uLL);
      if (v10)
      {
        v11 = v10;
        memcpy(v10, a4, (int)a3);
        free(*(void **)(data + 16));
        *(_QWORD *)(data + 16) = v11;
LABEL_17:
        result = 1;
      }
      else
      {
        v12 = 65;
        v13 = 605;
LABEL_20:
        ERR_put_error(50, 4095, v12, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/gost/gostr341001_pmeth.c", v13);
LABEL_21:
        result = 0;
      }
      break;
    default:
      switch(a2)
      {
        case 4097:
          *(_DWORD *)data = a3;
          goto LABEL_17;
        case 4098:
          if (a3 > 1)
            goto LABEL_21;
          *(_DWORD *)(data + 28) = a3;
          break;
        case 4099:
          *(_DWORD *)(data + 4) = a3;
          goto LABEL_17;
        case 4100:
          a4->type = *(_DWORD *)(data + 4);
          goto LABEL_17;
        default:
          goto LABEL_10;
      }
      goto LABEL_17;
  }
  return result;
}

uint64_t pkey_gost01_ctrl_str(uint64_t a1, char *__s1, char *a3)
{
  uint64_t result;
  int v7;
  int v8;
  int v9;

  if (strcmp(__s1, "paramset"))
  {
    if (strcmp(__s1, "dgst"))
      return 4294967294;
    if (!a3)
      return 0;
    if (!strcmp(a3, "gost94") || !strcmp(a3, "md_gost94"))
    {
      v9 = 822;
    }
    else if (!strcmp(a3, "streebog256"))
    {
      v9 = 941;
    }
    else
    {
      if (strcmp(a3, "streebog512"))
        return 0;
      v9 = 942;
    }
    *(_DWORD *)(EVP_PKEY_CTX_get_data(a1) + 4) = v9;
    return 1;
  }
  if (!a3)
    return 0;
  if (*(_DWORD *)(EVP_PKEY_CTX_get_data(a1) + 4) == 942)
    v7 = GostR3410_512_param_id(a3);
  else
    v7 = GostR3410_256_param_id(a3);
  v8 = v7;
  if (v7 || (result = OBJ_txt2nid(a3), (v8 = result) != 0))
  {
    *(_DWORD *)EVP_PKEY_CTX_get_data(a1) = v8;
    return 1;
  }
  return result;
}

uint64_t pack_signature_cp(ECDSA_SIG *a1, int a2, void *a3, size_t *a4)
{
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  size_t v16;

  v8 = BN_num_bits(a1->r);
  v9 = v8 + 7;
  if (v8 < -7)
    v9 = v8 + 14;
  v10 = v9 >> 3;
  v11 = BN_num_bits(a1->s);
  v12 = v11 + 7;
  if (v11 < -7)
    v12 = v11 + 14;
  v13 = v12 >> 3;
  if (v10 > a2 || v13 > a2)
    return 0;
  v16 = 2 * a2;
  *a4 = v16;
  bzero(a3, v16);
  BN_bn2bin(a1->s, (unsigned __int8 *)a3 + a2 - v13);
  BN_bn2bin(a1->r, (unsigned __int8 *)a3 + 2 * a2 - v10);
  ECDSA_SIG_free(a1);
  return 1;
}

void pack_signature_le(ECDSA_SIG *a1, int a2, void *a3, size_t *a4)
{
  size_t v7;

  v7 = 2 * a2;
  *a4 = v7;
  bzero(a3, v7);
  GOST_bn2le(a1->r, (uint64_t)a3, a2);
  GOST_bn2le(a1->s, (uint64_t)a3 + a2, a2);
  ECDSA_SIG_free(a1);
}

const DSA_METHOD *DSA_OpenSSL(void)
{
  return (const DSA_METHOD *)&openssl_dsa_meth;
}

DSA_SIG *DSA_SIG_new(void)
{
  return (DSA_SIG *)malloc_type_calloc(1uLL, 0x10uLL, 0x20040A4A59CD2uLL);
}

void DSA_SIG_free(DSA_SIG *a)
{
  if (a)
  {
    BN_free(a->r);
    BN_free(a->s);
    free(a);
  }
}

int DSA_sign_setup(DSA *dsa, BN_CTX *ctx_in, BIGNUM **kinvp, BIGNUM **rp)
{
  return (*(uint64_t (**)(void))&dsa->ex_data.sk->sorted)();
}

DSA_SIG *__cdecl DSA_do_sign(const unsigned __int8 *dgst, int dlen, DSA *dsa)
{
  return (DSA_SIG *)((uint64_t (*)(const unsigned __int8 *, _QWORD))dsa->ex_data.sk->data)(dgst, *(_QWORD *)&dlen);
}

int DSA_do_verify(const unsigned __int8 *dgst, int dgst_len, DSA_SIG *sig, DSA *dsa)
{
  return ((uint64_t (*)(const unsigned __int8 *, _QWORD, DSA_SIG *))dsa->ex_data.sk->comp)(dgst, *(_QWORD *)&dgst_len, sig);
}

_QWORD *dsa_do_sign(const unsigned __int8 *a1, int a2, uint64_t a3)
{
  BIGNUM *v6;
  BN_CTX *v7;
  BN_CTX *v8;
  BIGNUM *v9;
  BIGNUM *v10;
  BIGNUM *v11;
  BIGNUM *v12;
  BIGNUM *v13;
  BIGNUM *v14;
  BIGNUM *v15;
  BIGNUM *v16;
  BIGNUM *v17;
  BIGNUM *v18;
  int v19;
  int v20;
  int v21;
  int v22;
  int v23;
  BIGNUM *v24;
  int v25;
  BIGNUM *v26;
  int v27;
  _QWORD *v28;
  _QWORD *v30;
  BIGNUM *b;
  BIGNUM *a;

  b = 0;
  a = 0;
  if (dsa_check_key(a3))
  {
    v6 = BN_new();
    if (v6)
    {
      v7 = BN_CTX_new();
      v8 = v7;
      if (v7)
      {
        BN_CTX_start(v7);
        v9 = BN_CTX_get(v8);
        if (v9)
        {
          v10 = v9;
          v11 = BN_CTX_get(v8);
          if (v11)
          {
            v12 = v11;
            v13 = BN_CTX_get(v8);
            if (v13)
            {
              v14 = v13;
              v15 = BN_CTX_get(v8);
              if (v15)
              {
                v16 = v15;
                v17 = BN_CTX_get(v8);
                if (v17)
                {
                  v18 = v17;
                  v19 = BN_num_bits(*(const BIGNUM **)(a3 + 24));
                  v20 = v19 + 7;
                  if (v19 < -7)
                    v20 = v19 + 14;
                  if (a2 > v20 >> 3)
                  {
                    v21 = BN_num_bits(*(const BIGNUM **)(a3 + 24));
                    v22 = v21 + 7;
                    if (v21 < -7)
                      v22 = v21 + 14;
                    a2 = v22 >> 3;
                  }
                  if (BN_bin2bn(a1, a2, v18))
                  {
                    v23 = 33;
                    while (1)
                    {
                      v24 = *(BIGNUM **)(a3 + 56);
                      if (v24 && *(_QWORD *)(a3 + 64))
                      {
                        v25 = 0;
                        b = *(BIGNUM **)(a3 + 64);
                        a = v24;
                        *(_QWORD *)(a3 + 56) = 0;
                        *(_QWORD *)(a3 + 64) = 0;
                      }
                      else
                      {
                        if (!(*(unsigned int (**)(uint64_t, BN_CTX *, BIGNUM **, BIGNUM **))(*(_QWORD *)(a3 + 104) + 16))(a3, v8, &a, &b))break;
                        v25 = 1;
                      }
                      v26 = (BIGNUM *)BN_value_one();
                      if (!bn_rand_interval(v10, v26, *(BIGNUM **)(a3 + 24))
                        || !BN_mod_inverse_ct(v12, v10, *(const BIGNUM **)(a3 + 24), v8)
                        || !BN_mod_mul(v16, v10, *(const BIGNUM **)(a3 + 48), *(const BIGNUM **)(a3 + 24), v8)
                        || !BN_mod_mul(v16, v16, b, *(const BIGNUM **)(a3 + 24), v8)
                        || !BN_mod_mul(v14, v10, v18, *(const BIGNUM **)(a3 + 24), v8)
                        || !BN_mod_add(v6, v16, v14, *(const BIGNUM **)(a3 + 24), v8)
                        || !BN_mod_mul(v6, v6, a, *(const BIGNUM **)(a3 + 24), v8)
                        || !BN_mod_mul(v6, v6, v12, *(const BIGNUM **)(a3 + 24), v8))
                      {
                        break;
                      }
                      if (!BN_is_zero((uint64_t)b) && !BN_is_zero((uint64_t)v6))
                      {
                        v30 = malloc_type_calloc(1uLL, 0x10uLL, 0x20040A4A59CD2uLL);
                        if (v30)
                        {
                          v28 = v30;
                          *v30 = b;
                          v30[1] = v6;
                          goto LABEL_39;
                        }
                        v27 = 65;
                        goto LABEL_38;
                      }
                      if (!v25)
                      {
                        v27 = 110;
                        goto LABEL_38;
                      }
                      v27 = 112;
                      if (!--v23)
                        goto LABEL_38;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    else
    {
      v8 = 0;
    }
    v27 = 3;
  }
  else
  {
    v6 = 0;
    v8 = 0;
    v27 = 112;
  }
LABEL_38:
  ERR_put_error(10, 4095, v27, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/dsa/dsa_ossl.c", 217);
  BN_free(b);
  BN_free(v6);
  v28 = 0;
LABEL_39:
  BN_CTX_end(v8);
  BN_CTX_free(v8);
  BN_free(a);
  return v28;
}

uint64_t dsa_sign_setup(uint64_t a1, BN_CTX *a2, BIGNUM **a3, BIGNUM **a4)
{
  BIGNUM *v8;
  BN_CTX *v9;
  BIGNUM *v10;
  BIGNUM *v11;
  BIGNUM *v12;
  BIGNUM *v13;
  BIGNUM *v14;
  BIGNUM *v15;
  int v16;
  BIGNUM *v17;
  const BIGNUM *v18;
  unsigned int (*v19)(uint64_t, BIGNUM *, _QWORD, BIGNUM *, _QWORD, BN_CTX *, _QWORD);
  uint64_t v20;
  BIGNUM *v22;
  BIGNUM *v23;

  if (!dsa_check_key(a1))
  {
    v8 = 0;
    goto LABEL_24;
  }
  v8 = BN_new();
  if (!v8)
  {
LABEL_24:
    v9 = 0;
    goto LABEL_25;
  }
  v9 = a2;
  if (!a2)
  {
    v9 = BN_CTX_new();
    if (!v9)
      goto LABEL_25;
  }
  BN_CTX_start(v9);
  v10 = BN_CTX_get(v9);
  if (!v10)
    goto LABEL_25;
  v11 = v10;
  v12 = BN_CTX_get(v9);
  if (!v12)
    goto LABEL_25;
  v13 = v12;
  v14 = BN_CTX_get(v9);
  if (!v14)
    goto LABEL_25;
  v15 = v14;
  v16 = BN_num_bits(*(const BIGNUM **)(a1 + 24));
  if (!BN_set_bit(v11, v16))
    goto LABEL_25;
  if (!BN_set_bit(v13, v16))
    goto LABEL_25;
  if (!BN_set_bit(v15, v16))
    goto LABEL_25;
  v17 = (BIGNUM *)BN_value_one();
  if (!bn_rand_interval(v11, v17, *(BIGNUM **)(a1 + 24)))
    goto LABEL_25;
  BN_set_flags((uint64_t)v11, 4);
  if ((*(_BYTE *)(a1 + 72) & 1) != 0
    && !BN_MONT_CTX_set_locked((BN_MONT_CTX **)(a1 + 80), 8, *(const BIGNUM **)(a1 + 16), v9))
  {
    goto LABEL_25;
  }
  if (!BN_add(v13, v11, *(const BIGNUM **)(a1 + 24)) || !BN_add(v15, v13, *(const BIGNUM **)(a1 + 24)))
    goto LABEL_25;
  v18 = BN_num_bits(v13) <= v16 ? v15 : v13;
  if (!bn_copy(v11, v18))
    goto LABEL_25;
  v19 = *(unsigned int (**)(uint64_t, BIGNUM *, _QWORD, BIGNUM *, _QWORD, BN_CTX *, _QWORD))(*(_QWORD *)(a1 + 104) + 40);
  if (!v19)
  {
    if (BN_mod_exp_mont_ct(v8, *(const BIGNUM **)(a1 + 32), v11, *(const BIGNUM **)(a1 + 16), v9, *(BN_MONT_CTX **)(a1 + 80)))
    {
      goto LABEL_30;
    }
LABEL_25:
    ERR_put_error(10, 4095, 3, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/dsa/dsa_ossl.c", 322);
    BN_free(v8);
    v20 = 0;
    goto LABEL_26;
  }
  if (!v19(a1, v8, *(_QWORD *)(a1 + 32), v11, *(_QWORD *)(a1 + 16), v9, *(_QWORD *)(a1 + 80)))
    goto LABEL_25;
LABEL_30:
  if (!BN_mod_ct(v8, v8, *(const BIGNUM **)(a1 + 24), v9))
    goto LABEL_25;
  v22 = BN_mod_inverse_ct(0, v11, *(const BIGNUM **)(a1 + 24), v9);
  if (!v22)
    goto LABEL_25;
  v23 = v22;
  BN_free(*a3);
  *a3 = v23;
  BN_free(*a4);
  *a4 = v8;
  v20 = 1;
LABEL_26:
  BN_CTX_end(v9);
  if (v9 != a2)
    BN_CTX_free(v9);
  return v20;
}

uint64_t dsa_do_verify(const unsigned __int8 *a1, int a2, const BIGNUM **a3, uint64_t a4)
{
  BN_CTX *v8;
  BN_CTX *v9;
  BIGNUM *v10;
  BIGNUM *v11;
  BIGNUM *v12;
  BIGNUM *v13;
  BIGNUM *v14;
  BIGNUM *v15;
  uint64_t v16;
  int v18;
  int v19;
  BN_MONT_CTX *v20;
  unsigned int (*v21)(uint64_t, BIGNUM *, _QWORD, BIGNUM *, _QWORD, BIGNUM *, _QWORD, BN_CTX *, BN_MONT_CTX *);

  if (!dsa_check_key(a4))
  {
    v9 = 0;
    goto LABEL_14;
  }
  v8 = BN_CTX_new();
  v9 = v8;
  if (!v8)
    goto LABEL_14;
  BN_CTX_start(v8);
  v10 = BN_CTX_get(v9);
  if (!v10)
    goto LABEL_14;
  v11 = v10;
  v12 = BN_CTX_get(v9);
  if (!v12)
    goto LABEL_14;
  v13 = v12;
  v14 = BN_CTX_get(v9);
  if (!v14)
    goto LABEL_14;
  v15 = v14;
  if (!BN_is_zero((uint64_t)*a3)
    && !BN_is_negative((uint64_t)*a3)
    && BN_ucmp(*a3, *(const BIGNUM **)(a4 + 24)) < 0
    && !BN_is_zero((uint64_t)a3[1])
    && !BN_is_negative((uint64_t)a3[1])
    && BN_ucmp(a3[1], *(const BIGNUM **)(a4 + 24)) < 0)
  {
    if (!BN_mod_inverse_ct(v13, a3[1], *(const BIGNUM **)(a4 + 24), v9))
      goto LABEL_14;
    v18 = BN_num_bits(*(const BIGNUM **)(a4 + 24)) >> 3;
    v19 = v18 >= a2 ? a2 : v18;
    if (!BN_bin2bn(a1, v19, v11)
      || !BN_mod_mul(v11, v11, v13, *(const BIGNUM **)(a4 + 24), v9)
      || !BN_mod_mul(v13, *a3, v13, *(const BIGNUM **)(a4 + 24), v9))
    {
      goto LABEL_14;
    }
    if ((*(_BYTE *)(a4 + 72) & 1) != 0)
    {
      v20 = BN_MONT_CTX_set_locked((BN_MONT_CTX **)(a4 + 80), 8, *(const BIGNUM **)(a4 + 16), v9);
      if (!v20)
        goto LABEL_14;
    }
    else
    {
      v20 = 0;
    }
    v21 = *(unsigned int (**)(uint64_t, BIGNUM *, _QWORD, BIGNUM *, _QWORD, BIGNUM *, _QWORD, BN_CTX *, BN_MONT_CTX *))(*(_QWORD *)(a4 + 104) + 32);
    if (v21)
    {
      if (!v21(a4, v15, *(_QWORD *)(a4 + 32), v11, *(_QWORD *)(a4 + 40), v13, *(_QWORD *)(a4 + 16), v9, v20))
        goto LABEL_14;
LABEL_30:
      if (BN_mod_ct(v11, v15, *(const BIGNUM **)(a4 + 24), v9))
      {
        v16 = BN_ucmp(v11, *a3) == 0;
        goto LABEL_15;
      }
      goto LABEL_14;
    }
    if (BN_mod_exp2_mont(v15, *(const BIGNUM **)(a4 + 32), v11, *(const BIGNUM **)(a4 + 40), v13, *(const BIGNUM **)(a4 + 16), v9, v20))
    {
      goto LABEL_30;
    }
LABEL_14:
    ERR_put_error(10, 4095, 3, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/dsa/dsa_ossl.c", 417);
    v16 = 0xFFFFFFFFLL;
    goto LABEL_15;
  }
  v16 = 0;
LABEL_15:
  BN_CTX_end(v9);
  BN_CTX_free(v9);
  return v16;
}

uint64_t dsa_init(uint64_t a1)
{
  *(_DWORD *)(a1 + 72) |= 1u;
  return 1;
}

uint64_t dsa_finish(uint64_t a1)
{
  BN_MONT_CTX_free(*(BN_MONT_CTX **)(a1 + 80));
  return 1;
}

STACK *i2v_AUTHORITY_KEYID(uint64_t a1, int **a2, STACK *a3)
{
  STACK *v4;
  STACK *result;
  char *v6;
  GENERAL_NAMES *v7;
  unsigned __int8 **v8;
  STACK *extlist;

  extlist = a3;
  if (a3)
  {
    v4 = 0;
  }
  else
  {
    result = sk_new_null();
    v4 = result;
    extlist = result;
    if (!result)
      return result;
  }
  if (*a2)
  {
    v6 = hex_to_string(*((unsigned __int8 **)*a2 + 1), **a2);
    if (!v6 || !X509V3_add_value("keyid", v6, &extlist))
      goto LABEL_17;
    free(v6);
  }
  v7 = (GENERAL_NAMES *)a2[1];
  if (!v7 || (extlist = i2v_GENERAL_NAMES(0, v7, extlist)) != 0)
  {
    v8 = (unsigned __int8 **)a2[2];
    if (v8)
    {
      v6 = hex_to_string(v8[1], *(int *)v8);
      if (!v6 || !X509V3_add_value("serial", v6, &extlist))
        goto LABEL_17;
      free(v6);
    }
    if (sk_num(extlist) >= 1)
      return extlist;
  }
  v6 = 0;
LABEL_17:
  free(v6);
  sk_pop_free(v4, (void (__cdecl *)(void *))X509V3_conf_free);
  return 0;
}

AUTHORITY_KEYID *v2i_AUTHORITY_KEYID(int a1, uint64_t a2, STACK *a3)
{
  int v4;
  char v5;
  char v6;
  char *v7;
  const char *v8;
  const char *v9;
  const char *v10;
  X509 *v11;
  int ext_by_NID;
  X509_EXTENSION *ext;
  ASN1_OCTET_STRING *v14;
  AUTHORITY_KEYID *result;
  int v16;
  int v17;
  _BOOL4 v18;
  ASN1_INTEGER *v19;
  STACK *v20;
  X509_NAME *v21;
  GENERAL_NAME *v22;
  AUTHORITY_KEYID *v23;
  X509_NAME *issuer_name;
  ASN1_INTEGER *serialNumber;
  ASN1_INTEGER *v26;

  if (sk_num(a3) >= 1)
  {
    v4 = 0;
    v5 = 0;
    v6 = 0;
    while (1)
    {
      v7 = sk_value(a3, v4);
      v8 = (const char *)*((_QWORD *)v7 + 1);
      if (!strcmp(v8, "keyid"))
      {
        v10 = (const char *)*((_QWORD *)v7 + 2);
        if (v10)
        {
          if (!strcmp(v10, "always"))
            v6 = 2;
          else
            v6 = 1;
        }
        else
        {
          v6 = 1;
        }
      }
      else
      {
        if (strcmp(v8, "issuer"))
        {
          ERR_put_error(34, 4095, 120, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_akey.c", 175);
          ERR_asprintf_error_data("name=%s", *((const char **)v7 + 1));
          return 0;
        }
        v9 = (const char *)*((_QWORD *)v7 + 2);
        if (v9)
        {
          if (!strcmp(v9, "always"))
            v5 = 2;
          else
            v5 = 1;
        }
        else
        {
          v5 = 1;
        }
      }
      if (++v4 >= sk_num(a3))
        goto LABEL_18;
    }
  }
  v6 = 0;
  v5 = 0;
LABEL_18:
  if (a2)
  {
    v11 = *(X509 **)(a2 + 8);
    if (v11)
    {
      if (v6)
      {
        ext_by_NID = X509_get_ext_by_NID(*(X509 **)(a2 + 8), 82, -1);
        if (ext_by_NID < 0 || (ext = X509_get_ext(v11, ext_by_NID)) == 0)
          v14 = 0;
        else
          v14 = (ASN1_OCTET_STRING *)X509V3_EXT_d2i(ext);
        if (v6 == 2 && !v14)
        {
          v16 = 123;
          v17 = 195;
          goto LABEL_28;
        }
      }
      else
      {
        v14 = 0;
      }
      v18 = v5 != 0;
      if (v14)
        v18 = 0;
      if (v5 == 2 || v18)
      {
        issuer_name = X509_get_issuer_name(v11);
        v21 = X509_NAME_dup(issuer_name);
        serialNumber = X509_get_serialNumber(v11);
        v26 = ASN1_INTEGER_dup(serialNumber);
        v19 = v26;
        if (v21 && v26)
        {
          v23 = AUTHORITY_KEYID_new();
          if (v23)
          {
            v20 = sk_new_null();
            if (v20)
            {
              v22 = GENERAL_NAME_new();
              if (v22 && sk_push(v20, (char *)v22))
              {
                v22->type = 4;
                v22->d.ptr = (char *)v21;
                result = v23;
                goto LABEL_39;
              }
            }
            else
            {
              v22 = 0;
            }
            ERR_put_error(34, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_akey.c", 216);
          }
          else
          {
            v20 = 0;
            v22 = 0;
          }
        }
        else
        {
          ERR_put_error(34, 4095, 122, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_akey.c", 204);
          v20 = 0;
          v22 = 0;
          v23 = 0;
        }
      }
      else
      {
        result = AUTHORITY_KEYID_new();
        v19 = 0;
        v20 = 0;
        v21 = 0;
        v22 = 0;
        v23 = 0;
        if (result)
        {
LABEL_39:
          result->issuer = v20;
          result->serial = v19;
          result->keyid = v14;
          return result;
        }
      }
      AUTHORITY_KEYID_free(v23);
      GENERAL_NAME_free(v22);
      sk_free(v20);
      X509_NAME_free(v21);
      ASN1_INTEGER_free(v19);
      ASN1_OCTET_STRING_free(v14);
      return 0;
    }
    if (*(_DWORD *)a2 == 1)
      return AUTHORITY_KEYID_new();
  }
  v16 = 121;
  v17 = 184;
LABEL_28:
  ERR_put_error(34, 4095, v16, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_akey.c", v17);
  return 0;
}

void DES_cfb64_encrypt(const unsigned __int8 *in, unsigned __int8 *out, uint64_t length, DES_key_schedule *schedule, DES_cblock *ivec, int *num, int enc)
{
  uint64_t v10;
  int v13;
  int v14;
  char v15;
  unsigned __int8 v16;
  int v17;
  unsigned __int8 v18;
  unsigned __int8 v19;
  _QWORD v20[2];

  v10 = length;
  v20[1] = *MEMORY[0x24BDAC8D0];
  v13 = *num;
  if (enc)
  {
    if (length)
    {
      do
      {
        if (!v13)
        {
          v20[0] = *(_QWORD *)ivec;
          DES_encrypt1((unsigned int *)v20, schedule, 1);
          v14 = HIDWORD(v20[0]);
          *(_DWORD *)ivec = v20[0];
          *(_DWORD *)&(*ivec)[4] = v14;
        }
        v15 = *in++;
        v16 = (*ivec)[v13];
        *out++ = v16 ^ v15;
        (*ivec)[v13] = v16 ^ v15;
        v13 = (v13 + 1) & 7;
        --v10;
      }
      while (v10);
    }
  }
  else if (length)
  {
    do
    {
      if (!v13)
      {
        v20[0] = *(_QWORD *)ivec;
        DES_encrypt1((unsigned int *)v20, schedule, 1);
        v17 = HIDWORD(v20[0]);
        *(_DWORD *)ivec = v20[0];
        *(_DWORD *)&(*ivec)[4] = v17;
      }
      v18 = *in++;
      v19 = (*ivec)[v13];
      (*ivec)[v13] = v18;
      *out++ = v19 ^ v18;
      v13 = (v13 + 1) & 7;
      --v10;
    }
    while (v10);
  }
  *num = v13;
}

X509_REQ *__cdecl X509_to_X509_REQ(X509 *x, EVP_PKEY *pkey, const EVP_MD *md)
{
  X509_REQ *v6;
  X509_REQ *v7;
  X509_NAME *subject_name;
  EVP_PKEY *pubkey;
  EVP_PKEY *v10;
  int v11;

  v6 = X509_REQ_new();
  v7 = v6;
  if (!v6)
  {
    ERR_put_error(11, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_req.c", 85);
LABEL_10:
    X509_REQ_free(v7);
    return 0;
  }
  if (!X509_REQ_set_version(v6, 0))
    goto LABEL_10;
  subject_name = X509_get_subject_name(x);
  if (!X509_REQ_set_subject_name(v7, subject_name))
    goto LABEL_10;
  pubkey = X509_get_pubkey(x);
  if (!pubkey)
    goto LABEL_10;
  v10 = pubkey;
  v11 = X509_REQ_set_pubkey(v7, pubkey);
  EVP_PKEY_free(v10);
  if (!v11 || pkey && !X509_REQ_sign(v7, pkey, md))
    goto LABEL_10;
  return v7;
}

EVP_PKEY *__cdecl X509_REQ_get_pubkey(X509_REQ *req)
{
  if (req && req->req_info)
    return X509_PUBKEY_get(req->req_info->pubkey);
  else
    return 0;
}

EVP_PKEY *X509_REQ_get0_pubkey(uint64_t a1)
{
  if (a1 && *(_QWORD *)a1)
    return X509_PUBKEY_get0(*(_QWORD *)(*(_QWORD *)a1 + 40));
  else
    return 0;
}

int X509_REQ_check_private_key(X509_REQ *x509, EVP_PKEY *pkey)
{
  int v3;
  int v4;

  if (x509)
  {
    if (x509->req_info)
    {
      x509 = (X509_REQ *)X509_PUBKEY_get0((uint64_t)x509->req_info->pubkey);
      if (x509)
      {
        switch(EVP_PKEY_cmp((const EVP_PKEY *)x509, pkey))
        {
          case -2:
            if (pkey->type == 28)
            {
              v3 = 114;
              v4 = 162;
            }
            else if (pkey->type == 408)
            {
              v3 = 16;
              v4 = 155;
            }
            else
            {
              v3 = 117;
              v4 = 166;
            }
            goto LABEL_13;
          case -1:
            v3 = 115;
            v4 = 150;
            goto LABEL_13;
          case 0:
            v3 = 116;
            v4 = 147;
LABEL_13:
            ERR_put_error(11, 4095, v3, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_req.c", v4);
            goto LABEL_14;
          case 1:
            LODWORD(x509) = 1;
            return (int)x509;
          default:
            goto LABEL_14;
        }
      }
    }
    else
    {
LABEL_14:
      LODWORD(x509) = 0;
    }
  }
  return (int)x509;
}

int X509_REQ_extension_nid(int nid)
{
  int v1;
  int *v2;
  int v3;

  v1 = *ext_nids;
  if (!*ext_nids)
    return 0;
  v2 = ext_nids + 1;
  while (v1 != nid)
  {
    v3 = *v2++;
    v1 = v3;
    if (!v3)
      return 0;
  }
  return 1;
}

int *X509_REQ_get_extension_nids(void)
{
  return ext_nids;
}

void X509_REQ_set_extension_nids(int *nids)
{
  ext_nids = nids;
}

STACK *__cdecl X509_REQ_get_extensions(STACK *req)
{
  STACK *v1;
  BOOL v2;
  int v3;
  int *i;
  int attr_by_NID;
  int v6;
  X509_ATTRIBUTE *attr;
  ASN1_TYPE *v8;
  char *ptr;
  unsigned __int8 *in;

  if (req)
  {
    v1 = req;
    if (*(_QWORD *)&req->num)
      v2 = ext_nids == 0;
    else
      v2 = 1;
    if (!v2)
    {
      v3 = *ext_nids;
      if (!*ext_nids)
        return sk_new_null();
      for (i = ext_nids + 1; ; ++i)
      {
        attr_by_NID = X509at_get_attr_by_NID(*(const STACK **)(*(_QWORD *)&v1->num + 48), v3, -1);
        if (attr_by_NID != -1)
          break;
        v6 = *i;
        v3 = v6;
        if (!v6)
          return sk_new_null();
      }
      attr = X509at_get_attr(*(const STACK **)(*(_QWORD *)&v1->num + 48), attr_by_NID);
      v8 = X509_ATTRIBUTE_get0_type(attr, 0);
      if (!v8)
        return sk_new_null();
      if (v8->type == 16)
      {
        ptr = v8->value.ptr;
        in = (unsigned __int8 *)*((_QWORD *)ptr + 1);
        return d2i_X509_EXTENSIONS(0, (const unsigned __int8 **)&in, *(int *)ptr);
      }
    }
    return 0;
  }
  return req;
}

int X509_REQ_get_attr_by_NID(const X509_REQ *req, int nid, int lastpos)
{
  return X509at_get_attr_by_NID(req->req_info->attributes, nid, lastpos);
}

X509_ATTRIBUTE *__cdecl X509_REQ_get_attr(const X509_REQ *req, int loc)
{
  return X509at_get_attr(req->req_info->attributes, loc);
}

int X509_REQ_add_extensions_nid(X509_REQ *req, STACK *exts, int nid)
{
  int v5;
  _BOOL4 v6;
  unsigned __int8 *out;

  out = 0;
  v5 = i2d_X509_EXTENSIONS(exts, &out);
  if (v5 < 1)
    return 0;
  v6 = X509at_add1_attr_by_NID(&req->req_info->attributes, nid, 16, out, v5) != 0;
  free(out);
  return v6;
}

int X509_REQ_add1_attr_by_NID(X509_REQ *req, int nid, int type, const unsigned __int8 *bytes, int len)
{
  return X509at_add1_attr_by_NID(&req->req_info->attributes, nid, type, bytes, len) != 0;
}

int X509_REQ_add_extensions(X509_REQ *req, STACK *exts)
{
  return X509_REQ_add_extensions_nid(req, exts, 172);
}

int X509_REQ_get_attr_count(const X509_REQ *req)
{
  return X509at_get_attr_count(req->req_info->attributes);
}

int X509_REQ_get_attr_by_OBJ(const X509_REQ *req, ASN1_OBJECT *obj, int lastpos)
{
  return X509at_get_attr_by_OBJ(req->req_info->attributes, obj, lastpos);
}

X509_ATTRIBUTE *__cdecl X509_REQ_delete_attr(X509_REQ *req, int loc)
{
  return X509at_delete_attr(req->req_info->attributes, loc);
}

int X509_REQ_add1_attr(X509_REQ *req, X509_ATTRIBUTE *attr)
{
  return X509at_add1_attr(&req->req_info->attributes, attr) != 0;
}

int X509_REQ_add1_attr_by_OBJ(X509_REQ *req, const ASN1_OBJECT *obj, int type, const unsigned __int8 *bytes, int len)
{
  return X509at_add1_attr_by_OBJ(&req->req_info->attributes, obj, type, bytes, len) != 0;
}

int X509_REQ_add1_attr_by_txt(X509_REQ *req, const char *attrname, int type, const unsigned __int8 *bytes, int len)
{
  return X509at_add1_attr_by_txt(&req->req_info->attributes, attrname, type, bytes, len) != 0;
}

uint64_t i2d_re_X509_REQ_tbs(X509_REQ_INFO **a1, unsigned __int8 **a2)
{
  X509_REQ_INFO *v2;

  v2 = *a1;
  v2->enc.modified = 1;
  return i2d_X509_REQ_INFO(v2, a2);
}

uint64_t ec_GFp_simple_group_init(uint64_t a1)
{
  BN_init((BIGNUM *)(a1 + 104));
  BN_init((BIGNUM *)(a1 + 152));
  BN_init((BIGNUM *)(a1 + 176));
  *(_DWORD *)(a1 + 200) = 0;
  return 1;
}

void ec_GFp_simple_group_finish(uint64_t a1)
{
  BN_free((BIGNUM *)(a1 + 104));
  BN_free((BIGNUM *)(a1 + 152));
  BN_free((BIGNUM *)(a1 + 176));
}

BOOL ec_GFp_simple_group_copy(uint64_t a1, uint64_t a2)
{
  _BOOL8 result;

  result = bn_copy((BIGNUM *)(a1 + 104), (const BIGNUM *)(a2 + 104));
  if (result)
  {
    result = bn_copy((BIGNUM *)(a1 + 152), (const BIGNUM *)(a2 + 152));
    if (result)
    {
      result = bn_copy((BIGNUM *)(a1 + 176), (const BIGNUM *)(a2 + 176));
      if (result)
      {
        *(_DWORD *)(a1 + 200) = *(_DWORD *)(a2 + 200);
        return 1;
      }
    }
  }
  return result;
}

uint64_t ec_GFp_simple_group_set_curve(uint64_t a1, BIGNUM *a, const BIGNUM *a3, const BIGNUM *a4, BN_CTX *a5)
{
  BIGNUM *v10;
  BIGNUM *v11;
  unsigned int (*v12)(uint64_t, uint64_t, BIGNUM *, BN_CTX *);
  uint64_t v13;
  unsigned int (*v14)(uint64_t, uint64_t, uint64_t, BN_CTX *);

  if (BN_num_bits(a) >= 3 && BN_is_odd((uint64_t)a))
  {
    BN_CTX_start(a5);
    v10 = BN_CTX_get(a5);
    if (!v10)
      goto LABEL_16;
    v11 = v10;
    if (!bn_copy((BIGNUM *)(a1 + 104), a))
      goto LABEL_16;
    BN_set_negative((BIGNUM *)(a1 + 104), 0);
    if (!BN_nnmod(v11, a3, a, a5))
      goto LABEL_16;
    v12 = *(unsigned int (**)(uint64_t, uint64_t, BIGNUM *, BN_CTX *))(*(_QWORD *)a1 + 288);
    if (v12)
    {
      if (!v12(a1, a1 + 152, v11, a5))
        goto LABEL_16;
    }
    else if (!bn_copy((BIGNUM *)(a1 + 152), v11))
    {
      goto LABEL_16;
    }
    if (BN_nnmod((BIGNUM *)(a1 + 176), a4, a, a5))
    {
      v14 = *(unsigned int (**)(uint64_t, uint64_t, uint64_t, BN_CTX *))(*(_QWORD *)a1 + 288);
      if (!v14 || v14(a1, a1 + 176, a1 + 176, a5))
      {
        if (BN_add_word(v11, 3uLL))
        {
          *(_DWORD *)(a1 + 200) = BN_cmp(v11, (const BIGNUM *)(a1 + 104)) == 0;
          v13 = 1;
LABEL_17:
          BN_CTX_end(a5);
          return v13;
        }
      }
    }
LABEL_16:
    v13 = 0;
    goto LABEL_17;
  }
  ERR_put_error(16, 4095, 103, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ecp_smpl.c", 126);
  return 0;
}

uint64_t ec_GFp_simple_group_get_curve(uint64_t a1, BIGNUM *a2, BIGNUM *a3, BIGNUM *a4, uint64_t a5)
{
  uint64_t result;
  uint64_t (*v10)(uint64_t, BIGNUM *, uint64_t, uint64_t);

  if (a2)
  {
    result = bn_copy(a2, (const BIGNUM *)(a1 + 104));
    if (!(_DWORD)result)
      return result;
  }
  v10 = *(uint64_t (**)(uint64_t, BIGNUM *, uint64_t, uint64_t))(*(_QWORD *)a1 + 296);
  if (v10)
  {
    if (a3)
    {
      result = v10(a1, a3, a1 + 152, a5);
      if (!(_DWORD)result)
        return result;
    }
    if (a4)
    {
      result = (*(uint64_t (**)(uint64_t, BIGNUM *, uint64_t, uint64_t))(*(_QWORD *)a1 + 296))(a1, a4, a1 + 176, a5);
      if (!(_DWORD)result)
        return result;
    }
    return 1;
  }
  if (!a3 || (result = bn_copy(a3, (const BIGNUM *)(a1 + 152)), (_DWORD)result))
  {
    if (!a4)
      return 1;
    result = bn_copy(a4, (const BIGNUM *)(a1 + 176));
    if ((_DWORD)result)
      return 1;
  }
  return result;
}

uint64_t ec_GFp_simple_group_get_degree(uint64_t a1)
{
  return BN_num_bits((const BIGNUM *)(a1 + 104));
}

BIGNUM *ec_GFp_simple_group_check_discriminant(uint64_t a1, BN_CTX *ctx)
{
  BIGNUM *v4;
  BIGNUM *v5;
  BIGNUM *v6;
  BIGNUM *v7;
  BIGNUM *v8;
  BIGNUM *v9;
  BIGNUM *v10;
  unsigned int (*v11)(uint64_t, BIGNUM *, uint64_t, BN_CTX *);
  _BOOL4 is_zero;
  _BOOL4 v13;
  const BIGNUM *v15;

  BN_CTX_start(ctx);
  v4 = BN_CTX_get(ctx);
  if (v4)
  {
    v5 = BN_CTX_get(ctx);
    if (!v5)
      goto LABEL_14;
    v6 = v5;
    v7 = BN_CTX_get(ctx);
    if (!v7)
      goto LABEL_14;
    v8 = v7;
    v9 = BN_CTX_get(ctx);
    if (!v9)
      goto LABEL_14;
    v10 = v9;
    if (!BN_CTX_get(ctx))
      goto LABEL_14;
    v11 = *(unsigned int (**)(uint64_t, BIGNUM *, uint64_t, BN_CTX *))(*(_QWORD *)a1 + 296);
    if (v11)
    {
      if (!v11(a1, v4, a1 + 152, ctx)
        || !(*(unsigned int (**)(uint64_t, BIGNUM *, uint64_t, BN_CTX *))(*(_QWORD *)a1 + 296))(a1, v6, a1 + 176, ctx))
      {
        goto LABEL_14;
      }
    }
    else if (!bn_copy(v4, (const BIGNUM *)(a1 + 152)) || !bn_copy(v6, (const BIGNUM *)(a1 + 176)))
    {
      goto LABEL_14;
    }
    is_zero = BN_is_zero((uint64_t)v4);
    v13 = BN_is_zero((uint64_t)v6);
    if (is_zero)
    {
      if (v13)
      {
LABEL_14:
        v4 = 0;
        goto LABEL_15;
      }
    }
    else if (!v13)
    {
      v15 = (const BIGNUM *)(a1 + 104);
      if (!BN_mod_sqr(v8, v4, v15, ctx)
        || !BN_mod_mul(v10, v8, v4, v15, ctx)
        || !BN_lshift(v8, v10, 2)
        || !BN_mod_sqr(v10, v6, v15, ctx)
        || !BN_mul_word(v10, 0x1BuLL)
        || !BN_mod_add(v4, v8, v10, v15, ctx)
        || BN_is_zero((uint64_t)v4))
      {
        goto LABEL_14;
      }
    }
    v4 = (BIGNUM *)1;
  }
LABEL_15:
  BN_CTX_end(ctx);
  return v4;
}

uint64_t ec_GFp_simple_point_init(uint64_t a1)
{
  BN_init((BIGNUM *)(a1 + 8));
  BN_init((BIGNUM *)(a1 + 32));
  BN_init((BIGNUM *)(a1 + 56));
  *(_DWORD *)(a1 + 80) = 0;
  return 1;
}

void ec_GFp_simple_point_finish(uint64_t a1)
{
  BN_free((BIGNUM *)(a1 + 8));
  BN_free((BIGNUM *)(a1 + 32));
  BN_free((BIGNUM *)(a1 + 56));
  *(_DWORD *)(a1 + 80) = 0;
}

BOOL ec_GFp_simple_point_copy(uint64_t a1, uint64_t a2)
{
  _BOOL8 result;

  result = bn_copy((BIGNUM *)(a1 + 8), (const BIGNUM *)(a2 + 8));
  if (result)
  {
    result = bn_copy((BIGNUM *)(a1 + 32), (const BIGNUM *)(a2 + 32));
    if (result)
    {
      result = bn_copy((BIGNUM *)(a1 + 56), (const BIGNUM *)(a2 + 56));
      if (result)
      {
        *(_DWORD *)(a1 + 80) = *(_DWORD *)(a2 + 80);
        return 1;
      }
    }
  }
  return result;
}

uint64_t ec_GFp_simple_point_set_to_infinity(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a2 + 80) = 0;
  BN_zero(a2 + 56);
  return 1;
}

uint64_t ec_GFp_simple_set_Jprojective_coordinates(uint64_t a1, uint64_t a2, BIGNUM *m, BIGNUM *a4, BIGNUM *a5, BN_CTX *ctx)
{
  uint64_t result;
  uint64_t (*v12)(uint64_t, uint64_t, uint64_t, BN_CTX *);
  uint64_t (*v13)(uint64_t, uint64_t, uint64_t, BN_CTX *);
  _BOOL4 is_one;
  _BOOL4 v15;
  uint64_t (*v16)(uint64_t, uint64_t, uint64_t, BN_CTX *);
  uint64_t (*v17)(uint64_t, uint64_t, BN_CTX *);

  if (!m
    || (result = BN_nnmod((BIGNUM *)(a2 + 8), m, (const BIGNUM *)(a1 + 104), ctx), (_DWORD)result)
    && ((v12 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, BN_CTX *))(*(_QWORD *)a1 + 288)) == 0
     || (result = v12(a1, a2 + 8, a2 + 8, ctx), (_DWORD)result)))
  {
    if (!a4
      || (result = BN_nnmod((BIGNUM *)(a2 + 32), a4, (const BIGNUM *)(a1 + 104), ctx), (_DWORD)result)
      && ((v13 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, BN_CTX *))(*(_QWORD *)a1 + 288)) == 0
       || (result = v13(a1, a2 + 32, a2 + 32, ctx), (_DWORD)result)))
    {
      if (a5)
      {
        result = BN_nnmod((BIGNUM *)(a2 + 56), a5, (const BIGNUM *)(a1 + 104), ctx);
        if (!(_DWORD)result)
          return result;
        is_one = BN_is_one(a2 + 56);
        v15 = is_one;
        v16 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, BN_CTX *))(*(_QWORD *)a1 + 288);
        if (v16)
        {
          if (is_one && (v17 = *(uint64_t (**)(uint64_t, uint64_t, BN_CTX *))(*(_QWORD *)a1 + 304)) != 0)
          {
            result = v17(a1, a2 + 56, ctx);
            if (!(_DWORD)result)
              return result;
          }
          else
          {
            result = v16(a1, a2 + 56, a2 + 56, ctx);
            if (!(_DWORD)result)
              return result;
          }
        }
        *(_DWORD *)(a2 + 80) = v15;
      }
      return 1;
    }
  }
  return result;
}

uint64_t ec_GFp_simple_get_Jprojective_coordinates(uint64_t a1, uint64_t a2, BIGNUM *a3, BIGNUM *a4, BIGNUM *a5, uint64_t a6)
{
  uint64_t (*v9)(uint64_t, BIGNUM *, uint64_t, uint64_t);
  uint64_t result;

  v9 = *(uint64_t (**)(uint64_t, BIGNUM *, uint64_t, uint64_t))(*(_QWORD *)a1 + 296);
  if (v9)
  {
    if (a3)
    {
      result = v9(a1, a3, a2 + 8, a6);
      if (!(_DWORD)result)
        return result;
    }
    if (a4)
    {
      result = (*(uint64_t (**)(uint64_t, BIGNUM *, uint64_t, uint64_t))(*(_QWORD *)a1 + 296))(a1, a4, a2 + 32, a6);
      if (!(_DWORD)result)
        return result;
    }
    if (a5)
    {
      result = (*(uint64_t (**)(uint64_t, BIGNUM *, uint64_t, uint64_t))(*(_QWORD *)a1 + 296))(a1, a5, a2 + 56, a6);
      if (!(_DWORD)result)
        return result;
    }
    return 1;
  }
  if (!a3 || (result = bn_copy(a3, (const BIGNUM *)(a2 + 8)), (_DWORD)result))
  {
    if (!a4 || (result = bn_copy(a4, (const BIGNUM *)(a2 + 32)), (_DWORD)result))
    {
      if (!a5)
        return 1;
      result = bn_copy(a5, (const BIGNUM *)(a2 + 56));
      if ((_DWORD)result)
        return 1;
    }
  }
  return result;
}

uint64_t ec_GFp_simple_point_set_affine_coordinates(const EC_GROUP *a1, const EC_POINT *a2, uint64_t a3, uint64_t a4, BN_CTX *a5)
{
  const BIGNUM *v10;

  if (a3 && a4)
  {
    v10 = BN_value_one();
    return EC_POINT_set_Jprojective_coordinates(a1, a2, a3, a4, (uint64_t)v10, a5);
  }
  else
  {
    ERR_put_error(16, 4095, 67, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ecp_smpl.c", 406);
    return 0;
  }
}

uint64_t ec_GFp_simple_point_get_affine_coordinates(const EC_GROUP *a1, uint64_t a2, BIGNUM *a3, BIGNUM *a4, BN_CTX *a5)
{
  uint64_t v10;
  BIGNUM *v11;
  BIGNUM *v12;
  BIGNUM *v13;
  BIGNUM *v14;
  BIGNUM *v15;
  BIGNUM *v16;
  BIGNUM *v17;
  BIGNUM *v18;
  unsigned int (*v19)(const EC_GROUP *, BIGNUM *, uint64_t, BN_CTX *);
  const BIGNUM *v20;
  unsigned int (*v21)(const EC_GROUP *, BIGNUM *, uint64_t, BN_CTX *);

  if (EC_POINT_is_at_infinity(a1, (const EC_POINT *)a2) < 1)
  {
    BN_CTX_start(a5);
    v11 = BN_CTX_get(a5);
    if (!v11)
      goto LABEL_26;
    v12 = v11;
    v13 = BN_CTX_get(a5);
    if (!v13)
      goto LABEL_26;
    v14 = v13;
    v15 = BN_CTX_get(a5);
    if (!v15)
      goto LABEL_26;
    v16 = v15;
    v17 = BN_CTX_get(a5);
    if (!v17)
      goto LABEL_26;
    v18 = v17;
    v19 = *(unsigned int (**)(const EC_GROUP *, BIGNUM *, uint64_t, BN_CTX *))(*(_QWORD *)a1 + 296);
    v20 = (const BIGNUM *)(a2 + 56);
    if (v19)
    {
      v20 = v12;
      if (!v19(a1, v12, a2 + 56, a5))
        goto LABEL_26;
    }
    if (BN_is_one((uint64_t)v20))
    {
      v21 = *(unsigned int (**)(const EC_GROUP *, BIGNUM *, uint64_t, BN_CTX *))(*(_QWORD *)a1 + 296);
      if (v21)
      {
        if (a3 && !v21(a1, a3, a2 + 8, a5)
          || a4
          && !(*(unsigned int (**)(const EC_GROUP *, BIGNUM *, uint64_t, BN_CTX *))(*(_QWORD *)a1 + 296))(a1, a4, a2 + 32, a5))
        {
          goto LABEL_26;
        }
      }
      else if (a3 && !bn_copy(a3, (const BIGNUM *)(a2 + 8)) || a4 && !bn_copy(a4, (const BIGNUM *)(a2 + 32)))
      {
        goto LABEL_26;
      }
LABEL_38:
      v10 = 1;
      goto LABEL_27;
    }
    if (BN_mod_inverse_ct(v14, v20, (const BIGNUM *)((char *)a1 + 104), a5))
    {
      if (*(_QWORD *)(*(_QWORD *)a1 + 288))
      {
        if (!BN_mod_sqr(v16, v14, (const BIGNUM *)((char *)a1 + 104), a5))
          goto LABEL_26;
      }
      else if (!(*(unsigned int (**)(const EC_GROUP *, BIGNUM *, BIGNUM *, BN_CTX *))(*(_QWORD *)a1 + 272))(a1, v16, v14, a5))
      {
        goto LABEL_26;
      }
      if (a3
        && !(*(unsigned int (**)(const EC_GROUP *, BIGNUM *, uint64_t, BIGNUM *, BN_CTX *))(*(_QWORD *)a1 + 264))(a1, a3, a2 + 8, v16, a5))
      {
        goto LABEL_26;
      }
      if (!a4)
        goto LABEL_38;
      if (*(_QWORD *)(*(_QWORD *)a1 + 288))
      {
        if (!BN_mod_mul(v18, v16, v14, (const BIGNUM *)((char *)a1 + 104), a5))
          goto LABEL_26;
      }
      else if (!(*(unsigned int (**)(const EC_GROUP *, BIGNUM *, BIGNUM *, BIGNUM *, BN_CTX *))(*(_QWORD *)a1 + 264))(a1, v18, v16, v14, a5))
      {
        goto LABEL_26;
      }
      if ((*(unsigned int (**)(const EC_GROUP *, BIGNUM *, uint64_t, BIGNUM *, BN_CTX *))(*(_QWORD *)a1 + 264))(a1, a4, a2 + 32, v18, a5))
      {
        goto LABEL_38;
      }
    }
    else
    {
      ERR_put_error(16, 4095, 3, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ecp_smpl.c", 469);
    }
LABEL_26:
    v10 = 0;
LABEL_27:
    BN_CTX_end(a5);
    return v10;
  }
  ERR_put_error(16, 4095, 106, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ecp_smpl.c", 422);
  return 0;
}

uint64_t ec_GFp_simple_add(EC_GROUP *a1, EC_POINT *r, EC_POINT *a, uint64_t a4, BN_CTX *a5)
{
  BN_CTX *v5;
  EC_POINT *v10;
  const EC_POINT *v11;
  unsigned int (*v13)(EC_GROUP *, BIGNUM *);
  unsigned int (*v14)(EC_GROUP *, BIGNUM *, char *, BIGNUM *, BN_CTX *);
  BIGNUM *v15;
  BIGNUM *v16;
  BIGNUM *v17;
  BIGNUM *v18;
  BIGNUM *v19;
  BIGNUM *v20;
  BIGNUM *v21;
  BIGNUM *v22;
  BIGNUM *v23;
  uint64_t v24;
  int v25;
  BIGNUM *v26;
  const BIGNUM *v27;
  BIGNUM *v28;
  BIGNUM *ra;
  BIGNUM *v30;
  BIGNUM *b;
  BIGNUM *aa;

  v5 = a5;
  if (a == (EC_POINT *)a4)
    return EC_POINT_dbl(a1, r, a, a5);
  if (EC_POINT_is_at_infinity(a1, a) >= 1)
  {
    v10 = r;
    v11 = (const EC_POINT *)a4;
    return EC_POINT_copy(v10, v11);
  }
  if (EC_POINT_is_at_infinity(a1, (const EC_POINT *)a4) >= 1)
  {
    v10 = r;
    v11 = a;
    return EC_POINT_copy(v10, v11);
  }
  v14 = *(unsigned int (**)(EC_GROUP *, BIGNUM *, char *, BIGNUM *, BN_CTX *))(*(_QWORD *)a1 + 264);
  v13 = *(unsigned int (**)(EC_GROUP *, BIGNUM *))(*(_QWORD *)a1 + 272);
  BN_CTX_start(v5);
  v15 = BN_CTX_get(v5);
  if (!v15)
    goto LABEL_63;
  v16 = v15;
  v17 = BN_CTX_get(v5);
  if (!v17)
    goto LABEL_63;
  v18 = v17;
  v19 = BN_CTX_get(v5);
  if (!v19)
    goto LABEL_63;
  aa = v19;
  v20 = BN_CTX_get(v5);
  if (!v20)
    goto LABEL_63;
  b = v20;
  v21 = BN_CTX_get(v5);
  if (!v21)
    goto LABEL_63;
  v30 = v21;
  v22 = BN_CTX_get(v5);
  if (!v22)
    goto LABEL_63;
  ra = v22;
  v23 = BN_CTX_get(v5);
  if (!v23)
    goto LABEL_63;
  v28 = v23;
  if (*(_DWORD *)(a4 + 80))
  {
    if (!bn_copy(v18, (const BIGNUM *)((char *)a + 8)) || !bn_copy(aa, (const BIGNUM *)((char *)a + 32)))
      goto LABEL_63;
  }
  else if (!v13(a1, v16)
         || !v14(a1, v18, (char *)a + 8, v16, v5)
         || !v14(a1, v16, (char *)v16, (BIGNUM *)(a4 + 56), v5)
         || !v14(a1, aa, (char *)a + 32, v16, v5))
  {
    goto LABEL_63;
  }
  if (*((_DWORD *)a + 20))
  {
    if (!bn_copy(b, (const BIGNUM *)(a4 + 8)) || !bn_copy(v30, (const BIGNUM *)(a4 + 32)))
      goto LABEL_63;
  }
  else if (!v13(a1, v16)
         || !v14(a1, b, (char *)(a4 + 8), v16, v5)
         || !v14(a1, v16, (char *)v16, (BIGNUM *)((char *)a + 56), v5)
         || !v14(a1, v30, (char *)(a4 + 32), v16, v5))
  {
    goto LABEL_63;
  }
  if (!BN_mod_sub_quick(ra, v18, b, (const BIGNUM *)((char *)a1 + 104))
    || !BN_mod_sub_quick(v28, aa, v30, (const BIGNUM *)((char *)a1 + 104)))
  {
    goto LABEL_63;
  }
  if (BN_is_zero((uint64_t)ra))
  {
    if (BN_is_zero((uint64_t)v28))
    {
      BN_CTX_end(v5);
      v24 = EC_POINT_dbl(a1, r, a, v5);
      v5 = 0;
    }
    else
    {
      BN_zero((uint64_t)r + 56);
      *((_DWORD *)r + 20) = 0;
      v24 = 1;
    }
    goto LABEL_64;
  }
  if (!BN_mod_add_quick(v18, v18, b, (const BIGNUM *)((char *)a1 + 104))
    || !BN_mod_add_quick(aa, aa, v30, (const BIGNUM *)((char *)a1 + 104)))
  {
    goto LABEL_63;
  }
  v25 = *(_DWORD *)(a4 + 80);
  if (!*((_DWORD *)a + 20))
  {
    if (!v25)
    {
      if (!v14(a1, v16, (char *)a + 56, (BIGNUM *)(a4 + 56), v5))
        goto LABEL_63;
      goto LABEL_49;
    }
    v26 = v16;
    v27 = (const BIGNUM *)((char *)a + 56);
LABEL_46:
    if (!bn_copy(v26, v27))
      goto LABEL_63;
LABEL_49:
    if (v14(a1, (BIGNUM *)((char *)r + 56), (char *)v16, ra, v5))
      goto LABEL_50;
LABEL_63:
    v24 = 0;
    goto LABEL_64;
  }
  if (!v25)
  {
    v27 = (const BIGNUM *)(a4 + 56);
    v26 = v16;
    goto LABEL_46;
  }
  if (!bn_copy((BIGNUM *)((char *)r + 56), ra))
    goto LABEL_63;
LABEL_50:
  *((_DWORD *)r + 20) = 0;
  if (!((unsigned int (*)(EC_GROUP *, BIGNUM *, BIGNUM *, BN_CTX *))v13)(a1, v16, v28, v5)
    || !((unsigned int (*)(EC_GROUP *, BIGNUM *, BIGNUM *, BN_CTX *))v13)(a1, v30, ra, v5)
    || !v14(a1, b, (char *)v18, v30, v5)
    || !BN_mod_sub_quick((BIGNUM *)((char *)r + 8), v16, b, (const BIGNUM *)((char *)a1 + 104))
    || !BN_mod_lshift1_quick(v16, (const BIGNUM *)((char *)r + 8), (const BIGNUM *)((char *)a1 + 104))
    || !BN_mod_sub_quick(v16, b, v16, (const BIGNUM *)((char *)a1 + 104))
    || !v14(a1, v16, (char *)v16, v28, v5)
    || !v14(a1, ra, (char *)v30, ra, v5)
    || !v14(a1, v18, (char *)aa, ra, v5)
    || !BN_mod_sub_quick(v16, v16, v18, (const BIGNUM *)((char *)a1 + 104))
    || BN_is_odd((uint64_t)v16) && !BN_add(v16, v16, (const BIGNUM *)((char *)a1 + 104)))
  {
    goto LABEL_63;
  }
  v24 = BN_rshift1((BIGNUM *)((char *)r + 32), v16) != 0;
LABEL_64:
  BN_CTX_end(v5);
  return v24;
}

BOOL ec_GFp_simple_dbl(const EC_GROUP *a1, uint64_t a2, EC_POINT *a3, BN_CTX *a4)
{
  _BOOL8 v8;
  unsigned int (*v9)(const EC_GROUP *, BIGNUM *, BIGNUM *, BIGNUM *, BN_CTX *);
  unsigned int (*v10)(const EC_GROUP *, BIGNUM *, char *, BN_CTX *);
  BIGNUM *v11;
  BIGNUM *v12;
  BIGNUM *v13;
  BIGNUM *v14;
  BIGNUM *v15;
  BIGNUM *v16;
  BIGNUM *v17;
  const BIGNUM *v18;
  BIGNUM *v19;
  const BIGNUM *v20;
  BIGNUM *r;

  if (EC_POINT_is_at_infinity(a1, a3) < 1)
  {
    v9 = *(unsigned int (**)(const EC_GROUP *, BIGNUM *, BIGNUM *, BIGNUM *, BN_CTX *))(*(_QWORD *)a1 + 264);
    v10 = *(unsigned int (**)(const EC_GROUP *, BIGNUM *, char *, BN_CTX *))(*(_QWORD *)a1 + 272);
    BN_CTX_start(a4);
    v11 = BN_CTX_get(a4);
    if (!v11)
      goto LABEL_43;
    v12 = v11;
    v13 = BN_CTX_get(a4);
    if (!v13)
      goto LABEL_43;
    v14 = v13;
    v15 = BN_CTX_get(a4);
    if (!v15)
      goto LABEL_43;
    v16 = v15;
    v17 = BN_CTX_get(a4);
    if (!v17)
      goto LABEL_43;
    r = v17;
    if (*((_DWORD *)a3 + 20))
    {
      if (!v10(a1, v12, (char *)a3 + 8, a4)
        || !BN_mod_lshift1_quick(v14, v12, (const BIGNUM *)((char *)a1 + 104))
        || !BN_mod_add_quick(v12, v12, v14, (const BIGNUM *)((char *)a1 + 104)))
      {
        goto LABEL_43;
      }
      v18 = (const BIGNUM *)((char *)a1 + 152);
      v19 = v14;
      v20 = v12;
    }
    else if (*((_DWORD *)a1 + 50))
    {
      if (!v10(a1, v14, (char *)a3 + 56, a4)
        || !BN_mod_add_quick(v12, (const BIGNUM *)((char *)a3 + 8), v14, (const BIGNUM *)((char *)a1 + 104))
        || !BN_mod_sub_quick(v16, (const BIGNUM *)((char *)a3 + 8), v14, (const BIGNUM *)((char *)a1 + 104))
        || !v9(a1, v14, v12, v16, a4)
        || !BN_mod_lshift1_quick(v12, v14, (const BIGNUM *)((char *)a1 + 104)))
      {
        goto LABEL_43;
      }
      v19 = v14;
      v20 = v12;
      v18 = v14;
    }
    else
    {
      if (!v10(a1, v12, (char *)a3 + 8, a4)
        || !BN_mod_lshift1_quick(v14, v12, (const BIGNUM *)((char *)a1 + 104))
        || !BN_mod_add_quick(v12, v12, v14, (const BIGNUM *)((char *)a1 + 104))
        || !v10(a1, v14, (char *)a3 + 56, a4)
        || !v10(a1, v14, (char *)v14, a4)
        || !v9(a1, v14, v14, (BIGNUM *)((char *)a1 + 152), a4))
      {
        goto LABEL_43;
      }
      v19 = v14;
      v20 = v14;
      v18 = v12;
    }
    if (BN_mod_add_quick(v19, v20, v18, (const BIGNUM *)((char *)a1 + 104)))
    {
      if (*((_DWORD *)a3 + 20))
      {
        if (!bn_copy(v12, (const BIGNUM *)((char *)a3 + 32)))
          goto LABEL_43;
      }
      else if (!v9(a1, v12, (BIGNUM *)((char *)a3 + 32), (BIGNUM *)((char *)a3 + 56), a4))
      {
        goto LABEL_43;
      }
      if (BN_mod_lshift1_quick((BIGNUM *)(a2 + 56), v12, (const BIGNUM *)((char *)a1 + 104)))
      {
        *(_DWORD *)(a2 + 80) = 0;
        if (v10(a1, r, (char *)a3 + 32, a4))
        {
          if (v9(a1, v16, (BIGNUM *)((char *)a3 + 8), r, a4)
            && BN_mod_lshift_quick(v16, v16, 2, (const BIGNUM *)((char *)a1 + 104))
            && BN_mod_lshift1_quick(v12, v16, (const BIGNUM *)((char *)a1 + 104))
            && v10(a1, (BIGNUM *)(a2 + 8), (char *)v14, a4)
            && BN_mod_sub_quick((BIGNUM *)(a2 + 8), (const BIGNUM *)(a2 + 8), v12, (const BIGNUM *)((char *)a1 + 104))
            && v10(a1, v12, (char *)r, a4)
            && BN_mod_lshift_quick(r, v12, 3, (const BIGNUM *)((char *)a1 + 104))
            && BN_mod_sub_quick(v12, v16, (const BIGNUM *)(a2 + 8), (const BIGNUM *)((char *)a1 + 104))
            && v9(a1, v12, v14, v12, a4))
          {
            v8 = BN_mod_sub_quick((BIGNUM *)(a2 + 32), v12, r, (const BIGNUM *)((char *)a1 + 104)) != 0;
LABEL_44:
            BN_CTX_end(a4);
            return v8;
          }
        }
      }
    }
LABEL_43:
    v8 = 0;
    goto LABEL_44;
  }
  BN_zero(a2 + 56);
  *(_DWORD *)(a2 + 80) = 0;
  return 1;
}

uint64_t ec_GFp_simple_invert(uint64_t a1, const EC_POINT *a2)
{
  BIGNUM *v4;

  if (EC_POINT_is_at_infinity((const EC_GROUP *)a1, a2) > 0)
    return 1;
  v4 = (BIGNUM *)((char *)a2 + 32);
  if (BN_is_zero((uint64_t)v4))
    return 1;
  else
    return BN_usub(v4, (const BIGNUM *)(a1 + 104), v4);
}

BOOL ec_GFp_simple_is_at_infinity(uint64_t a1, uint64_t a2)
{
  return BN_is_zero(a2 + 56);
}

uint64_t ec_GFp_simple_is_on_curve(const EC_GROUP *a1, uint64_t a2, BN_CTX *a3)
{
  uint64_t v6;
  unsigned int (*v7)(const EC_GROUP *, BIGNUM *, BIGNUM *, uint64_t, BN_CTX *);
  unsigned int (*v8)(const EC_GROUP *, BIGNUM *);
  BIGNUM *v9;
  BIGNUM *v10;
  BIGNUM *v11;
  BIGNUM *v12;
  BIGNUM *v13;
  const BIGNUM *v14;
  BIGNUM *v15;
  BIGNUM *v16;
  const BIGNUM *v17;
  BIGNUM *v18;
  const BIGNUM *v19;
  uint64_t v21;

  if (EC_POINT_is_at_infinity(a1, (const EC_POINT *)a2) <= 0)
  {
    v7 = *(unsigned int (**)(const EC_GROUP *, BIGNUM *, BIGNUM *, uint64_t, BN_CTX *))(*(_QWORD *)a1 + 264);
    v8 = *(unsigned int (**)(const EC_GROUP *, BIGNUM *))(*(_QWORD *)a1 + 272);
    BN_CTX_start(a3);
    v9 = BN_CTX_get(a3);
    if (!v9)
      goto LABEL_28;
    v10 = v9;
    v11 = BN_CTX_get(a3);
    if (!v11)
      goto LABEL_28;
    v12 = v11;
    v13 = BN_CTX_get(a3);
    if (!v13)
      goto LABEL_28;
    v14 = v13;
    v15 = BN_CTX_get(a3);
    if (!v15)
      goto LABEL_28;
    v16 = v15;
    v21 = a2 + 8;
    if (!v8(a1, v10))
      goto LABEL_28;
    if (*(_DWORD *)(a2 + 80))
    {
      if (!BN_mod_add_quick(v10, v10, (const BIGNUM *)((char *)a1 + 152), (const BIGNUM *)((char *)a1 + 104))
        || !v7(a1, v10, v10, v21, a3))
      {
        goto LABEL_28;
      }
      v17 = (const BIGNUM *)((char *)a1 + 176);
      v18 = v10;
      v19 = v10;
    }
    else
    {
      if (!((unsigned int (*)(const EC_GROUP *, BIGNUM *, uint64_t, BN_CTX *))v8)(a1, v12, a2 + 56, a3)
        || !((unsigned int (*)(const EC_GROUP *, const BIGNUM *, BIGNUM *, BN_CTX *))v8)(a1, v14, v12, a3)
        || !v7(a1, v16, (BIGNUM *)v14, (uint64_t)v12, a3))
      {
        goto LABEL_28;
      }
      if (*((_DWORD *)a1 + 50))
      {
        if (!BN_mod_lshift1_quick(v12, v14, (const BIGNUM *)((char *)a1 + 104))
          || !BN_mod_add_quick(v12, v12, v14, (const BIGNUM *)((char *)a1 + 104))
          || !BN_mod_sub_quick(v10, v10, v12, (const BIGNUM *)((char *)a1 + 104)))
        {
          goto LABEL_28;
        }
      }
      else if (!v7(a1, v12, (BIGNUM *)v14, (uint64_t)a1 + 152, a3)
             || !BN_mod_add_quick(v10, v10, v12, (const BIGNUM *)((char *)a1 + 104)))
      {
        goto LABEL_28;
      }
      if (!v7(a1, v10, v10, v21, a3) || !v7(a1, v12, (BIGNUM *)((char *)a1 + 176), (uint64_t)v16, a3))
      {
LABEL_28:
        v6 = 0xFFFFFFFFLL;
        goto LABEL_29;
      }
      v18 = v10;
      v19 = v10;
      v17 = v12;
    }
    if (BN_mod_add_quick(v18, v19, v17, (const BIGNUM *)((char *)a1 + 104))
      && ((unsigned int (*)(const EC_GROUP *, BIGNUM *, uint64_t, BN_CTX *))v8)(a1, v12, a2 + 32, a3))
    {
      v6 = BN_ucmp(v12, v10) == 0;
LABEL_29:
      BN_CTX_end(a3);
      return v6;
    }
    goto LABEL_28;
  }
  return 1;
}

BOOL ec_GFp_simple_cmp(const EC_GROUP *a1, uint64_t a2, uint64_t a3, BN_CTX *a4)
{
  int v8;
  int v9;
  uint64_t v10;
  uint64_t (*v11)(const EC_GROUP *, BIGNUM *, uint64_t, BIGNUM *, BN_CTX *);
  unsigned int (*v12)(const EC_GROUP *, BIGNUM *, uint64_t, BN_CTX *);
  BIGNUM *v13;
  BIGNUM *v14;
  BIGNUM *v15;
  BIGNUM *v16;
  BIGNUM *v17;
  BIGNUM *v18;
  BIGNUM *v19;
  BIGNUM *v20;
  const BIGNUM *v21;
  const BIGNUM *v22;
  int v23;
  int v24;
  const BIGNUM *v25;
  const BIGNUM *v26;
  int v27;
  const BIGNUM *v28;
  int v29;
  const BIGNUM *v31;

  v8 = EC_POINT_is_at_infinity(a1, (const EC_POINT *)a2);
  v9 = EC_POINT_is_at_infinity(a1, (const EC_POINT *)a3);
  if (v8 < 1)
  {
    if (v9 > 0)
      return 1;
    if (*(_DWORD *)(a2 + 80) && *(_DWORD *)(a3 + 80))
    {
      if (!BN_cmp((const BIGNUM *)(a2 + 8), (const BIGNUM *)(a3 + 8)))
        return BN_cmp((const BIGNUM *)(a2 + 32), (const BIGNUM *)(a3 + 32)) != 0;
      return 1;
    }
    v11 = *(uint64_t (**)(const EC_GROUP *, BIGNUM *, uint64_t, BIGNUM *, BN_CTX *))(*(_QWORD *)a1 + 264);
    v12 = *(unsigned int (**)(const EC_GROUP *, BIGNUM *, uint64_t, BN_CTX *))(*(_QWORD *)a1 + 272);
    BN_CTX_start(a4);
    v13 = BN_CTX_get(a4);
    if (!v13)
      goto LABEL_35;
    v14 = v13;
    v15 = BN_CTX_get(a4);
    if (!v15)
      goto LABEL_35;
    v16 = v15;
    v17 = BN_CTX_get(a4);
    if (!v17)
      goto LABEL_35;
    v18 = v17;
    v19 = BN_CTX_get(a4);
    if (!v19)
      goto LABEL_35;
    v20 = v19;
    if (*(_DWORD *)(a3 + 80))
    {
      v21 = (const BIGNUM *)(a2 + 8);
    }
    else
    {
      if (!v12(a1, v19, a3 + 56, a4))
        goto LABEL_35;
      v23 = v11(a1, v14, a2 + 8, v20, a4);
      v21 = v14;
      if (!v23)
        goto LABEL_35;
    }
    v31 = v21;
    if (*(_DWORD *)(a2 + 80))
    {
      v22 = (const BIGNUM *)(a3 + 8);
    }
    else
    {
      if (!v12(a1, v18, a2 + 56, a4))
        goto LABEL_35;
      v24 = v11(a1, v16, a3 + 8, v18, a4);
      v22 = v16;
      v21 = v31;
      if (!v24)
        goto LABEL_35;
    }
    if (BN_cmp(v21, v22))
    {
      v10 = 1;
LABEL_36:
      BN_CTX_end(a4);
      return v10;
    }
    if (*(_DWORD *)(a3 + 80))
    {
      v25 = (const BIGNUM *)(a2 + 32);
    }
    else
    {
      if (!v11(a1, v20, (uint64_t)v20, (BIGNUM *)(a3 + 56), a4))
        goto LABEL_35;
      v27 = v11(a1, v14, a2 + 32, v20, a4);
      v25 = v31;
      if (!v27)
        goto LABEL_35;
    }
    if (*(_DWORD *)(a2 + 80))
    {
      v26 = (const BIGNUM *)(a3 + 32);
LABEL_29:
      v10 = BN_cmp(v25, v26) != 0;
      goto LABEL_36;
    }
    v28 = v25;
    if (v11(a1, v18, (uint64_t)v18, (BIGNUM *)(a2 + 56), a4))
    {
      v29 = v11(a1, v16, a3 + 32, v18, a4);
      v25 = v28;
      v26 = v22;
      if (v29)
        goto LABEL_29;
    }
LABEL_35:
    v10 = 0xFFFFFFFFLL;
    goto LABEL_36;
  }
  return v9 < 1;
}

uint64_t ec_GFp_simple_make_affine(const EC_GROUP *a1, uint64_t a2, BN_CTX *a3)
{
  uint64_t v6;
  BIGNUM *v8;
  uint64_t v9;
  BIGNUM *v10;
  uint64_t v11;

  if (!*(_DWORD *)(a2 + 80) && EC_POINT_is_at_infinity(a1, (const EC_POINT *)a2) <= 0)
  {
    BN_CTX_start(a3);
    v8 = BN_CTX_get(a3);
    if (v8)
    {
      v9 = (uint64_t)v8;
      v10 = BN_CTX_get(a3);
      if (v10)
      {
        v11 = (uint64_t)v10;
        if (EC_POINT_get_affine_coordinates((uint64_t)a1, (_QWORD *)a2, v9, (uint64_t)v10, a3))
        {
          if (EC_POINT_set_affine_coordinates(a1, (const EC_POINT *)a2, v9, v11, a3))
          {
            if (*(_DWORD *)(a2 + 80))
            {
              v6 = 1;
LABEL_13:
              BN_CTX_end(a3);
              return v6;
            }
            ERR_put_error(16, 4095, 68, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ecp_smpl.c", 1064);
          }
        }
      }
    }
    v6 = 0;
    goto LABEL_13;
  }
  return 1;
}

uint64_t ec_GFp_simple_points_make_affine(uint64_t a1, unint64_t a2, uint64_t *a3, BN_CTX *ctx)
{
  unint64_t v6;
  BIGNUM *v8;
  BIGNUM *v9;
  BIGNUM *v10;
  BIGNUM *v11;
  unint64_t v12;
  unint64_t v13;
  uint64_t *v14;
  uint64_t *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t *v19;
  unint64_t v20;
  uint64_t v21;
  uint64_t *v22;
  uint64_t i;
  BIGNUM *v24;
  const BIGNUM *v25;
  uint64_t v26;
  unsigned int (*v27)(uint64_t, uint64_t, uint64_t, BN_CTX *);
  const BIGNUM *v28;
  uint64_t v29;
  uint64_t *v30;
  uint64_t v31;
  uint64_t v32;
  _BOOL4 v33;
  uint64_t *v34;
  unint64_t v35;
  uint64_t v36;
  uint64_t v37;
  unsigned int (*v38)(uint64_t, uint64_t, BN_CTX *);
  const BIGNUM *v40;
  const BIGNUM *v41;
  unint64_t v42;

  if (!a2)
    return 1;
  v6 = a2;
  BN_CTX_start(ctx);
  v8 = BN_CTX_get(ctx);
  if (!v8)
    goto LABEL_27;
  v9 = v8;
  v10 = BN_CTX_get(ctx);
  if (!v10)
    goto LABEL_27;
  v11 = v10;
  v12 = 1;
  do
  {
    v13 = v12;
    v12 *= 2;
  }
  while (v13 < v6);
  v14 = (uint64_t *)reallocarray(0, v12, 8uLL);
  if (!v14)
  {
LABEL_27:
    BN_CTX_end(ctx);
    return 0;
  }
  v15 = v14;
  v40 = v9;
  *v14 = 0;
  v16 = v13 & 0x7FFFFFFFFFFFFFFFLL;
  v17 = (v13 & 0x7FFFFFFFFFFFFFFFLL) - 1;
  if ((v13 & 0x7FFFFFFFFFFFFFFFLL) != 1)
    bzero(v14 + 1, 8 * v13 - 8);
  v18 = v13;
  v19 = a3;
  v20 = v6;
  do
  {
    v21 = *v19++;
    v15[v18++] = v21 + 56;
    --v20;
  }
  while (v20);
  v41 = v11;
  v42 = v16 + v6;
  if (v12 > v16 + v6)
    bzero(&v15[v42], 8 * (v12 - (v16 + v6)));
  if ((v13 & 0x7FFFFFFFFFFFFFFFLL) != 1)
  {
    v22 = &v15[2 * v13 - 2];
    for (i = (v13 & 0x7FFFFFFFFFFFFFFFLL) - 1; i; --i)
    {
      v24 = BN_new();
      v15[i] = (uint64_t)v24;
      if (!v24)
        goto LABEL_58;
      v25 = (const BIGNUM *)*v22;
      if (*v22)
      {
        if (!v22[1])
          goto LABEL_22;
        if (BN_is_zero(v22[1]))
        {
          v24 = (BIGNUM *)v15[i];
          v25 = (const BIGNUM *)*v22;
          goto LABEL_22;
        }
        if (BN_is_zero(*v22))
        {
          v24 = (BIGNUM *)v15[i];
          v25 = (const BIGNUM *)v22[1];
LABEL_22:
          if (!bn_copy(v24, v25))
            goto LABEL_58;
          goto LABEL_23;
        }
        if (!(*(unsigned int (**)(uint64_t, uint64_t, uint64_t, uint64_t, BN_CTX *))(*(_QWORD *)a1 + 264))(a1, v15[i], *v22, v22[1], ctx))goto LABEL_58;
      }
LABEL_23:
      v22 -= 2;
    }
  }
  if (BN_is_zero(v15[1])
    || BN_mod_inverse_ct((BIGNUM *)v15[1], (const BIGNUM *)v15[1], (const BIGNUM *)(a1 + 104), ctx))
  {
    v27 = *(unsigned int (**)(uint64_t, uint64_t, uint64_t, BN_CTX *))(*(_QWORD *)a1 + 288);
    v28 = v41;
    if (!v27
      || v27(a1, v15[1], v15[1], ctx)
      && (*(unsigned int (**)(uint64_t, uint64_t, uint64_t, BN_CTX *))(*(_QWORD *)a1 + 288))(a1, v15[1], v15[1], ctx))
    {
      if (v42 < 3)
        goto LABEL_45;
      v29 = 0;
      do
      {
        v30 = &v15[v29];
        v31 = v30[3];
        v32 = 4 * (v29 + 2);
        if (v31 && !BN_is_zero(v31))
        {
          if (!(*(unsigned int (**)(uint64_t, const BIGNUM *, _QWORD, uint64_t, BN_CTX *))(*(_QWORD *)a1 + 264))(a1, v40, *(uint64_t *)((char *)v15 + v32), v30[3], ctx))goto LABEL_58;
          v34 = &v15[v29];
          v28 = v41;
          if (!(*(unsigned int (**)(uint64_t, const BIGNUM *, uint64_t, uint64_t, BN_CTX *))(*(_QWORD *)a1 + 264))(a1, v41, v15[(unint64_t)(v29 + 2) >> 1], v34[2], ctx)|| !bn_copy((BIGNUM *)v34[2], v40)|| !bn_copy((BIGNUM *)v30[3], v41))
          {
            goto LABEL_58;
          }
        }
        else
        {
          v33 = bn_copy((BIGNUM *)v30[2], *(const BIGNUM **)((char *)v15 + v32));
          v28 = v41;
          if (!v33)
            goto LABEL_58;
        }
        v35 = v29 + 4;
        v29 += 2;
      }
      while (v35 < v42);
      do
      {
LABEL_45:
        v36 = *a3;
        v37 = *a3 + 56;
        if (!BN_is_zero(v37))
        {
          if (!(*(unsigned int (**)(uint64_t, const BIGNUM *, uint64_t, BN_CTX *))(*(_QWORD *)a1 + 272))(a1, v28, v37, ctx)|| !(*(unsigned int (**)(uint64_t, uint64_t, uint64_t, const BIGNUM *, BN_CTX *))(*(_QWORD *)a1 + 264))(a1, v36 + 8, v36 + 8, v28, ctx)|| !(*(unsigned int (**)(uint64_t, const BIGNUM *, const BIGNUM *, uint64_t, BN_CTX *))(*(_QWORD *)a1 + 264))(a1, v28, v28, v37, ctx)|| !(*(unsigned int (**)(uint64_t, uint64_t, uint64_t, const BIGNUM *, BN_CTX *))(*(_QWORD *)a1 + 264))(a1, v36 + 32,
                  v36 + 32,
                  v28,
                  ctx))
          {
            goto LABEL_58;
          }
          v38 = *(unsigned int (**)(uint64_t, uint64_t, BN_CTX *))(*(_QWORD *)a1 + 304);
          if (v38)
          {
            if (!v38(a1, v37, ctx))
              goto LABEL_58;
          }
          else if (!BN_one(v37))
          {
            goto LABEL_58;
          }
          *(_DWORD *)(v36 + 80) = 1;
        }
        ++a3;
        --v6;
      }
      while (v6);
      v26 = 1;
      goto LABEL_59;
    }
  }
  else
  {
    ERR_put_error(16, 4095, 3, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ecp_smpl.c", 1161);
  }
LABEL_58:
  v26 = 0;
LABEL_59:
  BN_CTX_end(ctx);
  for (; v17; --v17)
    BN_free((BIGNUM *)v15[v17]);
  free(v15);
  return v26;
}

uint64_t ec_GFp_simple_field_mul(uint64_t a1, BIGNUM *r, BIGNUM *a, BIGNUM *b, BN_CTX *a5)
{
  return BN_mod_mul(r, a, b, (const BIGNUM *)(a1 + 104), a5);
}

uint64_t ec_GFp_simple_field_sqr(uint64_t a1, BIGNUM *r, BIGNUM *a, BN_CTX *a4)
{
  return BN_mod_sqr(r, a, (const BIGNUM *)(a1 + 104), a4);
}

uint64_t ec_GFp_simple_blind_coordinates(uint64_t *a1, uint64_t a2, BN_CTX *ctx)
{
  BIGNUM *v6;
  BIGNUM *v7;
  BIGNUM *v8;
  BIGNUM *v9;
  BIGNUM *v10;
  uint64_t v11;
  unsigned int (*v12)(uint64_t *, BIGNUM *, BIGNUM *, BN_CTX *);
  uint64_t v13;

  BN_CTX_start(ctx);
  v6 = BN_CTX_get(ctx);
  if (!v6)
    goto LABEL_13;
  v7 = v6;
  v8 = BN_CTX_get(ctx);
  if (!v8)
    goto LABEL_13;
  v9 = v8;
  v10 = (BIGNUM *)BN_value_one();
  if (!bn_rand_interval(v7, v10, (BIGNUM *)(a1 + 13)))
    goto LABEL_13;
  v11 = *a1;
  v12 = *(unsigned int (**)(uint64_t *, BIGNUM *, BIGNUM *, BN_CTX *))(*a1 + 288);
  if (v12)
  {
    if (!v12(a1, v7, v7, ctx))
    {
LABEL_13:
      v13 = 0;
      goto LABEL_14;
    }
    v11 = *a1;
  }
  if (!(*(unsigned int (**)(uint64_t *, uint64_t, BIGNUM *, uint64_t, BN_CTX *))(v11 + 264))(a1, a2 + 56, v7, a2 + 56, ctx)|| !(*(unsigned int (**)(uint64_t *, BIGNUM *, BIGNUM *, BN_CTX *))(*a1 + 272))(a1, v9, v7, ctx)|| !(*(unsigned int (**)(uint64_t *, uint64_t, BIGNUM *, uint64_t, BN_CTX *))(*a1 + 264))(a1, a2 + 8, v9, a2 + 8, ctx)|| !(*(unsigned int (**)(uint64_t *, BIGNUM *, BIGNUM *, BIGNUM *, BN_CTX *))(*a1 + 264))(a1, v9, v9, v7, ctx)|| !(*(unsigned int (**)(uint64_t *, uint64_t, BIGNUM *, uint64_t, BN_CTX *))(*a1 + 264))(
          a1,
          a2 + 32,
          v9,
          a2 + 32,
          ctx))
  {
    goto LABEL_13;
  }
  *(_DWORD *)(a2 + 80) = 0;
  v13 = 1;
LABEL_14:
  BN_CTX_end(ctx);
  return v13;
}

BIGNUM *ec_GFp_simple_mul_generator_ct(uint64_t a1, uint64_t a2, const BIGNUM *a3, BN_CTX *ctx)
{
  return ec_GFp_simple_mul_ct(a1, a2, a3, 0, ctx);
}

BIGNUM *ec_GFp_simple_mul_ct(uint64_t a1, uint64_t a2, const BIGNUM *a3, uint64_t a4, BN_CTX *ctx)
{
  EC_POINT *v10;
  EC_POINT *v11;
  const EC_POINT *v12;
  BIGNUM *v13;
  BIGNUM *v14;
  BIGNUM *v15;
  size_t v16;
  int is_bit_set;
  unsigned int v18;
  size_t v19;
  int v20;
  int v21;
  uint64_t v22;
  int v23;
  int v24;
  int v25;
  int v26;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  int count;
  uint64_t v33;
  int n;
  BIGNUM *a;

  BN_CTX_start(ctx);
  v10 = EC_POINT_new((const EC_GROUP *)a1);
  v11 = v10;
  if (!v10)
    goto LABEL_40;
  v12 = a4 ? (const EC_POINT *)a4 : *(const EC_POINT **)(a1 + 8);
  if (!EC_POINT_copy(v10, v12))
    goto LABEL_40;
  BN_set_flags((uint64_t)v11 + 8, 4);
  BN_set_flags((uint64_t)v11 + 32, 4);
  BN_set_flags((uint64_t)v11 + 56, 4);
  v13 = BN_CTX_get(ctx);
  if (v13)
  {
    v14 = BN_CTX_get(ctx);
    if (v14)
    {
      v15 = v14;
      a = BN_CTX_get(ctx);
      if (a)
      {
        if (BN_mul(v13, (const BIGNUM *)(a1 + 16), (const BIGNUM *)(a1 + 40), ctx))
        {
          v33 = (uint64_t)v11 + 32;
          n = BN_num_bits(v13);
          v16 = v13->top + 2;
          if (bn_wexpand((uint64_t)a, v16))
          {
            if (bn_wexpand((uint64_t)v15, v16))
            {
              v31 = (uint64_t)v11 + 56;
              if (bn_copy(a, a3))
              {
                if ((BN_set_flags((uint64_t)a, 4), BN_num_bits(a) <= n) && !BN_is_negative((uint64_t)a)
                  || BN_nnmod(a, a, v13, ctx))
                {
                  if (BN_add(v15, a, v13))
                  {
                    BN_set_flags((uint64_t)v15, 4);
                    if (BN_add(a, v15, v13))
                    {
                      is_bit_set = BN_is_bit_set(v15, n);
                      if (BN_swap_ct(is_bit_set, (uint64_t)a, (uint64_t)v15, v16))
                      {
                        v18 = *(_DWORD *)(a1 + 112);
                        if (bn_wexpand((uint64_t)v11 + 8, v18))
                        {
                          v19 = (int)v18;
                          if (bn_wexpand(v33, (int)v18))
                          {
                            if (bn_wexpand(v31, (int)v18))
                            {
                              if (bn_wexpand(a2 + 8, (int)v18))
                              {
                                if (bn_wexpand(a2 + 32, (int)v18))
                                {
                                  if (bn_wexpand(a2 + 56, (int)v18))
                                  {
                                    if (ec_point_blind_coordinates(a1))
                                    {
                                      if (EC_POINT_copy((EC_POINT *)a2, v11))
                                      {
                                        v30 = a2 + 8;
                                        BN_set_flags(a2 + 8, 4);
                                        v29 = a2 + 32;
                                        BN_set_flags(a2 + 32, 4);
                                        v28 = a2 + 56;
                                        BN_set_flags(a2 + 56, 4);
                                        if (EC_POINT_dbl((const EC_GROUP *)a1, v11, v11, ctx))
                                        {
                                          count = 0;
                                          while (1)
                                          {
                                            v20 = n - 1;
                                            if (n < 1)
                                              break;
                                            --n;
                                            v21 = BN_is_bit_set(a, v20);
                                            v22 = v21 ^ count;
                                            if (!BN_swap_ct(v22, v30, (uint64_t)v11 + 8, v19))
                                              goto LABEL_40;
                                            if (!BN_swap_ct(v22, v29, v33, v19))
                                              goto LABEL_40;
                                            if (!BN_swap_ct(v22, v28, v31, v19))
                                              goto LABEL_40;
                                            v23 = *(_DWORD *)(a2 + 80);
                                            v24 = (*((_DWORD *)v11 + 20) ^ v23) & v22;
                                            *(_DWORD *)(a2 + 80) = v24 ^ v23;
                                            *((_DWORD *)v11 + 20) ^= v24;
                                            if (!EC_POINT_add((const EC_GROUP *)a1, v11, (const EC_POINT *)a2, v11, ctx))goto LABEL_40;
                                            v13 = 0;
                                            count = v21;
                                            if (!EC_POINT_dbl((const EC_GROUP *)a1, (EC_POINT *)a2, (const EC_POINT *)a2, ctx))goto LABEL_41;
                                          }
                                          if (BN_swap_ct(count, v30, (uint64_t)v11 + 8, v19)
                                            && BN_swap_ct(count, v29, v33, v19)
                                            && BN_swap_ct(count, v28, v31, v19))
                                          {
                                            v25 = *(_DWORD *)(a2 + 80);
                                            v26 = (*((_DWORD *)v11 + 20) ^ v25) & count;
                                            *(_DWORD *)(a2 + 80) = v26 ^ v25;
                                            *((_DWORD *)v11 + 20) ^= v26;
                                            v13 = (BIGNUM *)1;
                                            goto LABEL_41;
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
LABEL_40:
    v13 = 0;
  }
LABEL_41:
  EC_POINT_free(v11);
  BN_CTX_end(ctx);
  return v13;
}

uint64_t ec_GFp_simple_mul_double_nonct(EC_GROUP *a1, EC_POINT *a2, const BIGNUM *a3, uint64_t a4, _QWORD *a5, BN_CTX *a6)
{
  _QWORD *v7;
  uint64_t v8;

  v7 = a5;
  v8 = a4;
  return ec_wNAF_mul(a1, a2, a3, 1uLL, &v7, (uint64_t)&v8, a6);
}

const EC_METHOD *EC_GFp_simple_method(void)
{
  return (const EC_METHOD *)&ec_GFp_simple_method;
}

X509_PUBKEY *__cdecl d2i_X509_PUBKEY(X509_PUBKEY **a, const unsigned __int8 **in, uint64_t len)
{
  return (X509_PUBKEY *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &X509_PUBKEY_it);
}

int i2d_X509_PUBKEY(X509_PUBKEY *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &X509_PUBKEY_it);
}

X509_PUBKEY *X509_PUBKEY_new(void)
{
  return (X509_PUBKEY *)ASN1_item_new(&X509_PUBKEY_it);
}

void X509_PUBKEY_free(X509_PUBKEY *a)
{
  ASN1_item_free((ASN1_VALUE *)a, &X509_PUBKEY_it);
}

int X509_PUBKEY_set(X509_PUBKEY **x, EVP_PKEY *pkey)
{
  ASN1_VALUE **v3;
  X509_PUBKEY **v4;
  char *ptr;
  unsigned int (*v6)(X509_PUBKEY **, EVP_PKEY *);
  int v7;
  int v8;

  if (!x)
    return (int)x;
  v3 = (ASN1_VALUE **)x;
  x = (X509_PUBKEY **)ASN1_item_new(&X509_PUBKEY_it);
  if (!x)
    return (int)x;
  v4 = x;
  ptr = pkey->pkey.ptr;
  if (!ptr)
  {
    v7 = 111;
    v8 = 161;
LABEL_12:
    ERR_put_error(11, 4095, v7, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/x_pubkey.c", v8);
    ASN1_item_free((ASN1_VALUE *)v4, &X509_PUBKEY_it);
    LODWORD(x) = 0;
    return (int)x;
  }
  v6 = (unsigned int (*)(X509_PUBKEY **, EVP_PKEY *))*((_QWORD *)ptr + 5);
  if (!v6)
  {
    v7 = 124;
    v8 = 157;
    goto LABEL_12;
  }
  if (!v6(x, pkey))
  {
    v7 = 126;
    v8 = 153;
    goto LABEL_12;
  }
  if (*v3)
    ASN1_item_free(*v3, &X509_PUBKEY_it);
  *v3 = (ASN1_VALUE *)v4;
  LODWORD(x) = 1;
  return (int)x;
}

EVP_PKEY *X509_PUBKEY_get0(uint64_t a1)
{
  EVP_PKEY *v2;
  int v3;
  unsigned int (*v4)(EVP_PKEY *, uint64_t);
  int v5;
  int v6;

  if (!a1)
    goto LABEL_10;
  v2 = *(EVP_PKEY **)(a1 + 16);
  if (v2)
    return v2;
  if (!*(_QWORD *)(a1 + 8))
  {
LABEL_10:
    v2 = 0;
LABEL_16:
    EVP_PKEY_free(v2);
    return 0;
  }
  v2 = EVP_PKEY_new();
  if (!v2)
  {
    v5 = 65;
    v6 = 193;
LABEL_15:
    ERR_put_error(11, 4095, v5, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/x_pubkey.c", v6);
    goto LABEL_16;
  }
  v3 = OBJ_obj2nid(**(const ASN1_OBJECT ***)a1);
  if (!EVP_PKEY_set_type((uint64_t)v2, v3))
  {
    v5 = 111;
    v6 = 198;
    goto LABEL_15;
  }
  v4 = (unsigned int (*)(EVP_PKEY *, uint64_t))*((_QWORD *)v2->pkey.ptr + 4);
  if (!v4)
  {
    v5 = 124;
    v6 = 208;
    goto LABEL_15;
  }
  if (!v4(v2, a1))
  {
    v5 = 125;
    v6 = 204;
    goto LABEL_15;
  }
  CRYPTO_lock(9, 10, 0, 0);
  if (*(_QWORD *)(a1 + 16))
  {
    CRYPTO_lock(10, 10, 0, 0);
    EVP_PKEY_free(v2);
    return *(EVP_PKEY **)(a1 + 16);
  }
  else
  {
    *(_QWORD *)(a1 + 16) = v2;
    CRYPTO_lock(10, 10, 0, 0);
  }
  return v2;
}

EVP_PKEY *__cdecl X509_PUBKEY_get(X509_PUBKEY *key)
{
  EVP_PKEY *v1;
  EVP_PKEY *v2;

  v1 = X509_PUBKEY_get0((uint64_t)key);
  v2 = v1;
  if (v1)
    CRYPTO_add_lock(&v1->references, 1, 10, 0, 0);
  return v2;
}

BOOL pkey_pubkey_ex_new(EVP_PKEY **a1)
{
  EVP_PKEY *v2;

  v2 = EVP_PKEY_new();
  *a1 = v2;
  return v2 != 0;
}

void pkey_pubkey_ex_free(EVP_PKEY **a1)
{
  EVP_PKEY_free(*a1);
  *a1 = 0;
}

uint64_t pkey_pubkey_ex_d2i(EVP_PKEY **a1, unsigned __int8 **a2, uint64_t len, uint64_t a4)
{
  return pubkey_ex_d2i(0, a1, a2, len, a4);
}

uint64_t pkey_pubkey_ex_i2d(dsa_st **a1, unsigned __int8 **a2)
{
  return pubkey_ex_i2d(0, a1, a2);
}

EVP_PKEY *__cdecl d2i_PUBKEY(EVP_PKEY **a, const unsigned __int8 **pp, uint64_t length)
{
  return (EVP_PKEY *)ASN1_item_d2i((ASN1_VALUE **)a, pp, length, &EVP_PKEY_PUBKEY_it);
}

int i2d_PUBKEY(EVP_PKEY *a, unsigned __int8 **pp)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, pp, &EVP_PKEY_PUBKEY_it);
}

EVP_PKEY *__cdecl d2i_PUBKEY_bio(BIO *bp, EVP_PKEY **a)
{
  return (EVP_PKEY *)ASN1_item_d2i_bio(&EVP_PKEY_PUBKEY_it, bp, a);
}

int i2d_PUBKEY_bio(BIO *bp, EVP_PKEY *pkey)
{
  return ASN1_item_i2d_bio(&EVP_PKEY_PUBKEY_it, bp, pkey);
}

EVP_PKEY *__cdecl d2i_PUBKEY_fp(FILE *fp, EVP_PKEY **a)
{
  return (EVP_PKEY *)ASN1_item_d2i_fp(&EVP_PKEY_PUBKEY_it, fp, a);
}

int i2d_PUBKEY_fp(FILE *fp, EVP_PKEY *pkey)
{
  return ASN1_item_i2d_fp(&EVP_PKEY_PUBKEY_it, fp, pkey);
}

BOOL rsa_pubkey_ex_new(RSA **a1)
{
  RSA *v2;

  v2 = RSA_new();
  *a1 = v2;
  return v2 != 0;
}

void rsa_pubkey_ex_free(RSA **a1)
{
  RSA_free(*a1);
  *a1 = 0;
}

uint64_t rsa_pubkey_ex_d2i(EVP_PKEY **a1, unsigned __int8 **a2, uint64_t len, uint64_t a4)
{
  return pubkey_ex_d2i(6, a1, a2, len, a4);
}

uint64_t rsa_pubkey_ex_i2d(dsa_st **a1, unsigned __int8 **a2)
{
  return pubkey_ex_i2d(6, a1, a2);
}

RSA *__cdecl d2i_RSA_PUBKEY(RSA **a, const unsigned __int8 **pp, uint64_t length)
{
  return (RSA *)ASN1_item_d2i((ASN1_VALUE **)a, pp, length, &RSA_PUBKEY_it);
}

int i2d_RSA_PUBKEY(RSA *a, unsigned __int8 **pp)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, pp, &RSA_PUBKEY_it);
}

RSA *__cdecl d2i_RSA_PUBKEY_bio(BIO *bp, RSA **rsa)
{
  return (RSA *)ASN1_item_d2i_bio(&RSA_PUBKEY_it, bp, rsa);
}

int i2d_RSA_PUBKEY_bio(BIO *bp, RSA *rsa)
{
  return ASN1_item_i2d_bio(&RSA_PUBKEY_it, bp, rsa);
}

RSA *__cdecl d2i_RSA_PUBKEY_fp(FILE *fp, RSA **rsa)
{
  return (RSA *)ASN1_item_d2i_fp(&RSA_PUBKEY_it, fp, rsa);
}

int i2d_RSA_PUBKEY_fp(FILE *fp, RSA *rsa)
{
  return ASN1_item_i2d_fp(&RSA_PUBKEY_it, fp, rsa);
}

BOOL dsa_pubkey_ex_new(DSA **a1)
{
  DSA *v2;

  v2 = DSA_new();
  *a1 = v2;
  return v2 != 0;
}

void dsa_pubkey_ex_free(DSA **a1)
{
  DSA_free(*a1);
  *a1 = 0;
}

uint64_t dsa_pubkey_ex_d2i(EVP_PKEY **a1, unsigned __int8 **a2, uint64_t len, uint64_t a4)
{
  return pubkey_ex_d2i(116, a1, a2, len, a4);
}

uint64_t dsa_pubkey_ex_i2d(dsa_st **a1, unsigned __int8 **a2)
{
  return pubkey_ex_i2d(116, a1, a2);
}

DSA *__cdecl d2i_DSA_PUBKEY(DSA **a, const unsigned __int8 **pp, uint64_t length)
{
  return (DSA *)ASN1_item_d2i((ASN1_VALUE **)a, pp, length, &DSA_PUBKEY_it);
}

int i2d_DSA_PUBKEY(DSA *a, unsigned __int8 **pp)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, pp, &DSA_PUBKEY_it);
}

DSA *__cdecl d2i_DSA_PUBKEY_bio(BIO *bp, DSA **dsa)
{
  return (DSA *)ASN1_item_d2i_bio(&DSA_PUBKEY_it, bp, dsa);
}

int i2d_DSA_PUBKEY_bio(BIO *bp, DSA *dsa)
{
  return ASN1_item_i2d_bio(&DSA_PUBKEY_it, bp, dsa);
}

DSA *__cdecl d2i_DSA_PUBKEY_fp(FILE *fp, DSA **dsa)
{
  return (DSA *)ASN1_item_d2i_fp(&DSA_PUBKEY_it, fp, dsa);
}

int i2d_DSA_PUBKEY_fp(FILE *fp, DSA *dsa)
{
  return ASN1_item_i2d_fp(&DSA_PUBKEY_it, fp, dsa);
}

BOOL ec_pubkey_ex_new(EC_KEY **a1)
{
  EC_KEY *v2;

  v2 = EC_KEY_new();
  *a1 = v2;
  return v2 != 0;
}

void ec_pubkey_ex_free(EC_KEY **a1)
{
  EC_KEY_free(*a1);
  *a1 = 0;
}

uint64_t ec_pubkey_ex_d2i(EVP_PKEY **a1, unsigned __int8 **a2, uint64_t len, uint64_t a4)
{
  return pubkey_ex_d2i(408, a1, a2, len, a4);
}

uint64_t ec_pubkey_ex_i2d(dsa_st **a1, unsigned __int8 **a2)
{
  return pubkey_ex_i2d(408, a1, a2);
}

EC_KEY *__cdecl d2i_EC_PUBKEY(EC_KEY **a, const unsigned __int8 **pp, uint64_t length)
{
  return ASN1_item_d2i(a, pp, length, &EC_PUBKEY_it);
}

int i2d_EC_PUBKEY(EC_KEY *a, unsigned __int8 **pp)
{
  return ASN1_item_i2d(a, pp, &EC_PUBKEY_it);
}

EC_KEY *__cdecl d2i_EC_PUBKEY_bio(BIO *bp, EC_KEY **eckey)
{
  return (EC_KEY *)ASN1_item_d2i_bio(&EC_PUBKEY_it, bp, eckey);
}

int i2d_EC_PUBKEY_bio(BIO *bp, EC_KEY *eckey)
{
  return ASN1_item_i2d_bio(&EC_PUBKEY_it, bp, eckey);
}

EC_KEY *__cdecl d2i_EC_PUBKEY_fp(FILE *fp, EC_KEY **eckey)
{
  return (EC_KEY *)ASN1_item_d2i_fp(&EC_PUBKEY_it, fp, eckey);
}

int i2d_EC_PUBKEY_fp(FILE *fp, EC_KEY *eckey)
{
  return ASN1_item_i2d_fp(&EC_PUBKEY_it, fp, eckey);
}

uint64_t X509_PUBKEY_set0_param(uint64_t a1, ASN1_OBJECT *a2, int a3, void *a4, void *a5, int a6)
{
  uint64_t result;

  result = X509_ALGOR_set0(*(X509_ALGOR **)a1, a2, a3, a4);
  if ((_DWORD)result)
  {
    if (a5)
    {
      ASN1_STRING_set0(*(ASN1_STRING **)(a1 + 8), a5, a6);
      return asn1_abs_set_unused_bits(*(_QWORD *)(a1 + 8), 0);
    }
    else
    {
      return 1;
    }
  }
  return result;
}

uint64_t X509_PUBKEY_get0_param(_QWORD *a1, _QWORD *a2, _DWORD *a3, _QWORD *a4, uint64_t a5)
{
  if (a1)
    *a1 = **(_QWORD **)a5;
  if (a2)
  {
    *a2 = *(_QWORD *)(*(_QWORD *)(a5 + 8) + 8);
    *a3 = **(_DWORD **)(a5 + 8);
  }
  if (a4)
    *a4 = *(_QWORD *)a5;
  return 1;
}

uint64_t pubkey_cb(int a1, uint64_t a2)
{
  if (a1 == 3)
    EVP_PKEY_free(*(EVP_PKEY **)(*(_QWORD *)a2 + 16));
  return 1;
}

uint64_t pubkey_ex_d2i(int a1, EVP_PKEY **a2, unsigned __int8 **a3, uint64_t len, uint64_t a5)
{
  uint64_t v9;
  ASN1_VALUE *v10;
  ASN1_VALUE *v11;
  EVP_PKEY *v12;
  EVP_PKEY *v13;
  uint64_t v14;
  EVP_PKEY *v15;
  EVP_PKEY *v16;
  unsigned __int8 *in;

  v9 = *(_QWORD *)(a5 + 32);
  in = *a3;
  v10 = ASN1_item_d2i(0, (const unsigned __int8 **)&in, len, &X509_PUBKEY_it);
  v11 = v10;
  if (!v10)
  {
    v13 = 0;
    goto LABEL_16;
  }
  v12 = X509_PUBKEY_get((X509_PUBKEY *)v10);
  v13 = v12;
  if (!v12)
  {
LABEL_16:
    v14 = 0;
    goto LABEL_17;
  }
  v14 = 0;
  if (a1 > 115)
  {
    if (a1 == 408)
    {
      v15 = (EVP_PKEY *)EVP_PKEY_get1_EC_KEY(v12);
      if (v15)
        goto LABEL_12;
    }
    else
    {
      if (a1 != 116)
        goto LABEL_17;
      v15 = (EVP_PKEY *)EVP_PKEY_get1_DSA(v12);
      if (v15)
      {
LABEL_12:
        v16 = v13;
        v13 = v15;
LABEL_14:
        (*(void (**)(EVP_PKEY **, uint64_t))(v9 + 16))(a2, a5);
        *a2 = v13;
        *a3 = in;
        v14 = 1;
        v13 = v16;
        goto LABEL_17;
      }
    }
    goto LABEL_16;
  }
  if (!a1)
  {
    v16 = 0;
    goto LABEL_14;
  }
  if (a1 == 6)
  {
    v15 = (EVP_PKEY *)EVP_PKEY_get1_RSA(v12);
    if (!v15)
      goto LABEL_16;
    goto LABEL_12;
  }
LABEL_17:
  EVP_PKEY_free(v13);
  ASN1_item_free(v11, &X509_PUBKEY_it);
  return v14;
}

uint64_t pubkey_ex_i2d(int a1, dsa_st **a2, unsigned __int8 **a3)
{
  EVP_PKEY *v6;
  EVP_PKEY *v7;
  uint64_t v8;
  int v9;
  dsa_st *v10;
  X509_PUBKEY *x;

  x = 0;
  v6 = EVP_PKEY_new();
  v7 = v6;
  v8 = 0xFFFFFFFFLL;
  if (!v6)
    goto LABEL_14;
  if (a1 > 115)
  {
    if (a1 == 116)
    {
      v9 = EVP_PKEY_set1_DSA(v6, *a2);
    }
    else
    {
      if (a1 != 408)
        goto LABEL_14;
      v9 = EVP_PKEY_set1_EC_KEY(v6, (ec_key_st *)*a2);
    }
LABEL_11:
    v10 = (dsa_st *)v7;
    if (!v9)
      goto LABEL_14;
    goto LABEL_12;
  }
  if (a1)
  {
    if (a1 != 6)
      goto LABEL_14;
    v9 = EVP_PKEY_set1_RSA(v6, (rsa_st *)*a2);
    goto LABEL_11;
  }
  v10 = *a2;
LABEL_12:
  if (X509_PUBKEY_set(&x, (EVP_PKEY *)v10))
    v8 = ASN1_item_i2d((ASN1_VALUE *)x, a3, &X509_PUBKEY_it);
LABEL_14:
  EVP_PKEY_free(v7);
  ASN1_item_free((ASN1_VALUE *)x, &X509_PUBKEY_it);
  return v8;
}

uint64_t STREEBOG512_Final(uint64_t a1, uint64_t a2)
{
  int v4;
  _BYTE *v5;
  uint64_t i;
  int v7;
  uint64_t k;
  uint64_t j;
  _OWORD v11[4];
  uint64_t v12;

  v12 = *MEMORY[0x24BDAC8D0];
  memset(v11, 0, sizeof(v11));
  v4 = *(_DWORD *)(a2 + 64);
  if (v4 == 64)
  {
    streebog_single_block((_QWORD *)a2, (_OWORD *)a2, 0x200uLL);
    v4 = *(_DWORD *)(a2 + 64) - 64;
    *(_DWORD *)(a2 + 64) = v4;
  }
  v5 = (_BYTE *)(a2 + v4);
  *v5 = 1;
  bzero(v5 + 1, 63 - v4);
  streebog_single_block((_QWORD *)a2, (_OWORD *)a2, (8 * *(_DWORD *)(a2 + 64)));
  gN((_QWORD *)(a2 + 72), (_QWORD *)(a2 + 136), v11);
  gN((_QWORD *)(a2 + 72), (_QWORD *)(a2 + 200), v11);
  for (i = 0; i != 64; i += 8)
    *(_QWORD *)(a2 + i + 72) = bswap64(*(_QWORD *)(a2 + i + 72));
  if (!a1)
    return 0;
  v7 = *(_DWORD *)(a2 + 68);
  if (v7 == 32)
  {
    for (j = 0; j != 32; j += 8)
      *(_QWORD *)(a1 + j) = bswap64(*(_QWORD *)(a2 + 104 + j));
    return 1;
  }
  if (v7 != 64)
    return 0;
  for (k = 0; k != 64; k += 8)
    *(_QWORD *)(a1 + k) = bswap64(*(_QWORD *)(a2 + 72 + k));
  return 1;
}

uint64_t *streebog_single_block(_QWORD *a1, _OWORD *a2, unint64_t a3)
{
  __int128 v5;
  __int128 v6;
  uint64_t *result;
  uint64_t v8;
  BOOL v9;
  unint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  BOOL v14;
  uint64_t v15;
  _BOOL8 v16;
  unint64_t v17;
  unint64_t v18;
  _QWORD *v19;
  _BOOL8 v20;
  _OWORD v21[4];
  uint64_t v22;

  v22 = *MEMORY[0x24BDAC8D0];
  v5 = a2[1];
  v21[0] = *a2;
  v21[1] = v5;
  v6 = a2[3];
  v21[2] = a2[2];
  v21[3] = v6;
  result = gN(a1 + 9, v21, a1 + 17);
  v8 = a1[17];
  v9 = __CFADD__(v8, a3);
  v10 = v8 + a3;
  a1[17] = v10;
  if (v9 || v10 < a3)
  {
    v11 = 0;
    v12 = a1 + 18;
    do
    {
      v13 = v12[v11] + 1;
      v12[v11] = v13;
      if (v13)
        break;
      v14 = v11++ == 6;
    }
    while (!v14);
  }
  v15 = 0;
  v16 = 0;
  v17 = *(_QWORD *)&v21[0];
  v18 = a1[25] + *(_QWORD *)&v21[0];
  a1[25] = v18;
  v19 = a1 + 26;
  do
  {
    v14 = v18 == v17;
    v20 = v18 < v17;
    if (!v14)
      v16 = v20;
    v17 = *(_QWORD *)((char *)v21 + v15 * 8 + 8);
    v18 = v19[v15] + v16 + v17;
    v19[v15++] = v18;
  }
  while (v15 != 7);
  return result;
}

uint64_t *gN(_QWORD *a1, _QWORD *a2, _QWORD *a3)
{
  uint64_t v5;
  uint64_t *result;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19[8];
  uint64_t v20[9];

  v20[8] = *MEMORY[0x24BDAC8D0];
  transform(v20, a1, a3);
  transform(v19, v20, a2);
  transform(v20, v20, C16);
  v5 = 8u;
  do
  {
    transform(v19, v20, v19);
    result = transform(v20, v20, &C16[v5]);
    v5 += 8;
  }
  while (v5 != 96);
  v7 = v19[1];
  v8 = v20[1];
  v9 = a1[1];
  *a1 ^= v20[0] ^ v19[0] ^ *a2;
  a1[1] = v8 ^ v7 ^ a2[1] ^ v9;
  v10 = v19[3];
  v11 = v20[3];
  v12 = a1[3];
  a1[2] ^= v20[2] ^ v19[2] ^ a2[2];
  a1[3] = v11 ^ v10 ^ a2[3] ^ v12;
  v13 = v19[5];
  v14 = v20[5];
  v15 = a1[5];
  a1[4] ^= v20[4] ^ v19[4] ^ a2[4];
  a1[5] = v14 ^ v13 ^ a2[5] ^ v15;
  v16 = v19[7];
  v17 = v20[7];
  v18 = a1[7];
  a1[6] ^= v20[6] ^ v19[6] ^ a2[6];
  a1[7] = v17 ^ v16 ^ a2[7] ^ v18;
  return result;
}

uint64_t STREEBOG512_Update(_DWORD *__dst, char *__src, size_t __n)
{
  size_t v3;
  char *v4;
  uint64_t v6;
  size_t v7;
  char *v8;
  size_t v9;
  char *v10;
  char *v11;

  if (__n)
  {
    v3 = __n;
    v4 = __src;
    v6 = __dst[16];
    if ((_DWORD)v6)
    {
      v7 = (64 - v6);
      v8 = (char *)__dst + v6;
      if (__n < v7)
      {
        memcpy(v8, __src, __n);
        LODWORD(v3) = __dst[16] + v3;
LABEL_12:
        __dst[16] = v3;
        return 1;
      }
      memcpy(v8, __src, (64 - v6));
      __dst[16] = 0;
      v4 += v7;
      streebog_single_block(__dst, __dst, 0x200uLL);
      v3 -= v7;
    }
    if (v3 >= 0x40)
    {
      v9 = v3 >> 6;
      v10 = v4;
      do
      {
        streebog_single_block(__dst, v10, 0x200uLL);
        v10 += 64;
        --v9;
      }
      while (v9);
      v11 = &v4[v3];
      v3 &= 0x3Fu;
      v4 = &v11[-v3];
    }
    if (v3)
    {
      memcpy(__dst, v4, v3);
      goto LABEL_12;
    }
  }
  return 1;
}

uint64_t STREEBOG256_Update(_DWORD *a1, char *a2, size_t a3)
{
  STREEBOG512_Update(a1, a2, a3);
  return 1;
}

uint64_t *STREEBOG512_Transform(_QWORD *a1, _OWORD *a2)
{
  return streebog_single_block(a1, a2, 0x200uLL);
}

uint64_t STREEBOG256_Init(uint64_t a1)
{
  __int128 v1;

  *(_QWORD *)(a1 + 256) = 0;
  *(_OWORD *)(a1 + 224) = 0u;
  *(_OWORD *)(a1 + 240) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 208) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_QWORD *)&v1 = 0x101010101010101;
  *((_QWORD *)&v1 + 1) = 0x101010101010101;
  *(_OWORD *)(a1 + 120) = v1;
  *(_OWORD *)(a1 + 104) = v1;
  *(_OWORD *)(a1 + 88) = v1;
  *(_OWORD *)(a1 + 72) = v1;
  *(_DWORD *)(a1 + 68) = 32;
  return 1;
}

uint64_t STREEBOG512_Init(uint64_t a1)
{
  *(_QWORD *)(a1 + 256) = 0;
  *(_OWORD *)(a1 + 224) = 0u;
  *(_OWORD *)(a1 + 240) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 208) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 120) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_QWORD *)(a1 + 64) = 0x4000000000;
  return 1;
}

void *STREEBOG256(char *__src, size_t __n, void *a3)
{
  void *v3;
  __int128 v4;
  _OWORD v6[4];
  uint64_t v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  uint64_t v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  uint64_t v20;

  v20 = 0;
  v18 = 0u;
  v19 = 0u;
  if (a3)
    v3 = a3;
  else
    v3 = &STREEBOG256_m;
  v16 = 0uLL;
  v17 = 0uLL;
  v14 = 0uLL;
  v15 = 0uLL;
  v12 = 0;
  v13 = 0uLL;
  v7 = 0x2000000000;
  memset(v6, 0, sizeof(v6));
  *(_QWORD *)&v4 = 0x101010101010101;
  *((_QWORD *)&v4 + 1) = 0x101010101010101;
  v11 = v4;
  v10 = v4;
  v9 = v4;
  v8 = v4;
  STREEBOG512_Update(v6, __src, __n);
  STREEBOG512_Final((uint64_t)v3, (uint64_t)v6);
  explicit_bzero(v6, 0x108uLL);
  return v3;
}

void *STREEBOG512(char *a1, size_t a2, void *a3)
{
  void *v5;
  _OWORD v7[16];
  uint64_t v8;

  v8 = 0;
  memset(&v7[2], 0, 224);
  if (a3)
    v5 = a3;
  else
    v5 = &STREEBOG512_m;
  memset(v7, 0, 32);
  STREEBOG512_Init((uint64_t)v7);
  STREEBOG512_Update(v7, a1, a2);
  STREEBOG512_Final((uint64_t)v5, (uint64_t)v7);
  explicit_bzero(v7, 0x108uLL);
  return v5;
}

uint64_t *transform(uint64_t *result, _QWORD *a2, _QWORD *a3)
{
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  char *v15;
  uint64_t v16;
  char *v17;

  v3 = *a3 ^ *a2;
  v4 = a3[1] ^ a2[1];
  v5 = a3[2] ^ a2[2];
  v6 = a3[3] ^ a2[3];
  v7 = a3[4] ^ a2[4];
  v8 = a3[5] ^ a2[5];
  v9 = a3[6] ^ a2[6];
  v10 = a3[7] ^ a2[7];
  v11 = A_PI_table[(*((_BYTE *)a3 + 8) ^ *((_BYTE *)a2 + 8)) + 256] ^ A_PI_table[(*(_BYTE *)a3 ^ *(_BYTE *)a2)];
  v12 = A_PI_table[(*((_BYTE *)a3 + 16) ^ *((_BYTE *)a2 + 16)) + 512];
  v13 = (char *)&A_PI_table[768];
  v14 = v12 ^ *(_QWORD *)&v13[8 * v6];
  v15 = (char *)&A_PI_table[1280];
  v16 = v11 ^ v14;
  v17 = (char *)&A_PI_table[1792];
  *result = v16 ^ qword_22D6A89D8[v7] ^ *(_QWORD *)&v15[8 * v8] ^ qword_22D6A99D8[v9] ^ *(_QWORD *)&v17[8 * v10];
  result[1] = A_PI_table[BYTE1(v4) + 256] ^ A_PI_table[BYTE1(v3)] ^ A_PI_table[BYTE1(v5) + 512] ^ *(_QWORD *)&v13[8 * BYTE1(v6)] ^ qword_22D6A89D8[BYTE1(v7)] ^ *(_QWORD *)&v15[8 * BYTE1(v8)] ^ qword_22D6A99D8[BYTE1(v9)] ^ *(_QWORD *)&v17[8 * BYTE1(v10)];
  result[2] = A_PI_table[BYTE2(v4) + 256] ^ A_PI_table[BYTE2(v3)] ^ A_PI_table[BYTE2(v5) + 512] ^ *(_QWORD *)&v13[8 * BYTE2(v6)] ^ qword_22D6A89D8[BYTE2(v7)] ^ *(_QWORD *)&v15[8 * BYTE2(v8)] ^ qword_22D6A99D8[BYTE2(v9)] ^ *(_QWORD *)&v17[8 * BYTE2(v10)];
  result[3] = A_PI_table[BYTE3(v4) + 256] ^ A_PI_table[BYTE3(v3)] ^ A_PI_table[BYTE3(v5) + 512] ^ *(_QWORD *)&v13[8 * BYTE3(v6)] ^ qword_22D6A89D8[BYTE3(v7)] ^ *(_QWORD *)&v15[8 * BYTE3(v8)] ^ qword_22D6A99D8[BYTE3(v9)] ^ *(_QWORD *)&v17[8 * BYTE3(v10)];
  result[4] = A_PI_table[BYTE4(v4) + 256] ^ A_PI_table[BYTE4(v3)] ^ A_PI_table[BYTE4(v5) + 512] ^ *(_QWORD *)&v13[8 * BYTE4(v6)] ^ qword_22D6A89D8[BYTE4(v7)] ^ *(_QWORD *)&v15[8 * BYTE4(v8)] ^ qword_22D6A99D8[BYTE4(v9)] ^ *(_QWORD *)&v17[8 * BYTE4(v10)];
  result[5] = A_PI_table[BYTE5(v4) + 256] ^ A_PI_table[BYTE5(v3)] ^ A_PI_table[BYTE5(v5) + 512] ^ *(_QWORD *)&v13[8 * BYTE5(v6)] ^ qword_22D6A89D8[BYTE5(v7)] ^ *(_QWORD *)&v15[8 * BYTE5(v8)] ^ qword_22D6A99D8[BYTE5(v9)] ^ *(_QWORD *)&v17[8 * BYTE5(v10)];
  result[6] = A_PI_table[BYTE6(v4) + 256] ^ A_PI_table[BYTE6(v3)] ^ A_PI_table[BYTE6(v5) + 512] ^ *(_QWORD *)&v13[8 * BYTE6(v6)] ^ qword_22D6A89D8[BYTE6(v7)] ^ *(_QWORD *)&v15[8 * BYTE6(v8)] ^ qword_22D6A99D8[BYTE6(v9)] ^ *(_QWORD *)&v17[8 * BYTE6(v10)];
  result[7] = *(_QWORD *)((char *)&A_PI_table[256] + ((v4 >> 53) & 0x7F8)) ^ *(_QWORD *)((char *)A_PI_table
                                                                                       + ((v3 >> 53) & 0x7F8)) ^ *(_QWORD *)((char *)&A_PI_table[512] + ((v5 >> 53) & 0x7F8)) ^ *(_QWORD *)&v13[(v6 >> 53) & 0x7F8] ^ *(_QWORD *)((char *)qword_22D6A89D8 + ((v7 >> 53) & 0x7F8)) ^ *(_QWORD *)&v15[(v8 >> 53) & 0x7F8] ^ *(_QWORD *)((char *)qword_22D6A99D8 + ((v9 >> 53) & 0x7F8)) ^ *(_QWORD *)&v17[(v10 >> 53) & 0x7F8];
  return result;
}

void ERR_load_RSA_strings(void)
{
  if (!ERR_func_error_string(RSA_str_functs))
  {
    ERR_load_strings(0, (ERR_STRING_DATA *)&RSA_str_functs);
    ERR_load_strings(0, (ERR_STRING_DATA *)&RSA_str_reasons);
  }
}

uint64_t i2r_PKEY_USAGE_PERIOD(int a1, ASN1_GENERALIZEDTIME **a2, BIO *bio, int a4)
{
  BIO_printf(bio, "%*s", a4, "");
  if (*a2)
  {
    BIO_write(bio, "Not Before: ", 12);
    ASN1_GENERALIZEDTIME_print(bio, *a2);
    if (a2[1])
      BIO_write(bio, ", ", 2);
  }
  if (a2[1])
  {
    BIO_write(bio, "Not After: ", 11);
    ASN1_GENERALIZEDTIME_print(bio, a2[1]);
  }
  return 1;
}

PKEY_USAGE_PERIOD *__cdecl d2i_PKEY_USAGE_PERIOD(PKEY_USAGE_PERIOD **a, const unsigned __int8 **in, uint64_t len)
{
  return (PKEY_USAGE_PERIOD *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &PKEY_USAGE_PERIOD_it);
}

int i2d_PKEY_USAGE_PERIOD(PKEY_USAGE_PERIOD *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &PKEY_USAGE_PERIOD_it);
}

PKEY_USAGE_PERIOD *PKEY_USAGE_PERIOD_new(void)
{
  return (PKEY_USAGE_PERIOD *)ASN1_item_new(&PKEY_USAGE_PERIOD_it);
}

void PKEY_USAGE_PERIOD_free(PKEY_USAGE_PERIOD *a)
{
  ASN1_item_free((ASN1_VALUE *)a, &PKEY_USAGE_PERIOD_it);
}

BOOL CMS_SignedData_init(ASN1_OBJECT **a1)
{
  return cms_signed_data_init(a1) != 0;
}

uint64_t cms_signed_data_init(ASN1_OBJECT **a1)
{
  ASN1_VALUE *v3;
  ASN1_OBJECT *v4;
  ASN1_OBJECT *v5;

  if (a1[1])
    return cms_get0_signed((uint64_t)a1);
  v3 = ASN1_item_new(&CMS_SignedData_it);
  a1[1] = (ASN1_OBJECT *)v3;
  if (v3)
  {
    *(_QWORD *)v3 = 1;
    v4 = OBJ_nid2obj(21);
    v5 = *a1;
    **(_QWORD **)&a1[1]->nid = v4;
    *(_DWORD *)(*(_QWORD *)&a1[1]->nid + 16) = 1;
    ASN1_OBJECT_free(v5);
    *a1 = OBJ_nid2obj(22);
    return (uint64_t)a1[1];
  }
  else
  {
    ERR_put_error(46, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/cms/cms_sd.c", 86);
    return 0;
  }
}

uint64_t cms_set1_SignerIdentifier(uint64_t a1, X509 *a2, int a3)
{
  uint64_t result;

  if (a3 == 1)
  {
    result = cms_set1_keyid((ASN1_OCTET_STRING **)(a1 + 8), a2);
    if (!(_DWORD)result)
      return result;
    goto LABEL_6;
  }
  if (a3)
  {
    ERR_put_error(46, 4095, 150, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/cms/cms_sd.c", 216);
    return 0;
  }
  result = cms_set1_ias((ASN1_VALUE **)(a1 + 8), a2);
  if ((_DWORD)result)
  {
LABEL_6:
    *(_DWORD *)a1 = a3;
    return 1;
  }
  return result;
}

uint64_t cms_SignerIdentifier_get0_signer_id(uint64_t a1, _QWORD *a2, _QWORD *a3, _QWORD *a4)
{
  _QWORD *v4;

  if (*(_DWORD *)a1 == 1)
  {
    if (!a2)
      return 1;
    v4 = (_QWORD *)(a1 + 8);
    a4 = a2;
LABEL_9:
    *a4 = *v4;
    return 1;
  }
  if (!*(_DWORD *)a1)
  {
    if (a3)
      *a3 = **(_QWORD **)(a1 + 8);
    if (!a4)
      return 1;
    v4 = (_QWORD *)(*(_QWORD *)(a1 + 8) + 8);
    goto LABEL_9;
  }
  return 0;
}

uint64_t cms_SignerIdentifier_cert_cmp(uint64_t a1, X509 *a2)
{
  if (*(_DWORD *)a1 == 1)
    return cms_keyid_cert_cmp(*(ASN1_OCTET_STRING **)(a1 + 8), a2);
  if (*(_DWORD *)a1)
    return 0xFFFFFFFFLL;
  return cms_ias_cert_cmp(*(_QWORD *)(a1 + 8), a2);
}

ASN1_VALUE *CMS_add1_signer(ASN1_OBJECT **a1, X509 *x509, EVP_PKEY *pkey, const EVP_MD *a4, int a5)
{
  uint64_t v10;
  uint64_t v11;
  ASN1_VALUE *v12;
  void *v13;
  int v14;
  int v15;
  int v16;
  int v17;
  char *v18;
  int v19;
  const char *v20;
  const EVP_MD *digestbyname;
  X509_ALGOR *v22;
  X509_ALGOR *v23;
  STACK *v24;
  unsigned int v25;
  STACK *v26;
  _BOOL4 v27;
  int v28;
  uint64_t *v29;
  STACK *v30;
  ASN1_OBJECT *paobj;

  if (!X509_check_private_key(x509, pkey))
  {
    ERR_put_error(46, 4095, 136, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/cms/cms_sd.c", 285);
    return 0;
  }
  v10 = cms_signed_data_init(a1);
  if (!v10)
  {
    v12 = 0;
    goto LABEL_57;
  }
  v11 = v10;
  v12 = ASN1_item_new(&CMS_SignerInfo_it);
  if (!v12)
    goto LABEL_55;
  X509_check_purpose(x509, -1, -1);
  X509_up_ref((uint64_t)x509);
  EVP_PKEY_up_ref((uint64_t)pkey);
  *((_QWORD *)v12 + 7) = x509;
  *((_QWORD *)v12 + 8) = pkey;
  v13 = EVP_MD_CTX_new();
  *((_QWORD *)v12 + 10) = 0;
  *((_QWORD *)v12 + 9) = v13;
  if (!v13)
  {
    v15 = 65;
    v16 = 306;
    goto LABEL_56;
  }
  if ((a5 & 0x10000) != 0)
  {
    *(_QWORD *)v12 = 3;
    if (*(uint64_t *)v11 <= 2)
      *(_QWORD *)v11 = 3;
    v14 = 1;
  }
  else
  {
    v14 = 0;
    *(_QWORD *)v12 = 1;
  }
  if (!cms_set1_SignerIdentifier(*((_QWORD *)v12 + 1), x509, v14))
    goto LABEL_57;
  if (!a4)
  {
    LODWORD(paobj) = 0;
    if ((int)EVP_PKEY_get_default_digest_nid((uint64_t)pkey) < 1)
      goto LABEL_57;
    v20 = OBJ_nid2sn((int)paobj);
    digestbyname = EVP_get_digestbyname(v20);
    if (digestbyname)
    {
      a4 = digestbyname;
      goto LABEL_15;
    }
    v15 = 128;
    v16 = 329;
LABEL_56:
    ERR_put_error(46, 4095, v15, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/cms/cms_sd.c", v16);
    goto LABEL_57;
  }
LABEL_15:
  X509_ALGOR_set_md(*((X509_ALGOR **)v12 + 2), a4);
  if (sk_num(*(const STACK **)(v11 + 8)) < 1)
  {
    v17 = 0;
  }
  else
  {
    v17 = 0;
    do
    {
      paobj = 0;
      v18 = sk_value(*(const STACK **)(v11 + 8), v17);
      X509_ALGOR_get0(&paobj, 0, 0, (X509_ALGOR *)v18);
      v19 = OBJ_obj2nid(paobj);
      if (v19 == EVP_MD_type(a4))
        break;
      ++v17;
    }
    while (v17 < sk_num(*(const STACK **)(v11 + 8)));
  }
  if (v17 == sk_num(*(const STACK **)(v11 + 8)))
  {
    v22 = X509_ALGOR_new();
    if (!v22)
      goto LABEL_55;
    v23 = v22;
    X509_ALGOR_set_md(v22, a4);
    if (!sk_push(*(STACK **)(v11 + 8), (char *)v23))
    {
      X509_ALGOR_free(v23);
      goto LABEL_55;
    }
  }
  if ((a5 & 0x40000) == 0 && !cms_sd_asn1_ctrl((uint64_t)v12))
    goto LABEL_57;
  if ((a5 & 0x100) != 0)
    goto LABEL_39;
  if (!*((_QWORD *)v12 + 3))
  {
    v24 = sk_new_null();
    *((_QWORD *)v12 + 3) = v24;
    if (!v24)
      goto LABEL_55;
  }
  if ((a5 & 0x200) == 0)
  {
    paobj = 0;
    v25 = CMS_add_standard_smimecap((STACK **)&paobj);
    v26 = (STACK *)paobj;
    if (v25)
    {
      v27 = CMS_add_smimecap((uint64_t)v12, (X509_ALGORS *)paobj);
      sk_pop_free(v26, (void (__cdecl *)(void *))X509_ALGOR_free);
      if (v27)
        goto LABEL_35;
    }
    else
    {
      sk_pop_free((STACK *)paobj, (void (__cdecl *)(void *))X509_ALGOR_free);
    }
LABEL_55:
    v15 = 65;
    v16 = 421;
    goto LABEL_56;
  }
LABEL_35:
  if ((a5 & 0x8000) != 0
    && (!cms_copy_messageDigest((uint64_t)a1, (uint64_t)v12)
     || (a5 & 0x44000) == 0 && !CMS_SignerInfo_sign((uint64_t)v12)))
  {
    goto LABEL_57;
  }
LABEL_39:
  if ((a5 & 2) == 0 && !CMS_add1_cert((uint64_t)a1, x509))
    goto LABEL_55;
  if ((a5 & 0x40000) != 0)
  {
    if ((a5 & 0x100) != 0)
    {
      v29 = (uint64_t *)EVP_PKEY_CTX_new(*((_QWORD *)v12 + 8), 0);
      *((_QWORD *)v12 + 10) = v29;
      if (!v29 || (int)EVP_PKEY_sign_init(v29) < 1)
        goto LABEL_57;
      v28 = EVP_PKEY_CTX_ctrl(*((uint64_t **)v12 + 10), -1, 248);
    }
    else
    {
      v28 = EVP_DigestSignInit(*((_QWORD *)v12 + 9), (_QWORD *)v12 + 10, a4, 0, (uint64_t)pkey);
    }
    if (v28 < 1)
    {
LABEL_57:
      ASN1_item_free(v12, &CMS_SignerInfo_it);
      return 0;
    }
  }
  v30 = *(STACK **)(v11 + 40);
  if (!v30)
  {
    v30 = sk_new_null();
    *(_QWORD *)(v11 + 40) = v30;
    if (!v30)
      goto LABEL_55;
  }
  if (!sk_push(v30, (char *)v12))
    goto LABEL_55;
  return v12;
}

uint64_t cms_sd_asn1_ctrl(uint64_t a1)
{
  uint64_t v1;
  uint64_t (*v2)(void);
  int v3;
  int v4;
  int v5;

  v1 = *(_QWORD *)(*(_QWORD *)(a1 + 64) + 16);
  if (!v1)
    return 1;
  v2 = *(uint64_t (**)(void))(v1 + 176);
  if (!v2)
    return 1;
  v3 = v2();
  if (v3 != -2)
  {
    if (v3 <= 0)
    {
      v4 = 111;
      v5 = 268;
      goto LABEL_8;
    }
    return 1;
  }
  v4 = 125;
  v5 = 264;
LABEL_8:
  ERR_put_error(46, 4095, v4, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/cms/cms_sd.c", v5);
  return 0;
}

ASN1_INTEGER *CMS_add_standard_smimecap(STACK **a1)
{
  const char *v2;

  if (cms_add_cipher_smcap(a1, 427, -1)
    && ((v2 = OBJ_nid2sn(809), !EVP_get_digestbyname(v2)) || CMS_add_simple_smimecap(a1, 809, -1))
    && cms_add_cipher_smcap(a1, 813, -1)
    && cms_add_cipher_smcap(a1, 423, -1)
    && cms_add_cipher_smcap(a1, 419, -1)
    && cms_add_cipher_smcap(a1, 44, -1)
    && cms_add_cipher_smcap(a1, 37, 128)
    && cms_add_cipher_smcap(a1, 37, 64)
    && cms_add_cipher_smcap(a1, 31, -1))
  {
    return cms_add_cipher_smcap(a1, 37, 40);
  }
  else
  {
    return 0;
  }
}

BOOL CMS_add_smimecap(uint64_t a1, X509_ALGORS *a)
{
  int v3;
  _BOOL8 v4;
  unsigned __int8 *out;

  out = 0;
  v3 = i2d_X509_ALGORS(a, &out);
  if (v3 < 1)
    return 0;
  v4 = CMS_signed_add1_attr_by_NID(a1, 167, 16, out, v3);
  free(out);
  return v4;
}

BOOL cms_copy_messageDigest(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  const STACK *v4;
  int v5;
  char *v6;
  uint64_t v7;
  int v8;
  int v9;
  ASN1_OBJECT *v11;
  const unsigned __int8 *v12;

  v3 = cms_get0_signed(a1);
  if (v3)
    v4 = *(const STACK **)(v3 + 40);
  else
    v4 = 0;
  if (sk_num(v4) < 1)
  {
LABEL_10:
    v8 = 131;
    v9 = 196;
LABEL_11:
    ERR_put_error(46, 4095, v8, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/cms/cms_sd.c", v9);
    return 0;
  }
  v5 = 0;
  while (1)
  {
    v6 = sk_value(v4, v5);
    if (v6 != (char *)a2)
    {
      v7 = (uint64_t)v6;
      if ((CMS_signed_get_attr_count((uint64_t)v6) & 0x80000000) == 0
        && !OBJ_cmp(**(const ASN1_OBJECT ***)(a2 + 16), **(const ASN1_OBJECT ***)(v7 + 16)))
      {
        break;
      }
    }
    if (++v5 >= sk_num(v4))
      goto LABEL_10;
  }
  v11 = OBJ_nid2obj(51);
  v12 = (const unsigned __int8 *)CMS_signed_get0_data_by_OBJ(v7, v11, -3, 4);
  if (!v12)
  {
    v8 = 114;
    v9 = 185;
    goto LABEL_11;
  }
  return CMS_signed_add1_attr_by_NID(a2, 51, 4, v12, -1);
}

const EVP_MD *CMS_SignerInfo_sign(uint64_t a1)
{
  EVP_MD_CTX *v2;
  int v3;
  const char *v4;
  const EVP_MD *result;
  const EVP_MD *v6;
  uint64_t *v7;
  ASN1_TIME *v8;
  ASN1_TIME *v9;
  _BOOL4 v10;
  int v11;
  unsigned __int8 *v12;
  int v13;
  int v14;
  size_t size;
  unsigned __int8 *out;
  uint64_t *v17;

  v2 = *(EVP_MD_CTX **)(a1 + 72);
  out = 0;
  v17 = 0;
  size = 0;
  v3 = OBJ_obj2nid(**(const ASN1_OBJECT ***)(a1 + 16));
  v4 = OBJ_nid2sn(v3);
  result = EVP_get_digestbyname(v4);
  if (result)
  {
    v6 = result;
    if ((CMS_signed_get_attr_by_NID(a1, 52, -1) & 0x80000000) == 0)
    {
LABEL_3:
      v7 = *(uint64_t **)(a1 + 80);
      if (v7)
      {
        v17 = *(uint64_t **)(a1 + 80);
      }
      else
      {
        EVP_MD_CTX_reset(v2);
        if ((int)EVP_DigestSignInit((uint64_t)v2, &v17, v6, 0, *(_QWORD *)(a1 + 64)) < 1)
        {
LABEL_22:
          free(out);
          EVP_MD_CTX_reset(v2);
          return 0;
        }
        v7 = v17;
        *(_QWORD *)(a1 + 80) = v17;
      }
      if ((int)EVP_PKEY_CTX_ctrl(v7, -1, 8) <= 0)
      {
        v13 = 110;
        v14 = 739;
      }
      else
      {
        v11 = ASN1_item_i2d(*(ASN1_VALUE **)(a1 + 24), &out, &CMS_Attributes_Sign_it);
        if (!out)
          goto LABEL_22;
        if (EVP_DigestUpdate(v2, out, v11) < 1)
          goto LABEL_22;
        if ((int)EVP_DigestSignFinal((uint64_t)v2, 0, &size) < 1)
          goto LABEL_22;
        free(out);
        v12 = (unsigned __int8 *)malloc_type_malloc(size, 0xDE024C5EuLL);
        out = v12;
        if (!v12 || (int)EVP_DigestSignFinal((uint64_t)v2, (uint64_t)v12, &size) < 1)
          goto LABEL_22;
        if ((int)EVP_PKEY_CTX_ctrl(v17, -1, 8) > 0)
        {
          EVP_MD_CTX_reset(v2);
          ASN1_STRING_set0(*(ASN1_STRING **)(a1 + 40), out, size);
          return (const EVP_MD *)1;
        }
        v13 = 110;
        v14 = 760;
      }
LABEL_21:
      ERR_put_error(46, 4095, v13, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/cms/cms_sd.c", v14);
      goto LABEL_22;
    }
    v8 = X509_gmtime_adj(0, 0);
    if (v8)
    {
      v9 = v8;
      v10 = CMS_signed_add1_attr_by_NID(a1, 52, v8->type, (const unsigned __int8 *)v8, -1);
      ASN1_TIME_free(v9);
      if (v10 > 0)
        goto LABEL_3;
    }
    else
    {
      ASN1_TIME_free(0);
    }
    v13 = 65;
    v14 = 452;
    goto LABEL_21;
  }
  return result;
}

uint64_t CMS_SignerInfo_get0_pkey_ctx(uint64_t a1)
{
  return *(_QWORD *)(a1 + 80);
}

uint64_t CMS_SignerInfo_get0_md_ctx(uint64_t a1)
{
  return *(_QWORD *)(a1 + 72);
}

uint64_t CMS_get0_SignerInfos(uint64_t a1)
{
  uint64_t result;

  result = cms_get0_signed(a1);
  if (result)
    return *(_QWORD *)(result + 40);
  return result;
}

uint64_t cms_get0_signed(uint64_t a1)
{
  if (OBJ_obj2nid(*(const ASN1_OBJECT **)a1) == 22)
    return *(_QWORD *)(a1 + 8);
  ERR_put_error(46, 4095, 108, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/cms/cms_sd.c", 74);
  return 0;
}

STACK *CMS_get0_signers(uint64_t a1)
{
  uint64_t v1;
  const STACK *v2;
  int v3;
  STACK *v4;
  char *v5;
  char *v6;
  char *v7;

  v1 = cms_get0_signed(a1);
  if (v1)
    v2 = *(const STACK **)(v1 + 40);
  else
    v2 = 0;
  if (sk_num(v2) >= 1)
  {
    v3 = 0;
    v4 = 0;
    while (1)
    {
      v5 = sk_value(v2, v3);
      v6 = (char *)*((_QWORD *)v5 + 7);
      if (v6)
      {
        if (!v4)
        {
          v7 = v5;
          v4 = sk_new_null();
          if (!v4)
            return v4;
          v6 = (char *)*((_QWORD *)v7 + 7);
        }
        if (!sk_push(v4, v6))
          break;
      }
      if (++v3 >= sk_num(v2))
        return v4;
    }
    sk_free(v4);
  }
  return 0;
}

void CMS_SignerInfo_set1_signer_cert(uint64_t a1, X509 *a2)
{
  if (a2)
  {
    X509_up_ref((uint64_t)a2);
    EVP_PKEY_free(*(EVP_PKEY **)(a1 + 64));
    *(_QWORD *)(a1 + 64) = X509_get_pubkey(a2);
  }
  X509_free(*(X509 **)(a1 + 56));
  *(_QWORD *)(a1 + 56) = a2;
}

uint64_t CMS_SignerInfo_get0_signer_id(uint64_t a1, _QWORD *a2, _QWORD *a3, _QWORD *a4)
{
  uint64_t v4;
  _QWORD *v5;

  v4 = *(_QWORD *)(a1 + 8);
  if (*(_DWORD *)v4 == 1)
  {
    if (!a2)
      return 1;
    v5 = (_QWORD *)(v4 + 8);
    a4 = a2;
LABEL_9:
    *a4 = *v5;
    return 1;
  }
  if (!*(_DWORD *)v4)
  {
    if (a3)
      *a3 = **(_QWORD **)(v4 + 8);
    if (!a4)
      return 1;
    v5 = (_QWORD *)(*(_QWORD *)(v4 + 8) + 8);
    goto LABEL_9;
  }
  return 0;
}

uint64_t CMS_SignerInfo_cert_cmp(uint64_t a1, X509 *a2)
{
  return cms_SignerIdentifier_cert_cmp(*(_QWORD *)(a1 + 8), a2);
}

uint64_t CMS_set1_signers_certs(uint64_t a1, const STACK *a2, char a3)
{
  uint64_t v5;
  uint64_t v6;
  const STACK *v7;
  uint64_t v8;
  int v9;
  char *v10;
  uint64_t v11;
  int v12;
  char *v13;
  int v14;
  char *v15;
  X509 *v16;

  v5 = cms_get0_signed(a1);
  if (!v5)
    return 0xFFFFFFFFLL;
  v6 = v5;
  v7 = *(const STACK **)(v5 + 24);
  if (sk_num(*(const STACK **)(v5 + 40)) >= 1)
  {
    v8 = 0;
    v9 = 0;
    while (1)
    {
      v10 = sk_value(*(const STACK **)(v6 + 40), v9);
      if (!*((_QWORD *)v10 + 7))
      {
        v11 = (uint64_t)v10;
        if (sk_num(a2) >= 1)
        {
          v12 = 0;
          while (1)
          {
            v13 = sk_value(a2, v12);
            if (!cms_SignerIdentifier_cert_cmp(*(_QWORD *)(v11 + 8), (X509 *)v13))
              break;
            if (++v12 >= sk_num(a2))
              goto LABEL_11;
          }
          CMS_SignerInfo_set1_signer_cert(v11, (X509 *)v13);
          v8 = (v8 + 1);
          if ((a3 & 0x10) != 0)
            goto LABEL_5;
LABEL_14:
          if (!*(_QWORD *)(v11 + 56) && sk_num(v7) >= 1)
          {
            v14 = 0;
            while (1)
            {
              v15 = sk_value(v7, v14);
              if (!*(_DWORD *)v15)
              {
                v16 = (X509 *)*((_QWORD *)v15 + 1);
                if (!cms_SignerIdentifier_cert_cmp(*(_QWORD *)(v11 + 8), v16))
                  break;
              }
              if (++v14 >= sk_num(v7))
                goto LABEL_5;
            }
            CMS_SignerInfo_set1_signer_cert(v11, v16);
            v8 = (v8 + 1);
          }
          goto LABEL_5;
        }
LABEL_11:
        if ((a3 & 0x10) == 0)
          goto LABEL_14;
      }
LABEL_5:
      if (++v9 >= sk_num(*(const STACK **)(v6 + 40)))
        return v8;
    }
  }
  return 0;
}

_QWORD *CMS_SignerInfo_get0_algs(_QWORD *result, _QWORD *a2, _QWORD *a3, _QWORD *a4, _QWORD *a5)
{
  if (a2)
    *a2 = result[8];
  if (a3)
    *a3 = result[7];
  if (a4)
    *a4 = result[2];
  if (a5)
    *a5 = result[4];
  return result;
}

uint64_t CMS_SignerInfo_get0_signature(uint64_t a1)
{
  return *(_QWORD *)(a1 + 40);
}

uint64_t cms_SignedData_final(uint64_t a1, BIO *a2)
{
  uint64_t v4;
  const STACK *v5;
  int v6;
  char *v7;
  EVP_MD_CTX *v8;
  EVP_MD_CTX *v9;
  const unsigned __int8 *v10;
  uint64_t *v11;
  void *v12;
  void *v13;
  int v14;
  unsigned __int8 *v15;
  unsigned __int8 *v16;
  int v18;
  int v19;
  unsigned int v20;
  unsigned int s[2];
  unsigned __int8 md[4];
  uint64_t v23;

  v23 = *MEMORY[0x24BDAC8D0];
  v4 = cms_get0_signed(a1);
  if (v4)
    v5 = *(const STACK **)(v4 + 40);
  else
    v5 = 0;
  if (sk_num(v5) < 1)
  {
LABEL_27:
    *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 16) + 16) = 0;
    return 1;
  }
  v6 = 0;
  while (1)
  {
    v7 = sk_value(v5, v6);
    v8 = (EVP_MD_CTX *)EVP_MD_CTX_new();
    if (!v8)
    {
      ERR_put_error(46, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/cms/cms_sd.c", 609);
      return 0;
    }
    v9 = v8;
    if (!*((_QWORD *)v7 + 8))
    {
      v18 = 133;
      v19 = 614;
      goto LABEL_30;
    }
    if (!cms_DigestAlgorithm_find_ctx(v8, a2, *((X509_ALGOR **)v7 + 2))
      || *((_QWORD *)v7 + 10) && !cms_sd_asn1_ctrl((uint64_t)v7))
    {
      goto LABEL_31;
    }
    if ((CMS_signed_get_attr_count((uint64_t)v7) & 0x80000000) == 0)
    {
      v10 = **(const unsigned __int8 ***)(*(_QWORD *)(a1 + 8) + 16);
      s[0] = 0;
      if (!EVP_DigestFinal_ex(v9, md, s)
        || !CMS_signed_add1_attr_by_NID((uint64_t)v7, 51, 4, md, s[0])
        || CMS_signed_add1_attr_by_NID((uint64_t)v7, 50, 6, v10, -1) < 1
        || !CMS_SignerInfo_sign((uint64_t)v7))
      {
        goto LABEL_31;
      }
      goto LABEL_16;
    }
    v11 = (uint64_t *)*((_QWORD *)v7 + 10);
    if (!v11)
    {
      *(_DWORD *)md = 0;
      v14 = EVP_PKEY_size(*((EVP_PKEY **)v7 + 8));
      v15 = (unsigned __int8 *)malloc_type_malloc(v14, 0x25E26D37uLL);
      if (v15)
      {
        v16 = v15;
        if (EVP_SignFinal(v9, v15, (unsigned int *)md, *((EVP_PKEY **)v7 + 8)))
        {
          ASN1_STRING_set0(*((ASN1_STRING **)v7 + 5), v16, *(int *)md);
LABEL_16:
          v11 = 0;
          goto LABEL_22;
        }
        ERR_put_error(46, 4095, 139, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/cms/cms_sd.c", 675);
        free(v16);
LABEL_31:
        v11 = 0;
        goto LABEL_32;
      }
      v18 = 65;
      v19 = 671;
LABEL_30:
      ERR_put_error(46, 4095, v18, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/cms/cms_sd.c", v19);
      goto LABEL_31;
    }
    v20 = 0;
    if (!EVP_DigestFinal_ex(v9, md, &v20))
      goto LABEL_32;
    *(_QWORD *)s = EVP_PKEY_size(*((EVP_PKEY **)v7 + 8));
    v12 = malloc_type_malloc(*(size_t *)s, 0x36934A08uLL);
    if (!v12)
      break;
    v13 = v12;
    if ((int)EVP_PKEY_sign(v11, (uint64_t)v12, s, (uint64_t)md, v20) <= 0)
    {
      free(v13);
      goto LABEL_32;
    }
    ASN1_STRING_set0(*((ASN1_STRING **)v7 + 5), v13, s[0]);
LABEL_22:
    EVP_MD_CTX_free(v9);
    EVP_PKEY_CTX_free((EVP_PKEY **)v11);
    if (++v6 >= sk_num(v5))
      goto LABEL_27;
  }
  ERR_put_error(46, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/cms/cms_sd.c", 657);
LABEL_32:
  EVP_MD_CTX_free(v9);
  EVP_PKEY_CTX_free((EVP_PKEY **)v11);
  return 0;
}

uint64_t CMS_SignerInfo_verify(uint64_t a1)
{
  int v2;
  const char *v3;
  const EVP_MD *digestbyname;
  const EVP_MD *v5;
  EVP_MD_CTX *v6;
  int v7;
  int v8;
  uint64_t v9;
  int v10;
  int v11;
  unsigned __int8 *out;

  out = 0;
  if (!*(_QWORD *)(a1 + 64))
  {
    v10 = 134;
    v11 = 786;
LABEL_12:
    ERR_put_error(46, 4095, v10, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/cms/cms_sd.c", v11);
    return 0xFFFFFFFFLL;
  }
  v2 = OBJ_obj2nid(**(const ASN1_OBJECT ***)(a1 + 16));
  v3 = OBJ_nid2sn(v2);
  digestbyname = EVP_get_digestbyname(v3);
  if (!digestbyname)
    return 0xFFFFFFFFLL;
  v5 = digestbyname;
  v6 = *(EVP_MD_CTX **)(a1 + 72);
  if (!v6)
  {
    v6 = (EVP_MD_CTX *)EVP_MD_CTX_new();
    *(_QWORD *)(a1 + 72) = v6;
    if (!v6)
    {
      v10 = 65;
      v11 = 794;
      goto LABEL_12;
    }
  }
  if ((int)EVP_DigestVerifyInit((uint64_t)v6, (_QWORD *)(a1 + 80), v5, 0, *(_QWORD *)(a1 + 64)) >= 1
    && cms_sd_asn1_ctrl(a1)
    && (v7 = ASN1_item_i2d(*(ASN1_VALUE **)(a1 + 24), &out, &CMS_Attributes_Verify_it), out)
    && (v8 = EVP_DigestUpdate(v6, out, v7), free(out), v8 >= 1))
  {
    v9 = EVP_DigestVerifyFinal((uint64_t)v6, *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8), **(int **)(a1 + 40));
    if ((int)v9 <= 0)
      ERR_put_error(46, 4095, 158, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/cms/cms_sd.c", 818);
  }
  else
  {
    v9 = 0xFFFFFFFFLL;
  }
  EVP_MD_CTX_reset(v6);
  return v9;
}

BIO *cms_SignedData_init_bio(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  int i;
  int v5;
  uint64_t v6;
  int v7;
  int v8;
  char *v9;
  uint64_t v10;
  BIO *v11;
  int v12;
  char *v13;
  BIO *inited;

  v2 = cms_get0_signed(a1);
  if (v2)
  {
    v3 = v2;
    if (*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 16) + 16))
    {
      if (sk_num(*(const STACK **)(v2 + 24)) >= 1)
      {
        for (i = 0; i < sk_num(*(const STACK **)(v3 + 24)); ++i)
        {
          v5 = *(_DWORD *)sk_value(*(const STACK **)(v3 + 24), i);
          if (v5 == 2)
          {
            if (*(uint64_t *)v3 <= 2)
            {
              v6 = 3;
              goto LABEL_14;
            }
          }
          else
          {
            if (v5 != 3)
            {
              if (v5 != 4 || *(uint64_t *)v3 >= 5)
                continue;
              v6 = 5;
              goto LABEL_14;
            }
            if (*(uint64_t *)v3 < 4)
            {
              v6 = 4;
LABEL_14:
              *(_QWORD *)v3 = v6;
            }
          }
        }
      }
      if (sk_num(*(const STACK **)(v3 + 32)) >= 1)
      {
        v7 = 0;
        do
        {
          if (*(_DWORD *)sk_value(*(const STACK **)(v3 + 32), v7) == 1 && *(uint64_t *)v3 <= 4)
            *(_QWORD *)v3 = 5;
          ++v7;
        }
        while (v7 < sk_num(*(const STACK **)(v3 + 32)));
      }
      if (OBJ_obj2nid(**(const ASN1_OBJECT ***)(v3 + 16)) != 21 && *(uint64_t *)v3 <= 2)
        *(_QWORD *)v3 = 3;
      if (sk_num(*(const STACK **)(v3 + 40)) >= 1)
      {
        v8 = 0;
        do
        {
          v9 = sk_value(*(const STACK **)(v3 + 40), v8);
          v10 = *(_QWORD *)v9;
          if (**((_DWORD **)v9 + 1) == 1)
          {
            if (v10 <= 2)
              *(_QWORD *)v9 = 3;
            if (*(uint64_t *)v3 <= 2)
              *(_QWORD *)v3 = 3;
          }
          else if (v10 <= 0)
          {
            *(_QWORD *)v9 = 1;
          }
          ++v8;
        }
        while (v8 < sk_num(*(const STACK **)(v3 + 40)));
      }
      if (*(uint64_t *)v3 <= 0)
        *(_QWORD *)v3 = 1;
    }
    if (sk_num(*(const STACK **)(v3 + 8)) >= 1)
    {
      v11 = 0;
      v12 = 0;
      while (1)
      {
        v13 = sk_value(*(const STACK **)(v3 + 8), v12);
        inited = cms_DigestAlgorithm_init_bio((X509_ALGOR *)v13);
        if (!inited)
          break;
        if (v11)
          BIO_push(v11, inited);
        else
          v11 = inited;
        if (++v12 >= sk_num(*(const STACK **)(v3 + 8)))
          return v11;
      }
      BIO_free_all(v11);
    }
  }
  return 0;
}

uint64_t CMS_SignerInfo_verify_content(uint64_t a1, BIO *a2)
{
  EVP_MD_CTX *v4;
  ASN1_OBJECT *v5;
  const void **v6;
  int v7;
  int v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t *v11;
  uint64_t v12;
  unsigned int s;
  unsigned __int8 md[64];
  uint64_t v16;

  v16 = *MEMORY[0x24BDAC8D0];
  v4 = (EVP_MD_CTX *)EVP_MD_CTX_new();
  s = 0;
  if (!v4)
  {
    v7 = 65;
    v8 = 872;
    goto LABEL_22;
  }
  if ((CMS_signed_get_attr_count(a1) & 0x80000000) != 0)
  {
    v6 = 0;
  }
  else
  {
    v5 = OBJ_nid2obj(51);
    v6 = (const void **)CMS_signed_get0_data_by_OBJ(a1, v5, -3, 4);
    if (!v6)
    {
      v7 = 114;
      v8 = 881;
LABEL_22:
      ERR_put_error(46, 4095, v7, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/cms/cms_sd.c", v8);
      goto LABEL_23;
    }
  }
  if (!cms_DigestAlgorithm_find_ctx(v4, a2, *(X509_ALGOR **)(a1 + 16)))
  {
LABEL_23:
    v9 = 0;
LABEL_24:
    v10 = 0xFFFFFFFFLL;
    goto LABEL_25;
  }
  if (EVP_DigestFinal_ex(v4, md, &s) <= 0)
  {
    v7 = 147;
    v8 = 890;
    goto LABEL_22;
  }
  if (v6)
  {
    if (s != *(_DWORD *)v6)
    {
      v7 = 120;
      v8 = 898;
      goto LABEL_22;
    }
    if (!memcmp(md, v6[1], s))
    {
      v9 = 0;
      v10 = 1;
      goto LABEL_25;
    }
    ERR_put_error(46, 4095, 158, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/cms/cms_sd.c", 903);
    v9 = 0;
LABEL_13:
    v10 = 0;
    goto LABEL_25;
  }
  EVP_MD_CTX_md(v4);
  v11 = (uint64_t *)EVP_PKEY_CTX_new(*(_QWORD *)(a1 + 64), 0);
  v9 = v11;
  if (!v11 || (int)EVP_PKEY_verify_init(v11) < 1)
    goto LABEL_24;
  v10 = 0xFFFFFFFFLL;
  if ((int)EVP_PKEY_CTX_ctrl(v9, -1, 248) >= 1)
  {
    *(_QWORD *)(a1 + 80) = v9;
    if (cms_sd_asn1_ctrl(a1))
    {
      v12 = EVP_PKEY_verify(v9);
      if ((int)v12 > 0)
      {
        v10 = v12;
        goto LABEL_25;
      }
      ERR_put_error(46, 4095, 158, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/cms/cms_sd.c", 923);
      goto LABEL_13;
    }
  }
LABEL_25:
  EVP_PKEY_CTX_free((EVP_PKEY **)v9);
  EVP_MD_CTX_free(v4);
  return v10;
}

ASN1_INTEGER *CMS_add_simple_smimecap(STACK **a1, int a2, int a3)
{
  ASN1_INTEGER *result;
  ASN1_INTEGER *v7;
  X509_ALGOR *v8;
  X509_ALGOR *v9;
  ASN1_OBJECT *v10;
  int v11;
  STACK *v12;

  if (a3 < 1)
  {
    v7 = 0;
  }
  else
  {
    result = ASN1_INTEGER_new();
    if (!result)
      return result;
    v7 = result;
    if (!ASN1_INTEGER_set(result, a3))
      goto LABEL_14;
  }
  v8 = X509_ALGOR_new();
  if (!v8)
  {
LABEL_14:
    ASN1_INTEGER_free(v7);
    return 0;
  }
  v9 = v8;
  v10 = OBJ_nid2obj(a2);
  if (v7)
    v11 = 2;
  else
    v11 = -1;
  X509_ALGOR_set0(v9, v10, v11, v7);
  v12 = *a1;
  if (*a1 || (v12 = sk_new_null(), (*a1 = v12) != 0))
  {
    if (sk_push(v12, (char *)v9))
      return (ASN1_INTEGER *)1;
  }
  X509_ALGOR_free(v9);
  return 0;
}

ASN1_INTEGER *cms_add_cipher_smcap(STACK **a1, int n, int a3)
{
  const char *v6;

  v6 = OBJ_nid2sn(n);
  if (EVP_get_cipherbyname(v6))
    return CMS_add_simple_smimecap(a1, n, a3);
  else
    return (ASN1_INTEGER *)1;
}

RSA *RSA_new(void)
{
  return RSA_new_method(0);
}

RSA *__cdecl RSA_new_method(ENGINE *engine)
{
  char *v2;
  const RSA_METHOD *v3;
  const RSA_METHOD *RSA;
  int v5;
  unsigned int v6;
  unsigned int (*v7)(char *);

  v2 = (char *)malloc_type_calloc(1uLL, 0xA0uLL, 0x1060040A7B8FD3BuLL);
  if (!v2)
  {
    ERR_put_error(4, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/rsa/rsa_lib.c", 136);
    return (RSA *)v2;
  }
  v3 = (const RSA_METHOD *)default_RSA_meth;
  if (!default_RSA_meth)
  {
    v3 = RSA_PKCS1_SSLeay();
    default_RSA_meth = (uint64_t)v3;
  }
  *((_QWORD *)v2 + 2) = v3;
  if (engine)
  {
    if (!ENGINE_init(engine))
    {
      v5 = 145;
      goto LABEL_12;
    }
    *((_QWORD *)v2 + 3) = engine;
    goto LABEL_9;
  }
  engine = ENGINE_get_default_RSA();
  *((_QWORD *)v2 + 3) = engine;
  if (engine)
  {
LABEL_9:
    RSA = ENGINE_get_RSA(engine);
    *((_QWORD *)v2 + 2) = RSA;
    if (!RSA)
    {
      v5 = 155;
LABEL_12:
      ERR_put_error(4, 4095, 38, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/rsa/rsa_lib.c", v5);
LABEL_18:
      ENGINE_finish(*((ENGINE **)v2 + 3));
      free(v2);
      return 0;
    }
    goto LABEL_14;
  }
  RSA = (const RSA_METHOD *)*((_QWORD *)v2 + 2);
LABEL_14:
  v6 = RSA->flags & 0xFFFFFBFF;
  *((_DWORD *)v2 + 28) = 1;
  *((_DWORD *)v2 + 29) = v6;
  if (!CRYPTO_new_ex_data(6, v2, (CRYPTO_EX_DATA *)(v2 + 104)))
    goto LABEL_18;
  v7 = *(unsigned int (**)(char *))(*((_QWORD *)v2 + 2) + 56);
  if (v7 && !v7(v2))
  {
    CRYPTO_free_ex_data(6, v2, (CRYPTO_EX_DATA *)(v2 + 104));
    goto LABEL_18;
  }
  return (RSA *)v2;
}

void RSA_set_default_method(const RSA_METHOD *meth)
{
  default_RSA_meth = (uint64_t)meth;
}

const RSA_METHOD *RSA_get_default_method(void)
{
  const RSA_METHOD *result;

  result = (const RSA_METHOD *)default_RSA_meth;
  if (!default_RSA_meth)
  {
    result = RSA_PKCS1_SSLeay();
    default_RSA_meth = (uint64_t)result;
  }
  return result;
}

const RSA_METHOD *__cdecl RSA_get_method(const RSA *rsa)
{
  return rsa->meth;
}

int RSA_set_method(RSA *rsa, const RSA_METHOD *meth)
{
  int (__cdecl *finish)(RSA *);
  int (__cdecl *init)(RSA *);

  finish = rsa->meth->finish;
  if (finish)
    ((void (*)(RSA *))finish)(rsa);
  ENGINE_finish(rsa->engine);
  rsa->meth = meth;
  rsa->engine = 0;
  init = meth->init;
  if (init)
    ((void (*)(RSA *))init)(rsa);
  return 1;
}

void RSA_free(RSA *r)
{
  int (__cdecl *finish)(RSA *);

  if (r && CRYPTO_add_lock(&r->references, -1, 9, 0, 0) <= 0)
  {
    finish = r->meth->finish;
    if (finish)
      ((void (*)(RSA *))finish)(r);
    ENGINE_finish(r->engine);
    CRYPTO_free_ex_data(6, r, (CRYPTO_EX_DATA *)&r->ex_data.dummy);
    BN_free(r->n);
    BN_free(r->e);
    BN_free(r->d);
    BN_free(r->p);
    BN_free(r->q);
    BN_free(r->dmp1);
    BN_free(r->dmq1);
    BN_free(r->iqmp);
    BN_BLINDING_free((BN_BLINDING *)r->bignum_data);
    BN_BLINDING_free(r->blinding);
    RSA_PSS_PARAMS_free((ASN1_VALUE *)r->ex_data.sk);
    free(r);
  }
}

int RSA_up_ref(RSA *r)
{
  return CRYPTO_add_lock(&r->references, 1, 9, 0, 0) > 1;
}

int RSA_get_ex_new_index(uint64_t argl, void *argp, CRYPTO_EX_new *new_func, CRYPTO_EX_dup *dup_func, CRYPTO_EX_free *free_func)
{
  return CRYPTO_get_ex_new_index(6, argl, argp, new_func, dup_func, free_func);
}

int RSA_set_ex_data(RSA *r, int idx, void *arg)
{
  return CRYPTO_set_ex_data((CRYPTO_EX_DATA *)&r->ex_data.dummy, idx, arg);
}

void *__cdecl RSA_get_ex_data(const RSA *r, int idx)
{
  return CRYPTO_get_ex_data((const CRYPTO_EX_DATA *)&r->ex_data.dummy, idx);
}

uint64_t RSA_security_bits(uint64_t a1)
{
  int v1;

  v1 = RSA_bits(a1);
  return BN_security_bits(v1, -1);
}

_QWORD *RSA_get0_key(_QWORD *result, _QWORD *a2, _QWORD *a3, _QWORD *a4)
{
  if (a2)
    *a2 = result[4];
  if (a3)
    *a3 = result[5];
  if (a4)
    *a4 = result[6];
  return result;
}

uint64_t RSA_set0_key(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  BIGNUM *v5;

  v5 = *(BIGNUM **)(a1 + 32);
  if (!(a2 | (unint64_t)v5) || !(a3 | *(_QWORD *)(a1 + 40)))
    return 0;
  if (a2)
  {
    BN_free(v5);
    *(_QWORD *)(a1 + 32) = a2;
  }
  if (a3)
  {
    BN_free(*(BIGNUM **)(a1 + 40));
    *(_QWORD *)(a1 + 40) = a3;
  }
  if (a4)
  {
    BN_free(*(BIGNUM **)(a1 + 48));
    *(_QWORD *)(a1 + 48) = a4;
  }
  return 1;
}

_QWORD *RSA_get0_crt_params(_QWORD *result, _QWORD *a2, _QWORD *a3, _QWORD *a4)
{
  if (a2)
    *a2 = result[9];
  if (a3)
    *a3 = result[10];
  if (a4)
    *a4 = result[11];
  return result;
}

uint64_t RSA_set0_crt_params(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  BIGNUM *v5;

  v5 = *(BIGNUM **)(a1 + 72);
  if (!(a2 | (unint64_t)v5) || !(a3 | *(_QWORD *)(a1 + 80)) || !(a4 | *(_QWORD *)(a1 + 88)))
    return 0;
  if (a2)
  {
    BN_free(v5);
    *(_QWORD *)(a1 + 72) = a2;
  }
  if (a3)
  {
    BN_free(*(BIGNUM **)(a1 + 80));
    *(_QWORD *)(a1 + 80) = a3;
  }
  if (a4)
  {
    BN_free(*(BIGNUM **)(a1 + 88));
    *(_QWORD *)(a1 + 88) = a4;
  }
  return 1;
}

uint64_t RSA_get0_factors(uint64_t result, _QWORD *a2, _QWORD *a3)
{
  if (a2)
    *a2 = *(_QWORD *)(result + 56);
  if (a3)
    *a3 = *(_QWORD *)(result + 64);
  return result;
}

uint64_t RSA_set0_factors(uint64_t a1, uint64_t a2, uint64_t a3)
{
  BIGNUM *v4;

  v4 = *(BIGNUM **)(a1 + 56);
  if (!(a2 | (unint64_t)v4) || !(a3 | *(_QWORD *)(a1 + 64)))
    return 0;
  if (a2)
  {
    BN_free(v4);
    *(_QWORD *)(a1 + 56) = a2;
  }
  if (a3)
  {
    BN_free(*(BIGNUM **)(a1 + 64));
    *(_QWORD *)(a1 + 64) = a3;
  }
  return 1;
}

uint64_t RSA_get0_n(uint64_t a1)
{
  return *(_QWORD *)(a1 + 32);
}

uint64_t RSA_get0_e(uint64_t a1)
{
  return *(_QWORD *)(a1 + 40);
}

uint64_t RSA_get0_d(uint64_t a1)
{
  return *(_QWORD *)(a1 + 48);
}

uint64_t RSA_get0_p(uint64_t a1)
{
  return *(_QWORD *)(a1 + 56);
}

uint64_t RSA_get0_q(uint64_t a1)
{
  return *(_QWORD *)(a1 + 64);
}

uint64_t RSA_get0_dmp1(uint64_t a1)
{
  return *(_QWORD *)(a1 + 72);
}

uint64_t RSA_get0_dmq1(uint64_t a1)
{
  return *(_QWORD *)(a1 + 80);
}

uint64_t RSA_get0_iqmp(uint64_t a1)
{
  return *(_QWORD *)(a1 + 88);
}

uint64_t RSA_get0_pss_params(uint64_t a1)
{
  return *(_QWORD *)(a1 + 96);
}

uint64_t RSA_clear_flags(uint64_t result, int a2)
{
  *(_DWORD *)(result + 116) &= ~a2;
  return result;
}

uint64_t RSA_test_flags(uint64_t a1, unsigned int a2)
{
  return *(_DWORD *)(a1 + 116) & a2;
}

uint64_t RSA_set_flags(uint64_t result, int a2)
{
  *(_DWORD *)(result + 116) |= a2;
  return result;
}

uint64_t RSA_pkey_ctx_ctrl(uint64_t *a1, int a2)
{
  int v2;
  BOOL v3;

  if (a1 && *a1 && ((v2 = *(_DWORD *)*a1, v2 != 912) ? (v3 = v2 == 6) : (v3 = 1), !v3))
    return 0xFFFFFFFFLL;
  else
    return EVP_PKEY_CTX_ctrl(a1, -1, a2);
}

EC_GROUP *__cdecl EC_GROUP_new_by_curve_name(int nid)
{
  char v2;
  unint64_t v3;
  BIGNUM *v4;
  BN_CTX *v5;
  BN_CTX *v6;
  BIGNUM *v7;
  BIGNUM *v8;
  BIGNUM *v9;
  BIGNUM *v10;
  BIGNUM *v11;
  BIGNUM *v12;
  BIGNUM *v13;
  BIGNUM *v14;
  BIGNUM *v15;
  BIGNUM *v16;
  EC_GROUP *v17;
  EC_POINT *v18;
  EC_GROUP *v19;
  int v20;
  int v21;
  int v22;
  int v23;
  int v25;
  int v26;
  BIGNUM *a;
  int len;
  BIGNUM *ret;

  if (nid >= 1)
  {
    v2 = 0;
    v3 = 0x1FFFFFFFFFFFFDE4uLL;
    while (LODWORD((&curve_list)[v3 + 541]) != nid)
    {
      ++v2;
      v3 += 10;
      if (!(v3 * 8))
      {
        ERR_put_error(16, 4095, 129, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_curve.c", 3122);
        return 0;
      }
    }
    v5 = BN_CTX_new();
    v6 = v5;
    if (v5)
    {
      BN_CTX_start(v5);
      v4 = BN_CTX_get(v6);
      if (!v4)
      {
        v22 = 3;
        v23 = 3015;
LABEL_31:
        ERR_put_error(16, 4095, v22, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_curve.c", v23);
        v19 = 0;
LABEL_42:
        v18 = 0;
        goto LABEL_43;
      }
      v7 = BN_CTX_get(v6);
      if (v7)
      {
        v8 = v7;
        v9 = BN_CTX_get(v6);
        if (v9)
        {
          v10 = v9;
          v11 = BN_CTX_get(v6);
          if (v11)
          {
            v12 = v11;
            v13 = BN_CTX_get(v6);
            if (v13)
            {
              ret = v13;
              v14 = BN_CTX_get(v6);
              if (v14)
              {
                v15 = v14;
                v16 = BN_CTX_get(v6);
                if (v16)
                {
                  a = v16;
                  len = (int)(&curve_list)[v3 + 542];
                  if (BN_bin2bn((const unsigned __int8 *)(&curve_list)[v3 + 544], len, v4))
                  {
                    if (BN_bin2bn((const unsigned __int8 *)(&curve_list)[v3 + 545], len, v8))
                    {
                      if (BN_bin2bn((const unsigned __int8 *)(&curve_list)[v3 + 546], len, v10))
                      {
                        v17 = EC_GROUP_new_curve_GFp(v4, v8, v10, v6);
                        v4 = (BIGNUM *)v17;
                        if (v17)
                        {
                          EC_GROUP_set_curve_name(v17, nid);
                          v18 = EC_POINT_new((const EC_GROUP *)v4);
                          if (v18)
                          {
                            if (BN_bin2bn((const unsigned __int8 *)(&curve_list)[v3 + 547], len, v12))
                            {
                              if (BN_bin2bn((const unsigned __int8 *)(&curve_list)[v3 + 548], len, ret))
                              {
                                if (EC_POINT_set_affine_coordinates((const EC_GROUP *)v4, v18, (uint64_t)v12, (uint64_t)ret, v6))
                                {
                                  if (BN_bin2bn((const unsigned __int8 *)(&curve_list)[v3 + 549], len, v15))
                                  {
                                    if (BN_set_word(a, *((unsigned int *)&curve_list + 2 * v3 + 1085)))
                                    {
                                      if (EC_GROUP_set_generator((EC_GROUP *)v4, v18, v15, a))
                                      {
                                        if (((0x3FFFFFFFC00590uLL >> v2) & 1) != 0
                                          || EC_GROUP_set_seed((EC_GROUP *)v4, (const unsigned __int8 *)(&curve_list)[v3 + 543], *((int *)&curve_list + 2 * v3 + 1083)))
                                        {
                                          v19 = 0;
LABEL_43:
                                          EC_GROUP_free(v19);
                                          EC_POINT_free(v18);
                                          BN_CTX_end(v6);
                                          BN_CTX_free(v6);
                                          return (EC_GROUP *)v4;
                                        }
                                        v25 = 16;
                                        v26 = 3092;
                                      }
                                      else
                                      {
                                        v25 = 16;
                                        v26 = 3086;
                                      }
                                    }
                                    else
                                    {
                                      v25 = 3;
                                      v26 = 3082;
                                    }
                                  }
                                  else
                                  {
                                    v25 = 16;
                                    v26 = 3078;
                                  }
                                }
                                else
                                {
                                  v25 = 16;
                                  v26 = 3074;
                                }
                              }
                              else
                              {
                                v25 = 3;
                                v26 = 3070;
                              }
                            }
                            else
                            {
                              v25 = 3;
                              v26 = 3066;
                            }
                          }
                          else
                          {
                            v25 = 16;
                            v26 = 3062;
                          }
                          ERR_put_error(16, 4095, v25, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_curve.c", v26);
                          v19 = (EC_GROUP *)v4;
                          v4 = 0;
                          goto LABEL_43;
                        }
                        v22 = 16;
                        v23 = 3056;
                        goto LABEL_31;
                      }
                      v20 = 3;
                      v21 = 3052;
                    }
                    else
                    {
                      v20 = 3;
                      v21 = 3048;
                    }
                  }
                  else
                  {
                    v20 = 3;
                    v21 = 3044;
                  }
                }
                else
                {
                  v20 = 3;
                  v21 = 3039;
                }
              }
              else
              {
                v20 = 3;
                v21 = 3035;
              }
            }
            else
            {
              v20 = 3;
              v21 = 3031;
            }
          }
          else
          {
            v20 = 3;
            v21 = 3027;
          }
        }
        else
        {
          v20 = 3;
          v21 = 3023;
        }
      }
      else
      {
        v20 = 3;
        v21 = 3019;
      }
    }
    else
    {
      v20 = 65;
      v21 = 3009;
    }
    ERR_put_error(16, 4095, v20, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_curve.c", v21);
    v19 = 0;
    v4 = 0;
    goto LABEL_42;
  }
  return 0;
}

size_t EC_get_builtin_curves(EC_builtin_curve *r, size_t nitems)
{
  size_t v2;
  const char **p_comment;
  int *v4;

  if (r && nitems)
  {
    v2 = 54;
    if (nitems < 0x36)
      v2 = nitems;
    p_comment = &r->comment;
    v4 = &dword_24F8ABCC0;
    do
    {
      *((_DWORD *)p_comment - 2) = *v4;
      *p_comment = (const char *)*((_QWORD *)v4 - 1);
      p_comment += 2;
      v4 += 20;
      --v2;
    }
    while (v2);
  }
  return 54;
}

char *EC_curve_nid2nist(int a1)
{
  uint64_t v1;

  v1 = 0;
  while (LODWORD((&nist_curves)[v1 + 1]) != a1)
  {
    v1 += 2;
    if (v1 == 30)
      return 0;
  }
  return (&nist_curves)[v1];
}

uint64_t EC_curve_nist2nid(char *__s2)
{
  uint64_t v2;

  v2 = 0;
  while (strcmp((&nist_curves)[v2], __s2))
  {
    v2 += 2;
    if (v2 == 30)
      return 0;
  }
  return LODWORD((&nist_curves)[v2 + 1]);
}

void freezero(void *a1, size_t a2)
{
  if (a1)
  {
    explicit_bzero(a1, a2);
    free(a1);
  }
}

X509_CINF *__cdecl d2i_X509_CINF(X509_CINF **a, const unsigned __int8 **in, uint64_t len)
{
  return (X509_CINF *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &X509_CINF_it);
}

int i2d_X509_CINF(X509_CINF *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &X509_CINF_it);
}

X509_CINF *X509_CINF_new(void)
{
  return (X509_CINF *)ASN1_item_new(&X509_CINF_it);
}

void X509_CINF_free(X509_CINF *a)
{
  ASN1_item_free((ASN1_VALUE *)a, &X509_CINF_it);
}

X509 *__cdecl d2i_X509(X509 **a, const unsigned __int8 **in, uint64_t len)
{
  return (X509 *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &X509_it);
}

int i2d_X509(X509 *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &X509_it);
}

X509 *X509_new(void)
{
  return (X509 *)ASN1_item_new(&X509_it);
}

void X509_free(X509 *a)
{
  ASN1_item_free((ASN1_VALUE *)a, &X509_it);
}

X509 *__cdecl X509_dup(X509 *x509)
{
  return (X509 *)ASN1_item_dup(&X509_it, x509);
}

int X509_get_ex_new_index(uint64_t argl, void *argp, CRYPTO_EX_new *new_func, CRYPTO_EX_dup *dup_func, CRYPTO_EX_free *free_func)
{
  return CRYPTO_get_ex_new_index(10, argl, argp, new_func, dup_func, free_func);
}

int X509_set_ex_data(X509 *r, int idx, void *arg)
{
  return CRYPTO_set_ex_data(&r->ex_data, idx, arg);
}

void *__cdecl X509_get_ex_data(X509 *r, int idx)
{
  return CRYPTO_get_ex_data(&r->ex_data, idx);
}

X509 *__cdecl d2i_X509_AUX(X509 **a, const unsigned __int8 **pp, uint64_t length)
{
  const unsigned __int8 *v6;
  ASN1_VALUE *v7;
  X509 *v8;
  uint64_t v9;

  v6 = *pp;
  v7 = ASN1_item_d2i(0, pp, length, &X509_it);
  v8 = (X509 *)v7;
  if (v7)
  {
    v9 = v6 - *pp + length;
    if (v9 < 1 || d2i_X509_CERT_AUX((X509_CERT_AUX **)v7 + 28, pp, v9))
    {
      if (a)
      {
        ASN1_item_free((ASN1_VALUE *)*a, &X509_it);
        *a = v8;
      }
    }
    else
    {
      ASN1_item_free((ASN1_VALUE *)v8, &X509_it);
      return 0;
    }
  }
  return v8;
}

int i2d_X509_AUX(X509 *a, unsigned __int8 **pp)
{
  int v4;

  v4 = ASN1_item_i2d((ASN1_VALUE *)a, pp, &X509_it);
  if (a)
    v4 += i2d_X509_CERT_AUX((X509_CERT_AUX *)a[1].ex_pcpathlen, pp);
  return v4;
}

uint64_t i2d_re_X509_tbs(uint64_t *a1, unsigned __int8 **a2)
{
  uint64_t v2;

  v2 = *a1;
  *(_DWORD *)(v2 + 96) = 1;
  return ASN1_item_i2d((ASN1_VALUE *)v2, a2, &X509_CINF_it);
}

_QWORD *X509_get0_signature(_QWORD *result, _QWORD *a2, uint64_t a3)
{
  if (result)
    *result = *(_QWORD *)(a3 + 16);
  if (a2)
    *a2 = *(_QWORD *)(a3 + 8);
  return result;
}

uint64_t X509_get_signature_nid(uint64_t a1)
{
  return OBJ_obj2nid(**(const ASN1_OBJECT ***)(a1 + 8));
}

uint64_t x509_cb(int a1, void **a2)
{
  char *v2;

  v2 = (char *)*a2;
  switch(a1)
  {
    case 5:
      free(*((void **)v2 + 4));
      *((_QWORD *)v2 + 4) = X509_NAME_oneline(*(X509_NAME **)(*(_QWORD *)v2 + 40), 0, 0);
      break;
    case 3:
      CRYPTO_free_ex_data(10, *a2, (CRYPTO_EX_DATA *)(v2 + 40));
      X509_CERT_AUX_free(*((X509_CERT_AUX **)v2 + 28));
      ASN1_OCTET_STRING_free(*((ASN1_OCTET_STRING **)v2 + 11));
      AUTHORITY_KEYID_free(*((AUTHORITY_KEYID **)v2 + 12));
      CRL_DIST_POINTS_free(*((CRL_DIST_POINTS **)v2 + 13));
      GENERAL_NAMES_free(*((GENERAL_NAMES **)v2 + 14));
      NAME_CONSTRAINTS_free(*((NAME_CONSTRAINTS **)v2 + 15));
      sk_pop_free(*((STACK **)v2 + 16), (void (__cdecl *)(void *))IPAddressFamily_free);
      ASIdentifiers_free(*((ASN1_VALUE **)v2 + 17));
      free(*((void **)v2 + 4));
      *((_QWORD *)v2 + 4) = 0;
      break;
    case 1:
      *((_DWORD *)v2 + 6) = 0;
      *((_QWORD *)v2 + 4) = 0;
      *((_OWORD *)v2 + 3) = xmmword_22D6ACFE0;
      *((_QWORD *)v2 + 28) = 0;
      *((_QWORD *)v2 + 12) = 0;
      *((_QWORD *)v2 + 13) = 0;
      *((_QWORD *)v2 + 11) = 0;
      *((_QWORD *)v2 + 16) = 0;
      *((_QWORD *)v2 + 17) = 0;
      CRYPTO_new_ex_data(10, v2, (CRYPTO_EX_DATA *)(v2 + 40));
      break;
  }
  return 1;
}

void BN_RECP_CTX_init(BN_RECP_CTX *recp)
{
  BN_init(&recp->N);
  BN_init(&recp->Nr);
  recp->num_bits = 0;
  recp->flags = 0;
}

BN_RECP_CTX *BN_RECP_CTX_new(void)
{
  BIGNUM *v0;
  BN_RECP_CTX *v1;

  v0 = (BIGNUM *)malloc_type_malloc(0x40uLL, 0x10100400860DEA3uLL);
  v1 = (BN_RECP_CTX *)v0;
  if (v0)
  {
    BN_init(v0);
    BN_init(&v1->Nr);
    v1->num_bits = 0;
    v1->flags = 1;
  }
  return v1;
}

void BN_RECP_CTX_free(BN_RECP_CTX *recp)
{
  if (recp)
  {
    BN_free(&recp->N);
    BN_free(&recp->Nr);
    if ((recp->flags & 1) != 0)
      free(recp);
  }
}

int BN_RECP_CTX_set(BN_RECP_CTX *recp, const BIGNUM *rdiv, BN_CTX *ctx)
{
  int result;

  result = bn_copy(&recp->N, rdiv);
  if (result)
  {
    BN_zero((uint64_t)&recp->Nr);
    recp->num_bits = BN_num_bits(rdiv);
    recp->shift = 0;
    return 1;
  }
  return result;
}

int BN_mod_mul_reciprocal(BIGNUM *r, const BIGNUM *x, const BIGNUM *y, BN_RECP_CTX *recp, BN_CTX *ctx)
{
  BIGNUM *v10;
  const BIGNUM *v11;
  int v12;

  BN_CTX_start(ctx);
  v10 = BN_CTX_get(ctx);
  if (!v10)
    goto LABEL_9;
  if (y)
  {
    v11 = v10;
    if (x == y)
    {
      if (!BN_sqr(v10, y, ctx))
      {
LABEL_9:
        v12 = 0;
        goto LABEL_10;
      }
    }
    else if (!BN_mul(v10, x, y, ctx))
    {
      goto LABEL_9;
    }
  }
  else
  {
    v11 = x;
  }
  v12 = BN_div_recp(0, r, v11, recp, ctx);
LABEL_10:
  BN_CTX_end(ctx);
  return v12;
}

int BN_div_recp(BIGNUM *dv, BIGNUM *rem, const BIGNUM *m, BN_RECP_CTX *recp, BN_CTX *ctx)
{
  BIGNUM *v10;
  BIGNUM *v11;
  _BOOL4 v12;
  int v13;
  int v14;
  int v15;
  int v16;

  BN_CTX_start(ctx);
  v10 = BN_CTX_get(ctx);
  v11 = BN_CTX_get(ctx);
  if (!dv)
  {
    dv = BN_CTX_get(ctx);
    if (rem)
      goto LABEL_3;
LABEL_14:
    rem = BN_CTX_get(ctx);
    goto LABEL_3;
  }
  if (!rem)
    goto LABEL_14;
LABEL_3:
  v12 = 0;
  if (v10 && v11 && dv && rem)
  {
    if (BN_ucmp(m, &recp->N) < 0)
    {
      BN_zero((uint64_t)dv);
      v12 = bn_copy(rem, m);
    }
    else
    {
      v13 = BN_num_bits(m);
      if (2 * recp->num_bits <= v13)
        v14 = v13;
      else
        v14 = 2 * recp->num_bits;
      if (v14 == recp->shift)
      {
        v15 = v14;
      }
      else
      {
        v15 = BN_reciprocal(&recp->Nr, &recp->N, v14, ctx);
        recp->shift = v15;
      }
      if (v15 != -1)
      {
        if (BN_rshift(v10, m, recp->num_bits))
        {
          if (BN_mul(v11, v10, &recp->Nr, ctx))
          {
            if (BN_rshift(dv, v11, v14 - recp->num_bits))
            {
              dv->neg = 0;
              if (BN_mul(v11, &recp->N, dv, ctx))
              {
                if (BN_usub(rem, m, v11))
                {
                  rem->neg = 0;
                  v16 = 4;
                  v12 = 0;
                  while (1)
                  {
                    if (BN_ucmp(rem, &recp->N) < 0)
                    {
                      BN_set_negative(rem, m->neg);
                      BN_set_negative(dv, recp->N.neg ^ m->neg);
                      v12 = 1;
                      goto LABEL_32;
                    }
                    if (!--v16)
                      break;
                    if (!BN_usub(rem, rem, &recp->N))
                      goto LABEL_31;
                    if (!BN_add_word(dv, 1uLL))
                      goto LABEL_32;
                  }
                  ERR_put_error(3, 4095, 101, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/bn/bn_recp.c", 214);
                }
              }
            }
          }
        }
      }
LABEL_31:
      v12 = 0;
    }
  }
LABEL_32:
  BN_CTX_end(ctx);
  return v12;
}

int BN_reciprocal(BIGNUM *r, const BIGNUM *m, int len, BN_CTX *ctx)
{
  BIGNUM *v8;
  const BIGNUM *v9;

  BN_CTX_start(ctx);
  v8 = BN_CTX_get(ctx);
  if (v8 && (v9 = v8, BN_set_bit(v8, len)))
  {
    if (!BN_div_ct((uint64_t)r, 0, v9, m, ctx))
      len = -1;
  }
  else
  {
    len = -1;
  }
  BN_CTX_end(ctx);
  return len;
}

STACK *i2v_AUTHORITY_INFO_ACCESS(X509V3_EXT_METHOD *a1, STACK *a2, STACK *a3)
{
  STACK *v5;
  STACK *v6;
  int v7;
  char *v8;
  ASN1_OBJECT **v9;
  STACK *v10;
  char *v11;
  char *v12;
  char *v14;
  char buf[80];
  uint64_t v16;

  v16 = *MEMORY[0x24BDAC8D0];
  if (a3)
  {
    v5 = a3;
    v6 = 0;
  }
  else
  {
    v5 = sk_new_null();
    v6 = v5;
    if (!v5)
      return v5;
  }
  v14 = 0;
  if (sk_num(a2) >= 1)
  {
    v7 = 0;
    while (1)
    {
      v8 = sk_value(a2, v7);
      if (!v8)
        break;
      v9 = (ASN1_OBJECT **)v8;
      v10 = i2v_GENERAL_NAME(a1, *((GENERAL_NAME **)v8 + 1), v5);
      if (!v10)
        break;
      v5 = v10;
      v11 = sk_value(v10, v7);
      if (!v11)
        break;
      v12 = v11;
      if (!i2t_ASN1_OBJECT(buf, 80, *v9))
        break;
      if (asprintf(&v14, "%s - %s", buf, *((const char **)v12 + 1)) == -1)
      {
        v14 = 0;
        ERR_put_error(34, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_info.c", 240);
        break;
      }
      free(*((void **)v12 + 1));
      *((_QWORD *)v12 + 1) = v14;
      if (++v7 >= sk_num(a2))
        return v5;
    }
    sk_pop_free(v6, (void (__cdecl *)(void *))X509V3_conf_free);
    return 0;
  }
  return v5;
}

STACK *v2i_AUTHORITY_INFO_ACCESS(X509V3_EXT_METHOD *a1, X509V3_CTX *a2, const STACK *a3)
{
  STACK *v6;
  int v7;
  char *v8;
  char *v9;
  char *v10;
  char *v11;
  char *v12;
  int v13;
  char *v14;
  size_t v15;
  char *v16;
  char *v17;
  ASN1_OBJECT *v18;
  int v19;
  int v20;
  CONF_VALUE cnf;

  v6 = sk_new_null();
  if (!v6)
  {
    ERR_put_error(34, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_info.c", 266);
    return v6;
  }
  memset(&cnf, 0, sizeof(cnf));
  if (sk_num(a3) >= 1)
  {
    v7 = 0;
    while (1)
    {
      v8 = sk_value(a3, v7);
      v9 = (char *)ASN1_item_new(&ACCESS_DESCRIPTION_it);
      if (!v9)
        break;
      v10 = v9;
      if (!sk_push(v6, v9))
      {
        ASN1_item_free((ASN1_VALUE *)v10, &ACCESS_DESCRIPTION_it);
        v19 = 65;
        v20 = 277;
        goto LABEL_17;
      }
      v11 = (char *)*((_QWORD *)v8 + 1);
      v12 = strchr(v11, 59);
      if (!v12)
      {
        v19 = 143;
        v20 = 282;
        goto LABEL_17;
      }
      v13 = (int)v12;
      v14 = (char *)*((_QWORD *)v8 + 2);
      cnf.name = v12 + 1;
      cnf.value = v14;
      if (!v2i_GENERAL_NAME_ex(*((GENERAL_NAME **)v10 + 1), a1, a2, &cnf, 0))
        goto LABEL_19;
      v15 = v13 - (int)v11 + 1;
      v16 = (char *)malloc_type_malloc(v15, 0x7CCAC4BBuLL);
      if (!v16)
      {
        v19 = 65;
        v20 = 291;
        goto LABEL_17;
      }
      v17 = v16;
      strlcpy(v16, *((const char **)v8 + 1), v15);
      v18 = OBJ_txt2obj(v17, 0);
      *(_QWORD *)v10 = v18;
      if (!v18)
      {
        ERR_put_error(34, 4095, 119, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_info.c", 297);
        ERR_asprintf_error_data("value=%s", v17);
        free(v17);
LABEL_19:
        sk_pop_free(v6, (void (__cdecl *)(void *))ACCESS_DESCRIPTION_free);
        return 0;
      }
      free(v17);
      if (++v7 >= sk_num(a3))
        return v6;
    }
    v19 = 65;
    v20 = 272;
LABEL_17:
    ERR_put_error(34, 4095, v19, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_info.c", v20);
    goto LABEL_19;
  }
  return v6;
}

ACCESS_DESCRIPTION *__cdecl d2i_ACCESS_DESCRIPTION(ACCESS_DESCRIPTION **a, const unsigned __int8 **in, uint64_t len)
{
  return (ACCESS_DESCRIPTION *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &ACCESS_DESCRIPTION_it);
}

int i2d_ACCESS_DESCRIPTION(ACCESS_DESCRIPTION *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &ACCESS_DESCRIPTION_it);
}

ACCESS_DESCRIPTION *ACCESS_DESCRIPTION_new(void)
{
  return (ACCESS_DESCRIPTION *)ASN1_item_new(&ACCESS_DESCRIPTION_it);
}

void ACCESS_DESCRIPTION_free(ACCESS_DESCRIPTION *a)
{
  ASN1_item_free((ASN1_VALUE *)a, &ACCESS_DESCRIPTION_it);
}

AUTHORITY_INFO_ACCESS *__cdecl d2i_AUTHORITY_INFO_ACCESS(AUTHORITY_INFO_ACCESS **a, const unsigned __int8 **in, uint64_t len)
{
  return (AUTHORITY_INFO_ACCESS *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &AUTHORITY_INFO_ACCESS_it);
}

int i2d_AUTHORITY_INFO_ACCESS(AUTHORITY_INFO_ACCESS *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &AUTHORITY_INFO_ACCESS_it);
}

AUTHORITY_INFO_ACCESS *AUTHORITY_INFO_ACCESS_new(void)
{
  return (AUTHORITY_INFO_ACCESS *)ASN1_item_new(&AUTHORITY_INFO_ACCESS_it);
}

void AUTHORITY_INFO_ACCESS_free(AUTHORITY_INFO_ACCESS *a)
{
  ASN1_item_free((ASN1_VALUE *)a, &AUTHORITY_INFO_ACCESS_it);
}

int i2a_ACCESS_DESCRIPTION(BIO *bp, ACCESS_DESCRIPTION *a)
{
  i2a_ASN1_OBJECT(bp, a->method);
  return 2;
}

uint64_t CMS_SharedInfo_encode(unsigned __int8 **out, uint64_t a2, uint64_t a3, int a4)
{
  _QWORD v5[3];
  unsigned int v6;
  _QWORD v7[3];

  v6 = bswap32(8 * a4);
  v7[0] = 0x400000004;
  v7[1] = &v6;
  v7[2] = 0;
  v5[0] = a2;
  v5[1] = a3;
  v5[2] = v7;
  return ASN1_item_i2d((ASN1_VALUE *)v5, out, &CMS_SharedInfo_it);
}

uint64_t cms_si_cb(int a1, uint64_t *a2)
{
  uint64_t v2;

  if (a1 == 3)
  {
    v2 = *a2;
    EVP_PKEY_free(*(EVP_PKEY **)(*a2 + 64));
    X509_free(*(X509 **)(v2 + 56));
    EVP_MD_CTX_free(*(EVP_MD_CTX **)(v2 + 72));
  }
  return 1;
}

uint64_t cms_rek_cb(int a1, uint64_t a2)
{
  if (a1 == 3)
    EVP_PKEY_free(*(EVP_PKEY **)(*(_QWORD *)a2 + 16));
  return 1;
}

uint64_t cms_kari_cb(int a1, uint64_t *a2)
{
  uint64_t v2;
  EVP_CIPHER_CTX *v3;
  uint64_t v4;

  v2 = *a2;
  if (a1 == 3)
  {
    EVP_PKEY_CTX_free(*(EVP_PKEY ***)(v2 + 40));
    EVP_CIPHER_CTX_free(*(EVP_CIPHER_CTX **)(v2 + 48));
    return 1;
  }
  if (a1 != 1)
    return 1;
  v3 = EVP_CIPHER_CTX_new();
  *(_QWORD *)(v2 + 48) = v3;
  if (!v3)
    return 0;
  v4 = 1;
  EVP_CIPHER_CTX_set_flags(v3, 1);
  *(_QWORD *)(v2 + 40) = 0;
  return v4;
}

uint64_t cms_ri_cb(int a1, int **a2)
{
  int *v2;
  int v3;
  uint64_t v4;

  if (a1 == 2)
  {
    v2 = *a2;
    v3 = **a2;
    if (v3 == 3 || v3 == 2)
    {
      freezero(*(void **)(*((_QWORD *)v2 + 1) + 32), *(_QWORD *)(*((_QWORD *)v2 + 1) + 40));
    }
    else if (!v3)
    {
      v4 = *((_QWORD *)v2 + 1);
      EVP_PKEY_free(*(EVP_PKEY **)(v4 + 40));
      X509_free(*(X509 **)(v4 + 32));
      EVP_PKEY_CTX_free(*(EVP_PKEY ***)(v4 + 48));
    }
  }
  return 1;
}

uint64_t cms_cb(int a1, uint64_t *a2, uint64_t a3, uint64_t a4)
{
  const ASN1_OBJECT **v5;
  uint64_t result;

  if (!a2)
    return 1;
  v5 = (const ASN1_OBJECT **)*a2;
  switch(a1)
  {
    case 10:
      if ((int)CMS_stream((unsigned __int8 ***)(a4 + 16), *a2) < 1)
        goto LABEL_9;
      goto LABEL_7;
    case 11:
    case 13:
      if ((int)CMS_dataFinal(v5, *(BIO **)(a4 + 8)) >= 1)
        goto LABEL_8;
LABEL_9:
      result = 0;
      break;
    case 12:
LABEL_7:
      result = (uint64_t)CMS_dataInit(v5, *(BIO **)a4);
      *(_QWORD *)(a4 + 8) = result;
      if (result)
        goto LABEL_8;
      return result;
    default:
LABEL_8:
      result = 1;
      break;
  }
  return result;
}

ASN1_TIME *ASN1_TIME_new(void)
{
  return (ASN1_TIME *)ASN1_item_new(&ASN1_TIME_it);
}

void ASN1_TIME_free(ASN1_TIME *a)
{
  ASN1_item_free((ASN1_VALUE *)a, &ASN1_TIME_it);
}

uint64_t ASN1_TIME_to_tm(int *a1, uint64_t a2)
{
  time_t v4;

  if (a1)
    return ASN1_time_parse(*((_QWORD *)a1 + 1), *a1, (_OWORD *)a2, 0) != -1;
  v4 = 0;
  time(&v4);
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  *(_OWORD *)(a2 + 32) = 0u;
  *(_QWORD *)(a2 + 48) = 0;
  return asn1_time_time_t_to_tm(&v4, a2);
}

uint64_t ASN1_TIME_diff(_DWORD *a1, _DWORD *a2, int *a3, int *a4)
{
  uint64_t result;
  _OWORD v8[3];
  uint64_t v9;
  _OWORD v10[3];
  uint64_t v11;

  v11 = 0;
  memset(v10, 0, sizeof(v10));
  v9 = 0;
  memset(v8, 0, sizeof(v8));
  result = ASN1_TIME_to_tm(a3, (uint64_t)v10);
  if ((_DWORD)result)
  {
    result = ASN1_TIME_to_tm(a4, (uint64_t)v8);
    if ((_DWORD)result)
      return OPENSSL_gmtime_diff(a1, a2, (int *)v10, (int *)v8);
  }
  return result;
}

ASN1_TIME *__cdecl d2i_ASN1_TIME(ASN1_TIME **a, const unsigned __int8 **in, uint64_t len)
{
  return (ASN1_TIME *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &ASN1_TIME_it);
}

int i2d_ASN1_TIME(ASN1_TIME *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &ASN1_TIME_it);
}

int RIPEMD160_Update(RIPEMD160_CTX *c, const void *data, size_t len)
{
  size_t v3;
  _DWORD *v4;
  uint64_t num;
  unsigned int *v7;
  char *v8;
  uint64_t v9;

  if (len)
  {
    v3 = len;
    v4 = data;
    *(_QWORD *)&c->Nl += 8 * len;
    num = c->num;
    if ((_DWORD)num)
    {
      v7 = c->data;
      v8 = (char *)c->data + num;
      if (len <= 0x3F && num + len < 0x40)
      {
        memcpy(v8, data, len);
        c->num += v3;
        return 1;
      }
      v9 = 64 - num;
      memcpy(v8, data, 64 - num);
      ripemd160_block_data_order(c, c->data, 1);
      v4 = (_DWORD *)((char *)v4 + v9);
      v3 -= v9;
      c->num = 0;
      *(_OWORD *)v7 = 0u;
      *(_OWORD *)&c->data[4] = 0u;
      *(_OWORD *)&c->data[8] = 0u;
      *(_OWORD *)&c->data[12] = 0u;
    }
    if (v3 >= 0x40)
    {
      ripemd160_block_data_order(c, v4, v3 >> 6);
      v4 = (_DWORD *)((char *)v4 + (v3 & 0xFFFFFFFFFFFFFFC0));
      v3 &= 0x3Fu;
    }
    if (v3)
    {
      c->num = v3;
      memcpy(c->data, v4, v3);
    }
  }
  return 1;
}

_DWORD *ripemd160_block_data_order(_DWORD *result, _DWORD *a2, uint64_t a3)
{
  unsigned int v4;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  unint64_t v10;
  int v11;
  int v12;
  int v13;
  unint64_t v14;
  int v15;
  int v16;
  int v17;
  int v18;
  int v19;
  int v20;
  int v21;
  int v22;
  int v23;
  int v24;
  int v25;
  int v26;
  unsigned int v27;
  int v28;
  int v29;
  unint64_t v30;
  int v31;
  int v32;
  int v33;
  int v34;
  int v35;
  int v36;
  int v37;
  int v38;
  int v39;
  int v40;
  int v41;
  unsigned int v42;
  int v43;
  int v44;
  unint64_t v45;
  int v46;
  int v47;
  int v48;
  int v49;
  int v50;
  int v51;
  int v52;
  int v53;
  int v54;
  int v55;
  int v56;
  unsigned int v57;
  int v58;
  int v59;
  unint64_t v60;
  int v61;
  int v62;
  int v63;
  int v64;
  int v65;
  int v66;
  int v67;
  int v68;
  int v69;
  int v70;
  int v71;
  int v72;
  int v73;
  int v74;
  int v75;
  int v76;
  int v77;
  int v78;
  int v79;
  int v80;
  int v81;
  int v82;
  int v83;
  int v84;
  int v85;
  int v86;
  int v87;
  int v88;
  int v89;
  int v90;
  int v91;
  int v92;
  int v93;
  int v94;
  int v95;
  int v96;
  int v97;
  int v98;
  int v99;
  int v100;
  int v101;
  int v102;
  unsigned int v103;
  int v104;
  int v105;
  int v106;
  unint64_t v107;
  int v108;
  int v109;
  int v110;
  unsigned int v111;
  int v112;
  int v113;
  int v114;
  unint64_t v115;
  int v116;
  int v117;
  int v118;
  unsigned int v119;
  int v120;
  int v121;
  int v122;
  unint64_t v123;
  int v124;
  int v125;
  int v126;
  unsigned int v127;
  int v128;
  int v129;
  int v130;
  unint64_t v131;
  int v132;
  int v133;
  unsigned int v134;
  unsigned int v135;
  int v136;
  unsigned int v137;
  int v138;
  unsigned int v139;
  int v140;
  unsigned int v141;
  int v142;
  unint64_t v143;
  int v144;
  int v145;
  unsigned int v146;
  unint64_t v147;
  int v148;
  int v149;
  int v150;
  unsigned int v151;
  int v152;
  unsigned int v153;
  unint64_t v154;
  int v155;
  int v156;
  unsigned int v157;
  unint64_t v158;
  int v159;
  int v160;
  int v161;
  int v162;
  int v163;
  int v164;
  unint64_t v165;
  int v166;
  int v167;
  unsigned int v168;
  unint64_t v169;
  int v170;
  int v171;
  unsigned int v172;
  unint64_t v173;
  int v174;
  int v175;
  unsigned int v176;
  unint64_t v177;
  int v178;
  int v179;
  unsigned int v180;
  int v181;
  int v182;
  unint64_t v183;
  int v184;
  int v185;
  unsigned int v186;
  unint64_t v187;
  int v188;
  int v189;
  unsigned int v190;
  unint64_t v191;
  int v192;
  int v193;
  unsigned int v194;
  unint64_t v195;
  int v196;
  int v197;
  int v198;
  unsigned int v199;
  int v200;
  int v201;
  int v202;
  unint64_t v203;
  int v204;
  int v205;
  unsigned int v206;
  unint64_t v207;
  int v208;
  int v209;
  int v210;
  unsigned int v211;
  unint64_t v212;
  int v213;
  int v214;
  unsigned int v215;
  unint64_t v216;
  int v217;
  int v218;
  int v219;
  unsigned int v220;
  unint64_t v221;
  int v222;
  unsigned int v223;
  int v224;
  int v225;
  unsigned int v226;
  unint64_t v227;
  int v228;
  int v229;
  int v230;
  int v231;
  unint64_t v232;
  int v233;
  int v234;
  unsigned int v235;
  unint64_t v236;
  int v237;
  int v238;
  int v239;
  unsigned int v240;
  unint64_t v241;
  int v242;
  int v243;
  unsigned int v244;
  unint64_t v245;
  int v246;
  int v247;
  unsigned int v248;
  unint64_t v249;
  int v250;
  unsigned int v251;
  int v252;
  int v253;
  unsigned int v254;
  unint64_t v255;
  int v256;
  int v257;
  int v258;
  int v259;
  unint64_t v260;
  int v261;
  int v262;
  unsigned int v263;
  unint64_t v264;
  int v265;
  int v266;
  int v267;
  unsigned int v268;
  unint64_t v269;
  int v270;
  int v271;
  unsigned int v272;
  unint64_t v273;
  int v274;
  int v275;
  unsigned int v276;
  unint64_t v277;
  int v278;
  int v279;
  int v280;
  int v281;
  unsigned int v282;
  unint64_t v283;
  int v284;
  int v285;
  unsigned int v286;
  int v287;
  unint64_t v288;
  int v289;
  int v290;
  unsigned int v291;
  unint64_t v292;
  int v293;
  int v294;
  int v295;
  unsigned int v296;
  unint64_t v297;
  int v298;
  int v299;
  unsigned int v300;
  unint64_t v301;
  int v302;
  int v303;
  int v304;
  int v305;
  unsigned int v306;
  unint64_t v307;
  int v308;
  unsigned int v309;
  int v310;
  int v311;
  int v312;
  unint64_t v313;
  int v314;
  int v315;
  unsigned int v316;
  int v317;
  unint64_t v318;
  int v319;
  int v320;
  unsigned int v321;
  unint64_t v322;
  int v323;
  int v324;
  unsigned int v325;
  unint64_t v326;
  int v327;
  int v328;
  int v329;
  unsigned int v330;
  unint64_t v331;
  int v332;
  int v333;
  int v334;
  int v335;
  int v336;
  unint64_t v337;
  int v338;
  int v339;
  unsigned int v340;
  unint64_t v341;
  int v342;
  int v343;
  unsigned int v344;
  unint64_t v345;
  int v346;
  int v347;
  unsigned int v348;
  unint64_t v349;
  int v350;
  int v351;
  int v352;
  int v353;
  int v354;
  int v355;
  unint64_t v356;
  int v357;
  int v358;
  unsigned int v359;
  unint64_t v360;
  int v361;
  int v362;
  unsigned int v363;
  unint64_t v364;
  int v365;
  int v366;
  int v367;
  unsigned int v368;
  unint64_t v369;
  int v370;
  int v371;
  int v372;
  int v373;
  int v374;
  unint64_t v375;
  int v376;
  int v377;
  unsigned int v378;
  unint64_t v379;
  int v380;
  int v381;
  unsigned int v382;
  unint64_t v383;
  int v384;
  int v385;
  int v386;
  unint64_t v387;
  int v388;
  int v389;
  int v390;
  int v391;
  int v392;
  int v393;
  unint64_t v394;
  int v395;
  int v396;
  int v397;
  int v398;
  int v399;
  int v400;
  int v401;
  int v402;
  unint64_t v403;
  int v404;
  int v405;
  int v406;
  int v407;
  unsigned int v408;
  int v409;
  int v410;
  int v411;
  int v412;
  int v413;
  int v414;
  int v415;
  int v416;
  int v417;
  int v418;
  unint64_t v419;
  int v420;
  unsigned int v421;
  int v422;
  int v423;
  int v424;
  int v425;
  int v426;
  int v427;
  int v428;
  int v429;
  int v430;
  int v431;
  unint64_t v432;
  int v433;
  unsigned int v434;
  int v435;
  int v436;
  int v437;
  int v438;
  int v439;
  int v440;
  int v441;
  int v442;
  int v443;
  int v444;
  unint64_t v445;
  int v446;
  unsigned int v447;
  int v448;
  int v449;
  int v450;
  int v451;
  int v452;
  int v453;
  int v454;
  int v455;
  int v456;
  int v457;
  unint64_t v458;
  int v459;
  unsigned int v460;
  int v461;
  int v462;
  int v463;
  int v464;
  int v465;
  int v466;
  int v467;
  int v468;
  int v469;
  int v470;
  unint64_t v471;
  int v472;
  unsigned int v473;
  int v474;
  int v475;
  int v476;
  int v477;
  unint64_t v478;
  int v479;
  int v480;
  int v481;
  int v482;
  int v483;
  unsigned int v484;
  int v485;
  int v486;
  unint64_t v487;
  int v488;
  unsigned int v489;
  int v490;
  int v491;
  int v492;
  int v493;
  unint64_t v494;
  int v495;
  unsigned int v496;
  int v497;
  int v498;
  int v499;
  int v500;
  int v501;
  int v502;
  int v503;
  unint64_t v504;
  int v505;
  unsigned int v506;
  int v507;
  int v508;
  int v509;
  unsigned int v510;
  unsigned int v511;
  unint64_t v512;
  int v513;
  int v514;
  unsigned int v515;
  unint64_t v516;
  int v517;
  int v518;
  unsigned int v519;
  unint64_t v520;
  int v521;
  int v522;
  unsigned int v523;
  unint64_t v524;
  int v525;
  int v526;
  unsigned int v527;
  unint64_t v528;
  int v529;
  int v530;
  unsigned int v531;
  unint64_t v532;
  int v533;
  int v534;
  unsigned int v535;
  unint64_t v536;
  int v537;
  int v538;
  unsigned int v539;
  unint64_t v540;
  int v541;
  int v542;
  unsigned int v543;
  unint64_t v544;
  int v545;
  int v546;
  int v547;
  unsigned int v548;
  unint64_t v549;
  int v550;
  int v551;
  unsigned int v552;
  unint64_t v553;
  int v554;
  int v555;
  int v556;
  unint64_t v557;
  int v558;
  int v559;
  int v560;
  unint64_t v561;
  int v562;
  int v563;
  unsigned int v564;
  unint64_t v565;
  int v566;
  int v567;
  int v568;
  int v569;
  int v570;
  int v571;
  unint64_t v572;
  int v573;
  int v574;
  int v575;
  unint64_t v576;
  int v577;
  int v578;
  int v579;
  int v580;
  _DWORD *v581;
  int v582;
  int v583;
  int v584;
  int v585;
  int v586;
  int v587;
  uint64_t v588;
  int v589;
  int v590;
  int v591;
  int v592;
  int v593;
  int v594;
  int v595;
  int v596;

  v581 = result;
  if (a3)
  {
    v5 = *result;
    v4 = result[1];
    v7 = result[2];
    v6 = result[3];
    v8 = result[4];
    do
    {
      v593 = v7;
      v594 = v8;
      v595 = v5;
      v588 = a3;
      v9 = a2[1];
      HIDWORD(v10) = (v7 ^ v4 ^ v6) + v5 + *a2;
      LODWORD(v10) = HIDWORD(v10);
      v11 = v8;
      v12 = (v10 >> 21) + v8;
      HIDWORD(v10) = v7;
      LODWORD(v10) = v7;
      v13 = v10 >> 22;
      v14 = __PAIR64__(v4, __ROR4__(v7, 22));
      v15 = v6;
      v592 = v6;
      v16 = v9 + v11 + (v4 ^ v14 ^ v12);
      LODWORD(v14) = v4;
      v586 = v14 >> 22;
      HIDWORD(v14) = v16;
      LODWORD(v14) = v16;
      v17 = (v14 >> 18) + v15;
      v19 = a2[2];
      v18 = a2[3];
      LODWORD(v14) = v19 + v15 + (v12 ^ __ROR4__(v4, 22) ^ v17);
      HIDWORD(v14) = v14;
      v20 = v14 >> 17;
      HIDWORD(v14) = v12;
      LODWORD(v14) = v12;
      v21 = v14 >> 22;
      v587 = v13;
      v22 = v20 + v13;
      LODWORD(v14) = v18 + v13 + (v17 ^ __ROR4__(v12, 22) ^ v22);
      HIDWORD(v14) = v14;
      v23 = v14 >> 20;
      HIDWORD(v14) = v17;
      LODWORD(v14) = v17;
      v24 = v14 >> 22;
      v25 = a2[4];
      v26 = a2[5];
      v27 = v23 + v586;
      LODWORD(v14) = v25 + v586 + (v22 ^ __ROR4__(v17, 22) ^ v27);
      HIDWORD(v14) = v14;
      v28 = (v14 >> 27) + v21;
      HIDWORD(v14) = v22;
      LODWORD(v14) = v22;
      v29 = v14 >> 22;
      v30 = __PAIR64__(v27, __ROR4__(v22, 22));
      v31 = v26 + v21 + (v27 ^ v30 ^ v28);
      LODWORD(v30) = v27;
      v32 = v30 >> 22;
      HIDWORD(v30) = v31;
      LODWORD(v30) = v31;
      v33 = (v30 >> 24) + v24;
      v34 = a2[6];
      v35 = a2[7];
      LODWORD(v30) = v34 + v24 + (v28 ^ __ROR4__(v27, 22) ^ v33);
      HIDWORD(v30) = v30;
      v36 = v30 >> 25;
      HIDWORD(v30) = v28;
      LODWORD(v30) = v28;
      v37 = v30 >> 22;
      v38 = v36 + v29;
      LODWORD(v30) = v35 + v29 + (v33 ^ __ROR4__(v28, 22) ^ v38);
      HIDWORD(v30) = v30;
      v39 = v30 >> 23;
      HIDWORD(v30) = v33;
      LODWORD(v30) = v33;
      v40 = v30 >> 22;
      v41 = a2[9];
      v42 = v39 + v32;
      LODWORD(v30) = a2[8] + v32 + (v38 ^ __ROR4__(v33, 22) ^ v42);
      HIDWORD(v30) = v30;
      v43 = (v30 >> 21) + v37;
      HIDWORD(v30) = v38;
      LODWORD(v30) = v38;
      v44 = v30 >> 22;
      v45 = __PAIR64__(v42, __ROR4__(v38, 22));
      v46 = v41 + v37 + (v42 ^ v45 ^ v43);
      LODWORD(v45) = v42;
      v47 = v45 >> 22;
      HIDWORD(v45) = v46;
      LODWORD(v45) = v46;
      v48 = (v45 >> 19) + v40;
      v49 = a2[10];
      v50 = a2[11];
      LODWORD(v45) = v49 + v40 + (v43 ^ __ROR4__(v42, 22) ^ v48);
      HIDWORD(v45) = v45;
      v51 = v45 >> 18;
      HIDWORD(v45) = v43;
      LODWORD(v45) = v43;
      v52 = v45 >> 22;
      v53 = v51 + v44;
      LODWORD(v45) = v50 + v44 + (v48 ^ __ROR4__(v43, 22) ^ v53);
      HIDWORD(v45) = v45;
      v54 = v45 >> 17;
      HIDWORD(v45) = v48;
      LODWORD(v45) = v48;
      v55 = v45 >> 22;
      v56 = a2[13];
      v57 = v54 + v47;
      v585 = a2[12];
      LODWORD(v45) = v585 + v47 + (v53 ^ __ROR4__(v48, 22) ^ v57);
      HIDWORD(v45) = v45;
      v58 = (v45 >> 26) + v52;
      HIDWORD(v45) = v53;
      LODWORD(v45) = v53;
      v59 = v45 >> 22;
      v60 = __PAIR64__(v57, __ROR4__(v53, 22));
      v61 = v52 + v56 + (v57 ^ v60 ^ v58);
      LODWORD(v60) = v57;
      v62 = v60 >> 22;
      HIDWORD(v60) = v61;
      LODWORD(v60) = v61;
      v63 = (v60 >> 25) + v55;
      v64 = a2[14];
      LODWORD(v60) = v55 + v64 + (v58 ^ __ROR4__(v57, 22) ^ v63);
      HIDWORD(v60) = v60;
      v65 = v60 >> 23;
      HIDWORD(v60) = v58;
      LODWORD(v60) = v58;
      v66 = v60 >> 22;
      v67 = v65 + v59;
      LODWORD(v60) = v59 + a2[15] + (v63 ^ __ROR4__(v58, 22) ^ v67);
      HIDWORD(v60) = v60;
      v68 = (v60 >> 24) + v62;
      HIDWORD(v60) = v63;
      LODWORD(v60) = v63;
      v69 = v60 >> 22;
      HIDWORD(v60) = v35 + 1518500249 + v62 + (v67 & v68 | v69 & ~v68);
      LODWORD(v60) = HIDWORD(v60);
      v70 = (v60 >> 25) + v66;
      HIDWORD(v60) = v67;
      LODWORD(v60) = v67;
      v71 = v60 >> 22;
      HIDWORD(v60) = v25 + 1518500249 + v66 + (v68 & v70 | v71 & ~v70);
      LODWORD(v60) = HIDWORD(v60);
      v72 = (v60 >> 26) + v69;
      HIDWORD(v60) = v68;
      LODWORD(v60) = v68;
      v73 = v60 >> 22;
      HIDWORD(v60) = v56 + 1518500249 + v69 + (v70 & v72 | v73 & ~v72);
      LODWORD(v60) = HIDWORD(v60);
      v74 = (v60 >> 24) + v71;
      HIDWORD(v60) = v70;
      LODWORD(v60) = v70;
      v75 = v60 >> 22;
      HIDWORD(v60) = v9 + 1518500249 + v71 + (v72 & v74 | v75 & ~v74);
      LODWORD(v60) = HIDWORD(v60);
      v76 = (v60 >> 19) + v73;
      HIDWORD(v60) = v72;
      LODWORD(v60) = v72;
      v77 = v60 >> 22;
      v590 = a2[15];
      v591 = v49;
      HIDWORD(v60) = v49 + 1518500249 + v73 + (v74 & v76 | v77 & ~v76);
      LODWORD(v60) = HIDWORD(v60);
      v78 = (v60 >> 21) + v75;
      HIDWORD(v60) = v74;
      LODWORD(v60) = v74;
      v79 = v60 >> 22;
      HIDWORD(v60) = v34 + 1518500249 + v75 + (v76 & v78 | v79 & ~v78);
      LODWORD(v60) = HIDWORD(v60);
      v80 = (v60 >> 23) + v77;
      HIDWORD(v60) = v76;
      LODWORD(v60) = v76;
      v81 = v60 >> 22;
      HIDWORD(v60) = v590 + 1518500249 + v77 + (v78 & v80 | v81 & ~v80);
      LODWORD(v60) = HIDWORD(v60);
      v82 = (v60 >> 25) + v79;
      HIDWORD(v60) = v78;
      LODWORD(v60) = v78;
      v83 = v60 >> 22;
      v596 = v18;
      HIDWORD(v60) = v18 + 1518500249 + v79 + (v80 & v82 | v83 & ~v82);
      LODWORD(v60) = HIDWORD(v60);
      v84 = (v60 >> 17) + v81;
      HIDWORD(v60) = v80;
      LODWORD(v60) = v80;
      v85 = v60 >> 22;
      HIDWORD(v60) = v585 + 1518500249 + v81 + (v82 & v84 | v85 & ~v84);
      LODWORD(v60) = HIDWORD(v60);
      v86 = (v60 >> 25) + v83;
      HIDWORD(v60) = v82;
      LODWORD(v60) = v82;
      v87 = v60 >> 22;
      HIDWORD(v60) = *a2 + 1518500249 + v83 + (v84 & v86 | v87 & ~v86);
      LODWORD(v60) = HIDWORD(v60);
      v88 = (v60 >> 20) + v85;
      HIDWORD(v60) = v84;
      LODWORD(v60) = v84;
      v89 = v60 >> 22;
      HIDWORD(v60) = v41 + 1518500249 + v85 + (v86 & v88 | v89 & ~v88);
      LODWORD(v60) = HIDWORD(v60);
      v90 = (v60 >> 17) + v87;
      HIDWORD(v60) = v86;
      LODWORD(v60) = v86;
      v91 = v60 >> 22;
      HIDWORD(v60) = v26 + 1518500249 + v87 + (v88 & v90 | v91 & ~v90);
      LODWORD(v60) = HIDWORD(v60);
      v92 = (v60 >> 23) + v89;
      HIDWORD(v60) = v88;
      LODWORD(v60) = v88;
      v93 = v60 >> 22;
      HIDWORD(v60) = v19 + 1518500249 + v89 + (v90 & v92 | v93 & ~v92);
      LODWORD(v60) = HIDWORD(v60);
      v94 = (v60 >> 21) + v91;
      HIDWORD(v60) = v90;
      LODWORD(v60) = v90;
      v95 = v60 >> 22;
      v96 = v64;
      v97 = v64 + 1518500249 + v91 + (v92 & v94 | v95 & ~v94);
      HIDWORD(v60) = v92;
      LODWORD(v60) = v92;
      v98 = v60 >> 22;
      HIDWORD(v60) = v97;
      LODWORD(v60) = v97;
      v99 = (v60 >> 25) + v93;
      HIDWORD(v60) = v50 + 1518500249 + v93 + (v94 & v99 | v98 & ~v99);
      LODWORD(v60) = HIDWORD(v60);
      v100 = v60 >> 19;
      HIDWORD(v60) = v94;
      LODWORD(v60) = v94;
      v101 = v60 >> 22;
      v102 = v100 + v95;
      v584 = a2[8];
      HIDWORD(v60) = v584 + 1518500249 + v95 + (v99 & v102 | v101 & ~v102);
      LODWORD(v60) = HIDWORD(v60);
      v103 = (v60 >> 20) + v98;
      HIDWORD(v60) = v99;
      LODWORD(v60) = v99;
      v104 = v60 >> 22;
      LODWORD(v60) = v18 + 1859775393 + v98 + ((v103 | ~v102) ^ __ROR4__(v99, 22));
      HIDWORD(v60) = v60;
      v105 = (v60 >> 21) + v101;
      HIDWORD(v60) = v102;
      LODWORD(v60) = v102;
      v106 = v60 >> 22;
      v107 = __PAIR64__(v103, __ROR4__(v102, 22));
      v108 = v49 + 1859775393 + v101 + ((v105 | ~v103) ^ v107);
      LODWORD(v107) = v103;
      v109 = v107 >> 22;
      HIDWORD(v107) = v108;
      LODWORD(v107) = v108;
      v110 = (v107 >> 19) + v104;
      LODWORD(v107) = v96 + 1859775393 + v104 + ((v110 | ~v105) ^ __ROR4__(v103, 22));
      HIDWORD(v107) = v107;
      v111 = (v107 >> 26) + v106;
      HIDWORD(v107) = v105;
      LODWORD(v107) = v105;
      v112 = v107 >> 22;
      LODWORD(v107) = v25 + 1859775393 + v106 + ((v111 | ~v110) ^ __ROR4__(v105, 22));
      HIDWORD(v107) = v107;
      v113 = (v107 >> 25) + v109;
      HIDWORD(v107) = v110;
      LODWORD(v107) = v110;
      v114 = v107 >> 22;
      v115 = __PAIR64__(v111, __ROR4__(v110, 22));
      v116 = v41 + 1859775393 + v109 + ((v113 | ~v111) ^ v115);
      LODWORD(v115) = v111;
      v117 = v115 >> 22;
      HIDWORD(v115) = v116;
      LODWORD(v115) = v116;
      v118 = (v115 >> 18) + v112;
      LODWORD(v115) = v590 + 1859775393 + v112 + ((v118 | ~v113) ^ __ROR4__(v111, 22));
      HIDWORD(v115) = v115;
      v119 = (v115 >> 23) + v114;
      HIDWORD(v115) = v113;
      LODWORD(v115) = v113;
      v120 = v115 >> 22;
      LODWORD(v115) = v584 + 1859775393 + v114 + ((v119 | ~v118) ^ __ROR4__(v113, 22));
      HIDWORD(v115) = v115;
      v121 = (v115 >> 19) + v117;
      HIDWORD(v115) = v118;
      LODWORD(v115) = v118;
      v122 = v115 >> 22;
      v123 = __PAIR64__(v119, __ROR4__(v118, 22));
      v124 = v9 + 1859775393 + v117 + ((v121 | ~v119) ^ v123);
      LODWORD(v123) = v119;
      v125 = v123 >> 22;
      HIDWORD(v123) = v124;
      LODWORD(v123) = v124;
      v126 = (v123 >> 17) + v120;
      LODWORD(v123) = v19 + 1859775393 + v120 + ((v126 | ~v121) ^ __ROR4__(v119, 22));
      HIDWORD(v123) = v123;
      v127 = (v123 >> 18) + v122;
      HIDWORD(v123) = v121;
      LODWORD(v123) = v121;
      v128 = v123 >> 22;
      LODWORD(v123) = v35 + 1859775393 + v122 + ((v127 | ~v126) ^ __ROR4__(v121, 22));
      HIDWORD(v123) = v123;
      v129 = (v123 >> 24) + v125;
      HIDWORD(v123) = v126;
      LODWORD(v123) = v126;
      v130 = v123 >> 22;
      v131 = __PAIR64__(v127, __ROR4__(v126, 22));
      v132 = *a2 + 1859775393 + v125 + ((v129 | ~v127) ^ v131);
      LODWORD(v131) = v127;
      v133 = v131 >> 22;
      HIDWORD(v131) = v132;
      LODWORD(v131) = v132;
      v134 = (v131 >> 19) + v128;
      LODWORD(v131) = v34 + 1859775393 + v128 + ((v134 | ~v129) ^ __ROR4__(v127, 22));
      HIDWORD(v131) = v131;
      v135 = (v131 >> 26) + v130;
      HIDWORD(v131) = v129;
      LODWORD(v131) = v129;
      v136 = v131 >> 22;
      LODWORD(v131) = v56 + 1859775393 + v130 + ((v135 | ~v134) ^ __ROR4__(v129, 22));
      HIDWORD(v131) = v131;
      v137 = (v131 >> 27) + v133;
      LODWORD(v131) = v50 + 1859775393 + v133 + ((v137 | ~v135) ^ __ROR4__(v134, 22));
      HIDWORD(v131) = v131;
      v138 = v131 >> 20;
      HIDWORD(v131) = v5 + 1352829926 + ((v593 | ~v592) ^ v4) + v26;
      LODWORD(v131) = HIDWORD(v131);
      v139 = v138 + v136;
      v140 = (v131 >> 24) + v594;
      LODWORD(v131) = v594 + 1352829926 + v96 + (v140 ^ (v4 | ~__ROR4__(v593, 22)));
      HIDWORD(v131) = v131;
      v141 = (v131 >> 23) + v592;
      v142 = v592 + 1352829926 + v35 + (v141 ^ (v140 | ~__ROR4__(v4, 22)));
      v143 = __PAIR64__(v142, __ROR4__(v135, 22));
      v144 = v26 + 1859775393 + v136 + ((v139 | ~v137) ^ v143);
      LODWORD(v143) = v142;
      v145 = (v143 >> 23) + v587;
      LODWORD(v143) = v587 + 1352829926 + *a2 + (v145 ^ (v141 | ~__ROR4__(v140, 22)));
      HIDWORD(v143) = v143;
      v146 = (v143 >> 21) + v586;
      v147 = __PAIR64__(v134, __ROR4__(v141, 22));
      v148 = v586 + 1352829926 + v41 + (v146 ^ (v145 | ~(_DWORD)v147));
      LODWORD(v147) = v134;
      v149 = v147 >> 22;
      HIDWORD(v147) = v140;
      LODWORD(v147) = v140;
      v150 = v147 >> 22;
      HIDWORD(v147) = v148;
      LODWORD(v147) = v148;
      v151 = (v147 >> 19) + v150;
      v152 = v19 + 1352829926 + v150;
      HIDWORD(v147) = v144;
      LODWORD(v147) = v144;
      v153 = (v147 >> 25) + v149;
      v154 = __PAIR64__(v141, __ROR4__(v137, 22));
      v155 = v585 + 1859775393 + v149 + ((v153 | ~v139) ^ v154);
      LODWORD(v154) = v141;
      v156 = v154 >> 22;
      HIDWORD(v154) = v152 + (v151 ^ (v146 | ~__ROR4__(v145, 22)));
      LODWORD(v154) = HIDWORD(v154);
      v157 = (v154 >> 17) + v156;
      v158 = __PAIR64__(v135, __ROR4__(v146, 22));
      v159 = v50 + 1352829926 + v156 + (v157 ^ (v151 | ~(_DWORD)v158));
      LODWORD(v158) = v135;
      v160 = v158 >> 22;
      HIDWORD(v158) = v145;
      LODWORD(v158) = v145;
      v161 = v158 >> 22;
      HIDWORD(v158) = v159;
      LODWORD(v158) = v159;
      v162 = (v158 >> 17) + v161;
      HIDWORD(v158) = v155;
      LODWORD(v158) = v155;
      v589 = a2[1];
      v163 = v589 - 1894007588 + v160;
      v164 = (v158 >> 27) + v160;
      v165 = __PAIR64__(v146, __ROR4__(v139, 22));
      v166 = v164 & v165 | v153 & ~__ROR4__(v139, 22);
      LODWORD(v165) = v146;
      v167 = v165 >> 22;
      HIDWORD(v165) = v25 + 1352829926 + v161 + (v162 ^ (v157 | ~__ROR4__(v151, 22)));
      LODWORD(v165) = HIDWORD(v165);
      v168 = (v165 >> 27) + v167;
      v169 = __PAIR64__(v151, __ROR4__(v157, 22));
      v170 = v56 + 1352829926 + v167 + (v168 ^ (v162 | ~(_DWORD)v169));
      LODWORD(v169) = v151;
      v171 = v169 >> 22;
      HIDWORD(v169) = v170;
      LODWORD(v169) = v170;
      v172 = (v169 >> 25) + v171;
      v173 = __PAIR64__(v157, __ROR4__(v162, 22));
      v174 = v34 + 1352829926 + v171 + (v172 ^ (v168 | ~(_DWORD)v173));
      LODWORD(v173) = v157;
      v175 = v173 >> 22;
      HIDWORD(v173) = v174;
      LODWORD(v173) = v174;
      v176 = (v173 >> 25) + v175;
      v177 = __PAIR64__(v137, __ROR4__(v168, 22));
      v178 = v590 + 1352829926 + v175 + (v176 ^ (v172 | ~(_DWORD)v177));
      LODWORD(v177) = v137;
      v179 = v177 >> 22;
      HIDWORD(v177) = v163 + v166;
      LODWORD(v177) = v163 + v166;
      v180 = (v177 >> 21) + v179;
      HIDWORD(v177) = v162;
      LODWORD(v177) = v162;
      v181 = v177 >> 22;
      HIDWORD(v177) = v178;
      LODWORD(v177) = v178;
      v182 = (v177 >> 24) + v181;
      v183 = __PAIR64__(v168, __ROR4__(v172, 22));
      v184 = v584 + 1352829926 + v181 + (v182 ^ (v176 | ~(_DWORD)v183));
      LODWORD(v183) = v168;
      v185 = v183 >> 22;
      HIDWORD(v183) = v184;
      LODWORD(v183) = v184;
      v186 = (v183 >> 21) + v185;
      v187 = __PAIR64__(v172, __ROR4__(v176, 22));
      v188 = v589 + 1352829926 + v185 + (v186 ^ (v182 | ~(_DWORD)v187));
      LODWORD(v187) = v172;
      v189 = v187 >> 22;
      HIDWORD(v187) = v188;
      LODWORD(v187) = v188;
      v190 = (v187 >> 18) + v189;
      v191 = __PAIR64__(v176, __ROR4__(v182, 22));
      v192 = v591 + 1352829926 + v189 + (v190 ^ (v186 | ~(_DWORD)v191));
      LODWORD(v191) = v176;
      v193 = v191 >> 22;
      HIDWORD(v191) = v192;
      LODWORD(v191) = v192;
      v194 = (v191 >> 18) + v193;
      v195 = __PAIR64__(v139, __ROR4__(v186, 22));
      v196 = v18 + 1352829926 + v193 + (v194 ^ (v190 | ~(_DWORD)v195));
      LODWORD(v195) = v139;
      v197 = v195 >> 22;
      HIDWORD(v195) = v182;
      LODWORD(v195) = v182;
      v198 = v195 >> 22;
      HIDWORD(v195) = v196;
      LODWORD(v195) = v196;
      v199 = (v195 >> 20) + v198;
      v200 = v585 + 1352829926 + v198;
      HIDWORD(v195) = v41 - 1894007588 + v179 + (v180 & __ROR4__(v153, 22) | v164 & ~__ROR4__(v153, 22));
      LODWORD(v195) = HIDWORD(v195);
      v583 = a2[11];
      v201 = v583 - 1894007588 + v197;
      v202 = (v195 >> 20) + v197;
      v203 = __PAIR64__(v186, __ROR4__(v164, 22));
      v204 = v202 & v203 | v180 & ~__ROR4__(v164, 22);
      LODWORD(v203) = v186;
      v205 = v203 >> 22;
      HIDWORD(v203) = v200 + (v199 ^ (v194 | ~__ROR4__(v190, 22)));
      LODWORD(v203) = HIDWORD(v203);
      v206 = (v203 >> 26) + v205;
      v207 = __PAIR64__(v190, __ROR4__(v194, 22));
      v208 = v34 + 1548603684 + v205 + (v206 & __ROR4__(v194, 22) | v199 & ~(_DWORD)v207);
      v209 = v201 + v204;
      LODWORD(v207) = v190;
      v210 = v207 >> 22;
      HIDWORD(v207) = v208;
      LODWORD(v207) = v208;
      v211 = (v207 >> 23) + v210;
      v212 = __PAIR64__(v153, __ROR4__(v199, 22));
      v213 = v211 & v212 | v206 & ~__ROR4__(v199, 22);
      LODWORD(v212) = v153;
      v214 = v212 >> 22;
      HIDWORD(v212) = v209;
      LODWORD(v212) = v209;
      v215 = (v212 >> 18) + v214;
      v216 = __PAIR64__(v194, __ROR4__(v180, 22));
      v217 = v215 & v216 | v202 & ~__ROR4__(v180, 22);
      LODWORD(v216) = v194;
      v218 = v216 >> 22;
      HIDWORD(v216) = v583 + 1548603684 + v210 + v213;
      LODWORD(v216) = HIDWORD(v216);
      v219 = v591 - 1894007588 + v214;
      v220 = (v216 >> 19) + v218;
      v221 = __PAIR64__(v199, __ROR4__(v206, 22));
      v222 = v220 & v221 | v211 & ~__ROR4__(v206, 22);
      v223 = v219 + v217;
      LODWORD(v221) = v199;
      v224 = v221 >> 22;
      HIDWORD(v221) = v164;
      LODWORD(v221) = v164;
      v225 = v221 >> 22;
      HIDWORD(v221) = v18 + 1548603684 + v218 + v222;
      LODWORD(v221) = HIDWORD(v221);
      v226 = (v221 >> 17) + v224;
      v227 = __PAIR64__(v223, __ROR4__(v211, 22));
      v228 = v226 & v227 | v220 & ~__ROR4__(v211, 22);
      LODWORD(v227) = v223;
      v229 = *a2 - 1894007588 + v225;
      v230 = (v227 >> 17) + v225;
      v231 = v35 + 1548603684 + v224 + v228;
      v232 = __PAIR64__(v206, __ROR4__(v202, 22));
      v233 = v230 & __ROR4__(v202, 22) | v215 & ~(_DWORD)v232;
      LODWORD(v232) = v206;
      v234 = v232 >> 22;
      HIDWORD(v232) = v231;
      LODWORD(v232) = v231;
      v235 = (v232 >> 25) + v234;
      v236 = __PAIR64__(v211, __ROR4__(v220, 22));
      v237 = *a2 + 1548603684 + v234 + (v235 & v236 | v226 & ~__ROR4__(v220, 22));
      v238 = v229 + v233;
      LODWORD(v236) = v211;
      v239 = v236 >> 22;
      HIDWORD(v236) = v237;
      LODWORD(v236) = v237;
      v240 = (v236 >> 20) + v239;
      v241 = __PAIR64__(v180, __ROR4__(v226, 22));
      v242 = v240 & v241 | v235 & ~__ROR4__(v226, 22);
      LODWORD(v241) = v180;
      v243 = v241 >> 22;
      HIDWORD(v241) = v238;
      LODWORD(v241) = v238;
      v244 = (v241 >> 18) + v243;
      v245 = __PAIR64__(v220, __ROR4__(v215, 22));
      v246 = v244 & v245 | v230 & ~__ROR4__(v215, 22);
      LODWORD(v245) = v220;
      v247 = v245 >> 22;
      HIDWORD(v245) = v56 + 1548603684 + v239 + v242;
      LODWORD(v245) = HIDWORD(v245);
      v248 = (v245 >> 24) + v247;
      v249 = __PAIR64__(v226, __ROR4__(v235, 22));
      v250 = v248 & __ROR4__(v235, 22) | v240 & ~(_DWORD)v249;
      v251 = v584 - 1894007588 + v243 + v246;
      LODWORD(v249) = v226;
      v252 = v249 >> 22;
      HIDWORD(v249) = v202;
      LODWORD(v249) = v202;
      v253 = v249 >> 22;
      HIDWORD(v249) = v26 + 1548603684 + v247 + v250;
      LODWORD(v249) = HIDWORD(v249);
      v254 = (v249 >> 23) + v252;
      v255 = __PAIR64__(v251, __ROR4__(v240, 22));
      v256 = v254 & v255 | v248 & ~__ROR4__(v240, 22);
      LODWORD(v255) = v251;
      v257 = v585 - 1894007588 + v253;
      v258 = (v255 >> 17) + v253;
      v259 = v591 + 1548603684 + v252 + v256;
      v260 = __PAIR64__(v235, __ROR4__(v230, 22));
      v261 = v258 & v260 | v244 & ~__ROR4__(v230, 22);
      LODWORD(v260) = v235;
      v262 = v260 >> 22;
      HIDWORD(v260) = v259;
      LODWORD(v260) = v259;
      v263 = (v260 >> 21) + v262;
      v264 = __PAIR64__(v240, __ROR4__(v248, 22));
      v265 = v96 + 1548603684 + v262 + (v263 & v264 | v254 & ~__ROR4__(v248, 22));
      v266 = v257 + v261;
      LODWORD(v264) = v240;
      v267 = v264 >> 22;
      HIDWORD(v264) = v265;
      LODWORD(v264) = v265;
      v268 = (v264 >> 25) + v267;
      v269 = __PAIR64__(v215, __ROR4__(v254, 22));
      v270 = v268 & __ROR4__(v254, 22) | v263 & ~(_DWORD)v269;
      LODWORD(v269) = v215;
      v271 = v269 >> 22;
      HIDWORD(v269) = v266;
      LODWORD(v269) = v266;
      v272 = (v269 >> 23) + v271;
      v273 = __PAIR64__(v248, __ROR4__(v244, 22));
      v274 = v272 & __ROR4__(v244, 22) | v258 & ~(_DWORD)v273;
      LODWORD(v273) = v248;
      v275 = v273 >> 22;
      HIDWORD(v273) = v590 + 1548603684 + v267 + v270;
      LODWORD(v273) = HIDWORD(v273);
      v276 = (v273 >> 25) + v275;
      v277 = __PAIR64__(v254, __ROR4__(v263, 22));
      v278 = v276 & v277 | v268 & ~__ROR4__(v263, 22);
      v279 = v25 - 1894007588 + v271 + v274;
      LODWORD(v277) = v254;
      v280 = v277 >> 22;
      HIDWORD(v277) = v230;
      LODWORD(v277) = v230;
      v281 = v277 >> 22;
      HIDWORD(v277) = v584 + 1548603684 + v275 + v278;
      LODWORD(v277) = HIDWORD(v277);
      v282 = (v277 >> 20) + v280;
      v283 = __PAIR64__(v279, __ROR4__(v268, 22));
      v284 = v282 & v283 | v276 & ~__ROR4__(v268, 22);
      LODWORD(v283) = v279;
      v285 = v56 - 1894007588 + v281;
      v286 = (v283 >> 24) + v281;
      v287 = v585 + 1548603684 + v280 + v284;
      v288 = __PAIR64__(v263, __ROR4__(v258, 22));
      v289 = v286 & v288 | v272 & ~__ROR4__(v258, 22);
      LODWORD(v288) = v263;
      v290 = v288 >> 22;
      HIDWORD(v288) = v287;
      LODWORD(v288) = v287;
      v291 = (v288 >> 25) + v290;
      v292 = __PAIR64__(v268, __ROR4__(v276, 22));
      v293 = v25 + 1548603684 + v290 + (v291 & __ROR4__(v276, 22) | v282 & ~(_DWORD)v292);
      v294 = v285 + v289;
      LODWORD(v292) = v268;
      v295 = v292 >> 22;
      HIDWORD(v292) = v293;
      LODWORD(v292) = v293;
      v296 = (v292 >> 26) + v295;
      v297 = __PAIR64__(v244, __ROR4__(v282, 22));
      v298 = v296 & v297 | v291 & ~__ROR4__(v282, 22);
      LODWORD(v297) = v244;
      v299 = v297 >> 22;
      HIDWORD(v297) = v294;
      LODWORD(v297) = v294;
      v300 = (v297 >> 23) + v299;
      v301 = __PAIR64__(v276, __ROR4__(v272, 22));
      v302 = v300 & v301 | v286 & ~__ROR4__(v272, 22);
      v303 = v41 + 1548603684 + v295 + v298;
      LODWORD(v301) = v276;
      v304 = v301 >> 22;
      HIDWORD(v301) = v303;
      LODWORD(v301) = v303;
      v305 = v18 - 1894007588 + v299;
      v306 = (v301 >> 17) + v304;
      v307 = __PAIR64__(v282, __ROR4__(v291, 22));
      v308 = v306 & v307 | v296 & ~__ROR4__(v291, 22);
      v309 = v305 + v302;
      LODWORD(v307) = v282;
      v310 = v307 >> 22;
      HIDWORD(v307) = v258;
      LODWORD(v307) = v258;
      v311 = v307 >> 22;
      HIDWORD(v307) = v589 + 1548603684 + v304 + v308;
      LODWORD(v307) = HIDWORD(v307);
      v312 = (v307 >> 19) + v310;
      v313 = __PAIR64__(v309, __ROR4__(v296, 22));
      v314 = v312 & v313 | v306 & ~__ROR4__(v296, 22);
      LODWORD(v313) = v309;
      v315 = v35 - 1894007588 + v311;
      v316 = (v313 >> 18) + v311;
      v317 = v19 + 1548603684 + v310 + v314;
      v318 = __PAIR64__(v291, __ROR4__(v286, 22));
      v319 = v316 & __ROR4__(v286, 22) | v300 & ~(_DWORD)v318;
      LODWORD(v318) = v291;
      v320 = v318 >> 22;
      HIDWORD(v318) = v317;
      LODWORD(v318) = v317;
      v321 = (v318 >> 21) + v320;
      v322 = __PAIR64__(v296, __ROR4__(v306, 22));
      v323 = v590 + 1836072691 + v320 + ((v321 | ~v312) ^ v322);
      LODWORD(v322) = v296;
      v324 = v322 >> 22;
      HIDWORD(v322) = v323;
      LODWORD(v322) = v323;
      v325 = (v322 >> 23) + v324;
      v326 = __PAIR64__(v306, __ROR4__(v312, 22));
      v327 = v26 + 1836072691 + v324 + ((v325 | ~v321) ^ v326);
      LODWORD(v326) = v306;
      v328 = v326 >> 22;
      HIDWORD(v326) = v327;
      LODWORD(v326) = v327;
      v329 = v315 + v319;
      v330 = (v326 >> 25) + v328;
      v331 = __PAIR64__(v272, __ROR4__(v321, 22));
      v332 = v589 + 1836072691 + v328 + ((v330 | ~v325) ^ v331);
      LODWORD(v331) = v272;
      v333 = v331 >> 22;
      HIDWORD(v331) = v329;
      LODWORD(v331) = v329;
      v334 = (v331 >> 27) + v333;
      HIDWORD(v331) = v312;
      LODWORD(v331) = v312;
      v335 = v331 >> 22;
      HIDWORD(v331) = v332;
      LODWORD(v331) = v332;
      v336 = (v331 >> 17) + v335;
      v337 = __PAIR64__(v321, __ROR4__(v325, 22));
      v338 = v18 + 1836072691 + v335 + ((v336 | ~v330) ^ v337);
      LODWORD(v337) = v321;
      v339 = v337 >> 22;
      HIDWORD(v337) = v338;
      LODWORD(v337) = v338;
      v340 = (v337 >> 21) + v339;
      v341 = __PAIR64__(v325, __ROR4__(v330, 22));
      v342 = v35 + 1836072691 + v339 + ((v340 | ~v336) ^ v341);
      LODWORD(v341) = v325;
      v343 = v341 >> 22;
      HIDWORD(v341) = v342;
      LODWORD(v341) = v342;
      v344 = (v341 >> 24) + v343;
      v582 = a2[14];
      v345 = __PAIR64__(v330, __ROR4__(v336, 22));
      v346 = v96 + 1836072691 + v343 + ((v344 | ~v340) ^ v345);
      LODWORD(v345) = v330;
      v347 = v345 >> 22;
      HIDWORD(v345) = v346;
      LODWORD(v345) = v346;
      v348 = (v345 >> 26) + v347;
      v349 = __PAIR64__(v286, __ROR4__(v340, 22));
      v350 = v34 + 1836072691 + v347 + ((v348 | ~v344) ^ v349);
      LODWORD(v349) = v286;
      v351 = v349 >> 22;
      HIDWORD(v349) = v336;
      LODWORD(v349) = v336;
      v352 = v349 >> 22;
      HIDWORD(v349) = v350;
      LODWORD(v349) = v350;
      v353 = (v349 >> 26) + v352;
      HIDWORD(v349) = v590 - 1894007588 + v333 + (v334 & __ROR4__(v300, 22) | v316 & ~__ROR4__(v300, 22));
      LODWORD(v349) = HIDWORD(v349);
      v354 = v96 - 1894007588 + v351;
      v355 = (v349 >> 26) + v351;
      v356 = __PAIR64__(v340, __ROR4__(v316, 22));
      v357 = v355 & v356 | v334 & ~__ROR4__(v316, 22);
      LODWORD(v356) = v340;
      v358 = v356 >> 22;
      HIDWORD(v356) = v41 + 1836072691 + v352 + ((v353 | ~v348) ^ __ROR4__(v344, 22));
      LODWORD(v356) = HIDWORD(v356);
      v359 = (v356 >> 18) + v358;
      v360 = __PAIR64__(v344, __ROR4__(v348, 22));
      v361 = v583 + 1836072691 + v358 + ((v359 | ~v353) ^ v360);
      LODWORD(v360) = v344;
      v362 = v360 >> 22;
      HIDWORD(v360) = v361;
      LODWORD(v360) = v361;
      v363 = (v360 >> 20) + v362;
      v364 = __PAIR64__(v348, __ROR4__(v353, 22));
      v365 = v584 + 1836072691 + v362 + ((v363 | ~v359) ^ v364);
      LODWORD(v364) = v348;
      v366 = v364 >> 22;
      HIDWORD(v364) = v365;
      LODWORD(v364) = v365;
      v367 = v354 + v357;
      v368 = (v364 >> 19) + v366;
      v369 = __PAIR64__(v300, __ROR4__(v359, 22));
      v370 = v585 + 1836072691 + v366 + ((v368 | ~v363) ^ v369);
      LODWORD(v369) = v300;
      v371 = v369 >> 22;
      HIDWORD(v369) = v367;
      LODWORD(v369) = v367;
      v372 = (v369 >> 24) + v371;
      HIDWORD(v369) = v353;
      LODWORD(v369) = v353;
      v373 = v369 >> 22;
      HIDWORD(v369) = v370;
      LODWORD(v369) = v370;
      v374 = (v369 >> 27) + v373;
      v375 = __PAIR64__(v359, __ROR4__(v363, 22));
      v376 = v19 + 1836072691 + v373 + ((v374 | ~v368) ^ v375);
      LODWORD(v375) = v359;
      v377 = v375 >> 22;
      HIDWORD(v375) = v376;
      LODWORD(v375) = v376;
      v378 = (v375 >> 18) + v377;
      v379 = __PAIR64__(v363, __ROR4__(v368, 22));
      v380 = v591 + 1836072691 + v377 + ((v378 | ~v374) ^ v379);
      LODWORD(v379) = v363;
      v381 = v379 >> 22;
      HIDWORD(v379) = v380;
      LODWORD(v379) = v380;
      v382 = (v379 >> 19) + v381;
      v383 = __PAIR64__(v368, __ROR4__(v374, 22));
      v384 = *a2 + 1836072691 + v381 + ((v382 | ~v378) ^ v383);
      LODWORD(v383) = v368;
      v385 = v383 >> 22;
      HIDWORD(v383) = v384;
      LODWORD(v383) = v384;
      v386 = (v383 >> 19) + v385;
      v387 = __PAIR64__(v316, __ROR4__(v378, 22));
      v388 = v25 + 1836072691 + v385 + ((v386 | ~v382) ^ v387);
      LODWORD(v387) = v316;
      v389 = v387 >> 22;
      HIDWORD(v387) = v374;
      LODWORD(v387) = v374;
      v390 = v387 >> 22;
      HIDWORD(v387) = v388;
      LODWORD(v387) = v388;
      v391 = (v387 >> 25) + v390;
      HIDWORD(v387) = v26 - 1894007588 + v371 + (v372 & __ROR4__(v334, 22) | v355 & ~__ROR4__(v334, 22));
      LODWORD(v387) = HIDWORD(v387);
      v392 = v34 - 1894007588 + v389;
      v393 = (v387 >> 26) + v389;
      v394 = __PAIR64__(v378, __ROR4__(v355, 22));
      v395 = v393 & v394 | v372 & ~__ROR4__(v355, 22);
      LODWORD(v394) = v378;
      v396 = v394 >> 22;
      HIDWORD(v394) = v56 + 1836072691 + v390 + ((v391 | ~v386) ^ __ROR4__(v382, 22));
      LODWORD(v394) = HIDWORD(v394);
      v397 = v394 >> 27;
      HIDWORD(v394) = v334;
      LODWORD(v394) = v334;
      v398 = v394 >> 22;
      v399 = v397 + v396;
      HIDWORD(v394) = v386;
      LODWORD(v394) = v386;
      v400 = v394 >> 22;
      HIDWORD(v394) = v392 + v395;
      LODWORD(v394) = v392 + v395;
      v401 = v19 - 1894007588 + v398;
      v402 = (v394 >> 27) + v398;
      v403 = __PAIR64__(v382, __ROR4__(v372, 22));
      v404 = v402 & v403 | v393 & ~__ROR4__(v372, 22);
      LODWORD(v403) = v382;
      v405 = v403 >> 22;
      HIDWORD(v403) = v584 + 2053994217 + v396 + (v391 & v399 | v400 & ~v399);
      LODWORD(v403) = HIDWORD(v403);
      v406 = v403 >> 17;
      HIDWORD(v403) = v355;
      LODWORD(v403) = v355;
      v407 = v403 >> 22;
      v408 = v406 + v405;
      HIDWORD(v403) = v391;
      LODWORD(v403) = v391;
      v409 = v403 >> 22;
      HIDWORD(v403) = v401 + v404;
      LODWORD(v403) = v401 + v404;
      v410 = v25 - 1454113458 + v407;
      v411 = (v403 >> 20) + v407;
      HIDWORD(v403) = v34 + 2053994217 + v405 + (v399 & v408 | v409 & ~v408);
      LODWORD(v403) = HIDWORD(v403);
      v412 = (v403 >> 27) + v400;
      HIDWORD(v403) = v399;
      LODWORD(v403) = v399;
      v413 = v403 >> 22;
      HIDWORD(v403) = v372;
      LODWORD(v403) = v372;
      v414 = v403 >> 22;
      HIDWORD(v403) = v410 + (v411 ^ (v402 | ~__ROR4__(v393, 22)));
      LODWORD(v403) = HIDWORD(v403);
      v415 = *a2 - 1454113458 + v414;
      v416 = (v403 >> 23) + v414;
      HIDWORD(v403) = v393;
      LODWORD(v403) = v393;
      v417 = v403 >> 22;
      HIDWORD(v403) = v25 + 2053994217 + v400 + (v408 & v412 | v413 & ~v412);
      LODWORD(v403) = HIDWORD(v403);
      v418 = v403 >> 24;
      v419 = __PAIR64__(v408, __ROR4__(v402, 22));
      v420 = v415 + (v416 ^ (v411 | ~(_DWORD)v419));
      v421 = v418 + v409;
      LODWORD(v419) = v408;
      v422 = v419 >> 22;
      HIDWORD(v419) = v420;
      LODWORD(v419) = v420;
      v423 = v26 - 1454113458 + v417;
      v424 = (v419 >> 17) + v417;
      HIDWORD(v419) = v589 + 2053994217 + v409 + (v412 & v421 | v422 & ~v421);
      LODWORD(v419) = HIDWORD(v419);
      v425 = (v419 >> 21) + v413;
      HIDWORD(v419) = v412;
      LODWORD(v419) = v412;
      v426 = v419 >> 22;
      HIDWORD(v419) = v402;
      LODWORD(v419) = v402;
      v427 = v419 >> 22;
      HIDWORD(v419) = v423 + (v424 ^ (v416 | ~__ROR4__(v411, 22)));
      LODWORD(v419) = HIDWORD(v419);
      v428 = v41 - 1454113458 + v427;
      v429 = (v419 >> 27) + v427;
      HIDWORD(v419) = v411;
      LODWORD(v419) = v411;
      v430 = v419 >> 22;
      HIDWORD(v419) = v18 + 2053994217 + v413 + (v421 & v425 | v426 & ~v425);
      LODWORD(v419) = HIDWORD(v419);
      v431 = v419 >> 18;
      v432 = __PAIR64__(v421, __ROR4__(v416, 22));
      v433 = v428 + (v429 ^ (v424 | ~(_DWORD)v432));
      v434 = v431 + v422;
      LODWORD(v432) = v421;
      v435 = v432 >> 22;
      HIDWORD(v432) = v433;
      LODWORD(v432) = v433;
      v436 = v35 - 1454113458 + v430;
      v437 = (v432 >> 21) + v430;
      HIDWORD(v432) = v583 + 2053994217 + v422 + (v425 & v434 | v435 & ~v434);
      LODWORD(v432) = HIDWORD(v432);
      v438 = (v432 >> 18) + v426;
      HIDWORD(v432) = v425;
      LODWORD(v432) = v425;
      v439 = v432 >> 22;
      HIDWORD(v432) = v416;
      LODWORD(v432) = v416;
      v440 = v432 >> 22;
      HIDWORD(v432) = v436 + (v437 ^ (v429 | ~__ROR4__(v424, 22)));
      LODWORD(v432) = HIDWORD(v432);
      v441 = v585 - 1454113458 + v440;
      v442 = (v432 >> 26) + v440;
      HIDWORD(v432) = v424;
      LODWORD(v432) = v424;
      v443 = v432 >> 22;
      HIDWORD(v432) = v590 + 2053994217 + v426 + (v434 & v438 | v439 & ~v438);
      LODWORD(v432) = HIDWORD(v432);
      v444 = v432 >> 26;
      v445 = __PAIR64__(v434, __ROR4__(v429, 22));
      v446 = v441 + (v442 ^ (v437 | ~(_DWORD)v445));
      v447 = v444 + v435;
      LODWORD(v445) = v434;
      v448 = v445 >> 22;
      HIDWORD(v445) = v446;
      LODWORD(v445) = v446;
      v449 = v19 - 1454113458 + v443;
      v450 = (v445 >> 24) + v443;
      HIDWORD(v445) = *a2 + 2053994217 + v435 + (v438 & v447 | v448 & ~v447);
      LODWORD(v445) = HIDWORD(v445);
      v451 = (v445 >> 18) + v439;
      HIDWORD(v445) = v438;
      LODWORD(v445) = v438;
      v452 = v445 >> 22;
      HIDWORD(v445) = v429;
      LODWORD(v445) = v429;
      v453 = v445 >> 22;
      HIDWORD(v445) = v449 + (v450 ^ (v442 | ~__ROR4__(v437, 22)));
      LODWORD(v445) = HIDWORD(v445);
      v454 = v591 - 1454113458 + v453;
      v455 = (v445 >> 19) + v453;
      HIDWORD(v445) = v437;
      LODWORD(v445) = v437;
      v456 = v445 >> 22;
      HIDWORD(v445) = v26 + 2053994217 + v439 + (v447 & v451 | v452 & ~v451);
      LODWORD(v445) = HIDWORD(v445);
      v457 = v445 >> 26;
      v458 = __PAIR64__(v447, __ROR4__(v442, 22));
      v459 = v454 + (v455 ^ (v450 | ~(_DWORD)v458));
      v460 = v457 + v448;
      LODWORD(v458) = v447;
      v461 = v458 >> 22;
      HIDWORD(v458) = v459;
      LODWORD(v458) = v459;
      v462 = v582 - 1454113458 + v456;
      v463 = (v458 >> 20) + v456;
      HIDWORD(v458) = v585 + 2053994217 + v448 + (v451 & v460 | v461 & ~v460);
      LODWORD(v458) = HIDWORD(v458);
      v464 = (v458 >> 23) + v452;
      HIDWORD(v458) = v451;
      LODWORD(v458) = v451;
      v465 = v458 >> 22;
      HIDWORD(v458) = v442;
      LODWORD(v458) = v442;
      v466 = v458 >> 22;
      HIDWORD(v458) = v462 + (v463 ^ (v455 | ~__ROR4__(v450, 22)));
      LODWORD(v458) = HIDWORD(v458);
      v467 = v589 - 1454113458 + v466;
      v468 = (v458 >> 27) + v466;
      HIDWORD(v458) = v450;
      LODWORD(v458) = v450;
      v469 = v458 >> 22;
      HIDWORD(v458) = v19 + 2053994217 + v452 + (v460 & v464 | v465 & ~v464);
      LODWORD(v458) = HIDWORD(v458);
      v470 = v458 >> 20;
      v471 = __PAIR64__(v460, __ROR4__(v455, 22));
      v472 = v467 + (v468 ^ (v463 | ~(_DWORD)v471));
      v473 = v470 + v461;
      LODWORD(v471) = v460;
      v474 = v471 >> 22;
      HIDWORD(v471) = v472;
      LODWORD(v471) = v472;
      v475 = v18 - 1454113458 + v469;
      v476 = (v471 >> 20) + v469;
      v477 = v56 + 2053994217 + v461 + (v464 & v473 | v474 & ~v473);
      v478 = __PAIR64__(v477, __ROR4__(v463, 22));
      v479 = v475 + (v476 ^ (v468 | ~(_DWORD)v478));
      LODWORD(v478) = v477;
      v480 = (v478 >> 23) + v465;
      HIDWORD(v478) = v464;
      LODWORD(v478) = v464;
      v481 = v478 >> 22;
      HIDWORD(v478) = v455;
      LODWORD(v478) = v455;
      v482 = v478 >> 22;
      HIDWORD(v478) = v479;
      LODWORD(v478) = v479;
      v483 = v584 - 1454113458 + v482;
      v484 = (v478 >> 19) + v482;
      HIDWORD(v478) = v463;
      LODWORD(v478) = v463;
      v485 = v478 >> 22;
      HIDWORD(v478) = v41 + 2053994217 + v465 + (v473 & v480 | v481 & ~v480);
      LODWORD(v478) = HIDWORD(v478);
      v486 = v478 >> 20;
      v487 = __PAIR64__(v473, __ROR4__(v468, 22));
      v488 = v483 + (v484 ^ (v476 | ~(_DWORD)v487));
      v489 = v486 + v474;
      LODWORD(v487) = v473;
      v490 = v487 >> 22;
      HIDWORD(v487) = v488;
      LODWORD(v487) = v488;
      v491 = v583 - 1454113458 + v485;
      v492 = (v487 >> 18) + v485;
      v493 = v35 + 2053994217 + v474 + (v480 & (v486 + v474) | v490 & ~(v486 + v474));
      v494 = __PAIR64__(v493, __ROR4__(v476, 22));
      v495 = v491 + (v492 ^ (v484 | ~(_DWORD)v494));
      LODWORD(v494) = v493;
      v496 = (v494 >> 27) + v481;
      HIDWORD(v494) = v480;
      LODWORD(v494) = v480;
      v497 = v494 >> 22;
      HIDWORD(v494) = v468;
      LODWORD(v494) = v468;
      v498 = v494 >> 22;
      v499 = v591 + 2053994217 + v481 + (v489 & v496 | v497 & ~v496);
      HIDWORD(v494) = v495;
      LODWORD(v494) = v495;
      v500 = v34 - 1454113458 + v498;
      v501 = (v494 >> 21) + v498;
      HIDWORD(v494) = v476;
      LODWORD(v494) = v476;
      v502 = v494 >> 22;
      HIDWORD(v494) = v499;
      LODWORD(v494) = v499;
      v503 = v494 >> 17;
      v504 = __PAIR64__(v489, __ROR4__(v484, 22));
      v505 = v500 + (v501 ^ (v492 | ~(_DWORD)v504));
      v506 = v503 + v490;
      LODWORD(v504) = v489;
      v507 = v504 >> 22;
      v508 = v496 & (v503 + v490) | v507 & ~(v503 + v490);
      HIDWORD(v504) = v505;
      LODWORD(v504) = v505;
      v509 = (v504 >> 24) + v502;
      HIDWORD(v504) = v582 + 2053994217 + v490 + v508;
      LODWORD(v504) = HIDWORD(v504);
      v510 = (v504 >> 24) + v497;
      LODWORD(v504) = v497 + v585 + (v506 ^ __ROR4__(v496, 22) ^ v510);
      HIDWORD(v504) = v504;
      v511 = (v504 >> 24) + v507;
      v512 = __PAIR64__(v496, __ROR4__(v506, 22));
      v513 = v510 ^ v512 ^ v511;
      LODWORD(v512) = v496;
      v514 = v512 >> 22;
      HIDWORD(v512) = v507 + v590 + v513;
      LODWORD(v512) = HIDWORD(v512);
      v515 = (v512 >> 27) + v514;
      v516 = __PAIR64__(v506, __ROR4__(v510, 22));
      v517 = v514 + v591 + (v511 ^ v516 ^ v515);
      LODWORD(v516) = v506;
      v518 = v516 >> 22;
      HIDWORD(v516) = v517;
      LODWORD(v516) = v517;
      v519 = (v516 >> 20) + v518;
      v520 = __PAIR64__(v510, __ROR4__(v511, 22));
      v521 = v515 ^ v520 ^ v519;
      LODWORD(v520) = v510;
      v522 = v520 >> 22;
      HIDWORD(v520) = v518 + v25 + v521;
      LODWORD(v520) = HIDWORD(v520);
      v523 = (v520 >> 23) + v522;
      v524 = __PAIR64__(v511, __ROR4__(v515, 22));
      v525 = v522 + v589 + (v519 ^ v524 ^ v523);
      LODWORD(v524) = v511;
      v526 = v524 >> 22;
      HIDWORD(v524) = v525;
      LODWORD(v524) = v525;
      v527 = (v524 >> 20) + v526;
      v528 = __PAIR64__(v515, __ROR4__(v519, 22));
      v529 = v523 ^ v528 ^ v527;
      LODWORD(v528) = v515;
      v530 = v528 >> 22;
      HIDWORD(v528) = v526 + v26 + v529;
      LODWORD(v528) = HIDWORD(v528);
      v531 = (v528 >> 27) + v530;
      v532 = __PAIR64__(v519, __ROR4__(v523, 22));
      v533 = v530 + v584 + (v527 ^ v532 ^ v531);
      LODWORD(v532) = v519;
      v534 = v532 >> 22;
      HIDWORD(v532) = v533;
      LODWORD(v532) = v533;
      v535 = (v532 >> 18) + v534;
      v536 = __PAIR64__(v523, __ROR4__(v527, 22));
      v537 = v531 ^ v536 ^ v535;
      LODWORD(v536) = v523;
      v538 = v536 >> 22;
      HIDWORD(v536) = v534 + v35 + v537;
      LODWORD(v536) = HIDWORD(v536);
      v539 = (v536 >> 26) + v538;
      v540 = __PAIR64__(v527, __ROR4__(v531, 22));
      v541 = v538 + v34 + (v535 ^ v540 ^ v539);
      LODWORD(v540) = v527;
      v542 = v540 >> 22;
      HIDWORD(v540) = v541;
      LODWORD(v540) = v541;
      v543 = (v540 >> 24) + v542;
      v544 = __PAIR64__(v531, __ROR4__(v492, 22));
      v545 = v509 ^ (v501 | ~(_DWORD)v544);
      LODWORD(v544) = v531;
      v546 = v544 >> 22;
      HIDWORD(v544) = v542 + v19 + (v539 ^ __ROR4__(v535, 22) ^ v543);
      LODWORD(v544) = HIDWORD(v544);
      v547 = v590 - 1454113458 + v502 + v545;
      v548 = (v544 >> 19) + v546;
      v549 = __PAIR64__(v535, __ROR4__(v539, 22));
      v550 = v543 ^ v549 ^ v548;
      LODWORD(v549) = v535;
      v551 = v549 >> 22;
      HIDWORD(v549) = v546 + v56 + v550;
      LODWORD(v549) = HIDWORD(v549);
      v552 = (v549 >> 26) + v551;
      v553 = __PAIR64__(v539, __ROR4__(v543, 22));
      v554 = v551 + v582 + (v548 ^ v553 ^ v552);
      LODWORD(v553) = v539;
      v555 = v553 >> 22;
      HIDWORD(v553) = v554;
      LODWORD(v553) = v554;
      v556 = (v553 >> 27) + v555;
      v557 = __PAIR64__(v543, __ROR4__(v548, 22));
      v558 = v552 ^ v557 ^ v556;
      LODWORD(v557) = v543;
      v559 = v557 >> 22;
      HIDWORD(v557) = v555 + *a2 + v558;
      LODWORD(v557) = HIDWORD(v557);
      v560 = (v557 >> 17) + v559;
      v561 = __PAIR64__(v548, __ROR4__(v552, 22));
      v562 = v559 + v596 + (v556 ^ v561 ^ v560);
      LODWORD(v561) = v548;
      v563 = v561 >> 22;
      HIDWORD(v561) = v562;
      LODWORD(v561) = v562;
      v564 = (v561 >> 19) + v563;
      v565 = __PAIR64__(v484, __ROR4__(v556, 22));
      v566 = v560 ^ v565 ^ v564;
      LODWORD(v565) = v484;
      v567 = v565 >> 22;
      v568 = v563 + v41 + v566;
      HIDWORD(v565) = v547;
      LODWORD(v565) = v547;
      v569 = v56 - 1454113458 + v567;
      v570 = (v565 >> 27) + v567;
      v572 = __PAIR64__(v552, __ROR4__(v501, 22));
      v571 = v509 | ~(_DWORD)v572;
      LODWORD(v572) = v552;
      v573 = v572 >> 22;
      HIDWORD(v572) = v568;
      LODWORD(v572) = v568;
      v574 = v569 + (v570 ^ v571);
      v575 = (v572 >> 21) + v573;
      v576 = __PAIR64__(v564, __ROR4__(v560, 22));
      result = (_DWORD *)(v573 + v583 + (v564 ^ v576 ^ v575));
      LODWORD(v576) = v564;
      v5 = v570 + v4 + (v576 >> 22);
      HIDWORD(v576) = v560;
      LODWORD(v576) = v560;
      v577 = v593 + (v576 >> 22);
      HIDWORD(v576) = v509;
      LODWORD(v576) = v509;
      v4 = (v576 >> 22) + v577;
      HIDWORD(v576) = v501;
      LODWORD(v576) = v501;
      v578 = v576 >> 22;
      HIDWORD(v576) = v556;
      LODWORD(v576) = v556;
      v579 = v576 >> 22;
      v7 = v578 + v592 + v579;
      HIDWORD(v576) = v492;
      LODWORD(v576) = v492;
      v580 = v576 >> 22;
      HIDWORD(v576) = (_DWORD)result;
      LODWORD(v576) = (_DWORD)result;
      v6 = v580 + v594 + v579 + (v576 >> 21);
      HIDWORD(v576) = v574;
      LODWORD(v576) = v574;
      v8 = v580 + v595 + v575 + (v576 >> 26);
      v581[2] = v7;
      v581[3] = v6;
      v581[4] = v8;
      *v581 = v5;
      v581[1] = v4;
      a2 += 16;
      a3 = v588 - 1;
    }
    while (v588 != 1);
  }
  return result;
}

void RIPEMD160_Transform(RIPEMD160_CTX *c, const unsigned __int8 *b)
{
  ripemd160_block_data_order(c, b, 1);
}

int RIPEMD160_Final(unsigned __int8 *md, RIPEMD160_CTX *c)
{
  unsigned int *data;
  uint64_t num;
  uint64_t v6;
  unsigned int Nh;

  data = c->data;
  num = c->num;
  *((_BYTE *)c->data + num) = 0x80;
  v6 = num + 1;
  if (num >= 0x38)
  {
    bzero((char *)data + v6, 63 - num);
    ripemd160_block_data_order(c, data, 1);
    v6 = 0;
  }
  bzero((char *)data + v6, 56 - v6);
  Nh = c->Nh;
  c->data[14] = c->Nl;
  c->data[15] = Nh;
  ripemd160_block_data_order(c, data, 1);
  c->num = 0;
  *(_OWORD *)data = 0u;
  *((_OWORD *)data + 1) = 0u;
  *((_OWORD *)data + 2) = 0u;
  *((_OWORD *)data + 3) = 0u;
  *(_DWORD *)md = c->A;
  *((_DWORD *)md + 1) = c->B;
  *((_DWORD *)md + 2) = c->C;
  *((_DWORD *)md + 3) = c->D;
  *((_DWORD *)md + 4) = c->E;
  return 1;
}

int RIPEMD160_Init(RIPEMD160_CTX *c)
{
  *(_OWORD *)&c->data[9] = 0u;
  *(_OWORD *)&c->data[13] = 0u;
  *(_OWORD *)&c->data[1] = 0u;
  *(_OWORD *)&c->data[5] = 0u;
  *(_OWORD *)&c->A = xmmword_22D69F860;
  *(_OWORD *)&c->E = 0u;
  c->E = -1009589776;
  return 1;
}

ASN1_VALUE *d2i_RSA_PSS_PARAMS(ASN1_VALUE **a1, const unsigned __int8 **a2, uint64_t a3)
{
  return ASN1_item_d2i(a1, a2, a3, &RSA_PSS_PARAMS_it);
}

uint64_t i2d_RSA_PSS_PARAMS(ASN1_VALUE *a1, unsigned __int8 **a2)
{
  return ASN1_item_i2d(a1, a2, &RSA_PSS_PARAMS_it);
}

ASN1_VALUE *RSA_PSS_PARAMS_new()
{
  return ASN1_item_new(&RSA_PSS_PARAMS_it);
}

void RSA_PSS_PARAMS_free(ASN1_VALUE *a1)
{
  ASN1_item_free(a1, &RSA_PSS_PARAMS_it);
}

ASN1_VALUE *d2i_RSA_OAEP_PARAMS(ASN1_VALUE **a1, const unsigned __int8 **a2, uint64_t a3)
{
  return ASN1_item_d2i(a1, a2, a3, &RSA_OAEP_PARAMS_it);
}

uint64_t i2d_RSA_OAEP_PARAMS(ASN1_VALUE *a1, unsigned __int8 **a2)
{
  return ASN1_item_i2d(a1, a2, &RSA_OAEP_PARAMS_it);
}

ASN1_VALUE *RSA_OAEP_PARAMS_new()
{
  return ASN1_item_new(&RSA_OAEP_PARAMS_it);
}

void RSA_OAEP_PARAMS_free(ASN1_VALUE *a1)
{
  ASN1_item_free(a1, &RSA_OAEP_PARAMS_it);
}

RSA *__cdecl d2i_RSAPrivateKey(RSA **a, const unsigned __int8 **in, uint64_t len)
{
  return (RSA *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &RSAPrivateKey_it);
}

int i2d_RSAPrivateKey(const RSA *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &RSAPrivateKey_it);
}

RSA *__cdecl d2i_RSAPublicKey(RSA **a, const unsigned __int8 **in, uint64_t len)
{
  return (RSA *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &RSAPublicKey_it);
}

int i2d_RSAPublicKey(const RSA *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &RSAPublicKey_it);
}

RSA *__cdecl RSAPublicKey_dup(RSA *rsa)
{
  return (RSA *)ASN1_item_dup(&RSAPublicKey_it, rsa);
}

RSA *__cdecl RSAPrivateKey_dup(RSA *rsa)
{
  return (RSA *)ASN1_item_dup(&RSAPrivateKey_it, rsa);
}

uint64_t rsa_cb(int a1, RSA **a2)
{
  RSA *v3;

  if (a1 == 2)
  {
    RSA_free(*a2);
    *a2 = 0;
    return 2;
  }
  else if (a1)
  {
    return 1;
  }
  else
  {
    v3 = RSA_new();
    *a2 = v3;
    return 2 * (v3 != 0);
  }
}

uint64_t rsa_pss_cb(int a1, uint64_t a2)
{
  if (a1 == 2)
    X509_ALGOR_free(*(X509_ALGOR **)(*(_QWORD *)a2 + 32));
  return 1;
}

uint64_t rsa_oaep_cb(int a1, uint64_t a2)
{
  if (a1 == 2)
    X509_ALGOR_free(*(X509_ALGOR **)(*(_QWORD *)a2 + 24));
  return 1;
}

X509_EXTENSION *__cdecl d2i_X509_EXTENSION(X509_EXTENSION **a, const unsigned __int8 **in, uint64_t len)
{
  return (X509_EXTENSION *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &X509_EXTENSION_it);
}

int i2d_X509_EXTENSION(X509_EXTENSION *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &X509_EXTENSION_it);
}

X509_EXTENSION *X509_EXTENSION_new(void)
{
  return (X509_EXTENSION *)ASN1_item_new(&X509_EXTENSION_it);
}

void X509_EXTENSION_free(X509_EXTENSION *a)
{
  ASN1_item_free((ASN1_VALUE *)a, &X509_EXTENSION_it);
}

X509_EXTENSIONS *__cdecl d2i_X509_EXTENSIONS(X509_EXTENSIONS **a, const unsigned __int8 **in, uint64_t len)
{
  return (X509_EXTENSIONS *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &X509_EXTENSIONS_it);
}

int i2d_X509_EXTENSIONS(X509_EXTENSIONS *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &X509_EXTENSIONS_it);
}

X509_EXTENSION *__cdecl X509_EXTENSION_dup(X509_EXTENSION *ex)
{
  return (X509_EXTENSION *)ASN1_item_dup(&X509_EXTENSION_it, ex);
}

uint64_t dsa_pub_decode(EVP_PKEY *a1, uint64_t a2)
{
  uint64_t result;
  DSA *v5;
  int v6;
  int v7;
  ASN1_INTEGER *v8;
  ASN1_INTEGER *v9;
  BIGNUM *v10;
  X509_ALGOR *algor;
  void *ppval;
  int pptype[2];
  unsigned __int8 *pp;
  unsigned __int8 *in;

  pp = 0;
  in = 0;
  ppval = 0;
  *(_QWORD *)pptype = 0;
  algor = 0;
  result = X509_PUBKEY_get0_param(0, &in, &pptype[1], &algor, a2);
  if ((_DWORD)result)
  {
    X509_ALGOR_get0(0, pptype, &ppval, algor);
    if (pptype[0] == -1 || pptype[0] == 5)
    {
      v5 = DSA_new();
      if (v5)
      {
LABEL_11:
        v8 = d2i_ASN1_INTEGER(0, (const unsigned __int8 **)&in, pptype[1]);
        if (v8)
        {
          v9 = v8;
          v10 = ASN1_INTEGER_to_BN(v8, 0);
          v5->g = v10;
          if (v10)
          {
            if (pptype[0] != 16 || dsa_check_key((uint64_t)v5))
            {
              ASN1_INTEGER_free(v9);
              EVP_PKEY_assign(a1, 116, (char *)v5);
              return 1;
            }
          }
          else
          {
            ERR_put_error(10, 4095, 108, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/dsa/dsa_ameth.c", 117);
          }
          ASN1_INTEGER_free(v9);
          goto LABEL_22;
        }
        v6 = 104;
        v7 = 112;
        goto LABEL_21;
      }
      v6 = 65;
      v7 = 103;
    }
    else
    {
      if (pptype[0] != 16)
      {
        ERR_put_error(10, 4095, 105, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/dsa/dsa_ameth.c", 107);
        v5 = 0;
LABEL_22:
        DSA_free(v5);
        return 0;
      }
      pp = (unsigned __int8 *)*((_QWORD *)ppval + 1);
      v5 = d2i_DSAparams(0, (const unsigned __int8 **)&pp, *(int *)ppval);
      if (v5)
        goto LABEL_11;
      v6 = 104;
      v7 = 98;
    }
LABEL_21:
    ERR_put_error(10, 4095, v6, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/dsa/dsa_ameth.c", v7);
    goto LABEL_22;
  }
  return result;
}

uint64_t dsa_pub_encode(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  ASN1_STRING *v4;
  ASN1_STRING *v5;
  int v6;
  int v7;
  ASN1_INTEGER *v8;
  ASN1_INTEGER *v9;
  int v10;
  ASN1_OBJECT *v11;
  int v13;
  unsigned __int8 *out;

  out = 0;
  v3 = *(_QWORD *)(a2 + 32);
  if (*(_DWORD *)(a2 + 40) && *(_QWORD *)(v3 + 16) && *(_QWORD *)(v3 + 24) && *(_QWORD *)(v3 + 32))
  {
    v4 = ASN1_STRING_new();
    v5 = v4;
    if (!v4)
    {
      v13 = 151;
      goto LABEL_17;
    }
    v6 = i2d_DSAparams((const DSA *)v3, &v4->data);
    v5->length = v6;
    if (v6 <= 0)
    {
      v13 = 156;
      goto LABEL_17;
    }
    v7 = 16;
  }
  else
  {
    v5 = 0;
    v7 = -1;
  }
  v8 = BN_to_ASN1_INTEGER(*(BIGNUM **)(v3 + 40), 0);
  if (!v8)
  {
    v13 = 163;
LABEL_17:
    ERR_put_error(10, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/dsa/dsa_ameth.c", v13);
    goto LABEL_18;
  }
  v9 = v8;
  v10 = i2d_ASN1_INTEGER(v8, &out);
  ASN1_INTEGER_free(v9);
  if (v10 <= 0)
  {
    v13 = 171;
    goto LABEL_17;
  }
  v11 = OBJ_nid2obj(116);
  if (X509_PUBKEY_set0_param(a1, v11, v7, v5, out, v10))
    return 1;
LABEL_18:
  free(out);
  ASN1_STRING_free(v5);
  return 0;
}

BOOL dsa_pub_cmp(uint64_t a1, uint64_t a2)
{
  return BN_cmp(*(const BIGNUM **)(*(_QWORD *)(a2 + 32) + 40), *(const BIGNUM **)(*(_QWORD *)(a1 + 32) + 40)) == 0;
}

BOOL dsa_pub_print(BIO *a1, uint64_t a2, int a3)
{
  return do_dsa_print(a1, *(const BIGNUM ***)(a2 + 32), a3, 1);
}

uint64_t dsa_priv_decode(EVP_PKEY *a1, uint64_t a2)
{
  ASN1_INTEGER *v3;
  BN_CTX *v4;
  DSA *v5;
  ASN1_INTEGER *v6;
  int v7;
  int v8;
  uint64_t v9;
  BIGNUM *v11;
  BIGNUM *v12;
  BN_CTX *v13;
  int v14;
  int v15;
  X509_ALGOR *algor;
  void *ppval;
  int pptype[2];
  unsigned __int8 *pp;
  unsigned __int8 *in;

  pp = 0;
  in = 0;
  ppval = 0;
  *(_QWORD *)pptype = 0;
  algor = 0;
  if (!PKCS8_pkey_get0(0, &in, &pptype[1], &algor, a2))
    return 0;
  X509_ALGOR_get0(0, pptype, &ppval, algor);
  v3 = 0;
  v4 = 0;
  v5 = 0;
  if (pptype[0] != 16)
    goto LABEL_6;
  v6 = d2i_ASN1_INTEGER(0, (const unsigned __int8 **)&in, pptype[1]);
  v3 = v6;
  if (!v6 || v6->type == 258)
  {
    v4 = 0;
    v5 = 0;
    goto LABEL_6;
  }
  pp = (unsigned __int8 *)*((_QWORD *)ppval + 1);
  v5 = d2i_DSAparams(0, (const unsigned __int8 **)&pp, *(int *)ppval);
  if (!v5)
  {
    v4 = 0;
    goto LABEL_6;
  }
  v11 = ASN1_INTEGER_to_BN(v3, 0);
  v5->pub_key = v11;
  if (!v11)
  {
    v14 = 109;
    v15 = 221;
LABEL_23:
    ERR_put_error(10, 4095, v14, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/dsa/dsa_ameth.c", v15);
    goto LABEL_24;
  }
  if (!dsa_check_key((uint64_t)v5))
  {
LABEL_24:
    v4 = 0;
    goto LABEL_8;
  }
  v12 = BN_new();
  v5->g = v12;
  if (!v12)
  {
    v14 = 65;
    v15 = 231;
    goto LABEL_23;
  }
  v13 = BN_CTX_new();
  v4 = v13;
  if (!v13)
  {
    v7 = 65;
    v8 = 236;
    goto LABEL_7;
  }
  BN_CTX_start(v13);
  if (!BN_mod_exp_ct(v5->g, v5->q, v5->pub_key, *(const BIGNUM **)&v5->write_params, v4))
  {
    v7 = 109;
    v8 = 243;
    goto LABEL_7;
  }
  if (EVP_PKEY_assign(a1, 116, (char *)v5))
  {
    v9 = 1;
    goto LABEL_9;
  }
LABEL_6:
  v7 = 104;
  v8 = 254;
LABEL_7:
  ERR_put_error(10, 4095, v7, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/dsa/dsa_ameth.c", v8);
LABEL_8:
  DSA_free(v5);
  v9 = 0;
LABEL_9:
  BN_CTX_end(v4);
  BN_CTX_free(v4);
  ASN1_INTEGER_free(v3);
  return v9;
}

uint64_t dsa_priv_encode(uint64_t a1, uint64_t a2)
{
  ASN1_STRING *v4;
  int v5;
  ASN1_INTEGER *v6;
  ASN1_INTEGER *v7;
  int v8;
  ASN1_OBJECT *v9;
  int v11;
  int v12;
  unsigned __int8 *v13;
  unsigned __int8 *out;

  out = 0;
  v4 = ASN1_STRING_new();
  if (!v4)
  {
    v11 = 65;
    v12 = 275;
LABEL_9:
    ERR_put_error(10, 4095, v11, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/dsa/dsa_ameth.c", v12);
    v13 = 0;
    goto LABEL_10;
  }
  v5 = i2d_DSAparams(*(const DSA **)(a2 + 32), &v4->data);
  v4->length = v5;
  if (v5 <= 0)
  {
    v11 = 65;
    v12 = 281;
    goto LABEL_9;
  }
  v4->type = 16;
  v6 = BN_to_ASN1_INTEGER(*(BIGNUM **)(*(_QWORD *)(a2 + 32) + 48), 0);
  if (!v6)
  {
    v11 = 109;
    v12 = 289;
    goto LABEL_9;
  }
  v7 = v6;
  v8 = i2d_ASN1_INTEGER(v6, &out);
  ASN1_INTEGER_free(v7);
  v9 = OBJ_nid2obj(116);
  if (PKCS8_pkey_set0(a1, v9, 0, 16, v4, out, v8))
    return 1;
  v13 = out;
LABEL_10:
  free(v13);
  ASN1_STRING_free(v4);
  ASN1_INTEGER_free(0);
  return 0;
}

BOOL dsa_priv_print(BIO *a1, uint64_t a2, int a3)
{
  return do_dsa_print(a1, *(const BIGNUM ***)(a2 + 32), a3, 2);
}

uint64_t int_dsa_size(uint64_t a1)
{
  return DSA_size(*(const DSA **)(a1 + 32));
}

uint64_t dsa_bits(uint64_t a1)
{
  return BN_num_bits(*(const BIGNUM **)(*(_QWORD *)(a1 + 32) + 16));
}

uint64_t dsa_security_bits(uint64_t a1)
{
  return DSA_security_bits(*(_QWORD *)(a1 + 32));
}

uint64_t dsa_param_decode(EVP_PKEY *a1, const unsigned __int8 **a2, int a3)
{
  DSA *v4;
  char *v5;

  v4 = d2i_DSAparams(0, a2, a3);
  if (v4)
  {
    v5 = (char *)v4;
    if (dsa_check_key((uint64_t)v4))
    {
      EVP_PKEY_assign(a1, 116, v5);
      return 1;
    }
    DSA_free((DSA *)v5);
  }
  else
  {
    ERR_put_error(10, 4095, 10, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/dsa/dsa_ameth.c", 467);
  }
  return 0;
}

uint64_t dsa_param_encode(uint64_t a1, unsigned __int8 **a2)
{
  return i2d_DSAparams(*(const DSA **)(a1 + 32), a2);
}

BOOL dsa_missing_parameters(uint64_t a1)
{
  _QWORD *v1;

  v1 = *(_QWORD **)(a1 + 32);
  return !v1[2] || !v1[3] || v1[4] == 0;
}

BIGNUM *dsa_copy_parameters(uint64_t a1, uint64_t a2)
{
  BIGNUM *result;
  BIGNUM *v5;
  BIGNUM *v6;
  BIGNUM *v7;

  result = BN_dup(*(const BIGNUM **)(*(_QWORD *)(a2 + 32) + 16));
  if (result)
  {
    v5 = result;
    BN_free(*(BIGNUM **)(*(_QWORD *)(a1 + 32) + 16));
    *(_QWORD *)(*(_QWORD *)(a1 + 32) + 16) = v5;
    result = BN_dup(*(const BIGNUM **)(*(_QWORD *)(a2 + 32) + 24));
    if (result)
    {
      v6 = result;
      BN_free(*(BIGNUM **)(*(_QWORD *)(a1 + 32) + 24));
      *(_QWORD *)(*(_QWORD *)(a1 + 32) + 24) = v6;
      result = BN_dup(*(const BIGNUM **)(*(_QWORD *)(a2 + 32) + 32));
      if (result)
      {
        v7 = result;
        BN_free(*(BIGNUM **)(*(_QWORD *)(a1 + 32) + 32));
        *(_QWORD *)(*(_QWORD *)(a1 + 32) + 32) = v7;
        return (BIGNUM *)1;
      }
    }
  }
  return result;
}

BOOL dsa_cmp_parameters(uint64_t a1, uint64_t a2)
{
  return !BN_cmp(*(const BIGNUM **)(*(_QWORD *)(a1 + 32) + 16), *(const BIGNUM **)(*(_QWORD *)(a2 + 32) + 16))
      && !BN_cmp(*(const BIGNUM **)(*(_QWORD *)(a1 + 32) + 24), *(const BIGNUM **)(*(_QWORD *)(a2 + 32) + 24))
      && BN_cmp(*(const BIGNUM **)(*(_QWORD *)(a1 + 32) + 32), *(const BIGNUM **)(*(_QWORD *)(a2 + 32) + 32)) == 0;
}

BOOL dsa_param_print(BIO *a1, uint64_t a2, int a3)
{
  return do_dsa_print(a1, *(const BIGNUM ***)(a2 + 32), a3, 0);
}

BOOL dsa_sig_print(BIO *bp, uint64_t a2, int *a3, int a4)
{
  DSA_SIG *v7;
  DSA_SIG *v8;
  const BIGNUM *r;
  int v10;
  int v11;
  int v12;
  unint64_t v13;
  _BOOL8 v14;
  const BIGNUM *s;
  int v16;
  int v17;
  int v18;
  uint64_t v19;
  unsigned __int8 *v20;
  unsigned __int8 *pp;

  if (!a3)
    return BIO_puts(bp, "\n") > 0;
  pp = (unsigned __int8 *)*((_QWORD *)a3 + 1);
  v7 = d2i_DSA_SIG(0, (const unsigned __int8 **)&pp, *a3);
  if (v7)
  {
    v8 = v7;
    r = v7->r;
    if (r)
    {
      v10 = BN_num_bits(r);
      v11 = v10 + 7;
      if (v10 < -7)
        v11 = v10 + 14;
      v12 = v11 >> 3;
      if ((v10 + 14) < 0xF)
        v12 = 0;
      v13 = v12;
    }
    else
    {
      v13 = 0;
    }
    s = v8->s;
    if (s)
    {
      v16 = BN_num_bits(s);
      v17 = v16 + 7;
      if (v16 < -7)
        v17 = v16 + 14;
      v18 = v17 >> 3;
      v19 = (uint64_t)v17 >> 3;
      if (v13 <= v18)
        v13 = v19;
    }
    v20 = (unsigned __int8 *)malloc_type_malloc(v13 + 10, 0xDC646523uLL);
    if (v20)
    {
      if (BIO_write(bp, "\n", 1) == 1 && ASN1_bn_print(bp, "r:   ", v8->r, v20, a4))
      {
        v14 = ASN1_bn_print(bp, "s:   ", v8->s, v20, a4) != 0;
LABEL_23:
        free(v20);
        DSA_SIG_free(v8);
        return v14;
      }
    }
    else
    {
      ERR_put_error(10, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/dsa/dsa_ameth.c", 604);
    }
    v14 = 0;
    goto LABEL_23;
  }
  return X509_signature_dump(bp, (unsigned int *)a3, a4);
}

void int_dsa_free(uint64_t a1)
{
  DSA_free(*(DSA **)(a1 + 32));
}

uint64_t dsa_pkey_ctrl(unsigned int *a1, int a2, uint64_t a3, _QWORD *a4)
{
  uint64_t result;
  int v6;
  int v7;
  int v8;
  X509_ALGOR *v9;
  ASN1_OBJECT *v10;
  X509_ALGOR *v11;
  const ASN1_OBJECT **v12;
  int v13;

  result = 4294967294;
  switch(a2)
  {
    case 1:
      if (a3)
        return 1;
      v13 = 0;
      v11 = 0;
      v12 = 0;
      PKCS7_SIGNER_INFO_get0_algs(a4, 0, &v12, &v11);
      goto LABEL_7;
    case 3:
      *(_DWORD *)a4 = 64;
      return 2;
    case 5:
      if (a3)
        return 1;
      v13 = 0;
      v11 = 0;
      v12 = 0;
      CMS_SignerInfo_get0_algs(a4, 0, 0, &v12, &v11);
LABEL_7:
      if (!v12)
        return 0xFFFFFFFFLL;
      if (!*v12)
        return 0xFFFFFFFFLL;
      v6 = OBJ_obj2nid(*v12);
      if (!v6)
        return 0xFFFFFFFFLL;
      v7 = v6;
      v8 = EVP_PKEY_id(a1);
      if (!OBJ_find_sigid_by_algs(&v13, v7, v8))
        return 0xFFFFFFFFLL;
      v9 = v11;
      v10 = OBJ_nid2obj(v13);
      X509_ALGOR_set0(v9, v10, -1, 0);
      return 1;
    case 8:
      *(_DWORD *)a4 = -1;
      return 1;
    default:
      return result;
  }
}

uint64_t old_dsa_priv_decode(EVP_PKEY *a1, const unsigned __int8 **a2, int a3)
{
  DSA *v4;
  DSA *v5;
  BN_CTX *v6;
  BN_CTX *v7;
  BIGNUM *v8;
  BIGNUM *v9;
  const BIGNUM *v10;
  const BIGNUM *v11;
  const BIGNUM *v12;
  int v13;
  int v14;

  v4 = d2i_DSAPrivateKey(0, a2, a3);
  v5 = v4;
  if (!v4)
  {
    ERR_put_error(10, 4095, 10, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/dsa/dsa_ameth.c", 510);
    goto LABEL_12;
  }
  if (!dsa_check_key((uint64_t)v4))
  {
LABEL_12:
    v7 = 0;
    goto LABEL_13;
  }
  v6 = BN_CTX_new();
  v7 = v6;
  if (!v6)
    goto LABEL_13;
  BN_CTX_start(v6);
  v8 = BN_CTX_get(v7);
  if (!v8)
    goto LABEL_13;
  v9 = v8;
  v10 = *(const BIGNUM **)&v5->write_params;
  v11 = BN_value_one();
  if (!BN_sub(v9, v10, v11) || !BN_mod_ct(v9, v9, v5->p, v7))
    goto LABEL_13;
  if (!BN_is_zero((uint64_t)v9))
  {
    v13 = 102;
    v14 = 535;
    goto LABEL_15;
  }
  if (!BN_mod_exp_ct(v9, v5->q, v5->p, *(const BIGNUM **)&v5->write_params, v7))
  {
LABEL_13:
    BN_CTX_end(v7);
    BN_CTX_free(v7);
    DSA_free(v5);
    return 0;
  }
  v12 = BN_value_one();
  if (BN_cmp(v9, v12))
  {
    v13 = 112;
    v14 = 548;
LABEL_15:
    ERR_put_error(10, 4095, v13, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/dsa/dsa_ameth.c", v14);
    goto LABEL_13;
  }
  if (BN_is_prime_ex(v5->p, 0, v7, 0) <= 0)
  {
    v13 = 102;
    v14 = 557;
    goto LABEL_15;
  }
  BN_CTX_end(v7);
  BN_CTX_free(v7);
  EVP_PKEY_assign(a1, 116, (char *)v5);
  return 1;
}

uint64_t old_dsa_priv_encode(uint64_t a1, unsigned __int8 **a2)
{
  return i2d_DSAPrivateKey(*(const DSA **)(a1 + 32), a2);
}

BOOL do_dsa_print(BIO *a1, const BIGNUM **a2, int a3, int a4)
{
  const BIGNUM *v7;
  const BIGNUM *v8;
  const BIGNUM *v9;
  const char *v10;
  const char *v11;
  const BIGNUM *v12;
  int v13;
  int v14;
  int v15;
  unint64_t v16;
  const BIGNUM *v17;
  int v18;
  int v19;
  int v20;
  uint64_t v21;
  const BIGNUM *v22;
  int v23;
  int v24;
  int v25;
  uint64_t v26;
  int v27;
  int v28;
  int v29;
  uint64_t v30;
  int v31;
  int v32;
  int v33;
  uint64_t v34;
  unsigned __int8 *v35;
  int v36;
  _BOOL8 v37;

  if (a4 == 2)
  {
    v7 = a2[6];
  }
  else
  {
    v7 = 0;
    v8 = 0;
    v9 = 0;
    if (a4 < 1)
      goto LABEL_5;
  }
  v9 = a2[5];
  v8 = v7;
LABEL_5:
  v10 = "DSA-Parameters";
  if (a4 == 1)
    v10 = "Public-Key";
  if (a4 == 2)
    v11 = "Private-Key";
  else
    v11 = v10;
  v12 = a2[2];
  if (v12)
  {
    v13 = BN_num_bits(v12);
    v14 = v13 + 7;
    if (v13 < -7)
      v14 = v13 + 14;
    v15 = v14 >> 3;
    if ((v13 + 14) < 0xF)
      v15 = 0;
    v16 = v15;
  }
  else
  {
    v16 = 0;
  }
  v17 = a2[3];
  if (v17)
  {
    v18 = BN_num_bits(v17);
    v19 = v18 + 7;
    if (v18 < -7)
      v19 = v18 + 14;
    v20 = v19 >> 3;
    v21 = (uint64_t)v19 >> 3;
    if (v16 <= v20)
      v16 = v21;
  }
  v22 = a2[4];
  if (v22)
  {
    v23 = BN_num_bits(v22);
    v24 = v23 + 7;
    if (v23 < -7)
      v24 = v23 + 14;
    v25 = v24 >> 3;
    v26 = (uint64_t)v24 >> 3;
    if (v16 <= v25)
      v16 = v26;
  }
  if (v8)
  {
    v27 = BN_num_bits(v8);
    v28 = v27 + 7;
    if (v27 < -7)
      v28 = v27 + 14;
    v29 = v28 >> 3;
    v30 = (uint64_t)v28 >> 3;
    if (v16 <= v29)
      v16 = v30;
  }
  if (v9)
  {
    v31 = BN_num_bits(v9);
    v32 = v31 + 7;
    if (v31 < -7)
      v32 = v31 + 14;
    v33 = v32 >> 3;
    v34 = (uint64_t)v32 >> 3;
    if (v16 <= v33)
      v16 = v34;
  }
  v35 = (unsigned __int8 *)malloc_type_malloc(v16 + 10, 0xBF0DC598uLL);
  if (!v35)
  {
    ERR_put_error(10, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/dsa/dsa_ameth.c", 433);
LABEL_47:
    v37 = 0;
    goto LABEL_48;
  }
  if (v8)
  {
    if (!BIO_indent(a1, a3, 128))
      goto LABEL_47;
    v36 = BN_num_bits(a2[2]);
    if (BIO_printf(a1, "%s: (%d bit)\n", v11, v36) < 1)
      goto LABEL_47;
  }
  if (!ASN1_bn_print(a1, "priv:", v8, v35, a3)
    || !ASN1_bn_print(a1, "pub: ", v9, v35, a3)
    || !ASN1_bn_print(a1, "P:   ", a2[2], v35, a3)
    || !ASN1_bn_print(a1, "Q:   ", a2[3], v35, a3))
  {
    goto LABEL_47;
  }
  v37 = ASN1_bn_print(a1, "G:   ", a2[4], v35, a3) != 0;
LABEL_48:
  free(v35);
  return v37;
}

BIO_METHOD *BIO_s_mem(void)
{
  return (BIO_METHOD *)&mem_method;
}

BIO *__cdecl BIO_new_mem_buf(void *buf, int len)
{
  unsigned int v2;
  BIO *result;
  BIO_METHOD *method;
  int v6;
  int v7;

  if (!buf)
  {
    v6 = 115;
    v7 = 128;
LABEL_9:
    ERR_put_error(32, 4095, v6, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/bio/bss_mem.c", v7);
    return 0;
  }
  v2 = len;
  if (len != -1)
  {
    if ((len & 0x80000000) == 0)
      goto LABEL_4;
    goto LABEL_8;
  }
  v2 = strlen((const char *)buf);
  if ((v2 & 0x80000000) != 0)
  {
LABEL_8:
    v6 = 125;
    v7 = 134;
    goto LABEL_9;
  }
LABEL_4:
  result = BIO_new(&mem_method);
  if (result)
  {
    method = result->next_bio->method;
    *(_QWORD *)&method->type = v2;
    method->name = (const char *)buf;
    method->bwrite = (int (__cdecl *)(BIO *, const char *, int))v2;
    result->num |= 0x200u;
    LODWORD(result->ptr) = 0;
  }
  return result;
}

uint64_t mem_write(uint64_t a1, const void *a2, uint64_t a3)
{
  BUF_MEM **v6;
  uint64_t v7;
  BUF_MEM *v8;
  unint64_t v9;
  char *v10;
  BOOL v11;
  size_t v12;
  size_t v13;
  BUF_MEM *v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v19;

  v6 = *(BUF_MEM ***)(a1 + 56);
  BIO_clear_flags((BIO *)a1, 15);
  v7 = 0;
  if (a2 && (int)a3 >= 1)
  {
    if ((*(_BYTE *)(a1 + 41) & 2) != 0)
    {
      ERR_put_error(32, 4095, 126, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/bio/bss_mem.c", 231);
      return 0xFFFFFFFFLL;
    }
    v8 = *v6;
    v9 = (unint64_t)v6[1];
    if (v9 <= 0x1000)
    {
      v17 = *(_QWORD *)&v8->length;
    }
    else
    {
      v10 = &v8->data[v9];
      v11 = *(_QWORD *)&v8->length >= v9;
      v12 = *(_QWORD *)&v8->length - v9;
      if (v11)
        v13 = v12;
      else
        v13 = 0;
      memmove(v8->data, v10, v13);
      v8 = *v6;
      v14 = v6[1];
      v15 = *(_QWORD *)&(*v6)->length;
      v11 = v15 >= (unint64_t)v14;
      v16 = v15 - (_QWORD)v14;
      if (v11)
        v17 = v16;
      else
        v17 = 0;
      *(_QWORD *)&v8->length = v17;
      v6[1] = 0;
    }
    v19 = v17 + a3;
    v7 = 0xFFFFFFFFLL;
    if (!__CFADD__(v17, a3) && !(v19 >> 31))
    {
      if (v19 == BUF_MEM_grow_clean(v8, v17 + a3))
      {
        memcpy(&(*v6)->data[v17], a2, a3);
        return a3;
      }
      return 0xFFFFFFFFLL;
    }
  }
  return v7;
}

unint64_t mem_read(uint64_t a1, void *a2, unint64_t a3)
{
  unint64_t **v6;
  unint64_t result;
  unint64_t v8;
  unint64_t v9;
  BOOL v10;
  unint64_t v11;

  v6 = *(unint64_t ***)(a1 + 56);
  BIO_clear_flags((BIO *)a1, 15);
  result = 0;
  if (a2 && (int)a3 >= 1)
  {
    v8 = (unint64_t)v6[1];
    v9 = **v6;
    v10 = v9 >= v8;
    v11 = v9 - v8;
    if (!v10)
      v11 = 0;
    if (v11 >= a3 || (a3 = v11, (_DWORD)v11))
    {
      memcpy(a2, (const void *)((*v6)[1] + v8), (int)a3);
      v6[1] = (unint64_t *)((char *)v6[1] + (int)a3);
      return a3;
    }
    else if (*(_DWORD *)(a1 + 48))
    {
      BIO_set_flags((BIO *)a1, 9);
      return *(unsigned int *)(a1 + 48);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t mem_puts(uint64_t a1, char *__s)
{
  size_t v4;

  v4 = strlen(__s);
  return mem_write(a1, __s, v4);
}

unint64_t mem_gets(BIO *a1, _BYTE *a2, int a3)
{
  bio_st *next_bio;
  uint64_t (__cdecl *callback)(bio_st *, int, const char *, int, uint64_t, uint64_t);
  unint64_t v8;
  BOOL v9;
  unsigned int v10;
  unint64_t v11;
  uint64_t v12;
  const char *v13;
  unint64_t result;

  next_bio = a1->next_bio;
  BIO_clear_flags(a1, 15);
  callback = next_bio->callback;
  v8 = *(_QWORD *)&next_bio->method->type;
  v9 = v8 >= (unint64_t)callback;
  v10 = v8 - (_DWORD)callback;
  if (!v9)
    v10 = 0;
  if ((int)v10 >= a3)
    v11 = (a3 - 1);
  else
    v11 = v10;
  if ((int)v11 < 1)
  {
    result = 0;
LABEL_15:
    *a2 = 0;
    return result;
  }
  v12 = 0;
  v13 = &next_bio->method->name[(unint64_t)callback];
  while (v13[v12] != 10)
  {
    if (v11 == ++v12)
      goto LABEL_13;
  }
  v11 = (v12 + 1);
LABEL_13:
  result = mem_read((uint64_t)a1, a2, v11);
  if ((int)result >= 1)
  {
    a2 += result;
    goto LABEL_15;
  }
  return result;
}

uint64_t mem_ctrl(uint64_t a1, int a2, int a3, unint64_t *a4)
{
  uint64_t result;
  unint64_t **v8;
  void *v9;
  unint64_t *v10;
  unint64_t v11;
  BOOL v12;
  uint64_t v13;

  result = 0;
  v8 = *(unint64_t ***)(a1 + 56);
  if (a2 > 113)
  {
    if (a2 == 114)
    {
      BUF_MEM_free((BUF_MEM *)*v8);
      *(_DWORD *)(a1 + 36) = a3;
      result = 1;
      *v8 = a4;
      v8[1] = 0;
    }
    else
    {
      if (a2 == 115)
      {
        if (a4)
          *a4 = (unint64_t)*v8;
      }
      else
      {
        if (a2 != 130)
          return result;
        *(_DWORD *)(a1 + 48) = a3;
      }
      return 1;
    }
  }
  else
  {
    switch(a2)
    {
      case 1:
        v9 = (void *)(*v8)[1];
        if (v9)
        {
          if ((*(_BYTE *)(a1 + 41) & 2) == 0)
          {
            bzero(v9, (*v8)[2]);
            **v8 = 0;
          }
          v8[1] = 0;
        }
        return 1;
      case 2:
        return **v8 <= (unint64_t)v8[1];
      case 3:
        if (!a4)
          goto LABEL_14;
        v10 = v8[1];
        *a4 = (unint64_t)v10 + (*v8)[1];
        goto LABEL_15;
      case 8:
        return *(int *)(a1 + 36);
      case 9:
        *(_DWORD *)(a1 + 36) = a3;
        return 1;
      case 10:
LABEL_14:
        v10 = v8[1];
LABEL_15:
        v11 = **v8;
        v12 = v11 >= (unint64_t)v10;
        v13 = v11 - (_QWORD)v10;
        if (v12)
          result = v13;
        else
          result = 0;
        break;
      case 11:
      case 12:
        return 1;
      default:
        return result;
    }
  }
  return result;
}

uint64_t mem_new(uint64_t a1)
{
  uint64_t result;
  _QWORD *v3;
  BUF_MEM *v4;

  result = (uint64_t)malloc_type_calloc(1uLL, 0x10uLL, 0x1020040EDED9539uLL);
  if (result)
  {
    v3 = (_QWORD *)result;
    v4 = BUF_MEM_new();
    *v3 = v4;
    if (v4)
    {
      *(_QWORD *)(a1 + 32) = 0x100000001;
      *(_DWORD *)(a1 + 48) = -1;
      *(_QWORD *)(a1 + 56) = v3;
      return 1;
    }
    else
    {
      free(v3);
      return 0;
    }
  }
  return result;
}

uint64_t mem_free(uint64_t result)
{
  uint64_t v1;
  BUF_MEM **v2;
  BUF_MEM *v3;

  if (result)
  {
    v1 = result;
    if (*(_DWORD *)(result + 32))
    {
      v2 = *(BUF_MEM ***)(result + 56);
      if (v2)
      {
        if (*(_DWORD *)(result + 36))
        {
          v3 = *v2;
          if ((*(_BYTE *)(v1 + 41) & 2) != 0)
            v3->data = 0;
          BUF_MEM_free(v3);
        }
        free(v2);
        *(_QWORD *)(v1 + 56) = 0;
      }
    }
    return 1;
  }
  return result;
}

void ERR_load_EVP_strings(void)
{
  if (!ERR_func_error_string(EVP_str_functs))
  {
    ERR_load_strings(0, (ERR_STRING_DATA *)&EVP_str_functs);
    ERR_load_strings(0, (ERR_STRING_DATA *)&EVP_str_reasons);
  }
}

void *EVP_md5_sha1()
{
  return &md5_sha1_md;
}

uint64_t md5_sha1_init(uint64_t a1)
{
  uint64_t v1;
  uint64_t result;

  v1 = *(_QWORD *)(a1 + 24);
  result = MD5_Init((_MD5_CTX *)v1);
  if ((_DWORD)result)
    return SHA1_Init((SHA_CTX *)(v1 + 92)) != 0;
  return result;
}

uint64_t md5_sha1_update(uint64_t a1, const void *a2, size_t a3)
{
  uint64_t v5;
  uint64_t result;

  v5 = *(_QWORD *)(a1 + 24);
  result = MD5_Update((_MD5_CTX *)v5, a2, a3);
  if ((_DWORD)result)
    return SHA1_Update((SHA_CTX *)(v5 + 92), a2, a3) != 0;
  return result;
}

uint64_t md5_sha1_final(uint64_t a1, unsigned __int8 *md)
{
  uint64_t v3;
  uint64_t result;

  v3 = *(_QWORD *)(a1 + 24);
  result = MD5_Final(md, (_MD5_CTX *)v3);
  if ((_DWORD)result)
    return SHA1_Final(md + 16, (SHA_CTX *)(v3 + 92)) != 0;
  return result;
}

PKCS8_PRIV_KEY_INFO *__cdecl PKCS8_decrypt(X509_SIG *p8, const char *pass, int passlen)
{
  return (PKCS8_PRIV_KEY_INFO *)PKCS12_item_decrypt_d2i(p8->algor, &PKCS8_PRIV_KEY_INFO_it, pass, passlen, p8->digest, 1);
}

uint64_t CMS_RecipientInfo_kari_get0_alg(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  if (*(_DWORD *)a1 == 1)
  {
    if (a2)
      *a2 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 24);
    if (a3)
      *a3 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 16);
    return 1;
  }
  else
  {
    ERR_put_error(46, 4095, 181, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/cms/cms_kari.c", 74);
    return 0;
  }
}

uint64_t CMS_RecipientInfo_kari_get0_reks(uint64_t a1)
{
  if (*(_DWORD *)a1 == 1)
    return *(_QWORD *)(*(_QWORD *)(a1 + 8) + 32);
  ERR_put_error(46, 4095, 181, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/cms/cms_kari.c", 91);
  return 0;
}

uint64_t CMS_RecipientInfo_kari_get0_orig_id(uint64_t a1, _QWORD *a2, _QWORD *a3, _QWORD *a4, _QWORD *a5, _QWORD *a6)
{
  int *v6;
  int v7;

  if (*(_DWORD *)a1 != 1)
  {
    ERR_put_error(46, 4095, 181, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/cms/cms_kari.c", 105);
    return 0;
  }
  v6 = *(int **)(*(_QWORD *)(a1 + 8) + 8);
  if (a5)
    *a5 = 0;
  if (a6)
    *a6 = 0;
  if (a4)
    *a4 = 0;
  if (a2)
    *a2 = 0;
  if (a3)
    *a3 = 0;
  v7 = *v6;
  if (*v6 == 2)
  {
    if (a2)
      *a2 = **((_QWORD **)v6 + 1);
    if (a3)
      *a3 = *(_QWORD *)(*((_QWORD *)v6 + 1) + 8);
    return 1;
  }
  if (v7 == 1)
  {
    if (a4)
      *a4 = *((_QWORD *)v6 + 1);
    return 1;
  }
  if (v7)
    return 0;
  if (a5)
    *a5 = **((_QWORD **)v6 + 1);
  if (a6)
    *a6 = *(_QWORD *)(*((_QWORD *)v6 + 1) + 8);
  return 1;
}

uint64_t CMS_RecipientInfo_kari_orig_id_cmp(uint64_t a1, X509 *a2)
{
  uint64_t v2;

  if (*(_DWORD *)a1 == 1)
  {
    v2 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8);
    if (*(_DWORD *)v2 == 1)
    {
      return cms_keyid_cert_cmp(*(ASN1_OCTET_STRING **)(v2 + 8), a2);
    }
    else if (*(_DWORD *)v2)
    {
      return 0xFFFFFFFFLL;
    }
    else
    {
      return cms_ias_cert_cmp(*(_QWORD *)(v2 + 8), a2);
    }
  }
  else
  {
    ERR_put_error(46, 4095, 181, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/cms/cms_kari.c", 144);
    return 4294967294;
  }
}

uint64_t CMS_RecipientEncryptedKey_get0_id(int **a1, _QWORD *a2, _QWORD *a3, _QWORD *a4, _QWORD *a5, _QWORD *a6)
{
  int *v6;
  int v7;

  v6 = *a1;
  v7 = **a1;
  if (v7 == 1)
  {
    if (a2)
      *a2 = **((_QWORD **)v6 + 1);
    if (a3)
      *a3 = *(_QWORD *)(*((_QWORD *)v6 + 1) + 8);
    if (a4)
      *a4 = *(_QWORD *)(*((_QWORD *)v6 + 1) + 16);
    if (a5)
      *a5 = 0;
    a4 = a6;
    if (!a6)
      return 1;
LABEL_22:
    *a4 = 0;
    return 1;
  }
  if (!v7)
  {
    if (a5)
      *a5 = **((_QWORD **)v6 + 1);
    if (a6)
      *a6 = *(_QWORD *)(*((_QWORD *)v6 + 1) + 8);
    if (a2)
      *a2 = 0;
    if (a3)
      *a3 = 0;
    if (!a4)
      return 1;
    goto LABEL_22;
  }
  return 0;
}

uint64_t CMS_RecipientEncryptedKey_cert_cmp(ASN1_OCTET_STRING ****a1, X509 *a2)
{
  ASN1_OCTET_STRING ***v2;
  int v3;

  v2 = *a1;
  v3 = *(_DWORD *)*a1;
  if (v3 == 1)
    return cms_keyid_cert_cmp(*v2[1], a2);
  if (v3)
    return 0xFFFFFFFFLL;
  return cms_ias_cert_cmp((uint64_t)v2[1], a2);
}

uint64_t CMS_RecipientInfo_kari_set0_pkey(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t *v4;
  EVP_PKEY **v5;

  v3 = *(_QWORD *)(a1 + 8);
  EVP_PKEY_CTX_free(*(EVP_PKEY ***)(v3 + 40));
  *(_QWORD *)(v3 + 40) = 0;
  if (!a2)
    return 1;
  v4 = (uint64_t *)EVP_PKEY_CTX_new(a2, 0);
  v5 = (EVP_PKEY **)v4;
  if (v4 && EVP_PKEY_derive_init(v4))
  {
    *(_QWORD *)(v3 + 40) = v5;
    return 1;
  }
  EVP_PKEY_CTX_free(v5);
  return 0;
}

uint64_t CMS_RecipientInfo_kari_get0_ctx(uint64_t a1)
{
  if (*(_DWORD *)a1 == 1)
    return *(_QWORD *)(*(_QWORD *)(a1 + 8) + 48);
  else
    return 0;
}

uint64_t CMS_RecipientInfo_kari_decrypt(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  int v6;
  const unsigned __int8 *v7;
  uint64_t v8;
  void *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v13;
  void *v14;

  v14 = 0;
  v5 = *(_QWORD *)(a3 + 8);
  v6 = *(_DWORD *)v5;
  v7 = *(const unsigned __int8 **)(v5 + 8);
  if (cms_env_asn1_ctrl(a2))
  {
    v13 = 0;
    if (cms_kek_cipher((unsigned __int8 **)&v14, &v13, v7, v6, *(_QWORD *)(a2 + 8), 0))
    {
      v8 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 24);
      freezero(*(void **)(v8 + 32), *(_QWORD *)(v8 + 40));
      v9 = 0;
      v10 = v13;
      *(_QWORD *)(v8 + 32) = v14;
      *(_QWORD *)(v8 + 40) = v10;
      v11 = 1;
    }
    else
    {
      v11 = 0;
      v9 = v14;
    }
  }
  else
  {
    v9 = 0;
    v11 = 0;
  }
  free(v9);
  return v11;
}

uint64_t cms_kek_cipher(unsigned __int8 **a1, _QWORD *a2, const unsigned __int8 *a3, int a4, uint64_t a5, int a6)
{
  int v12;
  uint64_t v13;
  unsigned __int8 *v14;
  int outl;
  size_t v17;
  unsigned __int8 key[64];
  uint64_t v19;

  v19 = *MEMORY[0x24BDAC8D0];
  v12 = EVP_CIPHER_CTX_key_length(*(const EVP_CIPHER_CTX **)(a5 + 48));
  v17 = v12;
  if (v12 <= 0x40)
  {
    outl = 0;
    if ((int)EVP_PKEY_derive(*(uint64_t **)(a5 + 40), (uint64_t)key, &v17) >= 1
      && EVP_CipherInit_ex(*(EVP_CIPHER_CTX **)(a5 + 48), 0, 0, key, 0, a6)
      && EVP_CipherUpdate(*(EVP_CIPHER_CTX **)(a5 + 48), 0, &outl, a3, a4))
    {
      v14 = (unsigned __int8 *)malloc_type_malloc(outl, 0xDD7F3802uLL);
      if (v14 && EVP_CipherUpdate(*(EVP_CIPHER_CTX **)(a5 + 48), v14, &outl, a3, a4))
      {
        *a1 = v14;
        *a2 = outl;
        explicit_bzero(key, v17);
        v13 = 1;
LABEL_11:
        EVP_CIPHER_CTX_reset(*(EVP_CIPHER_CTX **)(a5 + 48));
        EVP_PKEY_CTX_free(*(EVP_PKEY ***)(a5 + 40));
        *(_QWORD *)(a5 + 40) = 0;
        return v13;
      }
    }
    else
    {
      v14 = 0;
    }
    explicit_bzero(key, v17);
    free(v14);
    v13 = 0;
    goto LABEL_11;
  }
  return 0;
}

uint64_t cms_RecipientInfo_kari_init(uint64_t a1, X509 *a2, uint64_t a3, int a4)
{
  uint64_t result;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t *v12;
  EVP_PKEY **v13;
  uint64_t *v14;
  EVP_PKEY *pkey;

  result = (uint64_t)ASN1_item_new(&CMS_KeyAgreeRecipientInfo_it);
  *(_QWORD *)(a1 + 8) = result;
  if (result)
  {
    v9 = result;
    *(_DWORD *)a1 = 1;
    *(_QWORD *)result = 3;
    result = (uint64_t)ASN1_item_new(&CMS_RecipientEncryptedKey_it);
    if (result)
    {
      v10 = result;
      if (!sk_push(*(STACK **)(v9 + 32), (char *)result))
      {
        ASN1_item_free((ASN1_VALUE *)v10, &CMS_RecipientEncryptedKey_it);
        return 0;
      }
      v11 = *(_QWORD *)v10;
      if ((a4 & 0x10000) == 0)
      {
        *(_DWORD *)v11 = 0;
        result = cms_set1_ias((ASN1_VALUE **)(v11 + 8), a2);
        if (!(_DWORD)result)
          return result;
        goto LABEL_10;
      }
      *(_DWORD *)v11 = 1;
      *(_QWORD *)(*(_QWORD *)v10 + 8) = ASN1_item_new(&CMS_RecipientKeyIdentifier_it);
      result = *(_QWORD *)(*(_QWORD *)v10 + 8);
      if (result)
      {
        result = cms_set1_keyid((ASN1_OCTET_STRING **)result, a2);
        if ((_DWORD)result)
        {
LABEL_10:
          pkey = 0;
          v12 = (uint64_t *)EVP_PKEY_CTX_new(a3, 0);
          v13 = (EVP_PKEY **)v12;
          if (v12)
          {
            if ((int)EVP_PKEY_keygen_init(v12) >= 1 && (int)EVP_PKEY_keygen(v13, &pkey) >= 1)
            {
              EVP_PKEY_CTX_free(v13);
              v14 = (uint64_t *)EVP_PKEY_CTX_new((uint64_t)pkey, 0);
              v13 = (EVP_PKEY **)v14;
              if (v14)
              {
                if ((int)EVP_PKEY_derive_init(v14) > 0)
                {
                  *(_QWORD *)(v9 + 40) = v13;
                  EVP_PKEY_free(pkey);
                  EVP_PKEY_up_ref(a3);
                  *(_QWORD *)(v10 + 16) = a3;
                  return 1;
                }
              }
            }
          }
          EVP_PKEY_CTX_free(v13);
          EVP_PKEY_free(pkey);
          return 0;
        }
      }
    }
  }
  return result;
}

uint64_t cms_RecipientInfo_kari_encrypt(uint64_t a1, uint64_t a2)
{
  _QWORD *v3;
  const STACK *v4;
  uint64_t v5;
  EVP_CIPHER_CTX *v6;
  int v7;
  uint64_t result;
  const EVP_CIPHER *v9;
  uint64_t v10;
  int v11;
  char *v12;
  int len[2];
  void *data;

  if (*(_DWORD *)a2 != 1)
  {
    ERR_put_error(46, 4095, 181, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/cms/cms_kari.c", 446);
    return 0;
  }
  v3 = *(_QWORD **)(a2 + 8);
  v4 = (const STACK *)v3[4];
  v5 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 24);
  v6 = (EVP_CIPHER_CTX *)v3[6];
  v7 = EVP_CIPHER_key_length(*(const EVP_CIPHER **)(v5 + 24));
  if (EVP_CIPHER_CTX_cipher(v6))
  {
    result = (EVP_CIPHER_CTX_flags(v6) & 0xF0007) == 65538;
    if (!(_DWORD)result)
      return result;
  }
  else
  {
    if (v7 > 16)
    {
      if (v7 > 0x18)
        v9 = (const EVP_CIPHER *)EVP_aes_256_wrap();
      else
        v9 = (const EVP_CIPHER *)EVP_aes_192_wrap();
    }
    else
    {
      v9 = (const EVP_CIPHER *)EVP_aes_128_wrap();
    }
    result = EVP_EncryptInit_ex(v6, v9, 0, 0, 0);
    if (!(_DWORD)result)
      return result;
  }
  v10 = v3[1];
  if (*(_DWORD *)v10 != -1
    || (*(_DWORD *)v10 = 2,
        result = (uint64_t)ASN1_item_new(&CMS_OriginatorPublicKey_it),
        (*(_QWORD *)(v10 + 8) = result) != 0))
  {
    result = cms_env_asn1_ctrl(a2);
    if ((_DWORD)result)
    {
      if (sk_num(v4) < 1)
        return 1;
      v11 = 0;
      while (1)
      {
        *(_QWORD *)len = 0;
        data = 0;
        v12 = sk_value(v4, v11);
        if ((int)EVP_PKEY_derive_set_peer(v3[5], *((const EVP_PKEY **)v12 + 2)) < 1
          || !cms_kek_cipher((unsigned __int8 **)&data, len, *(const unsigned __int8 **)(v5 + 32), *(_QWORD *)(v5 + 40), (uint64_t)v3, 1))
        {
          break;
        }
        ASN1_STRING_set0(*((ASN1_STRING **)v12 + 1), data, len[0]);
        if (++v11 >= sk_num(v4))
          return 1;
      }
      return 0;
    }
  }
  return result;
}

unint64_t *bn_sqr_comba4(unint64_t *result, _QWORD *a2)
{
  uint64_t v2;
  unsigned int v3;
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  uint64_t v14;
  unsigned int v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t v20;
  unint64_t v21;
  unint64_t v22;
  unint64_t v23;
  unint64_t v24;
  unint64_t v25;
  unint64_t v26;
  unint64_t v27;
  unint64_t v28;
  unint64_t v29;
  unint64_t v30;
  unint64_t v31;
  unint64_t v32;
  unint64_t v33;
  unint64_t v34;
  unint64_t v35;
  unint64_t v36;
  unint64_t v37;
  unint64_t v38;
  unint64_t v39;
  unint64_t v40;
  unint64_t v41;
  unint64_t v42;
  unint64_t v43;
  unint64_t v44;
  unint64_t v45;
  unint64_t v46;
  unint64_t v47;
  unint64_t v48;
  unint64_t v49;
  unint64_t v50;
  unint64_t v51;
  unint64_t v52;
  unint64_t v53;
  unint64_t v54;
  unint64_t v55;
  unint64_t v56;
  uint64_t v57;
  unint64_t v58;
  unint64_t v59;
  unint64_t v60;
  unint64_t v61;
  unint64_t v62;
  unint64_t v63;
  unint64_t v64;
  unint64_t v65;
  unint64_t v66;
  unint64_t v67;
  unint64_t v68;
  unint64_t v69;
  unint64_t v70;
  unint64_t v71;
  unint64_t v72;
  unint64_t v73;
  unint64_t v74;
  unint64_t v75;
  unint64_t v76;
  unint64_t v77;
  unint64_t v78;
  unint64_t v79;
  unint64_t v80;
  unint64_t v81;
  unint64_t v82;
  unint64_t v83;
  unint64_t v84;
  unint64_t v85;
  unint64_t v86;
  unint64_t v87;
  unint64_t v88;
  unint64_t v89;
  uint64_t v90;
  unsigned int v91;
  unint64_t v92;
  unint64_t v93;
  unint64_t v94;
  unint64_t v95;
  unint64_t v96;
  unint64_t v97;
  unint64_t v98;
  unint64_t v99;
  unint64_t v100;
  unint64_t v101;
  unint64_t v102;
  unint64_t v103;
  unint64_t v104;
  unint64_t v105;
  unint64_t v106;
  unint64_t v107;
  unint64_t v108;
  unint64_t v109;
  unint64_t v110;
  unint64_t v111;
  unint64_t v112;
  unint64_t v113;
  unint64_t v114;
  unint64_t v115;
  unint64_t v116;
  unint64_t v117;
  unint64_t v118;
  unint64_t v119;
  unint64_t v120;
  unint64_t v121;
  unint64_t v122;
  unint64_t v123;
  unint64_t v124;
  unint64_t v125;
  unint64_t v126;
  unint64_t v127;
  unint64_t v128;
  unint64_t v129;
  unint64_t v130;
  unint64_t v131;
  unint64_t v132;
  unint64_t v133;
  unint64_t v134;
  unint64_t v135;
  unint64_t v136;
  unint64_t v137;
  unint64_t v138;
  unint64_t v139;
  unint64_t v140;
  unint64_t v141;
  unint64_t v142;
  unint64_t v143;
  unint64_t v144;
  unint64_t v145;
  unint64_t v146;
  unint64_t v147;
  unint64_t v148;
  unint64_t v149;
  unint64_t v150;
  unint64_t v151;
  unint64_t v152;
  unint64_t v153;
  unint64_t v154;
  unint64_t v155;
  unint64_t v156;
  unint64_t v157;
  unint64_t v158;
  unint64_t v159;
  unint64_t v160;
  unint64_t v161;
  unint64_t v162;
  unint64_t v163;
  unint64_t v164;
  unint64_t v165;
  unint64_t v166;
  unint64_t v167;
  unint64_t v168;
  unint64_t v169;
  unint64_t v170;
  unint64_t v171;
  unint64_t v172;
  unint64_t v173;
  unint64_t v174;
  unint64_t v175;
  unint64_t v176;
  unint64_t v177;
  unint64_t v178;
  unint64_t v179;
  unint64_t v180;
  unint64_t v181;
  uint64_t v182;
  unint64_t v183;
  unint64_t v184;
  unint64_t v185;
  unint64_t v186;
  unint64_t v187;
  unint64_t v188;
  unint64_t v189;
  unint64_t v190;
  unint64_t v191;
  unint64_t v192;
  unint64_t v193;
  unint64_t v194;
  unint64_t v195;
  unint64_t v196;
  unint64_t v197;
  unint64_t v198;
  unint64_t v199;
  unint64_t v200;
  unint64_t v201;
  unint64_t v202;
  unint64_t v203;
  unint64_t v204;
  unint64_t v205;
  unint64_t v206;
  unint64_t v207;
  unint64_t v208;
  unint64_t v209;
  unint64_t v210;
  unint64_t v211;
  unint64_t v212;
  unint64_t v213;
  unint64_t v214;
  unint64_t v215;
  unint64_t v216;
  unint64_t v217;
  unint64_t v218;
  unint64_t v219;
  unint64_t v220;
  unint64_t v221;
  unint64_t v222;
  unint64_t v223;
  unint64_t v224;
  unint64_t v225;
  unint64_t v226;
  unint64_t v227;
  unint64_t v228;
  unint64_t v229;
  unint64_t v230;
  unint64_t v231;
  unint64_t v232;
  unint64_t v233;
  unint64_t v234;
  unint64_t v235;
  unint64_t v236;
  unint64_t v237;

  v2 = HIDWORD(*a2);
  v3 = *a2;
  v4 = v3 * (unint64_t)v3;
  v5 = v3 * (unint64_t)v2;
  v6 = (v5 << 32) + v4;
  v7 = (v4 | (v5 << 32)) & ~v6 | v4 & (v5 << 32);
  v8 = v6 | (v5 << 32);
  v9 = v6 & (v5 << 32);
  v10 = v6 + (v5 << 32);
  v11 = ((v5 >> 31) & 0x1FFFFFFFELL)
      + v2 * (unint64_t)v2
      + (v7 >> 63)
      + ((v8 & ~v10 | v9) >> 63);
  *result = v10;
  v12 = a2[1];
  v13 = HIDWORD(v12);
  LODWORD(v8) = v12;
  v14 = HIDWORD(*a2);
  v15 = *a2;
  v16 = v15 * (unint64_t)v12;
  v17 = v15 * (unint64_t)v13;
  v18 = HIDWORD(v17) + v14 * (unint64_t)v13;
  v19 = v16 | (v17 << 32);
  v20 = v16 & (v17 << 32);
  v21 = (v17 << 32) + v15 * (unint64_t)v8;
  v22 = v19 & ~v21 | v20;
  v23 = v14 * (unint64_t)v8;
  v24 = v21 | (v23 << 32);
  v25 = v21 & (v23 << 32);
  v26 = v21 + (v23 << 32);
  v27 = v18 + HIDWORD(v23) + (v22 >> 63) + ((v24 & ~v26 | v25) >> 63);
  v28 = v11 | v26;
  v29 = v11 & v26;
  v30 = v11 + v26;
  v31 = v27 + ((v28 & ~v30 | v29) >> 63);
  v32 = v30 | v26;
  v33 = v30 & v26;
  v34 = v30 + v26;
  v35 = v27 + ((v32 & ~v34 | v33) >> 63);
  v36 = v35 | v31;
  v37 = v35 & v31;
  v38 = v35 + v31;
  v39 = v36 & ~v38 | v37;
  result[1] = v34;
  v40 = a2[1];
  v41 = HIDWORD(v40);
  v42 = v40 * (unint64_t)HIDWORD(v40);
  v43 = (v42 << 32) + v40 * (unint64_t)v40;
  v44 = ((v40 * (unint64_t)v40) | (v42 << 32)) & ~v43 | (v40
                                                                                          * (unint64_t)v40) & (v42 << 32);
  v45 = v43 | (v42 << 32);
  v46 = v43 & (v42 << 32);
  v47 = v43 + (v42 << 32);
  v48 = ((v42 >> 31) & 0x1FFFFFFFELL)
      + v41 * (unint64_t)v41
      + (v44 >> 63)
      + ((v45 & ~v47 | v46) >> 63);
  v49 = v38 | v47;
  v50 = v38 & v47;
  v51 = v38 + v47;
  v52 = v48 + ((v49 & ~v51 | v50) >> 63);
  v53 = v52 + (v39 >> 63);
  v54 = v52 & ~v53;
  v55 = a2[2];
  v56 = HIDWORD(v55);
  LODWORD(v50) = v55;
  v57 = HIDWORD(*a2);
  LODWORD(v46) = *a2;
  v58 = v46 * (unint64_t)v55;
  v59 = v46 * (unint64_t)HIDWORD(v55);
  v60 = HIDWORD(v59) + v57 * (unint64_t)v56;
  v61 = v58 | (v59 << 32);
  v62 = v58 & (v59 << 32);
  v63 = (v59 << 32) + v46 * (unint64_t)v50;
  v64 = v61 & ~v63 | v62;
  v65 = v57 * (unint64_t)v50;
  v66 = v63 | (v65 << 32);
  v67 = v63 & (v65 << 32);
  v68 = v63 + (v65 << 32);
  v69 = v60 + HIDWORD(v65) + (v64 >> 63) + ((v66 & ~v68 | v67) >> 63);
  v70 = v51 | v68;
  v71 = v51 & v68;
  v72 = v51 + v68;
  v73 = v69 + ((v70 & ~v72 | v71) >> 63);
  v74 = v73 | v53;
  v75 = v73 & v53;
  v76 = v73 + v53;
  v77 = ((v74 & ~v76 | v75) >> 63) + (v54 >> 63);
  v78 = v72 | v68;
  v79 = v72 & v68;
  v80 = v72 + v68;
  v81 = v69 + ((v78 & ~v80 | v79) >> 63);
  v82 = v81 | v76;
  v83 = v81 & v76;
  v84 = v81 + v76;
  v85 = v77 + ((v82 & ~v84 | v83) >> 63);
  result[2] = v80;
  v87 = a2[2];
  v86 = a2[3];
  v88 = HIDWORD(v86);
  LODWORD(v77) = v86;
  v89 = a2[1];
  v90 = HIDWORD(*a2);
  v91 = *a2;
  v92 = v91 * (unint64_t)v86;
  v93 = v91 * (unint64_t)v88;
  v94 = HIDWORD(v93) + v90 * (unint64_t)v88;
  v95 = v92 | (v93 << 32);
  v96 = v92 & (v93 << 32);
  v97 = (v93 << 32) + v91 * (unint64_t)v77;
  v98 = v95 & ~v97 | v96;
  v99 = v90 * (unint64_t)v77;
  v100 = v97 | (v99 << 32);
  v101 = v97 & (v99 << 32);
  v102 = v97 + (v99 << 32);
  v103 = v94 + HIDWORD(v99) + (v98 >> 63) + ((v100 & ~v102 | v101) >> 63);
  v104 = v84 | v102;
  v105 = v84 & v102;
  v106 = v84 + v102;
  v107 = v103 + ((v104 & ~v106 | v105) >> 63);
  v108 = v85 + v107;
  v109 = v107 & ~v108;
  v110 = v106 | v102;
  v111 = v106 & v102;
  v112 = v106 + v102;
  v113 = v103 + ((v110 & ~v112 | v111) >> 63);
  v114 = v113 | v108;
  v115 = v113 & v108;
  v116 = v113 + v108;
  v117 = ((v114 & ~v116 | v115) >> 63) + (v109 >> 63);
  v118 = HIDWORD(v87);
  LODWORD(v114) = v87;
  v119 = HIDWORD(v89);
  LODWORD(v111) = v89;
  v120 = v89 * (unint64_t)v87;
  v121 = v89 * (unint64_t)v118;
  v122 = HIDWORD(v121) + v119 * (unint64_t)v118;
  v123 = v120 | (v121 << 32);
  v124 = v120 & (v121 << 32);
  v125 = (v121 << 32) + v111 * (unint64_t)v114;
  v126 = v123 & ~v125 | v124;
  v127 = v119 * (unint64_t)v114;
  v128 = v125 | (v127 << 32);
  v129 = v125 & (v127 << 32);
  v130 = v125 + (v127 << 32);
  v131 = v122 + HIDWORD(v127) + (v126 >> 63) + ((v128 & ~v130 | v129) >> 63);
  v132 = v112 | v130;
  v133 = v112 & v130;
  v134 = v112 + v130;
  v135 = v131 + ((v132 & ~v134 | v133) >> 63);
  v136 = v135 | v116;
  v137 = v135 & v116;
  v138 = v135 + v116;
  v139 = v117 + ((v136 & ~v138 | v137) >> 63);
  v140 = v134 | v130;
  v141 = v134 & v130;
  v142 = v134 + v130;
  v143 = v131 + ((v140 & ~v142 | v141) >> 63);
  v144 = v143 | v138;
  v145 = v143 & v138;
  v146 = v143 + v138;
  v147 = v139 + ((v144 & ~v146 | v145) >> 63);
  result[3] = v142;
  v149 = a2[1];
  v148 = a2[2];
  v150 = HIDWORD(v148);
  v151 = v148 * (unint64_t)HIDWORD(v148);
  v152 = (v151 << 32) + v148 * (unint64_t)v148;
  v153 = ((v148 * (unint64_t)v148) | (v151 << 32)) & ~v152 | (v148
                                                                                               * (unint64_t)v148) & (v151 << 32);
  v154 = v152 | (v151 << 32);
  v155 = v152 & (v151 << 32);
  v156 = v152 + (v151 << 32);
  v157 = ((v151 >> 31) & 0x1FFFFFFFELL)
       + v150 * (unint64_t)v150
       + (v153 >> 63)
       + ((v154 & ~v156 | v155) >> 63);
  v158 = v146 | v156;
  v159 = v146 & v156;
  v160 = v146 + v156;
  v161 = v157 + ((v158 & ~v160 | v159) >> 63);
  v162 = v161 | v147;
  v163 = v161 + v147;
  v164 = v162 & ~v163;
  v165 = a2[3];
  v166 = HIDWORD(v165);
  LODWORD(v159) = v165;
  v167 = HIDWORD(v149);
  LODWORD(v155) = v149;
  v168 = v149 * (unint64_t)v165;
  v169 = v155 * (unint64_t)HIDWORD(v165);
  v170 = HIDWORD(v169) + v167 * (unint64_t)v166;
  v171 = v168 | (v169 << 32);
  v172 = v168 & (v169 << 32);
  v173 = (v169 << 32) + v155 * (unint64_t)v159;
  v174 = v171 & ~v173 | v172;
  v175 = v167 * (unint64_t)v159;
  v176 = v173 | (v175 << 32);
  v177 = v173 & (v175 << 32);
  v178 = v173 + (v175 << 32);
  v179 = v170 + HIDWORD(v175) + (v174 >> 63) + ((v176 & ~v178 | v177) >> 63);
  v180 = v160 | v178;
  v181 = v160 & v178;
  v182 = v160 + v178;
  v183 = v179 + ((v180 & ~v182 | v181) >> 63);
  v184 = v183 | v163;
  v185 = v183 & v163;
  v186 = v183 + v163;
  v187 = ((v184 & ~v186 | v185) >> 63) + (v164 >> 63);
  v188 = v182 | v178;
  v189 = v182 & v178;
  v190 = v182 + v178;
  v191 = v179 + ((v188 & ~v190 | v189) >> 63);
  v192 = v191 | v186;
  v193 = v191 & v186;
  v194 = v191 + v186;
  v195 = v187 + ((v192 & ~v194 | v193) >> 63);
  result[4] = v190;
  v197 = a2[2];
  v196 = a2[3];
  v198 = HIDWORD(v196);
  LODWORD(v193) = v196;
  v199 = HIDWORD(v197);
  LODWORD(v185) = v197;
  v200 = v197 * (unint64_t)v196;
  v201 = v197 * (unint64_t)v198;
  v202 = HIDWORD(v201) + v199 * (unint64_t)v198;
  v203 = v200 | (v201 << 32);
  v204 = v200 & (v201 << 32);
  v205 = (v201 << 32) + v185 * (unint64_t)v193;
  v206 = v203 & ~v205 | v204;
  v207 = v199 * (unint64_t)v193;
  v208 = v205 | (v207 << 32);
  v209 = v205 & (v207 << 32);
  v210 = v205 + (v207 << 32);
  v211 = v202 + HIDWORD(v207) + (v206 >> 63) + ((v208 & ~v210 | v209) >> 63);
  v212 = v194 | v210;
  v213 = v194 & v210;
  v214 = v194 + v210;
  v215 = v211 + ((v212 & ~v214 | v213) >> 63);
  v216 = v195 + v215;
  v217 = v215 & ~v216;
  v218 = v214 | v210;
  v219 = v214 & v210;
  v220 = v214 + v210;
  v221 = v211 + ((v218 & ~v220 | v219) >> 63);
  v222 = v221 | v216;
  v223 = v221 & v216;
  v224 = v221 + v216;
  v225 = v222 & ~v224 | v223;
  result[5] = v220;
  v226 = a2[3];
  v227 = HIDWORD(v226);
  v228 = v226 * (unint64_t)HIDWORD(v226);
  v229 = (v228 << 32) + v226 * (unint64_t)v226;
  v230 = ((v226 * (unint64_t)v226) | (v228 << 32)) & ~v229 | (v226
                                                                                               * (unint64_t)v226) & (v228 << 32);
  v231 = v229 | (v228 << 32);
  v232 = v229 & (v228 << 32);
  v233 = v229 + (v228 << 32);
  v234 = ((v228 >> 31) & 0x1FFFFFFFELL)
       + v227 * (unint64_t)v227
       + (v230 >> 63)
       + ((v231 & ~v233 | v232) >> 63);
  v235 = v224 | v233;
  v236 = v224 & v233;
  v237 = v224 + v233;
  result[6] = v237;
  result[7] = v234 + (v217 >> 63) + (v225 >> 63) + ((v235 & ~v237 | v236) >> 63);
  return result;
}

unint64_t *bn_sqr_comba8(unint64_t *result, _QWORD *a2)
{
  uint64_t v2;
  unsigned int v3;
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  uint64_t v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t v20;
  unint64_t v21;
  unint64_t v22;
  unint64_t v23;
  uint64_t v24;
  unint64_t v25;
  unint64_t v26;
  unint64_t v27;
  unint64_t v28;
  unint64_t v29;
  unint64_t v30;
  unint64_t v31;
  unint64_t v32;
  unint64_t v33;
  unint64_t v34;
  uint64_t v35;
  unint64_t v36;
  unint64_t v37;
  unint64_t v38;
  unint64_t v39;
  unint64_t v40;
  unint64_t v41;
  unint64_t v42;
  unint64_t v43;
  unint64_t v44;
  unint64_t v45;
  unint64_t v46;
  unint64_t v47;
  unint64_t v48;
  unint64_t v49;
  unint64_t v50;
  unint64_t v51;
  unint64_t v52;
  unint64_t v53;
  unint64_t v54;
  unint64_t v55;
  unint64_t v56;
  unint64_t v57;
  unint64_t v58;
  unint64_t v59;
  unint64_t v60;
  unint64_t v61;
  unint64_t v62;
  unint64_t v63;
  uint64_t v64;
  unint64_t v65;
  unint64_t v66;
  unint64_t v67;
  unint64_t v68;
  unint64_t v69;
  unint64_t v70;
  unint64_t v71;
  unint64_t v72;
  unint64_t v73;
  unint64_t v74;
  unint64_t v75;
  unint64_t v76;
  unint64_t v77;
  unint64_t v78;
  unint64_t v79;
  unint64_t v80;
  unint64_t v81;
  unint64_t v82;
  unint64_t v83;
  unint64_t v84;
  unint64_t v85;
  unint64_t v86;
  unint64_t v87;
  unint64_t v88;
  unint64_t v89;
  unint64_t v90;
  unint64_t v91;
  unint64_t v92;
  unint64_t v93;
  unint64_t v94;
  unint64_t v95;
  unint64_t v96;
  unint64_t v97;
  unint64_t v98;
  unint64_t v99;
  unint64_t v100;
  unint64_t v101;
  unint64_t v102;
  unint64_t v103;
  unint64_t v104;
  unint64_t v105;
  unint64_t v106;
  unint64_t v107;
  unint64_t v108;
  uint64_t v109;
  unint64_t v110;
  unint64_t v111;
  unint64_t v112;
  unint64_t v113;
  unint64_t v114;
  unint64_t v115;
  unint64_t v116;
  unint64_t v117;
  unint64_t v118;
  unint64_t v119;
  unint64_t v120;
  unint64_t v121;
  unint64_t v122;
  unint64_t v123;
  unint64_t v124;
  unint64_t v125;
  unint64_t v126;
  unint64_t v127;
  unint64_t v128;
  unint64_t v129;
  unint64_t v130;
  unint64_t v131;
  unint64_t v132;
  unint64_t v133;
  unint64_t v134;
  unint64_t v135;
  unint64_t v136;
  unint64_t v137;
  unint64_t v138;
  unint64_t v139;
  unint64_t v140;
  unint64_t v141;
  uint64_t v142;
  unint64_t v143;
  unint64_t v144;
  unint64_t v145;
  unint64_t v146;
  unint64_t v147;
  unint64_t v148;
  unint64_t v149;
  unint64_t v150;
  unint64_t v151;
  uint64_t v152;
  unint64_t v153;
  unint64_t v154;
  unint64_t v155;
  unint64_t v156;
  unint64_t v157;
  unint64_t v158;
  unint64_t v159;
  uint64_t v160;
  unint64_t v161;
  unint64_t v162;
  unint64_t v163;
  unint64_t v164;
  unint64_t v165;
  unint64_t v166;
  unint64_t v167;
  unint64_t v168;
  unint64_t v169;
  unint64_t v170;
  unint64_t v171;
  uint64_t v172;
  unint64_t v173;
  unint64_t v174;
  unint64_t v175;
  unint64_t v176;
  unint64_t v177;
  uint64_t v178;
  unint64_t v179;
  unint64_t v180;
  unint64_t v181;
  unint64_t v182;
  unint64_t v183;
  unint64_t v184;
  unint64_t v185;
  unint64_t v186;
  unint64_t v187;
  uint64_t v188;
  unint64_t v189;
  unint64_t v190;
  unint64_t v191;
  unint64_t v192;
  unint64_t v193;
  unint64_t v194;
  uint64_t v195;
  unint64_t v196;
  unint64_t v197;
  unint64_t v198;
  unint64_t v199;
  unint64_t v200;
  unint64_t v201;
  unint64_t v202;
  unint64_t v203;
  unint64_t v204;
  unint64_t v205;
  unint64_t v206;
  unint64_t v207;
  unint64_t v208;
  unint64_t v209;
  unint64_t v210;
  unint64_t v211;
  uint64_t v212;
  unint64_t v213;
  unint64_t v214;
  unint64_t v215;
  unint64_t v216;
  unint64_t v217;
  unint64_t v218;
  unint64_t v219;
  uint64_t v220;
  unint64_t v221;
  unint64_t v222;
  unint64_t v223;
  uint64_t v224;
  unint64_t v225;
  unint64_t v226;
  unint64_t v227;
  unint64_t v228;
  unint64_t v229;
  unint64_t v230;
  unint64_t v231;
  unint64_t v232;
  unint64_t v233;
  unint64_t v234;
  unint64_t v235;
  unint64_t v236;
  unint64_t v237;
  unint64_t v238;
  unint64_t v239;
  unint64_t v240;
  unint64_t v241;
  unint64_t v242;
  unint64_t v243;
  uint64_t v244;
  unint64_t v245;
  unint64_t v246;
  unint64_t v247;
  uint64_t v248;
  unint64_t v249;
  unint64_t v250;
  unint64_t v251;
  unint64_t v252;
  unint64_t v253;
  unint64_t v254;
  unint64_t v255;
  uint64_t v256;
  unint64_t v257;
  unint64_t v258;
  unint64_t v259;
  unint64_t v260;
  unint64_t v261;
  unint64_t v262;
  unint64_t v263;
  unint64_t v264;
  unint64_t v265;
  unint64_t v266;
  unint64_t v267;
  unint64_t v268;
  unint64_t v269;
  uint64_t v270;
  unint64_t v271;
  unint64_t v272;
  unint64_t v273;
  unint64_t v274;
  unint64_t v275;
  unint64_t v276;
  unint64_t v277;
  unint64_t v278;
  unint64_t v279;
  unint64_t v280;
  unint64_t v281;
  unint64_t v282;
  unint64_t v283;
  unint64_t v284;
  unint64_t v285;
  unint64_t v286;
  unint64_t v287;
  unint64_t v288;
  unint64_t v289;
  unint64_t v290;
  unint64_t v291;
  unint64_t v292;
  uint64_t v293;
  unint64_t v294;
  unint64_t v295;
  unint64_t v296;
  unint64_t v297;
  unint64_t v298;
  unint64_t v299;
  unint64_t v300;
  uint64_t v301;
  unint64_t v302;
  unint64_t v303;
  unint64_t v304;
  uint64_t v305;
  unint64_t v306;
  unint64_t v307;
  unint64_t v308;
  unint64_t v309;
  unint64_t v310;
  unint64_t v311;
  unint64_t v312;
  unint64_t v313;
  unint64_t v314;
  unint64_t v315;
  unint64_t v316;
  unint64_t v317;
  unint64_t v318;
  unint64_t v319;
  unint64_t v320;
  unint64_t v321;
  unint64_t v322;
  unint64_t v323;
  uint64_t v324;
  unint64_t v325;
  unint64_t v326;
  unint64_t v327;
  uint64_t v328;
  unint64_t v329;
  unint64_t v330;
  unint64_t v331;
  uint64_t v332;
  unint64_t v333;
  unint64_t v334;
  unint64_t v335;
  uint64_t v336;
  unint64_t v337;
  unint64_t v338;
  unint64_t v339;
  uint64_t v340;
  unint64_t v341;
  unint64_t v342;
  unint64_t v343;
  unint64_t v344;
  unint64_t v345;
  unint64_t v346;
  unint64_t v347;
  unint64_t v348;
  unint64_t v349;
  unint64_t v350;
  unint64_t v351;
  unint64_t v352;
  unint64_t v353;
  unint64_t v354;
  uint64_t v355;
  unint64_t v356;
  unint64_t v357;
  unint64_t v358;
  uint64_t v359;
  unint64_t v360;
  unint64_t v361;
  unint64_t v362;
  unint64_t v363;
  unint64_t v364;
  uint64_t v365;
  unint64_t v366;
  unint64_t v367;
  unint64_t v368;
  unint64_t v369;
  unint64_t v370;
  uint64_t v371;
  unint64_t v372;
  unint64_t v373;
  unint64_t v374;
  unint64_t v375;
  unint64_t v376;
  unint64_t v377;
  unint64_t v378;
  unint64_t v379;
  unint64_t v380;
  unint64_t v381;
  unint64_t v382;
  unint64_t v383;
  unint64_t v384;
  unint64_t v385;
  uint64_t v386;
  unint64_t v387;
  unint64_t v388;
  unint64_t v389;
  unint64_t v390;
  unint64_t v391;
  unint64_t v392;
  unint64_t v393;
  uint64_t v394;
  unint64_t v395;
  unint64_t v396;
  unint64_t v397;
  uint64_t v398;
  unint64_t v399;
  unint64_t v400;
  unint64_t v401;
  unint64_t v402;
  unint64_t v403;
  unint64_t v404;
  unint64_t v405;
  unint64_t v406;
  unint64_t v407;
  unint64_t v408;
  unint64_t v409;
  unint64_t v410;
  unint64_t v411;
  unint64_t v412;
  unint64_t v413;
  unint64_t v414;
  unint64_t v415;
  uint64_t v416;
  unint64_t v417;
  unint64_t v418;
  unint64_t v419;
  uint64_t v420;
  unint64_t v421;
  unint64_t v422;
  unint64_t v423;
  uint64_t v424;
  unint64_t v425;
  unint64_t v426;
  unint64_t v427;
  uint64_t v428;
  unint64_t v429;
  unint64_t v430;
  unint64_t v431;
  unint64_t v432;
  unint64_t v433;
  unint64_t v434;
  unint64_t v435;
  unint64_t v436;
  unint64_t v437;
  unint64_t v438;
  unint64_t v439;
  unint64_t v440;
  unint64_t v441;
  unint64_t v442;
  unint64_t v443;
  unint64_t v444;
  unint64_t v445;
  unint64_t v446;
  unint64_t v447;
  unint64_t v448;
  unint64_t v449;
  uint64_t v450;
  unint64_t v451;
  unint64_t v452;
  unint64_t v453;
  uint64_t v454;
  unint64_t v455;
  unint64_t v456;
  unint64_t v457;
  uint64_t v458;
  unint64_t v459;
  unint64_t v460;
  unint64_t v461;
  uint64_t v462;
  unint64_t v463;
  unint64_t v464;
  unint64_t v465;
  unint64_t v466;
  unint64_t v467;
  unint64_t v468;
  unint64_t v469;
  unint64_t v470;
  unint64_t v471;
  unint64_t v472;
  unint64_t v473;
  unint64_t v474;
  unint64_t v475;
  unint64_t v476;
  unint64_t v477;
  uint64_t v478;
  unint64_t v479;
  unint64_t v480;
  unint64_t v481;
  uint64_t v482;
  unint64_t v483;
  unint64_t v484;
  unint64_t v485;
  unint64_t v486;
  unint64_t v487;
  unint64_t v488;
  unint64_t v489;
  uint64_t v490;
  unint64_t v491;
  unint64_t v492;
  unint64_t v493;
  unint64_t v494;
  unint64_t v495;
  unint64_t v496;
  unint64_t v497;
  unint64_t v498;
  unint64_t v499;
  unint64_t v500;
  unint64_t v501;
  unint64_t v502;
  unint64_t v503;
  uint64_t v504;
  unint64_t v505;
  unint64_t v506;
  unint64_t v507;
  uint64_t v508;
  unint64_t v509;
  unint64_t v510;
  unint64_t v511;
  unint64_t v512;
  unint64_t v513;
  unint64_t v514;
  unint64_t v515;
  unint64_t v516;
  unint64_t v517;
  unint64_t v518;
  unint64_t v519;
  unint64_t v520;
  unint64_t v521;
  unint64_t v522;
  unint64_t v523;
  unint64_t v524;
  unint64_t v525;
  unint64_t v526;
  unint64_t v527;
  uint64_t v528;
  unint64_t v529;
  unint64_t v530;
  unint64_t v531;
  uint64_t v532;
  unint64_t v533;
  unint64_t v534;
  unint64_t v535;
  uint64_t v536;
  unint64_t v537;
  unint64_t v538;
  unint64_t v539;
  uint64_t v540;
  unint64_t v541;
  unint64_t v542;
  unint64_t v543;
  unint64_t v544;
  unint64_t v545;
  unint64_t v546;
  unint64_t v547;
  unint64_t v548;
  unint64_t v549;
  unint64_t v550;
  unint64_t v551;
  unint64_t v552;
  unint64_t v553;
  unint64_t v554;
  unint64_t v555;
  unint64_t v556;
  unint64_t v557;
  unint64_t v558;
  unint64_t v559;
  uint64_t v560;
  unint64_t v561;
  unint64_t v562;
  unint64_t v563;
  uint64_t v564;
  unint64_t v565;
  unint64_t v566;
  unint64_t v567;
  uint64_t v568;
  unint64_t v569;
  unint64_t v570;
  unint64_t v571;
  uint64_t v572;
  unint64_t v573;
  unint64_t v574;
  unint64_t v575;
  unint64_t v576;
  unint64_t v577;
  unint64_t v578;
  unint64_t v579;
  unint64_t v580;
  unint64_t v581;
  unint64_t v582;
  unint64_t v583;
  unint64_t v584;
  unint64_t v585;
  unint64_t v586;
  unint64_t v587;
  unint64_t v588;
  unint64_t v589;
  unint64_t v590;
  uint64_t v591;
  unint64_t v592;
  unint64_t v593;
  unint64_t v594;
  uint64_t v595;
  unint64_t v596;
  unint64_t v597;
  unint64_t v598;
  unint64_t v599;
  unint64_t v600;
  uint64_t v601;
  unint64_t v602;
  unint64_t v603;
  unint64_t v604;
  unint64_t v605;
  unint64_t v606;
  unint64_t v607;
  unint64_t v608;
  unint64_t v609;
  unint64_t v610;
  unint64_t v611;
  unint64_t v612;
  unint64_t v613;
  unint64_t v614;
  unint64_t v615;
  unint64_t v616;
  unint64_t v617;
  unint64_t v618;
  unint64_t v619;
  unint64_t v620;
  unint64_t v621;
  unint64_t v622;
  uint64_t v623;
  unint64_t v624;
  unint64_t v625;
  unint64_t v626;
  unint64_t v627;
  unint64_t v628;
  unint64_t v629;
  unint64_t v630;
  uint64_t v631;
  unint64_t v632;
  unint64_t v633;
  unint64_t v634;
  uint64_t v635;
  unint64_t v636;
  unint64_t v637;
  unint64_t v638;
  unint64_t v639;
  unint64_t v640;
  unint64_t v641;
  unint64_t v642;
  unint64_t v643;
  unint64_t v644;
  unint64_t v645;
  unint64_t v646;
  unint64_t v647;
  unint64_t v648;
  unint64_t v649;
  unint64_t v650;
  unint64_t v651;
  unint64_t v652;
  uint64_t v653;
  unint64_t v654;
  unint64_t v655;
  unint64_t v656;
  uint64_t v657;
  unint64_t v658;
  unint64_t v659;
  unint64_t v660;
  uint64_t v661;
  unint64_t v662;
  unint64_t v663;
  unint64_t v664;
  uint64_t v665;
  unint64_t v666;
  unint64_t v667;
  unint64_t v668;
  unint64_t v669;
  unint64_t v670;
  unint64_t v671;
  unint64_t v672;
  unint64_t v673;
  unint64_t v674;
  unint64_t v675;
  unint64_t v676;
  unint64_t v677;
  unint64_t v678;
  unint64_t v679;
  unint64_t v680;
  unint64_t v681;
  unint64_t v682;
  unint64_t v683;
  unint64_t v684;
  uint64_t v685;
  unint64_t v686;
  unint64_t v687;
  unint64_t v688;
  uint64_t v689;
  unint64_t v690;
  unint64_t v691;
  unint64_t v692;
  unint64_t v693;
  unint64_t v694;
  unint64_t v695;
  unint64_t v696;
  uint64_t v697;
  unint64_t v698;
  unint64_t v699;
  unint64_t v700;
  unint64_t v701;
  unint64_t v702;
  unint64_t v703;
  unint64_t v704;
  unint64_t v705;
  unint64_t v706;
  unint64_t v707;
  unint64_t v708;
  unint64_t v709;
  unint64_t v710;
  uint64_t v711;
  unint64_t v712;
  unint64_t v713;
  unint64_t v714;
  unint64_t v715;
  unint64_t v716;
  unint64_t v717;
  unint64_t v718;
  unint64_t v719;
  unint64_t v720;
  unint64_t v721;
  unint64_t v722;
  unint64_t v723;
  unint64_t v724;
  unint64_t v725;
  unint64_t v726;
  unint64_t v727;
  unint64_t v728;
  unint64_t v729;
  unint64_t v730;
  unint64_t v731;
  unint64_t v732;
  unint64_t v733;
  uint64_t v734;
  unint64_t v735;
  unint64_t v736;
  unint64_t v737;
  unint64_t v738;
  unint64_t v739;
  unint64_t v740;
  unint64_t v741;
  uint64_t v742;
  unint64_t v743;
  unint64_t v744;
  unint64_t v745;
  uint64_t v746;
  unint64_t v747;
  unint64_t v748;
  unint64_t v749;
  unint64_t v750;
  unint64_t v751;
  unint64_t v752;
  unint64_t v753;
  unint64_t v754;
  unint64_t v755;
  unint64_t v756;
  unint64_t v757;
  unint64_t v758;
  unint64_t v759;
  unint64_t v760;
  unint64_t v761;
  unint64_t v762;
  unint64_t v763;
  unint64_t v764;
  uint64_t v765;
  unint64_t v766;
  unint64_t v767;
  unint64_t v768;
  uint64_t v769;
  unint64_t v770;
  unint64_t v771;
  unint64_t v772;
  unint64_t v773;
  unint64_t v774;
  uint64_t v775;
  unint64_t v776;
  unint64_t v777;
  unint64_t v778;
  unint64_t v779;
  unint64_t v780;
  unint64_t v781;
  unint64_t v782;
  unint64_t v783;
  unint64_t v784;
  unint64_t v785;
  unint64_t v786;
  unint64_t v787;
  unint64_t v788;
  unint64_t v789;
  unint64_t v790;
  unint64_t v791;
  unint64_t v792;
  unint64_t v793;
  unint64_t v794;
  uint64_t v795;
  unint64_t v796;
  unint64_t v797;
  unint64_t v798;
  unint64_t v799;
  unint64_t v800;
  unint64_t v801;
  uint64_t v802;
  unint64_t v803;
  unint64_t v804;
  unint64_t v805;
  unint64_t v806;
  unint64_t v807;
  unint64_t v808;
  unint64_t v809;
  unint64_t v810;
  unint64_t v811;
  unint64_t v812;
  unint64_t v813;
  unint64_t v814;
  unint64_t v815;
  unint64_t v816;
  unint64_t v817;
  unint64_t v818;
  unint64_t v819;
  unint64_t v820;
  unint64_t v821;
  uint64_t v822;
  unint64_t v823;
  unint64_t v824;
  uint64_t v825;
  unint64_t v826;
  unint64_t v827;
  unint64_t v828;
  unint64_t v829;
  unint64_t v830;
  unint64_t v831;
  unint64_t v832;
  uint64_t v833;
  unint64_t v834;
  unint64_t v835;
  unint64_t v836;
  unint64_t v837;
  unint64_t v838;
  unint64_t v839;
  unint64_t v840;
  unint64_t v841;
  unint64_t v842;
  unint64_t v843;
  unint64_t v844;
  uint64_t v845;
  unint64_t v846;
  unint64_t v847;
  uint64_t v848;
  unint64_t v849;
  unint64_t v850;
  unint64_t v851;
  unint64_t v852;
  unint64_t v853;
  unint64_t v854;
  unint64_t v855;
  unint64_t v856;
  unint64_t v857;
  unint64_t v858;
  unint64_t v859;
  unint64_t v860;
  unint64_t v861;
  unint64_t v862;
  uint64_t v863;
  unint64_t v864;
  unint64_t v865;
  unint64_t v866;
  uint64_t v867;
  unint64_t v868;
  unint64_t v869;
  unint64_t v870;
  unint64_t v871;
  unint64_t v872;
  unint64_t v873;
  unint64_t v874;
  unint64_t v875;
  unint64_t v876;
  unint64_t v877;
  unint64_t v878;
  unint64_t v879;
  unint64_t v880;
  unint64_t v881;
  unint64_t v882;
  unint64_t v883;
  unint64_t v884;
  unint64_t v885;
  unint64_t v886;
  unint64_t v887;
  unint64_t v888;
  unint64_t v889;
  unint64_t v890;
  unint64_t v891;
  unint64_t v892;
  unint64_t v893;
  unint64_t v894;
  unint64_t v895;
  unint64_t v896;
  unint64_t v897;
  unint64_t v898;
  unint64_t v899;
  unint64_t v900;
  unint64_t v901;
  unint64_t v902;
  unint64_t v903;
  unint64_t v904;
  unint64_t v905;
  unint64_t v906;
  unint64_t v907;

  v2 = HIDWORD(*a2);
  v3 = *a2;
  v4 = v3 * (unint64_t)v3;
  v5 = v3 * (unint64_t)v2;
  v6 = (v5 << 32) + v4;
  v7 = v6 + (v5 << 32);
  v8 = ((v5 >> 31) & 0x1FFFFFFFELL)
     + v2 * (unint64_t)v2
     + (((v4 | (v5 << 32)) & ~v6 | v4 & (v5 << 32)) >> 63)
     + (((v6 | (v5 << 32)) & ~v7 | v6 & (v5 << 32)) >> 63);
  *result = v7;
  v9 = a2[1];
  v10 = HIDWORD(v9);
  v11 = *a2 * (unint64_t)v9;
  v12 = *a2 * (unint64_t)HIDWORD(v9);
  v13 = HIDWORD(*a2);
  v14 = (v12 << 32) + v11;
  v15 = v13 * (unint64_t)v9;
  v16 = v14 + (v15 << 32);
  v17 = HIDWORD(v12)
      + v13 * (unint64_t)v10
      + HIDWORD(v15)
      + (((v11 | (v12 << 32)) & ~v14 | v11 & (v12 << 32)) >> 63)
      + (((v14 | (v15 << 32)) & ~v16 | v14 & (v15 << 32)) >> 63);
  v18 = v8 + v16;
  v19 = v17 + (((v8 | v16) & ~(v8 + v16) | v8 & v16) >> 63);
  v20 = v18 | v16;
  v21 = v18 & v16;
  v22 = v18 + v16;
  v23 = v17 + ((v20 & ~v22 | v21) >> 63);
  result[1] = v22;
  v24 = a2[1];
  v25 = v24 * (unint64_t)HIDWORD(v24);
  v26 = (v25 << 32) + v24 * (unint64_t)v24;
  v27 = v26 + (v25 << 32);
  v28 = v23 + v19 + v27;
  v29 = ((v25 >> 31) & 0x1FFFFFFFELL)
      + HIDWORD(v24) * (unint64_t)HIDWORD(v24)
      + ((((v24 * (unint64_t)v24) | (v25 << 32)) & ~v26 | (v24
                                                                                            * (unint64_t)v24) & (v25 << 32)) >> 63)
      + (((v26 | (v25 << 32)) & ~v27 | v26 & (v25 << 32)) >> 63)
      + ((((v23 + v19) | v27) & ~v28 | (v23 + v19) & v27) >> 63);
  v30 = v29 + (((v23 | v19) & ~(v23 + v19) | v23 & v19) >> 63);
  v31 = a2[2];
  v32 = HIDWORD(v31);
  v33 = *a2 * (unint64_t)v31;
  v34 = *a2 * (unint64_t)HIDWORD(v31);
  v35 = HIDWORD(*a2);
  v36 = (v34 << 32) + v33;
  v37 = v35 * (unint64_t)v31;
  v38 = HIDWORD(v34) + v35 * (unint64_t)v32;
  v39 = v36 + (v37 << 32);
  v40 = v38
      + HIDWORD(v37)
      + (((v33 | (v34 << 32)) & ~v36 | v33 & (v34 << 32)) >> 63)
      + (((v36 | (v37 << 32)) & ~v39 | v36 & (v37 << 32)) >> 63);
  v41 = v28 + v39;
  v42 = v40 + (((v28 | v39) & ~(v28 + v39) | v28 & v39) >> 63);
  v43 = v29 & ~v30;
  v44 = v42 | v30;
  v45 = v42 & v30;
  v46 = v42 + v30;
  v47 = ((v44 & ~v46 | v45) >> 63) + (v43 >> 63);
  v48 = v41 | v39;
  v49 = v41 & v39;
  v50 = v41 + v39;
  v51 = v40 + ((v48 & ~v50 | v49) >> 63);
  v52 = v51 | v46;
  v53 = v51 & v46;
  v54 = v51 + v46;
  v55 = v47 + ((v52 & ~v54 | v53) >> 63);
  result[2] = v50;
  v57 = a2[2];
  v56 = a2[3];
  v58 = HIDWORD(v56);
  v59 = a2[1];
  v60 = *a2 * (unint64_t)v56;
  v61 = *a2 * (unint64_t)HIDWORD(v56);
  v62 = v60 | (v61 << 32);
  v63 = v60 & (v61 << 32);
  v64 = HIDWORD(*a2);
  v65 = (v61 << 32) + *a2 * (unint64_t)v56;
  v66 = v64 * (unint64_t)v56;
  v67 = HIDWORD(v61) + v64 * (unint64_t)v58;
  v68 = v65 + (v66 << 32);
  v69 = v67 + HIDWORD(v66) + ((v62 & ~v65 | v63) >> 63) + (((v65 | (v66 << 32)) & ~v68 | v65 & (v66 << 32)) >> 63);
  v70 = v54 | v68;
  v71 = v54 & v68;
  v72 = v54 + v68;
  v73 = v69 + ((v70 & ~v72 | v71) >> 63);
  v74 = v72 | v68;
  v75 = v72 & v68;
  v76 = v72 + v68;
  v77 = v69 + ((v74 & ~v76 | v75) >> 63);
  v78 = v55 + v73;
  v79 = v73 & ~v78;
  v80 = v77 | v78;
  v81 = v77 & v78;
  v82 = v77 + v78;
  v83 = ((v80 & ~v82 | v81) >> 63) + (v79 >> 63);
  v84 = HIDWORD(v57);
  LODWORD(v80) = v59;
  v85 = v59 * (unint64_t)v57;
  v86 = v59 * (unint64_t)HIDWORD(v57);
  v59 >>= 32;
  v87 = (v86 << 32) + v80 * (unint64_t)v57;
  v88 = v59 * (unint64_t)v57;
  v89 = HIDWORD(v86) + v59 * (unint64_t)v84;
  v90 = v87 + (v88 << 32);
  v91 = v89
      + HIDWORD(v88)
      + (((v85 | (v86 << 32)) & ~v87 | v85 & (v86 << 32)) >> 63)
      + (((v87 | (v88 << 32)) & ~v90 | v87 & (v88 << 32)) >> 63);
  v92 = v76 | v90;
  v93 = v76 & v90;
  v94 = v76 + v90;
  v95 = v91 + ((v92 & ~v94 | v93) >> 63);
  v96 = v95 | v82;
  v97 = v95 & v82;
  v98 = v95 + v82;
  v99 = v83 + ((v96 & ~v98 | v97) >> 63);
  v100 = v94 | v90;
  v101 = v94 & v90;
  v102 = v94 + v90;
  v103 = v91 + ((v100 & ~v102 | v101) >> 63);
  v104 = v103 | v98;
  v105 = v103 & v98;
  v106 = v103 + v98;
  v107 = v99 + ((v104 & ~v106 | v105) >> 63);
  result[3] = v102;
  v109 = a2[2];
  v108 = a2[3];
  v110 = v109 * (unint64_t)HIDWORD(v109);
  v111 = (v110 << 32) + v109 * (unint64_t)v109;
  v112 = v111 + (v110 << 32);
  v113 = ((v110 >> 31) & 0x1FFFFFFFELL)
       + HIDWORD(v109) * (unint64_t)HIDWORD(v109)
       + ((((v109 * (unint64_t)v109) | (v110 << 32)) & ~v111 | (v109
                                                                                                 * (unint64_t)v109) & (v110 << 32)) >> 63)
       + (((v111 | (v110 << 32)) & ~v112 | v111 & (v110 << 32)) >> 63);
  v114 = v106 | v112;
  v115 = v106 & v112;
  v116 = v106 + v112;
  v117 = v113 + ((v114 & ~v116 | v115) >> 63);
  v118 = HIDWORD(v108);
  v119 = a2[1];
  LODWORD(v97) = v119;
  v120 = v119 * (unint64_t)v108;
  v121 = v119 * (unint64_t)HIDWORD(v108);
  v122 = v120 | (v121 << 32);
  v123 = v120 & (v121 << 32);
  v119 >>= 32;
  v124 = (v121 << 32) + v97 * (unint64_t)v108;
  v125 = v119 * (unint64_t)v108;
  v126 = HIDWORD(v121) + v119 * (unint64_t)v118;
  v127 = v124 + (v125 << 32);
  v128 = v126
       + HIDWORD(v125)
       + ((v122 & ~v124 | v123) >> 63)
       + (((v124 | (v125 << 32)) & ~v127 | v124 & (v125 << 32)) >> 63);
  v129 = v116 | v127;
  v130 = v116 & v127;
  v131 = v116 + v127;
  v132 = v128 + ((v129 & ~v131 | v130) >> 63);
  v133 = v117 | v107;
  v134 = v117 + v107;
  v135 = v133 & ~v134;
  v136 = v132 | v134;
  v137 = v132 & v134;
  v138 = v132 + v134;
  v139 = ((v136 & ~v138 | v137) >> 63) + (v135 >> 63);
  v140 = v131 | v127;
  v141 = v131 & v127;
  v142 = v131 + v127;
  v143 = v128 + ((v140 & ~v142 | v141) >> 63);
  v144 = v143 | v138;
  v145 = v143 & v138;
  v146 = v143 + v138;
  v147 = v139 + ((v144 & ~v146 | v145) >> 63);
  v148 = a2[4];
  v149 = HIDWORD(v148);
  v150 = *a2 * (unint64_t)v148;
  v151 = *a2 * (unint64_t)HIDWORD(v148);
  v152 = HIDWORD(*a2);
  v153 = (v151 << 32) + v150;
  v154 = v152 * (unint64_t)v148;
  v155 = HIDWORD(v151) + v152 * (unint64_t)v149;
  v156 = v153 + (v154 << 32);
  v157 = v155
       + HIDWORD(v154)
       + (((v150 | (v151 << 32)) & ~v153 | v150 & (v151 << 32)) >> 63)
       + (((v153 | (v154 << 32)) & ~v156 | v153 & (v154 << 32)) >> 63);
  v158 = v142 | v156;
  v159 = v142 & v156;
  v160 = v142 + v156;
  v161 = v157 + ((v158 & ~v160 | v159) >> 63);
  v162 = v161 | v146;
  v163 = v161 & v146;
  v164 = v161 + v146;
  v165 = v147 + ((v162 & ~v164 | v163) >> 63);
  v166 = v160 | v156;
  v167 = v160 & v156;
  v168 = v160 + v156;
  v169 = v157 + ((v166 & ~v168 | v167) >> 63);
  v170 = v169 | v164;
  v171 = v169 & v164;
  v172 = v169 + v164;
  v173 = v165 + ((v170 & ~v172 | v171) >> 63);
  result[4] = v168;
  v175 = a2[4];
  v174 = a2[5];
  v176 = HIDWORD(v174);
  LODWORD(v171) = v174;
  v177 = a2[1];
  v178 = HIDWORD(*a2);
  LODWORD(v127) = *a2;
  v179 = v127 * (unint64_t)v174;
  v180 = v127 * (unint64_t)v176;
  v181 = (v180 << 32) + v127 * (unint64_t)v171;
  v182 = v178 * (unint64_t)v171;
  v183 = HIDWORD(v180) + v178 * (unint64_t)v176;
  v184 = v181 + (v182 << 32);
  v185 = v183
       + HIDWORD(v182)
       + (((v179 | (v180 << 32)) & ~v181 | v179 & (v180 << 32)) >> 63)
       + (((v181 | (v182 << 32)) & ~v184 | v181 & (v182 << 32)) >> 63);
  v186 = v172 | v184;
  v187 = v172 & v184;
  v188 = v172 + v184;
  v189 = v185 + ((v186 & ~v188 | v187) >> 63);
  v190 = v189 | v173;
  v191 = v189 + v173;
  v192 = v190 & ~v191;
  v193 = v188 | v184;
  v194 = v188 & v184;
  v195 = v188 + v184;
  v196 = v185 + ((v193 & ~v195 | v194) >> 63);
  v197 = v196 | v191;
  v198 = v196 & v191;
  v199 = v196 + v191;
  v200 = ((v197 & ~v199 | v198) >> 63) + (v192 >> 63);
  v201 = HIDWORD(v175);
  LODWORD(v197) = v175;
  v202 = HIDWORD(v177);
  LODWORD(v184) = v177;
  v203 = v177 * (unint64_t)v175;
  v204 = v177 * (unint64_t)v201;
  v205 = (v204 << 32) + v184 * (unint64_t)v197;
  v206 = v202 * (unint64_t)v197;
  v207 = HIDWORD(v204) + v202 * (unint64_t)v201;
  v208 = v205 + (v206 << 32);
  v209 = v207
       + HIDWORD(v206)
       + (((v203 | (v204 << 32)) & ~v205 | v203 & (v204 << 32)) >> 63)
       + (((v205 | (v206 << 32)) & ~v208 | v205 & (v206 << 32)) >> 63);
  v210 = v195 | v208;
  v211 = v195 & v208;
  v212 = v195 + v208;
  v213 = v209 + ((v210 & ~v212 | v211) >> 63);
  v214 = v213 | v199;
  v215 = v213 & v199;
  v216 = v213 + v199;
  v217 = v200 + ((v214 & ~v216 | v215) >> 63);
  v218 = v212 | v208;
  v219 = v212 & v208;
  v220 = v212 + v208;
  v221 = v209 + ((v218 & ~v220 | v219) >> 63);
  v222 = v221 | v216;
  v223 = v221 & v216;
  v224 = v221 + v216;
  v225 = v217 + ((v222 & ~v224 | v223) >> 63);
  v227 = a2[2];
  v226 = a2[3];
  v228 = HIDWORD(v226);
  LODWORD(v208) = v226;
  v229 = HIDWORD(v227);
  LODWORD(v205) = v227;
  v230 = v227 * (unint64_t)v226;
  v231 = v227 * (unint64_t)v228;
  v232 = HIDWORD(v231) + v229 * (unint64_t)v228;
  v233 = v230 | (v231 << 32);
  v234 = v230 & (v231 << 32);
  v235 = (v231 << 32) + v205 * (unint64_t)v208;
  v236 = v233 & ~v235 | v234;
  v237 = v229 * (unint64_t)v208;
  v238 = v235 | (v237 << 32);
  v239 = v235 & (v237 << 32);
  v240 = v235 + (v237 << 32);
  v241 = v232 + HIDWORD(v237) + (v236 >> 63) + ((v238 & ~v240 | v239) >> 63);
  v242 = v220 | v240;
  v243 = v220 & v240;
  v244 = v220 + v240;
  v245 = v241 + ((v242 & ~v244 | v243) >> 63);
  v246 = v245 | v224;
  v247 = v245 & v224;
  v248 = v245 + v224;
  v249 = v225 + ((v246 & ~v248 | v247) >> 63);
  v250 = v244 | v240;
  v251 = v244 & v240;
  v252 = v244 + v240;
  v253 = v241 + ((v250 & ~v252 | v251) >> 63);
  v254 = v253 | v248;
  v255 = v253 & v248;
  v256 = v253 + v248;
  v257 = v249 + ((v254 & ~v256 | v255) >> 63);
  result[5] = v252;
  v259 = a2[2];
  v258 = a2[3];
  v260 = HIDWORD(v258);
  v261 = v258 * (unint64_t)HIDWORD(v258);
  v262 = (v261 << 32) + v258 * (unint64_t)v258;
  v263 = ((v258 * (unint64_t)v258) | (v261 << 32)) & ~v262 | (v258
                                                                                               * (unint64_t)v258) & (v261 << 32);
  v264 = v262 | (v261 << 32);
  v265 = v262 & (v261 << 32);
  v266 = v262 + (v261 << 32);
  v267 = ((v261 >> 31) & 0x1FFFFFFFELL)
       + v260 * (unint64_t)v260
       + (v263 >> 63)
       + ((v264 & ~v266 | v265) >> 63);
  v268 = v256 | v266;
  v269 = v256 & v266;
  v270 = v256 + v266;
  v271 = v267 + ((v268 & ~v270 | v269) >> 63);
  v272 = v271 | v257;
  v273 = v271 + v257;
  v274 = v272 & ~v273;
  v275 = a2[4];
  v276 = a2[5];
  v277 = HIDWORD(v275);
  LODWORD(v264) = v275;
  v278 = HIDWORD(v259);
  LODWORD(v181) = v259;
  v279 = v259 * (unint64_t)v275;
  v280 = v181 * (unint64_t)HIDWORD(v275);
  v281 = HIDWORD(v280) + v278 * (unint64_t)v277;
  v282 = v279 | (v280 << 32);
  v283 = v279 & (v280 << 32);
  v284 = (v280 << 32) + v181 * (unint64_t)v264;
  v285 = v282 & ~v284 | v283;
  v286 = v278 * (unint64_t)v264;
  v287 = v284 | (v286 << 32);
  v288 = v284 & (v286 << 32);
  v289 = v284 + (v286 << 32);
  v290 = v281 + HIDWORD(v286) + (v285 >> 63) + ((v287 & ~v289 | v288) >> 63);
  v291 = v270 | v289;
  v292 = v270 & v289;
  v293 = v270 + v289;
  v294 = v290 + ((v291 & ~v293 | v292) >> 63);
  v295 = v294 | v273;
  v296 = v294 & v273;
  v297 = v294 + v273;
  v298 = ((v295 & ~v297 | v296) >> 63) + (v274 >> 63);
  v299 = v293 | v289;
  v300 = v293 & v289;
  v301 = v293 + v289;
  v302 = v290 + ((v299 & ~v301 | v300) >> 63);
  v303 = v302 | v297;
  v304 = v302 & v297;
  v305 = v302 + v297;
  v306 = v298 + ((v303 & ~v305 | v304) >> 63);
  v307 = HIDWORD(v276);
  LODWORD(v303) = v276;
  v308 = a2[1];
  v309 = HIDWORD(v308);
  LODWORD(v288) = v308;
  v310 = v308 * (unint64_t)v276;
  v311 = v308 * (unint64_t)v307;
  v312 = HIDWORD(v311) + v309 * (unint64_t)v307;
  v313 = v310 | (v311 << 32);
  v314 = v310 & (v311 << 32);
  v315 = (v311 << 32) + v288 * (unint64_t)v303;
  v316 = v313 & ~v315 | v314;
  v317 = v309 * (unint64_t)v303;
  v318 = v315 | (v317 << 32);
  v319 = v315 & (v317 << 32);
  v320 = v315 + (v317 << 32);
  v321 = v312 + HIDWORD(v317) + (v316 >> 63) + ((v318 & ~v320 | v319) >> 63);
  v322 = v301 | v320;
  v323 = v301 & v320;
  v324 = v301 + v320;
  v325 = v321 + ((v322 & ~v324 | v323) >> 63);
  v326 = v325 | v305;
  v327 = v325 & v305;
  v328 = v325 + v305;
  v329 = v306 + ((v326 & ~v328 | v327) >> 63);
  v330 = v324 | v320;
  v331 = v324 & v320;
  v332 = v324 + v320;
  v333 = v321 + ((v330 & ~v332 | v331) >> 63);
  v334 = v333 | v328;
  v335 = v333 & v328;
  v336 = v333 + v328;
  v337 = v329 + ((v334 & ~v336 | v335) >> 63);
  v338 = a2[6];
  v339 = HIDWORD(v338);
  LODWORD(v335) = v338;
  v340 = HIDWORD(*a2);
  LODWORD(v327) = *a2;
  v341 = v327 * (unint64_t)v338;
  v342 = v327 * (unint64_t)v339;
  v343 = HIDWORD(v342) + v340 * (unint64_t)v339;
  v344 = v341 | (v342 << 32);
  v345 = v341 & (v342 << 32);
  v346 = (v342 << 32) + v327 * (unint64_t)v335;
  v347 = v344 & ~v346 | v345;
  v348 = v340 * (unint64_t)v335;
  v349 = v346 | (v348 << 32);
  v350 = v346 & (v348 << 32);
  v351 = v346 + (v348 << 32);
  v352 = v343 + HIDWORD(v348) + (v347 >> 63) + ((v349 & ~v351 | v350) >> 63);
  v353 = v332 | v351;
  v354 = v332 & v351;
  v355 = v332 + v351;
  v356 = v352 + ((v353 & ~v355 | v354) >> 63);
  v357 = v356 | v336;
  v358 = v356 & v336;
  v359 = v356 + v336;
  v360 = v337 + ((v357 & ~v359 | v358) >> 63);
  v361 = v355 + v351;
  v362 = v352 + (((v355 | v351) & ~(v355 + v351) | v355 & v351) >> 63);
  v363 = v362 | v359;
  v364 = v362 & v359;
  v365 = v362 + v359;
  v366 = v360 + ((v363 & ~v365 | v364) >> 63);
  result[6] = v361;
  v368 = a2[6];
  v367 = a2[7];
  v369 = HIDWORD(v367);
  LODWORD(v357) = v367;
  v370 = a2[1];
  v371 = HIDWORD(*a2);
  LODWORD(v319) = *a2;
  v372 = v319 * (unint64_t)v367;
  v373 = v319 * (unint64_t)v369;
  v374 = HIDWORD(v373) + v371 * (unint64_t)v369;
  v375 = v372 | (v373 << 32);
  v376 = v372 & (v373 << 32);
  v377 = (v373 << 32) + v319 * (unint64_t)v357;
  v378 = v375 & ~v377 | v376;
  v379 = v371 * (unint64_t)v357;
  v380 = v377 | (v379 << 32);
  v381 = v377 & (v379 << 32);
  v382 = v377 + (v379 << 32);
  v383 = v374 + HIDWORD(v379) + (v378 >> 63) + ((v380 & ~v382 | v381) >> 63);
  v384 = v365 | v382;
  v385 = v365 & v382;
  v386 = v365 + v382;
  v387 = v383 + ((v384 & ~v386 | v385) >> 63);
  v388 = v387 | v366;
  v389 = v387 & v366;
  v390 = v387 + v366;
  v391 = v388 & ~v390 | v389;
  v392 = v386 | v382;
  v393 = v386 & v382;
  v394 = v386 + v382;
  v395 = v383 + ((v392 & ~v394 | v393) >> 63);
  v396 = v395 | v390;
  v397 = v395 & v390;
  v398 = v395 + v390;
  v399 = ((v396 & ~v398 | v397) >> 63) + (v391 >> 63);
  v400 = HIDWORD(v368);
  LODWORD(v396) = v368;
  v401 = HIDWORD(v370);
  LODWORD(v393) = v370;
  v402 = v370 * (unint64_t)v368;
  v403 = v370 * (unint64_t)v400;
  v404 = HIDWORD(v403) + v401 * (unint64_t)v400;
  v405 = v402 | (v403 << 32);
  v406 = v402 & (v403 << 32);
  v407 = (v403 << 32) + v393 * (unint64_t)v396;
  v408 = v405 & ~v407 | v406;
  v409 = v401 * (unint64_t)v396;
  v410 = v407 | (v409 << 32);
  v411 = v407 & (v409 << 32);
  v412 = v407 + (v409 << 32);
  v413 = v404 + HIDWORD(v409) + (v408 >> 63) + ((v410 & ~v412 | v411) >> 63);
  v414 = v394 | v412;
  v415 = v394 & v412;
  v416 = v394 + v412;
  v417 = v413 + ((v414 & ~v416 | v415) >> 63);
  v418 = v417 | v398;
  v419 = v417 & v398;
  v420 = v417 + v398;
  v421 = v399 + ((v418 & ~v420 | v419) >> 63);
  v422 = v416 | v412;
  v423 = v416 & v412;
  v424 = v416 + v412;
  v425 = v413 + ((v422 & ~v424 | v423) >> 63);
  v426 = v425 | v420;
  v427 = v425 & v420;
  v428 = v425 + v420;
  v429 = v421 + ((v426 & ~v428 | v427) >> 63);
  v431 = a2[4];
  v430 = a2[5];
  v432 = HIDWORD(v430);
  LODWORD(v419) = v430;
  v433 = a2[2];
  v434 = a2[3];
  v435 = HIDWORD(v433);
  LODWORD(v405) = v433;
  v436 = v433 * (unint64_t)v430;
  v437 = v433 * (unint64_t)v432;
  v438 = HIDWORD(v437) + v435 * (unint64_t)v432;
  v439 = v436 | (v437 << 32);
  v440 = v436 & (v437 << 32);
  v441 = (v437 << 32) + v405 * (unint64_t)v419;
  v442 = v439 & ~v441 | v440;
  v443 = v435 * (unint64_t)v419;
  v444 = v441 | (v443 << 32);
  v445 = v441 & (v443 << 32);
  v446 = v441 + (v443 << 32);
  v447 = v438 + HIDWORD(v443) + (v442 >> 63) + ((v444 & ~v446 | v445) >> 63);
  v448 = v424 | v446;
  v449 = v424 & v446;
  v450 = v424 + v446;
  v451 = v447 + ((v448 & ~v450 | v449) >> 63);
  v452 = v451 | v428;
  v453 = v451 & v428;
  v454 = v451 + v428;
  v455 = v429 + ((v452 & ~v454 | v453) >> 63);
  v456 = v450 | v446;
  v457 = v450 & v446;
  v458 = v450 + v446;
  v459 = v447 + ((v456 & ~v458 | v457) >> 63);
  v460 = v459 | v454;
  v461 = v459 & v454;
  v462 = v459 + v454;
  v463 = v455 + ((v460 & ~v462 | v461) >> 63);
  v464 = HIDWORD(v431);
  LODWORD(v460) = v431;
  v465 = HIDWORD(v434);
  LODWORD(v446) = v434;
  v466 = v434 * (unint64_t)v431;
  v467 = v434 * (unint64_t)v464;
  v468 = HIDWORD(v467) + v465 * (unint64_t)v464;
  v469 = (v467 << 32) + v446 * (unint64_t)v460;
  v470 = (v466 | (v467 << 32)) & ~v469 | v466 & (v467 << 32);
  v471 = v465 * (unint64_t)v460;
  v472 = v469 | (v471 << 32);
  v473 = v469 & (v471 << 32);
  v474 = v469 + (v471 << 32);
  v475 = v468 + HIDWORD(v471) + (v470 >> 63) + ((v472 & ~v474 | v473) >> 63);
  v476 = v458 | v474;
  v477 = v458 & v474;
  v478 = v458 + v474;
  v479 = v475 + ((v476 & ~v478 | v477) >> 63);
  v480 = v479 | v462;
  v481 = v479 & v462;
  v482 = v479 + v462;
  v483 = v463 + ((v480 & ~v482 | v481) >> 63);
  v484 = v478 | v474;
  v485 = v478 & v474;
  v486 = v478 + v474;
  v487 = v475 + ((v484 & ~v486 | v485) >> 63);
  v488 = v487 | v482;
  v489 = v487 & v482;
  v490 = v487 + v482;
  v491 = v483 + ((v488 & ~v490 | v489) >> 63);
  result[7] = v486;
  v493 = a2[3];
  v492 = a2[4];
  v494 = HIDWORD(v492);
  v495 = v492 * (unint64_t)HIDWORD(v492);
  v496 = (v495 << 32) + v492 * (unint64_t)v492;
  v497 = ((v492 * (unint64_t)v492) | (v495 << 32)) & ~v496 | (v492
                                                                                               * (unint64_t)v492) & (v495 << 32);
  v498 = v496 | (v495 << 32);
  v499 = v496 & (v495 << 32);
  v500 = v496 + (v495 << 32);
  v501 = ((v495 >> 31) & 0x1FFFFFFFELL)
       + v494 * (unint64_t)v494
       + (v497 >> 63)
       + ((v498 & ~v500 | v499) >> 63);
  v502 = v490 | v500;
  v503 = v490 & v500;
  v504 = v490 + v500;
  v505 = v501 + ((v502 & ~v504 | v503) >> 63);
  v506 = v505 | v491;
  v507 = v505 & v491;
  v508 = v505 + v491;
  v509 = v506 & ~v508 | v507;
  v510 = a2[5];
  v511 = a2[6];
  v512 = HIDWORD(v510);
  LODWORD(v498) = v510;
  v513 = HIDWORD(v493);
  LODWORD(v453) = v493;
  v514 = v493 * (unint64_t)v510;
  v515 = v453 * (unint64_t)HIDWORD(v510);
  v516 = HIDWORD(v515) + v513 * (unint64_t)v512;
  v517 = v514 | (v515 << 32);
  v518 = v514 & (v515 << 32);
  v519 = (v515 << 32) + v453 * (unint64_t)v498;
  v520 = v517 & ~v519 | v518;
  v521 = v513 * (unint64_t)v498;
  v522 = v519 | (v521 << 32);
  v523 = v519 & (v521 << 32);
  v524 = v519 + (v521 << 32);
  v525 = v516 + HIDWORD(v521) + (v520 >> 63) + ((v522 & ~v524 | v523) >> 63);
  v526 = v504 | v524;
  v527 = v504 & v524;
  v528 = v504 + v524;
  v529 = v525 + ((v526 & ~v528 | v527) >> 63);
  v530 = v529 | v508;
  v531 = v529 & v508;
  v532 = v529 + v508;
  v533 = ((v530 & ~v532 | v531) >> 63) + (v509 >> 63);
  v534 = v528 | v524;
  v535 = v528 & v524;
  v536 = v528 + v524;
  v537 = v525 + ((v534 & ~v536 | v535) >> 63);
  v538 = v537 | v532;
  v539 = v537 & v532;
  v540 = v537 + v532;
  v541 = v533 + ((v538 & ~v540 | v539) >> 63);
  v542 = HIDWORD(v511);
  LODWORD(v538) = v511;
  v544 = a2[1];
  v543 = a2[2];
  v545 = HIDWORD(v543);
  LODWORD(v523) = v543;
  v546 = v543 * (unint64_t)v511;
  v547 = v543 * (unint64_t)v542;
  v548 = HIDWORD(v547) + v545 * (unint64_t)v542;
  v549 = v546 | (v547 << 32);
  v550 = v546 & (v547 << 32);
  v551 = (v547 << 32) + v523 * (unint64_t)v538;
  v552 = v549 & ~v551 | v550;
  v553 = v545 * (unint64_t)v538;
  v554 = v551 | (v553 << 32);
  v555 = v551 & (v553 << 32);
  v556 = v551 + (v553 << 32);
  v557 = v548 + HIDWORD(v553) + (v552 >> 63) + ((v554 & ~v556 | v555) >> 63);
  v558 = v536 | v556;
  v559 = v536 & v556;
  v560 = v536 + v556;
  v561 = v557 + ((v558 & ~v560 | v559) >> 63);
  v562 = v561 | v540;
  v563 = v561 & v540;
  v564 = v561 + v540;
  v565 = v541 + ((v562 & ~v564 | v563) >> 63);
  v566 = v560 | v556;
  v567 = v560 & v556;
  v568 = v560 + v556;
  v569 = v557 + ((v566 & ~v568 | v567) >> 63);
  v570 = v569 | v564;
  v571 = v569 & v564;
  v572 = v569 + v564;
  v573 = v565 + ((v570 & ~v572 | v571) >> 63);
  v574 = a2[7];
  v575 = HIDWORD(v574);
  LODWORD(v571) = v574;
  v576 = HIDWORD(v544);
  LODWORD(v563) = v544;
  v577 = v544 * (unint64_t)v574;
  v578 = v544 * (unint64_t)v575;
  v579 = HIDWORD(v578) + v576 * (unint64_t)v575;
  v580 = v577 | (v578 << 32);
  v581 = v577 & (v578 << 32);
  v582 = (v578 << 32) + v563 * (unint64_t)v571;
  v583 = v580 & ~v582 | v581;
  v584 = v576 * (unint64_t)v571;
  v585 = v582 | (v584 << 32);
  v586 = v582 & (v584 << 32);
  v587 = v582 + (v584 << 32);
  v588 = v579 + HIDWORD(v584) + (v583 >> 63) + ((v585 & ~v587 | v586) >> 63);
  v589 = v568 | v587;
  v590 = v568 & v587;
  v591 = v568 + v587;
  v592 = v588 + ((v589 & ~v591 | v590) >> 63);
  v593 = v592 | v572;
  v594 = v592 & v572;
  v595 = v592 + v572;
  v596 = v573 + ((v593 & ~v595 | v594) >> 63);
  v597 = v591 + v587;
  v598 = v588 + (((v591 | v587) & ~(v591 + v587) | v591 & v587) >> 63);
  v599 = v598 | v595;
  v600 = v598 & v595;
  v601 = v598 + v595;
  v602 = v596 + ((v599 & ~v601 | v600) >> 63);
  result[8] = v597;
  v604 = a2[6];
  v603 = a2[7];
  v605 = HIDWORD(v603);
  LODWORD(v593) = v603;
  v606 = a2[2];
  v607 = a2[3];
  v608 = HIDWORD(v606);
  LODWORD(v555) = v606;
  v609 = v606 * (unint64_t)v603;
  v610 = v606 * (unint64_t)v605;
  v611 = HIDWORD(v610) + v608 * (unint64_t)v605;
  v612 = v609 | (v610 << 32);
  v613 = v609 & (v610 << 32);
  v614 = (v610 << 32) + v555 * (unint64_t)v593;
  v615 = v612 & ~v614 | v613;
  v616 = v608 * (unint64_t)v593;
  v617 = v614 | (v616 << 32);
  v618 = v614 & (v616 << 32);
  v619 = v614 + (v616 << 32);
  v620 = v611 + HIDWORD(v616) + (v615 >> 63) + ((v617 & ~v619 | v618) >> 63);
  v621 = v601 | v619;
  v622 = v601 & v619;
  v623 = v601 + v619;
  v624 = v620 + ((v621 & ~v623 | v622) >> 63);
  v625 = v624 | v602;
  v626 = v624 & v602;
  v627 = v624 + v602;
  v628 = v625 & ~v627 | v626;
  v629 = v623 | v619;
  v630 = v623 & v619;
  v631 = v623 + v619;
  v632 = v620 + ((v629 & ~v631 | v630) >> 63);
  v633 = v632 | v627;
  v634 = v632 & v627;
  v635 = v632 + v627;
  v636 = ((v633 & ~v635 | v634) >> 63) + (v628 >> 63);
  v637 = HIDWORD(v604);
  LODWORD(v633) = v604;
  v638 = HIDWORD(v607);
  LODWORD(v630) = v607;
  v639 = v607 * (unint64_t)v604;
  v640 = v607 * (unint64_t)v637;
  v641 = HIDWORD(v640) + v638 * (unint64_t)v637;
  v642 = v639 | (v640 << 32);
  v643 = v639 & (v640 << 32);
  v644 = (v640 << 32) + v630 * (unint64_t)v633;
  v645 = v642 & ~v644 | v643;
  v646 = v638 * (unint64_t)v633;
  v647 = v644 | (v646 << 32);
  v648 = v644 & (v646 << 32);
  v649 = v644 + (v646 << 32);
  v650 = v641 + HIDWORD(v646) + (v645 >> 63) + ((v647 & ~v649 | v648) >> 63);
  v651 = v631 | v649;
  v652 = v631 & v649;
  v653 = v631 + v649;
  v654 = v650 + ((v651 & ~v653 | v652) >> 63);
  v655 = v654 | v635;
  v656 = v654 & v635;
  v657 = v654 + v635;
  v658 = v636 + ((v655 & ~v657 | v656) >> 63);
  v659 = v653 | v649;
  v660 = v653 & v649;
  v661 = v653 + v649;
  v662 = v650 + ((v659 & ~v661 | v660) >> 63);
  v663 = v662 | v657;
  v664 = v662 & v657;
  v665 = v662 + v657;
  v666 = v658 + ((v663 & ~v665 | v664) >> 63);
  v668 = a2[4];
  v667 = a2[5];
  v669 = HIDWORD(v667);
  LODWORD(v656) = v667;
  v670 = HIDWORD(v668);
  LODWORD(v648) = v668;
  v671 = v668 * (unint64_t)v667;
  v672 = v668 * (unint64_t)v669;
  v673 = HIDWORD(v672) + v670 * (unint64_t)v669;
  v674 = v671 | (v672 << 32);
  v675 = v671 & (v672 << 32);
  v676 = (v672 << 32) + v648 * (unint64_t)v656;
  v677 = v674 & ~v676 | v675;
  v678 = v670 * (unint64_t)v656;
  v679 = v676 | (v678 << 32);
  v680 = v676 & (v678 << 32);
  v681 = v676 + (v678 << 32);
  v682 = v673 + HIDWORD(v678) + (v677 >> 63) + ((v679 & ~v681 | v680) >> 63);
  v683 = v661 | v681;
  v684 = v661 & v681;
  v685 = v661 + v681;
  v686 = v682 + ((v683 & ~v685 | v684) >> 63);
  v687 = v686 | v665;
  v688 = v686 & v665;
  v689 = v686 + v665;
  v690 = v666 + ((v687 & ~v689 | v688) >> 63);
  v691 = v685 | v681;
  v692 = v685 & v681;
  v693 = v685 + v681;
  v694 = v682 + ((v691 & ~v693 | v692) >> 63);
  v695 = v694 | v689;
  v696 = v694 & v689;
  v697 = v694 + v689;
  v698 = v690 + ((v695 & ~v697 | v696) >> 63);
  result[9] = v693;
  v699 = a2[5];
  v700 = a2[6];
  v701 = HIDWORD(v699);
  v702 = v699 * (unint64_t)HIDWORD(v699);
  v703 = (v702 << 32) + v699 * (unint64_t)v699;
  v704 = ((v699 * (unint64_t)v699) | (v702 << 32)) & ~v703 | (v699
                                                                                               * (unint64_t)v699) & (v702 << 32);
  v705 = v703 | (v702 << 32);
  v706 = v703 & (v702 << 32);
  v707 = v703 + (v702 << 32);
  v708 = ((v702 >> 31) & 0x1FFFFFFFELL)
       + v701 * (unint64_t)v701
       + (v704 >> 63)
       + ((v705 & ~v707 | v706) >> 63);
  v709 = v697 | v707;
  v710 = v697 & v707;
  v711 = v697 + v707;
  v712 = v708 + ((v709 & ~v711 | v710) >> 63);
  v713 = v712 | v698;
  v714 = v712 + v698;
  v715 = v713 & ~v714;
  v716 = HIDWORD(v700);
  LODWORD(v707) = v700;
  v718 = a2[3];
  v717 = a2[4];
  v719 = HIDWORD(v717);
  LODWORD(v618) = v717;
  v720 = v717 * (unint64_t)v700;
  v721 = v717 * (unint64_t)v716;
  v722 = HIDWORD(v721) + v719 * (unint64_t)v716;
  v723 = v720 | (v721 << 32);
  v724 = v720 & (v721 << 32);
  v725 = (v721 << 32) + v618 * (unint64_t)v707;
  v726 = v723 & ~v725 | v724;
  v727 = v719 * (unint64_t)v707;
  v728 = v725 | (v727 << 32);
  v729 = v725 & (v727 << 32);
  v730 = v725 + (v727 << 32);
  v731 = v722 + HIDWORD(v727) + (v726 >> 63) + ((v728 & ~v730 | v729) >> 63);
  v732 = v711 | v730;
  v733 = v711 & v730;
  v734 = v711 + v730;
  v735 = v731 + ((v732 & ~v734 | v733) >> 63);
  v736 = v735 | v714;
  v737 = v735 & v714;
  v738 = v735 + v714;
  v739 = ((v736 & ~v738 | v737) >> 63) + (v715 >> 63);
  v740 = v734 | v730;
  v741 = v734 & v730;
  v742 = v734 + v730;
  v743 = v731 + ((v740 & ~v742 | v741) >> 63);
  v744 = v743 | v738;
  v745 = v743 & v738;
  v746 = v743 + v738;
  v747 = v739 + ((v744 & ~v746 | v745) >> 63);
  v748 = a2[7];
  v749 = HIDWORD(v748);
  LODWORD(v745) = v748;
  v750 = HIDWORD(v718);
  LODWORD(v737) = v718;
  v751 = v718 * (unint64_t)v748;
  v752 = v718 * (unint64_t)v749;
  v753 = HIDWORD(v752) + v750 * (unint64_t)v749;
  v754 = v751 | (v752 << 32);
  v755 = v751 & (v752 << 32);
  v756 = (v752 << 32) + v737 * (unint64_t)v745;
  v757 = v754 & ~v756 | v755;
  v758 = v750 * (unint64_t)v745;
  v759 = v756 | (v758 << 32);
  v760 = v756 & (v758 << 32);
  v761 = v756 + (v758 << 32);
  v762 = v753 + HIDWORD(v758) + (v757 >> 63) + ((v759 & ~v761 | v760) >> 63);
  v763 = v742 | v761;
  v764 = v742 & v761;
  v765 = v742 + v761;
  v766 = v762 + ((v763 & ~v765 | v764) >> 63);
  v767 = v766 | v746;
  v768 = v766 & v746;
  v769 = v766 + v746;
  v770 = v747 + ((v767 & ~v769 | v768) >> 63);
  v771 = v765 + v761;
  v772 = v762 + (((v765 | v761) & ~(v765 + v761) | v765 & v761) >> 63);
  v773 = v772 | v769;
  v774 = v772 & v769;
  v775 = v772 + v769;
  v776 = v770 + ((v773 & ~v775 | v774) >> 63);
  result[10] = v771;
  v778 = a2[6];
  v777 = a2[7];
  v779 = HIDWORD(v777);
  LODWORD(v767) = v777;
  v780 = a2[4];
  v781 = a2[5];
  v782 = HIDWORD(v780);
  LODWORD(v729) = v780;
  v783 = v780 * (unint64_t)v777;
  v784 = v780 * (unint64_t)v779;
  v785 = HIDWORD(v784) + v782 * (unint64_t)v779;
  v786 = v783 | (v784 << 32);
  v787 = v783 & (v784 << 32);
  v788 = (v784 << 32) + v729 * (unint64_t)v767;
  v789 = v786 & ~v788 | v787;
  v790 = v782 * (unint64_t)v767;
  v791 = v788 | (v790 << 32);
  v792 = v788 & (v790 << 32);
  v793 = v788 + (v790 << 32);
  v794 = v785 + HIDWORD(v790) + (v789 >> 63) + ((v791 & ~v793 | v792) >> 63);
  v795 = v775 + v793;
  v796 = v794 + (((v775 | v793) & ~(v775 + v793) | v775 & v793) >> 63);
  v797 = v796 | v776;
  v798 = v796 + v776;
  v799 = v797 & ~v798;
  v800 = v795 | v793;
  v801 = v795 & v793;
  v802 = v795 + v793;
  v803 = v794 + ((v800 & ~v802 | v801) >> 63);
  v804 = v803 | v798;
  v805 = v803 & v798;
  v806 = v803 + v798;
  v807 = v804 & ~v806 | v805;
  v808 = HIDWORD(v778);
  LODWORD(v805) = v778;
  v809 = HIDWORD(v781);
  LODWORD(v792) = v781;
  v810 = v781 * (unint64_t)v778;
  v811 = v781 * (unint64_t)v808;
  v812 = HIDWORD(v811) + v809 * (unint64_t)v808;
  v813 = (v811 << 32) + v792 * (unint64_t)v805;
  v814 = (v810 | (v811 << 32)) & ~v813 | v810 & (v811 << 32);
  v815 = v809 * (unint64_t)v805;
  v816 = v813 | (v815 << 32);
  v817 = v813 & (v815 << 32);
  v818 = v813 + (v815 << 32);
  v819 = v812 + HIDWORD(v815) + (v814 >> 63) + ((v816 & ~v818 | v817) >> 63);
  v820 = v802 | v818;
  v821 = v802 & v818;
  v822 = v802 + v818;
  v823 = v819 + ((v820 & ~v822 | v821) >> 63);
  v824 = v823 | v806;
  result[11] = v822 + v818;
  v825 = a2[5];
  v826 = a2[6];
  v827 = v823 & v806;
  v828 = v823 + v806;
  v829 = v824 & ~v828 | v827;
  v830 = v819 + (((v822 | v818) & ~(v822 + v818) | v822 & v818) >> 63);
  v831 = v830 | v828;
  v832 = v830 & v828;
  v833 = v830 + v828;
  v834 = v831 & ~v833 | v832;
  v835 = HIDWORD(v826);
  LODWORD(v832) = v826;
  v836 = v826 * (unint64_t)v826;
  v837 = v826 * (unint64_t)HIDWORD(v826);
  v838 = (v837 << 32) + v832 * (unint64_t)v832;
  v839 = (v836 | (v837 << 32)) & ~v838 | v836 & (v837 << 32);
  v840 = v838 + (v837 << 32);
  v841 = (v838 | (v837 << 32)) & ~v840 | v838 & (v837 << 32);
  v842 = ((v837 >> 31) & 0x1FFFFFFFELL) + v835 * (unint64_t)v835;
  v843 = v833 | v840;
  v844 = v833 & v840;
  v845 = v833 + v840;
  v846 = (v807 >> 63) + (v799 >> 63) + (v829 >> 63) + (v834 >> 63);
  v847 = v842 + (v839 >> 63) + (v841 >> 63) + ((v843 & ~v845 | v844) >> 63);
  v848 = a2[7];
  v849 = v847 | v846;
  v850 = v847 + v846;
  v851 = v849 & ~v850;
  LODWORD(v842) = v848;
  v852 = v825 * (unint64_t)HIDWORD(v848);
  v853 = HIDWORD(v852) + HIDWORD(v825) * (unint64_t)HIDWORD(v848);
  v854 = (v852 << 32) + v825 * (unint64_t)v848;
  v855 = ((v825 * (unint64_t)v848) | (v852 << 32)) & ~v854 | (v825
                                                                                               * (unint64_t)v848) & (v852 << 32);
  v856 = HIDWORD(v825) * (unint64_t)v842;
  v857 = v854 | (v856 << 32);
  v858 = v854 & (v856 << 32);
  v859 = v854 + (v856 << 32);
  v860 = v853 + HIDWORD(v856) + (v855 >> 63) + ((v857 & ~v859 | v858) >> 63);
  v861 = v845 | v859;
  v862 = v845 & v859;
  v863 = v845 + v859;
  v864 = v860 + ((v861 & ~v863 | v862) >> 63);
  v865 = v864 | v850;
  v866 = v864 & v850;
  result[12] = v863 + v859;
  v867 = a2[6];
  v868 = a2[7];
  v869 = v864 + v850;
  v870 = (v865 & ~v869 | v866) >> 63;
  v871 = v860 + (((v863 | v859) & ~(v863 + v859) | v863 & v859) >> 63);
  v872 = v871 | v869;
  v873 = v871 & v869;
  v874 = v871 + v869;
  v875 = v872 & ~v874 | v873;
  v876 = HIDWORD(v868);
  LODWORD(v873) = v868;
  v877 = v867 * (unint64_t)v868;
  v878 = v867 * (unint64_t)HIDWORD(v868);
  v879 = HIDWORD(v878) + HIDWORD(v867) * (unint64_t)v876;
  v880 = (v878 << 32) + v867 * (unint64_t)v873;
  v881 = (v877 | (v878 << 32)) & ~v880 | v877 & (v878 << 32);
  v882 = HIDWORD(v867) * (unint64_t)v873;
  v883 = v880 + (v882 << 32);
  v884 = v870 + (v851 >> 63) + (v875 >> 63);
  v885 = v879 + HIDWORD(v882) + (v881 >> 63) + (((v880 | (v882 << 32)) & ~v883 | v880 & (v882 << 32)) >> 63);
  v886 = v874 | v883;
  v887 = v874 & v883;
  v888 = v874 + v883;
  v889 = v885 + ((v886 & ~v888 | v887) >> 63);
  result[13] = v888 + v883;
  v890 = a2[7];
  v891 = v884 + v889;
  v892 = v889 & ~v891;
  v893 = v885 + (((v888 | v883) & ~(v888 + v883) | v888 & v883) >> 63);
  v894 = v893 | v891;
  v895 = v893 & v891;
  v896 = v893 + v891;
  v897 = v894 & ~v896 | v895;
  v898 = HIDWORD(v890);
  v899 = v890 * (unint64_t)HIDWORD(v890);
  v900 = (v899 << 32) + v890 * (unint64_t)v890;
  v901 = ((v890 * (unint64_t)v890) | (v899 << 32)) & ~v900 | (v890
                                                                                               * (unint64_t)v890) & (v899 << 32);
  v902 = v900 + (v899 << 32);
  v903 = (v900 | (v899 << 32)) & ~v902 | v900 & (v899 << 32);
  v904 = ((v899 >> 31) & 0x1FFFFFFFELL) + v898 * (unint64_t)v898;
  v905 = v896 | v902;
  v906 = v896 & v902;
  v907 = v896 + v902;
  result[14] = v907;
  result[15] = v904 + (v901 >> 63) + (v903 >> 63) + (v892 >> 63) + (v897 >> 63) + ((v905 & ~v907 | v906) >> 63);
  return result;
}

void bn_sqr_words(unint64_t *rp, const unint64_t *ap, int num)
{
  unint64_t v3;
  unsigned int v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t v20;
  unint64_t v21;
  unint64_t v22;
  unint64_t v23;
  unint64_t v24;
  unint64_t v25;
  unint64_t v26;
  unint64_t v27;
  unint64_t v28;
  unint64_t v29;
  unint64_t v30;
  unint64_t v31;
  unint64_t v32;
  unint64_t v33;
  unint64_t v34;
  unint64_t v35;
  unint64_t *v36;
  uint64_t v37;
  unint64_t v38;
  unint64_t v39;
  unint64_t v40;
  unint64_t v41;
  unint64_t v42;
  unint64_t v43;
  unint64_t v44;

  if (num < 0)
    bn_sqr_words_cold_1();
  if (num)
  {
    if (num < 4)
      goto LABEL_6;
    do
    {
      v3 = HIDWORD(*ap);
      v4 = *ap;
      v5 = v4 * (unint64_t)v4;
      v6 = v4 * (unint64_t)v3;
      v7 = (v6 << 32) + v5;
      v8 = (v5 | (v6 << 32)) & ~v7 | v5 & (v6 << 32);
      v9 = v7 | (v6 << 32);
      v10 = v7 & (v6 << 32);
      v11 = v7 + (v6 << 32);
      *rp = v11;
      rp[1] = ((v6 >> 31) & 0x1FFFFFFFELL)
            + v3 * (unint64_t)v3
            + (v8 >> 63)
            + ((v9 & ~v11 | v10) >> 63);
      v12 = ap[1];
      v13 = HIDWORD(v12);
      v14 = v12 * (unint64_t)HIDWORD(v12);
      v15 = (v14 << 32) + v12 * (unint64_t)v12;
      v16 = ((v12 * (unint64_t)v12) | (v14 << 32)) & ~v15 | (v12
                                                                                              * (unint64_t)v12) & (v14 << 32);
      v17 = v15 | (v14 << 32);
      v18 = v15 & (v14 << 32);
      v19 = v15 + (v14 << 32);
      rp[2] = v19;
      rp[3] = ((v14 >> 31) & 0x1FFFFFFFELL)
            + v13 * (unint64_t)v13
            + (v16 >> 63)
            + ((v17 & ~v19 | v18) >> 63);
      v20 = ap[2];
      v21 = HIDWORD(v20);
      v22 = v20 * (unint64_t)HIDWORD(v20);
      v23 = (v22 << 32) + v20 * (unint64_t)v20;
      v24 = ((v20 * (unint64_t)v20) | (v22 << 32)) & ~v23 | (v20
                                                                                              * (unint64_t)v20) & (v22 << 32);
      v25 = v23 | (v22 << 32);
      v26 = v23 & (v22 << 32);
      v27 = v23 + (v22 << 32);
      rp[4] = v27;
      rp[5] = ((v22 >> 31) & 0x1FFFFFFFELL)
            + v21 * (unint64_t)v21
            + (v24 >> 63)
            + ((v25 & ~v27 | v26) >> 63);
      v28 = ap[3];
      v29 = HIDWORD(v28);
      v30 = v28 * (unint64_t)HIDWORD(v28);
      v31 = (v30 << 32) + v28 * (unint64_t)v28;
      v32 = ((v28 * (unint64_t)v28) | (v30 << 32)) & ~v31 | (v28
                                                                                              * (unint64_t)v28) & (v30 << 32);
      v33 = v31 | (v30 << 32);
      v34 = v31 & (v30 << 32);
      v35 = v31 + (v30 << 32);
      rp[6] = v35;
      rp[7] = ((v30 >> 31) & 0x1FFFFFFFELL)
            + v29 * (unint64_t)v29
            + (v32 >> 63)
            + ((v33 & ~v35 | v34) >> 63);
      ap += 4;
      rp += 8;
      num -= 4;
    }
    while (num >= 4);
    if (num)
    {
LABEL_6:
      v36 = rp + 1;
      do
      {
        v37 = *ap++;
        v38 = v37 * (unint64_t)v37;
        v39 = v37 * (unint64_t)HIDWORD(v37);
        v40 = (v39 << 32) + v38;
        v41 = (v38 | (v39 << 32)) & ~v40 | v38 & (v39 << 32);
        v42 = v40 | (v39 << 32);
        v43 = v40 & (v39 << 32);
        v44 = v40 + (v39 << 32);
        *(v36 - 1) = v44;
        *v36 = ((v39 >> 31) & 0x1FFFFFFFELL)
             + HIDWORD(v37) * (unint64_t)HIDWORD(v37)
             + (v41 >> 63)
             + ((v42 & ~v44 | v43) >> 63);
        v36 += 2;
        --num;
      }
      while (num);
    }
  }
}

unint64_t bn_sqr_normal(unint64_t *rp, uint64_t a2, int a3, unint64_t *a4)
{
  int v8;
  int v9;
  unint64_t *v10;
  unint64_t *v11;
  const unint64_t *v12;
  BOOL v13;

  v8 = 2 * a3;
  rp[2 * a3 - 1] = 0;
  *rp = 0;
  if (a3 >= 2)
  {
    rp[(a3 - 1) + 1] = bn_mul_words(rp + 1, (const unint64_t *)(a2 + 8), a3 - 1, *(_QWORD *)a2);
    v9 = a3 - 2;
    if (a3 != 2)
    {
      v10 = rp + 3;
      v11 = &rp[a3 + 1];
      v12 = (const unint64_t *)(a2 + 16);
      do
      {
        *v11++ = bn_mul_add_words(v10, v12, v9, *(v12 - 1));
        v10 += 2;
        ++v12;
        v13 = v9-- != 0;
      }
      while (v9 != 0 && v13);
    }
  }
  bn_add_words(rp, rp, rp, v8);
  bn_sqr_words(a4, (const unint64_t *)a2, a3);
  return bn_add_words(rp, rp, a4, v8);
}

uint64_t bn_sqr(unint64_t **a1, uint64_t a2, size_t a3, BN_CTX *ctx)
{
  BIGNUM *v8;
  unint64_t **p_d;
  uint64_t v10;

  BN_CTX_start(ctx);
  v8 = BN_CTX_get(ctx);
  if (v8 && (p_d = &v8->d, bn_wexpand((uint64_t)v8, a3)))
  {
    bn_sqr_normal(*a1, *(_QWORD *)a2, *(_DWORD *)(a2 + 8), *p_d);
    v10 = 1;
  }
  else
  {
    v10 = 0;
  }
  BN_CTX_end(ctx);
  return v10;
}

int BN_sqr(BIGNUM *r, const BIGNUM *a, BN_CTX *ctx)
{
  BIGNUM *v7;
  int top;
  size_t v9;
  int v10;

  BN_CTX_start(ctx);
  if (BN_is_zero((uint64_t)a))
  {
    BN_zero((uint64_t)r);
  }
  else
  {
    v7 = r;
    if (r == a)
      v7 = BN_CTX_get(ctx);
    if (v7)
    {
      top = a->top;
      v9 = (2 * top);
      if ((int)v9 >= top)
      {
        if (bn_wexpand((uint64_t)v7, (2 * top)))
        {
          v10 = a->top;
          if (v10 == 8)
          {
            bn_sqr_comba8(v7->d, a->d);
          }
          else if (v10 == 4)
          {
            bn_sqr_comba4(v7->d, a->d);
          }
          else if (!bn_sqr(&v7->d, (uint64_t)a, v9, ctx))
          {
            goto LABEL_3;
          }
          v7->top = v9;
          bn_correct_top((uint64_t *)v7);
          v7->neg = 0;
          bn_copy(r, v7);
        }
      }
    }
  }
LABEL_3:
  BN_CTX_end(ctx);
  return 1;
}

void bn_sqr_words_cold_1()
{
  __assert_rtn("bn_sqr_words", "bn_sqr.c", 170, "n >= 0");
}

void ENGINE_unregister_ECDSA(ENGINE *e)
{
  engine_table_unregister(&ecdsa_table, e);
}

int ENGINE_register_ECDSA(ENGINE *e)
{
  if (*((_QWORD *)e + 6))
    return engine_table_register(&ecdsa_table, (uint64_t)engine_unregister_all_ECDSA, (char *)e, dummy_nid_5, 1, 0);
  else
    return 1;
}

void engine_unregister_all_ECDSA()
{
  engine_table_cleanup(&ecdsa_table);
}

void ENGINE_register_all_ECDSA(void)
{
  ENGINE *first;
  ENGINE *next;

  first = ENGINE_get_first();
  if (first)
  {
    next = first;
    do
    {
      if (*((_QWORD *)next + 6))
        engine_table_register(&ecdsa_table, (uint64_t)engine_unregister_all_ECDSA, (char *)next, dummy_nid_5, 1, 0);
      next = ENGINE_get_next(next);
    }
    while (next);
  }
}

int ENGINE_set_default_ECDSA(ENGINE *e)
{
  if (*((_QWORD *)e + 6))
    return engine_table_register(&ecdsa_table, (uint64_t)engine_unregister_all_ECDSA, (char *)e, dummy_nid_5, 1, 1);
  else
    return 1;
}

ENGINE *ENGINE_get_default_ECDSA(void)
{
  return (ENGINE *)engine_table_select(&ecdsa_table, 1);
}

const ECDSA_METHOD *__cdecl ENGINE_get_ECDSA(const ENGINE *e)
{
  return (const ECDSA_METHOD *)*((_QWORD *)e + 6);
}

int ENGINE_set_ECDSA(ENGINE *e, const ECDSA_METHOD *ecdsa_meth)
{
  *((_QWORD *)e + 6) = ecdsa_meth;
  return 1;
}

ASN1_OCTET_STRING *ASN1_OCTET_STRING_new(void)
{
  return (ASN1_OCTET_STRING *)ASN1_item_new(&ASN1_OCTET_STRING_it);
}

void ASN1_OCTET_STRING_free(ASN1_OCTET_STRING *a)
{
  ASN1_item_free((ASN1_VALUE *)a, &ASN1_OCTET_STRING_it);
}

int i2d_ASN1_OCTET_STRING(ASN1_OCTET_STRING *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &ASN1_OCTET_STRING_it);
}

ASN1_OCTET_STRING *__cdecl d2i_ASN1_OCTET_STRING(ASN1_OCTET_STRING **a, const unsigned __int8 **in, uint64_t len)
{
  return (ASN1_OCTET_STRING *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &ASN1_OCTET_STRING_it);
}

uint64_t pkey_dsa_init(uint64_t a1)
{
  uint64_t result;

  result = (uint64_t)malloc_type_malloc(0x20uLL, 0x106004034A26F38uLL);
  if (result)
  {
    *(_QWORD *)result = 0xA000000400;
    *(_QWORD *)(result + 8) = 0;
    *(_QWORD *)(result + 24) = 0;
    *(_QWORD *)(a1 + 40) = result;
    *(_QWORD *)(a1 + 64) = result + 16;
    *(_DWORD *)(a1 + 72) = 2;
    return 1;
  }
  return result;
}

uint64_t pkey_dsa_copy(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  _QWORD *v5;
  _QWORD *v6;

  result = pkey_dsa_init(a1);
  if ((_DWORD)result)
  {
    v5 = *(_QWORD **)(a2 + 40);
    v6 = *(_QWORD **)(a1 + 40);
    *v6 = *v5;
    v6[1] = v5[1];
    v6[3] = v5[3];
    return 1;
  }
  return result;
}

void pkey_dsa_cleanup(uint64_t a1)
{
  free(*(void **)(a1 + 40));
}

BOOL pkey_dsa_paramgen(uint64_t a1, EVP_PKEY *a2)
{
  const EVP_MD **v3;
  BN_GENCB *v4;
  BIGNUM **v5;
  char *v6;
  _BOOL8 v7;
  _QWORD v9[3];

  v3 = *(const EVP_MD ***)(a1 + 40);
  memset(v9, 0, sizeof(v9));
  if (*(_QWORD *)(a1 + 56))
  {
    v4 = (BN_GENCB *)v9;
    evp_pkey_set_cb_translate((uint64_t)v9, a1);
  }
  else
  {
    v4 = 0;
  }
  v5 = (BIGNUM **)DSA_new();
  if (!v5)
    return 0;
  v6 = (char *)v5;
  v7 = dsa_builtin_paramgen(v5, *(int *)v3, *((int *)v3 + 1), v3[1], 0, 0, 0, 0, 0, v4);
  if (v7)
    EVP_PKEY_assign(a2, 116, v6);
  else
    DSA_free((DSA *)v6);
  return v7;
}

uint64_t pkey_dsa_keygen(uint64_t a1, uint64_t a2)
{
  char *v4;

  if (*(_QWORD *)(a1 + 16))
  {
    v4 = (char *)DSA_new();
    if (v4)
    {
      EVP_PKEY_assign((EVP_PKEY *)a2, 116, v4);
      if (EVP_PKEY_copy_parameters((EVP_PKEY *)a2, *(const EVP_PKEY **)(a1 + 16)))
        return DSA_generate_key(*(DSA **)(a2 + 32));
    }
  }
  else
  {
    ERR_put_error(10, 4095, 107, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/dsa/dsa_pmeth.c", 319);
  }
  return 0;
}

uint64_t pkey_dsa_sign(uint64_t a1, unsigned __int8 *sig, _QWORD *a3, unsigned __int8 *dgst, unint64_t dlen)
{
  DSA *v5;
  uint64_t v6;
  int v7;
  const EVP_MD *v11;
  uint64_t result;
  unsigned int siglen;

  v5 = *(DSA **)(*(_QWORD *)(a1 + 16) + 32);
  v6 = *(_QWORD *)(a1 + 40);
  *a3 = 0;
  if (dlen >> 31)
    return 0;
  v7 = dlen;
  v11 = *(const EVP_MD **)(v6 + 24);
  if (v11)
  {
    if (EVP_MD_size(v11) != dlen)
      return 0;
  }
  siglen = 0;
  result = DSA_sign(0, dgst, v7, sig, &siglen, v5);
  if ((_DWORD)result)
  {
    *a3 = siglen;
    return 1;
  }
  return result;
}

uint64_t pkey_dsa_verify(uint64_t a1, unsigned __int8 *sigbuf, unint64_t siglen, unsigned __int8 *dgst, uint64_t dgst_len)
{
  int v5;
  int v7;
  DSA *v9;
  const EVP_MD *v10;

  if ((dgst_len | siglen) >> 31)
    return 0;
  v5 = dgst_len;
  v7 = siglen;
  v9 = *(DSA **)(*(_QWORD *)(a1 + 16) + 32);
  v10 = *(const EVP_MD **)(*(_QWORD *)(a1 + 40) + 24);
  if (v10 && EVP_MD_size(v10) != dgst_len)
    return 0;
  else
    return DSA_verify(0, dgst, v5, sigbuf, v7, v9);
}

uint64_t pkey_dsa_ctrl(uint64_t a1, int a2, int a3, EVP_MD *md)
{
  uint64_t v5;
  uint64_t result;
  int v7;
  int v8;
  int v9;
  unsigned int v10;
  unint64_t v11;

  v5 = *(_QWORD *)(a1 + 40);
  if (a2 <= 4096)
  {
    result = 1;
    switch(a2)
    {
      case 1:
        v7 = EVP_MD_type(md);
        if ((v7 - 672) < 4
          || (v7 - 1031) < 4
          || (v7 - 64) <= 0x34 && ((1 << (v7 - 64)) & 0x10000000000005) != 0)
        {
          goto LABEL_19;
        }
        v8 = 221;
        goto LABEL_26;
      case 2:
        ERR_put_error(10, 4095, 150, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/dsa/dsa_pmeth.c", 237);
        return 4294967294;
      case 5:
      case 7:
      case 11:
        return result;
      case 13:
        *(_QWORD *)&md->type = *(_QWORD *)(v5 + 24);
        return result;
      default:
        return 4294967294;
    }
  }
  if (a2 == 4099)
  {
    v9 = EVP_MD_type(md);
    if (v9 == 64 || v9 == 672 || v9 == 675)
    {
LABEL_19:
      *(_QWORD *)(v5 + 24) = md;
      return 1;
    }
    v8 = 199;
LABEL_26:
    ERR_put_error(10, 4095, 106, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/dsa/dsa_pmeth.c", v8);
    return 0;
  }
  else
  {
    if (a2 != 4098)
    {
      if (a2 != 4097 || a3 < 256)
        return 4294967294;
      *(_DWORD *)v5 = a3;
      return 1;
    }
    HIDWORD(v11) = a3;
    LODWORD(v11) = a3;
    v10 = v11 >> 5;
    result = 4294967294;
    if (v10 <= 8 && ((1 << v10) & 0x1A1) != 0)
    {
      *(_DWORD *)(v5 + 4) = a3;
      return 1;
    }
  }
  return result;
}

uint64_t pkey_dsa_ctrl_str(uint64_t *a1, char *__s1, const char *a3)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  char *__endptr;

  __endptr = 0;
  if (!strcmp(__s1, "dsa_paramgen_bits"))
  {
    *__error() = 0;
    v7 = strtol(a3, &__endptr, 10);
    if (!*a3)
      return 4294967294;
    if (*__endptr)
      return 4294967294;
    v8 = v7;
    __error();
    if (v8 != (int)v8)
      return 4294967294;
  }
  else
  {
    if (strcmp(__s1, "dsa_paramgen_q_bits"))
    {
      if (!strcmp(__s1, "dsa_paramgen_md"))
      {
        EVP_get_digestbyname(a3);
        return EVP_PKEY_CTX_ctrl(a1, 116, 2);
      }
      return 4294967294;
    }
    *__error() = 0;
    v9 = strtol(a3, &__endptr, 10);
    if (!*a3)
      return 4294967294;
    if (*__endptr)
      return 4294967294;
    v10 = v9;
    __error();
    if (v10 != (int)v10)
      return 4294967294;
  }
  return EVP_PKEY_CTX_ctrl(a1, 116, 2);
}

uint64_t check_id(uint64_t a1)
{
  uint64_t v2;
  X509 *v3;
  int v4;
  int v5;
  char *v6;
  size_t v7;
  uint64_t result;
  char *v9;
  _BYTE *v10;

  v2 = *(_QWORD *)(*(_QWORD *)(a1 + 48) + 56);
  v3 = *(X509 **)(a1 + 16);
  if (*(_QWORD *)v2)
  {
    v4 = sk_num(*(const STACK **)v2);
    free(*(void **)(v2 + 16));
    *(_QWORD *)(v2 + 16) = 0;
    if (v4 < 1)
    {
LABEL_6:
      if (v4)
      {
        *(_QWORD *)(a1 + 184) = *(_QWORD *)(a1 + 16);
        *(_QWORD *)(a1 + 172) = 0x3E00000000;
        result = (*(uint64_t (**)(_QWORD, uint64_t))(a1 + 64))(0, a1);
        if (!(_DWORD)result)
          return result;
      }
    }
    else
    {
      v5 = 0;
      while (1)
      {
        v6 = sk_value(*(const STACK **)v2, v5);
        v7 = strlen(v6);
        if ((int)X509_check_host(v3, v6, v7, *(_DWORD *)(v2 + 8), (char **)(v2 + 16)) > 0)
          break;
        if (v4 == ++v5)
          goto LABEL_6;
      }
    }
  }
  v9 = *(char **)(v2 + 24);
  if (!v9
    || (int)X509_check_email(v3, v9, *(_QWORD *)(v2 + 32), 0) > 0
    || (*(_QWORD *)(a1 + 184) = *(_QWORD *)(a1 + 16),
        *(_QWORD *)(a1 + 172) = 0x3F00000000,
        result = (*(uint64_t (**)(_QWORD, uint64_t))(a1 + 64))(0, a1),
        (_DWORD)result))
  {
    v10 = *(_BYTE **)(v2 + 40);
    if (!v10)
      return 1;
    if ((int)X509_check_ip(v3, v10, *(_QWORD *)(v2 + 48), 0) > 0)
      return 1;
    *(_QWORD *)(a1 + 184) = *(_QWORD *)(a1 + 16);
    *(_QWORD *)(a1 + 172) = 0x4000000000;
    result = (*(uint64_t (**)(_QWORD, uint64_t))(a1 + 64))(0, a1);
    if ((_DWORD)result)
      return 1;
  }
  return result;
}

int X509_verify_cert(X509_STORE_CTX *ctx)
{
  X509 *cert;
  int v3;
  int v4;
  X509 *v5;
  int result;
  _QWORD **v7;
  uint64_t v8;
  int v9;

  cert = ctx->cert;
  if (!cert)
  {
    v3 = 105;
    v4 = 599;
    goto LABEL_15;
  }
  if (*(_QWORD *)&ctx->explicit_policy)
  {
    v3 = 66;
    v4 = 608;
LABEL_15:
    ERR_put_error(11, 4095, v3, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_vfy.c", v4);
    LODWORD(ctx->current_cert) = 65;
    return -1;
  }
  if (*(_DWORD *)(*((_QWORD *)ctx->other_ctx + 7) + 56))
  {
    v3 = 66;
    v4 = 617;
    goto LABEL_15;
  }
  if (LODWORD(ctx->current_cert) != 65)
  {
    v3 = 66;
    v4 = 625;
    goto LABEL_15;
  }
  if (check_key_level((uint64_t)ctx, (uint64_t)cert))
    goto LABEL_12;
  v5 = ctx->cert;
  *(&ctx->error + 1) = 0;
  if (!v5)
    v5 = (X509 *)sk_value(*(const STACK **)&ctx->explicit_policy, 0);
  ctx->current_issuer = v5;
  LODWORD(ctx->current_cert) = 67;
  result = ((uint64_t (*)(_QWORD, X509_STORE_CTX *))ctx->verify_cb)(0, ctx);
  if (result)
  {
LABEL_12:
    if ((*((_BYTE *)ctx->other_ctx + 26) & 0x50) != 0)
      return X509_verify_cert_legacy((uint64_t)ctx);
    v7 = (_QWORD **)x509_verify_ctx_new_from_xsc((uint64_t)ctx);
    if (v7)
    {
      v8 = (uint64_t)v7;
      LODWORD(ctx->current_cert) = 0;
      v9 = x509_verify(v7, 0, 0);
      x509_verify_ctx_free(v8);
      if (v9 >= 1)
        return *(_QWORD *)&ctx->explicit_policy != 0;
    }
    else
    {
      x509_verify_ctx_free(0);
    }
    return 0;
  }
  return result;
}

uint64_t check_key_level(uint64_t a1, uint64_t a2)
{
  EVP_PKEY *v3;
  int v4;

  v3 = X509_get0_pubkey(a2);
  if (v3 && (v4 = EVP_PKEY_security_bits((uint64_t)v3), v4 >= 1))
    return enough_bits_for_security_level(v4, *(_DWORD *)(*(_QWORD *)(a1 + 48) + 44));
  else
    return 0;
}

uint64_t X509_verify_cert_legacy(uint64_t a1)
{
  int *v2;
  uint64_t v3;
  uint64_t (*v4)(_QWORD, uint64_t);
  STACK *v5;
  STACK *v6;
  STACK *v7;
  int v8;
  char *v9;
  int v10;
  uint64_t v11;
  int v12;
  char v13;
  uint64_t (*v14)(uint64_t);
  uint64_t v15;
  int v17;
  char *v18;
  int v19;
  int v20;
  char *v21;
  uint64_t v22;
  char *issuer;
  uint64_t v24;
  int v25;
  int v26;
  int v27;
  char *v28;
  uint64_t v29;
  int v30;
  int v31;
  char *v33;
  uint64_t v34;
  unsigned int v35;
  uint64_t v36;
  int v37;
  int v38;
  int v39;
  int v40;
  uint64_t (*v41)(_QWORD, uint64_t);
  int v42;
  int v43;
  int v44;
  char *p;

  *(_DWORD *)(a1 + 176) = 0;
  v2 = (int *)(a1 + 176);
  p = 0;
  v3 = *(_QWORD *)(a1 + 48);
  v4 = *(uint64_t (**)(_QWORD, uint64_t))(a1 + 64);
  v5 = sk_new_null();
  *((_QWORD *)v2 - 2) = v5;
  if (!v5 || !sk_push(v5, *(char **)(a1 + 16)))
  {
    ERR_put_error(11, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_vfy.c", 255);
    v9 = 0;
    v10 = 0;
    v11 = 0;
    v7 = 0;
LABEL_9:
    v12 = 17;
LABEL_10:
    *v2 = v12;
    goto LABEL_11;
  }
  X509_up_ref(*(_QWORD *)(a1 + 16));
  *(_DWORD *)(a1 + 156) = 1;
  v6 = *(STACK **)(a1 + 24);
  if (v6)
  {
    v7 = sk_dup(v6);
    if (!v7)
    {
      v8 = 265;
LABEL_6:
      ERR_put_error(11, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_vfy.c", v8);
      v9 = 0;
      goto LABEL_7;
    }
  }
  else
  {
    v7 = 0;
  }
  v17 = sk_num(*(const STACK **)(a1 + 160));
  v18 = sk_value(*(const STACK **)(a1 + 160), v17 - 1);
  v19 = *(_DWORD *)(v3 + 40);
  v43 = v19;
  if (v19 >= v17)
  {
    v21 = v18;
    v20 = v19 + 1;
    while (1)
    {
      X509_check_purpose((X509 *)v21, -1, 0);
      if ((v21[57] & 0x20) != 0)
      {
LABEL_46:
        v41 = v4;
        v11 = 0;
        goto LABEL_50;
      }
      if ((*(_BYTE *)(*(_QWORD *)(a1 + 48) + 25) & 0x80) != 0)
      {
        v22 = (*(uint64_t (**)(char **, uint64_t, char *))(a1 + 72))(&p, a1, v21);
        v11 = v22;
        if ((v22 & 0x80000000) != 0)
          goto LABEL_48;
        if ((_DWORD)v22)
          break;
      }
      if (!*(_QWORD *)(a1 + 24))
        goto LABEL_46;
      issuer = find_issuer(a1, v7, (uint64_t)v21, 0);
      p = issuer;
      if (!issuer)
      {
        if ((*(_BYTE *)(*(_QWORD *)(a1 + 48) + 25) & 0x80) != 0)
          goto LABEL_46;
        v24 = (*(uint64_t (**)(char **, uint64_t, char *))(a1 + 72))(&p, a1, v21);
        v11 = v24;
        if ((v24 & 0x80000000) != 0)
        {
LABEL_48:
          v9 = 0;
          v10 = 0;
          v12 = 66;
          goto LABEL_10;
        }
        if ((_DWORD)v24)
          break;
        issuer = find_issuer(a1, v7, (uint64_t)v21, 1);
        p = issuer;
        if (!issuer)
          goto LABEL_46;
      }
      if (!sk_push(*(STACK **)(a1 + 160), issuer))
      {
        v8 = 327;
        goto LABEL_6;
      }
      X509_up_ref((uint64_t)p);
      sk_delete_ptr(v7, p);
      ++*(_DWORD *)(a1 + 156);
      v21 = p;
      if (v20 == ++v17)
      {
        v41 = v4;
        v11 = 0;
        v17 = v20;
        goto LABEL_50;
      }
    }
    v41 = v4;
    X509_free((X509 *)p);
  }
  else
  {
    v41 = v4;
    v11 = 0;
    v20 = v19 + 1;
  }
LABEL_50:
  v9 = 0;
  v42 = 0;
  v40 = v20;
  v44 = v20 - 1;
  v25 = v17;
LABEL_51:
  v26 = sk_num(*(const STACK **)(a1 + 160));
  v27 = v26 - 1;
  v28 = sk_value(*(const STACK **)(a1 + 160), v26 - 1);
  X509_check_purpose((X509 *)v28, -1, 0);
  if ((v28[57] & 0x20) != 0)
  {
    if (v26 != 1)
    {
      v9 = sk_pop(*(STACK **)(a1 + 160));
      --*(_DWORD *)(a1 + 156);
      v30 = v25 - 1;
      v28 = sk_value(*(const STACK **)(a1 + 160), v17 - 2);
      --v17;
      goto LABEL_63;
    }
    v29 = (*(uint64_t (**)(char **, uint64_t, char *))(a1 + 72))(&p, a1, v28);
    if ((int)v29 <= 0)
    {
      *(_QWORD *)(a1 + 184) = v28;
      *(_DWORD *)(a1 + 172) = v27;
      *(_DWORD *)(a1 + 176) = 18;
LABEL_59:
      v11 = v41(0, a1);
      v10 = 1;
      if (!(_DWORD)v11)
        goto LABEL_11;
      v42 = 1;
      goto LABEL_62;
    }
    v11 = v29;
    if (X509_cmp((const X509 *)v28, (const X509 *)p))
    {
      *(_QWORD *)(a1 + 184) = v28;
      *(_DWORD *)(a1 + 172) = v27;
      *(_DWORD *)(a1 + 176) = 18;
      if ((_DWORD)v11 == 1)
        X509_free((X509 *)p);
      goto LABEL_59;
    }
    X509_free((X509 *)v28);
    v28 = p;
    sk_set(*(STACK **)(a1 + 160), 0, p);
    *(_DWORD *)(a1 + 156) = 0;
  }
LABEL_62:
  v30 = v25;
LABEL_63:
  if (v43 >= v17)
  {
    X509_check_purpose((X509 *)v28, -1, 0);
    while (1)
    {
      if ((v28[57] & 0x20) != 0)
        goto LABEL_64;
      v36 = (*(uint64_t (**)(char **, uint64_t, char *))(a1 + 72))(&p, a1, v28);
      v11 = v36;
      if ((v36 & 0x80000000) != 0)
        break;
      if (!(_DWORD)v36)
        goto LABEL_64;
      v28 = p;
      if (!sk_push(*(STACK **)(a1 + 160), p))
      {
        X509_free((X509 *)p);
        ERR_put_error(11, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_vfy.c", 425);
        v11 = 0;
        v39 = 17;
        goto LABEL_101;
      }
      if (v44 == v17)
      {
        v17 = v40;
        goto LABEL_64;
      }
      X509_check_purpose((X509 *)v28, -1, 0);
      ++v17;
    }
    v39 = 66;
LABEL_101:
    *v2 = v39;
    goto LABEL_107;
  }
LABEL_64:
  v31 = check_trust(a1);
  if (v31 == 1)
  {
    v10 = v42;
    goto LABEL_98;
  }
  if (v31 != 2)
  {
    if ((*(_DWORD *)(*(_QWORD *)(a1 + 48) + 24) & 0x108000) == 0 && v30 >= 2)
    {
      while (1)
      {
        v33 = sk_value(*(const STACK **)(a1 + 160), v30 - 2);
        v34 = (*(uint64_t (**)(char **, uint64_t, char *))(a1 + 72))(&p, a1, v33);
        v11 = v34;
        if ((v34 & 0x80000000) != 0)
          goto LABEL_107;
        v25 = v30 - 1;
        if ((_DWORD)v34)
        {
          X509_free((X509 *)p);
          if (v17 >= v30)
          {
            v37 = v17 + 1;
            do
            {
              p = sk_pop(*(STACK **)(a1 + 160));
              X509_free((X509 *)p);
              --v37;
            }
            while (v37 > v30);
            v17 = v30 - 1;
          }
          *(_DWORD *)(a1 + 156) = sk_num(*(const STACK **)(a1 + 160));
          goto LABEL_51;
        }
        v35 = v30--;
        if (v35 < 3)
        {
          v11 = 0;
          break;
        }
      }
    }
    v10 = v42;
    if (v42)
      goto LABEL_98;
    if (v9 && (*(unsigned int (**)(uint64_t, char *, char *))(a1 + 80))(a1, v28, v9))
    {
      if (!sk_push(*(STACK **)(a1 + 160), v9))
      {
        ERR_put_error(11, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_vfy.c", 496);
LABEL_7:
        v10 = 0;
        v11 = 0;
        goto LABEL_9;
      }
      *(_DWORD *)(a1 + 156) = ++v17;
      *(_QWORD *)(a1 + 184) = v9;
      *(_DWORD *)(a1 + 176) = 19;
      v9 = 0;
    }
    else
    {
      v38 = *(_DWORD *)(a1 + 156) >= v17 ? 20 : 2;
      *(_DWORD *)(a1 + 176) = v38;
      *(_QWORD *)(a1 + 184) = v28;
    }
    *(_DWORD *)(a1 + 172) = v17 - 1;
    v11 = v41(0, a1);
    v10 = 1;
    if ((_DWORD)v11)
    {
LABEL_98:
      v13 = 0;
      goto LABEL_12;
    }
LABEL_11:
    v13 = 1;
    goto LABEL_12;
  }
  v11 = 0;
LABEL_107:
  v13 = 1;
  v10 = v42;
LABEL_12:
  sk_free(v7);
  X509_free((X509 *)v9);
  if ((v13 & 1) != 0)
    goto LABEL_13;
  if (x509_vfy_check_chain_extensions(a1))
  {
    if (x509_vfy_check_security_level(a1))
    {
      if (x509_constraints_chain(*(const STACK **)(a1 + 160), v2, (int *)(a1 + 172))
        || (*(_QWORD *)(a1 + 184) = sk_value(*(const STACK **)(a1 + 160), *(_DWORD *)(a1 + 172)),
            (*(unsigned int (**)(_QWORD, uint64_t))(a1 + 64))(0, a1)))
      {
        if (X509v3_asid_validate_path(a1)
          && X509v3_addr_validate_path(a1)
          && check_id(a1)
          && (*(unsigned int (**)(uint64_t))(a1 + 88))(a1))
        {
          v14 = *(uint64_t (**)(uint64_t))(a1 + 56);
          if (v14)
            v15 = v14(a1);
          else
            v15 = x509_vfy_internal_verify(a1, 0);
          v11 = v15;
          if ((_DWORD)v15 && !v10)
            v11 = (*(uint64_t (**)(uint64_t))(a1 + 120))(a1);
LABEL_13:
          if ((int)v11 > 0)
            return v11;
          goto LABEL_26;
        }
      }
    }
  }
  v11 = 0;
LABEL_26:
  if (!*v2)
    *v2 = 1;
  return v11;
}

uint64_t x509_vfy_check_chain_extensions(uint64_t a1)
{
  int v2;
  unsigned int v3;
  uint64_t v4;
  int v5;
  unsigned int (*v6)(_QWORD, uint64_t);
  char v7;
  char *v8;
  char *v9;
  int v10;
  uint64_t v11;
  int v13;
  uint64_t v14;

  if (*(_QWORD *)(a1 + 216))
    v2 = 6;
  else
    v2 = *(_DWORD *)(*(_QWORD *)(a1 + 48) + 32);
  if (*(int *)(a1 + 156) >= 1)
  {
    v3 = 0;
    LODWORD(v4) = 0;
    v5 = 0;
    v6 = *(unsigned int (**)(_QWORD, uint64_t))(a1 + 64);
    v7 = 1;
    while (1)
    {
      v8 = sk_value(*(const STACK **)(a1 + 160), v5);
      v9 = v8;
      if ((*(_BYTE *)(*(_QWORD *)(a1 + 48) + 24) & 0x10) == 0 && (v8[57] & 2) != 0)
      {
        *(_DWORD *)(a1 + 172) = v5;
        *(_DWORD *)(a1 + 176) = 34;
        *(_QWORD *)(a1 + 184) = v8;
        if (!v6(0, a1))
          return 0;
      }
      v10 = X509_check_ca((X509 *)v9);
      if ((v7 & 1) != 0)
      {
        v11 = *(_QWORD *)(a1 + 48);
        if ((*(_BYTE *)(v11 + 24) & 0x20) == 0)
          goto LABEL_22;
        if (v10 == 1 || v10 == 0)
          goto LABEL_22;
      }
      else if (v10)
      {
        v11 = *(_QWORD *)(a1 + 48);
        if ((*(_BYTE *)(v11 + 24) & 0x20) == 0 || v10 == 1)
          goto LABEL_22;
      }
      *(_DWORD *)(a1 + 172) = v5;
      *(_DWORD *)(a1 + 176) = 24;
      *(_QWORD *)(a1 + 184) = v9;
      if (!v6(0, a1))
        return 0;
      v11 = *(_QWORD *)(a1 + 48);
LABEL_22:
      if (*(int *)(v11 + 32) >= 1)
      {
        v13 = X509_check_purpose((X509 *)v9, v2, v4);
        if (!v13 || v13 != 1 && (*(_QWORD *)(*(_QWORD *)(a1 + 48) + 24) & 0x20) != 0)
        {
          *(_DWORD *)(a1 + 172) = v5;
          *(_DWORD *)(a1 + 176) = 26;
          *(_QWORD *)(a1 + 184) = v9;
          if (!v6(0, a1))
            return 0;
        }
      }
      if (v5 >= 2 && (v9[56] & 0x20) == 0)
      {
        v14 = *((_QWORD *)v9 + 6);
        if (v14 != -1 && v14 + 1 < v3)
        {
          *(_DWORD *)(a1 + 172) = v5;
          *(_DWORD *)(a1 + 176) = 25;
          *(_QWORD *)(a1 + 184) = v9;
          if (!v6(0, a1))
            return 0;
        }
      }
      v7 = 0;
      if ((v9[56] & 0x20) == 0)
        ++v3;
      ++v5;
      v4 = 1;
      if (v5 >= *(_DWORD *)(a1 + 156))
        return v4;
    }
  }
  return 1;
}

char *x509_vfy_lookup_cert_match(_QWORD *a1, X509 *a2)
{
  if (a1[16] && *a1 && *(_QWORD *)*a1)
    return lookup_cert_match((uint64_t)a1, a2);
  else
    return 0;
}

char *lookup_cert_match(uint64_t a1, X509 *a)
{
  uint64_t (*v4)(uint64_t, X509_NAME *);
  X509_NAME *subject_name;
  const STACK *v6;
  STACK *v7;
  unint64_t v8;
  char *v9;

  v4 = *(uint64_t (**)(uint64_t, X509_NAME *))(a1 + 128);
  subject_name = X509_get_subject_name(a);
  v6 = (const STACK *)v4(a1, subject_name);
  if (!v6)
    return 0;
  v7 = (STACK *)v6;
  v8 = 0;
  if (sk_num(v6))
  {
    do
    {
      v9 = sk_value(v7, v8);
      if (!X509_cmp((const X509 *)v9, a))
        break;
      ++v8;
    }
    while (v8 < sk_num(v7));
  }
  else
  {
    v9 = 0;
  }
  if (v8 >= sk_num(v7))
    v9 = 0;
  else
    X509_up_ref((uint64_t)v9);
  sk_pop_free(v7, (void (__cdecl *)(void *))X509_free);
  return v9;
}

uint64_t check_trust(uint64_t a1)
{
  unsigned int (*v2)(_QWORD, uint64_t);
  unint64_t v3;
  char *v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  char *v8;
  char *v9;

  v2 = *(unsigned int (**)(_QWORD, uint64_t))(a1 + 64);
  v3 = *(int *)(a1 + 156);
  if (v3 < sk_num(*(const STACK **)(a1 + 160)))
  {
    do
    {
      v4 = sk_value(*(const STACK **)(a1 + 160), v3);
      v5 = X509_check_trust((X509 *)v4, *(_DWORD *)(*(_QWORD *)(a1 + 48) + 36), 0);
      v6 = v5;
      if ((_DWORD)v5 == 2)
      {
        *(_QWORD *)(a1 + 184) = v4;
        *(_DWORD *)(a1 + 172) = v3;
        *(_DWORD *)(a1 + 176) = 28;
        if (!v2(0, a1))
          return v6;
      }
      else if ((_DWORD)v5 == 1)
      {
        return v6;
      }
      ++v3;
    }
    while (v3 < sk_num(*(const STACK **)(a1 + 160)));
  }
  if ((*(_BYTE *)(*(_QWORD *)(a1 + 48) + 26) & 8) == 0)
    return 3;
  v7 = *(_DWORD *)(a1 + 156);
  if (v7 < sk_num(*(const STACK **)(a1 + 160)))
    return 1;
  v8 = sk_value(*(const STACK **)(a1 + 160), 0);
  v9 = lookup_cert_match(a1, (X509 *)v8);
  if (v9)
  {
    sk_set(*(STACK **)(a1 + 160), 0, v9);
    X509_free((X509 *)v8);
    *(_DWORD *)(a1 + 156) = 0;
    return 1;
  }
  return 3;
}

uint64_t check_revocation(uint64_t a1)
{
  uint64_t v1;
  int v3;
  int v4;
  int v5;
  const STACK *v6;
  char *v7;
  int v8;
  unsigned int (*v9)(uint64_t, X509_CRL **, char *);
  X509_CRL *v10;
  X509_NAME *issuer_name;
  STACK *v12;
  X509_CRL *v13;
  int v14;
  int v15;
  int v16;
  int v17;
  X509_CRL *a;
  X509_CRL *v21;
  X509_CRL *v22;
  int v23;
  int v24;
  char *v25;

  v1 = *(_QWORD *)(*(_QWORD *)(a1 + 48) + 24);
  if ((v1 & 4) == 0)
    return 1;
  if ((v1 & 8) == 0)
  {
    if (!*(_QWORD *)(a1 + 216))
    {
      v3 = 0;
      goto LABEL_6;
    }
    return 1;
  }
  v4 = sk_num(*(const STACK **)(a1 + 160));
  v3 = v4 - 1;
  if (v4 < 1)
    return 1;
LABEL_6:
  v5 = 0;
  while (2)
  {
    v6 = *(const STACK **)(a1 + 160);
    a = 0;
    *(_DWORD *)(a1 + 172) = v5;
    v7 = sk_value(v6, v5);
    v8 = 0;
    *(_QWORD *)(a1 + 184) = v7;
    *(_QWORD *)(a1 + 192) = 0;
    *(_QWORD *)(a1 + 208) = 0;
    while (1)
    {
      v9 = *(unsigned int (**)(uint64_t, X509_CRL **, char *))(a1 + 96);
      if (!v9)
      {
        v25 = 0;
        v24 = 0;
        v21 = 0;
        v22 = 0;
        issuer_name = X509_get_issuer_name((X509 *)v7);
        v23 = *(_DWORD *)(a1 + 212);
        if (!get_crl_sk(a1, &v22, &v21, &v25, &v24, &v23, *(STACK **)(a1 + 40)))
        {
          v12 = (STACK *)(*(uint64_t (**)(uint64_t, X509_NAME *))(a1 + 136))(a1, issuer_name);
          if (!v12)
          {
            v13 = v22;
            if (v22)
            {
LABEL_16:
              *(_QWORD *)(a1 + 192) = v25;
              v14 = v23;
              *(_DWORD *)(a1 + 208) = v24;
              *(_DWORD *)(a1 + 212) = v14;
              a = v13;
              v10 = v21;
              goto LABEL_18;
            }
          }
          get_crl_sk(a1, &v22, &v21, &v25, &v24, &v23, v12);
          sk_pop_free(v12, (void (__cdecl *)(void *))X509_CRL_free);
        }
        v13 = v22;
        if (!v22)
        {
          v10 = 0;
          goto LABEL_29;
        }
        goto LABEL_16;
      }
      v10 = 0;
      if (!v9(a1, &a, v7))
        goto LABEL_29;
LABEL_18:
      *(_QWORD *)(a1 + 200) = a;
      if (!(*(unsigned int (**)(uint64_t))(a1 + 104))(a1))
        goto LABEL_27;
      if (!v10)
        goto LABEL_23;
      if (!(*(unsigned int (**)(uint64_t, X509_CRL *))(a1 + 104))(a1, v10))
      {
LABEL_27:
        v16 = 0;
        goto LABEL_30;
      }
      v15 = (*(uint64_t (**)(uint64_t, X509_CRL *, char *))(a1 + 112))(a1, v10, v7);
      v16 = v15;
      if (v15 != 2)
      {
        if (!v15)
          goto LABEL_30;
LABEL_23:
        v16 = (*(uint64_t (**)(uint64_t, X509_CRL *, char *))(a1 + 112))(a1, a, v7);
        if (!v16)
          goto LABEL_30;
      }
      *(_QWORD *)(a1 + 200) = 0;
      X509_CRL_free(a);
      X509_CRL_free(v10);
      a = 0;
      v17 = *(_DWORD *)(a1 + 212);
      if (v8 == v17)
        break;
      v8 = *(_DWORD *)(a1 + 212);
      if (v17 == 32895)
      {
        v10 = 0;
        goto LABEL_30;
      }
    }
    v10 = 0;
LABEL_29:
    *(_DWORD *)(a1 + 176) = 3;
    v16 = (*(uint64_t (**)(_QWORD, uint64_t))(a1 + 64))(0, a1);
LABEL_30:
    *(_QWORD *)(a1 + 200) = 0;
    X509_CRL_free(a);
    X509_CRL_free(v10);
    if (v16)
    {
      if (v5++ == v3)
        return 1;
      continue;
    }
    return 0;
  }
}

uint64_t x509_vfy_check_policy(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int a5)
{
  uint64_t result;
  int v7;
  STACK policy_oids;

  *(_QWORD *)&policy_oids.num = 0;
  if (*(_QWORD *)(a1 + 216))
    return 1;
  v7 = X509_policy_check(*(X509_POLICY_TREE ***)(a1 + 160), *(int **)(*(_QWORD *)(a1 + 48) + 48), *(STACK **)(*(_QWORD *)(a1 + 48) + 24), &policy_oids, a5);
  if (v7)
  {
    *(_QWORD *)(a1 + 184) = *(_QWORD *)&policy_oids.num;
    *(_DWORD *)(a1 + 176) = v7;
    if (v7 == 17)
      return 0;
    else
      return (*(uint64_t (**)(_QWORD, uint64_t))(a1 + 64))(0, a1);
  }
  else
  {
    if ((*(_BYTE *)(*(_QWORD *)(a1 + 48) + 25) & 8) == 0)
      return 1;
    *(_QWORD *)(a1 + 184) = 0;
    result = (*(uint64_t (**)(uint64_t, uint64_t))(a1 + 64))(2, a1);
    if ((_DWORD)result)
      return 1;
  }
  return result;
}

uint64_t x509_check_cert_time(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v6;
  uint64_t v7;
  time_t v8;
  int *v9;
  time_t v10;
  BOOL v11;
  int v12;
  char v13;
  uint64_t result;
  int v15;
  int *v16;
  time_t v17;
  BOOL v18;
  int v19;
  int v20;
  int v21;

  v6 = *(_QWORD *)(a1 + 48);
  v7 = *(_QWORD *)(v6 + 24);
  if ((v7 & 2) != 0)
  {
    v8 = *(_QWORD *)(v6 + 8);
  }
  else
  {
    if ((v7 & 0x200000) != 0)
      return 1;
    v8 = time(0);
  }
  if ((*(_BYTE *)(a2 + 57) & 1) != 0)
  {
    v10 = *(_QWORD *)(a2 + 208);
    v11 = v8 == -1 || v10 == -1;
  }
  else
  {
    v9 = (int *)X509_getm_notBefore(a2);
    v10 = x509_verify_asn1_time_to_time_t(v9, 0);
    v11 = v10 == -1;
  }
  v12 = v11;
  if (v10 > v8)
    v13 = 1;
  else
    v13 = v12;
  if (a3 < 0 && (v13 & 1) != 0)
    return 0;
  if (v12)
  {
    *(_QWORD *)(a1 + 184) = a2;
    v15 = 13;
  }
  else
  {
    if (v10 <= v8)
      goto LABEL_24;
    *(_QWORD *)(a1 + 184) = a2;
    v15 = 9;
  }
  *(_DWORD *)(a1 + 172) = a3;
  *(_DWORD *)(a1 + 176) = v15;
  result = (*(uint64_t (**)(_QWORD, uint64_t))(a1 + 64))(0, a1);
  if (!(_DWORD)result)
    return result;
LABEL_24:
  if ((*(_BYTE *)(a2 + 57) & 1) != 0)
  {
    v17 = *(_QWORD *)(a2 + 216);
    v18 = v8 == -1 || v17 == -1;
  }
  else
  {
    v16 = (int *)X509_getm_notAfter(a2);
    v17 = x509_verify_asn1_time_to_time_t(v16, 1);
    v18 = v17 == -1;
  }
  v19 = v18;
  if (v17 > v8)
    v20 = 1;
  else
    v20 = -1;
  if (v19)
    v20 = 0;
  if ((a3 & 0x80000000) == 0 || (result = 0, v20 >= 1))
  {
    if (v19)
    {
      *(_QWORD *)(a1 + 184) = a2;
      v21 = 14;
      goto LABEL_43;
    }
    if (v20 < 0)
    {
      *(_QWORD *)(a1 + 184) = a2;
      v21 = 10;
LABEL_43:
      *(_DWORD *)(a1 + 172) = a3;
      *(_DWORD *)(a1 + 176) = v21;
      result = (*(uint64_t (**)(_QWORD, uint64_t))(a1 + 64))(0, a1);
      if (!(_DWORD)result)
        return result;
    }
    return 1;
  }
  return result;
}

int X509_cmp_time(ASN1_TIME *s, time_t *t)
{
  return X509_cmp_time_internal(&s->length, t, 0);
}

uint64_t X509_cmp_time_internal(int *a1, time_t *a2, int a3)
{
  time_t v5;
  time_t v6;
  unsigned int v7;

  if (a2)
    v5 = *a2;
  else
    v5 = time(0);
  v6 = x509_verify_asn1_time_to_time_t(a1, a3);
  if (v6 > v5)
    v7 = 1;
  else
    v7 = -1;
  if (v6 == -1)
    return 0;
  else
    return v7;
}

uint64_t x509_vfy_callback_indicate_completion(uint64_t a1)
{
  return x509_vfy_internal_verify(a1, 1);
}

uint64_t x509_vfy_internal_verify(uint64_t a1, int a2)
{
  int v4;
  int v5;
  char *v6;
  X509 *v7;
  uint64_t result;
  EVP_PKEY *pubkey;
  char *v10;
  int v11;
  char *v12;

  v4 = sk_num(*(const STACK **)(a1 + 160));
  v5 = v4 - 1;
  v6 = sk_value(*(const STACK **)(a1 + 160), v4 - 1);
  if ((*(unsigned int (**)(uint64_t, char *, char *))(a1 + 80))(a1, v6, v6))
  {
    v7 = (X509 *)v6;
    while ((v5 & 0x80000000) == 0)
    {
      if (!a2)
      {
        if (v6 != (char *)v7 || (*(_BYTE *)(*(_QWORD *)(a1 + 48) + 25) & 0x40) != 0)
        {
          pubkey = X509_get_pubkey(v7);
          if (pubkey)
          {
            if (X509_verify((X509 *)v6, pubkey) <= 0)
            {
              *(_DWORD *)(a1 + 172) = v5;
              v10 = v6;
              if (!v6)
                v10 = sk_value(*(const STACK **)(a1 + 160), v5);
              *(_QWORD *)(a1 + 184) = v10;
              *(_DWORD *)(a1 + 176) = 7;
              if (!(*(unsigned int (**)(_QWORD, uint64_t))(a1 + 64))(0, a1))
              {
                EVP_PKEY_free(pubkey);
                return 0;
              }
            }
          }
          else
          {
            if (v6 == (char *)v7)
              v11 = v5;
            else
              v11 = v5 + 1;
            *(_DWORD *)(a1 + 172) = v11;
            v12 = (char *)v7;
            if (!v7)
              v12 = sk_value(*(const STACK **)(a1 + 160), v11);
            *(_QWORD *)(a1 + 184) = v12;
            *(_DWORD *)(a1 + 176) = 6;
            result = (*(uint64_t (**)(_QWORD, uint64_t))(a1 + 64))(0, a1);
            if (!(_DWORD)result)
              return result;
          }
          EVP_PKEY_free(pubkey);
        }
        else
        {
          v6 = (char *)v7;
        }
LABEL_30:
        result = x509_check_cert_time(a1, (uint64_t)v6, v5);
        if (!(_DWORD)result)
          return result;
      }
LABEL_31:
      *(_QWORD *)(a1 + 184) = v6;
      *(_QWORD *)(a1 + 192) = v7;
      *(_DWORD *)(a1 + 172) = v5;
      result = (*(uint64_t (**)(uint64_t, uint64_t))(a1 + 64))(1, a1);
      if (!(_DWORD)result)
        return result;
      if (v5-- > 0)
      {
LABEL_11:
        v7 = (X509 *)v6;
        v6 = sk_value(*(const STACK **)(a1 + 160), v5);
      }
    }
    return 1;
  }
  else
  {
    if ((*(_BYTE *)(*(_QWORD *)(a1 + 48) + 26) & 8) != 0)
    {
      v7 = (X509 *)v6;
      if (a2)
        goto LABEL_31;
      goto LABEL_30;
    }
    if (v4 > 1)
    {
      v5 = v4 - 2;
      *(_DWORD *)(a1 + 172) = v4 - 2;
      goto LABEL_11;
    }
    *(_DWORD *)(a1 + 172) = 0;
    if (!v6)
      v6 = sk_value(*(const STACK **)(a1 + 160), 0);
    *(_QWORD *)(a1 + 184) = v6;
    *(_DWORD *)(a1 + 176) = 21;
    return (*(uint64_t (**)(_QWORD, uint64_t))(a1 + 64))(0, a1);
  }
}

int X509_cmp_current_time(ASN1_TIME *s)
{
  time_t v2;
  time_t v3;
  int v4;

  v2 = time(0);
  v3 = x509_verify_asn1_time_to_time_t(&s->length, 0);
  if (v3 > v2)
    v4 = 1;
  else
    v4 = -1;
  if (v3 == -1)
    return 0;
  else
    return v4;
}

ASN1_TIME *__cdecl X509_gmtime_adj(ASN1_TIME *s, uint64_t adj)
{
  time_t v4;

  v4 = time(0);
  return ASN1_TIME_adj(s, v4, 0, adj);
}

ASN1_TIME *__cdecl X509_time_adj(ASN1_TIME *s, uint64_t adj, time_t *t)
{
  return X509_time_adj_ex(s, 0, adj, t);
}

ASN1_TIME *X509_time_adj_ex(ASN1_TIME *a1, int a2, uint64_t a3, time_t *a4)
{
  time_t v7;

  if (a4)
    v7 = *a4;
  else
    v7 = time(0);
  return ASN1_TIME_adj(a1, v7, a2, a3);
}

int X509_get_pubkey_parameters(EVP_PKEY *pkey, STACK *chain)
{
  int v4;
  char *v5;
  EVP_PKEY *v6;
  const EVP_PKEY *v7;
  int v8;
  int v9;
  char *v10;
  EVP_PKEY *v11;
  BOOL v12;

  if (pkey && !EVP_PKEY_missing_parameters(pkey))
  {
LABEL_15:
    LODWORD(v11) = 1;
    return (int)v11;
  }
  if (sk_num(chain) < 1)
  {
LABEL_8:
    v8 = 107;
    v9 = 2049;
LABEL_17:
    ERR_put_error(11, 4095, v8, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_vfy.c", v9);
    LODWORD(v11) = 0;
  }
  else
  {
    v4 = 0;
    while (1)
    {
      v5 = sk_value(chain, v4);
      v6 = X509_get0_pubkey((uint64_t)v5);
      if (!v6)
      {
        v8 = 108;
        v9 = 2040;
        goto LABEL_17;
      }
      v7 = v6;
      if (!EVP_PKEY_missing_parameters(v6))
        break;
      if (++v4 >= sk_num(chain))
        goto LABEL_8;
    }
    while (1)
    {
      v12 = __OFSUB__(v4--, 1);
      if (v4 < 0 != v12)
        break;
      v10 = sk_value(chain, v4);
      v11 = X509_get0_pubkey((uint64_t)v10);
      if (v11)
      {
        LODWORD(v11) = EVP_PKEY_copy_parameters(v11, v7);
        if ((_DWORD)v11)
          continue;
      }
      return (int)v11;
    }
    if (!pkey)
      goto LABEL_15;
    LODWORD(v11) = EVP_PKEY_copy_parameters(pkey, v7);
    if ((_DWORD)v11)
      goto LABEL_15;
  }
  return (int)v11;
}

int X509_STORE_CTX_get_ex_new_index(uint64_t argl, void *argp, CRYPTO_EX_new *new_func, CRYPTO_EX_dup *dup_func, CRYPTO_EX_free *free_func)
{
  return CRYPTO_get_ex_new_index(5, argl, argp, new_func, dup_func, free_func);
}

int X509_STORE_CTX_set_ex_data(X509_STORE_CTX *ctx, int idx, void *data)
{
  return CRYPTO_set_ex_data((CRYPTO_EX_DATA *)&ctx[1].current_method, idx, data);
}

void *__cdecl X509_STORE_CTX_get_ex_data(X509_STORE_CTX *ctx, int idx)
{
  return CRYPTO_get_ex_data((const CRYPTO_EX_DATA *)&ctx[1].current_method, idx);
}

int X509_STORE_CTX_get_error(X509_STORE_CTX *ctx)
{
  return (int)ctx->current_cert;
}

void X509_STORE_CTX_set_error(X509_STORE_CTX *ctx, int s)
{
  LODWORD(ctx->current_cert) = s;
}

int X509_STORE_CTX_get_error_depth(X509_STORE_CTX *ctx)
{
  return *(&ctx->error + 1);
}

uint64_t X509_STORE_CTX_set_error_depth(uint64_t result, int a2)
{
  *(_DWORD *)(result + 172) = a2;
  return result;
}

X509 *__cdecl X509_STORE_CTX_get_current_cert(X509_STORE_CTX *ctx)
{
  return ctx->current_issuer;
}

uint64_t X509_STORE_CTX_set_current_cert(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 184) = a2;
  return result;
}

STACK *__cdecl X509_STORE_CTX_get_chain(X509_STORE_CTX *ctx)
{
  return *(STACK **)&ctx->explicit_policy;
}

uint64_t X509_STORE_CTX_get0_chain(uint64_t a1)
{
  return *(_QWORD *)(a1 + 160);
}

STACK *__cdecl X509_STORE_CTX_get1_chain(X509_STORE_CTX *ctx)
{
  STACK *v1;
  STACK *v2;
  STACK *v3;
  int v4;
  char *v5;

  v1 = *(STACK **)&ctx->explicit_policy;
  if (!v1)
    return 0;
  v2 = sk_dup(v1);
  v3 = v2;
  if (v2 && sk_num(v2) >= 1)
  {
    v4 = 0;
    do
    {
      v5 = sk_value(v3, v4);
      CRYPTO_add_lock((int *)v5 + 7, 1, 3, 0, 0);
      ++v4;
    }
    while (v4 < sk_num(v3));
  }
  return v3;
}

uint64_t X509_STORE_CTX_get0_current_issuer(uint64_t a1)
{
  return *(_QWORD *)(a1 + 192);
}

uint64_t X509_STORE_CTX_get0_current_crl(uint64_t a1)
{
  return *(_QWORD *)(a1 + 200);
}

uint64_t X509_STORE_CTX_get0_parent_ctx(uint64_t a1)
{
  return *(_QWORD *)(a1 + 216);
}

uint64_t X509_STORE_CTX_get0_store(uint64_t a1)
{
  return *(_QWORD *)a1;
}

void X509_STORE_CTX_set_cert(X509_STORE_CTX *c, X509 *x)
{
  c->cert = x;
}

void X509_STORE_CTX_set_chain(X509_STORE_CTX *c, STACK *sk)
{
  c->untrusted = sk;
}

void X509_STORE_CTX_set0_crls(X509_STORE_CTX *c, STACK *sk)
{
  c->param = (X509_VERIFY_PARAM *)sk;
}

int X509_STORE_CTX_set_purpose(X509_STORE_CTX *ctx, int purpose)
{
  return X509_STORE_CTX_purpose_inherit(ctx, 0, purpose, 0);
}

int X509_STORE_CTX_purpose_inherit(X509_STORE_CTX *ctx, int def_purpose, int purpose, int trust)
{
  int v6;
  int v8;
  X509_PURPOSE *v9;
  int v10;
  int v11;
  int v12;
  char v13;
  _DWORD *other_ctx;
  _DWORD *v15;

  if (purpose)
    v6 = purpose;
  else
    v6 = def_purpose;
  if (!v6)
  {
LABEL_13:
    if (!trust)
    {
      v13 = 1;
      if (!v6)
        goto LABEL_20;
LABEL_19:
      other_ctx = ctx->other_ctx;
      if (!other_ctx[8])
      {
        other_ctx[8] = v6;
        if ((v13 & 1) == 0)
        {
LABEL_21:
          v15 = ctx->other_ctx;
          if (!v15[9])
            v15[9] = trust;
        }
        return 1;
      }
LABEL_20:
      if ((v13 & 1) == 0)
        goto LABEL_21;
      return 1;
    }
    goto LABEL_14;
  }
  v8 = X509_PURPOSE_get_by_id(v6);
  if (v8 == -1)
  {
    v10 = 121;
    v11 = 2253;
    goto LABEL_26;
  }
  v9 = X509_PURPOSE_get0(v8);
  if (v9->trust == -1)
  {
    v12 = X509_PURPOSE_get_by_id(def_purpose);
    if (v12 == -1)
    {
      v10 = 121;
      v11 = 2260;
      goto LABEL_26;
    }
    v9 = X509_PURPOSE_get0(v12);
    if (trust)
      goto LABEL_14;
    goto LABEL_12;
  }
  if (!trust)
  {
LABEL_12:
    trust = v9->trust;
    goto LABEL_13;
  }
LABEL_14:
  if (X509_TRUST_get_by_id(trust) != -1)
  {
    v13 = 0;
    if (!v6)
      goto LABEL_20;
    goto LABEL_19;
  }
  v10 = 120;
  v11 = 2272;
LABEL_26:
  ERR_put_error(11, 4095, v10, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_vfy.c", v11);
  return 0;
}

int X509_STORE_CTX_set_trust(X509_STORE_CTX *ctx, int trust)
{
  return X509_STORE_CTX_purpose_inherit(ctx, 0, 0, trust);
}

X509_STORE_CTX *X509_STORE_CTX_new(void)
{
  X509_STORE_CTX *v0;

  v0 = (X509_STORE_CTX *)malloc_type_calloc(1uLL, 0xE8uLL, 0x10A0040B2C3A4BFuLL);
  if (!v0)
    ERR_put_error(11, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_vfy.c", 2292);
  return v0;
}

void X509_STORE_CTX_free(X509_STORE_CTX *ctx)
{
  if (ctx)
  {
    X509_STORE_CTX_cleanup(ctx);
    free(ctx);
  }
}

void X509_STORE_CTX_cleanup(X509_STORE_CTX *ctx)
{
  STACK *chain;
  X509_VERIFY_PARAM *other_ctx;
  STACK *v4;

  chain = ctx->chain;
  if (chain)
    ((void (*)(X509_STORE_CTX *))chain)(ctx);
  other_ctx = (X509_VERIFY_PARAM *)ctx->other_ctx;
  if (other_ctx)
  {
    if (!ctx[1].ctx)
      X509_VERIFY_PARAM_free(other_ctx);
    ctx->other_ctx = 0;
  }
  v4 = *(STACK **)&ctx->explicit_policy;
  if (v4)
  {
    sk_pop_free(v4, (void (__cdecl *)(void *))X509_free);
    *(_QWORD *)&ctx->explicit_policy = 0;
  }
  CRYPTO_free_ex_data(5, ctx, (CRYPTO_EX_DATA *)&ctx[1].current_method);
  *(_QWORD *)&ctx[1].current_method = 0;
}

int X509_STORE_CTX_init(X509_STORE_CTX *ctx, X509_STORE *store, X509 *x509, STACK *chain)
{
  X509_VERIFY_PARAM *param;
  int (__cdecl *verify)(X509_STORE_CTX *);
  int (__cdecl *verify_cb)(X509 **, X509_STORE_CTX *, X509 *);
  int (__cdecl *get_issuer)(X509_STORE_CTX *, X509 *, X509 *);
  int (__cdecl *check_issued)(X509_STORE_CTX *);
  int (__cdecl *get_crl)(X509_STORE_CTX *, X509_CRL *);
  int (__cdecl *check_crl)(X509_STORE_CTX *, X509_CRL *, X509 *);
  int (__cdecl *cert_crl)(X509_STORE_CTX *);
  void *cleanup;
  STACK *sk;
  X509_VERIFY_PARAM *v16;
  void **p_other_ctx;
  X509_VERIFY_PARAM *v18;
  X509_VERIFY_PARAM *v19;
  int v20;
  const X509_VERIFY_PARAM *v21;

  *(_OWORD *)&ctx->ctx = 0u;
  *(_OWORD *)&ctx->cert = 0u;
  *(_QWORD *)&ctx[1].current_method = 0;
  *(_OWORD *)&ctx->current_crl = 0u;
  *(_OWORD *)&ctx->ex_data.dummy = 0u;
  *(_OWORD *)&ctx->explicit_policy = 0u;
  *(_OWORD *)&ctx->current_cert = 0u;
  *(_OWORD *)&ctx->cleanup = 0u;
  *(_OWORD *)&ctx->chain = 0u;
  *(_OWORD *)&ctx->get_crl = 0u;
  *(_OWORD *)&ctx->cert_crl = 0u;
  *(_OWORD *)&ctx->verify_cb = 0u;
  *(_OWORD *)&ctx->check_issued = 0u;
  *(_OWORD *)&ctx->crls = 0u;
  *(_OWORD *)&ctx->other_ctx = 0u;
  LODWORD(ctx->current_cert) = 65;
  ctx->ctx = store;
  ctx->cert = x509;
  ctx->untrusted = chain;
  if (store)
  {
    param = store->param;
    if (!param)
      param = (X509_VERIFY_PARAM *)internal_verify;
    ctx->verify = (int (__cdecl *)(X509_STORE_CTX *))param;
    verify = store->verify;
    if (!verify)
      verify = (int (__cdecl *)(X509_STORE_CTX *))null_callback;
    ctx->verify_cb = (int (__cdecl *)(int, X509_STORE_CTX *))verify;
    verify_cb = (int (__cdecl *)(X509 **, X509_STORE_CTX *, X509 *))store->verify_cb;
    if (!verify_cb)
      verify_cb = X509_STORE_CTX_get1_issuer;
    ctx->get_issuer = verify_cb;
    get_issuer = (int (__cdecl *)(X509_STORE_CTX *, X509 *, X509 *))store->get_issuer;
    if (!get_issuer)
      get_issuer = (int (__cdecl *)(X509_STORE_CTX *, X509 *, X509 *))::check_issued;
    ctx->check_issued = get_issuer;
    check_issued = (int (__cdecl *)(X509_STORE_CTX *))store->check_issued;
    if (!check_issued)
      check_issued = (int (__cdecl *)(X509_STORE_CTX *))check_revocation;
    ctx->check_revocation = check_issued;
    ctx->get_crl = (int (__cdecl *)(X509_STORE_CTX *, X509_CRL **, X509 *))store->check_revocation;
    get_crl = (int (__cdecl *)(X509_STORE_CTX *, X509_CRL *))store->get_crl;
    if (!get_crl)
      get_crl = (int (__cdecl *)(X509_STORE_CTX *, X509_CRL *))::check_crl;
    ctx->check_crl = get_crl;
    check_crl = (int (__cdecl *)(X509_STORE_CTX *, X509_CRL *, X509 *))store->check_crl;
    if (!check_crl)
      check_crl = (int (__cdecl *)(X509_STORE_CTX *, X509_CRL *, X509 *))::cert_crl;
    ctx->cert_crl = check_crl;
    ctx->check_policy = (int (__cdecl *)(X509_STORE_CTX *))check_policy;
    cert_crl = (int (__cdecl *)(X509_STORE_CTX *))store->cert_crl;
    if (!cert_crl)
      cert_crl = (int (__cdecl *)(X509_STORE_CTX *))X509_STORE_CTX_get1_certs;
    ctx->cleanup = cert_crl;
    cleanup = store->cleanup;
    if (!cleanup)
      cleanup = X509_STORE_CTX_get1_crls;
    *(_QWORD *)&ctx->valid = cleanup;
    sk = store->ex_data.sk;
    if (sk)
    {
      ctx->chain = sk;
      v16 = X509_VERIFY_PARAM_new();
      ctx->other_ctx = v16;
      p_other_ctx = &ctx->other_ctx;
      if (v16)
      {
        v18 = v16;
        goto LABEL_26;
      }
LABEL_28:
      v20 = 2402;
      goto LABEL_35;
    }
  }
  else
  {
    ctx->verify = (int (__cdecl *)(X509_STORE_CTX *))internal_verify;
    ctx->verify_cb = (int (__cdecl *)(int, X509_STORE_CTX *))null_callback;
    ctx->get_issuer = X509_STORE_CTX_get1_issuer;
    ctx->check_issued = (int (__cdecl *)(X509_STORE_CTX *, X509 *, X509 *))::check_issued;
    ctx->check_crl = (int (__cdecl *)(X509_STORE_CTX *, X509_CRL *))::check_crl;
    ctx->cert_crl = (int (__cdecl *)(X509_STORE_CTX *, X509_CRL *, X509 *))::cert_crl;
    ctx->check_revocation = (int (__cdecl *)(X509_STORE_CTX *))check_revocation;
    ctx->get_crl = 0;
    ctx->check_policy = (int (__cdecl *)(X509_STORE_CTX *))check_policy;
    ctx->cleanup = (int (__cdecl *)(X509_STORE_CTX *))X509_STORE_CTX_get1_certs;
    *(_QWORD *)&ctx->valid = X509_STORE_CTX_get1_crls;
  }
  ctx->chain = 0;
  v19 = X509_VERIFY_PARAM_new();
  ctx->other_ctx = v19;
  p_other_ctx = &ctx->other_ctx;
  if (!v19)
    goto LABEL_28;
  v18 = v19;
  if (!store)
  {
    v19->inh_flags |= 0x11uLL;
    goto LABEL_30;
  }
LABEL_26:
  if (!X509_VERIFY_PARAM_inherit(v18, (const X509_VERIFY_PARAM *)store->get_cert_methods))
  {
LABEL_33:
    v20 = 2419;
    goto LABEL_35;
  }
  v18 = (X509_VERIFY_PARAM *)*p_other_ctx;
LABEL_30:
  v21 = X509_VERIFY_PARAM_lookup("default");
  if (!X509_VERIFY_PARAM_inherit(v18, v21))
    goto LABEL_33;
  if (CRYPTO_new_ex_data(5, ctx, (CRYPTO_EX_DATA *)&ctx[1].current_method))
    return 1;
  v20 = 2425;
LABEL_35:
  ERR_put_error(11, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_vfy.c", v20);
  return 0;
}

uint64_t internal_verify(uint64_t a1)
{
  return x509_vfy_internal_verify(a1, 0);
}

BOOL check_issued(int a1, X509 *a2, X509 *issuer)
{
  return X509_check_issued(issuer, a2) == 0;
}

uint64_t check_crl(uint64_t a1, uint64_t a2)
{
  int v4;
  int v5;
  char *v6;
  int v7;
  const STACK *v8;
  uint64_t v9;
  EVP_PKEY *pubkey;
  int v11;
  int v12;
  X509 *v13;
  X509_VERIFY_PARAM *v14;
  uint64_t v15;
  const STACK *v16;
  const STACK *v17;
  int v18;
  char *v19;
  int v20;
  char *v21;
  uint64_t v22;
  _OWORD v24[2];
  __int128 v25;
  X509_VERIFY_PARAM *param[2];
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  uint64_t v37;

  v4 = *(_DWORD *)(a1 + 172);
  v5 = sk_num(*(const STACK **)(a1 + 160));
  v6 = *(char **)(a1 + 192);
  if (!v6)
  {
    v7 = v5 - 1;
    v8 = *(const STACK **)(a1 + 160);
    if (v4 >= v7)
    {
      v6 = sk_value(v8, v7);
      v9 = (*(uint64_t (**)(uint64_t, char *, char *))(a1 + 80))(a1, v6, v6);
      if (!(_DWORD)v9)
      {
        *(_DWORD *)(a1 + 176) = 33;
        if (!(*(unsigned int (**)(uint64_t, uint64_t))(a1 + 64))(v9, a1))
          goto LABEL_34;
      }
    }
    else
    {
      v6 = sk_value(v8, v4 + 1);
    }
    if (!v6)
      goto LABEL_29;
  }
  if (*(_QWORD *)(a2 + 64))
    goto LABEL_8;
  if ((v6[56] & 2) != 0 && (v6[64] & 2) == 0)
  {
    *(_DWORD *)(a1 + 176) = 35;
    if (!(*(unsigned int (**)(_QWORD, uint64_t))(a1 + 64))(0, a1))
      goto LABEL_34;
  }
  v12 = *(_DWORD *)(a1 + 208);
  if ((v12 & 0x80) == 0)
  {
    *(_DWORD *)(a1 + 176) = 44;
    if (!(*(unsigned int (**)(_QWORD, uint64_t))(a1 + 64))(0, a1))
      goto LABEL_34;
    v12 = *(_DWORD *)(a1 + 208);
  }
  if ((v12 & 8) == 0)
  {
    if (!*(_QWORD *)(a1 + 216))
    {
      v13 = *(X509 **)(a1 + 192);
      v37 = 0;
      v35 = 0u;
      v36 = 0u;
      v33 = 0u;
      v34 = 0u;
      v31 = 0u;
      v32 = 0u;
      v29 = 0u;
      v30 = 0u;
      v27 = 0u;
      v28 = 0u;
      v25 = 0u;
      *(_OWORD *)param = 0u;
      memset(v24, 0, sizeof(v24));
      if (!X509_STORE_CTX_init((X509_STORE_CTX *)v24, *(X509_STORE **)a1, v13, *(STACK **)(a1 + 24)))
        goto LABEL_30;
      v14 = *(X509_VERIFY_PARAM **)(a1 + 48);
      *((_QWORD *)&v25 + 1) = *(_QWORD *)(a1 + 40);
      if (param[0])
        X509_VERIFY_PARAM_free(param[0]);
      *((_QWORD *)&v36 + 1) = a1;
      v15 = *(_QWORD *)(a1 + 64);
      param[0] = v14;
      *(_QWORD *)&v27 = v15;
      if (X509_verify_cert((X509_STORE_CTX *)v24) > 0)
      {
        v16 = *(const STACK **)(a1 + 160);
        v17 = (const STACK *)v33;
        v18 = sk_num(v16);
        v19 = sk_value(v16, v18 - 1);
        v20 = sk_num(v17);
        v21 = sk_value(v17, v20 - 1);
        LODWORD(v19) = X509_cmp((const X509 *)v19, (const X509 *)v21);
        X509_STORE_CTX_cleanup((X509_STORE_CTX *)v24);
        if (!(_DWORD)v19)
          goto LABEL_32;
      }
      else
      {
LABEL_30:
        X509_STORE_CTX_cleanup((X509_STORE_CTX *)v24);
      }
    }
    *(_DWORD *)(a1 + 176) = 54;
    if (!(*(unsigned int (**)(_QWORD, uint64_t))(a1 + 64))(0, a1))
    {
LABEL_34:
      v6 = 0;
      goto LABEL_35;
    }
  }
LABEL_32:
  if ((*(_BYTE *)(a2 + 48) & 2) != 0)
  {
    *(_DWORD *)(a1 + 176) = 41;
    if (!(*(unsigned int (**)(_QWORD, uint64_t))(a1 + 64))(0, a1))
      goto LABEL_34;
  }
LABEL_8:
  if ((*(_BYTE *)(a1 + 208) & 0x40) == 0 && !check_crl_time(a1, a2, 1))
    goto LABEL_34;
  pubkey = X509_get_pubkey((X509 *)v6);
  v6 = (char *)pubkey;
  if (!pubkey)
  {
    *(_DWORD *)(a1 + 176) = 6;
    v11 = (*(uint64_t (**)(_QWORD, uint64_t))(a1 + 64))(0, a1);
LABEL_28:
    if (v11)
      goto LABEL_29;
LABEL_35:
    v22 = 0;
    goto LABEL_36;
  }
  if (X509_CRL_verify((X509_CRL *)a2, pubkey) <= 0)
  {
    *(_DWORD *)(a1 + 176) = 8;
    v11 = (*(uint64_t (**)(_QWORD, uint64_t))(a1 + 64))(0, a1);
    goto LABEL_28;
  }
LABEL_29:
  v22 = 1;
LABEL_36:
  EVP_PKEY_free((EVP_PKEY *)v6);
  return v22;
}

uint64_t cert_crl(uint64_t a1, uint64_t a2, X509 *x)
{
  uint64_t result;
  uint64_t v7;

  if ((*(_BYTE *)(*(_QWORD *)(a1 + 48) + 24) & 0x10) != 0
    || (*(_BYTE *)(a2 + 29) & 2) == 0
    || (*(_DWORD *)(a1 + 176) = 36,
        result = (*(uint64_t (**)(_QWORD, uint64_t))(a1 + 64))(0, a1),
        (_DWORD)result))
  {
    v7 = 0;
    if (!X509_CRL_get0_by_cert(a2, (uint64_t)&v7, x))
      return 1;
    if (*(_DWORD *)(v7 + 32) == 8)
      return 2;
    *(_DWORD *)(a1 + 176) = 23;
    result = (*(uint64_t (**)(_QWORD, uint64_t))(a1 + 64))(0, a1);
    if ((_DWORD)result)
      return 1;
  }
  return result;
}

void X509_STORE_CTX_trusted_stack(X509_STORE_CTX *ctx, STACK *sk)
{
  ctx->crls = sk;
  ctx->get_issuer = (int (__cdecl *)(X509 **, X509_STORE_CTX *, X509 *))get_trusted_issuer;
}

uint64_t X509_STORE_CTX_set0_trusted_stack(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 32) = a2;
  *(_QWORD *)(result + 72) = get_trusted_issuer;
  return result;
}

uint64_t get_trusted_issuer(char **a1, uint64_t a2, uint64_t a3)
{
  char *issuer;
  uint64_t v5;

  issuer = find_issuer(a2, *(STACK **)(a2 + 32), a3, 1);
  *a1 = issuer;
  if (!issuer)
    return 0;
  v5 = 1;
  CRYPTO_add_lock((int *)issuer + 7, 1, 3, 0, 0);
  return v5;
}

void X509_STORE_CTX_set_depth(X509_STORE_CTX *ctx, int depth)
{
  X509_VERIFY_PARAM_set_depth((X509_VERIFY_PARAM *)ctx->other_ctx, depth);
}

void X509_STORE_CTX_set_flags(X509_STORE_CTX *ctx, unint64_t flags)
{
  X509_VERIFY_PARAM_set_flags((X509_VERIFY_PARAM *)ctx->other_ctx, flags);
}

void X509_STORE_CTX_set_time(X509_STORE_CTX *ctx, unint64_t flags, time_t t)
{
  X509_VERIFY_PARAM_set_time((X509_VERIFY_PARAM *)ctx->other_ctx, t);
}

uint64_t X509_STORE_CTX_get_verify_cb(uint64_t a1)
{
  return *(_QWORD *)(a1 + 64);
}

void X509_STORE_CTX_set_verify_cb(X509_STORE_CTX *ctx, int (__cdecl *verify_cb)(int, X509_STORE_CTX *))
{
  ctx->verify_cb = verify_cb;
}

uint64_t X509_STORE_CTX_get_verify(uint64_t a1)
{
  return *(_QWORD *)(a1 + 56);
}

uint64_t X509_STORE_CTX_set_verify(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 56) = a2;
  return result;
}

uint64_t X509_STORE_get_check_issued(uint64_t a1)
{
  return *(_QWORD *)(a1 + 48);
}

uint64_t X509_STORE_set_check_issued(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 48) = a2;
  return result;
}

uint64_t X509_STORE_CTX_get_check_issued(uint64_t a1)
{
  return *(_QWORD *)(a1 + 80);
}

uint64_t X509_STORE_CTX_get0_cert(uint64_t a1)
{
  return *(_QWORD *)(a1 + 16);
}

uint64_t X509_STORE_CTX_get0_untrusted(uint64_t a1)
{
  return *(_QWORD *)(a1 + 24);
}

uint64_t X509_STORE_CTX_set0_untrusted(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 24) = a2;
  return result;
}

void X509_STORE_CTX_set0_verified_chain(uint64_t a1, uint64_t a2)
{
  sk_pop_free(*(STACK **)(a1 + 160), (void (__cdecl *)(void *))X509_free);
  *(_QWORD *)(a1 + 160) = a2;
}

uint64_t X509_STORE_CTX_get_num_untrusted(uint64_t a1)
{
  return *(unsigned int *)(a1 + 156);
}

int X509_STORE_CTX_set_default(X509_STORE_CTX *ctx, const char *name)
{
  const X509_VERIFY_PARAM *v3;

  v3 = X509_VERIFY_PARAM_lookup(name);
  if (v3)
    LODWORD(v3) = X509_VERIFY_PARAM_inherit((X509_VERIFY_PARAM *)ctx->other_ctx, v3);
  return (int)v3;
}

X509_VERIFY_PARAM *__cdecl X509_STORE_CTX_get0_param(X509_STORE_CTX *ctx)
{
  return (X509_VERIFY_PARAM *)ctx->other_ctx;
}

void X509_STORE_CTX_set0_param(X509_STORE_CTX *ctx, X509_VERIFY_PARAM *param)
{
  X509_VERIFY_PARAM *other_ctx;

  other_ctx = (X509_VERIFY_PARAM *)ctx->other_ctx;
  if (other_ctx)
    X509_VERIFY_PARAM_free(other_ctx);
  ctx->other_ctx = param;
}

uint64_t x509_vfy_check_security_level(uint64_t a1)
{
  int v2;
  uint64_t result;
  int v5;
  int v6;
  char *v7;
  char *v8;
  int signature_nid;
  const char *v10;
  const EVP_MD *digestbyname;
  int v12;
  int n;

  v2 = sk_num(*(const STACK **)(a1 + 160));
  if (*(int *)(*(_QWORD *)(a1 + 48) + 44) < 1 || v2 < 1)
    return 1;
  v5 = 0;
  v6 = v2 - 1;
  while (1)
  {
    v7 = sk_value(*(const STACK **)(a1 + 160), v5);
    if (v5 && !check_key_level(a1, (uint64_t)v7))
    {
      *(_DWORD *)(a1 + 172) = v5;
      v8 = v7;
      if (!v7)
        v8 = sk_value(*(const STACK **)(a1 + 160), v5);
      *(_QWORD *)(a1 + 184) = v8;
      *(_DWORD *)(a1 + 176) = 68;
      result = (*(uint64_t (**)(_QWORD, uint64_t))(a1 + 64))(0, a1);
      if (!(_DWORD)result)
        break;
    }
    if (v6 == v5)
      return 1;
    signature_nid = X509_get_signature_nid((uint64_t)v7);
    if (!signature_nid
      || (n = 0, !OBJ_find_sigid_algs(signature_nid, &n, 0))
      || !n
      || (v10 = OBJ_nid2sn(n), (digestbyname = EVP_get_digestbyname(v10)) == 0)
      || (v12 = EVP_MD_size(digestbyname),
          !enough_bits_for_security_level(4 * v12, *(_DWORD *)(*(_QWORD *)(a1 + 48) + 44))))
    {
      *(_DWORD *)(a1 + 172) = v5;
      if (!v7)
        v7 = sk_value(*(const STACK **)(a1 + 160), v5);
      *(_QWORD *)(a1 + 184) = v7;
      *(_DWORD *)(a1 + 176) = 69;
      result = (*(uint64_t (**)(_QWORD, uint64_t))(a1 + 64))(0, a1);
      if (!(_DWORD)result)
        break;
    }
    ++v5;
  }
  return result;
}

char *find_issuer(uint64_t a1, STACK *a2, uint64_t a3, int a4)
{
  char *v8;
  int v9;
  char *v10;

  if (sk_num(a2) < 1)
    return 0;
  v8 = 0;
  v9 = 0;
  do
  {
    v10 = sk_value(a2, v9);
    if ((*(unsigned int (**)(uint64_t, uint64_t, char *))(a1 + 80))(a1, a3, v10))
    {
      if (x509_check_cert_time(a1, (uint64_t)v10, -1))
        return v10;
      if (a4)
        v8 = v10;
    }
    ++v9;
    v10 = v8;
  }
  while (v9 < sk_num(a2));
  return v10;
}

BOOL get_crl_sk(uint64_t a1, X509_CRL **a2, X509_CRL **a3, char **a4, int *a5, _DWORD *a6, STACK *a7)
{
  const STACK *v7;
  int v13;
  char *v14;
  uint64_t v15;
  int v16;
  int v17;
  char *v18;
  uint64_t v19;
  char *v20;
  uint64_t v21;
  int v22;
  int v23;
  X509_NAME *issuer_name;
  const X509_NAME *issuer;
  int v26;
  int v27;
  int v28;
  const X509_NAME *v29;
  int v30;
  char *v31;
  int v32;
  uint64_t v33;
  char *v34;
  X509_NAME *v35;
  int v36;
  uint64_t v37;
  X509_NAME *subject_name;
  int v39;
  int v40;
  char *v41;
  const X509_NAME *v42;
  const STACK *v43;
  int v44;
  char *v45;
  uint64_t *v46;
  uint64_t v47;
  const X509_NAME *v48;
  int v49;
  char *v50;
  const STACK *v51;
  int v52;
  char *v53;
  _QWORD *v54;
  int v55;
  int v56;
  char *v57;
  uint64_t v58;
  const X509_NAME *v59;
  const X509_NAME *v60;
  int v62;
  int v63;
  X509_CRL **v64;
  char **v65;
  int *v66;
  X509_CRL **v67;
  uint64_t v68;
  X509_NAME *a;
  char *aa;
  _DWORD *v71;
  const STACK *v72;
  int v73;
  int v74;
  uint64_t v75;
  char *v76;
  char *v77;
  int v78;

  v7 = a7;
  v13 = *a5;
  v75 = *(_QWORD *)(a1 + 184);
  if (sk_num(a7) < 1)
    return v13 > 447;
  v66 = a5;
  v67 = a3;
  v64 = a2;
  v65 = a4;
  v14 = 0;
  v15 = 0;
  v16 = 0;
  v17 = 0;
  v18 = 0;
  v71 = a6;
  v72 = v7;
  v19 = v75;
  do
  {
    v20 = sk_value(v7, v17);
    v21 = (uint64_t)v20;
    v22 = *a6;
    v23 = *((_DWORD *)v20 + 12);
    if ((v23 & 2) != 0)
      goto LABEL_25;
    if ((*(_BYTE *)(*(_QWORD *)(a1 + 48) + 25) & 0x10) != 0)
    {
      if ((v23 & 0x40) != 0)
      {
        if ((*((_DWORD *)v20 + 13) & ~v22) == 0)
          goto LABEL_25;
      }
      else if (*((_QWORD *)v20 + 8))
      {
        goto LABEL_25;
      }
    }
    else if ((v23 & 0x60) != 0)
    {
      goto LABEL_25;
    }
    v78 = *a6;
    v76 = v18;
    issuer_name = X509_get_issuer_name((X509 *)v19);
    issuer = (const X509_NAME *)X509_CRL_get_issuer(v21);
    if (X509_NAME_cmp(issuer_name, issuer))
    {
      v26 = 0;
      if ((*(_BYTE *)(v21 + 48) & 0x20) == 0)
      {
        v18 = v76;
        v22 = v78;
        goto LABEL_26;
      }
    }
    else
    {
      v26 = 32;
    }
    v27 = ((*(_DWORD *)(v21 + 28) >> 1) & 0x100 | v26) ^ 0x100;
    if (check_crl_time(a1, v21, 0))
      v28 = v27 | 0x40;
    else
      v28 = v27;
    v29 = (const X509_NAME *)X509_CRL_get_issuer(v21);
    v30 = *(_DWORD *)(a1 + 172);
    if (v30 != sk_num(*(const STACK **)(a1 + 160)) - 1)
      ++v30;
    v31 = sk_value(*(const STACK **)(a1 + 160), v30);
    if (!X509_check_akid((X509 *)v31, *(_QWORD *)(v21 + 32)) && (v28 & 0x20) != 0)
    {
      v26 = v28 | 0x1C;
      goto LABEL_23;
    }
    v73 = v28;
    v32 = v30 + 1;
    v33 = a1;
    while (1)
    {
      if (v32 >= sk_num(*(const STACK **)(a1 + 160)))
      {
        v19 = v75;
        if ((*(_BYTE *)(*(_QWORD *)(a1 + 48) + 25) & 0x10) == 0 || sk_num(*(const STACK **)(a1 + 24)) < 1)
        {
          a6 = v71;
          v7 = v72;
LABEL_43:
          v18 = v76;
          v22 = v78;
          v26 = v73;
          if ((v73 & 4) == 0)
            goto LABEL_25;
          goto LABEL_44;
        }
        v36 = 0;
        while (1)
        {
          v37 = v33;
          v31 = sk_value(*(const STACK **)(v33 + 24), v36);
          subject_name = X509_get_subject_name((X509 *)v31);
          if (!X509_NAME_cmp(subject_name, v29) && !X509_check_akid((X509 *)v31, *(_QWORD *)(v21 + 32)))
            break;
          ++v36;
          v33 = v37;
          if (v36 >= sk_num(*(const STACK **)(v37 + 24)))
          {
            a6 = v71;
            v7 = v72;
            v19 = v75;
            goto LABEL_43;
          }
        }
        v26 = v73 | 4;
LABEL_23:
        v18 = v31;
        goto LABEL_24;
      }
      v34 = sk_value(*(const STACK **)(a1 + 160), v32);
      v35 = X509_get_subject_name((X509 *)v34);
      if (!X509_NAME_cmp(v35, v29) && !X509_check_akid((X509 *)v34, *(_QWORD *)(v21 + 32)))
        break;
      ++v32;
    }
    v26 = v73 | 0xC;
    v18 = v34;
LABEL_24:
    a6 = v71;
    v7 = v72;
    v19 = v75;
    v22 = v78;
    if ((v26 & 4) == 0)
    {
LABEL_25:
      v26 = 0;
      goto LABEL_26;
    }
LABEL_44:
    v39 = *(_DWORD *)(v21 + 48);
    if ((v39 & 0x10) != 0)
      goto LABEL_26;
    if ((*(_BYTE *)(v19 + 56) & 0x10) != 0)
    {
      if ((v39 & 4) != 0)
        goto LABEL_26;
    }
    else if ((v39 & 8) != 0)
    {
      goto LABEL_26;
    }
    v74 = v26;
    v77 = v18;
    v62 = *(_DWORD *)(v21 + 52);
    if (sk_num(*(const STACK **)(v19 + 104)) >= 1)
    {
      v40 = 0;
      while (1)
      {
        v41 = sk_value(*(const STACK **)(v19 + 104), v40);
        v42 = (const X509_NAME *)X509_CRL_get_issuer(v21);
        v43 = (const STACK *)*((_QWORD *)v41 + 2);
        if (v43)
        {
          if (sk_num(v43) < 1)
            goto LABEL_85;
          v44 = 0;
          while (1)
          {
            v45 = sk_value(*((const STACK **)v41 + 2), v44);
            if (*(_DWORD *)v45 == 4 && !X509_NAME_cmp(*((const X509_NAME **)v45 + 1), v42))
              break;
            if (++v44 >= sk_num(*((const STACK **)v41 + 2)))
              goto LABEL_85;
          }
        }
        else if ((v74 & 0x20) == 0)
        {
          goto LABEL_85;
        }
        v46 = *(uint64_t **)(v21 + 40);
        if (!v46)
          goto LABEL_91;
        v68 = *(_QWORD *)v41;
        if (!*(_QWORD *)v41)
          goto LABEL_91;
        v47 = *v46;
        if (!*v46)
          goto LABEL_91;
        if (*(_DWORD *)v68 == 1)
          break;
        if (*(_DWORD *)v47 == 1)
        {
          a = *(X509_NAME **)(v47 + 16);
          if (!a)
            goto LABEL_85;
LABEL_80:
          v51 = *(const STACK **)(v68 + 8);
          if (sk_num(v51) >= 1)
          {
            v52 = 0;
            while (1)
            {
              v53 = sk_value(v51, v52);
              if (*(_DWORD *)v53 == 4 && !X509_NAME_cmp(a, *((const X509_NAME **)v53 + 1)))
                goto LABEL_91;
              if (++v52 >= sk_num(v51))
                goto LABEL_85;
            }
          }
          goto LABEL_85;
        }
        if (sk_num(*(const STACK **)(v68 + 8)) >= 1)
        {
          v63 = 0;
          while (1)
          {
            aa = sk_value(*(const STACK **)(v68 + 8), v63);
            if (sk_num(*(const STACK **)(v47 + 8)) >= 1)
              break;
LABEL_77:
            if (++v63 >= sk_num(*(const STACK **)(v68 + 8)))
              goto LABEL_85;
          }
          v49 = 0;
          while (1)
          {
            v50 = sk_value(*(const STACK **)(v47 + 8), v49);
            if (!GENERAL_NAME_cmp((uint64_t)aa, (uint64_t)v50))
              break;
            if (++v49 >= sk_num(*(const STACK **)(v47 + 8)))
              goto LABEL_77;
          }
LABEL_91:
          v55 = *((_DWORD *)v41 + 6) & v62;
          a6 = v71;
          v7 = v72;
          v19 = v75;
          v18 = v77;
          v22 = v78;
          v26 = v74;
LABEL_92:
          if ((v55 & ~v22) != 0)
          {
            v22 |= v55;
            v26 |= 0x80u;
          }
          else
          {
            v26 = 0;
          }
          goto LABEL_26;
        }
LABEL_85:
        ++v40;
        v19 = v75;
        if (v40 >= sk_num(*(const STACK **)(v75 + 104)))
          goto LABEL_86;
      }
      a = *(X509_NAME **)(v68 + 16);
      if (!a)
        goto LABEL_85;
      if (*(_DWORD *)v47 == 1)
      {
        v48 = *(const X509_NAME **)(v47 + 16);
        if (v48 && !X509_NAME_cmp(a, v48))
          goto LABEL_91;
        goto LABEL_85;
      }
      v68 = *v46;
      goto LABEL_80;
    }
LABEL_86:
    v54 = *(_QWORD **)(v21 + 40);
    v22 = v78;
    if (v54)
    {
      a6 = v71;
      v7 = v72;
      v18 = v77;
      v26 = v74;
      v55 = v62;
      if ((v74 & 0x20) != 0 && !*v54)
        goto LABEL_92;
    }
    else
    {
      a6 = v71;
      v7 = v72;
      v18 = v77;
      v26 = v74;
      v55 = v62;
      if ((v74 & 0x20) != 0)
        goto LABEL_92;
    }
LABEL_26:
    if (v26 > v13)
    {
      v13 = v26;
      v16 = v22;
      v15 = v21;
      v14 = v18;
    }
    ++v17;
  }
  while (v17 < sk_num(v7));
  if (v15)
  {
    if (*v64)
      X509_CRL_free(*v64);
    *v64 = (X509_CRL *)v15;
    *v65 = v14;
    *v66 = v13;
    *a6 = v16;
    CRYPTO_add_lock((int *)(v15 + 24), 1, 6, 0, 0);
    if (*v67)
    {
      X509_CRL_free(*v67);
      *v67 = 0;
    }
    if ((*(_BYTE *)(*(_QWORD *)(a1 + 48) + 25) & 0x20) != 0
      && ((*(_DWORD *)(*(_QWORD *)(a1 + 184) + 56) | *(_DWORD *)(v15 + 28)) & 0x1000) != 0)
    {
      if (sk_num(v7) < 1)
      {
LABEL_119:
        v58 = 0;
      }
      else
      {
        v56 = 0;
        while (1)
        {
          v57 = sk_value(v7, v56);
          if (*((_QWORD *)v57 + 8))
          {
            if (*(_QWORD *)(v15 + 56))
            {
              v58 = (uint64_t)v57;
              v59 = (const X509_NAME *)X509_CRL_get_issuer(v15);
              v60 = (const X509_NAME *)X509_CRL_get_issuer(v58);
              if (!X509_NAME_cmp(v59, v60)
                && crl_extension_match((X509_CRL *)v58, (X509_CRL *)v15, 90)
                && crl_extension_match((X509_CRL *)v58, (X509_CRL *)v15, 770)
                && ASN1_INTEGER_cmp(*(ASN1_INTEGER **)(v58 + 64), *(ASN1_INTEGER **)(v15 + 56)) <= 0
                && ASN1_INTEGER_cmp(*(ASN1_INTEGER **)(v58 + 56), *(ASN1_INTEGER **)(v15 + 56)) >= 1)
              {
                break;
              }
            }
          }
          if (++v56 >= sk_num(v7))
            goto LABEL_119;
        }
        if (check_crl_time(a1, v58, 0))
          *v66 |= 2u;
        CRYPTO_add_lock((int *)(v58 + 24), 1, 6, 0, 0);
      }
      *v67 = (X509_CRL *)v58;
    }
  }
  return v13 > 447;
}

uint64_t check_crl_time(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v6;
  uint64_t v7;
  time_t *v8;
  int *lastUpdate;
  int v10;
  int v11;
  uint64_t result;
  int *nextUpdate;
  int v14;
  int v15;

  if (a3)
    *(_QWORD *)(a1 + 200) = a2;
  v6 = *(_QWORD *)(a1 + 48);
  v7 = *(_QWORD *)(v6 + 24);
  if ((v7 & 2) != 0)
  {
    v8 = (time_t *)(v6 + 8);
  }
  else
  {
    if ((v7 & 0x200000) != 0)
      return 1;
    v8 = 0;
  }
  lastUpdate = (int *)X509_CRL_get_lastUpdate(a2);
  v10 = X509_cmp_time_internal(lastUpdate, v8, 0);
  if (v10)
  {
    if (v10 < 1)
      goto LABEL_14;
    if (!a3)
      return 0;
    v11 = 11;
  }
  else
  {
    if (!a3)
      return 0;
    v11 = 15;
  }
  *(_DWORD *)(a1 + 176) = v11;
  result = (*(uint64_t (**)(_QWORD, uint64_t))(a1 + 64))(0, a1);
  if (!(_DWORD)result)
    return result;
LABEL_14:
  if (!X509_CRL_get_nextUpdate(a2))
    goto LABEL_20;
  nextUpdate = (int *)X509_CRL_get_nextUpdate(a2);
  v14 = X509_cmp_time_internal(nextUpdate, v8, 0);
  if (v14)
  {
    if (v14 < 0 && (*(_BYTE *)(a1 + 208) & 2) == 0)
    {
      if (a3)
      {
        v15 = 12;
        goto LABEL_24;
      }
      return 0;
    }
LABEL_20:
    if (!a3)
      return 1;
    goto LABEL_25;
  }
  if (a3)
  {
    v15 = 16;
LABEL_24:
    *(_DWORD *)(a1 + 176) = v15;
    result = (*(uint64_t (**)(_QWORD, uint64_t))(a1 + 64))(0, a1);
    if (!(_DWORD)result)
      return result;
LABEL_25:
    *(_QWORD *)(a1 + 200) = 0;
    return 1;
  }
  return 0;
}

BOOL crl_extension_match(X509_CRL *a1, X509_CRL *a2, int nid)
{
  int ext_by_NID;
  int v7;
  X509_EXTENSION *ext;
  ASN1_OCTET_STRING *data;
  int v10;
  int v11;
  _BOOL8 result;
  ASN1_OCTET_STRING *v13;
  X509_EXTENSION *v14;

  ext_by_NID = X509_CRL_get_ext_by_NID(a1, nid, -1);
  if (ext_by_NID < 0)
  {
    data = 0;
  }
  else
  {
    v7 = ext_by_NID;
    if (X509_CRL_get_ext_by_NID(a1, nid, ext_by_NID) != -1)
      return 0;
    ext = X509_CRL_get_ext(a1, v7);
    data = X509_EXTENSION_get_data(ext);
  }
  v10 = X509_CRL_get_ext_by_NID(a2, nid, -1);
  if (v10 < 0)
  {
    v13 = 0;
  }
  else
  {
    v11 = v10;
    if (X509_CRL_get_ext_by_NID(a2, nid, v10) != -1)
      return 0;
    v14 = X509_CRL_get_ext(a2, v11);
    v13 = X509_EXTENSION_get_data(v14);
  }
  if (!((unint64_t)data | (unint64_t)v13))
    return 1;
  result = 0;
  if (data)
  {
    if (v13)
      return ASN1_OCTET_STRING_cmp(data, v13) == 0;
  }
  return result;
}

uint64_t enough_bits_for_security_level(int a1, int a2)
{
  unsigned int v2;
  uint64_t result;
  BOOL v5;
  BOOL v6;
  BOOL v7;

  v2 = a2 & ~(a2 >> 31);
  if (v2 >= 5)
    v2 = 5;
  result = 1;
  switch(v2)
  {
    case 0u:
      return result;
    case 1u:
      v7 = __OFSUB__(a1, 79);
      v5 = a1 == 79;
      v6 = a1 - 79 < 0;
      goto LABEL_10;
    case 2u:
      v7 = __OFSUB__(a1, 111);
      v5 = a1 == 111;
      v6 = a1 - 111 < 0;
      goto LABEL_10;
    case 3u:
      v7 = __OFSUB__(a1, 127);
      v5 = a1 == 127;
      v6 = a1 - 127 < 0;
      goto LABEL_10;
    case 4u:
      v7 = __OFSUB__(a1, 191);
      v5 = a1 == 191;
      v6 = a1 - 191 < 0;
      goto LABEL_10;
    case 5u:
      v7 = __OFSUB__(a1, 255);
      v5 = a1 == 255;
      v6 = a1 - 255 < 0;
LABEL_10:
      if (v6 ^ v7 | v5)
        result = 0;
      else
        result = 1;
      break;
    default:
      result = 0;
      break;
  }
  return result;
}

X509_EXTENSION *__cdecl X509V3_EXT_nconf(CONF *conf, X509V3_CTX *ctx, char *name, char *value)
{
  int v7;
  int v8;
  X509_EXTENSION *result;
  int v10;
  const char *v11;
  char *v12;

  v12 = value;
  v7 = v3_check_critical((const char **)&v12);
  v8 = v3_check_generic((const char **)&v12);
  if (v8)
    return v3_generic_extension(name, v12, v7, v8, ctx);
  v10 = OBJ_sn2nid(name);
  v11 = v12;
  result = do_ext_nconf(conf, (uint64_t)ctx, v10, v7, v12);
  if (!result)
  {
    ERR_put_error(34, 4095, 128, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_conf.c", 102);
    ERR_asprintf_error_data("name=%s, value=%s", name, v11);
    return 0;
  }
  return result;
}

uint64_t v3_check_critical(const char **a1)
{
  const char *v2;
  const char *v4;
  uint64_t v5;
  uint64_t v6;
  int v7;

  v2 = *a1;
  if (strlen(*a1) < 9 || strncmp(v2, "critical,", 9uLL))
    return 0;
  v4 = v2 + 8;
  v5 = MEMORY[0x24BDAC740];
  do
  {
    v6 = *((unsigned __int8 *)v4 + 1);
    if (v4[1] < 0)
      v7 = __maskrune(v6, 0x4000uLL);
    else
      v7 = *(_DWORD *)(v5 + 4 * v6 + 60) & 0x4000;
    ++v4;
  }
  while (v7);
  *a1 = v4;
  return 1;
}

uint64_t v3_check_generic(const char **a1)
{
  const char *v2;
  size_t v3;
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;

  v2 = *a1;
  v3 = strlen(*a1);
  if (v3 < 4)
    return 0;
  v4 = v3;
  v5 = 4;
  if (!strncmp(v2, "DER:", 4uLL))
  {
    v6 = 1;
  }
  else
  {
    if (v4 < 5)
      return 0;
    v5 = 5;
    if (strncmp(v2, "ASN1:", 5uLL))
      return 0;
    v6 = 2;
  }
  v7 = (uint64_t)&v2[v5 - 1];
  v8 = MEMORY[0x24BDAC740];
  do
  {
    v9 = *(unsigned __int8 *)(v7 + 1);
    if (*(char *)(v7 + 1) < 0)
      v10 = __maskrune(v9, 0x4000uLL);
    else
      v10 = *(_DWORD *)(v8 + 4 * v9 + 60) & 0x4000;
    ++v7;
  }
  while (v10);
  *a1 = (const char *)v7;
  return v6;
}

X509_EXTENSION *v3_generic_extension(const char *a1, char *a2, int a3, int a4, X509V3_CTX *a5)
{
  ASN1_OBJECT *v9;
  unsigned __int8 *v10;
  ASN1_TYPE *v11;
  ASN1_OCTET_STRING *v12;
  ASN1_OCTET_STRING *v13;
  X509_EXTENSION *v14;
  uint64_t len;
  unsigned __int8 *out;

  len = 0;
  v9 = OBJ_txt2obj(a1, 0);
  if (!v9)
  {
    ERR_put_error(34, 4095, 115, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_conf.c", 293);
    ERR_asprintf_error_data("name=%s");
    goto LABEL_12;
  }
  if (a4 != 2)
  {
    if (a4 == 1)
    {
      v10 = string_to_hex(a2, &len);
      goto LABEL_8;
    }
    ERR_asprintf_error_data("Unexpected generic extension type %d");
LABEL_12:
    v10 = 0;
LABEL_14:
    v13 = 0;
LABEL_15:
    v14 = 0;
    goto LABEL_16;
  }
  out = 0;
  v11 = ASN1_generate_v3(a2, a5);
  v10 = (unsigned __int8 *)v11;
  if (v11)
  {
    len = i2d_ASN1_TYPE(v11, &out);
    ASN1_TYPE_free((ASN1_TYPE *)v10);
    v10 = out;
  }
LABEL_8:
  if (!v10)
  {
    ERR_put_error(34, 4095, 116, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_conf.c", 308);
    ERR_asprintf_error_data("value=%s", a2);
    goto LABEL_14;
  }
  v12 = ASN1_OCTET_STRING_new();
  v13 = v12;
  if (!v12)
  {
    ERR_put_error(34, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_conf.c", 314);
    goto LABEL_15;
  }
  v12->data = v10;
  v12->length = len;
  v14 = X509_EXTENSION_create_by_OBJ(0, v9, a3, v12);
  v10 = 0;
LABEL_16:
  ASN1_OBJECT_free(v9);
  ASN1_OCTET_STRING_free(v13);
  free(v10);
  return v14;
}

X509_EXTENSION *do_ext_nconf(const CONF *a1, uint64_t a2, int nid, int a4, const char *a5)
{
  X509V3_EXT_METHOD *v10;
  uint64_t v11;
  STACK *section;
  int v13;
  int v14;
  X509_EXTENSION *v15;
  uint64_t (*s2i)(X509V3_EXT_METHOD *, uint64_t, const char *);
  ASN1_VALUE *v18;
  STACK *v19;
  const ASN1_ITEM *v20;
  const char *v21;
  const char *v22;

  if (!nid)
  {
    v13 = 130;
    v14 = 137;
    goto LABEL_8;
  }
  v10 = X509V3_EXT_get_nid(nid);
  if (!v10)
  {
    v13 = 129;
    v14 = 141;
    goto LABEL_8;
  }
  v11 = (uint64_t)v10;
  if (!v10->v2i)
  {
    s2i = (uint64_t (*)(X509V3_EXT_METHOD *, uint64_t, const char *))v10->s2i;
    if (s2i)
      goto LABEL_12;
    s2i = (uint64_t (*)(X509V3_EXT_METHOD *, uint64_t, const char *))v10->r2i;
    if (!s2i)
    {
      ERR_put_error(34, 4095, 103, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_conf.c", 172);
      v22 = OBJ_nid2sn(nid);
      ERR_asprintf_error_data("name=%s", v22);
      return 0;
    }
    if (*(_QWORD *)(a2 + 48) && *(_QWORD *)(a2 + 40))
    {
LABEL_12:
      v18 = (ASN1_VALUE *)s2i(v10, a2, a5);
      goto LABEL_17;
    }
    v13 = 136;
    v14 = 167;
LABEL_8:
    ERR_put_error(34, 4095, v13, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_conf.c", v14);
    return 0;
  }
  if (*a5 == 64)
    section = NCONF_get_section(a1, a5 + 1);
  else
    section = X509V3_parse_list(a5);
  v19 = section;
  if (sk_num(section) <= 0)
  {
    ERR_put_error(34, 4095, 105, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_conf.c", 153);
    v21 = OBJ_nid2sn(nid);
    ERR_asprintf_error_data("name=%s,section=%s", v21, a5);
    if (*a5 != 64)
      sk_pop_free(v19, (void (__cdecl *)(void *))X509V3_conf_free);
    return 0;
  }
  v18 = (ASN1_VALUE *)(*(uint64_t (**)(uint64_t, uint64_t, STACK *))(v11 + 72))(v11, a2, v19);
  if (*a5 != 64)
    sk_pop_free(v19, (void (__cdecl *)(void *))X509V3_conf_free);
LABEL_17:
  if (!v18)
    return 0;
  v15 = do_ext_i2d(v11, nid, a4, v18);
  v20 = *(const ASN1_ITEM **)(v11 + 8);
  if (v20)
    ASN1_item_free(v18, v20);
  else
    (*(void (**)(ASN1_VALUE *))(v11 + 24))(v18);
  return v15;
}

X509_EXTENSION *__cdecl X509V3_EXT_nconf_nid(CONF *conf, X509V3_CTX *ctx, int ext_nid, char *value)
{
  int v7;
  int v8;
  int v9;
  const char *v10;
  char *v12;

  v12 = value;
  v7 = v3_check_critical((const char **)&v12);
  v8 = v3_check_generic((const char **)&v12);
  if (!v8)
    return do_ext_nconf(conf, (uint64_t)ctx, ext_nid, v7, v12);
  v9 = v8;
  v10 = OBJ_nid2sn(ext_nid);
  return v3_generic_extension(v10, v12, v7, v9, ctx);
}

X509_EXTENSION *__cdecl X509V3_EXT_i2d(int ext_nid, int crit, void *ext_struc)
{
  X509V3_EXT_METHOD *nid;

  nid = X509V3_EXT_get_nid(ext_nid);
  if (nid)
    return do_ext_i2d((uint64_t)nid, ext_nid, crit, (ASN1_VALUE *)ext_struc);
  ERR_put_error(34, 4095, 129, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_conf.c", 238);
  return 0;
}

X509_EXTENSION *do_ext_i2d(uint64_t a1, int a2, int a3, ASN1_VALUE *val)
{
  const ASN1_ITEM *v7;
  int v8;
  unsigned __int8 *v10;
  ASN1_OCTET_STRING *v11;
  ASN1_OCTET_STRING *v12;
  X509_EXTENSION *v13;
  X509_EXTENSION *v14;
  unsigned __int8 *v16;
  unsigned __int8 *out;

  v7 = *(const ASN1_ITEM **)(a1 + 8);
  if (v7)
  {
    out = 0;
    v8 = ASN1_item_i2d(val, &out, v7);
    if (v8 < 0)
      goto LABEL_9;
  }
  else
  {
    v8 = (*(uint64_t (**)(ASN1_VALUE *, _QWORD))(a1 + 40))(val, 0);
    v10 = (unsigned __int8 *)malloc_type_malloc(v8, 0x2797802FuLL);
    out = v10;
    if (!v10)
    {
LABEL_9:
      v12 = 0;
LABEL_10:
      ASN1_OCTET_STRING_free(v12);
      ERR_put_error(34, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_conf.c", 225);
      return 0;
    }
    v16 = v10;
    (*(void (**)(ASN1_VALUE *, unsigned __int8 **))(a1 + 40))(val, &v16);
  }
  v11 = ASN1_OCTET_STRING_new();
  v12 = v11;
  if (!v11)
    goto LABEL_10;
  v11->data = out;
  v11->length = v8;
  v13 = X509_EXTENSION_create_by_NID(0, a2, a3, v11);
  if (!v13)
    goto LABEL_10;
  v14 = v13;
  ASN1_OCTET_STRING_free(v12);
  return v14;
}

int X509V3_EXT_add_nconf_sk(CONF *conf, X509V3_CTX *ctx, char *section, STACK **sk)
{
  X509_EXTENSION *v7;
  const STACK *v8;
  int v9;
  char *v10;
  X509_EXTENSION *v11;

  v7 = (X509_EXTENSION *)NCONF_get_section(conf, section);
  if (v7)
  {
    v8 = (const STACK *)v7;
    if (sk_num((const STACK *)v7) < 1)
    {
LABEL_8:
      LODWORD(v7) = 1;
    }
    else
    {
      v9 = 0;
      while (1)
      {
        v10 = sk_value(v8, v9);
        v7 = X509V3_EXT_nconf(conf, ctx, *((char **)v10 + 1), *((char **)v10 + 2));
        if (!v7)
          break;
        v11 = v7;
        if (sk)
          X509v3_add_ext(sk, v7, -1);
        X509_EXTENSION_free(v11);
        if (++v9 >= sk_num(v8))
          goto LABEL_8;
      }
    }
  }
  return (int)v7;
}

int X509V3_EXT_add_nconf(CONF *conf, X509V3_CTX *ctx, char *section, X509 *cert)
{
  if (cert)
    cert = (X509 *)&cert->cert_info->extensions;
  return X509V3_EXT_add_nconf_sk(conf, ctx, section, (STACK **)cert);
}

int X509V3_EXT_CRL_add_nconf(CONF *conf, X509V3_CTX *ctx, char *section, X509_CRL *crl)
{
  if (crl)
    crl = (X509_CRL *)&crl->crl->extensions;
  return X509V3_EXT_add_nconf_sk(conf, ctx, section, (STACK **)crl);
}

int X509V3_EXT_REQ_add_nconf(CONF *conf, X509V3_CTX *ctx, char *section, X509_REQ *req)
{
  STACK **p_exts;
  int v6;
  int v7;
  STACK *exts;

  exts = 0;
  if (req)
    p_exts = &exts;
  else
    p_exts = 0;
  v6 = X509V3_EXT_add_nconf_sk(conf, ctx, section, p_exts);
  v7 = v6;
  if (req && v6)
  {
    v7 = X509_REQ_add_extensions(req, exts);
    sk_pop_free(exts, (void (__cdecl *)(void *))X509_EXTENSION_free);
  }
  return v7;
}

char *__cdecl X509V3_get_string(X509V3_CTX *ctx, char *name, char *section)
{
  X509V3_CONF_METHOD *db_meth;

  if (ctx->db)
  {
    db_meth = ctx->db_meth;
    if (db_meth)
    {
      if (db_meth->get_string)
        return (char *)((uint64_t (*)(void))db_meth->get_string)();
    }
  }
  ERR_put_error(34, 4095, 148, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_conf.c", 426);
  return 0;
}

STACK *__cdecl X509V3_get_section(X509V3_CTX *ctx, char *section)
{
  X509V3_CONF_METHOD *db_meth;
  uint64_t (*get_section)(void);

  if (ctx->db)
  {
    db_meth = ctx->db_meth;
    if (db_meth)
    {
      get_section = (uint64_t (*)(void))db_meth->get_section;
      if (get_section)
        return (STACK *)get_section();
    }
  }
  ERR_put_error(34, 4095, 148, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_conf.c", 437);
  return 0;
}

void X509V3_string_free(X509V3_CTX *ctx, char *str)
{
  void (__cdecl *free_string)(void *, char *);

  if (str)
  {
    free_string = ctx->db_meth->free_string;
    if (free_string)
      ((void (*)(void *))free_string)(ctx->db);
  }
}

void X509V3_section_free(X509V3_CTX *ctx, STACK *section)
{
  void (__cdecl *free_section)(void *, STACK *);

  if (section)
  {
    free_section = ctx->db_meth->free_section;
    if (free_section)
      ((void (*)(void *))free_section)(ctx->db);
  }
}

void X509V3_set_nconf(X509V3_CTX *ctx, CONF *conf)
{
  ctx->db_meth = (X509V3_CONF_METHOD *)nconf_method;
  ctx->db = conf;
}

void X509V3_set_ctx(X509V3_CTX *ctx, X509 *issuer, X509 *subject, X509_REQ *req, X509_CRL *crl, int flags)
{
  ctx->issuer_cert = issuer;
  ctx->subject_cert = subject;
  ctx->subject_req = req;
  ctx->crl = crl;
  ctx->flags = flags;
}

X509_EXTENSION *__cdecl X509V3_EXT_conf(LHASH *conf, X509V3_CTX *ctx, char *name, char *value)
{
  CONF confa;

  memset(&confa, 0, sizeof(confa));
  CONF_set_nconf(&confa, conf);
  return X509V3_EXT_nconf(&confa, ctx, name, value);
}

X509_EXTENSION *__cdecl X509V3_EXT_conf_nid(LHASH *conf, X509V3_CTX *ctx, int ext_nid, char *value)
{
  CONF confa;

  memset(&confa, 0, sizeof(confa));
  CONF_set_nconf(&confa, conf);
  return X509V3_EXT_nconf_nid(&confa, ctx, ext_nid, value);
}

void X509V3_set_conf_lhash(X509V3_CTX *ctx, LHASH *lhash)
{
  ctx->db_meth = (X509V3_CONF_METHOD *)conf_lhash_method;
  ctx->db = lhash;
}

int X509V3_EXT_add_conf(LHASH *conf, X509V3_CTX *ctx, char *section, X509 *cert)
{
  STACK **p_extensions;
  CONF confa;

  memset(&confa, 0, sizeof(confa));
  CONF_set_nconf(&confa, conf);
  if (cert)
    p_extensions = &cert->cert_info->extensions;
  else
    p_extensions = 0;
  return X509V3_EXT_add_nconf_sk(&confa, ctx, section, p_extensions);
}

int X509V3_EXT_CRL_add_conf(LHASH *conf, X509V3_CTX *ctx, char *section, X509_CRL *crl)
{
  STACK **p_extensions;
  CONF confa;

  memset(&confa, 0, sizeof(confa));
  CONF_set_nconf(&confa, conf);
  if (crl)
    p_extensions = &crl->crl->extensions;
  else
    p_extensions = 0;
  return X509V3_EXT_add_nconf_sk(&confa, ctx, section, p_extensions);
}

int X509V3_EXT_REQ_add_conf(LHASH *conf, X509V3_CTX *ctx, char *section, X509_REQ *req)
{
  CONF confa;

  memset(&confa, 0, sizeof(confa));
  CONF_set_nconf(&confa, conf);
  return X509V3_EXT_REQ_add_nconf(&confa, ctx, section, req);
}

X509_REQ_INFO *__cdecl d2i_X509_REQ_INFO(X509_REQ_INFO **a, const unsigned __int8 **in, uint64_t len)
{
  return (X509_REQ_INFO *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &X509_REQ_INFO_it);
}

int i2d_X509_REQ_INFO(X509_REQ_INFO *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &X509_REQ_INFO_it);
}

X509_REQ_INFO *X509_REQ_INFO_new(void)
{
  return (X509_REQ_INFO *)ASN1_item_new(&X509_REQ_INFO_it);
}

void X509_REQ_INFO_free(X509_REQ_INFO *a)
{
  ASN1_item_free((ASN1_VALUE *)a, &X509_REQ_INFO_it);
}

X509_REQ *__cdecl d2i_X509_REQ(X509_REQ **a, const unsigned __int8 **in, uint64_t len)
{
  return (X509_REQ *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &X509_REQ_it);
}

int i2d_X509_REQ(X509_REQ *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &X509_REQ_it);
}

X509_REQ *X509_REQ_new(void)
{
  return (X509_REQ *)ASN1_item_new(&X509_REQ_it);
}

void X509_REQ_free(X509_REQ *a)
{
  ASN1_item_free((ASN1_VALUE *)a, &X509_REQ_it);
}

X509_REQ *__cdecl X509_REQ_dup(X509_REQ *req)
{
  return (X509_REQ *)ASN1_item_dup(&X509_REQ_it, req);
}

uint64_t X509_REQ_get_signature_nid(uint64_t a1)
{
  return OBJ_obj2nid(**(const ASN1_OBJECT ***)(a1 + 8));
}

uint64_t X509_REQ_get0_signature(uint64_t result, _QWORD *a2, _QWORD *a3)
{
  if (a2)
    *a2 = *(_QWORD *)(result + 16);
  if (a3)
    *a3 = *(_QWORD *)(result + 8);
  return result;
}

uint64_t rinf_cb(int a1, uint64_t *a2)
{
  uint64_t v2;
  uint64_t result;

  if (a1 != 1)
    return 1;
  v2 = *a2;
  result = (uint64_t)sk_new_null();
  *(_QWORD *)(v2 + 48) = result;
  if (result)
    return 1;
  return result;
}

BOOL hmac_pkey_public_cmp(uint64_t a1, uint64_t a2)
{
  return ASN1_OCTET_STRING_cmp(*(ASN1_OCTET_STRING **)(a1 + 32), *(ASN1_OCTET_STRING **)(a2 + 32)) == 0;
}

uint64_t hmac_size()
{
  return 64;
}

void hmac_key_free(uint64_t a1)
{
  ASN1_OCTET_STRING *v1;
  unsigned __int8 *data;

  v1 = *(ASN1_OCTET_STRING **)(a1 + 32);
  if (v1)
  {
    data = v1->data;
    if (data)
      explicit_bzero(data, v1->length);
    ASN1_OCTET_STRING_free(v1);
  }
}

uint64_t hmac_pkey_ctrl(uint64_t a1, int a2, uint64_t a3, _DWORD *a4)
{
  if (a2 != 3)
    return 4294967294;
  *a4 = 64;
  return 1;
}

uint64_t hmac_set_priv_key(uint64_t a1, const unsigned __int8 *a2, unint64_t a3)
{
  ASN1_OCTET_STRING *v3;
  int v5;
  ASN1_OCTET_STRING *v7;

  v3 = 0;
  if (a3 >> 31
    || *(_QWORD *)(a1 + 32)
    || (v5 = a3, v7 = ASN1_OCTET_STRING_new(), (v3 = v7) == 0)
    || !ASN1_OCTET_STRING_set(v7, a2, v5))
  {
    ASN1_OCTET_STRING_free(v3);
    return 0;
  }
  else
  {
    *(_QWORD *)(a1 + 32) = v3;
    return 1;
  }
}

uint64_t hmac_get_priv_key(uint64_t a1, void *a2, size_t *a3)
{
  int *v3;
  _QWORD v7[3];

  v3 = *(int **)(a1 + 32);
  if (!v3)
    return 0;
  memset(v7, 0, sizeof(v7));
  if (a2)
  {
    CBS_init(v7, *((_QWORD *)v3 + 1), *v3);
    return CBS_write_bytes((uint64_t)v7, a2, *a3, a3);
  }
  else
  {
    *a3 = *v3;
    return 1;
  }
}

uint64_t evp_pkey_meth_get_count()
{
  if (pkey_app_methods)
    return (sk_num((const STACK *)pkey_app_methods) + 12);
  else
    return 12;
}

char *evp_pkey_meth_get0(unsigned int a1)
{
  if ((a1 & 0x80000000) != 0)
    return 0;
  if (a1 > 0xB)
    return sk_value((const STACK *)pkey_app_methods, a1 - 12);
  return (char *)*(&pkey_methods + a1);
}

char *EVP_PKEY_meth_find(int a1)
{
  unint64_t v2;
  char *result;

  if (pkey_app_methods)
    v2 = (sk_num((const STACK *)pkey_app_methods) + 12);
  else
    v2 = 12;
  while ((int)v2 >= 1)
  {
    if (v2 > 0xC)
      result = sk_value((const STACK *)pkey_app_methods, (int)v2 - 13);
    else
      result = (char *)*(&pkey_methods + v2 - 1);
    --v2;
    if (*(_DWORD *)result == a1)
      return result;
  }
  return 0;
}

_DWORD *EVP_PKEY_meth_new(int a1, int a2)
{
  _DWORD *result;

  result = malloc_type_calloc(1uLL, 0xF8uLL, 0x1080040399D213BuLL);
  if (result)
  {
    *result = a1;
    result[1] = a2 | 1;
  }
  return result;
}

_DWORD *EVP_PKEY_meth_get0_info(_DWORD *result, _DWORD *a2, _DWORD *a3)
{
  if (result)
    *result = *a3;
  if (a2)
    *a2 = a3[1];
  return result;
}

double EVP_PKEY_meth_copy(uint64_t a1, __int128 *a2)
{
  double result;
  __int128 v3;
  __int128 v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;

  result = *(double *)a1;
  v3 = *a2;
  v4 = a2[1];
  v5 = a2[3];
  *(_OWORD *)(a1 + 32) = a2[2];
  *(_OWORD *)(a1 + 48) = v5;
  *(_OWORD *)(a1 + 16) = v4;
  v6 = a2[7];
  v8 = a2[4];
  v7 = a2[5];
  *(_OWORD *)(a1 + 96) = a2[6];
  *(_OWORD *)(a1 + 112) = v6;
  *(_OWORD *)(a1 + 64) = v8;
  *(_OWORD *)(a1 + 80) = v7;
  v9 = a2[11];
  v11 = a2[8];
  v10 = a2[9];
  *(_OWORD *)(a1 + 160) = a2[10];
  *(_OWORD *)(a1 + 176) = v9;
  *(_OWORD *)(a1 + 128) = v11;
  *(_OWORD *)(a1 + 144) = v10;
  v13 = a2[13];
  v12 = a2[14];
  v14 = a2[12];
  *(_QWORD *)(a1 + 240) = *((_QWORD *)a2 + 30);
  *(_OWORD *)(a1 + 208) = v13;
  *(_OWORD *)(a1 + 224) = v12;
  *(_OWORD *)(a1 + 192) = v14;
  *(_OWORD *)a1 = v3;
  *(double *)a1 = result;
  return result;
}

void EVP_PKEY_meth_free(void *a1)
{
  if (a1)
  {
    if ((*((_BYTE *)a1 + 4) & 1) != 0)
      free(a1);
  }
}

EVP_PKEY **EVP_PKEY_CTX_new(uint64_t a1, ENGINE *a2)
{
  return int_ctx_new(a1, a2, -1);
}

EVP_PKEY **int_ctx_new(uint64_t a1, ENGINE *e, int a3)
{
  ENGINE *pkey_meth_engine;
  int v5;
  char v6;
  uint64_t pkey_meth;
  int *v8;
  uint64_t v9;
  EVP_PKEY **v10;
  EVP_PKEY **v11;
  int (*v12)(EVP_PKEY **);
  int v13;
  int v14;

  pkey_meth_engine = e;
  if (a3 == -1)
  {
    if (!a1)
      return 0;
    v8 = *(int **)(a1 + 16);
    if (!v8)
      return 0;
    v5 = *v8;
  }
  else
  {
    v5 = a3;
    if (!a1)
    {
      v6 = 1;
      if (!e)
        goto LABEL_4;
LABEL_12:
      if (!ENGINE_init(pkey_meth_engine))
      {
        v13 = 38;
        v14 = 170;
        goto LABEL_23;
      }
      goto LABEL_13;
    }
  }
  v6 = 0;
  if (*(_QWORD *)(a1 + 24))
    pkey_meth_engine = *(ENGINE **)(a1 + 24);
  if (pkey_meth_engine)
    goto LABEL_12;
LABEL_4:
  pkey_meth_engine = (ENGINE *)ENGINE_get_pkey_meth_engine(v5);
  if (!pkey_meth_engine)
  {
    pkey_meth = (uint64_t)EVP_PKEY_meth_find(v5);
    goto LABEL_14;
  }
LABEL_13:
  pkey_meth = ENGINE_get_pkey_meth((uint64_t)pkey_meth_engine);
LABEL_14:
  v9 = pkey_meth;
  if (!pkey_meth)
  {
    v13 = 156;
    v14 = 187;
LABEL_23:
    ERR_put_error(6, 4095, v13, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/pmeth_lib.c", v14);
    return 0;
  }
  v10 = (EVP_PKEY **)malloc_type_malloc(0x50uLL, 0x10F0040FE4E0FE9uLL);
  v11 = v10;
  if (!v10)
  {
    ENGINE_finish(pkey_meth_engine);
    ERR_put_error(6, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/pmeth_lib.c", 196);
    return v11;
  }
  *v10 = (EVP_PKEY *)v9;
  v10[1] = (EVP_PKEY *)pkey_meth_engine;
  *((_DWORD *)v10 + 8) = 0;
  v10[2] = (EVP_PKEY *)a1;
  v10[3] = 0;
  v10[7] = 0;
  if ((v6 & 1) == 0)
    CRYPTO_add_lock((int *)(a1 + 8), 1, 10, 0, 0);
  v11[5] = 0;
  v12 = *(int (**)(EVP_PKEY **))(v9 + 8);
  if (v12 && v12(v11) <= 0)
  {
    EVP_PKEY_CTX_free(v11);
    return 0;
  }
  return v11;
}

EVP_PKEY **EVP_PKEY_CTX_new_id(int a1, ENGINE *a2)
{
  return int_ctx_new(0, a2, a1);
}

_OWORD *EVP_PKEY_CTX_dup(uint64_t a1)
{
  ENGINE *v2;
  _OWORD *v3;
  _OWORD *v4;
  uint64_t v5;
  uint64_t v6;

  if (!*(_QWORD *)a1 || !*(_QWORD *)(*(_QWORD *)a1 + 16))
    return 0;
  v2 = *(ENGINE **)(a1 + 8);
  if (v2 && !ENGINE_init(v2))
  {
    ERR_put_error(6, 4095, 38, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/pmeth_lib.c", 285);
    return 0;
  }
  v3 = malloc_type_malloc(0x50uLL, 0x10F0040FE4E0FE9uLL);
  v4 = v3;
  if (v3)
  {
    *v3 = *(_OWORD *)a1;
    v5 = *(_QWORD *)(a1 + 16);
    if (v5)
    {
      CRYPTO_add_lock((int *)(v5 + 8), 1, 10, 0, 0);
      v5 = *(_QWORD *)(a1 + 16);
    }
    *((_QWORD *)v4 + 2) = v5;
    v6 = *(_QWORD *)(a1 + 24);
    if (v6)
    {
      CRYPTO_add_lock((int *)(v6 + 8), 1, 10, 0, 0);
      v6 = *(_QWORD *)(a1 + 24);
    }
    *((_QWORD *)v4 + 3) = v6;
    *((_QWORD *)v4 + 5) = 0;
    *((_QWORD *)v4 + 6) = 0;
    *((_DWORD *)v4 + 8) = *(_DWORD *)(a1 + 32);
    if ((*(int (**)(_OWORD *, uint64_t))(*(_QWORD *)a1 + 16))(v4, a1) <= 0)
    {
      EVP_PKEY_CTX_free((EVP_PKEY **)v4);
      return 0;
    }
  }
  return v4;
}

void EVP_PKEY_CTX_free(EVP_PKEY **a1)
{
  void (*v2)(EVP_PKEY **);

  if (a1)
  {
    if (*a1)
    {
      v2 = *(void (**)(EVP_PKEY **))&(*a1)->save_parameters;
      if (v2)
        v2(a1);
    }
    EVP_PKEY_free(a1[2]);
    EVP_PKEY_free(a1[3]);
    ENGINE_finish((ENGINE *)a1[1]);
    free(a1);
  }
}

STACK *EVP_PKEY_meth_add0(char *data)
{
  STACK *result;

  result = (STACK *)pkey_app_methods;
  if (pkey_app_methods)
    return (STACK *)(sk_push(result, data) != 0);
  result = sk_new(0);
  pkey_app_methods = (uint64_t)result;
  if (result)
    return (STACK *)(sk_push(result, data) != 0);
  return result;
}

uint64_t EVP_PKEY_CTX_ctrl(uint64_t *a1, int a2, int a3)
{
  uint64_t v3;
  uint64_t (*v4)(void);
  int v5;
  int v6;
  int v7;
  int v8;
  uint64_t result;

  if (!a1 || (v3 = *a1) == 0 || (v4 = *(uint64_t (**)(void))(v3 + 192)) == 0)
  {
    v8 = 356;
LABEL_11:
    ERR_put_error(6, 4095, 147, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/pmeth_lib.c", v8);
    return 4294967294;
  }
  if (a2 != -1 && *(_DWORD *)v3 != a2)
    return 0xFFFFFFFFLL;
  v5 = *((_DWORD *)a1 + 8);
  if (!v5)
  {
    v6 = 149;
    v7 = 363;
    goto LABEL_14;
  }
  if (a3 != -1 && (v5 & a3) == 0)
  {
    v6 = 148;
    v7 = 368;
LABEL_14:
    ERR_put_error(6, 4095, v6, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/pmeth_lib.c", v7);
    return 0xFFFFFFFFLL;
  }
  result = v4();
  if ((_DWORD)result == -2)
  {
    v8 = 375;
    goto LABEL_11;
  }
  return result;
}

uint64_t EVP_PKEY_CTX_ctrl_str(uint64_t *a1, char *__s1, char *a3)
{
  uint64_t v4;
  uint64_t (*v8)(uint64_t *, char *, char *);

  if (a1 && (v4 = *a1) != 0 && *(_QWORD *)(v4 + 200))
  {
    v8 = *(uint64_t (**)(uint64_t *, char *, char *))(v4 + 200);
    if (!strcmp(__s1, "digest"))
      return EVP_PKEY_CTX_md(a1, 248, 1, a3);
    else
      return v8(a1, __s1, a3);
  }
  else
  {
    ERR_put_error(6, 4095, 147, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/pmeth_lib.c", 385);
    return 4294967294;
  }
}

uint64_t EVP_PKEY_CTX_md(uint64_t *a1, int a2, int a3, char *name)
{
  if (EVP_get_digestbyname(name))
    return EVP_PKEY_CTX_ctrl(a1, -1, a2);
  ERR_put_error(6, 4095, 152, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/pmeth_lib.c", 433);
  return 0;
}

uint64_t EVP_PKEY_CTX_str2ctrl(uint64_t a1, uint64_t a2, char *__s)
{
  size_t v6;

  v6 = strlen(__s);
  if (v6 >> 31)
    return 0xFFFFFFFFLL;
  else
    return (*(uint64_t (**)(uint64_t, uint64_t, size_t, char *))(*(_QWORD *)a1 + 192))(a1, a2, v6, __s);
}

uint64_t EVP_PKEY_CTX_hex2ctrl(uint64_t a1, uint64_t a2, char *str)
{
  unsigned __int8 *v5;
  uint64_t v6;
  uint64_t len;

  len = 0;
  v5 = string_to_hex(str, &len);
  if (v5)
  {
    if ((unint64_t)len >> 31)
      v6 = 0xFFFFFFFFLL;
    else
      v6 = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 192))(a1, a2);
  }
  else
  {
    v6 = 0;
  }
  free(v5);
  return v6;
}

uint64_t EVP_PKEY_CTX_get_operation(uint64_t a1)
{
  return *(unsigned int *)(a1 + 32);
}

uint64_t EVP_PKEY_CTX_set0_keygen_info(uint64_t result, uint64_t a2, int a3)
{
  *(_QWORD *)(result + 64) = a2;
  *(_DWORD *)(result + 72) = a3;
  return result;
}

uint64_t EVP_PKEY_CTX_set_data(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = a2;
  return result;
}

uint64_t EVP_PKEY_CTX_get_data(uint64_t a1)
{
  return *(_QWORD *)(a1 + 40);
}

uint64_t EVP_PKEY_CTX_get0_pkey(uint64_t a1)
{
  return *(_QWORD *)(a1 + 16);
}

uint64_t EVP_PKEY_CTX_get0_peerkey(uint64_t a1)
{
  return *(_QWORD *)(a1 + 24);
}

uint64_t EVP_PKEY_CTX_set_app_data(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 48) = a2;
  return result;
}

uint64_t EVP_PKEY_CTX_get_app_data(uint64_t a1)
{
  return *(_QWORD *)(a1 + 48);
}

uint64_t EVP_PKEY_meth_set_init(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 8) = a2;
  return result;
}

uint64_t EVP_PKEY_meth_set_copy(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 16) = a2;
  return result;
}

uint64_t EVP_PKEY_meth_set_cleanup(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 24) = a2;
  return result;
}

uint64_t EVP_PKEY_meth_set_paramgen(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 32) = a2;
  *(_QWORD *)(result + 40) = a3;
  return result;
}

uint64_t EVP_PKEY_meth_set_keygen(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 48) = a2;
  *(_QWORD *)(result + 56) = a3;
  return result;
}

uint64_t EVP_PKEY_meth_set_sign(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 64) = a2;
  *(_QWORD *)(result + 72) = a3;
  return result;
}

uint64_t EVP_PKEY_meth_set_verify(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 80) = a2;
  *(_QWORD *)(result + 88) = a3;
  return result;
}

uint64_t EVP_PKEY_meth_set_verify_recover(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 96) = a2;
  *(_QWORD *)(result + 104) = a3;
  return result;
}

uint64_t EVP_PKEY_meth_set_signctx(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 112) = a2;
  *(_QWORD *)(result + 120) = a3;
  return result;
}

uint64_t EVP_PKEY_meth_set_verifyctx(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 128) = a2;
  *(_QWORD *)(result + 136) = a3;
  return result;
}

uint64_t EVP_PKEY_meth_set_encrypt(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 144) = a2;
  *(_QWORD *)(result + 152) = a3;
  return result;
}

uint64_t EVP_PKEY_meth_set_decrypt(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 160) = a2;
  *(_QWORD *)(result + 168) = a3;
  return result;
}

uint64_t EVP_PKEY_meth_set_derive(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 176) = a2;
  *(_QWORD *)(result + 184) = a3;
  return result;
}

uint64_t EVP_PKEY_meth_set_ctrl(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 192) = a2;
  *(_QWORD *)(result + 200) = a3;
  return result;
}

uint64_t EVP_PKEY_meth_set_check(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 224) = a2;
  return result;
}

uint64_t EVP_PKEY_meth_set_public_check(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 232) = a2;
  return result;
}

uint64_t EVP_PKEY_meth_set_param_check(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 240) = a2;
  return result;
}

_QWORD *GOST_KEY_new()
{
  _QWORD *v0;
  _QWORD *v1;

  v0 = malloc_type_malloc(0x20uLL, 0x102004016EE4530uLL);
  v1 = v0;
  if (v0)
  {
    *v0 = 0;
    v0[1] = 0;
    v0[2] = 0;
    v0[3] = 1;
  }
  else
  {
    ERR_put_error(50, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/gost/gostr341001_key.c", 81);
  }
  return v1;
}

void GOST_KEY_free(uint64_t a1)
{
  if (a1)
  {
    if (CRYPTO_add_lock((int *)(a1 + 24), -1, 33, 0, 0) <= 0)
    {
      EC_GROUP_free(*(EC_GROUP **)a1);
      EC_POINT_free(*(EC_POINT **)(a1 + 8));
      BN_free(*(BIGNUM **)(a1 + 16));
      freezero((void *)a1, 0x20uLL);
    }
  }
}

uint64_t GOST_KEY_check_key(uint64_t a1)
{
  const EC_GROUP *v2;
  const EC_POINT *v3;
  uint64_t v4;
  BN_CTX *v5;
  BIGNUM *v6;
  EC_POINT *v7;
  const BIGNUM *v9;
  int v10;
  int v11;

  if (!a1 || (v2 = *(const EC_GROUP **)a1) == 0 || (v3 = *(const EC_POINT **)(a1 + 8)) == 0)
  {
    ERR_put_error(50, 4095, 67, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/gost/gostr341001_key.c", 120);
    return 0;
  }
  if (!EC_POINT_is_at_infinity(v2, v3))
  {
    v5 = BN_CTX_new();
    if (!v5)
    {
      v4 = 0;
      goto LABEL_6;
    }
    v7 = EC_POINT_new(*(const EC_GROUP **)a1);
    if (v7)
    {
      if (EC_POINT_is_on_curve(*(const EC_GROUP **)a1, *(const EC_POINT **)(a1 + 8), v5))
      {
        v6 = BN_new();
        if (!v6)
        {
LABEL_27:
          v4 = 0;
          goto LABEL_7;
        }
        if (EC_GROUP_get_order(*(const EC_GROUP **)a1, v6, v5))
        {
          if (!EC_POINT_mul(*(const EC_GROUP **)a1, v7, 0, *(const EC_POINT **)(a1 + 8), v6, v5))
          {
            v10 = 16;
            v11 = 146;
            goto LABEL_26;
          }
          if (!EC_POINT_is_at_infinity(*(const EC_GROUP **)a1, v7))
          {
            v10 = 130;
            v11 = 150;
            goto LABEL_26;
          }
          v9 = *(const BIGNUM **)(a1 + 16);
          if (v9)
          {
            if ((BN_cmp(v9, v6) & 0x80000000) == 0)
            {
              v10 = 130;
              v11 = 159;
LABEL_26:
              ERR_put_error(50, 4095, v10, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/gost/gostr341001_key.c", v11);
              goto LABEL_27;
            }
            if (!EC_POINT_mul(*(const EC_GROUP **)a1, v7, *(const BIGNUM **)(a1 + 16), 0, 0, v5))
            {
              v10 = 16;
              v11 = 164;
              goto LABEL_26;
            }
            if (EC_POINT_cmp(*(const EC_GROUP **)a1, v7, *(const EC_POINT **)(a1 + 8), v5))
            {
              v10 = 123;
              v11 = 168;
              goto LABEL_26;
            }
          }
          v4 = 1;
          goto LABEL_7;
        }
        v10 = 122;
        v11 = 141;
        goto LABEL_26;
      }
      ERR_put_error(50, 4095, 107, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/gost/gostr341001_key.c", 134);
    }
    v4 = 0;
    v6 = 0;
    goto LABEL_7;
  }
  ERR_put_error(50, 4095, 106, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/gost/gostr341001_key.c", 124);
  v4 = 0;
  v5 = 0;
LABEL_6:
  v6 = 0;
  v7 = 0;
LABEL_7:
  BN_free(v6);
  BN_CTX_free(v5);
  EC_POINT_free(v7);
  return v4;
}

uint64_t GOST_KEY_set_public_key_affine_coordinates(const EC_GROUP **a1, const BIGNUM *a2, const BIGNUM *a3)
{
  BN_CTX *v6;
  BN_CTX *v7;
  EC_POINT *v8;
  BIGNUM *v9;
  const BIGNUM *v10;
  BIGNUM *v11;
  const BIGNUM *v12;
  uint64_t v13;

  if (a1 && a3 && a2 && *a1)
  {
    v6 = BN_CTX_new();
    v7 = v6;
    if (v6)
    {
      BN_CTX_start(v6);
      v8 = EC_POINT_new(*a1);
      if (v8)
      {
        v9 = BN_CTX_get(v7);
        if (v9)
        {
          v10 = v9;
          v11 = BN_CTX_get(v7);
          if (v11)
          {
            v12 = v11;
            if (EC_POINT_set_affine_coordinates(*a1, v8, (uint64_t)a2, (uint64_t)a3, v7))
            {
              if (EC_POINT_get_affine_coordinates((uint64_t)*a1, v8, (uint64_t)v10, (uint64_t)v12, v7))
              {
                if (BN_cmp(a2, v10) || BN_cmp(a3, v12))
                {
                  ERR_put_error(50, 4095, 146, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/gost/gostr341001_key.c", 217);
                }
                else if (GOST_KEY_set_public_key(a1, v8))
                {
                  v13 = GOST_KEY_check_key((uint64_t)a1);
                  goto LABEL_17;
                }
              }
            }
          }
        }
      }
    }
    else
    {
      v8 = 0;
    }
    v13 = 0;
LABEL_17:
    EC_POINT_free(v8);
    BN_CTX_end(v7);
    BN_CTX_free(v7);
    return v13;
  }
  ERR_put_error(50, 4095, 67, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/gost/gostr341001_key.c", 189);
  return 0;
}

BOOL GOST_KEY_set_public_key(const EC_GROUP **a1, const EC_POINT *a2)
{
  EC_POINT *v4;

  EC_POINT_free(a1[1]);
  v4 = EC_POINT_dup(a2, *a1);
  a1[1] = v4;
  return v4 != 0;
}

uint64_t GOST_KEY_get0_group(uint64_t a1)
{
  return *(_QWORD *)a1;
}

BOOL GOST_KEY_set_group(EC_GROUP **a1, const EC_GROUP *a2)
{
  EC_GROUP *v4;

  EC_GROUP_free(*a1);
  v4 = EC_GROUP_dup(a2);
  *a1 = v4;
  return v4 != 0;
}

uint64_t GOST_KEY_get0_private_key(uint64_t a1)
{
  return *(_QWORD *)(a1 + 16);
}

BOOL GOST_KEY_set_private_key(uint64_t a1, const BIGNUM *a2)
{
  BIGNUM *v4;

  BN_free(*(BIGNUM **)(a1 + 16));
  v4 = BN_dup(a2);
  *(_QWORD *)(a1 + 16) = v4;
  return v4 != 0;
}

uint64_t GOST_KEY_get0_public_key(uint64_t a1)
{
  return *(_QWORD *)(a1 + 8);
}

uint64_t GOST_KEY_get_digest(uint64_t a1)
{
  return *(unsigned int *)(a1 + 28);
}

uint64_t GOST_KEY_set_digest(uint64_t a1, int a2)
{
  if ((a2 - 941) >= 2 && a2 != 822)
    return 0;
  *(_DWORD *)(a1 + 28) = a2;
  return 1;
}

BIGNUM *GOST_KEY_get_size(BIGNUM *result)
{
  const EC_GROUP *d;
  BIGNUM *v2;
  int v3;
  int v4;

  if (!result)
    return result;
  d = (const EC_GROUP *)result->d;
  if (!result->d)
    return 0;
  result = BN_new();
  if (!result)
    return result;
  v2 = result;
  if (!EC_GROUP_get_order(d, result, 0))
  {
    BN_free(v2);
    return 0;
  }
  v3 = BN_num_bits(v2);
  if (v3 >= -7)
    v4 = v3 + 7;
  else
    v4 = v3 + 14;
  BN_free(v2);
  return (BIGNUM *)((uint64_t)v4 >> 3);
}

int X509v3_get_ext_count(const STACK *x)
{
  if (x)
    LODWORD(x) = sk_num(x);
  return (int)x;
}

int X509v3_get_ext_by_NID(const STACK *x, int nid, int lastpos)
{
  ASN1_OBJECT *v5;

  v5 = OBJ_nid2obj(nid);
  if (v5)
    return X509v3_get_ext_by_OBJ(x, v5, lastpos);
  else
    return -2;
}

int X509v3_get_ext_by_OBJ(const STACK *x, ASN1_OBJECT *obj, int lastpos)
{
  int v5;
  int v6;
  char *v7;

  if (x)
  {
    if (lastpos < 0)
      v5 = -1;
    else
      v5 = lastpos;
    v6 = sk_num(x);
    while (++v5 < v6)
    {
      v7 = sk_value(x, v5);
      if (!OBJ_cmp(*(const ASN1_OBJECT **)v7, obj))
        return v5;
    }
  }
  return -1;
}

int X509v3_get_ext_by_critical(const STACK *x, int crit, int lastpos)
{
  int v5;
  int v6;

  if (x)
  {
    if (lastpos < 0)
      v5 = -1;
    else
      v5 = lastpos;
    v6 = sk_num(x);
    while (++v5 < v6)
    {
      if ((crit != 0) == *((_DWORD *)sk_value(x, v5) + 2) > 0)
        return v5;
    }
  }
  return -1;
}

X509_EXTENSION *__cdecl X509v3_get_ext(const STACK *x, int loc)
{
  int v4;

  if (!x)
    return 0;
  v4 = sk_num(x);
  if (loc < 0 || v4 <= loc)
    return 0;
  else
    return (X509_EXTENSION *)sk_value(x, loc);
}

X509_EXTENSION *__cdecl X509v3_delete_ext(STACK *x, int loc)
{
  int v4;

  if (!x)
    return 0;
  v4 = sk_num(x);
  if (loc < 0 || v4 <= loc)
    return 0;
  else
    return (X509_EXTENSION *)sk_delete(x, loc);
}

STACK *__cdecl X509v3_add_ext(STACK **x, X509_EXTENSION *ex, int loc)
{
  STACK *v6;
  int v7;
  char *v8;
  X509_EXTENSION *v9;
  int v11;

  if (!x)
  {
    ERR_put_error(11, 4095, 67, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_v3.c", 167);
    return 0;
  }
  v6 = *x;
  if (!*x)
  {
    v6 = sk_new_null();
    if (!v6)
    {
      ERR_put_error(11, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_v3.c", 192);
      return v6;
    }
  }
  v7 = sk_num(v6);
  v8 = (char *)X509_EXTENSION_dup(ex);
  if (!v8)
  {
LABEL_16:
    if (v6 != *x)
      sk_free(v6);
    return 0;
  }
  v9 = (X509_EXTENSION *)v8;
  if (v7 < loc || loc < 0)
    v11 = v7;
  else
    v11 = loc;
  if (!sk_insert(v6, v8, v11))
  {
    ERR_put_error(11, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_v3.c", 192);
    X509_EXTENSION_free(v9);
    goto LABEL_16;
  }
  if (!*x)
    *x = v6;
  return v6;
}

X509_EXTENSION *__cdecl X509_EXTENSION_create_by_NID(X509_EXTENSION **ex, int nid, int crit, ASN1_OCTET_STRING *data)
{
  ASN1_OBJECT *v7;
  ASN1_OBJECT *v8;
  X509_EXTENSION *result;

  v7 = OBJ_nid2obj(nid);
  if (v7)
  {
    v8 = v7;
    result = X509_EXTENSION_create_by_OBJ(ex, v7, crit, data);
    if (result)
      return result;
    ASN1_OBJECT_free(v8);
  }
  else
  {
    ERR_put_error(11, 4095, 109, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_v3.c", 211);
  }
  return 0;
}

X509_EXTENSION *__cdecl X509_EXTENSION_create_by_OBJ(X509_EXTENSION **ex, ASN1_OBJECT *obj, int crit, ASN1_OCTET_STRING *data)
{
  X509_EXTENSION *v8;
  int v9;

  if (ex && (v8 = *ex) != 0 || (v8 = X509_EXTENSION_new()) != 0)
  {
    if (X509_EXTENSION_set_object(v8, obj)
      && (!crit ? (v9 = -1) : (v9 = 255), v8->critical = v9, ASN1_STRING_set(v8->value, data->data, data->length)))
    {
      if (ex && !*ex)
        *ex = v8;
    }
    else
    {
      if (!ex || v8 != *ex)
        X509_EXTENSION_free(v8);
      return 0;
    }
  }
  else
  {
    ERR_put_error(11, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_v3.c", 229);
  }
  return v8;
}

int X509_EXTENSION_set_object(X509_EXTENSION *ex, ASN1_OBJECT *obj)
{
  int result;
  ASN1_OBJECT *v5;

  result = 0;
  if (ex)
  {
    if (obj)
    {
      ASN1_OBJECT_free(ex->object);
      v5 = OBJ_dup(obj);
      ex->object = v5;
      return v5 != 0;
    }
  }
  return result;
}

int X509_EXTENSION_set_critical(X509_EXTENSION *ex, int crit)
{
  ASN1_BOOLEAN v2;

  if (ex)
  {
    if (crit)
      v2 = 255;
    else
      v2 = -1;
    ex->critical = v2;
    LODWORD(ex) = 1;
  }
  return (int)ex;
}

int X509_EXTENSION_set_data(X509_EXTENSION *ex, ASN1_OCTET_STRING *data)
{
  if (ex)
    LODWORD(ex) = ASN1_STRING_set(ex->value, data->data, data->length) != 0;
  return (int)ex;
}

ASN1_OBJECT *__cdecl X509_EXTENSION_get_object(ASN1_OBJECT *ex)
{
  if (ex)
    return (ASN1_OBJECT *)ex->sn;
  return ex;
}

ASN1_OCTET_STRING *__cdecl X509_EXTENSION_get_data(ASN1_OCTET_STRING *ne)
{
  if (ne)
    return (ASN1_OCTET_STRING *)ne->flags;
  return ne;
}

int X509_EXTENSION_get_critical(X509_EXTENSION *ex)
{
  if (ex)
    LODWORD(ex) = ex->critical > 0;
  return (int)ex;
}

void ERR_load_BN_strings(void)
{
  if (!ERR_func_error_string(BN_str_functs))
  {
    ERR_load_strings(0, (ERR_STRING_DATA *)&BN_str_functs);
    ERR_load_strings(0, (ERR_STRING_DATA *)&BN_str_reasons);
  }
}

int X509_issuer_and_serial_cmp(const X509 *a, const X509 *b)
{
  X509_CINF *cert_info;
  X509_CINF *v3;
  int result;

  cert_info = a->cert_info;
  v3 = b->cert_info;
  result = ASN1_INTEGER_cmp(a->cert_info->serialNumber, b->cert_info->serialNumber);
  if (!result)
    return X509_NAME_cmp(cert_info->issuer, v3->issuer);
  return result;
}

int X509_NAME_cmp(const X509_NAME *a, const X509_NAME *b)
{
  size_t entries_low;
  int entries;
  int result;

  if ((!a->hash || a->modified) && i2d_X509_NAME((X509_NAME *)a, 0) < 0
    || (!b->hash || b->modified) && i2d_X509_NAME((X509_NAME *)b, 0) < 0)
  {
    return -2;
  }
  entries_low = SLODWORD(a[1].entries);
  entries = (int)b[1].entries;
  result = entries_low - entries;
  if ((_DWORD)entries_low == entries)
    return memcmp((const void *)a->hash, (const void *)b->hash, entries_low);
  return result;
}

unint64_t X509_issuer_and_serial_hash(X509 *a)
{
  char *v2;
  const EVP_MD *v3;
  size_t v4;
  unint64_t v5;
  EVP_MD_CTX v7;
  __int128 v8;
  unsigned __int8 md[4];
  uint64_t v10;

  v10 = *MEMORY[0x24BDAC8D0];
  v8 = 0u;
  memset(&v7, 0, sizeof(v7));
  EVP_MD_CTX_init(&v7);
  v2 = X509_NAME_oneline(a->cert_info->issuer, 0, 0);
  if (v2 && (v3 = EVP_md5(), EVP_DigestInit_ex(&v7, v3, 0)) && (v4 = strlen(v2), EVP_DigestUpdate(&v7, v2, v4)))
  {
    free(v2);
    if (EVP_DigestUpdate(&v7, a->cert_info->serialNumber->data, a->cert_info->serialNumber->length)
      && EVP_DigestFinal_ex(&v7, md, 0))
    {
      v2 = 0;
      v5 = *(unsigned int *)md;
    }
    else
    {
      v5 = 0;
      v2 = 0;
    }
  }
  else
  {
    v5 = 0;
  }
  EVP_MD_CTX_cleanup(&v7);
  free(v2);
  return v5;
}

int X509_issuer_name_cmp(const X509 *a, const X509 *b)
{
  return X509_NAME_cmp(a->cert_info->issuer, b->cert_info->issuer);
}

int X509_subject_name_cmp(const X509 *a, const X509 *b)
{
  return X509_NAME_cmp(a->cert_info->subject, b->cert_info->subject);
}

int X509_CRL_cmp(const X509_CRL *a, const X509_CRL *b)
{
  return X509_NAME_cmp(a->crl->issuer, b->crl->issuer);
}

uint64_t X509_CRL_match(uint64_t a1, uint64_t a2)
{
  return memcmp((const void *)(a1 + 72), (const void *)(a2 + 72), 0x40uLL);
}

X509_NAME *__cdecl X509_get_issuer_name(X509 *a)
{
  return a->cert_info->issuer;
}

unint64_t X509_issuer_name_hash(X509 *a)
{
  return X509_NAME_hash(a->cert_info->issuer);
}

unint64_t X509_NAME_hash(X509_NAME *x)
{
  const void *hash;
  size_t entries_low;
  const EVP_MD *v4;
  unsigned __int8 md[4];
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  i2d_X509_NAME(x, 0);
  hash = (const void *)x->hash;
  entries_low = SLODWORD(x[1].entries);
  v4 = EVP_sha1();
  if (EVP_Digest(hash, entries_low, md, 0, v4, 0))
    return *(unsigned int *)md;
  else
    return 0;
}

uint64_t X509_issuer_name_hash_old(uint64_t a1)
{
  return X509_NAME_hash_old(*(_QWORD *)(*(_QWORD *)a1 + 24));
}

uint64_t X509_NAME_hash_old(uint64_t a1)
{
  const EVP_MD *v2;
  uint64_t v3;
  EVP_MD_CTX v5;
  __int128 v6;
  unsigned __int8 md[4];
  uint64_t v8;

  v8 = *MEMORY[0x24BDAC8D0];
  v6 = 0u;
  memset(&v5, 0, sizeof(v5));
  i2d_X509_NAME((X509_NAME *)a1, 0);
  EVP_MD_CTX_init(&v5);
  v2 = EVP_md5();
  if (EVP_DigestInit_ex(&v5, v2, 0)
    && EVP_DigestUpdate(&v5, *(const void **)(*(_QWORD *)(a1 + 16) + 8), **(_QWORD **)(a1 + 16))
    && EVP_DigestFinal_ex(&v5, md, 0))
  {
    v3 = *(unsigned int *)md;
  }
  else
  {
    v3 = 0;
  }
  EVP_MD_CTX_cleanup(&v5);
  return v3;
}

X509_NAME *__cdecl X509_get_subject_name(X509 *a)
{
  return a->cert_info->subject;
}

ASN1_INTEGER *__cdecl X509_get_serialNumber(X509 *x)
{
  return x->cert_info->serialNumber;
}

uint64_t X509_get0_serialNumber(uint64_t a1)
{
  return *(_QWORD *)(*(_QWORD *)a1 + 8);
}

unint64_t X509_subject_name_hash(X509 *x)
{
  return X509_NAME_hash(x->cert_info->subject);
}

uint64_t X509_subject_name_hash_old(uint64_t a1)
{
  return X509_NAME_hash_old(*(_QWORD *)(*(_QWORD *)a1 + 40));
}

int X509_cmp(const X509 *a, const X509 *b)
{
  X509_check_purpose((X509 *)a, -1, 0);
  X509_check_purpose((X509 *)b, -1, 0);
  return memcmp(&a->sha1_hash[16], &b->sha1_hash[16], 0x40uLL);
}

X509 *__cdecl X509_find_by_issuer_and_serial(STACK *sk, X509_NAME *name, ASN1_INTEGER *serial)
{
  int v4;
  X509 *v5;
  _QWORD v7[4];
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  uint64_t v12;
  _BYTE b[168];
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  uint64_t v18;

  v18 = *MEMORY[0x24BDAC8D0];
  if (!sk)
    return 0;
  v7[0] = 0;
  v7[2] = 0;
  v12 = 0;
  v10 = 0u;
  v11 = 0u;
  v8 = 0u;
  v9 = 0u;
  *(_QWORD *)b = v7;
  v7[1] = serial;
  v7[3] = name;
  if (sk_num(sk) < 1)
    return 0;
  v4 = 0;
  v16 = 0u;
  v17 = 0u;
  v14 = 0u;
  v15 = 0u;
  memset(&b[8], 0, 160);
  while (1)
  {
    v5 = (X509 *)sk_value(sk, v4);
    if (!X509_issuer_and_serial_cmp(v5, (const X509 *)b))
      break;
    if (++v4 >= sk_num(sk))
      return 0;
  }
  return v5;
}

X509 *__cdecl X509_find_by_subject(STACK *sk, X509_NAME *name)
{
  int v4;
  char *v5;

  if (sk_num(sk) < 1)
    return 0;
  v4 = 0;
  while (1)
  {
    v5 = sk_value(sk, v4);
    if (!X509_NAME_cmp(*(const X509_NAME **)(*(_QWORD *)v5 + 40), name))
      break;
    if (++v4 >= sk_num(sk))
      return 0;
  }
  return (X509 *)v5;
}

EVP_PKEY *__cdecl X509_get_pubkey(X509 *x)
{
  if (x && x->cert_info)
    return X509_PUBKEY_get(x->cert_info->key);
  else
    return 0;
}

EVP_PKEY *X509_get0_pubkey(uint64_t a1)
{
  if (a1 && *(_QWORD *)a1)
    return X509_PUBKEY_get0(*(_QWORD *)(*(_QWORD *)a1 + 48));
  else
    return 0;
}

ASN1_BIT_STRING *__cdecl X509_get0_pubkey_bitstr(ASN1_BIT_STRING *x)
{
  if (x)
    return *(ASN1_BIT_STRING **)(*(_QWORD *)(*(_QWORD *)&x->length + 48) + 8);
  return x;
}

int X509_check_private_key(X509 *x509, EVP_PKEY *pkey)
{
  EVP_PKEY *v3;
  int v4;

  if (x509
    && x509->cert_info
    && (v3 = X509_PUBKEY_get0((uint64_t)x509->cert_info->key)) != 0
    && (v4 = EVP_PKEY_cmp(v3, pkey), v4 != -2))
  {
    if (v4 == -1)
    {
      ERR_put_error(11, 4095, 115, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_cmp.c", 397);
      v4 = -1;
    }
    else if (!v4)
    {
      ERR_put_error(11, 4095, 116, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_cmp.c", 394);
      v4 = 0;
    }
  }
  else
  {
    ERR_put_error(11, 4095, 117, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_cmp.c", 400);
    v4 = -2;
  }
  return v4 > 0;
}

STACK *X509_chain_up_ref(STACK *a1)
{
  STACK *v1;
  unint64_t v2;
  char *v3;

  v1 = sk_dup(a1);
  if (sk_num(v1))
  {
    v2 = 0;
    do
    {
      v3 = sk_value(v1, v2);
      X509_up_ref((uint64_t)v3);
      ++v2;
    }
    while (v2 < sk_num(v1));
  }
  return v1;
}

