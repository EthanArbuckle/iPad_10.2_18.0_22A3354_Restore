uint64_t sub_22D3DE3A4()
{
  swift_getObjCClassMetadata();
  return sub_22D3DD92C();
}

void sub_22D3DE3C8()
{
  sub_22D3DE660();
}

void sub_22D3DE3D4()
{
  sub_22D3DE770();
}

void sub_22D3DE3E0()
{
  uint64_t v0;

  v0 = OUTLINED_FUNCTION_40_8();
  OUTLINED_FUNCTION_39_4(v0);
  OUTLINED_FUNCTION_9_12();
  OUTLINED_FUNCTION_30_5();
}

void sub_22D3DE408()
{
  sub_22D3DE71C();
}

void sub_22D3DE424()
{
  sub_22D3DE6B8();
}

void sub_22D3DE430()
{
  OUTLINED_FUNCTION_40_8();
  OUTLINED_FUNCTION_37_8();
  OUTLINED_FUNCTION_9_12();
  OUTLINED_FUNCTION_30_5();
}

void sub_22D3DE458(uint64_t a1, char a2)
{
  __asm { BR              X10 }
}

uint64_t sub_22D3DE498()
{
  OUTLINED_FUNCTION_8_12();
  return OUTLINED_FUNCTION_2_14();
}

uint64_t sub_22D3DE53C()
{
  OUTLINED_FUNCTION_8_12();
  return OUTLINED_FUNCTION_2_14();
}

uint64_t sub_22D3DE580()
{
  OUTLINED_FUNCTION_8_12();
  return OUTLINED_FUNCTION_2_14();
}

uint64_t sub_22D3DE5D8()
{
  OUTLINED_FUNCTION_8_12();
  return OUTLINED_FUNCTION_2_14();
}

uint64_t sub_22D3DE61C()
{
  OUTLINED_FUNCTION_8_12();
  return OUTLINED_FUNCTION_2_14();
}

void sub_22D3DE660()
{
  OUTLINED_FUNCTION_7_12();
  OUTLINED_FUNCTION_8_12();
  OUTLINED_FUNCTION_2_4();
  OUTLINED_FUNCTION_9_12();
  OUTLINED_FUNCTION_30_5();
}

void sub_22D3DE6B8()
{
  OUTLINED_FUNCTION_7_12();
  OUTLINED_FUNCTION_8_12();
  OUTLINED_FUNCTION_2_4();
  OUTLINED_FUNCTION_9_12();
  OUTLINED_FUNCTION_30_5();
}

void sub_22D3DE71C()
{
  OUTLINED_FUNCTION_7_12();
  OUTLINED_FUNCTION_8_12();
  OUTLINED_FUNCTION_2_4();
  OUTLINED_FUNCTION_9_12();
  OUTLINED_FUNCTION_30_5();
}

void sub_22D3DE770()
{
  OUTLINED_FUNCTION_7_12();
  OUTLINED_FUNCTION_8_12();
  OUTLINED_FUNCTION_2_4();
  OUTLINED_FUNCTION_9_12();
  OUTLINED_FUNCTION_30_5();
}

void sub_22D3DE7C4()
{
  sub_22D666BB4();
  OUTLINED_FUNCTION_37_8();
  OUTLINED_FUNCTION_9_12();
  OUTLINED_FUNCTION_30_5();
}

void sub_22D3DE7F0()
{
  uint64_t v0;

  v0 = OUTLINED_FUNCTION_7_12();
  OUTLINED_FUNCTION_39_4(v0);
  OUTLINED_FUNCTION_9_12();
  OUTLINED_FUNCTION_30_5();
}

uint64_t sub_22D3DE814()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  __swift_instantiateConcreteTypeFromMangledName((uint64_t *)&unk_254097F30);
  OUTLINED_FUNCTION_0_1();
  MEMORY[0x24BDAC7A8](v0);
  OUTLINED_FUNCTION_4_4();
  v1 = sub_22D665A08();
  OUTLINED_FUNCTION_0_1();
  MEMORY[0x24BDAC7A8](v2);
  OUTLINED_FUNCTION_16_14();
  sub_22D6659E4();
  OUTLINED_FUNCTION_28_6();
  __swift_storeEnumTagSinglePayload(v3, v4, v5, v1);
  return sub_22D665870();
}

uint64_t sub_22D3DE8B4()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v16;
  void (*v17)(uint64_t, uint64_t, uint64_t);
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;

  __swift_instantiateConcreteTypeFromMangledName(&qword_254096DF8);
  OUTLINED_FUNCTION_0_1();
  MEMORY[0x24BDAC7A8](v0);
  OUTLINED_FUNCTION_19_2();
  v22 = v1;
  __swift_instantiateConcreteTypeFromMangledName((uint64_t *)&unk_254097F30);
  OUTLINED_FUNCTION_0_1();
  MEMORY[0x24BDAC7A8](v2);
  OUTLINED_FUNCTION_19_2();
  v21 = v3;
  v4 = OUTLINED_FUNCTION_32_7();
  v5 = *(_QWORD *)(v4 - 8);
  MEMORY[0x24BDAC7A8](v4);
  OUTLINED_FUNCTION_19_2();
  v19 = v6;
  sub_22D665B58();
  OUTLINED_FUNCTION_0_1();
  MEMORY[0x24BDAC7A8](v7);
  OUTLINED_FUNCTION_26_2();
  sub_22D66656C();
  OUTLINED_FUNCTION_0_1();
  MEMORY[0x24BDAC7A8](v8);
  v16 = OUTLINED_FUNCTION_12_12();
  MEMORY[0x24BDAC7A8](v16);
  OUTLINED_FUNCTION_4_2();
  __swift_instantiateConcreteTypeFromMangledName(&qword_255D817D0);
  v9 = *(_QWORD *)(__swift_instantiateConcreteTypeFromMangledName(&qword_255D817D8) - 8);
  v18 = *(_QWORD *)(v9 + 72);
  v10 = (*(unsigned __int8 *)(v9 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v9 + 80);
  v20 = swift_allocObject();
  *(_OWORD *)(v20 + 16) = xmmword_22D686D40;
  *(_BYTE *)(v20 + v10) = 0;
  sub_22D666518();
  sub_22D665B4C();
  v11 = *MEMORY[0x24BDCD328];
  v17 = *(void (**)(uint64_t, uint64_t, uint64_t))(v5 + 104);
  v17(v19, v11, v4);
  OUTLINED_FUNCTION_8_2();
  OUTLINED_FUNCTION_4_19(v21);
  sub_22D665750();
  OUTLINED_FUNCTION_4_19(v22);
  OUTLINED_FUNCTION_17_11();
  *(_BYTE *)(v20 + v10 + v18) = 1;
  sub_22D666518();
  sub_22D665B4C();
  v17(v19, v11, v4);
  OUTLINED_FUNCTION_8_2();
  OUTLINED_FUNCTION_28_6();
  __swift_storeEnumTagSinglePayload(v12, v13, v14, v16);
  OUTLINED_FUNCTION_4_19(v22);
  OUTLINED_FUNCTION_17_11();
  sub_22D665768();
  sub_22D3DEFB4();
  return sub_22D6664C4();
}

uint64_t sub_22D3DEB94()
{
  uint64_t v0;
  unsigned int v1;

  v0 = sub_22D666ADC();
  OUTLINED_FUNCTION_2_4();
  if (v0 == 1)
    v1 = 1;
  else
    v1 = 2;
  if (v0)
    return v1;
  else
    return 0;
}

unint64_t sub_22D3DEBE4()
{
  unint64_t result;

  result = qword_2540972D0;
  if (!qword_2540972D0)
  {
    result = MEMORY[0x22E3159EC](&unk_22D68CDC4, &type metadata for ToggleCellularPlanAction.ToggleCellularPlanOperation);
    atomic_store(result, (unint64_t *)&qword_2540972D0);
  }
  return result;
}

uint64_t sub_22D3DEC20()
{
  return sub_22D3DE5D8();
}

void sub_22D3DEC38()
{
  sub_22D3DE71C();
}

uint64_t sub_22D3DEC50@<X0>(_BYTE *a1@<X8>)
{
  uint64_t result;

  result = sub_22D3DEB94();
  *a1 = result;
  return result;
}

void sub_22D3DEC7C()
{
  sub_22D3803F8(&qword_255D81738, (uint64_t *)&unk_255D81740, MEMORY[0x24BEE12E0]);
}

void sub_22D3DECA8(_QWORD *a1@<X8>)
{
  *a1 = &unk_24F890D78;
}

unint64_t sub_22D3DECBC()
{
  unint64_t result;

  result = qword_254097290;
  if (!qword_254097290)
  {
    result = MEMORY[0x22E3159EC](&unk_22D68CEDC, &type metadata for ToggleCellularPlanAction.ToggleCellularPlanOperation);
    atomic_store(result, (unint64_t *)&qword_254097290);
  }
  return result;
}

unint64_t sub_22D3DECFC()
{
  unint64_t result;

  result = qword_2540972B8;
  if (!qword_2540972B8)
  {
    result = MEMORY[0x22E3159EC](&unk_22D68CF14, &type metadata for ToggleCellularPlanAction.ToggleCellularPlanOperation);
    atomic_store(result, (unint64_t *)&qword_2540972B8);
  }
  return result;
}

unint64_t sub_22D3DED3C()
{
  unint64_t result;

  result = qword_2540972D8;
  if (!qword_2540972D8)
  {
    result = MEMORY[0x22E3159EC](&unk_22D68CE2C, &type metadata for ToggleCellularPlanAction.ToggleCellularPlanOperation);
    atomic_store(result, (unint64_t *)&qword_2540972D8);
  }
  return result;
}

unint64_t sub_22D3DED7C()
{
  unint64_t result;

  result = qword_2540972A8;
  if (!qword_2540972A8)
  {
    result = MEMORY[0x22E3159EC](&unk_22D68CF44, &type metadata for ToggleCellularPlanAction.ToggleCellularPlanOperation);
    atomic_store(result, (unint64_t *)&qword_2540972A8);
  }
  return result;
}

unint64_t sub_22D3DEDBC()
{
  unint64_t result;

  result = qword_2540972B0;
  if (!qword_2540972B0)
  {
    result = MEMORY[0x22E3159EC](&unk_22D68CF6C, &type metadata for ToggleCellularPlanAction.ToggleCellularPlanOperation);
    atomic_store(result, (unint64_t *)&qword_2540972B0);
  }
  return result;
}

unint64_t sub_22D3DEDFC()
{
  unint64_t result;

  result = qword_254097298;
  if (!qword_254097298)
  {
    result = MEMORY[0x22E3159EC](&unk_22D68CF94, &type metadata for ToggleCellularPlanAction.ToggleCellularPlanOperation);
    atomic_store(result, (unint64_t *)&qword_254097298);
  }
  return result;
}

unint64_t sub_22D3DEE3C()
{
  unint64_t result;

  result = qword_2540972A0;
  if (!qword_2540972A0)
  {
    result = MEMORY[0x22E3159EC](&unk_22D68CFEC, &type metadata for ToggleCellularPlanAction.ToggleCellularPlanOperation);
    atomic_store(result, (unint64_t *)&qword_2540972A0);
  }
  return result;
}

uint64_t sub_22D3DEE7C()
{
  sub_22D3DEEBC();
  return swift_getOpaqueTypeConformance2();
}

unint64_t sub_22D3DEEBC()
{
  unint64_t result;

  result = qword_254096E30;
  if (!qword_254096E30)
  {
    result = MEMORY[0x22E3159EC](&unk_22D68CE9C, &type metadata for ToggleCellularPlanAction.ToggleCellularPlanOperation);
    atomic_store(result, (unint64_t *)&qword_254096E30);
  }
  return result;
}

uint64_t sub_22D3DEEF8()
{
  sub_22D3DEEBC();
  return sub_22D665510();
}

unint64_t sub_22D3DEF34()
{
  unint64_t result;

  result = qword_2540972C0;
  if (!qword_2540972C0)
  {
    result = MEMORY[0x22E3159EC](&unk_22D68D02C, &type metadata for ToggleCellularPlanAction.ToggleCellularPlanOperation);
    atomic_store(result, (unint64_t *)&qword_2540972C0);
  }
  return result;
}

unint64_t sub_22D3DEF74()
{
  unint64_t result;

  result = qword_2540972E0;
  if (!qword_2540972E0)
  {
    result = MEMORY[0x22E3159EC](&unk_22D68CE64, &type metadata for ToggleCellularPlanAction.ToggleCellularPlanOperation);
    atomic_store(result, (unint64_t *)&qword_2540972E0);
  }
  return result;
}

unint64_t sub_22D3DEFB4()
{
  unint64_t result;

  result = qword_2540972C8;
  if (!qword_2540972C8)
  {
    result = MEMORY[0x22E3159EC](&unk_22D68CDEC, &type metadata for ToggleCellularPlanAction.ToggleCellularPlanOperation);
    atomic_store(result, (unint64_t *)&qword_2540972C8);
  }
  return result;
}

uint64_t sub_22D3DEFF4()
{
  sub_22D3DEE3C();
  return sub_22D665828();
}

unint64_t sub_22D3DF030()
{
  unint64_t result;

  result = qword_254096FF0;
  if (!qword_254096FF0)
  {
    result = MEMORY[0x22E3159EC](&unk_22D68D10C, &type metadata for ToggleCellularPlanAction);
    atomic_store(result, (unint64_t *)&qword_254096FF0);
  }
  return result;
}

unint64_t sub_22D3DF070()
{
  unint64_t result;

  result = qword_2540972E8;
  if (!qword_2540972E8)
  {
    result = MEMORY[0x22E3159EC](&unk_22D68D134, &type metadata for ToggleCellularPlanAction);
    atomic_store(result, (unint64_t *)&qword_2540972E8);
  }
  return result;
}

uint64_t sub_22D3DF0AC()
{
  return swift_getOpaqueTypeConformance2();
}

uint64_t sub_22D3DF0BC()
{
  return swift_getOpaqueTypeConformance2();
}

uint64_t sub_22D3DF0CC()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;

  v0 = OUTLINED_FUNCTION_32_7();
  v1 = *(_QWORD *)(v0 - 8);
  MEMORY[0x24BDAC7A8](v0);
  OUTLINED_FUNCTION_4_4();
  sub_22D665B58();
  OUTLINED_FUNCTION_0_1();
  MEMORY[0x24BDAC7A8](v2);
  OUTLINED_FUNCTION_5_3();
  sub_22D66656C();
  OUTLINED_FUNCTION_0_1();
  MEMORY[0x24BDAC7A8](v3);
  OUTLINED_FUNCTION_26_2();
  sub_22D666518();
  sub_22D665B4C();
  OUTLINED_FUNCTION_46(*MEMORY[0x24BDCD328], *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v1 + 104));
  OUTLINED_FUNCTION_10_1();
  return OUTLINED_FUNCTION_8_2();
}

uint64_t sub_22D3DF1A8()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  __swift_instantiateConcreteTypeFromMangledName((uint64_t *)&unk_254097F30);
  OUTLINED_FUNCTION_0_1();
  MEMORY[0x24BDAC7A8](v1);
  OUTLINED_FUNCTION_4_4();
  v2 = sub_22D6659F0();
  v3 = *(_QWORD *)(v2 - 8);
  MEMORY[0x24BDAC7A8](v2);
  OUTLINED_FUNCTION_5_3();
  sub_22D665B58();
  OUTLINED_FUNCTION_0_1();
  MEMORY[0x24BDAC7A8](v4);
  OUTLINED_FUNCTION_4_2();
  sub_22D66656C();
  OUTLINED_FUNCTION_0_1();
  MEMORY[0x24BDAC7A8](v5);
  OUTLINED_FUNCTION_2_2();
  v6 = sub_22D665A08();
  MEMORY[0x24BDAC7A8](v6);
  OUTLINED_FUNCTION_2_2();
  sub_22D666518();
  sub_22D665B4C();
  (*(void (**)(uint64_t, _QWORD, uint64_t))(v3 + 104))(v0, *MEMORY[0x24BDCD328], v2);
  OUTLINED_FUNCTION_10_1();
  OUTLINED_FUNCTION_8_2();
  OUTLINED_FUNCTION_28_6();
  __swift_storeEnumTagSinglePayload(v7, v8, v9, v6);
  __swift_instantiateConcreteTypeFromMangledName(&qword_255D80118);
  *(_OWORD *)(swift_allocObject() + 16) = xmmword_22D68C980;
  OUTLINED_FUNCTION_7_2();
  OUTLINED_FUNCTION_7_2();
  OUTLINED_FUNCTION_7_2();
  OUTLINED_FUNCTION_7_2();
  OUTLINED_FUNCTION_13_2();
  OUTLINED_FUNCTION_40_1();
  OUTLINED_FUNCTION_13_2();
  OUTLINED_FUNCTION_36_6();
  OUTLINED_FUNCTION_13_2();
  OUTLINED_FUNCTION_13_2();
  OUTLINED_FUNCTION_40_1();
  OUTLINED_FUNCTION_36_6();
  OUTLINED_FUNCTION_36_6();
  OUTLINED_FUNCTION_13_2();
  OUTLINED_FUNCTION_13_2();
  sub_22D6656B4();
  v10 = sub_22D6656A8();
  return OUTLINED_FUNCTION_3_3(v10);
}

uint64_t sub_22D3DF478()
{
  swift_getKeyPath();
  __swift_instantiateConcreteTypeFromMangledName(&qword_255D81768);
  sub_22D3E0A04();
  sub_22D3803F8(&qword_255D81770, &qword_255D81768, MEMORY[0x24BDB6560]);
  return sub_22D665900();
}

uint64_t sub_22D3DF508@<X0>(uint64_t a1@<X8>)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  char *v9;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  char *v15;
  uint64_t v16;
  char *v17;
  char *v18;
  void (*v19)(char *, uint64_t);
  _QWORD v21[3];
  uint64_t v22;
  char *v23;
  char *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  char v28;

  v27 = a1;
  v1 = __swift_instantiateConcreteTypeFromMangledName(&qword_255D81778);
  v2 = *(_QWORD *)(v1 - 8);
  v25 = v1;
  v26 = v2;
  v3 = MEMORY[0x24BDAC7A8](v1);
  v23 = (char *)v21 - ((v4 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x24BDAC7A8](v3);
  v24 = (char *)v21 - v5;
  v6 = __swift_instantiateConcreteTypeFromMangledName(&qword_255D81780);
  v22 = *(_QWORD *)(v6 - 8);
  v7 = MEMORY[0x24BDAC7A8](v6);
  v9 = (char *)v21 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x24BDAC7A8](v7);
  v11 = (char *)v21 - v10;
  v28 = 0;
  v12 = __swift_instantiateConcreteTypeFromMangledName(&qword_255D81788);
  sub_22D3E0A04();
  sub_22D3DEDFC();
  sub_22D3803F8(&qword_255D81790, &qword_255D81788, MEMORY[0x24BDB5F68]);
  v21[1] = v12;
  sub_22D6658F4();
  sub_22D3803F8(&qword_255D81798, &qword_255D81780, MEMORY[0x24BDB6438]);
  v21[2] = v13;
  v14 = v11;
  sub_22D665894();
  v22 = *(_QWORD *)(v22 + 8);
  ((void (*)(char *, uint64_t))v22)(v9, v6);
  v15 = v23;
  sub_22D665924();
  sub_22D3803F8(&qword_255D817A0, &qword_255D81778, MEMORY[0x24BDB6590]);
  v17 = v24;
  v16 = v25;
  v18 = v15;
  sub_22D665894();
  v19 = *(void (**)(char *, uint64_t))(v26 + 8);
  v19(v18, v16);
  sub_22D665888();
  v19(v17, v16);
  return ((uint64_t (*)(char *, uint64_t))v22)(v14, v6);
}

uint64_t sub_22D3DF7B8@<X0>(uint64_t a1@<X8>)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  char *v7;
  uint64_t v8;
  char *v9;
  void (*v10)(char *, uint64_t);
  _QWORD v12[2];

  v12[1] = a1;
  v1 = __swift_instantiateConcreteTypeFromMangledName(&qword_255D817A8);
  MEMORY[0x24BDAC7A8](v1);
  v2 = __swift_instantiateConcreteTypeFromMangledName(&qword_255D817B0);
  MEMORY[0x24BDAC7A8](v2);
  v3 = __swift_instantiateConcreteTypeFromMangledName(&qword_255D81788);
  v4 = *(_QWORD *)(v3 - 8);
  v5 = MEMORY[0x24BDAC7A8](v3);
  v7 = (char *)v12 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x24BDAC7A8](v5);
  v9 = (char *)v12 - v8;
  sub_22D3E0A04();
  sub_22D6657E0();
  sub_22D6657D4();
  swift_getKeyPath();
  __swift_instantiateConcreteTypeFromMangledName(&qword_255D817B8);
  sub_22D6657C8();
  swift_release();
  sub_22D6657D4();
  swift_getKeyPath();
  __swift_instantiateConcreteTypeFromMangledName(&qword_255D817C8);
  sub_22D6657C8();
  swift_release();
  sub_22D6657D4();
  swift_getKeyPath();
  __swift_instantiateConcreteTypeFromMangledName(&qword_255D817C0);
  sub_22D6657C8();
  swift_release();
  sub_22D6657D4();
  sub_22D6657F8();
  sub_22D6657B0();
  sub_22D3803F8(&qword_255D81790, &qword_255D81788, MEMORY[0x24BDB5F68]);
  sub_22D665810();
  v10 = *(void (**)(char *, uint64_t))(v4 + 8);
  v10(v7, v3);
  sub_22D665810();
  return ((uint64_t (*)(char *, uint64_t))v10)(v9, v3);
}

uint64_t sub_22D3DFA98@<X0>(uint64_t a1@<X8>)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  char *v7;
  uint64_t v8;
  char *v9;
  void (*v10)(char *, uint64_t);
  _QWORD v12[2];

  v12[1] = a1;
  v1 = __swift_instantiateConcreteTypeFromMangledName(&qword_255D817A8);
  MEMORY[0x24BDAC7A8](v1);
  v2 = __swift_instantiateConcreteTypeFromMangledName(&qword_255D817B0);
  MEMORY[0x24BDAC7A8](v2);
  v3 = __swift_instantiateConcreteTypeFromMangledName(&qword_255D81788);
  v4 = *(_QWORD *)(v3 - 8);
  v5 = MEMORY[0x24BDAC7A8](v3);
  v7 = (char *)v12 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x24BDAC7A8](v5);
  v9 = (char *)v12 - v8;
  sub_22D3E0A04();
  sub_22D6657E0();
  sub_22D6657D4();
  swift_getKeyPath();
  __swift_instantiateConcreteTypeFromMangledName(&qword_255D817B8);
  sub_22D6657C8();
  swift_release();
  sub_22D6657D4();
  swift_getKeyPath();
  __swift_instantiateConcreteTypeFromMangledName(&qword_255D817C0);
  sub_22D6657C8();
  swift_release();
  sub_22D6657D4();
  sub_22D6657F8();
  sub_22D6657B0();
  sub_22D3803F8(&qword_255D81790, &qword_255D81788, MEMORY[0x24BDB5F68]);
  sub_22D665810();
  v10 = *(void (**)(char *, uint64_t))(v4 + 8);
  v10(v7, v3);
  sub_22D665810();
  return ((uint64_t (*)(char *, uint64_t))v10)(v9, v3);
}

void sub_22D3DFD34()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  uint64_t v6;
  id v7;
  uint64_t v8;

  __swift_instantiateConcreteTypeFromMangledName((uint64_t *)&unk_254097918);
  OUTLINED_FUNCTION_0_1();
  MEMORY[0x24BDAC7A8](v0);
  OUTLINED_FUNCTION_19_3();
  v1 = sub_22D665F84();
  v2 = *(_QWORD *)(v1 - 8);
  MEMORY[0x24BDAC7A8](v1);
  v4 = (uint64_t *)((char *)&v8 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0));
  *v4 = sub_22D6665A8();
  v4[1] = v5;
  OUTLINED_FUNCTION_46(*MEMORY[0x24BEC3638], *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v2 + 104));
  sub_22D665FA8();
  v6 = sub_22D665F9C();
  OUTLINED_FUNCTION_3_3(v6);
  type metadata accessor for Key(0);
  sub_22D364498();
  sub_22D6664C4();
  v7 = objc_allocWithZone((Class)sub_22D665FB4());
  sub_22D665F90();
  OUTLINED_FUNCTION_19_0();
}

uint64_t sub_22D3DFE70(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v4;
  uint64_t v5;

  v4[27] = a3;
  v4[28] = a4;
  v4[25] = a1;
  v4[26] = a2;
  v5 = sub_22D6660E0();
  v4[29] = v5;
  v4[30] = *(_QWORD *)(v5 - 8);
  v4[31] = swift_task_alloc();
  return swift_task_switch();
}

uint64_t sub_22D3DFF00()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  void *v9;
  void *v10;
  id v11;
  unsigned int v12;
  unsigned int v13;
  void *v14;
  id v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t (*v26)(void);
  _BYTE *v27;
  NSObject *v28;
  os_log_type_t v29;
  _BOOL4 v30;
  uint8_t *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  unsigned __int8 v37;
  id v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  _BYTE *v48;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63[2];

  v63[1] = *MEMORY[0x24BDAC8D0];
  sub_22D665630();
  v1 = *(_QWORD *)(v0 + 96);
  if (!v1)
  {
    sub_22D3802E8();
    OUTLINED_FUNCTION_31();
    *v27 = 1;
    swift_willThrow();
LABEL_13:
    swift_task_dealloc();
    v26 = *(uint64_t (**)(void))(v0 + 8);
    return v26();
  }
  v59 = v0 + 184;
  v2 = *(_QWORD *)(v0 + 104);
  v3 = *(_QWORD *)(v0 + 112);
  v4 = *(_QWORD *)(v0 + 120);
  v5 = *(_QWORD *)(v0 + 128);
  v6 = *(_QWORD *)(v0 + 136);
  v7 = *(_QWORD *)(v0 + 144);
  v8 = *(_QWORD *)(v0 + 152);
  v61 = *(_QWORD *)(v0 + 88);
  *(_QWORD *)(v0 + 16) = v61;
  *(_QWORD *)(v0 + 24) = v1;
  *(_QWORD *)(v0 + 32) = v2;
  *(_QWORD *)(v0 + 40) = v3;
  *(_QWORD *)(v0 + 48) = v4;
  *(_QWORD *)(v0 + 56) = v5;
  *(_QWORD *)(v0 + 64) = v6;
  *(_QWORD *)(v0 + 72) = v7;
  *(_QWORD *)(v0 + 80) = v8;
  sub_22D3A0110(v0 + 16);
  v62 = v1;
  if (!v9)
  {
    sub_22D666098();
    swift_bridgeObjectRetain_n();
    OUTLINED_FUNCTION_10_3();
    OUTLINED_FUNCTION_10_3();
    OUTLINED_FUNCTION_10_3();
    OUTLINED_FUNCTION_10_3();
    OUTLINED_FUNCTION_10_3();
    OUTLINED_FUNCTION_10_3();
    OUTLINED_FUNCTION_10_3();
    v28 = sub_22D6660D4();
    v29 = sub_22D666818();
    v30 = os_log_type_enabled(v28, v29);
    v55 = *(_QWORD *)(v0 + 240);
    v57 = *(_QWORD *)(v0 + 232);
    v58 = *(_QWORD *)(v0 + 248);
    if (v30)
    {
      v31 = (uint8_t *)swift_slowAlloc();
      v63[0] = swift_slowAlloc();
      *(_DWORD *)v31 = 136315138;
      sub_22D6655D0();
      *(_QWORD *)(v0 + 176) = sub_22D3A8B54(*(_QWORD *)(v0 + 160), *(_QWORD *)(v0 + 168), v63);
      sub_22D666944();
      swift_bridgeObjectRelease();
      OUTLINED_FUNCTION_21_12();
      sub_22D380324(v32, v33);
      OUTLINED_FUNCTION_21_12();
      sub_22D380324(v34, v35);
      _os_log_impl(&dword_22D353000, v28, v29, "Could not find cellular plan with matching label %s", v31, 0xCu);
      swift_arrayDestroy();
      OUTLINED_FUNCTION_51();
    }
    OUTLINED_FUNCTION_10_11(v61);
    OUTLINED_FUNCTION_10_11(v61);

    (*(void (**)(uint64_t, uint64_t))(v55 + 8))(v58, v57);
    sub_22D3802E8();
    OUTLINED_FUNCTION_31();
    *v48 = 0;
    swift_willThrow();
    v46 = v61;
    v47 = v62;
    goto LABEL_12;
  }
  v10 = v9;
  v60 = v3;
  v11 = objc_msgSend(objc_allocWithZone((Class)WFCellularPlansManager), sel_init);
  sub_22D665630();
  if ((*(_BYTE *)(v0 + 257) & 1) == 0)
  {
    sub_22D665630();
    v36 = *(unsigned __int8 *)(v0 + 256);
    *(_QWORD *)(v0 + 184) = 0;
    v37 = objc_msgSend(v11, sel_setPlanStatus_forPlan_error_, v36, v10, v59);
    v14 = *(void **)(v0 + 184);
    if ((v37 & 1) != 0)
      goto LABEL_5;
    goto LABEL_10;
  }
  v12 = objc_msgSend(v10, sel_isActive);
  *(_QWORD *)(v0 + 192) = 0;
  v13 = objc_msgSend(v11, sel_setPlanStatus_forPlan_error_, v12 ^ 1, v10, v0 + 192);
  v14 = *(void **)(v0 + 192);
  if (!v13)
  {
LABEL_10:
    v38 = v14;
    sub_22D6659D8();

    swift_willThrow();
    v46 = OUTLINED_FUNCTION_34_9(v39, v40, v41, v42, v43, v5, v44, v45, v50, v51, v52, v53, v54, v56, v5, v8, v59, v60, v61);
LABEL_12:
    sub_22D380324(v46, v47);
    goto LABEL_13;
  }
LABEL_5:
  v15 = v14;
  sub_22D6655C4();

  v24 = OUTLINED_FUNCTION_34_9(v16, v17, v18, v19, v20, v21, v22, v23, v50, v51, v52, v53, v54, v56, v5, v8, v59, v60, v61);
  sub_22D380324(v24, v25);
  swift_task_dealloc();
  v26 = *(uint64_t (**)(void))(v0 + 8);
  return v26();
}

uint64_t sub_22D3E03A4()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  char *v6;
  uint64_t v7;
  char *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  void (*v26)(uint64_t);
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  char *v32;
  void (*v33)(uint64_t);
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  unsigned int v38;
  uint64_t v39;
  int v40;
  void (*v41)(uint64_t);
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  uint64_t v49;

  __swift_instantiateConcreteTypeFromMangledName(&qword_254096F60);
  OUTLINED_FUNCTION_0_1();
  MEMORY[0x24BDAC7A8](v0);
  OUTLINED_FUNCTION_19_2();
  v37 = v1;
  v44 = sub_22D665804();
  v36 = *(_QWORD *)(v44 - 8);
  MEMORY[0x24BDAC7A8](v44);
  OUTLINED_FUNCTION_19_2();
  v43 = v2;
  __swift_instantiateConcreteTypeFromMangledName(&qword_254096DA0);
  OUTLINED_FUNCTION_0_1();
  v4 = MEMORY[0x24BDAC7A8](v3);
  v6 = (char *)&v32 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x24BDAC7A8](v4);
  v8 = (char *)&v32 - v7;
  __swift_instantiateConcreteTypeFromMangledName((uint64_t *)&unk_254097F30);
  OUTLINED_FUNCTION_0_1();
  MEMORY[0x24BDAC7A8](v9);
  OUTLINED_FUNCTION_29_4();
  v11 = v10;
  v12 = OUTLINED_FUNCTION_32_7();
  v13 = *(_QWORD *)(v12 - 8);
  v42 = v12;
  MEMORY[0x24BDAC7A8](v12);
  OUTLINED_FUNCTION_29_4();
  v15 = v14;
  sub_22D665B58();
  OUTLINED_FUNCTION_0_1();
  MEMORY[0x24BDAC7A8](v16);
  OUTLINED_FUNCTION_19_3();
  sub_22D66656C();
  OUTLINED_FUNCTION_0_1();
  MEMORY[0x24BDAC7A8](v17);
  v18 = OUTLINED_FUNCTION_12_12();
  v39 = v18;
  MEMORY[0x24BDAC7A8](v18);
  OUTLINED_FUNCTION_2_2();
  v35 = __swift_instantiateConcreteTypeFromMangledName(&qword_254096DC8);
  sub_22D666518();
  OUTLINED_FUNCTION_15_13();
  v40 = *MEMORY[0x24BDCD328];
  v41 = *(void (**)(uint64_t))(v13 + 104);
  v34 = v15;
  v41(v15);
  OUTLINED_FUNCTION_8_2();
  OUTLINED_FUNCTION_28_6();
  __swift_storeEnumTagSinglePayload(v19, v20, v21, v18);
  sub_22D6655AC();
  v45 = 0u;
  v46 = 0u;
  v47 = 0u;
  v48 = 0u;
  v49 = 0;
  v32 = v8;
  OUTLINED_FUNCTION_4_22((uint64_t)v8);
  OUTLINED_FUNCTION_4_22((uint64_t)v6);
  v38 = *MEMORY[0x24BDB6090];
  v33 = *(void (**)(uint64_t))(v36 + 104);
  v22 = v44;
  v33(v43);
  sub_22D3802AC();
  v36 = sub_22D665660();
  v35 = __swift_instantiateConcreteTypeFromMangledName((uint64_t *)&unk_254096A50);
  OUTLINED_FUNCTION_16_14();
  sub_22D666518();
  OUTLINED_FUNCTION_15_13();
  OUTLINED_FUNCTION_24_10();
  OUTLINED_FUNCTION_8_2();
  OUTLINED_FUNCTION_16_12(v11);
  LOBYTE(v45) = 0;
  v23 = (uint64_t)v32;
  OUTLINED_FUNCTION_4_22((uint64_t)v32);
  OUTLINED_FUNCTION_4_22((uint64_t)v6);
  v24 = v43;
  v25 = v22;
  v26 = v33;
  ((void (*)(uint64_t, _QWORD, uint64_t))v33)(v43, v38, v25);
  sub_22D3DEEBC();
  v35 = sub_22D665654();
  __swift_instantiateConcreteTypeFromMangledName(&qword_254096DF0);
  sub_22D666518();
  OUTLINED_FUNCTION_15_13();
  OUTLINED_FUNCTION_24_10();
  OUTLINED_FUNCTION_8_2();
  OUTLINED_FUNCTION_16_12(v11);
  LOBYTE(v45) = 1;
  sub_22D6666D4();
  OUTLINED_FUNCTION_28_6();
  __swift_storeEnumTagSinglePayload(v27, v28, v29, v30);
  OUTLINED_FUNCTION_4_22(v23);
  ((void (*)(uint64_t, _QWORD, uint64_t))v26)(v24, v38, v44);
  sub_22D665684();
  return v36;
}

uint64_t sub_22D3E083C(uint64_t a1)
{
  uint64_t *v1;
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  _QWORD *v7;

  v4 = *v1;
  v5 = v1[1];
  v6 = v1[2];
  v7 = (_QWORD *)swift_task_alloc();
  *(_QWORD *)(v2 + 16) = v7;
  *v7 = v2;
  v7[1] = sub_22D359C34;
  return sub_22D3DFE70(a1, v4, v5, v6);
}

uint64_t sub_22D3E08A8@<X0>(uint64_t *a1@<X8>)
{
  uint64_t result;
  uint64_t v3;
  uint64_t v4;

  result = sub_22D3E03A4();
  *a1 = result;
  a1[1] = v3;
  a1[2] = v4;
  return result;
}

uint64_t sub_22D3E08D4()
{
  sub_22D3E0A04();
  return sub_22D665564();
}

ValueMetadata *type metadata accessor for ToggleCellularPlanAction()
{
  return &type metadata for ToggleCellularPlanAction;
}

uint64_t storeEnumTagSinglePayload for ToggleCellularPlanAction.ToggleCellularPlanOperation(_BYTE *a1, unsigned int a2, unsigned int a3)
{
  int v3;
  uint64_t v4;

  if (a3 + 1 >= 0xFFFF00)
    v3 = 4;
  else
    v3 = 2;
  if ((a3 + 1) >> 8 < 0xFF)
    LODWORD(v4) = 1;
  else
    LODWORD(v4) = v3;
  if (a3 >= 0xFF)
    v4 = v4;
  else
    v4 = 0;
  if (a2 <= 0xFE)
    return ((uint64_t (*)(void))((char *)&loc_22D3E0958 + 4 * byte_22D68CDBD[v4]))();
  *a1 = a2 + 1;
  return ((uint64_t (*)(void))((char *)sub_22D3E098C + 4 * byte_22D68CDB8[v4]))();
}

uint64_t sub_22D3E098C(uint64_t result)
{
  char v1;

  *(_BYTE *)(result + 1) = v1;
  return result;
}

uint64_t sub_22D3E0994(uint64_t result, int a2)
{
  *(_WORD *)(result + 1) = 0;
  if (a2)
    JUMPOUT(0x22D3E099CLL);
  return result;
}

uint64_t sub_22D3E09A8(uint64_t result, int a2)
{
  *(_DWORD *)(result + 1) = 0;
  if (!a2)
    JUMPOUT(0x22D3E09B0);
  *(_BYTE *)result = a2 + 1;
  return result;
}

uint64_t sub_22D3E09B4(uint64_t result)
{
  int v1;

  *(_DWORD *)(result + 1) = v1;
  return result;
}

uint64_t sub_22D3E09BC(uint64_t result)
{
  __int16 v1;

  *(_WORD *)(result + 1) = v1;
  return result;
}

ValueMetadata *type metadata accessor for ToggleCellularPlanAction.ToggleCellularPlanOperation()
{
  return &type metadata for ToggleCellularPlanAction.ToggleCellularPlanOperation;
}

void sub_22D3E09D8()
{
  sub_22D3803F8(&qword_255D81750, &qword_255D81758, MEMORY[0x24BDB64B8]);
}

unint64_t sub_22D3E0A04()
{
  unint64_t result;

  result = qword_2540972F0;
  if (!qword_2540972F0)
  {
    result = MEMORY[0x22E3159EC](&unk_22D68D054, &type metadata for ToggleCellularPlanAction);
    atomic_store(result, (unint64_t *)&qword_2540972F0);
  }
  return result;
}

uint64_t OUTLINED_FUNCTION_2_14()
{
  return swift_bridgeObjectRelease();
}

uint64_t OUTLINED_FUNCTION_4_22(uint64_t a1)
{
  uint64_t v1;

  return __swift_storeEnumTagSinglePayload(a1, 1, 1, v1);
}

uint64_t OUTLINED_FUNCTION_7_12()
{
  return sub_22D666BB4();
}

uint64_t OUTLINED_FUNCTION_8_12()
{
  return sub_22D6665E4();
}

uint64_t OUTLINED_FUNCTION_9_12()
{
  return sub_22D666BCC();
}

uint64_t OUTLINED_FUNCTION_10_11(uint64_t a1)
{
  uint64_t v1;

  return sub_22D380324(a1, v1);
}

uint64_t OUTLINED_FUNCTION_12_12()
{
  return sub_22D665A08();
}

uint64_t OUTLINED_FUNCTION_16_14()
{
  return 0x6F6974617265704FLL;
}

uint64_t OUTLINED_FUNCTION_24_10()
{
  uint64_t v0;
  uint64_t v1;

  return (*(uint64_t (**)(uint64_t, _QWORD, _QWORD))(v1 - 216))(v0, *(unsigned int *)(v1 - 220), *(_QWORD *)(v1 - 208));
}

uint64_t OUTLINED_FUNCTION_32_7()
{
  return sub_22D6659F0();
}

uint64_t OUTLINED_FUNCTION_34_9(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19)
{
  return a19;
}

uint64_t OUTLINED_FUNCTION_36_6()
{
  return sub_22D6659E4();
}

uint64_t OUTLINED_FUNCTION_37_8()
{
  return sub_22D666BC0();
}

void OUTLINED_FUNCTION_39_4(uint64_t a1, ...)
{
  char v1;
  va_list va;

  va_start(va, a1);
  sub_22D3DE458((uint64_t)va, v1);
}

uint64_t OUTLINED_FUNCTION_40_8()
{
  return sub_22D666BB4();
}

id sub_22D3E0B64(uint64_t a1)
{
  return sub_22D3E0B9C(a1, (uint64_t (*)(uint64_t))type metadata accessor for DescriptionKey, (unint64_t *)&unk_255D80CD0, (uint64_t)&unk_22D6879E4);
}

id sub_22D3E0B80(uint64_t a1)
{
  return sub_22D3E0B9C(a1, (uint64_t (*)(uint64_t))_s3__C3KeyVMa_0, (unint64_t *)&unk_254097660, (uint64_t)&unk_22D6879A0);
}

id sub_22D3E0B9C(uint64_t a1, uint64_t (*a2)(uint64_t), unint64_t *a3, uint64_t a4)
{
  id v7;
  void *v8;
  id v9;

  v7 = objc_allocWithZone((Class)swift_getObjCClassFromMetadata());
  a2(0);
  sub_22D3590CC(a3, a2, a4);
  v8 = (void *)sub_22D6664AC();
  swift_bridgeObjectRelease();
  v9 = objc_msgSend(v7, sel_initWithDictionary_, v8);

  return v9;
}

id sub_22D3E0C48(uint64_t a1)
{
  return sub_22D3E0B9C(a1, (uint64_t (*)(uint64_t))type metadata accessor for Key, (unint64_t *)&qword_254097C30, (uint64_t)&unk_22D686EE8);
}

uint64_t sub_22D3E0C64()
{
  return sub_22D6668A8();
}

id sub_22D3E0C8C()
{
  uint64_t v0;
  uint64_t v1;
  char *v2;
  uint64_t v3;
  uint64_t v4;
  char *v5;
  uint64_t inited;
  void *v7;
  uint64_t v8;
  void *v9;
  id v10;
  id v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  id v19;
  uint64_t v20;
  id v21;
  uint64_t v22;
  id v23;
  uint64_t v24;
  void *v25;
  id v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  id v33;
  id v34;
  void *v35;
  uint64_t v36;
  void *v37;
  id v38;
  id v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  id v46;
  id v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  void *v51;
  uint64_t v52;
  id v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  id v60;
  id v61;
  id v62;
  uint64_t v63;
  uint64_t v64;
  void *v65;
  void *v66;
  uint64_t v67;
  void *v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  id v72;
  id v73;
  id v74;
  uint64_t v75;
  uint64_t v76;
  void *v77;
  void *v78;
  id v79;
  id v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  id v87;
  uint64_t v88;
  id v89;
  void *v90;
  uint64_t v91;
  uint64_t v92;
  id v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  id v100;
  uint64_t v101;
  id v102;
  uint64_t v103;
  void *v104;
  uint64_t v105;
  void *v106;
  void **v107;
  void *v108;
  void *v109;
  id v110;
  id v111;
  id v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  id v120;
  uint64_t v121;
  id v122;
  uint64_t v123;
  uint64_t v124;
  id v125;
  _QWORD *v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  id v133;
  id v134;
  uint64_t v135;
  uint64_t v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  id v141;
  id v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t v148;
  id v149;
  id v150;
  id v151;
  _QWORD *v152;
  uint64_t v153;
  uint64_t v154;
  uint64_t v155;
  uint64_t v156;
  uint64_t v157;
  id v158;
  id v159;
  uint64_t v160;
  uint64_t v161;
  uint64_t v162;
  _QWORD *v163;
  uint64_t v164;
  void *v165;
  void *v166;
  uint64_t v167;
  uint64_t v168;
  uint64_t v169;
  uint64_t v170;
  uint64_t v171;
  uint64_t v172;
  uint64_t v173;
  id v174;
  uint64_t v175;
  id v176;
  void *v177;
  uint64_t v178;
  id v179;
  uint64_t v180;
  uint64_t v181;
  uint64_t v182;
  uint64_t v183;
  uint64_t v184;
  id v185;
  id v186;
  uint64_t v187;
  id v188;
  uint64_t v189;
  uint64_t v190;
  id v191;
  uint64_t v192;
  void *v193;
  uint64_t v194;
  id v195;
  id v196;
  id v197;
  id v198;
  id v199;
  uint64_t v200;
  uint64_t v201;
  uint64_t v202;
  uint64_t v203;
  uint64_t v204;
  uint64_t v205;
  id v206;
  uint64_t v207;
  id v208;
  void *v209;
  uint64_t v210;
  id v211;
  uint64_t v212;
  uint64_t v213;
  uint64_t v214;
  uint64_t v215;
  uint64_t v216;
  uint64_t v217;
  id v218;
  id v219;
  uint64_t v220;
  id v221;
  uint64_t v222;
  id v223;
  uint64_t v224;
  _QWORD *v225;
  uint64_t v226;
  uint64_t v227;
  void *v228;
  id v229;
  uint64_t v230;
  uint64_t v231;
  uint64_t v232;
  uint64_t v233;
  uint64_t v234;
  uint64_t v235;
  uint64_t v236;
  id v237;
  id v238;
  id v239;
  id v240;
  uint64_t v241;
  void **v242;
  void *v243;
  id v244;
  uint64_t v245;
  uint64_t v247;
  uint64_t v248;
  uint64_t v249;
  uint64_t v250;
  id v251;
  uint64_t v252;
  id v253;
  uint64_t v254;
  uint64_t v255;
  _OWORD *v256;
  uint64_t v257;
  uint64_t v258;
  __int128 v259;
  uint64_t v260;
  uint64_t v261;
  uint64_t v262;
  _QWORD *v263;

  v0 = sub_22D665A8C();
  MEMORY[0x24BDAC7A8](v0);
  v2 = (char *)&v247 - ((v1 + 15) & 0xFFFFFFFFFFFFFFF0);
  v3 = sub_22D665B58();
  MEMORY[0x24BDAC7A8](v3);
  v5 = (char *)&v247 - ((v4 + 15) & 0xFFFFFFFFFFFFFFF0);
  v255 = sub_22D3583E8(0, (unint64_t *)&unk_255D7F990);
  __swift_instantiateConcreteTypeFromMangledName((uint64_t *)&unk_254097C50);
  inited = swift_initStackObject();
  *(_OWORD *)(inited + 16) = xmmword_22D6883E0;
  v7 = (void *)*MEMORY[0x24BEC4258];
  v8 = MEMORY[0x24BEE0D00];
  *(_QWORD *)(inited + 32) = *MEMORY[0x24BEC4258];
  strcpy((char *)(inited + 40), "WFCountAction");
  *(_WORD *)(inited + 54) = -4864;
  v9 = (void *)*MEMORY[0x24BEC42C8];
  *(_QWORD *)(inited + 64) = v8;
  *(_QWORD *)(inited + 72) = v9;
  v10 = v7;
  v11 = v9;
  v12 = sub_22D6665D8();
  v14 = v13;
  v15 = sub_22D6665D8();
  v17 = v16;
  v18 = (uint64_t)v5;
  sub_22D665B40();
  if (qword_255D7F880 != -1)
    swift_once();
  v19 = objc_msgSend((id)qword_255D81590, sel_bundleURL);
  v20 = (uint64_t)v2;
  sub_22D665A74();

  v21 = objc_allocWithZone(MEMORY[0x24BDD19B8]);
  v22 = v18;
  v23 = sub_22D3E208C(v12, v14, v15, v17, 0, 0, v18, v20);
  v24 = sub_22D3583E8(0, (unint64_t *)&unk_255D7F9A0);
  *(_QWORD *)(inited + 80) = v23;
  v25 = (void *)*MEMORY[0x24BEC4250];
  *(_QWORD *)(inited + 104) = v24;
  *(_QWORD *)(inited + 112) = v25;
  v262 = v24;
  v26 = v25;
  v27 = sub_22D6665D8();
  v29 = v28;
  v30 = sub_22D6665D8();
  v32 = v31;
  sub_22D665B40();
  v33 = objc_msgSend((id)qword_255D81590, sel_bundleURL);
  sub_22D665A74();

  v34 = objc_allocWithZone(MEMORY[0x24BDD19B8]);
  *(_QWORD *)(inited + 120) = sub_22D3E208C(v27, v29, v30, v32, 0, 0, v22, v20);
  v35 = (void *)*MEMORY[0x24BEC4378];
  *(_QWORD *)(inited + 144) = v24;
  *(_QWORD *)(inited + 152) = v35;
  *(_QWORD *)&v259 = sub_22D3583E8(0, (unint64_t *)&unk_255D80CC0);
  __swift_instantiateConcreteTypeFromMangledName((uint64_t *)&unk_255D7F9B0);
  v36 = swift_initStackObject();
  *(_OWORD *)(v36 + 16) = xmmword_22D686D40;
  v37 = (void *)*MEMORY[0x24BEC4380];
  *(_QWORD *)(v36 + 32) = *MEMORY[0x24BEC4380];
  v38 = v35;
  v39 = v37;
  v40 = sub_22D6665D8();
  v42 = v41;
  v43 = sub_22D6665D8();
  v45 = v44;
  sub_22D665B40();
  v46 = objc_msgSend((id)qword_255D81590, sel_bundleURL);
  sub_22D665A74();

  v47 = objc_allocWithZone(MEMORY[0x24BDD19B8]);
  v48 = v45;
  v49 = v22;
  v50 = v20;
  *(_QWORD *)(v36 + 40) = sub_22D3E208C(v40, v42, v43, v48, 0, 0, v22, v20);
  v51 = (void *)*MEMORY[0x24BEC4390];
  v52 = v262;
  *(_QWORD *)(v36 + 64) = v262;
  *(_QWORD *)(v36 + 72) = v51;
  v53 = v51;
  v261 = sub_22D6665D8();
  v55 = v54;
  v56 = sub_22D6665D8();
  v58 = v57;
  v59 = v49;
  sub_22D665B40();
  v60 = objc_msgSend((id)qword_255D81590, sel_bundleURL);
  v260 = v50;
  sub_22D665A74();

  v61 = objc_allocWithZone(MEMORY[0x24BDD19B8]);
  v62 = sub_22D3E208C(v261, v55, v56, v58, 0, 0, v59, v50);
  *(_QWORD *)(v36 + 104) = v52;
  *(_QWORD *)(v36 + 80) = v62;
  type metadata accessor for DescriptionKey(0);
  sub_22D3590CC((unint64_t *)&unk_255D80CD0, (uint64_t (*)(uint64_t))type metadata accessor for DescriptionKey, (uint64_t)&unk_22D6879E4);
  v261 = MEMORY[0x24BEE4AD8] + 8;
  v63 = sub_22D6664C4();
  v64 = v259;
  *(_QWORD *)(inited + 160) = sub_22D3E0B9C(v63, (uint64_t (*)(uint64_t))type metadata accessor for DescriptionKey, (unint64_t *)&unk_255D80CD0, (uint64_t)&unk_22D6879E4);
  v65 = (void *)*MEMORY[0x24BEC4280];
  *(_QWORD *)(inited + 184) = v64;
  *(_QWORD *)(inited + 192) = v65;
  *(_QWORD *)(inited + 200) = 2036429383;
  *(_QWORD *)(inited + 208) = 0xE400000000000000;
  v66 = (void *)*MEMORY[0x24BEC4298];
  v67 = MEMORY[0x24BEE0D00];
  *(_QWORD *)(inited + 224) = MEMORY[0x24BEE0D00];
  *(_QWORD *)(inited + 232) = v66;
  *(_QWORD *)(inited + 240) = 7173491;
  *(_QWORD *)(inited + 248) = 0xE300000000000000;
  v68 = (void *)*MEMORY[0x24BEC4430];
  *(_QWORD *)(inited + 264) = v67;
  *(_QWORD *)(inited + 272) = v68;
  v256 = (_OWORD *)__swift_instantiateConcreteTypeFromMangledName((uint64_t *)&unk_255D7F9C0);
  v69 = swift_initStackObject();
  v259 = xmmword_22D686D30;
  *(_OWORD *)(v69 + 16) = xmmword_22D686D30;
  v70 = v59;
  *(_QWORD *)(v69 + 32) = 0x656C7069746C754DLL;
  *(_QWORD *)(v69 + 40) = 0xE800000000000000;
  v71 = MEMORY[0x24BEE1328];
  *(_BYTE *)(v69 + 48) = 1;
  *(_QWORD *)(v69 + 72) = v71;
  strcpy((char *)(v69 + 80), "ParameterKey");
  *(_BYTE *)(v69 + 93) = 0;
  *(_WORD *)(v69 + 94) = -5120;
  *(_QWORD *)(v69 + 96) = 0x7475706E49;
  *(_QWORD *)(v69 + 104) = 0xE500000000000000;
  *(_QWORD *)(v69 + 120) = v67;
  *(_QWORD *)(v69 + 128) = 0x6465726975716552;
  *(_QWORD *)(v69 + 136) = 0xE800000000000000;
  *(_BYTE *)(v69 + 144) = 1;
  *(_QWORD *)(v69 + 168) = v71;
  *(_QWORD *)(v69 + 176) = 0x7365707954;
  *(_QWORD *)(v69 + 184) = 0xE500000000000000;
  v258 = __swift_instantiateConcreteTypeFromMangledName((uint64_t *)&unk_255D80CE0);
  *(_QWORD *)(v69 + 216) = v258;
  *(_QWORD *)(v69 + 192) = &unk_24F890DC8;
  v72 = v65;
  v73 = v66;
  v74 = v68;
  v75 = sub_22D6664C4();
  v76 = __swift_instantiateConcreteTypeFromMangledName(&qword_255D7F9D0);
  v257 = v76;
  *(_QWORD *)(inited + 280) = v75;
  v77 = (void *)*MEMORY[0x24BEC42D0];
  *(_QWORD *)(inited + 304) = v76;
  *(_QWORD *)(inited + 312) = v77;
  *(_BYTE *)(inited + 320) = 1;
  v78 = (void *)*MEMORY[0x24BEC42D8];
  *(_QWORD *)(inited + 344) = v71;
  *(_QWORD *)(inited + 352) = v78;
  v79 = v77;
  v80 = v78;
  v81 = sub_22D6665D8();
  v83 = v82;
  v84 = sub_22D6665D8();
  v86 = v85;
  sub_22D665B40();
  v87 = objc_msgSend((id)qword_255D81590, sel_bundleURL);
  v88 = v260;
  sub_22D665A74();

  v89 = objc_allocWithZone(MEMORY[0x24BDD19B8]);
  *(_QWORD *)(inited + 360) = sub_22D3E208C(v81, v83, v84, v86, 0, 0, v70, v88);
  v90 = (void *)*MEMORY[0x24BEC44E8];
  v91 = v262;
  *(_QWORD *)(inited + 384) = v262;
  *(_QWORD *)(inited + 392) = v90;
  v92 = swift_allocObject();
  *(_OWORD *)(v92 + 16) = v259;
  *(_QWORD *)(v92 + 32) = 0x75736F6C63736944;
  *(_QWORD *)(v92 + 40) = 0xEF6C6576654C6572;
  *(_QWORD *)(v92 + 48) = 0x63696C627550;
  *(_QWORD *)(v92 + 56) = 0xE600000000000000;
  *(_QWORD *)(v92 + 72) = MEMORY[0x24BEE0D00];
  *(_QWORD *)(v92 + 80) = 0x656C7069746C754DLL;
  *(_QWORD *)(v92 + 88) = 0xE800000000000000;
  *(_BYTE *)(v92 + 96) = 0;
  *(_QWORD *)(v92 + 120) = MEMORY[0x24BEE1328];
  *(_QWORD *)(v92 + 128) = 0x614E74757074754FLL;
  *(_QWORD *)(v92 + 136) = 0xEA0000000000656DLL;
  v93 = v90;
  v256 = (_OWORD *)sub_22D6665D8();
  v95 = v94;
  v96 = sub_22D6665D8();
  v98 = v97;
  v99 = v70;
  v248 = v70;
  sub_22D665B40();
  v100 = objc_msgSend((id)qword_255D81590, sel_bundleURL);
  v101 = v260;
  sub_22D665A74();

  v102 = objc_allocWithZone(MEMORY[0x24BDD19B8]);
  *(_QWORD *)(v92 + 144) = sub_22D3E208C((uint64_t)v256, v95, v96, v98, 0, 0, v99, v101);
  *(_QWORD *)(v92 + 168) = v91;
  *(_QWORD *)(v92 + 176) = 0x7365707954;
  *(_QWORD *)(v92 + 216) = v258;
  *(_QWORD *)(v92 + 184) = 0xE500000000000000;
  *(_QWORD *)(v92 + 192) = &unk_24F890E08;
  v103 = MEMORY[0x24BEE0D00];
  *(_QWORD *)(inited + 400) = sub_22D6664C4();
  v104 = (void *)*MEMORY[0x24BEC42E8];
  *(_QWORD *)(inited + 424) = v257;
  *(_QWORD *)(inited + 432) = v104;
  __swift_instantiateConcreteTypeFromMangledName(&qword_255D809B0);
  v258 = swift_allocObject();
  *(_OWORD *)(v258 + 16) = xmmword_22D6883F0;
  v257 = sub_22D3583E8(0, &qword_255D7F9E0);
  v254 = __swift_instantiateConcreteTypeFromMangledName((uint64_t *)&unk_255D7F9E8);
  v105 = swift_allocObject();
  *(_OWORD *)(v105 + 16) = xmmword_22D6886E0;
  v106 = (void *)*MEMORY[0x24BEC4510];
  *(_QWORD *)(v105 + 32) = *MEMORY[0x24BEC4510];
  *(_QWORD *)(v105 + 40) = 0xD000000000000016;
  v107 = (void **)MEMORY[0x24BEC4518];
  *(_QWORD *)(v105 + 48) = 0x800000022D6AF870;
  v108 = *v107;
  *(_QWORD *)(v105 + 64) = v103;
  *(_QWORD *)(v105 + 72) = v108;
  *(_QWORD *)(v105 + 80) = 0x736D657449;
  *(_QWORD *)(v105 + 88) = 0xE500000000000000;
  v109 = (void *)*MEMORY[0x24BEC4550];
  *(_QWORD *)(v105 + 104) = v103;
  *(_QWORD *)(v105 + 112) = v109;
  v256 = (_OWORD *)swift_allocObject();
  v256[1] = xmmword_22D68C970;
  v110 = v104;
  v253 = v106;
  v111 = v108;
  v112 = v109;
  v113 = sub_22D6665D8();
  v115 = v114;
  v116 = sub_22D6665D8();
  v118 = v117;
  v119 = v248;
  sub_22D665B40();
  v120 = objc_msgSend((id)qword_255D81590, sel_bundleURL);
  v121 = v260;
  sub_22D665A74();

  v122 = objc_allocWithZone(MEMORY[0x24BDD19B8]);
  v123 = v118;
  v124 = v119;
  v125 = sub_22D3E208C(v113, v115, v116, v123, 0, 0, v119, v121);
  v252 = inited;
  v126 = v256;
  *((_QWORD *)v256 + 4) = v125;
  v127 = sub_22D6665D8();
  v129 = v128;
  v130 = sub_22D6665D8();
  v132 = v131;
  sub_22D665B40();
  v133 = objc_msgSend((id)qword_255D81590, sel_bundleURL);
  sub_22D665A74();

  v134 = objc_allocWithZone(MEMORY[0x24BDD19B8]);
  v126[5] = sub_22D3E208C(v127, v129, v130, v132, 0, 0, v124, v121);
  v135 = sub_22D6665D8();
  v137 = v136;
  v138 = sub_22D6665D8();
  v140 = v139;
  sub_22D665B40();
  v141 = objc_msgSend((id)qword_255D81590, sel_bundleURL);
  sub_22D665A74();

  v142 = objc_allocWithZone(MEMORY[0x24BDD19B8]);
  v126[6] = sub_22D3E208C(v135, v137, v138, v140, 0, 0, v124, v121);
  v143 = sub_22D6665D8();
  v145 = v144;
  v146 = sub_22D6665D8();
  v148 = v147;
  sub_22D665B40();
  v149 = objc_msgSend((id)qword_255D81590, sel_bundleURL);
  sub_22D665A74();

  v150 = objc_allocWithZone(MEMORY[0x24BDD19B8]);
  v151 = sub_22D3E208C(v143, v145, v146, v148, 0, 0, v124, v121);
  v152 = v256;
  *((_QWORD *)v256 + 7) = v151;
  v251 = (id)sub_22D6665D8();
  v154 = v153;
  v155 = sub_22D6665D8();
  v157 = v156;
  sub_22D665B40();
  v158 = objc_msgSend((id)qword_255D81590, sel_bundleURL);
  sub_22D665A74();

  v159 = objc_allocWithZone(MEMORY[0x24BDD19B8]);
  v160 = v124;
  v161 = v124;
  v162 = v121;
  v152[8] = sub_22D3E208C((uint64_t)v251, v154, v155, v157, 0, 0, v160, v121);
  v263 = v152;
  sub_22D6666A4();
  v163 = v263;
  v164 = __swift_instantiateConcreteTypeFromMangledName((uint64_t *)&unk_255D80CF0);
  *(_QWORD *)(v105 + 120) = v163;
  v165 = (void *)*MEMORY[0x24BEC4588];
  *(_QWORD *)(v105 + 144) = v164;
  *(_QWORD *)(v105 + 152) = v165;
  *(_QWORD *)(v105 + 160) = 0x54746E756F434657;
  *(_QWORD *)(v105 + 168) = 0xEB00000000657079;
  v166 = (void *)*MEMORY[0x24BEC4598];
  *(_QWORD *)(v105 + 184) = MEMORY[0x24BEE0D00];
  *(_QWORD *)(v105 + 192) = v166;
  v256 = v165;
  v251 = v166;
  v167 = sub_22D6665D8();
  v169 = v168;
  v170 = sub_22D6665D8();
  v172 = v171;
  v173 = v161;
  sub_22D665B40();
  v174 = objc_msgSend((id)qword_255D81590, sel_bundleURL);
  v175 = v162;
  sub_22D665A74();

  v176 = objc_allocWithZone(MEMORY[0x24BDD19B8]);
  *(_QWORD *)(v105 + 200) = sub_22D3E208C(v167, v169, v170, v172, 0, 0, v173, v162);
  v177 = (void *)*MEMORY[0x24BEC45D0];
  v178 = v262;
  *(_QWORD *)(v105 + 224) = v262;
  *(_QWORD *)(v105 + 232) = v177;
  v179 = v177;
  v250 = sub_22D6665D8();
  v181 = v180;
  v182 = sub_22D6665D8();
  v184 = v183;
  sub_22D665B40();
  v185 = objc_msgSend((id)qword_255D81590, sel_bundleURL);
  sub_22D665A74();

  v186 = objc_allocWithZone(MEMORY[0x24BDD19B8]);
  v187 = v175;
  v188 = sub_22D3E208C(v250, v181, v182, v184, 0, 0, v173, v175);
  *(_QWORD *)(v105 + 264) = v178;
  *(_QWORD *)(v105 + 240) = v188;
  _s3__C3KeyVMa_0(0);
  v250 = v189;
  v249 = sub_22D3590CC((unint64_t *)&unk_254097660, (uint64_t (*)(uint64_t))_s3__C3KeyVMa_0, (uint64_t)&unk_22D6879A0);
  v190 = sub_22D6664C4();
  v191 = sub_22D3E0B9C(v190, (uint64_t (*)(uint64_t))_s3__C3KeyVMa_0, (unint64_t *)&unk_254097660, (uint64_t)&unk_22D6879A0);
  *(_QWORD *)(v258 + 32) = v191;
  v192 = swift_allocObject();
  *(_OWORD *)(v192 + 16) = v259;
  v193 = v253;
  *(_QWORD *)(v192 + 32) = v253;
  *(_QWORD *)(v192 + 40) = 0xD000000000000019;
  *(_QWORD *)(v192 + 48) = 0x800000022D6AECC0;
  v194 = MEMORY[0x24BEE0D00];
  v195 = v256;
  *(_QWORD *)(v192 + 64) = MEMORY[0x24BEE0D00];
  *(_QWORD *)(v192 + 72) = v195;
  *(_QWORD *)(v192 + 80) = 0x7475706E49;
  *(_QWORD *)(v192 + 88) = 0xE500000000000000;
  v196 = v251;
  *(_QWORD *)(v192 + 104) = v194;
  *(_QWORD *)(v192 + 112) = v196;
  v197 = v193;
  v198 = v195;
  v199 = v196;
  v200 = sub_22D6665D8();
  v202 = v201;
  v203 = sub_22D6665D8();
  v205 = v204;
  sub_22D665B40();
  v206 = objc_msgSend((id)qword_255D81590, sel_bundleURL);
  v207 = v187;
  sub_22D665A74();

  v208 = objc_allocWithZone(MEMORY[0x24BDD19B8]);
  *(_QWORD *)(v192 + 120) = sub_22D3E208C(v200, v202, v203, v205, 0, 0, v173, v187);
  v209 = (void *)*MEMORY[0x24BEC45B8];
  v210 = v262;
  *(_QWORD *)(v192 + 144) = v262;
  *(_QWORD *)(v192 + 152) = v209;
  v211 = v209;
  v212 = sub_22D6665D8();
  v214 = v213;
  v215 = sub_22D6665D8();
  v217 = v216;
  sub_22D665B40();
  v218 = objc_msgSend((id)qword_255D81590, sel_bundleURL);
  sub_22D665A74();

  v219 = objc_allocWithZone(MEMORY[0x24BDD19B8]);
  v220 = v173;
  v221 = sub_22D3E208C(v212, v214, v215, v217, 0, 0, v173, v207);
  *(_QWORD *)(v192 + 184) = v210;
  *(_QWORD *)(v192 + 160) = v221;
  v222 = sub_22D6664C4();
  v223 = sub_22D3E0B9C(v222, (uint64_t (*)(uint64_t))_s3__C3KeyVMa_0, (unint64_t *)&unk_254097660, (uint64_t)&unk_22D6879A0);
  v224 = v258;
  *(_QWORD *)(v258 + 40) = v223;
  v263 = (_QWORD *)v224;
  sub_22D6666A4();
  v225 = v263;
  v226 = __swift_instantiateConcreteTypeFromMangledName((uint64_t *)&unk_255D80D00);
  v227 = v252;
  *(_QWORD *)(v252 + 440) = v225;
  v228 = (void *)*MEMORY[0x24BEC42E0];
  *(_QWORD *)(v227 + 464) = v226;
  *(_QWORD *)(v227 + 472) = v228;
  v229 = v228;
  v230 = sub_22D6665D8();
  v232 = v231;
  v233 = sub_22D6665D8();
  v235 = v234;
  v236 = v220;
  sub_22D665B40();
  v237 = objc_msgSend((id)qword_255D81590, sel_bundleURL);
  sub_22D665A74();

  v238 = objc_allocWithZone(MEMORY[0x24BDD19B8]);
  v239 = sub_22D3E208C(v230, v232, v233, v235, 0, 0, v236, v207);
  v240 = objc_msgSend(objc_allocWithZone(MEMORY[0x24BEC3A50]), sel_initWithString_, v239);

  v241 = sub_22D3583E8(0, &qword_255D7FA08);
  v242 = (void **)MEMORY[0x24BEC42C0];
  *(_QWORD *)(v227 + 480) = v240;
  v243 = *v242;
  *(_QWORD *)(v227 + 504) = v241;
  *(_QWORD *)(v227 + 512) = v243;
  *(_QWORD *)(v227 + 544) = MEMORY[0x24BEE1328];
  *(_BYTE *)(v227 + 520) = 1;
  type metadata accessor for Key(0);
  sub_22D3590CC((unint64_t *)&qword_254097C30, (uint64_t (*)(uint64_t))type metadata accessor for Key, (uint64_t)&unk_22D686EE8);
  v244 = v243;
  v245 = sub_22D6664C4();
  return sub_22D3E0B9C(v245, (uint64_t (*)(uint64_t))type metadata accessor for Key, (unint64_t *)&qword_254097C30, (uint64_t)&unk_22D686EE8);
}

uint64_t sub_22D3E2068()
{
  swift_getObjCClassMetadata();
  return sub_22D3E0C64();
}

id sub_22D3E208C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  void *v8;
  void *v9;
  void *v14;
  void *v15;
  void *v16;
  void *v17;
  void *v18;
  id v19;
  uint64_t v20;
  uint64_t v21;

  v9 = v8;
  v14 = (void *)sub_22D666578();
  swift_bridgeObjectRelease();
  if (!a4)
  {
    v15 = 0;
    if (a6)
      goto LABEL_3;
LABEL_5:
    v16 = 0;
    goto LABEL_6;
  }
  v15 = (void *)sub_22D666578();
  swift_bridgeObjectRelease();
  if (!a6)
    goto LABEL_5;
LABEL_3:
  v16 = (void *)sub_22D666578();
  swift_bridgeObjectRelease();
LABEL_6:
  v17 = (void *)sub_22D665B34();
  v18 = (void *)sub_22D665A50();
  v19 = objc_msgSend(v9, sel_initWithKey_defaultValue_table_locale_bundleURL_, v14, v15, v16, v17, v18);

  v20 = sub_22D665A8C();
  (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)(v20 - 8) + 8))(a8, v20);
  v21 = sub_22D665B58();
  (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)(v21 - 8) + 8))(a7, v21);
  return v19;
}

uint64_t libssh2_sftp_dtor(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  v5 = *a4;
  v6 = *(_QWORD *)(*a4 + 88);
  if (v6)
    (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v6, a1);
  v7 = *(_QWORD *)(v5 + 192);
  if (v7)
    (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v7, a1);
  return (*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(v5, a1);
}

uint64_t libssh2_sftp_init(uint64_t a1)
{
  uint64_t v2;
  int *v4;
  time_t v5;
  _DWORD *v6;
  int v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  _DWORD *v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  uint64_t v18;
  uint64_t v19;
  _DWORD *v20;
  unint64_t v21;
  uint64_t v22;
  _DWORD *v23;
  char *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  unint64_t v29;
  unint64_t v30;
  unint64_t v31;
  uint64_t v32;

  if (!a1)
    return 0;
  if ((*(_BYTE *)(a1 + 128) & 4) != 0)
  {
    v4 = (int *)(a1 + 72892);
    v5 = time(0);
    v6 = (_DWORD *)(a1 + 72917);
    while (1)
    {
      v31 = 0;
      v32 = 0;
      v28 = 0;
      v29 = 0;
      v30 = 0;
      v7 = *v4;
      v2 = *(_QWORD *)(a1 + 72896);
      switch(*v4)
      {
        case 0:
          if (v2)
            libssh2_sftp_init_cold_1();
          *(_QWORD *)(a1 + 72896) = 0;
          *v4 = 2;
          goto LABEL_10;
        case 2:
LABEL_10:
          v8 = _libssh2_channel_open(a1, "session", 7u, 0x200000u, 0x8000u, 0, 0);
          *(_QWORD *)(a1 + 72904) = v8;
          if (!v8)
          {
            if (libssh2_session_last_errno(a1) == -37)
            {
              v10 = a1;
              v11 = 4294967259;
              v12 = "Would block starting up channel";
              goto LABEL_41;
            }
            _libssh2_error(a1, 4294967275, "Unable to startup channel");
            goto LABEL_44;
          }
          *v4 = 3;
LABEL_13:
          v9 = _libssh2_channel_process_startup(v8, "subsystem", 9uLL, "sftp", 4uLL);
          if (v9)
          {
            if (v9 == -37)
            {
              v10 = a1;
              v11 = 4294967259;
              v12 = "Would block to request SFTP subsystem";
LABEL_41:
              _libssh2_error(v10, v11, v12);
              goto LABEL_53;
            }
            v10 = a1;
            v11 = 4294967275;
            v17 = "Unable to request SFTP subsystem";
          }
          else
          {
            *v4 = 4;
LABEL_18:
            if (_libssh2_channel_extended_data(*(_QWORD *)(a1 + 72904), 1) == -37)
            {
              v10 = a1;
              v11 = 4294967259;
              v12 = "Would block requesting handle extended data";
              goto LABEL_41;
            }
            v14 = _libssh2_calloc(a1, 0x168uLL);
            *(_QWORD *)(a1 + 72896) = v14;
            if (v14)
            {
              v2 = (uint64_t)v14;
              *(_QWORD *)v14 = *(_QWORD *)(a1 + 72904);
              v14[2] = 0;
              _libssh2_htonu32((_DWORD *)(a1 + 72912), 5u);
              *(_BYTE *)(a1 + 72916) = 1;
              _libssh2_htonu32(v6, 3u);
              v13 = 0;
              *(_QWORD *)(a1 + 72928) = 0;
              *v4 = 5;
LABEL_22:
              v15 = _libssh2_channel_write(*(_QWORD *)(a1 + 72904), 0, (const void *)(a1 + 72912 + v13), 9 - v13);
              if (v15 == -37)
              {
                v10 = a1;
                v11 = 4294967259;
                v12 = "Would block sending SSH_FXP_INIT";
                goto LABEL_41;
              }
              if (v15 < 0)
              {
                v10 = a1;
                v11 = 4294967289;
                v17 = "Unable to send SSH_FXP_INIT";
              }
              else
              {
                v16 = *(_QWORD *)(a1 + 72928) + v15;
                *(_QWORD *)(a1 + 72928) = v16;
                if (v16 == 9)
                {
                  *v4 = 6;
                }
                else
                {
                  v7 = *v4;
LABEL_34:
                  if (v7 == 16)
                  {
                    if (_libssh2_channel_free(*(_QWORD *)(a1 + 72904)) == -37)
                    {
                      v10 = a1;
                      v11 = 4294967259;
                      v12 = "Would block closing channel";
                      goto LABEL_41;
                    }
                    *(_QWORD *)(a1 + 72904) = 0;
                    v19 = *(_QWORD *)(a1 + 72896);
                    if (v19)
                    {
                      (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v19, a1);
                      *(_QWORD *)(a1 + 72896) = 0;
                    }
LABEL_44:
                    *v4 = 0;
                    goto LABEL_53;
                  }
                }
                v18 = sftp_packet_require(v2, 2, 0, &v32, &v31, 5uLL);
                if ((_DWORD)v18 == -38)
                {
                  if (v31)
                    (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v32, a1);
                  v10 = a1;
                  v11 = 4294967265;
                  v17 = "Invalid SSH_FXP_VERSION response";
                }
                else
                {
                  v11 = v18;
                  if (!(_DWORD)v18)
                  {
                    v20 = v6;
                    v21 = v31;
                    v22 = v32;
                    v28 = v32;
                    v29 = v32 + 1;
                    v30 = v31;
                    v23 = (_DWORD *)(v2 + 12);
                    if (_libssh2_get_u32(&v28, (_DWORD *)(v2 + 12)))
                    {
                      (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v32, a1);
                      v6 = v20;
                    }
                    else
                    {
                      if (*v23 >= 4u)
                        *v23 = 3;
                      if (v29 >= v22 + v21)
                      {
LABEL_67:
                        (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v32, a1);
                        v25 = *(_QWORD *)v2;
                        *(_QWORD *)(v25 + 112) = v2;
                        *(_QWORD *)(v25 + 120) = libssh2_sftp_dtor;
                        *(_QWORD *)v4 = 0;
                        *(_QWORD *)(a1 + 72900) = 0;
                        *(_DWORD *)(a1 + 72908) = 0;
                        _libssh2_list_init((_QWORD *)(v2 + 48));
                        return v2;
                      }
                      while (1)
                      {
                        v26 = 0;
                        v27 = 0;
                        if (_libssh2_get_string(&v28, &v27, 0))
                        {
                          (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v32, a1);
                          v24 = "Data too short when extracting extname";
                          goto LABEL_66;
                        }
                        if (_libssh2_get_string(&v28, &v26, 0))
                          break;
                        if (v29 >= v22 + v21)
                          goto LABEL_67;
                      }
                      (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v32, a1);
                      v24 = "Data too short when extracting extdata";
LABEL_66:
                      _libssh2_error(a1, 4294967258, v24);
                      v6 = v20;
                    }
                    goto LABEL_52;
                  }
                  v10 = a1;
                  if ((_DWORD)v11 == -37)
                  {
                    v12 = "Would block receiving SSH_FXP_VERSION";
                    goto LABEL_41;
                  }
                  v17 = "Timeout waiting for response from SFTP subsystem";
                }
              }
            }
            else
            {
              v10 = a1;
              v11 = 4294967290;
              v17 = "Unable to allocate a new SFTP structure";
            }
          }
          _libssh2_error(v10, v11, v17);
LABEL_52:
          *v4 = 16;
LABEL_53:
          if (!*(_DWORD *)(a1 + 172)
            || libssh2_session_last_errno(a1) != -37
            || _libssh2_wait_socket(a1, v5))
          {
            return 0;
          }
          break;
        case 3:
          v8 = *(_QWORD *)(a1 + 72904);
          goto LABEL_13;
        case 4:
          goto LABEL_18;
        case 5:
          v13 = *(_QWORD *)(a1 + 72928);
          goto LABEL_22;
        default:
          goto LABEL_34;
      }
    }
  }
  _libssh2_error(a1, 4294967262, "session not authenticated yet");
  return 0;
}

uint64_t libssh2_sftp_shutdown(uint64_t *a1)
{
  time_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t *v18;
  uint64_t *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t result;
  uint64_t v23;

  if (!a1)
    return 4294967257;
  v2 = time(0);
  do
  {
    v3 = *(_QWORD *)(*a1 + 104);
    v4 = a1[11];
    if (v4)
    {
      (*(void (**)(uint64_t, _QWORD))(v3 + 24))(v4, *(_QWORD *)(*a1 + 104));
      a1[11] = 0;
    }
    v5 = a1[16];
    if (v5)
    {
      (*(void (**)(uint64_t, uint64_t))(v3 + 24))(v5, v3);
      a1[16] = 0;
    }
    v6 = a1[24];
    if (v6)
    {
      (*(void (**)(uint64_t, uint64_t))(v3 + 24))(v6, v3);
      a1[24] = 0;
    }
    v7 = a1[26];
    if (v7)
    {
      (*(void (**)(uint64_t, uint64_t))(v3 + 24))(v7, v3);
      a1[26] = 0;
    }
    v8 = a1[28];
    if (v8)
    {
      (*(void (**)(uint64_t, uint64_t))(v3 + 24))(v8, v3);
      a1[28] = 0;
    }
    v9 = a1[30];
    if (v9)
    {
      (*(void (**)(uint64_t, uint64_t))(v3 + 24))(v9, v3);
      a1[30] = 0;
    }
    v10 = a1[33];
    if (v10)
    {
      (*(void (**)(uint64_t, uint64_t))(v3 + 24))(v10, v3);
      a1[33] = 0;
    }
    v11 = a1[35];
    if (v11)
    {
      (*(void (**)(uint64_t, uint64_t))(v3 + 24))(v11, v3);
      a1[35] = 0;
    }
    v12 = a1[37];
    if (v12)
    {
      (*(void (**)(uint64_t, uint64_t))(v3 + 24))(v12, v3);
      a1[37] = 0;
    }
    v13 = a1[39];
    if (v13)
    {
      (*(void (**)(uint64_t, uint64_t))(v3 + 24))(v13, v3);
      a1[39] = 0;
    }
    v14 = a1[41];
    if (v14)
    {
      (*(void (**)(uint64_t, uint64_t))(v3 + 24))(v14, v3);
      a1[41] = 0;
    }
    v15 = a1[43];
    if (v15)
    {
      (*(void (**)(uint64_t, uint64_t))(v3 + 24))(v15, v3);
      a1[43] = 0;
    }
    v16 = a1[22];
    if (v16)
    {
      (*(void (**)(uint64_t, uint64_t))(v3 + 24))(v16, v3);
      a1[22] = 0;
    }
    v17 = *(_QWORD *)(*a1 + 104);
    v18 = (uint64_t *)_libssh2_list_first((uint64_t)(a1 + 2));
    v19 = (uint64_t *)_libssh2_list_first((uint64_t)(a1 + 4));
    if (v18)
    {
      do
      {
        v20 = _libssh2_list_next((uint64_t)v18);
        _libssh2_list_remove(v18);
        (*(void (**)(uint64_t, uint64_t))(v17 + 24))(v18[4], v17);
        (*(void (**)(uint64_t *, uint64_t))(v17 + 24))(v18, v17);
        v18 = (uint64_t *)v20;
      }
      while (v20);
    }
    if (v19)
    {
      do
      {
        v21 = _libssh2_list_next((uint64_t)v19);
        _libssh2_list_remove(v19);
        (*(void (**)(uint64_t *, uint64_t))(v17 + 24))(v19, v17);
        v19 = (uint64_t *)v21;
      }
      while (v21);
    }
    result = _libssh2_channel_free(*a1);
    if ((_DWORD)result != -37)
      break;
    v23 = *(_QWORD *)(*a1 + 104);
    if (!*(_DWORD *)(v23 + 172))
      return 4294967259;
    result = _libssh2_wait_socket(v23, v2);
  }
  while (!(_DWORD)result);
  return result;
}

_QWORD *libssh2_sftp_open_ex(_QWORD *result, const void *a2, unsigned int a3, unsigned int a4, uint64_t a5, int a6)
{
  uint64_t v11;
  time_t v12;

  if (result)
  {
    v11 = (uint64_t)result;
    v12 = time(0);
    while (1)
    {
      result = sftp_open(v11, a2, a3, a4, a5, a6, 0);
      if (!*(_DWORD *)(*(_QWORD *)(*(_QWORD *)v11 + 104) + 172) || result != 0)
        break;
      if (libssh2_session_last_errno(*(_QWORD *)(*(_QWORD *)v11 + 104)) != -37
        || _libssh2_wait_socket(*(_QWORD *)(*(_QWORD *)v11 + 104), v12))
      {
        return 0;
      }
    }
  }
  return result;
}

_QWORD *sftp_open(uint64_t a1, const void *a2, unint64_t a3, unsigned int a4, uint64_t a5, int a6, uint64_t a7)
{
  uint64_t v9;
  uint64_t v10;
  int v11;
  __int128 v16;
  int v17;
  _DWORD *v18;
  unsigned int v19;
  uint64_t v20;
  char v21;
  char *v22;
  unsigned int v23;
  uint64_t v24;
  uint64_t v25;
  char *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  _QWORD *v30;
  uint64_t v31;
  char *v33;
  int v34;
  int v35;
  _QWORD *v36;
  unsigned int v37;
  unint64_t v38;
  uint64_t v39;
  size_t v40;
  uint64_t v41;
  unint64_t v42;
  _DWORD *v43;
  _OWORD v44[4];

  v9 = *(_QWORD *)a1;
  v10 = *(_QWORD *)(*(_QWORD *)a1 + 104);
  memset((char *)v44 + 8, 0, 48);
  v43 = 0;
  *(_QWORD *)&v44[0] = 4;
  v11 = *(_DWORD *)(a1 + 120);
  if (v11 != 2)
  {
    if (v11)
      goto LABEL_25;
    *(_DWORD *)(a1 + 64) = 0;
    if (a7)
    {
      v16 = *(_OWORD *)(a7 + 16);
      v44[0] = *(_OWORD *)a7;
      v44[1] = v16;
      v44[2] = *(_OWORD *)(a7 + 32);
      *(_QWORD *)&v44[3] = *(_QWORD *)(a7 + 48);
    }
    if (a6)
      v17 = 0;
    else
      v17 = (v44[0] & 0xC) + 8 * (v44[0] & 1) + ((4 * LODWORD(v44[0])) & 8) + 8;
    *(_DWORD *)(a1 + 136) = a3 + v17 + 13;
    *(_QWORD *)(a1 + 144) = 0;
    v18 = (_DWORD *)(*(uint64_t (**)(void))(v10 + 8))();
    *(_QWORD *)(a1 + 128) = v18;
    v43 = v18;
    if (!v18)
    {
      v26 = "Unable to allocate memory for FXP_OPEN or FXP_OPENDIR packet";
      v27 = v10;
      v28 = 4294967290;
      goto LABEL_36;
    }
    v19 = *(_DWORD *)(a1 + 136) - 4;
    v20 = 0x8000;
    if (a6)
      v20 = 0x4000;
    *(_QWORD *)&v44[2] = v20 | a5;
    if (a6)
      v21 = 11;
    else
      v21 = 3;
    _libssh2_store_u32(&v43, v19);
    v22 = (char *)v43;
    v43 = (_DWORD *)((char *)v43 + 1);
    *v22 = v21;
    v23 = *(_DWORD *)(a1 + 8);
    *(_DWORD *)(a1 + 8) = v23 + 1;
    *(_DWORD *)(a1 + 152) = v23;
    _libssh2_store_u32(&v43, v23);
    _libssh2_store_str(&v43, a2, a3);
    if (!a6)
    {
      _libssh2_store_u32(&v43, a4);
      v24 = sftp_attr2bin((char *)v43, (uint64_t *)v44);
      v43 = (_DWORD *)((char *)v43 + v24);
    }
    *(_DWORD *)(a1 + 120) = 2;
  }
  v25 = _libssh2_channel_write(v9, 0, (const void *)(*(_QWORD *)(a1 + 128) + *(_QWORD *)(a1 + 144)), *(unsigned int *)(a1 + 136) - *(_QWORD *)(a1 + 144));
  if (v25 == -37)
  {
    v26 = "Would block sending FXP_OPEN or FXP_OPENDIR command";
    v27 = v10;
    v28 = 4294967259;
LABEL_36:
    _libssh2_error(v27, v28, v26);
    return 0;
  }
  if (v25 < 0)
  {
    _libssh2_error(v10, v25, "Unable to send FXP_OPEN*");
    (*(void (**)(_QWORD, uint64_t))(v10 + 24))(*(_QWORD *)(a1 + 128), v10);
    v30 = 0;
    *(_QWORD *)(a1 + 128) = 0;
    *(_DWORD *)(a1 + 120) = 0;
    return v30;
  }
  v29 = *(_QWORD *)(a1 + 144) + v25;
  *(_QWORD *)(a1 + 144) = v29;
  if (v29 == *(_DWORD *)(a1 + 136))
  {
    (*(void (**)(_QWORD, uint64_t))(v10 + 24))(*(_QWORD *)(a1 + 128), v10);
    *(_QWORD *)(a1 + 128) = 0;
    *(_DWORD *)(a1 + 120) = 3;
    goto LABEL_26;
  }
  v11 = *(_DWORD *)(a1 + 120);
LABEL_25:
  if (v11 != 3)
    return 0;
LABEL_26:
  v41 = 0;
  v42 = 0;
  v31 = sftp_packet_requirev((_QWORD *)a1, (uint64_t)&sftp_open_fopen_responses, *(_DWORD *)(a1 + 152), &v41, &v42, 1uLL);
  if ((_DWORD)v31 == -38)
  {
    if (v42)
      (*(void (**)(uint64_t, uint64_t))(v10 + 24))(v41, v10);
    v26 = "Response too small";
    goto LABEL_32;
  }
  v28 = v31;
  if ((_DWORD)v31 == -37)
  {
    v26 = "Would block waiting for status message";
LABEL_35:
    v27 = v10;
    goto LABEL_36;
  }
  *(_DWORD *)(a1 + 120) = 0;
  if ((_DWORD)v31)
  {
    v26 = "Timeout waiting for status message";
    goto LABEL_35;
  }
  if (*(_BYTE *)v41 == 101)
  {
    if (v42 <= 8)
    {
      v33 = "Too small FXP_STATUS";
LABEL_50:
      _libssh2_error(v10, 4294967265, v33);
      (*(void (**)(uint64_t, uint64_t))(v10 + 24))(v41, v10);
      return 0;
    }
    v34 = _libssh2_ntohu32((unsigned int *)(v41 + 5));
    *(_DWORD *)(a1 + 64) = v34;
    if (v34)
    {
LABEL_43:
      v33 = "Failed opening remote file";
      goto LABEL_50;
    }
    (*(void (**)(uint64_t, uint64_t))(v10 + 24))(v41, v10);
    v35 = sftp_packet_require(a1, 102, *(_DWORD *)(a1 + 152), &v41, &v42, 0xAuLL);
    if (v35 != -38)
    {
      if (v35)
      {
        if (v35 == -37)
        {
          v30 = 0;
          *(_DWORD *)(a1 + 120) = 3;
          return v30;
        }
        goto LABEL_43;
      }
      goto LABEL_48;
    }
    if (v42)
      (*(void (**)(uint64_t, uint64_t))(v10 + 24))(v41, v10);
    v26 = "Too small FXP_HANDLE";
LABEL_32:
    v27 = v10;
    v28 = 4294967265;
    goto LABEL_36;
  }
LABEL_48:
  if (v42 <= 9)
  {
    v33 = "Too small FXP_HANDLE";
    goto LABEL_50;
  }
  v36 = _libssh2_calloc(v10, 0x188uLL);
  v30 = v36;
  if (v36)
  {
    *((_DWORD *)v36 + 74) = a6 != 0;
    v37 = _libssh2_ntohu32((unsigned int *)(v41 + 5));
    if (v37 >= 0x100)
      v38 = 256;
    else
      v38 = v37;
    v39 = v41;
    if (v42 - 9 >= v38)
      v40 = v38;
    else
      v40 = v42 - 9;
    v30[36] = v40;
    memcpy(v30 + 4, (const void *)(v39 + 9), v40);
    (*(void (**)(uint64_t, uint64_t))(v10 + 24))(v39, v10);
    _libssh2_list_add((_QWORD **)(a1 + 48), v30);
    v30[3] = a1;
    v30[38] = 0;
    v30[39] = 0;
  }
  else
  {
    _libssh2_error(v10, 4294967290, "Unable to allocate new SFTP handle structure");
    (*(void (**)(uint64_t, uint64_t))(v10 + 24))(v41, v10);
  }
  return v30;
}

_QWORD *libssh2_sftp_open_ex_r(_QWORD *result, const void *a2, unint64_t a3, unsigned int a4, uint64_t a5, int a6, uint64_t a7)
{
  uint64_t v13;
  time_t v14;

  if (result)
  {
    v13 = (uint64_t)result;
    v14 = time(0);
    while (1)
    {
      result = sftp_open(v13, a2, a3, a4, a5, a6, a7);
      if (!*(_DWORD *)(*(_QWORD *)(*(_QWORD *)v13 + 104) + 172) || result != 0)
        break;
      if (libssh2_session_last_errno(*(_QWORD *)(*(_QWORD *)v13 + 104)) != -37
        || _libssh2_wait_socket(*(_QWORD *)(*(_QWORD *)v13 + 104), v14))
      {
        return 0;
      }
    }
  }
  return result;
}

uint64_t libssh2_sftp_read(uint64_t a1, char *a2, size_t a3)
{
  uint64_t v5;
  _DWORD *v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  size_t v10;
  size_t v11;
  uint64_t v12;
  size_t v13;
  unint64_t v14;
  unint64_t v15;
  int v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  unsigned int v23;
  unint64_t v24;
  _BYTE *v25;
  unsigned int v26;
  BOOL v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  char *v35;
  int v36;
  int v38;
  unsigned int v39;
  unint64_t v40;
  size_t v41;
  unint64_t v42;
  BOOL v43;
  unint64_t v44;
  _DWORD *v45;
  uint64_t v46;
  uint64_t v47;
  char *v48;
  int v49;
  int v50;
  uint64_t v51;
  int v52;
  unsigned int v54;
  unint64_t v55;
  time_t v57;
  unint64_t v58;
  _DWORD *v59;

  if (!a1)
    return -39;
  v57 = time(0);
  v5 = 4 * a3;
  if (4 * a3 >= 0x800000)
    v5 = 0x800000;
  v55 = v5;
  v54 = 8 * v5;
  while (2)
  {
    v6 = *(_DWORD **)(a1 + 24);
    v7 = *(_QWORD *)v6;
    v8 = *(_QWORD *)(*(_QWORD *)v6 + 104);
    v9 = v6[39];
    if (v9 == 5)
    {
LABEL_44:
      v6[39] = 0;
      v33 = _libssh2_list_first(a1 + 376);
      if (v33)
      {
        v34 = v33;
        v11 = 0;
        v35 = a2;
        while (1)
        {
          v58 = 0;
          v59 = 0;
          if (*(_QWORD *)(v34 + 48))
          {
LABEL_67:
            if (v11)
              goto LABEL_80;
            goto LABEL_68;
          }
          v36 = sftp_packet_requirev(v6, (uint64_t)&sftp_read_read_responses, *(_DWORD *)(v34 + 56), &v59, &v58, 9uLL);
          if (v36 == -37 && v11 != 0)
            goto LABEL_80;
          if (v36 == -38)
          {
            if (v58)
              (*(void (**)(_DWORD *, uint64_t))(v8 + 24))(v59, v8);
            v47 = v8;
            v48 = "Response too small";
            goto LABEL_69;
          }
          if (v36 < 0)
          {
            v11 = v36;
            v49 = 5;
            goto LABEL_79;
          }
          v38 = *(unsigned __int8 *)v59;
          if (v38 != 103)
            break;
          if (*(_QWORD *)(v34 + 24) != *(_QWORD *)(a1 + 304))
          {
            v47 = v8;
            v48 = "Read Packet At Unexpected Offset";
            goto LABEL_69;
          }
          v39 = _libssh2_ntohu32((_DWORD *)((char *)v59 + 5));
          v40 = v58;
          if (v58 - 9 < v39)
          {
            v47 = v8;
            v48 = "SFTP Protocol badness";
            goto LABEL_69;
          }
          v41 = v39;
          v42 = *(_QWORD *)(v34 + 32);
          v43 = v39 >= v42;
          v44 = v39 - v42;
          if (v44 != 0 && v43)
          {
            v47 = v8;
            v48 = "FXP_READ response too big";
            goto LABEL_69;
          }
          if (v44)
            *(_QWORD *)(a1 + 312) += v44;
          if (v11 + v39 <= a3)
          {
            v40 = 0;
            v45 = v59;
            v11 += v39;
          }
          else
          {
            *(_QWORD *)(a1 + 344) = v11 + v39 - a3;
            v41 = (a3 - v11);
            v45 = v59;
            *(_QWORD *)(a1 + 328) = v59;
            v11 += v41;
          }
          *(_QWORD *)(a1 + 336) = v40;
          memcpy(v35, (char *)v45 + 9, v41);
          *(_QWORD *)(a1 + 304) += v41;
          if (!*(_QWORD *)(a1 + 336))
            (*(void (**)(_DWORD *, uint64_t))(v8 + 24))(v45, v8);
          v46 = _libssh2_list_next(v34);
          _libssh2_list_remove((uint64_t *)v34);
          (*(void (**)(uint64_t, uint64_t))(v8 + 24))(v34, v8);
          if (v11 < a3)
          {
            v35 += v41;
            v34 = v46;
            if (v46)
              continue;
          }
          goto LABEL_67;
        }
        if (v38 == 101)
        {
          _libssh2_list_remove((uint64_t *)v34);
          (*(void (**)(uint64_t, uint64_t))(v8 + 24))(v34, v8);
          sftp_packetlist_flush(a1);
          v50 = _libssh2_ntohu32((_DWORD *)((char *)v59 + 5));
          (*(void (**)(_DWORD *, uint64_t))(v8 + 24))(v59, v8);
          if (v50 == 1)
          {
            *(_BYTE *)(a1 + 352) = 1;
            goto LABEL_80;
          }
          v6[16] = v50;
          v47 = v8;
          v48 = "SFTP READ error";
        }
        else
        {
          v47 = v8;
          v48 = "SFTP Protocol badness: unrecognised read request response";
        }
      }
      else
      {
LABEL_68:
        v47 = v8;
        v48 = "sftp_read() internal error";
      }
LABEL_69:
      v16 = _libssh2_error(v47, 4294967265, v48);
      goto LABEL_70;
    }
    if (v9 != 3)
    {
      if (v9)
        libssh2_sftp_read_cold_1();
      v6[16] = 0;
      v10 = *(_QWORD *)(a1 + 344);
      if (v10)
      {
        if (v10 >= a3)
          v11 = a3;
        else
          v11 = *(_QWORD *)(a1 + 344);
        memcpy(a2, (const void *)(*(_QWORD *)(a1 + 328) + *(_QWORD *)(a1 + 336) - v10), v11);
        v12 = *(_QWORD *)(a1 + 344);
        *(_QWORD *)(a1 + 304) += v11;
        v13 = v12 - v11;
        *(_QWORD *)(a1 + 344) = v13;
        if (!v13)
        {
          (*(void (**)(_QWORD, uint64_t))(v8 + 24))(*(_QWORD *)(a1 + 328), v8);
          *(_QWORD *)(a1 + 328) = 0;
        }
        goto LABEL_80;
      }
      if (*(_BYTE *)(a1 + 352))
        return 0;
      v14 = *(_QWORD *)(a1 + 312) - *(_QWORD *)(a1 + 304);
      if (v55 >= v14)
        v15 = v55 - v14;
      else
        v15 = 0;
      if (v55 > libssh2_channel_window_read_ex(v7, 0, 0))
      {
        v16 = _libssh2_channel_receive_window_adjust(*(_QWORD *)v6, v54, 1, 0);
        if (v16)
        {
          if (v16 == -37)
          {
            if (*(_QWORD *)(a1 + 344))
              libssh2_sftp_read_cold_3();
            if (*(_BYTE *)(a1 + 352))
              libssh2_sftp_read_cold_2();
            goto LABEL_81;
          }
LABEL_70:
          v11 = v16;
          goto LABEL_80;
        }
      }
      if (v55 > v14)
      {
        do
        {
          v17 = a3;
          v59 = 0;
          v18 = *(_QWORD *)(a1 + 288);
          v19 = (v18 + 25);
          v20 = (*(uint64_t (**)(uint64_t, uint64_t))(v8 + 8))(v19 + 64, v8);
          if (!v20)
          {
            v11 = (int)_libssh2_error(v8, 4294967290, "malloc fail for FXP_WRITE");
            a3 = v17;
            goto LABEL_80;
          }
          v21 = v20;
          v22 = v17;
          if (v17 <= v15)
            v23 = v15;
          else
            v23 = v17;
          if (v23 >= 0x7530)
            v24 = 30000;
          else
            v24 = v23;
          *(_QWORD *)(v20 + 24) = *(_QWORD *)(a1 + 312);
          *(_QWORD *)(v20 + 32) = v24;
          *(_QWORD *)(v20 + 40) = 0;
          *(_QWORD *)(v20 + 48) = v19;
          a3 = v22;
          v59 = (_DWORD *)(v20 + 60);
          _libssh2_store_u32(&v59, v18 + 21);
          v25 = v59;
          v59 = (_DWORD *)((char *)v59 + 1);
          *v25 = 5;
          v26 = v6[2];
          v6[2] = v26 + 1;
          *(_DWORD *)(v21 + 56) = v26;
          _libssh2_store_u32(&v59, v26);
          _libssh2_store_str(&v59, (const void *)(a1 + 32), *(_QWORD *)(a1 + 288));
          *(_QWORD *)v59 = bswap64(*(_QWORD *)(a1 + 312));
          v59 += 2;
          *(_QWORD *)(a1 + 312) += v24;
          _libssh2_store_u32(&v59, v24);
          _libssh2_list_add((_QWORD **)(a1 + 376), (_QWORD *)v21);
          v27 = v15 > v24;
          if (v15 >= v24)
            v15 -= v24;
          else
            v15 = 0;
        }
        while (v27);
      }
    }
    v6[39] = 0;
    v28 = _libssh2_list_first(a1 + 376);
    if (!v28)
      goto LABEL_44;
    v29 = v28;
    while (1)
    {
      while (1)
      {
        v30 = *(_QWORD *)(v29 + 48);
        if (v30)
          break;
LABEL_43:
        v29 = _libssh2_list_next(v29);
        if (!v29)
          goto LABEL_44;
      }
      v31 = _libssh2_channel_write(v7, 0, (const void *)(v29 + *(_QWORD *)(v29 + 40) + 60), v30);
      v11 = v31;
      if (v31 < 0)
        break;
      v32 = *(_QWORD *)(v29 + 48) - v31;
      *(_QWORD *)(v29 + 40) += v31;
      *(_QWORD *)(v29 + 48) = v32;
      if (!v32)
        goto LABEL_43;
      if (v29 != _libssh2_list_first(a1 + 376))
        goto LABEL_44;
    }
    v49 = 3;
LABEL_79:
    v6[39] = v49;
LABEL_80:
    if (v11 == -37)
    {
LABEL_81:
      v51 = *(_QWORD *)(**(_QWORD **)(a1 + 24) + 104);
      if (!*(_DWORD *)(v51 + 172))
        return -37;
      v52 = _libssh2_wait_socket(v51, v57);
      if (v52)
        return v52;
      continue;
    }
    return v11;
  }
}

uint64_t libssh2_sftp_readdir_ex(uint64_t a1, void *a2, unint64_t a3, void *a4, unint64_t a5, uint64_t a6)
{
  time_t v12;
  uint64_t result;
  uint64_t v14;

  if (!a1)
    return 4294967257;
  v12 = time(0);
  while (1)
  {
    result = sftp_readdir(a1, a2, a3, a4, a5, a6);
    if (result != -37)
      break;
    v14 = *(_QWORD *)(**(_QWORD **)(a1 + 24) + 104);
    if (!*(_DWORD *)(v14 + 172))
      return -37;
    LODWORD(result) = _libssh2_wait_socket(v14, v12);
    if ((_DWORD)result)
      return result;
  }
  return result;
}

uint64_t sftp_readdir(uint64_t a1, void *a2, unint64_t a3, void *a4, unint64_t a5, uint64_t a6)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  char *v20;
  uint64_t v21;
  unint64_t v22;
  unint64_t v23;
  unsigned int *v25;
  unsigned int v26;
  uint64_t v27;
  unsigned int *v29;
  unint64_t v30;
  unsigned int *v31;
  unsigned int v32;
  unint64_t v33;
  char *v34;
  _QWORD *v36;
  _DWORD *v37;
  _BYTE *v38;
  unsigned int v39;
  uint64_t v40;
  int v41;
  int v42;
  uint64_t v43;
  uint64_t v44;
  int v45;
  uint64_t v47;
  _OWORD v48[3];
  uint64_t v49;
  uint64_t v50;
  _DWORD *v51;
  unint64_t v52;

  v11 = *(_QWORD *)(a1 + 24);
  v12 = *(_QWORD *)v11;
  v13 = *(_QWORD *)(*(_QWORD *)v11 + 104);
  v51 = 0;
  v52 = 0;
  v14 = *(_DWORD *)(a1 + 288);
  v50 = 0;
  v15 = *(_DWORD *)(v11 + 188);
  if (!v15)
  {
    *(_DWORD *)(v11 + 64) = 0;
    if (!*(_DWORD *)(a1 + 304))
    {
      v47 = a6;
      v37 = (_DWORD *)(*(uint64_t (**)(_QWORD, uint64_t))(v13 + 8))((v14 + 13), v13);
      *(_QWORD *)(v11 + 192) = v37;
      v51 = v37;
      if (!v37)
      {
        v20 = "Unable to allocate memory for FXP_READDIR packet";
        v21 = v13;
        v19 = 4294967290;
        return (int)_libssh2_error(v21, v19, v20);
      }
      _libssh2_store_u32(&v51, v14 + 9);
      v38 = v51;
      v51 = (_DWORD *)((char *)v51 + 1);
      *v38 = 12;
      v39 = *(_DWORD *)(v11 + 8);
      *(_DWORD *)(v11 + 8) = v39 + 1;
      *(_DWORD *)(v11 + 200) = v39;
      _libssh2_store_u32(&v51, v39);
      _libssh2_store_str(&v51, (const void *)(a1 + 32), *(_QWORD *)(a1 + 288));
      *(_DWORD *)(v11 + 188) = 2;
      goto LABEL_3;
    }
    v49 = 0;
    memset(v48, 0, sizeof(v48));
    v22 = *(_QWORD *)(a1 + 328);
    v23 = v22 - 4;
    if (v22 >= 4)
    {
      v25 = *(unsigned int **)(a1 + 320);
      v26 = _libssh2_ntohu32(v25);
      v27 = v26;
      if (v26 < a3 && v23 >= v26)
      {
        v29 = v25 + 1;
        memcpy(a2, v25 + 1, v26);
        *((_BYTE *)a2 + v27) = 0;
        v30 = v23 - v27 - 4;
        if (v23 - v27 >= 4)
        {
          v31 = (unsigned int *)((char *)v29 + v27);
          v32 = _libssh2_ntohu32(v31);
          v33 = v32;
          v34 = (char *)(v31 + 1);
          if (a4 && a5 >= 2)
          {
            if (v32 >= a5 || v30 < v32)
              return -38;
            memcpy(a4, v34, v32);
            *((_BYTE *)a4 + v33) = 0;
          }
          if (v30 >= v33)
          {
            if (a6)
            {
              v36 = (_QWORD *)a6;
              *(_QWORD *)(a6 + 48) = 0;
              *(_OWORD *)(a6 + 16) = 0u;
              *(_OWORD *)(a6 + 32) = 0u;
              *(_OWORD *)a6 = 0u;
            }
            else
            {
              v36 = v48;
            }
            v44 = sftp_bin2attr(v36, (uint64_t)&v34[v33], v30 - v33);
            if ((v44 & 0x8000000000000000) == 0)
            {
              *(_QWORD *)(a1 + 320) = &v34[v33 + v44];
              *(_QWORD *)(a1 + 328) = v30 - v33 - v44;
              v45 = *(_DWORD *)(a1 + 304) - 1;
              *(_DWORD *)(a1 + 304) = v45;
              if (!v45)
                (*(void (**)(_QWORD, uint64_t))(v13 + 24))(*(_QWORD *)(a1 + 312), v13);
              return v27;
            }
          }
        }
      }
    }
    return -38;
  }
  v47 = a6;
  if (v15 == 2)
  {
LABEL_3:
    v16 = _libssh2_channel_write(v12, 0, *(const void **)(v11 + 192), (v14 + 13));
    if (v16 == -37)
      return -37;
    v17 = v16;
    (*(void (**)(_QWORD, uint64_t))(v13 + 24))(*(_QWORD *)(v11 + 192), v13);
    *(_QWORD *)(v11 + 192) = 0;
    if (v17 != v14 + 13)
    {
      *(_DWORD *)(v11 + 188) = 0;
      v20 = "_libssh2_channel_write() failed";
      v21 = v13;
      v19 = 4294967289;
      return (int)_libssh2_error(v21, v19, v20);
    }
    *(_DWORD *)(v11 + 188) = 3;
  }
  v18 = sftp_packet_requirev((_QWORD *)v11, (uint64_t)&sftp_readdir_read_responses, *(_DWORD *)(v11 + 200), &v50, &v52, 9uLL);
  if ((_DWORD)v18)
  {
    v19 = v18;
    if ((_DWORD)v18 != -37)
    {
      if ((_DWORD)v18 != -38)
      {
        *(_DWORD *)(v11 + 188) = 0;
        v20 = "Timeout waiting for status message";
        v21 = v13;
        return (int)_libssh2_error(v21, v19, v20);
      }
      if (v52)
        (*(void (**)(uint64_t, uint64_t))(v13 + 24))(v50, v13);
      v20 = "Status message too short";
LABEL_12:
      v21 = v13;
      v19 = 4294967265;
      return (int)_libssh2_error(v21, v19, v20);
    }
    return -37;
  }
  v40 = v50;
  if (*(_BYTE *)v50 == 101)
  {
    v41 = _libssh2_ntohu32((unsigned int *)(v50 + 5));
    (*(void (**)(uint64_t, uint64_t))(v13 + 24))(v50, v13);
    if (v41 != 1)
    {
      *(_DWORD *)(v11 + 64) = v41;
      *(_DWORD *)(v11 + 188) = 0;
      v20 = "SFTP Protocol Error";
      goto LABEL_12;
    }
    v27 = 0;
    *(_DWORD *)(v11 + 188) = 0;
  }
  else
  {
    *(_DWORD *)(v11 + 188) = 0;
    v42 = _libssh2_ntohu32((unsigned int *)(v40 + 5));
    if (v42)
    {
      *(_DWORD *)(a1 + 304) = v42;
      v43 = v50 + 9;
      *(_QWORD *)(a1 + 312) = v50;
      *(_QWORD *)(a1 + 320) = v43;
      *(_QWORD *)(a1 + 328) = v52 - 9;
      return sftp_readdir(a1, a2, a3, a4, a5, v47);
    }
    else
    {
      (*(void (**)(uint64_t, uint64_t))(v13 + 24))(v50, v13);
      return 0;
    }
  }
  return v27;
}

uint64_t libssh2_sftp_write(_QWORD *a1, uint64_t a2, unint64_t a3)
{
  time_t v4;
  _DWORD *v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  char *v10;
  unint64_t v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  _BYTE *v16;
  unsigned int v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t result;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  int v26;
  uint64_t v27;
  unint64_t v28;
  uint64_t v29;
  char *v30;
  uint64_t v31;
  uint64_t v32;
  time_t v34;
  _QWORD **v36;
  uint64_t v37;
  _DWORD *v38;
  unint64_t v39;

  if (!a1)
    return -39;
  v4 = time(0);
  v36 = (_QWORD **)(a1 + 47);
  v34 = v4;
  while (1)
  {
    v5 = (_DWORD *)a1[3];
    v6 = *(_QWORD *)v5;
    v7 = *(_QWORD *)(*(_QWORD *)v5 + 104);
    v38 = 0;
    v39 = 0;
    v37 = 0;
    if (v5[41] == 3)
      break;
    v5[16] = 0;
    v8 = a1[39] - a1[38] + a1[40];
    v5[41] = 0;
    if (v8 >= a3)
    {
LABEL_14:
      v18 = _libssh2_list_first((uint64_t)v36);
      v4 = v34;
      if (v18)
      {
        v19 = v18;
        do
        {
          v20 = *(_QWORD *)(v19 + 48);
          if (v20)
          {
            result = _libssh2_channel_write(v6, 0, (const void *)(v19 + *(_QWORD *)(v19 + 40) + 60), v20);
            if (result < 0)
              goto LABEL_43;
            v22 = *(_QWORD *)(v19 + 48) - result;
            *(_QWORD *)(v19 + 40) += result;
            *(_QWORD *)(v19 + 48) = v22;
            if (v22)
              break;
          }
          v19 = _libssh2_list_next(v19);
        }
        while (v19);
      }
      break;
    }
    if (a3 >= v8)
      v9 = a3 - v8;
    else
      v9 = 0;
    v10 = (char *)(a2 + v8);
    while (1)
    {
      v11 = v9 >= 0x7530 ? 30000 : v9;
      v12 = a1[36] + v11;
      v13 = (v12 + 25);
      v14 = (*(uint64_t (**)(uint64_t, uint64_t))(v7 + 8))(v13 + 64, v7);
      if (!v14)
        break;
      v15 = v14;
      *(_QWORD *)(v14 + 32) = v11;
      *(_QWORD *)(v14 + 40) = 0;
      *(_QWORD *)(v14 + 48) = v13;
      v38 = (_DWORD *)(v14 + 60);
      _libssh2_store_u32(&v38, v12 + 21);
      v16 = v38;
      v38 = (_DWORD *)((char *)v38 + 1);
      *v16 = 6;
      v17 = v5[2];
      v5[2] = v17 + 1;
      *(_DWORD *)(v15 + 56) = v17;
      _libssh2_store_u32(&v38, v17);
      _libssh2_store_str(&v38, a1 + 4, a1[36]);
      *(_QWORD *)v38 = bswap64(a1[39]);
      v38 += 2;
      a1[39] += v11;
      _libssh2_store_str(&v38, v10, v11);
      _libssh2_list_add(v36, (_QWORD *)v15);
      v10 += v11;
      v9 -= v11;
      if (!v9)
        goto LABEL_14;
    }
    result = (int)_libssh2_error(v7, 4294967290, "malloc fail for FXP_WRITE");
    v4 = v34;
LABEL_43:
    if (result != -37)
      return result;
LABEL_44:
    v32 = *(_QWORD *)(*(_QWORD *)a1[3] + 104);
    if (!*(_DWORD *)(v32 + 172))
      return -37;
    LODWORD(result) = _libssh2_wait_socket(v32, v4);
    if ((_DWORD)result)
      return (int)result;
  }
  v5[41] = 0;
  v23 = _libssh2_list_first((uint64_t)v36);
  if (v23)
  {
    v24 = v23;
    v25 = 0;
    while (1)
    {
      if (*(_QWORD *)(v24 + 48) | v25)
        goto LABEL_29;
      LODWORD(result) = sftp_packet_require((uint64_t)v5, 101, *(_DWORD *)(v24 + 56), &v37, &v39, 9uLL);
      if ((_DWORD)result == -38)
        break;
      if ((result & 0x80000000) != 0)
      {
        if ((_DWORD)result == -37)
        {
          v5[41] = 3;
          goto LABEL_44;
        }
        goto LABEL_42;
      }
      v26 = _libssh2_ntohu32((unsigned int *)(v37 + 5));
      (*(void (**)(uint64_t, uint64_t))(v7 + 24))(v37, v7);
      v5[16] = v26;
      if (v26)
      {
        sftp_packetlist_flush((uint64_t)a1);
        v31 = a1[38] - a1[40];
        a1[38] = v31;
        a1[39] = v31;
        a1[40] = 0;
        v29 = v7;
        v30 = "FXP write failed";
        goto LABEL_41;
      }
      v25 = *(_QWORD *)(v24 + 32);
      a1[38] += v25;
      v27 = _libssh2_list_next(v24);
      _libssh2_list_remove((uint64_t *)v24);
      (*(void (**)(uint64_t, uint64_t))(v7 + 24))(v24, v7);
      v24 = v27;
      if (!v27)
        goto LABEL_29;
    }
    if (v39)
      (*(void (**)(uint64_t, uint64_t))(v7 + 24))(v37, v7);
    v29 = v7;
    v30 = "FXP write packet too short";
LABEL_41:
    LODWORD(result) = _libssh2_error(v29, 4294967265, v30);
LABEL_42:
    result = (int)result;
    goto LABEL_43;
  }
  v25 = 0;
LABEL_29:
  v28 = a1[40] + v25;
  if (v28)
  {
    if (v28 >= a3)
      result = a3;
    else
      result = a1[40] + v25;
    a1[40] = v28 - result;
    goto LABEL_43;
  }
  return 0;
}

uint64_t libssh2_sftp_fsync(_QWORD *a1)
{
  time_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  int v6;
  int v7;
  _DWORD *v8;
  const void *v9;
  _BYTE *v10;
  unsigned int v11;
  unint64_t v12;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  char *v18;
  int v19;
  uint64_t result;
  uint64_t v21;
  uint64_t v22;
  _DWORD *v23;
  unint64_t v24;

  if (!a1)
    return 4294967257;
  v2 = time(0);
  while (1)
  {
    v3 = a1[3];
    v4 = *(_QWORD *)v3;
    v5 = *(_QWORD *)(*(_QWORD *)v3 + 104);
    v6 = *((_DWORD *)a1 + 72);
    v23 = 0;
    v24 = 0;
    v22 = 0;
    v7 = *(_DWORD *)(v3 + 168);
    if (v7 == 2)
    {
      v9 = *(const void **)(v3 + 176);
    }
    else
    {
      if (v7)
        goto LABEL_15;
      *(_DWORD *)(v3 + 64) = 0;
      v8 = (_DWORD *)(*(uint64_t (**)(_QWORD, uint64_t))(v5 + 8))((v6 + 34), v5);
      v23 = v8;
      if (!v8)
      {
        v17 = v5;
        v16 = 4294967290;
        v18 = "Unable to allocate memory for FXP_EXTENDED packet";
        goto LABEL_26;
      }
      v9 = v8;
      _libssh2_store_u32(&v23, v6 + 30);
      v10 = v23;
      v23 = (_DWORD *)((char *)v23 + 1);
      *v10 = -56;
      v11 = *(_DWORD *)(v3 + 8);
      *(_DWORD *)(v3 + 8) = v11 + 1;
      *(_DWORD *)(v3 + 184) = v11;
      _libssh2_store_u32(&v23, v11);
      _libssh2_store_str(&v23, "fsync@openssh.com", 0x11uLL);
      _libssh2_store_str(&v23, a1 + 4, a1[36]);
      *(_DWORD *)(v3 + 168) = 2;
    }
    v12 = _libssh2_channel_write(v4, 0, v9, (v6 + 34));
    if (v12 == -37 || v12 < (v6 + 34))
    {
      *(_QWORD *)(v3 + 176) = v9;
      goto LABEL_27;
    }
    v14 = v12;
    (*(void (**)(const void *, uint64_t))(v5 + 24))(v9, v5);
    *(_QWORD *)(v3 + 176) = 0;
    if ((v14 & 0x8000000000000000) != 0)
    {
      *(_DWORD *)(v3 + 168) = 0;
      v17 = v5;
      v16 = 4294967289;
      v18 = "_libssh2_channel_write() failed";
      goto LABEL_26;
    }
    *(_DWORD *)(v3 + 168) = 3;
LABEL_15:
    v15 = sftp_packet_require(v3, 101, *(_DWORD *)(v3 + 184), &v22, &v24, 9uLL);
    if (!(_DWORD)v15)
      break;
    v16 = v15;
    if ((_DWORD)v15 == -37)
      goto LABEL_27;
    if ((_DWORD)v15 == -38)
    {
      if (v24)
        (*(void (**)(uint64_t, uint64_t))(v5 + 24))(v22, v5);
      v17 = v5;
      v16 = 4294967265;
      v18 = "SFTP fsync packet too short";
    }
    else
    {
      *(_DWORD *)(v3 + 168) = 0;
      v17 = v5;
      v18 = "Error waiting for FXP EXTENDED REPLY";
    }
LABEL_26:
    result = _libssh2_error(v17, v16, v18);
    if ((_DWORD)result != -37)
      return result;
LABEL_27:
    v21 = *(_QWORD *)(*(_QWORD *)a1[3] + 104);
    if (!*(_DWORD *)(v21 + 172))
      return 4294967259;
    result = _libssh2_wait_socket(v21, v2);
    if ((_DWORD)result)
      return result;
  }
  *(_DWORD *)(v3 + 168) = 0;
  v19 = _libssh2_ntohu32((unsigned int *)(v22 + 5));
  (*(void (**)(uint64_t, uint64_t))(v5 + 24))(v22, v5);
  if (v19)
  {
    *(_DWORD *)(v3 + 64) = v19;
    v17 = v5;
    v16 = 4294967265;
    v18 = "fsync failed";
    goto LABEL_26;
  }
  return 0;
}

uint64_t libssh2_sftp_fstat_ex(_QWORD *a1, uint64_t *a2, int a3)
{
  uint64_t result;
  time_t v7;
  char v8;
  const char *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  unint64_t v16;
  _DWORD *v17;
  char *v18;
  unsigned int v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  char *v26;
  int v27;
  uint64_t v28;
  uint64_t v29;
  char *v30;
  char v31;
  uint64_t v32;
  _DWORD *v33;
  unint64_t v34;

  result = 4294967257;
  if (a1 && a2)
  {
    v7 = time(0);
    if (a3)
      v8 = 10;
    else
      v8 = 8;
    v31 = v8;
    v9 = "Unable to send FXP_FSETSTAT";
    if (!a3)
      v9 = "Unable to send FXP_FSTAT command";
    v30 = (char *)v9;
    while (1)
    {
      v10 = a1[3];
      v11 = *(_QWORD *)v10;
      v12 = *(_QWORD *)(*(_QWORD *)v10 + 104);
      v34 = 0;
      v13 = a3 ? (*a2 & 0xC) + 8 * (*a2 & 1) + ((4 * *a2) & 8) + 4 : 0;
      v14 = a1[36] + 13 + v13;
      v32 = 0;
      v33 = 0;
      v15 = *(_DWORD *)(v10 + 204);
      if (!v15)
        break;
      if (v15 == 2)
      {
        v16 = v14;
LABEL_19:
        v21 = _libssh2_channel_write(v11, 0, *(const void **)(v10 + 208), v16);
        if (v21 == -37)
          goto LABEL_37;
        v22 = v21;
        (*(void (**)(_QWORD, uint64_t))(v12 + 24))(*(_QWORD *)(v10 + 208), v12);
        *(_QWORD *)(v10 + 208) = 0;
        if (v16 != v22)
        {
          *(_DWORD *)(v10 + 204) = 0;
          v25 = v12;
          v24 = 4294967289;
          v26 = v30;
          goto LABEL_36;
        }
        *(_DWORD *)(v10 + 204) = 3;
      }
      v23 = sftp_packet_requirev((_QWORD *)v10, (uint64_t)&sftp_fstat_fstat_responses, *(_DWORD *)(v10 + 216), &v32, &v34, 9uLL);
      if ((_DWORD)v23)
      {
        v24 = v23;
        if ((_DWORD)v23 == -37)
          goto LABEL_37;
        if ((_DWORD)v23 == -38)
        {
          if (v34)
            (*(void (**)(uint64_t, uint64_t))(v12 + 24))(v32, v12);
          v25 = v12;
          v24 = 4294967265;
          v26 = "SFTP fstat packet too short";
        }
        else
        {
          *(_DWORD *)(v10 + 204) = 0;
          v25 = v12;
          v26 = "Timeout waiting for status message";
        }
      }
      else
      {
        *(_DWORD *)(v10 + 204) = 0;
        if (*(_BYTE *)v32 == 101)
        {
          v27 = _libssh2_ntohu32((unsigned int *)(v32 + 5));
          (*(void (**)(uint64_t, uint64_t))(v12 + 24))(v32, v12);
          if (!v27)
            return 0;
          *(_DWORD *)(v10 + 64) = v27;
          v25 = v12;
          v24 = 4294967265;
          v26 = "SFTP Protocol Error";
        }
        else
        {
          v28 = sftp_bin2attr(a2, v32 + 5, v34 - 5);
          (*(void (**)(uint64_t, uint64_t))(v12 + 24))(v32, v12);
          if ((v28 & 0x8000000000000000) == 0)
            return 0;
          v25 = v12;
          v24 = 4294967265;
          v26 = "Attributes too short in SFTP fstat";
        }
      }
LABEL_36:
      result = _libssh2_error(v25, v24, v26);
      if ((_DWORD)result != -37)
        return result;
LABEL_37:
      v29 = *(_QWORD *)(*(_QWORD *)a1[3] + 104);
      if (!*(_DWORD *)(v29 + 172))
        return 4294967259;
      result = _libssh2_wait_socket(v29, v7);
      if ((_DWORD)result)
        return result;
    }
    *(_DWORD *)(v10 + 64) = 0;
    v16 = v14;
    v17 = (_DWORD *)(*(uint64_t (**)(_QWORD, uint64_t))(v12 + 8))(v14, v12);
    *(_QWORD *)(v10 + 208) = v17;
    v33 = v17;
    if (!v17)
    {
      v25 = v12;
      v24 = 4294967290;
      v26 = "Unable to allocate memory for FSTAT/FSETSTAT packet";
      goto LABEL_36;
    }
    _libssh2_store_u32(&v33, v14 - 4);
    v18 = (char *)v33;
    v33 = (_DWORD *)((char *)v33 + 1);
    *v18 = v31;
    v19 = *(_DWORD *)(v10 + 8);
    *(_DWORD *)(v10 + 8) = v19 + 1;
    *(_DWORD *)(v10 + 216) = v19;
    _libssh2_store_u32(&v33, v19);
    _libssh2_store_str(&v33, a1 + 4, a1[36]);
    if (a3)
    {
      v20 = sftp_attr2bin((char *)v33, a2);
      v33 = (_DWORD *)((char *)v33 + v20);
    }
    *(_DWORD *)(v10 + 204) = 2;
    goto LABEL_19;
  }
  return result;
}

uint64_t libssh2_sftp_seek64(uint64_t result, uint64_t a2)
{
  uint64_t v2;

  if (result)
  {
    v2 = result;
    if (*(_QWORD *)(result + 304) != a2 || *(_QWORD *)(result + 312) != a2)
    {
      *(_QWORD *)(result + 304) = a2;
      *(_QWORD *)(result + 312) = a2;
      result = sftp_packetlist_flush(result);
      if (*(_QWORD *)(v2 + 344))
      {
        result = (*(uint64_t (**)(_QWORD))(*(_QWORD *)(**(_QWORD **)(v2 + 24) + 104) + 24))(*(_QWORD *)(v2 + 328));
        *(_QWORD *)(v2 + 328) = 0;
        *(_QWORD *)(v2 + 336) = 0;
        *(_QWORD *)(v2 + 344) = 0;
      }
      *(_BYTE *)(v2 + 352) = 0;
    }
  }
  return result;
}

uint64_t sftp_packetlist_flush(uint64_t a1)
{
  _QWORD **v1;
  uint64_t v2;
  uint64_t result;
  uint64_t v4;
  uint64_t v5;
  int v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  v1 = *(_QWORD ***)(a1 + 24);
  v2 = (*v1)[13];
  result = _libssh2_list_first(a1 + 376);
  if (result)
  {
    v4 = result;
    do
    {
      v10 = 0;
      v5 = _libssh2_list_next(v4);
      if (sftp_packet_ask((uint64_t)v1, 101, *(_DWORD *)(v4 + 56), &v10, &v9)
        && sftp_packet_ask((uint64_t)v1, 103, *(_DWORD *)(v4 + 56), &v10, &v9))
      {
        if (*(_QWORD *)(v4 + 40))
        {
          v6 = *(_DWORD *)(v4 + 56);
          v7 = (*v1)[13];
          v8 = (*(uint64_t (**)(uint64_t, uint64_t))(v7 + 8))(32, v7);
          if (v8)
          {
            *(_DWORD *)(v8 + 24) = v6;
            _libssh2_list_add(v1 + 4, (_QWORD *)v8);
          }
          else
          {
            _libssh2_error(v7, 4294967290, "malloc fail for zombie request  ID");
          }
        }
      }
      else
      {
        (*(void (**)(uint64_t, uint64_t))(v2 + 24))(v10, v2);
      }
      _libssh2_list_remove((uint64_t *)v4);
      result = (*(uint64_t (**)(uint64_t, uint64_t))(v2 + 24))(v4, v2);
      v4 = v5;
    }
    while (v5);
  }
  return result;
}

uint64_t libssh2_sftp_tell(uint64_t result)
{
  if (result)
    return *(_QWORD *)(result + 304);
  return result;
}

uint64_t libssh2_sftp_tell64(uint64_t result)
{
  if (result)
    return *(_QWORD *)(result + 304);
  return result;
}

uint64_t libssh2_sftp_close_handle(uint64_t a1)
{
  time_t v2;
  _DWORD *v3;
  uint64_t v4;
  uint64_t v5;
  int v6;
  unint64_t v7;
  int v8;
  uint64_t v9;
  _DWORD *v10;
  _BYTE *v11;
  unsigned int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  int v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v24;
  _DWORD *v25;
  unint64_t v26;

  if (a1)
  {
    v2 = time(0);
    while (1)
    {
      v3 = *(_DWORD **)(a1 + 24);
      v4 = *(_QWORD *)v3;
      v5 = *(_QWORD *)(*(_QWORD *)v3 + 104);
      v25 = 0;
      v26 = 0;
      v6 = *(_DWORD *)(a1 + 288);
      v7 = (v6 + 13);
      v24 = 0;
      v8 = *(_DWORD *)(a1 + 360);
      if (v8)
      {
        v9 = 0;
      }
      else
      {
        v3[16] = 0;
        v10 = (_DWORD *)(*(uint64_t (**)(_QWORD, uint64_t))(v5 + 8))((v6 + 13), v5);
        *(_QWORD *)(a1 + 368) = v10;
        v25 = v10;
        if (v10)
        {
          _libssh2_store_u32(&v25, v6 + 9);
          v11 = v25;
          v25 = (_DWORD *)((char *)v25 + 1);
          *v11 = 4;
          v12 = v3[2];
          v3[2] = v12 + 1;
          *(_DWORD *)(a1 + 364) = v12;
          _libssh2_store_u32(&v25, v12);
          _libssh2_store_str(&v25, (const void *)(a1 + 32), *(_QWORD *)(a1 + 288));
          v9 = 0;
          *(_DWORD *)(a1 + 360) = 2;
LABEL_9:
          v13 = _libssh2_channel_write(v4, 0, *(const void **)(a1 + 368), v7);
          if (v13 == -37)
            goto LABEL_35;
          if (v13 == v7)
          {
            *(_DWORD *)(a1 + 360) = 3;
          }
          else
          {
            *(_DWORD *)(a1 + 360) = 0;
            v9 = _libssh2_error(v5, 4294967289, "Unable to send FXP_CLOSE command");
          }
          (*(void (**)(_QWORD, uint64_t))(v5 + 24))(*(_QWORD *)(a1 + 368), v5);
          *(_QWORD *)(a1 + 368) = 0;
          v8 = *(_DWORD *)(a1 + 360);
          goto LABEL_14;
        }
        *(_DWORD *)(a1 + 360) = 0;
        v9 = _libssh2_error(v5, 4294967290, "Unable to allocate memory for FXP_CLOSE packet");
        v8 = *(_DWORD *)(a1 + 360);
      }
      if (v8 == 2)
        goto LABEL_9;
      if (v8 != 3)
        goto LABEL_27;
LABEL_14:
      v14 = sftp_packet_require((uint64_t)v3, 101, *(_DWORD *)(a1 + 364), &v24, &v26, 9uLL);
      v9 = v14;
      if ((_DWORD)v14)
      {
        if ((_DWORD)v14 == -37)
          goto LABEL_35;
        if ((_DWORD)v14 == -38)
        {
          if (v26)
            (*(void (**)(uint64_t, uint64_t))(v5 + 24))(v24, v5);
          v24 = 0;
          v15 = v5;
          v16 = 4294967265;
          v17 = "Packet too short in FXP_CLOSE command";
        }
        else
        {
          v15 = v5;
          v16 = v9;
          v17 = "Error waiting for status message";
        }
        _libssh2_error(v15, v16, v17);
      }
      *(_DWORD *)(a1 + 360) = 4;
      if (v24)
      {
        v18 = _libssh2_ntohu32((unsigned int *)(v24 + 5));
        (*(void (**)(uint64_t, uint64_t))(v5 + 24))(v24, v5);
        if (v18)
        {
          v3[16] = v18;
          *(_DWORD *)(a1 + 360) = 0;
          v9 = _libssh2_error(v5, 4294967265, "SFTP Protocol Error");
        }
      }
      else
      {
LABEL_27:
        if (!(_DWORD)v9)
          libssh2_sftp_close_handle_cold_1();
      }
      _libssh2_list_remove((uint64_t *)a1);
      v19 = *(_DWORD *)(a1 + 296);
      if (v19)
      {
        if (v19 == 1 && *(_DWORD *)(a1 + 304))
          (*(void (**)(_QWORD, uint64_t))(v5 + 24))(*(_QWORD *)(a1 + 312), v5);
      }
      else
      {
        v20 = *(_QWORD *)(a1 + 328);
        if (v20)
          (*(void (**)(uint64_t, uint64_t))(v5 + 24))(v20, v5);
      }
      sftp_packetlist_flush(a1);
      v3[39] = 0;
      *(_DWORD *)(a1 + 360) = 0;
      (*(void (**)(uint64_t, uint64_t))(v5 + 24))(a1, v5);
      if ((_DWORD)v9 != -37)
        return v9;
LABEL_35:
      v21 = *(_QWORD *)(**(_QWORD **)(a1 + 24) + 104);
      if (!*(_DWORD *)(v21 + 172))
        return 4294967259;
      v22 = _libssh2_wait_socket(v21, v2);
      if ((_DWORD)v22)
        return v22;
    }
  }
  return 4294967257;
}

uint64_t libssh2_sftp_unlink_ex(uint64_t a1, const void *a2, unsigned int a3)
{
  time_t v6;
  unint64_t v7;
  unint64_t v8;
  unsigned int v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  _DWORD *v13;
  _BYTE *v14;
  unsigned int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  int v22;
  uint64_t result;
  uint64_t v24;
  uint64_t v25;
  _DWORD *v26;
  unint64_t v27;

  if (!a1)
    return 4294967257;
  v6 = time(0);
  v7 = a3;
  v8 = a3 + 13;
  v9 = a3 + 9;
  while (1)
  {
    v10 = *(_QWORD *)a1;
    v11 = *(_QWORD *)(*(_QWORD *)a1 + 104);
    v26 = 0;
    v27 = 0;
    v25 = 0;
    v12 = *(_DWORD *)(a1 + 220);
    if (v12 != 2)
    {
      if (v12)
        goto LABEL_10;
      *(_DWORD *)(a1 + 64) = 0;
      v13 = (_DWORD *)(*(uint64_t (**)(unint64_t, uint64_t))(v11 + 8))(v8, v11);
      *(_QWORD *)(a1 + 224) = v13;
      v26 = v13;
      if (!v13)
      {
        v20 = v11;
        v19 = 4294967290;
        v21 = "Unable to allocate memory for FXP_REMOVE packet";
        goto LABEL_21;
      }
      _libssh2_store_u32(&v26, v9);
      v14 = v26;
      v26 = (_DWORD *)((char *)v26 + 1);
      *v14 = 13;
      v15 = *(_DWORD *)(a1 + 8);
      *(_DWORD *)(a1 + 8) = v15 + 1;
      *(_DWORD *)(a1 + 232) = v15;
      _libssh2_store_u32(&v26, v15);
      _libssh2_store_str(&v26, a2, v7);
      *(_DWORD *)(a1 + 220) = 2;
    }
    v16 = _libssh2_channel_write(v10, 0, *(const void **)(a1 + 224), v8);
    if (v16 == -37)
      goto LABEL_22;
    v17 = v16;
    (*(void (**)(_QWORD, uint64_t))(v11 + 24))(*(_QWORD *)(a1 + 224), v11);
    *(_QWORD *)(a1 + 224) = 0;
    if (v17 != v8)
    {
      *(_DWORD *)(a1 + 220) = 0;
      v20 = v11;
      v19 = 4294967289;
      v21 = "Unable to send FXP_REMOVE command";
      goto LABEL_21;
    }
    *(_DWORD *)(a1 + 220) = 3;
LABEL_10:
    v18 = sftp_packet_require(a1, 101, *(_DWORD *)(a1 + 232), &v25, &v27, 9uLL);
    if (!(_DWORD)v18)
      break;
    v19 = v18;
    if ((_DWORD)v18 == -37)
      goto LABEL_22;
    if ((_DWORD)v18 == -38)
    {
      if (v27)
        (*(void (**)(uint64_t, uint64_t))(v11 + 24))(v25, v11);
      v20 = v11;
      v19 = 4294967265;
      v21 = "SFTP unlink packet too short";
    }
    else
    {
      *(_DWORD *)(a1 + 220) = 0;
      v20 = v11;
      v21 = "Error waiting for FXP STATUS";
    }
LABEL_21:
    result = _libssh2_error(v20, v19, v21);
    if ((_DWORD)result != -37)
      return result;
LABEL_22:
    v24 = *(_QWORD *)(*(_QWORD *)a1 + 104);
    if (!*(_DWORD *)(v24 + 172))
      return 4294967259;
    result = _libssh2_wait_socket(v24, v6);
    if ((_DWORD)result)
      return result;
  }
  *(_DWORD *)(a1 + 220) = 0;
  v22 = _libssh2_ntohu32((unsigned int *)(v25 + 5));
  (*(void (**)(uint64_t, uint64_t))(v11 + 24))(v25, v11);
  if (v22)
  {
    *(_DWORD *)(a1 + 64) = v22;
    v20 = v11;
    v19 = 4294967265;
    v21 = "SFTP Protocol Error";
    goto LABEL_21;
  }
  return 0;
}

uint64_t libssh2_sftp_rename_ex(uint64_t a1, const void *a2, unsigned int a3, const void *a4, unsigned int a5, unsigned int a6)
{
  time_t v11;
  int v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unsigned int v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  uint64_t v22;
  _BYTE *v23;
  unsigned int v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  int v28;
  uint64_t result;
  uint64_t v30;
  unint64_t v32;
  uint64_t v33;
  unint64_t v34;

  if (!a1)
    return 4294967257;
  v11 = time(0);
  v12 = a3 + a5 + 17;
  v32 = a3;
  v13 = a5;
  while (1)
  {
    v14 = *(_QWORD *)a1;
    v15 = *(_QWORD *)(*(_QWORD *)a1 + 104);
    v33 = 0;
    v34 = 0;
    v16 = *(_DWORD *)(a1 + 12);
    v17 = v12 + 4 * (v16 > 4);
    v18 = *(_DWORD *)(a1 + 236);
    if (v18 != 2)
    {
      if (v18)
        goto LABEL_14;
      *(_DWORD *)(a1 + 64) = 0;
      if (v16 <= 1)
      {
        v19 = v15;
        v20 = 4294967265;
        v21 = "Server does not support RENAME";
        goto LABEL_29;
      }
      v22 = (*(uint64_t (**)(uint64_t, uint64_t))(v15 + 8))(v17, v15);
      *(_QWORD *)(a1 + 240) = v22;
      *(_QWORD *)(a1 + 248) = v22;
      if (!v22)
      {
        v19 = v15;
        v20 = 4294967290;
        v21 = "Unable to allocate memory for FXP_RENAME packet";
        goto LABEL_29;
      }
      _libssh2_store_u32((_DWORD **)(a1 + 248), v17 - 4);
      v23 = *(_BYTE **)(a1 + 248);
      *(_QWORD *)(a1 + 248) = v23 + 1;
      *v23 = 18;
      v24 = *(_DWORD *)(a1 + 8);
      *(_DWORD *)(a1 + 8) = v24 + 1;
      *(_DWORD *)(a1 + 256) = v24;
      _libssh2_store_u32((_DWORD **)(a1 + 248), v24);
      _libssh2_store_str((_DWORD **)(a1 + 248), a2, v32);
      _libssh2_store_str((_DWORD **)(a1 + 248), a4, v13);
      if (*(_DWORD *)(a1 + 12) >= 5u)
        _libssh2_store_u32((_DWORD **)(a1 + 248), a6);
      *(_DWORD *)(a1 + 236) = 2;
    }
    v25 = _libssh2_channel_write(v14, 0, *(const void **)(a1 + 240), *(_QWORD *)(a1 + 248) - *(_QWORD *)(a1 + 240));
    if (v25 == -37)
      goto LABEL_30;
    v26 = v25;
    (*(void (**)(_QWORD, uint64_t))(v15 + 24))(*(_QWORD *)(a1 + 240), v15);
    *(_QWORD *)(a1 + 240) = 0;
    if (v26 != v17)
    {
      *(_DWORD *)(a1 + 236) = 0;
      v19 = v15;
      v20 = 4294967289;
      v21 = "Unable to send FXP_RENAME command";
      goto LABEL_29;
    }
    *(_DWORD *)(a1 + 236) = 3;
LABEL_14:
    v27 = sftp_packet_require(a1, 101, *(_DWORD *)(a1 + 256), &v33, &v34, 9uLL);
    if (!(_DWORD)v27)
      break;
    v20 = v27;
    if ((_DWORD)v27 == -37)
      goto LABEL_30;
    if ((_DWORD)v27 == -38)
    {
      if (v34)
        (*(void (**)(uint64_t, uint64_t))(v15 + 24))(v33, v15);
      v19 = v15;
      v20 = 4294967265;
      v21 = "SFTP rename packet too short";
    }
    else
    {
      *(_DWORD *)(a1 + 236) = 0;
      v19 = v15;
      v21 = "Error waiting for FXP STATUS";
    }
LABEL_29:
    result = _libssh2_error(v19, v20, v21);
    if ((_DWORD)result != -37)
      return result;
LABEL_30:
    v30 = *(_QWORD *)(*(_QWORD *)a1 + 104);
    if (!*(_DWORD *)(v30 + 172))
      return 4294967259;
    result = _libssh2_wait_socket(v30, v11);
    if ((_DWORD)result)
      return result;
  }
  *(_DWORD *)(a1 + 236) = 0;
  v28 = _libssh2_ntohu32((unsigned int *)(v33 + 5));
  (*(void (**)(uint64_t, uint64_t))(v15 + 24))(v33, v15);
  *(_DWORD *)(a1 + 64) = v28;
  if (v28 == 8)
  {
    v19 = v15;
    v20 = 4294967265;
    v21 = "Operation Not Supported";
    goto LABEL_29;
  }
  if (v28 == 11)
  {
    v19 = v15;
    v20 = 4294967265;
    v21 = "File already exists and SSH_FXP_RENAME_OVERWRITE not specified";
    goto LABEL_29;
  }
  if (v28)
  {
    v19 = v15;
    v20 = 4294967265;
    v21 = "SFTP Protocol Error";
    goto LABEL_29;
  }
  return 0;
}

uint64_t libssh2_sftp_fstatvfs(_QWORD *a1, unint64_t *a2)
{
  uint64_t result;
  time_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  int v9;
  _DWORD *v10;
  const void *v11;
  _BYTE *v12;
  unsigned int v13;
  unint64_t v14;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  char *v20;
  uint64_t v21;
  int v22;
  uint64_t v23;
  unint64_t v24;
  uint64_t v25;
  char v26;
  unint64_t v27;
  uint64_t v29;
  _DWORD *v30;
  unint64_t v31;

  result = 4294967257;
  if (a1 && a2)
  {
    v4 = time(0);
    do
    {
      v5 = a1[3];
      v6 = *(_QWORD *)v5;
      v7 = *(_QWORD *)(*(_QWORD *)v5 + 104);
      v30 = 0;
      v31 = 0;
      v8 = *((_DWORD *)a1 + 72);
      v29 = 0;
      v9 = *(_DWORD *)(v5 + 260);
      if (v9 == 2)
      {
        v11 = *(const void **)(v5 + 264);
      }
      else
      {
        if (v9)
          goto LABEL_16;
        *(_DWORD *)(v5 + 64) = 0;
        v10 = (_DWORD *)(*(uint64_t (**)(_QWORD, uint64_t))(v7 + 8))((v8 + 37), v7);
        v30 = v10;
        if (!v10)
        {
          v19 = v7;
          v18 = 4294967290;
          v20 = "Unable to allocate memory for FXP_EXTENDED packet";
          goto LABEL_29;
        }
        v11 = v10;
        _libssh2_store_u32(&v30, v8 + 33);
        v12 = v30;
        v30 = (_DWORD *)((char *)v30 + 1);
        *v12 = -56;
        v13 = *(_DWORD *)(v5 + 8);
        *(_DWORD *)(v5 + 8) = v13 + 1;
        *(_DWORD *)(v5 + 272) = v13;
        _libssh2_store_u32(&v30, v13);
        _libssh2_store_str(&v30, "fstatvfs@openssh.com", 0x14uLL);
        _libssh2_store_str(&v30, a1 + 4, a1[36]);
        *(_DWORD *)(v5 + 260) = 2;
      }
      v14 = _libssh2_channel_write(v6, 0, v11, (v8 + 37));
      if (v14 == -37 || v14 < (v8 + 37))
      {
        *(_QWORD *)(v5 + 264) = v11;
        goto LABEL_30;
      }
      v16 = v14;
      (*(void (**)(const void *, uint64_t))(v7 + 24))(v11, v7);
      *(_QWORD *)(v5 + 264) = 0;
      if ((v16 & 0x8000000000000000) != 0)
      {
        *(_DWORD *)(v5 + 260) = 0;
        v19 = v7;
        v18 = 4294967289;
        v20 = "_libssh2_channel_write() failed";
        goto LABEL_29;
      }
      *(_DWORD *)(v5 + 260) = 3;
LABEL_16:
      v17 = sftp_packet_requirev((_QWORD *)v5, (uint64_t)&sftp_fstatvfs_responses, *(_DWORD *)(v5 + 272), &v29, &v31, 9uLL);
      if ((_DWORD)v17)
      {
        v18 = v17;
        if ((_DWORD)v17 == -37)
          goto LABEL_30;
        if ((_DWORD)v17 == -38)
        {
          if (v31)
            (*(void (**)(uint64_t, uint64_t))(v7 + 24))(v29, v7);
          v19 = v7;
          v18 = 4294967265;
          v20 = "SFTP rename packet too short";
        }
        else
        {
          *(_DWORD *)(v5 + 260) = 0;
          v19 = v7;
          v20 = "Error waiting for FXP EXTENDED REPLY";
        }
      }
      else
      {
        v21 = v29;
        if (*(_BYTE *)v29 == 101)
        {
          v22 = _libssh2_ntohu32((unsigned int *)(v29 + 5));
          *(_DWORD *)(v5 + 260) = 0;
          (*(void (**)(uint64_t, uint64_t))(v7 + 24))(v29, v7);
          *(_DWORD *)(v5 + 64) = v22;
          v19 = v7;
          v18 = 4294967265;
          v20 = "SFTP Protocol Error";
        }
        else
        {
          if (v31 > 0x5C)
          {
            *(_DWORD *)(v5 + 260) = 0;
            v24 = _libssh2_ntohu64((unint64_t *)(v21 + 5));
            v25 = v29;
            *a2 = v24;
            a2[1] = _libssh2_ntohu64((unint64_t *)(v25 + 13));
            a2[2] = _libssh2_ntohu64((unint64_t *)(v29 + 21));
            a2[3] = _libssh2_ntohu64((unint64_t *)(v29 + 29));
            a2[4] = _libssh2_ntohu64((unint64_t *)(v29 + 37));
            a2[5] = _libssh2_ntohu64((unint64_t *)(v29 + 45));
            a2[6] = _libssh2_ntohu64((unint64_t *)(v29 + 53));
            a2[7] = _libssh2_ntohu64((unint64_t *)(v29 + 61));
            a2[8] = _libssh2_ntohu64((unint64_t *)(v29 + 69));
            v26 = _libssh2_ntohu64((unint64_t *)(v29 + 77));
            v27 = _libssh2_ntohu64((unint64_t *)(v29 + 85));
            a2[9] = v26 & 3;
            a2[10] = v27;
            (*(void (**)(uint64_t, uint64_t))(v7 + 24))(v29, v7);
            return 0;
          }
          (*(void (**)(void))(v7 + 24))();
          *(_DWORD *)(v5 + 260) = 0;
          v19 = v7;
          v18 = 4294967265;
          v20 = "SFTP Protocol Error: short response";
        }
      }
LABEL_29:
      result = _libssh2_error(v19, v18, v20);
      if ((_DWORD)result != -37)
        return result;
LABEL_30:
      v23 = *(_QWORD *)(*(_QWORD *)a1[3] + 104);
      if (!*(_DWORD *)(v23 + 172))
        return 4294967259;
      result = _libssh2_wait_socket(v23, v4);
    }
    while (!(_DWORD)result);
  }
  return result;
}

uint64_t libssh2_sftp_statvfs(uint64_t a1, const void *a2, unsigned int a3, unint64_t *a4)
{
  uint64_t result;
  time_t v8;
  unint64_t v9;
  unsigned int v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  _DWORD *v15;
  const void *v16;
  _BYTE *v17;
  unsigned int v18;
  unint64_t v19;
  unint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  char *v25;
  uint64_t v26;
  int v27;
  uint64_t v28;
  unint64_t v29;
  uint64_t v30;
  char v31;
  unint64_t v32;
  uint64_t v34;
  _DWORD *v35;
  unint64_t v36;

  result = 4294967257;
  if (a1 && a4)
  {
    v8 = time(0);
    v9 = a3 + 36;
    v10 = a3 + 32;
    v11 = a3;
    do
    {
      v12 = *(_QWORD *)a1;
      v13 = *(_QWORD *)(*(_QWORD *)a1 + 104);
      v35 = 0;
      v36 = 0;
      v34 = 0;
      v14 = *(_DWORD *)(a1 + 276);
      if (v14 == 2)
      {
        v16 = *(const void **)(a1 + 280);
      }
      else
      {
        if (v14)
          goto LABEL_16;
        *(_DWORD *)(a1 + 64) = 0;
        v15 = (_DWORD *)(*(uint64_t (**)(unint64_t, uint64_t))(v13 + 8))(v9, v13);
        v35 = v15;
        if (!v15)
        {
          v24 = v13;
          v23 = 4294967290;
          v25 = "Unable to allocate memory for FXP_EXTENDED packet";
          goto LABEL_29;
        }
        v16 = v15;
        _libssh2_store_u32(&v35, v10);
        v17 = v35;
        v35 = (_DWORD *)((char *)v35 + 1);
        *v17 = -56;
        v18 = *(_DWORD *)(a1 + 8);
        *(_DWORD *)(a1 + 8) = v18 + 1;
        *(_DWORD *)(a1 + 288) = v18;
        _libssh2_store_u32(&v35, v18);
        _libssh2_store_str(&v35, "statvfs@openssh.com", 0x13uLL);
        _libssh2_store_str(&v35, a2, v11);
        *(_DWORD *)(a1 + 276) = 2;
      }
      v19 = _libssh2_channel_write(v12, 0, v16, v9);
      if (v19 == -37 || v19 < v9)
      {
        *(_QWORD *)(a1 + 280) = v16;
        goto LABEL_30;
      }
      v21 = v19;
      (*(void (**)(const void *, uint64_t))(v13 + 24))(v16, v13);
      *(_QWORD *)(a1 + 280) = 0;
      if ((v21 & 0x8000000000000000) != 0)
      {
        *(_DWORD *)(a1 + 276) = 0;
        v24 = v13;
        v23 = 4294967289;
        v25 = "_libssh2_channel_write() failed";
        goto LABEL_29;
      }
      *(_DWORD *)(a1 + 276) = 3;
LABEL_16:
      v22 = sftp_packet_requirev((_QWORD *)a1, (uint64_t)&sftp_statvfs_responses, *(_DWORD *)(a1 + 288), &v34, &v36, 9uLL);
      if ((_DWORD)v22)
      {
        v23 = v22;
        if ((_DWORD)v22 == -37)
          goto LABEL_30;
        if ((_DWORD)v22 == -38)
        {
          if (v36)
            (*(void (**)(uint64_t, uint64_t))(v13 + 24))(v34, v13);
          v24 = v13;
          v23 = 4294967265;
          v25 = "SFTP fstat packet too short";
        }
        else
        {
          *(_DWORD *)(a1 + 276) = 0;
          v24 = v13;
          v25 = "Error waiting for FXP EXTENDED REPLY";
        }
      }
      else
      {
        v26 = v34;
        if (*(_BYTE *)v34 == 101)
        {
          v27 = _libssh2_ntohu32((unsigned int *)(v34 + 5));
          *(_DWORD *)(a1 + 276) = 0;
          (*(void (**)(uint64_t, uint64_t))(v13 + 24))(v34, v13);
          *(_DWORD *)(a1 + 64) = v27;
          v24 = v13;
          v23 = 4294967265;
          v25 = "SFTP Protocol Error";
        }
        else
        {
          if (v36 > 0x5C)
          {
            *(_DWORD *)(a1 + 276) = 0;
            v29 = _libssh2_ntohu64((unint64_t *)(v26 + 5));
            v30 = v34;
            *a4 = v29;
            a4[1] = _libssh2_ntohu64((unint64_t *)(v30 + 13));
            a4[2] = _libssh2_ntohu64((unint64_t *)(v34 + 21));
            a4[3] = _libssh2_ntohu64((unint64_t *)(v34 + 29));
            a4[4] = _libssh2_ntohu64((unint64_t *)(v34 + 37));
            a4[5] = _libssh2_ntohu64((unint64_t *)(v34 + 45));
            a4[6] = _libssh2_ntohu64((unint64_t *)(v34 + 53));
            a4[7] = _libssh2_ntohu64((unint64_t *)(v34 + 61));
            a4[8] = _libssh2_ntohu64((unint64_t *)(v34 + 69));
            v31 = _libssh2_ntohu64((unint64_t *)(v34 + 77));
            v32 = _libssh2_ntohu64((unint64_t *)(v34 + 85));
            a4[9] = v31 & 3;
            a4[10] = v32;
            (*(void (**)(uint64_t, uint64_t))(v13 + 24))(v34, v13);
            return 0;
          }
          (*(void (**)(void))(v13 + 24))();
          *(_DWORD *)(a1 + 276) = 0;
          v24 = v13;
          v23 = 4294967265;
          v25 = "SFTP Protocol Error: short response";
        }
      }
LABEL_29:
      result = _libssh2_error(v24, v23, v25);
      if ((_DWORD)result != -37)
        return result;
LABEL_30:
      v28 = *(_QWORD *)(*(_QWORD *)a1 + 104);
      if (!*(_DWORD *)(v28 + 172))
        return 4294967259;
      result = _libssh2_wait_socket(v28, v8);
    }
    while (!(_DWORD)result);
  }
  return result;
}

uint64_t libssh2_sftp_mkdir_ex(uint64_t a1, const void *a2, unsigned int a3, uint64_t a4)
{
  time_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  unint64_t v11;
  int v12;
  const void *v13;
  _DWORD *v14;
  _BYTE *v15;
  unsigned int v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  char *v23;
  int v24;
  uint64_t result;
  uint64_t v26;
  uint64_t v28;
  _DWORD *v29;
  unint64_t v30;
  _OWORD v31[2];
  __int128 v32;
  uint64_t v33;

  if (!a1)
    return 4294967257;
  v7 = time(0);
  while (1)
  {
    v8 = *(_QWORD *)a1;
    v9 = *(_QWORD *)(*(_QWORD *)a1 + 104);
    v33 = 0;
    v32 = 0u;
    memset(v31, 0, sizeof(v31));
    v30 = 0;
    v28 = 0;
    if (a4 == -1)
    {
      v10 = 0;
    }
    else
    {
      v10 = 4;
      *(_QWORD *)&v31[0] = 4;
      *(_QWORD *)&v32 = a4 | 0x4000;
    }
    v29 = 0;
    v11 = a3 + 17 + v10;
    v12 = *(_DWORD *)(a1 + 292);
    if (v12)
    {
      if (v12 != 2)
        goto LABEL_15;
      v13 = *(const void **)(a1 + 296);
    }
    else
    {
      *(_DWORD *)(a1 + 64) = 0;
      v14 = (_DWORD *)(*(uint64_t (**)(unint64_t, uint64_t))(v9 + 8))(v11, v9);
      v29 = v14;
      if (!v14)
      {
        v22 = v9;
        v21 = 4294967290;
        v23 = "Unable to allocate memory for FXP_MKDIR packet";
        goto LABEL_26;
      }
      v13 = v14;
      _libssh2_store_u32(&v29, v11 - 4);
      v15 = v29;
      v29 = (_DWORD *)((char *)v29 + 1);
      *v15 = 14;
      v16 = *(_DWORD *)(a1 + 8);
      *(_DWORD *)(a1 + 8) = v16 + 1;
      *(_DWORD *)(a1 + 304) = v16;
      _libssh2_store_u32(&v29, v16);
      _libssh2_store_str(&v29, a2, a3);
      v17 = sftp_attr2bin((char *)v29, (uint64_t *)v31);
      v29 = (_DWORD *)((char *)v29 + v17);
      *(_DWORD *)(a1 + 292) = 2;
    }
    v18 = _libssh2_channel_write(v8, 0, v13, v11);
    if (v18 == -37)
    {
      *(_QWORD *)(a1 + 296) = v13;
      goto LABEL_27;
    }
    v19 = v18;
    (*(void (**)(const void *, uint64_t))(v9 + 24))(v13, v9);
    if (v19 != v11)
    {
      *(_DWORD *)(a1 + 292) = 0;
      v22 = v9;
      v21 = 4294967289;
      v23 = "_libssh2_channel_write() failed";
      goto LABEL_26;
    }
    *(_DWORD *)(a1 + 292) = 3;
    *(_QWORD *)(a1 + 296) = 0;
LABEL_15:
    v20 = sftp_packet_require(a1, 101, *(_DWORD *)(a1 + 304), &v28, &v30, 9uLL);
    if (!(_DWORD)v20)
      break;
    v21 = v20;
    if ((_DWORD)v20 == -37)
      goto LABEL_27;
    if ((_DWORD)v20 == -38)
    {
      if (v30)
        (*(void (**)(uint64_t, uint64_t))(v9 + 24))(v28, v9);
      v22 = v9;
      v21 = 4294967265;
      v23 = "SFTP mkdir packet too short";
    }
    else
    {
      *(_DWORD *)(a1 + 292) = 0;
      v22 = v9;
      v23 = "Error waiting for FXP STATUS";
    }
LABEL_26:
    result = _libssh2_error(v22, v21, v23);
    if ((_DWORD)result != -37)
      return result;
LABEL_27:
    v26 = *(_QWORD *)(*(_QWORD *)a1 + 104);
    if (!*(_DWORD *)(v26 + 172))
      return 4294967259;
    result = _libssh2_wait_socket(v26, v7);
    if ((_DWORD)result)
      return result;
  }
  *(_DWORD *)(a1 + 292) = 0;
  v24 = _libssh2_ntohu32((unsigned int *)(v28 + 5));
  (*(void (**)(uint64_t, uint64_t))(v9 + 24))(v28, v9);
  if (v24)
  {
    *(_DWORD *)(a1 + 64) = v24;
    v22 = v9;
    v21 = 4294967265;
    v23 = "SFTP Protocol Error";
    goto LABEL_26;
  }
  return 0;
}

uint64_t libssh2_sftp_rmdir_ex(uint64_t a1, const void *a2, unsigned int a3)
{
  time_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  _DWORD *v10;
  _BYTE *v11;
  unsigned int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  char *v18;
  int v19;
  uint64_t result;
  uint64_t v21;
  uint64_t v22;
  _DWORD *v23;
  unint64_t v24;

  if (!a1)
    return 4294967257;
  v6 = time(0);
  while (1)
  {
    v7 = *(_QWORD *)a1;
    v8 = *(_QWORD *)(*(_QWORD *)a1 + 104);
    v23 = 0;
    v24 = 0;
    v22 = 0;
    v9 = *(_DWORD *)(a1 + 308);
    if (v9 != 2)
    {
      if (v9)
        goto LABEL_10;
      *(_DWORD *)(a1 + 64) = 0;
      v10 = (_DWORD *)(*(uint64_t (**)(_QWORD, uint64_t))(v8 + 8))(a3 + 13, v8);
      *(_QWORD *)(a1 + 312) = v10;
      v23 = v10;
      if (!v10)
      {
        v17 = v8;
        v16 = 4294967290;
        v18 = "Unable to allocate memory for FXP_RMDIR packet";
        goto LABEL_21;
      }
      _libssh2_store_u32(&v23, a3 + 9);
      v11 = v23;
      v23 = (_DWORD *)((char *)v23 + 1);
      *v11 = 15;
      v12 = *(_DWORD *)(a1 + 8);
      *(_DWORD *)(a1 + 8) = v12 + 1;
      *(_DWORD *)(a1 + 320) = v12;
      _libssh2_store_u32(&v23, v12);
      _libssh2_store_str(&v23, a2, a3);
      *(_DWORD *)(a1 + 308) = 2;
    }
    v13 = _libssh2_channel_write(v7, 0, *(const void **)(a1 + 312), a3 + 13);
    if (v13 == -37)
      goto LABEL_22;
    v14 = v13;
    (*(void (**)(_QWORD, uint64_t))(v8 + 24))(*(_QWORD *)(a1 + 312), v8);
    *(_QWORD *)(a1 + 312) = 0;
    if (v14 != a3 + 13)
    {
      *(_DWORD *)(a1 + 308) = 0;
      v17 = v8;
      v16 = 4294967289;
      v18 = "Unable to send FXP_RMDIR command";
      goto LABEL_21;
    }
    *(_DWORD *)(a1 + 308) = 3;
LABEL_10:
    v15 = sftp_packet_require(a1, 101, *(_DWORD *)(a1 + 320), &v22, &v24, 9uLL);
    if (!(_DWORD)v15)
      break;
    v16 = v15;
    if ((_DWORD)v15 == -37)
      goto LABEL_22;
    if ((_DWORD)v15 == -38)
    {
      if (v24)
        (*(void (**)(uint64_t, uint64_t))(v8 + 24))(v22, v8);
      v17 = v8;
      v16 = 4294967265;
      v18 = "SFTP rmdir packet too short";
    }
    else
    {
      *(_DWORD *)(a1 + 308) = 0;
      v17 = v8;
      v18 = "Error waiting for FXP STATUS";
    }
LABEL_21:
    result = _libssh2_error(v17, v16, v18);
    if ((_DWORD)result != -37)
      return result;
LABEL_22:
    v21 = *(_QWORD *)(*(_QWORD *)a1 + 104);
    if (!*(_DWORD *)(v21 + 172))
      return 4294967259;
    result = _libssh2_wait_socket(v21, v6);
    if ((_DWORD)result)
      return result;
  }
  *(_DWORD *)(a1 + 308) = 0;
  v19 = _libssh2_ntohu32((unsigned int *)(v22 + 5));
  (*(void (**)(uint64_t, uint64_t))(v8 + 24))(v22, v8);
  if (v19)
  {
    *(_DWORD *)(a1 + 64) = v19;
    v17 = v8;
    v16 = 4294967265;
    v18 = "SFTP Protocol Error";
    goto LABEL_21;
  }
  return 0;
}

uint64_t libssh2_sftp_stat_ex(uint64_t a1, const void *a2, unsigned int a3, int a4, uint64_t a5)
{
  time_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  unint64_t v14;
  int v15;
  _DWORD *v16;
  _BYTE *v17;
  uint64_t v18;
  uint64_t v19;
  char *v20;
  char *v21;
  char v22;
  unsigned int v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  int v29;
  uint64_t v30;
  uint64_t result;
  uint64_t v32;
  uint64_t v33;
  _DWORD *v34;
  unint64_t v35;

  if (!a1)
    return 4294967257;
  v10 = time(0);
  while (1)
  {
    v11 = *(_QWORD *)a1;
    v12 = *(_QWORD *)(*(_QWORD *)a1 + 104);
    v35 = 0;
    if (a4 == 2)
      v13 = (*(_DWORD *)a5 & 0xC) + 8 * (*(_DWORD *)a5 & 1) + ((4 * *(_DWORD *)a5) & 8) + 4;
    else
      v13 = 0;
    v14 = a3 + 13 + v13;
    v33 = 0;
    v34 = 0;
    v15 = *(_DWORD *)(a1 + 324);
    if (v15 != 2)
    {
      if (v15)
        goto LABEL_22;
      *(_DWORD *)(a1 + 64) = 0;
      v16 = (_DWORD *)(*(uint64_t (**)(unint64_t, uint64_t))(v12 + 8))(v14, v12);
      *(_QWORD *)(a1 + 328) = v16;
      v34 = v16;
      if (!v16)
      {
        v18 = v12;
        v19 = 4294967290;
        v20 = "Unable to allocate memory for FXP_*STAT packet";
        goto LABEL_35;
      }
      _libssh2_store_u32(&v34, v14 - 4);
      if (a4 == 1)
      {
        v21 = (char *)v34;
        v34 = (_DWORD *)((char *)v34 + 1);
        v22 = 7;
      }
      else
      {
        if (a4 == 2)
        {
          v17 = v34;
          v34 = (_DWORD *)((char *)v34 + 1);
          *v17 = 9;
LABEL_16:
          v23 = *(_DWORD *)(a1 + 8);
          *(_DWORD *)(a1 + 8) = v23 + 1;
          *(_DWORD *)(a1 + 336) = v23;
          _libssh2_store_u32(&v34, v23);
          _libssh2_store_str(&v34, a2, a3);
          if (a4 == 2)
          {
            v24 = sftp_attr2bin((char *)v34, (uint64_t *)a5);
            v34 = (_DWORD *)((char *)v34 + v24);
          }
          *(_DWORD *)(a1 + 324) = 2;
          goto LABEL_19;
        }
        v21 = (char *)v34;
        v34 = (_DWORD *)((char *)v34 + 1);
        v22 = 17;
      }
      *v21 = v22;
      goto LABEL_16;
    }
LABEL_19:
    v25 = _libssh2_channel_write(v11, 0, *(const void **)(a1 + 328), v14);
    if (v25 == -37)
      goto LABEL_36;
    v26 = v25;
    (*(void (**)(_QWORD, uint64_t))(v12 + 24))(*(_QWORD *)(a1 + 328), v12);
    *(_QWORD *)(a1 + 328) = 0;
    if (v26 != v14)
    {
      *(_DWORD *)(a1 + 324) = 0;
      v18 = v12;
      v19 = 4294967289;
      v20 = "Unable to send STAT/LSTAT/SETSTAT command";
      goto LABEL_35;
    }
    *(_DWORD *)(a1 + 324) = 3;
LABEL_22:
    v27 = sftp_packet_requirev((_QWORD *)a1, (uint64_t)&sftp_stat_stat_responses, *(_DWORD *)(a1 + 336), &v33, &v35, 9uLL);
    if (!(_DWORD)v27)
      break;
    v19 = v27;
    if ((_DWORD)v27 == -37)
      goto LABEL_36;
    if ((_DWORD)v27 == -38)
    {
      if (v35)
        (*(void (**)(uint64_t, uint64_t))(v12 + 24))(v33, v12);
      v18 = v12;
      v19 = 4294967265;
      v20 = "SFTP stat packet too short";
    }
    else
    {
      *(_DWORD *)(a1 + 324) = 0;
      v18 = v12;
      v20 = "Timeout waiting for status message";
    }
LABEL_35:
    result = _libssh2_error(v18, v19, v20);
    if ((_DWORD)result != -37)
      return result;
LABEL_36:
    v32 = *(_QWORD *)(*(_QWORD *)a1 + 104);
    if (!*(_DWORD *)(v32 + 172))
      return 4294967259;
    result = _libssh2_wait_socket(v32, v10);
    if ((_DWORD)result)
      return result;
  }
  *(_DWORD *)(a1 + 324) = 0;
  v28 = v33;
  if (*(_BYTE *)v33 != 101)
  {
    *(_QWORD *)(a5 + 48) = 0;
    *(_OWORD *)(a5 + 16) = 0u;
    *(_OWORD *)(a5 + 32) = 0u;
    *(_OWORD *)a5 = 0u;
    v30 = sftp_bin2attr((_QWORD *)a5, v28 + 5, v35 - 5);
    (*(void (**)(uint64_t, uint64_t))(v12 + 24))(v33, v12);
    if ((v30 & 0x8000000000000000) == 0)
      return 0;
    v18 = v12;
    v19 = 4294967265;
    v20 = "Attributes too short in SFTP fstat";
    goto LABEL_35;
  }
  v29 = _libssh2_ntohu32((unsigned int *)(v33 + 5));
  (*(void (**)(uint64_t, uint64_t))(v12 + 24))(v33, v12);
  if (v29)
  {
    *(_DWORD *)(a1 + 64) = v29;
    v18 = v12;
    v19 = 4294967265;
    v20 = "SFTP Protocol Error";
    goto LABEL_35;
  }
  *(_QWORD *)(a5 + 48) = 0;
  *(_OWORD *)(a5 + 16) = 0u;
  *(_OWORD *)(a5 + 32) = 0u;
  *(_OWORD *)a5 = 0u;
  return 0;
}

uint64_t libssh2_sftp_symlink_ex(uint64_t a1, const void *a2, unsigned int a3, void *a4, unsigned int a5, int a6)
{
  time_t v11;
  unsigned int v12;
  unsigned int v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  char *v20;
  _DWORD *v21;
  char *v22;
  char v23;
  unsigned int v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  int v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  unsigned __int8 *v34;
  unint64_t v37;
  unsigned int v38;
  unsigned __int8 *v39;
  _DWORD *v40;
  unint64_t v41;

  if (a1)
  {
    v11 = time(0);
    v12 = a5 + 4;
    if (a6)
      v12 = 0;
    v13 = a3 + v12;
    v14 = v13 + 13;
    v38 = v13 + 9;
    v37 = a3;
    while (1)
    {
      v15 = *(_QWORD *)a1;
      v16 = *(_QWORD *)(*(_QWORD *)a1 + 104);
      v40 = 0;
      v41 = 0;
      v39 = 0;
      v17 = *(_DWORD *)(a1 + 340);
      if (v17 != 2)
      {
        if (v17)
          goto LABEL_23;
        *(_DWORD *)(a1 + 64) = 0;
        if (a6 != 2 && *(_DWORD *)(a1 + 12) <= 2u)
        {
          v18 = v16;
          v19 = 4294967265;
          v20 = "Server does not support SYMLINK or READLINK";
LABEL_34:
          v30 = _libssh2_error(v18, v19, v20);
          goto LABEL_35;
        }
        v21 = (_DWORD *)(*(uint64_t (**)(unint64_t, uint64_t))(v16 + 8))(v14, v16);
        *(_QWORD *)(a1 + 344) = v21;
        v40 = v21;
        if (!v21)
        {
          v18 = v16;
          v19 = 4294967290;
          v20 = "Unable to allocate memory for SYMLINK/READLINK/REALPATH packet";
          goto LABEL_34;
        }
        _libssh2_store_u32(&v40, v38);
        if (a6)
        {
          v22 = (char *)v40;
          v40 = (_DWORD *)((char *)v40 + 1);
          if (a6 == 2)
            v23 = 16;
          else
            v23 = 19;
        }
        else
        {
          v22 = (char *)v40;
          v40 = (_DWORD *)((char *)v40 + 1);
          v23 = 20;
        }
        *v22 = v23;
        v24 = *(_DWORD *)(a1 + 8);
        *(_DWORD *)(a1 + 8) = v24 + 1;
        *(_DWORD *)(a1 + 352) = v24;
        _libssh2_store_u32(&v40, v24);
        _libssh2_store_str(&v40, a2, v37);
        if (!a6)
          _libssh2_store_str(&v40, a4, a5);
        *(_DWORD *)(a1 + 340) = 2;
      }
      v25 = _libssh2_channel_write(v15, 0, *(const void **)(a1 + 344), v14);
      if (v25 == -37)
        goto LABEL_36;
      v26 = v25;
      (*(void (**)(_QWORD, uint64_t))(v16 + 24))(*(_QWORD *)(a1 + 344), v16);
      *(_QWORD *)(a1 + 344) = 0;
      if (v26 != v14)
      {
        *(_DWORD *)(a1 + 340) = 0;
        v18 = v16;
        v19 = 4294967289;
        v20 = "Unable to send SYMLINK/READLINK command";
        goto LABEL_34;
      }
      *(_DWORD *)(a1 + 340) = 3;
LABEL_23:
      v27 = sftp_packet_requirev((_QWORD *)a1, (uint64_t)&sftp_symlink_link_responses, *(_DWORD *)(a1 + 352), &v39, &v41, 9uLL);
      if ((_DWORD)v27)
      {
        v19 = v27;
        if ((_DWORD)v27 == -37)
          goto LABEL_36;
        if ((_DWORD)v27 == -38)
        {
          if (v41)
            (*(void (**)(unsigned __int8 *, uint64_t))(v16 + 24))(v39, v16);
          v18 = v16;
          v19 = 4294967265;
          v20 = "SFTP symlink packet too short";
        }
        else
        {
          *(_DWORD *)(a1 + 340) = 0;
          v18 = v16;
          v20 = "Error waiting for status message";
        }
        goto LABEL_34;
      }
      *(_DWORD *)(a1 + 340) = 0;
      v28 = *v39;
      v29 = _libssh2_ntohu32((unsigned int *)(v39 + 5));
      v30 = v29;
      if (v28 == 101)
      {
        (*(void (**)(unsigned __int8 *, uint64_t))(v16 + 24))(v39, v16);
        if (!(_DWORD)v30)
          return v30;
        *(_DWORD *)(a1 + 64) = v30;
        v18 = v16;
        v19 = 4294967265;
        v20 = "SFTP Protocol Error";
        goto LABEL_34;
      }
      if (!(_DWORD)v29)
      {
        (*(void (**)(unsigned __int8 *, uint64_t))(v16 + 24))(v39, v16);
        v18 = v16;
        v19 = 4294967265;
        v20 = "Invalid READLINK/REALPATH response, no name entries";
        goto LABEL_34;
      }
      if (v41 <= 0xC)
      {
        if (v41)
          (*(void (**)(unsigned __int8 *, uint64_t))(v16 + 24))(v39, v16);
        v18 = v16;
        v19 = 4294967265;
        v20 = "SFTP stat packet too short";
        goto LABEL_34;
      }
      v33 = _libssh2_ntohu32((unsigned int *)(v39 + 9));
      v34 = v39;
      if (v33 >= a5)
      {
        v30 = 4294967258;
      }
      else
      {
        v30 = v33;
        memcpy(a4, v39 + 13, v33);
        *((_BYTE *)a4 + v30) = 0;
      }
      (*(void (**)(unsigned __int8 *, uint64_t))(v16 + 24))(v34, v16);
LABEL_35:
      if ((_DWORD)v30 != -37)
        return v30;
LABEL_36:
      v31 = *(_QWORD *)(*(_QWORD *)a1 + 104);
      if (!*(_DWORD *)(v31 + 172))
        return 4294967259;
      v32 = _libssh2_wait_socket(v31, v11);
      if ((_DWORD)v32)
        return v32;
    }
  }
  return 4294967257;
}

uint64_t libssh2_sftp_last_error(uint64_t result)
{
  if (result)
    return *(unsigned int *)(result + 64);
  return result;
}

uint64_t libssh2_sftp_get_channel(uint64_t result)
{
  if (result)
    return *(_QWORD *)result;
  return result;
}

uint64_t sftp_packet_require(uint64_t a1, int a2, int a3, _QWORD *a4, unint64_t *a5, unint64_t a6)
{
  uint64_t result;
  uint64_t v13;

  result = 4294967257;
  if (a4 && a5)
  {
    v13 = *(_QWORD *)(*(_QWORD *)a1 + 104);
    while (sftp_packet_ask(a1, a2, a3, a4, a5))
    {
      if (*(_DWORD *)(v13 + 596))
        return 4294967283;
      result = sftp_packet_read(a1);
      if ((result & 0x80000000) != 0)
        return result;
    }
    if (*a5 >= a6)
      return 0;
    else
      return 4294967258;
  }
  return result;
}

uint64_t sftp_packet_ask(uint64_t a1, int a2, int a3, _QWORD *a4, _QWORD *a5)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unsigned __int8 *v12;

  v9 = *(_QWORD *)(*(_QWORD *)a1 + 104);
  v10 = _libssh2_list_first(a1 + 16);
  if (!v10)
    return 0xFFFFFFFFLL;
  v11 = v10;
  while (1)
  {
    v12 = *(unsigned __int8 **)(v11 + 32);
    if (*v12 == a2 && (a2 == 2 || *(_DWORD *)(v11 + 24) == a3))
      break;
    v11 = _libssh2_list_next(v11);
    if (!v11)
      return 0xFFFFFFFFLL;
  }
  *a4 = v12;
  *a5 = *(_QWORD *)(v11 + 40);
  _libssh2_list_remove((uint64_t *)v11);
  (*(void (**)(uint64_t, uint64_t))(v9 + 24))(v11, v9);
  return 0;
}

uint64_t sftp_packet_read(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  int v4;
  unsigned __int8 *v5;
  unint64_t v6;
  unint64_t v7;
  int v8;
  int v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  unint64_t v16;
  int v17;
  int v18;
  int v19;
  unsigned int v20;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  int v25;
  uint64_t v26;
  uint64_t *zombie_request;
  uint64_t *v28;
  uint64_t v29;
  char *v30;
  uint64_t v31;
  char *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  int v36;

  v2 = *(_QWORD *)a1;
  v3 = *(_QWORD *)(*(_QWORD *)a1 + 104);
  v4 = *(_DWORD *)(a1 + 160);
  if (v4 == 4)
  {
    *(_DWORD *)(a1 + 160) = 0;
    v5 = *(unsigned __int8 **)(a1 + 88);
    if (v5)
      goto LABEL_11;
  }
  else if (v4 == 3)
  {
    *(_DWORD *)(a1 + 160) = 0;
    v5 = *(unsigned __int8 **)(a1 + 88);
LABEL_4:
    v6 = libssh2_channel_window_read_ex(v2, 0, 0);
    v7 = *(unsigned int *)(a1 + 96);
    if (v6 < v7)
    {
      v8 = _libssh2_channel_receive_window_adjust(v2, 2 * (int)v7, 1, 0);
      v9 = v8 == -37 ? 3 : 0;
      *(_DWORD *)(a1 + 160) = v9;
      if (v8 == -37)
        return 4294967259;
    }
LABEL_11:
    v10 = *(unsigned int *)(a1 + 96);
    v11 = *(_QWORD *)(a1 + 104);
    while (v11 < v10)
    {
      v12 = _libssh2_channel_read(v2, 0, (uint64_t)&v5[v11], v10 - v11);
      if (v12 == -37)
      {
        *(_DWORD *)(a1 + 160) = 4;
        return 4294967259;
      }
      v13 = v12;
      if ((v12 & 0x8000000000000000) != 0)
      {
        (*(void (**)(unsigned __int8 *, uint64_t))(v3 + 24))(v5, v3);
        *(_QWORD *)(a1 + 88) = 0;
        return _libssh2_error(v3, v13, "Error waiting for SFTP packet");
      }
      v11 = *(_QWORD *)(a1 + 104) + v12;
      *(_QWORD *)(a1 + 104) = v11;
      v10 = *(unsigned int *)(a1 + 96);
    }
    *(_QWORD *)(a1 + 88) = 0;
    if (v10 >= 5)
    {
      v23 = *v5;
      v24 = *(_QWORD *)(*(_QWORD *)a1 + 104);
      if ((v23 - 1) < 0x14 || (v23 - 101) < 5 || (v23 - 200) < 2)
      {
        v25 = _libssh2_ntohu32((unsigned int *)(v5 + 1));
        if ((*v5 | 2) == 0x67 && find_zombie_request(a1, v25))
        {
          (*(void (**)(unsigned __int8 *, uint64_t))(v24 + 24))(v5, v24);
          v26 = *(_QWORD *)(*(_QWORD *)a1 + 104);
          zombie_request = (uint64_t *)find_zombie_request(a1, v25);
          if (zombie_request)
          {
            v28 = zombie_request;
            _libssh2_list_remove(zombie_request);
            (*(void (**)(uint64_t *, uint64_t))(v26 + 24))(v28, v26);
          }
          return v23;
        }
        v29 = (*(uint64_t (**)(uint64_t, uint64_t))(v24 + 8))(48, v24);
        if (v29)
        {
          *(_QWORD *)(v29 + 32) = v5;
          *(_QWORD *)(v29 + 40) = v10;
          *(_DWORD *)(v29 + 24) = v25;
          _libssh2_list_add((_QWORD **)(a1 + 16), (_QWORD *)v29);
          return v23;
        }
        v32 = "Unable to allocate datablock for SFTP packet";
        v33 = v24;
        v34 = 4294967290;
      }
      else
      {
        *(_DWORD *)(a1 + 64) = 0;
        v32 = "Out of sync with the world";
        v33 = v24;
        v34 = 4294967265;
      }
      v22 = _libssh2_error(v33, v34, v32);
      if (!(_DWORD)v22)
        return v23;
    }
    else
    {
      v22 = 4294967255;
    }
    (*(void (**)(unsigned __int8 *, uint64_t))(v3 + 24))(v5, v3);
    return v22;
  }
  v14 = _libssh2_channel_read(v2, 0, a1 + 68 + *(_QWORD *)(a1 + 80), 9 - *(_QWORD *)(a1 + 80));
  if (v14 == -37)
    return 4294967259;
  v15 = v14;
  if ((v14 & 0x8000000000000000) == 0)
  {
    v16 = *(_QWORD *)(a1 + 80) + v14;
    *(_QWORD *)(a1 + 80) = v16;
    if (v16 != 9)
      return 4294967259;
    v17 = _libssh2_ntohu32((unsigned int *)(a1 + 68));
    v18 = *(unsigned __int8 *)(a1 + 72);
    *(_DWORD *)(a1 + 96) = v17;
    v19 = _libssh2_ntohu32((unsigned int *)(a1 + 73));
    v20 = *(_DWORD *)(a1 + 96);
    if (v20 <= 0x40000)
    {
      if (v20 <= 4)
      {
        v30 = "Invalid SFTP packet size";
LABEL_50:
        v31 = v3;
        v15 = 4294967290;
        return _libssh2_error(v31, v15, v30);
      }
    }
    else if (!*(_DWORD *)(a1 + 188) || *(_DWORD *)(a1 + 200) != v19 || v18 != 104)
    {
      libssh2_channel_flush_ex(v2, 0);
      *(_QWORD *)(a1 + 80) = 0;
      return _libssh2_error(v3, 4294967271, "SFTP packet too large");
    }
    v35 = (*(uint64_t (**)(void))(v3 + 8))();
    if (v35)
    {
      v5 = (unsigned __int8 *)v35;
      *(_QWORD *)(a1 + 80) = 0;
      *(_QWORD *)(a1 + 88) = v35;
      *(_QWORD *)(a1 + 104) = 5;
      v36 = *(_DWORD *)(a1 + 72);
      *(_BYTE *)(v35 + 4) = *(_BYTE *)(a1 + 76);
      *(_DWORD *)v35 = v36;
      goto LABEL_4;
    }
    v30 = "Unable to allocate SFTP packet";
    goto LABEL_50;
  }
  v30 = "channel read";
  v31 = v3;
  return _libssh2_error(v31, v15, v30);
}

uint64_t find_zombie_request(uint64_t a1, int a2)
{
  uint64_t result;

  for (result = _libssh2_list_first(a1 + 32); result; result = _libssh2_list_next(result))
  {
    if (*(_DWORD *)(result + 24) == a2)
      break;
  }
  return result;
}

uint64_t sftp_attr2bin(char *a1, uint64_t *a2)
{
  uint64_t v4;
  char *v6;

  v6 = a1;
  if (a2)
  {
    _libssh2_store_u32((_DWORD **)&v6, *(_DWORD *)a2 & 0xF);
    v4 = *a2;
    if ((*a2 & 1) != 0)
    {
      *(_QWORD *)v6 = bswap64(a2[1]);
      v6 += 8;
      v4 = *a2;
      if ((*a2 & 2) == 0)
      {
LABEL_4:
        if ((v4 & 4) == 0)
          goto LABEL_5;
        goto LABEL_12;
      }
    }
    else if ((v4 & 2) == 0)
    {
      goto LABEL_4;
    }
    _libssh2_store_u32((_DWORD **)&v6, *((_DWORD *)a2 + 4));
    _libssh2_store_u32((_DWORD **)&v6, *((_DWORD *)a2 + 6));
    v4 = *a2;
    if ((*a2 & 4) == 0)
    {
LABEL_5:
      if ((v4 & 8) == 0)
        return v6 - a1;
LABEL_6:
      _libssh2_store_u32((_DWORD **)&v6, *((_DWORD *)a2 + 10));
      _libssh2_store_u32((_DWORD **)&v6, *((_DWORD *)a2 + 12));
      return v6 - a1;
    }
LABEL_12:
    _libssh2_store_u32((_DWORD **)&v6, *((_DWORD *)a2 + 8));
    if ((*a2 & 8) == 0)
      return v6 - a1;
    goto LABEL_6;
  }
  _libssh2_htonu32(a1, 0);
  return 4;
}

uint64_t sftp_packet_requirev(_QWORD *a1, uint64_t a2, int a3, _QWORD *a4, unint64_t *a5, unint64_t a6)
{
  uint64_t v6;
  uint64_t v14;
  char v15;
  uint64_t v16;
  uint64_t v17;

  v6 = 4294967257;
  if (a4 && a5)
  {
    if (!a1[14])
      a1[14] = time(0);
    if (*(_DWORD *)(*(_QWORD *)(*a1 + 104) + 596))
    {
LABEL_6:
      a1[14] = 0;
      return 4294967283;
    }
    else
    {
      v14 = 0;
      v15 = 1;
      while (sftp_packet_ask((uint64_t)a1, *(unsigned __int8 *)(a2 + v14), a3, a4, a5))
      {
        if ((v15 & 1) != 0)
        {
          v14 = 1;
        }
        else
        {
          v16 = sftp_packet_read((uint64_t)a1);
          v6 = v16;
          if ((v16 & 0x80000000) != 0 && (_DWORD)v16 != -37)
          {
            a1[14] = 0;
            return v6;
          }
          if ((int)v16 <= 0)
          {
            v17 = *(_QWORD *)(*(_QWORD *)(*a1 + 104) + 73576);
            if (v17 - time(0) + a1[14] <= 0)
            {
              a1[14] = 0;
              return 4294967287;
            }
            if ((_DWORD)v6 == -37)
              return v6;
          }
          if (*(_DWORD *)(*(_QWORD *)(*a1 + 104) + 596))
            goto LABEL_6;
          v14 = 0;
        }
        v15 ^= 1u;
      }
      a1[14] = 0;
      if (*a5 >= a6)
        return 0;
      else
        return 4294967258;
    }
  }
  return v6;
}

uint64_t sftp_bin2attr(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unsigned int v13;
  unsigned int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  v14 = 0;
  v15 = a2;
  v16 = a2;
  v17 = a3;
  if (_libssh2_get_u32(&v15, &v14))
    return -38;
  LODWORD(v5) = v14;
  *a1 = v14;
  if ((v5 & 1) != 0)
  {
    if (_libssh2_get_u64((uint64_t)&v15, a1 + 1))
      return -38;
    v5 = *a1;
  }
  if ((v5 & 2) != 0)
  {
    LODWORD(v12) = 0;
    LODWORD(v11) = 0;
    if (_libssh2_get_u32(&v15, &v12) || _libssh2_get_u32(&v15, &v11))
      return -38;
    v6 = v11;
    a1[2] = v12;
    a1[3] = v6;
    v5 = *a1;
    if ((*a1 & 4) != 0)
      goto LABEL_9;
  }
  else if ((v5 & 4) != 0)
  {
LABEL_9:
    LODWORD(v12) = 0;
    if (_libssh2_get_u32(&v15, &v12))
      return -38;
    a1[4] = v12;
    v5 = *a1;
  }
  if ((v5 & 8) != 0)
  {
    LODWORD(v12) = 0;
    LODWORD(v11) = 0;
    if (_libssh2_get_u32(&v15, &v12) || _libssh2_get_u32(&v15, &v11))
      return -38;
    v7 = v11;
    a1[5] = v12;
    a1[6] = v7;
    if ((*a1 & 0x80000000) == 0)
      return v16 - v15;
  }
  else if ((v5 & 0x80000000) == 0)
  {
    return v16 - v15;
  }
  v13 = 0;
  v11 = 0;
  v12 = 0;
  v9 = 0;
  v10 = 0;
  if (!_libssh2_get_u32(&v15, &v13))
  {
    if (v13)
    {
      v8 = 0;
      while (!_libssh2_get_string(&v15, &v11, &v12)
           && !_libssh2_get_string(&v15, &v9, &v10))
      {
        if (++v8 >= v13)
          return v16 - v15;
      }
      return -38;
    }
    return v16 - v15;
  }
  return -38;
}

void libssh2_sftp_init_cold_1()
{
  __assert_rtn("sftp_init", "sftp.c", 821, "!session->sftpInit_sftp");
}

void libssh2_sftp_read_cold_1()
{
  __assert_rtn("sftp_read", "sftp.c", 1780, "0");
}

void libssh2_sftp_read_cold_2()
{
  __assert_rtn("sftp_read", "sftp.c", 1519, "rc != LIBSSH2_ERROR_EAGAIN || !filep->eof");
}

void libssh2_sftp_read_cold_3()
{
  __assert_rtn("sftp_read", "sftp.c", 1518, "rc != LIBSSH2_ERROR_EAGAIN || !filep->data_left");
}

void libssh2_sftp_close_handle_cold_1()
{
  __assert_rtn("sftp_close_handle", "sftp.c", 2717, "rc");
}

char ***libssh2_hostkey_methods()
{
  return hostkey_methods;
}

_DWORD *libssh2_hostkey_hash(_DWORD *a1, int a2)
{
  int v2;
  _DWORD *v3;

  switch(a2)
  {
    case 3:
      v2 = a1[72];
      v3 = a1 + 64;
      break;
    case 2:
      v2 = a1[63];
      v3 = a1 + 58;
      break;
    case 1:
      v2 = a1[57];
      v3 = a1 + 53;
      break;
    default:
      return 0;
  }
  if (v2)
    return v3;
  else
    return 0;
}

_QWORD *libssh2_session_hostkey(uint64_t a1, _QWORD *a2, int *a3)
{
  uint64_t v3;
  _QWORD *result;
  int v5;

  v3 = *(unsigned int *)(a1 + 208);
  if ((_DWORD)v3)
  {
    if (a2)
      *a2 = v3;
    result = *(_QWORD **)(a1 + 200);
    if (a3)
    {
      if (v3 >= 0xB)
      {
        if (*result == 0x2D68737307000000 && *(_QWORD *)((char *)result + 3) == 0x6173722D68737307)
        {
          v5 = 1;
          goto LABEL_46;
        }
        if (*result == 0x2D68737307000000 && *(_QWORD *)((char *)result + 3) == 0x7373642D68737307)
        {
          v5 = 2;
          goto LABEL_46;
        }
        if (v3 >= 0xF)
        {
          if (*result == 0x2D6873730B000000 && *(_QWORD *)((char *)result + 7) == 0x393135353264652DLL)
          {
            v5 = 6;
            goto LABEL_46;
          }
          if (v3 >= 0x17)
          {
            if (*result == 0x7364636513000000
              && result[1] == 0x6E2D326168732D61
              && *(_QWORD *)((char *)result + 15) == 0x363532707473696ELL)
            {
              v5 = 3;
            }
            else if (*result == 0x7364636513000000
                   && result[1] == 0x6E2D326168732D61
                   && *(_QWORD *)((char *)result + 15) == 0x343833707473696ELL)
            {
              v5 = 4;
            }
            else if (*result ^ 0x7364636513000000 | result[1] ^ 0x6E2D326168732D61 | *(_QWORD *)((char *)result + 15) ^ 0x313235707473696ELL)
            {
              v5 = 0;
            }
            else
            {
              v5 = 5;
            }
            goto LABEL_46;
          }
        }
      }
      v5 = 0;
LABEL_46:
      *a3 = v5;
    }
  }
  else
  {
    result = 0;
    if (a2)
      *a2 = 0;
  }
  return result;
}

uint64_t hostkey_method_ssh_ecdsa_init(uint64_t a1, uint64_t a2, unint64_t a3, EC_KEY **a4)
{
  uint64_t result;
  int string;
  char *v9;
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  int v15;
  _QWORD v16[3];
  uint64_t v17;
  size_t v18;
  const unsigned __int8 *v19;
  char *v20;
  char *__s1;
  EC_KEY *v22;

  v22 = 0;
  if (a4 && *a4)
  {
    EC_KEY_free(*a4);
    *a4 = 0;
  }
  if (a3 < 0x27)
    return 0xFFFFFFFFLL;
  v20 = 0;
  __s1 = 0;
  v18 = 0;
  v19 = 0;
  v16[2] = a3;
  v17 = 0;
  v16[0] = a2;
  v16[1] = a2;
  string = _libssh2_get_string(v16, &__s1, &v17);
  result = 0xFFFFFFFFLL;
  if (!string && v17 == 19)
  {
    v9 = __s1;
    v10 = strncmp(__s1, "ecdsa-sha2-nistp256", 0x13uLL);
    if (v10)
    {
      if (!strncmp(v9, "ecdsa-sha2-nistp384", 0x13uLL))
      {
        v13 = 0;
        v12 = 715;
        v11 = 1;
      }
      else
      {
        if (strncmp(v9, "ecdsa-sha2-nistp521", 0x13uLL))
          return 0xFFFFFFFFLL;
        v11 = 0;
        v12 = 716;
        v13 = 1;
      }
    }
    else
    {
      v11 = 0;
      v13 = 0;
      v12 = 415;
    }
    v14 = _libssh2_get_string(v16, &v20, &v17);
    result = 0xFFFFFFFFLL;
    if (v14 || v17 != 8)
      return result;
    if ((v10 || !strncmp(v20, "nistp256", 8uLL))
      && (!v11 || !strncmp(v20, "nistp384", 8uLL))
      && (!v13 || !strncmp(v20, "nistp521", 8uLL))
      && !_libssh2_get_string(v16, &v19, &v18)
      && _libssh2_eob(v16))
    {
      v15 = _libssh2_ecdsa_curve_name_with_octal_new(&v22, v19, v18, v12);
      if (v15)
        result = 0xFFFFFFFFLL;
      else
        result = 0;
      if (a4)
      {
        if (!v15)
        {
          result = 0;
          *a4 = v22;
        }
      }
      return result;
    }
    return 0xFFFFFFFFLL;
  }
  return result;
}

uint64_t hostkey_method_ssh_ecdsa_initPEM(uint64_t a1, const char *a2, void *a3, EC_KEY **a4)
{
  uint64_t result;
  EC_KEY *v9;

  v9 = 0;
  if (!a4)
    return _libssh2_ecdsa_new_private(&v9, a1, a2, a3);
  if (*a4)
  {
    EC_KEY_free(*a4);
    *a4 = 0;
  }
  result = _libssh2_ecdsa_new_private(&v9, a1, a2, a3);
  *a4 = v9;
  return result;
}

uint64_t hostkey_method_ssh_ecdsa_initPEMFromMemory(uint64_t a1, void *a2, unint64_t a3, char *a4, EC_KEY **a5)
{
  int v10;
  uint64_t result;
  EVP_PKEY *v12;

  v12 = 0;
  if (a5 && *a5)
  {
    EC_KEY_free(*a5);
    *a5 = 0;
  }
  v10 = _libssh2_ecdsa_new_private_frommemory(&v12, a1, a2, a3, a4);
  if (v10)
    result = 0xFFFFFFFFLL;
  else
    result = 0;
  if (a5)
  {
    if (!v10)
    {
      result = 0;
      *a5 = (EC_KEY *)v12;
    }
  }
  return result;
}

uint64_t hostkey_method_ssh_ecdsa_sig_verify(uint64_t a1, uint64_t a2, unint64_t a3, const void *a4, size_t a5, const EC_KEY **a6)
{
  const unsigned __int8 *v6;
  const unsigned __int8 *v7;
  uint64_t result;
  const EC_KEY *v11;
  int string;
  int u32;
  _QWORD v14[3];
  unsigned int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  const unsigned __int8 *v20;
  const unsigned __int8 *v21[7];

  if (a3 < 0x23)
    return 0xFFFFFFFFLL;
  v21[5] = v6;
  v21[6] = v7;
  v11 = *a6;
  v20 = 0;
  v21[0] = 0;
  v18 = 0;
  v19 = 0;
  v16 = 0;
  v17 = 0;
  v15 = 0;
  v14[0] = a2;
  v14[1] = a2;
  v14[2] = a3;
  string = _libssh2_get_string(v14, &v19, &v16);
  result = 0xFFFFFFFFLL;
  if (!string && v16 == 19)
  {
    u32 = _libssh2_get_u32(v14, &v15);
    result = 0xFFFFFFFFLL;
    if (!u32 && v15 >= 8)
    {
      if (_libssh2_get_string(v14, v21, &v18) || _libssh2_get_string(v14, &v20, &v17))
        return 0xFFFFFFFFLL;
      else
        return _libssh2_ecdsa_verify(v11, v21[0], v18, v20, v17, a4, a5);
    }
  }
  return result;
}

uint64_t hostkey_method_ssh_ecdsa_signv(uint64_t a1, _QWORD *a2, char **a3, int a4, uint64_t a5, const EC_KEY **a6)
{
  uint64_t v7;
  const EC_KEY *v11;
  int curve_type;
  size_t *v13;
  uint64_t v14;
  EC_KEY *v15;
  int v16;
  size_t *v17;
  size_t *v18;
  EVP_MD_CTX *ctx;
  unsigned __int8 md[64];
  uint64_t v22;

  LODWORD(v7) = a4;
  v22 = *MEMORY[0x24BDAC8D0];
  v11 = *a6;
  curve_type = _libssh2_ecdsa_get_curve_type(*a6);
  switch(curve_type)
  {
    case 716:
      ctx = 0;
      _libssh2_sha512_init(&ctx);
      if ((int)v7 >= 1)
      {
        v7 = v7;
        v17 = (size_t *)(a5 + 8);
        do
        {
          EVP_DigestUpdate(ctx, (const void *)*(v17 - 1), *v17);
          v17 += 2;
          --v7;
        }
        while (v7);
      }
      EVP_DigestFinal(ctx, md, 0);
      EVP_MD_CTX_free(ctx);
      v14 = a1;
      v15 = v11;
      v16 = 64;
      return _libssh2_ecdsa_sign(v14, v15, md, v16, a2, a3);
    case 715:
      ctx = 0;
      _libssh2_sha384_init(&ctx);
      if ((int)v7 >= 1)
      {
        v7 = v7;
        v18 = (size_t *)(a5 + 8);
        do
        {
          EVP_DigestUpdate(ctx, (const void *)*(v18 - 1), *v18);
          v18 += 2;
          --v7;
        }
        while (v7);
      }
      EVP_DigestFinal(ctx, md, 0);
      EVP_MD_CTX_free(ctx);
      v14 = a1;
      v15 = v11;
      v16 = 48;
      return _libssh2_ecdsa_sign(v14, v15, md, v16, a2, a3);
    case 415:
      ctx = 0;
      _libssh2_sha256_init(&ctx);
      if ((int)v7 >= 1)
      {
        v7 = v7;
        v13 = (size_t *)(a5 + 8);
        do
        {
          EVP_DigestUpdate(ctx, (const void *)*(v13 - 1), *v13);
          v13 += 2;
          --v7;
        }
        while (v7);
      }
      EVP_DigestFinal(ctx, md, 0);
      EVP_MD_CTX_free(ctx);
      v14 = a1;
      v15 = v11;
      v16 = 32;
      return _libssh2_ecdsa_sign(v14, v15, md, v16, a2, a3);
  }
  return 0xFFFFFFFFLL;
}

uint64_t hostkey_method_ssh_ecdsa_dtor(uint64_t a1, EC_KEY **a2)
{
  if (*a2)
    EC_KEY_free(*a2);
  *a2 = 0;
  return 0;
}

uint64_t hostkey_method_ssh_ed25519_init(uint64_t a1, uint64_t a2, unint64_t a3, EVP_PKEY **a4)
{
  uint64_t result;
  _QWORD v9[3];
  EVP_PKEY *v10;
  uint64_t v11;
  uint64_t v12;

  v10 = 0;
  if (*a4)
  {
    EVP_PKEY_free(*a4);
    *a4 = 0;
  }
  if (a3 < 0x13)
    return 0xFFFFFFFFLL;
  v11 = 0;
  v12 = 0;
  v9[0] = a2;
  v9[1] = a2;
  v9[2] = a3;
  if (_libssh2_match_string(v9, "ssh-ed25519"))
    return 0xFFFFFFFFLL;
  if (_libssh2_get_string(v9, &v11, &v12))
    return 0xFFFFFFFFLL;
  if (!_libssh2_eob(v9))
    return 0xFFFFFFFFLL;
  result = _libssh2_ed25519_new_public(&v10, a1, v11, v12);
  if ((_DWORD)result)
    return 0xFFFFFFFFLL;
  *a4 = v10;
  return result;
}

uint64_t hostkey_method_ssh_ed25519_initPEM(uint64_t a1, const char *a2, const char *a3, EVP_PKEY **a4)
{
  uint64_t result;
  EVP_PKEY *v9;

  v9 = 0;
  if (*a4)
  {
    EVP_PKEY_free(*a4);
    *a4 = 0;
  }
  result = _libssh2_ed25519_new_private(&v9, a1, a2, a3);
  if ((_DWORD)result)
    return 0xFFFFFFFFLL;
  *a4 = v9;
  return result;
}

uint64_t hostkey_method_ssh_ed25519_initPEMFromMemory(uint64_t a1, void *a2, unint64_t a3, char *a4, EVP_PKEY **a5)
{
  int v10;
  uint64_t result;
  EVP_PKEY *v12;

  v12 = 0;
  if (a5 && *a5)
  {
    EVP_PKEY_free(*a5);
    *a5 = 0;
  }
  v10 = _libssh2_ed25519_new_private_frommemory(&v12, a1, a2, a3, a4);
  if (v10)
    result = 0xFFFFFFFFLL;
  else
    result = 0;
  if (a5)
  {
    if (!v10)
    {
      result = 0;
      *a5 = v12;
    }
  }
  return result;
}

uint64_t hostkey_method_ssh_ed25519_sig_verify(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, size_t a5, uint64_t *a6)
{
  if (a3 == 83)
    return _libssh2_ed25519_verify(*a6, a2 + 19, 64, a4, a5);
  else
    return 0xFFFFFFFFLL;
}

uint64_t hostkey_method_ssh_ed25519_signv(uint64_t a1, _QWORD *a2, _QWORD *a3, int a4, uint64_t a5, uint64_t *a6)
{
  if (a4 == 1)
    return _libssh2_ed25519_sign(*a6, a1, a2, a3, *(void **)a5, *(_QWORD *)(a5 + 8));
  else
    return 0xFFFFFFFFLL;
}

uint64_t hostkey_method_ssh_ed25519_dtor(uint64_t a1, EVP_PKEY **a2)
{
  if (*a2)
    EVP_PKEY_free(*a2);
  *a2 = 0;
  return 0;
}

uint64_t hostkey_method_ssh_rsa_init(uint64_t a1, uint64_t a2, unint64_t a3, RSA **a4)
{
  uint64_t result;
  const char *v8;
  const char *v9;
  size_t v10;
  const char *v11;
  _QWORD v12[3];
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  const char *v16;
  const unsigned __int8 *v17;
  const unsigned __int8 *v18;
  RSA *v19;

  if (*a4)
  {
    RSA_free(*a4);
    *a4 = 0;
  }
  if (a3 < 0x13)
    return 0xFFFFFFFFLL;
  v18 = 0;
  v19 = 0;
  v16 = 0;
  v17 = 0;
  v14 = 0;
  v15 = 0;
  v13 = 0;
  v12[0] = a2;
  v12[1] = a2;
  v12[2] = a3;
  if (_libssh2_get_string(v12, &v16, &v13))
    return 0xFFFFFFFFLL;
  if (v13 != 12)
  {
    if (v13 != 7)
      return 0xFFFFFFFFLL;
    v8 = v16;
    v9 = "ssh-rsa";
    v10 = 7;
    goto LABEL_12;
  }
  v11 = v16;
  if (strncmp("rsa-sha2-256", v16, 0xCuLL))
  {
    v9 = "rsa-sha2-512";
    v8 = v11;
    v10 = 12;
LABEL_12:
    if (strncmp(v9, v8, v10))
      return 0xFFFFFFFFLL;
  }
  if (!_libssh2_get_string(v12, &v18, &v15)
    && !_libssh2_get_string(v12, &v17, &v14)
    && _libssh2_eob(v12))
  {
    result = _libssh2_rsa_new((uint64_t *)&v19, v18, v15, v17, v14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    if (!(_DWORD)result)
    {
      *a4 = v19;
      return result;
    }
  }
  return 0xFFFFFFFFLL;
}

uint64_t hostkey_method_ssh_rsa_initPEM(uint64_t a1, const char *a2, void *a3, RSA **a4)
{
  uint64_t result;
  RSA *v9;

  if (*a4)
  {
    RSA_free(*a4);
    *a4 = 0;
  }
  v9 = 0;
  result = _libssh2_rsa_new_private(&v9, a1, a2, a3);
  if ((_DWORD)result)
    return 0xFFFFFFFFLL;
  *a4 = v9;
  return result;
}

uint64_t hostkey_method_ssh_rsa_initPEMFromMemory(uint64_t a1, void *a2, unint64_t a3, char *a4, RSA **a5)
{
  uint64_t result;
  RSA *v11;

  if (*a5)
  {
    RSA_free(*a5);
    *a5 = 0;
  }
  v11 = 0;
  result = _libssh2_rsa_new_private_frommemory((EVP_PKEY **)&v11, a1, a2, a3, a4);
  if ((_DWORD)result)
    return 0xFFFFFFFFLL;
  *a5 = v11;
  return result;
}

uint64_t hostkey_method_ssh_rsa_sha2_512_sig_verify(uint64_t a1, uint64_t a2, unint64_t a3, const void *a4, size_t a5, RSA **a6)
{
  if (a3 >= 0x14)
    return _libssh2_rsa_sha2_verify(*a6, 0x40uLL, (unsigned __int8 *)(a2 + 20), (int)a3 - 20, a4, a5);
  else
    return 0xFFFFFFFFLL;
}

uint64_t hostkey_method_ssh_rsa_sha2_512_signv(uint64_t a1, unsigned __int8 **a2, _QWORD *a3, int a4, uint64_t a5, RSA **a6)
{
  uint64_t v7;
  RSA *v11;
  size_t *v12;
  EVP_MD_CTX *ctx;
  unsigned __int8 md[64];
  uint64_t v16;

  LODWORD(v7) = a4;
  v16 = *MEMORY[0x24BDAC8D0];
  v11 = *a6;
  ctx = 0;
  if (!_libssh2_sha512_init(&ctx))
    return 0xFFFFFFFFLL;
  if ((int)v7 >= 1)
  {
    v7 = v7;
    v12 = (size_t *)(a5 + 8);
    do
    {
      EVP_DigestUpdate(ctx, (const void *)*(v12 - 1), *v12);
      v12 += 2;
      --v7;
    }
    while (v7);
  }
  EVP_DigestFinal(ctx, md, 0);
  EVP_MD_CTX_free(ctx);
  if (_libssh2_rsa_sha2_sign(a1, v11, md, 64, a2, a3))
    return 0xFFFFFFFFLL;
  else
    return 0;
}

uint64_t hostkey_method_ssh_rsa_dtor(uint64_t a1, RSA **a2)
{
  RSA_free(*a2);
  *a2 = 0;
  return 0;
}

uint64_t hostkey_method_ssh_rsa_sha2_256_sig_verify(uint64_t a1, uint64_t a2, unint64_t a3, const void *a4, size_t a5, RSA **a6)
{
  if (a3 >= 0x14)
    return _libssh2_rsa_sha2_verify(*a6, 0x20uLL, (unsigned __int8 *)(a2 + 20), (int)a3 - 20, a4, a5);
  else
    return 0xFFFFFFFFLL;
}

uint64_t hostkey_method_ssh_rsa_sha2_256_signv(uint64_t a1, unsigned __int8 **a2, _QWORD *a3, int a4, uint64_t a5, RSA **a6)
{
  uint64_t v7;
  RSA *v11;
  size_t *v12;
  EVP_MD_CTX *ctx;
  unsigned __int8 md[32];
  uint64_t v16;

  LODWORD(v7) = a4;
  v16 = *MEMORY[0x24BDAC8D0];
  v11 = *a6;
  ctx = 0;
  if (!_libssh2_sha256_init(&ctx))
    return 0xFFFFFFFFLL;
  if ((int)v7 >= 1)
  {
    v7 = v7;
    v12 = (size_t *)(a5 + 8);
    do
    {
      EVP_DigestUpdate(ctx, (const void *)*(v12 - 1), *v12);
      v12 += 2;
      --v7;
    }
    while (v7);
  }
  EVP_DigestFinal(ctx, md, 0);
  EVP_MD_CTX_free(ctx);
  if (_libssh2_rsa_sha2_sign(a1, v11, md, 32, a2, a3))
    return 0xFFFFFFFFLL;
  else
    return 0;
}

uint64_t hostkey_method_ssh_rsa_sig_verify(uint64_t a1, uint64_t a2, unint64_t a3, const void *a4, size_t a5, RSA **a6)
{
  BOOL v6;
  unsigned int v7;

  v6 = a3 >= 0xF;
  v7 = a3 - 15;
  if (v6)
    return _libssh2_rsa_sha1_verify(*a6, (unsigned __int8 *)(a2 + 15), v7, a4, a5);
  else
    return 0xFFFFFFFFLL;
}

uint64_t hostkey_method_ssh_rsa_signv(uint64_t a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5, uint64_t *a6)
{
  uint64_t v7;
  uint64_t v11;
  size_t *v12;
  EVP_MD_CTX *ctx;
  unsigned __int8 md[20];
  uint64_t v16;

  LODWORD(v7) = a4;
  v16 = *MEMORY[0x24BDAC8D0];
  v11 = *a6;
  ctx = 0;
  _libssh2_sha1_init(&ctx);
  if ((int)v7 >= 1)
  {
    v7 = v7;
    v12 = (size_t *)(a5 + 8);
    do
    {
      EVP_DigestUpdate(ctx, (const void *)*(v12 - 1), *v12);
      v12 += 2;
      --v7;
    }
    while (v7);
  }
  EVP_DigestFinal(ctx, md, 0);
  EVP_MD_CTX_free(ctx);
  if (_libssh2_rsa_sha1_sign(a1, v11, md, 20, a2, a3))
    return 0xFFFFFFFFLL;
  else
    return 0;
}

uint64_t hostkey_method_ssh_dss_init(uint64_t a1, uint64_t a2, unint64_t a3, DSA **a4)
{
  uint64_t result;
  _QWORD v8[3];
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  const unsigned __int8 *v13;
  const unsigned __int8 *v14;
  const unsigned __int8 *v15;
  const unsigned __int8 *v16;
  DSA *v17;

  if (*a4)
  {
    DSA_free(*a4);
    *a4 = 0;
  }
  if (a3 < 0x1B)
    return 0xFFFFFFFFLL;
  v16 = 0;
  v17 = 0;
  v14 = 0;
  v15 = 0;
  v13 = 0;
  v11 = 0;
  v12 = 0;
  v9 = 0;
  v10 = 0;
  v8[0] = a2;
  v8[1] = a2;
  v8[2] = a3;
  if (_libssh2_match_string(v8, "ssh-dss"))
    return 0xFFFFFFFFLL;
  if (_libssh2_get_string(v8, &v16, &v12))
    return 0xFFFFFFFFLL;
  if (_libssh2_get_string(v8, &v15, &v11))
    return 0xFFFFFFFFLL;
  if (_libssh2_get_string(v8, &v14, &v10))
    return 0xFFFFFFFFLL;
  if (_libssh2_get_string(v8, &v13, &v9))
    return 0xFFFFFFFFLL;
  if (!_libssh2_eob(v8))
    return 0xFFFFFFFFLL;
  result = _libssh2_dsa_new((uint64_t *)&v17, v16, v12, v15, v11, v14, v10, v13, v9, 0, 0);
  if ((_DWORD)result)
    return 0xFFFFFFFFLL;
  *a4 = v17;
  return result;
}

uint64_t hostkey_method_ssh_dss_initPEM(uint64_t a1, const char *a2, void *a3, DSA **a4)
{
  uint64_t result;
  DSA *v9;

  if (*a4)
  {
    DSA_free(*a4);
    *a4 = 0;
  }
  v9 = 0;
  result = _libssh2_dsa_new_private(&v9, a1, a2, a3);
  if ((_DWORD)result)
    return 0xFFFFFFFFLL;
  *a4 = v9;
  return result;
}

uint64_t hostkey_method_ssh_dss_initPEMFromMemory(uint64_t a1, void *a2, unint64_t a3, char *a4, DSA **a5)
{
  uint64_t result;
  DSA *v11;

  if (*a5)
  {
    DSA_free(*a5);
    *a5 = 0;
  }
  v11 = 0;
  result = _libssh2_dsa_new_private_frommemory((EVP_PKEY **)&v11, a1, a2, a3, a4);
  if ((_DWORD)result)
    return 0xFFFFFFFFLL;
  *a5 = v11;
  return result;
}

uint64_t hostkey_method_ssh_dss_sig_verify(uint64_t a1, uint64_t a2, uint64_t a3, const void *a4, size_t a5, DSA **a6)
{
  if (a3 == 55)
    return _libssh2_dsa_sha1_verify(*a6, (const unsigned __int8 *)(a2 + 15), a4, a5);
  else
    return _libssh2_error(a1, 4294967282, "Invalid DSS signature length");
}

uint64_t hostkey_method_ssh_dss_signv(uint64_t a1, uint64_t *a2, _QWORD *a3, int a4, uint64_t a5, DSA **a6)
{
  uint64_t v7;
  DSA *v11;
  void *v12;
  size_t *v13;
  uint64_t result;
  EVP_MD_CTX *ctx;
  unsigned __int8 md[20];
  uint64_t v17;

  LODWORD(v7) = a4;
  v17 = *MEMORY[0x24BDAC8D0];
  v11 = *a6;
  v12 = _libssh2_calloc(a1, 0x28uLL);
  *a2 = (uint64_t)v12;
  if (!v12)
    return 0xFFFFFFFFLL;
  ctx = 0;
  *a3 = 40;
  _libssh2_sha1_init(&ctx);
  if ((int)v7 >= 1)
  {
    v7 = v7;
    v13 = (size_t *)(a5 + 8);
    do
    {
      EVP_DigestUpdate(ctx, (const void *)*(v13 - 1), *v13);
      v13 += 2;
      --v7;
    }
    while (v7);
  }
  EVP_DigestFinal(ctx, md, 0);
  EVP_MD_CTX_free(ctx);
  result = _libssh2_dsa_sha1_sign(v11, md, 20, *a2);
  if ((_DWORD)result)
  {
    (*(void (**)(uint64_t, uint64_t))(a1 + 24))(*a2, a1);
    return 0xFFFFFFFFLL;
  }
  return result;
}

uint64_t hostkey_method_ssh_dss_dtor(uint64_t a1, DSA **a2)
{
  DSA_free(*a2);
  *a2 = 0;
  return 0;
}

uint64_t _libssh2_bcrypt_pbkdf(const void *a1, size_t a2, const void *a3, unint64_t a4, uint64_t a5, unint64_t a6, unsigned int a7)
{
  size_t v7;
  uint64_t result;
  _BYTE *v13;
  unint64_t v14;
  unsigned int v15;
  int v16;
  unint64_t v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t i;
  unint64_t v21;
  unint64_t v22;
  size_t v24;
  size_t v25;
  size_t v26;
  size_t v27;
  size_t cnt;
  _BYTE *v29;
  unsigned int v31;
  EVP_MD_CTX *ctx;
  _OWORD d[2];
  _OWORD __s[2];
  unsigned __int8 v35[64];
  unsigned __int8 md[64];
  uint64_t v37;

  v37 = *MEMORY[0x24BDAC8D0];
  if (!a7)
    return 0xFFFFFFFFLL;
  v7 = a4;
  result = 0xFFFFFFFFLL;
  if (a4 > 0x100000 || !a2 || !a4 || a6 - 1025 < 0xFFFFFFFFFFFFFC00)
    return result;
  cnt = a4 + 4;
  v13 = malloc_type_calloc(1uLL, a4 + 4, 0xC06265B5uLL);
  if (!v13)
    return 0xFFFFFFFFLL;
  ctx = 0;
  v14 = (a6 + 31) >> 5;
  v29 = v13;
  memcpy(v13, a3, v7);
  _libssh2_sha512_init(&ctx);
  EVP_DigestUpdate(ctx, a1, a2);
  EVP_DigestFinal(ctx, md, 0);
  EVP_MD_CTX_free(ctx);
  v15 = 0;
  v26 = v7 + 1;
  v27 = v7;
  v25 = v7 + 2;
  v24 = v7 + 3;
  v16 = 1;
  v17 = a6;
  v18 = (unsigned __int16)(v14 + a6 - 1) / (unsigned __int16)v14;
  do
  {
    v31 = v15;
    v29[v7] = HIBYTE(v16);
    v29[v26] = BYTE2(v16);
    v29[v25] = BYTE1(v16);
    v29[v24] = v16;
    _libssh2_sha512_init(&ctx);
    EVP_DigestUpdate(ctx, v29, cnt);
    EVP_DigestFinal(ctx, v35, 0);
    EVP_MD_CTX_free(ctx);
    bcrypt_hash((uint64_t)md);
    __s[0] = d[0];
    __s[1] = d[1];
    if (a7 >= 2)
    {
      v19 = 1;
      do
      {
        _libssh2_sha512_init(&ctx);
        EVP_DigestUpdate(ctx, d, 0x20uLL);
        EVP_DigestFinal(ctx, v35, 0);
        EVP_MD_CTX_free(ctx);
        bcrypt_hash((uint64_t)md);
        for (i = 0; i != 2; ++i)
          __s[i] = veorq_s8((int8x16_t)__s[i], (int8x16_t)d[i]);
        ++v19;
      }
      while (v19 != a7);
    }
    v21 = 0;
    if (v18 >= v17)
      v18 = v17;
    if (v18)
    {
      v22 = v31;
      while (v22 < a6)
      {
        *(_BYTE *)(a5 + v22) = *((_BYTE *)__s + v21++);
        v22 += v14;
        if (v18 == v21)
        {
          v21 = v18;
          break;
        }
      }
    }
    ++v16;
    v15 = v31 + 1;
    v17 -= v21;
    v7 = v27;
  }
  while (v17);
  memset_s(__s, 0x20uLL, 0, 0x20uLL);
  free(v29);
  return 0;
}

uint64_t bcrypt_hash(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unsigned __int16 v8;
  int v9;
  unsigned int v10;
  BOOL v11;
  int v12;
  unsigned int v13;
  unint64_t v14;
  int v15;
  int v16;
  unsigned int v17;
  int v18;
  int v19;
  unsigned int v20;
  int v21;
  uint64_t i;
  unint64_t v23;
  int v24;
  unsigned int v25;
  int v26;
  int v27;
  unsigned int v28;
  int v29;
  _DWORD *v30;
  int v31;
  uint64_t v32;
  unsigned __int16 v33;
  int v34;
  unsigned int v35;
  int j;
  unsigned int v37;
  unsigned int *v38;
  uint64_t k;
  _DWORD __dst[1042];
  int v42;
  unsigned int v43[8];
  _BYTE __s[40];
  uint64_t v45;

  v1 = MEMORY[0x24BDAC7A8](a1);
  v3 = v2;
  v5 = v4;
  v6 = v1;
  v45 = *MEMORY[0x24BDAC8D0];
  qmemcpy(__s, "OxychromaticBlowfishSwatDynamite", 32);
  memcpy(__dst, &Blowfish_initstate_initstate, sizeof(__dst));
  v7 = 0;
  v8 = 0;
  do
  {
    v9 = 0;
    v10 = 0;
    do
    {
      if ((v8 & 0xFFC0) != 0)
        v8 = 0;
      v9 = *(unsigned __int8 *)(v6 + v8++) | (v9 << 8);
      v11 = v10++ >= 3;
    }
    while (!v11);
    __dst[v7++ + 1024] ^= v9;
  }
  while (v7 != 18);
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v15 = 0;
  do
  {
    v16 = 0;
    v17 = 0;
    do
    {
      if ((v15 & 0xFFC0) != 0)
        v18 = 0;
      else
        v18 = v15;
      v16 = *(unsigned __int8 *)(v5 + (unsigned __int16)v18) | (v16 << 8);
      v15 = v18 + 1;
      v11 = v17++ >= 3;
    }
    while (!v11);
    v19 = 0;
    v20 = 0;
    v43[0] = v16 ^ v13;
    do
    {
      if ((v15 & 0xFFC0) != 0)
        v21 = 0;
      else
        v21 = v15;
      v19 = *(unsigned __int8 *)(v5 + (unsigned __int16)v21) | (v19 << 8);
      v15 = v21 + 1;
      v11 = v20++ >= 3;
    }
    while (!v11);
    v42 = v19 ^ v12;
    Blowfish_encipher(__dst, v43, &v42);
    v12 = v42;
    v13 = v43[0];
    __dst[v14 + 1024] = v43[0];
    *(_DWORD *)((char *)&__dst[1024] + ((4 * v14) | 4)) = v12;
    v11 = v14 >= 0x10;
    v14 += 2;
  }
  while (!v11);
  for (i = 0; i != 4; ++i)
  {
    v23 = 0;
    do
    {
      v24 = 0;
      v25 = 0;
      do
      {
        if ((v15 & 0xFFC0) != 0)
          v26 = 0;
        else
          v26 = v15;
        v24 = *(unsigned __int8 *)(v5 + (unsigned __int16)v26) | (v24 << 8);
        v15 = v26 + 1;
        v11 = v25++ >= 3;
      }
      while (!v11);
      v27 = 0;
      v28 = 0;
      v43[0] = v24 ^ v13;
      do
      {
        if ((v15 & 0xFFC0) != 0)
          v29 = 0;
        else
          v29 = v15;
        v27 = *(unsigned __int8 *)(v5 + (unsigned __int16)v29) | (v27 << 8);
        v15 = v29 + 1;
        v11 = v28++ >= 3;
      }
      while (!v11);
      v42 = v27 ^ v12;
      Blowfish_encipher(__dst, v43, &v42);
      v12 = v42;
      v13 = v43[0];
      v30 = &__dst[256 * i];
      v30[v23] = v43[0];
      *(_DWORD *)((char *)v30 + ((4 * v23) | 4)) = v12;
      v11 = v23 >= 0xFE;
      v23 += 2;
    }
    while (!v11);
  }
  v31 = 64;
  do
  {
    Blowfish_expand0state(__dst, v5);
    Blowfish_expand0state(__dst, v6);
    --v31;
  }
  while (v31);
  v32 = 0;
  v33 = 0;
  do
  {
    v34 = 0;
    v35 = 0;
    do
    {
      if ((v33 & 0xFFE0) != 0)
        v33 = 0;
      v34 = __s[v33++] | (v34 << 8);
      v11 = v35++ >= 3;
    }
    while (!v11);
    v43[v32++] = v34;
  }
  while (v32 != 8);
  for (j = 0; j != 64; ++j)
  {
    v37 = 0;
    v38 = v43;
    do
    {
      Blowfish_encipher(__dst, v38, (int *)v38 + 1);
      v38 += 2;
      v11 = v37++ >= 3;
    }
    while (!v11);
  }
  for (k = 0; k != 8; ++k)
    *(_DWORD *)(v3 + k * 4) = v43[k];
  memset_s(__s, 0x20uLL, 0, 0x20uLL);
  memset_s(v43, 0x20uLL, 0, 0x20uLL);
  return memset_s(__dst, 0x1048uLL, 0, 0x1048uLL);
}

_DWORD *Blowfish_expand0state(_DWORD *a1, uint64_t a2)
{
  _DWORD *v2;
  uint64_t v3;
  unsigned __int16 v4;
  int v6;
  unsigned int v7;
  BOOL v8;
  unint64_t v9;
  uint64_t i;
  unint64_t v11;
  _DWORD *result;
  int v13;
  _DWORD *v14;
  uint64_t v15;

  v2 = a1;
  v3 = 0;
  v4 = 0;
  do
  {
    v6 = 0;
    v7 = 0;
    do
    {
      if ((v4 & 0xFFC0) != 0)
        v4 = 0;
      v6 = *(unsigned __int8 *)(a2 + v4++) | (v6 << 8);
      v8 = v7++ >= 3;
    }
    while (!v8);
    a1[v3++ + 1024] ^= v6;
  }
  while (v3 != 18);
  v9 = 0;
  v15 = 0;
  do
  {
    Blowfish_encipher(v2, (unsigned int *)&v15 + 1, (int *)&v15);
    v2[v9 + 1024] = HIDWORD(v15);
    v2[v9 + 1025] = v15;
    v8 = v9 >= 0x10;
    v9 += 2;
  }
  while (!v8);
  for (i = 0; i != 4; ++i)
  {
    v11 = 0;
    do
    {
      result = Blowfish_encipher(a1, (unsigned int *)&v15 + 1, (int *)&v15);
      v13 = v15;
      v14 = &v2[v11];
      *v14 = HIDWORD(v15);
      v14[1] = v13;
      v8 = v11 >= 0xFE;
      v11 += 2;
    }
    while (!v8);
    v2 += 256;
  }
  return result;
}

_DWORD *Blowfish_encipher(_DWORD *result, unsigned int *a2, int *a3)
{
  unsigned int v3;
  unsigned int v4;
  unsigned int v5;
  unsigned int v6;
  unsigned int v7;
  unsigned int v8;
  unsigned int v9;
  unsigned int v10;
  unsigned int v11;
  unsigned int v12;
  unsigned int v13;
  unsigned int v14;
  unsigned int v15;
  unsigned int v16;
  unsigned int v17;
  unsigned int v18;
  int v19;

  v3 = result[1024] ^ *a2;
  v4 = result[1025] ^ *a3 ^ (((result[BYTE2(v3) | 0x100] + result[HIBYTE(v3)]) ^ result[BYTE1(v3) | 0x200])
                           + result[(*((_BYTE *)result + 4096) ^ *(_BYTE *)a2) | 0x300]);
  v5 = result[1026] ^ v3 ^ (((result[BYTE2(v4) | 0x100] + result[HIBYTE(v4)]) ^ result[BYTE1(v4) | 0x200])
                          + result[(*((_BYTE *)result + 4100) ^ *(_BYTE *)a3 ^ (((LOBYTE(result[BYTE2(v3) | 0x100])
                                                                                                 + LOBYTE(result[HIBYTE(v3)])) ^ LOBYTE(result[BYTE1(v3) | 0x200]))
                                                                                               + LOBYTE(result[(*((_BYTE *)result + 4096) ^ *(_BYTE *)a2) | 0x300]))) | 0x300]);
  v6 = result[1027] ^ v4 ^ (((result[BYTE2(v5) | 0x100] + result[HIBYTE(v5)]) ^ result[BYTE1(v5) | 0x200])
                          + result[v5 | 0x300]);
  v7 = result[1028] ^ v5 ^ (((result[BYTE2(v6) | 0x100] + result[HIBYTE(v6)]) ^ result[BYTE1(v6) | 0x200])
                          + result[v6 | 0x300]);
  v8 = result[1029] ^ v6 ^ (((result[BYTE2(v7) | 0x100] + result[HIBYTE(v7)]) ^ result[BYTE1(v7) | 0x200])
                          + result[v7 | 0x300]);
  v9 = result[1030] ^ v7 ^ (((result[BYTE2(v8) | 0x100] + result[HIBYTE(v8)]) ^ result[BYTE1(v8) | 0x200])
                          + result[v8 | 0x300]);
  v10 = result[1031] ^ v8 ^ (((result[BYTE2(v9) | 0x100] + result[HIBYTE(v9)]) ^ result[BYTE1(v9) | 0x200])
                           + result[v9 | 0x300]);
  v11 = result[1032] ^ v9 ^ (((result[BYTE2(v10) | 0x100] + result[HIBYTE(v10)]) ^ result[BYTE1(v10) | 0x200])
                           + result[v10 | 0x300]);
  v12 = result[1033] ^ v10 ^ (((result[BYTE2(v11) | 0x100] + result[HIBYTE(v11)]) ^ result[BYTE1(v11) | 0x200])
                            + result[v11 | 0x300]);
  v13 = result[1034] ^ v11 ^ (((result[BYTE2(v12) | 0x100] + result[HIBYTE(v12)]) ^ result[BYTE1(v12) | 0x200])
                            + result[v12 | 0x300]);
  v14 = result[1035] ^ v12 ^ (((result[BYTE2(v13) | 0x100] + result[HIBYTE(v13)]) ^ result[BYTE1(v13) | 0x200])
                            + result[v13 | 0x300]);
  v15 = result[1036] ^ v13 ^ (((result[BYTE2(v14) | 0x100] + result[HIBYTE(v14)]) ^ result[BYTE1(v14) | 0x200])
                            + result[v14 | 0x300]);
  v16 = result[1037] ^ v14 ^ (((result[BYTE2(v15) | 0x100] + result[HIBYTE(v15)]) ^ result[BYTE1(v15) | 0x200])
                            + result[v15 | 0x300]);
  v17 = result[1038] ^ v15 ^ (((result[BYTE2(v16) | 0x100] + result[HIBYTE(v16)]) ^ result[BYTE1(v16) | 0x200])
                            + result[v16 | 0x300]);
  v18 = result[1039] ^ v16 ^ (((result[BYTE2(v17) | 0x100] + result[HIBYTE(v17)]) ^ result[BYTE1(v17) | 0x200])
                            + result[v17 | 0x300]);
  v19 = result[1040] ^ v17 ^ (((result[BYTE2(v18) | 0x100] + result[HIBYTE(v18)]) ^ result[BYTE1(v18) | 0x200])
                            + result[v18 | 0x300]);
  *a2 = result[1041] ^ v18;
  *a3 = v19;
  return result;
}

uint64_t libssh2_keepalive_config(uint64_t result, int a2, int a3)
{
  int v3;

  if (a3 == 1)
    v3 = 2;
  else
    v3 = a3;
  *(_DWORD *)(result + 73560) = v3;
  *(_DWORD *)(result + 73564) = a2 != 0;
  return result;
}

uint64_t libssh2_keepalive_send(uint64_t a1, _DWORD *a2)
{
  int *v3;
  time_t v5;
  time_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _OWORD v12[2];
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  v3 = (int *)(a1 + 73560);
  if (*(_DWORD *)(a1 + 73560))
  {
    v5 = time(0);
    v6 = v5;
    v7 = *((_QWORD *)v3 + 1);
    v8 = *v3;
    if (v7 + v8 > v5)
    {
      if (a2)
        *a2 = v8 + v7 - v5;
      return 0;
    }
    strcpy((char *)v12 + 12, "ve@libssh2.orgW");
    v12[0] = xmmword_22D68E284;
    BYTE10(v12[1]) = v3[1];
    v10 = _libssh2_transport_send(a1, v12, 0x1BuLL, 0, 0);
    v9 = v10;
    if ((_DWORD)v10 != -37 && (_DWORD)v10)
    {
      _libssh2_error(a1, 4294967289, "Unable to send keepalive message");
    }
    else
    {
      *((_QWORD *)v3 + 1) = v6;
      if (a2)
        *a2 = *v3;
    }
    if ((_DWORD)v9 == -37 || !(_DWORD)v9)
      return 0;
  }
  else
  {
    if (!a2)
      return 0;
    v9 = 0;
    *a2 = 0;
  }
  return v9;
}

uint64_t libssh2_session_banner_set(uint64_t a1, char *__s)
{
  size_t v4;
  uint64_t v5;
  void *v6;

  if (__s)
    v4 = strlen(__s);
  else
    v4 = 0;
  v5 = *(_QWORD *)(a1 + 424);
  if (v5)
  {
    (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v5, a1);
    *(_QWORD *)(a1 + 424) = 0;
  }
  if (!v4)
    return 0;
  v6 = (void *)(*(uint64_t (**)(size_t, uint64_t))(a1 + 8))(v4 + 3, a1);
  *(_QWORD *)(a1 + 424) = v6;
  if (v6)
  {
    memcpy(v6, __s, v4);
    *(_BYTE *)(*(_QWORD *)(a1 + 424) + v4) = 0;
    *(_BYTE *)(*(_QWORD *)(a1 + 424) + v4) = 13;
    *(_BYTE *)(v4 + *(_QWORD *)(a1 + 424) + 1) = 10;
    *(_BYTE *)(v4 + *(_QWORD *)(a1 + 424) + 2) = 0;
    return 0;
  }
  return _libssh2_error(a1, 4294967290, "Unable to allocate memory for local banner");
}

_QWORD *libssh2_session_init_ex(void *(*a1)(size_t a1), void (__cdecl *a2)(void *), void *(*a3)(void *a1, size_t a2), uint64_t a4)
{
  void *(*v6)(size_t);
  _QWORD *v7;
  _QWORD *v8;
  uint64_t v10;

  v10 = a4;
  if (a1)
  {
    v6 = a1;
    v7 = (_QWORD *)((uint64_t (*)(uint64_t, uint64_t *))a1)(73584, &v10);
  }
  else
  {
    v6 = libssh2_default_alloc;
    v7 = (_QWORD *)((uint64_t (*)(uint64_t, uint64_t *))libssh2_default_alloc)(73584, &v10);
  }
  v8 = v7;
  if (v7)
  {
    if (!a3)
      a3 = libssh2_default_realloc;
    if (!a2)
      a2 = libssh2_default_free;
    bzero(v7, 0x11F70uLL);
    v8[2] = a3;
    v8[3] = a2;
    v8[12] = _libssh2_send;
    v8[13] = _libssh2_recv;
    *v8 = v10;
    v8[1] = v6;
    v8[22] = 0;
    *((_DWORD *)v8 + 43) = 1;
    v8[9197] = 60;
    *((_DWORD *)v8 + 35) = 1;
    _libssh2_init_if_needed();
  }
  return v8;
}

void *libssh2_default_alloc(size_t a1)
{
  return malloc_type_malloc(a1, 0xA00FEF1BuLL);
}

void *libssh2_default_realloc(void *a1, size_t a2)
{
  return malloc_type_realloc(a1, a2, 0xE27BE433uLL);
}

uint64_t libssh2_session_callback_set(uint64_t *a1, int a2, uint64_t a3)
{
  uint64_t *v3;
  uint64_t result;

  switch(a2)
  {
    case 0:
      v3 = a1 + 4;
      goto LABEL_13;
    case 1:
      v3 = a1 + 5;
      goto LABEL_13;
    case 2:
      v3 = a1 + 6;
      goto LABEL_13;
    case 3:
      v3 = a1 + 7;
      goto LABEL_13;
    case 4:
      v3 = a1 + 8;
      goto LABEL_13;
    case 5:
      v3 = a1 + 12;
      goto LABEL_13;
    case 6:
      v3 = a1 + 13;
      goto LABEL_13;
    case 7:
      v3 = a1 + 9;
      goto LABEL_13;
    case 8:
      v3 = a1 + 10;
      goto LABEL_13;
    case 9:
      v3 = a1 + 11;
LABEL_13:
      result = *v3;
      *v3 = a3;
      break;
    default:
      result = 0;
      break;
  }
  return result;
}

uint64_t _libssh2_wait_socket(uint64_t a1, time_t a2)
{
  uint64_t result;
  int v5;
  uint64_t v6;
  uint64_t v7;
  _BOOL4 v8;
  fd_set *v9;
  int v10;
  fd_set *v11;
  int v12;
  timeval *v13;
  int v14;
  char *v15;
  time_t v16;
  double v17;
  uint64_t v18;
  _QWORD v19[2];
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  int v36;

  v36 = 0;
  *(_DWORD *)(a1 + 616) = 0;
  result = libssh2_keepalive_send(a1, &v36);
  if (!(_DWORD)result)
  {
    v5 = *(_DWORD *)(a1 + 600);
    if (v5)
      LODWORD(v6) = 1000 * v36;
    else
      LODWORD(v6) = 1000;
    v6 = (int)v6;
    v7 = *(_QWORD *)(a1 + 176);
    if (v7 < 1 || v36 && v7 >= (int)v6)
    {
      v8 = (int)v6 > 0;
    }
    else
    {
      v16 = time(0);
      v17 = difftime(v16, a2) * 1000.0;
      v18 = *(_QWORD *)(a1 + 176);
      v6 = v18 - (uint64_t)v17;
      if (v18 < (uint64_t)v17)
      {
        v15 = "API timeout expired";
        return _libssh2_error(a1, 4294967287, v15);
      }
      v8 = 1;
    }
    v9 = 0;
    v34 = 0u;
    v35 = 0u;
    v32 = 0u;
    v33 = 0u;
    v30 = 0u;
    v31 = 0u;
    v28 = 0u;
    v29 = 0u;
    v26 = 0u;
    v27 = 0u;
    v24 = 0u;
    v25 = 0u;
    v22 = 0u;
    v23 = 0u;
    v20 = 0u;
    v21 = 0u;
    v19[0] = v6 / 1000;
    v19[1] = 1000 * (v6 % 1000);
    if ((v5 & 1) != 0)
    {
      v34 = 0uLL;
      v35 = 0uLL;
      v32 = 0uLL;
      v33 = 0uLL;
      v30 = 0uLL;
      v31 = 0uLL;
      v28 = 0uLL;
      v29 = 0uLL;
      v10 = *(_DWORD *)(a1 + 592);
      v9 = (fd_set *)&v28;
      if (__darwin_check_fd_set_overflow(v10, &v28, 0))
        *(_DWORD *)((char *)&v28 + (((unint64_t)v10 >> 3) & 0x1FFFFFFFFFFFFFFCLL)) |= 1 << v10;
    }
    if ((v5 & 2) != 0)
    {
      v26 = 0u;
      v27 = 0u;
      v24 = 0u;
      v25 = 0u;
      v22 = 0u;
      v23 = 0u;
      v20 = 0u;
      v21 = 0u;
      v12 = *(_DWORD *)(a1 + 592);
      v11 = (fd_set *)&v20;
      if (__darwin_check_fd_set_overflow(v12, &v20, 0))
        *(_DWORD *)((char *)&v20 + (((unint64_t)v12 >> 3) & 0x1FFFFFFFFFFFFFFCLL)) |= 1 << v12;
    }
    else
    {
      v11 = 0;
    }
    if (v8)
      v13 = (timeval *)v19;
    else
      v13 = 0;
    v14 = select(*(_DWORD *)(a1 + 592) + 1, v9, v11, 0, v13);
    if (v14)
    {
      if ((v14 & 0x80000000) == 0)
        return 0;
      v15 = "Error waiting on socket";
    }
    else
    {
      v15 = "Timed out waiting on socket";
    }
    return _libssh2_error(a1, 4294967287, v15);
  }
  return result;
}

uint64_t libssh2_session_block_directions(uint64_t a1)
{
  return *(unsigned int *)(a1 + 600);
}

uint64_t libssh2_session_handshake(uint64_t a1, int a2)
{
  _QWORD *v3;
  uint64_t v4;
  time_t v5;
  _QWORD *v6;
  unint64_t *v7;
  uint64_t result;
  char v9;
  int v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  _QWORD *v16;
  unint64_t *v17;
  _QWORD *v18;
  const char *v19;
  size_t v20;
  uint64_t v21;
  uint64_t v22;
  size_t v23;
  uint64_t v24;
  BOOL v26;
  size_t v27;
  int v28;
  uint64_t v30;
  void *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  unsigned int v35;
  uint64_t v36;
  char v38;

  v3 = (_QWORD *)(a1 + 71040);
  v4 = a1 + 70720;
  v5 = time(0);
  v6 = (_QWORD *)(a1 + 71024);
  v7 = (unint64_t *)(a1 + 71032);
  while (2)
  {
    result = 4294967262;
    switch(*(_DWORD *)(v4 + 296))
    {
      case 0:
        if (a2 == -1)
        {
          v14 = a1;
          v13 = 4294967251;
          v15 = "Bad socket provided";
          goto LABEL_77;
        }
        *(_DWORD *)(a1 + 592) = a2;
        v9 = fcntl(a2, 3, 0);
        *(_DWORD *)(a1 + 604) = (v9 & 4) == 0;
        if ((v9 & 4) == 0)
        {
          v10 = *(_DWORD *)(a1 + 592);
          v11 = fcntl(v10, 3, 0);
          v12 = fcntl(v10, 4, v11 | 4u);
          if ((_DWORD)v12)
          {
            v13 = v12;
            v14 = a1;
            v15 = "Failed changing socket's blocking state to non-blocking";
            goto LABEL_77;
          }
        }
        *(_DWORD *)(v4 + 296) = 2;
        goto LABEL_8;
      case 2:
LABEL_8:
        if (*(_DWORD *)v4)
        {
          v16 = v3;
          v17 = v7;
          v18 = v6;
          v19 = "SSH-2.0-libssh2_1.11.0\r\n";
          v20 = 24;
        }
        else
        {
          v16 = v3;
          v17 = v7;
          v18 = v6;
          v19 = *(const char **)(a1 + 424);
          if (v19)
          {
            v20 = strlen(*(const char **)(a1 + 424));
          }
          else
          {
            v19 = "SSH-2.0-libssh2_1.11.0\r\n";
            v20 = 24;
          }
          *(_DWORD *)v4 = 2;
        }
        *(_DWORD *)(a1 + 600) &= ~2u;
        v21 = (*(uint64_t (**)(_QWORD, const char *, size_t, _QWORD, uint64_t))(a1 + 96))(*(unsigned int *)(a1 + 592), &v19[*(_QWORD *)(v4 + 264)], v20 - *(_QWORD *)(v4 + 264), (*(_DWORD *)(a1 + 132) == 0) << 19, a1);
        v22 = *(_QWORD *)(v4 + 264);
        if (v21 != v20 - v22)
        {
          v6 = v18;
          if (v21 < 0 && v21 != -35)
          {
            *(_DWORD *)v4 = 0;
            *(_QWORD *)(v4 + 264) = 0;
            result = _libssh2_error(a1, 4294967253, "Failed sending banner");
            v7 = v17;
            v3 = v16;
            goto LABEL_78;
          }
          *(_DWORD *)(a1 + 600) = 2;
          v7 = v17;
          v3 = v16;
          if (v21 >= 1)
            *(_QWORD *)(v4 + 264) = v22 + v21;
LABEL_79:
          if (!*(_DWORD *)(a1 + 172))
            return 4294967259;
          result = _libssh2_wait_socket(a1, v5);
          if ((_DWORD)result)
            return result;
          continue;
        }
        *(_QWORD *)(v4 + 264) = 0;
        *(_DWORD *)(v4 + 296) = 3;
        *(_DWORD *)v4 = 0;
        v6 = v18;
        v7 = v17;
        v3 = v16;
        do
        {
LABEL_17:
          if (*(_DWORD *)v4)
          {
            v23 = *(_QWORD *)(v4 + 264);
            if (v23 > 0xFF)
              goto LABEL_35;
            goto LABEL_19;
          }
          v23 = 0;
          *(_DWORD *)v4 = 2;
          do
          {
            v38 = 0;
            *(_DWORD *)(a1 + 600) &= ~1u;
            v24 = (*(uint64_t (**)(_QWORD, char *, uint64_t, _QWORD, uint64_t))(a1 + 104))(*(unsigned int *)(a1 + 592), &v38, 1, (*(_DWORD *)(a1 + 132) == 0) << 19, a1);
            if (v24 < 0)
            {
              if (v24 == -35)
              {
                *(_DWORD *)(a1 + 600) = 1;
                *(_QWORD *)(v4 + 264) = v23;
                v13 = 4294967259;
              }
              else
              {
                *(_DWORD *)v4 = 0;
                *(_QWORD *)(v4 + 264) = 0;
                v13 = 4294967253;
              }
LABEL_82:
              if ((_DWORD)v13 != -37)
              {
LABEL_64:
                v14 = a1;
                v15 = "Failed getting banner";
                goto LABEL_77;
              }
              goto LABEL_79;
            }
            if (!v24)
            {
              *(_DWORD *)(a1 + 596) = -1;
              v13 = 4294967283;
              goto LABEL_82;
            }
            v26 = v38 == 13 || v38 == 10;
            if (!v23 && v26)
            {
              v23 = 0;
              goto LABEL_34;
            }
            if (!v38)
            {
              *(_DWORD *)v4 = 0;
              *(_QWORD *)(v4 + 264) = 0;
              v13 = 4294967294;
              goto LABEL_82;
            }
            v27 = a1 + v23++;
            *(_BYTE *)(v27 + 70724) = v38;
LABEL_34:
            if (v23 >= 0x100)
              break;
LABEL_19:
            ;
          }
          while (!v23 || *(_BYTE *)(v23 + a1 + 70723) != 10);
LABEL_35:
          while (1)
          {
            v28 = *(unsigned __int8 *)(a1 + 70723 + v23);
            if (v28 != 13 && v28 != 10)
              break;
            if (!--v23)
            {
              *(_DWORD *)v4 = 0;
              *(_QWORD *)(v4 + 264) = 0;
              v13 = 4294967294;
              goto LABEL_64;
            }
          }
          *(_DWORD *)v4 = 0;
          *(_QWORD *)(v4 + 264) = 0;
          v30 = *(_QWORD *)(a1 + 312);
          if (v30)
            (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v30, a1);
          v31 = (void *)(*(uint64_t (**)(size_t, uint64_t))(a1 + 8))(v23 + 1, a1);
          *(_QWORD *)(a1 + 312) = v31;
          if (v31)
          {
            memcpy(v31, (const void *)(a1 + 70724), v23);
            *(_BYTE *)(*(_QWORD *)(a1 + 312) + v23) = 0;
            continue;
          }
          v13 = _libssh2_error(a1, 4294967290, "Error allocating space for remote banner");
          if ((_DWORD)v13)
            goto LABEL_82;
        }
        while (strncmp("SSH-", *(const char **)(a1 + 312), 4uLL));
        *(_DWORD *)(v4 + 296) = 4;
LABEL_55:
        v32 = _libssh2_kex_exchange(a1, 0, a1 + 71088);
        if ((_DWORD)v32 == -37)
          goto LABEL_79;
        v13 = v32;
        if ((_DWORD)v32)
        {
          v14 = a1;
          v15 = "Unable to exchange encryption keys";
          goto LABEL_77;
        }
        *(_DWORD *)(v4 + 296) = 5;
LABEL_58:
        *(_BYTE *)v3 = 5;
        _libssh2_htonu32((_DWORD *)(a1 + 71041), 0xCu);
        *(_DWORD *)(a1 + 71053) = 1752462689;
        *(_QWORD *)(a1 + 71045) = *(_QWORD *)"ssh-userauth";
        *(_DWORD *)(v4 + 296) = 6;
LABEL_59:
        v33 = _libssh2_transport_send(a1, v3, 0x11uLL, 0, 0);
        if ((_DWORD)v33 == -37)
          goto LABEL_79;
        v13 = v33;
        if ((_DWORD)v33)
        {
          v14 = a1;
          v15 = "Unable to ask for ssh-userauth service";
          goto LABEL_77;
        }
        *(_DWORD *)(v4 + 296) = 7;
LABEL_62:
        v34 = _libssh2_packet_require(a1, 6, v6, v7, 0, 0, 0, a1 + 71072);
        if ((_DWORD)v34)
        {
          v13 = v34;
          v14 = a1;
          v15 = "Failed to get response to ssh-userauth request";
          goto LABEL_77;
        }
        if (*v7 <= 4)
        {
          v14 = a1;
          v13 = 4294967282;
          v15 = "Unexpected packet length";
          goto LABEL_77;
        }
        v35 = _libssh2_ntohu32((unsigned int *)(*v6 + 1));
        v3[3] = v35;
        v36 = *v6;
        if (v35 == 12 && !strncmp("ssh-userauth", (const char *)(v36 + 5), 0xCuLL))
        {
          (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v36, a1);
          result = 0;
          *(_QWORD *)(v4 + 304) = 0;
          *(_DWORD *)(v4 + 296) = 0;
        }
        else
        {
          (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v36, a1);
          *v6 = 0;
          v14 = a1;
          v13 = 4294967282;
          v15 = "Invalid response received from server";
LABEL_77:
          result = _libssh2_error(v14, v13, v15);
LABEL_78:
          if ((_DWORD)result == -37)
            goto LABEL_79;
        }
        return result;
      case 3:
        goto LABEL_17;
      case 4:
        goto LABEL_55;
      case 5:
        goto LABEL_58;
      case 6:
        goto LABEL_59;
      case 7:
        goto LABEL_62;
      default:
        return result;
    }
  }
}

uint64_t libssh2_session_free(uint64_t a1)
{
  uint64_t v2;
  _QWORD *v3;
  time_t v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t result;
  uint64_t v9;
  void (*v10)(uint64_t, uint64_t);
  uint64_t v11;
  void (*v12)(uint64_t, uint64_t);
  uint64_t v13;
  void (*v14)(uint64_t, uint64_t, uint64_t);
  uint64_t v15;
  void (*v16)(uint64_t, uint64_t);
  uint64_t v17;
  void (*v18)(uint64_t, uint64_t);
  uint64_t v19;
  void (*v20)(uint64_t, _QWORD, uint64_t);
  uint64_t v21;
  void (*v22)(uint64_t, uint64_t);
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t *v63;
  int v64;
  int v65;
  uint64_t v66;

  v2 = a1 + 71000;
  v3 = (_QWORD *)(a1 + 35664);
  v4 = time(0);
  while (2)
  {
    v5 = *(_DWORD *)(v2 + 752);
    switch(v5)
    {
      case 3:
        goto LABEL_10;
      case 2:
        do
        {
LABEL_6:
          v6 = _libssh2_list_first(a1 + 552);
          if (!v6)
          {
            *(_DWORD *)(v2 + 752) = 3;
LABEL_10:
            while (1)
            {
              v7 = _libssh2_list_first(a1 + 576);
              if (!v7)
                break;
              if (_libssh2_channel_forward_cancel(v7) == -37)
                goto LABEL_12;
            }
            *(_DWORD *)(v2 + 752) = 4;
            goto LABEL_16;
          }
        }
        while (_libssh2_channel_free(v6) != -37);
LABEL_12:
        if (*(_DWORD *)(a1 + 172))
        {
          result = _libssh2_wait_socket(a1, v4);
          if (!(_DWORD)result)
            continue;
        }
        else
        {
          return 4294967259;
        }
        break;
      case 0:
        *(_DWORD *)(v2 + 752) = 2;
        goto LABEL_6;
      default:
LABEL_16:
        if ((*(_BYTE *)(a1 + 128) & 2) != 0)
        {
          v9 = *(_QWORD *)(a1 + 184);
          if (v9)
          {
            v10 = *(void (**)(uint64_t, uint64_t))(v9 + 64);
            if (v10)
              v10(a1, a1 + 192);
          }
          v11 = *(_QWORD *)(a1 + 448);
          if (v11)
          {
            v12 = *(void (**)(uint64_t, uint64_t))(v11 + 56);
            if (v12)
              v12(a1, a1 + 456);
          }
          v13 = *(_QWORD *)(a1 + 488);
          if (v13)
          {
            v14 = *(void (**)(uint64_t, uint64_t, uint64_t))(v13 + 40);
            if (v14)
              v14(a1, 1, a1 + 496);
          }
          v15 = *(_QWORD *)(a1 + 464);
          if (v15)
          {
            v16 = *(void (**)(uint64_t, uint64_t))(v15 + 32);
            if (v16)
              v16(a1, a1 + 480);
          }
          v17 = *(_QWORD *)(a1 + 336);
          if (v17)
          {
            v18 = *(void (**)(uint64_t, uint64_t))(v17 + 56);
            if (v18)
              v18(a1, a1 + 344);
          }
          v19 = *(_QWORD *)(a1 + 376);
          if (v19)
          {
            v20 = *(void (**)(uint64_t, _QWORD, uint64_t))(v19 + 40);
            if (v20)
              v20(a1, 0, a1 + 384);
          }
          v21 = *(_QWORD *)(a1 + 352);
          if (v21)
          {
            v22 = *(void (**)(uint64_t, uint64_t))(v21 + 32);
            if (v22)
              v22(a1, a1 + 368);
          }
          v23 = *(_QWORD *)(a1 + 160);
          if (v23)
            (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v23, a1);
        }
        v24 = *(_QWORD *)(a1 + 312);
        if (v24)
          (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v24, a1);
        v25 = *(_QWORD *)(a1 + 424);
        if (v25)
          (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v25, a1);
        v26 = *(_QWORD *)(a1 + 112);
        if (v26)
          (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v26, a1);
        v27 = *(_QWORD *)(a1 + 120);
        if (v27)
          (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v27, a1);
        v28 = *(_QWORD *)(a1 + 432);
        if (v28)
          (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v28, a1);
        v29 = *(_QWORD *)(a1 + 504);
        if (v29)
          (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v29, a1);
        v30 = *(_QWORD *)(a1 + 512);
        if (v30)
          (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v30, a1);
        v31 = *(_QWORD *)(a1 + 520);
        if (v31)
          (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v31, a1);
        v32 = *(_QWORD *)(a1 + 528);
        if (v32)
          (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v32, a1);
        v33 = *(_QWORD *)(a1 + 320);
        if (v33)
          (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v33, a1);
        v34 = *(_QWORD *)(a1 + 392);
        if (v34)
          (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v34, a1);
        v35 = *(_QWORD *)(a1 + 400);
        if (v35)
          (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v35, a1);
        v36 = *(_QWORD *)(a1 + 408);
        if (v36)
          (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v36, a1);
        v37 = *(_QWORD *)(a1 + 416);
        if (v37)
          (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v37, a1);
        v38 = *(_QWORD *)(a1 + 296);
        if (v38)
          (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v38, a1);
        v39 = *(_QWORD *)(a1 + 304);
        if (v39)
          (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v39, a1);
        if (*(_QWORD *)v2)
          (*(void (**)(_QWORD, uint64_t))(a1 + 24))(*(_QWORD *)v2, a1);
        v40 = *(_QWORD *)(v2 + 24);
        if (v40)
          (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v40, a1);
        v41 = *(_QWORD *)(v2 + 1056);
        if (v41)
          (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v41, a1);
        v42 = *(_QWORD *)(v2 + 1072);
        if (v42)
          (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v42, a1);
        v43 = *(_QWORD *)(v2 + 1096);
        if (v43)
          (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v43, a1);
        v44 = *(_QWORD *)(v2 + 1120);
        if (v44)
          (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v44, a1);
        v45 = *(_QWORD *)(v2 + 1168);
        if (v45)
          (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v45, a1);
        v46 = *(_QWORD *)(v2 + 1184);
        if (v46)
          (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v46, a1);
        v47 = *(_QWORD *)(v2 + 1152);
        if (v47)
          (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v47, a1);
        v48 = *(_QWORD *)(v2 + 1224);
        if (v48)
          (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v48, a1);
        v49 = *(_QWORD *)(v2 + 1240);
        if (v49)
          (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v49, a1);
        v50 = *(_QWORD *)(v2 + 1256);
        if (v50)
          (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v50, a1);
        v51 = *(_QWORD *)(v2 + 1304);
        if (v51)
          (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v51, a1);
        v52 = *(_QWORD *)(v2 + 1320);
        if (v52)
          (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v52, a1);
        v53 = *(_QWORD *)(v2 + 1360);
        if (v53)
          (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v53, a1);
        v54 = *(_QWORD *)(v2 + 1424);
        if (v54)
          (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v54, a1);
        v55 = *(_QWORD *)(v2 + 1440);
        if (v55)
          (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v55, a1);
        v56 = *(_QWORD *)(v2 + 1464);
        if (v56)
          (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v56, a1);
        v57 = *(_QWORD *)(v2 + 1504);
        if (v57)
          (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v57, a1);
        v58 = *(_QWORD *)(v2 + 1552);
        if (v58)
          (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v58, a1);
        v59 = *(_QWORD *)(v2 + 1944);
        if (v59)
          (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v59, a1);
        v60 = *(_QWORD *)(v2 + 2272);
        if (v60)
          (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v60, a1);
        v61 = *(_QWORD *)(v2 + 1896);
        if (v61)
          (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v61, a1);
        if (*v3)
          (*(void (**)(_QWORD, uint64_t))(a1 + 24))(v3[1], a1);
        v62 = _libssh2_list_first(a1 + 536);
        if (v62)
        {
          v63 = (uint64_t *)v62;
          do
          {
            _libssh2_list_remove(v63);
            (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v63[3], a1);
            (*(void (**)(uint64_t *, uint64_t))(a1 + 24))(v63, a1);
            v63 = (uint64_t *)_libssh2_list_first(a1 + 536);
          }
          while (v63);
        }
        if (*(_DWORD *)(a1 + 604))
        {
          v64 = *(_DWORD *)(a1 + 592);
          v65 = fcntl(v64, 3, 0);
          fcntl(v64, 4, v65 & 0xFFFFFFFB);
        }
        v66 = *(_QWORD *)(a1 + 200);
        if (v66)
          (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v66, a1);
        if (*(_QWORD *)(a1 + 608))
        {
          if ((*(_BYTE *)(a1 + 620) & 1) != 0)
            (*(void (**)(void))(a1 + 24))();
        }
        (*(void (**)(uint64_t, uint64_t))(a1 + 24))(a1, a1);
        return 0;
    }
    return result;
  }
}

uint64_t libssh2_session_disconnect_ex(_DWORD *a1, unsigned int a2, const void *a3, const char *a4)
{
  size_t *v7;
  _DWORD *v8;
  time_t v9;
  size_t v10;
  size_t v11;
  unint64_t v12;
  size_t v13;
  char *v14;
  uint64_t result;
  _DWORD *v17;

  v7 = (size_t *)(a1 + 18008);
  v8 = a1 + 17939;
  a1[32] &= ~1u;
  v9 = time(0);
  while (1)
  {
    v10 = 0;
    v17 = 0;
    if (*v8)
      break;
    if (!a3)
    {
      if (!a4)
      {
        v12 = 0;
LABEL_15:
        v10 = 0;
LABEL_16:
        *v7 = v12 + v10 + 13;
        v17 = (_DWORD *)((char *)a1 + 71761);
        *((_BYTE *)v8 + 4) = 1;
        _libssh2_store_u32(&v17, a2);
        _libssh2_store_str(&v17, a3, v12);
        _libssh2_store_u32(&v17, v10);
        *v8 = 2;
        break;
      }
      v10 = strlen(a4);
      v12 = 0;
LABEL_9:
      v14 = "too long language string";
      if (v10 <= 0x100)
        goto LABEL_16;
      goto LABEL_12;
    }
    v11 = strlen((const char *)a3);
    v12 = v11;
    if (a4)
    {
      v13 = strlen(a4);
      v14 = "too long description";
      if (v12 > 0x100)
        goto LABEL_12;
      v10 = v13;
      goto LABEL_9;
    }
    v14 = "too long description";
    if (v11 <= 0x100)
      goto LABEL_15;
LABEL_12:
    result = _libssh2_error((uint64_t)a1, 4294967262, v14);
    if ((_DWORD)result != -37)
      return result;
LABEL_18:
    if (!a1[43])
      return 4294967259;
    result = _libssh2_wait_socket((uint64_t)a1, v9);
    if ((_DWORD)result)
      return result;
  }
  if (_libssh2_transport_send((uint64_t)a1, a1 + 17940, *v7, a4, v10) == -37)
    goto LABEL_18;
  result = 0;
  *v8 = 0;
  return result;
}

const char *libssh2_session_methods(uint64_t a1, int a2)
{
  const char *v2;
  uint64_t *v3;
  char *v4;
  uint64_t v5;
  uint64_t v6;

  v2 = "";
  switch(a2)
  {
    case 0:
      v3 = (uint64_t *)(a1 + 144);
      goto LABEL_11;
    case 1:
      v3 = (uint64_t *)(a1 + 184);
      goto LABEL_11;
    case 2:
      v3 = (uint64_t *)(a1 + 448);
      goto LABEL_11;
    case 3:
      v3 = (uint64_t *)(a1 + 336);
      goto LABEL_11;
    case 4:
      v3 = (uint64_t *)(a1 + 464);
      goto LABEL_11;
    case 5:
      v3 = (uint64_t *)(a1 + 352);
      goto LABEL_11;
    case 6:
      v3 = (uint64_t *)(a1 + 488);
      goto LABEL_11;
    case 7:
      v3 = (uint64_t *)(a1 + 376);
LABEL_11:
      v6 = *v3;
      if (v6)
        return *(const char **)v6;
      v4 = "No method negotiated";
      v5 = 4294967279;
LABEL_14:
      _libssh2_error(a1, v5, v4);
      return 0;
    case 8:
    case 9:
      return v2;
    default:
      v4 = "Invalid parameter specified for method_type";
      v5 = 4294967262;
      goto LABEL_14;
  }
}

uint64_t libssh2_session_last_error(uint64_t a1, const char **a2, _DWORD *a3, int a4)
{
  const char *v8;
  size_t v9;
  size_t v10;
  char *v11;
  const char *v12;
  uint64_t result;

  if (*(_DWORD *)(a1 + 616))
  {
    if (a2)
    {
      if (*(_QWORD *)(a1 + 608))
        v8 = *(const char **)(a1 + 608);
      else
        v8 = "";
      v9 = strlen(v8);
      v10 = v9;
      if (!a4)
      {
        *a2 = v8;
        if (!a3)
          return *(unsigned int *)(a1 + 616);
        goto LABEL_16;
      }
      v11 = (char *)(*(uint64_t (**)(size_t, uint64_t))(a1 + 8))(v9 + 1, a1);
      *a2 = v11;
      if (v11)
      {
        memcpy(v11, v8, v10);
        (*a2)[v10] = 0;
        if (!a3)
          return *(unsigned int *)(a1 + 616);
        goto LABEL_16;
      }
    }
    else
    {
      LODWORD(v10) = 0;
    }
    if (!a3)
      return *(unsigned int *)(a1 + 616);
LABEL_16:
    *a3 = v10;
    return *(unsigned int *)(a1 + 616);
  }
  if (a2)
  {
    if (a4)
    {
      v12 = (const char *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 8))(1, a1);
      *a2 = v12;
      if (v12)
        *v12 = 0;
    }
    else
    {
      *a2 = "";
    }
  }
  result = 0;
  if (a3)
    *a3 = 0;
  return result;
}

uint64_t libssh2_session_last_errno(uint64_t a1)
{
  return *(unsigned int *)(a1 + 616);
}

uint64_t libssh2_session_set_last_error(uint64_t a1, uint64_t a2, char *a3)
{
  return _libssh2_error_flags(a1, a2, a3, 1);
}

uint64_t libssh2_session_flag(_DWORD *a1, int a2, int a3)
{
  _DWORD *v3;
  uint64_t result;

  switch(a2)
  {
    case 3:
      v3 = a1 + 35;
      goto LABEL_7;
    case 2:
      v3 = a1 + 34;
      goto LABEL_7;
    case 1:
      v3 = a1 + 33;
LABEL_7:
      result = 0;
      *v3 = a3;
      return result;
  }
  return 4294967262;
}

uint64_t _libssh2_session_set_blocking(uint64_t a1, int a2)
{
  uint64_t v2;

  v2 = *(unsigned int *)(a1 + 172);
  *(_DWORD *)(a1 + 172) = a2;
  return v2;
}

uint64_t libssh2_session_set_blocking(uint64_t result, int a2)
{
  *(_DWORD *)(result + 172) = a2;
  return result;
}

uint64_t libssh2_session_get_blocking(uint64_t a1)
{
  return *(unsigned int *)(a1 + 172);
}

uint64_t libssh2_session_set_timeout(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 176) = a2;
  return result;
}

uint64_t libssh2_session_get_timeout(uint64_t a1)
{
  return *(_QWORD *)(a1 + 176);
}

uint64_t libssh2_session_set_read_timeout(uint64_t result, uint64_t a2)
{
  uint64_t v2;

  v2 = 60;
  if (a2 >= 1)
    v2 = a2;
  *(_QWORD *)(result + 73576) = v2;
  return result;
}

uint64_t libssh2_session_get_read_timeout(uint64_t a1)
{
  return *(_QWORD *)(a1 + 73576);
}

uint64_t libssh2_poll_channel_read(uint64_t a1, int a2)
{
  uint64_t v4;
  uint64_t result;
  uint64_t v6;
  int v7;
  int v8;

  if (!a1)
    return 4294967257;
  v4 = *(_QWORD *)(a1 + 104);
  result = _libssh2_list_first(v4 + 536);
  if (result)
  {
    v6 = result;
    do
    {
      if (*(_QWORD *)(v6 + 32) <= 4uLL)
        return _libssh2_error(v4, 4294967258, "Packet too small");
      v7 = *(_DWORD *)(a1 + 48);
      if (v7 == _libssh2_ntohu32((unsigned int *)(*(_QWORD *)(v6 + 24) + 1)))
      {
        if (a2)
        {
          if (a2 != 1)
            goto LABEL_11;
          v8 = **(_BYTE **)(v6 + 24) & 0xFE;
        }
        else
        {
          v8 = **(unsigned __int8 **)(v6 + 24);
        }
        if (v8 == 94)
          return 1;
      }
LABEL_11:
      result = _libssh2_list_next(v6);
      v6 = result;
    }
    while (result);
  }
  return result;
}

uint64_t libssh2_poll(uint64_t a1, unsigned int a2, uint64_t a3)
{
  int v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t i;
  int v9;
  uint64_t v10;
  int v11;
  int v12;
  int v13;
  uint64_t v14;
  int v15;
  unsigned int v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t *v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  uint64_t v23;
  uint64_t v24;
  int v25;
  int v26;
  __darwin_time_t v27;
  __darwin_suseconds_t tv_usec;
  __darwin_suseconds_t v29;
  uint64_t v30;
  int v31;
  uint64_t v32;
  int *v33;
  int v34;
  int v35;
  int v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  int v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  int v44;
  BOOL v45;
  int v47;
  __darwin_time_t tv_sec;
  timeval v50;
  timeval v51;
  timeval v52;
  fd_set v53;
  fd_set v54;

  v52.tv_sec = 0;
  *(_QWORD *)&v52.tv_usec = 0;
  memset(&v54, 0, sizeof(v54));
  memset(&v53, 0, sizeof(v53));
  v5 = 0;
  if (a2)
  {
    v6 = 0;
    v7 = (_QWORD *)(a1 + 16);
    for (i = a2; i; --i)
    {
      v7[1] = 0;
      v9 = *((unsigned __int8 *)v7 - 16);
      switch(v9)
      {
        case 3:
          v13 = *(_DWORD *)(*(_QWORD *)(*(v7 - 1) + 24) + 592);
          if (__darwin_check_fd_set_overflow(v13, &v54, 0))
            *(__int32_t *)((char *)v54.fds_bits + (((unint64_t)v13 >> 3) & 0x1FFFFFFFFFFFFFFCLL)) |= 1 << v13;
          v14 = *(_QWORD *)(*(v7 - 1) + 24);
          break;
        case 2:
          v15 = *(_DWORD *)(*(_QWORD *)(*(v7 - 1) + 104) + 592);
          if (__darwin_check_fd_set_overflow(v15, &v54, 0))
            *(__int32_t *)((char *)v54.fds_bits + (((unint64_t)v15 >> 3) & 0x1FFFFFFFFFFFFFFCLL)) |= 1 << v15;
          v14 = *(_QWORD *)(*(v7 - 1) + 104);
          break;
        case 1:
          v10 = *v7;
          if ((*v7 & 1) != 0)
          {
            v11 = *((_DWORD *)v7 - 2);
            if (__darwin_check_fd_set_overflow(v11, &v54, 0))
              *(__int32_t *)((char *)v54.fds_bits + (((unint64_t)v11 >> 3) & 0x1FFFFFFFFFFFFFFCLL)) |= 1 << v11;
            if (*((_DWORD *)v7 - 2) > v5)
              v5 = *((_DWORD *)v7 - 2);
            v10 = *v7;
          }
          if ((v10 & 4) != 0)
          {
            v12 = *((_DWORD *)v7 - 2);
            if (__darwin_check_fd_set_overflow(v12, &v53, 0))
              *(__int32_t *)((char *)v53.fds_bits + (((unint64_t)v12 >> 3) & 0x1FFFFFFFFFFFFFFCLL)) |= 1 << v12;
            if (*((_DWORD *)v7 - 2) > v5)
              v5 = *((_DWORD *)v7 - 2);
          }
          goto LABEL_28;
        default:
          if (v6)
            _libssh2_error(v6, 4294967261, "Invalid descriptor passed to libssh2_poll()");
          return 0xFFFFFFFFLL;
      }
      if (*(_DWORD *)(v14 + 592) > v5)
        v5 = *(_DWORD *)(v14 + 592);
      if (!v6)
        v6 = v14;
LABEL_28:
      v7 += 4;
    }
  }
  v47 = v5 + 1;
  v16 = a2;
  do
  {
    v17 = 0;
    if (!v16)
      goto LABEL_61;
    v18 = a2;
    v19 = (uint64_t *)(a1 + 24);
    do
    {
      v21 = *(v19 - 1);
      v20 = *v19;
      if (v21 == *v19)
        goto LABEL_55;
      v22 = *((unsigned __int8 *)v19 - 24);
      if (v22 == 3)
      {
        if ((v21 & 1) != 0 && (v20 & 1) == 0)
        {
          v20 = *v19 | (_libssh2_list_first(*(v19 - 2) + 48) != 0);
          *v19 = v20;
        }
        v24 = *(_QWORD *)(*(v19 - 2) + 24);
      }
      else
      {
        if (v22 != 2)
        {
          v21 = *v19;
          goto LABEL_55;
        }
        if ((v21 & 1) != 0 && (v20 & 1) == 0)
        {
          v20 = *v19 | (libssh2_poll_channel_read(*(v19 - 2), 0) != 0);
          *v19 = v20;
          v21 = *(v19 - 1);
        }
        if ((v21 & 2) != 0 && (v20 & 2) == 0)
        {
          v20 = *v19 | (2 * (libssh2_poll_channel_read(*(v19 - 2), 1) != 0));
          *v19 = v20;
          v21 = *(v19 - 1);
        }
        if ((v21 & 4) != 0 && (v20 & 4) == 0)
        {
          v20 |= 4 * (*(_DWORD *)(*(v19 - 2) + 56) != 0);
          *v19 = v20;
        }
        v23 = *(v19 - 2);
        if (*(_BYTE *)(v23 + 84) || *(_BYTE *)(v23 + 64))
        {
          v20 |= 0x80uLL;
          *v19 = v20;
        }
        v24 = *(_QWORD *)(v23 + 104);
      }
      v25 = *(_DWORD *)(v24 + 596);
      v21 = v20;
      if (v25 == -1)
      {
        *v19 = v20 | 0x90;
        v21 = 1;
      }
LABEL_55:
      if (v21)
        v17 = (v17 + 1);
      else
        v17 = v17;
      v19 += 4;
      --v18;
    }
    while (v18);
    if ((_DWORD)v17)
      a3 = 0;
LABEL_61:
    *(_QWORD *)&v51.tv_usec = 0;
    v52.tv_sec = a3 / 1000;
    v52.tv_usec = 1000 * (a3 % 1000);
    *(_QWORD *)&v50.tv_usec = 0;
    v51.tv_sec = 0;
    v50.tv_sec = 0;
    gettimeofday(&v51, 0);
    v26 = select(v47, &v54, &v53, 0, &v52);
    gettimeofday(&v50, 0);
    tv_sec = v50.tv_sec;
    v27 = v51.tv_sec;
    tv_usec = v50.tv_usec;
    v29 = v51.tv_usec;
    if (v26 >= 1 && v16)
    {
      v30 = 0;
      do
      {
        v31 = *(unsigned __int8 *)(a1 + 32 * v30);
        switch(v31)
        {
          case 3:
            v37 = a1 + 32 * v30;
            v39 = *(_QWORD *)(v37 + 8);
            v38 = v37 + 8;
            v40 = *(_DWORD *)(*(_QWORD *)(v39 + 24) + 592);
            if (__darwin_check_fd_set_overflow(v40, &v54, 0)
              && ((*(unsigned int *)((char *)v54.fds_bits + (((unint64_t)v40 >> 3) & 0x1FFFFFFFFFFFFFFCLL)) >> v40) & 1) != 0)
            {
              while ((int)_libssh2_transport_read(*(_QWORD *)(*(_QWORD *)v38 + 24)) > 0)
                ;
            }
            break;
          case 2:
            v41 = a1 + 32 * v30;
            v43 = *(_QWORD *)(v41 + 8);
            v42 = v41 + 8;
            v44 = *(_DWORD *)(*(_QWORD *)(v43 + 104) + 592);
            if (__darwin_check_fd_set_overflow(v44, &v54, 0)
              && ((*(unsigned int *)((char *)v54.fds_bits + (((unint64_t)v44 >> 3) & 0x1FFFFFFFFFFFFFFCLL)) >> v44) & 1) != 0)
            {
              while ((int)_libssh2_transport_read(*(_QWORD *)(*(_QWORD *)v42 + 104)) > 0)
                ;
            }
            break;
          case 1:
            v32 = a1 + 32 * v30;
            v35 = *(_DWORD *)(v32 + 8);
            v33 = (int *)(v32 + 8);
            v34 = v35;
            if (__darwin_check_fd_set_overflow(v35, &v54, 0)
              && ((*(unsigned int *)((char *)v54.fds_bits + (((unint64_t)v34 >> 3) & 0x1FFFFFFFFFFFFFFCLL)) >> v34) & 1) != 0)
            {
              *(_QWORD *)(a1 + 32 * v30 + 24) |= 1uLL;
            }
            v36 = *v33;
            if (__darwin_check_fd_set_overflow(*v33, &v53, 0)
              && ((*(unsigned int *)((char *)v53.fds_bits + (((unint64_t)v36 >> 3) & 0x1FFFFFFFFFFFFFFCLL)) >> v36) & 1) != 0)
            {
              *(_QWORD *)(a1 + 32 * v30 + 24) |= 4uLL;
            }
            if (*(_QWORD *)(a1 + 32 * v30 + 24))
              v17 = (v17 + 1);
            else
              v17 = v17;
            break;
        }
        ++v30;
      }
      while (v30 != a2);
    }
    a3 = a3 - 1000 * (tv_sec - v27) + (tv_usec - v29) / -1000;
    v45 = a3 >= 1 && (_DWORD)v17 == 0;
    v16 = a2;
  }
  while (v45);
  return v17;
}

uint64_t libssh2_session_banner_get(uint64_t result)
{
  if (result)
    return *(_QWORD *)(result + 312);
  return result;
}

char ***_libssh2_comp_methods(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 136))
    return &comp_methods;
  else
    return &no_comp_methods;
}

uint64_t comp_method_none_comp()
{
  return 0;
}

uint64_t comp_method_none_decomp(uint64_t a1, _QWORD *a2, _QWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  *a2 = a5;
  *a3 = a6;
  return 0;
}

uint64_t libssh2_userauth_list(uint64_t a1, const void *a2, unsigned int a3)
{
  uint64_t v5;
  time_t v6;
  size_t v7;
  size_t *v8;
  void **v9;
  int v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  char *v17;
  char *v18;
  uint64_t result;
  size_t v20;
  char *v21;
  int v22;
  unsigned int v23;
  size_t v24;
  void *v25;
  unsigned int v26;
  uint64_t v27;
  _DWORD *v29;
  int v30;

  v5 = a1 + 72048;
  v6 = time(0);
  v7 = a3 + 27;
  v8 = (size_t *)(a1 + 72064);
  v9 = (void **)(a1 + 72056);
  do
  {
    v30 = 3486516;
    v29 = 0;
    v10 = *(_DWORD *)v5;
    if (*(_DWORD *)v5 == 3)
      goto LABEL_13;
    if (v10 == 2)
      goto LABEL_7;
    if (v10)
      goto LABEL_36;
    *(_QWORD *)(a1 + 72080) = 0;
    *v8 = v7;
    v11 = (*(uint64_t (**)(size_t, uint64_t))(a1 + 8))(v7, a1);
    *v9 = (void *)v11;
    if (v11)
    {
      v29 = (_DWORD *)(v11 + 1);
      *(_BYTE *)v11 = 50;
      _libssh2_store_str(&v29, a2, a3);
      _libssh2_store_str(&v29, "ssh-connection", 0xEuLL);
      _libssh2_store_u32(&v29, 4u);
      *(_DWORD *)v5 = 2;
LABEL_7:
      v12 = _libssh2_transport_send(a1, *v9, *v8, "none", 4uLL);
      if (v12 == -37)
      {
        v13 = a1;
        v14 = 4294967259;
      }
      else
      {
        v15 = v12;
        (*(void (**)(void *, uint64_t))(a1 + 24))(*v9, a1);
        *v9 = 0;
        if (v15)
        {
          v16 = a1;
          v14 = 4294967289;
          v17 = "Unable to send userauth-none request";
          goto LABEL_30;
        }
        *(_DWORD *)v5 = 3;
LABEL_13:
        v14 = _libssh2_packet_requirev(a1, (char *)&v30, (_QWORD *)(a1 + 72056), (unint64_t *)(a1 + 72064), 0, 0, 0, (time_t *)(a1 + 72080));
        if (!(_DWORD)v14)
        {
          v20 = *v8;
          if (!*v8)
            goto LABEL_29;
          v21 = (char *)*v9;
          v22 = *(unsigned __int8 *)*v9;
          if (v22 != 53)
            goto LABEL_27;
          if (v20 <= 4)
            goto LABEL_33;
          v23 = _libssh2_ntohu32((unsigned int *)(v21 + 1));
          if (*v8 - 5 < v23)
          {
            (*(void (**)(void *, uint64_t))(a1 + 24))(*v9, a1);
            *v9 = 0;
            v13 = a1;
            v14 = 4294967255;
            v18 = "Unexpected userauth banner size";
            goto LABEL_17;
          }
          v24 = v23;
          v25 = (void *)(*(uint64_t (**)(_QWORD, uint64_t))(a1 + 8))(v23 + 1, a1);
          *(_QWORD *)(v5 + 24) = v25;
          if (!v25)
          {
            (*(void (**)(void *, uint64_t))(a1 + 24))(*v9, a1);
            *v9 = 0;
            v13 = a1;
            v14 = 4294967290;
            v18 = "Unable to allocate memory for userauth_banner";
            goto LABEL_17;
          }
          memcpy(v25, (const void *)(*(_QWORD *)(v5 + 8) + 5), v24);
          *(_BYTE *)(*(_QWORD *)(v5 + 24) + v24) = 0;
          (*(void (**)(_QWORD, uint64_t))(a1 + 24))(*(_QWORD *)(v5 + 8), a1);
          *(_QWORD *)(v5 + 8) = 0;
          BYTE2(v30) = 0;
          v14 = _libssh2_packet_requirev(a1, (char *)&v30, (_QWORD *)(a1 + 72056), (unint64_t *)(a1 + 72064), 0, 0, 0, (time_t *)(a1 + 72080));
          if (!(_DWORD)v14)
          {
            v20 = *v8;
            if (*v8)
            {
              v21 = (char *)*v9;
              v22 = *(unsigned __int8 *)*v9;
LABEL_27:
              if (v22 != 52)
              {
                if (v20 > 4)
                {
                  v26 = _libssh2_ntohu32((unsigned int *)(v21 + 1));
                  if (*v8 - 5 > v26)
                  {
                    v27 = v26;
                    memmove(*v9, (char *)*v9 + 5, v26);
                    *((_BYTE *)*v9 + v27) = 0;
LABEL_36:
                    *(_DWORD *)v5 = 0;
                    result = *(_QWORD *)(v5 + 8);
                    goto LABEL_37;
                  }
                  v13 = a1;
                  v14 = 4294967255;
                  v18 = "Unexpected userauth list size";
                  goto LABEL_17;
                }
LABEL_33:
                (*(void (**)(void))(a1 + 24))();
                *v9 = 0;
                v13 = a1;
                v14 = 4294967282;
                v18 = "Unexpected packet size";
                goto LABEL_17;
              }
              _libssh2_error(a1, 0, "No error");
              (*(void (**)(_QWORD, uint64_t))(a1 + 24))(*(_QWORD *)(v5 + 8), a1);
              result = 0;
              *(_QWORD *)(v5 + 8) = 0;
              *(_DWORD *)(a1 + 128) |= 4u;
LABEL_31:
              *(_DWORD *)v5 = 0;
              goto LABEL_37;
            }
LABEL_29:
            v16 = a1;
            v17 = "Failed getting response";
LABEL_30:
            _libssh2_error(v16, v14, v17);
            result = 0;
            goto LABEL_31;
          }
        }
        if ((_DWORD)v14 != -37)
          goto LABEL_29;
        v13 = a1;
      }
      v18 = "Would block requesting userauth list";
      goto LABEL_17;
    }
    v13 = a1;
    v14 = 4294967290;
    v18 = "Unable to allocate memory for userauth_list";
LABEL_17:
    _libssh2_error(v13, v14, v18);
    result = 0;
LABEL_37:
    if (!*(_DWORD *)(a1 + 172) || result)
      return result;
  }
  while (libssh2_session_last_errno(a1) == -37 && !_libssh2_wait_socket(a1, v6));
  return 0;
}

uint64_t libssh2_userauth_banner(uint64_t a1, _QWORD *a2)
{
  uint64_t v2;
  uint64_t result;

  if (!a1)
    return 4294967246;
  v2 = *(_QWORD *)(a1 + 72072);
  if (!v2)
    return _libssh2_error(a1, 4294967246, "Missing userauth banner");
  result = 0;
  if (a2)
    *a2 = v2;
  return result;
}

uint64_t libssh2_userauth_authenticated(uint64_t a1)
{
  return (*(_DWORD *)(a1 + 128) >> 2) & 1;
}

uint64_t libssh2_userauth_password_ex(uint64_t a1, const void *a2, unsigned int a3, const void *a4, unsigned int a5, void (*a6)(uint64_t, const void **, int *, uint64_t))
{
  uint64_t v10;
  time_t v11;
  uint64_t v12;
  size_t *v13;
  void **v14;
  size_t v15;
  int v16;
  uint64_t v17;
  _BYTE *v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  char *v22;
  uint64_t v23;
  _BYTE *v24;
  int v25;
  int v26;
  _DWORD *v27;
  _BYTE *v28;
  uint64_t result;
  int v30;
  uint64_t v31;
  uint64_t v32;
  char *v33;
  int v34;
  unsigned int v35;
  size_t v36;
  int *v37;
  const void **v38;
  unint64_t v40;
  _DWORD *v42;

  v10 = a1 + 72088;
  v11 = time(0);
  v12 = a3 + 40;
  v13 = (size_t *)(a1 + 72112);
  v14 = (void **)(a1 + 72096);
  v40 = a3;
  v15 = a5;
  v37 = (int *)(a1 + 72128);
  v38 = (const void **)(a1 + 72120);
  v36 = a3 + a5 + 44;
  while (1)
  {
    v42 = 0;
    v16 = *(_DWORD *)v10;
    if (*(_DWORD *)v10 == 2)
      goto LABEL_6;
    if (!v16)
    {
      *(_QWORD *)(v10 + 48) = 0;
      *(_QWORD *)(v10 + 24) = v12;
      *(_BYTE *)(v10 + 16) = -61;
      v17 = (*(uint64_t (**)(uint64_t, uint64_t))(a1 + 8))(v12, a1);
      *(_QWORD *)(v10 + 8) = v17;
      if (v17)
      {
        v42 = (_DWORD *)(v17 + 1);
        *(_BYTE *)v17 = 50;
        _libssh2_store_str(&v42, a2, v40);
        _libssh2_store_str(&v42, "ssh-connection", 0xEuLL);
        _libssh2_store_str(&v42, "password", 8uLL);
        v18 = v42;
        v42 = (_DWORD *)((char *)v42 + 1);
        *v18 = 0;
        _libssh2_store_u32(&v42, a5);
        *(_DWORD *)v10 = 2;
LABEL_6:
        v19 = _libssh2_transport_send(a1, *v14, *v13, a4, v15);
        if (v19 == -37)
        {
          v20 = a1;
          v21 = 4294967259;
          v22 = "Would block writing password request";
        }
        else
        {
          v26 = v19;
          (*(void (**)(void *, uint64_t))(a1 + 24))(*v14, a1);
          *v14 = 0;
          if (!v26)
            goto LABEL_47;
          *(_DWORD *)v10 = 0;
          v20 = a1;
          v21 = 4294967289;
          v22 = "Unable to send userauth-password request";
        }
      }
      else
      {
        v20 = a1;
        v21 = 4294967290;
        v22 = "Unable to allocate memory for userauth-password request";
      }
LABEL_36:
      result = _libssh2_error(v20, v21, v22);
      goto LABEL_37;
    }
    if ((v16 - 3) >= 3)
    {
      v24 = *v14;
LABEL_19:
      (*(void (**)(_BYTE *, uint64_t))(a1 + 24))(v24, a1);
      *(_QWORD *)(v10 + 8) = 0;
      *(_DWORD *)v10 = 0;
      v20 = a1;
      v21 = 4294967278;
      v22 = "Authentication failed";
      goto LABEL_36;
    }
    while (1)
    {
      if (v16 == 3)
      {
        v23 = _libssh2_packet_requirev(a1, "43<", (_QWORD *)(a1 + 72096), (unint64_t *)(a1 + 72112), 0, 0, 0, (time_t *)(a1 + 72136));
        v21 = v23;
        if ((_DWORD)v23 == -37)
          goto LABEL_35;
        if ((_DWORD)v23)
        {
          *(_DWORD *)v10 = 0;
LABEL_35:
          v20 = a1;
          v22 = "Waiting for password response";
          goto LABEL_36;
        }
        if (!*v13)
          goto LABEL_33;
        v24 = *v14;
        v25 = *(unsigned __int8 *)*v14;
        if (v25 == 51)
        {
          (*(void (**)(void *, uint64_t))(a1 + 24))(*v14, a1);
          *(_QWORD *)(v10 + 8) = 0;
          *(_DWORD *)v10 = 0;
          v20 = a1;
          v21 = 4294967278;
          v22 = "Authentication failed (username/password)";
          goto LABEL_36;
        }
        if (v25 == 52)
        {
          (*(void (**)(void *, uint64_t))(a1 + 24))(*v14, a1);
          result = 0;
          *(_QWORD *)(v10 + 8) = 0;
          *(_DWORD *)(a1 + 128) |= 4u;
          *(_DWORD *)v10 = 0;
          return result;
        }
        *(_QWORD *)(v10 + 32) = 0;
        *(_DWORD *)(v10 + 40) = 0;
        v16 = 4;
        *(_DWORD *)v10 = 4;
      }
      else
      {
        if (!*v13)
        {
LABEL_33:
          *(_DWORD *)v10 = 0;
          v20 = a1;
          v21 = 4294967282;
          v22 = "Unexpected packet size";
          goto LABEL_36;
        }
        v24 = *v14;
      }
      if (*v24 != 60 && *(_BYTE *)(v10 + 16) != 60)
        goto LABEL_19;
      *(_BYTE *)(v10 + 16) = 60;
      if (v16 == 4)
      {
        (*(void (**)(_BYTE *, uint64_t))(a1 + 24))(v24, a1);
        v24 = 0;
        *v14 = 0;
      }
      if (!a6)
        goto LABEL_19;
      if (*(_DWORD *)v10 == 5)
      {
        v35 = a5;
      }
      else
      {
        if (*(_DWORD *)v10 != 4)
          goto LABEL_19;
        a6(a1, v38, v37, a1);
        if (!*v38)
        {
          v20 = a1;
          v21 = 4294967281;
          v22 = "Password expired, and callback failed";
          goto LABEL_36;
        }
        v35 = a5;
        *v13 = v36;
        v27 = (_DWORD *)(*(uint64_t (**)(void))(a1 + 8))();
        *v14 = v27;
        v42 = v27;
        if (!v27)
        {
          (*(void (**)(const void *, uint64_t))(a1 + 24))(*v38, a1);
          *v38 = 0;
          v31 = a1;
          v32 = 4294967290;
          v33 = "Unable to allocate memory for userauth password change request";
          goto LABEL_50;
        }
        v42 = (_DWORD *)((char *)v27 + 1);
        *(_BYTE *)v27 = 50;
        _libssh2_store_str(&v42, a2, v40);
        _libssh2_store_str(&v42, "ssh-connection", 0xEuLL);
        _libssh2_store_str(&v42, "password", 8uLL);
        v28 = v42;
        v42 = (_DWORD *)((char *)v42 + 1);
        *v28 = 1;
        _libssh2_store_str(&v42, a4, v15);
        _libssh2_store_u32(&v42, *(_DWORD *)(v10 + 40));
        *(_DWORD *)v10 = 5;
        v24 = *(_BYTE **)(v10 + 8);
      }
      v30 = _libssh2_transport_send(a1, v24, *v13, *v38, *v37);
      if (v30 == -37)
        break;
      v34 = v30;
      (*(void (**)(void *, uint64_t))(a1 + 24))(*v14, a1);
      *v14 = 0;
      (*(void (**)(const void *, uint64_t))(a1 + 24))(*v38, a1);
      *v38 = 0;
      a5 = v35;
      if (v34)
      {
        v20 = a1;
        v21 = 4294967289;
        v22 = "Unable to send userauth password-change request";
        goto LABEL_36;
      }
LABEL_47:
      v16 = 3;
      *(_DWORD *)v10 = 3;
    }
    v31 = a1;
    v32 = 4294967259;
    v33 = "Would block waiting";
LABEL_50:
    result = _libssh2_error(v31, v32, v33);
    a5 = v35;
LABEL_37:
    if ((_DWORD)result != -37)
      return result;
    if (!*(_DWORD *)(a1 + 172))
      return 4294967259;
    result = _libssh2_wait_socket(a1, v11);
    if ((_DWORD)result)
      return result;
  }
}

uint64_t libssh2_sign_sk(uint64_t a1, _QWORD *a2, _QWORD *a3, uint64_t a4, uint64_t a5, unsigned int **a6)
{
  unsigned int *v6;
  uint64_t v7;
  uint64_t v11;
  BOOL v12;
  uint64_t v14;
  _DWORD *v15;
  char *v16;
  _DWORD *v17;
  _DWORD *v19;
  _DWORD *v20;
  __int128 v21;
  __int128 v22;
  uint64_t v23;

  v6 = *a6;
  v23 = 0;
  v21 = 0u;
  v22 = 0u;
  v7 = *((_QWORD *)v6 + 3);
  if (!v7)
    return 4294967284;
  v11 = (*((uint64_t (**)(uint64_t, __int128 *, uint64_t, uint64_t, _QWORD, _QWORD, _QWORD, _QWORD, uint64_t, _QWORD))v6
         + 4))(a1, &v21, a4, a5, *v6, *((unsigned __int8 *)v6 + 4), *((_QWORD *)v6 + 1), *((_QWORD *)v6 + 2), v7, *((_QWORD *)v6 + 5));
  if ((_DWORD)v11)
    v12 = 1;
  else
    v12 = (_QWORD)v22 == 0;
  if (v12 || *((_QWORD *)&v21 + 1) == 0)
  {
    v14 = v11;
    *a3 = 0;
    return v14;
  }
  v20 = 0;
  if (!v23 || !*((_QWORD *)&v22 + 1))
  {
    *a3 = v22 + 9;
    v17 = (_DWORD *)(*(uint64_t (**)(void))(a1 + 8))();
    *a2 = v17;
    if (v17)
    {
      v20 = v17;
      _libssh2_store_str(&v20, *((const void **)&v21 + 1), v22);
      goto LABEL_18;
    }
LABEL_19:
    v14 = 4294967290;
    goto LABEL_20;
  }
  *a3 = v22 + v23 + 19;
  v15 = (_DWORD *)(*(uint64_t (**)(void))(a1 + 8))();
  *a2 = v15;
  if (!v15)
    goto LABEL_19;
  v19 = v15;
  v20 = v15;
  _libssh2_store_u32(&v20, 0);
  _libssh2_store_bignum2_bytes(&v20, *((_BYTE **)&v21 + 1), v22);
  _libssh2_store_bignum2_bytes(&v20, *((_BYTE **)&v22 + 1), v23);
  v16 = (char *)v20 - *a2;
  *a3 = v16;
  _libssh2_store_u32(&v19, (_DWORD)v16 - 4);
LABEL_18:
  v14 = 0;
LABEL_20:
  if (v20)
  {
    *(_BYTE *)v20 = v21;
    v20 = (_DWORD *)((char *)v20 + 1);
    _libssh2_store_u32(&v20, DWORD1(v21));
    *a3 = (char *)v20 - *a2;
  }
  (*(void (**)(_QWORD, uint64_t))(a1 + 24))(*((_QWORD *)&v21 + 1), a1);
  if (*((_QWORD *)&v22 + 1))
    (*(void (**)(_QWORD, uint64_t))(a1 + 24))(*((_QWORD *)&v22 + 1), a1);
  return v14;
}

uint64_t libssh2_userauth_hostbased_fromfile_ex(uint64_t a1, const void *a2, unsigned int a3, char *a4, char *a5, void *a6, const void *a7, unsigned int a8, const void *a9, unsigned int a10)
{
  uint64_t v14;
  time_t v15;
  unint64_t v16;
  const void **v17;
  unint64_t *v18;
  _QWORD *v19;
  int v20;
  char **v21;
  size_t *v22;
  uint64_t v23;
  _BYTE *v24;
  uint64_t v25;
  uint64_t v26;
  char *v27;
  uint64_t v28;
  uint64_t v29;
  char *v30;
  char *v31;
  _BYTE *v32;
  uint64_t v33;
  unint64_t v34;
  unint64_t v35;
  char **v36;
  char *v37;
  char *v38;
  char *v39;
  int v40;
  uint64_t v41;
  unint64_t v42;
  int v43;
  int v44;
  uint64_t v45;
  unint64_t v47;
  unint64_t v48;
  unint64_t v51;
  int v54;
  uint64_t v55;
  unint64_t v56;
  char *v57;
  const void *v58;
  const void *v59;
  char **v60;
  unint64_t v61[10];

  v61[8] = *MEMORY[0x24BDAC8D0];
  v14 = a1 + 72144;
  v15 = time(0);
  v16 = a8;
  v17 = (const void **)(a1 + 72184);
  v18 = (unint64_t *)(a1 + 72192);
  v47 = v16;
  v48 = a3;
  v51 = v16 + a3 + a10;
  v19 = (_QWORD *)(a1 + 72152);
  while (1)
  {
    v20 = *(_DWORD *)v14;
    if (*(_DWORD *)v14 == 3)
      goto LABEL_32;
    if (v20 == 2)
      goto LABEL_28;
    if (v20)
    {
      v24 = (_BYTE *)*v19;
      goto LABEL_8;
    }
    v59 = 0;
    v60 = 0;
    v57 = 0;
    v58 = 0;
    v55 = 0;
    v56 = 0;
    *(_QWORD *)(a1 + 72208) = 0;
    v21 = (char **)(a1 + 72184);
    v22 = (size_t *)(a1 + 72192);
    if (a4)
      v23 = file_read_publickey(a1, v21, v22, &v59, &v57, a4);
    else
      v23 = _libssh2_pub_priv_keyfile(a1, (uint64_t *)v21, v22, &v59, &v57, a5, a6);
    v28 = v23;
    if (!(_DWORD)v23)
    {
      v29 = *(_QWORD *)(v14 + 48);
      v30 = v57;
      v31 = &v57[v51 + v29];
      *(_QWORD *)(v14 + 32) = v31 + 52;
      v32 = (_BYTE *)(*(uint64_t (**)(char *, uint64_t))(a1 + 8))(&v30[v29 + 64 + (_QWORD)v31], a1);
      *(_QWORD *)(v14 + 24) = v32;
      *(_QWORD *)(v14 + 56) = v32;
      if (!v32)
      {
        (*(void (**)(const void *, uint64_t))(a1 + 24))(*v17, a1);
        *v17 = 0;
        (*(void (**)(const void *, uint64_t))(a1 + 24))(v59, a1);
        v25 = a1;
        v26 = 4294967290;
        v27 = "Out of memory";
        goto LABEL_39;
      }
      *(_QWORD *)(a1 + 72200) = v32 + 1;
      *v32 = 50;
      _libssh2_store_str((_DWORD **)(a1 + 72200), a2, v48);
      _libssh2_store_str((_DWORD **)(a1 + 72200), "ssh-connection", 0xEuLL);
      _libssh2_store_str((_DWORD **)(a1 + 72200), "hostbased", 9uLL);
      _libssh2_store_str((_DWORD **)(a1 + 72200), *v17, *v18);
      _libssh2_store_str((_DWORD **)(a1 + 72200), v59, (unint64_t)v57);
      (*(void (**)(const void *, uint64_t))(a1 + 24))(v59, a1);
      _libssh2_store_str((_DWORD **)(a1 + 72200), a7, v47);
      _libssh2_store_str((_DWORD **)(a1 + 72200), a9, a10);
      v33 = file_read_privatekey(a1, &v60, &v55, (const char *)*v17, *v18, (uint64_t)a5, (uint64_t)a6);
      if ((_DWORD)v33)
      {
        v28 = v33;
        (*(void (**)(_QWORD, uint64_t))(a1 + 24))(*(_QWORD *)(v14 + 40), a1);
        *(_QWORD *)(v14 + 40) = 0;
        (*(void (**)(_QWORD, uint64_t))(a1 + 24))(*(_QWORD *)(v14 + 24), a1);
        *(_QWORD *)(v14 + 24) = 0;
        goto LABEL_40;
      }
      _libssh2_htonu32(&v54, *(_DWORD *)(a1 + 168));
      v61[0] = (unint64_t)&v54;
      v61[1] = 4;
      v34 = *(unsigned int *)(a1 + 168);
      v61[2] = *(_QWORD *)(a1 + 160);
      v61[3] = v34;
      v35 = *(_QWORD *)(v14 + 32);
      v61[4] = *(_QWORD *)(v14 + 24);
      v61[5] = v35;
      v36 = v60;
      if (!v60)
        goto LABEL_23;
      v37 = v60[6];
      if (!v37
        || !((unsigned int (*)(uint64_t, const void **, unint64_t *, uint64_t, unint64_t *, uint64_t *))v37)(a1, &v58, &v56, 3, v61, &v55))
      {
        v39 = v36[8];
        if (v39)
          ((void (*)(uint64_t, uint64_t *))v39)(a1, &v55);
LABEL_23:
        v40 = v56;
        v41 = *(_QWORD *)(v14 + 24);
        if (v56 > (unint64_t)v57)
        {
          v42 = v56 + *(_QWORD *)(v14 + 32) + *(_QWORD *)(v14 + 48) + 12;
          if (v41)
          {
            v41 = (*(uint64_t (**)(uint64_t, unint64_t, uint64_t))(a1 + 16))(v41, v42, a1);
            if (v41)
              goto LABEL_26;
LABEL_45:
            (*(void (**)(const void *, uint64_t))(a1 + 24))(v58, a1);
            (*(void (**)(_QWORD, uint64_t))(a1 + 24))(*(_QWORD *)(v14 + 24), a1);
            *(_QWORD *)(v14 + 24) = 0;
            (*(void (**)(_QWORD, uint64_t))(a1 + 24))(*(_QWORD *)(v14 + 40), a1);
            *(_QWORD *)(v14 + 40) = 0;
            v25 = a1;
            v26 = 4294967290;
            v27 = "Failed allocating additional space for userauth-hostbased packet";
LABEL_39:
            v28 = _libssh2_error(v25, v26, v27);
            goto LABEL_40;
          }
          v41 = (*(uint64_t (**)(unint64_t, uint64_t))(a1 + 8))(v42, a1);
          if (!v41)
            goto LABEL_45;
LABEL_26:
          *(_QWORD *)(v14 + 24) = v41;
          v40 = v56;
        }
        *(_QWORD *)(v14 + 56) = v41 + *(_QWORD *)(v14 + 32);
        _libssh2_store_u32((_DWORD **)(a1 + 72200), v40 + *(_DWORD *)(v14 + 48) + 8);
        _libssh2_store_str((_DWORD **)(a1 + 72200), *(const void **)(v14 + 40), *(_QWORD *)(v14 + 48));
        (*(void (**)(_QWORD, uint64_t))(a1 + 24))(*(_QWORD *)(v14 + 40), a1);
        *(_QWORD *)(v14 + 40) = 0;
        _libssh2_store_str((_DWORD **)(a1 + 72200), v58, v56);
        (*(void (**)(const void *, uint64_t))(a1 + 24))(v58, a1);
        *(_DWORD *)v14 = 2;
LABEL_28:
        v43 = _libssh2_transport_send(a1, *(void **)(v14 + 24), *(_QWORD *)(v14 + 56) - *(_QWORD *)(v14 + 24), 0, 0);
        if (v43)
        {
          if (v43 != -37)
          {
            (*(void (**)(_QWORD, uint64_t))(a1 + 24))(*(_QWORD *)(v14 + 24), a1);
            *(_QWORD *)(v14 + 24) = 0;
            *(_DWORD *)v14 = 0;
            v25 = a1;
            v26 = 4294967289;
            v27 = "Unable to send userauth-hostbased request";
            goto LABEL_39;
          }
LABEL_33:
          v25 = a1;
          v26 = 4294967259;
          v27 = "Would block";
          goto LABEL_39;
        }
        (*(void (**)(_QWORD, uint64_t))(a1 + 24))(*(_QWORD *)(v14 + 24), a1);
        *(_QWORD *)(v14 + 24) = 0;
        *(_DWORD *)v14 = 3;
LABEL_32:
        v61[0] = 0;
        v44 = _libssh2_packet_requirev(a1, "43", (_QWORD *)(a1 + 72152), v61, 0, 0, 0, (time_t *)(a1 + 72208));
        if (v44 == -37)
          goto LABEL_33;
        *(_DWORD *)v14 = 0;
        if (v44 || !v61[0])
        {
          v25 = a1;
          v26 = 4294967277;
          v27 = "Auth failed";
          goto LABEL_39;
        }
        v24 = (_BYTE *)*v19;
        if (*(_BYTE *)*v19 == 52)
        {
          (*(void (**)(void))(a1 + 24))();
          v28 = 0;
          *v19 = 0;
          *(_DWORD *)(a1 + 128) |= 4u;
          goto LABEL_40;
        }
LABEL_8:
        (*(void (**)(_BYTE *, uint64_t))(a1 + 24))(v24, a1);
        *v19 = 0;
        v25 = a1;
        v26 = 4294967277;
        v27 = "Invalid signature for supplied public key, or bad username/public key combination";
        goto LABEL_39;
      }
      (*(void (**)(_QWORD, uint64_t))(a1 + 24))(*(_QWORD *)(v14 + 40), a1);
      *(_QWORD *)(v14 + 40) = 0;
      (*(void (**)(_QWORD, uint64_t))(a1 + 24))(*(_QWORD *)(v14 + 24), a1);
      *(_QWORD *)(v14 + 24) = 0;
      v38 = v36[8];
      if (v38)
        ((void (*)(uint64_t, uint64_t *))v38)(a1, &v55);
      v28 = 0xFFFFFFFFLL;
    }
LABEL_40:
    if ((_DWORD)v28 != -37)
      return v28;
    if (!*(_DWORD *)(a1 + 172))
      return 4294967259;
    v45 = _libssh2_wait_socket(a1, v15);
    if ((_DWORD)v45)
      return v45;
  }
}

size_t plain_method(char *__s2, size_t __n)
{
  size_t v2;

  v2 = __n;
  if (!strncmp("ssh-rsa-cert-v01@openssh.com", __s2, __n))
    return 7;
  if (!strncmp("ecdsa-sha2-nistp256-cert-v01@openssh.com", __s2, v2)
    || !strncmp("ecdsa-sha2-nistp384-cert-v01@openssh.com", __s2, v2)
    || !strncmp("ecdsa-sha2-nistp521-cert-v01@openssh.com", __s2, v2))
  {
    return 19;
  }
  if (!strncmp("ssh-ed25519-cert-v01@openssh.com", __s2, v2))
    return 11;
  if (!strncmp("sk-ecdsa-sha2-nistp256-cert-v01@openssh.com", __s2, v2))
  {
    qmemcpy(__s2, "sk-ecdsa-sha2-nistp256@openssh.com", 34);
    return 34;
  }
  else if (!strncmp("sk-ssh-ed25519-cert-v01@openssh.com", __s2, v2))
  {
    qmemcpy(__s2, "sk-ssh-ed25519@openssh.com", 26);
    return 26;
  }
  return v2;
}

uint64_t _libssh2_userauth_publickey(uint64_t a1, const void *a2, unint64_t a3, unsigned int *a4, size_t a5, uint64_t (*a6)(uint64_t, const void **, size_t *, char *, int64_t, uint64_t), uint64_t a7)
{
  uint64_t v7;
  size_t v8;
  uint64_t v10;
  time_t *v11;
  _QWORD *v12;
  unint64_t *v13;
  int v14;
  unsigned int v15;
  void *v16;
  const char *v17;
  char *v18;
  size_t v19;
  uint64_t v20;
  char *v21;
  char *v22;
  char *v23;
  char *v24;
  char *v25;
  size_t v26;
  char *v27;
  char *v28;
  char *v29;
  size_t v30;
  char *v31;
  size_t v32;
  char *v33;
  char *v34;
  char *v35;
  char *v36;
  size_t v37;
  char *v38;
  int v39;
  size_t v40;
  char *v41;
  char *v42;
  size_t v43;
  uint64_t v44;
  void *v45;
  uint64_t v46;
  uint64_t v47;
  _DWORD *v48;
  _DWORD *v49;
  int v50;
  int v51;
  int v52;
  _DWORD *v53;
  char *v54;
  int v55;
  char *v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  _DWORD *v60;
  char *v61;
  size_t v62;
  const char *v63;
  int v64;
  int v65;
  int v66;
  time_t *v68;
  _QWORD *v69;
  uint64_t v70;
  void *__src;
  unint64_t v73;
  unint64_t v74;
  unint64_t *v75;
  size_t v78;
  size_t v79;
  unsigned __int8 *v80;
  char v83;
  size_t v84;
  const void *v85;
  _DWORD *v86;
  char v87[12];

  v7 = a7;
  v8 = a5;
  v10 = a1 + 72216;
  *(_DWORD *)v87 = 3945268;
  v86 = 0;
  v11 = (time_t *)(a1 + 72288);
  __src = a4 + 1;
  v73 = a5 - 4;
  v79 = a5 + a3;
  v78 = a5 + 57;
  v12 = (_QWORD *)(a1 + 72224);
  v13 = (unint64_t *)(a1 + 72232);
  v14 = *(_DWORD *)(a1 + 72216);
  v83 = 1;
  while (2)
  {
    switch(v14)
    {
      case 0:
        if (v8 <= 3)
        {
          v56 = "Invalid public key, too short";
          goto LABEL_115;
        }
        *(_QWORD *)(v10 + 72) = 0;
        if (!*(_QWORD *)(v10 + 40))
        {
          v15 = _libssh2_ntohu32(a4);
          *(_QWORD *)(v10 + 48) = v15;
          if (v73 < v15)
          {
            v56 = "Invalid public key";
            goto LABEL_115;
          }
          v16 = (void *)(*(uint64_t (**)(void))(a1 + 8))();
          *(_QWORD *)(v10 + 40) = v16;
          if (!v16)
          {
            v56 = "Unable to allocate memory for public key data";
            goto LABEL_117;
          }
          memcpy(v16, __src, *(_QWORD *)(v10 + 48));
        }
        v74 = v8;
        v75 = v13;
        if ((v83 & 1) == 0)
          goto LABEL_62;
        v17 = _libssh2_supported_key_sign_algorithms(a1, *(_DWORD **)(v10 + 40), *(_QWORD *)(v10 + 48));
        if (!v17 || !*(_QWORD *)(a1 + 296))
          goto LABEL_62;
        v18 = (char *)v17;
        v19 = strlen(v17);
        v20 = (*(uint64_t (**)(size_t, uint64_t))(a1 + 8))(v19 + 1, a1);
        if (!v20)
        {
          v46 = _libssh2_error(a1, 4294967290, "Unable to allocate filtered algs");
          goto LABEL_61;
        }
        v68 = v11;
        v70 = v10;
        v21 = *(char **)(a1 + 296);
        v22 = (char *)v20;
        v23 = (char *)v20;
        if (v21)
        {
          v22 = (char *)v20;
          do
          {
            if (!*v21)
              break;
            v24 = strchr(v21, 44);
            v25 = v24;
            v26 = v24 ? v24 - v21 : strlen(v21);
            v27 = v18;
            do
            {
              if (!*v27)
                break;
              v28 = strchr(v27, 44);
              v29 = v28;
              if (v28)
                v30 = v28 - v27;
              else
                v30 = strlen(v27);
              if (v30 == v26 && !memcmp(v27, v21, v26))
              {
                v31 = v23;
                if (v22 != v23)
                {
                  *v22 = 44;
                  v31 = v22 + 1;
                }
                memcpy(v31, v21, v26);
                v22 = &v31[v26];
              }
              v27 = v29 + 1;
            }
            while (v29);
            v21 = v25 + 1;
          }
          while (v25);
        }
        v69 = v12;
        v32 = 0;
        v33 = 0;
        *v22 = 0;
        if (*(_QWORD *)(a1 + 304))
          v34 = *(char **)(a1 + 304);
        else
          v34 = v18;
        v80 = (unsigned __int8 *)v23;
        break;
      case 2:
LABEL_64:
        v50 = _libssh2_transport_send(a1, *(void **)(v10 + 24), *(_QWORD *)(v10 + 32), 0, 0);
        if (v50)
        {
          if (v50 == -37)
            goto LABEL_103;
          (*(void (**)(_QWORD, uint64_t))(a1 + 24))(*(_QWORD *)(v10 + 24), a1);
          *(_QWORD *)(v10 + 24) = 0;
          (*(void (**)(_QWORD, uint64_t))(a1 + 24))(*(_QWORD *)(v10 + 40), a1);
          *(_QWORD *)(v10 + 40) = 0;
          goto LABEL_110;
        }
        *(_DWORD *)v10 = 3;
LABEL_66:
        v51 = _libssh2_packet_requirev(a1, v87, v12, v13, 0, 0, 0, v11);
        if (v51)
        {
          if (v51 != -37)
          {
LABEL_76:
            (*(void (**)(_QWORD, uint64_t))(a1 + 24))(*(_QWORD *)(v10 + 24), a1);
            *(_QWORD *)(v10 + 24) = 0;
            (*(void (**)(_QWORD, uint64_t))(a1 + 24))(*(_QWORD *)(v10 + 40), a1);
            *(_QWORD *)(v10 + 40) = 0;
            *(_DWORD *)v10 = 0;
            v56 = "Waiting for USERAUTH response";
            goto LABEL_115;
          }
LABEL_103:
          v56 = "Would block";
LABEL_104:
          v57 = a1;
          v58 = 4294967259;
          return _libssh2_error(v57, v58, v56);
        }
        if (!*v13)
          goto LABEL_76;
        v52 = *(unsigned __int8 *)*v12;
        if (v52 == 51)
        {
          (*(void (**)(void))(a1 + 24))();
          *(_QWORD *)(v10 + 8) = 0;
          (*(void (**)(_QWORD, uint64_t))(a1 + 24))(*(_QWORD *)(v10 + 24), a1);
          *(_QWORD *)(v10 + 24) = 0;
          (*(void (**)(_QWORD, uint64_t))(a1 + 24))(*(_QWORD *)(v10 + 40), a1);
          *(_QWORD *)(v10 + 40) = 0;
          *(_DWORD *)v10 = 0;
          v56 = "Username/PublicKey combination invalid";
          v57 = a1;
          v58 = 4294967278;
          return _libssh2_error(v57, v58, v56);
        }
        if (v52 == 52)
        {
          (*(void (**)(void))(a1 + 24))();
          *(_QWORD *)(v10 + 8) = 0;
          (*(void (**)(_QWORD, uint64_t))(a1 + 24))(*(_QWORD *)(v10 + 24), a1);
          *(_QWORD *)(v10 + 24) = 0;
          (*(void (**)(_QWORD, uint64_t))(a1 + 24))(*(_QWORD *)(v10 + 40), a1);
          v46 = 0;
          *(_QWORD *)(v10 + 40) = 0;
LABEL_84:
          *(_DWORD *)(a1 + 128) |= 4u;
          *(_DWORD *)v10 = 0;
          return v46;
        }
        (*(void (**)(void))(a1 + 24))();
        *(_QWORD *)(v10 + 8) = 0;
        **(_BYTE **)(v10 + 64) = 1;
        *(_DWORD *)v10 = 4;
LABEL_71:
        v84 = 0;
        v85 = 0;
        v53 = (_DWORD *)(*(uint64_t (**)(_QWORD, uint64_t))(a1 + 8))(*(_QWORD *)(v10 + 32) + (*(_DWORD *)(a1 + 168) + 4), a1);
        v86 = v53;
        if (!v53)
        {
          v56 = "Unable to allocate memory for userauth-publickey signed data";
          goto LABEL_117;
        }
        v54 = (char *)v53;
        _libssh2_store_str(&v86, *(const void **)(a1 + 160), *(unsigned int *)(a1 + 168));
        memcpy(v86, *(const void **)(v10 + 24), *(_QWORD *)(v10 + 32));
        v86 = (_DWORD *)((char *)v86 + *(_QWORD *)(v10 + 32));
        v55 = a6(a1, &v85, &v84, v54, (char *)v86 - v54, v7);
        (*(void (**)(char *, uint64_t))(a1 + 24))(v54, a1);
        if (v55 == -37)
          goto LABEL_103;
        if ((v83 & (v55 == -51)) == 0)
        {
          if (v55)
          {
            (*(void (**)(_QWORD, uint64_t))(a1 + 24))(*(_QWORD *)(v10 + 40), a1);
            *(_QWORD *)(v10 + 40) = 0;
            (*(void (**)(_QWORD, uint64_t))(a1 + 24))(*(_QWORD *)(v10 + 24), a1);
            *(_QWORD *)(v10 + 24) = 0;
            *(_DWORD *)v10 = 0;
            v56 = "Callback returned error";
            goto LABEL_115;
          }
          v59 = *(_QWORD *)(v10 + 24);
          if (v84 > v8)
          {
            if (v59)
              v59 = (*(uint64_t (**)(uint64_t, size_t, uint64_t))(a1 + 16))(v59, v84 + *(_QWORD *)(v10 + 32) + *(_QWORD *)(v10 + 48) + 12, a1);
            else
              v59 = (*(uint64_t (**)(size_t, uint64_t))(a1 + 8))(v84 + *(_QWORD *)(v10 + 32) + *(_QWORD *)(v10 + 48) + 12, a1);
            if (v59)
            {
              *(_QWORD *)(v10 + 24) = v59;
              goto LABEL_96;
            }
            (*(void (**)(const void *, uint64_t))(a1 + 24))(v85, a1);
            (*(void (**)(_QWORD, uint64_t))(a1 + 24))(*(_QWORD *)(v10 + 24), a1);
            *(_QWORD *)(v10 + 24) = 0;
            (*(void (**)(_QWORD, uint64_t))(a1 + 24))(*(_QWORD *)(v10 + 40), a1);
            *(_QWORD *)(v10 + 40) = 0;
            *(_DWORD *)v10 = 0;
            v56 = "Failed allocating additional space for userauth-publickey packet";
LABEL_117:
            v57 = a1;
            v58 = 4294967290;
            return _libssh2_error(v57, v58, v56);
          }
LABEL_96:
          v61 = *(char **)(v10 + 40);
          v86 = (_DWORD *)(v59 + *(_QWORD *)(v10 + 32));
          *(_QWORD *)(v10 + 64) = 0;
          v62 = plain_method(v61, *(_QWORD *)(v10 + 48));
          *(_QWORD *)(v10 + 48) = v62;
          v63 = *(const char **)(v10 + 40);
          if (!strncmp(v63, "sk-ecdsa-sha2-nistp256@openssh.com", v62)
            || !strncmp(v63, "sk-ssh-ed25519@openssh.com", v62))
          {
            _libssh2_store_u32(&v86, v62 + v84 + 4);
            _libssh2_store_str(&v86, *(const void **)(v10 + 40), *(_QWORD *)(v10 + 48));
            memcpy(v86, v85, v84);
            v86 = (_DWORD *)((char *)v86 + v84);
          }
          else
          {
            _libssh2_store_u32(&v86, v62 + v84 + 8);
            _libssh2_store_str(&v86, *(const void **)(v10 + 40), *(_QWORD *)(v10 + 48));
            _libssh2_store_str(&v86, v85, v84);
          }
          (*(void (**)(_QWORD, uint64_t))(a1 + 24))(*(_QWORD *)(v10 + 40), a1);
          *(_QWORD *)(v10 + 40) = 0;
          (*(void (**)(const void *, uint64_t))(a1 + 24))(v85, a1);
          v60 = v86;
          *(_QWORD *)(v10 + 56) = v86;
          *(_DWORD *)v10 = 5;
LABEL_101:
          v64 = _libssh2_transport_send(a1, *(void **)(v10 + 24), (size_t)v60 - *(_QWORD *)(v10 + 24), 0, 0);
          if (v64)
          {
            if (v64 == -37)
              goto LABEL_103;
            (*(void (**)(_QWORD, uint64_t))(a1 + 24))(*(_QWORD *)(v10 + 24), a1);
            *(_QWORD *)(v10 + 24) = 0;
LABEL_110:
            *(_DWORD *)v10 = 0;
            v56 = "Unable to send userauth-publickey request";
            v57 = a1;
            v58 = 4294967289;
            return _libssh2_error(v57, v58, v56);
          }
          (*(void (**)(_QWORD, uint64_t))(a1 + 24))(*(_QWORD *)(v10 + 24), a1);
          *(_QWORD *)(v10 + 24) = 0;
          *(_DWORD *)v10 = 6;
LABEL_106:
          v87[2] = 0;
          v65 = _libssh2_packet_requirev(a1, v87, v12, v13, 0, 0, 0, v11);
          if (v65)
          {
            if (v65 == -37)
            {
              v56 = "Would block requesting userauth list";
              goto LABEL_104;
            }
LABEL_114:
            *(_DWORD *)v10 = 0;
            v56 = "Waiting for publickey USERAUTH response";
          }
          else
          {
            if (!*v13)
              goto LABEL_114;
            v66 = *(unsigned __int8 *)*v12;
            (*(void (**)(void))(a1 + 24))();
            *v12 = 0;
            if (v66 == 52)
            {
              v46 = 0;
              goto LABEL_84;
            }
            *(_DWORD *)v10 = 0;
            v56 = "Invalid signature for supplied public key, or bad username/public key combination";
          }
LABEL_115:
          v57 = a1;
          v58 = 4294967277;
          return _libssh2_error(v57, v58, v56);
        }
        (*(void (**)(_QWORD, uint64_t))(a1 + 24))(*(_QWORD *)(v10 + 40), a1);
        *(_QWORD *)(v10 + 40) = 0;
        (*(void (**)(_QWORD, uint64_t))(a1 + 24))(*(_QWORD *)(v10 + 24), a1);
        v14 = 0;
        v83 = 0;
        *(_QWORD *)(v10 + 24) = 0;
        *(_DWORD *)v10 = 0;
        continue;
      case 3:
        goto LABEL_66;
      case 4:
        goto LABEL_71;
      case 5:
        v60 = *(_DWORD **)(v10 + 56);
        goto LABEL_101;
      default:
        goto LABEL_106;
    }
    break;
  }
  do
  {
    if (v33 || !*v34)
      break;
    v35 = strchr(v34, 44);
    v36 = v35;
    if (v35)
      v37 = v35 - v34;
    else
      v37 = strlen(v34);
    v38 = v23;
    v39 = *v23;
    if (!v39)
    {
      v33 = 0;
      goto LABEL_53;
    }
    v40 = v32;
    while (1)
    {
      v41 = strchr(v38, 44);
      v42 = v41;
      if (v41)
        v43 = v41 - v38;
      else
        v43 = strlen(v38);
      if (v43 == v37)
      {
        v33 = v34;
        v32 = v37;
        if (!memcmp(v38, v34, v37))
          goto LABEL_48;
      }
      v33 = 0;
      if (!v42)
        break;
      v39 = v42[1];
      v38 = v42 + 1;
      v32 = v40;
LABEL_48:
      if (!v33)
      {
        v40 = v32;
        if (v39)
          continue;
      }
      goto LABEL_53;
    }
    v32 = v40;
LABEL_53:
    v34 = v36 + 1;
    v23 = (char *)v80;
  }
  while (v36);
  if (v33)
  {
    v10 = v70;
    v44 = *(_QWORD *)(v70 + 40);
    if (v44)
      (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v44, a1);
    v45 = (void *)(*(uint64_t (**)(size_t, uint64_t))(a1 + 8))(v32, a1);
    *(_QWORD *)(v70 + 40) = v45;
    memcpy(v45, v33, v32);
    v46 = 0;
    *(_QWORD *)(v70 + 48) = v32;
  }
  else
  {
    v46 = _libssh2_error(a1, 4294967279, "No signing signature matched");
    v10 = v70;
  }
  v11 = v68;
  v12 = v69;
  v7 = a7;
  (*(void (**)(unsigned __int8 *, uint64_t))(a1 + 24))(v80, a1);
LABEL_61:
  if (!(_DWORD)v46)
  {
LABEL_62:
    v47 = *(_QWORD *)(v10 + 48);
    *(_QWORD *)(v10 + 32) = v79 + v47 + 45;
    v48 = (_DWORD *)(*(uint64_t (**)(size_t, uint64_t))(a1 + 8))(v78 + v47 + v79 + v47, a1);
    *(_QWORD *)(v10 + 24) = v48;
    v86 = v48;
    if (v48)
    {
      v86 = (_DWORD *)((char *)v48 + 1);
      *(_BYTE *)v48 = 50;
      _libssh2_store_str(&v86, a2, a3);
      _libssh2_store_str(&v86, "ssh-connection", 0xEuLL);
      _libssh2_store_str(&v86, "publickey", 9uLL);
      v49 = v86;
      *(_QWORD *)(v10 + 64) = v86;
      v86 = (_DWORD *)((char *)v49 + 1);
      *(_BYTE *)v49 = 0;
      _libssh2_store_str(&v86, *(const void **)(v10 + 40), *(_QWORD *)(v10 + 48));
      v8 = v74;
      _libssh2_store_str(&v86, a4, v74);
      *(_DWORD *)v10 = 2;
      v13 = v75;
      goto LABEL_64;
    }
    (*(void (**)(_QWORD, uint64_t))(a1 + 24))(*(_QWORD *)(v10 + 40), a1);
    *(_QWORD *)(v10 + 40) = 0;
    v56 = "Out of memory";
    goto LABEL_117;
  }
  return v46;
}

uint64_t libssh2_userauth_publickey_frommemory(uint64_t a1, const void *a2, unint64_t a3, const void *a4, size_t a5, void *a6, unint64_t a7, char *a8)
{
  char *v15;
  time_t v16;
  BOOL v17;
  int v18;
  BOOL v19;
  int v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  int v25;
  const void *v26;
  size_t *v27;
  char **v28;
  int v29;
  _QWORD *v30;
  _QWORD v31[2];
  size_t v32;
  unsigned int *v33;

  if (a8)
    v15 = a8;
  else
    v15 = "";
  v16 = time(0);
  v26 = a4;
  if (a4)
    v17 = a5 == 0;
  else
    v17 = 1;
  v18 = !v17;
  v29 = v18;
  if (a6)
    v19 = a7 == 0;
  else
    v19 = 1;
  v20 = !v19;
  v25 = v20;
  v27 = (size_t *)(a1 + 72264);
  v28 = (char **)(a1 + 72256);
  while (1)
  {
    v32 = 0;
    v33 = 0;
    v30 = v31;
    v31[0] = a6;
    v31[1] = v15;
    if (!*(_DWORD *)(a1 + 72216))
    {
      if (v29)
      {
        v22 = memory_read_publickey(a1, v28, v27, &v33, &v32, v26, a5);
      }
      else
      {
        if (!v25)
        {
          v21 = _libssh2_error(a1, 4294967280, "Invalid data in public and private key.");
          goto LABEL_27;
        }
        v22 = _libssh2_pub_priv_keyfilememory(a1, (const char **)v28, v27, &v33, (uint64_t *)&v32, a6, a7, v15);
      }
      v21 = v22;
      if ((_DWORD)v22)
        goto LABEL_27;
    }
    v21 = _libssh2_userauth_publickey(a1, a2, a3, v33, v32, (uint64_t (*)(uint64_t, const void **, size_t *, char *, int64_t, uint64_t))sign_frommemory, (uint64_t)&v30);
    if (v33)
      (*(void (**)(unsigned int *, uint64_t))(a1 + 24))(v33, a1);
LABEL_27:
    if ((_DWORD)v21 != -37)
      return v21;
    if (!*(_DWORD *)(a1 + 172))
      return 4294967259;
    v23 = _libssh2_wait_socket(a1, v16);
    if ((_DWORD)v23)
      return v23;
  }
}

uint64_t libssh2_userauth_publickey_fromfile_ex(uint64_t a1, const void *a2, unsigned int a3, char *a4, char *a5, char *a6)
{
  char *v11;
  time_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  size_t *v17;
  uint64_t *v18;
  _QWORD *v19;
  _QWORD v20[2];
  char *v21;
  unsigned int *v22;

  if (a6)
    v11 = a6;
  else
    v11 = "";
  v12 = time(0);
  v17 = (size_t *)(a1 + 72264);
  v18 = (uint64_t *)(a1 + 72256);
  while (1)
  {
    v21 = 0;
    v22 = 0;
    v19 = v20;
    v20[0] = a5;
    v20[1] = v11;
    if (*(_DWORD *)(a1 + 72216)
      || (!a4
        ? (v14 = _libssh2_pub_priv_keyfile(a1, v18, v17, &v22, &v21, a5, v11))
        : (v14 = file_read_publickey(a1, (char **)v18, v17, &v22, &v21, a4)),
          v13 = v14,
          !(_DWORD)v14))
    {
      v13 = _libssh2_userauth_publickey(a1, a2, a3, v22, (size_t)v21, (uint64_t (*)(uint64_t, const void **, size_t *, char *, int64_t, uint64_t))sign_fromfile, (uint64_t)&v19);
      if (v22)
        (*(void (**)(unsigned int *, uint64_t))(a1 + 24))(v22, a1);
    }
    if ((_DWORD)v13 != -37)
      break;
    if (!*(_DWORD *)(a1 + 172))
      return 4294967259;
    v15 = _libssh2_wait_socket(a1, v12);
    if ((_DWORD)v15)
      return v15;
  }
  return v13;
}

uint64_t libssh2_userauth_publickey(uint64_t a1, const char *a2, unsigned int *a3, size_t a4, uint64_t (*a5)(uint64_t, const void **, size_t *, char *, int64_t, uint64_t), uint64_t a6)
{
  time_t v12;
  size_t v13;
  uint64_t result;

  if (!a1)
    return 4294967257;
  v12 = time(0);
  do
  {
    v13 = strlen(a2);
    result = _libssh2_userauth_publickey(a1, a2, v13, a3, a4, a5, a6);
    if ((_DWORD)result != -37)
      break;
    if (!*(_DWORD *)(a1 + 172))
      return 4294967259;
    result = _libssh2_wait_socket(a1, v12);
  }
  while (!(_DWORD)result);
  return result;
}

uint64_t libssh2_userauth_keyboard_interactive_ex(uint64_t a1, const void *a2, unsigned int a3, void (*a4)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, uint64_t))
{
  uint64_t v6;
  time_t v7;
  uint64_t *v8;
  uint64_t v9;
  unsigned __int8 **v10;
  int v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  char *v16;
  int v17;
  int v18;
  uint64_t v19;
  unsigned int *v20;
  uint64_t v21;
  unsigned int v22;
  unsigned int v23;
  _DWORD *v24;
  uint64_t v25;
  unint64_t v26;
  int v27;
  uint64_t result;
  uint64_t v29;
  uint64_t v30;
  char *v31;
  uint64_t v32;
  uint64_t v33;
  unint64_t v34;
  uint64_t v35;
  uint64_t v36;
  unint64_t v37;
  uint64_t v38;
  uint64_t v39;
  unint64_t v41;
  _DWORD *v43;

  v6 = a1 + 72296;
  v7 = time(0);
  v8 = (uint64_t *)(a1 + 72376);
  v9 = a3 + 55;
  v10 = (unsigned __int8 **)(a1 + 72304);
  v41 = a3;
  do
  {
    v43 = 0;
    v11 = *(_DWORD *)v6;
    if (*(_DWORD *)v6 == 2)
      goto LABEL_6;
    if (v11)
    {
      while (1)
      {
        if (v11 == 4)
          goto LABEL_30;
        if (v11 == 3)
        {
          v17 = _libssh2_packet_requirev(a1, "43<", (_QWORD *)(a1 + 72304), (unint64_t *)(a1 + 72312), 0, 0, 0, (time_t *)(a1 + 72392));
          if (v17)
          {
            if (v17 == -37)
              goto LABEL_32;
LABEL_33:
            *(_DWORD *)v6 = 0;
            v14 = a1;
            v15 = 4294967278;
            v16 = "Waiting for keyboard USERAUTH response";
            goto LABEL_34;
          }
          if (!*(_QWORD *)(a1 + 72312))
            goto LABEL_33;
          v18 = **v10;
          if (v18 == 51)
          {
            (*(void (**)(void))(a1 + 24))();
            *(_QWORD *)(v6 + 8) = 0;
            *(_DWORD *)v6 = 0;
            v14 = a1;
            v15 = 4294967278;
            v16 = "Authentication failed (keyboard-interactive)";
            goto LABEL_34;
          }
          if (v18 == 52)
          {
            (*(void (**)(void))(a1 + 24))();
            result = 0;
            *v10 = 0;
            *(_DWORD *)(a1 + 128) |= 4u;
LABEL_65:
            *(_DWORD *)v6 = 0;
            return result;
          }
          if ((userauth_keyboard_interactive_decode_info_request((_QWORD *)a1) & 0x80000000) == 0)
            break;
        }
LABEL_41:
        (*(void (**)(_QWORD, uint64_t))(a1 + 24))(*v10, a1);
        v32 = 0;
        *v10 = 0;
        if (*v8)
        {
          if (*(_DWORD *)(v6 + 72))
          {
            v33 = 0;
            v34 = 0;
            v32 = *v8;
            do
            {
              (*(void (**)(_QWORD, uint64_t))(a1 + 24))(*(_QWORD *)(v32 + v33), a1);
              v32 = *(_QWORD *)(v6 + 80);
              *(_QWORD *)(v32 + v33) = 0;
              ++v34;
              v33 += 24;
            }
            while (v34 < *(unsigned int *)(v6 + 72));
          }
          else
          {
            v32 = *v8;
          }
        }
        v35 = *(_QWORD *)(v6 + 88);
        if (v35 && *(_DWORD *)(v6 + 72))
        {
          v36 = 0;
          v37 = 0;
          do
          {
            (*(void (**)(_QWORD, uint64_t))(a1 + 24))(*(_QWORD *)(v35 + v36), a1);
            v35 = *(_QWORD *)(v6 + 88);
            *(_QWORD *)(v35 + v36) = 0;
            ++v37;
            v36 += 16;
          }
          while (v37 < *(unsigned int *)(v6 + 72));
          v32 = *v8;
        }
        if (v32)
        {
          (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v32, a1);
          *(_QWORD *)(v6 + 80) = 0;
          v35 = *(_QWORD *)(v6 + 88);
        }
        if (v35)
        {
          (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v35, a1);
          *(_QWORD *)(v6 + 88) = 0;
        }
        v38 = *(_QWORD *)(v6 + 48);
        if (v38)
        {
          (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v38, a1);
          *(_QWORD *)(v6 + 48) = 0;
        }
        v39 = *(_QWORD *)(v6 + 64);
        if (v39)
        {
          (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v39, a1);
          *(_QWORD *)(v6 + 64) = 0;
        }
        if (*(_DWORD *)(v6 + 76))
        {
          result = 0xFFFFFFFFLL;
          goto LABEL_65;
        }
LABEL_11:
        v11 = 3;
        *(_DWORD *)v6 = 3;
      }
      a4(*(_QWORD *)(v6 + 48), *(unsigned int *)(v6 + 40), *(_QWORD *)(v6 + 64), *(unsigned int *)(v6 + 56), *(unsigned int *)(v6 + 72), *(_QWORD *)(v6 + 80), *(_QWORD *)(v6 + 88), a1);
      *(_QWORD *)(v6 + 32) = 5;
      v19 = *(unsigned int *)(v6 + 72);
      if ((_DWORD)v19)
      {
        v20 = (unsigned int *)(*(_QWORD *)(v6 + 88) + 8);
        v21 = 5;
        while (1)
        {
          v23 = *v20;
          v20 += 4;
          v22 = v23;
          if (-5 - v21 < (unint64_t)v23)
            break;
          v21 += v22 + 4;
          *(_QWORD *)(v6 + 32) = v21;
          if (!--v19)
            goto LABEL_25;
        }
      }
      else
      {
LABEL_25:
        (*(void (**)(_QWORD, uint64_t))(a1 + 24))(*(_QWORD *)(v6 + 8), a1);
        v24 = (_DWORD *)(*(uint64_t (**)(_QWORD, uint64_t))(a1 + 8))(*(_QWORD *)(v6 + 32), a1);
        v43 = v24;
        *(_QWORD *)(v6 + 8) = v24;
        if (v24)
        {
          *(_BYTE *)v24 = 61;
          v43 = (_DWORD *)((char *)v43 + 1);
          _libssh2_store_u32(&v43, *(_DWORD *)(v6 + 72));
          if (*(_DWORD *)(v6 + 72))
          {
            v25 = 0;
            v26 = 0;
            do
            {
              _libssh2_store_str(&v43, *(const void **)(*(_QWORD *)(v6 + 88) + v25), *(unsigned int *)(*(_QWORD *)(v6 + 88) + v25 + 8));
              ++v26;
              v25 += 16;
            }
            while (v26 < *(unsigned int *)(v6 + 72));
          }
          *(_DWORD *)v6 = 4;
LABEL_30:
          v27 = _libssh2_transport_send(a1, *(void **)(v6 + 8), *(_QWORD *)(v6 + 32), 0, 0);
          if (!v27)
          {
            *(_DWORD *)(v6 + 76) = 0;
            goto LABEL_41;
          }
          if (v27 == -37)
            goto LABEL_32;
          v29 = a1;
          v30 = 4294967289;
          v31 = "Unable to send userauth-keyboard-interactive request";
LABEL_40:
          _libssh2_error(v29, v30, v31);
          goto LABEL_41;
        }
      }
      v29 = a1;
      v30 = 4294967290;
      v31 = "Unable to allocate memory for keyboard-interactive response packet";
      goto LABEL_40;
    }
    *(_QWORD *)(v6 + 48) = 0;
    *(_QWORD *)(v6 + 64) = 0;
    *(_QWORD *)(v6 + 72) = 0x100000000;
    *v8 = 0;
    *(_QWORD *)(a1 + 72384) = 0;
    *(_QWORD *)(v6 + 96) = 0;
    *(_QWORD *)(v6 + 32) = v9;
    v12 = (*(uint64_t (**)(uint64_t, uint64_t))(a1 + 8))(v9, a1);
    *(_QWORD *)(v6 + 8) = v12;
    if (v12)
    {
      v43 = (_DWORD *)(v12 + 1);
      *(_BYTE *)v12 = 50;
      _libssh2_store_str(&v43, a2, v41);
      _libssh2_store_str(&v43, "ssh-connection", 0xEuLL);
      _libssh2_store_str(&v43, "keyboard-interactive", 0x14uLL);
      _libssh2_store_u32(&v43, 0);
      _libssh2_store_u32(&v43, 0);
      *(_DWORD *)v6 = 2;
LABEL_6:
      v13 = _libssh2_transport_send(a1, *(void **)(v6 + 8), *(_QWORD *)(v6 + 32), 0, 0);
      if (!v13)
      {
        (*(void (**)(_QWORD, uint64_t))(a1 + 24))(*v10, a1);
        *v10 = 0;
        goto LABEL_11;
      }
      if (v13 == -37)
      {
LABEL_32:
        v14 = a1;
        v15 = 4294967259;
        v16 = "Would block";
      }
      else
      {
        (*(void (**)(_QWORD, uint64_t))(a1 + 24))(*(_QWORD *)(v6 + 8), a1);
        *(_QWORD *)(v6 + 8) = 0;
        *(_DWORD *)v6 = 0;
        v14 = a1;
        v15 = 4294967289;
        v16 = "Unable to send keyboard-interactive request";
      }
      goto LABEL_34;
    }
    v14 = a1;
    v15 = 4294967290;
    v16 = "Unable to allocate memory for keyboard-interactive authentication";
LABEL_34:
    result = _libssh2_error(v14, v15, v16);
    if ((_DWORD)result != -37)
      break;
    if (!*(_DWORD *)(a1 + 172))
      return 4294967259;
    result = _libssh2_wait_socket(a1, v7);
  }
  while (!(_DWORD)result);
  return result;
}

uint64_t libssh2_userauth_publickey_sk(uint64_t a1, const void *a2, unint64_t a3, const char *a4, size_t a5, void *a6, unint64_t a7, void *a8, uint64_t a9, uint64_t a10)
{
  char *v15;
  uint64_t v16;
  _QWORD *v18;
  void *v19;
  size_t v20;
  const char *v21;
  size_t v22;
  unsigned int **v23;
  size_t *v24;
  unsigned int *v25;
  size_t v26;
  uint64_t v27;
  __int128 *v28;
  __int128 v29;
  __int128 v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  size_t v37;
  const char *v38;

  v37 = 0;
  v38 = 0;
  v35 = 0;
  v36 = 0;
  v33 = 0;
  v34 = 0;
  v29 = 0u;
  v30 = 0u;
  v28 = &v29;
  v31 = a9;
  v32 = a10;
  if (!a6 || !a7)
  {
    v15 = "Invalid data in public and private key.";
    return _libssh2_error(a1, 4294967280, v15);
  }
  if (_libssh2_sk_pub_keyfilememory(a1, &v38, &v37, &v36, &v35, &v29, (_BYTE *)&v29 + 4, (void **)&v29 + 1, &v30, (size_t *)&v30 + 1, a6, a7, a8))
  {
    v15 = "Unable to extract public key from private key.";
    return _libssh2_error(a1, 4294967280, v15);
  }
  v18 = (_QWORD *)(a1 + 72256);
  if (!a4 || !a5)
  {
    v22 = v37;
    *v18 = v38;
    *(_QWORD *)(a1 + 72264) = v22;
    v23 = (unsigned int **)&v36;
    v24 = (size_t *)&v35;
    goto LABEL_19;
  }
  if (v38)
    (*(void (**)(const char *, uint64_t))(a1 + 24))(v38, a1);
  if (!strncmp(a4, "sk-ecdsa-sha2-nistp256-cert-v01@openssh.com", 0x2BuLL))
  {
    *(_QWORD *)(a1 + 72264) = 43;
    v19 = (void *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 8))(43, a1);
    *v18 = v19;
    v20 = *(_QWORD *)(a1 + 72264);
    v21 = "sk-ecdsa-sha2-nistp256-cert-v01@openssh.com";
  }
  else
  {
    if (strncmp(a4, "sk-ssh-ed25519-cert-v01@openssh.com", 0x23uLL))
      goto LABEL_18;
    *(_QWORD *)(a1 + 72264) = 35;
    v19 = (void *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 8))(35, a1);
    *v18 = v19;
    v20 = *(_QWORD *)(a1 + 72264);
    v21 = "sk-ssh-ed25519-cert-v01@openssh.com";
  }
  memcpy(v19, v21, v20);
LABEL_18:
  v23 = (unsigned int **)&v34;
  v24 = (size_t *)&v33;
  v16 = memory_read_publickey(a1, (char **)(a1 + 72256), (_QWORD *)(a1 + 72264), &v34, &v33, a4, a5);
  if (!(_DWORD)v16)
  {
LABEL_19:
    v25 = *v23;
    v26 = *v24;
    v16 = _libssh2_userauth_publickey(a1, a2, a3, v25, *v24, (uint64_t (*)(uint64_t, const void **, size_t *, char *, int64_t, uint64_t))libssh2_sign_sk, (uint64_t)&v28);
    if ((_DWORD)v16 == -37)
    {
      do
        v27 = _libssh2_userauth_publickey(a1, a2, a3, v25, v26, (uint64_t (*)(uint64_t, const void **, size_t *, char *, int64_t, uint64_t))libssh2_sign_sk, (uint64_t)&v28);
      while ((_DWORD)v27 == -37);
      v16 = v27;
    }
  }
  if (v36)
    (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v36, a1);
  if (*((_QWORD *)&v29 + 1))
    (*(void (**)(_QWORD, uint64_t))(a1 + 24))(*((_QWORD *)&v29 + 1), a1);
  return v16;
}

uint64_t memory_read_publickey(uint64_t a1, char **a2, _QWORD *a3, _QWORD *a4, _QWORD *a5, const void *a6, size_t a7)
{
  char *v8;
  char *v15;
  char *v16;
  size_t v17;
  uint64_t v18;
  size_t v19;
  int v20;
  int v21;
  unint64_t v22;
  unsigned __int8 *v23;
  char *v24;
  char *v25;
  char *v26;
  uint64_t result;
  uint64_t v28;
  uint64_t v29;

  if (a7 <= 1)
  {
    v8 = "Invalid data in public key file";
    return _libssh2_error(a1, 4294967280, v8);
  }
  v15 = (char *)(*(uint64_t (**)(size_t, uint64_t))(a1 + 8))(a7, a1);
  if (!v15)
    return _libssh2_error(a1, 4294967290, "Unable to allocate memory for public key data");
  v16 = v15;
  v28 = 0;
  v29 = 0;
  memcpy(v15, a6, a7);
  v17 = a7 + 1;
  v18 = MEMORY[0x24BDAC740];
  do
  {
    v19 = v17 - 1;
    if (v17 == 1)
    {
      (*(void (**)(char *, uint64_t))(a1 + 24))(v16, a1);
      v8 = "Missing public key data";
      return _libssh2_error(a1, 4294967280, v8);
    }
    v20 = v16[v17 - 2];
    if (v20 < 0)
      v21 = __maskrune(v20, 0x4000uLL);
    else
      v21 = *(_DWORD *)(v18 + 4 * v20 + 60) & 0x4000;
    v17 = v19;
  }
  while (v21);
  v22 = (unint64_t)memchr(v16, 32, v19);
  if (!v22)
  {
    (*(void (**)(char *, uint64_t))(a1 + 24))(v16, a1);
    v8 = "Invalid public key data";
    return _libssh2_error(a1, 4294967280, v8);
  }
  v23 = (unsigned __int8 *)(v22 + 1);
  v24 = &v16[v19];
  v25 = (char *)memchr((void *)(v22 + 1), 32, (size_t)&v24[~v22]);
  if (v25)
    v26 = v25;
  else
    v26 = v24;
  result = _libssh2_base64_decode(a1, &v29, &v28, v23, v26 - (char *)v23);
  if ((_DWORD)result)
  {
    (*(void (**)(char *, uint64_t))(a1 + 24))(v16, a1);
    return _libssh2_error(a1, 4294967280, "Invalid key data, not base64 encoded");
  }
  else
  {
    *a2 = v16;
    *a3 = v23 - (unsigned __int8 *)v16 - 1;
    *a4 = v29;
    *a5 = v28;
  }
  return result;
}

uint64_t file_read_publickey(uint64_t a1, char **a2, _QWORD *a3, _QWORD *a4, _QWORD *a5, char *__filename)
{
  FILE *v11;
  FILE *v12;
  char *v13;
  size_t v14;
  uint64_t result;
  char *v17;
  char *v18;
  size_t v19;
  uint64_t v20;
  size_t v21;
  int v22;
  int v23;
  char *v24;
  unsigned __int8 *v25;
  char *v26;
  char *v27;
  char *v28;
  char *v29;
  uint64_t v30;
  uint64_t v31;
  char __ptr;

  v11 = fopen(__filename, "r");
  if (!v11)
  {
    v13 = "Unable to open public key file";
    return _libssh2_error(a1, 4294967280, v13);
  }
  v12 = v11;
  if (feof(v11))
  {
    rewind(v12);
LABEL_13:
    fclose(v12);
    v13 = "Invalid data in public key file";
    return _libssh2_error(a1, 4294967280, v13);
  }
  v14 = 0;
  __ptr = 0;
  v30 = 0;
  v31 = 0;
  do
  {
    if (fread(&__ptr, 1uLL, 1uLL, v12) != 1)
      break;
    if (__ptr == 10 || __ptr == 13)
      break;
    ++v14;
  }
  while (!feof(v12));
  rewind(v12);
  if (v14 <= 1)
    goto LABEL_13;
  v17 = (char *)(*(uint64_t (**)(size_t, uint64_t))(a1 + 8))(v14, a1);
  if (!v17)
  {
    fclose(v12);
    return _libssh2_error(a1, 4294967290, "Unable to allocate memory for public key data");
  }
  v18 = v17;
  if (fread(v17, 1uLL, v14, v12) != v14)
  {
    (*(void (**)(char *, uint64_t))(a1 + 24))(v18, a1);
    fclose(v12);
    v13 = "Unable to read public key from file";
    return _libssh2_error(a1, 4294967280, v13);
  }
  fclose(v12);
  v19 = v14 + 1;
  v20 = MEMORY[0x24BDAC740];
  do
  {
    v21 = v19 - 1;
    if (v19 == 1)
    {
      (*(void (**)(char *, uint64_t))(a1 + 24))(v18, a1);
      v13 = "Missing public key data";
      return _libssh2_error(a1, 4294967280, v13);
    }
    v22 = v18[v19 - 2];
    if (v22 < 0)
      v23 = __maskrune(v22, 0x4000uLL);
    else
      v23 = *(_DWORD *)(v20 + 4 * v22 + 60) & 0x4000;
    v19 = v21;
  }
  while (v23);
  v24 = (char *)memchr(v18, 32, v21);
  if (!v24)
  {
    (*(void (**)(char *, uint64_t))(a1 + 24))(v18, a1);
    v13 = "Invalid public key data";
    return _libssh2_error(a1, 4294967280, v13);
  }
  v25 = (unsigned __int8 *)(v24 + 1);
  if (v18 <= v24 + 1)
    v26 = v24 + 1;
  else
    v26 = v18;
  v27 = &v18[v21];
  v28 = (char *)memchr(v24 + 1, 32, v27 - v26);
  if (v28)
    v29 = v28;
  else
    v29 = v27;
  result = _libssh2_base64_decode(a1, &v31, &v30, v25, v29 - (char *)v25);
  if ((_DWORD)result)
  {
    (*(void (**)(char *, uint64_t))(a1 + 24))(v18, a1);
    return _libssh2_error(a1, 4294967280, "Invalid key data, not base64 encoded");
  }
  else
  {
    *a2 = v18;
    *a3 = v25 - (unsigned __int8 *)v18 - 1;
    *a4 = v31;
    *a5 = v30;
  }
  return result;
}

uint64_t file_read_privatekey(uint64_t a1, char ***a2, _QWORD *a3, const char *a4, size_t a5, uint64_t a6, uint64_t a7)
{
  char ***v14;
  char **v15;
  char ***v16;
  char **v17;
  uint64_t result;

  v14 = libssh2_hostkey_methods();
  *a2 = 0;
  *a3 = 0;
  v15 = *v14;
  if (*v14)
  {
    v16 = v14 + 1;
    while (*v15)
    {
      if (v15[3] && !strncmp(*v15, a4, a5))
      {
        *a2 = v15;
        goto LABEL_10;
      }
      v17 = *v16++;
      v15 = v17;
      if (!v17)
        break;
    }
  }
  v15 = *a2;
  if (!*a2)
    return _libssh2_error(a1, 4294967279, "No handler for specified private key");
LABEL_10:
  result = ((uint64_t (*)(uint64_t, uint64_t, uint64_t, _QWORD *))v15[3])(a1, a6, a7, a3);
  if ((_DWORD)result)
    return _libssh2_error(a1, 4294967280, "Unable to initialize private key from file");
  return result;
}

uint64_t sign_frommemory(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, const char ***a6)
{
  const char **v8;
  const char *v9;
  size_t v10;
  const char *v11;
  size_t v12;
  const char *v13;
  char ***v14;
  char **v15;
  char ***v16;
  char *v17;
  char **v18;
  uint64_t v19;
  int v20;
  char *v21;
  _QWORD v26[2];
  uint64_t v27;

  v8 = *a6;
  v9 = *(const char **)(a1 + 72256);
  v10 = *(_QWORD *)(a1 + 72264);
  v11 = **a6;
  v12 = strlen(v11);
  v13 = v8[1];
  v14 = libssh2_hostkey_methods();
  v27 = 0;
  v15 = *v14;
  if (*v14)
  {
    v16 = v14 + 1;
    while (*v15)
    {
      v17 = v15[4];
      if (v17 && !strncmp(*v15, v9, v10))
      {
        if (((unsigned int (*)(uint64_t, const char *, size_t, const char *, uint64_t *))v17)(a1, v11, v12, v13, &v27))
        {
          v19 = _libssh2_error(a1, 4294967280, "Unable to initialize private key from memory");
          if ((_DWORD)v19)
            return v19;
        }
        goto LABEL_8;
      }
      v18 = *v16++;
      v15 = v18;
      if (!v18)
        break;
    }
  }
  v19 = _libssh2_error(a1, 4294967279, "No handler for specified private key");
  v15 = 0;
  if (!(_DWORD)v19)
  {
LABEL_8:
    v26[0] = a4;
    v26[1] = a5;
    v20 = ((uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, _QWORD *, uint64_t *))v15[6])(a1, a2, a3, 1, v26, &v27);
    v21 = v15[8];
    if (v20)
      v19 = 0xFFFFFFFFLL;
    else
      v19 = 0;
    if (v21)
      ((void (*)(uint64_t, uint64_t *))v21)(a1, &v27);
  }
  return v19;
}

uint64_t sign_fromfile(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t **a6)
{
  uint64_t *v11;
  uint64_t v12;
  char **v13;
  int v14;
  char *v15;
  _QWORD v17[2];
  uint64_t v18;
  char **v19;

  v11 = *a6;
  v18 = 0;
  v19 = 0;
  v12 = file_read_privatekey(a1, &v19, &v18, *(const char **)(a1 + 72256), *(_QWORD *)(a1 + 72264), *v11, v11[1]);
  if (!(_DWORD)v12)
  {
    v17[0] = a4;
    v17[1] = a5;
    v13 = v19;
    v14 = ((uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, _QWORD *, uint64_t *))v19[6])(a1, a2, a3, 1, v17, &v18);
    v15 = v13[8];
    if (v14)
      v12 = 0xFFFFFFFFLL;
    else
      v12 = 0;
    if (v15)
      ((void (*)(uint64_t, uint64_t *))v15)(a1, &v18);
  }
  return v12;
}

uint64_t _libssh2_kex_exchange(uint64_t a1, int a2, uint64_t a3)
{
  int v5;
  int v6;
  uint64_t v7;
  void (*v8)(uint64_t, uint64_t);
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _DWORD *v12;
  size_t v13;
  _BYTE *v14;
  uint64_t v15;
  uint64_t v16;
  const char *v17;
  unsigned int v18;
  uint64_t v19;
  char *v20;
  uint64_t v21;
  uint64_t v22;
  unsigned int v23;
  const char *v24;
  unsigned int v25;
  char ***v26;
  unsigned int v27;
  const char *v28;
  unsigned int v29;
  char ***v30;
  unsigned int v31;
  const char *v32;
  unsigned int v33;
  char ***v34;
  const char *v35;
  unsigned int v36;
  char ***v37;
  const char *v38;
  unsigned int v39;
  char ***v40;
  const char *v41;
  unsigned int v42;
  char ***v43;
  unsigned int v44;
  const char *v45;
  unsigned int v46;
  char ***v47;
  unsigned int v48;
  const char *v49;
  unsigned int v50;
  const char *v51;
  unsigned int v52;
  _BYTE *v53;
  int v54;
  uint64_t *v55;
  unint64_t *v56;
  int v57;
  uint64_t v58;
  uint64_t v59;
  unint64_t v60;
  uint64_t v61;
  _DWORD *v62;
  char *v63;
  char *v64;
  char ***v65;
  char *v66;
  char *v67;
  char ***v68;
  char *v69;
  char *v70;
  char ***v71;
  char *v72;
  char *v73;
  char ***v74;
  char *v75;
  char *v76;
  char ***v77;
  char *v78;
  char *v79;
  char ***v80;
  char *v81;
  char *v82;
  char ***v83;
  uint64_t v84;
  char *v85;
  uint64_t v86;
  _BYTE *v87;
  unsigned __int8 *v88;
  uint64_t v89;
  uint64_t v90;
  unsigned int v92;
  unsigned int v93;
  unsigned int v94;
  unsigned int v95;
  unsigned int v96;
  unsigned int v97;
  uint64_t v98;
  unsigned __int8 *v99;
  unint64_t v100;
  size_t v101;
  size_t v102;
  size_t v103;
  size_t v104;
  size_t v105;
  size_t v106;
  size_t v107;
  size_t v108;
  char *v109;
  char *v110;
  char *v111;
  char *v112;
  char *v113;
  char *v114;
  char *v115;
  char *v116;

  v5 = *(_DWORD *)(a1 + 128);
  *(_DWORD *)(a1 + 128) = v5 | 8;
  v6 = *(_DWORD *)a3;
  if (!*(_DWORD *)a3)
  {
    *(_DWORD *)(a1 + 128) = v5 | 9;
    if (a2)
    {
      *(_QWORD *)(a1 + 144) = 0;
      v7 = *(_QWORD *)(a1 + 184);
      if (v7)
      {
        v8 = *(void (**)(uint64_t, uint64_t))(v7 + 64);
        if (v8)
          v8(a1, a1 + 192);
      }
      *(_QWORD *)(a1 + 184) = 0;
    }
    v6 = 2;
    *(_DWORD *)a3 = 2;
  }
  v9 = *(_QWORD *)(a1 + 144);
  if (!v9 || !*(_QWORD *)(a1 + 184))
  {
    if (v6 == 4)
    {
LABEL_66:
      v55 = (uint64_t *)(a3 + 632);
      v56 = (unint64_t *)(a3 + 640);
      v57 = _libssh2_packet_require(a1, 20, (_QWORD *)(a3 + 632), (unint64_t *)(a3 + 640), 0, 0, 0, a3 + 8);
      if (v57)
      {
        if (v57 == -37)
          goto LABEL_68;
        v61 = *(_QWORD *)(a1 + 432);
        if (v61)
          (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v61, a1);
        goto LABEL_83;
      }
      v58 = *(_QWORD *)(a1 + 320);
      if (v58)
        (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v58, a1);
      v59 = *v55;
      *(_QWORD *)(a1 + 320) = *v55;
      v60 = *v56;
      *(_QWORD *)(a1 + 328) = *v56;
      if (v60 < 0x11)
        goto LABEL_80;
      v115 = 0;
      v116 = 0;
      v113 = 0;
      v114 = 0;
      v111 = 0;
      v112 = 0;
      v109 = 0;
      v110 = 0;
      v107 = 0;
      v108 = 0;
      v105 = 0;
      v106 = 0;
      v103 = 0;
      v104 = 0;
      v101 = 0;
      v102 = 0;
      v100 = v60;
      v98 = v59;
      v99 = (unsigned __int8 *)(v59 + 17);
      if (_libssh2_get_string(&v98, &v116, &v108)
        || _libssh2_get_string(&v98, &v115, &v107)
        || _libssh2_get_string(&v98, &v114, &v106)
        || _libssh2_get_string(&v98, &v113, &v105)
        || _libssh2_get_string(&v98, &v110, &v102)
        || _libssh2_get_string(&v98, &v109, &v101)
        || _libssh2_get_string(&v98, &v112, &v104)
        || _libssh2_get_string(&v98, &v111, &v103)
        || !_libssh2_check_length(&v98, 1uLL)
        || (v88 = v99,
            ++v99,
            *(_DWORD *)(a1 + 152) = *v88,
            kex_agree_kex_hostkey(a1, v116, v108, v115, v107))
        || kex_agree_crypt(a1 + 424, v114, v106)
        || kex_agree_crypt(a1 + 312, v113, v105)
        || kex_agree_mac(a1 + 424, v110, v102)
        || kex_agree_mac(a1 + 312, v109, v101)
        || kex_agree_comp(a1, a1 + 424, v112, v104)
        || kex_agree_comp(a1, a1 + 312, v111, v103))
      {
LABEL_80:
        *(_DWORD *)a3 = 5;
        v11 = 4294967291;
        goto LABEL_124;
      }
      v6 = 5;
      *(_DWORD *)a3 = 5;
      v9 = *(_QWORD *)(a1 + 144);
LABEL_122:
      v11 = 0;
      if (!v9 || v6 != 5)
        goto LABEL_124;
      goto LABEL_11;
    }
    if (v6 != 3)
    {
      if (v6 != 2)
        goto LABEL_122;
      *(_QWORD *)(a3 + 648) = *(_QWORD *)(a1 + 432);
      *(_QWORD *)(a3 + 656) = *(_QWORD *)(a1 + 440);
      *(_QWORD *)(a1 + 432) = 0;
      *(_DWORD *)a3 = 3;
    }
    v12 = (_DWORD *)(a1 + 70992);
    if (*(_DWORD *)(a1 + 70992))
    {
      v14 = *(_BYTE **)(a1 + 71000);
      v13 = *(_QWORD *)(a1 + 71008);
      *(_QWORD *)(a1 + 71000) = 0;
      *(_QWORD *)(a1 + 71008) = 0;
    }
    else
    {
      v17 = *(const char **)(a1 + 112);
      if (v17)
        v18 = strlen(v17);
      else
        v18 = kex_method_strlen((const char ***)libssh2_kex_methods);
      v23 = v18;
      v24 = *(const char **)(a1 + 120);
      if (v24)
      {
        v25 = strlen(v24);
      }
      else
      {
        v26 = libssh2_hostkey_methods();
        v25 = kex_method_strlen((const char ***)v26);
      }
      v27 = v25;
      v28 = *(const char **)(a1 + 504);
      if (v28)
      {
        v29 = strlen(v28);
      }
      else
      {
        v30 = libssh2_crypt_methods();
        v29 = kex_method_strlen((const char ***)v30);
      }
      v31 = v29;
      v32 = *(const char **)(a1 + 392);
      if (v32)
      {
        v33 = strlen(v32);
      }
      else
      {
        v34 = libssh2_crypt_methods();
        v33 = kex_method_strlen((const char ***)v34);
      }
      v95 = v33;
      v35 = *(const char **)(a1 + 512);
      if (v35)
      {
        v36 = strlen(v35);
      }
      else
      {
        v37 = _libssh2_mac_methods();
        v36 = kex_method_strlen((const char ***)v37);
      }
      v96 = v36;
      v38 = *(const char **)(a1 + 400);
      if (v38)
      {
        v39 = strlen(v38);
      }
      else
      {
        v40 = _libssh2_mac_methods();
        v39 = kex_method_strlen((const char ***)v40);
      }
      v97 = v39;
      v41 = *(const char **)(a1 + 520);
      if (v41)
      {
        v42 = strlen(v41);
      }
      else
      {
        v43 = _libssh2_comp_methods(a1);
        v42 = kex_method_strlen((const char ***)v43);
      }
      v44 = v42;
      v45 = *(const char **)(a1 + 408);
      if (v45)
      {
        v46 = strlen(v45);
      }
      else
      {
        v47 = _libssh2_comp_methods(a1);
        v46 = kex_method_strlen((const char ***)v47);
      }
      v48 = v46;
      v49 = *(const char **)(a1 + 528);
      if (v49)
        v50 = strlen(v49);
      else
        v50 = 0;
      v51 = *(const char **)(a1 + 416);
      if (v51)
        v52 = strlen(v51);
      else
        v52 = 0;
      v93 = v44;
      v94 = v48;
      v13 = v27 + v23 + v31 + v95 + v96 + v97 + v44 + v48 + v50 + v52 + 62;
      v53 = (_BYTE *)(*(uint64_t (**)(size_t, uint64_t))(a1 + 8))(v13, a1);
      if (!v53)
      {
        v20 = "Unable to allocate memory";
        v21 = a1;
        v22 = 4294967290;
        goto LABEL_62;
      }
      v14 = v53;
      *v53 = 20;
      if (_libssh2_openssl_random(v53 + 1, 0x10uLL))
      {
        v20 = "Unable to get random bytes for KEXINIT cookie";
        v21 = a1;
        v22 = 4294967247;
        goto LABEL_62;
      }
      v92 = v50;
      if (*(_QWORD *)(a1 + 112))
      {
        _libssh2_htonu32(v14 + 17, v23);
        memcpy(v14 + 21, *(const void **)(a1 + 112), v23);
        v62 = &v14[v23 + 21];
      }
      else
      {
        v62 = &v14[kex_method_list(v14 + 17, v23, (const char ***)libssh2_kex_methods) + 17];
      }
      if (*(_QWORD *)(a1 + 120))
      {
        _libssh2_htonu32(v62, v27);
        v63 = (char *)(v62 + 1);
        memcpy(v63, *(const void **)(a1 + 120), v27);
        v64 = &v63[v27];
      }
      else
      {
        v65 = libssh2_hostkey_methods();
        v64 = (char *)v62 + kex_method_list(v62, v27, (const char ***)v65);
      }
      if (*(_QWORD *)(a1 + 504))
      {
        _libssh2_htonu32(v64, v31);
        v66 = v64 + 4;
        memcpy(v66, *(const void **)(a1 + 504), v31);
        v67 = &v66[v31];
      }
      else
      {
        v68 = libssh2_crypt_methods();
        v67 = &v64[kex_method_list(v64, v31, (const char ***)v68)];
      }
      if (*(_QWORD *)(a1 + 392))
      {
        _libssh2_htonu32(v67, v95);
        v69 = v67 + 4;
        memcpy(v69, *(const void **)(a1 + 392), v95);
        v70 = &v69[v95];
      }
      else
      {
        v71 = libssh2_crypt_methods();
        v70 = &v67[kex_method_list(v67, v95, (const char ***)v71)];
      }
      if (*(_QWORD *)(a1 + 512))
      {
        _libssh2_htonu32(v70, v96);
        v72 = v70 + 4;
        memcpy(v72, *(const void **)(a1 + 512), v96);
        v73 = &v72[v96];
      }
      else
      {
        v74 = _libssh2_mac_methods();
        v73 = &v70[kex_method_list(v70, v96, (const char ***)v74)];
      }
      if (*(_QWORD *)(a1 + 400))
      {
        _libssh2_htonu32(v73, v97);
        v75 = v73 + 4;
        memcpy(v75, *(const void **)(a1 + 400), v97);
        v76 = &v75[v97];
      }
      else
      {
        v77 = _libssh2_mac_methods();
        v76 = &v73[kex_method_list(v73, v97, (const char ***)v77)];
      }
      if (*(_QWORD *)(a1 + 520))
      {
        _libssh2_htonu32(v76, v93);
        v78 = v76 + 4;
        memcpy(v78, *(const void **)(a1 + 520), v93);
        v79 = &v78[v93];
      }
      else
      {
        v80 = _libssh2_comp_methods(a1);
        v79 = &v76[kex_method_list(v76, v93, (const char ***)v80)];
      }
      if (*(_QWORD *)(a1 + 408))
      {
        _libssh2_htonu32(v79, v94);
        v81 = v79 + 4;
        memcpy(v81, *(const void **)(a1 + 408), v94);
        v82 = &v81[v94];
      }
      else
      {
        v83 = _libssh2_comp_methods(a1);
        v82 = &v79[kex_method_list(v79, v94, (const char ***)v83)];
      }
      v84 = *(_QWORD *)(a1 + 528);
      _libssh2_htonu32(v82, v92);
      v85 = v82 + 4;
      if (v84)
      {
        memcpy(v85, *(const void **)(a1 + 528), v92);
        v85 += v92;
      }
      v86 = *(_QWORD *)(a1 + 416);
      _libssh2_htonu32(v85, v52);
      v87 = v85 + 4;
      if (v86)
      {
        memcpy(v87, *(const void **)(a1 + 416), v52);
        v87 += v52;
      }
      *v87 = 0;
      _libssh2_htonu32(v87 + 1, 0);
      *v12 = 2;
    }
    v15 = _libssh2_transport_send(a1, v14, v13);
    if (!(_DWORD)v15)
    {
      v19 = *(_QWORD *)(a1 + 432);
      if (v19)
        (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v19, a1);
      *(_QWORD *)(a1 + 432) = v14;
      *(_QWORD *)(a1 + 440) = v13;
      *v12 = 0;
LABEL_65:
      *(_DWORD *)a3 = 4;
      goto LABEL_66;
    }
    v16 = v15;
    if ((_DWORD)v15 == -37)
    {
      *(_QWORD *)(a1 + 71000) = v14;
      *(_QWORD *)(a1 + 71008) = v13;
LABEL_68:
      *(_DWORD *)(a1 + 128) &= ~8u;
      return 4294967259;
    }
    (*(void (**)(_BYTE *, uint64_t))(a1 + 24))(v14, a1);
    *v12 = 0;
    v20 = "Unable to send KEXINIT packet to remote host";
    v21 = a1;
    v22 = v16;
LABEL_62:
    v54 = _libssh2_error(v21, v22, v20);
    if (v54)
    {
      if (v54 == -37)
        goto LABEL_68;
LABEL_83:
      *(_QWORD *)(a1 + 432) = *(_QWORD *)(a3 + 648);
      *(_QWORD *)(a1 + 440) = *(_QWORD *)(a3 + 656);
      *(_DWORD *)a3 = 0;
      *(_DWORD *)(a1 + 128) &= 0xFFFFFFF6;
      return 0xFFFFFFFFLL;
    }
    goto LABEL_65;
  }
  *(_DWORD *)a3 = 5;
LABEL_11:
  v10 = (*(uint64_t (**)(uint64_t, uint64_t))(v9 + 8))(a1, a3 + 24);
  v11 = v10;
  if ((_DWORD)v10)
  {
    if ((_DWORD)v10 == -37)
    {
      *(_DWORD *)(a1 + 128) &= ~8u;
      return v11;
    }
    v11 = _libssh2_error(a1, 4294967288, "Unrecoverable error exchanging keys");
  }
LABEL_124:
  v89 = *(_QWORD *)(a1 + 432);
  if (v89)
  {
    (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v89, a1);
    *(_QWORD *)(a1 + 432) = 0;
  }
  v90 = *(_QWORD *)(a1 + 320);
  if (v90)
  {
    (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v90, a1);
    *(_QWORD *)(a1 + 320) = 0;
  }
  *(_DWORD *)(a1 + 128) &= 0xFFFFFFF6;
  *(_DWORD *)a3 = 0;
  return v11;
}

uint64_t libssh2_session_method_pref(uint64_t a1, int a2, char *__s)
{
  size_t v6;
  char **v7;
  const char ***v8;
  char *v9;
  uint64_t v10;
  uint64_t v11;
  char ***v12;
  size_t v13;
  char *v14;
  char *v15;
  char *v16;
  char *v17;
  int64_t v18;
  char *v19;
  size_t v20;
  size_t v21;

  v6 = strlen(__s);
  switch(a2)
  {
    case 0:
      v7 = (char **)(a1 + 112);
      v8 = (const char ***)libssh2_kex_methods;
      goto LABEL_15;
    case 1:
      v7 = (char **)(a1 + 120);
      v12 = libssh2_hostkey_methods();
      goto LABEL_14;
    case 2:
      v7 = (char **)(a1 + 504);
      goto LABEL_7;
    case 3:
      v7 = (char **)(a1 + 392);
LABEL_7:
      v12 = libssh2_crypt_methods();
      goto LABEL_14;
    case 4:
      v7 = (char **)(a1 + 512);
      goto LABEL_10;
    case 5:
      v7 = (char **)(a1 + 400);
LABEL_10:
      v12 = _libssh2_mac_methods();
      goto LABEL_14;
    case 6:
      v7 = (char **)(a1 + 520);
      goto LABEL_13;
    case 7:
      v7 = (char **)(a1 + 408);
LABEL_13:
      v12 = _libssh2_comp_methods(a1);
LABEL_14:
      v8 = (const char ***)v12;
      goto LABEL_15;
    case 8:
      v8 = 0;
      v7 = (char **)(a1 + 528);
      goto LABEL_15;
    case 9:
      v8 = 0;
      v7 = (char **)(a1 + 416);
      goto LABEL_15;
    case 10:
      v8 = 0;
      v7 = (char **)(a1 + 304);
LABEL_15:
      v13 = v6 + 1;
      v14 = (char *)(*(uint64_t (**)(size_t, uint64_t))(a1 + 8))(v6 + 1, a1);
      if (!v14)
      {
        v9 = "Error allocated space for method preferences";
        v10 = a1;
        v11 = 4294967290;
        return _libssh2_error(v10, v11, v9);
      }
      v15 = v14;
      memcpy(v14, __s, v13);
      if (v8 && *v15)
      {
        v16 = v15;
        do
        {
          v17 = strchr(v16, 44);
          if (v17)
          {
            v18 = v17 - v16;
            v19 = v17 + 1;
            if (kex_get_method_by_name(v16, v17 - v16, v8))
            {
              v16 = v19;
            }
            else
            {
              v21 = strlen(v16);
              memmove(v16, v19, v21 - v18);
            }
          }
          else
          {
            v20 = strlen(v16);
            if (kex_get_method_by_name(v16, v20, v8))
              break;
            if (v16 <= v15)
              *v16 = 0;
            else
              *--v16 = 0;
          }
        }
        while (*v16);
      }
      if (!*v15)
      {
        (*(void (**)(char *, uint64_t))(a1 + 24))(v15, a1);
        v9 = "The requested method(s) are not currently supported";
        v10 = a1;
        v11 = 4294967263;
        return _libssh2_error(v10, v11, v9);
      }
      if (*v7)
        (*(void (**)(char *, uint64_t))(a1 + 24))(*v7, a1);
      *v7 = v15;
      return 0;
    default:
      v9 = "Invalid parameter specified for method_type";
      v10 = a1;
      v11 = 4294967262;
      return _libssh2_error(v10, v11, v9);
  }
}

const char **kex_get_method_by_name(const char *a1, size_t a2, const char ***a3)
{
  const char **v3;
  const char ***v6;
  const char **v7;

  v3 = *a3;
  if (*a3)
  {
    v6 = a3 + 1;
    do
    {
      if (strlen(*v3) == a2 && !strncmp(*v3, a1, a2))
        break;
      v7 = *v6++;
      v3 = v7;
    }
    while (v7);
  }
  return v3;
}

uint64_t libssh2_session_supported_algs(uint64_t a1, int a2, uint64_t *a3)
{
  uint64_t v3;
  char ***v5;
  char ***v6;
  char *v7;
  uint64_t v8;
  char **v9;
  uint64_t v10;
  unsigned int v11;
  uint64_t v12;
  char **v13;
  unsigned int v14;
  unsigned int v15;
  char *v16;
  BOOL v17;

  v3 = a1;
  if (a3)
  {
    v5 = libssh2_kex_methods;
    switch(a2)
    {
      case 0:
        goto LABEL_10;
      case 1:
        v6 = libssh2_hostkey_methods();
        goto LABEL_9;
      case 2:
      case 3:
        v6 = libssh2_crypt_methods();
        goto LABEL_9;
      case 4:
      case 5:
        v6 = _libssh2_mac_methods();
        goto LABEL_9;
      case 6:
      case 7:
        v6 = _libssh2_comp_methods(a1);
LABEL_9:
        v5 = v6;
        if (!v6)
          goto LABEL_28;
LABEL_10:
        v9 = *v5;
        if (!*v5)
          goto LABEL_28;
        LODWORD(v10) = 0;
        v11 = 1;
        do
        {
          if (*v9)
            v10 = (v10 + 1);
          else
            v10 = v10;
          v9 = v5[v11++];
        }
        while (v9);
        if (!(_DWORD)v10)
        {
LABEL_28:
          v7 = "No algorithm found";
          a1 = v3;
          v8 = 4294967262;
          return _libssh2_error(a1, v8, v7);
        }
        v12 = (*(uint64_t (**)(uint64_t, uint64_t))(v3 + 8))(8 * v10, v3);
        *a3 = v12;
        if (!v12)
        {
          v7 = "Memory allocation failed";
          a1 = v3;
          v8 = 4294967290;
          return _libssh2_error(a1, v8, v7);
        }
        v13 = *v5;
        if (*v5)
        {
          v14 = 0;
          v15 = 1;
          do
          {
            v16 = *v13;
            if (v16)
              *(_QWORD *)(*a3 + 8 * v14++) = v16;
            v13 = v5[v15++];
            if (v13)
              v17 = v14 >= v10;
            else
              v17 = 1;
          }
          while (!v17);
        }
        else
        {
          v14 = 0;
        }
        if (v14 == (_DWORD)v10)
          return v10;
        (*(void (**)(uint64_t, uint64_t))(v3 + 24))(*a3, v3);
        *a3 = 0;
        v7 = "Internal error";
        break;
      case 10:
        goto LABEL_28;
      default:
        v7 = "Unknown method type";
        v8 = 4294967263;
        return _libssh2_error(a1, v8, v7);
    }
  }
  else
  {
    v7 = "algs must not be NULL";
  }
  a1 = v3;
  v8 = 4294967257;
  return _libssh2_error(a1, v8, v7);
}

const char ***kex_method_strlen(const char ***result)
{
  const char **v1;
  uint64_t v2;
  const char ***v3;
  const char **v4;

  if (result)
  {
    v1 = *result;
    if (*result)
    {
      v2 = 0;
      v3 = result + 1;
      do
      {
        if (!*v1)
          break;
        v2 += strlen(*v1) + 1;
        v4 = *v3++;
        v1 = v4;
      }
      while (v4);
      return (const char ***)(v2 - 1);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t kex_method_list(_DWORD *a1, unsigned int a2, const char ***a3)
{
  const char **v6;
  char *v7;
  const char ***v8;
  const char *v9;
  unsigned int v10;
  char *v11;
  const char **v12;

  _libssh2_htonu32(a1, a2);
  if (!a3)
    return 4;
  v6 = *a3;
  if (!*a3)
    return 4;
  v7 = (char *)(a1 + 1);
  v8 = a3 + 1;
  do
  {
    v9 = *v6;
    if (!*v6)
      break;
    v10 = strlen(*v6);
    memcpy(v7, v9, v10);
    v11 = &v7[v10];
    *v11 = 44;
    v7 = v11 + 1;
    v12 = *v8++;
    v6 = v12;
  }
  while (v12);
  return a2 + 4;
}

uint64_t kex_agree_kex_hostkey(uint64_t a1, char *a2, size_t a3, char *a4, size_t a5)
{
  char *v10;
  char *v11;
  char *v12;
  size_t v13;
  char *v14;
  char *v15;
  const char **method_by_name;
  const char **v17;
  uint64_t result;
  char **v19;
  char ***v20;
  size_t v21;
  char *v22;
  char *v23;
  char **v24;
  int v25;
  _DWORD *v26;
  int v27;
  int v28;
  int v29;

  v10 = *(char **)(a1 + 112);
  if (v10)
  {
    while (*v10)
    {
      v11 = strchr(v10, 44);
      v12 = v11;
      if (v11)
        v13 = v11 - v10;
      else
        v13 = strlen(v10);
      v14 = kex_agree_instr(a2, a3, v10, v13);
      if (v14)
      {
        v15 = v14;
        method_by_name = kex_get_method_by_name(v10, v13, (const char ***)libssh2_kex_methods);
        if (!method_by_name)
          return 0xFFFFFFFFLL;
        v17 = method_by_name;
        result = kex_agree_hostkey(a1, (char)method_by_name[2], a4, a5);
        if (!(_DWORD)result)
        {
          v27 = *(_DWORD *)(a1 + 152);
          v26 = (_DWORD *)(a1 + 152);
          v25 = v27;
          *((_QWORD *)v26 - 1) = v17;
          if (v15 == a2 && v25)
            goto LABEL_28;
          return result;
        }
      }
      v10 = v12 + 1;
      if (!v12)
        return 0xFFFFFFFFLL;
    }
  }
  else
  {
    v19 = libssh2_kex_methods[0];
    if (libssh2_kex_methods[0])
    {
      v20 = off_255D81878;
      while (*v19)
      {
        v21 = strlen(*v19);
        v22 = kex_agree_instr(a2, a3, *v19, v21);
        if (v22)
        {
          v23 = v22;
          if (!kex_agree_hostkey(a1, (char)v19[2], a4, a5))
          {
            v29 = *(_DWORD *)(a1 + 152);
            v26 = (_DWORD *)(a1 + 152);
            v28 = v29;
            *((_QWORD *)v26 - 1) = *(v20 - 1);
            if (v23 != a2 || v28 == 0)
              return 0;
LABEL_28:
            result = 0;
            *v26 = 0;
            return result;
          }
        }
        v24 = *v20++;
        v19 = v24;
        if (!v24)
          return 0xFFFFFFFFLL;
      }
    }
  }
  return 0xFFFFFFFFLL;
}

uint64_t kex_agree_crypt(uint64_t a1, char *a2, size_t a3)
{
  char ***v6;
  const char ***v7;
  char *v8;
  char *v9;
  char *v10;
  size_t v11;
  const char **method_by_name;
  const char ***v13;
  size_t v14;
  const char **v15;
  uint64_t result;

  v6 = libssh2_crypt_methods();
  v7 = (const char ***)v6;
  v8 = *(char **)(a1 + 80);
  if (v8)
  {
    while (*v8)
    {
      v9 = strchr(v8, 44);
      v10 = v9;
      if (v9)
        v11 = v9 - v8;
      else
        v11 = strlen(v8);
      if (kex_agree_instr(a2, a3, v8, v11))
      {
        method_by_name = kex_get_method_by_name(v8, v11, v7);
        if (!method_by_name)
          return 0xFFFFFFFFLL;
        goto LABEL_16;
      }
      v8 = v10 + 1;
      if (!v10)
        return 0xFFFFFFFFLL;
    }
  }
  else
  {
    method_by_name = (const char **)*v6;
    if (*v6)
    {
      v13 = (const char ***)(v6 + 1);
      while (*method_by_name)
      {
        v14 = strlen(*method_by_name);
        if (kex_agree_instr(a2, a3, (char *)*method_by_name, v14))
        {
LABEL_16:
          result = 0;
          *(_QWORD *)(a1 + 24) = method_by_name;
          return result;
        }
        v15 = *v13++;
        method_by_name = v15;
        if (!v15)
          return 0xFFFFFFFFLL;
      }
    }
  }
  return 0xFFFFFFFFLL;
}

uint64_t kex_agree_mac(uint64_t a1, char *a2, size_t a3)
{
  char ***v6;
  const char **method_by_name;
  uint64_t result;
  char *v9;
  char *v10;
  char *v11;
  size_t v12;
  const char ***v13;
  size_t v14;
  const char **v15;

  v6 = _libssh2_mac_methods();
  method_by_name = (const char **)_libssh2_mac_override(*(const char ***)(a1 + 24));
  if (method_by_name)
  {
LABEL_2:
    result = 0;
    *(_QWORD *)(a1 + 40) = method_by_name;
  }
  else
  {
    v9 = *(char **)(a1 + 88);
    if (v9)
    {
      while (*v9)
      {
        v10 = strchr(v9, 44);
        v11 = v10;
        if (v10)
          v12 = v10 - v9;
        else
          v12 = strlen(v9);
        if (kex_agree_instr(a2, a3, v9, v12))
        {
          method_by_name = kex_get_method_by_name(v9, v12, (const char ***)v6);
          if (method_by_name)
            goto LABEL_2;
          return 0xFFFFFFFFLL;
        }
        v9 = v11 + 1;
        if (!v11)
          return 0xFFFFFFFFLL;
      }
    }
    else
    {
      method_by_name = (const char **)*v6;
      if (*v6)
      {
        v13 = (const char ***)(v6 + 1);
        while (*method_by_name)
        {
          v14 = strlen(*method_by_name);
          if (kex_agree_instr(a2, a3, (char *)*method_by_name, v14))
            goto LABEL_2;
          v15 = *v13++;
          method_by_name = v15;
          result = 0xFFFFFFFFLL;
          if (!v15)
            return result;
        }
      }
    }
    return 0xFFFFFFFFLL;
  }
  return result;
}

uint64_t kex_agree_comp(uint64_t a1, uint64_t a2, char *a3, size_t a4)
{
  char ***v7;
  const char ***v8;
  char *v9;
  char *v10;
  char *v11;
  size_t v12;
  const char **method_by_name;
  const char ***v14;
  size_t v15;
  const char **v16;
  uint64_t result;

  v7 = _libssh2_comp_methods(a1);
  v8 = (const char ***)v7;
  v9 = *(char **)(a2 + 96);
  if (v9)
  {
    while (*v9)
    {
      v10 = strchr(v9, 44);
      v11 = v10;
      if (v10)
        v12 = v10 - v9;
      else
        v12 = strlen(v9);
      if (kex_agree_instr(a3, a4, v9, v12))
      {
        method_by_name = kex_get_method_by_name(v9, v12, v8);
        if (!method_by_name)
          return 0xFFFFFFFFLL;
        goto LABEL_16;
      }
      v9 = v11 + 1;
      if (!v11)
        return 0xFFFFFFFFLL;
    }
  }
  else
  {
    method_by_name = (const char **)*v7;
    if (*v7)
    {
      v14 = (const char ***)(v7 + 1);
      while (*method_by_name)
      {
        v15 = strlen(*method_by_name);
        if (kex_agree_instr(a3, a4, (char *)*method_by_name, v15))
        {
LABEL_16:
          result = 0;
          *(_QWORD *)(a2 + 64) = method_by_name;
          return result;
        }
        v16 = *v14++;
        method_by_name = v16;
        if (!v16)
          return 0xFFFFFFFFLL;
      }
    }
  }
  return 0xFFFFFFFFLL;
}

char *kex_agree_instr(char *a1, size_t a2, char *__s2, size_t __n)
{
  _BYTE *v4;
  const char *v9;
  char *v10;
  size_t v11;
  size_t v12;

  v4 = 0;
  if (a1 && __n - 1 < a2)
  {
    if (!strncmp(a1, __s2, __n) && (__n == a2 || a1[__n] == 44))
    {
      return a1;
    }
    else
    {
      v9 = (const char *)memchr(a1, 44, a2);
      if (v9)
      {
        v10 = &a1[a2];
        v11 = __n - (_QWORD)a1;
        do
        {
          v12 = v10 - v9;
          if (v10 - v9 <= __n || v10 - v9 - 1 >= a2)
            break;
          v4 = v9 + 1;
          if (!strncmp(v9 + 1, __s2, __n) && (&v4[v11] == (_BYTE *)a2 || v4[__n] == 44))
            return v4;
          v9 = (const char *)memchr(v4, 44, v12);
        }
        while (v9);
      }
      return 0;
    }
  }
  return v4;
}

uint64_t kex_agree_hostkey(uint64_t a1, char a2, char *a3, size_t a4)
{
  char ***v8;
  const char ***v9;
  char *v10;
  char *v11;
  char *v12;
  size_t v13;
  const char **method_by_name;
  const char **v15;
  void **v16;
  size_t v17;
  const char **v18;
  uint64_t result;

  v8 = libssh2_hostkey_methods();
  v9 = (const char ***)v8;
  v10 = *(char **)(a1 + 120);
  if (v10)
  {
    while (*v10)
    {
      v11 = strchr(v10, 44);
      v12 = v11;
      if (v11)
        v13 = v11 - v10;
      else
        v13 = strlen(v10);
      if (kex_agree_instr(a3, a4, v10, v13))
      {
        method_by_name = kex_get_method_by_name(v10, v13, v9);
        if (!method_by_name)
          return 0xFFFFFFFFLL;
        v15 = method_by_name;
        if (((a2 & 1) == 0 || method_by_name[7]) && ((a2 & 2) == 0 || method_by_name[5]))
          goto LABEL_25;
      }
      v10 = v12 + 1;
      if (!v12)
        return 0xFFFFFFFFLL;
    }
  }
  else if (v8)
  {
    v15 = (const char **)*v8;
    if (*v8)
    {
      v16 = (void **)(v8 + 1);
      while (*v15)
      {
        v17 = strlen(*v15);
        if (kex_agree_instr(a3, a4, (char *)*v15, v17) && ((a2 & 1) == 0 || v15[7]) && ((a2 & 2) == 0 || v15[5]))
        {
LABEL_25:
          result = 0;
          *(_QWORD *)(a1 + 184) = v15;
          return result;
        }
        v18 = (const char **)*v16++;
        v15 = v18;
        if (!v18)
          return 0xFFFFFFFFLL;
      }
    }
  }
  return 0xFFFFFFFFLL;
}

uint64_t kex_method_curve25519_key_exchange(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  const char *v5;
  char *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  size_t v10;
  uint64_t v11;
  uint64_t v12;
  EVP_MD_CTX *v13;
  uint64_t v14;
  const void *v15;
  uint64_t v16;
  char *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  void *v21;
  int v22;
  int v23;
  int v24;
  int v25;
  int v26;
  char v27;
  uint64_t v28;
  _DWORD *v29;
  uint64_t v30;
  const char *v31;
  int v32;
  size_t v33;
  EVP_MD_CTX *v34;
  const char *v35;
  unsigned int v36;
  size_t v37;
  uint64_t v38;
  uint64_t v39;
  _OWORD *v40;
  __int128 v41;
  uint64_t v42;
  void (*v43)(uint64_t, uint64_t);
  uint64_t v44;
  void *v45;
  uint64_t v46;
  unint64_t v47;
  EVP_MD_CTX *v48;
  const void *v49;
  size_t v50;
  uint64_t v51;
  void *v52;
  uint64_t v53;
  unint64_t v54;
  EVP_MD_CTX *v55;
  const void *v56;
  size_t v57;
  uint64_t v58;
  void (*v59)(uint64_t, uint64_t);
  uint64_t v60;
  uint64_t v61;
  unint64_t v62;
  EVP_MD_CTX *v63;
  const void *v64;
  size_t v65;
  uint64_t v66;
  uint64_t v67;
  unint64_t v68;
  EVP_MD_CTX *v69;
  const void *v70;
  size_t v71;
  uint64_t v72;
  void *v73;
  void *v74;
  uint64_t v76;
  void (*v77)(uint64_t, uint64_t);
  uint64_t v78;
  void *v79;
  uint64_t v80;
  unint64_t v81;
  EVP_MD_CTX *v82;
  const void *v83;
  size_t v84;
  uint64_t v85;
  void (*v86)(uint64_t, uint64_t);
  uint64_t v87;
  void *v88;
  uint64_t v89;
  unint64_t v90;
  EVP_MD_CTX *v91;
  const void *v92;
  size_t v93;
  uint64_t v94;
  void (*v95)(uint64_t, uint64_t, uint64_t);
  unsigned int (*v96)(uint64_t, uint64_t, uint64_t);
  uint64_t v97;
  void (*v98)(uint64_t, _QWORD, uint64_t);
  unsigned int (*v99)(uint64_t, _QWORD, uint64_t);
  EVP_MD_CTX *ctx;
  EVP_MD_CTX *v101[3];
  uint64_t v102;
  size_t cnt;
  void *__src;
  void *d;

  v4 = 0;
  switch(*(_DWORD *)a2)
  {
    case 0:
      *(_QWORD *)(a2 + 576) = 0;
      *(_DWORD *)a2 = 2;
      goto LABEL_3;
    case 2:
LABEL_3:
      v101[0] = 0;
      v5 = **(const char ***)(a1 + 144);
      if (strcmp(v5, "curve25519-sha256@libssh.org") && strcmp(v5, "curve25519-sha256"))
      {
        v6 = "Unknown KEX curve25519 curve type";
        v7 = a1;
        v8 = 0xFFFFFFFFLL;
LABEL_26:
        v4 = _libssh2_error(v7, v8, v6);
LABEL_123:
        v73 = *(void **)(a2 + 592);
        if (v73)
        {
          memset_s(v73, 0x20uLL, 0, 0x20uLL);
          (*(void (**)(_QWORD, uint64_t))(a1 + 24))(*(_QWORD *)(a2 + 592), a1);
          *(_QWORD *)(a2 + 592) = 0;
        }
        v74 = *(void **)(a2 + 600);
        if (v74)
        {
          memset_s(v74, 0x20uLL, 0, 0x20uLL);
          (*(void (**)(_QWORD, uint64_t))(a1 + 24))(*(_QWORD *)(a2 + 600), a1);
          *(_QWORD *)(a2 + 600) = 0;
        }
        *(_DWORD *)a2 = 0;
        return v4;
      }
      v9 = _libssh2_curve25519_new(a1, (uint64_t *)(a2 + 592), (uint64_t *)(a2 + 600));
      if ((_DWORD)v9)
      {
        v8 = v9;
        v6 = "Unable to create private key";
        v7 = a1;
        goto LABEL_26;
      }
      *(_BYTE *)(a2 + 288) = 30;
      v101[0] = (EVP_MD_CTX *)(a2 + 289);
      _libssh2_store_str((_DWORD **)v101, *(const void **)(a2 + 592), 0x20uLL);
      v10 = 37;
      *(_QWORD *)(a2 + 552) = 37;
      *(_DWORD *)a2 = 3;
LABEL_10:
      v11 = _libssh2_transport_send(a1, (void *)(a2 + 288), v10, 0, 0);
      v4 = v11;
      if ((_DWORD)v11 == -37)
        return v4;
      if ((_DWORD)v11)
      {
        v6 = "Unable to send ECDH_INIT";
        goto LABEL_25;
      }
      *(_DWORD *)a2 = 4;
LABEL_13:
      v12 = _libssh2_packet_require(a1, 31, (_QWORD *)(a2 + 544), (unint64_t *)(a2 + 560), 0, 0, 0, a2 + 8);
      v4 = v12;
      if ((_DWORD)v12 == -37)
        return v4;
      if ((_DWORD)v12)
      {
        v6 = "Timeout waiting for ECDH_REPLY reply";
LABEL_25:
        v7 = a1;
        v8 = v4;
        goto LABEL_26;
      }
      *(_DWORD *)a2 = 5;
LABEL_16:
      v13 = *(EVP_MD_CTX **)(a2 + 560);
      if ((unint64_t)v13 > 4)
      {
        v4 = 0;
        v14 = *(_QWORD *)(a2 + 544);
        v15 = *(const void **)(a2 + 592);
        v16 = *(_QWORD *)(a2 + 600);
        switch(*(_DWORD *)(a2 + 24))
        {
          case 0:
            *(_QWORD *)(a2 + 184) = BN_new();
            *(_DWORD *)(a2 + 24) = 2;
            goto LABEL_20;
          case 2:
LABEL_20:
            __src = 0;
            d = 0;
            v102 = 0;
            cnt = 0;
            v101[0] = (EVP_MD_CTX *)v14;
            v101[1] = (EVP_MD_CTX *)(v14 + 1);
            v101[2] = v13;
            if (_libssh2_get_string(v101, &__src, &v102))
            {
              v17 = "Unexpected curve25519 key length 2";
LABEL_22:
              v18 = a1;
              v19 = 4294967282;
LABEL_117:
              v4 = _libssh2_error(v18, v19, v17);
LABEL_118:
              BN_clear_free(*(BIGNUM **)(a2 + 184));
              *(_QWORD *)(a2 + 184) = 0;
              v72 = *(_QWORD *)(a2 + 200);
              if (v72)
              {
                (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v72, a1);
                *(_QWORD *)(a2 + 200) = 0;
              }
              *(_DWORD *)(a2 + 24) = 0;
              goto LABEL_121;
            }
            v20 = v102;
            *(_DWORD *)(a1 + 208) = v102;
            v21 = (void *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 8))(v20, a1);
            *(_QWORD *)(a1 + 200) = v21;
            if (v21)
            {
              memcpy(v21, __src, *(unsigned int *)(a1 + 208));
              ctx = 0;
              if (_libssh2_md5_init(&ctx))
              {
                EVP_DigestUpdate(ctx, *(const void **)(a1 + 200), *(unsigned int *)(a1 + 208));
                EVP_DigestFinal(ctx, (unsigned __int8 *)(a1 + 212), 0);
                EVP_MD_CTX_free(ctx);
                v22 = 1;
              }
              else
              {
                v22 = 0;
              }
              *(_DWORD *)(a1 + 228) = v22;
              ctx = 0;
              if (_libssh2_sha1_init(&ctx))
              {
                EVP_DigestUpdate(ctx, *(const void **)(a1 + 200), *(unsigned int *)(a1 + 208));
                EVP_DigestFinal(ctx, (unsigned __int8 *)(a1 + 232), 0);
                EVP_MD_CTX_free(ctx);
                v23 = 1;
              }
              else
              {
                v23 = 0;
              }
              *(_DWORD *)(a1 + 252) = v23;
              ctx = 0;
              if (_libssh2_sha256_init(&ctx))
              {
                EVP_DigestUpdate(ctx, *(const void **)(a1 + 200), *(unsigned int *)(a1 + 208));
                EVP_DigestFinal(ctx, (unsigned __int8 *)(a1 + 256), 0);
                EVP_MD_CTX_free(ctx);
                v24 = 1;
              }
              else
              {
                v24 = 0;
              }
              *(_DWORD *)(a1 + 288) = v24;
              if ((*(unsigned int (**)(uint64_t, _QWORD, _QWORD, uint64_t))(*(_QWORD *)(a1 + 184) + 16))(a1, *(_QWORD *)(a1 + 200), *(unsigned int *)(a1 + 208), a1 + 192))
              {
                v17 = "Unable to initialize hostkey importer curve25519";
LABEL_41:
                v18 = a1;
                v19 = 4294967286;
                goto LABEL_117;
              }
              if (_libssh2_get_string(v101, &d, &cnt))
              {
                v17 = "Unexpected curve25519 key length";
                goto LABEL_22;
              }
              if (cnt != 32)
              {
                v17 = "Unexpected curve25519 server public key length";
                goto LABEL_41;
              }
              if (_libssh2_get_string(v101, (_QWORD *)(a2 + 208), (_QWORD *)(a2 + 232)))
              {
                v17 = "Unexpected curve25519 server sig length";
                goto LABEL_41;
              }
              if (_libssh2_curve25519_gen_k((BIGNUM **)(a2 + 184), v16, (uint64_t)d))
              {
                v17 = "Unable to create curve25519 shared secret";
                v18 = a1;
                v19 = 4294967291;
                goto LABEL_117;
              }
              v25 = BN_num_bits(*(const BIGNUM **)(a2 + 184));
              v26 = v25 + 7;
              if (v25 < -7)
                v26 = v25 + 14;
              *(_QWORD *)(a2 + 224) = (v26 >> 3) + 5;
              v27 = BN_num_bits(*(const BIGNUM **)(a2 + 184));
              v28 = *(_QWORD *)(a2 + 224);
              if ((v27 & 7) != 0)
                *(_QWORD *)(a2 + 224) = --v28;
              v29 = (_DWORD *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 8))(v28, a1);
              *(_QWORD *)(a2 + 200) = v29;
              if (!v29)
              {
                v17 = "Unable to allocate buffer for K";
                goto LABEL_31;
              }
              _libssh2_htonu32(v29, *(_DWORD *)(a2 + 224) - 4);
              if ((BN_num_bits(*(const BIGNUM **)(a2 + 184)) & 7) != 0)
              {
                v30 = 4;
              }
              else
              {
                *(_BYTE *)(*(_QWORD *)(a2 + 200) + 4) = 0;
                v30 = 5;
              }
              BN_bn2bin(*(const BIGNUM **)(a2 + 184), (unsigned __int8 *)(*(_QWORD *)(a2 + 200) + v30));
              ctx = 0;
              *(_QWORD *)(a2 + 240) = &ctx;
              _libssh2_sha256_init(&ctx);
              v31 = *(const char **)(a1 + 424);
              if (v31)
              {
                v32 = strlen(v31);
                _libssh2_htonu32((_DWORD *)(a2 + 56), v32 - 2);
                EVP_DigestUpdate(ctx, (const void *)(a2 + 56), 4uLL);
                v33 = strlen(*(const char **)(a1 + 424)) - 2;
                v34 = ctx;
                v35 = *(const char **)(a1 + 424);
              }
              else
              {
                _libssh2_htonu32((_DWORD *)(a2 + 56), 0x16u);
                EVP_DigestUpdate(ctx, (const void *)(a2 + 56), 4uLL);
                v34 = ctx;
                v35 = "SSH-2.0-libssh2_1.11.0";
                v33 = 22;
              }
              EVP_DigestUpdate(v34, v35, v33);
              v36 = strlen(*(const char **)(a1 + 312));
              _libssh2_htonu32((_DWORD *)(a2 + 56), v36);
              EVP_DigestUpdate(ctx, (const void *)(a2 + 56), 4uLL);
              v37 = strlen(*(const char **)(a1 + 312));
              EVP_DigestUpdate(ctx, *(const void **)(a1 + 312), v37);
              _libssh2_htonu32((_DWORD *)(a2 + 56), *(_DWORD *)(a1 + 440));
              EVP_DigestUpdate(ctx, (const void *)(a2 + 56), 4uLL);
              EVP_DigestUpdate(ctx, *(const void **)(a1 + 432), *(_QWORD *)(a1 + 440));
              _libssh2_htonu32((_DWORD *)(a2 + 56), *(_DWORD *)(a1 + 328));
              EVP_DigestUpdate(ctx, (const void *)(a2 + 56), 4uLL);
              EVP_DigestUpdate(ctx, *(const void **)(a1 + 320), *(_QWORD *)(a1 + 328));
              _libssh2_htonu32((_DWORD *)(a2 + 56), *(_DWORD *)(a1 + 208));
              EVP_DigestUpdate(ctx, (const void *)(a2 + 56), 4uLL);
              EVP_DigestUpdate(ctx, *(const void **)(a1 + 200), *(unsigned int *)(a1 + 208));
              _libssh2_htonu32((_DWORD *)(a2 + 56), 0x20u);
              EVP_DigestUpdate(ctx, (const void *)(a2 + 56), 4uLL);
              EVP_DigestUpdate(ctx, v15, 0x20uLL);
              _libssh2_htonu32((_DWORD *)(a2 + 56), cnt);
              EVP_DigestUpdate(ctx, (const void *)(a2 + 56), 4uLL);
              EVP_DigestUpdate(ctx, d, cnt);
              EVP_DigestUpdate(ctx, *(const void **)(a2 + 200), *(_QWORD *)(a2 + 224));
              EVP_DigestFinal(ctx, (unsigned __int8 *)(a2 + 56), 0);
              EVP_MD_CTX_free(ctx);
              if ((*(unsigned int (**)(uint64_t, _QWORD, _QWORD, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(a1 + 184) + 40))(a1, *(_QWORD *)(a2 + 208), *(_QWORD *)(a2 + 232), a2 + 56, 32, a1 + 192))
              {
                v17 = "Unable to verify hostkey signature curve25519";
                v18 = a1;
                v19 = 4294967285;
                goto LABEL_117;
              }
              *(_BYTE *)(a2 + 120) = 21;
              *(_DWORD *)(a2 + 24) = 3;
LABEL_65:
              v38 = _libssh2_transport_send(a1, (void *)(a2 + 120), 1uLL, 0, 0);
              v4 = v38;
              if ((_DWORD)v38 == -37)
                return v4;
              if ((_DWORD)v38)
              {
                v17 = "Unable to send NEWKEYS message curve25519";
              }
              else
              {
                *(_DWORD *)(a2 + 24) = 5;
LABEL_68:
                v39 = _libssh2_packet_require(a1, 21, (_QWORD *)(a2 + 48), (unint64_t *)(a2 + 144), 0, 0, 0, a2 + 248);
                v4 = v39;
                if ((_DWORD)v39 == -37)
                  return v4;
                if (!(_DWORD)v39)
                {
                  *(_DWORD *)(a1 + 128) |= 2u;
                  (*(void (**)(_QWORD, uint64_t))(a1 + 24))(*(_QWORD *)(a2 + 48), a1);
                  if (*(_QWORD *)(a1 + 160))
                    goto LABEL_73;
                  v40 = (_OWORD *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 8))(32, a1);
                  *(_QWORD *)(a1 + 160) = v40;
                  if (v40)
                  {
                    v41 = *(_OWORD *)(a2 + 72);
                    *v40 = *(_OWORD *)(a2 + 56);
                    v40[1] = v41;
                    *(_DWORD *)(a1 + 168) = 32;
LABEL_73:
                    v42 = *(_QWORD *)(a1 + 448);
                    v43 = *(void (**)(uint64_t, uint64_t))(v42 + 56);
                    if (v43)
                    {
                      v43(a1, a1 + 456);
                      v42 = *(_QWORD *)(a1 + 448);
                    }
                    if (*(_QWORD *)(v42 + 40))
                    {
                      LODWORD(d) = 0;
                      LODWORD(__src) = 0;
                      v101[0] = 0;
                      v44 = (*(uint64_t (**)(uint64_t, uint64_t))(a1 + 8))(*(int *)(v42 + 20) + 32, a1);
                      if (!v44)
                      {
                        v4 = 0xFFFFFFFFLL;
                        goto LABEL_118;
                      }
                      v45 = (void *)v44;
                      v46 = *(_QWORD *)(a1 + 448);
                      if (*(_DWORD *)(v46 + 20))
                      {
                        v47 = 0;
                        do
                        {
                          _libssh2_sha256_init(v101);
                          EVP_DigestUpdate(v101[0], *(const void **)(a2 + 200), *(_QWORD *)(a2 + 224));
                          EVP_DigestUpdate(v101[0], (const void *)(a2 + 56), 0x20uLL);
                          v48 = v101[0];
                          if (v47)
                          {
                            v49 = v45;
                            v50 = v47;
                          }
                          else
                          {
                            EVP_DigestUpdate(v101[0], "A", 1uLL);
                            v48 = v101[0];
                            v49 = *(const void **)(a1 + 160);
                            v50 = *(unsigned int *)(a1 + 168);
                          }
                          EVP_DigestUpdate(v48, v49, v50);
                          EVP_DigestFinal(v101[0], (unsigned __int8 *)v45 + v47, 0);
                          EVP_MD_CTX_free(v101[0]);
                          v47 += 32;
                          v46 = *(_QWORD *)(a1 + 448);
                        }
                        while (v47 < *(int *)(v46 + 20));
                      }
                      v101[0] = 0;
                      v51 = (*(uint64_t (**)(uint64_t, uint64_t))(a1 + 8))(*(int *)(v46 + 24) + 32, a1);
                      if (!v51)
                        goto LABEL_130;
                      v52 = (void *)v51;
                      v53 = *(_QWORD *)(a1 + 448);
                      if (*(_DWORD *)(v53 + 24))
                      {
                        v54 = 0;
                        do
                        {
                          _libssh2_sha256_init(v101);
                          EVP_DigestUpdate(v101[0], *(const void **)(a2 + 200), *(_QWORD *)(a2 + 224));
                          EVP_DigestUpdate(v101[0], (const void *)(a2 + 56), 0x20uLL);
                          v55 = v101[0];
                          if (v54)
                          {
                            v56 = v52;
                            v57 = v54;
                          }
                          else
                          {
                            EVP_DigestUpdate(v101[0], "C", 1uLL);
                            v55 = v101[0];
                            v56 = *(const void **)(a1 + 160);
                            v57 = *(unsigned int *)(a1 + 168);
                          }
                          EVP_DigestUpdate(v55, v56, v57);
                          EVP_DigestFinal(v101[0], (unsigned __int8 *)v52 + v54, 0);
                          EVP_MD_CTX_free(v101[0]);
                          v54 += 32;
                          v53 = *(_QWORD *)(a1 + 448);
                        }
                        while (v54 < *(int *)(v53 + 24));
                      }
                      if ((*(unsigned int (**)(uint64_t))(v53 + 40))(a1))
                        goto LABEL_113;
                      if ((_DWORD)d)
                      {
                        memset_s(v45, *(int *)(*(_QWORD *)(a1 + 448) + 20), 0, *(int *)(*(_QWORD *)(a1 + 448) + 20));
                        (*(void (**)(void *, uint64_t))(a1 + 24))(v45, a1);
                      }
                      if ((_DWORD)__src)
                      {
                        memset_s(v52, *(int *)(*(_QWORD *)(a1 + 448) + 24), 0, *(int *)(*(_QWORD *)(a1 + 448) + 24));
                        (*(void (**)(void *, uint64_t))(a1 + 24))(v52, a1);
                      }
                    }
                    v58 = *(_QWORD *)(a1 + 336);
                    v59 = *(void (**)(uint64_t, uint64_t))(v58 + 56);
                    if (v59)
                    {
                      v59(a1, a1 + 344);
                      v58 = *(_QWORD *)(a1 + 336);
                    }
                    if (!*(_QWORD *)(v58 + 40))
                      goto LABEL_137;
                    LODWORD(d) = 0;
                    LODWORD(__src) = 0;
                    v101[0] = 0;
                    v60 = (*(uint64_t (**)(uint64_t, uint64_t))(a1 + 8))(*(int *)(v58 + 20) + 32, a1);
                    if (!v60)
                    {
LABEL_131:
                      v4 = 4294967291;
                      goto LABEL_118;
                    }
                    v45 = (void *)v60;
                    v61 = *(_QWORD *)(a1 + 336);
                    if (*(_DWORD *)(v61 + 20))
                    {
                      v62 = 0;
                      do
                      {
                        _libssh2_sha256_init(v101);
                        EVP_DigestUpdate(v101[0], *(const void **)(a2 + 200), *(_QWORD *)(a2 + 224));
                        EVP_DigestUpdate(v101[0], (const void *)(a2 + 56), 0x20uLL);
                        v63 = v101[0];
                        if (v62)
                        {
                          v64 = v45;
                          v65 = v62;
                        }
                        else
                        {
                          EVP_DigestUpdate(v101[0], "B", 1uLL);
                          v63 = v101[0];
                          v64 = *(const void **)(a1 + 160);
                          v65 = *(unsigned int *)(a1 + 168);
                        }
                        EVP_DigestUpdate(v63, v64, v65);
                        EVP_DigestFinal(v101[0], (unsigned __int8 *)v45 + v62, 0);
                        EVP_MD_CTX_free(v101[0]);
                        v62 += 32;
                        v61 = *(_QWORD *)(a1 + 336);
                      }
                      while (v62 < *(int *)(v61 + 20));
                    }
                    v101[0] = 0;
                    v66 = (*(uint64_t (**)(uint64_t, uint64_t))(a1 + 8))(*(int *)(v61 + 24) + 32, a1);
                    if (v66)
                    {
                      v52 = (void *)v66;
                      v67 = *(_QWORD *)(a1 + 336);
                      if (*(_DWORD *)(v67 + 24))
                      {
                        v68 = 0;
                        do
                        {
                          _libssh2_sha256_init(v101);
                          EVP_DigestUpdate(v101[0], *(const void **)(a2 + 200), *(_QWORD *)(a2 + 224));
                          EVP_DigestUpdate(v101[0], (const void *)(a2 + 56), 0x20uLL);
                          v69 = v101[0];
                          if (v68)
                          {
                            v70 = v52;
                            v71 = v68;
                          }
                          else
                          {
                            EVP_DigestUpdate(v101[0], "D", 1uLL);
                            v69 = v101[0];
                            v70 = *(const void **)(a1 + 160);
                            v71 = *(unsigned int *)(a1 + 168);
                          }
                          EVP_DigestUpdate(v69, v70, v71);
                          EVP_DigestFinal(v101[0], (unsigned __int8 *)v52 + v68, 0);
                          EVP_MD_CTX_free(v101[0]);
                          v68 += 32;
                          v67 = *(_QWORD *)(a1 + 336);
                        }
                        while (v68 < *(int *)(v67 + 24));
                      }
                      if ((*(unsigned int (**)(uint64_t))(v67 + 40))(a1))
                      {
LABEL_113:
                        (*(void (**)(void *, uint64_t))(a1 + 24))(v45, a1);
                        (*(void (**)(void *, uint64_t))(a1 + 24))(v52, a1);
                        goto LABEL_131;
                      }
                      if ((_DWORD)d)
                      {
                        memset_s(v45, *(int *)(*(_QWORD *)(a1 + 336) + 20), 0, *(int *)(*(_QWORD *)(a1 + 336) + 20));
                        (*(void (**)(void *, uint64_t))(a1 + 24))(v45, a1);
                      }
                      if ((_DWORD)__src)
                      {
                        memset_s(v52, *(int *)(*(_QWORD *)(a1 + 336) + 24), 0, *(int *)(*(_QWORD *)(a1 + 336) + 24));
                        (*(void (**)(void *, uint64_t))(a1 + 24))(v52, a1);
                      }
LABEL_137:
                      v76 = *(_QWORD *)(a1 + 464);
                      v77 = *(void (**)(uint64_t, uint64_t))(v76 + 32);
                      if (v77)
                      {
                        v77(a1, a1 + 480);
                        v76 = *(_QWORD *)(a1 + 464);
                      }
                      if (*(_QWORD *)(v76 + 16))
                      {
                        LODWORD(d) = 0;
                        v101[0] = 0;
                        v78 = (*(uint64_t (**)(uint64_t, uint64_t))(a1 + 8))(*(int *)(v76 + 12) + 32, a1);
                        if (!v78)
                          goto LABEL_131;
                        v79 = (void *)v78;
                        v80 = *(_QWORD *)(a1 + 464);
                        if (*(_DWORD *)(v80 + 12))
                        {
                          v81 = 0;
                          do
                          {
                            _libssh2_sha256_init(v101);
                            EVP_DigestUpdate(v101[0], *(const void **)(a2 + 200), *(_QWORD *)(a2 + 224));
                            EVP_DigestUpdate(v101[0], (const void *)(a2 + 56), 0x20uLL);
                            v82 = v101[0];
                            if (v81)
                            {
                              v83 = v79;
                              v84 = v81;
                            }
                            else
                            {
                              EVP_DigestUpdate(v101[0], "E", 1uLL);
                              v82 = v101[0];
                              v83 = *(const void **)(a1 + 160);
                              v84 = *(unsigned int *)(a1 + 168);
                            }
                            EVP_DigestUpdate(v82, v83, v84);
                            EVP_DigestFinal(v101[0], (unsigned __int8 *)v79 + v81, 0);
                            EVP_MD_CTX_free(v101[0]);
                            v81 += 32;
                            v80 = *(_QWORD *)(a1 + 464);
                          }
                          while (v81 < *(int *)(v80 + 12));
                        }
                        (*(void (**)(uint64_t, void *, void **, uint64_t))(v80 + 16))(a1, v79, &d, a1 + 480);
                        if ((_DWORD)d)
                        {
                          memset_s(v79, *(int *)(*(_QWORD *)(a1 + 464) + 12), 0, *(int *)(*(_QWORD *)(a1 + 464) + 12));
                          (*(void (**)(void *, uint64_t))(a1 + 24))(v79, a1);
                        }
                      }
                      v85 = *(_QWORD *)(a1 + 352);
                      v86 = *(void (**)(uint64_t, uint64_t))(v85 + 32);
                      if (v86)
                      {
                        v86(a1, a1 + 368);
                        v85 = *(_QWORD *)(a1 + 352);
                      }
                      if (*(_QWORD *)(v85 + 16))
                      {
                        LODWORD(d) = 0;
                        v101[0] = 0;
                        v87 = (*(uint64_t (**)(uint64_t, uint64_t))(a1 + 8))(*(int *)(v85 + 12) + 32, a1);
                        if (!v87)
                          goto LABEL_131;
                        v88 = (void *)v87;
                        v89 = *(_QWORD *)(a1 + 352);
                        if (*(_DWORD *)(v89 + 12))
                        {
                          v90 = 0;
                          do
                          {
                            _libssh2_sha256_init(v101);
                            EVP_DigestUpdate(v101[0], *(const void **)(a2 + 200), *(_QWORD *)(a2 + 224));
                            EVP_DigestUpdate(v101[0], (const void *)(a2 + 56), 0x20uLL);
                            v91 = v101[0];
                            if (v90)
                            {
                              v92 = v88;
                              v93 = v90;
                            }
                            else
                            {
                              EVP_DigestUpdate(v101[0], "F", 1uLL);
                              v91 = v101[0];
                              v92 = *(const void **)(a1 + 160);
                              v93 = *(unsigned int *)(a1 + 168);
                            }
                            EVP_DigestUpdate(v91, v92, v93);
                            EVP_DigestFinal(v101[0], (unsigned __int8 *)v88 + v90, 0);
                            EVP_MD_CTX_free(v101[0]);
                            v90 += 32;
                            v89 = *(_QWORD *)(a1 + 352);
                          }
                          while (v90 < *(int *)(v89 + 12));
                        }
                        (*(void (**)(uint64_t, void *, void **, uint64_t))(v89 + 16))(a1, v88, &d, a1 + 368);
                        if ((_DWORD)d)
                        {
                          memset_s(v88, *(int *)(*(_QWORD *)(a1 + 352) + 12), 0, *(int *)(*(_QWORD *)(a1 + 352) + 12));
                          (*(void (**)(void *, uint64_t))(a1 + 24))(v88, a1);
                        }
                      }
                      v94 = *(_QWORD *)(a1 + 488);
                      if (!v94
                        || (v95 = *(void (**)(uint64_t, uint64_t, uint64_t))(v94 + 40)) != 0
                        && (v95(a1, 1, a1 + 496), (v94 = *(_QWORD *)(a1 + 488)) == 0)
                        || (v96 = *(unsigned int (**)(uint64_t, uint64_t, uint64_t))(v94 + 16)) == 0
                        || !v96(a1, 1, a1 + 496))
                      {
                        v97 = *(_QWORD *)(a1 + 376);
                        if (v97
                          && ((v98 = *(void (**)(uint64_t, _QWORD, uint64_t))(v97 + 40)) == 0
                           || (v98(a1, 0, a1 + 384), (v97 = *(_QWORD *)(a1 + 376)) != 0))
                          && (v99 = *(unsigned int (**)(uint64_t, _QWORD, uint64_t))(v97 + 16)) != 0)
                        {
                          if (v99(a1, 0, a1 + 384))
                            v4 = 4294967291;
                          else
                            v4 = 0;
                        }
                        else
                        {
                          v4 = 0;
                        }
                        goto LABEL_118;
                      }
                      goto LABEL_131;
                    }
LABEL_130:
                    (*(void (**)(void *, uint64_t))(a1 + 24))(v45, a1);
                    goto LABEL_131;
                  }
                  v17 = "Unable to allocate buffer for SHA digest";
LABEL_31:
                  v18 = a1;
                  v19 = 4294967290;
                  goto LABEL_117;
                }
                v17 = "Timed out waiting for NEWKEYS curve25519";
              }
              v18 = a1;
              v19 = v4;
              goto LABEL_117;
            }
            v17 = "Unable to allocate memory for a copy of the host curve25519 key";
            goto LABEL_31;
          case 3:
            goto LABEL_65;
          case 5:
            goto LABEL_68;
          default:
            goto LABEL_118;
        }
      }
      v4 = _libssh2_error(a1, 4294967286, "Data is too short");
LABEL_121:
      if ((_DWORD)v4 != -37)
      {
        (*(void (**)(_QWORD, uint64_t))(a1 + 24))(*(_QWORD *)(a2 + 544), a1);
        goto LABEL_123;
      }
      return v4;
    case 3:
      v10 = *(_QWORD *)(a2 + 552);
      goto LABEL_10;
    case 4:
      goto LABEL_13;
    case 5:
      goto LABEL_16;
    default:
      goto LABEL_123;
  }
}

uint64_t kex_method_ecdh_key_exchange(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t key;
  uint64_t v6;
  char *v7;
  uint64_t v8;
  size_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  EC_KEY *v13;
  int v15;
  _DWORD *v16;

  v4 = 0;
  v16 = 0;
  v15 = 0;
  switch(*(_DWORD *)a2)
  {
    case 0:
      *(_QWORD *)(a2 + 576) = 0;
      *(_DWORD *)a2 = 2;
      goto LABEL_3;
    case 2:
LABEL_3:
      if (kex_session_ecdh_curve_type(**(const char ***)(a1 + 144), &v15))
        goto LABEL_15;
      key = _libssh2_ecdsa_create_key(a1, (EC_KEY **)(a2 + 568), (_QWORD *)(a2 + 576), (size_t *)(a2 + 584), v15);
      if ((_DWORD)key)
      {
        v6 = key;
        v7 = "Unable to create private key";
        v8 = a1;
        goto LABEL_21;
      }
      *(_BYTE *)(a2 + 288) = 30;
      v16 = (_DWORD *)(a2 + 289);
      _libssh2_store_str(&v16, *(const void **)(a2 + 576), *(_QWORD *)(a2 + 584));
      v9 = *(_QWORD *)(a2 + 584) + 5;
      *(_QWORD *)(a2 + 552) = v9;
      *(_DWORD *)a2 = 3;
LABEL_8:
      v10 = _libssh2_transport_send(a1, (void *)(a2 + 288), v9, 0, 0);
      v4 = v10;
      if ((_DWORD)v10 == -37)
        return v4;
      if ((_DWORD)v10)
      {
        v7 = "Unable to send ECDH_INIT";
        goto LABEL_20;
      }
      *(_DWORD *)a2 = 4;
LABEL_11:
      v11 = _libssh2_packet_require(a1, 31, (_QWORD *)(a2 + 544), (unint64_t *)(a2 + 560), 0, 0, 0, a2 + 8);
      v4 = v11;
      if ((_DWORD)v11 != -37)
      {
        if (!(_DWORD)v11)
        {
          *(_DWORD *)a2 = 5;
LABEL_14:
          if (!kex_session_ecdh_curve_type(**(const char ***)(a1 + 144), &v15))
          {
            v4 = ecdh_sha2_nistp(a1, v15, *(_QWORD *)(a2 + 544), *(EVP_MD_CTX **)(a2 + 560), *(const void **)(a2 + 576), *(_QWORD *)(a2 + 584), *(const EC_KEY **)(a2 + 568), a2 + 24);
            if ((_DWORD)v4 == -37)
              return v4;
            (*(void (**)(_QWORD, uint64_t))(a1 + 24))(*(_QWORD *)(a2 + 544), a1);
            goto LABEL_22;
          }
LABEL_15:
          v7 = "Unknown KEX nistp curve type";
          v8 = a1;
          v6 = 0xFFFFFFFFLL;
LABEL_21:
          v4 = _libssh2_error(v8, v6, v7);
LABEL_22:
          v12 = *(_QWORD *)(a2 + 576);
          if (v12)
          {
            (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v12, a1);
            *(_QWORD *)(a2 + 576) = 0;
          }
          v13 = *(EC_KEY **)(a2 + 568);
          if (v13)
          {
            EC_KEY_free(v13);
            *(_QWORD *)(a2 + 568) = 0;
          }
          *(_DWORD *)a2 = 0;
          return v4;
        }
        v7 = "Timeout waiting for ECDH_REPLY reply";
LABEL_20:
        v8 = a1;
        v6 = v4;
        goto LABEL_21;
      }
      return v4;
    case 3:
      v9 = *(_QWORD *)(a2 + 552);
      goto LABEL_8;
    case 4:
      goto LABEL_11;
    case 5:
      goto LABEL_14;
    default:
      goto LABEL_22;
  }
}

uint64_t kex_session_ecdh_curve_type(const char *a1, int *a2)
{
  uint64_t result;
  int v5;
  BOOL v6;
  _BOOL4 v7;
  int v8;

  if (!a1)
    return 0xFFFFFFFFLL;
  result = strcmp(a1, "ecdh-sha2-nistp256");
  if (!(_DWORD)result)
  {
    v8 = 415;
    goto LABEL_15;
  }
  result = strcmp(a1, "ecdh-sha2-nistp384");
  if (!(_DWORD)result)
  {
    v8 = 715;
LABEL_15:
    v7 = 1;
    if (!a2)
      return result;
    goto LABEL_16;
  }
  v5 = strcmp(a1, "ecdh-sha2-nistp521");
  v6 = v5 == 0;
  v7 = v5 == 0;
  if (v5)
    result = 0xFFFFFFFFLL;
  else
    result = 0;
  if (v6)
    v8 = 716;
  else
    v8 = 0;
  if (a2)
  {
LABEL_16:
    if (v7)
      *a2 = v8;
  }
  return result;
}

uint64_t ecdh_sha2_nistp(uint64_t a1, int a2, uint64_t a3, EVP_MD_CTX *a4, const void *a5, size_t a6, const EC_KEY *a7, uint64_t a8)
{
  uint64_t v11;
  char *v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  int v22;
  int v23;
  int v24;
  int v25;
  char v26;
  uint64_t v27;
  _DWORD *v28;
  uint64_t v29;
  const char *v30;
  int v31;
  size_t v32;
  EVP_MD_CTX *v33;
  const char *v34;
  const char *v35;
  int v36;
  size_t v37;
  EVP_MD_CTX *v38;
  const char *v39;
  const char *v40;
  int v41;
  size_t v42;
  EVP_MD_CTX *v43;
  const char *v44;
  unsigned int v45;
  size_t v46;
  int v47;
  unsigned int v48;
  size_t v49;
  unsigned int v50;
  size_t v51;
  uint64_t v52;
  uint64_t v53;
  size_t v54;
  uint64_t v55;
  void *v56;
  uint64_t v57;
  void (*v58)(uint64_t, uint64_t);
  void *v59;
  unint64_t v60;
  EVP_MD_CTX *v61;
  const void *v62;
  size_t v63;
  unint64_t v64;
  EVP_MD_CTX *v65;
  const void *v66;
  size_t v67;
  unint64_t v68;
  EVP_MD_CTX *v69;
  const void *v70;
  size_t v71;
  void *v72;
  unint64_t v73;
  EVP_MD_CTX *v74;
  const void *v75;
  size_t v76;
  unint64_t v77;
  EVP_MD_CTX *v78;
  const void *v79;
  size_t v80;
  unint64_t v81;
  EVP_MD_CTX *v82;
  const void *v83;
  size_t v84;
  uint64_t v85;
  void (*v86)(uint64_t, uint64_t);
  unint64_t v87;
  EVP_MD_CTX *v88;
  const void *v89;
  size_t v90;
  unint64_t v91;
  EVP_MD_CTX *v92;
  const void *v93;
  size_t v94;
  unint64_t v95;
  EVP_MD_CTX *v96;
  const void *v97;
  size_t v98;
  unint64_t v99;
  EVP_MD_CTX *v100;
  const void *v101;
  size_t v102;
  unint64_t v103;
  EVP_MD_CTX *v104;
  const void *v105;
  size_t v106;
  unint64_t v107;
  EVP_MD_CTX *v108;
  const void *v109;
  size_t v110;
  uint64_t v111;
  void (*v112)(uint64_t, uint64_t);
  void *v113;
  unint64_t v114;
  EVP_MD_CTX *v115;
  const void *v116;
  size_t v117;
  unint64_t v118;
  EVP_MD_CTX *v119;
  const void *v120;
  size_t v121;
  unint64_t v122;
  EVP_MD_CTX *v123;
  const void *v124;
  size_t v125;
  uint64_t v126;
  void (*v127)(uint64_t, uint64_t);
  void *v128;
  unint64_t v129;
  EVP_MD_CTX *v130;
  const void *v131;
  size_t v132;
  unint64_t v133;
  EVP_MD_CTX *v134;
  const void *v135;
  size_t v136;
  unint64_t v137;
  EVP_MD_CTX *v138;
  const void *v139;
  size_t v140;
  uint64_t v141;
  void (*v142)(uint64_t, uint64_t, uint64_t);
  unsigned int (*v143)(uint64_t, uint64_t, uint64_t);
  uint64_t v144;
  void (*v145)(uint64_t, _QWORD, uint64_t);
  unsigned int (*v146)(uint64_t, _QWORD, uint64_t);
  EVP_MD_CTX *ctx;
  EVP_MD_CTX *v148[3];
  size_t v149;
  const unsigned __int8 *v150;

  if ((unint64_t)a4 <= 4)
    return _libssh2_error(a1, 4294967286, "Host key data is too short");
  v11 = 0;
  switch(*(_DWORD *)a8)
  {
    case 0:
      *(_QWORD *)(a8 + 160) = BN_new();
      *(_DWORD *)a8 = 2;
      goto LABEL_5;
    case 2:
LABEL_5:
      v149 = 0;
      v150 = 0;
      v148[0] = (EVP_MD_CTX *)a3;
      v148[1] = (EVP_MD_CTX *)(a3 + 1);
      v148[2] = a4;
      if (_libssh2_copy_string(a1, v148, (_QWORD *)(a1 + 200), &v149))
      {
        v18 = "Unable to allocate memory for a copy of the host ECDH key";
LABEL_7:
        v19 = a1;
        v20 = 4294967290;
LABEL_66:
        v11 = _libssh2_error(v19, v20, v18);
LABEL_67:
        BN_clear_free(*(BIGNUM **)(a8 + 160));
        *(_QWORD *)(a8 + 160) = 0;
        v55 = *(_QWORD *)(a8 + 176);
        if (v55)
        {
          (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v55, a1);
          *(_QWORD *)(a8 + 176) = 0;
        }
        *(_DWORD *)a8 = 0;
        return v11;
      }
      *(_DWORD *)(a1 + 208) = v149;
      ctx = 0;
      if (_libssh2_md5_init(&ctx))
      {
        EVP_DigestUpdate(ctx, *(const void **)(a1 + 200), *(unsigned int *)(a1 + 208));
        EVP_DigestFinal(ctx, (unsigned __int8 *)(a1 + 212), 0);
        EVP_MD_CTX_free(ctx);
        v21 = 1;
      }
      else
      {
        v21 = 0;
      }
      *(_DWORD *)(a1 + 228) = v21;
      ctx = 0;
      if (_libssh2_sha1_init(&ctx))
      {
        EVP_DigestUpdate(ctx, *(const void **)(a1 + 200), *(unsigned int *)(a1 + 208));
        EVP_DigestFinal(ctx, (unsigned __int8 *)(a1 + 232), 0);
        EVP_MD_CTX_free(ctx);
        v22 = 1;
      }
      else
      {
        v22 = 0;
      }
      *(_DWORD *)(a1 + 252) = v22;
      ctx = 0;
      if (_libssh2_sha256_init(&ctx))
      {
        EVP_DigestUpdate(ctx, *(const void **)(a1 + 200), *(unsigned int *)(a1 + 208));
        EVP_DigestFinal(ctx, (unsigned __int8 *)(a1 + 256), 0);
        EVP_MD_CTX_free(ctx);
        v23 = 1;
      }
      else
      {
        v23 = 0;
      }
      *(_DWORD *)(a1 + 288) = v23;
      if ((*(unsigned int (**)(uint64_t, _QWORD, _QWORD, uint64_t))(*(_QWORD *)(a1 + 184) + 16))(a1, *(_QWORD *)(a1 + 200), *(unsigned int *)(a1 + 208), a1 + 192))
      {
        v18 = "Unable to initialize hostkey importer ECDH";
LABEL_19:
        v19 = a1;
        v20 = 4294967286;
        goto LABEL_66;
      }
      if (_libssh2_get_string(v148, &v150, &v149))
      {
        v18 = "Unexpected key length ECDH";
        v19 = a1;
        v20 = 4294967282;
        goto LABEL_66;
      }
      if (_libssh2_get_string(v148, (_QWORD *)(a8 + 184), (_QWORD *)(a8 + 208)))
      {
        v18 = "Unexpected ECDH server sig length";
        goto LABEL_19;
      }
      if (_libssh2_ecdh_gen_k((BIGNUM **)(a8 + 160), a7, v150, v149))
      {
        v18 = "Unable to create ECDH shared secret";
LABEL_99:
        v19 = a1;
        v20 = 4294967291;
        goto LABEL_66;
      }
      v24 = BN_num_bits(*(const BIGNUM **)(a8 + 160));
      v25 = v24 + 7;
      if (v24 < -7)
        v25 = v24 + 14;
      *(_QWORD *)(a8 + 200) = (v25 >> 3) + 5;
      v26 = BN_num_bits(*(const BIGNUM **)(a8 + 160));
      v27 = *(_QWORD *)(a8 + 200);
      if ((v26 & 7) != 0)
        *(_QWORD *)(a8 + 200) = --v27;
      v28 = (_DWORD *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 8))(v27, a1);
      *(_QWORD *)(a8 + 176) = v28;
      if (!v28)
      {
        v18 = "Unable to allocate buffer for ECDH K";
        goto LABEL_7;
      }
      _libssh2_htonu32(v28, *(_DWORD *)(a8 + 200) - 4);
      if ((BN_num_bits(*(const BIGNUM **)(a8 + 160)) & 7) != 0)
      {
        v29 = 4;
      }
      else
      {
        *(_BYTE *)(*(_QWORD *)(a8 + 176) + 4) = 0;
        v29 = 5;
      }
      BN_bn2bin(*(const BIGNUM **)(a8 + 160), (unsigned __int8 *)(*(_QWORD *)(a8 + 176) + v29));
      switch(a2)
      {
        case 716:
          ctx = 0;
          *(_QWORD *)(a8 + 216) = &ctx;
          _libssh2_sha512_init(&ctx);
          v35 = *(const char **)(a1 + 424);
          if (v35)
          {
            v36 = strlen(v35);
            _libssh2_htonu32((_DWORD *)(a8 + 32), v36 - 2);
            EVP_DigestUpdate(ctx, (const void *)(a8 + 32), 4uLL);
            v37 = strlen(*(const char **)(a1 + 424)) - 2;
            v38 = ctx;
            v39 = *(const char **)(a1 + 424);
          }
          else
          {
            _libssh2_htonu32((_DWORD *)(a8 + 32), 0x16u);
            EVP_DigestUpdate(ctx, (const void *)(a8 + 32), 4uLL);
            v38 = ctx;
            v39 = "SSH-2.0-libssh2_1.11.0";
            v37 = 22;
          }
          EVP_DigestUpdate(v38, v39, v37);
          v48 = strlen(*(const char **)(a1 + 312));
          _libssh2_htonu32((_DWORD *)(a8 + 32), v48);
          EVP_DigestUpdate(ctx, (const void *)(a8 + 32), 4uLL);
          v49 = strlen(*(const char **)(a1 + 312));
          EVP_DigestUpdate(ctx, *(const void **)(a1 + 312), v49);
          _libssh2_htonu32((_DWORD *)(a8 + 32), *(_DWORD *)(a1 + 440));
          EVP_DigestUpdate(ctx, (const void *)(a8 + 32), 4uLL);
          EVP_DigestUpdate(ctx, *(const void **)(a1 + 432), *(_QWORD *)(a1 + 440));
          _libssh2_htonu32((_DWORD *)(a8 + 32), *(_DWORD *)(a1 + 328));
          EVP_DigestUpdate(ctx, (const void *)(a8 + 32), 4uLL);
          EVP_DigestUpdate(ctx, *(const void **)(a1 + 320), *(_QWORD *)(a1 + 328));
          _libssh2_htonu32((_DWORD *)(a8 + 32), *(_DWORD *)(a1 + 208));
          EVP_DigestUpdate(ctx, (const void *)(a8 + 32), 4uLL);
          EVP_DigestUpdate(ctx, *(const void **)(a1 + 200), *(unsigned int *)(a1 + 208));
          _libssh2_htonu32((_DWORD *)(a8 + 32), a6);
          EVP_DigestUpdate(ctx, (const void *)(a8 + 32), 4uLL);
          EVP_DigestUpdate(ctx, a5, a6);
          _libssh2_htonu32((_DWORD *)(a8 + 32), v149);
          EVP_DigestUpdate(ctx, (const void *)(a8 + 32), 4uLL);
          EVP_DigestUpdate(ctx, v150, v149);
          EVP_DigestUpdate(ctx, *(const void **)(a8 + 176), *(_QWORD *)(a8 + 200));
          EVP_DigestFinal(ctx, (unsigned __int8 *)(a8 + 32), 0);
          EVP_MD_CTX_free(ctx);
          v47 = (*(uint64_t (**)(uint64_t, _QWORD, _QWORD, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(a1 + 184)
                                                                                              + 40))(a1, *(_QWORD *)(a8 + 184), *(_QWORD *)(a8 + 208), a8 + 32, 64, a1 + 192);
          break;
        case 715:
          ctx = 0;
          *(_QWORD *)(a8 + 216) = &ctx;
          _libssh2_sha384_init(&ctx);
          v40 = *(const char **)(a1 + 424);
          if (v40)
          {
            v41 = strlen(v40);
            _libssh2_htonu32((_DWORD *)(a8 + 32), v41 - 2);
            EVP_DigestUpdate(ctx, (const void *)(a8 + 32), 4uLL);
            v42 = strlen(*(const char **)(a1 + 424)) - 2;
            v43 = ctx;
            v44 = *(const char **)(a1 + 424);
          }
          else
          {
            _libssh2_htonu32((_DWORD *)(a8 + 32), 0x16u);
            EVP_DigestUpdate(ctx, (const void *)(a8 + 32), 4uLL);
            v43 = ctx;
            v44 = "SSH-2.0-libssh2_1.11.0";
            v42 = 22;
          }
          EVP_DigestUpdate(v43, v44, v42);
          v50 = strlen(*(const char **)(a1 + 312));
          _libssh2_htonu32((_DWORD *)(a8 + 32), v50);
          EVP_DigestUpdate(ctx, (const void *)(a8 + 32), 4uLL);
          v51 = strlen(*(const char **)(a1 + 312));
          EVP_DigestUpdate(ctx, *(const void **)(a1 + 312), v51);
          _libssh2_htonu32((_DWORD *)(a8 + 32), *(_DWORD *)(a1 + 440));
          EVP_DigestUpdate(ctx, (const void *)(a8 + 32), 4uLL);
          EVP_DigestUpdate(ctx, *(const void **)(a1 + 432), *(_QWORD *)(a1 + 440));
          _libssh2_htonu32((_DWORD *)(a8 + 32), *(_DWORD *)(a1 + 328));
          EVP_DigestUpdate(ctx, (const void *)(a8 + 32), 4uLL);
          EVP_DigestUpdate(ctx, *(const void **)(a1 + 320), *(_QWORD *)(a1 + 328));
          _libssh2_htonu32((_DWORD *)(a8 + 32), *(_DWORD *)(a1 + 208));
          EVP_DigestUpdate(ctx, (const void *)(a8 + 32), 4uLL);
          EVP_DigestUpdate(ctx, *(const void **)(a1 + 200), *(unsigned int *)(a1 + 208));
          _libssh2_htonu32((_DWORD *)(a8 + 32), a6);
          EVP_DigestUpdate(ctx, (const void *)(a8 + 32), 4uLL);
          EVP_DigestUpdate(ctx, a5, a6);
          _libssh2_htonu32((_DWORD *)(a8 + 32), v149);
          EVP_DigestUpdate(ctx, (const void *)(a8 + 32), 4uLL);
          EVP_DigestUpdate(ctx, v150, v149);
          EVP_DigestUpdate(ctx, *(const void **)(a8 + 176), *(_QWORD *)(a8 + 200));
          EVP_DigestFinal(ctx, (unsigned __int8 *)(a8 + 32), 0);
          EVP_MD_CTX_free(ctx);
          v47 = (*(uint64_t (**)(uint64_t, _QWORD, _QWORD, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(a1 + 184)
                                                                                              + 40))(a1, *(_QWORD *)(a8 + 184), *(_QWORD *)(a8 + 208), a8 + 32, 48, a1 + 192);
          break;
        case 415:
          ctx = 0;
          *(_QWORD *)(a8 + 216) = &ctx;
          _libssh2_sha256_init(&ctx);
          v30 = *(const char **)(a1 + 424);
          if (v30)
          {
            v31 = strlen(v30);
            _libssh2_htonu32((_DWORD *)(a8 + 32), v31 - 2);
            EVP_DigestUpdate(ctx, (const void *)(a8 + 32), 4uLL);
            v32 = strlen(*(const char **)(a1 + 424)) - 2;
            v33 = ctx;
            v34 = *(const char **)(a1 + 424);
          }
          else
          {
            _libssh2_htonu32((_DWORD *)(a8 + 32), 0x16u);
            EVP_DigestUpdate(ctx, (const void *)(a8 + 32), 4uLL);
            v33 = ctx;
            v34 = "SSH-2.0-libssh2_1.11.0";
            v32 = 22;
          }
          EVP_DigestUpdate(v33, v34, v32);
          v45 = strlen(*(const char **)(a1 + 312));
          _libssh2_htonu32((_DWORD *)(a8 + 32), v45);
          EVP_DigestUpdate(ctx, (const void *)(a8 + 32), 4uLL);
          v46 = strlen(*(const char **)(a1 + 312));
          EVP_DigestUpdate(ctx, *(const void **)(a1 + 312), v46);
          _libssh2_htonu32((_DWORD *)(a8 + 32), *(_DWORD *)(a1 + 440));
          EVP_DigestUpdate(ctx, (const void *)(a8 + 32), 4uLL);
          EVP_DigestUpdate(ctx, *(const void **)(a1 + 432), *(_QWORD *)(a1 + 440));
          _libssh2_htonu32((_DWORD *)(a8 + 32), *(_DWORD *)(a1 + 328));
          EVP_DigestUpdate(ctx, (const void *)(a8 + 32), 4uLL);
          EVP_DigestUpdate(ctx, *(const void **)(a1 + 320), *(_QWORD *)(a1 + 328));
          _libssh2_htonu32((_DWORD *)(a8 + 32), *(_DWORD *)(a1 + 208));
          EVP_DigestUpdate(ctx, (const void *)(a8 + 32), 4uLL);
          EVP_DigestUpdate(ctx, *(const void **)(a1 + 200), *(unsigned int *)(a1 + 208));
          _libssh2_htonu32((_DWORD *)(a8 + 32), a6);
          EVP_DigestUpdate(ctx, (const void *)(a8 + 32), 4uLL);
          EVP_DigestUpdate(ctx, a5, a6);
          _libssh2_htonu32((_DWORD *)(a8 + 32), v149);
          EVP_DigestUpdate(ctx, (const void *)(a8 + 32), 4uLL);
          EVP_DigestUpdate(ctx, v150, v149);
          EVP_DigestUpdate(ctx, *(const void **)(a8 + 176), *(_QWORD *)(a8 + 200));
          EVP_DigestFinal(ctx, (unsigned __int8 *)(a8 + 32), 0);
          EVP_MD_CTX_free(ctx);
          v47 = (*(uint64_t (**)(uint64_t, _QWORD, _QWORD, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(a1 + 184)
                                                                                              + 40))(a1, *(_QWORD *)(a8 + 184), *(_QWORD *)(a8 + 208), a8 + 32, 32, a1 + 192);
          break;
        default:
          goto LABEL_52;
      }
      if (v47)
      {
        v18 = "Unable to verify hostkey signature ECDH";
        v19 = a1;
        v20 = 4294967285;
        goto LABEL_66;
      }
LABEL_52:
      *(_BYTE *)(a8 + 96) = 21;
      *(_DWORD *)a8 = 3;
LABEL_53:
      v52 = _libssh2_transport_send(a1, (void *)(a8 + 96), 1uLL, 0, 0);
      v11 = v52;
      if ((_DWORD)v52 == -37)
        return v11;
      if ((_DWORD)v52)
      {
        v18 = "Unable to send NEWKEYS message ECDH";
        goto LABEL_65;
      }
      *(_DWORD *)a8 = 5;
LABEL_56:
      v53 = _libssh2_packet_require(a1, 21, (_QWORD *)(a8 + 24), (unint64_t *)(a8 + 120), 0, 0, 0, a8 + 224);
      v11 = v53;
      if ((_DWORD)v53 != -37)
      {
        if (!(_DWORD)v53)
        {
          *(_DWORD *)(a1 + 128) |= 2u;
          (*(void (**)(_QWORD, uint64_t))(a1 + 24))(*(_QWORD *)(a8 + 24), a1);
          if (!*(_QWORD *)(a1 + 160))
          {
            switch(a2)
            {
              case 415:
                v54 = 32;
                break;
              case 716:
                v54 = 64;
                break;
              case 715:
                v54 = 48;
                break;
              default:
                v18 = "Unknown SHA digest for EC curve";
                goto LABEL_99;
            }
            v56 = (void *)(*(uint64_t (**)(size_t, uint64_t))(a1 + 8))(v54, a1);
            *(_QWORD *)(a1 + 160) = v56;
            if (!v56)
            {
              v18 = "Unable to allocate buffer for SHA digest";
              goto LABEL_7;
            }
            memcpy(v56, (const void *)(a8 + 32), v54);
            *(_DWORD *)(a1 + 168) = v54;
          }
          v57 = *(_QWORD *)(a1 + 448);
          v58 = *(void (**)(uint64_t, uint64_t))(v57 + 56);
          if (v58)
          {
            v58(a1, a1 + 456);
            v57 = *(_QWORD *)(a1 + 448);
          }
          if (!*(_QWORD *)(v57 + 40))
            goto LABEL_140;
          LODWORD(v150) = 0;
          LODWORD(v149) = 0;
          switch(a2)
          {
            case 415:
              v148[0] = 0;
              v59 = (void *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 8))(*(int *)(v57 + 20) + 32, a1);
              if (v59 && *(_DWORD *)(*(_QWORD *)(a1 + 448) + 20))
              {
                v60 = 0;
                do
                {
                  _libssh2_sha256_init(v148);
                  EVP_DigestUpdate(v148[0], *(const void **)(a8 + 176), *(_QWORD *)(a8 + 200));
                  EVP_DigestUpdate(v148[0], (const void *)(a8 + 32), 0x20uLL);
                  v61 = v148[0];
                  if (v60)
                  {
                    v62 = v59;
                    v63 = v60;
                  }
                  else
                  {
                    EVP_DigestUpdate(v148[0], "A", 1uLL);
                    v61 = v148[0];
                    v62 = *(const void **)(a1 + 160);
                    v63 = *(unsigned int *)(a1 + 168);
                  }
                  EVP_DigestUpdate(v61, v62, v63);
                  EVP_DigestFinal(v148[0], (unsigned __int8 *)v59 + v60, 0);
                  EVP_MD_CTX_free(v148[0]);
                  v60 += 32;
                }
                while (v60 < *(int *)(*(_QWORD *)(a1 + 448) + 20));
              }
              break;
            case 716:
              v148[0] = 0;
              v59 = (void *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 8))(*(int *)(v57 + 20) + 64, a1);
              if (v59 && *(_DWORD *)(*(_QWORD *)(a1 + 448) + 20))
              {
                v68 = 0;
                do
                {
                  _libssh2_sha512_init(v148);
                  EVP_DigestUpdate(v148[0], *(const void **)(a8 + 176), *(_QWORD *)(a8 + 200));
                  EVP_DigestUpdate(v148[0], (const void *)(a8 + 32), 0x40uLL);
                  v69 = v148[0];
                  if (v68)
                  {
                    v70 = v59;
                    v71 = v68;
                  }
                  else
                  {
                    EVP_DigestUpdate(v148[0], "A", 1uLL);
                    v69 = v148[0];
                    v70 = *(const void **)(a1 + 160);
                    v71 = *(unsigned int *)(a1 + 168);
                  }
                  EVP_DigestUpdate(v69, v70, v71);
                  EVP_DigestFinal(v148[0], (unsigned __int8 *)v59 + v68, 0);
                  EVP_MD_CTX_free(v148[0]);
                  v68 += 64;
                }
                while (v68 < *(int *)(*(_QWORD *)(a1 + 448) + 20));
              }
              break;
            case 715:
              v148[0] = 0;
              v59 = (void *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 8))(*(int *)(v57 + 20) + 48, a1);
              if (v59 && *(_DWORD *)(*(_QWORD *)(a1 + 448) + 20))
              {
                v64 = 0;
                do
                {
                  _libssh2_sha384_init(v148);
                  EVP_DigestUpdate(v148[0], *(const void **)(a8 + 176), *(_QWORD *)(a8 + 200));
                  EVP_DigestUpdate(v148[0], (const void *)(a8 + 32), 0x30uLL);
                  v65 = v148[0];
                  if (v64)
                  {
                    v66 = v59;
                    v67 = v64;
                  }
                  else
                  {
                    EVP_DigestUpdate(v148[0], "A", 1uLL);
                    v65 = v148[0];
                    v66 = *(const void **)(a1 + 160);
                    v67 = *(unsigned int *)(a1 + 168);
                  }
                  EVP_DigestUpdate(v65, v66, v67);
                  EVP_DigestFinal(v148[0], (unsigned __int8 *)v59 + v64, 0);
                  EVP_MD_CTX_free(v148[0]);
                  v64 += 48;
                }
                while (v64 < *(int *)(*(_QWORD *)(a1 + 448) + 20));
              }
              break;
            default:
              goto LABEL_117;
          }
          if (v59)
          {
            if (a2 == 415)
            {
              v148[0] = 0;
              v72 = (void *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 8))(*(int *)(*(_QWORD *)(a1 + 448) + 24) + 32, a1);
              if (v72 && *(_DWORD *)(*(_QWORD *)(a1 + 448) + 24))
              {
                v73 = 0;
                do
                {
                  _libssh2_sha256_init(v148);
                  EVP_DigestUpdate(v148[0], *(const void **)(a8 + 176), *(_QWORD *)(a8 + 200));
                  EVP_DigestUpdate(v148[0], (const void *)(a8 + 32), 0x20uLL);
                  v74 = v148[0];
                  if (v73)
                  {
                    v75 = v72;
                    v76 = v73;
                  }
                  else
                  {
                    EVP_DigestUpdate(v148[0], "C", 1uLL);
                    v74 = v148[0];
                    v75 = *(const void **)(a1 + 160);
                    v76 = *(unsigned int *)(a1 + 168);
                  }
                  EVP_DigestUpdate(v74, v75, v76);
                  EVP_DigestFinal(v148[0], (unsigned __int8 *)v72 + v73, 0);
                  EVP_MD_CTX_free(v148[0]);
                  v73 += 32;
                }
                while (v73 < *(int *)(*(_QWORD *)(a1 + 448) + 24));
              }
            }
            else if (a2 == 716)
            {
              v148[0] = 0;
              v72 = (void *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 8))(*(int *)(*(_QWORD *)(a1 + 448) + 24) + 64, a1);
              if (v72 && *(_DWORD *)(*(_QWORD *)(a1 + 448) + 24))
              {
                v81 = 0;
                do
                {
                  _libssh2_sha512_init(v148);
                  EVP_DigestUpdate(v148[0], *(const void **)(a8 + 176), *(_QWORD *)(a8 + 200));
                  EVP_DigestUpdate(v148[0], (const void *)(a8 + 32), 0x40uLL);
                  v82 = v148[0];
                  if (v81)
                  {
                    v83 = v72;
                    v84 = v81;
                  }
                  else
                  {
                    EVP_DigestUpdate(v148[0], "C", 1uLL);
                    v82 = v148[0];
                    v83 = *(const void **)(a1 + 160);
                    v84 = *(unsigned int *)(a1 + 168);
                  }
                  EVP_DigestUpdate(v82, v83, v84);
                  EVP_DigestFinal(v148[0], (unsigned __int8 *)v72 + v81, 0);
                  EVP_MD_CTX_free(v148[0]);
                  v81 += 64;
                }
                while (v81 < *(int *)(*(_QWORD *)(a1 + 448) + 24));
              }
            }
            else
            {
              v148[0] = 0;
              v72 = (void *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 8))(*(int *)(*(_QWORD *)(a1 + 448) + 24) + 48, a1);
              if (v72 && *(_DWORD *)(*(_QWORD *)(a1 + 448) + 24))
              {
                v77 = 0;
                do
                {
                  _libssh2_sha384_init(v148);
                  EVP_DigestUpdate(v148[0], *(const void **)(a8 + 176), *(_QWORD *)(a8 + 200));
                  EVP_DigestUpdate(v148[0], (const void *)(a8 + 32), 0x30uLL);
                  v78 = v148[0];
                  if (v77)
                  {
                    v79 = v72;
                    v80 = v77;
                  }
                  else
                  {
                    EVP_DigestUpdate(v148[0], "C", 1uLL);
                    v78 = v148[0];
                    v79 = *(const void **)(a1 + 160);
                    v80 = *(unsigned int *)(a1 + 168);
                  }
                  EVP_DigestUpdate(v78, v79, v80);
                  EVP_DigestFinal(v148[0], (unsigned __int8 *)v72 + v77, 0);
                  EVP_MD_CTX_free(v148[0]);
                  v77 += 48;
                }
                while (v77 < *(int *)(*(_QWORD *)(a1 + 448) + 24));
              }
            }
            if (!v72)
              goto LABEL_198;
            if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)(a1 + 448) + 40))(a1))
            {
LABEL_197:
              (*(void (**)(void *, uint64_t))(a1 + 24))(v59, a1);
LABEL_199:
              (*(void (**)(void *, uint64_t))(a1 + 24))(v72, a1);
              goto LABEL_200;
            }
            if ((_DWORD)v150)
            {
              memset_s(v59, *(int *)(*(_QWORD *)(a1 + 448) + 20), 0, *(int *)(*(_QWORD *)(a1 + 448) + 20));
              (*(void (**)(void *, uint64_t))(a1 + 24))(v59, a1);
            }
            if ((_DWORD)v149)
            {
              memset_s(v72, *(int *)(*(_QWORD *)(a1 + 448) + 24), 0, *(int *)(*(_QWORD *)(a1 + 448) + 24));
              (*(void (**)(void *, uint64_t))(a1 + 24))(v72, a1);
            }
LABEL_140:
            v85 = *(_QWORD *)(a1 + 336);
            v86 = *(void (**)(uint64_t, uint64_t))(v85 + 56);
            if (v86)
            {
              v86(a1, a1 + 344);
              v85 = *(_QWORD *)(a1 + 336);
            }
            if (!*(_QWORD *)(v85 + 40))
              goto LABEL_205;
            LODWORD(v150) = 0;
            LODWORD(v149) = 0;
            switch(a2)
            {
              case 415:
                v148[0] = 0;
                v59 = (void *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 8))(*(int *)(v85 + 20) + 32, a1);
                if (v59 && *(_DWORD *)(*(_QWORD *)(a1 + 336) + 20))
                {
                  v87 = 0;
                  do
                  {
                    _libssh2_sha256_init(v148);
                    EVP_DigestUpdate(v148[0], *(const void **)(a8 + 176), *(_QWORD *)(a8 + 200));
                    EVP_DigestUpdate(v148[0], (const void *)(a8 + 32), 0x20uLL);
                    v88 = v148[0];
                    if (v87)
                    {
                      v89 = v59;
                      v90 = v87;
                    }
                    else
                    {
                      EVP_DigestUpdate(v148[0], "B", 1uLL);
                      v88 = v148[0];
                      v89 = *(const void **)(a1 + 160);
                      v90 = *(unsigned int *)(a1 + 168);
                    }
                    EVP_DigestUpdate(v88, v89, v90);
                    EVP_DigestFinal(v148[0], (unsigned __int8 *)v59 + v87, 0);
                    EVP_MD_CTX_free(v148[0]);
                    v87 += 32;
                  }
                  while (v87 < *(int *)(*(_QWORD *)(a1 + 336) + 20));
                }
                break;
              case 716:
                v148[0] = 0;
                v59 = (void *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 8))(*(int *)(v85 + 20) + 64, a1);
                if (v59 && *(_DWORD *)(*(_QWORD *)(a1 + 336) + 20))
                {
                  v95 = 0;
                  do
                  {
                    _libssh2_sha512_init(v148);
                    EVP_DigestUpdate(v148[0], *(const void **)(a8 + 176), *(_QWORD *)(a8 + 200));
                    EVP_DigestUpdate(v148[0], (const void *)(a8 + 32), 0x40uLL);
                    v96 = v148[0];
                    if (v95)
                    {
                      v97 = v59;
                      v98 = v95;
                    }
                    else
                    {
                      EVP_DigestUpdate(v148[0], "B", 1uLL);
                      v96 = v148[0];
                      v97 = *(const void **)(a1 + 160);
                      v98 = *(unsigned int *)(a1 + 168);
                    }
                    EVP_DigestUpdate(v96, v97, v98);
                    EVP_DigestFinal(v148[0], (unsigned __int8 *)v59 + v95, 0);
                    EVP_MD_CTX_free(v148[0]);
                    v95 += 64;
                  }
                  while (v95 < *(int *)(*(_QWORD *)(a1 + 336) + 20));
                }
                break;
              case 715:
                v148[0] = 0;
                v59 = (void *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 8))(*(int *)(v85 + 20) + 48, a1);
                if (v59 && *(_DWORD *)(*(_QWORD *)(a1 + 336) + 20))
                {
                  v91 = 0;
                  do
                  {
                    _libssh2_sha384_init(v148);
                    EVP_DigestUpdate(v148[0], *(const void **)(a8 + 176), *(_QWORD *)(a8 + 200));
                    EVP_DigestUpdate(v148[0], (const void *)(a8 + 32), 0x30uLL);
                    v92 = v148[0];
                    if (v91)
                    {
                      v93 = v59;
                      v94 = v91;
                    }
                    else
                    {
                      EVP_DigestUpdate(v148[0], "B", 1uLL);
                      v92 = v148[0];
                      v93 = *(const void **)(a1 + 160);
                      v94 = *(unsigned int *)(a1 + 168);
                    }
                    EVP_DigestUpdate(v92, v93, v94);
                    EVP_DigestFinal(v148[0], (unsigned __int8 *)v59 + v91, 0);
                    EVP_MD_CTX_free(v148[0]);
                    v91 += 48;
                  }
                  while (v91 < *(int *)(*(_QWORD *)(a1 + 336) + 20));
                }
                break;
              default:
                goto LABEL_200;
            }
            if (v59)
            {
              if (a2 == 415)
              {
                v148[0] = 0;
                v72 = (void *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 8))(*(int *)(*(_QWORD *)(a1 + 336) + 24) + 32, a1);
                if (v72 && *(_DWORD *)(*(_QWORD *)(a1 + 336) + 24))
                {
                  v99 = 0;
                  do
                  {
                    _libssh2_sha256_init(v148);
                    EVP_DigestUpdate(v148[0], *(const void **)(a8 + 176), *(_QWORD *)(a8 + 200));
                    EVP_DigestUpdate(v148[0], (const void *)(a8 + 32), 0x20uLL);
                    v100 = v148[0];
                    if (v99)
                    {
                      v101 = v72;
                      v102 = v99;
                    }
                    else
                    {
                      EVP_DigestUpdate(v148[0], "D", 1uLL);
                      v100 = v148[0];
                      v101 = *(const void **)(a1 + 160);
                      v102 = *(unsigned int *)(a1 + 168);
                    }
                    EVP_DigestUpdate(v100, v101, v102);
                    EVP_DigestFinal(v148[0], (unsigned __int8 *)v72 + v99, 0);
                    EVP_MD_CTX_free(v148[0]);
                    v99 += 32;
                  }
                  while (v99 < *(int *)(*(_QWORD *)(a1 + 336) + 24));
                }
              }
              else if (a2 == 716)
              {
                v148[0] = 0;
                v72 = (void *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 8))(*(int *)(*(_QWORD *)(a1 + 336) + 24) + 64, a1);
                if (v72 && *(_DWORD *)(*(_QWORD *)(a1 + 336) + 24))
                {
                  v107 = 0;
                  do
                  {
                    _libssh2_sha512_init(v148);
                    EVP_DigestUpdate(v148[0], *(const void **)(a8 + 176), *(_QWORD *)(a8 + 200));
                    EVP_DigestUpdate(v148[0], (const void *)(a8 + 32), 0x40uLL);
                    v108 = v148[0];
                    if (v107)
                    {
                      v109 = v72;
                      v110 = v107;
                    }
                    else
                    {
                      EVP_DigestUpdate(v148[0], "D", 1uLL);
                      v108 = v148[0];
                      v109 = *(const void **)(a1 + 160);
                      v110 = *(unsigned int *)(a1 + 168);
                    }
                    EVP_DigestUpdate(v108, v109, v110);
                    EVP_DigestFinal(v148[0], (unsigned __int8 *)v72 + v107, 0);
                    EVP_MD_CTX_free(v148[0]);
                    v107 += 64;
                  }
                  while (v107 < *(int *)(*(_QWORD *)(a1 + 336) + 24));
                }
              }
              else
              {
                v148[0] = 0;
                v72 = (void *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 8))(*(int *)(*(_QWORD *)(a1 + 336) + 24) + 48, a1);
                if (v72 && *(_DWORD *)(*(_QWORD *)(a1 + 336) + 24))
                {
                  v103 = 0;
                  do
                  {
                    _libssh2_sha384_init(v148);
                    EVP_DigestUpdate(v148[0], *(const void **)(a8 + 176), *(_QWORD *)(a8 + 200));
                    EVP_DigestUpdate(v148[0], (const void *)(a8 + 32), 0x30uLL);
                    v104 = v148[0];
                    if (v103)
                    {
                      v105 = v72;
                      v106 = v103;
                    }
                    else
                    {
                      EVP_DigestUpdate(v148[0], "D", 1uLL);
                      v104 = v148[0];
                      v105 = *(const void **)(a1 + 160);
                      v106 = *(unsigned int *)(a1 + 168);
                    }
                    EVP_DigestUpdate(v104, v105, v106);
                    EVP_DigestFinal(v148[0], (unsigned __int8 *)v72 + v103, 0);
                    EVP_MD_CTX_free(v148[0]);
                    v103 += 48;
                  }
                  while (v103 < *(int *)(*(_QWORD *)(a1 + 336) + 24));
                }
              }
              if (v72)
              {
                if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)(a1 + 336) + 40))(a1))
                  goto LABEL_197;
                if ((_DWORD)v150)
                {
                  memset_s(v59, *(int *)(*(_QWORD *)(a1 + 336) + 20), 0, *(int *)(*(_QWORD *)(a1 + 336) + 20));
                  (*(void (**)(void *, uint64_t))(a1 + 24))(v59, a1);
                }
                if ((_DWORD)v149)
                {
                  memset_s(v72, *(int *)(*(_QWORD *)(a1 + 336) + 24), 0, *(int *)(*(_QWORD *)(a1 + 336) + 24));
                  (*(void (**)(void *, uint64_t))(a1 + 24))(v72, a1);
                }
LABEL_205:
                v111 = *(_QWORD *)(a1 + 464);
                v112 = *(void (**)(uint64_t, uint64_t))(v111 + 32);
                if (v112)
                {
                  v112(a1, a1 + 480);
                  v111 = *(_QWORD *)(a1 + 464);
                }
                if (*(_QWORD *)(v111 + 16))
                {
                  LODWORD(v150) = 0;
                  switch(a2)
                  {
                    case 716:
                      v148[0] = 0;
                      v113 = (void *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 8))(*(int *)(v111 + 12) + 64, a1);
                      if (v113 && *(_DWORD *)(*(_QWORD *)(a1 + 464) + 12))
                      {
                        v118 = 0;
                        do
                        {
                          _libssh2_sha512_init(v148);
                          EVP_DigestUpdate(v148[0], *(const void **)(a8 + 176), *(_QWORD *)(a8 + 200));
                          EVP_DigestUpdate(v148[0], (const void *)(a8 + 32), 0x40uLL);
                          v119 = v148[0];
                          if (v118)
                          {
                            v120 = v113;
                            v121 = v118;
                          }
                          else
                          {
                            EVP_DigestUpdate(v148[0], "E", 1uLL);
                            v119 = v148[0];
                            v120 = *(const void **)(a1 + 160);
                            v121 = *(unsigned int *)(a1 + 168);
                          }
                          EVP_DigestUpdate(v119, v120, v121);
                          EVP_DigestFinal(v148[0], (unsigned __int8 *)v113 + v118, 0);
                          EVP_MD_CTX_free(v148[0]);
                          v118 += 64;
                        }
                        while (v118 < *(int *)(*(_QWORD *)(a1 + 464) + 12));
                      }
                      break;
                    case 715:
                      v148[0] = 0;
                      v113 = (void *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 8))(*(int *)(v111 + 12) + 48, a1);
                      if (v113 && *(_DWORD *)(*(_QWORD *)(a1 + 464) + 12))
                      {
                        v122 = 0;
                        do
                        {
                          _libssh2_sha384_init(v148);
                          EVP_DigestUpdate(v148[0], *(const void **)(a8 + 176), *(_QWORD *)(a8 + 200));
                          EVP_DigestUpdate(v148[0], (const void *)(a8 + 32), 0x30uLL);
                          v123 = v148[0];
                          if (v122)
                          {
                            v124 = v113;
                            v125 = v122;
                          }
                          else
                          {
                            EVP_DigestUpdate(v148[0], "E", 1uLL);
                            v123 = v148[0];
                            v124 = *(const void **)(a1 + 160);
                            v125 = *(unsigned int *)(a1 + 168);
                          }
                          EVP_DigestUpdate(v123, v124, v125);
                          EVP_DigestFinal(v148[0], (unsigned __int8 *)v113 + v122, 0);
                          EVP_MD_CTX_free(v148[0]);
                          v122 += 48;
                        }
                        while (v122 < *(int *)(*(_QWORD *)(a1 + 464) + 12));
                      }
                      break;
                    case 415:
                      v148[0] = 0;
                      v113 = (void *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 8))(*(int *)(v111 + 12) + 32, a1);
                      if (v113 && *(_DWORD *)(*(_QWORD *)(a1 + 464) + 12))
                      {
                        v114 = 0;
                        do
                        {
                          _libssh2_sha256_init(v148);
                          EVP_DigestUpdate(v148[0], *(const void **)(a8 + 176), *(_QWORD *)(a8 + 200));
                          EVP_DigestUpdate(v148[0], (const void *)(a8 + 32), 0x20uLL);
                          v115 = v148[0];
                          if (v114)
                          {
                            v116 = v113;
                            v117 = v114;
                          }
                          else
                          {
                            EVP_DigestUpdate(v148[0], "E", 1uLL);
                            v115 = v148[0];
                            v116 = *(const void **)(a1 + 160);
                            v117 = *(unsigned int *)(a1 + 168);
                          }
                          EVP_DigestUpdate(v115, v116, v117);
                          EVP_DigestFinal(v148[0], (unsigned __int8 *)v113 + v114, 0);
                          EVP_MD_CTX_free(v148[0]);
                          v114 += 32;
                        }
                        while (v114 < *(int *)(*(_QWORD *)(a1 + 464) + 12));
                      }
                      break;
                    default:
                      goto LABEL_200;
                  }
                  if (!v113)
                    goto LABEL_200;
                  (*(void (**)(uint64_t, void *, const unsigned __int8 **, uint64_t))(*(_QWORD *)(a1 + 464)
                                                                                             + 16))(a1, v113, &v150, a1 + 480);
                  if ((_DWORD)v150)
                  {
                    memset_s(v113, *(int *)(*(_QWORD *)(a1 + 464) + 12), 0, *(int *)(*(_QWORD *)(a1 + 464) + 12));
                    (*(void (**)(void *, uint64_t))(a1 + 24))(v113, a1);
                  }
                }
                v126 = *(_QWORD *)(a1 + 352);
                v127 = *(void (**)(uint64_t, uint64_t))(v126 + 32);
                if (v127)
                {
                  v127(a1, a1 + 368);
                  v126 = *(_QWORD *)(a1 + 352);
                }
                if (*(_QWORD *)(v126 + 16))
                {
                  LODWORD(v150) = 0;
                  switch(a2)
                  {
                    case 716:
                      v148[0] = 0;
                      v128 = (void *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 8))(*(int *)(v126 + 12) + 64, a1);
                      if (v128 && *(_DWORD *)(*(_QWORD *)(a1 + 352) + 12))
                      {
                        v133 = 0;
                        do
                        {
                          _libssh2_sha512_init(v148);
                          EVP_DigestUpdate(v148[0], *(const void **)(a8 + 176), *(_QWORD *)(a8 + 200));
                          EVP_DigestUpdate(v148[0], (const void *)(a8 + 32), 0x40uLL);
                          v134 = v148[0];
                          if (v133)
                          {
                            v135 = v128;
                            v136 = v133;
                          }
                          else
                          {
                            EVP_DigestUpdate(v148[0], "F", 1uLL);
                            v134 = v148[0];
                            v135 = *(const void **)(a1 + 160);
                            v136 = *(unsigned int *)(a1 + 168);
                          }
                          EVP_DigestUpdate(v134, v135, v136);
                          EVP_DigestFinal(v148[0], (unsigned __int8 *)v128 + v133, 0);
                          EVP_MD_CTX_free(v148[0]);
                          v133 += 64;
                        }
                        while (v133 < *(int *)(*(_QWORD *)(a1 + 352) + 12));
                      }
                      break;
                    case 715:
                      v148[0] = 0;
                      v128 = (void *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 8))(*(int *)(v126 + 12) + 48, a1);
                      if (v128 && *(_DWORD *)(*(_QWORD *)(a1 + 352) + 12))
                      {
                        v137 = 0;
                        do
                        {
                          _libssh2_sha384_init(v148);
                          EVP_DigestUpdate(v148[0], *(const void **)(a8 + 176), *(_QWORD *)(a8 + 200));
                          EVP_DigestUpdate(v148[0], (const void *)(a8 + 32), 0x30uLL);
                          v138 = v148[0];
                          if (v137)
                          {
                            v139 = v128;
                            v140 = v137;
                          }
                          else
                          {
                            EVP_DigestUpdate(v148[0], "F", 1uLL);
                            v138 = v148[0];
                            v139 = *(const void **)(a1 + 160);
                            v140 = *(unsigned int *)(a1 + 168);
                          }
                          EVP_DigestUpdate(v138, v139, v140);
                          EVP_DigestFinal(v148[0], (unsigned __int8 *)v128 + v137, 0);
                          EVP_MD_CTX_free(v148[0]);
                          v137 += 48;
                        }
                        while (v137 < *(int *)(*(_QWORD *)(a1 + 352) + 12));
                      }
                      break;
                    case 415:
                      v148[0] = 0;
                      v128 = (void *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 8))(*(int *)(v126 + 12) + 32, a1);
                      if (v128 && *(_DWORD *)(*(_QWORD *)(a1 + 352) + 12))
                      {
                        v129 = 0;
                        do
                        {
                          _libssh2_sha256_init(v148);
                          EVP_DigestUpdate(v148[0], *(const void **)(a8 + 176), *(_QWORD *)(a8 + 200));
                          EVP_DigestUpdate(v148[0], (const void *)(a8 + 32), 0x20uLL);
                          v130 = v148[0];
                          if (v129)
                          {
                            v131 = v128;
                            v132 = v129;
                          }
                          else
                          {
                            EVP_DigestUpdate(v148[0], "F", 1uLL);
                            v130 = v148[0];
                            v131 = *(const void **)(a1 + 160);
                            v132 = *(unsigned int *)(a1 + 168);
                          }
                          EVP_DigestUpdate(v130, v131, v132);
                          EVP_DigestFinal(v148[0], (unsigned __int8 *)v128 + v129, 0);
                          EVP_MD_CTX_free(v148[0]);
                          v129 += 32;
                        }
                        while (v129 < *(int *)(*(_QWORD *)(a1 + 352) + 12));
                      }
                      break;
                    default:
                      goto LABEL_200;
                  }
                  if (!v128)
                    goto LABEL_200;
                  (*(void (**)(uint64_t, void *, const unsigned __int8 **, uint64_t))(*(_QWORD *)(a1 + 352)
                                                                                             + 16))(a1, v128, &v150, a1 + 368);
                  if ((_DWORD)v150)
                  {
                    memset_s(v128, *(int *)(*(_QWORD *)(a1 + 352) + 12), 0, *(int *)(*(_QWORD *)(a1 + 352) + 12));
                    (*(void (**)(void *, uint64_t))(a1 + 24))(v128, a1);
                  }
                }
                v141 = *(_QWORD *)(a1 + 488);
                if (!v141
                  || (v142 = *(void (**)(uint64_t, uint64_t, uint64_t))(v141 + 40)) != 0
                  && (v142(a1, 1, a1 + 496), (v141 = *(_QWORD *)(a1 + 488)) == 0)
                  || (v143 = *(unsigned int (**)(uint64_t, uint64_t, uint64_t))(v141 + 16)) == 0
                  || !v143(a1, 1, a1 + 496))
                {
                  v144 = *(_QWORD *)(a1 + 376);
                  if (v144
                    && ((v145 = *(void (**)(uint64_t, _QWORD, uint64_t))(v144 + 40)) == 0
                     || (v145(a1, 0, a1 + 384), (v144 = *(_QWORD *)(a1 + 376)) != 0))
                    && (v146 = *(unsigned int (**)(uint64_t, _QWORD, uint64_t))(v144 + 16)) != 0)
                  {
                    if (v146(a1, 0, a1 + 384))
                      v11 = 4294967291;
                    else
                      v11 = 0;
                  }
                  else
                  {
                    v11 = 0;
                  }
                  goto LABEL_67;
                }
                goto LABEL_200;
              }
LABEL_198:
              v72 = v59;
              goto LABEL_199;
            }
LABEL_200:
            v11 = 4294967291;
            goto LABEL_67;
          }
LABEL_117:
          v11 = 0xFFFFFFFFLL;
          goto LABEL_67;
        }
        v18 = "Timed out waiting for NEWKEYS ECDH";
LABEL_65:
        v19 = a1;
        v20 = v11;
        goto LABEL_66;
      }
      return v11;
    case 3:
      goto LABEL_53;
    case 5:
      goto LABEL_56;
    default:
      goto LABEL_67;
  }
}

uint64_t kex_method_diffie_hellman_group_exchange_sha256_key_exchange(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  size_t v5;
  uint64_t v6;
  uint64_t v7;
  char *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v13;
  _QWORD v14[3];
  int len[2];
  uint64_t v16;
  const unsigned __int8 *v17;
  const unsigned __int8 *v18;

  v3 = 0;
  switch(*(_DWORD *)a2)
  {
    case 0:
      *(_QWORD *)(a2 + 272) = BN_new();
      *(_QWORD *)(a2 + 280) = BN_new();
      *(_BYTE *)(a2 + 288) = 34;
      _libssh2_htonu32((_DWORD *)(a2 + 289), 0x800u);
      _libssh2_htonu32((_DWORD *)(a2 + 293), 0x1000u);
      _libssh2_htonu32((_DWORD *)(a2 + 297), 0x2000u);
      v5 = 13;
      *(_QWORD *)(a2 + 552) = 13;
      *(_DWORD *)a2 = 2;
      goto LABEL_4;
    case 2:
      v5 = *(_QWORD *)(a2 + 552);
LABEL_4:
      v6 = _libssh2_transport_send(a1, (void *)(a2 + 288), v5, 0, 0);
      v3 = v6;
      if ((_DWORD)v6 == -37)
        return v3;
      if ((_DWORD)v6)
      {
        v8 = "Unable to send Group Exchange Request SHA256";
LABEL_16:
        v10 = a1;
        v11 = v3;
LABEL_20:
        v3 = _libssh2_error(v10, v11, v8);
LABEL_21:
        *(_DWORD *)a2 = 0;
        BN_clear_free(*(BIGNUM **)(a2 + 280));
        *(_QWORD *)(a2 + 280) = 0;
        BN_clear_free(*(BIGNUM **)(a2 + 272));
        *(_QWORD *)(a2 + 272) = 0;
        return v3;
      }
      *(_DWORD *)a2 = 3;
LABEL_7:
      v7 = _libssh2_packet_require(a1, 31, (_QWORD *)(a2 + 544), (unint64_t *)(a2 + 560), 0, 0, 0, a2 + 8);
      v3 = v7;
      if ((_DWORD)v7 == -37)
        return v3;
      if ((_DWORD)v7)
      {
        v8 = "Timeout waiting for GEX_GROUP reply SHA256";
        goto LABEL_16;
      }
      *(_DWORD *)a2 = 4;
LABEL_10:
      v17 = 0;
      v18 = 0;
      v16 = 0;
      *(_QWORD *)len = 0;
      v13 = 0;
      if (*(_QWORD *)(a2 + 560) <= 8uLL)
      {
        v8 = "Unexpected key length DH-SHA256";
LABEL_19:
        v10 = a1;
        v11 = 4294967282;
        goto LABEL_20;
      }
      v9 = *(_QWORD *)(a2 + 544);
      v14[2] = *(_QWORD *)(a2 + 560);
      v14[0] = v9;
      v14[1] = v9 + 1;
      if (_libssh2_get_bignum_bytes(v14, &v18, &v16))
      {
        v8 = "Unexpected value DH-SHA256 p";
        goto LABEL_19;
      }
      if (_libssh2_get_bignum_bytes(v14, &v17, len))
      {
        v8 = "Unexpected value DH-SHA256 g";
        goto LABEL_19;
      }
      BN_bin2bn(v18, v16, *(BIGNUM **)(a2 + 272));
      BN_bin2bn(v17, len[0], *(BIGNUM **)(a2 + 280));
      v3 = diffie_hellman_sha_algo(a1, *(const BIGNUM **)(a2 + 280), *(const BIGNUM **)(a2 + 272), v16, 256, (uint64_t)&v13, 32, 33, (void *)(*(_QWORD *)(a2 + 544) + 1), *(_QWORD *)(a2 + 560) - 1, a2 + 24);
      if ((_DWORD)v3 != -37)
      {
        (*(void (**)(_QWORD, uint64_t))(a1 + 24))(*(_QWORD *)(a2 + 544), a1);
        goto LABEL_21;
      }
      return v3;
    case 3:
      goto LABEL_7;
    case 4:
      goto LABEL_10;
    default:
      goto LABEL_21;
  }
}

uint64_t diffie_hellman_sha_algo(uint64_t a1, const BIGNUM *a2, const BIGNUM *a3, int a4, uint64_t a5, uint64_t a6, int a7, int a8, void *a9, size_t cnt, uint64_t a11)
{
  unsigned int v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  uint64_t v22;
  uint64_t v23;
  int v24;
  int v25;
  char v26;
  uint64_t v27;
  _BYTE *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t *v32;
  int v33;
  uint64_t v34;
  uint64_t v35;
  int v36;
  int v37;
  int v38;
  int v39;
  int v40;
  char v41;
  uint64_t v42;
  _DWORD *v43;
  uint64_t v44;
  const char *v45;
  int v46;
  size_t v47;
  uint64_t v48;
  EVP_MD_CTX **v49;
  char *v50;
  unsigned int v51;
  size_t v52;
  uint64_t v53;
  uint64_t v54;
  void *v55;
  uint64_t v56;
  void (*v57)(uint64_t, uint64_t);
  void *v58;
  uint64_t v59;
  uint64_t v60;
  void (*v61)(uint64_t, uint64_t);
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v66;
  void (*v67)(uint64_t, uint64_t);
  void *v68;
  uint64_t v69;
  void (*v70)(uint64_t, uint64_t);
  void *v71;
  uint64_t v72;
  void (*v73)(uint64_t, uint64_t, uint64_t);
  unsigned int (*v74)(uint64_t, uint64_t, uint64_t);
  uint64_t v75;
  void (*v76)(uint64_t, _QWORD, uint64_t);
  unsigned int (*v77)(uint64_t, _QWORD, uint64_t);
  unsigned int v78;
  EVP_MD_CTX *ctx;
  uint64_t v80;
  uint64_t v81[3];
  int v82[2];

  *(_QWORD *)v82 = a6;
  if ((int)a5 > 383)
  {
    if ((_DWORD)a5 == 512)
    {
      v18 = 64;
      goto LABEL_10;
    }
    if ((_DWORD)a5 == 384)
    {
      v18 = 48;
      goto LABEL_10;
    }
LABEL_13:
    v21 = "sha algo value is unimplemented";
LABEL_14:
    v22 = a1;
    v23 = 4294967282;
    goto LABEL_113;
  }
  if ((_DWORD)a5 == 1)
  {
    v18 = 20;
    goto LABEL_10;
  }
  if ((_DWORD)a5 != 256)
    goto LABEL_13;
  v18 = 32;
LABEL_10:
  v19 = 0;
  switch(*(_DWORD *)a11)
  {
    case 0:
      v78 = v18;
      *(_QWORD *)(a11 + 8) = 0;
      v20 = a11 + 8;
      *(_QWORD *)(a11 + 176) = 0;
      *(_QWORD *)(a11 + 16) = 0;
      *(_QWORD *)(a11 + 128) = BN_CTX_new();
      _libssh2_dh_init((BIGNUM **)(a11 + 136));
      *(_QWORD *)(a11 + 144) = BN_new();
      *(_QWORD *)(a11 + 152) = BN_new();
      *(_QWORD *)(a11 + 160) = BN_new();
      *(_QWORD *)(a11 + 224) = 0;
      *(_QWORD *)(a11 + 232) = 0;
      if (BN_num_bits(a3) > 0x4000)
      {
        v21 = "dh modulus value is too large";
        v22 = a1;
        v23 = 4294967262;
        goto LABEL_113;
      }
      if (_libssh2_dh_key_pair((BIGNUM **)(a11 + 136), *(BIGNUM **)(a11 + 144), a2, a3, a4, *(BN_CTX **)(a11 + 128)))
      {
        v21 = "dh key pair generation failed";
        v22 = a1;
        v23 = 4294967291;
        goto LABEL_113;
      }
      v24 = BN_num_bits(*(const BIGNUM **)(a11 + 144));
      v25 = v24 + 7;
      if (v24 < -7)
        v25 = v24 + 14;
      *(_QWORD *)(a11 + 104) = (v25 >> 3) + 6;
      v26 = BN_num_bits(*(const BIGNUM **)(a11 + 144));
      v27 = *(_QWORD *)(a11 + 104);
      if ((v26 & 7) != 0)
        *(_QWORD *)(a11 + 104) = --v27;
      v28 = (_BYTE *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 8))(v27, a1);
      *(_QWORD *)v20 = v28;
      if (!v28)
      {
        v21 = "Out of memory error";
LABEL_112:
        v22 = a1;
        v23 = 4294967290;
        goto LABEL_113;
      }
      *v28 = a7;
      _libssh2_htonu32((_DWORD *)(*(_QWORD *)(a11 + 8) + 1), *(_DWORD *)(a11 + 104) - 5);
      if ((BN_num_bits(*(const BIGNUM **)(a11 + 144)) & 7) != 0)
      {
        v29 = 5;
      }
      else
      {
        *(_BYTE *)(*(_QWORD *)v20 + 5) = 0;
        v29 = 6;
      }
      v18 = v78;
      BN_bn2bin(*(const BIGNUM **)(a11 + 144), (unsigned __int8 *)(*(_QWORD *)(a11 + 8) + v29));
      *(_DWORD *)a11 = 2;
LABEL_27:
      v30 = _libssh2_transport_send(a1, *(void **)(a11 + 8), *(_QWORD *)(a11 + 104), 0, 0);
      v19 = v30;
      if ((_DWORD)v30 == -37)
        return v19;
      if ((_DWORD)v30)
      {
        v21 = "Unable to send KEX init message";
        goto LABEL_106;
      }
      *(_DWORD *)a11 = 3;
LABEL_30:
      if (*(_DWORD *)(a1 + 152))
      {
        v31 = _libssh2_packet_burn(a1, (_DWORD *)(a11 + 240));
        v19 = v31;
        if ((_DWORD)v31 == -37)
          return v19;
        if ((int)v31 < 1)
          goto LABEL_114;
        *(_DWORD *)(a1 + 152) = 0;
      }
      *(_DWORD *)a11 = 4;
LABEL_35:
      v80 = 0;
      v32 = (uint64_t *)(a11 + 112);
      v33 = _libssh2_packet_require(a1, a8, (_QWORD *)(a11 + 16), (unint64_t *)(a11 + 112), 0, 0, 0, a11 + 224);
      if (v33)
      {
        if (v33 == -37)
          return 4294967259;
        v21 = "Timed out waiting for KEX reply";
        v22 = a1;
        v23 = 4294967287;
        goto LABEL_113;
      }
      if ((unint64_t)*v32 <= 4)
      {
        v21 = "Unexpected packet length DH-SHA";
        goto LABEL_14;
      }
      v34 = *(_QWORD *)(a11 + 16);
      v81[2] = *v32;
      v81[0] = v34;
      v81[1] = v34 + 1;
      v35 = *(_QWORD *)(a1 + 200);
      if (v35)
        (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v35, a1);
      if (_libssh2_copy_string(a1, v81, (_QWORD *)(a1 + 200), (size_t *)&v80))
      {
        v21 = "Could not copy host key";
        goto LABEL_112;
      }
      *(_DWORD *)(a1 + 208) = v80;
      ctx = 0;
      if (_libssh2_md5_init(&ctx))
      {
        EVP_DigestUpdate(ctx, *(const void **)(a1 + 200), *(unsigned int *)(a1 + 208));
        EVP_DigestFinal(ctx, (unsigned __int8 *)(a1 + 212), 0);
        EVP_MD_CTX_free(ctx);
        v36 = 1;
      }
      else
      {
        v36 = 0;
      }
      *(_DWORD *)(a1 + 228) = v36;
      ctx = 0;
      if (_libssh2_sha1_init(&ctx))
      {
        EVP_DigestUpdate(ctx, *(const void **)(a1 + 200), *(unsigned int *)(a1 + 208));
        EVP_DigestFinal(ctx, (unsigned __int8 *)(a1 + 232), 0);
        EVP_MD_CTX_free(ctx);
        v37 = 1;
      }
      else
      {
        v37 = 0;
      }
      *(_DWORD *)(a1 + 252) = v37;
      ctx = 0;
      if (_libssh2_sha256_init(&ctx))
      {
        EVP_DigestUpdate(ctx, *(const void **)(a1 + 200), *(unsigned int *)(a1 + 208));
        EVP_DigestFinal(ctx, (unsigned __int8 *)(a1 + 256), 0);
        EVP_MD_CTX_free(ctx);
        v38 = 1;
      }
      else
      {
        v38 = 0;
      }
      *(_DWORD *)(a1 + 288) = v38;
      if ((*(unsigned int (**)(uint64_t, _QWORD, _QWORD, uint64_t))(*(_QWORD *)(a1 + 184) + 16))(a1, *(_QWORD *)(a1 + 200), *(unsigned int *)(a1 + 208), a1 + 192))
      {
        v21 = "Unable to initialize hostkey importer DH-SHA";
LABEL_61:
        v22 = a1;
        v23 = 4294967286;
        goto LABEL_113;
      }
      if (_libssh2_get_string(v81, (_QWORD *)(a11 + 168), (_QWORD *)(a11 + 192)))
      {
        v21 = "Unable to get DH-SHA f value";
        goto LABEL_61;
      }
      BN_bin2bn(*(const unsigned __int8 **)(a11 + 168), *(_DWORD *)(a11 + 192), *(BIGNUM **)(a11 + 152));
      if (_libssh2_get_string(v81, (_QWORD *)(a11 + 184), (_QWORD *)(a11 + 208)))
      {
        v21 = "Unable to get DH-SHA h sig";
        goto LABEL_61;
      }
      _libssh2_dh_secret((const BIGNUM **)(a11 + 136), *(BIGNUM **)(a11 + 160), *(BIGNUM **)(a11 + 152), a3, *(BN_CTX **)(a11 + 128));
      v39 = BN_num_bits(*(const BIGNUM **)(a11 + 160));
      v40 = v39 + 7;
      if (v39 < -7)
        v40 = v39 + 14;
      *(_QWORD *)(a11 + 200) = (v40 >> 3) + 5;
      v41 = BN_num_bits(*(const BIGNUM **)(a11 + 160));
      v42 = *(_QWORD *)(a11 + 200);
      if ((v41 & 7) != 0)
        *(_QWORD *)(a11 + 200) = --v42;
      v43 = (_DWORD *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 8))(v42, a1);
      *(_QWORD *)(a11 + 176) = v43;
      if (!v43)
      {
        v21 = "Unable to allocate buffer for DH-SHA K";
        goto LABEL_112;
      }
      _libssh2_htonu32(v43, *(_DWORD *)(a11 + 200) - 4);
      if ((BN_num_bits(*(const BIGNUM **)(a11 + 160)) & 7) != 0)
      {
        v44 = 4;
      }
      else
      {
        *(_BYTE *)(*(_QWORD *)(a11 + 176) + 4) = 0;
        v44 = 5;
      }
      BN_bn2bin(*(const BIGNUM **)(a11 + 160), (unsigned __int8 *)(*(_QWORD *)(a11 + 176) + v44));
      *(_QWORD *)(a11 + 216) = v82;
      _libssh2_sha_algo_ctx_init(a5, *(EVP_MD_CTX ***)v82);
      v45 = *(const char **)(a1 + 424);
      if (v45)
      {
        v46 = strlen(v45);
        _libssh2_htonu32((_DWORD *)(a11 + 32), v46 - 2);
        _libssh2_sha_algo_ctx_update(a5, *(EVP_MD_CTX ***)v82, (void *)(a11 + 32), 4uLL);
        v47 = strlen(*(const char **)(a1 + 424)) - 2;
        v48 = a5;
        v49 = *(EVP_MD_CTX ***)v82;
        v50 = *(char **)(a1 + 424);
      }
      else
      {
        _libssh2_htonu32((_DWORD *)(a11 + 32), 0x16u);
        _libssh2_sha_algo_ctx_update(a5, *(EVP_MD_CTX ***)v82, (void *)(a11 + 32), 4uLL);
        v49 = *(EVP_MD_CTX ***)v82;
        v50 = "SSH-2.0-libssh2_1.11.0";
        v48 = a5;
        v47 = 22;
      }
      _libssh2_sha_algo_ctx_update(v48, v49, v50, v47);
      v51 = strlen(*(const char **)(a1 + 312));
      _libssh2_htonu32((_DWORD *)(a11 + 32), v51);
      _libssh2_sha_algo_ctx_update(a5, *(EVP_MD_CTX ***)v82, (void *)(a11 + 32), 4uLL);
      v52 = strlen(*(const char **)(a1 + 312));
      _libssh2_sha_algo_ctx_update(a5, *(EVP_MD_CTX ***)v82, *(void **)(a1 + 312), v52);
      _libssh2_htonu32((_DWORD *)(a11 + 32), *(_DWORD *)(a1 + 440));
      _libssh2_sha_algo_ctx_update(a5, *(EVP_MD_CTX ***)v82, (void *)(a11 + 32), 4uLL);
      _libssh2_sha_algo_ctx_update(a5, *(EVP_MD_CTX ***)v82, *(void **)(a1 + 432), *(_QWORD *)(a1 + 440));
      _libssh2_htonu32((_DWORD *)(a11 + 32), *(_DWORD *)(a1 + 328));
      _libssh2_sha_algo_ctx_update(a5, *(EVP_MD_CTX ***)v82, (void *)(a11 + 32), 4uLL);
      _libssh2_sha_algo_ctx_update(a5, *(EVP_MD_CTX ***)v82, *(void **)(a1 + 320), *(_QWORD *)(a1 + 328));
      _libssh2_htonu32((_DWORD *)(a11 + 32), *(_DWORD *)(a1 + 208));
      _libssh2_sha_algo_ctx_update(a5, *(EVP_MD_CTX ***)v82, (void *)(a11 + 32), 4uLL);
      _libssh2_sha_algo_ctx_update(a5, *(EVP_MD_CTX ***)v82, *(void **)(a1 + 200), *(unsigned int *)(a1 + 208));
      if (a7 == 32)
      {
        _libssh2_htonu32((_DWORD *)(a11 + 32), 0x800u);
        _libssh2_htonu32((_DWORD *)(a11 + 36), 0x1000u);
        _libssh2_htonu32((_DWORD *)(a11 + 40), 0x2000u);
        _libssh2_sha_algo_ctx_update(a5, *(EVP_MD_CTX ***)v82, (void *)(a11 + 32), 0xCuLL);
      }
      if (a9)
        _libssh2_sha_algo_ctx_update(a5, *(EVP_MD_CTX ***)v82, a9, cnt);
      _libssh2_sha_algo_ctx_update(a5, *(EVP_MD_CTX ***)v82, (void *)(*(_QWORD *)(a11 + 8) + 1), *(_QWORD *)(a11 + 104) - 1);
      _libssh2_htonu32((_DWORD *)(a11 + 32), *(_DWORD *)(a11 + 192));
      _libssh2_sha_algo_ctx_update(a5, *(EVP_MD_CTX ***)v82, (void *)(a11 + 32), 4uLL);
      _libssh2_sha_algo_ctx_update(a5, *(EVP_MD_CTX ***)v82, *(void **)(a11 + 168), *(_QWORD *)(a11 + 192));
      _libssh2_sha_algo_ctx_update(a5, *(EVP_MD_CTX ***)v82, *(void **)(a11 + 176), *(_QWORD *)(a11 + 200));
      _libssh2_sha_algo_ctx_final(a5, *(EVP_MD_CTX ***)v82, (unsigned __int8 *)(a11 + 32));
      if ((*(unsigned int (**)(uint64_t, _QWORD, _QWORD, uint64_t, _QWORD, uint64_t))(*(_QWORD *)(a1 + 184)
                                                                                             + 40))(a1, *(_QWORD *)(a11 + 184), *(_QWORD *)(a11 + 208), a11 + 32, v18, a1 + 192))
      {
        v21 = "Unable to verify hostkey signature DH-SHA";
        v22 = a1;
        v23 = 4294967285;
LABEL_113:
        v19 = _libssh2_error(v22, v23, v21);
        goto LABEL_114;
      }
      *(_BYTE *)(a11 + 96) = 21;
      *(_DWORD *)a11 = 5;
LABEL_81:
      v53 = _libssh2_transport_send(a1, (void *)(a11 + 96), 1uLL, 0, 0);
      v19 = v53;
      if ((_DWORD)v53 != -37)
      {
        if ((_DWORD)v53)
        {
          v21 = "Unable to send NEWKEYS message DH-SHA";
          goto LABEL_106;
        }
        *(_DWORD *)a11 = 6;
LABEL_84:
        v54 = _libssh2_packet_require(a1, 21, (_QWORD *)(a11 + 24), (unint64_t *)(a11 + 120), 0, 0, 0, a11 + 224);
        v19 = v54;
        if ((_DWORD)v54 != -37)
        {
          if (!(_DWORD)v54)
          {
            *(_DWORD *)(a1 + 128) |= 2u;
            (*(void (**)(_QWORD, uint64_t))(a1 + 24))(*(_QWORD *)(a11 + 24), a1);
            if (!*(_QWORD *)(a1 + 160))
            {
              v55 = (void *)(*(uint64_t (**)(_QWORD, uint64_t))(a1 + 8))(v18, a1);
              *(_QWORD *)(a1 + 160) = v55;
              if (!v55)
              {
                v21 = "Unable to allocate buffer for SHA digest";
                goto LABEL_112;
              }
              memcpy(v55, (const void *)(a11 + 32), v18);
              *(_DWORD *)(a1 + 168) = v18;
            }
            v56 = *(_QWORD *)(a1 + 448);
            v57 = *(void (**)(uint64_t, uint64_t))(v56 + 56);
            if (v57)
            {
              v57(a1, a1 + 456);
              v56 = *(_QWORD *)(a1 + 448);
            }
            if (*(_QWORD *)(v56 + 40))
            {
              v80 = 0;
              v81[0] = 0;
              LODWORD(ctx) = 0;
              _libssh2_sha_algo_value_hash(a5, a1, a11, v81, *(int *)(v56 + 20), "A");
              v58 = (void *)v81[0];
              if (!v81[0])
              {
                v19 = 0xFFFFFFFFLL;
LABEL_114:
                _libssh2_dh_dtor((BIGNUM **)(a11 + 136));
                BN_clear_free(*(BIGNUM **)(a11 + 144));
                *(_QWORD *)(a11 + 144) = 0;
                BN_clear_free(*(BIGNUM **)(a11 + 152));
                *(_QWORD *)(a11 + 152) = 0;
                BN_clear_free(*(BIGNUM **)(a11 + 160));
                *(_QWORD *)(a11 + 160) = 0;
                BN_CTX_free(*(BN_CTX **)(a11 + 128));
                *(_QWORD *)(a11 + 128) = 0;
                v62 = *(_QWORD *)(a11 + 8);
                if (v62)
                {
                  (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v62, a1);
                  *(_QWORD *)(a11 + 8) = 0;
                }
                v63 = *(_QWORD *)(a11 + 16);
                if (v63)
                {
                  (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v63, a1);
                  *(_QWORD *)(a11 + 16) = 0;
                }
                v64 = *(_QWORD *)(a11 + 176);
                if (v64)
                {
                  (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v64, a1);
                  *(_QWORD *)(a11 + 176) = 0;
                }
                *(_DWORD *)a11 = 0;
                return v19;
              }
              _libssh2_sha_algo_value_hash(a5, a1, a11, &v80, *(int *)(*(_QWORD *)(a1 + 448) + 24), "C");
              v59 = v80;
              if (!v80)
                goto LABEL_108;
              if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)(a1 + 448) + 40))(a1))
              {
LABEL_103:
                (*(void (**)(void *, uint64_t))(a1 + 24))(v58, a1);
LABEL_109:
                (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v59, a1);
                goto LABEL_110;
              }
              if ((_DWORD)ctx)
              {
                memset_s(v58, *(int *)(*(_QWORD *)(a1 + 448) + 20), 0, *(int *)(*(_QWORD *)(a1 + 448) + 20));
                (*(void (**)(void *, uint64_t))(a1 + 24))(v58, a1);
              }
            }
            v60 = *(_QWORD *)(a1 + 336);
            v61 = *(void (**)(uint64_t, uint64_t))(v60 + 56);
            if (v61)
            {
              v61(a1, a1 + 344);
              v60 = *(_QWORD *)(a1 + 336);
            }
            if (!*(_QWORD *)(v60 + 40))
              goto LABEL_124;
            v80 = 0;
            v81[0] = 0;
            LODWORD(ctx) = 0;
            _libssh2_sha_algo_value_hash(a5, a1, a11, v81, *(int *)(v60 + 20), "B");
            v58 = (void *)v81[0];
            if (!v81[0])
            {
LABEL_110:
              v19 = 4294967291;
              goto LABEL_114;
            }
            _libssh2_sha_algo_value_hash(a5, a1, a11, &v80, *(int *)(*(_QWORD *)(a1 + 336) + 24), "D");
            v59 = v80;
            if (v80)
            {
              if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)(a1 + 336) + 40))(a1))
                goto LABEL_103;
              if ((_DWORD)ctx)
              {
                memset_s(v58, *(int *)(*(_QWORD *)(a1 + 336) + 20), 0, *(int *)(*(_QWORD *)(a1 + 336) + 20));
                (*(void (**)(void *, uint64_t))(a1 + 24))(v58, a1);
              }
LABEL_124:
              v66 = *(_QWORD *)(a1 + 464);
              v67 = *(void (**)(uint64_t, uint64_t))(v66 + 32);
              if (v67)
              {
                v67(a1, a1 + 480);
                v66 = *(_QWORD *)(a1 + 464);
              }
              if (*(_QWORD *)(v66 + 16))
              {
                v81[0] = 0;
                LODWORD(v80) = 0;
                _libssh2_sha_algo_value_hash(a5, a1, a11, v81, *(int *)(v66 + 12), "E");
                v68 = (void *)v81[0];
                if (!v81[0])
                  goto LABEL_110;
                (*(void (**)(uint64_t, uint64_t, uint64_t *, uint64_t))(*(_QWORD *)(a1 + 464) + 16))(a1, v81[0], &v80, a1 + 480);
                if ((_DWORD)v80)
                {
                  memset_s(v68, *(int *)(*(_QWORD *)(a1 + 464) + 12), 0, *(int *)(*(_QWORD *)(a1 + 464) + 12));
                  (*(void (**)(void *, uint64_t))(a1 + 24))(v68, a1);
                }
              }
              v69 = *(_QWORD *)(a1 + 352);
              v70 = *(void (**)(uint64_t, uint64_t))(v69 + 32);
              if (v70)
              {
                v70(a1, a1 + 368);
                v69 = *(_QWORD *)(a1 + 352);
              }
              if (*(_QWORD *)(v69 + 16))
              {
                v81[0] = 0;
                LODWORD(v80) = 0;
                _libssh2_sha_algo_value_hash(a5, a1, a11, v81, *(int *)(v69 + 12), "F");
                v71 = (void *)v81[0];
                if (!v81[0])
                  goto LABEL_110;
                (*(void (**)(uint64_t, uint64_t, uint64_t *, uint64_t))(*(_QWORD *)(a1 + 352) + 16))(a1, v81[0], &v80, a1 + 368);
                if ((_DWORD)v80)
                {
                  memset_s(v71, *(int *)(*(_QWORD *)(a1 + 352) + 12), 0, *(int *)(*(_QWORD *)(a1 + 352) + 12));
                  (*(void (**)(void *, uint64_t))(a1 + 24))(v71, a1);
                }
              }
              v72 = *(_QWORD *)(a1 + 488);
              if (!v72
                || (v73 = *(void (**)(uint64_t, uint64_t, uint64_t))(v72 + 40)) != 0
                && (v73(a1, 1, a1 + 496), (v72 = *(_QWORD *)(a1 + 488)) == 0)
                || (v74 = *(unsigned int (**)(uint64_t, uint64_t, uint64_t))(v72 + 16)) == 0
                || !v74(a1, 1, a1 + 496))
              {
                v75 = *(_QWORD *)(a1 + 376);
                if (v75
                  && ((v76 = *(void (**)(uint64_t, _QWORD, uint64_t))(v75 + 40)) == 0
                   || (v76(a1, 0, a1 + 384), (v75 = *(_QWORD *)(a1 + 376)) != 0))
                  && (v77 = *(unsigned int (**)(uint64_t, _QWORD, uint64_t))(v75 + 16)) != 0)
                {
                  if (v77(a1, 0, a1 + 384))
                    v19 = 4294967291;
                  else
                    v19 = 0;
                }
                else
                {
                  v19 = 0;
                }
                goto LABEL_114;
              }
              goto LABEL_110;
            }
LABEL_108:
            v59 = (uint64_t)v58;
            goto LABEL_109;
          }
          v21 = "Timed out waiting for NEWKEYS DH-SHA";
LABEL_106:
          v22 = a1;
          v23 = v19;
          goto LABEL_113;
        }
      }
      return v19;
    case 2:
      goto LABEL_27;
    case 3:
      goto LABEL_30;
    case 4:
      goto LABEL_35;
    case 5:
      goto LABEL_81;
    case 6:
      goto LABEL_84;
    default:
      goto LABEL_114;
  }
}

uint64_t _libssh2_sha_algo_ctx_init(int a1, EVP_MD_CTX **a2)
{
  if (a1 > 383)
  {
    if (a1 == 384)
    {
      return _libssh2_sha384_init(a2);
    }
    else
    {
      if (a1 != 512)
        goto LABEL_10;
      return _libssh2_sha512_init(a2);
    }
  }
  else
  {
    if (a1 != 1)
    {
      if (a1 == 256)
        return _libssh2_sha256_init(a2);
LABEL_10:
      _libssh2_sha_algo_ctx_init_cold_1();
    }
    return _libssh2_sha1_init(a2);
  }
}

uint64_t _libssh2_sha_algo_ctx_update(uint64_t result, EVP_MD_CTX **a2, void *d, size_t cnt)
{
  if ((int)result <= 383)
  {
    if ((_DWORD)result != 1 && (_DWORD)result != 256)
      return result;
    return EVP_DigestUpdate(*a2, d, cnt);
  }
  if ((_DWORD)result == 512 || (_DWORD)result == 384)
    return EVP_DigestUpdate(*a2, d, cnt);
  return result;
}

void _libssh2_sha_algo_ctx_final(int a1, EVP_MD_CTX **a2, unsigned __int8 *md)
{
  if (a1 <= 383)
  {
    if (a1 != 1 && a1 != 256)
      return;
LABEL_7:
    EVP_DigestFinal(*a2, md, 0);
    EVP_MD_CTX_free(*a2);
    return;
  }
  if (a1 == 512 || a1 == 384)
    goto LABEL_7;
}

void _libssh2_sha_algo_value_hash(int a1, uint64_t a2, uint64_t a3, uint64_t *a4, size_t a5, const void *a6)
{
  uint64_t v11;
  size_t v12;
  EVP_MD_CTX *v13;
  const void *v14;
  size_t v15;
  uint64_t v16;
  size_t v17;
  EVP_MD_CTX *v18;
  const void *v19;
  size_t v20;
  uint64_t v21;
  size_t v22;
  EVP_MD_CTX *v23;
  const void *v24;
  size_t v25;
  uint64_t v26;
  size_t v27;
  EVP_MD_CTX *v28;
  const void *v29;
  size_t v30;
  EVP_MD_CTX *ctx;

  if (a1 > 383)
  {
    if (a1 == 384)
    {
      ctx = 0;
      v26 = *a4;
      if (!*a4)
      {
        v26 = (*(uint64_t (**)(size_t, uint64_t))(a2 + 8))(a5 + 48, a2);
        *a4 = v26;
      }
      if (v26 && a5)
      {
        v27 = 0;
        do
        {
          _libssh2_sha384_init(&ctx);
          EVP_DigestUpdate(ctx, *(const void **)(a3 + 176), *(_QWORD *)(a3 + 200));
          EVP_DigestUpdate(ctx, (const void *)(a3 + 32), 0x30uLL);
          v28 = ctx;
          if (v27)
          {
            v29 = (const void *)*a4;
            v30 = v27;
          }
          else
          {
            EVP_DigestUpdate(ctx, a6, 1uLL);
            v28 = ctx;
            v29 = *(const void **)(a2 + 160);
            v30 = *(unsigned int *)(a2 + 168);
          }
          EVP_DigestUpdate(v28, v29, v30);
          EVP_DigestFinal(ctx, (unsigned __int8 *)(*a4 + v27), 0);
          EVP_MD_CTX_free(ctx);
          v27 += 48;
        }
        while (v27 < a5);
      }
    }
    else if (a1 == 512)
    {
      ctx = 0;
      v16 = *a4;
      if (!*a4)
      {
        v16 = (*(uint64_t (**)(size_t, uint64_t))(a2 + 8))(a5 + 64, a2);
        *a4 = v16;
      }
      if (v16 && a5)
      {
        v17 = 0;
        do
        {
          _libssh2_sha512_init(&ctx);
          EVP_DigestUpdate(ctx, *(const void **)(a3 + 176), *(_QWORD *)(a3 + 200));
          EVP_DigestUpdate(ctx, (const void *)(a3 + 32), 0x40uLL);
          v18 = ctx;
          if (v17)
          {
            v19 = (const void *)*a4;
            v20 = v17;
          }
          else
          {
            EVP_DigestUpdate(ctx, a6, 1uLL);
            v18 = ctx;
            v19 = *(const void **)(a2 + 160);
            v20 = *(unsigned int *)(a2 + 168);
          }
          EVP_DigestUpdate(v18, v19, v20);
          EVP_DigestFinal(ctx, (unsigned __int8 *)(*a4 + v17), 0);
          EVP_MD_CTX_free(ctx);
          v17 += 64;
        }
        while (v17 < a5);
      }
    }
  }
  else if (a1 == 1)
  {
    ctx = 0;
    v21 = *a4;
    if (!*a4)
    {
      v21 = (*(uint64_t (**)(size_t, uint64_t))(a2 + 8))(a5 + 20, a2);
      *a4 = v21;
    }
    if (v21 && a5)
    {
      v22 = 0;
      do
      {
        _libssh2_sha1_init(&ctx);
        EVP_DigestUpdate(ctx, *(const void **)(a3 + 176), *(_QWORD *)(a3 + 200));
        EVP_DigestUpdate(ctx, (const void *)(a3 + 32), 0x14uLL);
        v23 = ctx;
        if (v22)
        {
          v24 = (const void *)*a4;
          v25 = v22;
        }
        else
        {
          EVP_DigestUpdate(ctx, a6, 1uLL);
          v23 = ctx;
          v24 = *(const void **)(a2 + 160);
          v25 = *(unsigned int *)(a2 + 168);
        }
        EVP_DigestUpdate(v23, v24, v25);
        EVP_DigestFinal(ctx, (unsigned __int8 *)(*a4 + v22), 0);
        EVP_MD_CTX_free(ctx);
        v22 += 20;
      }
      while (v22 < a5);
    }
  }
  else if (a1 == 256)
  {
    ctx = 0;
    v11 = *a4;
    if (!*a4)
    {
      v11 = (*(uint64_t (**)(size_t, uint64_t))(a2 + 8))(a5 + 32, a2);
      *a4 = v11;
    }
    if (v11 && a5)
    {
      v12 = 0;
      do
      {
        _libssh2_sha256_init(&ctx);
        EVP_DigestUpdate(ctx, *(const void **)(a3 + 176), *(_QWORD *)(a3 + 200));
        EVP_DigestUpdate(ctx, (const void *)(a3 + 32), 0x20uLL);
        v13 = ctx;
        if (v12)
        {
          v14 = (const void *)*a4;
          v15 = v12;
        }
        else
        {
          EVP_DigestUpdate(ctx, a6, 1uLL);
          v13 = ctx;
          v14 = *(const void **)(a2 + 160);
          v15 = *(unsigned int *)(a2 + 168);
        }
        EVP_DigestUpdate(v13, v14, v15);
        EVP_DigestFinal(ctx, (unsigned __int8 *)(*a4 + v12), 0);
        EVP_MD_CTX_free(ctx);
        v12 += 32;
      }
      while (v12 < a5);
    }
  }
}

uint64_t kex_method_diffie_hellman_group16_sha512_key_exchange(uint64_t a1, uint64_t a2)
{
  BIGNUM *v4;
  const BIGNUM *v5;
  const BIGNUM *v6;
  uint64_t v7;
  uint64_t v9;

  if (!*(_DWORD *)a2)
  {
    *(_QWORD *)(a2 + 272) = BN_new();
    v4 = BN_new();
    *(_QWORD *)(a2 + 280) = v4;
    BN_set_word(v4, 2uLL);
    BN_bin2bn(kex_method_diffie_hellman_group16_sha512_key_exchange_p_value, 512, *(BIGNUM **)(a2 + 272));
    *(_DWORD *)a2 = 2;
  }
  v6 = *(const BIGNUM **)(a2 + 272);
  v5 = *(const BIGNUM **)(a2 + 280);
  v9 = 0;
  v7 = diffie_hellman_sha_algo(a1, v5, v6, 512, 512, (uint64_t)&v9, 30, 31, 0, 0, a2 + 24);
  if ((_DWORD)v7 != -37)
  {
    *(_DWORD *)a2 = 0;
    BN_clear_free(*(BIGNUM **)(a2 + 272));
    *(_QWORD *)(a2 + 272) = 0;
    BN_clear_free(*(BIGNUM **)(a2 + 280));
    *(_QWORD *)(a2 + 280) = 0;
  }
  return v7;
}

uint64_t kex_method_diffie_hellman_group18_sha512_key_exchange(uint64_t a1, uint64_t a2)
{
  BIGNUM *v4;
  const BIGNUM *v5;
  const BIGNUM *v6;
  uint64_t v7;
  uint64_t v9;

  if (!*(_DWORD *)a2)
  {
    *(_QWORD *)(a2 + 272) = BN_new();
    v4 = BN_new();
    *(_QWORD *)(a2 + 280) = v4;
    BN_set_word(v4, 2uLL);
    BN_bin2bn(kex_method_diffie_hellman_group18_sha512_key_exchange_p_value, 1024, *(BIGNUM **)(a2 + 272));
    *(_DWORD *)a2 = 2;
  }
  v6 = *(const BIGNUM **)(a2 + 272);
  v5 = *(const BIGNUM **)(a2 + 280);
  v9 = 0;
  v7 = diffie_hellman_sha_algo(a1, v5, v6, 1024, 512, (uint64_t)&v9, 30, 31, 0, 0, a2 + 24);
  if ((_DWORD)v7 != -37)
  {
    *(_DWORD *)a2 = 0;
    BN_clear_free(*(BIGNUM **)(a2 + 272));
    *(_QWORD *)(a2 + 272) = 0;
    BN_clear_free(*(BIGNUM **)(a2 + 280));
    *(_QWORD *)(a2 + 280) = 0;
  }
  return v7;
}

uint64_t kex_method_diffie_hellman_group14_sha256_key_exchange(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  v3 = 0;
  return kex_method_diffie_hellman_group14_key_exchange(a1, a2, 256, (uint64_t)&v3);
}

uint64_t kex_method_diffie_hellman_group14_key_exchange(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  BIGNUM *v8;
  uint64_t v9;

  if (!*(_DWORD *)a2)
  {
    *(_QWORD *)(a2 + 272) = BN_new();
    v8 = BN_new();
    *(_QWORD *)(a2 + 280) = v8;
    BN_set_word(v8, 2uLL);
    BN_bin2bn(kex_method_diffie_hellman_group14_key_exchange_p_value, 256, *(BIGNUM **)(a2 + 272));
    *(_DWORD *)a2 = 2;
  }
  v9 = diffie_hellman_sha_algo(a1, *(const BIGNUM **)(a2 + 280), *(const BIGNUM **)(a2 + 272), 256, a3, a4, 30, 31, 0, 0, a2 + 24);
  if ((_DWORD)v9 != -37)
  {
    *(_DWORD *)a2 = 0;
    BN_clear_free(*(BIGNUM **)(a2 + 272));
    *(_QWORD *)(a2 + 272) = 0;
    BN_clear_free(*(BIGNUM **)(a2 + 280));
    *(_QWORD *)(a2 + 280) = 0;
  }
  return v9;
}

uint64_t kex_method_diffie_hellman_group14_sha1_key_exchange(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  v3 = 0;
  return kex_method_diffie_hellman_group14_key_exchange(a1, a2, 1, (uint64_t)&v3);
}

uint64_t kex_method_diffie_hellman_group1_sha1_key_exchange(uint64_t a1, uint64_t a2)
{
  BIGNUM *v4;
  const BIGNUM *v5;
  const BIGNUM *v6;
  uint64_t v7;
  uint64_t v9;

  if (!*(_DWORD *)a2)
  {
    *(_QWORD *)(a2 + 272) = BN_new();
    v4 = BN_new();
    *(_QWORD *)(a2 + 280) = v4;
    BN_set_word(v4, 2uLL);
    BN_bin2bn(kex_method_diffie_hellman_group1_sha1_key_exchange_p_value, 128, *(BIGNUM **)(a2 + 272));
    *(_DWORD *)a2 = 2;
  }
  v6 = *(const BIGNUM **)(a2 + 272);
  v5 = *(const BIGNUM **)(a2 + 280);
  v9 = 0;
  v7 = diffie_hellman_sha_algo(a1, v5, v6, 128, 1, (uint64_t)&v9, 30, 31, 0, 0, a2 + 24);
  if ((_DWORD)v7 != -37)
  {
    BN_clear_free(*(BIGNUM **)(a2 + 272));
    *(_QWORD *)(a2 + 272) = 0;
    BN_clear_free(*(BIGNUM **)(a2 + 280));
    *(_QWORD *)(a2 + 280) = 0;
    *(_DWORD *)a2 = 0;
  }
  return v7;
}

uint64_t kex_method_diffie_hellman_group_exchange_sha1_key_exchange(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  size_t v5;
  uint64_t v6;
  uint64_t v7;
  char *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v13;
  _QWORD v14[3];
  unsigned __int8 *s;
  const unsigned __int8 *v16;
  uint64_t v17;
  uint64_t v18;

  v3 = 0;
  switch(*(_DWORD *)a2)
  {
    case 0:
      *(_QWORD *)(a2 + 272) = BN_new();
      *(_QWORD *)(a2 + 280) = BN_new();
      *(_BYTE *)(a2 + 288) = 34;
      _libssh2_htonu32((_DWORD *)(a2 + 289), 0x800u);
      _libssh2_htonu32((_DWORD *)(a2 + 293), 0x1000u);
      _libssh2_htonu32((_DWORD *)(a2 + 297), 0x2000u);
      v5 = 13;
      *(_QWORD *)(a2 + 552) = 13;
      *(_DWORD *)a2 = 2;
      goto LABEL_4;
    case 2:
      v5 = *(_QWORD *)(a2 + 552);
LABEL_4:
      v6 = _libssh2_transport_send(a1, (void *)(a2 + 288), v5, 0, 0);
      v3 = v6;
      if ((_DWORD)v6 == -37)
        return v3;
      if ((_DWORD)v6)
      {
        v8 = "Unable to send Group Exchange Request";
LABEL_16:
        v10 = a1;
        v11 = v3;
LABEL_20:
        v3 = _libssh2_error(v10, v11, v8);
LABEL_21:
        *(_DWORD *)a2 = 0;
        BN_clear_free(*(BIGNUM **)(a2 + 280));
        *(_QWORD *)(a2 + 280) = 0;
        BN_clear_free(*(BIGNUM **)(a2 + 272));
        *(_QWORD *)(a2 + 272) = 0;
        return v3;
      }
      *(_DWORD *)a2 = 3;
LABEL_7:
      v7 = _libssh2_packet_require(a1, 31, (_QWORD *)(a2 + 544), (unint64_t *)(a2 + 560), 0, 0, 0, a2 + 8);
      v3 = v7;
      if ((_DWORD)v7 == -37)
        return v3;
      if ((_DWORD)v7)
      {
        v8 = "Timeout waiting for GEX_GROUP reply";
        goto LABEL_16;
      }
      *(_DWORD *)a2 = 4;
LABEL_10:
      v17 = 0;
      v18 = 0;
      v16 = 0;
      s = 0;
      v13 = 0;
      if (*(_QWORD *)(a2 + 560) <= 8uLL)
      {
        v8 = "Unexpected key length DH-SHA1";
LABEL_19:
        v10 = a1;
        v11 = 4294967282;
        goto LABEL_20;
      }
      v9 = *(_QWORD *)(a2 + 544);
      v14[2] = *(_QWORD *)(a2 + 560);
      v14[0] = v9;
      v14[1] = v9 + 1;
      if (_libssh2_get_bignum_bytes(v14, &v16, &v18))
      {
        v8 = "Unexpected value DH-SHA1 p";
        goto LABEL_19;
      }
      if (_libssh2_get_bignum_bytes(v14, &s, &v17))
      {
        v8 = "Unexpected value DH-SHA1 g";
        goto LABEL_19;
      }
      BN_bin2bn(v16, v18, *(BIGNUM **)(a2 + 272));
      BN_bin2bn(s, v17, *(BIGNUM **)(a2 + 280));
      v3 = diffie_hellman_sha_algo(a1, *(const BIGNUM **)(a2 + 280), *(const BIGNUM **)(a2 + 272), v18, 1, (uint64_t)&v13, 32, 33, (void *)(*(_QWORD *)(a2 + 544) + 1), *(_QWORD *)(a2 + 560) - 1, a2 + 24);
      if ((_DWORD)v3 != -37)
      {
        (*(void (**)(_QWORD, uint64_t))(a1 + 24))(*(_QWORD *)(a2 + 544), a1);
        goto LABEL_21;
      }
      return v3;
    case 3:
      goto LABEL_7;
    case 4:
      goto LABEL_10;
    default:
      goto LABEL_21;
  }
}

void _libssh2_sha_algo_ctx_init_cold_1()
{
  __assert_rtn("_libssh2_sha_algo_ctx_init", "kex.c", 122, "0");
}

uint64_t _libssh2_error_flags(uint64_t a1, uint64_t a2, char *__s, char a4)
{
  size_t v8;
  void *v9;
  void *v10;

  if (a1)
  {
    if ((*(_BYTE *)(a1 + 620) & 1) != 0)
      (*(void (**)(_QWORD, uint64_t))(a1 + 24))(*(_QWORD *)(a1 + 608), a1);
    *(_DWORD *)(a1 + 616) = a2;
    *(_DWORD *)(a1 + 620) = 0;
    if (__s && (a4 & 1) != 0)
    {
      v8 = strlen(__s) + 1;
      v9 = (void *)(*(uint64_t (**)(size_t, uint64_t))(a1 + 8))(v8, a1);
      if (v9)
      {
        v10 = v9;
        memcpy(v9, __s, v8);
        *(_DWORD *)(a1 + 620) = 1;
        *(_QWORD *)(a1 + 608) = v10;
      }
      else
      {
        *(_QWORD *)(a1 + 608) = "former error forgotten (OOM)";
      }
    }
    else
    {
      *(_QWORD *)(a1 + 608) = __s;
    }
  }
  else if (__s)
  {
    fprintf((FILE *)*MEMORY[0x24BDAC8D8], "Session is NULL, error: %s\n", __s);
  }
  return a2;
}

uint64_t _libssh2_error(uint64_t a1, uint64_t a2, char *a3)
{
  return _libssh2_error_flags(a1, a2, a3, 0);
}

ssize_t _libssh2_recv(int a1, void *a2, size_t a3, int a4)
{
  ssize_t result;

  result = recv(a1, a2, a3, a4);
  if (result < 0)
  {
    if (*__error() == 2 || *__error() == 35)
      return -35;
    else
      return -(uint64_t)*__error();
  }
  return result;
}

ssize_t _libssh2_send(int a1, const void *a2, size_t a3, int a4)
{
  ssize_t result;

  result = send(a1, a2, a3, a4);
  if (result < 0)
  {
    if (*__error() == 35)
      return -35;
    else
      return -(uint64_t)*__error();
  }
  return result;
}

uint64_t _libssh2_ntohu32(unsigned int *a1)
{
  return bswap32(*a1);
}

unint64_t _libssh2_ntohu64(unint64_t *a1)
{
  return bswap64(*a1);
}

_DWORD *_libssh2_htonu32(_DWORD *result, unsigned int a2)
{
  *result = bswap32(a2);
  return result;
}

_DWORD **_libssh2_store_u32(_DWORD **result, unsigned int a2)
{
  *(*result)++ = bswap32(a2);
  return result;
}

uint64_t _libssh2_store_str(_DWORD **a1, const void *a2, unint64_t a3)
{
  _DWORD *v5;
  uint64_t v6;

  **a1 = bswap32(a3);
  v5 = *a1 + 1;
  *a1 = v5;
  v6 = a3;
  if ((_DWORD)a3)
  {
    memcpy(v5, a2, a3);
    *a1 = (_DWORD *)((char *)*a1 + v6);
  }
  if (HIDWORD(a3))
    _libssh2_store_str_cold_1();
  return 1;
}

uint64_t _libssh2_store_bignum2_bytes(_DWORD **a1, _BYTE *a2, uint64_t a3)
{
  uint64_t v3;
  _BYTE *v5;
  _BOOL4 v6;
  size_t v7;
  _BYTE *v8;

  v3 = a3;
  if (a3)
  {
    v5 = &a2[a3];
    while (!*a2)
    {
      ++a2;
      if (!--v3)
      {
        v6 = 0;
        a2 = v5;
        goto LABEL_8;
      }
    }
    v6 = (char)*a2 < 0;
  }
  else
  {
    v6 = 0;
  }
LABEL_8:
  if ((_DWORD)v3 == -1 && v6)
    v7 = 4294967294;
  else
    v7 = v3;
  **a1 = bswap32(v7 + v6);
  v8 = *a1 + 1;
  *a1 = v8;
  if (v6)
  {
    *v8 = 0;
    v8 = (char *)*a1 + 1;
    *a1 = v8;
  }
  if ((_DWORD)v7)
  {
    memcpy(v8, a2, v7);
    *a1 = (_DWORD *)((char *)*a1 + v7);
  }
  else
  {
    v7 = 0;
  }
  if (v3 != v7)
    _libssh2_store_bignum2_bytes_cold_1();
  return 1;
}

uint64_t libssh2_base64_decode(uint64_t a1, uint64_t *a2, _DWORD *a3, unsigned __int8 *a4, unsigned int a5)
{
  uint64_t result;
  uint64_t v7;

  v7 = 0;
  result = _libssh2_base64_decode(a1, a2, &v7, a4, a5);
  if (a3)
    *a3 = v7;
  return result;
}

uint64_t _libssh2_base64_decode(uint64_t a1, uint64_t *a2, _QWORD *a3, unsigned __int8 *a4, uint64_t a5)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unsigned __int8 *v13;
  unsigned int v14;
  uint64_t v15;
  char v16;
  char *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;

  v10 = (*(uint64_t (**)(unint64_t, uint64_t))(a1 + 8))(3 * ((unint64_t)a5 >> 2) + 1, a1);
  *a2 = v10;
  if (!v10)
  {
    v17 = "Unable to allocate memory for base64 decoding";
    v18 = 4294967290;
    v19 = a1;
    v20 = 4294967290;
    goto LABEL_19;
  }
  if (a5 < 1)
  {
    v11 = 0;
LABEL_21:
    v18 = 0;
    *a3 = v11;
    return v18;
  }
  v11 = 0;
  v12 = 0;
  v13 = &a4[a5];
  do
  {
    v14 = base64_reverse_table[*a4];
    if ((v14 & 0x80000000) == 0)
    {
      if (v12 <= 0)
        v15 = -(-v12 & 3);
      else
        v15 = v12 & 3;
      switch(v15)
      {
        case 0:
          v16 = 4 * v14;
          goto LABEL_12;
        case 1:
          *(_BYTE *)(v10 + v11++) |= v14 >> 4;
          v16 = 16 * v14;
          goto LABEL_12;
        case 2:
          *(_BYTE *)(v10 + v11++) |= v14 >> 2;
          v16 = (_BYTE)v14 << 6;
LABEL_12:
          *(_BYTE *)(v10 + v11) = v16;
          break;
        case 3:
          *(_BYTE *)(v10 + v11++) |= v14;
          break;
        default:
          break;
      }
      ++v12;
    }
    ++a4;
  }
  while (a4 < v13);
  if ((v12 & 0x8000000000000003) != 1)
    goto LABEL_21;
  (*(void (**)(uint64_t, uint64_t))(a1 + 24))(*a2, a1);
  *a2 = 0;
  v17 = "Invalid base64";
  v18 = 4294967262;
  v19 = a1;
  v20 = 4294967262;
LABEL_19:
  _libssh2_error_flags(v19, v20, v17, 0);
  return v18;
}

const char *_libssh2_base64_encode(uint64_t a1, char *__s, size_t a3, const char **a4)
{
  size_t v5;
  char *v6;
  const char *result;
  char *v9;
  uint64_t v10;
  int v11;
  char v12;
  char v13;
  unint64_t v14;
  unint64_t v15;
  unsigned __int8 v16;
  unint64_t v17;
  char v18;
  unsigned __int8 v19;
  unsigned __int8 v20;
  unsigned __int8 v21;

  v5 = a3;
  v6 = __s;
  *a4 = 0;
  if (!a3)
    v5 = strlen(__s);
  result = (const char *)(*(uint64_t (**)(size_t, uint64_t))(a1 + 8))(4 * v5 / 3 + 4, a1);
  if (result)
  {
    v9 = (char *)result;
    if (v5)
    {
      v9 = (char *)result;
      do
      {
        v10 = 0;
        v11 = 0;
        do
        {
          if (v5)
          {
            ++v11;
            v13 = *v6++;
            v12 = v13;
            --v5;
          }
          else
          {
            v12 = 0;
          }
          *(&v19 + v10++) = v12;
        }
        while (v10 != 3);
        v14 = (unint64_t)v19 >> 2;
        v15 = ((unint64_t)v20 >> 4) & 0xFFFFFFFFFFFFFFCFLL | (16 * (v19 & 3));
        v16 = v21;
        v17 = ((unint64_t)v21 >> 6) & 0xFFFFFFFFFFFFFFC3 | (4 * (v20 & 0xF));
        if (v11 == 2)
        {
          *v9 = table64[v14];
          v9[1] = table64[v15];
          v9[2] = table64[v17];
          v18 = 61;
        }
        else
        {
          *v9 = table64[v14];
          v9[1] = table64[v15];
          if (v11 == 1)
          {
            v18 = 61;
            v9[2] = 61;
          }
          else
          {
            v9[2] = table64[v17];
            v18 = table64[v16 & 0x3F];
          }
        }
        v9[3] = v18;
        v9 += 4;
      }
      while (v5);
    }
    *v9 = 0;
    *a4 = result;
    return (const char *)strlen(result);
  }
  return result;
}

uint64_t libssh2_free(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a2, a1);
}

uint64_t libssh2_trace()
{
  return 0;
}

uint64_t libssh2_trace_sethandler()
{
  return 0;
}

_QWORD *_libssh2_list_init(_QWORD *result)
{
  *result = 0;
  result[1] = 0;
  return result;
}

_QWORD *_libssh2_list_add(_QWORD **a1, _QWORD *a2)
{
  _QWORD *v2;
  _QWORD *result;

  a2[2] = a1;
  v2 = *a1;
  *a2 = 0;
  a2[1] = v2;
  *a1 = a2;
  result = a1 + 1;
  if (!v2)
    v2 = result;
  *v2 = a2;
  return result;
}

uint64_t _libssh2_list_first(uint64_t a1)
{
  return *(_QWORD *)(a1 + 8);
}

uint64_t _libssh2_list_next(uint64_t a1)
{
  return *(_QWORD *)a1;
}

uint64_t _libssh2_list_prev(uint64_t a1)
{
  return *(_QWORD *)(a1 + 8);
}

uint64_t *_libssh2_list_remove(uint64_t *result)
{
  _QWORD *v1;
  uint64_t v2;
  _QWORD *v3;

  v2 = *result;
  v1 = (_QWORD *)result[1];
  if (!v1)
  {
    *(_QWORD *)(result[2] + 8) = v2;
    if (v2)
      goto LABEL_3;
LABEL_5:
    v3 = (_QWORD *)result[2];
    goto LABEL_6;
  }
  *v1 = v2;
  v2 = *result;
  if (!*result)
    goto LABEL_5;
LABEL_3:
  v3 = (_QWORD *)(v2 + 8);
LABEL_6:
  *v3 = v1;
  return result;
}

void *_libssh2_calloc(uint64_t a1, size_t a2)
{
  void *v3;
  void *v4;

  v3 = (void *)(*(uint64_t (**)(size_t, uint64_t))(a1 + 8))(a2, a1);
  v4 = v3;
  if (v3)
    bzero(v3, a2);
  return v4;
}

_BYTE *_libssh2_xor_data(_BYTE *result, char *a2, char *a3, uint64_t a4)
{
  char v4;
  char v5;
  char v6;

  for (; a4; --a4)
  {
    v5 = *a2++;
    v4 = v5;
    v6 = *a3++;
    *result++ = v6 ^ v4;
  }
  return result;
}

unint64_t _libssh2_aes_ctr_increment(unint64_t result, uint64_t a2)
{
  unsigned __int8 *v2;
  int v3;
  unsigned int v4;

  v2 = (unsigned __int8 *)(result + a2 - 1);
  if ((unint64_t)v2 >= result)
  {
    v3 = 1;
    do
    {
      v4 = v3 + *v2;
      *v2-- = v4;
      v3 = v4 >> 8;
    }
    while ((unint64_t)v2 >= result);
  }
  return result;
}

_QWORD *_libssh2_string_buf_new(uint64_t a1)
{
  _QWORD *result;

  result = (_QWORD *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 8))(24, a1);
  if (result)
  {
    *result = 0;
    result[1] = 0;
    result[2] = 0;
  }
  return result;
}

uint64_t _libssh2_string_buf_free(uint64_t result, _QWORD *a2)
{
  uint64_t v3;

  if (a2)
  {
    v3 = result;
    if (*a2)
      (*(void (**)(_QWORD, uint64_t))(result + 24))(*a2, result);
    return (*(uint64_t (**)(_QWORD *, uint64_t))(v3 + 24))(a2, v3);
  }
  return result;
}

uint64_t _libssh2_get_byte(_QWORD *a1, _BYTE *a2)
{
  _BYTE *v2;
  unint64_t v3;
  unint64_t v4;
  BOOL v5;
  uint64_t result;

  v2 = (_BYTE *)a1[1];
  v3 = a1[2];
  v4 = *a1 + v3 - (_QWORD)v2;
  if (v4)
    v5 = v4 > v3;
  else
    v5 = 1;
  if (v5)
    return 0xFFFFFFFFLL;
  result = 0;
  *a2 = *v2;
  ++a1[1];
  return result;
}

BOOL _libssh2_check_length(_QWORD *a1, unint64_t a2)
{
  unint64_t v2;
  unint64_t v3;

  v2 = a1[2];
  v3 = *a1 + v2 - a1[1];
  return v3 >= a2 && v3 <= v2;
}

uint64_t _libssh2_get_BOOLean(_QWORD *a1, BOOL *a2)
{
  _BYTE *v2;
  unint64_t v3;
  unint64_t v4;
  BOOL v5;
  uint64_t result;

  v2 = (_BYTE *)a1[1];
  v3 = a1[2];
  v4 = *a1 + v3 - (_QWORD)v2;
  if (v4)
    v5 = v4 > v3;
  else
    v5 = 1;
  if (v5)
    return 0xFFFFFFFFLL;
  result = 0;
  *a2 = *v2 != 0;
  ++a1[1];
  return result;
}

uint64_t _libssh2_get_u32(_QWORD *a1, _DWORD *a2)
{
  unsigned int *v2;
  unint64_t v3;
  unint64_t v4;
  BOOL v5;
  BOOL v6;
  uint64_t result;

  v2 = (unsigned int *)a1[1];
  v3 = a1[2];
  v4 = *a1 + v3 - (_QWORD)v2;
  if (v4 >= 4)
  {
    v5 = v4 >= v3;
    v6 = v4 == v3;
  }
  else
  {
    v5 = 1;
    v6 = 0;
  }
  if (!v6 && v5)
    return 0xFFFFFFFFLL;
  result = 0;
  *a2 = bswap32(*v2);
  a1[1] = v2 + 1;
  return result;
}

uint64_t _libssh2_get_u64(uint64_t a1, unint64_t *a2)
{
  unint64_t v2;
  uint64_t v3;
  unint64_t v4;
  unint64_t v8;
  uint64_t result;

  v3 = *(_QWORD *)(a1 + 8);
  v2 = *(_QWORD *)(a1 + 16);
  v4 = *(_QWORD *)a1 + v2 - v3;
  if (v4 < 8 || v4 > v2)
    return 0xFFFFFFFFLL;
  v8 = _libssh2_ntohu64(*(unint64_t **)(a1 + 8));
  result = 0;
  *a2 = v8;
  *(_QWORD *)(a1 + 8) = v3 + 8;
  return result;
}

uint64_t _libssh2_match_string(_QWORD *a1, const char *a2)
{
  size_t v4;
  char *__s1;

  v4 = 0;
  __s1 = 0;
  if (_libssh2_get_string(a1, &__s1, &v4) || v4 != strlen(a2))
    return 0xFFFFFFFFLL;
  if (!strncmp(__s1, a2, v4))
    return 0;
  return 0xFFFFFFFFLL;
}

uint64_t _libssh2_get_string(_QWORD *a1, _QWORD *a2, _QWORD *a3)
{
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t result;
  unsigned int v12;

  if (!a1)
    return 0xFFFFFFFFLL;
  v12 = 0;
  if (_libssh2_get_u32(a1, &v12))
    return 0xFFFFFFFFLL;
  v6 = v12;
  v7 = a1[1];
  v8 = a1[2];
  v9 = *a1 + v8 - v7;
  if (v9 < v12 || v9 > v8)
    return 0xFFFFFFFFLL;
  *a2 = v7;
  a1[1] += v6;
  result = 0;
  if (a3)
    *a3 = v6;
  return result;
}

uint64_t _libssh2_copy_string(uint64_t a1, _QWORD *a2, _QWORD *a3, size_t *a4)
{
  uint64_t result;
  void *v8;
  size_t v9;
  const void *v10;
  size_t v11;

  v10 = 0;
  v11 = 0;
  if (_libssh2_get_string(a2, &v10, &v11))
    return 0xFFFFFFFFLL;
  if (!v11)
  {
    v9 = 0;
    *a3 = 0;
    goto LABEL_8;
  }
  v8 = (void *)(*(uint64_t (**)(size_t, uint64_t))(a1 + 8))(v11, a1);
  *a3 = v8;
  if (!v8)
    return 0xFFFFFFFFLL;
  memcpy(v8, v10, v11);
  if (a4)
  {
    v9 = v11;
LABEL_8:
    result = 0;
    *a4 = v9;
    return result;
  }
  return 0;
}

uint64_t _libssh2_get_bignum_bytes(_QWORD *a1, _QWORD *a2, _QWORD *a3)
{
  uint64_t v6;
  _BYTE *v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t result;
  _BYTE *v12;
  unsigned int v13;
  unsigned int v14;

  v14 = 0;
  if (_libssh2_get_u32(a1, &v14))
    return 0xFFFFFFFFLL;
  v6 = v14;
  v7 = (_BYTE *)a1[1];
  v8 = a1[2];
  v9 = *a1 + v8 - (_QWORD)v7;
  if (v9 < v14 || v9 > v8)
    return 0xFFFFFFFFLL;
  if (v14)
  {
    v12 = &v7[v14];
    v13 = v14;
    while (!*v7)
    {
      ++v7;
      if (!--v13)
      {
        v7 = v12;
        break;
      }
    }
  }
  else
  {
    v13 = 0;
  }
  *a2 = v7;
  a1[1] += v6;
  result = 0;
  if (a3)
    *a3 = v13;
  return result;
}

BOOL _libssh2_eob(_QWORD *a1)
{
  return a1[1] >= *a1 + a1[2];
}

void _libssh2_store_str_cold_1()
{
  __assert_rtn("_libssh2_store_str", "misc.c", 268, "len_stored == len");
}

void _libssh2_store_bignum2_bytes_cold_1()
{
  __assert_rtn("_libssh2_store_bignum2_bytes", "misc.c", 300, "len_stored == len");
}

char ***_libssh2_mac_methods()
{
  return mac_methods;
}

char **_libssh2_mac_override(const char **a1)
{
  const char *v1;
  char **v2;

  v1 = *a1;
  v2 = &mac_method_hmac_aesgcm;
  if (strcmp(*a1, "aes256-gcm@openssh.com") && strcmp(v1, "aes128-gcm@openssh.com"))
    return 0;
  return v2;
}

uint64_t mac_method_common_init(uint64_t a1, uint64_t a2, _DWORD *a3, _QWORD *a4)
{
  *a4 = a2;
  *a3 = 0;
  return 0;
}

uint64_t mac_method_hmac_sha2_256_hash(uint64_t a1, unsigned __int8 *a2, unsigned int a3, const unsigned __int8 *a4, size_t a5, const unsigned __int8 *a6, size_t a7, const void **a8)
{
  HMAC_CTX *v14;
  const void *v15;
  const EVP_MD *v16;
  int data;

  _libssh2_htonu32(&data, a3);
  v14 = HMAC_CTX_new();
  v15 = *a8;
  v16 = EVP_sha256();
  HMAC_Init_ex(v14, v15, 32, v16, 0);
  HMAC_Update(v14, (const unsigned __int8 *)&data, 4uLL);
  HMAC_Update(v14, a4, a5);
  if (a6 && a7)
    HMAC_Update(v14, a6, a7);
  HMAC_Final(v14, a2, 0);
  HMAC_CTX_free(v14);
  return 0;
}

uint64_t mac_method_common_dtor(uint64_t a1, _QWORD *a2)
{
  if (*a2)
    (*(void (**)(void))(a1 + 24))();
  *a2 = 0;
  return 0;
}

uint64_t mac_method_hmac_sha2_512_hash(uint64_t a1, unsigned __int8 *a2, unsigned int a3, const unsigned __int8 *a4, size_t a5, const unsigned __int8 *a6, size_t a7, const void **a8)
{
  HMAC_CTX *v14;
  const void *v15;
  const EVP_MD *v16;
  int data;

  _libssh2_htonu32(&data, a3);
  v14 = HMAC_CTX_new();
  v15 = *a8;
  v16 = EVP_sha512();
  HMAC_Init_ex(v14, v15, 64, v16, 0);
  HMAC_Update(v14, (const unsigned __int8 *)&data, 4uLL);
  HMAC_Update(v14, a4, a5);
  if (a6 && a7)
    HMAC_Update(v14, a6, a7);
  HMAC_Final(v14, a2, 0);
  HMAC_CTX_free(v14);
  return 0;
}

uint64_t mac_method_hmac_sha1_hash(uint64_t a1, unsigned __int8 *a2, unsigned int a3, const unsigned __int8 *a4, size_t a5, const unsigned __int8 *a6, size_t a7, const void **a8)
{
  HMAC_CTX *v14;
  const void *v15;
  const EVP_MD *v16;
  int data;

  _libssh2_htonu32(&data, a3);
  v14 = HMAC_CTX_new();
  v15 = *a8;
  v16 = EVP_sha1();
  HMAC_Init_ex(v14, v15, 20, v16, 0);
  HMAC_Update(v14, (const unsigned __int8 *)&data, 4uLL);
  HMAC_Update(v14, a4, a5);
  if (a6 && a7)
    HMAC_Update(v14, a6, a7);
  HMAC_Final(v14, a2, 0);
  HMAC_CTX_free(v14);
  return 0;
}

uint64_t mac_method_hmac_sha1_96_hash(uint64_t a1, uint64_t a2, unsigned int a3, const unsigned __int8 *a4, size_t a5, const unsigned __int8 *a6, size_t a7, const void **a8)
{
  uint64_t v10;
  int v11;
  uint64_t v12;

  v12 = *MEMORY[0x24BDAC8D0];
  mac_method_hmac_sha1_hash(a1, (unsigned __int8 *)&v10, a3, a4, a5, a6, a7, a8);
  *(_QWORD *)a2 = v10;
  *(_DWORD *)(a2 + 8) = v11;
  return 0;
}

uint64_t mac_method_hmac_md5_hash(uint64_t a1, unsigned __int8 *a2, unsigned int a3, const unsigned __int8 *a4, size_t a5, const unsigned __int8 *a6, size_t a7, const void **a8)
{
  HMAC_CTX *v14;
  const void *v15;
  const EVP_MD *v16;
  int data;

  _libssh2_htonu32(&data, a3);
  v14 = HMAC_CTX_new();
  v15 = *a8;
  v16 = EVP_md5();
  HMAC_Init_ex(v14, v15, 16, v16, 0);
  HMAC_Update(v14, (const unsigned __int8 *)&data, 4uLL);
  HMAC_Update(v14, a4, a5);
  if (a6 && a7)
    HMAC_Update(v14, a6, a7);
  HMAC_Final(v14, a2, 0);
  HMAC_CTX_free(v14);
  return 0;
}

uint64_t mac_method_hmac_md5_96_hash(uint64_t a1, uint64_t a2, unsigned int a3, const unsigned __int8 *a4, size_t a5, const unsigned __int8 *a6, size_t a7, const void **a8)
{
  uint64_t v10;
  int v11;
  uint64_t v12;

  v12 = *MEMORY[0x24BDAC8D0];
  mac_method_hmac_md5_hash(a1, (unsigned __int8 *)&v10, a3, a4, a5, a6, a7, a8);
  *(_QWORD *)a2 = v10;
  *(_DWORD *)(a2 + 8) = v11;
  return 0;
}

uint64_t mac_method_hmac_ripemd160_hash(uint64_t a1, unsigned __int8 *a2, unsigned int a3, const unsigned __int8 *a4, size_t a5, const unsigned __int8 *a6, size_t a7, const void **a8)
{
  HMAC_CTX *v14;
  const void *v15;
  const EVP_MD *v16;
  int data;

  _libssh2_htonu32(&data, a3);
  v14 = HMAC_CTX_new();
  v15 = *a8;
  v16 = EVP_ripemd160();
  HMAC_Init_ex(v14, v15, 20, v16, 0);
  HMAC_Update(v14, (const unsigned __int8 *)&data, 4uLL);
  HMAC_Update(v14, a4, a5);
  if (a6 && a7)
    HMAC_Update(v14, a6, a7);
  HMAC_Final(v14, a2, 0);
  HMAC_CTX_free(v14);
  return 0;
}

const char *libssh2_version(int a1)
{
  if (a1 >= 68353)
    return 0;
  else
    return "1.11.0";
}

uint64_t libssh2_crypto_engine()
{
  return 1;
}

uint64_t libssh2_init(int a1)
{
  int v2;

  v2 = _libssh2_initialized;
  if (!(_libssh2_initialized | a1 & 1))
  {
    _libssh2_openssl_crypto_init();
    v2 = _libssh2_initialized;
  }
  _libssh2_initialized = v2 + 1;
  _libssh2_init_flags |= a1;
  return 0;
}

uint64_t libssh2_exit()
{
  int v0;
  uint64_t result;

  v0 = _libssh2_initialized;
  if (_libssh2_initialized)
  {
    --_libssh2_initialized;
    if (v0 == 1 && (_libssh2_init_flags & 1) == 0)
      return _libssh2_openssl_crypto_exit();
  }
  return result;
}

uint64_t _libssh2_init_if_needed()
{
  uint64_t result;

  if (!_libssh2_initialized)
  {
    result = _libssh2_openssl_crypto_init();
    ++_libssh2_initialized;
  }
  return result;
}

uint64_t _libssh2_packet_add(uint64_t a1, unsigned __int8 *a2, unint64_t a3, int a4)
{
  uint64_t v5;
  uint64_t v6;
  _QWORD *v7;
  int v8;
  int v9;
  unint64_t v10;
  unint64_t v12;
  unint64_t v13;
  unsigned int v14;
  uint64_t v15;
  int v16;
  void (*v17)(uint64_t, _QWORD, uint64_t, _QWORD, uint64_t, _QWORD, uint64_t);
  uint64_t v18;
  unsigned int (*v19)(uint64_t, unsigned __int8 *, unint64_t, uint64_t);
  BOOL v23;
  _QWORD *v25;
  int v26;
  _QWORD *v27;
  void *v28;
  uint64_t v29;
  uint64_t v30;
  unsigned int v31;
  int v32;
  int v33;
  uint64_t v34;
  unint64_t v35;
  int v36;
  uint64_t v37;
  uint64_t v38;
  unint64_t v39;
  unint64_t v40;
  int v41;
  char *v42;
  uint64_t v43;
  uint64_t v44;
  int v45;
  uint64_t v46;
  int v47;
  uint64_t v48;
  int v49;
  int v50;
  unint64_t v51;
  int v52;
  void (*v53)(uint64_t, const char *, uint64_t, uint64_t);
  const char *v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  void (*v58)(uint64_t, uint64_t, uint64_t, _QWORD, uint64_t, _QWORD, uint64_t);
  uint64_t v59;
  unint64_t v60;
  unint64_t v61;
  unint64_t v62;
  _QWORD *v63;
  int i;
  BOOL v67;
  uint64_t v68;
  void *v69;
  uint64_t v70;
  _QWORD *v71;
  int v72;
  _QWORD *v73;
  void *v74;
  uint64_t v75;
  uint64_t v76;
  char *v77;
  unsigned int v78;
  char *v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  unsigned int v85;
  unsigned int v86;
  void *v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  unsigned int v91;
  size_t v92;
  uint64_t v93;
  int v94;
  _QWORD *v95;
  _QWORD *v96;
  void *v97;
  uint64_t v98;
  uint64_t v99;
  _QWORD *v100;
  char v101;
  int v102;
  void *__src;
  _QWORD *v104;
  int v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  unsigned __int8 *v110;
  unsigned __int8 *v111;
  unint64_t v112;
  size_t __n;
  _DWORD *v114;

  v5 = a1 + 72616;
  v6 = a1 + 72040;
  v7 = (_QWORD *)(a1 + 35664);
  v108 = 0;
  v109 = 0;
  v106 = 0;
  v107 = 0;
  v8 = *a2;
  v9 = *(_DWORD *)(a1 + 72600);
  v10 = a3;
  v12 = 0;
  switch(v9)
  {
    case 0:
      if (a4 == -1)
      {
        v19 = *(unsigned int (**)(uint64_t, unsigned __int8 *, unint64_t, uint64_t))(a1 + 56);
        if (!v19 || v19(a1, a2, a3, a1))
        {
          (*(void (**)(unsigned __int8 *, uint64_t))(a1 + 24))(a2, a1);
          return _libssh2_error(a1, 4294967292, "Invalid MAC received");
        }
      }
      *(_DWORD *)(v6 + 560) = 1;
LABEL_4:
      v12 = 0;
      v13 = 9;
      switch(v8)
      {
        case 'P':
          if (v10 >= 5)
          {
            v14 = _libssh2_ntohu32((unsigned int *)(a2 + 1));
            if (v14 <= 0xFFFFFFF9 && v14 + 6 <= v10 && a2[v14 + 5])
              goto LABEL_9;
          }
          goto LABEL_95;
        case 'Q':
        case 'R':
        case 'S':
        case 'T':
        case 'U':
        case 'V':
        case 'W':
        case 'X':
        case 'Y':
        case '[':
        case '\\':
          goto LABEL_108;
        case 'Z':
          if (v10 < 0x11)
            goto LABEL_89;
          if (v10 >= 0x14
            && _libssh2_ntohu32((unsigned int *)(a2 + 1)) == 15
            && *(_QWORD *)(a2 + 5) == 0x6564726177726F66
            && *(_QWORD *)(a2 + 12) == 0x70697063742D6465)
          {
            *(_QWORD *)(a1 + 72712) = 0;
            *(_OWORD *)(a1 + 72680) = 0u;
            *(_OWORD *)(a1 + 72696) = 0u;
            *(_OWORD *)(a1 + 72648) = 0u;
            *(_OWORD *)(a1 + 72664) = 0u;
            *(_OWORD *)(a1 + 72616) = 0u;
            *(_OWORD *)(a1 + 72632) = 0u;
            goto LABEL_190;
          }
          if (_libssh2_ntohu32((unsigned int *)(a2 + 1)) == 3
            && *(_WORD *)(a2 + 5) == 12664
            && a2[7] == 49)
          {
            *(_QWORD *)(a1 + 72800) = 0;
            *(_OWORD *)(a1 + 72768) = 0u;
            *(_OWORD *)(a1 + 72784) = 0u;
            *(_OWORD *)(a1 + 72736) = 0u;
            *(_OWORD *)(a1 + 72752) = 0u;
            *(_OWORD *)(a1 + 72720) = 0u;
            goto LABEL_153;
          }
          if (v10 >= 0x1B && _libssh2_ntohu32((unsigned int *)(a2 + 1)) == 22)
          {
            v23 = *(_QWORD *)(a2 + 5) == 0x6567612D68747561 && *(_QWORD *)(a2 + 13) == 0x736E65706F40746ELL;
            if (v23 && *(_QWORD *)(a2 + 19) == 0x6D6F632E6873736ELL)
            {
              *(_OWORD *)(a1 + 72840) = 0u;
              *(_OWORD *)(a1 + 72856) = 0u;
              *(_OWORD *)(a1 + 72808) = 0u;
              *(_OWORD *)(a1 + 72824) = 0u;
              goto LABEL_44;
            }
          }
LABEL_89:
          v18 = 0;
          goto LABEL_236;
        case ']':
          if (v10 >= 9)
          {
            v32 = _libssh2_ntohu32((unsigned int *)(a2 + 5));
            v33 = _libssh2_ntohu32((unsigned int *)(a2 + 1));
            v34 = _libssh2_channel_locate(a1, v33);
            if (v34)
              *(_DWORD *)(v34 + 56) += v32;
          }
          goto LABEL_95;
        case '^':
          goto LABEL_60;
        case '_':
          v13 = 13;
LABEL_60:
          v35 = v10 - v13;
          if (v10 < v13
            || (v36 = _libssh2_ntohu32((unsigned int *)(a2 + 1)), (v37 = _libssh2_channel_locate(a1, v36)) == 0))
          {
            v42 = "Packet received for unknown channel";
            v43 = a1;
            v44 = 4294967273;
LABEL_68:
            _libssh2_error(v43, v44, v42);
            goto LABEL_95;
          }
          v15 = v37;
          if (*(_BYTE *)(v37 + 86) == 1 && v8 == 95)
          {
            (*(void (**)(unsigned __int8 *, uint64_t))(a1 + 24))(a2, a1);
            v38 = *(_QWORD *)(v15 + 96);
            v39 = v35 + v38;
            v40 = *(unsigned int *)(v15 + 76);
            v41 = v13 - v38 + v40;
            if (v39 >= v40)
              LODWORD(v10) = v41;
            *(_DWORD *)(v15 + 76) = v40 + v13 - v10;
            *(_QWORD *)(v6 + 568) = v15;
LABEL_12:
            *(_DWORD *)(v6 + 560) = 11;
            v16 = _libssh2_channel_receive_window_adjust(v15, (v10 - 13), 1, 0);
            goto LABEL_115;
          }
          if (v35 > *(unsigned int *)(v37 + 80))
          {
            _libssh2_error(a1, 4294967271, "Packet contains more data than we offered to receive, truncating");
            v10 = v13 + *(unsigned int *)(v15 + 80);
          }
          v60 = *(unsigned int *)(v15 + 76);
          v61 = *(_QWORD *)(v15 + 96);
          if (v61 >= v60)
          {
            v42 = "The current receive window is full, data ignored";
            v43 = a1;
            v44 = 4294967272;
            goto LABEL_68;
          }
          *(_BYTE *)(v15 + 85) = 0;
          v62 = v10 - v13 + v61;
          if (v62 > v60)
          {
            _libssh2_error(a1, 4294967272, "Remote sent more data than current window allows, truncating");
            v10 = v13 - *(_QWORD *)(v15 + 96) + *(unsigned int *)(v15 + 76);
            v62 = *(unsigned int *)(v15 + 76);
          }
          *(_QWORD *)(v15 + 96) = v62;
          v12 = v13;
LABEL_108:
          *(_DWORD *)(v6 + 560) = 3;
LABEL_109:
          v63 = (_QWORD *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 8))(48, a1);
          if (!v63)
          {
            (*(void (**)(unsigned __int8 *, uint64_t))(a1 + 24))(a2, a1);
            *(_DWORD *)(v6 + 560) = 0;
            return 4294967290;
          }
          v63[3] = a2;
          v63[4] = v10;
          v63[5] = v12;
          _libssh2_list_add((_QWORD **)(a1 + 536), v63);
          v9 = 4;
          *(_DWORD *)(v6 + 560) = 4;
LABEL_111:
          if ((v8 != 20 || (*(_BYTE *)(a1 + 128) & 1) != 0) && v9 != 5)
            goto LABEL_117;
          *(_DWORD *)v6 = 0;
          *v7 = 0;
          *(_DWORD *)(v6 + 560) = 0;
          *(_DWORD *)(v5 + 256) = 0;
          bzero((void *)(a1 + 71088), 0x298uLL);
          v16 = _libssh2_kex_exchange(a1, 1, a1 + 71088);
LABEL_115:
          if (v16 != -37)
          {
LABEL_117:
            v18 = 0;
LABEL_237:
            *(_DWORD *)(v6 + 560) = 0;
            return v18;
          }
          return 4294967259;
          if (v10 >= 5)
          {
            v45 = _libssh2_ntohu32((unsigned int *)(a2 + 1));
            v46 = _libssh2_channel_locate(a1, v45);
            if (v46)
              *(_BYTE *)(v46 + 85) = 1;
          }
          goto LABEL_95;
        case 'a':
          if (v10 >= 5)
          {
            v47 = _libssh2_ntohu32((unsigned int *)(a2 + 1));
            v48 = _libssh2_channel_locate(a1, v47);
            if (v48)
              *(_WORD *)(v48 + 84) = 257;
          }
          goto LABEL_95;
        case 'b':
          if (v10 < 9)
            goto LABEL_89;
          v49 = _libssh2_ntohu32((unsigned int *)(a2 + 1));
          v50 = _libssh2_ntohu32((unsigned int *)(a2 + 5));
          v51 = (v50 + 9);
          if (v51 >= v10)
            v52 = 1;
          else
            v52 = a2[v51];
          v18 = 0;
          if (v10 < 0x14 || v50 != 11)
            goto LABEL_209;
          if (*(_QWORD *)(a2 + 9) == 0x6174732D74697865 && *(_QWORD *)(a2 + 12) == 0x7375746174732D74)
          {
            v70 = _libssh2_channel_locate(a1, v49);
            v18 = 0;
            if (v10 >= 0x19 && v70)
            {
              v18 = 0;
              *(_DWORD *)(v70 + 36) = _libssh2_ntohu32((unsigned int *)(a2 + 21));
            }
          }
          else
          {
            if (*(_QWORD *)(a2 + 9) != 0x6769732D74697865 || *(_QWORD *)(a2 + 12) != 0x6C616E6769732D74)
              goto LABEL_130;
            v83 = _libssh2_channel_locate(a1, v49);
            v18 = 0;
            if (v10 >= 0x19)
            {
              v84 = v83;
              if (v83)
              {
                v85 = _libssh2_ntohu32((unsigned int *)(a2 + 21));
                if (v85 == -1)
                {
                  *(_QWORD *)(v84 + 40) = 0;
                }
                else
                {
                  v86 = v85;
                  v87 = (void *)(*(uint64_t (**)(_QWORD, uint64_t))(a1 + 8))(v85 + 1, a1);
                  *(_QWORD *)(v84 + 40) = v87;
                  if (v87)
                  {
                    if ((unint64_t)v86 + 25 > v10)
                    {
LABEL_130:
                      v18 = 0;
                      goto LABEL_209;
                    }
                    v88 = v86;
                    memcpy(v87, a2 + 25, v86);
                    v18 = 0;
                    *(_BYTE *)(*(_QWORD *)(v84 + 40) + v88) = 0;
                    goto LABEL_209;
                  }
                }
                v18 = _libssh2_error(a1, 4294967290, "memory for signal name");
              }
            }
          }
LABEL_209:
          if (v52)
          {
LABEL_210:
            *(_DWORD *)(v6 + 560) = 14;
            v101 = 100;
            v102 = *(_DWORD *)(a2 + 1);
            v18 = _libssh2_transport_send(a1, &v101, 5uLL);
            if ((_DWORD)v18 == -37)
              return v18;
          }
LABEL_236:
          (*(void (**)(unsigned __int8 *, uint64_t))(a1 + 24))(a2, a1);
          goto LABEL_237;
        default:
          switch(v8)
          {
            case 1:
              if (v10 >= 5)
              {
                LODWORD(v114) = 0;
                v110 = a2;
                v111 = a2 + 1;
                v112 = v10;
                _libssh2_get_u32(&v110, &v114);
                _libssh2_get_string(&v110, &v109, &v107);
                _libssh2_get_string(&v110, &v108, &v106);
                v17 = *(void (**)(uint64_t, _QWORD, uint64_t, _QWORD, uint64_t, _QWORD, uint64_t))(a1 + 48);
                if (v17)
                  v17(a1, v114, v109, v107, v108, v106, a1);
              }
              (*(void (**)(unsigned __int8 *, uint64_t))(a1 + 24))(a2, a1);
              *(_DWORD *)(a1 + 596) = -1;
              *(_DWORD *)(v6 + 560) = 0;
              return _libssh2_error(a1, 4294967283, "socket disconnect");
            case 2:
              v53 = *(void (**)(uint64_t, const char *, uint64_t, uint64_t))(a1 + 32);
              if (v10 < 2)
              {
                if (!v53)
                  goto LABEL_95;
                v54 = "";
                v56 = a1;
                v55 = 0;
              }
              else
              {
                if (!v53)
                  goto LABEL_95;
                v54 = (const char *)(a2 + 1);
                v55 = (v10 - 1);
                v56 = a1;
              }
              v53(v56, v54, v55, a1);
              break;
            case 4:
              if (v10 >= 2)
              {
                v57 = a2[1];
                if (v10 >= 6)
                {
                  v110 = a2;
                  v111 = a2 + 2;
                  v112 = v10;
                  _libssh2_get_string(&v110, &v109, &v107);
                  _libssh2_get_string(&v110, &v108, &v106);
                }
                v58 = *(void (**)(uint64_t, uint64_t, uint64_t, _QWORD, uint64_t, _QWORD, uint64_t))(a1 + 40);
                if (v58)
                  v58(a1, v57, v109, v107, v108, v106, a1);
              }
              goto LABEL_95;
            case 7:
              if (v10 < 5)
                goto LABEL_89;
              v105 = 0;
              v110 = a2;
              v111 = a2 + 1;
              v112 = v10;
              if (_libssh2_get_u32(&v110, &v105))
                v18 = _libssh2_error(a1, 4294967282, "Invalid extension info received");
              else
                v18 = 0;
              if (!(_DWORD)v18)
              {
                for (i = v105; v105; i = v105)
                {
                  v114 = 0;
                  __n = 0;
                  __src = 0;
                  v104 = 0;
                  v105 = i - 1;
                  _libssh2_get_string(&v110, &v104, &v114);
                  _libssh2_get_string(&v110, &__src, &__n);
                  if (v114 == (_DWORD *)15
                    && (*v104 == 0x732D726576726573
                      ? (v67 = *(_QWORD *)((char *)v104 + 7) == 0x73676C612D676973)
                      : (v67 = 0),
                        v67))
                  {
                    v68 = *(_QWORD *)(a1 + 296);
                    if (v68)
                      (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v68, a1);
                    v69 = (void *)(*(uint64_t (**)(size_t, uint64_t))(a1 + 8))(__n + 1, a1);
                    *(_QWORD *)(a1 + 296) = v69;
                    if (v69)
                    {
                      memcpy(v69, __src, __n);
                      v18 = 0;
                      *(_BYTE *)(*(_QWORD *)(a1 + 296) + __n) = 0;
                    }
                    else
                    {
                      v18 = _libssh2_error(a1, 4294967290, "memory for server sign algo");
                    }
                  }
                  else
                  {
                    v18 = 0;
                  }
                  if ((_DWORD)v18)
                    break;
                }
              }
              goto LABEL_236;
            default:
              goto LABEL_108;
          }
          goto LABEL_95;
      }
    case 1:
      goto LABEL_4;
    case 3:
      goto LABEL_109;
    case 11:
      v15 = *(_QWORD *)(a1 + 72608);
      goto LABEL_12;
    case 12:
LABEL_190:
      *(_DWORD *)(v6 + 560) = 12;
      v114 = 0;
      v89 = _libssh2_list_first(a1 + 576);
      if (*(_DWORD *)v5 == 3)
      {
        v91 = 1;
      }
      else
      {
        v90 = v89;
        if (!*(_DWORD *)v5)
        {
          v112 = v10;
          __n = 0;
          v110 = a2;
          if (v10 <= 0x13)
          {
            v79 = "Unexpected packet size";
            v80 = a1;
            v81 = 4294967255;
            goto LABEL_234;
          }
          v111 = a2 + 20;
          if (_libssh2_get_u32(&v110, (_DWORD *)(a1 + 72680)))
          {
            v79 = "Data too short extracting channel";
LABEL_217:
            v80 = a1;
            v81 = 4294967258;
            goto LABEL_234;
          }
          if (_libssh2_get_u32(&v110, (_DWORD *)(a1 + 72684)))
          {
            v79 = "Data too short extracting window size";
            goto LABEL_217;
          }
          if (_libssh2_get_u32(&v110, (_DWORD *)(a1 + 72688)))
          {
            v79 = "Data too short extracting packet";
            goto LABEL_217;
          }
          if (_libssh2_get_string(&v110, (_QWORD *)(a1 + 72664), &__n))
          {
            v79 = "Data too short extracting host";
            goto LABEL_217;
          }
          *(_DWORD *)(v5 + 84) = __n;
          if (_libssh2_get_u32(&v110, (_DWORD *)(a1 + 72692)))
          {
            v79 = "Data too short extracting port";
            goto LABEL_217;
          }
          if (_libssh2_get_string(&v110, (_QWORD *)(a1 + 72672), &__n))
          {
            v79 = "Data too short extracting shost";
            goto LABEL_217;
          }
          *(_DWORD *)(v5 + 88) = __n;
          if (_libssh2_get_u32(&v110, (_DWORD *)(a1 + 72696)))
          {
            v79 = "Data too short extracting sport";
            goto LABEL_217;
          }
          *(_DWORD *)v5 = 1;
        }
        if (v90)
        {
          while (1)
          {
            if (*(_DWORD *)(v90 + 40) == *(_DWORD *)(v5 + 76))
            {
              v92 = strlen(*(const char **)(v90 + 32));
              if (v92 == *(_DWORD *)(v5 + 84) && !memcmp(*(const void **)(v90 + 32), *(const void **)(v5 + 48), v92))
              {
                *(_QWORD *)(v5 + 96) = 0;
                if (*(_DWORD *)v5 == 2)
                  goto LABEL_244;
                if (*(_DWORD *)v5 == 1)
                  break;
              }
            }
            v90 = _libssh2_list_next(v90);
            if (!v90)
              goto LABEL_226;
          }
          v94 = *(_DWORD *)(v90 + 68);
          if (!v94 || v94 > *(_DWORD *)(v90 + 64))
          {
            v95 = _libssh2_calloc(a1, 0x310uLL);
            if (v95)
            {
              v96 = v95;
              *(_QWORD *)(v5 + 96) = v95;
              v95[13] = a1;
              *((_DWORD *)v95 + 8) = 15;
              v97 = (void *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 8))(16, a1);
              v96[3] = v97;
              if (v97)
              {
                memcpy(v97, "forwarded-tcpip", (*((_DWORD *)v96 + 8) + 1));
                *((_DWORD *)v96 + 17) = *(_DWORD *)(v5 + 64);
                v96[9] = 0x20000000200000;
                *((_DWORD *)v96 + 20) = 0x8000;
                *((_DWORD *)v96 + 12) = _libssh2_channel_nextid(a1);
                v98 = *(_QWORD *)(v5 + 68);
                *((_DWORD *)v96 + 13) = v98;
                v96[7] = v98;
                v114 = (_DWORD *)(a1 + 72621);
                *(_BYTE *)(v5 + 4) = 91;
                _libssh2_store_u32(&v114, *((_DWORD *)v96 + 17));
                _libssh2_store_u32(&v114, *((_DWORD *)v96 + 12));
                _libssh2_store_u32(&v114, *((_DWORD *)v96 + 18));
                _libssh2_store_u32(&v114, *((_DWORD *)v96 + 20));
                *(_DWORD *)v5 = 2;
LABEL_244:
                v99 = _libssh2_transport_send(a1, (void *)(a1 + 72620), 0x11uLL);
                v18 = v99;
                if ((_DWORD)v99 == -37)
                  goto LABEL_235;
                if ((_DWORD)v99)
                {
                  *(_DWORD *)v5 = 0;
                  v79 = "Unable to send channel open confirmation";
                  goto LABEL_233;
                }
                v100 = *(_QWORD **)(v5 + 96);
                if (v100)
                {
                  _libssh2_list_add((_QWORD **)(v90 + 48), v100);
                  ++*(_DWORD *)(v90 + 64);
                }
                v18 = 0;
LABEL_230:
                *(_DWORD *)v5 = 0;
                goto LABEL_235;
              }
              _libssh2_error(a1, 4294967290, "Unable to allocate a channel for new connection");
              (*(void (**)(_QWORD *, uint64_t))(a1 + 24))(v96, a1);
            }
            else
            {
              _libssh2_error(a1, 4294967290, "Unable to allocate a channel for new connection");
            }
          }
          v91 = 4;
          goto LABEL_227;
        }
LABEL_226:
        v91 = 1;
LABEL_227:
        *(_DWORD *)v5 = 3;
      }
      v114 = (_DWORD *)(a1 + 72621);
      *(_BYTE *)(v5 + 4) = 92;
      _libssh2_store_u32(&v114, *(_DWORD *)(v5 + 64));
      _libssh2_store_u32(&v114, v91);
      _libssh2_store_str(&v114, "Forward not requested", 0x15uLL);
      _libssh2_htonu32(v114, 0);
      v93 = _libssh2_transport_send(a1, (void *)(v5 + 4), 0x26uLL);
      v18 = v93;
      if ((_DWORD)v93 == -37)
        goto LABEL_235;
      if (!(_DWORD)v93)
        goto LABEL_230;
      *(_DWORD *)v5 = 0;
      goto LABEL_232;
    case 13:
LABEL_153:
      *(_DWORD *)(v6 + 560) = 13;
      v114 = 0;
      v71 = *(_QWORD **)(v5 + 184);
      v72 = *(_DWORD *)(v5 + 104);
      if (v72)
        goto LABEL_154;
      v112 = v10;
      __n = 0;
      v110 = a2;
      if (v10 <= 7)
      {
        v77 = "unexpected data length";
LABEL_170:
        _libssh2_error(a1, 4294967262, v77);
        goto LABEL_171;
      }
      v111 = a2 + 8;
      if (_libssh2_get_u32(&v110, (_DWORD *)(a1 + 72776)))
      {
        v77 = "unexpected sender channel size";
        goto LABEL_170;
      }
      if (_libssh2_get_u32(&v110, (_DWORD *)(a1 + 72780))
        || _libssh2_get_u32(&v110, (_DWORD *)(a1 + 72784)))
      {
        v77 = "unexpected window size";
        goto LABEL_170;
      }
      if (_libssh2_get_string(&v110, (_QWORD *)(a1 + 72768), &__n))
      {
        v77 = "unexpected host size";
        goto LABEL_170;
      }
      *(_DWORD *)(v5 + 176) = __n;
      if (_libssh2_get_u32(&v110, (_DWORD *)(a1 + 72788)))
      {
        v77 = "unexpected port size";
        goto LABEL_170;
      }
      v72 = 1;
      *(_DWORD *)(v5 + 104) = 1;
LABEL_154:
      if (!*(_QWORD *)(a1 + 64))
        goto LABEL_176;
      if (v72 == 2)
        goto LABEL_160;
      if (v72 != 1)
      {
LABEL_171:
        v78 = 2;
LABEL_177:
        v114 = (_DWORD *)(a1 + 72725);
        *(_BYTE *)(v5 + 108) = 92;
        _libssh2_store_u32(&v114, *(_DWORD *)(v5 + 160));
        _libssh2_store_u32(&v114, v78);
        _libssh2_store_str(&v114, "X11 Forward Unavailable", 0x17uLL);
        _libssh2_htonu32(v114, 0);
        v82 = _libssh2_transport_send(a1, (void *)(v5 + 108), 0x28uLL);
        v18 = v82;
        if ((_DWORD)v82 == -37)
          goto LABEL_235;
        if (!(_DWORD)v82)
          goto LABEL_179;
        *(_DWORD *)(v5 + 104) = 0;
        goto LABEL_232;
      }
      v73 = _libssh2_calloc(a1, 0x310uLL);
      if (v73)
      {
        v71 = v73;
        v73[13] = a1;
        *((_DWORD *)v73 + 8) = 3;
        v74 = (void *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 8))(4, a1);
        v71[3] = v74;
        if (v74)
        {
          memcpy(v74, "x11", (*((_DWORD *)v71 + 8) + 1));
          *((_DWORD *)v71 + 17) = *(_DWORD *)(v5 + 160);
          v71[9] = 0x20000000200000;
          *((_DWORD *)v71 + 20) = 0x8000;
          *((_DWORD *)v71 + 12) = _libssh2_channel_nextid(a1);
          v75 = *(_QWORD *)(v5 + 164);
          *((_DWORD *)v71 + 13) = v75;
          v71[7] = v75;
          v114 = (_DWORD *)(a1 + 72725);
          *(_BYTE *)(v5 + 108) = 91;
          _libssh2_store_u32(&v114, *((_DWORD *)v71 + 17));
          _libssh2_store_u32(&v114, *((_DWORD *)v71 + 12));
          _libssh2_store_u32(&v114, *((_DWORD *)v71 + 18));
          _libssh2_store_u32(&v114, *((_DWORD *)v71 + 20));
          *(_DWORD *)(v5 + 104) = 2;
LABEL_160:
          v76 = _libssh2_transport_send(a1, (void *)(a1 + 72724), 0x11uLL);
          v18 = v76;
          if ((_DWORD)v76 == -37)
            goto LABEL_235;
          if ((_DWORD)v76)
          {
            *(_DWORD *)(v5 + 104) = 0;
            goto LABEL_173;
          }
          _libssh2_list_add((_QWORD **)(a1 + 552), v71);
          (*(void (**)(_QWORD, _QWORD *, _QWORD, _QWORD, _QWORD))(v71[13] + 64))(v71[13], v71, *(_QWORD *)(v5 + 152), *(unsigned int *)(v5 + 172), v71[13]);
LABEL_179:
          *(_DWORD *)(v5 + 104) = 0;
          goto LABEL_235;
        }
        _libssh2_error(a1, 4294967290, "allocate a channel for new connection");
        (*(void (**)(_QWORD *, uint64_t))(a1 + 24))(v71, a1);
      }
      else
      {
        _libssh2_error(a1, 4294967290, "allocate a channel for new connection");
      }
LABEL_176:
      v78 = 4;
      goto LABEL_177;
    case 14:
      goto LABEL_210;
    case 15:
LABEL_9:
      *(_DWORD *)(v6 + 560) = 15;
      if (_libssh2_transport_send(a1, &_libssh2_packet_add_packet, 1uLL) == -37)
        return 4294967259;
LABEL_95:
      (*(void (**)(unsigned __int8 *, uint64_t))(a1 + 24))(a2, a1);
      goto LABEL_117;
    case 18:
LABEL_44:
      *(_DWORD *)(v6 + 560) = 18;
      v25 = *(_QWORD **)(v5 + 248);
      v26 = *(_DWORD *)(v5 + 192);
      if (!v26)
      {
        *(_DWORD *)(v5 + 236) = _libssh2_ntohu32((unsigned int *)(a2 + 27));
        *(_DWORD *)(v5 + 240) = _libssh2_ntohu32((unsigned int *)(a2 + 31));
        *(_DWORD *)(v5 + 244) = _libssh2_ntohu32((unsigned int *)(a2 + 35));
        v26 = 1;
        *(_DWORD *)(v5 + 192) = 1;
      }
      v110 = 0;
      if (!*(_QWORD *)(a1 + 72))
        goto LABEL_97;
      if (v26 == 2)
        goto LABEL_52;
      if (v26 == 1)
      {
        v27 = (_QWORD *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 8))(784, a1);
        *(_QWORD *)(v5 + 248) = v27;
        if (v27)
        {
          v25 = v27;
          bzero(v27, 0x310uLL);
          v25[13] = a1;
          *((_DWORD *)v25 + 8) = 10;
          v28 = (void *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 8))(11, a1);
          v25[3] = v28;
          if (v28)
          {
            memcpy(v28, "auth agent", (*((_DWORD *)v25 + 8) + 1));
            *((_DWORD *)v25 + 17) = *(_DWORD *)(v5 + 236);
            v25[9] = 0x20000000200000;
            *((_DWORD *)v25 + 20) = 0x8000;
            *((_DWORD *)v25 + 12) = _libssh2_channel_nextid(a1);
            v29 = *(_QWORD *)(v5 + 240);
            *((_DWORD *)v25 + 13) = v29;
            v25[7] = v29;
            v110 = (unsigned __int8 *)(a1 + 72813);
            *(_BYTE *)(v5 + 196) = 91;
            _libssh2_store_u32((_DWORD **)&v110, *((_DWORD *)v25 + 17));
            _libssh2_store_u32((_DWORD **)&v110, *((_DWORD *)v25 + 12));
            _libssh2_store_u32((_DWORD **)&v110, *((_DWORD *)v25 + 18));
            _libssh2_store_u32((_DWORD **)&v110, *((_DWORD *)v25 + 20));
            *(_DWORD *)(v5 + 192) = 2;
LABEL_52:
            v30 = _libssh2_transport_send(a1, (void *)(a1 + 72812), 0x11uLL);
            v18 = v30;
            if ((_DWORD)v30 == -37)
            {
LABEL_235:
              if ((_DWORD)v18 == -37)
                return v18;
              goto LABEL_236;
            }
            if ((_DWORD)v30)
            {
              *(_DWORD *)(v5 + 192) = 0;
LABEL_173:
              v79 = "Unable to send channel open confirmation";
              v80 = a1;
              v81 = 4294967289;
LABEL_234:
              v18 = _libssh2_error(v80, v81, v79);
              goto LABEL_235;
            }
            _libssh2_list_add((_QWORD **)(a1 + 552), v25);
            *v7 = 0;
            *(_DWORD *)(v5 + 256) = 0;
            (*(void (**)(_QWORD, _QWORD *, _QWORD))(v25[13] + 72))(v25[13], v25, v25[13]);
            goto LABEL_100;
          }
          _libssh2_error(a1, 4294967290, "allocate a channel for new connection");
          (*(void (**)(_QWORD *, uint64_t))(a1 + 24))(v25, a1);
        }
        else
        {
          _libssh2_error(a1, 4294967290, "allocate a channel for new connection");
        }
LABEL_97:
        v31 = 4;
      }
      else
      {
        v31 = 2;
      }
      v110 = (unsigned __int8 *)(a1 + 72813);
      *(_BYTE *)(v5 + 196) = 92;
      _libssh2_store_u32((_DWORD **)&v110, *(_DWORD *)(v5 + 236));
      _libssh2_store_u32((_DWORD **)&v110, v31);
      _libssh2_store_str((_DWORD **)&v110, "Auth Agent unavailable", 0x16uLL);
      _libssh2_htonu32(v110, 0);
      v59 = _libssh2_transport_send(a1, (void *)(v5 + 196), 0x28uLL);
      v18 = v59;
      if ((_DWORD)v59 == -37)
        goto LABEL_235;
      if ((_DWORD)v59)
      {
        *(_DWORD *)(v5 + 192) = 0;
LABEL_232:
        v79 = "Unable to send open failure";
LABEL_233:
        v80 = a1;
        v81 = v18;
        goto LABEL_234;
      }
LABEL_100:
      *(_DWORD *)(v5 + 192) = 0;
      goto LABEL_235;
    default:
      goto LABEL_111;
  }
}

uint64_t _libssh2_packet_ask(uint64_t a1, int a2, _QWORD *a3, unint64_t *a4, int a5, const void *a6, size_t a7)
{
  uint64_t v14;
  uint64_t *v15;
  uint64_t v16;
  size_t v17;
  unsigned __int8 *v18;
  unint64_t v19;
  unint64_t *v21;

  v14 = _libssh2_list_first(a1 + 536);
  if (!v14)
    return 0xFFFFFFFFLL;
  v15 = (uint64_t *)v14;
  v21 = a4;
  v16 = a5;
  v17 = a7 + a5;
  while (1)
  {
    v18 = (unsigned __int8 *)v15[3];
    if (*v18 == a2)
    {
      v19 = v15[4];
      if (v19 >= v17 && (!a6 || !memcmp(&v18[v16], a6, a7)))
        break;
    }
    v15 = (uint64_t *)_libssh2_list_next((uint64_t)v15);
    if (!v15)
      return 0xFFFFFFFFLL;
  }
  *a3 = v18;
  *v21 = v19;
  _libssh2_list_remove(v15);
  (*(void (**)(uint64_t *, uint64_t))(a1 + 24))(v15, a1);
  return 0;
}

uint64_t _libssh2_packet_askv(uint64_t a1, char *__s, _QWORD *a3, unint64_t *a4, int a5, const void *a6, size_t a7)
{
  char *v12;
  size_t v14;
  size_t v15;
  int v16;
  uint64_t result;

  v12 = __s;
  v14 = strlen(__s);
  if (!v14)
    return 0xFFFFFFFFLL;
  v15 = v14;
  while (1)
  {
    v16 = *v12++;
    result = _libssh2_packet_ask(a1, v16, a3, a4, a5, a6, a7);
    if (!(_DWORD)result)
      break;
    if (!--v15)
      return 0xFFFFFFFFLL;
  }
  return result;
}

uint64_t _libssh2_packet_require(uint64_t a1, int a2, _QWORD *a3, unint64_t *a4, int a5, const void *a6, size_t a7, uint64_t a8)
{
  uint64_t result;
  uint64_t v17;

  if (*(_QWORD *)(a8 + 8))
  {
    while (1)
    {
LABEL_4:
      if (*(_DWORD *)(a1 + 596))
        return 4294967283;
      result = _libssh2_transport_read(a1);
      if ((_DWORD)result == -37)
        return result;
      if ((result & 0x80000000) != 0)
        break;
      if ((_DWORD)result == a2)
      {
        result = _libssh2_packet_ask(a1, a2, a3, a4, a5, a6, a7);
        break;
      }
      if (!(_DWORD)result)
      {
        v17 = *(_QWORD *)(a1 + 73576);
        if (v17 - time(0) + *(_QWORD *)(a8 + 8) > 0)
          return 0xFFFFFFFFLL;
        result = 4294967287;
        break;
      }
    }
    *(_QWORD *)(a8 + 8) = 0;
  }
  else
  {
    result = _libssh2_packet_ask(a1, a2, a3, a4, a5, a6, a7);
    if ((_DWORD)result)
    {
      *(_QWORD *)(a8 + 8) = time(0);
      goto LABEL_4;
    }
  }
  return result;
}

uint64_t _libssh2_packet_burn(uint64_t a1, _DWORD *a2)
{
  uint64_t i;
  uint64_t v5;
  uint64_t v6;
  unint64_t v8;
  unsigned __int8 *v9;
  char __s[255];
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  v9 = 0;
  if (*a2)
  {
LABEL_6:
    while (!*(_DWORD *)(a1 + 596))
    {
      v5 = _libssh2_transport_read(a1);
      v6 = v5;
      if ((_DWORD)v5 == -37)
        return v6;
      if ((v5 & 0x80000000) != 0)
        goto LABEL_12;
      if ((_DWORD)v5 && !_libssh2_packet_ask(a1, v5, &v9, &v8, 0, 0, 0))
      {
        (*(void (**)(unsigned __int8 *, uint64_t))(a1 + 24))(v9, a1);
LABEL_12:
        *a2 = 0;
        return v6;
      }
    }
    return 4294967283;
  }
  else
  {
    for (i = 0; i != 254; ++i)
      __s[i] = i + 1;
    __s[254] = 0;
    if (_libssh2_packet_askv(a1, __s, &v9, &v8, 0, 0, 0))
    {
      *a2 = 2;
      goto LABEL_6;
    }
    v6 = *v9;
    (*(void (**)(void))(a1 + 24))();
  }
  return v6;
}

uint64_t _libssh2_packet_requirev(uint64_t a1, char *a2, _QWORD *a3, unint64_t *a4, int a5, const void *a6, size_t a7, time_t *a8)
{
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  size_t v20;

  if (_libssh2_packet_askv(a1, a2, a3, a4, a5, a6, a7))
  {
    v20 = a7;
    if (!*a8)
      *a8 = time(0);
    while (1)
    {
      if (*(_DWORD *)(a1 + 596) == -1)
      {
        v17 = 4294967283;
        goto LABEL_15;
      }
      v16 = _libssh2_transport_read(a1);
      v17 = v16;
      if ((v16 & 0x80000000) != 0 && (_DWORD)v16 != -37)
        goto LABEL_15;
      if ((int)v16 <= 0)
      {
        v18 = *(_QWORD *)(a1 + 73576);
        if (v18 - time(0) + *a8 < 1)
        {
          v17 = 4294967287;
          goto LABEL_15;
        }
        if ((_DWORD)v17 == -37)
          return v17;
      }
      if (strchr(a2, v17))
      {
        v17 = _libssh2_packet_askv(a1, a2, a3, a4, a5, a6, v20);
        goto LABEL_15;
      }
    }
  }
  v17 = 0;
LABEL_15:
  *a8 = 0;
  return v17;
}

uint64_t _libssh2_channel_nextid(uint64_t a1)
{
  uint64_t v2;
  uint64_t i;
  unsigned int v4;

  v2 = *(unsigned int *)(a1 + 568);
  for (i = _libssh2_list_first(a1 + 552); i; i = _libssh2_list_next(i))
  {
    v4 = *(_DWORD *)(i + 48);
    if (v4 <= v2)
      v2 = v2;
    else
      v2 = v4;
  }
  *(_DWORD *)(a1 + 568) = v2 + 1;
  return v2;
}

uint64_t _libssh2_channel_locate(uint64_t a1, int a2)
{
  uint64_t result;
  uint64_t v5;

  result = _libssh2_list_first(a1 + 552);
  if (result)
  {
    while (*(_DWORD *)(result + 48) != a2)
    {
      result = _libssh2_list_next(result);
      if (!result)
        goto LABEL_4;
    }
  }
  else
  {
LABEL_4:
    result = _libssh2_list_first(a1 + 576);
    if (result)
    {
      v5 = result;
      while (1)
      {
        result = _libssh2_list_first(v5 + 48);
        if (result)
          break;
LABEL_9:
        result = _libssh2_list_next(v5);
        v5 = result;
        if (!result)
          return result;
      }
      while (*(_DWORD *)(result + 48) != a2)
      {
        result = _libssh2_list_next(result);
        if (!result)
          goto LABEL_9;
      }
    }
  }
  return result;
}

uint64_t _libssh2_channel_open(uint64_t a1, const void *a2, unsigned int a3, unsigned int a4, unsigned int a5, const void *a6, size_t a7)
{
  uint64_t v9;
  int v10;
  _QWORD *v16;
  _DWORD *v17;
  void *v18;
  uint64_t v19;
  _DWORD *v20;
  uint64_t v21;
  uint64_t v22;
  char *v23;
  unsigned __int8 **v24;
  _QWORD *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  int v29;
  char *v30;
  uint64_t v31;
  uint64_t v32;
  _QWORD *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t result;
  int v37;
  uint64_t v38;
  int v39;
  _DWORD *v40;

  v9 = a1 + 72400;
  v40 = 0;
  v10 = *(_DWORD *)(a1 + 72400);
  if (v10 != 3)
  {
    if (v10 != 2)
    {
      if (v10)
        goto LABEL_25;
      *(_QWORD *)(a1 + 72416) = 0;
      v16 = (_QWORD *)(a1 + 72416);
      *(_QWORD *)(a1 + 72424) = 0;
      *(_QWORD *)(a1 + 72432) = a3 + 17;
      *(_QWORD *)(a1 + 72440) = 0;
      *(_DWORD *)(a1 + 72456) = _libssh2_channel_nextid(a1);
      *(_QWORD *)(v9 + 8) = 0;
      v17 = _libssh2_calloc(a1, 0x310uLL);
      *v16 = v17;
      if (!v17)
      {
        v23 = "Unable to allocate space for channel data";
        v27 = a1;
        v22 = 4294967290;
        goto LABEL_37;
      }
      v17[8] = a3;
      v18 = (void *)(*(uint64_t (**)(_QWORD, uint64_t))(a1 + 8))(a3, a1);
      *(_QWORD *)(*v16 + 24) = v18;
      if (!v18)
      {
        _libssh2_error(a1, 4294967290, "Failed allocating memory for channel type name");
        (*(void (**)(_QWORD, uint64_t))(a1 + 24))(*v16, a1);
        result = 0;
        *v16 = 0;
        return result;
      }
      memcpy(v18, a2, a3);
      v19 = *(_QWORD *)(v9 + 16);
      *(_DWORD *)(v19 + 48) = *(_DWORD *)(v9 + 56);
      *(_DWORD *)(v19 + 72) = a4;
      *(_DWORD *)(v19 + 76) = a4;
      *(_DWORD *)(v19 + 80) = a5;
      *(_QWORD *)(v19 + 104) = a1;
      _libssh2_list_add((_QWORD **)(a1 + 552), (_QWORD *)v19);
      v20 = (_DWORD *)(*(uint64_t (**)(_QWORD, uint64_t))(a1 + 8))(*(_QWORD *)(v9 + 32), a1);
      *(_QWORD *)(v9 + 24) = v20;
      v40 = v20;
      if (!v20)
      {
        v30 = "Unable to allocate temporary space for packet";
        v31 = a1;
        v22 = 4294967290;
        goto LABEL_24;
      }
      v40 = (_DWORD *)((char *)v20 + 1);
      *(_BYTE *)v20 = 90;
      _libssh2_store_str(&v40, a2, a3);
      _libssh2_store_u32(&v40, *(_DWORD *)(v9 + 56));
      _libssh2_store_u32(&v40, a4);
      _libssh2_store_u32(&v40, a5);
      *(_DWORD *)v9 = 2;
    }
    v21 = _libssh2_transport_send(a1, *(void **)(v9 + 24), *(_QWORD *)(v9 + 32), a6, a7);
    if ((_DWORD)v21)
    {
      v22 = v21;
      if ((_DWORD)v21 == -37)
      {
        v23 = "Would block sending channel-open request";
LABEL_15:
        v27 = a1;
LABEL_37:
        _libssh2_error(v27, v22, v23);
        return 0;
      }
      v30 = "Unable to send channel-open request";
LABEL_23:
      v31 = a1;
      goto LABEL_24;
    }
    *(_DWORD *)v9 = 3;
  }
  v24 = (unsigned __int8 **)(v9 + 40);
  v25 = (_QWORD *)(v9 + 48);
  v26 = _libssh2_packet_requirev(a1, "[\\", (_QWORD *)(v9 + 40), (unint64_t *)(v9 + 48), 1, (const void *)(*(_QWORD *)(v9 + 24) + a3 + 5), 4uLL, (time_t *)(a1 + 72408));
  if ((_DWORD)v26)
  {
    v22 = v26;
    if ((_DWORD)v26 == -37)
    {
      v23 = "Would block";
      goto LABEL_15;
    }
    v30 = "Unexpected error";
    goto LABEL_23;
  }
  if (!*v25)
  {
LABEL_20:
    v30 = "Unexpected packet size";
    v31 = a1;
    v22 = 4294967282;
LABEL_24:
    _libssh2_error(v31, v22, v30);
    goto LABEL_25;
  }
  v28 = (uint64_t)*v24;
  v29 = **v24;
  if (v29 == 92)
  {
    switch(_libssh2_ntohu32((unsigned int *)(v28 + 5)))
    {
      case 1u:
        v30 = "Channel open failure (administratively prohibited)";
        break;
      case 2u:
        v30 = "Channel open failure (connect failed)";
        break;
      case 3u:
        v30 = "Channel open failure (unknown channel type)";
        break;
      case 4u:
        v30 = "Channel open failure (resource shortage)";
        break;
      default:
        v30 = "Channel open failure";
        break;
    }
    v31 = a1;
    v22 = 4294967275;
    goto LABEL_24;
  }
  if (v29 == 91)
  {
    if (*v25 > 0x10uLL)
    {
      *(_DWORD *)(*(_QWORD *)(v9 + 16) + 68) = _libssh2_ntohu32((unsigned int *)(v28 + 5));
      *(_DWORD *)(*(_QWORD *)(v9 + 16) + 56) = _libssh2_ntohu32((unsigned int *)(*(_QWORD *)(v9 + 40) + 9));
      *(_DWORD *)(*(_QWORD *)(v9 + 16) + 52) = _libssh2_ntohu32((unsigned int *)(*(_QWORD *)(v9 + 40) + 9));
      v37 = _libssh2_ntohu32((unsigned int *)(*(_QWORD *)(v9 + 40) + 13));
      v38 = *(_QWORD *)(v9 + 24);
      *(_DWORD *)(*(_QWORD *)(v9 + 16) + 60) = v37;
      (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v38, a1);
      *(_QWORD *)(v9 + 24) = 0;
      (*(void (**)(_QWORD, uint64_t))(a1 + 24))(*(_QWORD *)(v9 + 40), a1);
      *(_QWORD *)(v9 + 40) = 0;
      *(_DWORD *)v9 = 0;
      return *(_QWORD *)(v9 + 16);
    }
    goto LABEL_20;
  }
LABEL_25:
  v33 = (_QWORD *)(v9 + 40);
  v32 = *(_QWORD *)(v9 + 40);
  if (v32)
  {
    (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v32, a1);
    *v33 = 0;
  }
  v34 = *(_QWORD *)(v9 + 24);
  if (v34)
  {
    (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v34, a1);
    *(_QWORD *)(v9 + 24) = 0;
  }
  v35 = *(_QWORD *)(v9 + 16);
  if (v35)
  {
    (*(void (**)(_QWORD, uint64_t))(a1 + 24))(*(_QWORD *)(v35 + 24), a1);
    _libssh2_list_remove(*(uint64_t **)(v9 + 16));
    _libssh2_htonu32(&v39, *(_DWORD *)(*(_QWORD *)(v9 + 16) + 48));
    while ((_libssh2_packet_ask(a1, 94, (_QWORD *)(v9 + 40), (unint64_t *)(a1 + 72448), 1, &v39, 4uLL) & 0x80000000) == 0
         || (_libssh2_packet_ask(a1, 95, (_QWORD *)(v9 + 40), (unint64_t *)(a1 + 72448), 1, &v39, 4uLL) & 0x80000000) == 0)
    {
      (*(void (**)(_QWORD, uint64_t))(a1 + 24))(*v33, a1);
      *v33 = 0;
    }
    (*(void (**)(_QWORD, uint64_t))(a1 + 24))(*(_QWORD *)(v9 + 16), a1);
    *(_QWORD *)(v9 + 16) = 0;
  }
  result = 0;
  *(_DWORD *)v9 = 0;
  return result;
}

uint64_t libssh2_channel_open_ex(uint64_t result, const void *a2, unsigned int a3, unsigned int a4, unsigned int a5, const void *a6, unsigned int a7)
{
  uint64_t v13;
  time_t v14;

  if (result)
  {
    v13 = result;
    v14 = time(0);
    while (1)
    {
      result = _libssh2_channel_open(v13, a2, a3, a4, a5, a6, a7);
      if (!*(_DWORD *)(v13 + 172) || result != 0)
        break;
      if (libssh2_session_last_errno(v13) != -37 || _libssh2_wait_socket(v13, v14))
        return 0;
    }
  }
  return result;
}

uint64_t libssh2_channel_direct_tcpip_ex(uint64_t a1, const char *a2, unsigned int a3, const char *a4, unsigned int a5)
{
  uint64_t v10;
  time_t v11;
  size_t v12;
  size_t v13;
  _DWORD *v14;
  uint64_t v15;
  BOOL v16;
  _DWORD *v18;

  if (a1)
  {
    v10 = a1 + 72460;
    v11 = time(0);
    do
    {
      v18 = 0;
      if (!*(_DWORD *)v10)
      {
        v12 = strlen(a2);
        *(_QWORD *)(v10 + 12) = v12;
        v13 = strlen(a4);
        *(_QWORD *)(v10 + 20) = v13;
        *(_QWORD *)(v10 + 28) = v12 + v13 + 16;
        v14 = (_DWORD *)(*(uint64_t (**)(void))(a1 + 8))();
        *(_QWORD *)(v10 + 4) = v14;
        v18 = v14;
        if (!v14)
        {
          _libssh2_error(a1, 4294967290, "Unable to allocate memory for direct-tcpip connection");
          v15 = 0;
          goto LABEL_10;
        }
        _libssh2_store_str(&v18, a2, *(_QWORD *)(v10 + 12));
        _libssh2_store_u32(&v18, a3);
        _libssh2_store_str(&v18, a4, *(_QWORD *)(v10 + 20));
        _libssh2_store_u32(&v18, a5);
      }
      v15 = _libssh2_channel_open(a1, "direct-tcpip", 0xCu, 0x200000u, 0x8000u, *(const void **)(v10 + 4), *(_QWORD *)(v10 + 28));
      if (v15 || libssh2_session_last_errno(a1) != -37)
      {
        *(_DWORD *)v10 = 0;
        (*(void (**)(_QWORD, uint64_t))(a1 + 24))(*(_QWORD *)(v10 + 4), a1);
        *(_QWORD *)(v10 + 4) = 0;
      }
      else
      {
        v15 = 0;
        *(_DWORD *)v10 = 2;
      }
LABEL_10:
      if (v15)
        v16 = 1;
      else
        v16 = *(_DWORD *)(a1 + 172) == 0;
      if (v16)
        return v15;
    }
    while (libssh2_session_last_errno(a1) == -37 && !_libssh2_wait_socket(a1, v11));
  }
  return 0;
}

uint64_t libssh2_channel_direct_streamlocal_ex(uint64_t a1, const char *a2, const char *a3, unsigned int a4)
{
  uint64_t v8;
  time_t v9;
  size_t v10;
  size_t v11;
  _DWORD *v12;
  uint64_t v13;
  BOOL v14;
  _DWORD *v16;

  if (a1)
  {
    v8 = a1 + 72460;
    v9 = time(0);
    do
    {
      v16 = 0;
      if (!*(_DWORD *)v8)
      {
        v10 = strlen(a2);
        *(_QWORD *)(v8 + 12) = v10;
        v11 = strlen(a3);
        *(_QWORD *)(v8 + 20) = v11;
        *(_QWORD *)(v8 + 28) = v10 + v11 + 12;
        v12 = (_DWORD *)(*(uint64_t (**)(void))(a1 + 8))();
        *(_QWORD *)(v8 + 4) = v12;
        v16 = v12;
        if (!v12)
        {
          _libssh2_error(a1, 4294967290, "Unable to allocate memory for direct-streamlocal connection");
          v13 = 0;
          goto LABEL_10;
        }
        _libssh2_store_str(&v16, a2, *(_QWORD *)(v8 + 12));
        _libssh2_store_str(&v16, a3, *(_QWORD *)(v8 + 20));
        _libssh2_store_u32(&v16, a4);
      }
      v13 = _libssh2_channel_open(a1, "direct-streamlocal@openssh.com", 0x1Eu, 0x200000u, 0x8000u, *(const void **)(v8 + 4), *(_QWORD *)(v8 + 28));
      if (v13 || libssh2_session_last_errno(a1) != -37)
      {
        *(_DWORD *)v8 = 0;
        (*(void (**)(_QWORD, uint64_t))(a1 + 24))(*(_QWORD *)(v8 + 4), a1);
        *(_QWORD *)(v8 + 4) = 0;
      }
      else
      {
        v13 = 0;
        *(_DWORD *)v8 = 2;
      }
LABEL_10:
      if (v13)
        v14 = 1;
      else
        v14 = *(_DWORD *)(a1 + 172) == 0;
      if (v14)
        return v13;
    }
    while (libssh2_session_last_errno(a1) == -37 && !_libssh2_wait_socket(a1, v9));
  }
  return 0;
}

_QWORD *libssh2_channel_forward_listen_ex(uint64_t a1, const char *a2, unsigned int a3, _DWORD *a4, int a5)
{
  uint64_t v10;
  time_t v11;
  int v12;
  int v13;
  uint64_t v14;
  _BYTE *v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  int v20;
  int v21;
  _QWORD *v22;
  void *v23;
  int v24;
  uint64_t v25;
  uint64_t v26;
  char *v27;
  unint64_t v29;
  unsigned __int8 *v30;
  _DWORD *v31;

  if (a1)
  {
    v10 = a1 + 72496;
    v11 = time(0);
    if (!a2)
      a2 = "0.0.0.0";
    do
    {
      v31 = 0;
      v12 = *(_DWORD *)v10;
      if (*(_DWORD *)v10 != 3)
      {
        if (v12 != 2)
        {
          if (v12)
            goto LABEL_32;
          v13 = strlen(a2);
          *(_DWORD *)(v10 + 16) = v13;
          *(_DWORD *)(v10 + 20) = v13 + 27;
          *(_QWORD *)(v10 + 24) = 0;
          v14 = (*(uint64_t (**)(_QWORD, uint64_t))(a1 + 8))((v13 + 27), a1);
          *(_QWORD *)(v10 + 8) = v14;
          if (!v14)
          {
            v17 = a1;
            v18 = 4294967290;
            v19 = "Unable to allocate memory for setenv packet";
            goto LABEL_29;
          }
          v31 = (_DWORD *)(v14 + 1);
          *(_BYTE *)v14 = 80;
          _libssh2_store_str(&v31, "tcpip-forward", 0xDuLL);
          v15 = v31;
          v31 = (_DWORD *)((char *)v31 + 1);
          *v15 = 1;
          _libssh2_store_str(&v31, a2, *(unsigned int *)(v10 + 16));
          _libssh2_store_u32(&v31, a3);
          *(_DWORD *)v10 = 2;
        }
        v16 = _libssh2_transport_send(a1, *(void **)(v10 + 8), *(unsigned int *)(v10 + 20), 0, 0);
        if (v16)
        {
          if (v16 != -37)
          {
            _libssh2_error(a1, 4294967289, "Unable to send global-request packet for forward listen request");
            (*(void (**)(_QWORD, uint64_t))(a1 + 24))(*(_QWORD *)(v10 + 8), a1);
            v22 = 0;
            *(_QWORD *)(v10 + 8) = 0;
            goto LABEL_33;
          }
          v17 = a1;
          v18 = 4294967259;
          v19 = "Would block sending global-request packet for forward listen request";
          goto LABEL_29;
        }
        (*(void (**)(_QWORD, uint64_t))(a1 + 24))(*(_QWORD *)(v10 + 8), a1);
        *(_QWORD *)(v10 + 8) = 0;
        *(_DWORD *)v10 = 3;
      }
      v29 = 0;
      v30 = 0;
      v20 = _libssh2_packet_requirev(a1, "QR", &v30, &v29, 0, 0, 0, (time_t *)(v10 + 24));
      if (v20 != -37)
      {
        if (v20 || !v29)
        {
          v25 = a1;
          v26 = 4294967282;
          v27 = "Unknown";
        }
        else
        {
          v21 = *v30;
          if (v21 != 82)
          {
            if (v21 == 81)
            {
              v22 = _libssh2_calloc(a1, 0x60uLL);
              if (v22)
              {
                v23 = (void *)(*(uint64_t (**)(_QWORD, uint64_t))(a1 + 8))((*(_DWORD *)(v10 + 16) + 1), a1);
                v22[4] = v23;
                if (v23)
                {
                  v22[3] = a1;
                  memcpy(v23, a2, *(unsigned int *)(v10 + 16));
                  *(_BYTE *)(v22[4] + *(unsigned int *)(v10 + 16)) = 0;
                  v24 = a3;
                  if (!a3)
                  {
                    v24 = 0;
                    if (v29 >= 5)
                      v24 = _libssh2_ntohu32((unsigned int *)(v30 + 1));
                  }
                  *((_DWORD *)v22 + 10) = v24;
                  *((_DWORD *)v22 + 16) = 0;
                  *((_DWORD *)v22 + 17) = a5;
                  _libssh2_list_add((_QWORD **)(a1 + 576), v22);
                  if (a4)
                    *a4 = *((_DWORD *)v22 + 10);
                }
                else
                {
                  _libssh2_error(a1, 4294967290, "Unable to allocate memory for listener queue");
                  (*(void (**)(_QWORD *, uint64_t))(a1 + 24))(v22, a1);
                  v22 = 0;
                }
              }
              else
              {
                _libssh2_error(a1, 4294967290, "Unable to allocate memory for listener queue");
              }
              (*(void (**)(unsigned __int8 *, uint64_t))(a1 + 24))(v30, a1);
LABEL_33:
              *(_DWORD *)v10 = 0;
              if (v22)
                return v22;
              goto LABEL_34;
            }
LABEL_32:
            v22 = 0;
            goto LABEL_33;
          }
          (*(void (**)(void))(a1 + 24))();
          v25 = a1;
          v26 = 4294967264;
          v27 = "Unable to complete request for forward-listen";
        }
        _libssh2_error(v25, v26, v27);
        goto LABEL_32;
      }
      v17 = a1;
      v18 = 4294967259;
      v19 = "Would block";
LABEL_29:
      _libssh2_error(v17, v18, v19);
      v22 = 0;
LABEL_34:
      if (!*(_DWORD *)(a1 + 172))
        return v22;
    }
    while (libssh2_session_last_errno(a1) == -37 && !_libssh2_wait_socket(a1, v11));
  }
  return 0;
}

uint64_t _libssh2_channel_forward_cancel(uint64_t a1)
{
  uint64_t v2;
  size_t v3;
  size_t v4;
  int v5;
  void *v6;
  unint64_t v7;
  uint64_t v8;
  _BYTE *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  _DWORD *v16;

  v16 = 0;
  v2 = *(_QWORD *)(a1 + 24);
  v3 = strlen(*(const char **)(a1 + 32));
  v4 = v3 + 34;
  v5 = *(_DWORD *)(a1 + 72);
  if (v5)
  {
    if (v5 != 2)
    {
      v11 = 0;
      goto LABEL_12;
    }
    v6 = *(void **)(a1 + 80);
  }
  else
  {
    v7 = v3;
    v8 = (*(uint64_t (**)(size_t, uint64_t))(v2 + 8))(v3 + 34, v2);
    if (!v8)
    {
      v11 = 4294967290;
      _libssh2_error(v2, 4294967290, "Unable to allocate memory for setenv packet");
      return v11;
    }
    v6 = (void *)v8;
    v16 = (_DWORD *)(v8 + 1);
    *(_BYTE *)v8 = 80;
    _libssh2_store_str(&v16, "cancel-tcpip-forward", 0x14uLL);
    v9 = v16;
    v16 = (_DWORD *)((char *)v16 + 1);
    *v9 = 0;
    _libssh2_store_str(&v16, *(const void **)(a1 + 32), v7);
    _libssh2_store_u32(&v16, *(_DWORD *)(a1 + 40));
    *(_DWORD *)(a1 + 72) = 2;
  }
  v10 = _libssh2_transport_send(v2, v6, v4, 0, 0);
  v11 = v10;
  if ((_DWORD)v10)
  {
    if ((_DWORD)v10 == -37)
    {
      _libssh2_error(v2, 4294967259, "Would block sending forward request");
      *(_QWORD *)(a1 + 80) = v6;
      return v11;
    }
    v11 = 4294967289;
    _libssh2_error(v2, 4294967289, "Unable to send global-request packet for forward listen request");
    *(_DWORD *)(a1 + 72) = 3;
  }
  (*(void (**)(void *, uint64_t))(v2 + 24))(v6, v2);
  *(_DWORD *)(a1 + 72) = 3;
LABEL_12:
  v12 = _libssh2_list_first(a1 + 48);
  while (v12)
  {
    v13 = _libssh2_list_next(v12);
    v14 = _libssh2_channel_free(v12);
    v12 = v13;
    if (v14 == -37)
      return 4294967259;
  }
  (*(void (**)(_QWORD, uint64_t))(v2 + 24))(*(_QWORD *)(a1 + 32), v2);
  _libssh2_list_remove((uint64_t *)a1);
  (*(void (**)(uint64_t, uint64_t))(v2 + 24))(a1, v2);
  return v11;
}

uint64_t _libssh2_channel_free(uint64_t a1)
{
  uint64_t v1;
  uint64_t result;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  int v11;

  v1 = *(_QWORD *)(a1 + 104);
  if (!v1)
    _libssh2_channel_free_cold_1();
  if (!*(_DWORD *)(a1 + 684))
    *(_DWORD *)(a1 + 684) = 2;
  if (*(_BYTE *)(a1 + 64) || *(_DWORD *)(v1 + 596) || (result = _libssh2_channel_close(a1), (_DWORD)result != -37))
  {
    *(_DWORD *)(a1 + 684) = 0;
    v4 = *(_QWORD *)(a1 + 40);
    if (v4)
      (*(void (**)(uint64_t, uint64_t))(v1 + 24))(v4, v1);
    v9 = 0;
    v10 = 0;
    _libssh2_htonu32(&v11, *(_DWORD *)(a1 + 48));
    while ((_libssh2_packet_ask(v1, 94, &v10, &v9, 1, &v11, 4uLL) & 0x80000000) == 0
         || (_libssh2_packet_ask(v1, 95, &v10, &v9, 1, &v11, 4uLL) & 0x80000000) == 0)
      (*(void (**)(uint64_t, uint64_t))(v1 + 24))(v10, v1);
    v5 = *(_QWORD *)(a1 + 24);
    if (v5)
      (*(void (**)(uint64_t, uint64_t))(v1 + 24))(v5, v1);
    _libssh2_list_remove((uint64_t *)a1);
    v6 = *(_QWORD *)(a1 + 136);
    if (v6)
      (*(void (**)(uint64_t, uint64_t))(v1 + 24))(v6, v1);
    v7 = *(_QWORD *)(a1 + 504);
    if (v7)
      (*(void (**)(uint64_t, uint64_t))(v1 + 24))(v7, v1);
    v8 = *(_QWORD *)(a1 + 544);
    if (v8)
      (*(void (**)(uint64_t, uint64_t))(v1 + 24))(v8, v1);
    (*(void (**)(uint64_t, uint64_t))(v1 + 24))(a1, v1);
    return 0;
  }
  return result;
}

uint64_t libssh2_channel_forward_cancel(uint64_t a1)
{
  time_t v2;
  uint64_t result;
  uint64_t v4;

  if (!a1)
    return 4294967257;
  v2 = time(0);
  do
  {
    result = _libssh2_channel_forward_cancel(a1);
    if ((_DWORD)result != -37)
      break;
    v4 = *(_QWORD *)(a1 + 24);
    if (!*(_DWORD *)(v4 + 172))
      return 4294967259;
    result = _libssh2_wait_socket(v4, v2);
  }
  while (!(_DWORD)result);
  return result;
}

uint64_t *libssh2_channel_forward_accept(uint64_t a1)
{
  time_t v2;
  int v3;
  int v4;
  uint64_t v5;
  char *v6;
  uint64_t v7;
  uint64_t *v8;

  if (!a1)
    return 0;
  v2 = time(0);
  while (1)
  {
    do
      v3 = _libssh2_transport_read(*(_QWORD *)(a1 + 24));
    while (v3 > 0);
    v4 = v3;
    if (_libssh2_list_first(a1 + 48))
      break;
    if (v4 == -37)
    {
      v5 = 4294967259;
      v6 = "Would block waiting for packet";
    }
    else
    {
      v5 = 4294967273;
      v6 = "Channel not found";
    }
    _libssh2_error(*(_QWORD *)(a1 + 24), v5, v6);
    v7 = *(_QWORD *)(a1 + 24);
    if (!*(_DWORD *)(v7 + 172)
      || libssh2_session_last_errno(v7) != -37
      || _libssh2_wait_socket(*(_QWORD *)(a1 + 24), v2))
    {
      return 0;
    }
  }
  v8 = (uint64_t *)_libssh2_list_first(a1 + 48);
  _libssh2_list_remove(v8);
  --*(_DWORD *)(a1 + 64);
  _libssh2_list_add((_QWORD **)(v8[13] + 552), v8);
  return v8;
}

uint64_t libssh2_channel_setenv_ex(uint64_t a1, const void *a2, int a3, const void *a4, int a5)
{
  time_t v8;
  uint64_t v9;
  time_t *v10;
  unint64_t v11;
  unint64_t v12;
  _DWORD *v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  _BYTE *v17;
  int v18;
  uint64_t v19;
  uint64_t v20;
  _DWORD *v21;
  uint64_t v22;
  time_t *v23;
  const void *v24;
  const void *v25;
  unint64_t v26;
  unint64_t v27;
  int v28;
  BOOL v29;
  uint64_t v30;
  char *v31;
  uint64_t result;
  uint64_t v33;
  time_t v34;
  unint64_t v35;
  unsigned __int8 *v36;
  _DWORD *v37;

  if (!a1)
    return 4294967257;
  LODWORD(v12) = a5;
  LODWORD(v11) = a3;
  v8 = time(0);
  v9 = (v11 + v12 + 21);
  v10 = (time_t *)(a1 + 160);
  v11 = v11;
  v12 = v12;
  v13 = (_DWORD *)(a1 + 152);
  while (1)
  {
    v14 = *(_QWORD *)(a1 + 104);
    v36 = 0;
    v37 = 0;
    v35 = 0;
    v15 = *(_DWORD *)(a1 + 128);
    if (v15 != 3)
    {
      if (v15 != 2)
      {
        if (v15)
          goto LABEL_16;
        *(_QWORD *)(a1 + 144) = v9;
        *(_QWORD *)(a1 + 160) = 0;
        v16 = (*(uint64_t (**)(uint64_t, uint64_t))(v14 + 8))(v9, v14);
        *(_QWORD *)(a1 + 136) = v16;
        if (!v16)
        {
          v30 = v14;
          v20 = 4294967290;
          v31 = "Unable to allocate memory for setenv packet";
          goto LABEL_21;
        }
        v37 = (_DWORD *)(v16 + 1);
        *(_BYTE *)v16 = 98;
        _libssh2_store_u32(&v37, *(_DWORD *)(a1 + 68));
        _libssh2_store_str(&v37, "env", 3uLL);
        v17 = v37;
        v37 = (_DWORD *)((char *)v37 + 1);
        *v17 = 1;
        _libssh2_store_str(&v37, a2, v11);
        _libssh2_store_str(&v37, a4, v12);
        *(_DWORD *)(a1 + 128) = 2;
      }
      v18 = _libssh2_transport_send(v14, *(void **)(a1 + 136), *(_QWORD *)(a1 + 144), 0, 0);
      if (v18)
      {
        if (v18 == -37)
        {
          _libssh2_error(v14, 4294967259, "Would block sending setenv request");
          goto LABEL_22;
        }
        (*(void (**)(_QWORD, uint64_t))(v14 + 24))(*(_QWORD *)(a1 + 136), v14);
        *(_QWORD *)(a1 + 136) = 0;
        *(_DWORD *)(a1 + 128) = 0;
        v30 = v14;
        v20 = 4294967289;
        v31 = "Unable to send channel-request packet for setenv request";
        goto LABEL_21;
      }
      (*(void (**)(_QWORD, uint64_t))(v14 + 24))(*(_QWORD *)(a1 + 136), v14);
      *(_QWORD *)(a1 + 136) = 0;
      _libssh2_htonu32(v13, *(_DWORD *)(a1 + 48));
      *(_DWORD *)(a1 + 128) = 3;
    }
    v19 = _libssh2_packet_requirev(v14, "cd", &v36, &v35, 1, v13, 4uLL, v10);
    if ((_DWORD)v19 == -37)
      goto LABEL_22;
    v20 = v19;
    if ((_DWORD)v19)
    {
      *(_DWORD *)(a1 + 128) = 0;
      v30 = v14;
      v31 = "Failed getting response for channel-setenv";
      goto LABEL_21;
    }
    if (v35)
      break;
    *(_DWORD *)(a1 + 128) = 0;
    v30 = v14;
    v20 = 4294967282;
    v31 = "Unexpected packet size";
LABEL_21:
    result = _libssh2_error(v30, v20, v31);
    if ((_DWORD)result != -37)
      return result;
LABEL_22:
    v33 = *(_QWORD *)(a1 + 104);
    if (!*(_DWORD *)(v33 + 172))
      return 4294967259;
    result = _libssh2_wait_socket(v33, v8);
    if ((_DWORD)result)
      return result;
  }
  v34 = v8;
  v21 = v13;
  v22 = v9;
  v23 = v10;
  v24 = a2;
  v25 = a4;
  v26 = v12;
  v27 = v11;
  v28 = *v36;
  (*(void (**)(void))(v14 + 24))();
  v29 = v28 == 99;
  v11 = v27;
  v12 = v26;
  a4 = v25;
  a2 = v24;
  v10 = v23;
  v9 = v22;
  v13 = v21;
  v8 = v34;
  if (!v29)
  {
LABEL_16:
    *(_DWORD *)(a1 + 128) = 0;
    v30 = v14;
    v20 = 4294967274;
    v31 = "Unable to complete request for channel-setenv";
    goto LABEL_21;
  }
  result = 0;
  *(_DWORD *)(a1 + 128) = 0;
  return result;
}

uint64_t libssh2_channel_request_auth_agent(uint64_t a1)
{
  int v2;
  uint64_t result;
  time_t v4;
  uint64_t v5;
  time_t v7;
  uint64_t v8;
  int v9;

  if (!a1)
    return 4294967257;
  v2 = *(_DWORD *)(a1 + 692);
  if (v2)
  {
    result = 4294967273;
  }
  else
  {
    v4 = time(0);
    do
    {
      result = channel_request_auth_agent(a1, "auth-agent-req@openssh.com", 0x1Au);
      if ((_DWORD)result != -37)
        break;
      v5 = *(_QWORD *)(a1 + 104);
      if (!*(_DWORD *)(v5 + 172))
      {
        result = 4294967259;
        goto LABEL_15;
      }
      result = _libssh2_wait_socket(v5, v4);
    }
    while (!(_DWORD)result);
    if ((_DWORD)result != -37 && (_DWORD)result != 0)
    {
      *(_DWORD *)(a1 + 692) = 3;
      goto LABEL_17;
    }
LABEL_15:
    v2 = *(_DWORD *)(a1 + 692);
  }
  if (v2 == 3)
  {
LABEL_17:
    v7 = time(0);
    do
    {
      result = channel_request_auth_agent(a1, "auth-agent-req", 0xEu);
      if ((_DWORD)result != -37)
        break;
      v8 = *(_QWORD *)(a1 + 104);
      if (!*(_DWORD *)(v8 + 172))
        return 4294967259;
      result = _libssh2_wait_socket(v8, v7);
    }
    while (!(_DWORD)result);
    if ((_DWORD)result && (_DWORD)result != -37)
    {
      v9 = 4;
      goto LABEL_27;
    }
  }
  if ((_DWORD)result)
    return result;
  v9 = 0;
LABEL_27:
  *(_DWORD *)(a1 + 692) = v9;
  return result;
}

uint64_t channel_request_auth_agent(uint64_t a1, const void *a2, unsigned int a3)
{
  uint64_t v4;
  int v5;
  _BYTE *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  char *v14;
  uint64_t v15;
  unint64_t v17;
  unsigned __int8 *v18;
  _DWORD *v19;

  v4 = *(_QWORD *)(a1 + 104);
  v19 = 0;
  v5 = *(_DWORD *)(a1 + 696);
  if (v5 == 3)
    goto LABEL_9;
  if (v5 != 2)
  {
    if (v5)
    {
LABEL_12:
      v14 = "Unable to complete request for auth-agent";
      v15 = v4;
      v10 = 4294967274;
      return _libssh2_error(v15, v10, v14);
    }
    *(_QWORD *)(a1 + 736) = a3 + 10;
    *(_QWORD *)(a1 + 752) = 0;
    *(_BYTE *)(a1 + 700) = 98;
    v19 = (_DWORD *)(a1 + 701);
    _libssh2_store_u32(&v19, *(_DWORD *)(a1 + 68));
    _libssh2_store_str(&v19, a2, a3);
    v8 = v19;
    v19 = (_DWORD *)((char *)v19 + 1);
    *v8 = 1;
    *(_DWORD *)(a1 + 696) = 2;
  }
  v9 = _libssh2_transport_send(v4, (void *)(a1 + 700), *(_QWORD *)(a1 + 736), 0, 0);
  if (!(_DWORD)v9)
  {
    _libssh2_htonu32((_DWORD *)(a1 + 744), *(_DWORD *)(a1 + 48));
    *(_DWORD *)(a1 + 696) = 3;
LABEL_9:
    v17 = 0;
    v18 = 0;
    v12 = _libssh2_packet_requirev(v4, "cd", &v18, &v17, 1, (const void *)(a1 + 744), 4uLL, (time_t *)(a1 + 752));
    v11 = v12;
    if ((_DWORD)v12 == -37)
      return v11;
    if ((_DWORD)v12)
    {
      *(_DWORD *)(a1 + 696) = 0;
      v14 = "Failed to request auth-agent";
      v15 = v4;
      v10 = 4294967282;
      return _libssh2_error(v15, v10, v14);
    }
    v13 = *v18;
    (*(void (**)(void))(v4 + 24))();
    *(_DWORD *)(a1 + 696) = 0;
    if (v13 == 99)
      return v11;
    goto LABEL_12;
  }
  v10 = v9;
  if ((_DWORD)v9 != -37)
  {
    *(_DWORD *)(a1 + 696) = 0;
    v14 = "Unable to send auth-agent request";
    v15 = v4;
    return _libssh2_error(v15, v10, v14);
  }
  v11 = 4294967259;
  _libssh2_error(v4, v9, "Would block sending auth-agent request");
  return v11;
}

uint64_t libssh2_channel_request_pty_ex(uint64_t a1, const void *a2, unsigned int a3, const void *a4, unsigned int a5, uint64_t a6, uint64_t a7, uint64_t a8, unsigned int a9)
{
  uint64_t v17;
  time_t v18;
  unint64_t v19;
  time_t *v20;
  uint64_t v21;
  int v22;
  uint64_t v23;
  uint64_t v24;
  char *v25;
  _BYTE *v26;
  uint64_t v27;
  uint64_t result;
  BOOL v29;
  time_t *v30;
  uint64_t v31;
  const void *v32;
  const void *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  int v37;
  uint64_t v38;
  time_t v39;
  unint64_t v40;
  unint64_t v41;
  uint64_t v42;
  unsigned int v43;
  _DWORD *v44;
  unint64_t v45;
  unsigned __int8 *v46;
  _DWORD *v47;

  if (!a1)
    return 4294967257;
  v17 = a9;
  v18 = time(0);
  v43 = a5 + a3;
  v42 = a5 + a3 + 41;
  v19 = a3;
  v20 = (time_t *)(a1 + 488);
  v40 = a5;
  v41 = v19;
  v44 = (_DWORD *)(a1 + 480);
  v39 = v18;
  while (1)
  {
    v21 = *(_QWORD *)(a1 + 104);
    v47 = 0;
    v22 = *(_DWORD *)(a1 + 168);
    if (v22 == 3)
      break;
    if (v22 == 2)
      goto LABEL_9;
    if (v22)
      goto LABEL_22;
    if (v43 < 0x101)
    {
      *(_QWORD *)(a1 + 472) = v42;
      *(_QWORD *)(a1 + 488) = 0;
      v47 = (_DWORD *)(a1 + 173);
      *(_BYTE *)(a1 + 172) = 98;
      _libssh2_store_u32(&v47, *(_DWORD *)(a1 + 68));
      _libssh2_store_str(&v47, "pty-req", 7uLL);
      v26 = v47;
      v47 = (_DWORD *)((char *)v47 + 1);
      *v26 = 1;
      _libssh2_store_str(&v47, a2, v41);
      _libssh2_store_u32(&v47, a6);
      _libssh2_store_u32(&v47, a7);
      _libssh2_store_u32(&v47, a8);
      _libssh2_store_u32(&v47, v17);
      _libssh2_store_str(&v47, a4, v40);
      *(_DWORD *)(a1 + 168) = 2;
LABEL_9:
      v27 = _libssh2_transport_send(v21, (void *)(a1 + 172), *(_QWORD *)(a1 + 472), 0, 0);
      if ((_DWORD)v27)
      {
        v24 = v27;
        if ((_DWORD)v27 == -37)
        {
          _libssh2_error(v21, v27, "Would block sending pty request");
          goto LABEL_25;
        }
        *(_DWORD *)(a1 + 168) = 0;
        v23 = v21;
        v25 = "Unable to send pty-request packet";
        goto LABEL_23;
      }
      _libssh2_htonu32(v44, *(_DWORD *)(a1 + 48));
      *(_DWORD *)(a1 + 168) = 3;
      break;
    }
    v23 = v21;
    v24 = 4294967262;
    v25 = "term + mode lengths too large";
LABEL_23:
    result = _libssh2_error(v23, v24, v25);
LABEL_24:
    if ((_DWORD)result != -37)
      return result;
LABEL_25:
    v38 = *(_QWORD *)(a1 + 104);
    if (!*(_DWORD *)(v38 + 172))
      return 4294967259;
    result = _libssh2_wait_socket(v38, v18);
    if ((_DWORD)result)
      return result;
  }
  v45 = 0;
  v46 = 0;
  result = _libssh2_packet_requirev(v21, "cd", &v46, &v45, 1, v44, 4uLL, v20);
  if ((_DWORD)result == -37)
    goto LABEL_24;
  if ((_DWORD)result)
    v29 = 1;
  else
    v29 = v45 == 0;
  if (v29)
  {
    *(_DWORD *)(a1 + 168) = 0;
    v23 = v21;
    v24 = 4294967282;
    v25 = "Failed to require the PTY package";
    goto LABEL_23;
  }
  v30 = v20;
  v31 = v17;
  v32 = a2;
  v33 = a4;
  v34 = a6;
  v35 = a7;
  v36 = a8;
  v37 = *v46;
  (*(void (**)(void))(v21 + 24))();
  *(_DWORD *)(a1 + 168) = 0;
  v29 = v37 == 99;
  a8 = v36;
  a7 = v35;
  a6 = v34;
  a4 = v33;
  a2 = v32;
  v17 = v31;
  v20 = v30;
  v18 = v39;
  if (!v29)
  {
LABEL_22:
    v23 = v21;
    v24 = 4294967274;
    v25 = "Unable to complete request for channel request-pty";
    goto LABEL_23;
  }
  return 0;
}

uint64_t libssh2_channel_request_pty_size_ex(uint64_t a1, unsigned int a2, unsigned int a3, unsigned int a4, unsigned int a5)
{
  time_t v10;
  uint64_t v11;
  int v12;
  _BYTE *v13;
  uint64_t v14;
  uint64_t result;
  uint64_t v16;
  _DWORD *v17;

  if (!a1)
    return 4294967257;
  v10 = time(0);
  while (1)
  {
    v11 = *(_QWORD *)(a1 + 104);
    v17 = 0;
    v12 = *(_DWORD *)(a1 + 168);
    if (v12 != 2)
    {
      if (v12)
      {
        result = 4294967282;
        goto LABEL_18;
      }
      *(_QWORD *)(a1 + 472) = 39;
      *(_QWORD *)(a1 + 488) = 0;
      v17 = (_DWORD *)(a1 + 173);
      *(_BYTE *)(a1 + 172) = 98;
      _libssh2_store_u32(&v17, *(_DWORD *)(a1 + 68));
      _libssh2_store_str(&v17, "window-change", 0xDuLL);
      v13 = v17;
      v17 = (_DWORD *)((char *)v17 + 1);
      *v13 = 0;
      _libssh2_store_u32(&v17, a2);
      _libssh2_store_u32(&v17, a3);
      _libssh2_store_u32(&v17, a4);
      _libssh2_store_u32(&v17, a5);
      *(_DWORD *)(a1 + 168) = 2;
    }
    v14 = _libssh2_transport_send(v11, (void *)(a1 + 172), *(_QWORD *)(a1 + 472), 0, 0);
    if ((_DWORD)v14 == -37)
    {
      _libssh2_error(v11, v14, "Would block sending window-change request");
      goto LABEL_11;
    }
    if (!(_DWORD)v14)
      break;
    *(_DWORD *)(a1 + 168) = 0;
    result = _libssh2_error(v11, v14, "Unable to send window-change packet");
    if ((_DWORD)result != -37)
      return result;
LABEL_11:
    v16 = *(_QWORD *)(a1 + 104);
    if (!*(_DWORD *)(v16 + 172))
      return 4294967259;
    result = _libssh2_wait_socket(v16, v10);
    if ((_DWORD)result)
      return result;
  }
  _libssh2_htonu32((_DWORD *)(a1 + 480), *(_DWORD *)(a1 + 48));
  result = 0;
LABEL_18:
  *(_DWORD *)(a1 + 168) = 0;
  return result;
}

uint64_t libssh2_channel_x11_req_ex(uint64_t a1, int a2, const char *a3, const char *a4, unsigned int a5)
{
  time_t v10;
  const char *v11;
  uint64_t v12;
  size_t v13;
  size_t v14;
  int v15;
  _BYTE *v16;
  _BYTE *v17;
  _BYTE *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t result;
  uint64_t v22;
  int v23;
  uint64_t v24;
  char *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t i;
  unsigned int v29;
  const char *v30;
  BOOL v31;
  _DWORD *v32;
  unsigned __int8 *v33;
  void *__dst;
  unint64_t v35[4];

  v35[3] = *MEMORY[0x24BDAC8D0];
  if (!a1)
    return 4294967257;
  v10 = time(0);
  v31 = a2 != 0;
  v11 = "MIT-MAGIC-COOKIE-1";
  if (a3)
    v11 = a3;
  v30 = v11;
  v32 = (_DWORD *)(a1 + 520);
  while (1)
  {
    v12 = *(_QWORD *)(a1 + 104);
    if (a3)
    {
      v13 = strlen(a3);
      if (a4)
        goto LABEL_7;
    }
    else
    {
      v13 = 18;
      if (a4)
      {
LABEL_7:
        v14 = strlen(a4);
        goto LABEL_10;
      }
    }
    v14 = 32;
LABEL_10:
    __dst = 0;
    v15 = *(_DWORD *)(a1 + 496);
    if (v15 == 3)
      goto LABEL_21;
    if (v15 == 2)
      goto LABEL_17;
    if (!v15)
      break;
LABEL_25:
    v24 = v12;
    v22 = 4294967274;
    v25 = "Unable to complete request for channel x11-req";
LABEL_31:
    result = _libssh2_error(v24, v22, v25);
LABEL_32:
    if ((_DWORD)result != -37)
      return result;
LABEL_33:
    v26 = *(_QWORD *)(a1 + 104);
    if (!*(_DWORD *)(v26 + 172))
      return 4294967259;
    result = _libssh2_wait_socket(v26, v10);
    if ((_DWORD)result)
      return result;
  }
  *(_QWORD *)(a1 + 512) = v13 + v14 + 30;
  *(_QWORD *)(a1 + 528) = 0;
  v16 = (_BYTE *)(*(uint64_t (**)(void))(v12 + 8))();
  *(_QWORD *)(a1 + 504) = v16;
  if (!v16)
  {
    v24 = v12;
    v22 = 4294967290;
    v25 = "Unable to allocate memory for pty-request";
    goto LABEL_31;
  }
  __dst = v16 + 1;
  *v16 = 98;
  _libssh2_store_u32((_DWORD **)&__dst, *(_DWORD *)(a1 + 68));
  _libssh2_store_str((_DWORD **)&__dst, "x11-req", 7uLL);
  v17 = __dst;
  __dst = (char *)__dst + 1;
  *v17 = 1;
  v18 = __dst;
  __dst = (char *)__dst + 1;
  *v18 = v31;
  _libssh2_store_str((_DWORD **)&__dst, v30, v13);
  _libssh2_store_u32((_DWORD **)&__dst, v14);
  if (a4)
  {
    memcpy(__dst, a4, v14);
  }
  else
  {
    if (_libssh2_openssl_random((unsigned __int8 *)v35, 0x10uLL))
    {
      v24 = v12;
      v22 = 4294967247;
      v25 = "Unable to get random bytes for x11-req cookie";
      goto LABEL_31;
    }
    v29 = a5;
    v27 = 0;
    for (i = 0; i != 16; ++i)
    {
      snprintf((char *)__dst + v27, 3uLL, "%02X", *((unsigned __int8 *)v35 + i));
      v27 += 2;
    }
    a5 = v29;
  }
  __dst = (char *)__dst + v14;
  _libssh2_store_u32((_DWORD **)&__dst, a5);
  *(_DWORD *)(a1 + 496) = 2;
LABEL_17:
  v19 = _libssh2_transport_send(v12, *(void **)(a1 + 504), *(_QWORD *)(a1 + 512), 0, 0);
  if ((_DWORD)v19)
  {
    v20 = v19;
    if ((_DWORD)v19 == -37)
    {
      _libssh2_error(v12, 4294967259, "Would block sending X11-req packet");
      goto LABEL_33;
    }
    (*(void (**)(_QWORD, uint64_t))(v12 + 24))(*(_QWORD *)(a1 + 504), v12);
    *(_QWORD *)(a1 + 504) = 0;
    *(_DWORD *)(a1 + 496) = 0;
    v24 = v12;
    v22 = v20;
    v25 = "Unable to send x11-req packet";
    goto LABEL_31;
  }
  (*(void (**)(_QWORD, uint64_t))(v12 + 24))(*(_QWORD *)(a1 + 504), v12);
  *(_QWORD *)(a1 + 504) = 0;
  _libssh2_htonu32(v32, *(_DWORD *)(a1 + 48));
  *(_DWORD *)(a1 + 496) = 3;
LABEL_21:
  v35[0] = 0;
  v33 = 0;
  result = _libssh2_packet_requirev(v12, "cd", &v33, v35, 1, v32, 4uLL, (time_t *)(a1 + 528));
  if ((_DWORD)result == -37)
    goto LABEL_32;
  v22 = result;
  if ((_DWORD)result || !v35[0])
  {
    *(_DWORD *)(a1 + 496) = 0;
    v24 = v12;
    v25 = "waiting for x11-req response packet";
    goto LABEL_31;
  }
  v23 = *v33;
  (*(void (**)(void))(v12 + 24))();
  *(_DWORD *)(a1 + 496) = 0;
  if (v23 != 99)
    goto LABEL_25;
  return 0;
}

uint64_t _libssh2_channel_process_startup(uint64_t a1, const void *a2, unint64_t a3, const void *a4, size_t a5)
{
  uint64_t v6;
  int v7;
  uint64_t v13;
  _BYTE *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  char *v21;
  uint64_t v22;
  unint64_t v23;
  unsigned __int8 *v24;
  _DWORD *v25;

  v6 = *(_QWORD *)(a1 + 104);
  v25 = 0;
  v7 = *(_DWORD *)(a1 + 536);
  if (v7 > 2)
  {
    if (v7 != 3)
    {
      if (v7 == 17)
        return _libssh2_error(v6, 4294967257, "Channel can not be reused");
      goto LABEL_24;
    }
    goto LABEL_18;
  }
  if (v7)
  {
    if (v7 != 2)
    {
LABEL_24:
      v21 = "Unable to complete request for channel-process-startup";
      v22 = v6;
      v19 = 4294967274;
      return _libssh2_error(v22, v19, v21);
    }
    goto LABEL_14;
  }
  *(_QWORD *)(a1 + 552) = a3 + 10;
  *(_QWORD *)(a1 + 568) = 0;
  if (a4)
    *(_QWORD *)(a1 + 552) = a3 + 14;
  v13 = (*(uint64_t (**)(void))(v6 + 8))();
  *(_QWORD *)(a1 + 544) = v13;
  if (v13)
  {
    v25 = (_DWORD *)(v13 + 1);
    *(_BYTE *)v13 = 98;
    _libssh2_store_u32(&v25, *(_DWORD *)(a1 + 68));
    _libssh2_store_str(&v25, a2, a3);
    v14 = v25;
    v25 = (_DWORD *)((char *)v25 + 1);
    *v14 = 1;
    if (a4)
      _libssh2_store_u32(&v25, a5);
    *(_DWORD *)(a1 + 536) = 2;
LABEL_14:
    v15 = _libssh2_transport_send(v6, *(void **)(a1 + 544), *(_QWORD *)(a1 + 552), a4, a5);
    if ((_DWORD)v15)
    {
      v16 = v15;
      if ((_DWORD)v15 != -37)
      {
        (*(void (**)(_QWORD, uint64_t))(v6 + 24))(*(_QWORD *)(a1 + 544), v6);
        *(_QWORD *)(a1 + 544) = 0;
        *(_DWORD *)(a1 + 536) = 17;
        v21 = "Unable to send channel request";
        v22 = v6;
        v19 = v16;
        return _libssh2_error(v22, v19, v21);
      }
      v17 = 4294967259;
      _libssh2_error(v6, 4294967259, "Would block sending channel request");
      return v17;
    }
    (*(void (**)(_QWORD, uint64_t))(v6 + 24))(*(_QWORD *)(a1 + 544), v6);
    *(_QWORD *)(a1 + 544) = 0;
    _libssh2_htonu32((_DWORD *)(a1 + 560), *(_DWORD *)(a1 + 48));
    *(_DWORD *)(a1 + 536) = 3;
LABEL_18:
    v23 = 0;
    v24 = 0;
    v18 = _libssh2_packet_requirev(v6, "cd", &v24, &v23, 1, (const void *)(a1 + 560), 4uLL, (time_t *)(a1 + 568));
    if ((_DWORD)v18 == -37)
      return 4294967259;
    v19 = v18;
    if ((_DWORD)v18 || !v23)
    {
      *(_DWORD *)(a1 + 536) = 17;
      v21 = "Failed waiting for channel success";
      v22 = v6;
      return _libssh2_error(v22, v19, v21);
    }
    v20 = *v24;
    (*(void (**)(void))(v6 + 24))();
    *(_DWORD *)(a1 + 536) = 17;
    if (v20 != 99)
      goto LABEL_24;
    return 0;
  }
  return _libssh2_error(v6, 4294967290, "Unable to allocate memory for channel-process request");
}

uint64_t libssh2_channel_process_startup(uint64_t a1, const void *a2, unsigned int a3, const void *a4, unsigned int a5)
{
  time_t v10;
  uint64_t result;
  uint64_t v12;

  if (!a1)
    return 4294967257;
  v10 = time(0);
  do
  {
    result = _libssh2_channel_process_startup(a1, a2, a3, a4, a5);
    if ((_DWORD)result != -37)
      break;
    v12 = *(_QWORD *)(a1 + 104);
    if (!*(_DWORD *)(v12 + 172))
      return 4294967259;
    result = _libssh2_wait_socket(v12, v10);
  }
  while (!(_DWORD)result);
  return result;
}

uint64_t libssh2_channel_set_blocking(uint64_t result, int a2)
{
  if (result)
    return _libssh2_session_set_blocking(*(_QWORD *)(result + 104), a2);
  return result;
}

uint64_t _libssh2_channel_flush(uint64_t a1, int a2)
{
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  unsigned __int8 *v7;
  int v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t result;
  uint64_t v14;

  if (!*(_DWORD *)(a1 + 576))
  {
    v4 = _libssh2_list_first(*(_QWORD *)(a1 + 104) + 536);
    *(_OWORD *)(a1 + 584) = 0u;
    if (v4)
    {
      v5 = (uint64_t *)v4;
      do
      {
        v6 = _libssh2_list_next((uint64_t)v5);
        if ((unint64_t)v5[4] <= 4)
          goto LABEL_13;
        v7 = (unsigned __int8 *)v5[3];
        v8 = *v7;
        if ((v8 & 0xFE) != 0x5E || _libssh2_ntohu32((unsigned int *)(v7 + 1)) != *(_DWORD *)(a1 + 48))
          goto LABEL_13;
        if (v8 == 94)
        {
          v9 = 0;
        }
        else
        {
          if ((unint64_t)v5[4] < 9)
          {
            *(_DWORD *)(a1 + 576) = 0;
            return _libssh2_error(*(_QWORD *)(a1 + 104), 4294967282, "Unexpected packet length");
          }
          v9 = _libssh2_ntohu32((unsigned int *)(v5[3] + 5));
        }
        if (a2 != -2)
        {
          if (v8 == 95)
          {
            if (a2 != -1 && v9 != a2)
              goto LABEL_13;
          }
          else if (a2 || v8 != 94)
          {
            goto LABEL_13;
          }
        }
        v10 = v5[4];
        v11 = v5[3];
        v12 = v10 - v5[5];
        *(_QWORD *)(a1 + 584) = v10 + *(_QWORD *)(a1 + 584) - 13;
        *(_QWORD *)(a1 + 592) += v12;
        (*(void (**)(uint64_t))(*(_QWORD *)(a1 + 104) + 24))(v11);
        _libssh2_list_remove(v5);
        (*(void (**)(uint64_t *))(*(_QWORD *)(a1 + 104) + 24))(v5);
LABEL_13:
        v5 = (uint64_t *)v6;
      }
      while (v6);
    }
    *(_DWORD *)(a1 + 576) = 2;
  }
  result = *(_QWORD *)(a1 + 592);
  *(_QWORD *)(a1 + 96) -= result;
  *(_DWORD *)(a1 + 76) -= result;
  v14 = *(_QWORD *)(a1 + 584);
  if (v14)
  {
    if (_libssh2_channel_receive_window_adjust(a1, v14, 1, 0) == -37)
      return 4294967259;
    result = *(unsigned int *)(a1 + 592);
  }
  *(_DWORD *)(a1 + 576) = 0;
  return result;
}

uint64_t _libssh2_channel_receive_window_adjust(uint64_t a1, unsigned int a2, int a3, _DWORD *a4)
{
  unsigned int v4;
  int v6;
  uint64_t v7;
  unsigned int v8;
  int v9;

  v4 = a2;
  if (a4)
    *a4 = *(_DWORD *)(a1 + 76);
  if (!*(_DWORD *)(a1 + 600))
  {
    if (!a3)
    {
      v8 = *(_DWORD *)(a1 + 88) + a2;
      if (v8 <= 0x3FF)
      {
        v7 = 0;
        *(_DWORD *)(a1 + 88) = v8;
        return v7;
      }
    }
    v9 = *(_DWORD *)(a1 + 88);
    if (!(a2 | v9))
      return 0;
    v4 = v9 + a2;
    *(_DWORD *)(a1 + 88) = 0;
    *(_BYTE *)(a1 + 604) = 93;
    _libssh2_htonu32((_DWORD *)(a1 + 605), *(_DWORD *)(a1 + 68));
    _libssh2_htonu32((_DWORD *)(a1 + 609), v4);
    *(_DWORD *)(a1 + 600) = 2;
  }
  v6 = _libssh2_transport_send(*(_QWORD *)(a1 + 104), (void *)(a1 + 604), 9uLL, 0, 0);
  if (!v6)
  {
    v7 = 0;
    *(_DWORD *)(a1 + 76) += v4;
    *(_DWORD *)(a1 + 600) = 0;
    return v7;
  }
  if (v6 == -37)
  {
    v7 = 4294967259;
    _libssh2_error(*(_QWORD *)(a1 + 104), 4294967259, "Would block sending window adjust");
    return v7;
  }
  *(_DWORD *)(a1 + 88) = v4;
  return _libssh2_error(*(_QWORD *)(a1 + 104), 4294967289, "Unable to send transfer-window adjustment packet, deferring");
}

uint64_t libssh2_channel_flush_ex(uint64_t a1, int a2)
{
  time_t v4;
  uint64_t result;
  uint64_t v6;

  if (!a1)
    return 4294967257;
  v4 = time(0);
  do
  {
    result = _libssh2_channel_flush(a1, a2);
    if ((_DWORD)result != -37)
      break;
    v6 = *(_QWORD *)(a1 + 104);
    if (!*(_DWORD *)(v6 + 172))
      return 4294967259;
    result = _libssh2_wait_socket(v6, v4);
  }
  while (!(_DWORD)result);
  return result;
}

uint64_t libssh2_channel_get_exit_status(uint64_t result)
{
  if (result)
    return *(unsigned int *)(result + 36);
  return result;
}

uint64_t libssh2_channel_get_exit_signal(uint64_t a1, _QWORD *a2, size_t *a3, _QWORD *a4, _QWORD *a5, _QWORD *a6, _QWORD *a7)
{
  const char *v14;
  uint64_t v15;
  size_t v16;
  size_t v17;
  void *v18;

  if (!a1)
    return 0;
  v14 = *(const char **)(a1 + 40);
  if (!v14)
  {
    if (a2)
      *a2 = 0;
    if (!a3)
      goto LABEL_13;
    v17 = 0;
LABEL_12:
    *a3 = v17;
LABEL_13:
    if (a4)
      *a4 = 0;
    if (a5)
      *a5 = 0;
    if (a6)
      *a6 = 0;
    if (a7)
      *a7 = 0;
    return 0;
  }
  v15 = *(_QWORD *)(a1 + 104);
  v16 = strlen(v14);
  v17 = v16;
  if (!a2)
  {
LABEL_6:
    if (!a3)
      goto LABEL_13;
    goto LABEL_12;
  }
  v18 = (void *)(*(uint64_t (**)(size_t, uint64_t))(v15 + 8))(v16 + 1, v15);
  *a2 = v18;
  if (v18)
  {
    memcpy(v18, *(const void **)(a1 + 40), v17);
    *(_BYTE *)(*a2 + v17) = 0;
    goto LABEL_6;
  }
  return _libssh2_error(v15, 4294967290, "Unable to allocate memory for signal name");
}

uint64_t libssh2_channel_receive_window_adjust(uint64_t a1, unsigned int a2, int a3)
{
  time_t v6;
  uint64_t result;
  uint64_t v8;
  unsigned int v9;

  if (!a1)
    return -39;
  v9 = 0;
  v6 = time(0);
  while (1)
  {
    LODWORD(result) = _libssh2_channel_receive_window_adjust(a1, a2, a3, &v9);
    if ((_DWORD)result != -37)
      break;
    v8 = *(_QWORD *)(a1 + 104);
    if (!*(_DWORD *)(v8 + 172))
    {
      LODWORD(result) = -37;
      return (int)result;
    }
    LODWORD(result) = _libssh2_wait_socket(v8, v6);
    if ((_DWORD)result)
      return (int)result;
  }
  if ((_DWORD)result)
    return (int)result;
  else
    return v9;
}

uint64_t libssh2_channel_receive_window_adjust2(uint64_t a1, unsigned int a2, int a3, _DWORD *a4)
{
  time_t v8;
  uint64_t result;
  uint64_t v10;

  if (!a1)
    return 4294967257;
  v8 = time(0);
  do
  {
    result = _libssh2_channel_receive_window_adjust(a1, a2, a3, a4);
    if ((_DWORD)result != -37)
      break;
    v10 = *(_QWORD *)(a1 + 104);
    if (!*(_DWORD *)(v10 + 172))
      return 4294967259;
    result = _libssh2_wait_socket(v10, v8);
  }
  while (!(_DWORD)result);
  return result;
}

uint64_t _libssh2_channel_extended_data(uint64_t a1, char a2)
{
  if (!*(_DWORD *)(a1 + 688))
    *(_BYTE *)(a1 + 86) = a2;
  *(_DWORD *)(a1 + 688) = 0;
  return 0;
}

uint64_t libssh2_channel_handle_extended_data2(uint64_t a1, char a2)
{
  uint64_t result;

  if (!a1)
    return 4294967257;
  time(0);
  if (!*(_DWORD *)(a1 + 688))
    *(_BYTE *)(a1 + 86) = a2;
  result = 0;
  *(_DWORD *)(a1 + 688) = 0;
  return result;
}

time_t libssh2_channel_handle_extended_data(time_t result, char a2)
{
  time_t v3;

  if (result)
  {
    v3 = result;
    result = time(0);
    if (!*(_DWORD *)(v3 + 688))
      *(_BYTE *)(v3 + 86) = a2;
    *(_DWORD *)(v3 + 688) = 0;
  }
  return result;
}

unint64_t _libssh2_channel_read(uint64_t a1, int a2, uint64_t a3, unint64_t a4)
{
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unsigned int v11;
  unsigned int v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t *v17;
  unint64_t v18;
  uint64_t v19;
  int v20;
  unsigned __int8 *v21;
  int v22;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t v26;
  size_t v27;
  char *v28;
  uint64_t v29;
  uint64_t v30;
  int v32;
  uint64_t v33;

  v8 = *(_QWORD *)(a1 + 104);
  if (*(_DWORD *)(a1 + 616) == 11)
  {
    LODWORD(v10) = *(_DWORD *)(a1 + 72);
    LODWORD(v9) = *(_DWORD *)(a1 + 76);
LABEL_4:
    v11 = v10 + a4 - v9;
    if (v11 <= 0x400)
      v12 = 1024;
    else
      v12 = v11;
    *(_DWORD *)(a1 + 616) = 11;
    v13 = _libssh2_channel_receive_window_adjust(a1, v12, 0, 0);
    if (v13)
      return v13;
    *(_DWORD *)(a1 + 616) = 0;
    goto LABEL_9;
  }
  v10 = *(unsigned int *)(a1 + 72);
  v9 = *(unsigned int *)(a1 + 76);
  if (3 * (v10 >> 2) + a4 > v9)
    goto LABEL_4;
  do
LABEL_9:
    v14 = _libssh2_transport_read(v8);
  while ((int)v14 > 0);
  v15 = v14;
  if ((_DWORD)v14 != -37 && (_DWORD)v14)
  {
    v28 = "transport read";
    v29 = v8;
    v30 = v15;
    return (int)_libssh2_error(v29, v30, v28);
  }
  v16 = _libssh2_list_first(v8 + 536);
  if (!v16 || !a4)
    goto LABEL_38;
  v17 = (uint64_t *)v16;
  v33 = a3;
  v18 = 0;
  v32 = a2;
  do
  {
    v19 = _libssh2_list_next((uint64_t)v17);
    if ((unint64_t)v17[4] < 5)
      goto LABEL_34;
    v20 = _libssh2_ntohu32((unsigned int *)(v17[3] + 1));
    *(_DWORD *)(a1 + 620) = v20;
    v21 = (unsigned __int8 *)v17[3];
    v22 = *v21;
    if (a2)
    {
      if (v22 != 95
        || *(_DWORD *)(a1 + 48) != v20
        || (unint64_t)v17[4] < 9
        || _libssh2_ntohu32((unsigned int *)(v21 + 5)) != a2)
      {
        goto LABEL_34;
      }
      v21 = (unsigned __int8 *)v17[3];
    }
    else if (v22 == 95)
    {
      if (*(_DWORD *)(a1 + 48) != v20 || *(_BYTE *)(a1 + 86) != 2)
        goto LABEL_34;
    }
    else if (v22 != 94 || *(_DWORD *)(a1 + 48) != v20)
    {
      goto LABEL_34;
    }
    v23 = a4 - v18;
    v24 = v17[4];
    v25 = v17[5];
    v26 = v24 - v25;
    if (a4 - v18 >= v24 - v25)
      v27 = v24 - v25;
    else
      v27 = a4 - v18;
    memcpy((void *)(v33 + v18), &v21[v25], v27);
    v17[5] += v27;
    v18 += v27;
    if (v23 >= v26)
    {
      _libssh2_list_remove(v17);
      (*(void (**)(uint64_t, uint64_t))(v8 + 24))(v17[3], v8);
      (*(void (**)(uint64_t *, uint64_t))(v8 + 24))(v17, v8);
    }
    a2 = v32;
LABEL_34:
    if (!v19)
      break;
    v17 = (uint64_t *)v19;
  }
  while (v18 < a4);
  if (v18)
  {
    *(_QWORD *)(a1 + 96) -= v18;
    *(_DWORD *)(a1 + 76) -= v18;
    return v18;
  }
LABEL_38:
  if (*(_BYTE *)(a1 + 85))
    return 0;
  v18 = 0;
  if ((_DWORD)v15 == -37 && !*(_BYTE *)(a1 + 84))
  {
    v28 = "would block";
    v29 = v8;
    v30 = 4294967259;
    return (int)_libssh2_error(v29, v30, v28);
  }
  return v18;
}

unint64_t libssh2_channel_read_ex(uint64_t a1, int a2, uint64_t a3, unint64_t a4)
{
  time_t v8;
  uint64_t v9;
  time_t v10;
  unint64_t result;
  uint64_t v12;

  if (!a1)
    return -39;
  if (*(unsigned int *)(a1 + 76) < a4)
  {
    v8 = time(0);
    do
    {
      if (_libssh2_channel_receive_window_adjust(a1, a4, 1, 0) != -37)
        break;
      v9 = *(_QWORD *)(a1 + 104);
      if (!*(_DWORD *)(v9 + 172))
        break;
    }
    while (!_libssh2_wait_socket(v9, v8));
  }
  v10 = time(0);
  while (1)
  {
    result = _libssh2_channel_read(a1, a2, a3, a4);
    if (result != -37)
      break;
    v12 = *(_QWORD *)(a1 + 104);
    if (!*(_DWORD *)(v12 + 172))
      return -37;
    LODWORD(result) = _libssh2_wait_socket(v12, v10);
    if ((_DWORD)result)
      return (int)result;
  }
  return result;
}

uint64_t libssh2_channel_window_read_ex(uint64_t result, uint64_t *a2, _QWORD *a3)
{
  uint64_t v4;
  uint64_t v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (result)
  {
    v4 = result;
    if (a3)
      *a3 = *(unsigned int *)(result + 72);
    if (a2)
    {
      v5 = _libssh2_list_first(*(_QWORD *)(result + 104) + 536);
      if (v5)
      {
        v6 = (_QWORD *)v5;
        v7 = 0;
        do
        {
          v8 = _libssh2_list_next((uint64_t)v6);
          if (v6[4] > 4uLL)
          {
            v9 = v6[3];
            if ((*(_BYTE *)v9 & 0xFE) == 0x5E
              && _libssh2_ntohu32((unsigned int *)(v9 + 1)) == *(_DWORD *)(v4 + 48))
            {
              v7 = v6[4] + v7 - v6[5];
            }
          }
          v6 = (_QWORD *)v8;
        }
        while (v8);
      }
      else
      {
        v7 = 0;
      }
      *a2 = v7;
    }
    return *(unsigned int *)(v4 + 76);
  }
  return result;
}

uint64_t _libssh2_channel_packet_data_len(uint64_t a1, int a2)
{
  uint64_t result;
  _QWORD *v5;
  uint64_t v6;
  int v7;
  unsigned __int8 *v8;
  int v9;

  result = _libssh2_list_first(*(_QWORD *)(a1 + 104) + 536);
  if (result)
  {
    v5 = (_QWORD *)result;
    while (1)
    {
      v6 = _libssh2_list_next((uint64_t)v5);
      if (v5[4] >= 5uLL)
      {
        v7 = _libssh2_ntohu32((unsigned int *)(v5[3] + 1));
        v8 = (unsigned __int8 *)v5[3];
        v9 = *v8;
        if (a2)
        {
          if (v9 == 95
            && *(_DWORD *)(a1 + 48) == v7
            && v5[4] >= 9uLL
            && _libssh2_ntohu32((unsigned int *)(v8 + 5)) == a2)
          {
            return v5[4] - v5[5];
          }
        }
        else if (v9 == 95)
        {
          if (*(_DWORD *)(a1 + 48) == v7 && *(_BYTE *)(a1 + 86) == 2)
            return v5[4] - v5[5];
        }
        else if (v9 == 94 && *(_DWORD *)(a1 + 48) == v7)
        {
          return v5[4] - v5[5];
        }
      }
      v5 = (_QWORD *)v6;
      if (!v6)
        return 0;
    }
  }
  return result;
}

uint64_t _libssh2_channel_write(uint64_t a1, unsigned int a2, const void *a3, unint64_t a4)
{
  uint64_t v6;
  uint64_t v7;
  int v8;
  char *v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  uint64_t result;
  uint64_t v16;
  uint64_t v17;
  char v18;
  unint64_t v19;
  unint64_t v20;
  unint64_t v21;
  _DWORD *v22;

  v6 = *(_QWORD *)(a1 + 104);
  if (a4 >= 0x7FBC)
    v7 = 32700;
  else
    v7 = a4;
  v8 = *(_DWORD *)(a1 + 624);
  if (v8)
  {
    if (v8 != 2)
      return -34;
    v9 = *(char **)(a1 + 648);
    goto LABEL_7;
  }
  if (*(_BYTE *)(a1 + 64))
  {
    v12 = "We have already closed this channel";
    v13 = *(_QWORD *)(a1 + 104);
    v11 = 4294967270;
    return (int)_libssh2_error(v13, v11, v12);
  }
  if (*(_BYTE *)(a1 + 65))
  {
    v12 = "EOF has already been received, data might be ignored";
    v13 = *(_QWORD *)(a1 + 104);
    v11 = 4294967269;
    return (int)_libssh2_error(v13, v11, v12);
  }
  v16 = a1 + 628;
  do
    v17 = _libssh2_transport_read(v6);
  while ((int)v17 > 0);
  v11 = v17;
  if ((_DWORD)v17 != -37 && (_DWORD)v17)
  {
    v13 = *(_QWORD *)(a1 + 104);
    v12 = "Failure while draining incoming flow";
    return (int)_libssh2_error(v13, v11, v12);
  }
  if (*(_DWORD *)(a1 + 56))
  {
    *(_QWORD *)(a1 + 656) = v7;
    if (a2)
      v18 = 95;
    else
      v18 = 94;
    *(_BYTE *)(a1 + 628) = v18;
    v22 = (_DWORD *)(a1 + 629);
    _libssh2_store_u32(&v22, *(_DWORD *)(a1 + 68));
    if (a2)
      _libssh2_store_u32(&v22, a2);
    v19 = *(_QWORD *)(a1 + 656);
    v20 = *(unsigned int *)(a1 + 56);
    if (v19 > v20)
    {
      *(_QWORD *)(a1 + 656) = v20;
      v19 = v20;
    }
    v21 = *(unsigned int *)(a1 + 60);
    if (v19 > v21)
    {
      *(_QWORD *)(a1 + 656) = v21;
      LODWORD(v19) = v21;
    }
    _libssh2_store_u32(&v22, v19);
    v9 = (char *)v22 - v16;
    *(_QWORD *)(a1 + 648) = (char *)v22 - v16;
    *(_DWORD *)(a1 + 624) = 2;
LABEL_7:
    v10 = _libssh2_transport_send(v6, (void *)(a1 + 628), (size_t)v9, a3, *(_QWORD *)(a1 + 656));
    if (!(_DWORD)v10)
    {
      result = *(_QWORD *)(a1 + 656);
      *(_DWORD *)(a1 + 56) -= result;
      *(_DWORD *)(a1 + 624) = 0;
      return result;
    }
    v11 = v10;
    if ((_DWORD)v10 != -37)
      *(_DWORD *)(a1 + 624) = 0;
    v12 = "Unable to send channel data";
    v13 = v6;
    return (int)_libssh2_error(v13, v11, v12);
  }
  *(_DWORD *)(v6 + 600) = 1;
  if ((_DWORD)v17 == -37)
    return -37;
  else
    return 0;
}

uint64_t libssh2_channel_write_ex(uint64_t a1, unsigned int a2, const void *a3, unint64_t a4)
{
  time_t v8;
  uint64_t result;
  uint64_t v10;

  if (!a1)
    return -39;
  v8 = time(0);
  while (1)
  {
    result = _libssh2_channel_write(a1, a2, a3, a4);
    if (result != -37)
      break;
    v10 = *(_QWORD *)(a1 + 104);
    if (!*(_DWORD *)(v10 + 172))
      return -37;
    LODWORD(result) = _libssh2_wait_socket(v10, v8);
    if ((_DWORD)result)
      return (int)result;
  }
  return result;
}

uint64_t libssh2_channel_send_eof(uint64_t a1)
{
  time_t v2;
  uint64_t result;
  uint64_t v4;

  if (!a1)
    return 4294967257;
  v2 = time(0);
  do
  {
    result = channel_send_eof(a1);
    if ((_DWORD)result != -37)
      break;
    v4 = *(_QWORD *)(a1 + 104);
    if (!*(_DWORD *)(v4 + 172))
      return 4294967259;
    result = _libssh2_wait_socket(v4, v2);
  }
  while (!(_DWORD)result);
  return result;
}

uint64_t channel_send_eof(uint64_t a1)
{
  uint64_t v2;
  int v3;
  uint64_t v4;
  char __src;
  int v7;

  v2 = *(_QWORD *)(a1 + 104);
  __src = 96;
  _libssh2_htonu32(&v7, *(_DWORD *)(a1 + 68));
  v3 = _libssh2_transport_send(v2, &__src, 5uLL, 0, 0);
  if (v3)
  {
    if (v3 == -37)
    {
      v4 = 4294967259;
      _libssh2_error(v2, 4294967259, "Would block sending EOF");
    }
    else
    {
      return _libssh2_error(v2, 4294967289, "Unable to send EOF on channel");
    }
  }
  else
  {
    v4 = 0;
    *(_BYTE *)(a1 + 65) = 1;
  }
  return v4;
}

uint64_t libssh2_channel_eof(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  int v6;

  if (!a1)
    return 4294967257;
  v2 = _libssh2_list_first(*(_QWORD *)(a1 + 104) + 536);
  if (!v2)
    return *(char *)(a1 + 85);
  v3 = v2;
  while (1)
  {
    v4 = _libssh2_list_next(v3);
    if (*(_QWORD *)(v3 + 32) > 4uLL)
    {
      v5 = *(_QWORD *)(v3 + 24);
      if ((*(_BYTE *)v5 & 0xFE) == 0x5E)
      {
        v6 = *(_DWORD *)(a1 + 48);
        if (v6 == _libssh2_ntohu32((unsigned int *)(v5 + 1)))
          break;
      }
    }
    v3 = v4;
    if (!v4)
      return *(char *)(a1 + 85);
  }
  return 0;
}

uint64_t libssh2_channel_wait_eof(uint64_t a1)
{
  time_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  char *v7;
  uint64_t result;
  uint64_t v9;

  if (!a1)
    return 4294967257;
  v2 = time(0);
  while (2)
  {
    if (!*(_DWORD *)(a1 + 676))
      *(_DWORD *)(a1 + 676) = 2;
    v3 = *(_QWORD *)(a1 + 104);
    while (1)
    {
      if (*(_BYTE *)(a1 + 85))
      {
        result = 0;
        *(_DWORD *)(a1 + 676) = 0;
        return result;
      }
      if (*(_QWORD *)(a1 + 96) == *(_DWORD *)(a1 + 76) && *(_DWORD *)(v3 + 172))
        break;
      v4 = _libssh2_transport_read(v3);
      if ((_DWORD)v4 == -37)
        goto LABEL_14;
      v5 = v4;
      if ((v4 & 0x80000000) != 0)
      {
        *(_DWORD *)(a1 + 676) = 0;
        v6 = v3;
        v7 = "_libssh2_transport_read() bailed out!";
        goto LABEL_13;
      }
    }
    v6 = v3;
    v5 = 4294967249;
    v7 = "Receiving channel window has been exhausted";
LABEL_13:
    result = _libssh2_error(v6, v5, v7);
    if ((_DWORD)result != -37)
      return result;
LABEL_14:
    v9 = *(_QWORD *)(a1 + 104);
    if (!*(_DWORD *)(v9 + 172))
      return 4294967259;
    result = _libssh2_wait_socket(v9, v2);
    if (!(_DWORD)result)
      continue;
    return result;
  }
}

uint64_t _libssh2_channel_close(uint64_t a1)
{
  uint64_t v2;
  uint64_t v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  BOOL v9;
  void (*v10)(uint64_t, uint64_t, uint64_t, uint64_t);

  if (*(_BYTE *)(a1 + 64))
  {
    v2 = 0;
    *(_DWORD *)(a1 + 664) = 0;
    return v2;
  }
  v4 = *(_QWORD *)(a1 + 104);
  if (*(_BYTE *)(a1 + 65))
  {
    LODWORD(v2) = 0;
  }
  else
  {
    v7 = channel_send_eof(a1);
    v2 = v7;
    if ((_DWORD)v7 == -37)
      return v2;
    if ((_DWORD)v7)
      _libssh2_error(v4, v7, "Unable to send EOF, but closing channel anyway");
  }
  v5 = *(_DWORD *)(a1 + 664);
  if (v5 != 2)
  {
    if (v5)
      goto LABEL_17;
    *(_BYTE *)(a1 + 668) = 97;
    _libssh2_htonu32((_DWORD *)(a1 + 669), *(_DWORD *)(a1 + 68));
    *(_DWORD *)(a1 + 664) = 2;
  }
  v6 = _libssh2_transport_send(v4, (void *)(a1 + 668), 5uLL, 0, 0);
  v2 = v6;
  if ((_DWORD)v6)
  {
    if ((_DWORD)v6 == -37)
    {
      _libssh2_error(v4, 4294967259, "Would block sending close-channel");
      return v2;
    }
    _libssh2_error(v4, v6, "Unable to send close-channel request, but closing anyway");
    v5 = *(_DWORD *)(a1 + 664);
LABEL_17:
    if (v5 != 3)
      goto LABEL_26;
    goto LABEL_18;
  }
  *(_DWORD *)(a1 + 664) = 3;
LABEL_18:
  if (!*(_BYTE *)(a1 + 84) && !(_DWORD)v2)
  {
    while (*(_DWORD *)(v4 + 596) != -1)
    {
      v8 = _libssh2_transport_read(v4);
      if (*(_BYTE *)(a1 + 84))
        v9 = 0;
      else
        v9 = v8 == 0;
      if (!v9)
      {
        LODWORD(v2) = v8;
        goto LABEL_26;
      }
    }
    LODWORD(v2) = 0;
    goto LABEL_29;
  }
LABEL_26:
  if ((_DWORD)v2 != -37)
  {
LABEL_29:
    *(_BYTE *)(a1 + 64) = 1;
    v10 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a1 + 120);
    if (v10)
      v10(v4, v4, a1, a1 + 112);
    *(_DWORD *)(a1 + 664) = 0;
  }
  return v2 & ((int)v2 >> 31);
}

uint64_t libssh2_channel_close(uint64_t a1)
{
  time_t v2;
  uint64_t result;
  uint64_t v4;

  if (!a1)
    return 4294967257;
  v2 = time(0);
  do
  {
    result = _libssh2_channel_close(a1);
    if ((_DWORD)result != -37)
      break;
    v4 = *(_QWORD *)(a1 + 104);
    if (!*(_DWORD *)(v4 + 172))
      return 4294967259;
    result = _libssh2_wait_socket(v4, v2);
  }
  while (!(_DWORD)result);
  return result;
}

uint64_t libssh2_channel_wait_closed(uint64_t a1)
{
  time_t v2;
  uint64_t v3;
  uint64_t result;
  BOOL v5;
  uint64_t v6;

  if (!a1)
    return 4294967257;
  v2 = time(0);
  while (1)
  {
    v3 = *(_QWORD *)(a1 + 104);
    if (*(_BYTE *)(a1 + 85))
    {
      if (!*(_DWORD *)(a1 + 680))
        *(_DWORD *)(a1 + 680) = 2;
      if (*(_BYTE *)(a1 + 84))
        goto LABEL_20;
      do
      {
        result = _libssh2_transport_read(v3);
        if (*(_BYTE *)(a1 + 84))
          v5 = 1;
        else
          v5 = (int)result <= 0;
      }
      while (!v5);
      if ((result & 0x80000000) == 0)
      {
LABEL_20:
        result = 0;
        *(_DWORD *)(a1 + 680) = 0;
        return result;
      }
    }
    else
    {
      result = _libssh2_error(*(_QWORD *)(a1 + 104), 4294967262, "libssh2_channel_wait_closed() invoked when channel is not in EOF state");
    }
    if ((_DWORD)result != -37)
      return result;
    v6 = *(_QWORD *)(a1 + 104);
    if (!*(_DWORD *)(v6 + 172))
      return 4294967259;
    result = _libssh2_wait_socket(v6, v2);
    if ((_DWORD)result)
      return result;
  }
}

uint64_t libssh2_channel_free(uint64_t a1)
{
  time_t v2;
  uint64_t result;
  uint64_t v4;

  if (!a1)
    return 4294967257;
  v2 = time(0);
  do
  {
    result = _libssh2_channel_free(a1);
    if ((_DWORD)result != -37)
      break;
    v4 = *(_QWORD *)(a1 + 104);
    if (!*(_DWORD *)(v4 + 172))
      return 4294967259;
    result = _libssh2_wait_socket(v4, v2);
  }
  while (!(_DWORD)result);
  return result;
}

uint64_t libssh2_channel_window_write_ex(uint64_t result, _QWORD *a2)
{
  if (result)
  {
    if (a2)
      *a2 = *(unsigned int *)(result + 52);
    return *(unsigned int *)(result + 56);
  }
  return result;
}

uint64_t libssh2_channel_signal_ex(uint64_t a1, const void *a2, unint64_t a3)
{
  time_t v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  _BYTE *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  uint64_t result;
  uint64_t v17;
  _DWORD *v18;

  if (!a1)
    return 4294967257;
  v6 = time(0);
  while (1)
  {
    v7 = *(_QWORD *)(a1 + 104);
    v8 = *(_DWORD *)(a1 + 760);
    if (v8 == 2)
      break;
    if (v8)
    {
      result = 4294967282;
      goto LABEL_20;
    }
    *(_QWORD *)(a1 + 776) = a3 + 20;
    v9 = (*(uint64_t (**)(unint64_t, uint64_t))(v7 + 8))(a3 + 20, v7);
    *(_QWORD *)(a1 + 768) = v9;
    if (v9)
    {
      v18 = (_DWORD *)(v9 + 1);
      *(_BYTE *)v9 = 98;
      _libssh2_store_u32(&v18, *(_DWORD *)(a1 + 68));
      _libssh2_store_str(&v18, "signal", 6uLL);
      v10 = v18;
      v18 = (_DWORD *)((char *)v18 + 1);
      *v10 = 0;
      _libssh2_store_str(&v18, a2, a3);
      *(_DWORD *)(a1 + 760) = 2;
      break;
    }
    v13 = v7;
    v14 = 4294967290;
    v15 = "Unable to allocate memory for signal request";
LABEL_12:
    result = _libssh2_error(v13, v14, v15);
    if ((_DWORD)result != -37)
      return result;
LABEL_13:
    v17 = *(_QWORD *)(a1 + 104);
    if (!*(_DWORD *)(v17 + 172))
      return 4294967259;
    result = _libssh2_wait_socket(v17, v6);
    if ((_DWORD)result)
      return result;
  }
  v11 = _libssh2_transport_send(v7, *(void **)(a1 + 768), *(_QWORD *)(a1 + 776), 0, 0);
  if ((_DWORD)v11 == -37)
  {
    _libssh2_error(v7, 4294967259, "Would block sending signal request");
    goto LABEL_13;
  }
  v12 = v11;
  if ((_DWORD)v11)
  {
    (*(void (**)(_QWORD, uint64_t))(v7 + 24))(*(_QWORD *)(a1 + 768), v7);
    *(_DWORD *)(a1 + 760) = 0;
    v13 = v7;
    v14 = v12;
    v15 = "Unable to send signal packet";
    goto LABEL_12;
  }
  (*(void (**)(_QWORD, uint64_t))(v7 + 24))(*(_QWORD *)(a1 + 768), v7);
  result = 0;
LABEL_20:
  *(_DWORD *)(a1 + 760) = 0;
  return result;
}

void _libssh2_channel_free_cold_1()
{
  __assert_rtn("_libssh2_channel_free", "channel.c", 2823, "session");
}

uint64_t *libssh2_knownhost_init(uint64_t a1)
{
  uint64_t *v2;
  uint64_t *v3;

  v2 = (uint64_t *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 8))(24, a1);
  v3 = v2;
  if (v2)
  {
    *v2 = a1;
    _libssh2_list_init(v2 + 1);
  }
  else
  {
    _libssh2_error(a1, 4294967290, "Unable to allocate memory for known-hosts collection");
  }
  return v3;
}

uint64_t libssh2_knownhost_add(uint64_t a1, char *a2, char *a3, char *a4, size_t a5, int a6, _QWORD *a7)
{
  return knownhost_add(a1, a2, a3, 0, 0, a4, a5, 0, 0, a6, a7);
}

uint64_t knownhost_add(uint64_t a1, char *__s, char *a3, const void *a4, size_t a5, char *a6, size_t a7, const void *a8, uint64_t a9, int a10, _QWORD *a11)
{
  size_t v17;
  uint64_t v18;
  _DWORD *v19;
  _DWORD *v20;
  void *v21;
  char *v22;
  uint64_t v23;
  uint64_t v25;
  uint64_t v26;
  size_t v27;
  uint64_t v28;
  void *v29;
  void *v30;
  void *v31;
  uint64_t v32;
  char *v33;
  uint64_t v34;
  int v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v40;
  const char *v41;

  v17 = strlen(__s);
  v18 = *(_QWORD *)a1;
  if ((a10 & 0x3C0000) == 0)
  {
    v22 = "No key type set";
    v23 = 4294967262;
    return _libssh2_error(v18, v23, v22);
  }
  v19 = _libssh2_calloc(v18, 0x90uLL);
  if (!v19)
  {
    v18 = *(_QWORD *)a1;
    v22 = "Unable to allocate memory for known host entry";
    v23 = 4294967290;
    return _libssh2_error(v18, v23, v22);
  }
  v20 = v19;
  v40 = 0;
  v41 = 0;
  v19[11] = a10;
  switch((unsigned __int16)a10)
  {
    case 3u:
      goto LABEL_6;
    case 2u:
      v25 = _libssh2_base64_decode(*(_QWORD *)a1, (uint64_t *)&v41, &v40, (unsigned __int8 *)__s, v17);
      if ((_DWORD)v25)
        goto LABEL_40;
      v26 = v40;
      *((_QWORD *)v20 + 3) = v41;
      *((_QWORD *)v20 + 4) = v26;
      v27 = strlen(a3);
      v25 = _libssh2_base64_decode(*(_QWORD *)a1, (uint64_t *)&v41, &v40, (unsigned __int8 *)a3, v27);
      if ((_DWORD)v25)
        goto LABEL_40;
      v28 = v40;
      *((_QWORD *)v20 + 6) = v41;
      *((_QWORD *)v20 + 7) = v28;
      if ((a10 & 0x20000) == 0)
      {
LABEL_8:
        if (!_libssh2_base64_encode(*(_QWORD *)a1, a6, a7, &v41))
        {
          v32 = *(_QWORD *)a1;
          v33 = "Unable to allocate memory for base64-encoded key";
          goto LABEL_38;
        }
        *((_QWORD *)v20 + 8) = v41;
        if (!a4)
          goto LABEL_24;
LABEL_21:
        if ((a10 & 0x3C0000) == 0x3C0000)
        {
          v30 = (void *)(*(uint64_t (**)(size_t))(*(_QWORD *)a1 + 8))(a5 + 1);
          *((_QWORD *)v20 + 9) = v30;
          if (v30)
          {
            memcpy(v30, a4, a5);
            *(_BYTE *)(*((_QWORD *)v20 + 9) + a5) = 0;
            *((_QWORD *)v20 + 10) = a5;
            goto LABEL_24;
          }
          v32 = *(_QWORD *)a1;
          v33 = "Unable to allocate memory for key type";
LABEL_38:
          v34 = 4294967290;
          goto LABEL_39;
        }
LABEL_24:
        if (!a8)
        {
          *((_QWORD *)v20 + 11) = 0;
LABEL_30:
          _libssh2_list_add((_QWORD **)(a1 + 8), v20);
          if (!a11)
            return 0;
          v20[26] = -559035650;
          *((_QWORD *)v20 + 14) = v20;
          v35 = v20[11];
          if ((unsigned __int16)v35 == 1)
            v36 = *((_QWORD *)v20 + 3);
          else
            v36 = 0;
          v25 = 0;
          v37 = *((_QWORD *)v20 + 8);
          *((_QWORD *)v20 + 15) = v36;
          *((_QWORD *)v20 + 16) = v37;
          v20[34] = v35;
          *a11 = v20 + 26;
          return v25;
        }
        v31 = (void *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 8))(a9 + 1);
        *((_QWORD *)v20 + 11) = v31;
        if (v31)
        {
          memcpy(v31, a8, a9 + 1);
          *(_BYTE *)(*((_QWORD *)v20 + 11) + a9) = 0;
          *((_QWORD *)v20 + 12) = a9;
          goto LABEL_30;
        }
        v32 = *(_QWORD *)a1;
        v33 = "Unable to allocate memory for comment";
        goto LABEL_38;
      }
LABEL_17:
      if (!a7)
        a7 = strlen(a6);
      v29 = (void *)(*(uint64_t (**)(size_t))(*(_QWORD *)a1 + 8))(a7 + 1);
      *((_QWORD *)v20 + 8) = v29;
      if (!v29)
      {
        v32 = *(_QWORD *)a1;
        v33 = "Unable to allocate memory for key";
        goto LABEL_38;
      }
      memcpy(v29, a6, a7 + 1);
      *(_BYTE *)(*((_QWORD *)v20 + 8) + a7) = 0;
      if (!a4)
        goto LABEL_24;
      goto LABEL_21;
    case 1u:
LABEL_6:
      v21 = (void *)(*(uint64_t (**)(size_t))(*(_QWORD *)a1 + 8))(v17 + 1);
      *((_QWORD *)v20 + 3) = v21;
      if (!v21)
      {
        v32 = *(_QWORD *)a1;
        v33 = "Unable to allocate memory for host name";
        goto LABEL_38;
      }
      memcpy(v21, __s, v17 + 1);
      *((_QWORD *)v20 + 4) = v17;
      if ((a10 & 0x20000) == 0)
        goto LABEL_8;
      goto LABEL_17;
  }
  v32 = *(_QWORD *)a1;
  v33 = "Unknown host name type";
  v34 = 4294967263;
LABEL_39:
  v25 = _libssh2_error(v32, v34, v33);
LABEL_40:
  free_host(*(_QWORD *)a1, v20);
  return v25;
}

uint64_t libssh2_knownhost_addc(uint64_t a1, char *a2, char *a3, char *a4, size_t a5, const void *a6, uint64_t a7, int a8, _QWORD *a9)
{
  return knownhost_add(a1, a2, a3, 0, 0, a4, a5, a6, a7, a8, a9);
}

uint64_t libssh2_knownhost_check(uint64_t *a1, const char *a2, char *a3, size_t a4, int a5, uint64_t *a6)
{
  return knownhost_check(a1, a2, -1, a3, a4, a5, a6);
}

uint64_t knownhost_check(uint64_t *a1, const char *a2, int a3, char *a4, size_t a5, int a6, uint64_t *a7)
{
  int v7;
  uint64_t v8;
  char *v14;
  int v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  BOOL v22;
  HMAC_CTX *v23;
  HMAC_CTX *v24;
  const void *v25;
  int v26;
  const EVP_MD *v27;
  size_t v28;
  uint64_t *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  int v35;
  const char *v36;
  uint64_t *v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  char *v42;
  uint64_t v43;
  uint64_t *v45;
  uint64_t *v46;
  uint64_t v47;
  char *v49;
  unsigned __int8 md[8];
  uint64_t v51;
  int v52;
  char __str[270];
  uint64_t v54;

  v54 = *MEMORY[0x24BDAC8D0];
  v7 = (unsigned __int16)a6;
  v49 = 0;
  if ((unsigned __int16)a6 == 2)
    return 1;
  if ((a3 & 0x80000000) == 0)
  {
    v14 = __str;
    if (snprintf(__str, 0x10EuLL, "[%s]:%d", a2, a3) >= 0x10E)
    {
      v41 = *a1;
      v42 = "Known-host write buffer too small";
      v43 = 4294967258;
      goto LABEL_55;
    }
    v46 = a7;
    v15 = 2;
    if ((a6 & 0x20000) != 0)
      goto LABEL_10;
LABEL_8:
    if (_libssh2_base64_encode(*a1, a4, a5, (const char **)&v49))
    {
      a4 = v49;
      goto LABEL_10;
    }
    v41 = *a1;
    v42 = "Unable to allocate memory for base64-encoded key";
    v43 = 4294967290;
LABEL_55:
    _libssh2_error(v41, v43, v42);
    return 3;
  }
  v46 = a7;
  v15 = 1;
  v14 = (char *)a2;
  if ((a6 & 0x20000) == 0)
    goto LABEL_8;
LABEL_10:
  v16 = 0;
  v45 = a1;
  v47 = (uint64_t)(a1 + 1);
  v17 = a6 & 0x3C0000;
  do
  {
    v18 = _libssh2_list_first(v47);
    if (v18)
    {
      v19 = v18;
      do
      {
        v20 = *(unsigned __int16 *)(v19 + 44);
        if (v20 == 3)
        {
          if (v7 != 3)
            goto LABEL_41;
        }
        else
        {
          if (v20 == 2)
          {
            if (v7 != 1)
              goto LABEL_41;
            v23 = HMAC_CTX_new();
            if (*(_QWORD *)(v19 + 32) != 20)
              goto LABEL_41;
            v24 = v23;
            v25 = *(const void **)(v19 + 48);
            v26 = *(_DWORD *)(v19 + 56);
            v27 = EVP_sha1();
            HMAC_Init_ex(v24, v25, v26, v27, 0);
            v28 = strlen(v14);
            HMAC_Update(v24, (const unsigned __int8 *)v14, v28);
            HMAC_Final(v24, md, 0);
            HMAC_CTX_free(v24);
            v29 = *(uint64_t **)(v19 + 24);
            v30 = *v29;
            v31 = v29[1];
            v32 = *((unsigned int *)v29 + 4);
            v22 = *(_QWORD *)md == v30 && v51 == v31 && v52 == v32;
            goto LABEL_31;
          }
          if (v20 != 1 || v7 != 1)
            goto LABEL_41;
        }
        v22 = strcmp(v14, *(const char **)(v19 + 24)) == 0;
LABEL_31:
        if (v22)
        {
          v35 = *(_DWORD *)(v19 + 44);
          if (!v17 || v17 != 3932160 && v17 == (v35 & 0x3C0000))
          {
            v36 = *(const char **)(v19 + 64);
            if (!strcmp(a4, v36))
            {
              v37 = v46;
              if (v46)
              {
                *(_DWORD *)(v19 + 104) = -559035650;
                v38 = v19 + 104;
                *(_QWORD *)(v19 + 112) = v19;
                if ((unsigned __int16)v35 == 1)
                  v40 = *(_QWORD *)(v19 + 24);
                else
                  v40 = 0;
                v8 = 0;
                *(_QWORD *)(v19 + 120) = v40;
LABEL_62:
                *(_QWORD *)(v19 + 128) = v36;
                *(_DWORD *)(v19 + 136) = v35;
                *v37 = v38;
              }
              else
              {
                v8 = 0;
              }
              goto LABEL_63;
            }
            if (!v16)
              v16 = v19;
          }
        }
LABEL_41:
        v19 = _libssh2_list_next(v19);
      }
      while (v19);
    }
    v14 = (char *)a2;
    --v15;
  }
  while (v15);
  if (v16)
  {
    v37 = v46;
    if (v46)
    {
      *(_DWORD *)(v16 + 104) = -559035650;
      v38 = v16 + 104;
      *(_QWORD *)(v16 + 112) = v16;
      v35 = *(_DWORD *)(v16 + 44);
      if ((unsigned __int16)v35 == 1)
        v39 = *(_QWORD *)(v16 + 24);
      else
        v39 = 0;
      *(_QWORD *)(v16 + 120) = v39;
      v36 = *(const char **)(v16 + 64);
      v8 = 1;
      v19 = v16;
      goto LABEL_62;
    }
    v8 = 1;
  }
  else
  {
    v8 = 2;
  }
LABEL_63:
  if (v49)
    (*(void (**)(void))(*v45 + 24))();
  return v8;
}

uint64_t libssh2_knownhost_del(uint64_t *a1, uint64_t a2)
{
  uint64_t *v4;

  if (!a2 || *(_DWORD *)a2 != -559035650)
    return _libssh2_error(*a1, 4294967262, "Invalid host information");
  v4 = *(uint64_t **)(a2 + 8);
  _libssh2_list_remove(v4);
  *(_QWORD *)(a2 + 32) = 0;
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  free_host(*a1, v4);
  return 0;
}

uint64_t free_host(uint64_t result, _QWORD *a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  if (a2)
  {
    v3 = result;
    v4 = a2[11];
    if (v4)
      (*(void (**)(uint64_t, uint64_t))(v3 + 24))(v4, v3);
    v5 = a2[9];
    if (v5)
      (*(void (**)(uint64_t, uint64_t))(v3 + 24))(v5, v3);
    v6 = a2[8];
    if (v6)
      (*(void (**)(uint64_t, uint64_t))(v3 + 24))(v6, v3);
    v7 = a2[6];
    if (v7)
      (*(void (**)(uint64_t, uint64_t))(v3 + 24))(v7, v3);
    v8 = a2[3];
    if (v8)
      (*(void (**)(uint64_t, uint64_t))(v3 + 24))(v8, v3);
    return (*(uint64_t (**)(_QWORD *, uint64_t))(v3 + 24))(a2, v3);
  }
  return result;
}

uint64_t libssh2_knownhost_free(uint64_t *a1)
{
  uint64_t v2;
  _QWORD *v3;
  uint64_t v4;

  v2 = _libssh2_list_first((uint64_t)(a1 + 1));
  if (v2)
  {
    v3 = (_QWORD *)v2;
    do
    {
      v4 = _libssh2_list_next((uint64_t)v3);
      free_host(*a1, v3);
      v3 = (_QWORD *)v4;
    }
    while (v4);
  }
  return (*(uint64_t (**)(uint64_t *))(*a1 + 24))(a1);
}

uint64_t libssh2_knownhost_readline(uint64_t *a1, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v4;
  uint64_t i;
  unsigned int v6;
  uint64_t v7;
  char *v8;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  uint64_t v16;

  if (a4 == 1)
  {
    if (a3)
    {
      v4 = 0;
      for (i = a3; ; --i)
      {
        v6 = *(unsigned __int8 *)(a2 + v4);
        if (v6 > 0x23)
          break;
        if (((1 << v6) & 0x100000200) == 0)
        {
          if (((1 << v6) & 0x800000401) != 0)
            return 0;
          break;
        }
        if (a3 == ++v4)
          return 0;
      }
      v10 = 0;
      v11 = a2 + v4;
      while (v6 > 0x20u || ((1 << v6) & 0x100000201) == 0)
      {
        if (~v4 + a3 == v10)
          goto LABEL_23;
        LOBYTE(v6) = *(_BYTE *)(a2 + v10++ + v4 + 1);
      }
      v12 = v4 + v10;
      v13 = v12 + a2;
      v14 = i - v10;
      while (1)
      {
        v15 = *(unsigned __int8 *)(a2 + v12);
        if (v15 != 9 && v15 != 32)
          break;
        if (a3 == ++v12)
          goto LABEL_23;
      }
      if (!*(_BYTE *)(a2 + v12))
      {
LABEL_23:
        v7 = *a1;
        v8 = "Failed to parse known_hosts line";
        return _libssh2_error(v7, 4294967263, v8);
      }
      v16 = 0;
      while (v15 != 10)
      {
        if (~v12 + a3 == v16)
        {
          v15 = *(unsigned __int8 *)(v13 + v14);
          return hostline(a1, v11, v10, (char *)(a2 + v12), a3 - (v15 == 10) - v12);
        }
        v15 = *(unsigned __int8 *)(a2 + v16++ + v12 + 1);
        if (!v15)
          return hostline(a1, v11, v10, (char *)(a2 + v12), a3 - (v15 == 10) - v12);
      }
      return hostline(a1, v11, v10, (char *)(a2 + v12), a3 - (v15 == 10) - v12);
    }
    else
    {
      return 0;
    }
  }
  else
  {
    v7 = *a1;
    v8 = "Unsupported type of known-host information store";
    return _libssh2_error(v7, 4294967263, v8);
  }
}

uint64_t hostline(uint64_t *a1, unint64_t a2, uint64_t a3, char *__s1, unint64_t a5)
{
  uint64_t result;
  size_t v7;
  const char *v8;
  uint64_t v11;
  size_t v12;
  int v13;
  char *v14;
  char *v15;
  unsigned int v16;
  BOOL v17;
  uint64_t v18;
  int v20;
  uint64_t v21;
  char *v22;
  int v23;
  size_t v26;
  uint64_t *v27;
  unint64_t v28;
  unint64_t v29;
  int v30;
  unint64_t v31;
  unint64_t v32;
  unint64_t i;
  uint64_t v34;
  char *v35;
  const char *v36;
  int v37;
  int v38[2];
  char __s[256];
  char v40[32];
  uint64_t v41;

  v41 = *MEMORY[0x24BDAC8D0];
  if (a5 <= 0x13)
    return _libssh2_error(*a1, 4294967263, "Failed to parse known_hosts line (key too short)");
  v7 = a5;
  v8 = __s1;
  if ((*__s1 - 48) >= 0xA)
  {
    v14 = &__s1[a5];
    v15 = __s1;
    while (1)
    {
      v16 = *v15;
      v17 = v16 > 0x20;
      v18 = (1 << v16) & 0x100000201;
      if (!v17 && v18 != 0)
        break;
      ++v15;
      if (!--v7)
        goto LABEL_12;
    }
    v14 = v15;
LABEL_12:
    v12 = v14 - __s1;
    if (!strncmp(__s1, "ssh-dss", v14 - __s1))
    {
      v13 = 786432;
    }
    else if (!strncmp(v8, "ssh-rsa", v14 - v8))
    {
      v13 = 0x80000;
    }
    else if (!strncmp(v8, "ecdsa-sha2-nistp256", v14 - v8))
    {
      v13 = 0x100000;
    }
    else if (!strncmp(v8, "ecdsa-sha2-nistp384", v14 - v8))
    {
      v13 = 1310720;
    }
    else if (!strncmp(v8, "ecdsa-sha2-nistp521", v14 - v8))
    {
      v13 = 1572864;
    }
    else if (!strncmp(v8, "ssh-ed25519", v14 - v8))
    {
      v13 = 1835008;
    }
    else
    {
      v13 = 3932160;
    }
    while (1)
    {
      v20 = *v14;
      if (v20 != 9 && v20 != 32)
        break;
      ++v14;
      --v7;
    }
    if (v7)
    {
      v21 = 0;
      while (v20 > 0x20u || ((1 << v20) & 0x100000201) == 0)
      {
        if (v7 - 1 == v21)
          goto LABEL_34;
        LOBYTE(v20) = v14[++v21];
      }
      v11 = v7 - v21;
      v22 = &v14[v21];
      *(_QWORD *)v38 = &v14[v7];
      do
      {
        v23 = *v22;
        if (v23 != 32 && v23 != 9)
        {
          v7 = v21;
          *(_QWORD *)v38 = v22;
          goto LABEL_43;
        }
        ++v22;
        --v11;
      }
      while (v11);
      v7 = v21;
    }
    else
    {
LABEL_34:
      *(_QWORD *)v38 = 0;
      v11 = 0;
    }
  }
  else
  {
    *(_QWORD *)v38 = 0;
    v11 = 0;
    v12 = 0;
    v13 = 0x40000;
    v14 = __s1;
    v8 = 0;
  }
LABEL_43:
  if ((unint64_t)a3 >= 3 && (*(_WORD *)a2 != 12668 || *(_BYTE *)(a2 + 2) != 124))
  {
    if (a3 >= 1)
    {
      v36 = v8;
      v26 = v12;
      v27 = a1;
      v28 = 0;
      v29 = a2 + a3;
      v30 = v13 | 0x20001;
      do
      {
        v31 = v29 - 1;
        ++v28;
        if (v29 - 1 == a2 || *(_BYTE *)(v29 - 2) == 44)
        {
          if (v28 >= 0xFF)
          {
            v34 = *v27;
LABEL_68:
            v35 = "Failed to parse known_hosts line (unexpected length)";
            return _libssh2_error(v34, 4294967263, v35);
          }
          __memcpy_chk();
          __s[v28] = 0;
          result = knownhost_add((uint64_t)v27, __s, 0, v36, v26, v14, v7, *(const void **)v38, v11, v30, 0);
          if ((_DWORD)result)
            return result;
          if (v31 > a2)
          {
            v28 = 0;
            v31 = v29 - 2;
          }
        }
        v29 = v31;
      }
      while (v31 > a2);
    }
    return 0;
  }
  v32 = 0;
  for (i = a3 - 4; ; --i)
  {
    if (!*(_BYTE *)(a2 + v32 + 3))
      return 0;
    if (*(_BYTE *)(a2 + v32 + 3) == 124)
      break;
    ++v32;
  }
  if (v32 >= 0x1F)
  {
    v34 = *a1;
    v35 = "Failed to parse known_hosts line (unexpectedly long salt)";
    return _libssh2_error(v34, 4294967263, v35);
  }
  v37 = v13;
  __memcpy_chk();
  v40[v32] = 0;
  if (i >= 0xFF)
  {
    v34 = *a1;
    goto LABEL_68;
  }
  __memcpy_chk();
  __s[i] = 0;
  return knownhost_add((uint64_t)a1, __s, v40, v8, v12, v14, v7, *(const void **)v38, v11, v37 | 0x20002u, 0);
}

uint64_t libssh2_knownhost_readfile(uint64_t a1)
{
  uint64_t *v1;
  const char *v2;
  uint64_t *v3;
  int v4;
  FILE *v5;
  FILE *v6;
  uint64_t v7;
  size_t v8;
  uint64_t v9;
  char *v10;
  uint64_t v11;
  char __s[4092];
  uint64_t v14;

  v1 = (uint64_t *)MEMORY[0x24BDAC7A8](a1);
  v3 = v1;
  v14 = *MEMORY[0x24BDAC8D0];
  if (v4 != 1)
  {
    v9 = *v1;
    v10 = "Unsupported type of known-host information store";
    v11 = 4294967263;
    return _libssh2_error(v9, v11, v10);
  }
  v5 = fopen(v2, "r");
  if (!v5)
  {
    v9 = *v3;
    v10 = "Failed to open file";
    v11 = 4294967280;
    return _libssh2_error(v9, v11, v10);
  }
  v6 = v5;
  v7 = 0;
  if (fgets(__s, 4092, v5))
  {
    while (1)
    {
      v8 = strlen(__s);
      if (libssh2_knownhost_readline(v3, (uint64_t)__s, v8, 1))
        break;
      v7 = (v7 + 1);
      if (!fgets(__s, 4092, v6))
        goto LABEL_11;
    }
    v7 = _libssh2_error(*v3, 4294967250, "Failed to parse known hosts file");
  }
LABEL_11:
  fclose(v6);
  return v7;
}

uint64_t libssh2_knownhost_writeline(uint64_t *a1, uint64_t a2, char *a3, size_t a4, _QWORD *a5, int a6)
{
  if (*(_DWORD *)a2 == -559035650)
    return knownhost_writeline(a1, *(_QWORD *)(a2 + 8), a3, a4, a5, a6);
  else
    return _libssh2_error(*a1, 4294967262, "Invalid host information");
}

uint64_t knownhost_writeline(uint64_t *a1, uint64_t a2, char *a3, size_t a4, _QWORD *a5, int a6)
{
  int v8;
  uint64_t v9;
  uint64_t v13;
  char *v14;
  size_t v16;
  uint64_t v17;
  size_t v18;
  uint64_t v19;
  const char *v20;
  uint64_t v21;
  const char *v22;
  unint64_t v23;
  uint64_t v24;
  BOOL v25;
  char *v26;
  uint64_t v27;
  const char *v28;
  const char *v29;

  if (a6 != 1)
  {
    v13 = *a1;
    v14 = "Unsupported type of known-host information store";
    return _libssh2_error(v13, 4294967263, v14);
  }
  v8 = *(_DWORD *)(a2 + 44);
  v9 = ((v8 & 0x3C0000u) - 0x40000) >> 18;
  switch((int)v9)
  {
    case 0:
      goto LABEL_10;
    case 1:
    case 2:
      v9 = 7;
      goto LABEL_10;
    case 3:
    case 4:
    case 5:
      v9 = 19;
      goto LABEL_10;
    case 6:
      v9 = 11;
      goto LABEL_10;
    case 14:
      if (!*(_QWORD *)(a2 + 72))
        goto LABEL_31;
      v9 = *(_QWORD *)(a2 + 80);
LABEL_10:
      v16 = strlen(*(const char **)(a2 + 64));
      if (v9)
        v17 = v9 + 1;
      else
        v17 = 0;
      v18 = v16 + v17;
      v19 = *(_QWORD *)(a2 + 88);
      if (v19)
        v18 += *(_QWORD *)(a2 + 96) + 1;
      if ((unsigned __int16)v8 != 2)
      {
        v23 = v18 + *(_QWORD *)(a2 + 32) + 3;
        if (v23 <= a4)
        {
          if (v9)
            v25 = v19 == 0;
          else
            v25 = 1;
          if (v25)
          {
            if (v19 || v9)
              snprintf(a3, a4, "%s %s %s\n");
            else
              snprintf(a3, a4, "%s %s\n");
          }
          else
          {
            snprintf(a3, a4, "%s %s %s %s\n");
          }
        }
        goto LABEL_41;
      }
      v28 = 0;
      v29 = 0;
      v20 = _libssh2_base64_encode(*a1, *(char **)(a2 + 24), *(_QWORD *)(a2 + 32), &v29);
      v21 = *a1;
      if (!v20)
      {
        v26 = "Unable to allocate memory for base64-encoded host name";
LABEL_33:
        v27 = 4294967290;
        return _libssh2_error(v21, v27, v26);
      }
      v22 = _libssh2_base64_encode(v21, *(char **)(a2 + 48), *(_QWORD *)(a2 + 56), &v28);
      if (!v22)
      {
        (*(void (**)(const char *))(*a1 + 24))(v29);
        v21 = *a1;
        v26 = "Unable to allocate memory for base64-encoded salt";
        goto LABEL_33;
      }
      v23 = (unint64_t)&v20[v18 + 7 + (_QWORD)v22];
      if (v23 <= a4)
      {
        v24 = *(_QWORD *)(a2 + 88);
        if (v9 && v24)
        {
          snprintf(a3, a4, "|1|%s|%s %s %s %s\n");
        }
        else if (v24 || v9)
        {
          snprintf(a3, a4, "|1|%s|%s %s %s\n");
        }
        else
        {
          snprintf(a3, a4, "|1|%s|%s %s\n");
        }
      }
      (*(void (**)(const char *))(*a1 + 24))(v29);
      (*(void (**)(const char *))(*a1 + 24))(v28);
LABEL_41:
      *a5 = v23 - 1;
      if (v23 > a4)
      {
        v21 = *a1;
        v26 = "Known-host write buffer too small";
        v27 = 4294967258;
        return _libssh2_error(v21, v27, v26);
      }
      return 0;
    default:
LABEL_31:
      v13 = *a1;
      v14 = "Unsupported type of known-host entry";
      return _libssh2_error(v13, 4294967263, v14);
  }
}

uint64_t libssh2_knownhost_writefile(uint64_t a1)
{
  uint64_t *v1;
  const char *v2;
  uint64_t *v3;
  int v4;
  FILE *v5;
  FILE *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  size_t v10;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  size_t __nitems;
  char __ptr[4092];
  uint64_t v18;

  v1 = (uint64_t *)MEMORY[0x24BDAC7A8](a1);
  v3 = v1;
  v18 = *MEMORY[0x24BDAC8D0];
  if (v4 != 1)
  {
    v12 = *v1;
    v13 = "Unsupported type of known-host information store";
    v14 = 4294967263;
    return _libssh2_error(v12, v14, v13);
  }
  v5 = fopen(v2, "w");
  if (!v5)
  {
    v12 = *v3;
    v13 = "Failed to open file";
    v14 = 4294967280;
    return _libssh2_error(v12, v14, v13);
  }
  v6 = v5;
  v7 = _libssh2_list_first((uint64_t)(v3 + 1));
  if (v7)
  {
    v8 = v7;
    while (1)
    {
      __nitems = 0;
      v9 = knownhost_writeline(v3, v8, __ptr, 0xFFCuLL, &__nitems, 1);
      if ((_DWORD)v9)
        break;
      v10 = __nitems;
      if (fwrite(__ptr, 1uLL, __nitems, v6) != v10)
      {
        v9 = _libssh2_error(*v3, 4294967280, "Write failed");
        break;
      }
      v8 = _libssh2_list_next(v8);
      if (!v8)
        goto LABEL_8;
    }
    v11 = v9;
  }
  else
  {
LABEL_8:
    v11 = 0;
  }
  fclose(v6);
  return v11;
}

uint64_t libssh2_knownhost_get(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  uint64_t v4;
  uint64_t v5;
  int v6;
  uint64_t v7;
  uint64_t v8;

  if (a3 && *(_QWORD *)(a3 + 8))
  {
    v4 = _libssh2_list_next(*(_QWORD *)(a3 + 8));
    if (!v4)
      return 1;
  }
  else
  {
    v4 = _libssh2_list_first(a1 + 8);
    if (!v4)
      return 1;
  }
  *(_DWORD *)(v4 + 104) = -559035650;
  *(_QWORD *)(v4 + 112) = v4;
  v6 = *(_DWORD *)(v4 + 44);
  if ((unsigned __int16)v6 == 1)
    v7 = *(_QWORD *)(v4 + 24);
  else
    v7 = 0;
  v5 = 0;
  v8 = *(_QWORD *)(v4 + 64);
  *(_QWORD *)(v4 + 120) = v7;
  *(_QWORD *)(v4 + 128) = v8;
  *(_DWORD *)(v4 + 136) = v6;
  *a2 = v4 + 104;
  return v5;
}

uint64_t _libssh2_pem_parse(uint64_t a1, const char *a2, const char *a3, const char *a4, uint64_t a5, uint64_t *a6, rsize_t *a7)
{
  uint64_t v13;
  BOOL v15;
  BOOL v16;
  unsigned __int8 *v17;
  rsize_t v18;
  size_t v19;
  size_t v20;
  rsize_t v21;
  uint64_t v22;
  unsigned __int8 *v23;
  char ***v24;
  char **v25;
  char ***v26;
  char *v27;
  size_t v28;
  char **v29;
  uint64_t v30;
  char *v31;
  int v32;
  char v33;
  char v34;
  int v35;
  char v36;
  char **v37;
  unint64_t v38;
  size_t v39;
  size_t v40;
  rsize_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  size_t v45;
  uint64_t *v46;
  char **v47;
  EVP_MD_CTX *ctx;
  uint64_t v49;
  uint64_t v50;
  unsigned __int8 md[16];
  unsigned __int8 v52[16];
  char d;
  _BYTE v54[7];
  char __s1[8];
  _QWORD v56[17];

  v56[15] = *MEMORY[0x24BDAC8D0];
  do
  {
    __s1[0] = 0;
    if (readline(__s1))
      return 0xFFFFFFFFLL;
  }
  while (strcmp(__s1, a2));
  if (readline(__s1))
    return 0xFFFFFFFFLL;
  if (a4
    && (*(_QWORD *)__s1 == 0x7079542D636F7250 ? (v15 = v56[0] == 0x434E452C34203A65) : (v15 = 0),
        v15 ? (v16 = *(_QWORD *)((char *)v56 + 6) == 0x444554505952434ELL) : (v16 = 0),
        v16))
  {
    if (readline(__s1))
      return 0xFFFFFFFFLL;
    v24 = libssh2_crypt_methods();
    v25 = *v24;
    if (!*v24)
      return 0xFFFFFFFFLL;
    v47 = 0;
    v26 = v24 + 1;
    do
    {
      v27 = v25[1];
      if (*v27)
      {
        v28 = strlen(v25[1]);
        if (!memcmp(__s1, v27, v28))
        {
          __memcpy_chk();
          v47 = v25;
        }
      }
      v29 = *v26++;
      v25 = v29;
    }
    while (v29);
    if (!v47)
      return 0xFFFFFFFFLL;
    if (*((int *)v47 + 5) >= 1)
    {
      v30 = 0;
      v31 = v54;
      do
      {
        v32 = *(v31 - 1);
        if (v32 <= 64)
          v33 = 64;
        else
          v33 = 9;
        v34 = v33 + v32;
        v35 = *v31;
        if (v35 <= 64)
          v36 = -48;
        else
          v36 = -55;
        v54[v30++ - 1] = (v36 + v35) | (16 * v34);
        v31 += 2;
      }
      while (v30 < *((int *)v47 + 5));
    }
    if (readline(__s1))
      return 0xFFFFFFFFLL;
  }
  else
  {
    v47 = 0;
  }
  v46 = a6;
  v17 = 0;
  v18 = 0;
  do
  {
    if (__s1[0])
    {
      v19 = strlen(__s1);
      v20 = v19;
      v21 = v19 + v18;
      if (v17)
        v22 = (*(uint64_t (**)(unsigned __int8 *, rsize_t, uint64_t))(a1 + 16))(v17, v21, a1);
      else
        v22 = (*(uint64_t (**)(size_t, uint64_t))(a1 + 8))(v19 + v18, a1);
      v23 = (unsigned __int8 *)v22;
      if (!v22)
      {
        _libssh2_error(a1, 4294967290, "Unable to allocate memory for PEM parsing");
        goto LABEL_48;
      }
      memcpy((void *)(v22 + v18), __s1, v20);
      v17 = v23;
      v18 = v21;
    }
    __s1[0] = 0;
    if (readline(__s1))
      goto LABEL_48;
  }
  while (strcmp(__s1, a3));
  if (!v17)
    return 0xFFFFFFFFLL;
  if (_libssh2_base64_decode(a1, v46, a7, v17, v18))
  {
    v13 = 0xFFFFFFFFLL;
    goto LABEL_50;
  }
  v37 = v47;
  if (!v47)
  {
    v13 = 0;
    goto LABEL_50;
  }
  v49 = 0;
  v50 = 0;
  v38 = *((int *)v47 + 4);
  ctx = 0;
  if (!_libssh2_md5_init(&ctx))
    goto LABEL_48;
  v39 = strlen(a4);
  EVP_DigestUpdate(ctx, a4, v39);
  EVP_DigestUpdate(ctx, &d, 8uLL);
  EVP_DigestFinal(ctx, md, 0);
  EVP_MD_CTX_free(ctx);
  if (*((int *)v47 + 6) < 17)
    goto LABEL_56;
  if (!_libssh2_md5_init(&ctx))
  {
LABEL_48:
    v13 = 0xFFFFFFFFLL;
    goto LABEL_49;
  }
  EVP_DigestUpdate(ctx, md, 0x10uLL);
  v40 = strlen(a4);
  EVP_DigestUpdate(ctx, a4, v40);
  EVP_DigestUpdate(ctx, &d, 8uLL);
  EVP_DigestFinal(ctx, v52, 0);
  EVP_MD_CTX_free(ctx);
  v37 = v47;
LABEL_56:
  if (((unsigned int (*)(uint64_t, char **, char *, char *, unsigned __int8 *, uint64_t *, _QWORD, uint64_t *))v37[5])(a1, v37, &d, (char *)&v50 + 4, md, &v50, 0, &v49))
  {
    memset_s(md, 0x20uLL, 0, 0x20uLL);
    goto LABEL_63;
  }
  if ((_DWORD)v50)
    memset_s(md, 0x20uLL, 0, 0x20uLL);
  v41 = *a7;
  if (*a7 % v38)
  {
    memset_s(md, 0x20uLL, 0, 0x20uLL);
    ((void (*)(uint64_t, uint64_t *))v47[7])(a1, &v49);
    memset_s((void *)*v46, *a7, 0, *a7);
    v46 = (uint64_t *)*v46;
LABEL_63:
    v13 = 0xFFFFFFFFLL;
    (*(void (**)(uint64_t *, uint64_t))(a1 + 24))(v46, a1);
  }
  else
  {
    LODWORD(v42) = v41 - v38;
    if ((int)v41 - (int)v38 < 0)
    {
LABEL_71:
      v45 = *(unsigned __int8 *)(v41 + *v46 - 1);
      bzero((void *)(*v46 + v41 - v45), v45);
      *a7 -= v45;
      memset_s(md, 0x20uLL, 0, 0x20uLL);
      ((void (*)(uint64_t, uint64_t *))v47[7])(a1, &v49);
      v13 = 0;
    }
    else
    {
      v43 = 0;
      while (1)
      {
        v44 = v43 ? 2 * ((_DWORD)v43 == (_DWORD)v42) : 1;
        if (((unsigned int (*)(uint64_t, uint64_t, unint64_t, uint64_t *, uint64_t))v47[6])(a1, *v46 + v43, v38, &v49, v44))
        {
          break;
        }
        v43 += v38;
        v41 = *a7;
        v42 = (int)*a7 - v38;
        if (v43 > v42)
          goto LABEL_71;
      }
      memset_s(md, 0x20uLL, 0, 0x20uLL);
      ((void (*)(uint64_t, uint64_t *))v47[7])(a1, &v49);
      memset_s((void *)*v46, *a7, 0, *a7);
      v13 = 4294967284;
      (*(void (**)(uint64_t, uint64_t))(a1 + 24))(*v46, a1);
    }
  }
LABEL_49:
  if (!v17)
    return v13;
LABEL_50:
  memset_s(v17, v18, 0, v18);
  (*(void (**)(unsigned __int8 *, uint64_t))(a1 + 24))(v17, a1);
  return v13;
}

char *__cdecl readline(const char *a1)
{
  FILE *v1;
  size_t v3;
  char *result;
  char *v5;

  if (!a1)
    return (char *)0xFFFFFFFFLL;
  if (!fgets((char *)a1, 128, v1))
    return (char *)0xFFFFFFFFLL;
  if (!*a1)
    return 0;
  v3 = strlen(a1);
  if (v3)
  {
    if (a1[v3 - 1] == 10)
    {
      a1[v3 - 1] = 0;
      if (!*a1)
        return 0;
    }
  }
  result = (char *)strlen(a1);
  if (!result)
    return result;
  v5 = result - 1;
  if (result[(_QWORD)a1 - 1] != 13)
    return 0;
  result = 0;
  v5[(_QWORD)a1] = 0;
  return result;
}

uint64_t _libssh2_pem_parse_memory(uint64_t a1, const char *a2, const char *a3, uint64_t a4, unint64_t a5, uint64_t *a6, _QWORD *a7)
{
  void *v13;
  rsize_t v14;
  size_t v15;
  size_t v16;
  rsize_t v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v22;
  char __s1[128];
  uint64_t v24;

  v24 = *MEMORY[0x24BDAC8D0];
  v22 = 0;
  do
  {
    __s1[0] = 0;
    readline_memory(__s1, a4, a5, &v22);
  }
  while (strcmp(__s1, a2));
  v13 = 0;
  v14 = 0;
  __s1[0] = 0;
LABEL_7:
  v17 = v14;
  while (1)
  {
    __s1[0] = 0;
    readline_memory(__s1, a4, a5, &v22);
    if (!strcmp(__s1, a3))
      break;
    v14 = v17;
    if (!__s1[0])
      goto LABEL_7;
    v15 = strlen(__s1);
    v16 = v15;
    v17 += v15;
    if (v13)
    {
      v18 = (*(uint64_t (**)(void *, rsize_t, uint64_t))(a1 + 16))(v13, v17, a1);
      if (!v18)
      {
        _libssh2_error(a1, 4294967290, "Unable to allocate memory for PEM parsing");
        v19 = 0xFFFFFFFFLL;
        v17 = v14;
LABEL_17:
        memset_s(v13, v17, 0, v17);
        (*(void (**)(void *, uint64_t))(a1 + 24))(v13, a1);
        return v19;
      }
    }
    else
    {
      v18 = (*(uint64_t (**)(size_t, uint64_t))(a1 + 8))(v15 + v14, a1);
      if (!v18)
      {
        _libssh2_error(a1, 4294967290, "Unable to allocate memory for PEM parsing");
        return 0xFFFFFFFFLL;
      }
    }
    memcpy((void *)(v18 + v14), __s1, v16);
    v13 = (void *)v18;
  }
  if (v13)
  {
    if (_libssh2_base64_decode(a1, a6, a7, (unsigned __int8 *)v13, v17))
      v19 = 0xFFFFFFFFLL;
    else
      v19 = 0;
    goto LABEL_17;
  }
  return 0xFFFFFFFFLL;
}

_BYTE *readline_memory(_BYTE *__dst, uint64_t a2, unint64_t a3, unint64_t *a4)
{
  _BYTE *v5;
  unint64_t v6;
  unint64_t v7;
  int v8;
  size_t v10;
  unint64_t v11;

  v5 = __dst;
  v6 = *a4;
  if (*a4 >= a3)
  {
    v10 = 0;
  }
  else
  {
    v7 = 0;
    while (1)
    {
      v8 = *(unsigned __int8 *)(a2 + v6 + v7);
      if (v8 == 10 || v8 == 13)
        break;
      v10 = v7 + 1;
      if (v7 <= 0x7D)
      {
        v11 = v6 + 1 + v7++;
        if (v11 < a3)
          continue;
      }
      goto LABEL_12;
    }
    v10 = v7;
    if (!v7)
      goto LABEL_13;
LABEL_12:
    __dst = memcpy(__dst, (const void *)(a2 + v6), v10);
    *a4 += v10;
  }
LABEL_13:
  v5[v10] = 0;
  ++*a4;
  return __dst;
}

uint64_t _libssh2_openssh_pem_parse(uint64_t a1, const char *a2, uint64_t a3, _QWORD *a4)
{
  uint64_t v7;
  unsigned __int8 *v9;
  rsize_t v10;
  size_t v11;
  size_t v12;
  rsize_t v13;
  uint64_t v14;
  char __s1[128];
  uint64_t v16;

  v16 = *MEMORY[0x24BDAC8D0];
  do
  {
    __s1[0] = 0;
    if (readline(__s1))
      return 0xFFFFFFFFLL;
  }
  while (strcmp(__s1, "-----BEGIN OPENSSH PRIVATE KEY-----"));
  if (readline(__s1))
    return 0xFFFFFFFFLL;
  v9 = 0;
  v10 = 0;
  do
  {
    if (__s1[0])
    {
      v11 = strlen(__s1);
      v12 = v11;
      v13 = v11 + v10;
      if (v9)
        v14 = (*(uint64_t (**)(unsigned __int8 *, rsize_t, uint64_t))(a1 + 16))(v9, v13, a1);
      else
        v14 = (*(uint64_t (**)(size_t, uint64_t))(a1 + 8))(v11 + v10, a1);
      v9 = (unsigned __int8 *)v14;
      if (!v14)
      {
        _libssh2_error(a1, 4294967290, "Unable to allocate memory for PEM parsing");
        return 0xFFFFFFFFLL;
      }
      memcpy((void *)(v14 + v10), __s1, v12);
      v10 = v13;
    }
    __s1[0] = 0;
    if (readline(__s1))
      return 0xFFFFFFFFLL;
  }
  while (strcmp(__s1, "-----END OPENSSH PRIVATE KEY-----"));
  if (!v9)
    return 0xFFFFFFFFLL;
  v7 = _libssh2_openssh_pem_parse_data(a1, a2, v9, v10, a4);
  memset_s(v9, v10, 0, v10);
  (*(void (**)(unsigned __int8 *, uint64_t))(a1 + 24))(v9, a1);
  return v7;
}

uint64_t _libssh2_openssh_pem_parse_data(uint64_t a1, const char *a2, unsigned __int8 *a3, uint64_t a4, _QWORD *a5)
{
  uint64_t v5;
  char *v8;
  char *v9;
  char *v11;
  char ***v12;
  const char **v13;
  int *v14;
  char *v15;
  const char ***v16;
  size_t v17;
  const char **v18;
  int *v19;
  int v20;
  int v21;
  int v22;
  char *v23;
  int v24;
  char *v25;
  uint64_t v26;
  uint64_t v27;
  void *v28;
  void *v29;
  _QWORD *v30;
  _QWORD *v31;
  void *v32;
  char *v33;
  uint64_t v34;
  uint64_t v35;
  size_t v36;
  size_t v37;
  uint64_t v38;
  char *v39;
  size_t v40;
  unint64_t v41;
  uint64_t v42;
  uint64_t v43;
  unint64_t v44;
  size_t v45;
  uint64_t v46;
  rsize_t __n;
  void *__s;
  unsigned int v49;
  int v50;
  uint64_t v51;
  const void *v52;
  char *v53;
  uint64_t v54;
  char *v55;
  char *__s1;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  char *v60;
  char *v61;
  size_t v62;
  void *v63;
  void *v64;
  rsize_t v65;

  v5 = (uint64_t)a5;
  v55 = 0;
  __s1 = 0;
  v53 = 0;
  v54 = 0;
  v52 = 0;
  v49 = 0;
  __n = 0;
  __s = 0;
  v45 = 0;
  v46 = 0;
  v44 = 0;
  if (a5)
    *a5 = 0;
  v63 = 0;
  v64 = 0;
  v65 = 0;
  v61 = 0;
  v62 = 0;
  v60 = 0;
  v58 = 0;
  v59 = 0;
  v57 = 0;
  v51 = 0;
  v50 = 0;
  if (_libssh2_base64_decode(a1, (uint64_t *)&__s, &__n, a3, a4))
  {
    v5 = 0xFFFFFFFFLL;
    goto LABEL_18;
  }
  v8 = (char *)__s;
  v63 = __s;
  v64 = __s;
  v65 = __n;
  if (__n <= 0xD)
  {
    v9 = "key too short";
LABEL_17:
    v5 = _libssh2_error(a1, 4294967282, v9);
    goto LABEL_18;
  }
  if (strncmp((const char *)__s, "openssh-key-v1", 0xEuLL))
  {
    v9 = "key auth magic mismatch";
    goto LABEL_17;
  }
  v64 = v8 + 15;
  if (_libssh2_get_string(&v63, &__s1, &v45) || !v45)
  {
    v9 = "ciphername is missing";
    goto LABEL_17;
  }
  if (_libssh2_get_string(&v63, &v55, &v45) || !v45)
  {
    v9 = "kdfname is missing";
    goto LABEL_17;
  }
  if (_libssh2_get_string(&v63, &v54, &v46))
  {
    v9 = "kdf is missing";
    goto LABEL_17;
  }
  v57 = v54;
  v58 = v54;
  v59 = v46;
  if ((!a2 || !*a2) && strcmp(__s1, "none"))
  {
    v5 = 4294967248;
    goto LABEL_18;
  }
  v11 = v55;
  if (!strcmp(v55, "none"))
  {
    if (strcmp(__s1, "none"))
    {
      v9 = "invalid format";
      goto LABEL_17;
    }
  }
  else if (strcmp(v11, "bcrypt"))
  {
    v9 = "unknown cipher";
    goto LABEL_17;
  }
  if (_libssh2_get_u32(&v63, (_DWORD *)&v51 + 1) || HIDWORD(v51) != 1)
  {
    v9 = "Multiple keys are unsupported";
    goto LABEL_17;
  }
  if (_libssh2_get_string(&v63, &v53, &v45) || !v45)
  {
    v9 = "Invalid private key; expect embedded public key";
    goto LABEL_17;
  }
  if (_libssh2_get_string(&v63, &v53, &v45) || !v45)
  {
    v9 = "Private key data not found";
    goto LABEL_17;
  }
  v60 = v53;
  v61 = v53;
  v62 = v45;
  if (__s1 && strcmp(__s1, "none"))
  {
    v12 = libssh2_crypt_methods();
    v13 = (const char **)*v12;
    if (!*v12)
      goto LABEL_63;
    v14 = 0;
    v15 = __s1;
    v16 = (const char ***)(v12 + 1);
    do
    {
      if (**v13)
      {
        v17 = strlen(*v13);
        if (!memcmp(v15, *v13, v17))
          v14 = (int *)v13;
      }
      v18 = *v16++;
      v13 = v18;
    }
    while (v18);
    if (!v14)
    {
LABEL_63:
      v9 = "No supported cipher found";
      goto LABEL_17;
    }
    v19 = v14;
    v42 = 0;
    v43 = 0;
    v20 = v14[5];
    v21 = v14[6];
    v22 = v20 + v21;
    v23 = (char *)_libssh2_calloc(a1, v20 + v21);
    if (!v23)
    {
      v5 = _libssh2_error(a1, 4294967282, "Could not alloc key");
LABEL_67:
      v28 = 0;
LABEL_68:
      v29 = 0;
      goto LABEL_69;
    }
    v24 = strcmp(v55, "bcrypt");
    if (!a2 || v24)
    {
      v25 = "bcrypted without passphrase";
      v26 = a1;
      v27 = 4294967248;
      goto LABEL_66;
    }
    if (_libssh2_get_string(&v57, &v52, &v44) || _libssh2_get_u32(&v57, &v49))
    {
      v25 = "kdf contains unexpected values";
      v26 = a1;
      v27 = 4294967282;
LABEL_66:
      v5 = _libssh2_error(v26, v27, v25);
      (*(void (**)(char *, uint64_t))(a1 + 24))(v23, a1);
      goto LABEL_67;
    }
    v36 = strlen(a2);
    if ((_libssh2_bcrypt_pbkdf(a2, v36, v52, v44, (uint64_t)v23, v22, v49) & 0x80000000) != 0)
    {
      v25 = "invalid format";
      v26 = a1;
      v27 = 4294967284;
      goto LABEL_66;
    }
    v41 = v14[4];
    v28 = _libssh2_calloc(a1, v21);
    if (!v28)
    {
      v5 = _libssh2_error(a1, 4294967282, "Could not alloc key part");
      goto LABEL_68;
    }
    v29 = _libssh2_calloc(a1, v20);
    if (v29)
    {
      memcpy(v28, v23, v21);
      memcpy(v29, &v23[v21], v20);
      if (!(*((unsigned int (**)(uint64_t, int *, void *, char *, void *, uint64_t *, _QWORD, uint64_t *))v19
             + 5))(a1, v19, v29, (char *)&v43 + 4, v28, &v43, 0, &v42))
      {
        if (!(v62 % v41))
        {
          v37 = 0;
          v40 = v62 - v41;
          v39 = v60;
          while (1)
          {
            v38 = v37 ? 2 * (v40 == v37) : 1;
            if ((*((unsigned int (**)(uint64_t, char *, unint64_t, uint64_t *, uint64_t))v19 + 6))(a1, &v39[v37], v41, &v42, v38))
            {
              break;
            }
            v37 += v41;
            if (v40 < v37)
            {
              (*((void (**)(uint64_t, uint64_t *))v19 + 7))(a1, &v42);
              goto LABEL_55;
            }
          }
        }
        (*((void (**)(uint64_t, uint64_t *))v19 + 7))(a1, &v42);
      }
      v5 = 4294967284;
      goto LABEL_69;
    }
    v33 = "Could not alloc iv part";
    v34 = a1;
    v35 = 4294967282;
LABEL_76:
    v5 = _libssh2_error(v34, v35, v33);
    goto LABEL_69;
  }
  v23 = 0;
  v28 = 0;
  v29 = 0;
  v21 = 0;
  v20 = 0;
  v22 = 0;
LABEL_55:
  if (_libssh2_get_u32(&v60, &v51) || _libssh2_get_u32(&v60, &v50) || (_DWORD)v51 != v50)
  {
    _libssh2_error(a1, 4294967282, "Private key unpack failed (correct password?)");
    v5 = 4294967248;
  }
  else if (v5)
  {
    v30 = _libssh2_string_buf_new(a1);
    if (v30)
    {
      v31 = v30;
      v32 = _libssh2_calloc(a1, v62);
      *v31 = v32;
      if (v32)
      {
        memcpy(v32, v60, v62);
        v31[1] = *v31 + v61 - v60;
        v31[2] = v62;
        *(_QWORD *)v5 = v31;
        v5 = 0;
      }
      else
      {
        v5 = _libssh2_error(a1, 4294967290, "Unable to allocate memory for decrypted struct");
        _libssh2_string_buf_free(a1, v31);
      }
      goto LABEL_69;
    }
    v33 = "Unable to allocate memory for decrypted struct";
    v34 = a1;
    v35 = 4294967290;
    goto LABEL_76;
  }
LABEL_69:
  if (v23)
  {
    memset_s(v23, v22, 0, v22);
    (*(void (**)(char *, uint64_t))(a1 + 24))(v23, a1);
  }
  if (v28)
  {
    memset_s(v28, v21, 0, v21);
    (*(void (**)(void *, uint64_t))(a1 + 24))(v28, a1);
  }
  if (v29)
  {
    memset_s(v29, v20, 0, v20);
    (*(void (**)(void *, uint64_t))(a1 + 24))(v29, a1);
  }
LABEL_18:
  if (__s)
  {
    memset_s(__s, __n, 0, __n);
    (*(void (**)(void *, uint64_t))(a1 + 24))(__s, a1);
  }
  return v5;
}

uint64_t _libssh2_openssh_pem_parse_memory(uint64_t a1, const char *a2, uint64_t a3, unint64_t a4, _QWORD *a5)
{
  void *v10;
  rsize_t v11;
  size_t v12;
  size_t v13;
  rsize_t v14;
  uint64_t v15;
  void *v16;
  char *v18;
  uint64_t v19;
  char *v20;
  uint64_t v21;
  uint64_t v22;
  _QWORD *v23;
  unint64_t v24;
  char __s1[128];
  uint64_t v26;

  v26 = *MEMORY[0x24BDAC8D0];
  v24 = 0;
  if (!a3 || !a4)
    return _libssh2_error(a1, 4294967282, "Error parsing PEM: filedata missing");
  do
  {
    __s1[0] = 0;
    if (v24 >= a4)
    {
      v18 = "Error parsing PEM: OpenSSH header not found";
      return _libssh2_error(a1, 4294967282, v18);
    }
    readline_memory(__s1, a3, a4, &v24);
  }
  while (strcmp(__s1, "-----BEGIN OPENSSH PRIVATE KEY-----"));
  v23 = a5;
  v10 = 0;
  v11 = 0;
  __s1[0] = 0;
  while (1)
  {
    __s1[0] = 0;
    if (v24 >= a4)
    {
      v20 = "Error parsing PEM: offset out of bounds";
      v21 = a1;
      v22 = 4294967282;
LABEL_22:
      v19 = _libssh2_error(v21, v22, v20);
      if (!v10)
        return v19;
LABEL_23:
      memset_s(v10, v11, 0, v11);
      (*(void (**)(void *, uint64_t))(a1 + 24))(v10, a1);
      return v19;
    }
    readline_memory(__s1, a3, a4, &v24);
    if (!strcmp(__s1, "-----END OPENSSH PRIVATE KEY-----"))
      break;
    if (__s1[0])
    {
      v12 = strlen(__s1);
      v13 = v12;
      v14 = v12 + v11;
      if (v10)
        v15 = (*(uint64_t (**)(void *, rsize_t, uint64_t))(a1 + 16))(v10, v14, a1);
      else
        v15 = (*(uint64_t (**)(size_t, uint64_t))(a1 + 8))(v12 + v11, a1);
      v16 = (void *)v15;
      if (!v15)
      {
        v20 = "Unable to allocate memory for PEM parsing";
        v21 = a1;
        v22 = 4294967290;
        goto LABEL_22;
      }
      memcpy((void *)(v15 + v11), __s1, v13);
      v10 = v16;
      v11 = v14;
    }
  }
  if (v10)
  {
    v19 = _libssh2_openssh_pem_parse_data(a1, a2, (unsigned __int8 *)v10, v11, v23);
    goto LABEL_23;
  }
  v18 = "Error parsing PEM: base 64 data missing";
  return _libssh2_error(a1, 4294967282, v18);
}

uint64_t _libssh2_pem_decode_sequence(_QWORD *a1, uint64_t *a2)
{
  uint64_t v2;
  _BYTE *v4;
  _BYTE *v6;
  uint64_t v7;
  unsigned int v8;
  unsigned int v9;
  uint64_t result;
  unint64_t v11;

  v2 = *a2;
  if (!*a2)
    return 0xFFFFFFFFLL;
  v4 = (_BYTE *)*a1;
  if (*(_BYTE *)*a1 != 48)
    return 0xFFFFFFFFLL;
  v11 = 0;
  v6 = v4 + 1;
  *a1 = v4 + 1;
  v7 = v2 - 1;
  *a2 = v2 - 1;
  v8 = read_asn1_length(v4 + 1, v2 - 1, &v11);
  if ((v8 & 0x80000000) != 0)
    return 0xFFFFFFFFLL;
  v9 = v8;
  if (v11 + v8 != v7)
    return 0xFFFFFFFFLL;
  result = 0;
  *a1 = &v6[v9];
  *a2 = v7 - v9;
  return result;
}

uint64_t read_asn1_length(unsigned __int8 *a1, unint64_t a2, unint64_t *a3)
{
  int v3;
  unint64_t v4;
  unsigned int v5;
  unint64_t v7;
  unint64_t v8;

  if (!a2)
    return 0xFFFFFFFFLL;
  v3 = (char)*a1;
  v4 = *a1;
  *a3 = v4;
  if (v3 < 0)
  {
    v7 = v4 & 0x7F;
    v4 = a1[1];
    *a3 = v4;
    v5 = v7 + 1;
    if (v7 + 1 <= a2)
    {
      if (v7 < 2)
        goto LABEL_4;
      *a3 = v4 << 8;
      v8 = a1[2] | ((unint64_t)v4 << 8);
      *a3 = v8;
      v4 = v8;
      if ((_DWORD)v7 == 2)
        goto LABEL_4;
    }
    return 0xFFFFFFFFLL;
  }
  v5 = 1;
LABEL_4:
  if (v4 + v5 > a2)
    return 0xFFFFFFFFLL;
  else
    return v5;
}

uint64_t _libssh2_pem_decode_integer(_QWORD *a1, uint64_t *a2, _QWORD *a3, _DWORD *a4)
{
  uint64_t v4;
  _BYTE *v6;
  _BYTE *v10;
  unint64_t v11;
  unsigned int v12;
  unsigned int v13;
  unint64_t v14;
  unint64_t v15;
  BOOL v16;
  unint64_t v17;
  uint64_t result;
  _BYTE *v19;
  unint64_t v20;

  v4 = *a2;
  if (!*a2)
    return 0xFFFFFFFFLL;
  v6 = (_BYTE *)*a1;
  if (*(_BYTE *)*a1 != 2)
    return 0xFFFFFFFFLL;
  v20 = 0;
  v10 = v6 + 1;
  *a1 = v6 + 1;
  v11 = v4 - 1;
  *a2 = v4 - 1;
  v12 = read_asn1_length(v6 + 1, v4 - 1, &v20);
  if ((v12 & 0x80000000) != 0)
    return 0xFFFFFFFFLL;
  v13 = v12;
  v14 = v20;
  v15 = v20 + v12;
  v16 = v11 >= v15;
  v17 = v11 - v15;
  if (!v16)
    return 0xFFFFFFFFLL;
  result = 0;
  v19 = &v10[v13];
  *a1 = v19;
  *a3 = v19;
  *a4 = v14;
  *a1 += v14;
  *a2 = v17;
  return result;
}

_DWORD *libssh2_agent_init(uint64_t a1)
{
  _DWORD *v2;
  _DWORD *v3;

  v2 = _libssh2_calloc(a1, 0x68uLL);
  v3 = v2;
  if (v2)
  {
    v2[2] = -1;
    *(_QWORD *)v2 = a1;
    *((_QWORD *)v2 + 12) = 0;
    _libssh2_list_init((_QWORD *)v2 + 10);
  }
  else
  {
    _libssh2_error(a1, 4294967290, "Unable to allocate space for agent connection");
  }
  return v3;
}

uint64_t libssh2_agent_connect(uint64_t a1)
{
  *(_QWORD *)(a1 + 16) = &agent_ops_unix;
  return agent_ops_unix(a1);
}

uint64_t libssh2_agent_list_identities(uint64_t *a1)
{
  _BYTE **v2;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  char *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unsigned int v14;
  uint64_t v15;
  unsigned int *v16;
  uint64_t v17;
  uint64_t v18;
  unsigned int v19;
  uint64_t v20;
  uint64_t v21;
  void *v22;
  BOOL v23;
  unint64_t v24;
  unsigned int *v25;
  unsigned int v26;
  uint64_t v27;
  size_t v28;
  uint64_t v29;
  char *v30;
  char v31;

  *(_OWORD *)(a1 + 3) = 0u;
  v2 = (_BYTE **)(a1 + 3);
  *(_OWORD *)(a1 + 7) = 0u;
  *(_OWORD *)(a1 + 5) = 0u;
  agent_free_identities(a1);
  v31 = 11;
  if (*((_DWORD *)a1 + 14))
  {
    if (**v2 != 11)
      return _libssh2_error(*a1, 4294967257, "illegal agent request");
  }
  else
  {
    a1[3] = (uint64_t)&v31;
    a1[4] = 1;
    a1[8] = 0;
    *((_DWORD *)a1 + 14) = 1;
  }
  v4 = a1[2];
  if (!v4)
  {
    v7 = *a1;
    v8 = "agent not connected";
    v9 = 4294967257;
    return _libssh2_error(v7, v9, v8);
  }
  v5 = (*(uint64_t (**)(uint64_t *, _BYTE **))(v4 + 8))(a1, v2);
  if (!(_DWORD)v5)
  {
    a1[3] = 0;
    v10 = a1[6];
    if (v10 < 1)
    {
LABEL_24:
      v11 = 4294967254;
    }
    else
    {
      v11 = 4294967254;
      v12 = v10 - 5;
      if ((unint64_t)v10 >= 5)
      {
        v13 = a1[5];
        if (*(_BYTE *)v13 == 12)
        {
          v14 = _libssh2_ntohu32((unsigned int *)(v13 + 1));
          if (v14)
          {
            v15 = v14;
            v16 = (unsigned int *)(v13 + 5);
            while (1)
            {
              if (v12 < 4)
                goto LABEL_24;
              v17 = (*(uint64_t (**)(uint64_t))(*a1 + 8))(64);
              if (!v17)
              {
                v11 = 4294967290;
                goto LABEL_35;
              }
              v18 = v17;
              v19 = _libssh2_ntohu32(v16);
              *(_QWORD *)(v18 + 48) = v19;
              v20 = v12 - 4 - v19;
              v21 = *a1;
              if (v20 < 0)
                break;
              v22 = (void *)(*(uint64_t (**)(void))(v21 + 8))();
              *(_QWORD *)(v18 + 40) = v22;
              if (!v22)
              {
                v11 = 4294967290;
                goto LABEL_33;
              }
              memcpy(v22, v16 + 1, *(_QWORD *)(v18 + 48));
              v23 = (unint64_t)v20 >= 4;
              v24 = v20 - 4;
              if (!v23)
              {
                v11 = 4294967254;
                goto LABEL_31;
              }
              v25 = (unsigned int *)((char *)v16 + *(_QWORD *)(v18 + 48) + 4);
              v26 = _libssh2_ntohu32(v25);
              v27 = *a1;
              if (v24 < v26)
              {
                v11 = 4294967254;
                goto LABEL_32;
              }
              v28 = v26;
              v29 = (*(uint64_t (**)(uint64_t))(v27 + 8))(v26 + 1);
              *(_QWORD *)(v18 + 56) = v29;
              if (!v29)
              {
                v11 = 4294967290;
LABEL_31:
                v27 = *a1;
LABEL_32:
                (*(void (**)(_QWORD))(v27 + 24))(*(_QWORD *)(v18 + 40));
LABEL_33:
                v21 = *a1;
LABEL_34:
                (*(void (**)(uint64_t))(v21 + 24))(v18);
                goto LABEL_35;
              }
              --v15;
              v30 = (char *)(v25 + 1);
              v12 = v24 - v28;
              *(_BYTE *)(v29 + v28) = 0;
              memcpy(*(void **)(v18 + 56), v30, v28);
              v16 = (unsigned int *)&v30[v28];
              _libssh2_list_add((_QWORD **)a1 + 10, (_QWORD *)v18);
              v11 = 0;
              if (!v15)
                goto LABEL_35;
            }
            v11 = 4294967254;
            goto LABEL_34;
          }
          v11 = 0;
        }
      }
    }
LABEL_35:
    (*(void (**)(uint64_t))(*a1 + 24))(a1[5]);
    a1[5] = 0;
    v7 = *a1;
    v8 = "agent list id failed";
    v9 = v11;
    return _libssh2_error(v7, v9, v8);
  }
  v6 = v5;
  (*(void (**)(uint64_t))(*a1 + 24))(a1[5]);
  a1[5] = 0;
  return v6;
}

_QWORD *agent_free_identities(_QWORD *a1)
{
  _QWORD *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  v2 = a1 + 10;
  v3 = _libssh2_list_first((uint64_t)(a1 + 10));
  if (v3)
  {
    v4 = v3;
    do
    {
      v5 = _libssh2_list_next(v4);
      (*(void (**)(_QWORD))(*a1 + 24))(*(_QWORD *)(v4 + 40));
      (*(void (**)(_QWORD))(*a1 + 24))(*(_QWORD *)(v4 + 56));
      (*(void (**)(uint64_t))(*a1 + 24))(v4);
      v4 = v5;
    }
    while (v5);
  }
  return _libssh2_list_init(v2);
}

uint64_t libssh2_agent_get_identity(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t result;

  if (a3 && *(_QWORD *)(a3 + 8))
    v4 = _libssh2_list_next(*(_QWORD *)(a3 + 8));
  else
    v4 = _libssh2_list_first(a1 + 80);
  v5 = v4;
  if (!v4)
    return 1;
  result = 0;
  *(_DWORD *)(v5 + 24) = 1004469970;
  *(_QWORD *)(v5 + 32) = v5;
  *a2 = v5 + 24;
  return result;
}

uint64_t libssh2_agent_userauth(uint64_t *a1, const char *a2, uint64_t a3)
{
  time_t v6;
  size_t v7;
  uint64_t result;
  uint64_t *v9;

  v9 = a1;
  if (!*(_DWORD *)(*a1 + 72216))
  {
    *(_OWORD *)(a1 + 7) = 0u;
    *(_OWORD *)(a1 + 5) = 0u;
    *(_OWORD *)(a1 + 3) = 0u;
    a1[9] = *(_QWORD *)(a3 + 8);
  }
  v6 = time(0);
  do
  {
    v7 = strlen(a2);
    result = _libssh2_userauth_publickey(*a1, a2, v7, *(unsigned int **)(a3 + 16), *(_QWORD *)(a3 + 24), (uint64_t (*)(uint64_t, const void **, size_t *, char *, int64_t, uint64_t))agent_sign, (uint64_t)&v9);
    if ((_DWORD)result != -37)
      break;
    if (!*(_DWORD *)(*a1 + 172))
      return 4294967259;
    result = _libssh2_wait_socket(*a1, v6);
  }
  while (!(_DWORD)result);
  return result;
}

uint64_t agent_sign(uint64_t a1, _QWORD *a2, size_t *a3, const void *a4, unint64_t a5, uint64_t *a6)
{
  uint64_t v9;
  uint64_t v10;
  _BYTE **v11;
  uint64_t v12;
  uint64_t v13;
  _BYTE *v14;
  _BYTE *v17;
  uint64_t v18;
  char *v19;
  BOOL v20;
  unsigned int v21;
  uint64_t v24;
  int v25;
  _BOOL4 v27;
  uint64_t v28;
  uint64_t v29;
  _BYTE *v30;
  uint64_t v31;
  unsigned int v32;
  uint64_t v33;
  size_t v34;
  void *v35;
  const void *v36;
  size_t v37;
  char *v38;
  uint64_t v39;
  uint64_t v40;
  unsigned int v41;
  void *v42;
  void *__src;

  v9 = a1 + 72256;
  v10 = *a6;
  v11 = (_BYTE **)(*a6 + 24);
  v12 = *(_QWORD *)(*a6 + 72);
  v13 = *(_QWORD *)(v12 + 48);
  __src = 0;
  if (*(_DWORD *)(v10 + 56))
  {
    v14 = *v11;
  }
  else
  {
    v17 = (_BYTE *)(*(uint64_t (**)(unint64_t, uint64_t))(a1 + 8))(a5 + v13 + 13, a1);
    *v11 = v17;
    if (!v17)
      return _libssh2_error(a1, 4294967290, "out of memory");
    __src = v17 + 1;
    *v17 = 13;
    _libssh2_store_str((_DWORD **)&__src, *(const void **)(v12 + 40), *(_QWORD *)(v12 + 48));
    _libssh2_store_str((_DWORD **)&__src, a4, a5);
    v18 = *(_QWORD *)(v9 + 8);
    if (!v18 || ((v19 = *(char **)v9, v18 == 12) ? (v20 = v19 == 0) : (v20 = 1), v20))
    {
      v21 = 0;
    }
    else if (*(_QWORD *)v19 == 0x326168732D617372 && *((_DWORD *)v19 + 2) == 842085677)
    {
      v21 = 4;
    }
    else
    {
      v24 = *(_QWORD *)v19;
      v25 = *((_DWORD *)v19 + 2);
      v27 = v24 == 0x326168732D617372 && v25 == 909455917;
      v21 = 2 * v27;
    }
    _libssh2_store_u32((_DWORD **)&__src, v21);
    v14 = *(_BYTE **)(v10 + 24);
    *(_QWORD *)(v10 + 32) = (_BYTE *)__src - v14;
    *(_QWORD *)(v10 + 64) = 0;
    *(_DWORD *)(v10 + 56) = 1;
  }
  if (*v14 == 13)
  {
    v28 = *(_QWORD *)(v10 + 16);
    if (v28)
    {
      v29 = (*(uint64_t (**)(uint64_t, _BYTE **))(v28 + 8))(v10, v11);
      if (!(_DWORD)v29)
      {
        (*(void (**)(_QWORD, uint64_t))(a1 + 24))(*(_QWORD *)(v10 + 24), a1);
        *(_QWORD *)(v10 + 24) = 0;
        v30 = *(_BYTE **)(v10 + 40);
        v31 = *(_QWORD *)(v10 + 48);
        __src = v30;
        if (v31 >= 1
          && *v30 == 14
          && (__src = v30 + 1, (unint64_t)v31 >= 5)
          && (__src = v30 + 5, (unint64_t)v31 >= 9)
          && (v32 = _libssh2_ntohu32((unsigned int *)(v30 + 5)), __src = (char *)__src + 4,
                                                                 v33 = v31 - v32 - 9,
                                                                 v33 >= 0))
        {
          v34 = v32;
          v35 = (void *)(*(uint64_t (**)(_QWORD, uint64_t))(a1 + 8))(v32, a1);
          if (v35)
          {
            v36 = v35;
            memcpy(v35, __src, v34);
            __src = (char *)__src + v34;
            v37 = plain_method(*(char **)v9, *(_QWORD *)(v9 + 8));
            if ((*(_QWORD *)(v9 + 8) == v34 || v37 == v34) && !memcmp(v36, *(const void **)v9, v34))
            {
              if ((unint64_t)v33 >= 4
                && (v41 = _libssh2_ntohu32((unsigned int *)__src),
                    *a3 = v41,
                    __src = (char *)__src + 4,
                    v33 - 4 >= (unint64_t)v41))
              {
                v42 = (void *)(*(uint64_t (**)(void))(a1 + 8))();
                *a2 = v42;
                if (v42)
                {
                  memcpy(v42, __src, *a3);
                  v29 = 0;
                }
                else
                {
                  v29 = 4294967290;
                }
              }
              else
              {
                v29 = 4294967254;
              }
            }
            else
            {
              v29 = 4294967245;
            }
            (*(void (**)(const void *, uint64_t))(a1 + 24))(v36, a1);
          }
          else
          {
            v29 = 4294967290;
          }
        }
        else
        {
          v29 = 4294967254;
        }
      }
      (*(void (**)(_QWORD, uint64_t))(a1 + 24))(*(_QWORD *)(v10 + 24), a1);
      *(_QWORD *)(v10 + 24) = 0;
      (*(void (**)(_QWORD, uint64_t))(a1 + 24))(*(_QWORD *)(v10 + 40), a1);
      *(_QWORD *)(v10 + 40) = 0;
      *(_DWORD *)(v10 + 56) = 0;
      v38 = "agent sign failure";
      v39 = a1;
      v40 = v29;
      return _libssh2_error(v39, v40, v38);
    }
    v38 = "agent not connected";
  }
  else
  {
    v38 = "illegal request";
  }
  v39 = a1;
  v40 = 4294967257;
  return _libssh2_error(v39, v40, v38);
}

uint64_t libssh2_agent_sign(uint64_t *a1, uint64_t a2, _QWORD *a3, size_t *a4, const void *a5, unint64_t a6, const void *a7, unsigned int a8)
{
  unsigned int v16;
  unint64_t v17;
  size_t v18;
  uint64_t v19;
  uint64_t v20;
  void *v21;
  uint64_t *v23;

  v23 = a1;
  if (!*(_DWORD *)(*a1 + 72216))
  {
    *(_OWORD *)(a1 + 7) = 0u;
    *(_OWORD *)(a1 + 5) = 0u;
    *(_OWORD *)(a1 + 3) = 0u;
    a1[9] = *(_QWORD *)(a2 + 8);
  }
  if (*(_QWORD *)(a2 + 24) < 4uLL)
    return 4294967258;
  v16 = _libssh2_ntohu32(*(unsigned int **)(a2 + 16));
  v17 = *(_QWORD *)(a2 + 24);
  v18 = v16;
  if (v17 < (unint64_t)v16 + 4)
    return 4294967258;
  v20 = *a1;
  *(_QWORD *)(v20 + 72264) = a8;
  v21 = (void *)(*(uint64_t (**)(void))(v20 + 8))();
  *(_QWORD *)(*a1 + 72256) = v21;
  memcpy(v21, a7, v18);
  v19 = agent_sign(*a1, a3, a4, a5, a6, (uint64_t *)&v23);
  (*(void (**)(_QWORD))(*a1 + 24))(*(_QWORD *)(*a1 + 72256));
  *(_OWORD *)(*a1 + 72256) = 0u;
  return v19;
}

uint64_t libssh2_agent_disconnect(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 16);
  if (!v1 || *(_DWORD *)(a1 + 8) == -1)
    return 0;
  else
    return (*(uint64_t (**)(void))(v1 + 16))();
}

uint64_t libssh2_agent_free(_QWORD *a1)
{
  uint64_t v2;

  if (*((_DWORD *)a1 + 2) != -1)
  {
    v2 = a1[2];
    if (v2)
      (*(void (**)(_QWORD *))(v2 + 16))(a1);
  }
  if (a1[12])
    (*(void (**)(void))(*a1 + 24))();
  agent_free_identities(a1);
  return (*(uint64_t (**)(_QWORD *))(*a1 + 24))(a1);
}

unint64_t libssh2_agent_set_identity_path(_QWORD *a1, char *__s)
{
  unint64_t result;
  size_t v5;
  void *v6;

  result = a1[12];
  if (result)
  {
    result = (*(uint64_t (**)(void))(*a1 + 24))();
    a1[12] = 0;
  }
  if (__s)
  {
    result = strlen(__s);
    if (result <= 0xFFFFFFFFFFFFFFFDLL)
    {
      v5 = result;
      v6 = (void *)(*(uint64_t (**)(unint64_t))(*a1 + 8))(result + 1);
      result = (unint64_t)memcpy(v6, __s, v5);
      *((_BYTE *)v6 + v5) = 0;
      a1[12] = v6;
    }
  }
  return result;
}

uint64_t libssh2_agent_get_identity_path(uint64_t a1)
{
  return *(_QWORD *)(a1 + 96);
}

uint64_t agent_connect_unix(uint64_t a1)
{
  char *v2;
  int v3;
  int v4;
  uint64_t result;
  sockaddr v6;
  char v7;
  uint64_t v8;

  v8 = *MEMORY[0x24BDAC8D0];
  v2 = *(char **)(a1 + 96);
  if (!v2)
  {
    v2 = getenv("SSH_AUTH_SOCK");
    if (!v2)
      return _libssh2_error(*(_QWORD *)a1, 4294967257, "no auth sock variable");
  }
  v3 = socket(1, 1, 0);
  *(_DWORD *)(a1 + 8) = v3;
  if (v3 < 0)
    return _libssh2_error(*(_QWORD *)a1, 4294967251, "failed creating socket");
  v4 = v3;
  *(_WORD *)&v6.sa_len = 256;
  strncpy(v6.sa_data, v2, 0x68uLL);
  v7 = 0;
  result = connect(v4, &v6, 0x6Au);
  if ((_DWORD)result)
  {
    close(*(_DWORD *)(a1 + 8));
    return _libssh2_error(*(_QWORD *)a1, 4294967254, "failed connecting with agent");
  }
  return result;
}

uint64_t agent_transact_unix(unsigned int *a1, uint64_t *a2)
{
  unint64_t v4;
  uint64_t v5;
  uint64_t (*v6)(uint64_t, char *, unint64_t, _QWORD, uint64_t);
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t (*v11)(uint64_t, unint64_t, unint64_t, _QWORD, uint64_t);
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t (*v18)(uint64_t, char *, unint64_t, _QWORD, uint64_t);
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t result;
  unint64_t v24;
  uint64_t v25;
  uint64_t (*v26)(uint64_t, unint64_t, unint64_t, _QWORD, uint64_t);
  uint64_t v27;
  unint64_t v28;
  uint64_t v29;
  uint64_t v30;
  char *v31;
  uint64_t v32;
  unsigned int v33;

  switch(*((_DWORD *)a2 + 8))
  {
    case 1:
      _libssh2_htonu32(&v33, *((_DWORD *)a2 + 2));
      v4 = 0;
      v5 = *(_QWORD *)a1;
      v6 = *(uint64_t (**)(uint64_t, char *, unint64_t, _QWORD, uint64_t))(*(_QWORD *)a1 + 96);
      v7 = a1[2];
      do
      {
        if (v4 > 3)
          goto LABEL_6;
        v8 = v6(v7, (char *)&v33 + v4, 4 - v4, 0, v5);
        v4 += v8;
      }
      while ((v8 & 0x8000000000000000) == 0);
      LODWORD(v4) = v8;
LABEL_6:
      if ((_DWORD)v4 == -35)
        return 4294967259;
      if ((v4 & 0x80000000) == 0)
      {
        *((_DWORD *)a2 + 8) = 2;
        goto LABEL_9;
      }
      goto LABEL_35;
    case 2:
LABEL_9:
      v9 = 0;
      v10 = *(_QWORD *)a1;
      v11 = *(uint64_t (**)(uint64_t, unint64_t, unint64_t, _QWORD, uint64_t))(*(_QWORD *)a1 + 96);
      v12 = a1[2];
      v13 = *a2;
      v14 = a2[1];
      break;
    case 3:
      goto LABEL_16;
    case 4:
      v22 = a2[2];
      goto LABEL_25;
    default:
      return 0;
  }
  while (v14 > v9)
  {
    v15 = v11(v12, v13 + v9, v14 - v9, 0, v10);
    v9 += v15;
    if (v15 < 0)
    {
      LODWORD(v9) = v15;
      break;
    }
  }
  if ((_DWORD)v9 == -35)
    return 4294967259;
  if ((v9 & 0x80000000) != 0)
  {
LABEL_35:
    v30 = *(_QWORD *)a1;
    v31 = "agent send failed";
    goto LABEL_36;
  }
  *((_DWORD *)a2 + 8) = 3;
LABEL_16:
  v16 = 0;
  v17 = *(_QWORD *)a1;
  v18 = *(uint64_t (**)(uint64_t, char *, unint64_t, _QWORD, uint64_t))(*(_QWORD *)a1 + 104);
  v19 = a1[2];
  while (v16 <= 3)
  {
    v20 = v18(v19, (char *)&v33 + v16, 4 - v16, 0, v17);
    v16 += v20;
    if (v20 < 0)
    {
      LODWORD(v16) = v20;
      break;
    }
  }
  if ((v16 & 0x80000000) != 0)
  {
    if ((_DWORD)v16 != -35)
    {
      v30 = *(_QWORD *)a1;
      v31 = "agent recv failed";
      v32 = 4294967253;
      return _libssh2_error(v30, v32, v31);
    }
    return 4294967259;
  }
  a2[3] = _libssh2_ntohu32(&v33);
  v21 = (*(uint64_t (**)(void))(*(_QWORD *)a1 + 8))();
  a2[2] = v21;
  if (!v21)
    return 4294967290;
  v22 = v21;
  *((_DWORD *)a2 + 8) = 4;
LABEL_25:
  v24 = 0;
  v25 = *(_QWORD *)a1;
  v26 = *(uint64_t (**)(uint64_t, unint64_t, unint64_t, _QWORD, uint64_t))(*(_QWORD *)a1 + 104);
  v27 = a1[2];
  v28 = a2[3];
  while (v28 > v24)
  {
    v29 = v26(v27, v22 + v24, v28 - v24, 0, v25);
    v24 += v29;
    if (v29 < 0)
    {
      LODWORD(v24) = v29;
      break;
    }
  }
  if ((v24 & 0x80000000) == 0)
  {
    result = 0;
    *((_DWORD *)a2 + 8) = 5;
    return result;
  }
  if ((_DWORD)v24 == -35)
    return 4294967259;
  v30 = *(_QWORD *)a1;
  v31 = "agent recv failed";
LABEL_36:
  v32 = 4294967289;
  return _libssh2_error(v30, v32, v31);
}

uint64_t agent_disconnect_unix(uint64_t a1)
{
  if (close(*(_DWORD *)(a1 + 8)) == -1)
    return _libssh2_error(*(_QWORD *)a1, 4294967283, "failed closing the agent socket");
  *(_DWORD *)(a1 + 8) = -1;
  return 0;
}

char ***libssh2_crypt_methods()
{
  return _libssh2_crypt_methods;
}

uint64_t crypt_init(uint64_t a1, uint64_t a2, unsigned __int8 *a3, _DWORD *a4, const unsigned __int8 *a5, _DWORD *a6, int a7, uint64_t *a8)
{
  uint64_t v16;
  uint64_t v17;
  void *(*v18)();
  uint64_t result;

  v16 = (*(uint64_t (**)(uint64_t, uint64_t))(a1 + 8))(24, a1);
  if (!v16)
    return 4294967290;
  v17 = v16;
  *(_DWORD *)v16 = a7;
  v18 = *(void *(**)())(a2 + 64);
  *(_QWORD *)(v16 + 8) = v18;
  result = _libssh2_cipher_init((EVP_CIPHER_CTX **)(v16 + 16), v18, a3, a5, a7);
  if ((_DWORD)result)
  {
    (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v17, a1);
    return 0xFFFFFFFFLL;
  }
  else
  {
    *a8 = v17;
    *a4 = 1;
    *a6 = 1;
  }
  return result;
}

uint64_t crypt_encrypt(uint64_t a1, const unsigned __int8 *a2, unint64_t a3, int **a4, int a5)
{
  return _libssh2_cipher_crypt((EVP_CIPHER_CTX **)*a4 + 2, *((void *(**)())*a4 + 1), **a4, a2, a3, a5);
}

uint64_t crypt_dtor(uint64_t a1, _QWORD *a2)
{
  if (a2 && *a2)
  {
    EVP_CIPHER_CTX_free(*(EVP_CIPHER_CTX **)(*a2 + 16));
    (*(void (**)(_QWORD, uint64_t))(a1 + 24))(*a2, a1);
    *a2 = 0;
  }
  return 0;
}

uint64_t crypt_init_arcfour128(uint64_t a1, uint64_t a2, unsigned __int8 *a3, _DWORD *a4, const unsigned __int8 *a5, _DWORD *a6, int a7, uint64_t *a8)
{
  uint64_t v10;
  uint64_t v11;
  EVP_CIPHER_CTX **v12;
  uint64_t v13;
  unsigned __int8 v15[8];
  uint64_t v16;

  v16 = *MEMORY[0x24BDAC8D0];
  v10 = crypt_init(a1, a2, a3, a4, a5, a6, a7, a8);
  if (!(_DWORD)v10)
  {
    v11 = *a8;
    v12 = (EVP_CIPHER_CTX **)(*a8 + 16);
    v13 = -1536;
    do
    {
      _libssh2_cipher_crypt(v12, *(void *(**)())(v11 + 8), *(_DWORD *)v11, v15, *(int *)(a2 + 16), 0);
      v13 += 8;
    }
    while (v13);
  }
  return v10;
}

double libssh2_scp_recv(uint64_t a1, char *a2, uint64_t a3)
{
  _OWORD *v6;
  time_t v7;
  uint64_t v8;
  double result;
  BOOL v10;
  uint64_t v11;
  uint64_t v12;
  _OWORD v13[2];
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;

  v19 = 0u;
  v20 = 0u;
  v17 = 0u;
  v18 = 0u;
  if (a3)
    v6 = v13;
  else
    v6 = 0;
  v15 = 0uLL;
  v16 = 0uLL;
  v14 = 0uLL;
  memset(v13, 0, sizeof(v13));
  v7 = time(0);
  do
  {
    v8 = scp_recv(a1, a2, (uint64_t)v6);
    if (*(_DWORD *)(a1 + 172))
      v10 = v8 == 0;
    else
      v10 = 0;
  }
  while (v10 && libssh2_session_last_errno(a1) == -37 && !_libssh2_wait_socket(a1, v7));
  if (a3)
  {
    result = 0.0;
    v11 = v15;
    v12 = v14;
    *(_OWORD *)(a3 + 32) = 0u;
    *(_OWORD *)(a3 + 48) = 0u;
    *(_QWORD *)(a3 + 48) = v11;
    *(_OWORD *)(a3 + 112) = 0u;
    *(_OWORD *)(a3 + 128) = 0u;
    *(_OWORD *)(a3 + 80) = 0u;
    *(_OWORD *)(a3 + 96) = 0u;
    *(_OWORD *)(a3 + 64) = 0u;
    *(_OWORD *)a3 = 0u;
    *(_OWORD *)(a3 + 16) = 0u;
    *(_QWORD *)(a3 + 32) = v12;
    *(_QWORD *)(a3 + 96) = v18;
    *(_WORD *)(a3 + 4) = WORD2(v13[0]);
  }
  return result;
}

uint64_t scp_recv(uint64_t a1, char *__s, uint64_t a3)
{
  uint64_t v5;
  int v6;
  size_t v8;
  uint64_t v9;
  char *v10;
  const char *v11;
  const char *v12;
  size_t v13;
  size_t v14;
  size_t v15;
  uint64_t v16;
  char *v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  int v21;
  uint64_t result;
  unint64_t v23;
  unint64_t v24;
  uint64_t v25;
  unsigned int v26;
  unint64_t v28;
  const char *v29;
  unint64_t v30;
  uint64_t v31;
  unsigned int v32;
  uint64_t v35;
  uint64_t v36;
  char *v37;
  uint64_t v38;
  unint64_t v39;
  uint64_t v40;
  uint64_t v41;
  _BYTE *j;
  int v43;
  char *v45;
  char *v46;
  _BYTE *i;
  int v48;
  char *v50;
  char *v51;
  char *v52;
  const char *v53;
  char *v54;
  int v55;
  char *v56;
  int v57;
  uint64_t v58;
  int v59;
  char *__endptr;

  v5 = a1 + 72936;
  v6 = *(_DWORD *)(a1 + 72936);
  switch(v6)
  {
    case 0:
      *(_OWORD *)(a1 + 73224) = 0u;
      *(_OWORD *)(a1 + 73240) = 0u;
      v8 = 3 * strlen(__s);
      v9 = 10;
      if (a3)
        v9 = 11;
      *(_QWORD *)(v5 + 16) = v9 + v8;
      v10 = (char *)(*(uint64_t (**)(void))(a1 + 8))();
      *(_QWORD *)(v5 + 8) = v10;
      if (!v10)
      {
        v17 = "Unable to allocate a command buffer for SCP session";
        v18 = a1;
        v19 = 4294967290;
        goto LABEL_30;
      }
      v11 = "p";
      if (!a3)
        v11 = "";
      snprintf(v10, *(_QWORD *)(v5 + 16), "scp -%sf ", v11);
      v12 = *(const char **)(v5 + 8);
      v13 = strlen(v12);
      v14 = v13;
      if (*(_DWORD *)(a1 + 140))
      {
        v15 = (size_t)shell_quotearg(__s, &v12[v13], *(_QWORD *)(v5 + 16) - v13);
      }
      else
      {
        v15 = strlen(__s);
        memcpy((void *)&v12[v14], __s, v15);
      }
      *(_QWORD *)(v5 + 16) = v15 + v14;
      *(_DWORD *)v5 = 2;
      goto LABEL_17;
    case 2:
LABEL_17:
      v16 = _libssh2_channel_open(a1, "session", 7u, 0x200000u, 0x8000u, 0, 0);
      *(_QWORD *)(v5 + 320) = v16;
      if (!v16)
      {
        if (libssh2_session_last_errno(a1) == -37)
        {
          v17 = "Would block starting up channel";
          goto LABEL_29;
        }
        (*(void (**)(_QWORD, uint64_t))(a1 + 24))(*(_QWORD *)(v5 + 8), a1);
        result = 0;
        *(_QWORD *)(v5 + 8) = 0;
LABEL_135:
        *(_DWORD *)v5 = 0;
        return result;
      }
      *(_DWORD *)v5 = 3;
LABEL_19:
      v20 = _libssh2_channel_process_startup(v16, "exec", 4uLL, *(const void **)(v5 + 8), *(_QWORD *)(v5 + 16));
      if (v20)
      {
        if (v20 == -37)
        {
          v17 = "Would block requesting SCP startup";
          goto LABEL_29;
        }
        (*(void (**)(_QWORD, uint64_t))(a1 + 24))(*(_QWORD *)(v5 + 8), a1);
        *(_QWORD *)(v5 + 8) = 0;
LABEL_132:
        v57 = *(_DWORD *)(a1 + 616);
        v58 = *(_QWORD *)(a1 + 608);
        while (libssh2_channel_free(*(_QWORD *)(v5 + 320)) == -37)
          ;
        result = 0;
        *(_DWORD *)(a1 + 616) = v57;
        *(_QWORD *)(a1 + 608) = v58;
        *(_QWORD *)(v5 + 320) = 0;
        goto LABEL_135;
      }
      (*(void (**)(_QWORD, uint64_t))(a1 + 24))(*(_QWORD *)(v5 + 8), a1);
      *(_QWORD *)(v5 + 8) = 0;
      *(_BYTE *)(v5 + 24) = 0;
      *(_DWORD *)v5 = 4;
LABEL_23:
      v21 = _libssh2_channel_write(*(_QWORD *)(v5 + 320), 0, (const void *)(a1 + 72960), 1uLL);
      if (v21 != 1)
      {
        if (v21 == -37)
        {
          v17 = "Would block sending initial wakeup";
          goto LABEL_29;
        }
        goto LABEL_132;
      }
      *(_QWORD *)(v5 + 280) = 0;
      *(_DWORD *)v5 = 5;
LABEL_32:
      if (!a3)
        goto LABEL_51;
      v23 = *(_QWORD *)(v5 + 280);
      if (v23 > 0xFF)
        goto LABEL_51;
      break;
    case 3:
      v16 = *(_QWORD *)(a1 + 73256);
      goto LABEL_19;
    case 4:
      goto LABEL_23;
    default:
      if ((v6 - 5) <= 1)
        goto LABEL_32;
      if (v6 == 7)
        goto LABEL_51;
      if ((v6 & 0xFFFFFFFE) != 8)
        goto LABEL_74;
      goto LABEL_52;
  }
  while (1)
  {
    if (*(_DWORD *)v5 != 5)
    {
      if (*(_DWORD *)v5 == 6)
        goto LABEL_118;
      goto LABEL_50;
    }
    v24 = _libssh2_channel_read(*(_QWORD *)(v5 + 320), 0, v5 + 24 + v23, 1uLL);
    v19 = v24;
    if ((_DWORD)v24 == -37)
    {
      v17 = "Would block waiting for SCP response";
      v18 = a1;
      goto LABEL_30;
    }
    if ((v24 & 0x80000000) != 0)
    {
LABEL_79:
      v37 = "Failed reading SCP response";
      v38 = a1;
      goto LABEL_131;
    }
    if (!(_DWORD)v24)
    {
LABEL_80:
      if (libssh2_channel_eof(*(_QWORD *)(v5 + 320)))
      {
        v37 = "Unexpected channel close";
        goto LABEL_130;
      }
      return *(_QWORD *)(v5 + 320);
    }
    v25 = *(_QWORD *)(v5 + 280);
    v23 = v25 + 1;
    *(_QWORD *)(v5 + 280) = v25 + 1;
    if (*(_BYTE *)(v5 + 24) != 84)
    {
      v39 = _libssh2_channel_packet_data_len(*(_QWORD *)(v5 + 320), 0);
      v40 = (*(uint64_t (**)(unint64_t, uint64_t))(a1 + 8))(v39 + 1, a1);
      if (v40)
      {
        v41 = v40;
        _libssh2_channel_read(*(_QWORD *)(v5 + 320), 0, v40, v39);
        *(_BYTE *)(v41 + v39) = 0;
        _libssh2_error(a1, 4294967268, "Failed to recv file");
        (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v41, a1);
        goto LABEL_132;
      }
      v37 = "Failed to get memory ";
      v38 = a1;
      v19 = 4294967290;
LABEL_131:
      _libssh2_error(v38, v19, v37);
      goto LABEL_132;
    }
    if (v23 >= 2)
    {
      v26 = *(unsigned __int8 *)(a1 + v25 + 72960);
      if (v26 - 58 <= 0xFFFFFFF5 && (v26 > 0x20 || ((1 << v26) & 0x100002400) == 0))
      {
LABEL_101:
        v37 = "Invalid data in SCP response";
        goto LABEL_130;
      }
      if (v23 >= 9)
        break;
    }
LABEL_50:
    if (v23 >= 0x100)
      goto LABEL_51;
  }
  if (v26 != 10)
  {
    if (v25 == 255)
    {
LABEL_86:
      v37 = "Unterminated response from SCP server";
      goto LABEL_130;
    }
    goto LABEL_50;
  }
  for (i = (_BYTE *)(a1 + v25 + 72961); ; --i)
  {
    v48 = *(i - 1);
    if (v48 != 13 && v48 != 10)
      break;
    *(_QWORD *)(v5 + 280) = v25--;
  }
  *i = 0;
  if (*(_QWORD *)(v5 + 280) <= 7uLL)
    goto LABEL_110;
  v50 = strchr((char *)(a1 + 72961), 32);
  if (!v50 || (uint64_t)&v50[-a1 - 72961] <= 0)
  {
    v37 = "Invalid response from SCP server, malformed mtime";
LABEL_130:
    v38 = a1;
    v19 = 4294967268;
    goto LABEL_131;
  }
  *v50 = 0;
  v51 = v50 + 1;
  *(_QWORD *)(v5 + 304) = strtol((const char *)(a1 + 72961), 0, 10);
  v52 = strchr(v51, 32);
  if (!v52 || v52 - v51 <= 0)
  {
    v37 = "Invalid response from SCP server, malformed mtime.usec";
    goto LABEL_130;
  }
  v53 = v52 + 1;
  v54 = strchr(v52 + 1, 32);
  if (!v54 || v54 - v53 <= 0)
    goto LABEL_128;
  *v54 = 0;
  *(_QWORD *)(v5 + 312) = strtol(v53, 0, 10);
  *(_BYTE *)(v5 + 24) = 0;
  *(_DWORD *)v5 = 6;
LABEL_118:
  v55 = _libssh2_channel_write(*(_QWORD *)(v5 + 320), 0, (const void *)(v5 + 24), 1uLL);
  if (v55 != 1)
  {
    if (v55 != -37)
      goto LABEL_132;
    v17 = "Would block waiting to send SCP ACK";
LABEL_29:
    v18 = a1;
    v19 = 4294967259;
LABEL_30:
    _libssh2_error(v18, v19, v17);
    return 0;
  }
LABEL_51:
  *(_QWORD *)(v5 + 280) = 0;
  *(_DWORD *)v5 = 8;
LABEL_52:
  v28 = *(_QWORD *)(v5 + 280);
  if (v28 > 0xFF)
    goto LABEL_74;
  v29 = "Would block waiting for SCP response";
  while (2)
  {
    __endptr = 0;
    if (*(_DWORD *)v5 != 8)
    {
      if (*(_DWORD *)v5 == 9)
        goto LABEL_137;
      goto LABEL_73;
    }
    v30 = _libssh2_channel_read(*(_QWORD *)(v5 + 320), 0, v5 + 24 + v28, 1uLL);
    v19 = v30;
    if ((_DWORD)v30 == -37)
      goto LABEL_141;
    if ((v30 & 0x80000000) != 0)
      goto LABEL_79;
    if (!(_DWORD)v30)
      goto LABEL_80;
    v31 = *(_QWORD *)(v5 + 280);
    v28 = v31 + 1;
    *(_QWORD *)(v5 + 280) = v31 + 1;
    if (*(_BYTE *)(v5 + 24) != 67)
    {
      v37 = "Invalid response from SCP server";
      goto LABEL_130;
    }
    if (v28 < 2)
      goto LABEL_73;
    v32 = *(unsigned __int8 *)(a1 + v31 + 72960);
    if (v32 != 10 && v32 != 13 && v32 <= 0x1F)
      goto LABEL_101;
    if (v28 < 7)
      goto LABEL_73;
    if (v32 != 10)
    {
      if (v31 == 255)
        goto LABEL_86;
LABEL_73:
      if (v28 >= 0x100)
        goto LABEL_74;
      continue;
    }
    break;
  }
  for (j = (_BYTE *)(a1 + v31 + 72961); ; --j)
  {
    v43 = *(j - 1);
    if (v43 != 13 && v43 != 10)
      break;
    *(_QWORD *)(v5 + 280) = v31--;
  }
  *j = 0;
  if (*(_QWORD *)(v5 + 280) <= 5uLL)
  {
LABEL_110:
    v37 = "Invalid response from SCP server, too short";
    goto LABEL_130;
  }
  v45 = strchr((char *)(a1 + 72961), 32);
  if (!v45 || (uint64_t)&v45[-a1 - 72961] <= 0)
  {
    v37 = "Invalid response from SCP server, malformed mode";
    goto LABEL_130;
  }
  *v45 = 0;
  v46 = v45 + 1;
  *(_QWORD *)(v5 + 288) = strtol((const char *)(a1 + 72961), &__endptr, 8);
  if (__endptr && *__endptr)
  {
    v37 = "Invalid response from SCP server, invalid mode";
    goto LABEL_130;
  }
  v56 = strchr(v46, 32);
  if (!v56 || v56 - v46 <= 0)
  {
LABEL_128:
    v37 = "Invalid response from SCP server, too short or malformed";
    goto LABEL_130;
  }
  *v56 = 0;
  *(_QWORD *)(v5 + 296) = strtoll(v46, &__endptr, 10);
  if (__endptr && *__endptr)
  {
    v37 = "Invalid response from SCP server, invalid size";
    goto LABEL_130;
  }
  *(_BYTE *)(v5 + 24) = 0;
  *(_DWORD *)v5 = 9;
LABEL_137:
  v59 = _libssh2_channel_write(*(_QWORD *)(v5 + 320), 0, (const void *)(v5 + 24), 1uLL);
  if (v59 == -37)
  {
    v29 = "Would block sending SCP ACK";
LABEL_141:
    v18 = a1;
    v19 = 4294967259;
    v17 = (char *)v29;
    goto LABEL_30;
  }
  if (v59 != 1)
    goto LABEL_132;
LABEL_74:
  if (a3)
  {
    *(_OWORD *)(a3 + 112) = 0u;
    *(_OWORD *)(a3 + 128) = 0u;
    *(_OWORD *)(a3 + 80) = 0u;
    *(_OWORD *)(a3 + 96) = 0u;
    *(_OWORD *)(a3 + 48) = 0u;
    *(_OWORD *)(a3 + 64) = 0u;
    *(_OWORD *)(a3 + 16) = 0u;
    *(_OWORD *)(a3 + 32) = 0u;
    *(_OWORD *)a3 = 0u;
    v35 = *(_QWORD *)(v5 + 312);
    *(_QWORD *)(a3 + 48) = *(_QWORD *)(v5 + 304);
    *(_QWORD *)(a3 + 32) = v35;
    v36 = *(_QWORD *)(v5 + 288);
    *(_QWORD *)(a3 + 96) = *(_QWORD *)(v5 + 296);
    *(_WORD *)(a3 + 4) = v36;
  }
  *(_DWORD *)v5 = 0;
  return *(_QWORD *)(v5 + 320);
}

uint64_t libssh2_scp_recv2(uint64_t a1, char *a2, uint64_t a3)
{
  time_t v6;
  uint64_t result;

  v6 = time(0);
  while (1)
  {
    result = scp_recv(a1, a2, a3);
    if (!*(_DWORD *)(a1 + 172) || result != 0)
      break;
    if (libssh2_session_last_errno(a1) != -37 || _libssh2_wait_socket(a1, v6))
      return 0;
  }
  return result;
}

uint64_t libssh2_scp_send_ex(uint64_t a1, char *a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  time_t v12;
  uint64_t result;

  v12 = time(0);
  while (1)
  {
    result = scp_send(a1, a2, a3, a4, a5, a6);
    if (!*(_DWORD *)(a1 + 172) || result != 0)
      break;
    if (libssh2_session_last_errno(a1) != -37 || _libssh2_wait_socket(a1, v12))
      return 0;
  }
  return result;
}

uint64_t scp_send(uint64_t a1, char *__s, int a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v12;
  int v13;
  size_t v14;
  uint64_t v15;
  char *v16;
  const char *v17;
  const char *v18;
  size_t v19;
  size_t v20;
  size_t v21;
  int v22;
  uint64_t v23;
  char *v24;
  uint64_t v25;
  uint64_t v26;
  unint64_t v27;
  int v28;
  unint64_t v29;
  int v30;
  char *v31;
  uint64_t result;
  unint64_t v33;
  uint64_t v34;
  char *v35;
  const char *v36;
  int v37;
  int v38;
  unint64_t v39;
  uint64_t v40;
  uint64_t v41;
  int v42;
  uint64_t v43;

  v12 = a1 + 73264;
  v13 = *(_DWORD *)(a1 + 73264);
  switch(v13)
  {
    case 0:
      v14 = 3 * strlen(__s);
      v15 = 10;
      if (a6 | a5)
        v15 = 11;
      *(_QWORD *)(v12 + 16) = v15 + v14;
      v16 = (char *)(*(uint64_t (**)(void))(a1 + 8))();
      *(_QWORD *)(v12 + 8) = v16;
      if (!v16)
      {
        v24 = "Unable to allocate a command buffer for SCP session";
        v25 = a1;
        v26 = 4294967290;
LABEL_58:
        _libssh2_error(v25, v26, v24);
        return 0;
      }
      v17 = "p";
      if (!(a6 | a5))
        v17 = "";
      snprintf(v16, *(_QWORD *)(v12 + 16), "scp -%st ", v17);
      v18 = *(const char **)(v12 + 8);
      v19 = strlen(v18);
      v20 = v19;
      if (*(_DWORD *)(a1 + 140))
      {
        v21 = (size_t)shell_quotearg(__s, &v18[v19], *(_QWORD *)(v12 + 16) - v19);
      }
      else
      {
        v21 = strlen(__s);
        memcpy((void *)&v18[v20], __s, v21);
      }
      *(_QWORD *)(v12 + 16) = v21 + v20;
      *(_DWORD *)v12 = 2;
LABEL_17:
      v23 = _libssh2_channel_open(a1, "session", 7u, 0x200000u, 0x8000u, 0, 0);
      *(_QWORD *)(v12 + 288) = v23;
      if (!v23)
      {
        if (libssh2_session_last_errno(a1) == -37)
        {
          v24 = "Would block starting up channel";
          goto LABEL_57;
        }
        (*(void (**)(_QWORD, uint64_t))(a1 + 24))(*(_QWORD *)(v12 + 8), a1);
        result = 0;
        *(_QWORD *)(v12 + 8) = 0;
        goto LABEL_73;
      }
      *(_DWORD *)v12 = 3;
LABEL_19:
      v28 = _libssh2_channel_process_startup(v23, "exec", 4uLL, *(const void **)(v12 + 8), *(_QWORD *)(v12 + 16));
      if (v28)
      {
        if (v28 == -37)
        {
          v24 = "Would block requesting SCP startup";
LABEL_57:
          v25 = a1;
          v26 = 4294967259;
          goto LABEL_58;
        }
        (*(void (**)(_QWORD, uint64_t))(a1 + 24))(*(_QWORD *)(v12 + 8), a1);
        *(_QWORD *)(v12 + 8) = 0;
        v31 = "Unknown error while getting error string";
        goto LABEL_69;
      }
      (*(void (**)(_QWORD, uint64_t))(a1 + 24))(*(_QWORD *)(v12 + 8), a1);
      *(_QWORD *)(v12 + 8) = 0;
      *(_DWORD *)v12 = 4;
LABEL_23:
      v29 = _libssh2_channel_read(*(_QWORD *)(v12 + 288), 0, v12 + 24, 1uLL);
      v26 = v29;
      if ((_DWORD)v29 == -37)
      {
        v24 = "Would block waiting for response from remote";
LABEL_25:
        v25 = a1;
        goto LABEL_58;
      }
      if ((v29 & 0x80000000) != 0)
        goto LABEL_45;
      if (!(_DWORD)v29)
        goto LABEL_67;
      if (*(_BYTE *)(v12 + 24))
        goto LABEL_66;
      if (!(a6 | a5))
        goto LABEL_46;
      *(_QWORD *)(v12 + 280) = snprintf((char *)(v12 + 24), 0x100uLL, "T%ld 0 %ld 0\n", a5, a6);
      *(_DWORD *)v12 = 5;
LABEL_31:
      v30 = _libssh2_channel_write(*(_QWORD *)(v12 + 288), 0, (const void *)(a1 + 73288), *(_QWORD *)(v12 + 280));
      if (v30 == -37)
      {
        v24 = "Would block sending time data for SCP file";
        goto LABEL_57;
      }
      if (v30 != *(_DWORD *)(v12 + 280))
      {
        v31 = "Unable to send time data for SCP file";
        goto LABEL_78;
      }
      *(_DWORD *)v12 = 6;
LABEL_39:
      v33 = _libssh2_channel_read(*(_QWORD *)(v12 + 288), 0, v12 + 24, 1uLL);
      v26 = v33;
      if ((_DWORD)v33 == -37)
      {
        v24 = "Would block waiting for response";
        goto LABEL_25;
      }
      if ((v33 & 0x80000000) != 0)
      {
LABEL_45:
        v31 = "SCP failure";
        v34 = a1;
        goto LABEL_70;
      }
      if (!(_DWORD)v33)
      {
LABEL_67:
        if (libssh2_channel_eof(*(_QWORD *)(v12 + 288)))
        {
          v31 = "Unexpected channel close";
          goto LABEL_69;
        }
        return *(_QWORD *)(v12 + 288);
      }
      if (*(_BYTE *)(v12 + 24))
      {
        v31 = "Invalid SCP ACK response";
LABEL_69:
        v34 = a1;
        v26 = 4294967268;
        goto LABEL_70;
      }
LABEL_46:
      *(_DWORD *)v12 = 7;
LABEL_47:
      v35 = strrchr(__s, 47);
      if (v35)
        v36 = v35 + 1;
      else
        v36 = __s;
      v27 = snprintf((char *)(a1 + 73288), 0x100uLL, "C0%o %lld %s\n", a3, a4, v36);
      *(_QWORD *)(v12 + 280) = v27;
      *(_DWORD *)v12 = 8;
LABEL_51:
      v37 = _libssh2_channel_write(*(_QWORD *)(v12 + 288), 0, (const void *)(a1 + 73288), v27);
      if (v37 == -37)
      {
        v24 = "Would block send core file data for SCP file";
        goto LABEL_57;
      }
      if (v37 != *(_DWORD *)(v12 + 280))
      {
        v31 = "Unable to send core file data for SCP file";
LABEL_78:
        v34 = a1;
        v26 = 4294967289;
        goto LABEL_70;
      }
      *(_DWORD *)v12 = 9;
LABEL_55:
      v38 = _libssh2_channel_read(*(_QWORD *)(v12 + 288), 0, v12 + 24, 1uLL);
      if (v38 == -37)
      {
        v24 = "Would block waiting for response";
        goto LABEL_57;
      }
      if (v38 < 0)
      {
LABEL_66:
        v31 = "Invalid ACK response from remote";
        goto LABEL_69;
      }
      if (!v38)
        goto LABEL_67;
      if (*(_BYTE *)(v12 + 24))
      {
        v39 = _libssh2_channel_packet_data_len(*(_QWORD *)(v12 + 288), 0);
        v40 = (*(uint64_t (**)(unint64_t, uint64_t))(a1 + 8))(v39 + 1, a1);
        if (v40)
        {
          v41 = v40;
          if ((int)_libssh2_channel_read(*(_QWORD *)(v12 + 288), 0, v40, v39) >= 1)
            *(_BYTE *)(v41 + v39) = 0;
          (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v41, a1);
          v31 = "failed to send file";
          goto LABEL_69;
        }
        v31 = "failed to get memory";
        v34 = a1;
        v26 = 4294967290;
LABEL_70:
        _libssh2_error(v34, v26, v31);
        v42 = *(_DWORD *)(a1 + 616);
        v43 = *(_QWORD *)(a1 + 608);
        while (libssh2_channel_free(*(_QWORD *)(v12 + 288)) == -37)
          ;
        result = 0;
        *(_DWORD *)(a1 + 616) = v42;
        *(_QWORD *)(a1 + 608) = v43;
        *(_QWORD *)(v12 + 288) = 0;
LABEL_73:
        *(_DWORD *)v12 = 0;
        return result;
      }
LABEL_74:
      *(_DWORD *)v12 = 0;
      return *(_QWORD *)(v12 + 288);
    case 2:
      goto LABEL_17;
    case 3:
      v23 = *(_QWORD *)(a1 + 73552);
      goto LABEL_19;
    case 4:
      goto LABEL_23;
    default:
      v22 = v13 - 5;
      if (a6 | a5)
      {
        switch(v22)
        {
          case 0:
            goto LABEL_31;
          case 1:
            goto LABEL_39;
          case 2:
            goto LABEL_47;
          case 3:
            goto LABEL_14;
          case 4:
            goto LABEL_55;
          default:
            goto LABEL_74;
        }
      }
      switch(v22)
      {
        case 0:
          goto LABEL_46;
        case 2:
          goto LABEL_47;
        case 3:
LABEL_14:
          v27 = *(_QWORD *)(a1 + 73544);
          goto LABEL_51;
        case 4:
          goto LABEL_55;
        default:
          goto LABEL_74;
      }
  }
}

uint64_t libssh2_scp_send64(uint64_t a1, char *a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  time_t v12;
  uint64_t result;

  v12 = time(0);
  while (1)
  {
    result = scp_send(a1, a2, a3, a4, a5, a6);
    if (!*(_DWORD *)(a1 + 172) || result != 0)
      break;
    if (libssh2_session_last_errno(a1) != -37 || _libssh2_wait_socket(a1, v12))
      return 0;
  }
  return result;
}

char *shell_quotearg(char *a1, _WORD *a2, uint64_t a3)
{
  unint64_t v3;
  unint64_t v4;
  char v5;
  BOOL v6;
  _WORD *v7;
  int v9;
  char *v10;
  _BYTE *v11;
  _WORD *v12;
  char v13;

  v3 = (unint64_t)a2 + a3;
  v4 = (unint64_t)a2 + a3 - 1;
  v5 = *a1;
  if (*a1)
    v6 = v4 > (unint64_t)a2;
  else
    v6 = 0;
  v7 = a2;
  if (!v6)
    goto LABEL_5;
  v9 = 0;
  v10 = a1 + 1;
  v7 = a2;
  do
  {
    if (v5 != 33)
    {
      if (v5 == 39)
      {
        if (v9 == 1)
        {
          v11 = v7 + 1;
          if ((unint64_t)(v7 + 1) >= v3)
            return 0;
          *v7 = 8743;
          goto LABEL_24;
        }
        if (!v9)
        {
          v11 = (char *)v7 + 1;
          if ((unint64_t)v7 + 1 >= v3)
            return 0;
          *(_BYTE *)v7 = 34;
LABEL_24:
          v9 = 2;
          goto LABEL_35;
        }
        v9 = 2;
        goto LABEL_34;
      }
      if (v9 == 2)
      {
        v11 = v7 + 1;
        if ((unint64_t)(v7 + 1) >= v3)
          return 0;
        *v7 = 10018;
      }
      else
      {
        if (v9)
        {
          v9 = 1;
LABEL_34:
          v11 = v7;
          goto LABEL_35;
        }
        v11 = (char *)v7 + 1;
        if ((unint64_t)v7 + 1 >= v3)
          return 0;
        *(_BYTE *)v7 = 39;
      }
      v9 = 1;
      goto LABEL_35;
    }
    if (v9 == 2)
    {
      v11 = v7 + 1;
      if ((unint64_t)(v7 + 1) >= v3)
        return 0;
      v9 = 0;
      *v7 = 23586;
    }
    else if (v9 == 1)
    {
      v11 = v7 + 1;
      if ((unint64_t)(v7 + 1) >= v3)
        return 0;
      v9 = 0;
      *v7 = 23591;
    }
    else
    {
      v11 = (char *)v7 + 1;
      if ((unint64_t)v7 + 1 >= v3)
        return 0;
      v9 = 0;
      *(_BYTE *)v7 = 92;
    }
LABEL_35:
    v7 = v11 + 1;
    if ((unint64_t)(v11 + 1) >= v3)
      return 0;
    *v11 = *(v10 - 1);
    v5 = *v10;
    if (!*v10)
      break;
    ++v10;
  }
  while ((unint64_t)v7 < v4);
  if (v9 == 1)
  {
    v12 = v11 + 2;
    if ((unint64_t)(v11 + 2) >= v3)
      return 0;
    v13 = 39;
LABEL_44:
    *(_BYTE *)v7 = v13;
    v7 = v12;
    goto LABEL_5;
  }
  if (v9 != 2)
  {
LABEL_5:
    if ((unint64_t)v7 + 1 >= v3)
      return 0;
    *(_BYTE *)v7 = 0;
    return (char *)((char *)v7 - (char *)a2);
  }
  v12 = v11 + 2;
  if ((unint64_t)(v11 + 2) < v3)
  {
    v13 = 34;
    goto LABEL_44;
  }
  return 0;
}

uint64_t _libssh2_openssl_random(unsigned __int8 *a1, unint64_t a2)
{
  if (a2 >> 31)
    return 0xFFFFFFFFLL;
  if (RAND_bytes(a1, a2) == 1)
    return 0;
  return 0xFFFFFFFFLL;
}

uint64_t _libssh2_rsa_new(uint64_t *a1, const unsigned __int8 *a2, int a3, const unsigned __int8 *a4, int a5, BIGNUM *a6, int a7, const unsigned __int8 *a8, int a9, const unsigned __int8 *a10, int a11, const unsigned __int8 *a12, int a13, const unsigned __int8 *a14, int a15, const unsigned __int8 *a16, int a17)
{
  BIGNUM *v25;
  BIGNUM *v26;
  BIGNUM *v27;
  BIGNUM *v28;
  BIGNUM *v29;
  BIGNUM *v30;
  BIGNUM *v31;
  RSA *v32;

  v25 = BN_new();
  BN_bin2bn(a2, a3, v25);
  v26 = BN_new();
  BN_bin2bn(a4, a5, v26);
  if (a6)
  {
    v27 = BN_new();
    BN_bin2bn((const unsigned __int8 *)a6, a7, v27);
    v28 = BN_new();
    BN_bin2bn(a8, a9, v28);
    v29 = BN_new();
    BN_bin2bn(a10, a11, v29);
    v30 = BN_new();
    BN_bin2bn(a12, a13, v30);
    a6 = BN_new();
    BN_bin2bn(a14, a15, a6);
    v31 = BN_new();
    BN_bin2bn(a16, a17, v31);
  }
  else
  {
    v27 = 0;
    v28 = 0;
    v29 = 0;
    v30 = 0;
    v31 = 0;
  }
  v32 = RSA_new();
  *a1 = (uint64_t)v32;
  RSA_set0_key((uint64_t)v32, (uint64_t)v26, (uint64_t)v25, (uint64_t)v27);
  RSA_set0_factors(*a1, (uint64_t)v28, (uint64_t)v29);
  RSA_set0_crt_params(*a1, (uint64_t)v30, (uint64_t)a6, (uint64_t)v31);
  return 0;
}

uint64_t _libssh2_rsa_sha2_verify(RSA *a1, size_t size, unsigned __int8 *a3, unsigned int a4, const void *a5, size_t a6)
{
  unsigned __int8 *v12;
  unsigned __int8 *v13;
  int v14;
  int v15;
  int v16;
  int v18;
  int v19;

  v12 = (unsigned __int8 *)malloc_type_malloc(size, 0xDE968358uLL);
  if (!v12)
    return 0xFFFFFFFFLL;
  v13 = v12;
  if (size == 64)
  {
    v16 = _libssh2_sha512(a5, a6, v12);
    v15 = 674;
    if (!v16)
      goto LABEL_11;
LABEL_8:
    free(v13);
    return 0xFFFFFFFFLL;
  }
  if (size != 32)
  {
    if (size == 20)
    {
      v14 = _libssh2_sha1(a5, a6, v12);
      v15 = 64;
      if (!v14)
        goto LABEL_11;
    }
    goto LABEL_8;
  }
  v18 = _libssh2_sha256(a5, a6, v12);
  v15 = 672;
  if (v18)
    goto LABEL_8;
LABEL_11:
  v19 = RSA_verify(v15, v13, size, a3, a4, a1);
  free(v13);
  if (v19 == 1)
    return 0;
  else
    return 0xFFFFFFFFLL;
}

uint64_t _libssh2_sha1(const void *a1, size_t a2, unsigned __int8 *a3)
{
  EVP_MD_CTX *v6;
  EVP_MD_CTX *v7;
  const EVP_MD *digestbyname;
  uint64_t v9;

  v6 = (EVP_MD_CTX *)EVP_MD_CTX_new();
  if (!v6)
    return 1;
  v7 = v6;
  digestbyname = EVP_get_digestbyname("sha1");
  if (EVP_DigestInit(v7, digestbyname))
  {
    EVP_DigestUpdate(v7, a1, a2);
    EVP_DigestFinal(v7, a3, 0);
    v9 = 0;
  }
  else
  {
    v9 = 1;
  }
  EVP_MD_CTX_free(v7);
  return v9;
}

uint64_t _libssh2_sha256(const void *a1, size_t a2, unsigned __int8 *a3)
{
  EVP_MD_CTX *v6;
  EVP_MD_CTX *v7;
  const EVP_MD *digestbyname;
  uint64_t v9;

  v6 = (EVP_MD_CTX *)EVP_MD_CTX_new();
  if (!v6)
    return 1;
  v7 = v6;
  digestbyname = EVP_get_digestbyname("sha256");
  if (EVP_DigestInit(v7, digestbyname))
  {
    EVP_DigestUpdate(v7, a1, a2);
    EVP_DigestFinal(v7, a3, 0);
    v9 = 0;
  }
  else
  {
    v9 = 1;
  }
  EVP_MD_CTX_free(v7);
  return v9;
}

uint64_t _libssh2_sha512(const void *a1, size_t a2, unsigned __int8 *a3)
{
  EVP_MD_CTX *v6;
  EVP_MD_CTX *v7;
  const EVP_MD *digestbyname;
  uint64_t v9;

  v6 = (EVP_MD_CTX *)EVP_MD_CTX_new();
  if (!v6)
    return 1;
  v7 = v6;
  digestbyname = EVP_get_digestbyname("sha512");
  if (EVP_DigestInit(v7, digestbyname))
  {
    EVP_DigestUpdate(v7, a1, a2);
    EVP_DigestFinal(v7, a3, 0);
    v9 = 0;
  }
  else
  {
    v9 = 1;
  }
  EVP_MD_CTX_free(v7);
  return v9;
}

uint64_t _libssh2_rsa_sha1_verify(RSA *a1, unsigned __int8 *a2, unsigned int a3, const void *a4, size_t a5)
{
  return _libssh2_rsa_sha2_verify(a1, 0x14uLL, a2, a3, a4, a5);
}

uint64_t _libssh2_dsa_new(uint64_t *a1, const unsigned __int8 *a2, int a3, const unsigned __int8 *a4, int a5, const unsigned __int8 *a6, int a7, const unsigned __int8 *a8, int a9, const unsigned __int8 *a10, uint64_t a11)
{
  BIGNUM *v18;
  BIGNUM *v19;
  BIGNUM *v20;
  BIGNUM *v21;
  BIGNUM *v22;
  DSA *v23;

  v18 = BN_new();
  BN_bin2bn(a2, a3, v18);
  v19 = BN_new();
  BN_bin2bn(a4, a5, v19);
  v20 = BN_new();
  BN_bin2bn(a6, a7, v20);
  v21 = BN_new();
  BN_bin2bn(a8, a9, v21);
  if (a11)
  {
    v22 = BN_new();
    BN_bin2bn(a10, a11, v22);
  }
  else
  {
    v22 = 0;
  }
  v23 = DSA_new();
  *a1 = (uint64_t)v23;
  DSA_set0_pqg((uint64_t)v23, (uint64_t)v18, (uint64_t)v19, (uint64_t)v20);
  DSA_set0_key(*a1, (uint64_t)v21, (uint64_t)v22);
  return 0;
}

uint64_t _libssh2_dsa_sha1_verify(DSA *a1, const unsigned __int8 *a2, const void *a3, size_t a4)
{
  BIGNUM *v8;
  BIGNUM *v9;
  DSA_SIG *v10;
  uint64_t v11;
  unsigned __int8 dgst[20];
  uint64_t v14;

  v14 = *MEMORY[0x24BDAC8D0];
  v8 = BN_new();
  BN_bin2bn(a2, 20, v8);
  v9 = BN_new();
  BN_bin2bn(a2 + 20, 20, v9);
  v10 = DSA_SIG_new();
  DSA_SIG_set0(&v10->r, v8, v9);
  if (_libssh2_sha1(a3, a4, dgst))
  {
    v11 = 0xFFFFFFFFLL;
  }
  else if (DSA_do_verify(dgst, 20, v10, a1) == 1)
  {
    v11 = 0;
  }
  else
  {
    v11 = 0xFFFFFFFFLL;
  }
  DSA_SIG_free(v10);
  return v11;
}

uint64_t _libssh2_ecdsa_get_curve_type(const EC_KEY *a1)
{
  const EC_GROUP *v1;

  v1 = EC_KEY_get0_group(a1);
  return EC_GROUP_get_curve_name(v1);
}

uint64_t _libssh2_ecdsa_curve_type_from_name(const char *a1, int *a2)
{
  uint64_t result;
  int v5;
  BOOL v6;
  _BOOL4 v7;
  int v8;

  if (!a1)
    return 0xFFFFFFFFLL;
  if (strlen(a1) != 19)
    return 0xFFFFFFFFLL;
  result = strcmp(a1, "ecdsa-sha2-nistp256");
  if (!(_DWORD)result)
  {
    v8 = 415;
    goto LABEL_17;
  }
  result = strcmp(a1, "ecdsa-sha2-nistp384");
  if (!(_DWORD)result)
  {
    v8 = 715;
LABEL_17:
    v7 = 1;
    if (!a2)
      return result;
    goto LABEL_18;
  }
  v5 = strcmp(a1, "ecdsa-sha2-nistp521");
  v6 = v5 == 0;
  v7 = v5 == 0;
  if (v5)
    result = 0xFFFFFFFFLL;
  else
    result = 0;
  if (v6)
    v8 = 716;
  else
    v8 = 0;
  if (a2)
  {
LABEL_18:
    if (v7)
      *a2 = v8;
  }
  return result;
}

uint64_t _libssh2_ecdsa_curve_name_with_octal_new(EC_KEY **a1, const unsigned __int8 *a2, size_t a3, int nid)
{
  EC_KEY *v7;
  EC_KEY *v8;
  const EC_GROUP *v9;
  EC_POINT *v10;
  int v11;

  v7 = EC_KEY_new_by_curve_name(nid);
  if (v7)
  {
    v8 = v7;
    v9 = EC_KEY_get0_group(v7);
    v10 = EC_POINT_new(v9);
    EC_POINT_oct2point(v9, v10, a2, a3, 0);
    v11 = EC_KEY_set_public_key(v8, v10);
    if (v10)
      EC_POINT_free(v10);
    if (a1)
      *a1 = v8;
  }
  else
  {
    v11 = 0;
  }
  if (v11 == 1)
    return 0;
  else
    return 0xFFFFFFFFLL;
}

uint64_t _libssh2_ecdsa_verify(const EC_KEY *a1, const unsigned __int8 *a2, int a3, const unsigned __int8 *a4, int a5, const void *a6, size_t a7)
{
  const EC_GROUP *v13;
  int curve_name;
  ECDSA_SIG *v15;
  BIGNUM *v16;
  BIGNUM *v17;
  int v18;
  int v19;
  unsigned __int8 dgst[64];
  uint64_t v23;

  v23 = *MEMORY[0x24BDAC8D0];
  v13 = EC_KEY_get0_group(a1);
  curve_name = EC_GROUP_get_curve_name(v13);
  v15 = ECDSA_SIG_new();
  v16 = BN_new();
  v17 = BN_new();
  BN_bin2bn(a2, a3, v16);
  BN_bin2bn(a4, a5, v17);
  ECDSA_SIG_set0(&v15->r, v16, v17);
  switch(curve_name)
  {
    case 716:
      _libssh2_sha512(a6, a7, dgst);
      v18 = 64;
      goto LABEL_7;
    case 715:
      _libssh2_sha384(a6, a7, dgst);
      v18 = 48;
LABEL_7:
      v19 = ECDSA_do_verify(dgst, v18, v15, a1);
      if (!v15)
        goto LABEL_9;
      goto LABEL_8;
    case 415:
      _libssh2_sha256(a6, a7, dgst);
      v18 = 32;
      goto LABEL_7;
  }
  v19 = 0;
  if (v15)
LABEL_8:
    ECDSA_SIG_free(v15);
LABEL_9:
  if (v19 == 1)
    return 0;
  else
    return 0xFFFFFFFFLL;
}

uint64_t _libssh2_sha384(const void *a1, size_t a2, unsigned __int8 *a3)
{
  EVP_MD_CTX *v6;
  EVP_MD_CTX *v7;
  const EVP_MD *digestbyname;
  uint64_t v9;

  v6 = (EVP_MD_CTX *)EVP_MD_CTX_new();
  if (!v6)
    return 1;
  v7 = v6;
  digestbyname = EVP_get_digestbyname("sha384");
  if (EVP_DigestInit(v7, digestbyname))
  {
    EVP_DigestUpdate(v7, a1, a2);
    EVP_DigestFinal(v7, a3, 0);
    v9 = 0;
  }
  else
  {
    v9 = 1;
  }
  EVP_MD_CTX_free(v7);
  return v9;
}

BOOL _libssh2_cipher_init(EVP_CIPHER_CTX **a1, void *(*a2)(), unsigned __int8 *a3, const unsigned __int8 *a4, int a5)
{
  EVP_CIPHER_CTX *v10;
  const EVP_CIPHER *v11;
  int v12;
  _BOOL8 result;
  int v15;

  v10 = EVP_CIPHER_CTX_new();
  *a1 = v10;
  v11 = (const EVP_CIPHER *)a2();
  v12 = EVP_CipherInit(v10, v11, a4, a3, a5);
  result = v12 == 0;
  if (a2 == EVP_aes_128_gcm || a2 == EVP_aes_256_gcm)
  {
    v15 = EVP_CIPHER_CTX_ctrl(*a1, 18, -1, a3);
    return !v12 || v15 == 0;
  }
  return result;
}

uint64_t _libssh2_cipher_crypt(EVP_CIPHER_CTX **a1, void *(*a2)(), int a3, const unsigned __int8 *a4, unint64_t a5, int a6)
{
  BOOL v6;
  int v7;
  unsigned int v8;
  char v9;
  unsigned int v10;
  unsigned int v11;
  int v13;
  size_t v14;
  char v15;
  int v18;
  char v19;
  char v20;
  _BOOL8 v21;
  _BYTE ptr[33];
  uint64_t v25;

  v25 = *MEMORY[0x24BDAC8D0];
  v6 = a2 == EVP_aes_128_gcm || a2 == EVP_aes_256_gcm;
  v7 = v6;
  if (v6)
    v8 = 16;
  else
    v8 = 0;
  v9 = v7 & a6;
  if ((v7 & a6) != 0)
    v10 = 4;
  else
    v10 = 0;
  if ((a6 & 2) != 0)
    v11 = v8;
  else
    v11 = 0;
  if (a5 >= 0x21)
    _libssh2_cipher_crypt_cold_1();
  v13 = v10 | v11;
  v14 = a5 - (v10 | v11);
  if ((v14 & 0x80000000) != 0)
    _libssh2_cipher_crypt_cold_2();
  v15 = a6;
  if ((a6 & 1) != 0)
  {
    if (!v7)
    {
      v18 = 1;
      goto LABEL_29;
    }
    v18 = EVP_CIPHER_CTX_ctrl(*a1, 19, 1, ptr);
    if ((v9 & 1) != 0)
      v18 = EVP_Cipher(*a1, 0, a4, 4u);
  }
  else
  {
    v18 = 1;
  }
  v19 = v7 ^ 1;
  if (a3)
    v19 = 1;
  if ((v19 & 1) == 0 && (v15 & 2) != 0)
    v18 = EVP_CIPHER_CTX_ctrl(*a1, 17, v8, (void *)&a4[a5 - v8]);
LABEL_29:
  if ((_DWORD)a5 != v13)
    v18 = EVP_Cipher(*a1, &ptr[v10 + 1], &a4[v10], v14);
  if (v18 >= 1)
  {
    if ((v15 & 2) == 0)
      goto LABEL_38;
    if (EVP_Cipher(*a1, 0, 0, 0) < 0)
    {
      v21 = 1;
      goto LABEL_41;
    }
    v20 = v7 ^ 1;
    if (!a3)
      v20 = 1;
    if ((v20 & 1) != 0)
LABEL_38:
      v21 = 0;
    else
      v21 = EVP_CIPHER_CTX_ctrl(*a1, 16, v8, (void *)&a4[a5 - v8]) == 0;
LABEL_41:
    memcpy((void *)&a4[v10], &ptr[v10 + 1], v14);
    return v21;
  }
  return 1;
}

uint64_t _libssh2_openssl_crypto_init()
{
  OPENSSL_add_all_algorithms_noconf();
  OpenSSL_add_all_ciphers();
  OpenSSL_add_all_digests();
  ENGINE_load_builtin_engines();
  return ENGINE_register_all_complete();
}

uint64_t _libssh2_rsa_new_private_frommemory(EVP_PKEY **a1, uint64_t a2, void *a3, unint64_t a4, char *a5)
{
  BIO *v10;
  BIO *v11;

  _libssh2_init_if_needed();
  *a1 = 0;
  v10 = BIO_new_mem_buf(a3, a4);
  if (v10
    && (v11 = v10,
        *a1 = (EVP_PKEY *)PEM_read_bio_RSAPrivateKey(v10, 0, (pem_password_cb *)passphrase_cb, a5),
        BIO_free(v11),
        *a1))
  {
    return 0;
  }
  else
  {
    return _libssh2_pub_priv_openssh_keyfilememory(a2, a1, "ssh-rsa", 0, 0, 0, 0, (uint64_t)a3, a4, a5);
  }
}

uint64_t read_openssh_private_key_from_memory(EVP_PKEY **a1, uint64_t a2, char *a3, uint64_t a4, unint64_t a5, const char *a6)
{
  return _libssh2_pub_priv_openssh_keyfilememory(a2, a1, a3, 0, 0, 0, 0, a4, a5, a6);
}

uint64_t _libssh2_rsa_new_private(RSA **a1, uint64_t a2, const char *a3, void *a4)
{
  BIO *v8;
  BIO *v9;
  uint64_t v10;
  FILE *v11;
  FILE *v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  _QWORD *v17;
  char *__s2;

  _libssh2_init_if_needed();
  *a1 = 0;
  v8 = BIO_new_file(a3, "r");
  if (v8)
  {
    v9 = v8;
    *a1 = PEM_read_bio_RSAPrivateKey(v8, 0, (pem_password_cb *)passphrase_cb, a4);
    BIO_free(v9);
    if (*a1)
      return 0;
  }
  v17 = 0;
  __s2 = 0;
  if (!a2)
  {
    v13 = "Session is required";
    v14 = 0;
LABEL_12:
    v15 = 4294967282;
LABEL_14:
    _libssh2_error(v14, v15, v13);
    return 0xFFFFFFFFLL;
  }
  _libssh2_init_if_needed();
  v11 = fopen(a3, "r");
  if (!v11)
  {
    v13 = "Unable to open OpenSSH RSA private key file";
    v14 = a2;
    v15 = 4294967280;
    goto LABEL_14;
  }
  v12 = v11;
  v10 = _libssh2_openssh_pem_parse(a2, (const char *)a4, (uint64_t)v11, &v17);
  fclose(v12);
  if ((_DWORD)v10)
    return v10;
  if (_libssh2_get_string(v17, &__s2, 0) || !__s2)
  {
    v13 = "Public key type in decrypted key data not found";
    v14 = a2;
    goto LABEL_12;
  }
  if (!strcmp("ssh-rsa", __s2))
    v10 = gen_publickey_from_rsa_openssh_priv_data(a2, v17, 0, 0, 0, 0, a1);
  else
    v10 = 0xFFFFFFFFLL;
  if (v17)
    _libssh2_string_buf_free(a2, v17);
  return v10;
}

uint64_t _libssh2_dsa_new_private_frommemory(EVP_PKEY **a1, uint64_t a2, void *a3, unint64_t a4, char *a5)
{
  BIO *v10;
  BIO *v11;

  _libssh2_init_if_needed();
  *a1 = 0;
  v10 = BIO_new_mem_buf(a3, a4);
  if (v10
    && (v11 = v10,
        *a1 = (EVP_PKEY *)PEM_read_bio_DSAPrivateKey(v10, 0, (pem_password_cb *)passphrase_cb, a5),
        BIO_free(v11),
        *a1))
  {
    return 0;
  }
  else
  {
    return _libssh2_pub_priv_openssh_keyfilememory(a2, a1, "ssh-dsa", 0, 0, 0, 0, (uint64_t)a3, a4, a5);
  }
}

uint64_t _libssh2_dsa_new_private(DSA **a1, uint64_t a2, const char *a3, void *a4)
{
  BIO *v8;
  BIO *v9;
  uint64_t v10;
  FILE *v11;
  FILE *v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  _QWORD *v17;
  char *__s2;

  _libssh2_init_if_needed();
  *a1 = 0;
  v8 = BIO_new_file(a3, "r");
  if (v8)
  {
    v9 = v8;
    *a1 = PEM_read_bio_DSAPrivateKey(v8, 0, (pem_password_cb *)passphrase_cb, a4);
    BIO_free(v9);
    if (*a1)
      return 0;
  }
  v17 = 0;
  __s2 = 0;
  if (!a2)
  {
    v13 = "Session is required";
    v14 = 0;
LABEL_12:
    v15 = 4294967282;
LABEL_14:
    _libssh2_error(v14, v15, v13);
    return 0xFFFFFFFFLL;
  }
  _libssh2_init_if_needed();
  v11 = fopen(a3, "r");
  if (!v11)
  {
    v13 = "Unable to open OpenSSH DSA private key file";
    v14 = a2;
    v15 = 4294967280;
    goto LABEL_14;
  }
  v12 = v11;
  v10 = _libssh2_openssh_pem_parse(a2, (const char *)a4, (uint64_t)v11, &v17);
  fclose(v12);
  if ((_DWORD)v10)
    return v10;
  if (_libssh2_get_string(v17, &__s2, 0) || !__s2)
  {
    v13 = "Public key type in decrypted key data not found";
    v14 = a2;
    goto LABEL_12;
  }
  if (!strcmp("ssh-dss", __s2))
    v10 = gen_publickey_from_dsa_openssh_priv_data(a2, v17, 0, 0, 0, 0, a1);
  else
    v10 = 0xFFFFFFFFLL;
  if (v17)
    _libssh2_string_buf_free(a2, v17);
  return v10;
}

uint64_t _libssh2_ecdsa_new_private_frommemory(EVP_PKEY **a1, uint64_t a2, void *a3, unint64_t a4, char *a5)
{
  BIO *v10;
  BIO *v11;

  _libssh2_init_if_needed();
  *a1 = 0;
  v10 = BIO_new_mem_buf(a3, a4);
  if (v10
    && (v11 = v10,
        *a1 = (EVP_PKEY *)PEM_read_bio_ECPrivateKey(v10, 0, (pem_password_cb *)passphrase_cb, a5),
        BIO_free(v11),
        *a1))
  {
    return 0;
  }
  else
  {
    return _libssh2_pub_priv_openssh_keyfilememory(a2, a1, "ssh-ecdsa", 0, 0, 0, 0, (uint64_t)a3, a4, a5);
  }
}

uint64_t _libssh2_ecdsa_new_private_frommemory_sk(EVP_PKEY **a1, _BYTE *a2, void **a3, _QWORD *a4, size_t *a5, uint64_t a6, uint64_t a7, unint64_t a8, const char *a9)
{
  int v10;

  return _libssh2_sk_pub_openssh_keyfilememory(a6, a1, "sk-ecdsa-sha2-nistp256@openssh.com", 0, 0, 0, 0, &v10, a2, a3, a4, a5, a7, a8, a9);
}

uint64_t _libssh2_sk_pub_openssh_keyfilememory(uint64_t a1, EVP_PKEY **a2, char *__s, const char **a4, size_t *a5, _QWORD *a6, uint64_t *a7, _DWORD *a8, _BYTE *a9, void **a10, _QWORD *a11, size_t *a12, uint64_t a13, unint64_t a14, const char *a15)
{
  char *v19;
  uint64_t v20;
  uint64_t v21;
  char *v22;
  _QWORD *v28;
  char *__s2;

  v28 = 0;
  __s2 = 0;
  if (a2)
    *a2 = 0;
  if (!a1)
  {
    v19 = "Session is required";
    v20 = 0;
    return _libssh2_error(v20, 4294967282, v19);
  }
  if (__s && strlen(__s) <= 6)
  {
    v19 = "type is invalid";
    v20 = a1;
    return _libssh2_error(v20, 4294967282, v19);
  }
  _libssh2_init_if_needed();
  v21 = _libssh2_openssh_pem_parse_memory(a1, a15, a13, a14, &v28);
  if (!(_DWORD)v21)
  {
    if (_libssh2_get_string(v28, &__s2, 0))
      return _libssh2_error(a1, 4294967282, "Public key type in decrypted key data not found");
    v22 = __s2;
    if (!__s2)
    {
      return _libssh2_error(a1, 4294967282, "Public key type in decrypted key data not found");
    }
    else
    {
      if (!strcmp("sk-ssh-ed25519@openssh.com", __s2)
        && ((*a8 = 6, !__s) || !strcmp("sk-ssh-ed25519@openssh.com", __s)))
      {
        v21 = gen_publickey_from_sk_ed25519_openssh_priv_data(a1, v28, a4, a5, a6, a7, a9, a10, a11, a12, a2);
        v22 = __s2;
      }
      else
      {
        v21 = 4294967280;
      }
      if (!strcmp("sk-ecdsa-sha2-nistp256@openssh.com", v22))
      {
        *a8 = 3;
        v21 = gen_publickey_from_sk_ecdsa_openssh_priv_data(a1, v28, a4, a5, a6, a7, a9, a10, a11, a12, (EC_KEY **)a2);
      }
      if ((_DWORD)v21 == -16)
        v21 = _libssh2_error(a1, 4294967280, "Unable to extract public key from private key file: invalid/unrecognized private key file format");
      if (v28)
        _libssh2_string_buf_free(a1, v28);
    }
  }
  return v21;
}

uint64_t _libssh2_curve25519_new(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t *v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  EVP_PKEY *pkey;

  pkey = 0;
  v6 = (uint64_t *)EVP_PKEY_CTX_new_id(950, 0);
  if (!v6)
    return 0xFFFFFFFFLL;
  v7 = v6;
  if (EVP_PKEY_keygen_init(v6) != 1 || EVP_PKEY_keygen(v7, &pkey) != 1)
  {
    v8 = 0;
    goto LABEL_13;
  }
  if (!a3)
  {
LABEL_8:
    if (!a2)
    {
      v8 = 0;
      v9 = 0;
      v10 = 0;
      goto LABEL_15;
    }
    v9 = (*(uint64_t (**)(uint64_t, uint64_t))(a1 + 8))(32, a1);
    if (v9)
    {
      v8 = 0;
      v10 = 0xFFFFFFFFLL;
      if (EVP_PKEY_get_raw_public_key((uint64_t)pkey) == 1)
      {
        v8 = 0;
        v10 = 0;
        *a2 = v9;
        v9 = 0;
      }
      goto LABEL_15;
    }
    v8 = 0;
    goto LABEL_14;
  }
  v8 = (*(uint64_t (**)(uint64_t, uint64_t))(a1 + 8))(32, a1);
  if (!v8)
  {
LABEL_13:
    v9 = 0;
LABEL_14:
    v10 = 0xFFFFFFFFLL;
    goto LABEL_15;
  }
  v9 = 0;
  v10 = 0xFFFFFFFFLL;
  if (EVP_PKEY_get_raw_private_key((uint64_t)pkey) == 1)
  {
    *a3 = v8;
    goto LABEL_8;
  }
LABEL_15:
  EVP_PKEY_CTX_free((EVP_PKEY **)v7);
  if (pkey)
    EVP_PKEY_free(pkey);
  if (v8)
    (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v8, a1);
  if (v9)
    (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v9, a1);
  return v10;
}

uint64_t _libssh2_ed25519_new_private(EVP_PKEY **a1, uint64_t a2, const char *a3, const char *a4)
{
  FILE *v8;
  FILE *v9;
  uint64_t v10;
  int v11;
  char *v12;
  uint64_t v13;
  uint64_t v14;
  EVP_PKEY *pkey;
  _QWORD *v17;
  char *__s2;

  pkey = 0;
  v17 = 0;
  if (!a2)
  {
    v12 = "Session is required";
    v13 = 0;
LABEL_9:
    v14 = 4294967282;
LABEL_11:
    _libssh2_error(v13, v14, v12);
    return 0xFFFFFFFFLL;
  }
  _libssh2_init_if_needed();
  v8 = fopen(a3, "r");
  if (!v8)
  {
    v12 = "Unable to open ED25519 private key file";
    v13 = a2;
    v14 = 4294967280;
    goto LABEL_11;
  }
  v9 = v8;
  __s2 = 0;
  v10 = _libssh2_openssh_pem_parse(a2, a4, (uint64_t)v8, &v17);
  fclose(v9);
  if ((_DWORD)v10)
    return v10;
  if (_libssh2_get_string(v17, &__s2, 0) || !__s2)
  {
    v12 = "Public key type in decrypted key data not found";
    v13 = a2;
    goto LABEL_9;
  }
  if (!strcmp("ssh-ed25519", __s2))
    v11 = gen_publickey_from_ed25519_openssh_priv_data(a2, v17, 0, 0, 0, 0, &pkey);
  else
    v11 = -1;
  if (v17)
    _libssh2_string_buf_free(a2, v17);
  if (v11)
    return 0xFFFFFFFFLL;
  if (a1)
  {
    v10 = 0;
    *a1 = pkey;
  }
  else
  {
    if (pkey)
      EVP_PKEY_free(pkey);
    return 0;
  }
  return v10;
}

uint64_t gen_publickey_from_ed25519_openssh_priv_data(uint64_t a1, _QWORD *a2, uint64_t *a3, _QWORD *a4, _QWORD *a5, _QWORD *a6, EVP_PKEY **a7)
{
  EVP_PKEY *v14;
  char *v15;
  uint64_t v16;
  char *v17;
  uint64_t result;
  _BYTE *v19;
  _BYTE *v20;
  unint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v24;
  _DWORD *v25;
  _DWORD *v26;
  _DWORD *v27;
  size_t v28;
  const void *v29;
  uint64_t v30;
  const void *v31;

  v30 = 0;
  v31 = 0;
  v28 = 0;
  v29 = 0;
  if (_libssh2_get_string(a2, &v31, &v28) || v28 != 32)
  {
    v17 = "Wrong public key length";
LABEL_13:
    _libssh2_error(a1, 4294967282, v17);
    return 0xFFFFFFFFLL;
  }
  if (_libssh2_get_string(a2, &v30, &v28) || v28 != 64)
  {
    v17 = "Wrong private key length";
    goto LABEL_13;
  }
  v14 = EVP_PKEY_new_raw_private_key(952, 0, v30, 32);
  if (_libssh2_get_string(a2, &v29, &v28))
  {
    v15 = "Unable to read comment";
    goto LABEL_7;
  }
  if (v28)
  {
    v19 = _libssh2_calloc(a1, v28 + 1);
    if (v19)
    {
      v20 = v19;
      memcpy(v19, v29, v28);
      v20[v28] = 0;
      (*(void (**)(_BYTE *, uint64_t))(a1 + 24))(v20, a1);
    }
  }
  v21 = a2[1];
  v22 = a2[2];
  if (v21 < *a2 + v22)
  {
    v23 = 0;
    v24 = v22 + *a2 - v21;
    while ((_DWORD)v23 + 1 == *(unsigned __int8 *)(v21 + v23))
    {
      a2[1] = v21 + v23++ + 1;
      if (v24 == v23)
        goto LABEL_22;
    }
    v15 = "Wrong padding";
LABEL_7:
    _libssh2_error(a1, 4294967282, v15);
    v16 = 0;
    if (!v14)
      goto LABEL_9;
    goto LABEL_8;
  }
LABEL_22:
  v16 = (*(uint64_t (**)(uint64_t, uint64_t))(a1 + 8))(11, a1);
  if (!v16 || (v25 = _libssh2_calloc(a1, 0x33uLL)) == 0)
  {
    _libssh2_error(a1, 4294967290, "Unable to allocate memory for ED25519 key");
    if (!v14)
    {
LABEL_9:
      if (v16)
        (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v16, a1);
      return 0xFFFFFFFFLL;
    }
LABEL_8:
    EVP_PKEY_free(v14);
    goto LABEL_9;
  }
  v26 = v25;
  v27 = v25;
  _libssh2_store_str(&v27, "ssh-ed25519", 0xBuLL);
  _libssh2_store_str(&v27, v31, 0x20uLL);
  *(_DWORD *)(v16 + 7) = 959526197;
  *(_QWORD *)v16 = *(_QWORD *)"ssh-ed25519";
  if (a3)
    *a3 = v16;
  else
    (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v16, a1);
  if (a4)
    *a4 = 11;
  if (a5)
    *a5 = v26;
  else
    (*(void (**)(_DWORD *, uint64_t))(a1 + 24))(v26, a1);
  if (a6)
    *a6 = 51;
  if (a7)
  {
    result = 0;
    *a7 = v14;
  }
  else
  {
    if (v14)
      EVP_PKEY_free(v14);
    return 0;
  }
  return result;
}

uint64_t _libssh2_ed25519_new_private_sk(EVP_PKEY **a1, _BYTE *a2, void **a3, _QWORD *a4, size_t *a5, uint64_t a6, const char *a7, const char *a8)
{
  FILE *v16;
  FILE *v17;
  uint64_t v18;
  int v19;
  char *v20;
  uint64_t v21;
  uint64_t v22;
  EVP_PKEY *pkey;
  _QWORD *v25;
  char *__s2;

  pkey = 0;
  v25 = 0;
  if (!a6)
  {
    v20 = "Session is required";
    v21 = 0;
LABEL_9:
    v22 = 4294967282;
LABEL_11:
    _libssh2_error(v21, v22, v20);
    return 0xFFFFFFFFLL;
  }
  _libssh2_init_if_needed();
  v16 = fopen(a7, "r");
  if (!v16)
  {
    v20 = "Unable to open ED25519 SK private key file";
    v21 = a6;
    v22 = 4294967280;
    goto LABEL_11;
  }
  v17 = v16;
  __s2 = 0;
  v18 = _libssh2_openssh_pem_parse(a6, a8, (uint64_t)v16, &v25);
  fclose(v17);
  if ((_DWORD)v18)
    return v18;
  if (_libssh2_get_string(v25, &__s2, 0) || !__s2)
  {
    v20 = "Public key type in decrypted key data not found";
    v21 = a6;
    goto LABEL_9;
  }
  if (!strcmp("sk-ssh-ed25519@openssh.com", __s2))
    v19 = gen_publickey_from_sk_ed25519_openssh_priv_data(a6, v25, 0, 0, 0, 0, a2, a3, a4, a5, &pkey);
  else
    v19 = -1;
  if (v25)
    _libssh2_string_buf_free(a6, v25);
  if (v19)
    return 0xFFFFFFFFLL;
  if (a1)
  {
    v18 = 0;
    *a1 = pkey;
  }
  else
  {
    if (pkey)
      EVP_PKEY_free(pkey);
    return 0;
  }
  return v18;
}

uint64_t gen_publickey_from_sk_ed25519_openssh_priv_data(uint64_t a1, _QWORD *a2, _QWORD *a3, _QWORD *a4, _QWORD *a5, _QWORD *a6, _BYTE *a7, void **a8, _QWORD *a9, size_t *a10, EVP_PKEY **a11)
{
  char *v19;
  uint64_t result;
  void *v21;
  EVP_PKEY *v22;
  void *v23;
  void *v24;
  void *v25;
  void *v26;
  uint64_t v27;
  void *__src;
  uint64_t v29;
  unint64_t v30;
  const void *v31;
  const void *v32;

  v31 = 0;
  v32 = 0;
  v29 = 0;
  v30 = 0;
  if (_libssh2_get_string(a2, &v32, &v29) || v29 != 32)
  {
    v19 = "Wrong public key length";
    goto LABEL_6;
  }
  if (_libssh2_get_string(a2, &v31, &v30))
  {
    v19 = "No SK application.";
LABEL_6:
    _libssh2_error(a1, 4294967282, v19);
    return 0xFFFFFFFFLL;
  }
  if (a7 && _libssh2_get_byte(a2, a7))
  {
    v19 = "No SK flags.";
    goto LABEL_6;
  }
  if (a9 && a10)
  {
    __src = 0;
    if (_libssh2_get_string(a2, &__src, a10))
    {
      v19 = "No SK key_handle.";
      goto LABEL_6;
    }
    if (*a10)
    {
      v21 = (void *)(*(uint64_t (**)(size_t, uint64_t))(a1 + 8))(*a10, a1);
      *a9 = v21;
      memcpy(v21, __src, *a10);
    }
  }
  v22 = EVP_PKEY_new_raw_public_key(952, 0, (uint64_t)v32, 32);
  v23 = (void *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 8))(26, a1);
  if (!v23 || (v27 = v30 + 70, (v24 = _libssh2_calloc(a1, v30 + 70)) == 0))
  {
    _libssh2_error(a1, 4294967290, "Unable to allocate memory for ED25519 key");
    if (v22)
      EVP_PKEY_free(v22);
    if (v23)
      (*(void (**)(void *, uint64_t))(a1 + 24))(v23, a1);
    if (a8 && *a8)
    {
      (*(void (**)(void **, uint64_t))(a1 + 24))(a8, a1);
      *a8 = 0;
    }
    if (a9 && *a9)
    {
      (*(void (**)(_QWORD *, uint64_t))(a1 + 24))(a9, a1);
      *a9 = 0;
    }
    return 0xFFFFFFFFLL;
  }
  v25 = v24;
  __src = v24;
  _libssh2_store_str((_DWORD **)&__src, "sk-ssh-ed25519@openssh.com", 0x1AuLL);
  _libssh2_store_str((_DWORD **)&__src, v32, 0x20uLL);
  _libssh2_store_str((_DWORD **)&__src, v31, v30);
  if (a8 && v30)
  {
    v26 = (void *)(*(uint64_t (**)(unint64_t, uint64_t))(a1 + 8))(v30 + 1, a1);
    *a8 = v26;
    memset_s(v26, v30 + 1, 0, v30 + 1);
    memcpy(*a8, v31, v30);
  }
  qmemcpy(v23, "sk-ssh-ed25519@openssh.com", 26);
  if (a3)
    *a3 = v23;
  else
    (*(void (**)(void *, uint64_t))(a1 + 24))(v23, a1);
  if (a4)
    *a4 = 26;
  if (a5)
    *a5 = v25;
  else
    (*(void (**)(void *, uint64_t))(a1 + 24))(v25, a1);
  if (a6)
    *a6 = v27;
  if (a11)
  {
    result = 0;
    *a11 = v22;
  }
  else
  {
    if (v22)
      EVP_PKEY_free(v22);
    return 0;
  }
  return result;
}

uint64_t _libssh2_ed25519_new_private_frommemory(EVP_PKEY **a1, uint64_t a2, void *a3, unint64_t a4, char *a5)
{
  BIO *v10;
  BIO *v11;
  EVP_PKEY *bio_PrivateKey;

  _libssh2_init_if_needed();
  v10 = BIO_new_mem_buf(a3, a4);
  if (!v10)
    return _libssh2_pub_priv_openssh_keyfilememory(a2, a1, "ssh-ed25519", 0, 0, 0, 0, (uint64_t)a3, a4, a5);
  v11 = v10;
  bio_PrivateKey = PEM_read_bio_PrivateKey(v10, 0, (pem_password_cb *)passphrase_cb, a5);
  BIO_free(v11);
  if (!bio_PrivateKey)
    return _libssh2_pub_priv_openssh_keyfilememory(a2, a1, "ssh-ed25519", 0, 0, 0, 0, (uint64_t)a3, a4, a5);
  if (EVP_PKEY_id((unsigned int *)bio_PrivateKey) == 952)
  {
    *a1 = bio_PrivateKey;
    return 0;
  }
  else
  {
    EVP_PKEY_free(bio_PrivateKey);
    return _libssh2_error(a2, 4294967282, "Private key is not an ED25519 key");
  }
}

uint64_t _libssh2_ed25519_new_private_frommemory_sk(EVP_PKEY **a1, _BYTE *a2, void **a3, _QWORD *a4, size_t *a5, uint64_t a6, uint64_t a7, unint64_t a8, const char *a9)
{
  int v10;

  return _libssh2_sk_pub_openssh_keyfilememory(a6, a1, "sk-ssh-ed25519@openssh.com", 0, 0, 0, 0, &v10, a2, a3, a4, a5, a7, a8, a9);
}

uint64_t _libssh2_ed25519_new_public(EVP_PKEY **a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  EVP_PKEY *v6;
  EVP_PKEY *v7;
  uint64_t result;

  if (!a1)
    return 0xFFFFFFFFLL;
  v6 = EVP_PKEY_new_raw_public_key(952, 0, a3, a4);
  if (!v6)
    return _libssh2_error(a2, 4294967282, "could not create ED25519 public key");
  v7 = v6;
  result = 0;
  *a1 = v7;
  return result;
}

uint64_t _libssh2_rsa_sha2_sign(uint64_t a1, RSA *a2, const unsigned __int8 *a3, uint64_t a4, unsigned __int8 **a5, _QWORD *a6)
{
  uint64_t v12;
  uint64_t v13;
  unsigned __int8 *v14;
  int v15;
  const unsigned __int8 *v16;
  unsigned int v17;
  uint64_t result;
  unsigned int siglen;

  siglen = RSA_size(a2);
  v12 = siglen;
  v13 = (*(uint64_t (**)(_QWORD, uint64_t))(a1 + 8))(siglen, a1);
  if (!v13)
    return 0xFFFFFFFFLL;
  v14 = (unsigned __int8 *)v13;
  switch(a4)
  {
    case 64:
      v15 = 674;
      v16 = a3;
      v17 = 64;
      break;
    case 32:
      v15 = 672;
      v16 = a3;
      v17 = 32;
      break;
    case 20:
      v15 = 64;
      v16 = a3;
      v17 = 20;
      break;
    default:
      _libssh2_error(a1, 4294967282, "Unsupported hash digest length");
      goto LABEL_13;
  }
  if (!RSA_sign(v15, v16, v17, v14, &siglen, a2))
  {
    (*(void (**)(unsigned __int8 *, uint64_t))(a1 + 24))(v14, a1);
    return 0xFFFFFFFFLL;
  }
  v12 = siglen;
LABEL_13:
  result = 0;
  *a5 = v14;
  *a6 = v12;
  return result;
}

uint64_t _libssh2_dsa_sha1_sign(DSA *dsa, unsigned __int8 *dgst, uint64_t a3, uint64_t a4)
{
  DSA_SIG *v5;
  DSA_SIG *v6;
  int v7;
  int v8;
  int v9;
  uint64_t v10;
  int v11;
  unsigned int v12;
  BIGNUM *v14;
  BIGNUM *a;

  v5 = DSA_do_sign(dgst, 20, dsa);
  if (!v5)
    return 0xFFFFFFFFLL;
  v6 = v5;
  v14 = 0;
  a = 0;
  DSA_SIG_get0(v5, &a, &v14);
  v7 = BN_num_bits(a);
  if (v7 >= -7)
    v8 = v7 + 7;
  else
    v8 = v7 + 14;
  if ((v7 - 161) >= 0xFFFFFF60 && (v9 = BN_num_bits(v14), (v9 - 161) >= 0xFFFFFF60))
  {
    v11 = -(v8 >> 3);
    v12 = v9 + 7;
    *(_QWORD *)(a4 + 32) = 0;
    *(_OWORD *)a4 = 0u;
    *(_OWORD *)(a4 + 16) = 0u;
    BN_bn2bin(a, (unsigned __int8 *)(a4 + (v11 + 20)));
    BN_bn2bin(v14, (unsigned __int8 *)(a4 + 20 - (v12 >> 3) + 20));
    v10 = 0;
  }
  else
  {
    v10 = 0xFFFFFFFFLL;
  }
  DSA_SIG_free(v6);
  return v10;
}

uint64_t _libssh2_ecdsa_sign(uint64_t a1, EC_KEY *eckey, unsigned __int8 *dgst, int dgst_len, _QWORD *a5, char **a6)
{
  ECDSA_SIG *v9;
  ECDSA_SIG *v10;
  int v11;
  int v12;
  int v13;
  int v14;
  signed int v15;
  _BYTE *v16;
  _BYTE *v17;
  char *v18;
  char *v19;
  void *v20;
  void *v21;
  uint64_t v22;
  BIGNUM *v24;
  BIGNUM *a;

  v24 = 0;
  a = 0;
  v9 = ECDSA_do_sign(dgst, dgst_len, eckey);
  if (!v9)
    return 0xFFFFFFFFLL;
  v10 = v9;
  ECDSA_SIG_get0(v9, &a, &v24);
  v11 = BN_num_bits(a);
  if (v11 >= -7)
    v12 = v11 + 7;
  else
    v12 = v11 + 14;
  v13 = BN_num_bits(v24);
  v14 = v13 + 7;
  if (v13 < -7)
    v14 = v13 + 14;
  v15 = (v14 >> 3) + 1;
  v16 = malloc_type_malloc(v15 + (v12 >> 3) + 9, 0x59225677uLL);
  if (v16)
  {
    v17 = v16;
    v18 = write_bn((uint64_t)v16, a, (v12 >> 3) + 1);
    v19 = (char *)(write_bn((uint64_t)v18, v24, v15) - v17);
    v20 = _libssh2_calloc(a1, (size_t)v19);
    if (v20)
    {
      v21 = v20;
      memcpy(v20, v17, (size_t)v19);
      v22 = 0;
      *a5 = v21;
      *a6 = v19;
    }
    else
    {
      v22 = 0xFFFFFFFFLL;
    }
    free(v17);
  }
  else
  {
    v22 = 0xFFFFFFFFLL;
  }
  ECDSA_SIG_free(v10);
  return v22;
}

char *write_bn(uint64_t a1, BIGNUM *a, signed int a3)
{
  char *v5;
  const void *v6;

  *(_BYTE *)(a1 + 4) = 0;
  v5 = (char *)(a1 + 4);
  v6 = (const void *)(a1 + 5);
  BN_bn2bin(a, (unsigned __int8 *)(a1 + 5));
  if ((v5[1] & 0x80000000) == 0)
    memmove(v5, v6, --a3);
  _libssh2_htonu32((_DWORD *)a1, a3);
  return &v5[a3];
}

uint64_t _libssh2_sha1_init(EVP_MD_CTX **a1)
{
  uint64_t result;
  EVP_MD_CTX *v3;
  const EVP_MD *digestbyname;

  result = (uint64_t)EVP_MD_CTX_new();
  *a1 = (EVP_MD_CTX *)result;
  if (result)
  {
    v3 = (EVP_MD_CTX *)result;
    digestbyname = EVP_get_digestbyname("sha1");
    if (EVP_DigestInit(v3, digestbyname))
    {
      return 1;
    }
    else
    {
      EVP_MD_CTX_free(*a1);
      result = 0;
      *a1 = 0;
    }
  }
  return result;
}

uint64_t _libssh2_sha256_init(EVP_MD_CTX **a1)
{
  uint64_t result;
  EVP_MD_CTX *v3;
  const EVP_MD *digestbyname;

  result = (uint64_t)EVP_MD_CTX_new();
  *a1 = (EVP_MD_CTX *)result;
  if (result)
  {
    v3 = (EVP_MD_CTX *)result;
    digestbyname = EVP_get_digestbyname("sha256");
    if (EVP_DigestInit(v3, digestbyname))
    {
      return 1;
    }
    else
    {
      EVP_MD_CTX_free(*a1);
      result = 0;
      *a1 = 0;
    }
  }
  return result;
}

uint64_t _libssh2_sha384_init(EVP_MD_CTX **a1)
{
  uint64_t result;
  EVP_MD_CTX *v3;
  const EVP_MD *digestbyname;

  result = (uint64_t)EVP_MD_CTX_new();
  *a1 = (EVP_MD_CTX *)result;
  if (result)
  {
    v3 = (EVP_MD_CTX *)result;
    digestbyname = EVP_get_digestbyname("sha384");
    if (EVP_DigestInit(v3, digestbyname))
    {
      return 1;
    }
    else
    {
      EVP_MD_CTX_free(*a1);
      result = 0;
      *a1 = 0;
    }
  }
  return result;
}

uint64_t _libssh2_sha512_init(EVP_MD_CTX **a1)
{
  uint64_t result;
  EVP_MD_CTX *v3;
  const EVP_MD *digestbyname;

  result = (uint64_t)EVP_MD_CTX_new();
  *a1 = (EVP_MD_CTX *)result;
  if (result)
  {
    v3 = (EVP_MD_CTX *)result;
    digestbyname = EVP_get_digestbyname("sha512");
    if (EVP_DigestInit(v3, digestbyname))
    {
      return 1;
    }
    else
    {
      EVP_MD_CTX_free(*a1);
      result = 0;
      *a1 = 0;
    }
  }
  return result;
}

uint64_t _libssh2_md5_init(EVP_MD_CTX **a1)
{
  uint64_t result;
  EVP_MD_CTX *v3;
  const EVP_MD *digestbyname;

  result = (uint64_t)EVP_MD_CTX_new();
  *a1 = (EVP_MD_CTX *)result;
  if (result)
  {
    v3 = (EVP_MD_CTX *)result;
    digestbyname = EVP_get_digestbyname("md5");
    if (EVP_DigestInit(v3, digestbyname))
    {
      return 1;
    }
    else
    {
      EVP_MD_CTX_free(*a1);
      result = 0;
      *a1 = 0;
    }
  }
  return result;
}

uint64_t _libssh2_ecdsa_new_private(EC_KEY **a1, uint64_t a2, const char *a3, void *a4)
{
  BIO *v8;
  BIO *v9;
  uint64_t v10;
  FILE *v11;
  FILE *v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  _QWORD *v17;
  int v18;
  const char *v19;

  _libssh2_init_if_needed();
  *a1 = 0;
  v8 = BIO_new_file(a3, "r");
  if (v8)
  {
    v9 = v8;
    *a1 = PEM_read_bio_ECPrivateKey(v8, 0, (pem_password_cb *)passphrase_cb, a4);
    BIO_free(v9);
    if (*a1)
      return 0;
  }
  v19 = 0;
  v17 = 0;
  if (!a2)
  {
    v13 = "Session is required";
    v14 = 0;
LABEL_12:
    v15 = 4294967282;
LABEL_14:
    _libssh2_error(v14, v15, v13);
    return 0xFFFFFFFFLL;
  }
  _libssh2_init_if_needed();
  v11 = fopen(a3, "r");
  if (!v11)
  {
    v13 = "Unable to open OpenSSH ECDSA private key file";
    v14 = a2;
    v15 = 4294967280;
    goto LABEL_14;
  }
  v12 = v11;
  v18 = 0;
  v10 = _libssh2_openssh_pem_parse(a2, (const char *)a4, (uint64_t)v11, &v17);
  fclose(v12);
  if ((_DWORD)v10)
    return v10;
  if (_libssh2_get_string(v17, &v19, 0) || !v19)
  {
    v13 = "Public key type in decrypted key data not found";
    v14 = a2;
    goto LABEL_12;
  }
  if (_libssh2_ecdsa_curve_type_from_name(v19, &v18))
    v10 = 0xFFFFFFFFLL;
  else
    v10 = gen_publickey_from_ecdsa_openssh_priv_data(a2, v18, v17, 0, 0, 0, 0, a1);
  if (v17)
    _libssh2_string_buf_free(a2, v17);
  return v10;
}

uint64_t _libssh2_ecdsa_new_private_sk(EC_KEY **a1, _BYTE *a2, void **a3, _QWORD *a4, size_t *a5, uint64_t a6, const char *a7, void *a8)
{
  BIO *v16;
  BIO *v17;
  uint64_t v18;
  FILE *v19;
  FILE *v20;
  char *v21;
  uint64_t v22;
  uint64_t v23;
  _QWORD *v25;
  char *__s2;

  _libssh2_init_if_needed();
  *a1 = 0;
  v16 = BIO_new_file(a7, "r");
  if (v16)
  {
    v17 = v16;
    *a1 = PEM_read_bio_ECPrivateKey(v16, 0, (pem_password_cb *)passphrase_cb, a8);
    BIO_free(v17);
    if (*a1)
      return 0;
  }
  v25 = 0;
  __s2 = 0;
  if (!a6)
  {
    v21 = "Session is required";
    v22 = 0;
LABEL_12:
    v23 = 4294967282;
LABEL_14:
    _libssh2_error(v22, v23, v21);
    return 0xFFFFFFFFLL;
  }
  _libssh2_init_if_needed();
  v19 = fopen(a7, "r");
  if (!v19)
  {
    v21 = "Unable to open OpenSSH ECDSA private key file";
    v22 = a6;
    v23 = 4294967280;
    goto LABEL_14;
  }
  v20 = v19;
  v18 = _libssh2_openssh_pem_parse(a6, (const char *)a8, (uint64_t)v19, &v25);
  fclose(v20);
  if ((_DWORD)v18)
    return v18;
  if (_libssh2_get_string(v25, &__s2, 0) || !__s2)
  {
    v21 = "Public key type in decrypted key data not found";
    v22 = a6;
    goto LABEL_12;
  }
  if (!strcmp("sk-ecdsa-sha2-nistp256@openssh.com", __s2))
    v18 = gen_publickey_from_sk_ecdsa_openssh_priv_data(a6, v25, 0, 0, 0, 0, a2, a3, a4, a5, a1);
  else
    v18 = 0xFFFFFFFFLL;
  if (v25)
    _libssh2_string_buf_free(a6, v25);
  return v18;
}

uint64_t _libssh2_ecdsa_create_key(uint64_t a1, EC_KEY **a2, _QWORD *a3, size_t *a4, int a5)
{
  BN_CTX *v10;
  BN_CTX *v11;
  EC_KEY *v12;
  const EC_GROUP *v13;
  const EC_POINT *v14;
  size_t v15;
  size_t v16;
  void *v17;
  uint64_t v18;
  unsigned __int8 buf[133];
  uint64_t v21;

  v21 = *MEMORY[0x24BDAC8D0];
  v10 = BN_CTX_new();
  if (!v10)
    return 0xFFFFFFFFLL;
  v11 = v10;
  v12 = EC_KEY_new_by_curve_name(a5);
  v13 = EC_KEY_get0_group(v12);
  EC_KEY_generate_key(v12);
  v14 = EC_KEY_get0_public_key(v12);
  v15 = EC_POINT_point2oct(v13, v14, POINT_CONVERSION_UNCOMPRESSED, 0, 0, v11);
  if (v15 <= 0x85)
  {
    v16 = v15;
    if (EC_POINT_point2oct(v13, v14, POINT_CONVERSION_UNCOMPRESSED, buf, v15, v11) == v15)
    {
      if (a2)
        *a2 = v12;
      if (!a3)
        goto LABEL_9;
      v17 = (void *)(*(uint64_t (**)(size_t, uint64_t))(a1 + 8))(v16, a1);
      *a3 = v17;
      if (v17)
      {
        memcpy(v17, buf, v16);
LABEL_9:
        v18 = 0;
        if (a4)
          *a4 = v16;
        goto LABEL_12;
      }
    }
  }
  v18 = 0xFFFFFFFFLL;
LABEL_12:
  BN_CTX_free(v11);
  return v18;
}

uint64_t _libssh2_ecdh_gen_k(BIGNUM **a1, const EC_KEY *a2, const unsigned __int8 *a3, size_t a4)
{
  BN_CTX *v8;
  uint64_t v9;
  BN_CTX *v10;
  const EC_GROUP *v11;
  EC_POINT *v12;
  const EC_POINT *v13;
  int degree;
  int v15;
  size_t v16;
  unsigned __int8 *v17;
  unsigned __int8 *v18;
  int v19;

  v8 = BN_CTX_new();
  v9 = 0xFFFFFFFFLL;
  if (!a1)
    return v9;
  v10 = v8;
  if (!v8)
    return v9;
  v11 = EC_KEY_get0_group(a2);
  v12 = EC_POINT_new(v11);
  if (!v12)
    return 0xFFFFFFFFLL;
  v13 = v12;
  if (EC_POINT_oct2point(v11, v12, a3, a4, v10) == 1)
  {
    degree = EC_GROUP_get_degree(v11);
    v15 = degree + 7;
    if (degree < -7)
      v15 = degree + 14;
    v16 = (uint64_t)v15 >> 3;
    v17 = (unsigned __int8 *)malloc_type_malloc(v16, 0xEEB4C1A9uLL);
    v18 = v17;
    if (v17)
    {
      v19 = ECDH_compute_key(v17, v16, v13, a2, 0);
      if ((v19 - 134) >= 0xFFFFFF7B)
      {
        BN_bin2bn(v18, v19, *a1);
        v9 = 0;
        goto LABEL_13;
      }
    }
  }
  else
  {
    v18 = 0;
  }
  v9 = 0xFFFFFFFFLL;
LABEL_13:
  EC_POINT_free(v13);
  BN_CTX_free(v10);
  if (v18)
    free(v18);
  return v9;
}

uint64_t _libssh2_ed25519_sign(uint64_t a1, uint64_t a2, _QWORD *a3, _QWORD *a4, void *a5, size_t a6)
{
  EVP_MD_CTX *v12;
  EVP_MD_CTX *v13;
  int v14;
  void *v15;
  void *v16;
  uint64_t v18;

  v12 = (EVP_MD_CTX *)EVP_MD_CTX_new();
  v13 = v12;
  v18 = 0;
  if (v12)
  {
    if (EVP_DigestSignInit((uint64_t)v12, 0, 0, 0, a1) != 1)
    {
      v14 = -1;
      goto LABEL_12;
    }
    v14 = -1;
    if (EVP_DigestSign(v13, 0, &v18, a5, a6) != 1)
      goto LABEL_12;
    if (v18 != 64)
      goto LABEL_12;
    v15 = _libssh2_calloc(a2, 0x40uLL);
    if (!v15)
      goto LABEL_12;
    v16 = v15;
    v14 = EVP_DigestSign(v13, (uint64_t)v15, &v18, a5, a6);
    if (v14 == 1)
    {
      *a3 = v16;
      *a4 = v18;
LABEL_12:
      EVP_MD_CTX_free(v13);
      goto LABEL_13;
    }
  }
  else
  {
    v16 = 0;
    v14 = -1;
  }
  *a4 = 0;
  *a3 = 0;
  (*(void (**)(void *, uint64_t))(a2 + 24))(v16, a2);
  if (v13)
    goto LABEL_12;
LABEL_13:
  if (v14 == 1)
    return 0;
  else
    return 0xFFFFFFFFLL;
}

uint64_t _libssh2_curve25519_gen_k(BIGNUM **a1, uint64_t a2, uint64_t a3)
{
  BN_CTX *v6;
  BN_CTX *v7;
  EVP_PKEY *v8;
  EVP_PKEY *v9;
  EVP_PKEY *v10;
  uint64_t *v11;
  uint64_t *v12;
  int v13;
  int v14;
  uint64_t v16;
  unsigned __int8 s[32];
  uint64_t v18;

  v18 = *MEMORY[0x24BDAC8D0];
  v16 = 0;
  if (!a1)
    return 0xFFFFFFFFLL;
  if (!*a1)
    return 0xFFFFFFFFLL;
  v6 = BN_CTX_new();
  if (!v6)
    return 0xFFFFFFFFLL;
  v7 = v6;
  v8 = EVP_PKEY_new_raw_public_key(950, 0, a3, 32);
  v9 = EVP_PKEY_new_raw_private_key(950, 0, a2, 32);
  v10 = v9;
  if (v8 && v9)
  {
    v11 = (uint64_t *)EVP_PKEY_CTX_new((uint64_t)v9, 0);
    if (v11)
    {
      v12 = v11;
      v13 = EVP_PKEY_derive_init(v11);
      if (v13 < 1
        || (v13 = EVP_PKEY_derive_set_peer((uint64_t)v12, v8), v13 < 1)
        || (v13 = EVP_PKEY_derive(v12, 0, &v16), v13 < 1))
      {
        v14 = v13;
      }
      else if (v16 == 32)
      {
        v14 = -1;
        if (EVP_PKEY_derive(v12, (uint64_t)s, &v16) == 1 && v16 == 32)
        {
          BN_bin2bn(s, 32, *a1);
          v14 = 1;
        }
      }
      else
      {
        v14 = -1;
      }
      EVP_PKEY_CTX_free((EVP_PKEY **)v12);
    }
    else
    {
      v14 = -1;
    }
  }
  else
  {
    v14 = -1;
    if (!v8)
      goto LABEL_21;
  }
  EVP_PKEY_free(v8);
LABEL_21:
  if (v10)
    EVP_PKEY_free(v10);
  BN_CTX_free(v7);
  if (v14 == 1)
    return 0;
  else
    return 0xFFFFFFFFLL;
}

uint64_t _libssh2_ed25519_verify(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, size_t a5)
{
  EVP_MD_CTX *v10;
  EVP_MD_CTX *v11;
  unsigned int v12;

  v10 = (EVP_MD_CTX *)EVP_MD_CTX_new();
  if (!v10)
    return 0xFFFFFFFFLL;
  v11 = v10;
  v12 = EVP_DigestVerifyInit((uint64_t)v10, 0, 0, 0, a1);
  if (v12 == 1)
    v12 = EVP_DigestVerify(v11, a2, a3, a4, a5);
  EVP_MD_CTX_free(v11);
  if (v12 == 1)
    return 0;
  else
    return 0xFFFFFFFFLL;
}

uint64_t _libssh2_pub_priv_keyfile(uint64_t a1, uint64_t *a2, size_t *a3, _QWORD *a4, char **a5, char *filename, void *a7)
{
  BIO *v14;
  BIO *v15;
  EVP_PKEY *bio_PrivateKey;
  int v17;
  uint64_t v18;
  FILE *v20;
  FILE *v21;
  int v22;
  char *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  char *v27;
  int v28;
  int v29;
  _QWORD *v30;
  char *__s2;

  v14 = BIO_new_file(filename, "r");
  if (!v14)
    return _libssh2_error(a1, 4294967280, "Unable to extract public key from private key file: Unable to open private key file");
  v15 = v14;
  BIO_ctrl(v14, 1, 0, 0);
  bio_PrivateKey = PEM_read_bio_PrivateKey(v15, 0, 0, a7);
  BIO_free(v15);
  if (!bio_PrivateKey)
  {
    v30 = 0;
    __s2 = 0;
    if (a1)
    {
      _libssh2_init_if_needed();
      v20 = fopen(filename, "r");
      if (!v20)
      {
        v23 = "Unable to open private key file";
        goto LABEL_22;
      }
      v21 = v20;
      v22 = _libssh2_openssh_pem_parse(a1, (const char *)a7, (uint64_t)v20, &v30);
      fclose(v21);
      if (v22)
      {
        v23 = "Not an OpenSSH key file";
LABEL_22:
        v24 = a1;
        v25 = 4294967280;
        goto LABEL_23;
      }
      if (!_libssh2_get_string(v30, &__s2, 0))
      {
        v27 = __s2;
        if (__s2)
        {
          if (!strcmp("ssh-ed25519", __s2))
          {
            v28 = gen_publickey_from_ed25519_openssh_priv_data(a1, v30, a2, a3, a4, a5, 0);
            v27 = __s2;
          }
          else
          {
            v28 = -1;
          }
          if (!strcmp("ssh-rsa", v27))
          {
            v28 = gen_publickey_from_rsa_openssh_priv_data(a1, v30, a2, a3, a4, a5, 0);
            v27 = __s2;
          }
          if (!strcmp("ssh-dss", v27))
          {
            v28 = gen_publickey_from_dsa_openssh_priv_data(a1, v30, a2, a3, a4, a5, 0);
            v27 = __s2;
          }
          v29 = 0;
          if (!_libssh2_ecdsa_curve_type_from_name(v27, &v29))
            v28 = gen_publickey_from_ecdsa_openssh_priv_data(a1, v29, v30, (const char **)a2, a3, a4, (uint64_t *)a5, 0);
          if (v30)
            _libssh2_string_buf_free(a1, v30);
          if (!v28)
            return 0;
          v23 = "Unsupported OpenSSH key type";
          goto LABEL_22;
        }
      }
      v23 = "Public key type in decrypted key data not found";
      v24 = a1;
    }
    else
    {
      v23 = "Session is required";
      v24 = 0;
    }
    v25 = 4294967282;
LABEL_23:
    _libssh2_error(v24, v25, v23);
    return _libssh2_error(a1, 4294967280, "Unable to extract public key from private key file: Wrong passphrase or invalid/unrecognized private key file format");
  }
  v17 = EVP_PKEY_id((unsigned int *)bio_PrivateKey);
  if (v17 > 407)
  {
    if (v17 == 408)
    {
      v18 = gen_publickey_from_ec_evp(a1, (const char **)a2, a3, a4, (uint64_t *)a5, 0, bio_PrivateKey);
      goto LABEL_20;
    }
    if (v17 == 952)
    {
      v18 = gen_publickey_from_ed_evp(a1, a2, a3, a4, a5, (uint64_t)bio_PrivateKey);
      goto LABEL_20;
    }
LABEL_19:
    v18 = _libssh2_error(a1, 4294967280, "Unable to extract public key from private key file: Unsupported private key file format");
    goto LABEL_20;
  }
  if (v17 == 6)
  {
    v18 = gen_publickey_from_rsa_evp(a1, a2, a3, a4, a5, bio_PrivateKey);
    goto LABEL_20;
  }
  if (v17 != 116)
    goto LABEL_19;
  v18 = gen_publickey_from_dsa_evp(a1, a2, a3, a4, a5, bio_PrivateKey);
LABEL_20:
  v26 = v18;
  EVP_PKEY_free(bio_PrivateKey);
  return v26;
}

uint64_t gen_publickey_from_ed_evp(uint64_t a1, uint64_t *a2, _QWORD *a3, _QWORD *a4, _QWORD *a5, uint64_t a6)
{
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  _DWORD *v15;
  _DWORD *v16;
  uint64_t result;
  char *v18;
  uint64_t v19;
  uint64_t v20;
  _DWORD *v21;
  uint64_t v22;
  char v23[16];
  uint64_t v24;

  v24 = *MEMORY[0x24BDAC8D0];
  v22 = 0;
  strcpy(v23, "ssh-ed25519");
  v12 = (*(uint64_t (**)(uint64_t, uint64_t))(a1 + 8))(11, a1);
  if (!v12)
  {
    _libssh2_error(a1, 4294967290, "Unable to allocate memory for private key data");
    return 0xFFFFFFFFLL;
  }
  v13 = v12;
  *(_DWORD *)(v12 + 7) = 959526197;
  *(_QWORD *)v12 = *(_QWORD *)"ssh-ed25519";
  if (EVP_PKEY_get_raw_public_key(a6) != 1)
  {
    v18 = "EVP_PKEY_get_raw_public_key failed";
    v19 = a1;
    v20 = 4294967282;
LABEL_9:
    _libssh2_error(v19, v20, v18);
    (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v13, a1);
    return 0xFFFFFFFFLL;
  }
  v14 = v22 + 19;
  v15 = (_DWORD *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 8))(v22 + 19, a1);
  v21 = v15;
  if (!v15)
  {
    v18 = "Unable to allocate memory for private key data";
    v19 = a1;
    v20 = 4294967290;
    goto LABEL_9;
  }
  v16 = v15;
  _libssh2_store_str(&v21, v23, 0xBuLL);
  _libssh2_store_u32(&v21, v22);
  if (EVP_PKEY_get_raw_public_key(a6) == 1)
  {
    result = 0;
    *a2 = v13;
    *a3 = 11;
    *a4 = v16;
    *a5 = v14;
    return result;
  }
  _libssh2_error(a1, 4294967282, "EVP_PKEY_get_raw_public_key failed");
  (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v13, a1);
  (*(void (**)(_DWORD *, uint64_t))(a1 + 24))(v16, a1);
  return 0xFFFFFFFFLL;
}

uint64_t gen_publickey_from_rsa_evp(uint64_t a1, _QWORD *a2, _QWORD *a3, _QWORD *a4, char **a5, EVP_PKEY *pkey)
{
  rsa_st *v11;
  RSA *v12;
  uint64_t v13;
  _DWORD *v14;
  int v15;
  int v16;
  int v17;
  int v18;
  signed int v19;
  _DWORD *v20;
  _DWORD *v21;
  char *v22;
  char *v23;
  uint64_t result;
  BIGNUM *v25;
  BIGNUM *a;

  v11 = EVP_PKEY_get1_RSA(pkey);
  if (v11)
  {
    v12 = v11;
    v13 = (*(uint64_t (**)(uint64_t, uint64_t))(a1 + 8))(7, a1);
    if (v13)
    {
      v14 = (_DWORD *)v13;
      v25 = 0;
      a = 0;
      RSA_get0_key(v12, &v25, &a, 0);
      v15 = BN_num_bits(a);
      if (v15 >= -7)
        v16 = v15 + 7;
      else
        v16 = v15 + 14;
      v17 = BN_num_bits(v25);
      v18 = v17 + 7;
      if (v17 < -7)
        v18 = v17 + 14;
      v19 = (v18 >> 3) + 1;
      v20 = (_DWORD *)(*(uint64_t (**)(_QWORD, uint64_t))(a1 + 8))(v19 + (v16 >> 3) + 20, a1);
      if (v20)
      {
        v21 = v20;
        _libssh2_htonu32(v20, 7u);
        *(_DWORD *)((char *)v21 + 7) = 1634955821;
        v21[1] = 761820019;
        v22 = write_bn((uint64_t)v21 + 11, a, (v16 >> 3) + 1);
        v23 = (char *)(write_bn((uint64_t)v22, v25, v19) - (char *)v21);
        RSA_free(v12);
        result = 0;
        *(_DWORD *)((char *)v14 + 3) = 1634955821;
        *v14 = 761820019;
        *a2 = v14;
        *a3 = 7;
        *a4 = v21;
        *a5 = v23;
        return result;
      }
      RSA_free(v12);
      (*(void (**)(_DWORD *, uint64_t))(a1 + 24))(v14, a1);
    }
    else
    {
      RSA_free(v12);
    }
  }
  return _libssh2_error(a1, 4294967290, "Unable to allocate memory for private key data");
}

uint64_t gen_publickey_from_dsa_evp(uint64_t a1, _QWORD *a2, _QWORD *a3, _QWORD *a4, char **a5, EVP_PKEY *pkey)
{
  dsa_st *v11;
  DSA *v12;
  uint64_t v13;
  _DWORD *v14;
  int v15;
  int v16;
  int v17;
  int v18;
  signed int v19;
  int v20;
  int v21;
  signed int v22;
  int v23;
  int v24;
  signed int v25;
  _DWORD *v26;
  _DWORD *v27;
  char *v28;
  char *v29;
  char *v30;
  char *v31;
  uint64_t result;
  _QWORD *v33;
  char **v34;
  BIGNUM *v35;
  BIGNUM *v36;
  BIGNUM *v37;
  BIGNUM *a;

  v11 = EVP_PKEY_get1_DSA(pkey);
  if (v11)
  {
    v12 = v11;
    v13 = (*(uint64_t (**)(uint64_t, uint64_t))(a1 + 8))(7, a1);
    if (v13)
    {
      v14 = (_DWORD *)v13;
      v33 = a4;
      v34 = a5;
      v37 = 0;
      a = 0;
      v35 = 0;
      v36 = 0;
      DSA_get0_pqg(v12, &a, &v37, &v36);
      DSA_get0_key((uint64_t)v12, &v35, 0);
      v15 = BN_num_bits(a);
      if (v15 >= -7)
        v16 = v15 + 7;
      else
        v16 = v15 + 14;
      v17 = BN_num_bits(v37);
      v18 = v17 + 7;
      if (v17 < -7)
        v18 = v17 + 14;
      v19 = (v18 >> 3) + 1;
      v20 = BN_num_bits(v36);
      v21 = v20 + 7;
      if (v20 < -7)
        v21 = v20 + 14;
      v22 = (v21 >> 3) + 1;
      v23 = BN_num_bits(v35);
      v24 = v23 + 7;
      if (v23 < -7)
        v24 = v23 + 14;
      v25 = (v24 >> 3) + 1;
      v26 = (_DWORD *)(*(uint64_t (**)(_QWORD, uint64_t))(a1 + 8))(v19 + (v16 >> 3) + v22 + v25 + 28, a1);
      if (v26)
      {
        v27 = v26;
        _libssh2_htonu32(v26, 7u);
        *(_DWORD *)((char *)v27 + 7) = 1936942125;
        v27[1] = 761820019;
        v28 = write_bn((uint64_t)v27 + 11, a, (v16 >> 3) + 1);
        v29 = write_bn((uint64_t)v28, v37, v19);
        v30 = write_bn((uint64_t)v29, v36, v22);
        v31 = (char *)(write_bn((uint64_t)v30, v35, v25) - (char *)v27);
        DSA_free(v12);
        result = 0;
        *(_DWORD *)((char *)v14 + 3) = 1936942125;
        *v14 = 761820019;
        *a2 = v14;
        *a3 = 7;
        *v33 = v27;
        *v34 = v31;
        return result;
      }
      DSA_free(v12);
      (*(void (**)(_DWORD *, uint64_t))(a1 + 24))(v14, a1);
    }
    else
    {
      DSA_free(v12);
    }
  }
  return _libssh2_error(a1, 4294967290, "Unable to allocate memory for private key data");
}

uint64_t gen_publickey_from_ec_evp(uint64_t a1, const char **a2, size_t *a3, _QWORD *a4, uint64_t *a5, int a6, EVP_PKEY *a7)
{
  BN_CTX *v14;
  BN_CTX *v15;
  ec_key_st *v16;
  const EC_KEY *v17;
  const EC_POINT *v18;
  const EC_GROUP *v19;
  const EC_GROUP *v20;
  int curve_name;
  uint64_t v22;
  char *v23;
  const char *v24;
  const char *v25;
  size_t v26;
  char v27;
  void *v28;
  unint64_t v30;
  uint64_t v31;
  _DWORD *v32;
  _DWORD *v33;
  const char *v34;
  uint64_t *v35;
  const char **v36;
  _QWORD *v37;
  _DWORD *v38;

  v14 = BN_CTX_new();
  if (!v14)
    return 0xFFFFFFFFLL;
  v15 = v14;
  v16 = EVP_PKEY_get1_EC_KEY(a7);
  if (!v16)
  {
    BN_CTX_free(v15);
    return 0xFFFFFFFFLL;
  }
  v17 = v16;
  v36 = a2;
  v37 = a4;
  v18 = EC_KEY_get0_public_key(v16);
  v19 = EC_KEY_get0_group(v17);
  v20 = EC_KEY_get0_group(v17);
  curve_name = EC_GROUP_get_curve_name(v20);
  if (a6)
    v22 = 34;
  else
    v22 = 19;
  *a3 = v22;
  v23 = (char *)(*(uint64_t (**)(void))(a1 + 8))();
  if (!v23)
    return _libssh2_error(a1, 4294967290, "out of memory");
  v24 = v23;
  v38 = 0;
  v35 = a5;
  if (a6)
  {
    v25 = "sk-ecdsa-sha2-nistp256@openssh.com";
  }
  else
  {
    switch(curve_name)
    {
      case 415:
        v25 = "ecdsa-sha2-nistp256";
        break;
      case 716:
        v25 = "ecdsa-sha2-nistp521";
        break;
      case 715:
        v25 = "ecdsa-sha2-nistp384";
        break;
      default:
        goto LABEL_10;
    }
  }
  memcpy(v23, v25, *a3);
  v26 = EC_POINT_point2oct(v19, v18, POINT_CONVERSION_UNCOMPRESSED, 0, 0, v15);
  if (v26 <= 0x85)
  {
    v30 = v26;
    v28 = malloc_type_malloc(v26, 0x162F364CuLL);
    if (v28
      && EC_POINT_point2oct(v19, v18, POINT_CONVERSION_UNCOMPRESSED, (unsigned __int8 *)v28, v30, v15) == v30
      && (v31 = v30 + *a3 + 20, (v32 = (_DWORD *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 8))(v31, a1)) != 0))
    {
      v33 = v32;
      v38 = v32;
      _libssh2_store_str(&v38, v24, *a3);
      if (a6)
        v34 = "nistp256";
      else
        v34 = v24 + 11;
      _libssh2_store_str(&v38, v34, 8uLL);
      _libssh2_store_str(&v38, v28, v30);
      *v36 = v24;
      *v37 = v33;
      v27 = 1;
      *v35 = v31;
    }
    else
    {
      v27 = 0;
    }
    goto LABEL_25;
  }
LABEL_10:
  v27 = 0;
  v28 = 0;
LABEL_25:
  EC_KEY_free(v17);
  BN_CTX_free(v15);
  if (v28)
  {
    free(v28);
    if ((v27 & 1) != 0)
      return 0;
  }
  else if ((v27 & 1) != 0)
  {
    return 0;
  }
  (*(void (**)(const char *, uint64_t))(a1 + 24))(v24, a1);
  return 0xFFFFFFFFLL;
}

uint64_t _libssh2_pub_priv_openssh_keyfilememory(uint64_t a1, EVP_PKEY **a2, char *__s, uint64_t *a4, size_t *a5, _QWORD *a6, char **a7, uint64_t a8, unint64_t a9, const char *a10)
{
  char *v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  uint64_t v23;
  int v24;
  _QWORD *v25;
  char *__s2;

  v25 = 0;
  __s2 = 0;
  if (a2)
    *a2 = 0;
  if (!a1)
  {
    v18 = "Session is required";
    v19 = 0;
    return _libssh2_error(v19, 4294967282, v18);
  }
  if (__s && strlen(__s) - 12 <= 0xFFFFFFFFFFFFFFFALL)
  {
    v18 = "type is invalid";
    v19 = a1;
    return _libssh2_error(v19, 4294967282, v18);
  }
  _libssh2_init_if_needed();
  v20 = _libssh2_openssh_pem_parse_memory(a1, a10, a8, a9, &v25);
  if (!(_DWORD)v20)
  {
    if (!_libssh2_get_string(v25, &__s2, 0))
    {
      v21 = __s2;
      if (__s2)
      {
        if (!strcmp("ssh-ed25519", __s2))
        {
          if (__s && strcmp("ssh-ed25519", __s))
          {
            v20 = 4294967280;
            if (strcmp("sk-ssh-ed25519@openssh.com", v21))
              goto LABEL_24;
            goto LABEL_22;
          }
          v20 = gen_publickey_from_ed25519_openssh_priv_data(a1, v25, a4, a5, a6, a7, a2);
          v21 = __s2;
        }
        else
        {
          v20 = 4294967280;
        }
        if (strcmp("sk-ssh-ed25519@openssh.com", v21))
          goto LABEL_24;
        if (!__s)
        {
LABEL_23:
          v20 = gen_publickey_from_sk_ed25519_openssh_priv_data(a1, v25, a4, a5, a6, a7, 0, 0, 0, 0, a2);
          v21 = __s2;
LABEL_24:
          if (!strcmp("ssh-rsa", v21))
          {
            if (__s && strcmp("ssh-rsa", __s))
            {
              if (strcmp("ssh-dss", v21))
                goto LABEL_34;
              goto LABEL_32;
            }
            v20 = gen_publickey_from_rsa_openssh_priv_data(a1, v25, a4, a5, a6, a7, (RSA **)a2);
            v21 = __s2;
          }
          if (strcmp("ssh-dss", v21))
            goto LABEL_34;
          if (!__s)
          {
LABEL_33:
            v20 = gen_publickey_from_dsa_openssh_priv_data(a1, v25, a4, a5, a6, a7, (DSA **)a2);
            v21 = __s2;
LABEL_34:
            v24 = 0;
            if (!strcmp("sk-ecdsa-sha2-nistp256@openssh.com", v21))
            {
              v23 = gen_publickey_from_sk_ecdsa_openssh_priv_data(a1, v25, (const char **)a4, a5, a6, (uint64_t *)a7, 0, 0, 0, 0, (EC_KEY **)a2);
            }
            else
            {
              if (_libssh2_ecdsa_curve_type_from_name(v21, &v24) || __s && strcmp("ssh-ecdsa", __s))
                goto LABEL_41;
              v23 = gen_publickey_from_ecdsa_openssh_priv_data(a1, v24, v25, (const char **)a4, a5, a6, (uint64_t *)a7, (EC_KEY **)a2);
            }
            v20 = v23;
LABEL_41:
            if ((_DWORD)v20 == -16)
              v20 = _libssh2_error(a1, 4294967280, "Unable to extract public key from private key file: invalid/unrecognized private key file format");
            if (v25)
              _libssh2_string_buf_free(a1, v25);
            return v20;
          }
LABEL_32:
          if (strcmp("ssh-dss", __s))
            goto LABEL_34;
          goto LABEL_33;
        }
LABEL_22:
        if (strcmp("sk-ssh-ed25519@openssh.com", __s))
          goto LABEL_24;
        goto LABEL_23;
      }
    }
    return _libssh2_error(a1, 4294967282, "Public key type in decrypted key data not found");
  }
  return v20;
}

uint64_t _libssh2_pub_priv_keyfilememory(uint64_t a1, const char **a2, size_t *a3, _QWORD *a4, uint64_t *a5, void *buf, unint64_t len, void *a8)
{
  BIO *v16;
  BIO *v17;
  EVP_PKEY *bio_PrivateKey;
  int v19;
  uint64_t v20;
  char *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v25;

  v16 = BIO_new_mem_buf(buf, len);
  if (!v16)
  {
    v21 = "Unable to allocate memory whencomputing public key";
    v22 = a1;
    v23 = 4294967290;
    return _libssh2_error(v22, v23, v21);
  }
  v17 = v16;
  BIO_ctrl(v16, 1, 0, 0);
  bio_PrivateKey = PEM_read_bio_PrivateKey(v17, 0, 0, a8);
  BIO_free(v17);
  if (bio_PrivateKey)
  {
    v19 = EVP_PKEY_id((unsigned int *)bio_PrivateKey);
    if (v19 > 407)
    {
      if (v19 == 408)
      {
        v20 = gen_publickey_from_ec_evp(a1, a2, a3, a4, a5, 0, bio_PrivateKey);
        goto LABEL_18;
      }
      if (v19 == 952)
      {
        v20 = gen_publickey_from_ed_evp(a1, (uint64_t *)a2, a3, a4, a5, (uint64_t)bio_PrivateKey);
        goto LABEL_18;
      }
    }
    else
    {
      if (v19 == 6)
      {
        v20 = gen_publickey_from_rsa_evp(a1, a2, a3, a4, (char **)a5, bio_PrivateKey);
        goto LABEL_18;
      }
      if (v19 == 116)
      {
        v20 = gen_publickey_from_dsa_evp(a1, a2, a3, a4, (char **)a5, bio_PrivateKey);
LABEL_18:
        v25 = v20;
        EVP_PKEY_free(bio_PrivateKey);
        return v25;
      }
    }
    v20 = _libssh2_error(a1, 4294967280, "Unable to extract public key from private key file: Unsupported private key file format");
    goto LABEL_18;
  }
  if (_libssh2_pub_priv_openssh_keyfilememory(a1, 0, 0, (uint64_t *)a2, a3, a4, (char **)a5, (uint64_t)buf, len, (const char *)a8))
  {
    v21 = "Unable to extract public key from private key file: Unsupported private key file format";
    v22 = a1;
    v23 = 4294967280;
    return _libssh2_error(v22, v23, v21);
  }
  return 0;
}

uint64_t _libssh2_sk_pub_keyfilememory(uint64_t a1, const char **a2, size_t *a3, _QWORD *a4, uint64_t *a5, _DWORD *a6, _BYTE *a7, void **a8, _QWORD *a9, size_t *a10, void *a11, unint64_t a12, void *a13)
{
  BIO *v17;
  BIO *v18;
  EVP_PKEY *bio_PrivateKey;
  _DWORD *v21;

  v17 = BIO_new_mem_buf(a11, a12);
  if (!v17)
    return _libssh2_error(a1, 4294967290, "Unable to allocate memory whencomputing public key");
  v18 = v17;
  v21 = a6;
  BIO_ctrl(v17, 1, 0, 0);
  bio_PrivateKey = PEM_read_bio_PrivateKey(v18, 0, 0, a13);
  BIO_free(v18);
  if (bio_PrivateKey)
    return 0xFFFFFFFFLL;
  else
    return _libssh2_sk_pub_openssh_keyfilememory(a1, 0, 0, a2, a3, a4, a5, v21, a7, a8, a9, a10, (uint64_t)a11, a12, (const char *)a13);
}

BIGNUM *_libssh2_dh_init(BIGNUM **a1)
{
  BIGNUM *result;

  result = BN_new();
  *a1 = result;
  return result;
}

uint64_t _libssh2_dh_key_pair(BIGNUM **a1, BIGNUM *a2, const BIGNUM *a3, const BIGNUM *a4, int a5, BN_CTX *a6)
{
  BN_rand(*a1, 8 * a5 - 1, 0, -1);
  BN_mod_exp(a2, a3, *a1, a4, a6);
  return 0;
}

uint64_t _libssh2_dh_secret(const BIGNUM **a1, BIGNUM *r, BIGNUM *a, const BIGNUM *a4, BN_CTX *a5)
{
  BN_mod_exp(r, a, *a1, a4, a5);
  return 0;
}

void _libssh2_dh_dtor(BIGNUM **a1)
{
  BN_clear_free(*a1);
  *a1 = 0;
}

const char *_libssh2_supported_key_sign_algorithms(uint64_t a1, _DWORD *a2, uint64_t a3)
{
  BOOL v3;

  if (a3 == 7 && (*a2 == 761820019 ? (v3 = *(_DWORD *)((char *)a2 + 3) == 1634955821) : (v3 = 0), v3))
    return "rsa-sha2-512,rsa-sha2-256,ssh-rsa";
  else
    return 0;
}

uint64_t passphrase_cb(void *a1, int a2, int a3, char *__s)
{
  unsigned int v7;
  uint64_t v8;

  v7 = strlen(__s);
  if ((int)v7 >= a2)
    v8 = (a2 - 1);
  else
    v8 = v7;
  memcpy(a1, __s, (int)v8);
  *((_BYTE *)a1 + (int)v8) = 0;
  return v8;
}

uint64_t gen_publickey_from_rsa_openssh_priv_data(uint64_t a1, _QWORD *a2, _QWORD *a3, _QWORD *a4, _QWORD *a5, char **a6, RSA **a7)
{
  char *v14;
  uint64_t v15;
  RSA *v17;
  EVP_PKEY *v18;
  RSA *v19;
  uint64_t v20;
  const unsigned __int8 *v21;
  const unsigned __int8 *v22;
  const unsigned __int8 *v23;
  BIGNUM *v24;
  const unsigned __int8 *v25;
  const unsigned __int8 *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;

  v32 = 0;
  v33 = 0;
  v30 = 0;
  v31 = 0;
  v28 = 0;
  v29 = 0;
  v26 = 0;
  v27 = 0;
  v24 = 0;
  v25 = 0;
  v22 = 0;
  v23 = 0;
  v20 = 0;
  v21 = 0;
  v19 = 0;
  if (_libssh2_get_bignum_bytes(a2, &v26, &v33))
  {
    v14 = "RSA no n";
LABEL_15:
    _libssh2_error(a1, 4294967282, v14);
    return 0xFFFFFFFFLL;
  }
  if (_libssh2_get_bignum_bytes(a2, &v25, &v32))
  {
    v14 = "RSA no e";
    goto LABEL_15;
  }
  if (_libssh2_get_bignum_bytes(a2, &v24, &v31))
  {
    v14 = "RSA no d";
    goto LABEL_15;
  }
  if (_libssh2_get_bignum_bytes(a2, &v21, &v28))
  {
    v14 = "RSA no coeff";
    goto LABEL_15;
  }
  if (_libssh2_get_bignum_bytes(a2, &v23, &v30))
  {
    v14 = "RSA no p";
    goto LABEL_15;
  }
  if (_libssh2_get_bignum_bytes(a2, &v22, &v29))
  {
    v14 = "RSA no q";
    goto LABEL_15;
  }
  if (_libssh2_get_string(a2, &v20, &v27))
  {
    v14 = "RSA no comment";
    goto LABEL_15;
  }
  _libssh2_rsa_new((uint64_t *)&v19, v25, v32, v26, v33, v24, v31, v23, v30, v22, v29, 0, 0, 0, 0, v21, v28);
  v17 = v19;
  if (v19)
  {
    v15 = _libssh2_rsa_new_additional_parameters(v19);
    if (a3)
    {
      if (a5)
      {
        v18 = EVP_PKEY_new();
        EVP_PKEY_set1_RSA(v18, v17);
        v15 = gen_publickey_from_rsa_evp(a1, a3, a4, a5, a6, v18);
        if (v18)
          EVP_PKEY_free(v18);
      }
    }
  }
  else
  {
    v15 = 0;
  }
  if (a7)
    *a7 = v17;
  else
    RSA_free(v17);
  return v15;
}

uint64_t _libssh2_rsa_new_additional_parameters(_QWORD *a1)
{
  BN_CTX *v2;
  BN_CTX *v3;
  BIGNUM *v4;
  BIGNUM *v5;
  BIGNUM *v6;
  BIGNUM *v7;
  const BIGNUM *v8;
  const BIGNUM *v9;
  const BIGNUM *v10;
  const BIGNUM *v11;
  uint64_t v12;
  char v13;
  BIGNUM *m;
  const BIGNUM *v16;
  const BIGNUM *v17;

  v16 = 0;
  v17 = 0;
  m = 0;
  RSA_get0_key(a1, 0, 0, &m);
  RSA_get0_factors((uint64_t)a1, &v17, &v16);
  v2 = BN_CTX_new();
  if (!v2)
    return 0xFFFFFFFFLL;
  v3 = v2;
  v4 = BN_new();
  if (!v4)
  {
    BN_CTX_free(v3);
    return 0xFFFFFFFFLL;
  }
  v5 = v4;
  v6 = BN_new();
  if (v6)
  {
    v7 = BN_new();
    if (v7)
    {
      v8 = v16;
      v9 = BN_value_one();
      if (BN_sub(v5, v8, v9))
      {
        if (BN_div(0, v7, m, v5, v3))
        {
          v10 = v17;
          v11 = BN_value_one();
          if (BN_sub(v5, v10, v11))
          {
            if (BN_div(0, v6, m, v5, v3))
            {
              RSA_set0_crt_params((uint64_t)a1, (uint64_t)v6, (uint64_t)v7, 0);
              v12 = 0;
              v13 = 1;
              goto LABEL_14;
            }
          }
        }
      }
    }
  }
  else
  {
    v7 = 0;
  }
  v13 = 0;
  v12 = 0xFFFFFFFFLL;
LABEL_14:
  BN_clear_free(v5);
  BN_CTX_free(v3);
  if ((v13 & 1) == 0)
  {
    if (v6)
      BN_clear_free(v6);
    if (v7)
      BN_clear_free(v7);
  }
  return v12;
}

uint64_t gen_publickey_from_dsa_openssh_priv_data(uint64_t a1, _QWORD *a2, _QWORD *a3, _QWORD *a4, _QWORD *a5, char **a6, DSA **a7)
{
  char *v14;
  uint64_t v15;
  DSA *v17;
  EVP_PKEY *v18;
  DSA *r;
  const unsigned __int8 *v20;
  const unsigned __int8 *v21;
  const unsigned __int8 *v22;
  const unsigned __int8 *v23;
  const unsigned __int8 *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;

  v29 = 0;
  v27 = 0;
  v28 = 0;
  v25 = 0;
  v26 = 0;
  v23 = 0;
  v24 = 0;
  v21 = 0;
  v22 = 0;
  r = 0;
  v20 = 0;
  if (_libssh2_get_bignum_bytes(a2, &v24, &v29))
  {
    v14 = "DSA no p";
LABEL_11:
    _libssh2_error(a1, 4294967282, v14);
    return 0xFFFFFFFFLL;
  }
  if (_libssh2_get_bignum_bytes(a2, &v23, &v28))
  {
    v14 = "DSA no q";
    goto LABEL_11;
  }
  if (_libssh2_get_bignum_bytes(a2, &v22, &v27))
  {
    v14 = "DSA no g";
    goto LABEL_11;
  }
  if (_libssh2_get_bignum_bytes(a2, &v21, &v26))
  {
    v14 = "DSA no public key";
    goto LABEL_11;
  }
  if (_libssh2_get_bignum_bytes(a2, &v20, &v25))
  {
    v14 = "DSA no private key";
    goto LABEL_11;
  }
  _libssh2_dsa_new((uint64_t *)&r, v24, v29, v23, v28, v22, v27, v21, v26, v20, v25);
  v15 = 0;
  v17 = r;
  if (a3)
  {
    if (a5)
    {
      if (r)
      {
        v18 = EVP_PKEY_new();
        EVP_PKEY_set1_DSA(v18, v17);
        v15 = gen_publickey_from_dsa_evp(a1, a3, a4, a5, a6, v18);
        if (v18)
          EVP_PKEY_free(v18);
      }
    }
  }
  if (a7)
    *a7 = v17;
  else
    DSA_free(v17);
  return v15;
}

uint64_t gen_publickey_from_ecdsa_openssh_priv_data(uint64_t a1, int a2, _QWORD *a3, const char **a4, size_t *a5, _QWORD *a6, uint64_t *a7, EC_KEY **a8)
{
  char *v16;
  uint64_t v17;
  char *v19;
  uint64_t v20;
  uint64_t v21;
  BIGNUM *v22;
  const BIGNUM *v23;
  int v24;
  EVP_PKEY *v25;
  EC_KEY *key;
  int v27[2];
  unsigned __int8 *s;
  uint64_t v29;
  int v30[2];
  int len[2];
  uint64_t v32;

  *(_QWORD *)len = 0;
  v32 = 0;
  v29 = 0;
  *(_QWORD *)v30 = 0;
  *(_QWORD *)v27 = 0;
  s = 0;
  key = 0;
  if (_libssh2_get_string(a3, &v29, &v32) || !v32)
  {
    v16 = "ECDSA no curve";
    goto LABEL_6;
  }
  if (_libssh2_get_string(a3, v27, v30))
  {
    v16 = "ECDSA no point";
LABEL_6:
    _libssh2_error(a1, 4294967282, v16);
    return 0xFFFFFFFFLL;
  }
  if (_libssh2_get_bignum_bytes(a3, &s, len))
  {
    v16 = "ECDSA no exponent";
    goto LABEL_6;
  }
  if (_libssh2_ecdsa_curve_name_with_octal_new(&key, *(const unsigned __int8 **)v27, *(size_t *)v30, a2))
  {
    v19 = "ECDSA could not create key";
    v20 = a1;
    v21 = 4294967282;
    goto LABEL_13;
  }
  v22 = BN_new();
  if (!v22)
  {
    v19 = "Unable to allocate memory for private key data";
    v20 = a1;
    v21 = 4294967290;
LABEL_13:
    _libssh2_error(v20, v21, v19);
    if (key)
      EC_KEY_free(key);
    return 0xFFFFFFFFLL;
  }
  v23 = v22;
  BN_bin2bn(s, len[0], v22);
  v24 = EC_KEY_set_private_key(key, v23);
  v17 = v24 != 1;
  if (a4)
  {
    if (a6)
    {
      if (v24 == 1)
      {
        if (key)
        {
          v25 = EVP_PKEY_new();
          EVP_PKEY_set1_EC_KEY(v25, key);
          v17 = gen_publickey_from_ec_evp(a1, a4, a5, a6, a7, 0, v25);
          if (v25)
            EVP_PKEY_free(v25);
        }
      }
    }
  }
  if (a8)
    *a8 = key;
  else
    EC_KEY_free(key);
  return v17;
}

uint64_t gen_publickey_from_sk_ecdsa_openssh_priv_data(uint64_t a1, _QWORD *a2, const char **a3, size_t *a4, _QWORD *a5, uint64_t *a6, _BYTE *a7, void **a8, _QWORD *a9, size_t *a10, EC_KEY **a11)
{
  char *v19;
  uint64_t v20;
  char *v22;
  void *v23;
  EVP_PKEY *v24;
  size_t v25;
  char *v26;
  char *v27;
  size_t v28;
  void *v29;
  void *__src;
  EC_KEY *key;
  void *v32;
  char *v33;
  int v34[2];
  uint64_t v35;
  size_t __n;
  int v37[2];
  uint64_t v38;

  *(_QWORD *)v37 = 0;
  v38 = 0;
  v35 = 0;
  __n = 0;
  v33 = 0;
  *(_QWORD *)v34 = 0;
  key = 0;
  v32 = 0;
  if (_libssh2_get_string(a2, &v35, &v38) || !v38)
  {
    v19 = "ECDSA no curve";
    goto LABEL_6;
  }
  if (_libssh2_get_string(a2, v34, v37))
  {
    v19 = "ECDSA no point";
LABEL_6:
    _libssh2_error(a1, 4294967282, v19);
    return 0xFFFFFFFFLL;
  }
  if (!_libssh2_ecdsa_curve_name_with_octal_new(&key, *(const unsigned __int8 **)v34, *(size_t *)v37, 415))
  {
    if (_libssh2_get_string(a2, &v32, &__n))
    {
      v22 = "No SK application.";
    }
    else
    {
      if (!a7 || !_libssh2_get_byte(a2, a7))
      {
        if (a9 && a10)
        {
          __src = 0;
          if (_libssh2_get_string(a2, &__src, a10))
          {
            v22 = "No SK key_handle.";
            goto LABEL_13;
          }
          if (*a10)
          {
            v23 = (void *)(*(uint64_t (**)(size_t, uint64_t))(a1 + 8))(*a10, a1);
            *a9 = v23;
            if (v23)
              memcpy(v23, __src, *a10);
          }
        }
        v20 = 0;
        if (a5)
        {
          if (a3)
          {
            if (key)
            {
              v24 = EVP_PKEY_new();
              EVP_PKEY_set1_EC_KEY(v24, key);
              v20 = gen_publickey_from_ec_evp(a1, a3, a4, a5, a6, 1, v24);
              if (v24)
                EVP_PKEY_free(v24);
            }
          }
        }
        if (a5 && !(_DWORD)v20)
        {
          v25 = *a6 + __n + 4;
          v26 = (char *)(*(uint64_t (**)(size_t, uint64_t))(a1 + 8))(v25, a1);
          if (!v26)
            goto LABEL_10;
          v27 = v26;
          v28 = *a6;
          v33 = &v26[*a6];
          memcpy(v26, (const void *)*a5, v28);
          _libssh2_store_str((_DWORD **)&v33, v32, __n);
          if (a8 && __n)
          {
            v29 = (void *)(*(uint64_t (**)(size_t, uint64_t))(a1 + 8))(__n + 1, a1);
            *a8 = v29;
            memset_s(v29, __n + 1, 0, __n + 1);
            memcpy(*a8, v32, __n);
          }
          (*(void (**)(_QWORD, uint64_t))(a1 + 24))(*a5, a1);
          *a6 = v25;
          *a5 = v27;
        }
        if (a11)
          *a11 = key;
        else
          EC_KEY_free(key);
        return v20;
      }
      v22 = "No SK flags.";
    }
LABEL_13:
    _libssh2_error(a1, 4294967282, v22);
    v20 = 0;
    goto LABEL_14;
  }
  _libssh2_error(a1, 4294967282, "ECDSA could not create key");
LABEL_10:
  v20 = 0xFFFFFFFFLL;
LABEL_14:
  if (key)
    EC_KEY_free(key);
  if (a8 && *a8)
  {
    (*(void (**)(void **, uint64_t))(a1 + 24))(a8, a1);
    *a8 = 0;
  }
  if (a9 && *a9)
  {
    (*(void (**)(_QWORD *, uint64_t))(a1 + 24))(a9, a1);
    *a9 = 0;
  }
  return v20;
}

void _libssh2_cipher_crypt_cold_1()
{
  __assert_rtn("_libssh2_cipher_crypt", "openssl.c", 538, "blocksize <= sizeof(buf)");
}

void _libssh2_cipher_crypt_cold_2()
{
  __assert_rtn("_libssh2_cipher_crypt", "openssl.c", 539, "cryptlen >= 0");
}

uint64_t userauth_keyboard_interactive_decode_info_request(_QWORD *a1)
{
  _QWORD *v2;
  unint64_t v3;
  char *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t result;
  void *v9;
  void *v10;
  uint64_t v11;
  unint64_t v12;
  _QWORD v13[3];
  unsigned int v14;
  char v15;
  uint64_t v16;
  uint64_t v17;

  v2 = a1 + 9038;
  v3 = a1[9039];
  v13[0] = a1[9038];
  v13[1] = v13[0];
  v13[2] = v3;
  if (v3 > 0x10)
  {
    v16 = 0;
    v17 = 0;
    v15 = 0;
    v14 = 0;
    _libssh2_get_byte(v13, &v15);
    if (_libssh2_copy_string((uint64_t)a1, v13, a1 + 9043, a1 + 9042) == -1)
    {
      v4 = "Unable to decode keyboard-interactive 'name' request field";
    }
    else if (_libssh2_copy_string((uint64_t)a1, v13, a1 + 9045, a1 + 9044) == -1)
    {
      v4 = "Unable to decode keyboard-interactive 'instruction' request field";
    }
    else if (_libssh2_get_string(v13, &v17, &v16) == -1)
    {
      v4 = "Unable to decode keyboard-interactive 'language tag' request field";
    }
    else
    {
      if (_libssh2_get_u32(v13, &v14) == -1)
      {
        v4 = "Unable to decode keyboard-interactive number of keyboard prompts";
        goto LABEL_3;
      }
      v7 = v14;
      *((_DWORD *)v2 + 16) = v14;
      if (v7 > 0x64)
      {
        v4 = "Too many replies for keyboard-interactive prompts";
        v5 = (uint64_t)a1;
        v6 = 4294967255;
        goto LABEL_14;
      }
      if (!(_DWORD)v7)
        return 0;
      v9 = _libssh2_calloc((uint64_t)a1, 24 * v7);
      v2[9] = v9;
      if (v9)
      {
        v10 = _libssh2_calloc((uint64_t)a1, 16 * *((unsigned int *)v2 + 16));
        v2[10] = v10;
        if (v10)
        {
          if (*((_DWORD *)v2 + 16))
          {
            v11 = 0;
            v12 = 0;
            while (1)
            {
              if (_libssh2_copy_string((uint64_t)a1, v13, (_QWORD *)(v2[9] + v11), (size_t *)(v2[9] + v11 + 8)) == -1)
              {
                v4 = "Unable to decode keyboard-interactive prompt message";
                goto LABEL_13;
              }
              if (_libssh2_get_BOOLean(v13, (BOOL *)(v2[9] + v11 + 16)) == -1)
                break;
              result = 0;
              ++v12;
              v11 += 24;
              if (v12 >= *((unsigned int *)v2 + 16))
                return result;
            }
            v4 = "Unable to decode user auth keyboard prompt echo";
            goto LABEL_3;
          }
          return 0;
        }
        v4 = "Unable to allocate memory for keyboard-interactive responses array";
      }
      else
      {
        v4 = "Unable to allocate memory for keyboard-interactive prompts array";
      }
    }
LABEL_13:
    v5 = (uint64_t)a1;
    v6 = 4294967290;
    goto LABEL_14;
  }
  v4 = "userauth keyboard data buffer too small to get length";
LABEL_3:
  v5 = (uint64_t)a1;
  v6 = 4294967258;
LABEL_14:
  _libssh2_error(v5, v6, v4);
  return 0xFFFFFFFFLL;
}

uint64_t _libssh2_transport_read(uint64_t a1)
{
  uint64_t v2;
  int64_t *v3;
  _DWORD *v4;
  int v5;
  unsigned __int8 *v6;
  unint64_t v7;
  uint64_t v8;
  int v9;
  int v10;
  uint64_t v11;
  char v12;
  uint64_t v13;
  int64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  char *v21;
  uint64_t v22;
  unsigned int v23;
  unsigned int v24;
  unsigned int v25;
  int v26;
  _BYTE *v27;
  size_t v28;
  _BYTE *v29;
  uint64_t v30;
  char v31;
  int v32;
  uint64_t v33;
  unint64_t v34;
  uint64_t v35;
  char v36;
  uint64_t v37;
  unsigned int v38;
  int v39;
  uint64_t v40;
  void *v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  int v46;
  size_t v47;
  void (*v48)(uint64_t, _BYTE *, _QWORD, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t);
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v59;
  char *v60;
  char *v61;
  uint64_t v62;
  int v63;
  unint64_t v64;
  int v65;
  unsigned __int8 v66;
  _BYTE v67[3];
  char v68[32];
  _BYTE __s1[64];
  uint64_t v70;

  v70 = *MEMORY[0x24BDAC8D0];
  *(_DWORD *)(a1 + 600) &= ~1u;
  if ((*(_DWORD *)(a1 + 128) & 9) == 1)
  {
    v2 = _libssh2_kex_exchange(a1, 1, a1 + 71088);
    if ((_DWORD)v2)
      return v2;
  }
  v3 = (int64_t *)(a1 + 35632);
  if (*(_DWORD *)(a1 + 72040) == 11)
  {
    *(_DWORD *)(a1 + 72040) = 0;
    v63 = *(_DWORD *)(a1 + 72044);
LABEL_5:
    v4 = (_DWORD *)(a1 + 72040);
    v5 = *(_DWORD *)(a1 + 72872);
    if (v5)
    {
      if (v5 != 2)
        goto LABEL_110;
      v6 = *(unsigned __int8 **)(a1 + 35672);
      v7 = *(_QWORD *)(a1 + 72880);
LABEL_107:
      v56 = _libssh2_packet_add(a1, v6, v7, v4[209]);
      if ((_DWORD)v56)
      {
        v2 = v56;
        if ((_DWORD)v56 == -37)
        {
LABEL_112:
          if (v4[140])
          {
            *v4 = 11;
            v4[1] = v63;
          }
          return 4294967259;
        }
        v4[208] = 0;
LABEL_111:
        if ((_DWORD)v2 != -37)
        {
LABEL_120:
          *(_QWORD *)(a1 + 35664) = 0;
          return v2;
        }
        goto LABEL_112;
      }
LABEL_110:
      v4[208] = 0;
      v2 = v4[212];
      goto LABEL_111;
    }
    *(_DWORD *)(a1 + 72876) = 0;
    v43 = (*(_DWORD *)(a1 + 35648) - 1);
    *(_QWORD *)(a1 + 72880) = v43;
    if (v63)
    {
      v44 = *(_QWORD *)(a1 + 448);
      if (!v44 || (*(_BYTE *)(v44 + 32) & 1) == 0)
      {
        v45 = *(_QWORD *)(a1 + 352);
        v46 = *(_DWORD *)(v45 + 40);
        v47 = *(int *)(v45 + 8);
        v48 = *(void (**)(uint64_t, _BYTE *, _QWORD, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(v45 + 24);
        if (v46)
        {
          v49 = *(_QWORD *)(a1 + 35672);
          v50 = *(_QWORD *)(a1 + 35664) - v47;
          v51 = a1 + 368;
          v52 = a1;
          v53 = 0;
          v43 = 0;
        }
        else
        {
          v49 = a1 + 35624;
          v53 = *(_QWORD *)(a1 + 35672);
          v51 = a1 + 368;
          v52 = a1;
          v50 = 5;
        }
        v48(v52, __s1, *(unsigned int *)(a1 + 360), v49, v50, v53, v43, v51);
        v54 = *(_QWORD *)(a1 + 35672);
        if (!memcmp(__s1, (const void *)(v54 + *(_QWORD *)(a1 + 35664) - v47), v47))
        {
          if (v46)
          {
            v57 = *(int *)(*(_QWORD *)(a1 + 336) + 16);
            v2 = decrypt(a1, (char *)(v54 + 4), v68, v57, 1u);
            if (!(_DWORD)v2)
            {
              v59 = *(_QWORD *)(a1 + 35664) - v47 - 4;
              v60 = (char *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 8))(v59, a1);
              if (v60)
              {
                v61 = v60;
                *(_BYTE *)(a1 + 35652) = v68[0];
                if ((int)v57 >= 2)
                  memcpy(v60, &v68[1], (v57 - 1));
                if (v59 <= v57
                  || (v62 = decrypt(a1, (char *)(*(_QWORD *)(a1 + 35672) + v57 + 4), &v61[v57 - 1], v59 - v57, 2u),
                      !(_DWORD)v62))
                {
                  (*(void (**)(_QWORD, uint64_t))(a1 + 24))(*(_QWORD *)(a1 + 35672), a1);
                  *(_QWORD *)(a1 + 35672) = v61;
                  goto LABEL_99;
                }
                v2 = v62;
                (*(void (**)(char *, uint64_t))(a1 + 24))(v61, a1);
              }
              else
              {
                v2 = 4294967290;
              }
            }
            v4 = (_DWORD *)(a1 + 72040);
            goto LABEL_111;
          }
        }
        else
        {
          *(_DWORD *)(a1 + 72876) = -1;
        }
      }
    }
LABEL_99:
    ++*(_DWORD *)(a1 + 360);
    v4 = (_DWORD *)(a1 + 72040);
    v7 = *(_QWORD *)(a1 + 72880) - *(unsigned __int8 *)(a1 + 35652);
    *(_QWORD *)(a1 + 72880) = v7;
    v55 = *(_QWORD *)(a1 + 488);
    if (v55
      && *(_DWORD *)(v55 + 8)
      && ((*(_BYTE *)(a1 + 128) & 4) != 0 || *(_DWORD *)(v55 + 12))
      && *(_QWORD *)(a1 + 384))
    {
      *(_QWORD *)v68 = 0;
      v64 = 0;
      v2 = (*(uint64_t (**)(uint64_t, char *, unint64_t *, uint64_t, _QWORD))(*(_QWORD *)(a1 + 376) + 32))(a1, v68, &v64, 40000, *(_QWORD *)(a1 + 35672));
      (*(void (**)(_QWORD, uint64_t))(a1 + 24))(*(_QWORD *)(a1 + 35672), a1);
      if ((_DWORD)v2)
        goto LABEL_111;
      *(_QWORD *)(a1 + 35672) = *(_QWORD *)v68;
      v7 = v64;
      *(_QWORD *)(a1 + 72880) = v64;
    }
    v6 = *(unsigned __int8 **)(a1 + 35672);
    *(_DWORD *)(a1 + 72888) = *v6;
    *(_DWORD *)(a1 + 72872) = 2;
    goto LABEL_107;
  }
  v8 = a1 + 624;
  v63 = 1;
  while (1)
  {
    if (*(_DWORD *)(a1 + 596) == -1)
      return 4294967283;
    if ((*(_BYTE *)(a1 + 128) & 2) == 0)
    {
      v63 = 0;
      v9 = 0;
      v10 = 5;
LABEL_16:
      v12 = 1;
      goto LABEL_17;
    }
    v10 = *(_DWORD *)(*(_QWORD *)(a1 + 336) + 16);
    if (!v63)
    {
      v63 = 0;
      v9 = 0;
      goto LABEL_16;
    }
    v11 = *(_QWORD *)(a1 + 464);
    v12 = 0;
    v9 = v11 ? *(_DWORD *)(v11 + 40) : 0;
LABEL_17:
    v13 = *(_QWORD *)(a1 + 35640);
    v14 = *v3 - v13;
    if (v14 < 0)
      _libssh2_transport_read_cold_1();
    if (v14 < v10)
      break;
LABEL_23:
    v17 = v10;
    v18 = *(_QWORD *)(a1 + 35664);
    if (v18)
    {
      v19 = *(_QWORD *)(a1 + 35656);
    }
    else
    {
      if (v9)
        v20 = 4;
      else
        v20 = v10;
      if (v14 < v20)
        goto LABEL_94;
      v21 = (char *)(v8 + v13);
      if (!v9)
      {
        if ((v12 & 1) != 0)
        {
          __memcpy_chk();
        }
        else
        {
          v22 = decrypt(a1, v21, (char *)&v65, v10, 1u);
          if ((_DWORD)v22)
            return v22;
          *(_DWORD *)(a1 + 35624) = v65;
          *(_BYTE *)(a1 + 35628) = v66;
          v13 = *(_QWORD *)(a1 + 35640);
        }
        *(_QWORD *)(a1 + 35640) = v13 + v10;
        v21 = (char *)&v65;
      }
      v23 = _libssh2_ntohu32((unsigned int *)v21);
      *(_DWORD *)(a1 + 35648) = v23;
      if (!v23)
        return 4294967284;
      if (v23 > 0x9C40)
        return 4294967255;
      if (v9)
      {
        v24 = v23 + *(_DWORD *)(*(_QWORD *)(a1 + 352) + 8) + 4;
      }
      else
      {
        v25 = v66;
        *(_BYTE *)(a1 + 35652) = v66;
        if (v23 - 1 < v25)
          return 4294967284;
        if ((v12 & 1) != 0)
          v26 = 0;
        else
          v26 = *(_DWORD *)(*(_QWORD *)(a1 + 352) + 8);
        v24 = v26 + v23 - 1;
      }
      if (v24 - 40001 < 0xFFFF63C0)
        return 4294967255;
      v18 = v24;
      v27 = (_BYTE *)(*(uint64_t (**)(_QWORD, uint64_t))(a1 + 8))(v24, a1);
      *(_QWORD *)(a1 + 35672) = v27;
      if (!v27)
        return 4294967290;
      *(_QWORD *)(a1 + 35664) = v18;
      *(_QWORD *)(a1 + 35680) = v27;
      if (v9 || v10 < 6)
      {
        v29 = v27;
      }
      else
      {
        v28 = (v10 - 5);
        if (v28 > v18)
        {
          (*(void (**)(void))(a1 + 24))();
          return 4294967255;
        }
        memcpy(v27, v67, v28);
        v27 = *(_BYTE **)(a1 + 35672);
        v29 = (_BYTE *)(*(_QWORD *)(a1 + 35680) + v28);
        *(_QWORD *)(a1 + 35680) = v29;
        v18 = *(_QWORD *)(a1 + 35664);
      }
      v19 = v29 - v27;
      *(_QWORD *)(a1 + 35656) = v19;
      if (v9)
        v30 = 0;
      else
        v30 = v17;
      v14 -= v30;
    }
    if (v14 >= v18 - v19)
      v14 = v18 - v19;
    if (v9)
      v31 = 1;
    else
      v31 = v12;
    if ((v31 & 1) == 0)
    {
      v32 = *(_DWORD *)(*(_QWORD *)(a1 + 352) + 8);
      v33 = *(_QWORD *)(a1 + 336);
      if (v33 && (*(_BYTE *)(v33 + 32) & 1) != 0)
        v32 = 0;
      v34 = v18 - v32;
      if (v14 + v19 >= v34)
      {
        v39 = v34 - v19;
        v35 = v39 & ~(v39 >> 31);
        v38 = 2;
        if ((v39 & ~(v39 >> 31)) == 0)
          goto LABEL_80;
      }
      else
      {
        v35 = v14 / v17 * v17;
        if (v14 != v35)
          v14 = 0;
        if (v33)
        {
          v36 = *(_BYTE *)(v33 + 32);
          LODWORD(v37) = v18 - (v19 + v17) - v32;
          v37 = v35 >= (int)v37 ? (int)v37 : v35;
          if ((v36 & 1) != 0)
          {
            v14 = 0;
            v35 = v37;
          }
        }
        if (v35 < 0)
          _libssh2_transport_read_cold_2();
        v38 = 0;
        if (!v35)
          goto LABEL_80;
      }
      v40 = decrypt(a1, (char *)(v8 + *(_QWORD *)(a1 + 35640)), *(char **)(a1 + 35680), v35, v38);
      if ((_DWORD)v40)
      {
        v2 = v40;
        goto LABEL_120;
      }
      *(_QWORD *)(a1 + 35640) += v35;
      *(_QWORD *)(a1 + 35680) += v35;
      v18 = *(_QWORD *)(a1 + 35664);
      v19 = *(_QWORD *)(a1 + 35656) + v35;
      *(_QWORD *)(a1 + 35656) = v19;
      v14 -= v35;
    }
LABEL_80:
    if (v14 >= 1)
    {
      v42 = *(_QWORD *)(a1 + 35672);
      v41 = *(void **)(a1 + 35680);
      if (v14 <= (unint64_t)(v18 - (_QWORD)v41 + v42))
      {
        memcpy(v41, (const void *)(v8 + *(_QWORD *)(a1 + 35640)), v14);
        *(_QWORD *)(a1 + 35640) += v14;
        *(_QWORD *)(a1 + 35680) += v14;
        v18 = *(_QWORD *)(a1 + 35664);
        v19 = *(_QWORD *)(a1 + 35656) + v14;
        *(_QWORD *)(a1 + 35656) = v19;
        goto LABEL_83;
      }
      if (v42)
        (*(void (**)(_QWORD, uint64_t))(a1 + 24))(*(_QWORD *)(a1 + 35672), a1);
      return 4294967255;
    }
LABEL_83:
    if (v18 == v19)
      goto LABEL_5;
  }
  if (v14)
    memmove((void *)(a1 + 624), (const void *)(v8 + v13), *v3 - v13);
  *v3 = v14;
  *(_QWORD *)(a1 + 35640) = 0;
  v15 = (*(uint64_t (**)(_QWORD, uint64_t, int64_t, _QWORD, uint64_t))(a1 + 104))(*(unsigned int *)(a1 + 592), v8 + v14, 35000 - v14, (*(_DWORD *)(a1 + 132) == 0) << 19, a1);
  if (v15 > 0)
  {
    v13 = *(_QWORD *)(a1 + 35640);
    v16 = *v3 + v15;
    *v3 = v16;
    v14 = v16 - v13;
    goto LABEL_23;
  }
  if (v15 == -35)
  {
LABEL_94:
    *(_DWORD *)(a1 + 600) |= 1u;
    return 4294967259;
  }
  return 4294967253;
}

uint64_t decrypt(uint64_t a1, char *a2, char *a3, uint64_t a4, unsigned int a5)
{
  uint64_t v6;
  int64_t v10;
  uint64_t v11;
  uint64_t v12;
  int64_t v13;
  unsigned int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  int64_t v18;
  int v19;
  BOOL v20;
  int64_t v21;
  unsigned int v22;
  BOOL v23;

  v6 = a4;
  v10 = *(int *)(*(_QWORD *)(a1 + 336) + 16);
  v11 = *(_QWORD *)(a1 + 448);
  if ((!v11 || (*(_BYTE *)(v11 + 32) & 2) == 0) && a4 % v10)
    decrypt_cold_1();
  if (a4 < 1)
    return 0;
  v12 = 2 * (int)v10;
  while (1)
  {
    if (v6 >= v10)
      v13 = v10;
    else
      v13 = v6;
    if (v6 <= v10)
      v14 = a5;
    else
      v14 = 0;
    if ((a5 & 1) != 0)
      v15 = 1;
    else
      v15 = v14;
    v16 = *(_QWORD *)(a1 + 448);
    if (v16)
    {
      v17 = *(_QWORD *)(v16 + 32) & 2;
      if (v6 >= v12)
        v18 = v13;
      else
        v18 = v6;
      if (v6 >= v12)
        v19 = v15;
      else
        v19 = 2;
      v20 = v17 == 0;
      if (v17)
        v21 = v18;
      else
        v21 = v13;
      if (v20)
        v22 = v15;
      else
        v22 = v19;
      if ((a5 & 2) != 0)
      {
        v13 = v21;
        v15 = v22;
      }
      else
      {
        v15 = v15;
      }
    }
    if ((*(unsigned int (**)(uint64_t, char *, int64_t, uint64_t, uint64_t))(*(_QWORD *)(a1 + 336) + 48))(a1, a2, v13, a1 + 344, v15))
    {
      break;
    }
    memcpy(a3, a2, v13);
    a3 += v13;
    a2 += v13;
    v23 = v6 <= v13;
    v6 -= v13;
    if (v23)
      return 0;
  }
  (*(void (**)(_QWORD, uint64_t))(a1 + 24))(*(_QWORD *)(a1 + 35672), a1);
  return 4294967284;
}

uint64_t _libssh2_transport_send(uint64_t a1, void *__src, size_t __n, const void *a4, size_t a5)
{
  int v10;
  uint64_t result;
  _QWORD *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  _BOOL4 v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  int64_t v30;
  unint64_t v31;
  unint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  unint64_t v39;
  int v40;
  uint64_t v41;
  unint64_t v42;
  unsigned int v43;
  uint64_t v44;
  unint64_t v45;
  uint64_t v46;
  void *v47;
  int v48;
  uint64_t v49;
  uint64_t v50;

  if ((*(_DWORD *)(a1 + 128) & 2) != 0)
    v10 = *(_DWORD *)(*(_QWORD *)(a1 + 448) + 16);
  else
    v10 = 8;
  if ((*(_DWORD *)(a1 + 128) & 9) != 1 || (result = _libssh2_kex_exchange(a1, 1, a1 + 71088), !(_DWORD)result))
  {
    v12 = (_QWORD *)(a1 + 70688);
    if (*(_QWORD *)(a1 + 70704))
    {
      v13 = *(_QWORD *)(a1 + 70712);
      v14 = *v12 - v13;
      v15 = (*(uint64_t (**)(_QWORD, uint64_t, uint64_t, _QWORD, uint64_t))(a1 + 96))(*(unsigned int *)(a1 + 592), a1 + 35688 + v13, v14, (*(_DWORD *)(a1 + 132) == 0) << 19, a1);
      if (v15 == v14)
      {
        *v12 = 0;
        *(_QWORD *)(a1 + 70704) = 0;
LABEL_14:
        result = 0;
        *(_DWORD *)(a1 + 600) &= ~2u;
        return result;
      }
      if ((v15 & 0x8000000000000000) == 0)
      {
        *(_QWORD *)(a1 + 70712) += v15;
        if (v15 >= v14)
          goto LABEL_14;
        return 4294967259;
      }
      if (v15 == -35)
      {
        *(_DWORD *)(a1 + 600) |= 2u;
        return 4294967259;
      }
      return 4294967289;
    }
    *(_DWORD *)(a1 + 600) &= ~2u;
    v16 = *(_DWORD *)(a1 + 128);
    if ((v16 & 2) != 0 && (v17 = *(_QWORD *)(a1 + 464)) != 0)
      v18 = *(_DWORD *)(v17 + 40);
    else
      v18 = 0;
    v19 = *(_QWORD *)(a1 + 488);
    if (!v19 || !*(_DWORD *)(v19 + 8))
      goto LABEL_33;
    if ((v16 & 4) != 0)
    {
      v20 = 1;
      if ((v16 & 2) == 0)
        goto LABEL_33;
    }
    else
    {
      v20 = *(_DWORD *)(v19 + 12) != 0;
      if ((v16 & 2) == 0)
        goto LABEL_33;
    }
    if (v20 && *(_QWORD *)(a1 + 496))
    {
      v49 = 34739;
      v50 = 34739;
      result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t *, void *, size_t, uint64_t))(v19 + 24))(a1, a1 + 35693, &v50, __src, __n, a1 + 496);
      if ((_DWORD)result)
        return result;
      v21 = 0;
      if (a4 && a5)
      {
        v49 -= v50;
        result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t *, const void *, size_t, uint64_t))(*(_QWORD *)(a1 + 488) + 24))(a1, v50 + a1 + 35693, &v49, a4, a5, a1 + 496);
        if ((_DWORD)result)
          return result;
        v21 = v49;
      }
      v22 = v21 + v50;
LABEL_38:
      v23 = v22 + 5;
      v47 = __src;
      v48 = v18;
      if ((v16 & 2) == 0 || v18)
      {
        if (v18)
        {
          v25 = 4;
          goto LABEL_45;
        }
      }
      else
      {
        v24 = *(_QWORD *)(a1 + 336);
        if (v24)
        {
          v25 = 0;
          v26 = 0;
          v27 = 0;
          if ((*(_QWORD *)(v24 + 32) & 2) == 0)
          {
LABEL_47:
            v28 = 0;
            v29 = v10;
            v30 = (v27 + v23) / (unint64_t)v10 * v10 - (v27 + v23) + v10;
            if (v30 >= 4)
              v29 = 0;
            v31 = v29 + v30;
            v32 = v29 + v30 + v23;
            if ((v16 & 2) != 0)
              v28 = *(int *)(*(_QWORD *)(a1 + 464) + 8);
            v33 = a1 + 35688;
            _libssh2_htonu32((_DWORD *)(a1 + 35688), v32 - 4);
            *(_BYTE *)(a1 + 35692) = v31;
            if (_libssh2_openssl_random((unsigned __int8 *)(a1 + 35688 + v22 + 5), v31))
              return _libssh2_error(a1, 4294967247, "Unable to get random bytes for packet padding");
            v34 = v28 + v32;
            if ((v16 & 2) != 0)
            {
              if (!v48)
              {
                v35 = *(_QWORD *)(a1 + 336);
                if (!v35 || (*(_BYTE *)(v35 + 32) & 1) == 0)
                  (*(void (**)(uint64_t, unint64_t, _QWORD, uint64_t, unint64_t, _QWORD, _QWORD, uint64_t))(*(_QWORD *)(a1 + 464) + 24))(a1, v33 + v32, *(unsigned int *)(a1 + 472), a1 + 35688, v32, 0, 0, a1 + 480);
              }
              if (v26 < v32)
              {
                v36 = *(_QWORD *)(a1 + 448);
                LODWORD(v37) = *(_DWORD *)(v36 + 16);
                while (1)
                {
                  v38 = a1 + v26 + 35688;
                  v39 = v32 - v26;
                  if ((int)v37 >= (int)v32 - (int)v26)
                    v40 = v32 - v26;
                  else
                    v40 = v37;
                  v41 = *(_QWORD *)(v36 + 32);
                  v42 = v32 - (int)v37;
                  if (v26 == v42)
                    v43 = 2;
                  else
                    v43 = 0;
                  if ((v41 & 1) != 0)
                    v43 = 0;
                  if (v26)
                    v44 = v43;
                  else
                    v44 = 1;
                  if (v26 <= v32 - 2 * v40)
                  {
                    v42 = v26;
                    v39 = v40;
                  }
                  if ((v41 & 1) != 0)
                  {
                    v45 = v40;
                  }
                  else
                  {
                    v26 = v42;
                    v45 = v39;
                  }
                  if ((*(unsigned int (**)(uint64_t, uint64_t, unint64_t, uint64_t, uint64_t))(v36 + 48))(a1, v38, v45, a1 + 456, v44))
                  {
                    return 4294967252;
                  }
                  v36 = *(_QWORD *)(a1 + 448);
                  v37 = *(int *)(v36 + 16);
                  v26 += v37;
                  if (v26 >= v32)
                    goto LABEL_80;
                }
              }
              v36 = *(_QWORD *)(a1 + 448);
              if (v36)
              {
LABEL_80:
                if ((*(_BYTE *)(v36 + 32) & 1) != 0)
                {
                  if (v28 + v32 > v32 + *(int *)(v36 + 16))
                    _libssh2_transport_send_cold_1();
                  if ((*(unsigned int (**)(uint64_t, unint64_t, _QWORD, uint64_t, uint64_t))(v36 + 48))(a1, a1 + v32 + 35688, *(int *)(*(_QWORD *)(a1 + 464) + 8), a1 + 456, 2))
                  {
                    return 4294967252;
                  }
                }
              }
              v34 = v28 + v32;
              if (v48)
                (*(void (**)(uint64_t, unint64_t, _QWORD, uint64_t, unint64_t, _QWORD, _QWORD, uint64_t))(*(_QWORD *)(a1 + 464) + 24))(a1, v33 + v32, *(unsigned int *)(a1 + 472), a1 + 35688, v32, 0, 0, a1 + 480);
            }
            ++*(_DWORD *)(a1 + 472);
            v46 = (*(uint64_t (**)(_QWORD, uint64_t, uint64_t, _QWORD, uint64_t))(a1 + 96))(*(unsigned int *)(a1 + 592), a1 + 35688, v34, (*(_DWORD *)(a1 + 132) == 0) << 19, a1);
            if (v46 == v34)
            {
              result = 0;
              *(_OWORD *)(a1 + 70696) = 0u;
              return result;
            }
            if ((v46 & 0x8000000000000000) == 0 || v46 == -35)
            {
              *(_DWORD *)(a1 + 600) |= 2u;
              *(_QWORD *)(a1 + 70704) = __n;
              *(_QWORD *)(a1 + 70712) = v46 & ~(v46 >> 63);
              *v12 = v34;
              *(_QWORD *)(a1 + 70696) = v47;
              return 4294967259;
            }
            return 4294967289;
          }
LABEL_45:
          v27 = -4;
          v26 = v25;
          goto LABEL_47;
        }
      }
      v26 = 0;
      v27 = 0;
      goto LABEL_47;
    }
LABEL_33:
    v22 = a5 + __n;
    if (a5 + __n > 0x87B7)
      return 4294967262;
    memcpy((void *)(a1 + 35693), __src, __n);
    if (a4 && a5)
      memcpy((void *)(__n + a1 + 35693), a4, a5);
    goto LABEL_38;
  }
  return result;
}

void _libssh2_transport_read_cold_1()
{
  __assert_rtn("_libssh2_transport_read", "transport.c", 436, "remainbuf >= 0");
}

void _libssh2_transport_read_cold_2()
{
  __assert_rtn("_libssh2_transport_read", "transport.c", 678, "numdecrypt >= 0");
}

void decrypt_cold_1()
{
  __assert_rtn("decrypt", "transport.c", 140, "(len % blocksize) == 0");
}

void _libssh2_transport_send_cold_1()
{
  __assert_rtn("_libssh2_transport_send", "transport.c", 1071, "(size_t)total_length <= packet_length + session->local.crypt->blocksize");
}

int *CRYPTO_hchacha_20(int *result, int *a2, int *a3)
{
  int v3;
  int v4;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  int v15;
  int v16;
  unsigned int v17;
  int v18;
  int v19;
  int v20;
  int v21;
  unint64_t v22;
  int v23;
  int v24;
  int v25;
  int v26;
  int v27;
  int v28;
  int v29;
  int v30;
  int v31;
  int v32;
  int v33;
  int v34;
  int v35;
  int v36;
  int v37;
  int v38;
  int v39;
  int v40;
  int v41;
  int v42;
  int v43;
  int v44;
  int v45;
  int v46;
  int v47;
  int v48;
  int v49;
  int v50;
  int v51;
  int v52;
  int v53;
  int v54;
  int v55;
  int v56;
  int v57;
  int v58;
  int v59;
  int v60;
  int v61;
  int v62;
  int v63;
  int v64;
  int v65;
  int v66;
  int v67;
  int v68;
  int v69;
  int v70;
  int v71;
  int v72;

  v4 = *a2;
  v3 = a2[1];
  v5 = a2[2];
  v6 = a2[3];
  v7 = a2[4];
  v8 = a2[5];
  v9 = a2[6];
  v10 = a2[7];
  v12 = *a3;
  v11 = a3[1];
  v13 = 1797285236;
  v14 = 2036477234;
  v15 = 857760878;
  v16 = 1634760805;
  v17 = 22;
  v18 = a3[2];
  v19 = a3[3];
  do
  {
    v20 = v16 + v4;
    v21 = (v16 + v4) ^ v12;
    HIDWORD(v22) = v21;
    LODWORD(v22) = v21;
    v23 = (v22 >> 16) + v7;
    v24 = v23 ^ v4;
    HIDWORD(v22) = v24;
    LODWORD(v22) = v24;
    v25 = (v22 >> 20) + v20;
    LODWORD(v22) = v25 ^ __ROR4__(v21, 16);
    v26 = v22;
    HIDWORD(v22) = v22;
    v27 = (v22 >> 24) + v23;
    LODWORD(v22) = v27 ^ __ROR4__(v24, 20);
    v28 = v22;
    HIDWORD(v22) = v22;
    v29 = v22 >> 25;
    v30 = v15 + v3;
    v31 = v30 ^ v11;
    HIDWORD(v22) = v31;
    LODWORD(v22) = v31;
    v32 = (v22 >> 16) + v8;
    v33 = v32 ^ v3;
    HIDWORD(v22) = v33;
    LODWORD(v22) = v33;
    v34 = (v22 >> 20) + v30;
    LODWORD(v22) = v34 ^ __ROR4__(v31, 16);
    v35 = v22;
    HIDWORD(v22) = v22;
    v36 = (v22 >> 24) + v32;
    LODWORD(v22) = v36 ^ __ROR4__(v33, 20);
    v37 = v22;
    HIDWORD(v22) = v22;
    v38 = v22 >> 25;
    v39 = v14 + v5;
    v40 = v39 ^ v18;
    HIDWORD(v22) = v40;
    LODWORD(v22) = v40;
    v41 = (v22 >> 16) + v9;
    v42 = v41 ^ v5;
    HIDWORD(v22) = v42;
    LODWORD(v22) = v42;
    v43 = (v22 >> 20) + v39;
    LODWORD(v22) = v43 ^ __ROR4__(v40, 16);
    v44 = v22;
    HIDWORD(v22) = v22;
    v45 = (v22 >> 24) + v41;
    LODWORD(v22) = v45 ^ __ROR4__(v42, 20);
    v46 = v22;
    HIDWORD(v22) = v22;
    v47 = v22 >> 25;
    v48 = v13 + v6;
    v49 = v48 ^ v19;
    HIDWORD(v22) = v49;
    LODWORD(v22) = v49;
    v50 = (v22 >> 16) + v10;
    v51 = v50 ^ v6;
    HIDWORD(v22) = v51;
    LODWORD(v22) = v51;
    v52 = (v22 >> 20) + v48;
    LODWORD(v22) = v52 ^ __ROR4__(v49, 16);
    v53 = v22;
    HIDWORD(v22) = v22;
    v54 = (v22 >> 24) + v50;
    LODWORD(v22) = v54 ^ __ROR4__(v51, 20);
    v55 = v22;
    HIDWORD(v22) = v22;
    v56 = v22 >> 25;
    v57 = v38 + v25;
    LODWORD(v22) = v57 ^ __ROR4__(v53, 24);
    v58 = v22;
    HIDWORD(v22) = v22;
    v59 = (v22 >> 16) + v45;
    LODWORD(v22) = v59 ^ __ROR4__(v37, 25);
    v60 = v22;
    HIDWORD(v22) = v22;
    v16 = (v22 >> 20) + v57;
    LODWORD(v22) = v16 ^ __ROR4__(v58, 16);
    HIDWORD(v22) = v22;
    v19 = v22 >> 24;
    v9 = v19 + v59;
    LODWORD(v22) = v9 ^ __ROR4__(v60, 20);
    HIDWORD(v22) = v22;
    v3 = v22 >> 25;
    v61 = v47 + v34;
    LODWORD(v22) = v61 ^ __ROR4__(v26, 24);
    v62 = v22;
    HIDWORD(v22) = v22;
    v63 = (v22 >> 16) + v54;
    LODWORD(v22) = v63 ^ __ROR4__(v46, 25);
    v64 = v22;
    HIDWORD(v22) = v22;
    v15 = (v22 >> 20) + v61;
    LODWORD(v22) = v15 ^ __ROR4__(v62, 16);
    HIDWORD(v22) = v22;
    v12 = v22 >> 24;
    v10 = v12 + v63;
    LODWORD(v22) = v10 ^ __ROR4__(v64, 20);
    HIDWORD(v22) = v22;
    v5 = v22 >> 25;
    v65 = v56 + v43;
    LODWORD(v22) = v65 ^ __ROR4__(v35, 24);
    v66 = v22;
    HIDWORD(v22) = v22;
    v67 = (v22 >> 16) + v27;
    LODWORD(v22) = v67 ^ __ROR4__(v55, 25);
    v68 = v22;
    HIDWORD(v22) = v22;
    v14 = (v22 >> 20) + v65;
    LODWORD(v22) = v14 ^ __ROR4__(v66, 16);
    HIDWORD(v22) = v22;
    v11 = v22 >> 24;
    v7 = v11 + v67;
    LODWORD(v22) = v7 ^ __ROR4__(v68, 20);
    HIDWORD(v22) = v22;
    v6 = v22 >> 25;
    v69 = v29 + v52;
    LODWORD(v22) = v69 ^ __ROR4__(v44, 24);
    v70 = v22;
    HIDWORD(v22) = v22;
    v71 = (v22 >> 16) + v36;
    LODWORD(v22) = v71 ^ __ROR4__(v28, 25);
    v72 = v22;
    HIDWORD(v22) = v22;
    v13 = (v22 >> 20) + v69;
    LODWORD(v22) = v13 ^ __ROR4__(v70, 16);
    HIDWORD(v22) = v22;
    v18 = v22 >> 24;
    v8 = v18 + v71;
    v17 -= 2;
    LODWORD(v22) = v8 ^ __ROR4__(v72, 20);
    HIDWORD(v22) = v22;
    v4 = v22 >> 25;
  }
  while (v17 > 2);
  *result = v16;
  result[1] = v15;
  result[2] = v14;
  result[3] = v13;
  result[4] = v12;
  result[5] = v11;
  result[6] = v18;
  result[7] = v19;
  return result;
}

int8x8_t ChaCha_set_key(uint64_t a1, _DWORD *a2, int a3)
{
  _DWORD *v3;
  int8x8_t result;

  *(_DWORD *)(a1 + 16) = *a2;
  *(_DWORD *)(a1 + 20) = a2[1];
  *(_DWORD *)(a1 + 24) = a2[2];
  *(_DWORD *)(a1 + 28) = a2[3];
  v3 = &a2[4 * (a3 == 256)];
  *(_DWORD *)(a1 + 32) = *v3;
  *(_DWORD *)(a1 + 36) = v3[1];
  *(_DWORD *)(a1 + 40) = v3[2];
  *(_DWORD *)(a1 + 44) = v3[3];
  *(_DWORD *)a1 = 1634760805;
  result = vbsl_s8((int8x8_t)vcltz_s32(vshl_n_s32(vdup_n_s32(a3 == 256), 0x1FuLL)), (int8x8_t)0x79622D323320646ELL, (int8x8_t)0x79622D363120646ELL);
  *(int8x8_t *)(a1 + 4) = result;
  *(_DWORD *)(a1 + 12) = 1797285236;
  *(_BYTE *)(a1 + 128) = 0;
  return result;
}

uint64_t ChaCha_set_iv(uint64_t result, _DWORD *a2, _DWORD *a3)
{
  int v3;

  if (a3)
  {
    *(_DWORD *)(result + 48) = *a3;
    v3 = a3[1];
  }
  else
  {
    v3 = 0;
    *(_DWORD *)(result + 48) = 0;
  }
  *(_DWORD *)(result + 52) = v3;
  *(_DWORD *)(result + 56) = *a2;
  *(_DWORD *)(result + 60) = a2[1];
  *(_BYTE *)(result + 128) = 0;
  return result;
}

int *ChaCha(int *result, int *a2, char *a3, unint64_t a4)
{
  unint64_t v4;
  int *v7;
  _BYTE *v8;
  unint64_t v9;
  unint64_t v10;
  char *v11;
  int v12;
  char v13;
  char v14;
  char v15;
  unint64_t v16;

  v4 = a4;
  v7 = result;
  v8 = result + 32;
  v9 = *((unsigned __int8 *)result + 128);
  if (*((_BYTE *)result + 128))
  {
    if (v9 >= a4)
      v10 = a4;
    else
      v10 = *((unsigned __int8 *)result + 128);
    if ((_DWORD)v10)
    {
      v11 = &v8[-v9];
      v12 = v10;
      do
      {
        v14 = *a3++;
        v13 = v14;
        v15 = *v11++;
        *(_BYTE *)a2 = v15 ^ v13;
        a2 = (int *)((char *)a2 + 1);
        --v12;
      }
      while (v12);
      LOBYTE(v9) = *v8;
    }
    *v8 = v9 - v10;
    v4 = a4 - v10;
  }
  for (; v4; v4 -= v16)
  {
    if (v4 >= 0xFFFFFFFF)
      v16 = 0xFFFFFFFFLL;
    else
      v16 = v4;
    result = chacha_encrypt_bytes(v7, a3, a2, v16);
    a3 += v16;
    a2 = (int *)((char *)a2 + v16);
  }
  return result;
}

int *chacha_encrypt_bytes(int *result, _DWORD *a2, int *a3, unint64_t a4)
{
  int v4;
  int v5;
  int v6;
  uint64_t v7;
  int *v8;
  int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  int v18;
  int v19;
  int v20;
  int v21;
  int v22;
  int v23;
  int v24;
  int v25;
  int v26;
  int v27;
  unint64_t v28;
  int v29;
  int v30;
  int v31;
  int v32;
  int v33;
  int v34;
  int v35;
  int v36;
  int v37;
  int v38;
  int v39;
  int v40;
  int v41;
  int v42;
  int v43;
  int v44;
  int v45;
  int v46;
  int v47;
  int v48;
  int v49;
  int v50;
  int v51;
  int v52;
  int v53;
  int v54;
  int v55;
  int v56;
  int v57;
  int v58;
  int v59;
  int v60;
  int v61;
  int v62;
  int v63;
  int v64;
  int v65;
  int v66;
  int v67;
  int v68;
  int v69;
  int v70;
  int v71;
  int v72;
  int v73;
  int v74;
  int v75;
  int v76;
  int v77;
  int v78;
  int v79;
  int v80;
  int v81;
  int v82;
  int v83;
  int v84;
  int v85;
  int v86;
  int v87;
  int v88;
  int v89;
  int v90;
  int v91;
  int v92;
  int v93;
  int v94;
  int v95;
  int v96;
  int v97;
  int v98;
  int v99;
  int v100;
  int v101;
  int v102;
  int v103;
  int v104;
  int v105;
  int v106;
  int v107;
  int v108;
  int v109;
  unint64_t v110;
  int *v111;
  int v112;
  int v113;
  int v114;
  int v115;
  int v116;
  int v117;
  int v118;
  int v119;
  int v120;
  int v121;
  int v122;
  int v123;
  int v124;
  int v125;
  int v126;
  _BYTE v127[64];
  uint64_t v128;

  v128 = *MEMORY[0x24BDAC8D0];
  if ((_DWORD)a4)
  {
    v111 = 0;
    v4 = *result;
    v124 = result[2];
    v125 = result[1];
    v122 = result[4];
    v123 = result[3];
    v120 = result[6];
    v121 = result[5];
    v118 = result[8];
    v119 = result[7];
    v116 = result[10];
    v117 = result[9];
    v5 = result[12];
    v6 = result[13];
    a4 = a4;
    v114 = result[14];
    v115 = result[11];
    v112 = *result;
    v113 = result[15];
    while (1)
    {
      if (a4 > 0x3F)
      {
        v8 = a3;
      }
      else
      {
        v7 = 0;
        do
        {
          v8 = (int *)v127;
          v127[v7] = *((_BYTE *)a2 + v7);
          ++v7;
        }
        while (a4 != v7);
        a2 = v127;
        v111 = a3;
      }
      v9 = -20;
      v11 = v113;
      v10 = v114;
      v12 = v6;
      v126 = v5;
      v13 = v5;
      v15 = v115;
      v14 = v116;
      v17 = v117;
      v16 = v118;
      v19 = v119;
      v18 = v120;
      v20 = v121;
      v21 = v122;
      v23 = v123;
      v22 = v124;
      v24 = v125;
      v25 = v4;
      do
      {
        v26 = v21 + v25;
        v27 = v13 ^ v26;
        HIDWORD(v28) = v27;
        LODWORD(v28) = v27;
        v29 = (v28 >> 16) + v16;
        HIDWORD(v28) = v29 ^ v21;
        LODWORD(v28) = v29 ^ v21;
        v30 = (v28 >> 20) + v26;
        LODWORD(v28) = v30 ^ __ROR4__(v27, 16);
        v31 = v28;
        HIDWORD(v28) = v28;
        v32 = (v28 >> 24) + v29;
        LODWORD(v28) = v32 ^ __ROR4__(v29 ^ v21, 20);
        v33 = v28;
        HIDWORD(v28) = v28;
        v34 = v28 >> 25;
        v35 = v20 + v24;
        v36 = v12 ^ v35;
        HIDWORD(v28) = v36;
        LODWORD(v28) = v36;
        v37 = (v28 >> 16) + v17;
        v38 = v37 ^ v20;
        HIDWORD(v28) = v38;
        LODWORD(v28) = v38;
        v39 = (v28 >> 20) + v35;
        LODWORD(v28) = v39 ^ __ROR4__(v36, 16);
        v40 = v28;
        HIDWORD(v28) = v28;
        v41 = (v28 >> 24) + v37;
        LODWORD(v28) = v41 ^ __ROR4__(v38, 20);
        v42 = v28;
        HIDWORD(v28) = v28;
        v43 = v28 >> 25;
        v44 = v18 + v22;
        v45 = v10 ^ v44;
        HIDWORD(v28) = v45;
        LODWORD(v28) = v45;
        v46 = (v28 >> 16) + v14;
        v47 = v46 ^ v18;
        HIDWORD(v28) = v47;
        LODWORD(v28) = v47;
        v48 = (v28 >> 20) + v44;
        LODWORD(v28) = v48 ^ __ROR4__(v45, 16);
        v49 = v28;
        HIDWORD(v28) = v28;
        v50 = (v28 >> 24) + v46;
        LODWORD(v28) = v50 ^ __ROR4__(v47, 20);
        v51 = v28;
        HIDWORD(v28) = v28;
        v52 = v28 >> 25;
        v53 = v19 + v23;
        v54 = v11 ^ v53;
        HIDWORD(v28) = v54;
        LODWORD(v28) = v54;
        v55 = (v28 >> 16) + v15;
        v56 = v55 ^ v19;
        HIDWORD(v28) = v55 ^ v19;
        LODWORD(v28) = v55 ^ v19;
        v57 = (v28 >> 20) + v53;
        LODWORD(v28) = v57 ^ __ROR4__(v54, 16);
        v58 = v28;
        HIDWORD(v28) = v28;
        v59 = (v28 >> 24) + v55;
        LODWORD(v28) = v59 ^ __ROR4__(v56, 20);
        v60 = v28;
        HIDWORD(v28) = v28;
        v61 = v28 >> 25;
        v62 = v43 + v30;
        LODWORD(v28) = v62 ^ __ROR4__(v58, 24);
        v63 = v28;
        HIDWORD(v28) = v28;
        v64 = (v28 >> 16) + v50;
        LODWORD(v28) = v64 ^ __ROR4__(v42, 25);
        v65 = v28;
        HIDWORD(v28) = v28;
        v25 = (v28 >> 20) + v62;
        LODWORD(v28) = v25 ^ __ROR4__(v63, 16);
        HIDWORD(v28) = v28;
        v11 = v28 >> 24;
        v14 = v11 + v64;
        LODWORD(v28) = (v11 + v64) ^ __ROR4__(v65, 20);
        HIDWORD(v28) = v28;
        v20 = v28 >> 25;
        v66 = v52 + v39;
        LODWORD(v28) = v66 ^ __ROR4__(v31, 24);
        v67 = v28;
        HIDWORD(v28) = v28;
        v68 = (v28 >> 16) + v59;
        LODWORD(v28) = v68 ^ __ROR4__(v51, 25);
        v69 = v28;
        HIDWORD(v28) = v28;
        v24 = (v28 >> 20) + v66;
        LODWORD(v28) = v24 ^ __ROR4__(v67, 16);
        HIDWORD(v28) = v28;
        v13 = v28 >> 24;
        v15 = v13 + v68;
        LODWORD(v28) = (v13 + v68) ^ __ROR4__(v69, 20);
        HIDWORD(v28) = v28;
        v18 = v28 >> 25;
        v70 = v61 + v48;
        LODWORD(v28) = v70 ^ __ROR4__(v40, 24);
        v71 = v28;
        HIDWORD(v28) = v28;
        v72 = (v28 >> 16) + v32;
        LODWORD(v28) = v72 ^ __ROR4__(v60, 25);
        v73 = v28;
        HIDWORD(v28) = v28;
        v22 = (v28 >> 20) + v70;
        LODWORD(v28) = v22 ^ __ROR4__(v71, 16);
        HIDWORD(v28) = v28;
        v12 = v28 >> 24;
        v16 = v12 + v72;
        LODWORD(v28) = (v12 + v72) ^ __ROR4__(v73, 20);
        HIDWORD(v28) = v28;
        v19 = v28 >> 25;
        v74 = v34 + v57;
        LODWORD(v28) = v74 ^ __ROR4__(v49, 24);
        v75 = v28;
        HIDWORD(v28) = v28;
        v76 = (v28 >> 16) + v41;
        LODWORD(v28) = v76 ^ __ROR4__(v33, 25);
        v77 = v28;
        HIDWORD(v28) = v28;
        v23 = (v28 >> 20) + v74;
        LODWORD(v28) = v23 ^ __ROR4__(v75, 16);
        HIDWORD(v28) = v28;
        v10 = v28 >> 24;
        v17 = v10 + v76;
        LODWORD(v28) = (v10 + v76) ^ __ROR4__(v77, 20);
        HIDWORD(v28) = v28;
        v21 = v28 >> 25;
        v9 += 2;
      }
      while (v9);
      v78 = v25 + v4;
      v79 = v24 + v125;
      v80 = v22 + v124;
      v81 = v23 + v123;
      v82 = v21 + v122;
      v83 = v20 + v121;
      v84 = v18 + v120;
      v85 = v19 + v119;
      v86 = v16 + v118;
      v87 = v17 + v117;
      v88 = v14 + v116;
      v89 = v15 + v115;
      v90 = v13 + v126;
      v91 = v12 + v6;
      v92 = v10 + v114;
      v93 = v11 + v113;
      if (a4 <= 0x3F)
      {
        result[16] = v78;
        result[17] = v79;
        result[18] = v80;
        result[19] = v81;
        result[20] = v82;
        result[21] = v83;
        result[22] = v84;
        result[23] = v85;
        result[24] = v86;
        result[25] = v87;
        result[26] = v88;
        result[27] = v89;
        result[28] = v90;
        result[29] = v91;
        result[30] = v92;
        result[31] = v93;
      }
      v94 = *a2 ^ v78;
      v95 = a2[1] ^ v79;
      v96 = a2[2] ^ v80;
      v97 = a2[3] ^ v81;
      v98 = a2[4] ^ v82;
      v99 = a2[5] ^ v83;
      v100 = a2[6] ^ v84;
      v101 = a2[7] ^ v85;
      v102 = a2[8] ^ v86;
      v103 = a2[9] ^ v87;
      v104 = a2[10] ^ v88;
      v105 = a2[11] ^ v89;
      v106 = a2[12] ^ v90;
      v107 = a2[13] ^ v91;
      v108 = a2[14] ^ v92;
      v109 = a2[15] ^ v93;
      v5 = v126 + 1;
      if (v126 == -1)
        ++v6;
      *v8 = v94;
      v8[1] = v95;
      v8[2] = v96;
      v8[3] = v97;
      v8[4] = v98;
      v8[5] = v99;
      v8[6] = v100;
      v8[7] = v101;
      v8[8] = v102;
      v8[9] = v103;
      v8[10] = v104;
      v8[11] = v105;
      v8[12] = v106;
      v8[13] = v107;
      v8[14] = v108;
      v8[15] = v109;
      if (a4 <= 0x40)
        break;
      a3 = v8 + 16;
      a2 += 16;
      a4 -= 64;
      v4 = v112;
    }
    if ((a4 - 1) <= 0x3E)
    {
      v110 = 0;
      do
      {
        *((_BYTE *)v111 + v110) = *((_BYTE *)v8 + v110);
        ++v110;
      }
      while (v110 < a4);
    }
    result[12] = v5;
    result[13] = v6;
    *((_BYTE *)result + 128) = 64 - a4;
  }
  return result;
}

int *CRYPTO_chacha_20(int *result, _DWORD *a2, unint64_t a3, _OWORD *a4, uint64_t *a5, uint64_t a6)
{
  unint64_t v6;
  int *v8;
  __int128 v9;
  unint64_t v10;
  _OWORD v11[3];
  uint64_t v12;
  uint64_t v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  int v18;
  uint64_t v19;

  v6 = a3;
  v8 = result;
  v19 = *MEMORY[0x24BDAC8D0];
  v9 = a4[1];
  v11[1] = *a4;
  v11[2] = v9;
  v11[0] = xmmword_22D68ED80;
  v12 = 0;
  v13 = *a5;
  if (a6)
    v12 = a6;
  if (a3)
  {
    v18 = 0;
    v16 = 0u;
    v17 = 0u;
    v14 = 0u;
    v15 = 0u;
    do
    {
      if (v6 >= 0xFFFFFFFF)
        v10 = 0xFFFFFFFFLL;
      else
        v10 = v6;
      result = chacha_encrypt_bytes((int *)v11, a2, v8, v10);
      a2 = (_DWORD *)((char *)a2 + v10);
      v8 = (int *)((char *)v8 + v10);
      v6 -= v10;
    }
    while (v6);
  }
  return result;
}

int *CRYPTO_xchacha_20(int *a1, _DWORD *a2, unint64_t a3, int *a4, uint64_t a5)
{
  int v10[8];
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  CRYPTO_hchacha_20(v10, a4, (int *)a5);
  return CRYPTO_chacha_20(a1, a2, a3, v10, (uint64_t *)(a5 + 16), 0);
}

int UTF8_getc(const unsigned __int8 *str, int len, unint64_t *val)
{
  unsigned __int8 v4;
  unint64_t v5;
  int result;
  unsigned int v7;
  unsigned __int8 v8;
  unsigned __int8 v9;
  unint64_t v10;
  unsigned __int8 v11;
  unsigned __int8 v12;
  unsigned __int8 v13;
  unsigned __int8 v14;

  if (len < 1)
    return 0;
  v4 = *str;
  if ((*(char *)str & 0x80000000) == 0)
  {
    v5 = v4 & 0x7F;
    result = 1;
LABEL_4:
    *val = v5;
    return result;
  }
  v7 = *str;
  if ((v7 & 0xE0) == 0xC0)
  {
    if (v7 < 0xC2)
      return -2;
    if (len >= 2)
    {
      v11 = str[1];
      if ((v11 & 0xC0) == 0x80)
      {
        v5 = v11 & 0x3F | ((v7 & 0x1F) << 6);
        if (v5 >= 0x80)
        {
          result = 2;
          goto LABEL_4;
        }
        return -4;
      }
      return -3;
    }
    return -1;
  }
  if ((v7 & 0xF0) == 0xE0)
  {
    if (len < 3)
      return -1;
    v8 = str[1];
    if ((v8 & 0xC0) == 0x80)
    {
      v9 = str[2];
      if ((v9 & 0xC0) == 0x80)
      {
        v10 = ((unint64_t)(v4 & 0xF) << 12) | ((unint64_t)(v8 & 0x3F) << 6);
        v5 = v10 & 0xFFFFFFFFFFFFFFC0 | v9 & 0x3F;
        if (v5 >= 0x800)
        {
          if ((v10 & 0xF800) != 0xD800)
          {
            result = 3;
            goto LABEL_4;
          }
          return -2;
        }
        return -4;
      }
    }
    return -3;
  }
  result = -2;
  if (v7 <= 0xF4 && (v7 & 0xF8) == 0xF0)
  {
    if (len < 4)
      return -1;
    v12 = str[1];
    if ((v12 & 0xC0) != 0x80)
      return -3;
    v13 = str[2];
    if ((v13 & 0xC0) != 0x80)
      return -3;
    v14 = str[3];
    if ((v14 & 0xC0) != 0x80)
      return -3;
    v5 = ((unint64_t)(v4 & 7) << 18) | ((unint64_t)(v12 & 0x3F) << 12) | ((unint64_t)(v13 & 0x3F) << 6) | v14 & 0x3F;
    if (v5 < 0x10000)
      return -4;
    if (v5 >> 16 <= 0x10)
    {
      result = 4;
      goto LABEL_4;
    }
  }
  return result;
}

int UTF8_putc(unsigned __int8 *str, int len, unint64_t value)
{
  if (value <= 0x7F)
  {
    if (!str)
      return 1;
    if (len >= 1)
    {
      *str = value;
      return 1;
    }
    return -1;
  }
  if (value <= 0x7FF)
  {
    if (!str)
      return 2;
    if (len >= 2)
    {
      *str = (value >> 6) | 0xC0;
      str[1] = value & 0x3F | 0x80;
      return 2;
    }
    return -1;
  }
  if (!(value >> 16))
  {
    if (value >> 11 != 27)
    {
      if (str)
      {
        if (len < 3)
          return -1;
        *str = (value >> 12) | 0xE0;
        str[1] = (value >> 6) & 0x3F | 0x80;
        str[2] = value & 0x3F | 0x80;
      }
      return 3;
    }
    return -2;
  }
  if (value >> 16 > 0x10)
    return -2;
  if (str)
  {
    if (len < 4)
      return -1;
    *str = (value >> 18) | 0xF0;
    str[1] = (value >> 12) & 0x3F | 0x80;
    str[2] = (value >> 6) & 0x3F | 0x80;
    str[3] = value & 0x3F | 0x80;
  }
  return 4;
}

uint64_t EVP_PKEY_asn1_get_count()
{
  if (asn1_app_methods)
    return (sk_num((const STACK *)asn1_app_methods) + 18);
  else
    return 18;
}

char *EVP_PKEY_asn1_get0(unsigned int a1)
{
  if ((a1 & 0x80000000) != 0)
    return 0;
  if (a1 > 0x11)
    return sk_value((const STACK *)asn1_app_methods, a1 - 18);
  return (char *)*(&asn1_methods + a1);
}

uint64_t EVP_PKEY_asn1_find(uint64_t *a1, int a2)
{
  unint64_t v4;
  char *v5;
  uint64_t pkey_asn1_meth_engine;

LABEL_1:
  if (asn1_app_methods)
    v4 = (sk_num((const STACK *)asn1_app_methods) + 18);
  else
    v4 = 18;
  while ((int)v4 >= 1)
  {
    if (v4 > 0x12)
      v5 = sk_value((const STACK *)asn1_app_methods, (int)v4 - 19);
    else
      v5 = (char *)*(&asn1_methods + v4 - 1);
    --v4;
    if (*(_DWORD *)v5 == a2)
    {
      if ((v5[8] & 1) == 0)
        goto LABEL_12;
      a2 = *((_DWORD *)v5 + 1);
      goto LABEL_1;
    }
  }
  v5 = 0;
LABEL_12:
  if (a1)
  {
    pkey_asn1_meth_engine = ENGINE_get_pkey_asn1_meth_engine(a2);
    if (pkey_asn1_meth_engine)
    {
      *a1 = pkey_asn1_meth_engine;
      return ENGINE_get_pkey_asn1_meth(pkey_asn1_meth_engine);
    }
    *a1 = 0;
  }
  return (uint64_t)v5;
}

char *EVP_PKEY_asn1_find_str(ENGINE **a1, char *__s, signed int a3)
{
  signed int v3;
  uint64_t str;
  char *v7;
  int v8;
  unint64_t v9;
  unint64_t v10;
  ENGINE *e;

  v3 = a3;
  if (a3 == -1)
  {
    v3 = strlen(__s);
    if (!a1)
      goto LABEL_10;
  }
  else if (!a1)
  {
    goto LABEL_10;
  }
  e = 0;
  str = ENGINE_pkey_asn1_find_str(&e, (uint64_t)__s, v3);
  if (str)
  {
    v7 = (char *)str;
    if (!ENGINE_init(e))
      v7 = 0;
    ENGINE_free(e);
    *a1 = e;
    return v7;
  }
  *a1 = 0;
LABEL_10:
  if (asn1_app_methods)
  {
    v8 = sk_num((const STACK *)asn1_app_methods);
    if (v8 < -17)
      return 0;
    LODWORD(v9) = v8 + 18;
  }
  else
  {
    LODWORD(v9) = 18;
  }
  v9 = v9;
  while (1)
  {
    v10 = v9 - 1;
    v7 = v9 > 0x12
       ? sk_value((const STACK *)asn1_app_methods, (int)v9 - 19)
       : (char *)*(&asn1_methods + v10);
    if ((v7[8] & 1) == 0
      && v3 == strlen(*((const char **)v7 + 2))
      && !strncasecmp(*((const char **)v7 + 2), __s, v3))
    {
      break;
    }
    v9 = v10;
    if (v10 + 1 <= 1)
      return 0;
  }
  return v7;
}

STACK *EVP_PKEY_asn1_add0(char *data)
{
  STACK *result;

  result = (STACK *)asn1_app_methods;
  if (asn1_app_methods)
    return (STACK *)(sk_push(result, data) != 0);
  result = sk_new(0);
  asn1_app_methods = (uint64_t)result;
  if (result)
    return (STACK *)(sk_push(result, data) != 0);
  return result;
}

uint64_t EVP_PKEY_asn1_add_alias(int a1, int a2)
{
  uint64_t result;
  uint64_t v5;

  result = (uint64_t)malloc_type_calloc(1uLL, 0x110uLL, 0x1090040E55D908EuLL);
  if (result)
  {
    v5 = result;
    *(_QWORD *)(result + 8) = 3;
    *(_DWORD *)result = a2;
    *(_DWORD *)(result + 4) = a1;
    if (EVP_PKEY_asn1_add0((char *)result))
    {
      return 1;
    }
    else
    {
      EVP_PKEY_asn1_free(v5);
      return 0;
    }
  }
  return result;
}

uint64_t EVP_PKEY_asn1_new(int a1, int a2, const char *a3, const char *a4)
{
  _DWORD *v8;
  uint64_t v9;
  char *v10;
  char *v11;

  v8 = malloc_type_calloc(1uLL, 0x110uLL, 0x1090040E55D908EuLL);
  v9 = (uint64_t)v8;
  if (v8)
  {
    if ((*v8 = a1, v8[1] = a1, *((_QWORD *)v8 + 1) = a2 | 2, a4)
      && (v10 = strdup(a4), (*(_QWORD *)(v9 + 24) = v10) == 0)
      || a3 && (v11 = strdup(a3), (*(_QWORD *)(v9 + 16) = v11) == 0))
    {
      EVP_PKEY_asn1_free(v9);
      return 0;
    }
  }
  return v9;
}

void EVP_PKEY_asn1_free(uint64_t a1)
{
  if (a1)
  {
    if ((*(_BYTE *)(a1 + 8) & 2) != 0)
    {
      free(*(void **)(a1 + 16));
      free(*(void **)(a1 + 24));
      free((void *)a1);
    }
  }
}

uint64_t EVP_PKEY_asn1_get0_info(_DWORD *a1, _DWORD *a2, _DWORD *a3, _QWORD *a4, _QWORD *a5, uint64_t a6)
{
  if (!a6)
    return 0;
  if (a1)
    *a1 = *(_DWORD *)a6;
  if (a2)
    *a2 = *(_DWORD *)(a6 + 4);
  if (a3)
    *a3 = *(_QWORD *)(a6 + 8);
  if (a4)
    *a4 = *(_QWORD *)(a6 + 24);
  if (a5)
    *a5 = *(_QWORD *)(a6 + 16);
  return 1;
}

uint64_t EVP_PKEY_get0_asn1(uint64_t a1)
{
  return *(_QWORD *)(a1 + 16);
}

__n128 EVP_PKEY_asn1_copy(__n128 *a1, const void *a2)
{
  unint64_t v3;
  unint64_t v4;
  __n128 result;
  __n128 v6;

  v3 = a1->n128_u64[1];
  v6 = a1[1];
  v4 = a1->n128_u64[0];
  memcpy(a1, a2, 0x110uLL);
  a1->n128_u64[0] = v4;
  a1->n128_u64[1] = v3;
  result = v6;
  a1[1] = v6;
  return result;
}

_QWORD *EVP_PKEY_asn1_set_public(_QWORD *result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  result[4] = a2;
  result[5] = a3;
  result[6] = a4;
  result[7] = a5;
  result[11] = a6;
  result[12] = a7;
  return result;
}

_QWORD *EVP_PKEY_asn1_set_private(_QWORD *result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  result[8] = a2;
  result[9] = a3;
  result[10] = a4;
  return result;
}

_QWORD *EVP_PKEY_asn1_set_param(_QWORD *result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  result[14] = a2;
  result[15] = a3;
  result[16] = a4;
  result[17] = a5;
  result[18] = a6;
  result[19] = a7;
  return result;
}

uint64_t EVP_PKEY_asn1_set_free(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 168) = a2;
  return result;
}

uint64_t EVP_PKEY_asn1_set_ctrl(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 176) = a2;
  return result;
}

uint64_t EVP_PKEY_asn1_set_security_bits(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 104) = a2;
  return result;
}

uint64_t EVP_PKEY_asn1_set_check(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 216) = a2;
  return result;
}

uint64_t EVP_PKEY_asn1_set_public_check(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 224) = a2;
  return result;
}

uint64_t EVP_PKEY_asn1_set_param_check(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 232) = a2;
  return result;
}

int RSA_generate_key_ex(RSA *rsa, int bits, BIGNUM *e, BN_GENCB *cb)
{
  int (__cdecl *rsa_keygen)(RSA *, int, BIGNUM *, BN_GENCB *);
  BN_CTX *v10;
  BN_CTX *v11;
  BIGNUM *v12;
  __n128 *v13;
  BIGNUM *v14;
  BIGNUM *v15;
  BIGNUM *v16;
  BIGNUM *v17;
  int v18;
  BIGNUM *v19;
  BIGNUM *v20;
  BIGNUM *v21;
  BIGNUM *v22;
  BIGNUM *v23;
  BIGNUM *v24;
  BIGNUM *v25;
  BIGNUM *v26;
  int v27;
  int v28;
  int v29;
  BIGNUM *p;
  const BIGNUM *v31;
  int v33;
  BIGNUM *q;
  const BIGNUM *v35;
  int v37;
  int v38;
  int v39;
  BIGNUM *v40;
  BIGNUM *v41;
  BIGNUM *v42;
  BIGNUM *v43;
  const BIGNUM *v44;
  BIGNUM *v45;
  const BIGNUM *v46;
  int v47;
  BIGNUM v48;
  BIGNUM v49;
  BIGNUM v50;

  rsa_keygen = rsa->meth->rsa_keygen;
  if (rsa_keygen)
    return ((uint64_t (*)(RSA *, _QWORD, BIGNUM *, BN_GENCB *))rsa_keygen)(rsa, *(_QWORD *)&bits, e, cb);
  memset(&v50, 0, sizeof(v50));
  memset(&v49, 0, sizeof(v49));
  memset(&v48, 0, sizeof(v48));
  v10 = BN_CTX_new();
  v11 = v10;
  if (v10)
  {
    BN_CTX_start(v10);
    v12 = BN_CTX_get(v11);
    if (v12)
    {
      v13 = (__n128 *)v12;
      v14 = BN_CTX_get(v11);
      if (v14)
      {
        v15 = v14;
        v16 = BN_CTX_get(v11);
        if (v16)
        {
          v17 = v16;
          if (BN_CTX_get(v11))
          {
            v18 = bits >= -1 ? bits + 1 : bits + 2;
            if (rsa->n || (v19 = BN_new(), (rsa->n = v19) != 0))
            {
              if (rsa->d || (v20 = BN_new(), (rsa->d = v20) != 0))
              {
                if (rsa->e || (v21 = BN_new(), (rsa->e = v21) != 0))
                {
                  if (rsa->p || (v22 = BN_new(), (rsa->p = v22) != 0))
                  {
                    if (rsa->q || (v23 = BN_new(), (rsa->q = v23) != 0))
                    {
                      if (rsa->dmp1 || (v24 = BN_new(), (rsa->dmp1 = v24) != 0))
                      {
                        if (rsa->dmq1 || (v25 = BN_new(), (rsa->dmq1 = v25) != 0))
                        {
                          if (rsa->iqmp || (v26 = BN_new(), (rsa->iqmp = v26) != 0))
                          {
                            if (bn_copy(rsa->e, e))
                            {
                              v27 = 0;
                              v28 = v18 >> 1;
                              v29 = bits - (v18 >> 1);
                              do
                              {
                                if (!BN_generate_prime_ex(rsa->p, v28, 0, 0, 0, cb))
                                  break;
                                p = rsa->p;
                                v31 = BN_value_one();
                                if (!BN_sub(v17, p, v31) || !BN_gcd_ct((unint64_t)v15, v17, rsa->e, v11))
                                  break;
                                if (BN_is_one((uint64_t)v15))
                                {
                                  if (BN_GENCB_call(cb, 3, 0))
                                  {
LABEL_36:
                                    v33 = 3;
                                    while (BN_generate_prime_ex(rsa->q, v29, 0, 0, 0, cb))
                                    {
                                      if (BN_cmp(rsa->p, rsa->q))
                                      {
                                        q = rsa->q;
                                        v35 = BN_value_one();
                                        if (BN_sub(v17, q, v35) && BN_gcd_ct((unint64_t)v15, v17, rsa->e, v11))
                                        {
                                          if (BN_is_one((uint64_t)v15))
                                          {
                                            if (BN_GENCB_call(cb, 3, 1))
                                            {
                                              v39 = BN_cmp(rsa->p, rsa->q);
                                              v41 = rsa->p;
                                              v40 = rsa->q;
                                              if (v39 < 0)
                                              {
                                                rsa->p = v40;
                                                rsa->q = v41;
                                                v42 = v41;
                                              }
                                              else
                                              {
                                                v42 = rsa->q;
                                                v40 = rsa->p;
                                              }
                                              if (BN_mul(rsa->n, v40, v42, v11))
                                              {
                                                v43 = rsa->p;
                                                v44 = BN_value_one();
                                                if (BN_sub(v15, v43, v44))
                                                {
                                                  v45 = rsa->q;
                                                  v46 = BN_value_one();
                                                  if (BN_sub(v17, v45, v46))
                                                  {
                                                    if (BN_mul((BIGNUM *)v13, v15, v17, v11))
                                                    {
                                                      BN_init(&v50);
                                                      BN_with_flags((__n128 *)&v50, v13, 4);
                                                      if (BN_mod_inverse_ct(rsa->d, rsa->e, &v50, v11))
                                                      {
                                                        BN_init(&v49);
                                                        BN_with_flags((__n128 *)&v49, (__n128 *)rsa->d, 4);
                                                        if (BN_mod_ct(rsa->dmp1, &v49, v15, v11))
                                                        {
                                                          if (BN_mod_ct(rsa->dmq1, &v49, v17, v11))
                                                          {
                                                            BN_init(&v48);
                                                            BN_with_flags((__n128 *)&v48, (__n128 *)rsa->p, 4);
                                                            if (BN_mod_inverse_ct(rsa->iqmp, rsa->q, &v48, v11))
                                                            {
                                                              v47 = 1;
                                                              goto LABEL_61;
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                          else if (BN_GENCB_call(cb, 2, v27++))
                                          {
                                            goto LABEL_36;
                                          }
                                        }
                                        goto LABEL_59;
                                      }
                                      if (!--v33)
                                      {
                                        v37 = 120;
                                        v38 = 154;
                                        goto LABEL_60;
                                      }
                                    }
                                  }
                                  break;
                                }
                              }
                              while (BN_GENCB_call(cb, 2, v27++));
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
LABEL_59:
  v37 = 3;
  v38 = 213;
LABEL_60:
  ERR_put_error(4, 4095, v37, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/rsa/rsa_gen.c", v38);
  v47 = 0;
LABEL_61:
  if (v11)
  {
    BN_CTX_end(v11);
    BN_CTX_free(v11);
  }
  return v47;
}

RSA *__cdecl RSA_generate_key(int bits, unint64_t e, void (__cdecl *callback)(int, int, void *), void *cb_arg)
{
  RSA *v8;
  BIGNUM *v9;
  BIGNUM *v10;
  uint64_t v11;
  BN_GENCB cb;

  memset(&cb, 0, sizeof(cb));
  v8 = RSA_new();
  v9 = BN_new();
  v10 = v9;
  if (v8 && v9)
  {
    v11 = 0;
    while (((e >> v11) & 1) == 0 || BN_set_bit(v10, v11))
    {
      if (++v11 == 64)
      {
        BN_GENCB_set_old((uint64_t)&cb, (uint64_t)callback, (uint64_t)cb_arg);
        if (!RSA_generate_key_ex(v8, bits, v10, &cb))
          break;
        BN_free(v10);
        return v8;
      }
    }
  }
  BN_free(v10);
  RSA_free(v8);
  return 0;
}

X509_LOOKUP *__cdecl X509_LOOKUP_new(X509_LOOKUP_METHOD *method)
{
  X509_LOOKUP *v2;
  X509_LOOKUP *v3;
  int (__cdecl *new_item)(X509_LOOKUP *);

  v2 = (X509_LOOKUP *)malloc_type_calloc(1uLL, 0x20uLL, 0x1030040AE83759AuLL);
  v3 = v2;
  if (v2)
  {
    v2->method = method;
    new_item = method->new_item;
    if (new_item && !((unsigned int (*)(X509_LOOKUP *))new_item)(v2))
    {
      free(v3);
      return 0;
    }
  }
  else
  {
    ERR_put_error(11, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_lu.c", 74);
  }
  return v3;
}

void X509_LOOKUP_free(X509_LOOKUP *ctx)
{
  X509_LOOKUP_METHOD *method;
  void (__cdecl *free)(X509_LOOKUP *);

  if (ctx)
  {
    method = ctx->method;
    if (method)
    {
      free = method->free;
      if (free)
        ((void (*)(X509_LOOKUP *))free)(ctx);
    }
    ::free(ctx);
  }
}

int X509_LOOKUP_init(X509_LOOKUP *ctx)
{
  X509_LOOKUP_METHOD *method;
  uint64_t (*init)(void);

  method = ctx->method;
  if (!method)
    return 0;
  init = (uint64_t (*)(void))method->init;
  if (init)
    return init();
  else
    return 1;
}

int X509_LOOKUP_shutdown(X509_LOOKUP *ctx)
{
  X509_LOOKUP_METHOD *method;
  uint64_t (*shutdown)(void);

  method = ctx->method;
  if (!method)
    return 0;
  shutdown = (uint64_t (*)(void))method->shutdown;
  if (shutdown)
    return shutdown();
  else
    return 1;
}

int X509_LOOKUP_ctrl(X509_LOOKUP *ctx, int cmd, const char *argc, uint64_t argl, char **ret)
{
  X509_LOOKUP_METHOD *method;
  uint64_t (*ctrl)(void);

  method = ctx->method;
  if (!method)
    return -1;
  ctrl = (uint64_t (*)(void))method->ctrl;
  if (ctrl)
    return ctrl();
  else
    return 1;
}

int X509_LOOKUP_by_subject(X509_LOOKUP *ctx, int type, X509_NAME *name, X509_OBJECT *ret)
{
  X509_LOOKUP_METHOD *method;
  uint64_t (*get_by_subject)(void);

  method = ctx->method;
  if (method && (get_by_subject = (uint64_t (*)(void))method->get_by_subject) != 0)
    return get_by_subject();
  else
    return 0;
}

int X509_LOOKUP_by_issuer_serial(X509_LOOKUP *ctx, int type, X509_NAME *name, ASN1_INTEGER *serial, X509_OBJECT *ret)
{
  X509_LOOKUP_METHOD *method;
  uint64_t (*get_by_issuer_serial)(void);

  method = ctx->method;
  if (method && (get_by_issuer_serial = (uint64_t (*)(void))method->get_by_issuer_serial) != 0)
    return get_by_issuer_serial();
  else
    return 0;
}

int X509_LOOKUP_by_fingerprint(X509_LOOKUP *ctx, int type, unsigned __int8 *bytes, int len, X509_OBJECT *ret)
{
  X509_LOOKUP_METHOD *method;
  uint64_t (*get_by_fingerprint)(void);

  method = ctx->method;
  if (method && (get_by_fingerprint = (uint64_t (*)(void))method->get_by_fingerprint) != 0)
    return get_by_fingerprint();
  else
    return 0;
}

int X509_LOOKUP_by_alias(X509_LOOKUP *ctx, int type, char *str, int len, X509_OBJECT *ret)
{
  X509_LOOKUP_METHOD *method;
  uint64_t (*get_by_alias)(void);

  method = ctx->method;
  if (method && (get_by_alias = (uint64_t (*)(void))method->get_by_alias) != 0)
    return get_by_alias();
  else
    return 0;
}

X509_STORE *X509_STORE_new(void)
{
  void *v0;
  STACK *v1;
  STACK *v2;
  X509_VERIFY_PARAM *v3;

  v0 = malloc_type_calloc(1uLL, 0x80uLL, 0x10A0040B451168FuLL);
  if (v0
    && (v1 = sk_new((int (__cdecl *)(const char *const *, const char *const *))x509_object_cmp),
        (*(_QWORD *)v0 = v1) != 0)
    && (v2 = sk_new_null(), (*((_QWORD *)v0 + 1) = v2) != 0)
    && (v3 = X509_VERIFY_PARAM_new(), (*((_QWORD *)v0 + 2) = v3) != 0)
    && CRYPTO_new_ex_data(4, v0, (CRYPTO_EX_DATA *)v0 + 7))
  {
    *((_DWORD *)v0 + 30) = 1;
  }
  else
  {
    ERR_put_error(11, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_lu.c", 215);
    X509_STORE_free((X509_STORE *)v0);
    return 0;
  }
  return (X509_STORE *)v0;
}

uint64_t x509_object_cmp(const X509_CRL ***a1, const X509_CRL ***a2)
{
  const X509_CRL **v2;
  int v3;
  const X509_CRL **v4;
  int v5;
  uint64_t result;

  v2 = *a1;
  v3 = *(_DWORD *)*a1;
  v4 = *a2;
  v5 = *(_DWORD *)*a2;
  result = (v3 - v5);
  if (v3 == v5)
  {
    if (v3 == 2)
    {
      return X509_CRL_cmp(v2[1], v4[1]);
    }
    else if (v3 == 1)
    {
      return X509_subject_name_cmp((const X509 *)v2[1], (const X509 *)v4[1]);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

void X509_STORE_free(X509_STORE *v)
{
  STACK *objs;
  int v3;
  char *v4;
  X509_LOOKUP *v5;
  uint64_t v6;
  void (*v7)(char *);

  if (v && CRYPTO_add_lock(&v->references, -1, 11, 0, 0) <= 0)
  {
    objs = v->objs;
    if (sk_num(objs) >= 1)
    {
      v3 = 0;
      do
      {
        v4 = sk_value(objs, v3);
        v5 = (X509_LOOKUP *)v4;
        v6 = *((_QWORD *)v4 + 1);
        if (v6)
        {
          v7 = *(void (**)(char *))(v6 + 32);
          if (v7)
            v7(v4);
        }
        X509_LOOKUP_free(v5);
        ++v3;
      }
      while (v3 < sk_num(objs));
    }
    sk_free(objs);
    sk_pop_free(*(STACK **)&v->cache, (void (__cdecl *)(void *))X509_OBJECT_free);
    CRYPTO_free_ex_data(4, v, (CRYPTO_EX_DATA *)&v->ex_data.dummy);
    X509_VERIFY_PARAM_free((X509_VERIFY_PARAM *)v->get_cert_methods);
    free(v);
  }
}

_DWORD *X509_OBJECT_new()
{
  _DWORD *v0;
  _DWORD *v1;

  v0 = malloc_type_calloc(1uLL, 0x10uLL, 0x1020040D5A9D86FuLL);
  v1 = v0;
  if (v0)
    *v0 = 0;
  else
    ERR_put_error(11, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_lu.c", 228);
  return v1;
}

void X509_OBJECT_free(X509_CRL **a1)
{
  if (a1)
  {
    if (*(_DWORD *)a1 == 2)
    {
      X509_CRL_free(a1[1]);
    }
    else if (*(_DWORD *)a1 == 1)
    {
      X509_free((X509 *)a1[1]);
    }
    free(a1);
  }
}

BOOL X509_STORE_up_ref(uint64_t a1)
{
  return CRYPTO_add_lock((int *)(a1 + 120), 1, 11, 0, 0) > 1;
}

X509_LOOKUP *__cdecl X509_STORE_add_lookup(X509_STORE *v, X509_LOOKUP_METHOD *m)
{
  STACK *objs;
  int v5;
  X509_LOOKUP *v6;
  X509_LOOKUP *v7;
  X509_LOOKUP *v8;
  X509_LOOKUP_METHOD *method;
  void (__cdecl *free)(X509_LOOKUP *);

  objs = v->objs;
  if (sk_num(objs) < 1)
  {
LABEL_5:
    v7 = X509_LOOKUP_new(m);
    v8 = v7;
    if (v7)
    {
      v7->store_ctx = v;
      if (sk_push(v->objs, (char *)v7) <= 0)
      {
        ERR_put_error(11, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_lu.c", 312);
        method = v8->method;
        if (method)
        {
          free = method->free;
          if (free)
            ((void (*)(X509_LOOKUP *))free)(v8);
        }
        ::free(v8);
        return 0;
      }
    }
  }
  else
  {
    v5 = 0;
    while (1)
    {
      v6 = (X509_LOOKUP *)sk_value(objs, v5);
      if (v6->method == m)
        return v6;
      if (++v5 >= sk_num(objs))
        goto LABEL_5;
    }
  }
  return v8;
}

X509_OBJECT *X509_STORE_CTX_get_obj_by_subject(uint64_t *a1, uint64_t a2, X509_NAME *a3)
{
  X509_OBJECT *v6;
  int v7;

  v6 = (X509_OBJECT *)X509_OBJECT_new();
  if (v6)
  {
    X509_STORE_CTX_get_by_subject(a1, a2, a3, v6);
    if (!v7)
    {
      X509_OBJECT_free((X509_CRL **)v6);
      return 0;
    }
  }
  return v6;
}

void X509_STORE_CTX_get_by_subject(uint64_t *a1, uint64_t a2, X509_NAME *a3, X509_OBJECT *a4)
{
  uint64_t v4;
  X509_OBJECT *v8;
  int v9;
  char *v10;
  uint64_t v11;
  unsigned int (*v12)(char *, uint64_t);
  int v13;
  _QWORD v14[2];

  v4 = *a1;
  if (*a1)
  {
    v14[0] = 0;
    v14[1] = 0;
    CRYPTO_lock(9, 11, 0, 0);
    v8 = X509_OBJECT_retrieve_by_subject(*(STACK **)v4, a2, a3);
    CRYPTO_lock(10, 11, 0, 0);
    if ((_DWORD)a2 == 2 || !v8)
    {
      if (sk_num(*(const STACK **)(v4 + 8)) < 1)
      {
LABEL_10:
        if (!v8)
          return;
      }
      else
      {
        v9 = 0;
        while (1)
        {
          v10 = sk_value(*(const STACK **)(v4 + 8), v9);
          v11 = *((_QWORD *)v10 + 1);
          if (v11)
          {
            v12 = *(unsigned int (**)(char *, uint64_t))(v11 + 48);
            if (v12)
            {
              if (v12(v10, a2))
                break;
            }
          }
          if (++v9 >= sk_num(*(const STACK **)(v4 + 8)))
            goto LABEL_10;
        }
        v8 = (X509_OBJECT *)v14;
      }
    }
    X509_OBJECT_up_ref_count(v8);
    if (v13)
      *a4 = *v8;
  }
}

X509_OBJECT *__cdecl X509_OBJECT_retrieve_by_subject(STACK *h, int type, X509_NAME *name)
{
  int v4;

  v4 = x509_object_idx_cnt(h, type, (uint64_t)name, 0);
  if (v4 == -1)
    return 0;
  else
    return (X509_OBJECT *)sk_value(h, v4);
}

void X509_OBJECT_up_ref_count(X509_OBJECT *a)
{
  if (a->type == 2)
  {
    X509_CRL_up_ref((uint64_t)a->data.ptr);
  }
  else if (a->type == 1)
  {
    X509_up_ref((uint64_t)a->data.ptr);
  }
}

int X509_STORE_add_cert(X509_STORE *ctx, X509 *x)
{
  _DWORD *v4;
  _DWORD *v5;

  if (x)
  {
    v4 = X509_OBJECT_new();
    if (v4)
    {
      v5 = v4;
      if (X509_up_ref((uint64_t)x))
      {
        *v5 = 1;
        *((_QWORD *)v5 + 1) = x;
        return X509_STORE_add_object((STACK **)ctx, (char *)v5);
      }
      X509_OBJECT_free((X509_CRL **)v5);
    }
  }
  return 0;
}

uint64_t X509_STORE_add_object(STACK **a1, char *a2)
{
  uint64_t v4;

  CRYPTO_lock(9, 11, 0, 0);
  if (!X509_OBJECT_retrieve_match(*a1, (X509_OBJECT *)a2))
  {
    if (sk_push(*a1, a2) <= 0)
    {
      ERR_put_error(11, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_lu.c", 392);
      v4 = 0;
      goto LABEL_5;
    }
    a2 = 0;
  }
  v4 = 1;
LABEL_5:
  CRYPTO_lock(10, 11, 0, 0);
  X509_OBJECT_free((X509_CRL **)a2);
  return v4;
}

int X509_STORE_add_crl(X509_STORE *ctx, X509_CRL *x)
{
  _DWORD *v4;
  _DWORD *v5;

  if (x)
  {
    v4 = X509_OBJECT_new();
    if (v4)
    {
      v5 = v4;
      if (X509_CRL_up_ref((uint64_t)x))
      {
        *v5 = 2;
        *((_QWORD *)v5 + 1) = x;
        return X509_STORE_add_object((STACK **)ctx, (char *)v5);
      }
      X509_OBJECT_free((X509_CRL **)v5);
    }
  }
  return 0;
}

uint64_t X509_OBJECT_get_type(unsigned int *a1)
{
  return *a1;
}

int X509_OBJECT_idx_by_subject(STACK *h, int type, X509_NAME *name)
{
  return x509_object_idx_cnt(h, type, (uint64_t)name, 0);
}

uint64_t x509_object_idx_cnt(STACK *st, int a2, uint64_t a3, _DWORD *a4)
{
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  int i;
  const X509_CRL **v11;
  const X509_CRL **v12;
  __int128 v13;
  _OWORD v14[4];
  _OWORD v15[6];
  uint64_t v16;
  char data[8];
  _OWORD *v18;
  _OWORD v19[10];
  _OWORD v20[14];
  uint64_t v21;
  uint64_t v22;

  v22 = *MEMORY[0x24BDAC8D0];
  *(_DWORD *)&data[4] = 0;
  v18 = 0;
  v21 = 0;
  memset(v20, 0, sizeof(v20));
  v16 = 0;
  memset(v15, 0, sizeof(v15));
  memset(v19, 0, sizeof(v19));
  memset(v14, 0, sizeof(v14));
  v13 = 0u;
  *(_DWORD *)data = a2;
  if (a2 == 2)
  {
    v18 = v19;
    *(_QWORD *)&v19[0] = &v13;
    v6 = v14;
  }
  else
  {
    if (a2 != 1)
      return 0xFFFFFFFFLL;
    v18 = v20;
    *(_QWORD *)&v20[0] = v15;
    v6 = (_QWORD *)&v15[2] + 1;
  }
  *v6 = a3;
  v7 = sk_find(st, data);
  v8 = v7;
  if (a4 && (v7 & 0x80000000) == 0)
  {
    *a4 = 1;
    v11 = (const X509_CRL **)data;
    for (i = v7 + 1; i < sk_num(st); ++i)
    {
      v12 = (const X509_CRL **)sk_value(st, i);
      if (x509_object_cmp(&v12, &v11))
        break;
      ++*a4;
    }
  }
  return v8;
}

uint64_t X509_OBJECT_get0_X509(uint64_t result)
{
  if (result)
  {
    if (*(_DWORD *)result == 1)
      return *(_QWORD *)(result + 8);
    else
      return 0;
  }
  return result;
}

uint64_t X509_OBJECT_get0_X509_CRL(uint64_t result)
{
  if (result)
  {
    if (*(_DWORD *)result == 2)
      return *(_QWORD *)(result + 8);
    else
      return 0;
  }
  return result;
}

X509_CRL **X509_STORE_CTX_get1_certs(STACK ***a1, X509_NAME *a2)
{
  STACK **v2;
  X509_CRL **result;

  v2 = *a1;
  if (!*a1)
    return 0;
  result = (X509_CRL **)X509_get1_certs_from_cache(*a1, (uint64_t)a2);
  if (!result)
  {
    result = (X509_CRL **)X509_STORE_CTX_get_obj_by_subject((uint64_t *)a1, 1, a2);
    if (result)
    {
      X509_OBJECT_free(result);
      return (X509_CRL **)X509_get1_certs_from_cache(v2, (uint64_t)a2);
    }
  }
  return result;
}

STACK *X509_get1_certs_from_cache(STACK **a1, uint64_t a2)
{
  int v4;
  int v5;
  STACK *v6;
  int v7;
  char *v8;
  int v10;

  v10 = 0;
  CRYPTO_lock(9, 11, 0, 0);
  v4 = x509_object_idx_cnt(*a1, 1, a2, &v10);
  if (v4 < 0)
  {
    v6 = 0;
  }
  else
  {
    v5 = v4;
    v6 = sk_new_null();
    if (v6)
    {
      if (v10 < 1)
      {
LABEL_8:
        CRYPTO_lock(10, 11, 0, 0);
        return v6;
      }
      v7 = 0;
      while (1)
      {
        v8 = (char *)*((_QWORD *)sk_value(*a1, v5 + v7) + 1);
        if (!X509_up_ref((uint64_t)v8))
          break;
        if (!sk_push(v6, v8))
          goto LABEL_11;
        if (++v7 >= v10)
          goto LABEL_8;
      }
    }
  }
  v8 = 0;
LABEL_11:
  CRYPTO_lock(10, 11, 0, 0);
  sk_pop_free(v6, (void (__cdecl *)(void *))X509_free);
  X509_free((X509 *)v8);
  return 0;
}

STACK *X509_STORE_CTX_get1_crls(uint64_t *a1, X509_NAME *a2)
{
  STACK **v2;
  X509_CRL **obj_by_subject;
  int v5;
  int v6;
  STACK *v7;
  int v8;
  X509_CRL *v9;
  int v11;

  v2 = (STACK **)*a1;
  if (!*a1)
    return 0;
  obj_by_subject = (X509_CRL **)X509_STORE_CTX_get_obj_by_subject(a1, 2, a2);
  if (!obj_by_subject)
    return 0;
  v11 = 0;
  X509_OBJECT_free(obj_by_subject);
  CRYPTO_lock(9, 11, 0, 0);
  v5 = x509_object_idx_cnt(*v2, 2, (uint64_t)a2, &v11);
  if (v5 < 0)
  {
    v7 = 0;
LABEL_12:
    v9 = 0;
LABEL_13:
    CRYPTO_lock(10, 11, 0, 0);
    X509_CRL_free(v9);
    sk_pop_free(v7, (void (__cdecl *)(void *))X509_CRL_free);
    return 0;
  }
  v6 = v5;
  v7 = sk_new_null();
  if (!v7)
    goto LABEL_12;
  if (v11 >= 1)
  {
    v8 = 0;
    do
    {
      v9 = (X509_CRL *)*((_QWORD *)sk_value(*v2, v6 + v8) + 1);
      if (!X509_CRL_up_ref((uint64_t)v9))
        goto LABEL_12;
      if (!sk_push(v7, (char *)v9))
        goto LABEL_13;
    }
    while (++v8 < v11);
  }
  CRYPTO_lock(10, 11, 0, 0);
  return v7;
}

X509_OBJECT *__cdecl X509_OBJECT_retrieve_match(STACK *h, X509_OBJECT *x)
{
  int v4;
  int v5;
  char *v6;
  const X509_CRL **v8;
  const X509_CRL **v9;

  v9 = (const X509_CRL **)x;
  v4 = sk_find(h, (char *)x);
  if (v4 != -1)
  {
    v5 = v4;
    if ((x->type - 1) > 1)
      return (X509_OBJECT *)sk_value(h, v4);
    while (v5 < sk_num(h))
    {
      v6 = sk_value(h, v5);
      v8 = (const X509_CRL **)v6;
      if (x509_object_cmp(&v8, &v9))
        break;
      if (x->type == 2)
      {
        if (!X509_CRL_match(*((_QWORD *)v6 + 1), (uint64_t)x->data.ptr))
          return (X509_OBJECT *)v6;
      }
      else if (x->type != 1 || !X509_cmp(*((const X509 **)v6 + 1), x->data.x509))
      {
        return (X509_OBJECT *)v6;
      }
      ++v5;
    }
  }
  return 0;
}

int X509_STORE_CTX_get1_issuer(X509 **issuer, X509_STORE_CTX *ctx, X509 *x)
{
  X509_NAME *issuer_name;
  X509_OBJECT *obj_by_subject;
  X509_CRL **v8;
  X509 *x509;
  int v10;
  int v12;
  int v13;
  X509 *v14;
  char *v15;
  char *v16;
  X509_NAME *subject_name;

  *issuer = 0;
  issuer_name = X509_get_issuer_name(x);
  obj_by_subject = X509_STORE_CTX_get_obj_by_subject((uint64_t *)ctx, 1, issuer_name);
  if (!obj_by_subject)
    return 0;
  v8 = (X509_CRL **)obj_by_subject;
  if (obj_by_subject->type != 1 || (x509 = obj_by_subject->data.x509) == 0)
  {
    X509_OBJECT_free((X509_CRL **)obj_by_subject);
    return 0;
  }
  if (!X509_up_ref((uint64_t)obj_by_subject->data.ptr))
  {
    X509_OBJECT_free(v8);
    return -1;
  }
  if (((unsigned int (*)(X509_STORE_CTX *, X509 *, X509 *))ctx->check_issued)(ctx, x, x509)
    && x509_check_cert_time((uint64_t)ctx, (uint64_t)x509, -1))
  {
    *issuer = x509;
    X509_OBJECT_free(v8);
    return 1;
  }
  X509_free(x509);
  X509_OBJECT_free(v8);
  if (!ctx->ctx)
    return 0;
  CRYPTO_lock(9, 11, 0, 0);
  v12 = x509_object_idx_cnt(*(STACK **)ctx->ctx, 1, (uint64_t)issuer_name, 0);
  if (v12 == -1)
    goto LABEL_24;
  v13 = v12;
  if (v12 >= sk_num(*(const STACK **)ctx->ctx))
    goto LABEL_24;
  v14 = 0;
  do
  {
    v15 = sk_value(*(const STACK **)ctx->ctx, v13);
    if (*(_DWORD *)v15 != 1)
      break;
    v16 = v15;
    subject_name = X509_get_subject_name(*((X509 **)v15 + 1));
    if (X509_NAME_cmp(issuer_name, subject_name))
      break;
    if (((unsigned int (*)(X509_STORE_CTX *, X509 *, _QWORD))ctx->check_issued)(ctx, x, *((_QWORD *)v16 + 1)))
    {
      v14 = (X509 *)*((_QWORD *)v16 + 1);
      if (x509_check_cert_time((uint64_t)ctx, (uint64_t)v14, -1))
        break;
    }
    ++v13;
  }
  while (v13 < sk_num(*(const STACK **)ctx->ctx));
  if (!v14)
  {
LABEL_24:
    v10 = 0;
  }
  else if (X509_up_ref((uint64_t)v14))
  {
    *issuer = v14;
    v10 = 1;
  }
  else
  {
    v10 = -1;
  }
  CRYPTO_lock(10, 11, 0, 0);
  return v10;
}

uint64_t X509_STORE_get0_objects(uint64_t a1)
{
  return *(_QWORD *)a1;
}

void *X509_STORE_get_ex_data(const CRYPTO_EX_DATA *a1, int a2)
{
  return CRYPTO_get_ex_data(a1 + 7, a2);
}

uint64_t X509_STORE_set_ex_data(CRYPTO_EX_DATA *a1, int a2, void *a3)
{
  return CRYPTO_set_ex_data(a1 + 7, a2, a3);
}

int X509_STORE_set_flags(X509_STORE *ctx, unint64_t flags)
{
  return X509_VERIFY_PARAM_set_flags((X509_VERIFY_PARAM *)ctx->get_cert_methods, flags);
}

int X509_STORE_set_depth(X509_STORE *store, int depth)
{
  X509_VERIFY_PARAM_set_depth((X509_VERIFY_PARAM *)store->get_cert_methods, depth);
  return 1;
}

int X509_STORE_set_purpose(X509_STORE *ctx, int purpose)
{
  return X509_VERIFY_PARAM_set_purpose((X509_VERIFY_PARAM *)ctx->get_cert_methods, purpose);
}

int X509_STORE_set_trust(X509_STORE *ctx, int trust)
{
  return X509_VERIFY_PARAM_set_trust((X509_VERIFY_PARAM *)ctx->get_cert_methods, trust);
}

int X509_STORE_set1_param(X509_STORE *ctx, X509_VERIFY_PARAM *pm)
{
  return X509_VERIFY_PARAM_set1((X509_VERIFY_PARAM *)ctx->get_cert_methods, pm);
}

uint64_t X509_STORE_get0_param(uint64_t a1)
{
  return *(_QWORD *)(a1 + 16);
}

uint64_t X509_STORE_set_verify(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 24) = a2;
  return result;
}

uint64_t X509_STORE_get_verify(uint64_t a1)
{
  return *(_QWORD *)(a1 + 24);
}

uint64_t X509_STORE_set_verify_cb(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 32) = a2;
  return result;
}

uint64_t X509_STORE_get_verify_cb(uint64_t a1)
{
  return *(_QWORD *)(a1 + 32);
}

unint64_t bn_div_words(unint64_t h, unint64_t l, unint64_t d)
{
  int v6;
  uint64_t v7;
  char v8;
  unint64_t v9;
  unint64_t v10;
  int v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  unint64_t v19;
  __int128 v20;
  BOOL v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  unint64_t v26;
  uint64_t v27;
  unint64_t v28;
  __int128 v29;
  unint64_t v30;
  uint64_t v31;
  int v32;
  int v33;
  uint64_t v34;
  __int128 v35;

  if (!d)
    return -1;
  v6 = BN_num_bits_word(d);
  if (v6 != 64 && 1 << v6 < h)
    bn_div_words_cold_1();
  v7 = 0;
  v8 = 0;
  if (h >= d)
    v9 = d;
  else
    v9 = 0;
  v10 = h - v9;
  v11 = -v6;
  if (v6 == 64)
    v12 = v10;
  else
    v12 = (v10 << -(char)v6) | (l >> v6);
  v13 = d << v11;
  v14 = l << v11;
  if (v6 == 64)
  {
    v14 = l;
    v13 = d;
  }
  v15 = HIDWORD(v13);
  while (1)
  {
    if (v15 == HIDWORD(v12))
      v16 = 0xFFFFFFFFLL;
    else
      v16 = v12 / v15;
    v17 = v16 * v15;
    v18 = v16 * v13;
    *((_QWORD *)&v20 + 1) = v12 - v16 * v15;
    *(_QWORD *)&v20 = v14;
    v19 = v20 >> 32;
    if (HIDWORD(*((_QWORD *)&v20 + 1)))
      v21 = 0;
    else
      v21 = v18 > v19;
    if (v21)
    {
      v22 = 0;
      v23 = 0;
      v24 = v13 * (v16 - 1);
      v25 = v12 - v15 * (v16 - 1);
      do
      {
        --v16;
        v26 = v25 + v22;
        v27 = v23 - v13;
        v22 += v15;
        if (HIDWORD(v26))
          break;
        v28 = v24 + v23;
        *((_QWORD *)&v29 + 1) = v26;
        *(_QWORD *)&v29 = v14;
        v23 -= v13;
      }
      while (v28 > (unint64_t)(v29 >> 32));
      v18 += v27;
      v17 -= v22;
    }
    v30 = v17 + HIDWORD(v18);
    if (v14 < v18 << 32)
      ++v30;
    v31 = (__PAIR128__(v16, v12) - v30) >> 64;
    if ((v8 & 1) != 0)
      break;
    v32 = v12 - v30;
    if (v12 >= v30)
      v33 = 0;
    else
      v33 = v13;
    v34 = (v32 + v33);
    v7 = v31 << 32;
    *((_QWORD *)&v35 + 1) = v34;
    *(_QWORD *)&v35 = v14 - (v18 << 32);
    v12 = v35 >> 32;
    v14 <<= 32;
    v8 = 1;
  }
  return v31 | v7;
}

unint64_t bn_div_rem_words(unint64_t a1, unint64_t a2, unint64_t a3, unint64_t *a4, _QWORD *a5)
{
  unint64_t result;

  result = bn_div_words(a1, a2, a3);
  *a4 = result;
  *a5 = a2 - result * a3;
  return result;
}

unint64_t bn_div_3_words(unint64_t *a1, unint64_t a2, unint64_t a3)
{
  unint64_t v4;
  unint64_t result;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  uint64_t v17;
  unint64_t v18;
  unint64_t v19;
  BOOL v20;
  uint64_t v21;

  v4 = *a1;
  if (v4 == a3)
    return -1;
  v8 = *(a1 - 1);
  result = bn_div_words(v4, v8, a3);
  v9 = result * (unint64_t)HIDWORD(a2);
  v10 = (v9 << 32) + result * (unint64_t)a2;
  v11 = ((result * (unint64_t)a2) | (v9 << 32)) & ~v10 | (result
                                                                                           * (unint64_t)a2) & (v9 << 32);
  v12 = HIDWORD(result) * (unint64_t)a2;
  v13 = v10 | (v12 << 32);
  v14 = v10 & (v12 << 32);
  v15 = v10 + (v12 << 32);
  v16 = HIDWORD(v9)
      + HIDWORD(result) * (unint64_t)HIDWORD(a2)
      + HIDWORD(v12)
      + (v11 >> 63)
      + ((v13 & ~v15 | v14) >> 63);
  if (v16 >= v8 - result * a3)
  {
    v17 = -(uint64_t)(result * a3);
    v18 = a3 - result * a3;
    while (1)
    {
      v19 = result;
      if (v17 + v8 == v16 && v15 <= *(a1 - 2))
        break;
      if (v18 + v8 >= a3)
      {
        v20 = v15 >= a2;
        v15 -= a2;
        v21 = !v20;
        v16 -= v21;
        v8 += a3;
        --result;
        if (v16 >= v17 + v8)
          continue;
      }
      return v19 - 1;
    }
  }
  return result;
}

int BN_div(BIGNUM *dv, BIGNUM *rem, const BIGNUM *m, const BIGNUM *d, BN_CTX *ctx)
{
  _BOOL4 v10;

  if (BN_get_flags((uint64_t)m, 4u))
    v10 = 1;
  else
    v10 = BN_get_flags((uint64_t)d, 4u) != 0;
  return BN_div_internal((uint64_t)dv, rem, m, d, ctx, v10);
}

uint64_t BN_div_internal(uint64_t a1, BIGNUM *a2, const BIGNUM *a3, const BIGNUM *a4, BN_CTX *ctx, int a6)
{
  int top;
  BOOL v13;
  int v14;
  int v15;
  int v16;
  int v17;
  BIGNUM *v18;
  BIGNUM *v19;
  BIGNUM *v20;
  BIGNUM *v21;
  BIGNUM *v22;
  BIGNUM *v23;
  int v24;
  int v25;
  int v26;
  int v27;
  int v28;
  uint64_t v29;
  uint64_t v31;
  int v32;
  uint64_t v33;
  int v34;
  int v35;
  unint64_t *v36;
  int v37;
  int neg;
  int v39;
  uint64_t v40;
  unint64_t *v41;
  int v42;
  int v43;
  unint64_t *v44;
  unint64_t v45;
  unint64_t v46;
  const unint64_t *v47;
  int v48;
  int v49;
  uint64_t *v50;
  unint64_t *d;
  int n;
  int v53;
  int num[2];
  BIGNUM *r;
  unint64_t v56;
  unint64_t v57;
  BIGNUM *b;
  unint64_t **p_d;
  BIGNUM a;

  memset(&a, 0, sizeof(a));
  BN_CTX_start(ctx);
  top = a3->top;
  v13 = __OFSUB__(top, 1);
  v14 = top - 1;
  if (v14 < 0 == v13 && !a3->d[v14])
  {
    v16 = 107;
    v17 = 252;
    goto LABEL_25;
  }
  if (a6)
    v15 = -1;
  else
    v15 = 0;
  if (BN_is_zero((uint64_t)a4))
  {
    v16 = 103;
    v17 = 260;
LABEL_25:
    ERR_put_error(3, 4095, v16, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/bn/bn_div.c", v17);
    goto LABEL_26;
  }
  if (!a6 && BN_ucmp(a3, a4) < 0)
  {
    if (a2 && !bn_copy(a2, a3))
      goto LABEL_26;
    if (a1)
      BN_zero(a1);
LABEL_60:
    a1 = 1;
    goto LABEL_27;
  }
  v18 = BN_CTX_get(ctx);
  if (!v18)
    goto LABEL_26;
  v19 = v18;
  v20 = BN_CTX_get(ctx);
  if (!v20)
    goto LABEL_26;
  v21 = v20;
  r = a2;
  p_d = &v19->d;
  v22 = BN_CTX_get(ctx);
  if (!v22)
    goto LABEL_26;
  v23 = v22;
  if (a1 || (a1 = (uint64_t)BN_CTX_get(ctx)) != 0)
  {
    v24 = BN_num_bits(a4);
    if (v24 <= 0)
      v25 = -(-v24 & 0x3F);
    else
      v25 = v24 & 0x3F;
    if (!BN_lshift(v23, a4, 64 - v25))
      goto LABEL_26;
    b = v23;
    v23->neg = 0;
    v26 = 128 - v25;
    if (!BN_lshift(v21, a3, 128 - v25))
      goto LABEL_26;
    v21->neg = 0;
    v27 = v21->top;
    if (a6)
    {
      v28 = v23->top;
      if (v27 <= v28 + 1)
      {
        if (!bn_wexpand((uint64_t)v21, (v28 + 2)))
          goto LABEL_26;
        v31 = v21->top;
        v32 = v23->top;
        v27 = v32 + 2;
        if ((int)v31 < v32 + 2)
          bzero(&v21->d[v31], 8 * (v32 - v31 + 1) + 8);
      }
      else
      {
        if (!bn_wexpand((uint64_t)v21, (v27 + 1)))
        {
LABEL_26:
          a1 = 0;
          goto LABEL_27;
        }
        v29 = v21->top;
        v21->d[v29] = 0;
        v27 = v29 + 1;
      }
      v21->top = v27;
    }
    v33 = v23->top;
    v34 = v27 - v33;
    a.neg = 0;
    d = v21->d;
    a.d = &v21->d[v27 - (int)v33];
    v35 = v21->dmax - (v27 - v33);
    a.top = v33;
    a.dmax = v35;
    a.flags = v21->flags | 2;
    v36 = v23->d;
    n = v26;
    v53 = v27;
    *(_QWORD *)num = v33;
    if ((_DWORD)v33 == 1)
      v56 = 0;
    else
      v56 = v36[(int)v33 - 2];
    v57 = v36[(int)v33 - 1];
    v37 = v27 - v33;
    if (!bn_wexpand(a1, (v34 + 1)))
      goto LABEL_26;
    *(_DWORD *)(a1 + 8) = v37 + v15;
    neg = a3->neg;
    v39 = a4->neg;
    v40 = *(_QWORD *)a1;
    if (!bn_wexpand((uint64_t)p_d, (num[0] + 1)))
      goto LABEL_26;
    v41 = (unint64_t *)(v40 + 8 * (v37 - 1));
    if (!a6)
    {
      if (BN_ucmp(&a, b) < 0)
      {
        v42 = *(_DWORD *)(a1 + 8) - 1;
        *(_DWORD *)(a1 + 8) = v42;
        goto LABEL_46;
      }
      bn_sub_words(a.d, a.d, b->d, num[0]);
      *v41 = 1;
    }
    v42 = *(_DWORD *)(a1 + 8);
LABEL_46:
    v49 = v39;
    v50 = (uint64_t *)v21;
    if (v42)
      --v41;
    else
      *(_DWORD *)(a1 + 16) = 0;
    if (v37 >= 2)
    {
      v43 = v53 - 1;
      v44 = &d[v53 - 1];
      do
      {
        v45 = bn_div_3_words(v44, v56, v57);
        v46 = bn_mul_words(*p_d, b->d, num[0], v45);
        v47 = *p_d;
        (*p_d)[*(_QWORD *)num] = v46;
        --a.d;
        if (bn_sub_words(a.d, a.d, v47, num[0] + 1))
        {
          --v45;
          if (bn_add_words(a.d, a.d, b->d, num[0]))
            ++*v44;
        }
        *v41-- = v45;
        --v44;
        --v43;
      }
      while (num[0] != v43);
    }
    bn_correct_top(v50);
    if (r)
    {
      v48 = a3->neg;
      BN_rshift(r, (const BIGNUM *)v50, n);
      BN_set_negative(r, v48);
    }
    if (a6)
      bn_correct_top((uint64_t *)a1);
    BN_set_negative((BIGNUM *)a1, v49 ^ neg);
    goto LABEL_60;
  }
LABEL_27:
  BN_CTX_end(ctx);
  return a1;
}

uint64_t BN_div_nonct(uint64_t a1, BIGNUM *a2, const BIGNUM *a3, const BIGNUM *a4, BN_CTX *a5)
{
  return BN_div_internal(a1, a2, a3, a4, a5, 0);
}

uint64_t BN_div_ct(uint64_t a1, BIGNUM *a2, const BIGNUM *a3, const BIGNUM *a4, BN_CTX *a5)
{
  return BN_div_internal(a1, a2, a3, a4, a5, 1);
}

void bn_div_words_cold_1()
{
  __assert_rtn("bn_div_words", "bn_div.c", 96, "(i == BN_BITS2) || (h <= (BN_ULONG)1 << i)");
}

int X509_print_fp(FILE *bp, X509 *x)
{
  return X509_print_ex_fp(bp, x, 0, 0);
}

int X509_print_ex_fp(FILE *bp, X509 *x, unint64_t nmflag, unint64_t cflag)
{
  BIO_METHOD *v8;
  BIO *v9;
  BIO *v10;
  int v11;

  v8 = BIO_s_file();
  v9 = BIO_new(v8);
  if (v9)
  {
    v10 = v9;
    BIO_ctrl(v9, 106, 0, bp);
    v11 = X509_print_ex(v10, x, nmflag, cflag);
    BIO_free(v10);
    return v11;
  }
  else
  {
    ERR_put_error(11, 4095, 7, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/t_x509.c", 96);
    return 0;
  }
}

int X509_print_ex(BIO *bp, X509 *x, unint64_t nmflag, unint64_t cflag)
{
  uint64_t v8;
  int v9;
  int v10;
  X509_CINF *cert_info;
  int v12;
  ASN1_INTEGER *serialNumber;
  ASN1_INTEGER *v14;
  uint64_t v15;
  X509_NAME *issuer_name;
  ASN1_TIME *v17;
  int result;
  ASN1_TIME *v19;
  X509_NAME *subject_name;
  EVP_PKEY *pubkey;
  EVP_PKEY *v22;
  const char *v23;
  uint64_t v24;
  int v25;
  uint64_t v26;
  uint64_t v27;

  if ((nmflag & 0xF0000) == 0x40000)
    v8 = 10;
  else
    v8 = 32;
  if ((nmflag & 0xF0000) == 0x40000)
    v9 = 12;
  else
    v9 = 0;
  if (nmflag)
    v10 = v9;
  else
    v10 = 16;
  cert_info = x->cert_info;
  if ((cflag & 1) == 0 && (BIO_write(bp, "Certificate:\n", 13) < 1 || BIO_write(bp, "    Data:\n", 10) < 1))
    return 0;
  if ((cflag & 2) == 0)
  {
    v12 = (unint64_t)X509_get_version((ASN1_INTEGER ***)x) > 2
        ? BIO_printf(bp, "%8sVersion: unknown (%ld)\n")
        : BIO_printf(bp, "%8sVersion: %ld (0x%lx)\n");
    if (v12 < 1)
      return 0;
  }
  v27 = v8;
  if ((cflag & 4) == 0)
  {
    if (BIO_write(bp, "        Serial Number:", 22) < 1)
      return 0;
    serialNumber = X509_get_serialNumber(x);
    v14 = serialNumber;
    if (serialNumber->length > 8 || (v15 = ASN1_INTEGER_get(serialNumber), v15 < 0))
    {
      if (v14->type == 258)
        v23 = " (Negative)";
      else
        v23 = "";
      if (BIO_printf(bp, "\n%12s%s", "", v23) < 1)
        return 0;
      v24 = 0;
      while (v24 < v14->length)
      {
        v25 = v14->data[v24++];
        if (v24 == v14->length)
          v26 = 10;
        else
          v26 = 58;
        if (BIO_printf(bp, "%02x%c", v25, v26) < 1)
          return 0;
      }
    }
    else if (BIO_printf(bp, " %ld (0x%lx)\n", v15, v15) < 1)
    {
      return 0;
    }
  }
  if ((cflag & 8) == 0 && X509_signature_print(bp, x->sig_alg, 0) < 1)
    return 0;
  if ((cflag & 0x10) == 0)
  {
    if (BIO_printf(bp, "        Issuer:%c", v27) < 1)
      return 0;
    issuer_name = X509_get_issuer_name(x);
    if (X509_NAME_print_ex(bp, issuer_name, v10, nmflag) < (nmflag == 0) || BIO_write(bp, "\n", 1) < 1)
      return 0;
  }
  if ((cflag & 0x20) == 0)
  {
    if (BIO_write(bp, "        Validity\n", 17) < 1 || BIO_write(bp, "            Not Before: ", 24) < 1)
      return 0;
    v17 = (ASN1_TIME *)X509_getm_notBefore((uint64_t)x);
    result = ASN1_TIME_print(bp, v17);
    if (!result)
      return result;
    if (BIO_write(bp, "\n            Not After : ", 25) < 1)
      return 0;
    v19 = (ASN1_TIME *)X509_getm_notAfter((uint64_t)x);
    result = ASN1_TIME_print(bp, v19);
    if (!result)
      return result;
    if (BIO_write(bp, "\n", 1) < 1)
      return 0;
  }
  if ((cflag & 0x40) == 0)
  {
    if (BIO_printf(bp, "        Subject:%c", v27) < 1)
      return 0;
    subject_name = X509_get_subject_name(x);
    if (X509_NAME_print_ex(bp, subject_name, v10, nmflag) < (nmflag == 0) || BIO_write(bp, "\n", 1) < 1)
      return 0;
  }
  if ((cflag & 0x80) == 0)
  {
    if (BIO_write(bp, "        Subject Public Key Info:\n", 33) >= 1
      && BIO_printf(bp, "%12sPublic Key Algorithm: ", "") >= 1
      && i2a_ASN1_OBJECT(bp, cert_info->key->algor->algorithm) >= 1
      && BIO_puts(bp, "\n") >= 1)
    {
      pubkey = X509_get_pubkey(x);
      if (pubkey)
      {
        v22 = pubkey;
        EVP_PKEY_print_public(bp, (uint64_t)pubkey, 16);
        EVP_PKEY_free(v22);
      }
      else
      {
        BIO_printf(bp, "%12sUnable to load Public Key\n", "");
        ERR_print_errors(bp);
      }
      goto LABEL_60;
    }
    return 0;
  }
LABEL_60:
  if ((cflag & 0x100) == 0)
    X509V3_extensions_print(bp, "X509v3 extensions", cert_info->extensions, cflag, 8);
  if ((cflag & 0x200) == 0 && X509_signature_print(bp, x->sig_alg, x->signature) < 1)
    return 0;
  if ((cflag & 0x400) != 0)
    return 1;
  result = X509_CERT_AUX_print(bp, (X509_CERT_AUX *)x[1].ex_pcpathlen, 0);
  if (result)
    return 1;
  return result;
}

int X509_print(BIO *bp, X509 *x)
{
  return X509_print_ex(bp, x, 0, 0);
}

int X509_signature_print(BIO *bp, X509_ALGOR *alg, ASN1_STRING *sig)
{
  int v6;
  uint64_t v7;
  uint64_t (*v8)(BIO *, X509_ALGOR *, ASN1_STRING *, uint64_t, _QWORD);
  uint64_t v10;

  if (BIO_puts(bp, "    Signature Algorithm: ") < 1 || i2a_ASN1_OBJECT(bp, alg->algorithm) < 1)
    return 0;
  v6 = OBJ_obj2nid(alg->algorithm);
  if (v6)
  {
    v10 = 0;
    if (OBJ_find_sigid_algs(v6, &v10, (_DWORD *)&v10 + 1))
    {
      v7 = EVP_PKEY_asn1_find(0, SHIDWORD(v10));
      if (v7)
      {
        v8 = *(uint64_t (**)(BIO *, X509_ALGOR *, ASN1_STRING *, uint64_t, _QWORD))(v7 + 160);
        if (v8)
          return v8(bp, alg, sig, 9, 0);
      }
    }
  }
  if (sig)
    return X509_signature_dump(bp, (unsigned int *)sig, 9);
  return BIO_puts(bp, "\n") > 0;
}

int ASN1_TIME_print(BIO *fp, ASN1_TIME *a)
{
  int type;

  type = a->type;
  if (type == 24)
    return ASN1_GENERALIZEDTIME_print(fp, a);
  if (type == 23)
    return ASN1_UTCTIME_print(fp, a);
  BIO_write(fp, "Bad time value", 14);
  return 0;
}

int X509_ocspid_print(BIO *bp, X509 *x)
{
  int v4;
  size_t v5;
  unsigned __int8 *v6;
  const EVP_MD *v7;
  uint64_t v8;
  ASN1_BIT_STRING *public_key;
  unsigned __int8 *data;
  size_t length;
  const EVP_MD *v12;
  uint64_t v13;
  unsigned __int8 *out;
  unsigned __int8 md[20];
  uint64_t v17;

  v17 = *MEMORY[0x24BDAC8D0];
  if (BIO_printf(bp, "        Subject OCSP hash: ") < 1 || (v4 = i2d_X509_NAME(x->cert_info->subject, 0), v4 < 1))
  {
LABEL_15:
    v6 = 0;
  }
  else
  {
    v5 = v4;
    v6 = (unsigned __int8 *)malloc_type_malloc(v4, 0x76F293E4uLL);
    out = v6;
    if (v6)
    {
      if (i2d_X509_NAME(x->cert_info->subject, &out) >= 1)
      {
        v7 = EVP_sha1();
        if (EVP_Digest(v6, v5, md, 0, v7, 0))
        {
          v8 = 0;
          while (BIO_printf(bp, "%02X", md[v8]) >= 1)
          {
            if (++v8 == 20)
            {
              free(v6);
              if (BIO_printf(bp, "\n        Public key OCSP hash: ") >= 1)
              {
                public_key = x->cert_info->key->public_key;
                data = public_key->data;
                length = public_key->length;
                v12 = EVP_sha1();
                if (EVP_Digest(data, length, md, 0, v12, 0))
                {
                  v13 = 0;
                  while (BIO_printf(bp, "%02X", md[v13]) >= 1)
                  {
                    if (++v13 == 20)
                    {
                      BIO_printf(bp, "\n");
                      return 1;
                    }
                  }
                }
              }
              goto LABEL_15;
            }
          }
        }
      }
    }
  }
  free(v6);
  return 0;
}

BOOL X509_signature_dump(BIO *b, unsigned int *a2, int a3)
{
  unsigned int v5;
  int v6;
  uint64_t v7;
  unsigned __int8 *v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  int v12;
  const char *v13;

  v5 = 0;
  v6 = 0;
  v7 = *a2;
  v8 = (unsigned __int8 *)*((_QWORD *)a2 + 1);
  v9 = v7 & ~((int)v7 >> 31);
  v10 = v7 - 1;
  while (v9)
  {
    if (v6 + 18 * (v5 / 0x12) || BIO_write(b, "\n", 1) >= 1 && BIO_indent(b, a3, a3) >= 1)
    {
      v12 = *v8++;
      v11 = v12;
      v13 = v10 ? ":" : "";
      --v9;
      --v6;
      ++v5;
      --v10;
      if (BIO_printf(b, "%02x%s", v11, v13) >= 1)
        continue;
    }
    return 0;
  }
  return BIO_write(b, "\n", 1) == 1;
}

int ASN1_UTCTIME_print(BIO *fp, ASN1_UTCTIME *a)
{
  int length;
  uint64_t v4;
  unsigned __int8 *data;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  unsigned int v15;
  int v16;
  int v17;
  const char *v18;

  length = a->length;
  if (a->length >= 10)
  {
    v4 = 0;
    data = a->data;
    v6 = data[length - 1];
    while (data[v4] - 58 >= 0xFFFFFFF6)
    {
      if (++v4 == 10)
      {
        v7 = (char)data[1] + 10 * (char)*data;
        if (v7 >= 578)
          v8 = -528;
        else
          v8 = -428;
        v9 = (char)data[3] + 10 * (char)data[2];
        if ((v9 - 541) < 0xFFFFFFF4)
          break;
        v10 = (char)data[5] + 10 * (char)data[4] - 528;
        v11 = (char)data[7] + 10 * (char)data[6] - 528;
        v12 = (char)data[9] + 10 * (char)data[8] - 528;
        if (length < 12 || (v13 = (char)data[10], (v13 - 48) > 9))
        {
          v16 = 0;
        }
        else
        {
          v14 = data[11];
          v15 = v14 - 48;
          v16 = v14 + 10 * v13 - 528;
          if (v15 > 9)
            v16 = 0;
        }
        v17 = v7 + v8 + 1900;
        if (v6 == 90)
          v18 = " GMT";
        else
          v18 = "";
        return BIO_printf(fp, "%s %2d %02d:%02d:%02d %d%s", mon[v9 - 529], v10, v11, v12, v16, v17, v18) > 0;
      }
    }
  }
  BIO_write(fp, "Bad time value", 14);
  return 0;
}

int ASN1_GENERALIZEDTIME_print(BIO *fp, ASN1_GENERALIZEDTIME *a)
{
  int length;
  uint64_t v4;
  unsigned __int8 *data;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  uint64_t v12;
  int v13;
  int v14;
  int v15;
  const char *v16;
  uint64_t v17;
  unsigned __int8 *v18;
  const char *v19;
  const char *v20;

  length = a->length;
  if (a->length >= 12)
  {
    v4 = 0;
    data = a->data;
    v6 = data[length - 1];
    do
    {
      if (data[v4] - 58 < 0xFFFFFFF6)
        goto LABEL_2;
      ++v4;
    }
    while (v4 != 12);
    v7 = (char)data[5] + 10 * (char)data[4];
    if ((v7 - 541) < 0xFFFFFFF4)
      goto LABEL_2;
    v8 = 100 * (char)data[1] + 1000 * (char)*data + 10 * (char)data[2] + (char)data[3] - 53328;
    v9 = (char)data[7] + 10 * (char)data[6] - 528;
    v10 = (char)data[9] + 10 * (char)data[8] - 528;
    v11 = (char)data[11] + 10 * (char)data[10] - 528;
    v12 = (length - 14);
    if (length < 14)
    {
      v15 = 0;
      LODWORD(v12) = 0;
      v16 = "";
    }
    else
    {
      v13 = (char)data[12];
      if ((v13 - 48) > 9 || (v14 = data[13], (v14 - 48) > 9))
      {
        v15 = 0;
      }
      else
      {
        v15 = v14 + 10 * v13 - 528;
        if (length >= 0xF)
        {
          v16 = (const char *)(data + 14);
          if (data[14] == 46)
          {
            if (length < 0x10)
            {
              LODWORD(v12) = 1;
            }
            else
            {
              v17 = 0;
              v18 = data + 15;
              while (v18[v17] - 48 <= 9)
              {
                if (v12 - 1 == ++v17)
                  goto LABEL_21;
              }
              LODWORD(v12) = v17 + 1;
            }
            goto LABEL_21;
          }
        }
      }
      LODWORD(v12) = 0;
      v16 = "";
    }
LABEL_21:
    v19 = mon[v7 - 529];
    if (v6 == 90)
      v20 = " GMT";
    else
      v20 = "";
    return BIO_printf(fp, "%s %2d %02d:%02d:%02d%.*s %d%s", v19, v9, v10, v11, v15, v12, v16, v8, v20) > 0;
  }
LABEL_2:
  BIO_write(fp, "Bad time value", 14);
  return 0;
}

int X509_NAME_print(BIO *bp, X509_NAME *name, int obase)
{
  char *v4;
  char *v5;
  char *v6;
  uint64_t v7;
  char *v8;
  int v9;
  int v10;
  int v11;

  v4 = X509_NAME_oneline(name, 0, 0);
  if (!v4)
    return 0;
  v5 = v4;
  if (!*v4)
  {
    free(v4);
    return 1;
  }
  v6 = v4 + 1;
  v7 = 2;
  while (1)
  {
    v8 = &v5[v7];
    v9 = v5[v7 - 1];
    if (!v5[v7 - 1])
      break;
    if (v9 == 47)
    {
      if (v5[v7] - 65 > 0x19
        || (v10 = v5[v7 + 1], v10 != 61) && ((v10 - 65) > 0x19 || v5[v7 + 2] != 61))
      {
        v9 = 47;
        goto LABEL_15;
      }
      break;
    }
LABEL_15:
    ++v7;
    if (!v9)
      goto LABEL_16;
  }
  if (~(_DWORD)v6 + (_DWORD)v5 + (_DWORD)v7 != BIO_write(bp, v6, ~(_DWORD)v6 + (_DWORD)v5 + v7))
    goto LABEL_19;
  if (!*(v8 - 1))
  {
LABEL_16:
    v11 = 1;
    goto LABEL_20;
  }
  if (BIO_write(bp, ", ", 2) == 2)
  {
    v6 = &v5[v7];
    v9 = *(v8 - 1);
    goto LABEL_15;
  }
LABEL_19:
  ERR_put_error(11, 4095, 7, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/t_x509.c", 508);
  v11 = 0;
LABEL_20:
  free(v5);
  return v11;
}

int CONF_modules_load(const CONF *cnf, const char *appname, unint64_t flags)
{
  char v3;
  char *string;
  STACK *section;
  const STACK *v7;
  int v8;
  char *v9;
  char *v10;
  const char *v11;
  char *v12;
  int v13;
  int v14;
  const char **v15;
  char *v16;
  DSO *v17;
  DSO *v18;
  DSO_FUNC_TYPE v19;
  uint64_t v20;
  DSO_FUNC_TYPE v21;
  char *v22;
  char *v23;
  char *v24;
  char *v25;
  const char *v26;
  int v27;
  int v28;
  STACK *v29;
  int v30;
  const char *v31;

  if (cnf)
  {
    v3 = flags;
    if (!appname)
      goto LABEL_5;
    string = NCONF_get_string(cnf, 0, appname);
    if (string)
      goto LABEL_6;
    if ((v3 & 0x20) != 0)
    {
LABEL_5:
      string = NCONF_get_string(cnf, 0, "openssl_conf");
      if (string)
      {
LABEL_6:
        section = NCONF_get_section(cnf, string);
        if (!section)
          return (int)section;
        v7 = section;
        if (sk_num(section) >= 1)
        {
          v8 = 0;
          while (1)
          {
            v9 = sk_value(v7, v8);
            v10 = (char *)*((_QWORD *)v9 + 1);
            v11 = (const char *)*((_QWORD *)v9 + 2);
            v12 = strrchr(v10, 46);
            v13 = v12 ? (int)v12 - (int)v10 : strlen(v10);
            if (sk_num((const STACK *)supported_modules) >= 1)
              break;
LABEL_16:
            if ((v3 & 8) == 0)
            {
              v16 = NCONF_get_string(cnf, v11, "path");
              if (!v16)
              {
                ERR_clear_error();
                v16 = v10;
              }
              v17 = DSO_load(0, v16, 0, 0);
              if (v17)
              {
                v18 = v17;
                v19 = DSO_bind_func(v17, "OPENSSL_init");
                if (v19)
                {
                  v20 = (uint64_t)v19;
                  v21 = DSO_bind_func(v18, "OPENSSL_finish");
                  v15 = (const char **)module_add((uint64_t)v18, v10, v20, (uint64_t)v21);
                  if (v15)
                    goto LABEL_22;
                  v28 = 0;
                }
                else
                {
                  v28 = 112;
                }
                DSO_free(v18);
              }
              else
              {
                v28 = 110;
              }
              ERR_put_error(14, 4095, v28, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/conf/conf_mod.c", 273);
              ERR_asprintf_error_data("module=%s, path=%s", v10, v16);
            }
            if ((v3 & 4) == 0)
            {
              ERR_put_error(14, 4095, 113, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/conf/conf_mod.c", 214);
              ERR_asprintf_error_data("module=%s");
            }
LABEL_42:
            if ((v3 & 1) == 0)
            {
              LODWORD(section) = -1;
              return (int)section;
            }
LABEL_43:
            if (++v8 >= sk_num(v7))
              goto LABEL_58;
          }
          v14 = 0;
          while (1)
          {
            v15 = (const char **)sk_value((const STACK *)supported_modules, v14);
            if (!strncmp(v15[1], v10, v13))
              break;
            if (++v14 >= sk_num((const STACK *)supported_modules))
              goto LABEL_16;
          }
LABEL_22:
          v22 = (char *)malloc_type_malloc(0x28uLL, 0x10B0040F35B56FDuLL);
          if (!v22)
          {
LABEL_34:
            if ((v3 & 4) == 0)
            {
              ERR_put_error(14, 4095, 109, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/conf/conf_mod.c", 224);
              ERR_asprintf_error_data("module=%s, value=%s, retcode=%-8d");
            }
            goto LABEL_42;
          }
          v23 = v22;
          *(_QWORD *)v22 = v15;
          if (v10)
          {
            v24 = strdup(v10);
            *((_QWORD *)v23 + 1) = v24;
            if (v11)
            {
LABEL_25:
              v25 = strdup(v11);
              *((_QWORD *)v23 + 2) = v25;
              *((_QWORD *)v23 + 4) = 0;
              if (v24 && v25)
              {
                v26 = v15[2];
                if (v26)
                {
                  v27 = 1;
                  if (((int (*)(char *, const CONF *))v26)(v23, cnf) < 1)
                  {
LABEL_53:
                    if (v27)
                    {
                      v31 = v15[3];
                      if (v31)
                        ((void (*)(char *))v31)(v23);
                    }
                    goto LABEL_33;
                  }
                }
                else
                {
                  v27 = 0;
                }
                v29 = (STACK *)initialized_modules;
                if (initialized_modules || (v29 = sk_new_null(), (initialized_modules = (uint64_t)v29) != 0))
                {
                  if (sk_push(v29, v23))
                  {
                    ++*((_DWORD *)v15 + 8);
                    goto LABEL_43;
                  }
                  v30 = 376;
                }
                else
                {
                  v30 = 370;
                }
                ERR_put_error(14, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/conf/conf_mod.c", v30);
                goto LABEL_53;
              }
LABEL_33:
              free(*((void **)v23 + 1));
              free(*((void **)v23 + 2));
              free(v23);
              goto LABEL_34;
            }
          }
          else
          {
            v24 = 0;
            *((_QWORD *)v22 + 1) = 0;
            if (v11)
              goto LABEL_25;
          }
          *((_QWORD *)v23 + 2) = 0;
          *((_QWORD *)v23 + 4) = 0;
          goto LABEL_33;
        }
LABEL_58:
        LODWORD(section) = 1;
        return (int)section;
      }
    }
    ERR_clear_error();
    goto LABEL_58;
  }
  LODWORD(section) = 1;
  return (int)section;
}

int CONF_modules_load_file(const char *filename, const char *appname, unint64_t flags)
{
  CONF *v6;
  const char *v7;
  const char *default_cert_area;
  int v9;
  char *v10;
  int v11;
  char *v13;

  v6 = NCONF_new(0);
  if (!v6)
  {
    v7 = 0;
LABEL_8:
    v11 = 0;
    goto LABEL_9;
  }
  v7 = filename;
  if (!filename)
  {
    v13 = 0;
    default_cert_area = X509_get_default_cert_area();
    v9 = asprintf(&v13, "%s/openssl.cnf", default_cert_area);
    v10 = 0;
    v11 = 0;
    if (v9 == -1)
      goto LABEL_10;
    v7 = v13;
    if (!v13)
      goto LABEL_10;
  }
  if (NCONF_load(v6, v7, 0) > 0)
  {
    v11 = CONF_modules_load(v6, appname, flags);
    goto LABEL_9;
  }
  if ((flags & 0x10) == 0 || (ERR_peek_last_error() & 0xFFF) != 0x72)
    goto LABEL_8;
  ERR_clear_error();
  v11 = 1;
LABEL_9:
  v10 = (char *)v7;
  if (!filename)
LABEL_10:
    free(v10);
  NCONF_free(v6);
  return v11;
}

char *CONF_get1_default_config_file(void)
{
  const char *default_cert_area;
  char *v2;

  v2 = 0;
  default_cert_area = X509_get_default_cert_area();
  if (asprintf(&v2, "%s/openssl.cnf", default_cert_area) == -1)
    return 0;
  else
    return v2;
}

void CONF_modules_unload(int all)
{
  int v2;
  unsigned int i;
  char *v4;
  char *v5;

  CONF_modules_finish();
  v2 = sk_num((const STACK *)supported_modules);
  if (v2 >= 1)
  {
    for (i = v2 + 1; i > 1; --i)
    {
      v4 = sk_value((const STACK *)supported_modules, i - 2);
      v5 = v4;
      if (*((int *)v4 + 8) <= 0)
      {
        if (all || *(_QWORD *)v4)
        {
LABEL_5:
          sk_delete((STACK *)supported_modules, i - 2);
          if (*(_QWORD *)v5)
            DSO_free(*(DSO **)v5);
          free(*((void **)v5 + 1));
          free(v5);
        }
      }
      else if (all)
      {
        goto LABEL_5;
      }
    }
  }
  if (!sk_num((const STACK *)supported_modules))
  {
    sk_free((STACK *)supported_modules);
    supported_modules = 0;
  }
}

void CONF_modules_finish(void)
{
  char *v0;
  void **v1;
  _DWORD *v2;
  void (*v3)(char *);

  if (sk_num((const STACK *)initialized_modules) >= 1)
  {
    do
    {
      v0 = sk_pop((STACK *)initialized_modules);
      v1 = (void **)v0;
      v2 = *(_DWORD **)v0;
      v3 = *(void (**)(char *))(*(_QWORD *)v0 + 24);
      if (v3)
      {
        v3(v0);
        v2 = *v1;
      }
      --v2[8];
      free(v1[1]);
      free(v1[2]);
      free(v1);
    }
    while (sk_num((const STACK *)initialized_modules) > 0);
  }
  sk_free((STACK *)initialized_modules);
  initialized_modules = 0;
}

int CONF_module_add(const char *name, conf_init_func *ifunc, conf_finish_func *ffunc)
{
  return module_add(0, name, (uint64_t)ifunc, (uint64_t)ffunc) != 0;
}

_QWORD *module_add(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v8;
  _QWORD *v9;

  if (!a2)
    return 0;
  if (!supported_modules)
  {
    supported_modules = (uint64_t)sk_new_null();
    if (!supported_modules)
      return 0;
  }
  v8 = malloc_type_malloc(0x30uLL, 0x10B004022DC5C45uLL);
  v9 = v8;
  if (v8)
  {
    *v8 = a1;
    v8[1] = strdup(a2);
    v9[2] = a3;
    v9[3] = a4;
    *((_DWORD *)v9 + 8) = 0;
    if (!sk_push((STACK *)supported_modules, (char *)v9))
    {
      free(v9);
      return 0;
    }
  }
  return v9;
}

void CONF_modules_free(void)
{
  CONF_modules_finish();
  CONF_modules_unload(1);
}

const char *__cdecl CONF_imodule_get_name(const CONF_IMODULE *md)
{
  return (const char *)*((_QWORD *)md + 1);
}

const char *__cdecl CONF_imodule_get_value(const CONF_IMODULE *md)
{
  return (const char *)*((_QWORD *)md + 2);
}

void *__cdecl CONF_imodule_get_usr_data(const CONF_IMODULE *md)
{
  return (void *)*((_QWORD *)md + 4);
}

void CONF_imodule_set_usr_data(CONF_IMODULE *md, void *usr_data)
{
  *((_QWORD *)md + 4) = usr_data;
}

CONF_MODULE *__cdecl CONF_imodule_get_module(const CONF_IMODULE *md)
{
  return *(CONF_MODULE **)md;
}

unint64_t CONF_imodule_get_flags(const CONF_IMODULE *md)
{
  return *((_QWORD *)md + 3);
}

void CONF_imodule_set_flags(CONF_IMODULE *md, unint64_t flags)
{
  *((_QWORD *)md + 3) = flags;
}

void *__cdecl CONF_module_get_usr_data(CONF_MODULE *pmod)
{
  return (void *)*((_QWORD *)pmod + 5);
}

void CONF_module_set_usr_data(CONF_MODULE *pmod, void *usr_data)
{
  *((_QWORD *)pmod + 5) = usr_data;
}

int CONF_parse_list(const char *list, int sep, int nospc, int (__cdecl *list_cb)(const char *, int, void *), void *arg)
{
  char *v9;
  uint64_t v10;
  unsigned int v11;
  unsigned int v12;
  char *v13;
  char *v14;
  char *v15;
  uint64_t v16;
  int v17;
  char *v18;
  uint64_t v19;
  int result;

  if (list)
  {
    v9 = (char *)list;
    v10 = MEMORY[0x24BDAC740];
    while (1)
    {
      if (nospc)
      {
        v11 = *v9;
        if (*v9)
        {
          do
          {
            if ((v11 & 0x80) != 0)
            {
              if (!__maskrune(v11, 0x4000uLL))
                break;
            }
            else if ((*(_DWORD *)(v10 + 4 * v11 + 60) & 0x4000) == 0)
            {
              break;
            }
            v12 = *++v9;
            v11 = v12;
          }
          while (v12);
        }
      }
      v13 = strchr(v9, sep);
      v14 = v13;
      if (v13 != v9)
      {
        if (*v9)
          break;
      }
      v18 = 0;
      v19 = 0;
LABEL_23:
      result = ((uint64_t (*)(char *, uint64_t, void *))list_cb)(v18, v19, arg);
      if (result < 1)
        return result;
      v9 = v14 + 1;
      if (!v14)
        return 1;
    }
    v15 = v13;
    if (v13)
    {
      if (nospc)
        goto LABEL_14;
    }
    else
    {
      v15 = &v9[strlen(v9)];
      if (nospc)
      {
        do
        {
LABEL_14:
          v16 = *(v15 - 1);
          if (*(v15 - 1) < 0)
            v17 = __maskrune(v16, 0x4000uLL);
          else
            v17 = *(_DWORD *)(v10 + 4 * v16 + 60) & 0x4000;
          --v15;
        }
        while (v17);
        goto LABEL_22;
      }
    }
    LODWORD(v15) = (_DWORD)v15 - 1;
LABEL_22:
    v19 = ((_DWORD)v15 - (_DWORD)v9 + 1);
    v18 = v9;
    goto LABEL_23;
  }
  ERR_put_error(14, 4095, 115, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/conf/conf_mod.c", 568);
  return 0;
}

EVP_CIPHER_CTX *pkey_cmac_init(uint64_t a1)
{
  EVP_CIPHER_CTX *result;

  result = CMAC_CTX_new();
  *(_QWORD *)(a1 + 40) = result;
  if (result)
  {
    *(_DWORD *)(a1 + 72) = 0;
    return (EVP_CIPHER_CTX *)1;
  }
  return result;
}

EVP_CIPHER_CTX *pkey_cmac_copy(uint64_t a1, uint64_t a2)
{
  EVP_CIPHER_CTX *result;

  result = CMAC_CTX_new();
  *(_QWORD *)(a1 + 40) = result;
  if (result)
  {
    *(_DWORD *)(a1 + 72) = 0;
    return (EVP_CIPHER_CTX *)(CMAC_CTX_copy(result, *(EVP_CIPHER_CTX **)(a2 + 40)) != 0);
  }
  return result;
}

void pkey_cmac_cleanup(uint64_t a1)
{
  CMAC_CTX_free(*(EVP_CIPHER_CTX **)(a1 + 40));
}

EVP_CIPHER_CTX *pkey_cmac_keygen(uint64_t a1, EVP_PKEY *a2)
{
  EVP_CIPHER_CTX *result;
  char *v5;

  result = CMAC_CTX_new();
  if (result)
  {
    v5 = (char *)result;
    if (CMAC_CTX_copy(result, *(EVP_CIPHER_CTX **)(a1 + 40)))
    {
      EVP_PKEY_assign(a2, 894, v5);
      return (EVP_CIPHER_CTX *)1;
    }
    else
    {
      CMAC_CTX_free((EVP_CIPHER_CTX *)v5);
      return 0;
    }
  }
  return result;
}

uint64_t cmac_signctx_init(int a1, EVP_MD_CTX *ctx)
{
  EVP_MD_CTX_set_flags(ctx, 256);
  ctx[1].engine = (ENGINE *)int_update;
  return 1;
}

uint64_t cmac_signctx(uint64_t a1, unsigned __int8 *a2, size_t *a3)
{
  return CMAC_Final(*(EVP_CIPHER_CTX **)(a1 + 40), a2, a3);
}

uint64_t pkey_cmac_ctrl(uint64_t a1, int a2, uint64_t a3, EVP_CIPHER *a4)
{
  EVP_CIPHER_CTX *v4;
  uint64_t result;
  EVP_CIPHER_CTX *v6;
  const unsigned __int8 *v7;
  uint64_t v8;
  ENGINE *v9;

  v4 = *(EVP_CIPHER_CTX **)(a1 + 40);
  switch(a2)
  {
    case 1:
      v8 = *(_QWORD *)(a1 + 16);
      if (!v8 || (result = CMAC_CTX_copy(*(EVP_CIPHER_CTX **)(a1 + 40), *(EVP_CIPHER_CTX **)(v8 + 32)), (_DWORD)result))
      {
        v6 = v4;
        v7 = 0;
        a3 = 0;
        goto LABEL_10;
      }
      break;
    case 12:
      v9 = *(ENGINE **)(a1 + 8);
      v6 = *(EVP_CIPHER_CTX **)(a1 + 40);
      v7 = 0;
      a3 = 0;
LABEL_12:
      result = (uint64_t)CMAC_Init(v6, v7, a3, a4, v9);
      if ((_DWORD)result)
        return 1;
      return result;
    case 6:
      result = 0;
      if ((a3 & 0x80000000) == 0 && a4)
      {
        a3 = a3;
        v6 = v4;
        v7 = (const unsigned __int8 *)a4;
LABEL_10:
        a4 = 0;
        v9 = 0;
        goto LABEL_12;
      }
      break;
    default:
      return 4294967294;
  }
  return result;
}

uint64_t pkey_cmac_ctrl_str(uint64_t a1, char *__s1, char *a3)
{
  _BOOL8 v6;
  unsigned int v7;
  uint64_t v8;
  EVP_CIPHER_CTX *v9;
  const unsigned __int8 *v10;
  EVP_CIPHER *v11;
  ENGINE *v12;
  const EVP_CIPHER *cipherbyname;
  unsigned __int8 *v14;
  unsigned __int8 *v15;
  uint64_t len;

  if (!a3)
    return 0;
  if (!strcmp(__s1, "key"))
  {
    v7 = strlen(a3);
    if ((v7 & 0x80000000) != 0)
      return 0;
    v8 = v7;
    v9 = *(EVP_CIPHER_CTX **)(a1 + 40);
    v10 = (const unsigned __int8 *)a3;
    v11 = 0;
    v12 = 0;
    return CMAC_Init(v9, v10, v8, v11, v12) != 0;
  }
  if (!strcmp(__s1, "cipher"))
  {
    cipherbyname = EVP_get_cipherbyname(a3);
    if (!cipherbyname)
      return 0;
    v11 = (EVP_CIPHER *)cipherbyname;
    v9 = *(EVP_CIPHER_CTX **)(a1 + 40);
    v12 = *(ENGINE **)(a1 + 8);
    v10 = 0;
    v8 = 0;
    return CMAC_Init(v9, v10, v8, v11, v12) != 0;
  }
  if (strcmp(__s1, "hexkey"))
    return 4294967294;
  len = 0;
  v14 = string_to_hex(a3, &len);
  if (!v14)
    return 0;
  v15 = v14;
  v6 = (len & 0x80000000) == 0
    && CMAC_Init(*(EVP_CIPHER_CTX **)(a1 + 40), v14, len, 0, 0) != 0;
  free(v15);
  return v6;
}

BOOL int_update(uint64_t a1, char *a2, size_t a3)
{
  return CMAC_Update(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 40), a2, a3) != 0;
}

const ECDH_METHOD *ECDH_OpenSSL(void)
{
  return (const ECDH_METHOD *)&openssl_ecdh_meth;
}

_QWORD *ossl_ecdh_compute_key(uint64_t a1, uint64_t a2, uint64_t a3, EC_KEY *a4, uint64_t a5)
{
  _QWORD *result;

  result = ecdh_check(a4);
  if (result)
    return (_QWORD *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t, EC_KEY *, uint64_t))(result[3] + 8))(a1, a2, a3, a4, a5);
  return result;
}

int ECDH_compute_key(void *out, size_t outlen, const EC_POINT *pub_key, EC_KEY *ecdh, void *(__cdecl *KDF)(const void *, size_t, void *, size_t *))
{
  uint64_t (*v5)(void *, size_t, const EC_POINT *);

  v5 = *(uint64_t (**)(void *, size_t, const EC_POINT *))(*(_QWORD *)ecdh + 72);
  if (v5)
    return v5(out, outlen, pub_key);
  ERR_put_error(16, 4095, 126, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ecdh/ech_key.c", 227);
  return 0;
}

uint64_t ecdh_compute_key(char *a1, size_t a2, const EC_POINT *a3, const EC_KEY *a4, uint64_t (*a5)(char *, unint64_t, char *, size_t *))
{
  size_t v5;
  BN_CTX *v10;
  BN_CTX *v11;
  BIGNUM *v12;
  const BIGNUM *v13;
  uint64_t v14;
  const BIGNUM *v15;
  const BIGNUM *v16;
  const EC_GROUP *v17;
  EC_POINT *v18;
  signed int v19;
  int v20;
  int v21;
  int v22;
  int v23;
  char *v24;
  int v25;
  int v26;
  unint64_t v28;
  char *v29;
  uint64_t v30;
  int v31;
  int v32;
  BIGNUM *v33;
  size_t v34;

  v34 = a2;
  if (!(a2 >> 31))
  {
    v5 = a2;
    v10 = BN_CTX_new();
    v11 = v10;
    if (!v10)
    {
      EC_POINT_free(0);
      v24 = 0;
      v5 = 0xFFFFFFFFLL;
LABEL_23:
      BN_CTX_free(v11);
      free(v24);
      return v5;
    }
    BN_CTX_start(v10);
    v12 = BN_CTX_get(v11);
    if (!v12)
      goto LABEL_21;
    v13 = v12;
    v12 = BN_CTX_get(v11);
    if (!v12)
      goto LABEL_21;
    v14 = (uint64_t)v12;
    v15 = EC_KEY_get0_private_key(a4);
    if (v15)
    {
      v16 = v15;
      v17 = EC_KEY_get0_group(a4);
      if (!EC_POINT_is_on_curve(v17, a3, v11))
      {
LABEL_20:
        v12 = 0;
LABEL_21:
        v24 = 0;
        v5 = 0xFFFFFFFFLL;
        goto LABEL_22;
      }
      v18 = EC_POINT_new(v17);
      if (v18)
      {
        v33 = (BIGNUM *)v18;
        if (EC_POINT_mul(v17, v18, 0, a3, v16, v11))
        {
          if (EC_POINT_get_affine_coordinates((uint64_t)v17, v33, (uint64_t)v13, v14, v11))
          {
            v19 = ECDH_size(a4);
            v20 = BN_num_bits(v13);
            if (v20 >= -7)
              v21 = v20 + 7;
            else
              v21 = v20 + 14;
            if (v21 >> 3 <= v19)
            {
              v28 = v19;
              if (a5 || v5 >= v19)
              {
                v29 = (char *)malloc_type_malloc(v19, 0xCB43A3A3uLL);
                v24 = v29;
                if (v29)
                {
                  v30 = (uint64_t)v21 >> 3;
                  bzero(v29, v28 - v30);
                  if ((_DWORD)v30 == BN_bn2bin(v13, (unsigned __int8 *)&v24[v28 - v30]))
                  {
                    if (!a5)
                    {
                      if (v5 > v28)
                      {
                        bzero(&a1[v28], v5 - v28);
                        v34 = v28;
                        v5 = v28;
                      }
                      memcpy(a1, v24, v5);
                      goto LABEL_32;
                    }
                    if (a5(v24, v28, a1, &v34))
                    {
                      v5 = v34;
                      goto LABEL_32;
                    }
                    v31 = 102;
                    v32 = 173;
                  }
                  else
                  {
                    v31 = 3;
                    v32 = 167;
                  }
                }
                else
                {
                  v31 = 65;
                  v32 = 161;
                }
                ERR_put_error(43, 4095, v31, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ecdh/ech_key.c", v32);
LABEL_31:
                v5 = 0xFFFFFFFFLL;
LABEL_32:
                v12 = v33;
                goto LABEL_22;
              }
              v22 = 104;
              v23 = 157;
            }
            else
            {
              v22 = 68;
              v23 = 152;
            }
          }
          else
          {
            v22 = 101;
            v23 = 145;
          }
          ERR_put_error(43, 4095, v22, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ecdh/ech_key.c", v23);
          v24 = 0;
          goto LABEL_31;
        }
        ERR_put_error(43, 4095, 101, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ecdh/ech_key.c", 140);
        v24 = 0;
        v5 = 0xFFFFFFFFLL;
        v12 = v33;
LABEL_22:
        EC_POINT_free((EC_POINT *)v12);
        BN_CTX_end(v11);
        goto LABEL_23;
      }
      v25 = 65;
      v26 = 135;
    }
    else
    {
      v25 = 100;
      v26 = 125;
    }
    ERR_put_error(43, 4095, v25, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ecdh/ech_key.c", v26);
    goto LABEL_20;
  }
  ERR_put_error(43, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ecdh/ech_key.c", 111);
  return 0xFFFFFFFFLL;
}

void DES_encrypt1(unsigned int *data, DES_key_schedule *ks, int enc)
{
  unsigned int v3;
  unsigned int v4;
  unsigned int v5;
  int v6;
  int v7;
  unsigned int v8;
  int v9;
  int v10;
  unsigned int v11;
  int v12;
  int v13;
  unsigned int v14;
  int v15;
  int v16;
  int v17;
  unint64_t v18;
  int v19;
  unsigned int v20;
  unsigned int v21;
  unint64_t v22;
  int v23;
  unsigned int v24;
  unsigned int v25;
  int v26;
  unsigned int v27;
  unsigned int v28;
  int v29;
  unsigned int v30;
  unsigned int v31;
  int v32;
  unsigned int v33;
  unsigned int v34;
  int v35;
  unsigned int v36;
  unsigned int v37;
  int v38;
  unsigned int v39;
  unsigned int v40;
  int v41;
  unsigned int v42;
  unsigned int v43;
  int v44;
  unsigned int v45;
  unsigned int v46;
  int v47;
  unsigned int v48;
  unsigned int v49;
  int v50;
  unsigned int v51;
  unsigned int v52;
  int v53;
  unsigned int v54;
  unsigned int v55;
  int v56;
  unsigned int v57;
  unsigned int v58;
  int v59;
  unsigned int v60;
  unsigned int v61;
  int v62;
  unsigned int v63;
  int v64;
  unsigned int v65;
  unsigned int v66;
  unsigned int v67;
  unsigned int v68;
  unint64_t v69;
  int v70;
  unsigned int v71;
  unsigned int v72;
  int v73;
  unsigned int v74;
  unsigned int v75;
  int v76;
  unsigned int v77;
  unsigned int v78;
  int v79;
  unsigned int v80;
  unsigned int v81;
  int v82;
  unsigned int v83;
  unsigned int v84;
  int v85;
  unsigned int v86;
  unsigned int v87;
  int v88;
  unsigned int v89;
  unsigned int v90;
  int v91;
  unsigned int v92;
  unsigned int v93;
  int v94;
  unsigned int v95;
  unsigned int v96;
  int v97;
  unsigned int v98;
  unsigned int v99;
  int v100;
  unsigned int v101;
  unsigned int v102;
  int v103;
  unsigned int v104;
  unsigned int v105;
  int v106;
  unsigned int v107;
  unsigned int v108;
  unsigned int v109;
  unsigned int v110;
  unsigned int v111;
  unint64_t v112;
  unsigned int v113;
  unsigned int v114;
  int v115;
  int v116;
  unsigned int v117;
  int v118;
  int v119;
  unsigned int v120;
  int v121;
  int v122;
  unsigned int v123;
  int v124;
  int v125;

  v3 = data[1];
  v4 = (*data ^ (v3 >> 4)) & 0xF0F0F0F;
  v5 = v4 ^ *data;
  v6 = v3 ^ (16 * v4);
  v7 = (unsigned __int16)v6 ^ HIWORD(v5);
  v8 = v7 ^ v6;
  v9 = v5 ^ (v7 << 16);
  v10 = (v9 ^ (v8 >> 2)) & 0x33333333;
  v11 = v10 ^ v9;
  v12 = v8 ^ (4 * v10);
  v13 = (v12 ^ (v11 >> 8)) & 0xFF00FF;
  v14 = v13 ^ v12;
  v15 = v11 ^ (v13 << 8);
  v16 = (v15 ^ (v14 >> 1)) & 0x55555555;
  HIDWORD(v18) = v16 ^ v15;
  LODWORD(v18) = v16 ^ v15;
  v17 = v18 >> 29;
  HIDWORD(v18) = v14 ^ (2 * v16);
  LODWORD(v18) = HIDWORD(v18);
  v19 = v18 >> 29;
  if (enc)
  {
    v20 = ks->ks[0].deslong[0] ^ v17;
    HIDWORD(v22) = ks->ks[0].deslong[1] ^ v17;
    LODWORD(v22) = HIDWORD(v22);
    v21 = v22 >> 4;
    v23 = DES_SPtrans[v20 >> 2] ^ DES_SPtrans[((unsigned __int16)v20 >> 10) + 128] ^ DES_SPtrans[((v20 >> 18) & 0x3F) + 256] ^ DES_SPtrans[(v20 >> 26) + 384] ^ DES_SPtrans[(v21 >> 2) + 64] ^ DES_SPtrans[((unsigned __int16)v21 >> 10) + 192] ^ DES_SPtrans[((v21 >> 18) & 0x3F) + 320] ^ DES_SPtrans[(v21 >> 26) + 448] ^ v19;
    v24 = v23 ^ ks->ks[1].deslong[0];
    HIDWORD(v22) = v23 ^ ks->ks[1].deslong[1];
    LODWORD(v22) = HIDWORD(v22);
    v25 = v22 >> 4;
    v26 = DES_SPtrans[v24 >> 2] ^ DES_SPtrans[((unsigned __int16)v24 >> 10) + 128] ^ DES_SPtrans[((v24 >> 18) & 0x3F) + 256] ^ DES_SPtrans[(v24 >> 26) + 384] ^ DES_SPtrans[(v25 >> 2) + 64] ^ DES_SPtrans[((unsigned __int16)v25 >> 10) + 192] ^ DES_SPtrans[((v25 >> 18) & 0x3F) + 320] ^ DES_SPtrans[(v25 >> 26) + 448] ^ v17;
    v27 = v26 ^ ks->ks[2].deslong[0];
    HIDWORD(v22) = v26 ^ ks->ks[2].deslong[1];
    LODWORD(v22) = HIDWORD(v22);
    v28 = v22 >> 4;
    v29 = DES_SPtrans[v27 >> 2] ^ DES_SPtrans[((unsigned __int16)v27 >> 10) + 128] ^ DES_SPtrans[((v27 >> 18) & 0x3F) + 256] ^ DES_SPtrans[(v27 >> 26) + 384] ^ DES_SPtrans[(v28 >> 2) + 64] ^ DES_SPtrans[((unsigned __int16)v28 >> 10) + 192] ^ DES_SPtrans[((v28 >> 18) & 0x3F) + 320] ^ DES_SPtrans[(v28 >> 26) + 448] ^ v23;
    v30 = v29 ^ ks->ks[3].deslong[0];
    HIDWORD(v22) = v29 ^ ks->ks[3].deslong[1];
    LODWORD(v22) = HIDWORD(v22);
    v31 = v22 >> 4;
    v32 = DES_SPtrans[v30 >> 2] ^ DES_SPtrans[((unsigned __int16)v30 >> 10) + 128] ^ DES_SPtrans[((v30 >> 18) & 0x3F) + 256] ^ DES_SPtrans[(v30 >> 26) + 384] ^ DES_SPtrans[(v31 >> 2) + 64] ^ DES_SPtrans[((unsigned __int16)v31 >> 10) + 192] ^ DES_SPtrans[((v31 >> 18) & 0x3F) + 320] ^ DES_SPtrans[(v31 >> 26) + 448] ^ v26;
    v33 = v32 ^ ks->ks[4].deslong[0];
    HIDWORD(v22) = v32 ^ ks->ks[4].deslong[1];
    LODWORD(v22) = HIDWORD(v22);
    v34 = v22 >> 4;
    v35 = DES_SPtrans[v33 >> 2] ^ DES_SPtrans[((unsigned __int16)v33 >> 10) + 128] ^ DES_SPtrans[((v33 >> 18) & 0x3F) + 256] ^ DES_SPtrans[(v33 >> 26) + 384] ^ DES_SPtrans[(v34 >> 2) + 64] ^ DES_SPtrans[((unsigned __int16)v34 >> 10) + 192] ^ DES_SPtrans[((v34 >> 18) & 0x3F) + 320] ^ DES_SPtrans[(v34 >> 26) + 448] ^ v29;
    v36 = v35 ^ ks->ks[5].deslong[0];
    HIDWORD(v22) = v35 ^ ks->ks[5].deslong[1];
    LODWORD(v22) = HIDWORD(v22);
    v37 = v22 >> 4;
    v38 = DES_SPtrans[v36 >> 2] ^ DES_SPtrans[((unsigned __int16)v36 >> 10) + 128] ^ DES_SPtrans[((v36 >> 18) & 0x3F) + 256] ^ DES_SPtrans[(v36 >> 26) + 384] ^ DES_SPtrans[(v37 >> 2) + 64] ^ DES_SPtrans[((unsigned __int16)v37 >> 10) + 192] ^ DES_SPtrans[((v37 >> 18) & 0x3F) + 320] ^ DES_SPtrans[(v37 >> 26) + 448] ^ v32;
    v39 = v38 ^ ks->ks[6].deslong[0];
    HIDWORD(v22) = v38 ^ ks->ks[6].deslong[1];
    LODWORD(v22) = HIDWORD(v22);
    v40 = v22 >> 4;
    v41 = DES_SPtrans[v39 >> 2] ^ DES_SPtrans[((unsigned __int16)v39 >> 10) + 128] ^ DES_SPtrans[((v39 >> 18) & 0x3F) + 256] ^ DES_SPtrans[(v39 >> 26) + 384] ^ DES_SPtrans[(v40 >> 2) + 64] ^ DES_SPtrans[((unsigned __int16)v40 >> 10) + 192] ^ DES_SPtrans[((v40 >> 18) & 0x3F) + 320] ^ DES_SPtrans[(v40 >> 26) + 448] ^ v35;
    v42 = v41 ^ ks->ks[7].deslong[0];
    HIDWORD(v22) = v41 ^ ks->ks[7].deslong[1];
    LODWORD(v22) = HIDWORD(v22);
    v43 = v22 >> 4;
    v44 = DES_SPtrans[v42 >> 2] ^ DES_SPtrans[((unsigned __int16)v42 >> 10) + 128] ^ DES_SPtrans[((v42 >> 18) & 0x3F) + 256] ^ DES_SPtrans[(v42 >> 26) + 384] ^ DES_SPtrans[(v43 >> 2) + 64] ^ DES_SPtrans[((unsigned __int16)v43 >> 10) + 192] ^ DES_SPtrans[((v43 >> 18) & 0x3F) + 320] ^ DES_SPtrans[(v43 >> 26) + 448] ^ v38;
    v45 = v44 ^ ks->ks[8].deslong[0];
    HIDWORD(v22) = v44 ^ ks->ks[8].deslong[1];
    LODWORD(v22) = HIDWORD(v22);
    v46 = v22 >> 4;
    v47 = DES_SPtrans[v45 >> 2] ^ DES_SPtrans[((unsigned __int16)v45 >> 10) + 128] ^ DES_SPtrans[((v45 >> 18) & 0x3F) + 256] ^ DES_SPtrans[(v45 >> 26) + 384] ^ DES_SPtrans[(v46 >> 2) + 64] ^ DES_SPtrans[((unsigned __int16)v46 >> 10) + 192] ^ DES_SPtrans[((v46 >> 18) & 0x3F) + 320] ^ DES_SPtrans[(v46 >> 26) + 448] ^ v41;
    v48 = v47 ^ ks->ks[9].deslong[0];
    HIDWORD(v22) = v47 ^ ks->ks[9].deslong[1];
    LODWORD(v22) = HIDWORD(v22);
    v49 = v22 >> 4;
    v50 = DES_SPtrans[v48 >> 2] ^ DES_SPtrans[((unsigned __int16)v48 >> 10) + 128] ^ DES_SPtrans[((v48 >> 18) & 0x3F) + 256] ^ DES_SPtrans[(v48 >> 26) + 384] ^ DES_SPtrans[(v49 >> 2) + 64] ^ DES_SPtrans[((unsigned __int16)v49 >> 10) + 192] ^ DES_SPtrans[((v49 >> 18) & 0x3F) + 320] ^ DES_SPtrans[(v49 >> 26) + 448] ^ v44;
    v51 = v50 ^ ks->ks[10].deslong[0];
    HIDWORD(v22) = v50 ^ ks->ks[10].deslong[1];
    LODWORD(v22) = HIDWORD(v22);
    v52 = v22 >> 4;
    v53 = DES_SPtrans[v51 >> 2] ^ DES_SPtrans[((unsigned __int16)v51 >> 10) + 128] ^ DES_SPtrans[((v51 >> 18) & 0x3F) + 256] ^ DES_SPtrans[(v51 >> 26) + 384] ^ DES_SPtrans[(v52 >> 2) + 64] ^ DES_SPtrans[((unsigned __int16)v52 >> 10) + 192] ^ DES_SPtrans[((v52 >> 18) & 0x3F) + 320] ^ DES_SPtrans[(v52 >> 26) + 448] ^ v47;
    v54 = v53 ^ ks->ks[11].deslong[0];
    HIDWORD(v22) = v53 ^ ks->ks[11].deslong[1];
    LODWORD(v22) = HIDWORD(v22);
    v55 = v22 >> 4;
    v56 = DES_SPtrans[v54 >> 2] ^ DES_SPtrans[((unsigned __int16)v54 >> 10) + 128] ^ DES_SPtrans[((v54 >> 18) & 0x3F) + 256] ^ DES_SPtrans[(v54 >> 26) + 384] ^ DES_SPtrans[(v55 >> 2) + 64] ^ DES_SPtrans[((unsigned __int16)v55 >> 10) + 192] ^ DES_SPtrans[((v55 >> 18) & 0x3F) + 320] ^ DES_SPtrans[(v55 >> 26) + 448] ^ v50;
    v57 = v56 ^ ks->ks[12].deslong[0];
    HIDWORD(v22) = v56 ^ ks->ks[12].deslong[1];
    LODWORD(v22) = HIDWORD(v22);
    v58 = v22 >> 4;
    v59 = DES_SPtrans[v57 >> 2] ^ DES_SPtrans[((unsigned __int16)v57 >> 10) + 128] ^ DES_SPtrans[((v57 >> 18) & 0x3F) + 256] ^ DES_SPtrans[(v57 >> 26) + 384] ^ DES_SPtrans[(v58 >> 2) + 64] ^ DES_SPtrans[((unsigned __int16)v58 >> 10) + 192] ^ DES_SPtrans[((v58 >> 18) & 0x3F) + 320] ^ DES_SPtrans[(v58 >> 26) + 448] ^ v53;
    v60 = v59 ^ ks->ks[13].deslong[0];
    HIDWORD(v22) = v59 ^ ks->ks[13].deslong[1];
    LODWORD(v22) = HIDWORD(v22);
    v61 = v22 >> 4;
    v62 = DES_SPtrans[v60 >> 2] ^ DES_SPtrans[((unsigned __int16)v60 >> 10) + 128] ^ DES_SPtrans[((v60 >> 18) & 0x3F) + 256] ^ DES_SPtrans[(v60 >> 26) + 384] ^ DES_SPtrans[(v61 >> 2) + 64] ^ DES_SPtrans[((unsigned __int16)v61 >> 10) + 192] ^ DES_SPtrans[((v61 >> 18) & 0x3F) + 320] ^ DES_SPtrans[(v61 >> 26) + 448] ^ v56;
    v63 = v62 ^ ks->ks[14].deslong[0];
    HIDWORD(v22) = v62 ^ ks->ks[14].deslong[1];
    LODWORD(v22) = HIDWORD(v22);
    v64 = DES_SPtrans[v63 >> 2] ^ DES_SPtrans[((unsigned __int16)v63 >> 10) + 128] ^ DES_SPtrans[((v63 >> 18) & 0x3F) + 256] ^ DES_SPtrans[(v63 >> 26) + 384] ^ DES_SPtrans[((v22 >> 4) >> 2) + 64] ^ DES_SPtrans[((unsigned __int16)(v22 >> 4) >> 10) + 192] ^ DES_SPtrans[(((v22 >> 4) >> 18) & 0x3F) + 320] ^ DES_SPtrans[((v22 >> 4) >> 26) + 448] ^ v59;
    v65 = ks->ks[15].deslong[0];
    v66 = ks->ks[15].deslong[1];
  }
  else
  {
    v67 = ks->ks[15].deslong[0] ^ v17;
    HIDWORD(v69) = ks->ks[15].deslong[1] ^ v17;
    LODWORD(v69) = HIDWORD(v69);
    v68 = v69 >> 4;
    v70 = DES_SPtrans[v67 >> 2] ^ DES_SPtrans[((unsigned __int16)v67 >> 10) + 128] ^ DES_SPtrans[((v67 >> 18) & 0x3F) + 256] ^ DES_SPtrans[(v67 >> 26) + 384] ^ DES_SPtrans[(v68 >> 2) + 64] ^ DES_SPtrans[((unsigned __int16)v68 >> 10) + 192] ^ DES_SPtrans[((v68 >> 18) & 0x3F) + 320] ^ DES_SPtrans[(v68 >> 26) + 448] ^ v19;
    v71 = v70 ^ ks->ks[14].deslong[0];
    HIDWORD(v69) = v70 ^ ks->ks[14].deslong[1];
    LODWORD(v69) = HIDWORD(v69);
    v72 = v69 >> 4;
    v73 = DES_SPtrans[v71 >> 2] ^ DES_SPtrans[((unsigned __int16)v71 >> 10) + 128] ^ DES_SPtrans[((v71 >> 18) & 0x3F) + 256] ^ DES_SPtrans[(v71 >> 26) + 384] ^ DES_SPtrans[(v72 >> 2) + 64] ^ DES_SPtrans[((unsigned __int16)v72 >> 10) + 192] ^ DES_SPtrans[((v72 >> 18) & 0x3F) + 320] ^ DES_SPtrans[(v72 >> 26) + 448] ^ v17;
    v74 = v73 ^ ks->ks[13].deslong[0];
    HIDWORD(v69) = v73 ^ ks->ks[13].deslong[1];
    LODWORD(v69) = HIDWORD(v69);
    v75 = v69 >> 4;
    v76 = DES_SPtrans[v74 >> 2] ^ DES_SPtrans[((unsigned __int16)v74 >> 10) + 128] ^ DES_SPtrans[((v74 >> 18) & 0x3F) + 256] ^ DES_SPtrans[(v74 >> 26) + 384] ^ DES_SPtrans[(v75 >> 2) + 64] ^ DES_SPtrans[((unsigned __int16)v75 >> 10) + 192] ^ DES_SPtrans[((v75 >> 18) & 0x3F) + 320] ^ DES_SPtrans[(v75 >> 26) + 448] ^ v70;
    v77 = v76 ^ ks->ks[12].deslong[0];
    HIDWORD(v69) = v76 ^ ks->ks[12].deslong[1];
    LODWORD(v69) = HIDWORD(v69);
    v78 = v69 >> 4;
    v79 = DES_SPtrans[v77 >> 2] ^ DES_SPtrans[((unsigned __int16)v77 >> 10) + 128] ^ DES_SPtrans[((v77 >> 18) & 0x3F) + 256] ^ DES_SPtrans[(v77 >> 26) + 384] ^ DES_SPtrans[(v78 >> 2) + 64] ^ DES_SPtrans[((unsigned __int16)v78 >> 10) + 192] ^ DES_SPtrans[((v78 >> 18) & 0x3F) + 320] ^ DES_SPtrans[(v78 >> 26) + 448] ^ v73;
    v80 = v79 ^ ks->ks[11].deslong[0];
    HIDWORD(v69) = v79 ^ ks->ks[11].deslong[1];
    LODWORD(v69) = HIDWORD(v69);
    v81 = v69 >> 4;
    v82 = DES_SPtrans[v80 >> 2] ^ DES_SPtrans[((unsigned __int16)v80 >> 10) + 128] ^ DES_SPtrans[((v80 >> 18) & 0x3F) + 256] ^ DES_SPtrans[(v80 >> 26) + 384] ^ DES_SPtrans[(v81 >> 2) + 64] ^ DES_SPtrans[((unsigned __int16)v81 >> 10) + 192] ^ DES_SPtrans[((v81 >> 18) & 0x3F) + 320] ^ DES_SPtrans[(v81 >> 26) + 448] ^ v76;
    v83 = v82 ^ ks->ks[10].deslong[0];
    HIDWORD(v69) = v82 ^ ks->ks[10].deslong[1];
    LODWORD(v69) = HIDWORD(v69);
    v84 = v69 >> 4;
    v85 = DES_SPtrans[v83 >> 2] ^ DES_SPtrans[((unsigned __int16)v83 >> 10) + 128] ^ DES_SPtrans[((v83 >> 18) & 0x3F) + 256] ^ DES_SPtrans[(v83 >> 26) + 384] ^ DES_SPtrans[(v84 >> 2) + 64] ^ DES_SPtrans[((unsigned __int16)v84 >> 10) + 192] ^ DES_SPtrans[((v84 >> 18) & 0x3F) + 320] ^ DES_SPtrans[(v84 >> 26) + 448] ^ v79;
    v86 = v85 ^ ks->ks[9].deslong[0];
    HIDWORD(v69) = v85 ^ ks->ks[9].deslong[1];
    LODWORD(v69) = HIDWORD(v69);
    v87 = v69 >> 4;
    v88 = DES_SPtrans[v86 >> 2] ^ DES_SPtrans[((unsigned __int16)v86 >> 10) + 128] ^ DES_SPtrans[((v86 >> 18) & 0x3F) + 256] ^ DES_SPtrans[(v86 >> 26) + 384] ^ DES_SPtrans[(v87 >> 2) + 64] ^ DES_SPtrans[((unsigned __int16)v87 >> 10) + 192] ^ DES_SPtrans[((v87 >> 18) & 0x3F) + 320] ^ DES_SPtrans[(v87 >> 26) + 448] ^ v82;
    v89 = v88 ^ ks->ks[8].deslong[0];
    HIDWORD(v69) = v88 ^ ks->ks[8].deslong[1];
    LODWORD(v69) = HIDWORD(v69);
    v90 = v69 >> 4;
    v91 = DES_SPtrans[v89 >> 2] ^ DES_SPtrans[((unsigned __int16)v89 >> 10) + 128] ^ DES_SPtrans[((v89 >> 18) & 0x3F) + 256] ^ DES_SPtrans[(v89 >> 26) + 384] ^ DES_SPtrans[(v90 >> 2) + 64] ^ DES_SPtrans[((unsigned __int16)v90 >> 10) + 192] ^ DES_SPtrans[((v90 >> 18) & 0x3F) + 320] ^ DES_SPtrans[(v90 >> 26) + 448] ^ v85;
    v92 = v91 ^ ks->ks[7].deslong[0];
    HIDWORD(v69) = v91 ^ ks->ks[7].deslong[1];
    LODWORD(v69) = HIDWORD(v69);
    v93 = v69 >> 4;
    v94 = DES_SPtrans[v92 >> 2] ^ DES_SPtrans[((unsigned __int16)v92 >> 10) + 128] ^ DES_SPtrans[((v92 >> 18) & 0x3F) + 256] ^ DES_SPtrans[(v92 >> 26) + 384] ^ DES_SPtrans[(v93 >> 2) + 64] ^ DES_SPtrans[((unsigned __int16)v93 >> 10) + 192] ^ DES_SPtrans[((v93 >> 18) & 0x3F) + 320] ^ DES_SPtrans[(v93 >> 26) + 448] ^ v88;
    v95 = v94 ^ ks->ks[6].deslong[0];
    HIDWORD(v69) = v94 ^ ks->ks[6].deslong[1];
    LODWORD(v69) = HIDWORD(v69);
    v96 = v69 >> 4;
    v97 = DES_SPtrans[v95 >> 2] ^ DES_SPtrans[((unsigned __int16)v95 >> 10) + 128] ^ DES_SPtrans[((v95 >> 18) & 0x3F) + 256] ^ DES_SPtrans[(v95 >> 26) + 384] ^ DES_SPtrans[(v96 >> 2) + 64] ^ DES_SPtrans[((unsigned __int16)v96 >> 10) + 192] ^ DES_SPtrans[((v96 >> 18) & 0x3F) + 320] ^ DES_SPtrans[(v96 >> 26) + 448] ^ v91;
    v98 = v97 ^ ks->ks[5].deslong[0];
    HIDWORD(v69) = v97 ^ ks->ks[5].deslong[1];
    LODWORD(v69) = HIDWORD(v69);
    v99 = v69 >> 4;
    v100 = DES_SPtrans[v98 >> 2] ^ DES_SPtrans[((unsigned __int16)v98 >> 10) + 128] ^ DES_SPtrans[((v98 >> 18) & 0x3F) + 256] ^ DES_SPtrans[(v98 >> 26) + 384] ^ DES_SPtrans[(v99 >> 2) + 64] ^ DES_SPtrans[((unsigned __int16)v99 >> 10) + 192] ^ DES_SPtrans[((v99 >> 18) & 0x3F) + 320] ^ DES_SPtrans[(v99 >> 26) + 448] ^ v94;
    v101 = v100 ^ ks->ks[4].deslong[0];
    HIDWORD(v69) = v100 ^ ks->ks[4].deslong[1];
    LODWORD(v69) = HIDWORD(v69);
    v102 = v69 >> 4;
    v103 = DES_SPtrans[v101 >> 2] ^ DES_SPtrans[((unsigned __int16)v101 >> 10) + 128] ^ DES_SPtrans[((v101 >> 18) & 0x3F) + 256] ^ DES_SPtrans[(v101 >> 26) + 384] ^ DES_SPtrans[(v102 >> 2) + 64] ^ DES_SPtrans[((unsigned __int16)v102 >> 10) + 192] ^ DES_SPtrans[((v102 >> 18) & 0x3F) + 320] ^ DES_SPtrans[(v102 >> 26) + 448] ^ v97;
    v104 = v103 ^ ks->ks[3].deslong[0];
    HIDWORD(v69) = v103 ^ ks->ks[3].deslong[1];
    LODWORD(v69) = HIDWORD(v69);
    v105 = v69 >> 4;
    v106 = DES_SPtrans[v104 >> 2] ^ DES_SPtrans[((unsigned __int16)v104 >> 10) + 128] ^ DES_SPtrans[((v104 >> 18) & 0x3F) + 256] ^ DES_SPtrans[(v104 >> 26) + 384] ^ DES_SPtrans[(v105 >> 2) + 64] ^ DES_SPtrans[((unsigned __int16)v105 >> 10) + 192] ^ DES_SPtrans[((v105 >> 18) & 0x3F) + 320] ^ DES_SPtrans[(v105 >> 26) + 448] ^ v100;
    v107 = v106 ^ ks->ks[2].deslong[0];
    HIDWORD(v69) = v106 ^ ks->ks[2].deslong[1];
    LODWORD(v69) = HIDWORD(v69);
    v108 = v69 >> 4;
    v62 = DES_SPtrans[v107 >> 2] ^ DES_SPtrans[((unsigned __int16)v107 >> 10) + 128] ^ DES_SPtrans[((v107 >> 18) & 0x3F) + 256] ^ DES_SPtrans[(v107 >> 26) + 384] ^ DES_SPtrans[(v108 >> 2) + 64] ^ DES_SPtrans[((unsigned __int16)v108 >> 10) + 192] ^ DES_SPtrans[((v108 >> 18) & 0x3F) + 320] ^ DES_SPtrans[(v108 >> 26) + 448] ^ v103;
    v109 = v62 ^ ks->ks[1].deslong[0];
    HIDWORD(v69) = v62 ^ ks->ks[1].deslong[1];
    LODWORD(v69) = HIDWORD(v69);
    v64 = DES_SPtrans[v109 >> 2] ^ DES_SPtrans[((unsigned __int16)v109 >> 10) + 128] ^ DES_SPtrans[((v109 >> 18) & 0x3F) + 256] ^ DES_SPtrans[(v109 >> 26) + 384] ^ DES_SPtrans[((v69 >> 4) >> 2) + 64] ^ DES_SPtrans[((unsigned __int16)(v69 >> 4) >> 10) + 192] ^ DES_SPtrans[(((v69 >> 4) >> 18) & 0x3F) + 320] ^ DES_SPtrans[((v69 >> 4) >> 26) + 448] ^ v106;
    v65 = ks->ks[0].deslong[0];
    v66 = ks->ks[0].deslong[1];
  }
  v110 = v64 ^ v65;
  HIDWORD(v112) = v64 ^ v66;
  LODWORD(v112) = v64 ^ v66;
  v111 = v112 >> 4;
  HIDWORD(v112) = DES_SPtrans[v110 >> 2] ^ DES_SPtrans[((unsigned __int16)v110 >> 10) + 128] ^ DES_SPtrans[((v110 >> 18) & 0x3F) + 256] ^ DES_SPtrans[(v110 >> 26) + 384] ^ DES_SPtrans[(v111 >> 2) + 64] ^ DES_SPtrans[((unsigned __int16)v111 >> 10) + 192] ^ DES_SPtrans[((v111 >> 18) & 0x3F) + 320] ^ DES_SPtrans[(v111 >> 26) + 448] ^ v62;
  LODWORD(v112) = HIDWORD(v112);
  v113 = (((v112 >> 3) >> 1) ^ __ROR4__(v64, 3)) & 0x55555555;
  v114 = v113 ^ __ROR4__(v64, 3);
  v115 = (2 * v113) ^ __ROR4__(HIDWORD(v112), 3);
  v116 = (v115 ^ (v114 >> 8)) & 0xFF00FF;
  v117 = v116 ^ v115;
  v118 = v114 ^ (v116 << 8);
  v119 = (v118 ^ (v117 >> 2)) & 0x33333333;
  v120 = v119 ^ v118;
  v121 = v117 ^ (4 * v119);
  v122 = (unsigned __int16)v121 ^ HIWORD(v120);
  v123 = v122 ^ v121;
  v124 = v120 ^ (v122 << 16);
  v125 = (v124 ^ (v123 >> 4)) & 0xF0F0F0F;
  *data = v125 ^ v124;
  data[1] = v123 ^ (16 * v125);
}

void DES_encrypt2(unsigned int *data, DES_key_schedule *ks, int enc)
{
  int v3;
  unint64_t v4;
  int v5;
  unsigned int v6;
  unsigned int v7;
  unint64_t v8;
  int v9;
  unsigned int v10;
  unsigned int v11;
  int v12;
  unsigned int v13;
  unsigned int v14;
  int v15;
  unsigned int v16;
  unsigned int v17;
  int v18;
  unsigned int v19;
  unsigned int v20;
  int v21;
  unsigned int v22;
  unsigned int v23;
  int v24;
  unsigned int v25;
  unsigned int v26;
  int v27;
  unsigned int v28;
  unsigned int v29;
  int v30;
  unsigned int v31;
  unsigned int v32;
  int v33;
  unsigned int v34;
  unsigned int v35;
  int v36;
  unsigned int v37;
  unsigned int v38;
  int v39;
  unsigned int v40;
  unsigned int v41;
  int v42;
  unsigned int v43;
  unsigned int v44;
  int v45;
  unsigned int v46;
  unsigned int v47;
  int v48;
  unsigned int v49;
  int v50;
  unsigned int v51;
  unsigned int v52;
  unsigned int v53;
  unsigned int v54;
  unint64_t v55;
  int v56;
  unsigned int v57;
  unsigned int v58;
  int v59;
  unsigned int v60;
  unsigned int v61;
  int v62;
  unsigned int v63;
  unsigned int v64;
  int v65;
  unsigned int v66;
  unsigned int v67;
  int v68;
  unsigned int v69;
  unsigned int v70;
  int v71;
  unsigned int v72;
  unsigned int v73;
  int v74;
  unsigned int v75;
  unsigned int v76;
  int v77;
  unsigned int v78;
  unsigned int v79;
  int v80;
  unsigned int v81;
  unsigned int v82;
  int v83;
  unsigned int v84;
  unsigned int v85;
  int v86;
  unsigned int v87;
  unsigned int v88;
  int v89;
  unsigned int v90;
  unsigned int v91;
  int v92;
  unsigned int v93;
  unsigned int v94;
  unsigned int v95;
  unsigned int v96;
  unsigned int v97;
  unint64_t v98;
  unsigned int v99;

  HIDWORD(v4) = *data;
  LODWORD(v4) = *data;
  v3 = v4 >> 29;
  HIDWORD(v4) = data[1];
  LODWORD(v4) = HIDWORD(v4);
  v5 = v4 >> 29;
  if (enc)
  {
    v6 = ks->ks[0].deslong[0] ^ v3;
    HIDWORD(v8) = ks->ks[0].deslong[1] ^ v3;
    LODWORD(v8) = HIDWORD(v8);
    v7 = v8 >> 4;
    v9 = DES_SPtrans[v6 >> 2] ^ DES_SPtrans[((unsigned __int16)v6 >> 10) + 128] ^ DES_SPtrans[((v6 >> 18) & 0x3F) + 256] ^ DES_SPtrans[(v6 >> 26) + 384] ^ DES_SPtrans[(v7 >> 2) + 64] ^ DES_SPtrans[((unsigned __int16)v7 >> 10) + 192] ^ DES_SPtrans[((v7 >> 18) & 0x3F) + 320] ^ DES_SPtrans[(v7 >> 26) + 448] ^ v5;
    v10 = v9 ^ ks->ks[1].deslong[0];
    HIDWORD(v8) = v9 ^ ks->ks[1].deslong[1];
    LODWORD(v8) = HIDWORD(v8);
    v11 = v8 >> 4;
    v12 = DES_SPtrans[v10 >> 2] ^ DES_SPtrans[((unsigned __int16)v10 >> 10) + 128] ^ DES_SPtrans[((v10 >> 18) & 0x3F) + 256] ^ DES_SPtrans[(v10 >> 26) + 384] ^ DES_SPtrans[(v11 >> 2) + 64] ^ DES_SPtrans[((unsigned __int16)v11 >> 10) + 192] ^ DES_SPtrans[((v11 >> 18) & 0x3F) + 320] ^ DES_SPtrans[(v11 >> 26) + 448] ^ v3;
    v13 = v12 ^ ks->ks[2].deslong[0];
    HIDWORD(v8) = v12 ^ ks->ks[2].deslong[1];
    LODWORD(v8) = HIDWORD(v8);
    v14 = v8 >> 4;
    v15 = DES_SPtrans[v13 >> 2] ^ DES_SPtrans[((unsigned __int16)v13 >> 10) + 128] ^ DES_SPtrans[((v13 >> 18) & 0x3F) + 256] ^ DES_SPtrans[(v13 >> 26) + 384] ^ DES_SPtrans[(v14 >> 2) + 64] ^ DES_SPtrans[((unsigned __int16)v14 >> 10) + 192] ^ DES_SPtrans[((v14 >> 18) & 0x3F) + 320] ^ DES_SPtrans[(v14 >> 26) + 448] ^ v9;
    v16 = v15 ^ ks->ks[3].deslong[0];
    HIDWORD(v8) = v15 ^ ks->ks[3].deslong[1];
    LODWORD(v8) = HIDWORD(v8);
    v17 = v8 >> 4;
    v18 = DES_SPtrans[v16 >> 2] ^ DES_SPtrans[((unsigned __int16)v16 >> 10) + 128] ^ DES_SPtrans[((v16 >> 18) & 0x3F) + 256] ^ DES_SPtrans[(v16 >> 26) + 384] ^ DES_SPtrans[(v17 >> 2) + 64] ^ DES_SPtrans[((unsigned __int16)v17 >> 10) + 192] ^ DES_SPtrans[((v17 >> 18) & 0x3F) + 320] ^ DES_SPtrans[(v17 >> 26) + 448] ^ v12;
    v19 = v18 ^ ks->ks[4].deslong[0];
    HIDWORD(v8) = v18 ^ ks->ks[4].deslong[1];
    LODWORD(v8) = HIDWORD(v8);
    v20 = v8 >> 4;
    v21 = DES_SPtrans[v19 >> 2] ^ DES_SPtrans[((unsigned __int16)v19 >> 10) + 128] ^ DES_SPtrans[((v19 >> 18) & 0x3F) + 256] ^ DES_SPtrans[(v19 >> 26) + 384] ^ DES_SPtrans[(v20 >> 2) + 64] ^ DES_SPtrans[((unsigned __int16)v20 >> 10) + 192] ^ DES_SPtrans[((v20 >> 18) & 0x3F) + 320] ^ DES_SPtrans[(v20 >> 26) + 448] ^ v15;
    v22 = v21 ^ ks->ks[5].deslong[0];
    HIDWORD(v8) = v21 ^ ks->ks[5].deslong[1];
    LODWORD(v8) = HIDWORD(v8);
    v23 = v8 >> 4;
    v24 = DES_SPtrans[v22 >> 2] ^ DES_SPtrans[((unsigned __int16)v22 >> 10) + 128] ^ DES_SPtrans[((v22 >> 18) & 0x3F) + 256] ^ DES_SPtrans[(v22 >> 26) + 384] ^ DES_SPtrans[(v23 >> 2) + 64] ^ DES_SPtrans[((unsigned __int16)v23 >> 10) + 192] ^ DES_SPtrans[((v23 >> 18) & 0x3F) + 320] ^ DES_SPtrans[(v23 >> 26) + 448] ^ v18;
    v25 = v24 ^ ks->ks[6].deslong[0];
    HIDWORD(v8) = v24 ^ ks->ks[6].deslong[1];
    LODWORD(v8) = HIDWORD(v8);
    v26 = v8 >> 4;
    v27 = DES_SPtrans[v25 >> 2] ^ DES_SPtrans[((unsigned __int16)v25 >> 10) + 128] ^ DES_SPtrans[((v25 >> 18) & 0x3F) + 256] ^ DES_SPtrans[(v25 >> 26) + 384] ^ DES_SPtrans[(v26 >> 2) + 64] ^ DES_SPtrans[((unsigned __int16)v26 >> 10) + 192] ^ DES_SPtrans[((v26 >> 18) & 0x3F) + 320] ^ DES_SPtrans[(v26 >> 26) + 448] ^ v21;
    v28 = v27 ^ ks->ks[7].deslong[0];
    HIDWORD(v8) = v27 ^ ks->ks[7].deslong[1];
    LODWORD(v8) = HIDWORD(v8);
    v29 = v8 >> 4;
    v30 = DES_SPtrans[v28 >> 2] ^ DES_SPtrans[((unsigned __int16)v28 >> 10) + 128] ^ DES_SPtrans[((v28 >> 18) & 0x3F) + 256] ^ DES_SPtrans[(v28 >> 26) + 384] ^ DES_SPtrans[(v29 >> 2) + 64] ^ DES_SPtrans[((unsigned __int16)v29 >> 10) + 192] ^ DES_SPtrans[((v29 >> 18) & 0x3F) + 320] ^ DES_SPtrans[(v29 >> 26) + 448] ^ v24;
    v31 = v30 ^ ks->ks[8].deslong[0];
    HIDWORD(v8) = v30 ^ ks->ks[8].deslong[1];
    LODWORD(v8) = HIDWORD(v8);
    v32 = v8 >> 4;
    v33 = DES_SPtrans[v31 >> 2] ^ DES_SPtrans[((unsigned __int16)v31 >> 10) + 128] ^ DES_SPtrans[((v31 >> 18) & 0x3F) + 256] ^ DES_SPtrans[(v31 >> 26) + 384] ^ DES_SPtrans[(v32 >> 2) + 64] ^ DES_SPtrans[((unsigned __int16)v32 >> 10) + 192] ^ DES_SPtrans[((v32 >> 18) & 0x3F) + 320] ^ DES_SPtrans[(v32 >> 26) + 448] ^ v27;
    v34 = v33 ^ ks->ks[9].deslong[0];
    HIDWORD(v8) = v33 ^ ks->ks[9].deslong[1];
    LODWORD(v8) = HIDWORD(v8);
    v35 = v8 >> 4;
    v36 = DES_SPtrans[v34 >> 2] ^ DES_SPtrans[((unsigned __int16)v34 >> 10) + 128] ^ DES_SPtrans[((v34 >> 18) & 0x3F) + 256] ^ DES_SPtrans[(v34 >> 26) + 384] ^ DES_SPtrans[(v35 >> 2) + 64] ^ DES_SPtrans[((unsigned __int16)v35 >> 10) + 192] ^ DES_SPtrans[((v35 >> 18) & 0x3F) + 320] ^ DES_SPtrans[(v35 >> 26) + 448] ^ v30;
    v37 = v36 ^ ks->ks[10].deslong[0];
    HIDWORD(v8) = v36 ^ ks->ks[10].deslong[1];
    LODWORD(v8) = HIDWORD(v8);
    v38 = v8 >> 4;
    v39 = DES_SPtrans[v37 >> 2] ^ DES_SPtrans[((unsigned __int16)v37 >> 10) + 128] ^ DES_SPtrans[((v37 >> 18) & 0x3F) + 256] ^ DES_SPtrans[(v37 >> 26) + 384] ^ DES_SPtrans[(v38 >> 2) + 64] ^ DES_SPtrans[((unsigned __int16)v38 >> 10) + 192] ^ DES_SPtrans[((v38 >> 18) & 0x3F) + 320] ^ DES_SPtrans[(v38 >> 26) + 448] ^ v33;
    v40 = v39 ^ ks->ks[11].deslong[0];
    HIDWORD(v8) = v39 ^ ks->ks[11].deslong[1];
    LODWORD(v8) = HIDWORD(v8);
    v41 = v8 >> 4;
    v42 = DES_SPtrans[v40 >> 2] ^ DES_SPtrans[((unsigned __int16)v40 >> 10) + 128] ^ DES_SPtrans[((v40 >> 18) & 0x3F) + 256] ^ DES_SPtrans[(v40 >> 26) + 384] ^ DES_SPtrans[(v41 >> 2) + 64] ^ DES_SPtrans[((unsigned __int16)v41 >> 10) + 192] ^ DES_SPtrans[((v41 >> 18) & 0x3F) + 320] ^ DES_SPtrans[(v41 >> 26) + 448] ^ v36;
    v43 = v42 ^ ks->ks[12].deslong[0];
    HIDWORD(v8) = v42 ^ ks->ks[12].deslong[1];
    LODWORD(v8) = HIDWORD(v8);
    v44 = v8 >> 4;
    v45 = DES_SPtrans[v43 >> 2] ^ DES_SPtrans[((unsigned __int16)v43 >> 10) + 128] ^ DES_SPtrans[((v43 >> 18) & 0x3F) + 256] ^ DES_SPtrans[(v43 >> 26) + 384] ^ DES_SPtrans[(v44 >> 2) + 64] ^ DES_SPtrans[((unsigned __int16)v44 >> 10) + 192] ^ DES_SPtrans[((v44 >> 18) & 0x3F) + 320] ^ DES_SPtrans[(v44 >> 26) + 448] ^ v39;
    v46 = v45 ^ ks->ks[13].deslong[0];
    HIDWORD(v8) = v45 ^ ks->ks[13].deslong[1];
    LODWORD(v8) = HIDWORD(v8);
    v47 = v8 >> 4;
    v48 = DES_SPtrans[v46 >> 2] ^ DES_SPtrans[((unsigned __int16)v46 >> 10) + 128] ^ DES_SPtrans[((v46 >> 18) & 0x3F) + 256] ^ DES_SPtrans[(v46 >> 26) + 384] ^ DES_SPtrans[(v47 >> 2) + 64] ^ DES_SPtrans[((unsigned __int16)v47 >> 10) + 192] ^ DES_SPtrans[((v47 >> 18) & 0x3F) + 320] ^ DES_SPtrans[(v47 >> 26) + 448] ^ v42;
    v49 = v48 ^ ks->ks[14].deslong[0];
    HIDWORD(v8) = v48 ^ ks->ks[14].deslong[1];
    LODWORD(v8) = HIDWORD(v8);
    v50 = DES_SPtrans[v49 >> 2] ^ DES_SPtrans[((unsigned __int16)v49 >> 10) + 128] ^ DES_SPtrans[((v49 >> 18) & 0x3F) + 256] ^ DES_SPtrans[(v49 >> 26) + 384] ^ DES_SPtrans[((v8 >> 4) >> 2) + 64] ^ DES_SPtrans[((unsigned __int16)(v8 >> 4) >> 10) + 192] ^ DES_SPtrans[(((v8 >> 4) >> 18) & 0x3F) + 320] ^ DES_SPtrans[((v8 >> 4) >> 26) + 448] ^ v45;
    v51 = ks->ks[15].deslong[0];
    v52 = ks->ks[15].deslong[1];
  }
  else
  {
    v53 = ks->ks[15].deslong[0] ^ v3;
    HIDWORD(v55) = ks->ks[15].deslong[1] ^ v3;
    LODWORD(v55) = HIDWORD(v55);
    v54 = v55 >> 4;
    v56 = DES_SPtrans[v53 >> 2] ^ DES_SPtrans[((unsigned __int16)v53 >> 10) + 128] ^ DES_SPtrans[((v53 >> 18) & 0x3F) + 256] ^ DES_SPtrans[(v53 >> 26) + 384] ^ DES_SPtrans[(v54 >> 2) + 64] ^ DES_SPtrans[((unsigned __int16)v54 >> 10) + 192] ^ DES_SPtrans[((v54 >> 18) & 0x3F) + 320] ^ DES_SPtrans[(v54 >> 26) + 448] ^ v5;
    v57 = v56 ^ ks->ks[14].deslong[0];
    HIDWORD(v55) = v56 ^ ks->ks[14].deslong[1];
    LODWORD(v55) = HIDWORD(v55);
    v58 = v55 >> 4;
    v59 = DES_SPtrans[v57 >> 2] ^ DES_SPtrans[((unsigned __int16)v57 >> 10) + 128] ^ DES_SPtrans[((v57 >> 18) & 0x3F) + 256] ^ DES_SPtrans[(v57 >> 26) + 384] ^ DES_SPtrans[(v58 >> 2) + 64] ^ DES_SPtrans[((unsigned __int16)v58 >> 10) + 192] ^ DES_SPtrans[((v58 >> 18) & 0x3F) + 320] ^ DES_SPtrans[(v58 >> 26) + 448] ^ v3;
    v60 = v59 ^ ks->ks[13].deslong[0];
    HIDWORD(v55) = v59 ^ ks->ks[13].deslong[1];
    LODWORD(v55) = HIDWORD(v55);
    v61 = v55 >> 4;
    v62 = DES_SPtrans[v60 >> 2] ^ DES_SPtrans[((unsigned __int16)v60 >> 10) + 128] ^ DES_SPtrans[((v60 >> 18) & 0x3F) + 256] ^ DES_SPtrans[(v60 >> 26) + 384] ^ DES_SPtrans[(v61 >> 2) + 64] ^ DES_SPtrans[((unsigned __int16)v61 >> 10) + 192] ^ DES_SPtrans[((v61 >> 18) & 0x3F) + 320] ^ DES_SPtrans[(v61 >> 26) + 448] ^ v56;
    v63 = v62 ^ ks->ks[12].deslong[0];
    HIDWORD(v55) = v62 ^ ks->ks[12].deslong[1];
    LODWORD(v55) = HIDWORD(v55);
    v64 = v55 >> 4;
    v65 = DES_SPtrans[v63 >> 2] ^ DES_SPtrans[((unsigned __int16)v63 >> 10) + 128] ^ DES_SPtrans[((v63 >> 18) & 0x3F) + 256] ^ DES_SPtrans[(v63 >> 26) + 384] ^ DES_SPtrans[(v64 >> 2) + 64] ^ DES_SPtrans[((unsigned __int16)v64 >> 10) + 192] ^ DES_SPtrans[((v64 >> 18) & 0x3F) + 320] ^ DES_SPtrans[(v64 >> 26) + 448] ^ v59;
    v66 = v65 ^ ks->ks[11].deslong[0];
    HIDWORD(v55) = v65 ^ ks->ks[11].deslong[1];
    LODWORD(v55) = HIDWORD(v55);
    v67 = v55 >> 4;
    v68 = DES_SPtrans[v66 >> 2] ^ DES_SPtrans[((unsigned __int16)v66 >> 10) + 128] ^ DES_SPtrans[((v66 >> 18) & 0x3F) + 256] ^ DES_SPtrans[(v66 >> 26) + 384] ^ DES_SPtrans[(v67 >> 2) + 64] ^ DES_SPtrans[((unsigned __int16)v67 >> 10) + 192] ^ DES_SPtrans[((v67 >> 18) & 0x3F) + 320] ^ DES_SPtrans[(v67 >> 26) + 448] ^ v62;
    v69 = v68 ^ ks->ks[10].deslong[0];
    HIDWORD(v55) = v68 ^ ks->ks[10].deslong[1];
    LODWORD(v55) = HIDWORD(v55);
    v70 = v55 >> 4;
    v71 = DES_SPtrans[v69 >> 2] ^ DES_SPtrans[((unsigned __int16)v69 >> 10) + 128] ^ DES_SPtrans[((v69 >> 18) & 0x3F) + 256] ^ DES_SPtrans[(v69 >> 26) + 384] ^ DES_SPtrans[(v70 >> 2) + 64] ^ DES_SPtrans[((unsigned __int16)v70 >> 10) + 192] ^ DES_SPtrans[((v70 >> 18) & 0x3F) + 320] ^ DES_SPtrans[(v70 >> 26) + 448] ^ v65;
    v72 = v71 ^ ks->ks[9].deslong[0];
    HIDWORD(v55) = v71 ^ ks->ks[9].deslong[1];
    LODWORD(v55) = HIDWORD(v55);
    v73 = v55 >> 4;
    v74 = DES_SPtrans[v72 >> 2] ^ DES_SPtrans[((unsigned __int16)v72 >> 10) + 128] ^ DES_SPtrans[((v72 >> 18) & 0x3F) + 256] ^ DES_SPtrans[(v72 >> 26) + 384] ^ DES_SPtrans[(v73 >> 2) + 64] ^ DES_SPtrans[((unsigned __int16)v73 >> 10) + 192] ^ DES_SPtrans[((v73 >> 18) & 0x3F) + 320] ^ DES_SPtrans[(v73 >> 26) + 448] ^ v68;
    v75 = v74 ^ ks->ks[8].deslong[0];
    HIDWORD(v55) = v74 ^ ks->ks[8].deslong[1];
    LODWORD(v55) = HIDWORD(v55);
    v76 = v55 >> 4;
    v77 = DES_SPtrans[v75 >> 2] ^ DES_SPtrans[((unsigned __int16)v75 >> 10) + 128] ^ DES_SPtrans[((v75 >> 18) & 0x3F) + 256] ^ DES_SPtrans[(v75 >> 26) + 384] ^ DES_SPtrans[(v76 >> 2) + 64] ^ DES_SPtrans[((unsigned __int16)v76 >> 10) + 192] ^ DES_SPtrans[((v76 >> 18) & 0x3F) + 320] ^ DES_SPtrans[(v76 >> 26) + 448] ^ v71;
    v78 = v77 ^ ks->ks[7].deslong[0];
    HIDWORD(v55) = v77 ^ ks->ks[7].deslong[1];
    LODWORD(v55) = HIDWORD(v55);
    v79 = v55 >> 4;
    v80 = DES_SPtrans[v78 >> 2] ^ DES_SPtrans[((unsigned __int16)v78 >> 10) + 128] ^ DES_SPtrans[((v78 >> 18) & 0x3F) + 256] ^ DES_SPtrans[(v78 >> 26) + 384] ^ DES_SPtrans[(v79 >> 2) + 64] ^ DES_SPtrans[((unsigned __int16)v79 >> 10) + 192] ^ DES_SPtrans[((v79 >> 18) & 0x3F) + 320] ^ DES_SPtrans[(v79 >> 26) + 448] ^ v74;
    v81 = v80 ^ ks->ks[6].deslong[0];
    HIDWORD(v55) = v80 ^ ks->ks[6].deslong[1];
    LODWORD(v55) = HIDWORD(v55);
    v82 = v55 >> 4;
    v83 = DES_SPtrans[v81 >> 2] ^ DES_SPtrans[((unsigned __int16)v81 >> 10) + 128] ^ DES_SPtrans[((v81 >> 18) & 0x3F) + 256] ^ DES_SPtrans[(v81 >> 26) + 384] ^ DES_SPtrans[(v82 >> 2) + 64] ^ DES_SPtrans[((unsigned __int16)v82 >> 10) + 192] ^ DES_SPtrans[((v82 >> 18) & 0x3F) + 320] ^ DES_SPtrans[(v82 >> 26) + 448] ^ v77;
    v84 = v83 ^ ks->ks[5].deslong[0];
    HIDWORD(v55) = v83 ^ ks->ks[5].deslong[1];
    LODWORD(v55) = HIDWORD(v55);
    v85 = v55 >> 4;
    v86 = DES_SPtrans[v84 >> 2] ^ DES_SPtrans[((unsigned __int16)v84 >> 10) + 128] ^ DES_SPtrans[((v84 >> 18) & 0x3F) + 256] ^ DES_SPtrans[(v84 >> 26) + 384] ^ DES_SPtrans[(v85 >> 2) + 64] ^ DES_SPtrans[((unsigned __int16)v85 >> 10) + 192] ^ DES_SPtrans[((v85 >> 18) & 0x3F) + 320] ^ DES_SPtrans[(v85 >> 26) + 448] ^ v80;
    v87 = v86 ^ ks->ks[4].deslong[0];
    HIDWORD(v55) = v86 ^ ks->ks[4].deslong[1];
    LODWORD(v55) = HIDWORD(v55);
    v88 = v55 >> 4;
    v89 = DES_SPtrans[v87 >> 2] ^ DES_SPtrans[((unsigned __int16)v87 >> 10) + 128] ^ DES_SPtrans[((v87 >> 18) & 0x3F) + 256] ^ DES_SPtrans[(v87 >> 26) + 384] ^ DES_SPtrans[(v88 >> 2) + 64] ^ DES_SPtrans[((unsigned __int16)v88 >> 10) + 192] ^ DES_SPtrans[((v88 >> 18) & 0x3F) + 320] ^ DES_SPtrans[(v88 >> 26) + 448] ^ v83;
    v90 = v89 ^ ks->ks[3].deslong[0];
    HIDWORD(v55) = v89 ^ ks->ks[3].deslong[1];
    LODWORD(v55) = HIDWORD(v55);
    v91 = v55 >> 4;
    v92 = DES_SPtrans[v90 >> 2] ^ DES_SPtrans[((unsigned __int16)v90 >> 10) + 128] ^ DES_SPtrans[((v90 >> 18) & 0x3F) + 256] ^ DES_SPtrans[(v90 >> 26) + 384] ^ DES_SPtrans[(v91 >> 2) + 64] ^ DES_SPtrans[((unsigned __int16)v91 >> 10) + 192] ^ DES_SPtrans[((v91 >> 18) & 0x3F) + 320] ^ DES_SPtrans[(v91 >> 26) + 448] ^ v86;
    v93 = v92 ^ ks->ks[2].deslong[0];
    HIDWORD(v55) = v92 ^ ks->ks[2].deslong[1];
    LODWORD(v55) = HIDWORD(v55);
    v94 = v55 >> 4;
    v48 = DES_SPtrans[v93 >> 2] ^ DES_SPtrans[((unsigned __int16)v93 >> 10) + 128] ^ DES_SPtrans[((v93 >> 18) & 0x3F) + 256] ^ DES_SPtrans[(v93 >> 26) + 384] ^ DES_SPtrans[(v94 >> 2) + 64] ^ DES_SPtrans[((unsigned __int16)v94 >> 10) + 192] ^ DES_SPtrans[((v94 >> 18) & 0x3F) + 320] ^ DES_SPtrans[(v94 >> 26) + 448] ^ v89;
    v95 = v48 ^ ks->ks[1].deslong[0];
    HIDWORD(v55) = v48 ^ ks->ks[1].deslong[1];
    LODWORD(v55) = HIDWORD(v55);
    v50 = DES_SPtrans[v95 >> 2] ^ DES_SPtrans[((unsigned __int16)v95 >> 10) + 128] ^ DES_SPtrans[((v95 >> 18) & 0x3F) + 256] ^ DES_SPtrans[(v95 >> 26) + 384] ^ DES_SPtrans[((v55 >> 4) >> 2) + 64] ^ DES_SPtrans[((unsigned __int16)(v55 >> 4) >> 10) + 192] ^ DES_SPtrans[(((v55 >> 4) >> 18) & 0x3F) + 320] ^ DES_SPtrans[((v55 >> 4) >> 26) + 448] ^ v92;
    v51 = ks->ks[0].deslong[0];
    v52 = ks->ks[0].deslong[1];
  }
  v96 = v50 ^ v51;
  HIDWORD(v98) = v50 ^ v52;
  LODWORD(v98) = v50 ^ v52;
  v97 = v98 >> 4;
  HIDWORD(v98) = v50;
  LODWORD(v98) = v50;
  v99 = v98 >> 3;
  HIDWORD(v98) = DES_SPtrans[v96 >> 2] ^ DES_SPtrans[((unsigned __int16)v96 >> 10) + 128] ^ DES_SPtrans[((v96 >> 18) & 0x3F) + 256] ^ DES_SPtrans[(v96 >> 26) + 384] ^ DES_SPtrans[(v97 >> 2) + 64] ^ DES_SPtrans[((unsigned __int16)v97 >> 10) + 192] ^ DES_SPtrans[((v97 >> 18) & 0x3F) + 320] ^ DES_SPtrans[(v97 >> 26) + 448] ^ v48;
  LODWORD(v98) = HIDWORD(v98);
  *data = v99;
  data[1] = v98 >> 3;
}

void DES_encrypt3(unsigned int *data, DES_key_schedule *ks1, DES_key_schedule *ks2, DES_key_schedule *ks3)
{
  unsigned int v7;
  unsigned int v8;
  unsigned int v9;
  int v10;
  int v11;
  unsigned int v12;
  int v13;
  int v14;
  unsigned int v15;
  int v16;
  int v17;
  unsigned int v18;
  int v19;
  int v20;
  unsigned int v21;
  unsigned int v22;
  unsigned int v23;
  int v24;
  int v25;
  unsigned int v26;
  int v27;
  int v28;
  unsigned int v29;
  int v30;
  int v31;
  unsigned int v32;
  int v33;
  int v34;

  v7 = data[1];
  v8 = (*data ^ (v7 >> 4)) & 0xF0F0F0F;
  v9 = v8 ^ *data;
  v10 = v7 ^ (16 * v8);
  v11 = (unsigned __int16)v10 ^ HIWORD(v9);
  v12 = v11 ^ v10;
  v13 = v9 ^ (v11 << 16);
  v14 = (v13 ^ (v12 >> 2)) & 0x33333333;
  v15 = v14 ^ v13;
  v16 = v12 ^ (4 * v14);
  v17 = (v16 ^ (v15 >> 8)) & 0xFF00FF;
  v18 = v17 ^ v16;
  v19 = v15 ^ (v17 << 8);
  v20 = (v19 ^ (v18 >> 1)) & 0x55555555;
  *data = v20 ^ v19;
  data[1] = v18 ^ (2 * v20);
  DES_encrypt2(data, ks1, 1);
  DES_encrypt2(data, ks2, 0);
  DES_encrypt2(data, ks3, 1);
  v21 = data[1];
  v22 = (*data ^ (v21 >> 1)) & 0x55555555;
  v23 = v22 ^ *data;
  v24 = v21 ^ (2 * v22);
  v25 = (v24 ^ (v23 >> 8)) & 0xFF00FF;
  v26 = v25 ^ v24;
  v27 = v23 ^ (v25 << 8);
  v28 = (v27 ^ (v26 >> 2)) & 0x33333333;
  v29 = v28 ^ v27;
  v30 = v26 ^ (4 * v28);
  v31 = (unsigned __int16)v30 ^ HIWORD(v29);
  v32 = v31 ^ v30;
  v33 = v29 ^ (v31 << 16);
  v34 = (v33 ^ (v32 >> 4)) & 0xF0F0F0F;
  *data = v34 ^ v33;
  data[1] = v32 ^ (16 * v34);
}

void DES_decrypt3(unsigned int *data, DES_key_schedule *ks1, DES_key_schedule *ks2, DES_key_schedule *ks3)
{
  unsigned int v7;
  unsigned int v8;
  unsigned int v9;
  int v10;
  int v11;
  unsigned int v12;
  int v13;
  int v14;
  unsigned int v15;
  int v16;
  int v17;
  unsigned int v18;
  int v19;
  int v20;
  unsigned int v21;
  unsigned int v22;
  unsigned int v23;
  int v24;
  int v25;
  unsigned int v26;
  int v27;
  int v28;
  unsigned int v29;
  int v30;
  int v31;
  unsigned int v32;
  int v33;
  int v34;

  v7 = data[1];
  v8 = (*data ^ (v7 >> 4)) & 0xF0F0F0F;
  v9 = v8 ^ *data;
  v10 = v7 ^ (16 * v8);
  v11 = (unsigned __int16)v10 ^ HIWORD(v9);
  v12 = v11 ^ v10;
  v13 = v9 ^ (v11 << 16);
  v14 = (v13 ^ (v12 >> 2)) & 0x33333333;
  v15 = v14 ^ v13;
  v16 = v12 ^ (4 * v14);
  v17 = (v16 ^ (v15 >> 8)) & 0xFF00FF;
  v18 = v17 ^ v16;
  v19 = v15 ^ (v17 << 8);
  v20 = (v19 ^ (v18 >> 1)) & 0x55555555;
  *data = v20 ^ v19;
  data[1] = v18 ^ (2 * v20);
  DES_encrypt2(data, ks3, 0);
  DES_encrypt2(data, ks2, 1);
  DES_encrypt2(data, ks1, 0);
  v21 = data[1];
  v22 = (*data ^ (v21 >> 1)) & 0x55555555;
  v23 = v22 ^ *data;
  v24 = v21 ^ (2 * v22);
  v25 = (v24 ^ (v23 >> 8)) & 0xFF00FF;
  v26 = v25 ^ v24;
  v27 = v23 ^ (v25 << 8);
  v28 = (v27 ^ (v26 >> 2)) & 0x33333333;
  v29 = v28 ^ v27;
  v30 = v26 ^ (4 * v28);
  v31 = (unsigned __int16)v30 ^ HIWORD(v29);
  v32 = v31 ^ v30;
  v33 = v29 ^ (v31 << 16);
  v34 = (v33 ^ (v32 >> 4)) & 0xF0F0F0F;
  *data = v34 ^ v33;
  data[1] = v32 ^ (16 * v34);
}

void DES_ncbc_encrypt(const unsigned __int8 *input, unsigned __int8 *output, uint64_t length, DES_key_schedule *schedule, DES_cblock *ivec, int enc)
{
  DES_cblock *v6;
  uint64_t v8;
  unsigned int v11;
  unsigned int v12;
  unsigned __int8 *v13;
  unint64_t v14;
  unsigned int v15;
  int v16;
  int v17;
  const unsigned __int8 *v18;
  int v19;
  int v20;
  int v21;
  int v22;
  int v23;
  int v24;
  int v25;
  unsigned int v26;
  unsigned int v27;
  unsigned int v28;
  unsigned int v29;
  unsigned int v30;
  unsigned int v31;
  unsigned __int8 *v32;
  unsigned int v33;
  unsigned int v34;
  unint64_t v35;
  const unsigned __int8 *v36;
  __int16 v37;
  int v38;
  unsigned int v39;
  unsigned int v40;
  unsigned int v41;
  int v42;
  unsigned __int8 *v43;
  unsigned int data;
  unsigned int v46;
  uint64_t v47;

  v6 = ivec;
  v8 = length;
  v47 = *MEMORY[0x24BDAC8D0];
  v11 = *(_DWORD *)ivec;
  v12 = *(_DWORD *)&(*ivec)[4];
  if (enc)
  {
    if (length >= 8)
    {
      do
      {
        v13 = output;
        v14 = v8;
        v8 -= 8;
        v15 = *(_DWORD *)input;
        v16 = *((_DWORD *)input + 1);
        input += 8;
        data = v15 ^ v11;
        v46 = v16 ^ v12;
        DES_encrypt1(&data, schedule, 1);
        v11 = data;
        v12 = v46;
        output += 8;
        *(_DWORD *)v13 = data;
        *((_DWORD *)v13 + 1) = v12;
      }
      while (v14 > 0xF);
    }
    if (v8)
    {
      v17 = 0;
      v18 = &input[v8];
      v19 = 0;
      switch(v8)
      {
        case 1:
          goto LABEL_12;
        case 2:
          goto LABEL_11;
        case 3:
          goto LABEL_10;
        case 4:
          goto LABEL_9;
        case 5:
          goto LABEL_8;
        case 6:
          goto LABEL_7;
        case 7:
          v20 = *--v18;
          v17 = v20 << 16;
LABEL_7:
          v21 = *--v18;
          v17 |= v21 << 8;
LABEL_8:
          v22 = *--v18;
          v17 |= v22;
LABEL_9:
          v19 = v17;
          v23 = *--v18;
          v17 = v23 << 24;
LABEL_10:
          v24 = *--v18;
          v17 |= v24 << 16;
LABEL_11:
          v25 = *--v18;
          v17 |= v25 << 8;
LABEL_12:
          v17 |= *(v18 - 1);
          break;
        default:
          v19 = 0;
          break;
      }
      data = v17 ^ v11;
      v46 = v19 ^ v12;
      DES_encrypt1(&data, schedule, 1);
      LOBYTE(v11) = data;
      v12 = v46;
      v26 = data >> 8;
      v27 = HIWORD(data);
      v28 = HIBYTE(data);
      v29 = v46 >> 8;
      v30 = HIWORD(v46);
      v31 = HIBYTE(v46);
      *(_DWORD *)output = data;
      *((_DWORD *)output + 1) = v12;
    }
    else
    {
      v26 = v11 >> 8;
      v27 = HIWORD(v11);
      v28 = HIBYTE(v11);
      v29 = v12 >> 8;
      v30 = HIWORD(v12);
      v31 = HIBYTE(v12);
    }
    *(_BYTE *)v6 = v11;
    (*v6)[1] = v26;
    (*v6)[2] = v27;
    (*v6)[3] = v28;
    (*v6)[4] = v12;
    (*v6)[5] = v29;
    (*v6)[6] = v30;
  }
  else
  {
    if (length >= 8)
    {
      do
      {
        v32 = output;
        v33 = v11;
        v34 = v12;
        v11 = *(_DWORD *)input;
        v12 = *((_DWORD *)input + 1);
        v35 = v8;
        v8 -= 8;
        v36 = input + 8;
        data = *(_DWORD *)input;
        v46 = v12;
        DES_encrypt1(&data, schedule, 0);
        v37 = HIWORD(data) ^ HIWORD(v33);
        v38 = v46 ^ v34;
        *(_WORD *)v32 = data ^ v33;
        *((_WORD *)v32 + 1) = v37;
        *((_DWORD *)v32 + 1) = v38;
        output = v32 + 8;
        input += 8;
      }
      while (v35 > 0xF);
      input = v36;
      v6 = ivec;
    }
    if (v8)
    {
      v40 = *(_DWORD *)input;
      v39 = *((_DWORD *)input + 1);
      data = v40;
      v46 = v39;
      DES_encrypt1(&data, schedule, 0);
      v41 = data ^ v11;
      v42 = v46 ^ v12;
      v43 = &output[v8];
      switch(v8)
      {
        case 1:
          goto LABEL_25;
        case 2:
          goto LABEL_24;
        case 3:
          goto LABEL_23;
        case 4:
          goto LABEL_22;
        case 5:
          goto LABEL_21;
        case 6:
          goto LABEL_20;
        case 7:
          *--v43 = BYTE2(v42);
LABEL_20:
          *--v43 = BYTE1(v42);
LABEL_21:
          *--v43 = v42;
LABEL_22:
          *--v43 = HIBYTE(v41);
LABEL_23:
          *--v43 = BYTE2(v41);
LABEL_24:
          *--v43 = BYTE1(v41);
LABEL_25:
          *(v43 - 1) = v41;
          break;
        default:
          break;
      }
    }
    else
    {
      v40 = v11;
      v39 = v12;
    }
    *(_DWORD *)v6 = v40;
    *(_WORD *)&(*v6)[4] = v39;
    v31 = HIBYTE(v39);
    (*v6)[6] = BYTE2(v39);
  }
  (*v6)[7] = v31;
}

void DES_ede3_cbc_encrypt(const unsigned __int8 *input, unsigned __int8 *output, uint64_t length, DES_key_schedule *ks1, DES_key_schedule *ks2, DES_key_schedule *ks3, DES_cblock *ivec, int enc)
{
  DES_cblock *v8;
  DES_key_schedule *v9;
  DES_key_schedule *v10;
  uint64_t v11;
  unsigned int v14;
  unsigned int v15;
  unint64_t v16;
  unsigned int v17;
  int v18;
  int v19;
  const unsigned __int8 *v20;
  int v21;
  int v22;
  int v23;
  int v24;
  int v25;
  int v26;
  int v27;
  unsigned int v28;
  unsigned int v29;
  unsigned int v30;
  unsigned int v31;
  unsigned int v32;
  unsigned int v33;
  unsigned int v34;
  unsigned int v35;
  unint64_t v36;
  const unsigned __int8 *v37;
  __int16 v38;
  int v39;
  unsigned int v40;
  unsigned int v41;
  unsigned int v42;
  int v43;
  unsigned __int8 *v44;
  DES_key_schedule *v48;
  unsigned int data;
  int v50;
  uint64_t v51;

  v8 = ivec;
  v9 = ks3;
  v10 = ks2;
  v11 = length;
  v51 = *MEMORY[0x24BDAC8D0];
  v15 = *(_DWORD *)ivec;
  v14 = *(_DWORD *)&(*ivec)[4];
  v48 = ks1;
  if (enc)
  {
    if (length >= 8)
    {
      do
      {
        v16 = v11;
        v11 -= 8;
        v17 = *(_DWORD *)input;
        v18 = *((_DWORD *)input + 1);
        input += 8;
        data = v17 ^ v15;
        v50 = v18 ^ v14;
        DES_encrypt3(&data, ks1, v10, v9);
        ks1 = v48;
        v15 = data;
        v14 = v50;
        *(_WORD *)output = data;
        output[2] = BYTE2(v15);
        output[3] = HIBYTE(v15);
        *((_DWORD *)output + 1) = v14;
        output += 8;
      }
      while (v16 > 0xF);
    }
    if (v11)
    {
      v19 = 0;
      v20 = &input[v11];
      v21 = 0;
      switch(v11)
      {
        case 1:
          goto LABEL_12;
        case 2:
          goto LABEL_11;
        case 3:
          goto LABEL_10;
        case 4:
          goto LABEL_9;
        case 5:
          goto LABEL_8;
        case 6:
          goto LABEL_7;
        case 7:
          v22 = *--v20;
          v19 = v22 << 16;
LABEL_7:
          v23 = *--v20;
          v19 |= v23 << 8;
LABEL_8:
          v24 = *--v20;
          v19 |= v24;
LABEL_9:
          v21 = v19;
          v25 = *--v20;
          v19 = v25 << 24;
LABEL_10:
          v26 = *--v20;
          v19 |= v26 << 16;
LABEL_11:
          v27 = *--v20;
          v19 |= v27 << 8;
LABEL_12:
          v19 |= *(v20 - 1);
          break;
        default:
          v21 = 0;
          break;
      }
      data = v19 ^ v15;
      v50 = v21 ^ v14;
      DES_encrypt3(&data, ks1, v10, v9);
      v15 = data;
      v14 = v50;
      *output = data;
      v28 = v15 >> 8;
      output[1] = BYTE1(v15);
      v29 = HIWORD(v15);
      output[2] = BYTE2(v15);
      v30 = HIBYTE(v15);
      output[3] = HIBYTE(v15);
      *((_DWORD *)output + 1) = v14;
      v31 = v14 >> 8;
      v32 = HIWORD(v14);
      v33 = HIBYTE(v14);
    }
    else
    {
      v28 = v15 >> 8;
      v29 = HIWORD(v15);
      v30 = HIBYTE(v15);
      v31 = v14 >> 8;
      v32 = HIWORD(v14);
      v33 = HIBYTE(v14);
    }
    *(_BYTE *)v8 = v15;
    (*v8)[1] = v28;
    (*v8)[2] = v29;
    (*v8)[3] = v30;
    (*v8)[4] = v14;
    (*v8)[5] = v31;
    (*v8)[6] = v32;
  }
  else
  {
    if (length >= 8)
    {
      do
      {
        v34 = v15;
        v35 = v14;
        v15 = *(_DWORD *)input;
        v14 = *((_DWORD *)input + 1);
        v36 = v11;
        v11 -= 8;
        v37 = input + 8;
        data = *(_DWORD *)input;
        v50 = v14;
        DES_decrypt3(&data, ks1, ks2, ks3);
        ks1 = v48;
        v38 = HIWORD(data) ^ HIWORD(v34);
        v39 = v50 ^ v35;
        *(_WORD *)output = data ^ v34;
        *((_WORD *)output + 1) = v38;
        *((_DWORD *)output + 1) = v39;
        output += 8;
        input += 8;
      }
      while (v36 > 0xF);
      input = v37;
      v8 = ivec;
      v9 = ks3;
      v10 = ks2;
    }
    if (v11)
    {
      v41 = *(_DWORD *)input;
      v40 = *((_DWORD *)input + 1);
      data = v41;
      v50 = v40;
      DES_decrypt3(&data, ks1, v10, v9);
      v42 = data ^ v15;
      v43 = v50 ^ v14;
      v44 = &output[v11];
      switch(v11)
      {
        case 1:
          goto LABEL_25;
        case 2:
          goto LABEL_24;
        case 3:
          goto LABEL_23;
        case 4:
          goto LABEL_22;
        case 5:
          goto LABEL_21;
        case 6:
          goto LABEL_20;
        case 7:
          *--v44 = BYTE2(v43);
LABEL_20:
          *--v44 = BYTE1(v43);
LABEL_21:
          *--v44 = v43;
LABEL_22:
          *--v44 = HIBYTE(v42);
LABEL_23:
          *--v44 = BYTE2(v42);
LABEL_24:
          *--v44 = BYTE1(v42);
LABEL_25:
          *(v44 - 1) = v42;
          break;
        default:
          break;
      }
    }
    else
    {
      v41 = v15;
      v40 = v14;
    }
    *(_DWORD *)v8 = v41;
    *(_WORD *)&(*v8)[4] = v40;
    v33 = HIBYTE(v40);
    (*v8)[6] = BYTE2(v40);
  }
  (*v8)[7] = v33;
}

int EVP_DigestInit(EVP_MD_CTX *ctx, const EVP_MD *type)
{
  *(_OWORD *)&ctx->flags = 0u;
  *(_OWORD *)&ctx[1].digest = 0u;
  *(_OWORD *)&ctx->digest = 0u;
  return EVP_DigestInit_ex(ctx, type, 0);
}

void EVP_MD_CTX_init(EVP_MD_CTX *ctx)
{
  *(_OWORD *)&ctx->flags = 0u;
  *(_OWORD *)&ctx[1].digest = 0u;
  *(_OWORD *)&ctx->digest = 0u;
}

int EVP_DigestInit_ex(EVP_MD_CTX *ctx, const EVP_MD *type, ENGINE *impl)
{
  ENGINE *engine;
  int v7;
  int v8;
  const EVP_MD *digest;
  const EVP_MD *v10;
  size_t sign_high;
  void *v12;
  uint64_t *p_type;
  int v14;
  int v15;
  int result;

  EVP_MD_CTX_clear_flags(ctx, 2);
  engine = ctx->engine;
  if (!engine || !ctx->digest)
  {
    if (!type)
    {
      digest = ctx->digest;
      if (!ctx->digest)
      {
        v7 = 139;
        v8 = 178;
        goto LABEL_33;
      }
      type = 0;
LABEL_17:
      if (HIDWORD(digest->sign) && ctx->md_data && !EVP_MD_CTX_test_flags(ctx, 4))
      {
        freezero(ctx->md_data, SHIDWORD(ctx->digest->sign));
        ctx->md_data = 0;
      }
LABEL_21:
      ctx->digest = type;
      if ((ctx->flags & 0x100) != 0)
        goto LABEL_24;
      sign_high = SHIDWORD(type->sign);
      if (!(_DWORD)sign_high)
        goto LABEL_24;
      ctx[1].engine = (ENGINE *)type->update;
      v12 = malloc_type_calloc(1uLL, sign_high, 0xD2D81BBBuLL);
      ctx->md_data = v12;
      if (v12)
        goto LABEL_24;
      EVP_PKEY_CTX_free((EVP_PKEY **)ctx[1].digest);
      ctx[1].digest = 0;
      v7 = 65;
      v8 = 195;
      goto LABEL_33;
    }
LABEL_7:
    ENGINE_finish(engine);
    if (impl)
    {
      if (!ENGINE_init(impl))
      {
        v7 = 134;
        v8 = 154;
LABEL_33:
        ERR_put_error(6, 4095, v7, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/digest.c", v8);
        return 0;
      }
    }
    else
    {
      impl = ENGINE_get_digest_engine(type->type);
      if (!impl)
        goto LABEL_15;
    }
    v10 = ENGINE_get_digest(impl, type->type);
    if (!v10)
    {
      ERR_put_error(6, 4095, 134, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/digest.c", 165);
      ENGINE_finish(impl);
      return 0;
    }
    type = v10;
LABEL_15:
    ctx->engine = impl;
    digest = ctx->digest;
    if (ctx->digest == type)
      goto LABEL_24;
    if (!digest)
      goto LABEL_21;
    goto LABEL_17;
  }
  if (type && type->type != ctx->digest->type)
    goto LABEL_7;
LABEL_24:
  p_type = (uint64_t *)&ctx[1].digest->type;
  if (!p_type || (v14 = EVP_PKEY_CTX_ctrl(p_type, -1, 248), v14 > 0) || (v15 = v14, result = 0, v15 == -2))
  {
    if ((ctx->flags & 0x100) != 0)
      return 1;
    else
      return ((uint64_t (*)(EVP_MD_CTX *))ctx->digest->init)(ctx);
  }
  return result;
}

int EVP_DigestUpdate(EVP_MD_CTX *ctx, const void *d, size_t cnt)
{
  return ((uint64_t (*)(EVP_MD_CTX *, const void *, size_t))ctx[1].engine)(ctx, d, cnt);
}

int EVP_DigestFinal(EVP_MD_CTX *ctx, unsigned __int8 *md, unsigned int *s)
{
  int v4;

  v4 = EVP_DigestFinal_ex(ctx, md, s);
  EVP_MD_CTX_cleanup(ctx);
  return v4;
}

int EVP_DigestFinal_ex(EVP_MD_CTX *ctx, unsigned __int8 *md, unsigned int *s)
{
  int v3;
  const EVP_MD *digest;
  int (__cdecl *cleanup)(EVP_MD_CTX *);

  if (ctx->digest->md_size < 0x41u)
  {
    v3 = ((uint64_t (*)(void))ctx->digest->final)();
    digest = ctx->digest;
    if (s)
      *s = digest->md_size;
    cleanup = digest->cleanup;
    if (cleanup)
    {
      ((void (*)(EVP_MD_CTX *))cleanup)(ctx);
      EVP_MD_CTX_set_flags(ctx, 2);
      digest = ctx->digest;
    }
    bzero(ctx->md_data, SHIDWORD(digest->sign));
  }
  else
  {
    ERR_put_error(6, 4095, 164, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/digest.c", 239);
    return 0;
  }
  return v3;
}

int EVP_MD_CTX_cleanup(EVP_MD_CTX *ctx)
{
  const EVP_MD *digest;
  int v3;

  digest = ctx->digest;
  if (ctx->digest)
  {
    if (!digest->cleanup)
      goto LABEL_15;
    v3 = EVP_MD_CTX_test_flags(ctx, 2);
    digest = ctx->digest;
    if (!v3)
    {
      ((void (*)(EVP_MD_CTX *))digest->cleanup)(ctx);
      digest = ctx->digest;
    }
    if (digest)
    {
LABEL_15:
      if (HIDWORD(digest->sign) && ctx->md_data && !EVP_MD_CTX_test_flags(ctx, 4))
        freezero(ctx->md_data, SHIDWORD(ctx->digest->sign));
    }
  }
  if (!EVP_MD_CTX_test_flags(ctx, 1024))
    EVP_PKEY_CTX_free((EVP_PKEY **)ctx[1].digest);
  ENGINE_finish(ctx->engine);
  *(_OWORD *)&ctx->digest = 0u;
  *(_OWORD *)&ctx->flags = 0u;
  *(_OWORD *)&ctx[1].digest = 0u;
  return 1;
}

int EVP_MD_CTX_copy(EVP_MD_CTX *out, const EVP_MD_CTX *in)
{
  *(_OWORD *)&out->flags = 0u;
  *(_OWORD *)&out[1].digest = 0u;
  *(_OWORD *)&out->digest = 0u;
  return EVP_MD_CTX_copy_ex(out, in);
}

int EVP_MD_CTX_copy_ex(EVP_MD_CTX *out, const EVP_MD_CTX *in)
{
  const EVP_MD *digest;
  ENGINE *engine;
  void *md_data;
  int v7;
  int v8;
  __int128 v10;
  __int128 v11;
  void **p_md_data;
  int sign_high;
  void *v14;
  const EVP_MD *v15;
  const EVP_MD *v16;
  int (__cdecl *copy)(EVP_MD_CTX *, const EVP_MD_CTX *);

  if (!in || (digest = in->digest) == 0)
  {
    v7 = 111;
    v8 = 266;
    goto LABEL_9;
  }
  engine = in->engine;
  if (engine)
  {
    if (!ENGINE_init(engine))
    {
      v7 = 38;
      v8 = 272;
      goto LABEL_9;
    }
    digest = in->digest;
  }
  if (out->digest == digest)
  {
    md_data = out->md_data;
    EVP_MD_CTX_set_flags(out, 4);
  }
  else
  {
    md_data = 0;
  }
  EVP_MD_CTX_cleanup(out);
  v10 = *(_OWORD *)&in[1].digest;
  v11 = *(_OWORD *)&in->digest;
  *(_OWORD *)&out->flags = *(_OWORD *)&in->flags;
  *(_OWORD *)&out[1].digest = v10;
  *(_OWORD *)&out->digest = v11;
  out->md_data = 0;
  p_md_data = &out->md_data;
  out[1].digest = 0;
  EVP_MD_CTX_clear_flags(out, 1024);
  if (in->md_data)
  {
    sign_high = HIDWORD(out->digest->sign);
    if (sign_high)
    {
      if (md_data)
      {
        *p_md_data = md_data;
LABEL_19:
        memcpy(md_data, in->md_data, sign_high);
        goto LABEL_20;
      }
      v14 = malloc_type_calloc(1uLL, sign_high, 0x41AE253EuLL);
      *p_md_data = v14;
      if (v14)
      {
        md_data = v14;
        sign_high = HIDWORD(out->digest->sign);
        goto LABEL_19;
      }
      v7 = 65;
      v8 = 299;
LABEL_9:
      ERR_put_error(6, 4095, v7, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/digest.c", v8);
      return 0;
    }
  }
LABEL_20:
  v15 = in[1].digest;
  out[1].engine = in[1].engine;
  if (v15)
  {
    v16 = (const EVP_MD *)EVP_PKEY_CTX_dup((uint64_t)v15);
    out[1].digest = v16;
    if (!v16)
    {
      EVP_MD_CTX_cleanup(out);
      return 0;
    }
  }
  copy = out->digest->copy;
  if (copy)
    return ((uint64_t (*)(EVP_MD_CTX *, const EVP_MD_CTX *))copy)(out, in);
  else
    return 1;
}

int EVP_Digest(const void *data, size_t count, unsigned __int8 *md, unsigned int *size, const EVP_MD *type, ENGINE *impl)
{
  int v12;
  EVP_MD_CTX v14;
  __int128 v15;

  v15 = 0u;
  memset(&v14, 0, sizeof(v14));
  EVP_MD_CTX_set_flags(&v14, 1);
  v12 = EVP_DigestInit_ex(&v14, type, impl)
     && (*((unsigned int (**)(EVP_MD_CTX *, const void *, size_t))&v15 + 1))(&v14, data, count)
     && EVP_DigestFinal_ex(&v14, md, size) != 0;
  EVP_MD_CTX_cleanup(&v14);
  return v12;
}

void *EVP_MD_CTX_new()
{
  return malloc_type_calloc(1uLL, 0x30uLL, 0x10E0040E563E252uLL);
}

void EVP_MD_CTX_free(EVP_MD_CTX *a1)
{
  if (a1)
  {
    EVP_MD_CTX_cleanup(a1);
    free(a1);
  }
}

uint64_t EVP_MD_CTX_reset(EVP_MD_CTX *a1)
{
  EVP_MD_CTX_cleanup(a1);
  return 1;
}

EVP_MD_CTX *EVP_MD_CTX_create(void)
{
  return (EVP_MD_CTX *)malloc_type_calloc(1uLL, 0x30uLL, 0x10E0040E563E252uLL);
}

void EVP_MD_CTX_destroy(EVP_MD_CTX *ctx)
{
  if (ctx)
  {
    EVP_MD_CTX_cleanup(ctx);
    free(ctx);
  }
}

uint64_t EVP_MD_CTX_ctrl(uint64_t a1)
{
  uint64_t (*v1)(void);
  uint64_t result;
  int v3;
  int v4;

  if (*(_QWORD *)a1)
  {
    v1 = *(uint64_t (**)(void))(*(_QWORD *)a1 + 72);
    if (v1)
    {
      result = v1();
      if ((_DWORD)result != -1)
        return result;
      v3 = 133;
      v4 = 425;
    }
    else
    {
      v3 = 132;
      v4 = 419;
    }
  }
  else
  {
    v3 = 131;
    v4 = 414;
  }
  ERR_put_error(6, 4095, v3, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/digest.c", v4);
  return 0;
}

int EVP_SignFinal(EVP_MD_CTX *ctx, unsigned __int8 *md, unsigned int *s, EVP_PKEY *pkey)
{
  uint64_t *v8;
  uint64_t *v9;
  int v10;
  uint64_t v12;
  EVP_MD_CTX ctxa;
  __int128 v14;
  unsigned int sa;
  unsigned __int8 mda[64];
  uint64_t v17;

  v17 = *MEMORY[0x24BDAC8D0];
  sa = 0;
  v14 = 0u;
  memset(&ctxa, 0, sizeof(ctxa));
  v12 = 0;
  *s = 0;
  EVP_MD_CTX_init(&ctxa);
  if (!EVP_MD_CTX_copy_ex(&ctxa, ctx) || !EVP_DigestFinal_ex(&ctxa, mda, &sa))
  {
    v9 = 0;
LABEL_9:
    v10 = 0;
    goto LABEL_10;
  }
  EVP_MD_CTX_cleanup(&ctxa);
  v12 = EVP_PKEY_size(pkey);
  v8 = (uint64_t *)EVP_PKEY_CTX_new((uint64_t)pkey, 0);
  v9 = v8;
  if (!v8
    || (int)EVP_PKEY_sign_init(v8) < 1
    || (int)EVP_PKEY_CTX_ctrl(v9, -1, 248) < 1
    || (int)EVP_PKEY_sign(v9, (uint64_t)md, &v12, (uint64_t)mda, sa) < 1)
  {
    goto LABEL_9;
  }
  *s = v12;
  v10 = 1;
LABEL_10:
  EVP_PKEY_CTX_free((EVP_PKEY **)v9);
  return v10;
}

int ASN1_get_object(const unsigned __int8 **pp, uint64_t *plength, int *ptag, int *pclass, uint64_t omax)
{
  unint64_t v9;
  uint64_t v10;
  int v11;
  int v12;
  int v14;
  _QWORD v15[3];
  unint64_t v16;
  unsigned __int8 v17;
  int v18;
  uint64_t v19;

  v19 = 0;
  v18 = 0;
  v17 = 0;
  v16 = 0;
  memset(v15, 0, sizeof(v15));
  *pclass = 0;
  *ptag = 0;
  *plength = 0;
  CBS_init(v15, (uint64_t)*pp, omax);
  if (!asn1_get_object_cbs(v15, 0, &v17, (int *)&v19 + 1, &v18, &v19, &v16))
  {
    v12 = 89;
LABEL_8:
    ERR_put_error(13, 4095, 123, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/asn1_old_lib.c", v12);
    return 128;
  }
  if (v18 < 0)
  {
    v12 = 94;
    goto LABEL_8;
  }
  v9 = v16;
  if (v9 > CBS_len((uint64_t)v15) || (v10 = v16, (v16 & 0x8000000000000000) != 0))
  {
    ERR_put_error(13, 4095, 155, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/asn1_old_lib.c", 104);
    v11 = 128;
    v10 = v16;
  }
  else
  {
    v11 = 0;
  }
  *pclass = v17 << 6;
  *ptag = v18;
  *plength = v10;
  *pp = (const unsigned __int8 *)CBS_data((uint64_t)v15);
  if (HIDWORD(v19))
    v14 = v11 | 0x20;
  else
    v14 = v11;
  return v14 | ((_DWORD)v19 != 0);
}

void ASN1_put_object(unsigned __int8 **pp, int constructed, int length, int tag, int xclass)
{
  unsigned __int8 *v5;
  char v6;
  unsigned __int8 *v7;
  uint64_t v8;
  unsigned int v9;
  BOOL v10;
  uint64_t v11;
  unsigned __int8 *v12;
  uint64_t v13;
  unsigned int v14;
  BOOL v15;
  uint64_t v16;

  v5 = *pp;
  v6 = xclass & 0xC0 | (32 * (constructed != 0));
  if (tag > 30)
  {
    v8 = 0;
    *v5 = v6 | 0x1F;
    v9 = tag;
    do
    {
      ++v8;
      v10 = v9 >= 0x80;
      v9 >>= 7;
    }
    while (v10);
    v11 = 0;
    do
    {
      v5[v11 + v8] = tag & 0x7F | (((_DWORD)v11 != 0) << 7);
      tag = tag >> 7;
      --v11;
    }
    while (v11 + v8 > 0);
    v7 = &v5[v8 + 1];
  }
  else
  {
    *v5 = v6 | tag & 0x1F;
    v7 = v5 + 1;
  }
  if (constructed == 2)
  {
    *v7 = 0x80;
    v12 = v7 + 1;
  }
  else if (length >= 128)
  {
    v13 = 1;
    v14 = length;
    do
    {
      ++v13;
      v15 = v14 > 0xFF;
      v14 >>= 8;
    }
    while (v15);
    *v7 = (v13 - 1) | 0x80;
    v16 = v13;
    do
    {
      v7[(v16 - 2) + 1] = length;
      length = length >> 8;
      --v16;
    }
    while (v16 > 1);
    v12 = &v7[v13];
  }
  else
  {
    *v7 = length;
    v12 = v7 + 1;
  }
  *pp = v12;
}

int ASN1_put_eoc(unsigned __int8 **pp)
{
  unsigned __int8 *v1;

  v1 = *pp;
  *(_WORD *)v1 = 0;
  *pp = v1 + 2;
  return 2;
}

int ASN1_object_size(int constructed, int length, int tag)
{
  int v3;
  BOOL v4;
  int result;

  v3 = length + 1;
  if (tag >= 31)
  {
    do
    {
      ++v3;
      v4 = tag > 0x7F;
      tag = tag >> 7;
    }
    while (v4);
  }
  if (constructed == 2)
    return v3 + 3;
  result = v3 + 1;
  if (length >= 128)
  {
    do
    {
      ++result;
      v4 = length > 0xFF;
      length = length >> 8;
    }
    while (v4);
  }
  return result;
}

ASN1_VALUE *d2i_ASRange(ASN1_VALUE **a1, const unsigned __int8 **a2, uint64_t a3)
{
  return ASN1_item_d2i(a1, a2, a3, &ASRange_it);
}

uint64_t i2d_ASRange(ASN1_VALUE *a1, unsigned __int8 **a2)
{
  return ASN1_item_i2d(a1, a2, &ASRange_it);
}

ASN1_VALUE *ASRange_new()
{
  return ASN1_item_new(&ASRange_it);
}

void ASRange_free(ASN1_VALUE *a1)
{
  ASN1_item_free(a1, &ASRange_it);
}

ASN1_VALUE *d2i_ASIdOrRange(ASN1_VALUE **a1, const unsigned __int8 **a2, uint64_t a3)
{
  return ASN1_item_d2i(a1, a2, a3, &ASIdOrRange_it);
}

uint64_t i2d_ASIdOrRange(ASN1_VALUE *a1, unsigned __int8 **a2)
{
  return ASN1_item_i2d(a1, a2, &ASIdOrRange_it);
}

ASN1_VALUE *ASIdOrRange_new()
{
  return ASN1_item_new(&ASIdOrRange_it);
}

void ASIdOrRange_free(ASN1_VALUE *a1)
{
  ASN1_item_free(a1, &ASIdOrRange_it);
}

ASN1_VALUE *d2i_ASIdentifierChoice(ASN1_VALUE **a1, const unsigned __int8 **a2, uint64_t a3)
{
  return ASN1_item_d2i(a1, a2, a3, &ASIdentifierChoice_it);
}

uint64_t i2d_ASIdentifierChoice(ASN1_VALUE *a1, unsigned __int8 **a2)
{
  return ASN1_item_i2d(a1, a2, &ASIdentifierChoice_it);
}

ASN1_VALUE *ASIdentifierChoice_new()
{
  return ASN1_item_new(&ASIdentifierChoice_it);
}

void ASIdentifierChoice_free(ASN1_VALUE *a1)
{
  ASN1_item_free(a1, &ASIdentifierChoice_it);
}

ASN1_VALUE *d2i_ASIdentifiers(ASN1_VALUE **a1, const unsigned __int8 **a2, uint64_t a3)
{
  return ASN1_item_d2i(a1, a2, a3, &ASIdentifiers_it);
}

uint64_t i2d_ASIdentifiers(ASN1_VALUE *a1, unsigned __int8 **a2)
{
  return ASN1_item_i2d(a1, a2, &ASIdentifiers_it);
}

ASN1_VALUE *ASIdentifiers_new()
{
  return ASN1_item_new(&ASIdentifiers_it);
}

void ASIdentifiers_free(ASN1_VALUE *a1)
{
  ASN1_item_free(a1, &ASIdentifiers_it);
}

uint64_t X509v3_asid_add_inherit(uint64_t result, int a2)
{
  uint64_t v2;

  if (result)
  {
    v2 = result;
    if (a2)
    {
      if (a2 != 1)
        return 0;
      v2 = result + 8;
    }
    if (*(_QWORD *)v2)
    {
      return **(_DWORD **)v2 == 0;
    }
    else
    {
      result = (uint64_t)ASN1_item_new(&ASIdentifierChoice_it);
      *(_QWORD *)v2 = result;
      if (result)
      {
        result = (uint64_t)ASN1_NULL_new();
        *(_QWORD *)(*(_QWORD *)v2 + 8) = result;
        if (result)
        {
          **(_DWORD **)v2 = 0;
          return 1;
        }
      }
    }
  }
  return result;
}

ASN1_VALUE *X509v3_asid_add_id_or_range(ASN1_VALUE *result, int a2, uint64_t a3, uint64_t a4)
{
  ASN1_VALUE *v6;
  ASN1_VALUE *v7;
  ASN1_INTEGER **v8;

  if (result)
  {
    v6 = result;
    if (a2)
    {
      if (a2 != 1)
        return 0;
      v6 = (ASN1_VALUE *)((char *)result + 8);
    }
    if (*(_QWORD *)v6)
    {
      if (!**(_DWORD **)v6)
        return 0;
    }
    else
    {
      result = ASN1_item_new(&ASIdentifierChoice_it);
      *(_QWORD *)v6 = result;
      if (!result)
        return result;
      *(_QWORD *)(*(_QWORD *)v6 + 8) = sk_new((int (__cdecl *)(const char *const *, const char *const *))ASIdOrRange_cmp);
      if (!*(_QWORD *)(*(_QWORD *)v6 + 8))
        return 0;
      **(_DWORD **)v6 = 1;
    }
    result = ASN1_item_new(&ASIdOrRange_it);
    if (!result)
      return result;
    v7 = result;
    if (a4)
    {
      *(_DWORD *)result = 1;
      v8 = (ASN1_INTEGER **)ASN1_item_new(&ASRange_it);
      *((_QWORD *)v7 + 1) = v8;
      if (!v8)
      {
LABEL_18:
        ASN1_item_free(v7, &ASIdOrRange_it);
        return 0;
      }
      ASN1_INTEGER_free(*v8);
      **((_QWORD **)v7 + 1) = a3;
      ASN1_INTEGER_free(*(ASN1_INTEGER **)(*((_QWORD *)v7 + 1) + 8));
      *(_QWORD *)(*((_QWORD *)v7 + 1) + 8) = a4;
    }
    else
    {
      *(_DWORD *)result = 0;
      *((_QWORD *)result + 1) = a3;
    }
    if (sk_push(*(STACK **)(*(_QWORD *)v6 + 8), (char *)v7))
      return (ASN1_VALUE *)1;
    goto LABEL_18;
  }
  return result;
}

uint64_t ASIdOrRange_cmp(int **a1, uint64_t *a2)
{
  int *v2;
  uint64_t v3;
  int v4;
  _QWORD *v5;
  _QWORD *v6;
  ASN1_INTEGER *v7;
  ASN1_INTEGER *v8;
  uint64_t result;

  v2 = *a1;
  v3 = *a2;
  v4 = **a1;
  if (v4 == 1)
  {
    v5 = (_QWORD *)*((_QWORD *)v2 + 1);
    if (!v5 || !*v5 || !v5[1])
LABEL_8:
      OpenSSLDie("/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_asid.c", 381, "(a->type == ASIdOrRange_id && a->u.id != NULL) || (a->type == ASIdOrRange_range && a->u.range != NULL && a->u.range->min != NULL && a->u.range->max != NULL)");
  }
  else if (v4 || !*((_QWORD *)v2 + 1))
  {
    goto LABEL_8;
  }
  if (*(_DWORD *)v3 == 1)
  {
    v6 = *(_QWORD **)(v3 + 8);
    if (!v6 || !*v6 || !v6[1])
LABEL_16:
      OpenSSLDie("/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_asid.c", 385, "(b->type == ASIdOrRange_id && b->u.id != NULL) || (b->type == ASIdOrRange_range && b->u.range != NULL && b->u.range->min != NULL && b->u.range->max != NULL)");
  }
  else if (*(_DWORD *)v3 || !*(_QWORD *)(v3 + 8))
  {
    goto LABEL_16;
  }
  if (*v2 != 1)
  {
    if (!*v2)
    {
      v7 = (ASN1_INTEGER *)*((_QWORD *)v2 + 1);
      v8 = *(ASN1_INTEGER **)(v3 + 8);
      if (*(_DWORD *)v3)
        v8 = *(ASN1_INTEGER **)&v8->length;
      return ASN1_INTEGER_cmp(v7, v8);
    }
    goto LABEL_24;
  }
  if (*(_DWORD *)v3 != 1)
  {
LABEL_24:
    v7 = (ASN1_INTEGER *)**((_QWORD **)v2 + 1);
    v8 = *(ASN1_INTEGER **)(v3 + 8);
    return ASN1_INTEGER_cmp(v7, v8);
  }
  result = ASN1_INTEGER_cmp(**((ASN1_INTEGER ***)v2 + 1), **(ASN1_INTEGER ***)(v3 + 8));
  if (!(_DWORD)result)
  {
    v7 = *(ASN1_INTEGER **)(*((_QWORD *)v2 + 1) + 8);
    v8 = *(ASN1_INTEGER **)(*(_QWORD *)(v3 + 8) + 8);
    return ASN1_INTEGER_cmp(v7, v8);
  }
  return result;
}

uint64_t X509v3_asid_is_canonical(uint64_t *a1)
{
  uint64_t result;

  if (!a1)
    return 1;
  result = ASIdentifierChoice_is_canonical(*a1);
  if ((_DWORD)result)
    return ASIdentifierChoice_is_canonical(a1[1]) != 0;
  return result;
}

uint64_t ASIdentifierChoice_is_canonical(uint64_t a1)
{
  ASN1_INTEGER *v2;
  BIGNUM *v3;
  int v4;
  int v5;
  const STACK *v6;
  char *v7;
  char *v8;
  ASN1_INTEGER **v9;
  ASN1_INTEGER **v10;
  ASN1_INTEGER *v11;
  ASN1_INTEGER *v12;
  ASN1_INTEGER **v13;
  ASN1_INTEGER **v14;
  ASN1_INTEGER *v15;
  ASN1_INTEGER *v16;
  ASN1_INTEGER *v17;
  ASN1_INTEGER *v18;
  uint64_t v19;
  int v20;
  int v21;
  char *v22;

  if (!a1 || !*(_DWORD *)a1)
    return 1;
  if (*(_DWORD *)a1 != 1 || !sk_num(*(const STACK **)(a1 + 8)))
    return 0;
  v2 = 0;
  v3 = 0;
  v4 = 0;
  while (1)
  {
    v5 = sk_num(*(const STACK **)(a1 + 8)) - 1;
    v6 = *(const STACK **)(a1 + 8);
    if (v4 >= v5)
      break;
    v7 = sk_value(v6, v4);
    v8 = sk_value(*(const STACK **)(a1 + 8), v4 + 1);
    if (*(_DWORD *)v7 == 1)
    {
      v9 = (ASN1_INTEGER **)*((_QWORD *)v7 + 1);
      v10 = v9 + 1;
    }
    else
    {
      if (*(_DWORD *)v7)
        goto LABEL_34;
      v9 = (ASN1_INTEGER **)(v7 + 8);
      v10 = (ASN1_INTEGER **)(v7 + 8);
    }
    v11 = *v9;
    v12 = *v10;
    if (*(_DWORD *)v8 == 1)
    {
      v13 = (ASN1_INTEGER **)*((_QWORD *)v8 + 1);
      v14 = v13 + 1;
    }
    else
    {
      if (*(_DWORD *)v8)
        goto LABEL_34;
      v13 = (ASN1_INTEGER **)(v8 + 8);
      v14 = (ASN1_INTEGER **)(v8 + 8);
    }
    v15 = *v13;
    v16 = *v14;
    if ((ASN1_INTEGER_cmp(v11, *v13) & 0x80000000) == 0
      || ASN1_INTEGER_cmp(v11, v12) > 0
      || ASN1_INTEGER_cmp(v15, v16) > 0)
    {
      goto LABEL_34;
    }
    if (!v3 && (v3 = BN_new()) == 0 || !ASN1_INTEGER_to_BN(v12, v3) || !BN_add_word(v3, 1uLL))
    {
      v20 = 563;
LABEL_33:
      ERR_put_error(34, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_asid.c", v20);
      goto LABEL_34;
    }
    v17 = BN_to_ASN1_INTEGER(v3, v2);
    if (!v17)
    {
      v20 = 570;
      goto LABEL_33;
    }
    v18 = v17;
    ++v4;
    v2 = v17;
    if ((ASN1_INTEGER_cmp(v17, v15) & 0x80000000) == 0)
    {
      v19 = 0;
      v2 = v18;
      goto LABEL_35;
    }
  }
  v21 = sk_num(v6);
  v22 = sk_value(*(const STACK **)(a1 + 8), v21 - 1);
  if (!v22
    || *(_DWORD *)v22 != 1
    || ASN1_INTEGER_cmp(**((ASN1_INTEGER ***)v22 + 1), *(ASN1_INTEGER **)(*((_QWORD *)v22 + 1) + 8)) <= 0)
  {
    v19 = 1;
    goto LABEL_35;
  }
LABEL_34:
  v19 = 0;
LABEL_35:
  ASN1_INTEGER_free(v2);
  BN_free(v3);
  return v19;
}

uint64_t X509v3_asid_canonize(uint64_t *a1)
{
  uint64_t result;

  if (!a1)
    return 1;
  result = ASIdentifierChoice_canonize(*a1);
  if ((_DWORD)result)
    return ASIdentifierChoice_canonize(a1[1]);
  return result;
}

uint64_t ASIdentifierChoice_canonize(uint64_t a1)
{
  int v2;
  BIGNUM *v3;
  ASN1_INTEGER *v4;
  char *v5;
  char *v6;
  char *v7;
  ASN1_INTEGER **v8;
  ASN1_INTEGER **v9;
  ASN1_INTEGER *v10;
  ASN1_INTEGER *v11;
  ASN1_INTEGER **v12;
  ASN1_INTEGER **v13;
  ASN1_INTEGER *v14;
  ASN1_INTEGER *v15;
  ASN1_INTEGER *v16;
  _QWORD *v17;
  _QWORD *v18;
  _BOOL8 v19;
  int v20;
  char *v21;
  int v22;
  int v23;
  ASN1_INTEGER *ai;

  if (!a1 || !*(_DWORD *)a1)
    return 1;
  if (*(_DWORD *)a1 == 1 && sk_num(*(const STACK **)(a1 + 8)))
  {
    sk_sort(*(STACK **)(a1 + 8));
    if (sk_num(*(const STACK **)(a1 + 8)) >= 2)
    {
      v2 = 0;
      v3 = 0;
      v4 = 0;
      while (1)
      {
        v5 = sk_value(*(const STACK **)(a1 + 8), v2);
        v6 = sk_value(*(const STACK **)(a1 + 8), v2 + 1);
        v7 = v6;
        ai = v4;
        if (*(_DWORD *)v5 == 1)
        {
          v8 = (ASN1_INTEGER **)*((_QWORD *)v5 + 1);
          v9 = v8 + 1;
        }
        else
        {
          if (*(_DWORD *)v5)
            goto LABEL_50;
          v8 = (ASN1_INTEGER **)(v5 + 8);
          v9 = (ASN1_INTEGER **)(v5 + 8);
        }
        v10 = *v8;
        v11 = *v9;
        if (*(_DWORD *)v6 == 1)
        {
          v12 = (ASN1_INTEGER **)*((_QWORD *)v6 + 1);
          v13 = v12 + 1;
        }
        else
        {
          if (*(_DWORD *)v6)
            goto LABEL_50;
          v12 = (ASN1_INTEGER **)(v6 + 8);
          v13 = (ASN1_INTEGER **)(v6 + 8);
        }
        v14 = *v12;
        v15 = *v13;
        if (ASN1_INTEGER_cmp(v10, *v12) > 0 || ASN1_INTEGER_cmp(v10, v11) > 0 || ASN1_INTEGER_cmp(v14, v15) > 0)
          goto LABEL_50;
        if ((ASN1_INTEGER_cmp(v11, v14) & 0x80000000) == 0)
        {
          v22 = 116;
          v23 = 683;
          goto LABEL_49;
        }
        if (!v3 && (v3 = BN_new()) == 0 || !ASN1_INTEGER_to_BN(v11, v3) || !BN_add_word(v3, 1uLL))
        {
          v22 = 65;
          v23 = 693;
LABEL_49:
          ERR_put_error(34, 4095, v22, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_asid.c", v23);
          goto LABEL_50;
        }
        v16 = BN_to_ASN1_INTEGER(v3, ai);
        if (!v16)
        {
          v22 = 65;
          v23 = 700;
          goto LABEL_49;
        }
        v4 = v16;
        if (!ASN1_INTEGER_cmp(v16, v14))
          break;
        ++v2;
LABEL_37:
        if (v2 >= sk_num(*(const STACK **)(a1 + 8)) - 1)
          goto LABEL_42;
      }
      if (*(_DWORD *)v5 == 1)
      {
        ASN1_INTEGER_free(*(ASN1_INTEGER **)(*((_QWORD *)v5 + 1) + 8));
        *(_QWORD *)(*((_QWORD *)v5 + 1) + 8) = v15;
      }
      else if (!*(_DWORD *)v5)
      {
        v17 = malloc_type_calloc(1uLL, 0x10uLL, 0x20040A4A59CD2uLL);
        if (!v17)
        {
          ai = v4;
          v22 = 65;
          v23 = 712;
          goto LABEL_49;
        }
        *v17 = v10;
        v17[1] = v15;
        *(_DWORD *)v5 = 1;
        *((_QWORD *)v5 + 1) = v17;
      }
      if (*(_DWORD *)v7 == 1)
      {
        v18 = (_QWORD *)(*((_QWORD *)v7 + 1) + 8);
      }
      else
      {
        if (*(_DWORD *)v7)
        {
LABEL_36:
          ASN1_item_free((ASN1_VALUE *)v7, &ASIdOrRange_it);
          sk_delete(*(STACK **)(a1 + 8), v2 + 1);
          goto LABEL_37;
        }
        v18 = v7 + 8;
      }
      *v18 = 0;
      goto LABEL_36;
    }
    v4 = 0;
    v3 = 0;
LABEL_42:
    ai = v4;
    v20 = sk_num(*(const STACK **)(a1 + 8));
    v21 = sk_value(*(const STACK **)(a1 + 8), v20 - 1);
    if (v21
      && *(_DWORD *)v21 == 1
      && ASN1_INTEGER_cmp(**((ASN1_INTEGER ***)v21 + 1), *(ASN1_INTEGER **)(*((_QWORD *)v21 + 1) + 8)) > 0)
    {
LABEL_50:
      v19 = 0;
    }
    else
    {
      v19 = ASIdentifierChoice_is_canonical(a1) != 0;
    }
    ASN1_INTEGER_free(ai);
    BN_free(v3);
  }
  else
  {
    ERR_put_error(34, 4095, 116, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_asid.c", 638);
    return 0;
  }
  return v19;
}

uint64_t *v2i_ASIdentifiers(uint64_t a1, uint64_t a2, const STACK *a3)
{
  uint64_t *v4;
  int v5;
  const char *v6;
  const char *v7;
  CONF_VALUE *v8;
  int v9;
  const char *value;
  int v11;
  const char *v12;
  uint64_t v13;
  const char *v14;
  const char *v15;
  size_t v16;
  char *v17;
  char *v18;
  ASN1_INTEGER *v19;
  int v20;
  int v21;
  int v22;
  int v23;
  uint64_t *v25;
  ASN1_INTEGER *x;

  x = 0;
  v4 = (uint64_t *)ASN1_item_new(&ASIdentifiers_it);
  if (!v4)
  {
    ERR_put_error(34, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_asid.c", 796);
    return v4;
  }
  if (sk_num(a3) < 1)
  {
LABEL_24:
    if (X509v3_asid_canonize(v4))
      return v4;
    goto LABEL_35;
  }
  v5 = 0;
  v6 = "AS";
  v7 = "inherit";
  v25 = v4;
  while (1)
  {
    v8 = (CONF_VALUE *)sk_value(a3, v5);
    if (name_cmp(v8->name, v6))
    {
      if (name_cmp(v8->name, "RDI"))
      {
        v22 = 115;
        v23 = 812;
        goto LABEL_34;
      }
      v9 = 1;
    }
    else
    {
      v9 = 0;
    }
    value = v8->value;
    if (!strcmp(value, v7))
    {
      if (X509v3_asid_add_inherit((uint64_t)v4, v9))
        goto LABEL_23;
      v22 = 165;
      v23 = 823;
LABEL_34:
      ERR_put_error(34, 4095, v22, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_asid.c", v23);
      ERR_asprintf_error_data("section:%s,name:%s,value:%s", v8->section, v8->name, v8->value);
      goto LABEL_35;
    }
    v11 = strspn(value, "0123456789");
    v12 = &value[v11];
    if (!*v12)
    {
      if (X509V3_get_value_int(v8, &x))
      {
        v19 = 0;
        goto LABEL_21;
      }
      ERR_put_error(34, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_asid.c", 857);
LABEL_35:
      v19 = 0;
      goto LABEL_39;
    }
    v13 = strspn(v12, " \t") + v11;
    if (value[(int)v13] != 45)
    {
      v22 = 162;
      v23 = 838;
      goto LABEL_34;
    }
    v14 = v6;
    v15 = v7;
    v16 = strspn(&value[((v13 << 32) + 0x100000000) >> 32], " \t") + (((v13 << 32) + 0x100000000) >> 32);
    if (value[(int)(v16 + strspn(&value[(int)v16], "0123456789"))])
    {
      ERR_put_error(34, 4095, 163, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_asid.c", 846);
      ERR_asprintf_error_data("section:%s,name:%s,value:%s", v8->section, v8->name, v8->value);
LABEL_32:
      v19 = 0;
      goto LABEL_38;
    }
    v17 = strdup(value);
    if (!v17)
    {
      ERR_put_error(34, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_asid.c", 863);
      goto LABEL_32;
    }
    v18 = v17;
    v17[v11] = 0;
    x = s2i_ASN1_INTEGER(0, v17);
    v19 = s2i_ASN1_INTEGER(0, &v18[(int)v16]);
    free(v18);
    if (!x || !v19)
    {
      v20 = 65;
      v21 = 871;
      goto LABEL_37;
    }
    if (ASN1_INTEGER_cmp(x, v19) >= 1)
      break;
    v7 = v15;
    v6 = v14;
    v4 = v25;
LABEL_21:
    if (!X509v3_asid_add_id_or_range((ASN1_VALUE *)v4, v9, (uint64_t)x, (uint64_t)v19))
    {
      ERR_put_error(34, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_asid.c", 880);
      goto LABEL_39;
    }
    x = 0;
LABEL_23:
    if (++v5 >= sk_num(a3))
      goto LABEL_24;
  }
  v20 = 116;
  v21 = 875;
LABEL_37:
  ERR_put_error(34, 4095, v20, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_asid.c", v21);
LABEL_38:
  v4 = v25;
LABEL_39:
  ASN1_item_free((ASN1_VALUE *)v4, &ASIdentifiers_it);
  ASN1_INTEGER_free(x);
  ASN1_INTEGER_free(v19);
  return 0;
}

char *i2r_ASIdentifiers(uint64_t a1, uint64_t *a2, BIO *a3, int a4)
{
  char *result;

  result = i2r_ASIdentifierChoice(a3, *a2, a4, "Autonomous System Numbers");
  if ((_DWORD)result)
    return (char *)(i2r_ASIdentifierChoice(a3, a2[1], a4, "Routing Domain Identifiers") != 0);
  return result;
}

_QWORD *X509v3_asid_inherits(_QWORD *result)
{
  _DWORD *v1;

  if (result)
    return (_QWORD *)(*result && !*(_DWORD *)*result || (v1 = (_DWORD *)result[1]) != 0 && !*v1);
  return result;
}

uint64_t X509v3_asid_subset(uint64_t *a1, uint64_t *a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  _DWORD *v8;
  uint64_t v9;

  result = 1;
  if (a1 && a1 != a2)
  {
    if (a2)
    {
      v5 = *a1;
      if (!*a1 || *(_DWORD *)v5)
      {
        v6 = a1[1];
        if (!v6 || *(_DWORD *)v6)
        {
          v7 = *a2;
          if (!*a2 || *(_DWORD *)v7)
          {
            v8 = (_DWORD *)a2[1];
            if (!v8 || *v8)
            {
              if (!v5)
              {
LABEL_16:
                if (!v6)
                  return 1;
                v9 = a2[1];
                if (v9)
                {
                  result = asid_contains(*(STACK **)(v9 + 8), *(STACK **)(v6 + 8));
                  if (!(_DWORD)result)
                    return result;
                  return 1;
                }
                return 0;
              }
              if (v7)
              {
                result = asid_contains(*(STACK **)(v7 + 8), *(STACK **)(v5 + 8));
                if (!(_DWORD)result)
                  return result;
                v6 = a1[1];
                goto LABEL_16;
              }
            }
          }
        }
      }
    }
    return 0;
  }
  return result;
}

uint64_t asid_contains(STACK *a1, STACK *a2)
{
  uint64_t result;
  int v5;
  int v6;
  char *v7;
  ASN1_INTEGER **v8;
  ASN1_INTEGER **v9;
  ASN1_INTEGER *v10;
  ASN1_INTEGER *v11;
  char *v12;
  ASN1_INTEGER **v13;
  ASN1_INTEGER **v14;
  ASN1_INTEGER *v15;
  int v16;

  result = 1;
  if (a2 && a1 != a2)
  {
    if (!a1)
      return 0;
    if (sk_num(a2) >= 1)
    {
      v5 = 0;
      v6 = 0;
LABEL_6:
      v7 = sk_value(a2, v5);
      if (*(_DWORD *)v7 == 1)
      {
        v8 = (ASN1_INTEGER **)*((_QWORD *)v7 + 1);
        v9 = v8 + 1;
LABEL_10:
        v10 = *v8;
        v11 = *v9;
        while (v6 < sk_num(a1))
        {
          v12 = sk_value(a1, v6);
          if (*(_DWORD *)v12 == 1)
          {
            v13 = (ASN1_INTEGER **)*((_QWORD *)v12 + 1);
            v14 = v13 + 1;
          }
          else
          {
            if (*(_DWORD *)v12)
              return 0;
            v13 = (ASN1_INTEGER **)(v12 + 8);
            v14 = (ASN1_INTEGER **)(v12 + 8);
          }
          v15 = *v13;
          if ((ASN1_INTEGER_cmp(*v14, v11) & 0x80000000) == 0)
          {
            if (ASN1_INTEGER_cmp(v15, v10) > 0)
              return 0;
            ++v5;
            v16 = sk_num(a2);
            result = 1;
            if (v5 < v16)
              goto LABEL_6;
            return result;
          }
          ++v6;
        }
        return 0;
      }
      if (!*(_DWORD *)v7)
      {
        v8 = (ASN1_INTEGER **)(v7 + 8);
        v9 = (ASN1_INTEGER **)(v7 + 8);
        goto LABEL_10;
      }
      return 0;
    }
    return 1;
  }
  return result;
}

uint64_t X509v3_asid_validate_path(uint64_t a1)
{
  if (sk_num(*(const STACK **)(a1 + 160)) >= 1 && *(_QWORD *)(a1 + 64))
    return asid_validate_path_internal(a1, *(STACK **)(a1 + 160), 0);
  *(_DWORD *)(a1 + 176) = 1;
  return 0;
}

uint64_t asid_validate_path_internal(uint64_t a1, STACK *a2, uint64_t *a3)
{
  int v6;
  char *v7;
  uint64_t v8;
  uint64_t result;
  uint64_t v10;
  uint64_t v11;
  STACK *v12;
  int v13;
  uint64_t v14;
  STACK *v15;
  int v16;
  uint64_t *v17;
  uint64_t v18;
  BOOL v19;
  uint64_t v20;
  BOOL v21;
  _QWORD *v22;
  int *v23;
  int v24;

  if (sk_num(a2) < 1)
  {
LABEL_84:
    if (!a1)
      return 0;
    goto LABEL_85;
  }
  if (!(a1 | (unint64_t)a3))
    return 0;
  if (a1 && !*(_QWORD *)(a1 + 64))
  {
LABEL_85:
    result = 0;
    *(_DWORD *)(a1 + 176) = 1;
    return result;
  }
  if (a3)
  {
    if (X509v3_asid_is_canonical(a3))
    {
      v6 = 0;
      v7 = 0;
      v8 = 1;
    }
    else
    {
      if (!a1)
        return 0;
      *(_QWORD *)(a1 + 172) = 0x29FFFFFFFFLL;
      *(_QWORD *)(a1 + 184) = 0;
      v10 = (*(uint64_t (**)(_QWORD, uint64_t))(a1 + 64))(0, a1);
      v6 = 0;
      if (!(_DWORD)v10)
        return 0;
      v8 = v10;
      v7 = 0;
    }
LABEL_14:
    v11 = *a3;
    if (*a3)
    {
      if (*(_DWORD *)v11 == 1)
      {
        v13 = 0;
        v12 = *(STACK **)(v11 + 8);
LABEL_21:
        v14 = a3[1];
        if (v14)
        {
          if (*(_DWORD *)v14 == 1)
          {
            v16 = 0;
            v15 = *(STACK **)(v14 + 8);
LABEL_27:
            if (v6 < sk_num(a2))
            {
              while (1)
              {
                v7 = sk_value(a2, v6);
                if ((X509_get_extension_flags((uint64_t)v7) & 0x80) != 0)
                {
                  if (!a1)
                    return 0;
                  *(_DWORD *)(a1 + 172) = v6;
                  *(_DWORD *)(a1 + 176) = 41;
                  *(_QWORD *)(a1 + 184) = v7;
                  result = (*(uint64_t (**)(_QWORD, uint64_t))(a1 + 64))(0, a1);
                  v8 = result;
                  if (!(_DWORD)result)
                    return result;
                }
                v17 = (uint64_t *)*((_QWORD *)v7 + 17);
                if (!v17)
                {
                  if ((unint64_t)v12 | (unint64_t)v15)
                  {
                    if (!a1)
                      return 0;
                    *(_DWORD *)(a1 + 172) = v6;
                    *(_DWORD *)(a1 + 176) = 46;
                    *(_QWORD *)(a1 + 184) = v7;
                    result = (*(uint64_t (**)(_QWORD, uint64_t))(a1 + 64))(0, a1);
                    v8 = result;
                    if (!(_DWORD)result)
                      return result;
                  }
                  else
                  {
                    v12 = 0;
                    v15 = 0;
                  }
                  goto LABEL_63;
                }
                v18 = *v17;
                if (*v17)
                  v19 = 1;
                else
                  v19 = v12 == 0;
                if (!v19)
                {
                  if (!a1)
                    return 0;
                  *(_DWORD *)(a1 + 172) = v6;
                  *(_DWORD *)(a1 + 176) = 46;
                  *(_QWORD *)(a1 + 184) = v7;
                  result = (*(uint64_t (**)(_QWORD, uint64_t))(a1 + 64))(0, a1);
                  if (!(_DWORD)result)
                    return result;
                  v8 = result;
                  v12 = 0;
                  v13 = 0;
                  v17 = (uint64_t *)*((_QWORD *)v7 + 17);
                  v18 = *v17;
                }
                if (v18 && *(_DWORD *)v18 == 1)
                {
                  if (!v13)
                  {
                    if (!asid_contains(*(STACK **)(v18 + 8), v12))
                    {
                      if (!a1)
                        return 0;
                      *(_DWORD *)(a1 + 172) = v6;
                      *(_DWORD *)(a1 + 176) = 46;
                      *(_QWORD *)(a1 + 184) = v7;
                      result = (*(uint64_t (**)(_QWORD, uint64_t))(a1 + 64))(0, a1);
                      if (!(_DWORD)result)
                        return result;
                      v8 = result;
                      v13 = 0;
                      v20 = *(_QWORD *)(*((_QWORD *)v7 + 17) + 8);
                      if (v20 || !v15)
                        goto LABEL_52;
                      goto LABEL_50;
                    }
                    v17 = (uint64_t *)*((_QWORD *)v7 + 17);
                    v18 = *v17;
                  }
                  v13 = 0;
                  v12 = *(STACK **)(v18 + 8);
                }
                v20 = v17[1];
                if (v20)
                  v21 = 1;
                else
                  v21 = v15 == 0;
                if (!v21)
                {
                  if (!a1)
                    return 0;
LABEL_50:
                  *(_DWORD *)(a1 + 172) = v6;
                  *(_DWORD *)(a1 + 176) = 46;
                  *(_QWORD *)(a1 + 184) = v7;
                  result = (*(uint64_t (**)(_QWORD, uint64_t))(a1 + 64))(0, a1);
                  if (!(_DWORD)result)
                    return result;
                  v8 = result;
                  v15 = 0;
                  v16 = 0;
                  v20 = *(_QWORD *)(*((_QWORD *)v7 + 17) + 8);
                }
LABEL_52:
                if (!v20 || *(_DWORD *)v20 != 1)
                  goto LABEL_63;
                if (v16)
                  goto LABEL_57;
                if (asid_contains(*(STACK **)(v20 + 8), v15))
                {
                  v20 = *(_QWORD *)(*((_QWORD *)v7 + 17) + 8);
LABEL_57:
                  v16 = 0;
                  v15 = *(STACK **)(v20 + 8);
                  goto LABEL_63;
                }
                if (!a1)
                  return 0;
                *(_DWORD *)(a1 + 172) = v6;
                *(_DWORD *)(a1 + 176) = 46;
                *(_QWORD *)(a1 + 184) = v7;
                v8 = (*(uint64_t (**)(_QWORD, uint64_t))(a1 + 64))(0, a1);
                v16 = 0;
                result = 0;
                if (!(_DWORD)v8)
                  return result;
LABEL_63:
                if (++v6 >= sk_num(a2))
                  goto LABEL_74;
              }
            }
            if (v7)
            {
LABEL_74:
              v22 = (_QWORD *)*((_QWORD *)v7 + 17);
              if (!v22)
                return v8;
              if (!*v22 || *(_DWORD *)*v22)
              {
LABEL_77:
                v23 = (int *)v22[1];
                if (v23)
                {
                  v24 = *v23;
                  if (v24)
                    result = v8;
                  else
                    result = 0;
                  if (a1)
                  {
                    if (!v24)
                    {
                      *(_DWORD *)(a1 + 172) = v6;
                      *(_DWORD *)(a1 + 176) = 46;
                      *(_QWORD *)(a1 + 184) = v7;
                      return (*(uint64_t (**)(_QWORD, uint64_t))(a1 + 64))(0, a1);
                    }
                  }
                  return result;
                }
                return v8;
              }
              if (a1)
              {
                *(_DWORD *)(a1 + 172) = v6;
                *(_DWORD *)(a1 + 176) = 46;
                *(_QWORD *)(a1 + 184) = v7;
                result = (*(uint64_t (**)(_QWORD, uint64_t))(a1 + 64))(0, a1);
                if (!(_DWORD)result)
                  return result;
                v8 = result;
                v22 = (_QWORD *)*((_QWORD *)v7 + 17);
                goto LABEL_77;
              }
              return 0;
            }
            goto LABEL_84;
          }
          if (!*(_DWORD *)v14)
          {
            v15 = 0;
            v16 = 1;
            goto LABEL_27;
          }
        }
        v15 = 0;
        v16 = 0;
        goto LABEL_27;
      }
      if (!*(_DWORD *)v11)
      {
        v12 = 0;
        v13 = 1;
        goto LABEL_21;
      }
    }
    v12 = 0;
    v13 = 0;
    goto LABEL_21;
  }
  v7 = sk_value(a2, 0);
  if ((X509_get_extension_flags((uint64_t)v7) & 0x80) != 0)
    return 1;
  a3 = (uint64_t *)*((_QWORD *)v7 + 17);
  v6 = 1;
  v8 = 1;
  result = 1;
  if (a3)
    goto LABEL_14;
  return result;
}

uint64_t X509v3_asid_validate_resource_set(STACK *a1, uint64_t *a2, int a3)
{
  _DWORD *v7;

  if (!a2)
    return 1;
  if (sk_num(a1) >= 1)
  {
    if (a3)
      return asid_validate_path_internal(0, a1, a2);
    if (!*a2 || *(_DWORD *)*a2)
    {
      v7 = (_DWORD *)a2[1];
      if (!v7 || *v7)
        return asid_validate_path_internal(0, a1, a2);
    }
  }
  return 0;
}

char *i2r_ASIdentifierChoice(BIO *a1, uint64_t a2, int a3, const char *a4)
{
  int i;
  char *v8;
  char *v9;
  char *result;
  void *v11;
  void *v12;

  if (!a2)
    return (char *)1;
  BIO_printf(a1, "%*s%s:\n", a3, "", a4);
  if (*(_DWORD *)a2)
  {
    if (*(_DWORD *)a2 != 1)
      return 0;
    if (sk_num(*(const STACK **)(a2 + 8)) >= 1)
    {
      for (i = 0; i < sk_num(*(const STACK **)(a2 + 8)); ++i)
      {
        v8 = sk_value(*(const STACK **)(a2 + 8), i);
        v9 = v8;
        if (*(_DWORD *)v8 == 1)
        {
          result = i2s_ASN1_INTEGER(0, **((ASN1_INTEGER ***)v8 + 1));
          if (!result)
            return result;
          v12 = result;
          BIO_printf(a1, "%*s%s-", a3 + 2, "", result);
          free(v12);
          result = i2s_ASN1_INTEGER(0, *(ASN1_INTEGER **)(*((_QWORD *)v9 + 1) + 8));
          if (!result)
            return result;
          v11 = result;
          BIO_printf(a1, "%s\n");
        }
        else
        {
          if (*(_DWORD *)v8)
            return 0;
          result = i2s_ASN1_INTEGER(0, *((ASN1_INTEGER **)v8 + 1));
          if (!result)
            return result;
          v11 = result;
          BIO_printf(a1, "%*s%s\n");
        }
        free(v11);
      }
    }
  }
  else
  {
    BIO_printf(a1, "%*sinherit\n", a3 + 2, "");
  }
  return (char *)1;
}

void BF_cfb64_encrypt(const unsigned __int8 *in, unsigned __int8 *out, uint64_t length, const BF_KEY *schedule, unsigned __int8 *ivec, int *num, int enc)
{
  uint64_t v10;
  int v13;
  unsigned int v14;
  unsigned int v15;
  char v16;
  unsigned __int8 v17;
  unsigned int v18;
  unsigned int v19;
  unsigned __int8 v20;
  unsigned __int8 v21;
  unsigned int v22;
  unsigned int v23;
  uint64_t v24;

  v10 = length;
  v24 = *MEMORY[0x24BDAC8D0];
  v13 = *num;
  if (enc)
  {
    if (length)
    {
      do
      {
        if (!v13)
        {
          v14 = bswap32(*((_DWORD *)ivec + 1));
          v22 = bswap32(*(_DWORD *)ivec);
          v23 = v14;
          BF_encrypt(&v22, schedule);
          v15 = bswap32(v23);
          *(_DWORD *)ivec = bswap32(v22);
          *((_DWORD *)ivec + 1) = v15;
        }
        v16 = *in++;
        v17 = ivec[v13];
        *out++ = v17 ^ v16;
        ivec[v13] = v17 ^ v16;
        v13 = (v13 + 1) & 7;
        --v10;
      }
      while (v10);
    }
  }
  else if (length)
  {
    do
    {
      if (!v13)
      {
        v18 = bswap32(*((_DWORD *)ivec + 1));
        v22 = bswap32(*(_DWORD *)ivec);
        v23 = v18;
        BF_encrypt(&v22, schedule);
        v19 = bswap32(v23);
        *(_DWORD *)ivec = bswap32(v22);
        *((_DWORD *)ivec + 1) = v19;
      }
      v20 = *in++;
      v21 = ivec[v13];
      ivec[v13] = v20;
      *out++ = v21 ^ v20;
      v13 = (v13 + 1) & 7;
      --v10;
    }
    while (v10);
  }
  *num = v13;
}

char *__cdecl i2s_ASN1_OCTET_STRING(X509V3_EXT_METHOD *method, ASN1_OCTET_STRING *ia5)
{
  return hex_to_string(ia5->data, ia5->length);
}

ASN1_OCTET_STRING *s2i_skey_id(int a1, uint64_t a2, char *__s1)
{
  X509V3_EXT_METHOD *v5;
  X509V3_CTX *v6;
  ASN1_OCTET_STRING *v8;
  _QWORD *v9;
  uint64_t v10;
  _QWORD *v11;
  int *v12;
  const void *v13;
  size_t v14;
  const EVP_MD *v15;
  int v16;
  int v17;
  unsigned int size;
  unsigned __int8 md[64];
  uint64_t v20;

  v20 = *MEMORY[0x24BDAC8D0];
  v5 = (X509V3_EXT_METHOD *)strcmp(__s1, "hash");
  if ((_DWORD)v5)
    return s2i_ASN1_OCTET_STRING(v5, v6, __s1);
  v8 = ASN1_OCTET_STRING_new();
  if (!v8)
  {
    ERR_put_error(34, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_skey.c", 129);
    return v8;
  }
  size = 0;
  if (!a2)
    goto LABEL_15;
  if (*(_DWORD *)a2 == 1)
    return v8;
  v9 = *(_QWORD **)(a2 + 24);
  if (v9)
  {
    v10 = *v9 + 40;
    goto LABEL_11;
  }
  v11 = *(_QWORD **)(a2 + 16);
  if (!v11)
  {
LABEL_15:
    v16 = 114;
    v17 = 137;
    goto LABEL_16;
  }
  v10 = *v11 + 48;
LABEL_11:
  v12 = *(int **)(*(_QWORD *)v10 + 8);
  if (!v12)
  {
    v16 = 114;
    v17 = 147;
    goto LABEL_16;
  }
  v13 = (const void *)*((_QWORD *)v12 + 1);
  v14 = *v12;
  v15 = EVP_sha1();
  if (!EVP_Digest(v13, v14, md, &size, v15, 0))
  {
LABEL_17:
    ASN1_OCTET_STRING_free(v8);
    return 0;
  }
  if (!ASN1_STRING_set(v8, md, size))
  {
    v16 = 65;
    v17 = 156;
LABEL_16:
    ERR_put_error(34, 4095, v16, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_skey.c", v17);
    goto LABEL_17;
  }
  return v8;
}

ASN1_OCTET_STRING *__cdecl s2i_ASN1_OCTET_STRING(X509V3_EXT_METHOD *method, X509V3_CTX *ctx, char *str)
{
  ASN1_OCTET_STRING *v4;
  unsigned __int8 *v5;
  uint64_t len;

  v4 = ASN1_OCTET_STRING_new();
  if (v4)
  {
    len = 0;
    v5 = string_to_hex(str, &len);
    v4->data = v5;
    if (v5)
    {
      v4->length = len;
    }
    else
    {
      ASN1_OCTET_STRING_free(v4);
      return 0;
    }
  }
  else
  {
    ERR_put_error(34, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_skey.c", 102);
  }
  return v4;
}

uint64_t WHIRLPOOL_Init(uint64_t a1)
{
  *(_QWORD *)(a1 + 160) = 0;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  return 1;
}

uint64_t WHIRLPOOL_Update(uint64_t a1, unsigned __int8 *__src, unint64_t a3)
{
  unint64_t i;

  for (i = a3; i >> 60; __src += 0x1000000000000000)
  {
    WHIRLPOOL_BitUpdate(a1, __src, 0x8000000000000000);
    i -= 0x1000000000000000;
  }
  if (i)
    WHIRLPOOL_BitUpdate(a1, __src, 8 * i);
  return 1;
}

uint64_t WHIRLPOOL_BitUpdate(uint64_t result, unsigned __int8 *__src, unint64_t a3)
{
  unint64_t v3;
  uint64_t v5;
  unsigned int v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  BOOL v13;
  uint64_t v14;
  unsigned int v15;
  int v16;
  unint64_t v17;
  unsigned int v18;
  uint64_t v19;
  unsigned int v20;
  char v21;
  unint64_t v22;
  void *v23;
  unint64_t v24;
  size_t v25;
  _QWORD *v26;

  v3 = a3;
  v5 = result;
  v6 = *(_DWORD *)(result + 128);
  v7 = v6 & 7;
  v8 = -(int)a3 & 7;
  v9 = *(_QWORD *)(result + 136);
  *(_QWORD *)(result + 136) = v9 + a3;
  if (__CFADD__(v9, a3))
  {
    v10 = 18;
    do
    {
      v11 = *(_QWORD *)(result + 8 * v10);
      v12 = v11 + 1;
      v13 = v11 == -1;
      *(_QWORD *)(result + 8 * v10) = v12;
      if ((unint64_t)(v10 - 17) > 2)
        break;
      ++v10;
    }
    while (v13);
  }
  if (v8 | v7)
  {
    if (a3)
    {
      v26 = (_QWORD *)(result + 64);
      v14 = 8 - v7;
      do
      {
        v15 = v6 >> 3;
        if ((_DWORD)v7 == v8)
        {
          v21 = *__src++;
          *(_BYTE *)(v5 + v15 + 64) |= v21 & (0xFFu >> v7);
          v6 += v14;
          v3 -= v14;
          if (v6 == 512)
          {
            result = whirlpool_block((uint64_t *)v5, v26, 1);
            v6 = 0;
          }
          *(_DWORD *)(v5 + 128) = v6;
          goto LABEL_32;
        }
        v16 = *__src << v8;
        v17 = v3 - 8;
        if (v3 < 8)
        {
          v19 = v5 + v15;
          if ((_DWORD)v7)
            *(_BYTE *)(v19 + 64) |= (*__src << v8) >> v7;
          else
            *(_BYTE *)(v19 + 64) = v16;
          v6 += v3;
          if (v6 == 512)
          {
            result = whirlpool_block((uint64_t *)v5, v26, 1);
            v6 = 0;
            v20 = 0;
          }
          else
          {
            v20 = v15 + 1;
          }
          v17 = 0;
          v3 = 0;
          if (!(_DWORD)v7)
            goto LABEL_27;
        }
        else
        {
          v18 = *++__src;
          v16 |= v18 >> (8 - v8);
          if ((_DWORD)v7)
            *(_BYTE *)(v5 + v15 + 64) |= v16 >> v7;
          else
            *(_BYTE *)(v5 + v15 + 64) = v16;
          v6 += 8;
          if (v6 < 0x200)
          {
            v20 = v15 + 1;
          }
          else
          {
            result = whirlpool_block((uint64_t *)v5, v26, 1);
            v20 = 0;
            v6 &= 0x1FFu;
          }
          v3 -= 8;
          if (!(_DWORD)v7)
            goto LABEL_27;
        }
        *(_BYTE *)(v5 + v20 + 64) = v16 << v14;
        v3 = v17;
LABEL_27:
        *(_DWORD *)(v5 + 128) = v6;
      }
      while (v3);
    }
  }
  else
  {
LABEL_32:
    while (v3)
    {
      if (v3 < 0x200 || v6)
      {
        v22 = 512 - v6;
        v23 = (void *)(v5 + 64 + (v6 >> 3));
        v24 = v3 - v22;
        if (v3 >= v22)
        {
          v25 = v22 >> 3;
          memcpy(v23, __src, v25);
          __src += v25;
          result = whirlpool_block((uint64_t *)v5, (_QWORD *)(v5 + 64), 1);
          v6 = 0;
          v3 = v24;
        }
        else
        {
          result = (uint64_t)memcpy(v23, __src, v3 >> 3);
          v6 += v3;
          v3 = 0;
        }
        *(_DWORD *)(v5 + 128) = v6;
      }
      else
      {
        result = whirlpool_block((uint64_t *)v5, __src, v3 >> 9);
        __src += 64 * (v3 >> 9);
        v3 &= 0x1FFu;
      }
    }
  }
  return result;
}

uint64_t WHIRLPOOL_Final(_OWORD *a1, __int128 *a2)
{
  unint64_t v4;
  unint64_t v5;
  unsigned int v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  uint64_t result;

  v4 = *((unsigned int *)a2 + 32);
  v5 = v4 >> 3;
  if ((v4 & 7) != 0)
    *((_BYTE *)a2 + v5 + 64) |= 0x80u >> (v4 & 7);
  else
    *((_BYTE *)a2 + v5 + 64) = 0x80;
  v6 = v5 + 1;
  if (v4 >= 0x100)
  {
    if (v4 <= 0x1F7)
      bzero((char *)a2 + v6 + 64, (63 - v5));
    whirlpool_block((uint64_t *)a2, (_QWORD *)a2 + 8, 1);
    v6 = 0;
    goto LABEL_9;
  }
  if (v4 <= 0xF7)
LABEL_9:
    bzero((char *)a2 + v6 + 64, 32 - v6);
  v7 = 0;
  v8 = (uint64_t)a2 + 127;
  do
  {
    v9 = 0;
    v10 = *((_QWORD *)a2 + v7 + 17);
    do
    {
      *(_BYTE *)(v8 + v9) = v10;
      v10 >>= 8;
      --v9;
    }
    while (v9 != -8);
    ++v7;
    v8 -= 8;
  }
  while (v7 != 4);
  whirlpool_block((uint64_t *)a2, (_QWORD *)a2 + 8, 1);
  if (!a1)
    return 0;
  v11 = *a2;
  v12 = a2[1];
  v13 = a2[3];
  a1[2] = a2[2];
  a1[3] = v13;
  *a1 = v11;
  a1[1] = v12;
  a2[2] = 0u;
  a2[3] = 0u;
  a2[4] = 0u;
  a2[5] = 0u;
  a2[6] = 0u;
  a2[7] = 0u;
  a2[8] = 0u;
  a2[9] = 0u;
  *((_QWORD *)a2 + 20) = 0;
  result = 1;
  *a2 = 0u;
  a2[1] = 0u;
  return result;
}

_OWORD *WHIRLPOOL(unsigned __int8 *__src, unint64_t a2, _OWORD *a3)
{
  _OWORD *v3;
  __int128 v5[10];
  uint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v6 = 0;
  memset(&v5[8], 0, 32);
  if (a3)
    v3 = a3;
  else
    v3 = &WHIRLPOOL_m;
  memset(v5, 0, 128);
  WHIRLPOOL_Update((uint64_t)v5, __src, a2);
  WHIRLPOOL_Final(v3, v5);
  return v3;
}

int X509V3_EXT_add(X509V3_EXT_METHOD *ext)
{
  STACK *v2;
  int v4;

  v2 = (STACK *)ext_list;
  if (ext_list
    || (v2 = sk_new((int (__cdecl *)(const char *const *, const char *const *))ext_cmp), (ext_list = (uint64_t)v2) != 0))
  {
    if (sk_push(v2, (char *)ext))
      return 1;
    v4 = 159;
  }
  else
  {
    v4 = 155;
  }
  ERR_put_error(34, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_lib.c", v4);
  return 0;
}

uint64_t ext_cmp(_DWORD **a1, _DWORD **a2)
{
  return (**a1 - **a2);
}

X509V3_EXT_METHOD *__cdecl X509V3_EXT_get_nid(int nid)
{
  X509V3_EXT_METHOD **v1;
  X509V3_EXT_METHOD *result;
  int v3;
  char key[8];
  char data[16];
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  uint64_t v11;

  *(_QWORD *)key = data;
  if (nid < 0)
    return 0;
  v11 = 0;
  v9 = 0u;
  v10 = 0u;
  v7 = 0u;
  v8 = 0u;
  *(_OWORD *)data = 0u;
  v6 = 0u;
  *(_DWORD *)data = nid;
  v1 = (X509V3_EXT_METHOD **)OBJ_bsearch_(key, (const char *)&standard_exts, 40, 8, (int (__cdecl *)(const void *, const void *))ext_cmp_BSEARCH_CMP_FN);
  if (v1)
    return *v1;
  result = (X509V3_EXT_METHOD *)ext_list;
  if (ext_list)
  {
    v3 = sk_find((STACK *)ext_list, data);
    if (v3 != -1)
      return (X509V3_EXT_METHOD *)sk_value((const STACK *)ext_list, v3);
    return 0;
  }
  return result;
}

X509V3_EXT_METHOD *__cdecl X509V3_EXT_get(X509_EXTENSION *ext)
{
  int v1;

  v1 = OBJ_obj2nid(ext->object);
  if (v1)
    return X509V3_EXT_get_nid(v1);
  else
    return 0;
}

int X509V3_EXT_add_list(X509V3_EXT_METHOD *extlist)
{
  X509V3_EXT_METHOD *i;
  int result;
  int ext_nid;

  if (extlist->ext_nid == -1)
    return 1;
  for (i = extlist; ; ++i)
  {
    result = X509V3_EXT_add(i);
    if (!result)
      break;
    ext_nid = i[1].ext_nid;
    if (ext_nid == -1)
      return 1;
  }
  return result;
}

int X509V3_EXT_add_alias(int nid_to, int nid_from)
{
  X509V3_EXT_METHOD *nid;
  X509V3_EXT_METHOD *v4;
  X509V3_EXT_METHOD *v5;
  X509V3_EXT_METHOD *v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  int v12;
  int v14;
  int v15;

  nid = X509V3_EXT_get_nid(nid_from);
  if (!nid)
  {
    v14 = 102;
    v15 = 232;
LABEL_7:
    ERR_put_error(34, 4095, v14, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_lib.c", v15);
    return 0;
  }
  v4 = nid;
  v5 = (X509V3_EXT_METHOD *)malloc_type_malloc(0x68uLL, 0x10E0040B735ED96uLL);
  if (!v5)
  {
    v14 = 65;
    v15 = 236;
    goto LABEL_7;
  }
  v6 = v5;
  v7 = *(_OWORD *)&v4->d2i;
  v8 = *(_OWORD *)&v4->ext_nid;
  *(_OWORD *)&v5->ext_new = *(_OWORD *)&v4->ext_new;
  *(_OWORD *)&v5->d2i = v7;
  *(_OWORD *)&v5->ext_nid = v8;
  v9 = *(_OWORD *)&v4->i2s;
  v10 = *(_OWORD *)&v4->i2v;
  v11 = *(_OWORD *)&v4->i2r;
  v5->usr_data = v4->usr_data;
  *(_OWORD *)&v5->i2v = v10;
  *(_OWORD *)&v5->i2r = v11;
  *(_OWORD *)&v5->i2s = v9;
  v12 = v5->ext_flags | 1;
  v5->ext_nid = nid_to;
  v5->ext_flags = v12;
  if (X509V3_EXT_add(v5))
    return 1;
  free(v6);
  return 0;
}

void X509V3_EXT_cleanup(void)
{
  sk_pop_free((STACK *)ext_list, (void (__cdecl *)(void *))ext_list_free);
  ext_list = 0;
}

void ext_list_free(void *a1)
{
  if ((*((_BYTE *)a1 + 4) & 1) != 0)
    free(a1);
}

int X509V3_add_standard_extensions(void)
{
  return 1;
}

void *__cdecl X509V3_EXT_d2i(X509_EXTENSION *ext)
{
  void *result;
  ASN1_OCTET_STRING *value;
  const ASN1_ITEM *v4;
  unsigned __int8 *in;

  result = X509V3_EXT_get(ext);
  if (result)
  {
    value = ext->value;
    in = value->data;
    v4 = (const ASN1_ITEM *)*((_QWORD *)result + 1);
    if (v4)
      return ASN1_item_d2i(0, (const unsigned __int8 **)&in, value->length, v4);
    else
      return (void *)(*((uint64_t (**)(_QWORD, unsigned __int8 **, _QWORD))result + 4))(0, &in, value->length);
  }
  return result;
}

void *__cdecl X509V3_get_d2i(STACK *x, int nid, int *crit, int *idx)
{
  int v8;
  int v9;
  char *v10;
  char *v11;
  int v12;

  if (x)
  {
    v8 = idx ? *idx + 1 : 0;
    v9 = v8 & ~(v8 >> 31);
    if (v9 < sk_num(x))
    {
      v10 = 0;
      while (1)
      {
        v11 = sk_value(x, v9);
        if (OBJ_obj2nid(*(const ASN1_OBJECT **)v11) == nid)
        {
          if (idx)
          {
            *idx = v9;
LABEL_21:
            if (crit)
              *crit = X509_EXTENSION_get_critical((X509_EXTENSION *)v11);
            return X509V3_EXT_d2i((X509_EXTENSION *)v11);
          }
          if (v10)
          {
            if (!crit)
              return 0;
            v12 = -2;
LABEL_18:
            *crit = v12;
            return 0;
          }
        }
        else
        {
          v11 = v10;
        }
        ++v9;
        v10 = v11;
        if (v9 >= sk_num(x))
        {
          if (!v11)
            break;
          goto LABEL_21;
        }
      }
    }
  }
  if (idx)
    *idx = -1;
  if (crit)
  {
    v12 = -1;
    goto LABEL_18;
  }
  return 0;
}

int X509V3_add1_i2d(STACK **x, int nid, void *value, int crit, unint64_t flags)
{
  unint64_t v9;
  char *v10;
  STACK *v11;
  BOOL v12;
  char v14;
  int ext_by_NID;
  int v16;
  char *v17;
  int v18;
  int v19;
  X509_EXTENSION *v20;
  char *v21;
  char *v22;

  v9 = flags & 0xF;
  if (v9 == 1)
  {
LABEL_2:
    v10 = (char *)X509V3_EXT_i2d(nid, crit, value);
    if (v10)
    {
      v11 = *x;
      if (*x || (v11 = sk_new_null(), (*x = v11) != 0))
      {
        v12 = sk_push(v11, v10) == 0;
        goto LABEL_6;
      }
      return -1;
    }
    goto LABEL_24;
  }
  v14 = flags;
  ext_by_NID = X509v3_get_ext_by_NID(*x, nid, -1);
  if (ext_by_NID < 0)
  {
    v18 = 102;
    if (v9 != 3 && v9 != 5)
      goto LABEL_2;
    if ((v14 & 0x10) != 0)
      return 0;
LABEL_21:
    v19 = 433;
LABEL_25:
    ERR_put_error(34, 4095, v18, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_lib.c", v19);
    return 0;
  }
  if (!v9)
  {
    v18 = 145;
    if ((v14 & 0x10) != 0)
      return 0;
    goto LABEL_21;
  }
  if (v9 == 4)
    return 1;
  v16 = ext_by_NID;
  if (v9 == 5)
  {
    v17 = sk_delete(*x, ext_by_NID);
    if (!v17)
      return -1;
    X509_EXTENSION_free((X509_EXTENSION *)v17);
    return 1;
  }
  v20 = X509V3_EXT_i2d(nid, crit, value);
  if (!v20)
  {
LABEL_24:
    v18 = 144;
    v19 = 411;
    goto LABEL_25;
  }
  v21 = (char *)v20;
  v22 = sk_value(*x, v16);
  X509_EXTENSION_free((X509_EXTENSION *)v22);
  v12 = sk_set(*x, v16, v21) == 0;
LABEL_6:
  if (v12)
    return -1;
  else
    return 1;
}

uint64_t ext_cmp_BSEARCH_CMP_FN(_DWORD **a1, _DWORD **a2)
{
  return (**a1 - **a2);
}

int ASN1_parse(BIO *bp, const unsigned __int8 *pp, uint64_t len, int indent)
{
  unsigned __int8 *v5;

  v5 = (unsigned __int8 *)pp;
  return asn1_parse2(bp, &v5, len, 0, 0, indent, 0);
}

uint64_t asn1_parse2(BIO *a1, unsigned __int8 **a2, uint64_t a3, int a4, int a5, unsigned int a6, uint64_t a7)
{
  unsigned __int8 *v9;
  uint64_t v10;
  ASN1_OCTET_STRING *v11;
  ASN1_INTEGER *v12;
  ASN1_ENUMERATED *v13;
  uint64_t v15;
  uint64_t v16;
  int v17;
  int object;
  int v19;
  uint64_t v20;
  int v21;
  int v22;
  int v23;
  int v24;
  int v25;
  char *v26;
  const char *v27;
  uint64_t v28;
  unsigned __int8 *v29;
  unint64_t v30;
  unsigned __int8 *v31;
  uint64_t v32;
  unint64_t v33;
  uint64_t v34;
  uint64_t v35;
  int v36;
  int v37;
  BOOL v38;
  uint64_t length;
  uint64_t v40;
  int v42;
  ASN1_OCTET_STRING *v43;
  uint64_t v44;
  unsigned __int8 *data;
  unsigned __int8 v46;
  unsigned int v47;
  BOOL v48;
  int v49;
  uint64_t v51;
  uint64_t v52;
  BIO *v53;
  const char *v54;
  int v55;
  BOOL v56;
  int v57;
  uint64_t v58;
  uint64_t v59;
  unint64_t v62;
  int indent;
  uint64_t v64;
  unsigned int v65;
  ASN1_OBJECT *a;
  int pclass[2];
  uint64_t plength;
  unsigned __int8 *in;
  unsigned __int8 *pp;
  char __str[128];
  uint64_t v72;

  v72 = *MEMORY[0x24BDAC8D0];
  plength = 0;
  in = 0;
  a = 0;
  *(_QWORD *)pclass = 0;
  v9 = *a2;
  pp = *a2;
  if (a5 > 128)
  {
    BIO_printf(a1, "Max depth exceeded\n");
LABEL_3:
    v10 = 0;
LABEL_4:
    v11 = 0;
    goto LABEL_5;
  }
  v15 = a3;
  if (a3 < 1)
  {
    v11 = 0;
    v12 = 0;
    v13 = 0;
    v10 = 1;
    goto LABEL_7;
  }
  v16 = a7;
  v64 = a4;
  if (a6)
    v17 = a5;
  else
    v17 = 0;
  indent = v17;
  v65 = a5 + 1;
  v59 = (int)a7;
  v62 = (unint64_t)&v9[a3];
  while (1)
  {
    object = ASN1_get_object((const unsigned __int8 **)&pp, &plength, &pclass[1], pclass, v15);
    if ((object & 0x80) != 0)
    {
      BIO_write(a1, "Error in encoding\n", 18);
      goto LABEL_3;
    }
    v19 = object;
    v20 = v16;
    v21 = (int)pp;
    if (BIO_printf(a1, "%5ld:", &v9[v64] - *a2) < 1)
      goto LABEL_3;
    v22 = v21 - (_DWORD)v9;
    v23 = v19 == 33 ? BIO_printf(a1, "d=%-2d hl=%ld l=inf  ") : BIO_printf(a1, "d=%-2d hl=%ld l=%4ld ");
    if (v23 < 1)
      goto LABEL_3;
    v24 = pclass[0];
    v25 = pclass[1];
    v26 = (v19 & 0x20) != 0 ? "cons: " : "prim: ";
    if (BIO_write(a1, v26, 6) < 6 || !BIO_indent(a1, indent, 128))
      goto LABEL_3;
    if ((~v24 & 0xC0) != 0)
    {
      if ((v24 & 0x80) != 0)
      {
        v27 = __str;
        snprintf(__str, 0x80uLL, "cont [ %d ]");
      }
      else if ((v24 & 0x40) != 0)
      {
        v27 = __str;
        snprintf(__str, 0x80uLL, "appl [ %d ]");
      }
      else if (v25 < 31)
      {
        v27 = ASN1_tag2str(v25);
      }
      else
      {
        v27 = __str;
        snprintf(__str, 0x80uLL, "<ASN1 %d>");
      }
    }
    else
    {
      v27 = __str;
      snprintf(__str, 0x80uLL, "priv [ %d ] ");
    }
    if (BIO_printf(a1, "%-18s", v27) <= 0)
      goto LABEL_3;
    v28 = v15 - v22;
    if ((v19 & 0x20) == 0)
      break;
    v31 = pp;
    v32 = plength;
    if (BIO_write(a1, "\n", 1) < 1)
      goto LABEL_3;
    if (plength > v28)
    {
      BIO_printf(a1, "length is greater than %ld\n");
      goto LABEL_3;
    }
    v33 = (unint64_t)&v31[v32];
    v16 = v20;
    v30 = v62;
    v34 = v65;
    if (v19 != 33 || plength)
    {
      while (1)
      {
        v29 = pp;
        if ((unint64_t)pp >= v33)
          break;
        if (!asn1_parse2(a1, &pp, v33 - (_QWORD)pp, ((_DWORD)pp - *(_DWORD *)a2 + a4), v65, a6, v16))goto LABEL_3;
      }
    }
    else
    {
      v29 = pp;
      while (1)
      {
        v35 = asn1_parse2(a1, &pp, v62 - (_QWORD)v29, ((_DWORD)v29 - *(_DWORD *)a2 + a4), v34, a6, v16);
        v10 = v35;
        if (!(_DWORD)v35)
          goto LABEL_4;
        if ((_DWORD)v35 == 2)
          break;
        v29 = pp;
        v34 = v65;
        if ((unint64_t)pp >= v62)
          goto LABEL_60;
      }
      v29 = pp;
LABEL_60:
      plength = (uint64_t)&v29[-v33];
    }
LABEL_61:
    v11 = 0;
    v12 = 0;
    v13 = 0;
    v15 = v28 - plength;
    v10 = 1;
    v38 = (unint64_t)v29 >= v30 || v9 >= v29;
    v9 = v29;
    if (v38)
      goto LABEL_7;
  }
  if (pclass[0])
  {
    pp += plength;
    if (BIO_write(a1, "\n", 1) < 1)
      goto LABEL_3;
    v16 = v20;
    v29 = pp;
    v30 = v62;
    goto LABEL_61;
  }
  v16 = v20;
  switch(pclass[1])
  {
    case 1:
      if (plength == 1 && (unint64_t)pp < v62)
      {
        BIO_printf(a1, ":%u", *pp);
        goto LABEL_55;
      }
      v53 = a1;
      v54 = "Bad BOOLean\n";
      v55 = 12;
      goto LABEL_126;
    case 2:
      in = v9;
      v12 = d2i_ASN1_INTEGER(0, (const unsigned __int8 **)&in, plength + v22);
      if (v12)
      {
        if (BIO_write(a1, ":", 1) < 1 || v12->type == 258 && BIO_write(a1, "-", 1) < 1)
          goto LABEL_149;
        LODWORD(length) = v12->length;
        if (v12->length >= 1)
        {
          v40 = 0;
          do
          {
            if (BIO_printf(a1, "%02X", v12->data[v40]) < 1)
              goto LABEL_149;
            ++v40;
            length = v12->length;
          }
          while (v40 < length);
          v16 = v20;
        }
        if (!(_DWORD)length && BIO_write(a1, "00", 2) < 1)
        {
LABEL_149:
          v10 = 0;
          v11 = 0;
          goto LABEL_6;
        }
      }
      else if (BIO_write(a1, "BAD INTEGER", 11) < 1)
      {
        goto LABEL_3;
      }
      ASN1_INTEGER_free(v12);
      goto LABEL_55;
    case 4:
      in = v9;
      v43 = d2i_ASN1_OCTET_STRING(0, (const unsigned __int8 **)&in, plength + v22);
      v11 = v43;
      if (!v43)
        goto LABEL_106;
      v44 = v43->length;
      if ((int)v44 < 1)
        goto LABEL_106;
      data = v43->data;
      in = data;
      v16 = v20;
      break;
    case 6:
      in = v9;
      if (d2i_ASN1_OBJECT(&a, (const unsigned __int8 **)&in, plength + v22))
      {
        if (BIO_write(a1, ":", 1) < 1)
          goto LABEL_3;
        i2a_ASN1_OBJECT(a1, a);
      }
      else
      {
        v53 = a1;
        v54 = ":BAD OBJECT";
        v55 = 11;
LABEL_126:
        if (BIO_write(v53, v54, v55) < 1)
          goto LABEL_3;
      }
      goto LABEL_55;
    case 0xA:
      in = v9;
      v13 = d2i_ASN1_ENUMERATED(0, (const unsigned __int8 **)&in, plength + v22);
      if (v13)
      {
        if (BIO_write(a1, ":", 1) < 1 || v13->type == 266 && BIO_write(a1, "-", 1) < 1)
          goto LABEL_150;
        LODWORD(v51) = v13->length;
        if (v13->length >= 1)
        {
          v52 = 0;
          do
          {
            if (BIO_printf(a1, "%02X", v13->data[v52]) < 1)
              goto LABEL_150;
            ++v52;
            v51 = v13->length;
          }
          while (v52 < v51);
          v16 = v20;
        }
        if (!(_DWORD)v51 && BIO_write(a1, "00", 2) < 1)
        {
LABEL_150:
          v10 = 0;
          v11 = 0;
          v12 = 0;
          goto LABEL_7;
        }
      }
      else if (BIO_write(a1, "BAD ENUMERATED", 14) < 1)
      {
        goto LABEL_3;
      }
      ASN1_ENUMERATED_free(v13);
      goto LABEL_55;
    case 0xC:
    case 0x12:
    case 0x13:
    case 0x14:
    case 0x16:
    case 0x17:
    case 0x18:
    case 0x1A:
      if (BIO_write(a1, ":", 1) < 1)
        goto LABEL_3;
      if (plength >= 1)
      {
        v36 = BIO_write(a1, pp, plength);
        if (v36 != (_DWORD)plength)
          goto LABEL_3;
      }
      goto LABEL_55;
    case 0x1E:
      goto LABEL_55;
    default:
      if (!(_DWORD)v20 || plength < 1)
        goto LABEL_55;
      if (BIO_write(a1, "\n", 1) < 1)
        goto LABEL_3;
      if (plength < v59 || (_DWORD)v20 == -1)
        v42 = plength;
      else
        v42 = v59;
      v37 = BIO_dump_indent(a1, (const char *)pp, v42, 6);
      goto LABEL_56;
  }
  while (2)
  {
    v46 = *data++;
    v47 = v46;
    if (v46 > 0x1Fu)
    {
      if (v47 > 0x7E)
        goto LABEL_130;
LABEL_103:
      if (--v44)
        continue;
      if (BIO_write(a1, ":", 1) < 1 || BIO_write(a1, in, v11->length) < 1)
        goto LABEL_151;
LABEL_106:
      ASN1_OCTET_STRING_free(v11);
      v16 = v20;
LABEL_55:
      v37 = BIO_write(a1, "\n", 1);
LABEL_56:
      if (v37 < 1)
        goto LABEL_3;
LABEL_57:
      v29 = &pp[plength];
      pp += plength;
      v30 = v62;
      if (!*(_QWORD *)pclass)
      {
        v11 = 0;
        v12 = 0;
        v13 = 0;
        v10 = 2;
        goto LABEL_7;
      }
      goto LABEL_61;
    }
    break;
  }
  v48 = v47 > 0xD;
  v49 = (1 << v47) & 0x2600;
  if (!v48 && v49 != 0)
    goto LABEL_103;
LABEL_130:
  if (!(_DWORD)v20)
  {
    if (BIO_write(a1, "[HEX DUMP]:", 11) < 1)
      goto LABEL_151;
    if (v11->length >= 1)
    {
      v58 = 0;
      while (BIO_printf(a1, "%02X", in[v58]) >= 1)
      {
        if (++v58 >= v11->length)
          goto LABEL_106;
      }
      goto LABEL_151;
    }
    goto LABEL_106;
  }
  if (BIO_write(a1, "\n", 1) >= 1)
  {
    v56 = v11->length < (int)v20 || (_DWORD)v20 == -1;
    v57 = v56 ? v11->length : v20;
    if (BIO_dump_indent(a1, (const char *)in, v57, 6) >= 1)
    {
      ASN1_OCTET_STRING_free(v11);
      goto LABEL_57;
    }
  }
LABEL_151:
  v10 = 0;
LABEL_5:
  v12 = 0;
LABEL_6:
  v13 = 0;
LABEL_7:
  if (a)
    ASN1_OBJECT_free(a);
  ASN1_OCTET_STRING_free(v11);
  ASN1_INTEGER_free(v12);
  ASN1_ENUMERATED_free(v13);
  *a2 = pp;
  return v10;
}

int ASN1_parse_dump(BIO *bp, const unsigned __int8 *pp, uint64_t len, int indent, int dump)
{
  unsigned __int8 *v6;

  v6 = (unsigned __int8 *)pp;
  return asn1_parse2(bp, &v6, len, 0, 0, indent, *(uint64_t *)&dump);
}

void ENGINE_unregister_RSA(ENGINE *e)
{
  engine_table_unregister(&rsa_table, e);
}

int ENGINE_register_RSA(ENGINE *e)
{
  if (*((_QWORD *)e + 2))
    return engine_table_register(&rsa_table, (uint64_t)engine_unregister_all_RSA, (char *)e, &dummy_nid, 1, 0);
  else
    return 1;
}

void engine_unregister_all_RSA()
{
  engine_table_cleanup(&rsa_table);
}

void ENGINE_register_all_RSA(void)
{
  ENGINE *first;
  ENGINE *next;

  first = ENGINE_get_first();
  if (first)
  {
    next = first;
    do
    {
      if (*((_QWORD *)next + 2))
        engine_table_register(&rsa_table, (uint64_t)engine_unregister_all_RSA, (char *)next, &dummy_nid, 1, 0);
      next = ENGINE_get_next(next);
    }
    while (next);
  }
}

int ENGINE_set_default_RSA(ENGINE *e)
{
  if (*((_QWORD *)e + 2))
    return engine_table_register(&rsa_table, (uint64_t)engine_unregister_all_RSA, (char *)e, &dummy_nid, 1, 1);
  else
    return 1;
}

ENGINE *ENGINE_get_default_RSA(void)
{
  return (ENGINE *)engine_table_select(&rsa_table, 1);
}

const RSA_METHOD *__cdecl ENGINE_get_RSA(const ENGINE *e)
{
  return (const RSA_METHOD *)*((_QWORD *)e + 2);
}

int ENGINE_set_RSA(ENGINE *e, const RSA_METHOD *rsa_meth)
{
  *((_QWORD *)e + 2) = rsa_meth;
  return 1;
}

void *EVP_streebog256()
{
  return &streebog256_md;
}

void *EVP_streebog512()
{
  return &streebog512_md;
}

uint64_t streebog_init256(uint64_t a1)
{
  return STREEBOG256_Init(*(_QWORD *)(a1 + 24));
}

uint64_t streebog_update256(uint64_t a1, char *a2, size_t a3)
{
  return STREEBOG256_Update(*(_DWORD **)(a1 + 24), a2, a3);
}

uint64_t streebog_final256(uint64_t a1, uint64_t a2)
{
  return STREEBOG256_Final(a2, *(_QWORD *)(a1 + 24));
}

uint64_t streebog_init512(uint64_t a1)
{
  return STREEBOG512_Init(*(_QWORD *)(a1 + 24));
}

uint64_t streebog_update512(uint64_t a1, char *a2, size_t a3)
{
  return STREEBOG512_Update(*(_DWORD **)(a1 + 24), a2, a3);
}

uint64_t streebog_final512(uint64_t a1, uint64_t a2)
{
  return STREEBOG512_Final(a2, *(_QWORD *)(a1 + 24));
}

void *BIO_f_asn1()
{
  return &methods_asn1;
}

uint64_t BIO_asn1_set_prefix(BIO *a1, uint64_t a2, uint64_t a3)
{
  _QWORD v4[2];

  v4[0] = a2;
  v4[1] = a3;
  return BIO_ctrl(a1, 149, 0, v4);
}

uint64_t BIO_asn1_get_prefix(BIO *a1, _QWORD *a2, _QWORD *a3)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  v7 = 0;
  v8 = 0;
  result = BIO_ctrl(a1, 150, 0, &v7);
  if ((int)result >= 1)
  {
    v6 = v8;
    *a2 = v7;
    *a3 = v6;
  }
  return result;
}

uint64_t BIO_asn1_set_suffix(BIO *a1, uint64_t a2, uint64_t a3)
{
  _QWORD v4[2];

  v4[0] = a2;
  v4[1] = a3;
  return BIO_ctrl(a1, 151, 0, v4);
}

uint64_t BIO_asn1_get_suffix(BIO *a1, _QWORD *a2, _QWORD *a3)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  v7 = 0;
  v8 = 0;
  result = BIO_ctrl(a1, 152, 0, &v7);
  if ((int)result >= 1)
  {
    v6 = v8;
    *a2 = v7;
    *a3 = v6;
  }
  return result;
}

uint64_t asn1_bio_write(BIO *b, char *data, int length)
{
  uint64_t result;
  int v5;
  bio_st *next_bio;
  char *v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  int shutdown;
  int v14;
  int v15;
  unsigned int v16;
  unsigned __int8 *pp;

  result = 0;
  if (data)
  {
    v5 = length;
    if ((length & 0x80000000) == 0)
    {
      if (b->prev_bio)
      {
        next_bio = b->next_bio;
        if (next_bio)
        {
          v7 = data;
          v8 = 0;
          pp = 0;
          while (1)
          {
            switch(LODWORD(next_bio->method))
            {
              case 0:
                result = asn1_bio_setup_ex(b, next_bio, *(unsigned int (**)(BIO *, _DWORD *, _DWORD *, _DWORD *))&next_bio->num, 1, 2);
                if ((_DWORD)result)
                  continue;
                return result;
              case 1:
                v9 = asn1_bio_flush_ex((uint64_t)b, (uint64_t)next_bio, (void (*)(uint64_t, uint64_t, int *, uint64_t))next_bio->ptr, 2);
                if (v9 >= 1)
                  continue;
                v16 = v9;
                goto LABEL_30;
              case 2:
                v10 = ASN1_object_size(0, v5, next_bio->retry_reason) - v5;
                if (v10 < 1 || v10 > SLODWORD(next_bio->cb_arg))
                  return 0xFFFFFFFFLL;
                next_bio->init = v10;
                pp = (unsigned __int8 *)next_bio->callback;
                ASN1_put_object(&pp, 0, v5, next_bio->retry_reason, next_bio->flags);
                next_bio->shutdown = v5;
                LODWORD(next_bio->method) = 3;
                break;
              case 3:
                v11 = BIO_write(b->prev_bio, (char *)next_bio->callback + SHIDWORD(next_bio->cb_arg), next_bio->init);
                v16 = v11;
                if (v11 < 1)
                  goto LABEL_30;
                v12 = next_bio->init - v11;
                next_bio->init = v12;
                if (v12)
                {
                  HIDWORD(next_bio->cb_arg) += v11;
                }
                else
                {
                  HIDWORD(next_bio->cb_arg) = 0;
                  LODWORD(next_bio->method) = 4;
                }
                continue;
              case 4:
                if (v5 >= next_bio->shutdown)
                  shutdown = next_bio->shutdown;
                else
                  shutdown = v5;
                v14 = BIO_write(b->prev_bio, v7, shutdown);
                v16 = v14;
                if (v14 >= 1)
                {
                  v15 = next_bio->shutdown - v14;
                  next_bio->shutdown = v15;
                  if (!v15)
                    LODWORD(next_bio->method) = 2;
                  v8 += v14;
                  v7 += v14;
                  v5 -= v14;
                  if (v5)
                    continue;
                }
LABEL_30:
                BIO_clear_flags(b, 15);
                BIO_copy_next_retry(b);
                if (v8 <= 0)
                  return v16;
                else
                  return v8;
              default:
                BIO_clear_flags(b, 15);
                return 0;
            }
          }
        }
      }
      return 0;
    }
  }
  return result;
}

BIO *asn1_bio_read(uint64_t a1, void *a2, int a3)
{
  BIO *result;

  result = *(BIO **)(a1 + 64);
  if (result)
    return (BIO *)BIO_read(result, a2, a3);
  return result;
}

uint64_t asn1_bio_puts(BIO *a1, char *__s)
{
  int v4;

  v4 = strlen(__s);
  return asn1_bio_write(a1, __s, v4);
}

BIO *asn1_bio_gets(uint64_t a1, char *a2, int a3)
{
  BIO *result;

  result = *(BIO **)(a1 + 64);
  if (result)
    return (BIO *)BIO_gets(result, a2, a3);
  return result;
}

uint64_t asn1_bio_ctrl(BIO *b, int a2, uint64_t larg, _OWORD *parg)
{
  bio_st *next_bio;
  int method;
  uint64_t result;
  __int128 v10;

  next_bio = b->next_bio;
  if (next_bio)
  {
    switch(a2)
    {
      case 149:
        *(_OWORD *)&next_bio->num = *parg;
        return 1;
      case 150:
        v10 = *(_OWORD *)&next_bio->num;
        goto LABEL_17;
      case 151:
        *(_OWORD *)&next_bio->next_bio = *parg;
        return 1;
      case 152:
        v10 = *(_OWORD *)&next_bio->next_bio;
LABEL_17:
        *parg = v10;
        return 1;
      case 153:
        next_bio->num_write = (unint64_t)parg;
        return 1;
      case 154:
        *(_QWORD *)parg = next_bio->num_write;
        return 1;
      default:
        if (a2 != 11)
        {
          result = (uint64_t)b->prev_bio;
          if (!result)
            return result;
          return BIO_ctrl((BIO *)result, a2, larg, parg);
        }
        if (!b->prev_bio)
          return 0;
        method = (int)next_bio->method;
        if (LODWORD(next_bio->method) == 2)
        {
          if (!asn1_bio_setup_ex(b, b->next_bio, next_bio->next_bio, 5, 6))
            return 0;
          method = (int)next_bio->method;
        }
        if (method != 5)
          goto LABEL_12;
        LODWORD(result) = asn1_bio_flush_ex((uint64_t)b, (uint64_t)next_bio, (void (*)(uint64_t, uint64_t, int *, uint64_t))next_bio->prev_bio, 6);
        if ((int)result < 1)
          return (int)result;
        method = (int)next_bio->method;
LABEL_12:
        if (method == 6)
        {
          result = (uint64_t)b->prev_bio;
          a2 = 11;
          return BIO_ctrl((BIO *)result, a2, larg, parg);
        }
        BIO_clear_flags(b, 15);
        break;
    }
  }
  return 0;
}

uint64_t asn1_bio_new(uint64_t a1)
{
  uint64_t result;
  _QWORD *v3;
  void *v4;

  result = (uint64_t)malloc_type_calloc(1uLL, 0x60uLL, 0x109004097C5DC90uLL);
  if (result)
  {
    v3 = (_QWORD *)result;
    v4 = malloc_type_malloc(0x14uLL, 0x8883FF2DuLL);
    v3[1] = v4;
    if (v4)
    {
      *((_DWORD *)v3 + 4) = 20;
      v3[4] = 0x400000000;
      *(_DWORD *)v3 = 0;
      result = 1;
      *(_DWORD *)(a1 + 32) = 1;
      *(_QWORD *)(a1 + 56) = v3;
      *(_DWORD *)(a1 + 40) = 0;
    }
    else
    {
      free(v3);
      return 0;
    }
  }
  return result;
}

uint64_t asn1_bio_free(uint64_t a1)
{
  uint64_t v1;
  void (*v3)(uint64_t, uint64_t, uint64_t, uint64_t);
  void (*v4)(uint64_t, uint64_t, uint64_t, uint64_t);
  uint64_t result;

  v1 = *(_QWORD *)(a1 + 56);
  if (!v1)
    return 0;
  v3 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v1 + 48);
  if (v3)
    v3(a1, v1 + 72, v1 + 80, v1 + 88);
  v4 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v1 + 64);
  if (v4)
    v4(a1, v1 + 72, v1 + 80, v1 + 88);
  free(*(void **)(v1 + 8));
  free((void *)v1);
  *(_DWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 56) = 0;
  result = 1;
  *(_DWORD *)(a1 + 40) = 0;
  return result;
}

BIO *asn1_bio_callback_ctrl(uint64_t a1, int a2, void (__cdecl *a3)(bio_st *, int, const char *, int, uint64_t, uint64_t))
{
  BIO *result;

  result = *(BIO **)(a1 + 64);
  if (result)
    return (BIO *)BIO_callback_ctrl(result, a2, a3);
  return result;
}

uint64_t asn1_bio_setup_ex(BIO *a1, _DWORD *a2, unsigned int (*a3)(BIO *, _DWORD *, _DWORD *, _DWORD *), int a4, int a5)
{
  int v9;

  if (a3 && !a3(a1, a2 + 18, a2 + 20, a2 + 22))
  {
    BIO_clear_flags(a1, 15);
    return 0;
  }
  else
  {
    if ((int)a2[20] <= 0)
      v9 = a5;
    else
      v9 = a4;
    *a2 = v9;
    return 1;
  }
}

uint64_t asn1_bio_flush_ex(uint64_t a1, uint64_t a2, void (*a3)(uint64_t, uint64_t, int *, uint64_t), int a4)
{
  int v5;
  int *v6;
  uint64_t v10;
  BIO *v11;
  const void *i;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;

  v6 = (int *)(a2 + 80);
  v5 = *(_DWORD *)(a2 + 80);
  if (v5 < 1)
    return 1;
  v10 = a2 + 72;
  v11 = *(BIO **)(a1 + 64);
  for (i = (const void *)(*(_QWORD *)(a2 + 72) + *(int *)(a2 + 84)); ; i = (const void *)(*(_QWORD *)(a2 + 72) + v15))
  {
    v13 = BIO_write(v11, i, v5);
    v14 = v13;
    if ((int)v13 < 1)
      break;
    v5 = *v6 - v13;
    *v6 = v5;
    if (v5 < 1)
    {
      if (a3)
        a3(a1, v10, v6, a2 + 88);
      *(_DWORD *)a2 = a4;
      *(_DWORD *)(a2 + 84) = 0;
      return v14;
    }
    v15 = *(int *)(a2 + 84) + (uint64_t)(int)v13;
    *(_DWORD *)(a2 + 84) = v15;
    v11 = *(BIO **)(a1 + 64);
  }
  return v14;
}

const EVP_CIPHER *EVP_desx_cbc(void)
{
  return (const EVP_CIPHER *)&d_xcbc_cipher;
}

uint64_t desx_cbc_init_key(uint64_t a1, const_DES_cblock *key)
{
  DES_set_key_unchecked(key, *(DES_key_schedule **)(a1 + 120));
  *(_QWORD *)(*(_QWORD *)(a1 + 120) + 128) = *(_QWORD *)&(*key)[8];
  *(_QWORD *)(*(_QWORD *)(a1 + 120) + 136) = *(_QWORD *)&(*key)[16];
  return 1;
}

uint64_t desx_cbc_cipher(uint64_t a1, unsigned __int8 *output, unsigned __int8 *input, unint64_t a4)
{
  uint64_t v4;
  uint64_t v8;
  BOOL v9;

  v4 = a4;
  if (!(a4 >> 62))
  {
    v8 = a4;
    if (!a4)
      return 1;
    goto LABEL_4;
  }
  do
  {
    DES_xcbc_encrypt(input, output, 0x4000000000000000, *(DES_key_schedule **)(a1 + 120), (DES_cblock *)(a1 + 40), (const_DES_cblock *)(*(_QWORD *)(a1 + 120) + 128), (const_DES_cblock *)(*(_QWORD *)(a1 + 120) + 136), *(_DWORD *)(a1 + 16));
    v8 = v4 - 0x4000000000000000;
    input += 0x4000000000000000;
    output += 0x4000000000000000;
    v9 = v4 < 0x4000000000000000;
    v4 -= 0x4000000000000000;
  }
  while (v9);
  if (v8)
LABEL_4:
    DES_xcbc_encrypt(input, output, v8, *(DES_key_schedule **)(a1 + 120), (DES_cblock *)(a1 + 40), (const_DES_cblock *)(*(_QWORD *)(a1 + 120) + 128), (const_DES_cblock *)(*(_QWORD *)(a1 + 120) + 136), *(_DWORD *)(a1 + 16));
  return 1;
}

uint64_t long_new(_QWORD *a1, uint64_t a2)
{
  *a1 = *(_QWORD *)(a2 + 40);
  return 1;
}

_QWORD *long_free(_QWORD *result, uint64_t a2)
{
  *result = *(_QWORD *)(a2 + 40);
  return result;
}

_QWORD *long_clear(_QWORD *result, uint64_t a2)
{
  *result = *(_QWORD *)(a2 + 40);
  return result;
}

uint64_t long_c2i(uint64_t *a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  const unsigned __int8 **v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v12;
  ASN1_INTEGER *a;
  uint64_t v14;

  a = 0;
  v14 = a2;
  v12 = 0;
  if (a3)
  {
    if (a2)
      v8 = (const unsigned __int8 **)&v14;
    else
      v8 = 0;
    if (!c2i_ASN1_INTEGER(&a, v8, a3) || !ASN1_INTEGER_get_int64(&v12, (unsigned int *)a))
      goto LABEL_11;
    v9 = v12;
  }
  else
  {
    v9 = 0;
  }
  if (v9 != *(_QWORD *)(a6 + 40))
  {
    *a1 = v9;
    v10 = 1;
    goto LABEL_13;
  }
  ERR_put_error(13, 4095, 128, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/x_long.c", 213);
LABEL_11:
  v10 = 0;
LABEL_13:
  ASN1_INTEGER_free(a);
  return v10;
}

uint64_t long_i2c(unint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v4;
  uint64_t v5;
  ASN1_INTEGER *v7;
  ASN1_INTEGER *v8;
  unsigned __int8 **v9;
  uint64_t v11;

  v11 = a2;
  v4 = *a1;
  if (*a1 == *(_QWORD *)(a4 + 40))
    return 0xFFFFFFFFLL;
  v7 = ASN1_INTEGER_new();
  v8 = v7;
  if (v7 && ASN1_INTEGER_set_int64(&v7->length, v4))
  {
    if (a2)
      v9 = (unsigned __int8 **)&v11;
    else
      v9 = 0;
    v5 = i2c_ASN1_INTEGER(v8, v9);
  }
  else
  {
    v5 = 0;
  }
  ASN1_INTEGER_free(v8);
  return v5;
}

BOOL long_print(BIO *a1, _QWORD *a2)
{
  return BIO_printf(a1, "%ld\n", *a2) > 0;
}

BIGNUM *__cdecl BN_mod_sqrt(BIGNUM *ret, const BIGNUM *a, const BIGNUM *n, BN_CTX *ctx)
{
  BIGNUM *v8;
  BIGNUM *v9;
  BIGNUM *v10;
  BIGNUM *v11;
  BIGNUM *v12;
  int is_odd;
  BIGNUM *v14;
  const BIGNUM *v15;
  int v16;
  int v17;
  _BOOL4 v19;
  int v20;
  BIGNUM *v21;
  BIGNUM *v22;
  const BIGNUM *v23;
  int v24;
  int v25;
  BIGNUM *v26;
  const BIGNUM *v27;
  unint64_t v28;
  BIGNUM *v29;
  BIGNUM *v30;
  BIGNUM *v31;
  BIGNUM *v32;
  BIGNUM *v33;
  BIGNUM *v34;
  BIGNUM *v35;
  BIGNUM *v36;
  BIGNUM *v37;
  BIGNUM *v38;
  BIGNUM *v39;
  BIGNUM *v40;
  unsigned int v41;
  unint64_t i;
  int v43;
  int v44;
  int v45;
  BIGNUM *v46;
  const BIGNUM *v47;
  int v48;
  int v49;
  unsigned int v50;
  int v51;
  BIGNUM *b;
  BIGNUM *v53;
  BIGNUM *v54;
  BIGNUM *r;
  BIGNUM *aa;
  BIGNUM *ab;
  BIGNUM *ac;
  int v59;

  v8 = ret;
  if (!ret)
  {
    v8 = BN_new();
    if (!v8)
      goto LABEL_19;
  }
  BN_CTX_start(ctx);
  v9 = BN_CTX_get(ctx);
  if (!v9)
    goto LABEL_18;
  v10 = v9;
  v11 = BN_CTX_get(ctx);
  if (!v11)
    goto LABEL_18;
  v12 = v11;
  if (!BN_nnmod(v10, a, n, ctx))
    goto LABEL_18;
  if (BN_abs_is_word((uint64_t)n, 2))
  {
    is_odd = BN_is_odd((uint64_t)v10);
    goto LABEL_8;
  }
  if (!BN_is_odd((uint64_t)n) || BN_abs_is_word((uint64_t)n, 1))
  {
    v16 = 112;
    v17 = 96;
LABEL_17:
    ERR_put_error(3, 4095, v16, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/bn/bn_mod_sqrt.c", v17);
    goto LABEL_18;
  }
  if (BN_is_zero((uint64_t)v10) || BN_is_one((uint64_t)v10))
  {
    is_odd = BN_is_one((uint64_t)v10);
LABEL_8:
    if (!BN_set_word(v12, is_odd))
      goto LABEL_18;
    goto LABEL_9;
  }
  v20 = BN_kronecker(v10, n, ctx);
  if (v20 == -2)
    goto LABEL_18;
  if (v20 <= 0)
  {
    v16 = 111;
    v17 = 667;
    goto LABEL_17;
  }
  if (!n->top)
    goto LABEL_57;
  if ((~*(_DWORD *)n->d & 3) == 0)
  {
    BN_CTX_start(ctx);
    v21 = BN_CTX_get(ctx);
    if (!v21)
      goto LABEL_13;
    v22 = v21;
    v23 = BN_value_one();
    if (!BN_uadd(v22, n, v23) || !BN_rshift(v22, v22, 2))
      goto LABEL_13;
    v24 = BN_mod_exp_ct(v12, v10, v22, n, ctx);
    goto LABEL_36;
  }
  v28 = *n->d & 7;
  if (v28 != 1)
  {
    if (v28 == 5)
    {
      BN_CTX_start(ctx);
      v29 = BN_CTX_get(ctx);
      if (!v29)
        goto LABEL_13;
      v30 = v29;
      v31 = BN_CTX_get(ctx);
      if (!v31)
        goto LABEL_13;
      v32 = v31;
      v33 = BN_CTX_get(ctx);
      if (!v33)
        goto LABEL_13;
      v34 = v33;
      v35 = BN_CTX_get(ctx);
      if (!v35)
        goto LABEL_13;
      v36 = v35;
      if (!BN_rshift(v34, n, 3))
        goto LABEL_13;
      BN_set_negative(v34, 0);
      if (!BN_mod_lshift1(v36, v10, n, ctx)
        || !BN_mod_exp_ct(v30, v36, v34, n, ctx)
        || !BN_mod_sqr(v32, v30, n, ctx)
        || !BN_mod_mul(v32, v36, v32, n, ctx)
        || !BN_sub_word(v32, 1uLL)
        || !BN_mod_mul(v12, v10, v30, n, ctx))
      {
        goto LABEL_13;
      }
      v24 = BN_mod_mul(v12, v12, v32, n, ctx);
      goto LABEL_36;
    }
LABEL_57:
    v16 = 112;
    v17 = 684;
    goto LABEL_17;
  }
  BN_CTX_start(ctx);
  v37 = BN_CTX_get(ctx);
  if (!v37)
    goto LABEL_13;
  v38 = v37;
  v39 = BN_CTX_get(ctx);
  if (!v39)
    goto LABEL_13;
  v40 = v39;
  r = BN_CTX_get(ctx);
  if (!r)
    goto LABEL_13;
  v54 = BN_CTX_get(ctx);
  if (!v54)
    goto LABEL_13;
  v41 = 0;
  do
    ++v41;
  while (!BN_is_bit_set(n, v41));
  if (!BN_rshift(v40, n, v41))
    goto LABEL_13;
  BN_CTX_start(ctx);
  aa = BN_CTX_get(ctx);
  if (!aa)
    goto LABEL_86;
  v53 = BN_CTX_get(ctx);
  if (!v53)
    goto LABEL_86;
  b = BN_CTX_get(ctx);
  if (!b)
    goto LABEL_86;
  v59 = 0;
  for (i = 2; i != 32; ++i)
  {
    if (!BN_set_word(aa, i) || !bn_mod_sqrt_n_is_non_residue(&v59, aa, (BIGNUM *)n, ctx))
      goto LABEL_86;
    if (v59)
    {
LABEL_81:
      if (!BN_mod_exp_ct(v54, aa, v40, n, ctx))
        goto LABEL_86;
      if (BN_is_zero((uint64_t)v54) || BN_is_one((uint64_t)v54))
      {
        v44 = 112;
        v45 = 295;
      }
      else
      {
        BN_CTX_end(ctx);
        BN_CTX_start(ctx);
        v46 = BN_CTX_get(ctx);
        if (!v46)
          goto LABEL_86;
        v47 = v46;
        if (!BN_rshift1(v46, v40)
          || !BN_mod_exp_ct(r, v10, v47, n, ctx)
          || !BN_mod_sqr(v38, r, n, ctx)
          || !BN_mod_mul(v38, v10, v38, n, ctx))
        {
          goto LABEL_86;
        }
        v48 = BN_mod_mul(r, v10, r, n, ctx);
        BN_CTX_end(ctx);
        if (!v48)
          goto LABEL_13;
LABEL_93:
        if (BN_is_one((uint64_t)v38))
        {
          v24 = bn_copy(v12, r);
LABEL_36:
          v25 = v24;
          BN_CTX_end(ctx);
          if (!v25)
            goto LABEL_18;
          BN_CTX_start(ctx);
          v26 = BN_CTX_get(ctx);
          if (!v26)
            goto LABEL_13;
          v27 = v26;
          if (!BN_lshift1(v26, v12) || BN_ucmp(v27, n) >= 1 && !BN_usub(v12, n, v12))
            goto LABEL_13;
          BN_CTX_end(ctx);
LABEL_9:
          BN_CTX_start(ctx);
          v14 = BN_CTX_get(ctx);
          if (!v14)
            goto LABEL_13;
          v15 = v14;
          if (!BN_mod_sqr(v14, v12, n, ctx))
            goto LABEL_13;
          if (BN_cmp(v15, v10))
          {
            ERR_put_error(3, 4095, 111, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/bn/bn_mod_sqrt.c", 619);
            goto LABEL_13;
          }
          BN_CTX_end(ctx);
          v19 = bn_copy(v8, v12);
          BN_CTX_end(ctx);
          if (!v19)
            goto LABEL_19;
          return v8;
        }
        BN_CTX_start(ctx);
        ab = BN_CTX_get(ctx);
        if (!ab)
          goto LABEL_86;
        v49 = v41 - 2;
        if (v41 < 2)
        {
          v45 = 376;
        }
        else
        {
          if (!BN_is_zero((uint64_t)v38) && !BN_is_one((uint64_t)v38))
          {
            if (bn_copy(ab, v38))
            {
              v50 = 1;
              while (BN_mod_sqr(ab, ab, n, ctx))
              {
                if (BN_is_one((uint64_t)ab))
                {
                  BN_CTX_end(ctx);
                  BN_CTX_start(ctx);
                  ac = BN_CTX_get(ctx);
                  if (!ac
                    || !BN_set_bit(ac, v49)
                    || !BN_mod_exp_ct(ac, v54, ac, n, ctx)
                    || !BN_mod_mul(r, r, ac, n, ctx)
                    || !BN_mod_sqr(v54, ac, n, ctx))
                  {
                    goto LABEL_86;
                  }
                  v51 = BN_mod_mul(v38, v38, v54, n, ctx);
                  BN_CTX_end(ctx);
                  if (v41 > v50)
                  {
                    v41 = v50;
                    if (v51)
                      goto LABEL_93;
                  }
                  goto LABEL_13;
                }
                ++v50;
                if (--v49 == -1)
                {
                  v45 = 402;
                  goto LABEL_112;
                }
              }
            }
            goto LABEL_86;
          }
          v45 = 386;
        }
LABEL_112:
        v44 = 112;
      }
LABEL_85:
      ERR_put_error(3, 4095, v44, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/bn/bn_mod_sqrt.c", v45);
      goto LABEL_86;
    }
  }
  if (BN_set_word(v53, 0x20uLL) && bn_copy(b, n))
  {
    BN_set_negative(b, 0);
    v43 = 128;
    while (bn_rand_interval(aa, v53, b) && bn_mod_sqrt_n_is_non_residue(&v59, aa, (BIGNUM *)n, ctx))
    {
      if (v59)
        goto LABEL_81;
      if (!--v43)
      {
        v44 = 113;
        v45 = 282;
        goto LABEL_85;
      }
    }
  }
LABEL_86:
  BN_CTX_end(ctx);
LABEL_13:
  BN_CTX_end(ctx);
LABEL_18:
  BN_CTX_end(ctx);
LABEL_19:
  if (v8 != ret)
    BN_free(v8);
  return 0;
}

uint64_t bn_mod_sqrt_n_is_non_residue(_DWORD *a1, BIGNUM *a, BIGNUM *b, BN_CTX *ctx)
{
  uint64_t result;

  result = BN_kronecker(a, b, ctx);
  if ((_DWORD)result == 1)
  {
    *a1 = 0;
  }
  else
  {
    if ((_DWORD)result)
    {
      if ((_DWORD)result == -1)
      {
        result = 1;
        *a1 = 1;
        return result;
      }
    }
    else
    {
      ERR_put_error(3, 4095, 112, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/bn/bn_mod_sqrt.c", 221);
    }
    return 0;
  }
  return result;
}

void ERR_print_errors_cb(int (__cdecl *cb)(const char *, size_t, void *), void *u)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  int (*v5)(char *, size_t, uint64_t);
  uint64_t v6;
  unint64_t error_line_data;
  const char *v8;
  size_t v9;
  _QWORD v10[2];
  int flags[2];
  char *data;
  char *file;
  char __str[4096];
  char v15[256];
  uint64_t v16;

  v2 = MEMORY[0x24BDAC7A8](cb);
  v4 = v3;
  v5 = (int (*)(char *, size_t, uint64_t))v2;
  v16 = *MEMORY[0x24BDAC8D0];
  data = 0;
  file = 0;
  v10[1] = 0;
  *(_QWORD *)flags = 0;
  v10[0] = 0;
  CRYPTO_THREADID_current(v10);
  v6 = CRYPTO_THREADID_hash((uint64_t)v10);
  do
  {
    error_line_data = ERR_get_error_line_data((const char **)&file, &flags[1], (const char **)&data, flags);
    if (!error_line_data)
      break;
    ERR_error_string_n(error_line_data, v15, 0x100uLL);
    v8 = (flags[0] & 2) != 0 ? data : "";
    snprintf(__str, 0x1000uLL, "%lu:%s:%s:%d:%s\n", v6, v15, file, flags[1], v8);
    v9 = strlen(__str);
  }
  while (v5(__str, v9, v4) > 0);
}

void ERR_print_errors_fp(FILE *fp)
{
  ERR_print_errors_cb((int (__cdecl *)(const char *, size_t, void *))print_fp, fp);
}

uint64_t print_fp(const char *a1, uint64_t a2, void *a3)
{
  BIO_METHOD *v5;
  BIO a;

  memset(&a, 0, sizeof(a));
  v5 = BIO_s_file();
  BIO_set(&a, v5);
  BIO_ctrl(&a, 106, 0, a3);
  return BIO_printf(&a, "%s", a1);
}

void ERR_print_errors(BIO *bp)
{
  ERR_print_errors_cb((int (__cdecl *)(const char *, size_t, void *))print_bio, bp);
}

uint64_t print_bio(void *data, int len, BIO *b)
{
  return BIO_write(b, data, len);
}

uint64_t eckey_pub_decode(EVP_PKEY *a1, uint64_t a2)
{
  uint64_t result;
  X509_ALGOR *algor;
  EC_KEY *a;
  int pptype[2];
  void *ppval;
  unsigned __int8 *in;

  in = 0;
  *(_QWORD *)pptype = 0;
  ppval = 0;
  algor = 0;
  result = X509_PUBKEY_get0_param(0, &in, pptype, &algor, a2);
  if ((_DWORD)result)
  {
    X509_ALGOR_get0(0, &pptype[1], &ppval, algor);
    a = eckey_type2param(pptype[1], (const ASN1_OBJECT *)ppval);
    if (!a)
    {
      ERR_put_error(16, 4095, 16, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_ameth.c", 209);
      return 0;
    }
    if (o2i_ECPublicKey(&a, (const unsigned __int8 **)&in, pptype[0]))
    {
      EVP_PKEY_assign(a1, 408, (char *)a);
      return 1;
    }
    ERR_put_error(16, 4095, 142, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_ameth.c", 214);
    result = (uint64_t)a;
    if (a)
    {
      EC_KEY_free(a);
      return 0;
    }
  }
  return result;
}

uint64_t eckey_pub_encode(uint64_t a1, uint64_t a2)
{
  EC_KEY *v3;
  int v4;
  unsigned __int8 *v5;
  unsigned __int8 *v6;
  int v7;
  int v8;
  ASN1_OBJECT *v9;
  int v10;
  unsigned __int8 *out;
  int v13;
  ASN1_OBJECT *a;

  v3 = *(EC_KEY **)(a2 + 32);
  a = 0;
  v13 = 0;
  out = 0;
  if (eckey_param2type(&v13, &a, v3))
  {
    v4 = i2o_ECPublicKey(v3, 0);
    if (v4 < 1)
    {
      v6 = 0;
    }
    else
    {
      v5 = (unsigned __int8 *)malloc_type_malloc(v4, 0x8D6A78E8uLL);
      v6 = v5;
      if (v5)
      {
        out = v5;
        v7 = i2o_ECPublicKey(v3, &out);
        if (v7 >= 1)
        {
          v8 = v7;
          v9 = OBJ_nid2obj(408);
          v10 = v13;
          if (X509_PUBKEY_set0_param(a1, v9, v13, a, v6, v8))
            return 1;
          goto LABEL_10;
        }
      }
    }
    v10 = v13;
LABEL_10:
    if (v10 == 6)
      ASN1_OBJECT_free(a);
    else
      ASN1_STRING_free((ASN1_STRING *)a);
    free(v6);
    return 0;
  }
  ERR_put_error(16, 4095, 16, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_ameth.c", 120);
  return 0;
}

uint64_t eckey_pub_cmp(uint64_t a1, uint64_t a2)
{
  const EC_GROUP *v4;
  const EC_POINT *v5;
  const EC_POINT *v6;
  int v7;
  unsigned int v8;

  v4 = EC_KEY_get0_group(*(const EC_KEY **)(a2 + 32));
  v5 = EC_KEY_get0_public_key(*(const EC_KEY **)(a1 + 32));
  v6 = EC_KEY_get0_public_key(*(const EC_KEY **)(a2 + 32));
  v7 = EC_POINT_cmp(v4, v5, v6, 0);
  if (v7 == 1)
    v8 = 0;
  else
    v8 = -2;
  if (v7)
    return v8;
  else
    return 1;
}

uint64_t eckey_pub_print(BIO *a1, uint64_t a2, int a3)
{
  return do_EC_KEY_print(a1, *(EC_KEY **)(a2 + 32), a3, 1);
}

uint64_t eckey_priv_decode(EVP_PKEY *a1, uint64_t a2)
{
  uint64_t result;
  int v4;
  int v5;
  const EC_GROUP *v6;
  EC_POINT *v7;
  const EC_POINT *v8;
  const EC_POINT *v9;
  const BIGNUM *v10;
  int v11;
  int v12;
  X509_ALGOR *algor;
  EC_KEY *a;
  int pptype[2];
  void *ppval;
  unsigned __int8 *in;

  ppval = 0;
  in = 0;
  *(_QWORD *)pptype = 0;
  algor = 0;
  result = PKCS8_pkey_get0(0, &in, pptype, &algor, a2);
  if ((_DWORD)result)
  {
    X509_ALGOR_get0(0, &pptype[1], &ppval, algor);
    a = eckey_type2param(pptype[1], (const ASN1_OBJECT *)ppval);
    if (!a)
    {
LABEL_17:
      v4 = 16;
      v5 = 301;
LABEL_18:
      ERR_put_error(16, 4095, v4, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_ameth.c", v5);
      result = (uint64_t)a;
      if (a)
      {
        EC_KEY_free(a);
        return 0;
      }
      return result;
    }
    if (!d2i_ECPrivateKey(&a, (const unsigned __int8 **)&in, pptype[0]))
    {
      v4 = 142;
      v5 = 261;
      goto LABEL_18;
    }
    if (EC_KEY_get0_public_key(a))
    {
LABEL_5:
      EVP_PKEY_assign(a1, 408, (char *)a);
      return 1;
    }
    v6 = EC_KEY_get0_group(a);
    v7 = EC_POINT_new(v6);
    if (v7)
    {
      v8 = v7;
      v9 = EC_GROUP_get0_generator(v6);
      if (EC_POINT_copy(v8, v9))
      {
        v10 = EC_KEY_get0_private_key(a);
        if (EC_POINT_mul(v6, v8, v10, 0, 0, 0))
        {
          v11 = EC_KEY_set_public_key(a, v8);
          EC_POINT_free(v8);
          if (v11)
            goto LABEL_5;
          v12 = 292;
          goto LABEL_16;
        }
        v12 = 287;
      }
      else
      {
        v12 = 281;
      }
      EC_POINT_free(v8);
    }
    else
    {
      v12 = 276;
    }
LABEL_16:
    ERR_put_error(16, 4095, 16, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_ameth.c", v12);
    goto LABEL_17;
  }
  return result;
}

BOOL eckey_priv_encode(uint64_t a1, uint64_t a2)
{
  const EC_KEY *v3;
  unsigned int enc_flags;
  int v5;
  int v6;
  unsigned __int8 *v7;
  unsigned __int8 *v8;
  int v9;
  ASN1_OBJECT *v10;
  int v12;
  int v13;
  void *pval;
  int ptype;
  unsigned __int8 *out;

  ptype = 0;
  pval = 0;
  v3 = *(const EC_KEY **)(a2 + 32);
  if (eckey_param2type(&ptype, &pval, v3))
  {
    enc_flags = EC_KEY_get_enc_flags(v3);
    EC_KEY_set_enc_flags(v3, enc_flags | 1);
    v5 = i2d_ECPrivateKey(v3, 0);
    if (v5)
    {
      v6 = v5;
      v7 = (unsigned __int8 *)malloc_type_malloc(v5, 0x61B21F8FuLL);
      if (v7)
      {
        v8 = v7;
        out = v7;
        v9 = i2d_ECPrivateKey(v3, &out);
        EC_KEY_set_enc_flags(v3, enc_flags);
        if (v9)
        {
          v10 = OBJ_nid2obj(408);
          return PKCS8_pkey_set0(a1, v10, 0, ptype, pval, v8, v6) != 0;
        }
        free(v8);
        v12 = 16;
        v13 = 348;
      }
      else
      {
        EC_KEY_set_enc_flags(v3, enc_flags);
        v12 = 65;
        v13 = 341;
      }
    }
    else
    {
      EC_KEY_set_enc_flags(v3, enc_flags);
      v12 = 16;
      v13 = 335;
    }
  }
  else
  {
    v12 = 142;
    v13 = 320;
  }
  ERR_put_error(16, 4095, v12, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_ameth.c", v13);
  return 0;
}

uint64_t eckey_priv_print(BIO *a1, uint64_t a2, int a3)
{
  return do_EC_KEY_print(a1, *(EC_KEY **)(a2 + 32), a3, 2);
}

uint64_t int_ec_size(uint64_t a1)
{
  return ECDSA_size(*(const EC_KEY **)(a1 + 32));
}

uint64_t ec_bits(uint64_t a1)
{
  BIGNUM *v2;
  BIGNUM *v3;
  const EC_GROUP *v4;
  uint64_t v5;

  v2 = BN_new();
  if (v2)
  {
    v3 = v2;
    v4 = EC_KEY_get0_group(*(const EC_KEY **)(a1 + 32));
    if (EC_GROUP_get_order(v4, v3, 0))
    {
      v5 = BN_num_bits(v3);
      BN_free(v3);
      return v5;
    }
    BN_free(v3);
  }
  ERR_clear_error();
  return 0;
}

uint64_t ec_security_bits(uint64_t a1)
{
  int v1;
  int v2;
  int v3;
  int v4;
  int v5;
  int v6;
  unsigned int v7;

  v1 = ec_bits(a1);
  if (v1 >= 0)
    v2 = v1;
  else
    v2 = v1 + 1;
  v3 = v2 >> 1;
  if (v1 <= 159)
    v4 = v3;
  else
    v4 = 80;
  if (v1 <= 223)
    v5 = v4;
  else
    v5 = 112;
  if (v1 <= 255)
    v6 = v5;
  else
    v6 = 128;
  if (v1 <= 383)
    v7 = v6;
  else
    v7 = 192;
  if (v1 <= 511)
    return v7;
  else
    return 256;
}

uint64_t eckey_param_decode(EVP_PKEY *a1, const unsigned __int8 **a2, int a3)
{
  char *v4;

  v4 = (char *)d2i_ECParameters(0, a2, a3);
  if (v4)
  {
    EVP_PKEY_assign(a1, 408, v4);
    return 1;
  }
  else
  {
    ERR_put_error(16, 4095, 16, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_ameth.c", 528);
    return 0;
  }
}

uint64_t eckey_param_encode(uint64_t a1, unsigned __int8 **a2)
{
  return i2d_ECParameters(*(EC_KEY **)(a1 + 32), a2);
}

BOOL ec_missing_parameters(uint64_t a1)
{
  return EC_KEY_get0_group(*(const EC_KEY **)(a1 + 32)) == 0;
}

uint64_t ec_copy_parameters(uint64_t a1, uint64_t a2)
{
  EC_KEY *v2;
  const EC_GROUP *v3;

  v2 = *(EC_KEY **)(a1 + 32);
  v3 = EC_KEY_get0_group(*(const EC_KEY **)(a2 + 32));
  return EC_KEY_set_group(v2, v3);
}

BOOL ec_cmp_parameters(uint64_t a1, uint64_t a2)
{
  const EC_GROUP *v3;
  const EC_GROUP *v4;

  v3 = EC_KEY_get0_group(*(const EC_KEY **)(a1 + 32));
  v4 = EC_KEY_get0_group(*(const EC_KEY **)(a2 + 32));
  return EC_GROUP_cmp(v3, v4, 0) == 0;
}

uint64_t eckey_param_print(BIO *a1, uint64_t a2, int a3)
{
  return do_EC_KEY_print(a1, *(EC_KEY **)(a2 + 32), a3, 0);
}

void int_ec_free(uint64_t a1)
{
  EC_KEY_free(*(EC_KEY **)(a1 + 32));
}

uint64_t ec_pkey_ctrl(unsigned int *a1, int a2, uint64_t a3, _QWORD *a4)
{
  uint64_t v4;
  uint64_t v7;
  uint64_t v8;
  ASN1_OBJECT *v9;
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  int v15;
  EVP_CIPHER_CTX *v16;
  const EVP_CIPHER *v17;
  int v18;
  int v19;
  X509_ALGOR *v20;
  ASN1_TYPE *v21;
  int v22;
  int v23;
  ASN1_STRING *v24;
  X509_ALGOR *v25;
  ASN1_OBJECT *v26;
  int v27;
  int v28;
  int v29;
  ASN1_OBJECT *v30;
  ASN1_OBJECT *v31;
  uint64_t v32;
  int v33;
  EVP_MD *v34;
  uint64_t v35;
  const EC_GROUP *v36;
  ASN1_STRING *v37;
  EC_KEY *v38;
  int v39;
  unsigned __int8 *v40;
  unsigned __int8 *v41;
  int v42;
  X509_ALGOR *v43;
  ASN1_OBJECT *v44;
  const char *v45;
  ASN1_TYPE *parameter;
  char *ptr;
  X509_ALGOR *v48;
  uint64_t v49;
  EVP_CIPHER_CTX *v50;
  int v51;
  const char *v52;
  const EVP_CIPHER *cipherbyname;
  const EVP_CIPHER *v54;
  int v55;
  int v56;
  int v57;
  int v59;
  EVP_PKEY *v60;
  EVP_PKEY *v61;
  int v62;
  unsigned __int8 *v63;
  int n;
  EVP_MD *md;
  unsigned __int8 *out;
  unsigned __int8 *in;
  ASN1_STRING *str;
  ASN1_OBJECT *paobj;
  X509_ALGOR *algor;

  v4 = 4294967294;
  switch(a2)
  {
    case 1:
      if (a3)
        return 1;
      LODWORD(str) = 0;
      paobj = 0;
      algor = 0;
      PKCS7_SIGNER_INFO_get0_algs(a4, 0, &algor, &paobj);
      goto LABEL_40;
    case 3:
      *(_DWORD *)a4 = 64;
      return 2;
    case 5:
      if (a3)
        return 1;
      paobj = 0;
      algor = 0;
      LODWORD(str) = 0;
      CMS_SignerInfo_get0_algs(a4, 0, 0, &algor, &paobj);
LABEL_40:
      if (algor)
      {
        if (algor->algorithm)
        {
          v27 = OBJ_obj2nid(algor->algorithm);
          if (v27)
          {
            v28 = v27;
            v29 = EVP_PKEY_id(a1);
            if (OBJ_find_sigid_by_algs(&str, v28, v29))
            {
              v30 = paobj;
              v31 = OBJ_nid2obj((int)str);
              X509_ALGOR_set0((X509_ALGOR *)v30, v31, -1, 0);
              return 1;
            }
          }
        }
      }
      return 0xFFFFFFFFLL;
    case 7:
      if (a3 == 1)
      {
        v32 = CMS_RecipientInfo_get0_pkey_ctx((uint64_t)a4);
        v4 = v32;
        if (!v32)
          return v4;
        if (EVP_PKEY_CTX_get0_peerkey(v32))
          goto LABEL_48;
        md = 0;
        out = 0;
        if (!CMS_RecipientInfo_kari_get0_orig_id((uint64_t)a4, &out, &md, 0, 0, 0))
          return 0;
        if (!out)
          return 0;
        v34 = md;
        if (!md)
          return 0;
        paobj = 0;
        algor = 0;
        LODWORD(v63) = 0;
        in = 0;
        str = 0;
        X509_ALGOR_get0((ASN1_OBJECT **)&algor, (int *)&v63, (void **)&paobj, (X509_ALGOR *)out);
        if (OBJ_obj2nid((const ASN1_OBJECT *)algor) != 408)
          goto LABEL_99;
        if ((_DWORD)v63 == 5 || (_DWORD)v63 == -1)
        {
          v35 = EVP_PKEY_CTX_get0_pkey(v4);
          if (!v35)
            goto LABEL_99;
          v36 = EC_KEY_get0_group(*(const EC_KEY **)(v35 + 32));
          v37 = (ASN1_STRING *)EC_KEY_new();
          str = v37;
          if (!v37 || !EC_KEY_set_group((EC_KEY *)v37, v36))
            goto LABEL_99;
        }
        else
        {
          str = (ASN1_STRING *)eckey_type2param((int)v63, paobj);
          if (!str)
            goto LABEL_99;
        }
        v59 = ASN1_STRING_length((ASN1_STRING *)v34);
        in = (unsigned __int8 *)ASN1_STRING_get0_data((uint64_t)v34);
        if (in)
        {
          if (v59)
          {
            if (o2i_ECPublicKey((EC_KEY **)&str, (const unsigned __int8 **)&in, v59))
            {
              v60 = EVP_PKEY_new();
              if (v60)
              {
                v61 = v60;
                EVP_PKEY_set1_EC_KEY(v60, (ec_key_st *)str);
                v62 = EVP_PKEY_derive_set_peer(v4, v61);
                EC_KEY_free((EC_KEY *)str);
                EVP_PKEY_free(v61);
                if (v62 >= 1)
                {
LABEL_48:
                  paobj = 0;
                  algor = 0;
                  in = 0;
                  if (CMS_RecipientInfo_kari_get0_alg((uint64_t)a4, &algor, &paobj))
                  {
                    v33 = OBJ_obj2nid(algor->algorithm);
                    if (v33
                      && (LODWORD(out) = 0, LODWORD(md) = 0, OBJ_find_sigid_algs(v33, &md, &out))
                      && ((_DWORD)out == 990 || (_DWORD)out == 991)
                      && (int)EVP_PKEY_CTX_ctrl((uint64_t *)v4, 408, 1024) >= 1
                      && (int)EVP_PKEY_CTX_ctrl((uint64_t *)v4, 408, 1024) >= 1
                      && (v45 = OBJ_nid2sn((int)md), EVP_get_digestbyname(v45))
                      && (int)EVP_PKEY_CTX_ctrl((uint64_t *)v4, 408, 1024) > 0)
                    {
                      parameter = algor->parameter;
                      if (parameter->type == 16)
                      {
                        ptr = parameter->value.ptr;
                        str = (ASN1_STRING *)*((_QWORD *)ptr + 1);
                        v48 = d2i_X509_ALGOR(0, (const unsigned __int8 **)&str, *(int *)ptr);
                        if (v48)
                        {
                          v49 = CMS_RecipientInfo_kari_get0_ctx((uint64_t)a4);
                          if (v49)
                          {
                            v50 = (EVP_CIPHER_CTX *)v49;
                            v51 = OBJ_obj2nid(v48->algorithm);
                            v52 = OBJ_nid2sn(v51);
                            cipherbyname = EVP_get_cipherbyname(v52);
                            if (cipherbyname)
                            {
                              v54 = cipherbyname;
                              if ((EVP_CIPHER_flags(cipherbyname) & 0xF0007) == 0x10002)
                              {
                                if (EVP_EncryptInit_ex(v50, v54, 0, 0, 0))
                                {
                                  if (EVP_CIPHER_asn1_to_param(v50, v48->parameter) >= 1)
                                  {
                                    v55 = EVP_CIPHER_CTX_key_length(v50);
                                    if ((int)EVP_PKEY_CTX_ctrl((uint64_t *)v4, 408, 1024) >= 1
                                      && (int)CMS_SharedInfo_encode(&in, (uint64_t)v48, (uint64_t)paobj, v55) >= 1
                                      && (int)EVP_PKEY_CTX_ctrl((uint64_t *)v4, 408, 1024) >= 1)
                                    {
                                      in = 0;
                                      X509_ALGOR_free(v48);
                                      free(in);
                                      return 1;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                        X509_ALGOR_free(v48);
                        free(in);
                      }
                    }
                    else
                    {
                      ERR_put_error(16, 4095, 148, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_ameth.c", 789);
                    }
                  }
                  v56 = 150;
                  v57 = 858;
                  goto LABEL_89;
                }
LABEL_100:
                v56 = 149;
                v57 = 851;
LABEL_89:
                ERR_put_error(16, 4095, v56, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_ameth.c", v57);
                return 0;
              }
            }
          }
        }
LABEL_99:
        EC_KEY_free((EC_KEY *)str);
        EVP_PKEY_free(0);
        goto LABEL_100;
      }
      if (!a3)
      {
        out = 0;
        v7 = CMS_RecipientInfo_get0_pkey_ctx((uint64_t)a4);
        v4 = v7;
        if (v7)
        {
          paobj = 0;
          algor = 0;
          in = 0;
          str = 0;
          n = 0;
          md = 0;
          v8 = EVP_PKEY_CTX_get0_pkey(v7);
          if (CMS_RecipientInfo_kari_get0_orig_id((uint64_t)a4, &algor, &str, 0, 0, 0))
          {
            X509_ALGOR_get0(&paobj, 0, 0, algor);
            v9 = paobj;
            if (v9 == OBJ_nid2obj(0))
            {
              v38 = *(EC_KEY **)(v8 + 32);
              v39 = i2o_ECPublicKey(v38, 0);
              if (v39 < 1)
                goto LABEL_69;
              v40 = (unsigned __int8 *)malloc_type_malloc(v39, 0xDE0365E6uLL);
              out = v40;
              if (!v40)
                goto LABEL_69;
              v41 = v40;
              v63 = v40;
              v42 = i2o_ECPublicKey(v38, &v63);
              if (v42 < 1)
                goto LABEL_69;
              ASN1_STRING_set0(str, v41, v42);
              if (!asn1_abs_set_unused_bits((uint64_t)str, 0))
                goto LABEL_69;
              out = 0;
              v43 = algor;
              v44 = OBJ_nid2obj(408);
              X509_ALGOR_set0(v43, v44, -1, 0);
            }
            v10 = EVP_PKEY_CTX_ctrl((uint64_t *)v4, 408, 1024);
            if (v10 >= 1)
            {
              v11 = v10;
              if (EVP_PKEY_CTX_ctrl((uint64_t *)v4, 408, 1024))
              {
                v12 = EVP_PKEY_CTX_ctrl((uint64_t *)v4, 408, 1024);
                if ((v12 & 0x80000000) == 0)
                {
                  v13 = v12 == 1 ? 991 : v12;
                  v14 = v12 ? v13 : 990;
                  if (v11 == 1 && (int)EVP_PKEY_CTX_ctrl((uint64_t *)v4, 408, 1024) >= 1)
                  {
                    if (md || (md = (EVP_MD *)EVP_sha1(), (int)EVP_PKEY_CTX_ctrl((uint64_t *)v4, 408, 1024) >= 1))
                    {
                      if (CMS_RecipientInfo_kari_get0_alg((uint64_t)a4, &algor, &in))
                      {
                        v15 = EVP_MD_type(md);
                        if (OBJ_find_sigid_by_algs(&n, v15, v14))
                        {
                          v16 = (EVP_CIPHER_CTX *)CMS_RecipientInfo_kari_get0_ctx((uint64_t)a4);
                          v17 = EVP_CIPHER_CTX_cipher(v16);
                          v18 = EVP_CIPHER_type(v17);
                          v19 = EVP_CIPHER_CTX_key_length(v16);
                          v20 = X509_ALGOR_new();
                          if (v20)
                          {
                            v20->algorithm = OBJ_nid2obj(v18);
                            v21 = ASN1_TYPE_new();
                            v20->parameter = v21;
                            if (v21)
                            {
                              if (EVP_CIPHER_param_to_asn1(v16, v21) >= 1)
                              {
                                if (!ASN1_TYPE_get(v20->parameter))
                                {
                                  ASN1_TYPE_free(v20->parameter);
                                  v20->parameter = 0;
                                }
                                if ((int)EVP_PKEY_CTX_ctrl((uint64_t *)v4, 408, 1024) >= 1
                                  && (int)CMS_SharedInfo_encode(&out, (uint64_t)v20, (uint64_t)in, v19) >= 1
                                  && (int)EVP_PKEY_CTX_ctrl((uint64_t *)v4, 408, 1024) >= 1)
                                {
                                  out = 0;
                                  v22 = i2d_X509_ALGOR(v20, &out);
                                  if (v22 >= 1)
                                  {
                                    v23 = v22;
                                    v24 = ASN1_STRING_new();
                                    v4 = (uint64_t)v24;
                                    if (v24)
                                    {
                                      ASN1_STRING_set0(v24, out, v23);
                                      out = 0;
                                      v25 = algor;
                                      v26 = OBJ_nid2obj(n);
                                      X509_ALGOR_set0(v25, v26, 16, (void *)v4);
                                      v4 = 1;
                                    }
                                    goto LABEL_71;
                                  }
                                }
                              }
                            }
                          }
LABEL_70:
                          v4 = 0;
LABEL_71:
                          free(out);
                          X509_ALGOR_free(v20);
                          return v4;
                        }
                      }
                    }
                  }
                }
              }
            }
          }
LABEL_69:
          v20 = 0;
          goto LABEL_70;
        }
      }
      return v4;
    case 8:
      v4 = 1;
      *(_DWORD *)a4 = 1;
      return v4;
    default:
      return v4;
  }
}

uint64_t old_ec_priv_decode(EVP_PKEY *a1, const unsigned __int8 **a2, int a3)
{
  char *v4;

  v4 = (char *)d2i_ECPrivateKey(0, a2, a3);
  if (v4)
  {
    EVP_PKEY_assign(a1, 408, v4);
    return 1;
  }
  else
  {
    ERR_put_error(16, 4095, 142, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_ameth.c", 569);
    return 0;
  }
}

uint64_t old_ec_priv_encode(uint64_t a1, unsigned __int8 **a2)
{
  return i2d_ECPrivateKey(*(EC_KEY **)(a1 + 32), a2);
}

uint64_t ec_pkey_check(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 32);
  if (*(_QWORD *)(v1 + 40))
    return EC_KEY_check_key((const EC_KEY *)v1);
  ERR_put_error(16, 4095, 125, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_ameth.c", 649);
  return 0;
}

uint64_t ec_pkey_public_check(uint64_t a1)
{
  return EC_KEY_check_key(*(const EC_KEY **)(a1 + 32));
}

uint64_t ec_pkey_param_check(uint64_t a1)
{
  const EC_GROUP *v1;

  v1 = *(const EC_GROUP **)(*(_QWORD *)(a1 + 32) + 24);
  if (v1)
    return EC_GROUP_check(v1, 0);
  ERR_put_error(16, 4095, 124, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_ameth.c", 671);
  return 0;
}

EC_KEY *eckey_type2param(int a1, const ASN1_OBJECT *a2)
{
  EC_KEY *v3;
  const EC_GROUP *v4;
  int v5;
  EC_GROUP *v6;
  int v7;
  int v8;
  unsigned __int8 *in;

  if (a1 != 6)
  {
    if (a1 != 16)
    {
      ERR_put_error(16, 4095, 142, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_ameth.c", 180);
      v3 = 0;
LABEL_13:
      v4 = 0;
LABEL_14:
      EC_KEY_free(v3);
      v3 = 0;
      goto LABEL_15;
    }
    in = (unsigned __int8 *)a2->ln;
    v3 = d2i_ECParameters(0, (const unsigned __int8 **)&in, SLODWORD(a2->sn));
    if (v3)
    {
      v4 = 0;
      goto LABEL_15;
    }
    v7 = 142;
    v8 = 159;
LABEL_12:
    ERR_put_error(16, 4095, v7, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_ameth.c", v8);
    goto LABEL_13;
  }
  v3 = EC_KEY_new();
  if (!v3)
  {
    v7 = 65;
    v8 = 170;
    goto LABEL_12;
  }
  v5 = OBJ_obj2nid(a2);
  v6 = EC_GROUP_new_by_curve_name(v5);
  v4 = v6;
  if (!v6)
    goto LABEL_14;
  EC_GROUP_set_asn1_flag(v6, 1);
  if (!EC_KEY_set_group(v3, v4))
    goto LABEL_14;
LABEL_15:
  EC_GROUP_free(v4);
  return v3;
}

ASN1_STRING *eckey_param2type(int *a1, _QWORD *a2, EC_KEY *a3)
{
  const EC_GROUP *v6;
  const EC_GROUP *v7;
  int curve_name;
  int v9;
  int v10;
  int v11;
  ASN1_STRING *result;
  ASN1_STRING *v13;
  int v14;

  if (!a3 || (v6 = EC_KEY_get0_group(a3)) == 0)
  {
    v10 = 124;
    v11 = 84;
    goto LABEL_7;
  }
  v7 = v6;
  if (!EC_GROUP_get_asn1_flag(v6) || (curve_name = EC_GROUP_get_curve_name(v7)) == 0)
  {
    result = ASN1_STRING_new();
    if (!result)
      return result;
    v13 = result;
    v14 = i2d_ECParameters(a3, &result->data);
    v13->length = v14;
    if (v14 > 0)
    {
      *a2 = v13;
      v9 = 16;
      goto LABEL_11;
    }
    ASN1_STRING_free(v13);
    v10 = 16;
    v11 = 101;
LABEL_7:
    ERR_put_error(16, 4095, v10, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_ameth.c", v11);
    return 0;
  }
  *a2 = OBJ_nid2obj(curve_name);
  v9 = 6;
LABEL_11:
  *a1 = v9;
  return (ASN1_STRING *)1;
}

uint64_t do_EC_KEY_print(BIO *a1, EC_KEY *a2, int a3, int a4)
{
  const EC_KEY *v4;
  const EC_GROUP *v8;
  const EC_GROUP *v9;
  BN_CTX *v10;
  const char *v11;
  const EC_POINT *v12;
  point_conversion_form_t conv_form;
  BIGNUM *v14;
  int v15;
  int v16;
  unint64_t v17;
  BIGNUM *v18;
  int v19;
  const BIGNUM *v20;
  const BIGNUM *v21;
  int v22;
  int v23;
  int v24;
  uint64_t v25;
  const char *v26;
  int v27;
  uint64_t v28;

  v4 = a2;
  if (!a2)
  {
    v10 = 0;
    v18 = 0;
    v12 = 0;
LABEL_12:
    v19 = 67;
LABEL_44:
    ERR_put_error(16, 4095, v19, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_ameth.c", 514);
    v28 = 0;
    goto LABEL_45;
  }
  v8 = EC_KEY_get0_group(a2);
  if (!v8)
  {
    v10 = 0;
    v18 = 0;
    v12 = 0;
    v4 = 0;
    goto LABEL_12;
  }
  v9 = v8;
  v10 = BN_CTX_new();
  if (!v10)
  {
    v18 = 0;
    v12 = 0;
    v4 = 0;
LABEL_43:
    v19 = 65;
    goto LABEL_44;
  }
  v11 = "ECDSA-Parameters";
  if (a4 < 1)
  {
    v4 = 0;
    v12 = 0;
    v20 = 0;
    goto LABEL_30;
  }
  v12 = EC_KEY_get0_public_key(v4);
  if (v12)
  {
    conv_form = EC_KEY_get_conv_form(v4);
    v14 = EC_POINT_point2bn(v9, v12, conv_form, 0, v10);
    v12 = (const EC_POINT *)v14;
    if (!v14)
    {
      v18 = 0;
      v4 = 0;
      v19 = 16;
      goto LABEL_44;
    }
    v15 = BN_num_bits(v14);
    v16 = v15 + 7;
    if (v15 < -7)
      v16 = v15 + 14;
    v17 = (uint64_t)v16 >> 3;
  }
  else
  {
    v17 = 0;
  }
  if (a4 == 2)
  {
    v21 = EC_KEY_get0_private_key(v4);
    v20 = v21;
    if (v21)
    {
      v22 = BN_num_bits(v21);
      v23 = v22 + 7;
      if (v22 < -7)
        v23 = v22 + 14;
      v24 = v23 >> 3;
      v25 = (uint64_t)v23 >> 3;
      if (v17 <= v24)
        v17 = v25;
    }
  }
  else
  {
    v20 = 0;
  }
  v4 = (const EC_KEY *)malloc_type_malloc(v17 + 10, 0x3B22E2EDuLL);
  if (!v4)
  {
    v18 = 0;
    goto LABEL_43;
  }
  v26 = "Public-Key";
  if (a4 != 1)
    v26 = "ECDSA-Parameters";
  if (a4 == 2)
    v11 = "Private-Key";
  else
    v11 = v26;
LABEL_30:
  if (!BIO_indent(a1, a3, 128))
  {
    v18 = 0;
LABEL_41:
    v19 = 32;
    goto LABEL_44;
  }
  v18 = BN_new();
  if (!v18)
    goto LABEL_41;
  if (!EC_GROUP_get_order(v9, v18, 0))
    goto LABEL_41;
  v27 = BN_num_bits(v18);
  if (BIO_printf(a1, "%s: (%d bit)\n", v11, v27) < 1
    || v20 && !ASN1_bn_print(a1, "priv:", v20, (unsigned __int8 *)v4, a3))
  {
    goto LABEL_41;
  }
  if (v12 && !ASN1_bn_print(a1, "pub: ", (const BIGNUM *)v12, (unsigned __int8 *)v4, a3)
    || !ECPKParameters_print(a1, v9, a3))
  {
    goto LABEL_41;
  }
  v28 = 1;
LABEL_45:
  BN_free((BIGNUM *)v12);
  BN_free(v18);
  BN_CTX_free(v10);
  free(v4);
  return v28;
}

unint64_t BN_mod_word(const BIGNUM *a, unint64_t w)
{
  BIGNUM *v4;
  BIGNUM *v5;
  unint64_t v6;
  unint64_t result;
  uint64_t top;
  unint64_t *d;
  unint64_t v10;
  __int128 v11;

  if (!w)
    return -1;
  if (w >= 0x100000001)
  {
    v4 = BN_dup(a);
    if (v4)
    {
      v5 = v4;
      v6 = BN_div_word(v4, w);
      BN_free(v5);
      return v6;
    }
    return -1;
  }
  top = a->top;
  if ((int)top < 1)
    return 0;
  result = 0;
  d = a->d;
  v10 = top + 1;
  do
  {
    *((_QWORD *)&v11 + 1) = result;
    *(_QWORD *)&v11 = d[(v10 - 2)];
    result = (v11 | ((unint64_t)((unint64_t)(v11 >> 32) % w) << 32)) % w;
    --v10;
  }
  while (v10 > 1);
  return result;
}

unint64_t BN_div_word(BIGNUM *a, unint64_t w)
{
  int v4;
  char v5;
  char v6;
  uint64_t top;
  unint64_t v8;
  unint64_t *d;
  unint64_t v10;
  int v11;
  BOOL v12;
  int v13;
  unint64_t v15;
  unint64_t v16;

  v16 = 0;
  if (!w)
    return -1;
  if (!a->top)
    return 0;
  v4 = BN_num_bits_word(w);
  v5 = v4;
  v6 = 64 - v4;
  if (!BN_lshift(a, a, 64 - v4))
    return -1;
  top = a->top;
  if ((int)top >= 1)
  {
    v8 = w << -v5;
    d = a->d;
    v10 = top + 1;
    do
    {
      v15 = 0;
      bn_div_rem_words(v16, d[(v10 - 2)], v8, &v15, &v16);
      d = a->d;
      a->d[(v10-- - 2)] = v15;
    }
    while (v10 > 1);
    v11 = a->top;
    v12 = __OFSUB__(v11, 1);
    v13 = v11 - 1;
    if (v13 < 0 == v12 && !a->d[v13])
      a->top = v13;
  }
  v16 >>= v6;
  BN_set_negative(a, a->neg);
  return v16;
}

int BN_add_word(BIGNUM *a, unint64_t w)
{
  unint64_t v2;
  int v5;
  uint64_t v6;
  uint64_t top;
  unint64_t v8;
  BOOL v9;

  if (w)
  {
    v2 = w;
    if (BN_is_zero((uint64_t)a))
      return BN_set_word(a, v2);
    if (a->neg)
    {
      a->neg = 0;
      v5 = BN_sub_word(a, v2);
      BN_set_negative(a, a->neg == 0);
      return v5;
    }
    v6 = 0;
    top = a->top;
    while ((top & ~((int)top >> 31)) != v6)
    {
      v8 = a->d[v6];
      v9 = __CFADD__(v8, v2);
      a->d[v6++] = v8 + v2;
      v2 = 1;
      if (!v9)
        return v2;
    }
    if ((top & 0x80000000) == 0)
    {
      if (!bn_wexpand((uint64_t)a, (top + 1)))
      {
        LODWORD(v2) = 0;
        return v2;
      }
      ++a->top;
      a->d[top] = v2;
    }
  }
  LODWORD(v2) = 1;
  return v2;
}

int BN_sub_word(BIGNUM *a, unint64_t w)
{
  unint64_t v2;
  int v4;
  BIGNUM *v5;
  _BOOL4 v6;
  unint64_t *d;
  unint64_t v8;
  int v9;
  int v10;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  BOOL v14;

  if (!w)
    return 1;
  v2 = w;
  if (!BN_is_zero((uint64_t)a))
  {
    if (a->neg)
    {
      a->neg = 0;
      v4 = BN_add_word(a, v2);
      v6 = a->neg == 0;
      v5 = a;
      goto LABEL_7;
    }
    d = a->d;
    v8 = *a->d;
    v9 = a->top - 1;
    if (a->top == 1 && v8 < v2)
    {
      *d = v2 - v8;
      v4 = 1;
      goto LABEL_4;
    }
    v10 = 0;
    v11 = v8 - v2;
    if (v8 < v2)
    {
      v2 = 1;
      do
      {
        *d = v11;
        v12 = d[1];
        ++d;
        v8 = v12;
        ++v10;
        v11 = -1;
      }
      while (!v12);
    }
    v13 = v8 - v2;
    *d = v13;
    if (v13)
      v14 = 0;
    else
      v14 = v10 == v9;
    if (v14)
      a->top = v10;
    return 1;
  }
  v4 = BN_set_word(a, v2);
  if (v4)
  {
LABEL_4:
    v5 = a;
    v6 = 1;
LABEL_7:
    BN_set_negative(v5, v6);
  }
  return v4;
}

int BN_mul_word(BIGNUM *a, unint64_t w)
{
  int top;
  unint64_t v4;
  unint64_t v5;
  int result;
  unint64_t *d;
  uint64_t v8;

  top = a->top;
  if (top)
  {
    if (w)
    {
      v4 = bn_mul_words(a->d, a->d, top, w);
      if (v4)
      {
        v5 = v4;
        result = bn_wexpand((uint64_t)a, (a->top + 1));
        if (!result)
          return result;
        d = a->d;
        v8 = a->top;
        a->top = v8 + 1;
        d[v8] = v5;
      }
    }
    else
    {
      BN_zero((uint64_t)a);
    }
  }
  return 1;
}

uint64_t cms_get0_enveloped(uint64_t a1)
{
  if (OBJ_obj2nid(*(const ASN1_OBJECT **)a1) == 23)
    return *(_QWORD *)(a1 + 8);
  ERR_put_error(46, 4095, 107, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/cms/cms_env.c", 74);
  return 0;
}

uint64_t cms_env_asn1_ctrl(uint64_t a1)
{
  uint64_t result;
  uint64_t v2;
  uint64_t (*v3)(void);
  int v4;
  int v5;
  int v6;

  if (*(_DWORD *)a1 != 1)
  {
    if (*(_DWORD *)a1)
      return 0;
    result = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 40);
LABEL_6:
    v2 = *(_QWORD *)(result + 16);
    if (v2)
    {
      v3 = *(uint64_t (**)(void))(v2 + 176);
      if (v3)
      {
        v4 = v3();
        if (v4 == -2)
        {
          v5 = 125;
          v6 = 120;
LABEL_13:
          ERR_put_error(46, 4095, v5, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/cms/cms_env.c", v6);
          return 0;
        }
        if (v4 <= 0)
        {
          v5 = 111;
          v6 = 124;
          goto LABEL_13;
        }
      }
    }
    return 1;
  }
  result = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 40);
  if (result)
  {
    result = EVP_PKEY_CTX_get0_pkey(result);
    if (result)
      goto LABEL_6;
  }
  return result;
}

uint64_t CMS_get0_RecipientInfos(uint64_t a1)
{
  uint64_t result;

  result = cms_get0_enveloped(a1);
  if (result)
    return *(_QWORD *)(result + 16);
  return result;
}

uint64_t CMS_RecipientInfo_type(unsigned int *a1)
{
  return *a1;
}

uint64_t CMS_RecipientInfo_get0_pkey_ctx(uint64_t a1)
{
  uint64_t v1;

  if (*(_DWORD *)a1 == 1)
  {
    v1 = *(_QWORD *)(a1 + 8) + 40;
    return *(_QWORD *)v1;
  }
  if (!*(_DWORD *)a1)
  {
    v1 = *(_QWORD *)(a1 + 8) + 48;
    return *(_QWORD *)v1;
  }
  return 0;
}

ASN1_VALUE *CMS_EnvelopedData_create(ASN1_OBJECT *a1)
{
  ASN1_VALUE *v2;
  ASN1_VALUE *v3;
  uint64_t v4;
  ASN1_VALUE *v5;
  ASN1_OBJECT *v6;
  ASN1_OBJECT *v7;

  v2 = CMS_ContentInfo_new();
  v3 = v2;
  if (!v2)
    goto LABEL_10;
  if (!*((_QWORD *)v2 + 1))
  {
    v5 = ASN1_item_new(&CMS_EnvelopedData_it);
    *((_QWORD *)v3 + 1) = v5;
    if (v5)
    {
      *(_QWORD *)v5 = 0;
      v6 = OBJ_nid2obj(21);
      v7 = *(ASN1_OBJECT **)v3;
      **(_QWORD **)(*((_QWORD *)v3 + 1) + 24) = v6;
      ASN1_OBJECT_free(v7);
      *(_QWORD *)v3 = OBJ_nid2obj(23);
      v4 = *((_QWORD *)v3 + 1);
      if (v4)
        goto LABEL_7;
    }
    else
    {
      ERR_put_error(46, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/cms/cms_env.c", 86);
    }
LABEL_10:
    CMS_ContentInfo_free(v3);
    ERR_put_error(46, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/cms/cms_env.c", 180);
    return 0;
  }
  v4 = cms_get0_enveloped((uint64_t)v2);
  if (!v4)
    goto LABEL_10;
LABEL_7:
  if (!cms_EncryptedContent_init(*(ASN1_OBJECT ***)(v4 + 24), a1, 0, 0))
    goto LABEL_10;
  return v3;
}

ASN1_VALUE *CMS_add1_recipient_cert(uint64_t a1, X509 *a2, unsigned int a3)
{
  uint64_t v5;
  uint64_t v6;
  ASN1_VALUE *v7;
  EVP_PKEY *v8;
  uint64_t v9;
  char *ptr;
  int (*v11)(EVP_PKEY *, uint64_t, _QWORD, int *);
  ASN1_VALUE *v12;
  ASN1_VALUE *v13;
  int v14;
  int v15;
  uint64_t *v16;
  int v18;

  v5 = cms_get0_enveloped(a1);
  if (!v5)
  {
    v7 = 0;
    goto LABEL_23;
  }
  v6 = v5;
  v7 = ASN1_item_new(&CMS_RecipientInfo_it);
  if (!v7)
  {
LABEL_21:
    v14 = 65;
    v15 = 286;
    goto LABEL_22;
  }
  v8 = X509_get0_pubkey((uint64_t)a2);
  if (!v8)
  {
    v14 = 113;
    v15 = 258;
LABEL_22:
    ERR_put_error(46, 4095, v14, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/cms/cms_env.c", v15);
    goto LABEL_23;
  }
  v9 = (uint64_t)v8;
  ptr = v8->pkey.ptr;
  if (!ptr)
    goto LABEL_9;
  v11 = (int (*)(EVP_PKEY *, uint64_t, _QWORD, int *))*((_QWORD *)ptr + 22);
  if (!v11)
    goto LABEL_9;
  v18 = 0;
  if (v11(v8, 8, 0, &v18) < 1)
    goto LABEL_9;
  if (v18 == 1)
  {
    if (cms_RecipientInfo_kari_init((uint64_t)v7, a2, v9, a3))
      goto LABEL_20;
LABEL_23:
    ASN1_item_free(v7, &CMS_RecipientInfo_it);
    return 0;
  }
  if (v18)
  {
    v14 = 125;
    v15 = 275;
    goto LABEL_22;
  }
LABEL_9:
  v12 = ASN1_item_new(&CMS_KeyTransRecipientInfo_it);
  *((_QWORD *)v7 + 1) = v12;
  if (!v12)
    goto LABEL_23;
  v13 = v12;
  *(_DWORD *)v7 = 0;
  *(_QWORD *)v12 = (a3 & 0x10000) >> 15;
  if (!cms_set1_SignerIdentifier(*((_QWORD *)v12 + 1), a2, HIWORD(a3) & 1))
    goto LABEL_23;
  X509_up_ref((uint64_t)a2);
  EVP_PKEY_up_ref(v9);
  *((_QWORD *)v13 + 4) = a2;
  *((_QWORD *)v13 + 5) = v9;
  if ((a3 & 0x40000) != 0)
  {
    v16 = (uint64_t *)EVP_PKEY_CTX_new(v9, 0);
    *((_QWORD *)v13 + 6) = v16;
    if (!v16 || (int)EVP_PKEY_encrypt_init(v16) < 1)
      goto LABEL_23;
  }
  else if (!cms_env_asn1_ctrl((uint64_t)v7))
  {
    goto LABEL_23;
  }
LABEL_20:
  if (!sk_push(*(STACK **)(v6 + 16), (char *)v7))
    goto LABEL_21;
  return v7;
}

uint64_t cms_pkey_get_ri_type(uint64_t a1)
{
  uint64_t v1;
  int (*v2)(void);
  unsigned int v4;

  v1 = *(_QWORD *)(a1 + 16);
  if (v1 && (v2 = *(int (**)(void))(v1 + 176)) != 0 && (v4 = 0, v2() > 0))
    return v4;
  else
    return 0;
}

uint64_t CMS_RecipientInfo_ktri_get0_algs(uint64_t a1, _QWORD *a2, _QWORD *a3, _QWORD *a4)
{
  _QWORD *v5;

  if (*(_DWORD *)a1)
  {
    ERR_put_error(46, 4095, 124, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/cms/cms_env.c", 299);
    return 0;
  }
  else
  {
    v5 = *(_QWORD **)(a1 + 8);
    if (a2)
      *a2 = v5[5];
    if (a3)
      *a3 = v5[4];
    if (a4)
      *a4 = v5[2];
    return 1;
  }
}

uint64_t CMS_RecipientInfo_ktri_get0_signer_id(uint64_t a1, _QWORD *a2, _QWORD *a3, _QWORD *a4)
{
  if (!*(_DWORD *)a1)
    return cms_SignerIdentifier_get0_signer_id(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 8), a2, a3, a4);
  ERR_put_error(46, 4095, 124, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/cms/cms_env.c", 322);
  return 0;
}

uint64_t CMS_RecipientInfo_ktri_cert_cmp(uint64_t a1, X509 *a2)
{
  if (!*(_DWORD *)a1)
    return cms_SignerIdentifier_cert_cmp(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 8), a2);
  ERR_put_error(46, 4095, 124, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/cms/cms_env.c", 334);
  return 4294967294;
}

uint64_t CMS_RecipientInfo_set0_pkey(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)a1)
  {
    ERR_put_error(46, 4095, 124, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/cms/cms_env.c", 345);
    return 0;
  }
  else
  {
    EVP_PKEY_free(*(EVP_PKEY **)(*(_QWORD *)(a1 + 8) + 40));
    *(_QWORD *)(*(_QWORD *)(a1 + 8) + 40) = a2;
    return 1;
  }
}

uint64_t CMS_RecipientInfo_kekri_id_cmp(uint64_t a1, unsigned __int8 *a2, int a3)
{
  uint64_t v3;
  ASN1_OCTET_STRING a;

  if (*(_DWORD *)a1 == 2)
  {
    v3 = *(_QWORD *)(a1 + 8);
    a.data = a2;
    a.flags = 0;
    a.length = a3;
    a.type = 4;
    return ASN1_OCTET_STRING_cmp(&a, **(ASN1_OCTET_STRING ***)(v3 + 8));
  }
  else
  {
    ERR_put_error(46, 4095, 123, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/cms/cms_env.c", 514);
    return 4294967294;
  }
}

ASN1_VALUE *CMS_add0_recipient_key(uint64_t a1, int a2, uint64_t a3, uint64_t a4, void *a5, int a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  ASN1_VALUE *v19;
  ASN1_VALUE *v20;
  ASN1_VALUE *v21;
  ASN1_VALUE *v22;
  uint64_t v23;
  _QWORD *v24;
  X509_ALGOR *v25;
  ASN1_OBJECT *v26;
  int v27;
  int v28;

  v16 = cms_get0_enveloped(a1);
  if (!v16)
    goto LABEL_30;
  v17 = v16;
  if (a2 > 788)
  {
    if (a2 == 789)
    {
      v18 = 24;
      goto LABEL_14;
    }
    if (a2 == 790)
    {
      v18 = 32;
      goto LABEL_14;
    }
    goto LABEL_25;
  }
  if (a2)
  {
    if (a2 == 788)
    {
      v18 = 16;
LABEL_14:
      if (v18 == a4)
        goto LABEL_15;
      v27 = 118;
      v28 = 588;
      goto LABEL_29;
    }
LABEL_25:
    v27 = 153;
    v28 = 583;
LABEL_29:
    ERR_put_error(46, 4095, v27, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/cms/cms_env.c", v28);
LABEL_30:
    v19 = 0;
    goto LABEL_31;
  }
  switch(a4)
  {
    case 16:
      a2 = 788;
      break;
    case 32:
      a2 = 790;
      break;
    case 24:
      a2 = 789;
      break;
    default:
      v27 = 118;
      v28 = 574;
      goto LABEL_29;
  }
LABEL_15:
  v19 = ASN1_item_new(&CMS_RecipientInfo_it);
  if (!v19
    || (v20 = ASN1_item_new(&CMS_KEKRecipientInfo_it), (*((_QWORD *)v19 + 1) = v20) == 0)
    || (v21 = v20, *(_DWORD *)v19 = 2, a8)
    && (v22 = ASN1_item_new(&CMS_OtherKeyAttribute_it), (*(_QWORD *)(*((_QWORD *)v21 + 1) + 16) = v22) == 0)
    || !sk_push(*(STACK **)(v17 + 16), (char *)v19))
  {
    ERR_put_error(46, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/cms/cms_env.c", 637);
LABEL_31:
    ASN1_item_free(v19, &CMS_RecipientInfo_it);
    return 0;
  }
  *(_QWORD *)v21 = 4;
  *((_QWORD *)v21 + 4) = a3;
  *((_QWORD *)v21 + 5) = a4;
  ASN1_STRING_set0(**((ASN1_STRING ***)v21 + 1), a5, a6);
  v23 = *((_QWORD *)v21 + 1);
  *(_QWORD *)(v23 + 8) = a7;
  v24 = *(_QWORD **)(v23 + 16);
  if (v24)
  {
    *v24 = a8;
    v24[1] = a9;
  }
  v25 = (X509_ALGOR *)*((_QWORD *)v21 + 2);
  v26 = OBJ_nid2obj(a2);
  X509_ALGOR_set0(v25, v26, -1, 0);
  return v19;
}

uint64_t CMS_RecipientInfo_kekri_get0_id(uint64_t a1, _QWORD *a2, _QWORD *a3, _QWORD *a4, _QWORD *a5, _QWORD *a6)
{
  uint64_t v6;
  _QWORD *v7;
  _QWORD *v8;
  uint64_t v9;

  if (*(_DWORD *)a1 == 2)
  {
    v6 = *(_QWORD *)(a1 + 8);
    v7 = *(_QWORD **)(v6 + 8);
    if (a2)
      *a2 = *(_QWORD *)(v6 + 16);
    if (a3)
      *a3 = *v7;
    if (a4)
      *a4 = v7[1];
    if (a5)
    {
      v8 = (_QWORD *)v7[2];
      if (v8)
        v8 = (_QWORD *)*v8;
      *a5 = v8;
    }
    if (a6)
    {
      v9 = v7[2];
      if (v9)
        *a6 = *(_QWORD *)(v9 + 8);
      else
        *a6 = 0;
    }
    return 1;
  }
  else
  {
    ERR_put_error(46, 4095, 123, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/cms/cms_env.c", 651);
    return 0;
  }
}

uint64_t CMS_RecipientInfo_set0_key(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;

  if (*(_DWORD *)a1 == 2)
  {
    v3 = *(_QWORD *)(a1 + 8);
    *(_QWORD *)(v3 + 32) = a2;
    *(_QWORD *)(v3 + 40) = a3;
    return 1;
  }
  else
  {
    ERR_put_error(46, 4095, 123, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/cms/cms_env.c", 684);
    return 0;
  }
}

uint64_t CMS_RecipientInfo_decrypt(uint64_t a1, uint64_t a2)
{
  int v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t *v8;
  BOOL v9;
  int v10;
  int v11;
  uint64_t v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  int v17;
  int v18;
  int v19;
  int v20;
  uint64_t v21;
  unsigned __int8 *v22;
  int v23;
  const char *v24;
  const EVP_CIPHER *cipherbyname;
  int v26;
  unsigned int v27;
  unsigned __int8 *v28;
  uint64_t v29;
  int v30;
  int v31;
  int v32;
  int v33;
  AES_KEY size;

  v3 = *(_DWORD *)a2;
  if (*(_DWORD *)a2 == 3)
    return (uint64_t)cms_RecipientInfo_pwri_crypt(a1, a2, 0);
  if (v3 == 2)
  {
    memset(&size, 0, sizeof(size));
    v13 = *(_QWORD *)(a2 + 8);
    if (!*(_QWORD *)(v13 + 32))
    {
      v19 = 130;
      v20 = 759;
      goto LABEL_31;
    }
    v14 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 24);
    v15 = OBJ_obj2nid(**(const ASN1_OBJECT ***)(v13 + 16));
    if ((v15 - 788) >= 3)
      v16 = 0;
    else
      v16 = 8 * (v15 - 788) + 16;
    if (v16 != *(_QWORD *)(v13 + 40))
    {
      v19 = 118;
      v20 = 765;
      goto LABEL_31;
    }
    if (**(int **)(v13 + 24) > 15)
    {
      if (!AES_set_decrypt_key(*(const unsigned __int8 **)(v13 + 32), 8 * v16, &size))
      {
        v22 = (unsigned __int8 *)malloc_type_malloc(**(int **)(v13 + 24) - 8, 0xC8CB00B0uLL);
        if (v22)
        {
          v26 = AES_unwrap_key(&size, 0, v22, *(const unsigned __int8 **)(*(_QWORD *)(v13 + 24) + 8), **(_DWORD **)(v13 + 24));
          if (v26 > 0)
          {
            v27 = v26;
            freezero(*(void **)(v14 + 32), *(_QWORD *)(v14 + 40));
            *(_QWORD *)(v14 + 32) = v22;
            *(_QWORD *)(v14 + 40) = v27;
            v21 = 1;
            goto LABEL_38;
          }
          v30 = 157;
          v31 = 791;
        }
        else
        {
          v30 = 65;
          v31 = 783;
        }
        ERR_put_error(46, 4095, v30, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/cms/cms_env.c", v31);
LABEL_37:
        free(v22);
        v21 = 0;
LABEL_38:
        explicit_bzero(&size, 0xF4uLL);
        return v21;
      }
      v17 = 115;
      v18 = 777;
    }
    else
    {
      v17 = 117;
      v18 = 772;
    }
    ERR_put_error(46, 4095, v17, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/cms/cms_env.c", v18);
    v22 = 0;
    goto LABEL_37;
  }
  if (v3)
  {
    v19 = 155;
    v20 = 824;
LABEL_31:
    ERR_put_error(46, 4095, v19, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/cms/cms_env.c", v20);
    return 0;
  }
  v4 = *(_QWORD *)(a2 + 8);
  v5 = *(_QWORD *)(v4 + 40);
  if (!v5)
  {
    v19 = 133;
    v20 = 436;
    goto LABEL_31;
  }
  v6 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 24);
  *(_QWORD *)size.rd_key = 0;
  if (!*(_DWORD *)(v6 + 52) || *(_DWORD *)(v6 + 48))
  {
    v7 = 0;
    goto LABEL_8;
  }
  v23 = OBJ_obj2nid(**(const ASN1_OBJECT ***)(v6 + 8));
  v24 = OBJ_nid2sn(v23);
  cipherbyname = EVP_get_cipherbyname(v24);
  if (!cipherbyname)
  {
    v19 = 148;
    v20 = 446;
    goto LABEL_31;
  }
  v7 = EVP_CIPHER_key_length(cipherbyname);
LABEL_8:
  v8 = (uint64_t *)EVP_PKEY_CTX_new(v5, 0);
  *(_QWORD *)(v4 + 48) = v8;
  if (v8)
  {
    if ((int)EVP_PKEY_decrypt_init(v8) >= 1 && cms_env_asn1_ctrl(a2))
    {
      if ((int)EVP_PKEY_CTX_ctrl(*(uint64_t **)(v4 + 48), -1, 512) <= 0)
      {
        v10 = 110;
        v11 = 465;
      }
      else
      {
        v9 = EVP_PKEY_decrypt(*(unsigned __int8 **)(v4 + 48), 0, (int)&size, *(EVP_PKEY **)(*(_QWORD *)(v4 + 24) + 8)) < 1|| *(_QWORD *)size.rd_key == 0;
        if (!v9 && (!v7 || *(_QWORD *)size.rd_key == v7))
        {
          v28 = (unsigned __int8 *)malloc_type_malloc(*(size_t *)size.rd_key, 0x7DB66469uLL);
          if (v28)
          {
            if (EVP_PKEY_decrypt(*(unsigned __int8 **)(v4 + 48), v28, (int)&size, *(EVP_PKEY **)(*(_QWORD *)(v4 + 24) + 8)) > 0)
            {
              freezero(*(void **)(v6 + 32), *(_QWORD *)(v6 + 40));
              v29 = *(_QWORD *)size.rd_key;
              *(_QWORD *)(v6 + 32) = v28;
              *(_QWORD *)(v6 + 40) = v29;
              EVP_PKEY_CTX_free(*(EVP_PKEY ***)(v4 + 48));
              *(_QWORD *)(v4 + 48) = 0;
              return 1;
            }
            v32 = 104;
            v33 = 485;
          }
          else
          {
            v32 = 65;
            v33 = 479;
          }
          ERR_put_error(46, 4095, v32, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/cms/cms_env.c", v33);
          goto LABEL_48;
        }
        v10 = 104;
        v11 = 472;
      }
      ERR_put_error(46, 4095, v10, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/cms/cms_env.c", v11);
    }
    v28 = 0;
LABEL_48:
    EVP_PKEY_CTX_free(*(EVP_PKEY ***)(v4 + 48));
    *(_QWORD *)(v4 + 48) = 0;
    free(v28);
  }
  return 0;
}

EVP_CIPHER_CTX *CMS_RecipientInfo_encrypt(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  EVP_PKEY **v4;
  int v5;
  int v6;
  uint64_t v8;
  uint64_t v9;
  unsigned __int8 *v10;
  uint64_t *v11;
  void *v12;
  uint64_t v13;
  int v14;
  int v15;
  int v16;
  AES_KEY size;

  switch(*(_DWORD *)a2)
  {
    case 0:
      *(_QWORD *)size.rd_key = 0;
      v2 = *(_QWORD *)(a2 + 8);
      v3 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 24);
      v4 = *(EVP_PKEY ***)(v2 + 48);
      if (v4)
      {
        if (!cms_env_asn1_ctrl(a2))
          goto LABEL_25;
      }
      else
      {
        v11 = (uint64_t *)EVP_PKEY_CTX_new(*(_QWORD *)(v2 + 40), 0);
        if (!v11)
          return 0;
        v4 = (EVP_PKEY **)v11;
        if ((int)EVP_PKEY_encrypt_init(v11) < 1)
          goto LABEL_25;
      }
      if ((int)EVP_PKEY_CTX_ctrl((uint64_t *)v4, -1, 256) <= 0)
      {
        ERR_put_error(46, 4095, 110, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/cms/cms_env.c", 390);
      }
      else if (EVP_PKEY_encrypt((unsigned __int8 *)v4, 0, (int)&size, *(EVP_PKEY **)(v3 + 32)) >= 1)
      {
        v12 = malloc_type_malloc(*(size_t *)size.rd_key, 0xFD6232A5uLL);
        if (v12)
        {
          if (EVP_PKEY_encrypt((unsigned __int8 *)v4, (const unsigned __int8 *)v12, (int)&size, *(EVP_PKEY **)(v3 + 32)) >= 1)
          {
            ASN1_STRING_set0(*(ASN1_STRING **)(v2 + 24), v12, size.rd_key[0]);
            v12 = 0;
            v13 = 1;
LABEL_27:
            EVP_PKEY_CTX_free(v4);
            *(_QWORD *)(v2 + 48) = 0;
            free(v12);
            return (EVP_CIPHER_CTX *)v13;
          }
        }
        else
        {
          ERR_put_error(46, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/cms/cms_env.c", 400);
        }
LABEL_26:
        v13 = 0;
        goto LABEL_27;
      }
LABEL_25:
      v12 = 0;
      goto LABEL_26;
    case 1:
      return (EVP_CIPHER_CTX *)cms_RecipientInfo_kari_encrypt(a1, a2);
    case 2:
      memset(&size, 0, sizeof(size));
      v8 = *(_QWORD *)(a2 + 8);
      if (*(_QWORD *)(v8 + 32))
      {
        v9 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 24);
        if (AES_set_encrypt_key(*(const unsigned __int8 **)(v8 + 32), 8 * *(_DWORD *)(v8 + 40), &size))
        {
          ERR_put_error(46, 4095, 115, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/cms/cms_env.c", 715);
          v10 = 0;
        }
        else
        {
          v10 = (unsigned __int8 *)malloc_type_malloc(*(_QWORD *)(v9 + 40) + 8, 0x9E8967F1uLL);
          if (v10)
          {
            v14 = AES_wrap_key(&size, 0, v10, *(const unsigned __int8 **)(v9 + 32), *(_DWORD *)(v9 + 40));
            if (v14 > 0)
            {
              ASN1_STRING_set0(*(ASN1_STRING **)(v8 + 24), v10, v14);
              v13 = 1;
LABEL_33:
              explicit_bzero(&size, 0xF4uLL);
              return (EVP_CIPHER_CTX *)v13;
            }
            v15 = 159;
            v16 = 727;
          }
          else
          {
            v15 = 65;
            v16 = 721;
          }
          ERR_put_error(46, 4095, v15, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/cms/cms_env.c", v16);
        }
        free(v10);
        v13 = 0;
        goto LABEL_33;
      }
      v5 = 130;
      v6 = 710;
LABEL_19:
      ERR_put_error(46, 4095, v5, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/cms/cms_env.c", v6);
      return 0;
    case 3:
      return cms_RecipientInfo_pwri_crypt(a1, a2, 1);
    default:
      v5 = 154;
      v6 = 846;
      goto LABEL_19;
  }
}

BIO *cms_EnvelopedData_init_bio(uint64_t a1)
{
  uint64_t v2;
  BIO *inited;
  const STACK *v4;
  int v5;
  char *v6;
  uint64_t v7;
  const STACK **v8;
  int v9;
  int v10;
  int v11;
  int v12;
  char *v13;
  uint64_t v14;

  v2 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 24);
  inited = cms_EncryptedContent_init_bio(v2);
  if (!inited || !*(_QWORD *)(v2 + 24))
    return inited;
  v4 = *(const STACK **)(*(_QWORD *)(a1 + 8) + 16);
  if (sk_num(v4) < 1)
  {
LABEL_7:
    v7 = *(_QWORD *)(a1 + 8);
    if (*(uint64_t *)v7 > 3)
      goto LABEL_35;
    v8 = *(const STACK ***)(v7 + 8);
    if (v8)
    {
      if (sk_num(*v8) >= 1)
      {
        v9 = 0;
        do
        {
          v10 = *(_DWORD *)sk_value(*v8, v9);
          if (v10 == 3)
          {
            if (*(uint64_t *)v7 <= 2)
              *(_QWORD *)v7 = 3;
          }
          else if (v10 == 4)
          {
            v14 = 4;
            goto LABEL_34;
          }
          ++v9;
        }
        while (v9 < sk_num(*v8));
      }
      if (sk_num(v8[1]) >= 1)
      {
        v11 = 0;
        v14 = 4;
        do
        {
          if (*(_DWORD *)sk_value(v8[1], v11) == 1)
            goto LABEL_34;
          ++v11;
        }
        while (v11 < sk_num(v8[1]));
      }
    }
    if (*(uint64_t *)v7 > 2)
      goto LABEL_35;
    if (sk_num(*(const STACK **)(v7 + 16)) >= 1)
    {
      v12 = 0;
      while (1)
      {
        v13 = sk_value(*(const STACK **)(v7 + 16), v12);
        if (*(_DWORD *)v13)
          break;
        if (**((_QWORD **)v13 + 1))
          goto LABEL_28;
LABEL_29:
        if (++v12 >= sk_num(*(const STACK **)(v7 + 16)))
          goto LABEL_30;
      }
      if ((*(_DWORD *)v13 - 3) < 2)
      {
        v14 = 3;
        goto LABEL_34;
      }
LABEL_28:
      *(_QWORD *)v7 = 2;
      goto LABEL_29;
    }
LABEL_30:
    if (*(_QWORD *)(v7 + 8) || *(_QWORD *)(v7 + 32))
    {
      v14 = 2;
    }
    else
    {
      if (*(_QWORD *)v7 == 2)
        goto LABEL_35;
      v14 = 0;
    }
LABEL_34:
    *(_QWORD *)v7 = v14;
LABEL_35:
    *(_QWORD *)(v2 + 24) = 0;
    freezero(*(void **)(v2 + 32), *(_QWORD *)(v2 + 40));
    *(_QWORD *)(v2 + 32) = 0;
    *(_QWORD *)(v2 + 40) = 0;
    return inited;
  }
  v5 = 0;
  while (1)
  {
    v6 = sk_value(v4, v5);
    if ((int)CMS_RecipientInfo_encrypt(a1, (uint64_t)v6) <= 0)
      break;
    if (++v5 >= sk_num(v4))
      goto LABEL_7;
  }
  ERR_put_error(46, 4095, 116, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/cms/cms_env.c", 945);
  *(_QWORD *)(v2 + 24) = 0;
  freezero(*(void **)(v2 + 32), *(_QWORD *)(v2 + 40));
  *(_QWORD *)(v2 + 32) = 0;
  *(_QWORD *)(v2 + 40) = 0;
  BIO_free(inited);
  return 0;
}

void *__cdecl PEM_ASN1_read_bio(d2i_of_void *d2i, const char *name, BIO *bp, void **x, pem_password_cb *cb, void *u)
{
  void *v8;
  uint64_t plen;
  unsigned __int8 *pdata;
  unsigned __int8 *v12;

  plen = 0;
  pdata = 0;
  if (!PEM_bytes_read_bio(&pdata, &plen, 0, name, bp, cb, u))
    return 0;
  v12 = pdata;
  v8 = (void *)((uint64_t (*)(void **, unsigned __int8 **, uint64_t))d2i)(x, &v12, plen);
  if (!v8)
    ERR_put_error(9, 4095, 13, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/pem/pem_oth.c", 84);
  free(pdata);
  return v8;
}

int RSA_padding_add_X931(unsigned __int8 *to, int tlen, const unsigned __int8 *f, int fl)
{
  unsigned int v4;
  unsigned __int8 *v8;
  char v9;
  size_t v10;
  void *v11;

  v4 = tlen - fl;
  if (tlen - fl > 1)
  {
    v8 = to;
    if (v4 == 2)
    {
      v9 = 106;
    }
    else
    {
      *to = 107;
      v8 = to + 1;
      if (v4 >= 4)
      {
        v10 = v4 - 3;
        memset(v8, 187, v10);
        v8 += v10;
      }
      v9 = -70;
    }
    *v8 = v9;
    v11 = v8 + 1;
    memcpy(v11, f, fl);
    *((_BYTE *)v11 + fl) = -52;
    return 1;
  }
  else
  {
    ERR_put_error(4, 4095, 110, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/rsa/rsa_x931.c", 81);
    return -1;
  }
}

int RSA_padding_check_X931(unsigned __int8 *to, int tlen, const unsigned __int8 *f, int fl, int rsa_len)
{
  int v5;
  uint64_t v6;
  int v7;
  const unsigned __int8 *v8;
  int v9;
  int v10;
  int v11;
  unsigned int v12;

  if (rsa_len == fl)
  {
    v5 = *f;
    if ((v5 & 0xFE) == 0x6A)
    {
      if (v5 == 107)
      {
        if (rsa_len < 4)
        {
LABEL_20:
          v10 = 138;
          v11 = 129;
          goto LABEL_10;
        }
        v6 = 0;
        v7 = rsa_len - 3;
        v8 = &f[rsa_len - 4 + 2];
        while (1)
        {
          v9 = f[v6 + 1];
          if (v9 != 187)
            break;
          if (v7 == (_DWORD)++v6)
          {
            LODWORD(v6) = rsa_len - 3;
            goto LABEL_17;
          }
        }
        if (v9 != 186)
        {
          v10 = 138;
          v11 = 123;
          goto LABEL_10;
        }
        v8 = &f[v6 + 2];
LABEL_17:
        if (!(_DWORD)v6)
          goto LABEL_20;
        v12 = v7 - v6;
        if (v7 - (_DWORD)v6 < 0)
          goto LABEL_19;
      }
      else
      {
        v8 = f + 1;
        v12 = rsa_len - 2;
        if (rsa_len - 2 < 0)
        {
LABEL_19:
          v10 = 139;
          v11 = 138;
          goto LABEL_10;
        }
      }
      if (v8[v12] == 204)
      {
        memcpy(to, v8, v12);
        return v12;
      }
      goto LABEL_19;
    }
  }
  v10 = 137;
  v11 = 112;
LABEL_10:
  ERR_put_error(4, 4095, v10, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/rsa/rsa_x931.c", v11);
  return -1;
}

int RSA_X931_hash_id(int nid)
{
  if (nid > 672)
  {
    if (nid != 673)
    {
      if (nid == 674)
        return 53;
      return -1;
    }
    return 54;
  }
  else
  {
    if (nid != 64)
    {
      if (nid == 672)
        return 52;
      return -1;
    }
    return 51;
  }
}

const EVP_CIPHER *EVP_des_ede_cbc(void)
{
  return (const EVP_CIPHER *)&des_ede_cbc;
}

const EVP_CIPHER *EVP_des_ede_cfb64(void)
{
  return (const EVP_CIPHER *)&des_ede_cfb64;
}

const EVP_CIPHER *EVP_des_ede_ofb(void)
{
  return (const EVP_CIPHER *)&des_ede_ofb;
}

const EVP_CIPHER *EVP_des_ede_ecb(void)
{
  return (const EVP_CIPHER *)&des_ede_ecb;
}

const EVP_CIPHER *EVP_des_ede3_cbc(void)
{
  return (const EVP_CIPHER *)&des_ede3_cbc;
}

const EVP_CIPHER *EVP_des_ede3_cfb64(void)
{
  return (const EVP_CIPHER *)&des_ede3_cfb64;
}

const EVP_CIPHER *EVP_des_ede3_ofb(void)
{
  return (const EVP_CIPHER *)&des_ede3_ofb;
}

const EVP_CIPHER *EVP_des_ede3_ecb(void)
{
  return (const EVP_CIPHER *)&des_ede3_ecb;
}

const EVP_CIPHER *EVP_des_ede3_cfb1(void)
{
  return (const EVP_CIPHER *)&des_ede3_cfb1;
}

const EVP_CIPHER *EVP_des_ede3_cfb8(void)
{
  return (const EVP_CIPHER *)&des_ede3_cfb8;
}

const EVP_CIPHER *EVP_des_ede(void)
{
  return (const EVP_CIPHER *)&des_ede_ecb;
}

const EVP_CIPHER *EVP_des_ede3(void)
{
  return (const EVP_CIPHER *)&des_ede3_ecb;
}

uint64_t des_ede_init_key(uint64_t a1, const_DES_cblock *key)
{
  _OWORD *v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;

  DES_set_key_unchecked(key, *(DES_key_schedule **)(a1 + 120));
  DES_set_key_unchecked((const_DES_cblock *)&(*key)[8], (DES_key_schedule *)(*(_QWORD *)(a1 + 120) + 128));
  v4 = *(_OWORD **)(a1 + 120);
  v5 = v4[5];
  v4[20] = v4[4];
  v4[21] = v5;
  v6 = v4[7];
  v4[22] = v4[6];
  v4[23] = v6;
  v7 = v4[1];
  v4[16] = *v4;
  v4[17] = v7;
  v8 = v4[3];
  v4[18] = v4[2];
  v4[19] = v8;
  return 1;
}

uint64_t des_ede_cbc_cipher(uint64_t a1, unsigned __int8 *output, unsigned __int8 *input, unint64_t length)
{
  unint64_t i;

  for (i = length; i > 0x7FFFFFFFFFFFFEFFLL; output += 0x7FFFFFFFFFFFFF00)
  {
    DES_ede3_cbc_encrypt(input, output, 0x7FFFFFFFFFFFFF00, *(DES_key_schedule **)(a1 + 120), (DES_key_schedule *)(*(_QWORD *)(a1 + 120) + 128), (DES_key_schedule *)(*(_QWORD *)(a1 + 120) + 256), (DES_cblock *)(a1 + 40), *(_DWORD *)(a1 + 16));
    i -= 0x7FFFFFFFFFFFFF00;
    input += 0x7FFFFFFFFFFFFF00;
  }
  if (i)
    DES_ede3_cbc_encrypt(input, output, i, *(DES_key_schedule **)(a1 + 120), (DES_key_schedule *)(*(_QWORD *)(a1 + 120) + 128), (DES_key_schedule *)(*(_QWORD *)(a1 + 120) + 256), (DES_cblock *)(a1 + 40), *(_DWORD *)(a1 + 16));
  return 1;
}

uint64_t des3_ctrl(uint64_t a1, int a2, int a3, DES_cblock *ret)
{
  uint64_t result;

  if (a2 != 6)
    return 0xFFFFFFFFLL;
  result = DES_random_key(ret);
  if ((_DWORD)result)
  {
    if (*(int *)(a1 + 104) < 16)
      return 1;
    result = DES_random_key((DES_cblock *)&(*ret)[8]);
    if ((_DWORD)result)
    {
      if (*(int *)(a1 + 104) < 24)
        return 1;
      result = DES_random_key((DES_cblock *)&(*ret)[16]);
      if ((_DWORD)result)
        return 1;
    }
  }
  return result;
}

uint64_t des_ede_cfb64_cipher(uint64_t a1, unsigned __int8 *out, unsigned __int8 *in, unint64_t length)
{
  unint64_t i;

  for (i = length; i > 0x7FFFFFFFFFFFFEFFLL; out += 0x7FFFFFFFFFFFFF00)
  {
    DES_ede3_cfb64_encrypt(in, out, 0x7FFFFFFFFFFFFF00, *(DES_key_schedule **)(a1 + 120), (DES_key_schedule *)(*(_QWORD *)(a1 + 120) + 128), (DES_key_schedule *)(*(_QWORD *)(a1 + 120) + 256), (DES_cblock *)(a1 + 40), (int *)(a1 + 88), *(_DWORD *)(a1 + 16));
    i -= 0x7FFFFFFFFFFFFF00;
    in += 0x7FFFFFFFFFFFFF00;
  }
  if (i)
    DES_ede3_cfb64_encrypt(in, out, i, *(DES_key_schedule **)(a1 + 120), (DES_key_schedule *)(*(_QWORD *)(a1 + 120) + 128), (DES_key_schedule *)(*(_QWORD *)(a1 + 120) + 256), (DES_cblock *)(a1 + 40), (int *)(a1 + 88), *(_DWORD *)(a1 + 16));
  return 1;
}

uint64_t des_ede_ofb_cipher(uint64_t a1, unsigned __int8 *out, unsigned __int8 *in, unint64_t length)
{
  unint64_t i;

  for (i = length; i > 0x7FFFFFFFFFFFFEFFLL; out += 0x7FFFFFFFFFFFFF00)
  {
    DES_ede3_ofb64_encrypt(in, out, 0x7FFFFFFFFFFFFF00, *(DES_key_schedule **)(a1 + 120), (DES_key_schedule *)(*(_QWORD *)(a1 + 120) + 128), (DES_key_schedule *)(*(_QWORD *)(a1 + 120) + 256), (DES_cblock *)(a1 + 40), (int *)(a1 + 88));
    i -= 0x7FFFFFFFFFFFFF00;
    in += 0x7FFFFFFFFFFFFF00;
  }
  if (i)
    DES_ede3_ofb64_encrypt(in, out, i, *(DES_key_schedule **)(a1 + 120), (DES_key_schedule *)(*(_QWORD *)(a1 + 120) + 128), (DES_key_schedule *)(*(_QWORD *)(a1 + 120) + 256), (DES_cblock *)(a1 + 40), (int *)(a1 + 88));
  return 1;
}

uint64_t des_ede_ecb_cipher(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  unint64_t v4;
  unint64_t v5;
  unint64_t v9;

  v4 = *(int *)(*(_QWORD *)a1 + 4);
  v5 = a4 - v4;
  if (a4 >= v4)
  {
    v9 = 0;
    do
    {
      DES_ecb3_encrypt((const_DES_cblock *)(a3 + v9), (DES_cblock *)(a2 + v9), *(DES_key_schedule **)(a1 + 120), (DES_key_schedule *)(*(_QWORD *)(a1 + 120) + 128), (DES_key_schedule *)(*(_QWORD *)(a1 + 120) + 256), *(_DWORD *)(a1 + 16));
      v9 += v4;
    }
    while (v9 <= v5);
  }
  return 1;
}

uint64_t des_ede3_init_key(uint64_t a1, const_DES_cblock *key)
{
  DES_set_key_unchecked(key, *(DES_key_schedule **)(a1 + 120));
  DES_set_key_unchecked((const_DES_cblock *)&(*key)[8], (DES_key_schedule *)(*(_QWORD *)(a1 + 120) + 128));
  DES_set_key_unchecked((const_DES_cblock *)&(*key)[16], (DES_key_schedule *)(*(_QWORD *)(a1 + 120) + 256));
  return 1;
}

uint64_t des_ede3_cfb1_cipher(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  unint64_t v8;
  DES_cblock *v9;
  unsigned __int8 out;
  unsigned __int8 in;

  if ((*(_BYTE *)(a1 + 113) & 0x20) != 0)
    v4 = a4;
  else
    v4 = 8 * a4;
  if (v4)
  {
    v8 = 0;
    v9 = (DES_cblock *)(a1 + 40);
    do
    {
      in = *(unsigned __int8 *)(a3 + (v8 >> 3)) >> (v8 & 7 ^ 7) << 7;
      DES_ede3_cfb_encrypt(&in, &out, 1, 1, *(DES_key_schedule **)(a1 + 120), (DES_key_schedule *)(*(_QWORD *)(a1 + 120) + 128), (DES_key_schedule *)(*(_QWORD *)(a1 + 120) + 256), v9, *(_DWORD *)(a1 + 16));
      *(_BYTE *)(a2 + (v8 >> 3)) = ((out & 0x80) >> (v8 & 7)) | (-129 >> (v8 & 7)) & *(_BYTE *)(a2 + (v8 >> 3));
      ++v8;
    }
    while (v4 != v8);
  }
  return 1;
}

uint64_t des_ede3_cfb8_cipher(uint64_t a1, unsigned __int8 *out, unsigned __int8 *in, unint64_t length)
{
  unint64_t i;

  for (i = length; i > 0x7FFFFFFFFFFFFEFFLL; out += 0x7FFFFFFFFFFFFF00)
  {
    DES_ede3_cfb_encrypt(in, out, 8, 0x7FFFFFFFFFFFFF00, *(DES_key_schedule **)(a1 + 120), (DES_key_schedule *)(*(_QWORD *)(a1 + 120) + 128), (DES_key_schedule *)(*(_QWORD *)(a1 + 120) + 256), (DES_cblock *)(a1 + 40), *(_DWORD *)(a1 + 16));
    i -= 0x7FFFFFFFFFFFFF00;
    in += 0x7FFFFFFFFFFFFF00;
  }
  if (i)
    DES_ede3_cfb_encrypt(in, out, 8, i, *(DES_key_schedule **)(a1 + 120), (DES_key_schedule *)(*(_QWORD *)(a1 + 120) + 128), (DES_key_schedule *)(*(_QWORD *)(a1 + 120) + 256), (DES_cblock *)(a1 + 40), *(_DWORD *)(a1 + 16));
  return 1;
}

void OPENSSL_load_builtin_modules(void)
{
  ASN1_add_oid_module();
  ENGINE_add_conf_module();
}

uint64_t DH_check_params_ex(uint64_t a1)
{
  uint64_t result;
  int v2;
  int v3;

  v3 = 0;
  result = DH_check_params(a1, &v3);
  if ((_DWORD)result)
  {
    v2 = v3;
    if ((v3 & 1) != 0)
      ERR_put_error(5, 4095, 117, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/dh/dh_check.c", 84);
    if ((v2 & 8) != 0)
      ERR_put_error(5, 4095, 120, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/dh/dh_check.c", 86);
    return v2 == 0;
  }
  return result;
}

uint64_t DH_check_params(uint64_t a1, _DWORD *a2)
{
  const BIGNUM *v4;
  const BIGNUM *v5;
  BIGNUM *v6;
  BIGNUM *v7;
  uint64_t v8;

  *a2 = 0;
  if (!BN_is_odd(*(_QWORD *)(a1 + 8)))
    *a2 |= 1u;
  v4 = *(const BIGNUM **)(a1 + 16);
  v5 = BN_value_one();
  if (BN_cmp(v4, v5) <= 0)
    *a2 |= 8u;
  v6 = BN_dup(*(const BIGNUM **)(a1 + 8));
  v7 = v6;
  if (v6 && BN_sub_word(v6, 1uLL))
  {
    if ((BN_cmp(*(const BIGNUM **)(a1 + 16), v7) & 0x80000000) == 0)
      *a2 |= 8u;
    v8 = 1;
  }
  else
  {
    v8 = 0;
  }
  BN_free(v7);
  return v8;
}

uint64_t DH_check_ex(const DH *a1)
{
  uint64_t result;
  int v2;
  int codes;

  codes = 0;
  result = DH_check(a1, &codes);
  if ((_DWORD)result)
  {
    v2 = codes;
    if ((codes & 8) != 0)
    {
      ERR_put_error(5, 4095, 120, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/dh/dh_check.c", 139);
      if ((v2 & 0x10) == 0)
      {
LABEL_4:
        if ((v2 & 0x20) == 0)
          goto LABEL_5;
        goto LABEL_14;
      }
    }
    else if ((codes & 0x10) == 0)
    {
      goto LABEL_4;
    }
    ERR_put_error(5, 4095, 119, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/dh/dh_check.c", 141);
    if ((v2 & 0x20) == 0)
    {
LABEL_5:
      if ((v2 & 0x40) == 0)
        goto LABEL_6;
      goto LABEL_15;
    }
LABEL_14:
    ERR_put_error(5, 4095, 116, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/dh/dh_check.c", 143);
    if ((v2 & 0x40) == 0)
    {
LABEL_6:
      if ((v2 & 4) == 0)
        goto LABEL_7;
      goto LABEL_16;
    }
LABEL_15:
    ERR_put_error(5, 4095, 115, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/dh/dh_check.c", 145);
    if ((v2 & 4) == 0)
    {
LABEL_7:
      if ((v2 & 1) == 0)
        goto LABEL_8;
      goto LABEL_17;
    }
LABEL_16:
    ERR_put_error(5, 4095, 121, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/dh/dh_check.c", 147);
    if ((v2 & 1) == 0)
    {
LABEL_8:
      if ((v2 & 2) == 0)
        return v2 == 0;
LABEL_9:
      ERR_put_error(5, 4095, 118, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/dh/dh_check.c", 151);
      return v2 == 0;
    }
LABEL_17:
    ERR_put_error(5, 4095, 117, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/dh/dh_check.c", 149);
    if ((v2 & 2) == 0)
      return v2 == 0;
    goto LABEL_9;
  }
  return result;
}

int DH_check(const DH *dh, int *codes)
{
  BN_CTX *v4;
  BN_CTX *v5;
  BIGNUM *v6;
  const BIGNUM *v7;
  BIGNUM *v8;
  BIGNUM *v9;
  int is_prime;
  BIGNUM *j;
  int v12;
  BIGNUM *v13;
  const BIGNUM *v14;
  int v15;
  int v16;
  int v17;

  *codes = 0;
  if (!DH_check_params((uint64_t)dh, codes))
  {
    v5 = 0;
    goto LABEL_28;
  }
  v4 = BN_CTX_new();
  v5 = v4;
  if (v4)
  {
    BN_CTX_start(v4);
    if (dh->q)
    {
      v6 = BN_CTX_get(v5);
      if (!v6)
        goto LABEL_28;
      v7 = v6;
      v8 = BN_CTX_get(v5);
      if (!v8)
        goto LABEL_28;
      v9 = v8;
      if ((*(_BYTE *)codes & 8) == 0)
      {
        if (!BN_mod_exp_ct(v8, dh->g, dh->q, dh->p, v5))
          goto LABEL_28;
        if (!BN_is_one((uint64_t)v9))
          *codes |= 8u;
      }
      is_prime = BN_is_prime_ex(dh->q, 64, v5, 0);
      if (is_prime < 0)
        goto LABEL_28;
      if (!is_prime)
        *codes |= 0x10u;
      if (!BN_div_ct((uint64_t)v7, v9, dh->p, dh->q, v5))
        goto LABEL_28;
      if (!BN_is_one((uint64_t)v9))
        *codes |= 0x20u;
      j = dh->j;
      if (j && BN_cmp(j, v7))
        *codes |= 0x40u;
    }
    v12 = BN_is_prime_ex(dh->p, 64, v5, 0);
    if ((v12 & 0x80000000) == 0)
    {
      if (!v12)
      {
        v16 = 1;
        goto LABEL_31;
      }
      if (dh->q)
      {
LABEL_32:
        v17 = 1;
        goto LABEL_29;
      }
      v13 = BN_CTX_get(v5);
      if (v13)
      {
        v14 = v13;
        if (BN_rshift1(v13, dh->p))
        {
          v15 = BN_is_prime_ex(v14, 64, v5, 0);
          if ((v15 & 0x80000000) == 0)
          {
            if (!v15)
            {
              v16 = 2;
LABEL_31:
              *codes |= v16;
              goto LABEL_32;
            }
            goto LABEL_32;
          }
        }
      }
    }
  }
LABEL_28:
  v17 = 0;
LABEL_29:
  BN_CTX_end(v5);
  BN_CTX_free(v5);
  return v17;
}

uint64_t DH_check_pub_key_ex(const DH *a1, const BIGNUM *a2)
{
  uint64_t result;
  int v3;
  int codes;

  codes = 0;
  result = DH_check_pub_key(a1, a2, &codes);
  if ((_DWORD)result)
  {
    v3 = codes;
    if ((codes & 1) != 0)
    {
      ERR_put_error(5, 4095, 124, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/dh/dh_check.c", 240);
      if ((v3 & 2) == 0)
      {
LABEL_4:
        if ((v3 & 4) == 0)
          return v3 == 0;
LABEL_5:
        ERR_put_error(5, 4095, 122, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/dh/dh_check.c", 244);
        return v3 == 0;
      }
    }
    else if ((codes & 2) == 0)
    {
      goto LABEL_4;
    }
    ERR_put_error(5, 4095, 123, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/dh/dh_check.c", 242);
    if ((v3 & 4) == 0)
      return v3 == 0;
    goto LABEL_5;
  }
  return result;
}

int DH_check_pub_key(const DH *dh, const BIGNUM *pub_key, int *codes)
{
  BN_CTX *v6;
  BN_CTX *v7;
  BIGNUM *v8;
  BIGNUM *v9;
  const BIGNUM *v10;
  BIGNUM *p;
  const BIGNUM *v12;
  BIGNUM *v13;
  uint64_t v14;
  int v15;

  *codes = 0;
  v6 = BN_CTX_new();
  v7 = v6;
  if (!v6)
    goto LABEL_14;
  BN_CTX_start(v6);
  v8 = BN_CTX_get(v7);
  if (!v8)
    goto LABEL_14;
  v9 = v8;
  v10 = BN_value_one();
  if (BN_cmp(pub_key, v10) <= 0)
    *codes |= 1u;
  p = dh->p;
  v12 = BN_value_one();
  if (!BN_sub(v9, p, v12))
    goto LABEL_14;
  if ((BN_cmp(pub_key, v9) & 0x80000000) == 0)
    *codes |= 2u;
  if (!dh->q)
    goto LABEL_13;
  v13 = BN_CTX_get(v7);
  if (!v13 || (v14 = (uint64_t)v13, !BN_mod_exp_ct(v13, pub_key, dh->q, dh->p, v7)))
  {
LABEL_14:
    v15 = 0;
    goto LABEL_15;
  }
  if (!BN_is_one(v14))
    *codes = 4;
LABEL_13:
  v15 = 1;
LABEL_15:
  BN_CTX_end(v7);
  BN_CTX_free(v7);
  return v15;
}

void BF_set_key(BF_KEY *key, int len, const unsigned __int8 *data)
{
  uint64_t v6;
  int v7;
  const unsigned __int8 *v8;
  const unsigned __int8 *v9;
  const unsigned __int8 *v10;
  int v11;
  int v12;
  const unsigned __int8 *v13;
  int v14;
  int v15;
  const unsigned __int8 *v16;
  int v17;
  int v18;
  int v19;
  int v20;
  unint64_t v21;
  BF_KEY *v22;
  unint64_t v23;
  uint64_t v24;
  _QWORD v25[2];

  v25[1] = *MEMORY[0x24BDAC8D0];
  memcpy(key, &bf_init, sizeof(BF_KEY));
  v6 = 0;
  if (len >= 72)
    v7 = 72;
  else
    v7 = len;
  v8 = &data[v7];
  v9 = data;
  do
  {
    v12 = *v9;
    v10 = v9 + 1;
    v11 = v12;
    if (v10 >= v8)
      v10 = data;
    v15 = *v10;
    v13 = v10 + 1;
    v14 = v15;
    if (v13 >= v8)
      v13 = data;
    v17 = *v13;
    v16 = v13 + 1;
    v18 = (v11 << 16) | (v14 << 8) | v17;
    if (v16 >= v8)
      v16 = data;
    v19 = *v16;
    v9 = v16 + 1;
    v20 = v19 | (v18 << 8);
    if (v9 >= v8)
      v9 = data;
    key->P[v6++] ^= v20;
  }
  while (v6 != 18);
  v25[0] = 0;
  v21 = -2;
  v22 = key;
  do
  {
    BF_encrypt((unsigned int *)v25, key);
    *(_QWORD *)v22->P = v25[0];
    v22 = (BF_KEY *)((char *)v22 + 8);
    v21 += 2;
  }
  while (v21 < 0x10);
  v23 = -2;
  v24 = 18;
  do
  {
    BF_encrypt((unsigned int *)v25, key);
    *(_QWORD *)&key->P[v24] = v25[0];
    v23 += 2;
    v24 += 2;
  }
  while (v23 < 0x3FE);
}

void ERR_load_PEM_strings(void)
{
  if (!ERR_func_error_string(PEM_str_functs))
  {
    ERR_load_strings(0, (ERR_STRING_DATA *)&PEM_str_functs);
    ERR_load_strings(0, (ERR_STRING_DATA *)&PEM_str_reasons);
  }
}

PBEPARAM *__cdecl d2i_PBEPARAM(PBEPARAM **a, const unsigned __int8 **in, uint64_t len)
{
  return (PBEPARAM *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &PBEPARAM_it);
}

int i2d_PBEPARAM(PBEPARAM *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &PBEPARAM_it);
}

PBEPARAM *PBEPARAM_new(void)
{
  return (PBEPARAM *)ASN1_item_new(&PBEPARAM_it);
}

void PBEPARAM_free(PBEPARAM *a)
{
  ASN1_item_free((ASN1_VALUE *)a, &PBEPARAM_it);
}

uint64_t PKCS5_pbe_set0_algor(X509_ALGOR *a1, int a2, int a3, const void *a4, int a5)
{
  ASN1_VALUE *v10;
  ASN1_VALUE *v11;
  uint64_t v12;
  unsigned __int8 *v13;
  int v14;
  ASN1_OBJECT *v15;
  ASN1_OCTET_STRING *oct;

  oct = 0;
  v10 = ASN1_item_new(&PBEPARAM_it);
  if (!v10)
  {
    ERR_put_error(13, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/p5_pbe.c", 130);
    goto LABEL_20;
  }
  v11 = v10;
  if (a3 >= 1)
    v12 = a3;
  else
    v12 = 2048;
  if (!ASN1_INTEGER_set(*((ASN1_INTEGER **)v10 + 1), v12))
  {
    v14 = 136;
LABEL_19:
    ERR_put_error(13, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/p5_pbe.c", v14);
    ASN1_item_free(v11, &PBEPARAM_it);
    goto LABEL_20;
  }
  if (!a5)
    a5 = 8;
  if (!ASN1_STRING_set(*(ASN1_STRING **)v11, 0, a5))
  {
    v14 = 142;
    goto LABEL_19;
  }
  v13 = ASN1_STRING_data(*(ASN1_STRING **)v11);
  if (a4)
    memcpy(v13, a4, a5);
  else
    arc4random_buf(v13, a5);
  if (!ASN1_item_pack(v11, &PBEPARAM_it, &oct))
  {
    v14 = 152;
    goto LABEL_19;
  }
  ASN1_item_free(v11, &PBEPARAM_it);
  v15 = OBJ_nid2obj(a2);
  if (X509_ALGOR_set0(a1, v15, 16, oct))
    return 1;
LABEL_20:
  ASN1_STRING_free(oct);
  return 0;
}

X509_ALGOR *__cdecl PKCS5_pbe_set(int alg, int iter, unsigned __int8 *salt, int saltlen)
{
  X509_ALGOR *v8;
  X509_ALGOR *v9;

  v8 = X509_ALGOR_new();
  v9 = v8;
  if (v8)
  {
    if (!PKCS5_pbe_set0_algor(v8, alg, iter, salt, saltlen))
    {
      X509_ALGOR_free(v9);
      return 0;
    }
  }
  else
  {
    ERR_put_error(13, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/p5_pbe.c", 177);
  }
  return v9;
}

PKCS7 *__cdecl d2i_PKCS7(PKCS7 **a, const unsigned __int8 **in, uint64_t len)
{
  return (PKCS7 *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &PKCS7_it);
}

int i2d_PKCS7(PKCS7 *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &PKCS7_it);
}

PKCS7 *PKCS7_new(void)
{
  return (PKCS7 *)ASN1_item_new(&PKCS7_it);
}

void PKCS7_free(PKCS7 *a)
{
  ASN1_item_free((ASN1_VALUE *)a, &PKCS7_it);
}

PKCS7 *__cdecl PKCS7_dup(PKCS7 *p7)
{
  return (PKCS7 *)ASN1_item_dup(&PKCS7_it, p7);
}

PKCS7_SIGNED *__cdecl d2i_PKCS7_SIGNED(PKCS7_SIGNED **a, const unsigned __int8 **in, uint64_t len)
{
  return (PKCS7_SIGNED *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &PKCS7_SIGNED_it);
}

int i2d_PKCS7_SIGNED(PKCS7_SIGNED *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &PKCS7_SIGNED_it);
}

PKCS7_SIGNED *PKCS7_SIGNED_new(void)
{
  return (PKCS7_SIGNED *)ASN1_item_new(&PKCS7_SIGNED_it);
}

void PKCS7_SIGNED_free(PKCS7_SIGNED *a)
{
  ASN1_item_free((ASN1_VALUE *)a, &PKCS7_SIGNED_it);
}

PKCS7_SIGNER_INFO *__cdecl d2i_PKCS7_SIGNER_INFO(PKCS7_SIGNER_INFO **a, const unsigned __int8 **in, uint64_t len)
{
  return (PKCS7_SIGNER_INFO *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &PKCS7_SIGNER_INFO_it);
}

int i2d_PKCS7_SIGNER_INFO(PKCS7_SIGNER_INFO *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &PKCS7_SIGNER_INFO_it);
}

PKCS7_SIGNER_INFO *PKCS7_SIGNER_INFO_new(void)
{
  return (PKCS7_SIGNER_INFO *)ASN1_item_new(&PKCS7_SIGNER_INFO_it);
}

void PKCS7_SIGNER_INFO_free(PKCS7_SIGNER_INFO *a)
{
  ASN1_item_free((ASN1_VALUE *)a, &PKCS7_SIGNER_INFO_it);
}

PKCS7_ISSUER_AND_SERIAL *__cdecl d2i_PKCS7_ISSUER_AND_SERIAL(PKCS7_ISSUER_AND_SERIAL **a, const unsigned __int8 **in, uint64_t len)
{
  return (PKCS7_ISSUER_AND_SERIAL *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &PKCS7_ISSUER_AND_SERIAL_it);
}

int i2d_PKCS7_ISSUER_AND_SERIAL(PKCS7_ISSUER_AND_SERIAL *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &PKCS7_ISSUER_AND_SERIAL_it);
}

PKCS7_ISSUER_AND_SERIAL *PKCS7_ISSUER_AND_SERIAL_new(void)
{
  return (PKCS7_ISSUER_AND_SERIAL *)ASN1_item_new(&PKCS7_ISSUER_AND_SERIAL_it);
}

void PKCS7_ISSUER_AND_SERIAL_free(PKCS7_ISSUER_AND_SERIAL *a)
{
  ASN1_item_free((ASN1_VALUE *)a, &PKCS7_ISSUER_AND_SERIAL_it);
}

PKCS7_ENVELOPE *__cdecl d2i_PKCS7_ENVELOPE(PKCS7_ENVELOPE **a, const unsigned __int8 **in, uint64_t len)
{
  return (PKCS7_ENVELOPE *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &PKCS7_ENVELOPE_it);
}

int i2d_PKCS7_ENVELOPE(PKCS7_ENVELOPE *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &PKCS7_ENVELOPE_it);
}

PKCS7_ENVELOPE *PKCS7_ENVELOPE_new(void)
{
  return (PKCS7_ENVELOPE *)ASN1_item_new(&PKCS7_ENVELOPE_it);
}

void PKCS7_ENVELOPE_free(PKCS7_ENVELOPE *a)
{
  ASN1_item_free((ASN1_VALUE *)a, &PKCS7_ENVELOPE_it);
}

PKCS7_RECIP_INFO *__cdecl d2i_PKCS7_RECIP_INFO(PKCS7_RECIP_INFO **a, const unsigned __int8 **in, uint64_t len)
{
  return (PKCS7_RECIP_INFO *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &PKCS7_RECIP_INFO_it);
}

int i2d_PKCS7_RECIP_INFO(PKCS7_RECIP_INFO *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &PKCS7_RECIP_INFO_it);
}

PKCS7_RECIP_INFO *PKCS7_RECIP_INFO_new(void)
{
  return (PKCS7_RECIP_INFO *)ASN1_item_new(&PKCS7_RECIP_INFO_it);
}

void PKCS7_RECIP_INFO_free(PKCS7_RECIP_INFO *a)
{
  ASN1_item_free((ASN1_VALUE *)a, &PKCS7_RECIP_INFO_it);
}

PKCS7_ENC_CONTENT *__cdecl d2i_PKCS7_ENC_CONTENT(PKCS7_ENC_CONTENT **a, const unsigned __int8 **in, uint64_t len)
{
  return (PKCS7_ENC_CONTENT *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &PKCS7_ENC_CONTENT_it);
}

int i2d_PKCS7_ENC_CONTENT(PKCS7_ENC_CONTENT *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &PKCS7_ENC_CONTENT_it);
}

PKCS7_ENC_CONTENT *PKCS7_ENC_CONTENT_new(void)
{
  return (PKCS7_ENC_CONTENT *)ASN1_item_new(&PKCS7_ENC_CONTENT_it);
}

void PKCS7_ENC_CONTENT_free(PKCS7_ENC_CONTENT *a)
{
  ASN1_item_free((ASN1_VALUE *)a, &PKCS7_ENC_CONTENT_it);
}

PKCS7_SIGN_ENVELOPE *__cdecl d2i_PKCS7_SIGN_ENVELOPE(PKCS7_SIGN_ENVELOPE **a, const unsigned __int8 **in, uint64_t len)
{
  return (PKCS7_SIGN_ENVELOPE *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &PKCS7_SIGN_ENVELOPE_it);
}

int i2d_PKCS7_SIGN_ENVELOPE(PKCS7_SIGN_ENVELOPE *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &PKCS7_SIGN_ENVELOPE_it);
}

PKCS7_SIGN_ENVELOPE *PKCS7_SIGN_ENVELOPE_new(void)
{
  return (PKCS7_SIGN_ENVELOPE *)ASN1_item_new(&PKCS7_SIGN_ENVELOPE_it);
}

void PKCS7_SIGN_ENVELOPE_free(PKCS7_SIGN_ENVELOPE *a)
{
  ASN1_item_free((ASN1_VALUE *)a, &PKCS7_SIGN_ENVELOPE_it);
}

PKCS7_ENCRYPT *__cdecl d2i_PKCS7_ENCRYPT(PKCS7_ENCRYPT **a, const unsigned __int8 **in, uint64_t len)
{
  return (PKCS7_ENCRYPT *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &PKCS7_ENCRYPT_it);
}

int i2d_PKCS7_ENCRYPT(PKCS7_ENCRYPT *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &PKCS7_ENCRYPT_it);
}

PKCS7_ENCRYPT *PKCS7_ENCRYPT_new(void)
{
  return (PKCS7_ENCRYPT *)ASN1_item_new(&PKCS7_ENCRYPT_it);
}

void PKCS7_ENCRYPT_free(PKCS7_ENCRYPT *a)
{
  ASN1_item_free((ASN1_VALUE *)a, &PKCS7_ENCRYPT_it);
}

PKCS7_DIGEST *__cdecl d2i_PKCS7_DIGEST(PKCS7_DIGEST **a, const unsigned __int8 **in, uint64_t len)
{
  return (PKCS7_DIGEST *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &PKCS7_DIGEST_it);
}

int i2d_PKCS7_DIGEST(PKCS7_DIGEST *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &PKCS7_DIGEST_it);
}

PKCS7_DIGEST *PKCS7_DIGEST_new(void)
{
  return (PKCS7_DIGEST *)ASN1_item_new(&PKCS7_DIGEST_it);
}

void PKCS7_DIGEST_free(PKCS7_DIGEST *a)
{
  ASN1_item_free((ASN1_VALUE *)a, &PKCS7_DIGEST_it);
}

uint64_t PKCS7_print_ctx(BIO *a1, ASN1_VALUE *a2, uint64_t a3, uint64_t *a4)
{
  return ASN1_item_print(a1, a2, a3, (ASN1_ITEM *)&PKCS7_it, a4);
}

PKCS7 *__cdecl d2i_PKCS7_bio(BIO *bp, PKCS7 **p7)
{
  return (PKCS7 *)ASN1_item_d2i_bio(&PKCS7_it, bp, p7);
}

int i2d_PKCS7_bio(BIO *bp, PKCS7 *p7)
{
  return ASN1_item_i2d_bio(&PKCS7_it, bp, p7);
}

PKCS7 *__cdecl d2i_PKCS7_fp(FILE *fp, PKCS7 **p7)
{
  return (PKCS7 *)ASN1_item_d2i_fp(&PKCS7_it, fp, p7);
}

int i2d_PKCS7_fp(FILE *fp, PKCS7 *p7)
{
  return ASN1_item_i2d_fp(&PKCS7_it, fp, p7);
}

int PKCS7_ISSUER_AND_SERIAL_digest(PKCS7_ISSUER_AND_SERIAL *data, const EVP_MD *type, unsigned __int8 *md, unsigned int *len)
{
  return ASN1_item_digest(&PKCS7_ISSUER_AND_SERIAL_it, type, data, md, len);
}

uint64_t pk7_cb(int a1, uint64_t *a2, uint64_t a3, uint64_t a4)
{
  uint64_t result;

  switch(a1)
  {
    case 10:
      if ((int)PKCS7_stream((_QWORD *)(a4 + 16), *a2) < 1)
        goto LABEL_7;
      goto LABEL_5;
    case 11:
    case 13:
      if (PKCS7_dataFinal((PKCS7 *)*a2, *(BIO **)(a4 + 8)) >= 1)
        goto LABEL_6;
LABEL_7:
      result = 0;
      break;
    case 12:
LABEL_5:
      result = (uint64_t)PKCS7_dataInit((PKCS7 *)*a2, *(BIO **)a4);
      *(_QWORD *)(a4 + 8) = result;
      if (result)
        goto LABEL_6;
      return result;
    default:
LABEL_6:
      result = 1;
      break;
  }
  return result;
}

uint64_t si_cb(int a1, uint64_t a2)
{
  if (a1 == 3)
    EVP_PKEY_free(*(EVP_PKEY **)(*(_QWORD *)a2 + 56));
  return 1;
}

uint64_t ri_cb(int a1, uint64_t a2)
{
  if (a1 == 3)
    X509_free(*(X509 **)(*(_QWORD *)a2 + 32));
  return 1;
}

uint64_t HKDF(uint64_t a1, size_t a2, EVP_MD *a3, const unsigned __int8 *a4, size_t a5, void *a6, int a7, const unsigned __int8 *a8, size_t a9)
{
  uint64_t result;
  uint64_t v14;
  unsigned __int8 md[64];
  uint64_t v16;

  v16 = *MEMORY[0x24BDAC8D0];
  v14 = 0;
  result = HKDF_extract(md, &v14, a3, a4, a5, a6, a7);
  if ((_DWORD)result)
    return HKDF_expand(a1, a2, a3, md, v14, a8, a9) != 0;
  return result;
}

uint64_t HKDF_extract(unsigned __int8 *md, _QWORD *a2, EVP_MD *evp_md, const unsigned __int8 *a4, size_t a5, void *key, int key_len)
{
  unsigned int md_len;

  md_len = 0;
  if (HMAC(evp_md, key, key_len, a4, a5, md, &md_len))
  {
    *a2 = md_len;
    return 1;
  }
  else
  {
    ERR_put_error(15, 4095, 15, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/hkdf/hkdf.c", 60);
    return 0;
  }
}

uint64_t HKDF_expand(uint64_t a1, size_t a2, EVP_MD *md, const void *a4, int a5, const unsigned __int8 *a6, size_t a7)
{
  int v14;
  size_t v15;
  size_t v16;
  size_t v17;
  unint64_t v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  unsigned int v22;
  int v23;
  int v24;
  int v25;
  int v26;
  int v27;
  size_t v28;
  unsigned __int8 v31;
  HMAC_CTX ctx;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  unsigned __int8 data[64];
  uint64_t v38;

  v38 = *MEMORY[0x24BDAC8D0];
  v14 = EVP_MD_size(md);
  v15 = a2 + v14;
  if (__CFADD__(a2, v14) || (v16 = v14, v17 = v15 - 1, v18 = (v15 - 1) / v14, v18 >= 0x100))
  {
    ERR_put_error(15, 4095, 164, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/hkdf/hkdf.c", 83);
    return 0;
  }
  v35 = 0u;
  v36 = 0u;
  v33 = 0u;
  v34 = 0u;
  memset(&ctx, 0, sizeof(ctx));
  HMAC_CTX_init(&ctx);
  HMAC_Init_ex(&ctx, a4, a5, md, 0);
  if (v19)
  {
    if (v17 < v16)
    {
LABEL_5:
      v20 = 1;
      goto LABEL_20;
    }
    v21 = 0;
    v22 = 1;
    while (1)
    {
      v31 = v22;
      if (v22 != 1)
      {
        HMAC_Init_ex(&ctx, 0, 0, 0, 0);
        if (!v23)
          break;
        HMAC_Update(&ctx, data, v16);
        if (!v24)
          break;
      }
      HMAC_Update(&ctx, a6, a7);
      if (!v25)
        break;
      HMAC_Update(&ctx, &v31, 1uLL);
      if (!v26)
        break;
      HMAC_Final(&ctx, data, 0);
      if (!v27)
        break;
      if (v21 + v16 <= a2)
        v28 = v16;
      else
        v28 = a2 - v21;
      memcpy((void *)(a1 + v21), data, v28);
      v21 += v28;
      if (v18 <= v22++)
        goto LABEL_5;
    }
  }
  v20 = 0;
LABEL_20:
  HMAC_CTX_cleanup(&ctx);
  explicit_bzero(data, 0x40uLL);
  if ((v20 & 1) == 0)
    ERR_put_error(15, 4095, 15, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/hkdf/hkdf.c", 118);
  return v20;
}

X509_CERT_AUX *__cdecl d2i_X509_CERT_AUX(X509_CERT_AUX **a, const unsigned __int8 **in, uint64_t len)
{
  return (X509_CERT_AUX *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &X509_CERT_AUX_it);
}

int i2d_X509_CERT_AUX(X509_CERT_AUX *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &X509_CERT_AUX_it);
}

X509_CERT_AUX *X509_CERT_AUX_new(void)
{
  return (X509_CERT_AUX *)ASN1_item_new(&X509_CERT_AUX_it);
}

void X509_CERT_AUX_free(X509_CERT_AUX *a)
{
  ASN1_item_free((ASN1_VALUE *)a, &X509_CERT_AUX_it);
}

int X509_alias_set1(X509 *x, unsigned __int8 *name, int len)
{
  uint64_t ex_pcpathlen;
  ASN1_STRING *v7;
  uint64_t v8;
  ASN1_UTF8STRING *v9;

  if (name)
  {
    if (x)
    {
      ex_pcpathlen = x[1].ex_pcpathlen;
      if (ex_pcpathlen
        || (v7 = (ASN1_STRING *)ASN1_item_new(&X509_CERT_AUX_it),
            ex_pcpathlen = (uint64_t)v7,
            (x[1].ex_pcpathlen = (uint64_t)v7) != 0))
      {
        v7 = *(ASN1_STRING **)(ex_pcpathlen + 16);
        if (v7 || (v7 = ASN1_UTF8STRING_new(), (*(_QWORD *)(ex_pcpathlen + 16) = v7) != 0))
          LODWORD(v7) = ASN1_STRING_set(v7, name, len);
      }
    }
    else
    {
      LODWORD(v7) = 0;
    }
  }
  else
  {
    if (x)
    {
      v8 = x[1].ex_pcpathlen;
      if (v8)
      {
        v9 = *(ASN1_UTF8STRING **)(v8 + 16);
        if (v9)
        {
          ASN1_UTF8STRING_free(v9);
          *(_QWORD *)(x[1].ex_pcpathlen + 16) = 0;
        }
      }
    }
    LODWORD(v7) = 1;
  }
  return (int)v7;
}

int X509_keyid_set1(X509 *x, unsigned __int8 *id, int len)
{
  uint64_t ex_pcpathlen;
  ASN1_STRING *v7;
  uint64_t v8;
  ASN1_OCTET_STRING *v9;

  if (id)
  {
    if (x)
    {
      ex_pcpathlen = x[1].ex_pcpathlen;
      if (ex_pcpathlen
        || (v7 = (ASN1_STRING *)ASN1_item_new(&X509_CERT_AUX_it),
            ex_pcpathlen = (uint64_t)v7,
            (x[1].ex_pcpathlen = (uint64_t)v7) != 0))
      {
        v7 = *(ASN1_STRING **)(ex_pcpathlen + 24);
        if (v7 || (v7 = ASN1_OCTET_STRING_new(), (*(_QWORD *)(ex_pcpathlen + 24) = v7) != 0))
          LODWORD(v7) = ASN1_STRING_set(v7, id, len);
      }
    }
    else
    {
      LODWORD(v7) = 0;
    }
  }
  else
  {
    if (x)
    {
      v8 = x[1].ex_pcpathlen;
      if (v8)
      {
        v9 = *(ASN1_OCTET_STRING **)(v8 + 24);
        if (v9)
        {
          ASN1_OCTET_STRING_free(v9);
          *(_QWORD *)(x[1].ex_pcpathlen + 24) = 0;
        }
      }
    }
    LODWORD(v7) = 1;
  }
  return (int)v7;
}

unsigned __int8 *__cdecl X509_alias_get0(X509 *x, int *len)
{
  uint64_t ex_pcpathlen;
  uint64_t v3;

  ex_pcpathlen = x[1].ex_pcpathlen;
  if (!ex_pcpathlen)
    return 0;
  v3 = *(_QWORD *)(ex_pcpathlen + 16);
  if (!v3)
    return 0;
  if (len)
    *len = *(_DWORD *)v3;
  return *(unsigned __int8 **)(v3 + 8);
}

unsigned __int8 *__cdecl X509_keyid_get0(X509 *x, int *len)
{
  uint64_t ex_pcpathlen;
  uint64_t v3;

  ex_pcpathlen = x[1].ex_pcpathlen;
  if (!ex_pcpathlen)
    return 0;
  v3 = *(_QWORD *)(ex_pcpathlen + 24);
  if (!v3)
    return 0;
  if (len)
    *len = *(_DWORD *)v3;
  return *(unsigned __int8 **)(v3 + 8);
}

int X509_add1_trust_object(X509 *x, ASN1_OBJECT *obj)
{
  ASN1_OBJECT *v3;
  ASN1_OBJECT *v4;
  STACK **ex_pcpathlen;
  STACK *v6;

  v3 = OBJ_dup(obj);
  if (v3)
  {
    v4 = v3;
    if (!x)
      goto LABEL_8;
    ex_pcpathlen = (STACK **)x[1].ex_pcpathlen;
    if (!ex_pcpathlen)
    {
      ex_pcpathlen = (STACK **)ASN1_item_new(&X509_CERT_AUX_it);
      x[1].ex_pcpathlen = (uint64_t)ex_pcpathlen;
      if (!ex_pcpathlen)
        goto LABEL_8;
    }
    if ((v6 = *ex_pcpathlen) == 0 && (v6 = sk_new_null(), (*ex_pcpathlen = v6) == 0)
      || (LODWORD(v3) = sk_push(v6, (char *)v4), !(_DWORD)v3))
    {
LABEL_8:
      ASN1_OBJECT_free(v4);
      LODWORD(v3) = 0;
    }
  }
  return (int)v3;
}

int X509_add1_reject_object(X509 *x, ASN1_OBJECT *obj)
{
  ASN1_OBJECT *v3;
  ASN1_OBJECT *v4;
  uint64_t ex_pcpathlen;
  STACK *v6;

  v3 = OBJ_dup(obj);
  if (v3)
  {
    v4 = v3;
    if (!x)
      goto LABEL_8;
    ex_pcpathlen = x[1].ex_pcpathlen;
    if (!ex_pcpathlen)
    {
      ex_pcpathlen = (uint64_t)ASN1_item_new(&X509_CERT_AUX_it);
      x[1].ex_pcpathlen = ex_pcpathlen;
      if (!ex_pcpathlen)
        goto LABEL_8;
    }
    if ((v6 = *(STACK **)(ex_pcpathlen + 8)) == 0
      && (v6 = sk_new_null(), (*(_QWORD *)(ex_pcpathlen + 8) = v6) == 0)
      || (LODWORD(v3) = sk_push(v6, (char *)v4), !(_DWORD)v3))
    {
LABEL_8:
      ASN1_OBJECT_free(v4);
      LODWORD(v3) = 0;
    }
  }
  return (int)v3;
}

void X509_trust_clear(X509 *x)
{
  STACK **ex_pcpathlen;

  ex_pcpathlen = (STACK **)x[1].ex_pcpathlen;
  if (ex_pcpathlen)
  {
    if (*ex_pcpathlen)
    {
      sk_pop_free(*ex_pcpathlen, (void (__cdecl *)(void *))ASN1_OBJECT_free);
      *(_QWORD *)x[1].ex_pcpathlen = 0;
    }
  }
}

void X509_reject_clear(X509 *x)
{
  uint64_t ex_pcpathlen;
  STACK *v3;

  ex_pcpathlen = x[1].ex_pcpathlen;
  if (ex_pcpathlen)
  {
    v3 = *(STACK **)(ex_pcpathlen + 8);
    if (v3)
    {
      sk_pop_free(v3, (void (__cdecl *)(void *))ASN1_OBJECT_free);
      *(_QWORD *)(x[1].ex_pcpathlen + 8) = 0;
    }
  }
}

const EVP_MD *EVP_md4(void)
{
  return (const EVP_MD *)&md4_md;
}

uint64_t init(uint64_t a1)
{
  return MD4_Init(*(MD4_CTX **)(a1 + 24));
}

uint64_t update(uint64_t a1, const void *a2, size_t a3)
{
  return MD4_Update(*(MD4_CTX **)(a1 + 24), a2, a3);
}

uint64_t final(uint64_t a1, unsigned __int8 *md)
{
  return MD4_Final(md, *(MD4_CTX **)(a1 + 24));
}

uint64_t CRYPTO_ofb128_encrypt(uint64_t result, _BYTE *a2, unint64_t a3, uint64_t a4, uint64_t a5, unsigned int *a6, uint64_t (*a7)(uint64_t, uint64_t, uint64_t))
{
  char *v12;
  unsigned int v13;
  BOOL v14;
  unint64_t v15;
  char v16;
  unint64_t v17;
  BOOL v18;
  unsigned int v19;

  v12 = (char *)result;
  v13 = *a6;
  if (*a6)
    v14 = a3 == 0;
  else
    v14 = 1;
  if (v14)
  {
    v15 = a3;
  }
  else
  {
    do
    {
      v16 = *v12++;
      *a2++ = *(_BYTE *)(a5 + v13) ^ v16;
      v15 = a3 - 1;
      v13 = ((_BYTE)v13 + 1) & 0xF;
      if (!v13)
        break;
      --a3;
    }
    while (a3);
  }
  if (v15 < 0x10)
  {
    v19 = v13;
    if (!v15)
      goto LABEL_20;
    goto LABEL_18;
  }
  do
  {
    result = a7(a5, a5, a4);
    if (v13 <= 0xF)
    {
      v17 = v13;
      do
      {
        *(_QWORD *)&a2[v17] = *(_QWORD *)(a5 + v17) ^ *(_QWORD *)&v12[v17];
        v18 = v17 >= 8;
        v17 += 8;
      }
      while (!v18);
    }
    v13 = 0;
    v19 = 0;
    v15 -= 16;
    a2 += 16;
    v12 += 16;
  }
  while (v15 > 0xF);
  if (v15)
  {
LABEL_18:
    result = a7(a5, a5, a4);
    do
    {
      a2[v19] = *(_BYTE *)(a5 + v19) ^ v12[v19];
      ++v19;
      --v15;
    }
    while (v15);
  }
LABEL_20:
  *a6 = v19;
  return result;
}

uint64_t i2r_certpol(int a1, STACK *a2, BIO *a3, int a4)
{
  const STACK *v5;
  int v6;
  char *v7;
  const STACK *v8;
  int v9;
  char *v10;
  int v11;
  uint64_t *v12;
  uint64_t v13;
  int v14;
  const char *v15;
  int v16;
  char *v17;
  char *v18;
  STACK *v20;
  int v22;
  int v23;

  v5 = a2;
  if (sk_num(a2) >= 1)
  {
    v6 = 0;
    v23 = a4 + 4;
    v20 = (STACK *)v5;
    do
    {
      v22 = v6;
      v7 = sk_value(v5, v6);
      BIO_printf(a3, "%*sPolicy: ", a4, "");
      i2a_ASN1_OBJECT(a3, *(ASN1_OBJECT **)v7);
      BIO_puts(a3, "\n");
      v8 = (const STACK *)*((_QWORD *)v7 + 1);
      if (v8 && sk_num(*((const STACK **)v7 + 1)) >= 1)
      {
        v9 = 0;
        do
        {
          v10 = sk_value(v8, v9);
          v11 = OBJ_obj2nid(*(const ASN1_OBJECT **)v10);
          if (v11 == 165)
          {
            BIO_printf(a3, "%*sUser Notice:\n", a4 + 2, "");
            v12 = (uint64_t *)*((_QWORD *)v10 + 1);
            v13 = *v12;
            if (*v12)
            {
              BIO_printf(a3, "%*sOrganization: %.*s\n", v23, "", **(_DWORD **)v13, *(const char **)(*(_QWORD *)v13 + 8));
              v14 = sk_num(*(const STACK **)(v13 + 8));
              v15 = "s";
              if (v14 <= 1)
                v15 = "";
              BIO_printf(a3, "%*sNumber%s: ", v23, "", v15);
              if (sk_num(*(const STACK **)(v13 + 8)) >= 1)
              {
                v16 = 0;
                do
                {
                  v17 = sk_value(*(const STACK **)(v13 + 8), v16);
                  if (v16)
                    BIO_puts(a3, ", ");
                  v18 = i2s_ASN1_INTEGER(0, (ASN1_INTEGER *)v17);
                  BIO_puts(a3, v18);
                  free(v18);
                  ++v16;
                }
                while (v16 < sk_num(*(const STACK **)(v13 + 8)));
              }
              BIO_puts(a3, "\n");
            }
            if (v12[1])
              BIO_printf(a3, "%*sExplicit Text: %.*s\n");
          }
          else if (v11 == 164)
          {
            BIO_printf(a3, "%*sCPS: %.*s\n");
          }
          else
          {
            BIO_printf(a3, "%*sUnknown Qualifier: ", v23, "");
            i2a_ASN1_OBJECT(a3, *(ASN1_OBJECT **)v10);
            BIO_puts(a3, "\n");
          }
          ++v9;
        }
        while (v9 < sk_num(v8));
      }
      v6 = v22 + 1;
      v5 = v20;
    }
    while (v22 + 1 < sk_num(v20));
  }
  return 1;
}

STACK *r2i_certpol(uint64_t a1, X509V3_CTX *a2, const char *a3)
{
  STACK *v5;
  STACK *v6;
  STACK *v7;
  int v8;
  int v9;
  char *v10;
  const char **v11;
  uint64_t v12;
  STACK *section;
  STACK *v14;
  ASN1_VALUE *v15;
  int v16;
  int v17;
  const char **v18;
  const char *v19;
  const char *v20;
  STACK *v21;
  STACK *v22;
  ASN1_VALUE *v23;
  ASN1_VALUE *v24;
  int v25;
  const char **v26;
  const char *v27;
  ASN1_VALUE *v28;
  ASN1_VALUE *v29;
  STACK *v30;
  STACK *v31;
  STACK *v32;
  int v33;
  char *v34;
  char *v35;
  ASN1_STRING *v36;
  ASN1_VALUE *v37;
  int v38;
  ASN1_VALUE *v39;
  STACK *v40;
  ASN1_OBJECT *v41;
  ASN1_VALUE *v42;
  ASN1_IA5STRING *v43;
  ASN1_STRING *v44;
  const char *v45;
  int v46;
  STACK *v47;
  ASN1_OBJECT *v48;
  ASN1_OBJECT *v49;
  int v50;
  int v51;
  int v52;
  int v53;
  int v54;
  int v55;
  int v56;
  int v57;
  int v58;
  int v59;
  int v60;
  int v61;
  int v63;
  ASN1_VALUE *v64;
  X509V3_CTX *ctx;
  STACK *v66;
  int v67;
  char *data;

  v5 = sk_new_null();
  if (!v5)
  {
    ERR_put_error(34, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_cpols.c", 431);
    return v5;
  }
  v6 = X509V3_parse_list(a3);
  v7 = v6;
  if (!v6)
  {
    v50 = 34;
    v51 = 436;
LABEL_74:
    ERR_put_error(34, 4095, v50, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_cpols.c", v51);
    goto LABEL_100;
  }
  if (sk_num(v6) < 1)
  {
LABEL_71:
    sk_pop_free(v7, (void (__cdecl *)(void *))X509V3_conf_free);
    return v5;
  }
  v8 = 0;
  v9 = 0;
  while (1)
  {
    v10 = sk_value(v7, v9);
    v11 = (const char **)v10;
    if (*((_QWORD *)v10 + 2) || (v12 = *((_QWORD *)v10 + 1)) == 0)
    {
      v52 = 134;
      v53 = 443;
LABEL_76:
      ERR_put_error(34, 4095, v52, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_cpols.c", v53);
      ERR_asprintf_error_data("section:%s,name:%s,value:%s", *v11, v11[1], v11[2]);
      goto LABEL_100;
    }
    if (!strcmp(*((const char **)v10 + 1), "ia5org"))
    {
      v8 = 1;
      goto LABEL_70;
    }
    if (*(_BYTE *)v12 == 64)
      break;
    v48 = OBJ_txt2obj((const char *)v12, 0);
    if (!v48)
    {
      v52 = 110;
      v53 = 465;
      goto LABEL_76;
    }
    v49 = v48;
    v15 = ASN1_item_new(&POLICYINFO_it);
    *(_QWORD *)v15 = v49;
LABEL_69:
    if (!sk_push(v5, (char *)v15))
    {
      ASN1_item_free(v15, &POLICYINFO_it);
      v50 = 65;
      v51 = 474;
      goto LABEL_74;
    }
LABEL_70:
    if (++v9 >= sk_num(v7))
      goto LABEL_71;
  }
  section = X509V3_get_section(a2, (char *)(v12 + 1));
  if (!section)
  {
    v52 = 135;
    v53 = 455;
    goto LABEL_76;
  }
  v14 = section;
  v15 = ASN1_item_new(&POLICYINFO_it);
  if (!v15)
  {
LABEL_84:
    v42 = 0;
    goto LABEL_85;
  }
  v67 = v8;
  if (sk_num(v14) < 1)
  {
LABEL_64:
    if (!*(_QWORD *)v15)
    {
      ERR_put_error(34, 4095, 139, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_cpols.c", 561);
      goto LABEL_92;
    }
    X509V3_section_free(a2, v14);
    v8 = v67;
    goto LABEL_69;
  }
  v16 = 0;
  if (v8)
    v17 = 22;
  else
    v17 = 26;
  v63 = v17;
  v64 = v15;
  ctx = a2;
  v66 = v14;
  while (1)
  {
    v18 = (const char **)sk_value(v14, v16);
    v19 = v18[1];
    if (strcmp(v19, "policyIdentifier"))
      break;
    v41 = OBJ_txt2obj(v18[2], 0);
    if (!v41)
    {
      v58 = 110;
      v59 = 503;
      goto LABEL_91;
    }
    *(_QWORD *)v15 = v41;
LABEL_63:
    if (++v16 >= sk_num(v14))
      goto LABEL_64;
  }
  if (!name_cmp(v19, "CPS"))
  {
    v42 = ASN1_item_new(&POLICYQUALINFO_it);
    if (!v42)
      goto LABEL_85;
    *(_QWORD *)v42 = OBJ_nid2obj(164);
    v43 = ASN1_IA5STRING_new();
    *((_QWORD *)v42 + 1) = v43;
    if (!v43)
      goto LABEL_85;
    v44 = v43;
    v45 = v18[2];
    v46 = strlen(v45);
    if (!ASN1_STRING_set(v44, v45, v46))
      goto LABEL_85;
    v47 = (STACK *)*((_QWORD *)v15 + 1);
    if (!v47)
    {
      v47 = sk_new_null();
      *((_QWORD *)v15 + 1) = v47;
      if (!v47)
        goto LABEL_85;
    }
    if (!sk_push(v47, (char *)v42))
      goto LABEL_85;
    goto LABEL_63;
  }
  if (name_cmp(v18[1], "userNotice"))
  {
    v58 = 138;
    v59 = 555;
LABEL_91:
    ERR_put_error(34, 4095, v58, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_cpols.c", v59);
    ERR_asprintf_error_data("section:%s,name:%s,value:%s", *v18, v18[1], v18[2]);
LABEL_92:
    v42 = 0;
    goto LABEL_99;
  }
  v20 = v18[2];
  if (*v20 != 64)
  {
    v58 = 137;
    v59 = 532;
    goto LABEL_91;
  }
  v21 = X509V3_get_section(a2, (char *)v20 + 1);
  if (!v21)
  {
    ERR_put_error(34, 4095, 135, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_cpols.c", 538);
    ERR_asprintf_error_data("section:%s,name:%s,value:%s", *v18, v18[1], v18[2]);
    goto LABEL_98;
  }
  v22 = v21;
  data = (char *)ASN1_item_new(&POLICYQUALINFO_it);
  if (!data || (*(_QWORD *)data = OBJ_nid2obj(165), (v23 = ASN1_item_new(&USERNOTICE_it)) == 0))
  {
LABEL_81:
    v56 = 65;
    v57 = 654;
LABEL_82:
    ERR_put_error(34, 4095, v56, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_cpols.c", v57);
    goto LABEL_97;
  }
  v24 = v23;
  *((_QWORD *)data + 1) = v23;
  if (sk_num(v22) < 1)
  {
LABEL_48:
    v39 = *(ASN1_VALUE **)v24;
    if (*(_QWORD *)v24 && (!*((_QWORD *)v39 + 1) || !*(_QWORD *)v39))
    {
      v56 = 142;
      v57 = 647;
      goto LABEL_82;
    }
    a2 = ctx;
    X509V3_section_free(ctx, v22);
    v15 = v64;
    v40 = (STACK *)*((_QWORD *)v64 + 1);
    if (v40 || (v40 = sk_new_null(), (*((_QWORD *)v64 + 1) = v40) != 0))
    {
      v14 = v66;
      if (!sk_push(v40, data))
        goto LABEL_84;
      goto LABEL_63;
    }
    v42 = 0;
    v14 = v66;
LABEL_85:
    ERR_put_error(34, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_cpols.c", 568);
    goto LABEL_99;
  }
  v25 = 0;
  while (1)
  {
    v26 = (const char **)sk_value(v22, v25);
    v27 = v26[1];
    if (!strcmp(v27, "explicitText"))
    {
      v36 = (ASN1_STRING *)*((_QWORD *)v24 + 1);
      if (!v36)
      {
        v36 = ASN1_UTF8STRING_new();
        *((_QWORD *)v24 + 1) = v36;
        if (!v36)
          goto LABEL_81;
      }
      goto LABEL_46;
    }
    if (!strcmp(v27, "organization"))
    {
      v37 = *(ASN1_VALUE **)v24;
      if (!*(_QWORD *)v24)
      {
        v37 = ASN1_item_new(&NOTICEREF_it);
        if (!v37)
          goto LABEL_81;
        *(_QWORD *)v24 = v37;
      }
      v36 = *(ASN1_STRING **)v37;
      *(_DWORD *)(*(_QWORD *)v37 + 4) = v63;
LABEL_46:
      v38 = strlen(v26[2]);
      if (!ASN1_STRING_set(v36, v26[2], v38))
        goto LABEL_81;
      goto LABEL_47;
    }
    if (strcmp(v27, "noticeNumbers"))
    {
      v60 = 138;
      v61 = 639;
      goto LABEL_96;
    }
    v28 = *(ASN1_VALUE **)v24;
    if (!*(_QWORD *)v24)
    {
      v29 = ASN1_item_new(&NOTICEREF_it);
      if (!v29)
        goto LABEL_81;
      v28 = v29;
      *(_QWORD *)v24 = v29;
    }
    v30 = X509V3_parse_list(v26[2]);
    if (!v30)
      break;
    v31 = v30;
    if (!sk_num(v30))
    {
      ERR_put_error(34, 4095, 141, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_cpols.c", 627);
      ERR_asprintf_error_data("section:%s,name:%s,value:%s", *v26, v26[1], v26[2]);
LABEL_80:
      sk_pop_free(v31, (void (__cdecl *)(void *))X509V3_conf_free);
      goto LABEL_97;
    }
    v32 = (STACK *)*((_QWORD *)v28 + 1);
    if (sk_num(v31) >= 1)
    {
      v33 = 0;
      while (1)
      {
        v34 = sk_value(v31, v33);
        v35 = (char *)s2i_ASN1_INTEGER(0, *((char **)v34 + 1));
        if (!v35)
        {
          v54 = 140;
          v55 = 671;
          goto LABEL_79;
        }
        if (!sk_push(v32, v35))
          break;
        if (++v33 >= sk_num(v31))
          goto LABEL_38;
      }
      v54 = 65;
      v55 = 680;
LABEL_79:
      ERR_put_error(34, 4095, v54, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_cpols.c", v55);
      sk_pop_free(v32, (void (__cdecl *)(void *))ASN1_STRING_free);
      goto LABEL_80;
    }
LABEL_38:
    sk_pop_free(v31, (void (__cdecl *)(void *))X509V3_conf_free);
LABEL_47:
    if (++v25 >= sk_num(v22))
      goto LABEL_48;
  }
  v60 = 141;
  v61 = 627;
LABEL_96:
  ERR_put_error(34, 4095, v60, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_cpols.c", v61);
  ERR_asprintf_error_data("section:%s,name:%s,value:%s", *v26, v26[1], v26[2]);
LABEL_97:
  v15 = v64;
  a2 = ctx;
  ASN1_item_free((ASN1_VALUE *)data, &POLICYQUALINFO_it);
  X509V3_section_free(ctx, v22);
LABEL_98:
  v42 = 0;
  v14 = v66;
LABEL_99:
  ASN1_item_free(v42, &POLICYQUALINFO_it);
  ASN1_item_free(v15, &POLICYINFO_it);
  X509V3_section_free(a2, v14);
LABEL_100:
  sk_pop_free(v7, (void (__cdecl *)(void *))X509V3_conf_free);
  sk_pop_free(v5, (void (__cdecl *)(void *))POLICYINFO_free);
  return 0;
}

CERTIFICATEPOLICIES *__cdecl d2i_CERTIFICATEPOLICIES(CERTIFICATEPOLICIES **a, const unsigned __int8 **in, uint64_t len)
{
  return (CERTIFICATEPOLICIES *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &CERTIFICATEPOLICIES_it);
}

int i2d_CERTIFICATEPOLICIES(CERTIFICATEPOLICIES *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &CERTIFICATEPOLICIES_it);
}

CERTIFICATEPOLICIES *CERTIFICATEPOLICIES_new(void)
{
  return (CERTIFICATEPOLICIES *)ASN1_item_new(&CERTIFICATEPOLICIES_it);
}

void CERTIFICATEPOLICIES_free(CERTIFICATEPOLICIES *a)
{
  ASN1_item_free((ASN1_VALUE *)a, &CERTIFICATEPOLICIES_it);
}

POLICYINFO *__cdecl d2i_POLICYINFO(POLICYINFO **a, const unsigned __int8 **in, uint64_t len)
{
  return (POLICYINFO *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &POLICYINFO_it);
}

int i2d_POLICYINFO(POLICYINFO *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &POLICYINFO_it);
}

POLICYINFO *POLICYINFO_new(void)
{
  return (POLICYINFO *)ASN1_item_new(&POLICYINFO_it);
}

void POLICYINFO_free(POLICYINFO *a)
{
  ASN1_item_free((ASN1_VALUE *)a, &POLICYINFO_it);
}

POLICYQUALINFO *__cdecl d2i_POLICYQUALINFO(POLICYQUALINFO **a, const unsigned __int8 **in, uint64_t len)
{
  return (POLICYQUALINFO *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &POLICYQUALINFO_it);
}

int i2d_POLICYQUALINFO(POLICYQUALINFO *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &POLICYQUALINFO_it);
}

POLICYQUALINFO *POLICYQUALINFO_new(void)
{
  return (POLICYQUALINFO *)ASN1_item_new(&POLICYQUALINFO_it);
}

void POLICYQUALINFO_free(POLICYQUALINFO *a)
{
  ASN1_item_free((ASN1_VALUE *)a, &POLICYQUALINFO_it);
}

USERNOTICE *__cdecl d2i_USERNOTICE(USERNOTICE **a, const unsigned __int8 **in, uint64_t len)
{
  return (USERNOTICE *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &USERNOTICE_it);
}

int i2d_USERNOTICE(USERNOTICE *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &USERNOTICE_it);
}

USERNOTICE *USERNOTICE_new(void)
{
  return (USERNOTICE *)ASN1_item_new(&USERNOTICE_it);
}

void USERNOTICE_free(USERNOTICE *a)
{
  ASN1_item_free((ASN1_VALUE *)a, &USERNOTICE_it);
}

NOTICEREF *__cdecl d2i_NOTICEREF(NOTICEREF **a, const unsigned __int8 **in, uint64_t len)
{
  return (NOTICEREF *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &NOTICEREF_it);
}

int i2d_NOTICEREF(NOTICEREF *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &NOTICEREF_it);
}

NOTICEREF *NOTICEREF_new(void)
{
  return (NOTICEREF *)ASN1_item_new(&NOTICEREF_it);
}

void NOTICEREF_free(NOTICEREF *a)
{
  ASN1_item_free((ASN1_VALUE *)a, &NOTICEREF_it);
}

void OpenSSL_add_all_ciphers(void)
{
  pthread_once(&OpenSSL_add_all_ciphers_add_all_ciphers_once, (void (*)(void))OpenSSL_add_all_ciphers_internal);
}

uint64_t OpenSSL_add_all_ciphers_internal()
{
  const EVP_CIPHER *v0;
  const EVP_CIPHER *v1;
  const EVP_CIPHER *v2;
  const EVP_CIPHER *v3;
  const EVP_CIPHER *v4;
  const EVP_CIPHER *v5;
  const EVP_CIPHER *v6;
  const EVP_CIPHER *v7;
  const EVP_CIPHER *v8;
  const EVP_CIPHER *v9;
  const EVP_CIPHER *v10;
  const EVP_CIPHER *v11;
  const EVP_CIPHER *v12;
  const EVP_CIPHER *v13;
  const EVP_CIPHER *v14;
  const EVP_CIPHER *v15;
  const EVP_CIPHER *v16;
  const EVP_CIPHER *v17;
  const EVP_CIPHER *v18;
  const EVP_CIPHER *v19;
  const EVP_CIPHER *v20;
  const EVP_CIPHER *v21;
  const EVP_CIPHER *v22;
  const EVP_CIPHER *v23;
  const EVP_CIPHER *v24;
  const EVP_CIPHER *v25;
  const EVP_CIPHER *v26;
  const EVP_CIPHER *v27;
  const EVP_CIPHER *v28;
  const EVP_CIPHER *v29;
  const EVP_CIPHER *v30;
  const EVP_CIPHER *v31;
  const EVP_CIPHER *v32;
  const EVP_CIPHER *v33;
  const EVP_CIPHER *v34;
  const EVP_CIPHER *v35;
  const EVP_CIPHER *v36;
  const EVP_CIPHER *v37;
  const EVP_CIPHER *v38;
  const EVP_CIPHER *v39;
  const EVP_CIPHER *v40;
  const EVP_CIPHER *v41;
  const EVP_CIPHER *v42;
  const EVP_CIPHER *v43;
  const EVP_CIPHER *v44;
  const EVP_CIPHER *v45;
  const EVP_CIPHER *v46;
  const EVP_CIPHER *v47;
  const EVP_CIPHER *v48;
  const EVP_CIPHER *v49;
  const EVP_CIPHER *v50;
  const EVP_CIPHER *v51;
  const EVP_CIPHER *v52;
  const EVP_CIPHER *v53;
  const EVP_CIPHER *v54;
  const EVP_CIPHER *v55;
  const EVP_CIPHER *v56;
  const EVP_CIPHER *v57;
  const EVP_CIPHER *v58;
  const EVP_CIPHER *v59;
  const EVP_CIPHER *v60;
  const EVP_CIPHER *v61;
  const EVP_CIPHER *v62;
  const EVP_CIPHER *v63;
  const EVP_CIPHER *v64;
  const EVP_CIPHER *v65;
  const EVP_CIPHER *v66;
  const EVP_CIPHER *v67;
  const EVP_CIPHER *v68;
  const EVP_CIPHER *v69;
  const EVP_CIPHER *v70;
  const EVP_CIPHER *v71;
  const EVP_CIPHER *v72;
  const EVP_CIPHER *v73;
  const EVP_CIPHER *v74;
  const EVP_CIPHER *v75;
  const EVP_CIPHER *v76;
  const EVP_CIPHER *v77;
  const EVP_CIPHER *v78;
  const EVP_CIPHER *v79;
  const EVP_CIPHER *v80;
  const EVP_CIPHER *v81;
  const EVP_CIPHER *v82;
  const EVP_CIPHER *v83;
  const EVP_CIPHER *v84;
  const EVP_CIPHER *v85;
  const EVP_CIPHER *v86;
  const EVP_CIPHER *v87;
  const EVP_CIPHER *v88;
  const EVP_CIPHER *v89;
  const EVP_CIPHER *v90;
  const EVP_CIPHER *v91;
  const EVP_CIPHER *v92;
  const EVP_CIPHER *v93;
  const EVP_CIPHER *v94;
  const EVP_CIPHER *v95;
  const EVP_CIPHER *v96;
  const EVP_CIPHER *v97;
  const EVP_CIPHER *v98;
  const EVP_CIPHER *v99;

  v0 = EVP_des_cfb64();
  EVP_add_cipher(v0);
  v1 = EVP_des_cfb1();
  EVP_add_cipher(v1);
  v2 = EVP_des_cfb8();
  EVP_add_cipher(v2);
  v3 = EVP_des_ede_cfb64();
  EVP_add_cipher(v3);
  v4 = EVP_des_ede3_cfb64();
  EVP_add_cipher(v4);
  v5 = EVP_des_ede3_cfb1();
  EVP_add_cipher(v5);
  v6 = EVP_des_ede3_cfb8();
  EVP_add_cipher(v6);
  v7 = EVP_des_ofb();
  EVP_add_cipher(v7);
  v8 = EVP_des_ede_ofb();
  EVP_add_cipher(v8);
  v9 = EVP_des_ede3_ofb();
  EVP_add_cipher(v9);
  v10 = EVP_desx_cbc();
  EVP_add_cipher(v10);
  OBJ_NAME_add("DESX", 32770, "DESX-CBC");
  OBJ_NAME_add("desx", 32770, "DESX-CBC");
  v11 = EVP_des_cbc();
  EVP_add_cipher(v11);
  OBJ_NAME_add("DES", 32770, "DES-CBC");
  OBJ_NAME_add("des", 32770, "DES-CBC");
  v12 = EVP_des_ede_cbc();
  EVP_add_cipher(v12);
  v13 = EVP_des_ede3_cbc();
  EVP_add_cipher(v13);
  OBJ_NAME_add("DES3", 32770, "DES-EDE3-CBC");
  OBJ_NAME_add("des3", 32770, "DES-EDE3-CBC");
  v14 = EVP_des_ecb();
  EVP_add_cipher(v14);
  v15 = EVP_des_ede();
  EVP_add_cipher(v15);
  v16 = EVP_des_ede3();
  EVP_add_cipher(v16);
  v17 = EVP_rc4();
  EVP_add_cipher(v17);
  v18 = EVP_rc4_40();
  EVP_add_cipher(v18);
  v19 = (const EVP_CIPHER *)EVP_rc4_hmac_md5();
  EVP_add_cipher(v19);
  v20 = (const EVP_CIPHER *)EVP_idea_ecb();
  EVP_add_cipher(v20);
  v21 = (const EVP_CIPHER *)EVP_idea_cfb64();
  EVP_add_cipher(v21);
  v22 = (const EVP_CIPHER *)EVP_idea_ofb();
  EVP_add_cipher(v22);
  v23 = (const EVP_CIPHER *)EVP_idea_cbc();
  EVP_add_cipher(v23);
  OBJ_NAME_add("IDEA", 32770, "IDEA-CBC");
  OBJ_NAME_add("idea", 32770, "IDEA-CBC");
  v24 = EVP_rc2_ecb();
  EVP_add_cipher(v24);
  v25 = EVP_rc2_cfb64();
  EVP_add_cipher(v25);
  v26 = EVP_rc2_ofb();
  EVP_add_cipher(v26);
  v27 = EVP_rc2_cbc();
  EVP_add_cipher(v27);
  v28 = EVP_rc2_40_cbc();
  EVP_add_cipher(v28);
  v29 = EVP_rc2_64_cbc();
  EVP_add_cipher(v29);
  OBJ_NAME_add("RC2", 32770, "RC2-CBC");
  OBJ_NAME_add("rc2", 32770, "RC2-CBC");
  v30 = EVP_bf_ecb();
  EVP_add_cipher(v30);
  v31 = EVP_bf_cfb64();
  EVP_add_cipher(v31);
  v32 = EVP_bf_ofb();
  EVP_add_cipher(v32);
  v33 = EVP_bf_cbc();
  EVP_add_cipher(v33);
  OBJ_NAME_add("BF", 32770, "BF-CBC");
  OBJ_NAME_add("bf", 32770, "BF-CBC");
  OBJ_NAME_add("blowfish", 32770, "BF-CBC");
  v34 = EVP_cast5_ecb();
  EVP_add_cipher(v34);
  v35 = EVP_cast5_cfb64();
  EVP_add_cipher(v35);
  v36 = EVP_cast5_ofb();
  EVP_add_cipher(v36);
  v37 = EVP_cast5_cbc();
  EVP_add_cipher(v37);
  OBJ_NAME_add("CAST", 32770, "CAST5-CBC");
  OBJ_NAME_add("cast", 32770, "CAST5-CBC");
  OBJ_NAME_add("CAST-cbc", 32770, "CAST5-CBC");
  OBJ_NAME_add("cast-cbc", 32770, "CAST5-CBC");
  v38 = EVP_aes_128_ecb();
  EVP_add_cipher(v38);
  v39 = EVP_aes_128_cbc();
  EVP_add_cipher(v39);
  v40 = (const EVP_CIPHER *)EVP_aes_128_ccm();
  EVP_add_cipher(v40);
  v41 = EVP_aes_128_cfb128();
  EVP_add_cipher(v41);
  v42 = EVP_aes_128_cfb1();
  EVP_add_cipher(v42);
  v43 = EVP_aes_128_cfb8();
  EVP_add_cipher(v43);
  v44 = EVP_aes_128_ofb();
  EVP_add_cipher(v44);
  v45 = (const EVP_CIPHER *)EVP_aes_128_ctr();
  EVP_add_cipher(v45);
  v46 = (const EVP_CIPHER *)EVP_aes_128_gcm();
  EVP_add_cipher(v46);
  v47 = (const EVP_CIPHER *)EVP_aes_128_wrap();
  EVP_add_cipher(v47);
  v48 = (const EVP_CIPHER *)EVP_aes_128_xts();
  EVP_add_cipher(v48);
  OBJ_NAME_add("AES128", 32770, "AES-128-CBC");
  OBJ_NAME_add("aes128", 32770, "AES-128-CBC");
  v49 = EVP_aes_192_ecb();
  EVP_add_cipher(v49);
  v50 = EVP_aes_192_cbc();
  EVP_add_cipher(v50);
  v51 = (const EVP_CIPHER *)EVP_aes_192_ccm();
  EVP_add_cipher(v51);
  v52 = EVP_aes_192_cfb128();
  EVP_add_cipher(v52);
  v53 = EVP_aes_192_cfb1();
  EVP_add_cipher(v53);
  v54 = EVP_aes_192_cfb8();
  EVP_add_cipher(v54);
  v55 = EVP_aes_192_ofb();
  EVP_add_cipher(v55);
  v56 = (const EVP_CIPHER *)EVP_aes_192_ctr();
  EVP_add_cipher(v56);
  v57 = (const EVP_CIPHER *)EVP_aes_192_gcm();
  EVP_add_cipher(v57);
  v58 = (const EVP_CIPHER *)EVP_aes_192_wrap();
  EVP_add_cipher(v58);
  OBJ_NAME_add("AES192", 32770, "AES-192-CBC");
  OBJ_NAME_add("aes192", 32770, "AES-192-CBC");
  v59 = EVP_aes_256_ecb();
  EVP_add_cipher(v59);
  v60 = EVP_aes_256_cbc();
  EVP_add_cipher(v60);
  v61 = (const EVP_CIPHER *)EVP_aes_256_ccm();
  EVP_add_cipher(v61);
  v62 = EVP_aes_256_cfb128();
  EVP_add_cipher(v62);
  v63 = EVP_aes_256_cfb1();
  EVP_add_cipher(v63);
  v64 = EVP_aes_256_cfb8();
  EVP_add_cipher(v64);
  v65 = EVP_aes_256_ofb();
  EVP_add_cipher(v65);
  v66 = (const EVP_CIPHER *)EVP_aes_256_ctr();
  EVP_add_cipher(v66);
  v67 = (const EVP_CIPHER *)EVP_aes_256_gcm();
  EVP_add_cipher(v67);
  v68 = (const EVP_CIPHER *)EVP_aes_256_wrap();
  EVP_add_cipher(v68);
  v69 = (const EVP_CIPHER *)EVP_aes_256_xts();
  EVP_add_cipher(v69);
  OBJ_NAME_add("AES256", 32770, "AES-256-CBC");
  OBJ_NAME_add("aes256", 32770, "AES-256-CBC");
  v70 = (const EVP_CIPHER *)EVP_aes_128_cbc_hmac_sha1();
  EVP_add_cipher(v70);
  v71 = (const EVP_CIPHER *)EVP_aes_256_cbc_hmac_sha1();
  EVP_add_cipher(v71);
  v72 = (const EVP_CIPHER *)EVP_camellia_128_ecb();
  EVP_add_cipher(v72);
  v73 = (const EVP_CIPHER *)EVP_camellia_128_cbc();
  EVP_add_cipher(v73);
  v74 = (const EVP_CIPHER *)EVP_camellia_128_cfb128();
  EVP_add_cipher(v74);
  v75 = (const EVP_CIPHER *)EVP_camellia_128_cfb1();
  EVP_add_cipher(v75);
  v76 = (const EVP_CIPHER *)EVP_camellia_128_cfb8();
  EVP_add_cipher(v76);
  v77 = (const EVP_CIPHER *)EVP_camellia_128_ofb();
  EVP_add_cipher(v77);
  OBJ_NAME_add("CAMELLIA128", 32770, "CAMELLIA-128-CBC");
  OBJ_NAME_add("camellia128", 32770, "CAMELLIA-128-CBC");
  v78 = (const EVP_CIPHER *)EVP_camellia_192_ecb();
  EVP_add_cipher(v78);
  v79 = (const EVP_CIPHER *)EVP_camellia_192_cbc();
  EVP_add_cipher(v79);
  v80 = (const EVP_CIPHER *)EVP_camellia_192_cfb128();
  EVP_add_cipher(v80);
  v81 = (const EVP_CIPHER *)EVP_camellia_192_cfb1();
  EVP_add_cipher(v81);
  v82 = (const EVP_CIPHER *)EVP_camellia_192_cfb8();
  EVP_add_cipher(v82);
  v83 = (const EVP_CIPHER *)EVP_camellia_192_ofb();
  EVP_add_cipher(v83);
  OBJ_NAME_add("CAMELLIA192", 32770, "CAMELLIA-192-CBC");
  OBJ_NAME_add("camellia192", 32770, "CAMELLIA-192-CBC");
  v84 = (const EVP_CIPHER *)EVP_camellia_256_ecb();
  EVP_add_cipher(v84);
  v85 = (const EVP_CIPHER *)EVP_camellia_256_cbc();
  EVP_add_cipher(v85);
  v86 = (const EVP_CIPHER *)EVP_camellia_256_cfb128();
  EVP_add_cipher(v86);
  v87 = (const EVP_CIPHER *)EVP_camellia_256_cfb1();
  EVP_add_cipher(v87);
  v88 = (const EVP_CIPHER *)EVP_camellia_256_cfb8();
  EVP_add_cipher(v88);
  v89 = (const EVP_CIPHER *)EVP_camellia_256_ofb();
  EVP_add_cipher(v89);
  OBJ_NAME_add("CAMELLIA256", 32770, "CAMELLIA-256-CBC");
  OBJ_NAME_add("camellia256", 32770, "CAMELLIA-256-CBC");
  v90 = (const EVP_CIPHER *)EVP_chacha20();
  EVP_add_cipher(v90);
  v91 = (const EVP_CIPHER *)EVP_chacha20_poly1305();
  EVP_add_cipher(v91);
  v92 = (const EVP_CIPHER *)EVP_gost2814789_ecb();
  EVP_add_cipher(v92);
  v93 = (const EVP_CIPHER *)EVP_gost2814789_cfb64();
  EVP_add_cipher(v93);
  v94 = (const EVP_CIPHER *)EVP_gost2814789_cnt();
  EVP_add_cipher(v94);
  v95 = (const EVP_CIPHER *)EVP_sm4_ecb();
  EVP_add_cipher(v95);
  v96 = (const EVP_CIPHER *)EVP_sm4_cbc();
  EVP_add_cipher(v96);
  v97 = (const EVP_CIPHER *)EVP_sm4_cfb128();
  EVP_add_cipher(v97);
  v98 = (const EVP_CIPHER *)EVP_sm4_ofb();
  EVP_add_cipher(v98);
  v99 = (const EVP_CIPHER *)EVP_sm4_ctr();
  EVP_add_cipher(v99);
  OBJ_NAME_add("SM4", 32770, "SM4-CBC");
  return OBJ_NAME_add("sm4", 32770, "SM4-CBC");
}

void OpenSSL_add_all_digests(void)
{
  pthread_once(&OpenSSL_add_all_digests_add_all_digests_once, (void (*)(void))OpenSSL_add_all_digests_internal);
}

uint64_t OpenSSL_add_all_digests_internal()
{
  const EVP_MD *v0;
  const EVP_MD *v1;
  const EVP_MD *v2;
  const EVP_MD *v3;
  const EVP_MD *v4;
  const EVP_MD *v5;
  const EVP_MD *v6;
  const EVP_MD *v7;
  const EVP_MD *v8;
  const EVP_MD *v9;
  const EVP_MD *v10;
  const EVP_MD *v11;
  const EVP_MD *v12;
  const EVP_MD *v13;
  const EVP_MD *v14;
  const EVP_MD *v15;
  const EVP_MD *v16;
  const EVP_MD *v17;
  const EVP_MD *v18;
  const EVP_MD *v19;
  const EVP_MD *v20;

  v0 = EVP_md4();
  EVP_add_digest(v0);
  v1 = EVP_md5();
  EVP_add_digest(v1);
  v2 = (const EVP_MD *)EVP_md5_sha1();
  EVP_add_digest(v2);
  OBJ_NAME_add("ssl2-md5", 32769, "MD5");
  OBJ_NAME_add("ssl3-md5", 32769, "MD5");
  v3 = EVP_sha1();
  EVP_add_digest(v3);
  OBJ_NAME_add("ssl3-sha1", 32769, "SHA1");
  OBJ_NAME_add("RSA-SHA1-2", 32769, "RSA-SHA1");
  v4 = (const EVP_MD *)EVP_gostr341194();
  EVP_add_digest(v4);
  v5 = (const EVP_MD *)EVP_gost2814789imit();
  EVP_add_digest(v5);
  v6 = (const EVP_MD *)EVP_streebog256();
  EVP_add_digest(v6);
  v7 = (const EVP_MD *)EVP_streebog512();
  EVP_add_digest(v7);
  v8 = EVP_ripemd160();
  EVP_add_digest(v8);
  OBJ_NAME_add("ripemd", 32769, "RIPEMD160");
  OBJ_NAME_add("rmd160", 32769, "RIPEMD160");
  v9 = EVP_sha224();
  EVP_add_digest(v9);
  v10 = EVP_sha256();
  EVP_add_digest(v10);
  v11 = EVP_sha384();
  EVP_add_digest(v11);
  v12 = EVP_sha512();
  EVP_add_digest(v12);
  v13 = EVP_sha512_224();
  EVP_add_digest(v13);
  v14 = EVP_sha512_256();
  EVP_add_digest(v14);
  v15 = (const EVP_MD *)EVP_sha3_224();
  EVP_add_digest(v15);
  v16 = (const EVP_MD *)EVP_sha3_256();
  EVP_add_digest(v16);
  v17 = (const EVP_MD *)EVP_sha3_384();
  EVP_add_digest(v17);
  v18 = (const EVP_MD *)EVP_sha3_512();
  EVP_add_digest(v18);
  v19 = (const EVP_MD *)EVP_sm3();
  EVP_add_digest(v19);
  v20 = (const EVP_MD *)EVP_whirlpool();
  return EVP_add_digest(v20);
}

void OPENSSL_add_all_algorithms_noconf(void)
{
  OPENSSL_cpuid_setup();
  pthread_once(&OpenSSL_add_all_ciphers_add_all_ciphers_once, (void (*)(void))OpenSSL_add_all_ciphers_internal);
  pthread_once(&OpenSSL_add_all_digests_add_all_digests_once, (void (*)(void))OpenSSL_add_all_digests_internal);
}

void OPENSSL_add_all_algorithms_conf(void)
{
  OPENSSL_add_all_algorithms_noconf();
  OPENSSL_config(0);
}

int BN_kronecker(const BIGNUM *a, const BIGNUM *b, BN_CTX *ctx)
{
  BIGNUM *v6;
  BIGNUM *v7;
  BIGNUM *v8;
  BIGNUM *v9;
  int is_word;
  int v11;
  int v12;
  uint64_t v13;
  BIGNUM *v14;
  int v15;
  unint64_t v16;
  _BOOL4 is_negative;
  int top;
  unint64_t v19;
  unint64_t v20;
  unint64_t v21;

  BN_CTX_start(ctx);
  v6 = BN_CTX_get(ctx);
  if (!v6)
    goto LABEL_51;
  v7 = v6;
  v8 = BN_CTX_get(ctx);
  if (!v8)
    goto LABEL_51;
  v9 = v8;
  if (!bn_copy(v7, a) || !bn_copy(v9, b))
    goto LABEL_51;
  if (BN_is_zero((uint64_t)v9))
  {
    is_word = BN_abs_is_word((uint64_t)v7, 1);
    goto LABEL_52;
  }
  if (!BN_is_odd((uint64_t)v7) && !BN_is_odd((uint64_t)v9))
  {
    is_word = 0;
    goto LABEL_52;
  }
  v11 = -1;
  do
    ++v11;
  while (!BN_is_bit_set(v9, v11));
  if (!BN_rshift(v9, v9, v11))
  {
LABEL_51:
    is_word = -2;
    goto LABEL_52;
  }
  if ((v11 & 1) != 0)
  {
    if (v7->top)
      v13 = *v7->d & 7;
    else
      v13 = 0;
    v12 = BN_kronecker_tab[v13];
  }
  else
  {
    v12 = 1;
  }
  if (BN_is_negative((uint64_t)v9))
  {
    BN_set_negative(v9, 0);
    if (BN_is_negative((uint64_t)v7))
      v12 = -v12;
  }
  if (!BN_is_zero((uint64_t)v7))
  {
    while (1)
    {
      v14 = v7;
      v7 = v9;
      v15 = -1;
      do
        ++v15;
      while (!BN_is_bit_set(v14, v15));
      if (!BN_rshift(v14, v14, v15))
        goto LABEL_51;
      if ((v15 & 1) != 0)
      {
        if (v7->top)
          v16 = *v7->d;
        else
          LOBYTE(v16) = 0;
        v12 *= BN_kronecker_tab[v16 & 7];
      }
      is_negative = BN_is_negative((uint64_t)v14);
      top = v14->top;
      if (is_negative)
      {
        if (top)
          v19 = *v14->d;
        else
          LOBYTE(v19) = 0;
        LOBYTE(v20) = ~(_BYTE)v19;
      }
      else if (top)
      {
        v20 = *v14->d;
      }
      else
      {
        LOBYTE(v20) = 0;
      }
      if (v7->top)
        v21 = *v7->d;
      else
        LOBYTE(v21) = 0;
      if (!BN_nnmod(v7, v7, v14, ctx))
        goto LABEL_51;
      if ((v20 & v21 & 2) != 0)
        v12 = -v12;
      BN_set_negative(v14, 0);
      v9 = v14;
      if (BN_is_zero((uint64_t)v7))
        goto LABEL_24;
    }
  }
  v14 = v9;
LABEL_24:
  if (BN_is_one((uint64_t)v14))
    is_word = v12;
  else
    is_word = 0;
LABEL_52:
  BN_CTX_end(ctx);
  return is_word;
}

unint64_t idea_set_encrypt_key(unint64_t result, int *a2)
{
  int v2;
  int v3;
  unsigned int v4;
  int v5;
  unsigned int v6;
  int v7;
  unsigned int v8;
  int v9;
  unsigned int v10;
  int v11;
  unsigned int v12;
  int v13;
  unsigned int v14;
  int v15;
  unsigned int v16;
  uint64_t i;
  unsigned int *v18;
  unsigned int v19;

  v2 = *(unsigned __int8 *)result;
  *a2 = v2 << 8;
  *a2 = *(unsigned __int8 *)(result + 1) | (v2 << 8);
  v3 = *(unsigned __int8 *)(result + 2);
  a2[1] = v3 << 8;
  v4 = *(unsigned __int8 *)(result + 3) | (v3 << 8);
  a2[1] = v4;
  v5 = *(unsigned __int8 *)(result + 4);
  a2[2] = v5 << 8;
  v6 = *(unsigned __int8 *)(result + 5) | (v5 << 8);
  a2[2] = v6;
  v7 = *(unsigned __int8 *)(result + 6);
  a2[3] = v7 << 8;
  v8 = *(unsigned __int8 *)(result + 7) | (v7 << 8);
  a2[3] = v8;
  v9 = *(unsigned __int8 *)(result + 8);
  a2[4] = v9 << 8;
  v10 = *(unsigned __int8 *)(result + 9) | (v9 << 8);
  a2[4] = v10;
  v11 = *(unsigned __int8 *)(result + 10);
  a2[5] = v11 << 8;
  v12 = *(unsigned __int8 *)(result + 11) | (v11 << 8);
  a2[5] = v12;
  v13 = *(unsigned __int8 *)(result + 12);
  a2[6] = v13 << 8;
  v14 = *(unsigned __int8 *)(result + 13) | (v13 << 8);
  a2[6] = v14;
  v15 = *(unsigned __int8 *)(result + 14);
  a2[7] = v15 << 8;
  v16 = *(unsigned __int8 *)(result + 15) | (v15 << 8);
  a2[7] = v16;
  for (i = 15; ; i += 8)
  {
    v18 = (unsigned int *)&a2[i];
    v19 = (unsigned __int16)((v8 >> 7) | ((_WORD)v6 << 9));
    *(v18 - 7) = (unsigned __int16)((v6 >> 7) | ((_WORD)v4 << 9));
    *(v18 - 6) = v19;
    v6 = (unsigned __int16)((v10 >> 7) | ((_WORD)v8 << 9));
    v8 = (unsigned __int16)((v12 >> 7) | ((_WORD)v10 << 9));
    *(v18 - 5) = v6;
    *(v18 - 4) = v8;
    v10 = (unsigned __int16)((v14 >> 7) | ((_WORD)v12 << 9));
    v12 = (unsigned __int16)((v16 >> 7) | ((_WORD)v14 << 9));
    *(v18 - 3) = v10;
    *(v18 - 2) = v12;
    if ((_DWORD)(i * 4) == 220)
      break;
    result = *(v18 - 15);
    v14 = (unsigned __int16)((result >> 7) | ((_WORD)v16 << 9));
    v16 = (unsigned __int16)(((_WORD)result << 9) | (v4 >> 7));
    *(v18 - 1) = v14;
    *v18 = v16;
    v4 = v19;
  }
  return result;
}

int32x2_t idea_set_decrypt_key(uint64_t a1, uint64_t a2)
{
  int v2;
  unsigned int *v3;
  _DWORD *i;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  int32x2_t result;

  v2 = 0;
  v3 = (unsigned int *)(a1 + 192);
  for (i = (_DWORD *)a2; ; i += 6)
  {
    v5 = *v3;
    if ((_DWORD)v5)
    {
      v6 = 0x10001 % v5;
      if ((_DWORD)v6)
      {
        v7 = 0;
        v8 = 1;
        v9 = 65537;
        do
        {
          v10 = v5;
          v11 = v8;
          v5 = v6;
          v8 = v7 - (uint64_t)(v9 - v6) / v10 * v8;
          v6 = v10 % v6;
          v7 = v11;
          v9 = v10;
        }
        while (v6);
        LODWORD(v5) = v8 + 65537;
        if (v8 >= 0)
          LODWORD(v5) = v8;
      }
      else
      {
        LODWORD(v5) = 1;
      }
    }
    *i = v5;
    i[1] = (unsigned __int16)-*((_WORD *)v3 + 4);
    i[2] = (unsigned __int16)-*((_WORD *)v3 + 2);
    v12 = v3[3];
    if ((_DWORD)v12)
    {
      v13 = 0x10001 % v12;
      if ((_DWORD)v13)
      {
        v14 = 0;
        v15 = 1;
        v16 = 65537;
        do
        {
          v17 = v12;
          v18 = v15;
          v12 = v13;
          v15 = v14 - (uint64_t)(v16 - v13) / v17 * v15;
          v13 = v17 % v13;
          v14 = v18;
          v16 = v17;
        }
        while (v13);
        LODWORD(v12) = v15 + 65537;
        if (v15 >= 0)
          LODWORD(v12) = v15;
      }
      else
      {
        LODWORD(v12) = 1;
      }
    }
    i[3] = v12;
    if (v2 == 8)
      break;
    i[4] = *(v3 - 2);
    v19 = *(v3 - 1);
    v3 -= 6;
    i[5] = v19;
    ++v2;
  }
  *(int32x2_t *)(a2 + 4) = vrev64_s32(*(int32x2_t *)(a2 + 4));
  result = vrev64_s32(*(int32x2_t *)(a2 + 196));
  *(int32x2_t *)(a2 + 196) = result;
  return result;
}

CONF_METHOD *NCONF_default(void)
{
  return (CONF_METHOD *)&default_method;
}

CONF_METHOD *NCONF_WIN32(void)
{
  return (CONF_METHOD *)&WIN32_method;
}

void *def_create(uint64_t a1)
{
  void *v2;
  void *v3;

  v2 = malloc_type_malloc(0x20uLL, 0x7279D4DDuLL);
  v3 = v2;
  if (v2 && !(*(unsigned int (**)(void *))(a1 + 16))(v2))
  {
    free(v3);
    return 0;
  }
  return v3;
}

uint64_t def_init_default(uint64_t result)
{
  if (result)
  {
    *(_QWORD *)result = &default_method;
    *(_QWORD *)(result + 8) = &CONF_type_default;
    *(_QWORD *)(result + 16) = 0;
    return 1;
  }
  return result;
}

CONF *def_destroy(CONF *result)
{
  void *v1;

  if (result)
  {
    v1 = result;
    _CONF_free_data(result);
    free(v1);
    return (CONF *)1;
  }
  return result;
}

CONF *def_destroy_data(CONF *result)
{
  if (result)
  {
    _CONF_free_data(result);
    return (CONF *)1;
  }
  return result;
}

uint64_t def_load_bio(CONF *a1, BIO *a2, char **a3)
{
  LHASH *data;
  BUF_MEM *v7;
  BUF_MEM *v8;
  char *v9;
  char v10;
  uint64_t v11;
  char *v12;
  int v13;
  int v14;
  uint64_t v15;
  int v16;
  BOOL v17;
  BOOL v18;
  int v19;
  int v20;
  char *v21;
  _WORD *meth_data;
  char *v23;
  _WORD *v24;
  int v25;
  __int16 v26;
  char *v27;
  unsigned __int8 *i;
  int v29;
  int v30;
  unsigned __int8 *v31;
  __int16 v32;
  _BOOL4 v33;
  unsigned __int8 *v35;
  int v36;
  int v37;
  BOOL v38;
  int v39;
  const char *v40;
  int v41;
  int v42;
  __int16 v43;
  const char *v44;
  unsigned __int8 *v45;
  int v46;
  const char *v47;
  int v48;
  char *v49;
  unsigned __int8 *v50;
  const char *v51;
  int v52;
  int v53;
  _WORD *v54;
  uint64_t v55;
  const char *v56;
  int v57;
  uint64_t v58;
  uint64_t v59;
  int v60;
  const char *v61;
  CONF_VALUE *v62;
  char *v63;
  char *v64;
  int v65;
  CONF_VALUE *v66;
  uint64_t v67;
  unsigned int v68;
  const char *v69;
  const char *j;
  __int16 v71;
  int v72;
  const char *v73;
  unsigned int v74;
  char *v75;
  int v76;
  int v77;
  char *v78;
  int v79;
  int v80;
  LHASH *v81;
  int v83;
  int v84;
  char **v85;
  CONF_VALUE *v86;
  char *section;

  data = a1->data;
  v7 = BUF_MEM_new();
  if (!v7)
  {
    ERR_put_error(14, 4095, 7, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/conf/conf_def.c", 229);
    v78 = 0;
    v62 = 0;
    v9 = 0;
    goto LABEL_148;
  }
  v8 = v7;
  v9 = strdup("default");
  section = v9;
  if (!v9)
  {
    ERR_put_error(14, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/conf/conf_def.c", 235);
    v62 = 0;
    goto LABEL_147;
  }
  if (!_CONF_new_data(a1))
  {
    v79 = 65;
    v80 = 240;
LABEL_146:
    ERR_put_error(14, 4095, v79, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/conf/conf_def.c", v80);
    v62 = 0;
    v9 = 0;
    goto LABEL_147;
  }
  v86 = _CONF_new_section(a1, v9);
  if (!v86)
  {
    v79 = 103;
    v80 = 246;
    goto LABEL_146;
  }
  v9 = 0;
  if (!BUF_MEM_grow(v8, 512))
    goto LABEL_139;
  v85 = a3;
  while (2)
  {
    v10 = 0;
    LODWORD(v11) = 0;
LABEL_8:
    v12 = &v8->data[(int)v11];
    *v12 = 0;
    BIO_gets(a2, v12, 511);
    v12[511] = 0;
    v13 = strlen(v12);
    if ((v10 & 1) == 0 && !v13)
    {
      BUF_MEM_free(v8);
      free(section);
      return 1;
    }
    v14 = v13;
    if (v13 >= 1)
    {
      v15 = v13 + 1;
      v14 = v13;
      while (1)
      {
        v16 = v12[(v15 - 2)];
        v17 = v16 == 13 || v16 == 10;
        if (!v17)
          break;
        --v14;
        if ((unint64_t)--v15 <= 1)
        {
          v14 = 0;
          break;
        }
      }
    }
    if (v13)
      v18 = v14 == v13;
    else
      v18 = 0;
    v19 = v18;
    if (!v18)
    {
      v12[v14] = 0;
      ++v9;
    }
    v20 = v14 + v11;
    v11 = (v20 - 1);
    if (v20 >= 1 && (v21 = &v8->data[v11], meth_data = a1->meth_data, (meth_data[*v21] & 0x20) != 0))
    {
      if (v20 < 2
        || ((meth_data[*(v21 - 1)] & 0x20) != 0 ? (LODWORD(v11) = v20) : (LOBYTE(v19) = 1),
            (v19 & 1) != 0))
      {
        v10 = 1;
        goto LABEL_117;
      }
    }
    else if (v19)
    {
      v10 = 1;
      LODWORD(v11) = v20;
      goto LABEL_117;
    }
    v23 = v8->data;
    v24 = a1->meth_data;
    v25 = *v23;
    v26 = v24[*v23];
    v27 = v23;
    if ((v26 & 0x800) == 0)
    {
      v27 = v8->data;
      if ((v26 & 0x10) != 0)
      {
        v27 = v23 + 1;
        while (1)
        {
          v25 = *v27;
          v26 = v24[*v27];
          if ((v26 & 0x800) != 0)
            break;
          ++v27;
          if ((v26 & 0x10) == 0)
          {
            --v27;
            goto LABEL_43;
          }
        }
      }
      else
      {
LABEL_43:
        while ((v26 & 0x80) == 0)
        {
          if ((v26 & 0x400) != 0)
          {
            for (i = (unsigned __int8 *)v27; ; v27 = (char *)i)
            {
              v30 = *++i;
              v29 = v30;
              if ((v24[v30] & 8) != 0)
                break;
              if (v29 == v25)
              {
                if (v27[2] != v25)
                {
                  v29 = v25;
                  break;
                }
                i = (unsigned __int8 *)(v27 + 2);
              }
            }
            v27 += 2;
            if (v29 != v25)
              v27 = (char *)i;
          }
          else if ((v26 & 0x40) != 0)
          {
            v31 = (unsigned __int8 *)(v27 + 1);
            v32 = v24[v27[1]];
            v33 = v27[1] == v25;
            if (v27[1] != v25 && (v32 & 8) == 0)
            {
              while (1)
              {
                v35 = v31;
                if ((v32 & 0x20) != 0)
                {
                  v36 = v27[2];
                  v27 += 2;
                  v35 = (unsigned __int8 *)v27;
                  if ((v24[v36] & 8) != 0)
                    break;
                }
                v31 = v35 + 1;
                v37 = v35[1];
                v32 = v24[v35[1]];
                v33 = v37 == v25;
                v38 = v37 != v25 && (v32 & 8) == 0;
                v27 = (char *)v35;
                if (!v38)
                {
                  v27 = (char *)v35;
                  goto LABEL_67;
                }
              }
            }
            else
            {
LABEL_67:
              v27 += 2;
              if (!v33)
                v27 = (char *)v31;
            }
          }
          else if ((v26 & 0x20) != 0)
          {
            v39 = *++v27;
            if ((v24[v39] & 8) == 0)
              ++v27;
          }
          else
          {
            if ((v26 & 8) != 0)
              goto LABEL_78;
            ++v27;
          }
          v25 = *v27;
          v26 = v24[*v27];
        }
      }
    }
    *v27 = 0;
    v24 = a1->meth_data;
    do
    {
LABEL_78:
      v40 = v23;
      v42 = *v23++;
      v41 = v42;
      v43 = v24[v42];
    }
    while ((v43 & 0x18) == 0x10);
    if ((v43 & 8) != 0)
      goto LABEL_116;
    v44 = v23 - 1;
    v45 = (unsigned __int8 *)(v23 - 1);
    if (v41 != 91)
    {
      while (1)
      {
        if ((v43 & 0x20) != 0)
        {
          v46 = *++v45;
          if ((v24[v46] & 8) == 0)
            ++v45;
        }
        else
        {
          if ((v43 & 0x307) == 0)
          {
            if (v41 == 58 && v45[1] == 58)
            {
              *v45 = 0;
              v45 += 2;
              v47 = (const char *)v45;
              v24 = a1->meth_data;
              while (1)
              {
                while ((v24[*v45] & 0x20) != 0)
                {
                  v48 = *++v45;
                  if ((v24[v48] & 8) == 0)
                    ++v45;
                }
                if ((v24[*v45] & 0x307) == 0)
                  break;
                ++v45;
              }
              v49 = (char *)v44;
              v44 = v47;
            }
            else
            {
              v49 = 0;
            }
            v50 = v45;
            do
            {
              v51 = (const char *)v50;
              v53 = *v50++;
              v52 = v53;
            }
            while ((v24[v53] & 0x18) == 0x10);
            if (v52 != 61)
            {
              v76 = 101;
              v77 = 346;
              goto LABEL_140;
            }
            *v45 = 0;
            v54 = a1->meth_data;
            v55 = 1;
            v56 = v51;
            do
            {
              v57 = *(unsigned __int8 *)++v56;
              v58 = v55++;
            }
            while ((v54[v57] & 0x18) == 0x10);
            do
            {
              v59 = v58;
              v60 = *(unsigned __int8 *)++v51;
              --v58;
            }
            while ((v54[v60] & 8) == 0);
            do
            {
              v61 = v51;
              if (!v59)
                break;
              --v51;
              ++v59;
            }
            while ((v54[*((unsigned __int8 *)v61 - 1)] & 0x10) != 0);
            *v61 = 0;
            v62 = (CONF_VALUE *)malloc_type_malloc(0x18uLL, 0x100402FEFCB83uLL);
            if (!v62)
            {
              v83 = 65;
              v84 = 361;
LABEL_160:
              ERR_put_error(14, 4095, v83, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/conf/conf_def.c", v84);
LABEL_161:
              a3 = v85;
              goto LABEL_147;
            }
            v63 = section;
            if (!v49)
              v49 = section;
            v64 = strdup(v44);
            v62->value = 0;
            v62->name = v64;
            if (!v64)
            {
              v83 = 65;
              v84 = 369;
              goto LABEL_160;
            }
            if (!str_copy(a1, v49, (void **)&v62->value, v56))
              goto LABEL_161;
            v65 = strcmp(v49, v63);
            v66 = v86;
            if (v65)
            {
              v66 = _CONF_get_section(a1, v49);
              if (!v66)
              {
                v66 = _CONF_new_section(a1, v49);
                if (!v66)
                {
                  v83 = 103;
                  v84 = 380;
                  goto LABEL_160;
                }
              }
            }
            a3 = v85;
            if (!_CONF_add_string(a1, v66, v62))
            {
              ERR_put_error(14, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/conf/conf_def.c", 387);
              goto LABEL_147;
            }
LABEL_116:
            v10 = 0;
            LODWORD(v11) = 0;
LABEL_117:
            if (!BUF_MEM_grow(v8, v11 + 512))
            {
LABEL_139:
              v76 = 7;
              v77 = 254;
              goto LABEL_140;
            }
            goto LABEL_8;
          }
          ++v45;
        }
        v41 = *v45;
        v43 = v24[*v45];
      }
    }
    do
    {
      v68 = *(unsigned __int8 *)++v40;
      v67 = v68;
    }
    while ((v24[v68] & 0x18) == 0x10);
    v69 = v40;
LABEL_121:
    for (j = v69; ; v67 = *(unsigned __int8 *)j)
    {
      v71 = v24[v67];
      if ((v71 & 0x20) == 0)
        break;
      v72 = *(unsigned __int8 *)++j;
      if ((v24[v72] & 8) == 0)
        ++j;
LABEL_127:
      ;
    }
    if ((v71 & 0x307) != 0)
    {
      ++j;
      goto LABEL_127;
    }
    v73 = j - 1;
    do
    {
      v74 = *(unsigned __int8 *)++v73;
      v67 = v74;
    }
    while ((v24[v74] & 0x18) == 0x10);
    if (!v67)
      goto LABEL_163;
    if (v67 == 93)
    {
      *j = 0;
      if (!str_copy(a1, 0, (void **)&section, v40))
        goto LABEL_141;
      v75 = section;
      v86 = _CONF_get_section(a1, section);
      if (!v86)
      {
        v86 = _CONF_new_section(a1, v75);
        if (!v86)
        {
          v76 = 103;
          v77 = 329;
          goto LABEL_140;
        }
      }
      if (!BUF_MEM_grow(v8, 512))
        goto LABEL_139;
      continue;
    }
    break;
  }
  v17 = v73 == v69;
  v69 = v73;
  if (!v17)
    goto LABEL_121;
LABEL_163:
  v76 = 100;
  v77 = 320;
LABEL_140:
  ERR_put_error(14, 4095, v76, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/conf/conf_def.c", v77);
LABEL_141:
  v62 = 0;
LABEL_147:
  BUF_MEM_free(v8);
  v78 = section;
LABEL_148:
  free(v78);
  if (a3)
    *a3 = v9;
  ERR_asprintf_error_data("line %ld", v9);
  v81 = a1->data;
  if (data != v81 && v81)
  {
    CONF_free(v81);
    a1->data = 0;
  }
  if (v62)
  {
    free(v62->name);
    free(v62->value);
    free(v62);
  }
  return 0;
}

uint64_t def_dump(uint64_t a1, void *arg)
{
  lh_doall_arg(*(LHASH **)(a1 + 16), (LHASH_DOALL_ARG_FN_TYPE)dump_value_LHASH_DOALL_ARG, arg);
  return 1;
}

uint64_t def_is_number(uint64_t a1, unsigned __int8 a2)
{
  return *(_WORD *)(*(_QWORD *)(a1 + 8) + 2 * a2) & 1;
}

uint64_t def_to_int(uint64_t a1, int a2)
{
  return (a2 - 48);
}

uint64_t def_load(CONF *a1, char *filename, char **a3)
{
  BIO *v5;
  BIO *v6;
  uint64_t bio;
  int v9;
  int v10;

  v5 = BIO_new_file(filename, "rb");
  if (v5)
  {
    v6 = v5;
    bio = def_load_bio(a1, v5, a3);
    BIO_free(v6);
    return bio;
  }
  else
  {
    if ((ERR_peek_last_error() & 0xFFF) == 0x80)
    {
      v9 = 114;
      v10 = 200;
    }
    else
    {
      v9 = 2;
      v10 = 202;
    }
    ERR_put_error(14, 4095, v9, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/conf/conf_def.c", v10);
    return 0;
  }
}

BUF_MEM *str_copy(const CONF *a1, char *a2, void **a3, const char *a4)
{
  BUF_MEM *result;
  BUF_MEM *v9;
  int v10;
  int v11;
  const char *i;
  _WORD *meth_data;
  unsigned int v14;
  __int16 v15;
  const char *v16;
  unsigned __int8 *v17;
  int v18;
  __int16 v19;
  uint64_t v21;
  int v22;
  BOOL v23;
  unsigned __int8 *v24;
  unsigned int v25;
  uint64_t v26;
  unsigned int v27;
  int v28;
  char v29;
  char v30;
  int v31;
  int v32;
  char v33;
  char *v34;
  const char *v35;
  char *v36;
  int v37;
  int v38;
  const char *v39;
  unsigned int v40;
  char *string;
  char *v42;
  size_t v43;
  char v44;
  uint64_t v45;
  unsigned __int8 *v46;
  int v47;
  int v48;
  int v49;
  void **v50;
  char *section;
  char v52;

  result = BUF_MEM_new();
  if (!result)
    return result;
  v9 = result;
  v10 = strlen(a4);
  if (!BUF_MEM_grow(v9, v10 + 1))
    goto LABEL_86;
  v52 = 0;
  v11 = 0;
  while (1)
  {
    for (i = a4; ; ++i)
    {
      while (1)
      {
        while (1)
        {
          while (1)
          {
            meth_data = a1->meth_data;
            v14 = *(unsigned __int8 *)i;
            v15 = meth_data[*(unsigned __int8 *)i];
            if ((v15 & 0x40) == 0)
              break;
            v17 = (unsigned __int8 *)(i + 1);
            v18 = *((unsigned __int8 *)i + 1);
            v19 = meth_data[*((unsigned __int8 *)i + 1)];
            if (v18 != v14 && (v19 & 8) == 0)
            {
              v21 = v11;
              while (1)
              {
                if ((v19 & 0x20) != 0)
                {
                  v18 = *((unsigned __int8 *)i + 2);
                  v17 = (unsigned __int8 *)(i + 2);
                  if ((meth_data[*((unsigned __int8 *)i + 2)] & 8) != 0)
                    break;
                }
                i = (const char *)v17;
                v11 = v21 + 1;
                v9->data[v21] = v18;
                v22 = *++v17;
                v18 = v22;
                meth_data = a1->meth_data;
                v19 = meth_data[v22];
                v23 = v22 != v14 && (v19 & 8) == 0;
                ++v21;
                if (!v23)
                  goto LABEL_44;
              }
              v11 = v21;
            }
LABEL_44:
            if (v18 == v14)
              i = (const char *)(v17 + 1);
            else
              i = (const char *)v17;
          }
          if ((meth_data[*(unsigned __int8 *)i] & 0x400) == 0)
            break;
          v24 = (unsigned __int8 *)(i + 1);
          v25 = *((unsigned __int8 *)i + 1);
          if ((meth_data[*((unsigned __int8 *)i + 1)] & 8) == 0)
          {
            v26 = v11;
            do
            {
              if (v25 == v14)
              {
                if (*((unsigned __int8 *)i + 2) != v14)
                {
                  v25 = v14;
                  break;
                }
                LOBYTE(v25) = v14;
                v24 = (unsigned __int8 *)(i + 2);
              }
              i = (const char *)v24;
              v9->data[v26++] = v25;
              ++v11;
              v27 = *++v24;
              v25 = v27;
            }
            while ((*((_WORD *)a1->meth_data + v27) & 8) == 0);
          }
          if (v25 == v14)
            i += 2;
          else
            i = (const char *)v24;
        }
        if ((v15 & 0x20) == 0)
          break;
        v28 = *((unsigned __int8 *)i + 1);
        if ((meth_data[*((unsigned __int8 *)i + 1)] & 8) != 0)
        {
LABEL_80:
          v9->data[v11] = 0;
          free(*a3);
          *a3 = v9->data;
          free(v9);
          return (BUF_MEM *)1;
        }
        i += 2;
        if (v28 == 116)
          v29 = 9;
        else
          v29 = v28;
        if (v28 == 110)
          v29 = 10;
        if (v28 == 114)
          v29 = 13;
        if (v28 == 98)
          v30 = 8;
        else
          v30 = v29;
        v9->data[v11++] = v30;
      }
      if ((v15 & 8) != 0)
        goto LABEL_80;
      v16 = i + 1;
      if (v14 == 36)
        break;
      v9->data[v11++] = v14;
    }
    v31 = *(unsigned __int8 *)v16;
    section = a2;
    if (v31 == 123)
    {
      v32 = 125;
    }
    else
    {
      if (v31 != 40)
      {
        v32 = 0;
        v33 = 1;
        goto LABEL_57;
      }
      v32 = 41;
    }
    v33 = 0;
    v16 = i + 2;
LABEL_57:
    v34 = (char *)(v16 - 1);
    v35 = v16 + 1;
    do
    {
      v36 = (char *)v35;
      v38 = *++v34;
      v37 = v38;
      ++v35;
    }
    while ((meth_data[v38] & 0x107) != 0);
    if (v37 != 58)
      goto LABEL_65;
    if (v34[1] != 58)
    {
      LOBYTE(v37) = 58;
LABEL_65:
      v36 = v34;
      v39 = v16;
      v16 = section;
      v34 = 0;
      goto LABEL_66;
    }
    *v34 = 0;
    v39 = v34 + 2;
    do
    {
      v40 = *++v36;
      LOBYTE(v37) = v40;
    }
    while ((*((_WORD *)a1->meth_data + v40) & 0x107) != 0);
    v52 = 58;
LABEL_66:
    *v36 = 0;
    a4 = v36;
    if ((v33 & 1) != 0)
      goto LABEL_69;
    if (v32 != (char)v37)
      break;
    a4 = v36 + 1;
LABEL_69:
    v50 = a3;
    string = _CONF_get_string(a1, v16, v39);
    v42 = string;
    if (v34)
      *v34 = v52;
    *v36 = v37;
    if (!string)
    {
      v48 = 104;
      v49 = 566;
      goto LABEL_85;
    }
    v43 = i - a4 + strlen(string) + *(_QWORD *)&v9->length;
    if (v43 > 0x10000)
    {
      v48 = 116;
      v49 = 571;
      goto LABEL_85;
    }
    if (!BUF_MEM_grow_clean(v9, v43))
    {
      v48 = 109;
      v49 = 575;
      goto LABEL_85;
    }
    v44 = *v42;
    if (*v42)
    {
      v45 = v11;
      v46 = (unsigned __int8 *)(v42 + 1);
      a3 = v50;
      a2 = section;
      do
      {
        v9->data[v45++] = v44;
        v47 = *v46++;
        v44 = v47;
        ++v11;
      }
      while (v47);
    }
    else
    {
      a3 = v50;
      a2 = section;
    }
    *v36 = v37;
  }
  v48 = 102;
  v49 = 547;
LABEL_85:
  ERR_put_error(14, 4095, v48, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/conf/conf_def.c", v49);
LABEL_86:
  BUF_MEM_free(v9);
  return 0;
}

uint64_t dump_value_LHASH_DOALL_ARG(uint64_t a1, BIO *bio)
{
  if (*(_QWORD *)(a1 + 8))
    return BIO_printf(bio, "[%s] %s=%s\n");
  else
    return BIO_printf(bio, "[[%s]]\n");
}

uint64_t def_init_WIN32(uint64_t result)
{
  if (result)
  {
    *(_QWORD *)result = &WIN32_method;
    *(_QWORD *)(result + 8) = &CONF_type_win32;
    *(_QWORD *)(result + 16) = 0;
    return 1;
  }
  return result;
}

void CRYPTO_lock(int mode, int type, const char *file, int line)
{
  if (type <= 0x28)
  {
    if ((mode & 1) != 0)
    {
      pthread_mutex_lock((pthread_mutex_t *)&locks + type);
    }
    else if ((mode & 2) != 0)
    {
      pthread_mutex_unlock((pthread_mutex_t *)&locks + type);
    }
  }
}

int CRYPTO_add_lock(int *pointer, int amount, int type, const char *file, int line)
{
  int v7;
  pthread_mutex_t *v8;

  if (type < 0x29)
  {
    v8 = (pthread_mutex_t *)((char *)&locks + 64 * (unint64_t)type);
    pthread_mutex_lock(v8);
    v7 = *pointer + amount;
    *pointer = v7;
    pthread_mutex_unlock(v8);
  }
  else
  {
    v7 = *pointer + amount;
    *pointer = v7;
  }
  return v7;
}

int X509_NAME_get_text_by_NID(X509_NAME *name, int nid, char *buf, int len)
{
  ASN1_OBJECT *v7;

  v7 = OBJ_nid2obj(nid);
  if (v7)
    return X509_NAME_get_text_by_OBJ(name, v7, buf, len);
  else
    return -1;
}

int X509_NAME_get_text_by_OBJ(X509_NAME *name, ASN1_OBJECT *obj, char *buf, int len)
{
  size_t v7;
  int index_by_OBJ;
  X509_NAME_ENTRY *entry;
  const void **value;

  LODWORD(v7) = -1;
  index_by_OBJ = X509_NAME_get_index_by_OBJ(name, obj, -1);
  if ((index_by_OBJ & 0x80000000) == 0)
  {
    entry = X509_NAME_get_entry(name, index_by_OBJ);
    if (entry)
      value = (const void **)entry->value;
    else
      value = 0;
    if (*(_DWORD *)value >= len)
      v7 = (len - 1);
    else
      v7 = *(unsigned int *)value;
    if (buf)
    {
      if ((v7 & 0x80000000) == 0)
      {
        memcpy(buf, value[1], v7);
        buf[v7] = 0;
      }
    }
    else
    {
      LODWORD(v7) = *(_DWORD *)value;
    }
  }
  return v7;
}

int X509_NAME_get_index_by_OBJ(X509_NAME *name, ASN1_OBJECT *obj, int lastpos)
{
  int v4;
  STACK *entries;
  int v6;
  char *v7;

  if (name)
  {
    if (lastpos < 0)
      v4 = -1;
    else
      v4 = lastpos;
    entries = name->entries;
    v6 = sk_num(name->entries);
    while (++v4 < v6)
    {
      v7 = sk_value(entries, v4);
      if (!OBJ_cmp(*(const ASN1_OBJECT **)v7, obj))
        return v4;
    }
  }
  return -1;
}

ASN1_STRING *__cdecl X509_NAME_ENTRY_get_data(ASN1_STRING *ne)
{
  if (ne)
    return (ASN1_STRING *)ne->data;
  return ne;
}

X509_NAME_ENTRY *__cdecl X509_NAME_get_entry(X509_NAME *name, int loc)
{
  int v4;

  if (!name)
    return 0;
  v4 = sk_num(name->entries);
  if (loc < 0 || v4 <= loc)
    return 0;
  else
    return (X509_NAME_ENTRY *)sk_value(name->entries, loc);
}

int X509_NAME_entry_count(X509_NAME *name)
{
  if (name)
    LODWORD(name) = sk_num(name->entries);
  return (int)name;
}

int X509_NAME_get_index_by_NID(X509_NAME *name, int nid, int lastpos)
{
  ASN1_OBJECT *v5;

  v5 = OBJ_nid2obj(nid);
  if (v5)
    return X509_NAME_get_index_by_OBJ(name, v5, lastpos);
  else
    return -2;
}

X509_NAME_ENTRY *__cdecl X509_NAME_delete_entry(X509_NAME *name, int loc)
{
  int v4;
  X509_NAME_ENTRY *v5;
  STACK *entries;
  int v7;
  int v8;
  int set;
  char *v12;

  if (!name)
    return 0;
  v4 = sk_num(name->entries);
  v5 = 0;
  if ((loc & 0x80000000) == 0 && v4 > loc)
  {
    entries = name->entries;
    v5 = (X509_NAME_ENTRY *)sk_delete(name->entries, loc);
    v7 = sk_num(entries);
    name->modified = 1;
    if (v7 != loc)
    {
      v8 = v7;
      if (loc)
        set = *((_DWORD *)sk_value(entries, loc - 1) + 4) + 1;
      else
        set = v5->set;
      if (set < *((_DWORD *)sk_value(entries, loc) + 4) && v8 > loc)
      {
        do
        {
          v12 = sk_value(entries, loc);
          --*((_DWORD *)v12 + 4);
          ++loc;
        }
        while (v8 != loc);
      }
    }
  }
  return v5;
}

int X509_NAME_add_entry_by_OBJ(X509_NAME *name, ASN1_OBJECT *obj, int type, unsigned __int8 *bytes, int len, int loc, int set)
{
  X509_NAME_ENTRY *v10;
  X509_NAME_ENTRY *v11;
  int v12;

  v10 = X509_NAME_ENTRY_create_by_OBJ(0, obj, type, bytes, len);
  if (v10)
  {
    v11 = v10;
    v12 = X509_NAME_add_entry(name, v10, loc, set);
    X509_NAME_ENTRY_free(v11);
    LODWORD(v10) = v12;
  }
  return (int)v10;
}

X509_NAME_ENTRY *__cdecl X509_NAME_ENTRY_create_by_OBJ(X509_NAME_ENTRY **ne, ASN1_OBJECT *obj, int type, const unsigned __int8 *bytes, int len)
{
  X509_NAME_ENTRY *v10;

  if (ne && (v10 = *ne) != 0 || (v10 = X509_NAME_ENTRY_new()) != 0)
  {
    if (X509_NAME_ENTRY_set_object(v10, obj) && X509_NAME_ENTRY_set_data(v10, type, bytes, len))
    {
      if (ne && !*ne)
        *ne = v10;
    }
    else
    {
      if (!ne || v10 != *ne)
        X509_NAME_ENTRY_free(v10);
      return 0;
    }
  }
  return v10;
}

int X509_NAME_add_entry(X509_NAME *name, X509_NAME_ENTRY *ne, int loc, int set)
{
  X509_NAME *v7;
  STACK *entries;
  int v9;
  _BOOL4 v11;
  char *v12;
  int v13;
  X509_NAME *v14;
  int v15;
  int v16;
  int v17;
  char *v18;

  if (!name)
    return (int)name;
  v7 = name;
  entries = name->entries;
  v9 = sk_num(name->entries);
  if (v9 < loc || loc < 0)
    loc = v9;
  v11 = set == 0;
  v7->modified = 1;
  if (set == -1)
  {
    if (loc)
    {
      v12 = sk_value(entries, loc - 1);
      v11 = 0;
      goto LABEL_12;
    }
    v13 = 0;
    v11 = 1;
  }
  else
  {
    if (loc < v9)
    {
      v12 = sk_value(entries, loc);
LABEL_12:
      v13 = *((_DWORD *)v12 + 4);
      goto LABEL_17;
    }
    if (loc)
      v13 = *((_DWORD *)sk_value(entries, loc - 1) + 4) + 1;
    else
      v13 = 0;
  }
LABEL_17:
  name = (X509_NAME *)X509_NAME_ENTRY_dup(ne);
  if (name)
  {
    v14 = name;
    LODWORD(name->bytes) = v13;
    if (sk_insert(entries, (char *)name, loc))
    {
      if (v11)
      {
        v15 = sk_num(entries);
        v16 = loc + 1;
        if (v16 < v15)
        {
          v17 = v15;
          do
          {
            v18 = sk_value(entries, v16);
            ++*((_DWORD *)v18 + 4);
            ++v16;
          }
          while (v17 != v16);
        }
      }
      LODWORD(name) = 1;
    }
    else
    {
      ERR_put_error(11, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509name.c", 290);
      X509_NAME_ENTRY_free((X509_NAME_ENTRY *)v14);
      LODWORD(name) = 0;
    }
  }
  return (int)name;
}

int X509_NAME_add_entry_by_NID(X509_NAME *name, int nid, int type, unsigned __int8 *bytes, int len, int loc, int set)
{
  X509_NAME_ENTRY *v10;
  X509_NAME_ENTRY *v11;
  int v12;

  v10 = X509_NAME_ENTRY_create_by_NID(0, nid, type, bytes, len);
  if (v10)
  {
    v11 = v10;
    v12 = X509_NAME_add_entry(name, v10, loc, set);
    X509_NAME_ENTRY_free(v11);
    LODWORD(v10) = v12;
  }
  return (int)v10;
}

X509_NAME_ENTRY *__cdecl X509_NAME_ENTRY_create_by_NID(X509_NAME_ENTRY **ne, int nid, int type, unsigned __int8 *bytes, int len)
{
  ASN1_OBJECT *v9;
  ASN1_OBJECT *v10;
  X509_NAME_ENTRY *v11;

  v9 = OBJ_nid2obj(nid);
  if (v9)
  {
    v10 = v9;
    v11 = X509_NAME_ENTRY_create_by_OBJ(ne, v9, type, bytes, len);
    ASN1_OBJECT_free(v10);
    return v11;
  }
  else
  {
    ERR_put_error(11, 4095, 109, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509name.c", 335);
    return 0;
  }
}

int X509_NAME_add_entry_by_txt(X509_NAME *name, const char *field, int type, const unsigned __int8 *bytes, int len, int loc, int set)
{
  X509_NAME_ENTRY *v10;
  X509_NAME_ENTRY *v11;
  int v12;

  v10 = X509_NAME_ENTRY_create_by_txt(0, field, type, bytes, len);
  if (v10)
  {
    v11 = v10;
    v12 = X509_NAME_add_entry(name, v10, loc, set);
    X509_NAME_ENTRY_free(v11);
    LODWORD(v10) = v12;
  }
  return (int)v10;
}

X509_NAME_ENTRY *__cdecl X509_NAME_ENTRY_create_by_txt(X509_NAME_ENTRY **ne, const char *field, int type, const unsigned __int8 *bytes, int len)
{
  ASN1_OBJECT *v10;
  ASN1_OBJECT *v11;
  X509_NAME_ENTRY *v12;

  v10 = OBJ_txt2obj(field, 0);
  if (v10)
  {
    v11 = v10;
    v12 = X509_NAME_ENTRY_create_by_OBJ(ne, v10, type, bytes, len);
    ASN1_OBJECT_free(v11);
    return v12;
  }
  else
  {
    ERR_put_error(11, 4095, 119, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509name.c", 316);
    ERR_asprintf_error_data("name=%s", field);
    return 0;
  }
}

int X509_NAME_ENTRY_set_object(X509_NAME_ENTRY *ne, ASN1_OBJECT *obj)
{
  ASN1_OBJECT *v4;

  if (ne && obj)
  {
    ASN1_OBJECT_free(ne->object);
    v4 = OBJ_dup(obj);
    ne->object = v4;
    return v4 != 0;
  }
  else
  {
    ERR_put_error(11, 4095, 67, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509name.c", 376);
    return 0;
  }
}

int X509_NAME_ENTRY_set_data(X509_NAME_ENTRY *ne, int type, const unsigned __int8 *bytes, int len)
{
  int v4;
  X509_NAME_ENTRY *v7;
  int v8;

  if (ne)
  {
    v4 = len;
    v7 = ne;
    if (bytes || !len)
    {
      if (type >= 1 && (type & 0x1000) != 0)
      {
        v8 = OBJ_obj2nid(ne->object);
        LODWORD(ne) = ASN1_STRING_set_by_NID(&v7->value, bytes, v4, type, v8) != 0;
      }
      else
      {
        if (len < 0)
          v4 = strlen((const char *)bytes);
        LODWORD(ne) = ASN1_STRING_set(v7->value, bytes, v4);
        if ((_DWORD)ne)
        {
          if (type != -1)
          {
            if (type == -2)
              v7->value->type = ASN1_PRINTABLE_type(bytes, v4);
            else
              v7->value->type = type;
          }
          LODWORD(ne) = 1;
        }
      }
    }
    else
    {
      LODWORD(ne) = 0;
    }
  }
  return (int)ne;
}

ASN1_OBJECT *__cdecl X509_NAME_ENTRY_get_object(ASN1_OBJECT *ne)
{
  if (ne)
    return (ASN1_OBJECT *)ne->sn;
  return ne;
}

uint64_t X509_NAME_ENTRY_set(uint64_t a1)
{
  return *(unsigned int *)(a1 + 16);
}

uint64_t engine_unlocked_init(uint64_t a1)
{
  uint64_t (*v2)(uint64_t);
  uint64_t result;

  LODWORD(v2) = *(_DWORD *)(a1 + 184);
  if ((_DWORD)v2 || (v2 = *(uint64_t (**)(uint64_t))(a1 + 120)) == 0)
  {
    result = 1;
LABEL_3:
    ++*(_DWORD *)(a1 + 180);
    *(_DWORD *)(a1 + 184) = (_DWORD)v2 + 1;
    return result;
  }
  result = v2(a1);
  if ((_DWORD)result)
  {
    LODWORD(v2) = *(_DWORD *)(a1 + 184);
    goto LABEL_3;
  }
  return result;
}

uint64_t engine_unlocked_finish(uint64_t a1, int a2)
{
  int v3;
  uint64_t v4;
  uint64_t (*v6)(uint64_t);

  v3 = *(_DWORD *)(a1 + 184) - 1;
  *(_DWORD *)(a1 + 184) = v3;
  if (v3 || (v6 = *(uint64_t (**)(uint64_t))(a1 + 128)) == 0)
  {
    v4 = 1;
  }
  else if (a2)
  {
    CRYPTO_lock(10, 30, 0, 0);
    v4 = (*(uint64_t (**)(uint64_t))(a1 + 128))(a1);
    CRYPTO_lock(9, 30, 0, 0);
    if (!(_DWORD)v4)
      return v4;
  }
  else
  {
    v4 = v6(a1);
    if (!(_DWORD)v4)
      return v4;
  }
  if (!engine_free_util((CRYPTO_EX_DATA *)a1, 0))
  {
    ERR_put_error(38, 4095, 106, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/engine/eng_init.c", 109);
    return 0;
  }
  return v4;
}

int ENGINE_init(ENGINE *e)
{
  uint64_t (*v2)(ENGINE *);
  int v3;

  if (!e)
  {
    ERR_put_error(38, 4095, 67, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/engine/eng_init.c", 122);
    return 0;
  }
  CRYPTO_lock(9, 30, 0, 0);
  LODWORD(v2) = *((_DWORD *)e + 46);
  if ((_DWORD)v2 || (v2 = (uint64_t (*)(ENGINE *))*((_QWORD *)e + 15)) == 0)
  {
    v3 = 1;
  }
  else
  {
    v3 = v2(e);
    if (!v3)
      goto LABEL_5;
    LODWORD(v2) = *((_DWORD *)e + 46);
  }
  ++*((_DWORD *)e + 45);
  *((_DWORD *)e + 46) = (_DWORD)v2 + 1;
LABEL_5:
  CRYPTO_lock(10, 30, 0, 0);
  return v3;
}

int ENGINE_finish(ENGINE *e)
{
  int v2;

  if (!e)
    return 1;
  CRYPTO_lock(9, 30, 0, 0);
  v2 = engine_unlocked_finish((uint64_t)e, 1);
  CRYPTO_lock(10, 30, 0, 0);
  if (!v2)
    ERR_put_error(38, 4095, 106, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/engine/eng_init.c", 143);
  return v2;
}

uint64_t BN_mod_ct(BIGNUM *a1, const BIGNUM *a2, const BIGNUM *a3, BN_CTX *a4)
{
  return BN_div_ct(0, a1, a2, a3, a4);
}

uint64_t BN_mod_nonct(BIGNUM *a1, const BIGNUM *a2, const BIGNUM *a3, BN_CTX *a4)
{
  return BN_div_nonct(0, a1, a2, a3, a4);
}

int BN_nnmod(BIGNUM *r, const BIGNUM *m, const BIGNUM *d, BN_CTX *ctx)
{
  int result;

  result = BN_div_ct(0, r, m, d, ctx);
  if (result)
  {
    if (BN_is_negative((uint64_t)r))
      return BN_usub(r, d, r);
    else
      return 1;
  }
  return result;
}

int BN_mod_add(BIGNUM *r, const BIGNUM *a, const BIGNUM *b, const BIGNUM *m, BN_CTX *ctx)
{
  int result;

  result = BN_add(r, a, b);
  if (result)
    return BN_nnmod(r, r, m, ctx);
  return result;
}

int BN_mod_add_quick(BIGNUM *r, const BIGNUM *a, const BIGNUM *b, const BIGNUM *m)
{
  int result;

  result = BN_uadd(r, a, b);
  if (result)
  {
    if (BN_ucmp(r, m) < 0)
      return 1;
    else
      return BN_usub(r, r, m);
  }
  return result;
}

int BN_mod_sub(BIGNUM *r, const BIGNUM *a, const BIGNUM *b, const BIGNUM *m, BN_CTX *ctx)
{
  int result;

  result = BN_sub(r, a, b);
  if (result)
    return BN_nnmod(r, r, m, ctx);
  return result;
}

int BN_mod_sub_quick(BIGNUM *r, const BIGNUM *a, const BIGNUM *b, const BIGNUM *m)
{
  int result;

  if ((BN_ucmp(a, b) & 0x80000000) == 0)
    return BN_usub(r, a, b);
  result = BN_usub(r, b, a);
  if (result)
    return BN_usub(r, m, r);
  return result;
}

int BN_mod_mul(BIGNUM *r, const BIGNUM *a, const BIGNUM *b, const BIGNUM *m, BN_CTX *ctx)
{
  BIGNUM *v10;
  _BOOL4 v11;

  BN_CTX_start(ctx);
  if (r == a || (v10 = r, r == b))
  {
    v10 = BN_CTX_get(ctx);
    if (!v10)
      goto LABEL_10;
  }
  else if (!r)
  {
    goto LABEL_10;
  }
  if (a == b)
  {
    if (BN_sqr(v10, a, ctx))
      goto LABEL_8;
LABEL_10:
    v11 = 0;
    goto LABEL_11;
  }
  if (!BN_mul(v10, a, b, ctx))
    goto LABEL_10;
LABEL_8:
  v11 = BN_nnmod(r, v10, m, ctx) != 0;
LABEL_11:
  BN_CTX_end(ctx);
  return v11;
}

int BN_mod_sqr(BIGNUM *r, const BIGNUM *a, const BIGNUM *m, BN_CTX *ctx)
{
  return BN_mod_mul(r, a, a, m, ctx);
}

int BN_mod_lshift1(BIGNUM *r, const BIGNUM *a, const BIGNUM *m, BN_CTX *ctx)
{
  int result;

  result = BN_lshift1(r, a);
  if (result)
    return BN_nnmod(r, r, m, ctx);
  return result;
}

int BN_mod_lshift1_quick(BIGNUM *r, const BIGNUM *a, const BIGNUM *m)
{
  int result;

  result = BN_lshift1(r, a);
  if (result)
  {
    if (BN_ucmp(r, m) < 0)
      return 1;
    else
      return BN_usub(r, r, m);
  }
  return result;
}

int BN_mod_lshift(BIGNUM *r, const BIGNUM *a, int n, const BIGNUM *m, BN_CTX *ctx)
{
  BIGNUM *v10;
  BIGNUM *v11;
  int v12;

  BN_CTX_start(ctx);
  if (BN_nnmod(r, a, m, ctx))
  {
    if (!BN_is_negative((uint64_t)m))
    {
      v11 = (BIGNUM *)m;
      goto LABEL_8;
    }
    v10 = BN_CTX_get(ctx);
    if (v10)
    {
      v11 = v10;
      if (bn_copy(v10, m))
      {
        BN_set_negative(v11, 0);
LABEL_8:
        v12 = BN_mod_lshift_quick(r, r, n, v11);
        goto LABEL_9;
      }
    }
  }
  v12 = 0;
LABEL_9:
  BN_CTX_end(ctx);
  return v12;
}

int BN_mod_lshift_quick(BIGNUM *r, const BIGNUM *a, int n, const BIGNUM *m)
{
  int result;
  int v8;
  int v9;
  unsigned int v10;
  int v11;
  BOOL v12;

  result = bn_copy(r, a);
  if (result)
  {
    if (n < 1)
    {
      return 1;
    }
    else
    {
      while (1)
      {
        v8 = BN_num_bits(m);
        v9 = BN_num_bits(r);
        v10 = v8 - v9;
        if (v8 - v9 < 0)
          break;
        if (v8 == v9)
          v10 = 1;
        if (v10 >= n)
          v11 = n;
        else
          v11 = v10;
        result = BN_lshift(r, r, v11);
        if (!result)
          return result;
        if ((BN_ucmp(r, m) & 0x80000000) == 0)
        {
          result = BN_usub(r, r, m);
          if (!result)
            return result;
        }
        v12 = __OFSUB__(n, v11);
        n -= v11;
        if ((n < 0) ^ v12 | (n == 0))
          return 1;
      }
      ERR_put_error(3, 4095, 110, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/bn/bn_mod.c", 296);
      return 0;
    }
  }
  return result;
}

PBE2PARAM *__cdecl d2i_PBE2PARAM(PBE2PARAM **a, const unsigned __int8 **in, uint64_t len)
{
  return (PBE2PARAM *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &PBE2PARAM_it);
}

int i2d_PBE2PARAM(PBE2PARAM *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &PBE2PARAM_it);
}

PBE2PARAM *PBE2PARAM_new(void)
{
  return (PBE2PARAM *)ASN1_item_new(&PBE2PARAM_it);
}

void PBE2PARAM_free(PBE2PARAM *a)
{
  ASN1_item_free((ASN1_VALUE *)a, &PBE2PARAM_it);
}

PBKDF2PARAM *__cdecl d2i_PBKDF2PARAM(PBKDF2PARAM **a, const unsigned __int8 **in, uint64_t len)
{
  return (PBKDF2PARAM *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &PBKDF2PARAM_it);
}

int i2d_PBKDF2PARAM(PBKDF2PARAM *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &PBKDF2PARAM_it);
}

PBKDF2PARAM *PBKDF2PARAM_new(void)
{
  return (PBKDF2PARAM *)ASN1_item_new(&PBKDF2PARAM_it);
}

void PBKDF2PARAM_free(PBKDF2PARAM *a)
{
  ASN1_item_free((ASN1_VALUE *)a, &PBKDF2PARAM_it);
}

X509_ALGOR *PKCS5_pbe2_set_iv(const EVP_CIPHER *a1, int a2, const void *a3, int a4, uint64_t a5, int a6)
{
  int v12;
  int v13;
  ASN1_OBJECT *v14;
  ASN1_VALUE *v15;
  ASN1_VALUE *v16;
  uint64_t v17;
  ASN1_TYPE *v18;
  size_t v19;
  X509_ALGOR *v20;
  int v21;
  X509_ALGOR *v22;
  ASN1_TYPE *v23;
  int ptr;
  unsigned __int8 __buf[16];
  EVP_CIPHER_CTX a;
  uint64_t v28;

  v28 = *MEMORY[0x24BDAC8D0];
  ptr = a6;
  memset(&a, 0, sizeof(a));
  v12 = EVP_CIPHER_type(a1);
  if (!v12)
  {
    ERR_put_error(13, 4095, 108, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/p5_pbev2.c", 198);
    v20 = 0;
    v16 = 0;
LABEL_26:
    ASN1_item_free(v16, &PBE2PARAM_it);
    X509_ALGOR_free(0);
    X509_ALGOR_free(v20);
    return 0;
  }
  v13 = v12;
  v14 = OBJ_nid2obj(v12);
  v15 = ASN1_item_new(&PBE2PARAM_it);
  v16 = v15;
  if (!v15
    || (v17 = *((_QWORD *)v15 + 1), *(_QWORD *)v17 = v14, v18 = ASN1_TYPE_new(), (*(_QWORD *)(v17 + 8) = v18) == 0))
  {
LABEL_24:
    v20 = 0;
LABEL_25:
    ERR_put_error(13, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/p5_pbev2.c", 278);
    goto LABEL_26;
  }
  if (EVP_CIPHER_iv_length(a1))
  {
    v19 = EVP_CIPHER_iv_length(a1);
    if (a5)
      __memcpy_chk();
    else
      arc4random_buf(__buf, v19);
  }
  EVP_CIPHER_CTX_init(&a);
  if (!EVP_CipherInit_ex(&a, a1, 0, 0, __buf, 0))
  {
LABEL_17:
    v20 = 0;
    goto LABEL_26;
  }
  if (EVP_CIPHER_param_to_asn1(&a, *(ASN1_TYPE **)(v17 + 8)) < 0)
  {
    ERR_put_error(13, 4095, 114, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/p5_pbev2.c", 227);
    EVP_CIPHER_CTX_cleanup(&a);
    goto LABEL_17;
  }
  if (a6 == -1 && EVP_CIPHER_CTX_ctrl(&a, 7, 0, &ptr) <= 0)
  {
    ERR_clear_error();
    ptr = 163;
  }
  EVP_CIPHER_CTX_cleanup(&a);
  if (v13 == 37)
    v21 = EVP_CIPHER_key_length(a1);
  else
    v21 = -1;
  X509_ALGOR_free(*(X509_ALGOR **)v16);
  v22 = PKCS5_pbkdf2_set(a2, a3, a4, ptr, v21);
  *(_QWORD *)v16 = v22;
  if (!v22)
    goto LABEL_24;
  v20 = X509_ALGOR_new();
  if (!v20)
    goto LABEL_25;
  v23 = ASN1_TYPE_new();
  v20->parameter = v23;
  if (!v23)
    goto LABEL_25;
  v20->algorithm = OBJ_nid2obj(161);
  if (!ASN1_item_pack(v16, &PBE2PARAM_it, (ASN1_OCTET_STRING **)&v20->parameter->value))
    goto LABEL_25;
  v20->parameter->type = 16;
  ASN1_item_free(v16, &PBE2PARAM_it);
  return v20;
}

X509_ALGOR *PKCS5_pbkdf2_set(int a1, const void *a2, int a3, int a4, int a5)
{
  ASN1_VALUE *v10;
  ASN1_OCTET_STRING *v11;
  ASN1_OCTET_STRING *v12;
  int v13;
  unsigned __int8 *v14;
  uint64_t v15;
  ASN1_INTEGER *v16;
  X509_ALGOR *v17;
  X509_ALGOR *v18;
  ASN1_OBJECT *v19;
  X509_ALGOR *v20;
  ASN1_TYPE *v21;

  v10 = ASN1_item_new(&PBKDF2PARAM_it);
  if (!v10)
    goto LABEL_25;
  v11 = ASN1_OCTET_STRING_new();
  if (!v11)
    goto LABEL_25;
  v12 = v11;
  *(_QWORD *)(*(_QWORD *)v10 + 8) = v11;
  **(_DWORD **)v10 = 4;
  v13 = a3 ? a3 : 8;
  v14 = (unsigned __int8 *)malloc_type_malloc(v13, 0xDCB0AC39uLL);
  v12->data = v14;
  if (!v14)
    goto LABEL_25;
  v12->length = v13;
  if (a2)
    memcpy(v14, a2, v13);
  else
    arc4random_buf(v14, v13);
  v15 = a1 >= 1 ? a1 : 2048;
  if (!ASN1_INTEGER_set(*((ASN1_INTEGER **)v10 + 1), v15))
    goto LABEL_25;
  if (a5 >= 1)
  {
    v16 = ASN1_INTEGER_new();
    *((_QWORD *)v10 + 2) = v16;
    if (!v16 || !ASN1_INTEGER_set(v16, a5))
      goto LABEL_25;
  }
  if (a4 >= 1 && a4 != 163)
  {
    v17 = X509_ALGOR_new();
    *((_QWORD *)v10 + 3) = v17;
    if (v17)
    {
      v18 = v17;
      v19 = OBJ_nid2obj(a4);
      X509_ALGOR_set0(v18, v19, 5, 0);
      goto LABEL_21;
    }
LABEL_25:
    v20 = 0;
LABEL_26:
    ERR_put_error(13, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/p5_pbev2.c", 370);
    ASN1_item_free(v10, &PBKDF2PARAM_it);
    X509_ALGOR_free(v20);
    return 0;
  }
LABEL_21:
  v20 = X509_ALGOR_new();
  if (!v20)
    goto LABEL_26;
  v20->algorithm = OBJ_nid2obj(69);
  v21 = ASN1_TYPE_new();
  v20->parameter = v21;
  if (!v21 || !ASN1_item_pack(v10, &PBKDF2PARAM_it, (ASN1_OCTET_STRING **)&v21->value))
    goto LABEL_26;
  v20->parameter->type = 16;
  ASN1_item_free(v10, &PBKDF2PARAM_it);
  return v20;
}

X509_ALGOR *__cdecl PKCS5_pbe2_set(const EVP_CIPHER *cipher, int iter, unsigned __int8 *salt, int saltlen)
{
  return PKCS5_pbe2_set_iv(cipher, iter, salt, saltlen, 0, -1);
}

int PKCS5_PBE_keyivgen(EVP_CIPHER_CTX *ctx, const char *pass, int passlen, ASN1_TYPE *param, const EVP_CIPHER *cipher, const EVP_MD *md, int en_de)
{
  int v14;
  unsigned int v15;
  char *ptr;
  PBEPARAM *v17;
  PBEPARAM *v18;
  ASN1_INTEGER *iter;
  int v20;
  int v21;
  int v22;
  unsigned __int8 *data;
  int v25;
  int v26;
  int v27;
  size_t cnt;
  unsigned __int8 *in;
  EVP_MD_CTX ctxa;
  __int128 v31;
  unsigned __int8 iv[16];
  unsigned __int8 key[64];
  unsigned __int8 mda[64];
  uint64_t v35;

  v35 = *MEMORY[0x24BDAC8D0];
  if (!param || param->type != 16 || !param->value.ptr)
  {
    v21 = 95;
    goto LABEL_10;
  }
  v14 = EVP_MD_size(md);
  if ((v14 & 0x80000000) == 0)
  {
    v15 = v14;
    v31 = 0u;
    memset(&ctxa, 0, sizeof(ctxa));
    ptr = param->value.ptr;
    in = (unsigned __int8 *)*((_QWORD *)ptr + 1);
    v17 = d2i_PBEPARAM(0, (const unsigned __int8 **)&in, *(int *)ptr);
    if (v17)
    {
      v18 = v17;
      iter = v17->iter;
      if (iter)
      {
        v20 = ASN1_INTEGER_get(iter);
        if (v20 <= 0)
        {
          ERR_put_error(6, 4095, 135, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/p5_crpt.c", 112);
          PBEPARAM_free(v18);
          return 0;
        }
      }
      else
      {
        v20 = 1;
      }
      data = v18->salt->data;
      cnt = v18->salt->length;
      if (pass)
      {
        if (passlen == -1)
          passlen = strlen(pass);
      }
      else
      {
        passlen = 0;
      }
      EVP_MD_CTX_init(&ctxa);
      if (!EVP_DigestInit_ex(&ctxa, md, 0)
        || !EVP_DigestUpdate(&ctxa, pass, passlen)
        || !EVP_DigestUpdate(&ctxa, data, cnt)
        || !EVP_DigestFinal_ex(&ctxa, mda, 0))
      {
        goto LABEL_34;
      }
      if (v20 >= 2)
      {
        v25 = v20 - 1;
        while (EVP_DigestInit_ex(&ctxa, md, 0)
             && EVP_DigestUpdate(&ctxa, mda, v15)
             && EVP_DigestFinal_ex(&ctxa, mda, 0))
        {
          if (!--v25)
            goto LABEL_29;
        }
        goto LABEL_34;
      }
LABEL_29:
      if (EVP_CIPHER_key_length(cipher) < 0x41)
      {
        EVP_CIPHER_key_length(cipher);
        __memcpy_chk();
        if (EVP_CIPHER_iv_length(cipher) < 0x11)
        {
          EVP_CIPHER_iv_length(cipher);
          EVP_CIPHER_iv_length(cipher);
          __memcpy_chk();
          if (EVP_CipherInit_ex(ctx, cipher, 0, key, iv, en_de))
          {
            explicit_bzero(mda, 0x40uLL);
            explicit_bzero(key, 0x40uLL);
            explicit_bzero(iv, 0x10uLL);
            v22 = 1;
            goto LABEL_35;
          }
LABEL_34:
          v22 = 0;
LABEL_35:
          EVP_MD_CTX_cleanup(&ctxa);
          PBEPARAM_free(v18);
          return v22;
        }
        v26 = 102;
        v27 = 148;
      }
      else
      {
        v26 = 137;
        v27 = 143;
      }
      ERR_put_error(6, 4095, v26, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/p5_crpt.c", v27);
      goto LABEL_34;
    }
    v21 = 105;
LABEL_10:
    ERR_put_error(6, 4095, 114, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/p5_crpt.c", v21);
  }
  return 0;
}

int BN_lshift1(BIGNUM *r, const BIGNUM *a)
{
  int top;
  int v5;
  int result;
  unint64_t *d;
  uint64_t v8;
  unint64_t *v9;
  unint64_t *v10;
  unint64_t v11;
  unint64_t *v12;
  unint64_t *v13;
  unint64_t i;
  unint64_t v15;
  uint64_t v16;
  __int128 v17;

  top = a->top;
  if (top <= 0)
  {
    BN_zero((uint64_t)r);
  }
  else
  {
    v5 = top + 1;
    result = bn_wexpand((uint64_t)r, (top + 1));
    if (!result)
      return result;
    d = a->d;
    v8 = a->top;
    v9 = &a->d[v8];
    v11 = *(v9 - 1);
    v10 = v9 - 1;
    v12 = r->d;
    v13 = &r->d[v8];
    for (i = v11 >> 63; ; i = v17 >> 63)
    {
      *v13-- = i;
      if (v10 <= d)
        break;
      v15 = *v10;
      v16 = *--v10;
      *((_QWORD *)&v17 + 1) = v15;
      *(_QWORD *)&v17 = v16;
    }
    *v13 = 2 * *v10;
    while (v13 > v12)
      *--v13 = 0;
    r->top = v5;
    bn_correct_top((uint64_t *)r);
    BN_set_negative(r, a->neg);
  }
  return 1;
}

int BN_lshift(BIGNUM *r, const BIGNUM *a, int n)
{
  int top;
  char v7;
  unint64_t v8;
  unsigned int v9;
  int result;
  char v11;
  uint64_t v12;
  unint64_t v13;
  unint64_t *d;
  uint64_t v15;
  unint64_t *v16;
  unint64_t *v17;
  unint64_t v18;
  unint64_t *v19;
  unint64_t *v20;
  unint64_t *v21;
  uint64_t v22;
  unint64_t *v23;
  uint64_t v24;

  if (n < 0)
  {
    ERR_put_error(3, 4095, 106, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/bn/bn_shift.c", 32);
    return 0;
  }
  else
  {
    top = a->top;
    if (top <= 0)
    {
      BN_zero((uint64_t)r);
    }
    else
    {
      v7 = n;
      v8 = (unint64_t)n >> 6;
      v9 = v8 + top + 1;
      result = bn_wexpand((uint64_t)r, v9);
      if (!result)
        return result;
      v11 = v7 & 0x3F;
      v12 = -n & 0x3FLL;
      v13 = (v7 & 0x3F) + v12;
      d = a->d;
      v15 = a->top;
      v16 = &a->d[v15];
      v18 = *(v16 - 1);
      v17 = v16 - 1;
      v19 = r->d;
      v20 = &r->d[v15 + v8];
      *v20 = (v18 >> v12) & -(uint64_t)(v13 >> 6);
      v21 = v20 - 1;
      if (v17 > d)
      {
        v22 = (uint64_t)&v19[v8 - 1];
        v23 = d - 1;
        v24 = (uint64_t)&d[-(v13 >> 6) - 1];
        do
        {
          *(_QWORD *)(v22 + 8 * v15) = (*(_QWORD *)(v24 + 8 * v15) >> v12) | (v23[v15] << v11);
          v22 -= 8;
          --v23;
          v24 -= 8;
        }
        while (&v23[v15] > d);
        v21 = (unint64_t *)(v22 + 8 * v15);
        v17 = &v23[v15];
      }
      *v21 = *v17 << v11;
      while (v21 > v19)
        *--v21 = 0;
      r->top = v9;
      bn_correct_top((uint64_t *)r);
      BN_set_negative(r, a->neg);
    }
    return 1;
  }
}

int BN_rshift1(BIGNUM *r, const BIGNUM *a)
{
  unsigned int top;
  int result;
  unint64_t *d;
  unint64_t *v7;
  uint64_t v8;
  unint64_t *v9;
  unint64_t v10;
  __int128 v11;

  top = a->top;
  if (top)
  {
    result = bn_wexpand((uint64_t)r, a->top);
    if (!result)
      return result;
    d = a->d;
    v7 = r->d;
    if (top < 2)
    {
      v9 = a->d;
    }
    else
    {
      v8 = (int)top - 1;
      v9 = a->d;
      do
      {
        v10 = v9[1];
        ++v9;
        *((_QWORD *)&v11 + 1) = v10;
        *(_QWORD *)&v11 = *d;
        *v7++ = v11 >> 1;
        d = v9;
        --v8;
      }
      while (v8);
    }
    *v7 = *v9 >> 1;
    r->top = top;
    bn_correct_top((uint64_t *)r);
    BN_set_negative(r, a->neg);
  }
  else
  {
    BN_zero((uint64_t)r);
  }
  return 1;
}

int BN_rshift(BIGNUM *r, const BIGNUM *a, int n)
{
  char v6;
  unint64_t top;
  unint64_t v8;
  unint64_t v9;
  int result;
  uint64_t v11;
  unint64_t *v12;
  unint64_t *d;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;

  if (n < 0)
  {
    ERR_put_error(3, 4095, 106, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/bn/bn_shift.c", 103);
    return 0;
  }
  else
  {
    v6 = n;
    top = a->top;
    if (top <= (unint64_t)n >> 6)
    {
      BN_zero((uint64_t)r);
    }
    else
    {
      v8 = (unint64_t)n >> 6;
      v9 = top - v8;
      result = bn_wexpand((uint64_t)r, top - v8);
      if (!result)
        return result;
      v11 = v6 & 0x3F;
      v12 = &a->d[v8];
      d = r->d;
      if (v9 >= 2)
      {
        v14 = ~v8 + top;
        do
        {
          v15 = v12[((-n & 0x3FuLL) + v11) >> 6] << (-(char)n & 0x3F);
          v16 = *v12++;
          *d++ = (v16 >> v11) | v15;
          --v14;
        }
        while (v14);
      }
      *d = *v12 >> v11;
      r->top = v9;
      bn_correct_top((uint64_t *)r);
      BN_set_negative(r, a->neg);
    }
    return 1;
  }
}

uint64_t timingsafe_memcmp(unsigned __int8 *a1, unsigned __int8 *a2, uint64_t a3)
{
  int v3;
  uint64_t v4;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;

  if (!a3)
    return 0;
  v3 = 0;
  LODWORD(v4) = 0;
  do
  {
    v6 = *a1++;
    v5 = v6;
    v7 = *a2++;
    v8 = v5 - v7;
    v9 = v7 - v5;
    v4 = ((v8 >> 8) - (v9 >> 8)) & ~v3 | v4;
    v3 |= (v9 >> 8) | (v8 >> 8);
    --a3;
  }
  while (a3);
  return v4;
}

uint64_t whirlpool_block(uint64_t *a1, _QWORD *a2, uint64_t a3)
{
  unint64_t v3;
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t result;
  uint64_t v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t v20;
  unint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  unint64_t v39;
  unint64_t v40;
  unint64_t v41;
  unint64_t v42;
  unint64_t v43;
  uint64_t v44;
  uint64_t v45;
  unint64_t v46;
  _QWORD *v47;
  uint64_t v48;
  unint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  unint64_t v53;
  unint64_t v54;
  unint64_t v55;
  unint64_t v56;
  uint64_t v57;

  v3 = *a1;
  v4 = a1[1];
  v5 = a1[2];
  v6 = a1[3];
  v7 = a1[4];
  v8 = a1[5];
  v10 = a1[6];
  v9 = a1[7];
  do
  {
    v47 = a2;
    v48 = a3;
    v11 = 0;
    v12 = *a2 ^ v3;
    v13 = a2[1] ^ v4;
    v14 = a2[2] ^ v5;
    v15 = a2[3] ^ v6;
    result = a2[4] ^ v7;
    v17 = a2[5] ^ v8;
    v18 = a2[6] ^ v10;
    v19 = a2[7] ^ v9;
    v40 = v9;
    v41 = v10;
    v42 = v8;
    v43 = v7;
    v44 = v6;
    v45 = v5;
    v20 = v6;
    v21 = v5;
    v46 = v4;
    v39 = v12;
    do
    {
      v49 = v13;
      v54 = v17;
      v55 = result;
      v56 = v15;
      v57 = v11;
      v22 = Cx[2 * v4] ^ *(_QWORD *)((char *)Cx + ((v3 >> 4) & 0xFF0) + 7);
      v23 = *(_QWORD *)((char *)Cx + ((v4 >> 4) & 0xFF0) + 7) ^ *(_QWORD *)((char *)Cx + ((v3 >> 12) & 0xFF0) + 6);
      v24 = *(_QWORD *)((char *)&Cx[512] + v11) ^ Cx[2 * v3] ^ *(_QWORD *)((char *)Cx
                                                                                          + ((v4 >> 52) & 0xFF0)
                                                                                          + 1) ^ *(_QWORD *)((char *)Cx + ((v21 >> 44) & 0xFF0) + 2);
      v25 = *(_QWORD *)((char *)Cx + ((v4 >> 20) & 0xFF0) + 5) ^ *(_QWORD *)((char *)Cx + ((v3 >> 28) & 0xFF0) + 4) ^ *(_QWORD *)((char *)Cx + ((v21 >> 12) & 0xFF0) + 6) ^ *(_QWORD *)((char *)Cx + ((v20 >> 4) & 0xFF0) + 7);
      v26 = *(_QWORD *)((char *)Cx + ((v4 >> 28) & 0xFF0) + 4) ^ *(_QWORD *)((char *)Cx + ((v3 >> 36) & 0xFF0) + 3) ^ *(_QWORD *)((char *)Cx + ((v21 >> 20) & 0xFF0) + 5) ^ *(_QWORD *)((char *)Cx + ((v20 >> 12) & 0xFF0) + 6);
      v27 = *(_QWORD *)((char *)Cx + ((v4 >> 36) & 0xFF0) + 3) ^ *(_QWORD *)((char *)Cx + ((v3 >> 44) & 0xFF0) + 2) ^ *(_QWORD *)((char *)Cx + ((v21 >> 28) & 0xFF0) + 4) ^ *(_QWORD *)((char *)Cx + ((v20 >> 20) & 0xFF0) + 5);
      v28 = *(_QWORD *)((char *)Cx + ((v4 >> 12) & 0xFF0) + 6) ^ *(_QWORD *)((char *)Cx + ((v3 >> 20) & 0xFF0) + 5) ^ *(_QWORD *)((char *)Cx + ((v21 >> 4) & 0xFF0) + 7) ^ Cx[2 * v20] ^ *(_QWORD *)((char *)Cx + ((v7 >> 52) & 0xFF0) + 1) ^ *(_QWORD *)((char *)Cx + ((v8 >> 44) & 0xFF0) + 2) ^ *(_QWORD *)((char *)Cx + ((v10 >> 36) & 0xFF0) + 3);
      v53 = *(_QWORD *)((char *)Cx + ((v4 >> 44) & 0xFF0) + 2) ^ *(_QWORD *)((char *)Cx + ((v3 >> 52) & 0xFF0) + 1) ^ *(_QWORD *)((char *)Cx + ((v21 >> 36) & 0xFF0) + 3) ^ *(_QWORD *)((char *)Cx + ((v20 >> 28) & 0xFF0) + 4) ^ *(_QWORD *)((char *)Cx + ((v7 >> 20) & 0xFF0) + 5) ^ *(_QWORD *)((char *)Cx + ((v8 >> 12) & 0xFF0) + 6) ^ *(_QWORD *)((char *)Cx + ((v10 >> 4) & 0xFF0) + 7) ^ Cx[2 * v9];
      v3 = v24 ^ *(_QWORD *)((char *)Cx + ((v20 >> 36) & 0xFF0) + 3) ^ *(_QWORD *)((char *)Cx + ((v7 >> 28) & 0xFF0) + 4) ^ *(_QWORD *)((char *)Cx + ((v8 >> 20) & 0xFF0) + 5) ^ *(_QWORD *)((char *)Cx + ((v10 >> 12) & 0xFF0) + 6) ^ *(_QWORD *)((char *)Cx + ((v9 >> 4) & 0xFF0) + 7);
      v4 = v22 ^ *(_QWORD *)((char *)Cx + ((v21 >> 52) & 0xFF0) + 1) ^ *(_QWORD *)((char *)Cx + ((v20 >> 44) & 0xFF0)
                                                                                              + 2) ^ *(_QWORD *)((char *)Cx + ((v7 >> 36) & 0xFF0) + 3) ^ *(_QWORD *)((char *)Cx + ((v8 >> 28) & 0xFF0) + 4) ^ *(_QWORD *)((char *)Cx + ((v10 >> 20) & 0xFF0) + 5) ^ *(_QWORD *)((char *)Cx + ((v9 >> 12) & 0xFF0) + 6);
      v21 = v23 ^ Cx[2 * v21] ^ *(_QWORD *)((char *)Cx + ((v20 >> 52) & 0xFF0) + 1) ^ *(_QWORD *)((char *)Cx + ((v7 >> 44) & 0xFF0) + 2) ^ *(_QWORD *)((char *)Cx + ((v8 >> 36) & 0xFF0) + 3) ^ *(_QWORD *)((char *)Cx + ((v10 >> 28) & 0xFF0) + 4) ^ *(_QWORD *)((char *)Cx + ((v9 >> 20) & 0xFF0) + 5);
      v20 = v28 ^ *(_QWORD *)((char *)Cx + ((v9 >> 28) & 0xFF0) + 4);
      v52 = v25 ^ Cx[2 * v7] ^ *(_QWORD *)((char *)Cx + ((v8 >> 52) & 0xFF0) + 1) ^ *(_QWORD *)((char *)Cx + ((v10 >> 44) & 0xFF0) + 2) ^ *(_QWORD *)((char *)Cx + ((v9 >> 36) & 0xFF0) + 3);
      v51 = v26 ^ *(_QWORD *)((char *)Cx + ((v7 >> 4) & 0xFF0) + 7) ^ Cx[2 * v8] ^ *(_QWORD *)((char *)Cx + ((v10 >> 52) & 0xFF0) + 1) ^ *(_QWORD *)((char *)Cx + ((v9 >> 44) & 0xFF0) + 2);
      v50 = v27 ^ *(_QWORD *)((char *)Cx + ((v7 >> 12) & 0xFF0) + 6) ^ *(_QWORD *)((char *)Cx + ((v8 >> 4) & 0xFF0) + 7) ^ Cx[2 * v10] ^ *(_QWORD *)((char *)Cx + ((v9 >> 52) & 0xFF0) + 1);
      v29 = *(_QWORD *)((char *)Cx + ((v12 >> 52) & 0xFF0) + 1) ^ *(_QWORD *)((char *)Cx + ((v49 >> 44) & 0xFF0) + 2) ^ *(_QWORD *)((char *)Cx + ((v14 >> 36) & 0xFF0) + 3) ^ *(_QWORD *)((char *)Cx + ((v56 >> 28) & 0xFF0) + 4) ^ *(_QWORD *)((char *)Cx + ((v55 >> 20) & 0xFF0) + 5) ^ *(_QWORD *)((char *)Cx + ((v54 >> 12) & 0xFF0) + 6) ^ *(_QWORD *)((char *)Cx + ((v18 >> 4) & 0xFF0) + 7) ^ Cx[2 * v19];
      v30 = Cx[2 * v12] ^ *(_QWORD *)((char *)Cx + ((v49 >> 52) & 0xFF0) + 1) ^ *(_QWORD *)((char *)Cx + ((v14 >> 44) & 0xFF0) + 2) ^ *(_QWORD *)((char *)Cx + ((v56 >> 36) & 0xFF0) + 3) ^ *(_QWORD *)((char *)Cx + ((v55 >> 28) & 0xFF0) + 4) ^ *(_QWORD *)((char *)Cx + ((v54 >> 20) & 0xFF0) + 5) ^ *(_QWORD *)((char *)Cx + ((v18 >> 12) & 0xFF0) + 6);
      v31 = *(_QWORD *)((char *)Cx + ((v12 >> 4) & 0xFF0) + 7) ^ Cx[2 * v49] ^ *(_QWORD *)((char *)Cx + ((v14 >> 52) & 0xFF0) + 1) ^ *(_QWORD *)((char *)Cx + ((v56 >> 44) & 0xFF0) + 2) ^ *(_QWORD *)((char *)Cx + ((v55 >> 36) & 0xFF0) + 3) ^ *(_QWORD *)((char *)Cx + ((v54 >> 28) & 0xFF0) + 4) ^ *(_QWORD *)((char *)Cx + ((v18 >> 20) & 0xFF0) + 5) ^ *(_QWORD *)((char *)Cx + ((v19 >> 12) & 0xFF0) + 6);
      v32 = *(_QWORD *)((char *)Cx + ((v12 >> 12) & 0xFF0) + 6) ^ *(_QWORD *)((char *)Cx + ((v49 >> 4) & 0xFF0) + 7) ^ Cx[2 * v14] ^ *(_QWORD *)((char *)Cx + ((v56 >> 52) & 0xFF0) + 1) ^ *(_QWORD *)((char *)Cx + ((v55 >> 44) & 0xFF0) + 2) ^ *(_QWORD *)((char *)Cx + ((v54 >> 36) & 0xFF0) + 3) ^ *(_QWORD *)((char *)Cx + ((v18 >> 28) & 0xFF0) + 4) ^ *(_QWORD *)((char *)Cx + ((v19 >> 20) & 0xFF0) + 5);
      v33 = *(_QWORD *)((char *)Cx + ((v12 >> 20) & 0xFF0) + 5) ^ *(_QWORD *)((char *)Cx + ((v49 >> 12) & 0xFF0) + 6) ^ *(_QWORD *)((char *)Cx + ((v14 >> 4) & 0xFF0) + 7) ^ Cx[2 * v56] ^ *(_QWORD *)((char *)Cx + ((v55 >> 52) & 0xFF0) + 1) ^ *(_QWORD *)((char *)Cx + ((v54 >> 44) & 0xFF0) + 2) ^ *(_QWORD *)((char *)Cx + ((v18 >> 36) & 0xFF0) + 3) ^ *(_QWORD *)((char *)Cx + ((v19 >> 28) & 0xFF0) + 4);
      v34 = *(_QWORD *)((char *)Cx + ((v12 >> 28) & 0xFF0) + 4) ^ *(_QWORD *)((char *)Cx + ((v49 >> 20) & 0xFF0) + 5) ^ *(_QWORD *)((char *)Cx + ((v14 >> 12) & 0xFF0) + 6) ^ *(_QWORD *)((char *)Cx + ((v56 >> 4) & 0xFF0) + 7) ^ Cx[2 * v55] ^ *(_QWORD *)((char *)Cx + ((v54 >> 52) & 0xFF0) + 1) ^ *(_QWORD *)((char *)Cx + ((v18 >> 44) & 0xFF0) + 2) ^ *(_QWORD *)((char *)Cx + ((v19 >> 36) & 0xFF0) + 3);
      v35 = *(_QWORD *)((char *)Cx + ((v12 >> 36) & 0xFF0) + 3) ^ *(_QWORD *)((char *)Cx + ((v49 >> 28) & 0xFF0) + 4) ^ *(_QWORD *)((char *)Cx + ((v14 >> 20) & 0xFF0) + 5) ^ *(_QWORD *)((char *)Cx + ((v56 >> 12) & 0xFF0) + 6) ^ *(_QWORD *)((char *)Cx + ((v55 >> 4) & 0xFF0) + 7) ^ Cx[2 * v54] ^ *(_QWORD *)((char *)Cx + ((v18 >> 52) & 0xFF0) + 1) ^ *(_QWORD *)((char *)Cx + ((v19 >> 44) & 0xFF0) + 2);
      v10 = v50;
      v8 = v51;
      v36 = *(_QWORD *)((char *)Cx + ((v12 >> 44) & 0xFF0) + 2) ^ *(_QWORD *)((char *)Cx + ((v49 >> 36) & 0xFF0) + 3) ^ *(_QWORD *)((char *)Cx + ((v14 >> 28) & 0xFF0) + 4) ^ *(_QWORD *)((char *)Cx + ((v56 >> 20) & 0xFF0) + 5) ^ *(_QWORD *)((char *)Cx + ((v55 >> 12) & 0xFF0) + 6) ^ *(_QWORD *)((char *)Cx + ((v54 >> 4) & 0xFF0) + 7) ^ Cx[2 * v18];
      v37 = v29 ^ v53;
      v12 = v30 ^ *(_QWORD *)((char *)Cx + ((v19 >> 4) & 0xFF0) + 7) ^ v3;
      v13 = v31 ^ v4;
      v14 = v32 ^ v21;
      v15 = v33 ^ v20;
      v7 = v52;
      result = v34 ^ v52;
      v17 = v35 ^ v51;
      v18 = v36 ^ *(_QWORD *)((char *)Cx + ((v19 >> 52) & 0xFF0) + 1) ^ v50;
      v11 = v57 + 8;
      v9 = v53;
      v19 = v37;
    }
    while (v57 != 72);
    v3 = v12 ^ v39;
    *a1 = v12 ^ v39;
    v4 = v46 ^ v47[1] ^ v13;
    a1[1] = v4;
    v5 = v45 ^ v47[2] ^ v14;
    a1[2] = v5;
    v6 = v44 ^ v47[3] ^ v15;
    a1[3] = v6;
    v7 = v43 ^ v47[4] ^ result;
    a1[4] = v7;
    v8 = v42 ^ v47[5] ^ v17;
    a1[5] = v8;
    v10 = v41 ^ v47[6] ^ v18;
    a1[6] = v10;
    v9 = v40 ^ v47[7] ^ v37;
    a1[7] = v9;
    a2 = v47 + 8;
    a3 = v48 - 1;
  }
  while (v48 != 1);
  return result;
}

void RC2_cfb64_encrypt(const unsigned __int8 *in, unsigned __int8 *out, uint64_t length, RC2_KEY *schedule, unsigned __int8 *ivec, int *num, int enc)
{
  uint64_t v10;
  int v13;
  __int128 v14;
  __int128 v15;
  char v16;
  unsigned __int8 v17;
  __int128 v18;
  __int128 v19;
  unsigned __int8 v20;
  unsigned __int8 v21;
  unint64_t v22[3];
  uint64_t v23;

  v10 = length;
  v23 = *MEMORY[0x24BDAC8D0];
  v13 = *num;
  if (enc)
  {
    if (length)
    {
      do
      {
        if (!v13)
        {
          *(_QWORD *)&v14 = *(_QWORD *)ivec;
          *((_QWORD *)&v14 + 1) = HIDWORD(*(_QWORD *)ivec);
          *(_OWORD *)v22 = v14;
          RC2_encrypt(v22, schedule);
          v15 = *(_OWORD *)v22;
          *(_DWORD *)ivec = v22[0];
          *((_DWORD *)ivec + 1) = DWORD2(v15);
        }
        v16 = *in++;
        v17 = ivec[v13];
        *out++ = v17 ^ v16;
        ivec[v13] = v17 ^ v16;
        v13 = (v13 + 1) & 7;
        --v10;
      }
      while (v10);
    }
  }
  else if (length)
  {
    do
    {
      if (!v13)
      {
        *(_QWORD *)&v18 = *(_QWORD *)ivec;
        *((_QWORD *)&v18 + 1) = HIDWORD(*(_QWORD *)ivec);
        *(_OWORD *)v22 = v18;
        RC2_encrypt(v22, schedule);
        v19 = *(_OWORD *)v22;
        *(_DWORD *)ivec = v22[0];
        *((_DWORD *)ivec + 1) = DWORD2(v19);
      }
      v20 = *in++;
      v21 = ivec[v13];
      ivec[v13] = v20;
      *out++ = v21 ^ v20;
      v13 = (v13 + 1) & 7;
      --v10;
    }
    while (v10);
  }
  *num = v13;
}

unint64_t CRYPTO_gcm128_init(uint64_t a1, uint64_t a2, void (*a3)(unsigned int *, unsigned int *, uint64_t))
{
  unsigned int *v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  __int128 v13;
  unint64_t v14;
  uint64_t v15;
  unint64_t v16;
  unint64_t v17;
  uint64_t v18;
  unint64_t result;
  unint64_t v20;
  uint64_t v21;

  *(_OWORD *)(a1 + 352) = 0u;
  *(_OWORD *)(a1 + 368) = 0u;
  *(_OWORD *)(a1 + 320) = 0u;
  *(_OWORD *)(a1 + 336) = 0u;
  *(_OWORD *)(a1 + 288) = 0u;
  *(_OWORD *)(a1 + 304) = 0u;
  *(_OWORD *)(a1 + 256) = 0u;
  *(_OWORD *)(a1 + 272) = 0u;
  *(_OWORD *)(a1 + 224) = 0u;
  *(_OWORD *)(a1 + 240) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 208) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  v4 = (unsigned int *)(a1 + 80);
  *(_QWORD *)(a1 + 376) = a3;
  *(_QWORD *)(a1 + 384) = 0;
  *(_QWORD *)(a1 + 384) = a2;
  a3(v4, v4, a2);
  v5 = *(unsigned __int8 *)(a1 + 87);
  v6 = ((unint64_t)*(unsigned __int8 *)(a1 + 84) << 24) | ((unint64_t)*(unsigned __int8 *)(a1 + 85) << 16) | ((unint64_t)bswap32(*v4) << 32) | ((unint64_t)*(unsigned __int8 *)(a1 + 86) << 8) | v5;
  v7 = bswap32(*(_DWORD *)(a1 + 88));
  v8 = *(unsigned __int8 *)(a1 + 94);
  v9 = *(unsigned __int8 *)(a1 + 95);
  v10 = ((unint64_t)*(unsigned __int8 *)(a1 + 92) << 24) | ((unint64_t)*(unsigned __int8 *)(a1 + 93) << 16);
  *(_QWORD *)v4 = v6;
  v11 = v10 | (v7 << 32) | (v8 << 8) | v9;
  *(_QWORD *)(a1 + 88) = v11;
  *(_QWORD *)(a1 + 96) = 0;
  *((_QWORD *)&v13 + 1) = v5;
  *(_QWORD *)&v13 = v11;
  v12 = v13 >> 1;
  v14 = (v9 << 63 >> 63) & 0xE100000000000000 ^ (v6 >> 1);
  *((_QWORD *)&v13 + 1) = v6 >> 1;
  *(_QWORD *)&v13 = v12;
  v15 = v13 >> 1;
  v16 = (v12 << 63 >> 63) & 0xE100000000000000 ^ (v14 >> 1);
  v17 = (v15 << 63 >> 63) & 0xE100000000000000 ^ (v16 >> 1);
  *(_QWORD *)(a1 + 104) = 0;
  *(_QWORD *)(a1 + 112) = v17;
  *((_QWORD *)&v13 + 1) = v14 >> 1;
  *(_QWORD *)&v13 = v15;
  v18 = v13 >> 1;
  *(_QWORD *)(a1 + 120) = v18;
  *(_QWORD *)(a1 + 128) = v16;
  *(_QWORD *)(a1 + 136) = v15;
  *(_QWORD *)(a1 + 144) = v17 ^ v16;
  *(_QWORD *)(a1 + 152) = v18 ^ v15;
  *(_QWORD *)(a1 + 160) = v14;
  result = v17 ^ v14;
  *(_QWORD *)(a1 + 168) = v12;
  *(_QWORD *)(a1 + 176) = v17 ^ v14;
  *(_QWORD *)(a1 + 184) = v18 ^ v12;
  *(_QWORD *)(a1 + 192) = v16 ^ v14;
  v20 = v17 ^ v16 ^ v14;
  *(_QWORD *)(a1 + 200) = v15 ^ v12;
  *(_QWORD *)(a1 + 208) = v20;
  v21 = v18 ^ v15 ^ v12;
  *(_QWORD *)(a1 + 216) = v21;
  *(_QWORD *)(a1 + 224) = v6;
  *(_QWORD *)(a1 + 232) = v11;
  *(_QWORD *)(a1 + 240) = v17 ^ v6;
  *(_QWORD *)(a1 + 248) = v18 ^ v11;
  *(_QWORD *)(a1 + 256) = v16 ^ v6;
  *(_QWORD *)(a1 + 264) = v15 ^ v11;
  *(_QWORD *)(a1 + 272) = v17 ^ v16 ^ v6;
  *(_QWORD *)(a1 + 280) = v18 ^ v15 ^ v11;
  *(_QWORD *)(a1 + 288) = v14 ^ v6;
  *(_QWORD *)(a1 + 296) = v12 ^ v11;
  *(_QWORD *)(a1 + 304) = v17 ^ v14 ^ v6;
  *(_QWORD *)(a1 + 312) = v18 ^ v12 ^ v11;
  *(_QWORD *)(a1 + 320) = v16 ^ v14 ^ v6;
  *(_QWORD *)(a1 + 328) = v15 ^ v12 ^ v11;
  *(_QWORD *)(a1 + 336) = v20 ^ v6;
  *(_QWORD *)(a1 + 344) = v21 ^ v11;
  return result;
}

uint64_t CRYPTO_gcm128_setiv(uint64_t a1, uint64_t *a2, unint64_t a3)
{
  uint64_t *v3;
  uint64_t v5;
  unsigned int v6;
  unint64_t i;
  uint64_t j;
  uint64_t v10;
  int16x8_t v11;
  int16x8_t v12;
  uint64_t v13;
  uint64_t result;

  v3 = a2;
  *(_QWORD *)(a1 + 368) = 0;
  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  if (a3 != 12)
  {
    if (a3 < 0x10)
    {
      i = a3;
      if (!a3)
      {
LABEL_14:
        v11 = (int16x8_t)vdupq_n_s64(8 * a3);
        v12 = (int16x8_t)vuzp1q_s32((int32x4_t)vshlq_u64((uint64x2_t)v11, (uint64x2_t)xmmword_22D6916D0), (int32x4_t)vshlq_u64((uint64x2_t)v11, (uint64x2_t)xmmword_22D6916C0));
        *(int32x2_t *)v11.i8 = vmovn_s64((int64x2_t)vshlq_u64((uint64x2_t)v11, (uint64x2_t)xmmword_22D6916E0));
        LODWORD(v13) = a3 >> 5;
        HIDWORD(v13) = 8 * a3;
        v11.i64[1] = v13;
        *(int8x8_t *)(a1 + 8) = veor_s8(*(int8x8_t *)(a1 + 8), vmovn_s16(vuzp1q_s16(v12, v11)));
        gcm_gmult_4bit((_BYTE *)a1, a1 + 96);
        v6 = bswap32(*(_DWORD *)(a1 + 12)) + 1;
        goto LABEL_15;
      }
    }
    else
    {
      for (i = a3; i > 0xF; i -= 16)
      {
        for (j = 0; j != 16; ++j)
          *(_BYTE *)(a1 + j) ^= *((_BYTE *)v3 + j);
        gcm_gmult_4bit((_BYTE *)a1, a1 + 96);
        v3 += 2;
      }
      if (!i)
        goto LABEL_14;
    }
    v10 = 0;
    do
    {
      *(_BYTE *)(a1 + v10) ^= *((_BYTE *)v3 + v10);
      ++v10;
    }
    while (i != v10);
    gcm_gmult_4bit((_BYTE *)a1, a1 + 96);
    goto LABEL_14;
  }
  v5 = *a2;
  *(_DWORD *)(a1 + 8) = *((_DWORD *)a2 + 2);
  *(_QWORD *)a1 = v5;
  *(_BYTE *)(a1 + 15) = 1;
  v6 = 2;
LABEL_15:
  result = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD))(a1 + 376))(a1, a1 + 32, *(_QWORD *)(a1 + 384));
  *(_DWORD *)(a1 + 12) = bswap32(v6);
  return result;
}

_BYTE *gcm_gmult_4bit(_BYTE *result, uint64_t a2)
{
  unsigned __int8 v2;
  _QWORD *v3;
  __int128 v4;
  _QWORD *v5;
  unint64_t v6;
  uint64_t v7;
  unint64_t i;
  unsigned __int8 v9;
  uint64_t v10;
  __int128 v11;
  _QWORD *v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;

  v2 = result[15];
  v3 = (_QWORD *)(a2 + 16 * (v2 & 0xF));
  *((_QWORD *)&v4 + 1) = *v3;
  *(_QWORD *)&v4 = v3[1];
  v5 = (_QWORD *)(a2 + (v2 & 0xF0));
  v6 = rem_4bit[v4 & 0xF] ^ (*v3 >> 4) ^ *v5;
  v7 = v5[1] ^ (v4 >> 4);
  for (i = 14; i < 0xFFFFFFFFFFFFFFFELL; --i)
  {
    v9 = result[i];
    v10 = v7 & 0xF;
    *((_QWORD *)&v11 + 1) = v6;
    *(_QWORD *)&v11 = v7;
    v12 = (_QWORD *)(a2 + 16 * (v9 & 0xF));
    v13 = v12[1] ^ (v11 >> 4);
    *((_QWORD *)&v11 + 1) = rem_4bit[v10] ^ (v6 >> 4) ^ *v12;
    *(_QWORD *)&v11 = v13;
    v14 = (_QWORD *)(a2 + (v9 & 0xF0));
    v15 = v14[1];
    v6 = rem_4bit[v13 & 0xF] ^ (*((_QWORD *)&v11 + 1) >> 4) ^ *v14;
    v7 = v15 ^ (v11 >> 4);
  }
  *result = HIBYTE(v6);
  result[1] = BYTE6(v6);
  result[2] = BYTE5(v6);
  result[3] = BYTE4(v6);
  result[4] = BYTE3(v6);
  result[5] = BYTE2(v6);
  result[6] = BYTE1(v6);
  result[7] = v6;
  result[8] = HIBYTE(v7);
  result[9] = BYTE6(v7);
  result[10] = BYTE5(v7);
  result[11] = BYTE4(v7);
  result[12] = BYTE3(v7);
  result[13] = BYTE2(v7);
  result[14] = BYTE1(v7);
  result[15] = v7;
  return result;
}

uint64_t CRYPTO_gcm128_aad(uint64_t a1, char *a2, uint64_t a3)
{
  uint64_t result;
  uint64_t v5;
  BOOL v6;
  unint64_t v7;
  char v8;
  unsigned int v10;
  _BYTE *v11;
  char v12;
  uint64_t v13;
  _BYTE *v14;
  uint64_t v15;
  char v16;

  if (*(_QWORD *)(a1 + 56))
    return 4294967294;
  v5 = *(_QWORD *)(a1 + 48);
  v6 = __CFADD__(v5, a3);
  v7 = v5 + a3;
  v8 = v6;
  result = 0xFFFFFFFFLL;
  if (v7 <= 0x2000000000000000 && (v8 & 1) == 0)
  {
    *(_QWORD *)(a1 + 48) = v7;
    v10 = *(_DWORD *)(a1 + 372);
    if (v10)
    {
      if (!a3)
        goto LABEL_23;
      v11 = (_BYTE *)(a1 + 64);
      do
      {
        v12 = *a2++;
        v11[v10] ^= v12;
        v13 = a3 - 1;
        v10 = ((_BYTE)v10 + 1) & 0xF;
        if (!v10)
          break;
        --a3;
      }
      while (a3);
      if (v10)
      {
LABEL_23:
        result = 0;
        *(_DWORD *)(a1 + 372) = v10;
        return result;
      }
      gcm_gmult_4bit(v11, a1 + 96);
    }
    else
    {
      v13 = a3;
    }
    if ((v13 & 0xFFFFFFFFFFFFFFF0) != 0)
    {
      gcm_ghash_4bit((_BYTE *)(a1 + 64), a1 + 96, (uint64_t)a2, v13 & 0xFFFFFFFFFFFFFFF0);
      a2 += v13 & 0xFFFFFFFFFFFFFFF0;
      v13 &= 0xFu;
    }
    if (v13)
    {
      v14 = (_BYTE *)(a1 + 64);
      v15 = v13;
      do
      {
        v16 = *a2++;
        *v14++ ^= v16;
        --v15;
      }
      while (v15);
      v10 = v13;
    }
    else
    {
      v10 = 0;
    }
    goto LABEL_23;
  }
  return result;
}

_BYTE *gcm_ghash_4bit(_BYTE *result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  unsigned __int8 v5;
  _QWORD *v6;
  __int128 v7;
  _QWORD *v8;
  unint64_t v9;
  unint64_t i;
  unsigned __int8 v11;
  uint64_t v12;
  __int128 v13;
  _QWORD *v14;
  uint64_t v15;
  _QWORD *v16;
  uint64_t v17;

  LOBYTE(v4) = result[15];
  do
  {
    v5 = *(_BYTE *)(a3 + 15) ^ v4;
    v6 = (_QWORD *)(a2 + 16 * (v5 & 0xF));
    *((_QWORD *)&v7 + 1) = *v6;
    *(_QWORD *)&v7 = v6[1];
    v8 = (_QWORD *)(a2 + (v5 & 0xF0));
    v9 = rem_4bit[v7 & 0xF] ^ (*v6 >> 4) ^ *v8;
    v4 = v8[1] ^ (v7 >> 4);
    for (i = 14; i < 0xFFFFFFFFFFFFFFFELL; --i)
    {
      v11 = *(_BYTE *)(a3 + i) ^ result[i];
      v12 = v4 & 0xF;
      *((_QWORD *)&v13 + 1) = v9;
      *(_QWORD *)&v13 = v4;
      v14 = (_QWORD *)(a2 + 16 * (v11 & 0xF));
      v15 = v14[1] ^ (v13 >> 4);
      *((_QWORD *)&v13 + 1) = rem_4bit[v12] ^ (v9 >> 4) ^ *v14;
      *(_QWORD *)&v13 = v15;
      v16 = (_QWORD *)(a2 + (v11 & 0xF0));
      v17 = v16[1];
      v9 = rem_4bit[v15 & 0xF] ^ (*((_QWORD *)&v13 + 1) >> 4) ^ *v16;
      v4 = v17 ^ (v13 >> 4);
    }
    *result = HIBYTE(v9);
    result[1] = BYTE6(v9);
    result[2] = BYTE5(v9);
    result[3] = BYTE4(v9);
    result[4] = BYTE3(v9);
    result[5] = BYTE2(v9);
    result[6] = BYTE1(v9);
    result[7] = v9;
    result[8] = HIBYTE(v4);
    result[9] = BYTE6(v4);
    result[10] = BYTE5(v4);
    result[11] = BYTE4(v4);
    result[12] = BYTE3(v4);
    result[13] = BYTE2(v4);
    result[14] = BYTE1(v4);
    a3 += 16;
    result[15] = v4;
    a4 -= 16;
  }
  while (a4);
  return result;
}

uint64_t CRYPTO_gcm128_encrypt(uint64_t a1, char *a2, _QWORD *a3, unint64_t a4)
{
  uint64_t v5;
  BOOL v6;
  unint64_t v7;
  char v8;
  uint64_t result;
  unint64_t v10;
  uint64_t v13;
  void (*v14)(uint64_t, uint64_t, uint64_t);
  unsigned int v15;
  uint64_t v16;
  _BYTE *v17;
  char v18;
  char v19;
  unint64_t v20;
  unsigned int v21;
  uint64_t v22;
  _QWORD *v23;
  uint64_t v24;
  char v25;
  unint64_t v26;

  v5 = *(_QWORD *)(a1 + 56);
  v6 = __CFADD__(v5, a4);
  v7 = v5 + a4;
  v8 = v6;
  result = 0xFFFFFFFFLL;
  if (v7 <= 0xFFFFFFFE0 && (v8 & 1) == 0)
  {
    v10 = a4;
    v14 = *(void (**)(uint64_t, uint64_t, uint64_t))(a1 + 376);
    v13 = *(_QWORD *)(a1 + 384);
    *(_QWORD *)(a1 + 56) = v7;
    if (*(_DWORD *)(a1 + 372))
    {
      gcm_gmult_4bit((_BYTE *)(a1 + 64), a1 + 96);
      *(_DWORD *)(a1 + 372) = 0;
    }
    v15 = *(_DWORD *)(a1 + 12);
    LODWORD(v16) = *(_DWORD *)(a1 + 368);
    if ((_DWORD)v16)
    {
      if (!v10)
        goto LABEL_28;
      v17 = (_BYTE *)(a1 + 64);
      do
      {
        v18 = *a2++;
        v19 = *(_BYTE *)(a1 + 16 + v16) ^ v18;
        *(_BYTE *)a3 = v19;
        a3 = (_QWORD *)((char *)a3 + 1);
        v17[v16] ^= v19;
        v20 = v10 - 1;
        LODWORD(v16) = ((_BYTE)v16 + 1) & 0xF;
        if (!(_DWORD)v16)
          break;
        --v10;
      }
      while (v10);
      if ((_DWORD)v16)
      {
LABEL_28:
        result = 0;
        *(_DWORD *)(a1 + 368) = v16;
        return result;
      }
      gcm_gmult_4bit(v17, a1 + 96);
    }
    else
    {
      v20 = v10;
    }
    v21 = bswap32(v15);
    if (v20 >= 0xC00)
    {
      do
      {
        v26 = v20;
        v22 = -3072;
        do
        {
          v23 = &a3[(unint64_t)v22 / 8];
          v14(a1, a1 + 16, v13);
          *(_DWORD *)(a1 + 12) = bswap32(++v21);
          v23[384] = *(_QWORD *)(a1 + 16) ^ *(_QWORD *)&a2[v22 + 3072];
          v23[385] = *(_QWORD *)(a1 + 24) ^ *(_QWORD *)&a2[v22 + 3080];
          v22 += 16;
        }
        while (v22);
        gcm_ghash_4bit((_BYTE *)(a1 + 64), a1 + 96, (uint64_t)a3, 3072);
        v20 = v26 - 3072;
        a3 += 384;
        a2 += 3072;
      }
      while (v26 - 3072 > 0xBFF);
    }
    v24 = v20 & 0xFF0;
    if ((v20 & 0xFF0) != 0)
    {
      do
      {
        v14(a1, a1 + 16, v13);
        *(_DWORD *)(a1 + 12) = bswap32(++v21);
        *a3 = *(_QWORD *)(a1 + 16) ^ *(_QWORD *)a2;
        a3[1] = *(_QWORD *)(a1 + 24) ^ *((_QWORD *)a2 + 1);
        a3 += 2;
        a2 += 16;
        v20 -= 16;
      }
      while (v20 > 0xF);
      gcm_ghash_4bit((_BYTE *)(a1 + 64), a1 + 96, (uint64_t)a3 - v24, v24);
    }
    if (v20)
    {
      v14(a1, a1 + 16, v13);
      v16 = 0;
      *(_DWORD *)(a1 + 12) = bswap32(v21 + 1);
      do
      {
        v25 = *(_BYTE *)(a1 + 16 + v16) ^ a2[v16];
        *((_BYTE *)a3 + v16) = v25;
        *(_BYTE *)(a1 + 64 + v16++) ^= v25;
      }
      while (v20 != v16);
    }
    else
    {
      LODWORD(v16) = 0;
    }
    goto LABEL_28;
  }
  return result;
}

uint64_t CRYPTO_gcm128_decrypt(uint64_t a1, char *a2, _QWORD *a3, unint64_t a4)
{
  uint64_t v5;
  BOOL v6;
  unint64_t v7;
  char v8;
  uint64_t result;
  unint64_t v10;
  uint64_t v13;
  void (*v14)(uint64_t, uint64_t, uint64_t);
  unsigned int v15;
  uint64_t v16;
  _BYTE *v17;
  char v18;
  unint64_t v19;
  unsigned int v20;
  uint64_t i;
  _QWORD *v22;
  uint64_t v23;
  char v24;
  unint64_t v25;

  v5 = *(_QWORD *)(a1 + 56);
  v6 = __CFADD__(v5, a4);
  v7 = v5 + a4;
  v8 = v6;
  result = 0xFFFFFFFFLL;
  if (v7 <= 0xFFFFFFFE0 && (v8 & 1) == 0)
  {
    v10 = a4;
    v14 = *(void (**)(uint64_t, uint64_t, uint64_t))(a1 + 376);
    v13 = *(_QWORD *)(a1 + 384);
    *(_QWORD *)(a1 + 56) = v7;
    if (*(_DWORD *)(a1 + 372))
    {
      gcm_gmult_4bit((_BYTE *)(a1 + 64), a1 + 96);
      *(_DWORD *)(a1 + 372) = 0;
    }
    v15 = *(_DWORD *)(a1 + 12);
    LODWORD(v16) = *(_DWORD *)(a1 + 368);
    if ((_DWORD)v16)
    {
      if (!v10)
        goto LABEL_28;
      v17 = (_BYTE *)(a1 + 64);
      do
      {
        v18 = *a2++;
        *(_BYTE *)a3 = *(_BYTE *)(a1 + 16 + v16) ^ v18;
        a3 = (_QWORD *)((char *)a3 + 1);
        v17[v16] ^= v18;
        v19 = v10 - 1;
        LODWORD(v16) = ((_BYTE)v16 + 1) & 0xF;
        if (!(_DWORD)v16)
          break;
        --v10;
      }
      while (v10);
      if ((_DWORD)v16)
      {
LABEL_28:
        result = 0;
        *(_DWORD *)(a1 + 368) = v16;
        return result;
      }
      gcm_gmult_4bit(v17, a1 + 96);
    }
    else
    {
      v19 = v10;
    }
    v20 = bswap32(v15);
    if (v19 >= 0xC00)
    {
      do
      {
        v25 = v19;
        gcm_ghash_4bit((_BYTE *)(a1 + 64), a1 + 96, (uint64_t)a2, 3072);
        for (i = 0; i != 384; i += 2)
        {
          v22 = &a3[i];
          v14(a1, a1 + 16, v13);
          *(_DWORD *)(a1 + 12) = bswap32(++v20);
          *v22 = *(_QWORD *)(a1 + 16) ^ *(_QWORD *)&a2[i * 8];
          v22[1] = *(_QWORD *)(a1 + 24) ^ *(_QWORD *)&a2[i * 8 + 8];
        }
        v19 = v25 - 3072;
        a2 += 3072;
        a3 += 384;
      }
      while (v25 - 3072 > 0xBFF);
    }
    v23 = v19 & 0xFF0;
    if ((v19 & 0xFF0) != 0)
    {
      gcm_ghash_4bit((_BYTE *)(a1 + 64), a1 + 96, (uint64_t)a2, v23);
      do
      {
        v14(a1, a1 + 16, v13);
        *(_DWORD *)(a1 + 12) = bswap32(++v20);
        *a3 = *(_QWORD *)(a1 + 16) ^ *(_QWORD *)a2;
        a3[1] = *(_QWORD *)(a1 + 24) ^ *((_QWORD *)a2 + 1);
        a3 += 2;
        a2 += 16;
        v19 -= 16;
      }
      while (v19 > 0xF);
    }
    if (v19)
    {
      ((void (*)(uint64_t, uint64_t, uint64_t, uint64_t))v14)(a1, a1 + 16, v13, v23);
      v16 = 0;
      *(_DWORD *)(a1 + 12) = bswap32(v20 + 1);
      do
      {
        v24 = a2[v16];
        *(_BYTE *)(a1 + 64 + v16) ^= v24;
        *((_BYTE *)a3 + v16) = *(_BYTE *)(a1 + 16 + v16) ^ v24;
        ++v16;
      }
      while (v19 != v16);
    }
    else
    {
      LODWORD(v16) = 0;
    }
    goto LABEL_28;
  }
  return result;
}

uint64_t CRYPTO_gcm128_encrypt_ctr32(uint64_t a1, char *a2, _BYTE *a3, unint64_t a4, void (*a5)(char *, _BYTE *, uint64_t, uint64_t, uint64_t))
{
  uint64_t v6;
  BOOL v7;
  unint64_t v8;
  char v9;
  uint64_t result;
  unint64_t v12;
  uint64_t v15;
  unsigned int v16;
  uint64_t v17;
  _BYTE *v18;
  char v19;
  char v20;
  unint64_t v21;
  unsigned int v22;
  uint64_t v23;
  char v24;

  v6 = *(_QWORD *)(a1 + 56);
  v7 = __CFADD__(v6, a4);
  v8 = v6 + a4;
  v9 = v7;
  result = 0xFFFFFFFFLL;
  if (v8 <= 0xFFFFFFFE0 && (v9 & 1) == 0)
  {
    v12 = a4;
    v15 = *(_QWORD *)(a1 + 384);
    *(_QWORD *)(a1 + 56) = v8;
    if (*(_DWORD *)(a1 + 372))
    {
      gcm_gmult_4bit((_BYTE *)(a1 + 64), a1 + 96);
      *(_DWORD *)(a1 + 372) = 0;
    }
    v16 = *(_DWORD *)(a1 + 12);
    LODWORD(v17) = *(_DWORD *)(a1 + 368);
    if ((_DWORD)v17)
    {
      if (!v12)
        goto LABEL_25;
      v18 = (_BYTE *)(a1 + 64);
      do
      {
        v19 = *a2++;
        v20 = *(_BYTE *)(a1 + 16 + v17) ^ v19;
        *a3++ = v20;
        v18[v17] ^= v20;
        v21 = v12 - 1;
        LODWORD(v17) = ((_BYTE)v17 + 1) & 0xF;
        if (!(_DWORD)v17)
          break;
        --v12;
      }
      while (v12);
      if ((_DWORD)v17)
      {
LABEL_25:
        result = 0;
        *(_DWORD *)(a1 + 368) = v17;
        return result;
      }
      gcm_gmult_4bit(v18, a1 + 96);
    }
    else
    {
      v21 = v12;
    }
    v22 = bswap32(v16);
    if (v21 >= 0xC00)
    {
      do
      {
        a5(a2, a3, 192, v15, a1);
        v22 += 192;
        *(_DWORD *)(a1 + 12) = bswap32(v22);
        gcm_ghash_4bit((_BYTE *)(a1 + 64), a1 + 96, (uint64_t)a3, 3072);
        a3 += 3072;
        a2 += 3072;
        v21 -= 3072;
      }
      while (v21 > 0xBFF);
    }
    v23 = v21 & 0xFF0;
    if ((v21 & 0xFF0) != 0)
    {
      a5(a2, a3, v21 >> 4, v15, a1);
      v22 += v21 >> 4;
      *(_DWORD *)(a1 + 12) = bswap32(v22);
      a2 += v23;
      v21 &= 0xFu;
      gcm_ghash_4bit((_BYTE *)(a1 + 64), a1 + 96, (uint64_t)a3, v23);
      a3 += v23;
    }
    if (v21)
    {
      (*(void (**)(uint64_t, uint64_t, uint64_t))(a1 + 376))(a1, a1 + 16, v15);
      v17 = 0;
      *(_DWORD *)(a1 + 12) = bswap32(v22 + 1);
      do
      {
        v24 = *(_BYTE *)(a1 + 16 + v17) ^ a2[v17];
        a3[v17] = v24;
        *(_BYTE *)(a1 + 64 + v17++) ^= v24;
      }
      while (v21 != v17);
    }
    else
    {
      LODWORD(v17) = 0;
    }
    goto LABEL_25;
  }
  return result;
}

uint64_t CRYPTO_gcm128_decrypt_ctr32(uint64_t a1, char *a2, _BYTE *a3, unint64_t a4, void (*a5)(char *, _BYTE *, uint64_t, uint64_t, uint64_t))
{
  uint64_t v6;
  BOOL v7;
  unint64_t v8;
  char v9;
  uint64_t result;
  unint64_t v12;
  uint64_t v15;
  unsigned int v16;
  uint64_t v17;
  _BYTE *v18;
  char v19;
  unint64_t v20;
  unsigned int v21;
  unint64_t v22;
  char v23;

  v6 = *(_QWORD *)(a1 + 56);
  v7 = __CFADD__(v6, a4);
  v8 = v6 + a4;
  v9 = v7;
  result = 0xFFFFFFFFLL;
  if (v8 <= 0xFFFFFFFE0 && (v9 & 1) == 0)
  {
    v12 = a4;
    v15 = *(_QWORD *)(a1 + 384);
    *(_QWORD *)(a1 + 56) = v8;
    if (*(_DWORD *)(a1 + 372))
    {
      gcm_gmult_4bit((_BYTE *)(a1 + 64), a1 + 96);
      *(_DWORD *)(a1 + 372) = 0;
    }
    v16 = *(_DWORD *)(a1 + 12);
    LODWORD(v17) = *(_DWORD *)(a1 + 368);
    if ((_DWORD)v17)
    {
      if (!v12)
        goto LABEL_25;
      v18 = (_BYTE *)(a1 + 64);
      do
      {
        v19 = *a2++;
        *a3++ = *(_BYTE *)(a1 + 16 + v17) ^ v19;
        v18[v17] ^= v19;
        v20 = v12 - 1;
        LODWORD(v17) = ((_BYTE)v17 + 1) & 0xF;
        if (!(_DWORD)v17)
          break;
        --v12;
      }
      while (v12);
      if ((_DWORD)v17)
      {
LABEL_25:
        result = 0;
        *(_DWORD *)(a1 + 368) = v17;
        return result;
      }
      gcm_gmult_4bit(v18, a1 + 96);
    }
    else
    {
      v20 = v12;
    }
    v21 = bswap32(v16);
    if (v20 >= 0xC00)
    {
      do
      {
        gcm_ghash_4bit((_BYTE *)(a1 + 64), a1 + 96, (uint64_t)a2, 3072);
        a5(a2, a3, 192, v15, a1);
        v21 += 192;
        *(_DWORD *)(a1 + 12) = bswap32(v21);
        a3 += 3072;
        a2 += 3072;
        v20 -= 3072;
      }
      while (v20 > 0xBFF);
    }
    v22 = v20 & 0xFF0;
    if ((v20 & 0xFF0) != 0)
    {
      gcm_ghash_4bit((_BYTE *)(a1 + 64), a1 + 96, (uint64_t)a2, v20 & 0xFF0);
      a5(a2, a3, v20 >> 4, v15, a1);
      v21 += v20 >> 4;
      *(_DWORD *)(a1 + 12) = bswap32(v21);
      a3 += v22;
      a2 += v22;
      v20 &= 0xFu;
    }
    if (v20)
    {
      (*(void (**)(uint64_t, uint64_t, uint64_t))(a1 + 376))(a1, a1 + 16, v15);
      v17 = 0;
      *(_DWORD *)(a1 + 12) = bswap32(v21 + 1);
      do
      {
        v23 = a2[v17];
        *(_BYTE *)(a1 + 64 + v17) ^= v23;
        a3[v17] = *(_BYTE *)(a1 + 16 + v17) ^ v23;
        ++v17;
      }
      while (v20 != v17);
    }
    else
    {
      LODWORD(v17) = 0;
    }
    goto LABEL_25;
  }
  return result;
}

uint64_t CRYPTO_gcm128_finish(uint64_t a1, const void *a2, size_t a3)
{
  int64x2_t v6;
  uint64x2_t v7;
  int8x16_t *v8;
  int8x16_t v9;
  int8x16_t v10;
  int8x16_t v11;
  int64x2_t v13;
  uint64x2_t v14;

  v6 = *(int64x2_t *)(a1 + 48);
  v7 = (uint64x2_t)vshlq_n_s64(v6, 3uLL);
  if (*(_DWORD *)(a1 + 368) || *(_DWORD *)(a1 + 372))
  {
    v13 = *(int64x2_t *)(a1 + 48);
    v14 = v7;
    gcm_gmult_4bit((_BYTE *)(a1 + 64), a1 + 96);
    v6 = v13;
    v7 = v14;
  }
  v9 = *(int8x16_t *)(a1 + 64);
  v8 = (int8x16_t *)(a1 + 64);
  v8[-1] = (int8x16_t)v7;
  v10.i64[0] = 65280;
  v10.i64[1] = 65280;
  v11.i64[0] = 255;
  v11.i64[1] = 255;
  *v8 = veorq_s8(v9, vorrq_s8(vorrq_s8(vorrq_s8(vorrq_s8(vandq_s8((int8x16_t)vshlq_u64(v7, (uint64x2_t)xmmword_22D691710), (int8x16_t)xmmword_22D691760), vandq_s8((int8x16_t)vshlq_u64(v7, (uint64x2_t)xmmword_22D691720), (int8x16_t)xmmword_22D691750)), vandq_s8((int8x16_t)vshrq_n_u64(v7, 0x28uLL), v10)), (int8x16_t)vshrq_n_u64(v7, 0x38uLL)), (int8x16_t)vshlq_n_s64((int64x2_t)vorrq_s8(vorrq_s8(vandq_s8((int8x16_t)vshlq_u64((uint64x2_t)v6, (uint64x2_t)xmmword_22D6916F0), (int8x16_t)xmmword_22D691740), vandq_s8((int8x16_t)vshlq_u64((uint64x2_t)v6, (uint64x2_t)xmmword_22D691700), (int8x16_t)xmmword_22D691730)), vorrq_s8(
                                        vandq_s8((int8x16_t)vshrq_n_u64(v7, 8uLL), v10),
                                        vandq_s8((int8x16_t)vshrq_n_u64(v7, 0x18uLL), v11))),
                         0x20uLL)));
  gcm_gmult_4bit(v8, (uint64_t)v8[2].i64);
  *v8 = veorq_s8(*v8, v8[-2]);
  if (a2 && a3 <= 0x10)
    return memcmp(v8, a2, a3);
  else
    return 0xFFFFFFFFLL;
}

void *CRYPTO_gcm128_tag(uint64_t a1, void *a2, unint64_t a3)
{
  size_t v6;

  CRYPTO_gcm128_finish(a1, 0, 0);
  if (a3 >= 0x10)
    v6 = 16;
  else
    v6 = a3;
  return memcpy(a2, (const void *)(a1 + 64), v6);
}

void *CRYPTO_gcm128_new(uint64_t a1, void (*a2)(unsigned int *, unsigned int *, uint64_t))
{
  void *v4;
  void *v5;

  v4 = malloc_type_malloc(0x188uLL, 0x1080040DB0FD529uLL);
  v5 = v4;
  if (v4)
    CRYPTO_gcm128_init((uint64_t)v4, a1, a2);
  return v5;
}

void CRYPTO_gcm128_release(void *a1)
{
  freezero(a1, 0x188uLL);
}

STACK *i2v_EXTENDED_KEY_USAGE(int a1, STACK *a2, STACK *a3)
{
  STACK *v4;
  STACK *v5;
  int v6;
  char *v7;
  STACK *v9;
  char buf[80];
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  v9 = a3;
  if (a3)
  {
    v4 = a3;
    v5 = 0;
  }
  else
  {
    v4 = sk_new_null();
    v9 = v4;
    v5 = v4;
    if (!v4)
      return v4;
  }
  if (sk_num(a2) >= 1)
  {
    v6 = 0;
    while (1)
    {
      v7 = sk_value(a2, v6);
      if (!v7 || !i2t_ASN1_OBJECT(buf, 80, (ASN1_OBJECT *)v7) || !X509V3_add_value(0, buf, &v9))
        break;
      if (++v6 >= sk_num(a2))
        return v9;
    }
    sk_pop_free(v5, (void (__cdecl *)(void *))X509V3_conf_free);
    return 0;
  }
  return v4;
}

STACK *v2i_EXTENDED_KEY_USAGE(uint64_t a1, uint64_t a2, const STACK *a3)
{
  STACK *v4;
  int v5;
  char *v6;
  const char *v7;
  char *v8;
  ASN1_OBJECT *v9;

  v4 = sk_new_null();
  if (v4)
  {
    if (sk_num(a3) >= 1)
    {
      v5 = 0;
      while (1)
      {
        v6 = sk_value(a3, v5);
        v7 = (const char *)*((_QWORD *)v6 + 2);
        if (!v7)
          v7 = (const char *)*((_QWORD *)v6 + 1);
        v8 = (char *)OBJ_txt2obj(v7, 0);
        if (!v8)
        {
          sk_pop_free(v4, (void (__cdecl *)(void *))ASN1_OBJECT_free);
          ERR_put_error(34, 4095, 110, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_extku.c", 209);
          ERR_asprintf_error_data("section:%s,name:%s,value:%s", *(const char **)v6, *((const char **)v6 + 1), *((const char **)v6 + 2));
          return 0;
        }
        v9 = (ASN1_OBJECT *)v8;
        if (!sk_push(v4, v8))
          break;
        if (++v5 >= sk_num(a3))
          return v4;
      }
      ASN1_OBJECT_free(v9);
      sk_pop_free(v4, (void (__cdecl *)(void *))ASN1_OBJECT_free);
      ERR_put_error(34, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_extku.c", 216);
      return 0;
    }
  }
  else
  {
    ERR_put_error(34, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_extku.c", 197);
  }
  return v4;
}

EXTENDED_KEY_USAGE *__cdecl d2i_EXTENDED_KEY_USAGE(EXTENDED_KEY_USAGE **a, const unsigned __int8 **in, uint64_t len)
{
  return (EXTENDED_KEY_USAGE *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &EXTENDED_KEY_USAGE_it);
}

int i2d_EXTENDED_KEY_USAGE(EXTENDED_KEY_USAGE *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &EXTENDED_KEY_USAGE_it);
}

EXTENDED_KEY_USAGE *EXTENDED_KEY_USAGE_new(void)
{
  return (EXTENDED_KEY_USAGE *)ASN1_item_new(&EXTENDED_KEY_USAGE_it);
}

void EXTENDED_KEY_USAGE_free(EXTENDED_KEY_USAGE *a)
{
  ASN1_item_free((ASN1_VALUE *)a, &EXTENDED_KEY_USAGE_it);
}

int asn1_get_choice_selector(ASN1_VALUE **pval, const ASN1_ITEM *it)
{
  return *(_DWORD *)((char *)*pval + it->utype);
}

int asn1_set_choice_selector(ASN1_VALUE **pval, int value, const ASN1_ITEM *it)
{
  ASN1_VALUE *v3;
  uint64_t utype;
  int result;

  v3 = *pval;
  utype = it->utype;
  result = *(_DWORD *)((char *)*pval + utype);
  *(_DWORD *)((char *)v3 + utype) = value;
  return result;
}

int asn1_do_lock(ASN1_VALUE **pval, int op, const ASN1_ITEM *it)
{
  int itype;
  int *funcs;
  int result;
  uint64_t v7;
  _DWORD *v8;

  itype = it->itype;
  if (itype != 6 && itype != 1)
    return 0;
  funcs = (int *)it->funcs;
  if (!funcs || (funcs[2] & 1) == 0)
    return 0;
  v7 = funcs[3];
  v8 = (_DWORD *)((char *)*pval + v7);
  if (op)
    return CRYPTO_add_lock((int *)((char *)*pval + v7), op, funcs[4], 0, 0);
  result = 1;
  *v8 = 1;
  return result;
}

void asn1_enc_init(ASN1_VALUE **pval, const ASN1_ITEM *it)
{
  int *funcs;
  BOOL v3;
  char *v4;

  if (pval)
  {
    funcs = (int *)it->funcs;
    if (*pval)
      v3 = funcs == 0;
    else
      v3 = 1;
    if (!v3 && (funcs[2] & 2) != 0)
    {
      v4 = (char *)*pval + funcs[8];
      *(_QWORD *)v4 = 0;
      *((_QWORD *)v4 + 1) = 0;
      *((_DWORD *)v4 + 4) = 1;
    }
  }
}

void asn1_enc_cleanup(_QWORD *a1, uint64_t a2)
{
  uint64_t v2;
  BOOL v3;
  uint64_t v4;

  if (a1)
  {
    v2 = *(_QWORD *)(a2 + 32);
    if (*a1)
      v3 = v2 == 0;
    else
      v3 = 1;
    if (!v3 && (*(_BYTE *)(v2 + 8) & 2) != 0)
    {
      v4 = *a1 + *(int *)(v2 + 32);
      freezero(*(void **)v4, *(_QWORD *)(v4 + 8));
      *(_QWORD *)v4 = 0;
      *(_QWORD *)(v4 + 8) = 0;
      *(_DWORD *)(v4 + 16) = 1;
    }
  }
}

int asn1_enc_save(ASN1_VALUE **pval, const unsigned __int8 *in, int inlen, const ASN1_ITEM *it)
{
  uint64_t v4;
  int v6;
  char *v9;
  size_t v10;
  size_t v11;
  void *v12;

  v11 = 0;
  v12 = 0;
  if (!pval)
    return 1;
  v4 = *(_QWORD *)(*(_QWORD *)&inlen + 32);
  if (!*pval || v4 == 0)
    return 1;
  v6 = 1;
  if ((*(_BYTE *)(v4 + 8) & 2) != 0)
  {
    v9 = (char *)*pval + *(int *)(v4 + 32);
    freezero(*(void **)v9, *((_QWORD *)v9 + 1));
    *(_QWORD *)v9 = 0;
    *((_QWORD *)v9 + 1) = 0;
    *((_DWORD *)v9 + 4) = 1;
    if (CBS_stow((uint64_t)in, &v12, &v11))
    {
      v10 = v11;
      if ((v11 & 0x8000000000000000) == 0)
      {
        *(_QWORD *)v9 = v12;
        *((_QWORD *)v9 + 1) = v10;
        *((_DWORD *)v9 + 4) = 0;
        return v6;
      }
      freezero(v12, v11);
    }
    return 0;
  }
  return v6;
}

int asn1_enc_restore(int *len, unsigned __int8 **out, ASN1_VALUE **pval, const ASN1_ITEM *it)
{
  int *funcs;
  BOOL v5;
  char *v6;

  if (!pval)
    return 0;
  funcs = (int *)it->funcs;
  if (*pval)
    v5 = funcs == 0;
  else
    v5 = 1;
  if (v5)
    return 0;
  if ((funcs[2] & 2) == 0)
    return 0;
  v6 = (char *)*pval + funcs[8];
  if (*((_DWORD *)v6 + 4))
    return 0;
  if (out)
  {
    memcpy(*out, *(const void **)v6, *((_QWORD *)v6 + 1));
    *out += *((_QWORD *)v6 + 1);
  }
  if (len)
    *len = *((_QWORD *)v6 + 1);
  return 1;
}

ASN1_VALUE **__cdecl asn1_get_field_ptr(ASN1_VALUE **pval, const ASN1_TEMPLATE *tt)
{
  return (ASN1_VALUE **)((char *)*pval + tt->offset);
}

const ASN1_TEMPLATE *__cdecl asn1_do_adb(ASN1_VALUE **pval, const ASN1_TEMPLATE *tt, int nullerr)
{
  ASN1_ITEM_EXP *item;
  ASN1_OBJECT *v5;
  uint64_t v6;
  uint64_t tcount;

  if ((tt->flags & 0x300) == 0)
    return tt;
  item = tt->item;
  if (!*pval)
  {
    tt = (const ASN1_TEMPLATE *)item->size;
    if (tt)
      return tt;
    goto LABEL_13;
  }
  v5 = *(ASN1_OBJECT **)((char *)*pval + item->utype);
  if ((tt->flags & 0x100) != 0)
    v6 = OBJ_obj2nid(v5);
  else
    v6 = ASN1_INTEGER_get((ASN1_INTEGER *)v5);
  tcount = item->tcount;
  if (tcount < 1)
  {
LABEL_12:
    tt = (const ASN1_TEMPLATE *)item->funcs;
    if (tt)
      return tt;
LABEL_13:
    if (nullerr)
      ERR_put_error(13, 4095, 164, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/tasn_utl.c", 297);
    return 0;
  }
  tt = (const ASN1_TEMPLATE *)&item->templates->tag;
  while (tt[-1].item != (ASN1_ITEM_EXP *)v6)
  {
    tt = (const ASN1_TEMPLATE *)((char *)tt + 48);
    if (!--tcount)
      goto LABEL_12;
  }
  return tt;
}

uint64_t SM4_set_key(unsigned int *a1, uint64_t a2)
{
  uint64_t v2;
  unsigned int v3;
  unsigned int v4;
  unint64_t v5;
  int v6;
  unint64_t v7;
  _DWORD v9[4];
  uint64_t v10;

  v2 = 0;
  v10 = *MEMORY[0x24BDAC8D0];
  v3 = bswap32(a1[1]);
  v9[0] = bswap32(*a1) ^ 0xA3B1BAC6;
  v9[1] = v3 ^ 0x56AA3350;
  v4 = bswap32(a1[3]);
  v9[2] = bswap32(a1[2]) ^ 0x677D9197;
  v9[3] = v4 ^ 0xB27022DC;
  do
  {
    v5 = v9[((_BYTE)v2 + 2) & 3] ^ v9[(v2 + 1) & 3] ^ (v9[((_BYTE)v2 - 1) & 3] ^ SM4_set_key_CK[v2]);
    v6 = (SM4_S[v5 >> 24] << 24) | (SM4_S[BYTE2(v5)] << 16);
    LODWORD(v5) = SM4_S[LOBYTE(v9[((_BYTE)v2 + 2) & 3]) ^ LOBYTE(v9[(v2 + 1) & 3]) ^ LOBYTE(v9[((_BYTE)v2 - 1) & 3]) ^ LOBYTE(SM4_set_key_CK[v2])] | (SM4_S[BYTE1(v5)] << 8);
    HIDWORD(v7) = v5 | v6;
    LODWORD(v7) = v6;
    LODWORD(v5) = v9[v2 & 3] ^ (v7 >> 19) ^ (__PAIR64__(v5, v5 | v6) >> 9) ^ (v5 | v6);
    v9[v2 & 3] = v5;
    *(_DWORD *)(a2 + 4 * v2++) = v5;
  }
  while (v2 != 32);
  return 1;
}

uint64_t SM4_encrypt(unsigned int *a1, _BYTE *a2, _DWORD *a3)
{
  unsigned int v3;
  unsigned int v4;
  unsigned int v5;
  unsigned int v6;
  unint64_t v7;
  unsigned int v8;
  int v9;
  int v10;
  int v11;
  unint64_t v12;
  int v13;
  unint64_t v14;
  int v15;
  int v16;
  int v17;
  int v18;
  int v19;
  unint64_t v20;
  unsigned int v21;
  int v22;
  int v23;
  int v24;
  int v25;
  int v26;
  unsigned int v27;
  unint64_t v28;
  int v29;
  int v30;
  int v31;
  unsigned int v32;
  int v33;
  int v34;
  unsigned int v35;
  int v36;
  int v37;
  int v38;
  unsigned int v39;
  int v40;
  int v41;
  int v42;
  unsigned int v43;
  int v44;
  int v45;
  int v46;
  unsigned int v47;
  int v48;
  int v49;
  int v50;
  unsigned int v51;
  int v52;
  int v53;
  int v54;
  unsigned int v55;
  int v56;
  unsigned int v57;
  unint64_t v58;
  unsigned int v59;
  int v60;
  int v61;
  int v62;
  unsigned int v63;
  unint64_t v64;
  int v65;
  int v66;
  int v67;
  int v68;
  int v69;
  int v70;
  unint64_t v71;
  unsigned int v72;
  int v73;
  int v74;
  unsigned int v75;
  int v76;
  uint64_t result;
  unsigned int v78;
  unint64_t v79;
  int v80;
  unsigned int v81;
  int v82;

  v3 = bswap32(*a1);
  v4 = bswap32(a1[1]);
  v5 = bswap32(a1[2]);
  v6 = bswap32(a1[3]);
  v7 = v5 ^ *a3 ^ v6 ^ v4;
  v8 = SM4_S[v7 >> 24];
  v9 = SM4_S[(v5 ^ *(_BYTE *)a3 ^ v6 ^ v4)] | (SM4_S[BYTE1(v7)] << 8);
  v10 = v9 | (v8 << 24) | (SM4_S[BYTE2(v7)] << 16);
  HIDWORD(v12) = v10;
  LODWORD(v12) = (v8 << 24) | (SM4_S[BYTE2(v7)] << 16);
  v11 = v12 >> 22;
  HIDWORD(v12) = SM4_S[(v5 ^ *(_BYTE *)a3 ^ v6 ^ v4)];
  LODWORD(v12) = v10;
  v13 = v3 ^ v11 ^ (__PAIR64__(v9, v10) >> 14) ^ (v12 >> 8) ^ ((v8 >> 6) | (4 * v10)) ^ v10;
  v14 = v5 ^ a3[1] ^ v6 ^ v13;
  LODWORD(v7) = SM4_S[v14 >> 24];
  v15 = ((_DWORD)v7 << 24) | (SM4_S[BYTE2(v14)] << 16);
  v16 = SM4_S[(v5 ^ *((_BYTE *)a3 + 4) ^ v6 ^ v13)] | (SM4_S[BYTE1(v14)] << 8);
  v17 = v16 | v15;
  LODWORD(v7) = (v7 >> 6) | (4 * (v16 | v15));
  HIDWORD(v12) = v16 | v15;
  LODWORD(v12) = v15;
  v18 = v12 >> 22;
  HIDWORD(v12) = SM4_S[(v5 ^ *((_BYTE *)a3 + 4) ^ v6 ^ v13)];
  LODWORD(v12) = v17;
  v19 = (__PAIR64__(v16, v17) >> 14) ^ v18 ^ (v12 >> 8) ^ v7 ^ v4 ^ v17;
  v20 = a3[2] ^ v6 ^ v19 ^ v13;
  v21 = SM4_S[v20 >> 24];
  v22 = (v21 << 24) | (SM4_S[BYTE2(v20)] << 16);
  v23 = SM4_S[(*((_BYTE *)a3 + 8) ^ v6 ^ v19 ^ v13)] | (SM4_S[BYTE1(v20)] << 8);
  v24 = v23 | v22;
  v25 = (v21 >> 6) | (4 * (v23 | v22));
  HIDWORD(v12) = v23 | v22;
  LODWORD(v12) = v22;
  v26 = v12 >> 22;
  HIDWORD(v12) = SM4_S[(*((_BYTE *)a3 + 8) ^ v6 ^ v19 ^ v13)];
  LODWORD(v12) = v24;
  v27 = (__PAIR64__(v23, v24) >> 14) ^ v26 ^ (v12 >> 8) ^ v25 ^ v5 ^ v24;
  v28 = v19 ^ v13 ^ a3[3] ^ v27;
  LODWORD(v20) = SM4_S[v28 >> 24];
  v29 = SM4_S[(v19 ^ v13 ^ *((_BYTE *)a3 + 12) ^ v27)] | (SM4_S[BYTE1(v28)] << 8);
  v30 = v29 | ((_DWORD)v20 << 24) | (SM4_S[BYTE2(v28)] << 16);
  HIDWORD(v12) = v30;
  LODWORD(v12) = ((_DWORD)v20 << 24) | (SM4_S[BYTE2(v28)] << 16);
  v31 = v12 >> 22;
  HIDWORD(v12) = SM4_S[(v19 ^ v13 ^ *((_BYTE *)a3 + 12) ^ v27)];
  LODWORD(v12) = v30;
  LODWORD(v28) = (__PAIR64__(v29, v30) >> 14) ^ v31 ^ (v12 >> 8) ^ ((v20 >> 6) | (4 * v30)) ^ v6 ^ v30;
  v32 = v27 ^ a3[4] ^ v19 ^ v28;
  v33 = SM4_SBOX_T[HIBYTE(v32)] ^ __ROR4__(SM4_SBOX_T[BYTE2(v32)], 8) ^ __ROR4__(SM4_SBOX_T[BYTE1(v32)], 16) ^ __ROR4__(SM4_SBOX_T[(v27 ^ *((_BYTE *)a3 + 16) ^ v19 ^ v28)], 24) ^ v13;
  LODWORD(v20) = v27 ^ a3[5] ^ v28 ^ v33;
  v34 = SM4_SBOX_T[BYTE3(v20)] ^ __ROR4__(SM4_SBOX_T[BYTE2(v20)], 8) ^ __ROR4__(SM4_SBOX_T[BYTE1(v20)], 16) ^ __ROR4__(SM4_SBOX_T[(v27 ^ *((_BYTE *)a3 + 20) ^ v28 ^ v33)], 24) ^ v19;
  v35 = a3[6] ^ v28 ^ v34 ^ v33;
  v36 = SM4_SBOX_T[HIBYTE(v35)] ^ __ROR4__(SM4_SBOX_T[BYTE2(v35)], 8) ^ __ROR4__(SM4_SBOX_T[BYTE1(v35)], 16) ^ __ROR4__(SM4_SBOX_T[(*((_BYTE *)a3 + 24) ^ v28 ^ v34 ^ v33)], 24) ^ v27;
  LODWORD(v20) = a3[7] ^ v34 ^ v33 ^ v36;
  LODWORD(v28) = SM4_SBOX_T[BYTE3(v20)] ^ __ROR4__(SM4_SBOX_T[BYTE2(v20)], 8) ^ __ROR4__(SM4_SBOX_T[BYTE1(v20)], 16) ^ __ROR4__(SM4_SBOX_T[(*((_BYTE *)a3 + 28) ^ v34 ^ v33 ^ v36)], 24) ^ v28;
  LODWORD(v20) = v36 ^ a3[8] ^ v34 ^ v28;
  v37 = SM4_SBOX_T[BYTE3(v20)] ^ __ROR4__(SM4_SBOX_T[BYTE2(v20)], 8) ^ __ROR4__(SM4_SBOX_T[BYTE1(v20)], 16) ^ __ROR4__(SM4_SBOX_T[(v36 ^ *((_BYTE *)a3 + 32) ^ v34 ^ v28)], 24) ^ v33;
  LODWORD(v20) = v36 ^ a3[9] ^ v28 ^ v37;
  v38 = SM4_SBOX_T[BYTE3(v20)] ^ __ROR4__(SM4_SBOX_T[BYTE2(v20)], 8) ^ __ROR4__(SM4_SBOX_T[BYTE1(v20)], 16) ^ __ROR4__(SM4_SBOX_T[(v36 ^ *((_BYTE *)a3 + 36) ^ v28 ^ v37)], 24) ^ v34;
  v39 = a3[10] ^ v28 ^ v38 ^ v37;
  v40 = SM4_SBOX_T[HIBYTE(v39)] ^ __ROR4__(SM4_SBOX_T[BYTE2(v39)], 8) ^ __ROR4__(SM4_SBOX_T[BYTE1(v39)], 16) ^ __ROR4__(SM4_SBOX_T[(*((_BYTE *)a3 + 40) ^ v28 ^ v38 ^ v37)], 24) ^ v36;
  LODWORD(v20) = a3[11] ^ v38 ^ v37 ^ v40;
  LODWORD(v28) = SM4_SBOX_T[BYTE3(v20)] ^ __ROR4__(SM4_SBOX_T[BYTE2(v20)], 8) ^ __ROR4__(SM4_SBOX_T[BYTE1(v20)], 16) ^ __ROR4__(SM4_SBOX_T[(*((_BYTE *)a3 + 44) ^ v38 ^ v37 ^ v40)], 24) ^ v28;
  LODWORD(v20) = v40 ^ a3[12] ^ v38 ^ v28;
  v41 = SM4_SBOX_T[BYTE3(v20)] ^ __ROR4__(SM4_SBOX_T[BYTE2(v20)], 8) ^ __ROR4__(SM4_SBOX_T[BYTE1(v20)], 16) ^ __ROR4__(SM4_SBOX_T[(v40 ^ *((_BYTE *)a3 + 48) ^ v38 ^ v28)], 24) ^ v37;
  LODWORD(v20) = v40 ^ a3[13] ^ v28 ^ v41;
  v42 = SM4_SBOX_T[BYTE3(v20)] ^ __ROR4__(SM4_SBOX_T[BYTE2(v20)], 8) ^ __ROR4__(SM4_SBOX_T[BYTE1(v20)], 16) ^ __ROR4__(SM4_SBOX_T[(v40 ^ *((_BYTE *)a3 + 52) ^ v28 ^ v41)], 24) ^ v38;
  v43 = a3[14] ^ v28 ^ v42 ^ v41;
  v44 = SM4_SBOX_T[HIBYTE(v43)] ^ __ROR4__(SM4_SBOX_T[BYTE2(v43)], 8) ^ __ROR4__(SM4_SBOX_T[BYTE1(v43)], 16) ^ __ROR4__(SM4_SBOX_T[(*((_BYTE *)a3 + 56) ^ v28 ^ v42 ^ v41)], 24) ^ v40;
  LODWORD(v20) = a3[15] ^ v42 ^ v41 ^ v44;
  LODWORD(v28) = SM4_SBOX_T[BYTE3(v20)] ^ __ROR4__(SM4_SBOX_T[BYTE2(v20)], 8) ^ __ROR4__(SM4_SBOX_T[BYTE1(v20)], 16) ^ __ROR4__(SM4_SBOX_T[(*((_BYTE *)a3 + 60) ^ v42 ^ v41 ^ v44)], 24) ^ v28;
  LODWORD(v20) = v44 ^ a3[16] ^ v42 ^ v28;
  v45 = SM4_SBOX_T[BYTE3(v20)] ^ __ROR4__(SM4_SBOX_T[BYTE2(v20)], 8) ^ __ROR4__(SM4_SBOX_T[BYTE1(v20)], 16) ^ __ROR4__(SM4_SBOX_T[(v44 ^ *((_BYTE *)a3 + 64) ^ v42 ^ v28)], 24) ^ v41;
  LODWORD(v20) = v44 ^ a3[17] ^ v28 ^ v45;
  v46 = SM4_SBOX_T[BYTE3(v20)] ^ __ROR4__(SM4_SBOX_T[BYTE2(v20)], 8) ^ __ROR4__(SM4_SBOX_T[BYTE1(v20)], 16) ^ __ROR4__(SM4_SBOX_T[(v44 ^ *((_BYTE *)a3 + 68) ^ v28 ^ v45)], 24) ^ v42;
  v47 = a3[18] ^ v28 ^ v46 ^ v45;
  v48 = SM4_SBOX_T[HIBYTE(v47)] ^ __ROR4__(SM4_SBOX_T[BYTE2(v47)], 8) ^ __ROR4__(SM4_SBOX_T[BYTE1(v47)], 16) ^ __ROR4__(SM4_SBOX_T[(*((_BYTE *)a3 + 72) ^ v28 ^ v46 ^ v45)], 24) ^ v44;
  LODWORD(v20) = a3[19] ^ v46 ^ v45 ^ v48;
  LODWORD(v28) = SM4_SBOX_T[BYTE3(v20)] ^ __ROR4__(SM4_SBOX_T[BYTE2(v20)], 8) ^ __ROR4__(SM4_SBOX_T[BYTE1(v20)], 16) ^ __ROR4__(SM4_SBOX_T[(*((_BYTE *)a3 + 76) ^ v46 ^ v45 ^ v48)], 24) ^ v28;
  LODWORD(v20) = v48 ^ a3[20] ^ v46 ^ v28;
  v49 = SM4_SBOX_T[BYTE3(v20)] ^ __ROR4__(SM4_SBOX_T[BYTE2(v20)], 8) ^ __ROR4__(SM4_SBOX_T[BYTE1(v20)], 16) ^ __ROR4__(SM4_SBOX_T[(v48 ^ *((_BYTE *)a3 + 80) ^ v46 ^ v28)], 24) ^ v45;
  LODWORD(v20) = v48 ^ a3[21] ^ v28 ^ v49;
  v50 = SM4_SBOX_T[BYTE3(v20)] ^ __ROR4__(SM4_SBOX_T[BYTE2(v20)], 8) ^ __ROR4__(SM4_SBOX_T[BYTE1(v20)], 16) ^ __ROR4__(SM4_SBOX_T[(v48 ^ *((_BYTE *)a3 + 84) ^ v28 ^ v49)], 24) ^ v46;
  v51 = a3[22] ^ v28 ^ v50 ^ v49;
  v52 = SM4_SBOX_T[HIBYTE(v51)] ^ __ROR4__(SM4_SBOX_T[BYTE2(v51)], 8) ^ __ROR4__(SM4_SBOX_T[BYTE1(v51)], 16) ^ __ROR4__(SM4_SBOX_T[(*((_BYTE *)a3 + 88) ^ v28 ^ v50 ^ v49)], 24) ^ v48;
  LODWORD(v20) = a3[23] ^ v50 ^ v49 ^ v52;
  LODWORD(v28) = SM4_SBOX_T[BYTE3(v20)] ^ __ROR4__(SM4_SBOX_T[BYTE2(v20)], 8) ^ __ROR4__(SM4_SBOX_T[BYTE1(v20)], 16) ^ __ROR4__(SM4_SBOX_T[(*((_BYTE *)a3 + 92) ^ v50 ^ v49 ^ v52)], 24) ^ v28;
  LODWORD(v20) = v52 ^ a3[24] ^ v50 ^ v28;
  v53 = SM4_SBOX_T[BYTE3(v20)] ^ __ROR4__(SM4_SBOX_T[BYTE2(v20)], 8) ^ __ROR4__(SM4_SBOX_T[BYTE1(v20)], 16) ^ __ROR4__(SM4_SBOX_T[(v52 ^ *((_BYTE *)a3 + 96) ^ v50 ^ v28)], 24) ^ v49;
  LODWORD(v20) = v52 ^ a3[25] ^ v28 ^ v53;
  v54 = SM4_SBOX_T[BYTE3(v20)] ^ __ROR4__(SM4_SBOX_T[BYTE2(v20)], 8) ^ __ROR4__(SM4_SBOX_T[BYTE1(v20)], 16) ^ __ROR4__(SM4_SBOX_T[(v52 ^ *((_BYTE *)a3 + 100) ^ v28 ^ v53)], 24) ^ v50;
  v55 = a3[26] ^ v28 ^ v54 ^ v53;
  v56 = SM4_SBOX_T[HIBYTE(v55)] ^ __ROR4__(SM4_SBOX_T[BYTE2(v55)], 8) ^ __ROR4__(SM4_SBOX_T[BYTE1(v55)], 16) ^ __ROR4__(SM4_SBOX_T[(*((_BYTE *)a3 + 104) ^ v28 ^ v54 ^ v53)], 24) ^ v52;
  LODWORD(v20) = a3[27] ^ v54 ^ v53 ^ v56;
  v57 = SM4_SBOX_T[BYTE3(v20)] ^ __ROR4__(SM4_SBOX_T[BYTE2(v20)], 8) ^ __ROR4__(SM4_SBOX_T[BYTE1(v20)], 16) ^ __ROR4__(SM4_SBOX_T[(*((_BYTE *)a3 + 108) ^ v54 ^ v53 ^ v56)], 24) ^ v28;
  v58 = v56 ^ a3[28] ^ v54 ^ v57;
  v59 = SM4_S[v58 >> 24];
  v60 = SM4_S[(v56 ^ *((_BYTE *)a3 + 112) ^ v54 ^ v57)] | (SM4_S[BYTE1(v58)] << 8);
  v61 = v60 | (v59 << 24) | (SM4_S[BYTE2(v58)] << 16);
  HIDWORD(v12) = v61;
  LODWORD(v12) = (v59 << 24) | (SM4_S[BYTE2(v58)] << 16);
  v62 = v12 >> 22;
  HIDWORD(v12) = SM4_S[(v56 ^ *((_BYTE *)a3 + 112) ^ v54 ^ v57)];
  LODWORD(v12) = v61;
  v63 = (__PAIR64__(v60, v61) >> 14) ^ v62 ^ (v12 >> 8) ^ ((v59 >> 6) | (4 * v61)) ^ v53 ^ v61;
  v64 = v56 ^ a3[29] ^ v57 ^ v63;
  LODWORD(v20) = SM4_S[v64 >> 24];
  v65 = ((_DWORD)v20 << 24) | (SM4_S[BYTE2(v64)] << 16);
  v66 = SM4_S[(v56 ^ *((_BYTE *)a3 + 116) ^ v57 ^ v63)] | (SM4_S[BYTE1(v64)] << 8);
  v67 = v66 | v65;
  LODWORD(v20) = (v20 >> 6) | (4 * (v66 | v65));
  HIDWORD(v12) = v66 | v65;
  LODWORD(v12) = v65;
  v68 = v12 >> 22;
  HIDWORD(v12) = SM4_S[(v56 ^ *((_BYTE *)a3 + 116) ^ v57 ^ v63)];
  LODWORD(v12) = v67;
  v69 = (__PAIR64__(v66, v67) >> 14) ^ v68 ^ (v12 >> 8) ^ v20 ^ v54 ^ v67;
  v70 = a3[31];
  v71 = a3[30] ^ v57 ^ v69 ^ v63;
  v72 = SM4_S[v71 >> 24];
  v73 = SM4_S[BYTE1(v71)];
  v74 = (v72 << 24) | (SM4_S[BYTE2(v71)] << 16);
  LODWORD(v71) = SM4_S[v71];
  v75 = v71 | (v73 << 8);
  v76 = v75 | v74;
  HIDWORD(v12) = v75 | v74;
  LODWORD(v12) = v74;
  result = (__PAIR64__(v75, v75 | v74) >> 14);
  v78 = result ^ (v12 >> 22) ^ (__PAIR64__(v71, v76) >> 8) ^ ((v72 >> 6) | (4 * v76)) ^ v56 ^ v76;
  v79 = v69 ^ v63 ^ v70 ^ v78;
  LODWORD(v71) = SM4_S[v79 >> 24];
  v80 = ((_DWORD)v71 << 24) | (SM4_S[BYTE2(v79)] << 16);
  v81 = SM4_S[v79];
  LODWORD(v79) = v81 | (SM4_S[BYTE1(v79)] << 8);
  HIDWORD(v12) = v79 | v80;
  LODWORD(v12) = v80;
  v82 = (__PAIR64__(v79, v79 | v80) >> 14) ^ (v12 >> 22) ^ (__PAIR64__(v81, v79 | v80) >> 8) ^ ((v71 >> 6) | (4 * (v79 | v80))) ^ v57 ^ (v79 | v80);
  *a2 = HIBYTE(v82);
  a2[1] = BYTE2(v82);
  a2[2] = BYTE1(v82);
  a2[3] = v82;
  a2[4] = HIBYTE(v78);
  a2[5] = BYTE2(v78);
  a2[6] = BYTE1(v78);
  a2[7] = v78;
  a2[8] = HIBYTE(v69);
  a2[9] = BYTE2(v69);
  a2[10] = BYTE1(v69);
  a2[11] = v69;
  a2[12] = HIBYTE(v63);
  a2[13] = BYTE2(v63);
  a2[14] = BYTE1(v63);
  a2[15] = v63;
  return result;
}

uint64_t SM4_decrypt(unsigned int *a1, _BYTE *a2, _DWORD *a3)
{
  unsigned int v3;
  unsigned int v4;
  unsigned int v5;
  unsigned int v6;
  unint64_t v7;
  unsigned int v8;
  int v9;
  int v10;
  int v11;
  unint64_t v12;
  int v13;
  unint64_t v14;
  int v15;
  int v16;
  int v17;
  int v18;
  int v19;
  unint64_t v20;
  unsigned int v21;
  int v22;
  int v23;
  int v24;
  int v25;
  int v26;
  unsigned int v27;
  unint64_t v28;
  int v29;
  int v30;
  int v31;
  unsigned int v32;
  int v33;
  int v34;
  unsigned int v35;
  int v36;
  int v37;
  int v38;
  unsigned int v39;
  int v40;
  int v41;
  int v42;
  unsigned int v43;
  int v44;
  int v45;
  int v46;
  unsigned int v47;
  int v48;
  int v49;
  int v50;
  unsigned int v51;
  int v52;
  int v53;
  int v54;
  unsigned int v55;
  int v56;
  unsigned int v57;
  unint64_t v58;
  unsigned int v59;
  int v60;
  int v61;
  int v62;
  unsigned int v63;
  unint64_t v64;
  int v65;
  int v66;
  int v67;
  int v68;
  int v69;
  int v70;
  unint64_t v71;
  unsigned int v72;
  int v73;
  int v74;
  unsigned int v75;
  int v76;
  uint64_t result;
  unsigned int v78;
  unint64_t v79;
  int v80;
  unsigned int v81;
  int v82;

  v3 = bswap32(*a1);
  v4 = bswap32(a1[1]);
  v5 = bswap32(a1[2]);
  v6 = bswap32(a1[3]);
  v7 = v5 ^ a3[31] ^ v6 ^ v4;
  v8 = SM4_S[v7 >> 24];
  v9 = SM4_S[(v5 ^ *((_BYTE *)a3 + 124) ^ v6 ^ v4)] | (SM4_S[BYTE1(v7)] << 8);
  v10 = v9 | (v8 << 24) | (SM4_S[BYTE2(v7)] << 16);
  HIDWORD(v12) = v10;
  LODWORD(v12) = (v8 << 24) | (SM4_S[BYTE2(v7)] << 16);
  v11 = v12 >> 22;
  HIDWORD(v12) = SM4_S[(v5 ^ *((_BYTE *)a3 + 124) ^ v6 ^ v4)];
  LODWORD(v12) = v10;
  v13 = v3 ^ v11 ^ (__PAIR64__(v9, v10) >> 14) ^ (v12 >> 8) ^ ((v8 >> 6) | (4 * v10)) ^ v10;
  v14 = v5 ^ a3[30] ^ v6 ^ v13;
  LODWORD(v7) = SM4_S[v14 >> 24];
  v15 = ((_DWORD)v7 << 24) | (SM4_S[BYTE2(v14)] << 16);
  v16 = SM4_S[(v5 ^ *((_BYTE *)a3 + 120) ^ v6 ^ v13)] | (SM4_S[BYTE1(v14)] << 8);
  v17 = v16 | v15;
  LODWORD(v7) = (v7 >> 6) | (4 * (v16 | v15));
  HIDWORD(v12) = v16 | v15;
  LODWORD(v12) = v15;
  v18 = v12 >> 22;
  HIDWORD(v12) = SM4_S[(v5 ^ *((_BYTE *)a3 + 120) ^ v6 ^ v13)];
  LODWORD(v12) = v17;
  v19 = (__PAIR64__(v16, v17) >> 14) ^ v18 ^ (v12 >> 8) ^ v7 ^ v4 ^ v17;
  v20 = a3[29] ^ v6 ^ v19 ^ v13;
  v21 = SM4_S[v20 >> 24];
  v22 = (v21 << 24) | (SM4_S[BYTE2(v20)] << 16);
  v23 = SM4_S[(*((_BYTE *)a3 + 116) ^ v6 ^ v19 ^ v13)] | (SM4_S[BYTE1(v20)] << 8);
  v24 = v23 | v22;
  v25 = (v21 >> 6) | (4 * (v23 | v22));
  HIDWORD(v12) = v23 | v22;
  LODWORD(v12) = v22;
  v26 = v12 >> 22;
  HIDWORD(v12) = SM4_S[(*((_BYTE *)a3 + 116) ^ v6 ^ v19 ^ v13)];
  LODWORD(v12) = v24;
  v27 = (__PAIR64__(v23, v24) >> 14) ^ v26 ^ (v12 >> 8) ^ v25 ^ v5 ^ v24;
  v28 = v19 ^ v13 ^ a3[28] ^ v27;
  LODWORD(v20) = SM4_S[v28 >> 24];
  v29 = SM4_S[(v19 ^ v13 ^ *((_BYTE *)a3 + 112) ^ v27)] | (SM4_S[BYTE1(v28)] << 8);
  v30 = v29 | ((_DWORD)v20 << 24) | (SM4_S[BYTE2(v28)] << 16);
  HIDWORD(v12) = v30;
  LODWORD(v12) = ((_DWORD)v20 << 24) | (SM4_S[BYTE2(v28)] << 16);
  v31 = v12 >> 22;
  HIDWORD(v12) = SM4_S[(v19 ^ v13 ^ *((_BYTE *)a3 + 112) ^ v27)];
  LODWORD(v12) = v30;
  LODWORD(v28) = (__PAIR64__(v29, v30) >> 14) ^ v31 ^ (v12 >> 8) ^ ((v20 >> 6) | (4 * v30)) ^ v6 ^ v30;
  v32 = v27 ^ a3[27] ^ v19 ^ v28;
  v33 = SM4_SBOX_T[HIBYTE(v32)] ^ __ROR4__(SM4_SBOX_T[BYTE2(v32)], 8) ^ __ROR4__(SM4_SBOX_T[BYTE1(v32)], 16) ^ __ROR4__(SM4_SBOX_T[(v27 ^ *((_BYTE *)a3 + 108) ^ v19 ^ v28)], 24) ^ v13;
  LODWORD(v20) = v27 ^ a3[26] ^ v28 ^ v33;
  v34 = SM4_SBOX_T[BYTE3(v20)] ^ __ROR4__(SM4_SBOX_T[BYTE2(v20)], 8) ^ __ROR4__(SM4_SBOX_T[BYTE1(v20)], 16) ^ __ROR4__(SM4_SBOX_T[(v27 ^ *((_BYTE *)a3 + 104) ^ v28 ^ v33)], 24) ^ v19;
  v35 = a3[25] ^ v28 ^ v34 ^ v33;
  v36 = SM4_SBOX_T[HIBYTE(v35)] ^ __ROR4__(SM4_SBOX_T[BYTE2(v35)], 8) ^ __ROR4__(SM4_SBOX_T[BYTE1(v35)], 16) ^ __ROR4__(SM4_SBOX_T[(*((_BYTE *)a3 + 100) ^ v28 ^ v34 ^ v33)], 24) ^ v27;
  LODWORD(v20) = a3[24] ^ v34 ^ v33 ^ v36;
  LODWORD(v28) = SM4_SBOX_T[BYTE3(v20)] ^ __ROR4__(SM4_SBOX_T[BYTE2(v20)], 8) ^ __ROR4__(SM4_SBOX_T[BYTE1(v20)], 16) ^ __ROR4__(SM4_SBOX_T[(*((_BYTE *)a3 + 96) ^ v34 ^ v33 ^ v36)], 24) ^ v28;
  LODWORD(v20) = v36 ^ a3[23] ^ v34 ^ v28;
  v37 = SM4_SBOX_T[BYTE3(v20)] ^ __ROR4__(SM4_SBOX_T[BYTE2(v20)], 8) ^ __ROR4__(SM4_SBOX_T[BYTE1(v20)], 16) ^ __ROR4__(SM4_SBOX_T[(v36 ^ *((_BYTE *)a3 + 92) ^ v34 ^ v28)], 24) ^ v33;
  LODWORD(v20) = v36 ^ a3[22] ^ v28 ^ v37;
  v38 = SM4_SBOX_T[BYTE3(v20)] ^ __ROR4__(SM4_SBOX_T[BYTE2(v20)], 8) ^ __ROR4__(SM4_SBOX_T[BYTE1(v20)], 16) ^ __ROR4__(SM4_SBOX_T[(v36 ^ *((_BYTE *)a3 + 88) ^ v28 ^ v37)], 24) ^ v34;
  v39 = a3[21] ^ v28 ^ v38 ^ v37;
  v40 = SM4_SBOX_T[HIBYTE(v39)] ^ __ROR4__(SM4_SBOX_T[BYTE2(v39)], 8) ^ __ROR4__(SM4_SBOX_T[BYTE1(v39)], 16) ^ __ROR4__(SM4_SBOX_T[(*((_BYTE *)a3 + 84) ^ v28 ^ v38 ^ v37)], 24) ^ v36;
  LODWORD(v20) = a3[20] ^ v38 ^ v37 ^ v40;
  LODWORD(v28) = SM4_SBOX_T[BYTE3(v20)] ^ __ROR4__(SM4_SBOX_T[BYTE2(v20)], 8) ^ __ROR4__(SM4_SBOX_T[BYTE1(v20)], 16) ^ __ROR4__(SM4_SBOX_T[(*((_BYTE *)a3 + 80) ^ v38 ^ v37 ^ v40)], 24) ^ v28;
  LODWORD(v20) = v40 ^ a3[19] ^ v38 ^ v28;
  v41 = SM4_SBOX_T[BYTE3(v20)] ^ __ROR4__(SM4_SBOX_T[BYTE2(v20)], 8) ^ __ROR4__(SM4_SBOX_T[BYTE1(v20)], 16) ^ __ROR4__(SM4_SBOX_T[(v40 ^ *((_BYTE *)a3 + 76) ^ v38 ^ v28)], 24) ^ v37;
  LODWORD(v20) = v40 ^ a3[18] ^ v28 ^ v41;
  v42 = SM4_SBOX_T[BYTE3(v20)] ^ __ROR4__(SM4_SBOX_T[BYTE2(v20)], 8) ^ __ROR4__(SM4_SBOX_T[BYTE1(v20)], 16) ^ __ROR4__(SM4_SBOX_T[(v40 ^ *((_BYTE *)a3 + 72) ^ v28 ^ v41)], 24) ^ v38;
  v43 = a3[17] ^ v28 ^ v42 ^ v41;
  v44 = SM4_SBOX_T[HIBYTE(v43)] ^ __ROR4__(SM4_SBOX_T[BYTE2(v43)], 8) ^ __ROR4__(SM4_SBOX_T[BYTE1(v43)], 16) ^ __ROR4__(SM4_SBOX_T[(*((_BYTE *)a3 + 68) ^ v28 ^ v42 ^ v41)], 24) ^ v40;
  LODWORD(v20) = a3[16] ^ v42 ^ v41 ^ v44;
  LODWORD(v28) = SM4_SBOX_T[BYTE3(v20)] ^ __ROR4__(SM4_SBOX_T[BYTE2(v20)], 8) ^ __ROR4__(SM4_SBOX_T[BYTE1(v20)], 16) ^ __ROR4__(SM4_SBOX_T[(*((_BYTE *)a3 + 64) ^ v42 ^ v41 ^ v44)], 24) ^ v28;
  LODWORD(v20) = v44 ^ a3[15] ^ v42 ^ v28;
  v45 = SM4_SBOX_T[BYTE3(v20)] ^ __ROR4__(SM4_SBOX_T[BYTE2(v20)], 8) ^ __ROR4__(SM4_SBOX_T[BYTE1(v20)], 16) ^ __ROR4__(SM4_SBOX_T[(v44 ^ *((_BYTE *)a3 + 60) ^ v42 ^ v28)], 24) ^ v41;
  LODWORD(v20) = v44 ^ a3[14] ^ v28 ^ v45;
  v46 = SM4_SBOX_T[BYTE3(v20)] ^ __ROR4__(SM4_SBOX_T[BYTE2(v20)], 8) ^ __ROR4__(SM4_SBOX_T[BYTE1(v20)], 16) ^ __ROR4__(SM4_SBOX_T[(v44 ^ *((_BYTE *)a3 + 56) ^ v28 ^ v45)], 24) ^ v42;
  v47 = a3[13] ^ v28 ^ v46 ^ v45;
  v48 = SM4_SBOX_T[HIBYTE(v47)] ^ __ROR4__(SM4_SBOX_T[BYTE2(v47)], 8) ^ __ROR4__(SM4_SBOX_T[BYTE1(v47)], 16) ^ __ROR4__(SM4_SBOX_T[(*((_BYTE *)a3 + 52) ^ v28 ^ v46 ^ v45)], 24) ^ v44;
  LODWORD(v20) = a3[12] ^ v46 ^ v45 ^ v48;
  LODWORD(v28) = SM4_SBOX_T[BYTE3(v20)] ^ __ROR4__(SM4_SBOX_T[BYTE2(v20)], 8) ^ __ROR4__(SM4_SBOX_T[BYTE1(v20)], 16) ^ __ROR4__(SM4_SBOX_T[(*((_BYTE *)a3 + 48) ^ v46 ^ v45 ^ v48)], 24) ^ v28;
  LODWORD(v20) = v48 ^ a3[11] ^ v46 ^ v28;
  v49 = SM4_SBOX_T[BYTE3(v20)] ^ __ROR4__(SM4_SBOX_T[BYTE2(v20)], 8) ^ __ROR4__(SM4_SBOX_T[BYTE1(v20)], 16) ^ __ROR4__(SM4_SBOX_T[(v48 ^ *((_BYTE *)a3 + 44) ^ v46 ^ v28)], 24) ^ v45;
  LODWORD(v20) = v48 ^ a3[10] ^ v28 ^ v49;
  v50 = SM4_SBOX_T[BYTE3(v20)] ^ __ROR4__(SM4_SBOX_T[BYTE2(v20)], 8) ^ __ROR4__(SM4_SBOX_T[BYTE1(v20)], 16) ^ __ROR4__(SM4_SBOX_T[(v48 ^ *((_BYTE *)a3 + 40) ^ v28 ^ v49)], 24) ^ v46;
  v51 = a3[9] ^ v28 ^ v50 ^ v49;
  v52 = SM4_SBOX_T[HIBYTE(v51)] ^ __ROR4__(SM4_SBOX_T[BYTE2(v51)], 8) ^ __ROR4__(SM4_SBOX_T[BYTE1(v51)], 16) ^ __ROR4__(SM4_SBOX_T[(*((_BYTE *)a3 + 36) ^ v28 ^ v50 ^ v49)], 24) ^ v48;
  LODWORD(v20) = a3[8] ^ v50 ^ v49 ^ v52;
  LODWORD(v28) = SM4_SBOX_T[BYTE3(v20)] ^ __ROR4__(SM4_SBOX_T[BYTE2(v20)], 8) ^ __ROR4__(SM4_SBOX_T[BYTE1(v20)], 16) ^ __ROR4__(SM4_SBOX_T[(*((_BYTE *)a3 + 32) ^ v50 ^ v49 ^ v52)], 24) ^ v28;
  LODWORD(v20) = v52 ^ a3[7] ^ v50 ^ v28;
  v53 = SM4_SBOX_T[BYTE3(v20)] ^ __ROR4__(SM4_SBOX_T[BYTE2(v20)], 8) ^ __ROR4__(SM4_SBOX_T[BYTE1(v20)], 16) ^ __ROR4__(SM4_SBOX_T[(v52 ^ *((_BYTE *)a3 + 28) ^ v50 ^ v28)], 24) ^ v49;
  LODWORD(v20) = v52 ^ a3[6] ^ v28 ^ v53;
  v54 = SM4_SBOX_T[BYTE3(v20)] ^ __ROR4__(SM4_SBOX_T[BYTE2(v20)], 8) ^ __ROR4__(SM4_SBOX_T[BYTE1(v20)], 16) ^ __ROR4__(SM4_SBOX_T[(v52 ^ *((_BYTE *)a3 + 24) ^ v28 ^ v53)], 24) ^ v50;
  v55 = a3[5] ^ v28 ^ v54 ^ v53;
  v56 = SM4_SBOX_T[HIBYTE(v55)] ^ __ROR4__(SM4_SBOX_T[BYTE2(v55)], 8) ^ __ROR4__(SM4_SBOX_T[BYTE1(v55)], 16) ^ __ROR4__(SM4_SBOX_T[(*((_BYTE *)a3 + 20) ^ v28 ^ v54 ^ v53)], 24) ^ v52;
  LODWORD(v20) = a3[4] ^ v54 ^ v53 ^ v56;
  v57 = SM4_SBOX_T[BYTE3(v20)] ^ __ROR4__(SM4_SBOX_T[BYTE2(v20)], 8) ^ __ROR4__(SM4_SBOX_T[BYTE1(v20)], 16) ^ __ROR4__(SM4_SBOX_T[(*((_BYTE *)a3 + 16) ^ v54 ^ v53 ^ v56)], 24) ^ v28;
  v58 = v56 ^ a3[3] ^ v54 ^ v57;
  v59 = SM4_S[v58 >> 24];
  v60 = SM4_S[(v56 ^ *((_BYTE *)a3 + 12) ^ v54 ^ v57)] | (SM4_S[BYTE1(v58)] << 8);
  v61 = v60 | (v59 << 24) | (SM4_S[BYTE2(v58)] << 16);
  HIDWORD(v12) = v61;
  LODWORD(v12) = (v59 << 24) | (SM4_S[BYTE2(v58)] << 16);
  v62 = v12 >> 22;
  HIDWORD(v12) = SM4_S[(v56 ^ *((_BYTE *)a3 + 12) ^ v54 ^ v57)];
  LODWORD(v12) = v61;
  v63 = (__PAIR64__(v60, v61) >> 14) ^ v62 ^ (v12 >> 8) ^ ((v59 >> 6) | (4 * v61)) ^ v53 ^ v61;
  v64 = v56 ^ a3[2] ^ v57 ^ v63;
  LODWORD(v20) = SM4_S[v64 >> 24];
  v65 = ((_DWORD)v20 << 24) | (SM4_S[BYTE2(v64)] << 16);
  v66 = SM4_S[(v56 ^ *((_BYTE *)a3 + 8) ^ v57 ^ v63)] | (SM4_S[BYTE1(v64)] << 8);
  v67 = v66 | v65;
  LODWORD(v20) = (v20 >> 6) | (4 * (v66 | v65));
  HIDWORD(v12) = v66 | v65;
  LODWORD(v12) = v65;
  v68 = v12 >> 22;
  HIDWORD(v12) = SM4_S[(v56 ^ *((_BYTE *)a3 + 8) ^ v57 ^ v63)];
  LODWORD(v12) = v67;
  v69 = (__PAIR64__(v66, v67) >> 14) ^ v68 ^ (v12 >> 8) ^ v20 ^ v54 ^ v67;
  v70 = *a3;
  v71 = a3[1] ^ v57 ^ v69 ^ v63;
  v72 = SM4_S[v71 >> 24];
  v73 = SM4_S[BYTE1(v71)];
  v74 = (v72 << 24) | (SM4_S[BYTE2(v71)] << 16);
  LODWORD(v71) = SM4_S[v71];
  v75 = v71 | (v73 << 8);
  v76 = v75 | v74;
  HIDWORD(v12) = v75 | v74;
  LODWORD(v12) = v74;
  result = (__PAIR64__(v75, v75 | v74) >> 14);
  v78 = result ^ (v12 >> 22) ^ (__PAIR64__(v71, v76) >> 8) ^ ((v72 >> 6) | (4 * v76)) ^ v56 ^ v76;
  v79 = v69 ^ v63 ^ v70 ^ v78;
  LODWORD(v71) = SM4_S[v79 >> 24];
  v80 = ((_DWORD)v71 << 24) | (SM4_S[BYTE2(v79)] << 16);
  v81 = SM4_S[v79];
  LODWORD(v79) = v81 | (SM4_S[BYTE1(v79)] << 8);
  HIDWORD(v12) = v79 | v80;
  LODWORD(v12) = v80;
  v82 = (__PAIR64__(v79, v79 | v80) >> 14) ^ (v12 >> 22) ^ (__PAIR64__(v81, v79 | v80) >> 8) ^ ((v71 >> 6) | (4 * (v79 | v80))) ^ v57 ^ (v79 | v80);
  *a2 = HIBYTE(v82);
  a2[1] = BYTE2(v82);
  a2[2] = BYTE1(v82);
  a2[3] = v82;
  a2[4] = HIBYTE(v78);
  a2[5] = BYTE2(v78);
  a2[6] = BYTE1(v78);
  a2[7] = v78;
  a2[8] = HIBYTE(v69);
  a2[9] = BYTE2(v69);
  a2[10] = BYTE1(v69);
  a2[11] = v69;
  a2[12] = HIBYTE(v63);
  a2[13] = BYTE2(v63);
  a2[14] = BYTE1(v63);
  a2[15] = v63;
  return result;
}

double CRYPTO_poly1305_init(uint64_t a1, _DWORD *a2)
{
  double result;

  *(_QWORD *)a1 = *a2 & 0x3FFFFFF;
  *(_QWORD *)(a1 + 8) = ((unint64_t)*(unsigned int *)((char *)a2 + 3) >> 2) & 0x3FFFF03;
  *(_QWORD *)(a1 + 16) = ((unint64_t)*(unsigned int *)((char *)a2 + 6) >> 4) & 0x3FFC0FF;
  *(_QWORD *)(a1 + 24) = ((unint64_t)*(unsigned int *)((char *)a2 + 9) >> 6) & 0x3F03FFF;
  *(_QWORD *)(a1 + 32) = ((unint64_t)a2[3] >> 8) & 0xFFFFF;
  result = 0.0;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_QWORD *)(a1 + 72) = 0;
  *(_QWORD *)(a1 + 80) = a2[4];
  *(_QWORD *)(a1 + 88) = a2[5];
  *(_QWORD *)(a1 + 96) = a2[6];
  *(_QWORD *)(a1 + 104) = a2[7];
  *(_QWORD *)(a1 + 112) = 0;
  *(_BYTE *)(a1 + 136) = 0;
  return result;
}

uint64_t *CRYPTO_poly1305_update(uint64_t *result, char *a2, unint64_t a3)
{
  unint64_t v3;
  char *v4;
  uint64_t *v5;
  uint64_t v6;
  unint64_t v7;
  uint64_t *v8;
  char *v9;
  unint64_t v10;
  char v11;
  unint64_t v12;
  uint64_t *v13;
  unint64_t v14;
  char v15;

  v3 = a3;
  v4 = a2;
  v5 = result;
  v6 = result[14];
  if (!v6)
    goto LABEL_10;
  v7 = 16 - v6;
  if (16 - v6 >= a3)
    v7 = a3;
  if (v7)
  {
    v8 = result + 15;
    v9 = a2;
    v10 = v7;
    do
    {
      v11 = *v9++;
      *((_BYTE *)v8 + result[14]) = v11;
      v8 = (uint64_t *)((char *)v8 + 1);
      --v10;
    }
    while (v10);
    v6 = result[14];
  }
  v12 = v6 + v7;
  result[14] = v12;
  if (v12 >= 0x10)
  {
    v4 = &a2[v7];
    v3 = a3 - v7;
    result = poly1305_blocks(result, (_DWORD *)result + 30, 0x10uLL);
    v5[14] = 0;
LABEL_10:
    if (v3 >= 0x10)
    {
      result = poly1305_blocks(v5, v4, v3 & 0xFFFFFFFFFFFFFFF0);
      v4 += v3 & 0xFFFFFFFFFFFFFFF0;
      v3 &= 0xFu;
    }
    if (v3)
    {
      v13 = v5 + 15;
      v14 = v3;
      do
      {
        v15 = *v4++;
        *((_BYTE *)v13 + v5[14]) = v15;
        v13 = (uint64_t *)((char *)v13 + 1);
        --v14;
      }
      while (v14);
      v5[14] += v3;
    }
  }
  return result;
}

double CRYPTO_poly1305_finish(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  int64_t v16;
  uint64_t v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t v20;
  unint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  unint64_t v26;
  unint64_t v27;
  double result;

  v4 = *(_QWORD *)(a1 + 112);
  if (v4)
  {
    *(_BYTE *)(a1 + 120 + v4) = 1;
    if ((unint64_t)(v4 + 1) <= 0xF)
      bzero((void *)(v4 + a1 + 121), 15 - v4);
    *(_BYTE *)(a1 + 136) = 1;
    poly1305_blocks((uint64_t *)a1, (_DWORD *)(a1 + 120), 0x10uLL);
  }
  v5 = *(_QWORD *)(a1 + 56) + (*(_QWORD *)(a1 + 48) >> 26);
  v6 = v5 & 0x3FFFFFF;
  v7 = *(_QWORD *)(a1 + 64) + (v5 >> 26);
  v8 = v7 & 0x3FFFFFF;
  v9 = *(_QWORD *)(a1 + 72) + (v7 >> 26);
  v10 = 5 * (v9 >> 26) + *(_QWORD *)(a1 + 40);
  v11 = v10 & 0x3FFFFFF;
  v12 = (*(_QWORD *)(a1 + 48) & 0x3FFFFFFLL) + (v10 >> 26);
  v13 = v12 + ((v11 + 5) >> 26);
  v14 = v6 + (v13 >> 26);
  v15 = v8 + (v14 >> 26);
  v16 = (v9 | 0xFFFFFFFFFC000000) + (v15 >> 26);
  v17 = ((unint64_t)v16 >> 63) - 1;
  v18 = v17 & 0x3FFFFFF & v13 | v12 & (v16 >> 63);
  v19 = v17 & 0x3FFFFFF & v14 | v6 & (v16 >> 63);
  v20 = v17 & 0x3FFFFFF & v15 | v8 & (v16 >> 63);
  v21 = (v17 & 0x3FFFFFF & (v11 + 5) | v11 & (v16 >> 63) | ((_DWORD)v18 << 26)) + *(_QWORD *)(a1 + 80);
  v22 = *(_QWORD *)(a1 + 96);
  v23 = ((v18 >> 6) | ((_DWORD)v19 << 20)) + *(_QWORD *)(a1 + 88);
  v24 = *(_QWORD *)(a1 + 104);
  *(_WORD *)a2 = v21;
  *(_BYTE *)(a2 + 2) = BYTE2(v21);
  v25 = v23 + HIDWORD(v21);
  *(_BYTE *)(a2 + 3) = BYTE3(v21);
  *(_WORD *)(a2 + 4) = v25;
  *(_BYTE *)(a2 + 6) = BYTE2(v25);
  v26 = v22 + (v19 >> 12) + ((_DWORD)v20 << 14) + HIDWORD(v25);
  *(_BYTE *)(a2 + 7) = BYTE3(v25);
  *(_WORD *)(a2 + 8) = v26;
  *(_BYTE *)(a2 + 10) = BYTE2(v26);
  *(_BYTE *)(a2 + 11) = BYTE3(v26);
  v27 = v24
      + (v20 >> 18)
      + ((v17 & v16 | v9 & (v16 >> 63)) << 8)
      + HIDWORD(v26);
  *(_WORD *)(a2 + 12) = v27;
  *(_BYTE *)(a2 + 14) = BYTE2(v27);
  *(_BYTE *)(a2 + 15) = BYTE3(v27);
  result = 0.0;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)a1 = 0u;
  return result;
}

uint64_t *poly1305_blocks(uint64_t *result, _DWORD *a2, unint64_t a3)
{
  unint64_t v3;
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  unint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t v26;
  unint64_t v27;
  unint64_t v28;
  unint64_t v29;
  unint64_t v30;
  unint64_t v31;
  unint64_t v32;

  v4 = result[5];
  v3 = result[6];
  v5 = result[7];
  v6 = result[8];
  v7 = result[9];
  if (a3 >= 0x10)
  {
    v8 = *result;
    v9 = result[1];
    v10 = result[2];
    v11 = result[3];
    v12 = result[4];
    v13 = 5 * v10;
    v14 = 5 * v11;
    v15 = 5 * v12;
    do
    {
      v16 = v4 + (*a2 & 0x3FFFFFF);
      v17 = v3 + (((unint64_t)*(unsigned int *)((char *)a2 + 3) >> 2) & 0x3FFFFFF);
      v18 = v5 + (((unint64_t)*(unsigned int *)((char *)a2 + 6) >> 4) & 0x3FFFFFF);
      v19 = v6 + ((unint64_t)*(unsigned int *)((char *)a2 + 9) >> 6);
      v20 = (((unint64_t)(*((_BYTE *)result + 136) == 0) << 24) | ((unint64_t)a2[3] >> 8))
          + v7;
      v21 = v16 * v8 + v17 * v15 + v18 * v14 + v19 * v13 + 5 * v9 * v20;
      v22 = v16 * v9 + v17 * v8 + v18 * v15 + v19 * v14 + v20 * v13;
      v23 = v16 * v10 + v17 * v9 + v18 * v8 + v19 * v15 + v20 * v14;
      v24 = v16 * v11 + v17 * v10 + v18 * v9 + v19 * v8 + v20 * v15;
      v25 = v16 * v12 + v17 * v11 + v18 * v10 + v19 * v9 + v20 * v8;
      v26 = v21 & 0x3FFFFFF;
      v27 = v22 + (v21 >> 26);
      v28 = v27 & 0x3FFFFFF;
      v29 = v23 + (v27 >> 26);
      v5 = v29 & 0x3FFFFFF;
      v30 = v24 + (v29 >> 26);
      v6 = v30 & 0x3FFFFFF;
      v31 = v25 + (v30 >> 26);
      v7 = v31 & 0x3FFFFFF;
      v32 = 5 * (v31 >> 26) + v26;
      v4 = v32 & 0x3FFFFFF;
      v3 = v28 + (v32 >> 26);
      a2 += 4;
      a3 -= 16;
    }
    while (a3 > 0xF);
  }
  result[5] = v4;
  result[6] = v3;
  result[7] = v5;
  result[8] = v6;
  result[9] = v7;
  return result;
}

void *reallocarray(void *a1, unint64_t a2, unint64_t a3)
{
  if (!a2 || !((a3 | a2) >> 32) || is_mul_ok(a2, a3))
    return malloc_type_realloc(a1, a3 * a2, 0x86F04196uLL);
  *__error() = 12;
  return 0;
}

EVP_PKEY *__cdecl EVP_PKCS82PKEY(PKCS8_PRIV_KEY_INFO *p8)
{
  EVP_PKEY *v2;
  int v3;
  unsigned int (*v4)(EVP_PKEY *, PKCS8_PRIV_KEY_INFO *);
  int v5;
  int v6;
  ASN1_OBJECT *o;
  char buf[80];
  uint64_t v10;

  v10 = *MEMORY[0x24BDAC8D0];
  o = 0;
  if (!PKCS8_pkey_get0(&o, 0, 0, 0, (uint64_t)p8))
    return 0;
  v2 = EVP_PKEY_new();
  if (v2)
  {
    v3 = OBJ_obj2nid(o);
    if (!EVP_PKEY_set_type((uint64_t)v2, v3))
    {
      ERR_put_error(6, 4095, 118, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/evp_pkey.c", 86);
      i2t_ASN1_OBJECT(buf, 80, o);
      ERR_asprintf_error_data("TYPE=%s", buf);
LABEL_11:
      EVP_PKEY_free(v2);
      return 0;
    }
    v4 = (unsigned int (*)(EVP_PKEY *, PKCS8_PRIV_KEY_INFO *))*((_QWORD *)v2->pkey.ptr + 8);
    if (!v4)
    {
      v5 = 144;
      v6 = 98;
      goto LABEL_10;
    }
    if (!v4(v2, p8))
    {
      v5 = 145;
      v6 = 94;
LABEL_10:
      ERR_put_error(6, 4095, v5, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/evp_pkey.c", v6);
      goto LABEL_11;
    }
  }
  else
  {
    ERR_put_error(6, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/evp_pkey.c", 81);
  }
  return v2;
}

PKCS8_PRIV_KEY_INFO *__cdecl EVP_PKEY2PKCS8(EVP_PKEY *pkey)
{
  PKCS8_PRIV_KEY_INFO *v2;
  PKCS8_PRIV_KEY_INFO *v3;
  char *ptr;
  unsigned int (*v5)(PKCS8_PRIV_KEY_INFO *, EVP_PKEY *);
  int v6;
  int v7;

  v2 = PKCS8_PRIV_KEY_INFO_new();
  v3 = v2;
  if (v2)
  {
    ptr = pkey->pkey.ptr;
    if (!ptr)
    {
      v6 = 118;
      v7 = 132;
      goto LABEL_9;
    }
    v5 = (unsigned int (*)(PKCS8_PRIV_KEY_INFO *, EVP_PKEY *))*((_QWORD *)ptr + 9);
    if (!v5)
    {
      v6 = 144;
      v7 = 128;
      goto LABEL_9;
    }
    if (!v5(v2, pkey))
    {
      v6 = 146;
      v7 = 124;
LABEL_9:
      ERR_put_error(6, 4095, v6, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/evp_pkey.c", v7);
      PKCS8_PRIV_KEY_INFO_free(v3);
      return 0;
    }
  }
  else
  {
    ERR_put_error(6, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/evp_pkey.c", 117);
  }
  return v3;
}

int EVP_PKEY_get_attr_count(const EVP_PKEY *key)
{
  return X509at_get_attr_count(*(const STACK **)&key[1].references);
}

int EVP_PKEY_get_attr_by_NID(const EVP_PKEY *key, int nid, int lastpos)
{
  return X509at_get_attr_by_NID(*(const STACK **)&key[1].references, nid, lastpos);
}

int EVP_PKEY_get_attr_by_OBJ(const EVP_PKEY *key, ASN1_OBJECT *obj, int lastpos)
{
  return X509at_get_attr_by_OBJ(*(const STACK **)&key[1].references, obj, lastpos);
}

X509_ATTRIBUTE *__cdecl EVP_PKEY_get_attr(const EVP_PKEY *key, int loc)
{
  return X509at_get_attr(*(const STACK **)&key[1].references, loc);
}

X509_ATTRIBUTE *__cdecl EVP_PKEY_delete_attr(EVP_PKEY *key, int loc)
{
  return X509at_delete_attr(*(STACK **)&key[1].references, loc);
}

int EVP_PKEY_add1_attr(EVP_PKEY *key, X509_ATTRIBUTE *attr)
{
  return X509at_add1_attr((STACK **)&key[1].references, attr) != 0;
}

int EVP_PKEY_add1_attr_by_OBJ(EVP_PKEY *key, const ASN1_OBJECT *obj, int type, const unsigned __int8 *bytes, int len)
{
  return X509at_add1_attr_by_OBJ((STACK **)&key[1].references, obj, type, bytes, len) != 0;
}

int EVP_PKEY_add1_attr_by_NID(EVP_PKEY *key, int nid, int type, const unsigned __int8 *bytes, int len)
{
  return X509at_add1_attr_by_NID((STACK **)&key[1].references, nid, type, bytes, len) != 0;
}

int EVP_PKEY_add1_attr_by_txt(EVP_PKEY *key, const char *attrname, int type, const unsigned __int8 *bytes, int len)
{
  return X509at_add1_attr_by_txt((STACK **)&key[1].references, attrname, type, bytes, len) != 0;
}

void CONF_set_nconf(CONF *conf, LHASH *hash)
{
  CONF_METHOD *v4;

  v4 = (CONF_METHOD *)default_CONF_method;
  if (!default_CONF_method)
  {
    v4 = NCONF_default();
    default_CONF_method = (uint64_t)v4;
  }
  ((void (*)(CONF *))v4->init)(conf);
  conf->data = hash;
}

int CONF_set_default_method(CONF_METHOD *meth)
{
  default_CONF_method = (uint64_t)meth;
  return 1;
}

LHASH *__cdecl CONF_load(LHASH *conf, const char *file, uint64_t *eline)
{
  BIO *v5;
  BIO *v6;
  LHASH *bio;

  v5 = BIO_new_file(file, "rb");
  if (v5)
  {
    v6 = v5;
    bio = CONF_load_bio(conf, v5, eline);
    BIO_free(v6);
    return bio;
  }
  else
  {
    ERR_put_error(14, 4095, 2, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/conf/conf_lib.c", 97);
    return 0;
  }
}

LHASH *__cdecl CONF_load_bio(LHASH *conf, BIO *bp, uint64_t *eline)
{
  CONF_METHOD *v6;
  _QWORD v8[2];
  LHASH *v9;

  v6 = (CONF_METHOD *)default_CONF_method;
  if (!default_CONF_method)
  {
    v6 = NCONF_default();
    default_CONF_method = (uint64_t)v6;
  }
  v8[1] = 0;
  v9 = 0;
  v8[0] = 0;
  ((void (*)(_QWORD *))v6->init)(v8);
  v9 = conf;
  if ((*(unsigned int (**)(_QWORD *, BIO *, uint64_t *))(v8[0] + 40))(v8, bp, eline))
    return v9;
  else
    return 0;
}

LHASH *__cdecl CONF_load_fp(LHASH *conf, FILE *fp, uint64_t *eline)
{
  BIO *v5;
  BIO *v6;
  LHASH *bio;

  v5 = BIO_new_fp(fp, 0);
  if (v5)
  {
    v6 = v5;
    bio = CONF_load_bio(conf, v5, eline);
    BIO_free(v6);
    return bio;
  }
  else
  {
    ERR_put_error(14, 4095, 7, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/conf/conf_lib.c", 114);
    return 0;
  }
}

int NCONF_load_bio(CONF *conf, BIO *bp, uint64_t *eline)
{
  if (conf)
    return ((uint64_t (*)(CONF *, BIO *, uint64_t *))conf->meth->load_bio)(conf, bp, eline);
  ERR_put_error(14, 4095, 105, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/conf/conf_lib.c", 285);
  return 0;
}

STACK *__cdecl CONF_get_section(STACK *conf, const char *section)
{
  STACK *v3;
  CONF_METHOD *v4;
  CONF confa;

  if (conf)
  {
    v3 = conf;
    memset(&confa, 0, sizeof(confa));
    v4 = (CONF_METHOD *)default_CONF_method;
    if (!default_CONF_method)
    {
      v4 = NCONF_default();
      default_CONF_method = (uint64_t)v4;
    }
    ((void (*)(CONF *))v4->init)(&confa);
    confa.data = (LHASH *)v3;
    return NCONF_get_section(&confa, section);
  }
  return conf;
}

STACK *__cdecl NCONF_get_section(const CONF *conf, const char *section)
{
  int v3;
  int v4;

  if (conf)
  {
    if (section)
      return _CONF_get_section_values(conf, section);
    v3 = 107;
    v4 = 301;
  }
  else
  {
    v3 = 105;
    v4 = 296;
  }
  ERR_put_error(14, 4095, v3, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/conf/conf_lib.c", v4);
  return 0;
}

char *__cdecl CONF_get_string(LHASH *conf, const char *group, const char *name)
{
  CONF_METHOD *v6;
  CONF confa;

  if (!conf)
    return NCONF_get_string(0, group, name);
  memset(&confa, 0, sizeof(confa));
  v6 = (CONF_METHOD *)default_CONF_method;
  if (!default_CONF_method)
  {
    v6 = NCONF_default();
    default_CONF_method = (uint64_t)v6;
  }
  ((void (*)(CONF *))v6->init)(&confa);
  confa.data = conf;
  return NCONF_get_string(&confa, group, name);
}

char *__cdecl NCONF_get_string(const CONF *conf, const char *group, const char *name)
{
  char *string;
  const char *v7;

  string = _CONF_get_string(conf, group, name);
  if (!string)
  {
    if (conf)
    {
      ERR_put_error(14, 4095, 108, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/conf/conf_lib.c", 322);
      v7 = "";
      if (group)
        v7 = group;
      ERR_asprintf_error_data("group=%s name=%s", v7, name);
    }
    else
    {
      ERR_put_error(14, 4095, 106, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/conf/conf_lib.c", 319);
    }
  }
  return string;
}

uint64_t CONF_get_number(LHASH *conf, const char *group, const char *name)
{
  LHASH *v5;
  CONF_METHOD *v6;
  _QWORD v8[2];
  LHASH *v9;
  uint64_t result;

  result = 0;
  if (conf)
  {
    v5 = conf;
    v8[0] = 0;
    v8[1] = 0;
    v9 = 0;
    v6 = (CONF_METHOD *)default_CONF_method;
    if (!default_CONF_method)
    {
      v6 = NCONF_default();
      default_CONF_method = (uint64_t)v6;
    }
    ((void (*)(_QWORD *))v6->init)(v8);
    v9 = v5;
    conf = (LHASH *)v8;
  }
  if (!NCONF_get_number_e((const CONF *)conf, group, name, &result))
    ERR_clear_error();
  return result;
}

int NCONF_get_number_e(const CONF *conf, const char *group, const char *name, uint64_t *result)
{
  char *string;
  char *v7;
  char *v8;
  uint64_t v9;

  if (result)
  {
    string = NCONF_get_string(conf, group, name);
    if (string)
    {
      v7 = string;
      *result = 0;
      if (((unsigned int (*)(const CONF *, _QWORD))conf->meth->is_number)(conf, *string))
      {
        v8 = v7 + 1;
        do
        {
          v9 = 10 * *result;
          *result = v9 + ((int (*)(const CONF *, _QWORD))conf->meth->to_int)(conf, *(v8 - 1));
        }
        while (((unsigned int (*)(const CONF *, _QWORD))conf->meth->is_number)(conf, *v8++));
      }
      LODWORD(string) = 1;
    }
  }
  else
  {
    ERR_put_error(14, 4095, 67, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/conf/conf_lib.c", 335);
    LODWORD(string) = 0;
  }
  return (int)string;
}

void CONF_free(LHASH *conf)
{
  CONF_METHOD *v2;
  _QWORD v3[2];
  LHASH *v4;

  v2 = (CONF_METHOD *)default_CONF_method;
  if (!default_CONF_method)
  {
    v2 = NCONF_default();
    default_CONF_method = (uint64_t)v2;
  }
  v3[1] = 0;
  v4 = 0;
  v3[0] = 0;
  ((void (*)(_QWORD *))v2->init)(v3);
  v4 = conf;
  (*(void (**)(_QWORD *))(v3[0] + 32))(v3);
}

void NCONF_free_data(CONF *conf)
{
  if (conf)
    ((void (*)(CONF *))conf->meth->destroy_data)(conf);
}

int CONF_dump_fp(LHASH *conf, FILE *out)
{
  BIO *v3;
  BIO *v4;
  int v5;

  v3 = BIO_new_fp(out, 0);
  if (v3)
  {
    v4 = v3;
    v5 = CONF_dump_bio(conf, v3);
    BIO_free(v4);
    return v5;
  }
  else
  {
    ERR_put_error(14, 4095, 7, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/conf/conf_lib.c", 199);
    return 0;
  }
}

int CONF_dump_bio(LHASH *conf, BIO *out)
{
  CONF_METHOD *v4;
  _QWORD v6[2];
  LHASH *v7;

  v4 = (CONF_METHOD *)default_CONF_method;
  if (!default_CONF_method)
  {
    v4 = NCONF_default();
    default_CONF_method = (uint64_t)v4;
  }
  v6[1] = 0;
  v7 = 0;
  v6[0] = 0;
  ((void (*)(_QWORD *))v4->init)(v6);
  v7 = conf;
  return (*(uint64_t (**)(_QWORD *, BIO *))(v6[0] + 48))(v6, out);
}

int NCONF_dump_bio(const CONF *conf, BIO *out)
{
  if (conf)
    return ((uint64_t (*)(const CONF *, BIO *))conf->meth->dump)(conf, out);
  ERR_put_error(14, 4095, 105, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/conf/conf_lib.c", 370);
  return 0;
}

CONF *__cdecl NCONF_new(CONF_METHOD *meth)
{
  CONF *v1;

  if (!meth)
    meth = NCONF_default();
  v1 = (CONF *)((uint64_t (*)(void))meth->create)();
  if (!v1)
    ERR_put_error(14, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/conf/conf_lib.c", 232);
  return v1;
}

void NCONF_free(CONF *conf)
{
  if (conf)
    ((void (*)(CONF *))conf->meth->destroy)(conf);
}

int NCONF_load(CONF *conf, const char *file, uint64_t *eline)
{
  if (conf)
    return ((uint64_t (*)(CONF *, const char *, uint64_t *))conf->meth->load)(conf, file, eline);
  ERR_put_error(14, 4095, 105, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/conf/conf_lib.c", 259);
  return 0;
}

int NCONF_load_fp(CONF *conf, FILE *fp, uint64_t *eline)
{
  BIO *v5;
  BIO *v6;
  int bio;

  v5 = BIO_new_fp(fp, 0);
  if (v5)
  {
    v6 = v5;
    bio = NCONF_load_bio(conf, v5, eline);
    BIO_free(v6);
    return bio;
  }
  else
  {
    ERR_put_error(14, 4095, 7, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/conf/conf_lib.c", 273);
    return 0;
  }
}

int NCONF_dump_fp(const CONF *conf, FILE *out)
{
  BIO *v3;
  BIO *v4;
  int v5;

  v3 = BIO_new_fp(out, 0);
  if (v3)
  {
    v4 = v3;
    v5 = NCONF_dump_bio(conf, v3);
    BIO_free(v4);
    return v5;
  }
  else
  {
    ERR_put_error(14, 4095, 7, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/conf/conf_lib.c", 358);
    return 0;
  }
}

uint64_t CMS_signed_get_attr_count(uint64_t a1)
{
  return X509at_get_attr_count(*(const STACK **)(a1 + 24));
}

uint64_t CMS_signed_get_attr_by_NID(uint64_t a1, int a2, int a3)
{
  return X509at_get_attr_by_NID(*(const STACK **)(a1 + 24), a2, a3);
}

uint64_t CMS_signed_get_attr_by_OBJ(uint64_t a1, ASN1_OBJECT *a2, int a3)
{
  return X509at_get_attr_by_OBJ(*(const STACK **)(a1 + 24), a2, a3);
}

X509_ATTRIBUTE *CMS_signed_get_attr(uint64_t a1, int a2)
{
  return X509at_get_attr(*(const STACK **)(a1 + 24), a2);
}

X509_ATTRIBUTE *CMS_signed_delete_attr(uint64_t a1, int a2)
{
  return X509at_delete_attr(*(STACK **)(a1 + 24), a2);
}

BOOL CMS_signed_add1_attr(uint64_t a1, X509_ATTRIBUTE *a2)
{
  return X509at_add1_attr((STACK **)(a1 + 24), a2) != 0;
}

BOOL CMS_signed_add1_attr_by_OBJ(uint64_t a1, const ASN1_OBJECT *a2, int a3, const unsigned __int8 *a4, int a5)
{
  return X509at_add1_attr_by_OBJ((STACK **)(a1 + 24), a2, a3, a4, a5) != 0;
}

BOOL CMS_signed_add1_attr_by_NID(uint64_t a1, int a2, int a3, const unsigned __int8 *a4, int a5)
{
  return X509at_add1_attr_by_NID((STACK **)(a1 + 24), a2, a3, a4, a5) != 0;
}

BOOL CMS_signed_add1_attr_by_txt(uint64_t a1, const char *a2, int a3, const unsigned __int8 *a4, int a5)
{
  return X509at_add1_attr_by_txt((STACK **)(a1 + 24), a2, a3, a4, a5) != 0;
}

void *CMS_signed_get0_data_by_OBJ(uint64_t a1, ASN1_OBJECT *a2, int a3, int a4)
{
  return X509at_get0_data_by_OBJ(*(STACK **)(a1 + 24), a2, a3, a4);
}

uint64_t CMS_unsigned_get_attr_count(uint64_t a1)
{
  return X509at_get_attr_count(*(const STACK **)(a1 + 48));
}

uint64_t CMS_unsigned_get_attr_by_NID(uint64_t a1, int a2, int a3)
{
  return X509at_get_attr_by_NID(*(const STACK **)(a1 + 48), a2, a3);
}

uint64_t CMS_unsigned_get_attr_by_OBJ(uint64_t a1, ASN1_OBJECT *a2, int a3)
{
  return X509at_get_attr_by_OBJ(*(const STACK **)(a1 + 48), a2, a3);
}

X509_ATTRIBUTE *CMS_unsigned_get_attr(uint64_t a1, int a2)
{
  return X509at_get_attr(*(const STACK **)(a1 + 48), a2);
}

X509_ATTRIBUTE *CMS_unsigned_delete_attr(uint64_t a1, int a2)
{
  return X509at_delete_attr(*(STACK **)(a1 + 48), a2);
}

BOOL CMS_unsigned_add1_attr(uint64_t a1, X509_ATTRIBUTE *a2)
{
  return X509at_add1_attr((STACK **)(a1 + 48), a2) != 0;
}

BOOL CMS_unsigned_add1_attr_by_OBJ(uint64_t a1, const ASN1_OBJECT *a2, int a3, const unsigned __int8 *a4, int a5)
{
  return X509at_add1_attr_by_OBJ((STACK **)(a1 + 48), a2, a3, a4, a5) != 0;
}

BOOL CMS_unsigned_add1_attr_by_NID(uint64_t a1, int a2, int a3, const unsigned __int8 *a4, int a5)
{
  return X509at_add1_attr_by_NID((STACK **)(a1 + 48), a2, a3, a4, a5) != 0;
}

BOOL CMS_unsigned_add1_attr_by_txt(uint64_t a1, const char *a2, int a3, const unsigned __int8 *a4, int a5)
{
  return X509at_add1_attr_by_txt((STACK **)(a1 + 48), a2, a3, a4, a5) != 0;
}

void *CMS_unsigned_get0_data_by_OBJ(uint64_t a1, ASN1_OBJECT *a2, int a3, int a4)
{
  return X509at_get0_data_by_OBJ(*(STACK **)(a1 + 48), a2, a3, a4);
}

const EVP_MD *EVP_sha1(void)
{
  return (const EVP_MD *)&sha1_md;
}

const EVP_MD *EVP_sha224(void)
{
  return (const EVP_MD *)&sha224_md;
}

const EVP_MD *EVP_sha256(void)
{
  return (const EVP_MD *)&sha256_md;
}

const EVP_MD *EVP_sha384(void)
{
  return (const EVP_MD *)&sha384_md;
}

const EVP_MD *EVP_sha512(void)
{
  return (const EVP_MD *)&sha512_md;
}

const EVP_MD *EVP_sha512_224(void)
{
  return (const EVP_MD *)&sha512_224_md;
}

const EVP_MD *EVP_sha512_256(void)
{
  return (const EVP_MD *)&sha512_256_md;
}

uint64_t sha1_init(uint64_t a1)
{
  return SHA1_Init(*(SHA_CTX **)(a1 + 24));
}

uint64_t sha1_update(uint64_t a1, const void *a2, size_t a3)
{
  return SHA1_Update(*(SHA_CTX **)(a1 + 24), a2, a3);
}

uint64_t sha1_final(uint64_t a1, unsigned __int8 *md)
{
  return SHA1_Final(md, *(SHA_CTX **)(a1 + 24));
}

uint64_t sha224_init(uint64_t a1)
{
  return SHA224_Init(*(SHA256_CTX **)(a1 + 24));
}

uint64_t sha224_update(uint64_t a1, const void *a2, size_t a3)
{
  return SHA256_Update(*(SHA256_CTX **)(a1 + 24), a2, a3);
}

uint64_t sha224_final(uint64_t a1, unsigned __int8 *md)
{
  return SHA224_Final(md, *(SHA256_CTX **)(a1 + 24));
}

uint64_t sha256_init(uint64_t a1)
{
  return SHA256_Init(*(SHA256_CTX **)(a1 + 24));
}

uint64_t sha256_update(uint64_t a1, const void *a2, size_t a3)
{
  return SHA256_Update(*(SHA256_CTX **)(a1 + 24), a2, a3);
}

uint64_t sha256_final(uint64_t a1, unsigned __int8 *md)
{
  return SHA256_Final(md, *(SHA256_CTX **)(a1 + 24));
}

uint64_t sha384_init(uint64_t a1)
{
  return SHA384_Init(*(SHA512_CTX **)(a1 + 24));
}

uint64_t sha384_update(uint64_t a1, const void *a2, size_t a3)
{
  return SHA512_Update(*(SHA512_CTX **)(a1 + 24), a2, a3);
}

uint64_t sha384_final(uint64_t a1, unsigned __int8 *md)
{
  return SHA384_Final(md, *(SHA512_CTX **)(a1 + 24));
}

uint64_t sha512_init(uint64_t a1)
{
  return SHA512_Init(*(SHA512_CTX **)(a1 + 24));
}

uint64_t sha512_update(uint64_t a1, const void *a2, size_t a3)
{
  return SHA512_Update(*(SHA512_CTX **)(a1 + 24), a2, a3);
}

uint64_t sha512_final(uint64_t a1, unsigned __int8 *md)
{
  return SHA512_Final(md, *(SHA512_CTX **)(a1 + 24));
}

uint64_t sha512_224_init(uint64_t a1)
{
  return SHA512_224_Init(*(_QWORD *)(a1 + 24));
}

uint64_t sha512_224_update(uint64_t a1, const void *a2, size_t a3)
{
  return SHA512_224_Update(*(SHA512_CTX **)(a1 + 24), a2, a3);
}

uint64_t sha512_224_final(uint64_t a1, unsigned __int8 *md)
{
  return SHA512_224_Final(md, *(SHA512_CTX **)(a1 + 24));
}

uint64_t sha512_256_init(uint64_t a1)
{
  return SHA512_256_Init(*(_QWORD *)(a1 + 24));
}

uint64_t sha512_256_update(uint64_t a1, const void *a2, size_t a3)
{
  return SHA512_256_Update(*(SHA512_CTX **)(a1 + 24), a2, a3);
}

uint64_t sha512_256_final(uint64_t a1, unsigned __int8 *md)
{
  return SHA512_256_Final(md, *(SHA512_CTX **)(a1 + 24));
}

int (__cdecl *__cdecl sk_set_cmp_func(STACK *sk, int (__cdecl *c)(const char *const *, const char *const *)))(const char *const *, const char *const *)
{
  int (__cdecl *result)(const char *const *, const char *const *);

  result = sk->comp;
  if (result != c)
    sk->sorted = 0;
  sk->comp = c;
  return result;
}

STACK *__cdecl sk_dup(STACK *st)
{
  STACK *v2;
  STACK *v3;
  char **v4;

  v2 = sk_new(st->comp);
  v3 = v2;
  if (v2)
  {
    v4 = (char **)reallocarray(v2->data, st->num_alloc, 8uLL);
    if (v4)
    {
      v3->data = v4;
      v3->num = st->num;
      memcpy(v4, st->data, 8 * st->num);
      *(_QWORD *)&v3->sorted = *(_QWORD *)&st->sorted;
      v3->comp = st->comp;
    }
    else
    {
      free(v3->data);
      free(v3);
      return 0;
    }
  }
  return v3;
}

STACK *__cdecl sk_new(int (__cdecl *cmp)(const char *const *, const char *const *))
{
  STACK *v2;
  char **v3;
  uint64_t i;

  v2 = (STACK *)malloc_type_malloc(0x20uLL, 0x1080040FC7F6965uLL);
  if (v2 && (v3 = (char **)reallocarray(0, 4uLL, 8uLL), (v2->data = v3) != 0))
  {
    for (i = 0; i != 4; ++i)
      v2->data[i] = 0;
    v2->comp = cmp;
    v2->num = 0;
    *(_QWORD *)&v2->sorted = 0x400000000;
  }
  else
  {
    free(v2);
    return 0;
  }
  return v2;
}

void sk_free(STACK *a1)
{
  if (a1)
  {
    free(a1->data);
    free(a1);
  }
}

STACK *sk_new_null(void)
{
  return sk_new(0);
}

int sk_insert(STACK *sk, char *data, int where)
{
  STACK *v5;
  unint64_t num_alloc;
  int num;
  char **v8;

  if (sk)
  {
    v5 = sk;
    num_alloc = sk->num_alloc;
    num = sk->num;
    if ((int)num_alloc <= sk->num + 1)
    {
      sk = (STACK *)reallocarray(sk->data, num_alloc, 0x10uLL);
      if (!sk)
        return (int)sk;
      v5->data = (char **)sk;
      v5->num_alloc *= 2;
      num = v5->num;
    }
    v8 = v5->data;
    if (where < 0 || num <= where)
    {
      v8[num] = data;
    }
    else
    {
      memmove(&v8[where + 1], &v8[where], 8 * (num - where));
      v5->data[where] = data;
      num = v5->num;
    }
    LODWORD(sk) = num + 1;
    v5->num = num + 1;
    v5->sorted = 0;
  }
  return (int)sk;
}

char *__cdecl sk_delete_ptr(STACK *st, char *p)
{
  uint64_t num;
  uint64_t v3;

  num = st->num;
  if ((int)num < 1)
    return 0;
  v3 = 0;
  while (st->data[v3] != p)
  {
    if (num == ++v3)
      return 0;
  }
  return sk_delete(st, v3);
}

char *__cdecl sk_delete(STACK *st, int loc)
{
  char *v2;
  int num;
  char **data;
  char **v6;
  int v7;

  v2 = 0;
  if (st && (loc & 0x80000000) == 0)
  {
    num = st->num;
    if (st->num <= loc)
    {
      return 0;
    }
    else
    {
      data = st->data;
      v6 = &data[loc];
      v2 = *v6;
      v7 = num - 1;
      if (v7 != loc)
      {
        memmove(v6, &data[loc + 1], 8 * (v7 - loc));
        v7 = st->num - 1;
      }
      st->num = v7;
    }
  }
  return v2;
}

int sk_find(STACK *st, char *data)
{
  return internal_find(st, data, 2);
}

unint64_t internal_find(STACK *st, char *a2, int a3)
{
  const char *v6;
  unint64_t result;
  uint64_t num;
  char key[8];

  *(_QWORD *)key = a2;
  if (!st)
    return 0xFFFFFFFFLL;
  if (st->comp)
  {
    sk_sort(st);
    if (a2)
    {
      v6 = OBJ_bsearch_ex_(key, (const char *)st->data, st->num, 8, (int (__cdecl *)(const void *, const void *))st->comp, a3);
      if (v6)
        return (unint64_t)(v6 - (const char *)st->data) >> 3;
    }
    return 0xFFFFFFFFLL;
  }
  num = st->num;
  if ((int)num < 1)
    return 0xFFFFFFFFLL;
  result = 0;
  while (st->data[result] != a2)
  {
    if (num == ++result)
      return 0xFFFFFFFFLL;
  }
  return result;
}

int sk_find_ex(STACK *st, char *data)
{
  return internal_find(st, data, 1);
}

int sk_push(STACK *st, char *data)
{
  return sk_insert(st, data, st->num);
}

int sk_unshift(STACK *st, char *data)
{
  return sk_insert(st, data, 0);
}

char *__cdecl sk_shift(STACK *st)
{
  if (st && st->num >= 1)
    return sk_delete(st, 0);
  else
    return 0;
}

char *__cdecl sk_pop(STACK *st)
{
  if (st && st->num >= 1)
    return sk_delete(st, st->num - 1);
  else
    return 0;
}

void sk_zero(STACK *st)
{
  uint64_t num;

  if (st)
  {
    num = st->num;
    if ((int)num >= 1)
    {
      bzero(st->data, 8 * num);
      st->num = 0;
    }
  }
}

void sk_pop_free(STACK *st, void (__cdecl *func)(void *))
{
  int num;
  uint64_t v5;

  if (st)
  {
    num = st->num;
    if (st->num >= 1)
    {
      v5 = 0;
      do
      {
        if (st->data[v5])
        {
          ((void (*)(void))func)();
          num = st->num;
        }
        ++v5;
      }
      while (v5 < num);
    }
    free(st->data);
    free(st);
  }
}

int sk_num(const STACK *a1)
{
  if (a1)
    return a1->num;
  else
    return -1;
}

char *__cdecl sk_value(const STACK *a1, int a2)
{
  char *result;

  result = 0;
  if (a1 && (a2 & 0x80000000) == 0)
  {
    if (a1->num <= a2)
      return 0;
    else
      return a1->data[a2];
  }
  return result;
}

char *__cdecl sk_set(STACK *a1, int a2, char *a3)
{
  char *v3;

  v3 = 0;
  if (a1 && (a2 & 0x80000000) == 0)
  {
    if (a1->num <= a2)
    {
      return 0;
    }
    else
    {
      a1->sorted = 0;
      a1->data[a2] = a3;
      return a3;
    }
  }
  return v3;
}

void sk_sort(STACK *st)
{
  if (st)
  {
    if (!st->sorted)
    {
      qsort(st->data, st->num, 8uLL, (int (__cdecl *)(const void *, const void *))st->comp);
      st->sorted = 1;
    }
  }
}

int sk_is_sorted(const STACK *st)
{
  if (!st || st->sorted)
    return 1;
  if (st->comp)
    return st->num < 2;
  return 0;
}

void *EVP_idea_cbc()
{
  return &idea_cbc;
}

void *EVP_idea_cfb64()
{
  return &idea_cfb64;
}

void *EVP_idea_ofb()
{
  return &idea_ofb;
}

void *EVP_idea_ecb()
{
  return &idea_ecb;
}

uint64_t idea_init_key(EVP_CIPHER_CTX *ctx, unint64_t a2, uint64_t a3, int a4)
{
  _OWORD v7[13];
  uint64_t v8;

  if (a4 || (EVP_CIPHER_CTX_flags(ctx) & 0xF0007) == 4 || (EVP_CIPHER_CTX_flags(ctx) & 0xF0007) == 3)
  {
    idea_set_encrypt_key(a2, (int *)ctx->cipher_data);
  }
  else
  {
    v8 = 0;
    memset(v7, 0, sizeof(v7));
    idea_set_encrypt_key(a2, (int *)v7);
    idea_set_decrypt_key((uint64_t)v7, (uint64_t)ctx->cipher_data);
    explicit_bzero(v7, 0xD8uLL);
  }
  return 1;
}

uint64_t idea_cbc_cipher(uint64_t a1, _DWORD *a2, unsigned int *a3, unint64_t a4)
{
  unint64_t i;

  for (i = a4; i > 0x7FFFFFFFFFFFFEFFLL; a2 += 0x1FFFFFFFFFFFFFC0)
  {
    idea_cbc_encrypt(a3, a2, 0x7FFFFFFFFFFFFF00, *(unsigned int **)(a1 + 120), a1 + 40, *(_DWORD *)(a1 + 16));
    i -= 0x7FFFFFFFFFFFFF00;
    a3 += 0x1FFFFFFFFFFFFFC0;
  }
  if (i)
    idea_cbc_encrypt(a3, a2, i, *(unsigned int **)(a1 + 120), a1 + 40, *(_DWORD *)(a1 + 16));
  return 1;
}

uint64_t idea_cfb64_cipher(uint64_t a1, _BYTE *a2, unint64_t *a3, unint64_t a4)
{
  unint64_t v4;
  unint64_t v8;
  unsigned int *v9;
  int *v10;

  if (a4)
  {
    v4 = a4;
    if (a4 >= 0x7FFFFFFFFFFFFF00)
      v8 = 0x7FFFFFFFFFFFFF00;
    else
      v8 = a4;
    v9 = (unsigned int *)(a1 + 40);
    v10 = (int *)(a1 + 88);
    do
    {
      idea_cfb64_encrypt(a3, a2, v8, *(unsigned int **)(a1 + 120), v9, v10, *(_DWORD *)(a1 + 16));
      a3 = (unint64_t *)((char *)a3 + v8);
      a2 += v8;
      v4 -= v8;
      if (v4 < v8)
        v8 = v4;
    }
    while (v4);
  }
  return 1;
}

uint64_t idea_ofb_cipher(uint64_t a1, _BYTE *a2, unint64_t *a3, unint64_t a4)
{
  unint64_t i;

  for (i = a4; i > 0x7FFFFFFFFFFFFEFFLL; a2 += 0x7FFFFFFFFFFFFF00)
  {
    idea_ofb64_encrypt(a3, a2, 0x7FFFFFFFFFFFFF00, *(unsigned int **)(a1 + 120), (unsigned __int8 *)(a1 + 40), (int *)(a1 + 88));
    i -= 0x7FFFFFFFFFFFFF00;
    a3 += 0xFFFFFFFFFFFFFE0;
  }
  if (i)
    idea_ofb64_encrypt(a3, a2, i, *(unsigned int **)(a1 + 120), (unsigned __int8 *)(a1 + 40), (int *)(a1 + 88));
  return 1;
}

uint64_t idea_ecb_cipher(unsigned int **a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  unint64_t v4;
  unint64_t v5;
  unint64_t v9;

  v4 = (int)(*a1)[1];
  v5 = a4 - v4;
  if (a4 >= v4)
  {
    v9 = 0;
    do
    {
      idea_ecb_encrypt((unsigned int *)(a3 + v9), (_DWORD *)(a2 + v9), a1[15]);
      v9 += v4;
    }
    while (v9 <= v5);
  }
  return 1;
}

int BN_exp(BIGNUM *r, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx)
{
  _BOOL4 v8;
  BIGNUM *v9;
  BIGNUM *v10;
  BIGNUM *v11;
  int v12;

  if (!BN_get_flags((uint64_t)p, 4u))
  {
    BN_CTX_start(ctx);
    v9 = BN_CTX_get(ctx);
    if (v9)
    {
      v10 = v9;
      if (r == a || (v11 = r, r == p))
      {
        v11 = BN_CTX_get(ctx);
        if (!v11)
          goto LABEL_20;
      }
      else if (!r)
      {
        goto LABEL_20;
      }
      if (BN_one((uint64_t)v11)
        && (!BN_is_odd((uint64_t)p) || bn_copy(v11, a))
        && bn_copy(v10, a))
      {
        if (BN_num_bits(p) < 2)
        {
LABEL_19:
          v8 = bn_copy(r, v11);
LABEL_21:
          BN_CTX_end(ctx);
          return v8;
        }
        v12 = 1;
        while (BN_sqr(v10, v10, ctx) && (!BN_is_bit_set(p, v12) || BN_mul(v11, v11, v10, ctx)))
        {
          if (++v12 >= BN_num_bits(p))
            goto LABEL_19;
        }
      }
    }
LABEL_20:
    v8 = 0;
    goto LABEL_21;
  }
  ERR_put_error(3, 4095, 66, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/bn/bn_exp.c", 132);
  return -1;
}

int BN_mod_exp_simple(BIGNUM *r, const BIGNUM *a, const BIGNUM *p, const BIGNUM *m, BN_CTX *ctx)
{
  BIGNUM *v10;
  int v11;
  int v12;
  BIGNUM *v13;
  const BIGNUM *v14;
  unsigned int v16;
  uint64_t v17;
  BIGNUM *v18;
  int v20;
  char v21;
  int v22;
  int v23;
  int v24;
  int i;
  int is_bit_set;
  int v27;
  int v28;
  char v29;
  BIGNUM *v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  uint64_t v46;
  uint64_t v47;

  v47 = *MEMORY[0x24BDAC8D0];
  if (BN_get_flags((uint64_t)p, 4u))
  {
    ERR_put_error(3, 4095, 66, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/bn/bn_exp.c", 190);
    LODWORD(v10) = -1;
    return (int)v10;
  }
  v11 = BN_num_bits(p);
  if (v11)
  {
    v12 = v11;
    BN_CTX_start(ctx);
    v10 = BN_CTX_get(ctx);
    if (!v10)
    {
LABEL_51:
      BN_CTX_end(ctx);
      return (int)v10;
    }
    v13 = BN_CTX_get(ctx);
    v30 = v13;
    if (v13)
    {
      v14 = v13;
      if (BN_nnmod(v13, a, m, ctx))
      {
        if (BN_is_zero((uint64_t)v14))
        {
          BN_zero((uint64_t)r);
LABEL_9:
          LODWORD(v10) = 1;
          goto LABEL_51;
        }
        v46 = 0;
        v44 = 0u;
        v45 = 0u;
        v42 = 0u;
        v43 = 0u;
        v40 = 0u;
        v41 = 0u;
        v38 = 0u;
        v39 = 0u;
        v36 = 0u;
        v37 = 0u;
        v34 = 0u;
        v35 = 0u;
        v32 = 0u;
        v33 = 0u;
        v31 = 0u;
        if (v12 > 671)
        {
          v16 = 6;
          goto LABEL_21;
        }
        if (v12 > 239)
        {
          v16 = 5;
          goto LABEL_21;
        }
        if (v12 > 79)
        {
          v16 = 4;
          goto LABEL_21;
        }
        if (v12 >= 24)
        {
          v16 = 3;
LABEL_21:
          if (BN_mod_mul(v10, v14, v14, m, ctx))
          {
            v17 = 0;
            while (1)
            {
              v18 = BN_CTX_get(ctx);
              *(&v30 + v17 + 1) = v18;
              if (!v18 || !BN_mod_mul(v18, *(&v30 + v17), v10, m, ctx))
                break;
              if ((v17++ + 2) >> (v16 - 1))
                goto LABEL_28;
            }
          }
          goto LABEL_50;
        }
        v16 = 1;
LABEL_28:
        if (BN_one((uint64_t)r))
        {
          LOBYTE(v10) = 0;
          v20 = v12 - 1;
          v21 = 1;
          while (1)
          {
            while (!BN_is_bit_set(p, v20))
            {
              if ((v10 & 1) != 0 && !BN_mod_mul(r, r, r, m, ctx))
                goto LABEL_50;
              if (!v20)
                goto LABEL_9;
              --v20;
            }
            v29 = v21;
            if (v16 < 2)
            {
              v22 = 0;
              v24 = 1;
            }
            else
            {
              v22 = 0;
              v23 = v20 - 1;
              v24 = 1;
              for (i = 1; i != v16; ++i)
              {
                if (v23 < 0)
                  break;
                is_bit_set = BN_is_bit_set(p, v23);
                v27 = (v24 << (i - v22)) | 1;
                if (is_bit_set)
                {
                  v22 = i;
                  v24 = v27;
                }
                --v23;
              }
            }
            if (!(v29 & 1 | (v22 < 0)))
              break;
LABEL_47:
            if (!BN_mod_mul(r, r, *(&v30 + (v24 >> 1)), m, ctx))
              goto LABEL_50;
            v21 = 0;
            LODWORD(v10) = 1;
            v20 += ~v22;
            if (v20 < 0)
              goto LABEL_51;
          }
          v28 = v22 + 1;
          while (BN_mod_mul(r, r, r, m, ctx))
          {
            if (!--v28)
              goto LABEL_47;
          }
        }
      }
    }
LABEL_50:
    LODWORD(v10) = 0;
    goto LABEL_51;
  }
  if (!BN_abs_is_word((uint64_t)m, 1))
    return BN_one((uint64_t)r);
  BN_zero((uint64_t)r);
  LODWORD(v10) = 1;
  return (int)v10;
}

int BN_mod_exp_mont_consttime(BIGNUM *rr, const BIGNUM *a, const BIGNUM *p, const BIGNUM *m, BN_CTX *ctx, BN_MONT_CTX *in_mont)
{
  size_t top;
  int v13;
  int v14;
  BN_MONT_CTX *v15;
  int v16;
  int v17;
  int v18;
  int v19;
  unsigned int v20;
  int v21;
  uint64_t v22;
  BN_MONT_CTX *v23;
  const BIGNUM *v24;
  uint64_t v25;
  unint64_t *d;
  _QWORD *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t *v31;
  _QWORD *v32;
  uint64_t v33;
  uint64_t v34;
  unint64_t *v35;
  _QWORD *v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  unint64_t *v42;
  _QWORD *v43;
  uint64_t v44;
  int v45;
  int v46;
  int v47;
  int v48;
  int v49;
  int v50;
  _BOOL4 v51;
  int v52;
  BN_MONT_CTX *v53;
  uint64_t v55;
  uint64_t v56;
  BIGNUM *v57;
  BN_MONT_CTX *v58;
  int v59;
  BIGNUM r;
  BIGNUM b;

  if (BN_is_odd((uint64_t)m))
  {
    top = m->top;
    v13 = BN_num_bits(p);
    if (v13)
    {
      v14 = v13;
      memset(&b, 0, sizeof(b));
      memset(&r, 0, sizeof(r));
      BN_CTX_start(ctx);
      v15 = in_mont;
      if (!in_mont)
      {
        v23 = BN_MONT_CTX_new();
        if (!v23)
        {
          v52 = 0;
          v51 = 0;
LABEL_78:
          freezero(v23, v52 + 64);
          BN_CTX_end(ctx);
          return v51;
        }
        v15 = v23;
        if (!BN_MONT_CTX_set(v23, m, ctx))
        {
          v51 = 0;
          v23 = 0;
          v52 = 0;
          goto LABEL_73;
        }
      }
      v57 = rr;
      if (v14 <= 22)
        v16 = 1;
      else
        v16 = 3;
      if (v14 <= 89)
        v17 = v16;
      else
        v17 = 4;
      if (v14 <= 306)
        v18 = v17;
      else
        v18 = 5;
      if (v14 <= 937)
        v19 = v18;
      else
        v19 = 6;
      v20 = 1 << v19;
      v21 = 2 * top;
      if (2 * (int)top <= 1 << v19)
        v21 = 1 << v19;
      v22 = v21 + ((_DWORD)top << v19);
      v59 = 8 * v22;
      v23 = (BN_MONT_CTX *)malloc_type_calloc(((v22 << 35) + 0x4000000000) >> 32, 1uLL, 0xC562F41FuLL);
      if (!v23)
      {
        v51 = 0;
        v52 = v59;
LABEL_73:
        if (!in_mont)
        {
          if (v15)
          {
            v53 = v23;
            BN_MONT_CTX_free(v15);
            v23 = v53;
          }
        }
        goto LABEL_78;
      }
      v58 = v23;
      v56 = ((unint64_t)v23 & 0xFFFFFFFFFFFFFFC0) + 64;
      b.d = (unint64_t *)(v56 + ((8 * (int)top) << v19));
      r.d = &b.d[(int)top];
      r.top = 0;
      r.dmax = top;
      b.top = 0;
      b.dmax = top;
      *(_QWORD *)&r.neg = 0x200000000;
      *(_QWORD *)&b.neg = 0x200000000;
      v24 = BN_value_one();
      if (BN_to_montgomery(&b, v24, (uint64_t)v15, ctx)
        && BN_nnmod(&r, a, m, ctx)
        && BN_to_montgomery(&r, &r, (uint64_t)v15, ctx))
      {
        if (b.top >= (int)top)
          v25 = top;
        else
          v25 = b.top;
        if ((int)v25 >= 1)
        {
          d = b.d;
          v27 = (_QWORD *)v56;
          do
          {
            v28 = *d++;
            *v27 = v28;
            v27 += (1 << v19);
            --v25;
          }
          while (v25);
        }
        v29 = v58 & 0x3F;
        if (r.top >= (int)top)
          v30 = top;
        else
          v30 = r.top;
        if ((int)v30 >= 1)
        {
          v31 = r.d;
          v32 = (_QWORD *)((char *)&v58->Ni.neg - v29);
          do
          {
            v33 = *v31++;
            *v32 = v33;
            v32 += (1 << v19);
            --v30;
          }
          while (v30);
        }
        if (v19 < 2)
        {
LABEL_54:
          v45 = v14 - 1;
          v46 = 0;
          v47 = (v14 - 1) % v19;
          if ((v47 & 0x80000000) == 0)
          {
            v48 = v47 + 1;
            do
            {
              v46 = BN_is_bit_set(p, v45--) + 2 * v46;
              --v48;
            }
            while (v48);
          }
          if (MOD_EXP_CTIME_COPY_FROM_PREBUF((uint64_t)&b, top, v56, v46, v19))
          {
LABEL_58:
            if (v45 < 0)
            {
              v51 = BN_from_montgomery(v57, &b, v15, ctx) != 0;
              goto LABEL_65;
            }
            v49 = 0;
            v50 = 0;
            while (BN_mod_mul_montgomery(&b, &b, &b, v15, ctx))
            {
              v50 = BN_is_bit_set(p, v45 + v49--) + 2 * v50;
              if (!(v19 + v49))
              {
                if (MOD_EXP_CTIME_COPY_FROM_PREBUF((uint64_t)&r, top, v56, v50, v19))
                {
                  v45 += v49;
                  if (BN_mod_mul_montgomery(&b, &b, &r, v15, ctx))
                    goto LABEL_58;
                }
                break;
              }
            }
          }
        }
        else if (BN_mod_mul_montgomery(&b, &r, &r, v15, ctx))
        {
          if (b.top >= (int)top)
            v34 = top;
          else
            v34 = b.top;
          if ((int)v34 >= 1)
          {
            v35 = b.d;
            v36 = (unint64_t *)((char *)&v58->n0 - v29);
            do
            {
              v37 = *v35++;
              *v36 = v37;
              v36 += (1 << v19);
              --v34;
            }
            while (v34);
          }
          if (v20 <= 4)
            v38 = 4;
          else
            v38 = v20;
          v55 = v38;
          v39 = (uint64_t)&v58->flags - v29;
          v40 = 3;
          while (BN_mod_mul_montgomery(&b, &r, &b, v15, ctx))
          {
            if (b.top >= (int)top)
              v41 = top;
            else
              v41 = b.top;
            if ((int)v41 >= 1)
            {
              v42 = b.d;
              v43 = (_QWORD *)v39;
              do
              {
                v44 = *v42++;
                *v43 = v44;
                v43 += (1 << v19);
                --v41;
              }
              while (v41);
            }
            ++v40;
            v39 += 8;
            if (v40 == v55)
              goto LABEL_54;
          }
        }
      }
      v51 = 0;
LABEL_65:
      v23 = v58;
      v52 = v59;
      goto LABEL_73;
    }
    if (!BN_abs_is_word((uint64_t)m, 1))
      return BN_one((uint64_t)rr);
    BN_zero((uint64_t)rr);
    return 1;
  }
  else
  {
    ERR_put_error(3, 4095, 102, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/bn/bn_exp.c", 396);
    return 0;
  }
}

uint64_t MOD_EXP_CTIME_COPY_FROM_PREBUF(uint64_t a1, size_t a2, uint64_t a3, int a4, int a5)
{
  int v8;
  uint64_t result;
  uint64_t v11;
  BOOL v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  int v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;

  v8 = a2;
  result = bn_wexpand(a1, a2);
  if ((_DWORD)result)
  {
    v11 = (1 << a5);
    if (a5 > 3)
    {
      if (v8 >= 1)
      {
        v18 = 0;
        v19 = (1 << (a5 - 2));
        v20 = (v19 - 1) & a4;
        v21 = a4 >> (a5 - 2);
        v22 = 8 * (1 << a5);
        v23 = *(_QWORD *)a1;
        v24 = a3 + 8 * (3 << (a5 - 2));
        v25 = a3 + 8 * (2 << (a5 - 2));
        v26 = a3 + 8 * (int)v19;
        do
        {
          v27 = 0;
          v28 = 0;
          do
          {
            v29 = *(_QWORD *)(a3 + 8 * v27);
            if (v21)
              v29 = 0;
            v30 = *(_QWORD *)(v26 + 8 * v27);
            if ((((v21 ^ 1) - 1) & ~v21) >= 0)
              v30 = 0;
            v31 = v30 | v29;
            v32 = *(_QWORD *)(v25 + 8 * v27);
            v33 = *(_QWORD *)(v24 + 8 * v27);
            if ((((v21 ^ 2) - 1) & ~v21) >= 0)
              v32 = 0;
            if ((((v21 ^ 3) - 1) & ~v21) >= 0)
              v33 = 0;
            v34 = v31 | v32 | v33;
            if ((int)(((v20 ^ v27) - 1) & ~v20) >= 0)
              v34 = 0;
            v28 |= v34;
            ++v27;
          }
          while (v19 != v27);
          *(_QWORD *)(v23 + 8 * v18++) = v28;
          v24 += v22;
          v25 += v22;
          v26 += v22;
          a3 += v22;
        }
        while (v18 != v8);
      }
    }
    else
    {
      v12 = __OFSUB__(v8, 1);
      if (v8 >= 1)
      {
        v13 = 0;
        v14 = *(_QWORD *)a1;
        do
        {
          v15 = 0;
          v16 = 0;
          do
          {
            v17 = *(_QWORD *)(a3 + 8 * v15);
            if ((int)(((v15 ^ a4) - 1) & ~a4) < 0 == v12)
              v17 = 0;
            v16 |= v17;
            v12 = __OFSUB__(v11, ++v15);
          }
          while (v11 != v15);
          *(_QWORD *)(v14 + 8 * v13++) = v16;
          a3 += 8 * (1 << a5);
          v12 = __OFSUB__(v13, v8);
        }
        while (v13 != v8);
      }
    }
    *(_DWORD *)(a1 + 8) = v8;
    bn_correct_top((uint64_t *)a1);
    return 1;
  }
  return result;
}

int BN_mod_exp_mont(BIGNUM *r, const BIGNUM *a, const BIGNUM *p, const BIGNUM *m, BN_CTX *ctx, BN_MONT_CTX *m_ctx)
{
  _BOOL4 v12;

  v12 = BN_get_flags((uint64_t)p, 4u) != 0;
  return BN_mod_exp_mont_internal(r, (BIGNUM *)a, (BIGNUM *)p, (BIGNUM *)m, ctx, m_ctx, v12);
}

uint64_t BN_mod_exp_mont_internal(BIGNUM *rr, BIGNUM *a, BIGNUM *p, BIGNUM *m, BN_CTX *ctx, BN_MONT_CTX *in_mont, int a7)
{
  int v14;
  int v15;
  BIGNUM *v16;
  BIGNUM *v17;
  BIGNUM *v18;
  BIGNUM *v19;
  BIGNUM *v20;
  BIGNUM *v21;
  BN_MONT_CTX *v22;
  _BOOL8 v23;
  BN_MONT_CTX *v24;
  int v25;
  uint64_t v26;
  BIGNUM *v27;
  const BIGNUM *v29;
  char v30;
  int v31;
  char v32;
  int v33;
  int v34;
  int v35;
  int i;
  int is_bit_set;
  int v38;
  int v39;
  char v40;
  unsigned int v41;
  BN_MONT_CTX *mont;
  BIGNUM *v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  uint64_t v59;
  uint64_t v60;

  v60 = *MEMORY[0x24BDAC8D0];
  if (a7)
    return BN_mod_exp_mont_consttime(rr, a, p, m, ctx, in_mont);
  if (BN_is_odd((uint64_t)m))
  {
    v14 = BN_num_bits(p);
    if (v14)
    {
      v15 = v14;
      BN_CTX_start(ctx);
      v16 = BN_CTX_get(ctx);
      if (v16)
      {
        v17 = v16;
        v18 = BN_CTX_get(ctx);
        if (v18)
        {
          v19 = v18;
          v20 = BN_CTX_get(ctx);
          v43 = v20;
          if (v20)
          {
            v21 = v20;
            mont = in_mont;
            if (in_mont)
            {
LABEL_9:
              if (BN_nnmod(v21, a, m, ctx))
              {
                v22 = mont;
                if (BN_is_zero((uint64_t)v21))
                {
                  BN_zero((uint64_t)rr);
                  v23 = 1;
                  goto LABEL_61;
                }
                if (!BN_to_montgomery(v21, v21, (uint64_t)mont, ctx))
                  goto LABEL_60;
                v59 = 0;
                v57 = 0u;
                v58 = 0u;
                v55 = 0u;
                v56 = 0u;
                v53 = 0u;
                v54 = 0u;
                v51 = 0u;
                v52 = 0u;
                v49 = 0u;
                v50 = 0u;
                v47 = 0u;
                v48 = 0u;
                v45 = 0u;
                v46 = 0u;
                v44 = 0u;
                if (v15 <= 671)
                {
                  if (v15 <= 239)
                  {
                    if (v15 <= 79)
                    {
                      if (v15 < 24)
                      {
                        v41 = 1;
LABEL_38:
                        v29 = BN_value_one();
                        if (BN_to_montgomery(v19, v29, (uint64_t)v22, ctx))
                        {
                          v30 = 0;
                          v31 = v15 - 1;
                          v32 = 1;
                          while (1)
                          {
                            while (!BN_is_bit_set(p, v31))
                            {
                              if ((v30 & 1) != 0 && !BN_mod_mul_montgomery(v19, v19, v19, v22, ctx))
                                goto LABEL_60;
                              if (!v31)
                              {
LABEL_59:
                                v23 = BN_from_montgomery(rr, v19, v22, ctx) != 0;
                                goto LABEL_61;
                              }
                              --v31;
                            }
                            v40 = v32;
                            if (v41 < 2)
                            {
                              v33 = 0;
                              v35 = 1;
                            }
                            else
                            {
                              v33 = 0;
                              v34 = v31 - 1;
                              v35 = 1;
                              for (i = 1; i != v41; ++i)
                              {
                                if (v34 < 0)
                                  break;
                                is_bit_set = BN_is_bit_set(p, v34);
                                v38 = (v35 << (i - v33)) | 1;
                                if (is_bit_set)
                                {
                                  v33 = i;
                                  v35 = v38;
                                }
                                --v34;
                              }
                            }
                            v22 = mont;
                            if (!(v40 & 1 | (v33 < 0)))
                              break;
LABEL_57:
                            if (!BN_mod_mul_montgomery(v19, v19, *(&v43 + (v35 >> 1)), mont, ctx))
                              goto LABEL_60;
                            v32 = 0;
                            v30 = 1;
                            v31 += ~v33;
                            if (v31 < 0)
                              goto LABEL_59;
                          }
                          v39 = v33 + 1;
                          while (BN_mod_mul_montgomery(v19, v19, v19, mont, ctx))
                          {
                            if (!--v39)
                              goto LABEL_57;
                          }
                        }
                        goto LABEL_60;
                      }
                      v25 = 3;
                    }
                    else
                    {
                      v25 = 4;
                    }
                  }
                  else
                  {
                    v25 = 5;
                  }
                }
                else
                {
                  v25 = 6;
                }
                v41 = v25;
                if (BN_mod_mul_montgomery(v17, v21, v21, mont, ctx))
                {
                  v26 = 0;
                  while (1)
                  {
                    v27 = BN_CTX_get(ctx);
                    *(&v43 + v26 + 1) = v27;
                    if (!v27 || !BN_mod_mul_montgomery(v27, *(&v43 + v26), v17, mont, ctx))
                      goto LABEL_18;
                    if ((v26++ + 2) >> (v41 - 1))
                    {
                      v22 = mont;
                      goto LABEL_38;
                    }
                  }
                }
LABEL_60:
                v23 = 0;
LABEL_61:
                if (!in_mont)
                {
                  if (v22)
                    BN_MONT_CTX_free(v22);
                }
                goto LABEL_20;
              }
LABEL_18:
              v23 = 0;
              v22 = mont;
              goto LABEL_61;
            }
            v24 = BN_MONT_CTX_new();
            if (v24)
            {
              mont = v24;
              if (!BN_MONT_CTX_set(v24, m, ctx))
                goto LABEL_18;
              goto LABEL_9;
            }
          }
        }
      }
      v23 = 0;
LABEL_20:
      BN_CTX_end(ctx);
      return v23;
    }
    if (!BN_abs_is_word((uint64_t)m, 1))
      return BN_one((uint64_t)rr);
    BN_zero((uint64_t)rr);
    return 1;
  }
  else
  {
    ERR_put_error(3, 4095, 102, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/bn/bn_exp.c", 654);
    return 0;
  }
}

uint64_t BN_mod_exp_mont_nonct(BIGNUM *a1, BIGNUM *a2, BIGNUM *a3, BIGNUM *a4, BN_CTX *a5, BN_MONT_CTX *a6)
{
  return BN_mod_exp_mont_internal(a1, a2, a3, a4, a5, a6, 0);
}

int BN_mod_exp_mont_word(BIGNUM *r, unint64_t a, const BIGNUM *p, const BIGNUM *m, BN_CTX *ctx, BN_MONT_CTX *m_ctx)
{
  int v12;
  int v14;
  int v15;
  BIGNUM *v16;
  BIGNUM *v17;
  BIGNUM *v18;
  BN_MONT_CTX *v19;
  unint64_t v20;
  BIGNUM *v21;
  const BIGNUM *v22;
  int v23;
  BN_MONT_CTX *v24;
  int v25;
  char v26;
  BN_MONT_CTX *mont;
  BIGNUM *v28;
  int v29;

  if (BN_get_flags((uint64_t)p, 4u))
  {
    ERR_put_error(3, 4095, 66, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/bn/bn_exp.c", 831);
    return -1;
  }
  if (!BN_is_odd((uint64_t)m))
  {
    ERR_put_error(3, 4095, 102, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/bn/bn_exp.c", 837);
    return 0;
  }
  if (m->top == 1)
    a %= *m->d;
  v14 = BN_num_bits(p);
  if (!v14)
  {
    if (!BN_abs_is_word((uint64_t)m, 1))
      return BN_one((uint64_t)r);
LABEL_43:
    BN_zero((uint64_t)r);
    return 1;
  }
  if (!a)
    goto LABEL_43;
  v15 = v14;
  BN_CTX_start(ctx);
  if (!BN_CTX_get(ctx))
    goto LABEL_51;
  v16 = BN_CTX_get(ctx);
  if (!v16)
    goto LABEL_51;
  v17 = v16;
  v18 = BN_CTX_get(ctx);
  if (!v18)
    goto LABEL_51;
  v28 = v18;
  v19 = m_ctx;
  if (!m_ctx)
  {
    v24 = BN_MONT_CTX_new();
    if (v24)
    {
      v19 = v24;
      if (!BN_MONT_CTX_set(v24, m, ctx))
      {
LABEL_64:
        v12 = 0;
        goto LABEL_67;
      }
      goto LABEL_13;
    }
LABEL_51:
    v12 = 0;
    goto LABEL_52;
  }
LABEL_13:
  if (v15 < 2)
  {
    if (a == 1)
    {
LABEL_46:
      if (BN_one((uint64_t)r))
        goto LABEL_61;
    }
    else
    {
LABEL_58:
      if (BN_set_word(v17, a) && BN_to_montgomery(v17, v17, (uint64_t)v19, ctx))
        goto LABEL_60;
    }
    goto LABEL_64;
  }
  mont = v19;
  v29 = v15 - 1;
  v12 = 1;
  v20 = a;
  do
  {
    if (is_mul_ok(v20, v20))
    {
      v20 *= v20;
      if (v12)
      {
        v26 = 0;
        goto LABEL_29;
      }
      v21 = v28;
    }
    else
    {
      if (v12)
      {
        if (!BN_set_word(v17, v20))
          goto LABEL_65;
        v19 = mont;
        if (!BN_to_montgomery(v17, v17, (uint64_t)mont, ctx))
          goto LABEL_64;
        v21 = v28;
      }
      else
      {
        if (!BN_mul_word(v17, v20) || !BN_mod_ct(v28, v17, m, ctx))
          goto LABEL_65;
        v21 = v17;
        v17 = v28;
      }
      v20 = 1;
    }
    v12 = 0;
    if (!BN_mod_mul_montgomery(v17, v17, v17, mont, ctx))
      goto LABEL_66;
    v26 = 1;
    v28 = v21;
LABEL_29:
    v22 = v17;
    if (BN_is_bit_set(p, --v29))
    {
      if (is_mul_ok(a, v20))
      {
        v20 *= a;
      }
      else if ((v26 & 1) != 0)
      {
        if (!BN_mul_word(v17, v20))
          goto LABEL_65;
        v17 = v28;
        v23 = BN_mod_ct(v28, v22, m, ctx);
        v12 = 0;
        v20 = a;
        v28 = (BIGNUM *)v22;
        if (!v23)
          goto LABEL_66;
      }
      else
      {
        if (!BN_set_word(v17, v20))
          goto LABEL_65;
        v12 = 0;
        v20 = a;
        if (!BN_to_montgomery(v17, v17, (uint64_t)mont, ctx))
          goto LABEL_66;
      }
    }
  }
  while (v29 > 0);
  if (v20 != 1)
  {
    if (v12)
    {
      a = v20;
      v19 = mont;
      goto LABEL_58;
    }
    if (!BN_mul_word(v17, v20))
    {
LABEL_65:
      v12 = 0;
LABEL_66:
      v19 = mont;
      goto LABEL_67;
    }
    v25 = BN_mod_ct(v28, v17, m, ctx);
    v17 = v28;
    v19 = mont;
    if (v25)
      goto LABEL_60;
    goto LABEL_64;
  }
  v19 = mont;
  if (v12)
    goto LABEL_46;
LABEL_60:
  if (!BN_from_montgomery(r, v17, v19, ctx))
    goto LABEL_64;
LABEL_61:
  v12 = 1;
LABEL_67:
  if (!m_ctx)
  {
    if (v19)
      BN_MONT_CTX_free(v19);
  }
LABEL_52:
  BN_CTX_end(ctx);
  return v12;
}

int BN_mod_exp_recp(BIGNUM *r, const BIGNUM *a, const BIGNUM *p, const BIGNUM *m, BN_CTX *ctx)
{
  BIGNUM *v10;
  int v11;
  int v12;
  BIGNUM *v13;
  BIGNUM *v14;
  const BIGNUM *v15;
  unsigned int v17;
  uint64_t v18;
  BIGNUM *v19;
  int v21;
  char v22;
  int v23;
  int v24;
  int v25;
  int i;
  int is_bit_set;
  int v28;
  int v29;
  BN_RECP_CTX v30;
  BIGNUM *v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  uint64_t v47;
  uint64_t v48;

  v48 = *MEMORY[0x24BDAC8D0];
  if (BN_get_flags((uint64_t)p, 4u))
  {
    ERR_put_error(3, 4095, 66, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/bn/bn_exp.c", 964);
    LODWORD(v10) = -1;
    return (int)v10;
  }
  v11 = BN_num_bits(p);
  if (v11)
  {
    v12 = v11;
    memset(&v30, 0, sizeof(v30));
    BN_RECP_CTX_init(&v30);
    BN_CTX_start(ctx);
    v10 = BN_CTX_get(ctx);
    if (!v10)
    {
LABEL_56:
      BN_CTX_end(ctx);
      BN_RECP_CTX_free(&v30);
      return (int)v10;
    }
    v13 = BN_CTX_get(ctx);
    v31 = v13;
    if (v13)
    {
      v14 = v13;
      if (m->neg)
      {
        if (!bn_copy(v10, m))
          goto LABEL_55;
        v10->neg = 0;
        v15 = v10;
      }
      else
      {
        v15 = m;
      }
      if (BN_RECP_CTX_set(&v30, v15, ctx) >= 1 && BN_nnmod(v14, a, m, ctx))
      {
        if (BN_is_zero((uint64_t)v14))
        {
          BN_zero((uint64_t)r);
LABEL_17:
          LODWORD(v10) = 1;
          goto LABEL_56;
        }
        v47 = 0;
        v45 = 0u;
        v46 = 0u;
        v43 = 0u;
        v44 = 0u;
        v41 = 0u;
        v42 = 0u;
        v39 = 0u;
        v40 = 0u;
        v37 = 0u;
        v38 = 0u;
        v35 = 0u;
        v36 = 0u;
        v33 = 0u;
        v34 = 0u;
        v32 = 0u;
        if (v12 > 671)
        {
          v17 = 6;
          goto LABEL_26;
        }
        if (v12 > 239)
        {
          v17 = 5;
          goto LABEL_26;
        }
        if (v12 > 79)
        {
          v17 = 4;
          goto LABEL_26;
        }
        if (v12 >= 24)
        {
          v17 = 3;
LABEL_26:
          if (BN_mod_mul_reciprocal(v10, v14, v14, &v30, ctx))
          {
            v18 = 0;
            while (1)
            {
              v19 = BN_CTX_get(ctx);
              *(&v31 + v18 + 1) = v19;
              if (!v19 || !BN_mod_mul_reciprocal(v19, *(&v31 + v18), v10, &v30, ctx))
                break;
              if ((v18++ + 2) >> (v17 - 1))
                goto LABEL_33;
            }
          }
          goto LABEL_55;
        }
        v17 = 1;
LABEL_33:
        if (BN_one((uint64_t)r))
        {
          LOBYTE(v10) = 0;
          v21 = v12 - 1;
          v22 = 1;
          while (1)
          {
            while (!BN_is_bit_set(p, v21))
            {
              if ((v10 & 1) != 0 && !BN_mod_mul_reciprocal(r, r, r, &v30, ctx))
                goto LABEL_55;
              if (!v21)
                goto LABEL_17;
              --v21;
            }
            if (v17 < 2)
            {
              v23 = 0;
              v25 = 1;
            }
            else
            {
              v23 = 0;
              v24 = v21 - 1;
              v25 = 1;
              for (i = 1; i != v17; ++i)
              {
                if (v24 < 0)
                  break;
                is_bit_set = BN_is_bit_set(p, v24);
                v28 = (v25 << (i - v23)) | 1;
                if (is_bit_set)
                {
                  v23 = i;
                  v25 = v28;
                }
                --v24;
              }
            }
            if (!(v22 & 1 | (v23 < 0)))
              break;
LABEL_52:
            if (!BN_mod_mul_reciprocal(r, r, *(&v31 + (v25 >> 1)), &v30, ctx))
              goto LABEL_55;
            v22 = 0;
            LODWORD(v10) = 1;
            v21 += ~v23;
            if (v21 < 0)
              goto LABEL_56;
          }
          v29 = v23 + 1;
          while (BN_mod_mul_reciprocal(r, r, r, &v30, ctx))
          {
            if (!--v29)
              goto LABEL_52;
          }
        }
      }
    }
LABEL_55:
    LODWORD(v10) = 0;
    goto LABEL_56;
  }
  if (!BN_abs_is_word((uint64_t)m, 1))
    return BN_one((uint64_t)r);
  BN_zero((uint64_t)r);
  LODWORD(v10) = 1;
  return (int)v10;
}

int BN_mod_exp(BIGNUM *r, const BIGNUM *a, const BIGNUM *p, const BIGNUM *m, BN_CTX *ctx)
{
  _BOOL4 v10;

  v10 = BN_get_flags((uint64_t)p, 4u) != 0;
  return BN_mod_exp_internal(r, a, p, m, ctx, v10);
}

uint64_t BN_mod_exp_internal(BIGNUM *a1, const BIGNUM *a2, const BIGNUM *a3, const BIGNUM *a4, BN_CTX *a5, int a6)
{
  if (!BN_is_odd((uint64_t)a4))
    return BN_mod_exp_recp(a1, a2, a3, a4, a5);
  if (a2->top == 1 && !(a2->neg | a6))
    return BN_mod_exp_mont_word(a1, *a2->d, a3, a4, a5, 0);
  return BN_mod_exp_mont_consttime(a1, a2, a3, a4, a5, 0);
}

uint64_t BN_mod_exp_ct(BIGNUM *a1, const BIGNUM *a2, const BIGNUM *a3, const BIGNUM *a4, BN_CTX *a5)
{
  return BN_mod_exp_internal(a1, a2, a3, a4, a5, 1);
}

uint64_t BN_mod_exp_nonct(BIGNUM *a1, const BIGNUM *a2, const BIGNUM *a3, const BIGNUM *a4, BN_CTX *a5)
{
  return BN_mod_exp_internal(a1, a2, a3, a4, a5, 0);
}

int BN_mod_exp2_mont(BIGNUM *r, const BIGNUM *a1, const BIGNUM *p1, const BIGNUM *a2, const BIGNUM *p2, const BIGNUM *m, BN_CTX *ctx, BN_MONT_CTX *m_ctx)
{
  int v16;
  int v17;
  int v19;
  int v20;
  int v21;
  BIGNUM *v22;
  BIGNUM *v23;
  BIGNUM *v24;
  BIGNUM *v25;
  BIGNUM *v26;
  BN_MONT_CTX *v27;
  unsigned int v28;
  BN_MONT_CTX *v29;
  unsigned int v30;
  uint64_t v31;
  BIGNUM *v32;
  uint64_t v34;
  BIGNUM *v35;
  const BIGNUM *v37;
  int v38;
  int v39;
  int v40;
  int v41;
  int v42;
  int v43;
  int v44;
  int v46;
  int v47;
  int v48;
  int v50;
  int v51;
  int v52;
  BN_MONT_CTX *v53;
  int v54;
  int v55;
  unsigned int v56;
  int v57;
  int v58;
  BIGNUM *b;
  int ba;
  int bb;
  BIGNUM *v62;
  BN_MONT_CTX *mont;
  BN_MONT_CTX *v64;
  BIGNUM *ra;
  int rb;
  int v67;
  int v68;
  int v69;
  BIGNUM *v70;
  __int128 v71;
  __int128 v72;
  __int128 v73;
  __int128 v74;
  __int128 v75;
  __int128 v76;
  __int128 v77;
  __int128 v78;
  __int128 v79;
  __int128 v80;
  __int128 v81;
  __int128 v82;
  __int128 v83;
  __int128 v84;
  __int128 v85;
  uint64_t v86;
  BIGNUM *v87;
  __int128 v88;
  __int128 v89;
  __int128 v90;
  __int128 v91;
  __int128 v92;
  __int128 v93;
  __int128 v94;
  __int128 v95;
  __int128 v96;
  __int128 v97;
  __int128 v98;
  __int128 v99;
  __int128 v100;
  __int128 v101;
  __int128 v102;
  uint64_t v103;
  uint64_t v104;

  v104 = *MEMORY[0x24BDAC8D0];
  if (BN_is_odd((uint64_t)m))
  {
    v16 = BN_num_bits(p1);
    v17 = BN_num_bits(p2);
    if (!(v16 | v17))
      return BN_one((uint64_t)r);
    v20 = v17;
    if (v16 <= v17)
      v21 = v17;
    else
      v21 = v16;
    v67 = v21;
    BN_CTX_start(ctx);
    v22 = BN_CTX_get(ctx);
    if (v22)
    {
      ra = v22;
      v23 = BN_CTX_get(ctx);
      if (v23)
      {
        v62 = v23;
        v64 = m_ctx;
        v24 = BN_CTX_get(ctx);
        v87 = v24;
        if (v24)
        {
          v25 = v24;
          v26 = BN_CTX_get(ctx);
          v70 = v26;
          if (v26)
          {
            b = v26;
            v27 = v64;
            if (v64)
              goto LABEL_13;
            v29 = BN_MONT_CTX_new();
            if (v29)
            {
              mont = v29;
              if (!BN_MONT_CTX_set(v29, m, ctx))
                goto LABEL_96;
              v27 = mont;
LABEL_13:
              if (v16 <= 671)
              {
                if (v16 <= 239)
                {
                  if (v16 <= 79)
                  {
                    if (v16 <= 23)
                      v28 = 1;
                    else
                      v28 = 3;
                  }
                  else
                  {
                    v28 = 4;
                  }
                }
                else
                {
                  v28 = 5;
                }
              }
              else
              {
                v28 = 6;
              }
              mont = v27;
              if (v20 <= 671)
              {
                if (v20 <= 239)
                {
                  if (v20 <= 79)
                  {
                    if (v20 <= 23)
                      v30 = 1;
                    else
                      v30 = 3;
                  }
                  else
                  {
                    v30 = 4;
                  }
                }
                else
                {
                  v30 = 5;
                }
              }
              else
              {
                v30 = 6;
              }
              if (BN_nnmod(v25, a1, m, ctx))
              {
                if (BN_is_zero((uint64_t)v25))
                {
                  BN_zero((uint64_t)r);
                  v19 = 1;
                  goto LABEL_97;
                }
                if (BN_to_montgomery(v25, v25, (uint64_t)mont, ctx))
                {
                  v103 = 0;
                  v101 = 0u;
                  v102 = 0u;
                  v99 = 0u;
                  v100 = 0u;
                  v97 = 0u;
                  v98 = 0u;
                  v95 = 0u;
                  v96 = 0u;
                  v93 = 0u;
                  v94 = 0u;
                  v91 = 0u;
                  v92 = 0u;
                  v89 = 0u;
                  v90 = 0u;
                  v88 = 0u;
                  v56 = v28;
                  if (v28 >= 2)
                  {
                    if (BN_mod_mul_montgomery(ra, v25, v25, mont, ctx))
                    {
                      v31 = 0;
                      while (1)
                      {
                        v32 = BN_CTX_get(ctx);
                        *(&v87 + v31 + 1) = v32;
                        if (!v32 || !BN_mod_mul_montgomery(v32, *(&v87 + v31), ra, mont, ctx))
                          break;
                        if ((v31++ + 2) >> (v28 - 1))
                          goto LABEL_47;
                      }
                    }
                    goto LABEL_96;
                  }
LABEL_47:
                  if (!BN_nnmod(b, a2, m, ctx))
                    goto LABEL_100;
                  if (BN_is_zero((uint64_t)b))
                  {
                    BN_zero((uint64_t)r);
                    v19 = 1;
                    goto LABEL_101;
                  }
                  if (!BN_to_montgomery(b, b, (uint64_t)mont, ctx))
                  {
LABEL_100:
                    v19 = 0;
LABEL_101:
                    v53 = mont;
                    if (!v64)
                    {
LABEL_98:
                      if (v53)
                        BN_MONT_CTX_free(v53);
                    }
LABEL_21:
                    BN_CTX_end(ctx);
                    return v19;
                  }
                  v86 = 0;
                  v84 = 0u;
                  v85 = 0u;
                  v82 = 0u;
                  v83 = 0u;
                  v80 = 0u;
                  v81 = 0u;
                  v78 = 0u;
                  v79 = 0u;
                  v76 = 0u;
                  v77 = 0u;
                  v74 = 0u;
                  v75 = 0u;
                  v72 = 0u;
                  v73 = 0u;
                  v71 = 0u;
                  if (v30 >= 2)
                  {
                    if (BN_mod_mul_montgomery(ra, b, b, mont, ctx))
                    {
                      v34 = 0;
                      while (1)
                      {
                        v35 = BN_CTX_get(ctx);
                        *(&v70 + v34 + 1) = v35;
                        if (!v35 || !BN_mod_mul_montgomery(v35, *(&v70 + v34), ra, mont, ctx))
                          break;
                        if ((v34++ + 2) >> (v30 - 1))
                          goto LABEL_57;
                      }
                    }
                    goto LABEL_96;
                  }
LABEL_57:
                  v37 = BN_value_one();
                  if (BN_to_montgomery(v62, v37, (uint64_t)mont, ctx))
                  {
                    v38 = v67;
                    if (v67 < 1)
                    {
LABEL_94:
                      v53 = mont;
                      v19 = BN_from_montgomery(r, v62, mont, ctx) != 0;
                      if (!v64)
                        goto LABEL_98;
                      goto LABEL_21;
                    }
                    v39 = 0;
                    v19 = 0;
                    v54 = 0;
                    v55 = 0;
                    v40 = v67 - v56;
                    v41 = v67 - v30;
                    rb = 1;
                    while (1)
                    {
                      v42 = v38;
                      if (!rb && !BN_mod_mul_montgomery(v62, v62, v62, mont, ctx))
                        break;
                      --v38;
                      if (v19)
                      {
                        if (v39)
                          goto LABEL_64;
                      }
                      else if (BN_is_bit_set(p1, v42 - 1))
                      {
                        v68 = v38;
                        ba = v40;
                        v44 = v40;
                        while (!BN_is_bit_set(p1, v44++))
                          ;
                        v57 = v42;
                        v46 = v42 - 2;
                        v47 = v44 - 2;
                        v55 = v44 - 1;
                        v19 = 1;
                        if (v46 <= v44 - 2)
                        {
                          v38 = v68;
                        }
                        else
                        {
                          v38 = v68;
                          do
                            v19 = (BN_is_bit_set(p1, v46--) != 0) | (2 * v19);
                          while (v46 > v47);
                        }
                        v42 = v57;
                        v40 = ba;
                        if (v39)
                        {
LABEL_64:
                          if (!v19)
                            goto LABEL_90;
                          goto LABEL_65;
                        }
                      }
                      else
                      {
                        v19 = 0;
                        if (v39)
                          goto LABEL_64;
                      }
                      if (BN_is_bit_set(p2, v38))
                      {
                        bb = v40;
                        v69 = v38;
                        v48 = v41;
                        while (!BN_is_bit_set(p2, v48++))
                          ;
                        v58 = v42;
                        v50 = v42 - 2;
                        v51 = v48 - 2;
                        v54 = v48 - 1;
                        v39 = 1;
                        if (v50 <= v48 - 2)
                        {
                          v38 = v69;
                        }
                        else
                        {
                          v38 = v69;
                          do
                            v39 = (BN_is_bit_set(p2, v50--) != 0) | (2 * v39);
                          while (v50 > v51);
                        }
                        v42 = v58;
                        v40 = bb;
                        if (!v19)
                          goto LABEL_90;
                      }
                      else
                      {
                        v39 = 0;
                        if (!v19)
                          goto LABEL_90;
                      }
LABEL_65:
                      if (v38 == v55)
                      {
                        v43 = BN_mod_mul_montgomery(v62, v62, *(&v87 + (v19 >> 1)), mont, ctx);
                        v19 = 0;
                        rb = 0;
                        if (!v43)
                          goto LABEL_97;
                      }
LABEL_90:
                      if (v39)
                      {
                        if (v38 == v54)
                        {
                          v52 = BN_mod_mul_montgomery(v62, v62, *(&v70 + (v39 >> 1)), mont, ctx);
                          v39 = 0;
                          rb = 0;
                          if (!v52)
                          {
                            v19 = 0;
                            goto LABEL_97;
                          }
                        }
                      }
                      --v40;
                      --v41;
                      if (v42 <= 1)
                        goto LABEL_94;
                    }
                  }
                }
              }
LABEL_96:
              v19 = 0;
LABEL_97:
              v53 = mont;
              if (!v64)
                goto LABEL_98;
              goto LABEL_21;
            }
          }
        }
      }
    }
    v19 = 0;
    goto LABEL_21;
  }
  ERR_put_error(3, 4095, 102, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/bn/bn_exp.c", 1172);
  return 0;
}

int BIO_printf(BIO *bio, const char *format, ...)
{
  va_list va;

  va_start(va, format);
  return BIO_vprintf(bio, format, va);
}

int BIO_vprintf(BIO *bio, const char *format, va_list args)
{
  int v4;
  char *v6;

  v6 = 0;
  v4 = vasprintf(&v6, format, args);
  if (v4 != -1)
  {
    BIO_write(bio, v6, v4);
    free(v6);
  }
  return v4;
}

int BIO_snprintf(char *buf, size_t n, const char *format, ...)
{
  int result;
  va_list va;

  va_start(va, format);
  result = vsnprintf(buf, n, format, va);
  if (result >= n || result == -1)
    return -1;
  return result;
}

int BIO_vsnprintf(char *buf, size_t n, const char *format, va_list args)
{
  int result;

  result = vsnprintf(buf, n, format, args);
  if (result >= n || result == -1)
    return -1;
  return result;
}

uint64_t CMS_stream(unsigned __int8 ***a1, uint64_t a2)
{
  uint64_t result;
  _QWORD *v4;
  ASN1_OCTET_STRING *v5;

  result = (uint64_t)CMS_get0_content(a2);
  if (result)
  {
    v4 = (_QWORD *)result;
    v5 = *(ASN1_OCTET_STRING **)result;
    if (v5 || (v5 = ASN1_OCTET_STRING_new(), (*v4 = v5) != 0))
    {
      v5->flags = v5->flags & 0xFFFFFFFFFFFFFFCFLL | 0x10;
      *a1 = &v5->data;
      return 1;
    }
    else
    {
      ERR_put_error(46, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/cms/cms_io.c", 75);
      return 0;
    }
  }
  return result;
}

void *d2i_CMS_bio(BIO *in, void *x)
{
  return ASN1_item_d2i_bio(&CMS_ContentInfo_it, in, x);
}

uint64_t i2d_CMS_bio(BIO *out, void *x)
{
  return ASN1_item_i2d_bio(&CMS_ContentInfo_it, out, x);
}

void *PEM_read_bio_CMS(BIO *bp, void **x, pem_password_cb *cb, void *u)
{
  return PEM_ASN1_read_bio((d2i_of_void *)d2i_CMS_ContentInfo, "CMS", bp, x, cb, u);
}

void *PEM_read_CMS(FILE *fp, void **x, pem_password_cb *cb, void *u)
{
  return PEM_ASN1_read((d2i_of_void *)d2i_CMS_ContentInfo, "CMS", fp, x, cb, u);
}

uint64_t PEM_write_bio_CMS(BIO *bp, char *x)
{
  return PEM_ASN1_write_bio((i2d_of_void *)i2d_CMS_ContentInfo, "CMS", bp, x, 0, 0, 0, 0, 0);
}

uint64_t PEM_write_CMS(FILE *fp, char *x)
{
  return PEM_ASN1_write((i2d_of_void *)i2d_CMS_ContentInfo, "CMS", fp, x, 0, 0, 0, 0, 0);
}

uint64_t BIO_new_CMS(BIO *a1, uint64_t a2)
{
  return BIO_new_NDEF(a1, a2, (uint64_t)&CMS_ContentInfo_it);
}

uint64_t i2d_CMS_bio_stream(BIO *a1, void *a2, BIO *a3, int a4)
{
  return i2d_ASN1_bio_stream(a1, a2, a3, a4, &CMS_ContentInfo_it);
}

uint64_t PEM_write_bio_CMS_stream(BIO *a1, void *a2, BIO *a3, int a4)
{
  return PEM_write_bio_ASN1_stream(a1, a2, a3, a4, "CMS", &CMS_ContentInfo_it);
}

uint64_t SMIME_write_CMS(BIO *a1, uint64_t a2, BIO *a3, int a4)
{
  int v8;
  const ASN1_OBJECT *v9;
  int v10;
  STACK *v11;

  v8 = OBJ_obj2nid(*(const ASN1_OBJECT **)a2);
  v9 = (const ASN1_OBJECT *)CMS_get0_eContentType(a2);
  v10 = OBJ_obj2nid(v9);
  if (v8 == 22)
    v11 = *(STACK **)(*(_QWORD *)(a2 + 8) + 8);
  else
    v11 = 0;
  return SMIME_write_ASN1(a1, (void *)a2, a3, a4, v8, v10, v11, &CMS_ContentInfo_it);
}

ASN1_VALUE *SMIME_read_CMS(BIO *a1, BIO **a2)
{
  return SMIME_read_ASN1(a1, a2, &CMS_ContentInfo_it);
}

OCSP_SIGNATURE *__cdecl d2i_OCSP_SIGNATURE(OCSP_SIGNATURE **a, const unsigned __int8 **in, uint64_t len)
{
  return (OCSP_SIGNATURE *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &OCSP_SIGNATURE_it);
}

int i2d_OCSP_SIGNATURE(OCSP_SIGNATURE *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &OCSP_SIGNATURE_it);
}

OCSP_SIGNATURE *OCSP_SIGNATURE_new(void)
{
  return (OCSP_SIGNATURE *)ASN1_item_new(&OCSP_SIGNATURE_it);
}

void OCSP_SIGNATURE_free(OCSP_SIGNATURE *a)
{
  ASN1_item_free((ASN1_VALUE *)a, &OCSP_SIGNATURE_it);
}

OCSP_CERTID *__cdecl d2i_OCSP_CERTID(OCSP_CERTID **a, const unsigned __int8 **in, uint64_t len)
{
  return (OCSP_CERTID *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &OCSP_CERTID_it);
}

int i2d_OCSP_CERTID(OCSP_CERTID *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &OCSP_CERTID_it);
}

OCSP_CERTID *OCSP_CERTID_new(void)
{
  return (OCSP_CERTID *)ASN1_item_new(&OCSP_CERTID_it);
}

void OCSP_CERTID_free(OCSP_CERTID *a)
{
  ASN1_item_free((ASN1_VALUE *)a, &OCSP_CERTID_it);
}

OCSP_ONEREQ *__cdecl d2i_OCSP_ONEREQ(OCSP_ONEREQ **a, const unsigned __int8 **in, uint64_t len)
{
  return (OCSP_ONEREQ *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &OCSP_ONEREQ_it);
}

int i2d_OCSP_ONEREQ(OCSP_ONEREQ *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &OCSP_ONEREQ_it);
}

OCSP_ONEREQ *OCSP_ONEREQ_new(void)
{
  return (OCSP_ONEREQ *)ASN1_item_new(&OCSP_ONEREQ_it);
}

void OCSP_ONEREQ_free(OCSP_ONEREQ *a)
{
  ASN1_item_free((ASN1_VALUE *)a, &OCSP_ONEREQ_it);
}

OCSP_REQINFO *__cdecl d2i_OCSP_REQINFO(OCSP_REQINFO **a, const unsigned __int8 **in, uint64_t len)
{
  return (OCSP_REQINFO *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &OCSP_REQINFO_it);
}

int i2d_OCSP_REQINFO(OCSP_REQINFO *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &OCSP_REQINFO_it);
}

OCSP_REQINFO *OCSP_REQINFO_new(void)
{
  return (OCSP_REQINFO *)ASN1_item_new(&OCSP_REQINFO_it);
}

void OCSP_REQINFO_free(OCSP_REQINFO *a)
{
  ASN1_item_free((ASN1_VALUE *)a, &OCSP_REQINFO_it);
}

OCSP_REQUEST *__cdecl d2i_OCSP_REQUEST(OCSP_REQUEST **a, const unsigned __int8 **in, uint64_t len)
{
  return (OCSP_REQUEST *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &OCSP_REQUEST_it);
}

int i2d_OCSP_REQUEST(OCSP_REQUEST *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &OCSP_REQUEST_it);
}

void *d2i_OCSP_REQUEST_bio(BIO *in, void *x)
{
  return ASN1_item_d2i_bio(&OCSP_REQUEST_it, in, x);
}

uint64_t i2d_OCSP_REQUEST_bio(BIO *out, void *x)
{
  return ASN1_item_i2d_bio(&OCSP_REQUEST_it, out, x);
}

OCSP_REQUEST *OCSP_REQUEST_new(void)
{
  return (OCSP_REQUEST *)ASN1_item_new(&OCSP_REQUEST_it);
}

void OCSP_REQUEST_free(OCSP_REQUEST *a)
{
  ASN1_item_free((ASN1_VALUE *)a, &OCSP_REQUEST_it);
}

OCSP_RESPBYTES *__cdecl d2i_OCSP_RESPBYTES(OCSP_RESPBYTES **a, const unsigned __int8 **in, uint64_t len)
{
  return (OCSP_RESPBYTES *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &OCSP_RESPBYTES_it);
}

int i2d_OCSP_RESPBYTES(OCSP_RESPBYTES *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &OCSP_RESPBYTES_it);
}

OCSP_RESPBYTES *OCSP_RESPBYTES_new(void)
{
  return (OCSP_RESPBYTES *)ASN1_item_new(&OCSP_RESPBYTES_it);
}

void OCSP_RESPBYTES_free(OCSP_RESPBYTES *a)
{
  ASN1_item_free((ASN1_VALUE *)a, &OCSP_RESPBYTES_it);
}

OCSP_RESPONSE *__cdecl d2i_OCSP_RESPONSE(OCSP_RESPONSE **a, const unsigned __int8 **in, uint64_t len)
{
  return (OCSP_RESPONSE *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &OCSP_RESPONSE_it);
}

int i2d_OCSP_RESPONSE(OCSP_RESPONSE *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &OCSP_RESPONSE_it);
}

void *d2i_OCSP_RESPONSE_bio(BIO *in, void *x)
{
  return ASN1_item_d2i_bio(&OCSP_RESPONSE_it, in, x);
}

uint64_t i2d_OCSP_RESPONSE_bio(BIO *out, void *x)
{
  return ASN1_item_i2d_bio(&OCSP_RESPONSE_it, out, x);
}

OCSP_RESPONSE *OCSP_RESPONSE_new(void)
{
  return (OCSP_RESPONSE *)ASN1_item_new(&OCSP_RESPONSE_it);
}

void OCSP_RESPONSE_free(OCSP_RESPONSE *a)
{
  ASN1_item_free((ASN1_VALUE *)a, &OCSP_RESPONSE_it);
}

OCSP_RESPID *__cdecl d2i_OCSP_RESPID(OCSP_RESPID **a, const unsigned __int8 **in, uint64_t len)
{
  return (OCSP_RESPID *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &OCSP_RESPID_it);
}

int i2d_OCSP_RESPID(OCSP_RESPID *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &OCSP_RESPID_it);
}

OCSP_RESPID *OCSP_RESPID_new(void)
{
  return (OCSP_RESPID *)ASN1_item_new(&OCSP_RESPID_it);
}

void OCSP_RESPID_free(OCSP_RESPID *a)
{
  ASN1_item_free((ASN1_VALUE *)a, &OCSP_RESPID_it);
}

OCSP_REVOKEDINFO *__cdecl d2i_OCSP_REVOKEDINFO(OCSP_REVOKEDINFO **a, const unsigned __int8 **in, uint64_t len)
{
  return (OCSP_REVOKEDINFO *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &OCSP_REVOKEDINFO_it);
}

int i2d_OCSP_REVOKEDINFO(OCSP_REVOKEDINFO *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &OCSP_REVOKEDINFO_it);
}

OCSP_REVOKEDINFO *OCSP_REVOKEDINFO_new(void)
{
  return (OCSP_REVOKEDINFO *)ASN1_item_new(&OCSP_REVOKEDINFO_it);
}

void OCSP_REVOKEDINFO_free(OCSP_REVOKEDINFO *a)
{
  ASN1_item_free((ASN1_VALUE *)a, &OCSP_REVOKEDINFO_it);
}

OCSP_CERTSTATUS *__cdecl d2i_OCSP_CERTSTATUS(OCSP_CERTSTATUS **a, const unsigned __int8 **in, uint64_t len)
{
  return (OCSP_CERTSTATUS *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &OCSP_CERTSTATUS_it);
}

int i2d_OCSP_CERTSTATUS(OCSP_CERTSTATUS *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &OCSP_CERTSTATUS_it);
}

OCSP_CERTSTATUS *OCSP_CERTSTATUS_new(void)
{
  return (OCSP_CERTSTATUS *)ASN1_item_new(&OCSP_CERTSTATUS_it);
}

void OCSP_CERTSTATUS_free(OCSP_CERTSTATUS *a)
{
  ASN1_item_free((ASN1_VALUE *)a, &OCSP_CERTSTATUS_it);
}

OCSP_SINGLERESP *__cdecl d2i_OCSP_SINGLERESP(OCSP_SINGLERESP **a, const unsigned __int8 **in, uint64_t len)
{
  return (OCSP_SINGLERESP *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &OCSP_SINGLERESP_it);
}

int i2d_OCSP_SINGLERESP(OCSP_SINGLERESP *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &OCSP_SINGLERESP_it);
}

OCSP_SINGLERESP *OCSP_SINGLERESP_new(void)
{
  return (OCSP_SINGLERESP *)ASN1_item_new(&OCSP_SINGLERESP_it);
}

void OCSP_SINGLERESP_free(OCSP_SINGLERESP *a)
{
  ASN1_item_free((ASN1_VALUE *)a, &OCSP_SINGLERESP_it);
}

OCSP_RESPDATA *__cdecl d2i_OCSP_RESPDATA(OCSP_RESPDATA **a, const unsigned __int8 **in, uint64_t len)
{
  return (OCSP_RESPDATA *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &OCSP_RESPDATA_it);
}

int i2d_OCSP_RESPDATA(OCSP_RESPDATA *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &OCSP_RESPDATA_it);
}

OCSP_RESPDATA *OCSP_RESPDATA_new(void)
{
  return (OCSP_RESPDATA *)ASN1_item_new(&OCSP_RESPDATA_it);
}

void OCSP_RESPDATA_free(OCSP_RESPDATA *a)
{
  ASN1_item_free((ASN1_VALUE *)a, &OCSP_RESPDATA_it);
}

OCSP_BASICRESP *__cdecl d2i_OCSP_BASICRESP(OCSP_BASICRESP **a, const unsigned __int8 **in, uint64_t len)
{
  return (OCSP_BASICRESP *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &OCSP_BASICRESP_it);
}

int i2d_OCSP_BASICRESP(OCSP_BASICRESP *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &OCSP_BASICRESP_it);
}

OCSP_BASICRESP *OCSP_BASICRESP_new(void)
{
  return (OCSP_BASICRESP *)ASN1_item_new(&OCSP_BASICRESP_it);
}

void OCSP_BASICRESP_free(OCSP_BASICRESP *a)
{
  ASN1_item_free((ASN1_VALUE *)a, &OCSP_BASICRESP_it);
}

OCSP_CRLID *__cdecl d2i_OCSP_CRLID(OCSP_CRLID **a, const unsigned __int8 **in, uint64_t len)
{
  return (OCSP_CRLID *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &OCSP_CRLID_it);
}

int i2d_OCSP_CRLID(OCSP_CRLID *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &OCSP_CRLID_it);
}

OCSP_CRLID *OCSP_CRLID_new(void)
{
  return (OCSP_CRLID *)ASN1_item_new(&OCSP_CRLID_it);
}

void OCSP_CRLID_free(OCSP_CRLID *a)
{
  ASN1_item_free((ASN1_VALUE *)a, &OCSP_CRLID_it);
}

OCSP_SERVICELOC *__cdecl d2i_OCSP_SERVICELOC(OCSP_SERVICELOC **a, const unsigned __int8 **in, uint64_t len)
{
  return (OCSP_SERVICELOC *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &OCSP_SERVICELOC_it);
}

int i2d_OCSP_SERVICELOC(OCSP_SERVICELOC *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &OCSP_SERVICELOC_it);
}

OCSP_SERVICELOC *OCSP_SERVICELOC_new(void)
{
  return (OCSP_SERVICELOC *)ASN1_item_new(&OCSP_SERVICELOC_it);
}

void OCSP_SERVICELOC_free(OCSP_SERVICELOC *a)
{
  ASN1_item_free((ASN1_VALUE *)a, &OCSP_SERVICELOC_it);
}

uint64_t i2d_ASN1_bio_stream(BIO *out, void *x, BIO *a3, int a4, ASN1_ITEM *it)
{
  BIO *v8;
  BIO *v9;
  BIO *v10;

  if ((a4 & 0x1000) == 0)
  {
    ASN1_item_i2d_bio(it, out, x);
    return 1;
  }
  v8 = (BIO *)BIO_new_NDEF(out, (uint64_t)x, (uint64_t)it);
  if (v8)
  {
    v9 = v8;
    SMIME_crlf_copy(a3, v8, a4);
    BIO_ctrl(v9, 11, 0, 0);
    do
    {
      v10 = BIO_pop(v9);
      BIO_free(v9);
      v9 = v10;
    }
    while (v10 != out);
    return 1;
  }
  ERR_put_error(13, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/asn_mime.c", 126);
  return 0;
}

int SMIME_crlf_copy(BIO *in, BIO *out, int flags)
{
  char v3;
  BIO_METHOD *v6;
  BIO *v7;
  BIO *v8;
  BIO *v9;
  BIO *v10;
  int v11;
  int v12;
  int v13;
  uint64_t v14;
  int v15;
  BOOL v16;
  int v17;
  int i;
  char buf[1024];
  uint64_t v21;

  v3 = flags;
  v21 = *MEMORY[0x24BDAC8D0];
  v6 = BIO_f_buffer();
  v7 = BIO_new(v6);
  if (v7)
  {
    v8 = v7;
    v9 = BIO_push(v7, out);
    v10 = v9;
    if (v3 < 0)
    {
      v17 = BIO_read(in, buf, 1024);
      if (v17 >= 1)
      {
        for (i = v17; i > 0; i = BIO_read(in, buf, 1024))
          BIO_write(v10, buf, i);
      }
      goto LABEL_23;
    }
    if ((v3 & 1) != 0)
      BIO_printf(v9, "Content-Type: text/plain\r\n\r\n");
    v11 = BIO_gets(in, buf, 1024);
    if (v11 < 1)
      goto LABEL_23;
    v12 = v11;
    while (1)
    {
      v13 = 0;
      v14 = v12 - 1;
      while (1)
      {
        v15 = buf[v14];
        if (v15 == 10)
        {
          v13 = 1;
          goto LABEL_12;
        }
        if (v15 != 13)
          break;
LABEL_12:
        --v14;
        v16 = __OFSUB__(v12--, 1);
        if ((v12 < 0) ^ v16 | (v12 == 0))
        {
          if (!v13)
            goto LABEL_16;
          goto LABEL_15;
        }
      }
      BIO_write(v10, buf, v12);
      if (v13)
LABEL_15:
        BIO_write(v10, "\r\n", 2);
LABEL_16:
      v12 = BIO_gets(in, buf, 1024);
      if (v12 <= 0)
      {
LABEL_23:
        BIO_ctrl(v10, 11, 0, 0);
        BIO_pop(v10);
        BIO_free(v8);
        LODWORD(v7) = 1;
        return (int)v7;
      }
    }
  }
  return (int)v7;
}

uint64_t PEM_write_bio_ASN1_stream(BIO *a1, void *a2, BIO *a3, int a4, const char *a5, ASN1_ITEM *a6)
{
  uint64_t v12;

  BIO_printf(a1, "-----BEGIN %s-----\n", a5);
  v12 = B64_write_ASN1(a1, a2, a3, a4, a6);
  BIO_printf(a1, "-----END %s-----\n", a5);
  return v12;
}

uint64_t B64_write_ASN1(BIO *a1, void *a2, BIO *a3, int a4, ASN1_ITEM *a5)
{
  BIO_METHOD *v10;
  BIO *v11;
  BIO *v12;
  BIO *v13;
  uint64_t v14;

  v10 = BIO_f_base64();
  v11 = BIO_new(v10);
  if (v11)
  {
    v12 = v11;
    v13 = BIO_push(v11, a1);
    v14 = i2d_ASN1_bio_stream(v13, a2, a3, a4, a5);
    BIO_ctrl(v13, 11, 0, 0);
    BIO_pop(v13);
    BIO_free(v12);
    return v14;
  }
  else
  {
    ERR_put_error(13, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/asn_mime.c", 157);
    return 0;
  }
}

uint64_t SMIME_write_ASN1(BIO *bio, void *a2, BIO *a3, int a4, int a5, int a6, STACK *a7, ASN1_ITEM *a8)
{
  const char *v14;
  const char *v15;
  uint64_t v16;
  int8x16_t v17;
  uint8x16_t v18;
  int8x16_t v19;
  int8x16_t v20;
  int8x16_t v21;
  int v22;
  int v23;
  int i;
  char *v25;
  int v26;
  const char *v27;
  const EVP_MD *digestbyname;
  int (__cdecl *verify)(int, const unsigned __int8 *, unsigned int, const unsigned __int8 *, unsigned int, void *);
  int v30;
  BIO *v31;
  const char *v32;
  char v33;
  const char *v34;
  const char *v35;
  uint64_t result;
  ASN1_ITEM *v37;
  _QWORD *funcs;
  int (*v39)(uint64_t, void **, ASN1_ITEM *, char **);
  int v40;
  BIO *j;
  char *buf;
  BIO *out;
  uint64_t v46;
  void *v47;
  char __buf[33];
  uint64_t v49;

  v49 = *MEMORY[0x24BDAC8D0];
  if ((a4 & 0x400) != 0)
    v14 = "application/x-pkcs7-";
  else
    v14 = "application/pkcs7-";
  if ((a4 & 0x800) != 0)
    v15 = "\r\n";
  else
    v15 = "\n";
  if (a3 && (a4 & 0x40) != 0)
  {
    arc4random_buf(__buf, 0x20uLL);
    v16 = 0;
    v17.i64[0] = 0xF0F0F0F0F0F0F0FLL;
    v17.i64[1] = 0xF0F0F0F0F0F0F0FLL;
    v18.i64[0] = 0xA0A0A0A0A0A0A0ALL;
    v18.i64[1] = 0xA0A0A0A0A0A0A0ALL;
    v19.i64[0] = 0x3030303030303030;
    v19.i64[1] = 0x3030303030303030;
    v20.i64[0] = 0x3737373737373737;
    v20.i64[1] = 0x3737373737373737;
    do
    {
      v21 = vandq_s8(*(int8x16_t *)&__buf[v16], v17);
      *(int8x16_t *)&__buf[v16] = vbslq_s8((int8x16_t)vcgtq_u8(v18, (uint8x16_t)v21), vorrq_s8(v21, v19), vaddq_s8(v21, v20));
      v16 += 16;
    }
    while (v16 != 32);
    __buf[32] = 0;
    BIO_printf(bio, "MIME-Version: 1.0%s", v15);
    BIO_printf(bio, "Content-Type: multipart/signed;");
    BIO_printf(bio, " protocol=\"%ssignature\";", v14);
    BIO_puts(bio, " micalg=\"");
    if (sk_num(a7) >= 1)
    {
      v22 = 0;
      v23 = 0;
      for (i = 0; i < sk_num(a7); ++i)
      {
        if (v22)
          BIO_write(bio, ",", 1);
        v25 = sk_value(a7, i);
        v26 = OBJ_obj2nid(*(const ASN1_OBJECT **)v25);
        v27 = OBJ_nid2sn(v26);
        digestbyname = EVP_get_digestbyname(v27);
        if (digestbyname)
        {
          verify = digestbyname->verify;
          if (verify)
          {
            buf = 0;
            v30 = ((uint64_t (*)(_QWORD, uint64_t, _QWORD, char **))verify)(0, 2, 0, &buf);
            if (v30 > 0)
            {
              BIO_puts(bio, buf);
              free(buf);
              goto LABEL_32;
            }
            if (v30 != -2)
              break;
          }
        }
        if (v26 > 672)
        {
          switch(v26)
          {
            case 673:
              v31 = bio;
              v32 = "sha-384";
              goto LABEL_31;
            case 674:
              v31 = bio;
              v32 = "sha-512";
              goto LABEL_31;
            case 809:
              BIO_puts(bio, "gostr3411-94");
              goto LABEL_56;
          }
        }
        else
        {
          switch(v26)
          {
            case 4:
              v31 = bio;
              v32 = "md5";
              goto LABEL_31;
            case 64:
              v31 = bio;
              v32 = "sha1";
              goto LABEL_31;
            case 672:
              v31 = bio;
              v32 = "sha-256";
LABEL_31:
              BIO_puts(v31, v32);
              goto LABEL_32;
          }
        }
        if (v23)
        {
          v22 = 0;
          v23 = 1;
          continue;
        }
        BIO_puts(bio, "unknown");
        v23 = 1;
LABEL_32:
        v22 = 1;
      }
    }
LABEL_56:
    BIO_printf(bio, "\"; boundary=\"----%s\"%s%s", __buf, v15, v15);
    BIO_printf(bio, "This is an S/MIME signed message%s%s", v15, v15);
    BIO_printf(bio, "------%s%s", __buf, v15);
    v47 = a2;
    if ((a4 & 0x8040) == 0x40)
    {
      v37 = a8;
      funcs = a8->funcs;
      if (!funcs || (v39 = (int (*)(uint64_t, void **, ASN1_ITEM *, char **))funcs[3]) == 0)
      {
        ERR_put_error(13, 4095, 202, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/asn_mime.c", 391);
        return 0;
      }
      out = 0;
      v46 = 0;
      buf = (char *)bio;
      if (v39(12, &v47, a8, &buf) < 1)
        return 0;
      SMIME_crlf_copy(a3, out, a4);
      v40 = ((uint64_t (*)(uint64_t, void **, ASN1_ITEM *, char **))funcs[3])(13, &v47, a8, &buf);
      for (j = out; j != bio; out = j)
      {
        j = BIO_pop(j);
        BIO_free(out);
      }
      if (v40 < 1)
        return 0;
    }
    else
    {
      SMIME_crlf_copy(a3, bio, a4);
      v37 = a8;
    }
    BIO_printf(bio, "%s------%s%s", v15, __buf, v15);
    BIO_printf(bio, "Content-Type: %ssignature;", v14);
    BIO_printf(bio, " name=\"smime.p7s\"%s", v15);
    BIO_printf(bio, "Content-Transfer-Encoding: base64%s", v15);
    BIO_printf(bio, "Content-Disposition: attachment;");
    BIO_printf(bio, " filename=\"smime.p7s\"%s%s", v15, v15);
    B64_write_ASN1(bio, a2, 0, 0, v37);
    BIO_printf(bio, "%s------%s--%s%s");
    return 1;
  }
  if (a5 == 786)
  {
    v33 = 0;
    v34 = "compressed-data";
    v35 = "smime.p7z";
  }
  else
  {
    if (a5 == 23)
    {
      v33 = 0;
      v34 = "enveloped-data";
    }
    else if (a5 == 22)
    {
      if (a6 == 204)
      {
        v33 = 0;
        v34 = "signed-receipt";
      }
      else
      {
        v33 = 0;
        if (sk_num(a7) < 0)
          v34 = "certs-only";
        else
          v34 = "signed-data";
      }
    }
    else
    {
      v34 = 0;
      v33 = 1;
    }
    v35 = "smime.p7m";
  }
  BIO_printf(bio, "MIME-Version: 1.0%s", v15);
  BIO_printf(bio, "Content-Disposition: attachment;");
  BIO_printf(bio, " filename=\"%s\"%s", v35, v15);
  BIO_printf(bio, "Content-Type: %smime;", v14);
  if ((v33 & 1) == 0)
    BIO_printf(bio, " smime-type=%s;", v34);
  BIO_printf(bio, " name=\"%s\"%s", v35, v15);
  BIO_printf(bio, "Content-Transfer-Encoding: base64%s%s", v15, v15);
  result = B64_write_ASN1(bio, a2, a3, a4, a8);
  if ((_DWORD)result)
  {
    BIO_printf(bio, "%s");
    return 1;
  }
  return result;
}

ASN1_VALUE *__cdecl SMIME_read_ASN1(BIO *bio, BIO **bcont, const ASN1_ITEM *it)
{
  STACK *v6;
  STACK *v7;
  char *v8;
  char *v9;
  const char *v10;
  void (__cdecl *v11)(void *);
  STACK *v12;
  int v13;
  int v14;
  ASN1_VALUE *asn1;
  int v17;
  char *v18;
  const char *v19;
  int v20;
  int v21;
  int v22;
  BIO *v23;
  int v24;
  int v25;
  uint64_t v26;
  int v27;
  uint64_t v28;
  int v29;
  BOOL v30;
  BIO_METHOD *v31;
  BIO *v32;
  int v33;
  int v34;
  int v35;
  char *v36;
  STACK *v37;
  STACK *v38;
  char *v39;
  char *v40;
  const char *v41;
  STACK *st;
  char *__s;
  uint64_t v44;
  char data[8];
  uint64_t v46;
  uint64_t v47;

  v47 = *MEMORY[0x24BDAC8D0];
  if (bcont)
    *bcont = 0;
  v6 = mime_parse_hdr(bio);
  if (!v6)
  {
    v13 = 207;
    v14 = 442;
    goto LABEL_12;
  }
  v7 = v6;
  v8 = mime_hdr_find(v6);
  if (!v8 || (v9 = v8, (v10 = (const char *)*((_QWORD *)v8 + 1)) == 0))
  {
    sk_pop_free(v7, (void (__cdecl *)(void *))mime_hdr_free);
    v13 = 209;
    v14 = 448;
LABEL_12:
    ERR_put_error(13, 4095, v13, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/asn_mime.c", v14);
    return 0;
  }
  if (strcmp(*((const char **)v8 + 1), "multipart/signed"))
  {
    if (strcmp(v10, "application/x-pkcs7-mime") && strcmp(v10, "application/pkcs7-mime"))
    {
      ERR_put_error(13, 4095, 205, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/asn_mime.c", 517);
      ERR_asprintf_error_data("type: %s", *((const char **)v9 + 1));
      v11 = (void (__cdecl *)(void *))mime_hdr_free;
      v12 = v7;
      goto LABEL_59;
    }
    sk_pop_free(v7, (void (__cdecl *)(void *))mime_hdr_free);
    asn1 = (ASN1_VALUE *)b64_read_asn1(bio, it);
    if (!asn1)
      ERR_put_error(13, 4095, 203, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/asn_mime.c", 526);
    return asn1;
  }
  *(_QWORD *)data = "boundary";
  v46 = 0;
  v17 = sk_find(*((STACK **)v9 + 2), data);
  if (v17 < 0
    || (v18 = sk_value(*((const STACK **)v9 + 2), v17)) == 0
    || (v19 = (const char *)*((_QWORD *)v18 + 1)) == 0)
  {
    sk_pop_free(v7, (void (__cdecl *)(void *))mime_hdr_free);
    v13 = 211;
    v14 = 459;
    goto LABEL_12;
  }
  __s = (char *)v19;
  v20 = strlen(v19);
  st = sk_new_null();
  if (!st)
  {
LABEL_55:
    sk_pop_free(v7, (void (__cdecl *)(void *))mime_hdr_free);
LABEL_56:
    v33 = 210;
    v34 = 465;
LABEL_57:
    ERR_put_error(13, 4095, v33, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/asn_mime.c", v34);
    goto LABEL_58;
  }
  v21 = BIO_gets(bio, data, 1024);
  if (v21 < 1)
  {
    v23 = 0;
LABEL_54:
    BIO_free(v23);
    goto LABEL_55;
  }
  v22 = v21;
  v44 = 0;
  v23 = 0;
  v24 = 1;
  while (1)
  {
    v25 = v20;
    if (v20 == -1)
      v25 = strlen(__s);
    if (v25 + 2 <= v22 && *(unsigned __int16 *)data == 11565)
    {
      v26 = v25;
      if (!strncmp(&data[2], __s, v25))
        break;
    }
    if (BYTE4(v44))
    {
      v27 = 0;
      v28 = v22 - 1;
      do
      {
        v29 = data[v28];
        if (v29 == 10)
        {
          v27 = 1;
        }
        else if (v29 != 13)
        {
          goto LABEL_37;
        }
        --v28;
        v30 = __OFSUB__(v22--, 1);
      }
      while (!((v22 < 0) ^ v30 | (v22 == 0)));
      v22 = 0;
LABEL_37:
      if (v24)
      {
        if (v23 && !sk_push(st, (char *)v23))
          goto LABEL_55;
        v31 = BIO_s_mem();
        v32 = BIO_new(v31);
        if (!v32)
          goto LABEL_55;
        v23 = v32;
        BIO_ctrl(v32, 130, 0, 0);
      }
      else if ((_DWORD)v44)
      {
        BIO_write(v23, "\r\n", 2);
      }
      if (v22)
        BIO_write(v23, data, v22);
      v24 = 0;
      LODWORD(v44) = v27;
    }
    else
    {
      HIDWORD(v44) = 0;
    }
LABEL_48:
    v22 = BIO_gets(bio, data, 1024);
    if (v22 <= 0)
      goto LABEL_54;
  }
  if (strncmp(&data[v26 + 2], "--", 2uLL))
  {
    ++HIDWORD(v44);
    v24 = 1;
    goto LABEL_48;
  }
  v35 = sk_push(st, (char *)v23);
  sk_pop_free(v7, (void (__cdecl *)(void *))mime_hdr_free);
  if (!v35 || sk_num(st) != 2)
    goto LABEL_56;
  v36 = sk_value(st, 1);
  v37 = mime_parse_hdr((BIO *)v36);
  if (!v37)
  {
    v33 = 208;
    v34 = 474;
    goto LABEL_57;
  }
  v38 = v37;
  v39 = mime_hdr_find(v37);
  if (!v39 || (v40 = v39, (v41 = (const char *)*((_QWORD *)v39 + 1)) == 0))
  {
    sk_pop_free(v38, (void (__cdecl *)(void *))mime_hdr_free);
    sk_pop_free(st, (void (__cdecl *)(void *))BIO_vfree);
    v13 = 212;
    v14 = 485;
    goto LABEL_12;
  }
  if (!strcmp(*((const char **)v39 + 1), "application/x-pkcs7-signature")
    || !strcmp(v41, "application/pkcs7-signature"))
  {
    sk_pop_free(v38, (void (__cdecl *)(void *))mime_hdr_free);
    asn1 = (ASN1_VALUE *)b64_read_asn1((BIO *)v36, it);
    if (asn1)
    {
      if (bcont)
      {
        *bcont = (BIO *)sk_value(st, 0);
        BIO_free((BIO *)v36);
        sk_free(st);
        return asn1;
      }
    }
    else
    {
      ERR_put_error(13, 4095, 204, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/asn_mime.c", 500);
    }
    sk_pop_free(st, (void (__cdecl *)(void *))BIO_vfree);
    return asn1;
  }
  ERR_put_error(13, 4095, 213, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/asn_mime.c", 491);
  ERR_asprintf_error_data("type: %s", *((const char **)v40 + 1));
  sk_pop_free(v38, (void (__cdecl *)(void *))mime_hdr_free);
LABEL_58:
  v11 = (void (__cdecl *)(void *))BIO_vfree;
  v12 = st;
LABEL_59:
  sk_pop_free(v12, v11);
  return 0;
}

STACK *mime_parse_hdr(BIO *a1)
{
  uint64_t v1;
  int v2;
  int v3;
  uint64_t v4;
  char *v5;
  char *v6;
  char *v7;
  unsigned int v8;
  char *v10;
  char *v11;
  char *v12;
  char *v13;
  char *v14;
  char *v15;
  STACK *st;
  char buf[1024];
  uint64_t v20;

  v20 = *MEMORY[0x24BDAC8D0];
  st = sk_new((int (__cdecl *)(const char *const *, const char *const *))mime_hdr_cmp);
  if (st)
  {
    v1 = 0;
    v2 = 0;
    while (1)
    {
      if (BIO_gets(a1, buf, 1024) < 1)
        return st;
      if (v1)
      {
        if (buf[0] < 0)
        {
          if (__maskrune(buf[0], 0x4000uLL))
          {
LABEL_7:
            v3 = 3;
            goto LABEL_10;
          }
        }
        else if ((*(_DWORD *)(MEMORY[0x24BDAC740] + 4 * buf[0] + 60) & 0x4000) != 0)
        {
          goto LABEL_7;
        }
      }
      v3 = 1;
LABEL_10:
      v4 = 0;
      v5 = 0;
      v6 = buf;
      v7 = buf;
      while (1)
      {
        v8 = buf[v4];
        if (v8 <= 0xD && ((1 << v8) & 0x2401) != 0)
          break;
        switch(v3)
        {
          case 1:
            if (v8 == 58)
            {
              buf[v4] = 0;
              v5 = (char *)strip_ends((uint64_t)v7);
              v3 = 2;
              v7 = &buf[v4 + 1];
            }
            else
            {
              v3 = 1;
            }
            goto LABEL_45;
          case 2:
            if (v8 == 40)
            {
              v2 = 2;
LABEL_44:
              v3 = 6;
            }
            else if (v8 == 59)
            {
              buf[v4] = 0;
              v10 = (char *)strip_ends((uint64_t)v7);
              v11 = (char *)mime_hdr_new(v5, v10);
              if (!v11)
                goto LABEL_55;
              v1 = (uint64_t)v11;
              if (!sk_push(st, v11))
                goto LABEL_54;
LABEL_30:
              v5 = 0;
              v7 = v6 + 1;
LABEL_31:
              v3 = 3;
            }
            else
            {
              v3 = 2;
            }
LABEL_45:
            ++v6;
            ++v4;
            break;
          case 3:
            if (v8 != 61)
              goto LABEL_31;
            buf[v4] = 0;
            v5 = (char *)strip_ends((uint64_t)v7);
            v7 = v6 + 1;
            goto LABEL_38;
          case 4:
            switch(v8)
            {
              case '"':
                v3 = 5;
                goto LABEL_45;
              case '(':
                v2 = 4;
                goto LABEL_44;
              case ';':
                buf[v4] = 0;
                v12 = (char *)strip_ends((uint64_t)v7);
                mime_hdr_addparam(v1, v5, v12);
                goto LABEL_30;
            }
LABEL_38:
            v3 = 4;
            goto LABEL_45;
          case 5:
            if (v8 == 34)
              v3 = 4;
            else
              v3 = 5;
            goto LABEL_45;
          case 6:
            if (v8 == 41)
              v3 = v2;
            else
              v3 = 6;
            goto LABEL_45;
          default:
            goto LABEL_45;
        }
      }
      if (v3 == 4)
      {
        v15 = (char *)strip_ends((uint64_t)v7);
        mime_hdr_addparam(v1, v5, v15);
        if (!v4)
          return st;
      }
      else
      {
        if (v3 == 2)
        {
          v13 = (char *)strip_ends((uint64_t)v7);
          v14 = (char *)mime_hdr_new(v5, v13);
          if (!v14)
            goto LABEL_55;
          v1 = (uint64_t)v14;
          if (!sk_push(st, v14))
          {
LABEL_54:
            mime_hdr_free(v1);
LABEL_55:
            sk_pop_free(st, (void (__cdecl *)(void *))mime_hdr_free);
            return 0;
          }
        }
        if (!v4)
          return st;
      }
    }
  }
  return 0;
}

char *mime_hdr_find(STACK *a1)
{
  int v2;
  char data[8];
  uint64_t v5;
  uint64_t v6;

  v5 = 0;
  v6 = 0;
  *(_QWORD *)data = "content-type";
  v2 = sk_find(a1, data);
  if (v2 < 0)
    return 0;
  else
    return sk_value(a1, v2);
}

void mime_hdr_free(uint64_t a1)
{
  STACK *v2;

  free(*(void **)a1);
  free(*(void **)(a1 + 8));
  v2 = *(STACK **)(a1 + 16);
  if (v2)
    sk_pop_free(v2, (void (__cdecl *)(void *))mime_param_free);
  free((void *)a1);
}

void *b64_read_asn1(BIO *a1, const ASN1_ITEM *a2)
{
  BIO_METHOD *v4;
  BIO *v5;
  BIO *v6;
  BIO *v7;
  void *v8;

  v4 = BIO_f_base64();
  v5 = BIO_new(v4);
  if (v5)
  {
    v6 = v5;
    v7 = BIO_push(v5, a1);
    v8 = ASN1_item_d2i_bio(a2, v7, 0);
    if (!v8)
      ERR_put_error(13, 4095, 110, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/asn_mime.c", 196);
    BIO_ctrl(v7, 11, 0, 0);
    BIO_pop(v7);
    BIO_free(v6);
  }
  else
  {
    ERR_put_error(13, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/asn_mime.c", 190);
    return 0;
  }
  return v8;
}

int SMIME_text(BIO *in, BIO *out)
{
  BIO *v2;
  BIO *v3;
  BIO *v4;
  BIO *v5;
  STACK *v6;
  STACK *v7;
  char *v8;
  char *v9;
  const char *v10;
  int v12;
  _BYTE data[4096];
  uint64_t v14;

  v2 = (BIO *)MEMORY[0x24BDAC7A8](in);
  v4 = v3;
  v5 = v2;
  v14 = *MEMORY[0x24BDAC8D0];
  v6 = mime_parse_hdr(v2);
  if (!v6)
  {
    ERR_put_error(13, 4095, 207, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/asn_mime.c", 579);
    return 0;
  }
  v7 = v6;
  v8 = mime_hdr_find(v6);
  if (!v8 || (v9 = v8, (v10 = (const char *)*((_QWORD *)v8 + 1)) == 0))
  {
    ERR_put_error(13, 4095, 206, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/asn_mime.c", 583);
    goto LABEL_7;
  }
  if (strcmp(v10, "text/plain"))
  {
    ERR_put_error(13, 4095, 205, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/asn_mime.c", 588);
    ERR_asprintf_error_data("type: %s", *((const char **)v9 + 1));
LABEL_7:
    sk_pop_free(v7, (void (__cdecl *)(void *))mime_hdr_free);
    return 0;
  }
  sk_pop_free(v7, (void (__cdecl *)(void *))mime_hdr_free);
  v12 = BIO_read(v5, data, 4096);
  if (v12 >= 1)
  {
    do
    {
      BIO_write(v4, data, v12);
      v12 = BIO_read(v5, data, 4096);
    }
    while (v12 > 0);
  }
  return v12 == 0;
}

uint64_t mime_hdr_cmp(const char ***a1, const char ***a2)
{
  const char *v2;
  const char *v3;
  BOOL v4;

  v2 = **a1;
  v3 = **a2;
  if (v2)
    v4 = v3 == 0;
  else
    v4 = 1;
  if (v4)
    return (v2 != 0) - (v3 != 0);
  else
    return strcmp(v2, v3);
}

const char *strip_ends(uint64_t a1)
{
  const char *v1;
  uint64_t v2;
  uint64_t v3;
  const char *v4;
  const char *v5;
  unsigned int v6;

  v1 = (const char *)(a1 + 1);
  v2 = MEMORY[0x24BDAC740];
  while (1)
  {
    v3 = *((unsigned __int8 *)v1 - 1);
    if (!*(v1 - 1))
      return 0;
    if ((_DWORD)v3 == 34)
    {
      if (!*v1)
        return 0;
      goto LABEL_12;
    }
    if ((v3 & 0x80) != 0)
    {
      if (!__maskrune(v3, 0x4000uLL))
      {
LABEL_11:
        --v1;
LABEL_12:
        v4 = &v1[strlen(v1)];
        v5 = v4 - 1;
        if (v4 - 1 >= v1)
        {
          v6 = *(unsigned __int8 *)v5;
          if (v6 == 34)
          {
LABEL_21:
            if (v4 - 2 != v1)
            {
              *v5 = 0;
              return v1;
            }
          }
          else
          {
            while (1)
            {
              if ((v6 & 0x80) != 0)
              {
                if (!__maskrune(v6, 0x4000uLL))
                  return v1;
              }
              else if ((*(_DWORD *)(v2 + 4 * v6 + 60) & 0x4000) == 0)
              {
                return v1;
              }
              *v5-- = 0;
              if (v5 < v1)
                break;
              v6 = *(unsigned __int8 *)v5;
              if (v6 == 34)
              {
                v4 = v5 + 1;
                goto LABEL_21;
              }
            }
          }
        }
        return 0;
      }
    }
    else if ((*(_DWORD *)(v2 + 4 * v3 + 60) & 0x4000) == 0)
    {
      goto LABEL_11;
    }
    ++v1;
  }
}

_QWORD *mime_hdr_new(const char *a1, char *a2)
{
  char *v2;
  char *v3;
  unsigned __int8 *v4;
  __darwin_ct_rune_t v5;
  unsigned __int8 *v6;
  __darwin_ct_rune_t v7;
  char *v8;
  __darwin_ct_rune_t v9;
  unsigned __int8 *v10;
  __darwin_ct_rune_t v11;
  _QWORD *v12;
  _QWORD *v13;
  STACK *v14;

  v2 = a2;
  if (a1)
  {
    v3 = strdup(a1);
    v4 = (unsigned __int8 *)v3;
    if (!v3)
    {
      v2 = 0;
      goto LABEL_17;
    }
    v5 = *v3;
    if (*v4)
    {
      v6 = v4 + 1;
      do
      {
        *(v6 - 1) = __tolower(v5);
        v7 = *v6++;
        v5 = v7;
      }
      while (v7);
    }
    if (!v2)
      goto LABEL_13;
  }
  else
  {
    v4 = 0;
    if (!a2)
      goto LABEL_13;
  }
  v8 = strdup(v2);
  v2 = v8;
  if (!v8)
  {
LABEL_17:
    free(v4);
    free(v2);
    return 0;
  }
  v9 = *v8;
  if (*v2)
  {
    v10 = (unsigned __int8 *)(v2 + 1);
    do
    {
      *(v10 - 1) = __tolower(v9);
      v11 = *v10++;
      v9 = v11;
    }
    while (v11);
  }
LABEL_13:
  v12 = malloc_type_malloc(0x18uLL, 0x30040254F79A5uLL);
  if (!v12)
    goto LABEL_17;
  v13 = v12;
  *v12 = v4;
  v12[1] = v2;
  v14 = sk_new((int (__cdecl *)(const char *const *, const char *const *))mime_param_cmp);
  v13[2] = v14;
  if (!v14)
  {
    free(v13);
    goto LABEL_17;
  }
  return v13;
}

void mime_hdr_addparam(uint64_t a1, char *__s1, char *a3)
{
  char *v3;
  char *v5;
  unsigned __int8 *v6;
  __darwin_ct_rune_t v7;
  unsigned __int8 *v8;
  __darwin_ct_rune_t v9;
  _QWORD *v10;
  void *v11;

  v3 = a3;
  if (__s1)
  {
    v5 = strdup(__s1);
    v6 = (unsigned __int8 *)v5;
    if (!v5)
    {
      v3 = 0;
      goto LABEL_15;
    }
    v7 = *v5;
    if (*v6)
    {
      v8 = v6 + 1;
      do
      {
        *(v8 - 1) = __tolower(v7);
        v9 = *v8++;
        v7 = v9;
      }
      while (v9);
    }
    if (!v3)
      goto LABEL_10;
  }
  else
  {
    v6 = 0;
    if (!a3)
      goto LABEL_10;
  }
  v3 = strdup(v3);
  if (!v3)
  {
LABEL_15:
    free(v6);
    free(v3);
    return;
  }
LABEL_10:
  v10 = malloc_type_malloc(0x10uLL, 0x10040B8F86A93uLL);
  if (!v10)
    goto LABEL_15;
  v11 = v10;
  *v10 = v6;
  v10[1] = v3;
  if (!sk_push(*(STACK **)(a1 + 16), (char *)v10))
  {
    free(v11);
    goto LABEL_15;
  }
}

uint64_t mime_param_cmp(const char ***a1, const char ***a2)
{
  const char *v2;
  const char *v3;
  BOOL v4;

  v2 = **a1;
  v3 = **a2;
  if (v2)
    v4 = v3 == 0;
  else
    v4 = 1;
  if (v4)
    return (v2 != 0) - (v3 != 0);
  else
    return strcmp(v2, v3);
}

void mime_param_free(void **a1)
{
  free(*a1);
  free(a1[1]);
  free(a1);
}

BIO_METHOD *BIO_s_null(void)
{
  return (BIO_METHOD *)&null_method;
}

uint64_t null_write(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return a3;
}

uint64_t null_read()
{
  return 0;
}

size_t null_puts(int a1, char *__s)
{
  if (__s)
    return strlen(__s);
  else
    return 0;
}

uint64_t null_gets()
{
  return 0;
}

uint64_t null_ctrl(uint64_t a1, int a2)
{
  if ((a2 - 1) > 0xB)
    return 0;
  else
    return qword_22D691D80[a2 - 1];
}

uint64_t null_new(uint64_t a1)
{
  *(_DWORD *)(a1 + 32) = 1;
  *(_DWORD *)(a1 + 48) = 0;
  *(_QWORD *)(a1 + 56) = 0;
  return 1;
}

BOOL null_free(uint64_t a1)
{
  return a1 != 0;
}

BOOL X509_CRL_up_ref(uint64_t a1)
{
  return CRYPTO_add_lock((int *)(a1 + 24), 1, 6, 0, 0) > 1;
}

int X509_CRL_set_version(X509_CRL *x, uint64_t version)
{
  ASN1_INTEGER *v4;

  if (x && ((v4 = x->crl->version) != 0 || (v4 = ASN1_INTEGER_new(), (x->crl->version = v4) != 0)))
    return ASN1_INTEGER_set(v4, version);
  else
    return 0;
}

int X509_CRL_set_issuer_name(X509_CRL *x, X509_NAME *name)
{
  if (x && x->crl)
    return X509_NAME_set(&x->crl->issuer, name);
  else
    return 0;
}

int X509_CRL_set_lastUpdate(X509_CRL *x, ASN1_TIME *tm)
{
  ASN1_TIME *v2;
  X509_CRL *v3;

  if (x)
  {
    v2 = tm;
    v3 = x;
    if (x->crl->lastUpdate != tm)
    {
      v2 = ASN1_STRING_dup(tm);
      if (v2)
      {
        ASN1_TIME_free(v3->crl->lastUpdate);
        v3->crl->lastUpdate = v2;
      }
    }
    LODWORD(x) = v2 != 0;
  }
  return (int)x;
}

int X509_CRL_set_nextUpdate(X509_CRL *x, ASN1_TIME *tm)
{
  ASN1_TIME *v2;
  X509_CRL *v3;

  if (x)
  {
    v2 = tm;
    v3 = x;
    if (x->crl->nextUpdate != tm)
    {
      v2 = ASN1_STRING_dup(tm);
      if (v2)
      {
        ASN1_TIME_free(v3->crl->nextUpdate);
        v3->crl->nextUpdate = v2;
      }
    }
    LODWORD(x) = v2 != 0;
  }
  return (int)x;
}

int X509_CRL_sort(X509_CRL *crl)
{
  int v2;

  sk_sort(crl->crl->revoked);
  if (sk_num(crl->crl->revoked) >= 1)
  {
    v2 = 0;
    do
    {
      *((_DWORD *)sk_value(crl->crl->revoked, v2) + 9) = v2;
      ++v2;
    }
    while (v2 < sk_num(crl->crl->revoked));
  }
  crl->crl->enc.modified = 1;
  return 1;
}

uint64_t X509_REVOKED_get0_extensions(uint64_t a1)
{
  return *(_QWORD *)(a1 + 16);
}

uint64_t X509_REVOKED_get0_revocationDate(uint64_t a1)
{
  return *(_QWORD *)(a1 + 8);
}

uint64_t X509_REVOKED_get0_serialNumber(uint64_t a1)
{
  return *(_QWORD *)a1;
}

int X509_REVOKED_set_revocationDate(X509_REVOKED *r, ASN1_TIME *tm)
{
  ASN1_TIME *v2;
  X509_REVOKED *v3;

  if (r)
  {
    v2 = tm;
    v3 = r;
    if (r->revocationDate != tm)
    {
      v2 = ASN1_STRING_dup(tm);
      if (v2)
      {
        ASN1_TIME_free(v3->revocationDate);
        v3->revocationDate = v2;
      }
    }
    LODWORD(r) = v2 != 0;
  }
  return (int)r;
}

int X509_REVOKED_set_serialNumber(X509_REVOKED *x, ASN1_INTEGER *serial)
{
  ASN1_INTEGER *v2;
  X509_REVOKED *v3;

  if (x)
  {
    v2 = serial;
    v3 = x;
    if (x->serialNumber != serial)
    {
      v2 = ASN1_INTEGER_dup(serial);
      if (v2)
      {
        ASN1_INTEGER_free(v3->serialNumber);
        v3->serialNumber = v2;
      }
    }
    LODWORD(x) = v2 != 0;
  }
  return (int)x;
}

uint64_t i2d_re_X509_CRL_tbs(X509_CRL_INFO **a1, unsigned __int8 **a2)
{
  X509_CRL_INFO *v2;

  v2 = *a1;
  v2->enc.modified = 1;
  return i2d_X509_CRL_INFO(v2, a2);
}

void ERR_load_UI_strings(void)
{
  if (!ERR_func_error_string(UI_str_functs))
  {
    ERR_load_strings(0, (ERR_STRING_DATA *)&UI_str_functs);
    ERR_load_strings(0, (ERR_STRING_DATA *)&UI_str_reasons);
  }
}

void *EVP_aead_chacha20_poly1305()
{
  return &aead_chacha20_poly1305;
}

void *EVP_aead_xchacha20_poly1305()
{
  return &aead_xchacha20_poly1305;
}

void *EVP_chacha20_poly1305()
{
  return &cipher_chacha20_poly1305;
}

uint64_t aead_chacha20_poly1305_init(uint64_t a1, _OWORD *a2, uint64_t a3, unint64_t a4)
{
  unint64_t v4;
  uint64_t result;
  __int128 v8;

  if (a4)
    v4 = a4;
  else
    v4 = 16;
  if (v4 >= 0x11)
  {
    ERR_put_error(6, 4095, 164, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/e_chacha20poly1305.c", 58);
    return 0;
  }
  if (a3 != 32)
    return 0;
  result = (uint64_t)malloc_type_malloc(0x21uLL, 0x10000407D106B36uLL);
  if (result)
  {
    v8 = a2[1];
    *(_OWORD *)result = *a2;
    *(_OWORD *)(result + 16) = v8;
    *(_BYTE *)(result + 32) = v4;
    *(_QWORD *)(a1 + 8) = result;
    return 1;
  }
  return result;
}

void aead_chacha20_poly1305_cleanup(uint64_t a1)
{
  freezero(*(void **)(a1 + 8), 0x21uLL);
}

uint64_t aead_chacha20_poly1305_seal(_QWORD *a1, int *a2, unint64_t *a3, unint64_t a4, unsigned __int8 *a5, uint64_t a6, _DWORD *a7, unint64_t a8, char *a9, unint64_t a10)
{
  uint64_t v10;
  int v11;
  int v12;
  unint64_t v17;
  unint64_t v18;
  uint64_t *v19;
  uint64_t i;
  uint64_t v21;
  unint64_t v22;
  unint64_t v23;
  char v25[16];
  _OWORD v26[9];
  _OWORD v27[2];
  uint64_t v28;

  v28 = *MEMORY[0x24BDAC8D0];
  v10 = a1[1];
  memset(v26, 0, sizeof(v26));
  if (*(unsigned __int8 *)(v10 + 32) + a8 > a4)
  {
    v11 = 155;
    v12 = 137;
LABEL_11:
    ERR_put_error(6, 4095, v11, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/e_chacha20poly1305.c", v12);
    return 0;
  }
  if (*(unsigned __int8 *)(*a1 + 1) != a6)
  {
    v11 = 102;
    v12 = 142;
    goto LABEL_11;
  }
  v17 = a10;
  v18 = ((unint64_t)*a5 << 32) | ((unint64_t)a5[1] << 40) | ((unint64_t)a5[2] << 48) | ((unint64_t)a5[3] << 56);
  v19 = (uint64_t *)(a5 + 4);
  memset(v27, 0, sizeof(v27));
  CRYPTO_chacha_20((int *)v27, v27, 0x20uLL, (_OWORD *)v10, (uint64_t *)(a5 + 4), v18);
  CRYPTO_poly1305_init((uint64_t)v26, v27);
  poly1305_update_with_pad16((uint64_t *)v26, a9, a10);
  CRYPTO_chacha_20(a2, a7, a8, (_OWORD *)v10, v19, v18 | 1);
  poly1305_update_with_pad16((uint64_t *)v26, (char *)a2, a8);
  for (i = 0; i != 8; ++i)
  {
    v25[i] = v17;
    v17 >>= 8;
  }
  CRYPTO_poly1305_update((uint64_t *)v26, v25, 8uLL);
  v21 = 0;
  v22 = a8;
  do
  {
    v25[v21] = v22;
    v22 >>= 8;
    ++v21;
  }
  while (v21 != 8);
  CRYPTO_poly1305_update((uint64_t *)v26, v25, 8uLL);
  if (*(_BYTE *)(v10 + 32) == 16)
  {
    CRYPTO_poly1305_finish((uint64_t)v26, (uint64_t)a2 + a8);
    v23 = a8 + 16;
  }
  else
  {
    CRYPTO_poly1305_finish((uint64_t)v26, (uint64_t)v25);
    memcpy((char *)a2 + a8, v25, *(unsigned __int8 *)(v10 + 32));
    v23 = *(unsigned __int8 *)(v10 + 32) + a8;
  }
  *a3 = v23;
  return 1;
}

uint64_t aead_chacha20_poly1305_open(_QWORD *a1, int *a2, unint64_t *a3, unint64_t a4, unsigned __int8 *a5, uint64_t a6, char *a7, unint64_t a8, char *a9, unint64_t a10)
{
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  int v13;
  int v14;
  unint64_t v18;
  unint64_t v19;
  uint64_t *v20;
  uint64_t i;
  uint64_t v22;
  unint64_t v23;
  _OWORD v25[9];
  _OWORD v26[2];
  char v27[16];
  uint64_t v28;

  v28 = *MEMORY[0x24BDAC8D0];
  v10 = a1[1];
  memset(v25, 0, sizeof(v25));
  v11 = *(unsigned __int8 *)(v10 + 32);
  v12 = a8 - v11;
  if (a8 >= v11)
  {
    if (*(unsigned __int8 *)(*a1 + 1) == a6)
    {
      if (v12 <= a4)
      {
        v18 = a10;
        v19 = ((unint64_t)*a5 << 32) | ((unint64_t)a5[1] << 40) | ((unint64_t)a5[2] << 48) | ((unint64_t)a5[3] << 56);
        v20 = (uint64_t *)(a5 + 4);
        memset(v26, 0, sizeof(v26));
        CRYPTO_chacha_20((int *)v26, v26, 0x20uLL, (_OWORD *)v10, (uint64_t *)(a5 + 4), v19);
        CRYPTO_poly1305_init((uint64_t)v25, v26);
        poly1305_update_with_pad16((uint64_t *)v25, a9, a10);
        poly1305_update_with_pad16((uint64_t *)v25, a7, v12);
        for (i = 0; i != 8; ++i)
        {
          v27[i] = v18;
          v18 >>= 8;
        }
        CRYPTO_poly1305_update((uint64_t *)v25, v27, 8uLL);
        v22 = 0;
        v23 = v12;
        do
        {
          v27[v22] = v23;
          v23 >>= 8;
          ++v22;
        }
        while (v22 != 8);
        CRYPTO_poly1305_update((uint64_t *)v25, v27, 8uLL);
        CRYPTO_poly1305_finish((uint64_t)v25, (uint64_t)v27);
        if (!timingsafe_memcmp((unsigned __int8 *)v27, (unsigned __int8 *)&a7[v12], *(unsigned __int8 *)(v10 + 32)))
        {
          CRYPTO_chacha_20(a2, a7, v12, (_OWORD *)v10, v20, v19 | 1);
          *a3 = v12;
          return 1;
        }
        v13 = 100;
        v14 = 222;
      }
      else
      {
        v13 = 155;
        v14 = 201;
      }
    }
    else
    {
      v13 = 102;
      v14 = 194;
    }
  }
  else
  {
    v13 = 100;
    v14 = 189;
  }
  ERR_put_error(6, 4095, v13, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/e_chacha20poly1305.c", v14);
  return 0;
}

uint64_t *poly1305_update_with_pad16(uint64_t *a1, char *a2, unint64_t a3)
{
  char v3;
  uint64_t *result;

  v3 = a3;
  result = CRYPTO_poly1305_update(a1, a2, a3);
  if ((v3 & 0xF) != 0)
    return CRYPTO_poly1305_update(a1, poly1305_pad16_zero_pad16, 16 - (v3 & 0xF));
  return result;
}

uint64_t aead_xchacha20_poly1305_seal(_QWORD *a1, int *a2, unint64_t *a3, unint64_t a4, int *a5, uint64_t a6, _DWORD *a7, unint64_t a8, char *a9, unint64_t a10)
{
  uint64_t v10;
  int v11;
  int v12;
  uint64_t *v15;
  unint64_t v18;
  uint64_t i;
  uint64_t v20;
  unint64_t v21;
  unint64_t v22;
  char v24[16];
  _OWORD v25[9];
  int v26[8];
  _OWORD v27[2];
  uint64_t v28;

  v28 = *MEMORY[0x24BDAC8D0];
  v10 = a1[1];
  memset(v25, 0, sizeof(v25));
  if (*(unsigned __int8 *)(v10 + 32) + a8 > a4)
  {
    v11 = 155;
    v12 = 243;
LABEL_11:
    ERR_put_error(6, 4095, v11, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/e_chacha20poly1305.c", v12);
    return 0;
  }
  if (*(unsigned __int8 *)(*a1 + 1) != a6)
  {
    v11 = 102;
    v12 = 248;
    goto LABEL_11;
  }
  v15 = (uint64_t *)a5;
  v18 = a10;
  CRYPTO_hchacha_20(v26, (int *)v10, a5);
  v15 += 2;
  CRYPTO_chacha_20(a2, a7, a8, v26, v15, 1);
  memset(v27, 0, sizeof(v27));
  CRYPTO_chacha_20((int *)v27, v27, 0x20uLL, v26, v15, 0);
  CRYPTO_poly1305_init((uint64_t)v25, v27);
  poly1305_update_with_pad16((uint64_t *)v25, a9, a10);
  poly1305_update_with_pad16((uint64_t *)v25, (char *)a2, a8);
  for (i = 0; i != 8; ++i)
  {
    v24[i] = v18;
    v18 >>= 8;
  }
  CRYPTO_poly1305_update((uint64_t *)v25, v24, 8uLL);
  v20 = 0;
  v21 = a8;
  do
  {
    v24[v20] = v21;
    v21 >>= 8;
    ++v20;
  }
  while (v20 != 8);
  CRYPTO_poly1305_update((uint64_t *)v25, v24, 8uLL);
  if (*(_BYTE *)(v10 + 32) == 16)
  {
    CRYPTO_poly1305_finish((uint64_t)v25, (uint64_t)a2 + a8);
    v22 = a8 + 16;
  }
  else
  {
    CRYPTO_poly1305_finish((uint64_t)v25, (uint64_t)v24);
    memcpy((char *)a2 + a8, v24, *(unsigned __int8 *)(v10 + 32));
    v22 = *(unsigned __int8 *)(v10 + 32) + a8;
  }
  *a3 = v22;
  return 1;
}

uint64_t aead_xchacha20_poly1305_open(_QWORD *a1, int *a2, unint64_t *a3, unint64_t a4, int *a5, uint64_t a6, char *a7, unint64_t a8, char *a9, unint64_t a10)
{
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  int v13;
  int v14;
  unint64_t v19;
  uint64_t *v20;
  uint64_t i;
  uint64_t v22;
  unint64_t v23;
  uint64_t v24;
  _OWORD v26[9];
  int v27[8];
  _OWORD v28[2];
  char v29[16];
  uint64_t v30;

  v30 = *MEMORY[0x24BDAC8D0];
  v10 = a1[1];
  memset(v26, 0, sizeof(v26));
  v11 = *(unsigned __int8 *)(v10 + 32);
  v12 = a8 - v11;
  if (a8 >= v11)
  {
    if (*(unsigned __int8 *)(*a1 + 1) == a6)
    {
      if (v12 <= a4)
      {
        v19 = a10;
        CRYPTO_hchacha_20(v27, (int *)v10, a5);
        memset(v28, 0, sizeof(v28));
        v20 = (uint64_t *)(a5 + 4);
        CRYPTO_chacha_20((int *)v28, v28, 0x20uLL, v27, v20, 0);
        CRYPTO_poly1305_init((uint64_t)v26, v28);
        poly1305_update_with_pad16((uint64_t *)v26, a9, a10);
        poly1305_update_with_pad16((uint64_t *)v26, a7, v12);
        for (i = 0; i != 8; ++i)
        {
          v29[i] = v19;
          v19 >>= 8;
        }
        CRYPTO_poly1305_update((uint64_t *)v26, v29, 8uLL);
        v22 = 0;
        v23 = v12;
        do
        {
          v29[v22] = v23;
          v23 >>= 8;
          ++v22;
        }
        while (v22 != 8);
        CRYPTO_poly1305_update((uint64_t *)v26, v29, 8uLL);
        CRYPTO_poly1305_finish((uint64_t)v26, (uint64_t)v29);
        if (!timingsafe_memcmp((unsigned __int8 *)v29, (unsigned __int8 *)&a7[v12], *(unsigned __int8 *)(v10 + 32)))
        {
          v24 = 1;
          CRYPTO_chacha_20(a2, a7, v12, v27, v20, 1);
          *a3 = v12;
          return v24;
        }
        v13 = 100;
        v14 = 323;
      }
      else
      {
        v13 = 155;
        v14 = 305;
      }
    }
    else
    {
      v13 = 102;
      v14 = 298;
    }
  }
  else
  {
    v13 = 100;
    v14 = 293;
  }
  ERR_put_error(6, 4095, v13, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/e_chacha20poly1305.c", v14);
  return 0;
}

uint64_t chacha20_poly1305_init(uint64_t a1, unint64_t a2, unint64_t a3)
{
  uint64_t v3;
  __int128 v5;
  uint64_t v6;
  _OWORD v8[2];
  void *v9;

  v3 = *(_QWORD *)(a1 + 120);
  v9 = 0;
  memset(v8, 0, sizeof(v8));
  if (!(a2 | a3))
    goto LABEL_9;
  *(_DWORD *)(v3 + 380) = 0;
  if (a2)
  {
    v5 = *(_OWORD *)(a2 + 16);
    *(_OWORD *)(v3 + 280) = *(_OWORD *)a2;
    *(_OWORD *)(v3 + 296) = v5;
  }
  if (!a3
    || CBB_init_fixed((uint64_t)v8, v3 + 312, 12)
    && CBB_add_space((char **)v8, &v9, 12 - *(_QWORD *)(v3 + 328))
    && CBB_add_bytes((char **)v8, (const void *)a3, *(_QWORD *)(v3 + 328))
    && CBB_finish((uint64_t *)v8, 0, 0))
  {
LABEL_9:
    v6 = 1;
  }
  else
  {
    v6 = 0;
  }
  CBB_cleanup((uint64_t *)v8);
  return v6;
}

uint64_t chacha20_poly1305_cipher(uint64_t a1, int *a2, char *a3, unint64_t a4)
{
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  unint64_t v15;
  _OWORD v16[2];
  uint64_t v17;

  v17 = *MEMORY[0x24BDAC8D0];
  v8 = *(_QWORD *)(a1 + 120);
  if (*(_DWORD *)(v8 + 380))
  {
    v9 = *(_QWORD *)(v8 + 368);
  }
  else
  {
    v10 = *(_DWORD *)(v8 + 312);
    ChaCha_set_key(*(_QWORD *)(a1 + 120), (_DWORD *)(v8 + 280), 256);
    ChaCha_set_iv(v8, (_DWORD *)(v8 + 316), 0);
    *(_DWORD *)(v8 + 48) = 0;
    *(_DWORD *)(v8 + 52) = v10;
    memset(v16, 0, sizeof(v16));
    ChaCha((int *)v8, (int *)v16, (char *)v16, 0x20uLL);
    CRYPTO_poly1305_init(v8 + 136, v16);
    v9 = 0;
    *(_BYTE *)(v8 + 128) = 0;
    *(_QWORD *)(v8 + 360) = 0;
    *(_QWORD *)(v8 + 368) = 0;
    *(_QWORD *)(v8 + 376) = 0x100000000;
  }
  if (!__CFADD__(v9, a4))
  {
    if (!a2 && a3 && v9)
      return 0xFFFFFFFFLL;
    if (*(_DWORD *)(v8 + 376))
    {
      if (!a2 && a3)
        goto LABEL_21;
      if ((*(_QWORD *)(v8 + 360) & 0xFLL) != 0)
        CRYPTO_poly1305_update((uint64_t *)(v8 + 136), poly1305_pad16_zero_pad16, 16 - (*(_QWORD *)(v8 + 360) & 0xFLL));
      *(_DWORD *)(v8 + 376) = 0;
    }
    if (!a3)
    {
      if ((*(_QWORD *)(v8 + 368) & 0xFLL) != 0)
        CRYPTO_poly1305_update((uint64_t *)(v8 + 136), poly1305_pad16_zero_pad16, 16 - (*(_QWORD *)(v8 + 368) & 0xFLL));
      v12 = 0;
      v13 = *(_QWORD *)(v8 + 360);
      do
      {
        *((_BYTE *)v16 + v12) = v13;
        v13 >>= 8;
        ++v12;
      }
      while (v12 != 8);
      CRYPTO_poly1305_update((uint64_t *)(v8 + 136), (char *)v16, 8uLL);
      v14 = 0;
      v15 = *(_QWORD *)(v8 + 368);
      do
      {
        *((_BYTE *)v16 + v14) = v15;
        v15 >>= 8;
        ++v14;
      }
      while (v14 != 8);
      CRYPTO_poly1305_update((uint64_t *)(v8 + 136), (char *)v16, 8uLL);
      if (*(_DWORD *)(a1 + 16))
      {
        CRYPTO_poly1305_finish(v8 + 136, v8 + 336);
        *(_QWORD *)(v8 + 352) = 16;
      }
      else
      {
        if (!*(_QWORD *)(v8 + 352))
          return 0xFFFFFFFFLL;
        CRYPTO_poly1305_finish(v8 + 136, (uint64_t)v16);
        if (timingsafe_memcmp((unsigned __int8 *)v16, (unsigned __int8 *)(v8 + 336), *(_QWORD *)(v8 + 352)))return 0xFFFFFFFFLL;
      }
      *(_DWORD *)(v8 + 380) = 0;
      return a4;
    }
    if (a2)
    {
      ChaCha((int *)v8, a2, a3, a4);
      *(_QWORD *)(v8 + 368) += a4;
      if (*(_DWORD *)(a1 + 16))
      {
LABEL_23:
        CRYPTO_poly1305_update((uint64_t *)(v8 + 136), (char *)a2, a4);
        return a4;
      }
LABEL_22:
      a2 = (int *)a3;
      goto LABEL_23;
    }
LABEL_21:
    *(_QWORD *)(v8 + 360) += a4;
    *(_DWORD *)(v8 + 376) = 1;
    goto LABEL_22;
  }
  ERR_put_error(6, 4095, 164, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/e_chacha20poly1305.c", 478);
  return 0;
}

uint64_t chacha20_poly1305_cleanup(uint64_t a1)
{
  explicit_bzero(*(void **)(a1 + 120), 0x180uLL);
  return 1;
}

uint64_t chacha20_poly1305_ctrl(uint64_t a1, int a2, size_t __n, uint64_t *__src)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  result = 0;
  v6 = *(_QWORD *)(a1 + 120);
  switch(a2)
  {
    case 9:
      if ((__n - 13) < 0xFFFFFFF4)
        return 0;
      *(_QWORD *)(v6 + 328) = __n;
      return 1;
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
      return result;
    case 16:
      result = 0;
      if ((int)__n < 1 || !*(_DWORD *)(a1 + 16))
        return result;
      if (*(_QWORD *)(v6 + 352) < (unint64_t)__n)
        return 0;
      memcpy(__src, (const void *)(v6 + 336), __n);
      return 1;
    case 17:
      if (*(_DWORD *)(a1 + 16) || (__n - 17) < 0xFFFFFFF0)
        return 0;
      if (__src)
      {
        v7 = (int)__n;
        memcpy((void *)(v6 + 336), __src, (int)__n);
        *(_QWORD *)(v6 + 352) = v7;
      }
      return 1;
    case 18:
      if ((_DWORD)__n != 12)
        return 0;
      v8 = *__src;
      *(_DWORD *)(v6 + 320) = *((_DWORD *)__src + 2);
      *(_QWORD *)(v6 + 312) = v8;
      return 1;
    default:
      if (!a2)
      {
        *(_OWORD *)(v6 + 352) = 0u;
        *(_OWORD *)(v6 + 368) = 0u;
        *(_OWORD *)(v6 + 320) = 0u;
        *(_OWORD *)(v6 + 336) = 0u;
        *(_OWORD *)(v6 + 288) = 0u;
        *(_OWORD *)(v6 + 304) = 0u;
        *(_OWORD *)(v6 + 256) = 0u;
        *(_OWORD *)(v6 + 272) = 0u;
        *(_OWORD *)(v6 + 224) = 0u;
        *(_OWORD *)(v6 + 240) = 0u;
        *(_OWORD *)(v6 + 192) = 0u;
        *(_OWORD *)(v6 + 208) = 0u;
        *(_OWORD *)(v6 + 160) = 0u;
        *(_OWORD *)(v6 + 176) = 0u;
        *(_OWORD *)(v6 + 128) = 0u;
        *(_OWORD *)(v6 + 144) = 0u;
        *(_OWORD *)(v6 + 96) = 0u;
        *(_OWORD *)(v6 + 112) = 0u;
        *(_OWORD *)(v6 + 64) = 0u;
        *(_OWORD *)(v6 + 80) = 0u;
        *(_OWORD *)(v6 + 32) = 0u;
        *(_OWORD *)(v6 + 48) = 0u;
        *(_QWORD *)(v6 + 328) = 12;
        result = 1;
        *(_OWORD *)v6 = 0u;
        *(_OWORD *)(v6 + 16) = 0u;
      }
      return result;
  }
}

void ERR_load_OBJ_strings(void)
{
  if (!ERR_func_error_string(OBJ_str_functs))
  {
    ERR_load_strings(0, (ERR_STRING_DATA *)&OBJ_str_functs);
    ERR_load_strings(0, (ERR_STRING_DATA *)&OBJ_str_reasons);
  }
}

uint64_t ERR_load_KDF_strings()
{
  if (!ERR_func_error_string(KDF_str_functs))
  {
    ERR_load_strings(0, (ERR_STRING_DATA *)&KDF_str_functs);
    ERR_load_strings(0, (ERR_STRING_DATA *)&KDF_str_reasons);
  }
  return 1;
}

void ERR_load_DSO_strings(void)
{
  if (!ERR_func_error_string(DSO_str_functs))
  {
    ERR_load_strings(0, (ERR_STRING_DATA *)&DSO_str_functs);
    ERR_load_strings(0, (ERR_STRING_DATA *)&DSO_str_reasons);
  }
}

ASN1_INTEGER *ASN1_INTEGER_new(void)
{
  return (ASN1_INTEGER *)ASN1_item_new(&ASN1_INTEGER_it);
}

void ASN1_INTEGER_free(ASN1_INTEGER *a)
{
  ASN1_item_free((ASN1_VALUE *)a, &ASN1_INTEGER_it);
}

ASN1_INTEGER *__cdecl ASN1_INTEGER_dup(ASN1_INTEGER *x)
{
  if (!x || x->length < 0)
    return 0;
  else
    return ASN1_STRING_dup(x);
}

int ASN1_INTEGER_cmp(ASN1_INTEGER *x, ASN1_INTEGER *y)
{
  int type;
  int result;

  type = x->type;
  if (((y->type ^ type) & 0x100) != 0)
  {
    result = 1;
  }
  else
  {
    result = ASN1_STRING_cmp(x, y);
    type = x->type;
  }
  if ((type & 0x100) != 0)
    return -result;
  return result;
}

uint64_t asn1_aint_get_uint64(_QWORD *a1, unint64_t *a2)
{
  unint64_t v4;
  uint64_t result;
  unsigned __int8 v6;

  v6 = 0;
  *a2 = 0;
  v4 = 0;
  if (CBS_len((uint64_t)a1))
  {
    while (1)
    {
      result = CBS_get_u8(a1, &v6);
      if (!(_DWORD)result)
        break;
      if (HIBYTE(v4))
      {
        ERR_put_error(13, 4095, 223, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/a_int.c", 141);
        return 0;
      }
      v4 = v6 | (v4 << 8);
      if (!CBS_len((uint64_t)a1))
        goto LABEL_5;
    }
  }
  else
  {
LABEL_5:
    *a2 = v4;
    return 1;
  }
  return result;
}

uint64_t asn1_aint_set_uint64(unint64_t a1, _QWORD *a2, int *a3)
{
  uint64_t v6;
  int v7;
  uint64_t i;
  int v10;
  _OWORD v11[2];
  size_t v12;
  void *v13;

  v12 = 0;
  v13 = 0;
  memset(v11, 0, sizeof(v11));
  if (!CBB_init((uint64_t)v11, 8uLL))
    goto LABEL_6;
  v6 = 0;
  if (a2 && a3)
  {
    if (*a2 || (v7 = *a3) != 0)
    {
LABEL_6:
      v6 = 0;
      goto LABEL_7;
    }
    for (i = 56; i != -8; i -= 8)
    {
      if (v7 || !i || (a1 >> i))
      {
        if (!CBB_add_u8((char **)v11, (a1 >> i)))
          goto LABEL_6;
        v7 = 1;
      }
      else
      {
        v7 = 0;
      }
    }
    v6 = 0;
    if (CBB_finish((uint64_t *)v11, &v13, &v12))
    {
      v10 = v12;
      if (!(v12 >> 31))
      {
        *a2 = v13;
        *a3 = v10;
        v13 = 0;
        v6 = 1;
      }
    }
  }
LABEL_7:
  CBB_cleanup((uint64_t *)v11);
  freezero(v13, v12);
  return v6;
}

uint64_t asn1_aint_get_int64(_QWORD *a1, int a2, uint64_t *a3)
{
  uint64_t result;
  uint64_t v6;
  int v7;
  int v8;
  uint64_t v9;

  v9 = 0;
  result = asn1_aint_get_uint64(a1, (unint64_t *)&v9);
  if ((_DWORD)result)
  {
    v6 = v9;
    if (a2)
    {
      if ((unint64_t)v9 >= 0x8000000000000001)
      {
        v7 = 224;
        v8 = 207;
LABEL_7:
        ERR_put_error(13, 4095, v7, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/a_int.c", v8);
        return 0;
      }
      v6 = -v9;
    }
    else if (v9 < 0)
    {
      v7 = 223;
      v8 = 213;
      goto LABEL_7;
    }
    *a3 = v6;
    return 1;
  }
  return result;
}

uint64_t ASN1_INTEGER_get_uint64(_QWORD *a1, unsigned int *a2)
{
  uint64_t v2;
  unsigned int v3;
  int v4;
  int v5;
  uint64_t result;
  _QWORD v8[3];
  unint64_t v9;

  *a1 = 0;
  if (!a2)
    return 0;
  v2 = *a2;
  if ((v2 & 0x80000000) != 0)
    return 0;
  v3 = a2[1];
  if (v3 != 2)
  {
    if (v3 == 258)
    {
      v4 = 226;
      v5 = 234;
    }
    else
    {
      v4 = 225;
      v5 = 238;
    }
    ERR_put_error(13, 4095, v4, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/a_int.c", v5);
    return 0;
  }
  v9 = 0;
  memset(v8, 0, sizeof(v8));
  CBS_init(v8, *((_QWORD *)a2 + 1), v2);
  result = asn1_aint_get_uint64(v8, &v9);
  if ((_DWORD)result)
  {
    *a1 = v9;
    return 1;
  }
  return result;
}

uint64_t ASN1_INTEGER_set_uint64(int *a1, unint64_t a2)
{
  _QWORD *v4;

  v4 = a1 + 2;
  freezero(*((void **)a1 + 1), *a1);
  *(_QWORD *)a1 = 0;
  *v4 = 0;
  *((_QWORD *)a1 + 2) = 0;
  a1[1] = 2;
  return asn1_aint_set_uint64(a2, v4, a1);
}

uint64_t ASN1_INTEGER_get_int64(uint64_t *a1, unsigned int *a2)
{
  uint64_t v3;
  _QWORD v6[3];

  *a1 = 0;
  if (a2)
  {
    v3 = *a2;
    if ((v3 & 0x80000000) == 0)
    {
      if ((a2[1] | 0x100) == 0x102)
      {
        memset(v6, 0, sizeof(v6));
        CBS_init(v6, *((_QWORD *)a2 + 1), v3);
        return asn1_aint_get_int64(v6, a2[1] == 258, a1);
      }
      ERR_put_error(13, 4095, 225, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/a_int.c", 272);
    }
  }
  return 0;
}

uint64_t ASN1_INTEGER_set_int64(int *a1, unint64_t a2)
{
  _QWORD *v4;

  v4 = a1 + 2;
  freezero(*((void **)a1 + 1), *a1);
  *(_QWORD *)a1 = 0;
  *v4 = 0;
  *((_QWORD *)a1 + 2) = 0;
  a1[1] = 2;
  if ((a2 & 0x8000000000000000) != 0)
  {
    a1[1] = 258;
    a2 = -(uint64_t)a2;
  }
  return asn1_aint_set_uint64(a2, v4, a1);
}

uint64_t ASN1_INTEGER_get(uint64_t a)
{
  uint64_t v1;

  if (a)
  {
    v1 = 0;
    if (ASN1_INTEGER_get_int64(&v1, (unsigned int *)a))
      return v1;
    else
      return -1;
  }
  return a;
}

ASN1_INTEGER *__cdecl BN_to_ASN1_INTEGER(BIGNUM *bn, ASN1_INTEGER *ai)
{
  ASN1_INTEGER *v4;
  int v5;
  int v6;
  int v7;
  unsigned __int8 *data;
  unsigned __int8 *v9;
  int v10;
  int v11;
  int v12;

  v4 = ai;
  if (!ai)
  {
    v4 = (ASN1_INTEGER *)ASN1_item_new(&ASN1_INTEGER_it);
    if (!v4)
    {
      v11 = 58;
      v12 = 333;
LABEL_16:
      ERR_put_error(13, 4095, v11, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/a_int.c", v12);
      goto LABEL_17;
    }
  }
  if ((v4->length & 0x80000000) == 0)
  {
    if (BN_is_negative((uint64_t)bn))
      v5 = 258;
    else
      v5 = 2;
    v4->type = v5;
    v6 = BN_num_bits(bn);
    v7 = v6 / 8 + 5;
    if (!v6)
      v7 = 4;
    data = v4->data;
    if (v4->length >= v7)
      goto LABEL_12;
    v9 = (unsigned __int8 *)malloc_type_realloc(v4->data, v7, 0x844DBF6AuLL);
    if (v9)
    {
      data = v9;
      v4->data = v9;
LABEL_12:
      v10 = BN_bn2bin(bn, data);
      v4->length = v10;
      if (!v10)
      {
        *v4->data = 0;
        v4->length = 1;
      }
      return v4;
    }
    v11 = 65;
    v12 = 349;
    goto LABEL_16;
  }
LABEL_17:
  if (v4 != ai)
    ASN1_item_free((ASN1_VALUE *)v4, &ASN1_INTEGER_it);
  return 0;
}

BIGNUM *__cdecl ASN1_INTEGER_to_BN(ASN1_INTEGER *ai, BIGNUM *bn)
{
  BIGNUM *v3;
  BIGNUM *v4;

  if (!ai || ai->length < 0)
    return 0;
  v3 = BN_bin2bn(ai->data, ai->length, bn);
  v4 = v3;
  if (v3)
  {
    if (ai->type == 258)
      BN_set_negative(v3, 1);
  }
  else
  {
    ERR_put_error(13, 4095, 105, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/a_int.c", 378);
  }
  return v4;
}

int i2a_ASN1_INTEGER(BIO *bp, ASN1_INTEGER *a)
{
  int v4;
  uint64_t v5;
  unsigned __int8 *v6;
  _BYTE data[2];

  if (!a)
    return 0;
  if ((a->type & 0x100) != 0)
  {
    v4 = 1;
    if (BIO_write(bp, "-", 1) != 1)
      return -1;
  }
  else
  {
    v4 = 0;
  }
  if (a->length)
  {
    if (a->length >= 1)
    {
      v5 = 0;
      while (1)
      {
        if (v5 && !(v5 % 0x23))
        {
          if (BIO_write(bp, "\\\n", 2) != 2)
            return -1;
          v4 += 2;
        }
        v6 = a->data;
        data[0] = i2a_ASN1_INTEGER_h[(unint64_t)v6[v5] >> 4];
        data[1] = i2a_ASN1_INTEGER_h[v6[v5] & 0xF];
        if (BIO_write(bp, data, 2) != 2)
          break;
        v4 += 2;
        if (++v5 >= a->length)
          return v4;
      }
      return -1;
    }
  }
  else if (BIO_write(bp, "00", 2) == 2)
  {
    return v4 | 2;
  }
  else
  {
    return -1;
  }
  return v4;
}

int a2i_ASN1_INTEGER(BIO *bp, ASN1_INTEGER *bs, char *buf, int size)
{
  int v7;
  char v8;
  int v9;
  unsigned int v10;
  char *v11;
  uint64_t v12;
  int v13;
  unsigned int v14;
  unsigned int v15;
  int v16;
  unsigned int v17;
  char *v18;
  int v19;
  char *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  char v25;
  char v26;
  int v27;
  char v28;
  int v29;
  int v30;
  int v32;
  int v33;
  ASN1_INTEGER *v34;

  bs->type = 2;
  v7 = BIO_gets(bp, buf, size);
  if (v7 >= 1)
  {
    v34 = bs;
    v8 = 0;
    v9 = 0;
    v10 = 0;
    v11 = 0;
    while (1)
    {
      v12 = (v7 - 1);
      v13 = v12;
      if (buf[v12] == 10)
      {
        buf[v12] = 0;
        if (v7 == 1)
          goto LABEL_47;
        v12 = (v7 - 2);
        v14 = v7 - 2;
      }
      else
      {
        v14 = v7 - 1;
        v13 = v7;
      }
      if (buf[v12] == 13)
      {
        buf[v12] = 0;
        if (!v14)
          goto LABEL_47;
        v12 = v14 - 1;
        v15 = v14 - 1;
      }
      else
      {
        v15 = v14;
        v14 = v13;
      }
      v16 = buf[v12];
      if (v16 == 92)
        v17 = v15;
      else
        v17 = v14;
      buf[v17] = 0;
      if (v17 < 2)
      {
LABEL_47:
        v20 = v11;
        goto LABEL_44;
      }
      if ((v8 & 1) != 0)
      {
        v18 = buf;
      }
      else
      {
        v18 = buf;
        if (*buf == 48)
        {
          if (buf[1] == 48)
            v17 -= 2;
          v18 = &buf[2 * (buf[1] == 48)];
        }
      }
      if ((v17 & 1) != 0)
        break;
      v19 = v10 + (v17 >> 1);
      if (v19 <= v9)
      {
        v20 = v11;
      }
      else
      {
        v20 = recallocarray(v11, v9, v10 + (v17 >> 1), 1uLL);
        v9 = v10 + (v17 >> 1);
        if (!v20)
        {
          v32 = 65;
          v33 = 473;
LABEL_49:
          ERR_put_error(13, 4095, v32, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/a_int.c", v33);
          goto LABEL_46;
        }
      }
      if (v17 >= 2)
      {
        v21 = 0;
        v22 = 0;
        LODWORD(v23) = v17 >> 1;
        if (v17 >> 1 <= 1)
          v23 = 1;
        else
          v23 = v23;
        while (2)
        {
          v24 = 0;
          v25 = 1;
          do
          {
            v26 = v25;
            v27 = v18[v24 | v22];
            v28 = v27 - 48;
            if ((v27 - 48) >= 0xA)
            {
              if ((v27 - 97) > 5)
              {
                if ((v27 - 65) > 5)
                {
                  v29 = 141;
                  v30 = 489;
                  goto LABEL_45;
                }
                v28 = v27 - 55;
              }
              else
              {
                v28 = v27 - 87;
              }
            }
            v25 = 0;
            v20[v21 + v10] = v28 | (16 * v20[v21 + v10]);
            v24 = 1;
          }
          while ((v26 & 1) != 0);
          ++v21;
          v22 += 2;
          if (v21 != v23)
            continue;
          break;
        }
      }
      if (v16 != 92)
      {
        v34->length = v19;
        v34->data = (unsigned __int8 *)v20;
        return 1;
      }
      v7 = BIO_gets(bp, buf, size);
      v8 = 1;
      v10 += v17 >> 1;
      v11 = v20;
      if (v7 < 1)
        goto LABEL_44;
    }
    v32 = 145;
    v33 = 467;
    goto LABEL_49;
  }
  v20 = 0;
LABEL_44:
  v29 = 150;
  v30 = 507;
LABEL_45:
  ERR_put_error(13, 4095, v29, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/a_int.c", v30);
  v11 = v20;
LABEL_46:
  free(v11);
  return 0;
}

int i2c_ASN1_INTEGER(ASN1_INTEGER *a, unsigned __int8 **pp)
{
  uint64_t length;
  unsigned __int8 *data;
  size_t v6;
  unsigned __int8 *v7;
  int v8;
  int v10;
  int v11;
  int v12;
  size_t v13;
  size_t v14;
  char *v15;
  char v16;
  char v17;
  unsigned int v18;
  int v19;
  int v20;
  int v21;
  int v22;
  _OWORD v23[2];
  size_t __n;
  void *__src;
  _QWORD v26[3];
  char v27;
  size_t v28;
  unsigned __int8 *v29;

  __n = 0;
  __src = 0;
  memset(v23, 0, sizeof(v23));
  if (!CBB_init((uint64_t)v23, 0))
  {
    v6 = 0;
    goto LABEL_14;
  }
  v28 = 0;
  v29 = 0;
  v27 = 0;
  memset(v26, 0, sizeof(v26));
  length = a->length;
  if ((length & 0x80000000) != 0 || (data = a->data, (_DWORD)length) && !data || (a->type & 0xFFFFFEF7 | 8) != 0xA)
  {
LABEL_11:
    v6 = 0;
    v7 = 0;
LABEL_12:
    freezero(v7, v28);
LABEL_14:
    v8 = -3;
    goto LABEL_15;
  }
  CBS_init(v26, (uint64_t)data, length);
  while (CBS_len((uint64_t)v26))
  {
    if (!CBS_peek_u8((uint64_t)v26, &v27))
      goto LABEL_11;
    if (v27)
      break;
    if (!CBS_skip(v26, 1uLL))
      goto LABEL_11;
  }
  if (CBS_len((uint64_t)v26))
  {
    v10 = CBS_stow((uint64_t)v26, (void **)&v29, &v28);
    v7 = v29;
    if (!v10)
    {
LABEL_43:
      v6 = 0;
      goto LABEL_12;
    }
    if ((a->type & 0x100) != 0)
    {
      v14 = v28;
      if ((uint64_t)(v28 - 1) < 0)
      {
        v18 = *v29;
        v19 = (v18 >> 7) - 1;
        v11 = 1;
LABEL_32:
        if (!v11 || (v18 & 0x80) != 0)
          goto LABEL_35;
LABEL_34:
        v20 = CBB_add_u8((char **)v23, v19);
        v7 = v29;
        if (v20)
        {
LABEL_35:
          v21 = CBB_add_bytes((char **)v23, v7, v28);
          v7 = v29;
          if (v21)
          {
            v13 = v28;
            goto LABEL_37;
          }
          v6 = __n;
          goto LABEL_12;
        }
        goto LABEL_43;
      }
      v15 = (char *)(v29 - 1);
      v16 = 1;
      do
      {
        v17 = v16 + ~v15[v14];
        v15[v14] = v17;
        if (v17)
          v16 = 0;
        --v14;
      }
      while (v14);
      v7 = v29;
      v11 = a->type & 0x100;
    }
    else
    {
      v11 = 0;
    }
    v18 = (char)*v7;
    v19 = ((v18 >> 7) & 1) - 1;
    if (!v11 && (v18 & 0x80000000) != 0)
      goto LABEL_34;
    goto LABEL_32;
  }
  v12 = CBB_add_u8((char **)v23, 0);
  v13 = 0;
  v7 = 0;
  v6 = 0;
  if (!v12)
    goto LABEL_12;
LABEL_37:
  freezero(v7, v13);
  v22 = CBB_finish((uint64_t *)v23, &__src, &__n);
  v6 = __n;
  v8 = -3;
  if (v22 && !(__n >> 31))
  {
    if (!pp)
    {
LABEL_42:
      v8 = v6;
      goto LABEL_15;
    }
    if (!__CFADD__(__n, *pp))
    {
      memcpy(*pp, __src, __n);
      v6 = __n;
      *pp += __n;
      goto LABEL_42;
    }
  }
LABEL_15:
  freezero(__src, v6);
  CBB_cleanup((uint64_t *)v23);
  return v8;
}

uint64_t c2i_ASN1_INTEGER_cbs(ASN1_VALUE **a1, _QWORD *a2)
{
  ASN1_VALUE *v4;
  int v5;
  int v6;
  unsigned __int8 *v7;
  unint64_t v8;
  int v9;
  uint64_t v10;
  unint64_t v12;
  unsigned __int8 *v13;
  int v15;
  ASN1_VALUE *v16;
  size_t v17;
  char *v18;
  char *v19;
  char v20;
  char v21;
  __int16 v22;
  size_t v23;
  char *v24;

  v23 = 0;
  v24 = 0;
  v22 = 0;
  if (!a1)
    goto LABEL_16;
  v4 = *a1;
  if (v4)
  {
    ASN1_item_free(v4, &ASN1_INTEGER_it);
    *a1 = 0;
  }
  if (!CBS_len((uint64_t)a2))
  {
    v9 = 665;
    goto LABEL_15;
  }
  if (!CBS_peek_u8((uint64_t)a2, &v22))
  {
LABEL_16:
    v10 = 0;
    goto LABEL_17;
  }
  v5 = (char)v22;
  v6 = (char)v22 >> 7;
  v22 = (char)v22;
  if ((unint64_t)CBS_len((uint64_t)a2) >= 2 && v22 == v6)
  {
    v7 = (unsigned __int8 *)CBS_data((uint64_t)a2);
    v8 = CBS_len((uint64_t)a2);
    if (v8 >= 2 && *v7 == 255)
    {
      v12 = v8 - 1;
      v13 = v7 + 1;
      while (!*v13++)
      {
        if (!--v12)
          goto LABEL_21;
      }
    }
    if (!CBS_get_u8(a2, (_BYTE *)&v22 + 1) || !CBS_peek_u8((uint64_t)a2, &v22))
      goto LABEL_16;
    if (((HIBYTE(v22) ^ v22) & 0x80) == 0)
    {
      v9 = 687;
LABEL_15:
      ERR_put_error(13, 4095, 62, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/a_int.c", v9);
      goto LABEL_16;
    }
  }
LABEL_21:
  v15 = CBS_stow((uint64_t)a2, (void **)&v24, &v23);
  v10 = 0;
  if (v15 && !(v23 >> 31))
  {
    v16 = ASN1_item_new(&ASN1_INTEGER_it);
    if (!v16)
      goto LABEL_16;
    v17 = v23;
    v18 = v24;
    if (v5 < 0)
    {
      *((_DWORD *)v16 + 1) = 258;
      if ((uint64_t)(v17 - 1) >= 0)
      {
        v19 = v18 - 1;
        v20 = 1;
        do
        {
          v21 = v20 + ~v19[v17];
          v19[v17] = v21;
          if (v21)
            v20 = 0;
          --v17;
        }
        while (v17);
        LODWORD(v17) = v23;
        v18 = v24;
      }
    }
    *((_QWORD *)v16 + 1) = v18;
    *(_DWORD *)v16 = v17;
    v24 = 0;
    v10 = 1;
    *a1 = v16;
  }
LABEL_17:
  ASN1_item_free(0, &ASN1_INTEGER_it);
  freezero(v24, v23);
  return v10;
}

ASN1_INTEGER *__cdecl c2i_ASN1_INTEGER(ASN1_INTEGER **a, const unsigned __int8 **pp, uint64_t length)
{
  ASN1_INTEGER *result;
  _QWORD v7[3];
  ASN1_INTEGER *v8;

  v8 = 0;
  if (a)
  {
    ASN1_item_free((ASN1_VALUE *)*a, &ASN1_INTEGER_it);
    *a = 0;
  }
  if (length < 0)
  {
    ERR_put_error(13, 4095, 136, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/a_int.c", 738);
    return 0;
  }
  memset(v7, 0, sizeof(v7));
  CBS_init(v7, (uint64_t)*pp, length);
  if (!c2i_ASN1_INTEGER_cbs((ASN1_VALUE **)&v8, v7))
    return 0;
  *pp = (const unsigned __int8 *)CBS_data((uint64_t)v7);
  result = v8;
  if (a)
    *a = v8;
  return result;
}

int i2d_ASN1_INTEGER(ASN1_INTEGER *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &ASN1_INTEGER_it);
}

ASN1_INTEGER *__cdecl d2i_ASN1_INTEGER(ASN1_INTEGER **a, const unsigned __int8 **in, uint64_t len)
{
  return (ASN1_INTEGER *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &ASN1_INTEGER_it);
}

ASN1_INTEGER *__cdecl d2i_ASN1_UINTEGER(ASN1_INTEGER **a, const unsigned __int8 **pp, uint64_t length)
{
  ASN1_INTEGER *v6;
  int v7;
  unsigned __int8 *v9;
  unsigned __int8 *v10;
  size_t v11;
  unsigned __int8 *v12;
  int pclass[2];
  uint64_t plength;
  unsigned __int8 *ppa;

  if (!a || (v6 = *a) == 0)
  {
    v6 = (ASN1_INTEGER *)ASN1_item_new(&ASN1_INTEGER_it);
    if (!v6)
      return v6;
  }
  plength = 0;
  ppa = 0;
  *(_QWORD *)pclass = 0;
  if (v6->length < 0)
    goto LABEL_8;
  ppa = (unsigned __int8 *)*pp;
  if ((ASN1_get_object((const unsigned __int8 **)&ppa, &plength, &pclass[1], pclass, length) & 0x80) != 0)
  {
    v7 = 102;
    goto LABEL_11;
  }
  if (pclass[1] != 2)
  {
    v7 = 115;
    goto LABEL_11;
  }
  if ((unint64_t)plength >> 31)
  {
LABEL_8:
    v7 = 62;
    goto LABEL_11;
  }
  v9 = (unsigned __int8 *)malloc_type_malloc(plength + 1, 0xA53C0D48uLL);
  if (!v9)
  {
    v7 = 65;
LABEL_11:
    ERR_put_error(13, 4095, v7, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/a_int.c", 836);
    if (!a || *a != v6)
      ASN1_item_free((ASN1_VALUE *)v6, &ASN1_INTEGER_it);
    return 0;
  }
  v10 = v9;
  v6->type = 2;
  v11 = plength;
  if (plength)
  {
    v12 = ppa;
    if (plength != 1 && !*ppa)
    {
      v12 = ppa + 1;
      --plength;
      ++ppa;
      --v11;
    }
    memcpy(v9, v12, v11);
    ppa += plength;
  }
  free(v6->data);
  v6->data = v10;
  v6->length = plength;
  if (a)
    *a = v6;
  *pp = ppa;
  return v6;
}

void *EVP_sha3_224()
{
  return &sha3_224_md;
}

void *EVP_sha3_256()
{
  return &sha3_256_md;
}

void *EVP_sha3_384()
{
  return &sha3_384_md;
}

void *EVP_sha3_512()
{
  return &sha3_512_md;
}

uint64_t sha3_224_init(uint64_t a1)
{
  return sha3_init(*(_QWORD *)(a1 + 24), 0x1Cu);
}

uint64_t sha3_224_update(uint64_t a1, char *a2, uint64_t a3)
{
  return sha3_update(*(_QWORD **)(a1 + 24), a2, a3);
}

uint64_t sha3_224_final(uint64_t a1, uint64_t a2)
{
  return sha3_final(a2, *(_QWORD **)(a1 + 24));
}

uint64_t sha3_256_init(uint64_t a1)
{
  return sha3_init(*(_QWORD *)(a1 + 24), 0x20u);
}

uint64_t sha3_256_update(uint64_t a1, char *a2, uint64_t a3)
{
  return sha3_update(*(_QWORD **)(a1 + 24), a2, a3);
}

uint64_t sha3_256_final(uint64_t a1, uint64_t a2)
{
  return sha3_final(a2, *(_QWORD **)(a1 + 24));
}

uint64_t sha3_384_init(uint64_t a1)
{
  return sha3_init(*(_QWORD *)(a1 + 24), 0x30u);
}

uint64_t sha3_384_update(uint64_t a1, char *a2, uint64_t a3)
{
  return sha3_update(*(_QWORD **)(a1 + 24), a2, a3);
}

uint64_t sha3_384_final(uint64_t a1, uint64_t a2)
{
  return sha3_final(a2, *(_QWORD **)(a1 + 24));
}

uint64_t sha3_512_init(uint64_t a1)
{
  return sha3_init(*(_QWORD *)(a1 + 24), 0x40u);
}

uint64_t sha3_512_update(uint64_t a1, char *a2, uint64_t a3)
{
  return sha3_update(*(_QWORD **)(a1 + 24), a2, a3);
}

uint64_t sha3_512_final(uint64_t a1, uint64_t a2)
{
  return sha3_final(a2, *(_QWORD **)(a1 + 24));
}

const char *BF_options(void)
{
  return "blowfish(idx)";
}

void BF_ecb_encrypt(const unsigned __int8 *in, unsigned __int8 *out, const BF_KEY *key, int enc)
{
  unsigned int v5;
  unsigned int v6;
  unsigned int v7;
  unsigned int v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v5 = bswap32(*((_DWORD *)in + 1));
  v7 = bswap32(*(_DWORD *)in);
  v8 = v5;
  if (enc)
    BF_encrypt(&v7, key);
  else
    BF_decrypt(&v7, key);
  v6 = bswap32(v8);
  *(_DWORD *)out = bswap32(v7);
  *((_DWORD *)out + 1) = v6;
}

CONF_VALUE *__cdecl _CONF_get_section(const CONF *conf, const char *section)
{
  CONF_VALUE *result;
  _QWORD data[3];

  result = 0;
  if (conf)
  {
    if (section)
    {
      data[1] = 0;
      data[2] = 0;
      data[0] = section;
      return (CONF_VALUE *)lh_retrieve(conf->data, data);
    }
  }
  return result;
}

STACK *__cdecl _CONF_get_section_values(const CONF *conf, const char *section)
{
  STACK *result;
  _QWORD data[3];

  if (!conf || !section)
    return 0;
  data[1] = 0;
  data[2] = 0;
  data[0] = section;
  result = (STACK *)lh_retrieve(conf->data, data);
  if (result)
    return *(STACK **)&result->sorted;
  return result;
}

int _CONF_add_string(CONF *conf, CONF_VALUE *section, CONF_VALUE *value)
{
  char *v5;
  int result;
  char *v7;
  void **v8;

  v5 = section->value;
  value->section = section->section;
  result = sk_push((STACK *)v5, (char *)value);
  if (result)
  {
    v7 = (char *)lh_insert(conf->data, value);
    if (v7)
    {
      v8 = (void **)v7;
      sk_delete_ptr((STACK *)v5, v7);
      free(v8[1]);
      free(v8[2]);
      free(v8);
    }
    return 1;
  }
  return result;
}

char *__cdecl _CONF_get_string(const CONF *conf, const char *section, const char *name)
{
  char *result;
  const char *data;
  const char *v7;
  uint64_t v8;

  result = 0;
  if (conf && name)
  {
    data = 0;
    v7 = 0;
    v8 = 0;
    if (section)
    {
      data = section;
      v7 = name;
      result = (char *)lh_retrieve(conf->data, &data);
      if (result)
        return (char *)*((_QWORD *)result + 2);
    }
    data = "default";
    v7 = name;
    result = (char *)lh_retrieve(conf->data, &data);
    if (result)
      return (char *)*((_QWORD *)result + 2);
  }
  return result;
}

int _CONF_new_data(CONF *conf)
{
  CONF *v1;

  if (conf)
  {
    v1 = conf;
    if (conf->data
      || (conf = (CONF *)lh_new((LHASH_HASH_FN_TYPE)conf_value_LHASH_HASH, (LHASH_COMP_FN_TYPE)conf_value_LHASH_COMP),
          (v1->data = (LHASH *)conf) != 0))
    {
      LODWORD(conf) = 1;
    }
  }
  return (int)conf;
}

unint64_t conf_value_LHASH_HASH(const char **a1)
{
  unint64_t v2;

  v2 = lh_strhash(*a1);
  return lh_strhash(a1[1]) ^ (4 * v2);
}

uint64_t conf_value_LHASH_COMP(const char **a1, const char **a2)
{
  const char *v4;
  const char *v5;
  uint64_t result;
  const char *v7;
  const char *v8;
  unsigned int v9;

  v4 = *a1;
  v5 = *a2;
  if (v4 == v5 || (result = strcmp(v4, v5), !(_DWORD)result))
  {
    v7 = a1[1];
    v8 = a2[1];
    if (v7)
    {
      if (v8)
        return strcmp(v7, v8);
      v9 = 1;
    }
    else
    {
      v9 = -1;
    }
    if (v7 == v8)
      return 0;
    else
      return v9;
  }
  return result;
}

void _CONF_free_data(CONF *conf)
{
  LHASH *data;

  if (conf)
  {
    data = conf->data;
    if (data)
    {
      data->down_load = 0;
      lh_doall_arg(data, (LHASH_DOALL_ARG_FN_TYPE)value_free_hash_LHASH_DOALL_ARG, data);
      lh_doall(conf->data, (LHASH_DOALL_FN_TYPE)value_free_stack_LHASH_DOALL);
      lh_free(conf->data);
    }
  }
}

_QWORD *value_free_hash_LHASH_DOALL_ARG(_QWORD *data, LHASH *lh)
{
  if (data[1])
    return lh_delete(lh, data);
  return data;
}

void value_free_stack_LHASH_DOALL(uint64_t a1)
{
  STACK *v2;
  int v3;
  unsigned int v4;
  void **v5;

  if (!*(_QWORD *)(a1 + 8))
  {
    v2 = *(STACK **)(a1 + 16);
    v3 = sk_num(v2);
    if (v3 >= 1)
    {
      v4 = v3 + 1;
      do
      {
        v5 = (void **)sk_value(v2, v4 - 2);
        free(v5[2]);
        free(v5[1]);
        free(v5);
        --v4;
      }
      while (v4 > 1);
    }
    if (v2)
      sk_free(v2);
    free(*(void **)a1);
    free((void *)a1);
  }
}

CONF_VALUE *__cdecl _CONF_new_section(CONF *conf, const char *section)
{
  STACK *v4;
  STACK *v5;
  CONF_VALUE *v6;
  size_t v7;
  char *v8;

  v4 = sk_new_null();
  if (!v4)
  {
    v6 = 0;
LABEL_8:
    free(v6);
    return 0;
  }
  v5 = v4;
  v6 = (CONF_VALUE *)malloc_type_malloc(0x18uLL, 0x100402FEFCB83uLL);
  if (!v6
    || (v7 = (int)(strlen(section) + 1), v8 = (char *)malloc_type_malloc(v7, 0x9215DE77uLL), (v6->section = v8) == 0))
  {
    sk_free(v5);
    goto LABEL_8;
  }
  memcpy(v8, section, v7);
  v6->name = 0;
  v6->value = (char *)v5;
  if (lh_insert(conf->data, v6))
    OpenSSLDie("/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/conf/conf_api.c", 268, "vv == NULL");
  return v6;
}

ASN1_INTEGER *s2i_asn1_int(X509V3_EXT_METHOD *a1, int a2, char *value)
{
  return s2i_ASN1_INTEGER(a1, value);
}

BIO_METHOD *BIO_f_md(void)
{
  return (BIO_METHOD *)&methods_md;
}

uint64_t md_write(BIO *a1, const void *a2, int a3)
{
  uint64_t v3;
  EVP_MD_CTX *next_bio;
  BIO *prev_bio;
  uint64_t v8;

  v3 = 0;
  if (a2 && a3 >= 1)
  {
    next_bio = (EVP_MD_CTX *)a1->next_bio;
    if (next_bio && (prev_bio = a1->prev_bio) != 0)
    {
      v8 = BIO_write(prev_bio, a2, a3);
      v3 = v8;
      if (a1->flags && (int)v8 >= 1 && !EVP_DigestUpdate(next_bio, a2, v8))
      {
        BIO_clear_flags(a1, 15);
        return 0;
      }
    }
    else
    {
      v3 = 0;
    }
    if (a1->prev_bio)
    {
      BIO_clear_flags(a1, 15);
      BIO_copy_next_retry(a1);
    }
  }
  return v3;
}

uint64_t md_read(BIO *a1, void *a2, int a3)
{
  EVP_MD_CTX *next_bio;
  BIO *prev_bio;
  uint64_t v7;
  uint64_t v8;

  if (!a2)
    return 0;
  next_bio = (EVP_MD_CTX *)a1->next_bio;
  if (!next_bio)
    return 0;
  prev_bio = a1->prev_bio;
  if (!prev_bio)
    return 0;
  v7 = BIO_read(prev_bio, a2, a3);
  v8 = v7;
  if (a1->flags && (int)v7 >= 1 && EVP_DigestUpdate(next_bio, a2, v7) < 1)
    return 0xFFFFFFFFLL;
  BIO_clear_flags(a1, 15);
  BIO_copy_next_retry(a1);
  return v8;
}

uint64_t md_gets(uint64_t a1, unsigned __int8 *a2, int a3)
{
  EVP_MD_CTX *v3;
  unsigned int s;

  v3 = *(EVP_MD_CTX **)(a1 + 56);
  if (v3->digest->md_size > a3)
    return 0;
  s = 0;
  if (EVP_DigestFinal_ex(v3, a2, &s) < 1)
    return 0xFFFFFFFFLL;
  else
    return s;
}

uint64_t md_ctrl(BIO *b, int a2, uint64_t a3, bio_st *type)
{
  const EVP_MD_CTX *next_bio;
  uint64_t v8;
  uint64_t result;
  BIO *prev_bio;

  next_bio = (const EVP_MD_CTX *)b->next_bio;
  if (a2 <= 110)
  {
    switch(a2)
    {
      case 1:
        if (b->flags)
        {
          LODWORD(result) = EVP_DigestInit_ex((EVP_MD_CTX *)b->next_bio, next_bio->digest, 0);
          if ((int)result >= 1)
          {
            prev_bio = b->prev_bio;
            a2 = 1;
            return BIO_ctrl(prev_bio, a2, a3, type);
          }
          return (int)result;
        }
        break;
      case 12:
        if (EVP_MD_CTX_copy_ex((EVP_MD_CTX *)type->next_bio, next_bio))
        {
LABEL_24:
          result = 1;
          b->flags = 1;
          return result;
        }
        break;
      case 101:
        BIO_clear_flags(b, 15);
        v8 = BIO_ctrl(b->prev_bio, 101, a3, type);
        BIO_copy_next_retry(b);
        return v8;
      default:
LABEL_26:
        prev_bio = b->prev_bio;
        return BIO_ctrl(prev_bio, a2, a3, type);
    }
    return 0;
  }
  if (a2 > 119)
  {
    if (a2 != 120)
    {
      if (a2 == 148)
      {
        if (b->flags)
        {
          b->next_bio = type;
          return 1;
        }
        return 0;
      }
      goto LABEL_26;
    }
    type->method = (BIO_METHOD *)next_bio;
    goto LABEL_24;
  }
  if (a2 != 111)
  {
    if (a2 == 112)
    {
      if (b->flags)
      {
        type->method = (BIO_METHOD *)next_bio->digest;
        return 1;
      }
      return 0;
    }
    goto LABEL_26;
  }
  result = EVP_DigestInit_ex((EVP_MD_CTX *)b->next_bio, (const EVP_MD *)type, 0);
  if ((int)result >= 1)
    b->flags = 1;
  return result;
}

uint64_t md_new(uint64_t a1)
{
  uint64_t result;

  result = (uint64_t)EVP_MD_CTX_create();
  if (result)
  {
    *(_DWORD *)(a1 + 32) = 0;
    *(_QWORD *)(a1 + 56) = result;
    result = 1;
    *(_DWORD *)(a1 + 40) = 0;
  }
  return result;
}

uint64_t md_free(uint64_t result)
{
  uint64_t v1;

  if (result)
  {
    v1 = result;
    EVP_MD_CTX_destroy(*(EVP_MD_CTX **)(result + 56));
    *(_QWORD *)(v1 + 56) = 0;
    *(_DWORD *)(v1 + 32) = 0;
    result = 1;
    *(_DWORD *)(v1 + 40) = 0;
  }
  return result;
}

BIO *md_callback_ctrl(uint64_t a1, int a2, void (__cdecl *a3)(bio_st *, int, const char *, int, uint64_t, uint64_t))
{
  BIO *result;

  result = *(BIO **)(a1 + 64);
  if (result)
    return (BIO *)BIO_callback_ctrl(result, a2, a3);
  return result;
}

STACK *__cdecl i2v_ASN1_BIT_STRING(X509V3_EXT_METHOD *method, ASN1_BIT_STRING *bits, STACK *extlist)
{
  STACK *v5;
  char *usr_data;
  uint64_t v7;
  STACK *extlista;

  extlista = extlist;
  if (extlist)
  {
    v5 = 0;
  }
  else
  {
    extlist = sk_new_null();
    extlista = extlist;
    v5 = extlist;
    if (!extlist)
      return extlist;
  }
  usr_data = (char *)method->usr_data;
  if (*((_QWORD *)usr_data + 1))
  {
    while (!ASN1_BIT_STRING_get_bit(bits, *(_DWORD *)usr_data)
         || X509V3_add_value(*((const char **)usr_data + 1), 0, &extlista))
    {
      v7 = *((_QWORD *)usr_data + 4);
      usr_data += 24;
      if (!v7)
        return extlista;
    }
    sk_pop_free(v5, (void (__cdecl *)(void *))X509V3_conf_free);
    return 0;
  }
  return extlist;
}

ASN1_BIT_STRING *__cdecl v2i_ASN1_BIT_STRING(X509V3_EXT_METHOD *method, X509V3_CTX *ctx, STACK *nval)
{
  ASN1_BIT_STRING *v5;
  int v6;
  char *v7;
  const char **v8;
  char *usr_data;
  const char *v10;
  const char *v11;
  const char **v12;

  v5 = ASN1_BIT_STRING_new();
  if (v5)
  {
    if (sk_num(nval) >= 1)
    {
      v6 = 0;
      while (1)
      {
        v7 = sk_value(nval, v6);
        v8 = (const char **)v7;
        usr_data = (char *)method->usr_data;
        v10 = (const char *)*((_QWORD *)usr_data + 1);
        if (!v10)
        {
LABEL_15:
          ERR_put_error(34, 4095, 111, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_bitst.c", 212);
          ERR_asprintf_error_data("section:%s,name:%s,value:%s", *v8, v8[1], v8[2]);
          goto LABEL_16;
        }
        v11 = (const char *)*((_QWORD *)v7 + 1);
        v12 = (const char **)(usr_data + 16);
        while (strcmp(*v12, v11) && strcmp(v10, v11))
        {
          v10 = v12[2];
          v12 += 3;
          if (!v10)
            goto LABEL_15;
        }
        if (!ASN1_BIT_STRING_set_bit(v5, *((_DWORD *)v12 - 4), 1))
          break;
        if (!*(v12 - 1))
          goto LABEL_15;
        if (++v6 >= sk_num(nval))
          return v5;
      }
      ERR_put_error(34, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_bitst.c", 204);
LABEL_16:
      ASN1_BIT_STRING_free(v5);
      return 0;
    }
  }
  else
  {
    ERR_put_error(34, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_bitst.c", 194);
  }
  return v5;
}

const EVP_MD *EVP_md5(void)
{
  return (const EVP_MD *)&md5_md;
}

uint64_t init_0(uint64_t a1)
{
  return MD5_Init(*(_MD5_CTX **)(a1 + 24));
}

uint64_t update_0(uint64_t a1, const void *a2, size_t a3)
{
  return MD5_Update(*(_MD5_CTX **)(a1 + 24), a2, a3);
}

uint64_t final_0(uint64_t a1, unsigned __int8 *md)
{
  return MD5_Final(md, *(_MD5_CTX **)(a1 + 24));
}

int ASN1_item_digest(const ASN1_ITEM *it, const EVP_MD *type, void *data, unsigned __int8 *md, unsigned int *len)
{
  int v8;
  _BOOL4 v9;
  unsigned __int8 *out;

  out = 0;
  v8 = ASN1_item_i2d((ASN1_VALUE *)data, &out, it);
  if (!out)
    return 0;
  v9 = EVP_Digest(out, v8, md, len, type, 0) != 0;
  free(out);
  return v9;
}

void *__cdecl ASN1_item_dup(const ASN1_ITEM *it, void *x)
{
  int v3;
  ASN1_VALUE *v4;
  unsigned __int8 *v6;
  unsigned __int8 *out;

  out = 0;
  if (!x)
    return 0;
  v3 = ASN1_item_i2d((ASN1_VALUE *)x, &out, it);
  if (!out)
  {
    ERR_put_error(13, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/asn1_item.c", 161);
    return 0;
  }
  v6 = out;
  v4 = ASN1_item_d2i(0, (const unsigned __int8 **)&v6, v3, it);
  free(out);
  return v4;
}

ASN1_STRING *__cdecl ASN1_item_pack(void *obj, const ASN1_ITEM *it, ASN1_OCTET_STRING **oct)
{
  ASN1_STRING *v6;
  int v7;
  int v8;
  int v9;

  if (!oct || (v6 = *oct) == 0)
  {
    v6 = ASN1_STRING_new();
    if (!v6)
    {
      ERR_put_error(13, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/asn1_item.c", 178);
      return v6;
    }
  }
  free(v6->data);
  v6->data = 0;
  v7 = ASN1_item_i2d((ASN1_VALUE *)obj, &v6->data, it);
  v6->length = v7;
  if (v7)
  {
    if (v6->data)
    {
      if (oct)
        *oct = v6;
      return v6;
    }
    v8 = 65;
    v9 = 192;
  }
  else
  {
    v8 = 112;
    v9 = 188;
  }
  ERR_put_error(13, 4095, v8, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/asn1_item.c", v9);
  if (!oct || v6 != *oct)
    ASN1_STRING_free(v6);
  return 0;
}

void *__cdecl ASN1_item_unpack(ASN1_STRING *oct, const ASN1_ITEM *it)
{
  ASN1_VALUE *v2;
  unsigned __int8 *in;

  in = oct->data;
  v2 = ASN1_item_d2i(0, (const unsigned __int8 **)&in, oct->length, it);
  if (!v2)
    ERR_put_error(13, 4095, 110, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/asn1_item.c", 213);
  return v2;
}

int ASN1_item_sign(const ASN1_ITEM *it, X509_ALGOR *algor1, X509_ALGOR *algor2, ASN1_BIT_STRING *signature, void *data, EVP_PKEY *pkey, const EVP_MD *type)
{
  EVP_MD_CTX v15;
  __int128 v16;

  v16 = 0u;
  memset(&v15, 0, sizeof(v15));
  EVP_MD_CTX_init(&v15);
  if (EVP_DigestSignInit((uint64_t)&v15, 0, type, 0, (uint64_t)pkey))
    return ASN1_item_sign_ctx(it, algor1, algor2, signature, (ASN1_VALUE *)data, &v15);
  EVP_MD_CTX_cleanup(&v15);
  return 0;
}

uint64_t ASN1_item_sign_ctx(const ASN1_ITEM *a1, X509_ALGOR *a2, X509_ALGOR *a3, ASN1_STRING *a4, ASN1_VALUE *a5, EVP_MD_CTX *ctx)
{
  const EVP_MD *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t (*v15)(EVP_MD_CTX *, const ASN1_ITEM *, ASN1_VALUE *, X509_ALGOR *, X509_ALGOR *, ASN1_STRING *);
  int v16;
  void *v17;
  unsigned int v18;
  uint64_t v19;
  int length;
  int v21;
  int v22;
  int v23;
  int v24;
  ASN1_OBJECT *v25;
  ASN1_OBJECT *v26;
  int v27;
  int v28;
  uint64_t v29;
  int v30;
  int v31;
  int n;
  int len[2];
  unsigned __int8 *out;

  *(_QWORD *)len = 0;
  out = 0;
  v12 = EVP_MD_CTX_md(ctx);
  v13 = EVP_PKEY_CTX_get0_pkey((uint64_t)ctx[1].digest);
  if (v12 && (v14 = v13) != 0)
  {
    n = 0;
    v15 = *(uint64_t (**)(EVP_MD_CTX *, const ASN1_ITEM *, ASN1_VALUE *, X509_ALGOR *, X509_ALGOR *, ASN1_STRING *))(*(_QWORD *)(v13 + 16) + 208);
    if (!v15)
      goto LABEL_11;
    v16 = v15(ctx, a1, a5, a2, a3, a4);
    if (v16 == 1)
    {
      v17 = 0;
      v18 = 0;
      v19 = 0;
      length = a4->length;
LABEL_35:
      EVP_MD_CTX_cleanup(ctx);
      freezero(out, v18);
      freezero(v17, length);
      return v19;
    }
    if (v16 <= 0)
    {
      ERR_put_error(13, 4095, 6, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/asn1_item.c", 263);
      goto LABEL_28;
    }
    if (v16 != 2)
    {
LABEL_19:
      v27 = ASN1_item_i2d(a5, &out, a1);
      if (v27 >= 1)
      {
        v18 = v27;
        v28 = EVP_PKEY_size((EVP_PKEY *)v14);
        if (v28 >= 1)
        {
          length = v28;
          v29 = v28;
          v17 = malloc_type_malloc(v28, 0x6D146B38uLL);
          if (v17)
          {
            *(_QWORD *)len = v29;
            if (EVP_DigestUpdate(ctx, out, v18) && EVP_DigestSignFinal((uint64_t)ctx, (uint64_t)v17, len))
            {
              if (!(*(_QWORD *)len >> 31))
              {
                ASN1_STRING_set0(a4, v17, len[0]);
                if (asn1_abs_set_unused_bits((uint64_t)a4, 0))
                {
                  v17 = 0;
                  v19 = len[0];
                  goto LABEL_35;
                }
                ERR_put_error(13, 4095, 13, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/asn1_item.c", 321);
                v17 = 0;
                goto LABEL_34;
              }
              v30 = 155;
              v31 = 313;
            }
            else
            {
              v30 = 6;
              v31 = 308;
            }
          }
          else
          {
            v30 = 65;
            v31 = 301;
          }
          ERR_put_error(13, 4095, v30, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/asn1_item.c", v31);
LABEL_34:
          v19 = 0;
          goto LABEL_35;
        }
        v17 = 0;
LABEL_30:
        length = 0;
        goto LABEL_34;
      }
LABEL_28:
      v17 = 0;
      v18 = 0;
      goto LABEL_30;
    }
    if (*(_QWORD *)(v14 + 16))
    {
LABEL_11:
      v23 = EVP_MD_type(v12);
      if (OBJ_find_sigid_by_algs(&n, v23, **(_DWORD **)(v14 + 16)))
      {
        if ((*(_BYTE *)(*(_QWORD *)(v14 + 16) + 8) & 4) != 0)
          v24 = 5;
        else
          v24 = -1;
        if (a2)
        {
          v25 = OBJ_nid2obj(n);
          X509_ALGOR_set0(a2, v25, v24, 0);
        }
        if (a3)
        {
          v26 = OBJ_nid2obj(n);
          X509_ALGOR_set0(a3, v26, v24, 0);
        }
        goto LABEL_19;
      }
    }
    v21 = 198;
    v22 = 272;
  }
  else
  {
    v21 = 217;
    v22 = 247;
  }
  ERR_put_error(13, 4095, v21, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/asn1_item.c", v22);
  return 0;
}

int ASN1_item_verify(const ASN1_ITEM *it, X509_ALGOR *algor1, ASN1_BIT_STRING *signature, void *data, EVP_PKEY *pkey)
{
  int v10;
  int v11;
  int v12;
  const char *v13;
  const EVP_MD *digestbyname;
  const EVP_MD *v15;
  int v16;
  int v17;
  int v18;
  int v19;
  char *ptr;
  uint64_t (*v21)(EVP_MD_CTX *, const ASN1_ITEM *, void *, X509_ALGOR *, ASN1_BIT_STRING *, EVP_PKEY *);
  int v22;
  unsigned int v23;
  int n[2];
  unsigned __int8 *out;
  EVP_MD_CTX ctx;
  __int128 v28;

  out = 0;
  if (!pkey)
  {
    v10 = 67;
    v11 = 345;
    goto LABEL_12;
  }
  if (signature->type != 3 || (signature->flags & 7) == 0)
  {
    v28 = 0u;
    memset(&ctx, 0, sizeof(ctx));
    *(_QWORD *)n = 0;
    EVP_MD_CTX_init(&ctx);
    v12 = OBJ_obj2nid(algor1->algorithm);
    if (OBJ_find_sigid_algs(v12, &n[1], n))
    {
      if (n[1])
      {
        v13 = OBJ_nid2sn(n[1]);
        digestbyname = EVP_get_digestbyname(v13);
        if (!digestbyname)
        {
          v18 = 161;
          v19 = 380;
          goto LABEL_25;
        }
        v15 = digestbyname;
        if (EVP_PKEY_type(n[0]) != *(_DWORD *)pkey->pkey.ptr)
        {
          v18 = 200;
          v19 = 386;
          goto LABEL_25;
        }
        if (!EVP_DigestVerifyInit((uint64_t)&ctx, 0, v15, 0, (uint64_t)pkey))
        {
          v16 = 391;
LABEL_30:
          ERR_put_error(13, 4095, 6, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/asn1_item.c", v16);
          v17 = 0;
          goto LABEL_26;
        }
      }
      else
      {
        ptr = pkey->pkey.ptr;
        if (!ptr
          || (v21 = (uint64_t (*)(EVP_MD_CTX *, const ASN1_ITEM *, void *, X509_ALGOR *, ASN1_BIT_STRING *, EVP_PKEY *))*((_QWORD *)ptr + 25)) == 0)
        {
          v18 = 199;
          v19 = 364;
          goto LABEL_25;
        }
        v17 = v21(&ctx, it, data, algor1, signature, pkey);
        if (v17 != 2)
          goto LABEL_26;
      }
      v22 = ASN1_item_i2d((ASN1_VALUE *)data, &out, it);
      if (out)
      {
        v23 = v22;
        if (!EVP_DigestUpdate(&ctx, out, v22))
        {
          v16 = 406;
          goto LABEL_30;
        }
        freezero(out, v23);
        if ((int)EVP_DigestVerifyFinal((uint64_t)&ctx, (uint64_t)signature->data, signature->length) <= 0)
        {
          v16 = 415;
          goto LABEL_30;
        }
        v17 = 1;
LABEL_26:
        EVP_MD_CTX_cleanup(&ctx);
        return v17;
      }
      v18 = 65;
      v19 = 401;
    }
    else
    {
      v18 = 199;
      v19 = 359;
    }
LABEL_25:
    ERR_put_error(13, 4095, v18, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/asn1_item.c", v19);
    v17 = -1;
    goto LABEL_26;
  }
  v10 = 220;
  v11 = 351;
LABEL_12:
  ERR_put_error(13, 4095, v10, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/asn1_item.c", v11);
  return -1;
}

uint64_t asn1_d2i_read_bio(BIO *a1, BUF_MEM **a2)
{
  BUF_MEM *v4;
  BUF_MEM *v5;
  int v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  BOOL v11;
  unsigned __int8 *v12;
  char object;
  uint64_t v14;
  unint64_t v15;
  BOOL v16;
  unint64_t v17;
  unint64_t v18;
  int v19;
  int v20;
  int v21;
  int v22;
  int pclass[2];
  uint64_t plength;
  unsigned __int8 *pp;

  v4 = BUF_MEM_new();
  if (!v4)
  {
    ERR_put_error(13, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/asn1_item.c", 446);
    return 0xFFFFFFFFLL;
  }
  v5 = v4;
  plength = 0;
  pp = 0;
  *(_QWORD *)pclass = 0;
  ERR_clear_error();
  v6 = 0;
  v7 = 0;
  v8 = 0;
  while (1)
  {
    while (1)
    {
      v9 = v8 - v7;
      if (v8 - v7 <= 8)
      {
        if (__CFADD__(8 - v9, v8) || !BUF_MEM_grow_clean(v5, v7 + 8))
        {
          v21 = 65;
          v22 = 457;
LABEL_43:
          ERR_put_error(13, 4095, v21, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/asn1_item.c", v22);
LABEL_44:
          BUF_MEM_free(v5);
          return 0xFFFFFFFFLL;
        }
        v10 = BIO_read(a1, &v5->data[v8], 8 - v9);
        if (v8 == v7 && v10 < 0)
        {
          v21 = 142;
          v22 = 462;
          goto LABEL_43;
        }
        if (v10 >= 1)
        {
          v11 = __CFADD__(v8, v10);
          v8 += v10;
          if (v11)
          {
            v21 = 155;
            v22 = 467;
            goto LABEL_43;
          }
          v9 = v8 - v7;
        }
      }
      v12 = (unsigned __int8 *)&v5->data[v7];
      pp = v12;
      object = ASN1_get_object((const unsigned __int8 **)&pp, &plength, &pclass[1], pclass, v9);
      if (object < 0)
      {
        if ((ERR_peek_error() & 0xFFF) != 0x9B)
          goto LABEL_44;
        ERR_clear_error();
      }
      v7 += (int)pp - (int)v12;
      if ((object & 1) != 0)
      {
        v20 = 1;
        goto LABEL_41;
      }
      v14 = plength;
      if (v6)
      {
        if (!plength && !pclass[1])
          break;
      }
      v15 = plength - (v8 - v7);
      if (plength > v8 - v7)
      {
        v16 = __CFADD__(v8, v15);
        if (v15 >> 31 || v16)
        {
          v21 = 155;
          v22 = 514;
          goto LABEL_43;
        }
        if (v15)
        {
          v17 = 0x4000;
          while (2)
          {
            if (v15 >= v17)
              v18 = v17;
            else
              v18 = v15;
            if (!BUF_MEM_grow_clean(v5, v18 + v8))
            {
              v21 = 65;
              v22 = 527;
              goto LABEL_43;
            }
            v15 -= v18;
            do
            {
              v19 = BIO_read(a1, &v5->data[v8], v18);
              if (v19 <= 0)
              {
                v21 = 142;
                v22 = 534;
                goto LABEL_43;
              }
              v8 += v19;
              v18 -= v19;
            }
            while (v18);
            v17 <<= v17 < 0x3FFFFFFF;
            if (v15)
              continue;
            break;
          }
          v14 = plength;
        }
      }
      v11 = __CFADD__(v14, v7);
      v7 += v14;
      if (v11)
      {
        v21 = 155;
        v22 = 549;
        goto LABEL_43;
      }
      if (v6 <= 0)
        goto LABEL_50;
    }
    if (v6 < 2)
      break;
    v20 = -1;
LABEL_41:
    v6 += v20;
  }
LABEL_50:
  if (v7 >> 31)
  {
    v21 = 155;
    v22 = 561;
    goto LABEL_43;
  }
  *a2 = v5;
  return v7;
}

void *__cdecl ASN1_item_d2i_bio(const ASN1_ITEM *it, BIO *in, void *x)
{
  unsigned int v5;
  BUF_MEM *v6;
  ASN1_VALUE *v7;
  void *result;
  char *data;
  BUF_MEM *v10;

  data = 0;
  v10 = 0;
  v5 = asn1_d2i_read_bio(in, &v10);
  v6 = v10;
  if ((v5 & 0x80000000) != 0)
  {
    v7 = 0;
    result = 0;
    if (!v10)
      return result;
  }
  else
  {
    data = v10->data;
    v7 = ASN1_item_d2i((ASN1_VALUE **)x, (const unsigned __int8 **)&data, v5, it);
  }
  BUF_MEM_free(v6);
  return v7;
}

void *__cdecl ASN1_item_d2i_fp(const ASN1_ITEM *it, FILE *in, void *x)
{
  BIO_METHOD *v6;
  BIO *v7;
  BIO *v8;
  void *v9;

  v6 = BIO_s_file();
  v7 = BIO_new(v6);
  if (v7)
  {
    v8 = v7;
    BIO_ctrl(v7, 106, 0, in);
    v9 = ASN1_item_d2i_bio(it, v8, x);
    BIO_free(v8);
    return v9;
  }
  else
  {
    ERR_put_error(13, 4095, 7, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/asn1_item.c", 602);
    return 0;
  }
}

int ASN1_item_i2d_bio(const ASN1_ITEM *it, BIO *out, void *x)
{
  int v4;
  int v5;
  int v6;
  int v7;
  int v8;
  unsigned __int8 *outa;

  outa = 0;
  v4 = ASN1_item_i2d((ASN1_VALUE *)x, &outa, it);
  if (outa)
  {
    v5 = v4;
    v6 = BIO_write(out, outa, v4);
    if (v6 == v5)
    {
LABEL_6:
      v8 = 1;
    }
    else
    {
      v7 = 0;
      while (v6 >= 1)
      {
        v7 += v6;
        v5 -= v6;
        v6 = BIO_write(out, &outa[v7], v5);
        if (v6 == v5)
          goto LABEL_6;
      }
      v8 = 0;
    }
    free(outa);
  }
  else
  {
    ERR_put_error(13, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/asn1_item.c", 619);
    return 0;
  }
  return v8;
}

int ASN1_item_i2d_fp(const ASN1_ITEM *it, FILE *out, void *x)
{
  BIO_METHOD *v6;
  BIO *v7;
  BIO *v8;
  int v9;

  v6 = BIO_s_file();
  v7 = BIO_new(v6);
  if (v7)
  {
    v8 = v7;
    BIO_ctrl(v7, 106, 0, out);
    v9 = ASN1_item_i2d_bio(it, v8, x);
    BIO_free(v8);
    return v9;
  }
  else
  {
    ERR_put_error(13, 4095, 7, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/asn1_item.c", 645);
    return 0;
  }
}

void ERR_load_X509_strings(void)
{
  if (!ERR_func_error_string(X509_str_functs))
  {
    ERR_load_strings(0, (ERR_STRING_DATA *)&X509_str_functs);
    ERR_load_strings(0, (ERR_STRING_DATA *)&X509_str_reasons);
  }
}

void ERR_load_X509V3_strings(void)
{
  if (!ERR_func_error_string(X509V3_str_functs))
  {
    ERR_load_strings(0, (ERR_STRING_DATA *)&X509V3_str_functs);
    ERR_load_strings(0, (ERR_STRING_DATA *)&X509V3_str_reasons);
  }
}

const EVP_CIPHER *EVP_cast5_cbc(void)
{
  return (const EVP_CIPHER *)&cast5_cbc;
}

const EVP_CIPHER *EVP_cast5_cfb64(void)
{
  return (const EVP_CIPHER *)&cast5_cfb64;
}

const EVP_CIPHER *EVP_cast5_ofb(void)
{
  return (const EVP_CIPHER *)&cast5_ofb;
}

const EVP_CIPHER *EVP_cast5_ecb(void)
{
  return (const EVP_CIPHER *)&cast5_ecb;
}

uint64_t cast_init_key(const EVP_CIPHER_CTX *a1, const unsigned __int8 *a2)
{
  CAST_KEY *cipher_data;
  int v4;

  cipher_data = (CAST_KEY *)a1->cipher_data;
  v4 = EVP_CIPHER_CTX_key_length(a1);
  CAST_set_key(cipher_data, v4, a2);
  return 1;
}

uint64_t cast5_cbc_cipher(uint64_t a1, unsigned __int8 *out, unsigned __int8 *in, unint64_t length)
{
  unint64_t i;

  for (i = length; i > 0x7FFFFFFFFFFFFEFFLL; out += 0x7FFFFFFFFFFFFF00)
  {
    CAST_cbc_encrypt(in, out, 0x7FFFFFFFFFFFFF00, *(const CAST_KEY **)(a1 + 120), (unsigned __int8 *)(a1 + 40), *(_DWORD *)(a1 + 16));
    i -= 0x7FFFFFFFFFFFFF00;
    in += 0x7FFFFFFFFFFFFF00;
  }
  if (i)
    CAST_cbc_encrypt(in, out, i, *(const CAST_KEY **)(a1 + 120), (unsigned __int8 *)(a1 + 40), *(_DWORD *)(a1 + 16));
  return 1;
}

uint64_t cast5_cfb64_cipher(uint64_t a1, unsigned __int8 *out, unsigned __int8 *in, unint64_t a4)
{
  unint64_t v4;
  unint64_t v8;
  unsigned __int8 *v9;
  int *v10;

  if (a4)
  {
    v4 = a4;
    if (a4 >= 0x7FFFFFFFFFFFFF00)
      v8 = 0x7FFFFFFFFFFFFF00;
    else
      v8 = a4;
    v9 = (unsigned __int8 *)(a1 + 40);
    v10 = (int *)(a1 + 88);
    do
    {
      CAST_cfb64_encrypt(in, out, v8, *(const CAST_KEY **)(a1 + 120), v9, v10, *(_DWORD *)(a1 + 16));
      in += v8;
      out += v8;
      v4 -= v8;
      if (v4 < v8)
        v8 = v4;
    }
    while (v4);
  }
  return 1;
}

uint64_t cast5_ofb_cipher(uint64_t a1, unsigned __int8 *out, unsigned __int8 *in, unint64_t length)
{
  unint64_t i;

  for (i = length; i > 0x7FFFFFFFFFFFFEFFLL; out += 0x7FFFFFFFFFFFFF00)
  {
    CAST_ofb64_encrypt(in, out, 0x7FFFFFFFFFFFFF00, *(const CAST_KEY **)(a1 + 120), (unsigned __int8 *)(a1 + 40), (int *)(a1 + 88));
    i -= 0x7FFFFFFFFFFFFF00;
    in += 0x7FFFFFFFFFFFFF00;
  }
  if (i)
    CAST_ofb64_encrypt(in, out, i, *(const CAST_KEY **)(a1 + 120), (unsigned __int8 *)(a1 + 40), (int *)(a1 + 88));
  return 1;
}

uint64_t cast5_ecb_cipher(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  unint64_t v4;
  unint64_t v5;
  unint64_t v9;

  v4 = *(int *)(*(_QWORD *)a1 + 4);
  v5 = a4 - v4;
  if (a4 >= v4)
  {
    v9 = 0;
    do
    {
      CAST_ecb_encrypt((const unsigned __int8 *)(a3 + v9), (unsigned __int8 *)(a2 + v9), *(const CAST_KEY **)(a1 + 120), *(_DWORD *)(a1 + 16));
      v9 += v4;
    }
    while (v9 <= v5);
  }
  return 1;
}

ASN1_OBJECT *__cdecl OBJ_dup(const ASN1_OBJECT *o)
{
  ASN1_OBJECT *v2;
  unsigned __int8 *v3;
  unsigned __int8 *v4;
  unsigned __int8 *data;
  const char *ln;
  char *v7;
  char *v8;
  char *v9;

  if (!o)
    return 0;
  if ((o->flags & 1) != 0)
  {
    v2 = ASN1_OBJECT_new();
    if (!v2)
    {
      ERR_put_error(8, 4095, 13, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/objects/obj_lib.c", 84);
      return v2;
    }
    v3 = (unsigned __int8 *)malloc_type_malloc(o->length, 0x40F1F4B9uLL);
    v4 = v3;
    if (v3)
    {
      data = o->data;
      if (data)
        memcpy(v3, data, o->length);
      v2->data = v4;
      *(_QWORD *)&v2->nid = *(_QWORD *)&o->nid;
      v2->sn = 0;
      v2->ln = 0;
      ln = o->ln;
      if (!ln)
      {
        v8 = 0;
        goto LABEL_14;
      }
      v7 = strdup(ln);
      v8 = v7;
      if (v7)
      {
        v2->ln = v7;
LABEL_14:
        if (!o->sn)
        {
LABEL_17:
          v2->flags = o->flags | 0xD;
          return v2;
        }
        v9 = strdup(o->sn);
        if (v9)
        {
          v2->sn = v9;
          goto LABEL_17;
        }
      }
    }
    else
    {
      v8 = 0;
    }
    ERR_put_error(8, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/objects/obj_lib.c", 115);
    free(v8);
    free(v4);
    free(v2);
    return 0;
  }
  return (ASN1_OBJECT *)o;
}

int OBJ_cmp(const ASN1_OBJECT *a, const ASN1_OBJECT *b)
{
  size_t length;

  length = a->length;
  if ((_DWORD)length == b->length)
    return memcmp(a->data, b->data, length);
  else
    return length - b->length;
}

void RC4(RC4_KEY *key, unint64_t len, const unsigned __int8 *indata, unsigned __int8 *outdata)
{
  int v4;
  int v5;
  unsigned __int8 *v6;
  unint64_t v7;
  int v8;
  unsigned __int8 v9;
  int v10;
  int v11;
  unsigned __int8 v12;
  int v13;
  int v14;
  unsigned __int8 v15;
  int v16;
  int v17;
  unsigned __int8 v18;
  int v19;
  int v20;
  unsigned __int8 v21;
  int v22;
  int v23;
  unsigned __int8 v24;
  int v25;
  int v26;
  unsigned __int8 v27;
  int v28;
  int v29;
  int v30;
  int v31;
  const unsigned __int8 *v32;
  int v33;
  unsigned __int8 v34;
  int v35;
  uint64_t v36;
  int v37;
  unsigned __int8 v38;
  int v39;
  uint64_t v40;
  int v41;
  unsigned __int8 v42;
  int v43;
  unint64_t v44;
  int v45;
  unsigned __int8 v46;
  int v47;
  uint64_t v48;
  int v49;
  unsigned __int8 v50;
  int v51;
  unint64_t v52;
  int v53;
  unsigned __int8 v54;
  int v55;
  uint64_t v56;
  int v57;
  unsigned __int8 v58;
  int v59;
  uint64_t v60;
  unint64_t v61;
  int v62;
  unint64_t v63;
  int v64;
  int v65;
  char v66;
  int v67;
  int v68;
  unsigned __int8 v69;
  int v70;
  int v71;
  unsigned __int8 v72;
  int v73;
  int v74;
  unsigned __int8 v75;
  int v76;
  int v77;
  unsigned __int8 v78;
  int v79;
  int v80;
  unsigned __int8 v81;
  int v82;
  int v83;
  int v84;

  v4 = *(_DWORD *)&key->x;
  v5 = *(_DWORD *)&key->data[2];
  v6 = &key->data[6];
  if (((outdata | indata) & 7) != 0)
  {
    if (len >= 8)
    {
      v7 = len >> 3;
      do
      {
        v8 = *(_DWORD *)&v6[4 * (v4 + 1)];
        v9 = v8 + v5;
        v10 = *(_DWORD *)&v6[4 * v9];
        *(_DWORD *)&v6[4 * (v4 + 1)] = v10;
        *(_DWORD *)&v6[4 * v9] = v8;
        *outdata = *indata ^ *(_DWORD *)&v6[4 * (v10 + v8)];
        v11 = *(_DWORD *)&v6[4 * (v4 + 2)];
        v12 = v11 + v9;
        v13 = *(_DWORD *)&v6[4 * v12];
        *(_DWORD *)&v6[4 * (v4 + 2)] = v13;
        *(_DWORD *)&v6[4 * v12] = v11;
        outdata[1] = indata[1] ^ *(_DWORD *)&v6[4 * (v13 + v11)];
        v14 = *(_DWORD *)&v6[4 * (v4 + 3)];
        v15 = v14 + v12;
        v16 = *(_DWORD *)&v6[4 * v15];
        *(_DWORD *)&v6[4 * (v4 + 3)] = v16;
        *(_DWORD *)&v6[4 * v15] = v14;
        outdata[2] = indata[2] ^ *(_DWORD *)&v6[4 * (v16 + v14)];
        v17 = *(_DWORD *)&v6[4 * (v4 + 4)];
        v18 = v17 + v15;
        v19 = *(_DWORD *)&v6[4 * v18];
        *(_DWORD *)&v6[4 * (v4 + 4)] = v19;
        *(_DWORD *)&v6[4 * v18] = v17;
        outdata[3] = indata[3] ^ *(_DWORD *)&v6[4 * (v19 + v17)];
        v20 = *(_DWORD *)&v6[4 * (v4 + 5)];
        v21 = v20 + v18;
        v22 = *(_DWORD *)&v6[4 * v21];
        *(_DWORD *)&v6[4 * (v4 + 5)] = v22;
        *(_DWORD *)&v6[4 * v21] = v20;
        outdata[4] = indata[4] ^ *(_DWORD *)&v6[4 * (v22 + v20)];
        v23 = *(_DWORD *)&v6[4 * (v4 + 6)];
        v24 = v23 + v21;
        v25 = *(_DWORD *)&v6[4 * v24];
        *(_DWORD *)&v6[4 * (v4 + 6)] = v25;
        *(_DWORD *)&v6[4 * v24] = v23;
        outdata[5] = indata[5] ^ *(_DWORD *)&v6[4 * (v25 + v23)];
        v26 = *(_DWORD *)&v6[4 * (v4 + 7)];
        v27 = v26 + v24;
        v28 = *(_DWORD *)&v6[4 * v27];
        *(_DWORD *)&v6[4 * (v4 + 7)] = v28;
        *(_DWORD *)&v6[4 * v27] = v26;
        outdata[6] = indata[6] ^ *(_DWORD *)&v6[4 * (v28 + v26)];
        v4 = (v4 + 8);
        v29 = *(_DWORD *)&v6[4 * v4];
        v5 = (v29 + v27);
        v30 = *(_DWORD *)&v6[4 * v5];
        *(_DWORD *)&v6[4 * v4] = v30;
        *(_DWORD *)&v6[4 * v5] = v29;
        v31 = *(_DWORD *)&v6[4 * (v30 + v29)];
        v32 = indata + 8;
        outdata[7] = indata[7] ^ v31;
        outdata += 8;
        indata += 8;
        --v7;
      }
      while (v7);
      indata = v32;
    }
  }
  else
  {
    while (len >= 8)
    {
      v33 = *(_DWORD *)&v6[4 * (v4 + 1)];
      v34 = v33 + v5;
      v35 = *(_DWORD *)&v6[4 * v34];
      *(_DWORD *)&v6[4 * v34] = v33;
      *(_DWORD *)&v6[4 * (v4 + 1)] = v35;
      v36 = *(unsigned int *)&v6[4 * (v35 + v33)];
      v37 = *(_DWORD *)&v6[4 * (v4 + 2)];
      v38 = v37 + v34;
      v39 = *(_DWORD *)&v6[4 * v38];
      *(_DWORD *)&v6[4 * v38] = v37;
      *(_DWORD *)&v6[4 * (v4 + 2)] = v39;
      v40 = *(unsigned int *)&v6[4 * (v39 + v37)];
      v41 = *(_DWORD *)&v6[4 * (v4 + 3)];
      v42 = v41 + v38;
      v43 = *(_DWORD *)&v6[4 * v42];
      *(_DWORD *)&v6[4 * v42] = v41;
      *(_DWORD *)&v6[4 * (v4 + 3)] = v43;
      v44 = v36 | (v40 << 8) | ((unint64_t)*(unsigned int *)&v6[4 * (v43 + v41)] << 16);
      v45 = *(_DWORD *)&v6[4 * (v4 + 4)];
      v46 = v45 + v42;
      v47 = *(_DWORD *)&v6[4 * v46];
      *(_DWORD *)&v6[4 * v46] = v45;
      *(_DWORD *)&v6[4 * (v4 + 4)] = v47;
      v48 = *(unsigned int *)&v6[4 * (v47 + v45)];
      v49 = *(_DWORD *)&v6[4 * (v4 + 5)];
      v50 = v49 + v46;
      v51 = *(_DWORD *)&v6[4 * v50];
      *(_DWORD *)&v6[4 * v50] = v49;
      *(_DWORD *)&v6[4 * (v4 + 5)] = v51;
      v52 = v44 | (v48 << 24) | ((unint64_t)*(unsigned int *)&v6[4 * (v51 + v49)] << 32);
      v53 = *(_DWORD *)&v6[4 * (v4 + 6)];
      v54 = v53 + v50;
      v55 = *(_DWORD *)&v6[4 * v54];
      *(_DWORD *)&v6[4 * v54] = v53;
      *(_DWORD *)&v6[4 * (v4 + 6)] = v55;
      v56 = *(unsigned int *)&v6[4 * (v55 + v53)];
      v57 = *(_DWORD *)&v6[4 * (v4 + 7)];
      v58 = v57 + v54;
      v59 = *(_DWORD *)&v6[4 * v58];
      *(_DWORD *)&v6[4 * v58] = v57;
      v60 = *(_QWORD *)indata;
      indata += 8;
      *(_DWORD *)&v6[4 * (v4 + 7)] = v59;
      v61 = v52 | (v56 << 40) | ((unint64_t)*(unsigned int *)&v6[4 * (v59 + v57)] << 48);
      v4 = (v4 + 8);
      LODWORD(v56) = *(_DWORD *)&v6[4 * v4];
      v5 = (v56 + v58);
      v62 = *(_DWORD *)&v6[4 * v5];
      *(_DWORD *)&v6[4 * v5] = v56;
      *(_DWORD *)&v6[4 * v4] = v62;
      *(_QWORD *)outdata = (v61 | ((unint64_t)*(unsigned int *)&v6[4 * (v62 + v56)] << 56)) ^ v60;
      outdata += 8;
      len -= 8;
    }
  }
  v63 = len & 7;
  if ((len & 7) != 0)
  {
    v64 = (v4 + 1);
    v65 = *(_DWORD *)&v6[4 * (v4 + 1)];
    v66 = v65 + v5;
    v5 = (v65 + v5);
    v67 = *(_DWORD *)&v6[4 * v5];
    *(_DWORD *)&v6[4 * (v4 + 1)] = v67;
    *(_DWORD *)&v6[4 * v5] = v65;
    *outdata = *indata ^ v6[4 * (v67 + v65)];
    if (v63 == 1)
      goto LABEL_15;
    v64 = (v4 + 2);
    v68 = *(_DWORD *)&v6[4 * (v4 + 2)];
    v69 = v68 + v66;
    v5 = v69;
    v70 = *(_DWORD *)&v6[4 * v69];
    *(_DWORD *)&v6[4 * (v4 + 2)] = v70;
    *(_DWORD *)&v6[4 * v69] = v68;
    outdata[1] = indata[1] ^ v6[4 * (v70 + v68)];
    if (v63 == 2)
      goto LABEL_15;
    v64 = (v4 + 3);
    v71 = *(_DWORD *)&v6[4 * (v4 + 3)];
    v72 = v71 + v69;
    v5 = v72;
    v73 = *(_DWORD *)&v6[4 * v72];
    *(_DWORD *)&v6[4 * (v4 + 3)] = v73;
    *(_DWORD *)&v6[4 * v72] = v71;
    outdata[2] = indata[2] ^ v6[4 * (v73 + v71)];
    if (v63 == 3)
      goto LABEL_15;
    v64 = (v4 + 4);
    v74 = *(_DWORD *)&v6[4 * (v4 + 4)];
    v75 = v74 + v72;
    v5 = v75;
    v76 = *(_DWORD *)&v6[4 * v75];
    *(_DWORD *)&v6[4 * (v4 + 4)] = v76;
    *(_DWORD *)&v6[4 * v75] = v74;
    outdata[3] = indata[3] ^ v6[4 * (v76 + v74)];
    if (v63 == 4)
      goto LABEL_15;
    v64 = (v4 + 5);
    v77 = *(_DWORD *)&v6[4 * (v4 + 5)];
    v78 = v77 + v75;
    v5 = v78;
    v79 = *(_DWORD *)&v6[4 * v78];
    *(_DWORD *)&v6[4 * (v4 + 5)] = v79;
    *(_DWORD *)&v6[4 * v78] = v77;
    outdata[4] = indata[4] ^ v6[4 * (v79 + v77)];
    if (v63 == 5)
      goto LABEL_15;
    v64 = (v4 + 6);
    v80 = *(_DWORD *)&v6[4 * (v4 + 6)];
    v81 = v80 + v78;
    v5 = v81;
    v82 = *(_DWORD *)&v6[4 * v81];
    *(_DWORD *)&v6[4 * (v4 + 6)] = v82;
    *(_DWORD *)&v6[4 * v81] = v80;
    outdata[5] = indata[5] ^ v6[4 * (v82 + v80)];
    if (v63 == 6)
    {
LABEL_15:
      v4 = v64;
    }
    else
    {
      v4 = (v4 + 7);
      v83 = *(_DWORD *)&v6[4 * v4];
      v5 = (v83 + v81);
      v84 = *(_DWORD *)&v6[4 * (v83 + v81)];
      *(_DWORD *)&v6[4 * v4] = v84;
      *(_DWORD *)&v6[4 * (v83 + v81)] = v83;
      outdata[6] = indata[6] ^ v6[4 * (v84 + v83)];
    }
  }
  *(_DWORD *)&key->x = v4;
  *(_DWORD *)&key->data[2] = v5;
}

uint64_t gost2814789_set_asn1_params(uint64_t a1, ASN1_TYPE *a2)
{
  uint64_t v4;
  ASN1_OCTET_STRING **v5;
  ASN1_OCTET_STRING **v6;
  int v7;
  unsigned __int8 *v8;
  unsigned __int8 *v9;
  ASN1_OCTET_STRING *v10;
  ASN1_OCTET_STRING *v11;
  int v13;
  int v14;
  unsigned __int8 *v15;

  v4 = *(_QWORD *)(a1 + 120);
  v5 = (ASN1_OCTET_STRING **)GOST_CIPHER_PARAMS_new();
  if (v5)
  {
    v6 = v5;
    if (ASN1_OCTET_STRING_set(*v5, (const unsigned __int8 *)(a1 + 40), *(_DWORD *)(*(_QWORD *)a1 + 12)))
    {
      ASN1_OBJECT_free((ASN1_OBJECT *)v6[1]);
      v6[1] = (ASN1_OCTET_STRING *)OBJ_nid2obj(*(_DWORD *)(v4 + 4136));
      v7 = i2d_GOST_CIPHER_PARAMS((ASN1_VALUE *)v6, 0);
      v8 = (unsigned __int8 *)malloc_type_malloc(v7, 0x9BC0FFCuLL);
      v15 = v8;
      if (v8)
      {
        v9 = v8;
        i2d_GOST_CIPHER_PARAMS((ASN1_VALUE *)v6, &v15);
        GOST_CIPHER_PARAMS_free((ASN1_VALUE *)v6);
        v10 = ASN1_OCTET_STRING_new();
        if (v10)
        {
          v11 = v10;
          if (ASN1_OCTET_STRING_set(v10, v9, v7))
          {
            free(v9);
            ASN1_TYPE_set(a2, 16, v11);
            return 1;
          }
          ASN1_OCTET_STRING_free(v11);
          free(v9);
          v13 = 13;
          v14 = 142;
        }
        else
        {
          free(v9);
          v13 = 65;
          v14 = 136;
        }
      }
      else
      {
        GOST_CIPHER_PARAMS_free((ASN1_VALUE *)v6);
        v13 = 65;
        v14 = 127;
      }
    }
    else
    {
      GOST_CIPHER_PARAMS_free((ASN1_VALUE *)v6);
      v13 = 13;
      v14 = 117;
    }
  }
  else
  {
    v13 = 65;
    v14 = 112;
  }
  ERR_put_error(50, 4095, v13, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/e_gost2814789.c", v14);
  return 0;
}

uint64_t gost2814789_get_asn1_params(_QWORD *a1, ASN1_TYPE *a)
{
  uint64_t v4;
  char *ptr;
  ASN1_VALUE *v6;
  const ASN1_OBJECT **v7;
  size_t v8;
  int v9;
  const unsigned __int8 *v11;

  v4 = a1[15];
  if (ASN1_TYPE_get(a) == 16)
  {
    ptr = a->value.ptr;
    v11 = (const unsigned __int8 *)*((_QWORD *)ptr + 1);
    v6 = d2i_GOST_CIPHER_PARAMS(0, &v11, *(int *)ptr);
    v7 = (const ASN1_OBJECT **)v6;
    v8 = **(int **)v6;
    if ((_DWORD)v8 == *(_DWORD *)(*a1 + 12))
    {
      v9 = OBJ_obj2nid(*((const ASN1_OBJECT **)v6 + 1));
      if (Gost2814789_set_sbox(v4, v9))
      {
        *(_DWORD *)(v4 + 4136) = OBJ_obj2nid(v7[1]);
        memcpy(a1 + 3, (*v7)->ln, v8);
        memcpy(a1 + 5, (*v7)->ln, v8);
        GOST_CIPHER_PARAMS_free((ASN1_VALUE *)v7);
        return 1;
      }
      GOST_CIPHER_PARAMS_free((ASN1_VALUE *)v7);
    }
    else
    {
      GOST_CIPHER_PARAMS_free(v6);
      ERR_put_error(50, 4095, 103, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/e_gost2814789.c", 171);
    }
  }
  return 0xFFFFFFFFLL;
}

void *EVP_gost2814789_ecb()
{
  return &gost2814789_ecb;
}

void *EVP_gost2814789_cfb64()
{
  return &gost2814789_cfb64;
}

void *EVP_gost2814789_cnt()
{
  return &gost2814789_cnt;
}

uint64_t gost2814789_init_key(uint64_t a1, uint64_t a2)
{
  return Gost2814789_set_key(*(_QWORD *)(a1 + 120), a2, 8 * *(_DWORD *)(a1 + 104));
}

uint64_t gost2814789_ecb_cipher(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  unint64_t v4;
  unint64_t v5;
  unint64_t v9;

  v4 = *(int *)(*(_QWORD *)a1 + 4);
  v5 = a4 - v4;
  if (a4 >= v4)
  {
    v9 = 0;
    do
    {
      Gost2814789_ecb_encrypt((int *)(a3 + v9), (int *)(a2 + v9), *(_QWORD *)(a1 + 120), *(_DWORD *)(a1 + 16));
      v9 += v4;
    }
    while (v9 <= v5);
  }
  return 1;
}

uint64_t gost2814789_ctl(uint64_t a1, int a2, int a3, _DWORD *a4)
{
  uint64_t v4;
  int v6;

  v4 = *(_QWORD *)(a1 + 120);
  if (!a2)
  {
    *(_DWORD *)(v4 + 4136) = 824;
    v6 = 824;
    return Gost2814789_set_sbox(v4, v6);
  }
  if (a2 == 25)
  {
    v6 = a3;
    return Gost2814789_set_sbox(v4, v6);
  }
  if (a2 != 7)
    return 0xFFFFFFFFLL;
  if (!a4)
    return 0;
  *a4 = 810;
  return 1;
}

uint64_t gost2814789_cfb64_cipher(uint64_t a1, _BYTE *a2, uint64_t a3, unint64_t a4)
{
  unint64_t v4;
  unint64_t v8;
  int *v9;
  unsigned int *v10;

  if (a4)
  {
    v4 = a4;
    if (a4 >= 0x4000000000000000)
      v8 = 0x4000000000000000;
    else
      v8 = a4;
    v9 = (int *)(a1 + 40);
    v10 = (unsigned int *)(a1 + 88);
    do
    {
      Gost2814789_cfb64_encrypt(a3, a2, v8, *(_QWORD *)(a1 + 120), v9, v10, *(_DWORD *)(a1 + 16));
      a3 += v8;
      a2 += v8;
      v4 -= v8;
      if (v4 < v8)
        v8 = v4;
    }
    while (v4);
  }
  return 1;
}

uint64_t gost2814789_cnt_cipher(uint64_t a1, _BYTE *a2, uint64_t a3, unint64_t a4)
{
  uint64_t v4;
  uint64_t v8;
  unint64_t v9;
  BOOL v10;

  v4 = a4;
  v8 = *(_QWORD *)(a1 + 120);
  if (!(a4 >> 62))
  {
    v9 = a4;
    if (!a4)
      return 1;
    goto LABEL_4;
  }
  do
  {
    Gost2814789_cnt_encrypt(a3, a2, 0x4000000000000000uLL, v8, (int *)(a1 + 40), (int *)(a1 + 56), (unsigned int *)(a1 + 88));
    v9 = v4 - 0x4000000000000000;
    a3 += 0x4000000000000000;
    a2 += 0x4000000000000000;
    v10 = v4 < 0x4000000000000000;
    v4 -= 0x4000000000000000;
  }
  while (v10);
  if (v9)
LABEL_4:
    Gost2814789_cnt_encrypt(a3, a2, v9, v8, (int *)(a1 + 40), (int *)(a1 + 56), (unsigned int *)(a1 + 88));
  return 1;
}

uint64_t BIO_get_new_index()
{
  uint64_t result;

  LODWORD(result) = CRYPTO_add_lock((int *)&BIO_get_new_index_bio_type_index, 1, 21, 0, 0);
  if ((int)result > 255)
    return 0xFFFFFFFFLL;
  else
    return result;
}

BIO *__cdecl BIO_new(BIO_METHOD *type)
{
  BIO *v2;
  BIO *v3;

  v2 = (BIO *)malloc_type_malloc(0x70uLL, 0x10F0040CB86C5B6uLL);
  v3 = v2;
  if (v2)
  {
    if (!BIO_set(v2, type))
    {
      free(v3);
      return 0;
    }
  }
  else
  {
    ERR_put_error(32, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/bio/bio_lib.c", 141);
  }
  return v3;
}

int BIO_set(BIO *a, BIO_METHOD *type)
{
  int v4;
  int *p_dummy;
  int (__cdecl *create)(BIO *);

  a->method = type;
  a->callback = 0;
  a->cb_arg = 0;
  *(_QWORD *)&a->init = 0;
  a->flags = 0;
  *(_OWORD *)&a->retry_reason = xmmword_22D691E00;
  a->prev_bio = 0;
  *(_QWORD *)&a->references = 0;
  a->next_bio = 0;
  v4 = 1;
  LODWORD(a->num_read) = 1;
  p_dummy = &a->ex_data.dummy;
  a->num_write = 0;
  a->ex_data.sk = 0;
  CRYPTO_new_ex_data(0, a, (CRYPTO_EX_DATA *)&a->ex_data.dummy);
  create = type->create;
  if (create && !((unsigned int (*)(BIO *))create)(a))
  {
    CRYPTO_free_ex_data(0, a, (CRYPTO_EX_DATA *)p_dummy);
    return 0;
  }
  return v4;
}

int BIO_free(BIO *a)
{
  BIO *v1;
  char *cb_arg;
  uint64_t (__cdecl *callback)(bio_st *, int, const char *, int, uint64_t, uint64_t);
  int (__cdecl *destroy)(BIO *);

  if (!a)
    return (int)a;
  v1 = a;
  if (CRYPTO_add_lock((int *)&a->num_read, -1, 21, 0, 0) > 0)
  {
LABEL_13:
    LODWORD(a) = 1;
    return (int)a;
  }
  callback = v1->callback;
  cb_arg = v1->cb_arg;
  if (callback)
  {
    if (!cb_arg)
    {
      LODWORD(a) = ((uint64_t (*)(BIO *, uint64_t, _QWORD, _QWORD, _QWORD, uint64_t))callback)(v1, 1, 0, 0, 0, 1);
      goto LABEL_8;
    }
  }
  else if (!cb_arg)
  {
    goto LABEL_9;
  }
  LODWORD(a) = ((uint64_t (*)(BIO *, uint64_t, _QWORD, _QWORD, _QWORD, _QWORD, uint64_t, _QWORD))cb_arg)(v1, 1, 0, 0, 0, 0, 1, 0);
LABEL_8:
  if ((int)a >= 1)
  {
LABEL_9:
    CRYPTO_free_ex_data(0, v1, (CRYPTO_EX_DATA *)&v1->ex_data.dummy);
    if (v1->method)
    {
      destroy = v1->method->destroy;
      if (destroy)
        ((void (*)(BIO *))destroy)(v1);
    }
    free(v1);
    goto LABEL_13;
  }
  return (int)a;
}

uint64_t bio_call_callback(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, unint64_t a5, uint64_t a6, uint64_t a7, uint64_t *a8)
{
  char v9;
  uint64_t (*v10)(void);
  uint64_t result;
  int v12;

  v9 = a2;
  v10 = *(uint64_t (**)(void))(a1 + 16);
  if (v10)
    return v10();
  v12 = a2 & 0xFFFFFF7F;
  if ((a2 & 0xFFFFFF7E) == 2 || v12 == 5)
  {
    if (a4 >> 31)
      return -1;
    a5 = a4;
  }
  if (a7 >= 1 && (a2 & 0x80) != 0 && v12 != 6)
  {
    a7 = *a8;
    if ((unint64_t)*a8 >> 31)
      return -1;
  }
  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, unint64_t, uint64_t, uint64_t))(a1 + 8))(a1, a2, a3, a5, a6, a7);
  if (result >= 1 && v9 < 0 && v12 != 6)
  {
    *a8 = result;
    return 1;
  }
  return result;
}

BOOL BIO_up_ref(uint64_t a1)
{
  return CRYPTO_add_lock((int *)(a1 + 80), 1, 21, 0, 0) > 1;
}

uint64_t BIO_get_data(uint64_t a1)
{
  return *(_QWORD *)(a1 + 56);
}

uint64_t BIO_set_data(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 56) = a2;
  return result;
}

uint64_t BIO_get_init(uint64_t a1)
{
  return *(unsigned int *)(a1 + 32);
}

uint64_t BIO_set_init(uint64_t result, int a2)
{
  *(_DWORD *)(result + 32) = a2;
  return result;
}

uint64_t BIO_get_shutdown(uint64_t a1)
{
  return *(unsigned int *)(a1 + 36);
}

uint64_t BIO_set_shutdown(uint64_t result, int a2)
{
  *(_DWORD *)(result + 36) = a2;
  return result;
}

void BIO_clear_flags(BIO *b, int flags)
{
  b->num &= ~flags;
}

int BIO_test_flags(const BIO *b, int flags)
{
  return b->num & flags;
}

void BIO_set_flags(BIO *b, int flags)
{
  b->num |= flags;
}

uint64_t (__cdecl *__cdecl BIO_get_callback(const BIO *b))(bio_st *, int, const char *, int, uint64_t, uint64_t)
{
  return b->callback;
}

void BIO_set_callback(BIO *b, uint64_t (__cdecl *callback)(bio_st *, int, const char *, int, uint64_t, uint64_t))
{
  b->callback = callback;
}

uint64_t BIO_get_callback_ex(uint64_t a1)
{
  return *(_QWORD *)(a1 + 16);
}

uint64_t BIO_set_callback_ex(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 16) = a2;
  return result;
}

void BIO_set_callback_arg(BIO *b, char *arg)
{
  *(_QWORD *)&b->init = arg;
}

char *__cdecl BIO_get_callback_arg(const BIO *b)
{
  return *(char **)&b->init;
}

const char *__cdecl BIO_method_name(const BIO *b)
{
  return b->method->name;
}

int BIO_method_type(const BIO *b)
{
  return b->method->type;
}

int BIO_read(BIO *b, void *data, int len)
{
  uint64_t v3;
  int result;
  uint64_t v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  unint64_t v13;

  v13 = 0;
  if (!b)
  {
    v8 = 67;
    v9 = 327;
LABEL_17:
    ERR_put_error(32, 4095, v8, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/bio/bio_lib.c", v9);
    return -1;
  }
  v3 = *(_QWORD *)&len;
  if (len < 1)
    return 0;
  if (!data)
  {
    v8 = 67;
    v9 = 335;
    goto LABEL_17;
  }
  if (!b->method || !b->method->bread)
  {
    v10 = 121;
    v11 = 340;
LABEL_15:
    ERR_put_error(32, 4095, v10, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/bio/bio_lib.c", v11);
    return -2;
  }
  if (b->callback || b->cb_arg)
  {
    result = bio_call_callback((uint64_t)b, 2, (uint64_t)data, len, 0, 0, 1, 0);
    if (result < 1)
      return result;
  }
  if (!b->flags)
  {
    v10 = 120;
    v11 = 351;
    goto LABEL_15;
  }
  result = ((uint64_t (*)(BIO *, void *, uint64_t))b->method->bread)(b, data, v3);
  if (result < 1)
  {
    v7 = 0;
  }
  else
  {
    v7 = result;
    v13 = result;
  }
  b->num_write += v7;
  if (b->callback || b->cb_arg)
  {
    if (result > 0)
      v12 = 1;
    else
      v12 = result;
    result = bio_call_callback((uint64_t)b, 130, (uint64_t)data, v3, 0, 0, v12, (uint64_t *)&v13);
  }
  if (result >= 1)
  {
    result = v13;
    if (v13 >> 31)
    {
      v8 = 130;
      v9 = 367;
      goto LABEL_17;
    }
  }
  return result;
}

int BIO_write(BIO *b, const void *data, int len)
{
  int result;
  uint64_t v5;
  uint64_t v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  unint64_t v13;

  result = 0;
  v13 = 0;
  if (!b)
    return result;
  v5 = *(_QWORD *)&len;
  if (len < 1)
    return result;
  if (!data)
  {
    v10 = 67;
    v11 = 391;
LABEL_15:
    ERR_put_error(32, 4095, v10, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/bio/bio_lib.c", v11);
    return -1;
  }
  if (!b->method || !b->method->bwrite)
  {
    v8 = 121;
    v9 = 396;
LABEL_13:
    ERR_put_error(32, 4095, v8, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/bio/bio_lib.c", v9);
    return -2;
  }
  if (b->callback || b->cb_arg)
  {
    result = bio_call_callback((uint64_t)b, 3, (uint64_t)data, len, 0, 0, 1, 0);
    if (result < 1)
      return result;
  }
  if (!b->flags)
  {
    v8 = 120;
    v9 = 407;
    goto LABEL_13;
  }
  result = ((uint64_t (*)(BIO *, const void *, uint64_t))b->method->bwrite)(b, data, v5);
  if (result < 1)
  {
    v7 = 0;
  }
  else
  {
    v7 = result;
    v13 = result;
  }
  b->ex_data.sk = (STACK *)((char *)b->ex_data.sk + v7);
  if (b->callback || b->cb_arg)
  {
    if (result > 0)
      v12 = 1;
    else
      v12 = result;
    result = bio_call_callback((uint64_t)b, 131, (uint64_t)data, v5, 0, 0, v12, (uint64_t *)&v13);
  }
  if (result >= 1)
  {
    result = v13;
    if (v13 >> 31)
    {
      v10 = 130;
      v11 = 423;
      goto LABEL_15;
    }
  }
  return result;
}

int BIO_puts(BIO *bp, const char *buf)
{
  char *cb_arg;
  uint64_t (__cdecl *callback)(bio_st *, int, const char *, int, uint64_t, uint64_t);
  int result;
  int v7;
  int v8;
  uint64_t v9;
  int v10;
  unint64_t v11;

  v11 = 0;
  if (!bp || !bp->method || !bp->method->bputs)
  {
    v7 = 121;
    v8 = 440;
LABEL_8:
    ERR_put_error(32, 4095, v7, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/bio/bio_lib.c", v8);
    return -2;
  }
  callback = bp->callback;
  cb_arg = bp->cb_arg;
  if (callback)
  {
    if (!cb_arg)
    {
      result = ((uint64_t (*)(BIO *, uint64_t, const char *, _QWORD, _QWORD, uint64_t))callback)(bp, 4, buf, 0, 0, 1);
      goto LABEL_12;
    }
  }
  else if (!cb_arg)
  {
    goto LABEL_13;
  }
  result = ((uint64_t (*)(BIO *, uint64_t, const char *, _QWORD, _QWORD, _QWORD, uint64_t, _QWORD))cb_arg)(bp, 4, buf, 0, 0, 0, 1, 0);
LABEL_12:
  if (result < 1)
    return result;
LABEL_13:
  if (!bp->flags)
  {
    v7 = 120;
    v8 = 451;
    goto LABEL_8;
  }
  result = ((uint64_t (*)(BIO *, const char *))bp->method->bputs)(bp, buf);
  if (result < 1)
  {
    v9 = 0;
  }
  else
  {
    v9 = result;
    v11 = result;
  }
  bp->ex_data.sk = (STACK *)((char *)bp->ex_data.sk + v9);
  if (bp->callback || bp->cb_arg)
  {
    if (result > 0)
      v10 = 1;
    else
      v10 = result;
    result = bio_call_callback((uint64_t)bp, 132, (uint64_t)buf, 0, 0, 0, v10, (uint64_t *)&v11);
  }
  if (result >= 1)
  {
    result = v11;
    if (v11 >> 31)
    {
      ERR_put_error(32, 4095, 130, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/bio/bio_lib.c", 467);
      return -1;
    }
  }
  return result;
}

int BIO_gets(BIO *bp, char *buf, int size)
{
  uint64_t v4;
  int result;
  int v7;
  int v8;
  int v9;
  unint64_t v10;

  v10 = 0;
  if (!bp || !bp->method || !bp->method->bgets)
  {
    v8 = 121;
    v9 = 484;
LABEL_19:
    ERR_put_error(32, 4095, v8, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/bio/bio_lib.c", v9);
    return -2;
  }
  v4 = *(_QWORD *)&size;
  if (*(_OWORD *)&bp->callback != 0)
  {
    result = bio_call_callback((uint64_t)bp, 5, (uint64_t)buf, size, 0, 0, 1, 0);
    if (result < 1)
      return result;
  }
  if (!bp->flags)
  {
    v8 = 120;
    v9 = 495;
    goto LABEL_19;
  }
  result = ((uint64_t (*)(BIO *, char *, uint64_t))bp->method->bgets)(bp, buf, v4);
  if (result >= 1)
    v10 = result;
  if (bp->callback || bp->cb_arg)
  {
    if (result > 0)
      v7 = 1;
    else
      v7 = result;
    result = bio_call_callback((uint64_t)bp, 133, (uint64_t)buf, (int)v4, 0, 0, v7, (uint64_t *)&v10);
  }
  if (result >= 1)
  {
    result = v10;
    if (v10 >> 31)
    {
      ERR_put_error(32, 4095, 130, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/bio/bio_lib.c", 509);
      return -1;
    }
  }
  return result;
}

int BIO_indent(BIO *b, int indent, int max)
{
  int v4;
  int v5;

  if (indent >= max)
    v4 = max;
  else
    v4 = indent;
  v5 = (v4 & ~(v4 >> 31)) + 1;
  while (--v5)
  {
    if (BIO_puts(b, " ") != 1)
      return 0;
  }
  return 1;
}

uint64_t BIO_int_ctrl(BIO *bp, int cmd, uint64_t larg, int iarg)
{
  int parg;

  parg = iarg;
  return BIO_ctrl(bp, cmd, larg, &parg);
}

uint64_t BIO_ctrl(BIO *bp, int cmd, uint64_t larg, void *parg)
{
  uint64_t (__cdecl *ctrl)(BIO *, int, uint64_t, void *);
  unint64_t v8;
  char *cb_arg;
  uint64_t (__cdecl *callback)(bio_st *, int, const char *, int, uint64_t, uint64_t);
  uint64_t v11;
  uint64_t v12;

  if (!bp)
    return 0;
  if (!bp->method || (ctrl = bp->method->ctrl) == 0)
  {
    ERR_put_error(32, 4095, 121, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/bio/bio_lib.c", 561);
    return -2;
  }
  v8 = *(_QWORD *)&cmd;
  callback = bp->callback;
  cb_arg = bp->cb_arg;
  if (callback)
  {
    if (!cb_arg)
    {
      v11 = ((uint64_t (*)(BIO *, uint64_t, void *, _QWORD, uint64_t, uint64_t))callback)(bp, 6, parg, *(_QWORD *)&cmd, larg, 1);
      goto LABEL_12;
    }
LABEL_11:
    v11 = ((uint64_t (*)(BIO *, uint64_t, void *, _QWORD, _QWORD, uint64_t, uint64_t, _QWORD))cb_arg)(bp, 6, parg, 0, *(_QWORD *)&cmd, larg, 1, 0);
LABEL_12:
    v12 = v11;
    if (v11 >= 1)
    {
      ctrl = bp->method->ctrl;
      goto LABEL_14;
    }
    return v12;
  }
  if (cb_arg)
    goto LABEL_11;
LABEL_14:
  v12 = ((uint64_t (*)(BIO *, unint64_t, uint64_t, void *))ctrl)(bp, v8, larg, parg);
  if (!bp->callback && !bp->cb_arg)
    return v12;
  return bio_call_callback((uint64_t)bp, 134, (uint64_t)parg, 0, v8, larg, v12, 0);
}

char *__cdecl BIO_ptr_ctrl(BIO *bp, int cmd, uint64_t larg)
{
  char *parg;

  parg = 0;
  if (BIO_ctrl(bp, cmd, larg, &parg) >= 1)
    return parg;
  else
    return 0;
}

uint64_t BIO_callback_ctrl(BIO *b, int cmd, void (__cdecl *fp)(bio_st *, int, const char *, int, uint64_t, uint64_t))
{
  uint64_t (__cdecl *callback_ctrl)(BIO *, int, bio_info_cb *);
  char *cb_arg;
  uint64_t (__cdecl *callback)(bio_st *, int, const char *, int, uint64_t, uint64_t);
  uint64_t v7;
  uint64_t v8;
  void (__cdecl *v10)(bio_st *, int, const char *, int, uint64_t, uint64_t);

  v10 = fp;
  if (!b)
    return 0;
  if (!b->method || cmd != 14 || (callback_ctrl = b->method->callback_ctrl) == 0)
  {
    ERR_put_error(32, 4095, 121, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/bio/bio_lib.c", 591);
    return -2;
  }
  callback = b->callback;
  cb_arg = b->cb_arg;
  if (callback)
  {
    if (!cb_arg)
    {
      v7 = ((uint64_t (*)(BIO *, uint64_t, void (__cdecl **)(bio_st *, int, const char *, int, uint64_t, uint64_t), uint64_t, _QWORD, uint64_t))callback)(b, 6, &v10, 14, 0, 1);
LABEL_12:
      v8 = v7;
      if (v7 < 1)
        return v8;
      callback_ctrl = b->method->callback_ctrl;
      goto LABEL_14;
    }
LABEL_11:
    v7 = ((uint64_t (*)(BIO *, uint64_t, void (__cdecl **)(bio_st *, int, const char *, int, uint64_t, uint64_t), _QWORD, uint64_t, _QWORD, uint64_t, _QWORD))cb_arg)(b, 6, &v10, 0, 14, 0, 1, 0);
    goto LABEL_12;
  }
  if (cb_arg)
    goto LABEL_11;
LABEL_14:
  v8 = ((uint64_t (*)(BIO *, uint64_t))callback_ctrl)(b, 14);
  if (b->callback || b->cb_arg)
    return bio_call_callback((uint64_t)b, 134, (uint64_t)&v10, 0, 0xEuLL, 0, v8, 0);
  return v8;
}

size_t BIO_ctrl_pending(BIO *b)
{
  return BIO_ctrl(b, 10, 0, 0);
}

size_t BIO_ctrl_wpending(BIO *b)
{
  return BIO_ctrl(b, 13, 0, 0);
}

BIO *__cdecl BIO_push(BIO *b, BIO *append)
{
  BIO *v2;
  BIO *v3;
  BIO *v4;
  uint64_t v5;

  if (!b)
    return append;
  v2 = b;
  v3 = b;
  do
  {
    v4 = v3;
    v3 = v3->prev_bio;
  }
  while (v3);
  v4->prev_bio = append;
  if (append)
  {
    v5 = *(_QWORD *)&append->references;
    if (v5)
      *(_QWORD *)(v5 + 64) = 0;
    *(_QWORD *)&append->references = v4;
  }
  BIO_ctrl(b, 6, 0, v4);
  return v2;
}

BIO *__cdecl BIO_pop(BIO *b)
{
  BIO *prev_bio;
  bio_st **p_prev_bio;
  uint64_t v4;

  if (!b)
    return 0;
  p_prev_bio = &b->prev_bio;
  prev_bio = b->prev_bio;
  BIO_ctrl(b, 7, 0, b);
  v4 = *(_QWORD *)&b->references;
  if (v4)
    *(_QWORD *)(v4 + 64) = *p_prev_bio;
  if (*p_prev_bio)
    *(_QWORD *)&(*p_prev_bio)->references = v4;
  *p_prev_bio = 0;
  p_prev_bio[1] = 0;
  return prev_bio;
}

BIO *__cdecl BIO_get_retry_BIO(BIO *bio, int *reason)
{
  BIO *v2;

  v2 = bio;
  if ((bio->num & 8) != 0)
  {
    do
    {
      bio = v2;
      v2 = v2->prev_bio;
    }
    while (v2 && (v2->num & 8) != 0);
  }
  if (reason)
    *reason = *(&bio->num + 1);
  return bio;
}

int BIO_get_retry_reason(BIO *bio)
{
  return *(&bio->num + 1);
}

uint64_t BIO_set_retry_reason(uint64_t result, int a2)
{
  *(_DWORD *)(result + 44) = a2;
  return result;
}

BIO *__cdecl BIO_find_type(BIO *b, int bio_type)
{
  int type;

  for (; b; b = b->prev_bio)
  {
    if (b->method)
    {
      type = b->method->type;
      if ((_BYTE)bio_type)
      {
        if (type == bio_type)
          return b;
      }
      else if ((type & bio_type) != 0)
      {
        return b;
      }
    }
  }
  return b;
}

BIO *__cdecl BIO_next(BIO *b)
{
  if (b)
    return b->prev_bio;
  return b;
}

uint64_t BIO_set_next(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;

  v2 = *(_QWORD *)(result + 64);
  if (v2)
    *(_QWORD *)(v2 + 72) = 0;
  if (a2)
  {
    v3 = *(_QWORD *)(a2 + 72);
    if (v3)
      *(_QWORD *)(v3 + 64) = 0;
    *(_QWORD *)(result + 64) = a2;
    *(_QWORD *)(a2 + 72) = result;
  }
  else
  {
    *(_QWORD *)(result + 64) = 0;
  }
  return result;
}

void BIO_free_all(BIO *a)
{
  int num_read;
  BIO *prev_bio;
  BOOL v3;

  if (a)
  {
    do
    {
      num_read = a->num_read;
      prev_bio = a->prev_bio;
      BIO_free(a);
      v3 = num_read > 1 || prev_bio == 0;
      a = prev_bio;
    }
    while (!v3);
  }
}

BIO *__cdecl BIO_dup_chain(BIO *in)
{
  BIO *v1;
  BIO *v2;
  BIO *v3;
  BIO *v4;
  BIO *v5;

  if (in)
  {
    v1 = in;
    v2 = 0;
    v3 = 0;
    while (1)
    {
      v4 = BIO_new(v1->method);
      if (!v4)
        break;
      v5 = v4;
      *(_OWORD *)&v4->callback = *(_OWORD *)&v1->callback;
      *(_QWORD *)&v4->init = *(_QWORD *)&v1->init;
      *(_QWORD *)&v4->flags = *(_QWORD *)&v1->flags;
      v4->num = v1->num;
      LODWORD(v4->ptr) = v1->ptr;
      if (!BIO_ctrl(v1, 12, 0, v4))
      {
        BIO_free(v5);
        break;
      }
      if (!CRYPTO_dup_ex_data(0, (CRYPTO_EX_DATA *)&v5->ex_data.dummy, (CRYPTO_EX_DATA *)&v1->ex_data.dummy))
        break;
      in = v5;
      if (v3)
      {
        BIO_push(v2, v5);
        in = v3;
      }
      v1 = v1->prev_bio;
      v2 = v5;
      v3 = in;
      if (!v1)
        return in;
    }
    BIO_free(v3);
    return 0;
  }
  return in;
}

void BIO_copy_next_retry(BIO *b)
{
  bio_st *prev_bio;
  int num;

  prev_bio = b->prev_bio;
  num = prev_bio->num;
  LODWORD(prev_bio) = *(&prev_bio->num + 1);
  b->num |= num & 0xF;
  *(&b->num + 1) = (int)prev_bio;
}

int BIO_get_ex_new_index(uint64_t argl, void *argp, CRYPTO_EX_new *new_func, CRYPTO_EX_dup *dup_func, CRYPTO_EX_free *free_func)
{
  return CRYPTO_get_ex_new_index(0, argl, argp, new_func, dup_func, free_func);
}

int BIO_set_ex_data(BIO *bio, int idx, void *data)
{
  return CRYPTO_set_ex_data((CRYPTO_EX_DATA *)&bio->ex_data.dummy, idx, data);
}

void *__cdecl BIO_get_ex_data(BIO *bio, int idx)
{
  return CRYPTO_get_ex_data((const CRYPTO_EX_DATA *)&bio->ex_data.dummy, idx);
}

unint64_t BIO_number_read(unint64_t bio)
{
  if (bio)
    return *(_QWORD *)(bio + 88);
  return bio;
}

unint64_t BIO_number_written(unint64_t bio)
{
  if (bio)
    return *(_QWORD *)(bio + 96);
  return bio;
}

void CAST_ofb64_encrypt(const unsigned __int8 *in, unsigned __int8 *out, uint64_t length, const CAST_KEY *schedule, unsigned __int8 *ivec, int *num)
{
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  unsigned int v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  uint64_t v20;
  int v23;
  char v24;
  unint64_t data;
  unsigned int v26;
  unsigned int v27;
  uint64_t v28;

  v28 = *MEMORY[0x24BDAC8D0];
  v7 = *num;
  v8 = *ivec;
  v9 = ivec[1];
  v10 = ivec[2];
  v11 = ivec[3];
  v12 = (v8 << 24) | (v9 << 16) | (v10 << 8) | v11;
  v13 = ivec[4];
  v14 = ivec[5];
  v15 = ivec[6];
  v16 = ivec[7];
  v17 = (v13 << 24) | (v14 << 16) | (v15 << 8) | v16;
  data = __PAIR64__(v17, v12);
  LOBYTE(v26) = v8;
  BYTE1(v26) = v9;
  BYTE2(v26) = v10;
  HIBYTE(v26) = v11;
  LOBYTE(v27) = v13;
  BYTE1(v27) = v14;
  BYTE2(v27) = v15;
  HIBYTE(v27) = v16;
  if (length)
  {
    v20 = length;
    v23 = 0;
    do
    {
      if (!v7)
      {
        CAST_encrypt(&data, schedule);
        v12 = data;
        v17 = HIDWORD(data);
        v26 = bswap32(data);
        v27 = bswap32(HIDWORD(data));
        ++v23;
      }
      v24 = *in++;
      *out++ = *((_BYTE *)&v26 + v7) ^ v24;
      v7 = (v7 + 1) & 7;
      --v20;
    }
    while (v20);
    if (v23)
    {
      *ivec = HIBYTE(v12);
      ivec[1] = BYTE2(v12);
      ivec[2] = BYTE1(v12);
      ivec[3] = v12;
      ivec[4] = HIBYTE(v17);
      ivec[5] = BYTE2(v17);
      ivec[6] = BYTE1(v17);
      ivec[7] = v17;
    }
  }
  *num = v7;
}

void *EVP_camellia_128_cbc()
{
  return &camellia_128_cbc;
}

void *EVP_camellia_128_cfb128()
{
  return &camellia_128_cfb128;
}

void *EVP_camellia_128_ofb()
{
  return &camellia_128_ofb;
}

void *EVP_camellia_128_ecb()
{
  return &camellia_128_ecb;
}

void *EVP_camellia_192_cbc()
{
  return &camellia_192_cbc;
}

void *EVP_camellia_192_cfb128()
{
  return &camellia_192_cfb128;
}

void *EVP_camellia_192_ofb()
{
  return &camellia_192_ofb;
}

void *EVP_camellia_192_ecb()
{
  return &camellia_192_ecb;
}

void *EVP_camellia_256_cbc()
{
  return &camellia_256_cbc;
}

void *EVP_camellia_256_cfb128()
{
  return &camellia_256_cfb128;
}

void *EVP_camellia_256_ofb()
{
  return &camellia_256_ofb;
}

void *EVP_camellia_256_ecb()
{
  return &camellia_256_ecb;
}

void *EVP_camellia_128_cfb1()
{
  return &camellia_128_cfb1;
}

void *EVP_camellia_192_cfb1()
{
  return &camellia_192_cfb1;
}

void *EVP_camellia_256_cfb1()
{
  return &camellia_256_cfb1;
}

void *EVP_camellia_128_cfb8()
{
  return &camellia_128_cfb8;
}

void *EVP_camellia_192_cfb8()
{
  return &camellia_192_cfb8;
}

void *EVP_camellia_256_cfb8()
{
  return &camellia_256_cfb8;
}

uint64_t camellia_init_key(uint64_t a1, unsigned __int8 *a2)
{
  if ((Camellia_set_key(a2, 8 * *(_DWORD *)(a1 + 104), *(unsigned int **)(a1 + 120)) & 0x80000000) == 0)
    return 1;
  ERR_put_error(6, 4095, 157, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/e_camellia.c", 84);
  return 0;
}

uint64_t camellia_128_cbc_cipher(uint64_t a1, uint64_t *a2, _QWORD *a3, unint64_t a4)
{
  uint64_t v4;
  unint64_t v8;
  BOOL v9;

  v4 = a4;
  if (!(a4 >> 62))
  {
    v8 = a4;
    if (!a4)
      return 1;
    goto LABEL_4;
  }
  do
  {
    Camellia_cbc_encrypt(a3, a2, 0x4000000000000000uLL, *(_QWORD *)(a1 + 120), (_OWORD *)(a1 + 40), *(_DWORD *)(a1 + 16));
    v8 = v4 - 0x4000000000000000;
    a3 += 0x800000000000000;
    a2 += 0x800000000000000;
    v9 = v4 < 0x4000000000000000;
    v4 -= 0x4000000000000000;
  }
  while (v9);
  if (v8)
LABEL_4:
    Camellia_cbc_encrypt(a3, a2, v8, *(_QWORD *)(a1 + 120), (_OWORD *)(a1 + 40), *(_DWORD *)(a1 + 16));
  return 1;
}

uint64_t camellia_128_cfb128_cipher(uint64_t a1, _BYTE *a2, uint64_t a3, unint64_t a4)
{
  unint64_t v4;
  unint64_t v8;
  uint64_t v9;
  unsigned int *v10;

  if (a4)
  {
    v4 = a4;
    if (a4 >= 0x4000000000000000)
      v8 = 0x4000000000000000;
    else
      v8 = a4;
    v9 = a1 + 40;
    v10 = (unsigned int *)(a1 + 88);
    do
    {
      Camellia_cfb128_encrypt(a3, a2, v8, *(_QWORD *)(a1 + 120), v9, v10, *(_DWORD *)(a1 + 16));
      a3 += v8;
      a2 += v8;
      v4 -= v8;
      if (v4 < v8)
        v8 = v4;
    }
    while (v4);
  }
  return 1;
}

uint64_t camellia_128_ofb_cipher(uint64_t a1, _BYTE *a2, uint64_t a3, unint64_t a4)
{
  uint64_t v4;
  unint64_t v8;
  BOOL v9;

  v4 = a4;
  if (!(a4 >> 62))
  {
    v8 = a4;
    if (!a4)
      return 1;
    goto LABEL_4;
  }
  do
  {
    Camellia_ofb128_encrypt(a3, a2, 0x4000000000000000uLL, *(_QWORD *)(a1 + 120), a1 + 40, (unsigned int *)(a1 + 88));
    v8 = v4 - 0x4000000000000000;
    a3 += 0x4000000000000000;
    a2 += 0x4000000000000000;
    v9 = v4 < 0x4000000000000000;
    v4 -= 0x4000000000000000;
  }
  while (v9);
  if (v8)
LABEL_4:
    Camellia_ofb128_encrypt(a3, a2, v8, *(_QWORD *)(a1 + 120), a1 + 40, (unsigned int *)(a1 + 88));
  return 1;
}

uint64_t camellia_128_ecb_cipher(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  unint64_t v4;
  unint64_t v5;
  unint64_t v9;

  v4 = *(int *)(*(_QWORD *)a1 + 4);
  v5 = a4 - v4;
  if (a4 >= v4)
  {
    v9 = 0;
    do
    {
      Camellia_ecb_encrypt((unsigned int *)(a3 + v9), (_BYTE *)(a2 + v9), *(_DWORD **)(a1 + 120), *(_DWORD *)(a1 + 16));
      v9 += v4;
    }
    while (v9 <= v5);
  }
  return 1;
}

uint64_t camellia_192_cbc_cipher(uint64_t a1, uint64_t *a2, _QWORD *a3, unint64_t a4)
{
  uint64_t v4;
  unint64_t v8;
  BOOL v9;

  v4 = a4;
  if (!(a4 >> 62))
  {
    v8 = a4;
    if (!a4)
      return 1;
    goto LABEL_4;
  }
  do
  {
    Camellia_cbc_encrypt(a3, a2, 0x4000000000000000uLL, *(_QWORD *)(a1 + 120), (_OWORD *)(a1 + 40), *(_DWORD *)(a1 + 16));
    v8 = v4 - 0x4000000000000000;
    a3 += 0x800000000000000;
    a2 += 0x800000000000000;
    v9 = v4 < 0x4000000000000000;
    v4 -= 0x4000000000000000;
  }
  while (v9);
  if (v8)
LABEL_4:
    Camellia_cbc_encrypt(a3, a2, v8, *(_QWORD *)(a1 + 120), (_OWORD *)(a1 + 40), *(_DWORD *)(a1 + 16));
  return 1;
}

uint64_t camellia_192_cfb128_cipher(uint64_t a1, _BYTE *a2, uint64_t a3, unint64_t a4)
{
  unint64_t v4;
  unint64_t v8;
  uint64_t v9;
  unsigned int *v10;

  if (a4)
  {
    v4 = a4;
    if (a4 >= 0x4000000000000000)
      v8 = 0x4000000000000000;
    else
      v8 = a4;
    v9 = a1 + 40;
    v10 = (unsigned int *)(a1 + 88);
    do
    {
      Camellia_cfb128_encrypt(a3, a2, v8, *(_QWORD *)(a1 + 120), v9, v10, *(_DWORD *)(a1 + 16));
      a3 += v8;
      a2 += v8;
      v4 -= v8;
      if (v4 < v8)
        v8 = v4;
    }
    while (v4);
  }
  return 1;
}

uint64_t camellia_192_ofb_cipher(uint64_t a1, _BYTE *a2, uint64_t a3, unint64_t a4)
{
  uint64_t v4;
  unint64_t v8;
  BOOL v9;

  v4 = a4;
  if (!(a4 >> 62))
  {
    v8 = a4;
    if (!a4)
      return 1;
    goto LABEL_4;
  }
  do
  {
    Camellia_ofb128_encrypt(a3, a2, 0x4000000000000000uLL, *(_QWORD *)(a1 + 120), a1 + 40, (unsigned int *)(a1 + 88));
    v8 = v4 - 0x4000000000000000;
    a3 += 0x4000000000000000;
    a2 += 0x4000000000000000;
    v9 = v4 < 0x4000000000000000;
    v4 -= 0x4000000000000000;
  }
  while (v9);
  if (v8)
LABEL_4:
    Camellia_ofb128_encrypt(a3, a2, v8, *(_QWORD *)(a1 + 120), a1 + 40, (unsigned int *)(a1 + 88));
  return 1;
}

uint64_t camellia_192_ecb_cipher(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  unint64_t v4;
  unint64_t v5;
  unint64_t v9;

  v4 = *(int *)(*(_QWORD *)a1 + 4);
  v5 = a4 - v4;
  if (a4 >= v4)
  {
    v9 = 0;
    do
    {
      Camellia_ecb_encrypt((unsigned int *)(a3 + v9), (_BYTE *)(a2 + v9), *(_DWORD **)(a1 + 120), *(_DWORD *)(a1 + 16));
      v9 += v4;
    }
    while (v9 <= v5);
  }
  return 1;
}

uint64_t camellia_256_cbc_cipher(uint64_t a1, uint64_t *a2, _QWORD *a3, unint64_t a4)
{
  uint64_t v4;
  unint64_t v8;
  BOOL v9;

  v4 = a4;
  if (!(a4 >> 62))
  {
    v8 = a4;
    if (!a4)
      return 1;
    goto LABEL_4;
  }
  do
  {
    Camellia_cbc_encrypt(a3, a2, 0x4000000000000000uLL, *(_QWORD *)(a1 + 120), (_OWORD *)(a1 + 40), *(_DWORD *)(a1 + 16));
    v8 = v4 - 0x4000000000000000;
    a3 += 0x800000000000000;
    a2 += 0x800000000000000;
    v9 = v4 < 0x4000000000000000;
    v4 -= 0x4000000000000000;
  }
  while (v9);
  if (v8)
LABEL_4:
    Camellia_cbc_encrypt(a3, a2, v8, *(_QWORD *)(a1 + 120), (_OWORD *)(a1 + 40), *(_DWORD *)(a1 + 16));
  return 1;
}

uint64_t camellia_256_cfb128_cipher(uint64_t a1, _BYTE *a2, uint64_t a3, unint64_t a4)
{
  unint64_t v4;
  unint64_t v8;
  uint64_t v9;
  unsigned int *v10;

  if (a4)
  {
    v4 = a4;
    if (a4 >= 0x4000000000000000)
      v8 = 0x4000000000000000;
    else
      v8 = a4;
    v9 = a1 + 40;
    v10 = (unsigned int *)(a1 + 88);
    do
    {
      Camellia_cfb128_encrypt(a3, a2, v8, *(_QWORD *)(a1 + 120), v9, v10, *(_DWORD *)(a1 + 16));
      a3 += v8;
      a2 += v8;
      v4 -= v8;
      if (v4 < v8)
        v8 = v4;
    }
    while (v4);
  }
  return 1;
}

uint64_t camellia_256_ofb_cipher(uint64_t a1, _BYTE *a2, uint64_t a3, unint64_t a4)
{
  uint64_t v4;
  unint64_t v8;
  BOOL v9;

  v4 = a4;
  if (!(a4 >> 62))
  {
    v8 = a4;
    if (!a4)
      return 1;
    goto LABEL_4;
  }
  do
  {
    Camellia_ofb128_encrypt(a3, a2, 0x4000000000000000uLL, *(_QWORD *)(a1 + 120), a1 + 40, (unsigned int *)(a1 + 88));
    v8 = v4 - 0x4000000000000000;
    a3 += 0x4000000000000000;
    a2 += 0x4000000000000000;
    v9 = v4 < 0x4000000000000000;
    v4 -= 0x4000000000000000;
  }
  while (v9);
  if (v8)
LABEL_4:
    Camellia_ofb128_encrypt(a3, a2, v8, *(_QWORD *)(a1 + 120), a1 + 40, (unsigned int *)(a1 + 88));
  return 1;
}

uint64_t camellia_256_ecb_cipher(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  unint64_t v4;
  unint64_t v5;
  unint64_t v9;

  v4 = *(int *)(*(_QWORD *)a1 + 4);
  v5 = a4 - v4;
  if (a4 >= v4)
  {
    v9 = 0;
    do
    {
      Camellia_ecb_encrypt((unsigned int *)(a3 + v9), (_BYTE *)(a2 + v9), *(_DWORD **)(a1 + 120), *(_DWORD *)(a1 + 16));
      v9 += v4;
    }
    while (v9 <= v5);
  }
  return 1;
}

uint64_t camellia_128_cfb1_cipher(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  unint64_t v4;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  if (a4)
  {
    v4 = a4;
    if (a4 >= 0x800000000000000)
      v8 = 0x800000000000000;
    else
      v8 = a4;
    v9 = a1 + 40;
    v10 = a1 + 88;
    do
    {
      if ((*(_QWORD *)(a1 + 112) & 0x2000) != 0)
        v11 = v8;
      else
        v11 = 8 * v8;
      Camellia_cfb1_encrypt(a3, a2, v11, *(_QWORD *)(a1 + 120), v9, v10, *(_DWORD *)(a1 + 16));
      a3 += v8;
      a2 += v8;
      v4 -= v8;
      if (v4 < v8)
        v8 = v4;
    }
    while (v4);
  }
  return 1;
}

uint64_t camellia_192_cfb1_cipher(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  unint64_t v4;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  if (a4)
  {
    v4 = a4;
    if (a4 >= 0x800000000000000)
      v8 = 0x800000000000000;
    else
      v8 = a4;
    v9 = a1 + 40;
    v10 = a1 + 88;
    do
    {
      if ((*(_QWORD *)(a1 + 112) & 0x2000) != 0)
        v11 = v8;
      else
        v11 = 8 * v8;
      Camellia_cfb1_encrypt(a3, a2, v11, *(_QWORD *)(a1 + 120), v9, v10, *(_DWORD *)(a1 + 16));
      a3 += v8;
      a2 += v8;
      v4 -= v8;
      if (v4 < v8)
        v8 = v4;
    }
    while (v4);
  }
  return 1;
}

uint64_t camellia_256_cfb1_cipher(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  unint64_t v4;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  if (a4)
  {
    v4 = a4;
    if (a4 >= 0x800000000000000)
      v8 = 0x800000000000000;
    else
      v8 = a4;
    v9 = a1 + 40;
    v10 = a1 + 88;
    do
    {
      if ((*(_QWORD *)(a1 + 112) & 0x2000) != 0)
        v11 = v8;
      else
        v11 = 8 * v8;
      Camellia_cfb1_encrypt(a3, a2, v11, *(_QWORD *)(a1 + 120), v9, v10, *(_DWORD *)(a1 + 16));
      a3 += v8;
      a2 += v8;
      v4 -= v8;
      if (v4 < v8)
        v8 = v4;
    }
    while (v4);
  }
  return 1;
}

uint64_t camellia_128_cfb8_cipher(uint64_t a1, _BYTE *a2, uint64_t a3, unint64_t a4)
{
  unint64_t v4;
  unint64_t v8;
  __int128 *v9;
  uint64_t v10;

  if (a4)
  {
    v4 = a4;
    if (a4 >= 0x4000000000000000)
      v8 = 0x4000000000000000;
    else
      v8 = a4;
    v9 = (__int128 *)(a1 + 40);
    v10 = a1 + 88;
    do
    {
      Camellia_cfb8_encrypt(a3, a2, v8, *(_QWORD *)(a1 + 120), v9, v10, *(_DWORD *)(a1 + 16));
      a3 += v8;
      a2 += v8;
      v4 -= v8;
      if (v4 < v8)
        v8 = v4;
    }
    while (v4);
  }
  return 1;
}

uint64_t camellia_192_cfb8_cipher(uint64_t a1, _BYTE *a2, uint64_t a3, unint64_t a4)
{
  unint64_t v4;
  unint64_t v8;
  __int128 *v9;
  uint64_t v10;

  if (a4)
  {
    v4 = a4;
    if (a4 >= 0x4000000000000000)
      v8 = 0x4000000000000000;
    else
      v8 = a4;
    v9 = (__int128 *)(a1 + 40);
    v10 = a1 + 88;
    do
    {
      Camellia_cfb8_encrypt(a3, a2, v8, *(_QWORD *)(a1 + 120), v9, v10, *(_DWORD *)(a1 + 16));
      a3 += v8;
      a2 += v8;
      v4 -= v8;
      if (v4 < v8)
        v8 = v4;
    }
    while (v4);
  }
  return 1;
}

uint64_t camellia_256_cfb8_cipher(uint64_t a1, _BYTE *a2, uint64_t a3, unint64_t a4)
{
  unint64_t v4;
  unint64_t v8;
  __int128 *v9;
  uint64_t v10;

  if (a4)
  {
    v4 = a4;
    if (a4 >= 0x4000000000000000)
      v8 = 0x4000000000000000;
    else
      v8 = a4;
    v9 = (__int128 *)(a1 + 40);
    v10 = a1 + 88;
    do
    {
      Camellia_cfb8_encrypt(a3, a2, v8, *(_QWORD *)(a1 + 120), v9, v10, *(_DWORD *)(a1 + 16));
      a3 += v8;
      a2 += v8;
      v4 -= v8;
      if (v4 < v8)
        v8 = v4;
    }
    while (v4);
  }
  return 1;
}

int PEM_write_bio_PKCS8PrivateKey_nid(BIO *bp, EVP_PKEY *x, int nid, char *kstr, int klen, pem_password_cb *cb, void *u)
{
  return do_pk8pkey(bp, x, 0, nid, 0, kstr, klen, (uint64_t (*)(char *, uint64_t, uint64_t, void *))cb, u);
}

uint64_t do_pk8pkey(BIO *a1, EVP_PKEY *pkey, int a3, int a4, const EVP_CIPHER *a5, const char *a6, int a7, uint64_t (*a8)(char *, uint64_t, uint64_t, void *), void *key)
{
  PKCS8_PRIV_KEY_INFO *v16;
  PKCS8_PRIV_KEY_INFO *v17;
  uint64_t v18;
  uint64_t v19;
  X509_SIG *v20;
  int v21;
  uint64_t v22;
  char buf[1024];
  uint64_t v25;

  v25 = *MEMORY[0x24BDAC8D0];
  v16 = EVP_PKEY2PKCS8(pkey);
  if (!v16)
  {
    ERR_put_error(9, 4095, 115, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/pem/pem_pk8.c", 119);
    return 0;
  }
  v17 = v16;
  if (a4 == -1 && !a5)
  {
    if (a3)
      v18 = i2d_PKCS8_PRIV_KEY_INFO_bio(a1, v16);
    else
      v18 = PEM_ASN1_write_bio((i2d_of_void *)i2d_PKCS8_PRIV_KEY_INFO, "PRIVATE KEY", a1, (char *)v16, 0, 0, 0, 0, 0);
    v19 = v18;
    PKCS8_PRIV_KEY_INFO_free(v17);
    return v19;
  }
  if (!a6)
  {
    if (a8)
      v21 = a8(buf, 1024, 1, key);
    else
      v21 = PEM_def_callback(buf, 1024, 1, key);
    a7 = v21;
    if (v21 >= 1)
    {
      v20 = PKCS8_encrypt(a4, a5, buf, v21, 0, 0, 0, v17);
LABEL_18:
      explicit_bzero(buf, a7);
      goto LABEL_19;
    }
    ERR_put_error(9, 4095, 111, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/pem/pem_pk8.c", 129);
    PKCS8_PRIV_KEY_INFO_free(v17);
    return 0;
  }
  v20 = PKCS8_encrypt(a4, a5, a6, a7, 0, 0, 0, v16);
  if (buf == a6)
    goto LABEL_18;
LABEL_19:
  PKCS8_PRIV_KEY_INFO_free(v17);
  if (a3)
    v22 = i2d_PKCS8_bio(a1, v20);
  else
    v22 = PEM_ASN1_write_bio((i2d_of_void *)i2d_X509_SIG, "ENCRYPTED PRIVATE KEY", a1, (char *)v20, 0, 0, 0, 0, 0);
  v19 = v22;
  X509_SIG_free(v20);
  return v19;
}

int PEM_write_bio_PKCS8PrivateKey(BIO *a1, EVP_PKEY *a2, const EVP_CIPHER *a3, char *a4, int a5, pem_password_cb *a6, void *key)
{
  return do_pk8pkey(a1, a2, 0, -1, a3, a4, a5, (uint64_t (*)(char *, uint64_t, uint64_t, void *))a6, key);
}

int i2d_PKCS8PrivateKey_bio(BIO *bp, EVP_PKEY *x, const EVP_CIPHER *enc, char *kstr, int klen, pem_password_cb *cb, void *u)
{
  return do_pk8pkey(bp, x, 1, -1, enc, kstr, klen, (uint64_t (*)(char *, uint64_t, uint64_t, void *))cb, u);
}

int i2d_PKCS8PrivateKey_nid_bio(BIO *bp, EVP_PKEY *x, int nid, char *kstr, int klen, pem_password_cb *cb, void *u)
{
  return do_pk8pkey(bp, x, 1, nid, 0, kstr, klen, (uint64_t (*)(char *, uint64_t, uint64_t, void *))cb, u);
}

EVP_PKEY *__cdecl d2i_PKCS8PrivateKey_bio(BIO *bp, EVP_PKEY **x, pem_password_cb *cb, void *u)
{
  EVP_PKEY *v7;
  int v8;
  PKCS8_PRIV_KEY_INFO *v9;
  char buf[1024];
  uint64_t v12;

  v12 = *MEMORY[0x24BDAC8D0];
  v7 = (EVP_PKEY *)d2i_PKCS8_bio(bp, 0);
  if (!v7)
    return v7;
  if (cb)
    v8 = ((uint64_t (*)(char *, uint64_t, _QWORD, void *))cb)(buf, 1024, 0, u);
  else
    v8 = PEM_def_callback(buf, 1024, 0, u);
  if (v8 <= 0)
  {
    ERR_put_error(9, 4095, 104, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/pem/pem_pk8.c", 173);
    X509_SIG_free((X509_SIG *)v7);
    return 0;
  }
  v9 = PKCS8_decrypt((X509_SIG *)v7, buf, v8);
  X509_SIG_free((X509_SIG *)v7);
  if (!v9)
    return 0;
  v7 = EVP_PKCS82PKEY(v9);
  PKCS8_PRIV_KEY_INFO_free(v9);
  if (v7 && x)
  {
    EVP_PKEY_free(*x);
    *x = v7;
  }
  return v7;
}

int i2d_PKCS8PrivateKey_fp(FILE *fp, EVP_PKEY *x, const EVP_CIPHER *enc, char *kstr, int klen, pem_password_cb *cb, void *u)
{
  return do_pk8pkey_fp(fp, x, 1, -1, enc, kstr, klen, (uint64_t (*)(char *, uint64_t, uint64_t, void *))cb, u);
}

uint64_t do_pk8pkey_fp(FILE *a1, EVP_PKEY *a2, int a3, int a4, const EVP_CIPHER *a5, const char *a6, int a7, uint64_t (*a8)(char *, uint64_t, uint64_t, void *), void *key)
{
  BIO *v16;
  BIO *v17;
  uint64_t v18;

  v16 = BIO_new_fp(a1, 0);
  if (v16)
  {
    v17 = v16;
    v18 = do_pk8pkey(v16, a2, a3, a4, a5, a6, a7, a8, key);
    BIO_free(v17);
    return v18;
  }
  else
  {
    ERR_put_error(9, 4095, 7, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/pem/pem_pk8.c", 229);
    return 0;
  }
}

int i2d_PKCS8PrivateKey_nid_fp(FILE *fp, EVP_PKEY *x, int nid, char *kstr, int klen, pem_password_cb *cb, void *u)
{
  return do_pk8pkey_fp(fp, x, 1, nid, 0, kstr, klen, (uint64_t (*)(char *, uint64_t, uint64_t, void *))cb, u);
}

int PEM_write_PKCS8PrivateKey_nid(FILE *fp, EVP_PKEY *x, int nid, char *kstr, int klen, pem_password_cb *cb, void *u)
{
  return do_pk8pkey_fp(fp, x, 0, nid, 0, kstr, klen, (uint64_t (*)(char *, uint64_t, uint64_t, void *))cb, u);
}

int PEM_write_PKCS8PrivateKey(FILE *fp, EVP_PKEY *x, const EVP_CIPHER *enc, char *kstr, int klen, pem_password_cb *cd, void *u)
{
  return do_pk8pkey_fp(fp, x, 0, -1, enc, kstr, klen, (uint64_t (*)(char *, uint64_t, uint64_t, void *))cd, u);
}

EVP_PKEY *__cdecl d2i_PKCS8PrivateKey_fp(FILE *fp, EVP_PKEY **x, pem_password_cb *cb, void *u)
{
  BIO *v7;
  BIO *v8;
  EVP_PKEY *v9;

  v7 = BIO_new_fp(fp, 0);
  if (v7)
  {
    v8 = v7;
    v9 = d2i_PKCS8PrivateKey_bio(v7, x, cb, u);
    BIO_free(v8);
    return v9;
  }
  else
  {
    ERR_put_error(9, 4095, 7, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/pem/pem_pk8.c", 244);
    return 0;
  }
}

X509_SIG *__cdecl PEM_read_PKCS8(FILE *fp, X509_SIG **x, pem_password_cb *cb, void *u)
{
  return (X509_SIG *)PEM_ASN1_read((d2i_of_void *)d2i_X509_SIG, "ENCRYPTED PRIVATE KEY", fp, (void **)x, cb, u);
}

int PEM_write_PKCS8(FILE *fp, X509_SIG *x)
{
  return PEM_ASN1_write((i2d_of_void *)i2d_X509_SIG, "ENCRYPTED PRIVATE KEY", fp, (char *)x, 0, 0, 0, 0, 0);
}

X509_SIG *__cdecl PEM_read_bio_PKCS8(BIO *bp, X509_SIG **x, pem_password_cb *cb, void *u)
{
  return (X509_SIG *)PEM_ASN1_read_bio((d2i_of_void *)d2i_X509_SIG, "ENCRYPTED PRIVATE KEY", bp, (void **)x, cb, u);
}

int PEM_write_bio_PKCS8(BIO *bp, X509_SIG *x)
{
  return PEM_ASN1_write_bio((i2d_of_void *)i2d_X509_SIG, "ENCRYPTED PRIVATE KEY", bp, (char *)x, 0, 0, 0, 0, 0);
}

PKCS8_PRIV_KEY_INFO *__cdecl PEM_read_PKCS8_PRIV_KEY_INFO(FILE *fp, PKCS8_PRIV_KEY_INFO **x, pem_password_cb *cb, void *u)
{
  return (PKCS8_PRIV_KEY_INFO *)PEM_ASN1_read((d2i_of_void *)d2i_PKCS8_PRIV_KEY_INFO, "PRIVATE KEY", fp, (void **)x, cb, u);
}

int PEM_write_PKCS8_PRIV_KEY_INFO(FILE *fp, PKCS8_PRIV_KEY_INFO *x)
{
  return PEM_ASN1_write((i2d_of_void *)i2d_PKCS8_PRIV_KEY_INFO, "PRIVATE KEY", fp, (char *)x, 0, 0, 0, 0, 0);
}

PKCS8_PRIV_KEY_INFO *__cdecl PEM_read_bio_PKCS8_PRIV_KEY_INFO(BIO *bp, PKCS8_PRIV_KEY_INFO **x, pem_password_cb *cb, void *u)
{
  return (PKCS8_PRIV_KEY_INFO *)PEM_ASN1_read_bio((d2i_of_void *)d2i_PKCS8_PRIV_KEY_INFO, "PRIVATE KEY", bp, (void **)x, cb, u);
}

int PEM_write_bio_PKCS8_PRIV_KEY_INFO(BIO *bp, PKCS8_PRIV_KEY_INFO *x)
{
  return PEM_ASN1_write_bio((i2d_of_void *)i2d_PKCS8_PRIV_KEY_INFO, "PRIVATE KEY", bp, (char *)x, 0, 0, 0, 0, 0);
}

BIO *__cdecl PKCS7_dataInit(PKCS7 *p7, BIO *bio)
{
  int v4;
  const ASN1_OBJECT **v5;
  const EVP_CIPHER *v6;
  const STACK *v7;
  const STACK *v8;
  ASN1_OBJECT **v9;
  uint64_t octet_string;
  char *ptr;
  uint64_t *v12;
  int v13;
  int v14;
  int v15;
  int v16;
  char *v17;
  uint64_t v18;
  char *v19;
  char *v20;
  int v21;
  char *v22;
  BIO_METHOD *v23;
  BIO *v24;
  BIO *v25;
  int v26;
  int v27;
  int v28;
  ASN1_TYPE *v29;
  int v30;
  char *v31;
  EVP_PKEY *pubkey;
  EVP_PKEY *v33;
  uint64_t *v34;
  uint64_t *v35;
  void *v36;
  BIO_METHOD *v38;
  BIO *v39;
  BIO_METHOD *v40;
  BIO *v41;
  size_t v42;
  EVP_CIPHER_CTX *parg;
  BIO *b;
  size_t size;
  unsigned __int8 __buf[16];
  EVP_PKEY key;
  uint64_t v48;

  v48 = *MEMORY[0x24BDAC8D0];
  b = 0;
  if (p7)
  {
    if (p7->d.ptr)
    {
      v4 = OBJ_obj2nid(p7->type);
      p7->state = 0;
      v5 = 0;
      v6 = 0;
      v7 = 0;
      v8 = 0;
      v9 = 0;
      octet_string = 0;
      switch(v4)
      {
        case 21:
          goto LABEL_16;
        case 22:
          v5 = 0;
          ptr = p7->d.ptr;
          v7 = (const STACK *)*((_QWORD *)ptr + 1);
          v12 = (uint64_t *)(ptr + 40);
          goto LABEL_15;
        case 23:
          v17 = p7->d.ptr;
          v18 = *((_QWORD *)v17 + 2);
          v6 = *(const EVP_CIPHER **)(v18 + 24);
          if (v6)
          {
            v5 = 0;
            v7 = 0;
            octet_string = 0;
            v8 = (const STACK *)*((_QWORD *)v17 + 1);
            goto LABEL_13;
          }
          v15 = 116;
          v16 = 314;
          goto LABEL_48;
        case 24:
          v19 = p7->d.ptr;
          v18 = *((_QWORD *)v19 + 5);
          v6 = *(const EVP_CIPHER **)(v18 + 24);
          if (!v6)
          {
            v15 = 116;
            v16 = 305;
LABEL_48:
            ERR_put_error(33, 4095, v15, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/pkcs7/pk7_doit.c", v16);
            goto LABEL_49;
          }
          v5 = 0;
          octet_string = 0;
          v8 = (const STACK *)*((_QWORD *)v19 + 6);
          v7 = (const STACK *)*((_QWORD *)v19 + 1);
LABEL_13:
          v9 = *(ASN1_OBJECT ***)(v18 + 8);
LABEL_16:
          if (sk_num(v7) >= 1)
          {
            v21 = 0;
            do
            {
              v22 = sk_value(v7, v21);
              if (!PKCS7_bio_add_digest(&b, (const ASN1_OBJECT **)v22))
                goto LABEL_49;
            }
            while (++v21 < sk_num(v7));
          }
          if (v5 && !PKCS7_bio_add_digest(&b, v5))
            goto LABEL_49;
          if (v6)
          {
            parg = 0;
            v23 = BIO_f_cipher();
            v24 = BIO_new(v23);
            v25 = v24;
            if (!v24)
            {
              ERR_put_error(33, 4095, 32, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/pkcs7/pk7_doit.c", 343);
LABEL_50:
              if (b)
                BIO_free_all(b);
              if (v25)
                BIO_free_all(v25);
              return 0;
            }
            BIO_ctrl(v24, 129, 0, &parg);
            v26 = EVP_CIPHER_key_length(v6);
            v27 = EVP_CIPHER_iv_length(v6);
            v28 = EVP_CIPHER_type(v6);
            *v9 = OBJ_nid2obj(v28);
            if (v27 >= 1)
              arc4random_buf(__buf, v27);
            if (EVP_CipherInit_ex(parg, v6, 0, 0, 0, 1) < 1
              || EVP_CIPHER_CTX_rand_key(parg, (unsigned __int8 *)&key) < 1
              || EVP_CipherInit_ex(parg, 0, 0, (const unsigned __int8 *)&key, __buf, 1) < 1)
            {
              goto LABEL_50;
            }
            if (v27 >= 1)
            {
              v29 = (ASN1_TYPE *)v9[1];
              if (!v29)
              {
                v29 = ASN1_TYPE_new();
                v9[1] = (ASN1_OBJECT *)v29;
                if (!v29)
                  goto LABEL_50;
              }
              if (EVP_CIPHER_param_to_asn1(parg, v29) < 0)
                goto LABEL_50;
            }
            v42 = v26;
            if (sk_num(v8) >= 1)
            {
              v30 = 0;
              while (1)
              {
                v31 = sk_value(v8, v30);
                pubkey = X509_get_pubkey(*((X509 **)v31 + 4));
                if (!pubkey)
                  goto LABEL_50;
                v33 = pubkey;
                v34 = (uint64_t *)EVP_PKEY_CTX_new((uint64_t)pubkey, 0);
                if (!v34)
                  goto LABEL_50;
                v35 = v34;
                size = 0;
                if ((int)EVP_PKEY_encrypt_init(v34) < 1)
                  goto LABEL_70;
                if ((int)EVP_PKEY_CTX_ctrl(v35, -1, 256) <= 0)
                  break;
                if (EVP_PKEY_encrypt((unsigned __int8 *)v35, 0, (int)&size, &key) < 1)
                  goto LABEL_70;
                v36 = malloc_type_malloc(size, 0x59D5AE15uLL);
                if (!v36)
                {
                  ERR_put_error(33, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/pkcs7/pk7_doit.c", 180);
LABEL_72:
                  EVP_PKEY_free(v33);
                  EVP_PKEY_CTX_free((EVP_PKEY **)v35);
                  free(v36);
                  goto LABEL_50;
                }
                if (EVP_PKEY_encrypt((unsigned __int8 *)v35, (const unsigned __int8 *)v36, (int)&size, &key) < 1)
                  goto LABEL_72;
                ASN1_STRING_set0(*((ASN1_STRING **)v31 + 3), v36, size);
                EVP_PKEY_free(v33);
                EVP_PKEY_CTX_free((EVP_PKEY **)v35);
                if (++v30 >= sk_num(v8))
                  goto LABEL_43;
              }
              ERR_put_error(33, 4095, 152, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/pkcs7/pk7_doit.c", 170);
LABEL_70:
              v36 = 0;
              goto LABEL_72;
            }
LABEL_43:
            explicit_bzero(&key, v42);
            if (b)
              BIO_push(b, v25);
            else
              b = v25;
          }
          if (bio)
          {
LABEL_58:
            if (b)
            {
              BIO_push(b, bio);
              return b;
            }
            return bio;
          }
          if (OBJ_obj2nid(p7->type) == 22 && PKCS7_ctrl(p7, 2, 0, 0))
          {
            v38 = BIO_s_null();
            v39 = BIO_new(v38);
          }
          else
          {
            if (!octet_string || *(int *)octet_string < 1)
              goto LABEL_67;
            v39 = BIO_new_mem_buf(*(void **)(octet_string + 8), *(_DWORD *)octet_string);
          }
          bio = v39;
          if (v39)
            goto LABEL_58;
LABEL_67:
          v40 = BIO_s_mem();
          v41 = BIO_new(v40);
          if (v41)
          {
            bio = v41;
            BIO_ctrl(v41, 130, 0, 0);
            goto LABEL_58;
          }
LABEL_49:
          v25 = 0;
          goto LABEL_50;
        case 25:
          v7 = 0;
          v20 = p7->d.ptr;
          v5 = (const ASN1_OBJECT **)*((_QWORD *)v20 + 1);
          v12 = (uint64_t *)(v20 + 16);
LABEL_15:
          octet_string = PKCS7_get_octet_string(*v12);
          v6 = 0;
          v8 = 0;
          v9 = 0;
          goto LABEL_16;
        default:
          v15 = 112;
          v16 = 325;
          goto LABEL_48;
      }
    }
    v13 = 122;
    v14 = 287;
  }
  else
  {
    v13 = 143;
    v14 = 270;
  }
  ERR_put_error(33, 4095, v13, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/pkcs7/pk7_doit.c", v14);
  return 0;
}

uint64_t PKCS7_get_octet_string(uint64_t a1)
{
  _DWORD *v2;
  _DWORD *v4;

  if (OBJ_obj2nid(*(const ASN1_OBJECT **)(a1 + 24)) == 21)
  {
    v2 = (_DWORD *)(a1 + 32);
    return *(_QWORD *)v2;
  }
  if ((OBJ_obj2nid(*(const ASN1_OBJECT **)(a1 + 24)) - 21) >= 6)
  {
    v4 = *(_DWORD **)(a1 + 32);
    if (v4)
    {
      if (*v4 == 4)
      {
        v2 = v4 + 2;
        return *(_QWORD *)v2;
      }
    }
  }
  return 0;
}

uint64_t PKCS7_bio_add_digest(BIO **a1, const ASN1_OBJECT **a2)
{
  BIO_METHOD *v4;
  BIO *v5;
  int v6;
  const char *v7;
  EVP_MD *digestbyname;
  int v9;
  int v10;

  v4 = BIO_f_md();
  v5 = BIO_new(v4);
  if (!v5)
  {
    v9 = 32;
    v10 = 117;
    goto LABEL_10;
  }
  v6 = OBJ_obj2nid(*a2);
  v7 = OBJ_nid2sn(v6);
  digestbyname = (EVP_MD *)EVP_get_digestbyname(v7);
  if (!digestbyname)
  {
    v9 = 109;
    v10 = 123;
    goto LABEL_10;
  }
  if (BIO_ctrl(v5, 111, 0, digestbyname) <= 0)
  {
    v9 = 32;
    v10 = 128;
    goto LABEL_10;
  }
  if (*a1)
  {
    if (!BIO_push(*a1, v5))
    {
      v9 = 32;
      v10 = 135;
LABEL_10:
      ERR_put_error(33, 4095, v9, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/pkcs7/pk7_doit.c", v10);
      BIO_free(v5);
      return 0;
    }
  }
  else
  {
    *a1 = v5;
  }
  return 1;
}

BIO *__cdecl PKCS7_dataDecode(PKCS7 *p7, EVP_PKEY *pkey, BIO *in_bio, X509 *pcert)
{
  int v8;
  const EVP_CIPHER *v9;
  const ASN1_OBJECT **v10;
  const STACK *v11;
  const STACK *v12;
  int v13;
  int v14;
  char *ptr;
  uint64_t v16;
  char *v17;
  int v18;
  const char *v19;
  const EVP_CIPHER *cipherbyname;
  BIO *v21;
  int v22;
  char *v23;
  BIO_METHOD *v24;
  BIO *v25;
  int v26;
  const char *v27;
  EVP_MD *digestbyname;
  char *v29;
  uint64_t v30;
  uint64_t v31;
  int v32;
  const char *v33;
  const EVP_CIPHER *v34;
  int v35;
  int v36;
  BIO_METHOD *v37;
  BIO *v38;
  int v39;
  int v40;
  char *v41;
  int v42;
  int v43;
  int v44;
  BIO *v45;
  uint64_t v46;
  int v47;
  char *v48;
  int v49;
  int v50;
  int v51;
  unsigned __int8 *v52;
  BIO_METHOD *v54;
  unsigned __int8 *v55;
  int v56;
  const ASN1_OBJECT **v57;
  uint64_t octet_string;
  BIO *v59;
  int v60;
  unsigned __int8 *v61;
  EVP_CIPHER_CTX *parg;

  v61 = 0;
  parg = 0;
  v60 = 0;
  if (p7)
  {
    if (p7->d.ptr)
    {
      v8 = OBJ_obj2nid(p7->type);
      p7->state = 0;
      switch(v8)
      {
        case 24:
          ptr = p7->d.ptr;
          v12 = (const STACK *)*((_QWORD *)ptr + 1);
          v17 = ptr + 40;
          v16 = *((_QWORD *)ptr + 5);
          v11 = (const STACK *)*((_QWORD *)v17 + 1);
          octet_string = *(_QWORD *)(v16 + 16);
          v59 = in_bio;
          v10 = *(const ASN1_OBJECT ***)(v16 + 8);
          v18 = OBJ_obj2nid(*v10);
          v19 = OBJ_nid2sn(v18);
          cipherbyname = EVP_get_cipherbyname(v19);
          if (cipherbyname)
          {
            v9 = cipherbyname;
            goto LABEL_12;
          }
          v35 = 111;
          v36 = 470;
          break;
        case 23:
          v29 = p7->d.ptr;
          v11 = (const STACK *)*((_QWORD *)v29 + 1);
          v30 = *((_QWORD *)v29 + 2);
          v31 = *(_QWORD *)(v30 + 16);
          v57 = *(const ASN1_OBJECT ***)(v30 + 8);
          v32 = OBJ_obj2nid(*v57);
          v33 = OBJ_nid2sn(v32);
          v34 = EVP_get_cipherbyname(v33);
          if (v34)
          {
            v9 = v34;
            octet_string = v31;
            v59 = in_bio;
            v21 = 0;
            goto LABEL_28;
          }
          v35 = 111;
          v36 = 480;
          break;
        case 22:
          v59 = in_bio;
          octet_string = PKCS7_get_octet_string(*((_QWORD *)p7->d.ptr + 5));
          v9 = 0;
          v10 = 0;
          v11 = 0;
          v12 = (const STACK *)*((_QWORD *)p7->d.ptr + 1);
LABEL_12:
          v57 = v10;
          if (v12 && sk_num(v12) >= 1)
          {
            v21 = 0;
            v22 = 0;
            while (1)
            {
              v23 = sk_value(v12, v22);
              v24 = BIO_f_md();
              v25 = BIO_new(v24);
              if (!v25)
              {
                v50 = 32;
                v51 = 494;
                goto LABEL_59;
              }
              v26 = OBJ_obj2nid(*(const ASN1_OBJECT **)v23);
              v27 = OBJ_nid2sn(v26);
              digestbyname = (EVP_MD *)EVP_get_digestbyname(v27);
              if (!digestbyname)
              {
                v50 = 109;
                v51 = 501;
                goto LABEL_59;
              }
              if (BIO_ctrl(v25, 111, 0, digestbyname) <= 0)
                break;
              if (v21)
                BIO_push(v21, v25);
              else
                v21 = v25;
              if (++v22 >= sk_num(v12))
                goto LABEL_27;
            }
            v50 = 32;
            v51 = 506;
LABEL_59:
            ERR_put_error(33, 4095, v50, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/pkcs7/pk7_doit.c", v51);
            goto LABEL_60;
          }
          v21 = 0;
LABEL_27:
          if (!v9)
          {
            v44 = 0;
            goto LABEL_40;
          }
LABEL_28:
          v37 = BIO_f_cipher();
          v38 = BIO_new(v37);
          if (v38)
          {
            v39 = sk_num(v11);
            if (!pcert)
            {
              if (v39 >= 1)
              {
                v47 = 0;
                do
                {
                  v48 = sk_value(v11, v47);
                  v49 = EVP_CIPHER_key_length(v9);
                  if ((pkcs7_decrypt_rinfo((void **)&v61, &v60, (uint64_t)v48, (uint64_t)pkey, v49) & 0x80000000) != 0)
                    goto LABEL_38;
                  ERR_clear_error();
                }
                while (++v47 < sk_num(v11));
              }
LABEL_75:
              parg = 0;
              BIO_ctrl(v38, 129, 0, &parg);
              if (EVP_CipherInit_ex(parg, v9, 0, 0, 0, 0) >= 1
                && (EVP_CIPHER_asn1_to_param(parg, (ASN1_TYPE *)v57[1]) & 0x80000000) == 0)
              {
                v44 = EVP_CIPHER_CTX_key_length(parg);
                v52 = (unsigned __int8 *)malloc_type_malloc(v44, 0xCDA15344uLL);
                if (!v52 || EVP_CIPHER_CTX_rand_key(parg, v52) < 1)
                  goto LABEL_89;
                v55 = v61;
                if (v61)
                {
                  v56 = v60;
                }
                else
                {
                  v61 = v52;
                  v60 = v44;
                  v55 = v52;
                  v56 = v44;
                  v52 = 0;
                }
                if (v56 != EVP_CIPHER_CTX_key_length(parg) && !EVP_CIPHER_CTX_set_key_length(parg, v56))
                {
                  freezero(v55, v56);
                  v61 = v52;
                  v60 = v44;
                  v55 = v52;
                  v52 = 0;
                }
                ERR_clear_error();
                if (EVP_CipherInit_ex(parg, 0, 0, v55, 0, 0) < 1)
                {
LABEL_89:
                  v25 = 0;
                  goto LABEL_62;
                }
                freezero(v55, v60);
                v61 = 0;
                freezero(v52, v44);
                if (v21)
                  BIO_push(v21, v38);
                else
                  v21 = v38;
LABEL_40:
                v45 = v59;
                if (OBJ_obj2nid(p7->type) == 22)
                {
                  v46 = PKCS7_ctrl(p7, 2, 0, 0);
                  if (v59 || v46)
                    goto LABEL_72;
                }
                else if (v59)
                {
                  goto LABEL_72;
                }
                if (octet_string && *(int *)octet_string >= 1)
                {
                  v45 = BIO_new_mem_buf(*(void **)(octet_string + 8), *(_DWORD *)octet_string);
                }
                else
                {
                  v54 = BIO_s_mem();
                  v45 = BIO_new(v54);
                  BIO_ctrl(v45, 130, 0, 0);
                }
                if (!v45)
                {
                  v25 = 0;
                  v38 = 0;
                  v52 = 0;
                  goto LABEL_62;
                }
LABEL_72:
                BIO_push(v21, v45);
                return v21;
              }
LABEL_38:
              v25 = 0;
LABEL_61:
              v52 = 0;
              v44 = 0;
LABEL_62:
              freezero(v61, v60);
              freezero(v52, v44);
              if (v21)
                BIO_free_all(v21);
              if (v25)
                BIO_free_all(v25);
              if (v38)
                BIO_free_all(v38);
              return 0;
            }
            if (v39 >= 1)
            {
              v40 = 0;
              while (1)
              {
                v41 = sk_value(v11, v40);
                if (!X509_NAME_cmp(**((const X509_NAME ***)v41 + 1), pcert->cert_info->issuer)
                  && !ASN1_INTEGER_cmp(pcert->cert_info->serialNumber, *(ASN1_INTEGER **)(*((_QWORD *)v41 + 1) + 8)))
                {
                  break;
                }
                if (++v40 >= sk_num(v11))
                  goto LABEL_35;
              }
              if ((pkcs7_decrypt_rinfo((void **)&v61, &v60, (uint64_t)v41, (uint64_t)pkey, 0) & 0x80000000) != 0)
                goto LABEL_38;
              ERR_clear_error();
              goto LABEL_75;
            }
LABEL_35:
            v42 = 115;
            v43 = 537;
          }
          else
          {
            v42 = 32;
            v43 = 519;
          }
          ERR_put_error(33, 4095, v42, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/pkcs7/pk7_doit.c", v43);
          goto LABEL_38;
        default:
          v35 = 112;
          v36 = 485;
          break;
      }
      ERR_put_error(33, 4095, v35, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/pkcs7/pk7_doit.c", v36);
      v21 = 0;
      v25 = 0;
LABEL_60:
      v38 = 0;
      goto LABEL_61;
    }
    v13 = 122;
    v14 = 451;
  }
  else
  {
    v13 = 143;
    v14 = 446;
  }
  ERR_put_error(33, 4095, v13, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/pkcs7/pk7_doit.c", v14);
  return 0;
}

uint64_t pkcs7_decrypt_rinfo(void **a1, int *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t *v9;
  uint64_t *v10;
  const unsigned __int8 *v11;
  unsigned __int8 *v12;
  BOOL v13;
  uint64_t v14;
  int v15;
  int v16;
  size_t size;

  v9 = (uint64_t *)EVP_PKEY_CTX_new(a4, 0);
  if (!v9)
    return 0xFFFFFFFFLL;
  v10 = v9;
  size = 0;
  if ((int)EVP_PKEY_decrypt_init(v9) < 1)
    goto LABEL_17;
  if ((int)EVP_PKEY_CTX_ctrl(v10, -1, 512) <= 0)
  {
    v15 = 152;
    v16 = 219;
LABEL_16:
    ERR_put_error(33, 4095, v15, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/pkcs7/pk7_doit.c", v16);
    goto LABEL_17;
  }
  if (EVP_PKEY_decrypt((unsigned __int8 *)v10, 0, (int)&size, *(EVP_PKEY **)(*(_QWORD *)(a3 + 24) + 8)) < 1)
  {
LABEL_17:
    v14 = 0xFFFFFFFFLL;
LABEL_18:
    EVP_PKEY_CTX_free((EVP_PKEY **)v10);
    return v14;
  }
  v11 = (const unsigned __int8 *)malloc_type_malloc(size, 0xEB5B041uLL);
  if (!v11)
  {
    v15 = 65;
    v16 = 229;
    goto LABEL_16;
  }
  v12 = (unsigned __int8 *)v11;
  v13 = EVP_PKEY_decrypt((unsigned __int8 *)v10, v11, (int)&size, *(EVP_PKEY **)(*(_QWORD *)(a3 + 24) + 8)) < 1
     || size == 0;
  if (!v13 && (!a5 || size == a5))
  {
    freezero(*a1, *a2);
    *a1 = v12;
    *a2 = size;
    v14 = 1;
    goto LABEL_18;
  }
  ERR_put_error(33, 4095, 6, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/pkcs7/pk7_doit.c", 237);
  EVP_PKEY_CTX_free((EVP_PKEY **)v10);
  free(v12);
  return 0;
}

int PKCS7_dataFinal(PKCS7 *p7, BIO *bio)
{
  int v4;
  uint64_t ptr;
  int v6;
  int v7;
  BIO *v8;
  int v9;
  int v10;
  char *v11;
  const STACK *v12;
  ASN1_OCTET_STRING *v13;
  char *v14;
  ASN1_OCTET_STRING *v15;
  int v16;
  char *v17;
  PKCS7_SIGNER_INFO *v18;
  int v19;
  unsigned __int8 *v20;
  unsigned __int8 *v21;
  uint64_t octet_string;
  int v23;
  BIO *type;
  int v25;
  EVP_MD_CTX v27;
  __int128 v28;
  EVP_MD_CTX *in;
  unsigned int s;
  unsigned __int8 md[8];
  uint64_t v32;

  v32 = *MEMORY[0x24BDAC8D0];
  if (!p7)
  {
    v6 = 143;
    v7 = 709;
LABEL_7:
    ERR_put_error(33, 4095, v6, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/pkcs7/pk7_doit.c", v7);
    LODWORD(v8) = 0;
    return (int)v8;
  }
  if (!p7->d.ptr)
  {
    v6 = 122;
    v7 = 714;
    goto LABEL_7;
  }
  in = 0;
  memset(&v27, 0, sizeof(v27));
  v28 = 0u;
  EVP_MD_CTX_init(&v27);
  v4 = OBJ_obj2nid(p7->type);
  p7->state = 0;
  switch(v4)
  {
    case 21:
      ptr = (uint64_t)p7->d.ptr;
      goto LABEL_46;
    case 22:
      v11 = p7->d.ptr;
      v12 = (const STACK *)*((_QWORD *)v11 + 4);
      ptr = PKCS7_get_octet_string(*((_QWORD *)v11 + 5));
      if ((OBJ_obj2nid(p7->type) != 22 || !PKCS7_ctrl(p7, 2, 0, 0)) && !ptr)
      {
        v9 = 130;
        v10 = 755;
        goto LABEL_62;
      }
      if (OBJ_obj2nid(*(const ASN1_OBJECT **)(*((_QWORD *)p7->d.ptr + 5) + 24)) == 21 && p7->detached)
      {
        ASN1_OCTET_STRING_free((ASN1_OCTET_STRING *)ptr);
        ptr = 0;
        *(_QWORD *)(*((_QWORD *)p7->d.ptr + 5) + 32) = 0;
      }
      goto LABEL_21;
    case 23:
      ptr = *(_QWORD *)(*((_QWORD *)p7->d.ptr + 2) + 16);
      if (ptr)
        goto LABEL_46;
      v13 = ASN1_OCTET_STRING_new();
      if (v13)
      {
        ptr = (uint64_t)v13;
        *(_QWORD *)(*((_QWORD *)p7->d.ptr + 2) + 16) = v13;
        goto LABEL_46;
      }
      v9 = 65;
      v10 = 745;
      goto LABEL_62;
    case 24:
      v14 = p7->d.ptr;
      v12 = (const STACK *)*((_QWORD *)v14 + 4);
      ptr = *(_QWORD *)(*((_QWORD *)v14 + 5) + 16);
      if (ptr)
        goto LABEL_21;
      v15 = ASN1_OCTET_STRING_new();
      if (!v15)
      {
        v9 = 65;
        v10 = 733;
        goto LABEL_62;
      }
      ptr = (uint64_t)v15;
      *(_QWORD *)(*((_QWORD *)p7->d.ptr + 5) + 16) = v15;
LABEL_21:
      if (!v12 || sk_num(v12) < 1)
        goto LABEL_46;
      v16 = 0;
      while (2)
      {
        v17 = sk_value(v12, v16);
        if (!*((_QWORD *)v17 + 7))
          goto LABEL_37;
        v18 = (PKCS7_SIGNER_INFO *)v17;
        v19 = OBJ_obj2nid(**((const ASN1_OBJECT ***)v17 + 2));
        if (!PKCS7_find_digest((const EVP_MD_CTX **)&in, bio, v19) || !EVP_MD_CTX_copy_ex(&v27, in))
          goto LABEL_63;
        if (sk_num(v18->auth_attr) < 1)
        {
          *(_DWORD *)md = 0;
          *(_DWORD *)md = EVP_PKEY_size(v18->pkey);
          v20 = (unsigned __int8 *)malloc_type_malloc(*(unsigned int *)md, 0x7590445CuLL);
          if (!v20)
            goto LABEL_63;
          v21 = v20;
          if (EVP_SignFinal(&v27, v20, (unsigned int *)md, v18->pkey))
          {
            ASN1_STRING_set0(v18->enc_digest, v21, *(int *)md);
            goto LABEL_37;
          }
          v9 = 6;
          v10 = 819;
        }
        else if (get_attribute(v18->auth_attr, 52) || PKCS7_add0_attrib_signing_time(v18, 0))
        {
          s = 0;
          if (EVP_DigestFinal_ex(&v27, md, &s))
          {
            if (PKCS7_add1_attrib_digest(v18, md, s))
            {
              if (!PKCS7_SIGNER_INFO_sign((uint64_t)v18))
                goto LABEL_63;
LABEL_37:
              if (++v16 >= sk_num(v12))
                goto LABEL_46;
              continue;
            }
            v9 = 65;
            v10 = 684;
          }
          else
          {
            v9 = 6;
            v10 = 680;
          }
        }
        else
        {
          v9 = 65;
          v10 = 673;
        }
        goto LABEL_62;
      }
    case 25:
      octet_string = PKCS7_get_octet_string(*((_QWORD *)p7->d.ptr + 2));
      if (!octet_string)
      {
        v9 = 130;
        v10 = 769;
LABEL_62:
        ERR_put_error(33, 4095, v9, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/pkcs7/pk7_doit.c", v10);
        goto LABEL_63;
      }
      ptr = octet_string;
      if (OBJ_obj2nid(*(const ASN1_OBJECT **)(*((_QWORD *)p7->d.ptr + 2) + 24)) == 21 && p7->detached)
      {
        ASN1_OCTET_STRING_free((ASN1_OCTET_STRING *)ptr);
        ptr = 0;
        *(_QWORD *)(*((_QWORD *)p7->d.ptr + 2) + 32) = 0;
      }
      s = 0;
      v23 = OBJ_obj2nid(**((const ASN1_OBJECT ***)p7->d.ptr + 1));
      if (!PKCS7_find_digest((const EVP_MD_CTX **)&in, bio, v23)
        || !EVP_DigestFinal_ex(in, md, &s)
        || !ASN1_STRING_set(*((ASN1_STRING **)p7->d.ptr + 3), md, s))
      {
LABEL_63:
        LODWORD(v8) = 0;
        goto LABEL_64;
      }
LABEL_46:
      if (OBJ_obj2nid(p7->type) == 22 && PKCS7_ctrl(p7, 2, 0, 0))
        goto LABEL_52;
      if (!ptr)
        goto LABEL_63;
      if ((*(_BYTE *)(ptr + 16) & 0x10) != 0)
        goto LABEL_52;
      *(_QWORD *)md = 0;
      type = BIO_find_type(bio, 1025);
      v8 = type;
      if (type)
      {
        v25 = BIO_ctrl(type, 3, 0, md);
        BIO_set_flags(v8, 512);
        BIO_ctrl(v8, 130, 0, 0);
        ASN1_STRING_set0((ASN1_STRING *)ptr, *(void **)md, v25);
LABEL_52:
        LODWORD(v8) = 1;
        goto LABEL_64;
      }
      ERR_put_error(33, 4095, 107, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/pkcs7/pk7_doit.c", 852);
LABEL_64:
      EVP_MD_CTX_cleanup(&v27);
      return (int)v8;
    default:
      v9 = 112;
      v10 = 782;
      goto LABEL_62;
  }
}

BIO *PKCS7_find_digest(const EVP_MD_CTX **a1, BIO *b, int a3)
{
  BIO *type;
  BIO *v6;
  const EVP_MD *v7;
  BIO *v8;
  int v9;
  int v10;

  type = BIO_find_type(b, 520);
  if (type)
  {
    v6 = type;
    while (1)
    {
      BIO_ctrl(v6, 120, 0, a1);
      if (!*a1)
        break;
      v7 = EVP_MD_CTX_md(*a1);
      if (EVP_MD_type(v7) == a3)
        return v6;
      v8 = BIO_next(v6);
      v6 = BIO_find_type(v8, 520);
      if (!v6)
        goto LABEL_6;
    }
    v9 = 68;
    v10 = 654;
  }
  else
  {
LABEL_6:
    v9 = 108;
    v10 = 649;
  }
  ERR_put_error(33, 4095, v9, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/pkcs7/pk7_doit.c", v10);
  return 0;
}

const EVP_MD *PKCS7_SIGNER_INFO_sign(uint64_t a1)
{
  int v2;
  const char *v3;
  const EVP_MD *result;
  const EVP_MD *v5;
  int v6;
  unsigned __int8 *v7;
  int v8;
  size_t size;
  unsigned __int8 *out;
  uint64_t *v11;
  EVP_MD_CTX ctx;
  __int128 v13;

  v13 = 0u;
  memset(&ctx, 0, sizeof(ctx));
  out = 0;
  v11 = 0;
  size = 0;
  v2 = OBJ_obj2nid(**(const ASN1_OBJECT ***)(a1 + 16));
  v3 = OBJ_nid2sn(v2);
  result = EVP_get_digestbyname(v3);
  if (result)
  {
    v5 = result;
    EVP_MD_CTX_init(&ctx);
    if ((int)EVP_DigestSignInit((uint64_t)&ctx, &v11, v5, 0, *(_QWORD *)(a1 + 56)) >= 1)
    {
      if ((int)EVP_PKEY_CTX_ctrl(v11, -1, 8) < 1)
      {
        v8 = 892;
      }
      else
      {
        v6 = ASN1_item_i2d(*(ASN1_VALUE **)(a1 + 24), &out, &PKCS7_ATTR_SIGN_it);
        if (!out)
          goto LABEL_13;
        if (EVP_DigestUpdate(&ctx, out, v6) < 1)
          goto LABEL_13;
        free(out);
        out = 0;
        if ((int)EVP_DigestSignFinal((uint64_t)&ctx, 0, &size) < 1)
          goto LABEL_13;
        v7 = (unsigned __int8 *)malloc_type_malloc(size, 0x5979CC37uLL);
        out = v7;
        if (!v7 || (int)EVP_DigestSignFinal((uint64_t)&ctx, (uint64_t)v7, &size) < 1)
          goto LABEL_13;
        if ((int)EVP_PKEY_CTX_ctrl(v11, -1, 8) >= 1)
        {
          EVP_MD_CTX_cleanup(&ctx);
          ASN1_STRING_set0(*(ASN1_STRING **)(a1 + 40), out, size);
          return (const EVP_MD *)1;
        }
        v8 = 914;
      }
      ERR_put_error(33, 4095, 152, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/pkcs7/pk7_doit.c", v8);
    }
LABEL_13:
    free(out);
    EVP_MD_CTX_cleanup(&ctx);
    return 0;
  }
  return result;
}

int PKCS7_dataVerify(X509_STORE *cert_store, X509_STORE_CTX *ctx, BIO *bio, PKCS7 *p7, PKCS7_SIGNER_INFO *si)
{
  STACK *v10;
  X509 *v11;
  X509 *v12;
  int v14;
  int v15;

  if (!p7)
  {
    v14 = 143;
    v15 = 941;
LABEL_15:
    ERR_put_error(33, 4095, v14, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/pkcs7/pk7_doit.c", v15);
    return 0;
  }
  if (!p7->d.ptr)
  {
    v14 = 122;
    v15 = 946;
    goto LABEL_15;
  }
  if (OBJ_obj2nid(p7->type) != 22 && OBJ_obj2nid(p7->type) != 24)
  {
    v14 = 114;
    v15 = 955;
    goto LABEL_15;
  }
  v10 = (STACK *)*((_QWORD *)p7->d.ptr + 2);
  v11 = X509_find_by_issuer_and_serial(v10, si->issuer_and_serial->issuer, si->issuer_and_serial->serial);
  if (!v11)
  {
    v14 = 106;
    v15 = 965;
    goto LABEL_15;
  }
  v12 = v11;
  if (!X509_STORE_CTX_init(ctx, cert_store, v11, v10))
  {
    v14 = 11;
    v15 = 971;
    goto LABEL_15;
  }
  if (X509_STORE_CTX_set_purpose(ctx, 4))
  {
    if (X509_verify_cert(ctx) > 0)
    {
      X509_STORE_CTX_cleanup(ctx);
      return PKCS7_signatureVerify(bio, p7, si, v12);
    }
    ERR_put_error(33, 4095, 11, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/pkcs7/pk7_doit.c", 980);
  }
  X509_STORE_CTX_cleanup(ctx);
  return 0;
}

int PKCS7_signatureVerify(BIO *bio, PKCS7 *p7, PKCS7_SIGNER_INFO *si, X509 *x509)
{
  int v8;
  int v9;
  BIO *type;
  BIO *v11;
  const EVP_MD *v12;
  const EVP_MD *v13;
  int v14;
  int v15;
  STACK *auth_attr;
  char *attribute;
  const void **v18;
  size_t v19;
  int v20;
  int v21;
  int v22;
  const char *v24;
  const EVP_MD *digestbyname;
  int v26;
  ASN1_OCTET_STRING *enc_digest;
  EVP_PKEY *pubkey;
  EVP_PKEY *v29;
  int v30;
  unsigned int s;
  unsigned __int8 *out;
  const EVP_MD_CTX *parg;
  EVP_MD_CTX ctx;
  __int128 v35;
  unsigned __int8 md[64];
  uint64_t v37;

  v37 = *MEMORY[0x24BDAC8D0];
  v35 = 0u;
  memset(&ctx, 0, sizeof(ctx));
  parg = 0;
  EVP_MD_CTX_init(&ctx);
  if (OBJ_obj2nid(p7->type) == 22 || OBJ_obj2nid(p7->type) == 24)
  {
    v8 = OBJ_obj2nid(si->digest_alg->algorithm);
    if (bio)
    {
      v9 = v8;
      while (1)
      {
        type = BIO_find_type(bio, 520);
        if (!type)
          goto LABEL_10;
        v11 = type;
        BIO_ctrl(type, 120, 0, &parg);
        if (!parg)
        {
          v14 = 68;
          v15 = 1023;
          goto LABEL_23;
        }
        v12 = EVP_MD_CTX_md(parg);
        if (EVP_MD_type(v12) == v9)
          break;
        v13 = EVP_MD_CTX_md(parg);
        if (EVP_MD_pkey_type(v13) == v9)
          break;
        bio = BIO_next(v11);
        if (!bio)
          goto LABEL_10;
      }
      if (!EVP_MD_CTX_copy_ex(&ctx, parg))
        goto LABEL_24;
      auth_attr = si->auth_attr;
      if (auth_attr && sk_num(si->auth_attr))
      {
        out = 0;
        s = 0;
        if (!EVP_DigestFinal_ex(&ctx, md, &s))
          goto LABEL_24;
        attribute = get_attribute(auth_attr, 51);
        if (!attribute || *(_DWORD *)attribute != 4 || (v18 = (const void **)*((_QWORD *)attribute + 1)) == 0)
        {
          v14 = 108;
          v15 = 1052;
          goto LABEL_23;
        }
        v19 = *(unsigned int *)v18;
        if ((_DWORD)v19 != s || memcmp(v18[1], md, v19))
        {
          v20 = 101;
          v21 = 1057;
          goto LABEL_35;
        }
        v24 = OBJ_nid2sn(v9);
        digestbyname = EVP_get_digestbyname(v24);
        if (!EVP_DigestInit_ex(&ctx, digestbyname, 0))
          goto LABEL_24;
        v26 = ASN1_item_i2d((ASN1_VALUE *)auth_attr, &out, &PKCS7_ATTR_VERIFY_it);
        if (v26 <= 0)
        {
          v20 = 13;
          v21 = 1069;
          goto LABEL_35;
        }
        if (!EVP_DigestUpdate(&ctx, out, v26))
          goto LABEL_24;
        free(out);
      }
      enc_digest = si->enc_digest;
      pubkey = X509_get_pubkey(x509);
      if (!pubkey)
      {
LABEL_36:
        v22 = -1;
        goto LABEL_25;
      }
      v29 = pubkey;
      v30 = EVP_VerifyFinal(&ctx, enc_digest->data, enc_digest->length, pubkey);
      EVP_PKEY_free(v29);
      if (v30 > 0)
      {
        v22 = 1;
        goto LABEL_25;
      }
      v20 = 105;
      v21 = 1089;
LABEL_35:
      ERR_put_error(33, 4095, v20, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/pkcs7/pk7_doit.c", v21);
      goto LABEL_36;
    }
LABEL_10:
    v14 = 108;
    v15 = 1018;
  }
  else
  {
    v14 = 114;
    v15 = 1008;
  }
LABEL_23:
  ERR_put_error(33, 4095, v14, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/pkcs7/pk7_doit.c", v15);
LABEL_24:
  v22 = 0;
LABEL_25:
  EVP_MD_CTX_cleanup(&ctx);
  return v22;
}

ASN1_OCTET_STRING *__cdecl PKCS7_digest_from_attributes(STACK *sk)
{
  ASN1_OCTET_STRING *result;

  result = (ASN1_OCTET_STRING *)get_attribute(sk, 51);
  if (result)
  {
    if (result->length == 4)
      return (ASN1_OCTET_STRING *)result->data;
    else
      return 0;
  }
  return result;
}

PKCS7_ISSUER_AND_SERIAL *__cdecl PKCS7_get_issuer_and_serial(PKCS7 *p7, int idx)
{
  char *ptr;
  const STACK *v5;

  if (OBJ_obj2nid(p7->type) == 24
    && (ptr = p7->d.ptr) != 0
    && (v5 = (const STACK *)*((_QWORD *)ptr + 6)) != 0
    && (sk_value(*((const STACK **)ptr + 6), 0), sk_num(v5) > idx))
  {
    return (PKCS7_ISSUER_AND_SERIAL *)*((_QWORD *)sk_value(v5, idx) + 1);
  }
  else
  {
    return 0;
  }
}

ASN1_TYPE *__cdecl PKCS7_get_signed_attribute(PKCS7_SIGNER_INFO *si, int nid)
{
  return (ASN1_TYPE *)get_attribute(si->auth_attr, nid);
}

char *get_attribute(const STACK *a1, int n)
{
  ASN1_OBJECT *v3;
  const ASN1_OBJECT *v4;
  int v5;
  char *v6;

  v3 = OBJ_nid2obj(n);
  if (!a1)
    return 0;
  v4 = v3;
  if (!v3 || sk_num(a1) < 1)
    return 0;
  v5 = 0;
  while (1)
  {
    v6 = sk_value(a1, v5);
    if (!OBJ_cmp(*(const ASN1_OBJECT **)v6, v4))
      break;
    if (++v5 >= sk_num(a1))
      return 0;
  }
  return sk_value(*((const STACK **)v6 + 1), 0);
}

ASN1_TYPE *__cdecl PKCS7_get_attribute(PKCS7_SIGNER_INFO *si, int nid)
{
  return (ASN1_TYPE *)get_attribute(si->unauth_attr, nid);
}

int PKCS7_set_signed_attributes(PKCS7_SIGNER_INFO *p7si, STACK *sk)
{
  STACK *auth_attr;
  STACK *v5;
  int v6;
  STACK *v7;
  char *v8;
  char *v9;

  auth_attr = p7si->auth_attr;
  if (auth_attr)
    sk_pop_free(auth_attr, (void (__cdecl *)(void *))X509_ATTRIBUTE_free);
  v5 = sk_dup(sk);
  p7si->auth_attr = v5;
  if (v5)
  {
    if (sk_num(sk) < 1)
    {
LABEL_8:
      LODWORD(v5) = 1;
    }
    else
    {
      v6 = 0;
      while (1)
      {
        v7 = p7si->auth_attr;
        v8 = sk_value(sk, v6);
        v9 = (char *)X509_ATTRIBUTE_dup((X509_ATTRIBUTE *)v8);
        v5 = (STACK *)sk_set(v7, v6, v9);
        if (!v5)
          break;
        if (++v6 >= sk_num(sk))
          goto LABEL_8;
      }
    }
  }
  return (int)v5;
}

int PKCS7_set_attributes(PKCS7_SIGNER_INFO *p7si, STACK *sk)
{
  STACK *unauth_attr;
  STACK *v5;
  int v6;
  STACK *v7;
  char *v8;
  char *v9;

  unauth_attr = p7si->unauth_attr;
  if (unauth_attr)
    sk_pop_free(unauth_attr, (void (__cdecl *)(void *))X509_ATTRIBUTE_free);
  v5 = sk_dup(sk);
  p7si->unauth_attr = v5;
  if (v5)
  {
    if (sk_num(sk) < 1)
    {
LABEL_8:
      LODWORD(v5) = 1;
    }
    else
    {
      v6 = 0;
      while (1)
      {
        v7 = p7si->unauth_attr;
        v8 = sk_value(sk, v6);
        v9 = (char *)X509_ATTRIBUTE_dup((X509_ATTRIBUTE *)v8);
        v5 = (STACK *)sk_set(v7, v6, v9);
        if (!v5)
          break;
        if (++v6 >= sk_num(sk))
          goto LABEL_8;
      }
    }
  }
  return (int)v5;
}

int PKCS7_add_signed_attribute(PKCS7_SIGNER_INFO *p7si, int nid, int type, void *data)
{
  return add_attribute(&p7si->auth_attr, nid, type, data);
}

uint64_t add_attribute(STACK **a1, int a2, int a3, void *a4)
{
  const STACK *v8;
  int v9;
  X509_ATTRIBUTE *v10;
  uint64_t result;
  X509_ATTRIBUTE *v12;

  v8 = *a1;
  if (!v8)
  {
    result = (uint64_t)sk_new_null();
    *a1 = (STACK *)result;
    if (!result)
      return result;
LABEL_8:
    result = (uint64_t)X509_ATTRIBUTE_create(a2, a3, a4);
    if (!result)
      return result;
    v12 = (X509_ATTRIBUTE *)result;
    if (!sk_push(*a1, (char *)result))
      goto LABEL_13;
    return 1;
  }
  if (sk_num(v8) < 1)
    goto LABEL_8;
  v9 = 0;
  while (1)
  {
    v10 = (X509_ATTRIBUTE *)sk_value(*a1, v9);
    if (OBJ_obj2nid(v10->object) == a2)
      break;
    if (++v9 >= sk_num(*a1))
      goto LABEL_8;
  }
  X509_ATTRIBUTE_free(v10);
  result = (uint64_t)X509_ATTRIBUTE_create(a2, a3, a4);
  if (result)
  {
    v12 = (X509_ATTRIBUTE *)result;
    if (!sk_set(*a1, v9, (char *)result))
    {
LABEL_13:
      X509_ATTRIBUTE_free(v12);
      return 0;
    }
    return 1;
  }
  return result;
}

int PKCS7_add_attribute(PKCS7_SIGNER_INFO *p7si, int nid, int atrtype, void *value)
{
  return add_attribute(&p7si->unauth_attr, nid, atrtype, value);
}

void ERR_load_ECDSA_strings(void)
{
  if (!ERR_func_error_string(ECDSA_str_functs))
  {
    ERR_load_strings(0, (ERR_STRING_DATA *)&ECDSA_str_functs);
    ERR_load_strings(0, (ERR_STRING_DATA *)&ECDSA_str_reasons);
  }
}

STACK *v2i_crld(X509V3_EXT_METHOD *a1, X509V3_CTX *a2, const STACK *a3)
{
  STACK *v6;
  int v7;
  const ASN1_ITEM *v8;
  CONF_VALUE *v9;
  char *v10;
  STACK *v11;
  STACK *section;
  char *v13;
  ASN1_VALUE *v14;
  ASN1_VALUE *v15;
  const ASN1_ITEM *v16;
  int i;
  char *v18;
  int v19;
  const char *v20;
  GENERAL_NAMES *v21;
  X509V3_EXT_METHOD *v23;

  v6 = sk_new_null();
  if (!v6)
  {
    section = 0;
    goto LABEL_30;
  }
  if (sk_num(a3) >= 1)
  {
    v7 = 0;
    v8 = &DIST_POINT_it;
    v23 = a1;
    do
    {
      v9 = (CONF_VALUE *)sk_value(a3, v7);
      if (v9->value)
      {
        v10 = (char *)v2i_GENERAL_NAME(a1, a2, v9);
        if (!v10)
        {
          section = 0;
          goto LABEL_34;
        }
        v11 = GENERAL_NAMES_new();
        section = v11;
        if (!v11 || !sk_push(v11, v10))
          goto LABEL_31;
        v13 = (char *)ASN1_item_new(v8);
        if (!v13)
          goto LABEL_30;
        v14 = (ASN1_VALUE *)v13;
        if (!sk_push(v6, v13))
          goto LABEL_38;
        v15 = ASN1_item_new(&DIST_POINT_NAME_it);
        *(_QWORD *)v14 = v15;
        if (!v15)
          goto LABEL_30;
        *((_QWORD *)v15 + 1) = section;
        **(_DWORD **)v14 = 0;
      }
      else
      {
        section = X509V3_get_section(a2, v9->name);
        if (!section)
          goto LABEL_33;
        v16 = v8;
        v14 = ASN1_item_new(v8);
        if (!v14)
        {
LABEL_32:
          ASN1_item_free(v14, &DIST_POINT_it);
          X509V3_section_free(a2, section);
          section = 0;
LABEL_33:
          v10 = 0;
          goto LABEL_34;
        }
        if (sk_num(section) >= 1)
        {
          for (i = 0; i < sk_num(section); ++i)
          {
            v18 = sk_value(section, i);
            v19 = set_dist_point_name((ASN1_VALUE **)v14, a2, (uint64_t)v18);
            if (v19 <= 0)
            {
              if (v19 < 0)
                goto LABEL_32;
              v20 = (const char *)*((_QWORD *)v18 + 1);
              if (!strcmp(v20, "reasons"))
              {
                if (!set_reasons((ASN1_BIT_STRING **)v14 + 1, *((char **)v18 + 2)))
                  goto LABEL_32;
              }
              else if (!strcmp(v20, "CRLissuer"))
              {
                v21 = gnames_from_sectname(a2, *((char **)v18 + 2));
                *((_QWORD *)v14 + 2) = v21;
                if (!v21)
                  goto LABEL_32;
              }
            }
          }
        }
        X509V3_section_free(a2, section);
        a1 = v23;
        v8 = v16;
        if (!sk_push(v6, (char *)v14))
        {
          section = 0;
LABEL_38:
          ASN1_item_free(v14, &DIST_POINT_it);
LABEL_30:
          v10 = 0;
LABEL_31:
          ERR_put_error(34, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_crld.c", 359);
LABEL_34:
          GENERAL_NAME_free((GENERAL_NAME *)v10);
          GENERAL_NAMES_free(section);
          sk_pop_free(v6, (void (__cdecl *)(void *))DIST_POINT_free);
          return 0;
        }
      }
      ++v7;
    }
    while (v7 < sk_num(a3));
  }
  return v6;
}

uint64_t i2r_crldp(int a1, STACK *a2, BIO *a3, int a4)
{
  int v7;
  char *v8;
  ASN1_BIT_STRING *v9;

  if (sk_num(a2) >= 1)
  {
    v7 = 0;
    do
    {
      BIO_puts(a3, "\n");
      v8 = sk_value(a2, v7);
      if (*(_QWORD *)v8)
        print_distpoint(a3, *(_QWORD *)v8, a4);
      v9 = (ASN1_BIT_STRING *)*((_QWORD *)v8 + 1);
      if (v9)
        print_reasons(a3, "Reasons", v9, a4);
      if (*((_QWORD *)v8 + 2))
      {
        BIO_printf(a3, "%*sCRL Issuer:\n", a4, "");
        print_gens(a3, *((STACK **)v8 + 2), a4);
      }
      ++v7;
    }
    while (v7 < sk_num(a2));
  }
  return 1;
}

DIST_POINT_NAME *__cdecl d2i_DIST_POINT_NAME(DIST_POINT_NAME **a, const unsigned __int8 **in, uint64_t len)
{
  return (DIST_POINT_NAME *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &DIST_POINT_NAME_it);
}

int i2d_DIST_POINT_NAME(DIST_POINT_NAME *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &DIST_POINT_NAME_it);
}

DIST_POINT_NAME *DIST_POINT_NAME_new(void)
{
  return (DIST_POINT_NAME *)ASN1_item_new(&DIST_POINT_NAME_it);
}

void DIST_POINT_NAME_free(DIST_POINT_NAME *a)
{
  ASN1_item_free((ASN1_VALUE *)a, &DIST_POINT_NAME_it);
}

DIST_POINT *__cdecl d2i_DIST_POINT(DIST_POINT **a, const unsigned __int8 **in, uint64_t len)
{
  return (DIST_POINT *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &DIST_POINT_it);
}

int i2d_DIST_POINT(DIST_POINT *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &DIST_POINT_it);
}

DIST_POINT *DIST_POINT_new(void)
{
  return (DIST_POINT *)ASN1_item_new(&DIST_POINT_it);
}

void DIST_POINT_free(DIST_POINT *a)
{
  ASN1_item_free((ASN1_VALUE *)a, &DIST_POINT_it);
}

CRL_DIST_POINTS *__cdecl d2i_CRL_DIST_POINTS(CRL_DIST_POINTS **a, const unsigned __int8 **in, uint64_t len)
{
  return (CRL_DIST_POINTS *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &CRL_DIST_POINTS_it);
}

int i2d_CRL_DIST_POINTS(CRL_DIST_POINTS *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &CRL_DIST_POINTS_it);
}

CRL_DIST_POINTS *CRL_DIST_POINTS_new(void)
{
  return (CRL_DIST_POINTS *)ASN1_item_new(&CRL_DIST_POINTS_it);
}

void CRL_DIST_POINTS_free(CRL_DIST_POINTS *a)
{
  ASN1_item_free((ASN1_VALUE *)a, &CRL_DIST_POINTS_it);
}

ASN1_VALUE *d2i_ISSUING_DIST_POINT(ASN1_VALUE **a1, const unsigned __int8 **a2, uint64_t a3)
{
  return ASN1_item_d2i(a1, a2, a3, &ISSUING_DIST_POINT_it);
}

uint64_t i2d_ISSUING_DIST_POINT(ASN1_VALUE *a1, unsigned __int8 **a2)
{
  return ASN1_item_i2d(a1, a2, &ISSUING_DIST_POINT_it);
}

ASN1_VALUE *ISSUING_DIST_POINT_new()
{
  return ASN1_item_new(&ISSUING_DIST_POINT_it);
}

void ISSUING_DIST_POINT_free(ASN1_VALUE *a1)
{
  ASN1_item_free(a1, &ISSUING_DIST_POINT_it);
}

ASN1_VALUE *v2i_idp(uint64_t a1, X509V3_CTX *a2, const STACK *a3)
{
  ASN1_VALUE *v5;
  int i;
  char *v7;
  char *v8;
  const char *v9;
  int v10;
  CONF_VALUE *v11;
  int *v12;

  v5 = ASN1_item_new(&ISSUING_DIST_POINT_it);
  if (!v5)
  {
    ERR_put_error(34, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_crld.c", 714);
    goto LABEL_21;
  }
  if (sk_num(a3) >= 1)
  {
    for (i = 0; i < sk_num(a3); ++i)
    {
      v7 = sk_value(a3, i);
      v9 = (const char *)*((_QWORD *)v7 + 1);
      v8 = (char *)*((_QWORD *)v7 + 2);
      v10 = set_dist_point_name((ASN1_VALUE **)v5, a2, (uint64_t)v7);
      if (v10 <= 0)
      {
        if (v10 < 0)
          goto LABEL_21;
        if (!strcmp(v9, "onlyuser"))
        {
          v11 = (CONF_VALUE *)v7;
          v12 = (int *)((char *)v5 + 8);
          goto LABEL_17;
        }
        if (!strcmp(v9, "onlyCA"))
        {
          v11 = (CONF_VALUE *)v7;
          v12 = (int *)((char *)v5 + 12);
          goto LABEL_17;
        }
        if (!strcmp(v9, "onlyAA"))
        {
          v11 = (CONF_VALUE *)v7;
          v12 = (int *)((char *)v5 + 28);
          goto LABEL_17;
        }
        if (!strcmp(v9, "indirectCRL"))
        {
          v11 = (CONF_VALUE *)v7;
          v12 = (int *)((char *)v5 + 24);
LABEL_17:
          if (!X509V3_get_value_BOOL(v11, v12))
            goto LABEL_21;
          continue;
        }
        if (strcmp(v9, "onlysomereasons"))
        {
          ERR_put_error(34, 4095, 106, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_crld.c", 706);
          ERR_asprintf_error_data("section:%s,name:%s,value:%s", *(const char **)v7, *((const char **)v7 + 1), *((const char **)v7 + 2));
LABEL_21:
          ASN1_item_free(v5, &ISSUING_DIST_POINT_it);
          return 0;
        }
        if (!set_reasons((ASN1_BIT_STRING **)v5 + 2, v8))
          goto LABEL_21;
      }
    }
  }
  return v5;
}

uint64_t i2r_idp(int a1, uint64_t a2, BIO *bio, int a4)
{
  uint64_t v7;
  ASN1_BIT_STRING *v8;

  v7 = *(_QWORD *)a2;
  if (v7)
    print_distpoint(bio, v7, a4);
  if (*(int *)(a2 + 8) >= 1)
    BIO_printf(bio, "%*sOnly User Certificates\n", a4, "");
  if (*(int *)(a2 + 12) >= 1)
    BIO_printf(bio, "%*sOnly CA Certificates\n", a4, "");
  if (*(int *)(a2 + 24) >= 1)
    BIO_printf(bio, "%*sIndirect CRL\n", a4, "");
  v8 = *(ASN1_BIT_STRING **)(a2 + 16);
  if (v8)
    print_reasons(bio, "Only Some Reasons", v8, a4);
  if (*(int *)(a2 + 28) >= 1)
    BIO_printf(bio, "%*sOnly Attribute Certificates\n", a4, "");
  if (!*(_QWORD *)a2
    && *(int *)(a2 + 8) <= 0
    && *(int *)(a2 + 12) <= 0
    && *(int *)(a2 + 24) <= 0
    && !*(_QWORD *)(a2 + 16)
    && *(int *)(a2 + 28) <= 0)
  {
    BIO_printf(bio, "%*s<EMPTY>\n", a4, "");
  }
  return 1;
}

uint64_t DIST_POINT_set_dpname(uint64_t a1, X509_NAME *xn)
{
  const STACK *v3;
  uint64_t result;
  int v5;
  char *v6;

  if (!a1)
    return 1;
  if (*(_DWORD *)a1 != 1)
    return 1;
  v3 = *(const STACK **)(a1 + 8);
  result = (uint64_t)X509_NAME_dup(xn);
  *(_QWORD *)(a1 + 16) = result;
  if (!result)
    return result;
  if (sk_num(v3) >= 1)
  {
    v5 = 0;
    do
    {
      v6 = sk_value(v3, v5);
      if (!X509_NAME_add_entry(*(X509_NAME **)(a1 + 16), (X509_NAME_ENTRY *)v6, -1, v5 == 0))
        goto LABEL_11;
    }
    while (++v5 < sk_num(v3));
  }
  if ((i2d_X509_NAME(*(X509_NAME **)(a1 + 16), 0) & 0x80000000) == 0)
    return 1;
LABEL_11:
  X509_NAME_free(*(X509_NAME **)(a1 + 16));
  result = 0;
  *(_QWORD *)(a1 + 16) = 0;
  return result;
}

uint64_t set_dist_point_name(ASN1_VALUE **a1, X509V3_CTX *a2, uint64_t a3)
{
  const char *v6;
  uint64_t result;
  GENERAL_NAMES *v8;
  STACK *entries;
  STACK *v10;
  X509_NAME *v11;
  X509_NAME *v12;
  STACK *section;
  STACK *v14;
  int v15;
  int v16;
  ASN1_VALUE *v17;
  ASN1_VALUE *v18;

  v6 = *(const char **)(a3 + 8);
  if (!strncmp(v6, "fullname", 9uLL))
  {
    v8 = gnames_from_sectname(a2, *(char **)(a3 + 16));
    entries = 0;
    v10 = 0;
    if (!v8)
    {
LABEL_15:
      sk_pop_free(v10, (void (__cdecl *)(void *))GENERAL_NAME_free);
      sk_pop_free(entries, (void (__cdecl *)(void *))X509_NAME_ENTRY_free);
      return 0xFFFFFFFFLL;
    }
  }
  else
  {
    if (strcmp(v6, "relativename"))
      return 0;
    v11 = X509_NAME_new();
    if (!v11)
      return 0xFFFFFFFFLL;
    v12 = v11;
    section = X509V3_get_section(a2, *(char **)(a3 + 16));
    if (!section)
    {
      ERR_put_error(34, 4095, 150, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_crld.c", 150);
      X509_NAME_free(v12);
      return 0xFFFFFFFFLL;
    }
    v14 = section;
    v15 = X509V3_NAME_from_section(v12, section, 0x1001uLL);
    X509V3_section_free(a2, v14);
    entries = v12->entries;
    v12->entries = 0;
    X509_NAME_free(v12);
    if (!v15 || sk_num(entries) < 1)
      goto LABEL_14;
    v16 = sk_num(entries);
    if (*((_DWORD *)sk_value(entries, v16 - 1) + 4))
    {
      ERR_put_error(34, 4095, 161, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_crld.c", 166);
LABEL_14:
      v10 = 0;
      goto LABEL_15;
    }
    v8 = 0;
  }
  if (*a1)
  {
    ERR_put_error(34, 4095, 160, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_crld.c", 173);
LABEL_7:
    v10 = v8;
    goto LABEL_15;
  }
  v17 = ASN1_item_new(&DIST_POINT_NAME_it);
  *a1 = v17;
  if (!v17)
    goto LABEL_7;
  v18 = v17;
  if (v8)
  {
    *(_DWORD *)v17 = 0;
    *((_QWORD *)v17 + 1) = v8;
    return 1;
  }
  else
  {
    result = 1;
    *(_DWORD *)v18 = 1;
    *((_QWORD *)v18 + 1) = entries;
  }
  return result;
}

uint64_t set_reasons(ASN1_BIT_STRING **a1, char *line)
{
  uint64_t v2;
  STACK *v4;
  STACK *v5;
  int v6;
  const char *v7;
  ASN1_BIT_STRING *v8;
  char **v9;
  char *v10;

  if (*a1)
    return 0;
  v4 = X509V3_parse_list(line);
  if (!v4)
    return 0;
  v5 = v4;
  if (sk_num(v4) < 1)
  {
LABEL_14:
    v2 = 1;
  }
  else
  {
    v6 = 0;
    while (1)
    {
      v7 = (const char *)*((_QWORD *)sk_value(v5, v6) + 1);
      v8 = *a1;
      if (!*a1)
      {
        v8 = ASN1_BIT_STRING_new();
        *a1 = v8;
        if (!v8)
          break;
      }
      v9 = off_24F899DE0;
      while (strcmp(*(v9 - 2), v7))
      {
        v10 = *v9;
        v9 += 3;
        if (!v10)
          goto LABEL_15;
      }
      if (!ASN1_BIT_STRING_set_bit(v8, *((_DWORD *)v9 - 8), 1))
        break;
      if (++v6 >= sk_num(v5))
        goto LABEL_14;
    }
LABEL_15:
    v2 = 0;
  }
  sk_pop_free(v5, (void (__cdecl *)(void *))X509V3_conf_free);
  return v2;
}

GENERAL_NAMES *gnames_from_sectname(X509V3_CTX *ctx, char *line)
{
  STACK *section;
  STACK *v5;
  GENERAL_NAMES *v6;

  if (*line == 64)
    section = X509V3_get_section(ctx, line + 1);
  else
    section = X509V3_parse_list(line);
  v5 = section;
  if (section)
  {
    v6 = v2i_GENERAL_NAMES(0, ctx, section);
    if (*line == 64)
      X509V3_section_free(ctx, v5);
    else
      sk_pop_free(v5, (void (__cdecl *)(void *))X509V3_conf_free);
  }
  else
  {
    ERR_put_error(34, 4095, 150, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_crld.c", 120);
    return 0;
  }
  return v6;
}

uint64_t dpn_cb(int a1, uint64_t *a2)
{
  uint64_t v2;
  X509_NAME *v3;

  v2 = *a2;
  if (a1 == 3)
  {
    v3 = *(X509_NAME **)(v2 + 16);
    if (v3)
      X509_NAME_free(v3);
  }
  else if (a1 == 1)
  {
    *(_QWORD *)(v2 + 16) = 0;
  }
  return 1;
}

uint64_t print_distpoint(BIO *bio, uint64_t a2, int a3)
{
  _BYTE nm[40];

  if (*(_DWORD *)a2)
  {
    memset(&nm[8], 0, 32);
    *(_QWORD *)nm = *(_QWORD *)(a2 + 8);
    BIO_printf(bio, "%*sRelative Name:\n%*s", a3, "", a3 + 2, "");
    X509_NAME_print_ex(bio, (X509_NAME *)nm, 0, 0x82031FuLL);
    return BIO_puts(bio, "\n");
  }
  else
  {
    BIO_printf(bio, "%*sFull Name:\n", a3, "");
    return print_gens(bio, *(STACK **)(a2 + 8), a3);
  }
}

uint64_t print_reasons(BIO *a1, const char *a2, ASN1_BIT_STRING *a3, int a4)
{
  char v6;
  int *v7;
  const char *v8;
  int i;
  int v10;
  const char *v11;

  BIO_printf(a1, "%*s%s:\n%*s", a4, "", a2, a4 + 2, "");
  v6 = 0;
  v7 = &reason_flags;
  v8 = "Unused";
LABEL_2:
  for (i = *v7; ; i = v10)
  {
    if (ASN1_BIT_STRING_get_bit(a3, i))
    {
      if ((v6 & 1) != 0)
        BIO_puts(a1, ", ");
      BIO_puts(a1, v8);
      v8 = (const char *)*((_QWORD *)v7 + 4);
      v7 += 6;
      v6 = 1;
      if (!v8)
        goto LABEL_11;
      goto LABEL_2;
    }
    v8 = (const char *)*((_QWORD *)v7 + 4);
    if (!v8)
      break;
    v10 = v7[6];
    v7 += 6;
  }
  if ((v6 & 1) != 0)
  {
LABEL_11:
    v11 = "\n";
    return BIO_puts(a1, v11);
  }
  v11 = "<EMPTY>\n";
  return BIO_puts(a1, v11);
}

uint64_t print_gens(BIO *a1, STACK *a2, int a3)
{
  uint64_t result;
  int v7;
  char *v8;

  result = sk_num(a2);
  if ((int)result >= 1)
  {
    v7 = 0;
    do
    {
      BIO_printf(a1, "%*s", a3 + 2, "");
      v8 = sk_value(a2, v7);
      GENERAL_NAME_print(a1, (GENERAL_NAME *)v8);
      BIO_puts(a1, "\n");
      ++v7;
      result = sk_num(a2);
    }
    while (v7 < (int)result);
  }
  return result;
}

void ASN1_item_free(ASN1_VALUE *val, const ASN1_ITEM *it)
{
  ASN1_VALUE *pval;

  pval = val;
  asn1_item_free(&pval, (ASN1_ITEM *)it);
}

void asn1_item_free(ASN1_VALUE **pval, ASN1_ITEM *it)
{
  _QWORD *funcs;
  unsigned int (*v5)(uint64_t, ASN1_VALUE **, ASN1_ITEM *, _QWORD);
  uint64_t tcount;
  uint64_t v7;
  const ASN1_TEMPLATE *v8;
  const ASN1_TEMPLATE *v9;
  const ASN1_TEMPLATE *v10;
  ASN1_VALUE **field_ptr;
  const ASN1_TEMPLATE *templates;
  unsigned int choice_selector;
  const ASN1_TEMPLATE *v14;
  ASN1_VALUE **v15;
  void (*v16)(ASN1_VALUE **, ASN1_ITEM *);

  if (pval)
  {
    funcs = it->funcs;
    if (!it->itype || *pval)
    {
      if (funcs)
        v5 = (unsigned int (*)(uint64_t, ASN1_VALUE **, ASN1_ITEM *, _QWORD))funcs[3];
      else
        v5 = 0;
      switch(it->itype)
      {
        case 0:
          templates = it->templates;
          if (!templates)
            goto LABEL_19;
          ASN1_template_free(pval, templates);
          break;
        case 1:
        case 6:
          if (asn1_do_lock(pval, -1, it) <= 0 && (!v5 || v5(2, pval, it, 0) != 2))
          {
            asn1_enc_cleanup(pval, (uint64_t)it);
            tcount = it->tcount;
            if (tcount >= 1)
            {
              v7 = 0;
              v8 = &it->templates[tcount - 1];
              do
              {
                v9 = asn1_do_adb(pval, v8, 0);
                if (v9)
                {
                  v10 = v9;
                  field_ptr = asn1_get_field_ptr(pval, v9);
                  ASN1_template_free(field_ptr, v10);
                }
                ++v7;
                --v8;
              }
              while (it->tcount > v7);
            }
            goto LABEL_25;
          }
          break;
        case 2:
          if (!v5 || v5(2, pval, it, 0) != 2)
          {
            choice_selector = asn1_get_choice_selector(pval, it);
            if ((choice_selector & 0x80000000) == 0 && it->tcount > choice_selector)
            {
              v14 = &it->templates[choice_selector];
              v15 = asn1_get_field_ptr(pval, v14);
              ASN1_template_free(v15, v14);
            }
LABEL_25:
            if (v5)
              v5(3, pval, it, 0);
            free(*pval);
            *pval = 0;
          }
          break;
        case 4:
          if (funcs)
          {
            v16 = (void (*)(ASN1_VALUE **, ASN1_ITEM *))funcs[2];
            if (v16)
              v16(pval, it);
          }
          break;
        case 5:
LABEL_19:
          ASN1_primitive_free(pval, it);
          break;
        default:
          return;
      }
    }
  }
}

void ASN1_template_free(ASN1_VALUE **pval, const ASN1_TEMPLATE *tt)
{
  STACK *v4;
  int v5;
  ASN1_VALUE *pvala;

  if ((tt->flags & 6) != 0)
  {
    v4 = (STACK *)*pval;
    if (sk_num((const STACK *)*pval) >= 1)
    {
      v5 = 0;
      do
      {
        pvala = 0;
        pvala = (ASN1_VALUE *)sk_value(v4, v5);
        asn1_item_free(&pvala, tt->item);
        ++v5;
      }
      while (v5 < sk_num(v4));
    }
    sk_free(v4);
    *pval = 0;
  }
  else
  {
    asn1_item_free(pval, tt->item);
  }
}

void ASN1_primitive_free(ASN1_VALUE **pval, const ASN1_ITEM *it)
{
  ASN1_VALUE **v2;
  void (**funcs)(ASN1_VALUE **);
  ASN1_VALUE *v4;
  ASN1_VALUE *v5;
  int utype;
  int size;

  v2 = pval;
  if (!it)
  {
    v4 = *pval;
    v2 = (ASN1_VALUE **)((char *)*pval + 8);
    v5 = *v2;
    if (!*v2)
      return;
    utype = *(_DWORD *)v4;
    goto LABEL_6;
  }
  funcs = (void (**)(ASN1_VALUE **))it->funcs;
  if (funcs)
  {
    funcs[3](pval);
    return;
  }
  if (it->itype == 5)
  {
    v5 = *pval;
    if (!*v2)
      return;
    goto LABEL_17;
  }
  utype = it->utype;
  if (utype == 1)
    goto LABEL_19;
  v5 = *pval;
  if (*v2)
  {
LABEL_6:
    if (utype > 4)
    {
      if (utype != 5)
      {
        if (utype != 6)
        {
LABEL_17:
          ASN1_STRING_free((ASN1_STRING *)v5);
          goto LABEL_24;
        }
        ASN1_OBJECT_free((ASN1_OBJECT *)v5);
      }
LABEL_24:
      *v2 = 0;
      return;
    }
    if (utype == -4)
    {
      ASN1_primitive_free(v2, 0);
      free(*v2);
      goto LABEL_24;
    }
    if (utype != 1)
      goto LABEL_17;
    if (!it)
    {
      size = -1;
LABEL_20:
      *(_DWORD *)v2 = size;
      return;
    }
LABEL_19:
    size = it->size;
    goto LABEL_20;
  }
}

DH *__cdecl d2i_DHparams(DH **a, const unsigned __int8 **pp, uint64_t length)
{
  return (DH *)ASN1_item_d2i((ASN1_VALUE **)a, pp, length, &DHparams_it);
}

int i2d_DHparams(const DH *a, unsigned __int8 **pp)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, pp, &DHparams_it);
}

void *d2i_DHparams_bio(BIO *in, void *x)
{
  return ASN1_item_d2i_bio(&DHparams_it, in, x);
}

uint64_t i2d_DHparams_bio(BIO *out, void *x)
{
  return ASN1_item_i2d_bio(&DHparams_it, out, x);
}

void *d2i_DHparams_fp(FILE *in, void *x)
{
  return ASN1_item_d2i_fp(&DHparams_it, in, x);
}

uint64_t i2d_DHparams_fp(FILE *out, void *x)
{
  return ASN1_item_i2d_fp(&DHparams_it, out, x);
}

void *DHparams_dup(void *x)
{
  return ASN1_item_dup(&DHparams_it, x);
}

uint64_t dh_cb(int a1, DH **a2)
{
  DH *v3;

  if (a1 == 2)
  {
    DH_free(*a2);
    *a2 = 0;
    return 2;
  }
  else if (a1)
  {
    return 1;
  }
  else
  {
    v3 = DH_new();
    *a2 = v3;
    return 2 * (v3 != 0);
  }
}

int X509at_get_attr_by_NID(const STACK *x, int nid, int lastpos)
{
  ASN1_OBJECT *v5;

  v5 = OBJ_nid2obj(nid);
  if (v5)
    return X509at_get_attr_by_OBJ(x, v5, lastpos);
  else
    return -2;
}

int X509at_get_attr_by_OBJ(const STACK *sk, ASN1_OBJECT *obj, int lastpos)
{
  int v5;
  int v6;
  char *v7;

  if (sk)
  {
    if (lastpos < 0)
      v5 = -1;
    else
      v5 = lastpos;
    v6 = sk_num(sk);
    while (++v5 < v6)
    {
      v7 = sk_value(sk, v5);
      if (!OBJ_cmp(*(const ASN1_OBJECT **)v7, obj))
        return v5;
    }
  }
  return -1;
}

X509_ATTRIBUTE *__cdecl X509at_get_attr(const STACK *x, int loc)
{
  int v4;

  if (!x)
    return 0;
  v4 = sk_num(x);
  if (loc < 0 || v4 <= loc)
    return 0;
  else
    return (X509_ATTRIBUTE *)sk_value(x, loc);
}

X509_ATTRIBUTE *__cdecl X509at_delete_attr(STACK *x, int loc)
{
  int v4;

  if (!x)
    return 0;
  v4 = sk_num(x);
  if (loc < 0 || v4 <= loc)
    return 0;
  else
    return (X509_ATTRIBUTE *)sk_delete(x, loc);
}

STACK *__cdecl X509at_add1_attr(STACK **x, X509_ATTRIBUTE *attr)
{
  STACK *v4;
  char *v5;
  X509_ATTRIBUTE *v6;

  if (!x)
  {
    ERR_put_error(11, 4095, 67, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_att.c", 141);
    return 0;
  }
  v4 = *x;
  if (!*x)
  {
    v4 = sk_new_null();
    if (!v4)
    {
      ERR_put_error(11, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_att.c", 160);
      return v4;
    }
  }
  v5 = (char *)X509_ATTRIBUTE_dup(attr);
  if (!v5)
  {
LABEL_10:
    if (v4 != *x)
      sk_free(v4);
    return 0;
  }
  v6 = (X509_ATTRIBUTE *)v5;
  if (!sk_push(v4, v5))
  {
    ERR_put_error(11, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_att.c", 160);
    X509_ATTRIBUTE_free(v6);
    goto LABEL_10;
  }
  if (!*x)
    *x = v4;
  return v4;
}

STACK *__cdecl X509at_add1_attr_by_OBJ(STACK **x, const ASN1_OBJECT *obj, int type, const unsigned __int8 *bytes, int len)
{
  STACK *result;
  STACK *v7;
  STACK *v8;

  result = (STACK *)X509_ATTRIBUTE_create_by_OBJ(0, obj, type, bytes, len);
  if (result)
  {
    v7 = result;
    v8 = X509at_add1_attr(x, (X509_ATTRIBUTE *)result);
    X509_ATTRIBUTE_free((X509_ATTRIBUTE *)v7);
    return v8;
  }
  return result;
}

X509_ATTRIBUTE *__cdecl X509_ATTRIBUTE_create_by_OBJ(X509_ATTRIBUTE **attr, const ASN1_OBJECT *obj, int atrtype, const void *data, int len)
{
  X509_ATTRIBUTE *v10;

  if (attr && (v10 = *attr) != 0 || (v10 = X509_ATTRIBUTE_new()) != 0)
  {
    if (X509_ATTRIBUTE_set1_object(v10, obj) && X509_ATTRIBUTE_set1_data(v10, atrtype, data, len))
    {
      if (attr && !*attr)
        *attr = v10;
    }
    else
    {
      if (!attr || v10 != *attr)
        X509_ATTRIBUTE_free(v10);
      return 0;
    }
  }
  else
  {
    ERR_put_error(11, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_att.c", 264);
  }
  return v10;
}

STACK *__cdecl X509at_add1_attr_by_NID(STACK **x, int nid, int type, const unsigned __int8 *bytes, int len)
{
  STACK *result;
  STACK *v7;
  STACK *v8;

  result = (STACK *)X509_ATTRIBUTE_create_by_NID(0, nid, type, bytes, len);
  if (result)
  {
    v7 = result;
    v8 = X509at_add1_attr(x, (X509_ATTRIBUTE *)result);
    X509_ATTRIBUTE_free((X509_ATTRIBUTE *)v7);
    return v8;
  }
  return result;
}

X509_ATTRIBUTE *__cdecl X509_ATTRIBUTE_create_by_NID(X509_ATTRIBUTE **attr, int nid, int atrtype, const void *data, int len)
{
  ASN1_OBJECT *v9;
  ASN1_OBJECT *v10;
  X509_ATTRIBUTE *result;

  v9 = OBJ_nid2obj(nid);
  if (v9)
  {
    v10 = v9;
    result = X509_ATTRIBUTE_create_by_OBJ(attr, v9, atrtype, data, len);
    if (result)
      return result;
    ASN1_OBJECT_free(v10);
  }
  else
  {
    ERR_put_error(11, 4095, 109, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_att.c", 246);
  }
  return 0;
}

STACK *__cdecl X509at_add1_attr_by_txt(STACK **x, const char *attrname, int type, const unsigned __int8 *bytes, int len)
{
  STACK *result;
  STACK *v7;
  STACK *v8;

  result = (STACK *)X509_ATTRIBUTE_create_by_txt(0, attrname, type, bytes, len);
  if (result)
  {
    v7 = result;
    v8 = X509at_add1_attr(x, (X509_ATTRIBUTE *)result);
    X509_ATTRIBUTE_free((X509_ATTRIBUTE *)v7);
    return v8;
  }
  return result;
}

X509_ATTRIBUTE *__cdecl X509_ATTRIBUTE_create_by_txt(X509_ATTRIBUTE **attr, const char *atrname, int type, const unsigned __int8 *bytes, int len)
{
  ASN1_OBJECT *v10;
  ASN1_OBJECT *v11;
  X509_ATTRIBUTE *v12;

  v10 = OBJ_txt2obj(atrname, 0);
  if (v10)
  {
    v11 = v10;
    v12 = X509_ATTRIBUTE_create_by_OBJ(attr, v10, type, bytes, len);
    ASN1_OBJECT_free(v11);
    return v12;
  }
  else
  {
    ERR_put_error(11, 4095, 119, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_att.c", 295);
    ERR_asprintf_error_data("name=%s", atrname);
    return 0;
  }
}

void *__cdecl X509at_get0_data_by_OBJ(STACK *x, ASN1_OBJECT *obj, int lastpos, int type)
{
  int attr_by_OBJ;
  int v9;
  void *v11;
  X509_ATTRIBUTE *v12;
  X509_ATTRIBUTE *attr;

  attr_by_OBJ = X509at_get_attr_by_OBJ(x, obj, lastpos);
  if (attr_by_OBJ == -1)
    return 0;
  v9 = attr_by_OBJ;
  if (lastpos < -1)
  {
    if (X509at_get_attr_by_OBJ(x, obj, attr_by_OBJ) == -1)
    {
      attr = X509at_get_attr(x, v9);
      v12 = attr;
      if (lastpos > 0xFFFFFFFD || attr && sk_num(*(const STACK **)&attr->single) == 1)
        return X509_ATTRIBUTE_get0_data(v12, 0, type, v11);
    }
    return 0;
  }
  v12 = X509at_get_attr(x, attr_by_OBJ);
  return X509_ATTRIBUTE_get0_data(v12, 0, type, v11);
}

int X509_ATTRIBUTE_count(X509_ATTRIBUTE *attr)
{
  if (attr)
    LODWORD(attr) = sk_num(*(const STACK **)&attr->single);
  return (int)attr;
}

void *__cdecl X509_ATTRIBUTE_get0_data(void *attr, int idx, int atrtype, void *data)
{
  void *v5;

  if (attr)
  {
    attr = sk_value(*((const STACK **)attr + 1), idx);
    if (attr)
    {
      v5 = attr;
      if (ASN1_TYPE_get((ASN1_TYPE *)attr) == atrtype)
      {
        return (void *)*((_QWORD *)v5 + 1);
      }
      else
      {
        ERR_put_error(11, 4095, 122, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_att.c", 398);
        return 0;
      }
    }
  }
  return attr;
}

int X509_ATTRIBUTE_set1_object(X509_ATTRIBUTE *attr, const ASN1_OBJECT *obj)
{
  int result;
  ASN1_OBJECT *v5;

  result = 0;
  if (attr)
  {
    if (obj)
    {
      ASN1_OBJECT_free(attr->object);
      v5 = OBJ_dup(obj);
      attr->object = v5;
      return v5 != 0;
    }
  }
  return result;
}

int X509_ATTRIBUTE_set1_data(X509_ATTRIBUTE *attr, int attrtype, const void *data, int len)
{
  X509_ATTRIBUTE *v7;
  int v8;
  ASN1_STRING *v9;
  ASN1_STRING *v10;
  int type;
  ASN1_STRING *v12;
  char *v13;
  int v14;
  int v15;
  ASN1_TYPE *v16;

  if (attr)
  {
    v7 = attr;
    if ((attrtype & 0x1000) != 0)
    {
      v8 = OBJ_obj2nid(attr->object);
      v9 = ASN1_STRING_set_by_NID(0, (const unsigned __int8 *)data, len, attrtype, v8);
      if (!v9)
      {
        v14 = 13;
        v15 = 330;
LABEL_22:
        ERR_put_error(11, 4095, v14, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_att.c", v15);
        LODWORD(attr) = 0;
        return (int)attr;
      }
      v10 = v9;
      type = v9->type;
      goto LABEL_13;
    }
    if (len == -1)
    {
      v10 = 0;
      type = 0;
      if (!attrtype)
        goto LABEL_9;
    }
    else
    {
      v12 = ASN1_STRING_type_new(attrtype);
      v10 = v12;
      if (!v12 || !ASN1_STRING_set(v12, data, len))
      {
        v13 = 0;
        goto LABEL_21;
      }
      type = attrtype;
      if (!attrtype)
      {
LABEL_9:
        ASN1_STRING_free(v10);
LABEL_20:
        LODWORD(attr) = 1;
        return (int)attr;
      }
    }
LABEL_13:
    v16 = ASN1_TYPE_new();
    v13 = (char *)v16;
    if (v16)
    {
      if ((attrtype & 0x1000) != 0 || len != -1)
      {
        ASN1_TYPE_set(v16, type, v10);
      }
      else if (!ASN1_TYPE_set1(v16, attrtype, data))
      {
        goto LABEL_21;
      }
      if (sk_push(*(STACK **)&v7->single, v13))
        goto LABEL_20;
    }
LABEL_21:
    ASN1_TYPE_free((ASN1_TYPE *)v13);
    ASN1_STRING_free(v10);
    v14 = 65;
    v15 = 365;
    goto LABEL_22;
  }
  return (int)attr;
}

ASN1_OBJECT *__cdecl X509_ATTRIBUTE_get0_object(ASN1_OBJECT *attr)
{
  if (attr)
    return (ASN1_OBJECT *)attr->sn;
  return attr;
}

ASN1_TYPE *__cdecl X509_ATTRIBUTE_get0_type(ASN1_TYPE *attr, int idx)
{
  if (attr)
    return (ASN1_TYPE *)sk_value((const STACK *)attr->value.ptr, idx);
  return attr;
}

int EVP_CipherInit(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *cipher, const unsigned __int8 *key, const unsigned __int8 *iv, int enc)
{
  if (cipher)
  {
    *(_QWORD *)&ctx->final[24] = 0;
    *(_OWORD *)&ctx->final_used = 0u;
    *(_OWORD *)&ctx->final[8] = 0u;
    *(_OWORD *)&ctx->app_data = 0u;
    *(_OWORD *)&ctx->flags = 0u;
    *(_OWORD *)&ctx->buf[8] = 0u;
    *(_OWORD *)&ctx->buf[24] = 0u;
    *(_OWORD *)&ctx->oiv[8] = 0u;
    *(_OWORD *)&ctx->iv[8] = 0u;
    *(_OWORD *)&ctx->cipher = 0u;
    *(_OWORD *)&ctx->encrypt = 0u;
  }
  return EVP_CipherInit_ex(ctx, cipher, 0, key, iv, enc);
}

void EVP_CIPHER_CTX_init(EVP_CIPHER_CTX *a)
{
  *(_QWORD *)&a->final[24] = 0;
  *(_OWORD *)&a->final_used = 0u;
  *(_OWORD *)&a->final[8] = 0u;
  *(_OWORD *)&a->app_data = 0u;
  *(_OWORD *)&a->flags = 0u;
  *(_OWORD *)&a->buf[8] = 0u;
  *(_OWORD *)&a->buf[24] = 0u;
  *(_OWORD *)&a->oiv[8] = 0u;
  *(_OWORD *)&a->iv[8] = 0u;
  *(_OWORD *)&a->cipher = 0u;
  *(_OWORD *)&a->encrypt = 0u;
}

int EVP_CipherInit_ex(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *cipher, ENGINE *impl, const unsigned __int8 *key, const unsigned __int8 *iv, int enc)
{
  const EVP_CIPHER *v9;
  uint64_t encrypt;
  const EVP_CIPHER *v12;
  unint64_t flags;
  int v14;
  int v15;
  size_t ctx_size;
  void *v17;
  unsigned int block_size;
  BOOL v19;
  int v20;
  int result;
  int v23;
  size_t v24;
  unsigned __int8 *v25;
  const void *oiv;
  const EVP_CIPHER *v27;
  int v28;

  v9 = cipher;
  if (enc == -1)
  {
    encrypt = ctx->encrypt;
  }
  else
  {
    encrypt = enc != 0;
    ctx->encrypt = encrypt;
  }
  v12 = ctx->cipher;
  if (!ctx->engine)
  {
    if (cipher)
    {
      if (!v12)
        goto LABEL_13;
      goto LABEL_11;
    }
    if (v12)
      goto LABEL_28;
LABEL_22:
    v14 = 131;
    v15 = 163;
    goto LABEL_43;
  }
  if (v12)
  {
    if (!cipher || cipher->nid == v12->nid)
      goto LABEL_28;
LABEL_11:
    flags = ctx->flags;
    EVP_CIPHER_CTX_cleanup(ctx);
    ctx->encrypt = encrypt;
    ctx->flags = flags;
    goto LABEL_13;
  }
  if (!cipher)
    goto LABEL_22;
LABEL_13:
  if (impl)
  {
    if (!ENGINE_init(impl))
    {
      v14 = 134;
      v15 = 120;
      goto LABEL_43;
    }
  }
  else
  {
    impl = ENGINE_get_cipher_engine(v9->nid);
    if (!impl)
      goto LABEL_18;
  }
  v9 = ENGINE_get_cipher(impl, v9->nid);
  if (!v9)
  {
    v14 = 134;
    v15 = 131;
    goto LABEL_43;
  }
LABEL_18:
  ctx->cipher = v9;
  ctx->engine = impl;
  ctx_size = v9->ctx_size;
  if ((_DWORD)ctx_size)
  {
    v17 = malloc_type_calloc(1uLL, ctx_size, 0xDC090842uLL);
    ctx->cipher_data = v17;
    if (!v17)
    {
      v14 = 65;
      v15 = 148;
      goto LABEL_43;
    }
    v12 = ctx->cipher;
  }
  else
  {
    ctx->cipher_data = 0;
    v12 = v9;
  }
  ctx->key_len = v9->key_len;
  ctx->flags &= 1uLL;
  if ((v12->flags & 0x40) != 0)
  {
    if (!EVP_CIPHER_CTX_ctrl(ctx, 0, 0, 0))
    {
      v14 = 134;
      v15 = 158;
      goto LABEL_43;
    }
    v12 = ctx->cipher;
  }
LABEL_28:
  block_size = v12->block_size;
  v19 = block_size > 0x10;
  v20 = (1 << block_size) & 0x10102;
  if (v19 || v20 == 0)
  {
    v14 = 136;
    v15 = 173;
  }
  else
  {
    if ((ctx->flags & 1) != 0 || (EVP_CIPHER_CTX_flags(ctx) & 0xF0007) != 0x10002)
    {
      if ((EVP_CIPHER_CTX_flags(ctx) & 0x10) == 0)
      {
        switch(EVP_CIPHER_CTX_flags(ctx) & 0xF0007)
        {
          case 0uLL:
          case 1uLL:
            break;
          case 2uLL:
            goto LABEL_38;
          case 3uLL:
          case 4uLL:
            ctx->num = 0;
LABEL_38:
            if (EVP_CIPHER_CTX_iv_length(ctx) >= 0x11)
            {
              v14 = 102;
              v15 = 200;
              goto LABEL_43;
            }
            if (iv)
            {
              v23 = EVP_CIPHER_CTX_iv_length(ctx);
              memcpy(ctx->oiv, iv, v23);
            }
            v24 = EVP_CIPHER_CTX_iv_length(ctx);
            v25 = ctx->iv;
            oiv = ctx->oiv;
LABEL_51:
            memcpy(v25, oiv, v24);
            break;
          case 5uLL:
            ctx->num = 0;
            if (!iv)
              break;
            v24 = EVP_CIPHER_CTX_iv_length(ctx);
            v25 = ctx->iv;
            oiv = iv;
            goto LABEL_51;
          default:
            return 0;
        }
      }
      v27 = ctx->cipher;
      if (key || (v27->flags & 0x20) != 0)
      {
        result = ((uint64_t (*)(EVP_CIPHER_CTX *, const unsigned __int8 *, const unsigned __int8 *, uint64_t))v27->init)(ctx, key, iv, encrypt);
        if (!result)
          return result;
        v27 = ctx->cipher;
      }
      ctx->buf_len = 0;
      v28 = v27->block_size - 1;
      ctx->final_used = 0;
      ctx->block_mask = v28;
      return 1;
    }
    v14 = 170;
    v15 = 179;
  }
LABEL_43:
  ERR_put_error(6, 4095, v14, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/evp_enc.c", v15);
  return 0;
}

int EVP_CIPHER_CTX_cleanup(EVP_CIPHER_CTX *a)
{
  int (__cdecl *cleanup)(EVP_CIPHER_CTX *);
  void *cipher_data;

  if (a->cipher)
  {
    cleanup = a->cipher->cleanup;
    if (cleanup)
      ((void (*)(EVP_CIPHER_CTX *))cleanup)(a);
    cipher_data = a->cipher_data;
    if (cipher_data)
      explicit_bzero(cipher_data, a->cipher->ctx_size);
  }
  free(a->cipher_data);
  ENGINE_finish(a->engine);
  explicit_bzero(a, 0xA8uLL);
  return 1;
}

int EVP_CIPHER_CTX_ctrl(EVP_CIPHER_CTX *ctx, int type, int arg, void *ptr)
{
  uint64_t (*ctrl)(void);
  int result;
  int v6;
  int v7;

  if (ctx->cipher)
  {
    ctrl = (uint64_t (*)(void))ctx->cipher->ctrl;
    if (ctrl)
    {
      result = ctrl();
      if (result != -1)
        return result;
      v6 = 133;
      v7 = 666;
    }
    else
    {
      v6 = 132;
      v7 = 660;
    }
  }
  else
  {
    v6 = 131;
    v7 = 655;
  }
  ERR_put_error(6, 4095, v6, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/evp_enc.c", v7);
  return 0;
}

int EVP_CipherUpdate(EVP_CIPHER_CTX *ctx, unsigned __int8 *out, int *outl, const unsigned __int8 *in, int inl)
{
  if (ctx->encrypt)
    return EVP_EncryptUpdate(ctx, out, outl, in, inl);
  else
    return EVP_DecryptUpdate(ctx, out, outl, in, inl);
}

int EVP_EncryptUpdate(EVP_CIPHER_CTX *ctx, unsigned __int8 *out, int *outl, const unsigned __int8 *in, int inl)
{
  unsigned int v5;
  const EVP_CIPHER *cipher;
  uint64_t buf_len;
  unsigned int block_size;
  int v13;
  unsigned int v14;
  int v15;
  int result;
  int v17;
  uint64_t v18;
  int v19;
  uint64_t v20;

  *outl = 0;
  if (inl < 0)
    return 0;
  v5 = inl;
  if (!inl && (EVP_CIPHER_flags(ctx->cipher) & 0xF0007) != 7)
    return 1;
  cipher = ctx->cipher;
  if ((ctx->cipher->flags & 0x100000) != 0)
  {
    v15 = ((uint64_t (*)(EVP_CIPHER_CTX *, unsigned __int8 *, const unsigned __int8 *, _QWORD))cipher->do_cipher)(ctx, out, in, v5);
    if ((v15 & 0x80000000) == 0)
    {
      *outl = v15;
      return 1;
    }
    return 0;
  }
  buf_len = ctx->buf_len;
  if (!(_DWORD)buf_len)
  {
    if ((ctx->block_mask & v5) == 0)
    {
      result = ((uint64_t (*)(EVP_CIPHER_CTX *, unsigned __int8 *, const unsigned __int8 *, _QWORD))cipher->do_cipher)(ctx, out, in, v5);
      if (result)
      {
        *outl = v5;
        return 1;
      }
      goto LABEL_15;
    }
    block_size = cipher->block_size;
    if (block_size <= 0x20)
    {
      v17 = 0;
      goto LABEL_25;
    }
LABEL_14:
    ERR_put_error(6, 4095, 136, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/evp_enc.c", 330);
    result = 0;
LABEL_15:
    *outl = 0;
    return result;
  }
  block_size = cipher->block_size;
  if (block_size >= 0x21)
    goto LABEL_14;
  v13 = block_size - buf_len;
  v14 = v5 - (block_size - buf_len);
  if ((int)v5 < (int)(block_size - buf_len))
  {
    memcpy(&ctx->buf[buf_len], in, v5);
    ctx->buf_len += v5;
    *outl = 0;
    return 1;
  }
  if ((int)(v14 & -block_size) > (int)(block_size ^ 0x7FFFFFFF))
  {
    ERR_put_error(6, 4095, 164, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/evp_enc.c", 350);
    return 0;
  }
  v18 = v13;
  memcpy(&ctx->buf[buf_len], in, v13);
  result = ((uint64_t (*)(EVP_CIPHER_CTX *, unsigned __int8 *, unsigned __int8 *, _QWORD))ctx->cipher->do_cipher)(ctx, out, ctx->buf, (int)block_size);
  if (!result)
    return result;
  in += v18;
  out += (int)block_size;
  v17 = block_size;
  v5 = v14;
LABEL_25:
  *outl = v17;
  v19 = v5 & (block_size - 1);
  v20 = v5 - v19;
  if ((int)v20 < 1)
  {
LABEL_28:
    if (v19)
      memcpy(ctx->buf, &in[(int)v20], v19);
    ctx->buf_len = v19;
    return 1;
  }
  result = ((uint64_t (*)(EVP_CIPHER_CTX *, unsigned __int8 *, const unsigned __int8 *, uint64_t))ctx->cipher->do_cipher)(ctx, out, in, v20);
  if (result)
  {
    *outl += v20;
    goto LABEL_28;
  }
  return result;
}

int EVP_DecryptUpdate(EVP_CIPHER_CTX *ctx, unsigned __int8 *out, int *outl, const unsigned __int8 *in, int inl)
{
  const EVP_CIPHER *cipher;
  size_t block_size;
  int v12;
  int v13;
  int v14;
  int result;
  int final_used;

  *outl = 0;
  if (inl < 0)
    return 0;
  if (!inl && (EVP_CIPHER_flags(ctx->cipher) & 0xF0007) != 7)
    return 1;
  cipher = ctx->cipher;
  if ((ctx->cipher->flags & 0x100000) != 0)
  {
    v14 = ((uint64_t (*)(EVP_CIPHER_CTX *, unsigned __int8 *, const unsigned __int8 *, _QWORD))cipher->do_cipher)(ctx, out, in, inl);
    if (v14 < 0)
    {
      result = 0;
      *outl = 0;
      return result;
    }
    *outl = v14;
    return 1;
  }
  if ((ctx->flags & 0x100) != 0)
    return EVP_EncryptUpdate(ctx, out, outl, in, inl);
  block_size = cipher->block_size;
  if (block_size >= 0x21)
  {
    v12 = 136;
    v13 = 465;
LABEL_16:
    ERR_put_error(6, 4095, v12, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/evp_enc.c", v13);
    return 0;
  }
  final_used = ctx->final_used;
  if (final_used)
  {
    if ((-(int)block_size & inl) > (block_size ^ 0x7FFFFFFF))
    {
      v12 = 164;
      v13 = 477;
      goto LABEL_16;
    }
    memcpy(out, ctx->final, block_size);
    out += block_size;
  }
  result = EVP_EncryptUpdate(ctx, out, outl, in, inl);
  if (result)
  {
    if (block_size < 2 || ctx->buf_len)
    {
      ctx->final_used = 0;
    }
    else
    {
      *outl -= block_size;
      ctx->final_used = 1;
      memcpy(ctx->final, &out[*outl], block_size);
    }
    if (final_used)
      *outl += block_size;
    return 1;
  }
  return result;
}

int EVP_CipherFinal_ex(EVP_CIPHER_CTX *ctx, unsigned __int8 *outm, int *outl)
{
  if (ctx->encrypt)
    return EVP_EncryptFinal_ex(ctx, outm, outl);
  else
    return EVP_DecryptFinal_ex(ctx, outm, outl);
}

int EVP_EncryptFinal_ex(EVP_CIPHER_CTX *ctx, unsigned __int8 *out, int *outl)
{
  const EVP_CIPHER *cipher;
  uint64_t block_size;
  int v8;
  int v9;
  int v10;
  int result;
  uint64_t buf_len;

  cipher = ctx->cipher;
  if ((ctx->cipher->flags & 0x100000) != 0)
  {
    v10 = ((uint64_t (*)(EVP_CIPHER_CTX *, unsigned __int8 *, _QWORD, _QWORD))cipher->do_cipher)(ctx, out, 0, 0);
    if (v10 < 0)
      return 0;
    *outl = v10;
    return 1;
  }
  block_size = cipher->block_size;
  if (block_size >= 0x21)
  {
    v8 = 136;
    v9 = 406;
LABEL_4:
    ERR_put_error(6, 4095, v8, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/evp_enc.c", v9);
    return 0;
  }
  if ((_DWORD)block_size == 1)
  {
LABEL_9:
    *outl = 0;
    return 1;
  }
  buf_len = ctx->buf_len;
  if ((ctx->flags & 0x100) != 0)
  {
    if ((_DWORD)buf_len)
    {
      v8 = 138;
      v9 = 416;
      goto LABEL_4;
    }
    goto LABEL_9;
  }
  if (block_size > buf_len)
    memset(&ctx->buf[buf_len], block_size - buf_len, (block_size + ~(_DWORD)buf_len) + 1);
  result = ((uint64_t (*)(EVP_CIPHER_CTX *, unsigned __int8 *, unsigned __int8 *, uint64_t))cipher->do_cipher)(ctx, out, ctx->buf, block_size);
  if (result)
    *outl = block_size;
  return result;
}

int EVP_DecryptFinal_ex(EVP_CIPHER_CTX *ctx, unsigned __int8 *outm, int *outl)
{
  const EVP_CIPHER *cipher;
  unsigned int block_size;
  int v6;
  int v7;
  int v8;
  uint64_t v10;
  uint64_t v11;
  unsigned int v12;
  BOOL v13;
  int v14;
  unsigned __int8 *final;
  uint64_t v16;
  unsigned __int8 v17;

  *outl = 0;
  cipher = ctx->cipher;
  if ((ctx->cipher->flags & 0x100000) != 0)
  {
    v8 = ((uint64_t (*)(void))cipher->do_cipher)();
    if (v8 < 0)
      return 0;
    *outl = v8;
  }
  else
  {
    if ((ctx->flags & 0x100) == 0)
    {
      block_size = cipher->block_size;
      if (block_size < 2)
      {
        LODWORD(v10) = 0;
LABEL_13:
        *outl = v10;
        return 1;
      }
      if (!ctx->buf_len && ctx->final_used)
      {
        if (block_size >= 0x21)
        {
          v6 = 136;
          v7 = 548;
          goto LABEL_10;
        }
        v11 = block_size - 1;
        v12 = ctx->final[v11];
        if (ctx->final[v11])
          v13 = block_size >= v12;
        else
          v13 = 0;
        if (!v13)
        {
          v6 = 100;
          v7 = 553;
          goto LABEL_10;
        }
        v14 = ctx->final[v11];
        do
        {
          if (ctx->final[v11] != v12)
          {
            v6 = 100;
            v7 = 558;
            goto LABEL_10;
          }
          LODWORD(v11) = v11 - 1;
          --v14;
        }
        while (v14);
        v10 = block_size - v12;
        if ((int)v10 >= 1)
        {
          final = ctx->final;
          v16 = v10;
          do
          {
            v17 = *final++;
            *outm++ = v17;
            --v16;
          }
          while (v16);
        }
        goto LABEL_13;
      }
      v6 = 109;
      v7 = 544;
LABEL_10:
      ERR_put_error(6, 4095, v6, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/evp_enc.c", v7);
      return 0;
    }
    if (ctx->buf_len)
    {
      v6 = 138;
      v7 = 536;
      goto LABEL_10;
    }
  }
  return 1;
}

int EVP_CipherFinal(EVP_CIPHER_CTX *ctx, unsigned __int8 *outm, int *outl)
{
  if (ctx->encrypt)
    return EVP_EncryptFinal_ex(ctx, outm, outl);
  else
    return EVP_DecryptFinal_ex(ctx, outm, outl);
}

int EVP_EncryptInit(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *cipher, const unsigned __int8 *key, const unsigned __int8 *iv)
{
  return EVP_CipherInit(ctx, cipher, key, iv, 1);
}

int EVP_EncryptInit_ex(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *cipher, ENGINE *impl, const unsigned __int8 *key, const unsigned __int8 *iv)
{
  return EVP_CipherInit_ex(ctx, cipher, impl, key, iv, 1);
}

int EVP_DecryptInit(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *cipher, const unsigned __int8 *key, const unsigned __int8 *iv)
{
  return EVP_CipherInit(ctx, cipher, key, iv, 0);
}

int EVP_DecryptInit_ex(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *cipher, ENGINE *impl, const unsigned __int8 *key, const unsigned __int8 *iv)
{
  return EVP_CipherInit_ex(ctx, cipher, impl, key, iv, 0);
}

EVP_CIPHER_CTX *EVP_CIPHER_CTX_new(void)
{
  return (EVP_CIPHER_CTX *)malloc_type_calloc(1uLL, 0xA8uLL, 0x10E004046F6AA3FuLL);
}

void EVP_CIPHER_CTX_free(EVP_CIPHER_CTX *a)
{
  if (a)
  {
    EVP_CIPHER_CTX_cleanup(a);
    free(a);
  }
}

uint64_t EVP_CIPHER_CTX_reset(EVP_CIPHER_CTX *a1)
{
  EVP_CIPHER_CTX_cleanup(a1);
  return 1;
}

int EVP_CIPHER_CTX_set_key_length(EVP_CIPHER_CTX *x, int keylen)
{
  unint64_t flags;

  flags = x->cipher->flags;
  if ((flags & 0x80) != 0)
    return EVP_CIPHER_CTX_ctrl(x, 1, keylen, 0);
  if (x->key_len == keylen)
    return 1;
  if (keylen >= 1 && (flags & 8) != 0)
  {
    x->key_len = keylen;
    return 1;
  }
  ERR_put_error(6, 4095, 130, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/evp_enc.c", 635);
  return 0;
}

int EVP_CIPHER_CTX_set_padding(EVP_CIPHER_CTX *c, int pad)
{
  c->flags = c->flags & 0xFFFFFFFFFFFFFEFFLL | ((unint64_t)(pad == 0) << 8);
  return 1;
}

int EVP_CIPHER_CTX_rand_key(EVP_CIPHER_CTX *ctx, unsigned __int8 *key)
{
  if ((ctx->cipher->flags & 0x200) != 0)
    return EVP_CIPHER_CTX_ctrl(ctx, 6, 0, key);
  arc4random_buf(key, ctx->key_len);
  return 1;
}

uint64_t EVP_CIPHER_CTX_copy(EVP_CIPHER_CTX *a, uint64_t *a2)
{
  ENGINE *v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  uint64_t v13;
  size_t v14;
  void *v15;
  uint64_t result;
  int v17;
  int v18;

  if (!a2 || !*a2)
  {
    v17 = 111;
    v18 = 685;
    goto LABEL_13;
  }
  v4 = (ENGINE *)a2[1];
  if (v4 && !ENGINE_init(v4))
  {
    v17 = 38;
    v18 = 691;
    goto LABEL_13;
  }
  EVP_CIPHER_CTX_cleanup(a);
  v6 = *((_OWORD *)a2 + 1);
  v5 = *((_OWORD *)a2 + 2);
  *(_OWORD *)&a->cipher = *(_OWORD *)a2;
  *(_OWORD *)&a->encrypt = v6;
  *(_OWORD *)&a->oiv[8] = v5;
  v7 = *((_OWORD *)a2 + 6);
  v9 = *((_OWORD *)a2 + 3);
  v8 = *((_OWORD *)a2 + 4);
  *(_OWORD *)&a->buf[24] = *((_OWORD *)a2 + 5);
  *(_OWORD *)&a->app_data = v7;
  *(_OWORD *)&a->iv[8] = v9;
  *(_OWORD *)&a->buf[8] = v8;
  v11 = *((_OWORD *)a2 + 8);
  v10 = *((_OWORD *)a2 + 9);
  v12 = *((_OWORD *)a2 + 7);
  *(_QWORD *)&a->final[24] = a2[20];
  *(_OWORD *)&a->final_used = v11;
  *(_OWORD *)&a->final[8] = v10;
  *(_OWORD *)&a->flags = v12;
  v13 = *a2;
  if (a2[15])
  {
    v14 = *(int *)(v13 + 48);
    if ((_DWORD)v14)
    {
      v15 = malloc_type_calloc(1uLL, v14, 0xD5E8FBC9uLL);
      a->cipher_data = v15;
      if (v15)
      {
        memcpy(v15, (const void *)a2[15], *(int *)(*a2 + 48));
        v13 = *a2;
        goto LABEL_9;
      }
      v17 = 65;
      v18 = 702;
LABEL_13:
      ERR_put_error(6, 4095, v17, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/evp_enc.c", v18);
      return 0;
    }
  }
LABEL_9:
  if ((*(_BYTE *)(v13 + 17) & 4) == 0
    || (*(unsigned int (**)(uint64_t *, uint64_t, _QWORD, EVP_CIPHER_CTX *))(v13 + 72))(a2, 8, 0, a))
  {
    return 1;
  }
  freezero(a->cipher_data, *(int *)(*a2 + 48));
  result = 0;
  a->cipher_data = 0;
  return result;
}

uint64_t x25519_ge_tobytes(uint64_t a1, int *a2)
{
  uint64_t result;
  _OWORD v5[2];
  uint64_t v6;
  _OWORD v7[2];
  uint64_t v8;
  _OWORD v9[2];
  uint64_t v10;
  _BYTE v11[32];
  uint64_t v12;

  v12 = *MEMORY[0x24BDAC8D0];
  v10 = 0;
  memset(v9, 0, sizeof(v9));
  v8 = 0;
  memset(v7, 0, sizeof(v7));
  v6 = 0;
  memset(v5, 0, sizeof(v5));
  fe_invert(v9, a2 + 20);
  fe_mul(v7, a2, (int *)v9);
  fe_mul(v5, a2 + 10, (int *)v9);
  fe_tobytes(a1, v5);
  result = fe_tobytes((uint64_t)v11, v7);
  *(_BYTE *)(a1 + 31) ^= v11[0] << 7;
  return result;
}

uint64_t fe_invert(_DWORD *a1, int *a2)
{
  int v4;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  _OWORD v13[2];
  uint64_t v14;
  _OWORD v15[2];
  uint64_t v16;
  _OWORD v17[2];
  uint64_t v18;
  _OWORD v19[2];
  uint64_t v20;
  uint64_t v21;

  v21 = *MEMORY[0x24BDAC8D0];
  v20 = 0;
  memset(v19, 0, sizeof(v19));
  v18 = 0;
  memset(v17, 0, sizeof(v17));
  v16 = 0;
  memset(v15, 0, sizeof(v15));
  fe_sq(v19, a2);
  fe_sq(v17, (int *)v19);
  fe_sq(v17, (int *)v17);
  fe_mul(v17, a2, (int *)v17);
  fe_mul(v19, (int *)v19, (int *)v17);
  fe_sq(v15, (int *)v19);
  fe_mul(v17, (int *)v17, (int *)v15);
  fe_sq(v15, (int *)v17);
  v4 = 4;
  do
  {
    fe_sq(v15, (int *)v15);
    --v4;
  }
  while (v4);
  fe_mul(v17, (int *)v15, (int *)v17);
  fe_sq(v15, (int *)v17);
  v5 = 9;
  do
  {
    fe_sq(v15, (int *)v15);
    --v5;
  }
  while (v5);
  v14 = 0;
  memset(v13, 0, sizeof(v13));
  fe_mul(v15, (int *)v15, (int *)v17);
  fe_sq(v13, (int *)v15);
  v6 = 19;
  do
  {
    fe_sq(v13, (int *)v13);
    --v6;
  }
  while (v6);
  fe_mul(v15, (int *)v13, (int *)v15);
  fe_sq(v15, (int *)v15);
  v7 = 9;
  do
  {
    fe_sq(v15, (int *)v15);
    --v7;
  }
  while (v7);
  fe_mul(v17, (int *)v15, (int *)v17);
  fe_sq(v15, (int *)v17);
  v8 = 49;
  do
  {
    fe_sq(v15, (int *)v15);
    --v8;
  }
  while (v8);
  fe_mul(v15, (int *)v15, (int *)v17);
  fe_sq(v13, (int *)v15);
  v9 = 99;
  do
  {
    fe_sq(v13, (int *)v13);
    --v9;
  }
  while (v9);
  fe_mul(v15, (int *)v13, (int *)v15);
  fe_sq(v15, (int *)v15);
  v10 = 49;
  do
  {
    fe_sq(v15, (int *)v15);
    --v10;
  }
  while (v10);
  fe_mul(v17, (int *)v15, (int *)v17);
  fe_sq(v17, (int *)v17);
  v11 = 4;
  do
  {
    fe_sq(v17, (int *)v17);
    --v11;
  }
  while (v11);
  return fe_mul(a1, (int *)v17, (int *)v19);
}

uint64_t fe_mul(_DWORD *a1, int *a2, int *a3)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t result;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  unint64_t v69;
  unint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;

  v4 = a2[8];
  v5 = a3[1];
  v6 = 2 * a2[9];
  v7 = a2[9];
  v9 = a3[2];
  v8 = a3[3];
  v10 = 19 * v9;
  v11 = 19 * (int)v8;
  v12 = a3[4];
  v81 = a3[5];
  v13 = 19 * v12;
  v14 = 19 * (int)v81;
  v16 = a2[2];
  v15 = a2[3];
  v82 = a2[1];
  v17 = a2[4];
  v18 = a2[5];
  v19 = a2[6];
  v20 = a2[7];
  v71 = 2 * v15;
  v72 = 2 * v18;
  v21 = 19 * v5 * v6 + *a3 * (uint64_t)*a2 + v10 * v4 + v11 * 2 * v20;
  v22 = *a3 * (uint64_t)(int)v82 + (int)v5 * (uint64_t)*a2 + v10 * v7 + v11 * v4;
  v23 = v5 * 2 * v82 + *a3 * (uint64_t)(int)v16 + v9 * (uint64_t)*a2 + v11 * v6;
  v24 = v21 + v13 * v19 + v14 * 2 * v18;
  v25 = v5 * 2 * v15
      + *a3 * (uint64_t)(int)v17
      + v9 * (uint64_t)(int)v16
      + v8 * 2 * v82
      + v12 * (uint64_t)*a2
      + v14 * 2 * v7;
  v79 = v15;
  v26 = v22 + v13 * v20 + v14 * v19;
  v80 = v23 + v13 * v4 + v14 * 2 * v20;
  v27 = *a3 * (uint64_t)(int)v15
      + (int)v5 * (uint64_t)(int)v16
      + v9 * (uint64_t)(int)v82
      + (int)v8 * (uint64_t)*a2
      + v13 * v7
      + v14 * v4;
  LODWORD(v23) = a3[6];
  v28 = a3[7];
  v29 = 19 * (int)v23;
  v30 = v24 + v29 * v17;
  v31 = v25 + v29 * v4;
  v75 = v18;
  v32 = v26 + v29 * v18;
  v33 = *a3 * (uint64_t)(int)v18
      + (int)v5 * (uint64_t)(int)v17
      + v9 * (uint64_t)(int)v15
      + (int)v8 * (uint64_t)(int)v16
      + v12 * (uint64_t)(int)v82
      + (int)v81 * (uint64_t)*a2
      + v29 * a2[9];
  v34 = a2[9];
  v35 = v80 + v29 * v19;
  v36 = v27 + v29 * v20;
  v37 = 19 * (int)v28;
  v74 = v31 + v37 * 2 * v20;
  v76 = v32 + v37 * v17;
  v77 = v30 + v37 * v71;
  v38 = v33 + v37 * v4;
  v78 = v35 + v37 * v72;
  v39 = v5 * v72
      + *a3 * (uint64_t)(int)v19
      + v9 * (uint64_t)(int)v17
      + v8 * v71
      + v12 * (uint64_t)(int)v16
      + v81 * 2 * v82
      + (int)v23 * (uint64_t)*a2
      + v37 * 2 * v34;
  v73 = v36 + v37 * v19;
  LODWORD(v37) = a3[8];
  LODWORD(v80) = a3[9];
  v40 = 19 * (int)v37;
  v41 = 19 * (int)v80;
  v42 = v39 + v40 * v4 + v41 * 2 * v20;
  v43 = v5 * 2 * v20 + *a3 * (uint64_t)(int)v4;
  v44 = v38 + v40 * v20;
  v45 = *a3 * (uint64_t)(int)v34 + (int)v5 * (uint64_t)(int)v4 + v9 * (uint64_t)(int)v20;
  v46 = *a3 * (uint64_t)(int)v20 + (int)v5 * (uint64_t)(int)v19 + v9 * (uint64_t)(int)v75;
  v47 = v74 + v40 * v19 + v41 * v72;
  v48 = v43 + v9 * (uint64_t)(int)v19 + v8 * v72;
  v49 = v44 + v41 * v19;
  v50 = v45 + (int)v8 * (uint64_t)(int)v19;
  v51 = v46
      + (int)v8 * (uint64_t)(int)v17
      + v12 * (uint64_t)(int)v79
      + (int)v81 * (uint64_t)(int)v16
      + (int)v23 * (uint64_t)(int)v82
      + (int)v28 * (uint64_t)*a2
      + v40 * v34;
  v52 = v77 + v40 * v16;
  v53 = v76 + v40 * v79;
  v54 = v50 + v12 * (uint64_t)(int)v75;
  v55 = v78 + v40 * v17 + v41 * v71;
  v56 = v73 + v40 * v75 + v41 * v17;
  v57 = v51 + v41 * v4;
  v58 = v52 + v41 * 2 * v82;
  v59 = v48
      + v12 * (uint64_t)(int)v17
      + v81 * v71
      + (int)v23 * (uint64_t)(int)v16
      + v28 * 2 * v82
      + (int)v37 * (uint64_t)*a2
      + v41 * 2 * v34;
  result = 0x2000000;
  v61 = v53 + v41 * v16 + ((v58 + 0x2000000) >> 26);
  v62 = v49 + ((v47 + 0x2000000) >> 26);
  v63 = v55 + ((v61 + 0x1000000) >> 25);
  v64 = v42 + ((v62 + 0x1000000) >> 25);
  v65 = v56 + ((v63 + 0x2000000) >> 26);
  v66 = v57 + ((v64 + 0x2000000) >> 26);
  v67 = v59 + ((v66 + 0x1000000) >> 25);
  v68 = v54
      + (int)v81 * (uint64_t)(int)v17
      + (int)v23 * (uint64_t)(int)v79
      + (int)v28 * (uint64_t)(int)v16
      + (int)v37 * (uint64_t)(int)v82
      + (int)v80 * (uint64_t)*a2
      + ((v67 + 0x2000000) >> 26);
  v69 = v58 - ((v58 + 0x2000000) & 0xFFFFFFFFFC000000) + 19 * ((v68 + 0x1000000) >> 25);
  *a1 = v69 - ((v69 + 0x2000000) & 0xFC000000);
  a1[1] = v61 - ((v61 + 0x1000000) & 0xFE000000) + ((v69 + 0x2000000) >> 26);
  v70 = v47 - ((v47 + 0x2000000) & 0xFFFFFFFFFC000000) + ((v65 + 0x1000000) >> 25);
  a1[2] = v63 - ((v63 + 0x2000000) & 0xFC000000);
  a1[3] = v65 - ((v65 + 0x1000000) & 0xFE000000);
  a1[4] = v70 - ((v70 + 0x2000000) & 0xFC000000);
  a1[5] = v62 - ((v62 + 0x1000000) & 0xFE000000) + ((v70 + 0x2000000) >> 26);
  a1[6] = v64 - ((v64 + 0x2000000) & 0xFC000000);
  a1[7] = v66 - ((v66 + 0x1000000) & 0xFE000000);
  a1[8] = v67 - ((v67 + 0x2000000) & 0xFC000000);
  a1[9] = v68 - ((v68 + 0x1000000) & 0xFE000000);
  return result;
}

uint64_t fe_tobytes(uint64_t result, _DWORD *a2)
{
  int v2;
  int v3;
  int v4;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  unsigned int v12;
  unsigned int v13;
  unsigned int v14;
  unsigned int v15;
  int v16;
  unsigned int v17;
  unsigned int v18;
  unsigned int v19;
  unsigned int v20;

  v2 = a2[1];
  v3 = a2[2];
  v4 = a2[3];
  v5 = a2[4];
  v6 = a2[5];
  v7 = a2[6];
  v8 = a2[7];
  v9 = a2[8];
  v10 = a2[9];
  v11 = *a2
      + 19
      * ((v10
        + ((v9
          + ((v8
            + ((v7
              + ((v6
                + ((v5 + ((v4 + ((v3 + ((v2 + ((*a2 + ((19 * v10 + 0x1000000) >> 25)) >> 26)) >> 25)) >> 26)) >> 25)) >> 26)) >> 25)) >> 26)) >> 25)) >> 26)) >> 25);
  v12 = v2 + (v11 >> 26);
  v13 = v3 + ((int)v12 >> 25);
  v14 = v4 + ((int)v13 >> 26);
  v15 = v5 + ((int)v14 >> 25);
  v16 = v6 + ((int)v15 >> 26);
  v17 = v7 + (v16 >> 25);
  v18 = v8 + ((int)v17 >> 26);
  v19 = v9 + ((int)v18 >> 25);
  v20 = v10 + ((int)v19 >> 26);
  *(_WORD *)result = v11;
  *(_BYTE *)(result + 2) = BYTE2(v11);
  *(_BYTE *)(result + 3) = HIBYTE(v11) & 3 | (4 * v12);
  *(_BYTE *)(result + 4) = v12 >> 6;
  *(_BYTE *)(result + 5) = v12 >> 14;
  *(_BYTE *)(result + 6) = (v12 >> 22) & 7 | (8 * v13);
  *(_BYTE *)(result + 7) = v13 >> 5;
  *(_BYTE *)(result + 8) = v13 >> 13;
  *(_BYTE *)(result + 9) = (v13 >> 21) & 0x1F | (32 * v14);
  *(_BYTE *)(result + 10) = v14 >> 3;
  *(_BYTE *)(result + 11) = v14 >> 11;
  *(_BYTE *)(result + 12) = (v14 >> 19) & 0x3F | ((_BYTE)v15 << 6);
  *(_BYTE *)(result + 13) = v15 >> 2;
  *(_BYTE *)(result + 14) = v15 >> 10;
  *(_BYTE *)(result + 15) = v15 >> 18;
  *(_WORD *)(result + 16) = v16;
  *(_BYTE *)(result + 18) = BYTE2(v16);
  *(_BYTE *)(result + 19) = HIBYTE(v16) & 1 | (2 * v17);
  *(_BYTE *)(result + 20) = v17 >> 7;
  *(_BYTE *)(result + 21) = v17 >> 15;
  *(_BYTE *)(result + 22) = (v17 >> 23) & 7 | (8 * v18);
  *(_BYTE *)(result + 23) = v18 >> 5;
  *(_BYTE *)(result + 24) = v18 >> 13;
  *(_BYTE *)(result + 25) = (v18 >> 21) & 0xF | (16 * v19);
  *(_BYTE *)(result + 26) = v19 >> 4;
  *(_BYTE *)(result + 27) = v19 >> 12;
  *(_BYTE *)(result + 28) = (v19 >> 20) & 0x3F | ((_BYTE)v20 << 6);
  *(_BYTE *)(result + 29) = v20 >> 2;
  *(_BYTE *)(result + 30) = v20 >> 10;
  *(_BYTE *)(result + 31) = (v20 >> 18) & 0x7F;
  return result;
}

uint64_t x25519_ge_frombytes_vartime(uint64_t a1, uint64_t a2)
{
  int *v4;
  uint64_t i;
  uint64_t j;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  uint64_t k;
  uint64_t m;
  uint64_t n;
  _OWORD v18[2];
  uint64_t v19;
  _OWORD v20[2];
  uint64_t v21;
  _OWORD v22[2];
  uint64_t v23;
  _OWORD v24[2];
  uint64_t v25;
  _OWORD v26[2];
  uint64_t v27;
  _OWORD v28[2];
  uint64_t v29;
  _OWORD v30[2];
  uint64_t v31;
  _OWORD v32[2];
  uint64_t v33;
  uint64_t v34;

  v34 = *MEMORY[0x24BDAC8D0];
  v27 = 0;
  memset(v26, 0, sizeof(v26));
  v25 = 0;
  memset(v24, 0, sizeof(v24));
  v4 = (int *)(a1 + 40);
  fe_frombytes((_DWORD *)(a1 + 40), (unsigned int *)a2);
  *(_QWORD *)(a1 + 112) = 0;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_DWORD *)(a1 + 80) = 1;
  fe_sq(v26, v4);
  fe_mul(v24, (int *)v26, d);
  for (i = 0; i != 40; i += 4)
    *(_DWORD *)((char *)v26 + i) -= *(_DWORD *)(a1 + i + 80);
  for (j = 0; j != 40; j += 4)
    *(_DWORD *)((char *)v24 + j) += *(_DWORD *)(a1 + j + 80);
  v23 = 0;
  memset(v22, 0, sizeof(v22));
  fe_sq(v22, (int *)v24);
  fe_mul(v22, (int *)v22, (int *)v24);
  fe_sq((_DWORD *)a1, (int *)v22);
  fe_mul((_DWORD *)a1, (int *)a1, (int *)v24);
  fe_mul((_DWORD *)a1, (int *)a1, (int *)v26);
  v33 = 0;
  memset(v32, 0, sizeof(v32));
  v31 = 0;
  memset(v30, 0, sizeof(v30));
  fe_sq(v32, (int *)a1);
  fe_sq(v30, (int *)v32);
  fe_sq(v30, (int *)v30);
  fe_mul(v30, (int *)a1, (int *)v30);
  fe_mul(v32, (int *)v32, (int *)v30);
  fe_sq(v32, (int *)v32);
  fe_mul(v32, (int *)v30, (int *)v32);
  fe_sq(v30, (int *)v32);
  v7 = 4;
  do
  {
    fe_sq(v30, (int *)v30);
    --v7;
  }
  while (v7);
  fe_mul(v32, (int *)v30, (int *)v32);
  fe_sq(v30, (int *)v32);
  v8 = 9;
  do
  {
    fe_sq(v30, (int *)v30);
    --v8;
  }
  while (v8);
  v29 = 0;
  memset(v28, 0, sizeof(v28));
  fe_mul(v30, (int *)v30, (int *)v32);
  fe_sq(v28, (int *)v30);
  v9 = 19;
  do
  {
    fe_sq(v28, (int *)v28);
    --v9;
  }
  while (v9);
  fe_mul(v30, (int *)v28, (int *)v30);
  fe_sq(v30, (int *)v30);
  v10 = 9;
  do
  {
    fe_sq(v30, (int *)v30);
    --v10;
  }
  while (v10);
  fe_mul(v32, (int *)v30, (int *)v32);
  fe_sq(v30, (int *)v32);
  v11 = 49;
  do
  {
    fe_sq(v30, (int *)v30);
    --v11;
  }
  while (v11);
  fe_mul(v30, (int *)v30, (int *)v32);
  fe_sq(v28, (int *)v30);
  v12 = 99;
  do
  {
    fe_sq(v28, (int *)v28);
    --v12;
  }
  while (v12);
  fe_mul(v30, (int *)v28, (int *)v30);
  fe_sq(v30, (int *)v30);
  v13 = 49;
  do
  {
    fe_sq(v30, (int *)v30);
    --v13;
  }
  while (v13);
  v21 = 0;
  memset(v20, 0, sizeof(v20));
  memset(v18, 0, sizeof(v18));
  v19 = 0;
  fe_mul(v32, (int *)v30, (int *)v32);
  fe_sq(v32, (int *)v32);
  fe_sq(v32, (int *)v32);
  fe_mul((_DWORD *)a1, (int *)v32, (int *)a1);
  fe_mul((_DWORD *)a1, (int *)a1, (int *)v22);
  fe_mul((_DWORD *)a1, (int *)a1, (int *)v26);
  fe_sq(v20, (int *)a1);
  fe_mul(v20, (int *)v20, (int *)v24);
  for (k = 0; k != 40; k += 4)
    *(_DWORD *)((char *)v18 + k) = *(_DWORD *)((char *)v20 + k) - *(_DWORD *)((char *)v26 + k);
  fe_tobytes((uint64_t)v32, v18);
  if (timingsafe_memcmp((unsigned __int8 *)v32, fe_isnonzero_zero, 32))
  {
    for (m = 0; m != 40; m += 4)
      *(_DWORD *)((char *)v18 + m) = *(_DWORD *)((char *)v26 + m) + *(_DWORD *)((char *)v20 + m);
    fe_tobytes((uint64_t)v32, v18);
    if (timingsafe_memcmp((unsigned __int8 *)v32, fe_isnonzero_zero, 32))
      return 0xFFFFFFFFLL;
    fe_mul((_DWORD *)a1, (int *)a1, sqrtm1);
  }
  fe_tobytes((uint64_t)v32, (_DWORD *)a1);
  if ((v32[0] & 1) != *(unsigned __int8 *)(a2 + 31) >> 7)
  {
    for (n = 0; n != 40; n += 4)
      *(_DWORD *)(a1 + n) = -*(_DWORD *)(a1 + n);
  }
  fe_mul((_DWORD *)(a1 + 120), (int *)a1, v4);
  return 0;
}

_DWORD *fe_frombytes(_DWORD *result, unsigned int *a2)
{
  unint64_t v2;
  unint64_t v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  unint64_t v7;
  int v8;
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;

  v2 = ((unint64_t)*((unsigned __int8 *)a2 + 4) << 6) | ((unint64_t)*((unsigned __int8 *)a2 + 5) << 14) | ((unint64_t)*((unsigned __int8 *)a2 + 6) << 22);
  v3 = (8 * *((unsigned __int8 *)a2 + 10)) | ((unint64_t)*((unsigned __int8 *)a2 + 11) << 11) | ((unint64_t)*((unsigned __int8 *)a2 + 12) << 19);
  v4 = a2[4];
  v5 = ((4 * *((unsigned __int8 *)a2 + 29)) | ((unint64_t)*((unsigned __int8 *)a2 + 30) << 10)) & 0xFFFFFFFFFE03FFFFLL | ((unint64_t)(*((_BYTE *)a2 + 31) & 0x7F) << 18);
  v6 = *a2 + 19 * ((v5 + 0x1000000) >> 25);
  v7 = ((32 * *((unsigned __int8 *)a2 + 7)) | ((unint64_t)*((unsigned __int8 *)a2 + 8) << 13) | ((unint64_t)*((unsigned __int8 *)a2 + 9) << 21))
     + ((v2 + 0x1000000) >> 25);
  v8 = ((v7 + 0x2000000) >> 26) + v3;
  v3 += 0x1000000;
  v9 = ((4 * *((unsigned __int8 *)a2 + 13)) | ((unint64_t)*((unsigned __int8 *)a2 + 14) << 10) | ((unint64_t)*((unsigned __int8 *)a2 + 15) << 18))
     + (v3 >> 25);
  LODWORD(v3) = v8 - (v3 & 0xE000000);
  v10 = (32 * *((unsigned __int8 *)a2 + 23)) | ((unint64_t)*((unsigned __int8 *)a2 + 24) << 13) | ((unint64_t)*((unsigned __int8 *)a2 + 25) << 21);
  v11 = *((unsigned __int8 *)a2 + 26);
  v12 = (((unint64_t)*((unsigned __int8 *)a2 + 20) << 7) | ((unint64_t)*((unsigned __int8 *)a2 + 21) << 15) | ((unint64_t)*((unsigned __int8 *)a2 + 22) << 23))
      + ((unint64_t)(v4 + 0x1000000) >> 25);
  v13 = *((unsigned __int8 *)a2 + 27);
  v14 = *((unsigned __int8 *)a2 + 28);
  *result = v6 - ((v6 + 0x2000000) & 0xFC000000);
  result[1] = v2 - ((v2 + 0x1000000) & 0x7E000000) + ((unint64_t)(v6 + 0x2000000) >> 26);
  v15 = ((16 * v11) | (v13 << 12) | (v14 << 20)) + ((v10 + 0x1000000) >> 25);
  result[2] = v7 - ((v7 + 0x2000000) & 0xFC000000);
  result[3] = v3;
  result[4] = v9 - ((v9 + 0x2000000) & 0xFC000000);
  result[5] = v4 - ((v4 + 0x1000000) & 0xFE000000) + ((v9 + 0x2000000) >> 26);
  result[6] = v12 - ((v12 + 0x2000000) & 0xFC000000);
  result[7] = ((v12 + 0x2000000) >> 26) + v10 - ((v10 + 0x1000000) & 0x3E000000);
  result[8] = v15 - ((v15 + 0x2000000) & 0xFC000000);
  result[9] = v5 + ((v15 + 0x2000000) >> 26) - ((v5 + 0x1000000) & 0x2000000);
  return result;
}

_DWORD *fe_sq(_DWORD *result, int *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  unint64_t v37;
  unint64_t v38;

  v3 = a2[4];
  v2 = a2[5];
  v5 = a2[6];
  v4 = a2[7];
  v6 = 19 * (int)v5;
  v7 = *a2;
  v8 = a2[1];
  v9 = 38 * (int)v4;
  v11 = a2[8];
  v10 = a2[9];
  v12 = 19 * (int)v11;
  v13 = a2[2];
  v14 = a2[3];
  v15 = 2 * v7;
  v16 = 2 * v13;
  v17 = 2 * v14;
  v18 = 38 * (int)v10;
  v19 = 2 * v7 * v8;
  v20 = 2 * v8 * v13;
  v21 = 38 * (int)v2 * (uint64_t)(int)v2
      + (int)v7 * (uint64_t)(int)v7
      + v6 * 2 * v3
      + v9 * 2 * v14
      + v12 * 2 * v13
      + v18 * 2 * v8;
  v22 = 2 * v8 * v8 + v13 * 2 * v7;
  v23 = 2 * v14 * 2 * v8 + (int)v13 * (uint64_t)(int)v13 + v3 * 2 * v7 + v9 * v4 + 2 * v5 * v12 + v18 * 2 * v2;
  v24 = v19 + v6 * 2 * v2 + v9 * v3 + v12 * 2 * v14 + v18 * v13 + ((v21 + 0x2000000) >> 26);
  v25 = 2 * v13 * v14 + v3 * 2 * v8 + v2 * v15 + v12 * 2 * v4 + v18 * v5 + ((v23 + 0x2000000) >> 26);
  v26 = v22 + v6 * v5 + v9 * 2 * v2 + v12 * 2 * v3 + v18 * 2 * v14 + ((v24 + 0x1000000) >> 25);
  v27 = v20 + v14 * v15;
  v28 = v3 * v16 + 2 * v14 * v14 + 2 * v2 * 2 * v8 + v5 * v15 + v12 * v11 + v18 * 2 * v4 + ((v25 + 0x1000000) >> 25);
  v29 = v27 + v9 * v5 + v12 * 2 * v2 + v18 * v3 + ((v26 + 0x2000000) >> 26);
  LODWORD(v12) = v26 - ((v26 + 0x2000000) & 0xFC000000);
  v30 = 2 * v3 * v2;
  v31 = v17 * v3 + v2 * v16;
  v32 = v5 * v16 + (int)v3 * (uint64_t)(int)v3 + 2 * v2 * v17;
  v33 = v31 + v5 * 2 * v8 + v4 * v15 + v18 * v11 + ((v28 + 0x2000000) >> 26);
  v34 = v30 + v5 * v17 + v4 * v16 + v11 * 2 * v8;
  v35 = v32 + 2 * v4 * 2 * v8 + v11 * v15 + v18 * v10 + ((v33 + 0x1000000) >> 25);
  v36 = v34 + v10 * v15 + ((v35 + 0x2000000) >> 26);
  v37 = v21 - ((v21 + 0x2000000) & 0xFFFFFFFFFC000000) + 19 * ((v36 + 0x1000000) >> 25);
  *result = v37 - ((v37 + 0x2000000) & 0xFC000000);
  result[1] = v24 - ((v24 + 0x1000000) & 0xFE000000) + ((v37 + 0x2000000) >> 26);
  v38 = v23 - ((v23 + 0x2000000) & 0xFFFFFFFFFC000000) + ((v29 + 0x1000000) >> 25);
  result[2] = v12;
  result[3] = v29 - ((v29 + 0x1000000) & 0xFE000000);
  result[4] = v38 - ((v38 + 0x2000000) & 0xFC000000);
  result[5] = v25 - ((v25 + 0x1000000) & 0xFE000000) + ((v38 + 0x2000000) >> 26);
  result[6] = v28 - ((v28 + 0x2000000) & 0xFC000000);
  result[7] = v33 - ((v33 + 0x1000000) & 0xFE000000);
  result[8] = v35 - ((v35 + 0x2000000) & 0xFC000000);
  result[9] = v36 - ((v36 + 0x1000000) & 0xFE000000);
  return result;
}

uint64_t x25519_ge_p3_to_cached(uint64_t a1, uint64_t a2)
{
  uint64_t i;
  uint64_t j;
  __int128 v4;
  __int128 v5;

  for (i = 0; i != 40; i += 4)
    *(_DWORD *)(a1 + i) = *(_DWORD *)(a2 + i) + *(_DWORD *)(a2 + i + 40);
  for (j = 0; j != 40; j += 4)
    *(_DWORD *)(a1 + 40 + j) = *(_DWORD *)(a2 + j + 40) - *(_DWORD *)(a2 + j);
  v4 = *(_OWORD *)(a2 + 80);
  v5 = *(_OWORD *)(a2 + 96);
  *(_QWORD *)(a1 + 112) = *(_QWORD *)(a2 + 112);
  *(_OWORD *)(a1 + 80) = v4;
  *(_OWORD *)(a1 + 96) = v5;
  return fe_mul((_DWORD *)(a1 + 120), (int *)(a2 + 120), d2);
}

uint64_t x25519_ge_p1p1_to_p2(_DWORD *a1, int *a2)
{
  int *v2;
  int *v4;
  int *v5;

  v2 = a2;
  v4 = a2 + 30;
  fe_mul(a1, a2, a2 + 30);
  v5 = v2 + 10;
  v2 += 20;
  fe_mul(a1 + 10, v5, v2);
  return fe_mul(a1 + 20, v2, v4);
}

uint64_t x25519_ge_p1p1_to_p3(_DWORD *a1, int *a2)
{
  int *v4;

  v4 = a2 + 30;
  fe_mul(a1, a2, a2 + 30);
  fe_mul(a1 + 10, a2 + 10, a2 + 20);
  fe_mul(a1 + 20, a2 + 20, v4);
  return fe_mul(a1 + 30, a2, a2 + 10);
}

uint64_t x25519_ge_add(int *a1, uint64_t a2, int *a3)
{
  uint64_t v6;
  uint64_t i;
  uint64_t result;
  uint64_t j;
  uint64_t k;
  uint64_t m;
  uint64_t n;
  uint64_t ii;
  _OWORD v14[2];
  uint64_t v15;
  uint64_t v16;

  v6 = 0;
  v16 = *MEMORY[0x24BDAC8D0];
  do
  {
    a1[v6] = *(_DWORD *)(a2 + v6 * 4) + *(_DWORD *)(a2 + v6 * 4 + 40);
    ++v6;
  }
  while (v6 != 10);
  for (i = 0; i != 10; ++i)
    a1[i + 10] = *(_DWORD *)(a2 + i * 4 + 40) - *(_DWORD *)(a2 + i * 4);
  v15 = 0;
  memset(v14, 0, sizeof(v14));
  fe_mul(a1 + 20, a1, a3);
  fe_mul(a1 + 10, a1 + 10, a3 + 10);
  fe_mul(a1 + 30, a3 + 30, (int *)(a2 + 120));
  result = fe_mul(a1, (int *)(a2 + 80), a3 + 20);
  for (j = 0; j != 10; ++j)
    *(_DWORD *)((char *)v14 + j * 4) = 2 * a1[j];
  for (k = 0; k != 10; ++k)
    a1[k] = a1[k + 20] - a1[k + 10];
  for (m = 0; m != 10; ++m)
    a1[m + 10] += a1[m + 20];
  for (n = 0; n != 10; ++n)
    a1[n + 20] = a1[n + 30] + *(_DWORD *)((char *)v14 + n * 4);
  for (ii = 0; ii != 10; ++ii)
    a1[ii + 30] = *(_DWORD *)((char *)v14 + ii * 4) - a1[ii + 30];
  return result;
}

uint64_t x25519_ge_sub(int *a1, uint64_t a2, int *a3)
{
  uint64_t v6;
  uint64_t i;
  uint64_t result;
  uint64_t j;
  uint64_t k;
  uint64_t m;
  uint64_t n;
  uint64_t ii;
  _OWORD v14[2];
  uint64_t v15;
  uint64_t v16;

  v6 = 0;
  v16 = *MEMORY[0x24BDAC8D0];
  do
  {
    a1[v6] = *(_DWORD *)(a2 + v6 * 4) + *(_DWORD *)(a2 + v6 * 4 + 40);
    ++v6;
  }
  while (v6 != 10);
  for (i = 0; i != 10; ++i)
    a1[i + 10] = *(_DWORD *)(a2 + i * 4 + 40) - *(_DWORD *)(a2 + i * 4);
  v15 = 0;
  memset(v14, 0, sizeof(v14));
  fe_mul(a1 + 20, a1, a3 + 10);
  fe_mul(a1 + 10, a1 + 10, a3);
  fe_mul(a1 + 30, a3 + 30, (int *)(a2 + 120));
  result = fe_mul(a1, (int *)(a2 + 80), a3 + 20);
  for (j = 0; j != 10; ++j)
    *(_DWORD *)((char *)v14 + j * 4) = 2 * a1[j];
  for (k = 0; k != 10; ++k)
    a1[k] = a1[k + 20] - a1[k + 10];
  for (m = 0; m != 10; ++m)
    a1[m + 10] += a1[m + 20];
  for (n = 0; n != 10; ++n)
    a1[n + 20] = *(_DWORD *)((char *)v14 + n * 4) - a1[n + 30];
  for (ii = 0; ii != 10; ++ii)
    a1[ii + 30] += *(_DWORD *)((char *)v14 + ii * 4);
  return result;
}

uint64_t x25519_ge_scalarmult_small_precomp(_DWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  _QWORD *v6;
  uint64_t i;
  uint64_t j;
  unint64_t v9;
  uint64_t v10;
  int v11;
  unsigned __int8 *v12;
  unsigned int v13;
  _QWORD *v14;
  uint64_t k;
  uint64_t result;
  _OWORD v18[7];
  uint64_t v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  _QWORD v40[227];

  v5 = 0;
  v40[225] = *MEMORY[0x24BDAC8D0];
  v6 = v40;
  do
  {
    *(_QWORD *)&v32 = 0;
    v30 = 0u;
    v31 = 0u;
    *(_QWORD *)&v22 = 0;
    v20 = 0u;
    v21 = 0u;
    fe_frombytes(&v30, (unsigned int *)(a3 + (v5 << 6)));
    fe_frombytes(&v20, (unsigned int *)(a3 + (v5 << 6) + 32));
    for (i = 0; i != 40; i += 4)
      *(_DWORD *)((char *)v6 + i) = *(_DWORD *)((char *)&v30 + i) + *(_DWORD *)((char *)&v20 + i);
    for (j = 0; j != 40; j += 4)
      *(_DWORD *)((char *)v6 + j + 40) = *(_DWORD *)((char *)&v20 + j) - *(_DWORD *)((char *)&v30 + j);
    fe_mul(&v40[15 * v5 + 10], (int *)&v30, (int *)&v20);
    fe_mul(&v40[15 * v5 + 10], (int *)&v40[15 * v5 + 10], d2);
    ++v5;
    v6 += 15;
  }
  while (v5 != 15);
  ge_p3_0((uint64_t)a1);
  v9 = 63;
  do
  {
    v10 = 0;
    v11 = 0;
    v12 = (unsigned __int8 *)(a2 + (v9 >> 3));
    do
    {
      v13 = *v12;
      v12 += 8;
      v11 |= ((v13 >> (v9 & 7)) & 1) << v10++;
    }
    while (v10 != 4);
    v19 = 0;
    memset(v18, 0, sizeof(v18));
    ge_precomp_0((uint64_t)v18);
    v14 = v40;
    for (k = 1; k != 16; ++k)
    {
      cmov((uint64_t)v18, (uint64_t)v14, ((v11 ^ k) - 1) >> 31);
      v14 += 15;
    }
    v38 = 0u;
    v39 = 0u;
    v36 = 0u;
    v37 = 0u;
    v34 = 0u;
    v35 = 0u;
    v32 = 0u;
    v33 = 0u;
    v30 = 0u;
    v31 = 0u;
    v28 = 0u;
    v29 = 0u;
    v26 = 0u;
    v27 = 0u;
    v24 = 0u;
    v25 = 0u;
    v22 = 0u;
    v23 = 0u;
    v20 = 0u;
    v21 = 0u;
    x25519_ge_p3_to_cached((uint64_t)&v30, (uint64_t)a1);
    x25519_ge_add((int *)&v20, (uint64_t)a1, (int *)&v30);
    x25519_ge_p1p1_to_p3(a1, (int *)&v20);
    ge_madd((int *)&v20, (uint64_t)a1, (int *)v18);
    result = x25519_ge_p1p1_to_p3(a1, (int *)&v20);
    --v9;
  }
  while (v9 < 0x40);
  return result;
}

double ge_p3_0(uint64_t a1)
{
  double result;

  *(_QWORD *)(a1 + 32) = 0;
  result = 0.0;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_QWORD *)(a1 + 72) = 0;
  *(_DWORD *)(a1 + 40) = 1;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_QWORD *)(a1 + 112) = 0;
  *(_DWORD *)(a1 + 80) = 1;
  *(_OWORD *)(a1 + 120) = 0u;
  *(_OWORD *)(a1 + 136) = 0u;
  *(_QWORD *)(a1 + 152) = 0;
  return result;
}

double ge_precomp_0(uint64_t a1)
{
  double result;

  *(_QWORD *)(a1 + 32) = 0;
  result = 0.0;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)a1 = 1;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_QWORD *)(a1 + 72) = 0;
  *(_DWORD *)(a1 + 40) = 1;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_QWORD *)(a1 + 112) = 0;
  return result;
}

uint64_t cmov(uint64_t result, uint64_t a2, int a3)
{
  uint64_t i;
  uint64_t j;
  uint64_t k;

  for (i = 0; i != 40; i += 4)
    *(_DWORD *)(result + i) = *(_DWORD *)(a2 + i) & -a3 | *(_DWORD *)(result + i) & (a3 - 1);
  for (j = 0; j != 40; j += 4)
    *(_DWORD *)(result + 40 + j) = *(_DWORD *)(a2 + 40 + j) & -a3 | *(_DWORD *)(result + 40 + j) & (a3 - 1);
  for (k = 0; k != 40; k += 4)
    *(_DWORD *)(result + 80 + k) = *(_DWORD *)(a2 + 80 + k) & -a3 | *(_DWORD *)(result + 80 + k) & (a3 - 1);
  return result;
}

uint64_t ge_madd(int *a1, uint64_t a2, int *a3)
{
  uint64_t v6;
  uint64_t i;
  uint64_t result;
  uint64_t j;
  uint64_t k;
  uint64_t m;
  uint64_t n;
  uint64_t ii;
  _OWORD v14[2];
  uint64_t v15;
  uint64_t v16;

  v6 = 0;
  v16 = *MEMORY[0x24BDAC8D0];
  do
  {
    a1[v6] = *(_DWORD *)(a2 + v6 * 4) + *(_DWORD *)(a2 + v6 * 4 + 40);
    ++v6;
  }
  while (v6 != 10);
  for (i = 0; i != 10; ++i)
    a1[i + 10] = *(_DWORD *)(a2 + i * 4 + 40) - *(_DWORD *)(a2 + i * 4);
  v15 = 0;
  memset(v14, 0, sizeof(v14));
  fe_mul(a1 + 20, a1, a3);
  fe_mul(a1 + 10, a1 + 10, a3 + 10);
  result = fe_mul(a1 + 30, a3 + 20, (int *)(a2 + 120));
  for (j = 0; j != 40; j += 4)
    *(_DWORD *)((char *)v14 + j) = 2 * *(_DWORD *)(a2 + 80 + j);
  for (k = 0; k != 10; ++k)
    a1[k] = a1[k + 20] - a1[k + 10];
  for (m = 0; m != 10; ++m)
    a1[m + 10] += a1[m + 20];
  for (n = 0; n != 10; ++n)
    a1[n + 20] = a1[n + 30] + *(_DWORD *)((char *)v14 + n * 4);
  for (ii = 0; ii != 10; ++ii)
    a1[ii + 30] = *(_DWORD *)((char *)v14 + ii * 4) - a1[ii + 30];
  return result;
}

uint64_t x25519_ge_scalarmult_base(__int128 *a1, int8x16_t *a2)
{
  uint64_t v3;
  int8x16_t v4;
  int8x16_t v5;
  char *v6;
  uint64_t v7;
  int v8;
  int v9;
  int v10;
  unint64_t v11;
  BOOL v12;
  int v13;
  unint64_t v14;
  uint64_t result;
  _OWORD v16[7];
  uint64_t v17;
  _OWORD v18[7];
  uint64_t v19;
  _OWORD v20[10];
  _OWORD v21[7];
  uint64_t v22;
  _BYTE v23[63];
  char v24;
  uint64_t v25;
  int8x16x2_t v26;

  v3 = 0;
  v25 = *MEMORY[0x24BDAC8D0];
  v4.i64[0] = 0xF0F0F0F0F0F0F0FLL;
  v4.i64[1] = 0xF0F0F0F0F0F0F0FLL;
  do
  {
    v5 = *a2++;
    v26.val[0] = vandq_s8(v5, v4);
    v26.val[1] = (int8x16_t)vshrq_n_u8((uint8x16_t)v5, 4uLL);
    v6 = &v23[v3];
    vst2q_s8(v6, v26);
    v3 += 32;
  }
  while (v3 != 64);
  v7 = 0;
  v8 = 0;
  do
  {
    v9 = v23[v7] + v8;
    v8 = (v9 + 8) << 24 >> 28;
    v23[v7++] = v9 - ((v9 + 8) & 0xF0);
  }
  while (v7 != 63);
  memset(v20, 0, sizeof(v20));
  memset(v16, 0, sizeof(v16));
  v17 = 0;
  v24 += v8;
  ge_p3_0((uint64_t)a1);
  v10 = 0;
  v11 = 1;
  do
  {
    table_select((uint64_t)v16, v10, (char)v23[v11]);
    ge_madd((int *)v20, (uint64_t)a1, (int *)v16);
    x25519_ge_p1p1_to_p3(a1, (int *)v20);
    ++v10;
    v12 = v11 >= 0x3E;
    v11 += 2;
  }
  while (!v12);
  v19 = 0;
  memset(v18, 0, sizeof(v18));
  v22 = 0;
  memset(v21, 0, sizeof(v21));
  ge_p3_to_p2((uint64_t)v21, a1);
  ge_p2_dbl(v20, (int *)v21);
  x25519_ge_p1p1_to_p2(v18, (int *)v20);
  ge_p2_dbl(v20, (int *)v18);
  x25519_ge_p1p1_to_p2(v18, (int *)v20);
  ge_p2_dbl(v20, (int *)v18);
  x25519_ge_p1p1_to_p2(v18, (int *)v20);
  ge_p2_dbl(v20, (int *)v18);
  x25519_ge_p1p1_to_p3(a1, (int *)v20);
  v13 = 0;
  v14 = 0;
  do
  {
    table_select((uint64_t)v16, v13, (char)v23[v14]);
    ge_madd((int *)v20, (uint64_t)a1, (int *)v16);
    result = x25519_ge_p1p1_to_p3(a1, (int *)v20);
    ++v13;
    v12 = v14 >= 0x3E;
    v14 += 2;
  }
  while (!v12);
  return result;
}

uint64_t table_select(uint64_t a1, int a2, int a3)
{
  int v6;
  char *v7;
  __int128 v8;
  __int128 v9;
  uint64_t v10;
  _OWORD v12[2];
  uint64_t v13;
  __int128 v14;
  __int128 v15;
  uint64_t v16;
  __int128 v17;
  __int128 v18;
  uint64_t v19;

  v6 = a3 - 2 * (a3 & (a3 >> 31));
  ge_precomp_0(a1);
  v7 = (char *)&k25519Precomp + 960 * a2;
  cmov(a1, (uint64_t)v7, ((v6 ^ 1u) - 1) >> 31);
  cmov(a1, (uint64_t)(v7 + 120), ((v6 ^ 2u) - 1) >> 31);
  cmov(a1, (uint64_t)(v7 + 240), ((v6 ^ 3u) - 1) >> 31);
  cmov(a1, (uint64_t)(v7 + 360), ((v6 ^ 4u) - 1) >> 31);
  cmov(a1, (uint64_t)(v7 + 480), ((v6 ^ 5u) - 1) >> 31);
  cmov(a1, (uint64_t)(v7 + 600), ((v6 ^ 6u) - 1) >> 31);
  cmov(a1, (uint64_t)(v7 + 720), ((v6 ^ 7u) - 1) >> 31);
  cmov(a1, (uint64_t)(v7 + 840), ((v6 ^ 8u) - 1) >> 31);
  v8 = *(_OWORD *)(a1 + 56);
  v12[0] = *(_OWORD *)(a1 + 40);
  v12[1] = v8;
  v17 = 0u;
  v18 = 0u;
  v9 = *(_OWORD *)(a1 + 16);
  v14 = *(_OWORD *)a1;
  v13 = *(_QWORD *)(a1 + 72);
  v19 = 0;
  v16 = *(_QWORD *)(a1 + 32);
  v10 = 80;
  v15 = v9;
  do
  {
    *(_DWORD *)((char *)v12 + v10) = -*(_DWORD *)(a1 + v10);
    v10 += 4;
  }
  while (v10 != 120);
  return cmov(a1, (uint64_t)v12, (a3 >> 7) & 1);
}

_DWORD *ge_p2_dbl(_DWORD *a1, int *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  unint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  unint64_t v67;
  unint64_t v68;
  int *v69;
  _DWORD *result;
  uint64_t i;
  uint64_t j;
  uint64_t k;
  uint64_t m;
  _OWORD v75[2];
  uint64_t v76;
  uint64_t v77;

  v77 = *MEMORY[0x24BDAC8D0];
  fe_sq(a1, a2);
  fe_sq(a1 + 20, a2 + 10);
  v4 = 0;
  v5 = a2[20];
  v6 = a2[21];
  v7 = a2[24];
  v8 = a2[25];
  v10 = a2[26];
  v9 = a2[27];
  v11 = 19 * (int)v10;
  v12 = a2[22];
  v13 = a2[23];
  v15 = a2[28];
  v14 = a2[29];
  v16 = 2 * v5;
  v17 = 2 * v6;
  v18 = 2 * v12;
  v19 = 38 * (int)v9;
  v20 = 2 * v13;
  v21 = 2 * v8;
  v22 = 19 * (int)v15;
  v23 = 38 * (int)v14;
  v24 = 2 * v5 * v6;
  v25 = 38 * (int)v8 * (uint64_t)(int)v8 + (int)v5 * (uint64_t)(int)v5 + v11 * 2 * v7;
  v26 = 2 * v6 * v6 + v12 * v16 + v11 * v10;
  v27 = v24 + v11 * 2 * v8 + v19 * v7 + v22 * 2 * v13 + v23 * v12;
  v28 = 2 * v13 * v17 + (int)v12 * (uint64_t)(int)v12;
  v29 = v25 + v19 * 2 * v13;
  v30 = v26 + v19 * 2 * v8;
  v31 = v17 * v12 + v13 * v16 + v19 * v10;
  v32 = v28 + v7 * v16 + v19 * v9 + 2 * v10 * v22;
  v33 = v7 * v18 + 2 * v13 * v13;
  v34 = v30 + v22 * 2 * v7;
  v35 = v31 + v22 * 2 * v8;
  v36 = v18 * v13 + v7 * v17 + v8 * v16 + v22 * 2 * v9;
  v37 = v33 + 2 * v8 * v17 + v10 * v16 + v22 * v15;
  v38 = 2 * v7 * v8;
  v39 = v20 * v7 + v8 * v18;
  v40 = v35 + v23 * v7;
  v41 = v32 + v23 * v21;
  v42 = v10 * v18 + (int)v7 * (uint64_t)(int)v7 + v21 * v20;
  v43 = v34 + v23 * v20;
  v44 = v38 + v10 * v20;
  v45 = v36 + v23 * v10;
  v46 = v39 + v10 * v17;
  v47 = v29 + v22 * v18 + v23 * v17;
  v48 = v37 + v23 * 2 * v9;
  v49 = v42 + 2 * v9 * v17;
  v50 = 2 * v47;
  v51 = 2 * v47 + 0x2000000;
  v52 = (v51 >> 26) + 2 * v27;
  v53 = v50 - (v51 & 0xFFFFFFFFFC000000);
  v54 = 2 * v41 + 0x2000000;
  v55 = (v54 >> 26) + 2 * v45;
  v56 = v46 + v9 * v16 + v23 * v15;
  v57 = v44 + v9 * v18 + v15 * v17;
  v58 = v49 + v15 * v16;
  v59 = ((v52 + 0x1000000) >> 25) + 2 * v43;
  v60 = v58 + v23 * v14;
  v61 = ((v55 + 0x1000000) >> 25) + 2 * v48;
  v62 = v57 + v14 * v16;
  v63 = ((v59 + 0x2000000) >> 26) + 2 * v40;
  v64 = ((v61 + 0x2000000) >> 26) + 2 * v56;
  v65 = ((v64 + 0x1000000) >> 25) + 2 * v60;
  v66 = ((v65 + 0x2000000) >> 26) + 2 * v62;
  v67 = v53 + 19 * ((v66 + 0x1000000) >> 25);
  a1[30] = v67 - ((v67 + 0x2000000) & 0xFC000000);
  a1[31] = v52 - ((v52 + 0x1000000) & 0xFE000000) + ((v67 + 0x2000000) >> 26);
  v68 = 2 * v41 - (v54 & 0xFFFFFFFFFC000000) + ((v63 + 0x1000000) >> 25);
  a1[32] = v59 - ((v59 + 0x2000000) & 0xFC000000);
  a1[33] = v63 - ((v63 + 0x1000000) & 0xFE000000);
  a1[34] = v68 - ((v68 + 0x2000000) & 0xFC000000);
  a1[35] = v55 - ((v55 + 0x1000000) & 0xFE000000) + ((v68 + 0x2000000) >> 26);
  a1[36] = v61 - ((v61 + 0x2000000) & 0xFC000000);
  a1[37] = v64 - ((v64 + 0x1000000) & 0xFE000000);
  a1[38] = v65 - ((v65 + 0x2000000) & 0xFC000000);
  a1[39] = v66 - ((v66 + 0x1000000) & 0xFE000000);
  v69 = a1 + 10;
  do
  {
    v69[v4] = a2[v4 + 10] + a2[v4];
    ++v4;
  }
  while (v4 != 10);
  v76 = 0;
  memset(v75, 0, sizeof(v75));
  result = fe_sq(v75, v69);
  for (i = 0; i != 10; ++i)
    a1[i + 10] = a1[i] + a1[i + 20];
  for (j = 0; j != 10; ++j)
    a1[j + 20] -= a1[j];
  for (k = 0; k != 10; ++k)
    a1[k] = *(_DWORD *)((char *)v75 + k * 4) - a1[k + 10];
  for (m = 0; m != 10; ++m)
    a1[m + 30] -= a1[m + 20];
  return result;
}

uint64_t x25519_ge_scalarmult(int *a1, uint64_t a2, __int128 *a3)
{
  int *v6;
  unint64_t v7;
  int *v8;
  _DWORD *v9;
  unsigned int v10;
  int v11;
  uint64_t v12;
  _BYTE *v13;
  uint64_t v14;
  int v15;
  uint64_t result;
  BOOL v17;
  _OWORD v18[10];
  _OWORD v19[10];
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  _BYTE v30[160];
  uint64_t v31;
  uint64_t v32;
  _BYTE v33[120];
  _QWORD v34[91];

  v34[90] = *MEMORY[0x24BDAC8D0];
  memset(v19, 0, sizeof(v19));
  ge_cached_0((uint64_t)v30);
  x25519_ge_p3_to_cached((uint64_t)&v31, (uint64_t)a3);
  v6 = (int *)v33;
  ge_p3_to_p2((uint64_t)v33, a3);
  v7 = 0;
  v8 = (int *)&v32;
  v9 = v34;
  do
  {
    ge_p2_dbl(v19, v6);
    v28 = 0u;
    v29 = 0u;
    v26 = 0u;
    v27 = 0u;
    v24 = 0u;
    v25 = 0u;
    v22 = 0u;
    v23 = 0u;
    v20 = 0u;
    v21 = 0u;
    x25519_ge_p1p1_to_p3(&v20, (int *)v19);
    x25519_ge_p3_to_cached((uint64_t)v8, (uint64_t)&v20);
    if (v7 + 2 <= 7)
      x25519_ge_p1p1_to_p2(v9, (int *)v19);
    x25519_ge_add((int *)v19, (uint64_t)a3, v8);
    v28 = 0u;
    v29 = 0u;
    v26 = 0u;
    v27 = 0u;
    v24 = 0u;
    v25 = 0u;
    v22 = 0u;
    v23 = 0u;
    v20 = 0u;
    v21 = 0u;
    x25519_ge_p1p1_to_p3(&v20, (int *)v19);
    x25519_ge_p3_to_cached((uint64_t)(v8 + 40), (uint64_t)&v20);
    if (v7 + 2 <= 6)
      x25519_ge_p1p1_to_p2(v9 + 30, (int *)v19);
    v7 += 2;
    v8 += 80;
    v9 += 60;
    v6 += 30;
  }
  while (v7 < 0xE);
  ge_p2_0((uint64_t)a1);
  v10 = 0;
  v28 = 0u;
  v29 = 0u;
  v26 = 0u;
  v27 = 0u;
  v24 = 0u;
  v25 = 0u;
  v22 = 0u;
  v23 = 0u;
  v20 = 0u;
  v21 = 0u;
  do
  {
    ge_p2_dbl(v19, a1);
    x25519_ge_p1p1_to_p2(a1, (int *)v19);
    ge_p2_dbl(v19, a1);
    x25519_ge_p1p1_to_p2(a1, (int *)v19);
    ge_p2_dbl(v19, a1);
    x25519_ge_p1p1_to_p2(a1, (int *)v19);
    ge_p2_dbl(v19, a1);
    x25519_ge_p1p1_to_p3(&v20, (int *)v19);
    v11 = (*(unsigned __int8 *)(a2 - (v10 >> 3) + 31) >> (~(_BYTE)v10 & 4)) & 0xF;
    memset(v18, 0, sizeof(v18));
    ge_cached_0((uint64_t)v18);
    v12 = 0;
    v13 = v30;
    do
    {
      v14 = 0;
      v15 = (int)((v11 ^ v12) - 1) >> 31;
      do
      {
        *(_DWORD *)((char *)v18 + v14) = *(_DWORD *)&v13[v14] & v15 | *(_DWORD *)((_BYTE *)v18 + v14) & ~v15;
        v14 += 4;
      }
      while (v14 != 40);
      do
      {
        *(_DWORD *)((char *)v18 + v14) = *(_DWORD *)&v13[v14] & v15 | *(_DWORD *)((_BYTE *)v18 + v14) & ~v15;
        v14 += 4;
      }
      while (v14 != 80);
      do
      {
        *(_DWORD *)((char *)v18 + v14) = *(_DWORD *)&v13[v14] & v15 | *(_DWORD *)((_BYTE *)v18 + v14) & ~v15;
        v14 += 4;
      }
      while (v14 != 120);
      do
      {
        *(_DWORD *)((char *)v18 + v14) = *(_DWORD *)&v13[v14] & v15 | *(_DWORD *)((_BYTE *)v18 + v14) & ~v15;
        v14 += 4;
      }
      while (v14 != 160);
      ++v12;
      v13 += 160;
    }
    while (v12 != 16);
    x25519_ge_add((int *)v19, (uint64_t)&v20, (int *)v18);
    result = x25519_ge_p1p1_to_p2(a1, (int *)v19);
    v17 = v10 >= 0xFC;
    v10 += 4;
  }
  while (!v17);
  return result;
}

double ge_cached_0(uint64_t a1)
{
  double result;

  *(_QWORD *)(a1 + 32) = 0;
  result = 0.0;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)a1 = 1;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_QWORD *)(a1 + 72) = 0;
  *(_DWORD *)(a1 + 40) = 1;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_QWORD *)(a1 + 112) = 0;
  *(_DWORD *)(a1 + 80) = 1;
  *(_OWORD *)(a1 + 120) = 0u;
  *(_OWORD *)(a1 + 136) = 0u;
  *(_QWORD *)(a1 + 152) = 0;
  return result;
}

__n128 ge_p3_to_p2(uint64_t a1, __int128 *a2)
{
  __int128 v2;
  __int128 v3;
  __int128 v4;
  __int128 v5;
  __n128 result;
  __int128 v7;

  v2 = *a2;
  v3 = a2[1];
  *(_QWORD *)(a1 + 32) = *((_QWORD *)a2 + 4);
  *(_OWORD *)a1 = v2;
  *(_OWORD *)(a1 + 16) = v3;
  v4 = *(__int128 *)((char *)a2 + 40);
  v5 = *(__int128 *)((char *)a2 + 56);
  *(_QWORD *)(a1 + 72) = *((_QWORD *)a2 + 9);
  *(_OWORD *)(a1 + 56) = v5;
  *(_OWORD *)(a1 + 40) = v4;
  result = (__n128)a2[5];
  v7 = a2[6];
  *(_QWORD *)(a1 + 112) = *((_QWORD *)a2 + 14);
  *(__n128 *)(a1 + 80) = result;
  *(_OWORD *)(a1 + 96) = v7;
  return result;
}

double ge_p2_0(uint64_t a1)
{
  double result;

  *(_QWORD *)(a1 + 32) = 0;
  result = 0.0;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_QWORD *)(a1 + 72) = 0;
  *(_DWORD *)(a1 + 40) = 1;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_QWORD *)(a1 + 112) = 0;
  *(_DWORD *)(a1 + 80) = 1;
  return result;
}

unsigned __int16 *x25519_sc_reduce(unsigned __int16 *result)
{
  unint64_t v1;
  unint64_t v2;
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  unint64_t v20;
  unint64_t v21;
  unint64_t v22;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  unint64_t v28;
  unint64_t v29;
  uint64_t v30;
  uint64_t v31;
  unint64_t v32;
  uint64_t v33;
  unint64_t v34;
  unint64_t v35;
  unint64_t v36;
  unint64_t v37;
  unint64_t v38;
  unint64_t v39;
  unint64_t v40;
  unint64_t v41;
  unint64_t v42;
  unint64_t v43;
  unint64_t v44;
  unint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  unint64_t v49;
  unint64_t v50;
  unint64_t v51;
  unint64_t v52;
  unint64_t v53;
  unint64_t v54;
  unint64_t v55;
  unint64_t v56;
  unint64_t v57;
  unint64_t v58;
  unint64_t v59;
  unint64_t v60;
  unint64_t v61;
  unint64_t v62;
  unint64_t v63;
  unint64_t v64;
  uint64_t v65;
  unint64_t v66;
  unint64_t v67;
  unint64_t v68;
  unint64_t v69;
  unint64_t v70;
  uint64_t v71;
  unint64_t v72;
  unint64_t v73;
  uint64_t v74;
  unint64_t v75;
  uint64_t v76;
  unint64_t v77;
  unint64_t v78;
  uint64_t v79;
  unint64_t v80;
  int64_t v81;
  uint64_t v82;
  unint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  int64_t v88;
  uint64_t v89;
  int64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  int64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  unint64_t v105;

  v1 = *(unsigned int *)((char *)result + 15);
  v2 = *((unsigned int *)result + 9);
  v3 = (v2 >> 24) | ((unint64_t)*((unsigned __int8 *)result + 40) << 8) | ((unint64_t)*((unsigned __int8 *)result + 41) << 16);
  v4 = ((unint64_t)(HIBYTE(*((_DWORD *)result + 11)) | (*((unsigned __int8 *)result + 48) << 8) | (*((unsigned __int8 *)result + 49) << 16)) >> 2) & 0x1FFFFF;
  v5 = ((unint64_t)*(unsigned int *)((char *)result + 49) >> 7) & 0x1FFFFF;
  v6 = ((unint64_t)*((unsigned int *)result + 13) >> 4) & 0x1FFFFF;
  v7 = ((unint64_t)(HIBYTE(*((_DWORD *)result + 13)) | (*((unsigned __int8 *)result + 56) << 8) | (*((unsigned __int8 *)result + 57) << 16)) >> 1) & 0x1FFFFF;
  v8 = ((v1 >> 6) & 0x1FFFFF) + 666643 * v4;
  v9 = (*(unsigned __int16 *)((char *)result + 21) | ((unint64_t)(*((_BYTE *)result + 23) & 0x1F) << 16))
     + 470296 * v5
     + 666643 * v6
     + 654183 * v4;
  v10 = (((v1 >> 24) | ((unint64_t)*((unsigned __int8 *)result + 19) << 8) | ((unint64_t)*((unsigned __int8 *)result + 20) << 16)) >> 3)
      + 666643 * v5
      + 470296 * v4
      + ((unint64_t)(v8 + 0x100000) >> 21);
  v11 = (((unint64_t)*(unsigned int *)((char *)result + 23) >> 5) & 0x1FFFFF)
      + 654183 * v5
      + 470296 * v6
      - 997805 * (int)v4
      + 666643 * v7
      + ((v9 + 0x100000) >> 21);
  v12 = (((unint64_t)(HIBYTE(*(_DWORD *)((char *)result + 23)) | (*((unsigned __int8 *)result + 27) << 8) | (*((unsigned __int8 *)result + 28) << 16)) >> 2) & 0x1FFFFF)
      - 997805 * (int)v5
      + 654183 * v6
      + 136657 * v4;
  v13 = (((unint64_t)*((unsigned int *)result + 7) >> 7) & 0x1FFFFF)
      + 136657 * v5
      - 997805 * (int)v6
      - 683901 * (int)v4;
  v14 = (((unint64_t)*(unsigned int *)((char *)result + 31) >> 4) & 0x1FFFFF)
      - 683901 * (int)v5
      + 136657 * v6;
  v15 = (((unint64_t)(HIBYTE(*(_DWORD *)((char *)result + 31)) | (*((unsigned __int8 *)result + 35) << 8) | (*((unsigned __int8 *)result + 36) << 16)) >> 1) & 0x1FFFFF)
      - 683901 * (int)v6;
  v16 = (unint64_t)*((unsigned int *)result + 15) >> 3;
  v17 = ((v2 >> 6) & 0x1FFFFF) - 997805 * (int)v16;
  v18 = (v3 >> 3) + 136657 * v16;
  v19 = (result[21] | ((unint64_t)(result[22] & 0x1F) << 16)) - 683901 * (int)v16;
  v20 = v14 + 470296 * v16;
  v21 = v13 + 666643 * v16;
  v22 = v15 + 654183 * v16;
  v23 = ((unint64_t)*(unsigned int *)((char *)result + 57) >> 6) & 0x1FFFFF;
  v24 = v18 - 683901 * (int)v23;
  v25 = v17 + 136657 * v23 - 683901 * (int)v7;
  v26 = v20 + 654183 * v23 - 997805 * (int)v7;
  v27 = v12 + 666643 * v23 + 470296 * v7;
  v28 = v21 + 470296 * v23;
  v29 = v22 - 997805 * (int)v23;
  v30 = v28 + 654183 * v7 + ((v27 + 0x100000) >> 21);
  v31 = v29 + 136657 * v7 + ((v26 + 0x100000) >> 21);
  v32 = v26 - ((v26 + 0x100000) & 0xFFFFFFFFFFE00000);
  v33 = v24 + ((v25 + 0x100000) >> 21);
  v34 = (((unint64_t)*((unsigned int *)result + 11) >> 5) & 0x1FFFFF) + ((uint64_t)(v19 + 0x100000) >> 21);
  v35 = v9 - ((v9 + 0x100000) & 0xFFFFFE00000) + ((v10 + 0x100000) >> 21);
  v36 = v10 - ((v10 + 0x100000) & 0x7FFFFFFFFFE00000);
  v37 = v32 + ((v30 + 0x100000) >> 21);
  v38 = v30 - ((v30 + 0x100000) & 0xFFFFFFFFFFE00000);
  v39 = v25 - ((v25 + 0x100000) & 0xFFFFFFFFFFE00000) + ((v31 + 0x100000) >> 21);
  v40 = v31 - ((v31 + 0x100000) & 0xFFFFFFFFFFE00000);
  v41 = v19 - ((v19 + 0x100000) & 0xFFFFFFFFFFE00000) + ((v33 + 0x100000) >> 21);
  v42 = v33 - ((v33 + 0x100000) & 0xFFFFFFFFFFE00000);
  v43 = (((unint64_t)*(unsigned int *)((char *)result + 7) >> 7) & 0x1FFFFF) + 666643 * v42;
  v44 = (((unint64_t)*(unsigned int *)(result + 5) >> 4) & 0x1FFFFF) + 666643 * v41 + 470296 * v42;
  v45 = (((unint64_t)(HIBYTE(*(_DWORD *)(result + 5)) | (*((unsigned __int8 *)result + 14) << 8) | (*((unsigned __int8 *)result + 15) << 16)) >> 1) & 0x1FFFFF)
      + 666643 * v34
      + 470296 * v41
      + 654183 * v42;
  v46 = v8 - ((v8 + 0x100000) & 0x7FFFFE00000) + 470296 * v34 + 654183 * v41 - 997805 * v42;
  v47 = v36 + 654183 * v34 - 997805 * v41 + 136657 * v42;
  v48 = v35 - 997805 * v34 + 136657 * v41 - 683901 * v42;
  v49 = (((unint64_t)(HIBYTE(*(_DWORD *)(result + 1)) | (*((unsigned __int8 *)result + 6) << 8) | (*((unsigned __int8 *)result + 7) << 16)) >> 2) & 0x1FFFFF)
      + 666643 * v39;
  v50 = v43 + 470296 * v39;
  v51 = v44 + 654183 * v39;
  v52 = v45 - 997805 * v39;
  v53 = v46 + 136657 * v39;
  v54 = v47 - 683901 * v39;
  v55 = (((unint64_t)*(unsigned int *)(result + 1) >> 5) & 0x1FFFFF) + 666643 * v40;
  v56 = v49 + 470296 * v40;
  v57 = v50 + 654183 * v40;
  v58 = v51 - 997805 * v40;
  v59 = v52 + 136657 * v40;
  v60 = v53 - 683901 * v40;
  v61 = v27 - 683901 * v34 - ((v27 + 0x100000) & 0xFFFFFFFFFFE00000) + ((uint64_t)(v11 + 0x100000) >> 21);
  v62 = (*result | ((unint64_t)(result[1] & 0x1F) << 16)) + 666643 * v37;
  v63 = v56 + 654183 * v37;
  v64 = v58 + 136657 * v37;
  v65 = v55 + 470296 * v37 + ((uint64_t)(v62 + 0x100000) >> 21);
  v66 = v54 + ((uint64_t)(v60 + 0x100000) >> 21);
  v67 = v11 + 136657 * v34 - ((v11 + 0x100000) & 0xFFFFFFFFFFE00000) - 683901 * v41 + ((v48 + 0x100000) >> 21);
  v68 = v48 - ((v48 + 0x100000) & 0xFFFFFFFFFFE00000);
  v69 = v38 + ((uint64_t)(v61 + 0x100000) >> 21);
  v70 = v61 - ((v61 + 0x100000) & 0xFFFFFFFFFFE00000);
  v71 = v65 + 0x100000;
  v72 = v70 + ((uint64_t)(v67 + 0x100000) >> 21);
  v73 = v67 - ((v67 + 0x100000) & 0xFFFFFFFFFFE00000);
  v74 = (uint64_t)(v69 + 0x100000) >> 21;
  v75 = v65 + 470296 * v74 - ((v65 + 0x100000) & 0xFFFFFFFFFFE00000);
  v76 = v57 - 997805 * v37 + ((uint64_t)(v63 + 0x100000) >> 21);
  v77 = v63 + 654183 * v74 - ((v63 + 0x100000) & 0xFFFFFFFFFFE00000) + (v71 >> 21);
  v78 = v76 - 997805 * v74 - ((v76 + 0x100000) & 0xFFFFFFFFFFE00000);
  v79 = v59 - 683901 * v37 + ((uint64_t)(v64 + 0x100000) >> 21);
  v80 = v64 + 136657 * v74 - ((v64 + 0x100000) & 0xFFFFFFFFFFE00000) + ((v76 + 0x100000) >> 21);
  v81 = v62 - ((v62 + 0x100000) & 0xFFFFFFFFFFE00000) + 666643 * v74;
  v82 = v79 - 683901 * v74;
  v79 += 0x100000;
  v83 = v60 - ((v60 + 0x100000) & 0xFFFFFFFFFFE00000) + (v79 >> 21);
  v84 = v75 + (v81 >> 21);
  v85 = v77 + (v84 >> 21);
  v86 = v78 + (v85 >> 21);
  v87 = v80 + (v86 >> 21);
  v88 = v82 - (v79 & 0xFFFFFFFFFFE00000) + (v87 >> 21);
  v89 = v83 + (v88 >> 21);
  v90 = v66 - ((v66 + 0x100000) & 0xFFFFFFFFFFE00000) + (v89 >> 21);
  v91 = v68 + ((uint64_t)(v66 + 0x100000) >> 21) + (v90 >> 21);
  v92 = v73 + (v91 >> 21);
  v93 = v72 + (v92 >> 21);
  v94 = v69 - ((v69 + 0x100000) & 0xFFFFFFFFFFE00000) + (v93 >> 21);
  v95 = (v81 & 0x1FFFFF) + 666643 * (v94 >> 21);
  *((_BYTE *)result + 1) = (unsigned __int16)(v81 + 11283 * (v94 >> 21)) >> 8;
  v96 = (v84 & 0x1FFFFF) + 470296 * (v94 >> 21) + (v95 >> 21);
  *(_BYTE *)result = v81 + 19 * (v94 >> 21);
  *((_BYTE *)result + 2) = ((unint64_t)((v81 & 0x1FFFFF) + 666643 * (v94 >> 21)) >> 16) & 0x1F | (32 * (v84 + 24 * (v94 >> 21) + (v95 >> 21)));
  *((_BYTE *)result + 3) = (unint64_t)v96 >> 3;
  *((_BYTE *)result + 4) = (unint64_t)v96 >> 11;
  v97 = (v85 & 0x1FFFFF) + 654183 * (v94 >> 21) + (v96 >> 21);
  *((_BYTE *)result + 5) = (v96 >> 19) & 3 | (4 * (v85 + 103 * (v94 >> 21) + (v96 >> 21)));
  *((_BYTE *)result + 6) = (unint64_t)v97 >> 6;
  v98 = (v86 & 0x1FFFFF) - 997805 * (v94 >> 21) + (v97 >> 21);
  *((_BYTE *)result + 7) = (v97 >> 14) & 0x7F | (((_BYTE)v86
                                                              - -83 * (v94 >> 21)
                                                              + (v97 >> 21)) << 7);
  *((_BYTE *)result + 8) = (unint64_t)v98 >> 1;
  *((_BYTE *)result + 9) = (unint64_t)v98 >> 9;
  v99 = (v87 & 0x1FFFFF) + 136657 * (v94 >> 21) + (v98 >> 21);
  *((_BYTE *)result + 10) = (v98 >> 17) & 0xF | (16 * (v87 - 47 * (v94 >> 21) + (v98 >> 21)));
  *((_BYTE *)result + 11) = (unint64_t)v99 >> 4;
  *((_BYTE *)result + 12) = (unint64_t)v99 >> 12;
  v100 = (v88 & 0x1FFFFF) - 683901 * (v94 >> 21) + (v99 >> 21);
  *((_BYTE *)result + 13) = ((v99 & 0x100000) != 0) | (2 * (v88 - 125 * (v94 >> 21) + (v99 >> 21)));
  *((_BYTE *)result + 14) = (unint64_t)v100 >> 7;
  v101 = (v89 & 0x1FFFFF) + (v100 >> 21);
  *((_BYTE *)result + 15) = (v100 >> 15) & 0x3F | (((_BYTE)v89 + (v100 >> 21)) << 6);
  *((_BYTE *)result + 16) = (unint64_t)v101 >> 2;
  *((_BYTE *)result + 17) = (unint64_t)v101 >> 10;
  v102 = (v90 & 0x1FFFFF) + (v101 >> 21);
  *((_BYTE *)result + 18) = (v101 >> 18) & 7 | (8 * (v66 + (v89 >> 21) + (v101 >> 21)));
  *((_BYTE *)result + 19) = (unint64_t)v102 >> 5;
  *((_BYTE *)result + 20) = (unint64_t)v102 >> 13;
  *((_BYTE *)result + 22) = (unsigned __int16)(v91 + (v102 >> 21)) >> 8;
  v103 = (v92 & 0x1FFFFF) + (((v91 & 0x1FFFFF) + (v102 >> 21)) >> 21);
  *((_BYTE *)result + 21) = v91 + (v102 >> 21);
  *((_BYTE *)result + 23) = ((unint64_t)((v91 & 0x1FFFFF) + (v102 >> 21)) >> 16) & 0x1F | (32 * v103);
  *((_BYTE *)result + 24) = (unint64_t)v103 >> 3;
  *((_BYTE *)result + 25) = (unint64_t)v103 >> 11;
  v104 = (v93 & 0x1FFFFF) + (v103 >> 21);
  *((_BYTE *)result + 26) = (v103 >> 19) & 3 | (4 * v104);
  *((_BYTE *)result + 27) = (unint64_t)v104 >> 6;
  v105 = (v94 & 0x1FFFFF) + (v104 >> 21);
  *((_BYTE *)result + 28) = (v104 >> 14) & 0x7F | ((_BYTE)v105 << 7);
  *((_BYTE *)result + 29) = v105 >> 1;
  *((_BYTE *)result + 30) = v105 >> 9;
  *((_BYTE *)result + 31) = v105 >> 17;
  return result;
}

uint64_t ED25519_public_from_private(uint64_t a1, unsigned __int8 *d)
{
  __int128 v4[10];
  int8x16_t md;
  char v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  SHA512(d, 0x20uLL, (unsigned __int8 *)&md);
  md.i8[0] &= 0xF8u;
  v6 = v6 & 0x3F | 0x40;
  memset(v4, 0, sizeof(v4));
  x25519_ge_scalarmult_base(v4, &md);
  return ge_p3_tobytes(a1, (int *)v4);
}

uint64_t ge_p3_tobytes(uint64_t a1, int *a2)
{
  uint64_t result;
  _OWORD v5[2];
  uint64_t v6;
  _OWORD v7[2];
  uint64_t v8;
  _OWORD v9[2];
  uint64_t v10;
  _BYTE v11[32];
  uint64_t v12;

  v12 = *MEMORY[0x24BDAC8D0];
  v10 = 0;
  memset(v9, 0, sizeof(v9));
  v8 = 0;
  memset(v7, 0, sizeof(v7));
  v6 = 0;
  memset(v5, 0, sizeof(v5));
  fe_invert(v9, a2 + 20);
  fe_mul(v7, a2, (int *)v9);
  fe_mul(v5, a2 + 10, (int *)v9);
  fe_tobytes(a1, v5);
  result = fe_tobytes((uint64_t)v11, v7);
  *(_BYTE *)(a1 + 31) ^= v11[0] << 7;
  return result;
}

uint64_t ED25519_keypair(uint64_t a1, void *__buf)
{
  arc4random_buf(__buf, 0x20uLL);
  return ED25519_public_from_private(a1, (unsigned __int8 *)__buf);
}

uint64_t ED25519_sign(_BYTE *a1, const void *a2, size_t a3, const void *a4, unsigned __int8 *d)
{
  unsigned int v9;
  unsigned int v10;
  unsigned int v11;
  unsigned int v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t v20;
  unint64_t v21;
  unint64_t v22;
  unint64_t v23;
  unint64_t v24;
  unint64_t v25;
  unint64_t v26;
  unint64_t v27;
  unint64_t v28;
  unint64_t v29;
  unint64_t v30;
  unint64_t v31;
  unint64_t v32;
  unint64_t v33;
  unint64_t v34;
  unint64_t v35;
  unint64_t v36;
  unint64_t v37;
  unint64_t v38;
  unint64_t v39;
  unint64_t v40;
  unint64_t v41;
  unint64_t v42;
  unint64_t v43;
  unint64_t v44;
  unint64_t v45;
  unint64_t v46;
  unint64_t v47;
  unint64_t v48;
  unint64_t v49;
  unint64_t v50;
  unint64_t v51;
  unint64_t v52;
  unint64_t v53;
  unint64_t v54;
  unint64_t v55;
  unint64_t v56;
  unint64_t v57;
  unint64_t v58;
  unint64_t v59;
  unint64_t v60;
  unint64_t v61;
  unint64_t v62;
  unint64_t v63;
  unint64_t v64;
  unint64_t v65;
  unint64_t v66;
  unint64_t v67;
  unint64_t v68;
  unint64_t v69;
  unint64_t v70;
  unint64_t v71;
  unint64_t v72;
  unint64_t v73;
  unint64_t v74;
  unint64_t v75;
  unint64_t v76;
  unint64_t v77;
  unint64_t v78;
  unint64_t v79;
  unint64_t v80;
  unint64_t v81;
  unint64_t v82;
  unint64_t v83;
  unint64_t v84;
  uint64_t v85;
  unint64_t v86;
  unint64_t v87;
  unint64_t v88;
  unint64_t v89;
  unint64_t v90;
  unint64_t v91;
  unint64_t v92;
  unint64_t v93;
  unint64_t v94;
  unint64_t v95;
  unint64_t v96;
  unint64_t v97;
  unint64_t v98;
  unint64_t v99;
  unint64_t v100;
  uint64_t v101;
  uint64_t v102;
  unint64_t v103;
  unint64_t v104;
  unint64_t v105;
  uint64_t v106;
  unint64_t v107;
  unint64_t v108;
  unint64_t v109;
  uint64_t v110;
  uint64_t v111;
  unint64_t v112;
  int64_t v113;
  unint64_t v114;
  int64_t v115;
  uint64_t v116;
  int64_t v117;
  int64_t v118;
  int64_t v119;
  int64_t v120;
  int64_t v121;
  int64_t v122;
  int64_t v123;
  int64_t v124;
  uint64_t v125;
  int64_t v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  uint64_t v135;
  uint64_t v136;
  uint64_t v137;
  unint64_t v138;
  unint64_t v140;
  unint64_t v141;
  unint64_t v142;
  unint64_t v143;
  unint64_t v144;
  unint64_t v145;
  unint64_t v146;
  unint64_t v147;
  unint64_t v148;
  unint64_t v149;
  __int128 v150[10];
  SHA512_CTX c;
  unsigned __int8 v152[2];
  unsigned int v153;
  unsigned __int8 v154;
  _BYTE v155[7];
  unsigned __int8 v156;
  unsigned int v157;
  unsigned __int8 v158;
  unsigned __int8 v159;
  unsigned __int16 v160;
  unsigned int v161;
  unsigned __int8 v162;
  unsigned int v163;
  unsigned __int8 v164[2];
  unsigned int v165;
  unsigned __int8 v166;
  _BYTE v167[7];
  unsigned __int8 v168;
  unsigned int v169;
  unsigned __int8 v170;
  unsigned __int8 v171;
  unsigned __int16 v172;
  unsigned int v173;
  unsigned __int8 v174;
  unsigned int v175;
  unsigned __int8 md[2];
  unsigned int v177;
  unsigned __int8 v178;
  _BYTE v179[7];
  unsigned __int8 v180;
  unsigned int v181;
  unsigned __int8 v182;
  unsigned __int8 v183;
  unsigned __int16 v184;
  unsigned int v185;
  unsigned __int8 v186;
  unsigned int v187;
  _QWORD v188[7];

  v188[4] = *MEMORY[0x24BDAC8D0];
  SHA512(d, 0x20uLL, md);
  md[0] &= 0xF8u;
  HIBYTE(v187) = HIBYTE(v187) & 0x3F | 0x40;
  memset(&c, 0, sizeof(c));
  SHA512_Init(&c);
  SHA512_Update(&c, v188, 0x20uLL);
  SHA512_Update(&c, a2, a3);
  SHA512_Final(v164, &c);
  x25519_sc_reduce((unsigned __int16 *)v164);
  memset(v150, 0, sizeof(v150));
  x25519_ge_scalarmult_base(v150, (int8x16_t *)v164);
  ge_p3_tobytes((uint64_t)a1, (int *)v150);
  SHA512_Init(&c);
  SHA512_Update(&c, a1, 0x20uLL);
  SHA512_Update(&c, a4, 0x20uLL);
  SHA512_Update(&c, a2, a3);
  SHA512_Final(v152, &c);
  x25519_sc_reduce((unsigned __int16 *)v152);
  v9 = *(unsigned __int16 *)v152 | ((v153 & 0x1F) << 16);
  v10 = v160 | ((v161 & 0x1F) << 16);
  v11 = *(unsigned __int16 *)md | ((v177 & 0x1F) << 16);
  v12 = v184 | ((v185 & 0x1F) << 16);
  v13 = ((unint64_t)v153 >> 5) & 0x1FFFFF;
  v14 = ((unint64_t)(HIBYTE(v153) | (v154 << 8) | (v155[0] << 16)) >> 2) & 0x1FFFFF;
  v15 = ((unint64_t)v177 >> 5) & 0x1FFFFF;
  v16 = ((unint64_t)(HIBYTE(v177) | (v178 << 8) | (v179[0] << 16)) >> 2) & 0x1FFFFF;
  v149 = v15 * v13
       + v11 * (unint64_t)v14
       + v16 * v9
       + (((unint64_t)(HIBYTE(v165) | (v166 << 8) | (v167[0] << 16)) >> 2) & 0x1FFFFF);
  v17 = ((unint64_t)*(unsigned int *)v155 >> 7) & 0x1FFFFF;
  v18 = ((unint64_t)*(unsigned int *)&v155[3] >> 4) & 0x1FFFFF;
  v19 = ((unint64_t)*(unsigned int *)v179 >> 7) & 0x1FFFFF;
  v20 = ((unint64_t)*(unsigned int *)&v179[3] >> 4) & 0x1FFFFF;
  v21 = v15 * (unint64_t)v17
      + v11 * v18
      + v19 * (unint64_t)v13
      + v9 * (unint64_t)v20
      + v16 * (unint64_t)v14
      + (((unint64_t)*(unsigned int *)&v167[3] >> 4) & 0x1FFFFF);
  v22 = ((unint64_t)(v155[6] | (v156 << 8) | (v157 << 16)) >> 1) & 0x1FFFFF;
  v23 = ((unint64_t)v157 >> 6) & 0x1FFFFF;
  v24 = ((unint64_t)v181 >> 6) & 0x1FFFFF;
  v25 = ((unint64_t)(v179[6] | (v180 << 8) | (v181 << 16)) >> 1) & 0x1FFFFF;
  v147 = v22 * (unint64_t)v15
       + v11 * (unint64_t)v23
       + v19 * (unint64_t)v17
       + v14 * (unint64_t)v20
       + v16 * (unint64_t)v18
       + v9 * (unint64_t)v24
       + v25 * (unint64_t)v13
       + (((unint64_t)v169 >> 6) & 0x1FFFFF);
  v26 = (((unint64_t)v157 >> 24) | ((unint64_t)v158 << 8) | ((unint64_t)v159 << 16)) >> 3;
  v27 = (((unint64_t)v181 >> 24) | ((unint64_t)v182 << 8) | ((unint64_t)v183 << 16)) >> 3;
  v146 = v26 * (unint64_t)v15
       + v11 * (unint64_t)v10
       + v22 * (unint64_t)v19
       + v20 * (unint64_t)v18
       + v16 * (unint64_t)v23
       + v14 * (unint64_t)v24
       + v25 * (unint64_t)v17
       + v27 * (unint64_t)v13
       + v12 * (unint64_t)v9
       + v172
       + ((unint64_t)(v173 & 0x1F) << 16);
  v28 = ((unint64_t)v161 >> 5) & 0x1FFFFF;
  v29 = ((unint64_t)(HIBYTE(v161) | (v162 << 8) | (v163 << 16)) >> 2) & 0x1FFFFF;
  v30 = ((unint64_t)v185 >> 5) & 0x1FFFFF;
  v31 = ((unint64_t)(HIBYTE(v185) | (v186 << 8) | (v187 << 16)) >> 2) & 0x1FFFFF;
  v145 = v15 * v28
       + v11 * v29
       + v26 * (unint64_t)v19
       + v20 * (unint64_t)v23
       + v16 * (unint64_t)v10
       + v24 * (unint64_t)v18
       + v25 * (unint64_t)v22
       + v27 * (unint64_t)v17
       + v30 * v13
       + v12 * (unint64_t)v14
       + v31 * v9
       + (((unint64_t)(HIBYTE(v173) | (v174 << 8) | (v175 << 16)) >> 2) & 0x1FFFFF);
  v32 = (*(unsigned __int16 *)v164 | ((unint64_t)(v165 & 0x1F) << 16)) + v11 * (unint64_t)v9;
  v33 = v9 * (unint64_t)v15
      + v11 * (unint64_t)v13
      + (((unint64_t)v165 >> 5) & 0x1FFFFF)
      + ((v32 + 0x100000) >> 21);
  v148 = v32 - ((v32 + 0x100000) & 0xFFFFFE00000);
  v34 = v14 * (unint64_t)v15
      + v11 * (unint64_t)v17
      + v9 * (unint64_t)v19
      + v16 * (unint64_t)v13
      + (((unint64_t)*(unsigned int *)v167 >> 7) & 0x1FFFFF);
  v143 = v15 * (unint64_t)v18
       + v11 * (unint64_t)v22
       + v14 * (unint64_t)v19
       + v20 * (unint64_t)v13
       + v16 * (unint64_t)v17
       + v25 * (unint64_t)v9
       + ((v21 + 0x100000) >> 21)
       + (((unint64_t)(v167[6] | (v168 << 8) | (v169 << 16)) >> 1) & 0x1FFFFF);
  v35 = v21 - ((v21 + 0x100000) & 0xFFFFFFFFFFE00000);
  v141 = v15 * (unint64_t)v23
       + v11 * (unint64_t)v26
       + v19 * (unint64_t)v18
       + v20 * (unint64_t)v17
       + v16 * (unint64_t)v22
       + v24 * (unint64_t)v13
       + v25 * (unint64_t)v14
       + v27 * (unint64_t)v9
       + ((((unint64_t)v169 >> 24) | ((unint64_t)v170 << 8) | ((unint64_t)v171 << 16)) >> 3);
  v140 = v10 * (unint64_t)v15
       + v11 * (unint64_t)v28
       + v19 * (unint64_t)v23
       + v22 * (unint64_t)v20
       + v16 * (unint64_t)v26
       + v24 * (unint64_t)v17
       + v25 * (unint64_t)v18
       + v27 * (unint64_t)v14
       + v9 * (unint64_t)v30
       + v12 * (unint64_t)v13
       + (((unint64_t)v173 >> 5) & 0x1FFFFF);
  v36 = (unint64_t)v163 >> 7;
  v37 = v29 * (unint64_t)v15 + v11 * (unint64_t)v36;
  v38 = (unint64_t)v187 >> 7;
  v39 = v37
      + v10 * (unint64_t)v19
      + v26 * (unint64_t)v20
      + v16 * (unint64_t)v28
      + v22 * (unint64_t)v24
      + v25 * (unint64_t)v23
      + v27 * (unint64_t)v18
      + v14 * (unint64_t)v30
      + v12 * (unint64_t)v17
      + v9 * (unint64_t)v38;
  v40 = v15 * (unint64_t)v36
      + v19 * (unint64_t)v28
      + v10 * (unint64_t)v20
      + v16 * (unint64_t)v29
      + v24 * (unint64_t)v23
      + v25 * (unint64_t)v26
      + v27 * (unint64_t)v22
      + v30 * (unint64_t)v17
      + v12 * (unint64_t)v18
      + v38 * (unint64_t)v13;
  v41 = v39 + v31 * (unint64_t)v13 + ((unint64_t)v175 >> 7);
  v42 = v40 + v31 * (unint64_t)v14;
  v43 = v19 * (unint64_t)v36
      + v29 * (unint64_t)v20
      + v10 * (unint64_t)v24
      + v25 * (unint64_t)v28
      + v27 * (unint64_t)v26
      + v22 * (unint64_t)v30
      + v12 * (unint64_t)v23
      + v38 * (unint64_t)v17;
  v44 = v29 * (unint64_t)v19
      + v20 * (unint64_t)v28
      + v16 * (unint64_t)v36
      + v26 * (unint64_t)v24
      + v25 * (unint64_t)v10
      + v27 * (unint64_t)v23
      + v30 * (unint64_t)v18
      + v12 * (unint64_t)v22
      + v14 * (unint64_t)v38
      + v31 * (unint64_t)v17;
  v45 = v27 * (unint64_t)v36
      + v30 * (unint64_t)v28
      + v12 * (unint64_t)v29
      + v26 * (unint64_t)v38
      + v31 * (unint64_t)v10;
  v46 = v29 * (unint64_t)v30
      + v12 * (unint64_t)v36
      + v10 * (unint64_t)v38
      + v31 * (unint64_t)v28
      + ((v45 + 0x100000) >> 21);
  v47 = v43 + v31 * (unint64_t)v18;
  v48 = v20 * (unint64_t)v36
      + v24 * (unint64_t)v28
      + v25 * (unint64_t)v29
      + v27 * (unint64_t)v10
      + v30 * (unint64_t)v23
      + v12 * (unint64_t)v26
      + v38 * (unint64_t)v18;
  v49 = v29 * (unint64_t)v24
      + v25 * (unint64_t)v36
      + v27 * (unint64_t)v28
      + v26 * (unint64_t)v30
      + v12 * (unint64_t)v10
      + v22 * (unint64_t)v38;
  v50 = v24 * (unint64_t)v36
      + v27 * (unint64_t)v29
      + v10 * (unint64_t)v30;
  v51 = v34 + ((v149 + 0x100000) >> 21);
  v52 = v44 + ((v42 + 0x100000) >> 21);
  v53 = v49 + v31 * (unint64_t)v23;
  v54 = v48 + v31 * (unint64_t)v22 + ((v47 + 0x100000) >> 21);
  v55 = v50
      + v12 * (unint64_t)v28
      + v38 * (unint64_t)v23
      + v31 * (unint64_t)v26
      + ((v53 + 0x100000) >> 21);
  v56 = v30 * (unint64_t)v36
      + v38 * (unint64_t)v28
      + v31 * (unint64_t)v29;
  v57 = v29 * (unint64_t)v38
      + v31 * (unint64_t)v36
      + ((v56 + 0x100000) >> 21);
  v58 = v38 * (unint64_t)v36;
  v59 = (v58 + 0x100000) >> 21;
  v60 = v33 + 0x100000;
  v142 = v33 - ((v33 + 0x100000) & 0xFFFFFFFFFFE00000);
  v144 = v35 + ((v51 + 0x100000) >> 21);
  v61 = v45 - ((v45 + 0x100000) & 0xFFFFFFFFFFE00000) + ((v55 + 0x100000) >> 21);
  v62 = v55 - ((v55 + 0x100000) & 0xFFFFFFFFFFE00000);
  v63 = v56 - ((v56 + 0x100000) & 0x1FFFFFFE00000) + ((v46 + 0x100000) >> 21);
  v64 = v46 - ((v46 + 0x100000) & 0xFFFFFFFFFFE00000);
  v65 = v58 - ((v58 + 0x100000) & 0x7FFFFFFE00000) + ((v57 + 0x100000) >> 21);
  v66 = v57 - ((v57 + 0x100000) & 0x1FFFFFFE00000);
  v67 = v53 - 683901 * (int)v59 - ((v53 + 0x100000) & 0xFFFFFFFFFFE00000);
  v68 = v47 - 997805 * (int)v59 - ((v47 + 0x100000) & 0xFFFFFFFFFFE00000);
  v69 = v42 + 470296 * v59 - ((v42 + 0x100000) & 0xFFFFFFFFFFE00000);
  v70 = v141 + ((v147 + 0x100000) >> 21);
  v71 = v140 + ((v146 + 0x100000) >> 21);
  v72 = 666643 * v63
      + 470296 * v64
      + 654183 * v61
      + v146
      + ((v70 + 0x100000) >> 21)
      - ((v146 + 0x100000) & 0xFFFFFFFFFFE00000);
  v73 = v41 + ((v145 + 0x100000) >> 21);
  v74 = 666643 * v65
      + 470296 * v66
      + 654183 * v63
      - 997805 * v64
      + 136657 * v61
      + ((v71 + 0x100000) >> 21)
      + v145
      - ((v145 + 0x100000) & 0xFFFFFFFFFFE00000);
  v75 = 666643 * v64 + 470296 * v61 + v70 - ((v70 + 0x100000) & 0xFFFFFFFFFFE00000);
  v76 = 666643 * v66 + 470296 * v63 + 654183 * v64 - 997805 * v61 + v71 - ((v71 + 0x100000) & 0xFFFFFFFFFFE00000);
  v77 = v69 + 654183 * v65 - 997805 * v66 + 136657 * v63 - 683901 * v64 + ((v73 + 0x100000) >> 21);
  v78 = 470296 * v65
      + 666643 * v59
      + 654183 * v66
      - 997805 * v63
      + 136657 * v64
      - 683901 * v61
      + v73
      - ((v73 + 0x100000) & 0xFFFFFFFFFFE00000);
  v79 = v68 + ((v52 + 0x100000) >> 21);
  v80 = v52
      + 654183 * v59
      - ((v52 + 0x100000) & 0xFFFFFFFFFFE00000)
      - 997805 * v65
      + 136657 * v66
      - 683901 * v63
      + ((uint64_t)(v77 + 0x100000) >> 21);
  v81 = v54 + 136657 * v59;
  v54 += 0x100000;
  v82 = v67 + (v54 >> 21);
  v83 = v147 + 666643 * v61 - ((v147 + 0x100000) & 0xFFFFFFFFFFE00000) + ((v143 + 0x100000) >> 21);
  v84 = v76 + ((uint64_t)(v72 + 0x100000) >> 21);
  v85 = v79 + 136657 * v65 - 683901 * v66;
  v86 = v78 + ((uint64_t)(v74 + 0x100000) >> 21);
  v87 = v81 - (v54 & 0xFFFFFFFFFFE00000) - 683901 * v65 + ((v85 + 0x100000) >> 21);
  v88 = v62 + ((uint64_t)(v82 + 0x100000) >> 21);
  v89 = v82 - ((v82 + 0x100000) & 0xFFFFFFFFFFE00000);
  v90 = v77 - ((v77 + 0x100000) & 0xFFFFFFFFFFE00000) + ((uint64_t)(v86 + 0x100000) >> 21);
  v91 = v86 - ((v86 + 0x100000) & 0xFFFFFFFFFFE00000);
  v92 = v85 - ((v85 + 0x100000) & 0xFFFFFFFFFFE00000) + ((uint64_t)(v80 + 0x100000) >> 21);
  v93 = v80 - ((v80 + 0x100000) & 0xFFFFFFFFFFE00000);
  v94 = v89 + ((uint64_t)(v87 + 0x100000) >> 21);
  v95 = v87 - ((v87 + 0x100000) & 0xFFFFFFFFFFE00000);
  v96 = v74 - 683901 * v88 + ((uint64_t)(v84 + 0x100000) >> 21) - ((v74 + 0x100000) & 0xFFFFFFFFFFE00000);
  v97 = v75 + ((uint64_t)(v83 + 0x100000) >> 21);
  v98 = -997805 * v88
      + 136657 * v94
      - 683901 * v95
      + v72
      + ((uint64_t)(v97 + 0x100000) >> 21)
      - ((v72 + 0x100000) & 0xFFFFFFFFFFE00000);
  v99 = v83 + 470296 * v88 - ((v83 + 0x100000) & 0xFFFFFFFFFFE00000);
  v100 = v148 + 666643 * v90;
  v101 = v142 + 470296 * v90 + 666643 * v93 + ((uint64_t)(v100 + 0x100000) >> 21);
  v102 = v99 + 654183 * v94 - 997805 * v95 + 136657 * v92 - 683901 * v93;
  v103 = v97
       + 654183 * v88
       - 997805 * v94
       + 136657 * v95
       - ((v97 + 0x100000) & 0xFFFFFFFFFFE00000)
       - 683901 * v92
       + ((v102 + 0x100000) >> 21);
  v104 = 136657 * v88
       - 683901 * v94
       + v84
       - ((v84 + 0x100000) & 0xFFFFFFFFFFE00000)
       + ((uint64_t)(v98 + 0x100000) >> 21);
  v105 = v91 + ((uint64_t)(v96 + 0x100000) >> 21);
  v106 = (uint64_t)(v105 + 0x100000) >> 21;
  v107 = v149 + (v60 >> 21) - ((v149 + 0x100000) & 0xFFFFFFFFFFE00000) + 654183 * v90 + 666643 * v92 + 470296 * v93;
  v108 = v51
       - ((v51 + 0x100000) & 0xFFFFFFFFFFE00000)
       + 666643 * v95
       - 997805 * v90
       + 470296 * v92
       + 654183 * v93
       + ((uint64_t)(v107 + 0x100000) >> 21);
  v109 = v143 + 666643 * v88 - ((v143 + 0x100000) & 0xFFFFFFFFFFE00000) + 470296 * v94 + 654183 * v95 - 683901 * v90;
  v110 = v144 + 666643 * v94 + 470296 * v95 + 136657 * v90 + 654183 * v92 - 997805 * v93;
  v111 = v109 - 997805 * v92 + 136657 * v93 + ((v110 + 0x100000) >> 21);
  v112 = v96 + ((uint64_t)(v104 + 0x100000) >> 21);
  v113 = v100 - ((v100 + 0x100000) & 0xFFFFFFFFFFE00000) + 666643 * v106;
  v114 = (v96 + 0x100000) & 0xFFFFFFFFFFE00000;
  v115 = v101 + 470296 * v106 - ((v101 + 0x100000) & 0xFFFFFFFFFFE00000) + (v113 >> 21);
  v116 = v113 & 0x1FFFFF;
  v117 = v107 + 654183 * v106 - ((v107 + 0x100000) & 0xFFFFFFFFFFE00000) + ((v101 + 0x100000) >> 21) + (v115 >> 21);
  v118 = v108 - 997805 * v106 - ((v108 + 0x100000) & 0xFFFFFFFFFFE00000) + (v117 >> 21);
  v119 = v110
       + 136657 * v106
       - ((v110 + 0x100000) & 0xFFFFFFFFFFE00000)
       + ((uint64_t)(v108 + 0x100000) >> 21)
       + (v118 >> 21);
  v120 = v111 - 683901 * v106 - ((v111 + 0x100000) & 0xFFFFFFFFFFE00000) + (v119 >> 21);
  v121 = v102 - ((v102 + 0x100000) & 0xFFFFFFFFFFE00000) + ((v111 + 0x100000) >> 21) + (v120 >> 21);
  v122 = v103 - ((v103 + 0x100000) & 0xFFFFFFFFFFE00000) + (v121 >> 21);
  v123 = v98 - ((v98 + 0x100000) & 0xFFFFFFFFFFE00000) + ((uint64_t)(v103 + 0x100000) >> 21) + (v122 >> 21);
  v124 = v104 - ((v104 + 0x100000) & 0xFFFFFFFFFFE00000) + (v123 >> 21);
  v125 = v112 - v114 + (v124 >> 21);
  v126 = v105 - ((v105 + 0x100000) & 0xFFFFFFFFFFE00000) + (v125 >> 21);
  v127 = v116 + 666643 * (v126 >> 21);
  a1[33] = BYTE1(v127);
  v128 = (v115 & 0x1FFFFF) + 470296 * (v126 >> 21) + (v127 >> 21);
  a1[32] = v127;
  a1[34] = ((v116 + 666643 * (v126 >> 21)) >> 16) & 0x1F | (32
                                                                                      * (v115
                                                                                       + 24 * (v126 >> 21)
                                                                                       + (v127 >> 21)));
  a1[35] = (unint64_t)v128 >> 3;
  a1[36] = (unint64_t)v128 >> 11;
  v129 = (v117 & 0x1FFFFF) + 654183 * (v126 >> 21) + (v128 >> 21);
  a1[37] = (v128 >> 19) & 3 | (4 * (v117 + 103 * (v126 >> 21) + (v128 >> 21)));
  a1[38] = (unint64_t)v129 >> 6;
  v130 = (v118 & 0x1FFFFF) - 997805 * (v126 >> 21) + (v129 >> 21);
  a1[39] = (v129 >> 14) & 0x7F | (((_BYTE)v108
                                               - -83 * (_BYTE)v106
                                               + (v117 >> 21)
                                               - -83 * (v126 >> 21)
                                               + (v129 >> 21)) << 7);
  a1[40] = (unint64_t)v130 >> 1;
  a1[41] = (unint64_t)v130 >> 9;
  v131 = (v119 & 0x1FFFFF) + 136657 * (v126 >> 21) + (v130 >> 21);
  a1[42] = (v130 >> 17) & 0xF | (16 * (v119 - 47 * (v126 >> 21) + (v130 >> 21)));
  a1[43] = (unint64_t)v131 >> 4;
  a1[44] = (unint64_t)v131 >> 12;
  v132 = (v120 & 0x1FFFFF) - 683901 * (v126 >> 21) + (v131 >> 21);
  a1[45] = ((v131 & 0x100000) != 0) | (2 * (v120 - 125 * (v126 >> 21) + (v131 >> 21)));
  a1[46] = (unint64_t)v132 >> 7;
  v133 = (v121 & 0x1FFFFF) + (v132 >> 21);
  a1[47] = (v132 >> 15) & 0x3F | (((_BYTE)v121 + (v132 >> 21)) << 6);
  a1[48] = (unint64_t)v133 >> 2;
  a1[49] = (unint64_t)v133 >> 10;
  v134 = (v122 & 0x1FFFFF) + (v133 >> 21);
  a1[50] = (v133 >> 18) & 7 | (8 * (v122 + (v133 >> 21)));
  a1[51] = (unint64_t)v134 >> 5;
  v135 = (v123 & 0x1FFFFF) + (v134 >> 21);
  a1[52] = (unint64_t)v134 >> 13;
  a1[54] = BYTE1(v135);
  v136 = (v124 & 0x1FFFFF) + (v135 >> 21);
  a1[53] = v135;
  a1[55] = BYTE2(v135) & 0x1F | (32 * (v124 + (v135 >> 21)));
  a1[56] = (unint64_t)v136 >> 3;
  a1[57] = (unint64_t)v136 >> 11;
  v137 = (v125 & 0x1FFFFF) + (v136 >> 21);
  a1[58] = (v136 >> 19) & 3 | (4 * v137);
  a1[59] = (unint64_t)v137 >> 6;
  v138 = (v126 & 0x1FFFFF) + (v137 >> 21);
  a1[60] = (v137 >> 14) & 0x7F | ((_BYTE)v138 << 7);
  a1[61] = v138 >> 1;
  a1[62] = v138 >> 9;
  a1[63] = v138 >> 17;
  return 1;
}

BOOL ED25519_verify(const void *a1, size_t a2, unsigned __int8 *a3, const void *a4)
{
  uint64_t i;
  uint64_t j;
  __int128 v10;
  __int128 v11;
  unsigned int v12;
  unsigned int v13;
  uint64_t v14;
  unsigned int v16;
  uint64_t v17;
  unint64_t v18;
  int v19;
  uint64_t k;
  uint64_t m;
  int *v22;
  uint64_t n;
  uint64_t ii;
  uint64_t jj;
  uint64_t kk;
  uint64_t mm;
  _OWORD v29[7];
  uint64_t v30;
  SHA512_CTX c;
  __int128 v32[10];
  _OWORD v33[10];
  _OWORD v34[5];
  _OWORD v35[5];
  _OWORD v36[5];
  _OWORD v37[5];
  unsigned __int16 md[32];
  __int128 v39;
  __int128 v40;
  _OWORD v41[2];
  int v42[40];
  int v43[40];
  int v44[40];
  int v45[40];
  int v46[40];
  int v47[40];
  int v48[40];
  uint64_t v49;
  _BYTE v50[256];
  _BYTE v51[256];
  __int128 v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  uint64_t v59;
  uint64_t v60;

  v60 = *MEMORY[0x24BDAC8D0];
  if (a3[63] > 0x1Fu)
    return 0;
  memset(v32, 0, sizeof(v32));
  if (x25519_ge_frombytes_vartime((uint64_t)v32, (uint64_t)a4))
    return 0;
  for (i = 0; i != 40; i += 4)
    *(_DWORD *)((char *)v32 + i) = -*(_DWORD *)((char *)v32 + i);
  for (j = 120; j != 160; j += 4)
    *(_DWORD *)((char *)v32 + j) = -*(_DWORD *)((char *)v32 + j);
  v10 = *((_OWORD *)a3 + 1);
  v41[0] = *(_OWORD *)a3;
  v41[1] = v10;
  v11 = *((_OWORD *)a3 + 2);
  v40 = *((_OWORD *)a3 + 3);
  v39 = v11;
  v12 = HIBYTE(v40);
  if (HIBYTE(v40) > 0x10u)
    return 0;
  v13 = 16;
  v14 = 0x1Eu;
  while (v12 >= v13)
  {
    if (v14 != -1)
    {
      v12 = *((unsigned __int8 *)&v39 + v14);
      v13 = order[v14--];
      if (v12 <= v13)
        continue;
    }
    return 0;
  }
  memset(&c, 0, sizeof(c));
  SHA512_Init(&c);
  SHA512_Update(&c, a3, 0x20uLL);
  SHA512_Update(&c, a4, 0x20uLL);
  SHA512_Update(&c, a1, a2);
  SHA512_Final((unsigned __int8 *)md, &c);
  x25519_sc_reduce(md);
  v30 = 0;
  memset(v29, 0, sizeof(v29));
  memset(v37, 0, sizeof(v37));
  memset(v36, 0, sizeof(v36));
  memset(v35, 0, sizeof(v35));
  memset(v34, 0, sizeof(v34));
  memset(v33, 0, sizeof(v33));
  slide((uint64_t)v51, (uint64_t)md);
  slide((uint64_t)v50, (uint64_t)&v39);
  x25519_ge_p3_to_cached((uint64_t)v42, (uint64_t)v32);
  v59 = 0;
  v57 = 0u;
  v58 = 0u;
  v55 = 0u;
  v56 = 0u;
  v53 = 0u;
  v54 = 0u;
  v52 = 0u;
  ge_p3_to_p2((uint64_t)&v52, v32);
  ge_p2_dbl(v36, (int *)&v52);
  x25519_ge_p1p1_to_p3(v33, (int *)v36);
  x25519_ge_add((int *)v36, (uint64_t)v33, v42);
  x25519_ge_p1p1_to_p3(v34, (int *)v36);
  x25519_ge_p3_to_cached((uint64_t)v43, (uint64_t)v34);
  x25519_ge_add((int *)v36, (uint64_t)v33, v43);
  x25519_ge_p1p1_to_p3(v34, (int *)v36);
  x25519_ge_p3_to_cached((uint64_t)v44, (uint64_t)v34);
  x25519_ge_add((int *)v36, (uint64_t)v33, v44);
  x25519_ge_p1p1_to_p3(v34, (int *)v36);
  x25519_ge_p3_to_cached((uint64_t)v45, (uint64_t)v34);
  x25519_ge_add((int *)v36, (uint64_t)v33, v45);
  x25519_ge_p1p1_to_p3(v34, (int *)v36);
  x25519_ge_p3_to_cached((uint64_t)v46, (uint64_t)v34);
  x25519_ge_add((int *)v36, (uint64_t)v33, v46);
  x25519_ge_p1p1_to_p3(v34, (int *)v36);
  x25519_ge_p3_to_cached((uint64_t)v47, (uint64_t)v34);
  x25519_ge_add((int *)v36, (uint64_t)v33, v47);
  x25519_ge_p1p1_to_p3(v34, (int *)v36);
  x25519_ge_p3_to_cached((uint64_t)v48, (uint64_t)v34);
  x25519_ge_add((int *)v36, (uint64_t)v33, v48);
  x25519_ge_p1p1_to_p3(v34, (int *)v36);
  x25519_ge_p3_to_cached((uint64_t)&v49, (uint64_t)v34);
  ge_p2_0((uint64_t)v29);
  v16 = 255;
  while (1)
  {
    v17 = v16;
    if (v51[v16] || v50[v16])
      break;
    --v16;
    if (!(_DWORD)v17)
      goto LABEL_42;
  }
  if ((v16 & 0x80000000) == 0)
  {
    do
    {
      ge_p2_dbl(v36, (int *)v29);
      v18 = v51[v17];
      if ((char)v51[v17] < 1)
      {
        if ((v18 & 0x80) != 0)
        {
          x25519_ge_p1p1_to_p3(v34, (int *)v36);
          x25519_ge_sub((int *)v36, (uint64_t)v34, &v42[40 * (-(char)v18 >> 1)]);
        }
      }
      else
      {
        x25519_ge_p1p1_to_p3(v34, (int *)v36);
        x25519_ge_add((int *)v36, (uint64_t)v34, &v42[40 * (v18 >> 1)]);
      }
      v19 = (char)v50[v17];
      if (v19 < 1)
      {
        if (v19 < 0)
        {
          x25519_ge_p1p1_to_p3(v34, (int *)v36);
          for (k = 0; k != 40; k += 4)
            *(_DWORD *)((char *)v36 + k) = *(_DWORD *)((char *)v34 + k) + *(_DWORD *)((char *)&v34[2] + k + 8);
          for (m = 0; m != 40; m += 4)
            *(_DWORD *)((char *)&v36[2] + m + 8) = *(_DWORD *)((char *)&v34[2] + m + 8) - *(_DWORD *)((char *)v34 + m);
          *(_QWORD *)&v54 = 0;
          v22 = &Bi[30 * (-(char)v19 >> 1)];
          v52 = 0u;
          v53 = 0u;
          fe_mul(v37, (int *)v36, v22 + 10);
          fe_mul((_DWORD *)&v36[2] + 2, (int *)&v36[2] + 2, v22);
          fe_mul((_DWORD *)&v37[2] + 2, v22 + 20, (int *)&v35[2] + 2);
          for (n = 0; n != 40; n += 4)
            *(_DWORD *)((char *)&v52 + n) = 2 * *(_DWORD *)((char *)v35 + n);
          for (ii = 0; ii != 40; ii += 4)
            *(_DWORD *)((char *)v36 + ii) = *(_DWORD *)((char *)v37 + ii) - *(_DWORD *)((char *)&v36[2] + ii + 8);
          for (jj = 0; jj != 40; jj += 4)
            *(_DWORD *)((char *)&v36[2] + jj + 8) += *(_DWORD *)((char *)v37 + jj);
          for (kk = 0; kk != 40; kk += 4)
            *(_DWORD *)((char *)v37 + kk) = *(_DWORD *)((char *)&v52 + kk) - *(_DWORD *)((char *)&v37[2] + kk + 8);
          for (mm = 0; mm != 40; mm += 4)
            *(_DWORD *)((char *)&v37[2] + mm + 8) += *(_DWORD *)((char *)&v52 + mm);
        }
      }
      else
      {
        x25519_ge_p1p1_to_p3(v34, (int *)v36);
        ge_madd((int *)v36, (uint64_t)v34, &Bi[30 * (v19 >> 1)]);
      }
      x25519_ge_p1p1_to_p2(v29, (int *)v36);
    }
    while (v17-- > 0);
  }
LABEL_42:
  x25519_ge_tobytes((uint64_t)v42, (int *)v29);
  return timingsafe_memcmp((unsigned __int8 *)v42, (unsigned __int8 *)v41, 32) == 0;
}

uint64_t x25519_scalar_mult_generic(uint64_t a1, __int128 *a2, unsigned int *a3)
{
  __int128 v3;
  int v4;
  unsigned int v5;
  uint64_t v6;
  unsigned int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  uint64_t i;
  int v14;
  int v15;
  int v16;
  uint64_t j;
  uint64_t k;
  uint64_t m;
  uint64_t n;
  uint64_t ii;
  uint64_t jj;
  uint64_t kk;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  int v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t mm;
  uint64_t v36;
  int v37;
  int v38;
  int v39;
  int v40;
  uint64_t nn;
  int v42;
  int v43;
  int v44;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  uint64_t v51;
  _OWORD v52[2];
  uint64_t v53;
  int v54;
  __int128 v55;
  __int128 v56;
  int v57;
  _OWORD v58[2];
  uint64_t v59;
  _OWORD v60[2];
  uint64_t v61;
  int v62;
  __int128 v63;
  __int128 v64;
  int v65;
  __int128 v66;
  __int128 v67;
  uint64_t v68;
  uint64_t v69;

  v69 = *MEMORY[0x24BDAC8D0];
  v68 = 0;
  v66 = 0u;
  v67 = 0u;
  v53 = 0;
  memset(v52, 0, sizeof(v52));
  v51 = 0;
  v49 = 0u;
  v50 = 0u;
  v3 = a2[1];
  v47 = *a2;
  v48 = v3;
  LOBYTE(v47) = v47 & 0xF8;
  HIBYTE(v48) = HIBYTE(v3) & 0x3F | 0x40;
  fe_frombytes(&v66, a3);
  v4 = 0;
  v64 = 0u;
  v63 = 0u;
  v65 = 0;
  v62 = 1;
  memset(v60, 0, sizeof(v60));
  v61 = 0;
  v58[0] = v66;
  v58[1] = v67;
  v5 = 254;
  v59 = v68;
  v55 = 0u;
  v56 = 0u;
  v54 = 1;
  v57 = 0;
  do
  {
    v6 = 0;
    v7 = v5;
    v8 = v4;
    v4 = (*((unsigned __int8 *)&v47 + ((unint64_t)v5 >> 3)) >> (v5 & 7)) & 1;
    v9 = -(v4 ^ v8);
    do
    {
      v10 = *(int *)((char *)&v62 + v6);
      v11 = *(_DWORD *)((char *)v58 + v6);
      v12 = (v11 ^ v10) & v9;
      *(int *)((char *)&v62 + v6) = v12 ^ v10;
      *(_DWORD *)((char *)v58 + v6) = v12 ^ v11;
      v6 += 4;
    }
    while (v6 != 40);
    for (i = 0; i != 40; i += 4)
    {
      v14 = *(_DWORD *)((char *)v60 + i);
      v15 = *(int *)((char *)&v54 + i);
      v16 = (v15 ^ v14) & v9;
      *(_DWORD *)((char *)v60 + i) = v16 ^ v14;
      *(int *)((char *)&v54 + i) = v16 ^ v15;
    }
    for (j = 0; j != 40; j += 4)
      *(_DWORD *)((char *)v52 + j) = *(_DWORD *)((char *)v58 + j) - *(int *)((char *)&v54 + j);
    for (k = 0; k != 40; k += 4)
      *(_DWORD *)((char *)&v49 + k) = *(int *)((char *)&v62 + k) - *(_DWORD *)((char *)v60 + k);
    for (m = 0; m != 40; m += 4)
      *(int *)((char *)&v62 + m) += *(_DWORD *)((char *)v60 + m);
    for (n = 0; n != 40; n += 4)
      *(_DWORD *)((char *)v60 + n) = *(int *)((char *)&v54 + n) + *(_DWORD *)((char *)v58 + n);
    fe_mul(&v54, (int *)v52, &v62);
    fe_mul(v60, (int *)v60, (int *)&v49);
    fe_sq(v52, (int *)&v49);
    fe_sq(&v49, &v62);
    for (ii = 0; ii != 40; ii += 4)
      *(_DWORD *)((char *)v58 + ii) = *(_DWORD *)((char *)v60 + ii) + *(int *)((char *)&v54 + ii);
    for (jj = 0; jj != 40; jj += 4)
      *(_DWORD *)((char *)v60 + jj) = *(int *)((char *)&v54 + jj) - *(_DWORD *)((char *)v60 + jj);
    fe_mul(&v62, (int *)&v49, (int *)v52);
    for (kk = 0; kk != 40; kk += 4)
      *(_DWORD *)((char *)&v49 + kk) -= *(_DWORD *)((char *)v52 + kk);
    fe_sq(v60, (int *)v60);
    v24 = 121666 * SDWORD1(v49) + 0x1000000;
    v25 = 121666 * SDWORD2(v49) + (v24 >> 25);
    v26 = 121666 * SHIDWORD(v51) + 0x1000000;
    v27 = 121666 * SHIDWORD(v49) + 0x1000000;
    v28 = 121666 * (int)v50 + (v27 >> 25);
    v29 = 121666 * SDWORD1(v50) + 0x1000000;
    v30 = 121666 * SDWORD2(v50) + (v29 >> 25);
    v31 = 121666 * DWORD1(v50) - (v29 & 0xFE000000);
    v32 = 121666 * SHIDWORD(v50) + 0x1000000;
    v33 = 121666 * (int)v51 + (v32 >> 25);
    v34 = 121666 * (int)v49 + 19 * (int)(v26 >> 25);
    v54 = v34 - ((v34 + 0x2000000) & 0xFC000000);
    LODWORD(v55) = 121666 * DWORD1(v49) - (v24 & 0xFE000000) + ((unint64_t)(v34 + 0x2000000) >> 26);
    DWORD1(v55) = v25 - ((v25 + 0x2000000) & 0xFC000000);
    DWORD2(v55) = 121666 * HIDWORD(v49) - (v27 & 0xFE000000) + ((unint64_t)(v25 + 0x2000000) >> 26);
    HIDWORD(v55) = v28 - ((v28 + 0x2000000) & 0xFC000000);
    LODWORD(v56) = v31 + ((unint64_t)(v28 + 0x2000000) >> 26);
    DWORD1(v56) = v30 - ((v30 + 0x2000000) & 0xFC000000);
    DWORD2(v56) = 121666 * HIDWORD(v50) - (v32 & 0xFE000000) + ((unint64_t)(v30 + 0x2000000) >> 26);
    HIDWORD(v56) = v33 - ((v33 + 0x2000000) & 0xFC000000);
    v57 = 121666 * HIDWORD(v51) - (v26 & 0xFE000000) + ((unint64_t)(v33 + 0x2000000) >> 26);
    fe_sq(v58, (int *)v58);
    for (mm = 0; mm != 40; mm += 4)
      *(_DWORD *)((char *)v52 + mm) += *(int *)((char *)&v54 + mm);
    fe_mul(&v54, (int *)&v66, (int *)v60);
    fe_mul(v60, (int *)&v49, (int *)v52);
    v5 = v7 - 1;
  }
  while (v7);
  v36 = 0;
  v37 = -v4;
  do
  {
    v38 = *(int *)((char *)&v62 + v36);
    v39 = *(_DWORD *)((char *)v58 + v36);
    v40 = (v39 ^ v38) & v37;
    *(int *)((char *)&v62 + v36) = v40 ^ v38;
    *(_DWORD *)((char *)v58 + v36) = v40 ^ v39;
    v36 += 4;
  }
  while (v36 != 40);
  for (nn = 0; nn != 40; nn += 4)
  {
    v42 = *(_DWORD *)((char *)v60 + nn);
    v43 = *(int *)((char *)&v54 + nn);
    v44 = (v43 ^ v42) & v37;
    *(_DWORD *)((char *)v60 + nn) = v44 ^ v42;
    *(int *)((char *)&v54 + nn) = v44 ^ v43;
  }
  fe_invert(v60, (int *)v60);
  fe_mul(&v62, &v62, (int *)v60);
  return fe_tobytes(a1, &v62);
}

uint64_t X25519_public_from_private(uint64_t a1, uint64_t a2)
{
  return x25519_scalar_mult(a1, a2, &X25519_public_from_private_kMongomeryBasePoint);
}

uint64_t X25519_keypair(uint64_t a1, _BYTE *__buf)
{
  arc4random_buf(__buf, 0x20uLL);
  *__buf |= 7u;
  __buf[31] = __buf[31] & 0x3F | 0x80;
  return x25519_scalar_mult(a1, __buf, &X25519_public_from_private_kMongomeryBasePoint);
}

BOOL X25519(unsigned __int8 *a1, uint64_t a2, uint64_t a3)
{
  x25519_scalar_mult(a1, a2, a3);
  return timingsafe_memcmp(X25519_kZeros, a1, 32) != 0;
}

uint64_t slide(uint64_t result, uint64_t a2)
{
  uint64_t i;
  unint64_t v3;
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  unint64_t v14;

  for (i = 0; i != 256; ++i)
    *(_BYTE *)(result + i) = (*(unsigned __int8 *)(a2 + (i >> 3)) >> (i & 7)) & 1;
  v3 = 0;
  v4 = result + 1;
  v5 = 1;
  do
  {
    if (*(_BYTE *)(result + v3) && v3 <= 0xFE)
    {
      v6 = v3;
      v7 = 1;
      v8 = v5;
      do
      {
        v9 = *(char *)(result + v8);
        if (*(_BYTE *)(result + v8))
        {
          v10 = *(char *)(result + v3);
          v11 = v9 << v7;
          v12 = (v9 << v7) + v10;
          if (v12 > 15)
          {
            v13 = v10 - v11;
            if (v13 < -15)
              break;
            *(_BYTE *)(result + v3) = v13;
            v14 = v6;
            while (*(_BYTE *)(v4 + v14))
            {
              *(_BYTE *)(v4 + v14++) = 0;
              if (v14 >= 0xFF)
                goto LABEL_16;
            }
            *(_BYTE *)(v4 + v14) = 1;
          }
          else
          {
            *(_BYTE *)(result + v3) = v12;
            *(_BYTE *)(result + v8) = 0;
          }
        }
LABEL_16:
        if (v7 > 5)
          break;
        ++v7;
        ++v8;
        ++v6;
      }
      while (v7 + v3 < 0x100);
    }
    ++v3;
    ++v5;
  }
  while (v3 != 256);
  return result;
}

int RAND_set_rand_method(const RAND_METHOD *meth)
{
  return 1;
}

const RAND_METHOD *RAND_get_rand_method(void)
{
  return 0;
}

RAND_METHOD *RAND_SSLeay(void)
{
  return 0;
}

int RAND_set_rand_engine(ENGINE *engine)
{
  return 1;
}

int RAND_status(void)
{
  return 1;
}

int RAND_poll(void)
{
  return 1;
}

int RAND_bytes(unsigned __int8 *buf, int num)
{
  if (num >= 1)
    arc4random_buf(buf, num);
  return 1;
}

int RAND_pseudo_bytes(unsigned __int8 *buf, int num)
{
  if (num >= 1)
    arc4random_buf(buf, num);
  return 1;
}

STACK *i2v_POLICY_CONSTRAINTS(uint64_t a1, ASN1_INTEGER **a2, STACK *a3)
{
  STACK *v4;
  STACK *result;
  STACK *extlist;

  extlist = a3;
  if (a3)
  {
    v4 = 0;
  }
  else
  {
    result = sk_new_null();
    v4 = result;
    extlist = result;
    if (!result)
      return result;
  }
  if (X509V3_add_value_int("Require Explicit Policy", *a2, &extlist)
    && X509V3_add_value_int("Inhibit Policy Mapping", a2[1], &extlist))
  {
    return extlist;
  }
  sk_pop_free(v4, (void (__cdecl *)(void *))X509V3_conf_free);
  return 0;
}

ASN1_VALUE *v2i_POLICY_CONSTRAINTS(uint64_t a1, uint64_t a2, const STACK *a3)
{
  ASN1_VALUE *v4;
  int i;
  char *v6;
  const char *v7;
  CONF_VALUE *v8;
  ASN1_INTEGER **v9;

  v4 = ASN1_item_new(&POLICY_CONSTRAINTS_it);
  if (!v4)
  {
    ERR_put_error(34, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_pcons.c", 169);
    return v4;
  }
  if (sk_num(a3) >= 1)
  {
    for (i = 0; i < sk_num(a3); ++i)
    {
      v6 = sk_value(a3, i);
      v7 = (const char *)*((_QWORD *)v6 + 1);
      if (!strcmp(v7, "requireExplicitPolicy"))
      {
        v8 = (CONF_VALUE *)v6;
        v9 = (ASN1_INTEGER **)v4;
      }
      else
      {
        if (strcmp(v7, "inhibitPolicyMapping"))
        {
          ERR_put_error(34, 4095, 106, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_pcons.c", 181);
          ERR_asprintf_error_data("section:%s,name:%s,value:%s", *(const char **)v6, *((const char **)v6 + 1), *((const char **)v6 + 2));
LABEL_15:
          ASN1_item_free(v4, &POLICY_CONSTRAINTS_it);
          return 0;
        }
        v8 = (CONF_VALUE *)v6;
        v9 = (ASN1_INTEGER **)((char *)v4 + 8);
      }
      if (!X509V3_get_value_int(v8, v9))
        goto LABEL_15;
    }
  }
  if (!*((_QWORD *)v4 + 1) && !*(_QWORD *)v4)
  {
    ERR_put_error(34, 4095, 151, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_pcons.c", 187);
    goto LABEL_15;
  }
  return v4;
}

POLICY_CONSTRAINTS *POLICY_CONSTRAINTS_new(void)
{
  return (POLICY_CONSTRAINTS *)ASN1_item_new(&POLICY_CONSTRAINTS_it);
}

void POLICY_CONSTRAINTS_free(POLICY_CONSTRAINTS *a)
{
  ASN1_item_free((ASN1_VALUE *)a, &POLICY_CONSTRAINTS_it);
}

ASN1_VALUE *__cdecl ASN1_item_new(const ASN1_ITEM *it)
{
  ASN1_VALUE *pval;

  pval = 0;
  if (asn1_item_ex_new(&pval, (ASN1_ITEM *)it))
    return pval;
  else
    return 0;
}

uint64_t asn1_item_ex_new(ASN1_VALUE **pval, ASN1_ITEM *it)
{
  _QWORD *funcs;
  uint64_t (*v5)(uint64_t, ASN1_VALUE **, ASN1_ITEM *, _QWORD);
  uint64_t v6;
  int v7;
  ASN1_VALUE *v8;
  uint64_t v9;
  const ASN1_TEMPLATE *v10;
  ASN1_VALUE **field_ptr;
  const ASN1_TEMPLATE *templates;
  int v13;
  ASN1_VALUE *v14;
  _QWORD *v15;
  unsigned int (*v16)(ASN1_VALUE **, ASN1_ITEM *);

  funcs = it->funcs;
  if (funcs)
    v5 = (uint64_t (*)(uint64_t, ASN1_VALUE **, ASN1_ITEM *, _QWORD))funcs[3];
  else
    v5 = 0;
  *pval = 0;
  v6 = 1;
  switch(it->itype)
  {
    case 0:
      templates = it->templates;
      if (!templates)
        goto LABEL_18;
      if (!ASN1_template_new(pval, templates))
        goto LABEL_30;
      return v6;
    case 1:
    case 6:
      if (!v5)
        goto LABEL_35;
      v7 = v5(0, pval, it, 0);
      if (!v7)
        goto LABEL_26;
      if (v7 != 2)
      {
LABEL_35:
        v8 = (ASN1_VALUE *)malloc_type_calloc(1uLL, it->size, 0x31C8A62EuLL);
        *pval = v8;
        if (!v8)
          goto LABEL_30;
        asn1_do_lock(pval, 0, it);
        asn1_enc_init(pval, it);
        if (it->tcount >= 1)
        {
          v9 = 0;
          v10 = it->templates;
          do
          {
            field_ptr = asn1_get_field_ptr(pval, v10);
            if (!ASN1_template_new(field_ptr, v10))
              goto LABEL_30;
            ++v10;
            ++v9;
          }
          while (it->tcount > v9);
        }
        v6 = 1;
        if (v5)
          goto LABEL_25;
      }
      return v6;
    case 2:
      if (!v5)
        goto LABEL_23;
      v13 = v5(0, pval, it, 0);
      if (!v13)
        goto LABEL_26;
      if (v13 != 2)
      {
LABEL_23:
        v14 = (ASN1_VALUE *)malloc_type_calloc(1uLL, it->size, 0x1D76C7DAuLL);
        *pval = v14;
        if (!v14)
          goto LABEL_30;
        asn1_set_choice_selector(pval, -1, it);
        if (v5)
        {
LABEL_25:
          if (!v5(1, pval, it, 0))
          {
LABEL_26:
            ERR_put_error(13, 4095, 100, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/tasn_new.c", 176);
            ASN1_item_ex_free(pval, it);
            return 0;
          }
        }
      }
      return v6;
    case 4:
      v15 = it->funcs;
      if (v15)
      {
        v16 = (unsigned int (*)(ASN1_VALUE **, ASN1_ITEM *))v15[1];
        if (v16)
        {
          if (!v16(pval, it))
            goto LABEL_30;
        }
      }
      return v6;
    case 5:
LABEL_18:
      if (!ASN1_primitive_new(pval, it))
      {
LABEL_30:
        ERR_put_error(13, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/tasn_new.c", 172);
        return 0;
      }
      return v6;
    default:
      return v6;
  }
}

int ASN1_template_new(ASN1_VALUE **pval, const ASN1_TEMPLATE *tt)
{
  const ASN1_TEMPLATE *v2;
  unint64_t flags;
  STACK *v5;
  uint64_t item;
  uint64_t v8;
  void (*v9)(ASN1_VALUE **);

  v2 = tt;
  flags = tt->flags;
  if ((tt->flags & 1) != 0)
  {
    while ((v2->flags & 0x306) == 0)
    {
      item = (uint64_t)v2->item;
      if (*(_BYTE *)item)
      {
        switch(*(_BYTE *)item)
        {
          case 1:
          case 2:
          case 6:
            goto LABEL_11;
          case 4:
            v8 = *(_QWORD *)(item + 32);
            if (!v8)
              goto LABEL_11;
            v9 = *(void (**)(ASN1_VALUE **))(v8 + 24);
            if (!v9)
              goto LABEL_11;
            v9(pval);
            break;
          case 5:
            goto LABEL_13;
          default:
            return 1;
        }
        return 1;
      }
      v2 = *(const ASN1_TEMPLATE **)(item + 16);
      if (!v2)
      {
LABEL_13:
        asn1_primitive_clear(pval, item);
        return 1;
      }
    }
    goto LABEL_11;
  }
  if ((flags & 0x300) != 0)
  {
LABEL_11:
    *pval = 0;
    return 1;
  }
  if ((flags & 6) == 0)
    return asn1_item_ex_new(pval, tt->item);
  v5 = sk_new_null();
  if (v5)
  {
    *pval = (ASN1_VALUE *)v5;
    return 1;
  }
  ERR_put_error(13, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/tasn_new.c", 236);
  return 0;
}

int ASN1_primitive_new(ASN1_VALUE **pval, const ASN1_ITEM *it)
{
  _QWORD *funcs;
  uint64_t (*v5)(ASN1_VALUE **, const ASN1_ITEM *);
  int result;
  ASN1_VALUE *v7;
  int utype;

  if (!it)
  {
    v7 = (ASN1_VALUE *)ASN1_STRING_type_new(-1);
LABEL_6:
    *pval = v7;
    return v7 != 0;
  }
  funcs = it->funcs;
  if (!funcs)
  {
    if (it->itype == 5)
    {
      utype = -1;
LABEL_9:
      v7 = (ASN1_VALUE *)ASN1_STRING_type_new(utype);
      if (it->itype == 5 && v7)
        *((_QWORD *)v7 + 2) |= 0x40uLL;
      goto LABEL_6;
    }
    utype = it->utype;
    if (utype > 4)
    {
      if (utype == 5)
      {
        result = 1;
        *pval = (ASN1_VALUE *)1;
        return result;
      }
      if (utype != 6)
        goto LABEL_9;
      *pval = (ASN1_VALUE *)OBJ_nid2obj(0);
    }
    else
    {
      if (utype == -4)
      {
        v7 = (ASN1_VALUE *)malloc_type_malloc(0x10uLL, 0x1032040EB7D8BF6uLL);
        if (v7)
        {
          *((_QWORD *)v7 + 1) = 0;
          *(_DWORD *)v7 = -1;
        }
        goto LABEL_6;
      }
      if (utype != 1)
        goto LABEL_9;
      *(_DWORD *)pval = it->size;
    }
    return 1;
  }
  v5 = (uint64_t (*)(ASN1_VALUE **, const ASN1_ITEM *))funcs[2];
  if (v5)
    return v5(pval, it);
  else
    return 0;
}

_DWORD *asn1_primitive_clear(_DWORD *result, uint64_t a2)
{
  uint64_t v2;
  uint64_t (*v3)(void);

  if (a2)
  {
    v2 = *(_QWORD *)(a2 + 32);
    if (v2)
    {
      v3 = *(uint64_t (**)(void))(v2 + 32);
      if (v3)
        return (_DWORD *)v3();
    }
    else if (*(_BYTE *)a2 != 5 && *(_DWORD *)(a2 + 8) == 1)
    {
      *result = *(_QWORD *)(a2 + 40);
      return result;
    }
  }
  *(_QWORD *)result = 0;
  return result;
}

X509 *__cdecl d2i_X509_bio(BIO *bp, X509 **x509)
{
  return (X509 *)ASN1_item_d2i_bio(&X509_it, bp, x509);
}

int i2d_X509_bio(BIO *bp, X509 *x509)
{
  return ASN1_item_i2d_bio(&X509_it, bp, x509);
}

X509 *__cdecl d2i_X509_fp(FILE *fp, X509 **x509)
{
  return (X509 *)ASN1_item_d2i_fp(&X509_it, fp, x509);
}

int i2d_X509_fp(FILE *fp, X509 *x509)
{
  return ASN1_item_i2d_fp(&X509_it, fp, x509);
}

X509_CRL *__cdecl d2i_X509_CRL_bio(BIO *bp, X509_CRL **crl)
{
  return (X509_CRL *)ASN1_item_d2i_bio(&X509_CRL_it, bp, crl);
}

int i2d_X509_CRL_bio(BIO *bp, X509_CRL *crl)
{
  return ASN1_item_i2d_bio(&X509_CRL_it, bp, crl);
}

X509_CRL *__cdecl d2i_X509_CRL_fp(FILE *fp, X509_CRL **crl)
{
  return (X509_CRL *)ASN1_item_d2i_fp(&X509_CRL_it, fp, crl);
}

int i2d_X509_CRL_fp(FILE *fp, X509_CRL *crl)
{
  return ASN1_item_i2d_fp(&X509_CRL_it, fp, crl);
}

X509_REQ *__cdecl d2i_X509_REQ_bio(BIO *bp, X509_REQ **req)
{
  return (X509_REQ *)ASN1_item_d2i_bio(&X509_REQ_it, bp, req);
}

int i2d_X509_REQ_bio(BIO *bp, X509_REQ *req)
{
  return ASN1_item_i2d_bio(&X509_REQ_it, bp, req);
}

X509_REQ *__cdecl d2i_X509_REQ_fp(FILE *fp, X509_REQ **req)
{
  return (X509_REQ *)ASN1_item_d2i_fp(&X509_REQ_it, fp, req);
}

int i2d_X509_REQ_fp(FILE *fp, X509_REQ *req)
{
  return ASN1_item_i2d_fp(&X509_REQ_it, fp, req);
}

RSA *__cdecl d2i_RSAPrivateKey_bio(BIO *bp, RSA **rsa)
{
  return (RSA *)ASN1_item_d2i_bio(&RSAPrivateKey_it, bp, rsa);
}

int i2d_RSAPrivateKey_bio(BIO *bp, RSA *rsa)
{
  return ASN1_item_i2d_bio(&RSAPrivateKey_it, bp, rsa);
}

RSA *__cdecl d2i_RSAPrivateKey_fp(FILE *fp, RSA **rsa)
{
  return (RSA *)ASN1_item_d2i_fp(&RSAPrivateKey_it, fp, rsa);
}

int i2d_RSAPrivateKey_fp(FILE *fp, RSA *rsa)
{
  return ASN1_item_i2d_fp(&RSAPrivateKey_it, fp, rsa);
}

RSA *__cdecl d2i_RSAPublicKey_bio(BIO *bp, RSA **rsa)
{
  return (RSA *)ASN1_item_d2i_bio(&RSAPublicKey_it, bp, rsa);
}

int i2d_RSAPublicKey_bio(BIO *bp, RSA *rsa)
{
  return ASN1_item_i2d_bio(&RSAPublicKey_it, bp, rsa);
}

RSA *__cdecl d2i_RSAPublicKey_fp(FILE *fp, RSA **rsa)
{
  return (RSA *)ASN1_item_d2i_fp(&RSAPublicKey_it, fp, rsa);
}

int i2d_RSAPublicKey_fp(FILE *fp, RSA *rsa)
{
  return ASN1_item_i2d_fp(&RSAPublicKey_it, fp, rsa);
}

DSA *__cdecl d2i_DSAPrivateKey_bio(BIO *bp, DSA **dsa)
{
  return (DSA *)ASN1_item_d2i_bio(&DSAPrivateKey_it, bp, dsa);
}

int i2d_DSAPrivateKey_bio(BIO *bp, DSA *dsa)
{
  return ASN1_item_i2d_bio(&DSAPrivateKey_it, bp, dsa);
}

DSA *__cdecl d2i_DSAPrivateKey_fp(FILE *fp, DSA **dsa)
{
  return (DSA *)ASN1_item_d2i_fp(&DSAPrivateKey_it, fp, dsa);
}

int i2d_DSAPrivateKey_fp(FILE *fp, DSA *dsa)
{
  return ASN1_item_i2d_fp(&DSAPrivateKey_it, fp, dsa);
}

EC_KEY *__cdecl d2i_ECPrivateKey_bio(BIO *bp, EC_KEY **eckey)
{
  return (EC_KEY *)ASN1_d2i_bio((void *(*)(void))EC_KEY_new, (d2i_of_void *)d2i_ECPrivateKey, bp, (void **)eckey);
}

int i2d_ECPrivateKey_bio(BIO *bp, EC_KEY *eckey)
{
  return ASN1_i2d_bio((i2d_of_void *)i2d_ECPrivateKey, bp, (unsigned __int8 *)eckey);
}

EC_KEY *__cdecl d2i_ECPrivateKey_fp(FILE *fp, EC_KEY **eckey)
{
  return (EC_KEY *)ASN1_d2i_fp((void *(*)(void))EC_KEY_new, (d2i_of_void *)d2i_ECPrivateKey, fp, (void **)eckey);
}

int i2d_ECPrivateKey_fp(FILE *fp, EC_KEY *eckey)
{
  return ASN1_i2d_fp((i2d_of_void *)i2d_ECPrivateKey, fp, eckey);
}

X509_SIG *__cdecl d2i_PKCS8_bio(BIO *bp, X509_SIG **p8)
{
  return (X509_SIG *)ASN1_item_d2i_bio(&X509_SIG_it, bp, p8);
}

int i2d_PKCS8_bio(BIO *bp, X509_SIG *p8)
{
  return ASN1_item_i2d_bio(&X509_SIG_it, bp, p8);
}

X509_SIG *__cdecl d2i_PKCS8_fp(FILE *fp, X509_SIG **p8)
{
  return (X509_SIG *)ASN1_item_d2i_fp(&X509_SIG_it, fp, p8);
}

int i2d_PKCS8_fp(FILE *fp, X509_SIG *p8)
{
  return ASN1_item_i2d_fp(&X509_SIG_it, fp, p8);
}

PKCS8_PRIV_KEY_INFO *__cdecl d2i_PKCS8_PRIV_KEY_INFO_bio(BIO *bp, PKCS8_PRIV_KEY_INFO **p8inf)
{
  return (PKCS8_PRIV_KEY_INFO *)ASN1_item_d2i_bio(&PKCS8_PRIV_KEY_INFO_it, bp, p8inf);
}

int i2d_PKCS8_PRIV_KEY_INFO_bio(BIO *bp, PKCS8_PRIV_KEY_INFO *p8inf)
{
  return ASN1_item_i2d_bio(&PKCS8_PRIV_KEY_INFO_it, bp, p8inf);
}

PKCS8_PRIV_KEY_INFO *__cdecl d2i_PKCS8_PRIV_KEY_INFO_fp(FILE *fp, PKCS8_PRIV_KEY_INFO **p8inf)
{
  return (PKCS8_PRIV_KEY_INFO *)ASN1_item_d2i_fp(&PKCS8_PRIV_KEY_INFO_it, fp, p8inf);
}

int i2d_PKCS8_PRIV_KEY_INFO_fp(FILE *fp, PKCS8_PRIV_KEY_INFO *p8inf)
{
  return ASN1_item_i2d_fp(&PKCS8_PRIV_KEY_INFO_it, fp, p8inf);
}

EVP_PKEY *__cdecl d2i_PrivateKey_bio(BIO *bp, EVP_PKEY **a)
{
  return (EVP_PKEY *)ASN1_d2i_bio((void *(*)(void))EVP_PKEY_new, (d2i_of_void *)d2i_AutoPrivateKey, bp, (void **)a);
}

int i2d_PrivateKey_bio(BIO *bp, EVP_PKEY *pkey)
{
  return ASN1_i2d_bio((i2d_of_void *)i2d_PrivateKey, bp, (unsigned __int8 *)pkey);
}

EVP_PKEY *__cdecl d2i_PrivateKey_fp(FILE *fp, EVP_PKEY **a)
{
  return (EVP_PKEY *)ASN1_d2i_fp((void *(*)(void))EVP_PKEY_new, (d2i_of_void *)d2i_AutoPrivateKey, fp, (void **)a);
}

int i2d_PrivateKey_fp(FILE *fp, EVP_PKEY *pkey)
{
  return ASN1_i2d_fp((i2d_of_void *)i2d_PrivateKey, fp, pkey);
}

int i2d_PKCS8PrivateKeyInfo_bio(BIO *bp, EVP_PKEY *key)
{
  PKCS8_PRIV_KEY_INFO *v3;
  PKCS8_PRIV_KEY_INFO *v4;
  int v5;

  v3 = EVP_PKEY2PKCS8(key);
  if (v3)
  {
    v4 = v3;
    v5 = ASN1_item_i2d_bio(&PKCS8_PRIV_KEY_INFO_it, bp, v3);
    PKCS8_PRIV_KEY_INFO_free(v4);
    LODWORD(v3) = v5;
  }
  return (int)v3;
}

int i2d_PKCS8PrivateKeyInfo_fp(FILE *fp, EVP_PKEY *key)
{
  PKCS8_PRIV_KEY_INFO *v3;
  PKCS8_PRIV_KEY_INFO *v4;
  int v5;

  v3 = EVP_PKEY2PKCS8(key);
  if (v3)
  {
    v4 = v3;
    v5 = ASN1_item_i2d_fp(&PKCS8_PRIV_KEY_INFO_it, fp, v3);
    PKCS8_PRIV_KEY_INFO_free(v4);
    LODWORD(v3) = v5;
  }
  return (int)v3;
}

int X509_verify(X509 *a, EVP_PKEY *r)
{
  if (X509_ALGOR_cmp((uint64_t)a->sig_alg, (uint64_t)a->cert_info->signature))
    return 0;
  else
    return ASN1_item_verify(&X509_CINF_it, a->sig_alg, a->signature, a->cert_info, r);
}

int X509_REQ_verify(X509_REQ *a, EVP_PKEY *r)
{
  return ASN1_item_verify(&X509_REQ_INFO_it, a->sig_alg, a->signature, a->req_info, r);
}

int NETSCAPE_SPKI_verify(NETSCAPE_SPKI *a, EVP_PKEY *r)
{
  return ASN1_item_verify(&NETSCAPE_SPKAC_it, a->sig_algor, a->signature, a->spkac, r);
}

int X509_sign(X509 *x, EVP_PKEY *pkey, const EVP_MD *md)
{
  X509_ALGOR *sig_alg;
  X509_CINF *cert_info;

  cert_info = x->cert_info;
  sig_alg = x->sig_alg;
  cert_info->enc.modified = 1;
  return ASN1_item_sign(&X509_CINF_it, cert_info->signature, sig_alg, x->signature, cert_info, pkey, md);
}

uint64_t X509_sign_ctx(uint64_t *a1, EVP_MD_CTX *ctx)
{
  X509_ALGOR *v2;
  uint64_t v3;

  v3 = *a1;
  v2 = (X509_ALGOR *)a1[1];
  *(_DWORD *)(v3 + 96) = 1;
  return ASN1_item_sign_ctx(&X509_CINF_it, *(X509_ALGOR **)(v3 + 16), v2, (ASN1_STRING *)a1[2], (ASN1_VALUE *)v3, ctx);
}

int X509_REQ_sign(X509_REQ *x, EVP_PKEY *pkey, const EVP_MD *md)
{
  return ASN1_item_sign(&X509_REQ_INFO_it, x->sig_alg, 0, x->signature, x->req_info, pkey, md);
}

uint64_t X509_REQ_sign_ctx(uint64_t a1, EVP_MD_CTX *ctx)
{
  return ASN1_item_sign_ctx(&X509_REQ_INFO_it, *(X509_ALGOR **)(a1 + 8), 0, *(ASN1_STRING **)(a1 + 16), *(ASN1_VALUE **)a1, ctx);
}

int X509_CRL_sign(X509_CRL *x, EVP_PKEY *pkey, const EVP_MD *md)
{
  X509_ALGOR *sig_alg;
  X509_CRL_INFO *crl;

  crl = x->crl;
  sig_alg = x->sig_alg;
  crl->enc.modified = 1;
  return ASN1_item_sign(&X509_CRL_INFO_it, crl->sig_alg, sig_alg, x->signature, crl, pkey, md);
}

uint64_t X509_CRL_sign_ctx(uint64_t *a1, EVP_MD_CTX *ctx)
{
  X509_ALGOR *v2;
  uint64_t v3;

  v3 = *a1;
  v2 = (X509_ALGOR *)a1[1];
  *(_DWORD *)(v3 + 72) = 1;
  return ASN1_item_sign_ctx(&X509_CRL_INFO_it, *(X509_ALGOR **)(v3 + 8), v2, (ASN1_STRING *)a1[2], (ASN1_VALUE *)v3, ctx);
}

int NETSCAPE_SPKI_sign(NETSCAPE_SPKI *x, EVP_PKEY *pkey, const EVP_MD *md)
{
  return ASN1_item_sign(&NETSCAPE_SPKAC_it, x->sig_algor, 0, x->signature, x->spkac, pkey, md);
}

int X509_pubkey_digest(const X509 *data, const EVP_MD *type, unsigned __int8 *md, unsigned int *len)
{
  ASN1_BIT_STRING *v7;

  v7 = X509_get0_pubkey_bitstr(data);
  if (v7)
    LODWORD(v7) = EVP_Digest(v7->data, v7->length, md, len, type, 0);
  return (int)v7;
}

int X509_digest(const X509 *data, const EVP_MD *type, unsigned __int8 *md, unsigned int *len)
{
  return ASN1_item_digest(&X509_it, type, (void *)data, md, len);
}

int X509_CRL_digest(const X509_CRL *data, const EVP_MD *type, unsigned __int8 *md, unsigned int *len)
{
  return ASN1_item_digest(&X509_CRL_it, type, (void *)data, md, len);
}

int X509_REQ_digest(const X509_REQ *data, const EVP_MD *type, unsigned __int8 *md, unsigned int *len)
{
  return ASN1_item_digest(&X509_REQ_it, type, (void *)data, md, len);
}

int X509_NAME_digest(const X509_NAME *data, const EVP_MD *type, unsigned __int8 *md, unsigned int *len)
{
  return ASN1_item_digest(&X509_NAME_it, type, (void *)data, md, len);
}

BOOL X509_up_ref(uint64_t a1)
{
  return CRYPTO_add_lock((int *)(a1 + 28), 1, 3, 0, 0) > 1;
}

int EC_GROUP_check(const EC_GROUP *group, BN_CTX *ctx)
{
  BN_CTX *v4;
  BIGNUM *v5;
  BIGNUM *v6;
  const EC_POINT *v7;
  EC_POINT *v8;
  int v9;
  int v10;
  int v11;
  int v12;
  int v13;

  v4 = ctx;
  if (!ctx)
  {
    v4 = BN_CTX_new();
    if (!v4)
      goto LABEL_16;
  }
  BN_CTX_start(v4);
  v5 = BN_CTX_get(v4);
  if (!v5)
    goto LABEL_16;
  v6 = v5;
  if (!EC_GROUP_check_discriminant(group, v4))
  {
    v11 = 118;
    v12 = 79;
LABEL_15:
    ERR_put_error(16, 4095, v11, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_check.c", v12);
LABEL_16:
    v8 = 0;
    goto LABEL_17;
  }
  v7 = (const EC_POINT *)*((_QWORD *)group + 1);
  if (!v7)
  {
    v11 = 113;
    v12 = 84;
    goto LABEL_15;
  }
  if (EC_POINT_is_on_curve(group, v7, v4) <= 0)
  {
    v11 = 107;
    v12 = 88;
    goto LABEL_15;
  }
  v8 = EC_POINT_new(group);
  if (!v8 || !EC_GROUP_get_order(group, v6, v4))
    goto LABEL_17;
  if (BN_is_zero((uint64_t)v6))
  {
    v9 = 128;
    v10 = 97;
LABEL_11:
    ERR_put_error(16, 4095, v9, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_check.c", v10);
LABEL_17:
    v13 = 0;
    goto LABEL_18;
  }
  if (!EC_POINT_mul(group, v8, v6, 0, 0, v4))
    goto LABEL_17;
  if (EC_POINT_is_at_infinity(group, v8) <= 0)
  {
    v9 = 122;
    v10 = 103;
    goto LABEL_11;
  }
  v13 = 1;
LABEL_18:
  BN_CTX_end(v4);
  if (v4 != ctx)
    BN_CTX_free(v4);
  EC_POINT_free(v8);
  return v13;
}

uint64_t SM3_Update(unint64_t a1, char *__src, size_t __n)
{
  size_t v3;
  char *v4;
  uint64_t v6;
  _OWORD *v7;
  void *v8;
  uint64_t v9;

  if (__n)
  {
    v3 = __n;
    v4 = __src;
    *(_QWORD *)(a1 + 32) += 8 * __n;
    v6 = *(unsigned int *)(a1 + 104);
    if ((_DWORD)v6)
    {
      v7 = (_OWORD *)(a1 + 40);
      v8 = (void *)(a1 + 40 + v6);
      if (__n <= 0x3F && v6 + __n < 0x40)
      {
        memcpy(v8, __src, __n);
        *(_DWORD *)(a1 + 104) += v3;
        return 1;
      }
      v9 = 64 - v6;
      memcpy(v8, __src, 64 - v6);
      SM3_block_data_order(a1, a1 + 40, 1);
      v4 += v9;
      v3 -= v9;
      *(_DWORD *)(a1 + 104) = 0;
      *v7 = 0u;
      *(_OWORD *)(a1 + 56) = 0u;
      *(_OWORD *)(a1 + 72) = 0u;
      *(_OWORD *)(a1 + 88) = 0u;
    }
    if (v3 >= 0x40)
    {
      SM3_block_data_order(a1, (uint64_t)v4, v3 >> 6);
      v4 += v3 & 0xFFFFFFFFFFFFFFC0;
      v3 &= 0x3Fu;
    }
    if (v3)
    {
      *(_DWORD *)(a1 + 104) = v3;
      memcpy((void *)(a1 + 40), v4, v3);
    }
  }
  return 1;
}

unint64_t SM3_block_data_order(unint64_t result, uint64_t a2, uint64_t a3)
{
  int v3;
  int v4;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  unsigned int v11;
  unsigned int v12;
  unsigned int v13;
  unsigned int v14;
  unsigned int v15;
  unsigned int v16;
  unsigned int v17;
  unsigned int v18;
  unsigned int v19;
  unint64_t v20;
  int v21;
  int v22;
  int v23;
  unsigned int v24;
  unsigned int v25;
  int v26;
  int v27;
  unint64_t v28;
  unsigned int v29;
  int v30;
  unint64_t v31;
  int v32;
  unsigned int v33;
  unsigned int v34;
  unint64_t v35;
  int v36;
  int v37;
  unsigned int v38;
  unint64_t v39;
  unsigned int v40;
  int v41;
  int v42;
  unint64_t v43;
  int v44;
  unint64_t v45;
  unsigned int v46;
  unsigned int v47;
  int v48;
  unsigned int v49;
  int v50;
  unint64_t v51;
  int v52;
  int v53;
  int v54;
  unint64_t v55;
  unsigned int v56;
  int v57;
  unint64_t v58;
  unsigned int v59;
  int v60;
  unint64_t v61;
  unsigned int v62;
  int v63;
  unint64_t v64;
  int v65;
  int v66;
  unint64_t v67;
  unsigned int v68;
  int v69;
  unsigned int v70;
  unint64_t v71;
  int v72;
  int v73;
  int v74;
  int v75;
  unint64_t v76;
  int v77;
  int v78;
  unsigned int v79;
  unint64_t v80;
  int v81;
  int v82;
  int v83;
  int v84;
  unint64_t v85;
  int v86;
  unsigned int v87;
  unint64_t v88;
  unsigned int v89;
  int v90;
  int v91;
  unint64_t v92;
  int v93;
  int v94;
  unint64_t v95;
  unsigned int v96;
  int v97;
  unint64_t v98;
  unsigned int v99;
  int v100;
  int v101;
  unint64_t v102;
  int v103;
  int v104;
  unsigned int v105;
  unint64_t v106;
  int v107;
  int v108;
  unint64_t v109;
  int v110;
  int v111;
  unsigned int v112;
  unsigned int v113;
  int v114;
  int v115;
  unint64_t v116;
  int v117;
  unint64_t v118;
  unsigned int v119;
  int v120;
  int v121;
  unint64_t v122;
  int v123;
  int v124;
  unint64_t v125;
  int v126;
  int v127;
  unsigned int v128;
  int v129;
  unint64_t v130;
  unsigned int v131;
  unsigned int v132;
  int v133;
  int v134;
  unint64_t v135;
  int v136;
  unint64_t v137;
  int v138;
  int v139;
  unsigned int v140;
  unint64_t v141;
  int v142;
  int v143;
  unint64_t v144;
  unsigned int v145;
  int v146;
  int v147;
  unint64_t v148;
  int v149;
  int v150;
  int v151;
  unint64_t v152;
  int v153;
  unint64_t v154;
  int v155;
  unsigned int v156;
  int v157;
  unint64_t v158;
  int v159;
  int v160;
  unint64_t v161;
  unsigned int v162;
  int v163;
  int v164;
  unsigned int v165;
  int v166;
  int v167;
  unint64_t v168;
  int v169;
  unint64_t v170;
  int v171;
  unsigned int v172;
  unint64_t v173;
  int v174;
  int v175;
  int v176;
  int v177;
  int v178;
  int v179;
  unsigned int v180;
  int v181;
  int v182;
  unint64_t v183;
  unsigned int v184;
  unsigned int v185;
  int v186;
  int v187;
  unint64_t v188;
  int v189;
  unint64_t v190;
  int v191;
  int v192;
  int v193;
  unsigned int v194;
  int v195;
  int v196;
  unint64_t v197;
  int v198;
  int v199;
  unint64_t v200;
  int v201;
  int v202;
  int v203;
  unint64_t v204;
  int v205;
  int v206;
  int v207;
  int v208;
  int v209;
  int v210;
  int v211;
  int v212;
  int v213;
  unint64_t v214;
  int v215;
  int v216;
  unint64_t v217;
  int v218;
  unsigned int v219;
  int v220;
  int v221;
  unint64_t v222;
  int v223;
  int v224;
  int v225;
  int v226;
  int v227;
  int v228;
  unint64_t v229;
  int v230;
  int v231;
  int v232;
  unint64_t v233;
  int v234;
  int v235;
  unint64_t v236;
  unsigned int v237;
  int v238;
  int v239;
  int v240;
  int v241;
  int v242;
  int v243;
  int v244;
  unint64_t v245;
  int v246;
  int v247;
  int v248;
  unint64_t v249;
  unsigned int v250;
  int v251;
  int v252;
  unint64_t v253;
  int v254;
  int v255;
  int v256;
  unint64_t v257;
  int v258;
  int v259;
  int v260;
  unsigned int v261;
  int v262;
  int v263;
  unint64_t v264;
  int v265;
  int v266;
  int v267;
  unint64_t v268;
  int v269;
  int v270;
  int v271;
  int v272;
  unint64_t v273;
  unsigned int v274;
  int v275;
  int v276;
  int v277;
  int v278;
  unint64_t v279;
  unsigned int v280;
  int v281;
  unsigned int v282;
  int v283;
  unint64_t v284;
  int v285;
  int v286;
  unint64_t v287;
  int v288;
  int v289;
  unint64_t v290;
  int v291;
  int v292;
  unint64_t v293;
  unsigned int v294;
  unsigned int v295;
  unint64_t v296;
  int v297;
  int v298;
  int v299;
  int v300;
  unint64_t v301;
  int v302;
  int v303;
  unsigned int v304;
  int v305;
  int v306;
  int v307;
  int v308;
  unint64_t v309;
  int v310;
  int v311;
  int v312;
  unint64_t v313;
  int v314;
  int v315;
  int v316;
  int v317;
  unsigned int v318;
  int v319;
  int v320;
  unsigned int v321;
  int v322;
  unint64_t v323;
  int v324;
  int v325;
  int v326;
  unint64_t v327;
  int v328;
  int v329;
  int v330;
  unint64_t v331;
  unsigned int v332;
  int v333;
  int v334;
  int v335;
  int v336;
  unint64_t v337;
  unsigned int v338;
  int v339;
  unsigned int v340;
  int v341;
  unint64_t v342;
  int v343;
  int v344;
  unint64_t v345;
  int v346;
  int v347;
  unint64_t v348;
  int v349;
  unint64_t v350;
  unsigned int v351;
  unsigned int v352;
  unint64_t v353;
  int v354;
  int v355;
  int v356;
  unint64_t v357;
  int v358;
  int v359;
  unsigned int v360;
  int v361;
  int v362;
  int v363;
  int v364;
  unint64_t v365;
  int v366;
  int v367;
  int v368;
  unint64_t v369;
  int v370;
  int v371;
  int v372;
  int v373;
  unsigned int v374;
  int v375;
  int v376;
  int v377;
  unint64_t v378;
  int v379;
  int v380;
  int v381;
  unint64_t v382;
  int v383;
  int v384;
  int v385;
  int v386;
  unint64_t v387;
  unsigned int v388;
  int v389;
  int v390;
  int v391;
  int v392;
  unint64_t v393;
  unsigned int v394;
  int v395;
  int v396;
  unsigned int v397;
  int v398;
  unint64_t v399;
  int v400;
  int v401;
  unint64_t v402;
  int v403;
  int v404;
  unint64_t v405;
  int v406;
  int v407;
  unint64_t v408;
  unsigned int v409;
  unint64_t v410;
  int v411;
  int v412;
  int v413;
  int v414;
  unint64_t v415;
  int v416;
  int v417;
  unsigned int v418;
  int v419;
  int v420;
  int v421;
  int v422;
  int v423;
  unint64_t v424;
  int v425;
  int v426;
  int v427;
  unint64_t v428;
  int v429;
  int v430;
  int v431;
  int v432;
  unsigned int v433;
  int v434;
  int v435;
  unint64_t v436;
  int v437;
  int v438;
  int v439;
  unint64_t v440;
  int v441;
  int v442;
  int v443;
  int v444;
  unint64_t v445;
  unsigned int v446;
  int v447;
  int v448;
  int v449;
  int v450;
  unint64_t v451;
  unsigned int v452;
  int v453;
  int v454;
  unsigned int v455;
  int v456;
  unint64_t v457;
  int v458;
  int v459;
  unint64_t v460;
  int v461;
  int v462;
  unint64_t v463;
  int v464;
  unint64_t v465;
  unsigned int v466;
  unint64_t v467;
  int v468;
  int v469;
  int v470;
  int v471;
  unint64_t v472;
  int v473;
  unsigned int v474;
  int v475;
  int v476;
  int v477;
  int v478;
  int v479;
  unint64_t v480;
  int v481;
  int v482;
  int v483;
  unint64_t v484;
  int v485;
  int v486;
  int v487;
  unsigned int v488;
  int v489;
  int v490;
  unsigned int v491;
  unsigned int v492;
  int v493;
  unint64_t v494;
  int v495;
  int v496;
  int v497;
  unint64_t v498;
  int v499;
  int v500;
  int v501;
  unint64_t v502;
  unsigned int v503;
  int v504;
  int v505;
  int v506;
  int v507;
  unint64_t v508;
  unsigned int v509;
  int v510;
  int v511;
  unsigned int v512;
  int v513;
  unint64_t v514;
  int v515;
  int v516;
  unint64_t v517;
  int v518;
  int v519;
  unint64_t v520;
  int v521;
  int v522;
  unint64_t v523;
  unsigned int v524;
  unsigned int v525;
  unint64_t v526;
  int v527;
  int v528;
  int v529;
  unint64_t v530;
  int v531;
  unsigned int v532;
  int v533;
  int v534;
  int v535;
  int v536;
  unint64_t v537;
  int v538;
  int v539;
  int v540;
  unint64_t v541;
  int v542;
  int v543;
  int v544;
  int v545;
  unsigned int v546;
  int v547;
  int v548;
  int v549;
  unint64_t v550;
  int v551;
  int v552;
  int v553;
  unint64_t v554;
  int v555;
  int v556;
  int v557;
  unint64_t v558;
  int v559;
  int v560;
  int v561;
  int v562;
  unint64_t v563;
  unsigned int v564;
  int v565;
  unsigned int v566;
  int v567;
  unint64_t v568;
  int v569;
  int v570;
  unint64_t v571;
  int v572;
  int v573;
  unint64_t v574;
  int v575;
  unint64_t v576;
  unsigned int v577;
  unsigned int v578;
  unint64_t v579;
  int v580;
  int v581;
  int v582;
  unint64_t v583;
  int v584;
  unsigned int v585;
  int v586;
  int v587;
  int v588;
  int v589;
  unint64_t v590;
  unsigned int v591;
  int v592;
  int v593;
  int v594;
  unint64_t v595;
  int v596;
  int v597;
  int v598;
  int v599;
  unsigned int v600;
  int v601;
  int v602;
  int v603;
  unint64_t v604;
  int v605;
  int v606;
  int v607;
  unint64_t v608;
  int v609;
  int v610;
  int v611;
  unint64_t v612;
  unsigned int v613;
  int v614;
  int v615;
  int v616;
  int v617;
  unint64_t v618;
  unsigned int v619;
  int v620;
  unsigned int v621;
  int v622;
  unint64_t v623;
  int v624;
  int v625;
  unint64_t v626;
  int v627;
  int v628;
  unint64_t v629;
  int v630;
  unint64_t v631;
  unsigned int v632;
  unsigned int v633;
  unint64_t v634;
  int v635;
  int v636;
  int v637;
  unint64_t v638;
  int v639;
  unsigned int v640;
  int v641;
  int v642;
  int v643;
  int v644;
  unint64_t v645;
  int v646;
  int v647;
  int v648;
  unint64_t v649;
  int v650;
  int v651;
  int v652;
  int v653;
  unsigned int v654;
  int v655;
  int v656;
  int v657;
  unint64_t v658;
  int v659;
  int v660;
  int v661;
  unint64_t v662;
  int v663;
  int v664;
  int v665;
  int v666;
  unint64_t v667;
  int v668;
  int v669;
  int v670;
  int v671;
  unint64_t v672;
  unsigned int v673;
  int v674;
  unsigned int v675;
  int v676;
  unint64_t v677;
  int v678;
  int v679;
  unint64_t v680;
  int v681;
  int v682;
  unint64_t v683;
  int v684;
  int v685;
  unint64_t v686;
  unsigned int v687;
  unsigned int v688;
  unint64_t v689;
  int v690;
  int v691;
  int v692;
  int v693;
  unint64_t v694;
  int v695;
  unsigned int v696;
  int v697;
  int v698;
  int v699;
  int v700;
  unint64_t v701;
  int v702;
  int v703;
  int v704;
  unint64_t v705;
  int v706;
  int v707;
  int v708;
  unsigned int v709;
  int v710;
  int v711;
  int v712;
  unint64_t v713;
  int v714;
  int v715;
  int v716;
  unint64_t v717;
  int v718;
  int v719;
  int v720;
  unint64_t v721;
  int v722;
  int v723;
  int v724;
  int v725;
  int v726;
  unint64_t v727;
  unsigned int v728;
  int v729;
  unsigned int v730;
  int v731;
  unint64_t v732;
  int v733;
  int v734;
  unint64_t v735;
  int v736;
  int v737;
  unint64_t v738;
  int v739;
  int v740;
  unint64_t v741;
  int v742;
  unsigned int v743;
  unint64_t v744;
  int v745;
  int v746;
  int v747;
  unint64_t v748;
  int v749;
  unsigned int v750;
  int v751;
  int v752;
  int v753;
  int v754;
  unint64_t v755;
  int v756;
  int v757;
  int v758;
  unint64_t v759;
  int v760;
  int v761;
  int v762;
  unsigned int v763;
  int v764;
  int v765;
  int v766;
  unint64_t v767;
  int v768;
  int v769;
  int v770;
  unint64_t v771;
  int v772;
  int v773;
  int v774;
  unint64_t v775;
  int v776;
  int v777;
  int v778;
  int v779;
  int v780;
  unint64_t v781;
  unsigned int v782;
  int v783;
  int v784;
  unsigned int v785;
  int v786;
  unint64_t v787;
  int v788;
  int v789;
  unint64_t v790;
  int v791;
  int v792;
  unint64_t v793;
  int v794;
  int v795;
  unint64_t v796;
  int v797;
  unsigned int v798;
  unint64_t v799;
  int v800;
  int v801;
  int v802;
  int v803;
  unint64_t v804;
  int v805;
  int v806;
  unsigned int v807;
  int v808;
  int v809;
  int v810;
  int v811;
  int v812;
  unint64_t v813;
  int v814;
  int v815;
  int v816;
  unint64_t v817;
  int v818;
  int v819;
  int v820;
  int v821;
  unsigned int v822;
  int v823;
  int v824;
  int v825;
  unint64_t v826;
  int v827;
  int v828;
  int v829;
  unint64_t v830;
  int v831;
  int v832;
  int v833;
  unint64_t v834;
  int v835;
  int v836;
  int v837;
  int v838;
  int v839;
  unint64_t v840;
  unsigned int v841;
  int v842;
  unsigned int v843;
  int v844;
  unint64_t v845;
  int v846;
  int v847;
  unint64_t v848;
  int v849;
  int v850;
  unint64_t v851;
  int v852;
  unint64_t v853;
  unsigned int v854;
  int v855;
  int v856;
  int v857;
  unint64_t v858;
  unsigned int v859;
  int v860;
  int v861;
  unsigned int v862;
  int v863;
  unint64_t v864;
  int v865;
  int v866;
  unint64_t v867;
  int v868;
  int v869;
  unint64_t v870;
  int v871;
  unint64_t v872;
  int v873;
  int v874;
  int v875;
  int v876;
  int v877;
  unint64_t v878;
  unsigned int v879;
  int v880;
  int v881;
  unsigned int v882;
  int v883;
  unint64_t v884;
  int v885;
  int v886;
  unint64_t v887;
  int v888;
  int v889;
  unint64_t v890;
  int v891;
  unint64_t v892;
  int v893;
  int v894;
  int v895;
  int v896;
  int v897;
  int v898;
  int v899;
  int v900;
  int v901;
  int v902;
  unint64_t v903;
  int v904;
  int v905;
  int v906;
  int v907;
  int v908;
  int v909;
  unint64_t v910;
  int v911;
  int v912;
  int v913;
  unsigned int v914;
  int v915;
  int v916;
  unint64_t v917;
  int v918;
  unsigned int v919;
  int v920;
  unint64_t v921;
  int v922;
  unint64_t v923;
  unsigned int v924;
  int v925;
  int v926;
  int v927;
  unint64_t v928;
  unsigned int v929;
  int v930;
  int v931;
  int v932;
  unint64_t v933;
  int v934;
  unsigned int v935;
  int v936;
  int v937;
  int v938;
  int v939;
  unint64_t v940;
  int v941;
  int v942;
  int v943;
  int v944;
  unint64_t v945;
  int v946;
  unsigned int v947;
  unsigned int v948;
  unint64_t v949;
  int v950;
  int v951;
  int v952;
  int v953;
  int v954;
  unint64_t v955;
  int v956;
  int v957;
  unsigned int v958;
  int v959;
  unint64_t v960;
  int v961;
  int v962;
  unint64_t v963;
  unsigned int v964;
  int v965;
  int v966;
  int v967;
  unint64_t v968;
  int v969;
  int v970;
  int v971;
  int v972;
  int v973;
  int v974;
  int v975;
  unint64_t v976;
  int v977;
  int v978;
  int v979;
  int v980;
  int v981;
  int v982;
  int v983;
  int v984;
  int v985;
  int v986;
  unint64_t v987;
  int v988;
  int v989;
  int v990;
  int v991;
  int v992;
  int v993;
  int v994;
  int v995;
  int v996;
  int v997;
  unsigned int v998;
  int v999;
  unint64_t v1000;
  int v1001;
  int v1002;
  int v1003;
  unint64_t v1004;
  unsigned int v1005;
  int v1006;
  int v1007;
  int v1008;
  unint64_t v1009;
  unsigned int v1010;
  int v1011;
  int v1012;
  int v1013;
  unint64_t v1014;
  unsigned int v1015;
  int v1016;
  int v1017;
  int v1018;
  int v1019;
  int v1020;
  unint64_t v1021;
  int v1022;
  int v1023;
  int v1024;
  int v1025;
  int v1026;
  int v1027;
  int v1028;
  int v1029;
  int v1030;
  unint64_t v1031;
  int v1032;
  int v1033;
  unint64_t v1034;
  int v1035;
  int v1036;
  unsigned int v1037;
  unsigned int v1038;
  int v1039;
  int v1040;
  unint64_t v1041;
  int v1042;
  int v1043;
  unint64_t v1044;
  int v1045;
  int v1046;
  int v1047;
  unsigned int v1048;
  int v1049;
  int v1050;
  int v1051;
  unint64_t v1052;
  int v1053;
  unsigned int v1054;
  unsigned int v1055;
  int v1056;
  unint64_t v1057;
  int v1058;
  unint64_t v1059;
  int v1060;
  int v1061;
  int v1062;
  int v1063;
  int v1064;
  int v1065;
  unsigned int v1066;
  int v1067;
  int v1068;
  unint64_t v1069;
  int v1070;
  int v1071;
  int *v1072;
  int v1073;
  unsigned int v1074;
  int v1075;
  unsigned int v1076;
  unsigned int v1077;
  int v1078;
  unsigned int v1079;
  unsigned int v1080;
  int v1081;
  unsigned int v1082;
  unsigned int v1083;
  int v1084;
  int v1085;
  int v1086;
  int v1087;
  uint64_t v1088;
  unsigned int v1089;
  unsigned int v1090;
  unsigned int v1091;
  unsigned int v1092;
  unsigned int v1093;
  unsigned int v1094;
  unsigned int v1095;
  unsigned int v1096;
  unsigned int v1097;
  int v1098;
  int v1099;
  int v1100;

  v1072 = (int *)result;
  if (a3)
  {
    v3 = *(_DWORD *)result;
    v4 = *(_DWORD *)(result + 4);
    v6 = *(_DWORD *)(result + 8);
    v5 = *(_DWORD *)(result + 12);
    v8 = *(_DWORD *)(result + 16);
    v7 = *(_DWORD *)(result + 20);
    v10 = *(_DWORD *)(result + 24);
    v9 = *(_DWORD *)(result + 28);
    do
    {
      v1097 = v8;
      v1098 = v6;
      v1099 = v4;
      v1100 = v3;
      v1088 = a3;
      v11 = _byteswap_ulong(*(_DWORD *)(a2 + 12));
      v12 = _byteswap_ulong(*(_DWORD *)(a2 + 16));
      v13 = _byteswap_ulong(*(_DWORD *)(a2 + 20));
      v14 = _byteswap_ulong(*(_DWORD *)(a2 + 24));
      v15 = _byteswap_ulong(*(_DWORD *)(a2 + 28));
      v16 = _byteswap_ulong(*(_DWORD *)(a2 + 32));
      v17 = _byteswap_ulong(*(_DWORD *)(a2 + 36));
      v18 = _byteswap_ulong(*(_DWORD *)(a2 + 40));
      v1091 = *(unsigned __int8 *)(a2 + 52);
      v1094 = *(unsigned __int8 *)(a2 + 56);
      v1074 = _byteswap_ulong(*(_DWORD *)(a2 + 48));
      v19 = (v1091 << 24) | (*(unsigned __int8 *)(a2 + 53) << 16) | (bswap32(*(unsigned __int16 *)(a2 + 54)) >> 16);
      v1089 = *(unsigned __int8 *)(a2 + 60);
      v1077 = (v1094 << 24) | (*(unsigned __int8 *)(a2 + 57) << 16) | (bswap32(*(unsigned __int16 *)(a2 + 58)) >> 16);
      v1076 = (v1089 << 24) | (*(unsigned __int8 *)(a2 + 61) << 16) | (bswap32(*(unsigned __int16 *)(a2 + 62)) >> 16);
      HIDWORD(v20) = v3;
      LODWORD(v20) = v3;
      HIDWORD(v20) = (v20 >> 20) + v8 + 2043430169;
      LODWORD(v20) = HIDWORD(v20);
      v21 = v20 >> 25;
      v1086 = v9;
      v1087 = v5;
      v22 = (v4 ^ v3 ^ v6) + v5 + (v21 ^ __ROR4__(v3, 20));
      v1085 = v10;
      v23 = v9 + (v7 ^ v8 ^ v10) + v21;
      v24 = bswap32(*(_DWORD *)a2);
      v25 = v22 + (v12 ^ v24);
      v26 = v23 + v24;
      HIDWORD(v20) = v23 + v24;
      LODWORD(v20) = v23 + v24;
      v27 = v20 >> 15;
      v28 = __PAIR64__(v19, __ROR4__(v26, 23));
      v29 = v27 ^ v28 ^ v26;
      LODWORD(v28) = (v1091 << 24) | (*(unsigned __int8 *)(a2 + 53) << 16);
      v30 = (v28 >> 17) ^ v15 ^ v24;
      v31 = __PAIR64__(v25, __ROR4__(v30, 17));
      v32 = ((*(unsigned __int8 *)(a2 + 12) >> 1) | (v11 << 7)) ^ __ROR4__(v30, 9) ^ v31 ^ v30 ^ v18;
      LODWORD(v31) = v25;
      v33 = v29 - 208106958 + (v31 >> 20);
      v34 = bswap32(*(_DWORD *)(a2 + 4));
      v35 = __PAIR64__(v33, __ROR4__(v1099, 23));
      v36 = (v1100 ^ v35 ^ v25) + v1098 + (v13 ^ v34);
      LODWORD(v35) = v33;
      v37 = v35 >> 25;
      v38 = v36 + (v37 ^ __ROR4__(v25, 20));
      v1084 = v7;
      v39 = __PAIR64__(v1077, __ROR4__(v7, 13));
      v40 = v34 + v10 + (v1097 ^ v39 ^ v29) + v37;
      LODWORD(v39) = (v1094 << 24) | (*(unsigned __int8 *)(a2 + 57) << 16);
      v41 = (v39 >> 17) ^ v16 ^ v34;
      v43 = __PAIR64__(v40, __ROR4__(v41, 17));
      v42 = ((*(unsigned __int8 *)(a2 + 16) >> 1) | (v12 << 7)) ^ __ROR4__(v41, 9) ^ v43;
      LODWORD(v43) = v40;
      v44 = v43 >> 15;
      v45 = __PAIR64__(v1099, __ROR4__(v40, 23));
      v46 = v44 ^ v45 ^ v40;
      v47 = _byteswap_ulong(*(_DWORD *)(a2 + 44));
      v48 = v42 ^ v41 ^ v47;
      v49 = bswap32(*(_DWORD *)(a2 + 8));
      LODWORD(v45) = v1099;
      v50 = (v14 ^ v49) + (v45 >> 23);
      v51 = __PAIR64__(v38, __ROR4__(v1100, 23));
      v52 = v25 ^ v51 ^ v38;
      LODWORD(v51) = v38;
      v53 = v50 + v52;
      HIDWORD(v51) = (v51 >> 20) - 416213915 + v46;
      LODWORD(v51) = HIDWORD(v51);
      v54 = v51 >> 25;
      v55 = __PAIR64__(v7, __ROR4__(v38, 20));
      v56 = v53 + (v54 ^ v55);
      LODWORD(v55) = v7;
      v57 = v49 + (v55 >> 13);
      v58 = __PAIR64__(v1076, __ROR4__(v1097, 13));
      v59 = v57 + (v29 ^ v58 ^ v46) + v54;
      LODWORD(v58) = (v1089 << 24) | (*(unsigned __int8 *)(a2 + 61) << 16);
      v60 = (v58 >> 17) ^ v17 ^ v49;
      v61 = __PAIR64__(v1100, __ROR4__(v60, 17));
      v62 = ((*(unsigned __int8 *)(a2 + 20) >> 1) | (v13 << 7)) ^ __ROR4__(v60, 9) ^ v61 ^ v60 ^ v1074;
      LODWORD(v61) = v1100;
      v63 = (v15 ^ v11) + (v61 >> 23);
      v64 = __PAIR64__(v59, __ROR4__(v25, 23));
      v65 = v63 + (v38 ^ v64 ^ v56);
      LODWORD(v64) = v59;
      v66 = v64 >> 15;
      v67 = __PAIR64__(v56, __ROR4__(v59, 23));
      v68 = v66 ^ v67 ^ v59;
      LODWORD(v67) = v56;
      HIDWORD(v67) = (v67 >> 20) - 832427829 + v68;
      LODWORD(v67) = HIDWORD(v67);
      v69 = v67 >> 25;
      v70 = v65 + (v69 ^ __ROR4__(v56, 20));
      v71 = __PAIR64__(v1097, __ROR4__(v29, 13));
      v72 = v46 ^ v71 ^ v68;
      LODWORD(v71) = v1097;
      v73 = v11 + (v71 >> 13) + v72 + v69;
      v74 = v32;
      v1073 = v32;
      v75 = v18 ^ v11 ^ __ROR4__(v32, 17);
      v76 = __PAIR64__(v25, __ROR4__(v75, 17));
      v77 = ((*(unsigned __int8 *)(a2 + 24) >> 1) | (v14 << 7)) ^ __ROR4__(v75, 9) ^ v76 ^ v18 ^ v11;
      LODWORD(v76) = v25;
      v78 = (v16 ^ v12) + (v76 >> 23);
      HIDWORD(v76) = v73;
      LODWORD(v76) = v73;
      v79 = (v76 >> 15) ^ __ROR4__(v73, 23) ^ v73;
      v80 = __PAIR64__(v29, __ROR4__(v38, 23));
      v81 = v78 + (v56 ^ v80 ^ v70);
      LODWORD(v80) = v29;
      v82 = v12 + (v80 >> 13) + (v68 ^ __ROR4__(v46, 13) ^ v79);
      v83 = v47 ^ v12 ^ __ROR4__(v48, 17);
      v1075 = v48;
      v85 = __PAIR64__(v70, __ROR4__(v83, 17));
      v84 = ((*(unsigned __int8 *)(a2 + 28) >> 1) | (v15 << 7)) ^ __ROR4__(v83, 9) ^ v85;
      LODWORD(v85) = v70;
      HIDWORD(v85) = (v85 >> 20) - 1664855657 + v79;
      LODWORD(v85) = HIDWORD(v85);
      v86 = v85 >> 25;
      v87 = v82 + v86;
      v88 = __PAIR64__(v38, __ROR4__(v70, 20));
      v89 = v81 + (v86 ^ v88);
      v90 = v84 ^ v47 ^ v12;
      LODWORD(v88) = v38;
      v91 = (v17 ^ v13) + (v88 >> 23);
      v92 = __PAIR64__(v87, __ROR4__(v56, 23));
      v93 = v91 + (v70 ^ v92 ^ v89);
      LODWORD(v92) = v87;
      v94 = v92 >> 15;
      v95 = __PAIR64__(v89, __ROR4__(v87, 23));
      v96 = v94 ^ v95 ^ v87;
      LODWORD(v95) = v89;
      HIDWORD(v95) = (v95 >> 20) + 965255983 + v96;
      LODWORD(v95) = HIDWORD(v95);
      v97 = v95 >> 25;
      v98 = __PAIR64__(v46, __ROR4__(v89, 20));
      v99 = v93 + (v97 ^ v98);
      LODWORD(v98) = v46;
      v100 = (v98 >> 13) + v13 + (v79 ^ __ROR4__(v68, 13) ^ v96) + v97;
      v101 = v1074 ^ v13 ^ __ROR4__(v62, 17);
      v102 = __PAIR64__(v56, __ROR4__(v101, 17));
      v103 = ((*(unsigned __int8 *)(a2 + 32) >> 1) | (v16 << 7)) ^ __ROR4__(v101, 9) ^ v102 ^ v1074 ^ v13;
      LODWORD(v102) = v56;
      v104 = (v18 ^ v14) + (v102 >> 23);
      HIDWORD(v102) = v100;
      LODWORD(v102) = v100;
      v105 = (v102 >> 15) ^ __ROR4__(v100, 23) ^ v100;
      v106 = __PAIR64__(v68, __ROR4__(v70, 23));
      v107 = v104 + (v89 ^ v106 ^ v99);
      LODWORD(v106) = v68;
      v108 = v106 >> 13;
      v109 = __PAIR64__(v99, __ROR4__(v79, 13));
      v110 = v108 + v14 + (v96 ^ v109 ^ v105);
      LODWORD(v109) = v99;
      HIDWORD(v109) = (v109 >> 20) + 1930511966 + v105;
      LODWORD(v109) = HIDWORD(v109);
      v111 = v109 >> 25;
      v112 = v110 + v111;
      v113 = v107 + (v111 ^ __ROR4__(v99, 20));
      v1078 = v77 ^ __ROR4__(v74, 17) ^ v19;
      v114 = v19 ^ v14 ^ __ROR4__(v1078, 17);
      v116 = __PAIR64__(v112, __ROR4__(v114, 17));
      v115 = ((*(unsigned __int8 *)(a2 + 36) >> 1) | (v17 << 7)) ^ __ROR4__(v114, 9) ^ v116;
      LODWORD(v116) = v112;
      v117 = v116 >> 15;
      v118 = __PAIR64__(v70, __ROR4__(v112, 23));
      v119 = v117 ^ v118 ^ v112;
      v120 = v115 ^ v19 ^ v14;
      LODWORD(v118) = v70;
      v121 = (v47 ^ v15) + (v118 >> 23);
      v122 = __PAIR64__(v79, __ROR4__(v89, 23));
      v123 = v121 + (v99 ^ v122 ^ v113);
      LODWORD(v122) = v79;
      v124 = v122 >> 13;
      v125 = __PAIR64__(v113, __ROR4__(v96, 13));
      v126 = v124 + v15 + (v105 ^ v125 ^ v119);
      LODWORD(v125) = v113;
      HIDWORD(v125) = (v125 >> 20) - 433943364 + v119;
      LODWORD(v125) = HIDWORD(v125);
      v127 = v125 >> 25;
      v128 = v126 + v127;
      v130 = __PAIR64__(v128, __ROR4__(v113, 20));
      v129 = v127 ^ v130;
      LODWORD(v130) = v128;
      v131 = v123 + v129;
      v132 = (v130 >> 15) ^ __ROR4__(v128, 23) ^ v128;
      v1081 = v90 ^ __ROR4__(v48, 17) ^ v1077;
      v133 = v1077 ^ v15 ^ __ROR4__(v1081, 17);
      v135 = __PAIR64__(v89, __ROR4__(v133, 9));
      v134 = ((*(unsigned __int8 *)(a2 + 40) >> 1) | (v18 << 7)) ^ v135;
      LODWORD(v135) = v89;
      v136 = v135 >> 23;
      v137 = __PAIR64__(v131, __ROR4__(v133, 17));
      v138 = v134 ^ v137 ^ v1077 ^ v15;
      v139 = (v1074 ^ v16) + v136;
      LODWORD(v137) = v131;
      v140 = (v137 >> 20) - 867886727 + v132;
      v141 = __PAIR64__(v140, __ROR4__(v99, 23));
      v142 = v113 ^ v141 ^ v131;
      LODWORD(v141) = v140;
      v143 = v141 >> 25;
      v144 = __PAIR64__(v96, __ROR4__(v131, 20));
      v145 = v139 + v142 + (v143 ^ v144);
      LODWORD(v144) = v96;
      v146 = (v144 >> 13) + v16 + (v119 ^ __ROR4__(v105, 13) ^ v132);
      v148 = __PAIR64__(v99, __ROR4__(v62, 17));
      v147 = v103 ^ v148;
      LODWORD(v148) = v99;
      v149 = v148 >> 23;
      HIDWORD(v148) = v146 + v143;
      LODWORD(v148) = v146 + v143;
      v150 = (v148 >> 15) ^ __ROR4__(v146 + v143, 23) ^ (v146 + v143);
      v152 = __PAIR64__(v105, __ROR4__(v147 ^ v1076, 17));
      v151 = v1076 ^ v16 ^ v152;
      LODWORD(v152) = v105;
      v153 = v152 >> 13;
      v154 = __PAIR64__(v145, __ROR4__(v151, 17));
      v155 = ((*(unsigned __int8 *)(a2 + 44) >> 1) | (v47 << 7)) ^ __ROR4__(v151, 9) ^ v154 ^ v1076 ^ v16;
      LODWORD(v154) = v145;
      v156 = (v154 >> 20) - 1735773453 + v150;
      v158 = __PAIR64__(v156, __ROR4__(v113, 23));
      v157 = v131 ^ v158;
      LODWORD(v158) = v156;
      v159 = v158 >> 25;
      v160 = v149 + (v19 ^ v17) + (v157 ^ v145) + (v159 ^ __ROR4__(v145, 20));
      v161 = __PAIR64__(v113, __ROR4__(v1078, 17));
      v162 = v120 ^ v161 ^ v1073;
      LODWORD(v161) = v113;
      v163 = v161 >> 23;
      HIDWORD(v161) = v153 + v17 + (v132 ^ __ROR4__(v119, 13) ^ v150) + v159;
      LODWORD(v161) = HIDWORD(v161);
      v164 = v1073 ^ v17;
      v165 = (v161 >> 15) ^ __ROR4__(HIDWORD(v161), 23) ^ HIDWORD(v161);
      LODWORD(v161) = __ROR4__(v162, 17);
      v166 = v164 ^ v161;
      v168 = __PAIR64__(v119, __ROR4__(v164 ^ v161, 9));
      v167 = ((*(unsigned __int8 *)(a2 + 48) >> 1) | (v1074 << 7)) ^ v168;
      LODWORD(v168) = v119;
      v169 = v168 >> 13;
      v170 = __PAIR64__(v160, __ROR4__(v166, 17));
      v171 = v167 ^ v170 ^ v164;
      LODWORD(v170) = v160;
      v172 = (v170 >> 20) + 823420391 + v165;
      v173 = __PAIR64__(v172, __ROR4__(v131, 23));
      v174 = v145 ^ v173 ^ v160;
      LODWORD(v173) = v172;
      v175 = v173 >> 25;
      v176 = v163 + (v1077 ^ v18) + v174 + (v175 ^ __ROR4__(v160, 20));
      v177 = v169 + v18 + (v150 ^ __ROR4__(v132, 13) ^ v165);
      v178 = v138 ^ __ROR4__(v1081, 17);
      HIDWORD(v173) = v177 + v175;
      LODWORD(v173) = v177 + v175;
      v179 = v178 ^ v48;
      v180 = (v173 >> 15) ^ __ROR4__(HIDWORD(v173), 23) ^ HIDWORD(v173);
      v181 = v48 ^ v18;
      v182 = v181 ^ __ROR4__(v178 ^ v48, 17);
      v183 = __PAIR64__(v131, __ROR4__(v147 ^ v1076, 17));
      v184 = v62;
      v185 = v155 ^ v183 ^ v62;
      LODWORD(v183) = v131;
      v186 = v183 >> 23;
      v188 = __PAIR64__(v132, __ROR4__(v178 ^ v48, 17));
      v187 = ((v1091 >> 1) | (v19 << 7)) ^ __ROR4__(v182, 9) ^ __ROR4__(v182, 17) ^ v181 ^ v188;
      LODWORD(v188) = v132;
      v189 = v188 >> 13;
      v190 = __PAIR64__(v176, __ROR4__(v150, 13));
      v191 = v189 + v47 + (v165 ^ v190 ^ v180);
      LODWORD(v190) = v176;
      v192 = v171 ^ __ROR4__(v162, 17) ^ v1078;
      HIDWORD(v190) = (v190 >> 20) + 1646840782 + v180;
      LODWORD(v190) = HIDWORD(v190);
      v193 = v190 >> 25;
      v194 = v191 + v193;
      v195 = v186 + (v1076 ^ v47) + (v160 ^ __ROR4__(v145, 23) ^ v176) + (v193 ^ __ROR4__(v176, 20));
      v197 = __PAIR64__(v145, __ROR4__(v185, 17));
      v196 = v62 ^ v47 ^ v197;
      LODWORD(v197) = v145;
      v198 = v197 >> 23;
      v200 = __PAIR64__(v194, __ROR4__(v196, 17));
      v199 = ((v1094 >> 1) | (v1077 << 7)) ^ __ROR4__(v196, 9) ^ v200;
      LODWORD(v200) = v194;
      v201 = v200 >> 15;
      HIDWORD(v200) = v150;
      LODWORD(v200) = v150;
      v202 = v200 >> 13;
      v203 = v187 ^ v1081;
      v204 = __PAIR64__(v195, __ROR4__(v185, 17));
      v1092 = v185;
      v1095 = v199 ^ v62 ^ v47 ^ v204 ^ v147 ^ v1076;
      v205 = v201 ^ __ROR4__(v194, 23) ^ v194;
      LODWORD(v204) = v195;
      v206 = v204 >> 20;
      v207 = v198 + (v1073 ^ v1074);
      HIDWORD(v204) = v160;
      LODWORD(v204) = v160;
      v208 = v204 >> 23;
      HIDWORD(v204) = v206 - 1001285732 + v205;
      LODWORD(v204) = HIDWORD(v204);
      v209 = v204 >> 25;
      v210 = v207 + (v176 ^ __ROR4__(v160, 23) ^ v195);
      v211 = v209 ^ __ROR4__(v195, 20);
      v212 = v202 + v1074 + (v180 ^ __ROR4__(v165, 13) ^ v205) + v209;
      v214 = __PAIR64__(v165, __ROR4__(v192, 17));
      v213 = v1078 ^ v1074 ^ v214;
      LODWORD(v214) = v165;
      v215 = v214 >> 13;
      v217 = __PAIR64__(v176, __ROR4__(v213, 17));
      v216 = ((v1089 >> 1) | (v1076 << 7)) ^ __ROR4__(v213, 9) ^ v217;
      LODWORD(v217) = v176;
      v218 = v217 >> 23;
      v219 = v210 + v211;
      HIDWORD(v217) = v212;
      LODWORD(v217) = v212;
      v220 = (v217 >> 15) ^ __ROR4__(v212, 23);
      v222 = __PAIR64__(v219, __ROR4__(v192, 17));
      v221 = v216 ^ v1078 ^ v1074 ^ v222;
      v223 = v220 ^ v212;
      LODWORD(v222) = v219;
      HIDWORD(v222) = (v222 >> 20) - 2002571463 + (v220 ^ v212);
      LODWORD(v222) = HIDWORD(v222);
      v224 = v222 >> 25;
      v225 = v215 + v19 + (v205 ^ __ROR4__(v180, 13) ^ v223) + v224;
      v226 = v208 + (v48 ^ v19) + (v195 ^ __ROR4__(v176, 23) ^ v219) + (v224 ^ __ROR4__(v219, 20));
      HIDWORD(v222) = v225;
      LODWORD(v222) = v225;
      v227 = v222 >> 15;
      v229 = __PAIR64__(v180, __ROR4__(v203, 17));
      v228 = v1081 ^ v19 ^ v229;
      LODWORD(v229) = v180;
      v230 = v229 >> 13;
      HIDWORD(v229) = v1073;
      LODWORD(v229) = v1073;
      v231 = (v229 >> 25) ^ __ROR4__(v228, 9);
      v233 = __PAIR64__(v195, __ROR4__(v228, 17));
      v232 = v231 ^ v233;
      LODWORD(v233) = v195;
      v234 = v233 >> 23;
      v235 = v221 ^ v162;
      v236 = __PAIR64__(v226, __ROR4__(v203, 17));
      v237 = v232 ^ v1081 ^ v19 ^ v236 ^ v178 ^ v48;
      v238 = v227 ^ __ROR4__(v225, 23) ^ v225;
      LODWORD(v236) = v226;
      v239 = v236 >> 20;
      HIDWORD(v236) = v205;
      LODWORD(v236) = v205;
      v240 = v236 >> 13;
      HIDWORD(v236) = v239 + 289824371 + v238;
      LODWORD(v236) = HIDWORD(v236);
      v241 = v236 >> 25;
      v242 = v218 + (v62 ^ v1077) + (v219 ^ __ROR4__(v195, 23) ^ v226);
      v243 = v230 + v1077 + (v223 ^ __ROR4__(v205, 13) ^ v238);
      v245 = __PAIR64__(v219, __ROR4__(v226, 20));
      v244 = v241 ^ v245;
      v246 = v243 + v241;
      LODWORD(v245) = v219;
      v247 = v245 >> 23;
      v249 = __PAIR64__(v48, __ROR4__(v1095, 17));
      v248 = v147 ^ v1076 ^ v1077 ^ v249;
      v250 = v242 + v244;
      LODWORD(v249) = v48;
      v251 = (v249 >> 25) ^ __ROR4__(v248, 9);
      v253 = __PAIR64__(v223, __ROR4__(v248, 17));
      v252 = v251 ^ v253;
      LODWORD(v253) = v223;
      v254 = v253 >> 13;
      HIDWORD(v253) = v246;
      LODWORD(v253) = v246;
      v255 = (v253 >> 15) ^ __ROR4__(v246, 23);
      v257 = __PAIR64__(v250, __ROR4__(v1095, 17));
      v256 = v252 ^ v147 ^ v1076 ^ v1077 ^ v257;
      v258 = v255 ^ v246;
      v259 = v234 + (v1078 ^ v1076);
      LODWORD(v257) = v250;
      HIDWORD(v257) = (v257 >> 20) + 579648742 + v258;
      LODWORD(v257) = HIDWORD(v257);
      v260 = v257 >> 25;
      v261 = v240 + v1076 + (v238 ^ __ROR4__(v223, 13) ^ v258) + v260;
      v262 = v259 + (v226 ^ __ROR4__(v219, 23) ^ v250) + (v260 ^ __ROR4__(v250, 20));
      v264 = __PAIR64__(v62, __ROR4__(v235, 17));
      v263 = v162 ^ v1076 ^ v264;
      LODWORD(v264) = v184;
      v265 = v264 >> 25;
      HIDWORD(v264) = v226;
      LODWORD(v264) = v226;
      v266 = v264 >> 23;
      v268 = __PAIR64__(v261, __ROR4__(v263, 17));
      v267 = v265 ^ __ROR4__(v263, 9) ^ v268;
      LODWORD(v268) = v261;
      v269 = v268 >> 15;
      HIDWORD(v268) = v238;
      LODWORD(v268) = v238;
      v270 = v268 >> 13;
      v271 = v256 ^ v1092;
      v272 = v269 ^ __ROR4__(v261, 23);
      v273 = __PAIR64__(v262, __ROR4__(v235, 17));
      v274 = v267 ^ v162 ^ v1076 ^ v273 ^ v192;
      v275 = v272 ^ v261;
      LODWORD(v273) = v262;
      HIDWORD(v273) = (v273 >> 20) - 1651869049 + (v272 ^ v261);
      LODWORD(v273) = HIDWORD(v273);
      v276 = v273 >> 25;
      v277 = v247 + (v1081 ^ v1073) + ((v262 | v250) & __ROR4__(v226, 23) | v262 & v250);
      v279 = __PAIR64__(v250, __ROR4__(v262, 20));
      v278 = v276 ^ v279;
      v280 = v254 + v1073 + (v258 & v275 | v270 & ~v275) + v276;
      LODWORD(v279) = v250;
      v281 = v279 >> 23;
      v282 = v277 + v278;
      v284 = __PAIR64__(v1078, __ROR4__(v237, 17));
      v283 = v178 ^ v48 ^ v1073 ^ v284;
      LODWORD(v284) = v1078;
      v285 = v284 >> 25;
      v287 = __PAIR64__(v258, __ROR4__(v283, 9));
      v286 = v285 ^ v287;
      LODWORD(v287) = v258;
      v288 = v287 >> 13;
      v290 = __PAIR64__(v280, __ROR4__(v283, 17));
      v289 = v286 ^ v290;
      LODWORD(v290) = v280;
      v291 = v289 ^ v178 ^ v48 ^ v1073;
      v292 = (v290 >> 15) ^ __ROR4__(v280, 23) ^ v280;
      v293 = __PAIR64__(v282, __ROR4__(v237, 17));
      v294 = v291 ^ v293 ^ v203;
      LODWORD(v293) = v282;
      v295 = (v293 >> 20) + 991229199 + v292;
      v296 = __PAIR64__(v295, __ROR4__(v250, 23));
      v297 = (v282 | v262) & v296 | v282 & v262;
      LODWORD(v296) = v295;
      v298 = v296 >> 25;
      v299 = v266 + (v147 ^ v1076 ^ v1075) + v297;
      v301 = __PAIR64__(v275, __ROR4__(v282, 20));
      v300 = v298 ^ v301;
      v302 = v270 + v1075 + (v275 & v292 | v288 & ~v292);
      LODWORD(v301) = v275;
      v303 = v301 >> 13;
      v304 = v299 + v300;
      v305 = v302 + v298;
      HIDWORD(v301) = v302 + v298;
      LODWORD(v301) = v302 + v298;
      v306 = v301 >> 15;
      v307 = v1092 ^ v1075 ^ __ROR4__(v271, 17);
      v309 = __PAIR64__(v1081, __ROR4__(v305, 23));
      v308 = v306 ^ v309;
      LODWORD(v309) = v1081;
      v310 = (v309 >> 25) ^ __ROR4__(v307, 9) ^ __ROR4__(v307, 17) ^ v1092 ^ v1075;
      v311 = v308 ^ v305;
      v313 = __PAIR64__(v304, __ROR4__(v271, 17));
      v312 = v310 ^ v313;
      LODWORD(v313) = v304;
      v314 = (v313 >> 20) + 1982458398;
      HIDWORD(v313) = v262;
      LODWORD(v313) = v262;
      v315 = v313 >> 23;
      v316 = v281 + (v162 ^ v184) + ((v304 | v282) & __ROR4__(v262, 23) | v304 & v282);
      HIDWORD(v313) = v314 + v311;
      LODWORD(v313) = v314 + v311;
      v317 = v313 >> 25;
      v318 = v288 + v184 + (v292 & v311 | v303 & ~v311) + v317;
      v319 = v316 + (v317 ^ __ROR4__(v304, 20));
      v320 = v192 ^ v184;
      v321 = v274;
      v1083 = v274;
      v323 = __PAIR64__(v147 ^ v1076, __ROR4__(v274, 17));
      v322 = v192 ^ v184 ^ v323;
      LODWORD(v323) = v147 ^ v1076;
      v324 = v323 >> 25;
      HIDWORD(v323) = v282;
      LODWORD(v323) = v282;
      v325 = v323 >> 23;
      v327 = __PAIR64__(v318, __ROR4__(v322, 17));
      v326 = v324 ^ __ROR4__(v322, 9) ^ v327;
      LODWORD(v327) = v318;
      v328 = v327 >> 15;
      HIDWORD(v327) = v292;
      LODWORD(v327) = v292;
      v329 = v327 >> 13;
      v330 = v312 ^ v1095;
      v331 = __PAIR64__(v319, __ROR4__(v321, 17));
      v332 = v326 ^ v320 ^ v331 ^ v235;
      v333 = v328 ^ __ROR4__(v318, 23) ^ v318;
      LODWORD(v331) = v319;
      HIDWORD(v331) = (v331 >> 20) - 330050500 + v333;
      LODWORD(v331) = HIDWORD(v331);
      v334 = v331 >> 25;
      v335 = v315 + (v179 ^ v1078) + ((v319 | v304) & __ROR4__(v282, 23) | v319 & v304);
      v337 = __PAIR64__(v304, __ROR4__(v319, 20));
      v336 = v334 ^ v337;
      v338 = v303 + v1078 + (v311 & v333 | v329 & ~v333) + v334;
      LODWORD(v337) = v304;
      v339 = v337 >> 23;
      v340 = v335 + v336;
      v1080 = v294;
      v342 = __PAIR64__(v162, __ROR4__(v294, 17));
      v341 = v203 ^ v1078 ^ v342;
      LODWORD(v342) = v162;
      v343 = v342 >> 25;
      v345 = __PAIR64__(v311, __ROR4__(v341, 9));
      v344 = v343 ^ v345;
      LODWORD(v345) = v311;
      v346 = v345 >> 13;
      v348 = __PAIR64__(v338, __ROR4__(v341, 17));
      v347 = v344 ^ v348;
      LODWORD(v348) = v338;
      v349 = (v348 >> 15) ^ __ROR4__(v338, 23) ^ v338;
      v350 = __PAIR64__(v340, __ROR4__(v294, 17));
      v351 = v347 ^ v203 ^ v1078 ^ v350 ^ v237;
      LODWORD(v350) = v340;
      v352 = (v350 >> 20) - 660100999 + v349;
      v353 = __PAIR64__(v352, __ROR4__(v304, 23));
      v354 = (v340 | v319) & v353 | v340 & v319;
      LODWORD(v353) = v352;
      v355 = v353 >> 25;
      v357 = __PAIR64__(v333, __ROR4__(v340, 20));
      v356 = v355 ^ v357;
      v358 = v329 + v1081 + (v333 & v349 | v346 & ~v349);
      LODWORD(v357) = v333;
      v359 = v357 >> 13;
      v360 = v325 + (v1092 ^ v1081) + v354 + v356;
      v361 = v358 + v355;
      HIDWORD(v357) = v358 + v355;
      LODWORD(v357) = v358 + v355;
      v362 = v357 >> 15;
      v363 = v1095 ^ v1081 ^ __ROR4__(v330, 17);
      v365 = __PAIR64__(v179, __ROR4__(v361, 23));
      v364 = v362 ^ v365;
      LODWORD(v365) = v179;
      v366 = (v365 >> 25) ^ __ROR4__(v363, 9) ^ __ROR4__(v363, 17) ^ v1095 ^ v1081;
      v367 = v364 ^ v361;
      v369 = __PAIR64__(v360, __ROR4__(v330, 17));
      v368 = v366 ^ v369;
      LODWORD(v369) = v360;
      v370 = (v369 >> 20) - 1320201997;
      HIDWORD(v369) = v319;
      LODWORD(v369) = v319;
      v371 = v369 >> 23;
      v372 = v339 + (v192 ^ v147 ^ v1076) + ((v360 | v340) & __ROR4__(v319, 23) | v360 & v340);
      HIDWORD(v369) = v370 + v367;
      LODWORD(v369) = v370 + v367;
      v373 = v369 >> 25;
      v374 = v346 + (v147 ^ v1076) + (v349 & v367 | v359 & ~v367) + v373;
      v375 = v372 + (v373 ^ __ROR4__(v360, 20));
      v376 = v235 ^ v147 ^ v1076;
      v378 = __PAIR64__(v1092, __ROR4__(v332, 17));
      v377 = v376 ^ v378;
      LODWORD(v378) = v1092;
      v379 = v378 >> 25;
      HIDWORD(v378) = v340;
      LODWORD(v378) = v340;
      v380 = v378 >> 23;
      v382 = __PAIR64__(v374, __ROR4__(v377, 17));
      v381 = v379 ^ __ROR4__(v377, 9) ^ v382;
      LODWORD(v382) = v374;
      v383 = v382 >> 15;
      HIDWORD(v382) = v349;
      LODWORD(v382) = v349;
      v384 = v382 >> 13;
      v385 = v368 ^ v271;
      v386 = v383 ^ __ROR4__(v374, 23);
      v387 = __PAIR64__(v375, __ROR4__(v332, 17));
      v388 = v381 ^ v376 ^ v387 ^ v1083;
      v389 = v386 ^ v374;
      LODWORD(v387) = v375;
      HIDWORD(v387) = (v387 >> 20) + 1654563303 + v389;
      LODWORD(v387) = HIDWORD(v387);
      v390 = v387 >> 25;
      v391 = v371 + (v203 ^ v162) + ((v375 | v360) & __ROR4__(v340, 23) | v375 & v360);
      v393 = __PAIR64__(v360, __ROR4__(v375, 20));
      v392 = v390 ^ v393;
      v394 = v359 + v162 + (v367 & v389 | v384 & ~v389) + v390;
      LODWORD(v393) = v360;
      v395 = v393 >> 23;
      v396 = v237 ^ v162;
      v397 = v391 + v392;
      v399 = __PAIR64__(v192, __ROR4__(v351, 17));
      v398 = v396 ^ v399;
      LODWORD(v399) = v192;
      v400 = v399 >> 25;
      v402 = __PAIR64__(v367, __ROR4__(v398, 9));
      v401 = v400 ^ v402;
      LODWORD(v402) = v367;
      v403 = v402 >> 13;
      v405 = __PAIR64__(v394, __ROR4__(v398, 17));
      v404 = v401 ^ v405;
      LODWORD(v405) = v394;
      v406 = v404 ^ v396;
      v407 = (v405 >> 15) ^ __ROR4__(v394, 23) ^ v394;
      v408 = __PAIR64__(v397, __ROR4__(v351, 17));
      v1090 = v406 ^ v408 ^ v1080;
      LODWORD(v408) = v397;
      v409 = (v408 >> 20) - 985840690 + v407;
      v410 = __PAIR64__(v409, __ROR4__(v360, 23));
      v411 = (v397 | v375) & v410 | v397 & v375;
      LODWORD(v410) = v409;
      v412 = v410 >> 25;
      v413 = v380 + (v1095 ^ v179) + v411;
      v415 = __PAIR64__(v389, __ROR4__(v397, 20));
      v414 = v412 ^ v415;
      v416 = v384 + v179 + (v389 & v407 | v403 & ~v407);
      LODWORD(v415) = v389;
      v417 = v415 >> 13;
      v418 = v413 + v414;
      v419 = v416 + v412;
      HIDWORD(v415) = v416 + v412;
      LODWORD(v415) = v416 + v412;
      v420 = v415 >> 15;
      v421 = v271 ^ v179;
      v422 = v421 ^ __ROR4__(v385, 17);
      v424 = __PAIR64__(v203, __ROR4__(v419, 23));
      v423 = v420 ^ v424;
      LODWORD(v424) = v203;
      v425 = (v424 >> 25) ^ __ROR4__(v422, 9) ^ __ROR4__(v422, 17) ^ v421;
      v426 = v423 ^ v419;
      v428 = __PAIR64__(v418, __ROR4__(v385, 17));
      v427 = v425 ^ v428;
      LODWORD(v428) = v418;
      v429 = (v428 >> 20) - 1971681379;
      HIDWORD(v428) = v375;
      LODWORD(v428) = v375;
      v430 = v428 >> 23;
      v431 = v395 + (v235 ^ v1092) + ((v418 | v397) & __ROR4__(v375, 23) | v418 & v397);
      HIDWORD(v428) = v429 + v426;
      LODWORD(v428) = v429 + v426;
      v432 = v428 >> 25;
      v433 = v403 + v1092 + (v407 & v426 | v417 & ~v426) + v432;
      v434 = v431 + (v432 ^ __ROR4__(v418, 20));
      v1082 = v388;
      v436 = __PAIR64__(v1095, __ROR4__(v388, 17));
      v435 = v1083 ^ v1092 ^ v436;
      LODWORD(v436) = v1095;
      v437 = v436 >> 25;
      HIDWORD(v436) = v397;
      LODWORD(v436) = v397;
      v438 = v436 >> 23;
      v440 = __PAIR64__(v433, __ROR4__(v435, 17));
      v439 = v437 ^ __ROR4__(v435, 9) ^ v440;
      LODWORD(v440) = v433;
      v441 = v440 >> 15;
      HIDWORD(v440) = v407;
      LODWORD(v440) = v407;
      v442 = v440 >> 13;
      v443 = v427 ^ v330;
      v444 = v441 ^ __ROR4__(v433, 23);
      v445 = __PAIR64__(v434, __ROR4__(v388, 17));
      v446 = v439 ^ v1083 ^ v1092 ^ v445 ^ v332;
      v447 = v444 ^ v433;
      LODWORD(v445) = v434;
      HIDWORD(v445) = (v445 >> 20) + 351604539 + v447;
      LODWORD(v445) = HIDWORD(v445);
      v448 = v445 >> 25;
      v449 = v430 + (v237 ^ v192) + ((v434 | v418) & __ROR4__(v397, 23) | v434 & v418);
      v451 = __PAIR64__(v418, __ROR4__(v434, 20));
      v450 = v448 ^ v451;
      v452 = v417 + v192 + (v426 & v447 | v442 & ~v447) + v448;
      LODWORD(v451) = v418;
      v453 = v451 >> 23;
      v454 = v1080 ^ v192;
      v455 = v449 + v450;
      v457 = __PAIR64__(v235, __ROR4__(v1090, 17));
      v456 = v454 ^ v457;
      LODWORD(v457) = v235;
      v458 = v457 >> 25;
      v460 = __PAIR64__(v426, __ROR4__(v456, 9));
      v459 = v458 ^ v460;
      LODWORD(v460) = v426;
      v461 = v460 >> 13;
      v463 = __PAIR64__(v452, __ROR4__(v456, 17));
      v462 = v459 ^ v463;
      LODWORD(v463) = v452;
      v464 = (v463 >> 15) ^ __ROR4__(v452, 23) ^ v452;
      v465 = __PAIR64__(v455, __ROR4__(v1090, 17));
      v1093 = v462 ^ v454 ^ v465 ^ v351;
      LODWORD(v465) = v455;
      v466 = (v465 >> 20) + 703209078 + v464;
      v467 = __PAIR64__(v466, __ROR4__(v418, 23));
      v468 = (v455 | v434) & v467 | v455 & v434;
      LODWORD(v467) = v466;
      v469 = v467 >> 25;
      v470 = v438 + (v271 ^ v203) + v468;
      v472 = __PAIR64__(v447, __ROR4__(v455, 20));
      v471 = v469 ^ v472;
      LODWORD(v472) = v447;
      v473 = v472 >> 13;
      v474 = v470 + v471;
      v475 = v442 + v203 + (v447 & v464 | v461 & ~v464) + v469;
      HIDWORD(v472) = v475;
      LODWORD(v472) = v475;
      v476 = v472 >> 15;
      v477 = v330 ^ v203;
      v478 = v477 ^ __ROR4__(v443, 17);
      v480 = __PAIR64__(v237, __ROR4__(v475, 23));
      v479 = v476 ^ v480;
      LODWORD(v480) = v237;
      v481 = (v480 >> 25) ^ __ROR4__(v478, 9) ^ __ROR4__(v478, 17) ^ v477;
      v482 = v479 ^ v475;
      v484 = __PAIR64__(v474, __ROR4__(v443, 17));
      v483 = v481 ^ v484;
      LODWORD(v484) = v474;
      v485 = (v484 >> 20) + 1406418156;
      HIDWORD(v484) = v434;
      LODWORD(v484) = v434;
      v486 = v484 >> 23;
      HIDWORD(v484) = v485 + v482;
      LODWORD(v484) = v485 + v482;
      v487 = v484 >> 25;
      v488 = v461 + v1095 + (v464 & v482 | v473 & ~v482) + v487;
      v489 = v453 + (v1083 ^ v1095) + ((v474 | v455) & __ROR4__(v434, 23) | v474 & v455) + (v487 ^ __ROR4__(v474, 20));
      v490 = v332 ^ v1095;
      v491 = v332;
      v492 = v446;
      v1079 = v446;
      v494 = __PAIR64__(v271, __ROR4__(v446, 17));
      v493 = v490 ^ v494;
      LODWORD(v494) = v271;
      v495 = v494 >> 25;
      HIDWORD(v494) = v455;
      LODWORD(v494) = v455;
      v496 = v494 >> 23;
      v498 = __PAIR64__(v488, __ROR4__(v493, 17));
      v497 = v495 ^ __ROR4__(v493, 9) ^ v498;
      LODWORD(v498) = v488;
      v499 = v498 >> 15;
      HIDWORD(v498) = v464;
      LODWORD(v498) = v464;
      v500 = v498 >> 13;
      v501 = v483 ^ v385;
      v502 = __PAIR64__(v489, __ROR4__(v492, 17));
      v503 = v497 ^ v490 ^ v502 ^ v1082;
      v504 = v499 ^ __ROR4__(v488, 23) ^ v488;
      LODWORD(v502) = v489;
      HIDWORD(v502) = (v502 >> 20) - 1482130984 + v504;
      LODWORD(v502) = HIDWORD(v502);
      v505 = v502 >> 25;
      v506 = v486 + (v1080 ^ v235) + ((v489 | v474) & __ROR4__(v455, 23) | v489 & v474);
      v508 = __PAIR64__(v474, __ROR4__(v489, 20));
      v507 = v505 ^ v508;
      v509 = v473 + v235 + (v482 & v504 | v500 & ~v504) + v505;
      LODWORD(v508) = v474;
      v510 = v508 >> 23;
      v511 = v351 ^ v235;
      v512 = v506 + v507;
      v514 = __PAIR64__(v1083, __ROR4__(v1093, 17));
      v513 = v511 ^ v514;
      LODWORD(v514) = v1083;
      v515 = v514 >> 25;
      v517 = __PAIR64__(v482, __ROR4__(v513, 9));
      v516 = v515 ^ v517;
      LODWORD(v517) = v482;
      v518 = v517 >> 13;
      v520 = __PAIR64__(v509, __ROR4__(v513, 17));
      v519 = v516 ^ v520;
      LODWORD(v520) = v509;
      v521 = v519 ^ v511;
      v522 = (v520 >> 15) ^ __ROR4__(v509, 23) ^ v509;
      v523 = __PAIR64__(v512, __ROR4__(v1093, 17));
      v524 = v521 ^ v523 ^ v1090;
      LODWORD(v523) = v512;
      v525 = (v523 >> 20) + 1330705329 + v522;
      v526 = __PAIR64__(v525, __ROR4__(v474, 23));
      v527 = (v512 | v489) & v526 | v512 & v489;
      LODWORD(v526) = v525;
      v528 = v526 >> 25;
      v530 = __PAIR64__(v504, __ROR4__(v512, 20));
      v529 = v528 ^ v530;
      LODWORD(v530) = v504;
      v531 = v530 >> 13;
      v532 = v496 + (v330 ^ v237) + v527 + v529;
      v533 = v500 + v237 + (v504 & v522 | v518 & ~v522) + v528;
      HIDWORD(v530) = v533;
      LODWORD(v530) = v533;
      v534 = v530 >> 15;
      v535 = v385 ^ v237 ^ __ROR4__(v501, 17);
      v537 = __PAIR64__(v1080, __ROR4__(v533, 23));
      v536 = v534 ^ v537;
      LODWORD(v537) = v1080;
      v538 = (v537 >> 25) ^ __ROR4__(v535, 9) ^ __ROR4__(v535, 17) ^ v385 ^ v237;
      v539 = v536 ^ v533;
      v541 = __PAIR64__(v532, __ROR4__(v501, 17));
      v540 = v538 ^ v541;
      LODWORD(v541) = v532;
      v542 = (v541 >> 20) - 1633556638;
      HIDWORD(v541) = v489;
      LODWORD(v541) = v489;
      v543 = v541 >> 23;
      v544 = v510 + (v491 ^ v271) + ((v532 | v512) & __ROR4__(v489, 23) | v532 & v512);
      HIDWORD(v541) = v542 + v539;
      LODWORD(v541) = v542 + v539;
      v545 = v541 >> 25;
      v546 = v518 + v271 + (v522 & v539 | v531 & ~v539) + v545;
      v547 = v544 + (v545 ^ __ROR4__(v532, 20));
      v548 = v1082 ^ v271;
      v550 = __PAIR64__(v330, __ROR4__(v503, 17));
      v549 = v1082 ^ v271 ^ v550;
      LODWORD(v550) = v330;
      v551 = v550 >> 25;
      HIDWORD(v550) = v512;
      LODWORD(v550) = v512;
      v552 = v550 >> 23;
      v554 = __PAIR64__(v546, __ROR4__(v549, 17));
      v553 = v551 ^ __ROR4__(v549, 9) ^ v554;
      LODWORD(v554) = v546;
      v555 = v554 >> 15;
      HIDWORD(v554) = v522;
      LODWORD(v554) = v522;
      v556 = v554 >> 13;
      v557 = v540 ^ v443;
      v558 = __PAIR64__(v547, __ROR4__(v503, 17));
      v1096 = v553 ^ v548 ^ v558 ^ v1079;
      v559 = v555 ^ __ROR4__(v546, 23) ^ v546;
      LODWORD(v558) = v547;
      HIDWORD(v558) = (v558 >> 20) + 1027854021 + v559;
      LODWORD(v558) = HIDWORD(v558);
      v560 = v558 >> 25;
      v561 = v543 + (v351 ^ v1083) + ((v547 | v532) & __ROR4__(v512, 23) | v547 & v532);
      v563 = __PAIR64__(v532, __ROR4__(v547, 20));
      v562 = v560 ^ v563;
      v564 = v531 + v1083 + (v539 & v559 | v556 & ~v559) + v560;
      LODWORD(v563) = v532;
      v565 = v563 >> 23;
      v566 = v561 + v562;
      v568 = __PAIR64__(v491, __ROR4__(v524, 17));
      v567 = v1090 ^ v1083 ^ v568;
      LODWORD(v568) = v491;
      v569 = v568 >> 25;
      v571 = __PAIR64__(v539, __ROR4__(v567, 9));
      v570 = v569 ^ v571;
      LODWORD(v571) = v539;
      v572 = v571 >> 13;
      v574 = __PAIR64__(v564, __ROR4__(v567, 17));
      v573 = v570 ^ v574;
      LODWORD(v574) = v564;
      v575 = (v574 >> 15) ^ __ROR4__(v564, 23) ^ v564;
      v576 = __PAIR64__(v566, __ROR4__(v524, 17));
      v577 = v573 ^ v1090 ^ v1083 ^ v576 ^ v1093;
      LODWORD(v576) = v566;
      v578 = (v576 >> 20) + 2055708042 + v575;
      v579 = __PAIR64__(v578, __ROR4__(v532, 23));
      v580 = (v566 | v547) & v579 | v566 & v547;
      LODWORD(v579) = v578;
      v581 = v579 >> 25;
      v583 = __PAIR64__(v559, __ROR4__(v566, 20));
      v582 = v581 ^ v583;
      LODWORD(v583) = v559;
      v584 = v583 >> 13;
      v585 = v552 + (v385 ^ v1080) + v580 + v582;
      v586 = v556 + v1080 + (v559 & v575 | v572 & ~v575) + v581;
      HIDWORD(v583) = v586;
      LODWORD(v583) = v586;
      v587 = v583 >> 15;
      v588 = v443 ^ v1080 ^ __ROR4__(v557, 17);
      v590 = __PAIR64__(v351, __ROR4__(v586, 23));
      v589 = v587 ^ v590;
      LODWORD(v590) = v351;
      v591 = v351;
      v592 = (v590 >> 25) ^ __ROR4__(v588, 9) ^ __ROR4__(v588, 17) ^ v443 ^ v1080;
      v593 = v589 ^ v586;
      v595 = __PAIR64__(v585, __ROR4__(v557, 17));
      v594 = v592 ^ v595;
      LODWORD(v595) = v585;
      v596 = (v595 >> 20) - 183551212;
      HIDWORD(v595) = v547;
      LODWORD(v595) = v547;
      v597 = v595 >> 23;
      HIDWORD(v595) = v596 + v593;
      LODWORD(v595) = v596 + v593;
      v598 = v595 >> 25;
      v599 = v598 ^ __ROR4__(v585, 20);
      v600 = v572 + v330 + (v575 & v593 | v584 & ~v593) + v598;
      v601 = v565 + (v1082 ^ v330) + ((v585 | v566) & __ROR4__(v547, 23) | v585 & v566) + v599;
      v602 = v1079 ^ v330;
      v604 = __PAIR64__(v385, __ROR4__(v1096, 17));
      v603 = v1079 ^ v330 ^ v604;
      LODWORD(v604) = v385;
      v605 = v604 >> 25;
      HIDWORD(v604) = v566;
      LODWORD(v604) = v566;
      v606 = v604 >> 23;
      v608 = __PAIR64__(v600, __ROR4__(v603, 17));
      v607 = v605 ^ __ROR4__(v603, 9) ^ v608;
      LODWORD(v608) = v600;
      v609 = v608 >> 15;
      HIDWORD(v608) = v575;
      LODWORD(v608) = v575;
      v610 = v608 >> 13;
      v611 = v594 ^ v501;
      v612 = __PAIR64__(v601, __ROR4__(v1096, 17));
      v613 = v607 ^ v602 ^ v612 ^ v503;
      v614 = v609 ^ __ROR4__(v600, 23) ^ v600;
      LODWORD(v612) = v601;
      HIDWORD(v612) = (v612 >> 20) - 367102423 + v614;
      LODWORD(v612) = HIDWORD(v612);
      v615 = v612 >> 25;
      v616 = v597 + (v1090 ^ v491) + ((v601 | v585) & __ROR4__(v566, 23) | v601 & v585);
      v618 = __PAIR64__(v585, __ROR4__(v601, 20));
      v617 = v615 ^ v618;
      v619 = v584 + v491 + (v593 & v614 | v610 & ~v614) + v615;
      LODWORD(v618) = v585;
      v620 = v618 >> 23;
      v621 = v616 + v617;
      v623 = __PAIR64__(v1082, __ROR4__(v577, 17));
      v622 = v1093 ^ v491 ^ v623;
      LODWORD(v623) = v1082;
      v624 = v623 >> 25;
      v626 = __PAIR64__(v593, __ROR4__(v622, 9));
      v625 = v624 ^ v626;
      LODWORD(v626) = v593;
      v627 = v626 >> 13;
      v629 = __PAIR64__(v619, __ROR4__(v622, 17));
      v628 = v625 ^ v629;
      LODWORD(v629) = v619;
      v630 = (v629 >> 15) ^ __ROR4__(v619, 23) ^ v619;
      v631 = __PAIR64__(v621, __ROR4__(v577, 17));
      v632 = v628 ^ v1093 ^ v491 ^ v631 ^ v524;
      LODWORD(v631) = v621;
      v633 = (v631 >> 20) - 734204845 + v630;
      v634 = __PAIR64__(v633, __ROR4__(v585, 23));
      v635 = (v621 | v601) & v634 | v621 & v601;
      LODWORD(v634) = v633;
      v636 = v634 >> 25;
      v638 = __PAIR64__(v614, __ROR4__(v621, 20));
      v637 = v636 ^ v638;
      LODWORD(v638) = v614;
      v639 = v638 >> 13;
      v640 = v606 + (v443 ^ v591) + v635 + v637;
      v641 = v610 + v591 + (v614 & v630 | v627 & ~v630) + v636;
      HIDWORD(v638) = v641;
      LODWORD(v638) = v641;
      v642 = v638 >> 15;
      v643 = v501 ^ v591 ^ __ROR4__(v611, 17);
      v645 = __PAIR64__(v1090, __ROR4__(v641, 23));
      v644 = v642 ^ v645;
      LODWORD(v645) = v1090;
      v646 = (v645 >> 25) ^ __ROR4__(v643, 9) ^ __ROR4__(v643, 17) ^ v501 ^ v591;
      v647 = v644 ^ v641;
      v649 = __PAIR64__(v640, __ROR4__(v611, 17));
      v648 = v646 ^ v649;
      LODWORD(v649) = v640;
      v650 = (v649 >> 20) - 1468409689;
      HIDWORD(v649) = v601;
      LODWORD(v649) = v601;
      v651 = v649 >> 23;
      v652 = v620 + (v1079 ^ v385) + ((v640 | v621) & __ROR4__(v601, 23) | v640 & v621);
      HIDWORD(v649) = v650 + v647;
      LODWORD(v649) = v650 + v647;
      v653 = v649 >> 25;
      v654 = v627 + v385 + (v630 & v647 | v639 & ~v647) + v653;
      v655 = v652 + (v653 ^ __ROR4__(v640, 20));
      v656 = v503 ^ v385;
      v658 = __PAIR64__(v443, __ROR4__(v613, 17));
      v657 = v656 ^ v658;
      LODWORD(v658) = v443;
      v659 = v658 >> 25;
      HIDWORD(v658) = v621;
      LODWORD(v658) = v621;
      v660 = v658 >> 23;
      v662 = __PAIR64__(v654, __ROR4__(v657, 17));
      v661 = v659 ^ __ROR4__(v657, 9) ^ v662;
      LODWORD(v662) = v654;
      v663 = v662 >> 15;
      HIDWORD(v662) = v630;
      LODWORD(v662) = v630;
      v664 = v662 >> 13;
      v665 = v648 ^ v557;
      v666 = v663 ^ __ROR4__(v654, 23);
      v667 = __PAIR64__(v655, __ROR4__(v613, 17));
      v668 = v661 ^ v656 ^ v667 ^ v1096;
      v669 = v666 ^ v654;
      LODWORD(v667) = v655;
      HIDWORD(v667) = (v667 >> 20) + 1358147919 + v669;
      LODWORD(v667) = HIDWORD(v667);
      v670 = v667 >> 25;
      v672 = __PAIR64__(v640, __ROR4__(v655, 20));
      v671 = v670 ^ v672;
      v673 = v639 + v1082 + (v647 & v669 | v664 & ~v669) + v670;
      LODWORD(v672) = v640;
      v674 = v672 >> 23;
      v675 = v651 + (v1093 ^ v1082) + ((v655 | v640) & __ROR4__(v621, 23) | v655 & v640) + v671;
      v677 = __PAIR64__(v1079, __ROR4__(v632, 17));
      v676 = v524 ^ v1082 ^ v677;
      LODWORD(v677) = v1079;
      v678 = v677 >> 25;
      v680 = __PAIR64__(v647, __ROR4__(v676, 9));
      v679 = v678 ^ v680;
      LODWORD(v680) = v647;
      v681 = v680 >> 13;
      v683 = __PAIR64__(v673, __ROR4__(v676, 17));
      v682 = v679 ^ v683;
      LODWORD(v683) = v673;
      v684 = v682 ^ v524 ^ v1082;
      v685 = (v683 >> 15) ^ __ROR4__(v673, 23) ^ v673;
      v686 = __PAIR64__(v675, __ROR4__(v632, 17));
      v687 = v684 ^ v686 ^ v577;
      LODWORD(v686) = v675;
      v688 = (v686 >> 20) - 1578671458 + v685;
      v689 = __PAIR64__(v688, __ROR4__(v640, 23));
      v690 = (v675 | v655) & v689 | v675 & v655;
      LODWORD(v689) = v688;
      v691 = v689 >> 25;
      v692 = v660 + (v501 ^ v1090) + v690;
      v694 = __PAIR64__(v669, __ROR4__(v675, 20));
      v693 = v691 ^ v694;
      LODWORD(v694) = v669;
      v695 = v694 >> 13;
      v696 = v692 + v693;
      v697 = v664 + v1090 + (v669 & v685 | v681 & ~v685) + v691;
      HIDWORD(v694) = v697;
      LODWORD(v694) = v697;
      v698 = v694 >> 15;
      v699 = v557 ^ v1090 ^ __ROR4__(v665, 17);
      v701 = __PAIR64__(v1093, __ROR4__(v697, 23));
      v700 = v698 ^ v701;
      LODWORD(v701) = v1093;
      v702 = (v701 >> 25) ^ __ROR4__(v699, 9) ^ __ROR4__(v699, 17) ^ v557 ^ v1090;
      v703 = v700 ^ v697;
      v705 = __PAIR64__(v696, __ROR4__(v665, 17));
      v704 = v702 ^ v705;
      LODWORD(v705) = v696;
      v706 = (v705 >> 20) + 1137624381;
      HIDWORD(v705) = v655;
      LODWORD(v705) = v655;
      v707 = v705 >> 23;
      HIDWORD(v705) = v706 + v703;
      LODWORD(v705) = v706 + v703;
      v708 = v705 >> 25;
      v709 = v681 + v443 + (v685 & v703 | v695 & ~v703) + v708;
      v710 = v674 + (v503 ^ v443) + ((v696 | v675) & __ROR4__(v655, 23) | v696 & v675) + (v708 ^ __ROR4__(v696, 20));
      v711 = v1096 ^ v443;
      v713 = __PAIR64__(v501, __ROR4__(v668, 17));
      v712 = v711 ^ v713;
      LODWORD(v713) = v501;
      v714 = v713 >> 25;
      HIDWORD(v713) = v675;
      LODWORD(v713) = v675;
      v715 = v713 >> 23;
      v717 = __PAIR64__(v709, __ROR4__(v712, 17));
      v716 = v714 ^ __ROR4__(v712, 9) ^ v717;
      LODWORD(v717) = v709;
      v718 = v717 >> 15;
      HIDWORD(v717) = v685;
      LODWORD(v717) = v685;
      v719 = v717 >> 13;
      v720 = v704 ^ v611;
      v721 = __PAIR64__(v710, __ROR4__(v668, 17));
      v722 = v716 ^ v711 ^ v721 ^ v613;
      v723 = v718 ^ __ROR4__(v709, 23) ^ v709;
      LODWORD(v721) = v710;
      HIDWORD(v721) = (v721 >> 20) - 2019718534 + v723;
      LODWORD(v721) = HIDWORD(v721);
      v724 = v721 >> 25;
      v725 = v707 + (v524 ^ v1079) + ((v710 | v696) & __ROR4__(v675, 23) | v710 & v696);
      v727 = __PAIR64__(v696, __ROR4__(v710, 20));
      v726 = v724 ^ v727;
      v728 = v695 + v1079 + (v703 & v723 | v719 & ~v723) + v724;
      LODWORD(v727) = v696;
      v729 = v727 >> 23;
      v730 = v725 + v726;
      v732 = __PAIR64__(v503, __ROR4__(v687, 17));
      v731 = v577 ^ v1079 ^ v732;
      LODWORD(v732) = v503;
      v733 = v732 >> 25;
      v735 = __PAIR64__(v703, __ROR4__(v731, 9));
      v734 = v733 ^ v735;
      LODWORD(v735) = v703;
      v736 = v735 >> 13;
      v738 = __PAIR64__(v728, __ROR4__(v731, 17));
      v737 = v734 ^ v738;
      LODWORD(v738) = v728;
      v739 = v737 ^ v577 ^ v1079;
      v740 = (v738 >> 15) ^ __ROR4__(v728, 23) ^ v728;
      v741 = __PAIR64__(v730, __ROR4__(v687, 17));
      v742 = v739 ^ v741 ^ v632;
      LODWORD(v741) = v730;
      v743 = (v741 >> 20) + 255530229 + v740;
      v744 = __PAIR64__(v743, __ROR4__(v696, 23));
      v745 = (v730 | v710) & v744 | v730 & v710;
      LODWORD(v744) = v743;
      v746 = v744 >> 25;
      v748 = __PAIR64__(v723, __ROR4__(v730, 20));
      v747 = v746 ^ v748;
      LODWORD(v748) = v723;
      v749 = v748 >> 13;
      v750 = v715 + (v557 ^ v1093) + v745 + v747;
      v751 = v719 + v1093 + (v723 & v740 | v736 & ~v740) + v746;
      HIDWORD(v748) = v751;
      LODWORD(v748) = v751;
      v752 = v748 >> 15;
      v753 = v611 ^ v1093 ^ __ROR4__(v720, 17);
      v755 = __PAIR64__(v524, __ROR4__(v751, 23));
      v754 = v752 ^ v755;
      LODWORD(v755) = v524;
      v756 = (v755 >> 25) ^ __ROR4__(v753, 9) ^ __ROR4__(v753, 17) ^ v611 ^ v1093;
      v757 = v754 ^ v751;
      v759 = __PAIR64__(v750, __ROR4__(v720, 17));
      v758 = v756 ^ v759;
      LODWORD(v759) = v750;
      v760 = (v759 >> 20) + 511060458;
      HIDWORD(v759) = v710;
      LODWORD(v759) = v710;
      v761 = v759 >> 23;
      HIDWORD(v759) = v760 + v757;
      LODWORD(v759) = v760 + v757;
      v762 = v759 >> 25;
      v763 = v736 + v501 + (v740 & v757 | v749 & ~v757) + v762;
      v764 = v729 + (v1096 ^ v501) + ((v750 | v730) & __ROR4__(v710, 23) | v750 & v730) + (v762 ^ __ROR4__(v750, 20));
      v765 = v613 ^ v501;
      v767 = __PAIR64__(v557, __ROR4__(v722, 17));
      v766 = v613 ^ v501 ^ v767;
      LODWORD(v767) = v557;
      v768 = v767 >> 25;
      HIDWORD(v767) = v730;
      LODWORD(v767) = v730;
      v769 = v767 >> 23;
      v771 = __PAIR64__(v763, __ROR4__(v766, 17));
      v770 = v768 ^ __ROR4__(v766, 9) ^ v771;
      LODWORD(v771) = v763;
      v772 = v771 >> 15;
      HIDWORD(v771) = v740;
      LODWORD(v771) = v740;
      v773 = v771 >> 13;
      v774 = v758 ^ v665;
      v775 = __PAIR64__(v764, __ROR4__(v722, 17));
      v776 = v770 ^ v765 ^ v775 ^ v668;
      v777 = v772 ^ __ROR4__(v763, 23) ^ v763;
      LODWORD(v775) = v764;
      HIDWORD(v775) = (v775 >> 20) + 1022120916 + v777;
      LODWORD(v775) = HIDWORD(v775);
      v778 = v775 >> 25;
      v779 = v761 + (v577 ^ v503) + ((v764 | v750) & __ROR4__(v730, 23) | v764 & v750);
      v781 = __PAIR64__(v750, __ROR4__(v764, 20));
      v780 = v778 ^ v781;
      v782 = v749 + v503 + (v757 & v777 | v773 & ~v777) + v778;
      LODWORD(v781) = v750;
      v783 = v781 >> 23;
      v784 = v632 ^ v503;
      v785 = v779 + v780;
      v787 = __PAIR64__(v1096, __ROR4__(v742, 17));
      v786 = v784 ^ v787;
      LODWORD(v787) = v1096;
      v788 = v787 >> 25;
      v790 = __PAIR64__(v757, __ROR4__(v786, 9));
      v789 = v788 ^ v790;
      LODWORD(v790) = v757;
      v791 = v790 >> 13;
      v793 = __PAIR64__(v782, __ROR4__(v786, 17));
      v792 = v789 ^ v793;
      LODWORD(v793) = v782;
      v794 = v792 ^ v784;
      v795 = (v793 >> 15) ^ __ROR4__(v782, 23) ^ v782;
      v796 = __PAIR64__(v785, __ROR4__(v742, 17));
      v797 = v794 ^ v796 ^ v687;
      LODWORD(v796) = v785;
      v798 = (v796 >> 20) + 2044241832 + v795;
      v799 = __PAIR64__(v798, __ROR4__(v750, 23));
      v800 = (v785 | v764) & v799 | v785 & v764;
      LODWORD(v799) = v798;
      v801 = v799 >> 25;
      v802 = v769 + (v611 ^ v524) + v800;
      v804 = __PAIR64__(v777, __ROR4__(v785, 20));
      v803 = v801 ^ v804;
      v805 = v773 + v524 + (v777 & v795 | v791 & ~v795);
      LODWORD(v804) = v777;
      v806 = v804 >> 13;
      v807 = v802 + v803;
      v808 = v805 + v801;
      HIDWORD(v804) = v805 + v801;
      LODWORD(v804) = v805 + v801;
      v809 = v804 >> 15;
      v810 = v665 ^ v524;
      v811 = v810 ^ __ROR4__(v774, 17);
      v813 = __PAIR64__(v577, __ROR4__(v808, 23));
      v812 = v809 ^ v813;
      LODWORD(v813) = v577;
      v814 = (v813 >> 25) ^ __ROR4__(v811, 9) ^ __ROR4__(v811, 17) ^ v810;
      v815 = v812 ^ v808;
      v817 = __PAIR64__(v807, __ROR4__(v774, 17));
      v816 = v814 ^ v817;
      LODWORD(v817) = v807;
      v818 = (v817 >> 20) - 206483632;
      HIDWORD(v817) = v764;
      LODWORD(v817) = v764;
      v819 = v817 >> 23;
      v820 = v783 + (v613 ^ v557) + ((v807 | v785) & __ROR4__(v764, 23) | v807 & v785);
      HIDWORD(v817) = v818 + v815;
      LODWORD(v817) = v818 + v815;
      v821 = v817 >> 25;
      v822 = v791 + v557 + (v795 & v815 | v806 & ~v815) + v821;
      v823 = v820 + (v821 ^ __ROR4__(v807, 20));
      v824 = v668 ^ v557;
      v826 = __PAIR64__(v611, __ROR4__(v776, 17));
      v825 = v668 ^ v557 ^ v826;
      LODWORD(v826) = v611;
      v827 = v826 >> 25;
      HIDWORD(v826) = v785;
      LODWORD(v826) = v785;
      v828 = v826 >> 23;
      v830 = __PAIR64__(v822, __ROR4__(v825, 17));
      v829 = v827 ^ __ROR4__(v825, 9) ^ v830;
      LODWORD(v830) = v822;
      v831 = v830 >> 15;
      HIDWORD(v830) = v795;
      LODWORD(v830) = v795;
      v832 = v830 >> 13;
      v833 = v816 ^ v720;
      v834 = __PAIR64__(v823, __ROR4__(v776, 17));
      v835 = v829 ^ v824 ^ v834 ^ v722;
      v836 = v831 ^ __ROR4__(v822, 23) ^ v822;
      LODWORD(v834) = v823;
      HIDWORD(v834) = (v834 >> 20) - 412967263 + v836;
      LODWORD(v834) = HIDWORD(v834);
      v837 = v834 >> 25;
      v838 = v819 + (v632 ^ v1096) + ((v823 | v807) & __ROR4__(v785, 23) | v823 & v807);
      v840 = __PAIR64__(v807, __ROR4__(v823, 20));
      v839 = v837 ^ v840;
      v841 = v806 + v1096 + (v815 & v836 | v832 & ~v836) + v837;
      LODWORD(v840) = v807;
      v842 = v840 >> 23;
      v843 = v838 + v839;
      v845 = __PAIR64__(v613, __ROR4__(v797, 17));
      v844 = v687 ^ v1096 ^ v845;
      LODWORD(v845) = v613;
      v846 = v845 >> 25;
      v848 = __PAIR64__(v815, __ROR4__(v844, 9));
      v847 = v846 ^ v848;
      LODWORD(v848) = v815;
      v849 = v848 >> 13;
      v851 = __PAIR64__(v841, __ROR4__(v844, 17));
      v850 = v847 ^ v851;
      LODWORD(v851) = v841;
      v852 = v851 >> 15;
      v853 = __PAIR64__(v843, __ROR4__(v841, 23));
      v854 = v852 ^ v853 ^ v841;
      LODWORD(v853) = v843;
      HIDWORD(v853) = (v853 >> 20) - 825934525 + v854;
      LODWORD(v853) = HIDWORD(v853);
      v855 = v853 >> 25;
      v856 = v828 + (v665 ^ v577) + ((v843 | v823) & __ROR4__(v807, 23) | v843 & v823);
      v858 = __PAIR64__(v823, __ROR4__(v843, 20));
      v857 = v855 ^ v858;
      v859 = v832 + v577 + (v836 & v854 | v849 & ~v854) + v855;
      LODWORD(v858) = v823;
      v860 = v858 >> 23;
      v861 = v720 ^ v577;
      v862 = v856 + v857;
      v864 = __PAIR64__(v632, __ROR4__(v833, 17));
      v863 = v720 ^ v577 ^ v864;
      LODWORD(v864) = v632;
      v865 = v864 >> 25;
      v867 = __PAIR64__(v836, __ROR4__(v863, 9));
      v866 = v865 ^ v867;
      LODWORD(v867) = v836;
      v868 = v867 >> 13;
      v870 = __PAIR64__(v859, __ROR4__(v863, 17));
      v869 = v866 ^ v870;
      LODWORD(v870) = v859;
      v871 = v870 >> 15;
      v872 = __PAIR64__(v862, __ROR4__(v859, 23));
      v873 = v869 ^ v861;
      v874 = v871 ^ v872 ^ v859;
      LODWORD(v872) = v862;
      HIDWORD(v872) = (v872 >> 20) - 1651869049 + v874;
      LODWORD(v872) = HIDWORD(v872);
      v875 = v872 >> 25;
      v876 = v842 + (v668 ^ v611) + ((v862 | v843) & __ROR4__(v823, 23) | v862 & v843);
      v878 = __PAIR64__(v843, __ROR4__(v862, 20));
      v877 = v875 ^ v878;
      v879 = v849 + v611 + (v854 & v874 | v868 & ~v874) + v875;
      LODWORD(v878) = v843;
      v880 = v878 >> 23;
      v881 = v722 ^ v611;
      v882 = v876 + v877;
      v884 = __PAIR64__(v665, __ROR4__(v835, 17));
      v883 = v881 ^ v884;
      LODWORD(v884) = v665;
      v885 = v884 >> 25;
      v887 = __PAIR64__(v854, __ROR4__(v883, 9));
      v886 = v885 ^ v887;
      LODWORD(v887) = v854;
      v888 = v887 >> 13;
      v890 = __PAIR64__(v879, __ROR4__(v883, 17));
      v889 = v886 ^ v890;
      LODWORD(v890) = v879;
      v891 = v890 >> 15;
      v892 = __PAIR64__(v882, __ROR4__(v879, 23));
      v893 = v889 ^ v881;
      v894 = v891 ^ v892 ^ v879;
      LODWORD(v892) = v882;
      HIDWORD(v892) = (v892 >> 20) + 991229199 + v894;
      LODWORD(v892) = HIDWORD(v892);
      v895 = v892 >> 25;
      v896 = v860 + (v687 ^ v613) + ((v882 | v862) & __ROR4__(v843, 23) | v882 & v862);
      v897 = v895 ^ __ROR4__(v882, 20);
      v898 = v868 + v613 + (v874 & v894 | v888 & ~v894) + v895;
      HIDWORD(v892) = v898;
      LODWORD(v892) = v898;
      v899 = v892 >> 15;
      HIDWORD(v892) = v874;
      LODWORD(v892) = v874;
      v900 = v892 >> 13;
      v901 = v896 + v897;
      v903 = __PAIR64__(v896 + v897, __ROR4__(v898, 23));
      v902 = v899 ^ v903;
      LODWORD(v903) = v901;
      v904 = v903 >> 20;
      HIDWORD(v903) = v862;
      LODWORD(v903) = v862;
      v905 = v903 >> 23;
      v906 = v902 ^ v898;
      HIDWORD(v903) = v904 + 1982458398 + v906;
      LODWORD(v903) = HIDWORD(v903);
      v907 = v903 >> 25;
      v908 = v880 + (v720 ^ v632) + ((v901 | v882) & __ROR4__(v862, 23) | v901 & v882);
      v910 = __PAIR64__(v882, __ROR4__(v901, 20));
      v909 = v907 ^ v910;
      v911 = v888 + v632 + (v894 & v906 | v900 & ~v906) + v907;
      LODWORD(v910) = v882;
      v912 = v910 >> 23;
      HIDWORD(v910) = v894;
      LODWORD(v910) = v894;
      v913 = v910 >> 13;
      v914 = v908 + v909;
      HIDWORD(v910) = v911;
      LODWORD(v910) = v911;
      v915 = v910 >> 15;
      v917 = __PAIR64__(v914, __ROR4__(v911, 23));
      v916 = v915 ^ v917;
      LODWORD(v917) = v914;
      v918 = v916 ^ v911;
      v919 = (v917 >> 20) - 330050500 + v918;
      v921 = __PAIR64__(v919, __ROR4__(v882, 23));
      v920 = (v914 | v901) & v921;
      LODWORD(v921) = v919;
      v922 = v921 >> 25;
      v923 = __PAIR64__(v906, __ROR4__(v914, 20));
      v924 = v905 + (v722 ^ v665) + (v920 | v914 & v901) + (v922 ^ v923);
      v925 = v900 + v665 + (v906 & v918 | v913 & ~v918) + v922;
      LODWORD(v923) = v906;
      v926 = v923 >> 13;
      HIDWORD(v923) = v925;
      LODWORD(v923) = v925;
      v927 = v923 >> 15;
      v928 = __PAIR64__(v924, __ROR4__(v925, 23));
      v929 = v927 ^ v928 ^ v925;
      LODWORD(v928) = v924;
      v930 = (v928 >> 20) - 660100999;
      HIDWORD(v928) = v901;
      LODWORD(v928) = v901;
      v931 = v928 >> 23;
      HIDWORD(v928) = v930 + v929;
      LODWORD(v928) = v930 + v929;
      v932 = v928 >> 25;
      v933 = __PAIR64__(v914, __ROR4__(v924, 20));
      v934 = v913 + v668 + (v918 & v929 | v926 & ~v929) + v932;
      v935 = v912 + (v742 ^ v668) + ((v924 | v914) & __ROR4__(v901, 23) | v924 & v914) + (v932 ^ v933);
      LODWORD(v933) = v914;
      v936 = v933 >> 23;
      HIDWORD(v933) = v934;
      LODWORD(v933) = v934;
      v937 = v933 >> 15;
      HIDWORD(v933) = v918;
      LODWORD(v933) = v918;
      v938 = v933 >> 13;
      v939 = v937 ^ __ROR4__(v934, 23) ^ v934;
      v940 = __PAIR64__(v935, __ROR4__(v914, 23));
      v941 = v931 + (v774 ^ v687) + ((v935 | v924) & v940 | v935 & v924);
      LODWORD(v940) = v935;
      HIDWORD(v940) = (v940 >> 20) - 1320201997 + v939;
      LODWORD(v940) = HIDWORD(v940);
      v942 = v940 >> 25;
      v943 = v926 + v687 + (v929 & v939 | v938 & ~v939);
      v945 = __PAIR64__(v929, __ROR4__(v935, 20));
      v944 = v942 ^ v945;
      LODWORD(v945) = v929;
      v946 = v945 >> 13;
      v947 = v941 + v944;
      HIDWORD(v945) = v943 + v942;
      LODWORD(v945) = v943 + v942;
      v948 = (v945 >> 15) ^ __ROR4__(v943 + v942, 23) ^ (v943 + v942);
      v949 = __PAIR64__(v947, __ROR4__(v924, 23));
      v950 = v936 + (v776 ^ v720) + ((v947 | v935) & v949 | v947 & v935);
      LODWORD(v949) = v947;
      HIDWORD(v949) = (v949 >> 20) + 1654563303 + v948;
      LODWORD(v949) = HIDWORD(v949);
      v951 = v949 >> 25;
      HIDWORD(v949) = v924;
      LODWORD(v949) = v924;
      v952 = v949 >> 23;
      v953 = v938 + v720 + (v939 & v948 | v946 & ~v948);
      v955 = __PAIR64__(v939, __ROR4__(v947, 20));
      v954 = v951 ^ v955;
      v956 = v953 + v951;
      LODWORD(v955) = v939;
      v957 = v955 >> 13;
      v958 = v950 + v954;
      HIDWORD(v955) = v956;
      LODWORD(v955) = v956;
      v959 = (v955 >> 15) ^ __ROR4__(v956, 23) ^ v956;
      v960 = __PAIR64__(v958, __ROR4__(v935, 23));
      v961 = v952 + (v797 ^ v722) + ((v958 | v947) & v960 | v958 & v947);
      LODWORD(v960) = v958;
      HIDWORD(v960) = (v960 >> 20) - 985840690 + v959;
      LODWORD(v960) = HIDWORD(v960);
      v962 = v960 >> 25;
      v963 = __PAIR64__(v948, __ROR4__(v958, 20));
      v964 = v961 + (v962 ^ v963);
      v965 = v946 + v722 + (v948 & v959 | v957 & ~v959) + v962;
      LODWORD(v963) = v948;
      v966 = v963 >> 13;
      HIDWORD(v963) = v965;
      LODWORD(v963) = v965;
      v967 = v963 >> 15;
      v968 = __PAIR64__(v964, __ROR4__(v965, 23));
      v969 = v967 ^ v968 ^ v965;
      LODWORD(v968) = v964;
      v970 = (v968 >> 20) - 1971681379;
      HIDWORD(v968) = v935;
      LODWORD(v968) = v935;
      v971 = v968 >> 23;
      HIDWORD(v968) = v970 + v969;
      LODWORD(v968) = v970 + v969;
      v972 = v968 >> 25;
      v973 = v971 + (v833 ^ v742) + ((v964 | v958) & __ROR4__(v947, 23) | v964 & v958) + (v972 ^ __ROR4__(v964, 20));
      v974 = v742 ^ v613;
      v975 = v850 ^ v687 ^ v1096 ^ __ROR4__(v797, 17) ^ v742;
      v976 = __PAIR64__(v947, __ROR4__(v833, 17));
      v977 = v873 ^ v976 ^ v774;
      v978 = v774 ^ v632;
      LODWORD(v976) = v947;
      v979 = v976 >> 23;
      v980 = v957 + v742 + (v959 & v969 | v966 & ~v969) + v972;
      HIDWORD(v976) = v980;
      LODWORD(v976) = v980;
      v981 = v976 >> 15;
      HIDWORD(v976) = v959;
      LODWORD(v976) = v959;
      v982 = v976 >> 13;
      v983 = v981 ^ __ROR4__(v980, 23) ^ v980;
      v984 = (v973 | v964) & __ROR4__(v958, 23) | v973 & v964;
      v985 = v979 + (v835 ^ v774);
      v987 = __PAIR64__(v973, __ROR4__(v835, 17));
      v986 = v893 ^ v987;
      v988 = v966 + v774 + (v969 & v983 | v982 & ~v983);
      LODWORD(v987) = v973;
      v989 = v987 >> 20;
      HIDWORD(v987) = v958;
      LODWORD(v987) = v958;
      v990 = v987 >> 23;
      v991 = v776 ^ v665;
      HIDWORD(v987) = v989 + 351604539 + v983;
      LODWORD(v987) = HIDWORD(v987);
      v992 = v987 >> 25;
      v993 = v985 + v984;
      v994 = v992 ^ __ROR4__(v973, 20);
      v995 = v988 + v992;
      HIDWORD(v987) = v995;
      LODWORD(v987) = v995;
      v996 = v987 >> 15;
      HIDWORD(v987) = v969;
      LODWORD(v987) = v969;
      v997 = v987 >> 13;
      v998 = v993 + v994;
      v999 = v996 ^ __ROR4__(v995, 23) ^ v995;
      v1000 = __PAIR64__(v998, __ROR4__(v964, 23));
      v1001 = v990 + (v975 ^ v776) + ((v998 | v973) & v1000 | v998 & v973);
      LODWORD(v1000) = v998;
      v1002 = v986 ^ v776;
      HIDWORD(v1000) = (v1000 >> 20) + 703209078 + v999;
      LODWORD(v1000) = HIDWORD(v1000);
      v1003 = v1000 >> 25;
      v1004 = __PAIR64__(v983, __ROR4__(v998, 20));
      v1005 = v1001 + (v1003 ^ v1004);
      v1006 = v982 + v776 + (v983 & v999 | v997 & ~v999) + v1003;
      LODWORD(v1004) = v983;
      v1007 = v1004 >> 13;
      HIDWORD(v1004) = v1006;
      LODWORD(v1004) = v1006;
      v1008 = v1004 >> 15;
      v1009 = __PAIR64__(v1005, __ROR4__(v1006, 23));
      v1010 = v1008 ^ v1009 ^ v1006;
      LODWORD(v1009) = v1005;
      v1011 = (v1009 >> 20) + 1406418156;
      HIDWORD(v1009) = v964;
      LODWORD(v1009) = v964;
      v1012 = v1009 >> 23;
      HIDWORD(v1009) = v1011 + v1010;
      LODWORD(v1009) = v1011 + v1010;
      v1013 = v1009 >> 25;
      v1014 = __PAIR64__(v973, __ROR4__(v1005, 20));
      v1015 = v1012 + (v977 ^ v797) + ((v1005 | v998) & __ROR4__(v973, 23) | v1005 & v998) + (v1013 ^ v1014);
      LODWORD(v1014) = v973;
      v1016 = v1014 >> 23;
      v1017 = v997 + v797 + (v999 & v1010 | v1007 & ~v1010) + v1013;
      HIDWORD(v1014) = v1017;
      LODWORD(v1014) = v1017;
      v1018 = v1014 >> 15;
      HIDWORD(v1014) = v999;
      LODWORD(v1014) = v999;
      v1019 = v1014 >> 13;
      v1020 = v1018 ^ __ROR4__(v1017, 23) ^ v1017;
      v1021 = __PAIR64__(v1015, __ROR4__(v998, 23));
      v1022 = v1016 + (v1002 ^ v833) + ((v1015 | v1005) & v1021 | v1015 & v1005);
      LODWORD(v1021) = v1015;
      v1023 = (v1021 >> 20) - 1482130984 + v1020;
      HIDWORD(v1021) = v668;
      LODWORD(v1021) = v668;
      v1024 = v1021 >> 25;
      HIDWORD(v1021) = v1023;
      LODWORD(v1021) = v1023;
      v1025 = v1021 >> 25;
      v1026 = v1022 + (v1025 ^ __ROR4__(v1015, 20));
      v1027 = v974 ^ __ROR4__(v975, 17);
      HIDWORD(v1021) = v1007 + v833 + (v1010 & v1020 | v1019 & ~v1020) + v1025;
      LODWORD(v1021) = HIDWORD(v1021);
      v1028 = (v1021 >> 15) ^ __ROR4__(HIDWORD(v1021), 23) ^ HIDWORD(v1021);
      v1029 = v1024 ^ __ROR4__(v1027, 9) ^ __ROR4__(v1027, 17);
      v1031 = __PAIR64__(v998, __ROR4__(v1005, 23));
      v1030 = (v1026 | v1015) & v1031;
      LODWORD(v1031) = v998;
      v1032 = v1031 >> 23;
      v1034 = __PAIR64__(v1010, __ROR4__(v975, 17));
      v1033 = v1029 ^ v974 ^ v1034;
      LODWORD(v1034) = v1010;
      v1035 = v1034 >> 13;
      HIDWORD(v1034) = v1026;
      LODWORD(v1034) = v1026;
      v1036 = v1032 + (v1033 ^ v797 ^ v835) + (v1030 | v1026 & v1015);
      HIDWORD(v1034) = (v1034 >> 20) + 1330705329 + v1028;
      LODWORD(v1034) = HIDWORD(v1034);
      v1037 = v1034 >> 25;
      v1038 = v1019 + v835 + (v1020 & v1028 | v1035 & ~v1028) + v1037;
      result = v1036 + (v1037 ^ __ROR4__(v1026, 20));
      HIDWORD(v1034) = v1038;
      LODWORD(v1034) = v1038;
      v1039 = (v1034 >> 15) ^ __ROR4__(v1038, 23) ^ v1038;
      v1041 = __PAIR64__(v687, __ROR4__(v977, 17));
      v1040 = v978 ^ v1041;
      LODWORD(v1041) = v687;
      v1042 = (v1041 >> 25) ^ __ROR4__(v1040, 9) ^ __ROR4__(v1040, 17);
      v1044 = __PAIR64__(v1005, __ROR4__(v977, 17));
      v1043 = v1042 ^ v978 ^ v1044;
      LODWORD(v1044) = v1005;
      v1045 = v1044 >> 23;
      v1046 = v1043 ^ v833 ^ v975;
      HIDWORD(v1044) = v1020;
      LODWORD(v1044) = v1020;
      v1047 = v1044 >> 13;
      v1048 = v1045 + v1046 + ((result | v1026) & __ROR4__(v1015, 23) | result & v1026);
      HIDWORD(v1044) = v720;
      LODWORD(v1044) = v720;
      v1049 = v991 ^ __ROR4__(v1002, 17);
      v1050 = (v1044 >> 25) ^ __ROR4__(v1049, 9);
      v1052 = __PAIR64__(result, __ROR4__(v1049, 17));
      v1051 = v1050 ^ v1052;
      LODWORD(v1052) = result;
      HIDWORD(v1052) = (v1052 >> 20) - 1633556638 + v1039;
      LODWORD(v1052) = HIDWORD(v1052);
      v1053 = v1052 >> 25;
      v1054 = v1035 + v975 + (v1028 & v1039 | v1047 & ~v1039) + v1053;
      v1055 = v1048 + (v1053 ^ __ROR4__(result, 20));
      v1057 = __PAIR64__(v1054, __ROR4__(v1002, 17));
      v1056 = v1051 ^ v991 ^ v1057;
      LODWORD(v1057) = v1054;
      v1058 = (v1057 >> 15) ^ __ROR4__(v1054, 23) ^ v1054;
      v1059 = __PAIR64__(v1015, __ROR4__(v1026, 23));
      v1060 = (v1055 | result) & v1059 | v1055 & result;
      LODWORD(v1059) = v1015;
      v1061 = (v1059 >> 23) + (v1056 ^ v835 ^ v977);
      HIDWORD(v1059) = v1028;
      LODWORD(v1059) = v1028;
      v1062 = v1061 + v1060;
      v1063 = v1039 & v1058 | (v1059 >> 13) & ~v1058;
      HIDWORD(v1059) = v1055;
      LODWORD(v1059) = v1055;
      HIDWORD(v1059) = (v1059 >> 20) + 1027854021 + v1058;
      LODWORD(v1059) = HIDWORD(v1059);
      v1064 = v1059 >> 25;
      v1065 = v1064 ^ __ROR4__(v1055, 20);
      v1066 = v1047 + v977 + v1063 + v1064;
      v4 = v1055 ^ v1099;
      v6 = v1098 ^ __ROR4__(result, 23);
      v1067 = v1058 ^ v1084;
      v1069 = __PAIR64__(v1066, __ROR4__(v1026, 23));
      v1068 = v1087 ^ v1069;
      LODWORD(v1069) = v1066;
      v3 = (v1062 + v1065) ^ v1100;
      v8 = (v1069 >> 15) ^ __ROR4__(v1066, 23) ^ v1097 ^ v1066;
      v1070 = v1085 ^ __ROR4__(v1039, 13);
      v1071 = v1086 ^ __ROR4__(v1028, 13);
      v1072[2] = v6;
      v1072[3] = v1068;
      v5 = v1068;
      *v1072 = v3;
      v1072[1] = v4;
      v1072[4] = v8;
      v1072[5] = v1067;
      v7 = v1067;
      v10 = v1070;
      v1072[6] = v1070;
      v1072[7] = v1071;
      v9 = v1071;
      a2 += 64;
      a3 = v1088 - 1;
    }
    while (v1088 != 1);
  }
  return result;
}

unint64_t SM3_Transform(unint64_t a1, uint64_t a2)
{
  return SM3_block_data_order(a1, a2, 1);
}

uint64_t SM3_Final(_DWORD *a1, unsigned int *a2)
{
  _OWORD *v4;
  uint64_t v5;
  uint64_t v6;
  unsigned int v7;

  v4 = a2 + 10;
  v5 = a2[26];
  *((_BYTE *)a2 + v5 + 40) = 0x80;
  v6 = v5 + 1;
  if (v5 >= 0x38)
  {
    bzero((char *)v4 + v6, 63 - v5);
    SM3_block_data_order((unint64_t)a2, (uint64_t)v4, 1);
    v6 = 0;
  }
  bzero((char *)v4 + v6, 56 - v6);
  v7 = bswap32(a2[8]);
  a2[24] = bswap32(a2[9]);
  a2[25] = v7;
  SM3_block_data_order((unint64_t)a2, (uint64_t)v4, 1);
  a2[26] = 0;
  *v4 = 0u;
  v4[1] = 0u;
  v4[2] = 0u;
  v4[3] = 0u;
  *a1 = bswap32(*a2);
  a1[1] = bswap32(a2[1]);
  a1[2] = bswap32(a2[2]);
  a1[3] = bswap32(a2[3]);
  a1[4] = bswap32(a2[4]);
  a1[5] = bswap32(a2[5]);
  a1[6] = bswap32(a2[6]);
  a1[7] = bswap32(a2[7]);
  return 1;
}

uint64_t SM3_Init(_OWORD *a1)
{
  *(_OWORD *)((char *)a1 + 92) = 0u;
  a1[4] = 0u;
  a1[5] = 0u;
  a1[2] = 0u;
  a1[3] = 0u;
  *a1 = xmmword_22D699AF0;
  a1[1] = xmmword_22D699B00;
  return 1;
}

uint64_t ec_wNAF_mul(EC_GROUP *a1, EC_POINT *a2, const BIGNUM *a3, unint64_t a4, _QWORD **a5, uint64_t a6, BN_CTX *a7)
{
  int v7;
  uint64_t v8;
  _QWORD **v17;
  unint64_t v18;
  const EC_POINT *v19;
  _QWORD *data;
  _QWORD *v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v24;
  void **v25;
  _QWORD *v26;
  _QWORD *v27;
  _QWORD *v28;
  uint64_t v29;
  size_t v30;
  unint64_t v31;
  uint64_t v32;
  const BIGNUM *v33;
  unsigned int v34;
  uint64_t v35;
  uint64_t v36;
  const BIGNUM *v37;
  unint64_t *v38;
  _BYTE *v39;
  int v40;
  int v41;
  EC_POINT *v42;
  void **v43;
  void *v44;
  EC_POINT **v45;
  uint64_t v46;
  _BYTE *v47;
  unint64_t v48;
  size_t v49;
  unint64_t v50;
  unint64_t v51;
  unint64_t v52;
  uint64_t v53;
  EC_POINT **v54;
  EC_POINT **v55;
  uint64_t v56;
  unint64_t v57;
  EC_POINT *v58;
  void *v60;
  void **v61;
  void *v62;
  EC_POINT *v63;
  EC_POINT **v64;
  EC_POINT *v65;
  unint64_t v66;
  const EC_POINT *v67;
  uint64_t v68;
  const EC_POINT **v69;
  unint64_t v70;
  unsigned int v71;
  int v72;
  uint64_t i;
  unsigned int v74;
  int v75;
  uint64_t v76;
  int v77;
  BOOL v78;
  char *v79;
  _QWORD *v80;
  void **v81;
  unint64_t v82;
  BOOL v83;
  void *v84;
  unint64_t v85;
  unint64_t v86;
  int v87;
  int v88;
  unint64_t v89;
  BN_CTX *v90;
  EC_POINT *v91;
  _QWORD **v92;
  EC_POINT *a;
  unint64_t v94;
  _QWORD *v95;
  uint64_t v96;
  char v97;
  char v98;
  size_t v99;
  uint64_t v100;
  _QWORD *v101;
  uint64_t v102;
  _BYTE *v103;
  void *v104;
  const EC_POINT *v105;
  _QWORD *v106;
  void **v107;
  EC_POINT **v108;
  EC_POINT *v109;
  size_t v110;

  if (*(_QWORD *)a1 != *(_QWORD *)a2)
  {
    v7 = 364;
LABEL_3:
    ERR_put_error(16, 4095, 101, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_mult.c", v7);
    return 0;
  }
  if (a3 || a4)
  {
    if (a4)
    {
      v17 = a5;
      v18 = a4;
      while (*(_QWORD *)a1 == **v17)
      {
        ++v17;
        if (!--v18)
          goto LABEL_12;
      }
      v7 = 372;
      goto LABEL_3;
    }
LABEL_12:
    if (a3)
    {
      v19 = EC_GROUP_get0_generator(a1);
      if (!v19)
      {
        ERR_put_error(16, 4095, 113, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_mult.c", 380);
        v42 = 0;
        v26 = 0;
        v43 = 0;
        v44 = 0;
        goto LABEL_50;
      }
      data = EC_EX_DATA_get_data(*((_QWORD **)a1 + 12), (uint64_t)ec_pre_comp_dup, (uint64_t)ec_pre_comp_free, (uint64_t)ec_pre_comp_clear_free);
      if (data && (v21 = data, data[2]) && !EC_POINT_cmp(a1, v19, *(const EC_POINT **)data[4], a7))
      {
        v101 = v21;
        v99 = v21[1];
        v51 = BN_num_bits(a3) / v99;
        v52 = v21[2];
        v53 = v21[3];
        if (v51 + 1 < v52)
          v22 = v51 + 1;
        else
          v22 = v21[2];
        if (v21[5] != v52 << (v53 - 1))
        {
          v40 = 68;
          v41 = 409;
LABEL_48:
          ERR_put_error(16, 4095, v40, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_mult.c", v41);
          v42 = 0;
          v26 = 0;
          v43 = 0;
          v44 = 0;
          v19 = 0;
LABEL_50:
          v45 = 0;
          v28 = 0;
          v8 = 0;
          goto LABEL_92;
        }
        v97 = 0;
        v23 = 0;
        v98 = 1;
        v96 = 1 << (v53 - 1);
      }
      else
      {
        v98 = 0;
        v99 = 0;
        v96 = 0;
        v101 = 0;
        v22 = 1;
        v97 = 1;
        v23 = 1;
      }
    }
    else
    {
      v19 = 0;
      v22 = 0;
      v96 = 0;
      v101 = 0;
      v97 = 0;
      v23 = 0;
      v98 = 1;
      v99 = 0;
    }
    v100 = v22;
    v24 = v22 + a4;
    v25 = (void **)reallocarray(0, v22 + a4 + 1, 8uLL);
    if (v25)
    {
      v91 = v19;
      v92 = a5;
      a = a2;
      v107 = v25;
      *v25 = 0;
      v26 = reallocarray(0, v24, 8uLL);
      v19 = (const EC_POINT *)reallocarray(0, v24, 8uLL);
      v94 = v24;
      v27 = reallocarray(0, v24, 8uLL);
      v28 = v27;
      if (v26 && v19 && v27)
      {
        v90 = a7;
        v105 = v19;
        v106 = v26;
        v95 = v27;
        v89 = v23 + a4;
        if (v23 + a4)
        {
          v29 = 0;
          v30 = 0;
          v31 = 0;
          v102 = -(uint64_t)(v23 + a4);
          v32 = 1;
          while (1)
          {
            v33 = a3;
            if (v32 - 1 < a4)
              v33 = *(const BIGNUM **)(a6 + v29 * 8);
            v34 = BN_num_bits(v33);
            if (v34 <= 0x13)
              v35 = 1;
            else
              v35 = 2;
            if (v34 > 0x45)
              v35 = 3;
            if (v34 > 0x12B)
              v35 = 4;
            if (v34 > 0x31F)
              v35 = 5;
            if (v34 <= 0x7CF)
              v36 = v35;
            else
              v36 = 6;
            v106[v29] = v36;
            v107[v29 + 1] = 0;
            v37 = a3;
            if (v32 - 1 < a4)
              v37 = *(const BIGNUM **)(a6 + v29 * 8);
            v38 = (unint64_t *)((char *)v105 + v29 * 8);
            v39 = compute_wNAF(v37, v36, (unint64_t *)((char *)v105 + v29 * 8));
            v107[v29] = v39;
            if (!v39)
              break;
            v30 += 1 << (v36 - 1);
            if (*v38 > v31)
              v31 = *v38;
            ++v29;
            ++v32;
            if (v102 + v32 == 1)
              goto LABEL_53;
          }
          v42 = 0;
          v44 = 0;
          v45 = 0;
          v8 = 0;
          v43 = v107;
          v28 = v95;
          goto LABEL_91;
        }
        v31 = 0;
        v30 = 0;
LABEL_53:
        if (!v100)
        {
          v44 = 0;
          v43 = v107;
          v28 = v95;
          goto LABEL_77;
        }
        v43 = v107;
        v28 = v95;
        if (v101)
        {
          v110 = 0;
          if ((v98 & 1) != 0)
          {
            v46 = v101[3];
            v106[a4] = v46;
            v47 = compute_wNAF(a3, v46, &v110);
            if (v47)
            {
              v103 = v47;
              v48 = v110;
              if (v110 > v31)
              {
                v49 = v99;
                if (v110 < v100 * v99)
                {
                  v50 = (v99 + v110 - 1) / v99;
                  if (v50 > v101[2])
                  {
                    ERR_put_error(16, 4095, 68, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_mult.c", 520);
LABEL_160:
                    v44 = v103;
                    goto LABEL_72;
                  }
                  v94 = v50 + a4;
                }
                if (v94 > a4)
                {
                  v79 = v103;
                  v80 = (_QWORD *)v101[4];
                  v81 = &v107[a4 + 1];
                  v82 = a4;
                  while (1)
                  {
                    if (v82 >= v94 - 1)
                    {
                      *((_QWORD *)v105 + v82) = v48;
                      v49 = v48;
                    }
                    else
                    {
                      *((_QWORD *)v105 + v82) = v49;
                      v83 = v48 >= v49;
                      v48 -= v49;
                      if (!v83)
                      {
                        v87 = 68;
                        v88 = 533;
                        goto LABEL_159;
                      }
                    }
                    *v81 = 0;
                    v84 = malloc_type_malloc(v49, 0xFE1E066CuLL);
                    *(v81 - 1) = v84;
                    if (!v84)
                    {
                      v87 = 65;
                      v88 = 549;
                      goto LABEL_159;
                    }
                    memcpy(v84, v79, *((_QWORD *)v105 + v82));
                    if (!*v80)
                      break;
                    v85 = *((_QWORD *)v105 + v82);
                    v95[v82] = v80;
                    v86 = v82 + 1;
                    if (v85 > v31)
                      v31 = v85;
                    v49 = v99;
                    v79 += v99;
                    v80 += v96;
                    ++v81;
                    ++v82;
                    if (v94 == v86)
                    {
                      v43 = v107;
                      v28 = v95;
                      goto LABEL_156;
                    }
                  }
                  v87 = 68;
                  v88 = 557;
LABEL_159:
                  ERR_put_error(16, 4095, v87, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_mult.c", v88);
                  v43 = v107;
                  v28 = v95;
                  goto LABEL_160;
                }
LABEL_156:
                v44 = v103;
LABEL_77:
                v54 = (EC_POINT **)reallocarray(0, v30 + 1, 8uLL);
                v45 = v54;
                if (!v54)
                {
                  ERR_put_error(16, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_mult.c", 575);
                  v42 = 0;
                  goto LABEL_90;
                }
                v104 = v44;
                v108 = &v54[v30];
                *v108 = 0;
                v55 = v54;
                if (v89)
                {
                  v56 = 0;
                  v55 = v54;
                  while (2)
                  {
                    v28[v56] = v55;
                    v57 = 1;
                    do
                    {
                      v58 = EC_POINT_new(a1);
                      *v55 = v58;
                      if (!v58)
                      {
                        v42 = 0;
                        v8 = 0;
                        v28 = v95;
                        goto LABEL_88;
                      }
                      ++v55;
                    }
                    while (!(v57++ >> (v106[v56] - 1)));
                    ++v56;
                    v28 = v95;
                    if (v56 != v89)
                      continue;
                    break;
                  }
                }
                if (v55 != v108)
                {
                  ERR_put_error(16, 4095, 68, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_mult.c", 592);
                  v42 = 0;
                  goto LABEL_86;
                }
                v42 = EC_POINT_new(a1);
                if (!v42)
                {
LABEL_86:
                  v8 = 0;
LABEL_88:
                  v26 = v106;
                  v44 = v104;
                  v19 = v105;
                  goto LABEL_92;
                }
                if (v89)
                {
                  v66 = 0;
                  do
                  {
                    v67 = v66 >= a4 ? v91 : (const EC_POINT *)v92[v66];
                    if (!EC_POINT_copy(*(EC_POINT **)v28[v66], v67))
                      goto LABEL_86;
                    if (v106[v66] >= 2uLL)
                    {
                      if (!EC_POINT_dbl(a1, v42, *(const EC_POINT **)v28[v66], v90))
                        goto LABEL_86;
                      if (v106[v66] != 1)
                      {
                        v68 = 0;
                        do
                        {
                          v69 = (const EC_POINT **)(v28[v66] + 8 * v68);
                          if (!EC_POINT_add(a1, v69[1], *v69, v42, v90))
                            goto LABEL_86;
                          v70 = (unint64_t)(v68 + 2) >> (LOBYTE(v106[v66]) - 1);
                          ++v68;
                        }
                        while (!v70);
                      }
                    }
                  }
                  while (++v66 != v89);
                }
                if (!EC_POINTs_make_affine(a1, v30, v45, v90))
                  goto LABEL_86;
                v109 = v42;
                v71 = v31 - 1;
                if ((int)v31 - 1 < 0)
                {
LABEL_141:
                  if (!EC_POINT_set_to_infinity(a1, a))
                  {
LABEL_166:
                    v8 = 0;
LABEL_167:
                    v26 = v106;
                    v44 = v104;
                    v19 = v105;
LABEL_168:
                    v42 = v109;
                    goto LABEL_92;
                  }
                }
                else
                {
                  v72 = 0;
                  v8 = 1;
                  do
                  {
                    if (!(_DWORD)v8 && !EC_POINT_dbl(a1, a, a, v90))
                    {
                      v8 = 0;
LABEL_163:
                      v26 = v106;
                      v44 = v104;
                      v19 = v105;
                      goto LABEL_168;
                    }
                    if (v94)
                    {
                      for (i = 0; v94 != i; ++i)
                      {
                        if (*((_QWORD *)v105 + i) > (unint64_t)v71)
                        {
                          v74 = *((unsigned __int8 *)v43[i] + v71);
                          if (*((_BYTE *)v43[i] + v71))
                          {
                            if ((v74 & 0x80u) == 0)
                              LOBYTE(v75) = *((_BYTE *)v43[i] + v71);
                            else
                              v75 = -(char)v74;
                            if (v72 != v74 >> 7)
                            {
                              if (!(_DWORD)v8 && !EC_POINT_invert(a1, a, v90))
                              {
                                v8 = 0;
                                v28 = v95;
                                goto LABEL_163;
                              }
                              v72 = v72 == 0;
                            }
                            v76 = v95[i];
                            if ((_DWORD)v8)
                            {
                              v77 = EC_POINT_copy(a, *(const EC_POINT **)(v76 + 8 * (v75 >> 1)));
                              v8 = 0;
                            }
                            else
                            {
                              v77 = EC_POINT_add(a1, a, a, *(const EC_POINT **)(v76 + 8 * (v75 >> 1)), v90);
                            }
                            v28 = v95;
                            if (!v77)
                              goto LABEL_163;
                          }
                        }
                      }
                    }
                    v78 = __OFSUB__(v71--, 1);
                  }
                  while (((v71 & 0x80000000) != 0) == v78);
                  if ((_DWORD)v8)
                    goto LABEL_141;
                  if (v72 && !EC_POINT_invert(a1, a, v90))
                    goto LABEL_166;
                }
                v8 = 1;
                goto LABEL_167;
              }
              v107[a4] = v47;
              v94 = a4 + 1;
              v107[a4 + 1] = 0;
              *((_QWORD *)v105 + a4) = v48;
              v95[a4] = v101[4];
LABEL_76:
              v44 = 0;
              goto LABEL_77;
            }
          }
          else
          {
            ERR_put_error(16, 4095, 68, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_mult.c", 470);
          }
          v44 = 0;
LABEL_72:
          v42 = 0;
          goto LABEL_73;
        }
        if ((v97 & 1) == 0)
        {
          ERR_put_error(16, 4095, 68, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_mult.c", 462);
          v42 = 0;
          v44 = 0;
LABEL_73:
          v45 = 0;
LABEL_90:
          v8 = 0;
LABEL_91:
          v26 = v106;
          v19 = v105;
          goto LABEL_92;
        }
        goto LABEL_76;
      }
      ERR_put_error(16, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_mult.c", 436);
      v42 = 0;
      v44 = 0;
      v45 = 0;
      v8 = 0;
      v43 = v107;
LABEL_92:
      EC_POINT_free(v42);
      free(v26);
      free(v19);
      free(v44);
      if (v43)
      {
        v60 = *v43;
        if (*v43)
        {
          v61 = v43 + 1;
          do
          {
            free(v60);
            v62 = *v61++;
            v60 = v62;
          }
          while (v62);
        }
        free(v43);
      }
      if (v45)
      {
        v63 = *v45;
        if (*v45)
        {
          v64 = v45 + 1;
          do
          {
            EC_POINT_free(v63);
            v65 = *v64++;
            v63 = v65;
          }
          while (v65);
        }
        free(v45);
      }
      free(v28);
      return v8;
    }
    v40 = 65;
    v41 = 425;
    goto LABEL_48;
  }
  return EC_POINT_set_to_infinity(a1, a2);
}

uint64_t ec_pre_comp_dup(uint64_t a1)
{
  CRYPTO_add_lock((int *)(a1 + 48), 1, 36, 0, 0);
  return a1;
}

void ec_pre_comp_free(uint64_t a1)
{
  EC_POINT **v2;
  EC_POINT *v3;
  EC_POINT **v4;
  EC_POINT *v5;

  if (a1 && CRYPTO_add_lock((int *)(a1 + 48), -1, 36, 0, 0) <= 0)
  {
    v2 = *(EC_POINT ***)(a1 + 32);
    if (v2)
    {
      v3 = *v2;
      if (*v2)
      {
        v4 = v2 + 1;
        do
        {
          EC_POINT_free(v3);
          v5 = *v4++;
          v3 = v5;
        }
        while (v5);
        v2 = *(EC_POINT ***)(a1 + 32);
      }
      free(v2);
    }
    free((void *)a1);
  }
}

void ec_pre_comp_clear_free(uint64_t a1)
{
  EC_POINT **v2;
  EC_POINT *v3;
  EC_POINT *v4;

  if (a1 && CRYPTO_add_lock((int *)(a1 + 48), -1, 36, 0, 0) <= 0)
  {
    v2 = *(EC_POINT ***)(a1 + 32);
    if (v2)
    {
      v3 = *v2;
      if (*v2)
      {
        do
        {
          EC_POINT_free(v3);
          explicit_bzero(v2, 8uLL);
          v4 = v2[1];
          ++v2;
          v3 = v4;
        }
        while (v4);
        v2 = *(EC_POINT ***)(a1 + 32);
      }
      free(v2);
    }
    freezero((void *)a1, 0x38uLL);
  }
}

_BYTE *compute_wNAF(const BIGNUM *a1, unsigned int a2, unint64_t *a3)
{
  _BYTE *v6;
  _BYTE *v7;
  unint64_t v8;
  int v9;
  int v10;
  int v11;
  _BOOL4 is_negative;
  _BOOL4 v13;
  unint64_t v14;
  uint64_t v15;
  int v16;
  int v17;
  int v18;
  signed int v19;
  int v20;
  unint64_t v21;

  if (BN_is_zero((uint64_t)a1))
  {
    v6 = malloc_type_malloc(1uLL, 0x6423EC1FuLL);
    v7 = v6;
    if (!v6)
    {
      v10 = 65;
      v11 = 207;
      goto LABEL_8;
    }
    *v6 = 0;
    v8 = 1;
LABEL_4:
    *a3 = v8;
    return v7;
  }
  if (a2 - 8 <= 0xFFFFFFF8)
  {
    v9 = 217;
LABEL_34:
    ERR_put_error(16, 4095, 68, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_mult.c", v9);
    v7 = 0;
    goto LABEL_35;
  }
  is_negative = BN_is_negative((uint64_t)a1);
  if (!a1->d || !a1->top)
  {
    v9 = 228;
    goto LABEL_34;
  }
  v13 = is_negative;
  v14 = BN_num_bits(a1);
  v7 = malloc_type_malloc(v14 + 1, 0x2232A5FEuLL);
  if (!v7)
  {
    v10 = 65;
    v11 = 237;
    goto LABEL_8;
  }
  v8 = 0;
  v15 = a2;
  v16 = 1 << a2;
  v17 = 2 << a2;
  v18 = (v17 - 1) & *(_DWORD *)a1->d;
  while (v18)
  {
    if ((v18 & 1) == 0)
      goto LABEL_28;
    v19 = v18 - v17;
    if (v15 + v8 + 1 >= v14)
      v19 = v18 & ((v17 - 1) >> 1);
    v20 = v19 & 1;
    if ((v18 & v16) == 0)
    {
      v20 = 1;
      v19 = v18;
    }
    if (v19 <= -v16 || v19 >= v16 || !v20)
    {
      v10 = 68;
      v11 = 271;
      goto LABEL_8;
    }
    v18 -= v19;
    if (v18 && v18 != v17 && v18 != v16)
    {
      v10 = 68;
      v11 = 282;
      goto LABEL_8;
    }
LABEL_29:
    if (v13)
      v19 = -v19;
    v21 = v8 + 1;
    v7[v8] = v19;
    v18 = (BN_is_bit_set(a1, v15 + v8 + 1) << v15) + (v18 >> 1);
    v8 = v21;
    if (v18 > v17)
    {
      v10 = 68;
      v11 = 292;
      goto LABEL_8;
    }
  }
  if (v15 + v8 + 1 < v14)
  {
    v18 = 0;
LABEL_28:
    v19 = 0;
    goto LABEL_29;
  }
  if (v8 <= v14 + 1)
    goto LABEL_4;
  v10 = 68;
  v11 = 298;
LABEL_8:
  ERR_put_error(16, 4095, v10, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_mult.c", v11);
LABEL_35:
  free(v7);
  return 0;
}

BOOL ec_wNAF_precompute_mult(uint64_t a1, BN_CTX *a2)
{
  uint64_t v4;
  char *v5;
  _QWORD *v6;
  const EC_POINT *v7;
  const EC_POINT *v8;
  BIGNUM *v9;
  int v10;
  int v11;
  _BOOL8 v12;
  EC_POINT *v13;
  EC_POINT *v14;
  unsigned int v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  size_t v19;
  BIGNUM *v20;
  uint64_t v21;
  EC_POINT *v22;
  EC_POINT *v23;
  int v24;
  int v25;
  EC_POINT *d;
  int *p_top;
  EC_POINT *v28;
  uint64_t v30;
  EC_POINT **v31;
  unint64_t v32;
  uint64_t v34;
  uint64_t v35;
  unint64_t v36;
  uint64_t v37;
  unint64_t v38;
  char v39;

  v4 = a1 + 96;
  EC_EX_DATA_free_data((void **)(a1 + 96), (uint64_t)ec_pre_comp_dup, (void (*)(void *))ec_pre_comp_free, ec_pre_comp_clear_free);
  if (!a1)
    return 0;
  v5 = (char *)malloc_type_malloc(0x38uLL, 0x10E00400304B0BDuLL);
  if (!v5)
  {
    ERR_put_error(16, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_mult.c", 110);
    return 0;
  }
  v6 = v5;
  *(_QWORD *)v5 = a1;
  *(_OWORD *)(v5 + 8) = xmmword_22D699B10;
  *((_QWORD *)v5 + 4) = 0;
  *((_QWORD *)v5 + 5) = 0;
  *((_QWORD *)v5 + 3) = 4;
  *((_DWORD *)v5 + 12) = 1;
  v7 = EC_GROUP_get0_generator((const EC_GROUP *)a1);
  if (!v7)
  {
    v10 = 113;
    v11 = 737;
    goto LABEL_11;
  }
  v8 = v7;
  BN_CTX_start(a2);
  v9 = BN_CTX_get(a2);
  if (!v9)
    goto LABEL_35;
  if (!EC_GROUP_get_order((const EC_GROUP *)a1, v9, a2))
  {
LABEL_12:
    v13 = 0;
    v14 = 0;
    v9 = 0;
    goto LABEL_37;
  }
  if (BN_is_zero((uint64_t)v9))
  {
    v10 = 114;
    v11 = 749;
LABEL_11:
    ERR_put_error(16, 4095, v10, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_mult.c", v11);
    goto LABEL_12;
  }
  v15 = BN_num_bits(v9);
  v16 = 5;
  if (v15 > 0x7CF)
    v16 = 6;
  if (v15 <= 0x31F)
    v17 = 4;
  else
    v17 = v16;
  v18 = (int)v15 + 7;
  v39 = v17 - 1;
  v19 = v18 >> 3 << (v17 - 1);
  v20 = (BIGNUM *)reallocarray(0, v19 + 1, 8uLL);
  v9 = v20;
  if (!v20)
  {
    v25 = 777;
LABEL_34:
    ERR_put_error(16, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_mult.c", v25);
LABEL_35:
    v13 = 0;
    goto LABEL_36;
  }
  v38 = v18 >> 3;
  *((_QWORD *)&v20->d + v19) = 0;
  if (v19)
  {
    v21 = 0;
    while (1)
    {
      v22 = EC_POINT_new((const EC_GROUP *)a1);
      *((_QWORD *)&v9->d + v21) = v22;
      if (!v22)
        break;
      if (v19 == ++v21)
        goto LABEL_23;
    }
    v25 = 784;
    goto LABEL_34;
  }
LABEL_23:
  v37 = v17;
  v13 = EC_POINT_new((const EC_GROUP *)a1);
  if (!v13 || (v23 = EC_POINT_new((const EC_GROUP *)a1)) == 0)
  {
    ERR_put_error(16, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_mult.c", 790);
LABEL_36:
    v14 = 0;
    goto LABEL_37;
  }
  v14 = v23;
  if (EC_POINT_copy(v23, v8))
  {
    if (v18 >= 8)
    {
      v30 = v18 >> 3;
      v36 = 0;
      if (v38 <= 1)
        v30 = 1;
      v35 = v30;
      v31 = (EC_POINT **)v9;
LABEL_48:
      if (EC_POINT_dbl((const EC_GROUP *)a1, v13, v14, a2) && EC_POINT_copy(*v31, v14))
      {
        ++v31;
        v32 = 2;
        while (EC_POINT_add((const EC_GROUP *)a1, *v31, v13, *(v31 - 1), a2))
        {
          ++v31;
          if (v32++ >> v39)
          {
            if (v36 < v38 - 1)
            {
              if (EC_POINT_dbl((const EC_GROUP *)a1, v14, v13, a2))
              {
                v34 = 6;
                while (EC_POINT_dbl((const EC_GROUP *)a1, v14, v14, a2))
                {
                  if (!--v34)
                    goto LABEL_58;
                }
              }
              break;
            }
LABEL_58:
            if (++v36 != v35)
              goto LABEL_48;
            goto LABEL_27;
          }
        }
      }
    }
    else
    {
LABEL_27:
      if (EC_POINTs_make_affine((const EC_GROUP *)a1, v19, (EC_POINT **)v9, a2))
      {
        *v6 = a1;
        v6[1] = 8;
        v6[2] = v38;
        v6[3] = v37;
        v6[4] = v9;
        v6[5] = v19;
        v24 = EC_EX_DATA_set_data(v4, (uint64_t)v6, (uint64_t)ec_pre_comp_dup, (uint64_t)ec_pre_comp_free, (uint64_t)ec_pre_comp_clear_free);
        v9 = 0;
        v12 = v24 != 0;
        if (v24)
          v6 = 0;
        goto LABEL_38;
      }
    }
  }
LABEL_37:
  v12 = 0;
LABEL_38:
  BN_CTX_end(a2);
  ec_pre_comp_free((uint64_t)v6);
  if (v9)
  {
    d = (EC_POINT *)v9->d;
    if (v9->d)
    {
      p_top = &v9->top;
      do
      {
        EC_POINT_free(d);
        v28 = *(EC_POINT **)p_top;
        p_top += 2;
        d = v28;
      }
      while (v28);
    }
    free(v9);
  }
  EC_POINT_free(v13);
  EC_POINT_free(v14);
  return v12;
}

BOOL ec_wNAF_have_precompute_mult(uint64_t a1)
{
  return EC_EX_DATA_get_data(*(_QWORD **)(a1 + 96), (uint64_t)ec_pre_comp_dup, (uint64_t)ec_pre_comp_free, (uint64_t)ec_pre_comp_clear_free) != 0;
}

X509_REVOKED *__cdecl d2i_X509_REVOKED(X509_REVOKED **a, const unsigned __int8 **in, uint64_t len)
{
  return (X509_REVOKED *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &X509_REVOKED_it);
}

int i2d_X509_REVOKED(X509_REVOKED *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &X509_REVOKED_it);
}

X509_REVOKED *X509_REVOKED_new(void)
{
  return (X509_REVOKED *)ASN1_item_new(&X509_REVOKED_it);
}

void X509_REVOKED_free(X509_REVOKED *a)
{
  ASN1_item_free((ASN1_VALUE *)a, &X509_REVOKED_it);
}

void *X509_REVOKED_dup(void *x)
{
  return ASN1_item_dup(&X509_REVOKED_it, x);
}

X509_CRL_INFO *__cdecl d2i_X509_CRL_INFO(X509_CRL_INFO **a, const unsigned __int8 **in, uint64_t len)
{
  return (X509_CRL_INFO *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &X509_CRL_INFO_it);
}

int i2d_X509_CRL_INFO(X509_CRL_INFO *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &X509_CRL_INFO_it);
}

X509_CRL_INFO *X509_CRL_INFO_new(void)
{
  return (X509_CRL_INFO *)ASN1_item_new(&X509_CRL_INFO_it);
}

void X509_CRL_INFO_free(X509_CRL_INFO *a)
{
  ASN1_item_free((ASN1_VALUE *)a, &X509_CRL_INFO_it);
}

X509_CRL *__cdecl d2i_X509_CRL(X509_CRL **a, const unsigned __int8 **in, uint64_t len)
{
  return (X509_CRL *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &X509_CRL_it);
}

int i2d_X509_CRL(X509_CRL *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &X509_CRL_it);
}

X509_CRL *X509_CRL_new(void)
{
  return (X509_CRL *)ASN1_item_new(&X509_CRL_it);
}

void X509_CRL_free(X509_CRL *a)
{
  ASN1_item_free((ASN1_VALUE *)a, &X509_CRL_it);
}

X509_CRL *__cdecl X509_CRL_dup(X509_CRL *crl)
{
  return (X509_CRL *)ASN1_item_dup(&X509_CRL_it, crl);
}

int X509_CRL_add0_revoked(X509_CRL *crl, X509_REVOKED *rev)
{
  X509_CRL_INFO *v3;
  STACK *revoked;
  int result;

  v3 = crl->crl;
  revoked = crl->crl->revoked;
  if ((revoked
     || (revoked = sk_new((int (__cdecl *)(const char *const *, const char *const *))X509_REVOKED_cmp),
         (v3->revoked = revoked) != 0))
    && sk_push(revoked, (char *)rev))
  {
    result = 1;
    v3->enc.modified = 1;
  }
  else
  {
    ERR_put_error(13, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/x_crl.c", 541);
    return 0;
  }
  return result;
}

uint64_t X509_REVOKED_cmp(ASN1_INTEGER ***a1, ASN1_INTEGER ***a2)
{
  return ASN1_INTEGER_cmp(**a1, **a2);
}

int X509_CRL_verify(X509_CRL *a, EVP_PKEY *r)
{
  unsigned __int8 *data;

  data = a[4].signature[1].data;
  if (data)
    return ((uint64_t (*)(void))data)();
  else
    return 0;
}

uint64_t X509_CRL_get0_by_serial(uint64_t a1)
{
  uint64_t (*v1)(void);

  v1 = *(uint64_t (**)(void))(*(_QWORD *)(a1 + 144) + 24);
  if (v1)
    return v1();
  else
    return 0;
}

uint64_t X509_CRL_get0_by_cert(uint64_t a1, uint64_t a2, X509 *x)
{
  uint64_t v4;
  uint64_t result;
  ASN1_INTEGER *serialNumber;
  X509_NAME *issuer_name;
  uint64_t (*v10)(uint64_t, uint64_t, ASN1_INTEGER *, X509_NAME *);

  v4 = *(_QWORD *)(a1 + 144);
  result = *(_QWORD *)(v4 + 24);
  if (result)
  {
    v10 = *(uint64_t (**)(uint64_t, uint64_t, ASN1_INTEGER *, X509_NAME *))(v4 + 24);
    serialNumber = X509_get_serialNumber(x);
    issuer_name = X509_get_issuer_name(x);
    return v10(a1, a2, serialNumber, issuer_name);
  }
  return result;
}

void *X509_CRL_set_default_method(void *result)
{
  void *v1;

  v1 = &int_crl_meth;
  if (result)
    v1 = result;
  default_crl_method = (uint64_t)v1;
  return result;
}

_QWORD *X509_CRL_METHOD_new(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD *result;

  result = malloc_type_calloc(1uLL, 0x28uLL, 0x1080040E6FF41AEuLL);
  if (result)
  {
    result[1] = a1;
    result[2] = a2;
    result[3] = a3;
    result[4] = a4;
    *(_DWORD *)result = 1;
  }
  return result;
}

void X509_CRL_METHOD_free(void *a1)
{
  if (a1)
  {
    if ((*(_BYTE *)a1 & 1) != 0)
      free(a1);
  }
}

uint64_t X509_CRL_set_meth_data(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 152) = a2;
  return result;
}

uint64_t X509_CRL_get_meth_data(uint64_t a1)
{
  return *(_QWORD *)(a1 + 152);
}

uint64_t X509_CRL_get_signature_nid(uint64_t a1)
{
  return OBJ_obj2nid(**(const ASN1_OBJECT ***)(a1 + 8));
}

uint64_t X509_CRL_get0_extensions(uint64_t a1)
{
  return *(_QWORD *)(*(_QWORD *)a1 + 48);
}

uint64_t X509_CRL_get_version(ASN1_INTEGER ***a1)
{
  return ASN1_INTEGER_get(**a1);
}

uint64_t X509_CRL_get0_lastUpdate(uint64_t a1)
{
  return *(_QWORD *)(*(_QWORD *)a1 + 24);
}

uint64_t X509_CRL_get_lastUpdate(uint64_t a1)
{
  return *(_QWORD *)(*(_QWORD *)a1 + 24);
}

uint64_t X509_CRL_get0_nextUpdate(uint64_t a1)
{
  return *(_QWORD *)(*(_QWORD *)a1 + 32);
}

uint64_t X509_CRL_get_nextUpdate(uint64_t a1)
{
  return *(_QWORD *)(*(_QWORD *)a1 + 32);
}

uint64_t X509_CRL_get_issuer(uint64_t a1)
{
  return *(_QWORD *)(*(_QWORD *)a1 + 16);
}

uint64_t X509_CRL_get_REVOKED(uint64_t a1)
{
  return *(_QWORD *)(*(_QWORD *)a1 + 40);
}

uint64_t X509_CRL_get0_signature(uint64_t result, _QWORD *a2, _QWORD *a3)
{
  if (a2)
    *a2 = *(_QWORD *)(result + 16);
  if (a3)
    *a3 = *(_QWORD *)(result + 8);
  return result;
}

uint64_t X509_CRL_get0_tbs_sigalg(uint64_t a1)
{
  return *(_QWORD *)(*(_QWORD *)a1 + 8);
}

uint64_t crl_inf_cb(int a1, uint64_t a2)
{
  STACK *v2;

  if (*(_QWORD *)a2)
  {
    if (a1 == 5)
    {
      v2 = *(STACK **)(*(_QWORD *)a2 + 40);
      if (v2)
        sk_set_cmp_func(v2, (int (__cdecl *)(const char *const *, const char *const *))X509_REVOKED_cmp);
    }
  }
  return 1;
}

BOOL crl_cb(int a1, _QWORD *a2)
{
  uint64_t v2;
  const EVP_MD *v3;
  int *ext_d2i;
  int v5;
  int v6;
  unsigned int v7;
  unsigned int (*v8)(_QWORD);
  _BOOL8 v9;
  AUTHORITY_KEYID *v10;
  ASN1_VALUE *v11;
  int v12;
  uint64_t v14;
  int v15;
  unsigned __int8 *v16;
  int v17;
  void *v18;
  const STACK *v19;
  int v20;
  char *v21;
  int v22;
  const STACK *v23;
  char *v24;
  int v25;
  char *v26;
  char *v27;
  char *v28;
  STACK *v29;
  ASN1_ENUMERATED *v30;
  ASN1_ENUMERATED *v31;
  const STACK *v32;
  char *v33;
  int v34;
  unsigned int (*v35)(uint64_t);
  int crit;

  v2 = *a2;
  if (a1 == 5)
  {
    v3 = EVP_sha512();
    X509_CRL_digest((const X509_CRL *)v2, v3, (unsigned __int8 *)(v2 + 72), 0);
    ext_d2i = (int *)X509_CRL_get_ext_d2i((X509_CRL *)v2, 770, 0, 0);
    *(_QWORD *)(v2 + 40) = ext_d2i;
    if (ext_d2i)
    {
      v5 = *(_DWORD *)(v2 + 48);
      v6 = v5 | 1;
      *(_DWORD *)(v2 + 48) = v5 | 1;
      if (ext_d2i[2] < 1)
      {
        v7 = 0;
      }
      else
      {
        v6 = v5 | 5;
        *(_DWORD *)(v2 + 48) = v5 | 5;
        v7 = 1;
      }
      if (ext_d2i[3] >= 1)
      {
        ++v7;
        v6 |= 8u;
        *(_DWORD *)(v2 + 48) = v6;
      }
      v12 = ext_d2i[7];
      if (v12 > 0)
      {
        v6 |= 0x10u;
        ++v7;
      }
      if (v7 > 1)
        v6 |= 2u;
      if (v12 > 0 || v7 >= 2)
        *(_DWORD *)(v2 + 48) = v6;
      if (ext_d2i[6] >= 1)
      {
        v6 |= 0x20u;
        *(_DWORD *)(v2 + 48) = v6;
      }
      v14 = *((_QWORD *)ext_d2i + 2);
      if (v14)
      {
        *(_DWORD *)(v2 + 48) = v6 | 0x40;
        v15 = *(_DWORD *)v14;
        if (*(int *)v14 <= 0)
        {
          v17 = *(_DWORD *)(v2 + 52);
        }
        else
        {
          v16 = *(unsigned __int8 **)(v14 + 8);
          v17 = *v16;
          *(_DWORD *)(v2 + 52) = v17;
          if (v15 != 1)
            LOWORD(v17) = v17 | (v16[1] << 8);
        }
        *(_DWORD *)(v2 + 52) = v17 & 0x807F;
      }
      DIST_POINT_set_dpname(*(_QWORD *)ext_d2i, *(X509_NAME **)(*(_QWORD *)v2 + 16));
    }
    *(_QWORD *)(v2 + 32) = X509_CRL_get_ext_d2i((X509_CRL *)v2, 90, 0, 0);
    *(_QWORD *)(v2 + 56) = X509_CRL_get_ext_d2i((X509_CRL *)v2, 88, 0, 0);
    v18 = X509_CRL_get_ext_d2i((X509_CRL *)v2, 140, 0, 0);
    *(_QWORD *)(v2 + 64) = v18;
    if (v18 && !*(_QWORD *)(v2 + 56))
      *(_DWORD *)(v2 + 28) |= 0x80u;
    v19 = *(const STACK **)(*(_QWORD *)v2 + 48);
    if (sk_num(v19) >= 1)
    {
      v20 = 0;
      while (1)
      {
        v21 = sk_value(v19, v20);
        v22 = OBJ_obj2nid(*(const ASN1_OBJECT **)v21);
        if (v22 == 857)
          *(_DWORD *)(v2 + 28) |= 0x1000u;
        if (*((int *)v21 + 2) >= 1)
          break;
        if (++v20 >= sk_num(v19))
          goto LABEL_52;
      }
      if (v22 != 90 && v22 != 140 && v22 != 770)
        *(_DWORD *)(v2 + 28) |= 0x200u;
    }
LABEL_52:
    crit = 0;
    v23 = *(const STACK **)(*(_QWORD *)v2 + 40);
    if (sk_num(v23) >= 1)
    {
      v24 = 0;
      v25 = 0;
      while (1)
      {
        v26 = sk_value(v23, v25);
        v27 = (char *)X509_REVOKED_get_ext_d2i((X509_REVOKED *)v26, 771, &crit, 0);
        v28 = v27;
        if (!v27 && crit != -1)
          break;
        if (v27)
        {
          v29 = *(STACK **)(v2 + 136);
          if (!v29)
          {
            v29 = sk_new_null();
            *(_QWORD *)(v2 + 136) = v29;
            if (!v29)
              return 0;
          }
          v24 = v28;
          if (!sk_push(v29, v28))
            return 0;
        }
        *((_QWORD *)v26 + 3) = v24;
        v30 = (ASN1_ENUMERATED *)X509_REVOKED_get_ext_d2i((X509_REVOKED *)v26, 141, &crit, 0);
        v31 = v30;
        if (!v30 && crit != -1)
          break;
        if (v30)
        {
          *((_DWORD *)v26 + 8) = ASN1_ENUMERATED_get(v30);
          ASN1_ENUMERATED_free(v31);
        }
        else
        {
          *((_DWORD *)v26 + 8) = -1;
        }
        v32 = (const STACK *)*((_QWORD *)v26 + 2);
        crit = 0;
        if (sk_num(v32) >= 1)
        {
          while (1)
          {
            v33 = sk_value(v32, crit);
            if (*((int *)v33 + 2) >= 1 && OBJ_obj2nid(*(const ASN1_OBJECT **)v33) != 771)
              break;
            v34 = ++crit;
            if (v34 >= sk_num(v32))
              goto LABEL_71;
          }
          *(_DWORD *)(v2 + 28) |= 0x200u;
        }
LABEL_71:
        if (++v25 >= sk_num(v23))
          goto LABEL_74;
      }
      *(_DWORD *)(v2 + 28) |= 0x80u;
    }
LABEL_74:
    v35 = *(unsigned int (**)(uint64_t))(*(_QWORD *)(v2 + 144) + 8);
    return !v35 || v35(v2);
  }
  if (a1 != 3)
  {
    if (a1 == 1)
    {
      *(_QWORD *)(v2 + 36) = 0;
      *(_QWORD *)(v2 + 28) = 0;
      *(_QWORD *)(v2 + 44) = 0;
      *(_DWORD *)(v2 + 52) = 32895;
      *(_QWORD *)(v2 + 144) = default_crl_method;
      *(_QWORD *)(v2 + 152) = 0;
      *(_QWORD *)(v2 + 136) = 0;
      *(_QWORD *)(v2 + 56) = 0;
      *(_QWORD *)(v2 + 64) = 0;
    }
    return 1;
  }
  v8 = *(unsigned int (**)(_QWORD))(*(_QWORD *)(v2 + 144) + 16);
  if (v8)
    v9 = v8(*a2) != 0;
  else
    v9 = 1;
  v10 = *(AUTHORITY_KEYID **)(v2 + 32);
  if (v10)
    AUTHORITY_KEYID_free(v10);
  v11 = *(ASN1_VALUE **)(v2 + 40);
  if (v11)
    ISSUING_DIST_POINT_free(v11);
  ASN1_INTEGER_free(*(ASN1_INTEGER **)(v2 + 56));
  ASN1_INTEGER_free(*(ASN1_INTEGER **)(v2 + 64));
  sk_pop_free(*(STACK **)(v2 + 136), (void (__cdecl *)(void *))GENERAL_NAMES_free);
  return v9;
}

uint64_t def_crl_lookup(uint64_t a1, char **a2, ASN1_INTEGER *a3, const X509_NAME *a4)
{
  int v8;
  int i;
  char *v10;
  const STACK *v11;
  const X509_NAME *v12;
  int v13;
  char *v14;
  char data[8];
  __int128 v17;
  __int128 v18;

  *(_QWORD *)data = a3;
  if (!sk_is_sorted(*(const STACK **)(*(_QWORD *)a1 + 40)))
  {
    CRYPTO_lock(9, 6, 0, 0);
    sk_sort(*(STACK **)(*(_QWORD *)a1 + 40));
    CRYPTO_lock(10, 6, 0, 0);
  }
  v17 = 0u;
  v18 = 0u;
  v8 = sk_find(*(STACK **)(*(_QWORD *)a1 + 40), data);
  if ((v8 & 0x80000000) == 0)
  {
    for (i = v8; i < sk_num(*(const STACK **)(*(_QWORD *)a1 + 40)); ++i)
    {
      v10 = sk_value(*(const STACK **)(*(_QWORD *)a1 + 40), i);
      if (ASN1_INTEGER_cmp(*(ASN1_INTEGER **)v10, a3))
        break;
      v11 = (const STACK *)*((_QWORD *)v10 + 3);
      if (v11)
      {
        v12 = a4;
        if (!a4)
          v12 = *(const X509_NAME **)(*(_QWORD *)a1 + 16);
        if (sk_num(v11) >= 1)
        {
          v13 = 0;
          while (1)
          {
            v14 = sk_value(*((const STACK **)v10 + 3), v13);
            if (*(_DWORD *)v14 == 4 && !X509_NAME_cmp(v12, *((const X509_NAME **)v14 + 1)))
              break;
            if (++v13 >= sk_num(*((const STACK **)v10 + 3)))
              goto LABEL_18;
          }
LABEL_20:
          if (a2)
            *a2 = v10;
          if (*((_DWORD *)v10 + 8) == 8)
            return 2;
          else
            return 1;
        }
      }
      else if (!a4 || !X509_NAME_cmp(a4, *(const X509_NAME **)(*(_QWORD *)a1 + 16)))
      {
        goto LABEL_20;
      }
LABEL_18:
      ;
    }
  }
  return 0;
}

uint64_t def_crl_verify(uint64_t a1, EVP_PKEY *pkey)
{
  return ASN1_item_verify(&X509_CRL_INFO_it, *(X509_ALGOR **)(a1 + 8), *(ASN1_BIT_STRING **)(a1 + 16), *(void **)a1, pkey);
}

int AES_wrap_key(AES_KEY *key, const unsigned __int8 *iv, unsigned __int8 *out, const unsigned __int8 *in, unsigned int inlen)
{
  int result;
  int v10;
  const unsigned __int8 *v11;
  unsigned int v12;
  uint64_t v13;
  unsigned __int8 outa[8];
  uint64_t v15;
  uint64_t v16;

  v16 = *MEMORY[0x24BDAC8D0];
  result = -1;
  if (inlen >= 0x10 && (inlen & 7) == 0)
  {
    memmove(out + 8, in, inlen);
    v10 = 0;
    v11 = (const unsigned __int8 *)&default_iv;
    if (iv)
      v11 = iv;
    *(_QWORD *)outa = *(_QWORD *)v11;
    v12 = 1;
    do
    {
      v13 = 0;
      do
      {
        v15 = *(_QWORD *)&out[v13 + 8];
        AES_encrypt(outa, outa, key);
        outa[7] ^= v12;
        if (v12 >= 0x100)
        {
          outa[6] ^= BYTE1(v12);
          outa[5] ^= BYTE2(v12);
          outa[4] ^= HIBYTE(v12);
        }
        *(_QWORD *)&out[v13 + 8] = v15;
        ++v12;
        v13 += 8;
      }
      while (v13 < inlen);
      ++v10;
    }
    while (v10 != 6);
    *(_QWORD *)out = *(_QWORD *)outa;
    return inlen + 8;
  }
  return result;
}

int AES_unwrap_key(AES_KEY *key, const unsigned __int8 *iv, unsigned __int8 *out, const unsigned __int8 *in, unsigned int inlen)
{
  size_t v5;
  unsigned int v9;
  int i;
  unsigned int v11;
  size_t v12;
  const unsigned __int8 *v13;
  unsigned __int8 outa[8];
  uint64_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x24BDAC8D0];
  LODWORD(v5) = -1;
  if (inlen >= 0x18 && (inlen & 7) == 0)
  {
    v5 = inlen - 8;
    v9 = 6 * (v5 >> 3);
    *(_QWORD *)outa = *(_QWORD *)in;
    memmove(out, in + 8, v5);
    for (i = 0; i != 6; ++i)
    {
      v11 = 0;
      v12 = v5 - 8;
      do
      {
        outa[7] ^= v9;
        if (v9 >= 0x100)
        {
          outa[6] ^= BYTE1(v9);
          outa[5] ^= BYTE2(v9);
          outa[4] ^= HIBYTE(v9);
        }
        v16 = *(_QWORD *)&out[v12];
        AES_decrypt(outa, outa, key);
        *(_QWORD *)&out[v12] = v16;
        v11 += 8;
        --v9;
        v12 -= 8;
      }
      while (v11 < v5);
    }
    v13 = (const unsigned __int8 *)&default_iv;
    if (iv)
      v13 = iv;
    if (*(_QWORD *)outa != *(_QWORD *)v13)
    {
      explicit_bzero(out, v5);
      LODWORD(v5) = 0;
    }
  }
  return v5;
}

void ERR_load_PKCS12_strings(void)
{
  if (!ERR_func_error_string(PKCS12_str_functs))
  {
    ERR_load_strings(0, (ERR_STRING_DATA *)&PKCS12_str_functs);
    ERR_load_strings(0, (ERR_STRING_DATA *)&PKCS12_str_reasons);
  }
}

void ECDSA_set_default_method(const ECDSA_METHOD *meth)
{
  default_ECDSA_method = (uint64_t)meth;
}

const ECDSA_METHOD *ECDSA_get_default_method(void)
{
  const ECDSA_METHOD *result;

  result = (const ECDSA_METHOD *)default_ECDSA_method;
  if (!default_ECDSA_method)
  {
    result = ECDSA_OpenSSL();
    default_ECDSA_method = (uint64_t)result;
  }
  return result;
}

int ECDSA_set_method(EC_KEY *eckey, const ECDSA_METHOD *meth)
{
  ENGINE **v3;
  ENGINE **v4;

  v3 = (ENGINE **)ecdsa_check(eckey);
  if (v3)
  {
    v4 = v3;
    ENGINE_finish(v3[1]);
    v4[1] = 0;
    v4[3] = meth;
    LODWORD(v3) = 1;
  }
  return (int)v3;
}

void *ecdsa_check(EC_KEY *a1)
{
  void *key_method_data;
  uint64_t v3;
  uint64_t v4;

  key_method_data = EC_KEY_get_key_method_data(a1, (void *(__cdecl *)(void *))ecdsa_data_dup, (void (__cdecl *)(void *))ecdsa_data_free, (void (__cdecl *)(void *))ecdsa_data_free);
  if (!key_method_data)
  {
    key_method_data = ecdsa_data_new();
    if (key_method_data)
    {
      EC_KEY_insert_key_method_data(a1, key_method_data, (void *(__cdecl *)(void *))ecdsa_data_dup, (void (__cdecl *)(void *))ecdsa_data_free, (void (__cdecl *)(void *))ecdsa_data_free);
      if (v3)
      {
        v4 = v3;
        ecdsa_data_free((uint64_t)key_method_data);
        return (void *)v4;
      }
    }
  }
  return key_method_data;
}

CRYPTO_EX_DATA *ecdsa_data_dup(CRYPTO_EX_DATA *result)
{
  if (result)
    return ecdsa_data_new();
  return result;
}

void ecdsa_data_free(uint64_t a1)
{
  ENGINE_finish(*(ENGINE **)(a1 + 8));
  CRYPTO_free_ex_data(12, (void *)a1, (CRYPTO_EX_DATA *)(a1 + 32));
  freezero((void *)a1, 0x28uLL);
}

CRYPTO_EX_DATA *ecdsa_data_new()
{
  CRYPTO_EX_DATA *v0;
  CRYPTO_EX_DATA *v1;
  const ECDSA_METHOD *v2;
  ENGINE *default_ECDSA;
  const ECDSA_METHOD *ECDSA;

  v0 = (CRYPTO_EX_DATA *)malloc_type_malloc(0x28uLL, 0x10E00407A09E776uLL);
  v1 = v0;
  if (!v0)
  {
    ERR_put_error(42, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ecdsa/ecs_lib.c", 116);
    return v1;
  }
  v0->sk = 0;
  v2 = (const ECDSA_METHOD *)default_ECDSA_method;
  if (!default_ECDSA_method)
  {
    v2 = ECDSA_OpenSSL();
    default_ECDSA_method = (uint64_t)v2;
  }
  *(_QWORD *)&v1[1].dummy = v2;
  *(_QWORD *)&v1->dummy = 0;
  default_ECDSA = ENGINE_get_default_ECDSA();
  *(_QWORD *)&v1->dummy = default_ECDSA;
  if (!default_ECDSA)
  {
    ECDSA = *(const ECDSA_METHOD **)&v1[1].dummy;
    goto LABEL_9;
  }
  ECDSA = ENGINE_get_ECDSA(default_ECDSA);
  *(_QWORD *)&v1[1].dummy = ECDSA;
  if (ECDSA)
  {
LABEL_9:
    LODWORD(v1[1].sk) = *((_DWORD *)ECDSA + 8);
    CRYPTO_new_ex_data(12, v1, v1 + 2);
    return v1;
  }
  ERR_put_error(42, 4095, 38, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ecdsa/ecs_lib.c", 130);
  ENGINE_finish(*(ENGINE **)&v1->dummy);
  free(v1);
  return 0;
}

int ECDSA_size(const EC_KEY *eckey)
{
  const EC_GROUP *v1;
  BIGNUM *v2;
  int v3;
  ECDSA_SIG v5;

  v5.r = 0;
  v5.s = 0;
  if (!eckey)
  {
    v2 = 0;
LABEL_7:
    LODWORD(v1) = 0;
    goto LABEL_9;
  }
  v1 = EC_KEY_get0_group(eckey);
  if (!v1)
  {
    v2 = 0;
    goto LABEL_9;
  }
  v2 = BN_new();
  if (!v2 || !EC_GROUP_get_order(v1, v2, 0))
    goto LABEL_7;
  v5.r = v2;
  v5.s = v2;
  v3 = i2d_ECDSA_SIG(&v5, 0);
  LODWORD(v1) = v3 & ~(v3 >> 31);
LABEL_9:
  BN_free(v2);
  return (int)v1;
}

int ECDSA_get_ex_new_index(uint64_t argl, void *argp, CRYPTO_EX_new *new_func, CRYPTO_EX_dup *dup_func, CRYPTO_EX_free *free_func)
{
  return CRYPTO_get_ex_new_index(12, argl, argp, new_func, dup_func, free_func);
}

int ECDSA_set_ex_data(EC_KEY *d, int idx, void *arg)
{
  CRYPTO_EX_DATA *v5;

  v5 = (CRYPTO_EX_DATA *)ecdsa_check(d);
  if (v5)
    LODWORD(v5) = CRYPTO_set_ex_data(v5 + 2, idx, arg);
  return (int)v5;
}

void *__cdecl ECDSA_get_ex_data(EC_KEY *d, int idx)
{
  void *result;

  result = ecdsa_check(d);
  if (result)
    return CRYPTO_get_ex_data((const CRYPTO_EX_DATA *)result + 2, idx);
  return result;
}

X509_SIG *__cdecl PKCS8_encrypt(int pbe_nid, const EVP_CIPHER *cipher, const char *pass, int passlen, unsigned __int8 *salt, int saltlen, int iter, PKCS8_PRIV_KEY_INFO *p8)
{
  X509_SIG *v16;
  X509_ALGOR *v17;
  int v18;
  int v19;
  X509_ALGOR *v20;
  ASN1_OCTET_STRING *v21;

  v16 = X509_SIG_new();
  if (!v16)
  {
    v18 = 65;
    v19 = 75;
LABEL_10:
    ERR_put_error(35, 4095, v18, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/pkcs12/p12_p8e.c", v19);
    X509_SIG_free(v16);
    return 0;
  }
  if (pbe_nid == -1)
    v17 = PKCS5_pbe2_set(cipher, iter, salt, saltlen);
  else
    v17 = PKCS5_pbe_set(pbe_nid, iter, salt, saltlen);
  v20 = v17;
  if (!v17)
  {
    v18 = 13;
    v19 = 84;
    goto LABEL_10;
  }
  X509_ALGOR_free(v16->algor);
  v16->algor = v20;
  ASN1_OCTET_STRING_free(v16->digest);
  v21 = PKCS12_item_i2d_encrypt(v20, &PKCS8_PRIV_KEY_INFO_it, pass, passlen, p8, 1);
  v16->digest = v21;
  if (!v21)
  {
    v18 = 103;
    v19 = 93;
    goto LABEL_10;
  }
  return v16;
}

ASN1_VALUE *v2i_NAME_CONSTRAINTS(X509V3_EXT_METHOD *a1, X509V3_CTX *a2, const STACK *a3)
{
  ASN1_VALUE *v6;
  int i;
  char *v8;
  uint64_t v9;
  uint64_t v10;
  STACK **v11;
  char *v12;
  GENERAL_NAME **v13;
  STACK *v14;
  CONF_VALUE cnf;

  memset(&cnf, 0, sizeof(cnf));
  v6 = ASN1_item_new(&NAME_CONSTRAINTS_it);
  if (v6)
  {
    if (sk_num(a3) >= 1)
    {
      for (i = 0; i < sk_num(a3); ++i)
      {
        v8 = sk_value(a3, i);
        v9 = *((_QWORD *)v8 + 1);
        if (!strncmp((const char *)v9, "permitted", 9uLL) && *(_BYTE *)(v9 + 9))
        {
          v10 = 10;
          v11 = (STACK **)v6;
        }
        else
        {
          if (strncmp((const char *)v9, "excluded", 8uLL) || !*(_BYTE *)(v9 + 8))
          {
            ERR_put_error(34, 4095, 143, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_ncons.c", 213);
            v13 = 0;
            goto LABEL_19;
          }
          v10 = 9;
          v11 = (STACK **)((char *)v6 + 8);
        }
        v12 = (char *)*((_QWORD *)v8 + 2);
        cnf.name = (char *)(v9 + v10);
        cnf.value = v12;
        v13 = (GENERAL_NAME **)ASN1_item_new(&GENERAL_SUBTREE_it);
        if (!v2i_GENERAL_NAME_ex(*v13, a1, a2, &cnf, 1))
          goto LABEL_19;
        v14 = *v11;
        if (!*v11)
        {
          v14 = sk_new_null();
          *v11 = v14;
          if (!v14)
            goto LABEL_17;
        }
        if (!sk_push(v14, (char *)v13))
          goto LABEL_17;
      }
    }
  }
  else
  {
    v13 = 0;
LABEL_17:
    ERR_put_error(34, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_ncons.c", 230);
LABEL_19:
    ASN1_item_free(v6, &NAME_CONSTRAINTS_it);
    ASN1_item_free((ASN1_VALUE *)v13, &GENERAL_SUBTREE_it);
    return 0;
  }
  return v6;
}

uint64_t i2r_NAME_CONSTRAINTS(uint64_t a1, const STACK **a2, BIO *a3, int a4)
{
  do_i2r_name_constraints(*a2, a3, a4, "Permitted");
  do_i2r_name_constraints(a2[1], a3, a4, "Excluded");
  return 1;
}

GENERAL_SUBTREE *GENERAL_SUBTREE_new(void)
{
  return (GENERAL_SUBTREE *)ASN1_item_new(&GENERAL_SUBTREE_it);
}

void GENERAL_SUBTREE_free(GENERAL_SUBTREE *a)
{
  ASN1_item_free((ASN1_VALUE *)a, &GENERAL_SUBTREE_it);
}

NAME_CONSTRAINTS *NAME_CONSTRAINTS_new(void)
{
  return (NAME_CONSTRAINTS *)ASN1_item_new(&NAME_CONSTRAINTS_it);
}

void NAME_CONSTRAINTS_free(NAME_CONSTRAINTS *a)
{
  ASN1_item_free((ASN1_VALUE *)a, &NAME_CONSTRAINTS_it);
}

uint64_t NAME_CONSTRAINTS_check(uint64_t a1, const STACK **a2)
{
  X509_NAME *subject_name;
  uint64_t result;
  int v6;
  int index_by_NID;
  X509_NAME_ENTRY *entry;
  int v9;
  char *v10;
  uint64_t v11;
  ASN1_STRING *data;

  subject_name = X509_get_subject_name((X509 *)a1);
  if (X509_NAME_entry_count(subject_name) >= 1)
  {
    data = (ASN1_STRING *)subject_name;
    v11 = 4;
    result = nc_match(&v11, a2);
    if ((_DWORD)result)
      return result;
    LODWORD(v11) = 1;
    v6 = -1;
    while (1)
    {
      index_by_NID = X509_NAME_get_index_by_NID(subject_name, 48, v6);
      if (index_by_NID == -1)
        break;
      v6 = index_by_NID;
      entry = X509_NAME_get_entry(subject_name, index_by_NID);
      data = X509_NAME_ENTRY_get_data(entry);
      if (data->type != 22)
        return 53;
      result = nc_match(&v11, a2);
      if ((_DWORD)result)
        return result;
    }
  }
  if (sk_num(*(const STACK **)(a1 + 112)) < 1)
    return 0;
  v9 = 0;
  while (1)
  {
    v10 = sk_value(*(const STACK **)(a1 + 112), v9);
    result = nc_match(v10, a2);
    if ((_DWORD)result)
      break;
    if (++v9 >= sk_num(*(const STACK **)(a1 + 112)))
      return 0;
  }
  return result;
}

uint64_t nc_match(_DWORD *a1, const STACK **a2)
{
  int v4;
  int v5;
  uint64_t *v6;
  uint64_t result;
  int v8;
  uint64_t *v9;

  if (sk_num(*a2) < 1)
  {
LABEL_14:
    if (sk_num(a2[1]) < 1)
    {
      return 0;
    }
    else
    {
      v8 = 0;
      while (1)
      {
        v9 = (uint64_t *)sk_value(a2[1], v8);
        if (*a1 == *(_DWORD *)*v9)
        {
          if (v9[1] || v9[2])
            return 49;
          result = nc_match_single((uint64_t)a1, *v9);
          if ((_DWORD)result != 47)
            break;
        }
        if (++v8 >= sk_num(a2[1]))
          return 0;
      }
      if (!(_DWORD)result)
        return 48;
    }
  }
  else
  {
    v4 = 0;
    v5 = 0;
    do
    {
      v6 = (uint64_t *)sk_value(*a2, v5);
      if (*a1 == *(_DWORD *)*v6)
      {
        if (v6[1] || v6[2])
          return 49;
        if (v4 != 2)
        {
          result = nc_match_single((uint64_t)a1, *v6);
          if ((_DWORD)result)
          {
            v4 = 1;
            if ((_DWORD)result != 47)
              return result;
          }
          else
          {
            v4 = 2;
          }
        }
      }
      ++v5;
    }
    while (v5 < sk_num(*a2));
    if (v4 != 1)
      goto LABEL_14;
    return 47;
  }
  return result;
}

uint64_t do_i2r_name_constraints(const STACK *a1, BIO *a2, int a3, const char *a4)
{
  uint64_t result;
  int v9;
  int v10;
  char *v11;
  GENERAL_NAME *v12;
  char *ptr;
  unsigned __int8 *v14;
  int v15;
  int i;
  const char *v17;

  if (sk_num(a1) >= 1)
    BIO_printf(a2, "%*s%s:\n", a3, "", a4);
  result = sk_num(a1);
  if ((int)result >= 1)
  {
    v9 = 0;
    v10 = a3 + 2;
    do
    {
      v11 = sk_value(a1, v9);
      BIO_printf(a2, "%*s", v10, "");
      v12 = *(GENERAL_NAME **)v11;
      if (**(_DWORD **)v11 == 7)
      {
        ptr = v12->d.ptr;
        v14 = (unsigned __int8 *)*((_QWORD *)ptr + 1);
        v15 = *(_DWORD *)ptr;
        BIO_puts(a2, "IP:");
        if (v15 == 8)
        {
          BIO_printf(a2, "%d.%d.%d.%d/%d.%d.%d.%d", *v14);
        }
        else
        {
          if (v15 == 32)
          {
            for (i = 0; ; ++i)
            {
              BIO_printf(a2, "%X", __rev16(*(unsigned __int16 *)v14));
              v17 = "/";
              if (i != 7)
              {
                if (i == 15)
                  goto LABEL_16;
                v17 = ":";
              }
              BIO_puts(a2, v17);
              v14 += 2;
            }
          }
          BIO_printf(a2, "IP Address:<invalid>");
        }
      }
      else
      {
        GENERAL_NAME_print(a2, v12);
      }
LABEL_16:
      BIO_puts(a2, "\n");
      ++v9;
      result = sk_num(a1);
    }
    while (v9 < (int)result);
  }
  return result;
}

uint64_t nc_match_single(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;
  char *v6;
  char *v7;
  char *v8;
  char *v9;
  char *v10;
  size_t v11;
  int *v12;
  const char *v13;
  uint64_t v14;
  const char *v15;
  int v16;
  BOOL v17;
  int v18;
  uint64_t v19;
  uint64_t v20;
  size_t v21;
  int v22;
  int *v23;
  const char *v24;
  char *v25;
  char *v26;
  char *v27;
  int v28;
  size_t v29;

  v2 = 51;
  switch(*(_DWORD *)a2)
  {
    case 1:
      v4 = *(_QWORD *)(a1 + 8);
      v5 = *(_QWORD *)(a2 + 8);
      v6 = *(char **)(v5 + 8);
      v7 = *(char **)(v4 + 8);
      v8 = strchr(v6, 64);
      v9 = strchr(v7, 64);
      if (!v9)
        return 53;
      v10 = v9;
      if (v8)
      {
        v11 = v8 - v6;
        if (v8 == v6 || v11 == v9 - v7 && !strncmp(v6, v7, v11))
        {
          v6 = v8 + 1;
LABEL_38:
          v15 = v10 + 1;
          v13 = v6;
          goto LABEL_39;
        }
        return 47;
      }
      if (*v6 != 46)
        goto LABEL_38;
      if (*(_DWORD *)v4 <= *(_DWORD *)v5 || strcasecmp(v6, &v7[*(_DWORD *)v4 - *(_DWORD *)v5]))
        return 47;
      return 0;
    case 2:
      v12 = *(int **)(a2 + 8);
      v13 = (const char *)*((_QWORD *)v12 + 1);
      if (!*v13)
        return 0;
      v14 = *(_QWORD *)(a1 + 8);
      v15 = *(const char **)(v14 + 8);
      LODWORD(v14) = *(_DWORD *)v14;
      v16 = *v12;
      v17 = __OFSUB__((_DWORD)v14, v16);
      v18 = v14 - v16;
      if (!((v18 < 0) ^ v17 | (v18 == 0)))
      {
        v15 += v18;
        if (*v13 != 46 && *(v15 - 1) != 46)
          return 47;
      }
LABEL_39:
      if (!strcasecmp(v13, v15))
        return 0;
      else
        return 47;
    case 4:
      v19 = *(_QWORD *)(a1 + 8);
      v20 = *(_QWORD *)(a2 + 8);
      if (*(_DWORD *)(v19 + 8) && i2d_X509_NAME((X509_NAME *)v19, 0) < 0
        || *(_DWORD *)(v20 + 8) && i2d_X509_NAME((X509_NAME *)v20, 0) < 0)
      {
        return 17;
      }
      v21 = *(int *)(v20 + 32);
      v2 = 47;
      if ((int)v21 > *(_DWORD *)(v19 + 32))
        return v2;
      v22 = memcmp(*(const void **)(v20 + 24), *(const void **)(v19 + 24), v21);
      goto LABEL_19;
    case 6:
      v23 = *(int **)(a2 + 8);
      v24 = (const char *)*((_QWORD *)v23 + 1);
      v25 = strchr(*(char **)(*(_QWORD *)(a1 + 8) + 8), 58);
      if (!v25 || v25[1] != 47 || v25[2] != 47)
        return 53;
      v26 = v25 + 3;
      v27 = strchr(v25 + 3, 58);
      if (v27 || (v27 = strchr(v26, 47)) != 0)
      {
        v28 = (_DWORD)v27 - (_DWORD)v26;
        if (v28)
          goto LABEL_28;
        return 53;
      }
      v28 = strlen(v26);
      if (!v28)
        return 53;
LABEL_28:
      v29 = *v23;
      if (*v24 == 46)
      {
        if ((int)v29 < v28 && !strncasecmp(&v26[v28 - v29], v24, v29))
          return 0;
        else
          return 47;
      }
      else
      {
        v2 = 47;
        if ((_DWORD)v29 == v28)
        {
          v22 = strncasecmp(v26, v24, v28);
LABEL_19:
          if (v22)
            return 47;
          else
            return 0;
        }
      }
      return v2;
    default:
      return v2;
  }
}

void ENGINE_unregister_DH(ENGINE *e)
{
  engine_table_unregister(&dh_table, e);
}

int ENGINE_register_DH(ENGINE *e)
{
  if (*((_QWORD *)e + 4))
    return engine_table_register(&dh_table, (uint64_t)engine_unregister_all_DH, (char *)e, &dummy_nid_0, 1, 0);
  else
    return 1;
}

void engine_unregister_all_DH()
{
  engine_table_cleanup(&dh_table);
}

void ENGINE_register_all_DH(void)
{
  ENGINE *first;
  ENGINE *next;

  first = ENGINE_get_first();
  if (first)
  {
    next = first;
    do
    {
      if (*((_QWORD *)next + 4))
        engine_table_register(&dh_table, (uint64_t)engine_unregister_all_DH, (char *)next, &dummy_nid_0, 1, 0);
      next = ENGINE_get_next(next);
    }
    while (next);
  }
}

int ENGINE_set_default_DH(ENGINE *e)
{
  if (*((_QWORD *)e + 4))
    return engine_table_register(&dh_table, (uint64_t)engine_unregister_all_DH, (char *)e, &dummy_nid_0, 1, 1);
  else
    return 1;
}

ENGINE *ENGINE_get_default_DH(void)
{
  return (ENGINE *)engine_table_select(&dh_table, 1);
}

const DH_METHOD *__cdecl ENGINE_get_DH(const ENGINE *e)
{
  return (const DH_METHOD *)*((_QWORD *)e + 4);
}

int ENGINE_set_DH(ENGINE *e, const DH_METHOD *dh_meth)
{
  *((_QWORD *)e + 4) = dh_meth;
  return 1;
}

void ERR_load_crypto_strings(void)
{
  pthread_once(&ERR_load_crypto_strings_loaded, ERR_load_crypto_strings_internal);
}

void ERR_load_crypto_strings_internal()
{
  ERR_load_ERR_strings_internal();
  ERR_load_ASN1_strings();
  ERR_load_BIO_strings();
  ERR_load_BN_strings();
  ERR_load_BUF_strings();
  ERR_load_CMS_strings();
  ERR_load_CONF_strings();
  ERR_load_CRYPTO_strings();
  ERR_load_DH_strings();
  ERR_load_DSA_strings();
  ERR_load_DSO_strings();
  ERR_load_ECDH_strings();
  ERR_load_ECDSA_strings();
  ERR_load_EC_strings();
  ERR_load_ENGINE_strings();
  ERR_load_EVP_strings();
  ERR_load_GOST_strings();
  ERR_load_KDF_strings();
  ERR_load_OBJ_strings();
  ERR_load_OCSP_strings();
  ERR_load_PEM_strings();
  ERR_load_PKCS12_strings();
  ERR_load_PKCS7_strings();
  ERR_load_RAND_strings();
  ERR_load_RSA_strings();
  ERR_load_TS_strings();
  ERR_load_UI_strings();
  ERR_load_X509V3_strings();
  ERR_load_X509_strings();
}

EC_GROUP *__cdecl EC_GROUP_new(const EC_METHOD *a1)
{
  char *v2;
  char *v3;
  int v4;
  int v5;

  if (!a1)
  {
    v4 = 108;
    v5 = 82;
LABEL_8:
    ERR_put_error(16, 4095, v4, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_lib.c", v5);
    return 0;
  }
  if (!*((_QWORD *)a1 + 1))
  {
    v4 = 66;
    v5 = 86;
    goto LABEL_8;
  }
  v2 = (char *)malloc_type_malloc(0xE8uLL, 0x10F0040D5F8239AuLL);
  v3 = v2;
  if (!v2)
  {
    ERR_put_error(16, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_lib.c", 91);
    return (EC_GROUP *)v3;
  }
  *((_QWORD *)v2 + 12) = 0;
  *(_QWORD *)v2 = a1;
  *((_QWORD *)v2 + 1) = 0;
  BN_init((BIGNUM *)(v2 + 16));
  BN_init((BIGNUM *)(v3 + 40));
  *((_QWORD *)v3 + 8) = 0x100000000;
  *((_DWORD *)v3 + 18) = 4;
  *((_QWORD *)v3 + 10) = 0;
  *((_QWORD *)v3 + 11) = 0;
  if (!(*((unsigned int (**)(char *))a1 + 1))(v3))
  {
    free(v3);
    return 0;
  }
  return (EC_GROUP *)v3;
}

void EC_GROUP_free(EC_GROUP *a1)
{
  void (*v2)(EC_GROUP *);
  void *v3;
  void (*v4)(_QWORD);

  if (a1)
  {
    v2 = *(void (**)(EC_GROUP *))(*(_QWORD *)a1 + 16);
    if (v2)
      v2(a1);
    EC_EX_DATA_clear_free_all_data((void **)a1 + 12);
    v3 = (void *)*((_QWORD *)a1 + 1);
    if (v3)
    {
      v4 = *(void (**)(_QWORD))(*(_QWORD *)v3 + 80);
      if (v4)
        v4(*((_QWORD *)a1 + 1));
      freezero(v3, 0x58uLL);
    }
    BN_free((BIGNUM *)((char *)a1 + 16));
    BN_free((BIGNUM *)((char *)a1 + 40));
    freezero(*((void **)a1 + 10), *((_QWORD *)a1 + 11));
    freezero(a1, 0xE8uLL);
  }
}

void EC_EX_DATA_clear_free_all_data(void **a1)
{
  void (**v2)(_QWORD);
  void (*v3)(_QWORD);

  if (a1)
  {
    v2 = (void (**)(_QWORD))*a1;
    if (*a1)
    {
      do
      {
        v3 = *v2;
        v2[4](v2[1]);
        free(v2);
        v2 = (void (**)(_QWORD))v3;
      }
      while (v3);
    }
    *a1 = 0;
  }
}

void EC_POINT_free(EC_POINT *a1)
{
  void (*v2)(EC_POINT *);

  if (a1)
  {
    v2 = *(void (**)(EC_POINT *))(*(_QWORD *)a1 + 80);
    if (v2)
      v2(a1);
    freezero(a1, 0x58uLL);
  }
}

int EC_GROUP_copy(EC_GROUP *a1, const EC_GROUP *a2)
{
  int v3;
  int v4;
  EC_POINT *v5;
  _QWORD *v7;
  const EC_POINT *v8;
  void *v9;
  EC_POINT **v10;
  uint64_t v11;

  if (!*(_QWORD *)(*(_QWORD *)a1 + 24))
  {
    v3 = 66;
    v4 = 148;
    goto LABEL_5;
  }
  if (*(_QWORD *)a1 != *(_QWORD *)a2)
  {
    v3 = 101;
    v4 = 152;
LABEL_5:
    ERR_put_error(16, 4095, v3, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_lib.c", v4);
    LODWORD(v5) = 0;
    return (int)v5;
  }
  if (a1 == a2)
  {
    LODWORD(v5) = 1;
  }
  else
  {
    EC_EX_DATA_free_all_data((void **)a1 + 12);
    v7 = (_QWORD *)((char *)a2 + 96);
    while (1)
    {
      v7 = (_QWORD *)*v7;
      if (!v7)
        break;
      v5 = (EC_POINT *)((uint64_t (*)(_QWORD))v7[2])(v7[1]);
      if (v5)
      {
        LODWORD(v5) = EC_EX_DATA_set_data((uint64_t)a1 + 96, (uint64_t)v5, v7[2], v7[3], v7[4]);
        if ((_DWORD)v5)
          continue;
      }
      return (int)v5;
    }
    v8 = (const EC_POINT *)*((_QWORD *)a2 + 1);
    v5 = (EC_POINT *)*((_QWORD *)a1 + 1);
    if (v8)
    {
      if (!v5)
      {
        v5 = EC_POINT_new(a1);
        *((_QWORD *)a1 + 1) = v5;
        if (!v5)
          return (int)v5;
        v8 = (const EC_POINT *)*((_QWORD *)a2 + 1);
      }
      LODWORD(v5) = EC_POINT_copy(v5, v8);
      if (!(_DWORD)v5)
        return (int)v5;
    }
    else
    {
      EC_POINT_free(v5);
      *((_QWORD *)a1 + 1) = 0;
    }
    LODWORD(v5) = bn_copy((BIGNUM *)((char *)a1 + 16), (const BIGNUM *)((char *)a2 + 16));
    if ((_DWORD)v5)
    {
      LODWORD(v5) = bn_copy((BIGNUM *)((char *)a1 + 40), (const BIGNUM *)((char *)a2 + 40));
      if ((_DWORD)v5)
      {
        v10 = (EC_POINT **)((char *)a1 + 80);
        v9 = (void *)*((_QWORD *)a1 + 10);
        *((_QWORD *)a1 + 8) = *((_QWORD *)a2 + 8);
        *((_DWORD *)a1 + 18) = *((_DWORD *)a2 + 18);
        v11 = *((_QWORD *)a2 + 10);
        free(v9);
        if (v11)
        {
          v5 = (EC_POINT *)malloc_type_malloc(*((_QWORD *)a2 + 11), 0x24900E62uLL);
          *v10 = v5;
          if (!v5)
            return (int)v5;
          memcpy(v5, *((const void **)a2 + 10), *((_QWORD *)a2 + 11));
          *((_QWORD *)a1 + 11) = *((_QWORD *)a2 + 11);
        }
        else
        {
          *v10 = 0;
          *((_QWORD *)a1 + 11) = 0;
        }
        LODWORD(v5) = (*(uint64_t (**)(EC_GROUP *, const EC_GROUP *))(*(_QWORD *)a1 + 24))(a1, a2);
      }
    }
  }
  return (int)v5;
}

void EC_EX_DATA_free_all_data(void **a1)
{
  void (**v2)(_QWORD);
  void (*v3)(_QWORD);

  if (a1)
  {
    v2 = (void (**)(_QWORD))*a1;
    if (*a1)
    {
      do
      {
        v3 = *v2;
        v2[3](v2[1]);
        free(v2);
        v2 = (void (**)(_QWORD))v3;
      }
      while (v3);
    }
    *a1 = 0;
  }
}

uint64_t EC_EX_DATA_set_data(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  _QWORD *v9;
  _QWORD *v10;

  if (result)
  {
    v9 = (_QWORD *)result;
    v10 = *(_QWORD **)result;
    if (*(_QWORD *)result)
    {
      while (v10[2] != a3 || v10[3] != a4 || v10[4] != a5)
      {
        v10 = (_QWORD *)*v10;
        if (!v10)
          goto LABEL_7;
      }
      ERR_put_error(16, 4095, 108, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_lib.c", 695);
      return 0;
    }
    else
    {
LABEL_7:
      if (a2)
      {
        result = (uint64_t)malloc_type_malloc(0x28uLL, 0xA0040B756CE11uLL);
        if (!result)
          return result;
        *(_QWORD *)(result + 8) = a2;
        *(_QWORD *)(result + 16) = a3;
        *(_QWORD *)(result + 24) = a4;
        *(_QWORD *)(result + 32) = a5;
        *(_QWORD *)result = *v9;
        *v9 = result;
      }
      return 1;
    }
  }
  return result;
}

EC_POINT *__cdecl EC_POINT_new(const EC_GROUP *a1)
{
  EC_POINT *v2;
  EC_POINT *v3;
  uint64_t v4;
  int v5;
  int v6;

  if (!a1)
  {
    v5 = 67;
    v6 = 838;
LABEL_8:
    ERR_put_error(16, 4095, v5, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_lib.c", v6);
    return 0;
  }
  if (!*(_QWORD *)(*(_QWORD *)a1 + 72))
  {
    v5 = 66;
    v6 = 842;
    goto LABEL_8;
  }
  v2 = (EC_POINT *)malloc_type_malloc(0x58uLL, 0x10700408AB58AABuLL);
  v3 = v2;
  if (!v2)
  {
    ERR_put_error(16, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_lib.c", 847);
    return v3;
  }
  v4 = *(_QWORD *)a1;
  *(_QWORD *)v2 = *(_QWORD *)a1;
  if (!(*(unsigned int (**)(EC_POINT *))(v4 + 72))(v2))
  {
    free(v3);
    return 0;
  }
  return v3;
}

int EC_POINT_copy(EC_POINT *a1, const EC_POINT *a2)
{
  uint64_t (*v2)(void);
  int v3;
  int v4;

  v2 = *(uint64_t (**)(void))(*(_QWORD *)a1 + 88);
  if (!v2)
  {
    v3 = 66;
    v4 = 881;
    goto LABEL_5;
  }
  if (*(_QWORD *)a1 != *(_QWORD *)a2)
  {
    v3 = 101;
    v4 = 885;
LABEL_5:
    ERR_put_error(16, 4095, v3, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_lib.c", v4);
    return 0;
  }
  if (a1 == a2)
    return 1;
  else
    return v2();
}

EC_GROUP *__cdecl EC_GROUP_dup(const EC_GROUP *a1)
{
  EC_GROUP *v2;
  EC_GROUP *v3;

  if (!a1)
    return 0;
  v2 = EC_GROUP_new(*(const EC_METHOD **)a1);
  v3 = v2;
  if (v2 && !EC_GROUP_copy(v2, a1))
  {
    EC_GROUP_free(v3);
    return 0;
  }
  return v3;
}

const EC_METHOD *__cdecl EC_GROUP_method_of(const EC_GROUP *a1)
{
  return *(const EC_METHOD **)a1;
}

int EC_METHOD_get_field_type(const EC_METHOD *a1)
{
  return *(_DWORD *)a1;
}

int EC_GROUP_set_generator(EC_GROUP *a1, const EC_POINT *generator, const BIGNUM *order, const BIGNUM *cofactor)
{
  const BIGNUM *v8;
  int v9;
  int v10;
  EC_POINT *v11;
  const BIGNUM *v12;
  int v13;
  int v14;

  if (!generator)
  {
    v9 = 67;
    v10 = 322;
    goto LABEL_6;
  }
  v8 = (const BIGNUM *)((char *)a1 + 104);
  if (BN_is_zero((uint64_t)a1 + 104) || BN_is_negative((uint64_t)v8))
  {
    v9 = 103;
    v10 = 328;
LABEL_6:
    ERR_put_error(16, 4095, v9, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_lib.c", v10);
    LODWORD(v11) = 0;
    return (int)v11;
  }
  if (!order || (v12 = BN_value_one(), BN_cmp(order, v12) < 1) || (v13 = BN_num_bits(order), v13 > BN_num_bits(v8) + 1))
  {
    v9 = 122;
    v10 = 338;
    goto LABEL_6;
  }
  if (cofactor && BN_is_negative((uint64_t)cofactor))
  {
    v9 = 164;
    v10 = 348;
    goto LABEL_6;
  }
  v11 = (EC_POINT *)*((_QWORD *)a1 + 1);
  if (v11 || (v11 = EC_POINT_new(a1), (*((_QWORD *)a1 + 1) = v11) != 0))
  {
    LODWORD(v11) = EC_POINT_copy(v11, generator);
    if ((_DWORD)v11)
    {
      LODWORD(v11) = bn_copy((BIGNUM *)((char *)a1 + 16), order);
      if ((_DWORD)v11)
      {
        if (cofactor && !BN_is_zero((uint64_t)cofactor))
        {
          LODWORD(v11) = bn_copy((BIGNUM *)((char *)a1 + 40), cofactor);
          if (!(_DWORD)v11)
            return (int)v11;
        }
        else
        {
          LODWORD(v11) = ec_guess_cofactor((uint64_t)a1);
          if (!(_DWORD)v11)
            return (int)v11;
        }
        v14 = BN_num_bits((const BIGNUM *)((char *)a1 + 40));
        if (v14 > BN_num_bits(v8) + 1)
        {
          v9 = 122;
          v10 = 372;
          goto LABEL_6;
        }
        LODWORD(v11) = 1;
      }
    }
  }
  return (int)v11;
}

BOOL ec_guess_cofactor(uint64_t a1)
{
  const BIGNUM *v2;
  int v3;
  int v4;
  int v5;
  BN_CTX *v6;
  BN_CTX *v7;
  BIGNUM *v8;
  BIGNUM *v9;
  int v10;
  _BOOL8 v11;
  const BIGNUM *v12;

  v2 = (const BIGNUM *)(a1 + 16);
  v3 = BN_num_bits((const BIGNUM *)(a1 + 16));
  v4 = BN_num_bits((const BIGNUM *)(a1 + 104));
  v5 = v4 + 2;
  if (v4 >= -1)
    v5 = v4 + 1;
  if (v3 <= (v5 >> 1) + 3)
  {
    v11 = 1;
LABEL_17:
    BN_zero(a1 + 40);
    return v11;
  }
  v6 = BN_CTX_new();
  v7 = v6;
  if (!v6)
    goto LABEL_15;
  BN_CTX_start(v6);
  v8 = BN_CTX_get(v7);
  if (!v8)
    goto LABEL_15;
  v9 = v8;
  if (**(_DWORD **)a1 == 407)
  {
    BN_zero((uint64_t)v8);
    v10 = BN_num_bits((const BIGNUM *)(a1 + 104));
    if (!BN_set_bit(v9, v10 - 1))
      goto LABEL_15;
  }
  else if (!bn_copy(v8, (const BIGNUM *)(a1 + 104)))
  {
    goto LABEL_15;
  }
  if (BN_rshift1((BIGNUM *)(a1 + 40), v2))
  {
    v12 = BN_value_one();
    if (BN_add((BIGNUM *)(a1 + 40), (const BIGNUM *)(a1 + 40), v12))
    {
      if (BN_add((BIGNUM *)(a1 + 40), (const BIGNUM *)(a1 + 40), v9))
      {
        v11 = BN_div_ct(a1 + 40, 0, (const BIGNUM *)(a1 + 40), v2, v7) != 0;
        goto LABEL_16;
      }
    }
  }
LABEL_15:
  v11 = 0;
LABEL_16:
  BN_CTX_end(v7);
  BN_CTX_free(v7);
  if (!v11)
    goto LABEL_17;
  return v11;
}

const EC_POINT *__cdecl EC_GROUP_get0_generator(const EC_GROUP *a1)
{
  return (const EC_POINT *)*((_QWORD *)a1 + 1);
}

int EC_GROUP_get_order(const EC_GROUP *a1, BIGNUM *order, BN_CTX *a3)
{
  int result;

  result = bn_copy(order, (const BIGNUM *)((char *)a1 + 16));
  if (result)
    return !BN_is_zero((uint64_t)order);
  return result;
}

uint64_t EC_GROUP_order_bits(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 56))(a1);
}

int EC_GROUP_get_cofactor(const EC_GROUP *a1, BIGNUM *cofactor, BN_CTX *a3)
{
  char *v3;
  int result;

  v3 = (char *)a1 + 40;
  result = bn_copy(cofactor, (const BIGNUM *)((char *)a1 + 40));
  if (result)
    return !BN_is_zero((uint64_t)v3);
  return result;
}

void EC_GROUP_set_curve_name(EC_GROUP *a1, int nid)
{
  *((_DWORD *)a1 + 16) = nid;
}

int EC_GROUP_get_curve_name(const EC_GROUP *a1)
{
  return *((_DWORD *)a1 + 16);
}

void EC_GROUP_set_asn1_flag(EC_GROUP *a1, int flag)
{
  *((_DWORD *)a1 + 17) = flag;
}

int EC_GROUP_get_asn1_flag(const EC_GROUP *a1)
{
  return *((_DWORD *)a1 + 17);
}

void EC_GROUP_set_point_conversion_form(EC_GROUP *a1, point_conversion_form_t a2)
{
  *((_DWORD *)a1 + 18) = a2;
}

point_conversion_form_t EC_GROUP_get_point_conversion_form(const EC_GROUP *a1)
{
  return *((_DWORD *)a1 + 18);
}

size_t EC_GROUP_set_seed(EC_GROUP *a1, const unsigned __int8 *a2, size_t len)
{
  void *v6;
  size_t *v7;
  size_t result;

  v7 = (size_t *)((char *)a1 + 80);
  v6 = (void *)*((_QWORD *)a1 + 10);
  if (v6)
  {
    free(v6);
    *v7 = 0;
    v7[1] = 0;
  }
  result = 1;
  if (a2 && len)
  {
    result = (size_t)malloc_type_malloc(len, 0x611930E7uLL);
    *v7 = result;
    if (result)
    {
      memcpy((void *)result, a2, len);
      *((_QWORD *)a1 + 11) = len;
      return len;
    }
  }
  return result;
}

unsigned __int8 *__cdecl EC_GROUP_get0_seed(const EC_GROUP *a1)
{
  return (unsigned __int8 *)*((_QWORD *)a1 + 10);
}

size_t EC_GROUP_get_seed_len(const EC_GROUP *a1)
{
  return *((_QWORD *)a1 + 11);
}

uint64_t EC_GROUP_set_curve(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, BN_CTX *a5)
{
  BN_CTX *v10;
  uint64_t (*v11)(uint64_t, uint64_t, uint64_t, uint64_t, BN_CTX *);
  uint64_t v12;

  v10 = a5;
  if (a5 || (v10 = BN_CTX_new()) != 0)
  {
    v11 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, BN_CTX *))(*(_QWORD *)a1 + 32);
    if (v11)
    {
      v12 = v11(a1, a2, a3, a4, v10);
      goto LABEL_7;
    }
    ERR_put_error(16, 4095, 66, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_lib.c", 501);
  }
  v12 = 0;
LABEL_7:
  if (v10 != a5)
    BN_CTX_free(v10);
  return v12;
}

uint64_t EC_GROUP_get_curve(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, BN_CTX *a5)
{
  BN_CTX *v10;
  uint64_t (*v11)(uint64_t, uint64_t, uint64_t, uint64_t, BN_CTX *);
  uint64_t v12;

  v10 = a5;
  if (a5 || (v10 = BN_CTX_new()) != 0)
  {
    v11 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, BN_CTX *))(*(_QWORD *)a1 + 40);
    if (v11)
    {
      v12 = v11(a1, a2, a3, a4, v10);
      goto LABEL_7;
    }
    ERR_put_error(16, 4095, 66, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_lib.c", 526);
  }
  v12 = 0;
LABEL_7:
  if (v10 != a5)
    BN_CTX_free(v10);
  return v12;
}

int EC_GROUP_get_degree(const EC_GROUP *a1)
{
  uint64_t (*v1)(void);

  v1 = *(uint64_t (**)(void))(*(_QWORD *)a1 + 48);
  if (v1)
    return v1();
  ERR_put_error(16, 4095, 66, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_lib.c", 556);
  return 0;
}

int EC_GROUP_check_discriminant(const EC_GROUP *a1, BN_CTX *a2)
{
  BN_CTX *v4;
  uint64_t (*v5)(const EC_GROUP *, BN_CTX *);
  int v6;

  v4 = a2;
  if (a2 || (v4 = BN_CTX_new()) != 0)
  {
    v5 = *(uint64_t (**)(const EC_GROUP *, BN_CTX *))(*(_QWORD *)a1 + 64);
    if (v5)
    {
      v6 = v5(a1, v4);
      goto LABEL_7;
    }
    ERR_put_error(16, 4095, 66, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_lib.c", 575);
  }
  v6 = 0;
LABEL_7:
  if (v4 != a2)
    BN_CTX_free(v4);
  return v6;
}

int EC_GROUP_cmp(const EC_GROUP *a1, const EC_GROUP *a2, BN_CTX *a3)
{
  BN_CTX *v3;
  int v6;
  int v7;
  BOOL v8;
  BN_CTX *v9;
  int v10;
  BIGNUM *v11;
  BIGNUM *v12;
  BIGNUM *v13;
  BIGNUM *v14;
  BIGNUM *v15;
  const BIGNUM *v16;
  BIGNUM *v17;
  BIGNUM *v18;
  BIGNUM *v19;
  BIGNUM *v20;
  BIGNUM *v21;
  const BIGNUM *v22;
  BN_CTX *v23;
  BN_CTX *v24;
  BN_CTX *v25;
  BN_CTX *v26;

  if (**(_DWORD **)a1 == **(_DWORD **)a2)
  {
    v3 = a3;
    v6 = *((_DWORD *)a1 + 16);
    if (!v6 || ((v7 = *((_DWORD *)a2 + 16)) != 0 ? (v8 = v6 == v7) : (v8 = 1), v8))
    {
      if (a3)
      {
        v9 = 0;
      }
      else
      {
        v9 = BN_CTX_new();
        v3 = v9;
        if (!v9)
          return -1;
      }
      BN_CTX_start(v3);
      v11 = BN_CTX_get(v3);
      if (v11)
      {
        v12 = v11;
        v13 = BN_CTX_get(v3);
        if (v13)
        {
          v14 = v13;
          v15 = BN_CTX_get(v3);
          if (v15)
          {
            v16 = v15;
            v17 = BN_CTX_get(v3);
            if (v17)
            {
              v18 = v17;
              v19 = BN_CTX_get(v3);
              if (v19)
              {
                v20 = v19;
                v21 = BN_CTX_get(v3);
                if (v21)
                {
                  v22 = v21;
                  if (!(*(unsigned int (**)(const EC_GROUP *, BIGNUM *, BIGNUM *, const BIGNUM *, BN_CTX *))(*(_QWORD *)a1 + 40))(a1, v12, v14, v16, v3)|| !(*(unsigned int (**)(const EC_GROUP *, BIGNUM *, BIGNUM *, const BIGNUM *, BN_CTX *))(*(_QWORD *)a2 + 40))(a2, v18, v20, v22, v3)|| BN_cmp(v12, v18)|| BN_cmp(v14, v20)|| BN_cmp(v16, v22)|| EC_POINT_cmp(a1, *((const EC_POINT **)a1 + 1), *((const EC_POINT **)a2 + 1), v3))
                  {
                    goto LABEL_24;
                  }
                  if (EC_GROUP_get_order(a1, v12, v23)
                    && EC_GROUP_get_order(a2, v18, v24)
                    && EC_GROUP_get_cofactor(a1, v14, v25)
                    && EC_GROUP_get_cofactor(a2, v20, v26))
                  {
                    if (!BN_cmp(v12, v18) && !BN_cmp(v14, v20))
                    {
                      v10 = 0;
LABEL_25:
                      BN_CTX_end(v3);
                      if (!v9)
                        return v10;
                      goto LABEL_36;
                    }
LABEL_24:
                    v10 = 1;
                    goto LABEL_25;
                  }
                }
              }
            }
          }
        }
      }
      BN_CTX_end(v3);
      v10 = -1;
      if (!v9)
        return v10;
LABEL_36:
      BN_CTX_free(v3);
      return v10;
    }
  }
  return 1;
}

int EC_POINT_cmp(const EC_GROUP *a1, const EC_POINT *a, const EC_POINT *b, BN_CTX *a4)
{
  BN_CTX *v8;
  uint64_t v9;
  uint64_t (*v10)(const EC_GROUP *, const EC_POINT *, const EC_POINT *, BN_CTX *);
  int v11;
  int v12;
  int v13;

  v8 = a4;
  if (!a4)
  {
    v8 = BN_CTX_new();
    if (!v8)
      goto LABEL_9;
  }
  v9 = *(_QWORD *)a1;
  v10 = *(uint64_t (**)(const EC_GROUP *, const EC_POINT *, const EC_POINT *, BN_CTX *))(*(_QWORD *)a1 + 200);
  if (!v10)
  {
    v11 = 66;
    v12 = 1238;
    goto LABEL_8;
  }
  if (v9 != *(_QWORD *)a || v9 != *(_QWORD *)b)
  {
    v11 = 101;
    v12 = 1242;
LABEL_8:
    ERR_put_error(16, 4095, v11, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_lib.c", v12);
LABEL_9:
    v13 = -1;
    goto LABEL_10;
  }
  v13 = v10(a1, a, b, v8);
LABEL_10:
  if (v8 != a4)
    BN_CTX_free(v8);
  return v13;
}

uint64_t ec_point_blind_coordinates(uint64_t a1)
{
  uint64_t (*v1)(void);

  v1 = *(uint64_t (**)(void))(*(_QWORD *)a1 + 312);
  if (v1)
    return v1();
  else
    return 1;
}

_QWORD *EC_EX_DATA_get_data(_QWORD *result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (result)
  {
    while (result[2] != a2 || result[3] != a3 || result[4] != a4)
    {
      result = (_QWORD *)*result;
      if (!result)
        return result;
    }
    return (_QWORD *)result[1];
  }
  return result;
}

void EC_EX_DATA_free_data(void **a1, uint64_t a2, void (*a3)(void *), void *a4)
{
  _QWORD *v4;
  void **v5;
  void *v6;

  if (a1)
  {
    while (1)
    {
      v4 = *a1;
      if (!*a1)
        break;
      v5 = a1;
      a1 = (void **)*a1;
      if (v4[2] == a2 && a1[3] == a3 && a1[4] == a4)
      {
        v6 = *a1;
        a3(a1[1]);
        free(*v5);
        *v5 = v6;
        return;
      }
    }
  }
}

void EC_EX_DATA_clear_free_data(void **a1, uint64_t a2, void *a3, void (*a4)(void *))
{
  _QWORD *v4;
  void **v5;
  void *v6;

  if (a1)
  {
    while (1)
    {
      v4 = *a1;
      if (!*a1)
        break;
      v5 = a1;
      a1 = (void **)*a1;
      if (v4[2] == a2 && a1[3] == a3 && a1[4] == a4)
      {
        v6 = *a1;
        a4(a1[1]);
        free(*v5);
        *v5 = v6;
        return;
      }
    }
  }
}

void EC_POINT_clear_free(EC_POINT *a1)
{
  void (*v2)(EC_POINT *);

  if (a1)
  {
    v2 = *(void (**)(EC_POINT *))(*(_QWORD *)a1 + 80);
    if (v2)
      v2(a1);
    freezero(a1, 0x58uLL);
  }
}

EC_POINT *__cdecl EC_POINT_dup(const EC_POINT *a1, const EC_GROUP *a2)
{
  EC_POINT *v3;
  EC_POINT *v4;
  void (*v5)(EC_POINT *);

  if (!a1)
    return 0;
  v3 = EC_POINT_new(a2);
  v4 = v3;
  if (v3 && !EC_POINT_copy(v3, a1))
  {
    v5 = *(void (**)(EC_POINT *))(*(_QWORD *)v4 + 80);
    if (v5)
      v5(v4);
    freezero(v4, 0x58uLL);
    return 0;
  }
  return v4;
}

const EC_METHOD *__cdecl EC_POINT_method_of(const EC_POINT *a1)
{
  return *(const EC_METHOD **)a1;
}

int EC_POINT_set_to_infinity(const EC_GROUP *a1, EC_POINT *a2)
{
  uint64_t (*v2)(void);
  int v3;
  int v4;

  v2 = *(uint64_t (**)(void))(*(_QWORD *)a1 + 96);
  if (!v2)
  {
    v3 = 66;
    v4 = 923;
    goto LABEL_5;
  }
  if (*(_QWORD *)a1 != *(_QWORD *)a2)
  {
    v3 = 101;
    v4 = 927;
LABEL_5:
    ERR_put_error(16, 4095, v3, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_lib.c", v4);
    return 0;
  }
  return v2();
}

uint64_t EC_POINT_set_Jprojective_coordinates(const EC_GROUP *a1, const EC_POINT *a2, uint64_t a3, uint64_t a4, uint64_t a5, BN_CTX *a6)
{
  BN_CTX *v12;
  unsigned int (*v13)(const EC_GROUP *, const EC_POINT *, uint64_t, uint64_t, uint64_t, BN_CTX *);
  int v14;
  int v15;
  uint64_t v16;

  v12 = a6;
  if (!a6)
  {
    v12 = BN_CTX_new();
    if (!v12)
      goto LABEL_8;
  }
  v13 = *(unsigned int (**)(const EC_GROUP *, const EC_POINT *, uint64_t, uint64_t, uint64_t, BN_CTX *))(*(_QWORD *)a1 + 104);
  if (!v13)
  {
    v14 = 66;
    v15 = 946;
    goto LABEL_7;
  }
  if (*(_QWORD *)a1 != *(_QWORD *)a2)
  {
    v14 = 101;
    v15 = 950;
LABEL_7:
    ERR_put_error(16, 4095, v14, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_lib.c", v15);
LABEL_8:
    v16 = 0;
    goto LABEL_9;
  }
  if (!v13(a1, a2, a3, a4, a5, v12))
    goto LABEL_8;
  if (EC_POINT_is_on_curve(a1, a2, v12) <= 0)
  {
    v14 = 107;
    v15 = 958;
    goto LABEL_7;
  }
  v16 = 1;
LABEL_9:
  if (v12 != a6)
    BN_CTX_free(v12);
  return v16;
}

int EC_POINT_is_on_curve(const EC_GROUP *a1, const EC_POINT *a2, BN_CTX *a3)
{
  BN_CTX *v6;
  uint64_t (*v7)(const EC_GROUP *, const EC_POINT *, BN_CTX *);
  int v8;
  int v9;
  int v10;

  v6 = a3;
  if (!a3)
  {
    v6 = BN_CTX_new();
    if (!v6)
      goto LABEL_8;
  }
  v7 = *(uint64_t (**)(const EC_GROUP *, const EC_POINT *, BN_CTX *))(*(_QWORD *)a1 + 192);
  if (!v7)
  {
    v8 = 66;
    v9 = 1209;
    goto LABEL_7;
  }
  if (*(_QWORD *)a1 != *(_QWORD *)a2)
  {
    v8 = 101;
    v9 = 1213;
LABEL_7:
    ERR_put_error(16, 4095, v8, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_lib.c", v9);
LABEL_8:
    v10 = 0;
    goto LABEL_10;
  }
  v10 = v7(a1, a2, v6);
LABEL_10:
  if (v6 != a3)
    BN_CTX_free(v6);
  return v10;
}

uint64_t EC_POINT_get_Jprojective_coordinates(uint64_t a1, _QWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, BN_CTX *a6)
{
  BN_CTX *v12;
  uint64_t (*v13)(uint64_t, _QWORD *, uint64_t, uint64_t, uint64_t, BN_CTX *);
  int v14;
  int v15;
  uint64_t v16;

  v12 = a6;
  if (!a6)
  {
    v12 = BN_CTX_new();
    if (!v12)
      goto LABEL_8;
  }
  v13 = *(uint64_t (**)(uint64_t, _QWORD *, uint64_t, uint64_t, uint64_t, BN_CTX *))(*(_QWORD *)a1 + 112);
  if (!v13)
  {
    v14 = 66;
    v15 = 984;
    goto LABEL_7;
  }
  if (*(_QWORD *)a1 != *a2)
  {
    v14 = 101;
    v15 = 988;
LABEL_7:
    ERR_put_error(16, 4095, v14, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_lib.c", v15);
LABEL_8:
    v16 = 0;
    goto LABEL_10;
  }
  v16 = v13(a1, a2, a3, a4, a5, v12);
LABEL_10:
  if (v12 != a6)
    BN_CTX_free(v12);
  return v16;
}

uint64_t EC_POINT_set_affine_coordinates(const EC_GROUP *a1, const EC_POINT *a2, uint64_t a3, uint64_t a4, BN_CTX *a5)
{
  BN_CTX *v10;
  unsigned int (*v11)(const EC_GROUP *, const EC_POINT *, uint64_t, uint64_t, BN_CTX *);
  int v12;
  int v13;
  uint64_t v14;

  v10 = a5;
  if (!a5)
  {
    v10 = BN_CTX_new();
    if (!v10)
      goto LABEL_8;
  }
  v11 = *(unsigned int (**)(const EC_GROUP *, const EC_POINT *, uint64_t, uint64_t, BN_CTX *))(*(_QWORD *)a1 + 120);
  if (!v11)
  {
    v12 = 66;
    v13 = 1028;
    goto LABEL_7;
  }
  if (*(_QWORD *)a1 != *(_QWORD *)a2)
  {
    v12 = 101;
    v13 = 1032;
LABEL_7:
    ERR_put_error(16, 4095, v12, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_lib.c", v13);
LABEL_8:
    v14 = 0;
    goto LABEL_9;
  }
  if (!v11(a1, a2, a3, a4, v10))
    goto LABEL_8;
  if (EC_POINT_is_on_curve(a1, a2, v10) <= 0)
  {
    v12 = 107;
    v13 = 1039;
    goto LABEL_7;
  }
  v14 = 1;
LABEL_9:
  if (v10 != a5)
    BN_CTX_free(v10);
  return v14;
}

uint64_t EC_POINT_get_affine_coordinates(uint64_t a1, _QWORD *a2, uint64_t a3, uint64_t a4, BN_CTX *a5)
{
  BN_CTX *v10;
  uint64_t (*v11)(uint64_t, _QWORD *, uint64_t, uint64_t, BN_CTX *);
  int v12;
  int v13;
  uint64_t v14;

  v10 = a5;
  if (!a5)
  {
    v10 = BN_CTX_new();
    if (!v10)
      goto LABEL_8;
  }
  v11 = *(uint64_t (**)(uint64_t, _QWORD *, uint64_t, uint64_t, BN_CTX *))(*(_QWORD *)a1 + 128);
  if (!v11)
  {
    v12 = 66;
    v13 = 1072;
    goto LABEL_7;
  }
  if (*(_QWORD *)a1 != *a2)
  {
    v12 = 101;
    v13 = 1076;
LABEL_7:
    ERR_put_error(16, 4095, v12, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_lib.c", v13);
LABEL_8:
    v14 = 0;
    goto LABEL_10;
  }
  v14 = v11(a1, a2, a3, a4, v10);
LABEL_10:
  if (v10 != a5)
    BN_CTX_free(v10);
  return v14;
}

int EC_POINT_add(const EC_GROUP *a1, EC_POINT *r, const EC_POINT *a, const EC_POINT *b, BN_CTX *a5)
{
  BN_CTX *v10;
  uint64_t v11;
  uint64_t (*v12)(const EC_GROUP *, EC_POINT *, const EC_POINT *, const EC_POINT *, BN_CTX *);
  int v13;
  int v14;
  int v15;

  v10 = a5;
  if (!a5)
  {
    v10 = BN_CTX_new();
    if (!v10)
      goto LABEL_10;
  }
  v11 = *(_QWORD *)a1;
  v12 = *(uint64_t (**)(const EC_GROUP *, EC_POINT *, const EC_POINT *, const EC_POINT *, BN_CTX *))(*(_QWORD *)a1 + 160);
  if (!v12)
  {
    v13 = 66;
    v14 = 1108;
    goto LABEL_9;
  }
  if (v11 != *(_QWORD *)r || v11 != *(_QWORD *)a || v11 != *(_QWORD *)b)
  {
    v13 = 101;
    v14 = 1113;
LABEL_9:
    ERR_put_error(16, 4095, v13, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_lib.c", v14);
LABEL_10:
    v15 = 0;
    goto LABEL_11;
  }
  v15 = v12(a1, r, a, b, v10);
LABEL_11:
  if (v10 != a5)
    BN_CTX_free(v10);
  return v15;
}

int EC_POINT_dbl(const EC_GROUP *a1, EC_POINT *r, const EC_POINT *a, BN_CTX *a4)
{
  BN_CTX *v8;
  uint64_t v9;
  uint64_t (*v10)(const EC_GROUP *, EC_POINT *, const EC_POINT *, BN_CTX *);
  int v11;
  int v12;
  int v13;

  v8 = a4;
  if (!a4)
  {
    v8 = BN_CTX_new();
    if (!v8)
      goto LABEL_9;
  }
  v9 = *(_QWORD *)a1;
  v10 = *(uint64_t (**)(const EC_GROUP *, EC_POINT *, const EC_POINT *, BN_CTX *))(*(_QWORD *)a1 + 168);
  if (!v10)
  {
    v11 = 66;
    v12 = 1138;
    goto LABEL_8;
  }
  if (v9 != *(_QWORD *)r || v9 != *(_QWORD *)a)
  {
    v11 = 101;
    v12 = 1142;
LABEL_8:
    ERR_put_error(16, 4095, v11, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_lib.c", v12);
LABEL_9:
    v13 = 0;
    goto LABEL_10;
  }
  v13 = v10(a1, r, a, v8);
LABEL_10:
  if (v8 != a4)
    BN_CTX_free(v8);
  return v13;
}

int EC_POINT_invert(const EC_GROUP *a1, EC_POINT *a2, BN_CTX *a3)
{
  BN_CTX *v6;
  uint64_t (*v7)(const EC_GROUP *, EC_POINT *, BN_CTX *);
  int v8;
  int v9;
  int v10;

  v6 = a3;
  if (!a3)
  {
    v6 = BN_CTX_new();
    if (!v6)
      goto LABEL_8;
  }
  v7 = *(uint64_t (**)(const EC_GROUP *, EC_POINT *, BN_CTX *))(*(_QWORD *)a1 + 176);
  if (!v7)
  {
    v8 = 66;
    v9 = 1166;
    goto LABEL_7;
  }
  if (*(_QWORD *)a1 != *(_QWORD *)a2)
  {
    v8 = 101;
    v9 = 1170;
LABEL_7:
    ERR_put_error(16, 4095, v8, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_lib.c", v9);
LABEL_8:
    v10 = 0;
    goto LABEL_10;
  }
  v10 = v7(a1, a2, v6);
LABEL_10:
  if (v6 != a3)
    BN_CTX_free(v6);
  return v10;
}

int EC_POINT_is_at_infinity(const EC_GROUP *a1, const EC_POINT *a2)
{
  uint64_t (*v2)(void);
  int v3;
  int v4;

  v2 = *(uint64_t (**)(void))(*(_QWORD *)a1 + 184);
  if (!v2)
  {
    v3 = 66;
    v4 = 1186;
    goto LABEL_5;
  }
  if (*(_QWORD *)a1 != *(_QWORD *)a2)
  {
    v3 = 101;
    v4 = 1190;
LABEL_5:
    ERR_put_error(16, 4095, v3, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_lib.c", v4);
    return 0;
  }
  return v2();
}

int EC_POINT_make_affine(const EC_GROUP *a1, EC_POINT *a2, BN_CTX *a3)
{
  BN_CTX *v6;
  uint64_t (*v7)(const EC_GROUP *, EC_POINT *, BN_CTX *);
  int v8;
  int v9;
  int v10;

  v6 = a3;
  if (!a3)
  {
    v6 = BN_CTX_new();
    if (!v6)
      goto LABEL_8;
  }
  v7 = *(uint64_t (**)(const EC_GROUP *, EC_POINT *, BN_CTX *))(*(_QWORD *)a1 + 208);
  if (!v7)
  {
    v8 = 66;
    v9 = 1266;
    goto LABEL_7;
  }
  if (*(_QWORD *)a1 != *(_QWORD *)a2)
  {
    v8 = 101;
    v9 = 1270;
LABEL_7:
    ERR_put_error(16, 4095, v8, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_lib.c", v9);
LABEL_8:
    v10 = 0;
    goto LABEL_10;
  }
  v10 = v7(a1, a2, v6);
LABEL_10:
  if (v6 != a3)
    BN_CTX_free(v6);
  return v10;
}

int EC_POINTs_make_affine(const EC_GROUP *a1, size_t num, EC_POINT *a3[], BN_CTX *a4)
{
  BN_CTX *v8;
  uint64_t (*v9)(const EC_GROUP *, size_t, EC_POINT **__attribute__((__org_arrdim(0,0))), BN_CTX *);
  EC_POINT **__attribute__((__org_arrdim(0,0))) v10;
  size_t v11;
  int v12;
  int v13;
  int v14;

  v8 = a4;
  if (a4 || (v8 = BN_CTX_new()) != 0)
  {
    v9 = *(uint64_t (**)(const EC_GROUP *, size_t, EC_POINT **__attribute__((__org_arrdim(0,0))), BN_CTX *))(*(_QWORD *)a1 + 216);
    if (v9)
    {
      if (!num)
      {
LABEL_8:
        v12 = v9(a1, num, a3, v8);
        goto LABEL_13;
      }
      v10 = a3;
      v11 = num;
      while (*(_QWORD *)a1 == *(_QWORD *)*v10)
      {
        ++v10;
        if (!--v11)
          goto LABEL_8;
      }
      v13 = 101;
      v14 = 1301;
    }
    else
    {
      v13 = 66;
      v14 = 1296;
    }
    ERR_put_error(16, 4095, v13, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_lib.c", v14);
  }
  v12 = 0;
LABEL_13:
  if (v8 != a4)
    BN_CTX_free(v8);
  return v12;
}

int EC_POINTs_mul(const EC_GROUP *a1, EC_POINT *r, const BIGNUM *a3, size_t num, const EC_POINT *a5[], const BIGNUM *a6[], BN_CTX *a7)
{
  BN_CTX *v14;
  uint64_t v15;
  const EC_POINT *v16;
  const BIGNUM *v17;
  const EC_GROUP *v18;
  EC_POINT *v19;
  const BIGNUM *v20;
  int v21;
  int v22;
  int v23;

  v14 = a7;
  if (!a7)
  {
    v14 = BN_CTX_new();
    if (!v14)
      goto LABEL_13;
  }
  v15 = *(_QWORD *)a1;
  if (!*(_QWORD *)(*(_QWORD *)a1 + 224) || !*(_QWORD *)(v15 + 232) || num > 1 || !*(_QWORD *)(v15 + 240))
  {
    v21 = 66;
    v22 = 1332;
LABEL_12:
    ERR_put_error(16, 4095, v21, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_lib.c", v22);
LABEL_13:
    v23 = 0;
    goto LABEL_14;
  }
  if (num != 1 || !a5 || !a6)
  {
    if (a3 && !a5 && !a6)
    {
      v18 = a1;
      v19 = r;
      v20 = a3;
      v16 = 0;
      v17 = 0;
      goto LABEL_21;
    }
    v21 = 16;
    v22 = 1344;
    goto LABEL_12;
  }
  v16 = *a5;
  v17 = *a6;
  v18 = a1;
  v19 = r;
  v20 = a3;
LABEL_21:
  v23 = EC_POINT_mul(v18, v19, v20, v16, v17, v14);
LABEL_14:
  if (v14 != a7)
    BN_CTX_free(v14);
  return v23;
}

int EC_POINT_mul(const EC_GROUP *a1, EC_POINT *r, const BIGNUM *a3, const EC_POINT *a4, const BIGNUM *a5, BN_CTX *a6)
{
  BN_CTX *v12;
  uint64_t v13;
  uint64_t (*v14)(const EC_GROUP *, EC_POINT *, const BIGNUM *, BN_CTX *);
  uint64_t (*v15)(const EC_GROUP *, EC_POINT *, const BIGNUM *, const EC_POINT *, BN_CTX *);
  uint64_t (*v16)(const EC_GROUP *, EC_POINT *, const BIGNUM *, const BIGNUM *, const EC_POINT *, BN_CTX *);
  int v17;
  int v18;
  int v19;
  int v20;

  v12 = a6;
  if (!a6)
  {
    v12 = BN_CTX_new();
    if (!v12)
      goto LABEL_12;
  }
  v13 = *(_QWORD *)a1;
  v14 = *(uint64_t (**)(const EC_GROUP *, EC_POINT *, const BIGNUM *, BN_CTX *))(*(_QWORD *)a1 + 224);
  if (!v14
    || (v15 = *(uint64_t (**)(const EC_GROUP *, EC_POINT *, const BIGNUM *, const EC_POINT *, BN_CTX *))(v13 + 232)) == 0
    || (v16 = *(uint64_t (**)(const EC_GROUP *, EC_POINT *, const BIGNUM *, const BIGNUM *, const EC_POINT *, BN_CTX *))(v13 + 240)) == 0)
  {
    v18 = 66;
    v19 = 1370;
LABEL_11:
    ERR_put_error(16, 4095, v18, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_lib.c", v19);
LABEL_12:
    v20 = 0;
    goto LABEL_13;
  }
  if (!a3 || a4 || a5)
  {
    if (!a3 && a4 && a5)
    {
      v17 = v15(a1, r, a5, a4, v12);
      goto LABEL_24;
    }
    if (a3 && a4 && a5)
    {
      v17 = v16(a1, r, a3, a5, a4, v12);
      goto LABEL_24;
    }
    v18 = 16;
    v19 = 1405;
    goto LABEL_11;
  }
  v17 = v14(a1, r, a3, v12);
LABEL_24:
  v20 = v17;
LABEL_13:
  if (v12 != a6)
    BN_CTX_free(v12);
  return v20;
}

int EC_GROUP_precompute_mult(EC_GROUP *a1, BN_CTX *a2)
{
  uint64_t (*v2)(EC_GROUP *, BN_CTX *);
  BN_CTX *v5;
  int v6;

  v2 = *(uint64_t (**)(EC_GROUP *, BN_CTX *))(*(_QWORD *)a1 + 248);
  if (!v2)
    return 1;
  v5 = a2;
  if (a2)
    goto LABEL_5;
  v5 = BN_CTX_new();
  if (v5)
  {
    v2 = *(uint64_t (**)(EC_GROUP *, BN_CTX *))(*(_QWORD *)a1 + 248);
LABEL_5:
    v6 = v2(a1, v5);
    goto LABEL_6;
  }
  v6 = 0;
LABEL_6:
  if (v5 != a2)
    BN_CTX_free(v5);
  return v6;
}

int EC_GROUP_have_precompute_mult(const EC_GROUP *a1)
{
  uint64_t (*v1)(void);

  v1 = *(uint64_t (**)(void))(*(_QWORD *)a1 + 256);
  if (v1)
    return v1();
  else
    return 0;
}

uint64_t ec_group_simple_order_bits(uint64_t a1)
{
  return BN_num_bits((const BIGNUM *)(a1 + 16));
}

EC_KEY *ECParameters_dup(EC_KEY *a1)
{
  int v1;
  size_t v2;
  EC_KEY *v3;
  unsigned __int8 *v5;
  unsigned __int8 *in;

  v5 = 0;
  if (!a1)
    return 0;
  v1 = i2d_ECParameters(a1, &v5);
  if (v1 < 1)
    return 0;
  in = v5;
  v2 = v1;
  v3 = d2i_ECParameters(0, (const unsigned __int8 **)&in, v1);
  freezero(v5, v2);
  return v3;
}

uint64_t **x509_issuer_tree_RB_INSERT_COLOR(uint64_t **result, uint64_t *a2)
{
  uint64_t *i;
  uint64_t *v3;
  uint64_t v4;
  uint64_t *v5;
  uint64_t *v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t **v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t **v13;
  uint64_t *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t **v17;
  uint64_t v18;
  uint64_t **v19;

  for (i = (uint64_t *)a2[2]; i; a2 = v5)
  {
    if (*((_DWORD *)i + 6) != 1)
      break;
    v3 = (uint64_t *)i[2];
    v4 = *v3;
    if (i == (uint64_t *)*v3)
    {
      v4 = v3[1];
      if (!v4 || *(_DWORD *)(v4 + 24) != 1)
      {
        v6 = (uint64_t *)i[1];
        if (v6 != a2)
        {
          v7 = i;
          v5 = a2;
          a2 = i;
LABEL_33:
          *((_DWORD *)a2 + 6) = 0;
          *((_DWORD *)v3 + 6) = 1;
          *v3 = (uint64_t)v6;
          if (v6)
            v6[2] = (uint64_t)v3;
          v18 = v3[2];
          v7[2] = v18;
          v19 = result;
          if (v18)
          {
            v19 = (uint64_t **)v3[2];
            if (v3 != *v19)
              ++v19;
          }
          *v19 = v7;
          v7[1] = (uint64_t)v3;
          v3[2] = (uint64_t)v7;
          goto LABEL_39;
        }
        v11 = *a2;
        i[1] = *a2;
        if (v11)
        {
          *(_QWORD *)(v11 + 16) = i;
          v12 = i[2];
          a2[2] = v12;
          v13 = result;
          if (!v12)
          {
LABEL_32:
            *v13 = a2;
            *a2 = (uint64_t)i;
            i[2] = (uint64_t)a2;
            v7 = (uint64_t *)*v3;
            v6 = *(uint64_t **)(*v3 + 8);
            v5 = i;
            goto LABEL_33;
          }
        }
        else
        {
          a2[2] = (uint64_t)v3;
        }
        v13 = (uint64_t **)i[2];
        if (i != *v13)
          ++v13;
        goto LABEL_32;
      }
    }
    else if (!v4 || *(_DWORD *)(v4 + 24) != 1)
    {
      if ((uint64_t *)*i != a2)
      {
        v5 = a2;
        a2 = i;
LABEL_23:
        *((_DWORD *)a2 + 6) = 0;
        *((_DWORD *)v3 + 6) = 1;
        v14 = (uint64_t *)v3[1];
        v15 = *v14;
        v3[1] = *v14;
        if (v15)
          *(_QWORD *)(v15 + 16) = v3;
        v16 = v3[2];
        v14[2] = v16;
        v17 = result;
        if (v16)
        {
          v17 = (uint64_t **)v3[2];
          if (v3 != *v17)
            ++v17;
        }
        *v17 = v14;
        *v14 = (uint64_t)v3;
        v3[2] = (uint64_t)v14;
        goto LABEL_39;
      }
      v8 = a2[1];
      *i = v8;
      if (v8)
      {
        *(_QWORD *)(v8 + 16) = i;
        v9 = i[2];
        a2[2] = v9;
        v10 = result;
        if (!v9)
        {
LABEL_22:
          *v10 = a2;
          a2[1] = (uint64_t)i;
          v5 = i;
          i[2] = (uint64_t)a2;
          goto LABEL_23;
        }
      }
      else
      {
        a2[2] = (uint64_t)v3;
      }
      v10 = (uint64_t **)i[2];
      if (i != *v10)
        ++v10;
      goto LABEL_22;
    }
    *(_DWORD *)(v4 + 24) = 0;
    *((_DWORD *)i + 6) = 0;
    v5 = v3;
    *((_DWORD *)v3 + 6) = 1;
LABEL_39:
    i = (uint64_t *)v5[2];
  }
  *((_DWORD *)*result + 6) = 0;
  return result;
}

uint64_t *x509_issuer_tree_RB_REMOVE_COLOR(uint64_t *result, uint64_t a2, uint64_t **a3)
{
  uint64_t **v3;
  uint64_t **v4;
  uint64_t *v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t **v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t **v11;
  uint64_t v12;
  uint64_t **v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t **v16;
  uint64_t **v17;
  uint64_t *v18;
  uint64_t *v19;
  uint64_t *v20;
  uint64_t *v21;
  uint64_t *v22;
  uint64_t *v23;
  uint64_t *v24;
  uint64_t **v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t *v28;
  uint64_t v29;
  uint64_t *v30;
  uint64_t *v31;
  uint64_t *v32;
  uint64_t **v33;

  while (1)
  {
    v3 = a3;
    a3 = (uint64_t **)a2;
    if (v3)
    {
      if (*((_DWORD *)v3 + 6))
        break;
    }
    v4 = (uint64_t **)*result;
    if (v3 == (uint64_t **)*result)
      goto LABEL_74;
    v5 = *(uint64_t **)a2;
    if (*(uint64_t ***)a2 == v3)
    {
      v5 = *(uint64_t **)(a2 + 8);
      if (*((_DWORD *)v5 + 6) == 1)
      {
        *((_DWORD *)v5 + 6) = 0;
        *(_DWORD *)(a2 + 24) = 1;
        v9 = (uint64_t *)*v5;
        *(_QWORD *)(a2 + 8) = *v5;
        if (v9)
          v9[2] = a2;
        v10 = *(_QWORD *)(a2 + 16);
        v5[2] = v10;
        if (v10)
        {
          v11 = *(uint64_t ***)(a2 + 16);
          if ((uint64_t *)a2 == *v11)
          {
            *v11 = v5;
          }
          else
          {
            v11[1] = v5;
            v9 = *(uint64_t **)(a2 + 8);
          }
        }
        else
        {
          *result = (uint64_t)v5;
          v4 = (uint64_t **)v5;
        }
        *v5 = a2;
        *(_QWORD *)(a2 + 16) = v5;
        v5 = v9;
      }
      v14 = *v5;
      if (*v5 && *(_DWORD *)(v14 + 24))
      {
        v15 = v5[1];
        if (!v15)
          goto LABEL_56;
LABEL_37:
        if (*(_DWORD *)(v15 + 24))
        {
          *((_DWORD *)v5 + 6) = *(_DWORD *)(a2 + 24);
          *(_DWORD *)(a2 + 24) = 0;
          v17 = v4;
          goto LABEL_64;
        }
        if (v14)
LABEL_56:
          *(_DWORD *)(v14 + 24) = 0;
        *((_DWORD *)v5 + 6) = 1;
        v26 = *(_QWORD *)(v14 + 8);
        *v5 = v26;
        if (v26)
          *(_QWORD *)(v26 + 16) = v5;
        v27 = v5[2];
        *(_QWORD *)(v14 + 16) = v27;
        v28 = result;
        v17 = (uint64_t **)v14;
        if (v27)
        {
          v28 = (uint64_t *)v5[2];
          if (v5 != (uint64_t *)*v28)
            ++v28;
          v17 = v4;
        }
        *v28 = v14;
        *(_QWORD *)(v14 + 8) = v5;
        v5[2] = v14;
        v5 = a3[1];
        v15 = v5[1];
        *((_DWORD *)v5 + 6) = *((_DWORD *)a3 + 6);
        *((_DWORD *)a3 + 6) = 0;
        if (v15)
LABEL_64:
          *(_DWORD *)(v15 + 24) = 0;
        v29 = *v5;
        a3[1] = (uint64_t *)*v5;
        if (v29)
          *(_QWORD *)(v29 + 16) = a3;
        v30 = a3[2];
        v5[2] = (uint64_t)v30;
        v3 = (uint64_t **)v5;
        if (v30)
        {
          v31 = a3[2];
          v33 = (uint64_t **)*v31;
          v32 = v31 + 1;
          if (a3 == v33)
            result = a3[2];
          else
            result = v32;
          v3 = v17;
        }
        *result = (uint64_t)v5;
        *v5 = (uint64_t)a3;
        goto LABEL_73;
      }
      v15 = v5[1];
      if (v15 && *(_DWORD *)(v15 + 24))
        goto LABEL_37;
    }
    else
    {
      if (*((_DWORD *)v5 + 6) == 1)
      {
        *((_DWORD *)v5 + 6) = 0;
        *(_DWORD *)(a2 + 24) = 1;
        v6 = (uint64_t *)v5[1];
        *(_QWORD *)a2 = v6;
        if (v6)
          v6[2] = a2;
        v7 = *(_QWORD *)(a2 + 16);
        v5[2] = v7;
        if (v7)
        {
          v8 = *(uint64_t ***)(a2 + 16);
          if ((uint64_t *)a2 == *v8)
          {
            *v8 = v5;
            v6 = *(uint64_t **)a2;
          }
          else
          {
            v8[1] = v5;
          }
        }
        else
        {
          *result = (uint64_t)v5;
          v4 = (uint64_t **)v5;
        }
        v5[1] = a2;
        *(_QWORD *)(a2 + 16) = v5;
        v5 = v6;
      }
      v12 = *v5;
      if (*v5 && *(_DWORD *)(v12 + 24))
        goto LABEL_35;
      v13 = (uint64_t **)v5[1];
      if (v13 && *((_DWORD *)v13 + 6))
      {
        if (v12 && *(_DWORD *)(v12 + 24))
        {
LABEL_35:
          *((_DWORD *)v5 + 6) = *(_DWORD *)(a2 + 24);
          *(_DWORD *)(a2 + 24) = 0;
          v16 = v4;
          goto LABEL_46;
        }
        *((_DWORD *)v13 + 6) = 0;
        *((_DWORD *)v5 + 6) = 1;
        v18 = *v13;
        v5[1] = (uint64_t)*v13;
        if (v18)
          v18[2] = (uint64_t)v5;
        v19 = (uint64_t *)v5[2];
        v13[2] = v19;
        v20 = result;
        v16 = v13;
        if (v19)
        {
          v20 = (uint64_t *)v5[2];
          if (v5 != (uint64_t *)*v20)
            ++v20;
          v16 = v4;
        }
        *v20 = (uint64_t)v13;
        *v13 = v5;
        v5[2] = (uint64_t)v13;
        v5 = *a3;
        v12 = **a3;
        *((_DWORD *)*a3 + 6) = *((_DWORD *)a3 + 6);
        *((_DWORD *)a3 + 6) = 0;
        if (v12)
LABEL_46:
          *(_DWORD *)(v12 + 24) = 0;
        v21 = (uint64_t *)v5[1];
        *a3 = v21;
        if (v21)
          v21[2] = (uint64_t)a3;
        v22 = a3[2];
        v5[2] = (uint64_t)v22;
        v3 = (uint64_t **)v5;
        if (v22)
        {
          v23 = a3[2];
          v25 = (uint64_t **)*v23;
          v24 = v23 + 1;
          if (a3 == v25)
            result = a3[2];
          else
            result = v24;
          v3 = v16;
        }
        *result = (uint64_t)v5;
        v5[1] = (uint64_t)a3;
LABEL_73:
        a3[2] = v5;
LABEL_74:
        if (!v3)
          return result;
        break;
      }
    }
    *((_DWORD *)v5 + 6) = 1;
    a2 = *(_QWORD *)(a2 + 16);
  }
  *((_DWORD *)v3 + 6) = 0;
  return result;
}

uint64_t x509_issuer_tree_RB_REMOVE(uint64_t *a1, uint64_t a2)
{
  uint64_t *v3;
  uint64_t *v4;
  uint64_t *v5;
  _QWORD *v6;
  int v7;
  _QWORD *v8;
  uint64_t *v9;
  __int128 v10;
  _QWORD *v11;
  uint64_t *v12;
  uint64_t v13;
  int v15;
  _QWORD *v16;

  v4 = *(uint64_t **)a2;
  v3 = *(uint64_t **)(a2 + 8);
  if (!*(_QWORD *)a2)
  {
    v9 = *(uint64_t **)(a2 + 16);
    v15 = *(_DWORD *)(a2 + 24);
    if (!v3)
    {
      if (!v9)
      {
LABEL_26:
        v16 = a1;
        goto LABEL_27;
      }
LABEL_21:
      v16 = v9 + 1;
      if (*v9 == a2)
        v16 = v9;
LABEL_27:
      *v16 = v3;
      if (v15)
        return a2;
LABEL_28:
      x509_issuer_tree_RB_REMOVE_COLOR(a1, (uint64_t)v9, (uint64_t **)v3);
      return a2;
    }
LABEL_25:
    v3[2] = (uint64_t)v9;
    if (!v9)
      goto LABEL_26;
    goto LABEL_21;
  }
  if (!v3)
  {
    v9 = *(uint64_t **)(a2 + 16);
    v15 = *(_DWORD *)(a2 + 24);
    v3 = v4;
    goto LABEL_25;
  }
  do
  {
    v5 = v3;
    v3 = (uint64_t *)*v3;
  }
  while (v3);
  v3 = (uint64_t *)v5[1];
  v6 = (_QWORD *)v5[2];
  v7 = *((_DWORD *)v5 + 6);
  if (v3)
    v3[2] = (uint64_t)v6;
  v8 = a1;
  if (v6)
  {
    v8 = v6 + 1;
    if ((uint64_t *)*v6 == v5)
      v8 = v6;
  }
  *v8 = v3;
  if (v5[2] == a2)
    v9 = v5;
  else
    v9 = v6;
  v10 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)v5 = *(_OWORD *)a2;
  *((_OWORD *)v5 + 1) = v10;
  v11 = *(_QWORD **)(a2 + 16);
  v12 = a1;
  if (v11)
  {
    v12 = v11 + 1;
    if (*v11 == a2)
      v12 = *(uint64_t **)(a2 + 16);
  }
  *v12 = (uint64_t)v5;
  v13 = *(_QWORD *)(a2 + 8);
  *(_QWORD *)(*(_QWORD *)a2 + 16) = v5;
  if (v13)
    *(_QWORD *)(v13 + 16) = v5;
  if (!v7)
    goto LABEL_28;
  return a2;
}

uint64_t **x509_issuer_tree_RB_INSERT(uint64_t **a1, uint64_t a2)
{
  uint64_t *v4;
  uint64_t **v5;
  int v6;
  uint64_t **v7;
  _QWORD *v8;

  v4 = *a1;
  if (*a1)
  {
    do
    {
      v5 = (uint64_t **)v4;
      v6 = x509_issuer_cmp(a2, (uint64_t)v4);
      v7 = v5;
      if ((v6 & 0x80000000) == 0)
      {
        if (!v6)
          return v5;
        v7 = v5 + 1;
      }
      v4 = *v7;
    }
    while (v4);
    *(_QWORD *)(a2 + 8) = 0;
    *(_QWORD *)(a2 + 16) = v5;
    *(_QWORD *)a2 = 0;
    *(_DWORD *)(a2 + 24) = 1;
    v8 = v5 + 1;
    if (v6 < 0)
      v8 = v5;
  }
  else
  {
    *(_QWORD *)a2 = 0;
    *(_QWORD *)(a2 + 8) = 0;
    *(_QWORD *)(a2 + 16) = 0;
    *(_DWORD *)(a2 + 24) = 1;
    v8 = a1;
  }
  *v8 = a2;
  x509_issuer_tree_RB_INSERT_COLOR(a1, (uint64_t *)a2);
  return 0;
}

uint64_t x509_issuer_cmp(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  result = memcmp(*(const void **)(a1 + 48), *(const void **)(a2 + 48), 0x40uLL);
  if (!(_DWORD)result)
    return memcmp(*(const void **)(a1 + 56), *(const void **)(a2 + 56), 0x40uLL);
  return result;
}

_QWORD *x509_issuer_tree_RB_FIND(_QWORD **a1, uint64_t a2)
{
  _QWORD *i;
  int v4;

  for (i = *a1; i; i = (_QWORD *)*i)
  {
    v4 = x509_issuer_cmp(a2, (uint64_t)i);
    if ((v4 & 0x80000000) == 0)
    {
      if (!v4)
        return i;
      ++i;
    }
  }
  return i;
}

_QWORD *x509_issuer_tree_RB_NFIND(_QWORD **a1, uint64_t a2)
{
  _QWORD *v2;
  _QWORD *v4;
  int v5;

  v2 = *a1;
  if (*a1)
  {
    v4 = 0;
    while (1)
    {
      v5 = x509_issuer_cmp(a2, (uint64_t)v2);
      if (v5 < 0)
      {
        v4 = v2;
      }
      else
      {
        if (!v5)
          return v2;
        ++v2;
      }
      v2 = (_QWORD *)*v2;
      if (!v2)
        return v4;
    }
  }
  return 0;
}

_QWORD *x509_issuer_tree_RB_NEXT(uint64_t a1)
{
  _QWORD *v1;
  _QWORD *result;
  uint64_t v3;
  BOOL v4;

  v1 = *(_QWORD **)(a1 + 8);
  if (v1)
  {
    do
    {
      result = v1;
      v1 = (_QWORD *)*v1;
    }
    while (v1);
  }
  else
  {
    v3 = a1;
    result = *(_QWORD **)(a1 + 16);
    if (!result || *result != v3)
    {
      do
      {
        result = *(_QWORD **)(v3 + 16);
        if (!result)
          break;
        v4 = v3 == result[1];
        v3 = *(_QWORD *)(v3 + 16);
      }
      while (v4);
    }
  }
  return result;
}

_QWORD *x509_issuer_tree_RB_PREV(_QWORD *a1)
{
  _QWORD *v1;
  _QWORD *result;
  _QWORD *v3;
  BOOL v4;

  v1 = (_QWORD *)*a1;
  if (*a1)
  {
    do
    {
      result = v1;
      v1 = (_QWORD *)v1[1];
    }
    while (v1);
  }
  else
  {
    v3 = a1;
    result = (_QWORD *)a1[2];
    if (!result || (_QWORD *)result[1] != v3)
    {
      do
      {
        result = (_QWORD *)v3[2];
        if (!result)
          break;
        v4 = v3 == (_QWORD *)*result;
        v3 = (_QWORD *)v3[2];
      }
      while (v4);
    }
  }
  return result;
}

_QWORD *x509_issuer_tree_RB_MINMAX(_QWORD *a1, int a2)
{
  _QWORD *v2;
  _QWORD *result;
  _QWORD *v4;

  v2 = (_QWORD *)*a1;
  if (!*a1)
    return 0;
  do
  {
    result = v2;
    v4 = v2 + 1;
    if (a2 < 0)
      v4 = result;
    v2 = (_QWORD *)*v4;
  }
  while (v2);
  return result;
}

uint64_t x509_issuer_cache_set_max(uint64_t a1)
{
  if (pthread_mutex_lock(&x509_issuer_tree_mutex))
    return 0;
  x509_issuer_cache_max = a1;
  pthread_mutex_unlock(&x509_issuer_tree_mutex);
  return 1;
}

void x509_issuer_cache_free_oldest()
{
  uint64_t v0;
  uint64_t v1;
  _QWORD *v2;

  if (x509_issuer_cache_count)
  {
    v0 = *(_QWORD *)off_255D83B18[1];
    v1 = *(_QWORD *)(v0 + 32);
    v2 = *(_QWORD **)(v0 + 40);
    if (v1)
    {
      *(_QWORD *)(v1 + 40) = v2;
      v2 = *(_QWORD **)(v0 + 40);
    }
    else
    {
      off_255D83B18 = *(_UNKNOWN ***)(v0 + 40);
    }
    *v2 = v1;
    x509_issuer_tree_RB_REMOVE((uint64_t *)&x509_issuer_cache, v0);
    free(*(void **)(v0 + 48));
    free(*(void **)(v0 + 56));
    free((void *)v0);
    --x509_issuer_cache_count;
  }
}

uint64_t x509_issuer_cache_free()
{
  uint64_t result;

  result = pthread_mutex_lock(&x509_issuer_tree_mutex);
  if (!(_DWORD)result)
  {
    while (x509_issuer_cache_count)
      x509_issuer_cache_free_oldest();
    return pthread_mutex_unlock(&x509_issuer_tree_mutex);
  }
  return result;
}

uint64_t x509_issuer_cache_find(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _QWORD *v3;
  uint64_t v4;
  _QWORD *v5;
  char *v6;
  _QWORD *v7;
  BOOL v8;
  _QWORD *v9;
  _OWORD v11[3];
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;

  memset(v11, 0, sizeof(v11));
  v12 = a1;
  v13 = a2;
  v14 = 0;
  if (!x509_issuer_cache_max || pthread_mutex_lock(&x509_issuer_tree_mutex))
    return 0xFFFFFFFFLL;
  v3 = x509_issuer_tree_RB_FIND(&x509_issuer_cache, (uint64_t)v11);
  if (v3)
  {
    v4 = v3[4];
    v5 = (_QWORD *)v3[5];
    if (v4)
    {
      *(_QWORD *)(v4 + 40) = v5;
      v5 = (_QWORD *)v3[5];
    }
    else
    {
      off_255D83B18 = (_UNKNOWN **)v3[5];
    }
    *v5 = v4;
    v6 = (char *)x509_issuer_lru;
    v3[4] = x509_issuer_lru;
    v7 = v6 + 40;
    v8 = v6 == 0;
    x509_issuer_lru = v3;
    v9 = &off_255D83B18;
    if (!v8)
      v9 = v7;
    *v9 = v3 + 4;
    v3[5] = &x509_issuer_lru;
    v2 = *((unsigned int *)v3 + 16);
  }
  else
  {
    v2 = 0xFFFFFFFFLL;
  }
  pthread_mutex_unlock(&x509_issuer_tree_mutex);
  return v2;
}

void x509_issuer_cache_add(__int128 *a1, __int128 *a2, unsigned int a3)
{
  void *v6;
  uint64_t v7;
  _OWORD *v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  _OWORD *v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  uint64_t v16;
  char *v17;
  _QWORD *v18;

  if (a3 <= 1)
  {
    if (x509_issuer_cache_max)
    {
      v6 = malloc_type_calloc(1uLL, 0x48uLL, 0x10B004061D455DBuLL);
      if (v6)
      {
        v7 = (uint64_t)v6;
        v8 = malloc_type_calloc(1uLL, 0x40uLL, 0x5D37DD96uLL);
        *(_QWORD *)(v7 + 48) = v8;
        if (v8)
        {
          v9 = *a1;
          v10 = a1[1];
          v11 = a1[3];
          v8[2] = a1[2];
          v8[3] = v11;
          *v8 = v9;
          v8[1] = v10;
          v12 = malloc_type_calloc(1uLL, 0x40uLL, 0xE84DAE18uLL);
          *(_QWORD *)(v7 + 56) = v12;
          if (v12)
          {
            v13 = *a2;
            v14 = a2[1];
            v15 = a2[3];
            v12[2] = a2[2];
            v12[3] = v15;
            *v12 = v13;
            v12[1] = v14;
            *(_DWORD *)(v7 + 64) = a3;
            if (!pthread_mutex_lock(&x509_issuer_tree_mutex))
            {
              while (1)
              {
                v16 = x509_issuer_cache_count;
                if (x509_issuer_cache_count < (unint64_t)x509_issuer_cache_max)
                  break;
                x509_issuer_cache_free_oldest();
              }
              if (!x509_issuer_tree_RB_INSERT(&x509_issuer_cache, v7))
              {
                v17 = (char *)x509_issuer_lru;
                *(_QWORD *)(v7 + 32) = x509_issuer_lru;
                x509_issuer_lru = (_UNKNOWN *)v7;
                if (v17)
                  v18 = v17 + 40;
                else
                  v18 = &off_255D83B18;
                *v18 = v7 + 32;
                *(_QWORD *)(v7 + 40) = &x509_issuer_lru;
                x509_issuer_cache_count = v16 + 1;
                pthread_mutex_unlock(&x509_issuer_tree_mutex);
                v7 = 0;
                goto LABEL_13;
              }
              pthread_mutex_unlock(&x509_issuer_tree_mutex);
            }
          }
        }
        free(*(void **)(v7 + 48));
        free(*(void **)(v7 + 56));
LABEL_13:
        free((void *)v7);
      }
    }
  }
}

void ENGINE_add_conf_module(void)
{
  CONF_module_add("engines", (conf_init_func *)int_engine_module_init, (conf_finish_func *)int_engine_module_finish);
}

uint64_t int_engine_module_init(const CONF_IMODULE *a1, const CONF *a2)
{
  const char *value;
  STACK *section;
  const STACK *v5;
  int v6;
  char *v7;
  char *v8;
  const char *v9;
  char *v10;
  STACK *v11;
  const STACK *v12;
  ENGINE *v13;
  int v14;
  const char *v15;
  char *v16;
  char *v17;
  char *v18;
  const char *v19;
  ENGINE *v20;
  int v21;
  ENGINE *v22;
  int v23;
  int v24;
  const STACK *v26;
  CONF *conf;
  int v28;
  int v29;
  uint64_t result;

  value = CONF_imodule_get_value(a1);
  section = NCONF_get_section(a2, value);
  if (!section)
  {
    v23 = 148;
    v24 = 223;
    goto LABEL_50;
  }
  v5 = section;
  if (sk_num(section) < 1)
    return 1;
  v6 = 0;
  v26 = v5;
  conf = (CONF *)a2;
LABEL_4:
  v7 = sk_value(v5, v6);
  v8 = (char *)*((_QWORD *)v7 + 1);
  v9 = (const char *)*((_QWORD *)v7 + 2);
  result = -1;
  v10 = strchr(v8, 46);
  v11 = NCONF_get_section(a2, v9);
  if (v11)
  {
    v12 = v11;
    v28 = v6;
    if (sk_num(v11) < 1)
    {
      v13 = 0;
      goto LABEL_45;
    }
    v29 = 0;
    v13 = 0;
    v14 = 0;
    if (v10)
      v15 = v10 + 1;
    else
      v15 = v8;
    while (1)
    {
      v16 = sk_value(v12, v14);
      v17 = (char *)*((_QWORD *)v16 + 1);
      v18 = strchr(v17, 46);
      if (v18)
        v17 = v18 + 1;
      v19 = (const char *)*((_QWORD *)v16 + 2);
      if (!strcmp(v17, "engine_id"))
      {
        v15 = v19;
      }
      else if (!strcmp(v17, "soft_load"))
      {
        v29 = 1;
      }
      else
      {
        if (!strcmp(v17, "dynamic_path"))
        {
          v22 = ENGINE_by_id("dynamic");
          v13 = v22;
          if (!v22
            || !ENGINE_ctrl_cmd_string(v22, "SO_PATH", v19, 0)
            || !ENGINE_ctrl_cmd_string(v13, "LIST_ADD", "2", 0)
            || !ENGINE_ctrl_cmd_string(v13, "LOAD", 0, 0))
          {
            goto LABEL_54;
          }
          goto LABEL_36;
        }
        if (!v13)
        {
          v20 = ENGINE_by_id(v15);
          v13 = v20;
          if (!v20 && v29)
          {
            ERR_clear_error();
            v5 = v26;
            a2 = conf;
            goto LABEL_46;
          }
          if (!v20)
            goto LABEL_54;
        }
        if (!strcmp(v19, "EMPTY"))
          v19 = 0;
        if (strcmp(v17, "init"))
        {
          if (!strcmp(v17, "default_algorithms"))
            v21 = ENGINE_set_default_string(v13, v19);
          else
            v21 = ENGINE_ctrl_cmd_string(v13, v17, v19, 0);
LABEL_35:
          if (!v21)
            goto LABEL_54;
          goto LABEL_36;
        }
        if (!NCONF_get_number_e(conf, v9, "init", &result))
          goto LABEL_54;
        if (result)
        {
          if (result != 1)
          {
            ERR_put_error(38, 4095, 151, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/engine/eng_cnf.c", 177);
LABEL_54:
            ERR_put_error(38, 4095, 102, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/engine/eng_cnf.c", 197);
            ERR_asprintf_error_data("section=%s, name=%s, value=%s", *(const char **)v16, *((const char **)v16 + 1), *((const char **)v16 + 2));
LABEL_55:
            ENGINE_free(v13);
            return 0;
          }
          v21 = int_engine_init(v13);
          goto LABEL_35;
        }
      }
LABEL_36:
      if (++v14 >= sk_num(v12))
      {
        if (!v13)
        {
          v5 = v26;
          a2 = conf;
          goto LABEL_45;
        }
        v5 = v26;
        a2 = conf;
        if (result == -1 && !int_engine_init(v13))
        {
          ERR_put_error(38, 4095, 102, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/engine/eng_cnf.c", 197);
          goto LABEL_55;
        }
LABEL_45:
        ENGINE_free(v13);
LABEL_46:
        ++v6;
        if (v28 + 1 >= sk_num(v5))
          return 1;
        goto LABEL_4;
      }
    }
  }
  v23 = 149;
  v24 = 118;
LABEL_50:
  ERR_put_error(38, 4095, v23, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/engine/eng_cnf.c", v24);
  return 0;
}

void int_engine_module_finish()
{
  char *v0;

  while (1)
  {
    v0 = sk_pop((STACK *)initialized_engines);
    if (!v0)
      break;
    ENGINE_finish((ENGINE *)v0);
  }
  sk_free((STACK *)initialized_engines);
  initialized_engines = 0;
}

uint64_t int_engine_init(ENGINE *a1)
{
  uint64_t result;
  STACK *v3;

  result = ENGINE_init(a1);
  if ((_DWORD)result)
  {
    v3 = (STACK *)initialized_engines;
    if ((initialized_engines || (v3 = sk_new_null(), (initialized_engines = (uint64_t)v3) != 0))
      && sk_push(v3, (char *)a1))
    {
      return 1;
    }
    else
    {
      ENGINE_finish(a1);
      return 0;
    }
  }
  return result;
}

ASN1_VALUE *__cdecl ASN1_item_d2i(ASN1_VALUE **val, const unsigned __int8 **in, uint64_t len, const ASN1_ITEM *it)
{
  ASN1_TLC *v4;
  ASN1_VALUE **v5;
  uint64_t v7;

  v7 = 0;
  if (val)
    v5 = val;
  else
    v5 = (ASN1_VALUE **)&v7;
  if (ASN1_item_ex_d2i(v5, in, len, it, -1, 0, 0, v4) < 1)
    return 0;
  else
    return *v5;
}

int ASN1_item_ex_d2i(ASN1_VALUE **pval, const unsigned __int8 **in, uint64_t len, const ASN1_ITEM *it, int tag, int aclass, char opt, ASN1_TLC *ctx)
{
  int v8;
  uint64_t v9;
  uint64_t v10;
  int result;
  uint64_t v15[3];

  if (len < 0)
    return 0;
  v8 = opt;
  v9 = *(_QWORD *)&aclass;
  v10 = *(_QWORD *)&tag;
  memset(v15, 0, sizeof(v15));
  CBS_init(v15, (uint64_t)*in, len);
  result = asn1_item_d2i((uint64_t)pval, v15, (ASN1_ITEM *)it, v10, v9, v8, 0);
  if (result == 1)
  {
    *in = (const unsigned __int8 *)CBS_data((uint64_t)v15);
    return 1;
  }
  return result;
}

uint64_t asn1_item_d2i(uint64_t pval, uint64_t *a2, ASN1_ITEM *it, uint64_t a4, uint64_t a5, int a6, int a7)
{
  ASN1_TYPE **v8;
  int v9;
  int v10;
  ASN1_VALUE **v11;
  uint64_t v16;
  uint64_t v17;
  _QWORD *funcs;
  unsigned int (*v19)(uint64_t, ASN1_VALUE **, ASN1_ITEM *, _QWORD);
  const ASN1_TEMPLATE *templates;
  int v21;
  _QWORD *v22;
  unsigned int (*v23)(uint64_t, ASN1_VALUE **, ASN1_ITEM *, _QWORD);
  _QWORD *v24;
  uint64_t (*v25)(ASN1_TYPE **, unsigned __int16 **, uint64_t, ASN1_ITEM *, uint64_t, uint64_t, _QWORD, ASN1_VALUE **);
  uint64_t v26;
  unsigned __int16 *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  int v31;
  int v32;
  int itype;
  int v34;
  int v35;
  int v36;
  uint64_t v37;
  uint64_t v38;
  int v39;
  int v40;
  int v41;
  int v42;
  uint64_t tcount;
  uint64_t v44;
  uint64_t v45;
  const ASN1_TEMPLATE *v46;
  ASN1_VALUE **v47;
  int v48;
  uint64_t v49;
  uint64_t v50;
  const ASN1_TEMPLATE *v51;
  const ASN1_TEMPLATE *v52;
  const ASN1_TEMPLATE *v53;
  ASN1_VALUE **field_ptr;
  ASN1_VALUE **v55;
  int v56;
  int v57;
  ASN1_VALUE *v58;
  unint64_t v59;
  uint64_t v60;
  uint64_t v61;
  const ASN1_TEMPLATE *v62;
  const ASN1_TEMPLATE *v63;
  ASN1_VALUE **v64;
  unint64_t v65;
  const ASN1_ITEM *v66;
  ASN1_VALUE *pvala[2];
  __int128 v68;
  int tag[2];
  ASN1_VALUE *v70;
  uint64_t v71;
  unsigned __int8 in[8];
  uint64_t v73;
  uint64_t v74;
  unsigned __int16 *v75[3];

  if (!pval)
    return pval;
  v8 = (ASN1_TYPE **)pval;
  if (a7 >= 30)
  {
    v9 = 219;
    v10 = 948;
LABEL_4:
    ERR_put_error(13, 4095, v9, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/tasn_dec.c", v10);
LABEL_5:
    v11 = (ASN1_VALUE **)v8;
LABEL_6:
    ASN1_item_ex_free(v11, it);
LABEL_7:
    ERR_asprintf_error_data("Type=%s");
    return 0;
  }
  pval = 0;
  switch(it->itype)
  {
    case 0:
      templates = it->templates;
      if (!templates)
        return asn1_d2i_primitive(v8, (uint64_t)a2, (uint64_t)it, a4, a5, a6);
      if ((_DWORD)a4 != -1 || a6)
      {
        v9 = 170;
        v10 = 963;
        goto LABEL_4;
      }
      return asn1_template_d2i((uint64_t)v8, a2, (uint64_t)templates, 0);
    case 1:
    case 6:
      pvala[0] = 0;
      pvala[1] = 0;
      *(_QWORD *)&v68 = 0;
      memset(v75, 0, sizeof(v75));
      *(_QWORD *)in = 0;
      v73 = 0;
      v74 = 0;
      v70 = 0;
      v71 = 0;
      *(_QWORD *)tag = 0;
      v16 = CBS_data((uint64_t)a2);
      v17 = CBS_len((uint64_t)a2);
      CBS_init(pvala, v16, v17);
      funcs = it->funcs;
      if (funcs)
        v19 = (unsigned int (*)(uint64_t, ASN1_VALUE **, ASN1_ITEM *, _QWORD))funcs[3];
      else
        v19 = 0;
      itype = it->itype;
      if (itype != 6 && itype != 1)
        goto LABEL_133;
      if (*v8)
      {
        ASN1_item_ex_free((ASN1_VALUE **)v8, it);
        *v8 = 0;
      }
      if ((_DWORD)a4 == -1)
        v34 = 0;
      else
        v34 = a5;
      if ((_DWORD)a4 == -1)
        v35 = 16;
      else
        v35 = a4;
      pval = asn1_check_tag(pvala, tag, 0, 0, &v71, (_DWORD *)&v71 + 1, v35, v34, a6);
      if ((_DWORD)pval == -1)
        return pval;
      if ((_DWORD)pval != 1)
      {
        v39 = 58;
        v40 = 777;
        goto LABEL_132;
      }
      if (!HIDWORD(v71))
      {
        v39 = 149;
        v40 = 782;
        goto LABEL_132;
      }
      v36 = v71;
      if ((_DWORD)v71)
      {
        v37 = CBS_data((uint64_t)pvala);
        v38 = CBS_len((uint64_t)pvala);
        CBS_init(v75, v37, v38);
      }
      else if (!CBS_get_bytes((uint64_t *)pvala, v75, *(unint64_t *)tag))
      {
        goto LABEL_133;
      }
      if (!ASN1_item_ex_new(&v70, it))
      {
        v39 = 58;
        v40 = 796;
        goto LABEL_132;
      }
      if (v19 && !v19(4, &v70, it, 0))
      {
        v39 = 100;
        v40 = 801;
        goto LABEL_132;
      }
      if (it->tcount < 1)
      {
        LODWORD(v50) = 0;
LABEL_89:
        if (v36 && !asn1_check_eoc(v75))
        {
          v39 = 137;
          v40 = 848;
          goto LABEL_132;
        }
        if (!(_DWORD)v71)
        {
          if (CBS_len((uint64_t)v75))
          {
            v39 = 148;
            v40 = 856;
            goto LABEL_132;
          }
          goto LABEL_112;
        }
      }
      else
      {
        v49 = 0;
        v50 = 0;
        while (1)
        {
          v51 = it->templates;
          if (asn1_check_eoc(v75))
            break;
          if (!CBS_len((uint64_t)v75))
            goto LABEL_89;
          v52 = asn1_do_adb(&v70, &v51[v49], 1);
          if (!v52)
            goto LABEL_133;
          v53 = v52;
          field_ptr = asn1_get_field_ptr(&v70, v52);
          v55 = field_ptr;
          if (v50 == it->tcount - 1)
            v56 = 0;
          else
            v56 = v53->flags & 1;
          v57 = asn1_template_d2i((uint64_t)field_ptr, v75, (uint64_t)v53, v56);
          if (v57 != 1)
          {
            if (v57 != -1)
              goto LABEL_128;
            ASN1_template_free(v55, v53);
          }
          ++v50;
          ++v49;
          if (it->tcount <= v50)
            goto LABEL_89;
        }
        if (!(_DWORD)v71)
        {
          v39 = 159;
          v40 = 810;
          goto LABEL_132;
        }
      }
      v59 = CBS_offset((uint64_t)v75);
      if (!CBS_skip(pvala, v59))
        goto LABEL_133;
LABEL_112:
      if (it->tcount > v50)
      {
        v60 = v50;
        v61 = v50;
        while (1)
        {
          v62 = asn1_do_adb(&v70, &it->templates[v61], 1);
          if (!v62)
            goto LABEL_133;
          v63 = v62;
          if ((v62->flags & 1) == 0)
            break;
          v64 = asn1_get_field_ptr(&v70, v62);
          ASN1_template_free(v64, v63);
          ++v60;
          ++v61;
          if (it->tcount <= v60)
            goto LABEL_117;
        }
        ERR_put_error(13, 4095, 121, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/tasn_dec.c", 871);
LABEL_128:
        ASN1_item_ex_free(&v70, it);
        goto LABEL_129;
      }
LABEL_117:
      v65 = CBS_offset((uint64_t)pvala);
      if (!CBS_get_bytes(a2, in, v65))
      {
LABEL_133:
        v11 = &v70;
        goto LABEL_6;
      }
      if (asn1_enc_save(&v70, in, (int)it, v66))
      {
        if (!v19 || v19(5, &v70, it, 0))
        {
          v58 = v70;
          goto LABEL_122;
        }
        v39 = 100;
        v40 = 890;
      }
      else
      {
        v39 = 65;
        v40 = 885;
      }
LABEL_132:
      ERR_put_error(13, 4095, v39, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/tasn_dec.c", v40);
      goto LABEL_133;
    case 2:
      v21 = it->itype;
      pvala[0] = 0;
      v22 = it->funcs;
      if (v22)
        v23 = (unsigned int (*)(uint64_t, ASN1_VALUE **, ASN1_ITEM *, _QWORD))v22[3];
      else
        v23 = 0;
      if (v21 != 2)
        goto LABEL_48;
      if ((_DWORD)a4 != -1)
      {
        v41 = 230;
        v42 = 663;
        goto LABEL_47;
      }
      if (*v8)
      {
        ASN1_item_ex_free((ASN1_VALUE **)v8, it);
        *v8 = 0;
      }
      if (!ASN1_item_ex_new(pvala, it))
      {
        v41 = 58;
        v42 = 673;
        goto LABEL_47;
      }
      if (v23 && !v23(4, pvala, it, 0))
      {
        v41 = 100;
        v42 = 678;
        goto LABEL_47;
      }
      tcount = it->tcount;
      if (tcount < 1)
      {
        v44 = 0;
      }
      else
      {
        v44 = 0;
        v45 = 24;
        while (1)
        {
          v46 = it->templates;
          v47 = asn1_get_field_ptr(pvala, (const ASN1_TEMPLATE *)((char *)v46 + v45 - 24));
          v48 = asn1_template_d2i((uint64_t)v47, a2, (uint64_t)v46 + v45 - 24, 1);
          if (v48 != -1)
            break;
          ++v44;
          tcount = it->tcount;
          v45 += 40;
          if (tcount <= v44)
            goto LABEL_98;
        }
        if (v48 != 1)
        {
          ERR_put_error(13, 4095, 58, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/tasn_dec.c", 693);
          ASN1_item_ex_free(pvala, it);
          if (!v46)
            goto LABEL_7;
LABEL_129:
          ERR_asprintf_error_data("Field=%s, Type=%s");
          return 0;
        }
        asn1_set_choice_selector(pvala, v44, it);
        tcount = it->tcount;
      }
LABEL_98:
      if (tcount == v44)
      {
        if (a6)
        {
          ASN1_item_ex_free(pvala, it);
          return 0xFFFFFFFFLL;
        }
        v41 = 143;
        v42 = 709;
        goto LABEL_47;
      }
      if (v23 && !v23(5, pvala, it, 0))
      {
        v41 = 100;
        v42 = 714;
LABEL_47:
        ERR_put_error(13, 4095, v41, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/tasn_dec.c", v42);
LABEL_48:
        v11 = pvala;
        goto LABEL_6;
      }
      v58 = pvala[0];
LABEL_122:
      *v8 = (ASN1_TYPE *)v58;
      return 1;
    case 4:
      v24 = it->funcs;
      *(_OWORD *)pvala = 0u;
      v68 = 0u;
      if (CBS_len((uint64_t)a2) < 0)
        return 0;
      v75[0] = (unsigned __int16 *)CBS_data((uint64_t)a2);
      v25 = (uint64_t (*)(ASN1_TYPE **, unsigned __int16 **, uint64_t, ASN1_ITEM *, uint64_t, uint64_t, _QWORD, ASN1_VALUE **))v24[4];
      v26 = CBS_len((uint64_t)a2);
      pval = v25(v8, v75, v26, it, a4, a5, (char)a6, pvala);
      if ((_DWORD)pval != 1)
        return pval;
      v27 = v75[0];
      v28 = CBS_data((uint64_t)a2);
      if (CBS_skip(a2, (unint64_t)v27 - v28))
        return 1;
      goto LABEL_5;
    case 5:
      *(_DWORD *)in = 0;
      LODWORD(v70) = 0;
      BYTE4(v71) = 0;
      tag[0] = 0;
      pvala[0] = 0;
      pvala[1] = 0;
      *(_QWORD *)&v68 = 0;
      v75[0] = 0;
      v29 = CBS_data((uint64_t)a2);
      v30 = CBS_len((uint64_t)a2);
      CBS_init(pvala, v29, v30);
      if ((_DWORD)a4 != -1)
      {
        v31 = 230;
        v32 = 576;
LABEL_65:
        ERR_put_error(13, 4095, v31, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/tasn_dec.c", v32);
        return 0;
      }
      if (asn1_check_tag(pvala, v75, tag, (_BYTE *)&v71 + 4, &v70, in, -1, 0, 1) != 1)
      {
        v31 = 58;
        v32 = 582;
        goto LABEL_65;
      }
      if (BYTE4(v71))
      {
        if (!a6)
        {
          v31 = 139;
          v32 = 590;
          goto LABEL_65;
        }
      }
      else
      {
        if ((it->utype & ASN1_tag2bit(tag[0])) != 0)
          return asn1_d2i_primitive_content(v8, a2, (unsigned __int16 **)pvala, tag[0], *(int *)in, v70, (unint64_t)v75[0], (uint64_t)it);
        if (!a6)
        {
          v31 = 140;
          v32 = 597;
          goto LABEL_65;
        }
      }
      return 0xFFFFFFFFLL;
    default:
      return pval;
  }
}

int ASN1_template_d2i(ASN1_VALUE **pval, const unsigned __int8 **in, uint64_t len, const ASN1_TEMPLATE *tt)
{
  int result;
  _QWORD v8[3];

  if (len < 0)
    return 0;
  memset(v8, 0, sizeof(v8));
  CBS_init(v8, (uint64_t)*in, len);
  result = asn1_template_d2i((uint64_t)pval, v8, (uint64_t)tt, 0);
  if (result == 1)
  {
    *in = (const unsigned __int8 *)CBS_data((uint64_t)v8);
    return 1;
  }
  return result;
}

uint64_t asn1_template_d2i(uint64_t result, _QWORD *a2, uint64_t a3, int a4)
{
  ASN1_VALUE **v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  int v13;
  unint64_t v14;
  int v15;
  int v16;
  unint64_t v17;
  unint64_t v18;
  uint64_t v19;
  unsigned __int16 *v20[3];
  uint64_t v21[3];

  if (result)
  {
    v7 = (ASN1_VALUE **)result;
    if ((*(_BYTE *)a3 & 0x10) == 0)
      return asn1_template_noexp_d2i((ASN1_VALUE **)result, a2, a3, a4);
    memset(v21, 0, sizeof(v21));
    v19 = 0;
    memset(v20, 0, sizeof(v20));
    v18 = 0;
    v8 = CBS_data((uint64_t)a2);
    v9 = CBS_len((uint64_t)a2);
    CBS_init(v21, v8, v9);
    result = asn1_check_tag(v21, &v18, 0, 0, &v19, (_DWORD *)&v19 + 1, *(_DWORD *)(a3 + 8), *(_DWORD *)a3 & 0xC0, a4);
    if ((_DWORD)result != -1)
    {
      if ((_DWORD)result == 1)
      {
        if (HIDWORD(v19))
        {
          if ((_DWORD)v19)
          {
            v10 = CBS_data((uint64_t)v21);
            v11 = CBS_len((uint64_t)v21);
            CBS_init(v20, v10, v11);
          }
          else if (!CBS_get_bytes(v21, v20, v18))
          {
            goto LABEL_27;
          }
          if (asn1_template_noexp_d2i(v7, v20, a3, 0) == 1)
          {
            if ((_DWORD)v19)
            {
              if (asn1_check_eoc(v20))
              {
                v14 = CBS_offset((uint64_t)v20);
                if (!CBS_skip(v21, v14))
                  goto LABEL_27;
LABEL_23:
                v17 = CBS_offset((uint64_t)v21);
                if (CBS_skip(a2, v17))
                  return 1;
                goto LABEL_27;
              }
              v15 = 137;
              v16 = 1207;
            }
            else
            {
              if (!CBS_len((uint64_t)v20))
                goto LABEL_23;
              v15 = 148;
              v16 = 1213;
            }
            ERR_put_error(13, 4095, v15, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/tasn_dec.c", v16);
LABEL_27:
            ASN1_template_free(v7, (const ASN1_TEMPLATE *)a3);
            return 0;
          }
          v12 = 58;
          v13 = 1201;
        }
        else
        {
          v12 = 120;
          v13 = 1188;
        }
      }
      else
      {
        v12 = 58;
        v13 = 1183;
      }
      ERR_put_error(13, 4095, v12, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/tasn_dec.c", v13);
      return 0;
    }
  }
  return result;
}

uint64_t asn1_d2i_primitive(ASN1_TYPE **a1, uint64_t a2, uint64_t a3, int a4, int a5, int a6)
{
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t result;
  uint64_t v16;
  uint64_t v17;
  int v18;
  int v19;
  int v20;
  int v21;
  int v22;
  unsigned int v23;
  unint64_t v24;
  unsigned __int16 **v25;
  ASN1_TYPE **v26;
  _QWORD *v27;
  uint64_t v28;
  unint64_t v29;
  uint64_t v30;
  _QWORD v31[3];
  unint64_t v32;
  _QWORD v33[3];
  unsigned int v34;
  char v35;
  uint64_t v36;

  memset(v31, 0, sizeof(v31));
  v29 = 0;
  v30 = 0;
  v12 = *(unsigned int *)(a3 + 8);
  v13 = CBS_data(a2);
  v14 = CBS_len(a2);
  CBS_init(v31, v13, v14);
  result = 0;
  if (*(_BYTE *)a3 != 5)
  {
    if (*(_QWORD *)(a3 + 8) == -4)
    {
      v36 = 0;
      v35 = 0;
      v34 = 0;
      memset(v33, 0, sizeof(v33));
      v32 = 0;
      v16 = CBS_data(a2);
      v17 = CBS_len(a2);
      CBS_init(v33, v16, v17);
      result = 0;
      if (*(_QWORD *)(a3 + 8) != -4)
        return result;
      if ((a4 & 0x80000000) == 0)
      {
        v18 = 127;
        v19 = 538;
LABEL_23:
        ERR_put_error(13, 4095, v18, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/tasn_dec.c", v19);
        return 0;
      }
      if (a6)
      {
        v18 = 126;
        v19 = 542;
        goto LABEL_23;
      }
      if (asn1_check_tag(v33, &v32, &v34, &v35, &v36, (_DWORD *)&v36 + 1, -1, 0, 0) != 1)
      {
        v18 = 58;
        v19 = 549;
        goto LABEL_23;
      }
      if (v35)
      {
        v28 = 4294967293;
        v34 = -3;
      }
      else
      {
        v28 = v34;
      }
      v23 = v36;
      v22 = HIDWORD(v36);
      v24 = v32;
      v25 = (unsigned __int16 **)v33;
      v26 = a1;
      v27 = (_QWORD *)a2;
      return asn1_d2i_primitive_content(v26, v27, v25, v28, v22, v23, v24, a3);
    }
    if (a4 == -1)
      v20 = *(_QWORD *)(a3 + 8);
    else
      v20 = a4;
    if (a4 == -1)
      v21 = 0;
    else
      v21 = a5;
    result = asn1_check_tag(v31, &v29, 0, 0, &v30, (_DWORD *)&v30 + 1, v20, v21, a6);
    if ((_DWORD)result != -1)
    {
      if ((_DWORD)result != 1)
      {
        v18 = 58;
        v19 = 633;
        goto LABEL_23;
      }
      v23 = v30;
      v22 = HIDWORD(v30);
      v24 = v29;
      v25 = (unsigned __int16 **)v31;
      v26 = a1;
      v27 = (_QWORD *)a2;
      v28 = v12;
      return asn1_d2i_primitive_content(v26, v27, v25, v28, v22, v23, v24, a3);
    }
  }
  return result;
}

uint64_t asn1_check_tag(_QWORD *a1, _QWORD *a2, _DWORD *a3, _BYTE *a4, _DWORD *a5, _DWORD *a6, int a7, int a8, int a9)
{
  int v17;
  int v18;
  unint64_t v20;
  unint64_t v21;
  unsigned __int8 v22;
  int v23;
  uint64_t v24;

  if (a2)
    *a2 = 0;
  if (a3)
    *a3 = 0;
  if (a4)
    *a4 = 0;
  if (a5)
    *a5 = 0;
  if (a6)
    *a6 = 0;
  v24 = 0;
  v23 = 0;
  v22 = 0;
  v21 = 0;
  if (!asn1_get_identifier_cbs(a1, 0, &v22, (int *)&v24 + 1, &v23))
  {
    v17 = 102;
    v18 = 127;
    goto LABEL_42;
  }
  if ((a7 & 0x80000000) == 0 && (v23 != a7 || a8 != v22 << 6))
  {
    if (a9)
      return 0xFFFFFFFFLL;
    v17 = 168;
    v18 = 137;
    goto LABEL_42;
  }
  if (!asn1_get_length_cbs(a1, 0, &v24, &v21))
  {
    v17 = 102;
    v18 = 142;
    goto LABEL_42;
  }
  if ((_DWORD)v24 && !HIDWORD(v24))
  {
    v17 = 102;
    v18 = 148;
LABEL_42:
    ERR_put_error(13, 4095, v17, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/tasn_dec.c", v18);
    return 0;
  }
  if (!(_DWORD)v24)
  {
    v20 = CBS_len((uint64_t)a1);
    if (v20 < v21)
    {
      v17 = 155;
      v18 = 153;
      goto LABEL_42;
    }
  }
  if (v23 < 0)
  {
    v17 = 155;
    v18 = 158;
    goto LABEL_42;
  }
  if ((_DWORD)v24)
    v21 = CBS_len((uint64_t)a1);
  if (a2)
    *a2 = v21;
  if (a3)
    *a3 = v23;
  if (a4)
    *a4 = v22 << 6;
  if (a5)
    *a5 = v24;
  if (a6)
    *a6 = HIDWORD(v24);
  return 1;
}

BOOL asn1_d2i_primitive_content(ASN1_TYPE **a1, _QWORD *a2, unsigned __int16 **a3, uint64_t a4, int a5, unsigned int a6, unint64_t a7, uint64_t a8)
{
  _BOOL4 must_be_constructed;
  int v17;
  int v18;
  int must_be_primitive;
  _BOOL8 v20;
  uint64_t v22;
  unint64_t v23;
  uint64_t *v24;
  uint64_t v25;
  uint64_t (*v26)(ASN1_TYPE **, uint64_t, uint64_t, uint64_t, unint64_t *, uint64_t);
  uint64_t v27;
  uint64_t v28;
  int v29;
  ASN1_TYPE *v30;
  ASN1_TYPE *v31;
  asn1_type_st::$2DD2868AF9E8E8462C9810218891F7E4 *p_value;
  unint64_t v33;
  _OWORD v34[2];
  size_t v35;
  void *v36;
  _QWORD v37[3];
  _QWORD v38[3];
  unsigned int v39;
  unint64_t v40;

  memset(v38, 0, sizeof(v38));
  memset(v37, 0, sizeof(v37));
  v35 = 0;
  v36 = 0;
  memset(v34, 0, sizeof(v34));
  CBS_dup(a2, v37);
  CBS_init(v38, 0, 0);
  must_be_constructed = asn1_must_be_constructed(a4);
  if (a5 || !must_be_constructed)
  {
    must_be_primitive = asn1_must_be_primitive(a4);
    if (a5 && must_be_primitive)
    {
      v17 = 231;
      v18 = 473;
      goto LABEL_7;
    }
    if ((a4 + 3) <= 0x14 && ((1 << (a4 + 3)) & 0x180001) != 0)
    {
      v40 = a7;
      v39 = a6;
      if (a6)
      {
        v22 = 1;
        while (CBS_len((uint64_t)a3))
        {
          if (asn1_check_eoc(a3))
          {
            if (!--v22)
              goto LABEL_32;
          }
          else
          {
            if (!asn1_check_tag(a3, &v40, 0, 0, &v39, 0, -1, 0, 0))
            {
              v17 = 58;
              v18 = 257;
              goto LABEL_7;
            }
            if (v39)
            {
              ++v22;
            }
            else if (!CBS_skip(a3, v40))
            {
              goto LABEL_8;
            }
          }
        }
        if (!v22)
          goto LABEL_32;
        v17 = 137;
        v18 = 269;
        goto LABEL_7;
      }
      if (!CBS_skip(a3, a7))
      {
        v17 = 58;
        v18 = 241;
        goto LABEL_7;
      }
LABEL_32:
      v23 = CBS_offset((uint64_t)a3);
      v24 = v37;
    }
    else
    {
      if (a5)
      {
        if (!CBB_init((uint64_t)v34, 0)
          || !asn1_collect((char **)v34, (uint64_t *)a3, a6, 0)
          || !CBB_finish((uint64_t *)v34, &v36, &v35))
        {
          goto LABEL_8;
        }
        CBS_init(v38, (uint64_t)v36, v35);
        goto LABEL_36;
      }
      v24 = (uint64_t *)a3;
      v23 = a7;
    }
    if (!CBS_get_bytes(v24, v38, v23))
      goto LABEL_8;
LABEL_36:
    if ((unint64_t)CBS_len((uint64_t)v38) >> 31)
      goto LABEL_8;
    v25 = *(_QWORD *)(a8 + 32);
    if (v25)
    {
      LOBYTE(v40) = 0;
      v26 = *(uint64_t (**)(ASN1_TYPE **, uint64_t, uint64_t, uint64_t, unint64_t *, uint64_t))(v25 + 40);
      if (v26)
      {
        v27 = CBS_data((uint64_t)v38);
        v28 = CBS_len((uint64_t)v38);
        v29 = v26(a1, v27, v28, a4, &v40, a8);
      }
      else
      {
        v29 = 0;
      }
    }
    else
    {
      if (*(_QWORD *)(a8 + 8) == -4)
      {
        if (*a1)
        {
          ASN1_TYPE_free(*a1);
          *a1 = 0;
        }
        v30 = ASN1_TYPE_new();
        if (!v30)
          goto LABEL_8;
        v31 = v30;
        p_value = &v30->value;
        if (!asn1_c2i_primitive((ASN1_VALUE **)&v30->value, v38, a4, a8))
        {
          ASN1_TYPE_free(v31);
          goto LABEL_8;
        }
        v31->type = a4;
        if ((_DWORD)a4 == 5)
          p_value->ptr = 0;
        *a1 = v31;
        goto LABEL_51;
      }
      v29 = asn1_c2i_primitive((ASN1_VALUE **)a1, v38, a4, a8);
    }
    if (!v29)
      goto LABEL_8;
LABEL_51:
    v33 = CBS_offset((uint64_t)a3);
    v20 = CBS_skip(a2, v33) != 0;
    goto LABEL_9;
  }
  v17 = 156;
  v18 = 469;
LABEL_7:
  ERR_put_error(13, 4095, v17, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/tasn_dec.c", v18);
LABEL_8:
  v20 = 0;
LABEL_9:
  CBB_cleanup((uint64_t *)v34);
  freezero(v36, v35);
  return v20;
}

uint64_t asn1_collect(char **a1, uint64_t *a2, unsigned int a3, int a4)
{
  int v4;
  int v5;
  uint64_t v10;
  uint64_t result;
  const void *v12;
  size_t v13;
  _QWORD v14[3];
  unint64_t v15;
  int v16;
  unsigned int v17;

  v17 = a3;
  if (a4 <= 5)
  {
    v16 = 0;
    v15 = 0;
    memset(v14, 0, sizeof(v14));
    if (CBS_len((uint64_t)a2))
    {
      v10 = (a4 + 1);
      while (!asn1_check_eoc((unsigned __int16 **)a2))
      {
        if (!asn1_check_tag(a2, &v15, 0, 0, &v17, &v16, -1, 0, 0))
        {
          v4 = 58;
          v5 = 206;
          goto LABEL_20;
        }
        if (v16)
        {
          result = asn1_collect(a1, a2, v17, v10);
          if (!(_DWORD)result)
            return result;
        }
        else
        {
          if (!CBS_get_bytes(a2, v14, v15))
          {
            v4 = 58;
            v5 = 218;
            goto LABEL_20;
          }
          v12 = (const void *)CBS_data((uint64_t)v14);
          v13 = CBS_len((uint64_t)v14);
          result = CBB_add_bytes(a1, v12, v13);
          if (!(_DWORD)result)
            return result;
        }
        if (!CBS_len((uint64_t)a2))
          goto LABEL_13;
      }
      if (a3)
        return 1;
      v4 = 159;
      v5 = 199;
    }
    else
    {
LABEL_13:
      if (!a3)
        return 1;
      v4 = 137;
      v5 = 226;
    }
  }
  else
  {
    v4 = 197;
    v5 = 190;
  }
LABEL_20:
  ERR_put_error(13, 4095, v4, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/tasn_dec.c", v5);
  return 0;
}

uint64_t asn1_check_eoc(unsigned __int16 **a1)
{
  int v2;
  uint64_t result;
  __int16 v4;

  v4 = 0;
  v2 = CBS_peek_u16(a1, &v4);
  result = 0;
  if (v2)
  {
    if (!v4)
      return CBS_skip(a1, 2uLL);
  }
  return result;
}

uint64_t asn1_c2i_primitive(ASN1_VALUE **a1, _QWORD *a2, int a3, uint64_t a4)
{
  uint64_t result;
  int v8;
  int v9;
  ASN1_STRING *v10;
  ASN1_STRING *v11;
  const void *v12;
  int v13;
  unsigned __int8 v14;

  if (*(_QWORD *)(a4 + 32) || (unint64_t)CBS_len((uint64_t)a2) >> 31)
    return 0;
  switch(a3)
  {
    case 1:
      if (CBS_len((uint64_t)a2) != 1)
      {
        v8 = 106;
        v9 = 307;
        goto LABEL_33;
      }
      v14 = 0;
      result = CBS_get_u8(a2, &v14);
      if ((_DWORD)result)
      {
        *(_DWORD *)a1 = v14;
        goto LABEL_38;
      }
      return result;
    case 2:
      result = c2i_ASN1_INTEGER_cbs(a1, a2);
      if ((_DWORD)result)
        goto LABEL_38;
      return result;
    case 3:
      result = c2i_ASN1_BIT_STRING_cbs(a1, a2);
      if ((_DWORD)result)
        goto LABEL_38;
      return result;
    case 4:
    case 7:
    case 8:
    case 9:
      goto LABEL_11;
    case 5:
      if (CBS_len((uint64_t)a2))
      {
        v8 = 144;
        v9 = 298;
        goto LABEL_33;
      }
      *a1 = (ASN1_VALUE *)1;
      goto LABEL_38;
    case 6:
      result = c2i_ASN1_OBJECT_cbs((ASN1_OBJECT **)a1, a2);
      if (!(_DWORD)result)
        return result;
      goto LABEL_38;
    case 10:
      result = c2i_ASN1_ENUMERATED_cbs((uint64_t)a1, a2);
      if (!(_DWORD)result)
        return result;
      goto LABEL_38;
    default:
      if (a3 == 28)
      {
        if ((CBS_len((uint64_t)a2) & 3) != 0)
        {
          v8 = 215;
          v9 = 353;
          goto LABEL_33;
        }
      }
      else if (a3 == 30)
      {
        if ((CBS_len((uint64_t)a2) & 1) != 0)
        {
          v8 = 214;
          v9 = 349;
LABEL_33:
          ERR_put_error(13, 4095, v8, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/tasn_dec.c", v9);
          return 0;
        }
      }
      else
      {
LABEL_11:
        if ((a3 - 23) <= 1 && !asn1_time_parse_cbs(a2, a3 == 24, 0))
        {
          v8 = 132;
          v9 = 359;
          goto LABEL_33;
        }
      }
      if (*a1)
      {
        ASN1_STRING_free((ASN1_STRING *)*a1);
        *a1 = 0;
      }
      v10 = ASN1_STRING_type_new(a3);
      if (!v10)
      {
        v8 = 65;
        v9 = 369;
        goto LABEL_33;
      }
      v11 = v10;
      v12 = (const void *)CBS_data((uint64_t)a2);
      v13 = CBS_len((uint64_t)a2);
      if (!ASN1_STRING_set(v11, v12, v13))
      {
        ASN1_STRING_free(v11);
        return 0;
      }
      *a1 = (ASN1_VALUE *)v11;
LABEL_38:
      result = 1;
      break;
  }
  return result;
}

uint64_t asn1_template_noexp_d2i(ASN1_VALUE **pval, _QWORD *a2, uint64_t a3, int a4)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  int v12;
  int v13;
  uint64_t result;
  int v15;
  uint64_t v16;
  uint64_t v17;
  STACK *v18;
  int v19;
  int v20;
  unint64_t v21;
  unint64_t v22;
  unint64_t v23;
  int v24;
  char *data;
  unsigned __int16 *v26[3];
  uint64_t v27[3];

  if ((*(_QWORD *)a3 & 6) != 0)
  {
    memset(v27, 0, sizeof(v27));
    memset(v26, 0, sizeof(v26));
    data = 0;
    v24 = 0;
    v23 = 0;
    v8 = CBS_data((uint64_t)a2);
    v9 = CBS_len((uint64_t)a2);
    CBS_init(v27, v8, v9);
    asn1_template_stack_of_free((STACK *)*pval, a3);
    *pval = 0;
    v10 = *(_QWORD *)a3;
    if ((*(_QWORD *)a3 & 2) != 0)
      v11 = 17;
    else
      v11 = 16;
    if ((v10 & 8) != 0)
      v12 = *(_DWORD *)(a3 + 8);
    else
      v12 = v11;
    if ((v10 & 8) != 0)
      v13 = *(_DWORD *)a3 & 0xC0;
    else
      v13 = 0;
    result = asn1_check_tag(v27, &v23, 0, 0, &v24, 0, v12, v13, a4);
    if ((_DWORD)result != -1)
    {
      if ((_DWORD)result == 1)
      {
        v15 = v24;
        if (v24)
        {
          v16 = CBS_data((uint64_t)v27);
          v17 = CBS_len((uint64_t)v27);
          CBS_init(v26, v16, v17);
        }
        else if (!CBS_get_bytes(v27, v26, v23))
        {
          v18 = 0;
LABEL_40:
          asn1_template_stack_of_free(v18, a3);
          ASN1_item_ex_free((ASN1_VALUE **)&data, *(const ASN1_ITEM **)(a3 + 32));
          return 0;
        }
        v18 = sk_new_null();
        if (v18)
        {
          while (1)
          {
            if (!CBS_len((uint64_t)v26))
            {
              if (v15)
              {
                v19 = 137;
                v20 = 1096;
                goto LABEL_39;
              }
              goto LABEL_32;
            }
            if (asn1_check_eoc(v26))
              break;
            if (!asn1_item_d2i((ASN1_VALUE **)&data, (int)v26, *(ASN1_ITEM **)(a3 + 32)))
            {
              v19 = 58;
              v20 = 1086;
              goto LABEL_39;
            }
            if (!sk_push(v18, data))
            {
              v19 = 65;
              v20 = 1090;
              goto LABEL_39;
            }
            data = 0;
          }
          if (!v15)
          {
            v19 = 159;
            v20 = 1078;
            goto LABEL_39;
          }
LABEL_32:
          if (!v24 || (v21 = CBS_offset((uint64_t)v26), CBS_skip(v27, v21)))
          {
            v22 = CBS_offset((uint64_t)v27);
            if (CBS_skip(a2, v22))
            {
              *pval = (ASN1_VALUE *)v18;
              return 1;
            }
          }
        }
        else
        {
          v19 = 65;
          v20 = 1070;
LABEL_39:
          ERR_put_error(13, 4095, v19, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/tasn_dec.c", v20);
        }
        goto LABEL_40;
      }
      ERR_put_error(13, 4095, 58, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/tasn_dec.c", 1054);
      return 0;
    }
  }
  else
  {
    result = asn1_item_d2i(pval, (int)a2, *(ASN1_ITEM **)(a3 + 32));
    if ((_DWORD)result != -1 && (_DWORD)result != 1)
    {
      ERR_put_error(13, 4095, 58, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/tasn_dec.c", 1147);
      ASN1_template_free(pval, (const ASN1_TEMPLATE *)a3);
      return 0;
    }
  }
  return result;
}

void asn1_template_stack_of_free(STACK *a1, uint64_t a2)
{
  ASN1_VALUE *pval;

  if (a1)
  {
    pval = 0;
    if (sk_num(a1) >= 1)
    {
      do
      {
        pval = (ASN1_VALUE *)sk_pop(a1);
        ASN1_item_ex_free(&pval, *(const ASN1_ITEM **)(a2 + 32));
      }
      while (sk_num(a1) > 0);
    }
    sk_free(a1);
  }
}

int ASN1_mbstring_copy(ASN1_STRING **out, const unsigned __int8 *in, int len, int inform, unint64_t mask)
{
  return ASN1_mbstring_ncopy(out, in, len, inform, mask, 0, 0);
}

int ASN1_mbstring_ncopy(ASN1_STRING **out, const unsigned __int8 *in, int len, int inform, unint64_t mask, uint64_t minsize, uint64_t maxsize)
{
  int v11;
  int v14;
  const unsigned __int8 *v15;
  int v16;
  unsigned int v17;
  int v18;
  int v19;
  int v20;
  int v21;
  ASN1_STRING *v23;
  unsigned __int8 *data;
  ASN1_STRING *v25;
  ASN1_STRING *v26;
  int v27;
  int v28;
  uint64_t (*v29)(unint64_t, uint64_t);
  int v30;
  unsigned __int8 *v31;
  uint64_t v32;
  unsigned __int8 *v33;
  int v34;
  unint64_t v35;
  unint64_t val;

  v11 = len;
  v35 = mask;
  v34 = 0;
  if (len < 0)
  {
    v11 = strlen((const char *)in);
    if (mask)
      goto LABEL_3;
LABEL_10:
    v35 = 10246;
    goto LABEL_3;
  }
  if (!mask)
    goto LABEL_10;
LABEL_3:
  v33 = 0;
  v14 = v11;
  switch(inform)
  {
    case 4096:
      v14 = 0;
      if (!v11)
        goto LABEL_18;
      val = 0;
      v15 = in;
      v16 = v11;
      while (1)
      {
        v17 = UTF8_getc(v15, v16, &val);
        if ((v17 & 0x80000000) != 0)
          break;
        v15 += v17;
        ++v14;
        v16 -= v17;
        if (!v16)
          goto LABEL_18;
      }
      v18 = 134;
      v19 = 135;
      goto LABEL_37;
    case 4097:
      goto LABEL_18;
    case 4098:
      if ((v11 & 1) == 0)
      {
        v14 = v11 >> 1;
        goto LABEL_18;
      }
      v18 = 129;
      v19 = 116;
      goto LABEL_37;
    case 4100:
      if ((v11 & 3) != 0)
      {
        v18 = 133;
        v19 = 124;
LABEL_37:
        ERR_put_error(13, 4095, v18, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/a_mbstr.c", v19);
        return -1;
      }
      v14 = v11 >> 2;
LABEL_18:
      if (minsize >= 1 && v14 < minsize)
      {
        ERR_put_error(13, 4095, 152, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/a_mbstr.c", 150);
        ERR_asprintf_error_data("minsize=%ld");
        return -1;
      }
      if (maxsize >= 1 && v14 > maxsize)
      {
        ERR_put_error(13, 4095, 151, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/a_mbstr.c", 156);
        ERR_asprintf_error_data("maxsize=%ld");
        return -1;
      }
      if ((traverse_string((unsigned __int8 *)in, v11, inform, (uint64_t (*)(unint64_t, uint64_t))type_str, (uint64_t)&v35) & 0x80000000) != 0)
      {
        v18 = 124;
        v19 = 163;
        goto LABEL_37;
      }
      if ((v35 & 2) != 0)
      {
        v21 = 4097;
        v20 = 19;
      }
      else if ((v35 & 0x10) != 0)
      {
        v21 = 4097;
        v20 = 22;
      }
      else if ((v35 & 4) != 0)
      {
        v21 = 4097;
        v20 = 20;
      }
      else if ((v35 & 0x800) != 0)
      {
        v21 = 4098;
        v20 = 30;
      }
      else
      {
        if ((v35 & 0x100) != 0)
          v20 = 28;
        else
          v20 = 12;
        if ((v35 & 0x100) != 0)
          v21 = 4100;
        else
          v21 = 4096;
      }
      if (!out)
        return v20;
      v23 = *out;
      if (*out)
      {
        data = v23->data;
        if (data)
        {
          v23->length = 0;
          free(data);
          v23->data = 0;
        }
        v23->type = v20;
        v25 = v23;
      }
      else
      {
        v26 = ASN1_STRING_type_new(v20);
        if (!v26)
        {
          v18 = 65;
          v19 = 201;
          goto LABEL_37;
        }
        v25 = v26;
        *out = v26;
      }
      if (v21 == inform)
      {
        if (!ASN1_STRING_set(v25, in, v11))
        {
          v27 = 65;
          v28 = 209;
          goto LABEL_64;
        }
      }
      else
      {
        v29 = 0;
        v30 = 0;
        switch(v21)
        {
          case 4096:
            v34 = 0;
            if ((traverse_string((unsigned __int8 *)in, v11, inform, (uint64_t (*)(unint64_t, uint64_t))out_utf8, (uint64_t)&v34) & 0x80000000) == 0)
            {
              v29 = (uint64_t (*)(unint64_t, uint64_t))cpy_utf8;
              v30 = v34;
              break;
            }
            v27 = 124;
            v28 = 235;
            goto LABEL_64;
          case 4097:
            v34 = v14;
            v29 = (uint64_t (*)(unint64_t, uint64_t))cpy_asc;
            v30 = v14;
            break;
          case 4098:
            v30 = 2 * v14;
            v34 = 2 * v14;
            v29 = (uint64_t (*)(unint64_t, uint64_t))cpy_bmp;
            break;
          case 4100:
            v30 = 4 * v14;
            v34 = 4 * v14;
            v29 = (uint64_t (*)(unint64_t, uint64_t))cpy_univ;
            break;
          default:
            break;
        }
        v31 = (unsigned __int8 *)malloc_type_malloc(v30 + 1, 0xD4CC7B26uLL);
        v33 = v31;
        if (!v31)
        {
          v27 = 65;
          v28 = 242;
LABEL_64:
          ERR_put_error(13, 4095, v27, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/a_mbstr.c", v28);
          if (!v23)
          {
            ASN1_STRING_free(v25);
            *out = 0;
          }
          return -1;
        }
        v32 = v34;
        v25->length = v34;
        v25->data = v31;
        v31[v32] = 0;
        traverse_string((unsigned __int8 *)in, v11, inform, v29, (uint64_t)&v33);
      }
      return v20;
    default:
      v18 = 160;
      v19 = 145;
      goto LABEL_37;
  }
}

uint64_t traverse_string(unsigned __int8 *str, int len, int a3, uint64_t (*a4)(unint64_t, uint64_t), uint64_t a5)
{
  int v8;
  unsigned int v10;
  unint64_t v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v15;
  unsigned int v16;
  uint64_t result;
  unint64_t val;

  if (!len)
    return 1;
  v8 = len;
  val = 0;
  while (a3 != 4100)
  {
    if (a3 == 4098)
    {
      v15 = *str;
      val = v15 << 8;
      val = str[1] | ((unint64_t)v15 << 8);
      if ((v15 & 0xF8) == 0xD8)
        return 0xFFFFFFFFLL;
      str += 2;
      v8 -= 2;
      if (a4)
        goto LABEL_19;
    }
    else if (a3 == 4097)
    {
      v10 = *str++;
      val = v10;
      --v8;
      if (a4)
        goto LABEL_19;
    }
    else
    {
      v16 = UTF8_getc(str, v8, &val);
      if ((v16 & 0x80000000) != 0)
        return 0xFFFFFFFFLL;
      v8 -= v16;
      str += v16;
      if (a4)
      {
LABEL_19:
        result = a4(val, a5);
        if ((int)result < 1)
          return result;
      }
    }
LABEL_20:
    if (!v8)
      return 1;
  }
  val = (unint64_t)*str << 24;
  v11 = val | ((unint64_t)str[1] << 16);
  val = v11;
  v12 = v11 | ((unint64_t)str[2] << 8);
  val = v12;
  val = v12 | str[3];
  v13 = v12 & 0xFFFFF800;
  if (v11 >> 16 <= 0x10 && v13 != 55296)
  {
    str += 4;
    v8 -= 4;
    if (a4)
      goto LABEL_19;
    goto LABEL_20;
  }
  return 0xFFFFFFFFLL;
}

uint64_t type_str(unint64_t __c, unint64_t *a2)
{
  unint64_t v4;
  unint64_t v5;

  v4 = *a2;
  if ((*a2 & 2) != 0
    && (__c > 0x7F
     || (_DWORD)__c != 32
     && (__c - 48) >= 0xA
     && (__c & 0xFFFFFFDF) - 65 >= 0x1A
     && !memchr("'()+,-./:=?", __c, 0xCuLL)))
  {
    v4 &= ~2uLL;
  }
  if (__c > 0x7F && (v4 & 0x10) != 0)
    v5 = v4 & 0xFFFFFFFFFFFFFFEFLL;
  else
    v5 = v4;
  if (__c > 0xFF && (v5 & 4) != 0)
    v5 &= ~4uLL;
  if ((__c & 0xFFFFFFFFFFFF0000) != 0 && (v5 & 0x800) != 0)
    v5 &= ~0x800uLL;
  if (!v5)
    return 0xFFFFFFFFLL;
  *a2 = v5;
  return 1;
}

uint64_t cpy_asc(char a1, _QWORD *a2)
{
  *(_BYTE *)(*a2)++ = a1;
  return 1;
}

uint64_t cpy_bmp(unsigned int a1, _WORD **a2)
{
  *(*a2)++ = bswap32(a1) >> 16;
  return 1;
}

uint64_t cpy_univ(unsigned int a1, _DWORD **a2)
{
  *(*a2)++ = bswap32(a1);
  return 1;
}

uint64_t out_utf8(unint64_t value, _DWORD *a2)
{
  uint64_t result;

  result = UTF8_putc(0, -1, value);
  if ((result & 0x80000000) == 0)
  {
    *a2 += result;
    return 1;
  }
  return result;
}

uint64_t cpy_utf8(unint64_t value, unsigned __int8 **a2)
{
  *a2 += UTF8_putc(*a2, 255, value);
  return 1;
}

LHASH *__cdecl lh_new(LHASH_HASH_FN_TYPE h, LHASH_COMP_FN_TYPE c)
{
  LHASH *v4;
  LHASH_NODE **v5;
  LHASH_COMP_FN_TYPE v6;
  unint64_t (__cdecl *v7)(const void *);

  v4 = (LHASH *)malloc_type_calloc(1uLL, 0xB0uLL, 0x1080040A9E2475DuLL);
  if (v4)
  {
    v5 = (LHASH_NODE **)malloc_type_calloc(0x10uLL, 8uLL, 0x2004093837F09uLL);
    v4->b = v5;
    if (v5)
    {
      v6 = (LHASH_COMP_FN_TYPE)MEMORY[0x24BDAFEF0];
      v7 = (unint64_t (__cdecl *)(const void *))lh_strhash;
      if (c)
        v6 = c;
      if (h)
        v7 = h;
      v4->comp = v6;
      v4->hash = v7;
      *(_QWORD *)&v4->num_nodes = 0x1000000008;
      v4->pmax = 8;
      *(_OWORD *)&v4->up_load = xmmword_22D699B60;
    }
    else
    {
      free(v4);
      return 0;
    }
  }
  return v4;
}

unint64_t lh_strhash(unint64_t c)
{
  char v1;
  unint64_t v2;
  unsigned __int8 *v3;
  uint64_t v4;
  unint64_t v5;
  int v6;

  if (c)
  {
    v1 = *(_BYTE *)c;
    if (*(_BYTE *)c)
    {
      v2 = 0;
      v3 = (unsigned __int8 *)(c + 1);
      v4 = 256;
      do
      {
        v5 = v1 ^ ((unint64_t)v1 >> 2);
        if ((v5 & 0xF) != 0)
          v2 = (v2 >> (32 - (v5 & 0xFu))) | (v2 << (v5 & 0xF));
        v2 = v2 ^ ((v4 | v1) * (v4 | v1));
        v6 = *v3++;
        v1 = v6;
        v4 += 256;
      }
      while (v6);
      return v2 ^ (v2 >> 16);
    }
    else
    {
      return 0;
    }
  }
  return c;
}

void lh_free(LHASH *lh)
{
  unint64_t num_nodes;
  unint64_t i;
  LHASH_NODE *v4;
  LHASH_NODE *next;

  if (lh)
  {
    num_nodes = lh->num_nodes;
    if ((_DWORD)num_nodes)
    {
      for (i = 0; i < num_nodes; ++i)
      {
        v4 = lh->b[i];
        if (v4)
        {
          do
          {
            next = v4->next;
            free(v4);
            v4 = next;
          }
          while (next);
          num_nodes = lh->num_nodes;
        }
      }
    }
    free(lh->b);
    free(lh);
  }
}

void *__cdecl lh_insert(LHASH *lh, void *data)
{
  unint64_t num_nodes;
  uint64_t p;
  unint64_t num_alloc_nodes;
  LHASH_NODE **b;
  LHASH_NODE **p_next;
  unsigned int pmax;
  uint64_t v10;
  LHASH_NODE *v11;
  unsigned int v12;
  LHASH_NODE **v13;
  LHASH_NODE **v14;
  uint64_t v15;
  void ***v16;
  void **v17;
  void *result;
  void ***v19;
  void **v20;
  void *v21;

  v21 = 0;
  lh->error = 0;
  num_nodes = lh->num_nodes;
  if (lh->up_load <= (lh->num_items << 8) / num_nodes)
  {
    lh->num_nodes = num_nodes + 1;
    ++lh->num_expands;
    num_alloc_nodes = lh->num_alloc_nodes;
    p = lh->p;
    lh->p = p + 1;
    b = lh->b;
    p_next = &lh->b[p];
    pmax = lh->pmax;
    v10 = pmax + p;
    lh->b[v10] = 0;
    while (1)
    {
      v11 = *p_next;
      if (!*p_next)
        break;
      if (v11->hash % num_alloc_nodes == p)
      {
        p_next = &v11->next;
      }
      else
      {
        *p_next = v11->next;
        v11->next = b[v10];
        b[v10] = v11;
      }
    }
    if ((int)p + 1 >= pmax)
    {
      v12 = 2 * num_alloc_nodes;
      v13 = (LHASH_NODE **)reallocarray(lh->b, (2 * num_alloc_nodes), 8uLL);
      if (v13)
      {
        v14 = v13;
        v15 = lh->num_alloc_nodes;
        if (v15 < v12)
          bzero(&v13[v15], 8 * (v12 + ~(_DWORD)v15) + 8);
        lh->p = 0;
        lh->pmax = v15;
        ++lh->num_expand_reallocs;
        lh->num_alloc_nodes = v12;
        lh->b = v14;
      }
      else
      {
        ++lh->error;
        lh->p = 0;
      }
    }
  }
  v16 = (void ***)getrn((uint64_t)lh, (uint64_t)data, (unint64_t *)&v21);
  v17 = *v16;
  if (*v16)
  {
    result = *v17;
    *v17 = data;
    ++lh->num_replace;
  }
  else
  {
    v19 = v16;
    result = malloc_type_malloc(0x18uLL, 0x10A0040AFD1EA57uLL);
    if (result)
    {
      v20 = (void **)result;
      result = 0;
      *v20 = data;
      v20[1] = 0;
      v20[2] = v21;
      *v19 = v20;
      ++lh->num_insert;
      ++lh->num_items;
    }
    else
    {
      ++lh->error;
    }
  }
  return result;
}

_QWORD *getrn(uint64_t a1, uint64_t a2, unint64_t *a3)
{
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  _QWORD *v9;
  _QWORD *v10;
  unsigned int (*v11)(_QWORD, uint64_t);

  v6 = (*(uint64_t (**)(uint64_t))(a1 + 16))(a2);
  v7 = v6;
  ++*(_QWORD *)(a1 + 96);
  *a3 = v6;
  v8 = v6 % *(unsigned int *)(a1 + 36);
  if (v8 < *(unsigned int *)(a1 + 32))
    v8 = v6 % *(unsigned int *)(a1 + 28);
  v9 = (_QWORD *)(*(_QWORD *)a1 + 8 * (int)v8);
  v10 = (_QWORD *)*v9;
  if (*v9)
  {
    v11 = *(unsigned int (**)(_QWORD, uint64_t))(a1 + 8);
    do
    {
      ++*(_QWORD *)(a1 + 160);
      if (v10[2] == v7)
      {
        ++*(_QWORD *)(a1 + 104);
        if (!v11(*v10, a2))
          break;
      }
      v9 = v10 + 1;
      v10 = (_QWORD *)v10[1];
    }
    while (v10);
  }
  return v9;
}

void *__cdecl lh_delete(LHASH *lh, const void *data)
{
  void **v3;
  void *v4;
  void *v5;
  unint64_t v6;
  unint64_t num_nodes;
  unint64_t pmax;
  unsigned int p;
  signed int v10;
  int v11;
  LHASH_NODE *v12;
  LHASH_NODE **b;
  unsigned int v15;
  unsigned int v16;
  LHASH_NODE *v17;
  LHASH_NODE *v18;
  unint64_t v19;

  lh->error = 0;
  v3 = (void **)getrn((uint64_t)lh, (uint64_t)data, &v19);
  v4 = *v3;
  if (*v3)
  {
    *v3 = (void *)*((_QWORD *)v4 + 1);
    v5 = *(void **)v4;
    free(v4);
    ++lh->num_delete;
    v6 = lh->num_items - 1;
    lh->num_items = v6;
    num_nodes = lh->num_nodes;
    if (num_nodes >= 0x11 && lh->down_load >= (v6 << 8) / num_nodes)
    {
      p = lh->p;
      pmax = lh->pmax;
      v10 = p - 1;
      v11 = p - 1 + pmax;
      v12 = lh->b[v11];
      lh->b[v11] = 0;
      if (p)
      {
        lh->p = v10;
        b = lh->b;
      }
      else
      {
        b = (LHASH_NODE **)reallocarray(lh->b, pmax, 8uLL);
        if (!b)
        {
          ++lh->error;
          return v5;
        }
        ++lh->num_contract_reallocs;
        LODWORD(num_nodes) = lh->num_nodes;
        v15 = lh->num_alloc_nodes >> 1;
        v16 = lh->pmax >> 1;
        lh->pmax = v16;
        v10 = v16 - 1;
        lh->num_alloc_nodes = v15;
        lh->p = v10;
        lh->b = b;
      }
      lh->num_nodes = num_nodes - 1;
      ++lh->num_contracts;
      v17 = b[v10];
      if (v17)
      {
        do
        {
          v18 = v17;
          v17 = v17->next;
        }
        while (v17);
        v18->next = v12;
      }
      else
      {
        b[v10] = v12;
      }
    }
  }
  else
  {
    v5 = 0;
    ++lh->num_no_delete;
  }
  return v5;
}

void *__cdecl lh_retrieve(LHASH *lh, const void *data)
{
  void ***v3;
  void *result;
  unint64_t *p_num_retrieve;
  unint64_t v6;

  lh->error = 0;
  v3 = (void ***)getrn((uint64_t)lh, (uint64_t)data, &v6);
  if (*v3)
  {
    result = **v3;
    p_num_retrieve = &lh->num_retrieve;
  }
  else
  {
    result = 0;
    p_num_retrieve = &lh->num_retrieve_miss;
  }
  ++*p_num_retrieve;
  return result;
}

void lh_doall(LHASH *lh, LHASH_DOALL_FN_TYPE func)
{
  unsigned int num_nodes;
  uint64_t v4;
  LHASH_NODE *v6;
  LHASH_NODE *next;

  if (lh)
  {
    num_nodes = lh->num_nodes;
    v4 = num_nodes - 1;
    if ((int)(num_nodes - 1) >= 0)
    {
      do
      {
        v6 = lh->b[v4];
        if (v6)
        {
          do
          {
            next = v6->next;
            ((void (*)(void *))func)(v6->data);
            v6 = next;
          }
          while (next);
        }
      }
      while (v4-- >= 1);
    }
  }
}

void lh_doall_arg(LHASH *lh, LHASH_DOALL_ARG_FN_TYPE func, void *arg)
{
  unsigned int num_nodes;
  uint64_t v5;
  LHASH_NODE *v8;
  LHASH_NODE *next;

  if (lh)
  {
    num_nodes = lh->num_nodes;
    v5 = num_nodes - 1;
    if ((int)(num_nodes - 1) >= 0)
    {
      do
      {
        v8 = lh->b[v5];
        if (v8)
        {
          do
          {
            next = v8->next;
            ((void (*)(void *, void *))func)(v8->data, arg);
            v8 = next;
          }
          while (next);
        }
      }
      while (v5-- >= 1);
    }
  }
}

unint64_t lh_num_items(unint64_t lh)
{
  if (lh)
    return *(_QWORD *)(lh + 56);
  return lh;
}

void ENGINE_unregister_EC(void *a1)
{
  engine_table_unregister(&ec_table, a1);
}

uint64_t ENGINE_register_EC(uint64_t a1)
{
  if (*(_QWORD *)(a1 + 56))
    return engine_table_register(&ec_table, (uint64_t)engine_unregister_all_EC, (char *)a1, dummy_nid_1, 1, 0);
  else
    return 1;
}

void engine_unregister_all_EC()
{
  engine_table_cleanup(&ec_table);
}

ENGINE *ENGINE_register_all_EC()
{
  ENGINE *result;
  ENGINE *v1;

  result = ENGINE_get_first();
  if (result)
  {
    v1 = result;
    do
    {
      if (*((_QWORD *)v1 + 7))
        engine_table_register(&ec_table, (uint64_t)engine_unregister_all_EC, (char *)v1, dummy_nid_1, 1, 0);
      result = ENGINE_get_next(v1);
      v1 = result;
    }
    while (result);
  }
  return result;
}

uint64_t ENGINE_set_default_EC(uint64_t a1)
{
  if (*(_QWORD *)(a1 + 56))
    return engine_table_register(&ec_table, (uint64_t)engine_unregister_all_EC, (char *)a1, dummy_nid_1, 1, 1);
  else
    return 1;
}

uint64_t ENGINE_get_default_EC()
{
  return engine_table_select(&ec_table, 1);
}

uint64_t ENGINE_get_EC(uint64_t a1)
{
  return *(_QWORD *)(a1 + 56);
}

uint64_t ENGINE_set_EC(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)(a1 + 56) = a2;
  return 1;
}

void EVP_set_pw_prompt(const char *prompt)
{
  if (prompt)
    __strlcpy_chk();
  else
    prompt_string = 0;
}

char *EVP_get_pw_prompt(void)
{
  if (prompt_string)
    return &prompt_string;
  else
    return 0;
}

int EVP_read_pw_string(char *buf, int length, const char *prompt, int verify)
{
  return EVP_read_pw_string_min(buf, 0, length, (char *)prompt, verify);
}

uint64_t EVP_read_pw_string_min(char *a1, int a2, int a3, char *a4, int a5)
{
  int v6;
  BOOL v9;
  const char *v10;
  UI *v11;
  UI *v12;
  int v13;
  uint64_t v14;
  char result_buf[1024];
  uint64_t v17;

  v17 = *MEMORY[0x24BDAC8D0];
  if (a2 < 0)
    return 0xFFFFFFFFLL;
  v6 = a3 >= 1024 ? 1024 : a3;
  if (v6 <= a2)
    return 0xFFFFFFFFLL;
  v9 = prompt_string && a4 == 0;
  v10 = v9 ? &prompt_string : a4;
  v11 = UI_new();
  if (!v11)
    return 0xFFFFFFFFLL;
  v12 = v11;
  v13 = v6 - 1;
  if (UI_add_input_string(v11, v10, 0, a1, a2, v13) < 0
    || a5 && UI_add_verify_string(v12, v10, 0, result_buf, a2, v13, a1) < 0)
  {
    return 0xFFFFFFFFLL;
  }
  v14 = UI_process(v12);
  UI_free(v12);
  explicit_bzero(result_buf, 0x400uLL);
  return v14;
}

int EVP_BytesToKey(const EVP_CIPHER *type, const EVP_MD *md, const unsigned __int8 *salt, const unsigned __int8 *data, int datal, int count, unsigned __int8 *key, unsigned __int8 *iv)
{
  uint64_t key_len;
  int v9;
  int v10;
  unsigned int iv_len;
  const unsigned __int8 *v14;
  uint64_t v17;
  int v21;
  const unsigned __int8 *v22;
  uint64_t v23;
  int v24;
  int v25;
  uint64_t v26;
  int v27;
  uint64_t v28;
  const unsigned __int8 *v29;
  int v30;
  size_t v31;
  unsigned int cnt[9];
  __int128 v33;
  unsigned __int8 d[64];
  uint64_t v35;

  v35 = *MEMORY[0x24BDAC8D0];
  cnt[0] = 0;
  key_len = type->key_len;
  if (key_len >= 0x41)
  {
    v9 = 137;
    v10 = 144;
LABEL_5:
    ERR_put_error(6, 4095, v9, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/evp_key.c", v10);
    LODWORD(key_len) = 0;
    return key_len;
  }
  iv_len = type->iv_len;
  if (iv_len >= 0x11)
  {
    v9 = 102;
    v10 = 148;
    goto LABEL_5;
  }
  v14 = data;
  if (!data)
    return key_len;
  v17 = *(_QWORD *)&count;
  v33 = 0u;
  memset(&cnt[1], 0, 32);
  EVP_MD_CTX_init((EVP_MD_CTX *)&cnt[1]);
  v31 = datal;
  v21 = 0;
  v30 = v17 - 1;
  v29 = v14;
  while (EVP_DigestInit_ex((EVP_MD_CTX *)&cnt[1], md, 0)
       && (!v21 || EVP_DigestUpdate((EVP_MD_CTX *)&cnt[1], d, cnt[0]))
       && EVP_DigestUpdate((EVP_MD_CTX *)&cnt[1], v14, v31)
       && (!salt || EVP_DigestUpdate((EVP_MD_CTX *)&cnt[1], salt, 8uLL))
       && EVP_DigestFinal_ex((EVP_MD_CTX *)&cnt[1], d, cnt))
  {
    v22 = salt;
    v23 = v17;
    v24 = v21;
    v25 = v30;
    v26 = v23;
    if (v23 >= 2)
    {
      while (EVP_DigestInit_ex((EVP_MD_CTX *)&cnt[1], md, 0)
           && EVP_DigestUpdate((EVP_MD_CTX *)&cnt[1], d, cnt[0])
           && EVP_DigestFinal_ex((EVP_MD_CTX *)&cnt[1], d, cnt))
      {
        if (!--v25)
          goto LABEL_21;
      }
      break;
    }
LABEL_21:
    v27 = v24;
    if (key_len)
    {
      v28 = 0;
      v17 = v26;
      salt = v22;
      v14 = v29;
      while (v28 != cnt[0])
      {
        if (key)
          *key++ = d[v28];
        if ((_DWORD)key_len == (_DWORD)++v28)
        {
          LODWORD(v28) = key_len;
          key_len = 0;
          if (iv_len)
            goto LABEL_32;
          goto LABEL_37;
        }
      }
      key_len = (key_len - v28);
      if (!iv_len)
        goto LABEL_37;
LABEL_32:
      if ((_DWORD)v28 != cnt[0])
      {
        do
        {
          if ((_DWORD)v28 == cnt[0])
            break;
          if (iv)
            *iv++ = d[v28];
          LODWORD(v28) = v28 + 1;
          --iv_len;
        }
        while (iv_len);
      }
      goto LABEL_37;
    }
    LODWORD(v28) = 0;
    v17 = v26;
    salt = v22;
    v14 = v29;
    if (iv_len)
      goto LABEL_32;
LABEL_37:
    v21 = v27 + 1;
    if (!key_len && !iv_len)
    {
      LODWORD(key_len) = type->key_len;
      goto LABEL_41;
    }
  }
  LODWORD(key_len) = 0;
LABEL_41:
  EVP_MD_CTX_cleanup((EVP_MD_CTX *)&cnt[1]);
  explicit_bzero(d, 0x40uLL);
  return key_len;
}

uint64_t EVP_PKEY_paramgen_init(uint64_t *a1)
{
  uint64_t v2;
  uint64_t (*v3)(uint64_t *);
  uint64_t result;

  if (a1 && (v2 = *a1) != 0 && *(_QWORD *)(v2 + 40))
  {
    *((_DWORD *)a1 + 8) = 2;
    v3 = *(uint64_t (**)(uint64_t *))(v2 + 32);
    if (v3)
    {
      result = v3(a1);
      if ((int)result <= 0)
        *((_DWORD *)a1 + 8) = 0;
    }
    else
    {
      return 1;
    }
  }
  else
  {
    ERR_put_error(6, 4095, 150, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/pmeth_gn.c", 77);
    return 4294967294;
  }
  return result;
}

uint64_t EVP_PKEY_paramgen(_DWORD *a1, EVP_PKEY **a2)
{
  uint64_t (*v3)(_DWORD *);
  uint64_t v5;

  if (!a1 || !*(_QWORD *)a1 || (v3 = *(uint64_t (**)(_DWORD *))(*(_QWORD *)a1 + 40)) == 0)
  {
    ERR_put_error(6, 4095, 150, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/pmeth_gn.c", 95);
    return 4294967294;
  }
  if (a1[8] != 2)
  {
    ERR_put_error(6, 4095, 151, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/pmeth_gn.c", 100);
    return 0xFFFFFFFFLL;
  }
  if (!a2)
    return 0xFFFFFFFFLL;
  if (!*a2)
  {
    *a2 = EVP_PKEY_new();
    v3 = *(uint64_t (**)(_DWORD *))(*(_QWORD *)a1 + 40);
  }
  v5 = v3(a1);
  if ((int)v5 <= 0)
  {
    EVP_PKEY_free(*a2);
    *a2 = 0;
  }
  return v5;
}

uint64_t EVP_PKEY_keygen_init(uint64_t *a1)
{
  uint64_t v2;
  uint64_t (*v3)(uint64_t *);
  uint64_t result;

  if (a1 && (v2 = *a1) != 0 && *(_QWORD *)(v2 + 56))
  {
    *((_DWORD *)a1 + 8) = 4;
    v3 = *(uint64_t (**)(uint64_t *))(v2 + 48);
    if (v3)
    {
      result = v3(a1);
      if ((int)result <= 0)
        *((_DWORD *)a1 + 8) = 0;
    }
    else
    {
      return 1;
    }
  }
  else
  {
    ERR_put_error(6, 4095, 150, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/pmeth_gn.c", 124);
    return 4294967294;
  }
  return result;
}

uint64_t EVP_PKEY_keygen(_DWORD *a1, EVP_PKEY **a2)
{
  uint64_t (*v3)(_DWORD *);
  uint64_t v5;

  if (!a1 || !*(_QWORD *)a1 || (v3 = *(uint64_t (**)(_DWORD *))(*(_QWORD *)a1 + 56)) == 0)
  {
    ERR_put_error(6, 4095, 150, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/pmeth_gn.c", 142);
    return 4294967294;
  }
  if (a1[8] != 4)
  {
    ERR_put_error(6, 4095, 151, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/pmeth_gn.c", 146);
    return 0xFFFFFFFFLL;
  }
  if (!a2)
    return 0xFFFFFFFFLL;
  if (!*a2)
  {
    *a2 = EVP_PKEY_new();
    v3 = *(uint64_t (**)(_DWORD *))(*(_QWORD *)a1 + 56);
  }
  v5 = v3(a1);
  if ((int)v5 <= 0)
  {
    EVP_PKEY_free(*a2);
    *a2 = 0;
  }
  return v5;
}

uint64_t EVP_PKEY_CTX_set_cb(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 56) = a2;
  return result;
}

uint64_t EVP_PKEY_CTX_get_cb(uint64_t a1)
{
  return *(_QWORD *)(a1 + 56);
}

uint64_t evp_pkey_set_cb_translate(uint64_t a1, uint64_t a2)
{
  return BN_GENCB_set(a1, (uint64_t)trans_cb, a2);
}

uint64_t trans_cb(int a1, int a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t (*v4)(uint64_t);
  _DWORD *v5;

  v3 = *(_QWORD *)(a3 + 8);
  v4 = *(uint64_t (**)(uint64_t))(v3 + 56);
  v5 = *(_DWORD **)(v3 + 64);
  *v5 = a1;
  v5[1] = a2;
  return v4(v3);
}

uint64_t EVP_PKEY_CTX_get_keygen_info(uint64_t a1, unsigned int a2)
{
  if (a2 == -1)
    return *(unsigned int *)(a1 + 72);
  if ((a2 & 0x80000000) != 0 || *(_DWORD *)(a1 + 72) < (signed int)a2)
    return 0;
  return *(unsigned int *)(*(_QWORD *)(a1 + 64) + 4 * a2);
}

uint64_t *EVP_PKEY_new_mac_key(int a1, ENGINE *a2)
{
  uint64_t *result;
  uint64_t *v3;
  EVP_PKEY *v4;

  v4 = 0;
  result = (uint64_t *)EVP_PKEY_CTX_new_id(a1, a2);
  if (result)
  {
    v3 = result;
    if ((int)EVP_PKEY_keygen_init(result) >= 1 && (int)EVP_PKEY_CTX_ctrl(v3, -1, 4) >= 1)
      EVP_PKEY_keygen(v3, &v4);
    EVP_PKEY_CTX_free((EVP_PKEY **)v3);
    return (uint64_t *)v4;
  }
  return result;
}

uint64_t EVP_PKEY_check(_QWORD *a1)
{
  uint64_t v2;
  uint64_t (*v3)(void);
  uint64_t v5;

  v2 = a1[2];
  if (v2)
  {
    v3 = *(uint64_t (**)(void))(*a1 + 224);
    if (v3)
      return v3();
    v5 = *(_QWORD *)(v2 + 16);
    if (v5 && (v3 = *(uint64_t (**)(void))(v5 + 216)) != 0)
    {
      return v3();
    }
    else
    {
      ERR_put_error(6, 4095, 150, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/pmeth_gn.c", 241);
      return 4294967294;
    }
  }
  else
  {
    ERR_put_error(6, 4095, 154, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/pmeth_gn.c", 233);
    return 0;
  }
}

uint64_t EVP_PKEY_public_check(_QWORD *a1)
{
  uint64_t v2;
  uint64_t (*v3)(void);
  uint64_t v5;

  v2 = a1[2];
  if (v2)
  {
    v3 = *(uint64_t (**)(void))(*a1 + 232);
    if (v3)
      return v3();
    v5 = *(_QWORD *)(v2 + 16);
    if (v5 && (v3 = *(uint64_t (**)(void))(v5 + 224)) != 0)
    {
      return v3();
    }
    else
    {
      ERR_put_error(6, 4095, 150, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/pmeth_gn.c", 262);
      return 4294967294;
    }
  }
  else
  {
    ERR_put_error(6, 4095, 154, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/pmeth_gn.c", 254);
    return 0;
  }
}

uint64_t EVP_PKEY_param_check(_QWORD *a1)
{
  uint64_t v2;
  uint64_t (*v3)(void);
  uint64_t v5;

  v2 = a1[2];
  if (v2)
  {
    v3 = *(uint64_t (**)(void))(*a1 + 240);
    if (v3)
      return v3();
    v5 = *(_QWORD *)(v2 + 16);
    if (v5 && (v3 = *(uint64_t (**)(void))(v5 + 232)) != 0)
    {
      return v3();
    }
    else
    {
      ERR_put_error(6, 4095, 150, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/pmeth_gn.c", 283);
      return 4294967294;
    }
  }
  else
  {
    ERR_put_error(6, 4095, 154, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/pmeth_gn.c", 275);
    return 0;
  }
}

void RC2_ecb_encrypt(const unsigned __int8 *in, unsigned __int8 *out, RC2_KEY *key, int enc)
{
  __int128 v5;
  int v6;
  __int128 v7;
  uint64_t v8;

  v8 = *MEMORY[0x24BDAC8D0];
  *(_QWORD *)&v5 = *(_QWORD *)in;
  *((_QWORD *)&v5 + 1) = HIDWORD(*(_QWORD *)in);
  v7 = v5;
  if (enc)
    RC2_encrypt((unint64_t *)&v7, key);
  else
    RC2_decrypt((unint64_t *)&v7, key);
  v6 = DWORD2(v7);
  *(_DWORD *)out = v7;
  *((_DWORD *)out + 1) = v6;
}

unint64_t *bn_mul_comba4(unint64_t *result, _QWORD *a2, _QWORD *a3)
{
  uint64_t v3;
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  uint64_t v19;
  unint64_t v20;
  unint64_t v21;
  unsigned int v22;
  unint64_t v23;
  unint64_t v24;
  unint64_t v25;
  unint64_t v26;
  unint64_t v27;
  unint64_t v28;
  unint64_t v29;
  unint64_t v30;
  unint64_t v31;
  unint64_t v32;
  unint64_t v33;
  unint64_t v34;
  unint64_t v35;
  unint64_t v36;
  unint64_t v37;
  unint64_t v38;
  unint64_t v39;
  uint64_t v40;
  unint64_t v41;
  unint64_t v42;
  unint64_t v43;
  unint64_t v44;
  unint64_t v45;
  unint64_t v46;
  unint64_t v47;
  unint64_t v48;
  unint64_t v49;
  unint64_t v50;
  unint64_t v51;
  unint64_t v52;
  unint64_t v53;
  unint64_t v54;
  unint64_t v55;
  unint64_t v56;
  unint64_t v57;
  unint64_t v58;
  unint64_t v59;
  unint64_t v60;
  unint64_t v61;
  unint64_t v62;
  unint64_t v63;
  uint64_t v64;
  unint64_t v65;
  unint64_t v66;
  unint64_t v67;
  unint64_t v68;
  unint64_t v69;
  unint64_t v70;
  unint64_t v71;
  unint64_t v72;
  unint64_t v73;
  unint64_t v74;
  unint64_t v75;
  unint64_t v76;
  unint64_t v77;
  unint64_t v78;
  unint64_t v79;
  unint64_t v80;
  unint64_t v81;
  unint64_t v82;
  unint64_t v83;
  unint64_t v84;
  unint64_t v85;
  unint64_t v86;
  unint64_t v87;
  unint64_t v88;
  unint64_t v89;
  unint64_t v90;
  unint64_t v91;
  unint64_t v92;
  unint64_t v93;
  unint64_t v94;
  unint64_t v95;
  unint64_t v96;
  unint64_t v97;
  unint64_t v98;
  unint64_t v99;
  unint64_t v100;
  unint64_t v101;
  unint64_t v102;
  unint64_t v103;
  unint64_t v104;
  unint64_t v105;
  unint64_t v106;
  uint64_t v107;
  unint64_t v108;
  unint64_t v109;
  unint64_t v110;
  unint64_t v111;
  unint64_t v112;
  unint64_t v113;
  unint64_t v114;
  unint64_t v115;
  unint64_t v116;
  unint64_t v117;
  unint64_t v118;
  unint64_t v119;
  unint64_t v120;
  unint64_t v121;
  unint64_t v122;
  unint64_t v123;
  unint64_t v124;
  unint64_t v125;
  unint64_t v126;
  unint64_t v127;
  unint64_t v128;
  unint64_t v129;
  uint64_t v130;
  unint64_t v131;
  unint64_t v132;
  unint64_t v133;
  unint64_t v134;
  unint64_t v135;
  unint64_t v136;
  unint64_t v137;
  unint64_t v138;
  unint64_t v139;
  unint64_t v140;
  unint64_t v141;
  unint64_t v142;
  unint64_t v143;
  unint64_t v144;
  unint64_t v145;
  unint64_t v146;
  unint64_t v147;
  unint64_t v148;
  unint64_t v149;
  unint64_t v150;
  unint64_t v151;
  unint64_t v152;
  unint64_t v153;
  unint64_t v154;
  unint64_t v155;
  unint64_t v156;
  unint64_t v157;
  unint64_t v158;
  unint64_t v159;
  unint64_t v160;
  unint64_t v161;
  unint64_t v162;
  unint64_t v163;
  unint64_t v164;
  unint64_t v165;
  unint64_t v166;
  unint64_t v167;
  unint64_t v168;
  unint64_t v169;
  unint64_t v170;
  unint64_t v171;
  unint64_t v172;
  unint64_t v173;
  unint64_t v174;
  unint64_t v175;
  unint64_t v176;
  unint64_t v177;
  unint64_t v178;
  unint64_t v179;
  unint64_t v180;
  unint64_t v181;
  unint64_t v182;
  unint64_t v183;
  unint64_t v184;
  unint64_t v185;
  unint64_t v186;
  unint64_t v187;
  unint64_t v188;
  unint64_t v189;
  unint64_t v190;
  unint64_t v191;
  unint64_t v192;
  unint64_t v193;
  unint64_t v194;
  unint64_t v195;
  unint64_t v196;
  unint64_t v197;
  uint64_t v198;
  unint64_t v199;
  unint64_t v200;
  unint64_t v201;
  unint64_t v202;
  unint64_t v203;
  unint64_t v204;
  unint64_t v205;
  unint64_t v206;
  unint64_t v207;
  unint64_t v208;
  unint64_t v209;
  unint64_t v210;
  unint64_t v211;
  unint64_t v212;
  unint64_t v213;
  unint64_t v214;
  unint64_t v215;
  unint64_t v216;
  unint64_t v217;
  unint64_t v218;
  unint64_t v219;
  unint64_t v220;
  unint64_t v221;
  unint64_t v222;
  unint64_t v223;
  unint64_t v224;
  unint64_t v225;
  unint64_t v226;
  unint64_t v227;
  unint64_t v228;
  unint64_t v229;
  unint64_t v230;
  unint64_t v231;
  unint64_t v232;
  unint64_t v233;
  unint64_t v234;
  unint64_t v235;
  unint64_t v236;
  unint64_t v237;
  unint64_t v238;
  unint64_t v239;
  unint64_t v240;
  unint64_t v241;
  unint64_t v242;
  unint64_t v243;
  unint64_t v244;
  unint64_t v245;
  unint64_t v246;
  unint64_t v247;
  unint64_t v248;
  unint64_t v249;
  unint64_t v250;
  unint64_t v251;
  unint64_t v252;
  unint64_t v253;
  unint64_t v254;
  unint64_t v255;
  unint64_t v256;
  unint64_t v257;
  unint64_t v258;
  uint64_t v259;
  unint64_t v260;
  unint64_t v261;
  unint64_t v262;
  unint64_t v263;
  unint64_t v264;
  unint64_t v265;
  unint64_t v266;
  unint64_t v267;
  unint64_t v268;
  unint64_t v269;
  unint64_t v270;
  unint64_t v271;
  unint64_t v272;
  unint64_t v273;
  unint64_t v274;
  unint64_t v275;
  unint64_t v276;
  unint64_t v277;
  unint64_t v278;
  unint64_t v279;
  unint64_t v280;
  unint64_t v281;
  unint64_t v282;
  unint64_t v283;
  unint64_t v284;
  unint64_t v285;
  unint64_t v286;
  unint64_t v287;
  unint64_t v288;
  unint64_t v289;
  unint64_t v290;
  unint64_t v291;
  unint64_t v292;
  unint64_t v293;
  unint64_t v294;
  unint64_t v295;
  unint64_t v296;
  unint64_t v297;
  unint64_t v298;
  unint64_t v299;
  unint64_t v300;
  unint64_t v301;
  unint64_t v302;
  unint64_t v303;
  unint64_t v304;
  unint64_t v305;
  unint64_t v306;
  unint64_t v307;
  unint64_t v308;
  unint64_t v309;
  unint64_t v310;
  unint64_t v311;
  unint64_t v312;
  unint64_t v313;
  unint64_t v314;
  unint64_t v315;
  unint64_t v316;
  unint64_t v317;
  unint64_t v318;
  unint64_t v319;
  unint64_t v320;
  unint64_t v321;
  unint64_t v322;
  unint64_t v323;
  unint64_t v324;
  unint64_t v325;
  unint64_t v326;
  unint64_t v327;
  unint64_t v328;
  unint64_t v329;
  unint64_t v330;
  unint64_t v331;
  unint64_t v332;
  unint64_t v333;
  unint64_t v334;
  unint64_t v335;
  unint64_t v336;
  unint64_t v337;
  unint64_t v338;
  unint64_t v339;
  unint64_t v340;
  unint64_t v341;
  unint64_t v342;
  unint64_t v343;
  unint64_t v344;
  unint64_t v345;
  unint64_t v346;
  unint64_t v347;
  unint64_t v348;

  v3 = HIDWORD(*a2);
  v4 = *a3 * (unint64_t)*a2;
  v5 = *a3 * (unint64_t)v3;
  v6 = v4 | (v5 << 32);
  v7 = HIDWORD(*a3);
  v8 = HIDWORD(v5);
  v9 = v4 & (v5 << 32);
  v10 = (v5 << 32) + *a3 * (unint64_t)*a2;
  v11 = v7 * (unint64_t)*a2;
  v12 = v10 | (v11 << 32);
  v13 = v8 + v7 * (unint64_t)v3;
  v14 = v6 & ~v10;
  v15 = v10 & (v11 << 32);
  v16 = v10 + (v11 << 32);
  v17 = v13 + HIDWORD(v11) + ((v14 | v9) >> 63) + ((v12 & ~v16 | v15) >> 63);
  *result = v16;
  v18 = a2[1];
  v19 = HIDWORD(*a2);
  LODWORD(v9) = *a2;
  v20 = a3[1];
  v21 = HIDWORD(v20);
  v22 = v20;
  v23 = v20 * (unint64_t)v9;
  v24 = v20 * (unint64_t)v19;
  v25 = HIDWORD(v24) + v21 * (unint64_t)v19;
  v26 = v23 | (v24 << 32);
  v27 = v23 & (v24 << 32);
  v28 = (v24 << 32) + v22 * (unint64_t)v9;
  v29 = v26 & ~v28 | v27;
  v30 = v21 * (unint64_t)v9;
  v31 = v28 | (v30 << 32);
  v32 = v28 & (v30 << 32);
  v33 = v28 + (v30 << 32);
  v34 = v25 + HIDWORD(v30) + (v29 >> 63) + ((v31 & ~v33 | v32) >> 63);
  v35 = v17 | v33;
  v36 = v17 & v33;
  v37 = v17 + v33;
  v38 = v34 + ((v35 & ~v37 | v36) >> 63);
  v39 = HIDWORD(v18);
  LODWORD(v36) = v18;
  v40 = HIDWORD(*a3);
  LODWORD(v31) = *a3;
  v41 = v31 * (unint64_t)v18;
  v42 = v31 * (unint64_t)v39;
  v43 = HIDWORD(v42) + v40 * (unint64_t)v39;
  v44 = v41 | (v42 << 32);
  v45 = v41 & (v42 << 32);
  v46 = (v42 << 32) + v31 * (unint64_t)v36;
  v47 = v44 & ~v46 | v45;
  v48 = v40 * (unint64_t)v36;
  v49 = v46 | (v48 << 32);
  v50 = v46 & (v48 << 32);
  v51 = v46 + (v48 << 32);
  v52 = v43 + HIDWORD(v48) + (v47 >> 63) + ((v49 & ~v51 | v50) >> 63);
  v53 = v51 | v37;
  v54 = v51 & v37;
  v55 = v51 + v37;
  v56 = v52 + ((v53 & ~v55 | v54) >> 63);
  v57 = v56 | v38;
  v58 = v56 & v38;
  v59 = v56 + v38;
  v60 = v57 & ~v59 | v58;
  result[1] = v55;
  v61 = a2[2];
  v62 = HIDWORD(v61);
  LODWORD(v58) = v61;
  v63 = a3[1];
  v64 = HIDWORD(*a3);
  LODWORD(v32) = *a3;
  v65 = v32 * (unint64_t)v61;
  v66 = v32 * (unint64_t)v62;
  v67 = HIDWORD(v66) + v64 * (unint64_t)v62;
  v68 = v65 | (v66 << 32);
  v69 = v65 & (v66 << 32);
  v70 = (v66 << 32) + v32 * (unint64_t)v58;
  v71 = v68 & ~v70 | v69;
  v72 = v64 * (unint64_t)v58;
  v73 = v70 | (v72 << 32);
  v74 = v70 & (v72 << 32);
  v75 = v70 + (v72 << 32);
  v76 = v67 + HIDWORD(v72) + (v71 >> 63) + ((v73 & ~v75 | v74) >> 63);
  v77 = v59 | v75;
  v78 = v59 & v75;
  v79 = v59 + v75;
  v80 = v76 + ((v77 & ~v79 | v78) >> 63);
  v81 = v80 + (v60 >> 63);
  v82 = v80 & ~v81;
  v83 = a2[1];
  v84 = HIDWORD(v83);
  LODWORD(v73) = v83;
  v85 = HIDWORD(v63);
  LODWORD(v44) = v63;
  v86 = v63 * (unint64_t)v83;
  v87 = v63 * (unint64_t)v84;
  v88 = HIDWORD(v87) + v85 * (unint64_t)v84;
  v89 = v86 | (v87 << 32);
  v90 = v86 & (v87 << 32);
  v91 = (v87 << 32) + v44 * (unint64_t)v73;
  v92 = v89 & ~v91 | v90;
  v93 = v85 * (unint64_t)v73;
  v94 = v91 | (v93 << 32);
  v95 = v91 & (v93 << 32);
  v96 = v91 + (v93 << 32);
  v97 = v88 + HIDWORD(v93) + (v92 >> 63) + ((v94 & ~v96 | v95) >> 63);
  v98 = v79 | v96;
  v99 = v79 & v96;
  v100 = v79 + v96;
  v101 = v97 + ((v98 & ~v100 | v99) >> 63);
  v102 = v101 | v81;
  v103 = v101 & v81;
  v104 = v101 + v81;
  v105 = ((v102 & ~v104 | v103) >> 63) + (v82 >> 63);
  v106 = a3[2];
  v107 = HIDWORD(*a2);
  LODWORD(v103) = *a2;
  v108 = HIDWORD(v106);
  LODWORD(v94) = v106;
  v109 = v106 * (unint64_t)v103;
  v110 = v94 * (unint64_t)v107;
  v111 = HIDWORD(v110) + v108 * (unint64_t)v107;
  v112 = v109 | (v110 << 32);
  v113 = v109 & (v110 << 32);
  v114 = (v110 << 32) + v94 * (unint64_t)v103;
  v115 = v112 & ~v114 | v113;
  v116 = v108 * (unint64_t)v103;
  v117 = v114 | (v116 << 32);
  v118 = v114 & (v116 << 32);
  v119 = v114 + (v116 << 32);
  v120 = v111 + HIDWORD(v116) + (v115 >> 63) + ((v117 & ~v119 | v118) >> 63);
  v121 = v100 | v119;
  v122 = v100 & v119;
  v123 = v100 + v119;
  v124 = v120 + ((v121 & ~v123 | v122) >> 63);
  v125 = v124 | v104;
  v126 = v124 & v104;
  v127 = v124 + v104;
  v128 = v105 + ((v125 & ~v127 | v126) >> 63);
  result[2] = v123;
  v129 = a2[1];
  v130 = HIDWORD(*a2);
  LODWORD(v126) = *a2;
  v132 = a3[2];
  v131 = a3[3];
  v133 = HIDWORD(v131);
  LODWORD(v95) = v131;
  v134 = v131 * (unint64_t)v126;
  v135 = v131 * (unint64_t)v130;
  v136 = HIDWORD(v135) + v133 * (unint64_t)v130;
  v137 = v134 | (v135 << 32);
  v138 = v134 & (v135 << 32);
  v139 = (v135 << 32) + v95 * (unint64_t)v126;
  v140 = v137 & ~v139 | v138;
  v141 = v133 * (unint64_t)v126;
  v142 = v139 | (v141 << 32);
  v143 = v139 & (v141 << 32);
  v144 = v139 + (v141 << 32);
  v145 = v136 + HIDWORD(v141) + (v140 >> 63) + ((v142 & ~v144 | v143) >> 63);
  v146 = v127 | v144;
  v147 = v127 & v144;
  v148 = v127 + v144;
  v149 = v145 + ((v146 & ~v148 | v147) >> 63);
  v150 = v128 + v149;
  v151 = v149 & ~(v128 + v149);
  v152 = HIDWORD(v129);
  LODWORD(v149) = v129;
  v153 = HIDWORD(v132);
  LODWORD(v142) = v132;
  v154 = v132 * (unint64_t)v129;
  v155 = v132 * (unint64_t)v152;
  v156 = HIDWORD(v155) + v153 * (unint64_t)v152;
  v157 = v154 | (v155 << 32);
  v158 = v154 & (v155 << 32);
  v159 = (v155 << 32) + v142 * (unint64_t)v149;
  v160 = v157 & ~v159 | v158;
  v161 = v153 * (unint64_t)v149;
  v162 = v159 | (v161 << 32);
  v163 = v159 & (v161 << 32);
  v164 = v159 + (v161 << 32);
  v165 = v156 + HIDWORD(v161) + (v160 >> 63) + ((v162 & ~v164 | v163) >> 63);
  v166 = v148 + v164;
  v167 = v165 + (((v148 | v164) & ~(v148 + v164) | v148 & v164) >> 63);
  v168 = v167 | v150;
  v169 = v167 & v150;
  v170 = v167 + v150;
  v171 = ((v168 & ~v170 | v169) >> 63) + (v151 >> 63);
  v172 = a2[2];
  v173 = a2[3];
  v174 = HIDWORD(v172);
  LODWORD(v162) = v172;
  v175 = a3[1];
  v176 = HIDWORD(v175);
  LODWORD(v157) = v175;
  v177 = v175 * (unint64_t)v172;
  v178 = v175 * (unint64_t)v174;
  v179 = HIDWORD(v178) + v176 * (unint64_t)v174;
  v180 = v177 | (v178 << 32);
  v181 = v177 & (v178 << 32);
  v182 = (v178 << 32) + v157 * (unint64_t)v162;
  v183 = v180 & ~v182 | v181;
  v184 = v176 * (unint64_t)v162;
  v185 = v182 | (v184 << 32);
  v186 = v182 & (v184 << 32);
  v187 = v182 + (v184 << 32);
  v188 = v179 + HIDWORD(v184) + (v183 >> 63) + ((v185 & ~v187 | v186) >> 63);
  v189 = v166 | v187;
  v190 = v166 & v187;
  v191 = v166 + v187;
  v192 = v188 + ((v189 & ~v191 | v190) >> 63);
  v193 = v192 | v170;
  v194 = v192 & v170;
  v195 = v192 + v170;
  v196 = v171 + ((v193 & ~v195 | v194) >> 63);
  v197 = HIDWORD(v173);
  LODWORD(v193) = v173;
  v198 = HIDWORD(*a3);
  LODWORD(v187) = *a3;
  v199 = v187 * (unint64_t)v173;
  v200 = v187 * (unint64_t)v197;
  v201 = HIDWORD(v200) + v198 * (unint64_t)v197;
  v202 = (v200 << 32) + v187 * (unint64_t)v193;
  v203 = (v199 | (v200 << 32)) & ~v202 | v199 & (v200 << 32);
  v204 = v198 * (unint64_t)v193;
  v205 = v202 | (v204 << 32);
  v206 = v202 & (v204 << 32);
  v207 = v202 + (v204 << 32);
  v208 = v201 + HIDWORD(v204) + (v203 >> 63) + ((v205 & ~v207 | v206) >> 63);
  v209 = v191 | v207;
  v210 = v191 & v207;
  v211 = v191 + v207;
  v212 = v208 + ((v209 & ~v211 | v210) >> 63);
  v213 = v212 | v195;
  v214 = v212 & v195;
  v215 = v212 + v195;
  v216 = v196 + ((v213 & ~v215 | v214) >> 63);
  result[3] = v211;
  v217 = a2[3];
  v218 = HIDWORD(v217);
  LODWORD(v213) = v217;
  v219 = a3[1];
  v220 = a3[2];
  v221 = HIDWORD(v219);
  LODWORD(v206) = v219;
  v222 = v219 * (unint64_t)v217;
  v223 = v219 * (unint64_t)v218;
  v224 = HIDWORD(v223) + v221 * (unint64_t)v218;
  v225 = v222 | (v223 << 32);
  v226 = v222 & (v223 << 32);
  v227 = (v223 << 32) + v206 * (unint64_t)v213;
  v228 = v225 & ~v227 | v226;
  v229 = v221 * (unint64_t)v213;
  v230 = v227 | (v229 << 32);
  v231 = v227 & (v229 << 32);
  v232 = v227 + (v229 << 32);
  v233 = v224 + HIDWORD(v229) + (v228 >> 63) + ((v230 & ~v232 | v231) >> 63);
  v234 = v215 | v232;
  v235 = v215 & v232;
  v236 = v215 + v232;
  v237 = v233 + ((v234 & ~v236 | v235) >> 63);
  v238 = v237 | v216;
  v239 = v237 + v216;
  v240 = v238 & ~v239;
  v242 = a2[1];
  v241 = a2[2];
  v243 = HIDWORD(v241);
  LODWORD(v230) = v241;
  v244 = HIDWORD(v220);
  LODWORD(v185) = v220;
  v245 = v220 * (unint64_t)v241;
  v246 = v220 * (unint64_t)v243;
  v247 = HIDWORD(v246) + v244 * (unint64_t)v243;
  v248 = v245 | (v246 << 32);
  v249 = v245 & (v246 << 32);
  v250 = (v246 << 32) + v185 * (unint64_t)v230;
  v251 = v248 & ~v250 | v249;
  v252 = v244 * (unint64_t)v230;
  v253 = v250 | (v252 << 32);
  v254 = v250 & (v252 << 32);
  v255 = v250 + (v252 << 32);
  v256 = v247 + HIDWORD(v252) + (v251 >> 63) + ((v253 & ~v255 | v254) >> 63);
  v257 = v236 | v255;
  v258 = v236 & v255;
  v259 = v236 + v255;
  v260 = v256 + ((v257 & ~v259 | v258) >> 63);
  v261 = v260 | v239;
  v262 = v260 & v239;
  v263 = v260 + v239;
  v264 = ((v261 & ~v263 | v262) >> 63) + (v240 >> 63);
  v265 = a3[3];
  v266 = HIDWORD(v242);
  LODWORD(v262) = v242;
  v267 = HIDWORD(v265);
  LODWORD(v253) = v265;
  v268 = v265 * (unint64_t)v242;
  v269 = v253 * (unint64_t)HIDWORD(v242);
  v270 = HIDWORD(v269) + v267 * (unint64_t)v266;
  v271 = v268 | (v269 << 32);
  v272 = v268 & (v269 << 32);
  v273 = (v269 << 32) + v253 * (unint64_t)v262;
  v274 = v271 & ~v273 | v272;
  v275 = v267 * (unint64_t)v262;
  v276 = v273 | (v275 << 32);
  v277 = v273 & (v275 << 32);
  v278 = v273 + (v275 << 32);
  v279 = v270 + HIDWORD(v275) + (v274 >> 63) + ((v276 & ~v278 | v277) >> 63);
  v280 = v259 | v278;
  v281 = v259 & v278;
  v282 = v259 + v278;
  v283 = v279 + ((v280 & ~v282 | v281) >> 63);
  v284 = v283 | v263;
  v285 = v283 & v263;
  v286 = v283 + v263;
  v287 = v264 + ((v284 & ~v286 | v285) >> 63);
  result[4] = v282;
  v288 = a2[2];
  v289 = a2[3];
  v290 = HIDWORD(v288);
  LODWORD(v285) = v288;
  v292 = a3[2];
  v291 = a3[3];
  v293 = HIDWORD(v291);
  LODWORD(v254) = v291;
  v294 = v291 * (unint64_t)v288;
  v295 = v291 * (unint64_t)v290;
  v296 = HIDWORD(v295) + v293 * (unint64_t)v290;
  v297 = v294 | (v295 << 32);
  v298 = v294 & (v295 << 32);
  v299 = (v295 << 32) + v254 * (unint64_t)v285;
  v300 = v297 & ~v299 | v298;
  v301 = v293 * (unint64_t)v285;
  v302 = v299 | (v301 << 32);
  v303 = v299 & (v301 << 32);
  v304 = v299 + (v301 << 32);
  v305 = v296 + HIDWORD(v301) + (v300 >> 63) + ((v302 & ~v304 | v303) >> 63);
  v306 = v286 | v304;
  v307 = v286 & v304;
  v308 = v286 + v304;
  v309 = v305 + ((v306 & ~v308 | v307) >> 63);
  v310 = v287 + v309;
  v311 = v309 & ~(v287 + v309);
  v312 = HIDWORD(v289);
  LODWORD(v306) = v289;
  v313 = HIDWORD(v292);
  LODWORD(v302) = v292;
  v314 = v292 * (unint64_t)v289;
  v315 = v292 * (unint64_t)v312;
  v316 = HIDWORD(v315) + v313 * (unint64_t)v312;
  v317 = v314 | (v315 << 32);
  v318 = v314 & (v315 << 32);
  v319 = (v315 << 32) + v302 * (unint64_t)v306;
  v320 = v317 & ~v319 | v318;
  v321 = v313 * (unint64_t)v306;
  v322 = v319 | (v321 << 32);
  v323 = v319 & (v321 << 32);
  v324 = v319 + (v321 << 32);
  v325 = v316
       + HIDWORD(v321)
       + (v320 >> 63)
       + ((v322 & ~v324 | v323) >> 63)
       + (((v308 | v324) & ~(v308 + v324) | v308 & v324) >> 63);
  v326 = v325 | v310;
  v327 = v325 & v310;
  v328 = v325 + v310;
  v329 = v326 & ~v328 | v327;
  result[5] = v308 + v324;
  v330 = a2[3];
  v331 = a3[3];
  v332 = HIDWORD(v330);
  LODWORD(v308) = v330;
  v333 = HIDWORD(v331);
  LODWORD(v323) = v331;
  v334 = v331 * (unint64_t)v330;
  v335 = v331 * (unint64_t)v332;
  v336 = HIDWORD(v335) + v333 * (unint64_t)v332;
  v337 = v334 | (v335 << 32);
  v338 = v334 & (v335 << 32);
  v339 = (v335 << 32) + v323 * (unint64_t)v308;
  v340 = v337 & ~v339 | v338;
  v341 = v333 * (unint64_t)v308;
  v342 = v339 | (v341 << 32);
  v343 = v339 & (v341 << 32);
  v344 = v339 + (v341 << 32);
  v345 = v336 + HIDWORD(v341) + (v340 >> 63) + ((v342 & ~v344 | v343) >> 63);
  v346 = v328 | v344;
  v347 = v328 & v344;
  v348 = v328 + v344;
  result[6] = v348;
  result[7] = v345 + (v311 >> 63) + (v329 >> 63) + ((v346 & ~v348 | v347) >> 63);
  return result;
}

unint64_t *bn_mul_comba8(unint64_t *result, _QWORD *a2, _QWORD *a3)
{
  uint64_t v3;
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  uint64_t v19;
  unint64_t v20;
  unint64_t v21;
  unsigned int v22;
  unint64_t v23;
  unint64_t v24;
  unint64_t v25;
  unint64_t v26;
  unint64_t v27;
  unint64_t v28;
  unint64_t v29;
  unint64_t v30;
  unint64_t v31;
  unint64_t v32;
  unint64_t v33;
  unint64_t v34;
  unint64_t v35;
  unint64_t v36;
  unint64_t v37;
  unint64_t v38;
  unint64_t v39;
  uint64_t v40;
  unint64_t v41;
  unint64_t v42;
  unint64_t v43;
  unint64_t v44;
  unint64_t v45;
  unint64_t v46;
  unint64_t v47;
  unint64_t v48;
  unint64_t v49;
  unint64_t v50;
  unint64_t v51;
  unint64_t v52;
  unint64_t v53;
  unint64_t v54;
  unint64_t v55;
  unint64_t v56;
  unint64_t v57;
  unint64_t v58;
  unint64_t v59;
  unint64_t v60;
  unint64_t v61;
  unint64_t v62;
  unint64_t v63;
  uint64_t v64;
  unint64_t v65;
  unint64_t v66;
  unint64_t v67;
  unint64_t v68;
  unint64_t v69;
  unint64_t v70;
  unint64_t v71;
  unint64_t v72;
  unint64_t v73;
  unint64_t v74;
  unint64_t v75;
  unint64_t v76;
  unint64_t v77;
  unint64_t v78;
  unint64_t v79;
  unint64_t v80;
  unint64_t v81;
  unint64_t v82;
  unint64_t v83;
  unint64_t v84;
  unint64_t v85;
  unint64_t v86;
  unint64_t v87;
  unint64_t v88;
  unint64_t v89;
  unint64_t v90;
  unint64_t v91;
  unint64_t v92;
  unint64_t v93;
  unint64_t v94;
  unint64_t v95;
  unint64_t v96;
  unint64_t v97;
  unint64_t v98;
  unint64_t v99;
  unint64_t v100;
  unint64_t v101;
  unint64_t v102;
  unint64_t v103;
  unint64_t v104;
  unint64_t v105;
  unint64_t v106;
  uint64_t v107;
  unint64_t v108;
  unint64_t v109;
  unint64_t v110;
  unint64_t v111;
  unint64_t v112;
  unint64_t v113;
  unint64_t v114;
  unint64_t v115;
  unint64_t v116;
  unint64_t v117;
  unint64_t v118;
  unint64_t v119;
  unint64_t v120;
  unint64_t v121;
  unint64_t v122;
  unint64_t v123;
  unint64_t v124;
  unint64_t v125;
  unint64_t v126;
  unint64_t v127;
  unint64_t v128;
  unint64_t v129;
  uint64_t v130;
  unint64_t v131;
  unint64_t v132;
  unint64_t v133;
  unint64_t v134;
  unint64_t v135;
  unint64_t v136;
  unint64_t v137;
  unint64_t v138;
  unint64_t v139;
  unint64_t v140;
  unint64_t v141;
  unint64_t v142;
  unint64_t v143;
  unint64_t v144;
  unint64_t v145;
  unint64_t v146;
  unint64_t v147;
  unint64_t v148;
  unint64_t v149;
  unint64_t v150;
  unint64_t v151;
  unint64_t v152;
  unint64_t v153;
  unint64_t v154;
  unint64_t v155;
  unint64_t v156;
  unint64_t v157;
  unint64_t v158;
  unint64_t v159;
  unint64_t v160;
  unint64_t v161;
  unint64_t v162;
  unint64_t v163;
  unint64_t v164;
  unint64_t v165;
  unint64_t v166;
  unint64_t v167;
  unint64_t v168;
  unint64_t v169;
  unint64_t v170;
  unint64_t v171;
  unint64_t v172;
  unint64_t v173;
  unint64_t v174;
  unint64_t v175;
  unint64_t v176;
  unint64_t v177;
  unint64_t v178;
  unint64_t v179;
  unint64_t v180;
  unint64_t v181;
  unint64_t v182;
  unint64_t v183;
  unint64_t v184;
  unint64_t v185;
  unint64_t v186;
  unint64_t v187;
  unint64_t v188;
  unint64_t v189;
  unint64_t v190;
  unint64_t v191;
  unint64_t v192;
  unint64_t v193;
  unint64_t v194;
  unint64_t v195;
  unint64_t v196;
  unint64_t v197;
  uint64_t v198;
  unint64_t v199;
  unint64_t v200;
  unint64_t v201;
  unint64_t v202;
  unint64_t v203;
  unint64_t v204;
  unint64_t v205;
  unint64_t v206;
  unint64_t v207;
  unint64_t v208;
  unint64_t v209;
  unint64_t v210;
  unint64_t v211;
  unint64_t v212;
  unint64_t v213;
  unint64_t v214;
  unint64_t v215;
  unint64_t v216;
  unint64_t v217;
  unint64_t v218;
  unint64_t v219;
  uint64_t v220;
  unint64_t v221;
  unint64_t v222;
  unint64_t v223;
  unint64_t v224;
  unint64_t v225;
  unint64_t v226;
  unint64_t v227;
  unint64_t v228;
  unint64_t v229;
  unint64_t v230;
  unint64_t v231;
  unint64_t v232;
  unint64_t v233;
  unint64_t v234;
  unint64_t v235;
  unint64_t v236;
  unint64_t v237;
  unint64_t v238;
  unint64_t v239;
  unint64_t v240;
  unint64_t v241;
  unint64_t v242;
  unint64_t v243;
  unint64_t v244;
  unint64_t v245;
  unint64_t v246;
  unint64_t v247;
  unint64_t v248;
  unint64_t v249;
  unint64_t v250;
  unint64_t v251;
  unint64_t v252;
  unint64_t v253;
  unint64_t v254;
  unint64_t v255;
  unint64_t v256;
  unint64_t v257;
  uint64_t v258;
  unint64_t v259;
  unint64_t v260;
  unint64_t v261;
  unint64_t v262;
  unint64_t v263;
  unint64_t v264;
  unint64_t v265;
  unint64_t v266;
  unint64_t v267;
  unint64_t v268;
  unint64_t v269;
  unint64_t v270;
  unint64_t v271;
  unint64_t v272;
  unint64_t v273;
  unint64_t v274;
  unint64_t v275;
  unint64_t v276;
  unint64_t v277;
  unint64_t v278;
  unint64_t v279;
  unint64_t v280;
  unint64_t v281;
  uint64_t v282;
  unint64_t v283;
  unint64_t v284;
  unint64_t v285;
  unint64_t v286;
  unint64_t v287;
  unint64_t v288;
  unint64_t v289;
  unint64_t v290;
  unint64_t v291;
  unint64_t v292;
  unint64_t v293;
  unint64_t v294;
  unint64_t v295;
  unint64_t v296;
  unint64_t v297;
  unint64_t v298;
  unint64_t v299;
  unint64_t v300;
  unint64_t v301;
  unint64_t v302;
  unint64_t v303;
  unint64_t v304;
  uint64_t v305;
  unint64_t v306;
  unint64_t v307;
  unint64_t v308;
  unint64_t v309;
  unint64_t v310;
  unint64_t v311;
  uint64_t v312;
  unint64_t v313;
  unint64_t v314;
  unint64_t v315;
  unint64_t v316;
  unint64_t v317;
  unint64_t v318;
  unint64_t v319;
  unint64_t v320;
  unint64_t v321;
  unint64_t v322;
  unint64_t v323;
  unint64_t v324;
  unint64_t v325;
  unint64_t v326;
  unint64_t v327;
  unint64_t v328;
  unint64_t v329;
  unint64_t v330;
  unint64_t v331;
  uint64_t v332;
  unint64_t v333;
  unint64_t v334;
  uint64_t v335;
  unint64_t v336;
  unint64_t v337;
  unint64_t v338;
  unint64_t v339;
  unint64_t v340;
  unint64_t v341;
  unint64_t v342;
  unint64_t v343;
  unint64_t v344;
  unint64_t v345;
  unint64_t v346;
  unint64_t v347;
  unint64_t v348;
  unint64_t v349;
  unint64_t v350;
  unint64_t v351;
  unint64_t v352;
  uint64_t v353;
  unint64_t v354;
  unint64_t v355;
  unint64_t v356;
  unint64_t v357;
  unint64_t v358;
  unint64_t v359;
  unint64_t v360;
  unint64_t v361;
  unint64_t v362;
  unint64_t v363;
  unint64_t v364;
  unint64_t v365;
  unint64_t v366;
  unint64_t v367;
  unint64_t v368;
  unint64_t v369;
  unint64_t v370;
  unint64_t v371;
  unint64_t v372;
  unint64_t v373;
  uint64_t v374;
  unint64_t v375;
  unint64_t v376;
  unint64_t v377;
  unint64_t v378;
  unint64_t v379;
  unint64_t v380;
  unint64_t v381;
  unint64_t v382;
  unint64_t v383;
  unint64_t v384;
  unint64_t v385;
  unint64_t v386;
  unint64_t v387;
  unint64_t v388;
  unint64_t v389;
  unint64_t v390;
  unint64_t v391;
  unint64_t v392;
  unint64_t v393;
  unint64_t v394;
  unint64_t v395;
  unint64_t v396;
  unint64_t v397;
  unint64_t v398;
  unint64_t v399;
  uint64_t v400;
  unint64_t v401;
  unint64_t v402;
  unint64_t v403;
  unint64_t v404;
  unint64_t v405;
  unint64_t v406;
  unint64_t v407;
  unint64_t v408;
  unint64_t v409;
  unint64_t v410;
  unint64_t v411;
  unint64_t v412;
  unint64_t v413;
  unint64_t v414;
  unint64_t v415;
  unint64_t v416;
  unint64_t v417;
  unint64_t v418;
  unint64_t v419;
  uint64_t v420;
  unint64_t v421;
  unint64_t v422;
  unint64_t v423;
  uint64_t v424;
  unint64_t v425;
  unint64_t v426;
  unint64_t v427;
  unint64_t v428;
  unint64_t v429;
  unint64_t v430;
  unint64_t v431;
  unint64_t v432;
  unint64_t v433;
  unint64_t v434;
  unint64_t v435;
  unint64_t v436;
  unint64_t v437;
  unint64_t v438;
  unint64_t v439;
  unint64_t v440;
  unint64_t v441;
  unint64_t v442;
  unint64_t v443;
  unint64_t v444;
  uint64_t v445;
  unint64_t v446;
  unint64_t v447;
  unint64_t v448;
  uint64_t v449;
  unint64_t v450;
  unint64_t v451;
  uint64_t v452;
  unint64_t v453;
  unint64_t v454;
  unint64_t v455;
  unint64_t v456;
  unint64_t v457;
  unint64_t v458;
  unint64_t v459;
  unint64_t v460;
  unint64_t v461;
  unint64_t v462;
  unint64_t v463;
  unint64_t v464;
  unint64_t v465;
  unint64_t v466;
  unint64_t v467;
  unint64_t v468;
  uint64_t v469;
  unint64_t v470;
  unint64_t v471;
  unint64_t v472;
  unint64_t v473;
  uint64_t v474;
  unint64_t v475;
  unint64_t v476;
  unint64_t v477;
  unint64_t v478;
  unint64_t v479;
  unint64_t v480;
  unint64_t v481;
  unint64_t v482;
  unint64_t v483;
  unint64_t v484;
  unint64_t v485;
  unint64_t v486;
  unint64_t v487;
  unint64_t v488;
  uint64_t v489;
  unint64_t v490;
  unint64_t v491;
  unint64_t v492;
  unint64_t v493;
  unint64_t v494;
  unint64_t v495;
  unint64_t v496;
  unint64_t v497;
  unint64_t v498;
  unint64_t v499;
  unint64_t v500;
  unint64_t v501;
  unint64_t v502;
  unint64_t v503;
  unint64_t v504;
  unint64_t v505;
  unint64_t v506;
  unint64_t v507;
  unint64_t v508;
  unint64_t v509;
  unint64_t v510;
  unint64_t v511;
  uint64_t v512;
  unint64_t v513;
  unint64_t v514;
  unint64_t v515;
  unint64_t v516;
  unint64_t v517;
  unint64_t v518;
  unint64_t v519;
  unint64_t v520;
  unint64_t v521;
  unint64_t v522;
  unint64_t v523;
  unint64_t v524;
  unint64_t v525;
  unint64_t v526;
  unint64_t v527;
  unint64_t v528;
  unint64_t v529;
  unint64_t v530;
  unint64_t v531;
  unint64_t v532;
  unint64_t v533;
  unint64_t v534;
  unint64_t v535;
  uint64_t v536;
  unint64_t v537;
  unint64_t v538;
  unint64_t v539;
  uint64_t v540;
  unint64_t v541;
  unint64_t v542;
  unint64_t v543;
  unint64_t v544;
  unint64_t v545;
  unint64_t v546;
  unint64_t v547;
  unint64_t v548;
  unint64_t v549;
  unint64_t v550;
  unint64_t v551;
  unint64_t v552;
  unint64_t v553;
  unint64_t v554;
  unint64_t v555;
  unint64_t v556;
  unint64_t v557;
  unint64_t v558;
  unint64_t v559;
  uint64_t v560;
  unint64_t v561;
  unint64_t v562;
  unint64_t v563;
  uint64_t v564;
  unint64_t v565;
  unint64_t v566;
  unint64_t v567;
  unint64_t v568;
  unint64_t v569;
  unint64_t v570;
  unint64_t v571;
  unint64_t v572;
  unint64_t v573;
  unint64_t v574;
  unint64_t v575;
  unint64_t v576;
  unint64_t v577;
  unint64_t v578;
  unint64_t v579;
  unint64_t v580;
  unint64_t v581;
  unint64_t v582;
  unint64_t v583;
  uint64_t v584;
  unint64_t v585;
  unint64_t v586;
  unint64_t v587;
  uint64_t v588;
  unint64_t v589;
  unint64_t v590;
  unint64_t v591;
  unint64_t v592;
  unint64_t v593;
  unint64_t v594;
  unint64_t v595;
  unint64_t v596;
  unint64_t v597;
  unint64_t v598;
  unint64_t v599;
  unint64_t v600;
  unint64_t v601;
  unint64_t v602;
  unint64_t v603;
  unint64_t v604;
  unint64_t v605;
  unint64_t v606;
  uint64_t v607;
  unint64_t v608;
  unint64_t v609;
  unint64_t v610;
  uint64_t v611;
  unint64_t v612;
  unint64_t v613;
  uint64_t v614;
  unint64_t v615;
  unint64_t v616;
  unint64_t v617;
  unint64_t v618;
  unint64_t v619;
  unint64_t v620;
  unint64_t v621;
  unint64_t v622;
  unint64_t v623;
  unint64_t v624;
  unint64_t v625;
  unint64_t v626;
  unint64_t v627;
  unint64_t v628;
  unint64_t v629;
  unint64_t v630;
  unint64_t v631;
  unint64_t v632;
  unint64_t v633;
  uint64_t v634;
  unint64_t v635;
  unint64_t v636;
  uint64_t v637;
  unint64_t v638;
  unint64_t v639;
  unint64_t v640;
  unint64_t v641;
  unint64_t v642;
  unint64_t v643;
  unint64_t v644;
  unint64_t v645;
  unint64_t v646;
  unint64_t v647;
  unint64_t v648;
  unint64_t v649;
  unint64_t v650;
  unint64_t v651;
  unint64_t v652;
  unint64_t v653;
  unint64_t v654;
  uint64_t v655;
  unint64_t v656;
  unint64_t v657;
  unint64_t v658;
  unint64_t v659;
  unint64_t v660;
  unint64_t v661;
  unint64_t v662;
  unint64_t v663;
  unint64_t v664;
  unint64_t v665;
  unint64_t v666;
  unint64_t v667;
  unint64_t v668;
  unint64_t v669;
  unint64_t v670;
  unint64_t v671;
  unint64_t v672;
  unint64_t v673;
  unint64_t v674;
  unint64_t v675;
  unint64_t v676;
  uint64_t v677;
  unint64_t v678;
  unint64_t v679;
  unint64_t v680;
  uint64_t v681;
  unint64_t v682;
  unint64_t v683;
  unint64_t v684;
  unint64_t v685;
  unint64_t v686;
  unint64_t v687;
  unint64_t v688;
  unint64_t v689;
  unint64_t v690;
  unint64_t v691;
  unint64_t v692;
  unint64_t v693;
  unint64_t v694;
  unint64_t v695;
  unint64_t v696;
  unint64_t v697;
  unint64_t v698;
  unint64_t v699;
  unint64_t v700;
  unint64_t v701;
  unint64_t v702;
  uint64_t v703;
  unint64_t v704;
  unint64_t v705;
  unint64_t v706;
  uint64_t v707;
  unint64_t v708;
  unint64_t v709;
  unint64_t v710;
  unint64_t v711;
  unint64_t v712;
  unint64_t v713;
  unint64_t v714;
  unint64_t v715;
  unint64_t v716;
  unint64_t v717;
  unint64_t v718;
  unint64_t v719;
  unint64_t v720;
  unint64_t v721;
  unint64_t v722;
  uint64_t v723;
  unint64_t v724;
  unint64_t v725;
  unint64_t v726;
  uint64_t v727;
  unint64_t v728;
  unint64_t v729;
  unint64_t v730;
  unint64_t v731;
  unint64_t v732;
  unint64_t v733;
  unint64_t v734;
  unint64_t v735;
  unint64_t v736;
  unint64_t v737;
  unint64_t v738;
  unint64_t v739;
  unint64_t v740;
  unint64_t v741;
  unint64_t v742;
  unint64_t v743;
  unint64_t v744;
  unint64_t v745;
  unint64_t v746;
  unint64_t v747;
  unint64_t v748;
  uint64_t v749;
  unint64_t v750;
  unint64_t v751;
  unint64_t v752;
  uint64_t v753;
  unint64_t v754;
  unint64_t v755;
  unint64_t v756;
  unint64_t v757;
  unint64_t v758;
  unint64_t v759;
  unint64_t v760;
  unint64_t v761;
  unint64_t v762;
  unint64_t v763;
  unint64_t v764;
  unint64_t v765;
  unint64_t v766;
  unint64_t v767;
  unint64_t v768;
  uint64_t v769;
  unint64_t v770;
  unint64_t v771;
  unint64_t v772;
  uint64_t v773;
  unint64_t v774;
  unint64_t v775;
  unint64_t v776;
  unint64_t v777;
  unint64_t v778;
  unint64_t v779;
  unint64_t v780;
  unint64_t v781;
  unint64_t v782;
  unint64_t v783;
  unint64_t v784;
  unint64_t v785;
  unint64_t v786;
  unint64_t v787;
  unint64_t v788;
  unint64_t v789;
  unint64_t v790;
  unint64_t v791;
  unint64_t v792;
  unint64_t v793;
  uint64_t v794;
  unint64_t v795;
  unint64_t v796;
  unint64_t v797;
  uint64_t v798;
  unint64_t v799;
  unint64_t v800;
  uint64_t v801;
  unint64_t v802;
  unint64_t v803;
  unint64_t v804;
  unint64_t v805;
  unint64_t v806;
  unint64_t v807;
  unint64_t v808;
  unint64_t v809;
  unint64_t v810;
  unint64_t v811;
  unint64_t v812;
  unint64_t v813;
  unint64_t v814;
  unint64_t v815;
  uint64_t v816;
  unint64_t v817;
  unint64_t v818;
  unint64_t v819;
  unint64_t v820;
  unint64_t v821;
  unint64_t v822;
  unint64_t v823;
  unint64_t v824;
  unint64_t v825;
  unint64_t v826;
  unint64_t v827;
  unint64_t v828;
  unint64_t v829;
  unint64_t v830;
  unint64_t v831;
  unint64_t v832;
  unint64_t v833;
  unint64_t v834;
  unint64_t v835;
  unint64_t v836;
  uint64_t v837;
  unint64_t v838;
  unint64_t v839;
  unint64_t v840;
  uint64_t v841;
  unint64_t v842;
  unint64_t v843;
  unint64_t v844;
  unint64_t v845;
  unint64_t v846;
  unint64_t v847;
  unint64_t v848;
  unint64_t v849;
  unint64_t v850;
  unint64_t v851;
  unint64_t v852;
  unint64_t v853;
  unint64_t v854;
  unint64_t v855;
  unint64_t v856;
  unint64_t v857;
  unint64_t v858;
  unint64_t v859;
  unint64_t v860;
  uint64_t v861;
  unint64_t v862;
  unint64_t v863;
  unint64_t v864;
  uint64_t v865;
  unint64_t v866;
  unint64_t v867;
  unint64_t v868;
  unint64_t v869;
  unint64_t v870;
  unint64_t v871;
  unint64_t v872;
  unint64_t v873;
  unint64_t v874;
  unint64_t v875;
  unint64_t v876;
  unint64_t v877;
  unint64_t v878;
  unint64_t v879;
  unint64_t v880;
  unint64_t v881;
  unint64_t v882;
  unint64_t v883;
  unint64_t v884;
  uint64_t v885;
  unint64_t v886;
  unint64_t v887;
  unint64_t v888;
  uint64_t v889;
  unint64_t v890;
  unint64_t v891;
  unint64_t v892;
  unint64_t v893;
  unint64_t v894;
  unint64_t v895;
  unint64_t v896;
  unint64_t v897;
  unint64_t v898;
  unint64_t v899;
  unint64_t v900;
  unint64_t v901;
  unint64_t v902;
  unint64_t v903;
  unint64_t v904;
  unint64_t v905;
  unint64_t v906;
  unint64_t v907;
  unint64_t v908;
  uint64_t v909;
  unint64_t v910;
  unint64_t v911;
  unint64_t v912;
  uint64_t v913;
  unint64_t v914;
  unint64_t v915;
  unint64_t v916;
  unint64_t v917;
  unint64_t v918;
  unint64_t v919;
  unint64_t v920;
  unint64_t v921;
  unint64_t v922;
  unint64_t v923;
  unint64_t v924;
  unint64_t v925;
  unint64_t v926;
  unint64_t v927;
  unint64_t v928;
  unint64_t v929;
  unint64_t v930;
  unint64_t v931;
  unint64_t v932;
  uint64_t v933;
  unint64_t v934;
  unint64_t v935;
  unint64_t v936;
  uint64_t v937;
  unint64_t v938;
  unint64_t v939;
  unint64_t v940;
  unint64_t v941;
  unint64_t v942;
  unint64_t v943;
  unint64_t v944;
  unint64_t v945;
  unint64_t v946;
  unint64_t v947;
  unint64_t v948;
  unint64_t v949;
  unint64_t v950;
  unint64_t v951;
  unint64_t v952;
  unint64_t v953;
  unint64_t v954;
  unint64_t v955;
  unint64_t v956;
  uint64_t v957;
  unint64_t v958;
  unint64_t v959;
  unint64_t v960;
  uint64_t v961;
  unint64_t v962;
  unint64_t v963;
  unint64_t v964;
  unint64_t v965;
  unint64_t v966;
  unint64_t v967;
  unint64_t v968;
  unint64_t v969;
  unint64_t v970;
  unint64_t v971;
  unint64_t v972;
  unint64_t v973;
  unint64_t v974;
  unint64_t v975;
  unint64_t v976;
  unint64_t v977;
  unint64_t v978;
  unint64_t v979;
  unint64_t v980;
  unint64_t v981;
  unint64_t v982;
  unint64_t v983;
  uint64_t v984;
  unint64_t v985;
  unint64_t v986;
  unint64_t v987;
  unint64_t v988;
  unint64_t v989;
  unint64_t v990;
  unint64_t v991;
  unint64_t v992;
  unint64_t v993;
  unint64_t v994;
  unint64_t v995;
  unint64_t v996;
  unint64_t v997;
  unint64_t v998;
  unint64_t v999;
  unint64_t v1000;
  unint64_t v1001;
  unint64_t v1002;
  unint64_t v1003;
  unint64_t v1004;
  unint64_t v1005;
  uint64_t v1006;
  unint64_t v1007;
  unint64_t v1008;
  unint64_t v1009;
  unint64_t v1010;
  unint64_t v1011;
  unint64_t v1012;
  unint64_t v1013;
  unint64_t v1014;
  unint64_t v1015;
  unint64_t v1016;
  unint64_t v1017;
  unint64_t v1018;
  unint64_t v1019;
  unint64_t v1020;
  unint64_t v1021;
  unint64_t v1022;
  unint64_t v1023;
  unint64_t v1024;
  unint64_t v1025;
  unint64_t v1026;
  unint64_t v1027;
  uint64_t v1028;
  unint64_t v1029;
  unint64_t v1030;
  unint64_t v1031;
  uint64_t v1032;
  unint64_t v1033;
  unint64_t v1034;
  unint64_t v1035;
  unint64_t v1036;
  unint64_t v1037;
  unint64_t v1038;
  unint64_t v1039;
  unint64_t v1040;
  unint64_t v1041;
  unint64_t v1042;
  unint64_t v1043;
  unint64_t v1044;
  unint64_t v1045;
  unint64_t v1046;
  unint64_t v1047;
  unint64_t v1048;
  unint64_t v1049;
  unint64_t v1050;
  unint64_t v1051;
  unint64_t v1052;
  unint64_t v1053;
  uint64_t v1054;
  unint64_t v1055;
  unint64_t v1056;
  unint64_t v1057;
  uint64_t v1058;
  unint64_t v1059;
  unint64_t v1060;
  unint64_t v1061;
  unint64_t v1062;
  unint64_t v1063;
  unint64_t v1064;
  unint64_t v1065;
  unint64_t v1066;
  unint64_t v1067;
  unint64_t v1068;
  unint64_t v1069;
  unint64_t v1070;
  unint64_t v1071;
  unint64_t v1072;
  unint64_t v1073;
  uint64_t v1074;
  unint64_t v1075;
  unint64_t v1076;
  unint64_t v1077;
  uint64_t v1078;
  unint64_t v1079;
  unint64_t v1080;
  unint64_t v1081;
  unint64_t v1082;
  unint64_t v1083;
  unint64_t v1084;
  unint64_t v1085;
  unint64_t v1086;
  unint64_t v1087;
  unint64_t v1088;
  unint64_t v1089;
  unint64_t v1090;
  unint64_t v1091;
  unint64_t v1092;
  unint64_t v1093;
  unint64_t v1094;
  unint64_t v1095;
  unint64_t v1096;
  unint64_t v1097;
  unint64_t v1098;
  unint64_t v1099;
  uint64_t v1100;
  unint64_t v1101;
  unint64_t v1102;
  unint64_t v1103;
  uint64_t v1104;
  unint64_t v1105;
  unint64_t v1106;
  unint64_t v1107;
  unint64_t v1108;
  unint64_t v1109;
  unint64_t v1110;
  unint64_t v1111;
  unint64_t v1112;
  unint64_t v1113;
  unint64_t v1114;
  unint64_t v1115;
  unint64_t v1116;
  unint64_t v1117;
  unint64_t v1118;
  unint64_t v1119;
  unint64_t v1120;
  unint64_t v1121;
  unint64_t v1122;
  unint64_t v1123;
  uint64_t v1124;
  unint64_t v1125;
  unint64_t v1126;
  unint64_t v1127;
  unint64_t v1128;
  unint64_t v1129;
  unint64_t v1130;
  unint64_t v1131;
  unint64_t v1132;
  unint64_t v1133;
  unint64_t v1134;
  unint64_t v1135;
  unint64_t v1136;
  unint64_t v1137;
  unint64_t v1138;
  unint64_t v1139;
  unint64_t v1140;
  unint64_t v1141;
  unint64_t v1142;
  unint64_t v1143;
  unint64_t v1144;
  uint64_t v1145;
  unint64_t v1146;
  unint64_t v1147;
  unint64_t v1148;
  unint64_t v1149;
  unint64_t v1150;
  unint64_t v1151;
  unint64_t v1152;
  unint64_t v1153;
  unint64_t v1154;
  unint64_t v1155;
  unint64_t v1156;
  unint64_t v1157;
  unint64_t v1158;
  unint64_t v1159;
  unint64_t v1160;
  unint64_t v1161;
  unint64_t v1162;
  unint64_t v1163;
  unint64_t v1164;
  unint64_t v1165;
  unint64_t v1166;
  unint64_t v1167;
  uint64_t v1168;
  unint64_t v1169;
  unint64_t v1170;
  unint64_t v1171;
  unint64_t v1172;
  unint64_t v1173;
  unint64_t v1174;
  unint64_t v1175;
  unint64_t v1176;
  unint64_t v1177;
  unint64_t v1178;
  unint64_t v1179;
  unint64_t v1180;
  unint64_t v1181;
  unint64_t v1182;
  unint64_t v1183;
  unint64_t v1184;
  unint64_t v1185;
  unint64_t v1186;
  unint64_t v1187;
  unint64_t v1188;
  unint64_t v1189;
  unint64_t v1190;
  unint64_t v1191;
  uint64_t v1192;
  unint64_t v1193;
  unint64_t v1194;
  unint64_t v1195;
  uint64_t v1196;
  unint64_t v1197;
  unint64_t v1198;
  unint64_t v1199;
  unint64_t v1200;
  unint64_t v1201;
  unint64_t v1202;
  unint64_t v1203;
  unint64_t v1204;
  unint64_t v1205;
  unint64_t v1206;
  unint64_t v1207;
  unint64_t v1208;
  unint64_t v1209;
  unint64_t v1210;
  unint64_t v1211;
  unint64_t v1212;
  unint64_t v1213;
  unint64_t v1214;
  unint64_t v1215;
  uint64_t v1216;
  unint64_t v1217;
  unint64_t v1218;
  unint64_t v1219;
  uint64_t v1220;
  unint64_t v1221;
  unint64_t v1222;
  unint64_t v1223;
  unint64_t v1224;
  unint64_t v1225;
  unint64_t v1226;
  unint64_t v1227;
  unint64_t v1228;
  unint64_t v1229;
  unint64_t v1230;
  unint64_t v1231;
  unint64_t v1232;
  unint64_t v1233;
  unint64_t v1234;
  unint64_t v1235;
  unint64_t v1236;
  unint64_t v1237;
  unint64_t v1238;
  unint64_t v1239;
  unint64_t v1240;
  unint64_t v1241;
  unint64_t v1242;
  uint64_t v1243;
  unint64_t v1244;
  unint64_t v1245;
  unint64_t v1246;
  unint64_t v1247;
  unint64_t v1248;
  unint64_t v1249;
  unint64_t v1250;
  unint64_t v1251;
  unint64_t v1252;
  unint64_t v1253;
  unint64_t v1254;
  unint64_t v1255;
  unint64_t v1256;
  unint64_t v1257;
  unint64_t v1258;
  unint64_t v1259;
  unint64_t v1260;
  unint64_t v1261;
  unint64_t v1262;
  unint64_t v1263;
  unint64_t v1264;
  uint64_t v1265;
  unint64_t v1266;
  unint64_t v1267;
  unint64_t v1268;
  unint64_t v1269;
  unint64_t v1270;
  unint64_t v1271;
  unint64_t v1272;
  unint64_t v1273;
  unint64_t v1274;
  unint64_t v1275;
  unint64_t v1276;
  unint64_t v1277;
  unint64_t v1278;
  unint64_t v1279;
  unint64_t v1280;
  unint64_t v1281;
  unint64_t v1282;
  unint64_t v1283;
  unint64_t v1284;
  unint64_t v1285;
  uint64_t v1286;
  unint64_t v1287;
  unint64_t v1288;
  unint64_t v1289;
  unint64_t v1290;
  unint64_t v1291;
  unint64_t v1292;
  unint64_t v1293;
  unint64_t v1294;
  unint64_t v1295;
  unint64_t v1296;
  unint64_t v1297;
  unint64_t v1298;
  unint64_t v1299;
  unint64_t v1300;
  unint64_t v1301;
  unint64_t v1302;
  unint64_t v1303;
  unint64_t v1304;
  unint64_t v1305;
  unint64_t v1306;
  unint64_t v1307;
  unint64_t v1308;
  unint64_t v1309;
  unint64_t v1310;
  unint64_t v1311;
  uint64_t v1312;
  unint64_t v1313;
  unint64_t v1314;
  unint64_t v1315;
  unint64_t v1316;
  unint64_t v1317;
  unint64_t v1318;
  unint64_t v1319;
  unint64_t v1320;
  unint64_t v1321;
  unint64_t v1322;
  unint64_t v1323;
  unint64_t v1324;
  unint64_t v1325;
  unint64_t v1326;
  unint64_t v1327;
  unint64_t v1328;
  unint64_t v1329;
  unint64_t v1330;
  unint64_t v1331;
  unint64_t v1332;
  unint64_t v1333;
  unint64_t v1334;
  unint64_t v1335;
  uint64_t v1336;
  unint64_t v1337;
  unint64_t v1338;
  unint64_t v1339;
  unint64_t v1340;
  unint64_t v1341;
  unint64_t v1342;
  unint64_t v1343;
  unint64_t v1344;
  unint64_t v1345;
  unint64_t v1346;
  unint64_t v1347;
  unint64_t v1348;
  unint64_t v1349;
  unint64_t v1350;
  unint64_t v1351;
  unint64_t v1352;
  unint64_t v1353;
  unint64_t v1354;
  unint64_t v1355;
  unint64_t v1356;
  uint64_t v1357;
  unint64_t v1358;
  unint64_t v1359;
  unint64_t v1360;
  unint64_t v1361;
  unint64_t v1362;
  unint64_t v1363;
  unint64_t v1364;
  unint64_t v1365;
  unint64_t v1366;
  unint64_t v1367;
  unint64_t v1368;
  unint64_t v1369;
  unint64_t v1370;
  unint64_t v1371;
  unint64_t v1372;
  unint64_t v1373;
  unint64_t v1374;
  unint64_t v1375;
  unint64_t v1376;
  unint64_t v1377;
  unint64_t v1378;
  unint64_t v1379;
  uint64_t v1380;
  unint64_t v1381;
  unint64_t v1382;
  unint64_t v1383;
  unint64_t v1384;
  unint64_t v1385;
  unint64_t v1386;
  unint64_t v1387;
  unint64_t v1388;
  unint64_t v1389;
  unint64_t v1390;
  unint64_t v1391;
  unint64_t v1392;
  unint64_t v1393;
  unint64_t v1394;
  unint64_t v1395;
  unint64_t v1396;
  unint64_t v1397;
  unint64_t v1398;
  unint64_t v1399;
  unint64_t v1400;
  unint64_t v1401;
  unint64_t v1402;
  unint64_t v1403;
  unint64_t v1404;
  unint64_t v1405;
  unint64_t v1406;
  unint64_t v1407;
  unint64_t v1408;
  unint64_t v1409;
  unint64_t v1410;
  unint64_t v1411;
  unint64_t v1412;
  unint64_t v1413;
  unint64_t v1414;
  unint64_t v1415;
  unint64_t v1416;
  unint64_t v1417;
  unint64_t v1418;
  unint64_t v1419;
  unint64_t v1420;
  unint64_t v1421;
  unint64_t v1422;
  unint64_t v1423;
  unint64_t v1424;
  unint64_t v1425;
  unint64_t v1426;
  unint64_t v1427;
  unint64_t v1428;
  unint64_t v1429;
  unint64_t v1430;
  unint64_t v1431;
  unint64_t v1432;
  unint64_t v1433;
  unint64_t v1434;
  unint64_t v1435;
  unint64_t v1436;
  unint64_t v1437;
  unint64_t v1438;
  unint64_t v1439;
  unint64_t v1440;
  unint64_t v1441;
  unint64_t v1442;
  unint64_t v1443;
  unint64_t v1444;
  unint64_t v1445;
  unint64_t v1446;
  unint64_t v1447;
  unint64_t v1448;
  unint64_t v1449;
  unint64_t v1450;
  unint64_t v1451;
  unint64_t v1452;
  unint64_t v1453;
  unint64_t v1454;
  unint64_t v1455;
  unint64_t v1456;
  unint64_t v1457;
  unint64_t v1458;
  unint64_t v1459;
  unint64_t v1460;
  unint64_t v1461;
  unint64_t v1462;
  unint64_t v1463;
  unint64_t v1464;
  unint64_t v1465;
  unint64_t v1466;
  unint64_t v1467;
  unint64_t v1468;
  unint64_t v1469;

  v3 = HIDWORD(*a2);
  v4 = *a3 * (unint64_t)*a2;
  v5 = *a3 * (unint64_t)v3;
  v6 = v4 | (v5 << 32);
  v7 = HIDWORD(*a3);
  v8 = HIDWORD(v5);
  v9 = v4 & (v5 << 32);
  v10 = (v5 << 32) + *a3 * (unint64_t)*a2;
  v11 = v7 * (unint64_t)*a2;
  v12 = v10 | (v11 << 32);
  v13 = v8 + v7 * (unint64_t)v3;
  v14 = v6 & ~v10;
  v15 = v10 & (v11 << 32);
  v16 = v10 + (v11 << 32);
  v17 = v13 + HIDWORD(v11) + ((v14 | v9) >> 63) + ((v12 & ~v16 | v15) >> 63);
  *result = v16;
  v18 = a2[1];
  v19 = HIDWORD(*a2);
  LODWORD(v9) = *a2;
  v20 = a3[1];
  v21 = HIDWORD(v20);
  v22 = v20;
  v23 = v20 * (unint64_t)v9;
  v24 = v20 * (unint64_t)v19;
  v25 = HIDWORD(v24) + v21 * (unint64_t)v19;
  v26 = v23 | (v24 << 32);
  v27 = v23 & (v24 << 32);
  v28 = (v24 << 32) + v22 * (unint64_t)v9;
  v29 = v26 & ~v28 | v27;
  v30 = v21 * (unint64_t)v9;
  v31 = v28 | (v30 << 32);
  v32 = v28 & (v30 << 32);
  v33 = v28 + (v30 << 32);
  v34 = v25 + HIDWORD(v30) + (v29 >> 63) + ((v31 & ~v33 | v32) >> 63);
  v35 = v17 | v33;
  v36 = v17 & v33;
  v37 = v17 + v33;
  v38 = v34 + ((v35 & ~v37 | v36) >> 63);
  v39 = HIDWORD(v18);
  LODWORD(v36) = v18;
  v40 = HIDWORD(*a3);
  LODWORD(v31) = *a3;
  v41 = v31 * (unint64_t)v18;
  v42 = v31 * (unint64_t)v39;
  v43 = HIDWORD(v42) + v40 * (unint64_t)v39;
  v44 = v41 | (v42 << 32);
  v45 = v41 & (v42 << 32);
  v46 = (v42 << 32) + v31 * (unint64_t)v36;
  v47 = v44 & ~v46 | v45;
  v48 = v40 * (unint64_t)v36;
  v49 = v46 | (v48 << 32);
  v50 = v46 & (v48 << 32);
  v51 = v46 + (v48 << 32);
  v52 = v43 + HIDWORD(v48) + (v47 >> 63) + ((v49 & ~v51 | v50) >> 63);
  v53 = v51 | v37;
  v54 = v51 & v37;
  v55 = v51 + v37;
  v56 = v52 + ((v53 & ~v55 | v54) >> 63);
  v57 = v56 | v38;
  v58 = v56 & v38;
  v59 = v56 + v38;
  v60 = v57 & ~v59 | v58;
  result[1] = v55;
  v61 = a2[2];
  v62 = HIDWORD(v61);
  LODWORD(v58) = v61;
  v63 = a3[1];
  v64 = HIDWORD(*a3);
  LODWORD(v32) = *a3;
  v65 = v32 * (unint64_t)v61;
  v66 = v32 * (unint64_t)v62;
  v67 = HIDWORD(v66) + v64 * (unint64_t)v62;
  v68 = v65 | (v66 << 32);
  v69 = v65 & (v66 << 32);
  v70 = (v66 << 32) + v32 * (unint64_t)v58;
  v71 = v68 & ~v70 | v69;
  v72 = v64 * (unint64_t)v58;
  v73 = v70 | (v72 << 32);
  v74 = v70 & (v72 << 32);
  v75 = v70 + (v72 << 32);
  v76 = v67 + HIDWORD(v72) + (v71 >> 63) + ((v73 & ~v75 | v74) >> 63);
  v77 = v59 | v75;
  v78 = v59 & v75;
  v79 = v59 + v75;
  v80 = v76 + ((v77 & ~v79 | v78) >> 63);
  v81 = v80 + (v60 >> 63);
  v82 = v80 & ~v81;
  v83 = a2[1];
  v84 = HIDWORD(v83);
  LODWORD(v73) = v83;
  v85 = HIDWORD(v63);
  LODWORD(v44) = v63;
  v86 = v63 * (unint64_t)v83;
  v87 = v63 * (unint64_t)v84;
  v88 = HIDWORD(v87) + v85 * (unint64_t)v84;
  v89 = v86 | (v87 << 32);
  v90 = v86 & (v87 << 32);
  v91 = (v87 << 32) + v44 * (unint64_t)v73;
  v92 = v89 & ~v91 | v90;
  v93 = v85 * (unint64_t)v73;
  v94 = v91 | (v93 << 32);
  v95 = v91 & (v93 << 32);
  v96 = v91 + (v93 << 32);
  v97 = v88 + HIDWORD(v93) + (v92 >> 63) + ((v94 & ~v96 | v95) >> 63);
  v98 = v79 | v96;
  v99 = v79 & v96;
  v100 = v79 + v96;
  v101 = v97 + ((v98 & ~v100 | v99) >> 63);
  v102 = v101 | v81;
  v103 = v101 & v81;
  v104 = v101 + v81;
  v105 = ((v102 & ~v104 | v103) >> 63) + (v82 >> 63);
  v106 = a3[2];
  v107 = HIDWORD(*a2);
  LODWORD(v103) = *a2;
  v108 = HIDWORD(v106);
  LODWORD(v94) = v106;
  v109 = v106 * (unint64_t)v103;
  v110 = v94 * (unint64_t)v107;
  v111 = HIDWORD(v110) + v108 * (unint64_t)v107;
  v112 = v109 | (v110 << 32);
  v113 = v109 & (v110 << 32);
  v114 = (v110 << 32) + v94 * (unint64_t)v103;
  v115 = v112 & ~v114 | v113;
  v116 = v108 * (unint64_t)v103;
  v117 = v114 | (v116 << 32);
  v118 = v114 & (v116 << 32);
  v119 = v114 + (v116 << 32);
  v120 = v111 + HIDWORD(v116) + (v115 >> 63) + ((v117 & ~v119 | v118) >> 63);
  v121 = v100 | v119;
  v122 = v100 & v119;
  v123 = v100 + v119;
  v124 = v120 + ((v121 & ~v123 | v122) >> 63);
  v125 = v124 | v104;
  v126 = v124 & v104;
  v127 = v124 + v104;
  v128 = v105 + ((v125 & ~v127 | v126) >> 63);
  result[2] = v123;
  v129 = a2[1];
  v130 = HIDWORD(*a2);
  LODWORD(v126) = *a2;
  v132 = a3[2];
  v131 = a3[3];
  v133 = HIDWORD(v131);
  LODWORD(v95) = v131;
  v134 = v131 * (unint64_t)v126;
  v135 = v131 * (unint64_t)v130;
  v136 = HIDWORD(v135) + v133 * (unint64_t)v130;
  v137 = v134 | (v135 << 32);
  v138 = v134 & (v135 << 32);
  v139 = (v135 << 32) + v95 * (unint64_t)v126;
  v140 = v137 & ~v139 | v138;
  v141 = v133 * (unint64_t)v126;
  v142 = v139 | (v141 << 32);
  v143 = v139 & (v141 << 32);
  v144 = v139 + (v141 << 32);
  v145 = v136 + HIDWORD(v141) + (v140 >> 63) + ((v142 & ~v144 | v143) >> 63);
  v146 = v127 | v144;
  v147 = v127 & v144;
  v148 = v127 + v144;
  v149 = v145 + ((v146 & ~v148 | v147) >> 63);
  v150 = v128 + v149;
  v151 = v149 & ~(v128 + v149);
  v152 = HIDWORD(v129);
  LODWORD(v149) = v129;
  v153 = HIDWORD(v132);
  LODWORD(v142) = v132;
  v154 = v132 * (unint64_t)v129;
  v155 = v132 * (unint64_t)v152;
  v156 = HIDWORD(v155) + v153 * (unint64_t)v152;
  v157 = v154 | (v155 << 32);
  v158 = v154 & (v155 << 32);
  v159 = (v155 << 32) + v142 * (unint64_t)v149;
  v160 = v157 & ~v159 | v158;
  v161 = v153 * (unint64_t)v149;
  v162 = v159 | (v161 << 32);
  v163 = v159 & (v161 << 32);
  v164 = v159 + (v161 << 32);
  v165 = v156 + HIDWORD(v161) + (v160 >> 63) + ((v162 & ~v164 | v163) >> 63);
  v166 = v148 + v164;
  v167 = v165 + (((v148 | v164) & ~(v148 + v164) | v148 & v164) >> 63);
  v168 = v167 | v150;
  v169 = v167 & v150;
  v170 = v167 + v150;
  v171 = ((v168 & ~v170 | v169) >> 63) + (v151 >> 63);
  v172 = a2[2];
  v173 = a2[3];
  v174 = HIDWORD(v172);
  LODWORD(v162) = v172;
  v175 = a3[1];
  v176 = HIDWORD(v175);
  LODWORD(v157) = v175;
  v177 = v175 * (unint64_t)v172;
  v178 = v175 * (unint64_t)v174;
  v179 = HIDWORD(v178) + v176 * (unint64_t)v174;
  v180 = v177 | (v178 << 32);
  v181 = v177 & (v178 << 32);
  v182 = (v178 << 32) + v157 * (unint64_t)v162;
  v183 = v180 & ~v182 | v181;
  v184 = v176 * (unint64_t)v162;
  v185 = v182 | (v184 << 32);
  v186 = v182 & (v184 << 32);
  v187 = v182 + (v184 << 32);
  v188 = v179 + HIDWORD(v184) + (v183 >> 63) + ((v185 & ~v187 | v186) >> 63);
  v189 = v166 | v187;
  v190 = v166 & v187;
  v191 = v166 + v187;
  v192 = v188 + ((v189 & ~v191 | v190) >> 63);
  v193 = v192 | v170;
  v194 = v192 & v170;
  v195 = v192 + v170;
  v196 = v171 + ((v193 & ~v195 | v194) >> 63);
  v197 = HIDWORD(v173);
  LODWORD(v193) = v173;
  v198 = HIDWORD(*a3);
  LODWORD(v187) = *a3;
  v199 = v187 * (unint64_t)v173;
  v200 = v187 * (unint64_t)v197;
  v201 = HIDWORD(v200) + v198 * (unint64_t)v197;
  v202 = (v200 << 32) + v187 * (unint64_t)v193;
  v203 = (v199 | (v200 << 32)) & ~v202 | v199 & (v200 << 32);
  v204 = v198 * (unint64_t)v193;
  v205 = v202 | (v204 << 32);
  v206 = v202 & (v204 << 32);
  v207 = v202 + (v204 << 32);
  v208 = v201 + HIDWORD(v204) + (v203 >> 63) + ((v205 & ~v207 | v206) >> 63);
  v209 = v191 | v207;
  v210 = v191 & v207;
  v211 = v191 + v207;
  v212 = v208 + ((v209 & ~v211 | v210) >> 63);
  v213 = v212 | v195;
  v214 = v212 & v195;
  v215 = v212 + v195;
  v216 = v196 + ((v213 & ~v215 | v214) >> 63);
  result[3] = v211;
  v217 = a2[4];
  v218 = HIDWORD(v217);
  LODWORD(v213) = v217;
  v219 = a3[1];
  v220 = HIDWORD(*a3);
  LODWORD(v206) = *a3;
  v221 = v206 * (unint64_t)v217;
  v222 = v206 * (unint64_t)v218;
  v223 = HIDWORD(v222) + v220 * (unint64_t)v218;
  v224 = v221 | (v222 << 32);
  v225 = v221 & (v222 << 32);
  v226 = (v222 << 32) + v206 * (unint64_t)v213;
  v227 = v224 & ~v226 | v225;
  v228 = v220 * (unint64_t)v213;
  v229 = v226 | (v228 << 32);
  v230 = v226 & (v228 << 32);
  v231 = v226 + (v228 << 32);
  v232 = v223 + HIDWORD(v228) + (v227 >> 63) + ((v229 & ~v231 | v230) >> 63);
  v233 = v215 | v231;
  v234 = v215 & v231;
  v235 = v215 + v231;
  v236 = v232 + ((v233 & ~v235 | v234) >> 63);
  v237 = v236 | v216;
  v238 = v236 + v216;
  v239 = v237 & ~v238;
  v241 = a2[2];
  v240 = a2[3];
  v242 = HIDWORD(v240);
  LODWORD(v229) = v240;
  v243 = HIDWORD(v219);
  LODWORD(v185) = v219;
  v244 = v219 * (unint64_t)v240;
  v245 = v219 * (unint64_t)v242;
  v246 = HIDWORD(v245) + v243 * (unint64_t)v242;
  v247 = v244 | (v245 << 32);
  v248 = v244 & (v245 << 32);
  v249 = (v245 << 32) + v185 * (unint64_t)v229;
  v250 = v247 & ~v249 | v248;
  v251 = v243 * (unint64_t)v229;
  v252 = v249 | (v251 << 32);
  v253 = v249 & (v251 << 32);
  v254 = v249 + (v251 << 32);
  v255 = v246 + HIDWORD(v251) + (v250 >> 63) + ((v252 & ~v254 | v253) >> 63);
  v256 = v235 | v254;
  v257 = v235 & v254;
  v258 = v235 + v254;
  v259 = v255 + ((v256 & ~v258 | v257) >> 63);
  v260 = v259 | v238;
  v261 = v259 & v238;
  v262 = v259 + v238;
  v263 = ((v260 & ~v262 | v261) >> 63) + (v239 >> 63);
  v264 = HIDWORD(v241);
  LODWORD(v260) = v241;
  v265 = a3[2];
  v266 = a3[3];
  v267 = HIDWORD(v265);
  LODWORD(v253) = v265;
  v268 = v265 * (unint64_t)v241;
  v269 = v265 * (unint64_t)v264;
  v270 = HIDWORD(v269) + v267 * (unint64_t)v264;
  v271 = v268 | (v269 << 32);
  v272 = v268 & (v269 << 32);
  v273 = (v269 << 32) + v253 * (unint64_t)v260;
  v274 = v271 & ~v273 | v272;
  v275 = v267 * (unint64_t)v260;
  v276 = v273 | (v275 << 32);
  v277 = v273 & (v275 << 32);
  v278 = v273 + (v275 << 32);
  v279 = v270 + HIDWORD(v275) + (v274 >> 63) + ((v276 & ~v278 | v277) >> 63);
  v280 = v258 | v278;
  v281 = v258 & v278;
  v282 = v258 + v278;
  v283 = v279 + ((v280 & ~v282 | v281) >> 63);
  v284 = v283 | v262;
  v285 = v283 & v262;
  v286 = v283 + v262;
  v287 = v263 + ((v284 & ~v286 | v285) >> 63);
  v288 = a2[1];
  v289 = HIDWORD(v288);
  LODWORD(v278) = v288;
  v290 = HIDWORD(v266);
  LODWORD(v277) = v266;
  v291 = v266 * (unint64_t)v288;
  v292 = v266 * (unint64_t)v289;
  v293 = HIDWORD(v292) + v290 * (unint64_t)v289;
  v294 = v291 | (v292 << 32);
  v295 = v291 & (v292 << 32);
  v296 = (v292 << 32) + v277 * (unint64_t)v278;
  v297 = v294 & ~v296 | v295;
  v298 = v290 * (unint64_t)v278;
  v299 = v296 | (v298 << 32);
  v300 = v296 & (v298 << 32);
  v301 = v296 + (v298 << 32);
  v302 = v293 + HIDWORD(v298) + (v297 >> 63) + ((v299 & ~v301 | v300) >> 63);
  v303 = v282 | v301;
  v304 = v282 & v301;
  v305 = v282 + v301;
  v306 = v302 + ((v303 & ~v305 | v304) >> 63);
  v307 = v306 | v286;
  v308 = v306 & v286;
  v309 = v306 + v286;
  v310 = v287 + ((v307 & ~v309 | v308) >> 63);
  v311 = a3[4];
  v312 = HIDWORD(*a2);
  LODWORD(v308) = *a2;
  v313 = HIDWORD(v311);
  LODWORD(v299) = v311;
  v314 = v311 * (unint64_t)v308;
  v315 = v299 * (unint64_t)v312;
  v316 = HIDWORD(v315) + v313 * (unint64_t)v312;
  v317 = v314 | (v315 << 32);
  v318 = v314 & (v315 << 32);
  v319 = (v315 << 32) + v299 * (unint64_t)v308;
  v320 = v317 & ~v319 | v318;
  v321 = v313 * (unint64_t)v308;
  v322 = v319 | (v321 << 32);
  v323 = v319 & (v321 << 32);
  v324 = v319 + (v321 << 32);
  v325 = v316 + HIDWORD(v321) + (v320 >> 63) + ((v322 & ~v324 | v323) >> 63);
  v326 = v324 | v305;
  v327 = v324 & v305;
  v328 = v324 + v305;
  v329 = v325 + ((v326 & ~v328 | v327) >> 63);
  v330 = v329 | v309;
  v331 = v329 & v309;
  v332 = v329 + v309;
  v333 = v310 + ((v330 & ~v332 | v331) >> 63);
  result[4] = v328;
  v334 = a2[1];
  v335 = HIDWORD(*a2);
  LODWORD(v331) = *a2;
  v337 = a3[4];
  v336 = a3[5];
  v338 = HIDWORD(v336);
  LODWORD(v300) = v336;
  v339 = v336 * (unint64_t)v331;
  v340 = v336 * (unint64_t)v335;
  v341 = HIDWORD(v340) + v338 * (unint64_t)v335;
  v342 = v339 | (v340 << 32);
  v343 = v339 & (v340 << 32);
  v344 = (v340 << 32) + v300 * (unint64_t)v331;
  v345 = v342 & ~v344 | v343;
  v346 = v338 * (unint64_t)v331;
  v347 = v344 | (v346 << 32);
  v348 = v344 & (v346 << 32);
  v349 = v344 + (v346 << 32);
  v350 = v341 + HIDWORD(v346) + (v345 >> 63) + ((v347 & ~v349 | v348) >> 63);
  v351 = v332 | v349;
  v352 = v332 & v349;
  v353 = v332 + v349;
  v354 = v350 + ((v351 & ~v353 | v352) >> 63);
  v355 = v354 | v333;
  v356 = v354 + v333;
  v357 = v355 & ~v356;
  v358 = HIDWORD(v334);
  LODWORD(v352) = v334;
  v359 = HIDWORD(v337);
  LODWORD(v347) = v337;
  v360 = v337 * (unint64_t)v334;
  v361 = v337 * (unint64_t)v358;
  v362 = HIDWORD(v361) + v359 * (unint64_t)v358;
  v363 = v360 | (v361 << 32);
  v364 = v360 & (v361 << 32);
  v365 = (v361 << 32) + v347 * (unint64_t)v352;
  v366 = v363 & ~v365 | v364;
  v367 = v359 * (unint64_t)v352;
  v368 = v365 | (v367 << 32);
  v369 = v365 & (v367 << 32);
  v370 = v365 + (v367 << 32);
  v371 = v362 + HIDWORD(v367) + (v366 >> 63) + ((v368 & ~v370 | v369) >> 63);
  v372 = v353 | v370;
  v373 = v353 & v370;
  v374 = v353 + v370;
  v375 = v371 + ((v372 & ~v374 | v373) >> 63);
  v376 = v375 | v356;
  v377 = v375 & v356;
  v378 = v375 + v356;
  v379 = ((v376 & ~v378 | v377) >> 63) + (v357 >> 63);
  v380 = a2[2];
  v381 = a2[3];
  v382 = HIDWORD(v380);
  LODWORD(v368) = v380;
  v384 = a3[2];
  v383 = a3[3];
  v385 = HIDWORD(v383);
  LODWORD(v363) = v383;
  v386 = v383 * (unint64_t)v380;
  v387 = v383 * (unint64_t)v382;
  v388 = HIDWORD(v387) + v385 * (unint64_t)v382;
  v389 = v386 | (v387 << 32);
  v390 = v386 & (v387 << 32);
  v391 = (v387 << 32) + v363 * (unint64_t)v368;
  v392 = v389 & ~v391 | v390;
  v393 = v385 * (unint64_t)v368;
  v394 = v391 | (v393 << 32);
  v395 = v391 & (v393 << 32);
  v396 = v391 + (v393 << 32);
  v397 = v388 + HIDWORD(v393) + (v392 >> 63) + ((v394 & ~v396 | v395) >> 63);
  v398 = v374 | v396;
  v399 = v374 & v396;
  v400 = v374 + v396;
  v401 = v397 + ((v398 & ~v400 | v399) >> 63);
  v402 = v401 | v378;
  v403 = v401 & v378;
  v404 = v401 + v378;
  v405 = v379 + ((v402 & ~v404 | v403) >> 63);
  v406 = HIDWORD(v381);
  LODWORD(v402) = v381;
  v407 = HIDWORD(v384);
  LODWORD(v396) = v384;
  v408 = v384 * (unint64_t)v381;
  v409 = v384 * (unint64_t)v406;
  v410 = HIDWORD(v409) + v407 * (unint64_t)v406;
  v411 = (v409 << 32) + v396 * (unint64_t)v402;
  v412 = (v408 | (v409 << 32)) & ~v411 | v408 & (v409 << 32);
  v413 = v407 * (unint64_t)v402;
  v414 = v411 | (v413 << 32);
  v415 = v411 & (v413 << 32);
  v416 = v411 + (v413 << 32);
  v417 = v410 + HIDWORD(v413) + (v412 >> 63) + ((v414 & ~v416 | v415) >> 63);
  v418 = v416 | v400;
  v419 = v416 & v400;
  v420 = v416 + v400;
  v421 = v417 + ((v418 & ~v420 | v419) >> 63);
  v422 = v421 | v404;
  v423 = v421 & v404;
  v424 = v421 + v404;
  v425 = v405 + ((v422 & ~v424 | v423) >> 63);
  v426 = a2[4];
  v427 = a2[5];
  v428 = HIDWORD(v426);
  LODWORD(v414) = v426;
  v429 = a3[1];
  v430 = HIDWORD(v429);
  LODWORD(v395) = v429;
  v431 = v429 * (unint64_t)v426;
  v432 = v429 * (unint64_t)v428;
  v433 = HIDWORD(v432) + v430 * (unint64_t)v428;
  v434 = v431 | (v432 << 32);
  v435 = v431 & (v432 << 32);
  v436 = (v432 << 32) + v395 * (unint64_t)v414;
  v437 = v434 & ~v436 | v435;
  v438 = v430 * (unint64_t)v414;
  v439 = v436 | (v438 << 32);
  v440 = v436 & (v438 << 32);
  v441 = v436 + (v438 << 32);
  v442 = v433 + HIDWORD(v438) + (v437 >> 63) + ((v439 & ~v441 | v440) >> 63);
  v443 = v441 | v420;
  v444 = v441 & v420;
  v445 = v441 + v420;
  v446 = v442 + ((v443 & ~v445 | v444) >> 63);
  v447 = v446 | v424;
  v448 = v446 & v424;
  v449 = v446 + v424;
  v450 = v425 + ((v447 & ~v449 | v448) >> 63);
  v451 = HIDWORD(v427);
  LODWORD(v447) = v427;
  v452 = HIDWORD(*a3);
  LODWORD(v441) = *a3;
  v453 = v441 * (unint64_t)v427;
  v454 = v441 * (unint64_t)v451;
  v455 = HIDWORD(v454) + v452 * (unint64_t)v451;
  v456 = (v454 << 32) + v441 * (unint64_t)v447;
  v457 = (v453 | (v454 << 32)) & ~v456 | v453 & (v454 << 32);
  v458 = v452 * (unint64_t)v447;
  v459 = v456 | (v458 << 32);
  v460 = v456 & (v458 << 32);
  v461 = v456 + (v458 << 32);
  v462 = v455 + HIDWORD(v458) + (v457 >> 63) + ((v459 & ~v461 | v460) >> 63);
  v463 = v461 | v445;
  v464 = v461 & v445;
  v465 = v461 + v445;
  v466 = v462 + ((v463 & ~v465 | v464) >> 63);
  v467 = v466 | v449;
  v468 = v466 & v449;
  v469 = v466 + v449;
  v470 = v450 + ((v467 & ~v469 | v468) >> 63);
  result[5] = v465;
  v471 = a2[6];
  v472 = HIDWORD(v471);
  LODWORD(v467) = v471;
  v473 = a3[1];
  v474 = HIDWORD(*a3);
  LODWORD(v460) = *a3;
  v475 = v460 * (unint64_t)v471;
  v476 = v460 * (unint64_t)v472;
  v477 = HIDWORD(v476) + v474 * (unint64_t)v472;
  v478 = v475 | (v476 << 32);
  v479 = v475 & (v476 << 32);
  v480 = (v476 << 32) + v460 * (unint64_t)v467;
  v481 = v478 & ~v480 | v479;
  v482 = v474 * (unint64_t)v467;
  v483 = v480 | (v482 << 32);
  v484 = v480 & (v482 << 32);
  v485 = v480 + (v482 << 32);
  v486 = v477 + HIDWORD(v482) + (v481 >> 63) + ((v483 & ~v485 | v484) >> 63);
  v487 = v469 | v485;
  v488 = v469 & v485;
  v489 = v469 + v485;
  v490 = v486 + ((v487 & ~v489 | v488) >> 63);
  v491 = v490 | v470;
  v492 = v490 + v470;
  v493 = v491 & ~v492;
  v495 = a2[4];
  v494 = a2[5];
  v496 = HIDWORD(v494);
  LODWORD(v483) = v494;
  v497 = HIDWORD(v473);
  LODWORD(v439) = v473;
  v498 = v473 * (unint64_t)v494;
  v499 = v473 * (unint64_t)v496;
  v500 = HIDWORD(v499) + v497 * (unint64_t)v496;
  v501 = v498 | (v499 << 32);
  v502 = v498 & (v499 << 32);
  v503 = (v499 << 32) + v439 * (unint64_t)v483;
  v504 = v501 & ~v503 | v502;
  v505 = v497 * (unint64_t)v483;
  v506 = v503 | (v505 << 32);
  v507 = v503 & (v505 << 32);
  v508 = v503 + (v505 << 32);
  v509 = v500 + HIDWORD(v505) + (v504 >> 63) + ((v506 & ~v508 | v507) >> 63);
  v510 = v489 | v508;
  v511 = v489 & v508;
  v512 = v489 + v508;
  v513 = v509 + ((v510 & ~v512 | v511) >> 63);
  v514 = v513 | v492;
  v515 = v513 & v492;
  v516 = v513 + v492;
  v517 = ((v514 & ~v516 | v515) >> 63) + (v493 >> 63);
  v518 = HIDWORD(v495);
  LODWORD(v514) = v495;
  v519 = a3[2];
  v520 = a3[3];
  v521 = HIDWORD(v519);
  LODWORD(v507) = v519;
  v522 = v519 * (unint64_t)v495;
  v523 = v519 * (unint64_t)v518;
  v524 = HIDWORD(v523) + v521 * (unint64_t)v518;
  v525 = v522 | (v523 << 32);
  v526 = v522 & (v523 << 32);
  v527 = (v523 << 32) + v507 * (unint64_t)v514;
  v528 = v525 & ~v527 | v526;
  v529 = v521 * (unint64_t)v514;
  v530 = v527 | (v529 << 32);
  v531 = v527 & (v529 << 32);
  v532 = v527 + (v529 << 32);
  v533 = v524 + HIDWORD(v529) + (v528 >> 63) + ((v530 & ~v532 | v531) >> 63);
  v534 = v512 | v532;
  v535 = v512 & v532;
  v536 = v512 + v532;
  v537 = v533 + ((v534 & ~v536 | v535) >> 63);
  v538 = v537 | v516;
  v539 = v537 & v516;
  v540 = v537 + v516;
  v541 = v517 + ((v538 & ~v540 | v539) >> 63);
  v543 = a2[2];
  v542 = a2[3];
  v544 = HIDWORD(v542);
  LODWORD(v532) = v542;
  v545 = HIDWORD(v520);
  LODWORD(v531) = v520;
  v546 = v520 * (unint64_t)v542;
  v547 = v520 * (unint64_t)v544;
  v548 = HIDWORD(v547) + v545 * (unint64_t)v544;
  v549 = v546 | (v547 << 32);
  v550 = v546 & (v547 << 32);
  v551 = (v547 << 32) + v531 * (unint64_t)v532;
  v552 = v549 & ~v551 | v550;
  v553 = v545 * (unint64_t)v532;
  v554 = v551 | (v553 << 32);
  v555 = v551 & (v553 << 32);
  v556 = v551 + (v553 << 32);
  v557 = v548 + HIDWORD(v553) + (v552 >> 63) + ((v554 & ~v556 | v555) >> 63);
  v558 = v556 | v536;
  v559 = v556 & v536;
  v560 = v556 + v536;
  v561 = v557 + ((v558 & ~v560 | v559) >> 63);
  v562 = v561 | v540;
  v563 = v561 & v540;
  v564 = v561 + v540;
  v565 = v541 + ((v562 & ~v564 | v563) >> 63);
  v566 = HIDWORD(v543);
  LODWORD(v562) = v543;
  v567 = a3[4];
  v568 = a3[5];
  v569 = HIDWORD(v567);
  LODWORD(v555) = v567;
  v570 = v567 * (unint64_t)v543;
  v571 = v567 * (unint64_t)v566;
  v572 = HIDWORD(v571) + v569 * (unint64_t)v566;
  v573 = v570 | (v571 << 32);
  v574 = v570 & (v571 << 32);
  v575 = (v571 << 32) + v555 * (unint64_t)v562;
  v576 = v573 & ~v575 | v574;
  v577 = v569 * (unint64_t)v562;
  v578 = v575 | (v577 << 32);
  v579 = v575 & (v577 << 32);
  v580 = v575 + (v577 << 32);
  v581 = v572 + HIDWORD(v577) + (v576 >> 63) + ((v578 & ~v580 | v579) >> 63);
  v582 = v580 | v560;
  v583 = v580 & v560;
  v584 = v580 + v560;
  v585 = v581 + ((v582 & ~v584 | v583) >> 63);
  v586 = v585 | v564;
  v587 = v585 & v564;
  v588 = v585 + v564;
  v589 = v565 + ((v586 & ~v588 | v587) >> 63);
  v590 = a2[1];
  v591 = HIDWORD(v590);
  LODWORD(v580) = v590;
  v592 = HIDWORD(v568);
  LODWORD(v579) = v568;
  v593 = v568 * (unint64_t)v590;
  v594 = v568 * (unint64_t)v591;
  v595 = HIDWORD(v594) + v592 * (unint64_t)v591;
  v596 = v593 | (v594 << 32);
  v597 = v593 & (v594 << 32);
  v598 = (v594 << 32) + v579 * (unint64_t)v580;
  v599 = v596 & ~v598 | v597;
  v600 = v592 * (unint64_t)v580;
  v601 = v598 | (v600 << 32);
  v602 = v598 & (v600 << 32);
  v603 = v598 + (v600 << 32);
  v604 = v595 + HIDWORD(v600) + (v599 >> 63) + ((v601 & ~v603 | v602) >> 63);
  v605 = v603 | v584;
  v606 = v603 & v584;
  v607 = v603 + v584;
  v608 = v604 + ((v605 & ~v607 | v606) >> 63);
  v609 = v608 | v588;
  v610 = v608 & v588;
  v611 = v608 + v588;
  v612 = v589 + ((v609 & ~v611 | v610) >> 63);
  v613 = a3[6];
  v614 = HIDWORD(*a2);
  LODWORD(v610) = *a2;
  v615 = HIDWORD(v613);
  LODWORD(v601) = v613;
  v616 = v613 * (unint64_t)v610;
  v617 = v601 * (unint64_t)v614;
  v618 = HIDWORD(v617) + v615 * (unint64_t)v614;
  v619 = v616 | (v617 << 32);
  v620 = v616 & (v617 << 32);
  v621 = (v617 << 32) + v601 * (unint64_t)v610;
  v622 = v619 & ~v621 | v620;
  v623 = v615 * (unint64_t)v610;
  v624 = v621 | (v623 << 32);
  v625 = v621 & (v623 << 32);
  v626 = v621 + (v623 << 32);
  v627 = v618 + HIDWORD(v623) + (v622 >> 63) + ((v624 & ~v626 | v625) >> 63);
  v628 = v626 | v607;
  v629 = v626 & v607;
  v630 = v626 + v607;
  v631 = v627 + ((v628 & ~v630 | v629) >> 63);
  v632 = v631 | v611;
  v633 = v631 & v611;
  v634 = v631 + v611;
  v635 = v612 + ((v632 & ~v634 | v633) >> 63);
  result[6] = v630;
  v636 = a2[1];
  v637 = HIDWORD(*a2);
  LODWORD(v633) = *a2;
  v639 = a3[6];
  v638 = a3[7];
  v640 = HIDWORD(v638);
  LODWORD(v602) = v638;
  v641 = v638 * (unint64_t)v633;
  v642 = v638 * (unint64_t)v637;
  v643 = HIDWORD(v642) + v640 * (unint64_t)v637;
  v644 = v641 | (v642 << 32);
  v645 = v641 & (v642 << 32);
  v646 = (v642 << 32) + v602 * (unint64_t)v633;
  v647 = v644 & ~v646 | v645;
  v648 = v640 * (unint64_t)v633;
  v649 = v646 | (v648 << 32);
  v650 = v646 & (v648 << 32);
  v651 = v646 + (v648 << 32);
  v652 = v643 + HIDWORD(v648) + (v647 >> 63) + ((v649 & ~v651 | v650) >> 63);
  v653 = v634 | v651;
  v654 = v634 & v651;
  v655 = v634 + v651;
  v656 = v652 + ((v653 & ~v655 | v654) >> 63);
  v657 = v656 | v635;
  v658 = v656 & v635;
  v659 = v656 + v635;
  v660 = v657 & ~v659 | v658;
  v661 = HIDWORD(v636);
  LODWORD(v658) = v636;
  v662 = HIDWORD(v639);
  LODWORD(v649) = v639;
  v663 = v639 * (unint64_t)v636;
  v664 = v639 * (unint64_t)v661;
  v665 = HIDWORD(v664) + v662 * (unint64_t)v661;
  v666 = v663 | (v664 << 32);
  v667 = v663 & (v664 << 32);
  v668 = (v664 << 32) + v649 * (unint64_t)v658;
  v669 = v666 & ~v668 | v667;
  v670 = v662 * (unint64_t)v658;
  v671 = v668 | (v670 << 32);
  v672 = v668 & (v670 << 32);
  v673 = v668 + (v670 << 32);
  v674 = v665 + HIDWORD(v670) + (v669 >> 63) + ((v671 & ~v673 | v672) >> 63);
  v675 = v655 | v673;
  v676 = v655 & v673;
  v677 = v655 + v673;
  v678 = v674 + ((v675 & ~v677 | v676) >> 63);
  v679 = v678 | v659;
  v680 = v678 & v659;
  v681 = v678 + v659;
  v682 = ((v679 & ~v681 | v680) >> 63) + (v660 >> 63);
  v683 = a2[2];
  v684 = a2[3];
  v685 = HIDWORD(v683);
  LODWORD(v671) = v683;
  v687 = a3[4];
  v686 = a3[5];
  v688 = HIDWORD(v686);
  LODWORD(v666) = v686;
  v689 = v686 * (unint64_t)v683;
  v690 = v686 * (unint64_t)v685;
  v691 = HIDWORD(v690) + v688 * (unint64_t)v685;
  v692 = v689 | (v690 << 32);
  v693 = v689 & (v690 << 32);
  v694 = (v690 << 32) + v666 * (unint64_t)v671;
  v695 = v692 & ~v694 | v693;
  v696 = v688 * (unint64_t)v671;
  v697 = v694 | (v696 << 32);
  v698 = v694 & (v696 << 32);
  v699 = v694 + (v696 << 32);
  v700 = v691 + HIDWORD(v696) + (v695 >> 63) + ((v697 & ~v699 | v698) >> 63);
  v701 = v677 | v699;
  v702 = v677 & v699;
  v703 = v677 + v699;
  v704 = v700 + ((v701 & ~v703 | v702) >> 63);
  v705 = v704 | v681;
  v706 = v704 & v681;
  v707 = v704 + v681;
  v708 = v682 + ((v705 & ~v707 | v706) >> 63);
  v709 = HIDWORD(v684);
  LODWORD(v705) = v684;
  v710 = HIDWORD(v687);
  LODWORD(v699) = v687;
  v711 = v687 * (unint64_t)v684;
  v712 = v687 * (unint64_t)v709;
  v713 = HIDWORD(v712) + v710 * (unint64_t)v709;
  v714 = (v712 << 32) + v699 * (unint64_t)v705;
  v715 = (v711 | (v712 << 32)) & ~v714 | v711 & (v712 << 32);
  v716 = v710 * (unint64_t)v705;
  v717 = v714 | (v716 << 32);
  v718 = v714 & (v716 << 32);
  v719 = v714 + (v716 << 32);
  v720 = v713 + HIDWORD(v716) + (v715 >> 63) + ((v717 & ~v719 | v718) >> 63);
  v721 = v719 | v703;
  v722 = v719 & v703;
  v723 = v719 + v703;
  v724 = v720 + ((v721 & ~v723 | v722) >> 63);
  v725 = v724 | v707;
  v726 = v724 & v707;
  v727 = v724 + v707;
  v728 = v708 + ((v725 & ~v727 | v726) >> 63);
  v729 = a2[4];
  v730 = a2[5];
  v731 = HIDWORD(v729);
  LODWORD(v717) = v729;
  v733 = a3[2];
  v732 = a3[3];
  v734 = HIDWORD(v732);
  LODWORD(v698) = v732;
  v735 = v732 * (unint64_t)v729;
  v736 = v732 * (unint64_t)v731;
  v737 = HIDWORD(v736) + v734 * (unint64_t)v731;
  v738 = v735 | (v736 << 32);
  v739 = v735 & (v736 << 32);
  v740 = (v736 << 32) + v698 * (unint64_t)v717;
  v741 = v738 & ~v740 | v739;
  v742 = v734 * (unint64_t)v717;
  v743 = v740 | (v742 << 32);
  v744 = v740 & (v742 << 32);
  v745 = v740 + (v742 << 32);
  v746 = v737 + HIDWORD(v742) + (v741 >> 63) + ((v743 & ~v745 | v744) >> 63);
  v747 = v745 | v723;
  v748 = v745 & v723;
  v749 = v745 + v723;
  v750 = v746 + ((v747 & ~v749 | v748) >> 63);
  v751 = v750 | v727;
  v752 = v750 & v727;
  v753 = v750 + v727;
  v754 = v728 + ((v751 & ~v753 | v752) >> 63);
  v755 = HIDWORD(v730);
  LODWORD(v751) = v730;
  v756 = HIDWORD(v733);
  LODWORD(v745) = v733;
  v757 = v733 * (unint64_t)v730;
  v758 = v733 * (unint64_t)v755;
  v759 = HIDWORD(v758) + v756 * (unint64_t)v755;
  v760 = (v758 << 32) + v745 * (unint64_t)v751;
  v761 = (v757 | (v758 << 32)) & ~v760 | v757 & (v758 << 32);
  v762 = v756 * (unint64_t)v751;
  v763 = v760 | (v762 << 32);
  v764 = v760 & (v762 << 32);
  v765 = v760 + (v762 << 32);
  v766 = v759 + HIDWORD(v762) + (v761 >> 63) + ((v763 & ~v765 | v764) >> 63);
  v767 = v765 | v749;
  v768 = v765 & v749;
  v769 = v765 + v749;
  v770 = v766 + ((v767 & ~v769 | v768) >> 63);
  v771 = v770 | v753;
  v772 = v770 & v753;
  v773 = v770 + v753;
  v774 = v754 + ((v771 & ~v773 | v772) >> 63);
  v775 = a2[6];
  v776 = a2[7];
  v777 = HIDWORD(v775);
  LODWORD(v763) = v775;
  v778 = a3[1];
  v779 = HIDWORD(v778);
  LODWORD(v744) = v778;
  v780 = v778 * (unint64_t)v775;
  v781 = v778 * (unint64_t)v777;
  v782 = HIDWORD(v781) + v779 * (unint64_t)v777;
  v783 = v780 | (v781 << 32);
  v784 = v780 & (v781 << 32);
  v785 = (v781 << 32) + v744 * (unint64_t)v763;
  v786 = v783 & ~v785 | v784;
  v787 = v779 * (unint64_t)v763;
  v788 = v785 | (v787 << 32);
  v789 = v785 & (v787 << 32);
  v790 = v785 + (v787 << 32);
  v791 = v782 + HIDWORD(v787) + (v786 >> 63) + ((v788 & ~v790 | v789) >> 63);
  v792 = v790 | v769;
  v793 = v790 & v769;
  v794 = v790 + v769;
  v795 = v791 + ((v792 & ~v794 | v793) >> 63);
  v796 = v795 | v773;
  v797 = v795 & v773;
  v798 = v795 + v773;
  v799 = v774 + ((v796 & ~v798 | v797) >> 63);
  v800 = HIDWORD(v776);
  LODWORD(v796) = v776;
  v801 = HIDWORD(*a3);
  LODWORD(v790) = *a3;
  v802 = v790 * (unint64_t)v776;
  v803 = v790 * (unint64_t)v800;
  v804 = HIDWORD(v803) + v801 * (unint64_t)v800;
  v805 = (v803 << 32) + v790 * (unint64_t)v796;
  v806 = (v802 | (v803 << 32)) & ~v805 | v802 & (v803 << 32);
  v807 = v801 * (unint64_t)v796;
  v808 = v805 | (v807 << 32);
  v809 = v805 & (v807 << 32);
  v810 = v805 + (v807 << 32);
  v811 = v804 + HIDWORD(v807) + (v806 >> 63) + ((v808 & ~v810 | v809) >> 63);
  v812 = v810 + v794;
  v813 = v811 + (((v810 | v794) & ~(v810 + v794) | v810 & v794) >> 63);
  v814 = v813 | v798;
  v815 = v813 & v798;
  v816 = v813 + v798;
  v817 = v799 + ((v814 & ~v816 | v815) >> 63);
  result[7] = v812;
  v818 = a2[7];
  v819 = HIDWORD(v818);
  LODWORD(v815) = v818;
  v820 = a3[1];
  v821 = a3[2];
  v822 = HIDWORD(v820);
  LODWORD(v809) = v820;
  v823 = v820 * (unint64_t)v818;
  v824 = v820 * (unint64_t)v819;
  v825 = HIDWORD(v824) + v822 * (unint64_t)v819;
  v826 = v823 | (v824 << 32);
  v827 = v823 & (v824 << 32);
  v828 = (v824 << 32) + v809 * (unint64_t)v815;
  v829 = v826 & ~v828 | v827;
  v830 = v822 * (unint64_t)v815;
  v831 = v828 | (v830 << 32);
  v832 = v828 & (v830 << 32);
  v833 = v828 + (v830 << 32);
  v834 = v825 + HIDWORD(v830) + (v829 >> 63) + ((v831 & ~v833 | v832) >> 63);
  v835 = v816 | v833;
  v836 = v816 & v833;
  v837 = v816 + v833;
  v838 = v834 + ((v835 & ~v837 | v836) >> 63);
  v839 = v838 | v817;
  v840 = v838 & v817;
  v841 = v838 + v817;
  v842 = v839 & ~v841 | v840;
  v844 = a2[5];
  v843 = a2[6];
  v845 = HIDWORD(v843);
  LODWORD(v831) = v843;
  v846 = HIDWORD(v821);
  LODWORD(v788) = v821;
  v847 = v821 * (unint64_t)v843;
  v848 = v821 * (unint64_t)v845;
  v849 = HIDWORD(v848) + v846 * (unint64_t)v845;
  v850 = v847 | (v848 << 32);
  v851 = v847 & (v848 << 32);
  v852 = (v848 << 32) + v788 * (unint64_t)v831;
  v853 = v850 & ~v852 | v851;
  v854 = v846 * (unint64_t)v831;
  v855 = v852 | (v854 << 32);
  v856 = v852 & (v854 << 32);
  v857 = v852 + (v854 << 32);
  v858 = v849 + HIDWORD(v854) + (v853 >> 63) + ((v855 & ~v857 | v856) >> 63);
  v859 = v837 | v857;
  v860 = v837 & v857;
  v861 = v837 + v857;
  v862 = v858 + ((v859 & ~v861 | v860) >> 63);
  v863 = v862 | v841;
  v864 = v862 & v841;
  v865 = v862 + v841;
  v866 = ((v863 & ~v865 | v864) >> 63) + (v842 >> 63);
  v867 = HIDWORD(v844);
  LODWORD(v863) = v844;
  v868 = a3[3];
  v869 = a3[4];
  v870 = HIDWORD(v868);
  LODWORD(v856) = v868;
  v871 = v868 * (unint64_t)v844;
  v872 = v868 * (unint64_t)v867;
  v873 = HIDWORD(v872) + v870 * (unint64_t)v867;
  v874 = v871 | (v872 << 32);
  v875 = v871 & (v872 << 32);
  v876 = (v872 << 32) + v856 * (unint64_t)v863;
  v877 = v874 & ~v876 | v875;
  v878 = v870 * (unint64_t)v863;
  v879 = v876 | (v878 << 32);
  v880 = v876 & (v878 << 32);
  v881 = v876 + (v878 << 32);
  v882 = v873 + HIDWORD(v878) + (v877 >> 63) + ((v879 & ~v881 | v880) >> 63);
  v883 = v861 | v881;
  v884 = v861 & v881;
  v885 = v861 + v881;
  v886 = v882 + ((v883 & ~v885 | v884) >> 63);
  v887 = v886 | v865;
  v888 = v886 & v865;
  v889 = v886 + v865;
  v890 = v866 + ((v887 & ~v889 | v888) >> 63);
  v892 = a2[3];
  v891 = a2[4];
  v893 = HIDWORD(v891);
  LODWORD(v881) = v891;
  v894 = HIDWORD(v869);
  LODWORD(v880) = v869;
  v895 = v869 * (unint64_t)v891;
  v896 = v869 * (unint64_t)v893;
  v897 = HIDWORD(v896) + v894 * (unint64_t)v893;
  v898 = v895 | (v896 << 32);
  v899 = v895 & (v896 << 32);
  v900 = (v896 << 32) + v880 * (unint64_t)v881;
  v901 = v898 & ~v900 | v899;
  v902 = v894 * (unint64_t)v881;
  v903 = v900 | (v902 << 32);
  v904 = v900 & (v902 << 32);
  v905 = v900 + (v902 << 32);
  v906 = v897 + HIDWORD(v902) + (v901 >> 63) + ((v903 & ~v905 | v904) >> 63);
  v907 = v905 | v885;
  v908 = v905 & v885;
  v909 = v905 + v885;
  v910 = v906 + ((v907 & ~v909 | v908) >> 63);
  v911 = v910 | v889;
  v912 = v910 & v889;
  v913 = v910 + v889;
  v914 = v890 + ((v911 & ~v913 | v912) >> 63);
  v915 = HIDWORD(v892);
  LODWORD(v911) = v892;
  v916 = a3[5];
  v917 = a3[6];
  v918 = HIDWORD(v916);
  LODWORD(v904) = v916;
  v919 = v916 * (unint64_t)v892;
  v920 = v916 * (unint64_t)v915;
  v921 = HIDWORD(v920) + v918 * (unint64_t)v915;
  v922 = v919 | (v920 << 32);
  v923 = v919 & (v920 << 32);
  v924 = (v920 << 32) + v904 * (unint64_t)v911;
  v925 = v922 & ~v924 | v923;
  v926 = v918 * (unint64_t)v911;
  v927 = v924 | (v926 << 32);
  v928 = v924 & (v926 << 32);
  v929 = v924 + (v926 << 32);
  v930 = v921 + HIDWORD(v926) + (v925 >> 63) + ((v927 & ~v929 | v928) >> 63);
  v931 = v929 | v909;
  v932 = v929 & v909;
  v933 = v929 + v909;
  v934 = v930 + ((v931 & ~v933 | v932) >> 63);
  v935 = v934 | v913;
  v936 = v934 & v913;
  v937 = v934 + v913;
  v938 = v914 + ((v935 & ~v937 | v936) >> 63);
  v940 = a2[1];
  v939 = a2[2];
  v941 = HIDWORD(v939);
  LODWORD(v929) = v939;
  v942 = HIDWORD(v917);
  LODWORD(v928) = v917;
  v943 = v917 * (unint64_t)v939;
  v944 = v917 * (unint64_t)v941;
  v945 = HIDWORD(v944) + v942 * (unint64_t)v941;
  v946 = v943 | (v944 << 32);
  v947 = v943 & (v944 << 32);
  v948 = (v944 << 32) + v928 * (unint64_t)v929;
  v949 = v946 & ~v948 | v947;
  v950 = v942 * (unint64_t)v929;
  v951 = v948 | (v950 << 32);
  v952 = v948 & (v950 << 32);
  v953 = v948 + (v950 << 32);
  v954 = v945 + HIDWORD(v950) + (v949 >> 63) + ((v951 & ~v953 | v952) >> 63);
  v955 = v953 | v933;
  v956 = v953 & v933;
  v957 = v953 + v933;
  v958 = v954 + ((v955 & ~v957 | v956) >> 63);
  v959 = v958 | v937;
  v960 = v958 & v937;
  v961 = v958 + v937;
  v962 = v938 + ((v959 & ~v961 | v960) >> 63);
  v963 = a3[7];
  v964 = HIDWORD(v940);
  LODWORD(v960) = v940;
  v965 = HIDWORD(v963);
  LODWORD(v951) = v963;
  v966 = v963 * (unint64_t)v940;
  v967 = v951 * (unint64_t)HIDWORD(v940);
  v968 = HIDWORD(v967) + v965 * (unint64_t)v964;
  v969 = v966 | (v967 << 32);
  v970 = v966 & (v967 << 32);
  v971 = (v967 << 32) + v951 * (unint64_t)v960;
  v972 = v969 & ~v971 | v970;
  v973 = v965 * (unint64_t)v960;
  v974 = v971 | (v973 << 32);
  v975 = v971 & (v973 << 32);
  v976 = v971 + (v973 << 32);
  v977 = v968 + HIDWORD(v973) + (v972 >> 63) + ((v974 & ~v976 | v975) >> 63);
  v978 = v976 | v957;
  v979 = v976 & v957;
  v980 = v976 + v957;
  v981 = v977 + ((v978 & ~v980 | v979) >> 63);
  v982 = v981 | v961;
  v983 = v981 & v961;
  v984 = v981 + v961;
  v985 = v962 + ((v982 & ~v984 | v983) >> 63);
  result[8] = v980;
  v986 = a2[2];
  v987 = a2[3];
  v988 = HIDWORD(v986);
  LODWORD(v983) = v986;
  v990 = a3[6];
  v989 = a3[7];
  v991 = HIDWORD(v989);
  LODWORD(v952) = v989;
  v992 = v989 * (unint64_t)v986;
  v993 = v989 * (unint64_t)v988;
  v994 = HIDWORD(v993) + v991 * (unint64_t)v988;
  v995 = v992 | (v993 << 32);
  v996 = v992 & (v993 << 32);
  v997 = (v993 << 32) + v952 * (unint64_t)v983;
  v998 = v995 & ~v997 | v996;
  v999 = v991 * (unint64_t)v983;
  v1000 = v997 | (v999 << 32);
  v1001 = v997 & (v999 << 32);
  v1002 = v997 + (v999 << 32);
  v1003 = v994 + HIDWORD(v999) + (v998 >> 63) + ((v1000 & ~v1002 | v1001) >> 63);
  v1004 = v984 | v1002;
  v1005 = v984 & v1002;
  v1006 = v984 + v1002;
  v1007 = v1003 + ((v1004 & ~v1006 | v1005) >> 63);
  v1008 = v1007 | v985;
  v1009 = v1007 & v985;
  v1010 = v1007 + v985;
  v1011 = v1008 & ~v1010 | v1009;
  v1012 = HIDWORD(v987);
  LODWORD(v1009) = v987;
  v1013 = HIDWORD(v990);
  LODWORD(v1000) = v990;
  v1014 = v990 * (unint64_t)v987;
  v1015 = v990 * (unint64_t)v1012;
  v1016 = HIDWORD(v1015) + v1013 * (unint64_t)v1012;
  v1017 = v1014 | (v1015 << 32);
  v1018 = v1014 & (v1015 << 32);
  v1019 = (v1015 << 32) + v1000 * (unint64_t)v1009;
  v1020 = v1017 & ~v1019 | v1018;
  v1021 = v1013 * (unint64_t)v1009;
  v1022 = v1019 | (v1021 << 32);
  v1023 = v1019 & (v1021 << 32);
  v1024 = v1019 + (v1021 << 32);
  v1025 = v1016 + HIDWORD(v1021) + (v1020 >> 63) + ((v1022 & ~v1024 | v1023) >> 63);
  v1026 = v1006 | v1024;
  v1027 = v1006 & v1024;
  v1028 = v1006 + v1024;
  v1029 = v1025 + ((v1026 & ~v1028 | v1027) >> 63);
  v1030 = v1029 | v1010;
  v1031 = v1029 & v1010;
  v1032 = v1029 + v1010;
  v1033 = ((v1030 & ~v1032 | v1031) >> 63) + (v1011 >> 63);
  v1034 = a2[4];
  v1035 = a2[5];
  v1036 = HIDWORD(v1034);
  LODWORD(v1022) = v1034;
  v1038 = a3[4];
  v1037 = a3[5];
  v1039 = HIDWORD(v1037);
  LODWORD(v1017) = v1037;
  v1040 = v1037 * (unint64_t)v1034;
  v1041 = v1037 * (unint64_t)v1036;
  v1042 = HIDWORD(v1041) + v1039 * (unint64_t)v1036;
  v1043 = v1040 | (v1041 << 32);
  v1044 = v1040 & (v1041 << 32);
  v1045 = (v1041 << 32) + v1017 * (unint64_t)v1022;
  v1046 = v1043 & ~v1045 | v1044;
  v1047 = v1039 * (unint64_t)v1022;
  v1048 = v1045 | (v1047 << 32);
  v1049 = v1045 & (v1047 << 32);
  v1050 = v1045 + (v1047 << 32);
  v1051 = v1042 + HIDWORD(v1047) + (v1046 >> 63) + ((v1048 & ~v1050 | v1049) >> 63);
  v1052 = v1028 | v1050;
  v1053 = v1028 & v1050;
  v1054 = v1028 + v1050;
  v1055 = v1051 + ((v1052 & ~v1054 | v1053) >> 63);
  v1056 = v1055 | v1032;
  v1057 = v1055 & v1032;
  v1058 = v1055 + v1032;
  v1059 = v1033 + ((v1056 & ~v1058 | v1057) >> 63);
  v1060 = HIDWORD(v1035);
  LODWORD(v1056) = v1035;
  v1061 = HIDWORD(v1038);
  LODWORD(v1050) = v1038;
  v1062 = v1038 * (unint64_t)v1035;
  v1063 = v1038 * (unint64_t)v1060;
  v1064 = HIDWORD(v1063) + v1061 * (unint64_t)v1060;
  v1065 = (v1063 << 32) + v1050 * (unint64_t)v1056;
  v1066 = (v1062 | (v1063 << 32)) & ~v1065 | v1062 & (v1063 << 32);
  v1067 = v1061 * (unint64_t)v1056;
  v1068 = v1065 | (v1067 << 32);
  v1069 = v1065 & (v1067 << 32);
  v1070 = v1065 + (v1067 << 32);
  v1071 = v1064 + HIDWORD(v1067) + (v1066 >> 63) + ((v1068 & ~v1070 | v1069) >> 63);
  v1072 = v1070 | v1054;
  v1073 = v1070 & v1054;
  v1074 = v1070 + v1054;
  v1075 = v1071 + ((v1072 & ~v1074 | v1073) >> 63);
  v1076 = v1075 | v1058;
  v1077 = v1075 & v1058;
  v1078 = v1075 + v1058;
  v1079 = v1059 + ((v1076 & ~v1078 | v1077) >> 63);
  v1080 = a2[6];
  v1081 = a2[7];
  v1082 = HIDWORD(v1080);
  LODWORD(v1068) = v1080;
  v1084 = a3[2];
  v1083 = a3[3];
  v1085 = HIDWORD(v1083);
  LODWORD(v1049) = v1083;
  v1086 = v1083 * (unint64_t)v1080;
  v1087 = v1083 * (unint64_t)v1082;
  v1088 = HIDWORD(v1087) + v1085 * (unint64_t)v1082;
  v1089 = v1086 | (v1087 << 32);
  v1090 = v1086 & (v1087 << 32);
  v1091 = (v1087 << 32) + v1049 * (unint64_t)v1068;
  v1092 = v1089 & ~v1091 | v1090;
  v1093 = v1085 * (unint64_t)v1068;
  v1094 = v1091 | (v1093 << 32);
  v1095 = v1091 & (v1093 << 32);
  v1096 = v1091 + (v1093 << 32);
  v1097 = v1088 + HIDWORD(v1093) + (v1092 >> 63) + ((v1094 & ~v1096 | v1095) >> 63);
  v1098 = v1096 | v1074;
  v1099 = v1096 & v1074;
  v1100 = v1096 + v1074;
  v1101 = v1097 + ((v1098 & ~v1100 | v1099) >> 63);
  v1102 = v1101 | v1078;
  v1103 = v1101 & v1078;
  v1104 = v1101 + v1078;
  v1105 = v1079 + ((v1102 & ~v1104 | v1103) >> 63);
  v1106 = HIDWORD(v1081);
  LODWORD(v1102) = v1081;
  v1107 = HIDWORD(v1084);
  LODWORD(v1096) = v1084;
  v1108 = v1084 * (unint64_t)v1081;
  v1109 = v1084 * (unint64_t)v1106;
  v1110 = HIDWORD(v1109) + v1107 * (unint64_t)v1106;
  v1111 = (v1109 << 32) + v1096 * (unint64_t)v1102;
  v1112 = (v1108 | (v1109 << 32)) & ~v1111 | v1108 & (v1109 << 32);
  v1113 = v1107 * (unint64_t)v1102;
  v1114 = v1111 | (v1113 << 32);
  v1115 = v1111 & (v1113 << 32);
  v1116 = v1111 + (v1113 << 32);
  v1117 = v1110 + HIDWORD(v1113) + (v1112 >> 63) + ((v1114 & ~v1116 | v1115) >> 63);
  v1118 = v1116 | v1100;
  v1119 = v1116 & v1100;
  v1120 = v1116 + v1100;
  v1121 = v1117 + ((v1118 & ~v1120 | v1119) >> 63);
  v1122 = v1121 | v1104;
  v1123 = v1121 & v1104;
  v1124 = v1121 + v1104;
  v1125 = v1105 + ((v1122 & ~v1124 | v1123) >> 63);
  result[9] = v1120;
  v1126 = a2[7];
  v1127 = HIDWORD(v1126);
  LODWORD(v1122) = v1126;
  v1128 = a3[3];
  v1129 = a3[4];
  v1130 = HIDWORD(v1128);
  LODWORD(v1115) = v1128;
  v1131 = v1128 * (unint64_t)v1126;
  v1132 = v1128 * (unint64_t)v1127;
  v1133 = HIDWORD(v1132) + v1130 * (unint64_t)v1127;
  v1134 = v1131 | (v1132 << 32);
  v1135 = v1131 & (v1132 << 32);
  v1136 = (v1132 << 32) + v1115 * (unint64_t)v1122;
  v1137 = v1134 & ~v1136 | v1135;
  v1138 = v1130 * (unint64_t)v1122;
  v1139 = v1136 | (v1138 << 32);
  v1140 = v1136 & (v1138 << 32);
  v1141 = v1136 + (v1138 << 32);
  v1142 = v1133 + HIDWORD(v1138) + (v1137 >> 63) + ((v1139 & ~v1141 | v1140) >> 63);
  v1143 = v1124 | v1141;
  v1144 = v1124 & v1141;
  v1145 = v1124 + v1141;
  v1146 = v1142 + ((v1143 & ~v1145 | v1144) >> 63);
  v1147 = v1146 | v1125;
  v1148 = v1146 + v1125;
  v1149 = v1147 & ~v1148;
  v1151 = a2[5];
  v1150 = a2[6];
  v1152 = HIDWORD(v1150);
  LODWORD(v1139) = v1150;
  v1153 = HIDWORD(v1129);
  LODWORD(v1094) = v1129;
  v1154 = v1129 * (unint64_t)v1150;
  v1155 = v1129 * (unint64_t)v1152;
  v1156 = HIDWORD(v1155) + v1153 * (unint64_t)v1152;
  v1157 = v1154 | (v1155 << 32);
  v1158 = v1154 & (v1155 << 32);
  v1159 = (v1155 << 32) + v1094 * (unint64_t)v1139;
  v1160 = v1157 & ~v1159 | v1158;
  v1161 = v1153 * (unint64_t)v1139;
  v1162 = v1159 | (v1161 << 32);
  v1163 = v1159 & (v1161 << 32);
  v1164 = v1159 + (v1161 << 32);
  v1165 = v1156 + HIDWORD(v1161) + (v1160 >> 63) + ((v1162 & ~v1164 | v1163) >> 63);
  v1166 = v1145 | v1164;
  v1167 = v1145 & v1164;
  v1168 = v1145 + v1164;
  v1169 = v1165 + ((v1166 & ~v1168 | v1167) >> 63);
  v1170 = v1169 | v1148;
  v1171 = v1169 & v1148;
  v1172 = v1169 + v1148;
  v1173 = ((v1170 & ~v1172 | v1171) >> 63) + (v1149 >> 63);
  v1174 = HIDWORD(v1151);
  LODWORD(v1170) = v1151;
  v1175 = a3[5];
  v1176 = a3[6];
  v1177 = HIDWORD(v1175);
  LODWORD(v1163) = v1175;
  v1178 = v1175 * (unint64_t)v1151;
  v1179 = v1175 * (unint64_t)v1174;
  v1180 = HIDWORD(v1179) + v1177 * (unint64_t)v1174;
  v1181 = v1178 | (v1179 << 32);
  v1182 = v1178 & (v1179 << 32);
  v1183 = (v1179 << 32) + v1163 * (unint64_t)v1170;
  v1184 = v1181 & ~v1183 | v1182;
  v1185 = v1177 * (unint64_t)v1170;
  v1186 = v1183 | (v1185 << 32);
  v1187 = v1183 & (v1185 << 32);
  v1188 = v1183 + (v1185 << 32);
  v1189 = v1180 + HIDWORD(v1185) + (v1184 >> 63) + ((v1186 & ~v1188 | v1187) >> 63);
  v1190 = v1168 | v1188;
  v1191 = v1168 & v1188;
  v1192 = v1168 + v1188;
  v1193 = v1189 + ((v1190 & ~v1192 | v1191) >> 63);
  v1194 = v1193 | v1172;
  v1195 = v1193 & v1172;
  v1196 = v1193 + v1172;
  v1197 = v1173 + ((v1194 & ~v1196 | v1195) >> 63);
  v1199 = a2[3];
  v1198 = a2[4];
  v1200 = HIDWORD(v1198);
  LODWORD(v1188) = v1198;
  v1201 = HIDWORD(v1176);
  LODWORD(v1187) = v1176;
  v1202 = v1176 * (unint64_t)v1198;
  v1203 = v1176 * (unint64_t)v1200;
  v1204 = HIDWORD(v1203) + v1201 * (unint64_t)v1200;
  v1205 = v1202 | (v1203 << 32);
  v1206 = v1202 & (v1203 << 32);
  v1207 = (v1203 << 32) + v1187 * (unint64_t)v1188;
  v1208 = v1205 & ~v1207 | v1206;
  v1209 = v1201 * (unint64_t)v1188;
  v1210 = v1207 | (v1209 << 32);
  v1211 = v1207 & (v1209 << 32);
  v1212 = v1207 + (v1209 << 32);
  v1213 = v1204 + HIDWORD(v1209) + (v1208 >> 63) + ((v1210 & ~v1212 | v1211) >> 63);
  v1214 = v1212 | v1192;
  v1215 = v1212 & v1192;
  v1216 = v1212 + v1192;
  v1217 = v1213 + ((v1214 & ~v1216 | v1215) >> 63);
  v1218 = v1217 | v1196;
  v1219 = v1217 & v1196;
  v1220 = v1217 + v1196;
  v1221 = v1197 + ((v1218 & ~v1220 | v1219) >> 63);
  v1222 = a3[7];
  v1223 = HIDWORD(v1199);
  LODWORD(v1219) = v1199;
  v1224 = HIDWORD(v1222);
  LODWORD(v1210) = v1222;
  v1225 = v1222 * (unint64_t)v1199;
  v1226 = v1210 * (unint64_t)HIDWORD(v1199);
  v1227 = HIDWORD(v1226) + v1224 * (unint64_t)v1223;
  v1228 = v1225 | (v1226 << 32);
  v1229 = v1225 & (v1226 << 32);
  v1230 = (v1226 << 32) + v1210 * (unint64_t)v1219;
  v1231 = v1228 & ~v1230 | v1229;
  v1232 = v1224 * (unint64_t)v1219;
  v1233 = v1230 | (v1232 << 32);
  v1234 = v1230 & (v1232 << 32);
  v1235 = v1230 + (v1232 << 32);
  v1236 = v1227 + HIDWORD(v1232) + (v1231 >> 63) + ((v1233 & ~v1235 | v1234) >> 63);
  v1237 = v1235 | v1216;
  v1238 = v1235 & v1216;
  v1239 = v1235 + v1216;
  v1240 = v1236 + ((v1237 & ~v1239 | v1238) >> 63);
  v1241 = v1240 | v1220;
  v1242 = v1240 & v1220;
  v1243 = v1240 + v1220;
  v1244 = v1221 + ((v1241 & ~v1243 | v1242) >> 63);
  result[10] = v1239;
  v1245 = a2[4];
  v1246 = a2[5];
  v1247 = HIDWORD(v1245);
  LODWORD(v1242) = v1245;
  v1249 = a3[6];
  v1248 = a3[7];
  v1250 = HIDWORD(v1248);
  LODWORD(v1211) = v1248;
  v1251 = v1248 * (unint64_t)v1245;
  v1252 = v1248 * (unint64_t)v1247;
  v1253 = HIDWORD(v1252) + v1250 * (unint64_t)v1247;
  v1254 = v1251 | (v1252 << 32);
  v1255 = v1251 & (v1252 << 32);
  v1256 = (v1252 << 32) + v1211 * (unint64_t)v1242;
  v1257 = v1254 & ~v1256 | v1255;
  v1258 = v1250 * (unint64_t)v1242;
  v1259 = v1256 | (v1258 << 32);
  v1260 = v1256 & (v1258 << 32);
  v1261 = v1256 + (v1258 << 32);
  v1262 = v1253 + HIDWORD(v1258) + (v1257 >> 63) + ((v1259 & ~v1261 | v1260) >> 63);
  v1263 = v1243 | v1261;
  v1264 = v1243 & v1261;
  v1265 = v1243 + v1261;
  v1266 = v1262 + ((v1263 & ~v1265 | v1264) >> 63);
  v1267 = v1266 | v1244;
  v1268 = v1266 + v1244;
  v1269 = v1267 & ~v1268;
  v1270 = HIDWORD(v1246);
  LODWORD(v1264) = v1246;
  v1271 = HIDWORD(v1249);
  LODWORD(v1259) = v1249;
  v1272 = v1249 * (unint64_t)v1246;
  v1273 = v1249 * (unint64_t)v1270;
  v1274 = HIDWORD(v1273) + v1271 * (unint64_t)v1270;
  v1275 = v1272 | (v1273 << 32);
  v1276 = v1272 & (v1273 << 32);
  v1277 = (v1273 << 32) + v1259 * (unint64_t)v1264;
  v1278 = v1275 & ~v1277 | v1276;
  v1279 = v1271 * (unint64_t)v1264;
  v1280 = v1277 | (v1279 << 32);
  v1281 = v1277 & (v1279 << 32);
  v1282 = v1277 + (v1279 << 32);
  v1283 = v1274 + HIDWORD(v1279) + (v1278 >> 63) + ((v1280 & ~v1282 | v1281) >> 63);
  v1284 = v1265 | v1282;
  v1285 = v1265 & v1282;
  v1286 = v1265 + v1282;
  v1287 = v1283 + ((v1284 & ~v1286 | v1285) >> 63);
  v1288 = v1287 | v1268;
  v1289 = v1287 & v1268;
  v1290 = v1287 + v1268;
  v1291 = ((v1288 & ~v1290 | v1289) >> 63) + (v1269 >> 63);
  v1292 = a2[6];
  v1293 = a2[7];
  v1294 = HIDWORD(v1292);
  LODWORD(v1280) = v1292;
  v1296 = a3[4];
  v1295 = a3[5];
  v1297 = HIDWORD(v1295);
  LODWORD(v1275) = v1295;
  v1298 = v1295 * (unint64_t)v1292;
  v1299 = v1295 * (unint64_t)v1294;
  v1300 = HIDWORD(v1299) + v1297 * (unint64_t)v1294;
  v1301 = v1298 | (v1299 << 32);
  v1302 = v1298 & (v1299 << 32);
  v1303 = (v1299 << 32) + v1275 * (unint64_t)v1280;
  v1304 = v1301 & ~v1303 | v1302;
  v1305 = v1297 * (unint64_t)v1280;
  v1306 = v1303 | (v1305 << 32);
  v1307 = v1303 & (v1305 << 32);
  v1308 = v1303 + (v1305 << 32);
  v1309 = v1300 + HIDWORD(v1305) + (v1304 >> 63) + ((v1306 & ~v1308 | v1307) >> 63);
  v1310 = v1286 | v1308;
  v1311 = v1286 & v1308;
  v1312 = v1286 + v1308;
  v1313 = v1309 + ((v1310 & ~v1312 | v1311) >> 63);
  v1314 = v1313 | v1290;
  v1315 = v1313 & v1290;
  v1316 = v1313 + v1290;
  v1317 = v1291 + ((v1314 & ~v1316 | v1315) >> 63);
  v1318 = HIDWORD(v1293);
  LODWORD(v1314) = v1293;
  v1319 = HIDWORD(v1296);
  LODWORD(v1308) = v1296;
  v1320 = v1296 * (unint64_t)v1293;
  v1321 = v1296 * (unint64_t)v1318;
  v1322 = HIDWORD(v1321) + v1319 * (unint64_t)v1318;
  v1323 = (v1321 << 32) + v1308 * (unint64_t)v1314;
  v1324 = (v1320 | (v1321 << 32)) & ~v1323 | v1320 & (v1321 << 32);
  v1325 = v1319 * (unint64_t)v1314;
  v1326 = v1323 | (v1325 << 32);
  v1327 = v1323 & (v1325 << 32);
  v1328 = v1323 + (v1325 << 32);
  v1329 = v1322 + HIDWORD(v1325) + (v1324 >> 63) + ((v1326 & ~v1328 | v1327) >> 63);
  v1330 = v1328 | v1312;
  v1331 = v1328 & v1312;
  v1332 = v1328 + v1312;
  v1333 = v1329 + ((v1330 & ~v1332 | v1331) >> 63);
  v1334 = v1333 | v1316;
  v1335 = v1333 & v1316;
  v1336 = v1333 + v1316;
  v1337 = v1317 + ((v1334 & ~v1336 | v1335) >> 63);
  result[11] = v1332;
  v1338 = a2[7];
  v1339 = HIDWORD(v1338);
  LODWORD(v1334) = v1338;
  v1340 = a3[5];
  v1341 = a3[6];
  v1342 = HIDWORD(v1340);
  LODWORD(v1327) = v1340;
  v1343 = v1340 * (unint64_t)v1338;
  v1344 = v1340 * (unint64_t)v1339;
  v1345 = HIDWORD(v1344) + v1342 * (unint64_t)v1339;
  v1346 = v1343 | (v1344 << 32);
  v1347 = v1343 & (v1344 << 32);
  v1348 = (v1344 << 32) + v1327 * (unint64_t)v1334;
  v1349 = v1346 & ~v1348 | v1347;
  v1350 = v1342 * (unint64_t)v1334;
  v1351 = v1348 | (v1350 << 32);
  v1352 = v1348 & (v1350 << 32);
  v1353 = v1348 + (v1350 << 32);
  v1354 = v1345 + HIDWORD(v1350) + (v1349 >> 63) + ((v1351 & ~v1353 | v1352) >> 63);
  v1355 = v1336 | v1353;
  v1356 = v1336 & v1353;
  v1357 = v1336 + v1353;
  v1358 = v1354 + ((v1355 & ~v1357 | v1356) >> 63);
  v1359 = v1358 | v1337;
  v1360 = v1358 + v1337;
  v1361 = v1359 & ~v1360;
  v1363 = a2[5];
  v1362 = a2[6];
  v1364 = HIDWORD(v1362);
  LODWORD(v1351) = v1362;
  v1365 = HIDWORD(v1341);
  LODWORD(v1306) = v1341;
  v1366 = v1341 * (unint64_t)v1362;
  v1367 = v1341 * (unint64_t)v1364;
  v1368 = HIDWORD(v1367) + v1365 * (unint64_t)v1364;
  v1369 = v1366 | (v1367 << 32);
  v1370 = v1366 & (v1367 << 32);
  v1371 = (v1367 << 32) + v1306 * (unint64_t)v1351;
  v1372 = v1369 & ~v1371 | v1370;
  v1373 = v1365 * (unint64_t)v1351;
  v1374 = v1371 | (v1373 << 32);
  v1375 = v1371 & (v1373 << 32);
  v1376 = v1371 + (v1373 << 32);
  v1377 = v1368 + HIDWORD(v1373) + (v1372 >> 63) + ((v1374 & ~v1376 | v1375) >> 63);
  v1378 = v1357 | v1376;
  v1379 = v1357 & v1376;
  v1380 = v1357 + v1376;
  v1381 = v1377 + ((v1378 & ~v1380 | v1379) >> 63);
  v1382 = v1381 | v1360;
  v1383 = v1381 & v1360;
  v1384 = v1381 + v1360;
  v1385 = ((v1382 & ~v1384 | v1383) >> 63) + (v1361 >> 63);
  v1386 = a3[7];
  v1387 = HIDWORD(v1363);
  LODWORD(v1383) = v1363;
  v1388 = HIDWORD(v1386);
  LODWORD(v1374) = v1386;
  v1389 = v1386 * (unint64_t)v1363;
  v1390 = v1374 * (unint64_t)HIDWORD(v1363);
  v1391 = HIDWORD(v1390) + v1388 * (unint64_t)v1387;
  v1392 = v1389 | (v1390 << 32);
  v1393 = v1389 & (v1390 << 32);
  v1394 = (v1390 << 32) + v1374 * (unint64_t)v1383;
  v1395 = v1392 & ~v1394 | v1393;
  v1396 = v1388 * (unint64_t)v1383;
  v1397 = v1394 | (v1396 << 32);
  v1398 = v1394 & (v1396 << 32);
  v1399 = v1394 + (v1396 << 32);
  v1400 = v1391 + HIDWORD(v1396) + (v1395 >> 63) + ((v1397 & ~v1399 | v1398) >> 63);
  v1401 = v1380 | v1399;
  v1402 = v1380 & v1399;
  v1403 = v1380 + v1399;
  v1404 = v1400 + ((v1401 & ~v1403 | v1402) >> 63);
  v1405 = v1404 | v1384;
  v1406 = v1404 & v1384;
  v1407 = v1404 + v1384;
  v1408 = v1385 + ((v1405 & ~v1407 | v1406) >> 63);
  result[12] = v1403;
  v1409 = a2[6];
  v1410 = a2[7];
  v1411 = HIDWORD(v1409);
  LODWORD(v1406) = v1409;
  v1413 = a3[6];
  v1412 = a3[7];
  v1414 = HIDWORD(v1412);
  LODWORD(v1375) = v1412;
  v1415 = v1412 * (unint64_t)v1409;
  v1416 = v1412 * (unint64_t)v1411;
  v1417 = HIDWORD(v1416) + v1414 * (unint64_t)v1411;
  v1418 = v1415 | (v1416 << 32);
  v1419 = v1415 & (v1416 << 32);
  v1420 = (v1416 << 32) + v1375 * (unint64_t)v1406;
  v1421 = v1418 & ~v1420 | v1419;
  v1422 = v1414 * (unint64_t)v1406;
  v1423 = v1420 | (v1422 << 32);
  v1424 = v1420 & (v1422 << 32);
  v1425 = v1420 + (v1422 << 32);
  v1426 = v1417 + HIDWORD(v1422) + (v1421 >> 63) + ((v1423 & ~v1425 | v1424) >> 63);
  v1427 = v1407 | v1425;
  v1428 = v1407 & v1425;
  v1429 = v1407 + v1425;
  v1430 = v1426 + ((v1427 & ~v1429 | v1428) >> 63);
  v1431 = v1408 + v1430;
  v1432 = v1430 & ~(v1408 + v1430);
  v1433 = HIDWORD(v1410);
  LODWORD(v1427) = v1410;
  v1434 = HIDWORD(v1413);
  LODWORD(v1423) = v1413;
  v1435 = v1413 * (unint64_t)v1410;
  v1436 = v1413 * (unint64_t)v1433;
  v1437 = HIDWORD(v1436) + v1434 * (unint64_t)v1433;
  v1438 = v1435 | (v1436 << 32);
  v1439 = v1435 & (v1436 << 32);
  v1440 = (v1436 << 32) + v1423 * (unint64_t)v1427;
  v1441 = v1438 & ~v1440 | v1439;
  v1442 = v1434 * (unint64_t)v1427;
  v1443 = v1440 | (v1442 << 32);
  v1444 = v1440 & (v1442 << 32);
  v1445 = v1440 + (v1442 << 32);
  v1446 = v1437
        + HIDWORD(v1442)
        + (v1441 >> 63)
        + ((v1443 & ~v1445 | v1444) >> 63)
        + (((v1429 | v1445) & ~(v1429 + v1445) | v1429 & v1445) >> 63);
  v1447 = v1446 | v1431;
  v1448 = v1446 & v1431;
  v1449 = v1446 + v1431;
  v1450 = v1447 & ~v1449 | v1448;
  result[13] = v1429 + v1445;
  v1451 = a2[7];
  v1452 = a3[7];
  v1453 = HIDWORD(v1451);
  LODWORD(v1429) = v1451;
  v1454 = HIDWORD(v1452);
  LODWORD(v1444) = v1452;
  v1455 = v1452 * (unint64_t)v1451;
  v1456 = v1452 * (unint64_t)v1453;
  v1457 = HIDWORD(v1456) + v1454 * (unint64_t)v1453;
  v1458 = v1455 | (v1456 << 32);
  v1459 = v1455 & (v1456 << 32);
  v1460 = (v1456 << 32) + v1444 * (unint64_t)v1429;
  v1461 = v1458 & ~v1460 | v1459;
  v1462 = v1454 * (unint64_t)v1429;
  v1463 = v1460 | (v1462 << 32);
  v1464 = v1460 & (v1462 << 32);
  v1465 = v1460 + (v1462 << 32);
  v1466 = v1457 + HIDWORD(v1462) + (v1461 >> 63) + ((v1463 & ~v1465 | v1464) >> 63);
  v1467 = v1449 | v1465;
  v1468 = v1449 & v1465;
  v1469 = v1449 + v1465;
  result[14] = v1469;
  result[15] = v1466 + (v1432 >> 63) + (v1450 >> 63) + ((v1467 & ~v1469 | v1468) >> 63);
  return result;
}

unint64_t bn_mul_words(unint64_t *rp, const unint64_t *ap, int num, unint64_t w)
{
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t v20;
  unint64_t v21;
  unint64_t v22;
  unint64_t v23;
  unint64_t v24;
  unint64_t v25;
  unint64_t v26;
  unint64_t v27;
  unint64_t v28;
  unint64_t v29;
  unint64_t v30;
  unint64_t v31;
  unint64_t v32;
  unint64_t v33;
  unint64_t v34;
  unint64_t v35;
  unint64_t v36;
  unint64_t v37;
  unint64_t v38;
  unint64_t v39;
  unint64_t v40;
  unint64_t v41;
  unint64_t v42;
  unint64_t v43;
  unint64_t v44;
  unint64_t v45;
  unint64_t v46;
  unint64_t v47;
  unint64_t v48;
  unint64_t v49;
  unint64_t v50;
  unint64_t v51;
  unint64_t v52;
  unint64_t v53;
  unint64_t v54;
  unint64_t v55;
  unint64_t v56;
  unint64_t v57;
  unint64_t v58;
  unint64_t v59;
  unint64_t v60;
  unint64_t v61;
  unint64_t v62;
  unint64_t v63;
  unint64_t v64;
  unint64_t v65;
  unint64_t v66;
  unint64_t v67;
  unint64_t v68;
  unint64_t v69;
  unint64_t v70;
  unint64_t v71;
  uint64_t v72;
  unint64_t v73;
  unint64_t v74;
  unint64_t v75;
  unint64_t v76;
  unint64_t v77;
  unint64_t v78;
  unint64_t v79;
  unint64_t v80;
  unint64_t v81;
  unint64_t v82;
  unint64_t v83;
  unint64_t v84;
  unint64_t v85;
  unint64_t v86;
  unint64_t v87;

  if (num < 0)
    bn_mul_words_cold_1();
  if (!num)
    return 0;
  if (num < 4)
  {
    v4 = 0;
    do
    {
LABEL_9:
      v72 = *ap++;
      v73 = v72 * (unint64_t)w;
      v74 = HIDWORD(v72) * (unint64_t)w;
      v75 = HIDWORD(v74) + HIDWORD(v72) * (unint64_t)HIDWORD(w);
      v76 = v73 | (v74 << 32);
      v77 = v73 & (v74 << 32);
      v78 = (v74 << 32) + v72 * (unint64_t)w;
      v79 = v76 & ~v78 | v77;
      v80 = v72 * (unint64_t)HIDWORD(w);
      v81 = v78 | (v80 << 32);
      v82 = v78 & (v80 << 32);
      v83 = v78 + (v80 << 32);
      v84 = v75 + HIDWORD(v80) + (v79 >> 63) + ((v81 & ~v83 | v82) >> 63);
      v85 = v83 | v4;
      v86 = v83 & v4;
      v87 = v83 + v4;
      v4 = v84 + ((v85 & ~v87 | v86) >> 63);
      *rp++ = v87;
      --num;
    }
    while (num);
    return v4;
  }
  v4 = 0;
  do
  {
    v5 = HIDWORD(*ap);
    v6 = *ap * (unint64_t)w;
    v7 = v5 * (unint64_t)w;
    v8 = HIDWORD(v7) + v5 * (unint64_t)HIDWORD(w);
    v9 = v6 | (v7 << 32);
    v10 = v6 & (v7 << 32);
    v11 = (v7 << 32) + *ap * (unint64_t)w;
    v12 = v9 & ~v11 | v10;
    v13 = *ap * (unint64_t)HIDWORD(w);
    v14 = v11 | (v13 << 32);
    v15 = v11 & (v13 << 32);
    v16 = v11 + (v13 << 32);
    v17 = v8 + HIDWORD(v13) + (v12 >> 63) + ((v14 & ~v16 | v15) >> 63);
    v18 = v16 | v4;
    v19 = v16 & v4;
    v20 = v16 + v4;
    v21 = v17 + ((v18 & ~v20 | v19) >> 63);
    *rp = v20;
    v22 = ap[1];
    v23 = v22 * (unint64_t)w;
    v24 = HIDWORD(v22) * (unint64_t)w;
    v25 = HIDWORD(v24) + HIDWORD(v22) * (unint64_t)HIDWORD(w);
    v26 = v23 | (v24 << 32);
    v27 = v23 & (v24 << 32);
    v28 = (v24 << 32) + v22 * (unint64_t)w;
    v29 = v26 & ~v28 | v27;
    v30 = v22 * (unint64_t)HIDWORD(w);
    v31 = v28 | (v30 << 32);
    v32 = v28 & (v30 << 32);
    v33 = v28 + (v30 << 32);
    v34 = v25 + HIDWORD(v30) + (v29 >> 63) + ((v31 & ~v33 | v32) >> 63);
    v35 = v21 | v33;
    v36 = v21 & v33;
    v37 = v21 + v33;
    v38 = v34 + ((v35 & ~v37 | v36) >> 63);
    rp[1] = v37;
    v39 = ap[2];
    v40 = v39 * (unint64_t)w;
    v41 = HIDWORD(v39) * (unint64_t)w;
    v42 = HIDWORD(v41) + HIDWORD(v39) * (unint64_t)HIDWORD(w);
    v43 = v40 | (v41 << 32);
    v44 = v40 & (v41 << 32);
    v45 = (v41 << 32) + v39 * (unint64_t)w;
    v46 = v43 & ~v45 | v44;
    v47 = v39 * (unint64_t)HIDWORD(w);
    v48 = v45 | (v47 << 32);
    v49 = v45 & (v47 << 32);
    v50 = v45 + (v47 << 32);
    v51 = v42 + HIDWORD(v47) + (v46 >> 63) + ((v48 & ~v50 | v49) >> 63);
    v52 = v38 | v50;
    v53 = v38 & v50;
    v54 = v38 + v50;
    v55 = v51 + ((v52 & ~v54 | v53) >> 63);
    rp[2] = v54;
    v56 = ap[3];
    v57 = v56 * (unint64_t)w;
    v58 = HIDWORD(v56) * (unint64_t)w;
    v59 = HIDWORD(v58) + HIDWORD(v56) * (unint64_t)HIDWORD(w);
    v60 = v57 | (v58 << 32);
    v61 = v57 & (v58 << 32);
    v62 = (v58 << 32) + v56 * (unint64_t)w;
    v63 = v60 & ~v62 | v61;
    v64 = v56 * (unint64_t)HIDWORD(w);
    v65 = v62 | (v64 << 32);
    v66 = v62 & (v64 << 32);
    v67 = v62 + (v64 << 32);
    v68 = v59 + HIDWORD(v64) + (v63 >> 63) + ((v65 & ~v67 | v66) >> 63);
    v69 = v55 | v67;
    v70 = v55 & v67;
    v71 = v55 + v67;
    v4 = v68 + ((v69 & ~v71 | v70) >> 63);
    rp[3] = v71;
    ap += 4;
    rp += 4;
    num -= 4;
  }
  while (num >= 4);
  if (num)
    goto LABEL_9;
  return v4;
}

unint64_t bn_mul_add_words(unint64_t *rp, const unint64_t *ap, int num, unint64_t w)
{
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t v20;
  unint64_t v21;
  unint64_t v22;
  unint64_t v23;
  unint64_t v24;
  unint64_t v25;
  unint64_t v26;
  unint64_t v27;
  unint64_t v28;
  unint64_t v29;
  unint64_t v30;
  unint64_t v31;
  unint64_t v32;
  unint64_t v33;
  unint64_t v34;
  unint64_t v35;
  unint64_t v36;
  unint64_t v37;
  unint64_t v38;
  unint64_t v39;
  unint64_t v40;
  unint64_t v41;
  unint64_t v42;
  unint64_t v43;
  unint64_t v44;
  unint64_t v45;
  unint64_t v46;
  unint64_t v47;
  unint64_t v48;
  unint64_t v49;
  unint64_t v50;
  unint64_t v51;
  unint64_t v52;
  unint64_t v53;
  unint64_t v54;
  unint64_t v55;
  unint64_t v56;
  unint64_t v57;
  unint64_t v58;
  unint64_t v59;
  unint64_t v60;
  unint64_t v61;
  unint64_t v62;
  unint64_t v63;
  unint64_t v64;
  unint64_t v65;
  unint64_t v66;
  unint64_t v67;
  unint64_t v68;
  unint64_t v69;
  unint64_t v70;
  unint64_t v71;
  unint64_t v72;
  unint64_t v73;
  unint64_t v74;
  unint64_t v75;
  unint64_t v76;
  unint64_t v77;
  unint64_t v78;
  unint64_t v79;
  unint64_t v80;
  unint64_t v81;
  unint64_t v82;
  unint64_t v83;
  unint64_t v84;
  unint64_t v85;
  unint64_t v86;
  unint64_t v87;
  unint64_t v88;
  uint64_t v89;
  unint64_t v90;
  unint64_t v91;
  unint64_t v92;
  unint64_t v93;
  unint64_t v94;
  unint64_t v95;
  unint64_t v96;
  unint64_t v97;
  unint64_t v98;
  unint64_t v99;
  unint64_t v100;
  unint64_t v101;
  unint64_t v102;
  unint64_t v103;
  unint64_t v104;
  unint64_t v105;

  if (num < 0)
    bn_mul_add_words_cold_1();
  if (!num)
    return 0;
  if (num < 4)
  {
    v4 = 0;
    do
    {
LABEL_9:
      v89 = *ap++;
      v90 = v89 * (unint64_t)w;
      v91 = HIDWORD(v89) * (unint64_t)w;
      v92 = HIDWORD(v91) + HIDWORD(v89) * (unint64_t)HIDWORD(w);
      v93 = v90 | (v91 << 32);
      v94 = v90 & (v91 << 32);
      v95 = (v91 << 32) + v89 * (unint64_t)w;
      v96 = v93 & ~v95 | v94;
      v97 = v89 * (unint64_t)HIDWORD(w);
      v98 = v95 | (v97 << 32);
      v99 = v95 & (v97 << 32);
      v100 = v95 + (v97 << 32);
      v101 = v100 + *rp;
      v102 = v92
           + HIDWORD(v97)
           + (v96 >> 63)
           + ((v98 & ~v100 | v99) >> 63)
           + (((v100 | *rp) & ~v101 | v100 & *rp) >> 63);
      v103 = v101 | v4;
      v104 = v101 & v4;
      v105 = v101 + v4;
      v4 = v102 + ((v103 & ~v105 | v104) >> 63);
      *rp++ = v105;
      --num;
    }
    while (num);
    return v4;
  }
  v4 = 0;
  do
  {
    v5 = HIDWORD(*ap);
    v6 = *ap * (unint64_t)w;
    v7 = v5 * (unint64_t)w;
    v8 = HIDWORD(v7) + v5 * (unint64_t)HIDWORD(w);
    v9 = v6 | (v7 << 32);
    v10 = v6 & (v7 << 32);
    v11 = (v7 << 32) + *ap * (unint64_t)w;
    v12 = v9 & ~v11 | v10;
    v13 = *ap * (unint64_t)HIDWORD(w);
    v14 = v11 | (v13 << 32);
    v15 = v11 & (v13 << 32);
    v16 = v11 + (v13 << 32);
    v17 = v8 + HIDWORD(v13) + (v12 >> 63) + ((v14 & ~v16 | v15) >> 63);
    v18 = rp[1];
    v19 = v16 + *rp;
    v20 = v17 + (((v16 | *rp) & ~v19 | v16 & *rp) >> 63);
    v21 = v19 | v4;
    v22 = v19 & v4;
    v23 = v19 + v4;
    v24 = v20 + ((v21 & ~v23 | v22) >> 63);
    *rp = v23;
    v25 = ap[1];
    v26 = v25 * (unint64_t)w;
    v27 = HIDWORD(v25) * (unint64_t)w;
    v28 = HIDWORD(v27) + HIDWORD(v25) * (unint64_t)HIDWORD(w);
    v29 = v26 | (v27 << 32);
    v30 = v26 & (v27 << 32);
    v31 = (v27 << 32) + v25 * (unint64_t)w;
    v32 = v29 & ~v31 | v30;
    v33 = v25 * (unint64_t)HIDWORD(w);
    v34 = v31 | (v33 << 32);
    v35 = v31 & (v33 << 32);
    v36 = v31 + (v33 << 32);
    v37 = v28 + HIDWORD(v33) + (v32 >> 63) + ((v34 & ~v36 | v35) >> 63);
    v38 = v36 | v18;
    v39 = v36 & v18;
    v40 = v36 + v18;
    v41 = v37 + ((v38 & ~v40 | v39) >> 63);
    v42 = v24 | v40;
    v43 = v24 & v40;
    v44 = v24 + v40;
    v45 = v41 + ((v42 & ~v44 | v43) >> 63);
    rp[1] = v44;
    v46 = ap[2];
    v47 = v46 * (unint64_t)w;
    v48 = HIDWORD(v46) * (unint64_t)w;
    v49 = HIDWORD(v48) + HIDWORD(v46) * (unint64_t)HIDWORD(w);
    v50 = v47 | (v48 << 32);
    v51 = v47 & (v48 << 32);
    v52 = (v48 << 32) + v46 * (unint64_t)w;
    v53 = v50 & ~v52 | v51;
    v54 = v46 * (unint64_t)HIDWORD(w);
    v55 = v52 | (v54 << 32);
    v56 = v52 & (v54 << 32);
    v57 = v52 + (v54 << 32);
    v58 = v49 + HIDWORD(v54) + (v53 >> 63) + ((v55 & ~v57 | v56) >> 63);
    v59 = rp[2];
    v60 = rp[3];
    v61 = v57 | v59;
    v62 = v57 & v59;
    v63 = v57 + v59;
    v64 = v58 + ((v61 & ~v63 | v62) >> 63);
    v65 = v45 | v63;
    v66 = v45 & v63;
    v67 = v45 + v63;
    v68 = v64 + ((v65 & ~v67 | v66) >> 63);
    rp[2] = v67;
    v69 = ap[3];
    v70 = v69 * (unint64_t)w;
    v71 = HIDWORD(v69) * (unint64_t)w;
    v72 = HIDWORD(v71) + HIDWORD(v69) * (unint64_t)HIDWORD(w);
    v73 = v70 | (v71 << 32);
    v74 = v70 & (v71 << 32);
    v75 = (v71 << 32) + v69 * (unint64_t)w;
    v76 = v73 & ~v75 | v74;
    v77 = v69 * (unint64_t)HIDWORD(w);
    v78 = v75 | (v77 << 32);
    v79 = v75 & (v77 << 32);
    v80 = v75 + (v77 << 32);
    v81 = v72 + HIDWORD(v77) + (v76 >> 63) + ((v78 & ~v80 | v79) >> 63);
    v82 = v80 | v60;
    v83 = v80 & v60;
    v84 = v80 + v60;
    v85 = v81 + ((v82 & ~v84 | v83) >> 63);
    v86 = v68 | v84;
    v87 = v68 & v84;
    v88 = v68 + v84;
    v4 = v85 + ((v86 & ~v88 | v87) >> 63);
    rp[3] = v88;
    ap += 4;
    rp += 4;
    num -= 4;
  }
  while (num >= 4);
  if (num)
    goto LABEL_9;
  return v4;
}

unint64_t bn_mul_normal(unint64_t *rp, unint64_t *a2, int a3, unint64_t *a4, int a5)
{
  int v6;
  unint64_t *v7;
  int v8;
  const unint64_t *v9;
  unint64_t *v10;
  unint64_t result;
  uint64_t v12;
  unint64_t *v13;
  unint64_t *v14;
  unint64_t *v15;

  if (a3 < a5)
    v6 = a5;
  else
    v6 = a3;
  if (a3 < a5)
    v7 = a2;
  else
    v7 = a4;
  if (a3 < a5)
    v8 = a3;
  else
    v8 = a5;
  if (a3 < a5)
    v9 = a4;
  else
    v9 = a2;
  if (v8 <= 0)
    return bn_mul_words(rp, v9, v6, 0);
  v10 = &rp[v6];
  result = bn_mul_words(rp, v9, v6, *v7);
  *v10 = result;
  if (v8 != 1)
  {
    v12 = 0;
    v13 = v7 + 2;
    do
    {
      result = bn_mul_add_words(&rp[v12 + 1], v9, v6, v13[v12 - 1]);
      v10[v12 + 1] = result;
      if (v8 == 2)
        break;
      result = bn_mul_add_words(&rp[v12 + 2], v9, v6, v13[v12]);
      v10[v12 + 2] = result;
      if (v8 < 4)
        break;
      v14 = &v13[v12];
      result = bn_mul_add_words(&rp[v12 + 3], v9, v6, v13[v12 + 1]);
      v15 = &v10[v12];
      v10[v12 + 3] = result;
      v8 -= 4;
      if (!v8)
        break;
      v12 += 4;
      result = bn_mul_add_words(&rp[v12], v9, v6, v14[2]);
      v15[4] = result;
    }
    while (v8 > 1);
  }
  return result;
}

uint64_t bn_mul(unint64_t **a1, uint64_t a2, uint64_t a3)
{
  bn_mul_normal(*a1, *(unint64_t **)a2, *(_DWORD *)(a2 + 8), *(unint64_t **)a3, *(_DWORD *)(a3 + 8));
  return 1;
}

int BN_mul(BIGNUM *r, const BIGNUM *a, const BIGNUM *b, BN_CTX *ctx)
{
  int v8;
  BIGNUM *v10;
  int top;
  unsigned int v12;
  int v13;
  int v14;

  BN_CTX_start(ctx);
  if (!BN_is_zero((uint64_t)a) && !BN_is_zero((uint64_t)b))
  {
    if (r == a || (v10 = r, r == b))
      v10 = BN_CTX_get(ctx);
    if (!v10)
      goto LABEL_21;
    top = b->top;
    if (top < 0)
      goto LABEL_21;
    v12 = top + a->top;
    if (!bn_wexpand((uint64_t)v10, v12))
      goto LABEL_21;
    v13 = a->top;
    if (v13 == 4)
    {
      v14 = b->top;
      if (v14 == 4)
      {
        bn_mul_comba4(v10->d, a->d, b->d);
        goto LABEL_20;
      }
    }
    else if (v13 == 8)
    {
      v14 = b->top;
      if (v14 == 8)
      {
        bn_mul_comba8(v10->d, a->d, b->d);
        goto LABEL_20;
      }
    }
    else
    {
      v14 = b->top;
    }
    bn_mul_normal(v10->d, a->d, v13, b->d, v14);
LABEL_20:
    v10->top = v12;
    bn_correct_top((uint64_t *)v10);
    BN_set_negative(v10, b->neg ^ a->neg);
    if (bn_copy(r, v10))
      goto LABEL_4;
LABEL_21:
    v8 = 0;
    goto LABEL_5;
  }
  BN_zero((uint64_t)r);
LABEL_4:
  v8 = 1;
LABEL_5:
  BN_CTX_end(ctx);
  return v8;
}

void bn_mul_words_cold_1()
{
  __assert_rtn("bn_mul_words", "bn_mul.c", 209, "num >= 0");
}

void bn_mul_add_words_cold_1()
{
  __assert_rtn("bn_mul_add_words", "bn_mul.c", 246, "num >= 0");
}

X509_VERIFY_PARAM *X509_VERIFY_PARAM_new(void)
{
  X509_VERIFY_PARAM *v0;
  char *v1;

  v0 = (X509_VERIFY_PARAM *)malloc_type_calloc(1uLL, 0x40uLL, 0x103004012F0C6E0uLL);
  if (v0)
  {
    v1 = (char *)malloc_type_calloc(1uLL, 0x40uLL, 0x10300402D538A19uLL);
    if (v1)
    {
      v0[1].name = v1;
      x509_verify_param_zero((uint64_t)v0);
    }
    else
    {
      free(v0);
      return 0;
    }
  }
  return v0;
}

void x509_verify_param_zero(uint64_t a1)
{
  STACK *v2;
  uint64_t v3;

  free(*(void **)a1);
  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 24) = 0;
  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 40) = -1;
  v2 = *(STACK **)(a1 + 48);
  if (v2)
  {
    sk_pop_free(v2, (void (__cdecl *)(void *))ASN1_OBJECT_free);
    *(_QWORD *)(a1 + 48) = 0;
  }
  v3 = *(_QWORD *)(a1 + 56);
  if (*(_QWORD *)v3)
  {
    sk_pop_free(*(STACK **)v3, str_free);
    *(_QWORD *)v3 = 0;
  }
  free(*(void **)(v3 + 16));
  *(_QWORD *)(v3 + 16) = 0;
  free(*(void **)(v3 + 24));
  *(_QWORD *)(v3 + 24) = 0;
  *(_QWORD *)(v3 + 32) = 0;
  free(*(void **)(v3 + 40));
  *(_QWORD *)(v3 + 40) = 0;
  *(_QWORD *)(v3 + 48) = 0;
  *(_DWORD *)(v3 + 56) = 0;
}

void X509_VERIFY_PARAM_free(X509_VERIFY_PARAM *param)
{
  if (param)
  {
    x509_verify_param_zero((uint64_t)param);
    free(param[1].name);
    free(param);
  }
}

int X509_VERIFY_PARAM_inherit(X509_VERIFY_PARAM *to, const X509_VERIFY_PARAM *from)
{
  char *name;
  unint64_t inh_flags;
  unint64_t v6;
  char v7;
  int purpose;
  int trust;
  int result;
  unint64_t flags;
  int depth;
  STACK *policies;
  char *v14;
  char *v15;
  char *v16;
  X509_VERIFY_PARAM *v17;
  STACK *v18;
  STACK *v19;
  uint64_t num;
  uint64_t v21;
  char **data;
  const char *v23;
  uint64_t i;
  char *v25;

  if (!from)
    return 1;
  name = from[1].name;
  inh_flags = to->inh_flags;
  v6 = from->inh_flags;
  v7 = v6 | inh_flags;
  if (((v6 | inh_flags) & 0x10) != 0)
    to->inh_flags = 0;
  if (((v6 | inh_flags) & 8) != 0)
    return 1;
  purpose = from->purpose;
  if ((v7 & 2) != 0)
  {
    to->purpose = purpose;
    *(_QWORD *)&to->trust = *(_QWORD *)&from->trust;
    flags = to->flags;
LABEL_23:
    to->check_time = from->check_time;
    flags &= ~2uLL;
    to->flags = flags;
    goto LABEL_24;
  }
  if (purpose)
  {
    if ((v7 & 1) == 0 && to->purpose)
    {
      trust = from->trust;
      if (!trust)
        goto LABEL_18;
      goto LABEL_16;
    }
    to->purpose = purpose;
  }
  trust = from->trust;
  if (!trust)
    goto LABEL_18;
  if ((v7 & 1) != 0)
  {
LABEL_17:
    to->trust = trust;
    goto LABEL_18;
  }
LABEL_16:
  if (!to->trust)
    goto LABEL_17;
LABEL_18:
  depth = from->depth;
  if (depth != -1 && ((v7 & 1) != 0 || to->depth == -1))
    to->depth = depth;
  flags = to->flags;
  if ((flags & 2) == 0)
    goto LABEL_23;
LABEL_24:
  if ((v7 & 4) != 0)
  {
    flags = 0;
    to->flags = 0;
  }
  to->flags = flags | from->flags;
  policies = from->policies;
  if ((v7 & 2) != 0)
  {
    result = X509_VERIFY_PARAM_set1_policies(to, policies);
    if (!result)
      return result;
    v15 = to[1].name;
    *((_DWORD *)v15 + 2) = *((_DWORD *)name + 2);
    goto LABEL_47;
  }
  v14 = name;
  if (!policies)
  {
LABEL_36:
    if (!*((_DWORD *)v14 + 2))
      goto LABEL_42;
    if ((v7 & 1) != 0)
    {
      v16 = to[1].name;
LABEL_41:
      *((_DWORD *)v16 + 2) = *((_DWORD *)name + 2);
      goto LABEL_42;
    }
LABEL_38:
    v16 = to[1].name;
    if (*((_DWORD *)v16 + 2))
      goto LABEL_42;
    goto LABEL_41;
  }
  if ((v7 & 1) != 0 || !to->policies)
  {
    result = X509_VERIFY_PARAM_set1_policies(to, policies);
    if (!result)
      return result;
    v14 = from[1].name;
    goto LABEL_36;
  }
  v14 = name;
  if (*((_DWORD *)name + 2))
    goto LABEL_38;
LABEL_42:
  if (!*(_QWORD *)v14)
    goto LABEL_59;
  v17 = to + 1;
  v15 = to[1].name;
  if ((v7 & 1) == 0)
  {
    if (*(_QWORD *)v15)
    {
      if (!*((_QWORD *)v14 + 3))
        goto LABEL_65;
      goto LABEL_61;
    }
    goto LABEL_49;
  }
LABEL_47:
  v17 = to + 1;
  if (*(_QWORD *)v15)
  {
    sk_pop_free(*(STACK **)v15, str_free);
    v15 = v17->name;
    *(_QWORD *)v17->name = 0;
  }
LABEL_49:
  if (*(_QWORD *)name)
  {
    v18 = sk_dup(*(STACK **)name);
    if (!v18)
    {
LABEL_78:
      result = 0;
      *(_QWORD *)v17->name = 0;
      return result;
    }
    v19 = v18;
    num = v18->num;
    if ((_DWORD)num)
    {
      v21 = 0;
      data = v18->data;
      while (1)
      {
        v23 = data[v21];
        if (v23)
        {
          data[v21] = strdup(v23);
          data = v19->data;
          if (!data[v21])
            break;
        }
        if (num == ++v21)
          goto LABEL_56;
      }
      if (v21)
      {
        for (i = 0; i != v21; ++i)
        {
          v25 = v19->data[i];
          if (v25)
            free(v25);
        }
      }
      sk_free(v19);
      goto LABEL_78;
    }
LABEL_56:
    v15 = v17->name;
    *(_QWORD *)v17->name = v19;
  }
  if ((v7 & 2) != 0)
  {
LABEL_62:
    result = x509_param_set1_internal((void **)v15 + 3, (size_t *)v15 + 4, *((char **)name + 3), *((_QWORD *)name + 4), 1);
    if (!result)
    {
      *((_DWORD *)to[1].name + 14) = 1;
      return result;
    }
    if ((v7 & 2) != 0)
    {
LABEL_68:
      result = X509_VERIFY_PARAM_set1_ip((uint64_t)to, *((char **)name + 5), *((_QWORD *)name + 6));
      if (!result)
        return result;
      return 1;
    }
    v14 = from[1].name;
    goto LABEL_65;
  }
  v14 = from[1].name;
LABEL_59:
  if (!*((_QWORD *)v14 + 3))
    goto LABEL_65;
  v15 = to[1].name;
  if ((v7 & 1) != 0)
    goto LABEL_62;
LABEL_61:
  if (!*((_QWORD *)v15 + 3))
    goto LABEL_62;
LABEL_65:
  if (*((_QWORD *)v14 + 5) && ((v7 & 1) != 0 || !*((_QWORD *)to[1].name + 5)))
    goto LABEL_68;
  return 1;
}

int X509_VERIFY_PARAM_set1_policies(X509_VERIFY_PARAM *param, STACK *policies)
{
  X509_VERIFY_PARAM *v3;
  STACK *v4;
  int v5;
  char *v6;
  ASN1_OBJECT *v7;

  if (!param)
    return (int)param;
  v3 = param;
  v4 = param->policies;
  if (v4)
    sk_pop_free(v4, (void (__cdecl *)(void *))ASN1_OBJECT_free);
  if (!policies)
  {
    v3->policies = 0;
    goto LABEL_13;
  }
  param = (X509_VERIFY_PARAM *)sk_new_null();
  v3->policies = (STACK *)param;
  if (!param)
    return (int)param;
  if (sk_num(policies) < 1)
  {
LABEL_13:
    LODWORD(param) = 1;
    return (int)param;
  }
  v5 = 0;
  while (1)
  {
    v6 = sk_value(policies, v5);
    param = (X509_VERIFY_PARAM *)OBJ_dup((const ASN1_OBJECT *)v6);
    if (!param)
      return (int)param;
    v7 = (ASN1_OBJECT *)param;
    if (!sk_push(v3->policies, (char *)param))
    {
      ASN1_OBJECT_free(v7);
      LODWORD(param) = 0;
      return (int)param;
    }
    if (++v5 >= sk_num(policies))
      goto LABEL_13;
  }
}

uint64_t X509_VERIFY_PARAM_set1_email(uint64_t a1, char *__s, size_t __n)
{
  uint64_t v4;

  v4 = 1;
  if (!x509_param_set1_internal((void **)(*(_QWORD *)(a1 + 56) + 24), (size_t *)(*(_QWORD *)(a1 + 56) + 32), __s, __n, 1))
  {
    *(_DWORD *)(*(_QWORD *)(a1 + 56) + 56) = 1;
    return 0;
  }
  return v4;
}

uint64_t X509_VERIFY_PARAM_set1_ip(uint64_t a1, char *__s, size_t __n)
{
  uint64_t result;

  if ((__n == 16 || __n == 4)
    && x509_param_set1_internal((void **)(*(_QWORD *)(a1 + 56) + 40), (size_t *)(*(_QWORD *)(a1 + 56) + 48), __s, __n, 0))
  {
    return 1;
  }
  result = 0;
  *(_DWORD *)(*(_QWORD *)(a1 + 56) + 56) = 1;
  return result;
}

int X509_VERIFY_PARAM_set1(X509_VERIFY_PARAM *to, const X509_VERIFY_PARAM *from)
{
  unint64_t inh_flags;
  int result;

  inh_flags = to->inh_flags;
  to->inh_flags = inh_flags | 1;
  result = X509_VERIFY_PARAM_inherit(to, from);
  to->inh_flags = inh_flags;
  return result;
}

int X509_VERIFY_PARAM_set1_name(X509_VERIFY_PARAM *param, const char *name)
{
  char *v4;

  free(param->name);
  param->name = 0;
  if (!name)
    return 1;
  v4 = strdup(name);
  param->name = v4;
  return v4 != 0;
}

int X509_VERIFY_PARAM_set_flags(X509_VERIFY_PARAM *param, unint64_t flags)
{
  param->flags |= flags;
  return 1;
}

int X509_VERIFY_PARAM_clear_flags(X509_VERIFY_PARAM *param, unint64_t flags)
{
  param->flags &= ~flags;
  return 1;
}

unint64_t X509_VERIFY_PARAM_get_flags(X509_VERIFY_PARAM *param)
{
  return param->flags;
}

int X509_VERIFY_PARAM_set_purpose(X509_VERIFY_PARAM *param, int purpose)
{
  return X509_PURPOSE_set(&param->purpose, purpose);
}

int X509_VERIFY_PARAM_set_trust(X509_VERIFY_PARAM *param, int trust)
{
  return X509_TRUST_set(&param->trust, trust);
}

void X509_VERIFY_PARAM_set_depth(X509_VERIFY_PARAM *param, int depth)
{
  param->depth = depth;
}

uint64_t X509_VERIFY_PARAM_set_auth_level(uint64_t result, int a2)
{
  *(_DWORD *)(result + 44) = a2;
  return result;
}

uint64_t X509_VERIFY_PARAM_get_time(uint64_t a1)
{
  return *(_QWORD *)(a1 + 8);
}

void X509_VERIFY_PARAM_set_time(X509_VERIFY_PARAM *param, time_t t)
{
  param->check_time = t;
  param->flags |= 2uLL;
}

int X509_VERIFY_PARAM_add0_policy(X509_VERIFY_PARAM *param, ASN1_OBJECT *policy)
{
  STACK *policies;

  policies = param->policies;
  if (policies || (policies = sk_new_null(), (param->policies = policies) != 0))
    LODWORD(policies) = sk_push(policies, (char *)policy) != 0;
  return (int)policies;
}

uint64_t X509_VERIFY_PARAM_set1_host(uint64_t a1, char *__s1, size_t __n)
{
  int v4;
  uint64_t result;

  v4 = x509_param_set_hosts_internal(*(STACK ***)(a1 + 56), 0, __s1, __n);
  result = 1;
  if (!v4)
  {
    *(_DWORD *)(*(_QWORD *)(a1 + 56) + 56) = 1;
    return 0;
  }
  return result;
}

uint64_t x509_param_set_hosts_internal(STACK **a1, int a2, char *__s1, size_t __n)
{
  size_t v4;
  void *v8;
  uint64_t result;
  char *v10;
  STACK *v11;

  v4 = __n;
  if (__s1 && !__n)
  {
    v4 = strlen(__s1);
    goto LABEL_5;
  }
  if (__s1)
  {
LABEL_5:
    v8 = memchr(__s1, 0, v4);
    result = 0;
    if (v8)
      return result;
  }
  if (!a2 && *a1)
  {
    sk_pop_free(*a1, str_free);
    *a1 = 0;
  }
  result = 1;
  if (__s1)
  {
    if (v4)
    {
      result = (uint64_t)strndup(__s1, v4);
      if (result)
      {
        v10 = (char *)result;
        v11 = *a1;
        if (*a1 || (v11 = sk_new_null(), (*a1 = v11) != 0))
        {
          if (sk_push(v11, v10))
            return 1;
          free(v10);
          if (!sk_num(*a1))
          {
            sk_free(*a1);
            result = 0;
            *a1 = 0;
            return result;
          }
        }
        else
        {
          free(v10);
        }
        return 0;
      }
    }
  }
  return result;
}

uint64_t X509_VERIFY_PARAM_add1_host(uint64_t a1, char *__s1, size_t __n)
{
  uint64_t v4;

  v4 = 1;
  if (!x509_param_set_hosts_internal(*(STACK ***)(a1 + 56), 1, __s1, __n))
  {
    *(_DWORD *)(*(_QWORD *)(a1 + 56) + 56) = 1;
    return 0;
  }
  return v4;
}

uint64_t X509_VERIFY_PARAM_get_hostflags(uint64_t a1)
{
  return *(unsigned int *)(*(_QWORD *)(a1 + 56) + 8);
}

uint64_t X509_VERIFY_PARAM_set_hostflags(uint64_t result, int a2)
{
  *(_DWORD *)(*(_QWORD *)(result + 56) + 8) = a2;
  return result;
}

uint64_t X509_VERIFY_PARAM_get0_peername(uint64_t a1)
{
  return *(_QWORD *)(*(_QWORD *)(a1 + 56) + 16);
}

uint64_t x509_param_set1_internal(void **a1, size_t *a2, char *__s, size_t __n, int a5)
{
  size_t v5;
  void *v9;
  uint64_t result;
  uint64_t v11;

  if (!__s)
    return 0;
  v5 = __n;
  if (__n)
  {
    if (a5)
    {
      v9 = memchr(__s, 0, __n);
      result = 0;
      if (v9)
        return result;
    }
    result = (uint64_t)malloc_type_malloc(v5, 0xA8D27C08uLL);
    if (!result)
      return result;
    v11 = result;
    memcpy((void *)result, __s, v5);
  }
  else
  {
    result = strlen(__s);
    if (!result)
      return result;
    v5 = result;
    result = (uint64_t)strdup(__s);
    if (!result)
      return result;
    v11 = result;
  }
  if (*a1)
    free(*a1);
  *a1 = (void *)v11;
  if (a2)
    *a2 = v5;
  return 1;
}

uint64_t X509_VERIFY_PARAM_set1_ip_asc(uint64_t a1, const char *a2)
{
  int v3;
  unsigned __int8 ipout[16];
  uint64_t v6;

  v6 = *MEMORY[0x24BDAC8D0];
  v3 = a2i_ipadd(ipout, a2);
  return X509_VERIFY_PARAM_set1_ip(a1, (char *)ipout, v3);
}

int X509_VERIFY_PARAM_get_depth(const X509_VERIFY_PARAM *param)
{
  return param->depth;
}

uint64_t X509_VERIFY_PARAM_get0_name(uint64_t a1)
{
  return *(_QWORD *)a1;
}

int X509_VERIFY_PARAM_add0_table(X509_VERIFY_PARAM *param)
{
  int v2;
  STACK *v3;
  char *v4;

  if (param_table)
  {
    v2 = sk_find((STACK *)param_table, (char *)param);
    v3 = (STACK *)param_table;
    if (v2 != -1)
    {
      v4 = sk_value((const STACK *)param_table, v2);
      X509_VERIFY_PARAM_free((X509_VERIFY_PARAM *)v4);
      sk_delete((STACK *)param_table, v2);
      v3 = (STACK *)param_table;
    }
    goto LABEL_5;
  }
  v3 = sk_new((int (__cdecl *)(const char *const *, const char *const *))param_cmp);
  param_table = (uint64_t)v3;
  if (v3)
LABEL_5:
    LODWORD(v3) = sk_push(v3, (char *)param) != 0;
  return (int)v3;
}

uint64_t param_cmp(const char ***a1, const char ***a2)
{
  return strcmp(**a1, **a2);
}

uint64_t X509_VERIFY_PARAM_get_count()
{
  if (param_table)
    return (sk_num((const STACK *)param_table) + 5);
  else
    return 5;
}

char *X509_VERIFY_PARAM_get0(int a1)
{
  if (a1 > 4)
    return sk_value((const STACK *)param_table, a1 - 5);
  else
    return (char *)&(&default_table)[8 * (uint64_t)a1];
}

const X509_VERIFY_PARAM *__cdecl X509_VERIFY_PARAM_lookup(const char *name)
{
  int v2;
  uint64_t v4;
  const char *v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  uint64_t v9;

  v9 = 0;
  v8 = 0u;
  v7 = 0u;
  v6 = 0u;
  v5 = name;
  if (param_table)
  {
    v2 = sk_find((STACK *)param_table, (char *)&v5);
    if (v2 != -1)
      return (const X509_VERIFY_PARAM *)sk_value((const STACK *)param_table, v2);
  }
  v4 = 0;
  while (strcmp((&default_table)[v4], name))
  {
    v4 += 8;
    if (v4 == 40)
      return 0;
  }
  return (const X509_VERIFY_PARAM *)&(&default_table)[v4];
}

void X509_VERIFY_PARAM_table_cleanup(void)
{
  if (param_table)
    sk_pop_free((STACK *)param_table, (void (__cdecl *)(void *))X509_VERIFY_PARAM_free);
  param_table = 0;
}

int X509_CERT_AUX_print(BIO *bp, X509_CERT_AUX *x, int indent)
{
  int v6;
  char v7;
  char *v8;
  int v9;
  int v10;
  char v11;
  char *v12;
  int v13;
  ASN1_UTF8STRING *alias;
  ASN1_OCTET_STRING *keyid;
  uint64_t v16;
  const char *v17;
  char buf[80];
  uint64_t v20;

  v20 = *MEMORY[0x24BDAC8D0];
  if (x)
  {
    if (x->trust)
    {
      BIO_printf(bp, "%*sTrusted Uses:\n%*s", indent, "", indent + 2, "");
      if (sk_num(x->trust) >= 1)
      {
        v6 = 0;
        v7 = 0;
        do
        {
          if ((v7 & 1) != 0)
            BIO_puts(bp, ", ");
          v8 = sk_value(x->trust, v6);
          OBJ_obj2txt(buf, 80, (const ASN1_OBJECT *)v8, 0);
          BIO_puts(bp, buf);
          ++v6;
          v9 = sk_num(x->trust);
          v7 = 1;
        }
        while (v6 < v9);
      }
      BIO_puts(bp, "\n");
    }
    else
    {
      BIO_printf(bp, "%*sNo Trusted Uses.\n", indent, "");
    }
    if (x->reject)
    {
      BIO_printf(bp, "%*sRejected Uses:\n%*s", indent, "", indent + 2, "");
      if (sk_num(x->reject) >= 1)
      {
        v10 = 0;
        v11 = 0;
        do
        {
          if ((v11 & 1) != 0)
            BIO_puts(bp, ", ");
          v12 = sk_value(x->reject, v10);
          OBJ_obj2txt(buf, 80, (const ASN1_OBJECT *)v12, 0);
          BIO_puts(bp, buf);
          ++v10;
          v13 = sk_num(x->reject);
          v11 = 1;
        }
        while (v10 < v13);
      }
      BIO_puts(bp, "\n");
    }
    else
    {
      BIO_printf(bp, "%*sNo Rejected Uses.\n", indent, "");
    }
    alias = x->alias;
    if (alias)
      BIO_printf(bp, "%*sAlias: %.*s\n", indent, "", alias->length, (const char *)alias->data);
    if (x->keyid)
    {
      BIO_printf(bp, "%*sKey Id: ", indent, "");
      keyid = x->keyid;
      if (keyid->length >= 1)
      {
        v16 = 0;
        do
        {
          if (v16)
            v17 = ":";
          else
            v17 = "";
          BIO_printf(bp, "%s%02X", v17, keyid->data[v16++]);
          keyid = x->keyid;
        }
        while (v16 < keyid->length);
      }
      BIO_write(bp, "\n", 1);
    }
  }
  return 1;
}

int RSA_padding_add_PKCS1_type_1(unsigned __int8 *to, int tlen, const unsigned __int8 *f, int fl)
{
  unsigned __int8 *v7;
  int v8;
  unsigned __int8 *v9;

  if (tlen - 11 >= fl)
  {
    *(_WORD *)to = 256;
    v7 = to + 2;
    v8 = tlen - fl - 3;
    memset(to + 2, 255, v8);
    v9 = &v7[v8];
    *v9 = 0;
    memcpy(v9 + 1, f, fl);
    return 1;
  }
  else
  {
    ERR_put_error(4, 4095, 110, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/rsa/rsa_pk1.c", 75);
    return 0;
  }
}

int RSA_padding_check_PKCS1_type_1(unsigned __int8 *to, int tlen, const unsigned __int8 *f, int fl, int rsa_len)
{
  int v5;
  const unsigned __int8 *v6;
  int v7;
  int v8;
  int v9;

  if (fl + 1 != rsa_len || *f != 1)
  {
    v8 = 106;
    v9 = 103;
    goto LABEL_9;
  }
  v5 = fl - 2;
  if (fl < 2)
  {
    if (fl != 1)
    {
LABEL_12:
      v8 = 103;
      v9 = 129;
      goto LABEL_9;
    }
LABEL_18:
    v8 = 113;
    v9 = 124;
    goto LABEL_9;
  }
  v6 = f + 2;
  v7 = 1;
  while (*(v6 - 1) == 255)
  {
    ++v6;
    ++v7;
    if (--v5 == -1)
      goto LABEL_18;
  }
  if (*(v6 - 1))
  {
    v8 = 102;
    v9 = 116;
    goto LABEL_9;
  }
  if (v5 == -1)
    goto LABEL_18;
  if ((v7 - 1) <= 7)
    goto LABEL_12;
  if (v5 <= tlen)
  {
    memcpy(to, v6, v5);
    return v5;
  }
  v8 = 109;
  v9 = 135;
LABEL_9:
  ERR_put_error(4, 4095, v8, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/rsa/rsa_pk1.c", v9);
  return -1;
}

int RSA_padding_add_PKCS1_type_2(unsigned __int8 *to, int tlen, const unsigned __int8 *f, int fl)
{
  unsigned __int8 *v7;
  int v8;
  int i;

  if (tlen - 11 >= fl)
  {
    *(_WORD *)to = 512;
    v7 = to + 2;
    v8 = tlen - fl - 3;
    arc4random_buf(to + 2, v8);
    if (v8 >= 1)
    {
      for (i = 0; i != v8; ++i)
      {
        while (!*v7)
          arc4random_buf(v7, 1uLL);
        ++v7;
      }
    }
    *v7 = 0;
    memcpy(v7 + 1, f, fl);
    return 1;
  }
  else
  {
    ERR_put_error(4, 4095, 110, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/rsa/rsa_pk1.c", 151);
    return 0;
  }
}

int RSA_padding_check_PKCS1_type_2(unsigned __int8 *to, int tlen, const unsigned __int8 *f, int fl, int rsa_len)
{
  int v5;
  const unsigned __int8 *v6;
  int v7;
  int v8;
  int v9;

  if (fl + 1 != rsa_len || *f != 2)
  {
    v8 = 107;
    v9 = 185;
    goto LABEL_9;
  }
  v5 = fl - 2;
  if (fl < 2)
  {
    if (fl != 1)
    {
LABEL_12:
      v8 = 103;
      v9 = 201;
      goto LABEL_9;
    }
LABEL_17:
    v8 = 113;
    v9 = 196;
    goto LABEL_9;
  }
  v6 = f + 2;
  v7 = 1;
  while (*(v6 - 1))
  {
    ++v6;
    ++v7;
    if (--v5 == -1)
      goto LABEL_17;
  }
  if (v5 == -1)
    goto LABEL_17;
  if ((v7 - 1) <= 7)
    goto LABEL_12;
  if (v5 <= tlen)
  {
    memcpy(to, v6, v5);
    return v5;
  }
  v8 = 109;
  v9 = 207;
LABEL_9:
  ERR_put_error(4, 4095, v8, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/rsa/rsa_pk1.c", v9);
  return -1;
}

void mackey_free_gost(uint64_t a1)
{
  free(*(void **)(a1 + 32));
}

uint64_t mac_ctrl_gost(uint64_t a1, int a2, uint64_t a3, _DWORD *a4)
{
  if (a2 != 3)
    return 4294967294;
  *a4 = 815;
  return 2;
}

uint64_t ASN1_bn_print(BIO *a1, const char *a2, const BIGNUM *a3, unsigned __int8 *a4, int a5)
{
  const char *v10;
  uint64_t result;
  int v12;
  const char *v13;
  int v14;
  unsigned int v15;
  int v16;
  unsigned int v17;
  unsigned __int8 *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  int v23;
  const char *v24;
  int v25;

  if (!a3)
    return 1;
  if (BN_is_negative((uint64_t)a3))
    v10 = "-";
  else
    v10 = "";
  result = BIO_indent(a1, a5, 128);
  if ((_DWORD)result)
  {
    if (BN_is_zero((uint64_t)a3))
      return BIO_printf(a1, "%s 0\n", a2) > 0;
    if (BN_num_bits(a3) > 64)
    {
      *a4 = 0;
      if (*v10 == 45)
        v13 = " (Negative)";
      else
        v13 = "";
      if (BIO_printf(a1, "%s%s", a2, v13) < 1)
        return 0;
      v14 = BN_bn2bin(a3, a4 + 1);
      v15 = 0;
      v16 = 0;
      v17 = a4[1];
      if ((v17 & 0x80u) != 0)
        v18 = a4;
      else
        v18 = a4 + 1;
      v19 = v14 + (v17 >> 7);
      v20 = v19 & ~((int)v19 >> 31);
      v21 = v19 - 1;
      while (v20)
      {
        if (v16 - v15 / 0xF + 16 * (v15 / 0xF))
          goto LABEL_34;
        if (BIO_puts(a1, "\n") < 1)
          return 0;
        result = BIO_indent(a1, a5 + 4, 128);
        if ((_DWORD)result)
        {
LABEL_34:
          v23 = *v18++;
          v22 = v23;
          v24 = v21 ? ":" : "";
          v25 = BIO_printf(a1, "%02x%s", v22, v24);
          result = 0;
          --v20;
          --v16;
          ++v15;
          --v21;
          if (v25 >= 1)
            continue;
        }
        return result;
      }
      v12 = BIO_write(a1, "\n", 1);
    }
    else
    {
      v12 = BIO_printf(a1, "%s %s%lu (%s0x%lx)\n", a2, v10, *a3->d, v10, *a3->d);
    }
    return v12 >= 1;
  }
  return result;
}

uint64_t ASN1_buf_print(BIO *b, uint64_t a2, uint64_t a3, int indent)
{
  unint64_t v8;
  uint64_t v9;
  uint64_t result;
  const char *v11;

  if (!a3)
    return BIO_write(b, "\n", 1) > 0;
  v8 = 0;
  v9 = a3 - 1;
  while (1)
  {
    if (15 * (v8 / 0xF) == v8)
    {
      if (v8 && BIO_puts(b, "\n") < 1)
        return 0;
      result = BIO_indent(b, indent, 64);
      if (!(_DWORD)result)
        return result;
    }
    v11 = v9 == v8 ? "" : ":";
    if (BIO_printf(b, "%02x%s", *(unsigned __int8 *)(a2 + v8), v11) < 1)
      break;
    if (a3 == ++v8)
      return BIO_write(b, "\n", 1) > 0;
  }
  return 0;
}

BOOL bn_new(BIGNUM **a1)
{
  BIGNUM *v2;

  v2 = BN_new();
  *a1 = v2;
  return v2 != 0;
}

void bn_free(BIGNUM **a1)
{
  BIGNUM *v2;

  v2 = *a1;
  if (v2)
  {
    BN_free(v2);
    *a1 = 0;
  }
}

void bn_clear(BIGNUM **a1)
{
  BN_free(*a1);
  *a1 = 0;
}

uint64_t bn_c2i(BIGNUM **a1, uint64_t a2, unsigned int a3)
{
  BIGNUM *v6;
  uint64_t v7;
  ASN1_INTEGER *v9[3];
  ASN1_INTEGER *ai;

  ai = 0;
  memset(v9, 0, sizeof(v9));
  BN_free(*a1);
  *a1 = 0;
  if ((a3 & 0x80000000) == 0
    && (CBS_init(v9, a2, a3), c2i_ASN1_INTEGER_cbs((ASN1_VALUE **)&ai, v9))
    && (v6 = ASN1_INTEGER_to_BN(ai, 0)) != 0)
  {
    *a1 = v6;
    v7 = 1;
  }
  else
  {
    v7 = 0;
  }
  ASN1_INTEGER_free(ai);
  return v7;
}

uint64_t bn_i2c(BIGNUM **a1, uint64_t a2)
{
  BIGNUM *v2;
  ASN1_INTEGER *v4;
  ASN1_INTEGER *v5;
  unsigned __int8 **v6;
  uint64_t v7;
  uint64_t v9;

  v9 = a2;
  v2 = *a1;
  if (!v2)
    return 0xFFFFFFFFLL;
  v4 = BN_to_ASN1_INTEGER(v2, 0);
  if (!v4)
    return 0xFFFFFFFFLL;
  v5 = v4;
  if (a2)
    v6 = (unsigned __int8 **)&v9;
  else
    v6 = 0;
  v7 = i2c_ASN1_INTEGER(v4, v6);
  ASN1_INTEGER_free(v5);
  return v7;
}

uint64_t bn_print(BIO *a1, const BIGNUM **a2)
{
  uint64_t result;

  result = BN_print(a1, *a2);
  if ((_DWORD)result)
    return BIO_printf(a1, "\n") > 0;
  return result;
}

const EVP_MD *EVP_md_null(void)
{
  return (const EVP_MD *)&null_md;
}

uint64_t init_1()
{
  return 1;
}

uint64_t update_1()
{
  return 1;
}

uint64_t final_1()
{
  return 1;
}

ASN1_VALUE *d2i_IPAddressRange(ASN1_VALUE **a1, const unsigned __int8 **a2, uint64_t a3)
{
  return ASN1_item_d2i(a1, a2, a3, &IPAddressRange_it);
}

uint64_t i2d_IPAddressRange(ASN1_VALUE *a1, unsigned __int8 **a2)
{
  return ASN1_item_i2d(a1, a2, &IPAddressRange_it);
}

ASN1_VALUE *IPAddressRange_new()
{
  return ASN1_item_new(&IPAddressRange_it);
}

void IPAddressRange_free(ASN1_VALUE *a1)
{
  ASN1_item_free(a1, &IPAddressRange_it);
}

ASN1_VALUE *d2i_IPAddressOrRange(ASN1_VALUE **a1, const unsigned __int8 **a2, uint64_t a3)
{
  return ASN1_item_d2i(a1, a2, a3, &IPAddressOrRange_it);
}

uint64_t i2d_IPAddressOrRange(ASN1_VALUE *a1, unsigned __int8 **a2)
{
  return ASN1_item_i2d(a1, a2, &IPAddressOrRange_it);
}

ASN1_VALUE *IPAddressOrRange_new()
{
  return ASN1_item_new(&IPAddressOrRange_it);
}

void IPAddressOrRange_free(ASN1_VALUE *a1)
{
  ASN1_item_free(a1, &IPAddressOrRange_it);
}

ASN1_VALUE *d2i_IPAddressChoice(ASN1_VALUE **a1, const unsigned __int8 **a2, uint64_t a3)
{
  return ASN1_item_d2i(a1, a2, a3, &IPAddressChoice_it);
}

uint64_t i2d_IPAddressChoice(ASN1_VALUE *a1, unsigned __int8 **a2)
{
  return ASN1_item_i2d(a1, a2, &IPAddressChoice_it);
}

ASN1_VALUE *IPAddressChoice_new()
{
  return ASN1_item_new(&IPAddressChoice_it);
}

void IPAddressChoice_free(ASN1_VALUE *a1)
{
  ASN1_item_free(a1, &IPAddressChoice_it);
}

ASN1_VALUE *d2i_IPAddressFamily(ASN1_VALUE **a1, const unsigned __int8 **a2, uint64_t a3)
{
  return ASN1_item_d2i(a1, a2, a3, &IPAddressFamily_it);
}

uint64_t i2d_IPAddressFamily(ASN1_VALUE *a1, unsigned __int8 **a2)
{
  return ASN1_item_i2d(a1, a2, &IPAddressFamily_it);
}

ASN1_VALUE *IPAddressFamily_new()
{
  return ASN1_item_new(&IPAddressFamily_it);
}

void IPAddressFamily_free(ASN1_VALUE *a1)
{
  ASN1_item_free(a1, &IPAddressFamily_it);
}

int **X509v3_addr_get_afi(int **result)
{
  unsigned __int16 v1;

  if (result)
  {
    if (*result && *((_QWORD *)*result + 1))
    {
      v1 = 0;
      result = (int **)IPAddressFamily_afi_safi(result, &v1, 0, 0);
      if ((_DWORD)result)
        return (int **)v1;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t X509v3_addr_add_inherit(STACK *a1, unsigned int a2, unsigned int *a3)
{
  uint64_t result;
  uint64_t v4;
  uint64_t v5;

  result = (uint64_t)make_IPAddressFamily(a1, a2, a3);
  if (result)
  {
    v4 = result;
    v5 = *(_QWORD *)(result + 8);
    if (v5)
    {
      if (*(_DWORD *)v5)
      {
        if (*(_DWORD *)v5 == 1 && *(_QWORD *)(v5 + 8))
          return 0;
      }
      else if (*(_QWORD *)(v5 + 8))
      {
        return 1;
      }
    }
    result = (uint64_t)ASN1_NULL_new();
    *(_QWORD *)(*(_QWORD *)(v4 + 8) + 8) = result;
    if (!result)
      return result;
    **(_DWORD **)(v4 + 8) = 0;
    return 1;
  }
  return result;
}

char *make_IPAddressFamily(STACK *a1, unsigned int a2, unsigned int *a3)
{
  int v6;
  char *v7;
  ASN1_OCTET_STRING **v8;
  int len[2];
  unsigned __int8 *data;
  _QWORD v12[3];
  _OWORD v13[2];

  memset(v13, 0, sizeof(v13));
  memset(v12, 0, sizeof(v12));
  *(_QWORD *)len = 0;
  data = 0;
  if (!CBB_init((uint64_t)v13, 0)
    || !CBB_add_u16((char **)v13, a2)
    || a3 && !CBB_add_u8((char **)v13, *a3)
    || !CBB_finish((uint64_t *)v13, &data, len))
  {
    v7 = 0;
    goto LABEL_15;
  }
  if (sk_num(a1) >= 1)
  {
    v6 = 0;
    do
    {
      v7 = sk_value(a1, v6);
      CBS_init(v12, *(_QWORD *)(*(_QWORD *)v7 + 8), **(int **)v7);
      if (CBS_mem_equal((uint64_t)v12, data, *(uint64_t *)len))
        goto LABEL_13;
    }
    while (++v6 < sk_num(a1));
  }
  v8 = (ASN1_OCTET_STRING **)ASN1_item_new(&IPAddressFamily_it);
  v7 = (char *)v8;
  if (!v8 || !ASN1_OCTET_STRING_set(*v8, data, len[0]) || !sk_push(a1, v7))
  {
LABEL_15:
    CBB_cleanup((uint64_t *)v13);
    free(data);
    ASN1_item_free((ASN1_VALUE *)v7, &IPAddressFamily_it);
    return 0;
  }
LABEL_13:
  free(data);
  return v7;
}

uint64_t X509v3_addr_add_prefix(STACK *a1, unsigned int a2, unsigned int *a3, unsigned __int8 *a4, unsigned int a5)
{
  uint64_t result;
  STACK *v9;
  char *v10;
  char *data;

  result = (uint64_t)make_prefix_or_range(a1, a2, a3);
  if (result)
  {
    v9 = (STACK *)result;
    data = 0;
    result = make_addressPrefix((ASN1_VALUE **)&data, a4, a2, a5);
    if ((_DWORD)result)
    {
      v10 = data;
      if (sk_push(v9, data) <= 0)
      {
        ASN1_item_free((ASN1_VALUE *)v10, &IPAddressOrRange_it);
        return 0;
      }
      else
      {
        return 1;
      }
    }
  }
  return result;
}

STACK *make_prefix_or_range(STACK *a1, unsigned int a2, unsigned int *a3)
{
  char *IPAddressFamily;
  char *v5;
  uint64_t v6;
  STACK *v7;
  STACK *v8;
  int (__cdecl *v9)(const char *const *, const char *const *);
  uint64_t v10;

  IPAddressFamily = make_IPAddressFamily(a1, a2, a3);
  if (!IPAddressFamily)
    return 0;
  v5 = IPAddressFamily;
  v6 = *((_QWORD *)IPAddressFamily + 1);
  if (!v6)
  {
LABEL_9:
    v8 = sk_new_null();
    v7 = v8;
    if (!v8)
      return v7;
    if (a2 == 1)
    {
      v9 = (int (__cdecl *)(const char *const *, const char *const *))v4IPAddressOrRange_cmp;
    }
    else
    {
      if (a2 != 2)
      {
LABEL_15:
        v10 = *((_QWORD *)v5 + 1);
        *(_DWORD *)v10 = 1;
        *(_QWORD *)(v10 + 8) = v7;
        return v7;
      }
      v9 = (int (__cdecl *)(const char *const *, const char *const *))v6IPAddressOrRange_cmp;
    }
    sk_set_cmp_func(v8, v9);
    goto LABEL_15;
  }
  if (*(_DWORD *)v6 == 1)
  {
    v7 = *(STACK **)(v6 + 8);
    if (v7)
      return v7;
    goto LABEL_9;
  }
  if (*(_DWORD *)v6 || !*(_QWORD *)(v6 + 8))
    goto LABEL_9;
  return 0;
}

uint64_t make_addressPrefix(ASN1_VALUE **a1, unsigned __int8 *a2, int a3, unsigned int a4)
{
  int v5;
  unsigned int v6;
  ASN1_VALUE *v7;
  unsigned __int8 v11;
  ASN1_VALUE *v12;
  ASN1_BIT_STRING *v13;

  if ((a4 & 0x80000000) != 0)
    goto LABEL_8;
  v5 = 16 * (a3 == 2);
  if (a3 == 1)
    v5 = 4;
  v6 = v5 ? 8 * v5 : 128;
  if (v6 < a4)
  {
LABEL_8:
    v7 = 0;
LABEL_9:
    ASN1_item_free(v7, &IPAddressOrRange_it);
    return 0;
  }
  if ((a4 & 7) != 0)
    v11 = 8 - (a4 & 7);
  else
    v11 = 0;
  v12 = ASN1_item_new(&IPAddressOrRange_it);
  v7 = v12;
  if (!v12)
    goto LABEL_9;
  *(_DWORD *)v12 = 0;
  v13 = ASN1_BIT_STRING_new();
  *((_QWORD *)v7 + 1) = v13;
  if (!v13
    || !ASN1_BIT_STRING_set(v13, a2, (a4 + 7) >> 3)
    || !asn1_abs_set_unused_bits(*((_QWORD *)v7 + 1), v11))
  {
    goto LABEL_9;
  }
  *a1 = v7;
  return 1;
}

uint64_t X509v3_addr_add_range(STACK *a1, unsigned int a2, unsigned int *a3, void *a4, void *a5)
{
  uint64_t result;
  STACK *v9;
  size_t v10;
  char *v11;
  char *data;

  result = (uint64_t)make_prefix_or_range(a1, a2, a3);
  if (result)
  {
    v9 = (STACK *)result;
    data = 0;
    if (a2 == 1)
      v10 = 4;
    else
      v10 = 16 * (a2 == 2);
    result = make_addressRange((ASN1_VALUE **)&data, a4, a5, a2, v10);
    if ((_DWORD)result)
    {
      v11 = data;
      if (sk_push(v9, data) <= 0)
      {
        ASN1_item_free((ASN1_VALUE *)v11, &IPAddressOrRange_it);
        return 0;
      }
      else
      {
        return 1;
      }
    }
  }
  return result;
}

uint64_t make_addressRange(ASN1_VALUE **a1, void *__s1, void *__s2, int a4, size_t __n)
{
  int v5;
  uint64_t v10;
  ASN1_VALUE *v11;
  unsigned int should_be_prefix;
  uint64_t v14;
  int v15;
  int v16;
  unsigned __int8 v17;
  uint64_t v18;
  int v19;
  unsigned int v20;
  unsigned __int8 v21;
  int v22;
  ASN1_VALUE *v23;
  ASN1_BIT_STRING **v24;
  ASN1_BIT_STRING **v25;
  unsigned __int8 v26;
  _QWORD v27[3];

  v5 = __n;
  memset(v27, 0, sizeof(v27));
  v26 = 0;
  v10 = __n;
  v11 = 0;
  if (memcmp(__s1, __s2, __n) > 0)
    goto LABEL_19;
  should_be_prefix = range_should_be_prefix((uint64_t)__s1, (uint64_t)__s2, v5);
  if ((should_be_prefix & 0x80000000) == 0)
    return make_addressPrefix(a1, (unsigned __int8 *)__s1, a4, should_be_prefix);
  CBS_init(v27, (uint64_t)__s1, v10);
  if (!trim_end_u8(v27, 0))
    goto LABEL_18;
  v14 = CBS_len((uint64_t)v27);
  v15 = v14;
  if (v14)
  {
    if (!CBS_peek_last_u8(v27, &v26))
      goto LABEL_18;
    if (v26)
    {
      v16 = 0;
      do
        v17 = v16++;
      while (((v26 >> v17) & 1) == 0);
    }
    else
    {
      v17 = 8;
    }
  }
  else
  {
    v17 = 0;
  }
  CBS_init(v27, (uint64_t)__s2, v10);
  if (!trim_end_u8(v27, 255))
    goto LABEL_18;
  v18 = CBS_len((uint64_t)v27);
  v19 = v18;
  if (!v18)
  {
    v21 = 0;
    goto LABEL_24;
  }
  if (!CBS_peek_last_u8(v27, &v26))
  {
LABEL_18:
    v11 = 0;
    goto LABEL_19;
  }
  v20 = (v26 + 1);
  if (v20 == v26 + 1)
  {
    v22 = 0;
    do
      v21 = v22++;
    while (((v20 >> v21) & 1) == 0);
  }
  else
  {
    v21 = 8;
  }
LABEL_24:
  v23 = ASN1_item_new(&IPAddressOrRange_it);
  v11 = v23;
  if (v23)
  {
    *(_DWORD *)v23 = 1;
    v24 = (ASN1_BIT_STRING **)ASN1_item_new(&IPAddressRange_it);
    *((_QWORD *)v11 + 1) = v24;
    if (v24)
    {
      v25 = v24;
      if (ASN1_BIT_STRING_set(*v24, (unsigned __int8 *)__s1, v15))
      {
        if (asn1_abs_set_unused_bits((uint64_t)*v25, v17)
          && ASN1_BIT_STRING_set(v25[1], (unsigned __int8 *)__s2, v19)
          && asn1_abs_set_unused_bits((uint64_t)v25[1], v21))
        {
          *a1 = v11;
          return 1;
        }
      }
    }
  }
LABEL_19:
  ASN1_item_free(v11, &IPAddressOrRange_it);
  return 0;
}

uint64_t X509v3_addr_get_range(uint64_t a1, int a2, char *__dst, char *a4, int a5)
{
  int v5;
  BOOL v6;

  if (a2 == 1)
    v5 = 4;
  else
    v5 = 16 * (a2 == 2);
  if (v5)
    v6 = v5 <= a5;
  else
    v6 = 0;
  if (!v6)
    return 0;
  if (extract_min_max(a1, __dst, a4, v5))
    return v5;
  return 0;
}

uint64_t extract_min_max(uint64_t a1, char *__dst, char *a3, int a4)
{
  unsigned int *v6;
  unsigned int *v7;
  unsigned int **v8;

  if (!a1 || !__dst || !a3)
    return 0;
  if (*(_DWORD *)a1 == 1)
  {
    v8 = *(unsigned int ***)(a1 + 8);
    v6 = *v8;
    v7 = v8[1];
  }
  else
  {
    if (*(_DWORD *)a1)
      return 0;
    v6 = *(unsigned int **)(a1 + 8);
    v7 = v6;
  }
  if (addr_expand(__dst, v6, a4, 0))
    return addr_expand(a3, v7, a4, 1);
  return 0;
}

uint64_t X509v3_addr_is_canonical(STACK *a1)
{
  int i;
  char *v3;
  char *v4;
  uint64_t result;
  int *v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  char *v13;
  int v14;
  uint64_t v15;
  const STACK *v16;
  int v17;
  uint64_t v18;
  size_t v19;
  char *v20;
  char *v21;
  uint64_t v22;
  char *v23;
  int v24;
  char *v25;
  int v26;
  int v27;
  unsigned int v28;
  char v29[16];
  char __s2[16];
  char v31[16];
  char __s1[16];
  uint64_t v33;

  v33 = *MEMORY[0x24BDAC8D0];
  if (!a1)
    return 1;
  for (i = 0; i < sk_num(a1) - 1; ++i)
  {
    v3 = sk_value(a1, i);
    v4 = sk_value(a1, i + 1);
    result = IPAddressFamily_afi_safi((int **)v3, 0, 0, 0);
    if (!(_DWORD)result)
      return result;
    result = IPAddressFamily_afi_safi((int **)v4, 0, 0, 0);
    if (!(_DWORD)result)
      return result;
    v6 = *(int **)v3;
    v7 = **(_DWORD **)v3;
    v8 = **(_DWORD **)v4;
    v9 = v7 - v8;
    if (v7 >= v8)
      v7 = **(_DWORD **)v4;
    v10 = memcmp(*((const void **)v6 + 1), *(const void **)(*(_QWORD *)v4 + 8), v7);
    if (v10)
      v11 = v10;
    else
      v11 = v9;
    if ((v11 & 0x80000000) == 0)
      return 0;
  }
  if (sk_num(a1) < 1)
    return 1;
  v12 = 0;
  v28 = 0;
  do
  {
    v13 = sk_value(a1, v12);
    v14 = IPAddressFamily_afi_length((int **)v13, (int *)&v28);
    result = 0;
    if (!v13 || !v14)
      break;
    v15 = *((_QWORD *)v13 + 1);
    if (!v15)
      return 0;
    if (*(_DWORD *)v15 == 1)
    {
      v16 = *(const STACK **)(v15 + 8);
      if (!v16)
        return 0;
      result = sk_num(*(const STACK **)(v15 + 8));
      if (!(_DWORD)result)
        return result;
      if (sk_num(v16) >= 2)
      {
        v17 = 0;
        v18 = v28;
        v19 = (int)v28;
        while (1)
        {
          v20 = sk_value(v16, v17);
          v21 = sk_value(v16, ++v17);
          result = extract_min_max((uint64_t)v20, __s1, v31, v19);
          if (!(_DWORD)result)
            return result;
          result = extract_min_max((uint64_t)v21, __s2, v29, v18);
          if (!(_DWORD)result)
            return result;
          if ((memcmp(__s1, __s2, v19) & 0x80000000) == 0 || memcmp(__s1, v31, v19) > 0 || memcmp(__s2, v29, v19) > 0)
            return 0;
          v22 = v18;
          do
          {
            if ((int)v22 < 1)
              break;
            v23 = &__s2[v22--];
            v24 = *(v23 - 1);
            *(v23 - 1) = v24 - 1;
          }
          while (!v24);
          if ((memcmp(v31, __s2, v19) & 0x80000000) == 0
            || *(_DWORD *)v20 && (range_should_be_prefix((uint64_t)__s1, (uint64_t)v31, v19) & 0x80000000) == 0)
          {
            return 0;
          }
          if (v17 >= sk_num(v16) - 1)
            goto LABEL_40;
        }
      }
      v17 = 0;
LABEL_40:
      v25 = sk_value(v16, v17);
      if (*(_DWORD *)v25 == 1)
      {
        v26 = v28;
        result = extract_min_max((uint64_t)v25, __s1, v31, v28);
        if (!(_DWORD)result)
          return result;
        if (memcmp(__s1, v31, v26) > 0 || (range_should_be_prefix((uint64_t)__s1, (uint64_t)v31, v26) & 0x80000000) == 0)
          return 0;
      }
    }
    else if (*(_DWORD *)v15 || !*(_QWORD *)(v15 + 8))
    {
      return 0;
    }
    ++v12;
    v27 = sk_num(a1);
    result = 1;
  }
  while (v12 < v27);
  return result;
}

uint64_t IPAddressFamily_cmp(const void ****a1, const void ****a2)
{
  const void **v2;
  const void **v3;
  int v4;
  unsigned int v5;
  uint64_t result;

  v2 = **a1;
  v3 = **a2;
  v4 = *(_DWORD *)v2;
  v5 = *(_DWORD *)v2 - *(_DWORD *)v3;
  if (*(_DWORD *)v2 >= *(_DWORD *)v3)
    v4 = *(_DWORD *)v3;
  LODWORD(result) = memcmp(v2[1], v3[1], v4);
  if ((_DWORD)result)
    return result;
  else
    return v5;
}

uint64_t IPAddressFamily_afi_length(int **a1, int *a2)
{
  uint64_t result;
  int v4;
  __int16 v5;

  v5 = 0;
  *a2 = 0;
  result = IPAddressFamily_afi_safi(a1, &v5, 0, 0);
  if ((_DWORD)result)
  {
    if (v5 == 1)
      v4 = 4;
    else
      v4 = 16 * (v5 == 2);
    *a2 = v4;
    return 1;
  }
  return result;
}

uint64_t range_should_be_prefix(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v3;
  int v4;
  unsigned int v5;
  int v6;
  BOOL v7;
  int v8;
  uint64_t result;
  int v10;
  int v11;
  int v12;
  int v13;
  unsigned int v14;

  if (a3 < 1)
  {
    LODWORD(v3) = 0;
  }
  else
  {
    v3 = 0;
    while (*(unsigned __int8 *)(a1 + v3) == *(unsigned __int8 *)(a2 + v3))
    {
      if (a3 == ++v3)
      {
        LODWORD(v3) = a3;
        break;
      }
    }
  }
  v4 = a3 & (a3 >> 31);
  v5 = a3 - 1;
  while (1)
  {
    v6 = a3;
    v7 = __OFSUB__(a3--, 1);
    if (a3 < 0 != v7)
      break;
    if (!*(_BYTE *)(a1 + v5))
    {
      v8 = *(unsigned __int8 *)(a2 + v5--);
      if (v8 == 255)
        continue;
    }
    goto LABEL_13;
  }
  v6 = v4;
  a3 = v4 - 1;
LABEL_13:
  if ((int)v3 < a3)
    return 0xFFFFFFFFLL;
  if ((int)v3 >= v6)
    return (8 * v3);
  v10 = *(unsigned __int8 *)(a1 + v3);
  v11 = *(unsigned __int8 *)(a2 + v3);
  v12 = v11 ^ v10;
  result = 0xFFFFFFFFLL;
  if ((v11 ^ v10) <= 14)
  {
    switch(v12)
    {
      case 1:
        v13 = 7;
        break;
      case 3:
        v13 = 6;
        break;
      case 7:
        v13 = 5;
        break;
      default:
        return result;
    }
  }
  else if (v12 > 62)
  {
    if (v12 == 63)
    {
      v13 = 2;
    }
    else
    {
      if (v12 != 127)
        return result;
      v13 = 1;
    }
  }
  else if (v12 == 15)
  {
    v13 = 4;
  }
  else
  {
    if (v12 != 31)
      return result;
    v13 = 3;
  }
  if ((v12 & v10) == 0)
  {
    v14 = v13 | (8 * v3);
    if ((v12 & v11) == v12)
      return v14;
    else
      return 0xFFFFFFFFLL;
  }
  return result;
}

uint64_t X509v3_addr_canonize(STACK *a1)
{
  int v2;
  char *v3;
  uint64_t result;
  uint64_t v5;
  STACK *v6;
  int v7;
  size_t v8;
  int v9;
  char *v10;
  char *v11;
  uint64_t v12;
  int v14;
  char *v15;
  unsigned __int16 v16;
  char *v17;
  char v18[16];
  char __dst[16];
  char __s2[16];
  char __s1[16];
  uint64_t v22;

  v22 = *MEMORY[0x24BDAC8D0];
  v16 = 0;
  if (sk_num(a1) < 1)
  {
LABEL_33:
    sk_set_cmp_func(a1, (int (__cdecl *)(const char *const *, const char *const *))IPAddressFamily_cmp);
    sk_sort(a1);
    return X509v3_addr_is_canonical(a1);
  }
  else
  {
    v2 = 0;
    while (1)
    {
      v3 = sk_value(a1, v2);
      result = IPAddressFamily_afi_safi((int **)v3, &v16, 0, 0);
      if (!(_DWORD)result)
        break;
      if (v3)
      {
        v5 = *((_QWORD *)v3 + 1);
        if (v5)
        {
          if (*(_DWORD *)v5 == 1)
          {
            v6 = *(STACK **)(v5 + 8);
            if (v6)
            {
              v7 = v16;
              v17 = 0;
              if (v16 == 1)
                v8 = 4;
              else
                v8 = 16 * (v16 == 2);
              sk_sort(v6);
              if (sk_num(v6) >= 2)
              {
                v9 = 0;
                while (1)
                {
                  v10 = sk_value(v6, v9);
                  v11 = sk_value(v6, v9 + 1);
                  if (!extract_min_max((uint64_t)v10, __s1, __s2, v8)
                    || !extract_min_max((uint64_t)v11, __dst, v18, v8)
                    || memcmp(__s1, __s2, v8) > 0
                    || memcmp(__dst, v18, v8) > 0
                    || (memcmp(__s2, __dst, v8) & 0x80000000) == 0)
                  {
                    return 0;
                  }
                  v12 = v8;
                  do
                  {
                    if (v12-- < 1)
                      break;
                    v14 = __dst[v12];
                    __dst[v12] = v14 - 1;
                  }
                  while (!v14);
                  if (!memcmp(__s2, __dst, v8))
                  {
                    if (!make_addressRange((ASN1_VALUE **)&v17, __s1, v18, v7, v8))
                      return 0;
                    sk_set(v6, v9, v17);
                    sk_delete(v6, v9 + 1);
                    ASN1_item_free((ASN1_VALUE *)v10, &IPAddressOrRange_it);
                    ASN1_item_free((ASN1_VALUE *)v11, &IPAddressOrRange_it);
                  }
                  else
                  {
                    ++v9;
                  }
                  if (v9 >= sk_num(v6) - 1)
                    goto LABEL_28;
                }
              }
              v9 = 0;
LABEL_28:
              v15 = sk_value(v6, v9);
              if (v15
                && *(_DWORD *)v15 == 1
                && (!extract_min_max((uint64_t)v15, __s1, __s2, v8) || memcmp(__s1, __s2, v8) >= 1))
              {
                return 0;
              }
            }
          }
        }
      }
      if (++v2 >= sk_num(a1))
        goto LABEL_33;
    }
  }
  return result;
}

STACK *v2i_IPAddrBlocks(uint64_t a1, uint64_t a2, const STACK *a3)
{
  STACK *v4;
  int v5;
  const char **v6;
  unsigned int v7;
  const char *v8;
  const char *v9;
  char *v10;
  unsigned int *v11;
  int v12;
  unint64_t v13;
  char *v14;
  unsigned int v15;
  unint64_t v16;
  int v17;
  BOOL v18;
  char *v19;
  unsigned int v20;
  const STACK *v21;
  int v22;
  const char *v23;
  int v24;
  int v25;
  uint64_t v26;
  unsigned int v27;
  int v28;
  int v29;
  int v30;
  int v31;
  int v32;
  __int128 v33;
  const char *v34;
  int v35;
  STACK *v37;
  unsigned int v38;
  const char *v39;
  unsigned int *v40;
  char *__errstrp;
  int v42;
  char *__endptr;
  unsigned __int8 __s2[16];
  unsigned __int8 ipout[16];
  uint64_t v46;

  v46 = *MEMORY[0x24BDAC8D0];
  v4 = sk_new((int (__cdecl *)(const char *const *, const char *const *))IPAddressFamily_cmp);
  if (!v4)
  {
    ERR_put_error(34, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_addr.c", 1507);
    return v4;
  }
  __endptr = 0;
  if (sk_num(a3) < 1)
  {
LABEL_42:
    if (X509v3_addr_canonize(v4))
      return v4;
LABEL_43:
    v10 = 0;
    goto LABEL_59;
  }
  v5 = 0;
  v37 = v4;
  while (1)
  {
    v6 = (const char **)sk_value(a3, v5);
    v42 = 0;
    __errstrp = 0;
    if (!name_cmp(v6[1], "IPv4"))
    {
      v38 = 4;
      v7 = 1;
      v9 = "0123456789.";
      goto LABEL_11;
    }
    if (!name_cmp(v6[1], "IPv6"))
    {
      v38 = 16;
      v7 = 2;
      v9 = "0123456789.:abcdefABCDEF";
LABEL_11:
      v10 = strdup(v6[2]);
      v11 = 0;
      if (!v10)
        goto LABEL_45;
      goto LABEL_24;
    }
    if (!name_cmp(v6[1], "IPv4-SAFI"))
    {
      v38 = 4;
      v7 = 1;
      v8 = "0123456789.";
      goto LABEL_14;
    }
    if (name_cmp(v6[1], "IPv6-SAFI"))
    {
      ERR_put_error(34, 4095, 115, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_addr.c", 1530);
      ERR_asprintf_error_data("section:%s,name:%s,value:%s", *v6, v6[1], v6[2]);
      goto LABEL_43;
    }
    v38 = 16;
    v7 = 2;
    v8 = "0123456789.:abcdefABCDEF";
LABEL_14:
    v39 = v8;
    v12 = *__error();
    *__error() = 0;
    v13 = strtoul(v6[2], &__endptr, 0);
    if (!*v6[2]
      || (v14 = __endptr, v15 = *__endptr, v15 > 0x3A)
      || ((1 << v15) & 0x400000100000200) == 0)
    {
      v32 = 1560;
      goto LABEL_52;
    }
    v16 = v13;
    v17 = *__error();
    v18 = v16 == -1 && v17 == 34;
    if (v18 || v16 >= 0x100)
    {
      v32 = 1567;
      goto LABEL_52;
    }
    *__error() = v12;
    v42 = v16;
    v19 = &v14[strspn(v14, " \t")];
    __endptr = v19;
    if (*v19 != 58)
      break;
    __endptr = &v19[strspn(v19 + 1, " \t") + 1];
    v10 = strdup(__endptr);
    v11 = (unsigned int *)&v42;
    v4 = v37;
    v9 = v39;
    if (!v10)
    {
LABEL_45:
      v35 = 1594;
      goto LABEL_46;
    }
LABEL_24:
    v40 = v11;
    if (!strcmp(v10, "inherit"))
    {
      if (X509v3_addr_add_inherit(v4, v7, v40))
        goto LABEL_41;
      ERR_put_error(34, 4095, 165, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_addr.c", 1604);
      v33 = *(_OWORD *)v6;
      v34 = v6[2];
      goto LABEL_62;
    }
    v20 = v7;
    v21 = a3;
    v22 = strspn(v10, v9);
    v23 = &v10[v22];
    v24 = strspn(v23, " \t") + v22;
    v25 = v10[v24];
    *v23 = 0;
    if (a2i_ipadd(ipout, v10) != v38)
    {
      v30 = 166;
      v31 = 1619;
      goto LABEL_57;
    }
    if (v25)
    {
      v26 = v24 + 1;
      if (v25 != 45)
      {
        if (v25 == 47)
        {
          v27 = strtonum(&v10[(int)v26], 0, 8 * v38, (const char **)&__errstrp);
          if (__errstrp)
          {
            ERR_put_error(34, 4095, 116, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_addr.c", 1631);
            ERR_asprintf_error_data("section:%s,name:%s,value:%s", *v6, v6[1], v6[2]);
            v4 = v37;
            goto LABEL_59;
          }
          v4 = v37;
          a3 = v21;
          if (!X509v3_addr_add_prefix(v37, v20, v40, ipout, v27))
          {
            v35 = 1637;
LABEL_46:
            ERR_put_error(34, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_addr.c", v35);
            goto LABEL_59;
          }
          goto LABEL_41;
        }
        v30 = 116;
        v31 = 1672;
LABEL_57:
        ERR_put_error(34, 4095, v30, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_addr.c", v31);
        ERR_asprintf_error_data("section:%s,name:%s,value:%s", *v6, v6[1], v6[2]);
        goto LABEL_58;
      }
      v28 = v26 + strspn(&v10[v26], " \t");
      v29 = strspn(&v10[v28], v9);
      if (!v29 || v10[v28 + v29])
      {
        v30 = 116;
        v31 = 1645;
        goto LABEL_57;
      }
      if (a2i_ipadd(__s2, &v10[v28]) != v38)
      {
        v30 = 166;
        v31 = 1650;
        goto LABEL_57;
      }
      v4 = v37;
      if (memcmp(ipout, __s2, v38) < 1)
      {
        a3 = v21;
        if (!X509v3_addr_add_range(v37, v20, v40, ipout, __s2))
        {
          v35 = 1660;
          goto LABEL_46;
        }
        goto LABEL_41;
      }
      ERR_put_error(34, 4095, 116, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_addr.c", 1655);
      v33 = *(_OWORD *)v6;
      v34 = v6[2];
LABEL_62:
      ERR_asprintf_error_data("section:%s,name:%s,value:%s", (const char *)v33, *((const char **)&v33 + 1), v34);
      goto LABEL_59;
    }
    v4 = v37;
    a3 = v21;
    if (!X509v3_addr_add_prefix(v37, v20, v40, ipout, 8 * v38))
    {
      v35 = 1667;
      goto LABEL_46;
    }
LABEL_41:
    free(v10);
    if (++v5 >= sk_num(a3))
      goto LABEL_42;
  }
  v32 = 1578;
LABEL_52:
  ERR_put_error(34, 4095, 164, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_addr.c", v32);
  ERR_asprintf_error_data("section:%s,name:%s,value:%s", *v6, v6[1], v6[2]);
  v10 = 0;
LABEL_58:
  v4 = v37;
LABEL_59:
  free(v10);
  sk_pop_free(v4, (void (__cdecl *)(void *))IPAddressFamily_free);
  return 0;
}

uint64_t i2r_IPAddrBlocks(int a1, STACK *a2, BIO *a3, int a4)
{
  int v7;
  char *v8;
  BIO *v9;
  const char *v10;
  unsigned int *v11;
  unsigned int v12;
  uint64_t v13;
  const STACK *v14;
  int v15;
  int v16;
  char *v17;
  unsigned int *v18;
  uint64_t result;
  unsigned int **v20;
  int v21;
  unsigned __int8 v22;
  unsigned __int16 v23;

  v23 = 0;
  v22 = 0;
  if (sk_num(a2) >= 1)
  {
    v7 = 0;
    v21 = 0;
    do
    {
      v8 = sk_value(a2, v7);
      if (!IPAddressFamily_afi_safi((int **)v8, &v23, &v22, &v21))
        goto LABEL_27;
      if (v23 == 2)
      {
        BIO_printf(a3, "%*sIPv6");
      }
      else if (v23 == 1)
      {
        BIO_printf(a3, "%*sIPv4");
      }
      else
      {
        BIO_printf(a3, "%*sUnknown AFI %u");
      }
      if (!v21)
        goto LABEL_27;
      if (v22 <= 0x3Fu)
      {
        switch(v22)
        {
          case 1u:
            v9 = a3;
            v10 = " (Unicast)";
            goto LABEL_24;
          case 2u:
            v9 = a3;
            v10 = " (Multicast)";
            goto LABEL_24;
          case 3u:
            v9 = a3;
            v10 = " (Unicast/Multicast)";
            goto LABEL_24;
          case 4u:
            v9 = a3;
            v10 = " (MPLS)";
            goto LABEL_24;
          default:
            goto LABEL_35;
        }
      }
      if (v22 > 0x41u)
      {
        if (v22 == 66)
        {
          BIO_puts(a3, " (BGP MDT)");
LABEL_27:
          if (v8)
            goto LABEL_28;
          goto LABEL_48;
        }
        if (v22 == 128)
        {
          v9 = a3;
          v10 = " (MPLS-labeled VPN)";
          goto LABEL_24;
        }
      }
      else
      {
        if (v22 == 64)
        {
          v9 = a3;
          v10 = " (Tunnel)";
LABEL_24:
          BIO_puts(v9, v10);
          if (v8)
            goto LABEL_28;
          goto LABEL_48;
        }
        if (v22 == 65)
        {
          v9 = a3;
          v10 = " (VPLS)";
          goto LABEL_24;
        }
      }
LABEL_35:
      BIO_printf(a3, " (Unknown SAFI %u)", v22);
      if (v8)
      {
LABEL_28:
        v11 = (unsigned int *)*((_QWORD *)v8 + 1);
        if (v11)
        {
          v12 = *v11;
          if (v12 <= 1)
          {
            if (v12 == 1)
            {
              BIO_puts(a3, ":\n");
              v13 = *((_QWORD *)v8 + 1);
              if (v13 && *(_DWORD *)v13 == 1)
                v14 = *(const STACK **)(v13 + 8);
              else
                v14 = 0;
              v15 = v23;
              if (sk_num(v14) >= 1)
              {
                v16 = 0;
                do
                {
                  v17 = sk_value(v14, v16);
                  BIO_printf(a3, "%*s", a4 + 2, "");
                  if (*(_DWORD *)v17 == 1)
                  {
                    v20 = (unsigned int **)*((_QWORD *)v17 + 1);
                    result = i2r_address(a3, v15, 0, *v20);
                    if (!(_DWORD)result)
                      return result;
                    BIO_puts(a3, "-");
                    result = i2r_address(a3, v15, 255, v20[1]);
                    if (!(_DWORD)result)
                      return result;
                    BIO_puts(a3, "\n");
                  }
                  else if (!*(_DWORD *)v17)
                  {
                    v18 = (unsigned int *)*((_QWORD *)v17 + 1);
                    result = i2r_address(a3, v15, 0, v18);
                    if (!(_DWORD)result)
                      return result;
                    BIO_printf(a3, "/%d\n", 8 * *v18 - (v18[4] & 7));
                  }
                }
                while (++v16 < sk_num(v14));
              }
            }
            else
            {
              BIO_puts(a3, ": inherit\n");
            }
          }
        }
      }
LABEL_48:
      ++v7;
    }
    while (v7 < sk_num(a2));
  }
  return 1;
}

const STACK *X509v3_addr_inherits(const STACK *result)
{
  const STACK *v1;
  int v2;
  char *v3;
  uint64_t v4;

  if (result)
  {
    v1 = result;
    if (sk_num(result) < 1)
    {
      return 0;
    }
    else
    {
      v2 = 0;
      while (1)
      {
        v3 = sk_value(v1, v2);
        if (v3)
        {
          v4 = *((_QWORD *)v3 + 1);
          if (v4)
          {
            if (!*(_DWORD *)v4 && *(_QWORD *)(v4 + 8))
              break;
          }
        }
        if (++v2 >= sk_num(v1))
          return 0;
      }
      return (const STACK *)1;
    }
  }
  return result;
}

uint64_t X509v3_addr_subset(const STACK *a1, STACK *a2)
{
  uint64_t result;
  int v5;
  char *v6;
  uint64_t v7;
  uint64_t v8;
  STACK *v9;
  uint64_t v10;
  STACK *v11;
  int v12;
  int v13;

  result = 1;
  if (a1 && a1 != a2)
  {
    if (!a2 || X509v3_addr_inherits(a1) || X509v3_addr_inherits(a2))
    {
      return 0;
    }
    else if (sk_num(a1) < 1)
    {
      return 1;
    }
    else
    {
      v5 = 0;
      v13 = 0;
      do
      {
        v6 = sk_value(a1, v5);
        result = (uint64_t)IPAddressFamily_find_in_parent(a2, v6);
        if (!result)
          break;
        v7 = result;
        result = IPAddressFamily_afi_length((int **)result, &v13);
        if (!(_DWORD)result)
          break;
        if (v6 && (v8 = *((_QWORD *)v6 + 1)) != 0 && *(_DWORD *)v8 == 1)
          v9 = *(STACK **)(v8 + 8);
        else
          v9 = 0;
        v10 = *(_QWORD *)(v7 + 8);
        if (v10 && *(_DWORD *)v10 == 1)
          v11 = *(STACK **)(v10 + 8);
        else
          v11 = 0;
        result = addr_contains(v11, v9, v13);
        if (!(_DWORD)result)
          break;
        ++v5;
        v12 = sk_num(a1);
        result = 1;
      }
      while (v5 < v12);
    }
  }
  return result;
}

char *IPAddressFamily_find_in_parent(STACK *a1, char *a2)
{
  int v4;

  sk_set_cmp_func(a1, (int (__cdecl *)(const char *const *, const char *const *))IPAddressFamily_cmp);
  v4 = sk_find(a1, a2);
  if (v4 < 0)
    return 0;
  else
    return sk_value(a1, v4);
}

uint64_t addr_contains(STACK *a1, STACK *a2, int a3)
{
  uint64_t result;
  int v7;
  int v8;
  char *v9;
  char *v10;
  int v11;
  char __s2[16];
  char __dst[16];
  char __s1[16];
  char v15[16];
  uint64_t v16;

  v16 = *MEMORY[0x24BDAC8D0];
  result = 1;
  if (a2 && a1 != a2)
  {
    if (!a1)
      return 0;
    if (sk_num(a2) < 1)
    {
      return 1;
    }
    else
    {
      v7 = 0;
      v8 = 0;
LABEL_6:
      v9 = sk_value(a2, v7);
      result = extract_min_max((uint64_t)v9, __dst, __s2, a3);
      if ((_DWORD)result)
      {
        while (v8 < sk_num(a1))
        {
          v10 = sk_value(a1, v8);
          result = extract_min_max((uint64_t)v10, v15, __s1, a3);
          if (!(_DWORD)result)
            return result;
          if ((memcmp(__s1, __s2, a3) & 0x80000000) == 0)
          {
            if (memcmp(v15, __dst, a3) > 0)
              return 0;
            ++v7;
            v11 = sk_num(a2);
            result = 1;
            if (v7 < v11)
              goto LABEL_6;
            return result;
          }
          ++v8;
        }
        return 0;
      }
    }
  }
  return result;
}

uint64_t X509v3_addr_validate_path(uint64_t a1)
{
  if (sk_num(*(const STACK **)(a1 + 160)) >= 1 && *(_QWORD *)(a1 + 64))
    return addr_validate_path_internal(a1, *(STACK **)(a1 + 160), 0);
  *(_DWORD *)(a1 + 176) = 1;
  return 0;
}

uint64_t addr_validate_path_internal(uint64_t a1, STACK *a2, STACK *a3)
{
  const STACK *v4;
  STACK *v6;
  uint64_t v7;
  char *v8;
  uint64_t v9;
  STACK *v10;
  STACK *v11;
  int v12;
  int i;
  char *v14;
  char *v15;
  char *v16;
  uint64_t v17;
  uint64_t v18;
  STACK *v19;
  char *v20;
  STACK *v21;
  int v22;
  uint64_t v23;
  int v24;
  char *v25;
  uint64_t v26;
  const STACK *v27;
  int v28;
  char *v29;
  uint64_t v30;
  STACK *v32;
  unsigned int v33;
  int v34;

  v4 = a2;
  v34 = 0;
  if (sk_num(a2) < 1)
  {
    v6 = 0;
LABEL_5:
    sk_free(v6);
    if (!a1)
      return 0;
    goto LABEL_76;
  }
  if (a1 | (unint64_t)a3)
  {
    if (!a1 || *(_QWORD *)(a1 + 64))
    {
      if (a3)
      {
        if (!X509v3_addr_is_canonical(a3))
        {
          if (!a1)
            goto LABEL_83;
          *(_QWORD *)(a1 + 184) = 0;
          *(_QWORD *)(a1 + 172) = 0x29FFFFFFFFLL;
          v9 = (*(uint64_t (**)(_QWORD, uint64_t))(a1 + 64))(0, a1);
          v8 = 0;
          v7 = 0;
          v6 = 0;
          if (!(_DWORD)v9)
            goto LABEL_86;
LABEL_15:
          sk_set_cmp_func(a3, (int (__cdecl *)(const char *const *, const char *const *))IPAddressFamily_cmp);
          v10 = sk_dup(a3);
          if (v10)
          {
            v6 = v10;
            if ((int)v7 < sk_num(v4))
            {
              v32 = (STACK *)v4;
              do
              {
                v8 = sk_value(v4, v7);
                if ((X509_get_extension_flags((uint64_t)v8) & 0x80) != 0)
                {
                  if (!a1)
                    goto LABEL_84;
                  *(_QWORD *)(a1 + 184) = v8;
                  *(_DWORD *)(a1 + 172) = v7;
                  *(_DWORD *)(a1 + 176) = 41;
                  LODWORD(v9) = (*(uint64_t (**)(_QWORD, uint64_t))(a1 + 64))(0, a1);
                  if (!(_DWORD)v9)
                    goto LABEL_84;
                }
                v11 = (STACK *)*((_QWORD *)v8 + 16);
                v12 = sk_num(v6);
                v33 = v9;
                if (v11)
                {
                  if (v12 >= 1)
                  {
                    for (i = 0; i < sk_num(v6); ++i)
                    {
                      v14 = sk_value(v6, i);
                      v15 = IPAddressFamily_find_in_parent(v11, v14);
                      if (!v15)
                      {
                        if (!v14)
                          goto LABEL_61;
                        v23 = *((_QWORD *)v14 + 1);
                        if (!v23 || *(_DWORD *)v23 || !*(_QWORD *)(v23 + 8))
                          goto LABEL_61;
                        continue;
                      }
                      v16 = v15;
                      v17 = *((_QWORD *)v15 + 1);
                      if (v17 && !*(_DWORD *)v17 && *(_QWORD *)(v17 + 8))
                        continue;
                      if (v14)
                      {
                        v18 = *((_QWORD *)v14 + 1);
                        if (v18)
                        {
                          if (*(_DWORD *)v18 == 1)
                          {
                            v19 = *(STACK **)(v18 + 8);
                            goto LABEL_35;
                          }
                          if (!*(_DWORD *)v18 && *(_QWORD *)(v18 + 8))
                            goto LABEL_41;
                        }
                      }
                      v19 = 0;
LABEL_35:
                      if (!v17)
                        goto LABEL_5;
                      if (*(_DWORD *)v17 != 1)
                        goto LABEL_5;
                      if (!v19)
                        goto LABEL_5;
                      v20 = v8;
                      v21 = *(STACK **)(v17 + 8);
                      if (!v21 || !IPAddressFamily_afi_length((int **)v14, &v34))
                        goto LABEL_5;
                      v22 = addr_contains(v21, v19, v34);
                      v8 = v20;
                      if (v22)
                      {
LABEL_41:
                        sk_set(v6, i, v16);
                        continue;
                      }
                      if (!a1)
                        goto LABEL_84;
                      *(_QWORD *)(a1 + 184) = v20;
                      *(_DWORD *)(a1 + 172) = v7;
                      *(_DWORD *)(a1 + 176) = 46;
                      v33 = (*(uint64_t (**)(_QWORD, uint64_t))(a1 + 64))(0, a1);
                      if (!v33)
                        goto LABEL_84;
                    }
                  }
                }
                else if (v12 >= 1)
                {
                  v24 = 0;
                  while (1)
                  {
                    v25 = sk_value(v6, v24);
                    if (!v25)
                      break;
                    v26 = *((_QWORD *)v25 + 1);
                    if (!v26 || *(_DWORD *)v26 || !*(_QWORD *)(v26 + 8))
                      break;
                    if (++v24 >= sk_num(v6))
                      goto LABEL_63;
                  }
LABEL_61:
                  if (!a1)
                    goto LABEL_84;
                  *(_QWORD *)(a1 + 184) = v8;
                  *(_DWORD *)(a1 + 172) = v7;
                  *(_DWORD *)(a1 + 176) = 46;
                  v33 = (*(uint64_t (**)(_QWORD, uint64_t))(a1 + 64))(0, a1);
                  if (!v33)
                    goto LABEL_84;
                }
LABEL_63:
                LODWORD(v7) = v7 + 1;
                v4 = v32;
                v9 = v33;
              }
              while ((int)v7 < sk_num(v32));
            }
            v27 = (const STACK *)*((_QWORD *)v8 + 16);
            if (v27 && sk_num(*((const STACK **)v8 + 16)) >= 1)
            {
              v28 = 0;
              do
              {
                v29 = sk_value(v27, v28);
                if (v29)
                {
                  v30 = *((_QWORD *)v29 + 1);
                  if (v30)
                  {
                    if (!*(_DWORD *)v30)
                    {
                      if (*(_QWORD *)(v30 + 8))
                      {
                        if (!a1)
                          goto LABEL_84;
                        *(_QWORD *)(a1 + 184) = v8;
                        *(_DWORD *)(a1 + 172) = v7;
                        *(_DWORD *)(a1 + 176) = 46;
                        v9 = (*(uint64_t (**)(_QWORD, uint64_t))(a1 + 64))(0, a1);
                        if (!(_DWORD)v9)
                          goto LABEL_84;
                      }
                    }
                  }
                }
              }
              while (++v28 < sk_num(v27));
            }
            v7 = v9;
LABEL_86:
            sk_free(v6);
            return v7;
          }
          ERR_put_error(34, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_addr.c", 1885);
          if (a1)
          {
            v6 = 0;
            v7 = 0;
            *(_DWORD *)(a1 + 176) = 17;
            goto LABEL_86;
          }
LABEL_83:
          v6 = 0;
LABEL_84:
          v7 = 0;
          goto LABEL_86;
        }
        v8 = 0;
        LODWORD(v7) = 0;
      }
      else
      {
        v8 = sk_value(v4, 0);
        if ((X509_get_extension_flags((uint64_t)v8) & 0x80) != 0)
        {
          v6 = 0;
          v7 = 1;
          goto LABEL_86;
        }
        a3 = (STACK *)*((_QWORD *)v8 + 16);
        v7 = 1;
        if (!a3)
        {
          v6 = 0;
          goto LABEL_86;
        }
      }
      v9 = 1;
      goto LABEL_15;
    }
    sk_free(0);
LABEL_76:
    v7 = 0;
    *(_DWORD *)(a1 + 176) = 1;
    return v7;
  }
  sk_free(0);
  return 0;
}

uint64_t X509v3_addr_validate_resource_set(STACK *a1, STACK *a2, int a3)
{
  if (!a2)
    return 1;
  if (sk_num(a1) >= 1 && (a3 || !X509v3_addr_inherits(a2)))
    return addr_validate_path_internal(0, a1, a2);
  return 0;
}

uint64_t IPAddressFamily_afi_safi(int **a1, _WORD *a2, _BYTE *a3, int *a4)
{
  uint64_t result;
  int v8;
  char v9;
  __int16 v10;
  unsigned __int16 *v11[3];

  memset(v11, 0, sizeof(v11));
  v10 = 0;
  v9 = 0;
  CBS_init(v11, *((_QWORD *)*a1 + 1), **a1);
  result = CBS_get_u16(v11, &v10);
  if ((_DWORD)result)
  {
    if (CBS_len((uint64_t)v11))
    {
      result = CBS_get_u8(v11, &v9);
      if (!(_DWORD)result)
        return result;
      v8 = 1;
    }
    else
    {
      v8 = 0;
    }
    if (CBS_len((uint64_t)v11))
    {
      return 0;
    }
    else
    {
      if (a2)
        *a2 = v10;
      if (a3)
      {
        *a3 = v9;
        *a4 = v8;
      }
      return 1;
    }
  }
  return result;
}

uint64_t v4IPAddressOrRange_cmp(uint64_t *a1, uint64_t *a2)
{
  return IPAddressOrRange_cmp(*a1, *a2, 4u);
}

uint64_t v6IPAddressOrRange_cmp(uint64_t *a1, uint64_t *a2)
{
  return IPAddressOrRange_cmp(*a1, *a2, 0x10u);
}

uint64_t IPAddressOrRange_cmp(uint64_t a1, uint64_t a2, unsigned int a3)
{
  int v6;
  int v7;
  uint64_t result;
  char __s2[16];
  char __s1[16];
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  if (*(_DWORD *)a1 == 1)
  {
    if (!addr_expand(__s1, **(unsigned int ***)(a1 + 8), a3, 0))
      return 0xFFFFFFFFLL;
    v6 = 8 * a3;
  }
  else if (*(_DWORD *)a1)
  {
    v6 = 0;
  }
  else
  {
    if (!addr_expand(__s1, *(unsigned int **)(a1 + 8), a3, 0))
      return 0xFFFFFFFFLL;
    v6 = 8 * **(_DWORD **)(a1 + 8) - (*(_DWORD *)(*(_QWORD *)(a1 + 8) + 16) & 7);
  }
  if (*(_DWORD *)a2 == 1)
  {
    if (!addr_expand(__s2, **(unsigned int ***)(a2 + 8), a3, 0))
      return 0xFFFFFFFFLL;
    v7 = 8 * a3;
  }
  else
  {
    if (!*(_DWORD *)a2)
    {
      if (addr_expand(__s2, *(unsigned int **)(a2 + 8), a3, 0))
      {
        v7 = 8 * **(_DWORD **)(a2 + 8) - (*(_DWORD *)(*(_QWORD *)(a2 + 8) + 16) & 7);
        goto LABEL_16;
      }
      return 0xFFFFFFFFLL;
    }
    v7 = 0;
  }
LABEL_16:
  LODWORD(result) = memcmp(__s1, __s2, a3);
  if ((_DWORD)result)
    return result;
  else
    return (v6 - v7);
}

uint64_t addr_expand(char *__dst, unsigned int *a2, int a3, int a4)
{
  uint64_t result;
  size_t v7;
  int v10;
  char *v11;
  char v12;
  int v13;

  result = 0;
  v7 = *a2;
  if ((v7 & 0x80000000) == 0 && (int)v7 <= a3)
  {
    if ((_DWORD)v7)
    {
      v10 = -1 << (a2[4] & 7);
      memcpy(__dst, *((const void **)a2 + 1), v7);
      v11 = &__dst[*a2];
      if (a4)
        v12 = *(v11 - 1) | ~(_BYTE)v10;
      else
        v12 = *(v11 - 1) & v10;
      *(v11 - 1) = v12;
    }
    if (a4)
      v13 = -1;
    else
      v13 = 0;
    memset(&__dst[*a2], v13, a3 - (uint64_t)(int)*a2);
    return 1;
  }
  return result;
}

uint64_t trim_end_u8(_QWORD *a1, int a2)
{
  uint64_t result;
  unsigned __int8 v5;

  v5 = 0;
  while (CBS_len((uint64_t)a1))
  {
    result = CBS_peek_last_u8(a1, &v5);
    if (!(_DWORD)result)
      return result;
    if (v5 != a2)
      break;
    result = CBS_get_last_u8(a1, &v5);
    if (!(_DWORD)result)
      return result;
  }
  return 1;
}

uint64_t i2r_address(BIO *bio, int a2, int a3, unsigned int *a4)
{
  uint64_t result;
  uint64_t v7;
  int v8;
  int v9;
  unint64_t v10;
  unint64_t v11;
  unsigned int v12;
  const char *v13;
  uint64_t v14;
  const char *v15;
  char __dst;
  uint64_t v17;

  v17 = *MEMORY[0x24BDAC8D0];
  if ((*a4 & 0x80000000) != 0)
    return 0;
  if (a2 == 1)
  {
    result = addr_expand(&__dst, a4, 4, a3);
    if (!(_DWORD)result)
      return result;
    BIO_printf(bio, "%d.%d.%d.%d");
  }
  else if (a2 == 2)
  {
    result = addr_expand(&__dst, a4, 16, a3);
    if (!(_DWORD)result)
      return result;
    v7 = 0;
    do
    {
      if (v7 == -16)
        goto LABEL_28;
      v8 = v7;
      if (*(&__dst + (v7 + 15)))
        break;
      v7 -= 2;
    }
    while (!*(&__dst + ((v8 + 14) & 0xFFFFFFFE)));
    v9 = v8 + 16;
    if (v9 < 1)
    {
LABEL_28:
      BIO_puts(bio, ":");
LABEL_29:
      BIO_puts(bio, ":");
      return 1;
    }
    v10 = 0;
    v11 = v9 & 0xFFFFFFFE;
    do
    {
      v12 = __rev16(*(unsigned __int16 *)(&__dst + v10));
      if (v10 >= 0xE)
        v13 = "";
      else
        v13 = ":";
      BIO_printf(bio, "%x%s", v12, v13);
      v10 += 2;
    }
    while (v10 < v11);
    if (v10 <= 0xF)
    {
      BIO_puts(bio, ":");
      if (!(_DWORD)v10)
        goto LABEL_29;
    }
  }
  else
  {
    if (*a4)
    {
      v14 = 0;
      do
      {
        if (v14)
          v15 = ":";
        else
          v15 = "";
        BIO_printf(bio, "%s%02x", v15, *(unsigned __int8 *)(*((_QWORD *)a4 + 1) + v14++));
      }
      while (v14 < (int)*a4);
    }
    BIO_printf(bio, "[%d]");
  }
  return 1;
}

DSO_METHOD *DSO_METHOD_null(void)
{
  return (DSO_METHOD *)&dso_meth_null;
}

uint64_t CMS_RecipientInfo_set0_password(uint64_t a1, char *__s, size_t a3)
{
  uint64_t v3;

  if (*(_DWORD *)a1 == 3)
  {
    v3 = *(_QWORD *)(a1 + 8);
    *(_QWORD *)(v3 + 32) = __s;
    if (__s)
    {
      if ((a3 & 0x8000000000000000) != 0)
        a3 = strlen(__s);
    }
    *(_QWORD *)(v3 + 40) = a3;
    return 1;
  }
  else
  {
    ERR_put_error(46, 4095, 177, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/cms/cms_pwri.c", 75);
    return 0;
  }
}

EVP_CIPHER_CTX *CMS_add0_recipient_password(uint64_t a1, int a2, int a3, uint64_t a4, char *a5, size_t a6, const EVP_CIPHER *a7)
{
  uint64_t v12;
  uint64_t v13;
  int v14;
  int v15;
  X509_ALGOR *v16;
  EVP_CIPHER_CTX *v17;
  EVP_CIPHER_CTX *v18;
  int v19;
  ASN1_TYPE *v20;
  const EVP_CIPHER *v21;
  int v22;
  ASN1_VALUE *v23;
  ASN1_VALUE *v24;
  X509_ALGOR *v25;
  ASN1_TYPE *v26;
  X509_ALGOR *v27;
  int v28;
  int v29;
  unsigned __int8 __buf[16];
  uint64_t v32;

  v32 = *MEMORY[0x24BDAC8D0];
  v12 = cms_get0_enveloped(a1);
  if (!v12)
    return 0;
  v13 = v12;
  if (!a7)
  {
    a7 = *(const EVP_CIPHER **)(*(_QWORD *)(v12 + 24) + 24);
    if (!a7)
    {
      v14 = 126;
      v15 = 116;
      goto LABEL_26;
    }
  }
  if (a3 >= 1 && a3 != 893)
  {
    v14 = 179;
    v15 = 120;
LABEL_26:
    ERR_put_error(46, 4095, v14, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/cms/cms_pwri.c", v15);
    return 0;
  }
  v16 = X509_ALGOR_new();
  if (!v16)
  {
    v18 = 0;
    goto LABEL_23;
  }
  v17 = EVP_CIPHER_CTX_new();
  v18 = v17;
  if (!v17)
    goto LABEL_23;
  if (EVP_EncryptInit_ex(v17, a7, 0, 0, 0) <= 0)
  {
    v28 = 6;
    v29 = 134;
    goto LABEL_31;
  }
  v19 = EVP_CIPHER_CTX_iv_length(v18);
  if (v19 >= 1)
  {
    arc4random_buf(__buf, v19);
    if (EVP_EncryptInit_ex(v18, 0, 0, 0, __buf) <= 0)
    {
      v28 = 6;
      v29 = 143;
    }
    else
    {
      v20 = ASN1_TYPE_new();
      v16->parameter = v20;
      if (v20)
      {
        if (EVP_CIPHER_param_to_asn1(v18, v20) > 0)
          goto LABEL_14;
        v28 = 102;
        v29 = 152;
      }
      else
      {
        v28 = 65;
        v29 = 148;
      }
    }
LABEL_31:
    ERR_put_error(46, 4095, v28, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/cms/cms_pwri.c", v29);
    EVP_CIPHER_CTX_free(v18);
    goto LABEL_32;
  }
LABEL_14:
  v21 = EVP_CIPHER_CTX_cipher(v18);
  v22 = EVP_CIPHER_type(v21);
  v16->algorithm = OBJ_nid2obj(v22);
  EVP_CIPHER_CTX_free(v18);
  v18 = (EVP_CIPHER_CTX *)ASN1_item_new(&CMS_RecipientInfo_it);
  if (!v18)
    goto LABEL_23;
  v23 = ASN1_item_new(&CMS_PasswordRecipientInfo_it);
  v18->engine = v23;
  if (!v23)
    goto LABEL_23;
  v24 = v23;
  LODWORD(v18->cipher) = 3;
  X509_ALGOR_free(*((X509_ALGOR **)v23 + 2));
  v25 = X509_ALGOR_new();
  *((_QWORD *)v24 + 2) = v25;
  if (!v25
    || (**((_QWORD **)v24 + 2) = OBJ_nid2obj(893),
        v26 = ASN1_TYPE_new(),
        (*(_QWORD *)(*((_QWORD *)v24 + 2) + 8) = v26) == 0)
    || !ASN1_item_pack(v16, &X509_ALGOR_it, (ASN1_OCTET_STRING **)&v26->value))
  {
LABEL_23:
    ERR_put_error(46, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/cms/cms_pwri.c", 207);
    EVP_CIPHER_CTX_free(0);
    if (!v18)
    {
LABEL_32:
      X509_ALGOR_free(v16);
      return 0;
    }
LABEL_24:
    ASN1_item_free((ASN1_VALUE *)v18, &CMS_RecipientInfo_it);
    goto LABEL_32;
  }
  **(_DWORD **)(*((_QWORD *)v24 + 2) + 8) = 16;
  X509_ALGOR_free(v16);
  v27 = PKCS5_pbkdf2_set(a2, 0, 0, -1, -1);
  *((_QWORD *)v24 + 1) = v27;
  if (!v27)
  {
    EVP_CIPHER_CTX_free(0);
    v16 = 0;
    goto LABEL_24;
  }
  CMS_RecipientInfo_set0_password((uint64_t)v18, a5, a6);
  *(_QWORD *)v24 = 0;
  if (!sk_push(*(STACK **)(v13 + 16), (char *)v18))
  {
    v16 = 0;
    goto LABEL_23;
  }
  return v18;
}

EVP_CIPHER_CTX *cms_RecipientInfo_pwri_crypt(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v6;
  uint64_t v7;
  ASN1_STRING *v8;
  const ASN1_OBJECT **v9;
  X509_ALGOR *v10;
  int v11;
  const char *v12;
  const EVP_CIPHER *cipherbyname;
  const EVP_CIPHER *v14;
  EVP_CIPHER_CTX *v15;
  EVP_CIPHER_CTX *v16;
  unint64_t v17;
  int v18;
  unsigned __int8 *v19;
  int v20;
  size_t v21;
  unsigned __int8 *v22;
  uint64_t v23;
  int v24;
  int v25;
  int v27;
  int v28;
  unsigned __int8 *v29;
  unint64_t v30;
  int v31;
  int v32;
  size_t v33;

  v3 = *(_QWORD *)(a2 + 8);
  if (!*(_QWORD *)(v3 + 32))
  {
    v24 = 178;
    v25 = 342;
    goto LABEL_22;
  }
  v4 = *(_QWORD *)(v3 + 16);
  if (!v4 || (v6 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 24), OBJ_obj2nid(*(const ASN1_OBJECT **)v4) != 893))
  {
    v24 = 179;
    v25 = 348;
LABEL_22:
    ERR_put_error(46, 4095, v24, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/cms/cms_pwri.c", v25);
    return 0;
  }
  v7 = *(_QWORD *)(v4 + 8);
  if (!v7
    || *(_DWORD *)v7 != 16
    || (v8 = *(ASN1_STRING **)(v7 + 8)) == 0
    || (v9 = (const ASN1_OBJECT **)ASN1_item_unpack(v8, &X509_ALGOR_it)) == 0)
  {
    v24 = 176;
    v25 = 359;
    goto LABEL_22;
  }
  v10 = (X509_ALGOR *)v9;
  v11 = OBJ_obj2nid(*v9);
  v12 = OBJ_nid2sn(v11);
  cipherbyname = EVP_get_cipherbyname(v12);
  if (!cipherbyname)
  {
    v24 = 148;
    v25 = 365;
    goto LABEL_22;
  }
  v14 = cipherbyname;
  v15 = EVP_CIPHER_CTX_new();
  v16 = v15;
  if (v15)
  {
    if (EVP_CipherInit_ex(v15, v14, 0, 0, 0, a3))
    {
      EVP_CIPHER_CTX_set_padding(v16, 0);
      if (EVP_CIPHER_asn1_to_param(v16, v10->parameter) <= 0)
      {
        v27 = 102;
        v28 = 379;
      }
      else
      {
        if ((EVP_PBE_CipherInit(**(ASN1_OBJECT ***)(v3 + 8), *(const char **)(v3 + 32), *(_DWORD *)(v3 + 40), *(ASN1_TYPE **)(*(_QWORD *)(v3 + 8) + 8), v16, a3) & 0x80000000) == 0)
        {
          v33 = 0;
          if (a3)
          {
            v17 = *(_QWORD *)(v6 + 40);
            v18 = EVP_CIPHER_CTX_block_size(v16);
            v19 = 0;
            if (v17 <= 0xFF)
            {
              v20 = v18;
              v21 = (v17 + v18 + 3) / v18 * v18;
              if (v21 >= 2 * v20)
              {
                v33 = v21;
                v22 = (unsigned __int8 *)malloc_type_malloc(v21, 0x2C9EFED8uLL);
                v19 = v22;
                if (v22)
                {
                  if (kek_wrap_key(v22, &v33, *(_BYTE **)(v6 + 32), *(_QWORD *)(v6 + 40), v16))
                  {
                    v23 = *(_QWORD *)(v3 + 24);
                    *(_QWORD *)(v23 + 8) = v19;
                    *(_DWORD *)v23 = v33;
LABEL_35:
                    EVP_CIPHER_CTX_free(v16);
                    v16 = (EVP_CIPHER_CTX *)1;
                    goto LABEL_31;
                  }
                }
              }
            }
          }
          else
          {
            v29 = (unsigned __int8 *)malloc_type_malloc(**(int **)(v3 + 24), 0x1B8657BFuLL);
            v19 = v29;
            if (v29)
            {
              if (kek_unwrap_key(v29, &v33, *(const unsigned __int8 **)(*(_QWORD *)(v3 + 24) + 8), **(int **)(v3 + 24), v16))
              {
                freezero(*(void **)(v6 + 32), *(_QWORD *)(v6 + 40));
                v30 = v33;
                *(_QWORD *)(v6 + 32) = v19;
                *(_QWORD *)(v6 + 40) = v30;
                goto LABEL_35;
              }
              v31 = 180;
              v32 = 415;
            }
            else
            {
              v31 = 65;
              v32 = 410;
            }
            ERR_put_error(46, 4095, v31, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/cms/cms_pwri.c", v32);
          }
LABEL_30:
          EVP_CIPHER_CTX_free(v16);
          free(v19);
          v16 = 0;
LABEL_31:
          X509_ALGOR_free(v10);
          return v16;
        }
        v27 = 6;
        v28 = 389;
      }
      ERR_put_error(46, 4095, v27, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/cms/cms_pwri.c", v28);
    }
    v19 = 0;
    goto LABEL_30;
  }
  ERR_put_error(46, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/cms/cms_pwri.c", 371);
  return v16;
}

