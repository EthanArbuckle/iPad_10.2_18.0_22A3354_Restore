void sub_2096782BC(uint64_t a1, void *a2)
{
  CFUUIDBytes *v2;
  CFUUIDBytes *v3;

  if (a2 != (void *)MEMORY[0x24BDACFB8])
  {
    v2 = sub_2096791F4(a2, "uuid");
    if (v2)
    {
      v3 = v2;
      CFDictionaryRemoveValue((CFMutableDictionaryRef)qword_253D3BA90, v2);
      CFRelease(v3);
    }
  }
}

uint64_t krb5_addlog_dest(_krb5_context *a1, const char **a2, char *a3)
{
  char *v3;
  int v6;
  char *v7;
  uint64_t v8;
  const char *v9;
  int v11;
  char *v12;
  char *v13;
  int v14;
  int v15;
  FILE *v16;
  uint64_t v17;
  int v18;
  int v19;
  int v20;
  int v21;
  char *v22;
  int v24;
  int v25;
  NSObject *v26;
  NSObject *v27;
  char **v28;
  const char *v29;
  const char *v30;
  int v31;
  char **v32;
  const char *v33;
  const char *v34;
  int v35;
  void *v36;
  void *v37;
  NSObject *v38;
  char **v39;
  const char *v40;
  const char *v41;
  int v42;
  const char *v43;
  __asl_object_s *v44;
  _krb5_context *v45;
  uint64_t v46;
  int v47;
  int v48;
  os_log_t v49;
  int v50;
  int v51;
  int *v52;
  uint64_t v53;
  char *v54;
  char *v55;
  char v56;
  int v57;
  int v58;
  char facility[16];
  __int128 v60;
  __int128 v61;
  __int128 v62;
  __int128 v63;
  __int128 v64;
  __int128 v65;
  __int128 v66;
  __int128 v67;
  __int128 v68;
  __int128 v69;
  __int128 v70;
  __int128 v71;
  __int128 v72;
  __int128 v73;
  __int128 v74;
  uint64_t v75;

  v3 = a3;
  v75 = *MEMORY[0x24BDAC8D0];
  v57 = -1;
  v58 = 0;
  v56 = 0;
  v55 = a3;
  v6 = sscanf(a3, "%d%c%d/", &v58, &v56, &v57);
  if (v6 == 2 && v56 == 47)
  {
    if (v58 < 0)
    {
      v57 = -v58;
      v58 = 0;
    }
    else
    {
      v57 = v58;
    }
  }
  else if (!v6)
  {
    goto LABEL_10;
  }
  v7 = strchr(v3, 47);
  v55 = v7;
  if (!v7)
  {
    v8 = 2314790656;
    v54 = v3;
    v9 = "failed to parse \"%s\"";
    goto LABEL_19;
  }
  v3 = v7 + 1;
  v55 = v7 + 1;
LABEL_10:
  if (!strcmp(v3, "STDERR"))
    return sub_20969CD88(a1, (uint64_t)a2, v58, v57, 0, 0, *MEMORY[0x24BDAC8D8], 1, 0);
  if (!strcmp(v3, "CONSOLE"))
    return sub_20969CD88(a1, (uint64_t)a2, v58, v57, "/dev/console", (uint64_t)"w", 0, 0, 0);
  if (!strncmp(v3, "FILE", 4uLL))
  {
    v11 = v3[4];
    if (v11 == 61 || v11 == 58)
    {
      v12 = strdup(v3 + 5);
      if (v12)
      {
        v13 = v12;
        if (v11 == 61)
        {
          v14 = open(v12, 1545, 438);
          if (v14 < 0)
          {
            v52 = __error();
            v8 = *v52;
            strerror(*v52);
            krb5_set_error_message(a1, v8, "open(%s) logile: %s");
          }
          else
          {
            v15 = v14;
            sub_2096B7FDC(v14);
            v16 = fdopen(v15, "a");
            if (v16)
            {
              v17 = (uint64_t)v16;
              v18 = 1;
              return sub_20969CD88(a1, (uint64_t)a2, v58, v57, v13, (uint64_t)"a", v17, v18, 1);
            }
            v8 = *__error();
            close(v15);
            strerror(v8);
            krb5_set_error_message(a1, v8, "fdopen(%s) logfile: %s");
          }
          free(v13);
          return v8;
        }
        v17 = 0;
        v18 = 0;
        return sub_20969CD88(a1, (uint64_t)a2, v58, v57, v13, (uint64_t)"a", v17, v18, 1);
      }
LABEL_77:
      v8 = 12;
      krb5_set_error_message(a1, 12, "malloc: out of memory", v53);
      return v8;
    }
  }
  if (!strncmp(v3, "DEVICE", 6uLL))
  {
    v19 = v3[6];
    if (v19 == 61 || v19 == 58)
    {
      v21 = v57;
      v20 = v58;
      v22 = strdup(v3 + 7);
      return sub_20969CD88(a1, (uint64_t)a2, v20, v21, v22, (uint64_t)"w", 0, 0, 1);
    }
  }
  if (!strncmp(v3, "SYSLOG", 6uLL) && (v3[6] == 58 || !v3[6]))
  {
    v73 = 0u;
    v74 = 0u;
    v71 = 0u;
    v72 = 0u;
    v69 = 0u;
    v70 = 0u;
    v67 = 0u;
    v68 = 0u;
    v66 = 0u;
    v64 = 0u;
    v65 = 0u;
    v62 = 0u;
    v63 = 0u;
    v60 = 0u;
    v61 = 0u;
    *(_OWORD *)facility = 0u;
    v55 = v3 + 6;
    if (v3[6])
      v55 = v3 + 7;
    if (rk_strsep_copy((const char **)&v55, ":", &v67, 0x80uLL) != -1)
      rk_strsep_copy((const char **)&v55, ":", facility, 0x80uLL);
    if (!(_BYTE)v67)
      __strlcpy_chk();
    if (!facility[0])
      __strlcpy_chk();
    v25 = v57;
    v24 = v58;
    v26 = malloc_type_malloc(4uLL, 0x100004052888210uLL);
    if (!v26)
      goto LABEL_77;
    v27 = v26;
    v28 = &off_24C1F2480;
    v29 = "EMERG";
    do
    {
      if (!strcasecmp(v29, (const char *)&v67))
        break;
      v30 = v28[2];
      v28 += 2;
      v29 = v30;
    }
    while (v30);
    if (*((_DWORD *)v28 + 2) == -1)
      v31 = 3;
    else
      v31 = *((_DWORD *)v28 + 2);
    LODWORD(v27->isa) = v31;
    v32 = &off_24C1F2480;
    v33 = "EMERG";
    do
    {
      if (!strcasecmp(v33, facility))
        break;
      v34 = v32[2];
      v32 += 2;
      v33 = v34;
    }
    while (v34);
    if (*((_DWORD *)v32 + 2) == -1)
      v35 = 32;
    else
      v35 = *((_DWORD *)v32 + 2);
    LODWORD(v27->isa) = v35 | v31;
    openlog(*a2, 9, v35);
    v36 = sub_20969D41C;
    v37 = sub_20969D448;
    goto LABEL_76;
  }
  if (!strncmp(v3, "ASL", 3uLL) && (v3[3] == 58 || !v3[3]))
  {
    v73 = 0u;
    v74 = 0u;
    v71 = 0u;
    v72 = 0u;
    v69 = 0u;
    v70 = 0u;
    v67 = 0u;
    v68 = 0u;
    v66 = 0u;
    v64 = 0u;
    v65 = 0u;
    v62 = 0u;
    v63 = 0u;
    v60 = 0u;
    v61 = 0u;
    *(_OWORD *)facility = 0u;
    v55 = v3 + 3;
    if (v3[3])
      v55 = v3 + 4;
    if (rk_strsep_copy((const char **)&v55, ":", &v67, 0x80uLL) != -1)
      rk_strsep_copy((const char **)&v55, ":", facility, 0x80uLL);
    if (!(_BYTE)v67)
      __strlcpy_chk();
    if (!facility[0])
      __strlcpy_chk();
    v25 = v57;
    v24 = v58;
    v38 = malloc_type_malloc(0x18uLL, 0x1020040EDCEB4C7uLL);
    if (!v38)
      goto LABEL_77;
    v27 = v38;
    v39 = &off_24C1F2650;
    v40 = "EMERG";
    do
    {
      if (!strcasecmp(v40, (const char *)&v67))
        break;
      v41 = v39[2];
      v39 += 2;
      v40 = v41;
    }
    while (v41);
    v42 = *((_DWORD *)v39 + 2);
    if (v42 == -1)
      v42 = 3;
    LODWORD(v27[2].isa) = v42;
    v43 = getprogname();
    v27->isa = asl_open(v43, facility, 0);
    v44 = asl_new(0);
    v27[1].isa = v44;
    asl_set(v44, "org.h5l.asl", "krb5");
    v36 = sub_20969D45C;
    v37 = sub_20969D490;
LABEL_76:
    v45 = a1;
    v46 = (uint64_t)a2;
    v47 = v24;
    v48 = v25;
    v49 = v27;
    return krb5_addlog_func(v45, v46, v47, v48, (uint64_t)v36, (uint64_t)v37, (uint64_t)v49);
  }
  if (!strncmp(v3, "OSLOG", 5uLL) && (v3[5] == 58 || !v3[5]))
  {
    v73 = 0u;
    v74 = 0u;
    v71 = 0u;
    v72 = 0u;
    v69 = 0u;
    v70 = 0u;
    v67 = 0u;
    v68 = 0u;
    v66 = 0u;
    v64 = 0u;
    v65 = 0u;
    v62 = 0u;
    v63 = 0u;
    v60 = 0u;
    v61 = 0u;
    *(_OWORD *)facility = 0u;
    v55 = v3 + 5;
    if (v3[5])
      v55 = v3 + 6;
    if (rk_strsep_copy((const char **)&v55, ":", &v67, 0x80uLL) != -1)
      rk_strsep_copy((const char **)&v55, ":", facility, 0x80uLL);
    if (!(_BYTE)v67)
      __strlcpy_chk();
    if (!facility[0])
      __strlcpy_chk();
    v51 = v57;
    v50 = v58;
    v49 = os_log_create("com.apple.Heimdal", facility);
    if (v67 ^ 0x75626564 | WORD2(v67) ^ 0x67)
      v36 = sub_20969D4C0;
    else
      v36 = sub_20969D558;
    v37 = j__os_release;
    v45 = a1;
    v46 = (uint64_t)a2;
    v47 = v50;
    v48 = v51;
    return krb5_addlog_func(v45, v46, v47, v48, (uint64_t)v36, (uint64_t)v37, (uint64_t)v49);
  }
  v8 = 2314790656;
  v54 = v3;
  v9 = "unknown log type: %s";
LABEL_19:
  krb5_set_error_message(a1, -1980176640, v9, v54);
  return v8;
}

CFMutableDictionaryRef heim_dict_create()
{
  return CFDictionaryCreateMutable(0, 0, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
}

_QWORD *initialize_asn1_error_table_r(_QWORD *a1)
{
  return initialize_error_table_r(a1, (uint64_t)off_2545A5480, 21, 1859794432);
}

CFMutableArrayRef HeimCredCopyQuery()
{
  uint64_t v0;
  void *v1;
  CFMutableArrayRef Mutable;
  xpc_object_t value;
  void *v4;
  _QWORD applier[5];

  if (qword_253D3BA38 != -1)
    dispatch_once(&qword_253D3BA38, &unk_24C1F2208);
  v0 = sub_20967A0EC("query");
  if (!v0)
    return 0;
  v1 = (void *)v0;
  Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x24BDBD690]);
  if (Mutable)
  {
    value = xpc_dictionary_get_value(v1, "items");
    if (value)
    {
      v4 = value;
      if (MEMORY[0x20BD129CC]() == MEMORY[0x24BDACF78])
      {
        applier[0] = MEMORY[0x24BDAC760];
        applier[1] = 0x40000000;
        applier[2] = sub_20967A1A0;
        applier[3] = &unk_24C1F2158;
        applier[4] = Mutable;
        xpc_array_apply(v4, applier);
      }
    }
  }
  xpc_release(v1);
  return Mutable;
}

void krb5_clear_error_message(krb5_context a1)
{
  void *v2;

  pthread_mutex_lock(*((pthread_mutex_t **)a1 + 41));
  v2 = (void *)*((_QWORD *)a1 + 35);
  if (v2)
    free(v2);
  *((_DWORD *)a1 + 72) = 0;
  *((_QWORD *)a1 + 35) = 0;
  pthread_mutex_unlock(*((pthread_mutex_t **)a1 + 41));
}

void krb5_load_plugins(_krb5_context *a1, char *cStr, char **a3)
{
  CFStringRef v5;
  const __CFDictionary *v6;
  const __CFDictionary *v7;
  CFMutableDictionaryRef v8;
  char *v9;
  char *v10;
  size_t v11;
  char *v12;
  DIR *v13;
  DIR *v14;
  dirent *v15;
  int v16;
  char *d_name;
  size_t v18;
  int v19;
  char *v20;
  int v21;
  char *v22;
  CFStringRef v23;
  CFStringRef v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  _QWORD *v30;
  void *v31;
  char *v32;
  char *__path;
  char *__s;
  int v35;

  v5 = heim_string_create(cStr);
  pthread_mutex_lock((pthread_mutex_t *)&unk_253D3A5E8);
  v6 = (const __CFDictionary *)qword_253D3BA60;
  if (!qword_253D3BA60)
  {
    v6 = heim_dict_create();
    qword_253D3BA60 = (uint64_t)v6;
    if (!v6)
    {
      pthread_mutex_unlock((pthread_mutex_t *)&unk_253D3A5E8);
      return;
    }
  }
  v7 = (const __CFDictionary *)heim_dict_copy_value(v6, v5);
  if (!v7)
  {
    v8 = heim_dict_create();
    if (!v8)
    {
      pthread_mutex_unlock((pthread_mutex_t *)&unk_253D3A5E8);
      heim_release(v5);
      return;
    }
    v7 = v8;
    heim_dict_set_value((__CFDictionary *)qword_253D3BA60, v5, v8);
  }
  heim_release(v5);
  v35 = 0;
  if (!csops())
  {
    v9 = *a3;
    if (*a3)
    {
      while (1)
      {
        __s = 0;
        if (!_krb5_expand_default_cc_name_0(a1, v9, (void **)&__s))
        {
          v10 = __s;
          v11 = strlen(__s);
          if (v11)
          {
            v12 = __s - 1;
            do
            {
              if (v12[v11] != 47)
                break;
              v12[v11--] = 0;
            }
            while (v11);
            v10 = __s;
          }
          v13 = opendir(v10);
          if (v13)
            break;
        }
LABEL_46:
        if (__s)
          free(__s);
        v32 = a3[1];
        ++a3;
        v9 = v32;
        if (!v32)
          goto LABEL_49;
      }
      v14 = v13;
      sub_2096791E0(v13);
      while (1)
      {
        do
        {
          v15 = readdir(v14);
          if (!v15)
          {
LABEL_45:
            closedir(v14);
            goto LABEL_46;
          }
          d_name = v15->d_name;
          v16 = v15->d_name[0];
          __path = 0;
        }
        while (v16 == 46 && (!v15->d_name[1] || v15->d_name[1] == 46 && !v15->d_name[2]));
        v18 = strlen(v15->d_name);
        if (v18 < 8)
          break;
        v19 = v18 - 7;
        if (strcmp(&d_name[v18 - 7], ".bundle"))
          break;
        v21 = asprintf(&__path, "%s/%s/%.*s", __s, d_name, v19, d_name);
        if (!v21)
        {
          v20 = __path;
          goto LABEL_24;
        }
LABEL_28:
        v22 = __path;
        if (!__path)
          goto LABEL_34;
        if ((v35 & 0x2810) == 0x800)
        {
          if (sub_2096A577C((uint64_t)a1, (uint64_t)__path))
          {
            v22 = __path;
            goto LABEL_32;
          }
        }
        else
        {
LABEL_32:
          if (v21 < 0 || !v22)
            goto LABEL_34;
LABEL_35:
          if (v21 < 0 || !v22)
            goto LABEL_45;
          v23 = heim_string_create(d_name);
          if (!v23)
          {
            free(__path);
            goto LABEL_45;
          }
          v24 = v23;
          v30 = heim_dict_copy_value(v7, v23);
          if (!v30)
          {
            v30 = (_QWORD *)heim_uniq_alloc(0x38uLL, (uint64_t)"krb5-plugin", (uint64_t)sub_2096A593C, v25, v26, v27, v28, v29);
            if (v30)
            {
              v31 = dlopen(__path, 5);
              v30[5] = v31;
              if (v31)
              {
                v30[4] = heim_retain(v24);
                v30[6] = heim_dict_create();
                heim_dict_set_value(v7, v24, v30);
              }
            }
          }
          heim_release(v24);
          heim_release(v30);
          free(__path);
        }
      }
      v20 = 0;
LABEL_24:
      if (access(v20, 1))
      {
        __error();
        free(__path);
        __path = 0;
LABEL_34:
        v21 = asprintf(&__path, "%s/%s", __s, d_name);
        v22 = __path;
        goto LABEL_35;
      }
      v21 = 0;
      goto LABEL_28;
    }
LABEL_49:
    heim_release(v7);
    pthread_mutex_unlock((pthread_mutex_t *)&unk_253D3A5E8);
  }
}

void hx509_context_free(uint64_t *a1)
{
  uint64_t v2;
  void *v3;
  uint64_t v4;

  hx509_certs_free((const void **)(*a1 + 48));
  hx509_clear_error_string(*a1);
  v2 = *a1;
  v3 = *(void **)*a1;
  if (v3)
  {
    free(v3);
    *(_QWORD *)*a1 = 0;
    v2 = *a1;
  }
  *(_DWORD *)(v2 + 8) = 0;
  sub_2096BCE90(*(_QWORD **)(v2 + 32));
  v4 = *a1;
  *(_QWORD *)(v4 + 48) = 0;
  *(_OWORD *)(v4 + 16) = 0u;
  *(_OWORD *)(v4 + 32) = 0u;
  *(_OWORD *)v4 = 0u;
  free((void *)*a1);
  *a1 = 0;
}

_QWORD *sub_209679060(uint64_t a1, char **a2)
{
  _QWORD *result;
  uint64_t v5;

  result = sub_2096C85A4(a1, *a2);
  if (!result)
  {
    result = malloc_type_realloc(*(void **)a1, 8 * *(int *)(a1 + 8) + 8, 0x2004093837F09uLL);
    if (result)
    {
      v5 = *(int *)(a1 + 8);
      result[v5] = a2;
      *(_QWORD *)a1 = result;
      *(_DWORD *)(a1 + 8) = v5 + 1;
    }
  }
  return result;
}

uint64_t krb5_prepend_config_files(const char *a1, char **a2, void **a3)
{
  uint64_t v5;
  size_t v6;
  char *v7;
  char *v8;
  uint64_t v9;
  char *v10;
  char **v11;
  uint64_t v12;
  char *v13;
  unsigned int v15;
  void *v16;
  const char *v17;
  const char *v18;

  v16 = 0;
  v17 = a1;
  v15 = 0;
  while (1)
  {
    v18 = v17;
    v5 = rk_strsep_copy(&v18, ":", 0, 0);
    if (v5 == -1)
      break;
    v6 = v5 + 1;
    v7 = (char *)malloc_type_malloc(v5 + 1, 0x76F22E08uLL);
    if (!v7)
    {
      krb5_free_config_files((void **)v16);
      return 12;
    }
    v8 = v7;
    rk_strsep_copy(&v17, ":", v7, v6);
    v9 = sub_20968231C(&v16, &v15, v8);
    free(v8);
    if ((_DWORD)v9)
      goto LABEL_5;
  }
  if (a2)
  {
    v10 = *a2;
    if (*a2)
    {
      v11 = a2 + 1;
      while (1)
      {
        v12 = sub_20968231C(&v16, &v15, v10);
        if ((_DWORD)v12)
          break;
        v13 = *v11++;
        v10 = v13;
        if (!v13)
          goto LABEL_11;
      }
      v9 = v12;
LABEL_5:
      krb5_free_config_files((void **)v16);
      return v9;
    }
  }
LABEL_11:
  v9 = 0;
  *a3 = v16;
  return v9;
}

uint64_t sub_2096791E0(DIR *a1)
{
  int v1;

  v1 = dirfd(a1);
  return sub_2096B7FDC(v1);
}

CFUUIDBytes *sub_2096791F4(void *a1, const char *a2)
{
  CFUUIDBytes *result;

  result = (CFUUIDBytes *)xpc_dictionary_get_uuid(a1, a2);
  if (result)
    return (CFUUIDBytes *)CFUUIDCreateFromUUIDBytes(0, *result);
  return result;
}

const void *sub_20967921C(void *a1, const char *a2, uint64_t a3)
{
  const void *v4;
  const void *v5;

  if (!xpc_dictionary_get_value(a1, a2))
    return 0;
  v4 = (const void *)_CFXPCCreateCFObjectFromXPCObject();
  v5 = v4;
  if (v4 && CFGetTypeID(v4) != a3)
  {
    CFRelease(v5);
    return 0;
  }
  return v5;
}

void sub_20967926C(void *a1, const char *a2, CFUUIDRef uuid)
{
  CFUUIDBytes uuida;
  uint64_t v6;

  v6 = *MEMORY[0x24BDAC8D0];
  uuida = CFUUIDGetUUIDBytes(uuid);
  xpc_dictionary_set_uuid(a1, a2, &uuida.byte0);
}

void sub_2096792DC()
{
  if (qword_253D3BA40 != -1)
    dispatch_once(&qword_253D3BA40, &unk_24C1F0050);
}

CFMutableDictionaryRef sub_209679304()
{
  CFMutableDictionaryRef result;

  qword_253D3BA88 = _CFRuntimeRegisterClass();
  qword_253D3BA80 = (uint64_t)dispatch_queue_create("HeimCred", 0);
  result = CFDictionaryCreateMutable(0, 0, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
  qword_253D3BA90 = (uint64_t)result;
  return result;
}

void sub_209679368(uint64_t a1)
{
  const void *v2;
  const void *v3;

  v2 = *(const void **)(a1 + 16);
  if (v2)
  {
    CFRelease(v2);
    *(_QWORD *)(a1 + 16) = 0;
  }
  v3 = *(const void **)(a1 + 24);
  if (v3)
  {
    CFRelease(v3);
    *(_QWORD *)(a1 + 24) = 0;
  }
}

const __CFString *sub_2096793A4()
{
  return CFSTR("format");
}

CFStringRef sub_2096793B0(uint64_t a1)
{
  const __CFDictionary *v2;
  const void *Value;
  const void *v4;
  const void *v5;
  const __CFBoolean *v6;
  const __CFString *v7;
  const __CFString *v8;
  const __CFString *v9;
  const char *v10;
  const __CFString *v11;
  const __CFString *v12;
  const __CFString *v13;
  const __CFString *v14;
  const __CFString *v15;

  v2 = *(const __CFDictionary **)(a1 + 24);
  if (!v2)
    return CFStringCreateWithFormat(0, 0, CFSTR("HeimCred<%@>"), *(_QWORD *)(a1 + 16));
  Value = CFDictionaryGetValue(v2, CFSTR("kHEIMAttrClientName"));
  v4 = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 24), CFSTR("kHEIMAttrServerName"));
  v5 = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 24), CFSTR("kHEIMAttrParentCredential"));
  v6 = (const __CFBoolean *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 24), CFSTR("kHEIMAttrLeadCredential"));
  v7 = (const __CFString *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 24), CFSTR("kHEIMAttrAltDSID"));
  v8 = (const __CFString *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 24), CFSTR("kHEIMAttrUserID"));
  v9 = (const __CFString *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 24), CFSTR("kHEIMAttrASID"));
  v10 = "no";
  if (v6 && CFBooleanGetValue(v6))
    v10 = "yes";
  v11 = (const __CFString *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 24), CFSTR("kHEIMAttrBundleIdentifierACL"));
  v12 = &stru_24C1F9C88;
  if (v11)
    v13 = v11;
  else
    v13 = &stru_24C1F9C88;
  if (v7)
    v14 = v7;
  else
    v14 = &stru_24C1F9C88;
  if (v8)
    v15 = v8;
  else
    v15 = &stru_24C1F9C88;
  if (v9)
    v12 = v9;
  return CFStringCreateWithFormat(0, 0, CFSTR("HeimCred<%@ group: %@ parent: %@ client: %@ server: %@ lead: %s ACL: %@, altDSID: %@, Uid: %@, asid: %@>"), *(_QWORD *)(a1 + 16), v6, v5, Value, v4, v10, v13, v14, v15, v12);
}

uint64_t sub_209679520(const void *a1)
{
  uint64_t Instance;

  Instance = _CFRuntimeCreateInstance();
  if (Instance)
  {
    CFRetain(a1);
    *(_QWORD *)(Instance + 16) = a1;
  }
  return Instance;
}

void HeimCredSetImpersonateBundle(const __CFString *a1)
{
  if (qword_253D3BA78)
  {
    free((void *)qword_253D3BA78);
    qword_253D3BA78 = 0;
  }
  if (a1)
    qword_253D3BA78 = (uint64_t)sub_2096795AC(a1);
}

char *sub_2096795AC(const __CFString *a1)
{
  const char *CStringPtr;
  CFIndex Length;
  CFIndex v5;
  void *v6;

  CStringPtr = CFStringGetCStringPtr(a1, 0x8000100u);
  if (CStringPtr)
    return strdup(CStringPtr);
  Length = CFStringGetLength(a1);
  v5 = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u) + 1;
  v6 = malloc_type_malloc(v5, 0xBDB9818AuLL);
  if (v6)
  {
    if (!CFStringGetCString(a1, (char *)v6, v5, 0x8000100u))
    {
      free(v6);
      return 0;
    }
  }
  return (char *)v6;
}

uint64_t HeimCredGetImpersonateBundle()
{
  return qword_253D3BA78;
}

uint64_t HeimCredSetImpersonateAuditToken(uint64_t result)
{
  qword_2545A7980 = result;
  return result;
}

uint64_t HeimCredGetImpersonateAuditToken()
{
  return qword_2545A7980;
}

uint64_t HeimCredCreate(uint64_t a1, CFErrorRef *a2)
{
  uint64_t v3;
  void *v4;
  xpc_object_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  void *v13;
  xpc_object_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  const __CFString *v21;
  CFErrorRef *v22;
  unsigned int v23;
  CFTypeID TypeID;
  const __CFDictionary *v26;
  const __CFDictionary *v27;
  const void *Value;
  uint64_t v29;
  char v30;
  _QWORD block[5];

  if (a2)
    *a2 = 0;
  if (qword_253D3BA38 != -1)
    dispatch_once(&qword_253D3BA38, &unk_24C1F2208);
  v3 = _CFXPCCreateXPCObjectFromCFObject();
  if (!v3)
    return 0;
  v4 = (void *)v3;
  v5 = xpc_dictionary_create(0, 0, 0);
  if (!v5)
    heim_abort("xpc_dictionary_create:request != NULL", v6, v7, v8, v9, v10, v11, v12, v30);
  v13 = v5;
  xpc_dictionary_set_string(v5, "command", "create");
  xpc_dictionary_set_value(v13, "attributes", v4);
  xpc_release(v4);
  if (qword_253D3BA78)
    xpc_dictionary_set_string(v13, "impersonate", (const char *)qword_253D3BA78);
  v14 = xpc_connection_send_message_with_reply_sync((xpc_connection_t)qword_253D3BA98, v13);
  xpc_release(v13);
  if (!v14)
  {
    v21 = CFSTR("Server didn't return any data");
    v22 = a2;
    v23 = 564608;
LABEL_16:
    sub_209679890(v22, v23, v21, v15, v16, v17, v18, v19, v30);
    return 0;
  }
  if (MEMORY[0x20BD129CC](v14) == MEMORY[0x24BDACFB8])
  {
    v23 = 564609;
    v30 = (char)v14;
    v21 = CFSTR("Server returned an error: %@");
    v22 = a2;
    goto LABEL_16;
  }
  if (MEMORY[0x20BD129CC](v14) == MEMORY[0x24BDACFA0])
  {
    TypeID = CFDictionaryGetTypeID();
    v26 = (const __CFDictionary *)sub_20967921C(v14, "attributes", TypeID);
    if (v26)
    {
      v27 = v26;
      Value = CFDictionaryGetValue(v26, CFSTR("kHEIMAttrUUID"));
      if (Value)
      {
        v29 = sub_209679520(Value);
        v20 = v29;
        if (v29)
        {
          *(_QWORD *)(v29 + 24) = v27;
          block[0] = MEMORY[0x24BDAC760];
          block[1] = 0x40000000;
          block[2] = sub_20967B140;
          block[3] = &unk_24C1F2268;
          block[4] = v29;
          dispatch_sync((dispatch_queue_t)qword_253D3BA80, block);
        }
        else
        {
          CFRelease(v27);
        }
        goto LABEL_13;
      }
      CFRelease(v27);
    }
  }
  v20 = 0;
LABEL_13:
  xpc_release(v14);
  return v20;
}

void sub_209679890(CFErrorRef *a1, unsigned int a2, const __CFString *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  void *userInfoValues[2];
  void *userInfoKeys[3];

  userInfoKeys[2] = *(void **)MEMORY[0x24BDAC8D0];
  userInfoKeys[0] = *(void **)MEMORY[0x24BDBD378];
  userInfoKeys[1] = CFSTR("CommonErrorCode");
  userInfoValues[1] = *(void **)MEMORY[0x24BDBD270];
  if (a1)
  {
    userInfoValues[0] = (void *)CFStringCreateWithFormatAndArguments(0, 0, a3, &a9);
    *a1 = CFErrorCreateWithUserInfoKeysAndValues(0, CFSTR("org.h5l.HeimdalCredential"), a2, (const void *const *)userInfoKeys, (const void *const *)userInfoValues, 2);
    if (userInfoValues[0])
      CFRelease(userInfoValues[0]);
  }
}

uint64_t HeimCredGetUUID(uint64_t a1)
{
  return *(_QWORD *)(a1 + 16);
}

uint64_t HeimCredGetAttributes(uint64_t a1)
{
  return *(_QWORD *)(a1 + 24);
}

uint64_t HeimCredCopyFromUUID(uint64_t a1)
{
  uint64_t v2;
  _QWORD v4[6];
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;

  v5 = 0;
  v6 = &v5;
  v7 = 0x2000000000;
  v8 = 0;
  if (qword_253D3BA38 != -1)
    dispatch_once(&qword_253D3BA38, &unk_24C1F2208);
  v4[0] = MEMORY[0x24BDAC760];
  v4[1] = 0x40000000;
  v4[2] = sub_209679A30;
  v4[3] = &unk_24C1F20C8;
  v4[4] = &v5;
  v4[5] = a1;
  dispatch_sync((dispatch_queue_t)qword_253D3BA80, v4);
  v2 = v6[3];
  _Block_object_dispose(&v5, 8);
  return v2;
}

void sub_209679A30(uint64_t a1)
{
  const void *v2;

  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = CFDictionaryGetValue((CFDictionaryRef)qword_253D3BA90, *(const void **)(a1 + 40));
  v2 = *(const void **)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  if (v2)
  {
    CFRetain(v2);
  }
  else
  {
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = sub_209679520(*(const void **)(a1 + 40));
    CFDictionarySetValue((CFMutableDictionaryRef)qword_253D3BA90, *(const void **)(a1 + 40), *(const void **)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24));
  }
}

uint64_t HeimCredSetAttribute(uint64_t a1, void *a2, void *a3, CFErrorRef *a4)
{
  CFDictionaryRef v6;
  CFDictionaryRef v7;
  uint64_t v8;
  void *values;
  void *keys[2];

  keys[1] = *(void **)MEMORY[0x24BDAC8D0];
  values = a3;
  keys[0] = a2;
  v6 = CFDictionaryCreate(0, (const void **)keys, (const void **)&values, 1, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
  if (!v6)
    return 0;
  v7 = v6;
  v8 = HeimCredSetAttributes(a1, (uint64_t)v6, a4);
  CFRelease(v7);
  return v8;
}

uint64_t HeimCredSetAttributes(uint64_t a1, uint64_t a2, CFErrorRef *a3)
{
  uint64_t result;
  void *v6;
  xpc_object_t v7;
  xpc_object_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  _QWORD v14[6];

  if (a3)
    *a3 = 0;
  if (qword_253D3BA38 == -1)
  {
    if (!a1)
      return 0;
  }
  else
  {
    dispatch_once(&qword_253D3BA38, &unk_24C1F2208);
    if (!a1)
      return 0;
  }
  result = _CFXPCCreateXPCObjectFromCFObject();
  if (!result)
    return result;
  v6 = (void *)result;
  v7 = xpc_dictionary_create(0, 0, 0);
  xpc_dictionary_set_string(v7, "command", "setattributes");
  sub_20967926C(v7, "uuid", *(CFUUIDRef *)(a1 + 16));
  xpc_dictionary_set_value(v7, "attributes", v6);
  xpc_release(v6);
  if (qword_253D3BA78)
    xpc_dictionary_set_string(v7, "impersonate", (const char *)qword_253D3BA78);
  v8 = xpc_connection_send_message_with_reply_sync((xpc_connection_t)qword_253D3BA98, v7);
  xpc_release(v7);
  if (v8)
  {
    if (MEMORY[0x20BD129CC](v8) != MEMORY[0x24BDACFB8])
    {
      v14[0] = MEMORY[0x24BDAC760];
      v14[1] = 0x40000000;
      v14[2] = sub_209679CFC;
      v14[3] = &unk_24C1F20E8;
      v14[4] = a1;
      v14[5] = v8;
      dispatch_sync((dispatch_queue_t)qword_253D3BA80, v14);
      xpc_release(v8);
      return 1;
    }
  }
  else
  {
    sub_209679890(a3, 0x89D80u, CFSTR("Server didn't return any data"), v9, v10, v11, v12, v13, v14[0]);
  }
  return 0;
}

const void *sub_209679CFC(uint64_t a1)
{
  const void *v2;
  void *v3;
  CFTypeID TypeID;
  const void *result;

  v2 = *(const void **)(*(_QWORD *)(a1 + 32) + 24);
  if (v2)
  {
    CFRelease(v2);
    *(_QWORD *)(*(_QWORD *)(a1 + 32) + 24) = 0;
  }
  v3 = *(void **)(a1 + 40);
  TypeID = CFDictionaryGetTypeID();
  result = sub_20967921C(v3, "attributes", TypeID);
  *(_QWORD *)(*(_QWORD *)(a1 + 32) + 24) = result;
  return result;
}

const void *HeimCredCopyAttribute(uint64_t a1, const void *a2)
{
  uint64_t v4;
  const __CFDictionary *v5;
  int v6;
  const void *v7;
  const void *Value;
  const void *v9;
  const void *v10;
  _QWORD v12[6];
  uint64_t v13;
  uint64_t *v14;
  uint64_t v15;
  uint64_t v16;

  v13 = 0;
  v14 = &v13;
  v15 = 0x2000000000;
  v16 = 0;
  v12[0] = MEMORY[0x24BDAC760];
  v12[1] = 0x40000000;
  v12[2] = sub_209679E6C;
  v12[3] = &unk_24C1F2110;
  v12[4] = &v13;
  v12[5] = a1;
  dispatch_sync((dispatch_queue_t)qword_253D3BA80, v12);
  v5 = (const __CFDictionary *)v14[3];
  if (v5)
  {
    v6 = CFDictionaryContainsKey(v5, a2);
    v7 = (const void *)v14[3];
    if (v6)
      goto LABEL_6;
    if (v7)
    {
      CFRelease(v7);
      v14[3] = 0;
    }
  }
  v7 = (const void *)HeimCredCopyAttributes(a1, v4, 0);
  v14[3] = (uint64_t)v7;
  if (!v7)
  {
    v9 = 0;
    goto LABEL_11;
  }
LABEL_6:
  Value = CFDictionaryGetValue((CFDictionaryRef)v7, a2);
  v9 = Value;
  if (Value)
    CFRetain(Value);
  v10 = (const void *)v14[3];
  if (v10)
  {
    CFRelease(v10);
    v14[3] = 0;
  }
LABEL_11:
  _Block_object_dispose(&v13, 8);
  return v9;
}

CFTypeRef sub_209679E6C(uint64_t a1)
{
  CFTypeRef result;
  uint64_t v3;

  result = *(CFTypeRef *)(*(_QWORD *)(a1 + 40) + 24);
  if (result)
  {
    result = CFRetain(result);
    v3 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 24);
  }
  else
  {
    v3 = 0;
  }
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = v3;
  return result;
}

uint64_t HeimCredCopyAttributes(uint64_t a1, uint64_t a2, CFErrorRef *a3)
{
  xpc_object_t v5;
  xpc_object_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  const __CFString *v13;
  CFErrorRef *v14;
  unsigned int v15;
  char v17;
  _QWORD block[7];
  uint64_t v19;
  uint64_t *v20;
  uint64_t v21;
  uint64_t v22;

  v19 = 0;
  v20 = &v19;
  v21 = 0x2000000000;
  v22 = 0;
  if (a3)
    *a3 = 0;
  if (qword_253D3BA38 != -1)
    dispatch_once(&qword_253D3BA38, &unk_24C1F2208);
  v5 = xpc_dictionary_create(0, 0, 0);
  xpc_dictionary_set_string(v5, "command", "fetch");
  sub_20967926C(v5, "uuid", *(CFUUIDRef *)(a1 + 16));
  if (qword_253D3BA78)
    xpc_dictionary_set_string(v5, "impersonate", (const char *)qword_253D3BA78);
  v6 = xpc_connection_send_message_with_reply_sync((xpc_connection_t)qword_253D3BA98, v5);
  xpc_release(v5);
  if (!v6)
  {
    v13 = CFSTR("Server didn't return any data");
    v14 = a3;
    v15 = 564608;
LABEL_12:
    sub_209679890(v14, v15, v13, v7, v8, v9, v10, v11, v17);
    v12 = 0;
    goto LABEL_13;
  }
  if (MEMORY[0x20BD129CC](v6) == MEMORY[0x24BDACFB8])
  {
    v15 = 564609;
    v17 = (char)v6;
    v13 = CFSTR("Server returned an error: %@");
    v14 = a3;
    goto LABEL_12;
  }
  block[0] = MEMORY[0x24BDAC760];
  block[1] = 0x40000000;
  block[2] = sub_20967A06C;
  block[3] = &unk_24C1F2138;
  block[4] = &v19;
  block[5] = a1;
  block[6] = v6;
  dispatch_sync((dispatch_queue_t)qword_253D3BA80, block);
  xpc_release(v6);
  v12 = v20[3];
LABEL_13:
  _Block_object_dispose(&v19, 8);
  return v12;
}

CFTypeRef sub_20967A06C(_QWORD *a1)
{
  const void *v2;
  void *v3;
  CFTypeID TypeID;
  const void *v5;
  CFTypeRef result;

  v2 = *(const void **)(a1[5] + 24);
  if (v2)
  {
    CFRelease(v2);
    *(_QWORD *)(a1[5] + 24) = 0;
  }
  v3 = (void *)a1[6];
  TypeID = CFDictionaryGetTypeID();
  v5 = sub_20967921C(v3, "attributes", TypeID);
  *(_QWORD *)(a1[5] + 24) = v5;
  *(_QWORD *)(*(_QWORD *)(a1[4] + 8) + 24) = v5;
  result = *(CFTypeRef *)(*(_QWORD *)(a1[4] + 8) + 24);
  if (result)
    return CFRetain(result);
  return result;
}

uint64_t sub_20967A0EC(const char *a1)
{
  uint64_t result;
  void *v3;
  xpc_object_t v4;
  xpc_object_t v5;

  result = _CFXPCCreateXPCObjectFromCFObject();
  if (result)
  {
    v3 = (void *)result;
    v4 = xpc_dictionary_create(0, 0, 0);
    xpc_dictionary_set_string(v4, "command", a1);
    xpc_dictionary_set_value(v4, "query", v3);
    xpc_release(v3);
    if (qword_253D3BA78)
      xpc_dictionary_set_string(v4, "impersonate", (const char *)qword_253D3BA78);
    v5 = xpc_connection_send_message_with_reply_sync((xpc_connection_t)qword_253D3BA98, v4);
    xpc_release(v4);
    return (uint64_t)v5;
  }
  return result;
}

uint64_t sub_20967A1A0(uint64_t a1)
{
  const void *v2;
  const void *v3;
  const void *v4;

  v2 = (const void *)_CFXPCCreateCFObjectFromXPCObject();
  if (v2)
  {
    v3 = v2;
    v4 = (const void *)sub_209679520(v2);
    CFRelease(v3);
    if (v4)
    {
      CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 32), v4);
      CFRelease(v4);
    }
  }
  return 1;
}

BOOL HeimCredDeleteQuery(uint64_t a1, _QWORD *a2)
{
  void *v2;
  void *v3;
  _BOOL8 v4;

  if (a2)
    *a2 = 0;
  if (qword_253D3BA38 != -1)
    dispatch_once(&qword_253D3BA38, &unk_24C1F2208);
  v2 = (void *)sub_20967A0EC("delete");
  if (!v2)
    return 0;
  v3 = v2;
  v4 = xpc_dictionary_get_value(v2, "error") == 0;
  xpc_release(v3);
  return v4;
}

void HeimCredDeleteByUUID(void *a1)
{
  CFDictionaryRef v2;
  void *v3;
  _QWORD v4[5];
  void *values;
  void *keys[2];

  keys[1] = *(void **)MEMORY[0x24BDAC8D0];
  if (qword_253D3BA38 != -1)
    dispatch_once(&qword_253D3BA38, &unk_24C1F2208);
  values = a1;
  keys[0] = CFSTR("kHEIMAttrUUID");
  v2 = CFDictionaryCreate(0, (const void **)keys, (const void **)&values, 1, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
  v3 = (void *)sub_20967A0EC("delete");
  if (v2)
    CFRelease(v2);
  if (v3)
    xpc_release(v3);
  v4[0] = MEMORY[0x24BDAC760];
  v4[1] = 0x40000000;
  v4[2] = sub_20967A3B4;
  v4[3] = &unk_24C1F2178;
  v4[4] = a1;
  dispatch_sync((dispatch_queue_t)qword_253D3BA80, v4);
}

void sub_20967A3B4(uint64_t a1)
{
  CFDictionaryRemoveValue((CFMutableDictionaryRef)qword_253D3BA90, *(const void **)(a1 + 32));
}

void HeimCredDelete(uint64_t a1)
{
  HeimCredDeleteByUUID(*(void **)(a1 + 16));
}

void HeimCredRetainTransient(uint64_t a1)
{
  xpc_object_t v2;
  xpc_object_t v3;

  if (qword_253D3BA38 != -1)
    dispatch_once(&qword_253D3BA38, &unk_24C1F2208);
  v2 = xpc_dictionary_create(0, 0, 0);
  xpc_dictionary_set_string(v2, "command", "retain-transient");
  sub_20967926C(v2, "uuid", *(CFUUIDRef *)(a1 + 16));
  if (qword_253D3BA78)
    xpc_dictionary_set_string(v2, "impersonate", (const char *)qword_253D3BA78);
  v3 = xpc_connection_send_message_with_reply_sync((xpc_connection_t)qword_253D3BA98, v2);
  xpc_release(v2);
  xpc_release(v3);
}

void HeimCredReleaseTransient(uint64_t a1)
{
  xpc_object_t v2;
  xpc_object_t v3;

  if (qword_253D3BA38 != -1)
    dispatch_once(&qword_253D3BA38, &unk_24C1F2208);
  v2 = xpc_dictionary_create(0, 0, 0);
  xpc_dictionary_set_string(v2, "command", "release-transient");
  sub_20967926C(v2, "uuid", *(CFUUIDRef *)(a1 + 16));
  if (qword_253D3BA78)
    xpc_dictionary_set_string(v2, "impersonate", (const char *)qword_253D3BA78);
  v3 = xpc_connection_send_message_with_reply_sync((xpc_connection_t)qword_253D3BA98, v2);
  xpc_release(v2);
  xpc_release(v3);
}

BOOL HeimCredMove(const __CFUUID *a1, const __CFUUID *a2)
{
  xpc_object_t v4;
  xpc_object_t v5;
  _BOOL8 v6;

  if (qword_253D3BA38 != -1)
    dispatch_once(&qword_253D3BA38, &unk_24C1F2208);
  v4 = xpc_dictionary_create(0, 0, 0);
  xpc_dictionary_set_string(v4, "command", "move");
  sub_20967926C(v4, "from", a1);
  sub_20967926C(v4, "to", a2);
  if (qword_253D3BA78)
    xpc_dictionary_set_string(v4, "impersonate", (const char *)qword_253D3BA78);
  v5 = xpc_connection_send_message_with_reply_sync((xpc_connection_t)qword_253D3BA98, v4);
  v6 = xpc_dictionary_get_value(v5, "error") == 0;
  xpc_release(v4);
  xpc_release(v5);
  return v6;
}

uint64_t HeimCredCopyStatus(uint64_t a1)
{
  xpc_object_t v2;
  void *v3;
  void *v4;
  xpc_object_t v5;
  uint64_t v6;

  v2 = xpc_dictionary_create(0, 0, 0);
  xpc_dictionary_set_string(v2, "command", "status");
  if (a1)
  {
    v3 = (void *)_CFXPCCreateXPCObjectFromCFObject();
    if (!v3)
    {
      xpc_release(v2);
      return 0;
    }
    v4 = v3;
    xpc_dictionary_set_value(v2, "mech", v3);
    xpc_release(v4);
  }
  if (qword_253D3BA38 != -1)
    dispatch_once(&qword_253D3BA38, &unk_24C1F2208);
  if (qword_253D3BA78)
    xpc_dictionary_set_string(v2, "impersonate", (const char *)qword_253D3BA78);
  v5 = xpc_connection_send_message_with_reply_sync((xpc_connection_t)qword_253D3BA98, v2);
  xpc_release(v2);
  if (v5)
  {
    v6 = _CFXPCCreateCFObjectFromXPCObject();
    xpc_release(v5);
    return v6;
  }
  return 0;
}

const void *HeimCredCopyDefaultCredential(const __CFString *a1, CFErrorRef *a2)
{
  char *v4;
  char *v5;
  xpc_object_t v6;
  xpc_object_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  CFTypeID v13;
  const void *v14;
  const __CFString *v16;
  CFErrorRef *v17;
  unsigned int v18;
  char v19;

  if (qword_253D3BA38 == -1)
  {
    if (!a2)
      goto LABEL_4;
    goto LABEL_3;
  }
  dispatch_once(&qword_253D3BA38, &unk_24C1F2208);
  if (a2)
LABEL_3:
    *a2 = 0;
LABEL_4:
  v4 = sub_2096795AC(a1);
  if (v4)
  {
    v5 = v4;
    v6 = xpc_dictionary_create(0, 0, 0);
    xpc_dictionary_set_string(v6, "command", "default");
    xpc_dictionary_set_string(v6, "mech", v5);
    free(v5);
    if (qword_253D3BA78)
      xpc_dictionary_set_string(v6, "impersonate", (const char *)qword_253D3BA78);
    v7 = xpc_connection_send_message_with_reply_sync((xpc_connection_t)qword_253D3BA98, v6);
    xpc_release(v6);
    if (v7)
    {
      if (MEMORY[0x20BD129CC](v7) != MEMORY[0x24BDACFB8])
      {
        v13 = CFUUIDGetTypeID();
        v14 = sub_20967921C(v7, "default", v13);
        xpc_release(v7);
        return v14;
      }
      v18 = 564609;
      v19 = (char)v7;
      v16 = CFSTR("Server returned an error: %@");
      v17 = a2;
    }
    else
    {
      v16 = CFSTR("Server didn't return any data");
      v17 = a2;
      v18 = 564608;
    }
    sub_209679890(v17, v18, v16, v8, v9, v10, v11, v12, v19);
  }
  return 0;
}

uint64_t HeimCredDoAuth(uint64_t a1, uint64_t a2, CFErrorRef *a3)
{
  uint64_t v5;
  void *v6;
  xpc_object_t v7;
  xpc_object_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  const __CFString *v15;
  CFErrorRef *v16;
  unsigned int v17;
  char v19;
  _QWORD block[6];
  uint64_t v21;
  uint64_t *v22;
  uint64_t v23;
  uint64_t v24;

  v21 = 0;
  v22 = &v21;
  v23 = 0x2000000000;
  v24 = 0;
  if (qword_253D3BA38 == -1)
  {
    if (!a1)
    {
LABEL_14:
      v14 = 0;
      goto LABEL_15;
    }
  }
  else
  {
    dispatch_once(&qword_253D3BA38, &unk_24C1F2208);
    if (!a1)
      goto LABEL_14;
  }
  if (a3)
    *a3 = 0;
  v5 = _CFXPCCreateXPCObjectFromCFObject();
  if (!v5)
    goto LABEL_14;
  v6 = (void *)v5;
  v7 = xpc_dictionary_create(0, 0, 0);
  xpc_dictionary_set_string(v7, "command", "doauth");
  sub_20967926C(v7, "uuid", *(CFUUIDRef *)(a1 + 16));
  xpc_dictionary_set_value(v7, "attributes", v6);
  xpc_release(v6);
  if (qword_253D3BA78)
    xpc_dictionary_set_string(v7, "impersonate", (const char *)qword_253D3BA78);
  v8 = xpc_connection_send_message_with_reply_sync((xpc_connection_t)qword_253D3BA98, v7);
  xpc_release(v7);
  if (!v8)
  {
    v15 = CFSTR("Server didn't return any data");
    v16 = a3;
    v17 = 564608;
LABEL_13:
    sub_209679890(v16, v17, v15, v9, v10, v11, v12, v13, v19);
    goto LABEL_14;
  }
  if (MEMORY[0x20BD129CC](v8) == MEMORY[0x24BDACFB8])
  {
    v17 = 564609;
    v19 = (char)v8;
    v15 = CFSTR("Server returned an error: %@");
    v16 = a3;
    goto LABEL_13;
  }
  block[0] = MEMORY[0x24BDAC760];
  block[1] = 0x40000000;
  block[2] = sub_20967AAB0;
  block[3] = &unk_24C1F21A0;
  block[4] = &v21;
  block[5] = v8;
  dispatch_sync((dispatch_queue_t)qword_253D3BA80, block);
  xpc_release(v8);
  v14 = v22[3];
LABEL_15:
  _Block_object_dispose(&v21, 8);
  return v14;
}

const void *sub_20967AAB0(uint64_t a1)
{
  void *v2;
  CFTypeID TypeID;
  const void *result;

  v2 = *(void **)(a1 + 40);
  TypeID = CFDictionaryGetTypeID();
  result = sub_20967921C(v2, "attributes", TypeID);
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = result;
  return result;
}

BOOL HeimCredDeleteAll(void *a1, _QWORD *a2)
{
  void *v3;
  void *v4;
  _BOOL8 v5;
  void *values[2];
  void *keys[3];

  keys[2] = *(void **)MEMORY[0x24BDAC8D0];
  if (a2)
    *a2 = 0;
  if (qword_253D3BA38 != -1)
    dispatch_once(&qword_253D3BA38, &unk_24C1F2208);
  keys[0] = CFSTR("kHEIMAttrAltDSID");
  keys[1] = CFSTR("kHEIMObjectType");
  values[0] = a1;
  values[1] = CFSTR("kHEIMObjectAny");
  CFDictionaryCreate(0, (const void **)keys, (const void **)values, 2, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
  v3 = (void *)sub_20967A0EC("delete-all");
  if (!v3)
    return 0;
  v4 = v3;
  v5 = xpc_dictionary_get_value(v3, "error") == 0;
  xpc_release(v4);
  return v5;
}

BOOL HeimCredAddNTLMChallenge(UInt8 *bytes)
{
  const __CFData *v2;
  xpc_object_t v3;
  const UInt8 *BytePtr;
  size_t Length;
  xpc_object_t v6;
  _BOOL8 v7;

  if (qword_253D3BA38 != -1)
    dispatch_once(&qword_253D3BA38, &unk_24C1F2208);
  v2 = CFDataCreate(0, bytes, 8);
  v3 = xpc_dictionary_create(0, 0, 0);
  xpc_dictionary_set_string(v3, "command", "add-challenge");
  BytePtr = CFDataGetBytePtr(v2);
  Length = CFDataGetLength(v2);
  xpc_dictionary_set_data(v3, "challenge", BytePtr, Length);
  if (v2)
    CFRelease(v2);
  v6 = xpc_connection_send_message_with_reply_sync((xpc_connection_t)qword_253D3BA98, v3);
  xpc_release(v3);
  if (!v6)
    return 0;
  v7 = xpc_dictionary_get_value(v6, "error") == 0;
  xpc_release(v6);
  return v7;
}

BOOL HeimCredCheckNTLMChallenge(UInt8 *bytes)
{
  const __CFData *v2;
  xpc_object_t v3;
  const UInt8 *BytePtr;
  size_t Length;
  xpc_object_t v6;
  xpc_object_t value;
  _BOOL8 v8;

  if (qword_253D3BA38 != -1)
    dispatch_once(&qword_253D3BA38, &unk_24C1F2208);
  v2 = CFDataCreate(0, bytes, 8);
  v3 = xpc_dictionary_create(0, 0, 0);
  xpc_dictionary_set_string(v3, "command", "check-challenge");
  BytePtr = CFDataGetBytePtr(v2);
  Length = CFDataGetLength(v2);
  xpc_dictionary_set_data(v3, "challenge", BytePtr, Length);
  v6 = xpc_connection_send_message_with_reply_sync((xpc_connection_t)qword_253D3BA98, v3);
  xpc_release(v3);
  if (!v6)
    return 1;
  xpc_dictionary_get_value(v6, "error");
  value = xpc_dictionary_get_value(v6, "challenge-result");
  if (value)
    v8 = xpc_BOOL_get_value(value);
  else
    v8 = 1;
  xpc_release(v6);
  return v8;
}

uint64_t HeimCredDoSCRAM(uint64_t a1, uint64_t a2, CFErrorRef *a3)
{
  uint64_t v5;
  void *v6;
  xpc_object_t v7;
  xpc_object_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  const __CFString *v15;
  CFErrorRef *v16;
  unsigned int v17;
  char v19;
  _QWORD block[6];
  uint64_t v21;
  uint64_t *v22;
  uint64_t v23;
  uint64_t v24;

  v21 = 0;
  v22 = &v21;
  v23 = 0x2000000000;
  v24 = 0;
  if (qword_253D3BA38 == -1)
  {
    if (!a3)
      goto LABEL_4;
    goto LABEL_3;
  }
  dispatch_once(&qword_253D3BA38, &unk_24C1F2208);
  if (a3)
LABEL_3:
    *a3 = 0;
LABEL_4:
  v5 = _CFXPCCreateXPCObjectFromCFObject();
  if (!v5)
  {
LABEL_13:
    v14 = 0;
    goto LABEL_14;
  }
  v6 = (void *)v5;
  v7 = xpc_dictionary_create(0, 0, 0);
  xpc_dictionary_set_string(v7, "command", "doscram");
  sub_20967926C(v7, "uuid", *(CFUUIDRef *)(a1 + 16));
  xpc_dictionary_set_value(v7, "attributes", v6);
  xpc_release(v6);
  if (qword_253D3BA78)
    xpc_dictionary_set_string(v7, "impersonate", (const char *)qword_253D3BA78);
  v8 = xpc_connection_send_message_with_reply_sync((xpc_connection_t)qword_253D3BA98, v7);
  xpc_release(v7);
  if (!v8)
  {
    v15 = CFSTR("Server didn't return any data");
    v16 = a3;
    v17 = 564608;
LABEL_12:
    sub_209679890(v16, v17, v15, v9, v10, v11, v12, v13, v19);
    goto LABEL_13;
  }
  if (MEMORY[0x20BD129CC](v8) == MEMORY[0x24BDACFB8])
  {
    v17 = 564609;
    v19 = (char)v8;
    v15 = CFSTR("Server returned an error: %@");
    v16 = a3;
    goto LABEL_12;
  }
  block[0] = MEMORY[0x24BDAC760];
  block[1] = 0x40000000;
  block[2] = sub_20967B014;
  block[3] = &unk_24C1F21C8;
  block[4] = &v21;
  block[5] = v8;
  dispatch_sync((dispatch_queue_t)qword_253D3BA80, block);
  xpc_release(v8);
  v14 = v22[3];
LABEL_14:
  _Block_object_dispose(&v21, 8);
  return v14;
}

CFTypeRef sub_20967B014(uint64_t a1)
{
  void *v2;
  CFTypeID TypeID;
  CFTypeRef result;

  v2 = *(void **)(a1 + 40);
  TypeID = CFDictionaryGetTypeID();
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = sub_20967921C(v2, "attributes", TypeID);
  result = *(CFTypeRef *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  if (result)
    return CFRetain(result);
  return result;
}

void sub_20967B074()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  xpc_object_t v7;
  char v8;

  sub_2096792DC();
  qword_253D3BA98 = (uint64_t)xpc_connection_create_mach_service("com.apple.GSSCred", (dispatch_queue_t)qword_253D3BA80, 2uLL);
  xpc_connection_set_event_handler((xpc_connection_t)qword_253D3BA98, &unk_24C1F2248);
  xpc_connection_resume((xpc_connection_t)qword_253D3BA98);
  if (!qword_253D3BA98)
    heim_abort("no connection to XPCService:HeimCredCTX.conn != NULL", v0, v1, v2, v3, v4, v5, v6, v8);
  v7 = xpc_dictionary_create(0, 0, 0);
  xpc_dictionary_set_string(v7, "command", "wakeup");
  xpc_dictionary_set_int64(v7, "version", 0);
  if (qword_253D3BA78)
    xpc_dictionary_set_string(v7, "impersonate", (const char *)qword_253D3BA78);
  xpc_connection_send_message((xpc_connection_t)qword_253D3BA98, v7);
  xpc_release(v7);
}

void sub_20967B140(uint64_t a1)
{
  CFDictionarySetValue((CFMutableDictionaryRef)qword_253D3BA90, *(const void **)(*(_QWORD *)(a1 + 32) + 16), *(const void **)(a1 + 32));
}

uint64_t krb5_add_et_list(uint64_t a1, void (*a2)(uint64_t))
{
  a2(a1 + 144);
  return 0;
}

uint64_t krb5_sockaddr2address(_krb5_context *a1, uint64_t a2, uint64_t a3)
{
  int *v3;

  v3 = &dword_24C1F08E8;
  while (*v3 != *(unsigned __int8 *)(a2 + 1))
  {
    v3 += 32;
    if (v3 >= (int *)&off_24C1F0A68)
    {
      krb5_set_error_message(a1, -1765328170, "Address family %d not supported", *(unsigned __int8 *)(a2 + 1));
      return 2529639126;
    }
  }
  return (*((uint64_t (**)(uint64_t, uint64_t))v3 + 2))(a2, a3);
}

uint64_t krb5_sockaddr2port(_krb5_context *a1, uint64_t a2, uint64_t a3)
{
  int *v3;

  v3 = &dword_24C1F08E8;
  while (*v3 != *(unsigned __int8 *)(a2 + 1))
  {
    v3 += 32;
    if (v3 >= (int *)&off_24C1F0A68)
    {
      krb5_set_error_message(a1, -1765328170, "Address family %d not supported", *(unsigned __int8 *)(a2 + 1));
      return 2529639126;
    }
  }
  return (*((uint64_t (**)(uint64_t, uint64_t))v3 + 3))(a2, a3);
}

uint64_t krb5_addr2sockaddr(_krb5_context *a1, _DWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  int *v5;
  uint64_t v6;
  void (*v7)(_DWORD *, uint64_t, uint64_t, uint64_t);

  v5 = &dword_24C1F08E8;
  while (v5[1] != *a2)
  {
    v5 += 32;
    if (v5 >= (int *)&off_24C1F0A68)
    {
      v6 = 2529639126;
      krb5_set_error_message(a1, -1765328170, "Address type %d not supported");
      return v6;
    }
  }
  v7 = (void (*)(_DWORD *, uint64_t, uint64_t, uint64_t))*((_QWORD *)v5 + 4);
  if (v7)
  {
    v7(a2, a3, a4, a5);
    return 0;
  }
  else
  {
    v6 = 2529639126;
    krb5_set_error_message(a1, -1765328170, "Can't convert address type %d to sockaddr");
  }
  return v6;
}

unint64_t krb5_max_sockaddr_size()
{
  unint64_t result;
  int *v1;

  result = qword_2545A7988;
  if (!qword_2545A7988)
  {
    v1 = &dword_24C1F08E8;
    do
    {
      if (result <= *((_QWORD *)v1 + 1))
        result = *((_QWORD *)v1 + 1);
      v1 += 32;
    }
    while (v1 < (int *)&off_24C1F0A68);
    qword_2545A7988 = result;
  }
  return result;
}

uint64_t krb5_sockaddr_uninteresting(uint64_t a1)
{
  int *v1;
  uint64_t (*v2)(void);

  v1 = dword_24C1F08E8;
  while (*v1 != *(unsigned __int8 *)(a1 + 1))
  {
    v1 += 32;
    if (v1 >= (int *)&off_24C1F0A68)
      return 1;
  }
  v2 = (uint64_t (*)(void))*((_QWORD *)v1 + 7);
  if (v2)
    return v2();
  return 1;
}

uint64_t sub_20967B3A0(uint64_t a1)
{
  int *v1;
  uint64_t (*v2)(void);

  v1 = dword_24C1F08E8;
  while (*v1 != *(unsigned __int8 *)(a1 + 1))
  {
    v1 += 32;
    if (v1 >= (int *)&off_24C1F0A68)
      return 1;
  }
  v2 = (uint64_t (*)(void))*((_QWORD *)v1 + 8);
  if (v2)
    return v2();
  return 1;
}

uint64_t krb5_h_addr2sockaddr(_krb5_context *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  int *v6;
  uint64_t v7;

  v6 = &dword_24C1F08E8;
  while (*v6 != a2)
  {
    v6 += 32;
    if (v6 >= (int *)&off_24C1F0A68)
    {
      v7 = 2529639126;
      krb5_set_error_message(a1, -1765328170, "Address family %d not supported", a2);
      return v7;
    }
  }
  (*((void (**)(uint64_t, uint64_t, uint64_t, uint64_t))v6 + 5))(a3, a4, a5, a6);
  return 0;
}

uint64_t krb5_h_addr2addr(_krb5_context *a1, int a2, uint64_t a3, uint64_t a4)
{
  int *v4;

  v4 = &dword_24C1F08E8;
  while (*v4 != a2)
  {
    v4 += 32;
    if (v4 >= (int *)&off_24C1F0A68)
    {
      krb5_set_error_message(a1, -1765328170, "Address family %d not supported", a2);
      return 2529639126;
    }
  }
  return (*((uint64_t (**)(uint64_t, uint64_t))v4 + 6))(a3, a4);
}

uint64_t krb5_anyaddr(_krb5_context *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  int *v5;
  uint64_t v6;

  v5 = dword_24C1F08E8;
  while (*v5 != a2)
  {
    v5 += 32;
    if (v5 >= (int *)&off_24C1F0A68)
    {
      v6 = 2529639126;
      krb5_set_error_message(a1, -1765328170, "Address family %d not supported", a2);
      return v6;
    }
  }
  (*((void (**)(uint64_t, uint64_t, uint64_t))v5 + 9))(a3, a4, a5);
  return 0;
}

uint64_t krb5_print_address(uint64_t a1, char *__str, size_t __size, _QWORD *a4)
{
  int *v8;
  uint64_t (*v9)(uint64_t, char *, size_t);
  unsigned int v10;
  uint64_t v11;
  unsigned int v12;
  char *v13;
  uint64_t v14;
  size_t v15;
  unsigned int v16;
  uint64_t result;

  v8 = &dword_24C1F08E8;
  while (v8[1] != *(_DWORD *)a1)
  {
    v8 += 32;
    if (v8 >= (int *)&off_24C1F0A68)
      goto LABEL_9;
  }
  v9 = (uint64_t (*)(uint64_t, char *, size_t))*((_QWORD *)v8 + 10);
  if (!v9)
  {
LABEL_9:
    v12 = snprintf(__str, __size, "TYPE_%d:", *(_DWORD *)a1);
    if ((v12 & 0x80000000) == 0 && __size > v12)
    {
      v13 = &__str[v12];
      if (!*(_QWORD *)(a1 + 8))
      {
LABEL_16:
        if (a4)
        {
          v11 = v13 - __str;
          goto LABEL_18;
        }
        return 0;
      }
      v14 = 0;
      v15 = __size - v12;
      while (1)
      {
        v16 = snprintf(v13, v15, "%02x", *(char *)(*(_QWORD *)(a1 + 16) + v14));
        if ((v16 & 0x80000000) != 0 || v15 <= v16)
          break;
        v15 -= v16;
        v13 += v16;
        if ((unint64_t)++v14 >= *(_QWORD *)(a1 + 8))
          goto LABEL_16;
      }
    }
    return 22;
  }
  v10 = v9(a1, __str, __size);
  if ((v10 & 0x80000000) != 0)
    return 22;
  if (a4)
  {
    v11 = v10;
LABEL_18:
    result = 0;
    *a4 = v11;
    return result;
  }
  return 0;
}

uint64_t krb5_parse_address(_krb5_context *a1, char *a2, uint64_t a3)
{
  uint64_t v6;
  unsigned int (*v7)(_krb5_context *, char *, __int128 *);
  uint64_t v8;
  uint64_t v9;
  int *v10;
  uint64_t v11;
  _QWORD *v12;
  __int128 v13;
  addrinfo *v14;
  unsigned int v15;
  void *v16;
  addrinfo *v17;
  int v18;
  addrinfo *v19;
  __int128 v21;
  uint64_t v22;
  addrinfo *v23;

  v6 = 0;
  v23 = 0;
  *(_DWORD *)a3 = 0;
  *(_QWORD *)(a3 + 8) = 0;
  do
  {
    if (v6 != 64)
    {
      v7 = *(unsigned int (**)(_krb5_context *, char *, __int128 *))&dword_24C1F08E8[v6 + 22];
      v21 = 0uLL;
      v22 = 0;
      if (!v7(a1, a2, &v21))
      {
        *(_DWORD *)a3 = 1;
        v12 = malloc_type_calloc(1uLL, 0x18uLL, 0x10800404ACF7207uLL);
        *(_QWORD *)(a3 + 8) = v12;
        if (v12)
        {
          v11 = 0;
          v13 = v21;
          v12[2] = v22;
          *(_OWORD *)v12 = v13;
        }
        else
        {
          v11 = 12;
          krb5_set_error_message(a1, 12, "malloc: out of memory");
        }
        return v11;
      }
    }
    v6 += 32;
  }
  while (v6 != 96);
  v8 = getaddrinfo(a2, 0, 0, &v23);
  if ((_DWORD)v8)
  {
    v9 = v8;
    v10 = __error();
    v11 = krb5_eai_to_heim_errno(v9, *v10);
    gai_strerror(v9);
    krb5_set_error_message(a1, v11, "%s: %s");
  }
  else
  {
    v14 = v23;
    if (v23)
    {
      v15 = 0;
      do
      {
        ++v15;
        v14 = v14->ai_next;
      }
      while (v14);
    }
    else
    {
      v15 = 0;
    }
    *(_DWORD *)a3 = v15;
    v16 = malloc_type_calloc(v15, 0x18uLL, 0x10800404ACF7207uLL);
    *(_QWORD *)(a3 + 8) = v16;
    if (v16)
    {
      *(_DWORD *)a3 = 0;
      v17 = v23;
      if (v23)
      {
        v18 = 0;
        do
        {
          if (!krb5_sockaddr2address(a1, (uint64_t)v17->ai_addr, *(_QWORD *)(a3 + 8) + 24 * v18))
          {
            if (krb5_address_search(a1, (const krb5_address *)(*(_QWORD *)(a3 + 8) + 24 * v18), (krb5_address *const *)a3))
            {
              krb5_free_address((uint64_t)a1, *(_QWORD *)(a3 + 8) + 24 * v18);
            }
            else
            {
              *(_DWORD *)a3 = ++v18;
            }
          }
          v17 = v17->ai_next;
        }
        while (v17);
        v19 = v23;
      }
      else
      {
        v19 = 0;
      }
      freeaddrinfo(v19);
      return 0;
    }
    else
    {
      v11 = 12;
      krb5_set_error_message(a1, 12, "malloc: out of memory");
      freeaddrinfo(v23);
    }
  }
  return v11;
}

krb5_BOOLean krb5_address_search(krb5_context a1, const krb5_address *a2, krb5_address *const *a3)
{
  uint64_t v6;
  unint64_t v7;

  if (!*(_DWORD *)a3)
    return 0;
  v6 = 0;
  v7 = 0;
  while (krb5_address_order(a1, a2, (const krb5_address *)(*((_QWORD *)a3 + 1) + v6)))
  {
    ++v7;
    v6 += 24;
    if (v7 >= *(unsigned int *)a3)
      return 0;
  }
  return 1;
}

uint64_t krb5_free_address(uint64_t a1, uint64_t a2)
{
  int *v3;
  uint64_t (*v4)(uint64_t, uint64_t);

  v3 = &dword_24C1F08E8;
  while (v3[1] != *(_DWORD *)a2)
  {
    v3 += 32;
    if (v3 >= (int *)&off_24C1F0A68)
      goto LABEL_7;
  }
  v4 = (uint64_t (*)(uint64_t, uint64_t))*((_QWORD *)v3 + 13);
  if (v4)
    return v4(a1, a2);
LABEL_7:
  krb5_data_free((_QWORD *)(a2 + 8));
  *(_QWORD *)a2 = 0;
  *(_QWORD *)(a2 + 8) = 0;
  *(_QWORD *)(a2 + 16) = 0;
  return 0;
}

int krb5_address_order(krb5_context a1, const krb5_address *a2, const krb5_address *a3)
{
  krb5_magic magic;
  int *v4;
  int v5;
  uint64_t (*v7)(krb5_context);
  krb5_magic v8;
  int *v9;
  size_t v10;
  uint64_t v11;

  magic = a2->magic;
  v4 = &dword_24C1F08E8;
  while (v4[1] != magic)
  {
    v4 += 32;
    if (v4 >= (int *)&off_24C1F0A68)
    {
      v5 = -1765328170;
      krb5_set_error_message(a1, -1765328170, "Address family %d not supported", a2->magic);
      return v5;
    }
  }
  v7 = (uint64_t (*)(krb5_context))*((_QWORD *)v4 + 12);
  if (v7)
    return v7(a1);
  v8 = a3->magic;
  v9 = &dword_24C1F08E8;
  while (v9[1] != v8)
  {
    v9 += 32;
    if (v9 >= (int *)&off_24C1F0A68)
    {
      v5 = -1765328170;
      krb5_set_error_message(a1, -1765328170, "Address family %d not supported", a3->magic);
      return v5;
    }
  }
  v7 = (uint64_t (*)(krb5_context))*((_QWORD *)v9 + 12);
  if (v7)
    return v7(a1);
  v5 = magic - v8;
  if (magic != v8)
    return v5;
  v10 = *(_QWORD *)&a2->length;
  v11 = *(_QWORD *)&a3->length;
  if (v10 != v11)
    return v10 - v11;
  return memcmp(a2->contents, a3->contents, v10);
}

krb5_BOOLean krb5_address_compare(krb5_context a1, const krb5_address *a2, const krb5_address *a3)
{
  return krb5_address_order(a1, a2, a3) == 0;
}

void krb5_free_addresses(krb5_context a1, krb5_address **a2)
{
  uint64_t v4;
  unint64_t v5;

  if (*(_DWORD *)a2)
  {
    v4 = 0;
    v5 = 0;
    do
    {
      krb5_free_address((uint64_t)a1, (uint64_t)&a2[1][v4]);
      ++v5;
      ++v4;
    }
    while (v5 < *(unsigned int *)a2);
  }
  free(a2[1]);
  *(_DWORD *)a2 = 0;
  a2[1] = 0;
}

uint64_t krb5_copy_address(uint64_t a1, _DWORD *a2)
{
  int *v2;
  uint64_t (*v3)(void);

  v2 = &dword_24C1F08E8;
  while (*v2 != *a2)
  {
    v2 += 32;
    if (v2 >= (int *)&off_24C1F0A68)
      return sub_2096BB52C();
  }
  v3 = (uint64_t (*)(void))*((_QWORD *)v2 + 14);
  if (v3)
    return v3();
  return sub_2096BB52C();
}

krb5_error_code krb5_copy_addresses(krb5_context a1, krb5_address *const *a2, krb5_address ***a3)
{
  krb5_address **v6;
  BOOL v7;
  uint64_t v8;
  unint64_t v9;

  *(_DWORD *)a3 = *(_DWORD *)a2;
  v6 = (krb5_address **)malloc_type_calloc(*(unsigned int *)a2, 0x18uLL, 0x10800404ACF7207uLL);
  a3[1] = v6;
  if (*(_DWORD *)a2)
    v7 = v6 == 0;
  else
    v7 = 0;
  if (v7)
    return 12;
  if (*(_DWORD *)a2)
  {
    v8 = 0;
    v9 = 0;
    do
    {
      krb5_copy_address((uint64_t)a1, (_DWORD *)(*((_QWORD *)a2 + 1) + v8));
      ++v9;
      v8 += 24;
    }
    while (v9 < *(unsigned int *)a2);
  }
  return 0;
}

uint64_t krb5_append_addresses(_krb5_context *a1, uint64_t a2, unsigned int *a3)
{
  void *v6;
  uint64_t v7;
  unint64_t i;
  uint64_t v9;
  uint64_t v10;

  if (*a3)
  {
    v6 = malloc_type_realloc(*(void **)(a2 + 8), 24 * (*(_DWORD *)a2 + *a3), 0x10800404ACF7207uLL);
    if (!v6)
    {
      v10 = 12;
      krb5_set_error_message(a1, 12, "malloc: out of memory");
      return v10;
    }
    *(_QWORD *)(a2 + 8) = v6;
    if (*a3)
    {
      v7 = 0;
      for (i = 0; i < *a3; ++i)
      {
        if (!krb5_address_search(a1, (const krb5_address *)(*((_QWORD *)a3 + 1) + v7), (krb5_address *const *)a2))
        {
          v9 = krb5_copy_address((uint64_t)a1, (_DWORD *)(*((_QWORD *)a3 + 1) + v7));
          if ((_DWORD)v9)
            return v9;
          ++*(_DWORD *)a2;
        }
        v7 += 24;
      }
    }
  }
  return 0;
}

uint64_t krb5_make_addrport(_krb5_context *a1, void **a2, uint64_t a3, __int16 a4)
{
  uint64_t v8;
  size_t *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  v8 = *(_QWORD *)(a3 + 8);
  v9 = (size_t *)malloc_type_malloc(0x18uLL, 0x10800404ACF7207uLL);
  *a2 = v9;
  if (v9)
  {
    *(_DWORD *)v9 = 256;
    v10 = krb5_data_alloc(v9 + 1, v8 + 18);
    if ((_DWORD)v10)
    {
      krb5_set_error_message(a1, v10, "malloc: out of memory");
      free(*a2);
      *a2 = 0;
    }
    else
    {
      v11 = *((_QWORD *)*a2 + 2);
      *(_WORD *)v11 = 0;
      *(_WORD *)(v11 + 2) = *(_DWORD *)a3;
      *(_WORD *)(v11 + 4) = *(_QWORD *)(a3 + 8);
      *(_BYTE *)(v11 + 6) = BYTE2(*(_QWORD *)(a3 + 8));
      v12 = v11 + 8;
      *(_BYTE *)(v11 + 7) = BYTE3(*(_QWORD *)(a3 + 8));
      memcpy((void *)(v11 + 8), *(const void **)(a3 + 16), *(_QWORD *)(a3 + 8));
      v13 = v12 + *(_QWORD *)(a3 + 8);
      *(_QWORD *)v13 = 0x201010000;
      *(_WORD *)(v13 + 8) = a4;
    }
  }
  else
  {
    v10 = 12;
    krb5_set_error_message(a1, 12, "malloc: out of memory");
  }
  return v10;
}

uint64_t krb5_address_prefixlen_boundary(_krb5_context *a1, _DWORD *a2)
{
  int *v2;
  uint64_t (*v3)(void);

  v2 = &dword_24C1F08E8;
  while (v2[1] != *a2)
  {
    v2 += 32;
    if (v2 >= (int *)&off_24C1F0A68)
      goto LABEL_7;
  }
  v3 = (uint64_t (*)(void))*((_QWORD *)v2 + 15);
  if (v3)
    return v3();
LABEL_7:
  krb5_set_error_message(a1, -1765328170, "Address family %d doesn't support address mask operation", *a2);
  return 2529639126;
}

uint64_t sub_20967BF10(uint64_t a1, uint64_t a2)
{
  int v3;

  *(_DWORD *)a2 = 2;
  v3 = *(_DWORD *)(a1 + 4);
  return krb5_data_copy((_QWORD *)(a2 + 8), &v3, 4uLL);
}

uint64_t sub_20967BF4C(uint64_t a1, _WORD *a2)
{
  *a2 = *(_WORD *)(a1 + 2);
  return 0;
}

void *sub_20967BF5C(uint64_t a1, void *__dst, _DWORD *a3, __int16 a4)
{
  size_t v5;
  void *result;
  _QWORD __src[3];

  __src[2] = *MEMORY[0x24BDAC8D0];
  __src[0] = 512;
  __src[1] = 0;
  HIDWORD(__src[0]) = **(_DWORD **)(a1 + 16);
  WORD1(__src[0]) = a4;
  if (*a3 >= 0x10u)
    v5 = 16;
  else
    v5 = *a3;
  result = memcpy(__dst, __src, v5);
  *a3 = 16;
  return result;
}

void *sub_20967BFEC(_DWORD *a1, void *__dst, _DWORD *a3, __int16 a4)
{
  size_t v5;
  void *result;
  _QWORD __src[3];

  __src[2] = *MEMORY[0x24BDAC8D0];
  __src[0] = 512;
  __src[1] = 0;
  WORD1(__src[0]) = a4;
  HIDWORD(__src[0]) = *a1;
  if (*a3 >= 0x10u)
    v5 = 16;
  else
    v5 = *a3;
  result = memcpy(__dst, __src, v5);
  *a3 = 16;
  return result;
}

uint64_t sub_20967C078(int *a1, uint64_t a2)
{
  int v3;

  *(_DWORD *)a2 = 2;
  v3 = *a1;
  return krb5_data_copy((_QWORD *)(a2 + 8), &v3, 4uLL);
}

BOOL sub_20967C0B4(uint64_t a1)
{
  return *(_DWORD *)(a1 + 4) == 0;
}

BOOL sub_20967C0C4(uint64_t a1)
{
  return *(_BYTE *)(a1 + 4) == 127;
}

void *sub_20967C0D4(void *a1, _DWORD *a2, __int16 a3)
{
  size_t v4;
  void *result;
  _QWORD __src[3];

  __src[2] = *MEMORY[0x24BDAC8D0];
  __src[0] = 512;
  __src[1] = 0;
  WORD1(__src[0]) = a3;
  if (*a2 >= 0x10u)
    v4 = 16;
  else
    v4 = *a2;
  result = memcpy(a1, __src, v4);
  *a2 = 16;
  return result;
}

uint64_t sub_20967C150(uint64_t a1, char *a2, size_t a3)
{
  in_addr v5;
  char *v6;

  v5.s_addr = **(_DWORD **)(a1 + 16);
  v6 = inet_ntoa(v5);
  return snprintf(a2, a3, "IPv4:%s", v6);
}

uint64_t sub_20967C19C(int a1, char *__s, uint64_t a3)
{
  char *v5;
  const char *v6;
  size_t v7;
  in_addr v9;

  v5 = strchr(__s, 58);
  if (v5)
  {
    v6 = v5 + 1;
    v7 = v5 + 1 - __s;
    if (strncasecmp(__s, "ip:", v7)
      && strncasecmp(__s, "ip4:", v7)
      && strncasecmp(__s, "ipv4:", v7)
      && strncasecmp(__s, "inet:", v7))
    {
      return 0xFFFFFFFFLL;
    }
  }
  else
  {
    v6 = __s;
  }
  v9.s_addr = 0;
  if (!inet_aton(v6, &v9))
    return 0xFFFFFFFFLL;
  *(_DWORD *)a3 = 2;
  if (krb5_data_alloc((size_t *)(a3 + 8), 4uLL))
    return 0xFFFFFFFFLL;
  _krb5_put_int(*(_QWORD *)(a3 + 16), bswap32(v9.s_addr), *(_QWORD *)(a3 + 8));
  return 0;
}

uint64_t sub_20967C294(krb5_context a1, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5)
{
  char v5;
  uint64_t v7;
  unsigned int v10;
  int v11;
  unint64_t v13;

  v5 = a3;
  if (a3 < 0x21)
  {
    v13 = 0;
    v7 = 0xFFFFFFFFLL;
    _krb5_get_int(*(unsigned __int8 **)(a2 + 16), &v13, *(_QWORD *)(a2 + 8));
    v10 = v13;
    *(_DWORD *)a4 = 2;
    if (!krb5_data_alloc((size_t *)(a4 + 8), 4uLL))
    {
      v11 = -1 << -v5;
      _krb5_put_int(*(_QWORD *)(a4 + 16), v11 & v10, *(_QWORD *)(a4 + 8));
      *(_DWORD *)a5 = 2;
      if (krb5_data_alloc((size_t *)(a5 + 8), 4uLL))
      {
        krb5_free_address((uint64_t)a1, a4);
        return 0xFFFFFFFFLL;
      }
      else
      {
        _krb5_put_int(*(_QWORD *)(a5 + 16), v10 | ~v11, *(_QWORD *)(a5 + 8));
        return 0;
      }
    }
  }
  else
  {
    v7 = 2529639126;
    krb5_set_error_message(a1, -1765328170, "IPv4 prefix too large (%ld)", a3);
  }
  return v7;
}

uint64_t sub_20967C38C(_DWORD *a1, uint64_t a2)
{
  int v3;

  if (a1[2] || a1[3] || a1[4] != -65536)
  {
    *(_DWORD *)a2 = 24;
    return krb5_data_copy((_QWORD *)(a2 + 8), a1 + 2, 0x10uLL);
  }
  else
  {
    *(_DWORD *)a2 = 2;
    v3 = a1[5];
    return krb5_data_copy((_QWORD *)(a2 + 8), &v3, 4uLL);
  }
}

uint64_t sub_20967C404(uint64_t a1, _WORD *a2)
{
  *a2 = *(_WORD *)(a1 + 2);
  return 0;
}

void *sub_20967C414(uint64_t a1, void *__dst, _DWORD *a3, __int16 a4)
{
  size_t v5;
  void *result;
  uint64_t v7;
  __int128 v8;
  int v9;

  v8 = 0uLL;
  v7 = 7680;
  v9 = 0;
  v8 = *(_OWORD *)*(_QWORD *)(a1 + 16);
  WORD1(v7) = a4;
  if (*a3 >= 0x1Cu)
    v5 = 28;
  else
    v5 = *a3;
  result = memcpy(__dst, &v7, v5);
  *a3 = 28;
  return result;
}

void *sub_20967C480(__int128 *a1, void *__dst, _DWORD *a3, __int16 a4)
{
  size_t v5;
  void *result;
  uint64_t v7;
  __int128 v8;
  int v9;

  v8 = 0uLL;
  v7 = 7680;
  v9 = 0;
  WORD1(v7) = a4;
  v8 = *a1;
  if (*a3 >= 0x1Cu)
    v5 = 28;
  else
    v5 = *a3;
  result = memcpy(__dst, &v7, v5);
  *a3 = 28;
  return result;
}

uint64_t sub_20967C4E8(const void *a1, uint64_t a2)
{
  *(_DWORD *)a2 = 24;
  return krb5_data_copy((_QWORD *)(a2 + 8), a1, 0x10uLL);
}

BOOL sub_20967C504(uint64_t a1)
{
  int v2;

  if (*(unsigned __int8 *)(a1 + 8) == 254 && (*(_BYTE *)(a1 + 9) & 0xC0) == 0x80)
    return 1;
  if (*(_DWORD *)(a1 + 8) || *(_DWORD *)(a1 + 12) || *(_DWORD *)(a1 + 16))
    return 0;
  v2 = *(_DWORD *)(a1 + 20);
  return v2 && v2 != 0x1000000;
}

BOOL sub_20967C564(_DWORD *a1)
{
  return !a1[2] && !a1[3] && !a1[4] && a1[5] == 0x1000000;
}

void *sub_20967C598(void *a1, _DWORD *a2, __int16 a3)
{
  size_t v4;
  void *result;
  uint64_t v6;
  __int128 v7;
  int v8;

  v7 = 0uLL;
  v6 = 7680;
  v8 = 0;
  WORD1(v6) = a3;
  v7 = *MEMORY[0x24BDAE878];
  if (*a2 >= 0x1Cu)
    v4 = 28;
  else
    v4 = *a2;
  result = memcpy(a1, &v6, v4);
  *a2 = 28;
  return result;
}

uint64_t sub_20967C600(uint64_t a1, char *a2, size_t a3)
{
  uint64_t v6;
  unint64_t v7;
  char __str[3];
  char v10[128];
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  if (!inet_ntop(30, *(const void **)(a1 + 16), v10, 0x80u))
  {
    v10[0] = 0;
    v6 = *(_QWORD *)(a1 + 16);
    if (*(_QWORD *)(a1 + 8))
    {
      v7 = 0;
      do
      {
        snprintf(__str, 3uLL, "%02x", *(unsigned __int8 *)(v6 + v7));
        if (v7 && (v7 & 1) == 0)
          __strlcat_chk();
        __strlcat_chk();
        ++v7;
      }
      while (v7 < *(_QWORD *)(a1 + 8));
    }
  }
  return snprintf(a2, a3, "IPv6:%s", v10);
}

double sub_20967C71C(int a1, char *__s, uint64_t a3)
{
  const char *v4;
  char *v5;
  const char *v6;
  size_t v7;
  double result;
  __int128 v9;

  v4 = __s;
  v5 = strchr(__s, 58);
  if (v5)
  {
    v6 = v5 + 1;
    v7 = v5 + 1 - v4;
    if (!strncasecmp(v4, "ip6:", v7) || !strncasecmp(v4, "ipv6:", v7) || !strncasecmp(v4, "inet6:", v7))
      v4 = v6;
  }
  v9 = 0uLL;
  if (inet_pton(30, v4, &v9) == 1)
  {
    *(_DWORD *)a3 = 24;
    if (!krb5_data_alloc((size_t *)(a3 + 8), 0x10uLL))
    {
      result = *(double *)&v9;
      *(_OWORD *)*(_QWORD *)(a3 + 16) = v9;
    }
  }
  return result;
}

uint64_t sub_20967C7F8(krb5_context a1, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v6;
  uint64_t v9;
  char v10;
  int v11;
  char v12;
  __int128 v14;
  __int128 v15;
  __int128 v16;

  if (a3 < 0x81)
  {
    if (*(_QWORD *)(a2 + 8) == 16)
    {
      v9 = 0;
      v15 = 0uLL;
      v14 = 0uLL;
      v16 = *(_OWORD *)*(_QWORD *)(a2 + 16);
      do
      {
        v10 = 8 - a3;
        if (a3 > 8)
          v10 = 0;
        v11 = 255 << v10;
        v12 = *((_BYTE *)&v16 + v9);
        *((_BYTE *)&v15 + v9) = v12 & v11;
        *((_BYTE *)&v14 + v9) = v12 | ~(_BYTE)v11;
        if (a3 >= 8)
          a3 -= 8;
        else
          a3 = 0;
        ++v9;
      }
      while (v9 != 16);
      *(_DWORD *)a4 = 24;
      if (!krb5_data_alloc((size_t *)(a4 + 8), 0x10uLL))
      {
        *(_OWORD *)*(_QWORD *)(a4 + 16) = v15;
        *(_DWORD *)a5 = 24;
        if (!krb5_data_alloc((size_t *)(a5 + 8), 0x10uLL))
        {
          v6 = 0;
          *(_OWORD *)*(_QWORD *)(a5 + 16) = v14;
          return v6;
        }
        krb5_free_address((uint64_t)a1, a4);
      }
      return 0xFFFFFFFFLL;
    }
    else
    {
      v6 = 2529639126;
      krb5_set_error_message(a1, -1765328170, "IPv6 addr bad length");
    }
  }
  else
  {
    v6 = 2529639126;
    krb5_set_error_message(a1, -1765328170, "IPv6 prefix too large (%ld)");
  }
  return v6;
}

uint64_t sub_20967C93C(uint64_t a1, char *a2, size_t a3)
{
  _QWORD *v5;
  uint64_t v6;
  int v7;
  size_t v8;
  int v9;
  size_t v10;
  uint64_t result;
  int v12;
  size_t v13;
  int v14;
  size_t v15;
  uint64_t v16;
  uint64_t v17;
  unsigned __int8 *v18;
  _QWORD v19[3];

  v5 = krb5_storage_from_data((uint64_t *)(a1 + 8));
  if (!v5)
    return 12;
  v6 = (uint64_t)v5;
  memset(v19, 0, sizeof(v19));
  v17 = 0;
  v18 = 0;
  v16 = 0;
  krb5_storage_set_byteorder((uint64_t)v5, 32);
  krb5_storage_seek(v6);
  krb5_ret_address(v6, (uint64_t)v19);
  krb5_storage_seek(v6);
  krb5_ret_address(v6, (uint64_t)&v16);
  krb5_storage_free(v6);
  v7 = 0;
  if ((_DWORD)v16 == 257 && v17 == 2)
  {
    v15 = 0;
    _krb5_get_int(v18, &v15, 2);
    v7 = (unsigned __int16)v15;
  }
  v8 = strlcpy(a2, "ADDRPORT:", a3);
  v9 = v8;
  v15 = v8;
  if (v8 >= a3)
    v10 = a3;
  else
    v10 = v8;
  result = krb5_print_address((uint64_t)v19, &a2[v10], a3 - v10, &v15);
  if (!(_DWORD)result)
  {
    v12 = v15;
    v13 = v15 + v10;
    if (a3 - v10 <= v15)
      v13 = a3;
    v14 = snprintf(&a2[v13], a3 - v13, ",PORT=%u", v7);
    if (v14 < 0)
      return 0xFFFFFFFFLL;
    else
      return (v14 + v12 + v9);
  }
  return result;
}

krb5_error_code krb5_aname_to_localname(krb5_context a1, krb5_const_principal a2, int a3, char *a4)
{
  size_t v5;
  krb5_error_code default_realms;
  char **v9;
  char *v10;
  krb5_data *data;
  uint64_t v12;
  krb5_magic magic;
  const char *v15;
  krb5_error_code v16;
  krb5_BOOLean v17;
  krb5_principal v18;
  char **v19;

  v5 = *(_QWORD *)&a3;
  v19 = 0;
  default_realms = krb5_get_default_realms((CFArrayRef *)a1, (char *const **)&v19);
  if (!default_realms)
  {
    v9 = v19;
    v10 = *v19;
    if (*v19)
    {
      data = a2->data;
      v12 = 1;
      while (strcmp(v10, (const char *)data))
      {
        v10 = v9[v12++];
        if (!v10)
          goto LABEL_6;
      }
      default_realms = -1765328227;
      krb5_free_host_realm(a1, v9);
      magic = a2->realm.magic;
      if (magic == 2)
      {
        if (strcmp(*((const char **)a2->realm.data + 1), "root"))
          return default_realms;
        v18 = 0;
        v16 = krb5_copy_principal(a1, a2, &v18);
        if (v16)
          return v16;
        v15 = "root";
        v17 = krb5_kuserok(a1, v18, "root");
        krb5_free_principal(a1, v18);
        if (!v17)
          return default_realms;
      }
      else
      {
        if (magic != 1)
          return default_realms;
        v15 = *(const char **)a2->realm.data;
      }
      if (strlen(v15) >= v5)
      {
        return 34;
      }
      else
      {
        strlcpy(a4, v15, v5);
        return 0;
      }
    }
    else
    {
LABEL_6:
      default_realms = -1765328227;
      krb5_free_host_realm(a1, v9);
    }
  }
  return default_realms;
}

void krb5_appdefault_BOOLean(krb5_context context, const char *appname, const krb5_data *realm, const char *option, int default_value, int *ret_value)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v9;
  const char *v11;
  _BOOL8 BOOL_default;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  _BOOL8 v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  _BOOL8 v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  _BOOL8 v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  _BOOL8 v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  _BOOL4 v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;

  v9 = *(_QWORD *)&default_value;
  v11 = appname;
  if (!appname)
    v11 = getprogname();
  BOOL_default = krb5_config_get_BOOL_default((uint64_t)context, 0, v9, (uint64_t)option, *(uint64_t *)&default_value, (uint64_t)ret_value, v6, v7, (uint64_t)"libdefaults");
  if (realm)
  {
    v19 = krb5_config_get_BOOL_default((uint64_t)context, 0, BOOL_default, v14, v15, v16, v17, v18, (uint64_t)"realms");
    v25 = krb5_config_get_BOOL_default((uint64_t)context, 0, v19, v20, v21, v22, v23, v24, (uint64_t)"appdefaults");
    v31 = krb5_config_get_BOOL_default((uint64_t)context, 0, v25, v26, v27, v28, v29, v30, (uint64_t)"appdefaults");
    if (v11)
    {
      v37 = krb5_config_get_BOOL_default((uint64_t)context, 0, v31, v32, v33, v34, v35, v36, (uint64_t)"appdefaults");
      v43 = krb5_config_get_BOOL_default((uint64_t)context, 0, v37, v38, v39, v40, v41, v42, (uint64_t)"appdefaults");
LABEL_8:
      LODWORD(v31) = v43;
    }
  }
  else
  {
    v31 = krb5_config_get_BOOL_default((uint64_t)context, 0, BOOL_default, v14, v15, v16, v17, v18, (uint64_t)"appdefaults");
    if (v11)
    {
      v43 = krb5_config_get_BOOL_default((uint64_t)context, 0, v31, v44, v45, v46, v47, v48, (uint64_t)"appdefaults");
      goto LABEL_8;
    }
  }
  *ret_value = v31;
}

void krb5_appdefault_string(krb5_context context, const char *appname, const krb5_data *realm, const char *option, const char *default_value, char **ret_value)
{
  uint64_t v6;
  uint64_t v7;
  const char *v11;
  uint64_t string_default;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  const char *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  char *v49;

  v11 = appname;
  if (!appname)
    v11 = getprogname();
  string_default = krb5_config_get_string_default((uint64_t)context, 0, (uint64_t)default_value, (uint64_t)option, (uint64_t)default_value, (uint64_t)ret_value, v6, v7, (uint64_t)"libdefaults");
  if (realm)
  {
    v19 = krb5_config_get_string_default((uint64_t)context, 0, string_default, v14, v15, v16, v17, v18, (uint64_t)"realms");
    v25 = krb5_config_get_string_default((uint64_t)context, 0, v19, v20, v21, v22, v23, v24, (uint64_t)"appdefaults");
    v31 = (const char *)krb5_config_get_string_default((uint64_t)context, 0, v25, v26, v27, v28, v29, v30, (uint64_t)"appdefaults");
    if (!v11)
      goto LABEL_9;
    v37 = krb5_config_get_string_default((uint64_t)context, 0, (uint64_t)v31, v32, v33, v34, v35, v36, (uint64_t)"appdefaults");
    v43 = krb5_config_get_string_default((uint64_t)context, 0, v37, v38, v39, v40, v41, v42, (uint64_t)"appdefaults");
  }
  else
  {
    v31 = (const char *)krb5_config_get_string_default((uint64_t)context, 0, string_default, v14, v15, v16, v17, v18, (uint64_t)"appdefaults");
    if (!v11)
      goto LABEL_9;
    v43 = krb5_config_get_string_default((uint64_t)context, 0, (uint64_t)v31, v44, v45, v46, v47, v48, (uint64_t)"appdefaults");
  }
  v31 = (const char *)v43;
LABEL_9:
  if (v31)
    v49 = strdup(v31);
  else
    v49 = 0;
  *ret_value = v49;
}

void krb5_appdefault_time(_krb5_context *a1, const char *a2, const krb5_data *a3, const char *a4, uint64_t a5, _QWORD *a6)
{
  char *v8;
  krb5_error_code v9;
  uint64_t v10;
  char *v11;
  krb5_deltat v12[2];

  v11 = 0;
  *(_QWORD *)v12 = 0;
  krb5_appdefault_string(a1, a2, a3, a4, 0, &v11);
  v8 = v11;
  if (v11)
  {
    v9 = krb5_string_to_deltat(v11, v12);
    v10 = *(_QWORD *)v12;
    if (v9)
      v10 = a5;
    *a6 = v10;
    free(v8);
  }
  else
  {
    *a6 = a5;
  }
}

uint64_t _krb5_principal2principalname()
{
  return sub_2096BB494();
}

uint64_t _krb5_principalname2krb5_principal(uint64_t a1, _QWORD *a2, uint64_t a3, const char *a4)
{
  _QWORD *v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  char *v10;

  v6 = malloc_type_malloc(0x20uLL, 0x10900408A8AD7E9uLL);
  if (!v6)
    return 12;
  v7 = v6;
  v8 = sub_2096BB494();
  if (!(_DWORD)v8)
  {
    v10 = strdup(a4);
    v7[3] = v10;
    if (v10)
    {
      v9 = 0;
      *a2 = v7;
      return v9;
    }
    sub_2096BB484();
    free(v7);
    return 12;
  }
  v9 = v8;
  free(v7);
  return v9;
}

krb5_error_code krb5_auth_con_init(krb5_context a1, krb5_auth_context *a2)
{
  _OWORD *v4;
  _OWORD *v5;
  _QWORD *v6;
  krb5_error_code v7;

  v4 = malloc_type_calloc(1uLL, 0x70uLL, 0x10A004051926EB3uLL);
  if (v4)
  {
    v5 = v4;
    v4[5] = 0u;
    v4[6] = 0u;
    v4[3] = 0u;
    v4[4] = 0u;
    v4[1] = 0u;
    v4[2] = 0u;
    *v4 = 0u;
    v6 = malloc_type_calloc(1uLL, 0x58uLL, 0x10B0040F0B9F0F0uLL);
    *((_QWORD *)v5 + 8) = v6;
    if (v6)
    {
      v7 = 0;
      v6[10] = 0;
      *((_OWORD *)v6 + 3) = 0u;
      *((_OWORD *)v6 + 4) = 0u;
      *((_OWORD *)v6 + 1) = 0u;
      *((_OWORD *)v6 + 2) = 0u;
      *(_OWORD *)v6 = 0u;
      *(_DWORD *)v5 = 1;
      *((_QWORD *)v5 + 1) = 0;
      *((_QWORD *)v5 + 2) = 0;
      *((_DWORD *)v5 + 6) = 0;
      *((_QWORD *)v5 + 12) = 0;
      *((_QWORD *)v5 + 13) = 0;
      *((_QWORD *)v5 + 11) = 0;
      *a2 = (krb5_auth_context)v5;
    }
    else
    {
      v7 = 12;
      krb5_set_error_message(a1, 12, "malloc: out of memory");
      free(v5);
    }
  }
  else
  {
    v7 = 12;
    krb5_set_error_message(a1, 12, "malloc: out of memory");
  }
  return v7;
}

krb5_error_code krb5_auth_con_free(krb5_context a1, krb5_auth_context a2)
{
  if (a2)
  {
    krb5_free_authenticator(a1, (krb5_authenticator *)((char *)a2 + 64));
    if (*((_QWORD *)a2 + 1))
    {
      sub_2096BB51C();
      free(*((void **)a2 + 1));
    }
    if (*((_QWORD *)a2 + 2))
    {
      sub_2096BB51C();
      free(*((void **)a2 + 2));
    }
    krb5_free_keyblock(a1, *((krb5_keyblock **)a2 + 4));
    krb5_free_keyblock(a1, *((krb5_keyblock **)a2 + 6));
    krb5_free_keyblock(a1, *((krb5_keyblock **)a2 + 5));
    if (*((_QWORD *)a2 + 12))
    {
      sub_2096BB628();
      free(*((void **)a2 + 12));
    }
    if (*((_QWORD *)a2 + 13))
      sub_2096AE778(a1, (uint64_t)a2);
    *((_OWORD *)a2 + 5) = 0u;
    *((_OWORD *)a2 + 6) = 0u;
    *((_OWORD *)a2 + 3) = 0u;
    *((_OWORD *)a2 + 4) = 0u;
    *((_OWORD *)a2 + 1) = 0u;
    *((_OWORD *)a2 + 2) = 0u;
    *(_OWORD *)a2 = 0u;
    free(a2);
  }
  return 0;
}

void krb5_free_authenticator(krb5_context a1, krb5_authenticator *a2)
{
  uint64_t v3;

  if (a2)
  {
    sub_2096BB930();
    v3 = *(_QWORD *)&a2->magic;
    *(_QWORD *)(v3 + 80) = 0;
    *(_OWORD *)(v3 + 48) = 0u;
    *(_OWORD *)(v3 + 64) = 0u;
    *(_OWORD *)(v3 + 16) = 0u;
    *(_OWORD *)(v3 + 32) = 0u;
    *(_OWORD *)v3 = 0u;
    free(*(void **)&a2->magic);
    *(_QWORD *)&a2->magic = 0;
  }
}

krb5_error_code krb5_auth_con_setflags(krb5_context a1, krb5_auth_context a2, krb5_int32 a3)
{
  *(_DWORD *)a2 = a3;
  return 0;
}

krb5_error_code krb5_auth_con_getflags(krb5_context a1, krb5_auth_context a2, krb5_int32 *a3)
{
  *a3 = *(_DWORD *)a2;
  return 0;
}

uint64_t krb5_auth_con_addflags(uint64_t a1, _DWORD *a2, int a3, _DWORD *a4)
{
  if (a4)
    *a4 = *a2;
  *a2 |= a3;
  return 0;
}

uint64_t krb5_auth_con_removeflags(uint64_t a1, _DWORD *a2, int a3, _DWORD *a4)
{
  if (a4)
    *a4 = *a2;
  *a2 &= ~a3;
  return 0;
}

void sub_20967D228(uint64_t a1, uint64_t a2, char a3)
{
  uint64_t v6;
  uint64_t v7;

  if ((a3 & 1) != 0)
  {
    v6 = *(_QWORD *)(a2 + 8);
    if (v6)
    {
      krb5_free_address(a1, v6);
      free(*(void **)(a2 + 8));
      *(_QWORD *)(a2 + 8) = 0;
    }
  }
  if ((a3 & 2) != 0)
  {
    v7 = *(_QWORD *)(a2 + 16);
    if (v7)
    {
      krb5_free_address(a1, v7);
      free(*(void **)(a2 + 16));
      *(_QWORD *)(a2 + 16) = 0;
    }
  }
}

krb5_error_code krb5_auth_con_setaddrs(krb5_context a1, krb5_auth_context a2, krb5_address *a3, krb5_address *a4)
{
  uint64_t v8;
  void *v9;
  uint64_t v10;
  void *v11;

  if (a3)
  {
    v8 = *((_QWORD *)a2 + 1);
    if (v8)
    {
      krb5_free_address((uint64_t)a1, v8);
    }
    else
    {
      v9 = malloc_type_malloc(0x18uLL, 0x10800404ACF7207uLL);
      *((_QWORD *)a2 + 1) = v9;
      if (!v9)
        return 12;
    }
    krb5_copy_address((uint64_t)a1, a3);
  }
  if (!a4)
    return 0;
  v10 = *((_QWORD *)a2 + 2);
  if (v10)
  {
    krb5_free_address((uint64_t)a1, v10);
LABEL_10:
    krb5_copy_address((uint64_t)a1, a4);
    return 0;
  }
  v11 = malloc_type_malloc(0x18uLL, 0x10800404ACF7207uLL);
  *((_QWORD *)a2 + 2) = v11;
  if (v11)
    goto LABEL_10;
  return 12;
}

krb5_error_code krb5_auth_con_genaddrs(krb5_context a1, krb5_auth_context a2, int a3, int a4)
{
  char v4;
  krb5_address *v8;
  krb5_address *v9;
  int v10;
  _WORD *v12;
  int v13;
  _WORD *v14;
  socklen_t v15;
  _QWORD v16[3];
  _QWORD v17[3];
  char __strerrbuf[128];
  sockaddr v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  sockaddr v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  uint64_t v35;

  v4 = a4;
  v8 = 0;
  v35 = *MEMORY[0x24BDAC8D0];
  memset(v17, 0, sizeof(v17));
  memset(v16, 0, sizeof(v16));
  v33 = 0u;
  v34 = 0u;
  v31 = 0u;
  v32 = 0u;
  v29 = 0u;
  v30 = 0u;
  v27 = (sockaddr)0;
  v28 = 0u;
  v25 = 0u;
  v26 = 0u;
  v23 = 0u;
  v24 = 0u;
  v21 = 0u;
  v22 = 0u;
  v19 = (sockaddr)0;
  v20 = 0u;
  v15 = 0;
  if ((a4 & 1) == 0)
  {
LABEL_4:
    if ((a4 & 4) == 0)
    {
LABEL_5:
      v9 = 0;
      goto LABEL_6;
    }
LABEL_18:
    v15 = 128;
    if (getpeername(a3, &v19, &v15) < 0)
    {
      v10 = *__error();
      strerror_r(v10, __strerrbuf, 0x80uLL);
      krb5_set_error_message(a1, v10, "getpeername: %s", __strerrbuf);
    }
    else
    {
      v13 = krb5_sockaddr2address(a1, (uint64_t)&v19, (uint64_t)v16);
      if (!v13)
      {
        v14 = (_WORD *)((char *)a2 + 26);
        if ((v4 & 0xC) != 0)
          krb5_sockaddr2port(a1, (uint64_t)&v19, (uint64_t)v14);
        else
          *v14 = 0;
        v9 = (krb5_address *)v16;
LABEL_6:
        v10 = krb5_auth_con_setaddrs(a1, a2, v8, v9);
        if (!v8)
          goto LABEL_8;
        goto LABEL_7;
      }
      v10 = v13;
    }
    v9 = 0;
    if (!v8)
    {
LABEL_8:
      if (v9)
        krb5_free_address((uint64_t)a1, (uint64_t)v9);
      return v10;
    }
LABEL_7:
    krb5_free_address((uint64_t)a1, (uint64_t)v8);
    goto LABEL_8;
  }
  if (*((_QWORD *)a2 + 1))
  {
    v8 = 0;
    goto LABEL_4;
  }
  v15 = 128;
  if (getsockname(a3, &v27, &v15) < 0)
  {
    v10 = *__error();
    strerror_r(v10, __strerrbuf, 0x80uLL);
    krb5_set_error_message(a1, v10, "getsockname: %s", __strerrbuf);
    return v10;
  }
  v10 = krb5_sockaddr2address(a1, (uint64_t)&v27, (uint64_t)v17);
  if (!v10)
  {
    v12 = (_WORD *)((char *)a2 + 24);
    if ((v4 & 3) != 0)
      krb5_sockaddr2port(a1, (uint64_t)&v27, (uint64_t)v12);
    else
      *v12 = 0;
    v8 = (krb5_address *)v17;
    if ((v4 & 4) == 0)
      goto LABEL_5;
    goto LABEL_18;
  }
  return v10;
}

uint64_t krb5_auth_con_setaddrs_from_fd(_krb5_context *a1, _krb5_auth_context *a2, int *a3)
{
  int v3;
  int v4;
  int v5;

  v3 = *a3;
  if (*((_QWORD *)a2 + 1))
    v4 = 0;
  else
    v4 = 3;
  if (*((_QWORD *)a2 + 2))
    v5 = v4;
  else
    v5 = v4 | 0xC;
  return krb5_auth_con_genaddrs(a1, a2, v3, v5);
}

krb5_error_code krb5_auth_con_getaddrs(krb5_context a1, krb5_auth_context a2, krb5_address **a3, krb5_address **a4)
{
  krb5_address *v8;
  krb5_address *v9;
  krb5_error_code v10;

  if (*a3)
    krb5_free_address((uint64_t)a1, (uint64_t)*a3);
  v8 = (krb5_address *)malloc_type_malloc(0x18uLL, 0x10800404ACF7207uLL);
  *a3 = v8;
  if (v8)
  {
    krb5_copy_address((uint64_t)a1, *((_DWORD **)a2 + 1));
    if (*a4)
      krb5_free_address((uint64_t)a1, (uint64_t)*a4);
    v9 = (krb5_address *)malloc_type_malloc(0x18uLL, 0x10800404ACF7207uLL);
    *a4 = v9;
    if (v9)
    {
      krb5_copy_address((uint64_t)a1, *((_DWORD **)a2 + 2));
      return 0;
    }
    else
    {
      v10 = 12;
      krb5_set_error_message(a1, 12, "malloc: out of memory");
      krb5_free_address((uint64_t)a1, (uint64_t)*a3);
      *a3 = 0;
    }
  }
  else
  {
    v10 = 12;
    krb5_set_error_message(a1, 12, "malloc: out of memory");
  }
  return v10;
}

krb5_error_code krb5_auth_con_getkey(krb5_context a1, krb5_auth_context a2, krb5_keyblock **a3)
{
  const krb5_keyblock *v3;

  v3 = (const krb5_keyblock *)*((_QWORD *)a2 + 4);
  if (v3)
    return krb5_copy_keyblock(a1, v3, a3);
  *a3 = 0;
  return 0;
}

uint64_t krb5_auth_con_getlocalsubkey(_krb5_context *a1, uint64_t a2, krb5_keyblock **a3)
{
  const krb5_keyblock *v3;

  v3 = *(const krb5_keyblock **)(a2 + 40);
  if (v3)
    return krb5_copy_keyblock(a1, v3, a3);
  *a3 = 0;
  return 0;
}

uint64_t krb5_auth_con_getremotesubkey(_krb5_context *a1, uint64_t a2, krb5_keyblock **a3)
{
  const krb5_keyblock *v3;

  v3 = *(const krb5_keyblock **)(a2 + 48);
  if (v3)
    return krb5_copy_keyblock(a1, v3, a3);
  *a3 = 0;
  return 0;
}

uint64_t krb5_auth_con_setkey(krb5_context a1, krb5_keyblock **a2, krb5_keyblock *a3)
{
  krb5_keyblock *v5;
  krb5_keyblock **v6;

  v6 = a2 + 4;
  v5 = a2[4];
  if (v5)
    krb5_free_keyblock(a1, v5);
  if (a3)
    return krb5_copy_keyblock(a1, a3, v6);
  *v6 = 0;
  return 0;
}

uint64_t krb5_auth_con_setlocalsubkey(krb5_context a1, krb5_keyblock **a2, krb5_keyblock *a3)
{
  krb5_keyblock *v5;
  krb5_keyblock **v6;

  v6 = a2 + 5;
  v5 = a2[5];
  if (v5)
    krb5_free_keyblock(a1, v5);
  if (a3)
    return krb5_copy_keyblock(a1, a3, v6);
  *v6 = 0;
  return 0;
}

uint64_t krb5_auth_con_generatelocalsubkey(_krb5_context *a1, uint64_t a2, unsigned int *a3)
{
  uint64_t v5;
  krb5_keyblock *v6;
  void *v8;

  v8 = 0;
  v5 = krb5_generate_subkey_extended(a1, a3, (char *)*(unsigned int *)(a2 + 88), &v8);
  if (!(_DWORD)v5)
  {
    v6 = *(krb5_keyblock **)(a2 + 40);
    if (v6)
      krb5_free_keyblock(a1, v6);
    *(_QWORD *)(a2 + 40) = v8;
  }
  return v5;
}

uint64_t krb5_auth_con_setremotesubkey(krb5_context a1, krb5_keyblock **a2, krb5_keyblock *a3)
{
  krb5_keyblock *v5;
  krb5_keyblock **v6;

  v6 = a2 + 6;
  v5 = a2[6];
  if (v5)
    krb5_free_keyblock(a1, v5);
  if (a3)
    return krb5_copy_keyblock(a1, a3, v6);
  *v6 = 0;
  return 0;
}

uint64_t krb5_auth_con_setcksumtype(uint64_t a1, uint64_t a2, int a3)
{
  *(_DWORD *)(a2 + 92) = a3;
  return 0;
}

uint64_t krb5_auth_con_getcksumtype(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  *a3 = *(_DWORD *)(a2 + 92);
  return 0;
}

uint64_t krb5_auth_con_setkeytype(uint64_t a1, uint64_t a2, int a3)
{
  *(_DWORD *)(a2 + 88) = a3;
  return 0;
}

uint64_t krb5_auth_con_getkeytype(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  *a3 = *(_DWORD *)(a2 + 88);
  return 0;
}

krb5_error_code krb5_auth_con_getlocalseqnumber(krb5_context a1, krb5_auth_context a2, krb5_int32 *a3)
{
  *a3 = *((_DWORD *)a2 + 14);
  return 0;
}

uint64_t krb5_auth_con_setlocalseqnumber(uint64_t a1, uint64_t a2, int a3)
{
  *(_DWORD *)(a2 + 56) = a3;
  return 0;
}

krb5_error_code krb5_auth_con_getremoteseqnumber(krb5_context a1, krb5_auth_context a2, krb5_int32 *a3)
{
  *a3 = *((_DWORD *)a2 + 15);
  return 0;
}

uint64_t krb5_auth_con_setremoteseqnumber(uint64_t a1, uint64_t a2, int a3)
{
  *(_DWORD *)(a2 + 60) = a3;
  return 0;
}

krb5_error_code krb5_auth_con_getauthenticator(krb5_context a1, krb5_auth_context a2, krb5_authenticator **a3)
{
  krb5_authenticator *v5;

  v5 = (krb5_authenticator *)malloc_type_malloc(0x58uLL, 0x10B0040F0B9F0F0uLL);
  *a3 = v5;
  if (v5)
    return sub_2096BB940();
  krb5_set_error_message(a1, 12, "malloc: out of memory");
  return 12;
}

uint64_t krb5_auth_con_setuserkey(krb5_context a1, krb5_keyblock **a2, krb5_keyblock *a3)
{
  krb5_keyblock *v5;
  krb5_keyblock **v6;

  v6 = a2 + 4;
  v5 = a2[4];
  if (v5)
    krb5_free_keyblock(a1, v5);
  return krb5_copy_keyblock(a1, a3, v6);
}

krb5_error_code krb5_auth_con_getrcache(krb5_context a1, krb5_auth_context a2, krb5_rcache *a3)
{
  *a3 = (krb5_rcache)*((_QWORD *)a2 + 10);
  return 0;
}

krb5_error_code krb5_auth_con_setrcache(krb5_context a1, krb5_auth_context a2, krb5_rcache a3)
{
  *((_QWORD *)a2 + 10) = a3;
  return 0;
}

uint64_t krb5_auth_con_add_AuthorizationData(_krb5_context *a1, uint64_t a2)
{
  unsigned int *v3;

  v3 = *(unsigned int **)(a2 + 96);
  if (v3)
    return sub_2096BB64C(v3);
  v3 = (unsigned int *)malloc_type_calloc(1uLL, 0x10uLL, 0x1020040D5A9D86FuLL);
  *(_QWORD *)(a2 + 96) = v3;
  if (v3)
    return sub_2096BB64C(v3);
  else
    return krb5_enomem(a1);
}

uint64_t krb5_build_ap_req(_krb5_context *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v9;
  uint64_t v10;
  size_t v11;
  void *v12;
  uint64_t v13;

  v9 = decode_Ticket();
  if (!(_DWORD)v9)
  {
    v11 = sub_2096BBDC0();
    *(_QWORD *)a7 = v11;
    v12 = malloc_type_malloc(v11, 0x2D20C3DFuLL);
    *(_QWORD *)(a7 + 8) = v12;
    if (v12)
    {
      v13 = sub_2096BBDA0();
      if (!(_DWORD)v13)
      {
        if (*(_QWORD *)a7)
          krb5_abortx(a1, "internal error in ASN.1 encoder");
        v10 = 0;
        goto LABEL_10;
      }
      v10 = v13;
      free(*(void **)(a7 + 8));
      *(_QWORD *)(a7 + 8) = 0;
    }
    else
    {
      v10 = 12;
    }
    krb5_data_zero((_QWORD *)a7);
LABEL_10:
    sub_2096BBDD0();
    return v10;
  }
  v10 = v9;
  krb5_data_zero((_QWORD *)a7);
  return v10;
}

uint64_t _krb5_build_authenticator(_krb5_context *a1, uint64_t a2, char *a3, uint64_t a4, uint64_t a5, void *a6, void *a7)
{
  uint64_t v14;
  uint64_t v15;
  void *v16;
  _DWORD *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  krb5_encrypt_block *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  unsigned int *v34;
  uint64_t v35;
  krb5_encrypt_block *v36;
  uint64_t v37;
  char v38;
  krb5_keyblock **v39;
  krb5_encrypt_block *v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  unsigned int *v46;
  _QWORD v47[2];

  v39 = 0;
  v40 = 0;
  v41 = 0u;
  v42 = 0u;
  v43 = 0u;
  v44 = 0u;
  v45 = 0u;
  v46 = 0;
  v47[0] = 0;
  v47[1] = 0;
  LODWORD(v41) = 5;
  v14 = sub_2096BB420();
  if ((_DWORD)v14)
    goto LABEL_4;
  v14 = sub_2096BB494();
  if ((_DWORD)v14)
    goto LABEL_4;
  krb5_us_timeofday(a1, (krb5_timestamp *)&v44 + 2, (krb5_int32 *)&v44);
  v14 = krb5_auth_con_getlocalsubkey(a1, a2, (krb5_keyblock **)&v45);
  if ((_DWORD)v14)
    goto LABEL_4;
  if ((*(_BYTE *)a2 & 4) != 0)
  {
    if (!*(_DWORD *)(a2 + 56))
      krb5_generate_seq_number(a1, a4 + 16, (int *)(a2 + 56));
    v18 = malloc_type_calloc(1uLL, 4uLL, 0x100004052888210uLL);
    *((_QWORD *)&v45 + 1) = v18;
    if (!v18)
      goto LABEL_35;
    *v18 = *(_DWORD *)(a2 + 56);
  }
  else
  {
    *((_QWORD *)&v45 + 1) = 0;
  }
  if (*(_QWORD *)(a2 + 96))
  {
    v46 = (unsigned int *)malloc_type_calloc(1uLL, 0x10uLL, 0x1020040D5A9D86FuLL);
    if (!v46)
      goto LABEL_35;
    v14 = sub_2096BB638();
    if ((_DWORD)v14)
      goto LABEL_4;
  }
  else
  {
    v46 = 0;
  }
  if (*(_QWORD *)(a2 + 104))
  {
    v14 = sub_2096AE8EC(a1, a2, *(const krb5_principal_data **)a4, (unsigned int *)v47);
    if ((_DWORD)v14)
      goto LABEL_4;
  }
  if (!a5)
    goto LABEL_25;
  *((_QWORD *)&v43 + 1) = malloc_type_calloc(1uLL, 0x18uLL, 0x10800404ACF7207uLL);
  if (!*((_QWORD *)&v43 + 1))
  {
LABEL_35:
    v16 = 0;
    goto LABEL_36;
  }
  v14 = sub_2096BB8CC();
  if (!(_DWORD)v14)
  {
    if (**((_DWORD **)&v43 + 1) != 32771
      || (v14 = sub_20967DF54(a1, (unsigned int *)v47, v19, v20, v21, v22, v23, v24), !(_DWORD)v14))
    {
LABEL_25:
      if (LODWORD(v47[0]))
      {
        v25 = (krb5_encrypt_block *)sub_2096BC1C0();
        v16 = malloc_type_malloc((size_t)v25, 0x63D3C43DuLL);
        if (!v16)
          goto LABEL_36;
        v26 = sub_2096BC1A0();
        if ((_DWORD)v26)
        {
LABEL_34:
          v15 = v26;
          free(v16);
          goto LABEL_5;
        }
        if (v25 != v40)
          heim_abort("internal error in ASN.1 encoder:buf_size == len", v27, v28, v29, v30, v31, v32, v33, v38);
        v34 = v46;
        if (!v46)
        {
          v34 = (unsigned int *)malloc_type_calloc(1uLL, 0x10uLL, 0x1020040D5A9D86FuLL);
          v46 = v34;
          if (!v34)
          {
            v37 = krb5_enomem(a1);
            goto LABEL_41;
          }
        }
        v15 = sub_2096BB64C(v34);
        if ((_DWORD)v15)
          goto LABEL_6;
      }
      v35 = *(_QWORD *)(a2 + 64);
      *(_QWORD *)(v35 + 56) = *((_QWORD *)&v44 + 1);
      *(_DWORD *)(v35 + 48) = v44;
      v36 = (krb5_encrypt_block *)sub_2096BB920();
      v16 = malloc_type_malloc((size_t)v36, 0xA3890389uLL);
      if (v16)
      {
        v26 = sub_2096BB900();
        if ((_DWORD)v26)
          goto LABEL_34;
        if (v36 != v40)
          krb5_abortx(a1, "internal error in ASN.1 encoder");
        v37 = krb5_crypto_init(a1, (const krb5_keyblock *)(a4 + 16), a3, &v39);
        if (!(_DWORD)v37)
        {
          v15 = krb5_encrypt(a1, v39, a7, (size_t)v16, v40, a6);
          krb5_crypto_destroy(a1, (uint64_t)v39);
          goto LABEL_6;
        }
LABEL_41:
        v15 = v37;
        goto LABEL_6;
      }
LABEL_36:
      v15 = 12;
      goto LABEL_6;
    }
  }
LABEL_4:
  v15 = v14;
LABEL_5:
  v16 = 0;
LABEL_6:
  sub_2096BB628();
  sub_2096BB930();
  free(v16);
  return v15;
}

uint64_t sub_20967DF54(_krb5_context *a1, unsigned int *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t inited;
  size_t v10;
  void *v11;
  void *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  void *v26;

  v23 = 0;
  v24 = 0;
  v22 = 0;
  inited = _krb5_init_etype(a1, 11, (unsigned int *)&v22, &v23, 0, a6, a7, a8);
  if (!(_DWORD)inited)
  {
    v10 = sub_2096BC180();
    v11 = malloc_type_malloc(v10, 0xDD305473uLL);
    if (!v11)
    {
      inited = 12;
      goto LABEL_6;
    }
    v12 = v11;
    v13 = sub_2096BC160();
    if ((_DWORD)v13)
    {
      inited = v13;
      free(v12);
LABEL_6:
      sub_2096BC190();
      return inited;
    }
    sub_2096BC190();
    if (v10)
      heim_abort("internal error in ASN.1 encoder:buf_size == len", v14, v15, v16, v17, v18, v19, v20, 0);
    LODWORD(v24) = 129;
    v25 = 0;
    v26 = v12;
    inited = sub_2096BB64C(a2);
    free(v12);
  }
  return inited;
}

uint64_t krb5_cc_register(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v5;
  uint64_t v7;
  uint64_t v8;
  const char *v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;

  v5 = *(unsigned int *)(a1 + 176);
  if ((int)v5 < 1)
  {
    LODWORD(v7) = 0;
  }
  else
  {
    v7 = 0;
    v8 = *(_QWORD *)(a1 + 168);
    while (1)
    {
      v9 = *(const char **)(*(_QWORD *)(v8 + 8 * v7) + 8);
      if (!v9)
        break;
      if (!strcmp(v9, *(const char **)(a2 + 8)))
      {
        if (a3)
          break;
        v12 = 2529639103;
        krb5_set_error_message((krb5_context)a1, -1765328193, "cache type %s already exists");
        return v12;
      }
      if (v5 == ++v7)
      {
        LODWORD(v7) = v5;
        goto LABEL_10;
      }
    }
  }
  if ((_DWORD)v7 == (_DWORD)v5)
  {
LABEL_10:
    v10 = malloc_type_realloc(*(void **)(a1 + 168), 8 * ((int)v5 + 1), 0x6004044C4A2DFuLL);
    if (!v10)
    {
      v12 = 2529639110;
      krb5_set_error_message((krb5_context)a1, -1765328186, "malloc: out of memory");
      return v12;
    }
    *(_QWORD *)(a1 + 168) = v10;
    v11 = *(int *)(a1 + 176);
    v10[v11] = 0;
    *(_DWORD *)(a1 + 176) = v11 + 1;
  }
  v12 = 0;
  *(_QWORD *)(*(_QWORD *)(a1 + 168) + 8 * v7) = a2;
  return v12;
}

uint64_t sub_20967E178(_krb5_context *a1, uint64_t a2, _QWORD *a3)
{
  _QWORD *v6;
  uint64_t v7;

  v6 = malloc_type_malloc(0x18uLL, 0x10E0040A403B16CuLL);
  if (v6)
  {
    v7 = 0;
    *v6 = a2;
    *a3 = v6;
  }
  else
  {
    v7 = 2529639110;
    krb5_set_error_message(a1, -1765328186, "malloc: out of memory");
  }
  return v7;
}

krb5_error_code krb5_cc_resolve(krb5_context a1, const char *a2, krb5_ccache *a3)
{
  uint64_t v6;
  uint64_t v7;
  void *v8;
  const char *v9;
  size_t v10;
  void *v12;
  _krb5_context *v13;
  char *v14;

  *a3 = 0;
  v6 = *((unsigned int *)a1 + 44);
  if ((int)v6 >= 1)
  {
    v7 = *((_QWORD *)a1 + 21);
    do
    {
      v8 = *(void **)v7;
      v9 = *(const char **)(*(_QWORD *)v7 + 8);
      if (!v9)
        break;
      v10 = strlen(*(const char **)(*(_QWORD *)v7 + 8));
      if (!strncmp(v9, a2, v10) && a2[v10] == 58)
      {
        v14 = (char *)&a2[v10 + 1];
        v13 = a1;
        v12 = v8;
        return sub_20967E308(v13, (uint64_t)v12, v14, a3);
      }
      v7 += 8;
      --v6;
    }
    while (v6);
  }
  if (strchr((char *)a2, 58))
  {
    krb5_set_error_message(a1, -1765328244, "unknown ccache type %s", a2);
    return -1765328244;
  }
  else
  {
    v12 = &krb5_fcc_ops;
    v13 = a1;
    v14 = (char *)a2;
    return sub_20967E308(v13, (uint64_t)v12, v14, a3);
  }
}

uint64_t sub_20967E308(_krb5_context *a1, uint64_t a2, char *__s1, _QWORD *a4)
{
  uint64_t v7;
  void *v8;
  uint64_t v9;
  void *v11;

  v11 = 0;
  v7 = _krb5_expand_default_cc_name_0(a1, __s1, &v11);
  if (!(_DWORD)v7)
  {
    v8 = v11;
    v9 = sub_20967E178(a1, a2, a4);
    if ((_DWORD)v9)
    {
      v7 = v9;
    }
    else
    {
      v7 = (*(uint64_t (**)(_krb5_context *, _QWORD *, void *))(*(_QWORD *)*a4 + 24))(a1, a4, v8);
      if ((_DWORD)v7)
      {
        free((void *)*a4);
        *a4 = 0;
      }
    }
    if (v11)
      free(v11);
  }
  return v7;
}

krb5_error_code krb5_cc_new_unique(krb5_context context, const char *type, const char *hint, krb5_ccache *id)
{
  void *prefix_ops;
  krb5_error_code v8;

  prefix_ops = krb5_cc_get_prefix_ops((uint64_t)context, (char *)type);
  if (prefix_ops)
  {
    v8 = sub_20967E178(context, (uint64_t)prefix_ops, id);
    if (!v8)
    {
      v8 = (*(uint64_t (**)(krb5_context, krb5_ccache *))(*(_QWORD *)*id + 32))(context, id);
      if (v8)
      {
        free(*id);
        *id = 0;
      }
    }
  }
  else
  {
    v8 = -1765328244;
    krb5_set_error_message(context, -1765328244, "Credential cache type %s is unknown", type);
  }
  return v8;
}

void *krb5_cc_get_prefix_ops(uint64_t a1, char *__s1)
{
  char *v4;
  char *v5;
  char *v6;
  uint64_t v7;
  uint64_t v8;
  const char *v9;

  if (!__s1)
    return &krb5_xcc_ops;
  if (*__s1 == 47)
    return &krb5_fcc_ops;
  v4 = strdup(__s1);
  if (v4)
  {
    v5 = v4;
    v6 = strchr(v4, 58);
    if (v6)
      *v6 = 0;
    v7 = *(unsigned int *)(a1 + 176);
    if ((int)v7 >= 1)
    {
      v8 = *(_QWORD *)(a1 + 168);
      do
      {
        v9 = *(const char **)(*(_QWORD *)v8 + 8);
        if (!v9)
          break;
        if (!strcmp(v9, v5))
        {
          free(v5);
          return *(void **)v8;
        }
        v8 += 8;
        --v7;
      }
      while (v7);
    }
    free(v5);
  }
  else
  {
    krb5_set_error_message((krb5_context)a1, 12, "malloc: out of memory");
  }
  return 0;
}

const char *__cdecl krb5_cc_get_name(krb5_context context, krb5_ccache cache)
{
  return (const char *)(*(uint64_t (**)(krb5_context))(*(_QWORD *)cache + 16))(context);
}

const char *__cdecl krb5_cc_get_type(krb5_context context, krb5_ccache cache)
{
  return *(const char **)(*(_QWORD *)cache + 8);
}

uint64_t krb5_cc_get_full_name(_krb5_context *a1, uint64_t a2, char **a3)
{
  const char *v4;
  const char *v6;
  uint64_t v7;

  *a3 = 0;
  v4 = *(const char **)(*(_QWORD *)a2 + 8);
  if (v4)
  {
    v6 = (const char *)(*(uint64_t (**)(_krb5_context *))(*(_QWORD *)a2 + 16))(a1);
    if (v6)
    {
      if (asprintf(a3, "%s:%s", v4, v6) == -1)
      {
        v7 = 12;
        krb5_set_error_message(a1, 12, "malloc: out of memory");
        *a3 = 0;
      }
      else
      {
        return 0;
      }
    }
    else
    {
      v7 = 2529639051;
      krb5_set_error_message(a1, -1765328245, "cache of type %s have no name");
    }
  }
  else
  {
    v7 = 2529639052;
    krb5_set_error_message(a1, -1765328244, "cache have no name of type");
  }
  return v7;
}

uint64_t krb5_cc_get_ops(uint64_t a1, uint64_t a2)
{
  return *(_QWORD *)a2;
}

uint64_t krb5_cc_switch(uint64_t a1, uint64_t a2)
{
  uint64_t (*v2)(void);

  v2 = *(uint64_t (**)(void))(*(_QWORD *)a2 + 176);
  if (v2)
    return v2();
  else
    return 0;
}

BOOL krb5_cc_support_switch(uint64_t a1, char *a2)
{
  _QWORD *prefix_ops;

  prefix_ops = krb5_cc_get_prefix_ops(a1, a2);
  return prefix_ops && prefix_ops[22];
}

krb5_error_code krb5_cc_set_default_name(krb5_context a1, const char *a2)
{
  char *v3;
  krb5_error_code v4;
  void *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  char *string;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  krb5_error_code v19;
  char *v20;
  char *v21;
  krb5_principal_data *v22;
  krb5_principal v23;
  char *v24;
  char *v25;
  uint64_t (**prefix_ops)(krb5_context, void **);
  krb5_ccache v27;
  char *v28;
  char *v29;
  krb5_ccache id;
  krb5_principal v32;
  void *v33;
  char *v34;

  v34 = 0;
  v33 = 0;
  if (a2)
  {
    v3 = strdup(a2);
    v34 = v3;
    *((_DWORD *)a1 + 80) = 1;
    if (v3)
      goto LABEL_3;
LABEL_33:
    v4 = 12;
    krb5_set_error_message(a1, 12, "malloc: out of memory");
    return v4;
  }
  if (issuid())
    goto LABEL_8;
  v20 = getenv("KRB5CCPRINCIPAL");
  if (v20)
  {
    v21 = v20;
    id = 0;
    v32 = 0;
    if (*v20 == 64)
    {
      v22 = (krb5_principal_data *)malloc_type_calloc(1uLL, 0x20uLL, 0x10900408A8AD7E9uLL);
      v32 = v22;
      if (!v22)
        return krb5_enomem(a1);
      v23 = v22;
      v24 = strdup(v21 + 1);
      v23->data = (krb5_data *)v24;
      if (!v24)
      {
        free(v23);
        return krb5_enomem(a1);
      }
    }
    else
    {
      v4 = krb5_parse_name(a1, v20, &v32);
      if (v4)
        return v4;
      v23 = v32;
    }
    if (!krb5_cc_cache_match(a1, v23, &id))
    {
      v27 = id;
      krb5_cc_get_full_name(a1, (uint64_t)id, &v34);
      (*(void (**)(krb5_context, krb5_ccache))(*(_QWORD *)v27 + 56))(a1, v27);
      free(v27);
    }
    v28 = v34;
    if (v34)
    {
LABEL_26:
      if (*((_QWORD *)a1 + 39))
      {
        free(*((void **)a1 + 39));
        v28 = v34;
      }
      *((_QWORD *)a1 + 39) = strdup(v28);
      goto LABEL_32;
    }
  }
  v29 = getenv("KRB5CCNAME");
  if (v29)
  {
    v28 = strdup(v29);
    v34 = v28;
    if (!v28)
      goto LABEL_32;
    goto LABEL_26;
  }
LABEL_8:
  string = (char *)krb5_config_get_string((uint64_t)a1, 0, v6, v7, v8, v9, v10, v11, (uint64_t)"libdefaults");
  if (string)
  {
    v19 = _krb5_expand_default_cc_name_0(a1, string, (void **)&v34);
  }
  else
  {
    v25 = (char *)krb5_config_get_string((uint64_t)a1, 0, v13, v14, v15, v16, v17, v18, (uint64_t)"libdefaults");
    if (v25)
    {
      prefix_ops = (uint64_t (**)(krb5_context, void **))krb5_cc_get_prefix_ops((uint64_t)a1, v25);
      if (!prefix_ops)
      {
        v4 = -1765328244;
        krb5_set_error_message(a1, -1765328244, "Credential cache type %s is unknown");
        return v4;
      }
    }
    else
    {
      prefix_ops = (uint64_t (**)(krb5_context, void **))&krb5_xcc_ops;
    }
    v19 = prefix_ops[21](a1, (void **)&v34);
  }
  v4 = v19;
  if (v19)
    return v4;
LABEL_32:
  *((_DWORD *)a1 + 80) = 0;
  v3 = v34;
  if (!v34)
    goto LABEL_33;
LABEL_3:
  v4 = _krb5_expand_default_cc_name_0(a1, v3, &v33);
  free(v34);
  if (!v4)
  {
    v5 = (void *)*((_QWORD *)a1 + 38);
    if (v5)
      free(v5);
    v4 = 0;
    *((_QWORD *)a1 + 38) = v33;
  }
  return v4;
}

krb5_error_code krb5_cc_cache_match(krb5_context context, krb5_principal client, krb5_ccache *id)
{
  krb5_error_code v6;
  _krb5_cccol_cursor *v7;
  krb5_error_code v8;
  krb5_ccache v9;
  krb5_ccache v10;
  BOOL v11;
  krb5_ccache v12;
  krb5_BOOLean v13;
  krb5_principal_data *v14;
  const char *v16;
  uint64_t v17;
  krb5_const_principal v18;
  krb5_ccache ccache;
  krb5_cccol_cursor cursor;

  ccache = 0;
  cursor = 0;
  *id = 0;
  v6 = krb5_cccol_cursor_new(context, &cursor);
  if (!v6)
  {
    v7 = cursor;
    v8 = krb5_cccol_cursor_next(context, cursor, &ccache);
    v9 = ccache;
    v10 = 0;
    if (v8)
      v11 = 1;
    else
      v11 = ccache == 0;
    if (!v11)
    {
      while (1)
      {
        v17 = 0;
        v18 = 0;
        if ((*(unsigned int (**)(krb5_context))(*(_QWORD *)v9 + 80))(context)
          || (!client->realm.magic
            ? (krb5_principal_data *)(v14 = (krb5_principal_data *)v18,
                                      v13 = strcmp((const char *)client->data, (const char *)v18->data) == 0)
            : (v13 = krb5_principal_compare(context, v18, client), v14 = (krb5_principal_data *)v18),
              krb5_free_principal(context, v14),
              !v13))
        {
          v12 = ccache;
          if (ccache)
          {
            (*(void (**)(krb5_context, krb5_ccache))(*(_QWORD *)ccache + 56))(context, ccache);
            free(v12);
          }
        }
        else
        {
          if (v10 || !krb5_cc_get_lifetime(context, (uint64_t)ccache, &v17) && v17)
            break;
          v10 = ccache;
        }
        ccache = 0;
        if (!krb5_cccol_cursor_next(context, v7, &ccache))
        {
          v9 = ccache;
          if (ccache)
            continue;
        }
        break;
      }
    }
    krb5_cccol_cursor_free(context, &cursor);
    if (!ccache && v10)
      goto LABEL_24;
    if (v10)
    {
      (*(void (**)(krb5_context, krb5_ccache))(*(_QWORD *)v10 + 56))(context, v10);
      free(v10);
      v10 = ccache;
LABEL_24:
      v6 = 0;
      *id = v10;
      return v6;
    }
    v10 = ccache;
    if (ccache)
      goto LABEL_24;
    v6 = -1765328243;
    v18 = 0;
    krb5_unparse_name(context, client, (char **)&v18);
    v16 = (const char *)v18;
    if (!v18)
      v16 = "<out of memory>";
    krb5_set_error_message(context, -1765328243, "Principal %s not found in any credential cache", v16);
    if (v18)
      free((void *)v18);
  }
  return v6;
}

krb5_error_code krb5_cc_close(krb5_context context, krb5_ccache cache)
{
  krb5_error_code v3;

  v3 = (*(uint64_t (**)(krb5_context))(*(_QWORD *)cache + 56))(context);
  free(cache);
  return v3;
}

const char *__cdecl krb5_cc_default_name(krb5_context a1)
{
  const char *v2;
  char *v3;
  const char *v4;

  v2 = (const char *)*((_QWORD *)a1 + 38);
  if (!v2)
    goto LABEL_14;
  if (*((_DWORD *)a1 + 80))
    return (const char *)*((_QWORD *)a1 + 38);
  if (!strncmp(*((const char **)a1 + 38), "KCM:", 4uLL)
    || !strncmp(v2, "API:", 4uLL)
    || !strncmp(v2, "XCACHE:", 4uLL)
    || !strncmp(v2, "KCC:", 4uLL))
  {
LABEL_14:
    krb5_cc_set_default_name(a1, 0);
    return (const char *)*((_QWORD *)a1 + 38);
  }
  if (issuid())
    return (const char *)*((_QWORD *)a1 + 38);
  v3 = getenv("KRB5CCNAME");
  v4 = (const char *)*((_QWORD *)a1 + 39);
  if (!v3)
  {
    if (!v4)
      return (const char *)*((_QWORD *)a1 + 38);
    free(*((void **)a1 + 39));
    *((_QWORD *)a1 + 39) = 0;
    goto LABEL_14;
  }
  if (!v4 || strcmp(v3, v4))
    goto LABEL_14;
  return (const char *)*((_QWORD *)a1 + 38);
}

krb5_error_code krb5_cc_default(krb5_context a1, krb5_ccache *a2)
{
  const char *v4;

  v4 = krb5_cc_default_name(a1);
  if (v4)
    return krb5_cc_resolve(a1, v4, a2);
  krb5_set_error_message(a1, 12, "malloc: out of memory");
  return 12;
}

krb5_error_code krb5_cc_initialize(krb5_context context, krb5_ccache cache, krb5_principal principal)
{
  return (*(uint64_t (**)(krb5_context))(*(_QWORD *)cache + 40))(context);
}

krb5_error_code krb5_cc_destroy(krb5_context context, krb5_ccache cache)
{
  krb5_error_code v4;

  v4 = (*(uint64_t (**)(void))(*(_QWORD *)cache + 48))();
  (*(void (**)(krb5_context, krb5_ccache))(*(_QWORD *)cache + 56))(context, cache);
  free(cache);
  return v4;
}

krb5_error_code krb5_cc_store_cred(krb5_context context, krb5_ccache cache, krb5_creds *creds)
{
  return (*(uint64_t (**)(krb5_context))(*(_QWORD *)cache + 64))(context);
}

krb5_error_code krb5_cc_retrieve_cred(krb5_context context, krb5_ccache cache, krb5_flags flags, krb5_creds *mcreds, krb5_creds *creds)
{
  uint64_t (*v10)(krb5_context, krb5_ccache, _QWORD, krb5_creds *, krb5_creds *);
  krb5_error_code result;
  char *v12;
  const char *v13;
  char *v14;
  void *v15;

  v10 = *(uint64_t (**)(krb5_context, krb5_ccache, _QWORD, krb5_creds *, krb5_creds *))(*(_QWORD *)cache + 72);
  if (v10)
  {
    result = v10(context, cache, *(_QWORD *)&flags, mcreds, creds);
    goto LABEL_3;
  }
  result = sub_20967EE2C(context, (uint64_t)cache, flags, (uint64_t)mcreds, creds);
  if (result != -1765328242)
    return result;
  if ((flags & 0x200000) != 0)
  {
    result = sub_20967EE2C(context, (uint64_t)cache, flags | 0x80000000, (uint64_t)mcreds, creds);
LABEL_3:
    if (result != -1765328242)
      return result;
  }
  v14 = 0;
  v15 = 0;
  krb5_cc_get_full_name(context, (uint64_t)cache, (char **)&v15);
  krb5_unparse_name(context, mcreds->client, &v14);
  v12 = v14;
  if (!v14)
    v12 = "server";
  v13 = (const char *)v15;
  if (!v15)
    v13 = "unknown";
  krb5_set_error_message(context, -1765328243, "Did not find credential for %s in cache %s", v12, v13);
  free(v15);
  free(v14);
  return -1765328243;
}

uint64_t sub_20967EE2C(_krb5_context *a1, uint64_t a2, int a3, uint64_t a4, krb5_creds *a5)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v13;

  v13 = 0;
  v10 = (*(uint64_t (**)(void))(*(_QWORD *)a2 + 88))();
  if (!(_DWORD)v10)
  {
    v10 = (*(uint64_t (**)(_krb5_context *, uint64_t, uint64_t *, krb5_creds *))(*(_QWORD *)a2 + 96))(a1, a2, &v13, a5);
    if (!(_DWORD)v10)
    {
      do
      {
        if (krb5_compare_creds(a1, a3, a4, (uint64_t)a5))
        {
          v10 = 0;
          goto LABEL_8;
        }
        krb5_free_cred_contents(a1, a5);
        v11 = (*(uint64_t (**)(_krb5_context *, uint64_t, uint64_t *, krb5_creds *))(*(_QWORD *)a2 + 96))(a1, a2, &v13, a5);
      }
      while (!(_DWORD)v11);
      v10 = v11;
    }
LABEL_8:
    (*(void (**)(_krb5_context *, uint64_t, uint64_t *))(*(_QWORD *)a2 + 104))(a1, a2, &v13);
  }
  return v10;
}

krb5_error_code krb5_cc_get_principal(krb5_context context, krb5_ccache cache, krb5_principal *principal)
{
  return (*(uint64_t (**)(krb5_context))(*(_QWORD *)cache + 80))(context);
}

krb5_error_code krb5_cc_start_seq_get(krb5_context context, krb5_ccache cache, krb5_cc_cursor *cursor)
{
  return (*(uint64_t (**)(krb5_context))(*(_QWORD *)cache + 88))(context);
}

krb5_error_code krb5_cc_next_cred(krb5_context context, krb5_ccache cache, krb5_cc_cursor *cursor, krb5_creds *creds)
{
  return (*(uint64_t (**)(krb5_context))(*(_QWORD *)cache + 96))(context);
}

krb5_error_code krb5_cc_end_seq_get(krb5_context context, krb5_ccache cache, krb5_cc_cursor *cursor)
{
  return (*(uint64_t (**)(krb5_context))(*(_QWORD *)cache + 104))(context);
}

krb5_error_code krb5_cc_remove_cred(krb5_context context, krb5_ccache cache, krb5_flags flags, krb5_creds *creds)
{
  uint64_t (*v4)(krb5_context);

  v4 = *(uint64_t (**)(krb5_context))(*(_QWORD *)cache + 112);
  if (v4)
    return v4(context);
  krb5_set_error_message(context, 13, "ccache %s does not support remove_cred", *(const char **)(*(_QWORD *)cache + 8));
  return 13;
}

krb5_error_code krb5_cc_set_flags(krb5_context context, krb5_ccache cache, krb5_flags flags)
{
  return (*(uint64_t (**)(krb5_context))(*(_QWORD *)cache + 120))(context);
}

uint64_t krb5_cc_copy_match_f(_krb5_context *a1, uint64_t a2, uint64_t a3, unsigned int (*a4)(_krb5_context *, uint64_t, _BYTE *), uint64_t a5, _DWORD *a6)
{
  uint64_t v12;
  uint64_t v13;
  int v15;
  krb5_principal v16;
  _BYTE v17[144];
  uint64_t v18;

  if (a6)
    *a6 = 0;
  v18 = 0;
  memset(v17, 0, sizeof(v17));
  v16 = 0;
  v12 = (*(uint64_t (**)(_krb5_context *, uint64_t, krb5_principal *))(*(_QWORD *)a2 + 80))(a1, a2, &v16);
  if (!(_DWORD)v12)
  {
    v13 = (*(uint64_t (**)(_krb5_context *, uint64_t, krb5_principal))(*(_QWORD *)a3 + 40))(a1, a3, v16);
    if ((_DWORD)v13
      || (v13 = (*(uint64_t (**)(_krb5_context *, uint64_t, uint64_t *))(*(_QWORD *)a2 + 88))(a1, a2, &v18),
          (_DWORD)v13))
    {
      v12 = v13;
      krb5_free_principal(a1, v16);
    }
    else
    {
      LODWORD(v12) = (*(uint64_t (**)(_krb5_context *, uint64_t, uint64_t *, _BYTE *))(*(_QWORD *)a2 + 96))(a1, a2, &v18, v17);
      if (!(_DWORD)v12)
      {
        do
        {
          if (!a4 || a4(a1, a5, v17))
          {
            if (a6)
              ++*a6;
            v15 = (*(uint64_t (**)(_krb5_context *, uint64_t, _BYTE *))(*(_QWORD *)a3 + 64))(a1, a3, v17);
            if (v15)
              break;
          }
          krb5_free_cred_contents(a1, (krb5_creds *)v17);
          v15 = (*(uint64_t (**)(_krb5_context *, uint64_t, uint64_t *, _BYTE *))(*(_QWORD *)a2 + 96))(a1, a2, &v18, v17);
        }
        while (!v15);
        LODWORD(v12) = v15;
      }
      (*(void (**)(_krb5_context *, uint64_t, uint64_t *))(*(_QWORD *)a2 + 104))(a1, a2, &v18);
      krb5_free_principal(a1, v16);
      if ((_DWORD)v12 == -1765328242)
        return 0;
      else
        return v12;
    }
  }
  return v12;
}

uint64_t krb5_cc_copy_cache(_krb5_context *a1, uint64_t a2, uint64_t a3)
{
  return krb5_cc_copy_match_f(a1, a2, a3, 0, 0, 0);
}

uint64_t krb5_cc_get_version(uint64_t a1, uint64_t a2)
{
  uint64_t (*v2)(void);

  v2 = *(uint64_t (**)(void))(*(_QWORD *)a2 + 128);
  if (v2)
    return v2();
  else
    return 0;
}

double krb5_cc_clear_mcred(_OWORD *a1)
{
  double result;

  result = 0.0;
  a1[7] = 0u;
  a1[8] = 0u;
  a1[5] = 0u;
  a1[6] = 0u;
  a1[3] = 0u;
  a1[4] = 0u;
  a1[1] = 0u;
  a1[2] = 0u;
  *a1 = 0u;
  return result;
}

uint64_t krb5_cc_cache_get_first(_krb5_context *a1, char *__s1, void **a3)
{
  char *v4;
  _QWORD *prefix_ops;
  _QWORD *v7;
  _QWORD *v8;
  uint64_t v9;

  v4 = __s1;
  if (!__s1)
    v4 = (char *)krb5_cc_default_name(a1);
  prefix_ops = krb5_cc_get_prefix_ops((uint64_t)a1, v4);
  if (prefix_ops)
  {
    v7 = prefix_ops;
    if (prefix_ops[17])
    {
      v8 = malloc_type_calloc(1uLL, 0x10uLL, 0xE00402B90B96AuLL);
      *a3 = v8;
      if (v8)
      {
        *v8 = v7;
        v9 = ((uint64_t (*)(_krb5_context *, uint64_t))v7[17])(a1, (uint64_t)*a3 + 8);
        if ((_DWORD)v9)
        {
          free(*a3);
          *a3 = 0;
        }
      }
      else
      {
        v9 = 12;
        krb5_set_error_message(a1, 12, "malloc: out of memory");
      }
    }
    else
    {
      v9 = 2529639159;
      krb5_set_error_message(a1, -1765328137, "Credential cache type %s doesn't support iterations over caches");
    }
  }
  else
  {
    v9 = 2529639052;
    krb5_set_error_message(a1, -1765328244, "Unknown type \"%s\" when iterating trying to iterate the credential caches");
  }
  return v9;
}

uint64_t krb5_cc_cache_next(uint64_t a1, _QWORD *a2)
{
  return (*(uint64_t (**)(uint64_t, _QWORD))(*a2 + 144))(a1, a2[1]);
}

uint64_t krb5_cc_cache_end_seq_get(uint64_t a1, _QWORD *a2)
{
  uint64_t v3;

  v3 = (*(uint64_t (**)(uint64_t, _QWORD))(*a2 + 152))(a1, a2[1]);
  free(a2);
  return v3;
}

krb5_error_code krb5_cccol_cursor_new(krb5_context context, krb5_cccol_cursor *cursor)
{
  _krb5_cccol_cursor *v4;
  krb5_error_code v5;

  v4 = (_krb5_cccol_cursor *)malloc_type_calloc(1uLL, 0x18uLL, 0x1030040EC63B64AuLL);
  *cursor = v4;
  if (v4)
  {
    v5 = 0;
    *(_DWORD *)v4 = -1;
  }
  else
  {
    v5 = 12;
    krb5_set_error_message(context, 12, "malloc: out of memory");
  }
  return v5;
}

krb5_error_code krb5_cccol_cursor_next(krb5_context context, krb5_cccol_cursor cursor, krb5_ccache *ccache)
{
  int v6;
  char *v7;
  _QWORD *v8;
  int v9;
  int v10;
  void *v11;
  char *v12;
  int v13;
  krb5_ccache v14;
  krb5_error_code v15;
  char *v17;
  char *__s2;

  *ccache = 0;
  v6 = *(_DWORD *)cursor;
  if (*(_DWORD *)cursor == -1)
  {
    v17 = getenv("KRB5CCNAME");
    *(_DWORD *)cursor = 0;
    if (v17)
    {
      if (!krb5_cc_resolve(context, v17, ccache))
      {
        krb5_cc_get_full_name(context, (uint64_t)*ccache, (char **)cursor + 2);
        return 0;
      }
      v6 = *(_DWORD *)cursor;
    }
    else
    {
      v6 = 0;
    }
  }
  if (v6 < *((_DWORD *)context + 44))
  {
    v7 = (char *)cursor + 8;
    do
    {
      v8 = *(_QWORD **)v7;
      if (!*(_QWORD *)v7)
      {
        if (krb5_cc_cache_get_first(context, *(char **)(*(_QWORD *)(*((_QWORD *)context + 21) + 8 * v6) + 8), (void **)cursor + 1))goto LABEL_9;
        v8 = *(_QWORD **)v7;
      }
      v9 = (*(uint64_t (**)(krb5_context, _QWORD, krb5_ccache *))(*v8 + 144))(context, v8[1], ccache);
      if (v9)
      {
        v10 = v9;
        v11 = *(void **)v7;
        (*(void (**)(krb5_context, _QWORD))(**(_QWORD **)v7 + 152))(context, *(_QWORD *)(*(_QWORD *)v7 + 8));
        free(v11);
        *(_QWORD *)v7 = 0;
        if (v10 != -1765328242)
          break;
LABEL_9:
        v6 = *(_DWORD *)cursor + 1;
        *(_DWORD *)cursor = v6;
        continue;
      }
      if (!*((_QWORD *)cursor + 2))
        break;
      __s2 = 0;
      if (krb5_cc_get_full_name(context, (uint64_t)*ccache, &__s2))
        break;
      v12 = __s2;
      v13 = strcmp(*((const char **)cursor + 2), __s2);
      free(v12);
      if (v13)
        break;
      v14 = *ccache;
      (*(void (**)(krb5_context, krb5_ccache))(*(_QWORD *)*ccache + 56))(context, *ccache);
      free(v14);
      *ccache = 0;
      v6 = *(_DWORD *)cursor;
    }
    while (v6 < *((_DWORD *)context + 44));
  }
  if (*(_DWORD *)cursor >= *((_DWORD *)context + 44))
  {
    v15 = -1765328242;
    krb5_set_error_message(context, -1765328242, "Reached end of credential caches");
    return v15;
  }
  return 0;
}

uint64_t krb5_cc_get_lifetime(_krb5_context *a1, uint64_t a2, _QWORD *a3)
{
  time_t v6;
  uint64_t v7;
  uint64_t v8;
  _BOOL8 is_root_krbtgt;
  uint64_t v10;
  krb5_const_principal v14[2];
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  uint64_t v23;

  v23 = 0;
  v21 = 0u;
  v22 = 0u;
  v19 = 0u;
  v20 = 0u;
  v17 = 0u;
  v18 = 0u;
  v15 = 0u;
  v16 = 0u;
  *(_OWORD *)v14 = 0u;
  *a3 = 0;
  v6 = time(0);
  v7 = (*(uint64_t (**)(_krb5_context *, uint64_t, uint64_t *))(*(_QWORD *)a2 + 88))(a1, a2, &v23);
  if (!(_DWORD)v7)
  {
    v7 = (*(uint64_t (**)(_krb5_context *, uint64_t, uint64_t *, krb5_const_principal *))(*(_QWORD *)a2 + 96))(a1, a2, &v23, v14);
    if (!(_DWORD)v7)
    {
      v8 = 0;
      while (1)
      {
        is_root_krbtgt = krb5_principal_is_root_krbtgt((uint64_t)a1, (uint64_t)v14[1]);
        if (is_root_krbtgt)
          break;
        if (!krb5_is_config_principal((krb5_context)is_root_krbtgt, v14[1])
          && (*((uint64_t *)&v17 + 1) < v8 || v8 == 0)
          && v6 < *((_QWORD *)&v17 + 1))
        {
          v8 = *((_QWORD *)&v17 + 1);
        }
        krb5_free_cred_contents(a1, (krb5_creds *)v14);
        v10 = (*(uint64_t (**)(_krb5_context *, uint64_t, uint64_t *, krb5_const_principal *))(*(_QWORD *)a2 + 96))(a1, a2, &v23, v14);
        if ((_DWORD)v10)
        {
          v7 = v10;
          if (!v8)
            goto LABEL_23;
          goto LABEL_22;
        }
      }
      if (v6 < *((uint64_t *)&v17 + 1))
        v8 = *((_QWORD *)&v17 + 1);
      krb5_free_cred_contents(a1, (krb5_creds *)v14);
      v7 = 0;
      if (v8)
      {
LABEL_22:
        v7 = 0;
        *a3 = v8 - v6;
      }
    }
LABEL_23:
    (*(void (**)(_krb5_context *, uint64_t, uint64_t *))(*(_QWORD *)a2 + 104))(a1, a2, &v23);
  }
  return v7;
}

krb5_error_code krb5_cccol_cursor_free(krb5_context context, krb5_cccol_cursor *cursor)
{
  krb5_cccol_cursor v2;
  _QWORD *v3;
  void *v4;

  v2 = *cursor;
  *cursor = 0;
  if (v2)
  {
    v3 = (_QWORD *)*((_QWORD *)v2 + 1);
    if (v3)
    {
      (*(void (**)(krb5_context, _QWORD))(*v3 + 152))(context, v3[1]);
      free(v3);
    }
    v4 = (void *)*((_QWORD *)v2 + 2);
    if (v4)
      free(v4);
    free(v2);
  }
  return 0;
}

krb5_error_code krb5_cc_move(krb5_context context, krb5_ccache src, krb5_ccache dst)
{
  const char *v6;
  uint64_t v7;
  const char *v8;
  int v9;
  uint64_t (*v10)(krb5_context, krb5_ccache);
  int v11;
  krb5_error_code v12;

  v6 = *(const char **)(*(_QWORD *)src + 8);
  v7 = *(_QWORD *)dst;
  v8 = *(const char **)(*(_QWORD *)dst + 8);
  v9 = strcmp(v6, v8);
  v10 = *(uint64_t (**)(krb5_context, krb5_ccache))(v7 + 288);
  if (v9)
  {
    if (!v10)
      goto LABEL_9;
  }
  else if (!v10)
  {
    goto LABEL_6;
  }
  v11 = v10(context, src);
  v7 = *(_QWORD *)dst;
  if (!v11)
  {
    v6 = *(const char **)(*(_QWORD *)src + 8);
    v8 = *(const char **)(v7 + 8);
LABEL_9:
    v12 = -1765328137;
    krb5_set_error_message(context, -1765328137, "Moving credentials between different types not yet supported (from %s to %s)", v6, v8);
    return v12;
  }
LABEL_6:
  v12 = (*(uint64_t (**)(krb5_context, krb5_ccache, krb5_ccache))(v7 + 160))(context, src, dst);
  if (!v12)
  {
    *(_QWORD *)src = 0;
    *((_QWORD *)src + 1) = 0;
    *((_QWORD *)src + 2) = 0;
    free(src);
  }
  return v12;
}

krb5_BOOLean krb5_is_config_principal(krb5_context a1, krb5_const_principal a2)
{
  return !strcmp((const char *)a2->data, "X-CACHECONF:")
      && a2->realm.magic
      && strcmp(*(const char **)a2->realm.data, "krb5_ccache_conf_data") == 0;
}

krb5_error_code krb5_cc_set_config(krb5_context a1, krb5_ccache a2, krb5_const_principal a3, const char *a4, krb5_data *a5)
{
  krb5_error_code v8;
  krb5_error_code v10;
  BOOL v11;
  int v12;
  _BYTE v13[144];

  memset(v13, 0, sizeof(v13));
  v8 = sub_20967F94C(a1, (uint64_t)a2, a3, (uint64_t)a4, (uint64_t)v13);
  if (!v8)
  {
    v10 = krb5_cc_remove_cred(a1, a2, 0, (krb5_creds *)v13);
    v8 = v10;
    if (v10)
      v11 = v10 == -1765328243;
    else
      v11 = 1;
    v12 = v11;
    if (a5)
    {
      if (v12)
      {
        *(_QWORD *)&v13[40] = time(0) - 10;
        *(_QWORD *)&v13[56] = *(_QWORD *)&v13[40];
        v8 = krb5_data_copy(&v13[72], a5->data, *(_QWORD *)&a5->magic);
        if (!v8)
          v8 = (*(uint64_t (**)(krb5_context, krb5_ccache, _BYTE *))(*(_QWORD *)a2 + 64))(a1, a2, v13);
      }
    }
  }
  krb5_free_cred_contents(a1, (krb5_creds *)v13);
  return v8;
}

uint64_t sub_20967F94C(_krb5_context *a1, uint64_t a2, const krb5_principal_data *a3, uint64_t a4, uint64_t a5)
{
  uint64_t principal;
  char *v10;
  krb5_principal_data *v11;
  char *v13;
  krb5_const_principal v14;

  v13 = 0;
  v14 = 0;
  *(_OWORD *)a5 = 0u;
  *(_OWORD *)(a5 + 16) = 0u;
  *(_OWORD *)(a5 + 32) = 0u;
  *(_OWORD *)(a5 + 48) = 0u;
  *(_OWORD *)(a5 + 64) = 0u;
  *(_OWORD *)(a5 + 80) = 0u;
  *(_OWORD *)(a5 + 96) = 0u;
  *(_OWORD *)(a5 + 112) = 0u;
  *(_OWORD *)(a5 + 128) = 0u;
  principal = (*(uint64_t (**)(void))(*(_QWORD *)a2 + 80))();
  if (!(_DWORD)principal)
  {
    if (a3)
    {
      principal = krb5_unparse_name(a1, a3, &v13);
      if ((_DWORD)principal)
        return principal;
      v10 = v13;
    }
    else
    {
      v10 = 0;
    }
    principal = krb5_make_principal(a1, (_QWORD *)(a5 + 8), "X-CACHECONF:", "krb5_ccache_conf_data", a4, v10, 0);
    free(v13);
    v11 = (krb5_principal_data *)v14;
    if (!(_DWORD)principal)
    {
      principal = krb5_copy_principal(a1, v14, (krb5_principal *)a5);
      v11 = (krb5_principal_data *)v14;
    }
    krb5_free_principal(a1, v11);
  }
  return principal;
}

krb5_error_code krb5_cc_get_config(krb5_context a1, krb5_ccache a2, krb5_const_principal a3, const char *a4, krb5_data *a5)
{
  krb5_error_code cred;
  _OWORD v12[4];
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  _BYTE mcreds[144];

  v17 = 0u;
  memset(mcreds, 0, sizeof(mcreds));
  v15 = 0u;
  v16 = 0u;
  v13 = 0u;
  v14 = 0u;
  memset(v12, 0, sizeof(v12));
  krb5_data_zero(a5);
  cred = sub_20967F94C(a1, (uint64_t)a2, a3, (uint64_t)a4, (uint64_t)mcreds);
  if (!cred)
  {
    cred = krb5_cc_retrieve_cred(a1, a2, 0, (krb5_creds *)mcreds, (krb5_creds *)v12);
    if (!cred)
      cred = krb5_data_copy(a5, (const void *)v14, *((size_t *)&v13 + 1));
  }
  krb5_free_cred_contents(a1, (krb5_creds *)v12);
  krb5_free_cred_contents(a1, (krb5_creds *)mcreds);
  return cred;
}

krb5_error_code krb5_cccol_last_change_time(krb5_context context, krb5_timestamp *change_time)
{
  _QWORD *v2;
  _QWORD *v3;
  krb5_error_code result;
  _krb5_cccol_cursor *v7;
  krb5_error_code v8;
  krb5_ccache v9;
  BOOL v10;
  uint64_t v11;
  int v12;
  krb5_ccache v13;
  uint64_t v14;
  krb5_ccache ccache;
  krb5_cccol_cursor cursor;

  v3 = v2;
  ccache = 0;
  cursor = 0;
  v14 = 0;
  *v2 = 0;
  result = krb5_cccol_cursor_new(context, &cursor);
  if (!result)
  {
    v7 = cursor;
    v8 = krb5_cccol_cursor_next(context, cursor, &ccache);
    v9 = ccache;
    if (v8)
      v10 = 1;
    else
      v10 = ccache == 0;
    if (!v10)
    {
      do
      {
        v11 = *(_QWORD *)v9;
        if (!change_time || !strcmp(*(const char **)(v11 + 8), (const char *)change_time))
        {
          v14 = 0;
          v12 = (*(uint64_t (**)(krb5_context, krb5_ccache, uint64_t *))(v11 + 184))(context, v9, &v14);
          v13 = ccache;
          (*(void (**)(krb5_context, krb5_ccache))(*(_QWORD *)ccache + 56))(context, ccache);
          free(v13);
          if (!v12 && v14 > *v3)
            *v3 = v14;
        }
        if (krb5_cccol_cursor_next(context, v7, &ccache))
          break;
        v9 = ccache;
      }
      while (ccache);
    }
    krb5_cccol_cursor_free(context, &cursor);
    return 0;
  }
  return result;
}

uint64_t krb5_cc_get_friendly_name(_krb5_context *a1, _krb5_ccache *a2, char **a3)
{
  uint64_t v6;
  uint64_t v7;
  int v8;
  krb5_const_principal v10;
  krb5_data v11;

  *(_QWORD *)&v11.magic = 0;
  v11.data = 0;
  if (krb5_cc_get_config(a1, a2, 0, "FriendlyName", &v11))
  {
    v10 = 0;
    v6 = (*(uint64_t (**)(_krb5_context *, _krb5_ccache *, krb5_const_principal *))(*(_QWORD *)a2 + 80))(a1, a2, &v10);
    if ((_DWORD)v6)
    {
      return v6;
    }
    else
    {
      v7 = krb5_unparse_name(a1, v10, a3);
      krb5_free_principal(a1, (krb5_principal)v10);
    }
  }
  else
  {
    v8 = asprintf(a3, "%.*s", v11.magic, v11.data);
    krb5_data_free(&v11);
    if (v8 <= 0)
    {
      v7 = 12;
      krb5_set_error_message(a1, 12, "malloc: out of memory");
    }
    else
    {
      return 0;
    }
  }
  return v7;
}

uint64_t krb5_cc_set_friendly_name(_krb5_context *a1, _krb5_ccache *a2, char *__s)
{
  krb5_data v6;

  v6.data = __s;
  *(_QWORD *)&v6.magic = strlen(__s);
  return krb5_cc_set_config(a1, a2, 0, "FriendlyName", &v6);
}

uint64_t krb5_cc_set_kdc_offset(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t (*v3)(void);

  v3 = *(uint64_t (**)(void))(*(_QWORD *)a2 + 192);
  if (v3)
    return v3();
  *(_DWORD *)(a1 + 108) = a3;
  *(_DWORD *)(a1 + 112) = 0;
  return 0;
}

uint64_t krb5_cc_get_kdc_offset(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  uint64_t (*v3)(void);

  v3 = *(uint64_t (**)(void))(*(_QWORD *)a2 + 200);
  if (v3)
    return v3();
  *a3 = *(int *)(a1 + 108);
  return 0;
}

uint64_t krb5_cc_hold(uint64_t a1, uint64_t a2)
{
  uint64_t (*v2)(void);

  v2 = *(uint64_t (**)(void))(*(_QWORD *)a2 + 208);
  if (v2)
    return v2();
  else
    return 0;
}

uint64_t krb5_cc_unhold(uint64_t a1, uint64_t a2)
{
  uint64_t (*v2)(void);

  v2 = *(uint64_t (**)(void))(*(_QWORD *)a2 + 216);
  if (v2)
    return v2();
  else
    return 0;
}

uint64_t krb5_cc_get_uuid(_krb5_context *a1, uint64_t a2)
{
  uint64_t (*v2)(void);

  v2 = *(uint64_t (**)(void))(*(_QWORD *)a2 + 224);
  if (v2)
    return v2();
  krb5_set_error_message(a1, -1765328244, "Credential cache type %s doesn't support uuid", *(const char **)(*(_QWORD *)a2 + 8));
  return 2529639052;
}

uint64_t krb5_cc_resolve_by_uuid(_krb5_context *a1, char *a2, _QWORD *a3)
{
  _QWORD *prefix_ops;
  uint64_t v6;

  if (a2)
  {
    prefix_ops = krb5_cc_get_prefix_ops((uint64_t)a1, a2);
    if (!prefix_ops)
    {
      v6 = 2529639052;
      krb5_set_error_message(a1, -1765328244, "Credential cache type %s is unknown");
      return v6;
    }
  }
  else
  {
    prefix_ops = &krb5_xcc_ops;
  }
  if (prefix_ops[29])
  {
    v6 = sub_20967E178(a1, (uint64_t)prefix_ops, a3);
    if (!(_DWORD)v6)
    {
      v6 = (*(uint64_t (**)(_krb5_context *))(*(_QWORD *)*a3 + 232))(a1);
      if ((_DWORD)v6)
      {
        free((void *)*a3);
        *a3 = 0;
      }
    }
  }
  else
  {
    v6 = 2529639052;
    krb5_set_error_message(a1, -1765328244, "Credential cache type %s doesn't support uuid");
  }
  return v6;
}

uint64_t krb5_cc_set_acl(uint64_t a1, uint64_t a2)
{
  uint64_t (*v2)(void);

  v2 = *(uint64_t (**)(void))(*(_QWORD *)a2 + 256);
  if (v2)
    return v2();
  else
    return 0;
}

krb5_error_code krb5_set_password(krb5_context context, krb5_creds *creds, char *newpw, krb5_principal change_password_for, int *result_code, krb5_data *result_code_string, krb5_data *result_string)
{
  krb5_error_code v13;
  const char **v14;
  unint64_t v15;
  krb5_principal v16;
  char *data;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t ImpersonateBundle;
  char *v25;
  __CFBundle *MainBundle;
  CFStringRef Identifier;
  CFStringRef v28;
  CFStringRef v29;
  krb5_error_code result;
  const char *v31;
  krb5_data *v33;
  krb5_auth_context v34;
  krb5_creds *v35;
  krb5_principal v36;
  char *v37;
  int v38[2];
  _QWORD v39[2];
  _QWORD v40[2];

  *result_code = 1;
  krb5_data_zero(result_code_string);
  v33 = result_string;
  krb5_data_zero(result_string);
  sub_20969D1E8((uint64_t)context, 1, "trying to set password");
  v13 = 0;
  v14 = (const char **)&off_24C1F1910;
  v34 = 0;
  v35 = creds;
  v15 = -1;
  v36 = change_password_for;
  v37 = newpw;
  while (1)
  {
    if (change_password_for && v15 < 2)
      goto LABEL_28;
    v40[0] = 0;
    v40[1] = 0;
    v39[0] = 0;
    v39[1] = 0;
    *(_QWORD *)v38 = 0;
    krb5_data_zero(v40);
    krb5_data_zero(v39);
    v16 = v36;
    if (!v36)
      v16 = *(krb5_principal *)&v35->magic;
    data = (char *)v16->data;
    sub_20969D1E8((uint64_t)context, 1, "trying to set password using: %s in realm %s", *v14, data);
    v13 = krb5_auth_con_init(context, &v34);
    if (!v13)
    {
      krb5_auth_con_setflags(context, v34, 4);
      v13 = krb5_sendto_ctx_alloc((uint64_t)context, (uint64_t)v38, v18, v19, v20, v21, v22, v23);
      if (!v13)
      {
        krb5_sendto_ctx_set_type(*(uint64_t *)v38, 3);
        if (v35->addresses >= (krb5_address **)0x2BD)
        {
          sub_20969D1E8((uint64_t)context, 1, "using TCP since the ticket is large: %lu", v35->addresses);
          krb5_sendto_ctx_add_flags(*(uint64_t *)v38, 2);
        }
        sub_2096AB520(*(uint64_t *)v38, (uint64_t)v14[2], (uint64_t)&v34);
        ImpersonateBundle = HeimCredGetImpersonateBundle();
        if (!ImpersonateBundle)
          goto LABEL_20;
        v25 = (char *)ImpersonateBundle;
        MainBundle = CFBundleGetMainBundle();
        if (!MainBundle)
          goto LABEL_20;
        Identifier = CFBundleGetIdentifier(MainBundle);
        v28 = CFStringCreateWithCString(0, v25, 0x8000100u);
        v29 = v28;
        if (v28 && Identifier)
        {
          if (CFEqual(Identifier, v28))
            sub_20969D1E8((uint64_t)context, 5, "Bundle identifiers match, not setting delegate");
          else
            krb5_sendto_set_delegated_app(0, *(uint64_t *)v38, 0, 0, v25);
        }
        else if (!v28)
        {
LABEL_20:
          v13 = krb5_sendto_context((uint64_t)context, *(uint64_t *)v38, v40, data, v39);
          if (!v13)
            v13 = ((uint64_t (*)(krb5_context, krb5_auth_context, _QWORD *, int *, krb5_data *, krb5_data *))v14[3])(context, v34, v39, result_code, result_code_string, v33);
          goto LABEL_22;
        }
        CFRelease(v29);
        goto LABEL_20;
      }
    }
LABEL_22:
    sub_20969D1E8((uint64_t)context, 1, "set password using %s returned: %d result_code %d", *v14, v13, *result_code);
    krb5_auth_con_free(context, v34);
    if (*(_QWORD *)v38)
      krb5_sendto_ctx_free((uint64_t)context, *(const void **)v38);
    krb5_data_free(v39);
    if (v13 != -1765328228)
      break;
    krb5_set_error_message(context, -1765328228, "Unable to reach any changepw server  in realm %s", data);
    *result_code = 2;
    v13 = -1765328228;
LABEL_28:
    v31 = v14[4];
    v14 += 4;
    ++v15;
    result = v13;
    if (!v31)
      return result;
  }
  if (v13)
    goto LABEL_28;
  result = 0;
  if (*result_code)
    goto LABEL_28;
  return result;
}

krb5_error_code krb5_set_password_using_ccache(krb5_context context, krb5_ccache ccache, char *newpw, krb5_principal change_password_for, int *result_code, krb5_data *result_code_string, krb5_data *result_string)
{
  krb5_principal v14;
  char *realm;
  krb5_error_code credentials;
  krb5_error_code v17;
  krb5_creds *v18;
  krb5_principal v20;
  krb5_creds *creds;
  krb5_principal principal[2];
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;

  v20 = 0;
  creds = 0;
  *result_code = 1;
  krb5_data_zero(result_code_string);
  krb5_data_zero(result_string);
  v29 = 0u;
  v30 = 0u;
  v27 = 0u;
  v28 = 0u;
  v25 = 0u;
  v26 = 0u;
  v23 = 0u;
  v24 = 0u;
  *(_OWORD *)principal = 0u;
  if (change_password_for)
  {
    v20 = change_password_for;
    v14 = change_password_for;
  }
  else
  {
    credentials = krb5_cc_get_principal(context, ccache, &v20);
    if (credentials)
      return credentials;
    v14 = v20;
  }
  realm = (char *)krb5_principal_get_realm((uint64_t)context, (uint64_t)v14);
  credentials = krb5_make_principal(context, &principal[1], realm, "kadmin", "changepw", 0);
  if (!credentials)
  {
    v17 = krb5_cc_get_principal(context, ccache, principal);
    if (v17)
    {
      credentials = v17;
      krb5_free_principal(context, principal[1]);
    }
    else
    {
      credentials = krb5_get_credentials(context, 0, ccache, (krb5_creds *)principal, &creds);
      krb5_free_principal(context, principal[1]);
      krb5_free_principal(context, principal[0]);
      v18 = creds;
      if (!credentials)
      {
        credentials = krb5_set_password(context, creds, newpw, change_password_for, result_code, result_code_string, result_string);
        v18 = creds;
      }
      if (v18)
        krb5_free_creds(context, v18);
    }
  }
  if (!change_password_for)
    krb5_free_principal(context, v20);
  return credentials;
}

const char *krb5_passwd_result_to_string(uint64_t a1, unsigned int a2)
{
  if (a2 <= 7)
    return off_24C1F2288[a2];
  else
    return "unknown result code";
}

uint64_t sub_209680410(_krb5_context *a1, uint64_t a2, uint64_t a3, int a4, size_t *a5)
{
  uint64_t v9;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  krb5_data v16;
  krb5_data v17;
  krb5_data v18;

  *(_QWORD *)&v18.magic = 0;
  v18.data = 0;
  *(_QWORD *)&v17.magic = 0;
  v17.data = 0;
  *(_QWORD *)&v16.magic = 0;
  v16.data = 0;
  krb5_data_zero(&v18);
  krb5_data_zero(&v17);
  krb5_data_zero(&v16);
  v9 = krb5_auth_con_genaddrs(a1, *(krb5_auth_context *)a3, a4, 1);
  if ((_DWORD)v9)
    goto LABEL_3;
  v9 = krb5_mk_req_extended(a1, (krb5_auth_context *)a3, 6, 0, *(krb5_creds **)(a3 + 8), &v18);
  if ((_DWORD)v9)
    goto LABEL_3;
  strlen(*(const char **)(a3 + 24));
  *(_QWORD *)&v16.magic = sub_2096BC120();
  v16.data = (char *)malloc_type_malloc(*(size_t *)&v16.magic, 0x5ECCEB8DuLL);
  if (!v16.data)
    goto LABEL_16;
  v11 = sub_2096BC100();
  if ((_DWORD)v11)
  {
    v9 = v11;
    free(v16.data);
    v16.data = 0;
LABEL_3:
    sub_20969D1E8((uint64_t)a1, 10, "setpw_prexmit failed with %d", v9);
    goto LABEL_4;
  }
  if (*(_QWORD *)&v16.magic)
    krb5_abortx(a1, "internal error in ASN.1 encoder");
  v9 = krb5_mk_priv(a1, *(krb5_auth_context *)a3, &v16, &v17, 0);
  if ((_DWORD)v9)
    goto LABEL_3;
  v12 = krb5_storage_emem();
  if (!v12)
  {
LABEL_16:
    v9 = 12;
    goto LABEL_3;
  }
  v13 = (uint64_t)v12;
  v9 = krb5_store_uint16((uint64_t)v12, LOWORD(v18.magic) + LOWORD(v17.magic) + 6);
  if ((_DWORD)v9
    || (v9 = krb5_store_uint16(v13, 65408), (_DWORD)v9)
    || (v9 = krb5_store_uint16(v13, v18.magic), (_DWORD)v9)
    || (v14 = krb5_storage_write(v13), v9 = 22, v14 < 0)
    || v14 != *(_QWORD *)&v18.magic
    || (v15 = krb5_storage_write(v13), v9 = 22, v15 < 0)
    || v15 != *(_QWORD *)&v17.magic
    || (v9 = krb5_storage_to_data(v13, a5), (_DWORD)v9))
  {
    sub_20969D1E8((uint64_t)a1, 10, "setpw_prexmit failed with %d", v9);
  }
  krb5_storage_free(v13);
LABEL_4:
  krb5_data_free(&v17);
  krb5_data_free(&v18);
  krb5_data_free(&v16);
  return v9;
}

uint64_t sub_20968067C(_krb5_context *a1, _krb5_auth_context *a2, uint64_t *a3, _DWORD *a4, krb5_data *a5, _QWORD *a6)
{
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  const char *v19;
  uint64_t v20;
  unsigned __int8 *v22;
  uint64_t v23;
  unsigned int v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  char *data;
  uint64_t v35;
  krb5_data v36;
  krb5_ap_rep_enc_part *v37;
  krb5_data v38;

  sub_20967D228((uint64_t)a1, (uint64_t)a2, 3);
  v18 = *a3;
  if (*a3 <= 5)
  {
    v35 = *a3;
    v19 = "server sent to too short message (%ld bytes)";
LABEL_3:
    sub_2096875E0(a6, v19, v12, v13, v14, v15, v16, v17, v35);
LABEL_4:
    v20 = 0;
    *a4 = 1;
    return v20;
  }
  v22 = (unsigned __int8 *)a3[1];
  v23 = v22[1];
  if (v18 == (v23 | ((unint64_t)*v22 << 8)) && (v23 | 0x20) != 0x7E)
  {
    v24 = __rev16(*((unsigned __int16 *)v22 + 1));
    if (v24 != 1)
    {
      sub_2096875E0(a6, "client: wrong version number (%d)", v12, v13, v14, v15, v16, v17, v24);
      goto LABEL_4;
    }
    v38.data = (char *)(v22 + 6);
    v25 = __rev16(*((unsigned __int16 *)v22 + 2));
    *(_QWORD *)&v38.magic = v25;
    if (&v22[v18] < &v22[v25 + 6])
    {
      v19 = "client: wrong AP len in reply";
      goto LABEL_3;
    }
    if (v25)
    {
      v36.data = (char *)&v22[v25 + 6];
      v37 = 0;
      *(_QWORD *)&v36.magic = v18 - v25 - 6;
      v20 = krb5_rd_rep(a1, a2, &v38, &v37);
      if (!(_DWORD)v20)
      {
        krb5_free_ap_rep_enc_part(a1, v37);
        v26 = krb5_rd_priv(a1, a2, &v36, a5, 0);
        if ((_DWORD)v26)
        {
          v20 = v26;
          krb5_data_free(a5);
        }
        else
        {
          v33 = *(_QWORD *)&a5->magic;
          if (*(_QWORD *)&a5->magic > 1uLL)
          {
            data = a5->data;
            *a4 = __rev16(*(unsigned __int16 *)data);
            krb5_data_copy(a6, data + 2, v33 - 2);
          }
          else
          {
            *a4 = 1;
            sub_2096875E0(a6, "client: bad length in result", v27, v28, v29, v30, v31, v32, v35);
          }
          return 0;
        }
      }
      return v20;
    }
  }
  return sub_209680A0C();
}

uint64_t sub_209680844(_krb5_context *a1, uint64_t a2, uint64_t a3, int a4, size_t *a5)
{
  uint64_t v9;
  _QWORD *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  krb5_data v15;
  krb5_data v16;
  krb5_data v17;

  *(_QWORD *)&v17.magic = 0;
  v17.data = 0;
  *(_QWORD *)&v16.magic = 0;
  v16.data = 0;
  *(_QWORD *)&v15.magic = 0;
  v15.data = 0;
  krb5_data_zero(&v17);
  krb5_data_zero(&v16);
  v9 = krb5_auth_con_genaddrs(a1, *(krb5_auth_context *)a3, a4, 1);
  if ((_DWORD)v9)
    goto LABEL_4;
  v9 = krb5_mk_req_extended(a1, (krb5_auth_context *)a3, 6, 0, *(krb5_creds **)(a3 + 8), &v17);
  if ((_DWORD)v9)
    goto LABEL_4;
  v15.data = *(char **)(a3 + 24);
  *(_QWORD *)&v15.magic = strlen(v15.data);
  v9 = krb5_mk_priv(a1, *(krb5_auth_context *)a3, &v15, &v16, 0);
  if ((_DWORD)v9)
    goto LABEL_4;
  v11 = krb5_storage_emem();
  if (!v11)
  {
    v9 = 12;
LABEL_4:
    sub_20969D1E8((uint64_t)a1, 10, "chgpw_prexmit failed with: %d", v9);
    goto LABEL_5;
  }
  v12 = (uint64_t)v11;
  v9 = krb5_store_uint16((uint64_t)v11, LOWORD(v17.magic) + LOWORD(v16.magic) + 6);
  if ((_DWORD)v9
    || (v9 = krb5_store_uint16(v12, 1), (_DWORD)v9)
    || (v9 = krb5_store_uint16(v12, v17.magic), (_DWORD)v9)
    || (v13 = krb5_storage_write(v12), v9 = 22, v13 < 0)
    || v13 != *(_QWORD *)&v17.magic
    || (v14 = krb5_storage_write(v12), v9 = 22, v14 < 0)
    || v14 != *(_QWORD *)&v16.magic
    || (v9 = krb5_storage_to_data(v12, a5), (_DWORD)v9))
  {
    sub_20969D1E8((uint64_t)a1, 10, "chgpw_prexmit failed with: %d", v9);
  }
  krb5_storage_free(v12);
LABEL_5:
  krb5_data_free(&v16);
  krb5_data_free(&v17);
  return v9;
}

uint64_t sub_209680A0C()
{
  uint64_t v0;

  v0 = sub_2096BC080();
  if (!(_DWORD)v0)
  {
    v0 = 0;
    sub_2096BC0D0();
  }
  return v0;
}

_QWORD *sub_209680AF4(_QWORD *a1, char *__s1, int a3)
{
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;

  v5 = a1;
  v6 = *a1;
  if (*a1)
  {
    while (1)
    {
      v7 = (_QWORD *)v6;
      if (a3 == 1 && *(_DWORD *)v6 == 1 && !strcmp(__s1, *(const char **)(v6 + 8)))
        break;
      v6 = v7[2];
      if (!v6)
      {
        v5 = v7 + 2;
        goto LABEL_7;
      }
    }
  }
  else
  {
LABEL_7:
    v7 = malloc_type_calloc(1uLL, 0x20uLL, 0x10B20403397373FuLL);
    *v5 = v7;
    if (v7)
    {
      v7[1] = strdup(__s1);
      v7 = (_QWORD *)*v5;
      *(_DWORD *)v7 = a3;
      if (!v7[1])
      {
        free(v7);
        v7 = 0;
        *v5 = 0;
      }
    }
  }
  return v7;
}

uint64_t krb5_config_parse_file_multi(_krb5_context *a1, char *__s1, void *a3)
{
  char *v4;
  uid_t v6;
  passwd *v7;
  char *pw_dir;
  uint64_t v9;
  char *v10;
  size_t v11;
  CFIndex v12;
  _QWORD *v13;
  uint64_t v14;
  char *v15;
  char *v16;
  uint64_t v17;
  int v18;
  uint64_t v20;
  char *v21;
  _QWORD *v22;
  int *v23;
  const char *v24;
  const __CFAllocator *v25;
  const __CFURL *v26;
  const __CFURL *v27;
  __CFReadStream *v28;
  const __CFDictionary *v29;
  const char *v30;
  uint64_t v32;
  char *v33;
  char *v34;
  const char *v35;
  char *v36;
  _QWORD *v37;
  uint64_t v38;
  FILE *v39;
  unsigned int v40;
  char *__s;
  char *v42;
  const char *v43;
  uint64_t v44;
  char __strerrbuf[2048];
  uint64_t v46;

  v4 = __s1;
  v46 = *MEMORY[0x24BDAC8D0];
  v42 = 0;
  v43 = 0;
  __s = 0;
  v40 = 0;
  if (*__s1 == 126 && __s1[1] == 47)
  {
    if (!krb5_homedir_access((uint64_t)a1))
    {
      v9 = 1;
      krb5_set_error_message(a1, 1, "Access to home directory not allowed");
      goto LABEL_56;
    }
    if (!issuid() && (pw_dir = getenv("HOME")) != 0
      || (v6 = getuid(), (v7 = getpwuid(v6)) != 0) && (pw_dir = v7->pw_dir) != 0)
    {
      asprintf(&v42, "%s%s", pw_dir, v4 + 1);
      v4 = v42;
      if (!v42)
      {
        v9 = 12;
        krb5_set_error_message(a1, 12, "malloc: out of memory", v32, v34);
        goto LABEL_56;
      }
    }
  }
  v9 = _krb5_expand_default_cc_name_0(a1, v4, (void **)&__s);
  if ((_DWORD)v9)
    goto LABEL_56;
  v10 = __s;
  v11 = strlen(__s);
  if (v11 >= 7)
  {
    v12 = v11;
    if (!strcasecmp(&__s[v11 - 6], ".plist"))
    {
      v25 = (const __CFAllocator *)*MEMORY[0x24BDBD240];
      v26 = CFURLCreateFromFileSystemRepresentation((CFAllocatorRef)*MEMORY[0x24BDBD240], (const UInt8 *)v10, v12, 0);
      if (v26 && (v27 = v26, v28 = CFReadStreamCreateWithFile(v25, v26), CFRelease(v27), v28))
      {
        if (CFReadStreamOpen(v28))
        {
          v29 = (const __CFDictionary *)CFPropertyListCreateWithStream(0, v28, 0, 0, 0, 0);
          CFRelease(v28);
          if (v29)
          {
            CFDictionaryApplyFunction(v29, (CFDictionaryApplierFunction)sub_209681794, a3);
            CFRelease(v29);
            goto LABEL_37;
          }
        }
        else
        {
          CFRelease(v28);
        }
        v9 = 2;
      }
      else
      {
        v9 = 12;
      }
      krb5_clear_error_message(a1);
      v33 = v10;
      v24 = "Failed to parse plist %s";
      goto LABEL_55;
    }
  }
  v38 = 0;
  v39 = fopen(v10, "r");
  if (!v39)
  {
    v23 = __error();
    v9 = *v23;
    strerror_r(*v23, __strerrbuf, 0x80uLL);
    v33 = v10;
    v34 = __strerrbuf;
    v24 = "open %s: %s";
    goto LABEL_55;
  }
  v36 = v10;
  v37 = a3;
  v44 = 0;
  if (!sub_2096819A8(__strerrbuf, (uint64_t)&v38))
  {
LABEL_36:
    fclose(v39);
LABEL_37:
    v9 = 0;
    goto LABEL_56;
  }
  v13 = 0;
  v14 = MEMORY[0x24BDAC740];
  while (1)
  {
    v15 = (char *)++v40;
    __strerrbuf[strcspn(__strerrbuf, "\r\n")] = 0;
    v16 = __strerrbuf;
    do
    {
      v17 = *v16;
      if (*v16 < 0)
        v18 = __maskrune(*v16, 0x4000uLL);
      else
        v18 = *(_DWORD *)(v14 + 4 * v17 + 60) & 0x4000;
      ++v16;
    }
    while (v18);
    if (v17 <= 0x3B && ((1 << v17) & 0x800000800000001) != 0)
      goto LABEL_35;
    if ((_DWORD)v17 == 91)
      break;
    if ((_DWORD)v17 == 125)
    {
      v30 = "unmatched }";
      goto LABEL_50;
    }
    if (!v13)
    {
      v30 = "binding before section";
      goto LABEL_50;
    }
    v20 = sub_209681A60((uint64_t)&v38, (int *)&v40, v16 - 1, &v44, v13 + 3, &v43);
    if ((_DWORD)v20)
    {
      v9 = v20;
      v15 = (char *)v40;
      v30 = v43;
      goto LABEL_51;
    }
LABEL_35:
    if (!sub_2096819A8(__strerrbuf, (uint64_t)&v38))
      goto LABEL_36;
  }
  v21 = strchr(v16, 93);
  if (!v21)
  {
    v30 = "missing ]";
    goto LABEL_50;
  }
  *v21 = 0;
  v22 = sub_209680AF4(v37, v16, 1);
  if (v22)
  {
    v13 = v22;
    v44 = 0;
    goto LABEL_35;
  }
  v30 = "out of memory";
LABEL_50:
  v43 = v30;
  v9 = 2529639048;
LABEL_51:
  fclose(v39);
  v34 = v15;
  v35 = v30;
  v33 = v36;
  v24 = "%s:%u: %s";
LABEL_55:
  krb5_set_error_message(a1, v9, v24, v33, v34, v35);
LABEL_56:
  if (v42)
    free(v42);
  if (__s)
    free(__s);
  return v9;
}

uint64_t krb5_config_parse_file(_krb5_context *a1, char *__s1, void *a3)
{
  *(_QWORD *)a3 = 0;
  return krb5_config_parse_file_multi(a1, __s1, a3);
}

uint64_t krb5_config_file_free(uint64_t a1, void **a2)
{
  sub_209681008(a1, a2);
  return 0;
}

void sub_209681008(uint64_t a1, void **a2)
{
  void **v2;
  void **v4;

  if (a2)
  {
    v2 = a2;
    do
    {
      free(v2[1]);
      if (*(_DWORD *)v2 == 1)
      {
        sub_209681008(a1, v2[3]);
      }
      else
      {
        if (*(_DWORD *)v2)
          krb5_abortx(a1, "unknown binding type (%d) in free_binding", *(_DWORD *)v2);
        free(v2[3]);
      }
      v4 = (void **)v2[2];
      free(v2);
      v2 = v4;
    }
    while (v4);
  }
}

uint64_t sub_209681094(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5)
{
  int v5;
  uint64_t v7;
  uint64_t v8;
  const char *v9;

  v5 = a4;
  if (!a2)
  {
    a2 = *(_QWORD *)(a1 + 136);
    if (!a2)
      return 0;
  }
  v7 = *a3;
  if (!*a3)
  {
    if (*(_QWORD *)a5)
      return sub_20968114C(a2, a3, a4, *(const char **)a5, (uint64_t *)(a5 + 8));
    return 0;
  }
  v8 = *(_QWORD *)(v7 + 16);
  if (!v8)
    return 0;
  v9 = *(const char **)(v7 + 8);
  while (strcmp(*(const char **)(v8 + 8), v9) || *(_DWORD *)v8 != v5)
  {
    v8 = *(_QWORD *)(v8 + 16);
    if (!v8)
      return 0;
  }
  *a3 = v8;
  return *(_QWORD *)(v8 + 24);
}

uint64_t sub_20968114C(uint64_t result, uint64_t *a2, uint64_t a3, const char *a4, uint64_t *a5)
{
  uint64_t v8;
  uint64_t v9;
  _QWORD *v12;

  v12 = a5 + 1;
  if (result)
  {
    v8 = result;
    v9 = *a5;
    while (1)
    {
      if (!strcmp(*(const char **)(v8 + 8), a4))
      {
        if (*(_DWORD *)v8 == (_DWORD)a3 && v9 == 0)
        {
          *a2 = v8;
          return *(_QWORD *)(v8 + 24);
        }
        if (*(_DWORD *)v8 == 1 && v9 != 0)
          return sub_20968114C(*(_QWORD *)(v8 + 24), a2, a3, v9, v12);
      }
      v8 = *(_QWORD *)(v8 + 16);
      if (!v8)
        return 0;
    }
  }
  return result;
}

uint64_t krb5_config_get_list(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v10;

  v10 = 0;
  return sub_209681094(a1, a2, &v10, 1, (uint64_t)&a9);
}

uint64_t krb5_config_get_string(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v10;

  v10 = 0;
  return sub_209681094(a1, a2, &v10, 0, (uint64_t)&a9);
}

uint64_t krb5_config_get_string_default(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t result;
  uint64_t v11;

  v11 = 0;
  result = sub_209681094(a1, a2, &v11, 0, (uint64_t)&a9);
  if (!result)
    return a3;
  return result;
}

_QWORD *sub_2096812A0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  const char *v6;
  int v7;
  void *v8;
  char *v9;
  char *v10;
  char *v11;
  char *v12;
  uint64_t v13;
  size_t v14;
  _QWORD *v15;
  _QWORD *v16;
  char *v17;
  _QWORD *v18;
  uint64_t v19;
  char *v22;
  uint64_t v23;

  v23 = 0;
  v6 = (const char *)sub_209681094(a1, a2, &v23, 0, a3);
  if (v6)
  {
    v7 = 0;
    v8 = 0;
    while (1)
    {
      v9 = strdup(v6);
      v22 = 0;
      if (!v9)
        break;
      v10 = v9;
      v11 = sub_209681428(v9, &v22);
      if (v11)
      {
        v12 = v11;
        v13 = v7;
        v14 = 8 * v7 + 8;
        while (1)
        {
          v15 = malloc_type_realloc(v8, v14, 0x10040436913F5uLL);
          if (!v15)
            break;
          v16 = v15;
          v17 = strdup(v12);
          v16[v13] = v17;
          if (!v17)
          {
            LODWORD(v13) = v13 + 1;
            v8 = v16;
            break;
          }
          v12 = sub_209681428(0, &v22);
          ++v13;
          v14 += 8;
          v8 = v16;
          if (!v12)
          {
            v8 = v16;
            v7 = v13;
            goto LABEL_10;
          }
        }
        v7 = v13;
        break;
      }
LABEL_10:
      free(v10);
      v6 = (const char *)sub_209681094(a1, a2, &v23, 0, a3);
      if (!v6)
      {
        if (!v7)
          return v8;
        v18 = malloc_type_realloc(v8, 8 * (v7 + 1), 0x10040436913F5uLL);
        if (v18)
        {
          v18[v7] = 0;
          return v18;
        }
        goto LABEL_17;
      }
    }
    if (!v7)
      goto LABEL_19;
LABEL_17:
    v19 = v7 - 1;
    do
      free(*((void **)v8 + v19));
    while ((_DWORD)v19--);
LABEL_19:
    free(v8);
  }
  return 0;
}

char *sub_209681428(char *__s, char **a2)
{
  char *v3;
  int v4;
  char *v5;
  char *v6;

  v3 = __s;
  if (!__s)
    v3 = *a2;
  v4 = *v3;
  if (!*v3)
    return 0;
  v5 = v3;
  while (v4 == 34)
  {
    v6 = strchr(v5 + 1, 34);
    if (v6)
      v5 = v6 + 1;
    else
      v5 += strlen(v5);
    v4 = *v5;
  }
  if (v4 && (v5 += strcspn(v5, " \t"), *v5))
  {
    *v5 = 0;
    *a2 = v5 + 1;
  }
  else
  {
    *a2 = v5;
  }
  if (*v3 == 34 && *(v5 - 1) == 34 && v3 + 1 < v5)
  {
    ++v3;
    *(v5 - 1) = 0;
  }
  return v3;
}

_QWORD *krb5_config_get_strings(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  return sub_2096812A0(a1, a2, (uint64_t)&a9);
}

void krb5_config_free_strings(void **a1)
{
  void *v2;
  void **v3;
  void *v4;

  if (a1)
  {
    v2 = *a1;
    if (*a1)
    {
      v3 = a1 + 1;
      do
      {
        free(v2);
        v4 = *v3++;
        v2 = v4;
      }
      while (v4);
    }
  }
  free(a1);
}

BOOL sub_209681568(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  const char *v5;
  const char *v6;
  uint64_t v8;

  v8 = 0;
  v5 = (const char *)sub_209681094(a1, a2, &v8, 0, a4);
  if (v5)
  {
    v6 = v5;
    return !strcasecmp(v5, "yes") || !strcasecmp(v6, "true") || atoi(v6) != 0;
  }
  return a3;
}

BOOL krb5_config_get_BOOL_default(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  return sub_209681568(a1, a2, a3, (uint64_t)&a9);
}

BOOL krb5_config_get_BOOL(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  return sub_209681568(a1, a2, 0, (uint64_t)&a9);
}

uint64_t sub_20968163C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  char *v5;
  uint64_t v7;
  uint64_t v8;

  v7 = 0;
  v8 = 0;
  v5 = (char *)sub_209681094(a1, a2, &v8, 0, a4);
  if (v5 && !krb5_string_to_deltat(v5, (krb5_deltat *)&v7))
    return (int)v7;
  return a3;
}

uint64_t krb5_config_get_time_default(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  return sub_20968163C(a1, a2, a3, (uint64_t)&a9);
}

uint64_t krb5_config_get_time(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  return sub_20968163C(a1, a2, -1, (uint64_t)&a9);
}

uint64_t sub_2096816E0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  const char *v5;
  char *v6;
  unsigned int v7;
  char *__endptr;

  __endptr = 0;
  v5 = (const char *)sub_209681094(a1, a2, (uint64_t *)&__endptr, 0, a4);
  if (v5)
  {
    v6 = (char *)v5;
    __endptr = 0;
    v7 = strtol(v5, &__endptr, 0);
    if (__endptr == v6)
      return a3;
    else
      return v7;
  }
  return a3;
}

uint64_t krb5_config_get_int_default(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  return sub_2096816E0(a1, a2, a3, (uint64_t)&a9);
}

uint64_t krb5_config_get_int(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  return sub_2096816E0(a1, a2, 0xFFFFFFFFLL, (uint64_t)&a9);
}

void sub_209681794(const __CFString *a1, const __CFString *a2, _QWORD *a3)
{
  CFTypeID v6;
  char *v7;
  char *v8;
  CFTypeID v9;
  _QWORD *v10;
  CFTypeID v11;
  _QWORD *v12;
  CFTypeID v13;
  _QWORD v14[2];
  CFRange v15;

  v6 = CFGetTypeID(a1);
  if (v6 == CFStringGetTypeID())
  {
    v7 = sub_2096818B0(a1);
    if (v7)
    {
      v8 = v7;
      v9 = CFGetTypeID(a2);
      if (v9 == CFStringGetTypeID())
      {
        v10 = sub_209680AF4(a3, v8, 0);
        v10[3] = sub_2096818B0(a2);
      }
      else
      {
        v11 = CFGetTypeID(a2);
        if (v11 == CFDictionaryGetTypeID())
        {
          v12 = sub_209680AF4(a3, v8, 1);
          CFDictionaryApplyFunction((CFDictionaryRef)a2, (CFDictionaryApplierFunction)sub_209681794, v12 + 3);
        }
        else
        {
          v13 = CFGetTypeID(a2);
          if (v13 == CFArrayGetTypeID())
          {
            v14[0] = a3;
            v14[1] = v8;
            v15.length = CFArrayGetCount((CFArrayRef)a2);
            v15.location = 0;
            CFArrayApplyFunction((CFArrayRef)a2, v15, (CFArrayApplierFunction)sub_209681950, v14);
          }
        }
      }
      free(v8);
    }
  }
}

char *sub_2096818B0(const __CFString *a1)
{
  const char *CStringPtr;
  CFIndex Length;
  CFIndex v5;
  void *v6;

  CStringPtr = CFStringGetCStringPtr(a1, 0x8000100u);
  if (CStringPtr)
    return strdup(CStringPtr);
  Length = CFStringGetLength(a1);
  v5 = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u) + 1;
  v6 = malloc_type_malloc(v5, 0x424BA24CuLL);
  if (v6)
  {
    if (!CFStringGetCString(a1, (char *)v6, v5, 0x8000100u))
    {
      free(v6);
      return 0;
    }
  }
  return (char *)v6;
}

CFTypeID sub_209681950(const __CFString *a1, uint64_t a2)
{
  CFTypeID v4;
  CFTypeID result;
  _QWORD *v6;

  v4 = CFGetTypeID(a1);
  result = CFStringGetTypeID();
  if (v4 == result)
  {
    v6 = sub_209680AF4(*(_QWORD **)a2, *(char **)(a2 + 8), 0);
    result = (CFTypeID)sub_2096818B0(a1);
    v6[3] = result;
  }
  return result;
}

char *sub_2096819A8(char *a1, uint64_t a2)
{
  char *v2;
  FILE *v3;
  const char *v6;
  size_t v7;
  uint64_t v8;
  size_t v9;

  v2 = a1;
  v3 = *(FILE **)(a2 + 8);
  if (v3)
    return fgets(a1, 2048, v3);
  v6 = *(const char **)a2;
  if (!**(_BYTE **)a2)
    return 0;
  v7 = strcspn(v6, "\n");
  if (v6[v7] == 10)
    v8 = (uint64_t)&v6[v7 + 1];
  else
    v8 = (uint64_t)&v6[v7];
  if ((unint64_t)(v8 - (_QWORD)v6) >= 0x800)
    v9 = 2048;
  else
    v9 = v8 - (_QWORD)v6;
  memcpy(v2, v6, v9);
  v2[v9] = 0;
  *(_QWORD *)a2 = v8;
  return v2;
}

uint64_t sub_209681A60(uint64_t a1, int *a2, char *a3, _QWORD *a4, _QWORD *a5, const char **a6)
{
  char *v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  uint64_t v16;
  int v17;
  int v18;
  uint64_t v19;
  _QWORD *v20;
  char *v21;
  char *v22;
  int v23;
  unsigned int v24;
  int v25;
  uint64_t v27;
  int v28;
  uint64_t result;
  const char *v30;
  _QWORD *v31;
  _QWORD *v32;
  int64_t v33;
  uint64_t v34;
  int64_t v35;
  uint64_t v36;
  char *v37;
  char *v38;
  int v39;
  _QWORD *v40;
  _QWORD *v41;
  char v42[7];
  char v43;
  char __s[2048];
  uint64_t v45;

  v45 = *MEMORY[0x24BDAC8D0];
  v12 = a3 - 1;
  v13 = MEMORY[0x24BDAC740];
  while (1)
  {
    v14 = v12[1];
    if (!v12[1] || (_DWORD)v14 == 61)
      break;
    if ((v14 & 0x80) != 0)
    {
      if (__maskrune(v14, 0x4000uLL))
      {
LABEL_9:
        LODWORD(v14) = v12[1];
        break;
      }
    }
    else if ((*(_DWORD *)(v13 + 4 * v14 + 60) & 0x4000) != 0)
    {
      goto LABEL_9;
    }
    ++v12;
  }
  if (!(_DWORD)v14)
    goto LABEL_43;
  v15 = v12;
  do
  {
    v16 = v15[1];
    if (v15[1] < 0)
      v17 = __maskrune(v15[1], 0x4000uLL);
    else
      v17 = *(_DWORD *)(v13 + 4 * v16 + 60) & 0x4000;
    ++v15;
  }
  while (v17);
  if ((_DWORD)v16 != 61)
  {
LABEL_43:
    result = 2529639048;
    v30 = "missing =";
LABEL_44:
    *a6 = v30;
    return result;
  }
  do
  {
    while (1)
    {
      v18 = *++v15;
      v19 = v18;
      if (v18 < 0)
        break;
      if ((*(_DWORD *)(v13 + 4 * v19 + 60) & 0x4000) == 0)
        goto LABEL_21;
    }
  }
  while (__maskrune(v19, 0x4000uLL));
LABEL_21:
  v12[1] = 0;
  if (*v15 != 123)
  {
    v31 = sub_209680AF4(a5, a3, 0);
    if (v31)
    {
      v32 = v31;
      v33 = strlen(v15);
      if (v33 < 1)
      {
LABEL_56:
        v37 = &v15[v33];
      }
      else
      {
        do
        {
          v34 = v15[v33 - 1];
          if (v15[v33 - 1] < 0)
          {
            if (!__maskrune(v34, 0x4000uLL))
              goto LABEL_56;
          }
          else if ((*(_DWORD *)(v13 + 4 * v34 + 60) & 0x4000) == 0)
          {
            goto LABEL_56;
          }
          v35 = v33 - 1;
          v36 = v33-- + 1;
        }
        while (v36 >= 3);
        v37 = &v15[v35];
      }
      *v37 = 0;
      v38 = strdup(v15);
      result = 0;
      v32[3] = v38;
      goto LABEL_58;
    }
    goto LABEL_53;
  }
  v20 = sub_209680AF4(a5, a3, 1);
  if (!v20)
  {
LABEL_53:
    result = 2529639048;
    v30 = "out of memory";
    goto LABEL_44;
  }
  v41 = v20;
  v40 = a4;
  v39 = *a2;
  if (!sub_2096819A8(__s, a1))
  {
LABEL_54:
    result = 2529639048;
    *a2 = v39;
    *a6 = "unclosed {";
    goto LABEL_55;
  }
  while (1)
  {
    ++*a2;
    __s[strcspn(__s, "\r\n")] = 0;
    v21 = &v43;
    do
    {
      v22 = v21;
      v23 = v21[1];
      v24 = v23;
      if (v23 < 0)
        v25 = __maskrune(v23, 0x4000uLL);
      else
        v25 = *(_DWORD *)(v13 + 4 * v23 + 60) & 0x4000;
      v21 = v22 + 1;
    }
    while (v25);
    if (v24 <= 0x3B && ((1 << v24) & 0x800000800000001) != 0)
      goto LABEL_33;
    do
    {
      v27 = v22[1];
      if (v22[1] < 0)
        v28 = __maskrune(v22[1], 0x4000uLL);
      else
        v28 = *(_DWORD *)(v13 + 4 * v27 + 60) & 0x4000;
      ++v22;
    }
    while (v28);
    if (!(_DWORD)v27)
      goto LABEL_33;
    if ((_DWORD)v27 == 125)
      break;
    result = sub_209681A60(a1, a2, v22, v42, v41 + 3, a6);
    if ((_DWORD)result)
      goto LABEL_55;
LABEL_33:
    if (!sub_2096819A8(__s, a1))
      goto LABEL_54;
  }
  result = 0;
LABEL_55:
  a4 = v40;
  v32 = v41;
LABEL_58:
  *a4 = v32;
  return result;
}

uint64_t krb5_init_context_flags(char a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  uint64_t v11;
  pthread_mutex_t *v12;
  uint64_t default_config_files;
  char **v14;
  void *v16;

  v16 = 0;
  *a2 = 0;
  v10 = heim_uniq_alloc(0x188uLL, (uint64_t)"krb5-context", (uint64_t)sub_209681FC0, a4, a5, a6, a7, a8);
  if (v10)
  {
    v11 = v10;
    v12 = (pthread_mutex_t *)malloc_type_malloc(0x40uLL, 0x1000040FA0F61DDuLL);
    *(_QWORD *)(v11 + 328) = v12;
    if (v12)
    {
      pthread_mutex_init(v12, 0);
      pthread_mutex_lock(&stru_253D3A5A8);
      if (dword_2545A4D60)
        *(_DWORD *)(v11 + 360) |= 4u;
      pthread_mutex_unlock(&stru_253D3A5A8);
      if ((a1 & 1) != 0)
      {
        v14 = 0;
      }
      else
      {
        default_config_files = krb5_get_default_config_files(&v16);
        if ((_DWORD)default_config_files)
        {
LABEL_13:
          heim_release((CFTypeRef)v11);
          v11 = 0;
LABEL_14:
          *a2 = v11;
          return default_config_files;
        }
        v14 = (char **)v16;
      }
      default_config_files = krb5_set_config_files((void ***)v11, v14);
      krb5_free_config_files((void **)v16);
      if (!(_DWORD)default_config_files)
      {
        heim_base_once_f(&qword_253D3BA58, (void *)v11, (dispatch_function_t)sub_20968223C);
        krb5_init_ets(v11);
        *(_QWORD *)(v11 + 168) = 0;
        *(_DWORD *)(v11 + 176) = 0;
        krb5_cc_register(v11, (uint64_t)&krb5_fcc_ops, 1);
        krb5_cc_register(v11, (uint64_t)&krb5_mcc_ops, 1);
        krb5_cc_register(v11, (uint64_t)&krb5_xcc_api_ops, 1);
        krb5_cc_register(v11, (uint64_t)&krb5_xcc_ops, 1);
        krb5_cc_register(v11, (uint64_t)&krb5_xcc_temp_api_ops, 1);
        sub_2096B6D84(v11);
        *(_DWORD *)(v11 + 256) = 0;
        *(_QWORD *)(v11 + 264) = 0;
        krb5_kt_register(v11, (__int128 *)&off_24C1F1288);
        krb5_kt_register(v11, (__int128 *)&off_24C1F1480);
        krb5_kt_register(v11, (__int128 *)&off_24C1F12F0);
        default_config_files = hx509_context_init((uint64_t *)(v11 + 376));
        if (!(_DWORD)default_config_files)
          goto LABEL_14;
      }
      goto LABEL_13;
    }
    heim_release((CFTypeRef)v11);
  }
  return 12;
}

void sub_209681FC0(uint64_t a1)
{
  void *v2;
  void *v3;
  void **v4;
  uint64_t v5;
  uint64_t v6;

  v2 = *(void **)(a1 + 304);
  if (v2)
    free(v2);
  v3 = *(void **)(a1 + 312);
  if (v3)
    free(v3);
  v4 = *(void ***)(a1 + 120);
  if (v4)
    krb5_free_config_files(v4);
  free(*(void **)(a1 + 32));
  free(*(void **)(a1 + 40));
  heim_release(*(CFTypeRef *)(a1 + 72));
  krb5_config_file_free(a1, *(void ***)(a1 + 136));
  sub_2096BCE90(*(_QWORD **)(a1 + 144));
  free(*(void **)(a1 + 168));
  free(*(void **)(a1 + 264));
  krb5_clear_error_message((krb5_context)a1);
  v5 = *(_QWORD *)(a1 + 152);
  if (v5)
    krb5_closelog(a1, v5);
  v6 = *(_QWORD *)(a1 + 160);
  if (v6)
    krb5_closelog(a1, v6);
  krb5_set_extra_addresses((krb5_context)a1, 0);
  krb5_set_ignore_addresses((krb5_context)a1, 0);
  if (*(_QWORD *)(a1 + 376))
    hx509_context_free((uint64_t *)(a1 + 376));
  pthread_mutex_destroy(*(pthread_mutex_t **)(a1 + 328));
  free(*(void **)(a1 + 328));
}

uint64_t krb5_get_default_config_files(void **a1)
{
  char *v2;

  if (!a1)
    return 22;
  if (issuid())
    v2 = 0;
  else
    v2 = getenv("KRB5_CONFIG");
  if (!v2)
    v2 = off_2545A4D30[0];
  return krb5_prepend_config_files(v2, 0, a1);
}

uint64_t krb5_set_config_files(void ***a1, char **a2)
{
  char *v3;
  char **v4;
  uint64_t v5;
  char *v6;
  void **v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unsigned int v16;
  void *v17;
  void **v18;

  v17 = 0;
  v18 = 0;
  if (a2 && (v16 = 0, (v3 = *a2) != 0))
  {
    v4 = a2 + 1;
    do
    {
      if (!*v3)
        break;
      v5 = sub_20968231C(&v17, &v16, v3);
      if (!(_DWORD)v5)
        v5 = krb5_config_parse_file_multi((_krb5_context *)a1, *(v4 - 1), &v18);
      if ((v5 > 0xD || ((1 << v5) & 0x2007) == 0) && (_DWORD)v5 != -1765328248)
      {
        krb5_free_config_files((void **)v17);
        krb5_config_file_free((uint64_t)a1, v18);
        return v5;
      }
      v6 = *v4++;
      v3 = v6;
    }
    while (v6);
    v7 = (void **)v17;
  }
  else
  {
    v7 = 0;
  }
  krb5_free_config_files(a1[15]);
  a1[15] = v7;
  krb5_config_file_free((uint64_t)a1, a1[17]);
  a1[17] = v18;
  return sub_2096823E0((uint64_t)a1, v8, v9, v10, v11, v12, v13, v14);
}

void krb5_free_config_files(void **a1)
{
  void *v2;
  void **v3;
  void *v4;

  if (a1)
  {
    v2 = *a1;
    if (*a1)
    {
      v3 = a1 + 1;
      do
      {
        free(v2);
        v4 = *v3++;
        v2 = v4;
      }
      while (v4);
    }
  }
  free(a1);
}

void sub_20968223C(_krb5_context *a1)
{
  notify_register_check("com.apple.Kerberos.configuration-changed", &dword_253D3A59C);
  notify_register_check("com.apple.ManagedConfiguration.profileListChanged", &dword_253D3A5A0);
  krb5_load_plugins(a1, "krb5", off_2545A4D68);
}

uint64_t krb5_init_ets(uint64_t result)
{
  uint64_t v1;

  if (!*(_QWORD *)(result + 144))
  {
    v1 = result;
    krb5_add_et_list(result, (void (*)(uint64_t))initialize_krb5_error_table_r);
    krb5_add_et_list(v1, (void (*)(uint64_t))initialize_asn1_error_table_r);
    krb5_add_et_list(v1, (void (*)(uint64_t))initialize_heim_error_table_r);
    krb5_add_et_list(v1, (void (*)(uint64_t))initialize_k524_error_table_r);
    return krb5_add_et_list(v1, (void (*)(uint64_t))initialize_hx_error_table_r);
  }
  return result;
}

krb5_error_code krb5_init_context(krb5_context *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  return krb5_init_context_flags(0, (uint64_t *)a1, v1, v2, v3, v4, v5, v6);
}

uint64_t sub_20968231C(void **a1, unsigned int *a2, char *__s2)
{
  void *v6;
  int v7;
  uint64_t v8;
  const char **v9;
  uint64_t result;
  _QWORD *v11;
  _QWORD *v12;
  char *v13;
  uint64_t v14;
  unsigned int v15;

  v6 = *a1;
  v7 = *a2;
  if (*a2)
  {
    v8 = *a2;
    v9 = (const char **)*a1;
    while (1)
    {
      result = strcmp(*v9, __s2);
      if (!(_DWORD)result)
        break;
      ++v9;
      if (!--v8)
        goto LABEL_5;
    }
  }
  else
  {
LABEL_5:
    v11 = malloc_type_realloc(v6, 8 * (v7 + 2), 0x10040436913F5uLL);
    if (v11 && (v12 = v11, *a1 = v11, v13 = strdup(__s2), v14 = *a2, (v12[v14] = v13) != 0))
    {
      result = 0;
      v15 = v14 + 1;
      v12[v15] = 0;
      *a2 = v15;
    }
    else
    {
      return 12;
    }
  }
  return result;
}

uint64_t sub_2096823E0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t result;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t string_default;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  const char *string;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  char **strings;
  void **v100;
  char *v101;
  char **v102;
  char *v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  char **v110;
  void **v111;
  char *v112;
  char **v113;
  char *v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  _BOOL8 BOOL_default;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  uint64_t v135;
  uint64_t v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t v148;
  uint64_t v149;
  uint64_t v150;
  uint64_t v151;
  uint64_t v152;
  uint64_t v153;
  uint64_t v154;
  uint64_t v155;
  uint64_t v156;
  uint64_t v157;
  uint64_t v158;
  uint64_t v159;
  uint64_t v160;
  uint64_t v161;
  uint64_t v162;
  uint64_t v163;
  uint64_t v164;
  uint64_t v165;
  uint64_t v166;
  void *v167;
  void **v168;
  uint64_t v169;
  uint64_t v170;
  uint64_t v171;
  uint64_t v172;
  uint64_t v173;
  uint64_t v174;
  uint64_t v175;
  void **v176;
  char *v177;
  char **v178;
  char *v179;
  const __CFBoolean *v180;
  const __CFBoolean *v181;
  CFTypeID v182;
  char *v183;
  CFTypeID v184;
  const char **v185;
  _BOOL4 valuePtr;
  krb5_address *v187;
  uint64_t v188;
  uint64_t v189;

  *(_QWORD *)(a1 + 80) = krb5_config_get_time_default(a1, 0, 300, a4, a5, a6, a7, a8, (uint64_t)"libdefaults");
  *(_QWORD *)(a1 + 88) = krb5_config_get_time_default(a1, 0, 30, v9, v10, v11, v12, v13, (uint64_t)"libdefaults");
  *(_QWORD *)(a1 + 96) = krb5_config_get_time_default(a1, 0, 3, v14, v15, v16, v17, v18, (uint64_t)"libdefaults");
  *(_QWORD *)(a1 + 352) = krb5_config_get_time_default(a1, 0, 1200, v19, v20, v21, v22, v23, (uint64_t)"libdefaults");
  *(_DWORD *)(a1 + 104) = krb5_config_get_int_default(a1, 0, 3, v24, v25, v26, v27, v28, (uint64_t)"libdefaults");
  *(_QWORD *)(a1 + 184) = krb5_config_get_string_default(a1, 0, 0, v29, v30, v31, v32, v33, (uint64_t)"libdefaults");
  if (krb5_config_get_BOOL_default(a1, 0, 0, v34, v35, v36, v37, v38, (uint64_t)"libdefaults"))
    sub_209686B48(a1, 1);
  v189 = 0;
  result = sub_209683338((char *)a1, (uint64_t)"default_etypes", &v189, v39, v40, v41, v42, v43);
  if (!(_DWORD)result)
  {
    free(*(void **)(a1 + 32));
    *(_QWORD *)(a1 + 32) = v189;
    result = sub_209683338((char *)a1, (uint64_t)"default_etypes_des", &v189, v45, v46, v47, v48, v49);
    if (!(_DWORD)result)
    {
      free(*(void **)(a1 + 40));
      *(_QWORD *)(a1 + 40) = v189;
      result = sub_209683338((char *)a1, (uint64_t)"default_as_etypes", &v189, v50, v51, v52, v53, v54);
      if (!(_DWORD)result)
      {
        free(*(void **)(a1 + 48));
        *(_QWORD *)(a1 + 48) = v189;
        result = sub_209683338((char *)a1, (uint64_t)"default_tgs_etypes", &v189, v55, v56, v57, v58, v59);
        if (!(_DWORD)result)
        {
          free(*(void **)(a1 + 56));
          *(_QWORD *)(a1 + 56) = v189;
          result = sub_209683338((char *)a1, (uint64_t)"permitted_enctypes", &v189, v60, v61, v62, v63, v64);
          if (!(_DWORD)result)
          {
            free(*(void **)(a1 + 64));
            *(_QWORD *)(a1 + 64) = v189;
            if (issuid() || (string_default = (uint64_t)getenv("KRB5_KTNAME")) == 0)
              string_default = krb5_config_get_string_default(a1, 0, (uint64_t)"FILE:/etc/krb5.keytab", v65, v66, v67, v68, v69, (uint64_t)"libdefaults");
            *(_QWORD *)(a1 + 208) = string_default;
            *(_QWORD *)(a1 + 216) = krb5_config_get_string_default(a1, 0, 0, v65, v66, v67, v68, v69, (uint64_t)"libdefaults");
            *(_QWORD *)(a1 + 192) = krb5_config_get_string_default(a1, 0, (uint64_t)"%Y-%m-%dT%H:%M:%S", v71, v72, v73, v74, v75, (uint64_t)"libdefaults");
            *(_QWORD *)(a1 + 272) = krb5_config_get_string_default(a1, 0, (uint64_t)"%Y-%m-%d", v76, v77, v78, v79, v80, (uint64_t)"libdefaults");
            *(_DWORD *)(a1 + 200) = krb5_config_get_BOOL_default(a1, 0, 0, v81, v82, v83, v84, v85, (uint64_t)"libdefaults");
            string = (const char *)krb5_config_get_string(a1, 0, v86, v87, v88, v89, v90, v91, (uint64_t)"libdefaults");
            if (string)
              sub_2096B9AE0(*(char **)(a1 + 184), string);
            heim_release(*(CFTypeRef *)(a1 + 72));
            *(_QWORD *)(a1 + 72) = 0;
            krb5_set_extra_addresses((krb5_context)a1, 0);
            strings = (char **)krb5_config_get_strings(a1, 0, v93, v94, v95, v96, v97, v98, (uint64_t)"libdefaults");
            v100 = (void **)strings;
            v187 = 0;
            v188 = 0;
            if (strings)
            {
              v101 = *strings;
              if (*strings)
              {
                v102 = strings + 1;
                do
                {
                  if (!krb5_parse_address((_krb5_context *)a1, v101, (uint64_t)&v187))
                  {
                    krb5_add_extra_addresses((_krb5_context *)a1, &v187);
                    krb5_free_addresses((krb5_context)a1, &v187);
                  }
                  v103 = *v102++;
                  v101 = v103;
                }
                while (v103);
              }
            }
            krb5_config_free_strings(v100);
            krb5_set_ignore_addresses((krb5_context)a1, 0);
            v110 = (char **)krb5_config_get_strings(a1, 0, v104, v105, v106, v107, v108, v109, (uint64_t)"libdefaults");
            v111 = (void **)v110;
            v187 = 0;
            v188 = 0;
            if (v110)
            {
              v112 = *v110;
              if (*v110)
              {
                v113 = v110 + 1;
                do
                {
                  if (!krb5_parse_address((_krb5_context *)a1, v112, (uint64_t)&v187))
                  {
                    krb5_add_ignore_addresses((_krb5_context *)a1, &v187);
                    krb5_free_addresses((krb5_context)a1, &v187);
                  }
                  v114 = *v113++;
                  v112 = v114;
                }
                while (v114);
              }
            }
            krb5_config_free_strings(v111);
            *(_DWORD *)(a1 + 240) = krb5_config_get_BOOL_default(a1, 0, 1, v115, v116, v117, v118, v119, (uint64_t)"libdefaults");
            *(_DWORD *)(a1 + 252) = krb5_config_get_int_default(a1, 0, 0, v120, v121, v122, v123, v124, (uint64_t)"libdefaults");
            BOOL_default = krb5_config_get_BOOL_default(a1, 0, 1, v125, v126, v127, v128, v129, (uint64_t)"libdefaults");
            *(_DWORD *)(a1 + 244) = BOOL_default;
            *(_DWORD *)(a1 + 244) = krb5_config_get_BOOL_default(a1, 0, BOOL_default, v131, v132, v133, v134, v135, (uint64_t)"libdefaults");
            *(_DWORD *)(a1 + 336) = krb5_config_get_int_default(a1, 0, 1400, v136, v137, v138, v139, v140, (uint64_t)"libdefaults");
            *(_DWORD *)(a1 + 340) = krb5_config_get_int_default(a1, 0, 1024000, v141, v142, v143, v144, v145, (uint64_t)"libdefaults");
            *(_DWORD *)(a1 + 344) = krb5_config_get_int_default(a1, 0, 5, v146, v147, v148, v149, v150, (uint64_t)"libdefaults");
            if (krb5_config_get_BOOL_default(a1, 0, 1, v151, v152, v153, v154, v155, (uint64_t)"libdefaults"))
              *(_DWORD *)(a1 + 360) |= 1u;
            if (krb5_config_get_BOOL_default(a1, 0, 1, v156, v157, v158, v159, v160, (uint64_t)"libdefaults"))
              *(_DWORD *)(a1 + 360) |= 2u;
            v167 = *(void **)(a1 + 304);
            if (v167)
              free(v167);
            *(_QWORD *)(a1 + 304) = 0;
            *(_DWORD *)(a1 + 320) = 0;
            v168 = (void **)krb5_config_get_strings(a1, 0, v161, v162, v163, v164, v165, v166, (uint64_t)"logging");
            v175 = *(_QWORD *)(a1 + 160);
            if (v168)
            {
              v176 = v168;
              if (v175)
                krb5_closelog(a1, v175);
              krb5_initlog((_krb5_context *)a1, "libkrb5", (char ***)(a1 + 160));
              v177 = (char *)*v176;
              if (*v176)
              {
                v178 = (char **)(v176 + 1);
                do
                {
                  krb5_addlog_dest((_krb5_context *)a1, *(const char ***)(a1 + 160), v177);
                  v179 = *v178++;
                  v177 = v179;
                }
                while (v179);
              }
              krb5_config_free_strings(v176);
            }
            else if (!v175)
            {
              v187 = 0;
              if (issuid()
                || (v183 = getenv("KRB5_TRACE")) == 0
                || (asprintf((char **)&v187, "0-/FILE:%s", v183), !v187))
              {
                v180 = geteuid() && krb5_homedir_access(0)
                     ? (const __CFBoolean *)CFPreferencesCopyAppValue(CFSTR("KerberosDebugLevel"), CFSTR(".GlobalPreferences")): sub_209683470();
                v181 = v180;
                if (v180)
                {
                  valuePtr = 1;
                  v182 = CFGetTypeID(v180);
                  if (v182 == CFBooleanGetTypeID())
                  {
                    valuePtr = CFBooleanGetValue(v181) != 0;
                  }
                  else
                  {
                    v184 = CFGetTypeID(v181);
                    if (v184 == CFNumberGetTypeID())
                      CFNumberGetValue(v181, kCFNumberIntType, &valuePtr);
                  }
                  CFRelease(v181);
                  asprintf((char **)&v187, "0-%d/OSLOG:normal:libkrb5", valuePtr);
                }
              }
              krb5_initlog((_krb5_context *)a1, "libkrb5", (char ***)(a1 + 160));
              v185 = *(const char ***)(a1 + 160);
              if (v187)
              {
                krb5_addlog_dest((_krb5_context *)a1, v185, (char *)v187);
                free(v187);
              }
              else
              {
                krb5_addlog_dest((_krb5_context *)a1, v185, "0-10/OSLOG:normal:libkrb5");
              }
            }
            result = krb5_config_get_string(a1, 0, v169, v170, v171, v172, v173, v174, (uint64_t)"libdefaults");
            if (!result)
            {
              if (issuid())
                return 0;
              result = (uint64_t)getenv("KRB5_CHECK_RD_REQ_SERVER");
              if (!result)
                return result;
            }
            result = strcasecmp((const char *)result, "ignore");
            if (!(_DWORD)result)
            {
              *(_DWORD *)(a1 + 360) |= 0x10u;
              return result;
            }
            return 0;
          }
        }
      }
    }
  }
  return result;
}

uint64_t krb5_prepend_config_files_default(const char *a1, _QWORD *a2)
{
  uint64_t default_config_files;
  void *v6;
  void *v7;

  v6 = 0;
  v7 = 0;
  default_config_files = krb5_get_default_config_files(&v7);
  if (!(_DWORD)default_config_files)
  {
    default_config_files = krb5_prepend_config_files(a1, (char **)v7, &v6);
    krb5_free_config_files((void **)v7);
    if (!(_DWORD)default_config_files)
      *a2 = v6;
  }
  return default_config_files;
}

int *krb5_kerberos_enctypes(_krb5_context *a1)
{
  uint64_t v2;
  int *v3;

  v2 = 0;
  v3 = dword_2096D9338;
  while (!krb5_enctype_valid(a1, (char *)dword_2096D9338[v2]))
  {
    if (++v2 == 7)
      return v3;
  }
  return (int *)&unk_2096D9328;
}

uint64_t krb5_set_default_in_tkt_etypes(krb5_context a1, unsigned int *a2)
{
  uint64_t v3;
  uint64_t v4;
  void *v5;
  uint64_t v7;

  v7 = 0;
  if (!a2)
    goto LABEL_7;
  v3 = sub_209682CDC(a1, a2, &v7);
  if ((_DWORD)v3)
    return v3;
  v4 = v7;
  if (!v7)
  {
LABEL_7:
    v3 = 2529639062;
    krb5_set_error_message(a1, -1765328234, "entypes not supported");
    return v3;
  }
  v5 = (void *)*((_QWORD *)a1 + 4);
  if (v5)
    free(v5);
  v3 = 0;
  *((_QWORD *)a1 + 4) = v4;
  return v3;
}

uint64_t sub_209682CDC(_krb5_context *a1, unsigned int *a2, _QWORD *a3)
{
  size_t v6;
  _DWORD *v8;
  _DWORD *v9;
  unint64_t v10;
  uint64_t v11;
  unsigned int *v12;
  unsigned int v13;
  uint64_t v14;

  v6 = 0;
  while (a2[v6++])
    ;
  v8 = malloc_type_calloc(v6, 4uLL, 0x100004052888210uLL);
  if (!v8)
    return krb5_enomem(a1);
  v9 = v8;
  v10 = *a2;
  if (!(_DWORD)v10)
    goto LABEL_12;
  v11 = 0;
  v12 = a2 + 1;
  do
  {
    if (!krb5_enctype_valid(a1, (char *)v10))
      v9[v11++] = *(v12 - 1);
    v13 = *v12++;
    v10 = v13;
  }
  while (v13);
  v9[v11] = 0;
  if (v11)
  {
    v14 = 0;
    *a3 = v9;
  }
  else
  {
LABEL_12:
    v14 = 2529639062;
    free(v9);
    krb5_set_error_message(a1, -1765328234, "no valid enctype set");
  }
  return v14;
}

uint64_t krb5_get_default_in_tkt_etypes(_krb5_context *a1, uint64_t a2, _QWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int *v9;
  uint64_t result;
  char v11;
  uint64_t v12;

  v12 = 0;
  switch((_DWORD)a2)
  {
    case 2:
      v9 = (unsigned int *)*((_QWORD *)a1 + 6);
      if (v9)
        goto LABEL_10;
      break;
    case 4:
      v9 = (unsigned int *)*((_QWORD *)a1 + 7);
      if (v9)
        goto LABEL_10;
      break;
    case 0xB:
      break;
    default:
      heim_abort("pdu contant not as expected:pdu_type == KRB5_PDU_AS_REQUEST || pdu_type == KRB5_PDU_TGS_REQUEST || pdu_type == KRB5_PDU_NONE", a2, (uint64_t)a3, a4, a5, a6, a7, a8, v11);
  }
  v9 = (unsigned int *)*((_QWORD *)a1 + 4);
  if (!v9)
    v9 = (unsigned int *)&unk_2096D9358;
LABEL_10:
  result = sub_209682CDC(a1, v9, &v12);
  if (!(_DWORD)result)
  {
    result = 0;
    *a3 = v12;
  }
  return result;
}

uint64_t krb5_set_use_admin_kdc(uint64_t result, int a2)
{
  *(_DWORD *)(result + 224) = a2;
  return result;
}

uint64_t krb5_get_use_admin_kdc(uint64_t a1)
{
  return *(unsigned int *)(a1 + 224);
}

uint64_t krb5_add_extra_addresses(_krb5_context *a1, krb5_address **a2)
{
  uint64_t v3;

  v3 = *((_QWORD *)a1 + 29);
  if (v3)
    return krb5_append_addresses(a1, v3, (unsigned int *)a2);
  else
    return krb5_set_extra_addresses(a1, a2);
}

uint64_t krb5_set_extra_addresses(krb5_context a1, krb5_address **a2)
{
  krb5_address **v4;
  krb5_address ***v5;
  uint64_t v7;

  v4 = (krb5_address **)*((_QWORD *)a1 + 29);
  if (v4)
    krb5_free_addresses(a1, v4);
  v5 = (krb5_address ***)*((_QWORD *)a1 + 29);
  if (a2)
  {
    if (v5)
      return krb5_copy_addresses(a1, a2, v5);
    v5 = (krb5_address ***)malloc_type_malloc(0x10uLL, 0x1020040D5A9D86FuLL);
    *((_QWORD *)a1 + 29) = v5;
    if (v5)
      return krb5_copy_addresses(a1, a2, v5);
    v7 = 12;
    krb5_set_error_message(a1, 12, "malloc: out of memory");
  }
  else if (v5)
  {
    free(*((void **)a1 + 29));
    v7 = 0;
    *((_QWORD *)a1 + 29) = 0;
  }
  else
  {
    return 0;
  }
  return v7;
}

uint64_t krb5_get_extra_addresses(_krb5_context *a1, krb5_address ***a2)
{
  krb5_address *const *v3;

  v3 = (krb5_address *const *)*((_QWORD *)a1 + 29);
  if (v3)
    return krb5_copy_addresses(a1, v3, a2);
  *a2 = 0;
  a2[1] = 0;
  return 0;
}

uint64_t krb5_add_ignore_addresses(_krb5_context *a1, krb5_address **a2)
{
  uint64_t v3;

  v3 = *((_QWORD *)a1 + 37);
  if (v3)
    return krb5_append_addresses(a1, v3, (unsigned int *)a2);
  else
    return krb5_set_ignore_addresses(a1, a2);
}

uint64_t krb5_set_ignore_addresses(krb5_context a1, krb5_address **a2)
{
  krb5_address **v4;
  krb5_address ***v5;
  uint64_t v7;

  v4 = (krb5_address **)*((_QWORD *)a1 + 37);
  if (v4)
    krb5_free_addresses(a1, v4);
  v5 = (krb5_address ***)*((_QWORD *)a1 + 37);
  if (a2)
  {
    if (v5)
      return krb5_copy_addresses(a1, a2, v5);
    v5 = (krb5_address ***)malloc_type_malloc(0x10uLL, 0x1020040D5A9D86FuLL);
    *((_QWORD *)a1 + 37) = v5;
    if (v5)
      return krb5_copy_addresses(a1, a2, v5);
    v7 = 12;
    krb5_set_error_message(a1, 12, "malloc: out of memory");
  }
  else if (v5)
  {
    free(*((void **)a1 + 37));
    v7 = 0;
    *((_QWORD *)a1 + 37) = 0;
  }
  else
  {
    return 0;
  }
  return v7;
}

uint64_t krb5_get_ignore_addresses(_krb5_context *a1, krb5_address ***a2)
{
  krb5_address *const *v3;

  v3 = (krb5_address *const *)*((_QWORD *)a1 + 37);
  if (v3)
    return krb5_copy_addresses(a1, v3, a2);
  *a2 = 0;
  a2[1] = 0;
  return 0;
}

uint64_t krb5_set_fcache_version(uint64_t a1, int a2)
{
  *(_DWORD *)(a1 + 252) = a2;
  return 0;
}

uint64_t krb5_get_fcache_version(uint64_t a1, _DWORD *a2)
{
  *a2 = *(_DWORD *)(a1 + 252);
  return 0;
}

krb5_BOOLean krb5_is_thread_safe(void)
{
  return 1;
}

uint64_t krb5_set_dns_canonicalize_hostname(uint64_t result, int a2)
{
  *(_DWORD *)(result + 360) = *(_DWORD *)(result + 360) & 0xFFFFFFFE | (a2 != 0);
  return result;
}

uint64_t krb5_get_dns_canonicalize_hostname(uint64_t a1)
{
  return *(_DWORD *)(a1 + 360) & 1;
}

uint64_t krb5_get_kdc_sec_offset(uint64_t a1, _DWORD *a2, _DWORD *a3)
{
  if (a2)
    *a2 = *(_DWORD *)(a1 + 108);
  if (a3)
    *a3 = *(_DWORD *)(a1 + 112);
  return 0;
}

uint64_t krb5_set_kdc_sec_offset(uint64_t a1, int a2, int a3)
{
  *(_DWORD *)(a1 + 108) = a2;
  if ((a3 & 0x80000000) == 0)
    *(_DWORD *)(a1 + 112) = a3;
  return 0;
}

uint64_t krb5_get_max_time_skew(uint64_t a1)
{
  return *(_QWORD *)(a1 + 80);
}

uint64_t krb5_set_max_time_skew(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 80) = a2;
  return result;
}

uint64_t _krb5_init_etype(_krb5_context *a1, uint64_t a2, unsigned int *a3, uint64_t *a4, unsigned int *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result;
  unsigned int v11;
  uint64_t v12;

  if (a5)
  {
    result = sub_209682CDC(a1, a5, a4);
    if ((_DWORD)result)
      return result;
  }
  else
  {
    result = krb5_get_default_in_tkt_etypes(a1, a2, a4, (uint64_t)a4, 0, a6, a7, a8);
    if ((_DWORD)result)
      return result;
  }
  if (a3)
  {
    v11 = 0;
    v12 = *a4;
    do
      *a3 = v11;
    while (*(_DWORD *)(v12 + 4 * v11++));
  }
  return 0;
}

uint64_t krb5_homedir_access(uint64_t a1)
{
  uint64_t v2;

  if (!geteuid() || a1 && (*(_BYTE *)(a1 + 360) & 4) == 0)
    return 0;
  pthread_mutex_lock(&stru_253D3A5A8);
  v2 = dword_2545A4D60;
  pthread_mutex_unlock(&stru_253D3A5A8);
  return v2;
}

uint64_t krb5_set_home_dir_access(uint64_t a1, int a2)
{
  unsigned int v3;
  uint64_t v4;
  unsigned int v5;

  if (a1)
  {
    v3 = *(_DWORD *)(a1 + 360);
    v4 = (v3 >> 2) & 1;
    if (a2)
      v5 = v3 | 4;
    else
      v5 = v3 & 0xFFFFFFFB;
    *(_DWORD *)(a1 + 360) = v5;
  }
  else
  {
    pthread_mutex_lock(&stru_253D3A5A8);
    v4 = dword_2545A4D60;
    dword_2545A4D60 = a2;
    pthread_mutex_unlock(&stru_253D3A5A8);
  }
  return v4;
}

uint64_t krb5_reload_config(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  BOOL v5;
  char **v7;
  char *v8;
  unsigned int v9;
  uint64_t v10;
  BOOL v11;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v21;
  void **v22;
  int check;

  v22 = 0;
  if (a3)
    *a3 = 0;
  check = 0;
  if (dword_253D3A59C == -1 || (!notify_check(dword_253D3A59C, &check) ? (v5 = check == 0) : (v5 = 1), v5))
  {
    if (dword_253D3A5A0 == -1)
      return 0;
    if (notify_check(dword_253D3A5A0, &check) || check == 0)
      return 0;
  }
  *(_QWORD *)(a1 + 128) = time(0);
  v7 = *(char ***)(a1 + 120);
  if (!v7)
    return 0;
  v8 = *v7;
  if (*v7)
  {
    v9 = 1;
    while (1)
    {
      v10 = krb5_config_parse_file_multi((_krb5_context *)a1, v8, &v22);
      v11 = v10 > 0xD || ((1 << v10) & 0x2007) == 0;
      if (v11 && (_DWORD)v10 != -1765328248)
        break;
      v8 = *(char **)(*(_QWORD *)(a1 + 120) + 8 * v9++);
      if (!v8)
        goto LABEL_26;
    }
    v21 = v10;
    krb5_config_file_free(a1, v22);
  }
  else
  {
LABEL_26:
    if (a3)
      *a3 = 1;
    krb5_config_file_free(a1, *(void ***)(a1 + 136));
    *(_QWORD *)(a1 + 136) = v22;
    return sub_2096823E0(a1, v13, v14, v15, v16, v17, v18, v19);
  }
  return v21;
}

uint64_t sub_209683338(char *a1, uint64_t a2, _QWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  void **strings;
  void **v11;
  uint64_t v12;
  uint64_t v13;
  void *v14;
  _DWORD *v15;
  _DWORD *v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;

  strings = (void **)krb5_config_get_strings((uint64_t)a1, 0, (uint64_t)a3, a4, a5, a6, a7, a8, (uint64_t)"libdefaults");
  if (!strings)
  {
    v16 = 0;
LABEL_15:
    v18 = 0;
    *a3 = v16;
    return v18;
  }
  v11 = strings;
  v12 = 0;
  v13 = 0;
  do
  {
    v14 = strings[v13++];
    v12 += 4;
  }
  while (v14);
  v15 = malloc_type_malloc(v12 & 0x3FFFFFFFCLL, 0x100004052888210uLL);
  if (v15)
  {
    v16 = v15;
    if (v13 == 1)
    {
      v17 = 0;
    }
    else
    {
      v19 = 0;
      v17 = 0;
      v20 = v13 - 1;
      do
      {
        if (!krb5_string_to_enctype(a1, (krb5_enctype *)v11[v19])
          && !krb5_enctype_valid((_krb5_context *)a1, 0))
        {
          v16[v17++] = 0;
        }
        ++v19;
      }
      while (v20 != v19);
    }
    v16[v17] = 0;
    krb5_config_free_strings(v11);
    goto LABEL_15;
  }
  krb5_config_free_strings(v11);
  v18 = 12;
  krb5_set_error_message((krb5_context)a1, 12, "malloc: out of memory");
  return v18;
}

__CFReadStream *sub_209683470()
{
  const __CFAllocator *v0;
  const __CFURL *v1;
  const __CFURL *v2;
  __CFReadStream *v3;
  void *v4;
  CFTypeID v5;
  __CFReadStream *Value;
  __CFReadStream *v7;
  CFErrorRef error;

  v0 = (const __CFAllocator *)*MEMORY[0x24BDBD240];
  v1 = CFURLCreateWithFileSystemPath((CFAllocatorRef)*MEMORY[0x24BDBD240], CFSTR("/Library/Managed Preferences/mobile/.GlobalPreferences.plist"), kCFURLPOSIXPathStyle, 0);
  if (!v1)
    return 0;
  v2 = v1;
  v3 = CFReadStreamCreateWithFile(v0, v1);
  CFRelease(v2);
  if (!v3)
    return v3;
  if (!CFReadStreamOpen(v3))
  {
    v7 = v3;
LABEL_11:
    CFRelease(v7);
    return 0;
  }
  error = 0;
  v4 = (void *)CFPropertyListCreateWithStream(v0, v3, 0, 0, 0, &error);
  CFRelease(v3);
  if (!v4)
    return 0;
  v5 = CFGetTypeID(v4);
  if (v5 != CFDictionaryGetTypeID())
  {
    v7 = (__CFReadStream *)v4;
    goto LABEL_11;
  }
  Value = (__CFReadStream *)CFDictionaryGetValue((CFDictionaryRef)v4, CFSTR("KerberosDebugLevel"));
  v3 = Value;
  if (Value)
    CFRetain(Value);
  CFRelease(v4);
  return v3;
}

uint64_t krb5_copy_host_realm(_krb5_context *a1, const char **a2, char *const **a3)
{
  uint64_t v6;
  size_t v8;
  char *const *v9;
  char *const *v10;
  const char *v11;
  uint64_t v12;
  _QWORD *v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;

  if (*a2)
  {
    v6 = 1;
    while (a2[v6++])
      ;
    v8 = v6;
  }
  else
  {
    v8 = 1;
  }
  v9 = (char *const *)malloc_type_calloc(v8, 8uLL, 0x10040436913F5uLL);
  *a3 = v9;
  if (!v9)
  {
LABEL_13:
    v16 = 12;
    krb5_set_error_message(a1, 12, "malloc: out of memory");
    return v16;
  }
  v10 = v9;
  v11 = *a2;
  if (*a2)
  {
    v12 = 0;
    v13 = a2 + 1;
    while (1)
    {
      v14 = strdup(v11);
      v15 = v12;
      v10[v15] = v14;
      v10 = *a3;
      if (!(*a3)[v15])
        break;
      v11 = (const char *)v13[v12++];
      if (!v11)
        return 0;
    }
    krb5_free_host_realm(a1, *a3);
    goto LABEL_13;
  }
  return 0;
}

void _krb5_crc_init_table()
{
  uint64_t i;
  int v1;
  unsigned int v2;

  if ((byte_2545A7990 & 1) == 0)
  {
    for (i = 0; i != 256; ++i)
    {
      v1 = -8;
      v2 = i;
      do
      {
        if ((v2 & 1) != 0)
          v2 = (v2 >> 1) ^ 0xEDB88320;
        else
          v2 >>= 1;
      }
      while (!__CFADD__(v1++, 1));
      dword_2545A7994[i] = v2;
    }
    byte_2545A7990 = 1;
  }
}

uint64_t _krb5_crc_update(char *a1, uint64_t a2, uint64_t a3)
{
  char v3;

  for (; a2; --a2)
  {
    v3 = *a1++;
    a3 = dword_2545A7994[(v3 ^ a3)] ^ (a3 >> 8);
  }
  return a3;
}

void krb5_free_cred_contents(krb5_context a1, krb5_creds *a2)
{
  krb5_free_principal(a1, *(krb5_principal *)&a2->magic);
  *(_QWORD *)&a2->magic = 0;
  krb5_free_principal(a1, a2->client);
  a2->client = 0;
  krb5_free_keyblock_contents(a1, (krb5_keyblock *)&a2->server);
  krb5_data_free(&a2->addresses);
  krb5_data_free(&a2->ticket.data);
  sub_2096BB628();
  krb5_free_addresses(a1, (krb5_address **)&a2[1]);
  *(_OWORD *)&a2->magic = 0u;
  *(_OWORD *)&a2->server = 0u;
  *(_OWORD *)&a2->keyblock.length = 0u;
  a2->times = 0u;
  *(_OWORD *)&a2->is_skey = 0u;
  a2->ticket = 0u;
  a2->second_ticket = 0u;
  *(_OWORD *)&a2->authdata = 0u;
  *(_OWORD *)&a2[1].client = 0u;
}

uint64_t krb5_copy_creds_contents(_krb5_context *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  __int128 v7;

  *(_OWORD *)(a3 + 112) = 0u;
  *(_OWORD *)(a3 + 128) = 0u;
  *(_OWORD *)(a3 + 80) = 0u;
  *(_OWORD *)(a3 + 96) = 0u;
  *(_OWORD *)(a3 + 48) = 0u;
  *(_OWORD *)(a3 + 64) = 0u;
  *(_OWORD *)(a3 + 16) = 0u;
  *(_OWORD *)(a3 + 32) = 0u;
  *(_OWORD *)a3 = 0u;
  v6 = krb5_copy_principal(a1, *(krb5_const_principal *)a2, (krb5_principal *)a3);
  if ((_DWORD)v6)
    goto LABEL_8;
  v6 = krb5_copy_principal(a1, *(krb5_const_principal *)(a2 + 8), (krb5_principal *)(a3 + 8));
  if ((_DWORD)v6)
    goto LABEL_8;
  v6 = krb5_copy_keyblock_contents(a1, (const krb5_keyblock *)(a2 + 16), (krb5_keyblock *)(a3 + 16));
  if ((_DWORD)v6
    || (v7 = *(_OWORD *)(a2 + 40),
        *(_OWORD *)(a3 + 56) = *(_OWORD *)(a2 + 56),
        *(_OWORD *)(a3 + 40) = v7,
        v6 = krb5_data_copy((_QWORD *)(a3 + 72), *(const void **)(a2 + 80), *(_QWORD *)(a2 + 72)),
        (_DWORD)v6)
    || (v6 = krb5_data_copy((_QWORD *)(a3 + 88), *(const void **)(a2 + 96), *(_QWORD *)(a2 + 88)), (_DWORD)v6)
    || (v6 = sub_2096BB638(), (_DWORD)v6)
    || (v6 = krb5_copy_addresses(a1, (krb5_address *const *)(a2 + 120), (krb5_address ***)(a3 + 120)), (_DWORD)v6))
  {
LABEL_8:
    krb5_free_cred_contents(a1, (krb5_creds *)a3);
  }
  else
  {
    *(_DWORD *)(a3 + 136) = *(_DWORD *)(a2 + 136);
  }
  return v6;
}

krb5_error_code krb5_copy_creds(krb5_context a1, const krb5_creds *a2, krb5_creds **a3)
{
  krb5_creds *v6;

  v6 = (krb5_creds *)malloc_type_malloc(0x90uLL, 0x10A0040AAA52FDDuLL);
  if (v6)
  {
    *(_OWORD *)&v6->authdata = 0u;
    *(_OWORD *)&v6[1].client = 0u;
    v6->ticket = 0u;
    v6->second_ticket = 0u;
    v6->times = 0u;
    *(_OWORD *)&v6->is_skey = 0u;
    *(_OWORD *)&v6->server = 0u;
    *(_OWORD *)&v6->keyblock.length = 0u;
    *(_OWORD *)&v6->magic = 0u;
    *a3 = v6;
    return krb5_copy_creds_contents(a1, (uint64_t)a2, (uint64_t)v6);
  }
  else
  {
    krb5_set_error_message(a1, 12, "malloc: out of memory");
    return 12;
  }
}

void krb5_free_creds(krb5_context a1, krb5_creds *a2)
{
  krb5_free_cred_contents(a1, a2);
  free(a2);
}

uint64_t krb5_compare_creds(krb5_context a1, int a2, uint64_t a3, uint64_t a4)
{
  const krb5_principal_data *v8;
  const krb5_principal_data *v9;
  uint64_t result;
  const krb5_principal_data *v11;
  const krb5_principal_data *v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;

  v8 = *(const krb5_principal_data **)(a3 + 8);
  if (v8)
  {
    v9 = *(const krb5_principal_data **)(a4 + 8);
    if ((a2 & 0xA0000000) != 0)
    {
      result = krb5_principal_compare_any_realm((uint64_t)a1, (uint64_t)v8, (uint64_t)v9);
      if (!(_DWORD)result)
        return result;
    }
    else
    {
      result = krb5_principal_compare(a1, v8, v9);
      if (!(_DWORD)result)
        return result;
    }
  }
  else
  {
    result = 1;
  }
  v11 = *(const krb5_principal_data **)a3;
  if (*(_QWORD *)a3)
  {
    v12 = *(const krb5_principal_data **)a4;
    if (a2 < 0)
    {
      result = krb5_principal_compare_any_realm((uint64_t)a1, (uint64_t)v11, (uint64_t)v12);
      if (!(_DWORD)result)
        return result;
    }
    else
    {
      result = krb5_principal_compare(a1, v11, v12);
      if (!(_DWORD)result)
        return result;
    }
  }
  if ((a2 & 0x40000000) != 0)
  {
    if (*(_DWORD *)(a3 + 16) != *(_DWORD *)(a4 + 16))
      return 0;
    result = 1;
  }
  if ((a2 & 0x10000000) != 0)
  {
    if (*(_DWORD *)(a3 + 136) != *(_DWORD *)(a4 + 136))
      return 0;
    result = 1;
  }
  if ((a2 & 0x8000000) != 0)
  {
    if ((*(_DWORD *)(a3 + 136) & ~*(_DWORD *)(a4 + 136)) != 0)
      return 0;
    result = 1;
  }
  if ((a2 & 0x4000000) == 0)
  {
    if ((a2 & 0x2000000) == 0)
      goto LABEL_23;
LABEL_34:
    if (*(_QWORD *)(a3 + 64) > *(_QWORD *)(a4 + 64) || *(_QWORD *)(a3 + 56) > *(_QWORD *)(a4 + 56))
      return 0;
    result = 1;
    if ((a2 & 0x1000000) == 0)
      goto LABEL_24;
    goto LABEL_37;
  }
  if (*(_QWORD *)(a3 + 48) != *(_QWORD *)(a4 + 48)
    || *(_QWORD *)(a3 + 40) != *(_QWORD *)(a4 + 40)
    || *(_QWORD *)(a3 + 56) != *(_QWORD *)(a4 + 56)
    || *(_QWORD *)(a3 + 64) != *(_QWORD *)(a4 + 64))
  {
    return 0;
  }
  result = 1;
  if ((a2 & 0x2000000) != 0)
    goto LABEL_34;
LABEL_23:
  if ((a2 & 0x1000000) == 0)
    goto LABEL_24;
LABEL_37:
  if (*(_DWORD *)(a3 + 104) != *(_DWORD *)(a4 + 104))
    return 0;
  if (*(_DWORD *)(a3 + 104))
  {
    v13 = 0;
    v14 = 0;
    while (1)
    {
      v15 = *(_QWORD *)(a3 + 112);
      v16 = *(_QWORD *)(a4 + 112);
      if (*(_DWORD *)(v15 + v13) != *(_DWORD *)(v16 + v13) || krb5_data_cmp(v15 + v13 + 8, v16 + v13 + 8))
        return 0;
      ++v14;
      v13 += 24;
      if (v14 >= *(unsigned int *)(a3 + 104))
      {
        result = 1;
        break;
      }
    }
  }
LABEL_24:
  if ((a2 & 0x800000) == 0)
    goto LABEL_27;
  if (krb5_data_cmp(a3 + 88, a4 + 88))
    return 0;
  result = 1;
LABEL_27:
  if ((a2 & 0x400000) != 0)
    return (*(_QWORD *)(a3 + 88) != 0) ^ (*(_QWORD *)(a4 + 88) == 0);
  return result;
}

uint64_t krb5_enctype_keysize(_krb5_context *a1, char *a2, _QWORD *a3)
{
  uint64_t v3;
  _UNKNOWN **i;

  v3 = dword_2545A4EE8;
  if (dword_2545A4EE8 < 1)
    return sub_209683BD0(a1, a2);
  for (i = &off_2545A4EB8; *(_DWORD *)*i != (_DWORD)a2; ++i)
  {
    if (!--v3)
      return sub_209683BD0(a1, a2);
  }
  *a3 = *(_QWORD *)(*((_QWORD *)*i + 5) + 24);
  return 0;
}

_DWORD *sub_209683B8C(int a1)
{
  uint64_t v1;
  _QWORD *i;
  _DWORD *v3;

  v1 = dword_2545A4EE8;
  if (dword_2545A4EE8 < 1)
    return 0;
  for (i = &off_2545A4EB8; ; ++i)
  {
    v3 = (_DWORD *)*i;
    if (*(_DWORD *)*i == a1)
      break;
    if (!--v1)
      return 0;
  }
  return v3;
}

uint64_t sub_209683BD0(_krb5_context *a1, char *a2)
{
  uint64_t v3;
  char *v4;
  char *v6;

  v6 = 0;
  v3 = krb5_enctype_to_string((krb5_enctype)a1, a2, (size_t)&v6);
  if (!(_DWORD)v3)
  {
    v3 = 2529639062;
    v4 = v6;
    krb5_set_error_message(a1, -1765328234, "Encryption type %s not supported", v6);
    free(v4);
  }
  return v3;
}

uint64_t krb5_enctype_keybits(_krb5_context *a1, char *a2, _QWORD *a3)
{
  uint64_t v3;
  _UNKNOWN **i;

  v3 = dword_2545A4EE8;
  if (dword_2545A4EE8 < 1)
    return sub_209683BD0(a1, a2);
  for (i = &off_2545A4EB8; *(_DWORD *)*i != (_DWORD)a2; ++i)
  {
    if (!--v3)
      return sub_209683BD0(a1, a2);
  }
  *a3 = *(_QWORD *)(*((_QWORD *)*i + 5) + 16);
  return 0;
}

uint64_t krb5_generate_random_keyblock(_krb5_context *a1, char *a2, uint64_t a3)
{
  int v3;
  uint64_t v5;
  _QWORD *i;
  _DWORD *v8;
  uint64_t result;
  void (*v10)(_krb5_context *, uint64_t);

  v3 = (int)a2;
  v5 = dword_2545A4EE8;
  if (dword_2545A4EE8 < 1)
    return sub_209683BD0(a1, a2);
  for (i = &off_2545A4EB8; ; ++i)
  {
    v8 = (_DWORD *)*i;
    if (*(_DWORD *)*i == (_DWORD)a2)
      break;
    if (!--v5)
      return sub_209683BD0(a1, a2);
  }
  result = krb5_data_alloc((size_t *)(a3 + 8), *(_QWORD *)(*((_QWORD *)v8 + 5) + 24));
  if (!(_DWORD)result)
  {
    *(_DWORD *)a3 = v3;
    v10 = *(void (**)(_krb5_context *, uint64_t))(*((_QWORD *)v8 + 5) + 40);
    if (v10)
      v10(a1, a3);
    else
      krb5_generate_random_block(*(_QWORD *)(a3 + 16), *(_QWORD *)(a3 + 8));
    return 0;
  }
  return result;
}

uint64_t sub_209683D50(uint64_t a1, uint64_t a2, const void *a3, size_t a4, uint64_t a5, uint64_t *a6, uint64_t a7)
{
  char *v14;
  char *v15;
  char *v16;
  char *v17;
  uint64_t v18;
  unint64_t v19;
  char **v20;
  uint64_t v21;
  char *v22;
  char *v23;
  char *v24;
  char v25;

  v14 = (char *)malloc_type_malloc(*(_QWORD *)(a2 + 16) + a4, 0xCD580FFuLL);
  if (v14)
  {
    v15 = v14;
    v16 = (char *)malloc_type_malloc(*(_QWORD *)(a2 + 24) + *(_QWORD *)(a2 + 16), 0xBBFCCF0CuLL);
    if (!v16)
    {
      v21 = 12;
      v17 = v15;
LABEL_12:
      free(v17);
      return v21;
    }
    v17 = v16;
    memset(v15, 54, *(_QWORD *)(a2 + 16));
    memset(v17, 92, *(_QWORD *)(a2 + 16));
    v18 = *a6;
    v19 = *(_QWORD *)(*a6 + 8);
    if (v19 <= *(_QWORD *)(a2 + 16))
    {
      v20 = (char **)(v18 + 16);
      if (!v19)
      {
LABEL_11:
        memcpy(&v15[*(_QWORD *)(a2 + 16)], a3, a4);
        (*(void (**)(uint64_t, uint64_t *, char *, size_t, uint64_t, uint64_t))(a2 + 40))(a1, a6, v15, *(_QWORD *)(a2 + 16) + a4, a5, a7);
        memcpy(&v17[*(_QWORD *)(a2 + 16)], *(const void **)(a7 + 16), *(_QWORD *)(a7 + 8));
        (*(void (**)(uint64_t, uint64_t *, char *, _QWORD, uint64_t, uint64_t))(a2 + 40))(a1, a6, v17, *(_QWORD *)(a2 + 24) + *(_QWORD *)(a2 + 16), a5, a7);
        bzero(v15, *(_QWORD *)(a2 + 16) + a4);
        free(v15);
        bzero(v17, *(_QWORD *)(a2 + 24) + *(_QWORD *)(a2 + 16));
        v21 = 0;
        goto LABEL_12;
      }
    }
    else
    {
      (*(void (**)(uint64_t, uint64_t *, _QWORD))(a2 + 40))(a1, a6, *(_QWORD *)(v18 + 16));
      v20 = (char **)(a7 + 16);
      v19 = *(_QWORD *)(a7 + 8);
      if (!v19)
        goto LABEL_11;
    }
    v22 = *v20;
    v23 = v15;
    v24 = v17;
    do
    {
      *v23++ ^= *v22;
      v25 = *v22++;
      *v24++ ^= v25;
      --v19;
    }
    while (v19);
    goto LABEL_11;
  }
  return 12;
}

uint64_t krb5_hmac(krb5_context a1, int a2, const void *a3, size_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v8;
  _DWORD **v9;
  _DWORD *v10;
  uint64_t v11;
  uint64_t v13;
  krb5_data *v14;

  v8 = dword_2545A4EB0;
  if (dword_2545A4EB0 < 1)
  {
LABEL_5:
    v11 = 2529639065;
    krb5_set_error_message(a1, -1765328231, "checksum type %d not supported", a2);
  }
  else
  {
    v9 = (_DWORD **)&off_2545A4E78;
    while (1)
    {
      v10 = *v9;
      if (**v9 == a2)
        break;
      ++v9;
      if (!--v8)
        goto LABEL_5;
    }
    v13 = a6;
    v14 = 0;
    v11 = sub_209683D50((uint64_t)a1, (uint64_t)v10, a3, a4, a5, &v13, a7);
    if (v14)
      krb5_free_data(a1, v14);
  }
  return v11;
}

_DWORD *sub_209683FE0(int a1)
{
  uint64_t v1;
  _QWORD *i;
  _DWORD *v3;

  v1 = dword_2545A4EB0;
  if (dword_2545A4EB0 < 1)
    return 0;
  for (i = &off_2545A4E78; ; ++i)
  {
    v3 = (_DWORD *)*i;
    if (*(_DWORD *)*i == a1)
      break;
    if (!--v1)
      return 0;
  }
  return v3;
}

uint64_t sub_209684024(_krb5_context *a1, uint64_t *a2, const void *a3, size_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v9;
  _DWORD **v10;
  _DWORD *v11;
  __int128 v13;
  void *__src;
  char v15;
  uint64_t v16;

  v16 = *MEMORY[0x24BDAC8D0];
  v9 = dword_2545A4EB0;
  if (dword_2545A4EB0 < 1)
  {
LABEL_5:
    v11 = 0;
  }
  else
  {
    v10 = (_DWORD **)&off_2545A4E78;
    while (1)
    {
      v11 = *v10;
      if (**v10 == 14)
        break;
      ++v10;
      if (!--v9)
        goto LABEL_5;
    }
  }
  __src = &v15;
  v13 = xmmword_2096D9380;
  if (sub_209683D50((uint64_t)a1, (uint64_t)v11, a3, a4, a5, a2, (uint64_t)&v13))
    krb5_abortx(a1, "hmac failed");
  memcpy(*(void **)(a6 + 16), __src, *(_QWORD *)(a6 + 8));
  return 0;
}

uint64_t sub_2096840FC(_krb5_context *a1)
{
  uint64_t result;

  result = CCDigest();
  if ((_DWORD)result)
    krb5_abortx(a1, "sha1 checksum failed");
  return result;
}

uint64_t krb5_create_checksum(krb5_context a1, _DWORD **a2, unsigned int a3, int a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v12;
  int **v13;
  int *v14;
  uint64_t v15;
  uint64_t v16;
  unsigned int v18;

  if (a4)
  {
    v12 = dword_2545A4EB0;
    if (dword_2545A4EB0 >= 1)
    {
      v13 = (int **)&off_2545A4E78;
      do
      {
        v14 = *v13;
        if (**v13 == a4)
          goto LABEL_11;
        ++v13;
      }
      while (--v12);
    }
LABEL_14:
    v16 = 2529639065;
    krb5_set_error_message(a1, -1765328231, "checksum type %d not supported", a4);
    return v16;
  }
  if (!a2)
    goto LABEL_14;
  v14 = (int *)*((_QWORD *)*a2 + 7);
  if (!v14)
  {
    v14 = (int *)*((_QWORD *)*a2 + 6);
    if (!v14)
      goto LABEL_14;
  }
  a4 = *v14;
LABEL_11:
  if (a4 == -138 && *a2[1] == 23)
  {
    v18 = a3;
    sub_2096B4D98((uint64_t)a1, (int *)&v18);
    v15 = v18;
  }
  else
  {
    v15 = (a3 << 8) | 0x99;
    v18 = (a3 << 8) | 0x99;
  }
  return sub_20968426C(a1, (uint64_t)v14, (uint64_t)a2, v15, a5, a6, a7);
}

uint64_t sub_20968426C(krb5_context a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  int v8;
  uint64_t v14;
  uint64_t v16;

  v8 = *(_DWORD *)(a2 + 32);
  if ((v8 & 0x40) != 0)
  {
    v14 = 2529639065;
    krb5_clear_error_message(a1);
    return v14;
  }
  if (!a3 && (v8 & 1) != 0)
  {
    v14 = 2529639065;
    krb5_set_error_message(a1, -1765328231, "Checksum type %s is keyed but no crypto context (key) was passed in", *(const char **)(a2 + 8));
    return v14;
  }
  v16 = 0;
  if ((v8 & 1) != 0)
  {
    v14 = sub_2096871FC(a1, a3, a4, a2, &v16);
    if ((_DWORD)v14)
      return v14;
  }
  *(_DWORD *)a7 = *(_DWORD *)a2;
  v14 = krb5_data_alloc((size_t *)(a7 + 8), *(_QWORD *)(a2 + 24));
  if ((_DWORD)v14)
    return v14;
  return (*(uint64_t (**)(krb5_context, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(a2 + 40))(a1, v16, a5, a6, a4, a7);
}

krb5_error_code krb5_verify_checksum(krb5_context context, krb5_cksumtype ctype, const krb5_checksum *cksum, krb5_const_pointer in, size_t in_length, krb5_const_pointer seed, size_t seed_length)
{
  int v8;
  uint64_t v9;
  uint64_t v13;
  _DWORD **v14;
  krb5_error_code v15;
  uint64_t v16;
  unsigned int v18;

  v8 = *(_DWORD *)seed;
  v9 = dword_2545A4EB0;
  if (dword_2545A4EB0 < 1)
  {
LABEL_5:
    v15 = -1765328231;
    krb5_set_error_message(context, -1765328231, "checksum type %d not supported", *(_DWORD *)seed);
  }
  else
  {
    v13 = *(_QWORD *)&ctype;
    v14 = (_DWORD **)&off_2545A4E78;
    while (**v14 != v8)
    {
      ++v14;
      if (!--v9)
        goto LABEL_5;
    }
    if (v8 == -138 && **(_DWORD **)(*(_QWORD *)&ctype + 8) == 23)
    {
      v18 = cksum;
      sub_2096B4D98((uint64_t)context, (int *)&v18);
      v16 = v18;
    }
    else
    {
      v16 = ((_DWORD)cksum << 8) | 0x99u;
      v18 = v16;
    }
    return sub_20968448C(context, v13, v16, (uint64_t)in, in_length, (unsigned int *)seed);
  }
  return v15;
}

uint64_t sub_20968448C(krb5_context a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unsigned int *a6)
{
  _krb5_context *v6;
  uint64_t v7;
  uint64_t v8;
  _DWORD **v14;
  _DWORD *v15;
  int v16;
  const char **v17;
  uint64_t (*v18)(_krb5_context *, uint64_t, uint64_t, uint64_t, uint64_t, unsigned int *);
  uint64_t v19;
  const char *v20;
  const char *v21;
  krb5_error_code v22;
  _DWORD *v24;
  uint64_t v25;
  const char *v26;
  uint64_t v27;
  const char *v28;
  uint64_t v29;
  uint64_t v30;
  size_t v31[2];
  uint64_t v32;

  v6 = a1;
  v7 = *a6;
  v8 = dword_2545A4EB0;
  if (dword_2545A4EB0 < 1)
    goto LABEL_14;
  v30 = 0;
  v31[0] = 0;
  v31[1] = 0;
  v14 = (_DWORD **)&off_2545A4E78;
  while (1)
  {
    v15 = *v14;
    if (**v14 == (_DWORD)v7)
      break;
    ++v14;
    if (!--v8)
      goto LABEL_14;
  }
  v16 = v15[8];
  if ((v16 & 0x40) != 0)
  {
LABEL_14:
    v19 = 2529639065;
    v27 = v7;
    v21 = "checksum type %d not supported";
LABEL_15:
    v22 = -1765328231;
LABEL_16:
    krb5_set_error_message(a1, v22, v21, v27, v28, v29);
    return v19;
  }
  v17 = (const char **)(a6 + 2);
  if (*((_QWORD *)v15 + 3) != *((_QWORD *)a6 + 1))
  {
    krb5_clear_error_message(a1);
    v19 = 2529638943;
    v28 = *v17;
    v29 = *((_QWORD *)v15 + 3);
    v27 = *((_QWORD *)v15 + 1);
    v21 = "Decrypt integrity check failed for checksum type %s, length was %u, expected %u";
LABEL_19:
    a1 = v6;
    v22 = v19;
    goto LABEL_16;
  }
  v32 = 0;
  if ((v16 & 1) == 0)
  {
    v32 = 0;
    goto LABEL_10;
  }
  if (!a2)
  {
    v19 = 2529639065;
    v27 = *((_QWORD *)v15 + 1);
    v21 = "Checksum type %s is keyed but no crypto context (key) was passed in";
    goto LABEL_15;
  }
  v24 = *(_DWORD **)(*(_QWORD *)a2 + 56);
  if (v24 && *v24 != (_DWORD)v7)
  {
    v19 = 2529639065;
    v27 = *((_QWORD *)v15 + 1);
    v28 = *(const char **)(*(_QWORD *)a2 + 8);
    v21 = "Checksum type %s is keyed, but the key type %s passed didnt have that checksum type as the keyed type";
    goto LABEL_15;
  }
  v19 = sub_2096871FC(a1, a2, a3, (uint64_t)v15, &v32);
  if ((_DWORD)v19)
    return v19;
LABEL_10:
  v18 = (uint64_t (*)(_krb5_context *, uint64_t, uint64_t, uint64_t, uint64_t, unsigned int *))*((_QWORD *)v15 + 6);
  if (v18)
  {
    v19 = v18(v6, v32, a4, a5, a3, a6);
    if ((_DWORD)v19)
    {
      if (a2)
        v20 = *(const char **)(*(_QWORD *)a2 + 8);
      else
        v20 = "(none)";
      v27 = *((_QWORD *)v15 + 1);
      v28 = v20;
      v21 = "Decrypt integrity check failed for checksum type %s, key type %s";
      goto LABEL_19;
    }
  }
  else
  {
    v19 = krb5_data_alloc(v31, *((_QWORD *)v15 + 3));
    if (!(_DWORD)v19)
    {
      v25 = (*((uint64_t (**)(_krb5_context *, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t *))v15 + 5))(v6, v32, a4, a5, a3, &v30);
      if ((_DWORD)v25)
      {
        v19 = v25;
      }
      else if (krb5_data_ct_cmp((uint64_t)v31, (uint64_t)v17))
      {
        if (a2)
          v26 = *(const char **)(*(_QWORD *)a2 + 8);
        else
          v26 = "(unkeyed)";
        v19 = 2529638943;
        krb5_set_error_message(v6, -1765328353, "Decrypt integrity check failed for checksum type %s, key type %s", *((const char **)v15 + 1), v26);
      }
      else
      {
        v19 = 0;
      }
      krb5_data_free(v31);
    }
  }
  return v19;
}

uint64_t krb5_crypto_get_checksum_type(_krb5_context *a1, uint64_t a2, _DWORD *a3)
{
  _DWORD *v3;
  uint64_t v4;

  if (a2 && ((v3 = *(_DWORD **)(*(_QWORD *)a2 + 56)) != 0 || (v3 = *(_DWORD **)(*(_QWORD *)a2 + 48)) != 0))
  {
    v4 = 0;
    *a3 = *v3;
  }
  else
  {
    v4 = 2529639065;
    krb5_set_error_message(a1, -1765328231, "checksum type not found");
  }
  return v4;
}

uint64_t krb5_checksumsize(_krb5_context *a1, int a2, _QWORD *a3)
{
  uint64_t v3;
  _UNKNOWN **v4;
  uint64_t v5;

  v3 = dword_2545A4EB0;
  if (dword_2545A4EB0 < 1)
  {
LABEL_5:
    v5 = 2529639065;
    krb5_set_error_message(a1, -1765328231, "checksum type %d not supported", a2);
  }
  else
  {
    v4 = &off_2545A4E78;
    while (*(_DWORD *)*v4 != a2)
    {
      ++v4;
      if (!--v3)
        goto LABEL_5;
    }
    v5 = 0;
    *a3 = *((_QWORD *)*v4 + 3);
  }
  return v5;
}

uint64_t krb5_checksum_is_keyed(uint64_t a1, int a2)
{
  uint64_t v2;
  _UNKNOWN **i;

  v2 = dword_2545A4EB0;
  if (dword_2545A4EB0 < 1)
    return 0;
  for (i = &off_2545A4E78; *(_DWORD *)*i != a2; ++i)
  {
    if (!--v2)
      return 0;
  }
  return *((_DWORD *)*i + 8) & 1;
}

uint64_t krb5_checksum_is_collision_proof(uint64_t a1, int a2)
{
  uint64_t v2;
  _UNKNOWN **i;

  v2 = dword_2545A4EB0;
  if (dword_2545A4EB0 < 1)
    return 0;
  for (i = &off_2545A4E78; *(_DWORD *)*i != a2; ++i)
  {
    if (!--v2)
      return 0;
  }
  return (*((_DWORD *)*i + 8) >> 1) & 1;
}

uint64_t krb5_checksum_disable(_krb5_context *a1, int a2)
{
  uint64_t v2;
  _UNKNOWN **v3;
  uint64_t v4;

  v2 = dword_2545A4EB0;
  if (dword_2545A4EB0 < 1)
  {
LABEL_5:
    v4 = 2529639065;
    if (a1)
      krb5_set_error_message(a1, -1765328231, "checksum type %d not supported", a2);
  }
  else
  {
    v3 = &off_2545A4E78;
    while (*(_DWORD *)*v3 != a2)
    {
      ++v3;
      if (!--v2)
        goto LABEL_5;
    }
    v4 = 0;
    *((_DWORD *)*v3 + 8) |= 0x40u;
  }
  return v4;
}

krb5_error_code krb5_enctype_to_string(krb5_enctype a1, char *a2, size_t a3)
{
  _krb5_context *v4;
  uint64_t v5;
  _UNKNOWN **v6;
  const char **v7;
  unint64_t v8;
  const char *v9;
  char *v10;
  krb5_error_code v11;

  v4 = *(_krb5_context **)&a1;
  v5 = dword_2545A4EE8;
  if (dword_2545A4EE8 < 1)
  {
LABEL_5:
    if (dword_2545A4F20 < 1)
      goto LABEL_16;
    v7 = (const char **)&off_2545A4EF8;
    v8 = 1;
    do
    {
      if (*((_DWORD *)v7 - 2) == (_DWORD)a2)
        v9 = *v7;
      else
        v9 = 0;
      if (v8 >= dword_2545A4F20)
        break;
      v7 += 2;
      ++v8;
    }
    while (!v9);
    if (!v9)
    {
LABEL_16:
      v11 = -1765328234;
      krb5_set_error_message(v4, -1765328234, "encryption type %d not supported", (_DWORD)a2);
      *(_QWORD *)a3 = 0;
      return v11;
    }
  }
  else
  {
    v6 = &off_2545A4EB8;
    while (*(_DWORD *)*v6 != (_DWORD)a2)
    {
      ++v6;
      if (!--v5)
        goto LABEL_5;
    }
    v9 = (const char *)*((_QWORD *)*v6 + 1);
    if (!v9)
      goto LABEL_16;
  }
  v10 = strdup(v9);
  *(_QWORD *)a3 = v10;
  if (v10)
    return 0;
  v11 = 12;
  krb5_set_error_message(v4, 12, "malloc: out of memory");
  return v11;
}

krb5_error_code krb5_string_to_enctype(char *a1, krb5_enctype *a2)
{
  _DWORD *v2;
  uint64_t v5;
  _DWORD *v6;
  _UNKNOWN **v7;
  _DWORD *v8;
  krb5_error_code v9;

  v5 = dword_2545A4EE8;
  if (dword_2545A4EE8 < 1)
  {
LABEL_5:
    v9 = -1765328234;
    krb5_set_error_message((krb5_context)a1, -1765328234, "encryption type %s not supported", (const char *)a2);
  }
  else
  {
    v6 = v2;
    v7 = &off_2545A4EB8;
    while (1)
    {
      v8 = *v7;
      if (!strcasecmp(*((const char **)*v7 + 1), (const char *)a2))
        break;
      ++v7;
      if (!--v5)
        goto LABEL_5;
    }
    v9 = 0;
    *v6 = *v8;
  }
  return v9;
}

uint64_t krb5_enctype_valid(_krb5_context *a1, char *a2)
{
  uint64_t v2;
  const char ***v3;
  const char **v4;
  uint64_t v6;

  v2 = dword_2545A4EE8;
  if (dword_2545A4EE8 < 1)
  {
LABEL_5:
    if (a1)
      return sub_209683BD0(a1, a2);
    return 2529639062;
  }
  else
  {
    v3 = (const char ***)&off_2545A4EB8;
    while (1)
    {
      v4 = *v3;
      if (*(_DWORD *)*v3 == (_DWORD)a2)
        break;
      ++v3;
      if (!--v2)
        goto LABEL_5;
    }
    if (((_BYTE)v4[8] & 0x40) != 0)
    {
      v6 = 2529639062;
      if (a1)
        krb5_set_error_message(a1, -1765328234, "encryption type %s is disabled", v4[1]);
    }
    else
    {
      return 0;
    }
  }
  return v6;
}

uint64_t krb5_cksumtype_valid(_krb5_context *a1, int a2)
{
  uint64_t v2;
  _UNKNOWN **v3;
  uint64_t v4;

  v2 = dword_2545A4EB0;
  if (dword_2545A4EB0 < 1)
  {
LABEL_5:
    v4 = 2529639065;
    krb5_set_error_message(a1, -1765328231, "checksum type %d not supported");
  }
  else
  {
    v3 = &off_2545A4E78;
    while (*(_DWORD *)*v3 != a2)
    {
      ++v3;
      if (!--v2)
        goto LABEL_5;
    }
    if ((*((_BYTE *)*v3 + 32) & 0x40) != 0)
    {
      v4 = 2529639065;
      krb5_set_error_message(a1, -1765328231, "checksum type %s is disabled");
    }
    else
    {
      return 0;
    }
  }
  return v4;
}

uint64_t krb5_encrypt_iov_ivec(_krb5_context *a1, uint64_t a2, unsigned int a3, uint64_t a4, unsigned int a5, uint64_t a6)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  size_t v19;
  uint64_t v20;
  uint64_t v21;
  size_t v22;
  uint64_t v23;
  uint64_t v24;
  void **v25;
  uint64_t v26;
  size_t v27;
  _QWORD *v28;
  uint64_t v29;
  char *v30;
  char *v31;
  uint64_t v32;
  uint64_t v33;
  char *v34;
  char *v35;
  char *v36;
  char *v37;
  char *v38;
  uint64_t v39;
  uint64_t v40;
  pthread_mutex_t *v41;
  uint64_t v42;
  unsigned int **v44;
  char *v45;
  uint64_t v46;
  char *v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  void *v51;
  uint64_t v52;
  uint64_t v53;
  _krb5_context *v55;
  size_t __n;
  char *__na;
  size_t v58;
  size_t v59;
  unsigned int **v60;
  uint64_t v61;
  uint64_t v62;
  void *__src;

  if ((a5 & 0x80000000) != 0)
    goto LABEL_54;
  v7 = *(_QWORD *)a2;
  if ((*(_BYTE *)(*(_QWORD *)a2 + 64) & 4) == 0)
  {
    krb5_clear_error_message(a1);
    return 2529639090;
  }
  v11 = a4;
  if (!a5)
    return 2529639102;
  v12 = 0;
  v13 = a5;
  v14 = (_QWORD *)(a4 + 8);
  v15 = a5;
  do
  {
    if (*((_DWORD *)v14 - 2) == 2)
      v12 += *v14;
    v14 += 3;
    --v15;
  }
  while (v15);
  v16 = *(_QWORD *)(v7 + 32);
  v17 = v12 + v16;
  v18 = (v12 + v16 + *(_QWORD *)(v7 + 24) - 1) & -*(_QWORD *)(v7 + 24);
  v19 = v18 - (v12 + v16);
  v20 = a4 + 8;
  v21 = a5;
  while (*(_DWORD *)(v20 - 8) != 1)
  {
    v20 += 24;
    if (!--v21)
      return 2529639102;
  }
  if (*(_QWORD *)v20 != v16)
    return 2529639102;
  v55 = a1;
  __n = *(_QWORD *)(*(_QWORD *)(v7 + 56) + 24);
  v58 = v19;
  v59 = v18;
  krb5_generate_random_block(*(_QWORD *)(v20 + 8), v16);
  v22 = v59;
  v23 = a5;
  v24 = v11;
  while (*(_DWORD *)v24 != 4)
  {
    v24 += 24;
    if (!--v23)
    {
      if (v59 != v17)
        return 2529639102;
LABEL_22:
      v24 = 0;
      goto LABEL_24;
    }
  }
  if (*(_QWORD *)(v24 + 8) < v58)
    return 2529639102;
  *(_QWORD *)(v24 + 8) = v58;
  if (v59 == v17)
    goto LABEL_22;
  memset(*(void **)(v24 + 16), v58, v58);
  v22 = v59;
LABEL_24:
  v25 = (void **)(v11 + 16);
  v26 = a5;
  while (*((_DWORD *)v25 - 4) != 5)
  {
    v25 += 3;
    if (!--v26)
      return 2529639102;
  }
  v53 = a6;
  v8 = 2529639102;
  if (*(v25 - 1) != (void *)__n)
    return v8;
  v27 = v22;
  if (a5)
  {
    v28 = (_QWORD *)(v11 + 8);
    v29 = a5;
    v27 = v22;
    do
    {
      if (*((_DWORD *)v28 - 2) == 3)
        v27 += *v28;
      v28 += 3;
      --v29;
    }
    while (v29);
  }
  v52 = v27;
  v30 = (char *)malloc_type_malloc(v27, 0x524DCC0BuLL);
  memcpy(v30, *(const void **)(v20 + 8), *(_QWORD *)v20);
  v50 = a5;
  v51 = v30;
  v31 = &v30[*(_QWORD *)v20];
  if (a5)
  {
    v32 = v11 + 8;
    do
    {
      if ((*(_DWORD *)(v32 - 8) & 0xFFFFFFFE) == 2)
      {
        v33 = v11;
        v34 = v31;
        memcpy(v31, *(const void **)(v32 + 8), *(_QWORD *)v32);
        v35 = v34;
        v11 = v33;
        v31 = &v35[*(_QWORD *)v32];
      }
      v32 += 24;
      --v13;
    }
    while (v13);
  }
  if (v24)
    bzero(v31, *(_QWORD *)(v24 + 8));
  v61 = 0;
  v62 = 0;
  __src = 0;
  v8 = sub_20968426C(v55, *(_QWORD *)(v7 + 56), a2, (a3 << 8) | 0x55, (uint64_t)v51, v52, (uint64_t)&v61);
  free(v51);
  if ((_DWORD)v8)
    return v8;
  if (v62 != __n)
  {
    sub_2096BB8BC();
    a1 = v55;
LABEL_54:
    krb5_clear_error_message(a1);
    return 2529639090;
  }
  memcpy(*v25, __src, __n);
  sub_2096BB8BC();
  v36 = (char *)malloc_type_malloc(v59, 0x28A590FuLL);
  if (!v36)
    return 12;
  v37 = v36;
  v60 = 0;
  memcpy(v36, *(const void **)(v20 + 8), *(_QWORD *)v20);
  __na = v37;
  v38 = &v37[*(_QWORD *)v20];
  if (a5)
  {
    v39 = v11 + 8;
    v40 = a5;
    do
    {
      if (*(_DWORD *)(v39 - 8) == 2)
      {
        memcpy(v38, *(const void **)(v39 + 8), *(_QWORD *)v39);
        v38 += *(_QWORD *)v39;
      }
      v39 += 24;
      --v40;
    }
    while (v40);
  }
  if (v24)
    bzero(v38, *(_QWORD *)(v24 + 8));
  v41 = (pthread_mutex_t *)(a2 + 40);
  pthread_mutex_lock((pthread_mutex_t *)(a2 + 40));
  v42 = sub_209685110(v55, a2, (a3 << 8) | 0xAA, (uint64_t *)&v60);
  if ((_DWORD)v42)
  {
    v8 = v42;
LABEL_58:
    v45 = __na;
LABEL_59:
    free(v45);
    return v8;
  }
  v44 = v60;
  v8 = sub_209685208(v55, v60);
  pthread_mutex_unlock(v41);
  if ((_DWORD)v8)
    goto LABEL_58;
  v46 = (*(uint64_t (**)(_krb5_context *, unsigned int **, char *, size_t, uint64_t, _QWORD, uint64_t))(v7 + 72))(v55, v44, __na, v59, 1, a3, v53);
  if ((_DWORD)v46)
  {
    v8 = v46;
    v45 = __na;
    goto LABEL_59;
  }
  memcpy(*(void **)(v20 + 8), __na, *(_QWORD *)v20);
  v47 = &__na[*(_QWORD *)v20];
  if (a5)
  {
    v48 = v11 + 8;
    v49 = v50;
    do
    {
      if (*(_DWORD *)(v48 - 8) == 2)
      {
        memcpy(*(void **)(v48 + 8), v47, *(_QWORD *)v48);
        v47 += *(_QWORD *)v48;
      }
      v48 += 24;
      --v49;
    }
    while (v49);
  }
  if (v24)
    memcpy(*(void **)(v24 + 16), v47, v58);
  free(__na);
  return 0;
}

uint64_t sub_209685110(_krb5_context *a1, uint64_t a2, unsigned int a3, uint64_t *a4)
{
  uint64_t v8;
  _DWORD **v9;
  char *v10;
  uint64_t v11;
  uint64_t v12;
  _BYTE v14[5];

  v8 = *(unsigned int *)(a2 + 24);
  if ((int)v8 < 1)
  {
LABEL_5:
    v10 = sub_20968731C(a2, a3);
    if (v10)
    {
      v11 = (uint64_t)v10;
      krb5_copy_keyblock(a1, *(const krb5_keyblock **)(a2 + 8), (krb5_keyblock **)v10);
      _krb5_put_int((uint64_t)v14, a3, 5);
      sub_209686428(a1, *(_QWORD *)a2, v11, v14, 5uLL);
      v12 = 0;
      *a4 = v11;
    }
    else
    {
      pthread_mutex_unlock((pthread_mutex_t *)(a2 + 40));
      v12 = 12;
      krb5_set_error_message(a1, 12, "malloc: out of memory");
    }
  }
  else
  {
    v9 = *(_DWORD ***)(a2 + 32);
    while (**v9 != a3)
    {
      ++v9;
      if (!--v8)
        goto LABEL_5;
    }
    v12 = 0;
    *a4 = (uint64_t)(*v9 + 2);
  }
  return v12;
}

uint64_t sub_209685208(_krb5_context *a1, unsigned int **a2)
{
  char *v4;
  uint64_t v5;
  _UNKNOWN **i;
  uint64_t v8;
  uint64_t v9;
  size_t *v10;

  v4 = (char *)**a2;
  v5 = dword_2545A4EE8;
  if (dword_2545A4EE8 < 1)
    return sub_209683BD0(a1, v4);
  for (i = &off_2545A4EB8; *(_DWORD *)*i != (_DWORD)v4; ++i)
  {
    if (!--v5)
      return sub_209683BD0(a1, v4);
  }
  v8 = *((_QWORD *)*i + 5);
  if (!*(_QWORD *)(v8 + 48) || a2[1])
    return 0;
  v10 = (size_t *)malloc_type_calloc(1uLL, 0x10uLL, 0x108004057E67DB5uLL);
  a2[1] = (unsigned int *)v10;
  if (v10)
  {
    v9 = krb5_data_alloc(v10, *(_QWORD *)(v8 + 32));
    if ((_DWORD)v9)
    {
      free(a2[1]);
      a2[1] = 0;
    }
    else
    {
      (*(void (**)(_krb5_context *, uint64_t, unsigned int **))(v8 + 48))(a1, v8, a2);
    }
  }
  else
  {
    v9 = 12;
    krb5_set_error_message(a1, 12, "malloc: out of memory");
  }
  return v9;
}

uint64_t krb5_decrypt_iov_ivec(krb5_context a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int a5, uint64_t a6)
{
  uint64_t v7;
  uint64_t v8;
  size_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  _QWORD *v19;
  char *v20;
  char *v21;
  char *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  void *v26;
  uint64_t v27;
  int v28;
  char *v29;
  uint64_t v30;
  uint64_t v31;
  _QWORD *v32;
  uint64_t v33;
  uint64_t v34;
  void *v35;
  uint64_t v36;
  char *v37;
  uint64_t v38;
  unsigned int **v40;
  uint64_t v41;
  _krb5_context *v42;
  char *v43;
  uint64_t v44;
  unsigned int **v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;

  v7 = *(_QWORD *)a2;
  if ((*(_BYTE *)(*(_QWORD *)a2 + 64) & 4) == 0)
  {
    krb5_clear_error_message(a1);
    return 2529639090;
  }
  v8 = 2529639102;
  if (a5)
  {
    v13 = *(_QWORD *)(v7 + 32);
    v14 = a5;
    v15 = a4 + 8;
    v16 = a5;
    while (*(_DWORD *)(v15 - 8) != 1)
    {
      v15 += 24;
      if (!--v16)
        return v8;
    }
    if (*(_QWORD *)v15 == v13)
    {
      v17 = a4;
      while (*(_DWORD *)v17 != 5)
      {
        v17 += 24;
        if (!--v14)
        {
          v17 = 0;
          break;
        }
      }
      if (*(_QWORD *)(v17 + 8) == *(_QWORD *)(*(_QWORD *)(v7 + 56) + 24))
      {
        if (a5 <= 1)
          v18 = 1;
        else
          v18 = a5;
        v19 = (_QWORD *)(a4 + 8);
        v44 = v18;
        do
        {
          if (*((_DWORD *)v19 - 2) == 2)
            v13 += *v19;
          v19 += 3;
          --v18;
        }
        while (v18);
        if (v13 % *(_QWORD *)(v7 + 24))
        {
          krb5_clear_error_message(a1);
          return v8;
        }
        v20 = (char *)malloc_type_malloc(v13, 0xA5F5F28DuLL);
        if (v20)
        {
          v21 = v20;
          v42 = a1;
          memcpy(v20, *(const void **)(v15 + 8), *(_QWORD *)v15);
          v43 = v21;
          v22 = &v21[*(_QWORD *)v15];
          v41 = a4;
          v23 = a4 + 8;
          v24 = v44;
          do
          {
            if (*(_DWORD *)(v23 - 8) == 2)
            {
              memcpy(v22, *(const void **)(v23 + 8), *(_QWORD *)v23);
              v22 += *(_QWORD *)v23;
            }
            v23 += 24;
            --v24;
          }
          while (v24);
          v46 = 0;
          v47 = 0;
          v48 = 0;
          v45 = 0;
          pthread_mutex_lock((pthread_mutex_t *)(a2 + 40));
          v25 = sub_209685110(v42, a2, ((_DWORD)a3 << 8) | 0xAAu, (uint64_t *)&v45);
          if ((_DWORD)v25)
          {
            v8 = v25;
LABEL_31:
            v26 = v43;
LABEL_32:
            free(v26);
            return v8;
          }
          v40 = v45;
          v8 = sub_209685208(v42, v45);
          pthread_mutex_unlock((pthread_mutex_t *)(a2 + 40));
          if ((_DWORD)v8)
            goto LABEL_31;
          v27 = (*(uint64_t (**)(_krb5_context *, unsigned int **, char *, size_t, _QWORD, uint64_t, uint64_t))(v7 + 72))(v42, v40, v43, v13, 0, a3, a6);
          if ((_DWORD)v27)
          {
            v8 = v27;
            v26 = v43;
            goto LABEL_32;
          }
          v28 = (_DWORD)a3 << 8;
          memcpy(*(void **)(v15 + 8), v43, *(_QWORD *)v15);
          v29 = &v43[*(_QWORD *)v15];
          v30 = v41 + 8;
          v31 = v44;
          do
          {
            if (*(_DWORD *)(v30 - 8) == 2)
            {
              memcpy(*(void **)(v30 + 8), v29, *(_QWORD *)v30);
              v29 += *(_QWORD *)v30;
            }
            v30 += 24;
            --v31;
          }
          while (v31);
          free(v43);
          v32 = (_QWORD *)(v41 + 8);
          v33 = v44;
          v34 = v44;
          do
          {
            if (*((_DWORD *)v32 - 2) == 3)
              v13 += *v32;
            v32 += 3;
            --v34;
          }
          while (v34);
          v35 = malloc_type_malloc(v13, 0xFA80AC2FuLL);
          if (v35)
          {
            v36 = (uint64_t)v35;
            memcpy(v35, *(const void **)(v15 + 8), *(_QWORD *)v15);
            v37 = (char *)(v36 + *(_QWORD *)v15);
            v38 = v41 + 8;
            do
            {
              if ((*(_DWORD *)(v38 - 8) & 0xFFFFFFFE) == 2)
              {
                memcpy(v37, *(const void **)(v38 + 8), *(_QWORD *)v38);
                v37 += *(_QWORD *)v38;
              }
              v38 += 24;
              --v33;
            }
            while (v33);
            v48 = *(_QWORD *)(v17 + 16);
            v47 = *(_QWORD *)(v17 + 8);
            LODWORD(v46) = **(_DWORD **)(v7 + 56);
            v8 = sub_20968448C(v42, a2, v28 | 0x55u, v36, v13, (unsigned int *)&v46);
            v26 = (void *)v36;
            goto LABEL_32;
          }
        }
        return 12;
      }
    }
  }
  return v8;
}

uint64_t krb5_create_checksum_iov(krb5_context a1, _DWORD **a2, unsigned int a3, uint64_t a4, unsigned int a5, _DWORD *a6)
{
  uint64_t checksum;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  size_t v15;
  _QWORD *v16;
  uint64_t v17;
  char *v18;
  uint64_t v19;
  char *v20;
  size_t v21;
  uint64_t v23;
  size_t __n;
  void *__src;

  checksum = 2529639102;
  if (((*a2)[16] & 4) != 0)
  {
    if (a5)
    {
      v12 = a5;
      v13 = a4 + 8;
      v14 = a5;
      while (*(_DWORD *)(v13 - 8) != 6)
      {
        v13 += 24;
        if (!--v14)
          return checksum;
      }
      v15 = 0;
      v16 = (_QWORD *)(a4 + 8);
      v17 = a5;
      do
      {
        if ((*(_DWORD *)(v16 - 1) & 0xFFFFFFFE) == 2)
          v15 += *v16;
        v16 += 3;
        --v17;
      }
      while (v17);
      v18 = (char *)malloc_type_malloc(v15, 0x1FAC21A4uLL);
      v19 = a4 + 8;
      v20 = v18;
      do
      {
        if ((*(_DWORD *)(v19 - 8) & 0xFFFFFFFE) == 2)
        {
          memcpy(v20, *(const void **)(v19 + 8), *(_QWORD *)v19);
          v20 += *(_QWORD *)v19;
        }
        v19 += 24;
        --v12;
      }
      while (v12);
      v23 = 0;
      __n = 0;
      __src = 0;
      checksum = krb5_create_checksum(a1, a2, a3, 0, (uint64_t)v18, v15, (uint64_t)&v23);
      free(v18);
      if (!(_DWORD)checksum)
      {
        if (a6)
          *a6 = v23;
        v21 = __n;
        if (__n <= *(_QWORD *)v13)
        {
          *(_QWORD *)v13 = __n;
          memcpy(*(void **)(v13 + 8), __src, v21);
          sub_2096BB8BC();
          return 0;
        }
        else
        {
          krb5_set_error_message(a1, -1765328194, "Checksum larger then input buffer");
          sub_2096BB8BC();
          return 2529639102;
        }
      }
    }
  }
  else
  {
    krb5_clear_error_message(a1);
    return 2529639090;
  }
  return checksum;
}

uint64_t krb5_verify_checksum_iov(krb5_context a1, uint64_t *a2, const krb5_checksum *a3, uint64_t a4, unsigned int a5, _DWORD *a6)
{
  uint64_t v7;
  uint64_t v8;
  krb5_cksumtype v11;
  uint64_t v12;
  _QWORD *v13;
  uint64_t v14;
  size_t v15;
  _QWORD *v16;
  uint64_t v17;
  size_t v18;
  char *v19;
  uint64_t v20;
  char *v21;
  uint64_t v22;
  _QWORD seed[3];

  v7 = 2529639102;
  v8 = *a2;
  if ((*(_BYTE *)(*a2 + 64) & 4) != 0)
  {
    if (a5)
    {
      v11 = (int)a2;
      v12 = a5;
      v13 = (_QWORD *)(a4 + 16);
      v14 = a5;
      while (*((_DWORD *)v13 - 4) != 6)
      {
        v13 += 3;
        if (!--v14)
          return v7;
      }
      v15 = 0;
      v16 = (_QWORD *)(a4 + 8);
      v17 = a5;
      do
      {
        if ((*(_DWORD *)(v16 - 1) & 0xFFFFFFFE) == 2)
          v15 += *v16;
        v16 += 3;
        --v17;
      }
      while (v17);
      v19 = (char *)malloc_type_malloc(v15, 0x739C9819uLL);
      v20 = a4 + 8;
      v21 = v19;
      do
      {
        if ((*(_DWORD *)(v20 - 8) & 0xFFFFFFFE) == 2)
        {
          memcpy(v21, *(const void **)(v20 + 8), *(_QWORD *)v20);
          v21 += *(_QWORD *)v20;
        }
        v20 += 24;
        --v12;
      }
      while (v12);
      seed[0] = 0;
      LODWORD(seed[0]) = **(_DWORD **)(v8 + 56);
      v22 = *v13;
      seed[1] = *(v13 - 1);
      seed[2] = v22;
      v7 = krb5_verify_checksum(a1, v11, a3, v19, v15, seed, v18);
      free(v19);
      if (a6 && !(_DWORD)v7)
        *a6 = seed[0];
    }
  }
  else
  {
    krb5_clear_error_message(a1);
    return 2529639090;
  }
  return v7;
}

uint64_t krb5_crypto_length(_krb5_context *a1, uint64_t a2, uint64_t a3, unint64_t *a4)
{
  _QWORD *v4;
  const char *v5;
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v10;

  v4 = *(_QWORD **)a2;
  if ((*(_BYTE *)(*(_QWORD *)a2 + 64) & 4) != 0)
  {
    v6 = 0;
    switch((int)a3)
    {
      case 0:
        v6 = 0;
        *a4 = 0;
        return v6;
      case 1:
        v6 = 0;
        v7 = v4[2];
        goto LABEL_15;
      case 2:
      case 3:
        return v6;
      case 4:
        v6 = 0;
        v7 = v4[3];
        if (v7 <= 1)
          v7 = 0;
        goto LABEL_15;
      case 5:
        v6 = 0;
        v7 = *(_QWORD *)(v4[7] + 24);
        goto LABEL_15;
      case 6:
        v8 = v4[7];
        if (!v8)
          v8 = v4[6];
        v6 = 0;
        v7 = *(_QWORD *)(v8 + 24);
LABEL_15:
        *a4 = v7;
        break;
      default:
        v10 = a3;
        v5 = "%d not a supported type";
        goto LABEL_3;
    }
  }
  else
  {
    v5 = "not a derived crypto";
LABEL_3:
    v6 = 22;
    krb5_set_error_message(a1, 22, v5, v10);
  }
  return v6;
}

uint64_t krb5_crypto_length_iov(_krb5_context *a1, uint64_t a2, uint64_t a3, unsigned int a4)
{
  uint64_t v6;
  unint64_t *i;
  uint64_t result;

  if (!a4)
    return 0;
  v6 = a4;
  for (i = (unint64_t *)(a3 + 8); ; i += 3)
  {
    result = krb5_crypto_length(a1, a2, *((unsigned int *)i - 2), i);
    if ((_DWORD)result)
      break;
    if (!--v6)
      return 0;
  }
  return result;
}

uint64_t krb5_encrypt_ivec(_krb5_context *a1, uint64_t a2, uint64_t a3, const void *a4, size_t a5, size_t *a6, uint64_t a7)
{
  uint64_t v13;
  int v14;
  size_t v15;
  uint64_t v16;
  void *v17;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  size_t v21;
  uint64_t v22;
  size_t v23;
  char *v24;
  char *v25;
  pthread_mutex_t *v26;
  unsigned int **v27;
  size_t v28;
  size_t v29;
  void *v30;
  uint64_t v31;
  void *v32;
  size_t v33;
  void *v34;
  size_t *v36;
  unsigned int **v38;
  uint64_t v39;
  uint64_t v40;
  void *__src;

  v13 = *(_QWORD *)a2;
  v14 = *(_DWORD *)(*(_QWORD *)a2 + 64);
  if ((v14 & 4) != 0)
  {
    v36 = a6;
    v21 = *(_QWORD *)(*(_QWORD *)(v13 + 56) + 24);
    v22 = (a5 + *(_QWORD *)(v13 + 32) + *(_QWORD *)(v13 + 24) - 1) & -*(_QWORD *)(v13 + 24);
    v23 = v22 + v21;
    v24 = (char *)malloc_type_calloc(1uLL, v22 + v21, 0xEC1B67F3uLL);
    if (v24)
    {
      v25 = v24;
      v39 = 0;
      v40 = 0;
      __src = 0;
      krb5_generate_random_block((uint64_t)v24, *(_QWORD *)(v13 + 32));
      memcpy(&v25[*(_QWORD *)(v13 + 32)], a4, a5);
      v20 = sub_20968426C(a1, *(_QWORD *)(v13 + 56), a2, ((_DWORD)a3 << 8) | 0x55u, (uint64_t)v25, v22, (uint64_t)&v39);
      if (!(_DWORD)v20)
      {
        if (v40 == v21)
        {
          v38 = 0;
          memcpy(&v25[v22], __src, v21);
          sub_2096BB8BC();
          v26 = (pthread_mutex_t *)(a2 + 40);
          pthread_mutex_lock((pthread_mutex_t *)(a2 + 40));
          v20 = sub_209685110(a1, a2, ((_DWORD)a3 << 8) | 0xAAu, (uint64_t *)&v38);
          if (!(_DWORD)v20)
          {
            v27 = v38;
            v20 = sub_209685208(a1, v38);
            pthread_mutex_unlock(v26);
            if (!(_DWORD)v20)
            {
              v20 = (*(uint64_t (**)(_krb5_context *, unsigned int **, char *, uint64_t, uint64_t, uint64_t, uint64_t))(v13 + 72))(a1, v27, v25, v22, 1, a3, a7);
              if (!(_DWORD)v20)
              {
                *v36 = v23;
                v36[1] = (size_t)v25;
                return v20;
              }
            }
          }
        }
        else
        {
          v20 = 2529639090;
          sub_2096BB8BC();
          krb5_clear_error_message(a1);
        }
      }
      bzero(v25, v23);
      v34 = v25;
LABEL_26:
      free(v34);
      return v20;
    }
    goto LABEL_19;
  }
  if ((v14 & 0x20) != 0)
  {
    v28 = *(_QWORD *)(*(_QWORD *)(v13 + 48) + 24);
    v29 = v28 + a5 + *(_QWORD *)(v13 + 32);
    v30 = malloc_type_malloc(v29, 0x9E11B8AuLL);
    if (v30)
    {
      v18 = (uint64_t)v30;
      bzero(v30, v28);
      v31 = v18 + v28;
      krb5_generate_random_block(v31, *(_QWORD *)(v13 + 32));
      memcpy((void *)(v31 + *(_QWORD *)(v13 + 32)), a4, a5);
      v20 = (*(uint64_t (**)(_krb5_context *, uint64_t, uint64_t, size_t, uint64_t, uint64_t, uint64_t))(v13 + 72))(a1, a2 + 8, v18, v29, 1, a3, a7);
      if (!(_DWORD)v20)
      {
        *a6 = v29;
        a6[1] = v18;
        return v20;
      }
      v32 = (void *)v18;
      v33 = v29;
      goto LABEL_25;
    }
LABEL_19:
    v20 = 12;
    krb5_set_error_message(a1, 12, "malloc: out of memory", v36);
    return v20;
  }
  v15 = *(_QWORD *)(*(_QWORD *)(v13 + 48) + 24);
  v16 = (a5 + *(_QWORD *)(v13 + 32) + *(_QWORD *)(v13 + 24) + v15 - 1) & -*(_QWORD *)(v13 + 24);
  v17 = malloc_type_calloc(1uLL, v16, 0x8E8ECFB8uLL);
  if (!v17)
    goto LABEL_19;
  v18 = (uint64_t)v17;
  v39 = 0;
  v40 = 0;
  __src = 0;
  krb5_generate_random_block((uint64_t)v17, *(_QWORD *)(v13 + 32));
  v19 = (char *)(v18 + *(_QWORD *)(v13 + 32));
  bzero(v19, v15);
  memcpy(&v19[v15], a4, a5);
  v20 = sub_20968426C(a1, *(_QWORD *)(v13 + 48), a2, 0, v18, v16, (uint64_t)&v39);
  if ((_DWORD)v20)
  {
LABEL_24:
    v32 = (void *)v18;
    v33 = v16;
LABEL_25:
    bzero(v32, v33);
    v34 = (void *)v18;
    goto LABEL_26;
  }
  if (v40 != v15)
  {
    v20 = 2529639090;
    krb5_clear_error_message(a1);
    sub_2096BB8BC();
    goto LABEL_24;
  }
  memcpy((void *)(v18 + *(_QWORD *)(v13 + 32)), __src, v15);
  sub_2096BB8BC();
  pthread_mutex_lock((pthread_mutex_t *)(a2 + 40));
  v20 = sub_209685208(a1, (unsigned int **)(a2 + 8));
  pthread_mutex_unlock((pthread_mutex_t *)(a2 + 40));
  if ((_DWORD)v20)
    goto LABEL_24;
  v20 = (*(uint64_t (**)(_krb5_context *, uint64_t, uint64_t, uint64_t, uint64_t, _QWORD, uint64_t))(v13 + 72))(a1, a2 + 8, v18, v16, 1, 0, a7);
  if ((_DWORD)v20)
    goto LABEL_24;
  *a6 = v16;
  a6[1] = v18;
  return v20;
}

krb5_error_code krb5_encrypt(krb5_context context, krb5_const_pointer inptr, krb5_pointer outptr, size_t size, krb5_encrypt_block *eblock, krb5_pointer ivec)
{
  return krb5_encrypt_ivec(context, (uint64_t)inptr, (uint64_t)outptr, (const void *)size, (size_t)eblock, (size_t *)ivec, 0);
}

uint64_t krb5_encrypt_EncryptedData(_krb5_context *a1, _DWORD **a2, uint64_t a3, const void *a4, size_t a5, int a6, uint64_t a7)
{
  _DWORD *v14;

  *(_DWORD *)a7 = **a2;
  if (a6)
  {
    v14 = malloc_type_calloc(1uLL, 4uLL, 0x100004052888210uLL);
    *v14 = a6;
  }
  else
  {
    v14 = 0;
  }
  *(_QWORD *)(a7 + 8) = v14;
  return krb5_encrypt_ivec(a1, (uint64_t)a2, a3, a4, a5, (size_t *)(a7 + 16), 0);
}

uint64_t krb5_decrypt_ivec(krb5_context a1, uint64_t a2, uint64_t a3, const void *a4, size_t size, _QWORD *a6, uint64_t a7)
{
  uint64_t v14;
  int v15;
  size_t v16;
  char *v17;
  char *v18;
  pthread_mutex_t *v19;
  unsigned int **v20;
  uint64_t v21;
  uint64_t v22;
  char *v23;
  uint64_t v24;
  uint64_t v25;
  char *v26;
  char *v27;
  uint64_t v28;
  uint64_t v29;
  char *v30;
  uint64_t v32;
  void *v33;
  BOOL v34;
  uint64_t v35;
  char *v36;
  size_t v37;
  void *v38;
  size_t v39;
  uint64_t v40;
  void *v41;
  unsigned int **v42;
  void *v43;
  char *v44;
  unsigned int **v45;
  uint64_t v46;
  uint64_t v47;
  char *v48;

  v14 = *(_QWORD *)a2;
  v15 = *(_DWORD *)(*(_QWORD *)a2 + 64);
  if ((v15 & 4) != 0)
  {
    v24 = *(_QWORD *)(*(_QWORD *)(v14 + 56) + 24);
    if (*(_QWORD *)(v14 + 32) + v24 <= size)
    {
      v29 = size - v24;
      if (!((size - v24) % *(_QWORD *)(v14 + 24)))
      {
        v30 = (char *)malloc_type_malloc(size, 0x792167C6uLL);
        if (size && !v30)
          goto LABEL_23;
        v45 = 0;
        v46 = 0;
        v44 = v30;
        memcpy(v30, a4, size);
        pthread_mutex_lock((pthread_mutex_t *)(a2 + 40));
        v32 = sub_209685110(a1, a2, ((_DWORD)a3 << 8) | 0xAAu, (uint64_t *)&v45);
        if ((_DWORD)v32)
        {
          v21 = v32;
        }
        else
        {
          v42 = v45;
          v21 = sub_209685208(a1, v45);
          pthread_mutex_unlock((pthread_mutex_t *)(a2 + 40));
          if (!(_DWORD)v21)
          {
            v35 = (*(uint64_t (**)(krb5_context, unsigned int **, char *, uint64_t, _QWORD, uint64_t, uint64_t))(v14 + 72))(a1, v42, v44, v29, 0, a3, a7);
            if ((_DWORD)v35
              || (v47 = v24,
                  v48 = &v44[v29],
                  LODWORD(v46) = **(_DWORD **)(v14 + 56),
                  v35 = sub_20968448C(a1, a2, ((_DWORD)a3 << 8) | 0x55u, (uint64_t)v44, v29, (unsigned int *)&v46),
                  (_DWORD)v35))
            {
              v21 = v35;
              v23 = v44;
              goto LABEL_29;
            }
            v40 = *(_QWORD *)(v14 + 32);
            memmove(v44, &v44[v40], v29 - v40);
            v41 = malloc_type_realloc(v44, v29 - v40, 0x77FF862EuLL);
            a6[1] = v41;
            v39 = v29 - v40;
            if (v29 != v40 && !v41)
            {
              v36 = v44;
              goto LABEL_39;
            }
            goto LABEL_47;
          }
        }
        v23 = v44;
        goto LABEL_29;
      }
      goto LABEL_20;
    }
  }
  else
  {
    if ((v15 & 0x20) == 0)
    {
      if (!(size % *(_QWORD *)(v14 + 24)))
      {
        v16 = *(_QWORD *)(*(_QWORD *)(v14 + 48) + 24);
        if (*(_QWORD *)(v14 + 32) + v16 <= size)
        {
          v17 = (char *)malloc_type_malloc(size, 0xB0499F1AuLL);
          v18 = v17;
          if (size && !v17)
            goto LABEL_23;
          memcpy(v17, a4, size);
          v19 = (pthread_mutex_t *)(a2 + 40);
          pthread_mutex_lock((pthread_mutex_t *)(a2 + 40));
          v20 = (unsigned int **)(a2 + 8);
          v21 = sub_209685208(a1, v20);
          pthread_mutex_unlock(v19);
          if ((_DWORD)v21)
          {
LABEL_11:
            v23 = v18;
LABEL_29:
            free(v23);
            return v21;
          }
          v22 = (*(uint64_t (**)(krb5_context, unsigned int **, char *, size_t, _QWORD, _QWORD, uint64_t))(v14 + 72))(a1, v20, v18, size, 0, 0, a7);
          if ((_DWORD)v22
            || (v46 = 0,
                v47 = 0,
                v48 = 0,
                v22 = krb5_data_copy(&v47, &v18[*(_QWORD *)(v14 + 32)], v16),
                (_DWORD)v22))
          {
            v21 = v22;
            goto LABEL_11;
          }
          bzero(&v18[*(_QWORD *)(v14 + 32)], v16);
          LODWORD(v46) = **(_DWORD **)(v14 + 48);
          v21 = sub_20968448C(a1, 0, 0, (uint64_t)v18, size, (unsigned int *)&v46);
          sub_2096BB8BC();
          if ((_DWORD)v21)
            goto LABEL_11;
          v37 = *(_QWORD *)(v14 + 32) + v16;
          memmove(v18, &v18[v37], size - v37);
          v38 = malloc_type_realloc(v18, size - v37, 0xD0054DAAuLL);
          a6[1] = v38;
          v39 = size - v37;
          if (size != v37 && !v38)
          {
            v36 = v18;
            goto LABEL_39;
          }
LABEL_47:
          v21 = 0;
          *a6 = v39;
          return v21;
        }
        goto LABEL_13;
      }
LABEL_20:
      v21 = 2529639102;
      krb5_clear_error_message(a1);
      return v21;
    }
    if (size % *(_QWORD *)(v14 + 24))
      goto LABEL_20;
    v25 = *(_QWORD *)(*(_QWORD *)(v14 + 48) + 24);
    if (size >= *(_QWORD *)(v14 + 32) + v25)
    {
      v43 = (void *)(*(_QWORD *)(v14 + 32) + v25);
      v26 = (char *)malloc_type_malloc(size, 0x11B917B3uLL);
      if (!v26)
      {
LABEL_23:
        v21 = 12;
        krb5_set_error_message(a1, 12, "malloc: out of memory", v42);
        return v21;
      }
      v27 = v26;
      memcpy(v26, a4, size);
      v28 = (*(uint64_t (**)(krb5_context, uint64_t, char *, size_t, _QWORD, uint64_t, uint64_t))(v14 + 72))(a1, a2 + 8, v27, size, 0, a3, a7);
      if ((_DWORD)v28)
      {
        v21 = v28;
        v23 = v27;
        goto LABEL_29;
      }
      memmove(v27, &v27[v25 + *(_QWORD *)(v14 + 32)], size - (_QWORD)v43);
      v33 = malloc_type_realloc(v27, size - (_QWORD)v43, 0x901FBB81uLL);
      a6[1] = v33;
      if (v33)
        v34 = 1;
      else
        v34 = size == (_QWORD)v43;
      if (v34)
      {
        v21 = 0;
        *a6 = size - (_QWORD)v43;
        return v21;
      }
      v36 = v27;
LABEL_39:
      free(v36);
      goto LABEL_23;
    }
  }
LABEL_13:
  v21 = 2529639102;
  krb5_set_error_message(a1, -1765328194, "Encrypted data shorter then checksum + confunder");
  return v21;
}

krb5_error_code krb5_decrypt(krb5_context context, krb5_const_pointer inptr, krb5_pointer outptr, size_t size, krb5_encrypt_block *eblock, krb5_pointer ivec)
{
  return krb5_decrypt_ivec(context, (uint64_t)inptr, (uint64_t)outptr, (const void *)size, (size_t)eblock, ivec, 0);
}

uint64_t krb5_decrypt_EncryptedData(_krb5_context *a1, uint64_t a2, uint64_t a3, uint64_t a4, _QWORD *a5)
{
  return krb5_decrypt_ivec(a1, a2, a3, *(const void **)(a4 + 24), *(_QWORD *)(a4 + 16), a5, 0);
}

uint64_t sub_209686428(_krb5_context *a1, uint64_t a2, uint64_t a3, const void *a4, size_t a5)
{
  int *v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  unint64_t v14;
  char *v15;
  uint64_t v16;
  uint64_t v18;
  uint64_t v19;
  int v20;
  unint64_t v21;

  v10 = *(int **)(a2 + 40);
  v11 = sub_209685208(a1, (unsigned int **)a3);
  if ((_DWORD)v11)
    return v11;
  v12 = *(_QWORD *)(a2 + 16);
  v13 = 8 * v12;
  v14 = *((_QWORD *)v10 + 2) + 8 * v12 - 1;
  v21 = v14 / (8 * v12);
  v15 = (char *)malloc_type_malloc(v21 * v12, 0x7741FAA4uLL);
  if (v15)
  {
    v16 = sub_20969FB10(a4, a5, v15, *(_QWORD *)(a2 + 16));
    if ((_DWORD)v16)
    {
      v11 = v16;
      krb5_set_error_message(a1, v16, "malloc: out of memory");
    }
    else
    {
      if (v13 <= v14)
      {
        v18 = 0;
        if (v21 <= 1)
          v19 = 1;
        else
          v19 = v21;
        do
        {
          if (v18)
            memcpy(&v15[*(_QWORD *)(a2 + 16) * v18], &v15[*(_QWORD *)(a2 + 16) * (v18 - 1)], *(_QWORD *)(a2 + 16));
          (*(void (**)(_krb5_context *, uint64_t, char *, _QWORD, uint64_t, _QWORD, _QWORD))(a2 + 72))(a1, a3, &v15[*(_QWORD *)(a2 + 16) * v18++], *(_QWORD *)(a2 + 16), 1, 0, 0);
        }
        while (v19 != v18);
      }
      v20 = *v10;
      if ((*v10 - 17) < 2)
      {
        memcpy(*(void **)(*(_QWORD *)a3 + 16), v15, *(_QWORD *)(*(_QWORD *)a3 + 8));
      }
      else
      {
        if (v20 != 16 && v20 != 7)
        {
          v11 = 2529639090;
          krb5_set_error_message(a1, -1765328206, "derive_key() called with unknown keytype (%u)");
          goto LABEL_6;
        }
        sub_2096B5514((uint64_t)a1, *(_QWORD *)a3, (uint64_t)v15, *(_QWORD *)(a2 + 16) * v21);
      }
      v11 = 0;
    }
  }
  else
  {
    v11 = 12;
    krb5_set_error_message(a1, 12, "malloc: out of memory");
  }
LABEL_6:
  if (*(_QWORD *)(a3 + 8))
  {
    sub_209686628(a1, a3, a2);
    *(_QWORD *)(a3 + 8) = 0;
  }
  if (v15)
  {
    bzero(v15, *(_QWORD *)(a2 + 16) * v21);
    free(v15);
  }
  return v11;
}

void sub_209686628(_krb5_context *a1, uint64_t a2, uint64_t a3)
{
  void (*v5)(_krb5_context *, uint64_t);

  v5 = *(void (**)(_krb5_context *, uint64_t))(*(_QWORD *)(a3 + 40) + 72);
  if (v5)
    v5(a1, a2);
  bzero(*(void **)(*(_QWORD *)(a2 + 8) + 8), **(_QWORD **)(a2 + 8));
  krb5_free_data(a1, *(krb5_data **)(a2 + 8));
}

uint64_t krb5_derive_key(krb5_context a1, const krb5_keyblock *a2, krb5_keyblock *a3, const void *a4, size_t a5, krb5_keyblock **a6)
{
  uint64_t v7;
  _DWORD **i;
  _DWORD *v12;
  uint64_t v14;
  krb5_keyblock *v15;
  uint64_t v16;

  *a6 = 0;
  v7 = dword_2545A4EE8;
  if (dword_2545A4EE8 < 1)
    return sub_209683BD0(a1, (char *)a3);
  v15 = 0;
  v16 = 0;
  for (i = (_DWORD **)&off_2545A4EB8; ; ++i)
  {
    v12 = *i;
    if (**i == (_DWORD)a3)
      break;
    if (!--v7)
      return sub_209683BD0(a1, (char *)a3);
  }
  v14 = krb5_copy_keyblock(a1, a2, &v15);
  if (!(_DWORD)v14)
  {
    v16 = 0;
    v14 = sub_209686428(a1, (uint64_t)v12, (uint64_t)&v15, a4, a5);
    if (!(_DWORD)v14)
      v14 = krb5_copy_keyblock(a1, v15, a6);
    sub_209686774(a1, (uint64_t)&v15, (uint64_t)v12);
  }
  return v14;
}

void sub_209686774(_krb5_context *a1, uint64_t a2, uint64_t a3)
{
  krb5_free_keyblock(a1, *(krb5_keyblock **)a2);
  if (*(_QWORD *)(a2 + 8))
  {
    sub_209686628(a1, a2, a3);
    *(_QWORD *)(a2 + 8) = 0;
  }
}

uint64_t krb5_crypto_init(_krb5_context *a1, const krb5_keyblock *a2, char *magic, krb5_keyblock ***a4)
{
  krb5_keyblock **v8;
  uint64_t v9;
  krb5_keyblock **v10;
  krb5_keyblock *v11;
  krb5_keyblock **v12;
  krb5_keyblock *v13;
  uint64_t v14;
  krb5_keyblock **v15;
  krb5_keyblock **v17;

  v8 = (krb5_keyblock **)malloc_type_calloc(1uLL, 0x68uLL, 0x10A0040CBDFC28DuLL);
  *a4 = v8;
  if (v8)
  {
    if (!(_DWORD)magic)
      magic = (char *)a2->magic;
    v9 = dword_2545A4EE8;
    if (dword_2545A4EE8 < 1)
    {
LABEL_8:
      v11 = 0;
    }
    else
    {
      v10 = (krb5_keyblock **)&off_2545A4EB8;
      while (1)
      {
        v11 = *v10;
        if ((*v10)->magic == (_DWORD)magic)
          break;
        ++v10;
        if (!--v9)
          goto LABEL_8;
      }
    }
    *v8 = v11;
    v12 = *a4;
    v13 = **a4;
    if (!v13 || ((uint64_t)v13[2].contents & 0x40) != 0)
    {
      free(v12);
      *a4 = 0;
      return sub_209683BD0(a1, magic);
    }
    if (*((_QWORD *)v13[1].contents + 3) == *(_QWORD *)&a2->length)
    {
      v14 = krb5_copy_keyblock(a1, a2, v12 + 1);
      v15 = *a4;
      if ((_DWORD)v14)
      {
        free(v15);
        *a4 = 0;
      }
      else
      {
        v15[2] = 0;
        v17 = *a4;
        *((_DWORD *)v17 + 6) = 0;
        v17[4] = 0;
        pthread_mutex_init((pthread_mutex_t *)(*a4 + 5), 0);
      }
    }
    else
    {
      v14 = 2529639101;
      free(v12);
      *a4 = 0;
      krb5_set_error_message(a1, -1765328195, "encryption key has bad length");
    }
  }
  else
  {
    v14 = 12;
    krb5_set_error_message(a1, 12, "malloc: out of memory");
  }
  return v14;
}

uint64_t krb5_crypto_destroy(_krb5_context *a1, uint64_t a2)
{
  uint64_t v4;
  void *v5;

  if (a2)
  {
    pthread_mutex_destroy((pthread_mutex_t *)(a2 + 40));
    if (*(int *)(a2 + 24) >= 1)
    {
      v4 = 0;
      do
      {
        v5 = *(void **)(*(_QWORD *)(a2 + 32) + 8 * v4);
        sub_209686774(a1, (uint64_t)v5 + 8, *(_QWORD *)a2);
        free(v5);
        ++v4;
      }
      while (v4 < *(int *)(a2 + 24));
    }
    free(*(void **)(a2 + 32));
    sub_209686774(a1, a2 + 8, *(_QWORD *)a2);
    free((void *)a2);
  }
  return 0;
}

uint64_t krb5_crypto_getblocksize(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  *a3 = *(_QWORD *)(*(_QWORD *)a2 + 16);
  return 0;
}

uint64_t krb5_crypto_getenctype(uint64_t a1, _DWORD **a2, _DWORD *a3)
{
  *a3 = **a2;
  return 0;
}

uint64_t krb5_crypto_getpadsize(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  *a3 = *(_QWORD *)(*(_QWORD *)a2 + 24);
  return 0;
}

uint64_t krb5_crypto_getconfoundersize(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  *a3 = *(_QWORD *)(*(_QWORD *)a2 + 32);
  return 0;
}

uint64_t krb5_enctype_disable(_krb5_context *a1, int a2)
{
  uint64_t v2;
  _UNKNOWN **v3;
  uint64_t v4;

  v2 = dword_2545A4EE8;
  if (dword_2545A4EE8 < 1)
  {
LABEL_5:
    v4 = 2529639062;
    if (a1)
      krb5_set_error_message(a1, -1765328234, "encryption type %d not supported", a2);
  }
  else
  {
    v3 = &off_2545A4EB8;
    while (*(_DWORD *)*v3 != a2)
    {
      ++v3;
      if (!--v2)
        goto LABEL_5;
    }
    v4 = 0;
    *((_DWORD *)*v3 + 16) |= 0x40u;
  }
  return v4;
}

uint64_t krb5_enctype_enable(_krb5_context *a1, int a2)
{
  uint64_t v2;
  _UNKNOWN **v3;
  uint64_t v4;

  v2 = dword_2545A4EE8;
  if (dword_2545A4EE8 < 1)
  {
LABEL_5:
    v4 = 2529639062;
    if (a1)
      krb5_set_error_message(a1, -1765328234, "encryption type %d not supported", a2);
  }
  else
  {
    v3 = &off_2545A4EB8;
    while (*(_DWORD *)*v3 != a2)
    {
      ++v3;
      if (!--v2)
        goto LABEL_5;
    }
    v4 = 0;
    *((_DWORD *)*v3 + 16) &= ~0x40u;
  }
  return v4;
}

uint64_t sub_209686B48(uint64_t a1, int a2)
{
  uint64_t v2;
  _UNKNOWN **v3;
  int v4;

  v2 = dword_2545A4EE8;
  if (dword_2545A4EE8 >= 1)
  {
    v3 = &off_2545A4EB8;
    do
    {
      v4 = *((_DWORD *)*v3 + 16);
      if ((v4 & 0x80) != 0)
        *((_DWORD *)*v3 + 16) = v4 & 0xFFFFFFBF | ((a2 == 0) << 6);
      ++v3;
      --v2;
    }
    while (v2);
  }
  return 0;
}

uint64_t krb5_enctype_warning(uint64_t a1, int a2)
{
  uint64_t v2;
  _UNKNOWN **i;

  v2 = dword_2545A4EE8;
  if (dword_2545A4EE8 < 1)
    return 1;
  for (i = &off_2545A4EB8; *(_DWORD *)*i != a2; ++i)
  {
    if (!--v2)
      return 1;
  }
  return (*((_DWORD *)*i + 16) >> 8) & 1;
}

unint64_t krb5_get_wrapped_length(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD *v3;
  unint64_t v4;
  uint64_t v6;

  v3 = *(_QWORD **)a2;
  v4 = *(_QWORD *)(*(_QWORD *)a2 + 24);
  if ((*(_BYTE *)(*(_QWORD *)a2 + 64) & 4) == 0)
    return (v4 + a3 + v3[4] + *(_QWORD *)(v3[6] + 24) - 1) / v4 * v4;
  v6 = v3[7];
  if (!v6)
    v6 = v3[6];
  return *(_QWORD *)(v6 + 24) + (v4 + a3 + v3[4] - 1) / v4 * v4;
}

uint64_t krb5_random_to_key(krb5_context a1, int a2, const void *a3, unint64_t a4, uint64_t a5)
{
  uint64_t v7;
  _QWORD *v11;
  _DWORD *v12;
  uint64_t v13;
  uint64_t v15;
  uint64_t v16;
  void (*v17)(krb5_context, uint64_t, const void *, unint64_t);

  v7 = dword_2545A4EE8;
  if (dword_2545A4EE8 < 1)
  {
LABEL_5:
    v13 = 2529639062;
    krb5_set_error_message(a1, -1765328234, "encryption type %d not supported");
  }
  else
  {
    v11 = &off_2545A4EB8;
    while (1)
    {
      v12 = (_DWORD *)*v11;
      if (*(_DWORD *)*v11 == a2)
        break;
      ++v11;
      if (!--v7)
        goto LABEL_5;
    }
    v15 = *((_QWORD *)v12 + 5);
    if (a4 >= (unint64_t)(*(_QWORD *)(v15 + 16) + 7) >> 3)
    {
      v13 = krb5_data_alloc((size_t *)(a5 + 8), *(_QWORD *)(v15 + 24));
      if (!(_DWORD)v13)
      {
        *(_DWORD *)a5 = a2;
        v16 = *((_QWORD *)v12 + 5);
        v17 = *(void (**)(krb5_context, uint64_t, const void *, unint64_t))(v16 + 64);
        if (v17)
          v17(a1, a5, a3, a4);
        else
          memcpy(*(void **)(a5 + 16), a3, *(_QWORD *)(v16 + 24));
        return 0;
      }
    }
    else
    {
      v13 = 2529639062;
      krb5_set_error_message(a1, -1765328234, "encryption key %s needs %d bytes of random to make an encryption key out of it");
    }
  }
  return v13;
}

uint64_t krb5_crypto_prf_length(_krb5_context *a1, int a2, _QWORD *a3)
{
  uint64_t v3;
  _UNKNOWN **v4;
  uint64_t v5;
  uint64_t v6;

  v3 = dword_2545A4EE8;
  if (dword_2545A4EE8 < 1)
  {
LABEL_5:
    v5 = 2529639062;
    krb5_set_error_message(a1, -1765328234, "encryption type %d not supported");
  }
  else
  {
    v4 = &off_2545A4EB8;
    while (*(_DWORD *)*v4 != a2)
    {
      ++v4;
      if (!--v3)
        goto LABEL_5;
    }
    v6 = *((_QWORD *)*v4 + 10);
    if (v6)
    {
      v5 = 0;
      *a3 = v6;
    }
    else
    {
      v5 = 2314790690;
      krb5_set_error_message(a1, -1980176606, "encryption type %d not supported");
    }
  }
  return v5;
}

uint64_t krb5_crypto_prf(_krb5_context *a1, uint64_t *a2, uint64_t a3, _QWORD *a4)
{
  uint64_t v8;
  uint64_t (*v9)(_krb5_context *, uint64_t *, uint64_t, _QWORD *);

  v8 = *a2;
  krb5_data_zero(a4);
  v9 = *(uint64_t (**)(_krb5_context *, uint64_t *, uint64_t, _QWORD *))(v8 + 88);
  if (v9)
    return v9(a1, a2, a3, a4);
  krb5_set_error_message(a1, -1980176606, "kerberos prf for %s not supported", *(const char **)(v8 + 8));
  return 2314790690;
}

uint64_t krb5_crypto_fx_cf2(_krb5_context *a1, uint64_t *a2, uint64_t *a3, uint64_t a4, uint64_t a5, char *a6, _QWORD *a7)
{
  uint64_t v14;
  size_t v15;
  _BYTE *v16;
  char *v17;
  size_t v18;
  char v19;
  size_t v21;
  size_t v22;
  char *v23;
  size_t v24;
  _BYTE *v25;

  v24 = 0;
  v25 = 0;
  v22 = 0;
  v23 = 0;
  v21 = 0;
  a7[1] = 0;
  a7[2] = 0;
  *a7 = 0;
  krb5_data_zero(&v24);
  krb5_data_zero(&v22);
  v14 = krb5_enctype_keysize(a1, a6, &v21);
  if (!(_DWORD)v14)
  {
    v15 = v21;
    v14 = sub_209687008(a1, a2, a4, v21, &v24);
    if (!(_DWORD)v14)
    {
      v14 = sub_209687008(a1, a3, a5, v15, &v22);
      if (!(_DWORD)v14)
      {
        v16 = v25;
        if (v15)
        {
          v17 = v23;
          v18 = v15;
          do
          {
            v19 = *v17++;
            *v16++ ^= v19;
            --v18;
          }
          while (v18);
          v16 = v25;
        }
        v14 = krb5_random_to_key(a1, (int)a6, v16, v15, (uint64_t)a7);
      }
    }
    krb5_data_free(&v24);
    krb5_data_free(&v22);
  }
  return v14;
}

uint64_t sub_209687008(_krb5_context *a1, uint64_t *a2, uint64_t a3, size_t a4, size_t *a5)
{
  uint64_t v10;
  char *v12;
  char v13;
  uint64_t v14;
  size_t v15;
  size_t v16;
  size_t v17;
  const void *v18;
  size_t v19;
  char *v20;

  v19 = 0;
  v20 = 0;
  krb5_data_zero(&v19);
  krb5_data_zero(a5);
  krb5_clear_error_message(a1);
  v10 = krb5_data_alloc(a5, a4);
  if ((_DWORD)v10 || (v10 = krb5_data_alloc(&v19, *(_QWORD *)a3 + 1), (_DWORD)v10))
  {
LABEL_3:
    krb5_data_free(&v19);
    krb5_data_free(a5);
  }
  else
  {
    krb5_clear_error_message(a1);
    memcpy(v20 + 1, *(const void **)(a3 + 8), *(_QWORD *)a3);
    if (a4)
    {
      v12 = (char *)a5[1];
      v13 = 1;
      while (1)
      {
        v17 = 0;
        v18 = 0;
        *v20 = v13;
        v14 = krb5_crypto_prf(a1, a2, (uint64_t)&v19, &v17);
        if ((_DWORD)v14)
        {
          v10 = v14;
          goto LABEL_3;
        }
        v15 = v17;
        v16 = a4 - v17;
        if (a4 <= v17)
          break;
        ++v13;
        memcpy(v12, v18, v17);
        v12 += v15;
        krb5_data_free(&v17);
        a4 = v16;
        if (!v16)
          goto LABEL_13;
      }
      memcpy(v12, v18, a4);
      krb5_data_free(&v17);
    }
LABEL_13:
    krb5_data_free(&v19);
    return 0;
  }
  return v10;
}

void _krb5_debug_keyblock(uint64_t a1, int a2, const char *a3, uint64_t a4)
{
  uint64_t v8;
  size_t v9;
  char *__s;

  if (_krb5_have_debug(a1))
  {
    __s = 0;
    if (*(_QWORD *)(a4 + 8) >= 4uLL)
      v8 = 4;
    else
      v8 = *(_QWORD *)(a4 + 8);
    if ((rk_hex_encode(*(char **)(a4 + 16), v8, &__s) & 0x8000000000000000) == 0)
    {
      sub_20969D1E8(a1, a2, "%s %d/%s", a3, *(_DWORD *)a4, __s);
      v9 = strlen(__s);
      bzero(__s, v9);
      free(__s);
    }
  }
}

uint64_t sub_2096871FC(_krb5_context *a1, uint64_t a2, unsigned int a3, uint64_t a4, uint64_t *a5)
{
  pthread_mutex_t *v10;
  int v11;
  unsigned int **v12;
  uint64_t v13;
  char *v15;
  uint64_t v16;
  unint64_t v17;

  v10 = (pthread_mutex_t *)(a2 + 40);
  pthread_mutex_lock((pthread_mutex_t *)(a2 + 40));
  v11 = *(_DWORD *)(a4 + 32);
  if ((v11 & 4) == 0)
  {
    if ((v11 & 8) != 0)
    {
      v15 = sub_20968731C(a2, 255);
      *a5 = (uint64_t)v15;
      if (!v15)
      {
        v13 = 12;
        krb5_set_error_message(a1, 12, "malloc: out of memory");
        goto LABEL_7;
      }
      v13 = krb5_copy_keyblock(a1, *(const krb5_keyblock **)(a2 + 8), (krb5_keyblock **)v15);
      if ((_DWORD)v13)
      {
LABEL_7:
        pthread_mutex_unlock(v10);
        return v13;
      }
      v12 = (unsigned int **)*a5;
      v16 = *(_QWORD *)*a5;
      if (*(_QWORD *)(v16 + 8))
      {
        v17 = 0;
        do
        {
          *(_BYTE *)(*(_QWORD *)(v16 + 16) + v17++) ^= 0xF0u;
          v12 = (unsigned int **)*a5;
          v16 = *(_QWORD *)*a5;
        }
        while (v17 < *(_QWORD *)(v16 + 8));
      }
    }
    else
    {
      v12 = (unsigned int **)(a2 + 8);
      *a5 = a2 + 8;
    }
LABEL_6:
    v13 = sub_209685208(a1, v12);
    goto LABEL_7;
  }
  v13 = sub_209685110(a1, a2, a3, a5);
  if (!(_DWORD)v13)
  {
    v12 = (unsigned int **)*a5;
    goto LABEL_6;
  }
  return v13;
}

char *sub_20968731C(uint64_t a1, int a2)
{
  void *v4;
  char *v5;
  uint64_t v6;
  char *v7;

  v4 = malloc_type_realloc(*(void **)(a1 + 32), 8 * *(int *)(a1 + 24) + 8, 0x2004093837F09uLL);
  if (!v4)
    return 0;
  *(_QWORD *)(a1 + 32) = v4;
  v5 = (char *)malloc_type_malloc(0x18uLL, 0x1020040F89CB87BuLL);
  v6 = *(int *)(a1 + 24);
  *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8 * v6) = v5;
  if (!v5)
    return 0;
  *(_DWORD *)(a1 + 24) = v6 + 1;
  *(_QWORD *)(v5 + 12) = 0;
  *(_QWORD *)(v5 + 4) = 0;
  *((_DWORD *)v5 + 5) = 0;
  v7 = v5 + 8;
  *(_DWORD *)v5 = a2;
  return v7;
}

_QWORD *krb5_data_zero(_QWORD *result)
{
  *result = 0;
  result[1] = 0;
  return result;
}

void krb5_data_free(_QWORD *a1)
{
  void *v2;

  v2 = (void *)a1[1];
  if (v2)
    free(v2);
  *a1 = 0;
  a1[1] = 0;
}

void krb5_free_data(krb5_context a1, krb5_data *a2)
{
  char *data;

  data = a2->data;
  if (data)
    free(data);
  free(a2);
}

uint64_t krb5_data_alloc(size_t *a1, size_t a2)
{
  void *v4;
  uint64_t result;

  v4 = malloc_type_calloc(1uLL, a2, 0xAC2A8630uLL);
  a1[1] = (size_t)v4;
  if (a2 && !v4)
    return 12;
  result = 0;
  *a1 = a2;
  return result;
}

uint64_t krb5_data_realloc(uint64_t a1, size_t a2)
{
  void *v4;
  void *v5;
  uint64_t result;

  v4 = malloc_type_realloc(*(void **)(a1 + 8), a2, 0x9FB019A7uLL);
  v5 = v4;
  if (a2 && !v4)
    return 12;
  result = 0;
  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = v5;
  return result;
}

uint64_t krb5_data_copy(_QWORD *a1, const void *a2, size_t size)
{
  void *v6;
  uint64_t result;

  if (!size)
  {
    a1[1] = 0;
    goto LABEL_5;
  }
  v6 = malloc_type_calloc(1uLL, size, 0xAC2A8630uLL);
  a1[1] = v6;
  if (v6)
  {
    *a1 = size;
    memmove(v6, a2, size);
LABEL_5:
    result = 0;
    *a1 = size;
    return result;
  }
  return 12;
}

krb5_error_code krb5_copy_data(krb5_context a1, const krb5_data *a2, krb5_data **a3)
{
  krb5_data *v5;
  krb5_error_code v6;

  v5 = (krb5_data *)malloc_type_calloc(1uLL, 0x10uLL, 0x108004057E67DB5uLL);
  *a3 = v5;
  if (v5)
  {
    v6 = der_copy_octet_string();
    if (v6)
    {
      krb5_clear_error_message(a1);
      free(*a3);
      *a3 = 0;
    }
  }
  else
  {
    v6 = 12;
    krb5_set_error_message(a1, 12, "malloc: out of memory");
  }
  return v6;
}

uint64_t krb5_data_cmp(uint64_t a1, uint64_t a2)
{
  size_t v2;

  v2 = *(_QWORD *)a1;
  if (*(_QWORD *)a1 == *(_QWORD *)a2)
    return memcmp(*(const void **)(a1 + 8), *(const void **)(a2 + 8), v2);
  else
    return v2 - *(_QWORD *)a2;
}

uint64_t sub_2096875E0(_QWORD *a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  unsigned int v10;
  char *v11;
  uint64_t result;
  char *v13[2];

  v13[0] = 0;
  v13[1] = &a9;
  v10 = vasprintf(v13, a2, &a9);
  v11 = v13[0];
  result = 12;
  if (v13[0])
  {
    if ((v10 & 0x80000000) == 0)
    {
      result = 0;
      *a1 = v10;
      a1[1] = v11;
    }
  }
  return result;
}

uint64_t krb5_data_ct_cmp(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)a1;
  if (*(_QWORD *)a1 == *(_QWORD *)a2)
    return ct_memcmp(*(unsigned __int8 **)(a1 + 8), *(unsigned __int8 **)(a2 + 8), v2);
  else
    return v2 - *(_QWORD *)a2;
}

char *krb5_get_error_string(uint64_t a1)
{
  const char *v2;
  char *v3;

  pthread_mutex_lock(*(pthread_mutex_t **)(a1 + 328));
  v2 = *(const char **)(a1 + 280);
  if (v2)
    v3 = strdup(v2);
  else
    v3 = 0;
  pthread_mutex_unlock(*(pthread_mutex_t **)(a1 + 328));
  return v3;
}

uint64_t _krb5_xcc_get_initial_ticket(_krb5_context *a1, uint64_t a2, int a3, const krb5_principal_data *a4, char *__s)
{
  uint64_t v8;
  size_t v9;
  CFDataRef v10;
  CFDataRef v11;
  CFIndex v12;
  CFDictionaryRef v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  CFDictionaryRef v21;
  const void *v22;
  uint64_t v23;
  char v25;
  const char *v26;
  void *values[7];
  void *keys[8];

  keys[7] = *(void **)MEMORY[0x24BDAC8D0];
  v8 = *(_QWORD *)(a2 + 16);
  v9 = strlen(__s);
  v10 = CFDataCreateWithBytesNoCopy(0, (const UInt8 *)__s, v9, (CFAllocatorRef)*MEMORY[0x24BDBD258]);
  if (v10)
  {
    v11 = v10;
    if (a4)
      a4 = (const krb5_principal_data *)sub_2096878D8(a1, a4);
    keys[0] = CFSTR("kHEIMObjectType");
    keys[1] = CFSTR("kHEIMAttrType");
    keys[2] = CFSTR("kHEIMAttrParentCredential");
    keys[3] = CFSTR("kHEIMAttrClientName");
    keys[4] = CFSTR("kHEIMAttrData");
    keys[5] = CFSTR("kHEIMAttrCredential");
    keys[6] = CFSTR("kHEIMAttrServerName");
    values[0] = CFSTR("kHEIMObjectKerberosAcquireCred");
    values[1] = CFSTR("kHEIMTypeKerberosAcquireCred");
    values[2] = *(void **)v8;
    values[3] = *(void **)(v8 + 16);
    values[4] = v11;
    values[5] = *(void **)MEMORY[0x24BDBD270];
    values[6] = (void *)a4;
    if (a4)
      v12 = 7;
    else
      v12 = 6;
    v13 = CFDictionaryCreate(0, (const void **)keys, (const void **)values, v12, 0, 0);
    if (!v13)
      heim_abort("Failed to create dictionary:query != NULL", v14, v15, v16, v17, v18, v19, v20, v25);
    v21 = v13;
    v22 = (const void *)HeimCredCreate((uint64_t)v13, 0);
    if (v22)
    {
      CFRelease(v22);
      v23 = 0;
      if (!a4)
      {
LABEL_11:
        CFRelease(v21);
        CFRelease(v11);
        return v23;
      }
    }
    else
    {
      sub_20969D1E8((uint64_t)a1, 5, "failed to add initial ticket request to %s\n", *(const char **)(v8 + 32));
      v26 = *(const char **)(v8 + 32);
      v23 = 22;
      krb5_set_error_message(a1, 22, "failed to store initial ticket request to %s", v26);
      if (!a4)
        goto LABEL_11;
    }
    CFRelease(a4);
    goto LABEL_11;
  }
  return krb5_enomem(a1);
}

CFStringRef sub_2096878D8(_krb5_context *a1, const krb5_principal_data *a2)
{
  CFStringRef v2;
  char *cStr;

  cStr = 0;
  v2 = 0;
  if (!krb5_unparse_name(a1, a2, &cStr))
  {
    v2 = CFStringCreateWithCString(0, cStr, 0x8000100u);
    krb5_xfree(cStr);
  }
  return v2;
}

uint64_t sub_209687930(uint64_t a1, uint64_t a2)
{
  return *(_QWORD *)(*(_QWORD *)(a2 + 16) + 32);
}

uint64_t sub_20968793C(_krb5_context *a1, uint64_t a2, char *in)
{
  uint64_t v5;
  CFUUIDRef v7;
  CFUUIDRef v8;
  uint64_t v9;
  uint64_t *v10;
  uuid_t uu;

  memset(uu, 0, sizeof(uu));
  if (uuid_parse(in, uu))
  {
    v5 = 2529639054;
    krb5_set_error_message(a1, -1765328242, "failed to parse uuid: %s");
  }
  else
  {
    v7 = CFUUIDCreateFromUUIDBytes(0, *(CFUUIDBytes *)uu);
    if (v7)
    {
      v8 = v7;
      v9 = sub_209688B38(a1, a2);
      if ((_DWORD)v9)
      {
        v5 = v9;
        CFRelease(v8);
      }
      else
      {
        v10 = *(uint64_t **)(*(_QWORD *)a2 + 16);
        *v10 = (uint64_t)v8;
        sub_209688BA4((uint64_t)v10);
        sub_209688BFC(a1, v10);
        return 0;
      }
    }
    else
    {
      v5 = 2529639054;
      krb5_set_error_message(a1, -1765328242, "failed to create uuid from: %s");
    }
  }
  return v5;
}

CFIndex sub_209687A28(_krb5_context *a1, uint64_t a2)
{
  CFIndex result;

  result = sub_209688B38(a1, a2);
  if (!(_DWORD)result)
    return sub_209688D58(a1, *(_QWORD **)(*(_QWORD *)a2 + 16), 0, **(_QWORD **)a2 == (_QWORD)&krb5_xcc_temp_api_ops);
  return result;
}

uint64_t sub_209687A80(krb5_context a1, _QWORD *a2, krb5_const_principal a3)
{
  uint64_t v6;
  krb5_principal_data *v7;
  CFIndex v8;
  const void *v10;
  CFStringRef v11;
  CFDictionaryRef v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  CFDictionaryRef v20;
  char v21;
  void *values[2];
  void *keys[3];

  keys[2] = *(void **)MEMORY[0x24BDAC8D0];
  v6 = a2[2];
  v7 = *(krb5_principal_data **)(v6 + 24);
  if (v7)
    krb5_free_principal(a1, v7);
  v8 = krb5_copy_principal(a1, a3, (krb5_principal *)(v6 + 24));
  if ((_DWORD)v8)
    return v8;
  v10 = *(const void **)(v6 + 16);
  if (v10)
  {
    CFRelease(v10);
    *(_QWORD *)(v6 + 16) = 0;
  }
  v11 = sub_2096878D8(a1, a3);
  *(_QWORD *)(v6 + 16) = v11;
  if (v11)
  {
    if (*(_QWORD *)(v6 + 8))
    {
      keys[0] = CFSTR("kHEIMAttrType");
      keys[1] = CFSTR("kHEIMAttrParentCredential");
      values[0] = CFSTR("kHEIMTypeKerberos");
      values[1] = *(void **)v6;
      v12 = CFDictionaryCreate(0, (const void **)keys, (const void **)values, 2, 0, 0);
      if (!v12)
        heim_abort("Failed to create dictionary:query != NULL", v13, v14, v15, v16, v17, v18, v19, v21);
      v20 = v12;
      HeimCredDeleteQuery((uint64_t)v12, 0);
      CFRelease(v20);
    }
    else
    {
      v8 = sub_209688D58(a1, (_QWORD *)v6, *(void **)v6, *a2 == (_QWORD)&krb5_xcc_temp_api_ops);
      if ((_DWORD)v8)
        return v8;
    }
    if ((HeimCredSetAttribute(*(_QWORD *)(v6 + 8), CFSTR("kHEIMAttrClientName"), *(void **)(v6 + 16), 0) & 1) != 0)
      return 0;
    v8 = 22;
    krb5_set_error_message(a1, 22, "failed to store credential to %s", *(const char **)(v6 + 32));
    return v8;
  }
  return krb5_enomem(a1);
}

uint64_t sub_209687C68(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  const void *v3;

  v2 = *(_QWORD *)(a2 + 16);
  if (*(_QWORD *)v2)
    HeimCredDeleteByUUID(*(void **)v2);
  v3 = *(const void **)(v2 + 8);
  if (v3)
  {
    CFRelease(v3);
    *(_QWORD *)(v2 + 8) = 0;
  }
  return 0;
}

uint64_t sub_209687CA4(krb5_context a1, uint64_t a2)
{
  uint64_t v4;
  const void *v5;
  const void *v6;

  v4 = *(_QWORD *)(a2 + 16);
  if (*(_QWORD *)v4)
  {
    CFRelease(*(CFTypeRef *)v4);
    *(_QWORD *)v4 = 0;
  }
  v5 = *(const void **)(v4 + 8);
  if (v5)
  {
    CFRelease(v5);
    *(_QWORD *)(v4 + 8) = 0;
  }
  v6 = *(const void **)(v4 + 16);
  if (v6)
  {
    CFRelease(v6);
    *(_QWORD *)(v4 + 16) = 0;
  }
  krb5_free_principal(a1, *(krb5_principal *)(v4 + 24));
  free(*(void **)(v4 + 32));
  krb5_data_free((_QWORD *)(a2 + 8));
  return 0;
}

uint64_t sub_209687D24(_krb5_context *a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v5;
  uint64_t v6;
  double *v7;
  double Current;
  CFDateRef v9;
  CFDateRef v10;
  uint64_t v11;
  CFDateRef v12;
  uint64_t v13;
  uint64_t v14;
  CFDateRef v15;
  _QWORD *v16;
  uint64_t v17;
  CFDataRef v18;
  CFDataRef v19;
  _BOOL4 is_root_krbtgt;
  CFStringRef v21;
  CFStringRef v22;
  void *v23;
  CFIndex v24;
  const __CFDictionary *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  const __CFDictionary *v33;
  __CFDictionary *MutableCopy;
  const void *v35;
  const void *v36;
  char v38;
  CFIndex v39;
  const UInt8 *v40;
  void *values[9];
  void *keys[11];

  keys[9] = *(void **)MEMORY[0x24BDAC8D0];
  v5 = *(_QWORD *)(a2 + 16);
  v39 = 0;
  v40 = 0;
  krb5_data_zero(&v39);
  v6 = a3[6];
  v7 = (double *)MEMORY[0x24BDBD238];
  if (v6 || (v6 = a3[5]) != 0)
    Current = (double)v6 - *MEMORY[0x24BDBD238];
  else
    Current = CFAbsoluteTimeGetCurrent();
  v9 = CFDateCreate(0, Current);
  if (!v9)
  {
    v13 = krb5_enomem(a1);
    goto LABEL_40;
  }
  v10 = v9;
  v11 = a3[7];
  if (v11)
    v12 = CFDateCreate(0, (double)v11 - *v7);
  else
    v12 = 0;
  v14 = a3[8];
  if (v14)
    v15 = CFDateCreate(0, (double)v14 - *v7);
  else
    v15 = 0;
  v16 = krb5_storage_emem();
  if (v16)
  {
    v17 = (uint64_t)v16;
    v13 = krb5_store_creds((uint64_t)v16, (uint64_t)a3);
    if (!(_DWORD)v13)
    {
      krb5_storage_to_data(v17, (size_t *)&v39);
      v18 = CFDataCreateWithBytesNoCopy(0, v40, v39, (CFAllocatorRef)*MEMORY[0x24BDBD258]);
      if (v18)
      {
        v19 = v18;
        is_root_krbtgt = krb5_principal_is_root_krbtgt((uint64_t)a1, a3[1]);
        v21 = sub_2096878D8(a1, (const krb5_principal_data *)a3[1]);
        if (v21)
        {
          v22 = v21;
          v23 = (void *)*MEMORY[0x24BDBD268];
          if (is_root_krbtgt)
            v23 = (void *)*MEMORY[0x24BDBD270];
          keys[0] = CFSTR("kHEIMObjectType");
          keys[1] = CFSTR("kHEIMAttrType");
          keys[2] = CFSTR("kHEIMAttrClientName");
          keys[3] = CFSTR("kHEIMAttrServerName");
          keys[4] = CFSTR("kHEIMAttrData");
          keys[5] = CFSTR("kHEIMAttrParentCredential");
          keys[6] = CFSTR("kHEIMAttrLeadCredential");
          keys[7] = CFSTR("kHEIMAttrAuthTime");
          keys[8] = CFSTR("kHEIMAttrRenewTill");
          values[0] = CFSTR("kHEIMObjectKerberos");
          values[1] = CFSTR("kHEIMTypeKerberos");
          values[2] = *(void **)(v5 + 16);
          values[3] = (void *)v21;
          values[4] = v19;
          values[5] = *(void **)v5;
          values[6] = v23;
          if (v15)
            v24 = 9;
          else
            v24 = 8;
          values[7] = v10;
          values[8] = v15;
          v25 = CFDictionaryCreate(0, (const void **)keys, (const void **)values, v24, 0, 0);
          if (!v25)
            heim_abort("Failed to create dictionary:query != NULL", v26, v27, v28, v29, v30, v31, v32, v38);
          v33 = v25;
          if (v12)
          {
            MutableCopy = CFDictionaryCreateMutableCopy(0, 0, v25);
            CFDictionarySetValue(MutableCopy, CFSTR("kHEIMAttrExpire"), v12);
            CFRelease(v33);
            v33 = MutableCopy;
          }
          v35 = (const void *)HeimCredCreate((uint64_t)v33, 0);
          if (v35)
          {
            CFRelease(v35);
            v13 = 0;
          }
          else
          {
            sub_20969D1E8((uint64_t)a1, 5, "failed to add credential to %s\n", *(const char **)(v5 + 32));
            v13 = 22;
            krb5_set_error_message(a1, 22, "failed to store credential to %s", *(const char **)(v5 + 32));
          }
          krb5_storage_free(v17);
          if (v33)
            CFRelease(v33);
          CFRelease(v19);
          v36 = v22;
        }
        else
        {
          v13 = krb5_enomem(a1);
          krb5_storage_free(v17);
          v36 = v19;
        }
        CFRelease(v36);
        goto LABEL_36;
      }
      v13 = krb5_enomem(a1);
    }
    krb5_storage_free(v17);
  }
  else
  {
    v13 = krb5_enomem(a1);
  }
LABEL_36:
  CFRelease(v10);
  if (v12)
    CFRelease(v12);
  if (v15)
    CFRelease(v15);
LABEL_40:
  krb5_data_free(&v39);
  return v13;
}

uint64_t sub_2096880E4(_krb5_context *a1, uint64_t a2, krb5_principal *a3)
{
  uint64_t v5;
  uint64_t result;

  v5 = *(_QWORD *)(a2 + 16);
  result = sub_209688BFC(a1, (uint64_t *)v5);
  if (!(_DWORD)result)
    return krb5_copy_principal(a1, *(krb5_const_principal *)(v5 + 24), a3);
  return result;
}

uint64_t sub_209688138(_krb5_context *a1, uint64_t a2, const void ***a3)
{
  uint64_t v3;
  void *v4;
  const void **v7;
  const void **v8;
  CFDictionaryRef v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  CFDictionaryRef v17;
  char v19;
  void *values[2];
  void *keys[3];

  keys[2] = *(void **)MEMORY[0x24BDAC8D0];
  v3 = 2529639054;
  v4 = **(void ***)(a2 + 16);
  if (v4)
  {
    v7 = (const void **)malloc_type_calloc(1uLL, 0x10uLL, 0x1060040C2E02434uLL);
    if (!v7)
      return krb5_enomem(a1);
    v8 = v7;
    keys[0] = CFSTR("kHEIMAttrParentCredential");
    keys[1] = CFSTR("kHEIMAttrType");
    values[0] = v4;
    values[1] = CFSTR("kHEIMTypeKerberos");
    v9 = CFDictionaryCreate(0, (const void **)keys, (const void **)values, 2, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
    if (!v9)
      heim_abort("out of memory:query != NULL", v10, v11, v12, v13, v14, v15, v16, v19);
    v17 = v9;
    *v8 = HeimCredCopyQuery();
    CFRelease(v17);
    if (*v8)
    {
      v3 = 0;
      *a3 = v8;
    }
    else
    {
      sub_209688EFC(v8);
    }
  }
  return v3;
}

uint64_t sub_20968829C(uint64_t a1, uint64_t a2, const __CFArray ***a3, uint64_t a4)
{
  uint64_t v4;
  const __CFArray **v5;
  CFIndex v7;
  const __CFArray *v8;
  CFIndex v9;
  const void *ValueAtIndex;
  const __CFData *v11;
  const __CFData *v12;
  const UInt8 *BytePtr;
  CFIndex Length;
  _QWORD *v15;
  uint64_t v16;

  v4 = 2529639054;
  v5 = *a3;
  if (**a3)
  {
    while (1)
    {
      v7 = (CFIndex)v5[1];
      if (v7 >= CFArrayGetCount(*v5))
        break;
      v8 = *v5;
      v9 = (CFIndex)v5[1];
      v5[1] = (const __CFArray *)(v9 + 1);
      ValueAtIndex = CFArrayGetValueAtIndex(v8, v9);
      if (!ValueAtIndex)
        break;
      v11 = (const __CFData *)HeimCredCopyAttribute((uint64_t)ValueAtIndex, CFSTR("kHEIMAttrData"));
      if (v11)
      {
        v12 = v11;
        BytePtr = CFDataGetBytePtr(v11);
        Length = CFDataGetLength(v12);
        v15 = krb5_storage_from_readonly_mem((uint64_t)BytePtr, Length);
        if (v15)
        {
          v16 = (uint64_t)v15;
          v4 = krb5_ret_creds((uint64_t)v15, a4);
          krb5_storage_free(v16);
        }
        CFRelease(v12);
        return v4;
      }
    }
  }
  return v4;
}

uint64_t sub_209688360(uint64_t a1, uint64_t a2, const void ***a3)
{
  sub_209688EFC(*a3);
  *a3 = 0;
  return 0;
}

uint64_t sub_20968838C(_krb5_context *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;
  void **v6;
  CFStringRef v7;
  CFStringRef v8;
  CFDictionaryRef v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  CFDictionaryRef v17;
  BOOL v18;
  char v20;
  void *values[3];
  void *keys[4];

  keys[3] = *(void **)MEMORY[0x24BDAC8D0];
  v5 = 2529639053;
  v6 = *(void ***)(a2 + 16);
  v7 = sub_2096878D8(a1, *(const krb5_principal_data **)(a4 + 8));
  if (!v7)
    return 2529639054;
  v8 = v7;
  keys[0] = CFSTR("kHEIMAttrParentCredential");
  keys[1] = CFSTR("kHEIMAttrType");
  keys[2] = CFSTR("kHEIMAttrServerName");
  values[0] = *v6;
  values[1] = CFSTR("kHEIMTypeKerberos");
  values[2] = (void *)v7;
  v9 = CFDictionaryCreate(0, (const void **)keys, (const void **)values, 3, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
  if (!v9)
    heim_abort("Failed to create dictionary:query != NULL", v10, v11, v12, v13, v14, v15, v16, v20);
  v17 = v9;
  CFRelease(v8);
  v18 = HeimCredDeleteQuery((uint64_t)v17, 0);
  CFRelease(v17);
  if (v18)
    return 0;
  krb5_set_error_message(a1, -1765328243, "Deleted credential not found");
  return v5;
}

uint64_t sub_2096884CC()
{
  return 0;
}

uint64_t sub_2096884D4()
{
  return 0;
}

uint64_t sub_2096884DC(_krb5_context *a1, const void ***a2)
{
  const void *v4;
  const void **v5;
  const void **v6;
  CFDictionaryRef v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  CFDictionaryRef v15;
  uint64_t result;
  const void *v17[3];
  void *keys[3];

  keys[2] = *(void **)MEMORY[0x24BDAC8D0];
  keys[0] = CFSTR("kHEIMAttrType");
  keys[1] = CFSTR("kHEIMAttrServerName");
  v4 = (const void *)*MEMORY[0x24BDBD430];
  v17[0] = CFSTR("kHEIMTypeKerberos");
  v17[1] = v4;
  v17[2] = *(const void **)MEMORY[0x24BDBD268];
  v5 = (const void **)malloc_type_calloc(1uLL, 0x10uLL, 0x1060040C2E02434uLL);
  if (!v5)
    return krb5_enomem(a1);
  v6 = v5;
  v7 = CFDictionaryCreate(0, (const void **)keys, v17, 2, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
  if (!v7)
    heim_abort("Failed to create dictionary:query != NULL", v8, v9, v10, v11, v12, v13, v14, (char)v17[0]);
  v15 = v7;
  *v6 = HeimCredCopyQuery();
  CFRelease(v15);
  if (*v6)
  {
    result = 0;
    *a2 = v6;
  }
  else
  {
    sub_209688EFC(v6);
    return 2529639054;
  }
  return result;
}

uint64_t sub_209688640()
{
  return 2529639054;
}

uint64_t sub_20968864C(int a1, const void **a2)
{
  sub_209688EFC(a2);
  return 0;
}

uint64_t sub_209688668(_krb5_context *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;
  const void *v7;
  const void *v8;
  _QWORD *v9;
  const void *v10;
  krb5_principal_data *v11;

  v5 = *(_QWORD *)(a2 + 16);
  v6 = *(_QWORD *)(a3 + 16);
  if (!HeimCredMove(*(const __CFUUID **)v5, *(const __CFUUID **)v6))
    return 2529639054;
  if (*(_QWORD *)v5)
  {
    HeimCredDeleteByUUID(*(void **)v5);
    if (*(_QWORD *)v5)
    {
      CFRelease(*(CFTypeRef *)v5);
      *(_QWORD *)v5 = 0;
    }
  }
  v7 = *(const void **)(v6 + 8);
  if (v7)
  {
    CFRelease(v7);
    *(_QWORD *)(v6 + 8) = 0;
  }
  v8 = *(const void **)(v5 + 8);
  if (v8)
  {
    CFRelease(v8);
    *(_QWORD *)(v5 + 8) = 0;
  }
  v9 = (_QWORD *)(a2 + 8);
  v10 = *(const void **)(v6 + 16);
  if (v10)
  {
    CFRelease(v10);
    *(_QWORD *)(v6 + 16) = 0;
  }
  *(_QWORD *)(v6 + 16) = *(_QWORD *)(v5 + 16);
  *(_QWORD *)(v5 + 16) = 0;
  v11 = *(krb5_principal_data **)(v6 + 24);
  if (v11)
    krb5_free_principal(a1, v11);
  *(_QWORD *)(v6 + 24) = *(_QWORD *)(v5 + 24);
  *(_QWORD *)(v5 + 24) = 0;
  free(*(void **)(v6 + 32));
  *(_QWORD *)(v6 + 32) = 0;
  sub_209688BA4(v6);
  free(*(void **)(v5 + 32));
  krb5_data_free(v9);
  return 0;
}

uint64_t sub_209688754(int a1, char **a2)
{
  return sub_209688F28(a1, (uint64_t)&krb5_xcc_ops, "XCACHE:11111111-71F2-48EB-94C4-7D7392E900E5", a2);
}

uint64_t sub_20968876C(_krb5_context *a1, uint64_t a2)
{
  uint64_t *v3;
  uint64_t v4;
  uint64_t v5;

  v3 = *(uint64_t **)(a2 + 16);
  v4 = v3[1];
  if (!v4)
  {
    v4 = HeimCredCopyFromUUID(*v3);
    v3[1] = v4;
    if (!v4)
      return 2529639054;
  }
  if ((HeimCredSetAttribute(v4, CFSTR("kHEIMAttrDefaultCredential"), (void *)*MEMORY[0x24BDBD270], 0) & 1) != 0)
    return 0;
  v5 = 22;
  krb5_set_error_message(a1, 22, "XCACHE couldn't set default credential");
  return v5;
}

uint64_t sub_2096887F8(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  *a3 = 0;
  return 0;
}

uint64_t sub_209688804(uint64_t a1, uint64_t a2)
{
  uint64_t *v2;
  uint64_t v3;

  v2 = *(uint64_t **)(a2 + 16);
  v3 = v2[1];
  if (!v3)
  {
    v3 = HeimCredCopyFromUUID(*v2);
    v2[1] = v3;
    if (!v3)
      return 2529639053;
  }
  HeimCredRetainTransient(v3);
  return 0;
}

uint64_t sub_20968884C(uint64_t a1, uint64_t a2)
{
  uint64_t *v2;
  uint64_t v3;

  v2 = *(uint64_t **)(a2 + 16);
  v3 = v2[1];
  if (!v3)
  {
    v3 = HeimCredCopyFromUUID(*v2);
    v2[1] = v3;
    if (!v3)
      return 2529639053;
  }
  HeimCredReleaseTransient(v3);
  return 0;
}

uint64_t sub_209688894(uint64_t a1, uint64_t a2, CFUUIDBytes *a3)
{
  *a3 = CFUUIDGetUUIDBytes((CFUUIDRef)**(_QWORD **)(a2 + 16));
  return 0;
}

uint64_t sub_2096888C8(_krb5_context *a1, uint64_t a2, char *cStr, void *a4)
{
  uint64_t *v7;
  uint64_t v8;
  __CFString *v9;
  __CFString *v10;
  int v11;

  v7 = *(uint64_t **)(a2 + 16);
  if (!v7[1])
  {
    v8 = HeimCredCopyFromUUID(*v7);
    v7[1] = v8;
    if (!v8)
      return 2529639054;
  }
  v9 = (__CFString *)CFStringCreateWithCString(0, cStr, 0x8000100u);
  if (!v9)
    return krb5_enomem(a1);
  v10 = v9;
  v11 = HeimCredSetAttribute(v7[1], v9, a4, 0);
  CFRelease(v10);
  if (v11)
    return 0;
  else
    return 2529639054;
}

uint64_t sub_20968897C(_krb5_context *a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  v6 = *(uint64_t **)(a2 + 16);
  *a4 = 0;
  v7 = v6[1];
  if (!v7)
  {
    v7 = HeimCredCopyFromUUID(*v6);
    v6[1] = v7;
    if (!v7)
      return 2529639054;
  }
  v8 = HeimCredCopyAttributes(v7, 0, 0);
  *a4 = v8;
  if (v8)
    return 0;
  v9 = 2529639054;
  krb5_set_error_message(a1, -1765328242, "Credential have no attributes");
  return v9;
}

BOOL sub_209688A10(uint64_t a1, void **a2)
{
  void *v2;

  v2 = *a2;
  return *a2 == &krb5_xcc_api_ops || v2 == &krb5_xcc_ops || v2 == &krb5_xcc_temp_api_ops;
}

uint64_t sub_209688A40(_krb5_context *a1, uint64_t a2, _QWORD *a3)
{
  uint64_t v4;
  CFIndex v7;
  const __CFArray *v8;
  CFIndex v9;
  const void *ValueAtIndex;
  const void *v11;
  _QWORD *v12;
  const void *UUID;

  v4 = 2529639054;
  if (*(_QWORD *)a2)
  {
    v7 = *(_QWORD *)(a2 + 8);
    if (v7 < CFArrayGetCount(*(CFArrayRef *)a2))
    {
      v8 = *(const __CFArray **)a2;
      v9 = *(_QWORD *)(a2 + 8);
      *(_QWORD *)(a2 + 8) = v9 + 1;
      ValueAtIndex = CFArrayGetValueAtIndex(v8, v9);
      if (ValueAtIndex)
      {
        v11 = ValueAtIndex;
        v4 = sub_20967E178(a1, (uint64_t)&krb5_xcc_api_ops, a3);
        if (!(_DWORD)v4)
        {
          sub_209688B38(a1, (uint64_t)a3);
          v12 = *(_QWORD **)(*a3 + 16);
          UUID = (const void *)HeimCredGetUUID((uint64_t)v11);
          *v12 = UUID;
          CFRetain(UUID);
          v12[1] = v11;
          CFRetain(v11);
          sub_209688BA4((uint64_t)v12);
        }
      }
    }
  }
  return v4;
}

uint64_t sub_209688B04(int a1, char **a2)
{
  return sub_209688F28(a1, (uint64_t)&krb5_xcc_api_ops, "API:11111111-71F2-48EB-94C4-7D7392E900E5", a2);
}

uint64_t sub_209688B20()
{
  return 2529639054;
}

uint64_t sub_209688B2C()
{
  return 2529639054;
}

uint64_t sub_209688B38(_krb5_context *a1, uint64_t a2)
{
  *(_QWORD *)(*(_QWORD *)a2 + 16) = malloc_type_calloc(1uLL, 0x28uLL, 0x700403DF0E5C8uLL);
  if (!*(_QWORD *)(*(_QWORD *)a2 + 16))
    return krb5_enomem(a1);
  *(_QWORD *)(*(_QWORD *)a2 + 8) = 40;
  return 0;
}

void sub_209688BA4(uint64_t a1)
{
  char *v2;
  CFUUIDBytes v3;

  if (!*(_QWORD *)(a1 + 32))
  {
    v3 = CFUUIDGetUUIDBytes((CFUUIDRef)*(_QWORD *)a1);
    v2 = (char *)malloc_type_malloc(0x25uLL, 0x90064977uLL);
    *(_QWORD *)(a1 + 32) = v2;
    uuid_unparse(&v3.byte0, v2);
  }
}

uint64_t sub_209688BFC(_krb5_context *a1, uint64_t *a2)
{
  uint64_t v4;
  const void *v5;
  const void *v6;
  const __CFString *v7;
  uint64_t v8;
  char *v9;
  char *v10;
  krb5_principal v11;
  krb5_principal v13;

  v4 = a2[1];
  if (!v4)
  {
    v5 = (const void *)HeimCredCopyFromUUID(*a2);
    v6 = (const void *)HeimCredCopyAttributes((uint64_t)v5, 0, 0);
    if (v6)
    {
      a2[1] = (uint64_t)v5;
      CFRetain(v5);
    }
    if (v5)
      CFRelease(v5);
    if (v6)
      CFRelease(v6);
    v4 = a2[1];
    if (!v4)
    {
      v8 = 2529639053;
      krb5_set_error_message(a1, -1765328243, "no credential for %s");
      return v8;
    }
  }
  v7 = (const __CFString *)a2[2];
  if (!v7)
  {
    v7 = (const __CFString *)HeimCredCopyAttribute(v4, CFSTR("kHEIMAttrClientName"));
    a2[2] = (uint64_t)v7;
    if (!v7)
    {
      v8 = 2529639053;
      krb5_set_error_message(a1, -1765328243, "no cache for %s");
      return v8;
    }
  }
  if (!a2[3])
  {
    v13 = 0;
    v9 = rk_cfstring2cstring(v7);
    if (v9)
    {
      v10 = v9;
      krb5_parse_name(a1, v9, &v13);
      free(v10);
      v11 = v13;
      a2[3] = (uint64_t)v13;
      if (v11)
        return 0;
    }
    else
    {
      a2[3] = 0;
    }
    v8 = 2529639053;
    krb5_set_error_message(a1, -1765328243, "no principal for %s");
    return v8;
  }
  return 0;
}

CFIndex sub_209688D58(_krb5_context *a1, _QWORD *a2, void *a3, int a4)
{
  void **v7;
  CFIndex v8;
  CFDictionaryRef v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  CFDictionaryRef v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  const void *UUID;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  CFIndex v34;
  CFTypeRef cf;
  void *values[4];
  void *keys[5];

  keys[4] = *(void **)MEMORY[0x24BDAC8D0];
  keys[0] = CFSTR("kHEIMObjectType");
  keys[1] = CFSTR("kHEIMAttrType");
  keys[2] = CFSTR("kHEIMAttrTemporaryCache");
  keys[3] = CFSTR("kHEIMAttrUUID");
  values[0] = CFSTR("kHEIMObjectKerberos");
  values[1] = CFSTR("kHEIMTypeKerberos");
  v7 = (void **)MEMORY[0x24BDBD268];
  if (a4)
    v7 = (void **)MEMORY[0x24BDBD270];
  values[2] = *v7;
  values[3] = a3;
  if (a3)
    v8 = 4;
  else
    v8 = 3;
  cf = 0;
  v9 = CFDictionaryCreate(0, (const void **)keys, (const void **)values, v8, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
  if (!v9)
    heim_abort("Failed to create dictionary:attrs != NULL", v10, v11, v12, v13, v14, v15, v16, (char)cf);
  v17 = v9;
  a2[1] = HeimCredCreate((uint64_t)v9, (CFErrorRef *)&cf);
  CFRelease(v17);
  v25 = a2[1];
  if (v25)
  {
    if (!a3)
    {
      if (*a2)
        heim_abort("credential should not already have a UUID:x->uuid == NULL", v18, v19, v20, v21, v22, v23, v24, (char)cf);
      UUID = (const void *)HeimCredGetUUID(v25);
      *a2 = UUID;
      if (!UUID)
        heim_abort("no uuid for credential?:x->uuid != NULL", v27, v28, v29, v30, v31, v32, v33, (char)cf);
      CFRetain(UUID);
    }
    sub_209688BA4((uint64_t)a2);
    v34 = 0;
  }
  else
  {
    v34 = sub_2096895C4(a1, 12, (__CFError *)cf, "no reply from GSSCred", v21, v22, v23, v24, (char)cf);
  }
  if (cf)
    CFRelease(cf);
  return v34;
}

void sub_209688EFC(const void **a1)
{
  const void *v2;

  v2 = *a1;
  if (v2)
    CFRelease(v2);
  free(a1);
}

uint64_t sub_209688F28(int a1, uint64_t a2, char *a3, char **a4)
{
  const __CFUUID *v8;
  const __CFUUID *v9;
  CFUUIDBytes uu;
  uuid_string_t out;
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  v8 = (const __CFUUID *)HeimCredCopyDefaultCredential(CFSTR("kHEIMTypeKerberos"), 0);
  if (!v8)
    return _krb5_expand_default_cc_name(a1, a3);
  v9 = v8;
  uu = CFUUIDGetUUIDBytes(v8);
  uuid_unparse(&uu.byte0, out);
  CFRelease(v9);
  asprintf(a4, "%s:%s", *(const char **)(a2 + 8), out);
  return 0;
}

uint64_t sub_209689028(_krb5_context *a1, uint64_t a2, CFUUIDBytes *a3)
{
  CFUUIDRef v5;
  CFUUIDRef v6;
  uint64_t v7;
  CFUUIDRef *v8;
  uint64_t v10;

  v10 = a2;
  v5 = CFUUIDCreateFromUUIDBytes(0, *a3);
  if (v5)
  {
    v6 = v5;
    v7 = sub_209688B38(a1, (uint64_t)&v10);
    if ((_DWORD)v7)
    {
      CFRelease(v6);
    }
    else
    {
      v8 = *(CFUUIDRef **)(a2 + 16);
      *v8 = v6;
      sub_209688BA4((uint64_t)v8);
    }
  }
  else
  {
    v7 = 2529639054;
    krb5_set_error_message(a1, -1765328242, "failed to create uuid");
  }
  return v7;
}

uint64_t krb5_eai_to_heim_errno(uint64_t result, uint64_t a2)
{
  int v2;

  switch((int)result)
  {
    case 0:
      return result;
    case 1:
      return 2314790785;
    case 2:
      return 2314790786;
    case 3:
      return 2314790787;
    case 4:
      return 2314790788;
    case 5:
      v2 = 5;
      goto LABEL_12;
    case 6:
      return 2314790790;
    case 7:
      return 2314790791;
    case 8:
      return 2314790792;
    case 9:
      v2 = 9;
      goto LABEL_12;
    case 10:
      v2 = 10;
LABEL_12:
      result = v2 | 0x89F8E780;
      break;
    case 11:
      result = a2;
      break;
    default:
      result = 2314790784;
      break;
  }
  return result;
}

uint64_t krb5_h_errno_to_heim_errno(unsigned int a1)
{
  if (a1 > 4)
    return 2314790784;
  else
    return dword_2096D93A4[a1];
}

void krb5_set_error_message(krb5_context a1, krb5_error_code a2, const char *a3, ...)
{
  va_list va;

  va_start(va, a3);
  krb5_vset_error_message(a1, a2, a3, va);
}

void krb5_vset_error_message(krb5_context a1, krb5_error_code a2, const char *a3, va_list a4)
{
  _QWORD *v8;
  void *v9;
  const char *v10;

  if (a1)
  {
    pthread_mutex_lock(*((pthread_mutex_t **)a1 + 41));
    v8 = (_QWORD *)((char *)a1 + 280);
    v9 = (void *)*((_QWORD *)a1 + 35);
    if (v9)
    {
      free(v9);
      *v8 = 0;
    }
    *((_DWORD *)a1 + 72) = a2;
    if (vasprintf((char **)a1 + 35, a3, a4) < 0)
      *v8 = 0;
    pthread_mutex_unlock(*((pthread_mutex_t **)a1 + 41));
    v10 = (const char *)*((_QWORD *)a1 + 35);
    if (v10)
      sub_20969D1E8((uint64_t)a1, 100, "set-error: %d: %s", a2, v10);
  }
}

const char *__cdecl krb5_get_error_message(krb5_context a1, krb5_error_code a2)
{
  const char *v4;
  int v5;
  char *v6;
  krb5_error_code inited;
  krb5_error_code v9;
  char *v10;
  const char *v11;
  char *v12;
  int v13;
  BOOL v14;
  char *v15;
  krb5_context v16;
  char __dst[128];
  uint64_t v18;

  v18 = *MEMORY[0x24BDAC8D0];
  v15 = 0;
  v16 = a1;
  if (!a2)
    return strdup("Success");
  if (!a1)
  {
    inited = krb5_init_context(&v16);
    v9 = inited;
    if (v16)
    {
      v10 = com_right_r(*((_QWORD **)v16 + 18), a2, __dst, 0x80uLL);
      v6 = v10;
      if (v9)
      {
        if (!v10)
          goto LABEL_19;
        goto LABEL_13;
      }
    }
    else
    {
      if (inited)
        goto LABEL_19;
      v6 = 0;
    }
    krb5_free_context(v16);
    if (!v6)
      goto LABEL_19;
LABEL_13:
    v11 = v6;
    return strdup(v11);
  }
  pthread_mutex_lock(*((pthread_mutex_t **)a1 + 41));
  v4 = (const char *)*((_QWORD *)a1 + 35);
  if (!v4 || (v5 = *((_DWORD *)a1 + 72), v5 != a2) && v5)
  {
    pthread_mutex_unlock(*((pthread_mutex_t **)a1 + 41));
    goto LABEL_7;
  }
  v12 = strdup(v4);
  v15 = v12;
  pthread_mutex_unlock(*((pthread_mutex_t **)a1 + 41));
  if (!v12)
  {
LABEL_7:
    v6 = com_right_r(*((_QWORD **)a1 + 18), a2, __dst, 0x80uLL);
    if (!v6)
    {
LABEL_19:
      v11 = error_message(a2);
      if (!v11)
      {
        v13 = asprintf(&v15, "<unknown error: %d>", a2);
        if (v15)
          v14 = v13 == -1;
        else
          v14 = 1;
        if (v14)
          return 0;
        else
          return v15;
      }
      return strdup(v11);
    }
    goto LABEL_13;
  }
  return v12;
}

void krb5_free_error_message(krb5_context a1, const char *a2)
{
  if (a2)
    free((void *)a2);
}

const char *krb5_get_err_text(uint64_t a1, int __errnum)
{
  const char *result;

  if (!a1 || (result = (const char *)com_right(*(_QWORD **)(a1 + 144), __errnum)) == 0)
    result = strerror(__errnum);
  if (!result)
    return "Unknown error";
  return result;
}

CFIndex sub_209689474(_krb5_context *a1, CFIndex Code, CFErrorRef err, char *a4, va_list a5)
{
  const __CFString *v10;
  const __CFString *v11;
  char *v12;
  const __CFDictionary *v13;
  const __CFDictionary *v14;
  const __CFBoolean *Value;
  const __CFBoolean *v16;
  CFTypeID v17;
  char *v19;

  v19 = 0;
  if (err)
  {
    v10 = CFErrorCopyDescription(err);
    if (v10)
    {
      v11 = v10;
      v12 = rk_cfstring2cstring(v10);
      CFRelease(v11);
    }
    else
    {
      v12 = 0;
    }
    v13 = CFErrorCopyUserInfo(err);
    if (v13)
    {
      v14 = v13;
      Value = (const __CFBoolean *)CFDictionaryGetValue(v13, CFSTR("CommonErrorCode"));
      if (Value)
      {
        v16 = Value;
        v17 = CFGetTypeID(Value);
        if (v17 == CFBooleanGetTypeID())
        {
          if (CFBooleanGetValue(v16))
            Code = CFErrorGetCode(err);
        }
      }
      CFRelease(v14);
    }
  }
  else
  {
    v12 = 0;
  }
  if ((vasprintf(&v19, a4, a5) & 0x80000000) == 0 && v19)
  {
    if (v12)
    {
      krb5_set_error_message(a1, Code, "%s: %s", v19, v12);
      free(v12);
    }
    else
    {
      krb5_set_error_message(a1, Code, "%s", v19);
    }
    v12 = v19;
  }
  free(v12);
  return Code;
}

CFIndex sub_2096895C4(_krb5_context *a1, CFIndex a2, __CFError *a3, char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  return sub_209689474(a1, a2, a3, a4, &a9);
}

uint64_t krb5_expand_hostname(_krb5_context *a1, char *__s1, unsigned __int8 **a3)
{
  addrinfo *v7;
  addrinfo *v8;
  const char *ai_canonname;
  uint64_t v10;
  addrinfo v11;
  addrinfo *v12;

  if ((*((_BYTE *)a1 + 360) & 1) == 0)
    return sub_2096896F0(a1, __s1, a3);
  v12 = 0;
  memset(&v11, 0, sizeof(v11));
  v11.ai_flags = 2;
  if (!getaddrinfo(__s1, 0, &v11, &v12))
  {
    v7 = v12;
    if (v12)
    {
      v8 = v12;
      while (1)
      {
        ai_canonname = v8->ai_canonname;
        if (ai_canonname)
          break;
        v8 = v8->ai_next;
        if (!v8)
          goto LABEL_8;
      }
      *a3 = (unsigned __int8 *)strdup(ai_canonname);
      freeaddrinfo(v7);
      if (*a3)
        return 0;
      v10 = 12;
      krb5_set_error_message(a1, 12, "malloc: out of memory");
      return v10;
    }
LABEL_8:
    freeaddrinfo(v12);
  }
  return sub_2096896F0(a1, __s1, a3);
}

uint64_t sub_2096896F0(_krb5_context *a1, char *__s1, unsigned __int8 **a3)
{
  unsigned __int8 *v5;
  uint64_t v6;

  v5 = (unsigned __int8 *)strdup(__s1);
  *a3 = v5;
  if (v5)
  {
    rk_strlwr(v5);
    return 0;
  }
  else
  {
    v6 = 12;
    krb5_set_error_message(a1, 12, "malloc: out of memory");
  }
  return v6;
}

uint64_t krb5_expand_hostname_realms(_krb5_context *a1, char *a2, unsigned __int8 **a3, char ***a4)
{
  addrinfo *v9;
  char *ai_canonname;
  uint64_t v11;
  addrinfo *v12;
  uint64_t v13;
  addrinfo v14;
  addrinfo *v15;

  if ((*((_BYTE *)a1 + 360) & 1) == 0)
    return sub_209689880(a1, a2, a3, a4);
  v15 = 0;
  memset(&v14, 0, sizeof(v14));
  v14.ai_flags = 2;
  if (getaddrinfo(a2, 0, &v14, &v15))
    return sub_209689880(a1, a2, a3, a4);
  v9 = v15;
  if (!v15)
  {
    v12 = 0;
LABEL_12:
    freeaddrinfo(v12);
    return sub_209689880(a1, a2, a3, a4);
  }
  while (1)
  {
    ai_canonname = v9->ai_canonname;
    if (ai_canonname)
      break;
LABEL_9:
    v9 = v9->ai_next;
    if (!v9)
    {
      v12 = v15;
      goto LABEL_12;
    }
  }
  v11 = sub_2096896F0(a1, ai_canonname, a3);
  if ((_DWORD)v11)
  {
    v13 = v11;
    freeaddrinfo(v15);
    return v13;
  }
  rk_strlwr(*a3);
  if (krb5_get_host_realm(a1, (const char *)*a3, a4))
  {
    free(*a3);
    goto LABEL_9;
  }
  freeaddrinfo(v15);
  return 0;
}

uint64_t sub_209689880(_krb5_context *a1, char *a2, unsigned __int8 **a3, char ***a4)
{
  uint64_t host_realm;

  host_realm = sub_2096896F0(a1, a2, a3);
  if (!(_DWORD)host_realm)
  {
    rk_strlwr(*a3);
    host_realm = krb5_get_host_realm(a1, (const char *)*a3, a4);
    if ((_DWORD)host_realm)
      free(*a3);
  }
  return host_realm;
}

uint64_t sub_2096898E4(_krb5_context *a1, int a2, int a3)
{
  __int16 v4;
  uint64_t v5;
  int v6;
  BOOL v7;
  _QWORD v9[2];
  uint64_t v10;
  char __strerrbuf[128];
  uint64_t v12;

  v12 = *MEMORY[0x24BDAC8D0];
  v9[1] = 0;
  v10 = 0;
  if (a3)
    v4 = 3;
  else
    v4 = 1;
  v9[0] = 0;
  WORD2(v10) = v4;
  v5 = fcntl(a2, 9, v9);
  if ((v5 & 0x80000000) != 0)
    v5 = *__error();
  if ((_DWORD)v5 == 13)
    v6 = 35;
  else
    v6 = v5;
  if (v6)
    v7 = v6 == 22;
  else
    v7 = 1;
  if (v7)
    return 0;
  if (v6 == 35)
  {
    v5 = 35;
    krb5_set_error_message(a1, 35, "timed out locking cache file %s");
  }
  else
  {
    strerror_r(v6, __strerrbuf, 0x80uLL);
    krb5_set_error_message(a1, v6, "error locking cache file %s: %s");
  }
  return v5;
}

uint64_t sub_2096899F8(_krb5_context *a1, int a2)
{
  uint64_t v3;
  uint64_t result;
  _QWORD v5[3];
  char __strerrbuf[128];
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[1] = 0;
  v5[2] = 0x200000000;
  v5[0] = 0;
  v3 = fcntl(a2, 9, v5);
  if ((v3 & 0x80000000) != 0)
    v3 = *__error();
  result = 0;
  if ((_DWORD)v3)
  {
    if ((_DWORD)v3 != 22)
    {
      strerror_r(v3, __strerrbuf, 0x80uLL);
      krb5_set_error_message(a1, v3, "Failed to unlock file: %s", __strerrbuf);
      return v3;
    }
  }
  return result;
}

uint64_t sub_209689AC4(_krb5_context *a1, char *a2)
{
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  unsigned int v9;
  unsigned int v10;
  stat v11;
  stat v12;

  memset(&v12, 0, sizeof(v12));
  memset(&v11, 0, sizeof(v11));
  if (lstat(a2, &v12) < 0)
    return *__error();
  v4 = open(a2, 2);
  if (v4 < 0)
  {
    if (*__error() == 2)
      return 0;
    return *__error();
  }
  v5 = v4;
  sub_2096B7FDC(v4);
  v6 = sub_2096898E4(a1, v5, 1);
  if ((_DWORD)v6)
  {
    v7 = v6;
    close(v5);
    return v7;
  }
  if (unlink(a2) < 0 || fstat(v5, &v11) < 0)
  {
    sub_2096899F8(a1, v5);
    close(v5);
    return *__error();
  }
  if (v12.st_dev != v11.st_dev || v12.st_ino != v11.st_ino)
  {
    sub_2096899F8(a1, v5);
    close(v5);
    return 1;
  }
  if (v11.st_nlink)
  {
    sub_2096899F8(a1, v5);
    close(v5);
    return 0;
  }
  v9 = sub_209689C54(v5);
  v10 = sub_2096899F8(a1, v5);
  close(v5);
  if (v9)
    return v9;
  else
    return v10;
}

uint64_t sub_209689C54(int a1)
{
  off_t v2;
  uint64_t v3;
  size_t v4;
  ssize_t v5;
  _OWORD v7[8];
  uint64_t v8;

  v8 = *MEMORY[0x24BDAC8D0];
  v2 = lseek(a1, 0, 2);
  if ((v2 & 0x8000000000000000) == 0)
  {
    v3 = v2;
    if ((lseek(a1, 0, 0) & 0x8000000000000000) == 0)
    {
      memset(v7, 0, sizeof(v7));
      if (!v3)
      {
LABEL_9:
        fsync(a1);
        return 0;
      }
      while (1)
      {
        v4 = (unint64_t)v3 >= 0x80 ? 128 : v3;
        v5 = write(a1, v7, v4);
        if (v5 < 0)
          break;
        v3 -= v5;
        if (v3 < 1)
          goto LABEL_9;
      }
    }
  }
  return *__error();
}

uint64_t sub_209689D2C(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a2 + 16);
  if (v2)
    return *(_QWORD *)v2;
  else
    return 0;
}

uint64_t sub_209689D44(_krb5_context *a1, uint64_t a2, const char *a3)
{
  _DWORD *v6;
  _DWORD *v7;
  char *v8;
  uint64_t v9;

  v6 = malloc_type_malloc(0x10uLL, 0x1010040A1D9428BuLL);
  if (!v6)
  {
    v9 = 2529639110;
LABEL_6:
    krb5_set_error_message(a1, -1765328186, "malloc: out of memory");
    return v9;
  }
  v7 = v6;
  v8 = strdup(a3);
  *(_QWORD *)v7 = v8;
  if (!v8)
  {
    v9 = 2529639110;
    free(v7);
    goto LABEL_6;
  }
  v9 = 0;
  v7[2] = 0;
  *(_QWORD *)(*(_QWORD *)a2 + 16) = v7;
  *(_QWORD *)(*(_QWORD *)a2 + 8) = 16;
  return v9;
}

uint64_t sub_209689DF8(_krb5_context *a1, uint64_t a2)
{
  _DWORD *v4;
  _DWORD *v5;
  uint64_t v6;
  char *v7;
  int v9;
  char *v10;
  char *__s1;

  v10 = 0;
  __s1 = 0;
  v4 = malloc_type_malloc(0x10uLL, 0x1010040A1D9428BuLL);
  if (!v4)
  {
    v6 = 2529639110;
LABEL_9:
    krb5_set_error_message(a1, -1765328186, "malloc: out of memory");
    return v6;
  }
  v5 = v4;
  if (asprintf(&__s1, "%sXXXXXX", "%{TEMP}/krb5cc_") < 0 || !__s1)
  {
    v6 = 2529639110;
    free(v5);
    goto LABEL_9;
  }
  v6 = _krb5_expand_default_cc_name_0(a1, __s1, (void **)&v10);
  free(__s1);
  if ((_DWORD)v6)
  {
    v7 = (char *)v5;
  }
  else
  {
    __s1 = v10;
    v9 = mkstemp(v10);
    if ((v9 & 0x80000000) == 0)
    {
      close(v9);
      v6 = 0;
      *(_QWORD *)v5 = v10;
      v5[2] = 0;
      *(_QWORD *)(*(_QWORD *)a2 + 16) = v5;
      *(_QWORD *)(*(_QWORD *)a2 + 8) = 16;
      return v6;
    }
    v6 = *__error();
    krb5_set_error_message(a1, v6, "mkstemp %s failed", v10);
    free(v5);
    v7 = v10;
  }
  free(v7);
  return v6;
}

uint64_t sub_209689F44(unsigned int *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;
  uint64_t v7;
  _QWORD *v8;
  int v9;
  int v10;
  int v11;
  int v13;
  int v14;
  int v15;
  int v16;
  int v18;
  int v19;
  int *v20;
  int v21;
  char __strerrbuf[128];
  uint64_t v23;

  v23 = *MEMORY[0x24BDAC8D0];
  v4 = *(_QWORD *)(a2 + 16);
  if (!v4)
    return sub_20969EB00();
  v21 = 0;
  unlink(*(const char **)v4);
  v7 = sub_20968AE48((_krb5_context *)a1, a2, "initialize", &v21, 16779778, 0x180u);
  if (!(_DWORD)v7)
  {
    v8 = krb5_storage_emem();
    krb5_storage_set_eof_code((uint64_t)v8, -1765328242);
    v9 = a1[63];
    if (!v9)
      v9 = 4;
    *(_DWORD *)(v4 + 8) = v9;
    v10 = krb5_store_int8((uint64_t)v8, 5);
    v11 = krb5_store_int8((uint64_t)v8, *(_BYTE *)(v4 + 8)) | v10;
    sub_20968AFBC((_krb5_context *)a1, (uint64_t)v8, *(_DWORD *)(v4 + 8));
    if (*(_DWORD *)(v4 + 8) == 4 && v11 == 0)
    {
      if (a1[27])
      {
        v13 = krb5_store_int16((uint64_t)v8, 0xCu);
        v14 = krb5_store_int16((uint64_t)v8, 1u) | v13;
        v15 = v14 | krb5_store_int16((uint64_t)v8, 8u);
        v16 = v15 | krb5_store_int32((uint64_t)v8, a1[27]);
        v11 = v16 | krb5_store_int32((uint64_t)v8, a1[28]);
      }
      else
      {
        v11 = krb5_store_int16((uint64_t)v8, 0);
      }
    }
    v18 = krb5_store_principal((uint64_t)v8, a3);
    v19 = v21;
    v7 = v18 | v11 | sub_20968B004((_krb5_context *)a1, (uint64_t)v8, v21);
    krb5_storage_free((uint64_t)v8);
    sub_2096899F8((_krb5_context *)a1, v19);
    if (close(v19) < 0 && !(_DWORD)v7)
    {
      v20 = __error();
      v7 = *v20;
      strerror_r(*v20, __strerrbuf, 0x80uLL);
      krb5_set_error_message((krb5_context)a1, v7, "close %s: %s", **(const char ***)(a2 + 16), __strerrbuf);
    }
  }
  return v7;
}

uint64_t sub_20968A190(_krb5_context *a1, uint64_t a2)
{
  char **v2;

  v2 = *(char ***)(a2 + 16);
  if (!v2)
    return sub_20969EB00();
  sub_209689AC4(a1, *v2);
  return 0;
}

uint64_t sub_20968A1C8(uint64_t a1, uint64_t a2)
{
  void **v2;
  _QWORD *v3;

  v2 = *(void ***)(a2 + 16);
  if (!v2)
    return sub_20969EB00();
  v3 = (_QWORD *)(a2 + 8);
  free(*v2);
  krb5_data_free(v3);
  return 0;
}

uint64_t sub_20968A218(_krb5_context *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  int v15;
  char __strerrbuf[128];
  uint64_t v17;

  v17 = *MEMORY[0x24BDAC8D0];
  v15 = 0;
  v6 = sub_20968AE48(a1, a2, "store", &v15, 16777225, 0);
  if (!(_DWORD)v6)
  {
    v7 = krb5_storage_emem();
    krb5_storage_set_eof_code((uint64_t)v7, -1765328242);
    sub_20968AFBC(a1, (uint64_t)v7, *(_DWORD *)(*(_QWORD *)(a2 + 16) + 8));
    if (!krb5_config_get_BOOL_default((uint64_t)a1, 0, 1, v8, v9, v10, v11, v12, (uint64_t)"libdefaults"))
      krb5_storage_set_flags((uint64_t)v7, 128);
    v6 = krb5_store_creds((uint64_t)v7, a3);
    v13 = v15;
    if (!(_DWORD)v6)
      v6 = sub_20968B004(a1, (uint64_t)v7, v15);
    krb5_storage_free((uint64_t)v7);
    sub_2096899F8(a1, v13);
    if (close(v13) < 0 && !(_DWORD)v6)
    {
      strerror_r(0, __strerrbuf, 0x80uLL);
      v6 = *__error();
      krb5_set_error_message(a1, v6, "close %s: %s", **(const char ***)(a2 + 16), __strerrbuf);
    }
  }
  return v6;
}

uint64_t sub_20968A398(unsigned int *a1, uint64_t a2, _QWORD *a3)
{
  uint64_t v5;
  uint64_t v6;
  int v7;
  uint64_t v9;
  int v10;

  v10 = 0;
  v9 = 0;
  v5 = sub_20968B0A8(a1, a2, "get-pricipal", &v9, &v10, 0);
  if (!(_DWORD)v5)
  {
    v6 = v9;
    v5 = krb5_ret_principal(v9, a3);
    if ((_DWORD)v5)
      krb5_clear_error_message((krb5_context)a1);
    krb5_storage_free(v6);
    v7 = v10;
    sub_2096899F8((_krb5_context *)a1, v10);
    close(v7);
  }
  return v5;
}

uint64_t sub_20968A434(unsigned int *a1, uint64_t a2, int **a3)
{
  int *v6;
  uint64_t v7;
  uint64_t v8;
  krb5_principal v10;

  if (!*(_QWORD *)(a2 + 16))
    return sub_20969EB00();
  v6 = (int *)malloc_type_malloc(0x10uLL, 0x1020040D5A9D86FuLL);
  *a3 = v6;
  if (v6)
  {
    *(_QWORD *)v6 = 0;
    *((_QWORD *)v6 + 1) = 0;
    v7 = sub_20968B0A8(a1, a2, "get-frist", (uint64_t *)*a3 + 1, *a3, 0);
    if ((_DWORD)v7)
    {
      v8 = v7;
      free(*a3);
      *a3 = 0;
    }
    else
    {
      v10 = 0;
      v8 = krb5_ret_principal(*((_QWORD *)*a3 + 1), &v10);
      if ((_DWORD)v8)
      {
        krb5_clear_error_message((krb5_context)a1);
        sub_20968A624((uint64_t)a1, a2, a3);
      }
      else
      {
        krb5_free_principal((krb5_context)a1, v10);
        sub_2096899F8((_krb5_context *)a1, **a3);
      }
    }
  }
  else
  {
    v8 = 12;
    krb5_set_error_message((krb5_context)a1, 12, "malloc: out of memory");
  }
  return v8;
}

uint64_t sub_20968A564(_krb5_context *a1, uint64_t a2, int **a3, uint64_t a4)
{
  uint64_t v7;

  if (!*(_QWORD *)(a2 + 16) || !*a3)
    return sub_20969EB00();
  v7 = sub_2096898E4(a1, **a3, 0);
  if (!(_DWORD)v7)
  {
    v7 = krb5_ret_creds(*((_QWORD *)*a3 + 1), a4);
    if ((_DWORD)v7)
      krb5_clear_error_message(a1);
    sub_2096899F8(a1, **a3);
  }
  return v7;
}

uint64_t sub_20968A624(uint64_t a1, uint64_t a2, int **a3)
{
  if (!*(_QWORD *)(a2 + 16) || !*a3)
    return sub_20969EB00();
  krb5_storage_free(*((_QWORD *)*a3 + 1));
  close(**a3);
  free(*a3);
  *a3 = 0;
  return 0;
}

uint64_t sub_20968A69C(krb5_context context, uint64_t a2, krb5_flags a3, krb5_creds *a4)
{
  uint64_t v8;
  uint64_t v9;
  _krb5_ccache *v10;
  uint64_t v12;
  int v13;
  uint64_t v14;
  std::error_code *v15;
  int v16;
  char *v17;
  krb5_ccache cache;
  krb5_ccache id;

  v17 = 0;
  if (!*(_QWORD *)(a2 + 16))
    return sub_20969EB00();
  cache = 0;
  id = 0;
  v8 = krb5_cc_new_unique(context, krb5_cc_type_memory[0], 0, &id);
  if (!(_DWORD)v8)
  {
    v9 = krb5_cc_copy_cache(context, a2, (uint64_t)id);
    v10 = id;
    if ((_DWORD)v9)
    {
      v8 = v9;
    }
    else
    {
      v12 = krb5_cc_remove_cred(context, id, a3, a4);
      if ((_DWORD)v12)
      {
        v8 = v12;
      }
      else
      {
        if (asprintf(&v17, "FILE:%s.XXXXXX", **(const char ***)(a2 + 16)) < 0 || !v17)
        {
          krb5_cc_destroy(context, id);
          return 12;
        }
        v13 = mkstemp(v17 + 5);
        if (v13 < 0)
        {
          v8 = *__error();
        }
        else
        {
          close(v13);
          v14 = krb5_cc_resolve(context, v17, &cache);
          if (!(_DWORD)v14)
          {
            v8 = krb5_cc_copy_cache(context, (uint64_t)id, (uint64_t)cache);
            krb5_cc_destroy(context, id);
            if (!(_DWORD)v8)
            {
              rename((const std::__fs::filesystem::path *)(v17 + 5), **(const std::__fs::filesystem::path ***)(a2 + 16), v15);
              if (v16)
                v8 = *__error();
              else
                v8 = 0;
              free(v17);
              krb5_cc_close(context, cache);
              return v8;
            }
            free(v17);
            v10 = cache;
            goto LABEL_9;
          }
          v8 = v14;
          unlink(v17 + 5);
          free(v17);
        }
      }
      v10 = id;
    }
LABEL_9:
    krb5_cc_destroy(context, v10);
  }
  return v8;
}

uint64_t sub_20968A874(uint64_t a1, uint64_t a2)
{
  if (*(_QWORD *)(a2 + 16))
    return 0;
  else
    return sub_20969EB00();
}

uint64_t sub_20968A894(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a2 + 16);
  if (v2)
    return *(unsigned int *)(v2 + 8);
  else
    return 0xFFFFFFFFLL;
}

uint64_t sub_20968A8AC(_krb5_context *a1, _QWORD *a2)
{
  _DWORD *v4;
  uint64_t v5;

  v4 = malloc_type_calloc(1uLL, 4uLL, 0x100004052888210uLL);
  if (v4)
  {
    v5 = 0;
    *v4 = 1;
    *a2 = v4;
  }
  else
  {
    v5 = 12;
    krb5_set_error_message(a1, 12, "malloc: out of memory");
  }
  return v5;
}

uint64_t sub_20968A924(const char **a1, _DWORD *a2, krb5_ccache *a3)
{
  const char *v5;
  uint64_t v6;
  stat v8;
  char *v9;

  v9 = 0;
  if (!a2)
    return sub_20969EB00();
  if (*a2)
  {
    *a2 = 0;
    v5 = a1[38];
    if (v5 && !strncasecmp(a1[38], "FILE:", 5uLL))
      goto LABEL_7;
    v6 = _krb5_expand_default_cc_name((int)a1, "FILE:%{TEMP}/krb5cc_%{uid}");
    if (!(_DWORD)v6)
    {
      v5 = v9;
LABEL_7:
      if (!strncasecmp(v5, "FILE:", 5uLL) && (memset(&v8, 0, sizeof(v8)), stat(v5 + 5, &v8)))
        v6 = 2529639054;
      else
        v6 = krb5_cc_resolve((krb5_context)a1, v5, a3);
      if (v9)
        free(v9);
    }
  }
  else
  {
    v6 = 2529639054;
    krb5_clear_error_message((krb5_context)a1);
  }
  return v6;
}

uint64_t sub_20968AA50(int a1, void *a2)
{
  if (!a2)
    return sub_20969EB00();
  free(a2);
  return 0;
}

uint64_t sub_20968AA80(_krb5_context *a1, uint64_t a2, uint64_t a3)
{
  int v6;
  uint64_t v7;
  int v8;
  int v9;
  const char *v10;
  ssize_t v11;
  int *v12;
  int v13;
  int v15[2];
  uint64_t __buf[129];

  __buf[128] = *MEMORY[0x24BDAC8D0];
  rename(**(const std::__fs::filesystem::path ***)(a2 + 16), **(const std::__fs::filesystem::path ***)(a3 + 16), (std::error_code *)a3);
  if (v6)
  {
    if (*__error() != 18)
    {
      v12 = __error();
      v7 = *v12;
      strerror_r(*v12, (char *)__buf, 0x80uLL);
      krb5_set_error_message(a1, v7, "Rename of file from %s to %s failed: %s", **(const char ***)(a2 + 16), **(const char ***)(a3 + 16), (const char *)__buf);
      return v7;
    }
    if (*__error() == 18)
    {
      *(_QWORD *)v15 = 0;
      v7 = sub_20968AE48(a1, a2, "move/from", &v15[1], 0x1000000, 0);
      if ((_DWORD)v7)
        return v7;
      unlink(**(const char ***)(a3 + 16));
      v7 = sub_20968AE48(a1, a3, "move/to", v15, 16779777, 0x180u);
      v8 = v15[1];
      if (!(_DWORD)v7)
      {
        v9 = v15[0];
        v10 = "Failed to write data from one file credential cache to the other";
        while (1)
        {
          v11 = read(v8, __buf, 0x400uLL);
          if (v11 < 1)
            break;
          if (v11 != write(v9, __buf, v11))
            goto LABEL_14;
        }
        if ((v11 & 0x8000000000000000) == 0)
        {
          v7 = 0;
          goto LABEL_15;
        }
        v10 = "Failed to read data from one file credential cache to the other";
LABEL_14:
        v7 = 5;
        krb5_set_error_message(a1, 5, v10);
LABEL_15:
        sub_2096899F8(a1, v9);
        close(v9);
      }
      sub_2096899F8(a1, v8);
      close(v8);
      sub_209689AC4(a1, **(char ***)(a2 + 16));
      if ((_DWORD)v7)
      {
        sub_209689AC4(a1, **(char ***)(a3 + 16));
        return v7;
      }
    }
  }
  __buf[0] = 0;
  v15[1] = 0;
  v7 = sub_20968B0A8((unsigned int *)a1, a3, "move", __buf, &v15[1], 0);
  if (!(_DWORD)v7)
  {
    if (__buf[0])
      krb5_storage_free(__buf[0]);
    v13 = v15[1];
    sub_2096899F8(a1, v15[1]);
    close(v13);
  }
  sub_20968A1C8((uint64_t)a1, a2);
  return v7;
}

uint64_t sub_20968ACFC(int a1)
{
  return _krb5_expand_default_cc_name(a1, "FILE:%{TEMP}/krb5cc_%{uid}");
}

uint64_t sub_20968AD0C(_krb5_context *a1, uint64_t a2, __darwin_time_t *a3)
{
  uint64_t v5;
  int v6;
  int v7;
  int v9;
  stat v10;

  memset(&v10, 0, sizeof(v10));
  v9 = 0;
  v5 = sub_20968AE48(a1, a2, "lastchange", &v9, 0x1000000, 0);
  if (!(_DWORD)v5)
  {
    v6 = v9;
    v7 = fstat(v9, &v10);
    close(v6);
    if (v7)
    {
      v5 = *__error();
      krb5_set_error_message(a1, v5, "Failed to stat cache file");
    }
    else
    {
      v5 = 0;
      *a3 = v10.st_mtimespec.tv_sec;
    }
  }
  return v5;
}

uint64_t sub_20968ADC8()
{
  return 0;
}

uint64_t sub_20968ADD0(unsigned int *a1, uint64_t a2, _QWORD *a3)
{
  uint64_t v4;
  int v5;
  int v7;
  uint64_t v8;

  v8 = 0;
  v7 = 0;
  v4 = sub_20968B0A8(a1, a2, "get-kdc-offset", &v8, &v7, a3);
  if (v8)
    krb5_storage_free(v8);
  v5 = v7;
  sub_2096899F8((_krb5_context *)a1, v7);
  close(v5);
  return v4;
}

uint64_t sub_20968AE48(_krb5_context *a1, uint64_t a2, const char *a3, int *a4, int a5, unsigned int a6)
{
  _BOOL4 v8;
  const char **v9;
  const char *v12;
  int v13;
  int v14;
  int *v16;
  uint64_t v17;
  uint64_t v18;
  char __strerrbuf[128];
  uint64_t v20;

  v20 = *MEMORY[0x24BDAC8D0];
  v8 = (a5 | 1) == a5 || (a5 | 2) == a5;
  v9 = *(const char ***)(a2 + 16);
  if (!v9)
    return sub_20969EB00();
  v12 = *v9;
  v13 = open(*v9, a5, a6);
  if (v13 < 0)
  {
    v16 = __error();
    v17 = *v16;
    strerror_r(*v16, __strerrbuf, 0x80uLL);
    krb5_set_error_message(a1, v17, "%s open(%s): %s", a3, v12, __strerrbuf);
  }
  else
  {
    v14 = v13;
    sub_2096B7FDC(v13);
    v18 = sub_2096898E4(a1, v14, v8);
    v17 = v18;
    if ((_DWORD)v18)
      close(v14);
    else
      *a4 = v14;
  }
  return v17;
}

uint64_t sub_20968AFBC(_krb5_context *a1, uint64_t a2, int a3)
{
  if ((a3 - 1) >= 4)
    krb5_abortx(a1, "storage_set_flags called with bad vno (%x)", a3);
  return krb5_storage_set_flags(a2, dword_2096D93B8[a3 - 1]);
}

uint64_t sub_20968B004(_krb5_context *a1, uint64_t a2, int a3)
{
  uint64_t v5;
  uint64_t v6;
  ssize_t v7;
  size_t v8;
  size_t v10;
  const void *v11;

  v10 = 0;
  v11 = 0;
  v5 = krb5_storage_to_data(a2, &v10);
  if ((_DWORD)v5)
  {
    v6 = v5;
    krb5_set_error_message(a1, v5, "malloc: out of memory");
  }
  else
  {
    v7 = write(a3, v11, v10);
    v8 = v10;
    krb5_data_free(&v10);
    if (v7 == v8)
    {
      return 0;
    }
    else
    {
      v6 = *__error();
      krb5_set_error_message(a1, v6, "Failed to write FILE credential data");
    }
  }
  return v6;
}

uint64_t sub_20968B0A8(unsigned int *a1, uint64_t a2, const char *a3, uint64_t *a4, int *a5, _QWORD *a6)
{
  uint64_t v11;
  int v12;
  _QWORD *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  const char *v17;
  _krb5_context *v18;
  krb5_error_code v19;
  int v21;
  int v22;
  uint64_t v23;
  __int16 v24;
  int v25;
  uint64_t v26;
  uint64_t v27;
  signed int v28;
  char v29;
  int v30;
  __int16 v31;
  __int16 v32;
  int v33;

  if (a6)
    *a6 = 0;
  v33 = 0;
  v32 = 0;
  v11 = sub_20968AE48((_krb5_context *)a1, a2, a3, &v33, 0x1000000, 0);
  if ((_DWORD)v11)
    return v11;
  v12 = v33;
  v13 = krb5_storage_from_fd(v33);
  if (!v13)
  {
    krb5_clear_error_message((krb5_context)a1);
    v11 = 12;
    goto LABEL_18;
  }
  v14 = (uint64_t)v13;
  v11 = 2529639111;
  krb5_storage_set_eof_code((uint64_t)v13, -1765328242);
  v15 = krb5_ret_int8(v14, (uint64_t)&v32 + 1);
  if ((_DWORD)v15)
  {
    v16 = v15;
    if ((_DWORD)v15 == -1765328242)
    {
      v11 = 2;
      krb5_set_error_message((krb5_context)a1, 2, "Empty credential cache file: %s");
    }
    else
    {
      krb5_set_error_message((krb5_context)a1, v15, "Error reading pvno in cache file: %s", **(const char ***)(a2 + 16));
      v11 = v16;
    }
    goto LABEL_17;
  }
  if (HIBYTE(v32) != 5)
  {
    v11 = 2529639124;
    v26 = **(_QWORD **)(a2 + 16);
    v17 = "Bad version number in credential cache file: %s";
LABEL_15:
    v18 = (_krb5_context *)a1;
    v19 = -1765328172;
    goto LABEL_16;
  }
  if (krb5_ret_int8(v14, (uint64_t)&v32))
  {
    v26 = **(_QWORD **)(a2 + 16);
    v17 = "Error reading tag in cache file: %s";
    goto LABEL_12;
  }
  v21 = (char)v32;
  *(_DWORD *)(*(_QWORD *)(a2 + 16) + 8) = (char)v32;
  sub_20968AFBC((_krb5_context *)a1, v14, v21);
  if (((char)v32 - 1) < 3)
  {
LABEL_21:
    v11 = 0;
    *a4 = v14;
    *a5 = v12;
    return v11;
  }
  if ((char)v32 != 4)
  {
    v11 = 2529639124;
    v26 = (char)v32;
    v27 = **(_QWORD **)(a2 + 16);
    v17 = "Unknown version number (%d) in credential cache file: %s";
    goto LABEL_15;
  }
  v31 = 0;
  if (krb5_ret_int16(v14, &v31))
  {
    v26 = **(_QWORD **)(a2 + 16);
    v17 = "Error reading tag length in cache file: %s";
    goto LABEL_12;
  }
  if (v31 < 1)
    goto LABEL_21;
  while (1)
  {
    v30 = 0;
    v29 = 0;
    if (krb5_ret_int16(v14, (_WORD *)&v30 + 1))
    {
      v26 = **(_QWORD **)(a2 + 16);
      v17 = "Error reading dtag in cache file: %s";
      goto LABEL_12;
    }
    if (krb5_ret_int16(v14, &v30))
    {
      v26 = **(_QWORD **)(a2 + 16);
      v17 = "Error reading dlength in cache file: %s";
      goto LABEL_12;
    }
    if (HIWORD(v30) != 1)
      break;
    v28 = 0;
    v22 = krb5_ret_int32(v14, (unsigned int *)&v28);
    if (krb5_ret_int32(v14, a1 + 28) | v22)
    {
      v26 = **(_QWORD **)(a2 + 16);
      v17 = "Error reading kdc_sec in cache file: %s";
      goto LABEL_12;
    }
    v23 = v28;
    a1[27] = v28;
    if (a6)
      *a6 = v23;
    v24 = v30;
LABEL_38:
    v31 = v31 - v24 - 4;
    if (v31 <= 0)
      goto LABEL_21;
  }
  v24 = v30;
  if ((__int16)v30 < 1)
    goto LABEL_38;
  v25 = 0;
  while (!krb5_ret_int8(v14, (uint64_t)&v29))
  {
    ++v25;
    v24 = v30;
    if (v25 >= (__int16)v30)
      goto LABEL_38;
  }
  v26 = **(_QWORD **)(a2 + 16);
  v17 = "Error reading unknown tag in cache file: %s";
LABEL_12:
  v18 = (_krb5_context *)a1;
  v19 = -1765328185;
LABEL_16:
  krb5_set_error_message(v18, v19, v17, v26, v27);
LABEL_17:
  krb5_storage_free(v14);
LABEL_18:
  sub_2096899F8((_krb5_context *)a1, v12);
  close(v12);
  return v11;
}

krb5_error_code krb5_free_host_realm(krb5_context a1, char *const *a2)
{
  char *v3;
  char *const *v4;
  char *v5;

  if (a2)
  {
    v3 = *a2;
    if (*a2)
    {
      v4 = a2 + 1;
      do
      {
        free(v3);
        v5 = *v4++;
        v3 = v5;
      }
      while (v5);
    }
    free((void *)a2);
  }
  return 0;
}

uint64_t krb5_free_kdc_rep(uint64_t a1, _OWORD *a2)
{
  sub_2096BBC9C();
  sub_2096BBD70();
  sub_2096BC0D0();
  a2[23] = 0u;
  a2[24] = 0u;
  a2[21] = 0u;
  a2[22] = 0u;
  a2[19] = 0u;
  a2[20] = 0u;
  a2[17] = 0u;
  a2[18] = 0u;
  a2[15] = 0u;
  a2[16] = 0u;
  a2[13] = 0u;
  a2[14] = 0u;
  a2[11] = 0u;
  a2[12] = 0u;
  a2[9] = 0u;
  a2[10] = 0u;
  a2[7] = 0u;
  a2[8] = 0u;
  a2[5] = 0u;
  a2[6] = 0u;
  a2[3] = 0u;
  a2[4] = 0u;
  a2[1] = 0u;
  a2[2] = 0u;
  *a2 = 0u;
  return 0;
}

uint64_t krb5_xfree(void *a1)
{
  free(a1);
  return 0;
}

uint64_t krb5_generate_seq_number(_krb5_context *a1, uint64_t a2, int *a3)
{
  uint64_t result;
  int v6;

  result = CCRandomCopyBytes();
  if ((_DWORD)result)
    krb5_abortx(a1, "Failed to generate random block");
  if ((*a3 & 0x3FFFFFFE) != 0)
    v6 = *a3 & 0x3FFFFFFF;
  else
    v6 = 1;
  *a3 = v6;
  return result;
}

uint64_t krb5_generate_subkey_extended(_krb5_context *a1, unsigned int *a2, char *a3, void **a4)
{
  void *v8;
  uint64_t random_keyblock;

  v8 = malloc_type_calloc(1uLL, 0x18uLL, 0x10800404ACF7207uLL);
  *a4 = v8;
  if (v8)
  {
    if (!(_DWORD)a3)
      a3 = (char *)*a2;
    random_keyblock = krb5_generate_random_keyblock(a1, a3, (uint64_t)v8);
    if ((_DWORD)random_keyblock)
    {
      free(*a4);
      *a4 = 0;
    }
  }
  else
  {
    random_keyblock = 12;
    krb5_set_error_message(a1, 12, "malloc: out of memory");
  }
  return random_keyblock;
}

uint64_t krb5_get_all_client_addrs(_krb5_context *a1, uint64_t a2)
{
  char v2;

  if (*((_DWORD *)a1 + 60))
    v2 = 14;
  else
    v2 = 6;
  return sub_20968B5F8(a1, a2, v2);
}

uint64_t sub_20968B5F8(_krb5_context *a1, uint64_t a2, char a3)
{
  uint64_t extra_addresses;
  int *v7;
  uint64_t *v8;
  uint64_t *v9;
  _QWORD *v10;
  uint64_t v11;
  int *v12;
  krb5_address **v14[33];

  v14[32] = *(krb5_address ***)MEMORY[0x24BDAC8D0];
  *(_DWORD *)a2 = 0;
  *(_QWORD *)(a2 + 8) = 0;
  if ((a3 & 8) != 0 && (sub_20968BA1C(a1, a2, a3) || !*(_DWORD *)a2))
  {
    if (gethostname((char *)v14, 0x100uLL))
    {
      v7 = __error();
      extra_addresses = *v7;
      strerror(*v7);
      krb5_set_error_message(a1, extra_addresses, "gethostname: %s");
      goto LABEL_7;
    }
    v8 = sub_2096B9D00((const char *)v14);
    if (!v8)
    {
      v12 = __error();
      extra_addresses = *v12;
      strerror(*v12);
      krb5_set_error_message(a1, extra_addresses, "gethostbyname %s: %s");
LABEL_7:
      if ((_DWORD)extra_addresses)
        goto LABEL_21;
      goto LABEL_2;
    }
    v9 = v8;
    *(_DWORD *)a2 = 1;
    v10 = malloc_type_malloc(0x18uLL, 0x10800404ACF7207uLL);
    *(_QWORD *)(a2 + 8) = v10;
    if (!v10)
    {
      extra_addresses = 12;
      krb5_set_error_message(a1, 12, "malloc: out of memory");
      goto LABEL_21;
    }
    *(_DWORD *)v10 = *((_DWORD *)v9 + 4);
    v10[2] = 0;
    v10[1] = 0;
    v11 = krb5_data_copy(v10 + 1, *(const void **)v9[3], *((int *)v9 + 5));
    if ((_DWORD)v11)
    {
      extra_addresses = v11;
      free(*(void **)(a2 + 8));
      goto LABEL_21;
    }
  }
LABEL_2:
  if ((a3 & 4) != 0)
  {
    v14[0] = 0;
    v14[1] = 0;
    extra_addresses = krb5_get_extra_addresses(a1, v14);
    if ((_DWORD)extra_addresses
      || (extra_addresses = krb5_append_addresses(a1, a2, (unsigned int *)v14), (_DWORD)extra_addresses))
    {
      krb5_free_addresses(a1, (krb5_address **)a2);
      return extra_addresses;
    }
    krb5_free_addresses(a1, (krb5_address **)v14);
  }
  else
  {
    extra_addresses = 0;
  }
LABEL_21:
  if (!*(_DWORD *)a2)
  {
    free(*(void **)(a2 + 8));
    *(_QWORD *)(a2 + 8) = 0;
  }
  return extra_addresses;
}

uint64_t krb5_get_all_server_addrs(_krb5_context *a1, uint64_t a2)
{
  return sub_20968B5F8(a1, a2, 9);
}

uint64_t krb5_get_all_any_addrs(_krb5_context *a1, uint64_t a2)
{
  uint64_t v4;
  char v5;
  char v6;
  uint64_t appended;
  int v9;
  _QWORD v10[3];
  uint64_t v11;
  _QWORD *v12;
  _OWORD v13[8];
  uint64_t v14;

  v4 = 0;
  v14 = *MEMORY[0x24BDAC8D0];
  v11 = 0;
  v12 = 0;
  memset(v13, 0, sizeof(v13));
  memset(v10, 0, sizeof(v10));
  *(_DWORD *)a2 = 0;
  v5 = 1;
  *(_QWORD *)(a2 + 8) = 0;
  do
  {
    v6 = v5;
    v9 = 128;
    if (!krb5_anyaddr(a1, dword_2096D93C8[v4], (uint64_t)v13, (uint64_t)&v9, 0)
      && !krb5_sockaddr2address(a1, (uint64_t)v13, (uint64_t)v10))
    {
      v12 = v10;
      LODWORD(v11) = 1;
      appended = krb5_append_addresses(a1, a2, (unsigned int *)&v11);
      krb5_free_address((uint64_t)a1, (uint64_t)v10);
      if ((_DWORD)appended)
      {
        krb5_free_addresses(a1, (krb5_address **)a2);
        return appended;
      }
    }
    v5 = 0;
    v4 = 1;
  }
  while ((v6 & 1) != 0);
  if (*(_DWORD *)a2)
    return 0;
  appended = 6;
  krb5_set_error_message(a1, 6, "no addresses found");
  return appended;
}

uint64_t sub_20968B958(_krb5_context *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  char v5;
  char v6;
  krb5_address *v8;
  uint64_t v9;

  v8 = 0;
  v9 = 0;
  if (sub_20968BA1C(a1, (uint64_t)&v8, 8))
    return 0;
  if ((_DWORD)v8)
  {
    v3 = 0;
    v2 = 0;
    do
    {
      v4 = 0;
      v5 = 1;
      while (1)
      {
        v6 = v5;
        if (*(_DWORD *)(v9 + 24 * v3) == dword_2096D93D0[2 * v4])
          break;
        v5 = 0;
        v4 = 1;
        if ((v6 & 1) == 0)
          goto LABEL_10;
      }
      v2 = dword_2096D93D0[2 * v4 + 1] | v2;
LABEL_10:
      ++v3;
    }
    while (v3 != v8);
  }
  else
  {
    v2 = 0;
  }
  krb5_free_addresses(a1, &v8);
  return v2;
}

uint64_t sub_20968BA1C(_krb5_context *a1, uint64_t a2, char a3)
{
  ifaddrs **v6;
  size_t v7;
  uint64_t ignore_addresses;
  int *v9;
  void *v10;
  ifaddrs *v11;
  unsigned int v12;
  sockaddr *ifa_addr;
  BOOL v14;
  uint64_t v15;
  ifaddrs *v17;
  sockaddr *v18;
  BOOL v19;
  uint64_t v20;
  krb5_address **v21[2];
  ifaddrs *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;

  v25 = *MEMORY[0x24BDAC8D0];
  v21[1] = 0;
  v22 = 0;
  v21[0] = 0;
  if (getifaddrs(&v22) == -1)
  {
    v9 = __error();
    ignore_addresses = *v9;
    strerror(*v9);
    krb5_set_error_message(a1, ignore_addresses, "getifaddrs: %s");
    return ignore_addresses;
  }
  v23 = 0;
  v24 = 0;
  v6 = &v22;
  LODWORD(v7) = -1;
  do
  {
    v6 = (ifaddrs **)*v6;
    v7 = (v7 + 1);
  }
  while (v6);
  if (!(_DWORD)v7)
  {
    MEMORY[0x20BD12264](v22);
    ignore_addresses = 6;
    krb5_set_error_message(a1, 6, "no addresses found");
    return ignore_addresses;
  }
  if ((a3 & 4) != 0)
  {
    ignore_addresses = krb5_get_ignore_addresses(a1, v21);
    if ((_DWORD)ignore_addresses)
      return ignore_addresses;
  }
  else
  {
    ignore_addresses = 6;
  }
  v10 = malloc_type_calloc(v7, 0x18uLL, 0x10800404ACF7207uLL);
  *(_QWORD *)(a2 + 8) = v10;
  if (!v10)
  {
    krb5_free_addresses(a1, (krb5_address **)v21);
    MEMORY[0x20BD12264](v22);
    ignore_addresses = 12;
    krb5_set_error_message(a1, 12, "malloc: out of memory");
    return ignore_addresses;
  }
  v11 = v22;
  if (v22)
  {
    v12 = 0;
    do
    {
      if ((v11->ifa_flags & 1) != 0)
      {
        ifa_addr = v11->ifa_addr;
        if (ifa_addr)
        {
          v14 = *(_QWORD *)&ifa_addr->sa_len == v23 && *(_QWORD *)&ifa_addr->sa_data[6] == v24;
          if (!v14
            && !krb5_sockaddr_uninteresting((uint64_t)ifa_addr)
            && (!sub_20967B3A0((uint64_t)v11->ifa_addr) || (a3 & 1) != 0))
          {
            v15 = krb5_sockaddr2address(a1, (uint64_t)v11->ifa_addr, *(_QWORD *)(a2 + 8) + 24 * v12);
            if ((_DWORD)v15)
            {
              ignore_addresses = v15;
            }
            else if ((a3 & 4) != 0
                   && krb5_address_search(a1, (const krb5_address *)(*(_QWORD *)(a2 + 8) + 24 * v12), (krb5_address *const *)v21))
            {
              krb5_free_address((uint64_t)a1, *(_QWORD *)(a2 + 8) + 24 * v12);
              ignore_addresses = 0;
              a3 &= ~2u;
            }
            else
            {
              ignore_addresses = 0;
              ++v12;
            }
          }
        }
      }
      v11 = v11->ifa_next;
    }
    while (v11);
    if ((a3 & 2) == 0)
      goto LABEL_55;
    goto LABEL_34;
  }
  v12 = 0;
  if ((a3 & 2) != 0)
  {
LABEL_34:
    if (!v12)
    {
      v17 = v22;
      if (v22)
      {
        v12 = 0;
        do
        {
          if ((v17->ifa_flags & 1) != 0)
          {
            v18 = v17->ifa_addr;
            if (v18)
            {
              v19 = *(_QWORD *)&v18->sa_len == v23 && *(_QWORD *)&v18->sa_data[6] == v24;
              if (!v19
                && !krb5_sockaddr_uninteresting((uint64_t)v18)
                && sub_20967B3A0((uint64_t)v17->ifa_addr)
                && (v17->ifa_flags & 8) != 0)
              {
                v20 = krb5_sockaddr2address(a1, (uint64_t)v17->ifa_addr, *(_QWORD *)(a2 + 8) + 24 * v12);
                if ((_DWORD)v20)
                {
                  ignore_addresses = v20;
                }
                else if ((a3 & 4) != 0
                       && krb5_address_search(a1, (const krb5_address *)(*(_QWORD *)(a2 + 8) + 24 * v12), (krb5_address *const *)v21))
                {
                  krb5_free_address((uint64_t)a1, *(_QWORD *)(a2 + 8) + 24 * v12);
                  ignore_addresses = 0;
                }
                else
                {
                  ignore_addresses = 0;
                  ++v12;
                }
              }
            }
          }
          v17 = v17->ifa_next;
        }
        while (v17);
      }
      else
      {
        v12 = 0;
      }
    }
  }
LABEL_55:
  if ((a3 & 4) != 0)
    krb5_free_addresses(a1, (krb5_address **)v21);
  MEMORY[0x20BD12264](v22);
  if ((_DWORD)ignore_addresses)
  {
    free(*(void **)(a2 + 8));
    *(_QWORD *)(a2 + 8) = 0;
  }
  else
  {
    *(_DWORD *)a2 = v12;
  }
  return ignore_addresses;
}

uint64_t _krb5_get_krbtgt(_krb5_context *a1, _krb5_ccache *a2, char *data, krb5_creds **a4)
{
  uint64_t credentials_with_flags;
  uint64_t v9;
  krb5_principal_data *v10;
  krb5_principal principal[2];
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;

  v19 = 0u;
  v20 = 0u;
  v17 = 0u;
  v18 = 0u;
  v15 = 0u;
  v16 = 0u;
  v13 = 0u;
  v14 = 0u;
  *(_OWORD *)principal = 0u;
  credentials_with_flags = krb5_cc_get_principal(a1, a2, principal);
  if (!(_DWORD)credentials_with_flags)
  {
    if (!data)
      data = (char *)principal[0]->data;
    v9 = krb5_make_principal(a1, &principal[1], data, "krbtgt", data, 0);
    if ((_DWORD)v9)
    {
      credentials_with_flags = v9;
      v10 = principal[0];
    }
    else
    {
      credentials_with_flags = krb5_get_credentials_with_flags((uint64_t)a1, 1, 0, a2, (uint64_t)principal, a4);
      krb5_free_principal(a1, principal[0]);
      v10 = principal[1];
    }
    krb5_free_principal(a1, v10);
  }
  return credentials_with_flags;
}

krb5_error_code krb5_get_credentials(krb5_context a1, krb5_flags a2, krb5_ccache a3, krb5_creds *a4, krb5_creds **a5)
{
  return krb5_get_credentials_with_flags((uint64_t)a1, a2, 0, a3, (uint64_t)a4, a5);
}

uint64_t krb5_get_kdc_cred(_krb5_context *a1, _krb5_ccache *a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, void **a7)
{
  void *v13;
  uint64_t krbtgt;
  uint64_t v15;
  krb5_creds *v17;

  v13 = malloc_type_calloc(1uLL, 0x90uLL, 0x10A0040AAA52FDDuLL);
  *a7 = v13;
  if (v13)
  {
    v17 = 0;
    krbtgt = _krb5_get_krbtgt(a1, a2, *(char **)(*(_QWORD *)(a6 + 8) + 24), &v17);
    if ((_DWORD)krbtgt)
    {
      v15 = krbtgt;
LABEL_6:
      free(*a7);
      *a7 = 0;
      return v15;
    }
    v15 = sub_20968BF44((uint64_t)a1, (uint64_t)a2, 0, a3, a4, a6, (uint64_t)v17, 0, 0, 0, 0, (krb5_principal *)*a7);
    krb5_free_creds(a1, v17);
    if ((_DWORD)v15)
      goto LABEL_6;
  }
  else
  {
    v15 = 12;
    krb5_set_error_message(a1, 12, "malloc: out of memory");
  }
  return v15;
}

uint64_t sub_20968BF44(uint64_t a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5, uint64_t a6, uint64_t a7, __int128 *a8, _OWORD *a9, char *a10, char *a11, krb5_principal *a12)
{
  _OWORD *v20;
  int v21;
  uint64_t v22;
  uint64_t v23;
  __int128 *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t ImpersonateBundle;
  char *v39;
  __CFBundle *MainBundle;
  CFStringRef Identifier;
  CFStringRef v42;
  CFStringRef v43;
  char v44;
  uint64_t v45;
  int v46[2];
  uint64_t v47;
  _QWORD v48[2];
  uint64_t v49;
  _OWORD v50[4];
  uint64_t v51;
  uint64_t v52;
  krb5_keyblock *v53;
  int v54;
  _OWORD v55[6];
  uint64_t v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  __int128 v61;
  __int128 v62;
  __int128 v63;
  __int128 v64;
  __int128 v65;
  __int128 v66;
  __int128 v67;
  __int128 v68;
  __int128 v69;
  __int128 v70;
  __int128 v71;
  __int128 v72;
  __int128 v73;
  __int128 v74;
  __int128 v75;
  __int128 v76;
  __int128 v77;
  __int128 v78;
  __int128 v79;
  __int128 v80;
  __int128 v81;
  krb5_data v82;
  size_t v83;
  void *v84;
  _BYTE v85[96];
  __int128 v86;
  uint64_t v87;

  v20 = a9;
  v87 = 0;
  v86 = 0u;
  memset(v85, 0, sizeof(v85));
  v83 = 0;
  v84 = 0;
  *(_QWORD *)&v82.magic = 0;
  v82.data = 0;
  v80 = 0u;
  v81 = 0u;
  v78 = 0u;
  v79 = 0u;
  v76 = 0u;
  v77 = 0u;
  v74 = 0u;
  v75 = 0u;
  v72 = 0u;
  v73 = 0u;
  v70 = 0u;
  v71 = 0u;
  v68 = 0u;
  v69 = 0u;
  v66 = 0u;
  v67 = 0u;
  v64 = 0u;
  v65 = 0u;
  v62 = 0u;
  v63 = 0u;
  v60 = 0u;
  v61 = 0u;
  v58 = 0u;
  v59 = 0u;
  v57 = 0u;
  v56 = 0;
  memset(v55, 0, sizeof(v55));
  v54 = 0;
  v52 = 0;
  v53 = 0;
  v51 = 0;
  memset(v50, 0, sizeof(v50));
  v49 = 0;
  krb5_data_zero(&v82);
  krb5_data_zero(&v83);
  v48[1] = 0;
  v48[0] = 0;
  krb5_generate_random_block((uint64_t)&v54, 4);
  if ((a4 & 0x10000000) != 0 && !a9)
  {
    v21 = a4;
    v22 = a1;
    v23 = a7;
    v24 = a8;
    v25 = a3;
    v26 = decode_Ticket();
    if ((_DWORD)v26)
      return v26;
    a3 = v25;
    a8 = v24;
    a7 = v23;
    a1 = v22;
    a4 = v21;
    v20 = v50;
  }
  if (!krb5_cc_get_kdc_offset(a1, a2, &v49))
    *(_QWORD *)(a1 + 108) = v49;
  v27 = sub_20969AC6C((_krb5_context *)a1, a2, a3, a5, a4, a8, (uint64_t)v20, a6, a7, v54, (unsigned int *)v48, &v53, (uint64_t)v85);
  v28 = a3;
  v26 = v27;
  if (!(_DWORD)v27)
  {
    v45 = v28;
    v83 = sub_2096BBAC0();
    v84 = malloc_type_malloc(v83, 0x3ED40145uLL);
    if (!v84)
    {
      v26 = 12;
      goto LABEL_8;
    }
    v30 = sub_2096BBAA0();
    if ((_DWORD)v30)
    {
      v26 = v30;
      free(v84);
      v84 = 0;
      goto LABEL_8;
    }
    if (v83 != v52)
      krb5_abortx((_krb5_context *)a1, "internal error in ASN.1 encoder");
    *(_QWORD *)&v86 = 0;
    sub_2096BBAD0();
    *(_QWORD *)v46 = 0;
    v37 = krb5_sendto_ctx_alloc(a1, (uint64_t)v46, v31, v32, v33, v34, v35, v36);
    if ((_DWORD)v37)
      return v37;
    krb5_sendto_ctx_set_func(*(uint64_t *)v46, (uint64_t)sub_2096AB744, 0);
    if (a10)
      sub_2096AB528((_krb5_context *)a1, *(uint64_t *)v46, a10);
    if (a11)
      sub_2096AB56C((_krb5_context *)a1, *(uint64_t *)v46, a11);
    ImpersonateBundle = HeimCredGetImpersonateBundle();
    if (ImpersonateBundle)
    {
      v39 = (char *)ImpersonateBundle;
      MainBundle = CFBundleGetMainBundle();
      if (MainBundle)
      {
        Identifier = CFBundleGetIdentifier(MainBundle);
        v42 = CFStringCreateWithCString(0, v39, 0x8000100u);
        v43 = v42;
        if (v42 && Identifier)
        {
          if (CFEqual(Identifier, v42))
            sub_20969D1E8(a1, 5, "Bundle identifiers match, not setting delegate");
          else
            krb5_sendto_set_delegated_app(0, *(uint64_t *)v46, 0, 0, v39);
          goto LABEL_33;
        }
        if (v42)
LABEL_33:
          CFRelease(v43);
      }
    }
    v26 = krb5_sendto_context(a1, *(uint64_t *)v46, &v83, *(char **)(*(_QWORD *)(*(_QWORD *)(a7 + 8) + 16) + 8), &v82);
    krb5_sendto_ctx_free(a1, *(const void **)v46);
    if (!(_DWORD)v26)
    {
      v80 = 0u;
      v81 = 0u;
      v78 = 0u;
      v79 = 0u;
      v76 = 0u;
      v77 = 0u;
      v74 = 0u;
      v75 = 0u;
      v72 = 0u;
      v73 = 0u;
      v70 = 0u;
      v71 = 0u;
      v68 = 0u;
      v69 = 0u;
      v66 = 0u;
      v67 = 0u;
      v64 = 0u;
      v65 = 0u;
      v62 = 0u;
      v63 = 0u;
      v60 = 0u;
      v61 = 0u;
      v58 = 0u;
      v59 = 0u;
      v57 = 0u;
      if (sub_2096BBCDC())
      {
        if (krb5_rd_error((krb5_context)a1, &v82, (krb5_error **)v55))
        {
          if (*(_QWORD *)&v82.magic && *v82.data == 4)
          {
            krb5_clear_error_message((krb5_context)a1);
            v26 = 2529639131;
          }
          else
          {
            v26 = 2529638952;
            krb5_clear_error_message((krb5_context)a1);
          }
        }
        else
        {
          v26 = krb5_error_from_rd_error((krb5_context)a1, (uint64_t)v55, (uint64_t *)a6);
          krb5_free_error_contents(a1, (uint64_t)v55);
        }
      }
      else
      {
        *(_QWORD *)v46 = 0;
        v47 = 0;
        v26 = sub_2096B7B24((krb5_context)a1, v54, 0, v45, (uint64_t)&v57);
        if (!(_DWORD)v26)
        {
          v26 = krb5_copy_principal((krb5_context)a1, *(krb5_const_principal *)a6, a12);
          if (!(_DWORD)v26)
          {
            v26 = krb5_copy_principal((krb5_context)a1, *(krb5_const_principal *)(a6 + 8), a12 + 1);
            if (!(_DWORD)v26)
            {
              a12[7] = *(krb5_principal *)(a6 + 56);
              if (a8)
                v44 = 1;
              else
                v44 = BYTE2(a4) & 1;
              *(_QWORD *)v46 = v53;
              v47 = v45;
              v26 = sub_2096B1B94(a1, (uint64_t)&v57, (uint64_t)a12, (const krb5_keyblock *)(a7 + 16), 0, (krb5_address *const *)(a7 + 120), v54, v44, 0, (uint64_t (*)(_krb5_context *, const krb5_keyblock *, uint64_t, uint64_t, uint64_t))sub_20969B498, (uint64_t)v46);
            }
          }
        }
        krb5_free_kdc_rep(a1, &v57);
      }
    }
  }
LABEL_8:
  if (v20 == v50)
    free_Ticket();
  sub_2096BB9D4();
  krb5_data_free(&v82);
  krb5_data_free(&v83);
  if (v53)
    krb5_free_keyblock((krb5_context)a1, v53);
  return v26;
}

uint64_t sub_20968C474(uint64_t a1, unsigned int a2, krb5_ccache a3, uint64_t a4, __int128 *a5, __int128 *a6, _OWORD *a7, krb5_creds **a8, uint64_t **a9)
{
  char *v16;
  char *v17;
  char *v18;
  char *v19;
  uint64_t v20;
  unsigned int v21;
  BOOL v22;
  char *realm;
  uint64_t principal;
  uint64_t v25;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  uint64_t v31;
  krb5_creds *v32;
  uint64_t v33;
  BOOL v35;
  int v36;
  __int128 v37;
  uint64_t v38;
  char *v39;
  uint64_t *v40;
  uint64_t v41;
  BOOL v42;
  int v43;
  uint64_t v44;
  _OWORD *v45;
  __int128 *v46;
  krb5_data v48;
  uint64_t v49;
  _OWORD mcreds[3];
  _OWORD mcreds_48[6];
  _BYTE creds[128];
  __int128 v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  __int128 v61;
  __int128 v62;
  _BYTE v63[128];
  __int128 v64;

  *(_QWORD *)&v48.magic = 0;
  v48.data = 0;
  v49 = 0;
  v16 = 0;
  if (!krb5_cc_get_config((krb5_context)a1, a3, 0, "lkdc-hostname", &v48))
  {
    v17 = (char *)malloc_type_malloc(*(_QWORD *)&v48.magic + 1, 0xBB8C12A5uLL);
    if (!v17)
      goto LABEL_22;
    v16 = v17;
    memcpy(v17, v48.data, *(size_t *)&v48.magic);
    v16[*(_QWORD *)&v48.magic] = 0;
    krb5_data_free(&v48);
  }
  v18 = 0;
  if (krb5_cc_get_config((krb5_context)a1, a3, 0, "sitename", &v48))
    goto LABEL_7;
  v19 = (char *)malloc_type_malloc(*(_QWORD *)&v48.magic + 1, 0xDCCAADA9uLL);
  if (!v19)
  {
LABEL_22:
    v25 = 12;
    krb5_set_error_message((krb5_context)a1, 12, "malloc: out of memory");
    return v25;
  }
  v18 = v19;
  memcpy(v19, v48.data, *(size_t *)&v48.magic);
  v18[*(_QWORD *)&v48.magic] = 0;
  krb5_data_free(&v48);
LABEL_7:
  v44 = a4;
  if (!krb5_cc_get_kdc_offset(a1, (uint64_t)a3, &v49))
    *(_QWORD *)(a1 + 108) = v49;
  v20 = *((_QWORD *)a5 + 1);
  v21 = *(_DWORD *)(v20 + 8);
  v22 = v21 <= 1 && (a2 & 0x8000) == 0;
  v45 = a7;
  v46 = a6;
  if (v22)
  {
    v25 = 2529638940;
    krb5_set_error_message((krb5_context)a1, -1765328356, "Name too short to do referals, skipping referals");
    goto LABEL_18;
  }
  if (v21 && !strcmp(**(const char ***)(v20 + 16), "kadmin"))
  {
    v25 = 2529638940;
    krb5_set_error_message((krb5_context)a1, -1765328356, "Name[0] is kadmin, skipping referrals");
  }
  else
  {
    v64 = 0u;
    memset(v63, 0, sizeof(v63));
    memset(creds, 0, sizeof(creds));
    v53 = 0u;
    *a8 = 0;
    realm = (char *)krb5_principal_get_realm(a1, *(_QWORD *)a5);
    *(_QWORD *)&v54 = 0;
    principal = krb5_make_principal((krb5_context)a1, &v54, realm, "krbtgt", realm, 0);
    if ((_DWORD)principal)
    {
      v25 = principal;
      goto LABEL_18;
    }
    v25 = sub_20968D844((_krb5_context *)a1, a3, (const krb5_principal_data *)v54, *a9, (krb5_creds *)v63);
    krb5_free_principal((krb5_context)a1, (krb5_principal)v54);
    if (!(_DWORD)v25)
    {
      v27 = a5[7];
      v60 = a5[6];
      v61 = v27;
      v62 = a5[8];
      v28 = a5[3];
      v56 = a5[2];
      v57 = v28;
      v29 = a5[5];
      v58 = a5[4];
      v59 = v29;
      v30 = a5[1];
      v54 = *a5;
      v55 = v30;
      v31 = krb5_copy_principal((krb5_context)a1, (krb5_const_principal)v20, (krb5_principal *)&v54 + 1);
      if ((_DWORD)v31)
      {
        v25 = v31;
        v32 = (krb5_creds *)v63;
LABEL_27:
        krb5_free_cred_contents((krb5_context)a1, v32);
        goto LABEL_18;
      }
      v33 = krb5_principal_set_realm((_krb5_context *)a1, *((uint64_t *)&v54 + 1), realm);
      if (!(_DWORD)v33)
      {
        v35 = (a2 & 0x10000) == 0 && v46 != 0;
        v36 = 1;
        v37 = 0uLL;
        v43 = 1;
        v42 = v35;
        while (1)
        {
          mcreds_48[4] = v37;
          mcreds_48[5] = v37;
          mcreds_48[2] = v37;
          mcreds_48[3] = v37;
          mcreds_48[0] = v37;
          mcreds_48[1] = v37;
          mcreds[1] = v37;
          mcreds[2] = v37;
          mcreds[0] = v37;
          if (v35
            || (krb5_cc_clear_mcred(mcreds),
                *((_QWORD *)&mcreds[0] + 1) = *((_QWORD *)&v54 + 1),
                krb5_timeofday((krb5_context)a1, (krb5_timestamp *)mcreds_48 + 2),
                krb5_cc_retrieve_cred((krb5_context)a1, a3, 0x2000000, (krb5_creds *)mcreds, (krb5_creds *)creds)))
          {
            v38 = sub_20968D92C((krb5_context)a1, (uint64_t)a3, v44, a2 | 0x8000, (uint64_t)&v54, (uint64_t)v63, v46, v45, v16, v18, (krb5_principal *)creds);
            if ((_DWORD)v38)
              goto LABEL_55;
          }
          if (krb5_principal_compare_any_realm(a1, *((uint64_t *)&v54 + 1), *(uint64_t *)&creds[8]))
            goto LABEL_54;
          if (!krb5_principal_is_krbtgt(a1, *(uint64_t *)&creds[8]))
            break;
          v39 = *(char **)(*(_QWORD *)(*(_QWORD *)&creds[8] + 16) + 8);
          v40 = *a9;
          krb5_cc_clear_mcred(mcreds);
          *((_QWORD *)&mcreds[0] + 1) = *(_QWORD *)&creds[8];
          if (v40)
          {
            while (1)
            {
              v41 = *v40;
              if (!*v40)
                break;
              ++v40;
              if (krb5_compare_creds((krb5_context)a1, 0x80000000, (uint64_t)mcreds, v41))
              {
                v25 = 2529639135;
                krb5_set_error_message((krb5_context)a1, -1765328161, "Referral from %s loops back to realm %s");
                goto LABEL_56;
              }
            }
          }
          if (v43 && (WORD4(v53) & 0x2000) != 0)
          {
            v43 = 1;
          }
          else
          {
            v43 = 0;
            DWORD2(v53) &= ~0x2000u;
          }
          v38 = sub_20968DA38((_krb5_context *)a1, (const krb5_creds *)creds, (void **)a9);
          if ((_DWORD)v38)
            goto LABEL_55;
          v25 = krb5_principal_set_realm((_krb5_context *)a1, *((uint64_t *)&v54 + 1), v39);
          krb5_free_cred_contents((krb5_context)a1, (krb5_creds *)v63);
          *(_OWORD *)&v63[96] = *(_OWORD *)&creds[96];
          *(_OWORD *)&v63[112] = *(_OWORD *)&creds[112];
          v64 = v53;
          *(_OWORD *)&v63[32] = *(_OWORD *)&creds[32];
          *(_OWORD *)&v63[48] = *(_OWORD *)&creds[48];
          *(_OWORD *)&v63[64] = *(_OWORD *)&creds[64];
          *(_OWORD *)&v63[80] = *(_OWORD *)&creds[80];
          *(_OWORD *)v63 = *(_OWORD *)creds;
          *(_OWORD *)&v63[16] = *(_OWORD *)&creds[16];
          v37 = 0uLL;
          v53 = 0u;
          memset(creds, 0, sizeof(creds));
          if ((_DWORD)v25)
            goto LABEL_56;
          ++v36;
          v35 = v42;
          if (v36 == 18)
          {
LABEL_54:
            v38 = krb5_copy_creds((krb5_context)a1, (const krb5_creds *)creds, a8);
LABEL_55:
            v25 = v38;
            goto LABEL_56;
          }
        }
        v25 = 2529638947;
        krb5_set_error_message((krb5_context)a1, -1765328349, "Got back an non krbtgt ticket referrals");
LABEL_56:
        krb5_free_principal((krb5_context)a1, *((krb5_principal *)&v54 + 1));
        krb5_free_cred_contents((krb5_context)a1, (krb5_creds *)v63);
        v32 = (krb5_creds *)creds;
        goto LABEL_27;
      }
      v25 = v33;
      krb5_free_cred_contents((krb5_context)a1, (krb5_creds *)v63);
      krb5_free_principal((krb5_context)a1, *((krb5_principal *)&v54 + 1));
    }
  }
LABEL_18:
  if ((_DWORD)v25 && (a2 & 0x8000) == 0)
    v25 = sub_20968CA0C((_krb5_context *)a1, a2, a3, v44, (uint64_t *)a5, v46, v45, v16, v18, a8, a9);
  free(v16);
  free(v18);
  return v25;
}

uint64_t sub_20968CA0C(_krb5_context *a1, unsigned int a2, _krb5_ccache *a3, uint64_t a4, uint64_t *a5, __int128 *a6, _OWORD *a7, char *a8, char *a9, krb5_creds **a10, uint64_t **a11)
{
  char *realm;
  uint64_t result;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  const char *string;
  char *v27;
  int v28;

  realm = (char *)krb5_principal_get_realm((uint64_t)a1, *a5);
  krb5_principal_get_realm((uint64_t)a1, a5[1]);
  result = sub_20968DAEC(a1, a2, a3, a4, a5, realm, a6, a7, a8, a9, a10, a11);
  if ((_DWORD)result == -1765328377)
  {
    string = (const char *)krb5_config_get_string((uint64_t)a1, 0, v20, v21, v22, v23, v24, v25, (uint64_t)"capaths");
    if (string)
    {
      v27 = (char *)string;
      v28 = strcmp(string, realm);
      result = 2529638919;
      if (v28)
        return sub_20968DAEC(a1, a2, a3, a4, a5, v27, a6, a7, a8, a9, a10, a11);
    }
    else
    {
      return 2529638919;
    }
  }
  return result;
}

uint64_t krb5_get_credentials_with_flags(uint64_t a1, krb5_flags a2, int a3, _krb5_ccache *a4, uint64_t a5, krb5_creds **a6)
{
  char *v12;
  uint64_t v13;
  krb5_creds *v14;
  krb5_creds *v15;
  uint64_t cred;
  int v17;
  char *v18;
  unsigned int v19;
  int v20;
  char *v21;
  krb5_creds *v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  krb5_data second_ticket;
  krb5_data ticket;
  uint64_t v29;
  uint64_t v30;
  _QWORD *v31;
  uint64_t v32;
  time_t v33;
  char *v34;
  unint64_t v36;
  _QWORD *v37;
  uint64_t v38;
  uint64_t v39;
  unint64_t v40;
  unint64_t v41;
  BOOL v42;
  unint64_t v43;
  unint64_t v44;
  const char *v45;
  char *v46;
  unint64_t v47;
  void *v48[2];
  uint64_t v49;
  const char *v50;
  krb5_timestamp v51[4];
  __int128 v52;
  __int128 v53;
  krb5_ticket_times times;
  __int128 v55;
  krb5_data v56;
  krb5_data v57;
  __int128 v58;
  __int128 v59;
  unsigned int v60;
  uint64_t v61;
  char *v62;
  timeval v63;
  timeval v64;

  v64.tv_sec = 0;
  *(_QWORD *)&v64.tv_usec = 0;
  v63.tv_sec = 0;
  *(_QWORD *)&v63.tv_usec = 0;
  gettimeofday(&v64, 0);
  v12 = (char *)*(unsigned int *)(a5 + 16);
  if ((_DWORD)v12)
  {
    v13 = krb5_enctype_valid((_krb5_context *)a1, v12);
    if ((_DWORD)v13)
      return v13;
  }
  *a6 = 0;
  v14 = (krb5_creds *)malloc_type_calloc(1uLL, 0x90uLL, 0x10A0040AAA52FDDuLL);
  if (!v14)
  {
    v13 = 12;
    krb5_set_error_message((krb5_context)a1, 12, "malloc: out of memory");
    return v13;
  }
  v15 = v14;
  if (*(_DWORD *)(a5 + 16))
    a2 |= 0x40000000u;
  cred = krb5_cc_retrieve_cred((krb5_context)a1, a4, a2, (krb5_creds *)a5, v14);
  if ((_DWORD)cred)
  {
    v13 = cred;
    if ((_DWORD)cred != -1765328243)
    {
      v18 = (char *)v15;
LABEL_16:
      free(v18);
      return v13;
    }
    v17 = a2 & 1;
  }
  else
  {
    *(_QWORD *)v51 = 0;
    if ((a2 & 4) != 0 || (krb5_timeofday((krb5_context)a1, v51), *(_QWORD *)&v15->times.endtime > *(uint64_t *)v51))
    {
      v13 = 0;
      *a6 = v15;
      return v13;
    }
    v17 = a2 & 1;
    if ((a2 & 1) != 0)
      krb5_cc_remove_cred((krb5_context)a1, a4, 0, v15);
    krb5_free_cred_contents((krb5_context)a1, v15);
  }
  free(v15);
  if (v17)
  {
    v13 = 2529639053;
    sub_20968D078((_krb5_context *)a1, *(const krb5_principal_data **)(a5 + 8));
    return v13;
  }
  if ((a2 & 0x40000000) != 0)
    goto LABEL_20;
  if (!*(_QWORD *)(a1 + 352))
    goto LABEL_20;
  memset(v51, 0, sizeof(v51));
  if (krb5_cc_get_config((krb5_context)a1, a4, *(krb5_const_principal *)(a5 + 8), "negative-cache", (krb5_data *)v51))
    goto LABEL_20;
  v61 = 0;
  v36 = time(0);
  v60 = -1765328243;
  v48[0] = 0;
  v37 = krb5_storage_from_data((uint64_t *)v51);
  if (!v37)
  {
    krb5_data_free(v51);
    return 12;
  }
  v38 = (uint64_t)v37;
  v39 = krb5_ret_uint32((uint64_t)v37, (_DWORD *)&v61 + 1);
  if ((_DWORD)v39 || (v39 = krb5_ret_int32(v38, &v60), (_DWORD)v39))
  {
    v13 = v39;
    v40 = v36;
  }
  else
  {
    v13 = krb5_ret_string(v38, v48);
    v40 = v36;
    if (!(_DWORD)v13)
    {
      if (krb5_ret_uint32(v38, &v61))
      {
        v47 = 0;
        LODWORD(v61) = 0;
      }
      else
      {
        v47 = (unint64_t)v61 << 32;
      }
      v13 = 0;
      v40 = v47 | HIDWORD(v61);
    }
  }
  v41 = v40 - v36;
  v42 = v36 >= v40;
  v43 = v36 - v40;
  if (v43 != 0 && v42)
    v44 = v43;
  else
    v44 = v41;
  krb5_storage_free(v38);
  krb5_data_free(v51);
  if ((_DWORD)v13)
  {
    v18 = (char *)v48[0];
    goto LABEL_16;
  }
  if (v44 < *(_QWORD *)(a1 + 352))
  {
    v62 = 0;
    v13 = v60;
    krb5_unparse_name((krb5_context)a1, *(krb5_const_principal *)(a5 + 8), &v62);
    v45 = (const char *)v48[0];
    if (!v48[0])
      v45 = "<no cached error string>";
    v46 = v62;
    if (!v62)
      v46 = "unknown";
    krb5_set_error_message((krb5_context)a1, v13, "%s while looking up '%s' (cached result, timeout in %lld sec)", v45, v46, *(_QWORD *)(a1 + 352) - v44);
    free(v48[0]);
    v18 = v62;
    goto LABEL_16;
  }
  free(v48[0]);
LABEL_20:
  v19 = (a2 << 27) & 0x10000000 | a3;
  v20 = a2 | (v19 >> 25);
  v62 = 0;
  v13 = sub_20968C474(a1, v19, a4, 0, (__int128 *)a5, 0, 0, a6, (uint64_t **)&v62);
  v21 = v62;
  if (v62)
  {
    sub_20968D0E0((_krb5_context *)a1, a4, (krb5_creds **)v62);
    free(v21);
  }
  if (v13 | v20 & 8)
  {
    if ((a2 & 0x40000000) == 0 && (v13 & 0xFFFFFFFE) == 0x96C73A06)
    {
      v31 = krb5_storage_emem();
      memset(v51, 0, sizeof(v51));
      if (v31)
      {
        v32 = (uint64_t)v31;
        v33 = time(0);
        krb5_store_uint32(v32, v33);
        krb5_store_int32(v32, v13);
        if (*(_DWORD *)(a1 + 288) == (_DWORD)v13)
        {
          v34 = *(char **)(a1 + 280);
          if (v34)
            krb5_store_string(v32, v34);
        }
        if (!krb5_storage_to_data(v32, (size_t *)v51))
        {
          krb5_cc_set_config((krb5_context)a1, a4, *(krb5_const_principal *)(a5 + 8), "negative-cache", (krb5_data *)v51);
          krb5_data_free(v51);
        }
        krb5_storage_free(v32);
      }
    }
  }
  else
  {
    krb5_cc_store_cred((krb5_context)a1, a4, *a6);
    if (!krb5_principal_compare_any_realm(a1, (uint64_t)(*a6)->client, *(_QWORD *)(a5 + 8)))
    {
      v22 = *a6;
      *(_OWORD *)v51 = *(_OWORD *)&(*a6)->magic;
      v23 = *(_OWORD *)&v22->is_skey;
      v25 = *(_OWORD *)&v22->server;
      v24 = *(_OWORD *)&v22->keyblock.length;
      times = v22->times;
      v55 = v23;
      v52 = v25;
      v53 = v24;
      v26 = *(_OWORD *)&v22[1].client;
      ticket = v22->ticket;
      second_ticket = v22->second_ticket;
      v58 = *(_OWORD *)&v22->authdata;
      v59 = v26;
      v56 = ticket;
      v57 = second_ticket;
      v29 = *(_QWORD *)(a5 + 8);
      v30 = *(_QWORD *)(v29 + 16);
      *(_OWORD *)v48 = *(_OWORD *)v29;
      v49 = v30;
      v50 = "";
      *(_QWORD *)&v51[2] = v48;
      krb5_cc_store_cred((krb5_context)a1, a4, (krb5_creds *)v51);
    }
  }
  gettimeofday(&v63, 0);
  sub_2096D4088((uint64_t)&v63, (uint64_t)&v64);
  sub_20969D1E8(a1, 1, "krb5_get_credentials_with_flags: %s wc: %lld.%06d", *(const char **)(*(_QWORD *)a5 + 24), v63.tv_sec, v63.tv_usec);
  return v13;
}

void sub_20968D078(_krb5_context *a1, const krb5_principal_data *a2)
{
  char *v3;

  v3 = 0;
  if (krb5_unparse_name(a1, a2, &v3))
  {
    krb5_clear_error_message(a1);
  }
  else
  {
    krb5_set_error_message(a1, -1765328243, "Matching credential (%s) not found", v3);
    free(v3);
  }
}

void sub_20968D0E0(_krb5_context *a1, _krb5_ccache *a2, krb5_creds **a3)
{
  krb5_creds *v3;
  krb5_creds **v7;
  uint64_t client;
  krb5_creds *v9;
  krb5_creds *v10;
  krb5_creds **v11;
  krb5_creds *v12;

  v3 = *a3;
  if (*a3)
  {
    v7 = a3 + 1;
    do
    {
      client = (uint64_t)v3->client;
      if (krb5_principal_is_krbtgt((uint64_t)a1, client)
        && strcmp(*(const char **)(*(_QWORD *)(client + 16) + 8), *(const char **)(client + 24)))
      {
        krb5_cc_store_cred(a1, a2, *(v7 - 1));
      }
      v9 = *v7++;
      v3 = v9;
    }
    while (v9);
    v10 = *a3;
    if (*a3)
    {
      v11 = a3 + 1;
      do
      {
        krb5_free_creds(a1, v10);
        v12 = *v11++;
        v10 = v12;
      }
      while (v12);
    }
  }
}

uint64_t krb5_get_creds_opt_alloc(_krb5_context *a1, _QWORD *a2)
{
  void *v4;
  uint64_t v5;

  v4 = malloc_type_calloc(1uLL, 0x18uLL, 0x102004014030ADEuLL);
  *a2 = v4;
  if (v4)
    return 0;
  v5 = 12;
  krb5_set_error_message(a1, 12, "malloc: out of memory");
  return v5;
}

void krb5_get_creds_opt_free(_krb5_context *a1, void **a2)
{
  krb5_principal_data *v3;

  v3 = (krb5_principal_data *)*a2;
  if (v3)
    krb5_free_principal(a1, v3);
  if (a2[2])
  {
    free_Ticket();
    free(a2[2]);
  }
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  free(a2);
}

void krb5_get_creds_opt_set_options(uint64_t a1, uint64_t a2, int a3)
{
  *(_DWORD *)(a2 + 8) = a3;
}

void krb5_get_creds_opt_add_options(uint64_t a1, uint64_t a2, int a3)
{
  *(_DWORD *)(a2 + 8) |= a3;
}

void krb5_get_creds_opt_set_enctype(uint64_t a1, uint64_t a2, int a3)
{
  *(_DWORD *)(a2 + 12) = a3;
}

uint64_t krb5_get_creds_opt_set_impersonate(krb5_context a1, krb5_principal *a2, krb5_const_principal a3)
{
  krb5_principal_data *v6;

  v6 = *a2;
  if (v6)
    krb5_free_principal(a1, v6);
  return krb5_copy_principal(a1, a3, a2);
}

uint64_t krb5_get_creds_opt_set_ticket(_krb5_context *a1, uint64_t a2, uint64_t a3)
{
  void *v6;

  if (*(_QWORD *)(a2 + 16))
  {
    free_Ticket();
    free(*(void **)(a2 + 16));
    *(_QWORD *)(a2 + 16) = 0;
  }
  if (a3)
  {
    v6 = malloc_type_malloc(0x48uLL, 0x1090040DEC7D988uLL);
    *(_QWORD *)(a2 + 16) = v6;
    if (!v6)
    {
      a3 = 12;
      goto LABEL_8;
    }
    a3 = sub_2096BB814();
    if ((_DWORD)a3)
    {
      free(*(void **)(a2 + 16));
      *(_QWORD *)(a2 + 16) = 0;
LABEL_8:
      krb5_set_error_message(a1, a3, "malloc: out of memory");
    }
  }
  return a3;
}

uint64_t krb5_get_creds(_krb5_context *a1, uint64_t a2, _krb5_ccache *a3, const krb5_principal_data *a4, krb5_creds **a5)
{
  __int128 v10;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  unsigned int v15;
  krb5_creds *v16;
  krb5_creds *v17;
  krb5_creds *v18;
  uint64_t cred;
  int v20;
  __int128 *v21;
  void *v22;
  krb5_timestamp v24[2];
  krb5_principal principal[2];
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  _BYTE v34[80];
  uint64_t v35;

  v10 = 0uLL;
  memset(v34, 0, sizeof(v34));
  v35 = 0;
  if (!a2
    || (v11 = (char *)*(unsigned int *)(a2 + 12), !(_DWORD)v11)
    || (v12 = krb5_enctype_valid(a1, v11), v10 = 0uLL, v13 = v12, !(_DWORD)v12))
  {
    v33 = v10;
    v31 = v10;
    v32 = v10;
    v29 = v10;
    v30 = v10;
    v27 = v10;
    v28 = v10;
    principal[0] = (krb5_principal)v10;
    v26 = v10;
    principal[1] = (krb5_principal)a4;
    if (_krb5_have_debug((_BOOL8)a1))
    {
      *(_QWORD *)v24 = 0;
      if (!krb5_unparse_name(a1, a4, (char **)v24))
      {
        if (a2)
          v14 = *(_DWORD *)(a2 + 8);
        else
          v14 = 0;
        sub_20969D1E8((uint64_t)a1, 5, "krb5_get_creds: %s: opt: %d", *(const char **)v24, v14);
        krb5_xfree(*(void **)v24);
      }
    }
    v13 = krb5_cc_get_principal(a1, a3, principal);
    if (!(_DWORD)v13)
    {
      if (a2)
      {
        v15 = *(_DWORD *)(a2 + 8);
        *a5 = 0;
        v16 = (krb5_creds *)malloc_type_calloc(1uLL, 0x90uLL, 0x10A0040AAA52FDDuLL);
        if (v16)
        {
          v17 = v16;
          if (*(_DWORD *)(a2 + 12))
          {
            LODWORD(v26) = *(_DWORD *)(a2 + 12);
            v15 |= 0x40000000u;
          }
LABEL_17:
          cred = krb5_cc_retrieve_cred(a1, a3, v15 & 0x40000000, (krb5_creds *)principal, v17);
          if ((_DWORD)cred)
          {
            v13 = cred;
            if ((_DWORD)cred != -1765328243)
            {
              free(v17);
              krb5_free_principal(a1, principal[0]);
              goto LABEL_36;
            }
            v20 = v15 & 1;
          }
          else
          {
            *(_QWORD *)v24 = 0;
            if ((v15 & 4) != 0 || (krb5_timeofday(a1, v24), *(_QWORD *)&v17->times.endtime > *(uint64_t *)v24))
            {
              *a5 = v17;
              krb5_free_principal(a1, principal[0]);
              goto LABEL_26;
            }
            v20 = v15 & 1;
            if ((v15 & 1) != 0)
              krb5_cc_remove_cred(a1, a3, 0, v17);
          }
          free(v17);
          if (v20)
          {
            krb5_free_principal(a1, principal[0]);
            sub_20968D078(a1, principal[1]);
            v13 = 2529639053;
LABEL_36:
            sub_2096B7CE0(a1, (uint64_t)v34);
            sub_20969D1E8((uint64_t)a1, 5, "krb5_get_creds: ret = %d", v13);
            return v13;
          }
          *(_QWORD *)v24 = 0;
          if (a2)
            v21 = *(__int128 **)a2;
          else
            v21 = 0;
          v13 = sub_20968C474((uint64_t)a1, (v15 >> 3) & 2 | ((((v15 & 2) >> 1) & 1) << 28) | (((v15 >> 5) & 1) << 26) | (((v15 >> 6) & 1) << 16) | (((v15 >> 7) & 1) << 15), a3, (uint64_t)v34, (__int128 *)principal, v21, *(_OWORD **)(a2 + 16), a5, (uint64_t **)v24);
          krb5_free_principal(a1, principal[0]);
          v22 = *(void **)v24;
          if (*(_QWORD *)v24)
          {
            sub_20968D0E0(a1, a3, *(krb5_creds ***)v24);
            free(v22);
          }
          if ((_DWORD)v13)
            goto LABEL_36;
          if (!((4 * (v15 & 2)) | v15 & 8))
            krb5_cc_store_cred(a1, a3, *a5);
LABEL_26:
          v13 = 0;
          goto LABEL_36;
        }
      }
      else
      {
        *a5 = 0;
        v18 = (krb5_creds *)malloc_type_calloc(1uLL, 0x90uLL, 0x10A0040AAA52FDDuLL);
        if (v18)
        {
          v17 = v18;
          v15 = 0;
          goto LABEL_17;
        }
      }
      krb5_free_principal(a1, principal[0]);
      v13 = 12;
      krb5_set_error_message(a1, 12, "malloc: out of memory");
    }
  }
  return v13;
}

krb5_error_code krb5_get_renewed_creds(krb5_context context, krb5_creds *creds, krb5_principal client, krb5_ccache ccache, char *in_tkt_service)
{
  krb5_error_code kdc_cred;
  krb5_error_code principal;
  char *realm;
  uint64_t v13;
  int v14;
  krb5_creds *v15;
  uint64_t v17;
  krb5_creds *v18;
  krb5_principal v19[2];
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;

  v17 = 0;
  v18 = 0;
  *(_OWORD *)v19 = 0u;
  v20 = 0u;
  v21 = 0u;
  v22 = 0u;
  v23 = 0u;
  v24 = 0u;
  v25 = 0u;
  v26 = 0u;
  v27 = 0u;
  *(_OWORD *)&creds->magic = 0u;
  *(_OWORD *)&creds->server = 0u;
  *(_OWORD *)&creds->keyblock.length = 0u;
  creds->times = 0u;
  *(_OWORD *)&creds->is_skey = 0u;
  creds->ticket = 0u;
  creds->second_ticket = 0u;
  *(_OWORD *)&creds->authdata = 0u;
  *(_OWORD *)&creds[1].client = 0u;
  kdc_cred = krb5_copy_principal(context, client, v19);
  if (!kdc_cred)
  {
    if (in_tkt_service)
    {
      principal = krb5_parse_name(context, in_tkt_service, &v19[1]);
      if (principal)
      {
LABEL_4:
        kdc_cred = principal;
        krb5_free_principal(context, v19[0]);
        return kdc_cred;
      }
    }
    else
    {
      realm = (char *)krb5_principal_get_realm((uint64_t)context, (uint64_t)client);
      principal = krb5_make_principal(context, &v19[1], realm, "krbtgt", realm, 0);
      if (principal)
        goto LABEL_4;
    }
    if (krb5_get_credentials_with_flags((uint64_t)context, 1, 0, ccache, (uint64_t)v19, &v18))
    {
      v14 = 1073742080;
    }
    else
    {
      v14 = (uint64_t)v18[1].server & 0xA | 0x40000100;
      krb5_free_creds(context, v18);
    }
    kdc_cred = krb5_get_kdc_cred(context, ccache, v14, 0, v13, (uint64_t)v19, (void **)&v17);
    krb5_free_principal(context, v19[0]);
    krb5_free_principal(context, v19[1]);
    if (!kdc_cred)
    {
      v15 = (krb5_creds *)v17;
      kdc_cred = krb5_copy_creds_contents(context, v17, (uint64_t)creds);
      krb5_free_creds(context, v15);
    }
  }
  return kdc_cred;
}

uint64_t sub_20968D844(_krb5_context *a1, _krb5_ccache *a2, const krb5_principal_data *a3, uint64_t *a4, krb5_creds *a5)
{
  uint64_t result;
  uint64_t v11;
  uint64_t *v12;
  uint64_t v13;
  _BYTE v14[144];

  memset(v14, 0, sizeof(v14));
  krb5_cc_clear_mcred(v14);
  *(_QWORD *)&v14[8] = a3;
  krb5_timeofday(a1, (krb5_timestamp *)&v14[56]);
  result = krb5_cc_retrieve_cred(a1, a2, -2113929216, (krb5_creds *)v14, a5);
  if ((_DWORD)result)
  {
    if (a4 && (v11 = *a4) != 0)
    {
      v12 = a4 + 1;
      while (!krb5_compare_creds(a1, 0x80000000, (uint64_t)v14, v11))
      {
        v13 = *v12++;
        v11 = v13;
        if (!v13)
          goto LABEL_7;
      }
      return krb5_copy_creds_contents(a1, *(v12 - 1), (uint64_t)a5);
    }
    else
    {
LABEL_7:
      sub_20968D078(a1, a3);
      return 2529639053;
    }
  }
  return result;
}

uint64_t sub_20968D92C(krb5_context context, uint64_t a2, uint64_t a3, int a4, uint64_t a5, uint64_t a6, __int128 *a7, _OWORD *a8, char *a9, char *a10, krb5_principal *a11)
{
  __int128 *v12;
  krb5_address **v19;
  uint64_t v20;
  int ret_value;
  krb5_address *v24[2];

  v12 = a7;
  v24[0] = 0;
  v24[1] = 0;
  if (*(_DWORD *)(a6 + 120))
  {
    ret_value = 0;
    krb5_appdefault_BOOLean(context, 0, *(const krb5_data **)(*(_QWORD *)(a6 + 8) + 24), "no-addresses", 0, &ret_value);
    v19 = 0;
    if (!ret_value)
    {
      krb5_get_all_client_addrs(context, (uint64_t)v24);
      if (LODWORD(v24[0]))
        v19 = v24;
      else
        v19 = 0;
    }
    v12 = a7;
  }
  else
  {
    v19 = 0;
  }
  v20 = sub_20968BF44((uint64_t)context, a2, a3, a4, (uint64_t)v19, a5, a6, v12, a8, a9, a10, a11);
  krb5_free_addresses(context, v24);
  return v20;
}

uint64_t sub_20968DA38(_krb5_context *a1, const krb5_creds *a2, void **a3)
{
  unsigned int v6;
  uint64_t *v7;
  uint64_t v8;
  _QWORD *v9;
  _QWORD *v10;
  uint64_t result;

  if (*a3)
  {
    v6 = -1;
    v7 = (uint64_t *)*a3;
    do
    {
      v8 = *v7++;
      ++v6;
    }
    while (v8);
  }
  else
  {
    v6 = 0;
  }
  v9 = malloc_type_realloc(*a3, 8 * (v6 + 2), 0x2004093837F09uLL);
  if (v9)
  {
    v10 = v9;
    *a3 = v9;
    result = krb5_copy_creds(a1, a2, (krb5_creds **)&v9[v6]);
    v10[v6 + 1] = 0;
  }
  else
  {
    krb5_set_error_message(a1, 12, "malloc: out of memory");
    return 12;
  }
  return result;
}

uint64_t sub_20968DAEC(_krb5_context *a1, unsigned int a2, _krb5_ccache *a3, uint64_t a4, uint64_t *a5, char *a6, __int128 *a7, _OWORD *a8, char *a9, char *a10, krb5_creds **a11, uint64_t **a12)
{
  const char *realm;
  const char *v19;
  uint64_t v20;
  uint64_t principal;
  uint64_t v22;
  char *v23;
  int v24;
  krb5_principal *v25;
  uint64_t *v26;
  int v27;
  uint64_t v28;
  const krb5_creds *v29;
  int server;
  char *v31;
  int v32;
  krb5_principal *v33;
  krb5_creds *v34;
  char *v36;
  uint64_t v37;
  _BYTE v40[128];
  __int128 v41;
  krb5_principal v42[2];
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  krb5_creds *v51;

  v51 = 0;
  *a11 = 0;
  realm = (const char *)krb5_principal_get_realm((uint64_t)a1, *a5);
  v19 = (const char *)krb5_principal_get_realm((uint64_t)a1, a5[1]);
  *(_OWORD *)v42 = 0u;
  v43 = 0u;
  v44 = 0u;
  v45 = 0u;
  v46 = 0u;
  v47 = 0u;
  v48 = 0u;
  v49 = 0u;
  v50 = 0u;
  v20 = krb5_copy_principal(a1, (krb5_const_principal)*a5, v42);
  if ((_DWORD)v20)
    return v20;
  v37 = a4;
  principal = krb5_make_principal(a1, &v42[1], a6, "krbtgt", v19, 0);
  if ((_DWORD)principal)
  {
    v20 = principal;
LABEL_36:
    krb5_free_principal(a1, v42[0]);
    return v20;
  }
  v36 = (char *)v19;
  v41 = 0u;
  memset(v40, 0, sizeof(v40));
  v22 = (uint64_t)a3;
  if (!sub_20968D844(a1, a3, v42[1], *a12, (krb5_creds *)v40))
  {
    if (!strcmp(a6, realm) && !strcmp(a6, v19))
    {
      v23 = a9;
      v24 = 1;
    }
    else
    {
      v23 = a9;
      v24 = (DWORD2(v41) >> 13) & 1;
    }
    v25 = (krb5_principal *)malloc_type_calloc(1uLL, 0x90uLL, 0x10A0040AAA52FDDuLL);
    *a11 = (krb5_creds *)v25;
    if (!v25)
    {
      v20 = 12;
      krb5_set_error_message(a1, 12, "malloc: out of memory");
      goto LABEL_34;
    }
    v20 = sub_20968D92C(a1, (uint64_t)a3, v37, a2, (uint64_t)a5, (uint64_t)v40, a7, a8, v23, a10, v25);
    v26 = (uint64_t *)*a11;
    if ((_DWORD)v20)
    {
      free(v26);
    }
    else
    {
      if (krb5_principal_compare_any_realm((uint64_t)a1, v26[1], a5[1]) == 1)
      {
        v20 = 0;
        if (!v24)
          LODWORD((*a11)[1].server) &= ~0x2000u;
LABEL_34:
        krb5_free_cred_contents(a1, (krb5_creds *)v40);
LABEL_35:
        krb5_free_principal(a1, v42[1]);
        goto LABEL_36;
      }
      v20 = 2529638919;
      krb5_free_creds(a1, *a11);
    }
    *a11 = 0;
    goto LABEL_34;
  }
  if (krb5_realm_compare(a1, (krb5_const_principal)*a5, (krb5_const_principal)a5[1]))
  {
    sub_20968D078(a1, (const krb5_principal_data *)a5[1]);
    return 2529639053;
  }
  v27 = 1;
  while (1)
  {
    v28 = sub_20968CA0C(a1, a2, v22, v37, v42, 0, 0, a9, a10, &v51, a12);
    if ((_DWORD)v28
      || ((v29 = v51, server = (int)v51[1].server, !v27) || (server & 0x2000) == 0
        ? (v27 = 0, LODWORD(v51[1].server) = server & 0xFFFFDFFF)
        : (v27 = 1),
          v28 = sub_20968DA38(a1, v29, (void **)a12),
          (_DWORD)v28))
    {
LABEL_23:
      v20 = v28;
      goto LABEL_35;
    }
    v31 = (char *)*((_QWORD *)v51->client->realm.data + 1);
    v32 = strcmp(v31, v36);
    krb5_free_principal(a1, v42[1]);
    if (!v32)
      break;
    v28 = krb5_make_principal(a1, &v42[1], v31, "krbtgt", v36, 0);
    if (!(_DWORD)v28)
    {
      krb5_free_creds(a1, v51);
      if (!(_DWORD)v28)
        continue;
    }
    goto LABEL_23;
  }
  krb5_free_principal(a1, v42[0]);
  v33 = (krb5_principal *)malloc_type_calloc(1uLL, 0x90uLL, 0x10A0040AAA52FDDuLL);
  *a11 = (krb5_creds *)v33;
  if (!v33)
  {
    v20 = 12;
    krb5_set_error_message(a1, 12, "malloc: out of memory");
    goto LABEL_43;
  }
  v20 = sub_20968D92C(a1, v22, v37, a2, (uint64_t)a5, (uint64_t)v51, a7, a8, a9, a10, v33);
  v34 = *a11;
  if ((_DWORD)v20)
  {
    free(v34);
  }
  else
  {
    if (krb5_principal_compare_any_realm((uint64_t)a1, (uint64_t)v34->client, a5[1]) == 1)
    {
      v20 = 0;
      goto LABEL_43;
    }
    v20 = 2529638919;
    krb5_free_creds(a1, *a11);
  }
  *a11 = 0;
LABEL_43:
  if (v51)
    krb5_free_creds(a1, v51);
  return v20;
}

uint64_t sub_20968DF68(_krb5_context *a1, _QWORD *a2)
{
  uid_t v4;
  passwd *v5;
  char *pw_name;
  char *v7;

  *a2 = 0;
  v4 = getuid();
  if (v4)
  {
    v5 = getpwuid(v4);
    if (v5)
    {
      pw_name = v5->pw_name;
      if (!pw_name)
      {
LABEL_12:
        krb5_set_error_message(a1, 25, "unable to figure out current principal");
        return 25;
      }
    }
    else
    {
      pw_name = sub_20968E044();
      if (!pw_name)
      {
        pw_name = getlogin();
        if (!pw_name)
          goto LABEL_12;
      }
    }
    return krb5_make_principal(a1, a2, 0, pw_name, 0);
  }
  v7 = getlogin();
  if ((v7 || (v7 = sub_20968E044()) != 0) && strcmp(v7, "root"))
    return krb5_make_principal(a1, a2, 0, v7, "root", 0);
  else
    return krb5_make_principal(a1, a2, 0, "root", 0);
}

char *sub_20968E044()
{
  char *result;

  result = getenv("USER");
  if (!result)
  {
    result = getenv("LOGNAME");
    if (!result)
      return getenv("USERNAME");
  }
  return result;
}

uint64_t krb5_get_default_principal(_krb5_context *a1, krb5_principal *a2)
{
  krb5_error_code principal;
  krb5_ccache cache;

  cache = 0;
  *a2 = 0;
  if (krb5_cc_default(a1, &cache))
    return sub_20968DF68(a1, a2);
  principal = krb5_cc_get_principal(a1, cache, a2);
  krb5_cc_close(a1, cache);
  if (principal)
    return sub_20968DF68(a1, a2);
  else
    return 0;
}

uint64_t sub_20968E100(_krb5_context *a1, CFArrayRef theArray, char *const **a3)
{
  CFIndex length;
  char *const *v7;
  CFIndex v8;
  const __CFString *v9;
  const __CFString *v10;
  char *const *v11;
  uint64_t v12;

  length = heim_array_get_length(theArray);
  v7 = (char *const *)malloc_type_calloc(length + 1, 8uLL, 0x10040436913F5uLL);
  *a3 = v7;
  if (length)
  {
    v8 = 0;
    while (1)
    {
      v9 = (const __CFString *)heim_array_copy_value(theArray, v8);
      if (v9)
      {
        v10 = v9;
        (*a3)[v8] = heim_string_copy_utf8(v9);
        heim_release(v10);
      }
      v11 = *a3;
      if (!(*a3)[v8])
        break;
      if (length == ++v8)
        goto LABEL_9;
    }
    krb5_free_host_realm(a1, v11);
    v12 = 12;
    krb5_set_error_message(a1, 12, "malloc: out of memory");
  }
  else
  {
    v11 = v7;
LABEL_9:
    v12 = 0;
    a3 = (char *const **)&v11[length];
  }
  *a3 = 0;
  return v12;
}

uint64_t krb5_get_default_realms(CFArrayRef *a1, char *const **a2)
{
  uint64_t result;

  result = sub_20968E224((_krb5_context *)a1);
  if (!(_DWORD)result)
    return sub_20968E100((_krb5_context *)a1, a1[9], a2);
  return result;
}

uint64_t sub_20968E224(_krb5_context *a1)
{
  const __CFArray *v2;
  uint64_t v3;
  const __CFArray *v4;

  v2 = (const __CFArray *)*((_QWORD *)a1 + 9);
  if ((!v2 || !heim_array_get_length(v2)) && krb5_set_default_realm(a1, 0))
    return 2529639136;
  v4 = (const __CFArray *)*((_QWORD *)a1 + 9);
  if (v4 && heim_array_get_length(v4))
    return 0;
  v3 = 2529639136;
  krb5_set_error_message(a1, -1765328160, "No default realm found");
  return v3;
}

krb5_error_code krb5_get_default_realm(krb5_context a1, char **a2)
{
  krb5_error_code v4;
  const __CFString *v5;
  const __CFString *v6;

  v4 = sub_20968E224(a1);
  if (!v4)
  {
    v5 = (const __CFString *)heim_array_copy_value(*((const __CFArray **)a1 + 9), 0);
    if (v5 && (v6 = v5, *a2 = heim_string_copy_utf8(v5), heim_release(v6), *a2))
    {
      return 0;
    }
    else
    {
      v4 = 12;
      krb5_set_error_message(a1, 12, "malloc: out of memory");
    }
  }
  return v4;
}

krb5_error_code krb5_fwd_tgt_creds(krb5_context a1, krb5_auth_context a2, char *a3, krb5_principal a4, krb5_principal a5, krb5_ccache a6, int forwardable, krb5_data *a8)
{
  const char *comp_string;
  uint64_t v14;
  uint64_t v16;
  const char *v17;
  int v18;
  char *realm;
  krb5_error_code result;
  krb5_principal v21;
  _OWORD v22[8];
  uint64_t v23;

  comp_string = a3;
  if (forwardable)
    v14 = 6;
  else
    v14 = 4;
  if (!a3)
  {
    if (krb5_principal_get_type((uint64_t)a1, (unsigned int *)a5) == 3)
    {
      comp_string = (const char *)krb5_principal_get_comp_string((uint64_t)a1, (uint64_t)a5, 0);
      v16 = krb5_principal_get_comp_string((uint64_t)a1, (uint64_t)a5, 1u);
      if (comp_string)
      {
        v17 = (const char *)v16;
        v18 = strcmp(comp_string, "host");
        comp_string = 0;
        if (!v18)
        {
          if (v17)
          {
            if (krb5_principal_get_comp_string((uint64_t)a1, (uint64_t)a5, 2u))
              comp_string = 0;
            else
              comp_string = v17;
          }
        }
      }
    }
    else
    {
      comp_string = 0;
    }
  }
  realm = (char *)krb5_principal_get_realm((uint64_t)a1, (uint64_t)a4);
  memset(v22, 0, sizeof(v22));
  v23 = 0;
  v21 = a4;
  result = krb5_make_principal(a1, v22, realm, "krbtgt", realm, 0);
  if (!result)
    return krb5_get_forwarded_creds(a1, (uint64_t)a2, a6, v14, comp_string, (uint64_t)&v21, (size_t *)a8);
  return result;
}

uint64_t krb5_get_forwarded_creds(_krb5_context *a1, uint64_t a2, _krb5_ccache *a3, uint64_t a4, const char *a5, uint64_t a6, size_t *a7)
{
  const krb5_data *realm;
  krb5_magic magic;
  uint64_t kdc_cred;
  uint64_t v17;
  uint64_t v18;
  int *v19;
  krb5_address **v20;
  const krb5_principal_data *v21;
  krb5_error_code config;
  krb5_error_code v23;
  addrinfo *v25;
  int v26;
  addrinfo *v27;
  char *v28;
  unint64_t v29;
  BOOL v30;
  uint64_t v31;
  char *v32;
  uint64_t v33;
  char *v34;
  __int128 v35;
  _QWORD *v36;
  uint64_t v37;
  void *v38;
  krb5_error_code v39;
  size_t *v40;
  int v41;
  krb5_error_code v42;
  _QWORD *v43;
  _DWORD *v44;
  uint64_t v45;
  char v46;
  const krb5_data *v47;
  _QWORD *v48;
  _DWORD *v49;
  _QWORD *v50;
  _QWORD *v51;
  _QWORD *v52;
  _QWORD *v53;
  size_t v54;
  void *v55;
  void *v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t addrport;
  size_t v60;
  void *v61;
  size_t *v62;
  _QWORD v63[2];
  krb5_creds *v64;
  addrinfo *v65;
  krb5_keyblock **v66;
  size_t v67;
  __int128 v68;
  __int128 v69;
  __int128 v70;
  void *v71[3];
  __int128 v72;
  _BYTE v73[32];
  krb5_address *v74;
  char *v75;
  uint64_t v76;
  krb5_address ret_value;
  krb5_int32 v78[5];

  v76 = 0;
  v71[0] = 0;
  v69 = 0u;
  v70 = 0u;
  v68 = 0u;
  v66 = 0;
  v67 = 0;
  v64 = 0;
  v65 = 0;
  v63[0] = 0;
  v63[1] = 0;
  v72 = 0u;
  memset(v73, 0, sizeof(v73));
  v71[2] = (void *)0x1600000005;
  v74 = 0;
  v75 = 0;
  krb5_data_zero(v63);
  if (!*(_QWORD *)(a2 + 32))
  {
    kdc_cred = 2529638921;
    krb5_set_error_message(a1, -1765328375, "auth context is missing session key");
    return kdc_cred;
  }
  if (krb5_get_credentials(a1, 0, a3, (krb5_creds *)a6, &v64))
  {
    ret_value.magic = 0;
    realm = (const krb5_data *)krb5_principal_get_realm((uint64_t)a1, *(_QWORD *)a6);
    krb5_appdefault_BOOLean(a1, 0, realm, "no-addresses", 1, &ret_value.magic);
    if (ret_value.magic)
    {
      LOBYTE(magic) = 0;
LABEL_9:
      v20 = 0;
      goto LABEL_10;
    }
  }
  else
  {
    magic = v64[1].magic;
    krb5_free_creds(a1, v64);
    if (!magic)
      goto LABEL_9;
  }
  v17 = getaddrinfo(a5, 0, 0, &v65);
  if ((_DWORD)v17)
  {
    v18 = v17;
    v19 = __error();
    kdc_cred = krb5_eai_to_heim_errno(v18, *v19);
    gai_strerror(v18);
    krb5_set_error_message(a1, kdc_cred, "resolving host %s failed: %s");
    return kdc_cred;
  }
  v25 = v65;
  if (v65)
  {
    v26 = 0;
    v27 = v65;
    do
    {
      ++v26;
      v27 = v27->ai_next;
    }
    while (v27);
  }
  else
  {
    v26 = 0;
  }
  v28 = (char *)malloc_type_realloc(v75, 24 * ((_DWORD)v74 + v26), 0x10800404ACF7207uLL);
  v29 = v74;
  if (v28)
    v30 = 1;
  else
    v30 = (_DWORD)v74 == -v26;
  if (v30)
  {
    v75 = v28;
    if (v74 < (int)v74 + v26)
    {
      v31 = 24 * v74;
      do
      {
        v32 = v75;
        *(_DWORD *)&v75[v31] = 0;
        krb5_data_zero(&v32[v31 + 8]);
        ++v29;
        v31 += 24;
      }
      while (v29 < ((_DWORD)v74 + v26));
      LODWORD(v29) = (_DWORD)v74;
    }
    for (; v25; v25 = v25->ai_next)
    {
      memset(&ret_value, 0, sizeof(ret_value));
      v33 = krb5_sockaddr2address(a1, (uint64_t)v25->ai_addr, (uint64_t)&ret_value);
      if ((_DWORD)v33 == -1765328170)
      {
        krb5_clear_error_message(a1);
      }
      else
      {
        kdc_cred = v33;
        if ((_DWORD)v33)
          goto LABEL_39;
        if (krb5_address_search(a1, &ret_value, &v74))
        {
          krb5_free_address((uint64_t)a1, (uint64_t)&ret_value);
        }
        else
        {
          v34 = &v75[24 * v29];
          v35 = *(_OWORD *)&ret_value.magic;
          *((_QWORD *)v34 + 2) = ret_value.contents;
          *(_OWORD *)v34 = v35;
          LODWORD(v29) = v29 + 1;
        }
      }
      LODWORD(v74) = v29;
    }
    freeaddrinfo(v65);
    v20 = &v74;
    LOBYTE(magic) = 1;
LABEL_10:
    LODWORD(v72) = 1;
    *((_QWORD *)&v72 + 1) = malloc_type_calloc(1uLL, 0x48uLL, 0x1090040DEC7D988uLL);
    if (!*((_QWORD *)&v72 + 1))
    {
      kdc_cred = 12;
      krb5_set_error_message(a1, 12, "malloc: out of memory");
      return kdc_cred;
    }
    v62 = a7;
    if (!v20)
    {
      v21 = *(const krb5_principal_data **)(a6 + 8);
      *(_QWORD *)&ret_value.magic = 0;
      *(_QWORD *)&ret_value.length = 0;
      v78[0] = 0;
      krb5_data_zero(&ret_value);
      config = krb5_cc_get_config(a1, a3, v21, "_forward", (krb5_data *)&ret_value);
      if (config)
      {
        v23 = config;
        krb5_data_free(&ret_value);
LABEL_57:
        sub_20969D22C((uint64_t *)a1, 1, v23, "_krb5_get_cached_forward_creds");
        goto LABEL_58;
      }
      v36 = krb5_storage_from_data((uint64_t *)&ret_value.magic);
      if (v36)
      {
        v37 = (uint64_t)v36;
        v23 = krb5_ret_uint32((uint64_t)v36, v78);
        if (!v23)
        {
          if (v78[0] == (_DWORD)a4)
          {
            v38 = malloc_type_calloc(1uLL, 0x90uLL, 0x10A0040AAA52FDDuLL);
            v76 = (uint64_t)v38;
            if (v38)
            {
              v39 = krb5_ret_creds(v37, (uint64_t)v38);
              if (v39)
              {
                v23 = v39;
                if (v76)
                {
                  krb5_free_creds(a1, (krb5_creds *)v76);
                  v76 = 0;
                }
              }
              else if (*(_QWORD *)(v76 + 56) >= time(0))
              {
                v23 = 0;
              }
              else
              {
                krb5_cc_set_config(a1, a3, v21, "_forward", 0);
                krb5_free_creds(a1, (krb5_creds *)v76);
                v76 = 0;
                v23 = -1765328352;
              }
            }
            else
            {
              v23 = krb5_enomem(a1);
            }
          }
          else
          {
            v23 = -1765328349;
            krb5_set_error_message(a1, -1765328349, "cached forward credential not same flags");
          }
        }
        krb5_storage_free(v37);
      }
      else
      {
        v23 = krb5_enomem(a1);
      }
      krb5_data_free(&ret_value);
      if (v23)
        goto LABEL_57;
    }
LABEL_58:
    if (!v76)
    {
      v41 = sub_2096BB6D0(a4);
      kdc_cred = krb5_get_kdc_cred(a1, a3, v41, (uint64_t)v20, 0, a6, (void **)&v76);
      krb5_free_addresses(a1, &v74);
      if ((_DWORD)kdc_cred)
        goto LABEL_89;
      if (!v20)
      {
        v42 = sub_20968EF6C(a1, a3, *(const krb5_principal_data **)(a6 + 8), a4, v76);
        if (v42)
          sub_20969D22C((uint64_t *)a1, 1, v42, "_krb5_store_cached_forward_creds");
      }
    }
    kdc_cred = decode_Ticket();
    if ((_DWORD)kdc_cred)
      goto LABEL_89;
    v71[0] = 0;
    v69 = 0u;
    v70 = 0u;
    v68 = 0u;
    LODWORD(v68) = 1;
    *((_QWORD *)&v68 + 1) = malloc_type_calloc(1uLL, 0x68uLL, 0x10B00407801D9E3uLL);
    if (!*((_QWORD *)&v68 + 1))
      goto LABEL_87;
    if ((*(_BYTE *)a2 & 1) != 0)
    {
      *(_QWORD *)&ret_value.magic = 0;
      v78[0] = 0;
      krb5_us_timeofday(a1, &ret_value.magic, v78);
      v43 = malloc_type_calloc(1uLL, 8uLL, 0x100004000313F17uLL);
      *((_QWORD *)&v69 + 1) = v43;
      v40 = v62;
      if (!v43)
        goto LABEL_87;
      *v43 = *(_QWORD *)&ret_value.magic;
      v44 = malloc_type_calloc(1uLL, 4uLL, 0x100004052888210uLL);
      *(_QWORD *)&v70 = v44;
      if (!v44)
        goto LABEL_87;
      *v44 = v78[0];
    }
    else
    {
      *((_QWORD *)&v69 + 1) = 0;
      *(_QWORD *)&v70 = 0;
      v40 = v62;
    }
    v45 = *(_QWORD *)(a2 + 8);
    if (v45)
    {
      v46 = magic ^ 1;
      if (!*(_WORD *)(a2 + 24))
        v46 = 1;
      if ((v46 & 1) == 0)
      {
        kdc_cred = krb5_make_addrport(a1, (void **)&v70 + 1, v45, *(_WORD *)(a2 + 24));
        if ((_DWORD)kdc_cred)
          goto LABEL_88;
      }
    }
    if (!*(_QWORD *)(a2 + 16))
      goto LABEL_78;
    if (*(_WORD *)(a2 + 26))
    {
      ret_value.magic = 0;
      v47 = (const krb5_data *)krb5_principal_get_realm((uint64_t)a1, *(_QWORD *)(v76 + 8));
      krb5_appdefault_BOOLean(a1, 0, v47, "no-addresses", 0, &ret_value.magic);
      if (!ret_value.magic)
      {
        addrport = krb5_make_addrport(a1, v71, *(_QWORD *)(a2 + 16), *(_WORD *)(a2 + 26));
        if ((_DWORD)addrport)
        {
          kdc_cred = addrport;
          goto LABEL_88;
        }
      }
LABEL_78:
      LODWORD(v68) = 1;
      v48 = (_QWORD *)*((_QWORD *)&v68 + 1);
      copy_EncryptionKey();
      v48[3] = malloc_type_calloc(1uLL, 8uLL, 0x10040436913F5uLL);
      sub_2096BB420();
      v48[4] = malloc_type_calloc(1uLL, 0x18uLL, 0x10800407C14B876uLL);
      sub_2096BB494();
      v49 = malloc_type_calloc(1uLL, 4uLL, 0x100004052888210uLL);
      v48[5] = v49;
      *v49 = *(_DWORD *)(v76 + 136);
      v50 = malloc_type_calloc(1uLL, 8uLL, 0x100004000313F17uLL);
      v48[6] = v50;
      *v50 = *(_QWORD *)(v76 + 40);
      v51 = malloc_type_calloc(1uLL, 8uLL, 0x100004000313F17uLL);
      v48[7] = v51;
      *v51 = *(_QWORD *)(v76 + 48);
      v52 = malloc_type_calloc(1uLL, 8uLL, 0x100004000313F17uLL);
      v48[8] = v52;
      *v52 = *(_QWORD *)(v76 + 56);
      v53 = malloc_type_calloc(1uLL, 8uLL, 0x100004000313F17uLL);
      v48[9] = v53;
      *v53 = *(_QWORD *)(v76 + 64);
      v48[10] = malloc_type_calloc(1uLL, 8uLL, 0x10040436913F5uLL);
      sub_2096BB420();
      v48[11] = malloc_type_calloc(1uLL, 0x18uLL, 0x10800407C14B876uLL);
      sub_2096BB494();
      v48[12] = malloc_type_calloc(1uLL, 0x10uLL, 0x1020040D5A9D86FuLL);
      sub_2096BB540();
      krb5_free_creds(a1, (krb5_creds *)v76);
      v54 = sub_2096BC060();
      v55 = malloc_type_malloc(v54, 0x2DBE7F64uLL);
      if (v55)
      {
        v56 = v55;
        v57 = sub_2096BC040();
        if (!(_DWORD)v57)
        {
          sub_2096BC070();
          if (v54 == v67)
          {
            v58 = krb5_crypto_init(a1, *(const krb5_keyblock **)(a2 + 32), 0, &v66);
            if ((_DWORD)v58)
              goto LABEL_93;
            kdc_cred = krb5_encrypt_EncryptedData(a1, (_DWORD **)v66, 14, v56, v67, 0, (uint64_t)v73);
            free(v56);
            krb5_crypto_destroy(a1, (uint64_t)v66);
            if ((_DWORD)kdc_cred)
              goto LABEL_83;
            v60 = sub_2096BC000();
            v61 = malloc_type_malloc(v60, 0x5F4E26BEuLL);
            if (!v61)
            {
              kdc_cred = 12;
              goto LABEL_83;
            }
            v56 = v61;
            v58 = sub_2096BBFE0();
            if ((_DWORD)v58)
            {
LABEL_93:
              kdc_cred = v58;
              free(v56);
              goto LABEL_83;
            }
            sub_2096BC010();
            if (v60 == v67)
            {
              kdc_cred = 0;
              *v40 = v60;
              v40[1] = (size_t)v56;
              return kdc_cred;
            }
          }
          krb5_abortx(a1, "internal error in ASN.1 encoder");
        }
        kdc_cred = v57;
        free(v56);
      }
      else
      {
        kdc_cred = 12;
      }
      sub_2096BC070();
LABEL_83:
      sub_2096BC010();
      return kdc_cred;
    }
    v71[0] = malloc_type_calloc(1uLL, 0x18uLL, 0x10800404ACF7207uLL);
    if (v71[0])
    {
      kdc_cred = krb5_copy_address((uint64_t)a1, *(_DWORD **)(a2 + 16));
      if (!(_DWORD)kdc_cred)
        goto LABEL_78;
LABEL_88:
      sub_2096BC070();
LABEL_89:
      sub_2096BC010();
      if (v76)
        krb5_free_creds(a1, (krb5_creds *)v76);
      return kdc_cred;
    }
LABEL_87:
    kdc_cred = 12;
    krb5_set_error_message(a1, 12, "malloc: out of memory");
    goto LABEL_88;
  }
  kdc_cred = 12;
  krb5_set_error_message(a1, 12, "malloc: out of memory");
LABEL_39:
  v20 = &v74;
  krb5_free_addresses(a1, &v74);
  freeaddrinfo(v65);
  if (!(_DWORD)kdc_cred)
  {
    LOBYTE(magic) = 1;
    goto LABEL_10;
  }
  return kdc_cred;
}

uint64_t sub_20968EF6C(_krb5_context *a1, _krb5_ccache *a2, const krb5_principal_data *a3, uint64_t a4, uint64_t a5)
{
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  krb5_data v14;

  *(_QWORD *)&v14.magic = 0;
  v14.data = 0;
  krb5_data_zero(&v14);
  v10 = krb5_storage_emem();
  if (v10)
  {
    v11 = (uint64_t)v10;
    v12 = krb5_store_uint32(v10, a4);
    if (!(_DWORD)v12)
    {
      v12 = krb5_store_creds(v11, a5);
      if (!(_DWORD)v12)
      {
        v12 = krb5_storage_to_data(v11, (size_t *)&v14);
        if (!(_DWORD)v12)
          v12 = krb5_cc_set_config(a1, a2, a3, "_forward", &v14);
      }
    }
    krb5_data_free(&v14);
    krb5_storage_free(v11);
  }
  else
  {
    v12 = krb5_enomem(a1);
    krb5_data_free(&v14);
  }
  return v12;
}

uint64_t _krb5_get_host_realm_int(_krb5_context *a1, char *a2, int a3, unsigned __int8 ***a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _BOOL4 BOOL_default;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  BOOL v19;
  int v20;
  char *v21;
  const char **strings;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  char *v33;
  char *v34;
  char *v35;
  unsigned __int8 **v36;
  uint64_t v37;

  BOOL_default = krb5_config_get_BOOL_default((uint64_t)a1, 0, 0, (uint64_t)a4, a5, a6, a7, a8, (uint64_t)"libdefaults");
  if (!a2)
  {
LABEL_19:
    v34 = strchr(a2, 46);
    if (!v34)
    {
      v37 = 2529639129;
      krb5_set_error_message(a1, -1765328167, "unable to find realm of host %s");
      return v37;
    }
    v35 = v34;
    v36 = (unsigned __int8 **)malloc_type_malloc(0x10uLL, 0x10040436913F5uLL);
    *a4 = v36;
    if (v36)
    {
      *v36 = (unsigned __int8 *)strdup(v35 + 1);
      if (**a4)
      {
        rk_strupr(**a4);
        v37 = 0;
        (*a4)[1] = 0;
        return v37;
      }
      free(*a4);
    }
    v37 = 12;
    krb5_set_error_message(a1, 12, "malloc: out of memory");
    return v37;
  }
  if (a3)
    v19 = !BOOL_default;
  else
    v19 = 1;
  v20 = !v19;
  v21 = a2;
  while (1)
  {
    strings = (const char **)krb5_config_get_strings((uint64_t)a1, 0, v13, v14, v15, v16, v17, v18, (uint64_t)"domain_realm");
    if (strings)
      break;
    if (v20 && !sub_20968F224((uint64_t)a1, v21, (void **)a4, v23, v24, v25, v26, v27))
      return 0;
LABEL_18:
    v21 = strchr(v21 + 1, 46);
    if (!v21)
      goto LABEL_19;
  }
  *a4 = (unsigned __int8 **)strings;
  if (strcasecmp(*strings, "dns_locate"))
    return 0;
  if (!a3)
    goto LABEL_18;
  v33 = a2;
  while (sub_20968F224((uint64_t)a1, v33, (void **)a4, v28, v29, v30, v31, v32))
  {
    v33 = strchr(v33 + 1, 46);
    if (!v33)
      goto LABEL_18;
  }
  return 0;
}

uint64_t sub_20968F224(uint64_t a1, const char *a2, void **a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  void **strings;
  const char **v11;
  const char *v12;
  const char *v13;
  uint64_t v14;
  char *v15;
  _DWORD *v16;
  _QWORD *v17;
  char *v18;
  uint64_t v19;
  unsigned int v20;
  uint64_t v21;
  uint64_t v22;
  void *v23;
  uint64_t v24;
  unsigned int v25;
  char *v26;
  uint64_t v27;
  unsigned int v28;
  uint64_t v29;
  uint64_t v30;
  void **v32;
  char __str[256];
  uint64_t v34;

  v34 = *MEMORY[0x24BDAC8D0];
  strings = (void **)krb5_config_get_strings(a1, 0, (uint64_t)a3, a4, a5, a6, a7, a8, (uint64_t)"libdefaults");
  v32 = strings;
  if (strings)
    v11 = (const char **)strings;
  else
    v11 = (const char **)&off_24C1F22C8;
  if (*a2 == 46)
    v12 = a2 + 1;
  else
    v12 = a2;
  v13 = *v11;
  if (*v11)
  {
    v14 = 0;
    v15 = "TXT";
    do
    {
      if (snprintf(__str, 0x100uLL, "%s.%s.", v13, v12) >= 0x100)
        break;
      v16 = sub_2096B9700(__str, v15);
      if (v16)
      {
        v17 = v16;
        v18 = v15;
        v19 = *((_QWORD *)v16 + 6);
        if (v19)
        {
          v20 = 0;
          v21 = *((_QWORD *)v16 + 6);
          do
          {
            if (*(_DWORD *)(v21 + 8) == 16)
              ++v20;
            v21 = *(_QWORD *)(v21 + 32);
          }
          while (v21);
          if (v20)
          {
            v22 = v20 + 1;
            v23 = malloc_type_malloc(8 * v22, 0x10040436913F5uLL);
            *a3 = v23;
            if (v23)
            {
              if ((_DWORD)v22)
              {
                v24 = 0;
                do
                {
                  *(_QWORD *)((char *)*a3 + v24) = 0;
                  v24 += 8;
                }
                while (8 * v22 != v24);
              }
              v25 = 0;
              while (1)
              {
                if (*(_DWORD *)(v19 + 8) == 16)
                {
                  v26 = strdup(*(const char **)(v19 + 24));
                  if (!v26)
                  {
                    v27 = 0;
                    if (v20 <= 1)
                      v28 = 1;
                    else
                      v28 = v20;
                    v29 = 8 * v28;
                    do
                    {
                      free(*(void **)((char *)*a3 + v27));
                      v27 += 8;
                    }
                    while (v29 != v27);
                    free(*a3);
                    break;
                  }
                  *((_QWORD *)*a3 + v25++) = v26;
                }
                v19 = *(_QWORD *)(v19 + 32);
                if (!v19)
                {
                  sub_2096B8E14(v17);
                  v30 = 0;
                  goto LABEL_36;
                }
              }
            }
          }
        }
        sub_2096B8E14(v17);
        v15 = v18;
      }
      v13 = v11[++v14];
    }
    while (v13);
  }
  v30 = 0xFFFFFFFFLL;
LABEL_36:
  if (v32)
    krb5_config_free_strings(v32);
  return v30;
}

krb5_error_code krb5_get_host_realm(krb5_context a1, const char *a2, char ***a3)
{
  CFMutableArrayRef v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  __CFArray *v13;
  unsigned __int8 **strings;
  char *const *v15;
  _BOOL4 v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char *const *v21;
  CFIndex length;
  krb5_error_code v23;
  char **v25;
  _QWORD v26[2];
  char __s[256];
  uint64_t v28;

  v28 = *MEMORY[0x24BDAC8D0];
  v25 = 0;
  if (a2)
  {
    __strlcpy_chk();
  }
  else
  {
    if (gethostname(__s, 0x100uLL))
    {
      *a3 = 0;
      return *__error();
    }
    __s[255] = 0;
  }
  sub_2096979B0(__s);
  v6 = heim_array_create();
  if (!v6)
    return 12;
  v13 = v6;
  strings = (unsigned __int8 **)krb5_config_get_strings((uint64_t)a1, 0, v7, v8, v9, v10, v11, v12, (uint64_t)"domain_realm");
  if (strings)
  {
    v15 = (char *const *)strings;
    v25 = (char **)strings;
    sub_20968F650(v13, (char **)strings);
    krb5_free_host_realm(a1, v15);
  }
  v26[0] = __s;
  v26[1] = v13;
  krb5_plugin_run_f((uint64_t)a1, "krb5", "krb5_configuration", 1u, 0, (uint64_t)v26, (uint64_t)sub_20968F6B8);
  v16 = strchr(__s, 46) != 0;
  if (!_krb5_get_host_realm_int(a1, __s, v16, (unsigned __int8 ***)&v25, v17, v18, v19, v20))
  {
    v21 = v25;
    if (v25)
    {
      sub_20968F650(v13, v25);
      krb5_free_host_realm(a1, v21);
    }
  }
  length = heim_array_get_length(v13);
  if (!a2 || length)
  {
    if (!heim_array_get_length(v13))
    {
      v23 = -1765328167;
      krb5_set_error_message(a1, -1765328167, "Unable to find realm of self");
      return v23;
    }
    v23 = sub_20968E100(a1, v13, (char *const **)a3);
    goto LABEL_22;
  }
  if (!krb5_get_default_realms(a1, a3))
  {
    v23 = 0;
LABEL_22:
    heim_release(v13);
    return v23;
  }
  v23 = -1765328167;
  krb5_set_error_message(a1, -1765328167, "Unable to find realm of host %s");
  return v23;
}

char *sub_20968F650(__CFArray *a1, char **a2)
{
  char *result;
  char **v4;
  CFStringRef v5;
  CFStringRef v6;
  char *v7;

  result = *a2;
  if (*a2)
  {
    v4 = a2 + 1;
    do
    {
      v5 = heim_string_create(result);
      if (v5)
      {
        v6 = v5;
        if (!sub_2096D7788(a1, v5))
          heim_array_append_value(a1, v6);
        heim_release(v6);
      }
      v7 = *v4++;
      result = v7;
    }
    while (v7);
  }
  return result;
}

uint64_t sub_20968F6B8(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD *a4)
{
  uint64_t (*v4)(uint64_t, _QWORD, uint64_t, _QWORD, void (*)(int, __CFArray *, char *));

  v4 = *(uint64_t (**)(uint64_t, _QWORD, uint64_t, _QWORD, void (*)(int, __CFArray *, char *)))(a2 + 32);
  if (v4)
    return v4(a1, *a4, a3, a4[1], sub_20968F6DC);
  else
    return 2529639161;
}

void sub_20968F6DC(int a1, __CFArray *a2, char *cStr)
{
  CFStringRef v4;
  CFStringRef v5;

  v4 = heim_string_create(cStr);
  if (v4)
  {
    v5 = v4;
    heim_array_append_value(a2, v4);
    heim_release(v5);
  }
}

void sub_20968F724()
{
  void *v0;

  v0 = (void *)MEMORY[0x20BD125D0]();
  AnalyticsSendEventLazy();
  objc_autoreleasePoolPop(v0);
}

uint64_t sub_20968F7BC(uint64_t a1)
{
  uint64_t v2;
  const __CFString *v3;
  _QWORD v5[4];
  _QWORD v6[5];

  v6[4] = *MEMORY[0x24BDAC8D0];
  v5[0] = CFSTR("AS_REQ_replykey_et");
  v6[0] = objc_msgSend(MEMORY[0x24BDD16E0], "numberWithInt:", *(unsigned int *)(a1 + 40));
  v5[1] = CFSTR("AS_REQ_useret_et");
  v6[1] = objc_msgSend(MEMORY[0x24BDD16E0], "numberWithInt:", *(unsigned int *)(a1 + 44));
  v5[2] = CFSTR("AS_REQ_preauth");
  v2 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithCString:encoding:", *(_QWORD *)(a1 + 32), 4);
  v3 = CFSTR("unknown");
  if (v2)
    v3 = (const __CFString *)v2;
  v6[2] = v3;
  v5[3] = CFSTR("AS_REQ_FAST");
  v6[3] = objc_msgSend(MEMORY[0x24BDD16E0], "numberWithInt:", *(unsigned int *)(a1 + 48));
  return objc_msgSend(MEMORY[0x24BDBCE70], "dictionaryWithObjects:forKeys:count:", v6, v5, 4);
}

uint64_t krb5_getportbyname(int a1, char *a2, char *a3, unsigned int a4)
{
  servent *v5;

  v5 = getservbyname(a2, a3);
  if (v5)
    return v5->s_port;
  else
    return bswap32(a4) >> 16;
}

uint64_t krb5_process_last_request(_krb5_context *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  _QWORD *v7;
  _QWORD *v8;
  uint64_t v9;
  unint64_t v10;
  _QWORD *v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;

  if (a2)
  {
    v6 = *(_QWORD *)(a2 + 88);
    if (v6)
    {
      if (*(_QWORD *)(v6 + 48))
      {
        v7 = malloc_type_calloc((*(_DWORD *)(a3 + 784) + 1), 8uLL, 0x2004093837F09uLL);
        if (!v7)
        {
          v14 = 12;
          krb5_set_error_message(a1, 12, "malloc: out of memory");
          return v14;
        }
        v8 = v7;
        if (*(_DWORD *)(a3 + 784))
        {
          v9 = 0;
          v10 = 0;
          do
          {
            v11 = malloc_type_calloc(1uLL, 0x10uLL, 0x1000040F7F8B94BuLL);
            v8[v10] = v11;
            if (!v11)
              break;
            v12 = *(_QWORD *)(a3 + 792) + v9;
            *(_DWORD *)v11 = *(_DWORD *)v12;
            v11[1] = *(_QWORD *)(v12 + 8);
            ++v10;
            v9 += 16;
          }
          while (v10 < *(unsigned int *)(a3 + 784));
        }
        (*(void (**)(_krb5_context *, _QWORD *, _QWORD))(*(_QWORD *)(a2 + 88) + 48))(a1, v8, *(_QWORD *)(*(_QWORD *)(a2 + 88) + 56));
        if (*(_DWORD *)(a3 + 784))
        {
          v13 = 0;
          do
            free((void *)v8[v13++]);
          while (v13 < *(unsigned int *)(a3 + 784));
        }
        free(v8);
      }
    }
  }
  krb5_init_creds_warn_user(a1, a3);
  return 0;
}

uint64_t krb5_init_creds_warn_user(_krb5_context *a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t time;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  time_t v21;
  uint64_t v22;
  time_t v23;
  int v24;
  const char *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  unsigned int *v31;
  char *v32;
  const char *v33;
  char *v34;
  void *v35;
  krb5_timestamp v36[2];

  if (!*(_QWORD *)(a2 + 904) || *(_DWORD *)(a2 + 920))
    return 0;
  *(_QWORD *)v36 = 0;
  *(_DWORD *)(a2 + 920) = 1;
  krb5_timeofday(a1, v36);
  krb5_principal_get_realm((uint64_t)a1, *(_QWORD *)(a2 + 8));
  v5 = *(_QWORD *)v36;
  time = krb5_config_get_time((uint64_t)a1, 0, v6, v7, v8, v9, v10, v11, (uint64_t)"realms");
  if (time < 0)
  {
    time = krb5_config_get_time((uint64_t)a1, 0, v13, v14, v15, v16, v17, v18, (uint64_t)"libdefaults");
    if (time < 0)
      time = 604800;
  }
  if (*(_DWORD *)(a2 + 784))
  {
    v19 = 0;
    v20 = 0;
    v21 = time + v5;
    do
    {
      v22 = *(_QWORD *)(a2 + 792);
      v23 = *(_QWORD *)(v22 + v19 + 8);
      if (v23 <= v21)
      {
        v24 = *(_DWORD *)(v22 + v19);
        if (v24 == 6)
        {
          v25 = "Your password will expire at ";
          goto LABEL_14;
        }
        if (v24 == 7)
        {
          v25 = "Your account will expire at ";
LABEL_14:
          sub_20968FC50((uint64_t)a1, *(void (**)(uint64_t, uint64_t, _QWORD, char *, _QWORD, _QWORD))(a2 + 904), *(_QWORD *)(a2 + 912), v25, v23);
        }
      }
      ++v20;
      v19 += 16;
    }
    while (v20 < *(unsigned int *)(a2 + 784));
  }
  if (krb5_enctype_warning((uint64_t)a1, *(_DWORD *)(a2 + 1024)))
  {
    v31 = (unsigned int *)(a2 + 1024);
  }
  else
  {
    v31 = (unsigned int *)(a2 + 24);
    if (!krb5_enctype_warning((uint64_t)a1, *(_DWORD *)(a2 + 24)))
      return 0;
  }
  if (*(_QWORD *)(a2 + 904))
  {
    v32 = (char *)*v31;
    if ((_DWORD)v32)
    {
      if (!krb5_config_get_BOOL_default((uint64_t)a1, 0, 0, v26, v27, v28, v29, v30, (uint64_t)"libdefaults"))
      {
        v34 = 0;
        v35 = 0;
        krb5_enctype_to_string((krb5_enctype)a1, v32, (size_t)&v35);
        v33 = (const char *)v35;
        if (!v35)
          v33 = "unknown";
        asprintf(&v34, "Encryption type %s(%d) used for authentication is weak and will be deprecated", v33, (_DWORD)v32);
        if (v34)
        {
          (*(void (**)(_krb5_context *, _QWORD, _QWORD, char *, _QWORD, _QWORD))(a2 + 904))(a1, *(_QWORD *)(a2 + 912), 0, v34, 0, 0);
          free(v34);
        }
        free(v35);
      }
    }
  }
  return 0;
}

void sub_20968FC50(uint64_t a1, void (*a2)(uint64_t, uint64_t, _QWORD, char *, _QWORD, _QWORD), uint64_t a3, const char *a4, time_t a5)
{
  char *v9;
  char *v10;
  time_t v11;

  v10 = 0;
  v11 = a5;
  v9 = ctime(&v11);
  if ((asprintf(&v10, "%s%s", a4, v9) & 0x80000000) == 0)
  {
    if (v10)
    {
      a2(a1, a3, 0, v10, 0, 0);
      free(v10);
    }
  }
}

uint64_t krb5_keyblock_key_proc(_krb5_context *a1, int a2, int a3, krb5_keyblock *a4, krb5_keyblock **a5)
{
  return krb5_copy_keyblock(a1, a4, a5);
}

uint64_t _krb5_make_pa_enc_challange(_krb5_context *a1, _DWORD **a2, uint64_t a3, unsigned int *a4)
{
  size_t v8;
  void *v9;
  void *v10;
  uint64_t v11;
  uint64_t v12;
  void *v13;
  uint64_t v14;
  void *v15;
  void *v16;
  uint64_t v17;
  krb5_int32 v19;
  krb5_int32 v20;
  _OWORD v21[2];
  uint64_t v22;
  krb5_timestamp v23[2];
  krb5_int32 *v24;

  *(_QWORD *)v23 = 0;
  v24 = 0;
  v22 = 0;
  memset(v21, 0, sizeof(v21));
  v20 = 0;
  krb5_us_timeofday(a1, v23, &v20);
  v19 = v20;
  v24 = &v19;
  v8 = sub_2096BBB20();
  v9 = malloc_type_malloc(v8, 0x138FC18uLL);
  if (!v9)
    return 12;
  v10 = v9;
  v11 = sub_2096BBB00();
  if (!(_DWORD)v11)
  {
    if (v8 == v22)
    {
      v12 = krb5_encrypt_EncryptedData(a1, a2, a3, v10, v8, 0, (uint64_t)v21);
      free(v10);
      if ((_DWORD)v12)
        return v12;
      v14 = sub_2096BB720();
      v15 = malloc_type_malloc(v14, 0xAD016E33uLL);
      if (!v15)
      {
        v12 = 12;
        goto LABEL_12;
      }
      v16 = v15;
      v17 = sub_2096BB700();
      if ((_DWORD)v17)
      {
        v12 = v17;
        free(v16);
LABEL_12:
        sub_2096BB730();
        return v12;
      }
      sub_2096BB730();
      if (v14 == v22)
      {
        v12 = krb5_padata_add(a1, a4, 138, (uint64_t)v16, v14);
        if (!(_DWORD)v12)
          return v12;
        v13 = v16;
        goto LABEL_4;
      }
    }
    krb5_abortx(a1, "internal error in ASN.1 encoder");
  }
  v12 = v11;
  v13 = v10;
LABEL_4:
  free(v13);
  return v12;
}

uint64_t _krb5_validate_pa_enc_challange(_krb5_context *a1, uint64_t a2, uint64_t a3, uint64_t a4, const char *a5)
{
  uint64_t v7;
  int v8;
  int v9;
  krb5_int32 v11;
  krb5_timestamp v12[2];
  time_t v13;
  uint64_t v14;
  _QWORD v15[2];
  char v16[100];
  uint64_t v17;

  v17 = *MEMORY[0x24BDAC8D0];
  v15[0] = 0;
  v15[1] = 0;
  v13 = 0;
  v14 = 0;
  *(_QWORD *)v12 = 0;
  v11 = 0;
  v7 = krb5_decrypt_EncryptedData(a1, a2, a3, a4, v15);
  if (!(_DWORD)v7)
  {
    v8 = sub_2096BBAE0();
    krb5_data_free(v15);
    if (v8)
    {
      v7 = 2529638936;
      sub_20969D1E8((uint64_t)a1, 5, "Failed to decode PA-ENC-TS_ENC - %s", a5);
    }
    else
    {
      krb5_us_timeofday(a1, v12, &v11);
      if (krb5_time_abs(*(uint64_t *)v12, v13) <= *((_QWORD *)a1 + 10))
      {
        v7 = 0;
      }
      else
      {
        krb5_format_time((uint64_t)a1, v13, v16, 0x64uLL, 1);
        v9 = krb5_time_abs(*(uint64_t *)v12, v13);
        sub_20969D1E8((uint64_t)a1, 0, "Too large time skew, client time %s is out by %u > %d seconds -- %s", v16, v9, *((_QWORD *)a1 + 10), a5);
        v7 = 2529638949;
      }
    }
    sub_2096BBB30();
  }
  return v7;
}

void *_krb5_srp_validate_group(int a1)
{
  if (a1 == 1)
    return &unk_24C1F1CE0;
  else
    return 0;
}

uint64_t _krb5_srp_pkisize(uint64_t a1)
{
  (*(void (**)(void))(a1 + 8))();
  return ccdh_ccn_size();
}

uint64_t _krb5_srp_keysize(uint64_t a1)
{
  return *(_QWORD *)(*(uint64_t (**)(void))(a1 + 16))();
}

void *_krb5_srp_create(uint64_t a1)
{
  _QWORD *v2;
  uint64_t v3;
  void *v4;

  v2 = (_QWORD *)(*(uint64_t (**)(void))(a1 + 16))();
  (*(void (**)(void))(a1 + 8))();
  v3 = ccdh_ccn_size();
  v4 = malloc_type_malloc(4 * (*v2 + v3) + 48, 0xECFA35FBuLL);
  if (v4)
    ccsrp_ctx_init();
  return v4;
}

uint64_t _krb5_srp_create_pa(_krb5_context *a1, uint64_t a2, const krb5_principal_data *a3, const char *a4, uint64_t a5, size_t *a6)
{
  size_t v11;
  uint64_t v12;
  uint64_t v13;
  size_t *v14;
  uint64_t v15;
  void *v17;
  void *v18;
  int verifier;
  size_t v20[2];
  char *v21;

  (*(void (**)(void))(a2 + 8))();
  v11 = ccdh_ccn_size();
  v12 = krb5_data_alloc(a6, v11);
  if (!(_DWORD)v12)
  {
    v20[1] = 0;
    v21 = 0;
    v20[0] = 0;
    v13 = krb5_unparse_name_flags(a1, a3, 2, &v21);
    if ((_DWORD)v13)
    {
      v12 = v13;
LABEL_7:
      krb5_data_free(a6);
      return v12;
    }
    v14 = (size_t *)(*(uint64_t (**)(void))(a2 + 16))();
    v15 = krb5_data_alloc(v20, *v14);
    if ((_DWORD)v15
      || ((*(void (**)(void))(a2 + 16))(),
          strlen(a4),
          (*(void (**)(void))(a2 + 16))(),
          v15 = ccpbkdf2_hmac(),
          (_DWORD)v15))
    {
      v12 = v15;
      free(v21);
      goto LABEL_7;
    }
    v17 = _krb5_srp_create(a2);
    if (v17)
    {
      v18 = v17;
      verifier = ccsrp_generate_verifier();
      krb5_data_free(v20);
      krb5_xfree(v18);
      krb5_xfree(v21);
      if (verifier)
        return 22;
      else
        return 0;
    }
    else
    {
      krb5_data_free(a6);
      krb5_data_free(v20);
      krb5_xfree(v21);
      return 12;
    }
  }
  return v12;
}

uint64_t _krb5_srp_reply_key(_krb5_context *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  __int128 v10;
  uint64_t v11;

  v10 = *(_OWORD *)*(_QWORD *)(a2 + 24);
  v11 = 0;
  return _krb5_pk_kdf(a1, &v10, a4, a5, a6, 0, a3, a7, a8, 0, a9);
}

uint64_t sub_209690284(uint64_t a1, uint64_t a2)
{
  if (*(_QWORD *)(a2 + 376))
    return 0;
  else
    return 2314790669;
}

uint64_t sub_20969029C(uint64_t *a1, uint64_t a2, uint64_t a3, _DWORD *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, unsigned int *a9)
{
  uint64_t result;
  uint64_t v11;

  if (a6)
  {
    result = sub_2096A2988(a1, *(char **)(a5 + 32), *(_QWORD *)(a2 + 376), *(_DWORD *)(a6 + 120), a7, *(_DWORD *)(a2 + 188), a2 + 192, a4, (void **)(a2 + 944));
    if (!(_DWORD)result)
      *(_BYTE *)(a2 + 444) |= 4u;
  }
  else
  {
    v11 = *(_QWORD *)(a2 + 376);
    if (!v11)
      return 2314790668;
    result = sub_2096A1D34(a1, v11, *(_DWORD *)(a2 + 384), 0, a5 + 16, *(unsigned int *)(a2 + 188), a9, a8);
    if (!(_DWORD)result)
      return 2314790668;
  }
  return result;
}

uint64_t sub_209690334(uint64_t *a1, uint64_t a2, uint64_t a3, _DWORD *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, unsigned int *a9)
{
  uint64_t result;
  uint64_t v11;

  if (a6)
  {
    result = sub_2096A2988(a1, *(char **)(a5 + 32), *(_QWORD *)(a2 + 376), *(_DWORD *)(a6 + 120), a7, *(_DWORD *)(a2 + 188), a2 + 192, a4, (void **)(a2 + 944));
    if (!(_DWORD)result)
      *(_BYTE *)(a2 + 444) |= 4u;
  }
  else
  {
    v11 = *(_QWORD *)(a2 + 376);
    if (!v11)
      return 2314790668;
    result = sub_2096A1D34(a1, v11, *(_DWORD *)(a2 + 384), 1, a5 + 16, *(unsigned int *)(a2 + 188), a9, a8);
    if (!(_DWORD)result)
      return 2314790668;
  }
  return result;
}

uint64_t sub_2096903C8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;

  if (!*(_QWORD *)(a2 + 336))
    return 2314790669;
  result = 0;
  *(_DWORD *)a3 = 1;
  *(_QWORD *)(a3 + 8) = 0;
  return result;
}

uint64_t sub_2096903F0(_krb5_context *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7, int a8, unsigned int *a9)
{
  uint64_t v13;
  int v14;
  _DWORD *v15;
  uint64_t v16;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  const char *v27;
  __int128 v28;
  krb5_error_code v29;
  char v31;
  krb5_keyblock *v32;
  void *v33;
  const char *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  void *v41;
  int v42;
  krb5_principal_data *v43;
  void *v44;
  void *v45;
  int v46;
  size_t v47;
  void *v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  int v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  char v64;
  char v65;
  char *v66;
  krb5_const_principal v67;
  krb5_principal v68[2];
  uint64_t v69;
  size_t v70[2];
  __int128 v71;
  __int128 v72;
  uint64_t v73;

  if (!a4)
  {
    v13 = 2314790669;
    sub_20969D1E8((uint64_t)a1, 0, "KDC didn't return any SRP pa data");
LABEL_12:
    *(_DWORD *)a3 = 4;
    return v13;
  }
  v13 = 2314790669;
  switch(*(_DWORD *)a3)
  {
    case 1:
      v73 = 0;
      v71 = 0u;
      v72 = 0u;
      v68[0] = 0;
      v70[0] = 0;
      v70[1] = 0;
      v69 = 0;
      if (sub_2096BC4B8())
        goto LABEL_12;
      if (krb5_data_copy((_QWORD *)(a3 + 56), *(const void **)(a4 + 16), *(_QWORD *)(a4 + 8)))
        goto LABEL_36;
      v14 = v71;
      if (!(_DWORD)v71)
        goto LABEL_10;
      v15 = (_DWORD *)*((_QWORD *)&v71 + 1);
      v16 = v71;
      while (*v15 != 1)
      {
        v15 += 8;
        if (!--v16)
        {
          *(_QWORD *)(a3 + 8) = 0;
LABEL_10:
          sub_20969D1E8((uint64_t)a1, 0, "KDC didn't send a good SRP group for us, sent %u group(s)", v14);
          goto LABEL_36;
        }
      }
      *(_QWORD *)(a3 + 8) = &unk_24C1F1CE0;
      if (copy_KRB5_SRP_PA()
        || (v41 = _krb5_srp_create(*(_QWORD *)(a3 + 8)), (*(_QWORD *)(a3 + 16) = v41) == 0)
        || (*(_QWORD *)(a3 + 24) = *(_QWORD *)(*(uint64_t (**)(void))(*(_QWORD *)(a3 + 8) + 16))(),
            (*(void (**)(void))(*(_QWORD *)(a3 + 8) + 8))(),
            *(_QWORD *)(a3 + 32) = ccdh_ccn_size(),
            krb5_data_alloc((size_t *)(a3 + 40), *(_QWORD *)(a3 + 24))))
      {
LABEL_36:
        *(_DWORD *)a3 = 4;
        sub_2096BC4D8();
        return v13;
      }
      (*(void (**)(void))(*(_QWORD *)(a3 + 8) + 16))();
      strlen(*(const char **)(a2 + 336));
      v42 = ccpbkdf2_hmac();
      sub_2096BC4D8();
      if (v42 || krb5_data_alloc(v70, *(_QWORD *)(a3 + 32)))
        goto LABEL_12;
      LODWORD(v69) = **(_DWORD **)(a3 + 8);
      ccDRBGGetRngState();
      ccsrp_client_start_authentication();
      v43 = (krb5_principal_data *)sub_2096BC508();
      v44 = malloc_type_malloc((size_t)v43, 0xE52BE08CuLL);
      if (!v44)
        goto LABEL_44;
      v45 = v44;
      if (sub_2096BC4E8())
      {
        free(v45);
LABEL_44:
        sub_2096BC518();
        goto LABEL_12;
      }
      sub_2096BC518();
      if (v43 != v68[0])
        heim_abort("ASN1.1 Internal error:data.length == size", v57, v58, v59, v60, v61, v62, v63, v64);
      if (!krb5_padata_add(a1, a9, 250, (uint64_t)v45, (uint64_t)v43))
      {
        v56 = 2;
        goto LABEL_55;
      }
      goto LABEL_53;
    case 2:
      v69 = 0;
      v70[0] = 0;
      v66 = 0;
      v67 = 0;
      v68[0] = 0;
      v68[1] = 0;
      if (sub_2096BC528())
        goto LABEL_12;
      if (v69 != *(_QWORD *)(a3 + 32))
        goto LABEL_21;
      v26 = *(_QWORD *)(a5 + 24);
      if (!v26)
        heim_abort("should not get here since we could not have found the hdb entry otherwise:a->req_body.cname != NULL", v19, v20, v21, v22, v23, v24, v25, v64);
      v27 = *(const char **)(a5 + 32);
      v28 = *(_OWORD *)v26;
      *(_QWORD *)&v72 = *(_QWORD *)(v26 + 16);
      v71 = v28;
      if (_krb5_principalname2krb5_principal((uint64_t)a1, &v67, (uint64_t)&v71, v27))
        goto LABEL_21;
      v29 = krb5_unparse_name_flags(a1, v67, 2, &v66);
      krb5_free_principal(a1, (krb5_principal)v67);
      if (v29)
        goto LABEL_21;
      if (krb5_data_alloc((size_t *)v68, *(_QWORD *)(a3 + 24)))
      {
        free(v66);
LABEL_21:
        *(_DWORD *)a3 = 4;
        sub_2096BC548();
        return v13;
      }
      sub_20969D1E8((uint64_t)a1, 5, "ccsrp client start for user: %s", v66);
      v46 = ccsrp_client_process_challenge();
      sub_2096BC548();
      if (v46)
      {
        *(_DWORD *)a3 = 4;
        sub_2096BC588();
        return v13;
      }
      v47 = sub_2096BC578();
      v48 = malloc_type_malloc(v47, 0xD4E58162uLL);
      if (!v48)
        goto LABEL_50;
      v45 = v48;
      if (sub_2096BC558())
      {
        free(v45);
LABEL_50:
        sub_2096BC588();
        goto LABEL_12;
      }
      sub_2096BC588();
      if (v47)
        heim_abort("ASN.1 internal error:data.length == size", v49, v50, v51, v52, v53, v54, v55, v65);
      if (krb5_padata_add(a1, a9, 250, (uint64_t)v45, 0))
      {
LABEL_53:
        free(v45);
        goto LABEL_12;
      }
      v56 = 3;
LABEL_55:
      *(_DWORD *)a3 = v56;
      return 2314790668;
    case 3:
      v69 = 0;
      v70[0] = 0;
      v67 = 0;
      v68[0] = 0;
      if (!a6)
      {
        sub_20969D1E8((uint64_t)a1, 0, "KDC didn't return an AS-REP in last step of verifier");
        goto LABEL_12;
      }
      if (sub_2096BC598())
        goto LABEL_12;
      if (v69 != *(_QWORD *)(a3 + 24))
      {
        *(_DWORD *)a3 = 4;
        sub_2096BC5B8();
        return v13;
      }
      v31 = ccsrp_client_verify_session();
      sub_2096BC5B8();
      if ((v31 & 1) != 0)
      {
        v32 = *(krb5_keyblock **)(a2 + 944);
        if (v32)
          krb5_free_keyblock(a1, v32);
        v33 = malloc_type_calloc(1uLL, 0x18uLL, 0x10800404ACF7207uLL);
        *(_QWORD *)(a2 + 944) = v33;
        if (v33)
        {
          v34 = *(const char **)(a6 + 16);
          v71 = *(_OWORD *)(a6 + 24);
          *(_QWORD *)&v72 = *(_QWORD *)(a6 + 40);
          if (!_krb5_principalname2krb5_principal((uint64_t)a1, v68, (uint64_t)&v71, v34))
          {
            v35 = *(unsigned int *)(a6 + 120);
            v36 = *(_QWORD *)(a3 + 8);
            v37 = *(_QWORD *)(a3 + 16);
            v38 = MEMORY[0x20BD11E44](*(_QWORD *)(v37 + 8));
            v39 = *(_QWORD *)(a3 + 24);
            v40 = *(_QWORD *)(a2 + 944);
            v71 = *(_OWORD *)*(_QWORD *)(v36 + 24);
            *(_QWORD *)&v72 = 0;
            LODWORD(v35) = _krb5_pk_kdf(a1, &v71, v37 + 32 * v38 + 32, v39, (uint64_t)v68[0], 0, v35, a2 + 192, a3 + 56, 0, v40);
            krb5_free_principal(a1, v68[0]);
            if (!(_DWORD)v35)
            {
              v13 = 0;
              *(_BYTE *)(a2 + 444) |= 4u;
            }
          }
        }
      }
      else
      {
        sub_20969D1E8((uint64_t)a1, 0, "Failed to validate the KDC");
      }
      goto LABEL_12;
    case 4:
      return v13;
    default:
      krb5_abortx(a1, "internal state machine error");
  }
}

uint64_t sub_2096909DC(uint64_t a1)
{
  free(*(void **)(a1 + 16));
  krb5_data_free((_QWORD *)(a1 + 56));
  krb5_data_free((_QWORD *)(a1 + 40));
  return free_KRB5_SRP_PA();
}

uint64_t sub_209690A14(_krb5_context *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, unsigned int *a9)
{
  int v13;
  unsigned int *v14;
  double v15;
  unsigned int *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t (*v20)(_krb5_context *, uint64_t, uint64_t, __int128 *, uint64_t, uint64_t);
  uint64_t pa_enc_challange;
  double v22;
  const char *v23;
  uint64_t v24;
  double v26;
  double v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  uint64_t v31;
  unsigned int v32;
  krb5_keyblock **v33;
  uint64_t v34;
  const char *v35;
  uint64_t v36;
  const char *v37;
  krb5_keyblock v38;
  _OWORD v39[2];
  uint64_t v40;

  v33 = 0;
  memset(v39, 0, sizeof(v39));
  v40 = 0;
  if (a6)
    v13 = *(_DWORD *)(a6 + 120);
  else
    v13 = 0;
  memset(&v38, 0, sizeof(v38));
  v36 = 0;
  v37 = 0;
  v34 = 0;
  v35 = 0;
  v32 = 0;
  LODWORD(v39[0]) = v13;
  v14 = sub_2096945E4((uint64_t)a1, *(_QWORD *)(a2 + 8), a5, (uint64_t)v39, a8);
  if (v14)
  {
    v16 = v14;
    v17 = *v14;
    if ((_DWORD)v17)
    {
      if (*(_QWORD *)(a2 + 944))
      {
        krb5_free_keyblock(a1, *(krb5_keyblock **)(a2 + 944));
        v17 = *v16;
      }
      v30 = *(_OWORD *)(v16 + 2);
      v18 = *((_QWORD *)v16 + 4);
      v31 = *((_QWORD *)v16 + 3);
      v19 = *(_QWORD *)(a2 + 352);
      v20 = *(uint64_t (**)(_krb5_context *, uint64_t, uint64_t, __int128 *, uint64_t, uint64_t))(a2 + 360);
      v28 = v30;
      *(_QWORD *)&v29 = v31;
      pa_enc_challange = v20(a1, v17, v19, &v28, v18, a2 + 944);
      v22 = sub_2096946B4(a1, (uint64_t)v39);
      if ((_DWORD)pa_enc_challange)
      {
        sub_20969D1E8((uint64_t)a1, 5, "enc-chal: failed to build key", v22);
      }
      else
      {
        pa_enc_challange = krb5_crypto_init(a1, *(const krb5_keyblock **)(a2 + 944), 0, &v33);
        if (!(_DWORD)pa_enc_challange)
        {
          krb5_crypto_getenctype((uint64_t)a1, *(_DWORD ***)(a2 + 984), &v32);
          v23 = "kdcchallengearmor";
          if (!a6)
            v23 = "clientchallengearmor";
          v24 = 20;
          if (a6)
            v24 = 17;
          v36 = v24;
          v37 = v23;
          v34 = 17;
          v35 = "challengelongterm";
          pa_enc_challange = krb5_crypto_fx_cf2(a1, *(uint64_t **)(a2 + 984), (uint64_t *)v33, (uint64_t)&v36, (uint64_t)&v34, (char *)v32, &v38);
          krb5_crypto_destroy(a1, (uint64_t)v33);
          if (!(_DWORD)pa_enc_challange)
          {
            pa_enc_challange = krb5_crypto_init(a1, &v38, 0, &v33);
            krb5_free_keyblock_contents(a1, &v38);
            if (!(_DWORD)pa_enc_challange)
            {
              if (a6)
              {
                sub_20969D1E8((uint64_t)a1, 5, "ENC_CHAL rep key", 0, 0, 0, 0, 0);
                if (*(_QWORD *)(a2 + 1016))
                {
                  if (a4)
                  {
                    if (sub_2096BB6E0())
                    {
                      pa_enc_challange = 2529638943;
                      sub_20969D1E8((uint64_t)a1, 5, "Failed to decode ENC_CHAL KDC reply", v26);
                    }
                    else
                    {
                      pa_enc_challange = _krb5_validate_pa_enc_challange(a1, (uint64_t)v33, 55, (uint64_t)&v28, "KDC");
                      sub_2096BB730();
                      krb5_crypto_destroy(a1, (uint64_t)v33);
                    }
                  }
                  else
                  {
                    krb5_crypto_destroy(a1, (uint64_t)v33);
                    sub_20969D1E8((uint64_t)a1, 0, "KDC response missing");
                    return 2314790669;
                  }
                }
                else
                {
                  krb5_crypto_destroy(a1, (uint64_t)v33);
                  sub_20969D1E8((uint64_t)a1, 5, "ENC_CHAL w/o strengthen_key");
                  return 2529639059;
                }
              }
              else
              {
                pa_enc_challange = _krb5_make_pa_enc_challange(a1, (_DWORD **)v33, 54, a9);
                krb5_crypto_destroy(a1, (uint64_t)v33);
                if ((_DWORD)pa_enc_challange)
                  sub_20969D1E8((uint64_t)a1, 5, "enc-chal: failed build enc challange", v27);
                else
                  return 2314790668;
              }
            }
          }
        }
      }
    }
    else
    {
      return 2314790669;
    }
  }
  else
  {
    pa_enc_challange = 2314790668;
    sub_20969D1E8((uint64_t)a1, 5, "no ppaid found", v15);
  }
  return pa_enc_challange;
}

uint64_t sub_209690D3C(_krb5_context *a1, uint64_t a2, uint64_t a3)
{
  *(_DWORD *)a3 = 0;
  krb5_free_principal(a1, *(krb5_principal *)(a3 + 8));
  *(_QWORD *)(a3 + 8) = 0;
  return 0;
}

uint64_t sub_209690D6C(krb5_context a1, uint64_t a2, krb5_principal *a3, int a4, uint64_t a5, uint64_t a6, int a7, uint64_t a8, unsigned int *a9)
{
  const krb5_principal_data *v15;
  krb5_principal *v16;
  uint64_t v17;
  _DWORD *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t (*v22)(krb5_context, uint64_t, uint64_t, __int128 *, uint64_t, uint64_t);
  unsigned int *v23;
  unsigned int *v24;
  int v25;
  int v26;
  const char *v27;
  __int128 v29;
  __int128 v30;
  uint64_t v31;
  unsigned int (*v32)(krb5_context, uint64_t, uint64_t, __int128 *, uint64_t, krb5_keyblock **);
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  __int128 v36;
  krb5_keyblock *v37;
  size_t v38;
  void *v39;
  void *v40;
  void *v41;
  int v42;
  uint64_t v43;
  void *v44;
  void *v45;
  krb5_timestamp v46[4];
  uint64_t v47;
  _OWORD v48[2];
  uint64_t v49;
  krb5_keyblock *v50;
  krb5_keyblock **v51;
  krb5_int32 v52;
  krb5_int32 v53;
  __int128 v54;
  __int128 v55;
  size_t v56;

  v16 = a3 + 1;
  v15 = a3[1];
  if (v15)
  {
    if (krb5_principal_compare(a1, v15, *(krb5_const_principal *)(a2 + 8)))
    {
      if (*v16)
        goto LABEL_7;
    }
    else
    {
      *(_DWORD *)a3 = 0;
      krb5_free_principal(a1, a3[1]);
      a3[1] = 0;
    }
  }
  v17 = krb5_copy_principal(a1, *(krb5_const_principal *)(a2 + 8), v16);
  if ((_DWORD)v17)
    return v17;
LABEL_7:
  v49 = 0;
  memset(v48, 0, sizeof(v48));
  if (a6)
  {
    LODWORD(v48[0]) = *(_DWORD *)(a6 + 120);
    v18 = sub_2096945E4((uint64_t)a1, *(_QWORD *)(a2 + 8), a5, (uint64_t)v48, a8);
    if (v18)
    {
LABEL_11:
      v19 = *(unsigned int *)(a6 + 120);
      *(_OWORD *)v46 = *(_OWORD *)(v18 + 2);
      v20 = *((_QWORD *)v18 + 4);
      v47 = *((_QWORD *)v18 + 3);
      v21 = *(_QWORD *)(a2 + 352);
      v22 = *(uint64_t (**)(krb5_context, uint64_t, uint64_t, __int128 *, uint64_t, uint64_t))(a2 + 360);
      v54 = *(_OWORD *)v46;
      *(_QWORD *)&v55 = v47;
      v17 = v22(a1, v19, v21, &v54, v20, a2 + 944);
      sub_2096946B4(a1, (uint64_t)v48);
      return v17;
    }
    if (*(_DWORD *)(a2 + 448))
    {
      v18 = (_DWORD *)(a2 + 448);
      goto LABEL_11;
    }
    sub_20969D1E8((uint64_t)a1, 0, "no paid when building key, build a default salt structure ?");
    return 2314790669;
  }
  v23 = sub_2096945E4((uint64_t)a1, *(_QWORD *)(a2 + 8), a5, (uint64_t)v48, a8);
  if (!v23)
  {
    v17 = 2314790668;
    sub_20969D1E8((uint64_t)a1, 5, "TS-ENC: waiting for KDC to set pw-salt/etype_info{,2}");
    return v17;
  }
  v24 = v23;
  if (!*v23)
  {
    sub_2096946B4(a1, (uint64_t)v48);
    sub_20969D1E8((uint64_t)a1, 5, "TS-ENC: kdc proposes enctype NULL ?");
    return 2314790669;
  }
  v25 = *(_DWORD *)a3;
  if ((*(_DWORD *)a3 & 8) != 0)
    v26 = 16;
  else
    v26 = 8;
  if ((v26 & v25) == 0)
  {
    *(_DWORD *)a3 = v26 | v25;
    sub_2096946B4(a1, a2 + 448);
    v29 = *(_OWORD *)v24;
    v30 = *((_OWORD *)v24 + 1);
    *(_QWORD *)(a2 + 480) = *((_QWORD *)v24 + 4);
    *(_OWORD *)(a2 + 448) = v29;
    *(_OWORD *)(a2 + 464) = v30;
    if (!*(_QWORD *)(a2 + 360) || !*(_QWORD *)(a2 + 352))
    {
      v17 = 2314790668;
      sub_20969D1E8((uint64_t)a1, 5, "krb5_get_init_creds: no keyproc or keyseed");
      return v17;
    }
    sub_20969D1E8((uint64_t)a1, 5, "krb5_get_init_creds: pa-info found, using %d", *v24);
    v33 = a2 + 352;
    v31 = *(_QWORD *)(a2 + 352);
    v32 = *(unsigned int (**)(krb5_context, uint64_t, uint64_t, __int128 *, uint64_t, krb5_keyblock **))(v33 + 8);
    v34 = *((_QWORD *)v24 + 4);
    v50 = 0;
    sub_20969D1E8((uint64_t)a1, 5, "krb5_get_init_creds: using ENC-TS with enctype %d", *v24);
    v35 = *v24;
    v36 = *(_OWORD *)(v24 + 2);
    *(_QWORD *)&v55 = *((_QWORD *)v24 + 3);
    v54 = v36;
    if (v32(a1, v35, v31, &v54, v34, &v50))
      return 2314790668;
    v37 = v50;
    memset(v46, 0, sizeof(v46));
    v56 = 0;
    v54 = 0u;
    v55 = 0u;
    v53 = 0;
    v51 = 0;
    krb5_us_timeofday(a1, v46, &v53);
    v52 = v53;
    *(_QWORD *)&v46[2] = &v52;
    v38 = sub_2096BBB20();
    v39 = malloc_type_malloc(v38, 0x7D05C84DuLL);
    if (!v39)
    {
LABEL_38:
      v17 = 2314790668;
      krb5_free_keyblock(a1, v50);
      return v17;
    }
    v40 = v39;
    if (sub_2096BBB00())
      goto LABEL_36;
    if (v38 == v56)
    {
      if (krb5_crypto_init(a1, v37, 0, &v51))
      {
LABEL_36:
        v41 = v40;
LABEL_37:
        free(v41);
        goto LABEL_38;
      }
      v42 = krb5_encrypt_EncryptedData(a1, (_DWORD **)v51, 1, v40, v56, 0, (uint64_t)&v54);
      free(v40);
      krb5_crypto_destroy(a1, (uint64_t)v51);
      if (v42)
        goto LABEL_38;
      v43 = sub_2096BB720();
      v44 = malloc_type_malloc(v43, 0x56520668uLL);
      if (!v44)
      {
LABEL_43:
        sub_2096BB730();
        goto LABEL_38;
      }
      v45 = v44;
      if (sub_2096BB700())
      {
        free(v45);
        goto LABEL_43;
      }
      sub_2096BB730();
      if (v43 == v56)
      {
        if (!krb5_padata_add(a1, a9, 2, (uint64_t)v45, v43))
        {
          krb5_free_keyblock(a1, v50);
          return 2314790668;
        }
        v41 = v45;
        goto LABEL_37;
      }
    }
    krb5_abortx(a1, "internal error in ASN.1 encoder");
  }
  v17 = 2529639135;
  if ((v25 & 8) != 0)
    v27 = "reneg";
  else
    v27 = "info";
  sub_2096946B4(a1, (uint64_t)v48);
  krb5_set_error_message(a1, -1765328161, "Already tried ENC-TS-%s, looping", v27);
  return v17;
}

void sub_2096911F0(uint64_t a1)
{
  krb5_principal_data *v1;

  v1 = *(krb5_principal_data **)(a1 + 8);
  if (v1)
    krb5_free_principal(0, v1);
}

uint64_t sub_209691204(_krb5_context *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, unsigned int *a9)
{
  uint64_t result;
  size_t v11;
  void *v12;
  void *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  char v23;

  result = *(unsigned int *)(a2 + 368);
  if ((_DWORD)result)
  {
    v11 = sub_2096BBB60();
    v12 = malloc_type_malloc(v11, 0xC9762E7CuLL);
    if (v12)
    {
      v13 = v12;
      v21 = sub_2096BBB40();
      if ((_DWORD)v21)
        goto LABEL_6;
      if (v11)
        heim_abort("internal error in ASN.1 encoder:len == length", v14, v15, v16, v17, v18, v19, v20, v23);
      v22 = krb5_padata_add(a1, a9, 128, (uint64_t)v13, 0);
      v21 = 0;
      result = 0;
      if (v22)
      {
LABEL_6:
        free(v13);
        return v21;
      }
    }
    else
    {
      return 12;
    }
  }
  return result;
}

uint64_t sub_2096912E4(_krb5_context *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, unsigned int *a9)
{
  uint64_t v9;
  uint64_t v11;
  uint64_t v13;
  uint64_t v14;

  v9 = *(_QWORD *)(a2 + 1072);
  if (!v9)
    return 0;
  v13 = 0;
  v14 = 0;
  v11 = krb5_data_copy(&v13, *(const void **)(v9 + 8), *(_QWORD *)v9);
  if (!(_DWORD)v11)
  {
    v11 = krb5_padata_add(a1, a9, 148, v14, v13);
    if ((_DWORD)v11)
      krb5_data_free(&v13);
  }
  return v11;
}

uint64_t sub_209691358(_krb5_context *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, unsigned int *a9)
{
  if ((*(_BYTE *)(a2 + 444) & 2) != 0)
    return krb5_padata_add(a1, a9, 149, 0, 0);
  else
    return 0;
}

uint64_t sub_20969137C(_krb5_context *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, unsigned int *a9)
{
  _DWORD *padata;
  uint64_t v11;
  void *v12;
  void *v13;
  int v15;

  v15 = 0;
  padata = krb5_find_padata(*(_QWORD *)(a8 + 8), *(_DWORD *)a8, 133, &v15);
  v11 = (uint64_t)padata;
  if (padata)
  {
    v12 = malloc_type_malloc(*((_QWORD *)padata + 1), 0x1FD5A44FuLL);
    if (v12)
    {
      v13 = v12;
      memcpy(v12, *(const void **)(v11 + 16), *(_QWORD *)(v11 + 8));
      v11 = krb5_padata_add(a1, a9, 133, (uint64_t)v13, *(_QWORD *)(v11 + 8));
      if ((_DWORD)v11)
        free(v13);
      else
        sub_20969D1E8((uint64_t)a1, 5, "Mirrored FX-COOKIE to KDC");
    }
    else
    {
      return 12;
    }
  }
  return v11;
}

uint64_t sub_209691438()
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;

  v1 = 0;
  v2 = 0;
  v3 = 0;
  sub_2096BB984();
  sub_2096BB9A4();
  return 0;
}

uint64_t sub_2096915E0()
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;

  v1 = 0;
  v2 = 0;
  v3 = 0;
  sub_2096BB954();
  sub_2096BB974();
  return 0;
}

int *sub_20969178C(_krb5_context *a1, uint64_t a2, uint64_t a3, int *a4, uint64_t a5)
{
  char *v5;

  v5 = (char *)*a4;
  if (!(_DWORD)v5 || krb5_enctype_valid(a1, v5))
    return 0;
  if (sub_209694710((uint64_t)a4, a1, *a4, a4[2], *(const void **)(a5 + 8), *(_QWORD *)a5, 0))
    return 0;
  return a4;
}

uint64_t krb5_init_creds_init(_krb5_context *a1, krb5_principal_data *a2, uint64_t a3, uint64_t a4, uint64_t a5, krb5_get_init_creds_opt *a6, _QWORD *a7)
{
  char *v14;
  char *v15;
  const krb5_data *realm;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t inited;
  uint64_t v24;
  krb5_flags flags;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  krb5_flags v29;
  uint64_t v30;
  uint64_t v31;
  int *p_preauth_list_length;
  uint64_t default_principal;
  void *v34;
  _DWORD *v35;
  _DWORD *v36;
  _DWORD *v37;
  _DWORD *v38;
  int v39;
  size_t v40;
  size_t v41;
  const char *v42;
  char *v43;
  krb5_get_init_creds_opt *opt;
  krb5_timestamp v46[2];

  *a7 = 0;
  v14 = (char *)malloc_type_calloc(1uLL, 0x448uLL, 0x10F0040D241B14AuLL);
  if (!v14)
  {
    inited = 12;
    krb5_set_error_message(a1, 12, "malloc: out of memory");
    return inited;
  }
  v15 = v14;
  opt = 0;
  bzero(v14, 0x448uLL);
  if (!a6)
  {
    realm = (const krb5_data *)krb5_principal_get_realm((uint64_t)a1, (uint64_t)a2);
    krb5_get_init_creds_opt_alloc(a1, &opt);
    a6 = opt;
    krb5_get_init_creds_opt_set_default_flags(a1, 0, realm, (uint64_t)opt, v17, v18, v19, v20);
  }
  v21 = *(_QWORD *)&a6[1].proxiable;
  if (v21)
  {
    v22 = *(_QWORD *)(v21 + 8);
    if (v22)
    {
      inited = krb5_init_creds_set_password(a1, (uint64_t)v15, v22);
      if ((_DWORD)inited)
        goto LABEL_62;
      v21 = *(_QWORD *)&a6[1].proxiable;
    }
    v24 = *(_QWORD *)(v21 + 16);
    *((_QWORD *)v15 + 45) = v24;
    *((_DWORD *)v15 + 92) = *(_DWORD *)(v21 + 24);
    *((_QWORD *)v15 + 47) = *(_QWORD *)(v21 + 32);
    *((_DWORD *)v15 + 96) = *(_DWORD *)(v21 + 44);
  }
  else
  {
    *((_DWORD *)v15 + 92) = 0;
    v24 = *((_QWORD *)v15 + 45);
  }
  if (!v24)
    *((_QWORD *)v15 + 45) = sub_2096947EC;
  if ((v15[384] & 2) != 0 || krb5_principal_get_type((uint64_t)a1, (unsigned int *)a2) == 10)
    *(_DWORD *)v15 |= 0x8000u;
  *((_QWORD *)v15 + 19) = 0;
  *((_QWORD *)v15 + 20) = 0;
  *((_QWORD *)v15 + 21) = 0;
  *(_QWORD *)v46 = 0;
  krb5_timeofday(a1, v46);
  *(_OWORD *)(v15 + 8) = 0u;
  *(_OWORD *)(v15 + 24) = 0u;
  *(_OWORD *)(v15 + 40) = 0u;
  *(_OWORD *)(v15 + 56) = 0u;
  *(_OWORD *)(v15 + 72) = 0u;
  *(_OWORD *)(v15 + 88) = 0u;
  *(_OWORD *)(v15 + 104) = 0u;
  *(_OWORD *)(v15 + 120) = 0u;
  *(_OWORD *)(v15 + 136) = 0u;
  if (a2)
  {
    krb5_copy_principal(a1, a2, (krb5_principal *)v15 + 1);
    goto LABEL_18;
  }
  default_principal = krb5_get_default_principal(a1, (krb5_principal *)v15 + 1);
  if (!(_DWORD)default_principal)
  {
LABEL_18:
    if (a5)
      *((_QWORD *)v15 + 7) = *(_QWORD *)v46 + a5;
    flags = a6->flags;
    if ((a6->flags & 1) != 0)
      v26 = *(_QWORD *)&a6->renew_life;
    else
      v26 = 36000;
    v27 = *(_QWORD *)v46;
    *((_QWORD *)v15 + 8) = *(_QWORD *)v46 + v26;
    if ((flags & 2) != 0)
    {
      v28 = *(_QWORD *)&a6->proxiable;
      if (v28 >= 1)
        *((_QWORD *)v15 + 9) = v28 + v27;
    }
    inited = krb5_init_creds_set_service(a1, (uint64_t)v15, 0);
    if ((_DWORD)inited)
      goto LABEL_62;
    if ((a6->flags & 4) != 0)
    {
      *(_DWORD *)v15 = *(_DWORD *)v15 & 0xFFFFFFFD | (2 * ((uint64_t)a6->etype_list & 1));
      if ((a6->flags & 8) == 0)
      {
LABEL_29:
        if (!a5)
          goto LABEL_31;
        goto LABEL_30;
      }
    }
    else if ((a6->flags & 8) == 0)
    {
      goto LABEL_29;
    }
    *(_DWORD *)v15 = *(_DWORD *)v15 & 0xFFFFFFF7 | (8 * (HIDWORD(a6->etype_list) & 1));
    if (!a5)
    {
LABEL_31:
      if (*((_QWORD *)v15 + 9))
        *(_DWORD *)v15 |= 0x100u;
      v29 = a6->flags;
      if ((a6->flags & 0x20) != 0)
      {
        p_preauth_list_length = &a6->preauth_list_length;
      }
      else
      {
        v30 = *(_QWORD *)&a6[1].proxiable;
        if (!v30 || (v31 = *(int *)(v30 + 40), v31 > 2))
        {
LABEL_44:
          if ((v29 & 0x10) != 0)
          {
            v34 = (void *)*((_QWORD *)v15 + 20);
            if (v34)
              free(v34);
            v35 = malloc_type_malloc(4 * SLODWORD(a6->preauth_list) + 4, 0x100004052888210uLL);
            if (!v35)
            {
LABEL_61:
              inited = 12;
              krb5_set_error_message(a1, 12, "malloc: out of memory");
              goto LABEL_62;
            }
            v36 = v35;
            memcpy(v35, a6->address_list, 4 * SLODWORD(a6->preauth_list));
            v36[SLODWORD(a6->preauth_list)] = 0;
            *((_QWORD *)v15 + 20) = v36;
            v29 = a6->flags;
          }
          if ((v29 & 0x40) == 0)
          {
LABEL_52:
            if ((v29 & 0x100) != 0)
              *(_DWORD *)v15 = *(_DWORD *)v15 & 0xFFFEFFFF | ((a6->etype_list_length & 1) << 16);
            if (opt)
              krb5_get_init_creds_opt_free(a1, opt);
            krb5_generate_random_block((uint64_t)(v15 + 184), 4);
            v39 = *((_DWORD *)v15 + 46) & 0x7FFFFFFF;
            *((_DWORD *)v15 + 46) = v39;
            *((_DWORD *)v15 + 47) = v39;
            *((_QWORD *)v15 + 113) = a3;
            *((_QWORD *)v15 + 114) = a4;
            v40 = strlen("WELLKNOWN:COM.APPLE.LKDC");
            if (!*((_QWORD *)v15 + 49))
            {
              v41 = v40;
              v42 = *(const char **)(*((_QWORD *)v15 + 1) + 24);
              if (!strncmp(v42, "WELLKNOWN:COM.APPLE.LKDC", v40) && v42[v41] == 58)
              {
                v43 = strdup(&v42[v41 + 1]);
                *((_QWORD *)v15 + 49) = v43;
                sub_20969D1E8((uint64_t)a1, 5, "krb5_get_init_creds: setting LKDC hostname to: %s", v43);
              }
            }
            inited = 0;
            v15[444] |= 2u;
            *((_DWORD *)v15 + 235) |= 0x1000u;
            *a7 = v15;
            return inited;
          }
          v37 = malloc_type_malloc(4 * a6[1].flags + 4, 0x100004052888210uLL);
          if (v37)
          {
            v38 = v37;
            memcpy(v37, a6->salt, 4 * a6[1].flags);
            v38[a6[1].flags] = 0;
            *((_QWORD *)v15 + 21) = v38;
            v29 = a6->flags;
            goto LABEL_52;
          }
          goto LABEL_61;
        }
        p_preauth_list_length = (int *)(&off_24C1F2308 + v31);
      }
      *((_QWORD *)v15 + 19) = *(_QWORD *)p_preauth_list_length;
      goto LABEL_44;
    }
LABEL_30:
    *(_DWORD *)v15 |= 0x40u;
    goto LABEL_31;
  }
  inited = default_principal;
  krb5_free_cred_contents(a1, (krb5_creds *)(v15 + 8));
LABEL_62:
  if (opt)
    krb5_get_init_creds_opt_free(a1, opt);
  free(v15);
  return inited;
}

void sub_209691C80(krb5_context a1, uint64_t a2)
{
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  size_t v9;
  krb5_keyblock *v10;
  uint64_t v11;
  krb5_data *v12;
  void *v13;
  void *v14;

  v4 = *(void **)(a2 + 160);
  if (v4)
    free(v4);
  v5 = *(void **)(a2 + 168);
  if (v5)
    free(v5);
  v6 = *(void **)(a2 + 176);
  if (v6)
    free(v6);
  v7 = *(void **)(a2 + 344);
  if (v7)
    free(v7);
  v8 = *(void **)(a2 + 336);
  if (v8)
  {
    v9 = strlen(*(const char **)(a2 + 336));
    bzero(v8, v9);
    free(*(void **)(a2 + 336));
  }
  sub_2096B7CE0(a1, a2 + 936);
  v10 = *(krb5_keyblock **)(a2 + 1032);
  if (v10)
    krb5_free_keyblock(a1, v10);
  krb5_data_free((_QWORD *)(a2 + 192));
  krb5_free_cred_contents(a1, (krb5_creds *)(a2 + 8));
  sub_2096BB9D4();
  sub_2096BBCCC();
  sub_2096BBCFC();
  sub_2096BC0D0();
  sub_2096BBA7C();
  heim_release(*(CFTypeRef *)(a2 + 1048));
  heim_release(*(CFTypeRef *)(a2 + 1040));
  *(_QWORD *)(a2 + 1040) = 0;
  v11 = *(_QWORD *)(a2 + 1064);
  if (v11)
    hx509_cert_free(v11);
  v12 = *(krb5_data **)(a2 + 1072);
  if (v12)
    krb5_free_data(a1, v12);
  v13 = *(void **)(a2 + 392);
  if (v13)
    free(v13);
  v14 = *(void **)(a2 + 400);
  if (v14)
    free(v14);
  sub_2096946B4(a1, a2 + 448);
  bzero((void *)a2, 0x448uLL);
}

uint64_t krb5_init_creds_set_kdc_hostname(_krb5_context *a1, uint64_t a2, char *__s1)
{
  void *v6;
  char *v7;

  v6 = *(void **)(a2 + 392);
  if (v6)
    free(v6);
  v7 = strdup(__s1);
  *(_QWORD *)(a2 + 392) = v7;
  if (v7)
    return 0;
  else
    return krb5_enomem(a1);
}

uint64_t krb5_init_creds_set_sitename(_krb5_context *a1, uint64_t a2, char *__s1)
{
  void *v6;
  char *v7;

  v6 = *(void **)(a2 + 400);
  if (v6)
    free(v6);
  v7 = strdup(__s1);
  *(_QWORD *)(a2 + 400) = v7;
  if (v7)
    return 0;
  else
    return krb5_enomem(a1);
}

uint64_t krb5_init_creds_set_source_app(uint64_t a1, uint64_t a2, unsigned __int8 *a3, char *__s1)
{
  krb5_init_creds_set_source_process(a1, a2, a3, 0, __s1);
  return 0;
}

uint64_t krb5_init_creds_set_source_process(uint64_t a1, uint64_t a2, unsigned __int8 *a3, int a4, char *__s1)
{
  void *v10;

  *(_BYTE *)(a2 + 444) |= 8u;
  *(_OWORD *)(a2 + 408) = *(_OWORD *)a3;
  v10 = *(void **)(a2 + 432);
  if (v10)
  {
    free(v10);
    *(_QWORD *)(a2 + 432) = 0;
  }
  if (__s1)
    *(_QWORD *)(a2 + 432) = strdup(__s1);
  sub_20969D1E8(a1, 5, "krb5_init_creds_set_source_app: %s %d%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x", __s1, a4, *a3, a3[1], a3[2], a3[3], a3[4], a3[5], a3[6], a3[7], a3[8], a3[9], a3[10], a3[11], a3[12], a3[13],
    a3[14],
    a3[15]);
  return 0;
}

uint64_t krb5_init_creds_set_service(_krb5_context *a1, uint64_t a2, const char *a3)
{
  char *realm;
  char *v7;
  uint64_t result;
  krb5_principal v9;

  v9 = 0;
  realm = (char *)krb5_principal_get_realm((uint64_t)a1, *(_QWORD *)(a2 + 8));
  v7 = realm;
  if (a3)
  {
    result = krb5_parse_name(a1, a3, &v9);
    if ((_DWORD)result)
      return result;
    krb5_principal_set_realm(a1, (uint64_t)v9, v7);
  }
  else
  {
    result = krb5_make_principal(a1, &v9, realm, "krbtgt", realm, 0);
    if ((_DWORD)result)
      return result;
  }
  if (krb5_principal_is_krbtgt((uint64_t)a1, (uint64_t)v9))
    krb5_principal_set_type((uint64_t)a1, v9, 2);
  krb5_free_principal(a1, *(krb5_principal *)(a2 + 16));
  result = 0;
  *(_QWORD *)(a2 + 16) = v9;
  return result;
}

uint64_t krb5_init_creds_set_pkinit_client_cert(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_QWORD *)(a2 + 1064))
    hx509_cert_free();
  *(_QWORD *)(a2 + 1064) = hx509_cert_ref(a3);
  return 0;
}

uint64_t krb5_init_creds_set_password(_krb5_context *a1, uint64_t a2, uint64_t __s1)
{
  void *v6;
  size_t v7;
  char *v8;

  v6 = *(void **)(a2 + 336);
  if (v6)
  {
    v7 = strlen(*(const char **)(a2 + 336));
    bzero(v6, v7);
    free(*(void **)(a2 + 336));
  }
  if (__s1)
  {
    v8 = strdup((const char *)__s1);
    *(_QWORD *)(a2 + 336) = v8;
    if (v8)
    {
      __s1 = 0;
      *(_QWORD *)(a2 + 352) = v8;
    }
    else
    {
      __s1 = 12;
      krb5_set_error_message(a1, 12, "malloc: out of memory");
    }
  }
  else
  {
    *(_QWORD *)(a2 + 352) = 0;
    *(_QWORD *)(a2 + 336) = 0;
  }
  return __s1;
}

uint64_t krb5_init_creds_set_keytab(_krb5_context *a1, uint64_t a2, _krb5_kt *a3)
{
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  int v10;
  int principal;
  uint64_t v12;
  void *v13;
  uint64_t v14;
  unsigned int v15;
  int v16;
  BOOL v17;
  _DWORD *v18;
  void *v19;
  krb5_kt_cursor cursor[3];
  krb5_keytab_entry entry;
  uint64_t v22;

  v6 = malloc_type_malloc(0x10uLL, 0x20040A4A59CD2uLL);
  if (!v6)
  {
    v8 = 12;
    krb5_set_error_message(a1, 12, "malloc: out of memory");
    return v8;
  }
  v22 = 0;
  memset(&entry, 0, sizeof(entry));
  memset(cursor, 0, sizeof(cursor));
  v7 = *(_QWORD *)(a2 + 8);
  *v6 = a3;
  v6[1] = v7;
  *(_QWORD *)(a2 + 344) = v6;
  *(_QWORD *)(a2 + 352) = v6;
  *(_QWORD *)(a2 + 360) = sub_20969239C;
  v8 = krb5_kt_start_seq_get(a1, a3, cursor);
  if ((_DWORD)v8)
    goto LABEL_5;
  if (krb5_kt_next_entry(a1, a3, &entry, cursor))
  {
    v8 = 2529639093;
    krb5_kt_end_seq_get(a1, a3, cursor);
    goto LABEL_5;
  }
  v10 = 0;
  principal = 0;
  v12 = 0;
  v13 = 0;
  do
  {
    if (!krb5_principal_compare(a1, *(krb5_const_principal *)&entry.magic, *(krb5_const_principal *)(a2 + 8)))
      goto LABEL_27;
    if (SLODWORD(entry.principal) <= principal)
    {
      if (LODWORD(entry.principal) != principal)
        goto LABEL_16;
    }
    else
    {
      if (v13)
      {
        free(v13);
        v13 = 0;
      }
      v12 = 0;
      principal = (int)entry.principal;
    }
    if (krb5_enctype_valid(a1, (char *)entry.timestamp))
      goto LABEL_16;
    v14 = *(_QWORD *)(a2 + 160);
    if (v14)
    {
      v15 = 0;
      do
      {
        v16 = *(_DWORD *)(v14 + 4 * v15++);
        if (v16)
          v17 = v16 == entry.timestamp;
        else
          v17 = 1;
      }
      while (!v17);
      if (!v16)
      {
LABEL_16:
        v10 = 1;
        goto LABEL_27;
      }
    }
    v18 = malloc_type_realloc(v13, 4 * v12 + 8, 0x100004052888210uLL);
    if (!v18)
    {
      free(v13);
      return krb5_enomem(a1);
    }
    v18[v12++] = entry.timestamp;
    v18[v12] = 0;
    v10 = 1;
    v13 = v18;
LABEL_27:
    krb5_kt_free_entry(a1, (uint64_t)&entry);
  }
  while (!krb5_kt_next_entry(a1, a3, &entry, cursor));
  krb5_kt_end_seq_get(a1, a3, cursor);
  v19 = *(void **)(a2 + 160);
  if (v13)
  {
    if (v19)
      free(v19);
    *(_QWORD *)(a2 + 160) = v13;
    if (!v10)
    {
      v8 = 2529639093;
      goto LABEL_5;
    }
    return 0;
  }
  v8 = 2529639093;
  if (!v19 && v10)
    return 0;
LABEL_5:
  sub_209697338(a1, v8, (uint64_t)a3, *(_QWORD *)(a2 + 8), 0, 0);
  return v8;
}

uint64_t sub_20969239C(krb5_context context, krb5_enctype enctype, uint64_t a3, uint64_t a4, uint64_t a5, krb5_keyblock **a6)
{
  _krb5_kt *v9;
  const krb5_principal_data *v10;
  uint64_t entry;
  krb5_keytab_entry v13;
  uint64_t v14;
  krb5_keytab keytab;

  v9 = *(_krb5_kt **)a3;
  v10 = *(const krb5_principal_data **)(a3 + 8);
  v14 = 0;
  keytab = 0;
  memset(&v13, 0, sizeof(v13));
  if (v9)
  {
    keytab = v9;
    entry = krb5_kt_get_entry(context, v9, v10, 0, enctype, &v13);
    if (!(_DWORD)entry)
    {
LABEL_6:
      entry = krb5_copy_keyblock(context, (const krb5_keyblock *)&v13.timestamp, a6);
      krb5_kt_free_entry(context, (uint64_t)&v13);
    }
  }
  else
  {
    entry = krb5_kt_default(context, &keytab);
    if (!(_DWORD)entry)
    {
      entry = krb5_kt_get_entry(context, keytab, v10, 0, enctype, &v13);
      krb5_kt_close(context, keytab);
      if (!(_DWORD)entry)
        goto LABEL_6;
    }
  }
  return entry;
}

uint64_t _krb5_init_creds_set_pku2u(_krb5_context *a1, uint64_t a2, const krb5_data *a3)
{
  krb5_data *v6;
  krb5_data **v7;
  uint64_t result;

  *(_DWORD *)(a2 + 384) |= 0x10u;
  *(_DWORD *)a2 = sub_2096BB6D0(0);
  v6 = *(krb5_data **)(a2 + 1072);
  if (v6)
    krb5_free_data(a1, v6);
  v7 = (krb5_data **)(a2 + 1072);
  if (a3)
  {
    result = krb5_copy_data(a1, a3, v7);
    if ((_DWORD)result)
      return result;
  }
  else
  {
    *v7 = 0;
  }
  return 0;
}

uint64_t krb5_init_creds_set_keyblock(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(a2 + 352) = a3;
  *(_QWORD *)(a2 + 360) = sub_209692510;
  return 0;
}

uint64_t sub_209692510(_krb5_context *a1, int a2, krb5_keyblock *a3, int a4, int a5, krb5_keyblock **a6)
{
  return krb5_copy_keyblock(a1, a3, a6);
}

uint64_t krb5_init_creds_set_fast_ccache(_krb5_context *a1, uint64_t a2, _krb5_ccache *a3)
{
  uint64_t krbtgt;
  krb5_data v8;
  krb5_creds *v9;

  v8.data = 0;
  v9 = 0;
  *(_QWORD *)&v8.magic = 0;
  krbtgt = _krb5_get_krbtgt(a1, a3, 0, &v9);
  if (!(_DWORD)krbtgt)
  {
    krbtgt = krb5_cc_get_config(a1, a3, v9->client, "fast_avail", &v8);
    krb5_free_creds(a1, v9);
    if ((_DWORD)krbtgt)
    {
      krbtgt = 22;
      krb5_set_error_message(a1, 22, "FAST not available for the KDC in the armor ccache");
    }
    else
    {
      *(_QWORD *)(a2 + 952) = a3;
      *(_DWORD *)(a2 + 940) |= 0x40u;
    }
  }
  return krbtgt;
}

uint64_t krb5_init_creds_step(_krb5_context *a1, uint64_t a2, const krb5_data *a3, _QWORD *a4, uint64_t a5, _QWORD *a6, _DWORD *a7)
{
  _OWORD *v14;
  int v15;
  int v16;
  uint64_t inited;
  const char *v18;
  _DWORD *v19;
  uint64_t *v20;
  uint64_t v21;
  unsigned int *v22;
  krb5_address *const *v23;
  int v24;
  void *v25;
  void *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  _QWORD *v30;
  _QWORD *v31;
  _QWORD *v32;
  krb5_address ***v33;
  int v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  char *v41;
  uint64_t v42;
  int v43;
  size_t v44;
  void *v45;
  void *v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  _DWORD *v55;
  krb5_error_code v56;
  const char *error_message;
  int v58;
  char v59;
  int v60;
  uint64_t v61;
  int v62;
  uint64_t v63;
  __int128 v64;
  krb5_keyblock *v65;
  void (*v66)(_krb5_context *, _QWORD, _QWORD, const char *, _QWORD, _QWORD);
  const char *v67;
  uint64_t v68;
  void (*v69)(_krb5_context *, uint64_t, uint64_t);
  _QWORD *v70;
  uint64_t v71;
  void (*v72)(_krb5_context *, uint64_t, uint64_t);
  void *v73;
  _QWORD *v74;
  _DWORD *v75;
  int v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  _QWORD *v98;
  uint64_t v99;
  uint64_t v100;
  unsigned int *v101;
  void (*v102)(_krb5_context *, uint64_t, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, uint64_t, unsigned int *);
  _DWORD *v103;
  size_t v104;
  void *v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  _QWORD *v110;
  _QWORD *v111;
  _QWORD *v112;
  _QWORD v113[2];
  _OWORD v114[25];
  _OWORD v115[7];
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  _QWORD v119[2];
  timeval v120;
  timeval v121;
  krb5_keyblock __s1[42];
  uint64_t v123;

  v123 = *MEMORY[0x24BDAC8D0];
  *(_QWORD *)&v121.tv_usec = 0;
  v121.tv_sec = 0;
  *(_QWORD *)&v120.tv_usec = 0;
  v120.tv_sec = 0;
  v119[1] = 0;
  v119[0] = 0;
  v118 = 0;
  v117 = 0;
  v116 = 0;
  memset(v115, 0, sizeof(v115));
  gettimeofday(&v121, 0);
  krb5_data_zero(a4);
  krb5_data_zero(v119);
  if (a6)
    *a6 = 0;
  v14 = (_OWORD *)(a2 + 208);
  if (*(_QWORD *)(a2 + 232))
  {
    v15 = 0;
    goto LABEL_5;
  }
  v19 = a7;
  v20 = *(uint64_t **)(a2 + 376);
  if (v20)
  {
    v21 = *(_QWORD *)(a2 + 1064);
    if (v21)
      sub_2096A3404((uint64_t)a1, v20, v21);
  }
  v23 = *(krb5_address *const **)(a2 + 152);
  v22 = *(unsigned int **)(a2 + 160);
  v24 = *(_DWORD *)a2;
  *(_QWORD *)(a2 + 320) = 0;
  *(_OWORD *)(a2 + 288) = 0u;
  *(_OWORD *)(a2 + 304) = 0u;
  *(_OWORD *)(a2 + 256) = 0u;
  *(_OWORD *)(a2 + 272) = 0u;
  *(_OWORD *)(a2 + 224) = 0u;
  *(_OWORD *)(a2 + 240) = 0u;
  *v14 = 0u;
  *(_QWORD *)(a2 + 208) = 0xA00000005;
  *(_DWORD *)(a2 + 224) = v24;
  v25 = malloc_type_malloc(0x18uLL, 0x10800407C14B876uLL);
  *(_QWORD *)(a2 + 232) = v25;
  if (!v25)
    goto LABEL_112;
  v26 = malloc_type_calloc(1uLL, 0x18uLL, 0x10800407C14B876uLL);
  *(_QWORD *)(a2 + 248) = v26;
  if (!v26)
    goto LABEL_112;
  v110 = a4;
  inited = _krb5_principal2principalname();
  if ((_DWORD)inited)
    goto LABEL_113;
  inited = sub_2096BB420();
  if ((_DWORD)inited)
    goto LABEL_113;
  inited = _krb5_principal2principalname();
  if ((_DWORD)inited)
    goto LABEL_113;
  if (*(_QWORD *)(a2 + 56))
  {
    v30 = malloc_type_malloc(8uLL, 0x100004000313F17uLL);
    *(_QWORD *)(a2 + 256) = v30;
    if (!v30)
      goto LABEL_112;
    *v30 = *(_QWORD *)(a2 + 56);
  }
  if (*(_QWORD *)(a2 + 64))
  {
    v31 = malloc_type_calloc(1uLL, 8uLL, 0x100004000313F17uLL);
    *(_QWORD *)(a2 + 264) = v31;
    *v31 = *(_QWORD *)(a2 + 64);
  }
  if (*(_QWORD *)(a2 + 72))
  {
    v32 = malloc_type_malloc(8uLL, 0x100004000313F17uLL);
    *(_QWORD *)(a2 + 272) = v32;
    if (v32)
    {
      *v32 = *(_QWORD *)(a2 + 72);
      goto LABEL_24;
    }
LABEL_112:
    inited = 12;
    krb5_set_error_message(a1, 12, "malloc: out of memory");
    goto LABEL_113;
  }
LABEL_24:
  *(_DWORD *)(a2 + 280) = 0;
  inited = _krb5_init_etype(a1, 2, (unsigned int *)(a2 + 288), (uint64_t *)(a2 + 296), v22, v27, v28, v29);
  if ((_DWORD)inited)
  {
LABEL_113:
    sub_2096BBA7C();
    *(_QWORD *)(a2 + 320) = 0;
    *(_OWORD *)(a2 + 288) = 0u;
    *(_OWORD *)(a2 + 304) = 0u;
    *(_OWORD *)(a2 + 256) = 0u;
    *(_OWORD *)(a2 + 272) = 0u;
    *(_OWORD *)(a2 + 224) = 0u;
    *(_OWORD *)(a2 + 240) = 0u;
    *v14 = 0u;
    sub_209691C80(a1, a2);
    return inited;
  }
  if (!v23)
  {
    v73 = malloc_type_malloc(0x10uLL, 0x1020040D5A9D86FuLL);
    *(_QWORD *)(a2 + 304) = v73;
    if (!v73)
      goto LABEL_112;
    inited = krb5_get_all_client_addrs(a1, (uint64_t)v73);
    if ((_DWORD)inited)
      goto LABEL_113;
    v74 = (_QWORD *)(a2 + 304);
    v75 = *(_DWORD **)(a2 + 304);
    if (*v75)
      goto LABEL_118;
    free(v75);
LABEL_117:
    *v74 = 0;
    goto LABEL_118;
  }
  if (!*(_DWORD *)v23)
  {
    v74 = (_QWORD *)(a2 + 304);
    goto LABEL_117;
  }
  v33 = (krb5_address ***)malloc_type_malloc(0x10uLL, 0x1020040D5A9D86FuLL);
  *(_QWORD *)(a2 + 304) = v33;
  if (!v33)
    goto LABEL_112;
  inited = krb5_copy_addresses(a1, v23, v33);
  if ((_DWORD)inited)
    goto LABEL_113;
LABEL_118:
  *(_QWORD *)(a2 + 216) = 0;
  *(_QWORD *)(a2 + 312) = 0;
  *(_QWORD *)(a2 + 320) = 0;
  v76 = *(_DWORD *)(a2 + 940);
  if ((v76 & 0x140) == 0)
    *(_DWORD *)(a2 + 940) = v76 | 0x80;
  *(_QWORD *)(a2 + 1048) = heim_array_create();
  a7 = v19;
  a4 = v110;
  if (*(_QWORD *)(a2 + 360) || *(_QWORD *)(a2 + 352) || *(_QWORD *)(a2 + 904))
  {
    if (*(_QWORD *)(a2 + 376))
    {
LABEL_126:
      sub_209694930((uint64_t)a1, a2, 17, v77, v78, v79, v80, v81);
      sub_209694930((uint64_t)a1, a2, 15, v92, v93, v94, v95, v96);
      goto LABEL_127;
    }
    sub_209694930((uint64_t)a1, a2, 250, v77, v78, v79, v80, v81);
    sub_209694930((uint64_t)a1, a2, 138, v82, v83, v84, v85, v86);
    sub_209694930((uint64_t)a1, a2, 2, v87, v88, v89, v90, v91);
  }
  if (*(_QWORD *)(a2 + 376))
    goto LABEL_126;
LABEL_127:
  v15 = 1;
LABEL_5:
  v16 = *(_DWORD *)(a2 + 328);
  if (v16 >= 11)
  {
    inited = 2529639135;
    v108 = *(unsigned int *)(a2 + 328);
    v18 = "Looping %d times while getting initial credentials";
LABEL_7:
    krb5_set_error_message(a1, inited, v18, v108);
    return inited;
  }
  v34 = v16 + 1;
  *(_DWORD *)(a2 + 328) = v34;
  sub_20969D1E8((uint64_t)a1, 5, "krb5_get_init_creds: loop %d", v34);
  if (a3 && *(_QWORD *)&a3->magic)
  {
    memset(v114, 0, sizeof(v114));
    sub_20969D1E8((uint64_t)a1, 5, "krb5_get_init_creds: processing input");
    if (sub_2096BBCAC())
    {
      v111 = a4;
      sub_20969D1E8((uint64_t)a1, 5, "krb5_get_init_creds: got an KRB-ERROR from KDC");
      sub_2096BC0D0();
      v40 = krb5_rd_error(a1, a3, (krb5_error **)(a2 + 504));
      if ((_DWORD)v40)
      {
        inited = v40;
        if (*(_QWORD *)&a3->magic)
        {
          if (*a3->data == 4)
            inited = 2529639131;
          else
            inited = v40;
        }
        v41 = "krb5_get_init_creds: failed to read error";
        v42 = (uint64_t)a1;
        v43 = 5;
        goto LABEL_39;
      }
      v55 = (_DWORD *)(a2 + 488);
      sub_2096BB9D4();
      *(_QWORD *)(a2 + 488) = 0;
      *(_QWORD *)(a2 + 496) = 0;
      if (*(_QWORD *)(a2 + 600))
      {
        v56 = sub_2096BB9B4();
        if (v56)
          sub_20969D22C((uint64_t *)a1, 5, v56, "Failed to decode METHOD-DATA");
      }
      inited = sub_2096B78BC(a1, a2 + 936, a2 + 488, a2 + 504);
      if ((_DWORD)inited)
        return inited;
      inited = krb5_error_from_rd_error(a1, a2 + 504, (uint64_t *)(a2 + 8));
      if (_krb5_have_debug((_BOOL8)a1))
      {
        error_message = krb5_get_error_message(a1, inited);
        sub_20969D1E8((uint64_t)a1, 5, "krb5_get_init_creds: KRB-ERROR %d/%s", inited, error_message);
        krb5_free_error_message(a1, error_message);
      }
      if ((int)inited <= -1765328360)
      {
        if ((_DWORD)inited != -1765328370)
        {
          if ((_DWORD)inited == -1765328361)
          {
            if ((*(_BYTE *)(a2 + 444) & 1) == 0)
            {
              v66 = *(void (**)(_krb5_context *, _QWORD, _QWORD, const char *, _QWORD, _QWORD))(a2 + 904);
              if (v66)
              {
                *(_BYTE *)(a2 + 444) |= 1u;
                v66(a1, *(_QWORD *)(a2 + 912), 0, "Password has expired", 0, 0);
                v67 = *(const char **)(a2 + 176);
                if (v67 && !strcmp(v67, "kadmin/changepw"))
                  return 2529638935;
                gettimeofday(&v120, 0);
                sub_2096D4088((uint64_t)&v120, (uint64_t)&v121);
                sub_2096D4028(a2 + 1080, (uint64_t)&v120);
                inited = sub_209693908(a1, *(krb5_principal_data **)(a2 + 8), *(char **)(a2 + 336), (char *)__s1, *(krb5_error_code (__cdecl **)(krb5_context, void *, const char *, const char *, int, krb5_prompt[]))(a2 + 904), *(void **)(a2 + 912), 0);
                if ((_DWORD)inited)
                  return inited;
                gettimeofday(&v121, 0);
                krb5_init_creds_set_password(a1, a2, (uint64_t)__s1);
LABEL_133:
                v68 = *(_QWORD *)(a2 + 1040);
                if (!v68)
                  goto LABEL_136;
                v69 = *(void (**)(_krb5_context *, uint64_t, uint64_t))(*(_QWORD *)(v68 + 32) + 48);
                if (!v69)
                  goto LABEL_136;
LABEL_135:
                v69(a1, a2, v68 + 48);
LABEL_136:
                v15 = 1;
                goto LABEL_137;
              }
            }
          }
          else if ((_DWORD)inited == -1765328360)
          {
            if ((*(_BYTE *)(a2 + 444) & 2) != 0)
            {
              if (!*v55)
              {
                sub_20969D1E8((uint64_t)a1, 10, "Disable allow_enc_pa_rep and trying again");
                *(_BYTE *)(a2 + 444) &= ~2u;
                goto LABEL_133;
              }
              inited = 2529638936;
              v41 = "Server send PA data with KRB-ERROR, so not a pre 1.7 MIT KDC and wont retry w/o ENC-PA-REQ";
            }
            else
            {
              v62 = *(_DWORD *)(a2 + 940);
              if ((v62 & 0x80) != 0)
              {
                inited = 2529638936;
                v41 = "FAST disabled and got preauth failed";
              }
              else
              {
                if ((v62 & 0x200) != 0)
                {
                  sub_20969D1E8((uint64_t)a1, 10, "preauth failed with Optimistic FAST, trying w/o FAST");
                  *(_DWORD *)(a2 + 940) = *(_DWORD *)(a2 + 940) & 0xFFFFFD7F | 0x80;
                  goto LABEL_133;
                }
                inited = 2529638936;
                v41 = "Preauth failed";
              }
            }
            v42 = (uint64_t)a1;
            v43 = 10;
LABEL_39:
            sub_20969D1E8(v42, v43, v41, v108, v109);
            return inited;
          }
          goto LABEL_89;
        }
        goto LABEL_72;
      }
      if ((int)inited <= -1765328317)
      {
        if ((_DWORD)inited != -1765328359)
        {
          if ((_DWORD)inited == -1765328347 && !*((_DWORD *)a1 + 27))
          {
            krb5_set_real_time(a1, *(_QWORD *)(a2 + 528), -1);
            v58 = *((_DWORD *)a1 + 27);
            sub_20969D1E8((uint64_t)a1, 10, "init_creds: err skew updateing kdc offset to %d", v58);
            if (!v58)
              return 2529638949;
            goto LABEL_133;
          }
          goto LABEL_89;
        }
LABEL_72:
        if (!*v55)
        {
          v18 = "Preauth required but no preauth options send by KDC";
          goto LABEL_7;
        }
        goto LABEL_137;
      }
      if ((_DWORD)inited != -1765328316)
      {
        if ((_DWORD)inited == -1765328293)
          goto LABEL_72;
LABEL_89:
        if ((*(_BYTE *)(a2 + 941) & 2) == 0)
          return inited;
        sub_20969D1E8((uint64_t)a1, 10, "Some other error %d failed with Optimistic FAST, trying w/o FAST", inited);
        *(_DWORD *)(a2 + 940) = *(_DWORD *)(a2 + 940) & 0xFFFFFD7F | 0x80;
        v68 = *(_QWORD *)(a2 + 1040);
        if (v68)
        {
          v69 = *(void (**)(_krb5_context *, uint64_t, uint64_t))(*(_QWORD *)(v68 + 32) + 48);
          if (!v69)
            goto LABEL_136;
          goto LABEL_135;
        }
LABEL_106:
        v15 = 1;
LABEL_137:
        a4 = v111;
        goto LABEL_138;
      }
      if ((*(_BYTE *)(a2 + 1) & 0x80) == 0)
        goto LABEL_89;
      *(_QWORD *)&__s1[0].magic = 0;
      v70 = *(_QWORD **)(a2 + 544);
      if (!v70)
      {
        inited = 2529638980;
        v18 = "Got a client referral, not but no realm";
        goto LABEL_7;
      }
      *(_QWORD *)&__s1[0].magic = *v70;
      sub_20969D1E8((uint64_t)a1, 5, "krb5_get_init_creds: referral to realm %s", *(const char **)&__s1[0].magic);
      if (!krb5_principal_is_krbtgt((uint64_t)a1, *(_QWORD *)(a2 + 16)))
      {
LABEL_99:
        free(*(void **)(a2 + 240));
        inited = sub_2096BB420();
        if ((_DWORD)inited)
          return inited;
        inited = krb5_principal_set_realm(a1, *(_QWORD *)(a2 + 8), **(char ***)(a2 + 544));
        if ((_DWORD)inited)
          return inited;
        if (!krb5_unparse_name(a1, *(krb5_const_principal *)(a2 + 8), (char **)__s1))
        {
          sub_20969D1E8((uint64_t)a1, 5, "krb5_get_init_creds: got referal to %s", *(const char **)&__s1[0].magic);
          krb5_xfree(*(void **)&__s1[0].magic);
        }
        v71 = *(_QWORD *)(a2 + 1040);
        if (v71)
        {
          v72 = *(void (**)(_krb5_context *, uint64_t, uint64_t))(*(_QWORD *)(v71 + 32) + 48);
          if (v72)
            v72(a1, a2, v71 + 48);
        }
        goto LABEL_106;
      }
      free(*(void **)(*(_QWORD *)(*(_QWORD *)(a2 + 16) + 16) + 8));
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 16) + 16) + 8) = strdup(*(const char **)&__s1[0].magic);
      if (*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 16) + 16) + 8))
      {
        sub_2096BB484();
        inited = _krb5_principal2principalname();
        if ((_DWORD)inited)
          return inited;
        goto LABEL_99;
      }
      return 12;
    }
    v44 = sub_2096BB7F4();
    v113[0] = v44;
    v45 = malloc_type_malloc(v44, 0xBBC010A0uLL);
    v113[1] = v45;
    if (!v45)
      return 12;
    v46 = v45;
    v47 = sub_2096BB7D4();
    if ((_DWORD)v47)
    {
      inited = v47;
      free(v46);
      return inited;
    }
    if (v44 != v117)
      heim_abort("ASN.1 internal error:data.length == size", v48, v49, v50, v51, v52, v53, v54, v108);
    inited = sub_2096B7B24(a1, *(_DWORD *)(a2 + 184), (uint64_t)v113, a2 + 936, (uint64_t)v114);
    krb5_data_free(v113);
    if ((_DWORD)inited)
      return inited;
    if ((*(_DWORD *)a2 & 0x8000) != 0)
      v59 = 30;
    else
      v59 = 24;
    v60 = *(_DWORD *)(a2 + 384);
    v61 = sub_209693574((uint64_t *)a1, a2, (uint64_t *)(a2 + 8), a2 + 208, (uint64_t)v114, a5);
    if ((_DWORD)v61)
    {
LABEL_62:
      inited = v61;
      sub_2096BBCCC();
      return inited;
    }
    if (*(_QWORD *)(a2 + 1016))
    {
      memset(__s1, 0, 24);
      sub_20969D1E8((uint64_t)a1, 5, "krb5_get_init_creds: FAST strengthen_key");
      v61 = _krb5_fast_cf2(a1, *(const krb5_keyblock **)(a2 + 1016), "strengthenkey", *(const krb5_keyblock **)(a2 + 944), "replykey", __s1, 0);
      if ((_DWORD)v61)
        goto LABEL_62;
      *(_BYTE *)(a2 + 444) |= 4u;
      krb5_free_keyblock_contents(a1, *(krb5_keyblock **)(a2 + 944));
      v63 = *(_QWORD *)(a2 + 944);
      v64 = *(_OWORD *)&__s1[0].magic;
      *(_QWORD *)(v63 + 16) = __s1[0].contents;
      *(_OWORD *)v63 = v64;
    }
    sub_20969D1E8((uint64_t)a1, 5, "krb5_get_init_creds: extracting ticket");
    inited = sub_2096B1B94((uint64_t)a1, (uint64_t)v114, a2 + 8, *(const krb5_keyblock **)(a2 + 944), 3, 0, *(_DWORD *)(a2 + 184), v59 & 0xFEu | ((v60 & 4) != 0), a2 + 192, 0, 0);
    if (!(_DWORD)inited)
    {
      inited = sub_2096BBD0C();
      if (!(_DWORD)inited)
        inited = sub_2096936AC(a1, a2, (uint64_t)v114, (_DWORD *)(a2 + 24));
    }
    sub_20968F724();
    v65 = *(krb5_keyblock **)(a2 + 944);
    *(_DWORD *)(a2 + 1024) = v65->magic;
    if ((*(_BYTE *)(a2 + 444) & 4) != 0)
      *(_QWORD *)(a2 + 1032) = v65;
    else
      krb5_free_keyblock(a1, v65);
    *(_QWORD *)(a2 + 944) = 0;
    *(_DWORD *)(a2 + 384) |= 1u;
    *a7 = 0;
    sub_2096BBCCC();
    sub_2096BBD40();
    gettimeofday(&v120, 0);
    sub_2096D4088((uint64_t)&v120, (uint64_t)&v121);
    sub_2096D4028(a2 + 1080, (uint64_t)&v120);
    sub_20969D1E8((uint64_t)a1, 1, "krb5_get_init_creds: wc: %lld.%06d");
    return inited;
  }
LABEL_138:
  v112 = a4;
  if (*(_QWORD *)(a2 + 216))
  {
    sub_2096BB9D4();
    free(*(void **)(a2 + 216));
    *(_QWORD *)(a2 + 216) = 0;
  }
  inited = sub_2096B710C(a1, a2 + 936, *(const char **)(*(_QWORD *)(a2 + 8) + 24), v35, v36, v37, v38, v39);
  if (!(_DWORD)inited)
  {
    *(_DWORD *)(a2 + 280) = *(_DWORD *)(a2 + 184);
    v98 = malloc_type_calloc(1uLL, 0x10uLL, 0x1020040D5A9D86FuLL);
    *(_QWORD *)(a2 + 216) = v98;
    if (!v98)
    {
      inited = 12;
      krb5_set_error_message(a1, 12, "malloc: out of memory", v108);
      return inited;
    }
    *(_DWORD *)v98 = 0;
    v98[1] = 0;
    sub_209694A2C((uint64_t)a1, (unsigned int *)(a2 + 488));
    if (!v15)
    {
      v99 = sub_209694B18((uint64_t *)a1, a2, a2 + 208, 0, 0, a2 + 488, *(_QWORD *)(a2 + 216));
      if ((_DWORD)v99 == -1980176628)
      {
        sub_20969D1E8((uint64_t)a1, 0, "pamech need more stepping");
      }
      else
      {
        inited = v99;
        if ((_DWORD)v99)
          return inited;
        sub_20969D1E8((uint64_t)a1, 0, "pamech done step");
      }
    }
    v100 = 0;
    v101 = *(unsigned int **)(a2 + 216);
    do
    {
      if ((dword_253D3B3C8[v100 + 4] & 3) != 0)
      {
        v102 = *(void (**)(_krb5_context *, uint64_t, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, uint64_t, unsigned int *))&dword_253D3B3C8[v100 + 14];
        if (v102)
          v102(a1, a2, 0, 0, 0, 0, 0, a2 + 488, v101);
        else
          krb5_padata_add(a1, v101, dword_253D3B3C8[v100], 0, 0);
      }
      v100 += 18;
    }
    while (v100 != 342);
    v103 = *(_DWORD **)(a2 + 216);
    if (!*v103)
    {
      free(v103);
      *(_QWORD *)(a2 + 216) = 0;
    }
    inited = sub_2096BBA8C();
    if (!(_DWORD)inited)
    {
      inited = sub_2096B7400(a1, a2 + 936, 0, (uint64_t)v115);
      krb5_data_free(v119);
      if ((_DWORD)inited)
      {
LABEL_159:
        sub_2096BBA7C();
        return inited;
      }
      krb5_data_free((_QWORD *)(a2 + 192));
      v104 = sub_2096BBA6C();
      *(_QWORD *)(a2 + 192) = v104;
      v105 = malloc_type_malloc(v104, 0x369CB5B3uLL);
      *(_QWORD *)(a2 + 200) = v105;
      if (!v105)
      {
        inited = 12;
        goto LABEL_159;
      }
      v106 = sub_2096BBA4C();
      if ((_DWORD)v106)
      {
        inited = v106;
        free(*(void **)(a2 + 200));
        *(_QWORD *)(a2 + 200) = 0;
        goto LABEL_159;
      }
      sub_2096BBA7C();
      if (v118 != *(_QWORD *)(a2 + 192))
        krb5_abortx(a1, "internal error in ASN.1 encoder");
      v107 = *(_QWORD *)(a2 + 200);
      *v112 = v118;
      v112[1] = v107;
      *a7 = 1;
      if (a6)
        *a6 = *(_QWORD *)(*(_QWORD *)(a2 + 8) + 24);
      gettimeofday(&v120, 0);
      sub_2096D4088((uint64_t)&v120, (uint64_t)&v121);
      sub_2096D4028(a2 + 1080, (uint64_t)&v120);
      return 0;
    }
  }
  return inited;
}

uint64_t sub_209693574(uint64_t *a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  unsigned int *v12;
  uint64_t v13;
  int v14;
  uint64_t result;
  _OWORD v16[2];
  uint64_t v17;

  v17 = 0;
  memset(v16, 0, sizeof(v16));
  v12 = *(unsigned int **)(a5 + 8);
  if (v12)
  {
    sub_209694A2C((uint64_t)a1, v12);
    v13 = *(_QWORD *)(a5 + 8);
    v14 = *(_DWORD *)(a5 + 120);
    if (v13)
    {
      LODWORD(v16[0]) = *(_DWORD *)(a5 + 120);
      if (sub_2096945E4((uint64_t)a1, *a3, a4, (uint64_t)v16, v13))
        goto LABEL_8;
    }
  }
  else
  {
    v14 = *(_DWORD *)(a5 + 120);
  }
  if (*(_DWORD *)(a2 + 448)
    || (*(_DWORD *)(a2 + 448) = v14,
        *(_QWORD *)(a2 + 480) = 0,
        result = krb5_get_pw_salt((uint64_t)a1, *a3, a2 + 456),
        !(_DWORD)result))
  {
LABEL_8:
    result = sub_209694B18(a1, a2, a4, a5, a6, *(_QWORD *)(a5 + 8), 0);
    if ((_DWORD)result)
    {
      if ((_DWORD)result == -1980176628)
      {
        sub_20969D1E8((uint64_t)a1, 0, "In final stretch and pa require more stepping ?");
        return 2314790668;
      }
    }
    else
    {
      sub_20969D1E8((uint64_t)a1, 0, "final pamech done step");
      sub_2096946B4((_krb5_context *)a1, (uint64_t)v16);
      return 0;
    }
  }
  return result;
}

uint64_t sub_2096936AC(_krb5_context *a1, uint64_t a2, uint64_t a3, _DWORD *a4)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  const krb5_keyblock *v15;
  uint64_t v16;
  char v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  const char *v22;
  uint64_t v23;
  const char *v24;
  _QWORD v25[2];
  _OWORD v26[2];
  krb5_keyblock v27;
  krb5_keyblock v28;
  krb5_keyblock **v29;
  krb5_keyblock **v30;

  v29 = 0;
  v30 = 0;
  memset(&v28, 0, sizeof(v28));
  memset(&v27, 0, sizeof(v27));
  memset(v26, 0, sizeof(v26));
  v25[0] = 0;
  v25[1] = 0;
  v23 = 0;
  v24 = 0;
  v21 = 0;
  v22 = 0;
  v20 = 0;
  v19 = 0;
  krb5_keyblock_zero((uint64_t)&v27);
  krb5_keyblock_zero((uint64_t)&v28);
  v8 = *(_QWORD *)(a3 + 8);
  if (v8 && krb5_find_padata(*(_QWORD *)(v8 + 8), *(_DWORD *)v8, 147, &v19))
  {
    v15 = *(const krb5_keyblock **)(a2 + 944);
    if (!v15)
      heim_abort("must have a reply key at this stage:ctx->fast_state.reply_key != NULL", 0, v9, v10, v11, v12, v13, v14, v18);
    v16 = krb5_crypto_init(a1, v15, 0, &v30);
    if (!(_DWORD)v16)
    {
      v16 = sub_2096BB6E0();
      if (!(_DWORD)v16)
      {
        v16 = krb5_decrypt_EncryptedData(a1, (uint64_t)v30, 44, (uint64_t)v26, v25);
        sub_2096BB730();
        if (!(_DWORD)v16)
        {
          v16 = decode_EncryptionKey();
          if (!(_DWORD)v16)
          {
            v16 = krb5_crypto_init(a1, &v28, 0, &v29);
            if (!(_DWORD)v16)
            {
              v23 = 6;
              v24 = "PKINIT";
              v21 = 11;
              v22 = "KEYEXCHANGE";
              v16 = krb5_crypto_fx_cf2(a1, (uint64_t *)v29, (uint64_t *)v30, (uint64_t)&v23, (uint64_t)&v21, (char *)v28.magic, &v27);
              if (!(_DWORD)v16)
              {
                if (v27.magic == *a4 && !krb5_data_ct_cmp((uint64_t)&v27.length, (uint64_t)(a4 + 2)))
                {
                  v16 = 0;
                  *(_DWORD *)(a2 + 384) |= 0x20u;
                }
                else
                {
                  v16 = 2529639059;
                  krb5_set_error_message(a1, -1765328237, "PKINIT-KX session key doesn't match");
                }
              }
            }
          }
        }
      }
    }
    krb5_free_keyblock_contents(a1, &v28);
    krb5_free_keyblock_contents(a1, &v27);
    if (v30)
      krb5_crypto_destroy(a1, (uint64_t)v30);
    if (v29)
      krb5_crypto_destroy(a1, (uint64_t)v29);
  }
  else if ((*(_BYTE *)(a2 + 2) & 1) != 0 && *(_QWORD *)(a2 + 376))
  {
    v16 = 2529639059;
    krb5_set_error_message(a1, -1765328237, "Requested anonymous with PKINIT and KDC didn't set PKINIT_KX");
  }
  else
  {
    return 0;
  }
  return v16;
}

uint64_t sub_209693908(_krb5_context *a1, krb5_principal_data *a2, char *a3, char *a4, krb5_error_code (__cdecl *a5)(krb5_context, void *, const char *, const char *, int, krb5_prompt[]), void *a6, uint64_t a7)
{
  uint64_t init_creds_opt_alloc;
  char *data;
  char *v16;
  char *v17;
  krb5_get_init_creds_opt *opt;
  char *v20;
  krb5_data result_string;
  krb5_data result_code_string;
  int result_code;
  krb5_creds creds;
  _QWORD v25[2];
  _QWORD v26[2];
  char __s2[1024];
  char __s1[1024];
  const char *v29;
  int v30;
  _QWORD *v31;
  int v32;
  const char *v33;
  int v34;
  _QWORD *v35;
  int v36;
  uint64_t v37;

  v37 = *MEMORY[0x24BDAC8D0];
  result_code = 0;
  *(_QWORD *)&result_code_string.magic = 0;
  result_code_string.data = 0;
  *(_QWORD *)&result_string.magic = 0;
  result_string.data = 0;
  opt = 0;
  v20 = 0;
  memset(&creds, 0, 144);
  init_creds_opt_alloc = krb5_get_init_creds_opt_alloc(a1, &opt);
  if (!(_DWORD)init_creds_opt_alloc)
  {
    krb5_get_init_creds_opt_set_tkt_life(opt, 60);
    krb5_get_init_creds_opt_set_forwardable(opt, 0);
    krb5_get_init_creds_opt_set_proxiable(opt, 0);
    if (a7 && (*(_BYTE *)a7 & 0x40) != 0)
      krb5_get_init_creds_opt_set_preauth_list(opt, *(krb5_preauthtype **)(a7 + 64), *(_DWORD *)(a7 + 72));
    krb5_data_zero(&result_code_string);
    krb5_data_zero(&result_string);
    init_creds_opt_alloc = krb5_get_init_creds_password(a1, &creds, a2, a3, a5, a6, 0, "kadmin/changepw", opt);
    krb5_get_init_creds_opt_free(a1, opt);
    if ((_DWORD)init_creds_opt_alloc)
      goto LABEL_24;
    while (1)
    {
      v25[0] = 1024;
      v25[1] = __s1;
      v30 = 1;
      v29 = "New password: ";
      v31 = v25;
      v32 = 2;
      v26[0] = 1024;
      v26[1] = __s2;
      v34 = 1;
      v33 = "Repeat new password: ";
      v35 = v26;
      v36 = 3;
      if (((unsigned int (*)(_krb5_context *, void *, _QWORD, const char *, uint64_t, const char **))a5)(a1, a6, 0, "Changing password", 2, &v29))
      {
        init_creds_opt_alloc = 2529639044;
        goto LABEL_24;
      }
      if (!strcmp(__s1, __s2))
        break;
      bzero(__s1, 0x400uLL);
      bzero(__s2, 0x400uLL);
    }
    init_creds_opt_alloc = krb5_set_password(a1, &creds, __s1, 0, &result_code, &result_code_string, &result_string);
    if ((_DWORD)init_creds_opt_alloc)
      goto LABEL_24;
    if (result_code)
    {
      data = result_code_string.data;
      v16 = "";
      if (!*(_QWORD *)&result_code_string.magic)
        data = "";
      if (*(_QWORD *)&result_string.magic)
        v16 = result_string.data;
      if (asprintf(&v20, "Failed: %.*s %.*s: %d\n", result_code_string.magic, data, result_string.magic, v16, result_code) < 0)
      {
        init_creds_opt_alloc = 12;
LABEL_24:
        bzero(__s1, 0x400uLL);
        bzero(__s2, 0x400uLL);
        krb5_data_free(&result_string);
        krb5_data_free(&result_code_string);
        krb5_free_cred_contents(a1, &creds);
        return init_creds_opt_alloc;
      }
      v17 = v20;
    }
    else
    {
      v17 = strdup("Success");
      v20 = v17;
    }
    ((void (*)(_krb5_context *, void *, _QWORD, char *, _QWORD, _QWORD))a5)(a1, a6, 0, v17, 0, 0);
    if (result_code)
    {
      init_creds_opt_alloc = 25;
      krb5_set_error_message(a1, 25, "failed changing password: %s", v20);
    }
    else
    {
      strlcpy(a4, __s1, 0x400uLL);
      init_creds_opt_alloc = 0;
    }
    free(v20);
    goto LABEL_24;
  }
  return init_creds_opt_alloc;
}

uint64_t krb5_init_creds_get_creds(_krb5_context *a1, uint64_t a2, uint64_t a3)
{
  return krb5_copy_creds_contents(a1, a2 + 8, a3);
}

uint64_t krb5_init_creds_get_as_reply_key(_krb5_context *a1, uint64_t a2, krb5_keyblock *a3)
{
  const krb5_keyblock *v3;

  v3 = *(const krb5_keyblock **)(a2 + 1032);
  if (v3)
    return krb5_copy_keyblock_contents(a1, v3, a3);
  else
    return 2529638937;
}

uint64_t _krb5_init_creds_get_cred_endtime(uint64_t a1, uint64_t a2)
{
  return *(_QWORD *)(a2 + 64);
}

uint64_t _krb5_init_creds_get_cred_client(uint64_t a1, uint64_t a2)
{
  return *(_QWORD *)(a2 + 8);
}

uint64_t krb5_init_creds_set_nonce(uint64_t a1, uint64_t a2, int a3)
{
  *(_DWORD *)(a2 + 184) = a3;
  *(_DWORD *)(a2 + 188) = a3;
  return 0;
}

uint64_t krb5_init_creds_store_config(_krb5_context *a1, uint64_t a2, _krb5_ccache *a3)
{
  char *v6;
  uint64_t result;
  char *v8;
  krb5_data v9;

  v6 = *(char **)(a2 + 392);
  if (!v6
    || (*(_QWORD *)&v9.magic = strlen(*(const char **)(a2 + 392)),
        v9.data = v6,
        result = krb5_cc_set_config(a1, a3, 0, "lkdc-hostname", &v9),
        !(_DWORD)result))
  {
    v8 = *(char **)(a2 + 400);
    if (!v8)
      return 0;
    *(_QWORD *)&v9.magic = strlen(v8);
    v9.data = v8;
    result = krb5_cc_set_config(a1, a3, 0, "sitename", &v9);
    if (!(_DWORD)result)
      return 0;
  }
  return result;
}

uint64_t krb5_init_creds_store(krb5_context a1, uint64_t a2, krb5_ccache cache)
{
  krb5_principal_data *v5;
  krb5_creds *v6;
  uint64_t v8;
  __int128 v10;

  v6 = (krb5_creds *)(a2 + 8);
  v5 = *(krb5_principal_data **)(a2 + 8);
  if (v5)
  {
    v8 = krb5_cc_initialize(a1, cache, v5);
    if (!(_DWORD)v8)
    {
      v8 = krb5_cc_store_cred(a1, cache, v6);
      if (!(_DWORD)v8)
      {
        if ((*(_BYTE *)(a2 + 145) & 0x80) == 0)
          return 0;
        v10 = xmmword_24C1F22F8;
        v8 = krb5_cc_set_config(a1, cache, *(krb5_const_principal *)(a2 + 16), "fast_avail", (krb5_data *)&v10);
        if (!(_DWORD)v8)
          return 0;
      }
    }
  }
  else
  {
    v8 = 2529638937;
    krb5_set_error_message(a1, -1765328359, "init creds not completed yet");
  }
  return v8;
}

void krb5_init_creds_free(_krb5_context *a1, void *a2)
{
  sub_209691C80(a1, (uint64_t)a2);
  free(a2);
}

uint64_t krb5_init_creds_get(_krb5_context *a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t inited;
  char *v11;
  char *v12;
  uint64_t v14;
  timeval v15;
  timeval v16;
  char *v17;
  int v18;
  _QWORD v19[2];
  krb5_data v20;
  const void *v21;

  v20.data = 0;
  v21 = 0;
  *(_QWORD *)&v20.magic = 0;
  v19[0] = 0;
  v19[1] = 0;
  krb5_data_zero(&v20);
  krb5_data_zero(v19);
  inited = krb5_sendto_ctx_alloc((uint64_t)a1, (uint64_t)&v21, v4, v5, v6, v7, v8, v9);
  if (!(_DWORD)inited)
  {
    krb5_sendto_ctx_set_func((uint64_t)v21, (uint64_t)sub_2096AB744, 0);
    v11 = *(char **)(a2 + 392);
    if (v11)
      sub_2096AB528(a1, (uint64_t)v21, v11);
    v12 = *(char **)(a2 + 400);
    if (v12)
      sub_2096AB56C(a1, (uint64_t)v21, v12);
    if ((*(_BYTE *)(a2 + 444) & 8) != 0)
      krb5_sendto_set_delegated_app((uint64_t)a1, (uint64_t)v21, (_OWORD *)(a2 + 408), *(_DWORD *)(a2 + 424), *(char **)(a2 + 432));
    *(_QWORD *)&v16.tv_usec = 0;
    v17 = 0;
    *(_QWORD *)&v15.tv_usec = 0;
    v16.tv_sec = 0;
    v15.tv_sec = 0;
    v18 = 0;
    inited = krb5_init_creds_step(a1, a2, &v20, v19, 0, &v17, &v18);
    krb5_data_free(&v20);
    if (!(_DWORD)inited)
    {
      while (1)
      {
        if ((v18 & 1) == 0)
        {
          inited = 0;
          goto LABEL_9;
        }
        gettimeofday(&v16, 0);
        v14 = krb5_sendto_context((uint64_t)a1, (uint64_t)v21, v19, v17, &v20);
        if ((_DWORD)v14)
          break;
        gettimeofday(&v15, 0);
        sub_2096D4088((uint64_t)&v15, (uint64_t)&v16);
        sub_2096D4028(a2 + 1080, (uint64_t)&v15);
        *(_QWORD *)&v16.tv_usec = 0;
        v17 = 0;
        *(_QWORD *)&v15.tv_usec = 0;
        v16.tv_sec = 0;
        v15.tv_sec = 0;
        v18 = 0;
        inited = krb5_init_creds_step(a1, a2, &v20, v19, 0, &v17, &v18);
        krb5_data_free(&v20);
        if ((_DWORD)inited)
          goto LABEL_9;
      }
      inited = v14;
    }
  }
LABEL_9:
  if (v21)
    krb5_sendto_ctx_free((uint64_t)a1, v21);
  return inited;
}

krb5_error_code krb5_get_init_creds_password(krb5_context context, krb5_creds *creds, krb5_principal client, char *password, krb5_prompter_fct prompter, void *data, krb5_deltat start_time, char *in_tkt_service, krb5_get_init_creds_opt *k5_gic_options)
{
  uint64_t v10;
  uint64_t v11;
  krb5_error_code inited;
  char v18;
  _QWORD *v19;
  krb5_error_code v20;
  uint64_t v21;
  int v22;
  uint64_t v23;
  uint64_t v24;
  char *v25;
  uint64_t ImpersonateBundle;
  char *v27;
  __CFBundle *MainBundle;
  CFStringRef Identifier;
  CFStringRef v30;
  CFStringRef v31;
  uint64_t v32;
  int v33;
  krb5_principal_data *v34;
  xpc_object_t xarray;
  krb5_creds *v37;
  const krb5_principal_data *v38;
  unint64_t __s1;
  char *v40;
  char *v41;
  uint64_t v42;
  _BYTE *v43;
  _QWORD *v44;
  __int128 v45;
  __int128 v46;
  _BYTE v47[1024];
  uint64_t v48;

  v10 = *(_QWORD *)&start_time;
  v11 = (uint64_t)data;
  v48 = *MEMORY[0x24BDAC8D0];
  v44 = 0;
  inited = krb5_init_creds_init(context, client, (uint64_t)prompter, (uint64_t)data, *(uint64_t *)&start_time, k5_gic_options, &v44);
  if (!inited)
  {
    v38 = client;
    __s1 = (unint64_t)password;
    v37 = creds;
    inited = -1765328361;
    v18 = 1;
    while (1)
    {
      v19 = v44;
      v20 = krb5_init_creds_set_service(context, (uint64_t)v44, in_tkt_service);
      if (v20)
      {
LABEL_36:
        inited = v20;
        goto LABEL_37;
      }
      if (!prompter)
        break;
      v21 = __s1;
      if (!(__s1 | v19[42]))
      {
        v45 = 0u;
        v46 = 0u;
        v42 = 0;
        v43 = 0;
        v40 = 0;
        v41 = 0;
        krb5_unparse_name(context, v38, &v41);
        asprintf(&v40, "%s's Password: ", v41);
        free(v41);
        *(_QWORD *)&v45 = v40;
        v43 = v47;
        v42 = 1024;
        DWORD2(v45) = 1;
        *(_QWORD *)&v46 = &v42;
        DWORD2(v46) = 1;
        v22 = ((uint64_t (*)(krb5_context, uint64_t, _QWORD, _QWORD, uint64_t, __int128 *))prompter)(context, v11, 0, 0, 1, &v45);
        free(v40);
        if (v22)
        {
          bzero(v47, 0x400uLL);
          krb5_clear_error_message(context);
          inited = -1765328252;
          goto LABEL_37;
        }
        v21 = (uint64_t)v43;
      }
      if (v21)
        goto LABEL_11;
LABEL_12:
      __s1 = v21;
      v23 = v11;
      v24 = v10;
      v25 = in_tkt_service;
      ImpersonateBundle = HeimCredGetImpersonateBundle();
      if (ImpersonateBundle)
      {
        v27 = (char *)ImpersonateBundle;
        MainBundle = CFBundleGetMainBundle();
        if (MainBundle)
        {
          Identifier = CFBundleGetIdentifier(MainBundle);
          v30 = CFStringCreateWithCString(0, v27, 0x8000100u);
          v31 = v30;
          if (v30 && Identifier)
          {
            if (CFEqual(Identifier, v30))
            {
              sub_20969D1E8((uint64_t)context, 5, "Bundle identifiers match, not setting delegate");
              inited = -1765328361;
            }
            else
            {
              v45 = 0uLL;
              v32 = NEHelperCacheCopyAppUUIDMapping();
              inited = -1765328361;
              if (v32)
              {
                xarray = (xpc_object_t)v32;
                if (MEMORY[0x20BD129CC]() == MEMORY[0x24BDACF78] && xpc_array_get_count(xarray))
                  v45 = *(_OWORD *)xpc_array_get_uuid(xarray, 0);
                xpc_release(xarray);
              }
              krb5_init_creds_set_source_process((uint64_t)context, (uint64_t)v19, (unsigned __int8 *)&v45, 0, v27);
            }
LABEL_26:
            CFRelease(v31);
            goto LABEL_27;
          }
          inited = -1765328361;
          if (v30)
            goto LABEL_26;
        }
      }
LABEL_27:
      v20 = krb5_init_creds_get(context, v19);
      if (!v20)
      {
        krb5_process_last_request(context, (uint64_t)k5_gic_options, (uint64_t)v19);
        krb5_copy_creds_contents(context, (uint64_t)(v19 + 1), (uint64_t)v37);
        inited = 0;
        if (v19)
          goto LABEL_38;
        return inited;
      }
      if (v20 == -1765328361 && (v18 & 1) != 0)
      {
        in_tkt_service = v25;
        if (v25)
        {
          v33 = strcmp(v25, "kadmin/changepw");
          v34 = (krb5_principal_data *)v38;
          if (!prompter)
            goto LABEL_37;
          v10 = v24;
          if (!v33)
            goto LABEL_37;
        }
        else
        {
          v10 = v24;
          v34 = (krb5_principal_data *)v38;
          if (!prompter)
            goto LABEL_37;
        }
        v11 = v23;
        v20 = sub_209693908(context, v34, v19[42], &v45, prompter, v23, k5_gic_options);
        if (!v20)
        {
          sub_209691C80(context, (uint64_t)v19);
          free(v19);
          v20 = krb5_init_creds_init(context, v34, (uint64_t)prompter, v23, v10, k5_gic_options, &v44);
          v18 = 0;
          if (!v20)
            continue;
        }
      }
      goto LABEL_36;
    }
    v21 = __s1;
    if (!__s1)
      goto LABEL_12;
LABEL_11:
    v20 = krb5_init_creds_set_password(context, (uint64_t)v19, v21);
    if (v20)
      goto LABEL_36;
    goto LABEL_12;
  }
LABEL_37:
  v19 = v44;
  if (v44)
  {
LABEL_38:
    sub_209691C80(context, (uint64_t)v19);
    free(v19);
  }
  return inited;
}

uint64_t krb5_get_init_creds_keyblock(_krb5_context *a1, _OWORD *a2, krb5_principal_data *a3, uint64_t a4, uint64_t a5, const char *a6, krb5_get_init_creds_opt *a7)
{
  uint64_t inited;
  _QWORD *v13;
  _QWORD *v15;

  v15 = 0;
  *a2 = 0u;
  a2[1] = 0u;
  a2[2] = 0u;
  a2[3] = 0u;
  a2[4] = 0u;
  a2[5] = 0u;
  a2[6] = 0u;
  a2[7] = 0u;
  a2[8] = 0u;
  inited = krb5_init_creds_init(a1, a3, 0, 0, a5, a7, &v15);
  v13 = v15;
  if (!(_DWORD)inited)
  {
    inited = krb5_init_creds_set_service(a1, (uint64_t)v15, a6);
    if (!(_DWORD)inited)
    {
      v13[44] = a4;
      v13[45] = sub_209692510;
      inited = krb5_init_creds_get(a1, (uint64_t)v13);
      if (!(_DWORD)inited)
      {
        krb5_process_last_request(a1, (uint64_t)a7, (uint64_t)v13);
        krb5_copy_creds_contents(a1, (uint64_t)(v13 + 1), (uint64_t)a2);
      }
      goto LABEL_4;
    }
  }
  if (v13)
  {
LABEL_4:
    sub_209691C80(a1, (uint64_t)v13);
    free(v13);
  }
  return inited;
}

krb5_error_code krb5_get_init_creds_keytab(krb5_context context, krb5_creds *creds, krb5_principal client, krb5_keytab arg_keytab, krb5_deltat start_time, char *in_tkt_service, krb5_get_init_creds_opt *k5_gic_options)
{
  krb5_error_code inited;
  void *v13;
  void *v15;

  v15 = 0;
  *(_OWORD *)&creds->magic = 0u;
  *(_OWORD *)&creds->server = 0u;
  *(_OWORD *)&creds->keyblock.length = 0u;
  creds->times = 0u;
  *(_OWORD *)&creds->is_skey = 0u;
  creds->ticket = 0u;
  creds->second_ticket = 0u;
  *(_OWORD *)&creds->authdata = 0u;
  *(_OWORD *)&creds[1].client = 0u;
  inited = krb5_init_creds_init(context, client, 0, 0, *(uint64_t *)&start_time, k5_gic_options, &v15);
  v13 = v15;
  if (!inited)
  {
    inited = krb5_init_creds_set_service(context, (uint64_t)v15, in_tkt_service);
    if (!inited)
    {
      inited = krb5_init_creds_set_keytab(context, (uint64_t)v13, arg_keytab);
      if (!inited)
      {
        inited = krb5_init_creds_get(context, (uint64_t)v13);
        if (!inited)
        {
          krb5_process_last_request(context, (uint64_t)k5_gic_options, (uint64_t)v13);
          krb5_copy_creds_contents(context, (uint64_t)v13 + 8, (uint64_t)creds);
        }
      }
    }
  }
  if (v13)
  {
    sub_209691C80(context, (uint64_t)v13);
    free(v13);
  }
  return inited;
}

_DWORD *sub_2096945E4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  unint64_t v10;
  uint64_t *i;
  _DWORD *result;
  int v14;

  if (a5)
  {
    v10 = 0;
    for (i = &qword_253D3B3E8; ; i += 9)
    {
      v14 = 0;
      if (*i)
      {
        result = krb5_find_padata(*(_QWORD *)(a5 + 8), *(_DWORD *)a5, *((_DWORD *)i - 8), &v14);
        if (result)
        {
          *(_DWORD *)(a4 + 8) = *((_DWORD *)i - 8);
          result = (_DWORD *)((uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, _DWORD *))*i)(a1, a2, a3, a4, result + 2);
        }
        if (result)
          return result;
      }
      else
      {
        result = 0;
      }
      if (v10++ >= 0x12)
        return result;
    }
  }
  return 0;
}

double sub_2096946B4(_krb5_context *a1, uint64_t a2)
{
  krb5_data *v4;
  double result;
  __int128 v6;
  uint64_t v7;

  v6 = *(_OWORD *)(a2 + 8);
  v7 = *(_QWORD *)(a2 + 24);
  krb5_free_salt((uint64_t)a1, (uint64_t)&v6);
  v4 = *(krb5_data **)(a2 + 32);
  if (v4)
    krb5_free_data(a1, v4);
  *(_QWORD *)(a2 + 32) = 0;
  result = 0.0;
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  return result;
}

uint64_t sub_209694710(uint64_t a1, _krb5_context *a2, int a3, int a4, const void *a5, size_t a6, const krb5_data *a7)
{
  __int128 *v12;
  void *v13;
  krb5_data **v14;
  __int128 v16;
  uint64_t v17;

  *(_DWORD *)a1 = a3;
  *(_DWORD *)(a1 + 8) = a4;
  v12 = (__int128 *)(a1 + 8);
  v13 = malloc_type_malloc(a6 + 1, 0xE1C19B90uLL);
  *(_QWORD *)(a1 + 24) = v13;
  if (v13)
  {
    memcpy(v13, a5, a6);
    *(_BYTE *)(*(_QWORD *)(a1 + 24) + a6) = 0;
    *(_QWORD *)(a1 + 16) = a6;
    v14 = (krb5_data **)(a1 + 32);
    if (a7)
    {
      a7 = (const krb5_data *)krb5_copy_data(a2, a7, v14);
      if ((_DWORD)a7)
      {
        krb5_clear_error_message(a2);
        v16 = *v12;
        v17 = *((_QWORD *)v12 + 2);
        krb5_free_salt((uint64_t)a2, (uint64_t)&v16);
      }
    }
    else
    {
      *v14 = 0;
    }
  }
  else
  {
    krb5_clear_error_message(a2);
    return 12;
  }
  return (uint64_t)a7;
}

uint64_t sub_2096947EC(_krb5_context *a1, char *a2, const char *a3, uint64_t a4, __int128 *a5, void **a6)
{
  uint64_t v12;
  size_t v13;
  void *v14;
  uint64_t v15;
  void *v17[2];
  uint64_t v18;
  __int128 v19;

  v19 = 0uLL;
  if (_krb5_have_debug((_BOOL8)a1))
  {
    v17[0] = 0;
    v12 = krb5_enctype_to_string((krb5_enctype)a1, a2, (size_t)v17);
    if ((_DWORD)v12)
      return v12;
    sub_20969D1E8((uint64_t)a1, 5, "krb5_get_init_creds: using default_s2k_func: %s (%d)", (const char *)v17[0], (_DWORD)a2);
    free(v17[0]);
  }
  if (a3)
  {
    v13 = strlen(a3);
    if (a5)
    {
LABEL_6:
      v19 = *a5;
      goto LABEL_9;
    }
  }
  else
  {
    v13 = 0;
    if (a5)
      goto LABEL_6;
  }
  krb5_data_zero(&v19);
LABEL_9:
  v14 = malloc_type_malloc(0x18uLL, 0x10800404ACF7207uLL);
  *a6 = v14;
  if (!v14)
    return krb5_enomem(a1);
  *(_OWORD *)v17 = *(_OWORD *)a4;
  v18 = *(_QWORD *)(a4 + 16);
  v15 = krb5_string_to_key_data_salt_opaque(a1, (uint64_t)a2, v13, (uint64_t)a3, (__int128 *)v17, v19, *((uint64_t *)&v19 + 1), (uint64_t)v14);
  if ((_DWORD)v15)
  {
    free(*a6);
    *a6 = 0;
  }
  return v15;
}

void sub_209694930(uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v10;
  _DWORD *v11;
  int v12;
  int v13;
  uint64_t v14;
  const void *v15;
  unsigned int (*v16)(uint64_t, uint64_t, uint64_t);

  v10 = 0;
  v11 = &unk_253D3B380;
  do
  {
    v13 = v11[18];
    v11 += 18;
    v12 = v13;
    if (v10 > 0x11)
      break;
    ++v10;
  }
  while (v12 != a3);
  if (v12 == a3)
  {
    v14 = heim_uniq_alloc(*((_QWORD *)v11 + 3) + 55, (uint64_t)"heim-pa-mech-ctx", (uint64_t)sub_209694A14, a4, a5, a6, a7, a8);
    if (v14)
    {
      v15 = (const void *)v14;
      *(_QWORD *)(v14 + 32) = v11;
      v16 = (unsigned int (*)(uint64_t, uint64_t, uint64_t))*((_QWORD *)v11 + 5);
      if (!v16 || !v16(a1, a2, v14 + 48))
      {
        sub_20969D1E8(a1, 5, "Adding PA mech: %s", *((const char **)v11 + 1));
        heim_array_append_value(*(__CFArray **)(a2 + 1048), v15);
      }
      heim_release(v15);
    }
  }
}

uint64_t sub_209694A14(uint64_t result)
{
  uint64_t (*v1)(uint64_t);

  v1 = *(uint64_t (**)(uint64_t))(*(_QWORD *)(result + 32) + 64);
  if (v1)
    return v1(result + 48);
  return result;
}

uint64_t sub_209694A2C(uint64_t a1, unsigned int *a2)
{
  uint64_t result;
  unint64_t v5;
  uint64_t v6;
  const char *v7;

  result = _krb5_have_debug(a1);
  if ((_DWORD)result)
  {
    result = sub_20969D1E8(a1, 5, "KDC sent %d patypes", *a2);
    if (*a2)
    {
      v5 = 0;
      do
      {
        v6 = 0;
        while (dword_253D3B3C8[v6] != *(_DWORD *)(*((_QWORD *)a2 + 1) + 24 * v5))
        {
          v6 += 18;
          if (v6 == 342)
          {
            v7 = "unknown";
            goto LABEL_9;
          }
        }
        v7 = *(const char **)&dword_253D3B3C8[v6 + 2];
LABEL_9:
        result = sub_20969D1E8(a1, 5, "KDC sent PA-DATA type: %d (%s)", *(_DWORD *)(*((_QWORD *)a2 + 1) + 24 * v5++), v7);
      }
      while (v5 < *a2);
    }
  }
  return result;
}

uint64_t sub_209694B18(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v8;
  char *v14;
  char *v15;
  BOOL i;
  uint64_t v17;
  int v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  char *v25;
  uint64_t v26;
  _QWORD *v27;
  const char *v28;
  _DWORD *padata;
  int v32;

  v8 = a6;
  padata = 0;
  v32 = 0;
  v14 = "Stepping pa-mech: %s";
  v15 = "PA type %s returned %d";
  for (i = *(_QWORD *)(a2 + 1040) == 0; ; i = 1)
  {
    do
    {
      if (i)
      {
        if (!heim_array_get_length(*(CFArrayRef *)(a2 + 1048)))
        {
          sub_20969D1E8((uint64_t)a1, 0, "no more available_pa_mechs to try");
          return 2314790670;
        }
        *(_QWORD *)(a2 + 1040) = heim_array_copy_value(*(const __CFArray **)(a2 + 1048), 0);
        heim_array_delete_value(*(CFMutableArrayRef *)(a2 + 1048), 0);
      }
      v17 = *(_QWORD *)(*(_QWORD *)(a2 + 1040) + 32);
      v18 = *(_DWORD *)(v17 + 16);
      if (*(_QWORD *)(a2 + 984))
      {
        if ((v18 & 4) == 0)
        {
          sub_20969D1E8((uint64_t)a1, 0, "pa-mech %s dropped under FAST (not supported)");
LABEL_10:
          heim_release(*(CFTypeRef *)(a2 + 1040));
          v19 = 0;
          *(_QWORD *)(a2 + 1040) = 0;
          goto LABEL_15;
        }
      }
      else if ((v18 & 8) == 0)
      {
        sub_20969D1E8((uint64_t)a1, 0, "dropped pa-mech %s since not running under FAST");
        goto LABEL_10;
      }
      sub_20969D1E8((uint64_t)a1, 0, "pa-mech trying: %s, searching for %d", *(const char **)(v17 + 8), *(_DWORD *)v17);
      v32 = 0;
      if (v8)
        padata = krb5_find_padata(*(_QWORD *)(v8 + 8), *(_DWORD *)v8, **(_DWORD **)(*(_QWORD *)(a2 + 1040) + 32), &v32);
      else
        padata = 0;
      v19 = *(_QWORD *)(a2 + 1040);
LABEL_15:
      i = 1;
    }
    while (!v19);
    sub_20969D1E8((uint64_t)a1, 5, v14, *(_QWORD *)(*(_QWORD *)(v19 + 32) + 8));
    v20 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t, _DWORD *, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(*(_QWORD *)(a2 + 1040) + 32) + 56))(a1, a2, *(_QWORD *)(a2 + 1040) + 48, padata, a3, a4, a5, v8, a7);
    sub_20969D22C(a1, 10, v20, v15, *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 1040) + 32) + 8), v20);
    if (!(_DWORD)v20)
    {
      v21 = v15;
      v22 = a3;
      v23 = a5;
      v24 = a7;
      v25 = v14;
      v26 = *(_QWORD *)(a2 + 1040);
      v27 = *(_QWORD **)(v26 + 40);
      if (v27)
      {
        sub_20969D1E8((uint64_t)a1, 5, "Next PA type in set is: %s", *(const char **)(v27[4] + 8));
        v20 = 2314790668;
      }
      else
      {
        v28 = *(const char **)(*(_QWORD *)(v26 + 32) + 8);
        if (a4)
        {
          v20 = 0;
          *(_QWORD *)(a2 + 1056) = v28;
        }
        else
        {
          sub_20969D1E8((uint64_t)a1, 5, "PA %s done, but no ticket in sight!!!", v28);
          v20 = 2314790669;
        }
      }
      heim_retain(v27);
      heim_release(*(CFTypeRef *)(a2 + 1040));
      *(_QWORD *)(a2 + 1040) = v27;
      v14 = v25;
      a7 = v24;
      a5 = v23;
      a3 = v22;
      v15 = v21;
      v8 = a6;
    }
    if ((_DWORD)v20 != -1980176627)
      break;
    sub_20969D1E8((uint64_t)a1, 5, "Dropping PA type %s", *(const char **)(*(_QWORD *)(*(_QWORD *)(a2 + 1040) + 32) + 8));
    heim_release(*(CFTypeRef *)(a2 + 1040));
    *(_QWORD *)(a2 + 1040) = 0;
  }
  if ((_DWORD)v20 == -1980176628)
  {
    sub_20969D1E8((uint64_t)a1, 5, "Continue needed for %s", *(const char **)(*(_QWORD *)(*(_QWORD *)(a2 + 1040) + 32) + 8));
    return 2314790668;
  }
  else
  {
    if ((_DWORD)v20)
    {
      sub_20969D1E8((uint64_t)a1, 5, "Other error from mech %s: %d", *(const char **)(*(_QWORD *)(*(_QWORD *)(a2 + 1040) + 32) + 8), v20);
      heim_release(*(CFTypeRef *)(a2 + 1040));
      *(_QWORD *)(a2 + 1040) = 0;
    }
    return v20;
  }
}

krb5_error_code krb5_get_init_creds_opt_alloc(krb5_context context, krb5_get_init_creds_opt **opt)
{
  krb5_get_init_creds_opt *v4;
  krb5_get_init_creds_opt *v5;
  _DWORD *v6;
  krb5_error_code v7;

  *opt = 0;
  v4 = (krb5_get_init_creds_opt *)malloc_type_calloc(1uLL, 0x60uLL, 0x10300404DCE2E84uLL);
  if (v4)
  {
    v5 = v4;
    v6 = malloc_type_calloc(1uLL, 0x40uLL, 0x10F00401127319BuLL);
    *(_QWORD *)&v5[1].proxiable = v6;
    if (v6)
    {
      v7 = 0;
      *v6 = 1;
      *opt = v5;
    }
    else
    {
      v7 = 12;
      krb5_set_error_message(context, 12, "malloc: out of memory");
      free(v5);
    }
  }
  else
  {
    v7 = 12;
    krb5_set_error_message(context, 12, "malloc: out of memory");
  }
  return v7;
}

void krb5_get_init_creds_opt_free(krb5_context context, krb5_get_init_creds_opt *opt)
{
  int *v3;
  BOOL v4;

  if (opt)
  {
    v3 = *(int **)&opt[1].proxiable;
    if (v3)
    {
      v4 = *v3 == 1;
      if (*v3 >= 1)
      {
        --*v3;
        if (v4)
        {
          sub_2096A402C((uint64_t)opt);
          free(*(void **)&opt[1].proxiable);
        }
        *(_OWORD *)&opt->salt = 0u;
        *(_OWORD *)&opt[1].renew_life = 0u;
        *(_OWORD *)&opt->etype_list_length = 0u;
        *(_OWORD *)&opt->preauth_list = 0u;
        *(_OWORD *)&opt->flags = 0u;
        *(_OWORD *)&opt->proxiable = 0u;
        free(opt);
      }
    }
  }
}

void krb5_get_init_creds_opt_set_default_flags(_krb5_context *a1, const char *a2, const krb5_data *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  int v31;
  uint64_t v32;
  int ret_value;

  v32 = 0;
  ret_value = sub_2096951C4((uint64_t)a1, 1, (uint64_t)a3, (uint64_t)"forwardable", a5, a6, a7, a8);
  krb5_appdefault_BOOLean(a1, a2, a3, "forwardable", ret_value, &ret_value);
  v12 = ret_value;
  *(_DWORD *)a4 |= 4u;
  *(_DWORD *)(a4 + 24) = v12;
  ret_value = sub_2096951C4((uint64_t)a1, 0, (uint64_t)a3, (uint64_t)"proxiable", v13, v14, v15, v16);
  krb5_appdefault_BOOLean(a1, a2, a3, "proxiable", ret_value, &ret_value);
  v17 = ret_value;
  *(_DWORD *)a4 |= 8u;
  *(_DWORD *)(a4 + 28) = v17;
  krb5_appdefault_time(a1, a2, a3, "ticket_lifetime", 0, &v32);
  v23 = v32;
  if (v32
    || (v23 = sub_209695264((uint64_t)a1, (uint64_t)a3, (uint64_t)"ticket_lifetime", v18, v19, v20, v21, v22),
        (v32 = v23) != 0))
  {
    *(_DWORD *)a4 |= 1u;
    *(_QWORD *)(a4 + 8) = v23;
  }
  krb5_appdefault_time(a1, a2, a3, "renew_lifetime", 0, &v32);
  v29 = v32;
  if (v32
    || (v29 = sub_209695264((uint64_t)a1, (uint64_t)a3, (uint64_t)"renew_lifetime", v24, v25, v26, v27, v28),
        (v32 = v29) != 0))
  {
    *(_DWORD *)a4 |= 2u;
    *(_QWORD *)(a4 + 16) = v29;
  }
  krb5_appdefault_BOOLean(a1, a2, a3, "no-addresses", 1, &ret_value);
  v30 = *(_QWORD *)(a4 + 88);
  if (v30)
  {
    if (ret_value)
      v31 = 1;
    else
      v31 = 2;
    *(_DWORD *)(v30 + 40) = v31;
  }
  else
  {
    krb5_set_error_message(a1, 22, "%s on non extendable opt", "init_creds_opt_set_pac_req");
  }
}

BOOL sub_2096951C4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _BOOL8 result;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;

  result = krb5_config_get_BOOL_default(a1, 0, a2, a4, a5, a6, a7, a8, (uint64_t)"realms");
  if (result == (_DWORD)a2)
    return krb5_config_get_BOOL_default(a1, 0, a2, v11, v12, v13, v14, v15, (uint64_t)"libdefaults");
  return result;
}

void krb5_get_init_creds_opt_set_forwardable(krb5_get_init_creds_opt *opt, int forwardable)
{
  opt->flags |= 4u;
  LODWORD(opt->etype_list) = forwardable;
}

void krb5_get_init_creds_opt_set_proxiable(krb5_get_init_creds_opt *opt, int proxiable)
{
  opt->flags |= 8u;
  HIDWORD(opt->etype_list) = proxiable;
}

uint64_t sub_209695264(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t time;

  result = krb5_config_get_time(a1, 0, a3, a4, a5, a6, a7, a8, (uint64_t)"realms");
  if (result < 0)
  {
    time = krb5_config_get_time(a1, 0, v10, v11, v12, v13, v14, v15, (uint64_t)"libdefaults");
    return time & ~(time >> 63);
  }
  return result;
}

void krb5_get_init_creds_opt_set_tkt_life(krb5_get_init_creds_opt *opt, krb5_deltat tkt_life)
{
  opt->flags |= 1u;
  *(_QWORD *)&opt->renew_life = *(_QWORD *)&tkt_life;
}

void krb5_get_init_creds_opt_set_renew_life(krb5_get_init_creds_opt *opt, krb5_deltat renew_life)
{
  opt->flags |= 2u;
  *(_QWORD *)&opt->proxiable = *(_QWORD *)&renew_life;
}

uint64_t krb5_get_init_creds_opt_set_addressless(_krb5_context *a1, uint64_t a2, int a3)
{
  uint64_t v3;
  uint64_t v4;
  int v5;

  v3 = *(_QWORD *)(a2 + 88);
  if (v3)
  {
    v4 = 0;
    if (a3)
      v5 = 1;
    else
      v5 = 2;
    *(_DWORD *)(v3 + 40) = v5;
  }
  else
  {
    v4 = 22;
    krb5_set_error_message(a1, 22, "%s on non extendable opt", "init_creds_opt_set_pac_req");
  }
  return v4;
}

void krb5_get_init_creds_opt_set_etype_list(krb5_get_init_creds_opt *opt, krb5_enctype *etype_list, int etype_list_length)
{
  opt->flags |= 0x10u;
  opt->address_list = (krb5_address **)etype_list;
  LODWORD(opt->preauth_list) = etype_list_length;
}

void krb5_get_init_creds_opt_set_address_list(krb5_get_init_creds_opt *opt, krb5_address **addresses)
{
  opt->flags |= 0x20u;
  *(_QWORD *)&opt->preauth_list_length = addresses;
}

void krb5_get_init_creds_opt_set_preauth_list(krb5_get_init_creds_opt *opt, krb5_preauthtype *preauth_list, int preauth_list_length)
{
  opt->flags |= 0x40u;
  opt[1].flags = preauth_list_length;
  opt->salt = (krb5_data *)preauth_list;
}

void krb5_get_init_creds_opt_set_salt(krb5_get_init_creds_opt *opt, krb5_data *salt)
{
  opt->flags |= 0x80u;
  *(_QWORD *)&opt[1].renew_life = salt;
}

_DWORD *krb5_get_init_creds_opt_set_anonymous(_DWORD *result, int a2)
{
  *result |= 0x100u;
  result[8] = a2;
  return result;
}

uint64_t krb5_get_init_creds_opt_set_pa_password(_krb5_context *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  uint64_t v5;

  v4 = *(_QWORD *)(a2 + 88);
  if (v4)
  {
    v5 = 0;
    *(_QWORD *)(v4 + 8) = a3;
    *(_QWORD *)(v4 + 16) = a4;
  }
  else
  {
    v5 = 22;
    krb5_set_error_message(a1, 22, "%s on non extendable opt", "init_creds_opt_set_pa_password");
  }
  return v5;
}

uint64_t krb5_get_init_creds_opt_set_pac_request(_krb5_context *a1, uint64_t a2, int a3)
{
  uint64_t v3;
  uint64_t v4;
  int v5;

  v3 = *(_QWORD *)(a2 + 88);
  if (v3)
  {
    v4 = 0;
    if (a3)
      v5 = 1;
    else
      v5 = 2;
    *(_DWORD *)(v3 + 24) = v5;
  }
  else
  {
    v4 = 22;
    krb5_set_error_message(a1, 22, "%s on non extendable opt", "init_creds_opt_set_pac_req");
  }
  return v4;
}

void krb5_get_init_creds_opt_set_canonicalize(krb5_get_init_creds_opt *opt, int canonicalize)
{
  int v2;
  uint64_t v3;
  int v4;
  unsigned int v5;

  v3 = *(_QWORD *)(*(_QWORD *)&canonicalize + 88);
  if (v3)
  {
    v4 = *(_DWORD *)(v3 + 44);
    if (v2)
      v5 = v4 | 2;
    else
      v5 = v4 & 0xFFFFFFFD;
    *(_DWORD *)(v3 + 44) = v5;
  }
  else
  {
    krb5_set_error_message((krb5_context)opt, 22, "%s on non extendable opt", "init_creds_opt_set_canonicalize");
  }
}

uint64_t krb5_get_init_creds_opt_set_win2k(_krb5_context *a1, uint64_t a2, int a3)
{
  uint64_t v3;
  int v4;
  uint64_t v5;
  unsigned int v6;

  v3 = *(_QWORD *)(a2 + 88);
  if (v3)
  {
    v4 = *(_DWORD *)(v3 + 44);
    v5 = 0;
    if (a3)
      v6 = v4 | 0x4C;
    else
      v6 = v4 & 0xFFFFFFB3;
    *(_DWORD *)(v3 + 44) = v6;
  }
  else
  {
    v5 = 22;
    krb5_set_error_message(a1, 22, "%s on non extendable opt", "init_creds_opt_set_win2k");
  }
  return v5;
}

krb5_error_code krb5_get_init_creds_opt_set_process_last_req(krb5_context a1, krb5_get_init_creds_opt *a2, krb5_gic_process_last_req a3, void *a4)
{
  uint64_t v4;
  krb5_error_code v5;

  v4 = *(_QWORD *)&a2[1].proxiable;
  if (v4)
  {
    v5 = 0;
    *(_QWORD *)(v4 + 48) = a3;
    *(_QWORD *)(v4 + 56) = a4;
  }
  else
  {
    v5 = 22;
    krb5_set_error_message(a1, 22, "%s on non extendable opt", "init_creds_opt_set_win2k");
  }
  return v5;
}

_QWORD *krb5_keyblock_zero(uint64_t a1)
{
  *(_DWORD *)a1 = 0;
  return krb5_data_zero((_QWORD *)(a1 + 8));
}

void krb5_free_keyblock_contents(krb5_context a1, krb5_keyblock *a2)
{
  unsigned int *p_length;
  krb5_octet *contents;

  if (a2)
  {
    p_length = &a2->length;
    contents = a2->contents;
    if (contents)
      bzero(contents, *(_QWORD *)p_length);
    krb5_data_free(p_length);
    a2->magic = 0;
  }
}

void krb5_free_keyblock(krb5_context a1, krb5_keyblock *a2)
{
  if (a2)
  {
    krb5_free_keyblock_contents(a1, a2);
    free(a2);
  }
}

krb5_error_code krb5_copy_keyblock_contents(krb5_context a1, const krb5_keyblock *a2, krb5_keyblock *a3)
{
  return copy_EncryptionKey();
}

krb5_error_code krb5_copy_keyblock(krb5_context a1, const krb5_keyblock *a2, krb5_keyblock **a3)
{
  krb5_keyblock *v5;
  krb5_keyblock *v6;
  krb5_error_code v7;

  *a3 = 0;
  v5 = (krb5_keyblock *)malloc_type_calloc(1uLL, 0x18uLL, 0x10800404ACF7207uLL);
  if (v5)
  {
    v6 = v5;
    v7 = copy_EncryptionKey();
    if (v7)
      free(v6);
    else
      *a3 = v6;
  }
  else
  {
    v7 = 12;
    krb5_set_error_message(a1, 12, "malloc: out of memory");
  }
  return v7;
}

uint64_t krb5_keyblock_get_enctype(unsigned int *a1)
{
  return *a1;
}

uint64_t krb5_keyblock_init(_krb5_context *a1, char *a2, const void *a3, size_t a4, _QWORD *a5)
{
  int v8;
  uint64_t v10;
  uint64_t v12;

  v8 = (int)a2;
  v12 = 0;
  a5[1] = 0;
  a5[2] = 0;
  *a5 = 0;
  v10 = krb5_enctype_keysize(a1, a2, &v12);
  if (!(_DWORD)v10)
  {
    if (v12 == a4)
    {
      v10 = krb5_data_copy(a5 + 1, a3, a4);
      if ((_DWORD)v10)
        krb5_set_error_message(a1, v10, "malloc: out of memory");
      else
        *(_DWORD *)a5 = v8;
    }
    else
    {
      v10 = 2529639062;
      krb5_set_error_message(a1, -1765328234, "Encryption key %d is %lu bytes long, %lu was passed in");
    }
  }
  return v10;
}

uint64_t sub_2096957A8(_krb5_context *a1, const char *a2, uint64_t a3)
{
  _DWORD *v6;
  _DWORD *v7;
  char *v8;
  uint64_t v9;

  v6 = malloc_type_malloc(0x10uLL, 0x1010040A1D9428BuLL);
  if (!v6)
    goto LABEL_5;
  v7 = v6;
  v8 = strdup(a2);
  *(_QWORD *)v7 = v8;
  if (!v8)
  {
    free(v7);
LABEL_5:
    v9 = 12;
    krb5_set_error_message(a1, 12, "malloc: out of memory");
    return v9;
  }
  v9 = 0;
  v7[2] = 0;
  *(_QWORD *)(a3 + 88) = v7;
  return v9;
}

uint64_t sub_209695838(int a1, uint64_t a2, char *__dst, size_t __size)
{
  strlcpy(__dst, **(const char ***)(a2 + 88), __size);
  return 0;
}

uint64_t sub_209695860(uint64_t a1, uint64_t a2)
{
  void **v2;

  v2 = *(void ***)(a2 + 88);
  free(*v2);
  free(v2);
  return 0;
}

uint64_t sub_209695890(_krb5_context *a1, uint64_t a2)
{
  sub_209689AC4(a1, **(char ***)(a2 + 88));
  return 0;
}

uint64_t sub_2096958B0(_krb5_context *a1, uint64_t a2, uint64_t a3)
{
  return sub_209695FD0(a1, a2, 0x1000000, 0, a3);
}

uint64_t sub_2096958C0(_krb5_context *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return sub_209696214(a1, a2, a3, a4, 0, 0);
}

uint64_t sub_2096958CC(_krb5_context *a1, uint64_t a2, uint64_t a3)
{
  krb5_storage_free(*(_QWORD *)(a3 + 8));
  sub_2096899F8(a1, *(_DWORD *)a3);
  close(*(_DWORD *)a3);
  return 0;
}

uint64_t sub_20969590C(_krb5_context *a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v6;
  int v7;
  int v8;
  uint64_t v9;
  _QWORD *v10;
  _QWORD *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  const char *v19;
  int v20;
  int *v21;
  const char *v22;
  char *v23;
  uint64_t v24;
  uint64_t v25;
  _QWORD *v26;
  uint64_t v27;
  uint64_t v28;
  _BOOL4 is_flags;
  __int16 v30;
  uint64_t v31;
  _krb5_context *v32;
  krb5_error_code v33;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  unsigned int v41;
  unsigned int v42;
  int *v43;
  const char *v44;
  char *v45;
  const char *v46;
  char *v47;
  __int16 v48;
  unsigned int v49;
  size_t v50;
  void *v51;

  v6 = *(_QWORD *)(a2 + 88);
  v50 = 0;
  v51 = 0;
  v49 = 0;
  v7 = open(*(const char **)v6, 16777218);
  if ((v7 & 0x80000000) == 0)
  {
    v8 = v7;
    v48 = 0;
    sub_2096B7FDC(v7);
    v9 = sub_2096898E4(a1, v8, 1);
    if (!(_DWORD)v9)
    {
      v10 = krb5_storage_from_fd(v8);
      v11 = v10;
      if (!v10)
      {
        v19 = "out of memory";
        goto LABEL_26;
      }
      krb5_storage_set_eof_code((uint64_t)v10, -1765328202);
      if (!krb5_ret_int8((uint64_t)v11, (uint64_t)&v48 + 1))
      {
        if (HIBYTE(v48) != 5)
        {
          v18 = 2529639125;
          v46 = *(const char **)v6;
          v19 = "Bad version in keytab %s";
          goto LABEL_28;
        }
        v31 = krb5_ret_int8((uint64_t)v11, (uint64_t)&v48);
        if ((_DWORD)v31)
        {
          v18 = v31;
          v46 = *(const char **)v6;
          v19 = "failed reading tag from keytab %s";
          goto LABEL_28;
        }
        v25 = (char)v48;
        *(_DWORD *)(a2 + 96) = v25;
        goto LABEL_15;
      }
      v12 = sub_20969679C(a2, (uint64_t)v11);
      if ((_DWORD)v12)
      {
        v18 = v12;
        v46 = *(const char **)v6;
        v47 = strerror(v12);
        v19 = "%s: keytab is corrupted: %s";
LABEL_28:
        v32 = a1;
        v33 = v18;
        goto LABEL_29;
      }
LABEL_14:
      v25 = *(unsigned int *)(a2 + 96);
LABEL_15:
      sub_2096961C0(a1, (uint64_t)v11, v25, v13, v14, v15, v16, v17);
      v26 = krb5_storage_emem();
      if (v26)
      {
        v27 = (uint64_t)v26;
        v28 = *a3;
        is_flags = krb5_storage_is_flags((uint64_t)v26, 2);
        v30 = *(_WORD *)(v28 + 8);
        if (is_flags)
          ++v30;
        v18 = krb5_store_int16(v27, v30);
        if (!(_DWORD)v18)
        {
          v18 = sub_2096968C0(v27, *(char **)(v28 + 24));
          if (!(_DWORD)v18)
          {
            if (*(_DWORD *)(v28 + 8))
            {
              v35 = 0;
              while (1)
              {
                v36 = sub_2096968C0(v27, *(char **)(*(_QWORD *)(v28 + 16) + 8 * v35));
                if ((_DWORD)v36)
                  break;
                if (++v35 >= (unint64_t)*(unsigned int *)(v28 + 8))
                  goto LABEL_38;
              }
              v18 = v36;
            }
            else
            {
LABEL_38:
              if (krb5_storage_is_flags(v27, 4) || (v18 = krb5_store_int32(v27, *(_DWORD *)v28), !(_DWORD)v18))
              {
                v37 = krb5_store_int32(v27, *((_DWORD *)a3 + 10));
                if ((_DWORD)v37)
                {
                  v18 = v37;
                  krb5_set_error_message(a1, v37, "Failed storing timpstamp in keytab %s");
                }
                else
                {
                  v38 = krb5_store_int8(v27, *((_BYTE *)a3 + 8));
                  if ((_DWORD)v38)
                  {
                    v18 = v38;
                    krb5_set_error_message(a1, v38, "Failed storing kvno in keytab %s");
                  }
                  else
                  {
                    v39 = sub_2096967F0(a1, (const char **)v6, v27, (__int16 *)a3 + 8);
                    if ((_DWORD)v39)
                    {
                      v18 = v39;
                    }
                    else
                    {
                      if ((*(_BYTE *)(v6 + 8) & 1) != 0
                        || (v40 = krb5_store_int32(v27, *((_DWORD *)a3 + 2)), !(_DWORD)v40)
                        && (v40 = krb5_store_uint32(v27, *((unsigned int *)a3 + 11)), !(_DWORD)v40))
                      {
                        v18 = krb5_storage_to_data(v27, &v50);
                        krb5_storage_free(v27);
                        if (!(_DWORD)v18)
                        {
                          while (1)
                          {
                            if (krb5_ret_int32((uint64_t)v11, &v49) == -1765328202)
                            {
                              v42 = v50;
                              v49 = v50;
                              goto LABEL_59;
                            }
                            v41 = v49;
                            if ((v49 & 0x80000000) != 0)
                            {
                              v49 = -v49;
                              if ((signed int)-v41 >= (int)v50)
                                break;
                            }
                            krb5_storage_seek((uint64_t)v11);
                          }
                          krb5_storage_seek((uint64_t)v11);
                          v42 = v49;
LABEL_59:
                          v18 = krb5_store_int32((uint64_t)v11, v42);
                          if (krb5_storage_write((uint64_t)v11) < 0)
                          {
                            v43 = __error();
                            v18 = *v43;
                            v44 = *(const char **)v6;
                            v45 = strerror(*v43);
                            krb5_set_error_message(a1, v18, "Failed writing keytab block in keytab %s: %s", v44, v45);
                          }
                          bzero(v51, v50);
                          krb5_data_free(&v50);
                          goto LABEL_30;
                        }
                        v46 = *(const char **)v6;
                        v19 = "Failed converting keytab entry to memory block for keytab %s";
                        goto LABEL_28;
                      }
                      v18 = v40;
                      krb5_set_error_message(a1, v40, "Failed storing extended kvno in keytab %s");
                    }
                  }
                }
                goto LABEL_21;
              }
            }
          }
        }
        krb5_set_error_message(a1, v18, "Failed storing principal in keytab %s");
LABEL_21:
        krb5_storage_free(v27);
        goto LABEL_30;
      }
      v19 = "malloc: out of memory";
LABEL_26:
      v18 = 12;
      v32 = a1;
      v33 = 12;
LABEL_29:
      krb5_set_error_message(v32, v33, v19, v46, v47);
      goto LABEL_30;
    }
    goto LABEL_9;
  }
  v20 = open(*(const char **)v6, 16779778, 384);
  if ((v20 & 0x80000000) == 0)
  {
    v8 = v20;
    sub_2096B7FDC(v20);
    v9 = sub_2096898E4(a1, v8, 1);
    if (!(_DWORD)v9)
    {
      v11 = krb5_storage_from_fd(v8);
      krb5_storage_set_eof_code((uint64_t)v11, -1765328202);
      v24 = sub_20969679C(a2, (uint64_t)v11);
      if ((_DWORD)v24)
      {
        v18 = v24;
LABEL_30:
        krb5_storage_free((uint64_t)v11);
        sub_2096899F8(a1, v8);
        goto LABEL_31;
      }
      goto LABEL_14;
    }
LABEL_9:
    v18 = v9;
LABEL_31:
    close(v8);
    return v18;
  }
  v21 = __error();
  v18 = *v21;
  v22 = *(const char **)v6;
  v23 = strerror(*v21);
  krb5_set_error_message(a1, v18, "open(%s): %s", v22, v23);
  return v18;
}

uint64_t sub_209695DD8(_krb5_context *a1, _krb5_kt *a2, uint64_t a3)
{
  int v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  krb5_kt_cursor cursor;
  uint64_t v14;
  uint64_t v15;
  _OWORD v16[3];
  uint64_t v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 i;
  uint64_t v26;

  v26 = *MEMORY[0x24BDAC8D0];
  v17 = 0;
  memset(v16, 0, sizeof(v16));
  cursor = 0;
  v14 = 0;
  v15 = 0;
  v11 = 0;
  v12 = 0;
  if (sub_209695FD0(a1, (uint64_t)a2, 16777218, 1, (uint64_t)&cursor))
    goto LABEL_4;
  if (sub_209696214(a1, (uint64_t)a2, (uint64_t)v16, (uint64_t)&cursor, &v12, &v11))
  {
    krb5_kt_end_seq_get(a1, a2, &cursor);
LABEL_4:
    krb5_clear_error_message(a1);
    return 2529639093;
  }
  v7 = 0;
  do
  {
    if (krb5_kt_compare((uint64_t)a1, (uint64_t)v16, *(_DWORD **)a3, *(_DWORD *)(a3 + 8), *(_DWORD *)(a3 + 16)))
    {
      v8 = v14;
      krb5_storage_seek(v14);
      v9 = v11 - v12 - 4;
      krb5_store_int32(v8, 4 - (v11 - v12));
      v18 = 0u;
      v19 = 0u;
      v20 = 0u;
      v21 = 0u;
      v22 = 0u;
      v23 = 0u;
      v24 = 0u;
      for (i = 0u; v9; v9 -= v10)
      {
        if (v9 >= 0x80)
          v10 = 128;
        else
          v10 = v9;
        krb5_storage_write(v8);
      }
      v7 = 1;
    }
    krb5_kt_free_entry(a1, (uint64_t)v16);
  }
  while (!sub_209696214(a1, (uint64_t)a2, (uint64_t)v16, (uint64_t)&cursor, &v12, &v11));
  krb5_kt_end_seq_get(a1, a2, &cursor);
  if (!v7)
    goto LABEL_4;
  return 0;
}

uint64_t sub_209695F9C(_krb5_context *a1, const char *a2, uint64_t a3)
{
  uint64_t result;

  result = sub_2096957A8(a1, a2, a3);
  if (!(_DWORD)result)
    *(_DWORD *)(*(_QWORD *)(a3 + 88) + 8) |= 1u;
  return result;
}

uint64_t sub_209695FD0(_krb5_context *a1, uint64_t a2, int a3, int a4, uint64_t a5)
{
  const char **v10;
  int v11;
  int v12;
  int *v13;
  uint64_t v14;
  const char *v15;
  int v17;
  int v18;
  int *v19;
  _QWORD *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  const char *v29;
  char *v30;
  __int16 v31;

  v10 = *(const char ***)(a2 + 88);
  if ((a3 & 1) != 0)
    v11 = 2;
  else
    v11 = 4;
  if ((a3 & 2) != 0)
    v12 = 6;
  else
    v12 = v11;
  if (access(*v10, v12))
  {
    v13 = __error();
    v14 = *v13;
    v29 = *v10;
    v30 = strerror(*v13);
    v15 = "keytab %s access failed: %s";
LABEL_9:
    krb5_set_error_message(a1, v14, v15, v29, v30);
    return v14;
  }
  v17 = open(*v10, a3);
  *(_DWORD *)a5 = v17;
  if (v17 < 0)
  {
    v19 = __error();
    v14 = *v19;
    v29 = *v10;
    v30 = strerror(*v19);
    v15 = "keytab %s open failed: %s";
    goto LABEL_9;
  }
  sub_2096B7FDC(v17);
  v14 = sub_2096898E4(a1, *(_DWORD *)a5, a4);
  v18 = *(_DWORD *)a5;
  if ((_DWORD)v14)
  {
    close(v18);
  }
  else
  {
    v20 = krb5_storage_from_fd(v18);
    *(_QWORD *)(a5 + 8) = v20;
    if (v20)
    {
      v31 = 0;
      krb5_storage_set_eof_code((uint64_t)v20, -1765328202);
      v21 = krb5_ret_int8(*(_QWORD *)(a5 + 8), (uint64_t)&v31 + 1);
      if ((_DWORD)v21)
      {
        v14 = v21;
      }
      else
      {
        v22 = *(_QWORD *)(a5 + 8);
        if (HIBYTE(v31) != 5)
        {
          krb5_storage_free(v22);
          sub_2096899F8(a1, *(_DWORD *)a5);
          close(*(_DWORD *)a5);
          krb5_clear_error_message(a1);
          return 2529639125;
        }
        v14 = krb5_ret_int8(v22, (uint64_t)&v31);
        if (!(_DWORD)v14)
        {
          v28 = (char)v31;
          *(_DWORD *)(a2 + 96) = v28;
          sub_2096961C0(a1, *(_QWORD *)(a5 + 8), v28, v23, v24, v25, v26, v27);
          return v14;
        }
      }
      krb5_storage_free(*(_QWORD *)(a5 + 8));
      sub_2096899F8(a1, *(_DWORD *)a5);
      close(*(_DWORD *)a5);
      krb5_clear_error_message(a1);
    }
    else
    {
      sub_2096899F8(a1, *(_DWORD *)a5);
      close(*(_DWORD *)a5);
      v14 = 12;
      krb5_set_error_message(a1, 12, "malloc: out of memory");
    }
  }
  return v14;
}

uint64_t sub_2096961C0(_krb5_context *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v9;

  if ((_DWORD)a3 == 2)
    goto LABEL_5;
  if ((_DWORD)a3 != 1)
  {
    krb5_warnx(a1, "storage_set_flags called with bad vno (%d)", a3, a4, a5, a6, a7, a8, a3);
LABEL_5:
    v9 = 0;
    return krb5_storage_set_flags(a2, v9);
  }
  v9 = 7;
  return krb5_storage_set_flags(a2, v9);
}

uint64_t sub_209696214(_krb5_context *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5, _QWORD *a6)
{
  const char **v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  krb5_principal_data *v16;
  krb5_principal_data *v17;
  uint64_t v18;
  const char *v19;
  _BOOL4 is_flags;
  __int16 v22;
  uint64_t v23;
  char *v24;
  int v25;
  uint64_t v26;
  unint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  size_t v31;
  void *v32;
  uint64_t v33;
  uint64_t v34;
  int v35;
  const char *v36;
  _QWORD *v37;
  uint64_t v38;
  uint64_t v39;
  char v40;
  int v41;
  krb5_magic size;
  _WORD size_6[5];

  v11 = *(const char ***)(a2 + 88);
  v41 = 0;
  v40 = 0;
  v39 = 0;
  v12 = krb5_storage_seek(*(_QWORD *)(a4 + 8));
  v13 = krb5_ret_int32(*(_QWORD *)(a4 + 8), (unsigned int *)&v41);
  if (!(_DWORD)v13)
  {
    while (v41 < 0)
    {
      v12 = krb5_storage_seek(*(_QWORD *)(a4 + 8));
      v14 = krb5_ret_int32(*(_QWORD *)(a4 + 8), (unsigned int *)&v41);
      if ((_DWORD)v14)
        return v14;
    }
    v15 = *(_QWORD *)(a4 + 8);
    v16 = (krb5_principal_data *)malloc_type_calloc(1uLL, 0x20uLL, 0x10900408A8AD7E9uLL);
    if (!v16)
    {
      v13 = 12;
      krb5_set_error_message(a1, 12, "malloc: out of memory");
      goto LABEL_11;
    }
    v17 = v16;
    size_6[0] = 0;
    v18 = krb5_ret_int16(v15, size_6);
    if ((_DWORD)v18)
    {
      v13 = v18;
      v36 = *v11;
      v19 = "Failed decoding length of keytab principal in keytab file %s";
LABEL_8:
      krb5_set_error_message(a1, v13, v19, v36);
LABEL_9:
      krb5_free_principal(a1, v17);
LABEL_11:
      krb5_kt_free_entry(a1, a3);
LABEL_12:
      krb5_storage_seek(*(_QWORD *)(a4 + 8));
      return v13;
    }
    is_flags = krb5_storage_is_flags(v15, 2);
    v22 = size_6[0];
    if (is_flags)
      v22 = --size_6[0];
    if (v22 < 0)
    {
      v13 = 2529639094;
      krb5_set_error_message(a1, -1765328202, "Keytab principal contains invalid length in keytab %s");
      goto LABEL_9;
    }
    v23 = sub_2096966CC(a1, v15, &v17->data);
    if ((_DWORD)v23)
    {
      v13 = v23;
      v36 = *v11;
      v19 = "Can't read realm from keytab: %s";
      goto LABEL_8;
    }
    v24 = (char *)malloc_type_calloc(size_6[0], 8uLL, 0x10040436913F5uLL);
    v17->realm.data = v24;
    if (!v24)
    {
      v13 = 12;
      krb5_set_error_message(a1, 12, "malloc: out of memory");
      goto LABEL_9;
    }
    v37 = a6;
    v38 = a3;
    v25 = size_6[0];
    v17->realm.magic = size_6[0];
    if (v25)
    {
      v26 = 0;
      v27 = 0;
      while (1)
      {
        v28 = sub_2096966CC(a1, v15, &v17->realm.data[v26]);
        if ((_DWORD)v28)
          break;
        ++v27;
        v26 += 8;
        if (v27 >= v17->realm.magic)
          goto LABEL_26;
      }
      v13 = v28;
      krb5_set_error_message(a1, v28, "Can't read principal from keytab: %s", *v11);
      a3 = v38;
      goto LABEL_9;
    }
LABEL_26:
    if (krb5_storage_is_flags(v15, 4))
    {
      v17->magic = 0;
      a3 = v38;
    }
    else
    {
      size = 0;
      v30 = krb5_ret_int32(v15, (unsigned int *)&size);
      v17->magic = size;
      a3 = v38;
      if ((_DWORD)v30)
      {
        v13 = v30;
        v36 = *v11;
        v19 = "Can't read name-type from keytab: %s";
        goto LABEL_8;
      }
    }
    *(_QWORD *)a3 = v17;
    v13 = krb5_ret_uint32(*(_QWORD *)(a4 + 8), &v39);
    *(_DWORD *)(a3 + 40) = v39;
    if ((_DWORD)v13)
      goto LABEL_11;
    v13 = krb5_ret_int8(*(_QWORD *)(a4 + 8), (uint64_t)&v40);
    if ((_DWORD)v13)
      goto LABEL_11;
    *(_DWORD *)(a3 + 8) = v40;
    v29 = *(_QWORD *)(a4 + 8);
    size_6[0] = 0;
    v13 = krb5_ret_int16(v29, size_6);
    if ((_DWORD)v13
      || (*(_DWORD *)(a3 + 16) = size_6[0], LOWORD(size) = 0, v13 = krb5_ret_int16(v29, &size), (_DWORD)v13))
    {
LABEL_32:
      krb5_set_error_message(a1, v13, "Cant read keyblock from file %s");
      goto LABEL_11;
    }
    v31 = (__int16)size;
    *(_QWORD *)(a3 + 24) = (__int16)size;
    v32 = malloc_type_malloc(v31, 0xBF34AA18uLL);
    *(_QWORD *)(a3 + 32) = v32;
    if (!v32)
    {
      v13 = 12;
      krb5_set_error_message(a1, 12, "malloc: out of memory");
      goto LABEL_32;
    }
    v33 = krb5_storage_read(v29);
    if (v33 != (__int16)size)
    {
      if ((v33 & 0x8000000000000000) == 0)
      {
        v13 = 2529639094;
        a3 = v38;
        goto LABEL_32;
      }
      v13 = *__error();
      a3 = v38;
      if ((_DWORD)v13)
        goto LABEL_32;
    }
    v34 = v12 - krb5_storage_seek(*(_QWORD *)(a4 + 8));
    if (v41 + v34 + 4 < 4)
    {
      v13 = 0;
    }
    else
    {
      v13 = krb5_ret_int32(*(_QWORD *)(a4 + 8), (unsigned int *)&v39 + 1);
      if (!(_DWORD)v13 && HIDWORD(v39))
      {
        v13 = 0;
        *(_DWORD *)(v38 + 8) = HIDWORD(v39);
      }
    }
    if (v41 + v34 + 4 < 8)
    {
      v35 = 0;
    }
    else
    {
      v13 = krb5_ret_uint32(*(_QWORD *)(a4 + 8), &v39);
      if ((_DWORD)v13)
        goto LABEL_52;
      v35 = v39;
    }
    *(_DWORD *)(v38 + 44) = v35;
LABEL_52:
    *(_QWORD *)(v38 + 48) = 0;
    if (a5)
      *a5 = v12;
    if (v37)
      *v37 = v12 + v41 + 4;
    a3 = v38;
    if (!(_DWORD)v13)
      goto LABEL_12;
    goto LABEL_11;
  }
  return v13;
}

uint64_t sub_2096966CC(_krb5_context *a1, uint64_t a2, _QWORD *a3)
{
  uint64_t v6;
  void *v8;
  uint64_t v9;
  __int16 v10;

  v10 = 0;
  v6 = krb5_ret_int16(a2, &v10);
  if (!(_DWORD)v6)
  {
    v8 = malloc_type_malloc(v10 + 1, 0x8A8CC141uLL);
    *a3 = v8;
    if (v8)
    {
      v9 = krb5_storage_read(a2);
      v6 = 0;
      *(_BYTE *)(*a3 + v10) = 0;
      if (v9 != v10)
      {
        if (v9 < 0)
          return *__error();
        else
          return 2529639094;
      }
    }
    else
    {
      v6 = 12;
      krb5_set_error_message(a1, 12, "malloc: out of memory");
    }
  }
  return v6;
}

uint64_t sub_20969679C(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  int v5;

  result = krb5_store_int8(a2, 5);
  if (!(_DWORD)result)
  {
    v5 = *(_DWORD *)(a1 + 96);
    if (!v5)
    {
      LOBYTE(v5) = 2;
      *(_DWORD *)(a1 + 96) = 2;
    }
    return krb5_store_int8(a2, v5);
  }
  return result;
}

uint64_t sub_2096967F0(_krb5_context *a1, const char **a2, uint64_t a3, __int16 *a4)
{
  uint64_t v8;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  v8 = krb5_store_int16(a3, *a4);
  if (!(_DWORD)v8)
  {
    v10 = *((_QWORD *)a4 + 1);
    v11 = krb5_store_int16(a3, (__int16)v10);
    if ((v11 & 0x80000000) != 0)
    {
      v8 = v11;
    }
    else
    {
      v12 = krb5_storage_write(a3);
      if (v12 == v10)
        return 0;
      if (v12 < 0)
      {
        v8 = *__error();
        if (!(_DWORD)v8)
          return v8;
      }
      else
      {
        v8 = 2529639094;
      }
    }
  }
  krb5_set_error_message(a1, v8, "Cant store keyblock to file %s", *a2);
  return v8;
}

uint64_t sub_2096968C0(uint64_t a1, char *__s)
{
  size_t v3;
  uint64_t result;
  uint64_t v5;

  v3 = strlen(__s);
  result = krb5_store_int16(a1, (__int16)v3);
  if ((result & 0x80000000) == 0)
  {
    v5 = krb5_storage_write(a1);
    if (v5 == v3)
    {
      return 0;
    }
    else if (v5 < 0)
    {
      return *__error();
    }
    else
    {
      return 2529639094;
    }
  }
  return result;
}

uint64_t krb5_kt_register(uint64_t a1, __int128 *a2)
{
  uint64_t v4;
  char *v5;
  char *v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;

  if (strlen(*(const char **)a2) < 0x1E)
  {
    v5 = (char *)malloc_type_realloc(*(void **)(a1 + 264), 104 * *(int *)(a1 + 256) + 104, 0x10D00400BBDB9B3uLL);
    if (v5)
    {
      v4 = 0;
      v6 = &v5[104 * *(int *)(a1 + 256)];
      v7 = *a2;
      v8 = a2[2];
      *((_OWORD *)v6 + 1) = a2[1];
      *((_OWORD *)v6 + 2) = v8;
      *(_OWORD *)v6 = v7;
      v9 = a2[3];
      v10 = a2[4];
      v11 = a2[5];
      *((_QWORD *)v6 + 12) = *((_QWORD *)a2 + 12);
      *((_OWORD *)v6 + 4) = v10;
      *((_OWORD *)v6 + 5) = v11;
      *((_OWORD *)v6 + 3) = v9;
      *(_QWORD *)(a1 + 264) = v5;
      ++*(_DWORD *)(a1 + 256);
    }
    else
    {
      v4 = 12;
      krb5_set_error_message((krb5_context)a1, 12, "malloc: out of memory");
    }
  }
  else
  {
    v4 = 2529639091;
    krb5_set_error_message((krb5_context)a1, -1765328205, "can't register cache type, prefix too long");
  }
  return v4;
}

krb5_error_code krb5_kt_resolve(krb5_context a1, const char *a2, krb5_keytab *a3)
{
  const char *v4;
  char *v6;
  int v7;
  const char *v8;
  size_t v9;
  uint64_t v10;
  uint64_t v11;
  const char **v12;
  krb5_error_code v13;
  _OWORD *v14;
  void *v15;
  uint64_t v16;
  __int128 v17;
  __int128 v18;
  uint64_t v19;
  __int128 v20;
  __int128 v21;

  v4 = a2;
  v6 = strchr((char *)a2, 58);
  if (v6)
  {
    v7 = *(unsigned __int8 *)v4;
    if (v7 == 47)
      v8 = "FILE";
    else
      v8 = v4;
    if (v7 == 47)
      v9 = 4;
    else
      v9 = v6 - v4;
    if (v7 != 47)
      v4 = v6 + 1;
  }
  else
  {
    v8 = "FILE";
    v9 = 4;
  }
  v10 = *((unsigned int *)a1 + 64);
  if ((int)v10 < 1)
  {
    LODWORD(v11) = 0;
  }
  else
  {
    v11 = 0;
    v12 = (const char **)*((_QWORD *)a1 + 33);
    while (strncasecmp(v8, *v12, v9))
    {
      ++v11;
      v12 += 13;
      if (v10 == v11)
        goto LABEL_19;
    }
  }
  if ((_DWORD)v11 == (_DWORD)v10)
  {
LABEL_19:
    v13 = -1765328204;
    krb5_set_error_message(a1, -1765328204, "unknown keytab type %.*s");
  }
  else
  {
    v14 = malloc_type_malloc(0x68uLL, 0x10D00400BBDB9B3uLL);
    if (v14)
    {
      v15 = v14;
      v16 = *((_QWORD *)a1 + 33) + 104 * v11;
      v17 = *(_OWORD *)(v16 + 48);
      v18 = *(_OWORD *)(v16 + 64);
      v19 = *(_QWORD *)(v16 + 96);
      v14[5] = *(_OWORD *)(v16 + 80);
      v21 = *(_OWORD *)(v16 + 16);
      v20 = *(_OWORD *)(v16 + 32);
      *v14 = *(_OWORD *)v16;
      v14[1] = v21;
      v14[3] = v17;
      v14[4] = v18;
      v14[2] = v20;
      *((_QWORD *)v14 + 11) = 0;
      *((_QWORD *)v14 + 12) = v19;
      v13 = (*((uint64_t (**)(krb5_context, const char *, _OWORD *))v14 + 1))(a1, v4, v14);
      if (v13)
      {
        free(v15);
        v15 = 0;
      }
      *a3 = (krb5_keytab)v15;
    }
    else
    {
      v13 = 12;
      krb5_set_error_message(a1, 12, "malloc: out of memory");
    }
  }
  return v13;
}

krb5_error_code krb5_kt_default_name(krb5_context a1, char *a2, int a3)
{
  if (strlcpy(a2, *((const char **)a1 + 26), *(size_t *)&a3) < *(_QWORD *)&a3)
    return 0;
  krb5_clear_error_message(a1);
  return -1765328247;
}

uint64_t krb5_kt_default_modify_name(_krb5_context *a1, char *__dst, size_t __size)
{
  const char *v6;
  uint64_t v7;
  const char *v8;
  size_t v9;
  size_t v10;

  v6 = (const char *)*((_QWORD *)a1 + 27);
  if (!v6)
  {
    v6 = (const char *)*((_QWORD *)a1 + 26);
    if (!strncasecmp(v6, "ANY:", 4uLL))
    {
      v8 = v6 + 4;
      v9 = strcspn(v8, ",");
      if (v9 < __size)
      {
        v10 = v9;
        strlcpy(__dst, v8, __size);
        v7 = 0;
        __dst[v10] = 0;
        return v7;
      }
LABEL_7:
      v7 = 2529639049;
      krb5_clear_error_message(a1);
      return v7;
    }
  }
  if (strlcpy(__dst, v6, __size) >= __size)
    goto LABEL_7;
  return 0;
}

krb5_error_code krb5_kt_default(krb5_context a1, krb5_keytab *a2)
{
  return krb5_kt_resolve(a1, *((const char **)a1 + 26), a2);
}

krb5_error_code krb5_kt_read_service_key(krb5_context a1, krb5_pointer a2, krb5_principal a3, krb5_kvno a4, krb5_enctype a5, krb5_keyblock **a6)
{
  krb5_error_code entry;
  krb5_keytab v12;
  krb5_keytab_entry v14;
  uint64_t v15;
  krb5_keytab keytab;

  v15 = 0;
  keytab = 0;
  memset(&v14, 0, sizeof(v14));
  if (!a2)
    a2 = (krb5_pointer)*((_QWORD *)a1 + 26);
  entry = krb5_kt_resolve(a1, (const char *)a2, &keytab);
  if (!entry)
  {
    v12 = keytab;
    entry = krb5_kt_get_entry(a1, keytab, a3, a4, a5, &v14);
    (*((void (**)(krb5_context, krb5_keytab))v12 + 3))(a1, v12);
    *(_OWORD *)v12 = 0u;
    *((_OWORD *)v12 + 1) = 0u;
    *((_OWORD *)v12 + 2) = 0u;
    *((_OWORD *)v12 + 3) = 0u;
    *((_OWORD *)v12 + 4) = 0u;
    *((_OWORD *)v12 + 5) = 0u;
    *((_QWORD *)v12 + 12) = 0;
    free(v12);
    if (!entry)
    {
      entry = krb5_copy_keyblock(a1, (const krb5_keyblock *)&v14.timestamp, a6);
      krb5_kt_free_entry(a1, (uint64_t)&v14);
    }
  }
  return entry;
}

krb5_error_code krb5_kt_get_entry(krb5_context context, krb5_keytab keytab, krb5_const_principal principal, krb5_kvno vno, krb5_enctype enctype, krb5_keytab_entry *entry)
{
  char *v7;
  uint64_t (*v12)(krb5_context, krb5_keytab, krb5_const_principal, _QWORD, _QWORD, krb5_keytab_entry *);
  unsigned int (*v14)(krb5_context, krb5_keytab, krb5_kt_cursor *);
  int v15;
  BOOL v16;
  int v17;
  void (*v18)(krb5_context, krb5_keytab, krb5_kt_cursor *);
  krb5_error_code v19;
  void (*v20)(krb5_context, krb5_keytab, krb5_kt_cursor *);
  krb5_kt_cursor cursor[3];
  krb5_keytab_entry entrya;
  uint64_t v23;

  v7 = *(char **)&enctype;
  v12 = (uint64_t (*)(krb5_context, krb5_keytab, krb5_const_principal, _QWORD, _QWORD, krb5_keytab_entry *))*((_QWORD *)keytab + 5);
  if (v12)
    return v12(context, keytab, principal, *(_QWORD *)&vno, *(_QWORD *)&enctype, entry);
  v14 = (unsigned int (*)(krb5_context, krb5_keytab, krb5_kt_cursor *))*((_QWORD *)keytab + 6);
  if (v14)
  {
    v23 = 0;
    memset(&entrya, 0, sizeof(entrya));
    memset(cursor, 0, sizeof(cursor));
    if (!v14(context, keytab, cursor))
    {
      LODWORD(entry->principal) = 0;
      if (!krb5_kt_next_entry(context, keytab, &entrya, cursor))
      {
        if ((int)vno <= 0)
          v15 = --(char)vno;
        else
          v15 = vno;
        do
        {
          if (krb5_kt_compare((uint64_t)context, (uint64_t)&entrya, principal, 0, (int)v7))
          {
            if (LODWORD(entrya.principal) == vno
              || (SLODWORD(entrya.principal) <= 255 ? (v16 = v15 == LODWORD(entrya.principal)) : (v16 = 0), v16))
            {
              krb5_kt_copy_entry_contents(context, (uint64_t)&entrya, (uint64_t)entry);
              krb5_kt_free_entry(context, (uint64_t)&entrya);
              v20 = (void (*)(krb5_context, krb5_keytab, krb5_kt_cursor *))*((_QWORD *)keytab + 8);
              if (v20)
                v20(context, keytab, cursor);
              else
                krb5_set_error_message(context, -1980176636, "end_seq_get is not supported in the %s  keytab", *(const char **)keytab);
              return 0;
            }
            if (!vno)
            {
              v17 = (int)entry->principal;
              if (SLODWORD(entrya.principal) > v17)
              {
                if (v17)
                  krb5_kt_free_entry(context, (uint64_t)entry);
                krb5_kt_copy_entry_contents(context, (uint64_t)&entrya, (uint64_t)entry);
              }
            }
          }
          krb5_kt_free_entry(context, (uint64_t)&entrya);
        }
        while (!krb5_kt_next_entry(context, keytab, &entrya, cursor));
      }
      v18 = (void (*)(krb5_context, krb5_keytab, krb5_kt_cursor *))*((_QWORD *)keytab + 8);
      if (v18)
        v18(context, keytab, cursor);
      else
        krb5_set_error_message(context, -1980176636, "end_seq_get is not supported in the %s  keytab", *(const char **)keytab);
      if (LODWORD(entry->principal))
        return 0;
      v19 = -1765328203;
      sub_209697338(context, 2529639093, (uint64_t)keytab, (uint64_t)principal, v7, vno);
      return v19;
    }
  }
  else
  {
    krb5_set_error_message(context, -1980176636, "start_seq_get is not supported in the %s keytab type", *(const char **)keytab);
  }
  v19 = -1765328203;
  *((_DWORD *)context + 72) = -1765328203;
  return v19;
}

krb5_error_code krb5_kt_close(krb5_context context, krb5_keytab keytab)
{
  krb5_error_code v3;

  v3 = (*((uint64_t (**)(krb5_context))keytab + 3))(context);
  *(_OWORD *)keytab = 0u;
  *((_OWORD *)keytab + 1) = 0u;
  *((_OWORD *)keytab + 2) = 0u;
  *((_OWORD *)keytab + 3) = 0u;
  *((_OWORD *)keytab + 4) = 0u;
  *((_OWORD *)keytab + 5) = 0u;
  *((_QWORD *)keytab + 12) = 0;
  free(keytab);
  return v3;
}

uint64_t krb5_kt_free_entry(_krb5_context *a1, uint64_t a2)
{
  krb5_free_principal(a1, *(krb5_principal *)a2);
  krb5_free_keyblock_contents(a1, (krb5_keyblock *)(a2 + 16));
  *(_QWORD *)(a2 + 48) = 0;
  *(_OWORD *)(a2 + 16) = 0u;
  *(_OWORD *)(a2 + 32) = 0u;
  *(_OWORD *)a2 = 0u;
  return 0;
}

const char *__cdecl krb5_kt_get_type(krb5_context a1, krb5_keytab keytab)
{
  char *v2;
  size_t v3;

  strlcpy(v2, *(const char **)keytab, v3);
  return 0;
}

krb5_error_code krb5_kt_get_name(krb5_context context, krb5_keytab keytab, char *name, unsigned int namelen)
{
  return (*((uint64_t (**)(krb5_context))keytab + 2))(context);
}

uint64_t krb5_kt_get_full_name(_krb5_context *a1, uint64_t a2, char **a3)
{
  uint64_t v6;
  char v8[1024];
  char v9[30];
  uint64_t v10;

  v10 = *MEMORY[0x24BDAC8D0];
  *a3 = 0;
  __strlcpy_chk();
  v6 = (*(uint64_t (**)(_krb5_context *, uint64_t, char *, uint64_t))(a2 + 16))(a1, a2, v8, 1024);
  if (!(_DWORD)v6)
  {
    if (asprintf(a3, "%s:%s", v9, v8) == -1)
    {
      v6 = 12;
      krb5_set_error_message(a1, 12, "malloc: out of memory");
      *a3 = 0;
    }
    else
    {
      return 0;
    }
  }
  return v6;
}

uint64_t krb5_kt_destroy(uint64_t a1, uint64_t (**a2)(void))
{
  uint64_t v4;

  v4 = a2[4]();
  ((void (*)(uint64_t, uint64_t (**)(void)))a2[3])(a1, a2);
  *(_OWORD *)a2 = 0u;
  *((_OWORD *)a2 + 1) = 0u;
  *((_OWORD *)a2 + 2) = 0u;
  *((_OWORD *)a2 + 3) = 0u;
  *((_OWORD *)a2 + 4) = 0u;
  *((_OWORD *)a2 + 5) = 0u;
  a2[12] = 0;
  free(a2);
  return v4;
}

uint64_t krb5_kt_compare(uint64_t a1, uint64_t a2, _DWORD *a3, int a4, int a5)
{
  unsigned int (*v10)(uint64_t, uint64_t, _DWORD *);
  uint64_t result;
  unsigned int *v12;
  uint64_t v13;
  unint64_t v14;

  if (!a3)
    return (!a4 || *(_DWORD *)(a2 + 8) == a4) && (!a5 || *(_DWORD *)(a2 + 16) == a5);
  if (*a3 == -1202)
  {
    v10 = (unsigned int (*)(uint64_t, uint64_t, _DWORD *))krb5_principal_compare_any_realm;
    result = ((uint64_t (*)(uint64_t, _QWORD))krb5_principal_compare_any_realm)(a1, *(_QWORD *)a2);
  }
  else
  {
    v10 = (unsigned int (*)(uint64_t, uint64_t, _DWORD *))krb5_principal_compare;
    result = ((uint64_t (*)(uint64_t, _QWORD))krb5_principal_compare)(a1, *(_QWORD *)a2);
  }
  if ((_DWORD)result)
  {
    v12 = *(unsigned int **)(a2 + 48);
    if (v12 && *v12)
    {
      v13 = 0;
      v14 = 0;
      while (!v10(a1, *((_QWORD *)v12 + 1) + v13, a3))
      {
        ++v14;
        v12 = *(unsigned int **)(a2 + 48);
        v13 += 32;
        if (v14 >= *v12)
          return (!a4 || *(_DWORD *)(a2 + 8) == a4) && (!a5 || *(_DWORD *)(a2 + 16) == a5);
      }
      return 0;
    }
    return (!a4 || *(_DWORD *)(a2 + 8) == a4) && (!a5 || *(_DWORD *)(a2 + 16) == a5);
  }
  return result;
}

uint64_t sub_209697338(_krb5_context *a1, uint64_t a2, uint64_t a3, uint64_t a4, char *a5, int a6)
{
  const char *v11;
  const char *v12;
  void *v14;
  void *v15;
  char __str[25];
  char v17[256];
  uint64_t v18;

  v18 = *MEMORY[0x24BDAC8D0];
  v14 = 0;
  v15 = 0;
  krb5_unparse_name_fixed(a1, a4, (uint64_t)v17, 0x100uLL);
  krb5_kt_get_full_name(a1, a3, (char **)&v15);
  if ((_DWORD)a5)
    krb5_enctype_to_string((krb5_enctype)a1, a5, (size_t)&v14);
  if (a6)
    snprintf(__str, 0x19uLL, "(kvno %d)", a6);
  else
    __str[0] = 0;
  v11 = (const char *)v15;
  if (!v15)
    v11 = "unknown keytab";
  v12 = (const char *)v14;
  if (!v14)
    v12 = "unknown enctype";
  krb5_set_error_message(a1, a2, "Failed to find %s%s in keytab %s (%s)", v17, __str, v11, v12);
  free(v15);
  if (v14)
    free(v14);
  return a2;
}

krb5_error_code krb5_kt_start_seq_get(krb5_context context, krb5_keytab keytab, krb5_kt_cursor *cursor)
{
  uint64_t (*v3)(krb5_context);

  v3 = (uint64_t (*)(krb5_context))*((_QWORD *)keytab + 6);
  if (v3)
    return v3(context);
  krb5_set_error_message(context, -1980176636, "start_seq_get is not supported in the %s keytab type", *(const char **)keytab);
  return -1980176636;
}

krb5_error_code krb5_kt_next_entry(krb5_context context, krb5_keytab keytab, krb5_keytab_entry *entry, krb5_kt_cursor *cursor)
{
  uint64_t (*v4)(krb5_context);

  *(_QWORD *)&entry[1].magic = 0;
  *(_OWORD *)&entry->timestamp = 0u;
  *(_OWORD *)&entry->key.length = 0u;
  *(_OWORD *)&entry->magic = 0u;
  v4 = (uint64_t (*)(krb5_context))*((_QWORD *)keytab + 7);
  if (v4)
    return v4(context);
  krb5_set_error_message(context, -1980176636, "next_entry is not supported in the %s  keytab", *(const char **)keytab);
  return -1980176636;
}

uint64_t krb5_kt_copy_entry_contents(_krb5_context *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;

  *(_QWORD *)(a3 + 48) = 0;
  *(_OWORD *)(a3 + 16) = 0u;
  *(_OWORD *)(a3 + 32) = 0u;
  *(_OWORD *)a3 = 0u;
  *(_DWORD *)(a3 + 8) = *(_DWORD *)(a2 + 8);
  v6 = krb5_copy_principal(a1, *(krb5_const_principal *)a2, (krb5_principal *)a3);
  if ((_DWORD)v6
    || (v6 = krb5_copy_keyblock_contents(a1, (const krb5_keyblock *)(a2 + 16), (krb5_keyblock *)(a3 + 16)), (_DWORD)v6))
  {
    krb5_kt_free_entry(a1, a3);
  }
  else
  {
    *(_DWORD *)(a3 + 40) = *(_DWORD *)(a2 + 40);
  }
  return v6;
}

krb5_error_code krb5_kt_end_seq_get(krb5_context context, krb5_keytab keytab, krb5_kt_cursor *cursor)
{
  uint64_t (*v3)(krb5_context);

  v3 = (uint64_t (*)(krb5_context))*((_QWORD *)keytab + 8);
  if (v3)
    return v3(context);
  krb5_set_error_message(context, -1980176636, "end_seq_get is not supported in the %s  keytab", *(const char **)keytab);
  return -1980176636;
}

krb5_error_code krb5_kt_add_entry(krb5_context a1, krb5_keytab a2, krb5_keytab_entry *a3)
{
  if (*((_QWORD *)a2 + 9))
  {
    LODWORD(a3->key.contents) = time(0);
    return (*((uint64_t (**)(krb5_context, krb5_keytab, krb5_keytab_entry *))a2 + 9))(a1, a2, a3);
  }
  else
  {
    krb5_set_error_message(a1, -1765328201, "Add is not supported in the %s keytab", *(const char **)a2);
    return -1765328201;
  }
}

krb5_error_code krb5_kt_remove_entry(krb5_context a1, krb5_keytab a2, krb5_keytab_entry *a3)
{
  uint64_t (*v3)(krb5_context);

  v3 = (uint64_t (*)(krb5_context))*((_QWORD *)a2 + 10);
  if (v3)
    return v3(a1);
  krb5_set_error_message(a1, -1765328201, "Remove is not supported in the %s keytab", *(const char **)a2);
  return -1765328201;
}

uint64_t krb5_kt_have_content(krb5_context a1, const char **a2)
{
  const char *v4;
  uint64_t v5;
  const char *v6;
  void *v8;
  krb5_kt_cursor cursor[3];
  krb5_keytab_entry entry;
  uint64_t v11;

  v11 = 0;
  memset(&entry, 0, sizeof(entry));
  memset(cursor, 0, sizeof(cursor));
  v8 = 0;
  v4 = a2[6];
  if (v4)
  {
    if (!((unsigned int (*)(krb5_context, const char **, krb5_kt_cursor *))v4)(a1, a2, cursor))
    {
      v5 = krb5_kt_next_entry(a1, (krb5_keytab)a2, &entry, cursor);
      v6 = a2[8];
      if (v6)
      {
        ((void (*)(krb5_context, const char **, krb5_kt_cursor *))v6)(a1, a2, cursor);
        if (!(_DWORD)v5)
          goto LABEL_11;
      }
      else
      {
        krb5_set_error_message(a1, -1980176636, "end_seq_get is not supported in the %s  keytab", *a2);
        if (!(_DWORD)v5)
        {
LABEL_11:
          krb5_kt_free_entry(a1, (uint64_t)&entry);
          return v5;
        }
      }
    }
  }
  else
  {
    krb5_set_error_message(a1, -1980176636, "start_seq_get is not supported in the %s keytab type", *a2);
  }
  v5 = 2529639093;
  if (!krb5_kt_get_full_name(a1, (uint64_t)a2, (char **)&v8))
  {
    krb5_set_error_message(a1, -1765328203, "No entry in keytab: %s", (const char *)v8);
    free(v8);
  }
  return v5;
}

void _krb5_state_srv_sort(uint64_t a1)
{
  size_t v1;
  size_t v3;
  unsigned int v4;
  unint64_t v5;
  unint64_t i;
  uint64_t v7;
  int v8;
  uint64_t v9;
  unsigned int v10;
  unint64_t v11;
  unint64_t v12;
  int v13;
  uint32_t v14;
  unint64_t v15;
  uint64_t v16;
  uint32_t v17;
  BOOL v18;

  v1 = *(unsigned int *)(a1 + 96);
  if (v1 >= 2)
  {
    qsort(*(void **)(a1 + 88), v1, 8uLL, (int (__cdecl *)(const void *, const void *))sub_209697988);
    v3 = *(unsigned int *)(a1 + 96);
    if (v3 >= 2)
    {
      v4 = 0;
      v5 = 0;
      for (i = 1; i < v3; ++i)
      {
        v7 = *(_QWORD *)(a1 + 88);
        v8 = *(unsigned __int16 *)(*(_QWORD *)(v7 + 8 * v5) + 34);
        v9 = *(_QWORD *)(v7 + 8 * i);
        if (v8 == *(unsigned __int16 *)(v9 + 34))
        {
          v10 = *(_DWORD *)(v9 + 36) + v4;
          v11 = v5;
        }
        else
        {
          v10 = 0;
          if (v5 >= i)
            goto LABEL_18;
          v11 = i;
          if (v4)
          {
            v12 = v5;
            do
            {
              v13 = ~*(_DWORD *)(a1 + 96);
              v14 = arc4random() % v4;
              v15 = v5;
              do
              {
                v16 = *(_QWORD *)(*(_QWORD *)(a1 + 88) + 8 * v15);
                v17 = *(_DWORD *)(v16 + 36);
                if ((v17 & 0x80000000) == 0)
                {
                  v18 = v14 >= v17;
                  v14 -= v17;
                  if (v14 == 0 || !v18)
                  {
                    v4 -= v17;
                    *(_DWORD *)(v16 + 36) = v13;
                    goto LABEL_15;
                  }
                }
                ++v15;
              }
              while (i != v15);
              sub_20969D1E8(*(_QWORD *)(a1 + 32), 2, "o too large: sum %d", v4);
LABEL_15:
              ++v12;
            }
            while (v12 < i && v4);
            v10 = 0;
            v3 = *(unsigned int *)(a1 + 96);
LABEL_18:
            v11 = i;
          }
        }
        v4 = v10;
        v5 = v11;
      }
    }
    qsort(*(void **)(a1 + 88), v3, 8uLL, (int (__cdecl *)(const void *, const void *))sub_209697988);
  }
}

uint64_t sub_209697988(uint64_t *a1, uint64_t a2)
{
  uint64_t v2;
  int v3;
  int v4;
  uint64_t result;

  v2 = *a1;
  v3 = *(unsigned __int16 *)(*a1 + 34);
  v4 = *(unsigned __int16 *)(*(_QWORD *)a2 + 34);
  result = (v3 - v4);
  if (v3 == v4)
    return (*(_DWORD *)(v2 + 36) - *(_DWORD *)(*(_QWORD *)a2 + 36));
  return result;
}

size_t sub_2096979B0(const char *a1)
{
  size_t result;

  result = strlen(a1);
  if (result)
  {
    if (a1[result - 1] == 46)
      a1[result - 1] = 0;
  }
  return result;
}

void sub_2096979E8(_QWORD *a1)
{
  addrinfo *v2;
  void *v3;

  v2 = (addrinfo *)a1[1];
  if (v2)
  {
    freeaddrinfo(v2);
    a1[1] = 0;
  }
  v3 = (void *)a1[5];
  if (v3)
    free(v3);
  free(a1);
}

uint64_t krb5_krbhst_format_string(int a1, int *a2, char *__str, size_t __size)
{
  int v7;
  const char *v8;
  const char *v9;
  const char *v10;
  char __stra[8];

  *(_DWORD *)&__stra[3] = 0;
  *(_DWORD *)__stra = 0;
  v7 = *a2;
  if ((*a2 - 1) > 2)
    v8 = "";
  else
    v8 = off_24C1F2468[v7 - 1];
  if (*((unsigned __int16 *)a2 + 2) != *((unsigned __int16 *)a2 + 3))
  {
    snprintf(__stra, 7uLL, ":%d", *((unsigned __int16 *)a2 + 2));
    v7 = *a2;
  }
  if (v7 == 3)
  {
    v9 = (const char *)*((_QWORD *)a2 + 5);
    v10 = "/";
  }
  else
  {
    v10 = "";
    v9 = "";
  }
  snprintf(__str, __size, "%s%s%s%s%s", v8, (const char *)a2 + 48, __stra, v10, v9);
  return 0;
}

uint64_t krb5_krbhst_get_addrinfo(uint64_t a1, uint64_t a2, addrinfo **a3)
{
  addrinfo *v4;
  addrinfo **v5;
  uint64_t result;
  char *v8;
  char *v9;
  uint64_t v10;
  int *v11;
  int v12;
  char *v13;
  addrinfo v14;
  char __str[32];
  uint64_t v16;

  v16 = *MEMORY[0x24BDAC8D0];
  v5 = (addrinfo **)(a2 + 8);
  v4 = *(addrinfo **)(a2 + 8);
  if (v4)
  {
    result = 0;
  }
  else
  {
    memset(&v14, 0, sizeof(v14));
    v8 = (char *)(a2 + 48);
    v12 = *(unsigned __int16 *)(a2 + 4);
    v13 = (char *)(a2 + 48);
    snprintf(__str, 0x20uLL, "%d", v12);
    sub_209697C7C((uint64_t)&v14, *(_DWORD *)a2);
    v14.ai_flags |= 0x1004u;
    result = getaddrinfo(v8, __str, &v14, v5);
    if ((_DWORD)result)
    {
      v14.ai_flags &= ~4u;
      if (strchr(v8, 46) && v8[strlen(v8) - 1] != 46)
      {
        if (asprintf(&v13, "%s.", v8) < 0)
          return 12;
        v9 = v13;
        if (!v13)
          return 12;
      }
      else
      {
        v9 = v8;
      }
      v10 = getaddrinfo(v9, __str, &v14, v5);
      if (v13 != v8)
        free(v13);
      if ((_DWORD)v10)
      {
        v11 = __error();
        result = krb5_eai_to_heim_errno(v10, *v11);
      }
      else
      {
        result = 0;
      }
    }
    v4 = *v5;
  }
  *a3 = v4;
  return result;
}

uint64_t sub_209697C7C(uint64_t result, unsigned int a2)
{
  *(_OWORD *)(result + 16) = 0u;
  *(_OWORD *)(result + 32) = 0u;
  *(_OWORD *)result = 0u;
  *(_DWORD *)(result + 4) = 0;
  if (a2 <= 3)
    *(_DWORD *)(result + 8) = dword_2096D9400[a2];
  return result;
}

uint64_t krb5_krbhst_init(_krb5_context *a1, char *a2, int a3, uint64_t *a4)
{
  return krb5_krbhst_init_flags(a1, a2, a3, 0, a4);
}

uint64_t krb5_krbhst_init_flags(_krb5_context *a1, char *a2, int a3, int a4, uint64_t *a5)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unsigned int v14;
  const char *v15;
  uint64_t (*v16)(_krb5_context *, uint64_t, _QWORD *, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t);
  uint64_t v17;
  uint64_t v18;
  char *v19;
  dispatch_queue_t v20;
  dispatch_queue_t v21;
  unsigned int v22;
  uint64_t v23;

  *a5 = 0;
  switch(a3)
  {
    case 3:
      v14 = krb5_getportbyname((int)a1, "kpasswd", "udp", 0x1D0u);
      v15 = "change_password";
      v16 = sub_209698364;
      break;
    case 2:
      v14 = krb5_getportbyname((int)a1, "kerberos-adm", "tcp", 0x2EDu);
      v15 = "admin";
      v16 = sub_2096981B4;
      break;
    case 1:
      v14 = krb5_getportbyname((int)a1, "kerberos", "udp", 0x58u);
      v15 = "kdc";
      v16 = sub_209697EB8;
      break;
    default:
      v23 = 25;
      krb5_set_error_message(a1, 25, "unknown krbhst type (%u)", a3);
      return v23;
  }
  v17 = heim_uniq_alloc(0xF0uLL, (uint64_t)"krbhst-context", (uint64_t)sub_20969AB88, v9, v10, v11, v12, v13);
  if (!v17)
    return 12;
  v18 = v17;
  v19 = strdup(a2);
  *(_QWORD *)(v18 + 96) = v19;
  if (!v19
    || (v20 = sub_2096D7C40("krbhst-srv"), (*(_QWORD *)(v18 + 200) = v20) == 0)
    || (v21 = sub_2096D7C40("krbhst-addrinfo"), (*(_QWORD *)(v18 + 208) = v21) == 0))
  {
    heim_release((CFTypeRef)v18);
    return 12;
  }
  v22 = bswap32(v14);
  sub_20969D1E8((uint64_t)a1, 2, "Trying to find service %s for realm %s flags %x", v15, a2, a4);
  if (!strchr(a2, 46))
    *(_DWORD *)(v18 + 104) |= 0x100u;
  if ((a4 & 2) != 0)
    *(_DWORD *)(v18 + 104) |= 0x200u;
  *(_QWORD *)(v18 + 176) = v18 + 168;
  *(_QWORD *)(v18 + 184) = v18 + 168;
  pthread_mutex_init((pthread_mutex_t *)(v18 + 32), 0);
  v23 = 0;
  *(_QWORD *)(v18 + 120) = v16;
  *(_DWORD *)(v18 + 108) = HIWORD(v22);
  *a5 = v18;
  return v23;
}

uint64_t sub_209697EB8(_krb5_context *a1, uint64_t a2, _QWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v11;
  uint64_t v12;
  uint64_t v13;
  unsigned int v15;

  v11 = *(_DWORD *)(a2 + 104);
  if ((v11 & 0x800) == 0)
  {
    *(_DWORD *)(a2 + 104) = v11 | 0x800;
    if (*(_QWORD *)(a2 + 128))
    {
      sub_20969D1E8((uint64_t)a1, 5, "adding hostname: %s", *(const char **)(a2 + 128));
      sub_209698FB0((uint64_t)a1, a2, (uint64_t)"hostname", *(char **)(a2 + 128), *(_DWORD *)(a2 + 108), *(_DWORD *)(a2 + 112));
    }
    if (sub_2096985CC(a2, a3))
      return 0;
    v11 = *(_DWORD *)(a2 + 104);
  }
  if ((v11 & 0x400) == 0)
  {
    sub_209698890((uint64_t)a1, a2, 1u);
    *(_DWORD *)(a2 + 104) |= 0x400u;
    if (sub_2096985CC(a2, a3))
      return 0;
    v11 = *(_DWORD *)(a2 + 104);
  }
  if ((v11 & 1) == 0)
  {
    sub_2096988FC((uint64_t)a1, a2, (uint64_t)"kdc", a4, a5, a6, a7, a8);
    *(_DWORD *)(a2 + 104) |= 1u;
    if (sub_2096985CC(a2, a3))
      return 0;
    v11 = *(_DWORD *)(a2 + 104);
  }
  if ((v11 & 0x100) != 0)
  {
    v12 = 2529639068;
    sub_20969D1E8((uint64_t)a1, 1, "Configuration exists for realm %s, wont go to DNS");
    return v12;
  }
  if (!*((_DWORD *)a1 + 61))
    goto LABEL_32;
  if ((v11 & 0x10) == 0)
  {
    v13 = *(_QWORD *)(a2 + 136);
    if (v13)
    {
      sub_2096989E4(a1, a2, v13, "tcp", "kerberos");
      *(_DWORD *)(a2 + 104) |= 0x10u;
      if (sub_2096985CC(a2, a3))
        return 0;
      v11 = *(_DWORD *)(a2 + 104);
    }
  }
  if ((v11 & 4) == 0)
  {
    sub_2096989E4(a1, a2, 0, "tcp", "kerberos");
    *(_DWORD *)(a2 + 104) |= 4u;
    if (sub_2096985CC(a2, a3))
      return 0;
    v11 = *(_DWORD *)(a2 + 104);
  }
  if ((v11 & 0x202) != 0)
  {
    if ((v11 & 0x40) != 0)
      goto LABEL_30;
  }
  else
  {
    sub_2096989E4(a1, a2, 0, "udp", "kerberos");
    *(_DWORD *)(a2 + 104) |= 2u;
    if (sub_2096985CC(a2, a3))
      return 0;
    v11 = *(_DWORD *)(a2 + 104);
    if ((v11 & 0x40) != 0)
      goto LABEL_30;
  }
  sub_2096989E4(a1, a2, 0, "kkdcp", "kerberos");
  *(_DWORD *)(a2 + 104) |= 0x40u;
  if (sub_2096985CC(a2, a3))
    return 0;
  v11 = *(_DWORD *)(a2 + 104);
LABEL_30:
  if ((v11 & 0x20) == 0)
  {
    sub_2096989E4(a1, a2, 0, "http", "kerberos");
    *(_DWORD *)(a2 + 104) |= 0x20u;
    if (sub_2096985CC(a2, a3))
      return 0;
  }
LABEL_32:
  while (1)
  {
    v15 = *(_DWORD *)(a2 + 104);
    if ((v15 & 0x80) != 0)
      break;
    v12 = sub_209698D8C((uint64_t)a1, a2, *(_DWORD *)(a2 + 108), (v15 >> 9) & 1, a5, a6, a7, a8);
    if ((_DWORD)v12 || sub_2096985CC(a2, a3))
      return v12;
  }
  v12 = 2529639068;
  sub_20969D1E8((uint64_t)a1, 0, "No KDC entries found for %s");
  return v12;
}

uint64_t sub_2096981B4(_krb5_context *a1, uint64_t a2, _QWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unsigned int v18;

  v11 = *(_DWORD *)(a2 + 104);
  if ((v11 & 0x400) == 0)
  {
    sub_209698890((uint64_t)a1, a2, 3u);
    *(_DWORD *)(a2 + 104) |= 0x400u;
    if (sub_2096985CC(a2, a3))
      return 0;
    v11 = *(_DWORD *)(a2 + 104);
  }
  if ((v11 & 1) == 0)
  {
    sub_2096988FC((uint64_t)a1, a2, (uint64_t)"admin_server", a4, a5, a6, a7, a8);
    *(_DWORD *)(a2 + 104) |= 1u;
    if (sub_2096985CC(a2, a3))
      return 0;
    v11 = *(_DWORD *)(a2 + 104);
  }
  if ((v11 & 0x100) != 0)
  {
    v12 = 2529639068;
    sub_20969D1E8((uint64_t)a1, 1, "Configuration exists for realm %s, wont go to DNS");
    return v12;
  }
  if ((v11 & 4) != 0
    || !*((_DWORD *)a1 + 61)
    || (sub_2096989E4(a1, a2, 0, "tcp", "kerberos-adm"), *(_DWORD *)(a2 + 104) |= 4u, !sub_2096985CC(a2, a3)))
  {
    pthread_mutex_lock((pthread_mutex_t *)(a2 + 32));
    v13 = *(_QWORD *)(a2 + 176);
    pthread_mutex_unlock((pthread_mutex_t *)(a2 + 32));
    if (v13 != a2 + 168)
      goto LABEL_17;
    v18 = *(_DWORD *)(a2 + 104);
    if ((v18 & 0x80) != 0)
      goto LABEL_17;
    v12 = sub_209698D8C((uint64_t)a1, a2, *(_DWORD *)(a2 + 108), (v18 >> 9) & 1, v14, v15, v16, v17);
    if ((_DWORD)v12)
      return v12;
    *(_DWORD *)(a2 + 104) |= 0x80u;
    if (!sub_2096985CC(a2, a3))
    {
LABEL_17:
      v12 = 2529639068;
      sub_20969D1E8((uint64_t)a1, 0, "No admin entries found for realm %s");
      return v12;
    }
  }
  return 0;
}

uint64_t sub_209698364(_krb5_context *a1, uint64_t a2, _QWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;

  v11 = *(_DWORD *)(a2 + 104);
  if ((v11 & 0x400) == 0)
  {
    sub_209698890((uint64_t)a1, a2, 5u);
    *(_DWORD *)(a2 + 104) |= 0x400u;
    if (sub_2096985CC(a2, a3))
      return 0;
    v11 = *(_DWORD *)(a2 + 104);
  }
  if ((v11 & 1) == 0)
  {
    sub_2096988FC((uint64_t)a1, a2, (uint64_t)"kpasswd_server", a4, a5, a6, a7, a8);
    *(_DWORD *)(a2 + 104) |= 1u;
    if (sub_2096985CC(a2, a3))
      return 0;
    v11 = *(_DWORD *)(a2 + 104);
  }
  if ((v11 & 0x100) != 0)
  {
    v12 = 2529639068;
    sub_20969D1E8((uint64_t)a1, 1, "Configuration exists for realm %s, wont go to DNS");
    return v12;
  }
  if (*((_DWORD *)a1 + 61))
  {
    if ((v11 & 0x202) != 0)
    {
      if ((v11 & 4) != 0)
        goto LABEL_17;
    }
    else
    {
      sub_2096989E4(a1, a2, 0, "udp", "kpasswd");
      *(_DWORD *)(a2 + 104) |= 2u;
      if (sub_2096985CC(a2, a3))
        return 0;
      if ((*(_DWORD *)(a2 + 104) & 4) != 0)
        goto LABEL_17;
    }
    sub_2096989E4(a1, a2, 0, "tcp", "kpasswd");
    *(_DWORD *)(a2 + 104) |= 4u;
    if (sub_2096985CC(a2, a3))
      return 0;
  }
LABEL_17:
  pthread_mutex_lock((pthread_mutex_t *)(a2 + 32));
  v13 = *(_QWORD *)(a2 + 176);
  pthread_mutex_unlock((pthread_mutex_t *)(a2 + 32));
  if (v13 == a2 + 168)
  {
    *(_DWORD *)(a2 + 104) = 0;
    *(_DWORD *)(a2 + 112) = *(_DWORD *)(a2 + 108);
    *(_QWORD *)(a2 + 120) = sub_2096981B4;
    v12 = sub_2096981B4(a1, a2, a3, v14, v15, v16, v17, v18);
    if (!(_DWORD)v12)
      *(_DWORD *)*a3 = (*(_DWORD *)(a2 + 104) >> 9) & 1;
  }
  else
  {
    v12 = 2529639068;
    sub_20969D1E8((uint64_t)a1, 0, "No kpasswd entries found for realm %s");
  }
  return v12;
}

uint64_t krb5_krbhst_next(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  if (sub_2096985CC(a2, a3))
    return 0;
  else
    return (*(uint64_t (**)(uint64_t, uint64_t, _QWORD *))(a2 + 120))(a1, a2, a3);
}

BOOL sub_2096985CC(uint64_t a1, _QWORD *a2)
{
  pthread_mutex_t *v4;
  uint64_t v5;
  _BOOL8 v6;

  v4 = (pthread_mutex_t *)(a1 + 32);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 32));
  v5 = **(_QWORD **)(a1 + 176);
  if (v5)
  {
    *a2 = v5;
    *(_QWORD *)(a1 + 176) = **(_QWORD **)(a1 + 176) + 16;
  }
  v6 = v5 != 0;
  pthread_mutex_unlock(v4);
  return v6;
}

uint64_t krb5_krbhst_next_as_string(uint64_t a1, uint64_t a2, char *a3, size_t a4)
{
  uint64_t result;
  int v9[2];

  *(_QWORD *)v9 = 0;
  LODWORD(result) = sub_2096985CC(a2, v9);
  if ((_DWORD)result
    || (result = (*(uint64_t (**)(uint64_t, uint64_t, int *))(a2 + 120))(a1, a2, v9), !(_DWORD)result))
  {
    krb5_krbhst_format_string(result, *(int **)v9, a3, a4);
    return 0;
  }
  return result;
}

uint64_t krb5_krbhst_set_hostname(_krb5_context *a1, uint64_t a2, char *__s1)
{
  void *v6;
  char *v7;

  v6 = *(void **)(a2 + 128);
  if (v6)
    free(v6);
  v7 = strdup(__s1);
  *(_QWORD *)(a2 + 128) = v7;
  if (v7)
    return 0;
  else
    return krb5_enomem(a1);
}

uint64_t krb5_krbhst_set_sitename(_krb5_context *a1, uint64_t a2, char *__s1)
{
  void *v6;
  char *v7;

  v6 = *(void **)(a2 + 136);
  if (v6)
    free(v6);
  v7 = strdup(__s1);
  *(_QWORD *)(a2 + 136) = v7;
  if (v7)
    return 0;
  else
    return krb5_enomem(a1);
}

uint64_t krb5_krbhst_set_delgated_uuid(uint64_t a1, uint64_t a2, unsigned __int8 *a3)
{
  if (a3)
  {
    *(_DWORD *)(a2 + 104) |= 0x1000u;
    *(_OWORD *)(a2 + 144) = *(_OWORD *)a3;
    sub_20969D1E8(a1, 5, "krb5_krbhst_set_delegated_uuid: %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x", *a3, a3[1], a3[2], a3[3], a3[4], a3[5], a3[6], a3[7], a3[8], a3[9], a3[10], a3[11], a3[12], a3[13], a3[14], a3[15]);
  }
  return 0;
}

uint64_t krb5_krbhst_set_delgated_pid(uint64_t a1, uint64_t a2, int a3)
{
  if (a3)
  {
    *(_DWORD *)(a2 + 104) |= 0x1000u;
    *(_DWORD *)(a2 + 160) = a3;
    sub_20969D1E8(a1, 5, "krb5_krbhst_set_delegated_pid: %d", a3);
  }
  return 0;
}

uint64_t krb5_krbhst_reset(uint64_t a1, uint64_t a2)
{
  pthread_mutex_t *v3;

  v3 = (pthread_mutex_t *)(a2 + 32);
  pthread_mutex_lock((pthread_mutex_t *)(a2 + 32));
  *(_QWORD *)(a2 + 176) = a2 + 168;
  return pthread_mutex_unlock(v3);
}

void krb5_krbhst_free(uint64_t a1, const void *a2)
{
  heim_release(a2);
}

uint64_t sub_209698890(uint64_t a1, uint64_t a2, unsigned int a3)
{
  _QWORD v5[3];

  v5[1] = a2;
  v5[0] = a3;
  v5[2] = krb5_homedir_access(a1) != 0;
  return krb5_plugin_run_f(a1, "krb5", "service_locator", 0, 0, (uint64_t)v5, (uint64_t)sub_209699388);
}

void sub_2096988FC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  void **strings;
  const char *v11;
  char *v12;
  char **v13;
  char *v14;

  strings = (void **)krb5_config_get_strings(a1, 0, a3, a4, a5, a6, a7, a8, (uint64_t)"realms");
  v11 = "";
  if (!strings)
    v11 = " not";
  sub_20969D1E8(a1, 2, "configuration file for realm %s%s found", *(const char **)(a2 + 96), v11);
  if (strings)
  {
    *(_DWORD *)(a2 + 104) |= 0x100u;
    v12 = (char *)*strings;
    if (*strings)
    {
      v13 = (char **)(strings + 1);
      do
      {
        sub_209698FB0(a1, a2, (uint64_t)"config", v12, *(_DWORD *)(a2 + 108), *(_DWORD *)(a2 + 112));
        v14 = *v13++;
        v12 = v14;
      }
      while (v14);
    }
    krb5_config_free_strings(strings);
  }
}

void sub_2096989E4(_krb5_context *a1, uint64_t a2, uint64_t a3, char *a4, char *a5)
{
  int v10;
  unsigned int v11;
  const char *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  dispatch_semaphore_t v20;
  char **v21;
  uint32_t v22;
  int DelegateConnection;
  NSObject *v24;
  dispatch_time_t v25;
  NSObject *v26;
  char *v27;
  _QWORD block[6];
  int v29;
  DNSServiceRef sdRef;

  v27 = 0;
  if (!krb5_realm_is_lkdc(*(const char **)(a2 + 96)))
  {
    if (!strcasecmp(a4, "udp"))
    {
      v10 = 0;
    }
    else
    {
      if (strcasecmp(a4, "tcp"))
      {
        if (!strcasecmp(a4, "http"))
        {
          v12 = 0;
          v11 = bswap32(krb5_getportbyname((int)a1, "http", "tcp", 0x50u)) >> 16;
          v10 = 2;
        }
        else
        {
          if (strcasecmp(a4, "kkdcp"))
          {
            return;
          }
          v11 = bswap32(krb5_getportbyname((int)a1, "https", "tcp", 0x1BBu)) >> 16;
          v12 = "kkdcp";
          v10 = 3;
        }
LABEL_13:
        if (a3)
          asprintf(&v27, "_%s._%s.%s._sites.%s.");
        else
          asprintf(&v27, "_%s._%s.%s.");
        if (v27)
        {
          v18 = heim_uniq_alloc(0x68uLL, (uint64_t)"heim-query-ctx", (uint64_t)sub_209699660, v13, v14, v15, v16, v17);
          if (v18)
          {
            v19 = v18;
            *(_QWORD *)(v18 + 32) = a1;
            v20 = j__dispatch_semaphore_create(0);
            *(_QWORD *)(v19 + 40) = v20;
            *(_QWORD *)(v19 + 56) = v27;
            if (v20)
            {
              v21 = (char **)heim_retain((CFTypeRef)a2);
              *(_QWORD *)(v19 + 48) = v21;
              *(_DWORD *)(v19 + 64) = v11;
              *(_DWORD *)(v19 + 68) = v10;
              *(_QWORD *)(v19 + 72) = v12;
              *(_QWORD *)(v19 + 88) = 0;
              *(_DWORD *)(v19 + 96) = 0;
              v29 = 69632;
              if (*(_QWORD *)(a2 + 216))
                goto LABEL_20;
              if ((*(_BYTE *)(a2 + 105) & 0x10) != 0)
                DelegateConnection = DNSServiceCreateDelegateConnection();
              else
                DelegateConnection = DNSServiceCreateConnection((DNSServiceRef *)(a2 + 216));
              if (DelegateConnection)
              {
                sub_20969D1E8((uint64_t)a1, 2, "Failed setting up search context for domain %s failed: %d");
              }
              else
              {
                if (!DNSServiceSetDispatchQueue(*(DNSServiceRef *)(a2 + 216), *(dispatch_queue_t *)(a2 + 200)))
                {
                  v21 = *(char ***)(v19 + 48);
LABEL_20:
                  v22 = sub_2096997A8((uint64_t)a1, v21[12], a2, &v29);
                  sdRef = *(DNSServiceRef *)(a2 + 216);
                  heim_retain((CFTypeRef)v19);
                  if (DNSServiceQueryRecord(&sdRef, v29 | 0x4000, v22, *(const char **)(v19 + 56), 0x21u, 1u, (DNSServiceQueryRecordReply)sub_209699ADC, (void *)v19))
                  {
                    sub_20969D1E8((uint64_t)a1, 2, "searching DNS for domain %s failed: %d");
                  }
                  else
                  {
                    v24 = *(NSObject **)(v19 + 40);
                    v25 = dispatch_time(0, 10000000000);
                    if (dispatch_semaphore_wait(v24, v25))
                      sub_20969D1E8((uint64_t)a1, 2, "searching DNS %s for domain timed out", *(const char **)(v19 + 56));
                    v26 = *(NSObject **)(a2 + 200);
                    block[0] = MEMORY[0x24BDAC760];
                    block[1] = 0x40000000;
                    block[2] = sub_20969A2F4;
                    block[3] = &unk_24C1F2340;
                    block[4] = sdRef;
                    block[5] = v19;
                    dispatch_sync(v26, block);
                  }
                  goto LABEL_35;
                }
                DNSServiceRefDeallocate(*(DNSServiceRef *)(a2 + 216));
                sub_20969D1E8((uint64_t)a1, 2, "Failed setting run queue for SRV query: %d");
              }
LABEL_35:
              heim_release((CFTypeRef)v19);
              return;
            }
            heim_release((CFTypeRef)v19);
          }
          else
          {
            free(v27);
          }
        }
        krb5_enomem(a1);
        return;
      }
      v10 = 1;
    }
    v11 = *(_DWORD *)(a2 + 112);
    v12 = 0;
    if (!v11)
      v11 = bswap32(krb5_getportbyname((int)a1, a5, a4, 0x58u)) >> 16;
    goto LABEL_13;
  }
}

uint64_t sub_209698D8C(uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8;
  uint64_t result;
  int v13;
  int v14;
  size_t v15;
  int *v16;
  int *v17;
  char *v18;
  char *v19;
  addrinfo v20;
  addrinfo *v21;
  char *__s;
  char __str[32];
  uint64_t v24;

  v8 = a4;
  v24 = *MEMORY[0x24BDAC8D0];
  __s = 0;
  result = krb5_config_get_BOOL_default(a1, 0, 0, a4, a5, a6, a7, a8, (uint64_t)"libdefaults");
  if (!(_DWORD)result)
    goto LABEL_5;
  sub_20969D1E8(a1, 2, "fallback lookup %d for realm %s (service %s)", *(_DWORD *)(a2 + 164), *(const char **)(a2 + 96), "kerberos");
  if (*(_DWORD *)(a2 + 164) > 4u || krb5_realm_is_lkdc(*(const char **)(a2 + 96)))
  {
LABEL_4:
    result = 0;
LABEL_5:
    *(_DWORD *)(a2 + 104) |= 0x80u;
    return result;
  }
  v21 = 0;
  memset(&v20, 0, sizeof(v20));
  if (*(_DWORD *)(a2 + 164))
    v13 = asprintf(&__s, "%s-%d.%s.");
  else
    v13 = asprintf(&__s, "%s.%s.");
  v14 = v13;
  result = 12;
  if ((v14 & 0x80000000) == 0 && __s)
  {
    sub_209697C7C((uint64_t)&v20, v8);
    snprintf(__str, 0x20uLL, "%d", a3);
    if (getaddrinfo(__s, __str, &v20, &v21))
    {
      free(__s);
      goto LABEL_4;
    }
    v15 = strlen(__s);
    v16 = (int *)malloc_type_calloc(1uLL, v15 + 56, 0x5B6B3234uLL);
    if (v16)
    {
      v17 = v16;
      *v16 = v8;
      *((_WORD *)v16 + 3) = a3;
      *((_WORD *)v16 + 2) = a3;
      v18 = __s;
      *((_QWORD *)v16 + 1) = v21;
      *((_QWORD *)v16 + 4) = "fallback";
      v19 = (char *)(v16 + 12);
      memmove(v16 + 12, v18, v15);
      v19[v15] = 0;
      free(__s);
      sub_209699294(a1, a2, v17);
      result = 0;
      ++*(_DWORD *)(a2 + 164);
    }
    else
    {
      free(__s);
      return 12;
    }
  }
  return result;
}

uint64_t sub_209698FB0(uint64_t a1, uint64_t a2, uint64_t a3, char *__s, __int16 a5, int a6)
{
  unsigned int v7;
  char *v8;
  size_t v12;
  _DWORD *v13;
  _WORD *v14;
  char *v15;
  int v16;
  unsigned int v17;
  char *v18;
  char *v19;
  const void *v20;
  size_t v21;
  char *v22;
  int v23;
  BOOL v24;
  const char *v25;
  const char *v26;
  int v27;
  size_t v28;
  void *v30;
  char *__endptr;

  LOWORD(v7) = a5;
  v8 = __s;
  v12 = strlen(__s);
  v13 = malloc_type_calloc(1uLL, v12 + 56, 0x9128AF0AuLL);
  if (!v13)
    return 12;
  v14 = v13;
  *v13 = (*(_DWORD *)(a2 + 104) >> 9) & 1;
  if (!strncmp(v8, "http://", 7uLL))
  {
    *(_DWORD *)v14 = 2;
    v8 += 7;
    goto LABEL_14;
  }
  if (!strncmp(v8, "http/", 5uLL))
  {
    *(_DWORD *)v14 = 2;
    v8 += 5;
    v15 = "http";
    v16 = a1;
    v17 = 80;
LABEL_11:
    v7 = bswap32(krb5_getportbyname(v16, v15, "tcp", v17)) >> 16;
    goto LABEL_14;
  }
  if (!strncmp(v8, "kkdcp://", 8uLL))
  {
    *(_DWORD *)v14 = 3;
    v8 += 8;
    v15 = "https";
    v16 = a1;
    v17 = 443;
    goto LABEL_11;
  }
  if (!strncmp(v8, "tcp/", 4uLL))
  {
    *(_DWORD *)v14 = 1;
    goto LABEL_13;
  }
  if (!strncmp(v8, "udp/", 4uLL))
  {
    *(_DWORD *)v14 = 0;
LABEL_13:
    v8 += 4;
  }
LABEL_14:
  *((_QWORD *)v14 + 4) = a3;
  if (*v8 == 91)
  {
    v18 = strchr(v8, 93);
    if (v18)
    {
      v19 = v18;
      v20 = v8 + 1;
      v21 = (size_t)&v18[~(unint64_t)v8];
      memcpy(v14 + 24, v20, v21);
      *((_BYTE *)v14 + v21 + 48) = 0;
      v23 = v19[1];
      v22 = v19 + 1;
      v24 = v23 == 58;
      if (v23 == 58)
        v8 = v22 + 1;
      else
        v8 = v22;
      if (v24)
        v25 = v22 + 1;
      else
        v25 = 0;
LABEL_25:
      v8 = strchr(v8, 47);
      if (!v8)
        goto LABEL_32;
      goto LABEL_28;
    }
  }
  v25 = (const char *)strcspn(v8, ":/");
  if (!v25)
  {
    v28 = strlen(v8);
    memcpy(v14 + 24, v8, v28 + 1);
LABEL_28:
    v27 = *v8;
    goto LABEL_30;
  }
  memcpy(v14 + 24, v8, (size_t)v25);
  v25[(_QWORD)v14 + 48] = 0;
  v26 = &v25[(_QWORD)v8];
  v27 = v25[(_QWORD)v8];
  if (v27 == 58)
  {
    v25 = v26 + 1;
    goto LABEL_25;
  }
  v25 = 0;
  v8 = (char *)v26;
LABEL_30:
  if (v27 == 47)
    *((_QWORD *)v14 + 5) = strdup(v8 + 1);
LABEL_32:
  rk_strlwr((unsigned __int8 *)v14 + 48);
  v14[3] = v7;
  v14[2] = v7;
  if (v25)
  {
    if (*v25)
    {
      __endptr = 0;
      v14[2] = strtol(v25, &__endptr, 0);
      if (__endptr == v25)
      {
        v30 = (void *)*((_QWORD *)v14 + 5);
        if (v30)
          free(v30);
        free(v14);
        return 12;
      }
    }
  }
  if (a6)
    v14[2] = a6;
  sub_209699294(a1, a2, (int *)v14);
  return 0;
}

uint64_t sub_209699294(uint64_t a1, uint64_t a2, int *a3)
{
  int *v5;
  int *v6;
  int v7;
  int v8;
  int v9;
  pthread_mutex_t *v11;

  v11 = (pthread_mutex_t *)(a2 + 32);
  pthread_mutex_lock((pthread_mutex_t *)(a2 + 32));
  if (a3)
  {
    do
    {
      v5 = (int *)*((_QWORD *)a3 + 2);
      *((_QWORD *)a3 + 2) = 0;
      v6 = *(int **)(a2 + 168);
      if (v6)
      {
        v7 = *a3;
        while (1)
        {
          v8 = *v6;
          if (*v6 == v7)
          {
            v9 = *((unsigned __int16 *)v6 + 2);
            if (v9 == *((unsigned __int16 *)a3 + 2) && !strcasecmp((const char *)v6 + 48, (const char *)a3 + 48))
              break;
          }
          v6 = (int *)*((_QWORD *)v6 + 2);
          if (!v6)
            goto LABEL_8;
        }
        sub_20969D1E8(a1, 10, "dropping dup KDC host: %s:%d (proto %d)", (const char *)v6 + 48, v9, v8);
        sub_2096979E8(a3);
      }
      else
      {
LABEL_8:
        **(_QWORD **)(a2 + 184) = a3;
        *(_QWORD *)(a2 + 184) = a3 + 4;
      }
      a3 = v5;
    }
    while (v5);
  }
  return pthread_mutex_unlock(v11);
}

uint64_t sub_209699388(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int *a4)
{
  uint64_t (*v4)(uint64_t, uint64_t, uint64_t, uint64_t, _QWORD, _QWORD, void *);
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  void *v8;

  if (*(int *)a2 >= 3)
  {
    v4 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, _QWORD, _QWORD, void *))(a2 + 40);
    if (v4)
    {
      v5 = *a4;
      v6 = *((_QWORD *)a4 + 2);
      v7 = *(_QWORD *)(*((_QWORD *)a4 + 1) + 96);
      v8 = sub_209699428;
      return v4(a3, v6, v5, v7, 0, 0, v8);
    }
LABEL_5:
    v4 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, _QWORD, _QWORD, void *))(a2 + 32);
    v5 = *a4;
    v6 = *((_QWORD *)a4 + 2);
    v7 = *(_QWORD *)(*((_QWORD *)a4 + 1) + 96);
    v8 = sub_209699444;
    return v4(a3, v6, v5, v7, 0, 0, v8);
  }
  if (*(_DWORD *)a2 == 2)
    goto LABEL_5;
  if ((a4[4] & 1) != 0)
    return (*(uint64_t (**)(uint64_t, _QWORD, _QWORD, _QWORD, _QWORD, uint64_t (*)(_DWORD *, uint64_t, const sockaddr *)))(a2 + 24))(a3, *a4, *(_QWORD *)(*((_QWORD *)a4 + 1) + 96), 0, 0, sub_209699444);
  else
    return 2529639161;
}

uint64_t sub_209699428(uint64_t a1, char *__s)
{
  return sub_209698FB0(*(_QWORD *)(a1 + 192), a1, (uint64_t)"plugin", __s, *(_DWORD *)(a1 + 108), *(_DWORD *)(a1 + 112));
}

uint64_t sub_209699444(_DWORD *a1, uint64_t a2, const sockaddr *a3)
{
  socklen_t v5;
  __int16 v6;
  uint64_t result;
  int v8;
  unsigned int v9;
  char __str[32];
  char v11[1025];
  uint64_t v12;

  v12 = *MEMORY[0x24BDAC8D0];
  v5 = rk_socket_sockaddr_size((uint64_t)a3);
  v6 = sub_2096B99C4((uint64_t)a3);
  if (getnameinfo(a3, v5, v11, 0x401u, __str, 0x20u, 10))
    return 0;
  v8 = a1[28];
  if (!v8)
  {
    if (atoi(__str))
      goto LABEL_6;
    v8 = a1[27];
  }
  snprintf(__str, 0x20uLL, "%d", v8);
LABEL_6:
  v9 = (a1[26] >> 9) & 1;
  result = sub_20969956C((uint64_t)a1, v11, __str, v6, v9);
  if (!(_DWORD)result)
  {
    if (v9)
      return 0;
    result = sub_20969956C((uint64_t)a1, v11, __str, v6, 1u);
    if (!(_DWORD)result)
      return 0;
  }
  return result;
}

uint64_t sub_20969956C(uint64_t a1, const char *a2, const char *a3, __int16 a4, unsigned int a5)
{
  size_t v10;
  int *v11;
  int *v12;
  char *v13;
  addrinfo *v15;
  addrinfo v16;

  memset(&v16, 0, sizeof(v16));
  v15 = 0;
  sub_209697C7C((uint64_t)&v16, a5);
  if (!getaddrinfo(a2, a3, &v16, &v15))
  {
    v10 = strlen(a2);
    v11 = (int *)malloc_type_calloc(1uLL, v10 + 56, 0x22497B9CuLL);
    if (!v11)
      return 12;
    v12 = v11;
    *v11 = a5;
    *((_WORD *)v11 + 3) = a4;
    *((_WORD *)v11 + 2) = a4;
    *((_QWORD *)v11 + 1) = v15;
    *((_QWORD *)v11 + 4) = "plugin";
    v13 = (char *)(v11 + 12);
    memmove(v11 + 12, a2, v10);
    v13[v10] = 0;
    sub_209699294(*(_QWORD *)(a1 + 192), a1, v12);
  }
  return 0;
}

void sub_209699660(uint64_t a1)
{
  NSObject *v2;
  void *v3;
  unint64_t v4;
  uint64_t v5;
  NSObject *v6;
  _QWORD v7[6];

  free(*(void **)(a1 + 56));
  v2 = *(NSObject **)(a1 + 40);
  if (v2)
    dispatch_release(v2);
  v3 = *(void **)(a1 + 88);
  if (v3)
  {
    if (*(_DWORD *)(a1 + 96))
    {
      v4 = 0;
      v5 = MEMORY[0x24BDAC760];
      do
      {
        v6 = *(NSObject **)(*(_QWORD *)(a1 + 48) + 208);
        v7[0] = v5;
        v7[1] = 0x40000000;
        v7[2] = sub_209699730;
        v7[3] = &unk_24C1F2320;
        v7[4] = a1;
        v7[5] = v4;
        dispatch_sync(v6, v7);
        heim_release(*(CFTypeRef *)(*(_QWORD *)(a1 + 88) + 8 * v4++));
      }
      while (v4 < *(unsigned int *)(a1 + 96));
      v3 = *(void **)(a1 + 88);
    }
    free(v3);
    *(_DWORD *)(a1 + 96) = 0;
  }
  heim_release(*(CFTypeRef *)(a1 + 48));
}

void sub_209699730(uint64_t a1)
{
  _DNSServiceRef_t *v2;
  uint64_t v3;
  uint64_t v4;

  v2 = *(_DNSServiceRef_t **)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 88) + 8 * *(_QWORD *)(a1 + 40)) + 64);
  if (v2)
  {
    DNSServiceRefDeallocate(v2);
    v3 = *(_QWORD *)(a1 + 40);
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 88) + 8 * v3) + 64) = 0;
    v4 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 88) + 8 * v3);
    if ((*(_BYTE *)(v4 + 96) & 1) == 0)
    {
      *(_BYTE *)(v4 + 96) |= 1u;
      heim_release(*(CFTypeRef *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 88) + 8 * *(_QWORD *)(a1 + 40)));
    }
  }
}

uint64_t sub_2096997A8(uint64_t a1, char *__s1, uint64_t a3, _DWORD *a4)
{
  unsigned __int8 *v7;
  nw_endpoint_t host;
  nw_endpoint_t v9;
  nw_parameters_t v10;
  nw_parameters_t v11;
  uint64_t dns_service_id;
  uint64_t evaluator_for_endpoint;
  NSObject *v15;
  uint64_t v16;
  void *v17;
  nw_endpoint_t v18;
  NSObject *v19;
  NSObject *v20;

  v7 = (unsigned __int8 *)strdup(__s1);
  rk_strlwr(v7);
  host = nw_endpoint_create_host((const char *)v7, "88");
  if (host)
  {
    v9 = host;
    v10 = nw_parameters_create();
    if (v10)
    {
      v11 = v10;
      if ((*(_BYTE *)(a3 + 105) & 0x10) != 0)
      {
        sub_20969D1E8(a1, 5, "host_create(%s): have delegate uuid", (const char *)v7);
        nw_parameters_set_e_proc_uuid();
      }
      else
      {
        getpid();
        nw_parameters_set_pid();
      }
      evaluator_for_endpoint = nw_path_create_evaluator_for_endpoint();
      if (evaluator_for_endpoint)
      {
        v15 = evaluator_for_endpoint;
        v16 = nw_path_evaluator_copy_path();
        if (v16)
        {
          v17 = (void *)v16;
          if (nw_path_is_flow_divert())
          {
            if ((nw_path_get_vpn_config_id() & 1) != 0)
            {
              sub_20969D1E8(a1, 5, "host_create(%s): vpn config uuid: %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x", (const char *)v7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0);
              nw_path_is_per_app_vpn();
              dns_service_id = ne_session_service_get_dns_service_id();
              sub_20969D1E8(a1, 5, "host_create(%s): AppVPN: %d", (const char *)v7, dns_service_id);
              if ((_DWORD)dns_service_id)
                *a4 |= 0x10000000u;
            }
            else
            {
              sub_20969D1E8(a1, 5, "host_create(%s): path have no config id", (const char *)v7);
              dns_service_id = 0;
            }
            v20 = 0;
          }
          else
          {
            v19 = nw_path_copy_scoped_interface();
            v20 = v19;
            if (v19)
            {
              dns_service_id = nw_interface_get_index(v19);
              sub_20969D1E8(a1, 5, "host_create(%s): use dns_service_id %d", (const char *)v7, dns_service_id);
            }
            else
            {
              sub_20969D1E8(a1, 5, "host_create(%s): no interface", (const char *)v7);
              dns_service_id = 0;
            }
          }
          nw_release(v17);
          nw_release(v9);
          nw_release(v15);
          if (v20)
            nw_release(v20);
LABEL_27:
          nw_release(v11);
          if (!v7)
            return dns_service_id;
          goto LABEL_8;
        }
        sub_20969D1E8(a1, 5, "host_create(%s): path is NULL", (const char *)v7);
        nw_release(v9);
        v18 = v15;
      }
      else
      {
        sub_20969D1E8(a1, 5, "host_create(%s): nw_path_evaluator_t is NULL", (const char *)v7);
        v18 = v9;
      }
      nw_release(v18);
      dns_service_id = 0;
      goto LABEL_27;
    }
    sub_20969D1E8(a1, 5, "host_create(%s): nw_parameters_t is NULL", (const char *)v7);
    nw_release(v9);
  }
  else
  {
    sub_20969D1E8(a1, 5, "host_create(%s): nw_endpoint_t host is NULL", (const char *)v7);
  }
  dns_service_id = 0;
  if (v7)
LABEL_8:
    free(v7);
  return dns_service_id;
}

void sub_209699ADC(uint64_t a1, char a2, uint64_t a3, int a4, const char *a5, int a6, uint64_t a7, unsigned int a8, const u_char *a9, uint64_t a10, uint64_t a11)
{
  char v12;
  uint64_t *v14;
  time_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;
  time_t v24;
  char *v25;
  uint64_t v26;
  uint64_t v27;
  const char *v28;
  const char *v29;
  uint64_t v30;
  uint64_t v31;
  BOOL v32;
  NSObject *v33;
  _QWORD *v34;
  uint64_t v35;
  unint64_t v36;
  uint64_t v37;
  uint64_t v38;
  const char *v39;
  unsigned int v40;
  unsigned int v41;
  unsigned int v42;
  char *v43;
  char *v44;
  unsigned int v45;
  size_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  _krb5_context *v54;
  void *v55;
  CFTypeRef v56;
  uint64_t v57;
  char v58;
  uint64_t v59;
  int DelegateConnection;
  uint64_t v61;
  NSObject *v62;
  DNSServiceErrorType v63;
  uint64_t v64;
  uint32_t v65;
  dispatch_semaphore_t v66;
  char v67;
  DNSServiceProtocol v68;
  DNSServiceErrorType AddrInfo;
  char v70;
  uint64_t v71;
  _QWORD v72[5];
  _QWORD block[6];
  _QWORD v74[6];
  char *v75[7];

  if ((*(_BYTE *)(a11 + 80) & 1) != 0)
  {
    sub_20969D1E8(*(_QWORD *)(a11 + 32), 10, "Got SRV callback after MoreComing == 0 was already set!");
    return;
  }
  if (a4)
  {
    sub_20969D1E8(*(_QWORD *)(a11 + 32), 10, "SRV callback: error: %d", a4);
    v12 = 0;
LABEL_9:
    v14 = (uint64_t *)(a11 + 32);
    sub_20969D1E8(*(_QWORD *)(a11 + 32), 10, "SRV callback end: %s", a5);
    goto LABEL_10;
  }
  v12 = a2;
  if (a6 != 33)
  {
    sub_20969D1E8(*(_QWORD *)(a11 + 32), 10, "SRV callback: rd_len no srv query");
    goto LABEL_9;
  }
  if (a8 <= 6)
  {
    sub_20969D1E8(*(_QWORD *)(a11 + 32), 10, "SRV callback: rd_len too short: %d");
    goto LABEL_9;
  }
  v40 = __rev16(*(unsigned __int16 *)a9);
  v41 = __rev16(*((unsigned __int16 *)a9 + 1));
  v42 = __rev16(*((unsigned __int16 *)a9 + 2));
  v14 = (uint64_t *)(a11 + 32);
  sub_20969D1E8(*(_QWORD *)(a11 + 32), 10, "Got SRV callback: %s:%d prio: %d weight: %d", a5, v42, v40, v41);
  v43 = (char *)malloc_type_malloc(a8 + 1, 0x30EA6D39uLL);
  if (!v43)
  {
    sub_20969D1E8(*v14, 10, "SRV callback: failed to allocate hostname", v71);
    goto LABEL_9;
  }
  v44 = v43;
  v45 = res_9_dn_expand(a9, &a9[a8], a9 + 6, v43, a8);
  if ((v45 & 0x80000000) != 0 || (unint64_t)v45 + 6 > a8)
  {
    sub_20969D1E8(*v14, 10, "SRV callback: dn_expand: %d");
LABEL_62:
    sub_20969D1E8(*v14, 10, "SRV callback end: %s", a5);
    free(v44);
    goto LABEL_10;
  }
  v46 = strlen(v44);
  if (v46 && v44[v46 - 1] == 46)
    v44[v46 - 1] = 0;
  if (sub_20969A33C(*v14, (uint64_t)v44))
    goto LABEL_62;
  v52 = heim_uniq_alloc(0x68uLL, (uint64_t)"heim-srv-object", (uint64_t)sub_20969A3EC, v47, v48, v49, v50, v51);
  if (!v52)
  {
    sub_20969D1E8(*v14, 10, "SRV callback: alloc heim-srv-object");
    goto LABEL_62;
  }
  v53 = v52;
  *(_WORD *)(v52 + 32) = v42;
  *(_WORD *)(v52 + 34) = v40;
  *(_DWORD *)(v52 + 36) = v41;
  *(_QWORD *)(v52 + 40) = a11;
  *(_QWORD *)(v52 + 80) = v44;
  v54 = *(_krb5_context **)(a11 + 32);
  if ((*(_BYTE *)(*(_QWORD *)(a11 + 48) + 105) & 0x10) != 0)
  {
    v58 = sub_20968B958(v54);
    v59 = *(_QWORD *)(a11 + 48);
    LODWORD(v74[0]) = 69632;
    v75[0] = 0;
    sub_20969D1E8(*(_QWORD *)(a11 + 32), 10, "Got delegated query on: %s", *(const char **)(v53 + 80));
    *(_QWORD *)(v53 + 72) = heim_retain(*(CFTypeRef *)(v59 + 208));
    DelegateConnection = DNSServiceCreateDelegateConnection();
    v61 = *(_QWORD *)(a11 + 32);
    if (DelegateConnection)
    {
      sub_20969D1E8(v61, 2, "Failed setting up search context for addrinfo resolving for %s failed: %d");
      goto LABEL_70;
    }
    sub_20969D1E8(v61, 10, "setting queue");
    v63 = DNSServiceSetDispatchQueue(*(DNSServiceRef *)(v53 + 56), *(dispatch_queue_t *)(v53 + 72));
    v64 = *v14;
    if (v63)
    {
      sub_20969D1E8(v64, 2, "Failed setting run queue for SRV query: %d");
      goto LABEL_70;
    }
    v65 = sub_2096997A8(v64, *(char **)(*(_QWORD *)(a11 + 48) + 96), v59, v74);
    v66 = j__dispatch_semaphore_create(0);
    *(_QWORD *)(v53 + 48) = v66;
    if (!v66)
      goto LABEL_70;
    heim_retain((CFTypeRef)v53);
    if ((v58 & 1) != 0)
    {
      if ((v58 & 2) != 0)
      {
        v68 = 3;
      }
      else
      {
        *(_BYTE *)(v53 + 96) |= 0x20u;
        v68 = 1;
      }
    }
    else
    {
      v67 = *(_BYTE *)(v53 + 96);
      *(_BYTE *)(v53 + 96) = v67 | 0x10;
      if ((v58 & 2) == 0)
      {
        *(_BYTE *)(v53 + 96) = v67 | 0x30;
        sub_20969D1E8(*v14, 10, "No support address families: %s");
        goto LABEL_82;
      }
      v68 = 2;
    }
    sub_20969D1E8(*v14, 10, "DNS SRV using address flags: %08x", v68);
    asprintf(v75, "%s.", *(const char **)(v53 + 80));
    *(_QWORD *)(v53 + 64) = *(_QWORD *)(v53 + 56);
    AddrInfo = DNSServiceGetAddrInfo((DNSServiceRef *)(v53 + 64), LODWORD(v74[0]) | 0x4000, v65, v68, v75[0], (DNSServiceGetAddrInfoReply)sub_20969A4C0, (void *)v53);
    free(v75[0]);
    if (AddrInfo)
    {
      sub_20969D1E8(*v14, 10, "Failed doing A/AAAA lookup: %s: %d");
      goto LABEL_82;
    }
  }
  else
  {
    sub_20969D1E8((uint64_t)v54, 10, "Adding host: %s:%d", v44, v42);
    sub_20969A838(v53, *(char **)(v53 + 80), 0, (uint64_t)"srv", a11);
  }
  v55 = malloc_type_realloc(*(void **)(a11 + 88), 8 * (*(_DWORD *)(a11 + 96) + 1), 0x2004093837F09uLL);
  if (!v55)
  {
    sub_20969D1E8(*v14, 10, "SRV callback: realloc failed");
    if (*(_QWORD *)(v53 + 64))
    {
      v62 = *(NSObject **)(v53 + 72);
      v72[0] = MEMORY[0x24BDAC760];
      v72[1] = 0x40000000;
      v72[2] = sub_20969A910;
      v72[3] = &unk_24C1F2360;
      v72[4] = v53;
      dispatch_sync(v62, v72);
      goto LABEL_70;
    }
LABEL_82:
    heim_release((CFTypeRef)v53);
    goto LABEL_70;
  }
  *(_QWORD *)(a11 + 88) = v55;
  v56 = heim_retain((CFTypeRef)v53);
  v57 = *(unsigned int *)(a11 + 96);
  *(_QWORD *)(*(_QWORD *)(a11 + 88) + 8 * v57) = v56;
  *(_DWORD *)(a11 + 96) = v57 + 1;
LABEL_70:
  sub_20969D1E8(*v14, 10, "SRV callback end: %s", a5);
  heim_release((CFTypeRef)v53);
LABEL_10:
  if ((v12 & 1) == 0)
  {
    sub_20969D1E8(*(_QWORD *)(a11 + 32), 10, "SRV callback no more coming");
    v15 = time(0);
    if ((*(_BYTE *)(a11 + 80) & 1) != 0)
      heim_abort("DNS-SD invariant not true, canceled but got error message:!query->state.srvQueryDone", v16, v17, v18, v19, v20, v21, v22, v70);
    *(_BYTE *)(a11 + 80) |= 1u;
    if (*(_DWORD *)(a11 + 96))
    {
      v23 = 0;
      v24 = v15 + 10;
      v25 = (char *)MEMORY[0x24BDAC760];
      do
      {
        v26 = *(_QWORD *)(*(_QWORD *)(a11 + 88) + 8 * v23);
        v27 = *(_QWORD *)(v26 + 88);
        if (v27)
        {
          v28 = (const char *)(v27 + 48);
        }
        else
        {
          v29 = *(const char **)(v26 + 80);
          if (v29)
            v28 = v29;
          else
            v28 = "<no-hostname>";
        }
        v30 = v24 - time(0);
        v31 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a11 + 88) + 8 * v23) + 48);
        if (v31)
          v32 = v30 < 1;
        else
          v32 = 1;
        if (v32)
        {
          if (!v31)
            goto LABEL_36;
        }
        else if (v23 < *(unsigned int *)(*v14 + 344))
        {
          sub_20969D1E8(*v14, 10, "SRV waiting for addrinfo: %s", v28);
          if (sub_2096D7C5C(*(NSObject **)(*(_QWORD *)(*(_QWORD *)(a11 + 88) + 8 * v23) + 48), v30))
          {
            v33 = *(NSObject **)(*(_QWORD *)(a11 + 48) + 208);
            v74[0] = v25;
            v74[1] = 0x40000000;
            v74[2] = sub_20969AAA0;
            v74[3] = &unk_24C1F23C8;
            v74[4] = a11;
            v74[5] = v23;
            v34 = v74;
LABEL_31:
            dispatch_sync(v33, v34);
            v35 = *v14;
            if (qword_2545A7DB8 != -1)
              dispatch_once(&qword_2545A7DB8, &unk_24C1F0070);
            if (qword_2545A7DA8 && qword_2545A7DB0)
            {
              sub_20969D1E8(v35, 10, " DNS adding negative cache for %s for %ld seconds", v28, 3600);
              v75[0] = v25;
              v75[1] = (char *)0x40000000;
              v75[2] = (char *)sub_20969AB10;
              v75[3] = (char *)&unk_24C1F2428;
              v75[4] = (char *)3600;
              v75[5] = (char *)v28;
              dispatch_sync((dispatch_queue_t)qword_2545A7DA8, v75);
            }
            goto LABEL_36;
          }
          goto LABEL_36;
        }
        if (*(_QWORD *)(*(_QWORD *)(a11 + 48) + 208))
        {
          sub_20969D1E8(*(_QWORD *)(a11 + 32), 10, "SRV timeout waiting for addrinfo: %s", v28);
          v33 = *(NSObject **)(*(_QWORD *)(a11 + 48) + 208);
          block[0] = v25;
          block[1] = 0x40000000;
          block[2] = sub_20969AABC;
          block[3] = &unk_24C1F23E8;
          block[4] = a11;
          block[5] = v23;
          v34 = block;
          goto LABEL_31;
        }
LABEL_36:
        ++v23;
      }
      while (v23 < *(unsigned int *)(a11 + 96));
    }
    _krb5_state_srv_sort(a11);
    sub_20969D1E8(*(_QWORD *)(a11 + 32), 10, "SRV order after sorting");
    if (*(_DWORD *)(a11 + 96))
    {
      v36 = 0;
      do
      {
        v37 = *(_QWORD *)(*(_QWORD *)(a11 + 88) + 8 * v36);
        v38 = *(_QWORD *)(v37 + 88);
        if (v38)
        {
          v39 = (const char *)(v38 + 48);
          LODWORD(v38) = *(unsigned __int16 *)(v38 + 4);
        }
        else
        {
          v39 = *(const char **)(v37 + 80);
          if (!v39)
            v39 = "<no-hostname>";
        }
        sub_20969D1E8(*(_QWORD *)(a11 + 32), 10, "  SRV%lu kdc: %s:%d prio: %d weight: %d", v36, v39, v38, *(unsigned __int16 *)(v37 + 34), *(_DWORD *)(v37 + 36));
        if (v36 < *(unsigned int *)(*v14 + 344))
        {
          sub_209699294(*v14, *(_QWORD *)(a11 + 48), *(int **)(*(_QWORD *)(*(_QWORD *)(a11 + 88) + 8 * v36) + 88));
          *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a11 + 88) + 8 * v36) + 88) = 0;
        }
        ++v36;
      }
      while (v36 < *(unsigned int *)(a11 + 96));
    }
    dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a11 + 40));
    heim_release((CFTypeRef)a11);
  }
}

void sub_20969A2F4(uint64_t a1)
{
  uint64_t v2;

  DNSServiceRefDeallocate(*(DNSServiceRef *)(a1 + 32));
  v2 = *(_QWORD *)(a1 + 40);
  if ((*(_BYTE *)(v2 + 80) & 1) == 0)
  {
    *(_BYTE *)(v2 + 80) |= 1u;
    heim_release(*(CFTypeRef *)(a1 + 40));
  }
}

uint64_t sub_20969A33C(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  BOOL v3;
  _QWORD block[7];
  uint64_t v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t v9;

  v2 = 0;
  if (qword_2545A7DA8)
    v3 = qword_2545A7DB0 == 0;
  else
    v3 = 1;
  v6 = 0;
  v7 = &v6;
  v8 = 0x2000000000;
  v9 = 0;
  if (!v3)
  {
    block[0] = MEMORY[0x24BDAC760];
    block[1] = 0x40000000;
    block[2] = sub_20969A968;
    block[3] = &unk_24C1F2388;
    block[4] = &v6;
    block[5] = a2;
    block[6] = a1;
    dispatch_sync((dispatch_queue_t)qword_2545A7DA8, block);
    v2 = v7[3];
  }
  _Block_object_dispose(&v6, 8);
  return v2;
}

_QWORD *sub_20969A3EC(uint64_t a1)
{
  const void *v2;
  NSObject *v3;
  void *v4;
  _QWORD *result;
  _QWORD *v6;
  int8x16_t v7;
  _QWORD block[4];
  int8x16_t v9;
  NSObject *v10;

  if ((*(_BYTE *)(a1 + 96) & 1) == 0)
    sub_20969D1E8(0, 10, "srv_release w/o getAddrDone set");
  v2 = *(const void **)(a1 + 48);
  if (v2)
    heim_release(v2);
  v3 = *(NSObject **)(a1 + 72);
  if (v3)
  {
    v7 = *(int8x16_t *)(a1 + 56);
    *(_QWORD *)(a1 + 56) = 0;
    *(_QWORD *)(a1 + 64) = 0;
    heim_retain(v3);
    block[0] = MEMORY[0x24BDAC760];
    block[1] = 0x40000000;
    block[2] = sub_20969AA68;
    block[3] = &unk_24C1F23A8;
    v9 = vextq_s8(v7, v7, 8uLL);
    v10 = v3;
    dispatch_async(v3, block);
  }
  v4 = *(void **)(a1 + 80);
  if (v4)
    free(v4);
  result = *(_QWORD **)(a1 + 88);
  if (result)
  {
    do
    {
      v6 = (_QWORD *)result[2];
      sub_2096979E8(result);
      result = v6;
    }
    while (v6);
  }
  return result;
}

void sub_20969A4C0(uint64_t a1, char a2, uint64_t a3, int a4, char *a5, const sockaddr *a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  int v13;
  char v14;
  int sa_family;
  char v16;
  int v17;
  const char *v18;
  const char *v19;
  const char *v20;
  const char *v21;
  const char *v22;
  socklen_t v23;
  unsigned int v24;
  int v25;
  int v26;
  addrinfo v27;
  addrinfo *v28;
  char __str[32];
  char v30[1025];
  uint64_t v31;

  v31 = *MEMORY[0x24BDAC8D0];
  v8 = *(_QWORD *)(a8 + 40);
  v28 = 0;
  if ((*(_BYTE *)(a8 + 96) & 1) != 0)
    return;
  if ((*(_BYTE *)(a8 + 96) & 2) != 0)
  {
    sub_20969D1E8(*(_QWORD *)(v8 + 32), 10, "SRV getaddrinfo: canceled: %s");
    goto LABEL_13;
  }
  if (!a4)
  {
    sub_20969D1E8(*(_QWORD *)(v8 + 32), 10, "DNS getaddrinfo callback on: %s for af = %d", a5, a6->sa_family);
    sa_family = a6->sa_family;
    if (sa_family == 2)
    {
      v16 = 4;
    }
    else
    {
      if (sa_family != 30)
      {
        v17 = 1;
LABEL_41:
        v23 = sub_2096B9984((uint64_t)a6);
        if (!getnameinfo(a6, v23, v30, 0x401u, 0, 0, 2))
        {
          memset(&v27, 0, sizeof(v27));
          snprintf(__str, 0x20uLL, "%d", *(unsigned __int16 *)(a8 + 32));
          v24 = *(_DWORD *)(v8 + 68);
          sub_209697C7C((uint64_t)&v27, v24);
          v25 = a6->sa_family;
          v27.ai_flags = 4100;
          v27.ai_family = v25;
          sub_20969D1E8(*(_QWORD *)(v8 + 32), 10, " SRV getaddrinfo: %s domain: proto: %d addr: %s:%d", *(const char **)(v8 + 56), v24, v30, *(unsigned __int16 *)(a8 + 32));
          v26 = getaddrinfo(v30, __str, &v27, &v28);
          if (v26)
            sub_20969D1E8(*(_QWORD *)(v8 + 32), 10, " SRV getaddrinfo: failed to parse host: [%s]:%s error: %d", v30, __str, v26);
          if (v28)
          {
            sub_20969D1E8(*(_QWORD *)(v8 + 32), 10, " Adding srv-addrinfo host: %s:%d", a5, *(unsigned __int16 *)(a8 + 32));
            sub_20969A838(a8, a5, v28, (uint64_t)"srv-addrinfo", v8);
          }
        }
        goto LABEL_14;
      }
      v16 = 8;
    }
    v17 = 0;
    *(_BYTE *)(a8 + 96) |= v16;
    goto LABEL_41;
  }
  if (a4 == -65554)
  {
    v13 = a6->sa_family;
    if (v13 == 2)
    {
      v14 = 16;
    }
    else
    {
      if (v13 != 30)
      {
        v17 = 1;
        goto LABEL_37;
      }
      v14 = 32;
    }
    v17 = 0;
    *(_BYTE *)(a8 + 96) |= v14;
LABEL_37:
    sub_20969D1E8(*(_QWORD *)(v8 + 32), 10, "SRV callback: getaddrinfo on %s: no such record for af = %d", a5, a6->sa_family);
    goto LABEL_14;
  }
  sub_20969D1E8(*(_QWORD *)(v8 + 32), 10, "SRV getaddrinfo other error: %d");
LABEL_13:
  v17 = 1;
LABEL_14:
  v18 = "more coming";
  if ((a2 & 1) == 0)
    v18 = "done";
  v19 = "yes";
  if ((*(_BYTE *)(a8 + 96) & 4) != 0)
    v20 = "yes";
  else
    v20 = "waiting";
  if ((*(_BYTE *)(a8 + 96) & 0x10) != 0)
    v20 = "no-rr";
  if ((*(_BYTE *)(a8 + 96) & 8) == 0)
    v19 = "waiting";
  if ((*(_BYTE *)(a8 + 96) & 0x20) != 0)
    v21 = "no-rr";
  else
    v21 = v19;
  sub_20969D1E8(*(_QWORD *)(v8 + 32), 10, " SRV getaddrinfo end: %s (%s) (IPv4:%s) (IPv6:%s)", a5, v18, v20, v21);
  if (v17)
  {
    v22 = "failed";
LABEL_28:
    sub_20969D1E8(*(_QWORD *)(v8 + 32), 10, " DNS getaddrinfo done: %s %s", *(const char **)(a8 + 80), v22);
    *(_BYTE *)(a8 + 96) |= 1u;
    j__dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a8 + 48));
    heim_release((CFTypeRef)a8);
    return;
  }
  if ((*(_BYTE *)(a8 + 96) & 0x14) != 0 && (a2 & 1) == 0 && (*(_BYTE *)(a8 + 96) & 0x28) != 0)
  {
    v22 = "success";
    goto LABEL_28;
  }
}

void sub_20969A838(uint64_t a1, char *__s, addrinfo *a3, uint64_t a4, uint64_t a5)
{
  size_t v10;
  char *v11;
  char *v12;
  void *v13;
  size_t v14;
  const char *v15;
  uint64_t v16;

  v10 = strlen(__s);
  v11 = (char *)malloc_type_calloc(1uLL, v10 + 56, 0x2A9CC98DuLL);
  if (v11)
  {
    v12 = v11;
    v13 = v11 + 48;
    v14 = strlen(__s);
    memcpy(v13, __s, v14 + 1);
    *(_DWORD *)v12 = *(_DWORD *)(a5 + 68);
    *((_WORD *)v12 + 3) = 0;
    *((_WORD *)v12 + 2) = *(_WORD *)(a1 + 32);
    v15 = *(const char **)(a5 + 72);
    if (v15)
      *((_QWORD *)v12 + 5) = strdup(v15);
    *((_QWORD *)v12 + 4) = a4;
    v16 = *(_QWORD *)(a1 + 88);
    *((_QWORD *)v12 + 1) = a3;
    *((_QWORD *)v12 + 2) = v16;
    *(_QWORD *)(a1 + 88) = v12;
  }
  else if (a3)
  {
    freeaddrinfo(a3);
  }
}

void sub_20969A910(uint64_t a1)
{
  _DNSServiceRef_t *v2;
  uint64_t v3;

  v2 = *(_DNSServiceRef_t **)(*(_QWORD *)(a1 + 32) + 64);
  if (v2)
  {
    DNSServiceRefDeallocate(v2);
    *(_QWORD *)(*(_QWORD *)(a1 + 32) + 64) = 0;
    v3 = *(_QWORD *)(a1 + 32);
    if ((*(_BYTE *)(v3 + 96) & 1) == 0)
    {
      *(_BYTE *)(v3 + 96) |= 1u;
      heim_release(*(CFTypeRef *)(a1 + 32));
    }
  }
}

void sub_20969A968(uint64_t a1)
{
  CFStringRef v2;
  CFStringRef v3;
  const __CFNumber *v4;
  const __CFNumber *v5;
  time_t v6;
  uint64_t v7;

  v2 = heim_string_create(*(char **)(a1 + 40));
  if (v2)
  {
    v3 = v2;
    v4 = (const __CFNumber *)heim_dict_copy_value((const __CFDictionary *)qword_2545A7DB0, v2);
    if (v4)
    {
      v5 = v4;
      v6 = time(0);
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = (int)heim_number_get_int(v5);
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) -= v6;
      heim_release(v5);
    }
    v7 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
    if (v7 <= 0)
    {
      heim_dict_delete_key((CFMutableDictionaryRef)qword_2545A7DB0, v3);
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 0;
    }
    else
    {
      sub_20969D1E8(*(_QWORD *)(a1 + 48), 10, " DNS negative cache for host %s for another %ld seconds", *(const char **)(a1 + 40), v7);
    }
    heim_release(v3);
  }
}

void sub_20969AA68(uint64_t a1)
{
  _DNSServiceRef_t *v2;
  _DNSServiceRef_t *v3;

  v2 = *(_DNSServiceRef_t **)(a1 + 32);
  if (v2)
    DNSServiceRefDeallocate(v2);
  v3 = *(_DNSServiceRef_t **)(a1 + 40);
  if (v3)
    DNSServiceRefDeallocate(v3);
  heim_release(*(CFTypeRef *)(a1 + 48));
}

uint64_t sub_20969AAA0(uint64_t result)
{
  uint64_t v1;

  v1 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 88) + 8 * *(_QWORD *)(result + 40));
  *(_BYTE *)(v1 + 96) |= 2u;
  return result;
}

uint64_t sub_20969AABC(uint64_t result)
{
  uint64_t v1;

  v1 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 88) + 8 * *(_QWORD *)(result + 40));
  *(_BYTE *)(v1 + 96) |= 2u;
  return result;
}

dispatch_queue_t sub_20969AAD8()
{
  dispatch_queue_t result;

  qword_2545A7DB0 = (uint64_t)heim_dict_create();
  result = dispatch_queue_create("krbhst-dns-cache", 0);
  qword_2545A7DA8 = (uint64_t)result;
  return result;
}

void sub_20969AB10(uint64_t a1)
{
  int v2;
  CFNumberRef v3;
  CFNumberRef v4;
  CFStringRef v5;
  CFStringRef v6;

  v2 = time(0);
  v3 = heim_number_create(*(_DWORD *)(a1 + 32) + v2);
  if (v3)
  {
    v4 = v3;
    v5 = heim_string_create(*(char **)(a1 + 40));
    if (v5)
    {
      v6 = v5;
      heim_dict_set_value((__CFDictionary *)qword_2545A7DB0, v5, v4);
      heim_release(v4);
      v4 = (CFNumberRef)v6;
    }
    heim_release(v4);
  }
}

void sub_20969AB88(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  void *v4;
  void *v5;
  uint64_t v6;
  NSObject *v7;
  NSObject *v8;
  NSObject *v9;
  _QWORD block[5];

  v2 = *(_QWORD **)(a1 + 168);
  if (v2)
  {
    do
    {
      v3 = (_QWORD *)v2[2];
      sub_2096979E8(v2);
      v2 = v3;
    }
    while (v3);
  }
  *(_QWORD *)(a1 + 168) = 0;
  v4 = *(void **)(a1 + 128);
  if (v4)
  {
    free(v4);
    *(_QWORD *)(a1 + 128) = 0;
  }
  v5 = *(void **)(a1 + 136);
  if (v5)
  {
    free(v5);
    *(_QWORD *)(a1 + 136) = 0;
  }
  v6 = *(_QWORD *)(a1 + 216);
  if (v6)
  {
    *(_QWORD *)(a1 + 216) = 0;
    v7 = *(NSObject **)(a1 + 200);
    block[0] = MEMORY[0x24BDAC760];
    block[1] = 0x40000000;
    block[2] = sub_20969AC64;
    block[3] = &unk_24C1F2448;
    block[4] = v6;
    dispatch_async(v7, block);
  }
  v8 = *(NSObject **)(a1 + 200);
  if (v8)
  {
    sub_2096D7C48(v8);
    *(_QWORD *)(a1 + 200) = 0;
  }
  v9 = *(NSObject **)(a1 + 208);
  if (v9)
  {
    sub_2096D7C48(v9);
    *(_QWORD *)(a1 + 208) = 0;
  }
  pthread_mutex_destroy((pthread_mutex_t *)(a1 + 32));
  free(*(void **)(a1 + 96));
  *(_QWORD *)(a1 + 96) = 0;
}

void sub_20969AC64(uint64_t a1)
{
  DNSServiceRefDeallocate(*(DNSServiceRef *)(a1 + 32));
}

uint64_t sub_20969AC6C(_krb5_context *a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, __int128 *a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, unsigned int *a11, krb5_keyblock **a12, uint64_t a13)
{
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t (*v24)(_krb5_context *, uint64_t, __int128 *, _OWORD *);
  uint64_t checksum;
  int v26;
  uint64_t v27;
  uint64_t v28;
  size_t v29;
  void *v30;
  uint64_t v31;
  _DWORD *v32;
  void *v33;
  _QWORD *v34;
  _DWORD *v35;
  void *v36;
  void *v37;
  void *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  size_t v46;
  void *v47;
  krb5_keyblock **v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  __int128 v61;
  __int128 v62;
  __int128 v63;
  __int128 v64;
  __int128 v65;
  __int128 v66;
  __int128 v67;
  __int128 v68;
  __int128 v69;
  __int128 v70;
  __int128 v71;
  __int128 v72;
  __int128 v73;
  __int128 v74;
  uint64_t v75;
  _OWORD v76[8];
  uint64_t v77;
  uint64_t v78;
  krb5_auth_context v79;

  v78 = 0;
  v79 = 0;
  v77 = 0;
  *(_OWORD *)a13 = 0u;
  *(_OWORD *)(a13 + 16) = 0u;
  *(_OWORD *)(a13 + 32) = 0u;
  *(_OWORD *)(a13 + 48) = 0u;
  *(_OWORD *)(a13 + 64) = 0u;
  *(_OWORD *)(a13 + 80) = 0u;
  *(_OWORD *)(a13 + 96) = 0u;
  *(_QWORD *)(a13 + 112) = 0;
  krb5_data_zero(&v77);
  v24 = *(uint64_t (**)(_krb5_context *, uint64_t, __int128 *, _OWORD *))(*(_QWORD *)a2 + 240);
  if (v24)
  {
    v75 = 0;
    v73 = 0u;
    v74 = 0u;
    v71 = 0u;
    v72 = 0u;
    v69 = 0u;
    v70 = 0u;
    v67 = 0u;
    v68 = 0u;
    v65 = 0u;
    v66 = 0u;
    v63 = 0u;
    v64 = 0u;
    v61 = 0u;
    v62 = 0u;
    v59 = 0u;
    v60 = 0u;
    v57 = 0u;
    v58 = 0u;
    v55 = 0u;
    v56 = 0u;
    v53 = 0u;
    v54 = 0u;
    v51 = 0u;
    v52 = 0u;
    v49 = 0u;
    v50 = 0u;
    memset(v76, 0, sizeof(v76));
    checksum = v24(a1, a2, &v49, v76);
    if (!(_DWORD)checksum)
      sub_2096BC404();
    return checksum;
  }
  v26 = *(_DWORD *)(a9 + 136);
  if (a6)
  {
    v48 = 0;
    v76[0] = 0uLL;
    v51 = 0uLL;
    v49 = *a6;
    v27 = *((_QWORD *)a6 + 3);
    *(_QWORD *)&v50 = *((_QWORD *)a6 + 2);
    *((_QWORD *)&v50 + 1) = v27;
    *(_QWORD *)&v52 = 0;
    *((_QWORD *)&v52 + 1) = "Kerberos";
    checksum = _krb5_s4u2self_to_checksumdata(a1, (uint64_t)&v49, (size_t *)v76);
    if ((_DWORD)checksum)
      goto LABEL_45;
    v28 = krb5_crypto_init(a1, (const krb5_keyblock *)(a9 + 16), 0, &v48);
    if ((_DWORD)v28)
    {
      checksum = v28;
      krb5_data_free(v76);
      goto LABEL_45;
    }
    checksum = krb5_create_checksum(a1, (_DWORD **)v48, 0x11u, 0, *((uint64_t *)&v76[0] + 1), *(uint64_t *)&v76[0], (uint64_t)&v51);
    krb5_crypto_destroy(a1, (uint64_t)v48);
    krb5_data_free(v76);
    if ((_DWORD)checksum)
      goto LABEL_45;
    v29 = sub_2096BC1F0();
    v30 = malloc_type_malloc(v29, 0x4BDAB54AuLL);
    if (!v30)
    {
      checksum = 12;
      goto LABEL_13;
    }
    v46 = v29;
    v47 = v30;
    v31 = sub_2096BC1D0();
    if ((_DWORD)v31)
    {
      checksum = v31;
      free(v47);
LABEL_13:
      sub_2096BB8BC();
      goto LABEL_45;
    }
    sub_2096BB8BC();
    if (v29)
      krb5_abortx(a1, "internal asn1 error");
    checksum = krb5_padata_add(a1, a11, 129, (uint64_t)v47, 0);
    if ((_DWORD)checksum)
      goto LABEL_45;
  }
  *(_QWORD *)a13 = 0xC00000005;
  if (*(_DWORD *)(a8 + 16))
  {
    *(_DWORD *)(a13 + 80) = 1;
    v32 = malloc_type_calloc(1uLL, 4uLL, 0x100004052888210uLL);
    *(_QWORD *)(a13 + 88) = v32;
    if (!v32)
      goto LABEL_44;
    *v32 = *(_DWORD *)(a8 + 16);
  }
  else
  {
    checksum = _krb5_init_etype(a1, 4, (unsigned int *)(a13 + 80), (uint64_t *)(a13 + 88), 0, v21, v22, v23);
    if ((_DWORD)checksum)
      goto LABEL_45;
  }
  *(_DWORD *)(a13 + 16) = v26 & 0xA | a5 & 0xFFFFFFF5;
  *(_QWORD *)(a13 + 96) = a4;
  checksum = sub_2096BB420();
  if ((_DWORD)checksum)
    goto LABEL_45;
  v33 = malloc_type_calloc(1uLL, 0x18uLL, 0x10800407C14B876uLL);
  *(_QWORD *)(a13 + 40) = v33;
  if (!v33)
    goto LABEL_44;
  checksum = sub_2096BB494();
  if ((_DWORD)checksum)
    goto LABEL_45;
  v34 = malloc_type_calloc(1uLL, 8uLL, 0x100004000313F17uLL);
  *(_QWORD *)(a13 + 56) = v34;
  if (!v34)
    goto LABEL_44;
  *v34 = *(_QWORD *)(a8 + 56);
  *(_DWORD *)(a13 + 72) = a10;
  if (!a7)
    goto LABEL_28;
  v35 = malloc_type_calloc(1uLL, 0x10uLL, 0x1020040D5A9D86FuLL);
  *(_QWORD *)(a13 + 112) = v35;
  if (!v35
    || (*v35 = 1,
        v36 = malloc_type_calloc(1uLL, 0x48uLL, 0x1090040DEC7D988uLL),
        (*(_QWORD *)(*(_QWORD *)(a13 + 112) + 8) = v36) == 0))
  {
LABEL_44:
    checksum = 12;
    krb5_set_error_message(a1, 12, "malloc: out of memory", v46);
    goto LABEL_45;
  }
  checksum = sub_2096BB814();
  if ((_DWORD)checksum)
    goto LABEL_45;
LABEL_28:
  if (a11)
  {
    if (!*(_QWORD *)(a13 + 8))
    {
      v37 = malloc_type_calloc(1uLL, 0x10uLL, 0x1020040D5A9D86FuLL);
      *(_QWORD *)(a13 + 8) = v37;
      if (!v37)
      {
LABEL_51:
        v44 = krb5_enomem(a1);
        goto LABEL_52;
      }
    }
    checksum = sub_2096BB9E4();
    if ((_DWORD)checksum)
      goto LABEL_45;
  }
  checksum = krb5_auth_con_init(a1, &v79);
  if ((_DWORD)checksum)
    goto LABEL_45;
  checksum = krb5_auth_con_generatelocalsubkey(a1, (uint64_t)v79, (unsigned int *)(a9 + 16));
  if ((_DWORD)checksum)
    goto LABEL_45;
  checksum = sub_20969B22C(a1, a13 + 16, (_DWORD *)(a8 + 104), *((const krb5_keyblock **)v79 + 5));
  if ((_DWORD)checksum)
    goto LABEL_45;
  if (!*(_QWORD *)(a13 + 8))
  {
    v38 = malloc_type_calloc(1uLL, 0x10uLL, 0x1020040D5A9D86FuLL);
    *(_QWORD *)(a13 + 8) = v38;
    if (!v38)
      goto LABEL_51;
  }
  checksum = sub_20969B3A0(a1, v79, a13 + 16, a2, a9, (uint64_t)&v77);
  if (!(_DWORD)checksum)
  {
    if (a3)
    {
      *(_QWORD *)(a3 + 24) = v79;
      checksum = sub_2096B710C(a1, a3, 0, v39, v40, v41, v42, v43);
      *(_QWORD *)(a3 + 24) = 0;
      if ((_DWORD)checksum)
        goto LABEL_45;
      checksum = sub_2096B7400(a1, a3, &v77, a13);
      if ((_DWORD)checksum)
        goto LABEL_45;
      *(_DWORD *)(a3 + 4) &= ~0x20u;
    }
    checksum = krb5_padata_add(a1, *(unsigned int **)(a13 + 8), 1, v78, v77);
    if (!(_DWORD)checksum)
    {
      krb5_data_zero(&v77);
      v44 = krb5_auth_con_getlocalsubkey(a1, (uint64_t)v79, a12);
LABEL_52:
      checksum = v44;
    }
  }
LABEL_45:
  if (v79)
    krb5_auth_con_free(a1, v79);
  if ((_DWORD)checksum)
  {
    *(_QWORD *)(a13 + 96) = 0;
    sub_2096BBAD0();
  }
  krb5_data_free(&v77);
  return checksum;
}

uint64_t sub_20969B22C(_krb5_context *a1, uint64_t a2, _DWORD *a3, const krb5_keyblock *a4)
{
  size_t v7;
  void *v8;
  void *v9;
  uint64_t v10;
  uint64_t v11;
  void *v13;
  krb5_keyblock **v14;
  size_t v15;

  if (!*a3)
  {
    v11 = 0;
LABEL_6:
    *(_QWORD *)(a2 + 88) = 0;
    return v11;
  }
  v14 = 0;
  v15 = 0;
  v7 = sub_2096BB618();
  v8 = malloc_type_malloc(v7, 0xDDC2985EuLL);
  if (!v8)
    return 12;
  v9 = v8;
  v10 = sub_2096BB5F8();
  if (!(_DWORD)v10)
  {
    if (v7 != v15)
      krb5_abortx(a1, "internal error in ASN.1 encoder", v14);
    v13 = malloc_type_calloc(1uLL, 0x20uLL, 0x1090040863882BEuLL);
    *(_QWORD *)(a2 + 88) = v13;
    if (!v13)
    {
      free(v9);
      v11 = 12;
      krb5_set_error_message(a1, 12, "malloc: out of memory", v14);
      return v11;
    }
    v11 = krb5_crypto_init(a1, a4, 0, &v14);
    if (!(_DWORD)v11)
    {
      krb5_encrypt_EncryptedData(a1, (_DWORD **)v14, 5, v9, v15, 0, *(_QWORD *)(a2 + 88));
      free(v9);
      krb5_crypto_destroy(a1, (uint64_t)v14);
      return v11;
    }
    free(v9);
    free(*(void **)(a2 + 88));
    goto LABEL_6;
  }
  v11 = v10;
  free(v9);
  return v11;
}

uint64_t sub_20969B3A0(_krb5_context *a1, _krb5_auth_context *a2, uint64_t a3, int a4, uint64_t a5, uint64_t a6)
{
  size_t v10;
  void *v11;
  void *v12;
  uint64_t v13;
  uint64_t v15[2];
  krb5_auth_context v16;

  v16 = a2;
  v10 = sub_2096BBA18();
  v11 = malloc_type_malloc(v10, 0xBC45CE0FuLL);
  if (!v11)
    return 12;
  v12 = v11;
  v13 = sub_2096BB9F8();
  if (!(_DWORD)v13)
  {
    if (v10)
      krb5_abortx(a1, "internal error in ASN.1 encoder");
    v15[0] = 0;
    v15[1] = (uint64_t)v12;
    v13 = sub_20969F3D4(a1, &v16, 0, v15, a4, a5, a6, 6u, 7u);
  }
  free(v12);
  return v13;
}

uint64_t sub_20969B498(_krb5_context *a1, krb5_keyblock *a2, int a3, uint64_t a4, uint64_t a5)
{
  uint64_t v9;
  _BOOL4 v10;
  krb5_keyblock v12;
  krb5_keyblock **v13[2];
  _QWORD v14[2];

  if (a3)
    sub_2096D7D28();
  v14[0] = 0;
  v14[1] = 0;
  v13[0] = 0;
  v13[1] = 0;
  memset(&v12, 0, sizeof(v12));
  krb5_data_zero(v14);
  krb5_keyblock_zero((uint64_t)&v12);
  if (!*(_QWORD *)a4)
    goto LABEL_12;
  v9 = sub_20969B688(a1, *(_QWORD *)(a4 + 8), *(krb5_keyblock **)a4, &v12);
  if ((_DWORD)v9)
    return v9;
  v9 = krb5_crypto_init(a1, &v12, 0, v13);
  krb5_free_keyblock_contents(a1, &v12);
  if ((_DWORD)v9)
    return v9;
  if (krb5_decrypt_EncryptedData(a1, (uint64_t)v13[0], 9, a5 + 120, v14))
    v10 = **(_DWORD **)a4 != 23
       || krb5_decrypt_EncryptedData(a1, (uint64_t)v13[0], 8, a5 + 120, v14) != 0;
  else
    v10 = 0;
  krb5_crypto_destroy(a1, (uint64_t)v13[0]);
  if (!*(_QWORD *)a4 || v10)
  {
LABEL_12:
    v9 = sub_20969B688(a1, *(_QWORD *)(a4 + 8), a2, &v12);
    if ((_DWORD)v9)
      return v9;
    v9 = krb5_crypto_init(a1, &v12, 0, v13);
    krb5_free_keyblock_contents(a1, &v12);
    if ((_DWORD)v9)
      return v9;
    v9 = krb5_decrypt_EncryptedData(a1, (uint64_t)v13[0], 8, a5 + 120, v14);
    krb5_crypto_destroy(a1, (uint64_t)v13[0]);
    if ((_DWORD)v9)
      return v9;
  }
  if (sub_2096BBD20())
  {
    v9 = sub_2096BBD50();
    if ((_DWORD)v9)
      krb5_set_error_message(a1, v9, "Failed to decode encpart in ticket");
  }
  else
  {
    v9 = 0;
  }
  krb5_data_free(v14);
  return v9;
}

uint64_t sub_20969B688(_krb5_context *a1, uint64_t a2, krb5_keyblock *a3, krb5_keyblock *a4)
{
  _DWORD *v8;
  krb5_magic magic;
  uint64_t v10;
  uint64_t v11;

  if (a2 && *(_QWORD *)(a2 + 80))
  {
    sub_20969D1E8((uint64_t)a1, 5, "_krb5_fast_tgs_strengthen_key");
    v8 = *(_DWORD **)(a2 + 80);
    magic = a3->magic;
    if (*v8 != a3->magic)
    {
      v11 = 2529638953;
      krb5_set_error_message(a1, -1765328343, "strengthen_key %d not same enctype as reply key %d", *v8, magic);
      return v11;
    }
    _krb5_debug_keyblock((uint64_t)a1, 10, "tkt: strengthen_key", (uint64_t)v8);
    _krb5_debug_keyblock((uint64_t)a1, 10, "tkt: old reply_key", (uint64_t)a3);
    v10 = _krb5_fast_cf2(a1, *(const krb5_keyblock **)(a2 + 80), "strengthenkey", a3, "replykey", a4, 0);
  }
  else
  {
    v10 = krb5_copy_keyblock_contents(a1, a3, a4);
  }
  v11 = v10;
  if (!(_DWORD)v10)
  {
    _krb5_debug_keyblock((uint64_t)a1, 10, "tkt: extract key", (uint64_t)a4);
    return 0;
  }
  return v11;
}

uint64_t krb5_tkt_creds_init(_krb5_context *a1, uint64_t a2, const krb5_creds *a3, uint64_t a4, uint64_t *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v9;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;

  v9 = a4;
  *a5 = 0;
  v13 = heim_uniq_alloc(0x208uLL, (uint64_t)"tkt-ctx", (uint64_t)sub_20969B8B8, a4, (uint64_t)a5, a6, a7, a8);
  if (!v13)
    return 12;
  v14 = v13;
  *(_QWORD *)(v13 + 32) = a1;
  *(_QWORD *)(v13 + 40) = sub_20969B924;
  *(_DWORD *)(v13 + 48) = v9;
  *(_QWORD *)(v13 + 88) = a2;
  if ((v9 & 0x10) == 0)
  {
    if ((v9 & 2) == 0)
      goto LABEL_4;
LABEL_10:
    *(_DWORD *)(v13 + 68) |= 0x10000000u;
    *(_DWORD *)(v13 + 48) = v9 | 8;
    if ((v9 & 0x80) == 0)
      goto LABEL_6;
    goto LABEL_5;
  }
  *(_DWORD *)(v13 + 68) |= 2u;
  if ((v9 & 2) != 0)
    goto LABEL_10;
LABEL_4:
  if ((v9 & 0x80) != 0)
LABEL_5:
    *(_DWORD *)(v13 + 68) |= 0x8000u;
LABEL_6:
  v15 = krb5_copy_creds(a1, a3, (krb5_creds **)(v13 + 96));
  if ((_DWORD)v15)
  {
    v16 = v15;
  }
  else
  {
    v16 = krb5_unparse_name(a1, *(krb5_const_principal *)(*(_QWORD *)(v14 + 96) + 8), (char **)(v14 + 56));
    if (!(_DWORD)v16)
    {
      *a5 = v14;
      return v16;
    }
  }
  heim_release((CFTypeRef)v14);
  return v16;
}

void sub_20969B8B8(uint64_t a1)
{
  krb5_creds *v2;
  krb5_creds **v3;
  krb5_creds *v4;
  uint64_t v5;

  v2 = *(krb5_creds **)(a1 + 512);
  if (v2)
    krb5_free_creds(*(krb5_context *)(a1 + 32), v2);
  sub_20969BA8C(*(_krb5_context **)(a1 + 32), a1);
  v3 = *(krb5_creds ***)(a1 + 408);
  if (v3)
  {
    v4 = *v3;
    if (*v3)
    {
      v5 = 1;
      do
      {
        krb5_free_creds(*(krb5_context *)(a1 + 32), v4);
        v3 = *(krb5_creds ***)(a1 + 408);
        v4 = v3[v5++];
      }
      while (v4);
    }
    free(v3);
  }
  free(*(void **)(a1 + 56));
}

uint64_t sub_20969B924(uint64_t a1, uint64_t a2)
{
  sub_20969D1E8(a1, 10, "tkt_init: %s", *(const char **)(a2 + 56));
  *(_QWORD *)(a2 + 40) = sub_20969BADC;
  return 0;
}

uint64_t krb5_tkt_creds_step(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, _QWORD *a5, _DWORD *a6)
{
  uint64_t result;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t (*v21)(uint64_t, uint64_t, uint64_t, uint64_t *, _QWORD *, _DWORD *);
  char v22;

  krb5_data_zero(a4);
  result = 0;
  *a6 = 0;
  *a5 = 0;
  *(_DWORD *)(a2 + 64) = 0;
  if (!*a4)
  {
    while (1)
    {
      v21 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t *, _QWORD *, _DWORD *))(a2 + 40);
      if (!v21)
        return 0;
      result = v21(a1, a2, a3, a4, a5, a6);
      if ((_DWORD)result)
        break;
      v20 = *a4;
      if ((*(_BYTE *)a6 & 1) != 0)
      {
        if (!v20)
          heim_abort("no data to send to KDC:out->length != 0", v13, v14, v15, v16, v17, v18, v19, v22);
        if (!*a5)
          heim_abort("no realm to send data too:*realm != NULL", v13, v14, v15, v16, v17, v18, v19, v22);
        return 0;
      }
      if (v20)
        heim_abort("out state but not state continue:out->length == 0", v13, v14, v15, v16, v17, v18, v19, v22);
    }
    if (*(_DWORD *)(a2 + 64) != (_DWORD)result)
      heim_abort("error not same as saved:ctx->error == ret", v13, v14, v15, v16, v17, v18, v19, v22);
  }
  return result;
}

uint64_t krb5_tkt_creds_get_creds(_krb5_context *a1, uint64_t a2, krb5_creds **a3)
{
  if (*(_QWORD *)(a2 + 40))
    return 22;
  if (*(_QWORD *)(a2 + 512))
    return krb5_copy_creds(a1, *(const krb5_creds **)(a2 + 512), a3);
  return *(unsigned int *)(a2 + 64);
}

void krb5_tkt_creds_free(uint64_t a1, const void *a2)
{
  heim_release(a2);
}

void sub_20969BA8C(_krb5_context *a1, uint64_t a2)
{
  sub_2096B7CE0(a1, a2 + 424);
  krb5_free_cred_contents(a1, (krb5_creds *)(a2 + 120));
  krb5_free_cred_contents(a1, (krb5_creds *)(a2 + 264));
  krb5_free_keyblock(a1, *(krb5_keyblock **)(a2 + 112));
  *(_QWORD *)(a2 + 112) = 0;
}

uint64_t sub_20969BADC(_krb5_context *a1, uint64_t a2)
{
  char *realm;
  int principal;
  int v6;
  _krb5_ccache *v7;
  const krb5_principal_data *v8;
  krb5_error_code v9;
  void *v10;
  krb5_principal v12;
  _BYTE mcreds[144];
  char *v14;

  v12 = 0;
  sub_20969D1E8((uint64_t)a1, 10, "tkt_step_referrals: %s", *(const char **)(a2 + 56));
  *(_OWORD *)(a2 + 264) = 0u;
  *(_OWORD *)(a2 + 280) = 0u;
  *(_OWORD *)(a2 + 296) = 0u;
  *(_OWORD *)(a2 + 312) = 0u;
  *(_OWORD *)(a2 + 328) = 0u;
  *(_OWORD *)(a2 + 344) = 0u;
  *(_OWORD *)(a2 + 360) = 0u;
  *(_OWORD *)(a2 + 376) = 0u;
  *(_OWORD *)(a2 + 392) = 0u;
  *(_DWORD *)(a2 + 104) = 0x8000;
  realm = (char *)krb5_principal_get_realm((uint64_t)a1, **(_QWORD **)(a2 + 96));
  principal = krb5_make_principal(a1, &v12, realm, "krbtgt", realm, 0);
  if (principal)
    goto LABEL_2;
  v7 = *(_krb5_ccache **)(a2 + 88);
  v8 = v12;
  memset(mcreds, 0, sizeof(mcreds));
  krb5_cc_clear_mcred(mcreds);
  *(_QWORD *)&mcreds[8] = v8;
  if (krb5_cc_retrieve_cred(a1, v7, 0x80000000, (krb5_creds *)mcreds, (krb5_creds *)(a2 + 120)))
  {
    v6 = -1765328243;
    v14 = 0;
    if (krb5_unparse_name(a1, v8, &v14))
    {
      krb5_clear_error_message(a1);
    }
    else
    {
      krb5_set_error_message(a1, -1765328243, "Matching credential (%s) not found", v14);
      free(v14);
    }
    krb5_free_principal(a1, v12);
    goto LABEL_11;
  }
  krb5_free_principal(a1, v12);
  principal = krb5_copy_principal(a1, **(krb5_const_principal **)(a2 + 96), (krb5_principal *)(a2 + 264));
  if (principal)
  {
LABEL_2:
    v6 = principal;
LABEL_11:
    v10 = sub_20969BCD0;
    goto LABEL_12;
  }
  v9 = krb5_copy_principal(a1, *(krb5_const_principal *)(*(_QWORD *)(a2 + 96) + 8), (krb5_principal *)(a2 + 272));
  v10 = sub_20969BCD0;
  if (v9)
  {
    v6 = v9;
  }
  else
  {
    v6 = krb5_principal_set_realm(a1, *(_QWORD *)(a2 + 272), *(char **)(*(_QWORD *)(a2 + 128) + 24));
    if (!v6)
      v10 = sub_20969BD34;
  }
LABEL_12:
  *(_DWORD *)(a2 + 64) = v6;
  *(_QWORD *)(a2 + 40) = v10;
  return 0;
}

uint64_t sub_20969BCD0(_krb5_context *a1, uint64_t a2)
{
  sub_20969D1E8((uint64_t)a1, 10, "tkt_direct_init: %s", *(const char **)(a2 + 56));
  sub_20969BA8C(a1, a2);
  *(_DWORD *)(a2 + 64) = 22;
  *(_QWORD *)(a2 + 40) = sub_20969BF0C;
  return 0;
}

uint64_t sub_20969BD34(_krb5_context *a1, uint64_t a2, uint64_t a3, uint64_t a4, _QWORD *a5, _DWORD *a6)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t (*v13)(_krb5_context *, uint64_t, const krb5_data *);
  size_t v15;
  void *v16;
  uint64_t v17;
  char *v18;
  char *v19;
  _QWORD v20[2];
  uint64_t v21;
  _OWORD v22[6];
  __int128 v23;
  uint64_t v24;

  v20[1] = 0;
  v21 = 0;
  v20[0] = 0;
  memset(v22, 0, sizeof(v22));
  v23 = 0u;
  v24 = 0;
  krb5_generate_random_block(a2 + 108, 4);
  if (_krb5_have_debug((_BOOL8)a1))
  {
    v18 = 0;
    v19 = 0;
    krb5_unparse_name(a1, *(krb5_const_principal *)(a2 + 128), &v18);
    krb5_unparse_name(a1, *(krb5_const_principal *)(a2 + 272), &v19);
    sub_20969D1E8((uint64_t)a1, 10, "sending TGS-REQ for %s using %s", v19, v18);
  }
  v11 = sub_20969AC6C(a1, *(_QWORD *)(a2 + 88), a2 + 424, *(_QWORD *)(a2 + 80), *(_DWORD *)(a2 + 104), *(__int128 **)(a2 + 72), 0, a2 + 264, a2 + 120, *(_DWORD *)(a2 + 108), (unsigned int *)v20, (krb5_keyblock **)(a2 + 112), (uint64_t)v22);
  if ((_DWORD)v11)
  {
    v12 = v11;
    v13 = 0;
  }
  else
  {
    v15 = sub_2096BBAC0();
    *(_QWORD *)a4 = v15;
    v16 = malloc_type_malloc(v15, 0xFE0E7D5FuLL);
    *(_QWORD *)(a4 + 8) = v16;
    if (v16)
    {
      v17 = sub_2096BBAA0();
      if ((_DWORD)v17)
      {
        v12 = v17;
        free(*(void **)(a4 + 8));
        v13 = 0;
        *(_QWORD *)(a4 + 8) = 0;
      }
      else
      {
        if (*(_QWORD *)a4 != v21)
          krb5_abortx(a1, "internal error in ASN.1 encoder");
        *(_QWORD *)&v23 = 0;
        sub_2096BBAD0();
        v12 = 0;
        *a5 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 128) + 16) + 8);
        *a6 |= 1u;
        v13 = sub_20969BF68;
      }
    }
    else
    {
      v13 = 0;
      v12 = 12;
    }
  }
  *(_DWORD *)(a2 + 64) = v12;
  *(_QWORD *)(a2 + 40) = v13;
  return v12;
}

uint64_t sub_20969BF0C(_krb5_context *a1, uint64_t a2)
{
  sub_20969D1E8((uint64_t)a1, 10, "tkt_step_capath: %s", *(const char **)(a2 + 56));
  sub_20969BA8C(a1, a2);
  *(_DWORD *)(a2 + 64) = 22;
  *(_QWORD *)(a2 + 40) = 0;
  return 0;
}

uint64_t sub_20969BF68(_krb5_context *a1, uint64_t a2, const krb5_data *a3)
{
  krb5_error_code v6;
  uint64_t result;
  uint64_t (*v8)(_krb5_context *, uint64_t);
  char v9;
  krb5_error_code v10;
  const char *error_message;
  uint64_t *v12;
  unint64_t v13;
  uint64_t v14;
  BOOL v15;
  int v16;
  BOOL v17;
  unsigned int v18;
  uint64_t *v19;
  uint64_t v20;
  krb5_creds **v21;
  krb5_creds **v22;
  krb5_error_code v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  _OWORD v29[9];
  krb5_principal v30[2];
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  _OWORD v42[24];
  __int128 v43;

  memset(v29, 0, sizeof(v29));
  sub_20969D1E8((uint64_t)a1, 10, "tkt_referral_recv: %s", *(const char **)(a2 + 56));
  v41 = 0;
  memset(v42, 0, sizeof(v42));
  v43 = 0u;
  v37 = 0u;
  v38 = 0u;
  v35 = 0u;
  v36 = 0u;
  v33 = 0u;
  v34 = 0u;
  v31 = 0u;
  v32 = 0u;
  *(_OWORD *)v30 = 0u;
  if (*(_QWORD *)(**(_QWORD **)(a2 + 88) + 248))
  {
    v6 = 22;
LABEL_3:
    sub_20969D1E8((uint64_t)a1, 10, "tkt_referral_recv: parse_tgs_rep %d", v6);
    sub_20969BA8C(a1, a2);
LABEL_4:
    result = 0;
    v8 = sub_20969BF0C;
    goto LABEL_5;
  }
  if (sub_2096BBCDC())
  {
    if (krb5_rd_error(a1, a3, (krb5_error **)&v42[18] + 1))
    {
      krb5_clear_error_message(a1);
      krb5_free_kdc_rep((uint64_t)a1, v42);
      v6 = -1765328344;
      goto LABEL_3;
    }
    v39 = 0;
    v40 = 0;
    if (*((_QWORD *)&v43 + 1) && (v10 = sub_2096BB9B4()) != 0)
    {
      v6 = v10;
      krb5_set_error_message(a1, v10, "Failed to decode METHOD-DATA");
    }
    else
    {
      v6 = sub_2096B78BC(a1, a2 + 424, (uint64_t)&v39, (uint64_t)&v42[18] + 8);
      sub_2096BB9D4();
      if (!v6)
      {
        v6 = krb5_error_from_rd_error(a1, (uint64_t)&v42[18] + 8, *(uint64_t **)(a2 + 96));
        if (_krb5_have_debug((_BOOL8)a1))
        {
          error_message = krb5_get_error_message(a1, v6);
          sub_20969D1E8((uint64_t)a1, 5, "parse_tgs_rep: KRB-ERROR %d/%s", v6, error_message);
          krb5_free_error_message(a1, error_message);
        }
      }
    }
  }
  else
  {
    v6 = sub_2096B7B24(a1, *(_DWORD *)(a2 + 108), 0, a2 + 424, (uint64_t)v42);
    if (v6)
      goto LABEL_3;
    v6 = krb5_copy_principal(a1, *(krb5_const_principal *)(a2 + 264), v30);
    if (v6)
      goto LABEL_3;
    v6 = krb5_copy_principal(a1, *(krb5_const_principal *)(a2 + 272), &v30[1]);
    if (v6)
      goto LABEL_3;
    *((_QWORD *)&v33 + 1) = *(_QWORD *)(*(_QWORD *)(a2 + 96) + 56);
    v9 = (*(_BYTE *)(a2 + 106) & 1) != 0 || *(_QWORD *)(a2 + 72);
    v39 = *(_QWORD *)(a2 + 112);
    v40 = a2 + 424;
    v6 = sub_2096B1B94((uint64_t)a1, (uint64_t)v42, (uint64_t)v30, (const krb5_keyblock *)(a2 + 136), 0, (krb5_address *const *)(a2 + 240), *(_DWORD *)(a2 + 108), v9, 0, (uint64_t (*)(_krb5_context *, const krb5_keyblock *, uint64_t, uint64_t, uint64_t))sub_20969B498, (uint64_t)&v39);
  }
  krb5_free_kdc_rep((uint64_t)a1, v42);
  if (v6)
    goto LABEL_3;
  if (!krb5_principal_compare_any_realm((uint64_t)a1, *(_QWORD *)(a2 + 272), (uint64_t)v30[1]))
  {
    if (krb5_principal_is_krbtgt((uint64_t)a1, (uint64_t)v30[1]))
    {
      sub_20969D1E8((uint64_t)a1, 10, "KDC for realm %s sends a referrals to %s", *(const char **)(*(_QWORD *)(a2 + 128) + 24), *((const char **)v30[1]->realm.data + 1));
      krb5_cc_clear_mcred(v29);
      *((krb5_principal *)&v29[0] + 1) = v30[1];
      v12 = *(uint64_t **)(a2 + 408);
      if (v12)
      {
        v13 = 0;
        do
        {
          v14 = v12[v13];
          v15 = v14 != 0;
          if (!v14)
            break;
          if (krb5_compare_creds(a1, 0x80000000, (uint64_t)v29, v14))
          {
            sub_20969D1E8((uint64_t)a1, 5, "Referral from %s loops back to realm %s", *(const char **)(*(_QWORD *)(a2 + 128) + 24), (const char *)v30[1]->data);
            goto LABEL_4;
          }
          ++v13;
          v12 = *(uint64_t **)(a2 + 408);
        }
        while (v12);
        if (v13 >= 0x10)
          goto LABEL_4;
      }
      else
      {
        v15 = 1;
      }
      v16 = DWORD2(v38);
      if (*(_DWORD *)(a2 + 416))
        v17 = (WORD4(v38) & 0x2000) == 0;
      else
        v17 = 1;
      if (v17)
      {
        *(_DWORD *)(a2 + 416) = 0;
        DWORD2(v38) = v16 & 0xFFFFDFFF;
      }
      if (v15)
      {
        v18 = 0;
      }
      else
      {
        v18 = -1;
        v19 = v12;
        do
        {
          v20 = *v19++;
          ++v18;
        }
        while (v20);
      }
      v21 = (krb5_creds **)malloc_type_realloc(v12, 8 * (v18 + 2), 0x2004093837F09uLL);
      if (v21)
      {
        v22 = v21;
        *(_QWORD *)(a2 + 408) = v21;
        v23 = krb5_copy_creds(a1, (const krb5_creds *)v30, &v21[v18]);
        v22[v18 + 1] = 0;
        if (!v23)
        {
          krb5_free_cred_contents(a1, (krb5_creds *)(a2 + 120));
          v24 = v33;
          *(_OWORD *)(a2 + 152) = v32;
          *(_OWORD *)(a2 + 168) = v24;
          v25 = v38;
          v26 = v36;
          *(_OWORD *)(a2 + 232) = v37;
          *(_OWORD *)(a2 + 248) = v25;
          v27 = v35;
          *(_OWORD *)(a2 + 184) = v34;
          *(_OWORD *)(a2 + 200) = v27;
          *(_OWORD *)(a2 + 216) = v26;
          v28 = v31;
          *(_OWORD *)(a2 + 120) = *(_OWORD *)v30;
          *(_OWORD *)(a2 + 136) = v28;
          result = krb5_principal_set_realm(a1, *(_QWORD *)(a2 + 272), *(char **)(*(_QWORD *)(a2 + 128) + 24));
          if (!(_DWORD)result)
          {
            v8 = (uint64_t (*)(_krb5_context *, uint64_t))sub_20969BD34;
            goto LABEL_5;
          }
        }
      }
      else
      {
        krb5_set_error_message(a1, 12, "malloc: out of memory");
      }
    }
    else
    {
      krb5_set_error_message(a1, -1765328349, "Got back an non krbtgt ticket referrals");
      krb5_free_cred_contents(a1, (krb5_creds *)v30);
    }
    goto LABEL_4;
  }
  result = krb5_copy_creds(a1, (const krb5_creds *)v30, (krb5_creds **)(a2 + 512));
  if ((_DWORD)result)
  {
    *(_DWORD *)(a2 + 64) = result;
    return result;
  }
  krb5_free_cred_contents(a1, (krb5_creds *)v30);
  result = 0;
  v8 = sub_20969C484;
LABEL_5:
  *(_QWORD *)(a2 + 40) = v8;
  return result;
}

uint64_t sub_20969C484(_krb5_context *a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  krb5_creds **v10;
  krb5_creds *v11;
  _krb5_ccache *v12;
  krb5_creds **v13;
  uint64_t client;
  krb5_creds *v15;
  krb5_creds *v16;
  krb5_creds **v17;
  krb5_creds *v18;
  krb5_creds *v19;
  _OWORD *v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  _krb5_ccache *v27;
  __int128 *v28;
  uint64_t v29;
  char v31;
  __int128 v32;
  uint64_t v33;
  const char *v34;
  _OWORD creds[9];

  sub_20969D1E8((uint64_t)a1, 10, "tkt_step_store: %s", *(const char **)(a2 + 56));
  *(_DWORD *)(a2 + 64) = 0;
  *(_QWORD *)(a2 + 40) = 0;
  if ((*(_BYTE *)(a2 + 48) & 8) == 0)
  {
    v10 = *(krb5_creds ***)(a2 + 408);
    if (v10)
    {
      v11 = *v10;
      if (*v10)
      {
        v12 = *(_krb5_ccache **)(a2 + 88);
        v13 = v10 + 1;
        do
        {
          client = (uint64_t)v11->client;
          if (krb5_principal_is_krbtgt((uint64_t)a1, client)
            && strcmp(*(const char **)(*(_QWORD *)(client + 16) + 8), *(const char **)(client + 24)))
          {
            krb5_cc_store_cred(a1, v12, *(v13 - 1));
          }
          v15 = *v13++;
          v11 = v15;
        }
        while (v15);
        v16 = *v10;
        if (*v10)
        {
          v17 = v10 + 1;
          do
          {
            krb5_free_creds(a1, v16);
            v18 = *v17++;
            v16 = v18;
          }
          while (v18);
        }
      }
      free(*(void **)(a2 + 408));
      *(_QWORD *)(a2 + 408) = 0;
    }
    v19 = *(krb5_creds **)(a2 + 512);
    if (!v19)
      heim_abort("store but no credential:ctx->cred != NULL", v4, 0, v5, v6, v7, v8, v9, v31);
    krb5_cc_store_cred(a1, *(krb5_ccache *)(a2 + 88), v19);
    if (!krb5_principal_compare_any_realm((uint64_t)a1, *(_QWORD *)(*(_QWORD *)(a2 + 512) + 8), *(_QWORD *)(*(_QWORD *)(a2 + 96) + 8)))
    {
      v20 = *(_OWORD **)(a2 + 512);
      creds[0] = *v20;
      v21 = v20[4];
      v23 = v20[1];
      v22 = v20[2];
      creds[3] = v20[3];
      creds[4] = v21;
      creds[1] = v23;
      creds[2] = v22;
      v24 = v20[8];
      v26 = v20[5];
      v25 = v20[6];
      creds[7] = v20[7];
      creds[8] = v24;
      creds[5] = v26;
      creds[6] = v25;
      v27 = *(_krb5_ccache **)(a2 + 88);
      v28 = *(__int128 **)(*(_QWORD *)(a2 + 96) + 8);
      v29 = *((_QWORD *)v28 + 2);
      v32 = *v28;
      v33 = v29;
      v34 = "";
      *((_QWORD *)&creds[0] + 1) = &v32;
      krb5_cc_store_cred(a1, v27, (krb5_creds *)creds);
    }
  }
  return 0;
}

krb5_BOOLean krb5_kuserok(krb5_context a1, krb5_principal a2, const char *a3)
{
  passwd *v6;
  uint64_t v7;
  const char *pw_dir;
  size_t v9;
  char *v10;
  char *v11;
  int v12;
  BOOL v13;
  int v14;
  int v15;
  BOOL v16;
  int v17;
  int v18;
  DIR *v19;
  DIR *v20;
  int v21;
  dirent *v22;
  dirent *v23;
  int v24;
  krb5_BOOLean v25;
  char *const *v26;
  _QWORD *v27;
  const char *realm;
  const char *comp_string;
  size_t v31;
  size_t v32;
  char *__s;
  stat v35;
  stat v36;
  uint64_t v37;

  v37 = *MEMORY[0x24BDAC8D0];
  LODWORD(__s) = 0;
  v6 = getpwnam(a3);
  if (!v6)
    goto LABEL_52;
  v7 = (uint64_t)v6;
  pw_dir = v6->pw_dir;
  v9 = strlen(pw_dir) + 12;
  v10 = (char *)malloc_type_malloc(v9, 0x3E1E8F29uLL);
  if (!v10)
    goto LABEL_52;
  v11 = v10;
  strlcpy(v10, pw_dir, v9);
  strlcat(v11, "/.k5login", v9);
  v12 = sub_20969CA4C(a1, v11, v7, a2, (krb5_BOOLean *)&__s);
  if (v12)
    v13 = 0;
  else
    v13 = (_DWORD)__s == 1;
  if (v13)
  {
    free(v11);
    return 1;
  }
  v14 = v12;
  strlcat(v11, ".d", v9);
  memset(&v35, 0, sizeof(v35));
  LODWORD(__s) = 0;
  if (lstat(v11, &v35) < 0)
    goto LABEL_32;
  if ((v35.st_mode & 0xF000) != 0x4000)
  {
    v15 = 0;
    v18 = 20;
    goto LABEL_37;
  }
  v15 = 0;
  if (v35.st_uid)
    v16 = v35.st_uid == *(_DWORD *)(v7 + 16);
  else
    v16 = 1;
  v17 = v16;
  v18 = 13;
  if ((v35.st_mode & 0x12) != 0 || !v17)
    goto LABEL_37;
  v19 = opendir(v11);
  if (!v19)
  {
LABEL_32:
    v15 = 0;
    v18 = *__error();
    goto LABEL_37;
  }
  v20 = v19;
  memset(&v36, 0, sizeof(v36));
  v21 = dirfd(v19);
  if (fstat(v21, &v36) < 0)
  {
    closedir(v20);
    v18 = *__error();
  }
  else
  {
    if (v35.st_dev == v36.st_dev && v35.st_ino == v36.st_ino)
    {
      v22 = readdir(v20);
      if (v22)
      {
        v23 = v22;
        v15 = 0;
        do
        {
          if (strcmp(v23->d_name, "."))
          {
            if (strcmp(v23->d_name, ".."))
            {
              if (v23->d_name[0] != 35 && *(&v23->d_type + strlen(v23->d_name)) != 126)
              {
                snprintf((char *)&v36, 0x400uLL, "%s/%s", v11, v23->d_name);
                v24 = sub_20969CA4C(a1, (char *)&v36, v7, a2, (krb5_BOOLean *)&__s);
                v15 = (int)__s;
                if (!v24 && (_DWORD)__s == 1)
                  break;
              }
            }
          }
          v23 = readdir(v20);
        }
        while (v23);
      }
      else
      {
        v15 = 0;
      }
      closedir(v20);
      v18 = 0;
      goto LABEL_37;
    }
    closedir(v20);
    v18 = 13;
  }
  v15 = 0;
LABEL_37:
  free(v11);
  if (!v18 && v15 == 1)
    return 1;
  if ((v18 == 20 || v18 == 2) && v14 == 2 && !krb5_principal_get_comp_string((uint64_t)a1, (uint64_t)a2, 1u))
  {
    *(_QWORD *)&v36.st_dev = 0;
    if (!krb5_get_default_realms((CFArrayRef *)a1, (char *const **)&v36))
    {
      v26 = *(char *const **)&v36.st_dev;
      if (**(_QWORD **)&v36.st_dev)
      {
        v27 = (_QWORD *)(*(_QWORD *)&v36.st_dev + 8);
        while (1)
        {
          realm = (const char *)krb5_principal_get_realm((uint64_t)a1, (uint64_t)a2);
          if (!strcmp(realm, (const char *)*(v27 - 1)))
          {
            comp_string = (const char *)krb5_principal_get_comp_string((uint64_t)a1, (uint64_t)a2, 0);
            if (!strcmp(comp_string, a3))
              break;
          }
          if (!*v27++)
          {
            v26 = *(char *const **)&v36.st_dev;
            goto LABEL_51;
          }
        }
        krb5_free_host_realm(a1, *(char *const **)&v36.st_dev);
        return 1;
      }
LABEL_51:
      krb5_free_host_realm(a1, v26);
    }
  }
LABEL_52:
  *(_QWORD *)&v36.st_dev = 0;
  v36.st_ino = 0;
  *(_QWORD *)&v35.st_dev = 0;
  v35.st_ino = 0;
  __s = 0;
  v25 = !krb5_unparse_name(a1, a2, &__s)
     && (v31 = strlen(a3), !mbr_identifier_to_uuid(4, a3, v31, (unsigned __int8 *)&v35))
     && (v32 = strlen(__s), !mbr_identifier_to_uuid(12, __s, v32, (unsigned __int8 *)&v36))
     && uuid_compare((const unsigned __int8 *)&v36, (const unsigned __int8 *)&v35) == 0;
  if (__s)
    free(__s);
  return v25;
}

uint64_t sub_20969CA4C(_krb5_context *a1, char *__filename, uint64_t a3, const krb5_principal_data *a4, krb5_BOOLean *a5)
{
  FILE *v9;
  FILE *v10;
  int v11;
  size_t v13;
  int v14;
  krb5_principal v15;
  stat v16;
  char __s[1024];
  uint64_t v18;

  v18 = *MEMORY[0x24BDAC8D0];
  memset(&v16, 0, sizeof(v16));
  *a5 = 0;
  v9 = fopen(__filename, "r");
  if (!v9)
    return *__error();
  v10 = v9;
  rk_cloexec_file(v9);
  v11 = fileno(v10);
  if (fstat(v11, &v16))
  {
    fclose(v10);
    return *__error();
  }
  if ((v16.st_mode & 0xF000) == 0x4000)
  {
    fclose(v10);
    return 21;
  }
  else if (v16.st_uid && v16.st_uid != *(_DWORD *)(a3 + 16) || (v16.st_mode & 0x12) != 0)
  {
    fclose(v10);
    return 13;
  }
  else
  {
    while (fgets(__s, 1024, v10))
    {
      v15 = 0;
      v13 = strcspn(__s, "\n");
      if (__s[v13] == 10 || (v14 = fgetc(v10), v14 == -1))
      {
        __s[v13] = 0;
        if (!krb5_parse_name(a1, __s, &v15))
        {
          *a5 = krb5_principal_compare(a1, a4, v15);
          krb5_free_principal(a1, v15);
          if (*a5)
            break;
        }
      }
      else
      {
        while (v14 != -1 && v14 != 10)
          v14 = fgetc(v10);
      }
    }
    fclose(v10);
    return 0;
  }
}

uint64_t krb5_initlog(_krb5_context *a1, const char *a2, char ***a3)
{
  char **v6;
  char **v7;
  char *v8;
  uint64_t v9;

  v6 = (char **)malloc_type_calloc(1uLL, 0x18uLL, 0x1030040B20C17F8uLL);
  if (!v6)
    goto LABEL_5;
  v7 = v6;
  v8 = strdup(a2);
  *v7 = v8;
  if (!v8)
  {
    free(v7);
LABEL_5:
    v9 = 12;
    krb5_set_error_message(a1, 12, "malloc: out of memory");
    return v9;
  }
  v9 = 0;
  *a3 = v7;
  return v9;
}

uint64_t krb5_addlog_func(_krb5_context *a1, uint64_t a2, int a3, int a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  char *v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;

  v14 = (char *)malloc_type_realloc(*(void **)(a2 + 16), 32 * *(int *)(a2 + 8) + 32, 0x10800409938AC02uLL);
  if (v14)
  {
    v15 = 0;
    v16 = *(int *)(a2 + 8);
    *(_DWORD *)(a2 + 8) = v16 + 1;
    *(_QWORD *)(a2 + 16) = v14;
    v17 = &v14[32 * v16];
    *(_DWORD *)v17 = a3;
    *((_DWORD *)v17 + 1) = a4;
    *((_QWORD *)v17 + 1) = a5;
    *((_QWORD *)v17 + 2) = a6;
    *((_QWORD *)v17 + 3) = a7;
  }
  else
  {
    v15 = 12;
    krb5_set_error_message(a1, 12, "malloc: out of memory");
  }
  return v15;
}

uint64_t sub_20969CD88(_krb5_context *a1, uint64_t a2, int a3, int a4, void *a5, uint64_t a6, uint64_t a7, int a8, int a9)
{
  _QWORD *v17;

  v17 = malloc_type_malloc(0x20uLL, 0x107004068A0B128uLL);
  if (v17)
  {
    *v17 = a5;
    v17[1] = a6;
    v17[2] = a7;
    *((_DWORD *)v17 + 6) = a8;
    *((_DWORD *)v17 + 7) = a9;
    return krb5_addlog_func(a1, a2, a3, a4, (uint64_t)sub_20969D2F8, (uint64_t)sub_20969D3D0, (uint64_t)v17);
  }
  else
  {
    krb5_set_error_message(a1, 12, "malloc: out of memory");
    if (a5)
    {
      if (a9)
        free(a5);
    }
    return 12;
  }
}

uint64_t krb5_openlog(_krb5_context *a1, const char *a2, char ***a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  void **strings;
  char *v19;
  char **v20;
  uint64_t v21;
  char *v22;
  BOOL v23;

  v11 = krb5_initlog(a1, a2, a3);
  if ((_DWORD)v11)
    return v11;
  strings = (void **)krb5_config_get_strings((uint64_t)a1, 0, v5, v6, v7, v8, v9, v10, (uint64_t)"logging");
  if (strings
    || (strings = (void **)krb5_config_get_strings((uint64_t)a1, 0, v12, v13, v14, v15, v16, v17, (uint64_t)"logging")) != 0)
  {
    v19 = (char *)*strings;
    if (*strings)
    {
      v20 = (char **)(strings + 1);
      do
      {
        v21 = krb5_addlog_dest(a1, (const char **)*a3, v19);
        v22 = *v20++;
        v19 = v22;
        if (v22)
          v23 = (_DWORD)v21 == 0;
        else
          v23 = 0;
      }
      while (v23);
      v11 = v21;
    }
    else
    {
      v11 = 0;
    }
    krb5_config_free_strings(strings);
    return v11;
  }
  return krb5_addlog_dest(a1, (const char **)*a3, "SYSLOG");
}

uint64_t krb5_closelog(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;

  if (*(int *)(a2 + 8) >= 1)
  {
    v3 = 0;
    v4 = 0;
    do
    {
      (*(void (**)(_QWORD))(*(_QWORD *)(a2 + 16) + v3 + 16))(*(_QWORD *)(*(_QWORD *)(a2 + 16) + v3 + 24));
      ++v4;
      v3 += 32;
    }
    while (v4 < *(int *)(a2 + 8));
  }
  free(*(void **)(a2 + 16));
  free(*(void **)a2);
  free((void *)a2);
  return 0;
}

uint64_t krb5_vlog_msg(uint64_t a1, uint64_t a2, void **a3, int a4, char *a5, va_list a6)
{
  uint64_t v12;
  time_t v13;
  char *v14;
  uint64_t i;
  uint64_t v16;
  int v17;
  int v18;
  BOOL v19;
  void *v21;
  char v22[64];
  uint64_t v23;

  v23 = *MEMORY[0x24BDAC8D0];
  v21 = 0;
  if (a2 && *(int *)(a2 + 8) >= 1)
  {
    v12 = 0;
    v13 = 0;
    v14 = 0;
    for (i = 0; i < *(int *)(a2 + 8); ++i)
    {
      v16 = *(_QWORD *)(a2 + 16);
      if (*(_DWORD *)(v16 + v12) > a4)
        goto LABEL_10;
      v17 = *(_DWORD *)(v16 + v12 + 4);
      if ((v17 & 0x80000000) == 0 && v17 < a4)
        goto LABEL_10;
      if (v13)
      {
        if (!v14)
          goto LABEL_13;
      }
      else
      {
        v13 = time(0);
        krb5_format_time(a1, v13, v22, 0x40uLL, 1);
        if (!v14)
        {
LABEL_13:
          v18 = vasprintf((char **)&v21, a5, a6);
          if (v21)
            v19 = v18 < 0;
          else
            v19 = 1;
          if (v19)
            v14 = a5;
          else
            v14 = (char *)v21;
        }
      }
      (*(void (**)(char *, char *, _QWORD))(*(_QWORD *)(a2 + 16) + v12 + 8))(v22, v14, *(_QWORD *)(*(_QWORD *)(a2 + 16) + v12 + 24));
LABEL_10:
      v12 += 32;
    }
  }
  if (a3)
    *a3 = v21;
  else
    free(v21);
  return 0;
}

uint64_t krb5_vlog(uint64_t a1, uint64_t a2, int a3, char *a4, va_list a5)
{
  krb5_vlog_msg(a1, a2, 0, a3, a4, a5);
  return 0;
}

uint64_t krb5_log_msg(uint64_t a1, uint64_t a2, int a3, void **a4, char *a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  krb5_vlog_msg(a1, a2, a4, a3, a5, &a9);
  return 0;
}

uint64_t krb5_log(uint64_t a1, uint64_t a2, int a3, char *a4, ...)
{
  va_list va;

  va_start(va, a4);
  krb5_vlog_msg(a1, a2, 0, a3, a4, va);
  return 0;
}

uint64_t sub_20969D1E8(uint64_t result, int a2, char *a3, ...)
{
  va_list va;

  va_start(va, a3);
  if (result)
  {
    if (*(_QWORD *)(result + 160))
      return krb5_vlog_msg(result, *(_QWORD *)(result + 160), 0, a2, a3, va);
  }
  return result;
}

void sub_20969D22C(uint64_t *a1, int a2, krb5_error_code a3, char *a4, ...)
{
  const char *error_message;
  const char *v8;
  const char *v9;
  char *v10[2];
  va_list va;

  va_start(va, a4);
  v10[0] = 0;
  if (a1)
  {
    if (a1[20])
    {
      va_copy((va_list)&v10[1], va);
      vasprintf(v10, a4, va);
      if (v10[0])
      {
        error_message = krb5_get_error_message((krb5_context)a1, a3);
        v8 = error_message;
        v9 = "<unknown error>";
        if (error_message)
          v9 = error_message;
        krb5_log((uint64_t)a1, a1[20], a2, "%s: %s", v10[0], v9);
        krb5_free_error_message((krb5_context)a1, v8);
        free(v10[0]);
      }
    }
  }
}

BOOL _krb5_have_debug(_BOOL8 result)
{
  if (result)
    return *(_QWORD *)(result + 160) != 0;
  return result;
}

void sub_20969D2F8(const char *a1, char *__s, uint64_t a3)
{
  size_t v6;
  FILE *v7;
  char *v8;
  char *v9;

  v6 = strlen(__s);
  if (*(_DWORD *)(a3 + 24))
  {
    v7 = *(FILE **)(a3 + 16);
    if (!v7)
      return;
  }
  else
  {
    v7 = fopen(*(const char **)a3, *(const char **)(a3 + 8));
    if (!v7)
      return;
  }
  v8 = (char *)malloc_type_malloc(4 * v6 + 4, 0xF8F1D59DuLL);
  if (v8)
  {
    v9 = v8;
    strvisx(v8, __s, v6, 1);
    fprintf(v7, "%s %s\n", a1, v9);
    free(v9);
  }
  if (!*(_DWORD *)(a3 + 24))
    fclose(v7);
}

void sub_20969D3D0(FILE **a1)
{
  if (*((_DWORD *)a1 + 6))
  {
    if (!*a1)
      goto LABEL_7;
    fclose(a1[2]);
  }
  if (*a1 && *((_DWORD *)a1 + 7))
    free(*a1);
LABEL_7:
  free(a1);
}

void sub_20969D41C(uint64_t a1, const char *a2, int *a3)
{
  syslog(*a3, "%s", a2);
}

void sub_20969D448(void *a1)
{
  free(a1);
  closelog();
}

uint64_t sub_20969D45C(uint64_t a1, const char *a2, uint64_t a3)
{
  return asl_log(*(asl_object_t *)a3, *(asl_object_t *)(a3 + 8), *(_DWORD *)(a3 + 16), "%s", a2);
}

void sub_20969D490(_QWORD *a1)
{
  MEMORY[0x20BD11DA8](a1[1]);
  MEMORY[0x20BD11D9C](*a1);
  free(a1);
}

void sub_20969D4C0(int a1, uint64_t a2, os_log_t oslog)
{
  int v5;
  uint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  if (os_log_type_enabled(oslog, OS_LOG_TYPE_DEFAULT))
  {
    v5 = 136446210;
    v6 = a2;
    _os_log_impl(&dword_209677000, oslog, OS_LOG_TYPE_DEFAULT, "%{public}s", (uint8_t *)&v5, 0xCu);
  }
}

void sub_20969D558(int a1, uint64_t a2, os_log_t oslog)
{
  if (os_log_type_enabled(oslog, OS_LOG_TYPE_DEBUG))
    sub_2096D7D50(a2, oslog);
}

uint64_t sub_20969D59C(uint64_t a1, uint64_t a2)
{
  return **(_QWORD **)(a2 + 16);
}

uint64_t sub_20969D5A8(uint64_t a1, uint64_t a2, const char *a3)
{
  char **v6;
  const char *v7;

  pthread_mutex_lock(&stru_2545A4D98);
  v6 = (char **)off_2545A4D88;
  if (off_2545A4D88)
  {
    while (1)
    {
      v7 = *v6;
      if (!strcmp(*v6, a3))
        break;
      v6 = (char **)v6[5];
      if (!v6)
        goto LABEL_4;
    }
    sub_20969D1E8(a1, 20, "mcc_resolve, found: %s\n", v7);
    pthread_mutex_lock((pthread_mutex_t *)(v6 + 11));
    ++*((_DWORD *)v6 + 2);
    pthread_mutex_unlock((pthread_mutex_t *)(v6 + 11));
  }
  else
  {
LABEL_4:
    v6 = sub_20969E524(a3);
    sub_20969D1E8(a1, 20, "mcc_resolve, allocated: %s\n", *v6);
  }
  pthread_mutex_unlock(&stru_2545A4D98);
  *(_QWORD *)(*(_QWORD *)a2 + 16) = v6;
  *(_QWORD *)(*(_QWORD *)a2 + 8) = 152;
  return 0;
}

uint64_t sub_20969D6A0(uint64_t a1, uint64_t a2)
{
  char **v4;

  pthread_mutex_lock(&stru_2545A4D98);
  v4 = sub_20969E524(0);
  sub_20969D1E8(a1, 20, "mcc_gen_new: %s\n", *v4);
  pthread_mutex_unlock(&stru_2545A4D98);
  *(_QWORD *)(*(_QWORD *)a2 + 16) = v4;
  *(_QWORD *)(*(_QWORD *)a2 + 8) = 152;
  return 0;
}

uint64_t sub_20969D728(_krb5_context *a1, uint64_t a2, const krb5_principal_data *a3)
{
  const char **v5;
  int v6;
  uint64_t v7;
  krb5_principal_data *v8;
  const char *v9;
  const char *v10;
  const char **v11;
  krb5_principal_data *v12;
  krb5_principal v14;

  v5 = *(const char ***)(a2 + 16);
  v14 = 0;
  pthread_mutex_lock(&stru_2545A4D98);
  pthread_mutex_lock((pthread_mutex_t *)(v5 + 11));
  sub_20969D1E8((uint64_t)a1, 20, "mcc_initialize: %s\n", *v5);
  v6 = *((_DWORD *)v5 + 3);
  *((_DWORD *)v5 + 3) = 0;
  v5[7] = (const char *)time(0);
  v7 = krb5_copy_principal(a1, a3, &v14);
  if (!(_DWORD)v7)
  {
    v8 = (krb5_principal_data *)v5[2];
    if (v8)
      krb5_free_principal(a1, v8);
    v5[2] = (const char *)v14;
    sub_20969E660(a1, (uint64_t)v5);
    if (v6)
    {
      sub_20969D1E8((uint64_t)a1, 20, "mcc_initialize was dead: %s\n", *v5);
      v9 = (const char *)off_2545A4D88;
      if (off_2545A4D88)
      {
        v10 = *v5;
        v11 = (const char **)off_2545A4D88;
        while (strcmp(v10, *v11))
        {
          v11 = (const char **)v11[5];
          if (!v11)
          {
            v5[5] = v9;
            *((_QWORD *)v9 + 6) = v5 + 5;
            goto LABEL_12;
          }
        }
        v12 = (krb5_principal_data *)v5[2];
        if (v12)
        {
          krb5_free_principal(a1, v12);
          v5[2] = 0;
        }
        *((_DWORD *)v5 + 3) = 1;
        v7 = 17;
      }
      else
      {
        v5[5] = 0;
        qword_2545A4D90 = (uint64_t)(v5 + 5);
LABEL_12:
        v7 = 0;
        off_2545A4D88 = v5;
        v5[6] = (const char *)&off_2545A4D88;
      }
    }
    else
    {
      v7 = 0;
    }
  }
  pthread_mutex_unlock((pthread_mutex_t *)(v5 + 11));
  pthread_mutex_unlock(&stru_2545A4D98);
  return v7;
}

uint64_t sub_20969D8B0(_krb5_context *a1, uint64_t a2)
{
  const char **v3;

  v3 = *(const char ***)(a2 + 16);
  sub_20969D1E8((uint64_t)a1, 20, "mcc_destroy: %s\n", *v3);
  pthread_mutex_lock(&stru_2545A4D98);
  sub_20969E6CC(a1, (uint64_t)v3);
  pthread_mutex_unlock(&stru_2545A4D98);
  return 0;
}

uint64_t sub_20969D920(uint64_t a1, uint64_t a2)
{
  if (sub_20969E78C(a1, *(const char ***)(a2 + 16)))
    krb5_data_free((_QWORD *)(a2 + 8));
  return 0;
}

uint64_t sub_20969D954(_krb5_context *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;
  _QWORD *v7;
  _QWORD *v8;
  _QWORD *v9;
  uint64_t v10;
  _QWORD *v11;

  v5 = *(_QWORD *)(a2 + 16);
  pthread_mutex_lock((pthread_mutex_t *)(v5 + 88));
  if (*(_DWORD *)(v5 + 12))
  {
    pthread_mutex_unlock((pthread_mutex_t *)(v5 + 88));
    return 2;
  }
  else
  {
    v7 = malloc_type_calloc(1uLL, 0xA0uLL, 0x10A0040A2A4A3C5uLL);
    if (v7)
    {
      v8 = v7;
      v7[18] = 0;
      v9 = *(_QWORD **)(v5 + 32);
      v7[19] = v9;
      *v9 = v7;
      *(_QWORD *)(v5 + 32) = v7 + 18;
      *((_OWORD *)v7 + 7) = 0u;
      *((_OWORD *)v7 + 8) = 0u;
      *((_OWORD *)v7 + 5) = 0u;
      *((_OWORD *)v7 + 6) = 0u;
      *((_OWORD *)v7 + 3) = 0u;
      *((_OWORD *)v7 + 4) = 0u;
      *((_OWORD *)v7 + 1) = 0u;
      *((_OWORD *)v7 + 2) = 0u;
      *(_OWORD *)v7 = 0u;
      v6 = krb5_copy_creds_contents(a1, a3, (uint64_t)v7);
      if ((_DWORD)v6)
      {
        v10 = v8[18];
        v11 = (_QWORD *)v8[19];
        if (v10)
        {
          *(_QWORD *)(v10 + 152) = v11;
          v11 = (_QWORD *)v8[19];
        }
        else
        {
          *(_QWORD *)(v5 + 32) = v11;
        }
        *v11 = v10;
        free(v8);
      }
      else
      {
        *(_QWORD *)(v5 + 56) = time(0);
      }
      pthread_mutex_unlock((pthread_mutex_t *)(v5 + 88));
    }
    else
    {
      v6 = 2529639110;
      pthread_mutex_unlock((pthread_mutex_t *)(v5 + 88));
      krb5_set_error_message(a1, -1765328186, "malloc: out of memory");
    }
  }
  return v6;
}

uint64_t sub_20969DA84(_krb5_context *a1, uint64_t a2, krb5_principal *a3)
{
  uint64_t v5;
  uint64_t v6;
  const krb5_principal_data *v7;

  v5 = *(_QWORD *)(a2 + 16);
  pthread_mutex_lock((pthread_mutex_t *)(v5 + 88));
  sub_20969D1E8((uint64_t)a1, 20, "mcc_get_principal: %p\n", (const void *)v5);
  if (*(_DWORD *)(v5 + 12) || (v7 = *(const krb5_principal_data **)(v5 + 16)) == 0)
    v6 = 2;
  else
    v6 = krb5_copy_principal(a1, v7, a3);
  pthread_mutex_unlock((pthread_mutex_t *)(v5 + 88));
  return v6;
}

uint64_t sub_20969DB10(_krb5_context *a1, uint64_t a2, uint64_t **a3)
{
  uint64_t v5;
  pthread_mutex_t *v6;
  uint64_t v7;
  uint64_t *v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t *v13;
  uint64_t *v14;
  uint64_t v15;
  uint64_t **v16;
  uint64_t *v17;

  v5 = *(_QWORD *)(a2 + 16);
  v6 = (pthread_mutex_t *)(v5 + 88);
  pthread_mutex_lock((pthread_mutex_t *)(v5 + 88));
  if (*(_DWORD *)(v5 + 12))
  {
    pthread_mutex_unlock((pthread_mutex_t *)(v5 + 88));
    return 2;
  }
  else
  {
    v9 = (uint64_t *)malloc_type_calloc(1uLL, 0x10uLL, 0xA0040AFF93C70uLL);
    if (v9)
    {
      v10 = v9;
      *v9 = 0;
      v9[1] = (uint64_t)v9;
      v11 = *(_QWORD *)(v5 + 24);
      if (v11)
      {
        while (1)
        {
          v12 = *(_QWORD *)(v11 + 144);
          v13 = (uint64_t *)malloc_type_calloc(1uLL, 0xA0uLL, 0x10A0040A2A4A3C5uLL);
          if (!v13)
          {
            v7 = 2529639110;
            krb5_set_error_message(a1, -1765328186, "malloc: out of memory");
            sub_20969E868(a1, v10);
            v17 = v10;
            goto LABEL_13;
          }
          v14 = v13;
          v15 = krb5_copy_creds_contents(a1, v11, (uint64_t)v13);
          if ((_DWORD)v15)
            break;
          v14[18] = 0;
          v16 = (uint64_t **)v10[1];
          v14[19] = (uint64_t)v16;
          *v16 = v14;
          v10[1] = (uint64_t)(v14 + 18);
          v11 = v12;
          if (!v12)
            goto LABEL_9;
        }
        v7 = v15;
        v17 = v14;
LABEL_13:
        free(v17);
        pthread_mutex_unlock(v6);
      }
      else
      {
LABEL_9:
        pthread_mutex_unlock(v6);
        v7 = 0;
        *a3 = v10;
      }
    }
    else
    {
      v7 = 2529639110;
      pthread_mutex_unlock(v6);
      krb5_set_error_message(a1, -1765328186, "malloc: out of memory");
    }
  }
  return v7;
}

uint64_t sub_20969DC88(uint64_t a1, uint64_t a2, uint64_t *a3, _OWORD *a4)
{
  uint64_t v5;
  uint64_t v6;
  pthread_mutex_t *v7;
  _OWORD *v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  uint64_t v16;
  _QWORD *v17;

  v5 = *(_QWORD *)(a2 + 16);
  v6 = *a3;
  v7 = (pthread_mutex_t *)(v5 + 88);
  pthread_mutex_lock((pthread_mutex_t *)(v5 + 88));
  LODWORD(v5) = *(_DWORD *)(v5 + 12);
  pthread_mutex_unlock(v7);
  if ((_DWORD)v5)
    return 2;
  v9 = *(_OWORD **)v6;
  if (!*(_QWORD *)v6)
    return 2529639054;
  *a4 = *v9;
  v10 = v9[1];
  v11 = v9[2];
  v12 = v9[4];
  a4[3] = v9[3];
  a4[4] = v12;
  a4[1] = v10;
  a4[2] = v11;
  v13 = v9[5];
  v14 = v9[6];
  v15 = v9[8];
  a4[7] = v9[7];
  a4[8] = v15;
  a4[5] = v13;
  a4[6] = v14;
  v16 = *((_QWORD *)v9 + 18);
  v17 = (_QWORD *)*((_QWORD *)v9 + 19);
  if (v16)
  {
    *(_QWORD *)(v16 + 152) = v17;
    v17 = (_QWORD *)*((_QWORD *)v9 + 19);
  }
  else
  {
    *(_QWORD *)(v6 + 8) = v17;
  }
  *v17 = v16;
  free(v9);
  return 0;
}

uint64_t sub_20969DD38(_krb5_context *a1, uint64_t a2, uint64_t **a3)
{
  uint64_t *v3;

  v3 = *a3;
  *a3 = 0;
  sub_20969E868(a1, v3);
  free(v3);
  return 0;
}

uint64_t sub_20969DD6C(_krb5_context *a1, uint64_t a2, int a3, uint64_t a4)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;

  v7 = *(_QWORD *)(a2 + 16);
  pthread_mutex_lock((pthread_mutex_t *)(v7 + 88));
  v8 = *(_QWORD *)(v7 + 24);
  if (v8)
  {
    do
    {
      v9 = *(_QWORD *)(v8 + 144);
      if (krb5_compare_creds(a1, a3, a4, v8))
      {
        krb5_free_cred_contents(a1, (krb5_creds *)v8);
        v10 = *(_QWORD *)(v8 + 144);
        v11 = *(_QWORD **)(v8 + 152);
        if (v10)
        {
          *(_QWORD *)(v10 + 152) = v11;
          v11 = *(_QWORD **)(v8 + 152);
        }
        else
        {
          *(_QWORD *)(v7 + 32) = v11;
        }
        *v11 = v10;
        free((void *)v8);
        *(_QWORD *)(v7 + 56) = time(0);
      }
      v8 = v9;
    }
    while (v9);
  }
  pthread_mutex_unlock((pthread_mutex_t *)(v7 + 88));
  return 0;
}

uint64_t sub_20969DE2C()
{
  return 0;
}

uint64_t sub_20969DE34(_krb5_context *a1, uint64_t *a2)
{
  _QWORD *v4;
  uint64_t v5;
  const char **v6;
  const char **v7;
  _QWORD *v8;
  _QWORD *v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;

  v4 = malloc_type_calloc(1uLL, 0x10uLL, 0xA0040AFF93C70uLL);
  if (v4)
  {
    v5 = (uint64_t)v4;
    *v4 = 0;
    v4[1] = v4;
    pthread_mutex_lock(&stru_2545A4D98);
    v6 = (const char **)off_2545A4D88;
    if (off_2545A4D88)
    {
      do
      {
        while (1)
        {
          v7 = v6;
          v6 = (const char **)v6[5];
          v8 = malloc_type_calloc(1uLL, 0x18uLL, 0xA0040E93CF5C4uLL);
          if (!v8)
          {
            pthread_mutex_unlock(&stru_2545A4D98);
            v12 = 12;
            krb5_set_error_message(a1, 12, "malloc: out of memory");
            sub_20969E8D4((uint64_t)a1, v5);
            return v12;
          }
          v9 = v8;
          v8[1] = 0;
          *v8 = v7;
          v10 = *(_QWORD **)(v5 + 8);
          v8[2] = v10;
          *v10 = v8;
          *(_QWORD *)(v5 + 8) = v8 + 1;
          sub_20969D1E8((uint64_t)a1, 20, "mcc_get_cache_first, adding to cursor cache: %s\n", *v7);
          if (*v9)
            break;
LABEL_7:
          if (!v6)
            goto LABEL_10;
        }
        pthread_mutex_lock((pthread_mutex_t *)(*v9 + 88));
        v11 = *v9;
        if (*(_DWORD *)(*v9 + 12))
        {
          pthread_mutex_unlock((pthread_mutex_t *)(v11 + 88));
          *v9 = 0;
          goto LABEL_7;
        }
        ++*(_DWORD *)(v11 + 8);
        pthread_mutex_unlock((pthread_mutex_t *)(v11 + 88));
      }
      while (v6);
    }
LABEL_10:
    pthread_mutex_unlock(&stru_2545A4D98);
    v12 = 0;
    *a2 = v5;
  }
  else
  {
    v12 = 2529639110;
    krb5_set_error_message(a1, -1765328186, "malloc: out of memory");
  }
  return v12;
}

uint64_t sub_20969DFD4(_krb5_context *a1, uint64_t a2, _QWORD *a3)
{
  uint64_t v3;
  const char ***v7;
  const char **v8;
  const char **v9;
  const char **v10;
  int v11;

  v3 = 2529639054;
  if (!a2)
    return v3;
  v7 = *(const char ****)a2;
  while (!v7)
  {
LABEL_10:
    v7 = *(const char ****)a2;
    if (!*(_QWORD *)a2)
      return v3;
  }
  v8 = v7[1];
  v9 = v7[2];
  if (v8)
  {
    v8[2] = (const char *)v9;
    v9 = v7[2];
  }
  else
  {
    *(_QWORD *)(a2 + 8) = v9;
  }
  *v9 = (const char *)v8;
  v10 = *v7;
  free(v7);
  pthread_mutex_lock((pthread_mutex_t *)(v10 + 11));
  v11 = *((_DWORD *)v10 + 3);
  pthread_mutex_unlock((pthread_mutex_t *)(v10 + 11));
  if (v11)
  {
    sub_20969D1E8((uint64_t)a1, 20, "mcc_get_cache_next, not returning, already dead: %s\n", *v10);
    if (sub_20969E78C((uint64_t)a1, v10))
    {
      sub_20969D1E8((uint64_t)a1, 20, "mcc_get_cache_next, needs to be freed: %s\n", *v10);
      free(v10);
    }
    goto LABEL_10;
  }
  sub_20969D1E8((uint64_t)a1, 20, "mcc_get_cache_next, returning: %s\n", *v10);
  v3 = sub_20967E178(a1, (uint64_t)&krb5_mcc_ops, a3);
  if (!(_DWORD)v3)
  {
    *(_QWORD *)(*a3 + 16) = v10;
    *(_QWORD *)(*a3 + 8) = 152;
  }
  return v3;
}

uint64_t sub_20969E124(uint64_t a1, void *a2)
{
  sub_20969E8D4(a1, (uint64_t)a2);
  free(a2);
  return 0;
}

uint64_t sub_20969E150(_krb5_context *a1, uint64_t a2, uint64_t a3)
{
  const char **v5;
  uint64_t v6;
  const char *v7;
  char *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  const char *v13;
  const char *v14;
  uint64_t v15;
  const char *v16;
  const char **v17;
  const char *v18;
  const char **v19;
  const char *v20;
  time_t v21;

  v5 = *(const char ***)(a2 + 16);
  v6 = *(_QWORD *)(a3 + 16);
  sub_20969D1E8((uint64_t)a1, 20, "mcc_move, from: %s to: %s\n", *v5, *(const char **)v6);
  pthread_mutex_lock(&stru_2545A4D98);
  v7 = v5[5];
  v8 = (char *)v5[6];
  if (v7)
  {
    *((_QWORD *)v7 + 6) = v8;
    v8 = (char *)v5[6];
  }
  else
  {
    qword_2545A4D90 = (uint64_t)v5[6];
  }
  *(_QWORD *)v8 = v7;
  pthread_mutex_lock((pthread_mutex_t *)(v5 + 11));
  pthread_mutex_lock((pthread_mutex_t *)(v6 + 88));
  v9 = *(_QWORD *)(v6 + 24);
  if (v9)
  {
    do
    {
      v10 = *(_QWORD *)(v9 + 144);
      krb5_free_cred_contents(a1, (krb5_creds *)v9);
      v11 = *(_QWORD *)(v9 + 144);
      v12 = *(_QWORD **)(v9 + 152);
      if (v11)
      {
        *(_QWORD *)(v11 + 152) = v12;
        v12 = *(_QWORD **)(v9 + 152);
      }
      else
      {
        *(_QWORD *)(v6 + 32) = v12;
      }
      *v12 = v11;
      free((void *)v9);
      v9 = v10;
    }
    while (v10);
  }
  v13 = v5[3];
  if (v13)
  {
    v14 = v13 + 144;
    v15 = *((_QWORD *)v13 + 18);
    if (v15)
    {
      do
      {
        v16 = (const char *)v15;
        *(_QWORD *)(v15 + 152) = *((_QWORD *)v13 + 19);
        **((_QWORD **)v13 + 19) = v15;
        v17 = *(const char ***)(v6 + 32);
        *((_QWORD *)v13 + 18) = 0;
        *((_QWORD *)v13 + 19) = v17;
        *v17 = v13;
        *(_QWORD *)(v6 + 32) = v14;
        v14 = v16 + 144;
        v15 = *((_QWORD *)v16 + 18);
        v13 = v16;
      }
      while (v15);
    }
    else
    {
      v16 = v5[3];
    }
    v18 = (const char *)*((_QWORD *)v16 + 19);
    v5[4] = v18;
    *(_QWORD *)v18 = 0;
    v19 = *(const char ***)(v6 + 32);
    *((_QWORD *)v16 + 18) = 0;
    *((_QWORD *)v16 + 19) = v19;
    *v19 = v16;
    *(_QWORD *)(v6 + 32) = v14;
  }
  v20 = *(const char **)(v6 + 16);
  *(_QWORD *)(v6 + 16) = v5[2];
  v5[2] = v20;
  v21 = time(0);
  v5[7] = (const char *)v21;
  *(_QWORD *)(v6 + 56) = v21;
  pthread_mutex_unlock((pthread_mutex_t *)(v5 + 11));
  pthread_mutex_unlock((pthread_mutex_t *)(v6 + 88));
  sub_20969E6CC(a1, (uint64_t)v5);
  pthread_mutex_unlock(&stru_2545A4D98);
  if (sub_20969E78C((uint64_t)a1, v5))
  {
    krb5_data_free((_QWORD *)(a2 + 8));
    sub_20969D1E8((uint64_t)a1, 20, "mcc_move, from freed\n");
  }
  else
  {
    sub_20969D1E8((uint64_t)a1, 20, "mcc_move, from not freed\n");
  }
  return 0;
}

uint64_t sub_20969E32C(_krb5_context *a1, char **a2)
{
  char *v4;
  uint64_t v5;

  v4 = strdup("MEMORY:");
  *a2 = v4;
  if (v4)
    return 0;
  v5 = 12;
  krb5_set_error_message(a1, 12, "malloc: out of memory");
  return v5;
}

uint64_t sub_20969E384(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  uint64_t v4;

  v4 = *(_QWORD *)(a2 + 16);
  pthread_mutex_lock((pthread_mutex_t *)(v4 + 88));
  *a3 = *(_QWORD *)(v4 + 56);
  pthread_mutex_unlock((pthread_mutex_t *)(v4 + 88));
  return 0;
}

uint64_t sub_20969E3CC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;

  v4 = *(_QWORD *)(a2 + 16);
  pthread_mutex_lock((pthread_mutex_t *)(v4 + 88));
  *(_QWORD *)(v4 + 64) = a3;
  pthread_mutex_unlock((pthread_mutex_t *)(v4 + 88));
  return 0;
}

uint64_t sub_20969E410(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  uint64_t v4;

  v4 = *(_QWORD *)(a2 + 16);
  pthread_mutex_lock((pthread_mutex_t *)(v4 + 88));
  *a3 = *(_QWORD *)(v4 + 64);
  pthread_mutex_unlock((pthread_mutex_t *)(v4 + 88));
  return 0;
}

uint64_t sub_20969E458(uint64_t a1, uint64_t a2, _OWORD *a3)
{
  *a3 = *(_OWORD *)(*(_QWORD *)(a2 + 16) + 72);
  return 0;
}

uint64_t sub_20969E46C(_krb5_context *a1, uint64_t a2, _QWORD *a3)
{
  char *v6;
  uint64_t result;

  pthread_mutex_lock(&stru_2545A4D98);
  v6 = (char *)off_2545A4D88;
  if (off_2545A4D88)
  {
    while (*((_QWORD *)v6 + 9) != *a3 || *((_QWORD *)v6 + 10) != a3[1])
    {
      v6 = (char *)*((_QWORD *)v6 + 5);
      if (!v6)
        goto LABEL_7;
    }
    pthread_mutex_lock((pthread_mutex_t *)(v6 + 88));
    ++*((_DWORD *)v6 + 2);
    pthread_mutex_unlock((pthread_mutex_t *)(v6 + 88));
    pthread_mutex_unlock(&stru_2545A4D98);
    result = 0;
    *(_QWORD *)(a2 + 8) = 152;
    *(_QWORD *)(a2 + 16) = v6;
  }
  else
  {
LABEL_7:
    pthread_mutex_unlock(&stru_2545A4D98);
    krb5_clear_error_message(a1);
    return 2529639054;
  }
  return result;
}

char **sub_20969E524(const char *a1)
{
  char **v2;
  char **v3;
  char *v4;
  const char **v5;
  char *v6;
  uint64_t *v7;
  BOOL v8;
  uint64_t *v9;

  v2 = (char **)malloc_type_calloc(1uLL, 0x98uLL, 0x10B0040EEA56EF3uLL);
  v3 = v2;
  if (v2)
  {
    if (a1)
    {
      v4 = strdup(a1);
      *v3 = v4;
      if (!v4)
      {
LABEL_14:
        free(v3);
        return 0;
      }
    }
    else
    {
      if (asprintf(v2, "%p", v2) < 0)
        goto LABEL_14;
      v4 = *v3;
      if (!*v3)
        goto LABEL_14;
    }
    v5 = (const char **)off_2545A4D88;
    if (off_2545A4D88)
    {
      while (strcmp(v4, *v5))
      {
        v5 = (const char **)v5[5];
        if (!v5)
          goto LABEL_10;
      }
      free(v4);
      goto LABEL_14;
    }
LABEL_10:
    v3[1] = (char *)1;
    v3[2] = 0;
    v3[3] = 0;
    v3[4] = (char *)(v3 + 3);
    v3[7] = (char *)time(0);
    v3[8] = 0;
    krb5_generate_random_block((uint64_t)(v3 + 9), 16);
    pthread_mutex_init((pthread_mutex_t *)(v3 + 11), 0);
    v6 = (char *)off_2545A4D88;
    v3[5] = (char *)off_2545A4D88;
    v7 = (uint64_t *)(v6 + 48);
    v8 = v6 == 0;
    off_2545A4D88 = v3;
    v9 = &qword_2545A4D90;
    if (!v8)
      v9 = v7;
    *v9 = (uint64_t)(v3 + 5);
    v3[6] = (char *)&off_2545A4D88;
  }
  return v3;
}

void sub_20969E660(krb5_context a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v5;
  uint64_t v6;
  _QWORD *v7;

  v2 = *(_QWORD *)(a2 + 24);
  if (v2)
  {
    do
    {
      v5 = *(_QWORD *)(v2 + 144);
      krb5_free_cred_contents(a1, (krb5_creds *)v2);
      v6 = *(_QWORD *)(v2 + 144);
      v7 = *(_QWORD **)(v2 + 152);
      if (v6)
      {
        *(_QWORD *)(v6 + 152) = v7;
        v7 = *(_QWORD **)(v2 + 152);
      }
      else
      {
        *(_QWORD *)(a2 + 32) = v7;
      }
      *v7 = v6;
      free((void *)v2);
      v2 = v5;
    }
    while (v5);
  }
}

uint64_t sub_20969E6CC(_krb5_context *a1, uint64_t a2)
{
  pthread_mutex_t *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  krb5_principal_data *v14;
  char v16;

  v4 = (pthread_mutex_t *)(a2 + 88);
  pthread_mutex_lock((pthread_mutex_t *)(a2 + 88));
  sub_20969D1E8((uint64_t)a1, 20, "mcc_destroy_internal_locked: %s\n", *(const char **)a2);
  if (!*(_DWORD *)(a2 + 8))
    heim_abort("mcc_destroy: refcnt already 0:m->refcnt != 0", v5, v6, v7, v8, v9, v10, v11, v16);
  if (!*(_DWORD *)(a2 + 12))
  {
    v12 = *(_QWORD *)(a2 + 40);
    v13 = *(_QWORD **)(a2 + 48);
    if (v12)
    {
      *(_QWORD *)(v12 + 48) = v13;
      v13 = *(_QWORD **)(a2 + 48);
    }
    else
    {
      qword_2545A4D90 = *(_QWORD *)(a2 + 48);
    }
    *v13 = v12;
    v14 = *(krb5_principal_data **)(a2 + 16);
    if (v14)
    {
      krb5_free_principal(a1, v14);
      *(_QWORD *)(a2 + 16) = 0;
    }
    *(_DWORD *)(a2 + 12) = 1;
    sub_20969E660(a1, a2);
  }
  return pthread_mutex_unlock(v4);
}

uint64_t sub_20969E78C(uint64_t a1, const char **a2)
{
  int v4;
  uint64_t v5;

  pthread_mutex_lock(&stru_2545A4D98);
  pthread_mutex_lock((pthread_mutex_t *)(a2 + 11));
  sub_20969D1E8(a1, 20, "mcc_close_internal: %s, %d\n", *a2, *((_DWORD *)a2 + 2));
  v4 = *((_DWORD *)a2 + 2) - 1;
  *((_DWORD *)a2 + 2) = v4;
  if (v4 || !*((_DWORD *)a2 + 3))
  {
    pthread_mutex_unlock((pthread_mutex_t *)(a2 + 11));
    v5 = 0;
  }
  else
  {
    sub_20969D1E8(a1, 20, "mcc_close_internal, dead: %s\n", *a2);
    pthread_mutex_unlock((pthread_mutex_t *)(a2 + 11));
    free((void *)*a2);
    *a2 = 0;
    pthread_mutex_destroy((pthread_mutex_t *)(a2 + 11));
    v5 = 1;
  }
  pthread_mutex_unlock(&stru_2545A4D98);
  return v5;
}

void sub_20969E868(krb5_context a1, uint64_t *a2)
{
  uint64_t v2;
  uint64_t v5;
  uint64_t v6;
  _QWORD *v7;

  v2 = *a2;
  if (*a2)
  {
    do
    {
      v5 = *(_QWORD *)(v2 + 144);
      krb5_free_cred_contents(a1, (krb5_creds *)v2);
      v6 = *(_QWORD *)(v2 + 144);
      v7 = *(_QWORD **)(v2 + 152);
      if (v6)
      {
        *(_QWORD *)(v6 + 152) = v7;
        v7 = *(_QWORD **)(v2 + 152);
      }
      else
      {
        a2[1] = (uint64_t)v7;
      }
      *v7 = v6;
      free((void *)v2);
      v2 = v5;
    }
    while (v5);
  }
}

void sub_20969E8D4(uint64_t a1, uint64_t a2)
{
  const char ***i;
  const char **v5;
  const char **v6;
  const char **v7;

  for (i = *(const char ****)a2; *(_QWORD *)a2; i = *(const char ****)a2)
  {
    sub_20969D1E8(a1, 20, "mcc_free_cache_cursor, closing cache: %s\n", **i);
    if (sub_20969E78C(a1, *i))
    {
      v5 = *i;
      sub_20969D1E8(a1, 20, "mcc_free_cache_cursor, needs to be freed: %s\n", **i);
      free(v5);
    }
    v6 = i[1];
    v7 = i[2];
    if (v6)
    {
      v6[2] = (const char *)v7;
      v7 = i[2];
    }
    else
    {
      *(_QWORD *)(a2 + 8) = v7;
    }
    *v7 = (const char *)v6;
    free(i);
  }
}

uint64_t _krb5_s4u2self_to_checksumdata(_krb5_context *a1, uint64_t a2, size_t *a3)
{
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  size_t v10;
  size_t v11;
  size_t v12;
  uint64_t v13;

  v6 = krb5_storage_emem();
  if (v6)
  {
    v7 = (uint64_t)v6;
    krb5_storage_set_flags((uint64_t)v6, 32);
    v8 = krb5_store_int32(v7, *(_DWORD *)a2);
    if (!(_DWORD)v8)
    {
      if (*(_DWORD *)(a2 + 8))
      {
        v9 = 0;
        while (1)
        {
          v10 = strlen(*(const char **)(*(_QWORD *)(a2 + 16) + 8 * v9));
          if (krb5_storage_write(v7) != v10)
            break;
          if (++v9 >= (unint64_t)*(unsigned int *)(a2 + 8))
            goto LABEL_7;
        }
      }
      else
      {
LABEL_7:
        v11 = strlen(*(const char **)(a2 + 24));
        if (krb5_storage_write(v7) == v11)
        {
          v12 = strlen(*(const char **)(a2 + 56));
          if (krb5_storage_write(v7) == v12)
          {
            v13 = krb5_storage_to_data(v7, a3);
            krb5_storage_free(v7);
            return v13;
          }
        }
      }
      v8 = 12;
    }
    krb5_clear_error_message(a1);
  }
  else
  {
    krb5_clear_error_message(a1);
    return 12;
  }
  return v8;
}

uint64_t krb5_enomem(_krb5_context *a1)
{
  krb5_set_error_message(a1, 12, "malloc: out of memory");
  return 12;
}

uint64_t sub_20969EB00()
{
  return 22;
}

_BYTE *krb5_uuid_to_string(uint64_t a1)
{
  _BYTE *result;
  uint64_t v3;
  _BYTE *v4;

  result = malloc_type_malloc(0x25uLL, 0x9A742ABuLL);
  if (result)
  {
    v3 = 0;
    v4 = result;
    do
    {
      if ((v3 & 0x7FFFFFFFFFFFFFFDLL) == 8 || (v3 & 0x7FFFFFFFFFFFFFFDLL) == 4)
        *v4++ = 45;
      *v4 = byte_2096D9428[(unint64_t)*(unsigned __int8 *)(a1 + v3) >> 4];
      v4[1] = byte_2096D9428[*(_BYTE *)(a1 + v3) & 0xF];
      v4 += 2;
      ++v3;
    }
    while (v3 != 16);
    *v4 = 0;
  }
  return result;
}

uint64_t krb5_string_to_uuid(const char *a1, uint64_t a2)
{
  unsigned __int8 *v3;
  uint64_t v4;
  int v6;
  char v7;

  v3 = (unsigned __int8 *)a1;
  if (strlen(a1) == 36)
  {
    v4 = 0;
    while (1)
    {
      if ((v4 & 0x7FFFFFFFFFFFFFFDLL) == 8 || (v4 & 0x7FFFFFFFFFFFFFFDLL) == 4)
      {
        v6 = *v3++;
        if (v6 != 45)
          break;
      }
      v7 = sub_20969EC38(*v3);
      *(_BYTE *)(a2 + v4) = sub_20969EC38(v3[1]) | (16 * v7);
      v3 += 2;
      if (++v4 == 16)
        return 0;
    }
  }
  return 22;
}

uint64_t sub_20969EC38(unsigned __int8 a1)
{
  char v1;
  uint64_t result;
  int v3;

  v1 = __toupper(a1);
  result = 0;
  LOBYTE(v3) = 48;
  while (v1 != (char)v3)
  {
    v3 = byte_2096D9428[++result];
    if (!v3)
      return 0xFFFFFFFFLL;
  }
  return result;
}

krb5_error_code krb5_mk_error(krb5_context a1, const krb5_error *a2, krb5_data *a3)
{
  uint64_t v3;
  uint64_t v4;
  __int128 *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  __int128 *v10;
  uint64_t v11;
  uint64_t v12;
  krb5_data *error_message;
  krb5_error_code v14;
  const char *v16;
  int v17;
  char *v18;
  size_t v19;
  void *v20;
  krb5_error_code v21;
  krb5_int32 v23;
  krb5_timestamp v24[2];
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  uint64_t v33;
  krb5_data *v34;
  uint64_t v35;

  v8 = v7;
  v9 = v6;
  v10 = v5;
  v11 = v4;
  v12 = v3;
  error_message = a3;
  v14 = (int)a2;
  v34 = a3;
  *(_QWORD *)v24 = 0;
  v23 = 0;
  krb5_us_timeofday(a1, v24, &v23);
  v29 = 0u;
  v30 = 0u;
  v31 = 0u;
  v32 = 0u;
  v33 = 0;
  v25 = 0x1E00000005;
  v27 = v8;
  v28 = *(_QWORD *)v24;
  LODWORD(v29) = v23;
  v26 = v9;
  if ((v14 + 1765328256) > 0xFFFFFF7F)
  {
    v16 = 0;
    v17 = v14 + 1765328384;
    goto LABEL_6;
  }
  if (!error_message)
  {
    error_message = (krb5_data *)krb5_get_error_message(a1, v14);
    v34 = error_message;
    v17 = 60;
    v16 = (const char *)error_message;
LABEL_6:
    DWORD1(v29) = v17;
    if (!error_message)
      goto LABEL_8;
    goto LABEL_7;
  }
  v16 = 0;
  DWORD1(v29) = 60;
LABEL_7:
  *((_QWORD *)&v32 + 1) = &v34;
LABEL_8:
  if (v12)
    v33 = v12;
  if (v10)
  {
    v31 = *v10;
    v18 = (char *)*((_QWORD *)v10 + 3);
    *(_QWORD *)&v32 = *((_QWORD *)v10 + 2);
  }
  else
  {
    v18 = aUnspecifiedRea;
  }
  *((_QWORD *)&v30 + 1) = v18;
  if (v11)
  {
    *((_QWORD *)&v29 + 1) = v11 + 24;
    *(_QWORD *)&v30 = v11;
  }
  v19 = sub_2096BC0C0();
  *(_QWORD *)v35 = v19;
  v20 = malloc_type_malloc(v19, 0xD9582E5EuLL);
  *(_QWORD *)(v35 + 8) = v20;
  if (!v20)
  {
    v21 = 12;
    if (!v16)
      goto LABEL_20;
    goto LABEL_19;
  }
  v21 = sub_2096BC0A0();
  if (v21)
  {
    free(*(void **)(v35 + 8));
    *(_QWORD *)(v35 + 8) = 0;
  }
  if (v16)
LABEL_19:
    krb5_free_error_message(a1, v16);
LABEL_20:
  if (!v21 && *(_QWORD *)v35)
    krb5_abortx(a1, "internal error in ASN.1 encoder");
  return v21;
}

krb5_error_code krb5_mk_priv(krb5_context a1, krb5_auth_context a2, const krb5_data *a3, krb5_data *a4, krb5_replay_data *a5)
{
  krb5_error_code v9;
  const krb5_keyblock *v10;
  int v11;
  uint64_t *v12;
  uint64_t *v13;
  char *v14;
  size_t v15;
  char *v16;
  void *v17;
  char *v18;
  krb5_error_code v19;
  krb5_error_code v20;
  size_t v21;
  char *v22;
  char *v23;
  uint64_t v25;
  uint64_t v26;
  krb5_keyblock **v27;
  size_t size;
  krb5_data v29;
  uint64_t *v30;
  uint64_t *v31;
  char *v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  uint64_t v36;

  size = 0;
  if (!a5 && (*(_DWORD *)a2 & 0xA) != 0)
    return -1765328169;
  v10 = (const krb5_keyblock *)*((_QWORD *)a2 + 5);
  if (!v10)
  {
    v10 = (const krb5_keyblock *)*((_QWORD *)a2 + 6);
    if (!v10)
      v10 = (const krb5_keyblock *)*((_QWORD *)a2 + 4);
  }
  v36 = 0;
  v34 = 0u;
  v35 = 0u;
  v33 = 0uLL;
  v26 = 0;
  v27 = 0;
  v25 = 0;
  v29 = *a3;
  krb5_us_timeofday(a1, (krb5_timestamp *)&v25, (krb5_int32 *)&v26);
  v11 = *(_DWORD *)a2;
  if ((*(_DWORD *)a2 & 1) != 0)
    v12 = &v25;
  else
    v12 = 0;
  if ((v11 & 1) != 0)
    v13 = &v26;
  else
    v13 = 0;
  v30 = v12;
  v31 = v13;
  if ((v11 & 2) != 0)
  {
    *(_QWORD *)&a5->timestamp = v25;
    a5->seq = v26;
  }
  if ((v11 & 4) != 0)
  {
    v14 = (char *)&v26 + 4;
    HIDWORD(v26) = *((_DWORD *)a2 + 14);
  }
  else
  {
    v14 = 0;
  }
  v32 = v14;
  if ((v11 & 8) != 0)
    a5[1].timestamp = *((_DWORD *)a2 + 14);
  v33 = *(_OWORD *)((char *)a2 + 8);
  krb5_data_zero((_QWORD *)&v35 + 1);
  v15 = sub_2096BBFA0();
  v16 = (char *)malloc_type_malloc(v15, 0xA8A53C70uLL);
  if (!v16)
    goto LABEL_33;
  v17 = v16;
  v18 = &v16[v15];
  v19 = sub_2096BBF80();
  if (v19)
  {
LABEL_22:
    v9 = v19;
    free(v17);
LABEL_34:
    krb5_data_free((_QWORD *)&v35 + 1);
    return v9;
  }
  if (v15 != size)
LABEL_38:
    krb5_abortx(a1, "internal error in ASN.1 encoder");
  *(_QWORD *)&v34 = 0x1500000005;
  DWORD2(v34) = v10->magic;
  *(_QWORD *)&v35 = 0;
  v20 = krb5_crypto_init(a1, v10, 0, &v27);
  if (v20)
  {
    v9 = v20;
LABEL_26:
    free(v17);
    return v9;
  }
  v9 = krb5_encrypt(a1, v27, (krb5_pointer)0xD, (size_t)&v18[-size], (krb5_encrypt_block *)size, (char *)&v35 + 8);
  krb5_crypto_destroy(a1, (uint64_t)v27);
  free(v17);
  if (v9)
    return v9;
  v21 = sub_2096BBF40();
  v22 = (char *)malloc_type_malloc(v21, 0xBFD430uLL);
  if (!v22)
  {
LABEL_33:
    v9 = 12;
    goto LABEL_34;
  }
  v17 = v22;
  v23 = &v22[v21];
  v19 = sub_2096BBF20();
  if (v19)
    goto LABEL_22;
  if (v21 != size)
    goto LABEL_38;
  krb5_data_free((_QWORD *)&v35 + 1);
  if (krb5_data_copy(a4, &v23[-size], size))
  {
    v9 = 12;
    krb5_set_error_message(a1, 12, "malloc: out of memory");
    goto LABEL_26;
  }
  free(v17);
  v9 = 0;
  if ((*(_BYTE *)a2 & 4) != 0)
    ++*((_DWORD *)a2 + 14);
  return v9;
}

krb5_error_code krb5_mk_rep(krb5_context a1, krb5_auth_context a2, krb5_data *a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v11;
  int v12;
  const krb5_keyblock *v13;
  _DWORD *v14;
  krb5_error_code v15;
  krb5_encrypt_block *v16;
  void *v17;
  void *v18;
  char *v19;
  krb5_error_code v20;
  size_t v22;
  char *v23;
  krb5_error_code v24;
  uint64_t v25;
  __int128 v26;
  __int128 v27;
  uint64_t v28;
  krb5_encrypt_block *eblock;
  uint64_t v30;
  uint64_t v31;
  krb5_keyblock *v32;
  _DWORD *v33;
  krb5_keyblock **v34;

  v34 = 0;
  v28 = 0;
  eblock = 0;
  v27 = 0u;
  v26 = 0u;
  v32 = 0;
  v33 = 0;
  v25 = 0xF00000005;
  v11 = *((_QWORD *)a2 + 8);
  v30 = *(_QWORD *)(v11 + 56);
  v31 = 0;
  LODWORD(v31) = *(_DWORD *)(v11 + 48);
  v12 = *(_DWORD *)a2;
  if ((*(_DWORD *)a2 & 0x20) != 0)
  {
    v13 = (const krb5_keyblock *)*((_QWORD *)a2 + 5);
    if (!v13)
    {
      v15 = krb5_auth_con_generatelocalsubkey(a1, (uint64_t)a2, *((unsigned int **)a2 + 4));
      if (v15)
        goto LABEL_25;
      v13 = (const krb5_keyblock *)*((_QWORD *)a2 + 5);
    }
    if (krb5_copy_keyblock(a1, v13, &v32))
      goto LABEL_16;
    v12 = *(_DWORD *)a2;
  }
  if ((v12 & 4) != 0)
  {
    if (!*((_DWORD *)a2 + 14))
      krb5_generate_seq_number(a1, *((_QWORD *)a2 + 4), (int *)a2 + 14);
    v14 = malloc_type_calloc(1uLL, 4uLL, 0x100004052888210uLL);
    v33 = v14;
    if (v14)
    {
      *v14 = *((_DWORD *)a2 + 14);
      goto LABEL_11;
    }
LABEL_16:
    v15 = krb5_enomem(a1);
    goto LABEL_25;
  }
  v33 = 0;
LABEL_11:
  LODWORD(v26) = **((_DWORD **)a2 + 4);
  *((_QWORD *)&v26 + 1) = 0;
  if (*((_QWORD *)a2 + 13))
  {
    v15 = sub_2096AF214(a1, (uint64_t)a2, (uint64_t)&v25, v3, v4, v5, v6, v7);
    if (v15)
      goto LABEL_25;
  }
  v16 = (krb5_encrypt_block *)sub_2096BBE80();
  v17 = malloc_type_malloc((size_t)v16, 0x15D00830uLL);
  if (!v17)
  {
    v15 = 12;
    goto LABEL_25;
  }
  v18 = v17;
  v19 = (char *)v16 + (_QWORD)v17;
  v20 = sub_2096BBE60();
  if (v20)
  {
    v15 = v20;
    free(v18);
    goto LABEL_25;
  }
  if (v16 != eblock)
    goto LABEL_32;
  v15 = krb5_crypto_init(a1, *((const krb5_keyblock **)a2 + 4), 0, &v34);
  if (!v15)
  {
    v15 = krb5_encrypt(a1, v34, (krb5_pointer)0xC, v19 - (char *)eblock, eblock, &v27);
    if (!v15)
    {
      v22 = sub_2096BBE20();
      *(_QWORD *)&a3->magic = v22;
      v23 = (char *)malloc_type_malloc(v22, 0x7E47B92EuLL);
      a3->data = v23;
      if (!v23)
      {
        v15 = 12;
        goto LABEL_23;
      }
      v24 = sub_2096BBE00();
      if (v24)
      {
        v15 = v24;
        free(a3->data);
        a3->data = 0;
        goto LABEL_23;
      }
      if (*(krb5_encrypt_block **)&a3->magic == eblock)
      {
        v15 = 0;
        goto LABEL_23;
      }
LABEL_32:
      krb5_abortx(a1, "internal error in ASN.1 encoder", v25, v26, v27, v28);
    }
  }
LABEL_23:
  free(v18);
  if (v34)
    krb5_crypto_destroy(a1, (uint64_t)v34);
LABEL_25:
  sub_2096BBE90();
  sub_2096BBE30();
  return v15;
}

uint64_t sub_20969F3D4(krb5_context a1, krb5_auth_context *a2, uint64_t a3, uint64_t *a4, int a5, uint64_t a6, uint64_t a7, unsigned int a8, unsigned int a9)
{
  _krb5_auth_context *v16;
  uint64_t checksum;
  krb5_auth_context v18;
  const krb5_keyblock *v20;
  krb5_magic magic;
  uint64_t v22;
  uint64_t v23;
  _krb5_context *v24;
  int v25;
  _QWORD *v26;
  uint64_t v27;
  krb5_keyblock **v28;
  krb5_auth_context v29;
  _QWORD v30[3];
  uint64_t v31;
  uint64_t v32;

  v31 = 0;
  v32 = 0;
  memset(v30, 0, sizeof(v30));
  v29 = 0;
  if (!a2)
  {
    checksum = krb5_auth_con_init(a1, &v29);
    if ((_DWORD)checksum)
      return checksum;
LABEL_8:
    v18 = v29;
    if ((a3 & 4) != 0 && !*((_QWORD *)v29 + 5))
    {
      checksum = krb5_auth_con_generatelocalsubkey(a1, (uint64_t)v29, (unsigned int *)(a6 + 16));
      if ((_DWORD)checksum)
        goto LABEL_13;
      v18 = v29;
    }
    krb5_free_keyblock(a1, *((krb5_keyblock **)v18 + 4));
    checksum = krb5_copy_keyblock(a1, (const krb5_keyblock *)(a6 + 16), (krb5_keyblock **)v29 + 4);
    if ((_DWORD)checksum)
    {
LABEL_13:
      if (!a2)
        krb5_auth_con_free(a1, v29);
      return checksum;
    }
    if (a2)
    {
      if ((a3 & 8) != 0)
      {
        checksum = _krb5_auth_con_setup_pfs(a1, (uint64_t)v29, **((_DWORD **)v29 + 4));
        if ((_DWORD)checksum)
          return checksum;
      }
    }
    if (!a4)
    {
      v26 = 0;
      goto LABEL_26;
    }
    v20 = (const krb5_keyblock *)*((_QWORD *)v29 + 4);
    magic = v20->magic;
    if (v20->magic <= 0x18u)
    {
      if (((1 << magic) & 0x180000C) != 0)
      {
        v23 = *a4;
        v22 = a4[1];
        v24 = a1;
        v25 = 7;
        goto LABEL_23;
      }
      if (magic == 1)
      {
        v23 = *a4;
        v22 = a4[1];
        v24 = a1;
        v25 = 2;
LABEL_23:
        checksum = krb5_create_checksum(v24, 0, 0, v25, v22, v23, (uint64_t)v30);
        if ((_DWORD)checksum)
          goto LABEL_13;
LABEL_24:
        v26 = v30;
LABEL_26:
        checksum = _krb5_build_authenticator(a1, (uint64_t)v29, (char *)**((unsigned int **)v29 + 4), a6, (uint64_t)v26, &v31, (void *)a9);
        if (v26)
          sub_2096BB8BC();
        if ((_DWORD)checksum)
          goto LABEL_13;
        v27 = krb5_build_ap_req(a1, **((unsigned int **)v29 + 4), a6, a3, v31, v32, a7);
        goto LABEL_33;
      }
    }
    v28 = 0;
    v27 = krb5_crypto_init(a1, v20, 0, &v28);
    if ((_DWORD)v27)
    {
LABEL_33:
      checksum = v27;
      goto LABEL_13;
    }
    checksum = krb5_create_checksum(a1, (_DWORD **)v28, a8, 0, a4[1], *a4, (uint64_t)v30);
    krb5_crypto_destroy(a1, (uint64_t)v28);
    if ((_DWORD)checksum)
      goto LABEL_13;
    goto LABEL_24;
  }
  v16 = *a2;
  if (*a2)
  {
    checksum = 0;
  }
  else
  {
    checksum = krb5_auth_con_init(a1, a2);
    v16 = *a2;
  }
  v29 = v16;
  if (!(_DWORD)checksum)
    goto LABEL_8;
  return checksum;
}

krb5_error_code krb5_mk_req_extended(krb5_context a1, krb5_auth_context *a2, krb5_flags a3, krb5_data *a4, krb5_creds *a5, krb5_data *a6)
{
  return sub_20969F3D4(a1, a2, *(uint64_t *)&a3, (uint64_t *)&a4->magic, (int)a5, (uint64_t)a5, (uint64_t)a6, 0xAu, 0xBu);
}

uint64_t krb5_mk_req_exact(_krb5_context *a1, krb5_auth_context *a2, krb5_flags a3, const krb5_principal_data *a4, krb5_data *a5, krb5_ccache cache, krb5_data *a7)
{
  uint64_t credentials;
  uint64_t v15;
  krb5_creds *v17;
  krb5_principal principal[2];
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;

  v17 = 0;
  *(_OWORD *)principal = 0u;
  v19 = 0u;
  v20 = 0u;
  v21 = 0u;
  v22 = 0u;
  v23 = 0u;
  v24 = 0u;
  v25 = 0u;
  v26 = 0u;
  credentials = krb5_cc_get_principal(a1, cache, principal);
  if (!(_DWORD)credentials)
  {
    v15 = krb5_copy_principal(a1, a4, &principal[1]);
    if ((_DWORD)v15)
    {
      credentials = v15;
      krb5_free_cred_contents(a1, (krb5_creds *)principal);
    }
    else
    {
      *((_QWORD *)&v21 + 1) = 0;
      if (a2 && *a2 && *((_DWORD *)*a2 + 22))
        LODWORD(v19) = *((_DWORD *)*a2 + 22);
      credentials = krb5_get_credentials(a1, 0, cache, (krb5_creds *)principal, &v17);
      krb5_free_cred_contents(a1, (krb5_creds *)principal);
      if (!(_DWORD)credentials)
      {
        credentials = krb5_mk_req_extended(a1, a2, a3, a5, v17, a7);
        krb5_free_creds(a1, v17);
      }
    }
  }
  return credentials;
}

krb5_error_code krb5_mk_req(krb5_context a1, krb5_auth_context *a2, krb5_flags a3, char *a4, char *a5, krb5_data *a6, krb5_ccache a7, krb5_data *a8)
{
  krb5_error_code principal;
  krb5_principal v17;
  void *v18;
  char **v19;

  v18 = 0;
  v19 = 0;
  v17 = 0;
  principal = krb5_expand_hostname_realms(a1, a5, (unsigned __int8 **)&v18, &v19);
  if (!principal)
  {
    principal = krb5_make_principal(a1, &v17, *v19, a4, v18, 0);
    free(v18);
    krb5_free_host_realm(a1, v19);
    if (!principal)
    {
      principal = krb5_mk_req_exact(a1, a2, a3, v17, a6, a7, a8);
      krb5_free_principal(a1, v17);
    }
  }
  return principal;
}

krb5_error_code krb5_mk_safe(krb5_context a1, krb5_auth_context a2, const krb5_data *a3, krb5_data *a4, krb5_replay_data *a5)
{
  krb5_error_code checksum;
  const krb5_keyblock *v10;
  int v11;
  krb5_timestamp *v12;
  uint64_t *v13;
  char *v14;
  size_t v15;
  void *v16;
  void *v17;
  krb5_error_code v18;
  size_t v20;
  void *v21;
  void *v22;
  krb5_error_code v23;
  krb5_timestamp v24[2];
  uint64_t v25;
  krb5_keyblock **v26;
  uint64_t v27;
  uint64_t v28;
  krb5_data v29;
  krb5_timestamp *v30;
  uint64_t *v31;
  char *v32;
  __int128 v33;
  __int128 v34;
  uint64_t v35;

  v27 = 0;
  if (!a5 && (*(_DWORD *)a2 & 0xA) != 0)
    return -1765328169;
  v10 = (const krb5_keyblock *)*((_QWORD *)a2 + 5);
  if (!v10)
  {
    v10 = (const krb5_keyblock *)*((_QWORD *)a2 + 6);
    if (!v10)
      v10 = (const krb5_keyblock *)*((_QWORD *)a2 + 4);
  }
  v35 = 0;
  v33 = 0u;
  v34 = 0u;
  v25 = 0;
  v26 = 0;
  v28 = 0x1400000005;
  *(_QWORD *)v24 = 0;
  v29 = *a3;
  krb5_us_timeofday(a1, v24, (krb5_int32 *)&v25);
  v11 = *(_DWORD *)a2;
  if ((*(_DWORD *)a2 & 1) != 0)
    v12 = v24;
  else
    v12 = 0;
  if ((v11 & 1) != 0)
    v13 = &v25;
  else
    v13 = 0;
  v30 = v12;
  v31 = v13;
  if ((v11 & 2) != 0)
  {
    *(_QWORD *)&a5->timestamp = *(_QWORD *)v24;
    a5->seq = v25;
  }
  if ((v11 & 4) != 0)
  {
    v14 = (char *)&v25 + 4;
    HIDWORD(v25) = *((_DWORD *)a2 + 14);
  }
  else
  {
    v14 = 0;
  }
  v32 = v14;
  if ((v11 & 8) != 0)
    a5[1].timestamp = *((_DWORD *)a2 + 14);
  v33 = *(_OWORD *)((char *)a2 + 8);
  LODWORD(v34) = 0;
  *((_QWORD *)&v34 + 1) = 0;
  v35 = 0;
  v15 = sub_2096BBEE0();
  v16 = malloc_type_malloc(v15, 0xA7DDBABCuLL);
  if (!v16)
    return 12;
  v17 = v16;
  v18 = sub_2096BBEC0();
  if (v18)
  {
LABEL_24:
    checksum = v18;
    free(v17);
    return checksum;
  }
  if (v15 != v27)
    goto LABEL_36;
  v18 = krb5_crypto_init(a1, v10, 0, &v26);
  if (v18)
    goto LABEL_24;
  checksum = krb5_create_checksum(a1, (_DWORD **)v26, 0xFu, 0, (uint64_t)v17, v27, (uint64_t)&v34);
  krb5_crypto_destroy(a1, (uint64_t)v26);
  free(v17);
  if (checksum)
    return checksum;
  v20 = sub_2096BBEE0();
  v21 = malloc_type_malloc(v20, 0x1FF53DFEuLL);
  if (!v21)
  {
    checksum = 12;
    goto LABEL_32;
  }
  v22 = v21;
  v23 = sub_2096BBEC0();
  if (v23)
  {
    checksum = v23;
    free(v22);
LABEL_32:
    sub_2096BB8BC();
    return checksum;
  }
  sub_2096BB8BC();
  if (v20 != v27)
LABEL_36:
    krb5_abortx(a1, "internal error in ASN.1 encoder");
  *(_QWORD *)&a4->magic = v20;
  a4->data = (char *)v22;
  checksum = 0;
  if ((*(_BYTE *)a2 & 4) != 0)
    ++*((_DWORD *)a2 + 14);
  return checksum;
}

uint64_t sub_20969FB10(const void *a1, size_t a2, char *a3, size_t a4)
{
  size_t v6;
  size_t v8;
  size_t v9;
  char *v10;
  void *v11;
  void *v12;
  BOOL v13;
  uint64_t v14;
  size_t v15;
  unint64_t v16;
  size_t v17;
  uint64_t v18;
  char *v19;
  char *v20;
  _BYTE *v21;
  _BYTE *v22;
  uint64_t v23;
  unint64_t v24;
  unint64_t v25;
  unint64_t v26;
  char v27;
  unint64_t v28;
  int v29;
  _BOOL4 v30;
  size_t v31;
  unsigned int v32;
  size_t v33;
  unsigned int v34;
  BOOL v35;
  void *v36;
  size_t v38;
  char *v39;
  size_t v40;
  char *v41;
  void *__src;

  v6 = a2;
  if (a4 <= a2)
    v8 = a2;
  else
    v8 = a4;
  v9 = 2 * v8;
  v10 = (char *)malloc_type_malloc(2 * v8, 0xA840375AuLL);
  v11 = malloc_type_malloc(v6, 0xEEE7A0D5uLL);
  v12 = v11;
  if (v10)
    v13 = v11 == 0;
  else
    v13 = 1;
  if (!v13)
  {
    v38 = v9;
    __src = v11;
    memcpy(v11, a1, v6);
    bzero(a3, a4);
    v12 = __src;
    v15 = 0;
    v16 = 8 * v6;
    v17 = v6 & 0x1FFFFFFFFFFFFFFFLL;
    if ((v6 & 0x1FFFFFFFFFFFFFFELL) != 0)
      v18 = v6 & 0x1FFFFFFFFFFFFFFFLL;
    else
      v18 = 1;
    v40 = v6;
    v41 = &v10[a4];
    v19 = v10 - 1;
    v20 = a3 - 1;
    v39 = v10;
    while (1)
    {
      memcpy(&v10[v15], v12, v6);
      if (v16)
      {
        v21 = malloc_type_malloc(v17, 0x584A9DA5uLL);
        if (!v21)
        {
          v14 = 12;
          v9 = v38;
          v6 = v40;
          v12 = __src;
          if (__src)
            goto LABEL_38;
          goto LABEL_39;
        }
        v22 = v21;
        memcpy(v21, __src, v17);
        v23 = 0;
        do
        {
          v24 = 8 * v23 - 0xD % v16;
          do
          {
            v25 = v24;
            v24 += v16;
          }
          while ((v25 & 0x8000000000000000) != 0);
          v26 = v25 >> 3;
          v27 = v25 & 7;
          v28 = v25 + 8;
          v29 = -(int)v25 & 7;
          if (v28 <= v16)
            LOBYTE(v29) = 8 - v27;
          *((_BYTE *)__src + v23++) = (v22[(v26 + 1) % v17] >> v29) | (v22[v26] << v27);
        }
        while (v23 != v18);
        free(v22);
        v10 = v39;
        v6 = v40;
      }
      v15 += v6;
      if (v15 >= a4)
      {
        v12 = __src;
        while (1)
        {
          if (((a4 - 1) & 0x8000000000000000) == 0)
          {
            v30 = 0;
            v31 = a4;
            do
            {
              v32 = v30 + v20[v31] + v19[v31];
              v30 = v32 > 0xFF;
              v20[v31--] = v32;
            }
            while (v31);
            v33 = a4 - 1;
            if (v32 >= 0x100)
            {
              do
              {
                v34 = a3[v33]++ + 1;
                v35 = v33-- != 0;
              }
              while (v35 && ((v34 >> 8) & 1) != 0);
            }
          }
          v15 -= a4;
          if (!v15)
            break;
          memmove(v10, v41, v15);
          v12 = __src;
          if (v15 < a4)
            goto LABEL_36;
        }
LABEL_37:
        v14 = 0;
        v9 = v38;
        if (!v12)
          goto LABEL_39;
        goto LABEL_38;
      }
      v12 = __src;
LABEL_36:
      if (!v15)
        goto LABEL_37;
    }
  }
  v14 = 12;
  if (v11)
  {
LABEL_38:
    v36 = v12;
    bzero(v12, v6);
    free(v36);
  }
LABEL_39:
  if (v10)
  {
    bzero(v10, v9);
    free(v10);
  }
  return v14;
}

ssize_t krb5_net_read(int a1, int *a2, char *a3, size_t a4)
{
  return sub_2096B82F4(*a2, a3, a4);
}

size_t krb5_net_write(int a1, int *a2, char *__buf, size_t __nbyte)
{
  return sub_2096B8374(*a2, __buf, __nbyte);
}

uint64_t krb5_net_write_block(uint64_t a1, int *a2, char *a3, size_t a4, uint64_t a5)
{
  size_t v6;
  int v8;
  int v9;
  unint64_t v10;
  size_t v11;
  timeval *v12;
  int v13;
  ssize_t v14;
  ssize_t v15;
  fd_set v17;
  uint64_t v18;
  uint64_t v19;

  v6 = a4;
  v8 = *a2;
  v18 = 0;
  v19 = 0;
  v9 = 1 << v8;
  v10 = (unint64_t)v8 >> 5;
  v11 = a4;
  while (1)
  {
    memset(&v17, 0, sizeof(v17));
    if (__darwin_check_fd_set_overflow(v8, &v17, 0))
      v17.fds_bits[v10] |= v9;
    if (a5)
    {
      v18 = a5;
      LODWORD(v19) = 0;
      v12 = (timeval *)&v18;
    }
    else
    {
      v12 = 0;
    }
    v13 = select(v8 + 1, 0, &v17, 0, v12);
    if ((v13 & 0x80000000) == 0)
      break;
    if (*__error() != 4)
      return -1;
LABEL_16:
    if (!v11)
      return v6;
  }
  if (!v13)
    return 0;
  if (!__darwin_check_fd_set_overflow(v8, &v17, 0) || (v17.fds_bits[v10] & v9) == 0)
  {
    *__error() = 60;
    return -1;
  }
  v14 = write(v8, a3, v11);
  v15 = v14;
  if ((v14 & 0x8000000000000000) == 0)
  {
    a3 += v14;
    v11 -= v14;
    goto LABEL_16;
  }
  if (*__error() == 4)
    goto LABEL_16;
  return v15;
}

uint64_t krb5_pac_parse(_krb5_context *a1, const void *a2, size_t a3, _QWORD *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _QWORD *v12;
  _QWORD *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  void *v17;
  const char *v19;
  size_t v20;
  unsigned int *v21;
  int v22;
  unint64_t v23;
  uint64_t v24;
  unsigned int *v25;
  size_t v26;
  unsigned int *v27;
  int v28;
  int v29;
  const char *v30;
  const char *v31;
  size_t v32;
  uint64_t v33;

  v12 = (_QWORD *)heim_uniq_alloc(0x68uLL, (uint64_t)"krb5-pac", (uint64_t)sub_2096A02D4, (uint64_t)a4, a5, a6, a7, a8);
  if (!v12)
  {
    v16 = krb5_enomem(a1);
    goto LABEL_12;
  }
  v33 = 0;
  v13 = krb5_storage_from_readonly_mem((uint64_t)a2, a3);
  if (!v13)
  {
    v16 = krb5_enomem(a1);
    goto LABEL_9;
  }
  v14 = (uint64_t)v13;
  krb5_storage_set_flags((uint64_t)v13, 32);
  v15 = krb5_ret_uint32(v14, (_DWORD *)&v33 + 1);
  if ((_DWORD)v15 || (v15 = krb5_ret_uint32(v14, &v33), (_DWORD)v15))
  {
LABEL_5:
    v16 = v15;
    krb5_clear_error_message(a1);
    goto LABEL_6;
  }
  if (!HIDWORD(v33))
  {
    v19 = "PAC have too few buffers";
    goto LABEL_19;
  }
  if (HIDWORD(v33) >= 0x3E9)
  {
    v16 = 2314790741;
    krb5_set_error_message(a1, -1980176555, "PAC have too many buffers");
    goto LABEL_6;
  }
  if ((_DWORD)v33)
  {
    v31 = (const char *)v33;
    v19 = "PAC have wrong version %d";
    goto LABEL_19;
  }
  v20 = (16 * HIDWORD(v33)) | 8;
  v21 = (unsigned int *)malloc_type_calloc(1uLL, v20, 0x18F7D02DuLL);
  v12[4] = v21;
  if (!v21)
  {
    v16 = krb5_enomem(a1);
    goto LABEL_6;
  }
  v22 = HIDWORD(v33);
  *v21 = HIDWORD(v33);
  v21[1] = v33;
  if (v20 > a3)
  {
    v16 = 22;
    goto LABEL_6;
  }
  if (!v22)
  {
LABEL_47:
    v16 = krb5_data_copy(v12 + 5, a2, a3);
    if ((_DWORD)v16)
      goto LABEL_6;
    krb5_storage_free(v14);
    goto LABEL_12;
  }
  v23 = 0;
  v24 = 3;
  while (2)
  {
    v15 = krb5_ret_uint32(v14, &v21[v24 - 1]);
    if ((_DWORD)v15)
      goto LABEL_5;
    v15 = krb5_ret_uint32(v14, (_DWORD *)(v12[4] + v24 * 4));
    if ((_DWORD)v15)
      goto LABEL_5;
    v15 = krb5_ret_uint32(v14, (_DWORD *)(v12[4] + v24 * 4 + 8));
    if ((_DWORD)v15)
      goto LABEL_5;
    v15 = krb5_ret_uint32(v14, (_DWORD *)(v12[4] + v24 * 4 + 4));
    if ((_DWORD)v15)
      goto LABEL_5;
    v21 = (unsigned int *)v12[4];
    v25 = &v21[v24];
    v26 = v21[v24 + 2];
    if ((v26 & 7) != 0)
    {
      v19 = "PAC out of allignment";
      goto LABEL_19;
    }
    if (v25[1])
    {
      v19 = "PAC high offset set";
      goto LABEL_19;
    }
    if (a3 < v26)
    {
      v19 = "PAC offset off end";
      goto LABEL_19;
    }
    if (v26 < v20)
    {
      v31 = (const char *)v21[v24 + 2];
      v32 = v20;
      v19 = "PAC offset inside header: %lu %lu";
      goto LABEL_19;
    }
    if (a3 - v26 < v21[v24])
    {
      v19 = "PAC length off end";
      goto LABEL_19;
    }
    v29 = *(v25 - 1);
    v27 = v25 - 1;
    v28 = v29;
    switch(v29)
    {
      case 2:
        if (!v12[10])
        {
          v12[10] = v27;
          goto LABEL_46;
        }
        v30 = "credential info";
        goto LABEL_58;
      case 6:
        if (v12[7])
        {
          v30 = "server checksum";
          goto LABEL_58;
        }
        v12[7] = v27;
        goto LABEL_46;
      case 7:
        if (v12[8])
        {
          v30 = "KDC checksum";
          goto LABEL_58;
        }
        v12[8] = v27;
        goto LABEL_46;
      case 10:
        if (!v12[9])
        {
          v12[9] = v27;
LABEL_46:
          ++v23;
          v24 += 4;
          if (v23 >= *v21)
            goto LABEL_47;
          continue;
        }
        v30 = "logon names";
LABEL_58:
        v31 = v30;
        v19 = "PAC have two %s";
LABEL_19:
        v16 = 22;
        krb5_set_error_message(a1, 22, v19, v31, v32);
LABEL_6:
        krb5_storage_free(v14);
LABEL_9:
        v17 = (void *)v12[4];
        if (v17)
          free(v17);
        free(v12);
        v12 = 0;
LABEL_12:
        *a4 = v12;
        return v16;
      default:
        sub_20969D1E8((uint64_t)a1, 5, "krb5_pac_parse: unsupported pac type %d", v28);
        v21 = (unsigned int *)v12[4];
        goto LABEL_46;
    }
  }
}

void sub_2096A02D4(uint64_t a1)
{
  krb5_data_free((_QWORD *)(a1 + 40));
  krb5_data_free((_QWORD *)(a1 + 88));
  free(*(void **)(a1 + 32));
}

uint64_t krb5_pac_init(_krb5_context *a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  uint64_t v11;
  void *v12;
  uint64_t result;

  v10 = heim_uniq_alloc(0x68uLL, (uint64_t)"krb5-pac", (uint64_t)sub_2096A02D4, a4, a5, a6, a7, a8);
  if (!v10)
    return krb5_enomem(a1);
  v11 = v10;
  v12 = malloc_type_calloc(1uLL, 0x18uLL, 0x1000040504FFAC1uLL);
  *(_QWORD *)(v11 + 32) = v12;
  if (!v12)
  {
LABEL_5:
    free((void *)v11);
    return krb5_enomem(a1);
  }
  result = krb5_data_alloc((size_t *)(v11 + 40), 8uLL);
  if ((_DWORD)result)
  {
    free(*(void **)(v11 + 32));
    goto LABEL_5;
  }
  *a2 = v11;
  return result;
}

uint64_t krb5_pac_add_buffer(krb5_context a1, _QWORD *a2, int a3, uint64_t a4)
{
  unsigned int *v6;
  uint64_t v7;
  const char *v8;
  int v11;
  char *v12;
  _DWORD *v13;
  uint64_t v14;
  unint64_t v15;
  unint64_t v16;
  char *v17;
  size_t v18;
  unsigned int v19;
  uint64_t v20;
  uint64_t v22;
  _QWORD *v23;

  if (*(_DWORD *)(a4 + 4) || (v6 = (unsigned int *)a2[4], v7 = *v6, (_DWORD)v7 == -1))
  {
LABEL_13:
    v8 = "integer overrun";
    goto LABEL_14;
  }
  if (v7 >= 0x3E8)
  {
    v8 = "PAC has too many buffers";
LABEL_14:
    v20 = 22;
    krb5_set_error_message(a1, 22, v8);
    return v20;
  }
  v11 = 16 * v7;
  v12 = (char *)malloc_type_realloc(v6, 16 * v7 + 24, 0xA7EAE51AuLL);
  if (v12)
  {
    a2[4] = v12;
    if ((_DWORD)v7)
    {
      v13 = v12 + 20;
      v14 = v7;
      while (*v13 < 0xFFFFFFF0)
      {
        *v13 += 16;
        v13 += 4;
        if (!--v14)
          goto LABEL_10;
      }
    }
    else
    {
LABEL_10:
      v15 = a2[5];
      if (v15 < 0xFFFFFFF0)
      {
        v16 = (v15 + 16);
        v17 = &v12[16 * v7];
        v18 = *(_QWORD *)a4;
        *((_DWORD *)v17 + 2) = a3;
        *(_QWORD *)(v17 + 12) = v18;
        *((_DWORD *)v17 + 5) = v16;
        if (0xFFFFFFFF - v18 >= v16)
        {
          v19 = v16 + v18;
          if ((v16 + v18) < 0xFFFFFFF9)
          {
            v20 = krb5_data_realloc((uint64_t)(a2 + 5), (v19 + 7) & 0xFFFFFFF8);
            if ((_DWORD)v20)
            {
              krb5_set_error_message(a1, v20, "malloc: out of memory");
            }
            else
            {
              v22 = v11 | 8u;
              memmove((void *)(a2[6] + v22 + 16), (const void *)(a2[6] + v22), (v15 - v22));
              v23 = (_QWORD *)(a2[6] + v22);
              *v23 = 0;
              v23[1] = 0;
              memcpy((void *)(a2[6] + v16), *(const void **)(a4 + 8), *(_QWORD *)a4);
              bzero((void *)(a2[6] + *(_QWORD *)a4 + v16), a2[5] - v19);
              ++*(_DWORD *)a2[4];
            }
            return v20;
          }
        }
      }
    }
    goto LABEL_13;
  }
  return krb5_enomem(a1);
}

uint64_t krb5_pac_get_buffer(_krb5_context *a1, uint64_t a2, int a3, _QWORD *a4)
{
  unsigned int *v5;
  uint64_t v6;
  unsigned int *v7;
  uint64_t v8;

  v5 = *(unsigned int **)(a2 + 32);
  v6 = *v5;
  if ((_DWORD)v6)
  {
    v7 = v5 + 3;
    while (*(v7 - 1) != a3)
    {
      v7 += 4;
      if (!--v6)
        goto LABEL_5;
    }
    v8 = krb5_data_copy(a4, (const void *)(*(_QWORD *)(a2 + 48) + v7[2]), *v7);
    if ((_DWORD)v8)
      krb5_set_error_message(a1, v8, "malloc: out of memory");
  }
  else
  {
LABEL_5:
    v8 = 2;
    krb5_set_error_message(a1, 2, "No PAC buffer of type %lu was found");
  }
  return v8;
}

uint64_t krb5_pac_get_types(_krb5_context *a1, uint64_t a2, unint64_t *a3, _QWORD *a4)
{
  _DWORD *v8;
  _DWORD *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;

  v8 = malloc_type_calloc(**(unsigned int **)(a2 + 32), 4uLL, 0x100004052888210uLL);
  *a4 = v8;
  if (v8)
  {
    v9 = *(_DWORD **)(a2 + 32);
    if (*v9)
    {
      v10 = 0;
      v11 = 2;
      do
      {
        v8[v10++] = v9[v11];
        v12 = *v9;
        v11 += 4;
      }
      while (v10 < v12);
    }
    else
    {
      v12 = 0;
    }
    *a3 = v12;
    return 0;
  }
  else
  {
    *a3 = 0;
    return krb5_enomem(a1);
  }
}

void krb5_pac_free(uint64_t a1, const void *a2)
{
  heim_release(a2);
}

uint64_t krb5_pac_verify(krb5_context a1, uint64_t a2, uint64_t a3, uint64_t a4, const krb5_keyblock *a5, const krb5_keyblock *a6)
{
  uint64_t v8;
  _QWORD *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  const char *v17;
  unsigned __int16 *v19;
  unsigned __int16 *v20;
  uint64_t v21;
  uint64_t v22;
  unsigned __int16 *v23;
  unsigned __int16 *v24;
  uint64_t v25;
  unsigned int v26;
  uint64_t v27;
  _BYTE *v28;
  void *v29;
  unsigned int v30;
  unint64_t v31;
  unint64_t v32;
  _WORD size[5];
  krb5_principal v34;

  if (!*(_QWORD *)(a2 + 56))
  {
    v17 = "PAC missing server checksum";
LABEL_11:
    v16 = 22;
    krb5_set_error_message(a1, 22, v17);
    return v16;
  }
  if (!*(_QWORD *)(a2 + 64))
  {
    v17 = "PAC missing kdc checksum";
    goto LABEL_11;
  }
  v8 = *(_QWORD *)(a2 + 72);
  if (!v8)
  {
    v17 = "PAC missing logon name";
    goto LABEL_11;
  }
  v13 = krb5_storage_from_readonly_mem(*(_QWORD *)(a2 + 48) + *(unsigned int *)(v8 + 12), *(unsigned int *)(v8 + 4));
  if (!v13)
  {
LABEL_24:
    v16 = krb5_enomem(a1);
    goto LABEL_25;
  }
  v14 = (uint64_t)v13;
  v34 = 0;
  memset(size, 0, sizeof(size));
  krb5_storage_set_flags((uint64_t)v13, 32);
  v15 = krb5_ret_uint32(v14, &size[3]);
  if ((_DWORD)v15)
    goto LABEL_7;
  v15 = krb5_ret_uint32(v14, &size[1]);
  if ((_DWORD)v15)
    goto LABEL_7;
  if (10000000 * a3 + 116444736000000000 != (*(unsigned int *)&size[3] | ((unint64_t)*(unsigned int *)&size[1] << 32)))
  {
    krb5_storage_free(v14);
    v17 = "PAC timestamp mismatch";
    goto LABEL_11;
  }
  v15 = krb5_ret_uint16(v14, size);
  if ((_DWORD)v15)
  {
LABEL_7:
    v16 = v15;
    krb5_clear_error_message(a1);
    return v16;
  }
  if (!size[0])
  {
    krb5_storage_free(v14);
    v17 = "PAC logon name length missing";
    goto LABEL_11;
  }
  v19 = (unsigned __int16 *)malloc_type_malloc(size[0], 0x6D044D09uLL);
  if (!v19)
  {
    krb5_storage_free(v14);
    goto LABEL_24;
  }
  v20 = v19;
  v21 = krb5_storage_read(v14);
  v22 = size[0];
  krb5_storage_free(v14);
  if (v21 != v22)
  {
    v17 = "Failed to read PAC logon name";
    goto LABEL_11;
  }
  v31 = 0;
  v32 = (unint64_t)size[0] >> 1;
  v30 = 1;
  v23 = (unsigned __int16 *)malloc_type_malloc(2 * v32, 0x1000040BDFB0063uLL);
  if (!v23)
    goto LABEL_24;
  v24 = v23;
  v16 = sub_2096BB150(v20, size[0], &v30, v23, (uint64_t *)&v32);
  free(v20);
  if (!(_DWORD)v16)
  {
    v27 = wind_ucs2utf8_length(v24, v32, &v31);
    if ((_DWORD)v27)
    {
      v16 = v27;
      free(v24);
      krb5_set_error_message(a1, v16, "Failed to count length of UCS-2 string");
      goto LABEL_25;
    }
    v28 = malloc_type_malloc(++v31, 0x9D3085B4uLL);
    if (v28)
    {
      v29 = v28;
      v16 = wind_ucs2utf8(v24, v32, v28, &v31);
      free(v24);
      if ((_DWORD)v16)
      {
        free(v29);
        krb5_set_error_message(a1, v16, "Failed to convert to UTF-8");
      }
      else
      {
        v16 = krb5_parse_name_flags(a1, (const char *)v29, 1, &v34);
        free(v29);
        if ((_DWORD)v16)
          return v16;
        if (krb5_principal_compare_any_realm((uint64_t)a1, a4, (uint64_t)v34) == 1)
        {
          v16 = 0;
        }
        else
        {
          v16 = 22;
          krb5_set_error_message(a1, 22, "PAC logon name mismatch");
        }
        krb5_free_principal(a1, v34);
      }
      goto LABEL_25;
    }
    free(v24);
    goto LABEL_24;
  }
  free(v24);
  krb5_set_error_message(a1, v16, "Failed to convert string to UCS-2");
LABEL_25:
  if (!(_DWORD)v16)
  {
    v34 = 0;
    v16 = krb5_copy_data(a1, (const krb5_data *)(a2 + 40), (krb5_data **)&v34);
    if (!(_DWORD)v16)
    {
      v25 = *(_QWORD *)(a2 + 56);
      v26 = *(_DWORD *)(v25 + 4);
      if (v26 >= 4 && *(_DWORD *)(*(_QWORD *)(a2 + 64) + 4) > 3u)
      {
        bzero((void *)(*(_QWORD *)&v34->realm.magic + *(unsigned int *)(v25 + 12) + 4), v26 - 4);
        bzero((void *)(*(_QWORD *)&v34->realm.magic + *(unsigned int *)(*(_QWORD *)(a2 + 64) + 12) + 4), (*(_DWORD *)(*(_QWORD *)(a2 + 64) + 4) - 4));
        v16 = sub_2096A0AF4(a1, *(_QWORD *)(a2 + 56), a2 + 40, *(const void **)&v34->realm.magic, *(_QWORD *)&v34->magic, a5);
        krb5_free_data(a1, (krb5_data *)v34);
        if (!(_DWORD)v16)
        {
          if (!a6)
            return 0;
          v16 = sub_2096A0AF4(a1, *(_QWORD *)(a2 + 64), a2 + 40, (const void *)(*(_QWORD *)(a2 + 48) + *(unsigned int *)(*(_QWORD *)(a2 + 56) + 12) + 4), (*(_DWORD *)(*(_QWORD *)(a2 + 56) + 4) - 4), a6);
          if (!(_DWORD)v16)
            return 0;
        }
      }
      else
      {
        return 22;
      }
    }
  }
  return v16;
}

uint64_t sub_2096A0AF4(_krb5_context *a1, uint64_t a2, uint64_t a3, const void *a4, size_t a5, const krb5_keyblock *a6)
{
  _QWORD *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  void *v20;
  void *v21;
  const char *v22;
  void *v23;
  uint64_t v24;
  size_t v25;
  uint64_t v26;
  krb5_cksumtype ctype[2];
  _QWORD v28[2];
  uint64_t seed;
  uint64_t v30;
  void *v31;
  unsigned int v32;

  seed = 0;
  v30 = 0;
  v31 = 0;
  v11 = krb5_storage_from_mem(*(_QWORD *)(a3 + 8) + *(unsigned int *)(a2 + 12), *(unsigned int *)(a2 + 4));
  if (!v11)
    return krb5_enomem(a1);
  v12 = (uint64_t)v11;
  v32 = 0;
  krb5_storage_set_flags((uint64_t)v11, 32);
  v13 = krb5_ret_uint32(v12, &v32);
  if (!(_DWORD)v13)
  {
    v16 = v32;
    LODWORD(seed) = v32;
    v17 = *(unsigned int *)(a2 + 4);
    v18 = krb5_storage_seek(v12);
    v19 = v17 - v18;
    v30 = v17 - v18;
    v20 = malloc_type_malloc(v17 - v18, 0x94A962CDuLL);
    v31 = v20;
    if (!v20)
    {
      v14 = krb5_enomem(a1);
      goto LABEL_24;
    }
    v21 = v20;
    if (krb5_storage_read(v12) == v19)
    {
      if (krb5_checksum_is_keyed((uint64_t)a1, v16))
      {
        if ((_DWORD)v16 == -138)
        {
          *(_QWORD *)ctype = 0;
          v28[0] = 0;
          v28[1] = 0;
          if (sub_2096A18C8(a1, a6, (uint64_t)a4, a5, (uint64_t)ctype)
            || krb5_data_ct_cmp((uint64_t)v28, (uint64_t)&v30))
          {
            v14 = 2529638943;
            krb5_set_error_message(a1, -1765328353, "PAC integrity check failed for hmac-md5 checksum");
          }
          else
          {
            v14 = 0;
          }
          krb5_data_free(v28);
          goto LABEL_22;
        }
        *(_QWORD *)ctype = 0;
        v24 = krb5_crypto_init(a1, a6, 0, (krb5_keyblock ***)ctype);
        if (!(_DWORD)v24)
        {
          v14 = krb5_verify_checksum(a1, ctype[0], (const krb5_checksum *)0x11, a4, a5, &seed, v25);
          krb5_crypto_destroy(a1, *(uint64_t *)ctype);
LABEL_22:
          v23 = v31;
          goto LABEL_23;
        }
        v14 = v24;
        v21 = v31;
        if (!v31)
          goto LABEL_24;
LABEL_17:
        v23 = v21;
LABEL_23:
        free(v23);
        goto LABEL_24;
      }
      v26 = v16;
      v22 = "Checksum type %d not keyed";
    }
    else
    {
      v22 = "PAC checksum missing checksum";
    }
    v14 = 22;
    krb5_set_error_message(a1, 22, v22, v26);
    goto LABEL_17;
  }
  v14 = v13;
  krb5_clear_error_message(a1);
LABEL_24:
  krb5_storage_free(v12);
  return v14;
}

uint64_t krb5_pac_process_credentials_buffer(_krb5_context *a1, _QWORD *a2, const krb5_keyblock *a3)
{
  uint64_t v3;
  void *v4;
  uint64_t v7;
  uint64_t v8;
  _QWORD *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  const char *v15;
  uint64_t magic;
  uint64_t v17;
  krb5_const_pointer inptr;
  uint64_t v19;

  v3 = 2314790736;
  inptr = 0;
  v19 = 0;
  v4 = a2 + 11;
  if (a2[11])
    return 2314790739;
  v7 = a2[10];
  if (!v7)
    return 2314790737;
  v8 = *(unsigned int *)(v7 + 4);
  if (v8 < 8)
    return 2314790739;
  if (v8 > 0x2710)
    return 2314790741;
  v11 = krb5_storage_from_readonly_mem(a2[6] + *(unsigned int *)(v7 + 12), v8);
  if (v11)
  {
    v12 = (uint64_t)v11;
    krb5_storage_set_flags((uint64_t)v11, 32);
    v13 = krb5_ret_uint32(v12, (_DWORD *)&v19 + 1);
    if ((_DWORD)v13 || (v13 = krb5_ret_int32(v12, (unsigned int *)&v19), (_DWORD)v13))
    {
      v14 = v13;
      krb5_clear_error_message(a1);
      v3 = v14;
    }
    else if (HIDWORD(v19))
    {
      v3 = 2314790738;
      krb5_set_error_message(a1, -1980176558, "unsupport pac credentail version: %d");
    }
    else
    {
      if (v19 <= 0x17 && ((1 << v19) & 0x86000A) != 0)
      {
        if (a3->magic == (_DWORD)v19)
        {
          v3 = krb5_crypto_init(a1, a3, 0, (krb5_keyblock ***)&inptr);
          if (!(_DWORD)v3)
            v3 = krb5_decrypt(a1, inptr, (krb5_pointer)0x10, a2[6] + *(unsigned int *)(a2[10] + 12) + 8, (krb5_encrypt_block *)(*(_DWORD *)(a2[10] + 4) - 8), v4);
          goto LABEL_14;
        }
        magic = a3->magic;
        v17 = v19;
        v15 = "as key (%d) mismatch with PAC enctype (%d)";
      }
      else
      {
        magic = v19;
        v15 = "enctype: %d not support as pac enctype";
      }
      krb5_set_error_message(a1, -1980176560, v15, magic, v17);
    }
LABEL_14:
    krb5_storage_free(v12);
    if (inptr)
      krb5_crypto_destroy(a1, (uint64_t)inptr);
    return v3;
  }
  return krb5_enomem(a1);
}

uint64_t krb5_pac_copy_credential_package()
{
  return 2314790737;
}

uint64_t _krb5_pac_sign(_krb5_context *a1, _QWORD *a2, uint64_t a3, const krb5_principal_data *a4, const krb5_keyblock *a5, const krb5_keyblock *a6, _OWORD *a7)
{
  int v14;
  _QWORD *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  _DWORD *v19;
  const char *v20;
  unsigned int v21;
  _DWORD *v23;
  uint64_t v24;
  _DWORD *v25;
  _DWORD *v26;
  uint64_t v27;
  _DWORD *v28;
  _DWORD *v29;
  uint64_t v30;
  _DWORD *v31;
  _QWORD *v32;
  uint64_t v33;
  _QWORD *v34;
  uint64_t v35;
  uint64_t v36;
  size_t v37;
  size_t v38;
  char *v39;
  char *v40;
  uint64_t v41;
  char *v42;
  uint64_t v43;
  unsigned int *v44;
  int v45;
  const char *v46;
  uint64_t v47;
  uint64_t v48;
  unsigned int v49;
  unint64_t v50;
  uint64_t v51;
  uint64_t v52;
  int v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  unint64_t v58;
  uint64_t v59;
  uint64_t v60;
  unsigned int v61;
  __int128 v62;
  size_t v63[2];
  uint64_t v64;
  unint64_t v65;
  unint64_t v66;
  char *__s;

  v65 = 0;
  v66 = 0;
  v63[1] = 0;
  v64 = 0;
  v63[0] = 0;
  v62 = 0uLL;
  krb5_data_zero(v63);
  if (a4)
  {
    v14 = a2[9] == 0;
    if (!a5)
      goto LABEL_5;
  }
  else
  {
    v14 = 0;
    if (!a5)
      goto LABEL_5;
  }
  if (!a2[7])
    ++v14;
LABEL_5:
  if (a6 && !a2[8])
  {
    ++v14;
  }
  else if (!v14)
  {
    goto LABEL_8;
  }
  v19 = (_DWORD *)a2[4];
  if (__CFADD__(v14, *v19))
  {
    v20 = "integer overrun";
LABEL_23:
    v18 = 22;
    krb5_set_error_message(a1, 22, v20);
    goto LABEL_24;
  }
  v21 = *v19 + v14;
  if (v21 > 0x3E8)
  {
    v20 = "PAC has too many buffers";
    goto LABEL_23;
  }
  v23 = malloc_type_realloc(v19, (16 * v21) | 8, 0x7E3432CFuLL);
  if (!v23)
    return krb5_enomem(a1);
  a2[4] = v23;
  if (a4 && !a2[9])
  {
    v24 = *v23;
    *v23 = v24 + 1;
    v25 = &v23[4 * v24];
    a2[9] = v25 + 2;
    *((_QWORD *)v25 + 1) = 0;
    *((_QWORD *)v25 + 2) = 0;
    *(_DWORD *)a2[9] = 10;
  }
  if (a5 && !a2[7])
  {
    v26 = (_DWORD *)a2[4];
    v27 = *v26;
    *v26 = v27 + 1;
    v28 = &v26[4 * v27];
    a2[7] = v28 + 2;
    *((_QWORD *)v28 + 1) = 0;
    *((_QWORD *)v28 + 2) = 0;
    *(_DWORD *)a2[7] = 6;
  }
  if (a6 && !a2[8])
  {
    v29 = (_DWORD *)a2[4];
    v30 = *v29;
    *v29 = v30 + 1;
    v31 = &v29[4 * v30];
    a2[8] = v31 + 2;
    *((_QWORD *)v31 + 1) = 0;
    *((_QWORD *)v31 + 2) = 0;
    *(_DWORD *)a2[8] = 7;
  }
LABEL_8:
  if (!a4)
    goto LABEL_37;
  krb5_data_zero(v63);
  v15 = krb5_storage_emem();
  if (!v15)
  {
    v18 = krb5_enomem(a1);
    if ((_DWORD)v18)
      goto LABEL_24;
    goto LABEL_37;
  }
  v16 = (uint64_t)v15;
  __s = 0;
  krb5_storage_set_flags((uint64_t)v15, 32);
  v17 = krb5_store_uint32(v16, 10000000 * a3 + 116444736000000000);
  if ((_DWORD)v17
    || (v17 = krb5_store_uint32(v16, (unint64_t)(10000000 * a3 + 116444736000000000) >> 32), (_DWORD)v17))
  {
LABEL_12:
    v18 = v17;
    krb5_clear_error_message(a1);
    goto LABEL_13;
  }
  v18 = krb5_unparse_name_flags(a1, a4, 2, &__s);
  if (!(_DWORD)v18)
  {
    v37 = strlen(__s);
    v38 = 2 * v37;
    v17 = krb5_store_uint16(v16, 2 * (unsigned __int16)v37);
    if (!(_DWORD)v17)
    {
      v39 = (char *)malloc_type_malloc(v38, 0x3BE4CF34uLL);
      if (v39)
      {
        v40 = v39;
        if (v37)
        {
          v41 = 0;
          v42 = v39 + 1;
          do
          {
            *(_WORD *)(v42 - 1) = __s[v41];
            v42 += 2;
            ++v41;
          }
          while (v37 != v41);
        }
        free(__s);
        v43 = krb5_storage_write(v16);
        free(v40);
        if (v43 < 0 || v43 != v38)
        {
          v18 = krb5_enomem(a1);
        }
        else
        {
          v18 = krb5_storage_to_data(v16, v63);
          if (!(_DWORD)v18)
          {
            krb5_storage_free(v16);
            if (!a5)
              goto LABEL_39;
LABEL_38:
            v18 = sub_2096A1684(a1, a5, (_DWORD *)&v64 + 1, &v66);
            if (!(_DWORD)v18)
              goto LABEL_39;
LABEL_24:
            krb5_data_free(v63);
            return v18;
          }
        }
      }
      else
      {
        v18 = krb5_enomem(a1);
        free(__s);
      }
      goto LABEL_13;
    }
    goto LABEL_12;
  }
LABEL_13:
  krb5_storage_free(v16);
  if ((_DWORD)v18)
    goto LABEL_24;
LABEL_37:
  if (a5)
    goto LABEL_38;
LABEL_39:
  if (a6)
  {
    if (a2[7])
    {
      v18 = sub_2096A1684(a1, a6, &v64, &v65);
      if ((_DWORD)v18)
        goto LABEL_24;
    }
  }
  v32 = krb5_storage_emem();
  if (!v32)
    return krb5_enomem(a1);
  v33 = (uint64_t)v32;
  krb5_storage_set_flags((uint64_t)v32, 32);
  v34 = krb5_storage_emem();
  if (!v34)
  {
    krb5_storage_free(v33);
    return krb5_enomem(a1);
  }
  v35 = (uint64_t)v34;
  krb5_storage_set_flags((uint64_t)v34, 32);
  v36 = krb5_store_uint32(v33, *(unsigned int *)a2[4]);
  if ((_DWORD)v36 || (v36 = krb5_store_uint32(v33, *(unsigned int *)(a2[4] + 4)), (_DWORD)v36))
  {
LABEL_46:
    v18 = v36;
    krb5_clear_error_message(a1);
    goto LABEL_47;
  }
  v44 = (unsigned int *)a2[4];
  v45 = *v44;
  if (*v44 >= 0x3E9)
  {
    v46 = "PAC has too many buffers";
    goto LABEL_63;
  }
  if (v45)
  {
    v47 = 0;
    v48 = 0;
    v59 = 0;
    v58 = __PAIR64__(v64, HIDWORD(v64));
    v61 = (16 * v45) | 8;
    while (1)
    {
      v49 = v44[v47 + 2];
      v60 = v48;
      switch(v49)
      {
        case 0xAu:
          v51 = krb5_storage_write(v35);
          if (v63[0] != v51)
          {
            v18 = 22;
            goto LABEL_47;
          }
          break;
        case 7u:
          v50 = v65;
          if (v65 > 0xFFFFFFFB)
            goto LABEL_100;
          v36 = krb5_store_uint32(v35, HIDWORD(v58));
          if ((_DWORD)v36)
            goto LABEL_46;
          v36 = sub_2096A173C(a1, v35, v65);
          if ((_DWORD)v36)
            goto LABEL_46;
          LODWORD(v59) = v61 + 4;
          goto LABEL_79;
        case 6u:
          v50 = v66;
          if (v66 > 0xFFFFFFFB)
            goto LABEL_100;
          v36 = krb5_store_uint32(v35, v58);
          if ((_DWORD)v36)
            goto LABEL_46;
          v36 = sub_2096A173C(a1, v35, v66);
          if ((_DWORD)v36)
            goto LABEL_46;
          HIDWORD(v59) = v61 + 4;
LABEL_79:
          v51 = v50 + 4;
          break;
        default:
          v51 = v44[v47 + 3];
          v52 = krb5_storage_write(v35);
          if (v52 < 0 || v52 != v51)
            goto LABEL_99;
          break;
      }
      v36 = krb5_store_uint32(v33, *(unsigned int *)(a2[4] + v47 * 4 + 8));
      if ((_DWORD)v36)
        goto LABEL_46;
      v36 = krb5_store_uint32(v33, v51);
      if ((_DWORD)v36)
        goto LABEL_46;
      v36 = krb5_store_uint32(v33, v61);
      if ((_DWORD)v36)
        goto LABEL_46;
      v36 = krb5_store_uint32(v33, 0);
      if ((_DWORD)v36)
        goto LABEL_46;
      if (0xFFFFFFFFLL - v51 < (unint64_t)v61 || (v53 = v61 + v51, v61 + v51 >= 0xFFFFFFF9))
      {
LABEL_100:
        v46 = "integer overrun";
LABEL_63:
        v18 = 22;
        krb5_set_error_message(a1, 22, v46, v58, v59);
LABEL_47:
        krb5_data_free(v63);
        krb5_storage_free(v33);
        krb5_storage_free(v35);
        return v18;
      }
      v61 = (v53 + 7) & 0xFFFFFFF8;
      if (v61 != v53)
      {
        v36 = sub_2096A173C(a1, v35, v61 - v53);
        if ((_DWORD)v36)
          goto LABEL_46;
      }
      v48 = v60 + 1;
      v44 = (unsigned int *)a2[4];
      v47 += 4;
      if (v60 + 1 >= (unint64_t)*v44)
        goto LABEL_94;
    }
  }
  v59 = 0;
LABEL_94:
  v54 = krb5_storage_to_data(v35, (size_t *)&v62);
  if ((_DWORD)v54)
  {
    v18 = v54;
    krb5_set_error_message(a1, v54, "malloc: out of memory", v58, v59);
    goto LABEL_47;
  }
  v55 = krb5_storage_write(v33);
  v56 = (int)v62;
  krb5_data_free(&v62);
  if (v55 != v56 || krb5_storage_to_data(v33, (size_t *)&v62))
  {
LABEL_99:
    v18 = krb5_enomem(a1);
    goto LABEL_47;
  }
  if (a5
    && (v57 = sub_2096A17C0(a1, a5, SHIDWORD(v64), *((uint64_t *)&v62 + 1), v62, (void *)(*((_QWORD *)&v62 + 1) + HIDWORD(v59)), v66), (_DWORD)v57)|| a6&& a2[7]&& (v57 = sub_2096A17C0(a1, a6, v64, *((_QWORD *)&v62 + 1) + HIDWORD(v59), v66, (void *)(*((_QWORD *)&v62 + 1) + v59), v65), (_DWORD)v57))
  {
    v18 = v57;
    krb5_data_free(&v62);
    goto LABEL_47;
  }
  *a7 = v62;
  krb5_data_free(v63);
  krb5_storage_free(v33);
  krb5_storage_free(v35);
  return 0;
}

uint64_t sub_2096A1684(_krb5_context *a1, const krb5_keyblock *a2, _DWORD *a3, _QWORD *a4)
{
  uint64_t checksum_type;
  krb5_keyblock **v9;
  int v10;

  v10 = 0;
  v9 = 0;
  checksum_type = krb5_crypto_init(a1, a2, 0, &v9);
  if (!(_DWORD)checksum_type)
  {
    checksum_type = krb5_crypto_get_checksum_type(a1, (uint64_t)v9, &v10);
    krb5_crypto_destroy(a1, (uint64_t)v9);
    if (!(_DWORD)checksum_type)
    {
      if (!krb5_checksum_is_keyed((uint64_t)a1, v10))
      {
        *a3 = -138;
        *a4 = 16;
      }
      checksum_type = krb5_checksumsize(a1, v10, a4);
      if (!(_DWORD)checksum_type)
        *a3 = v10;
    }
  }
  return checksum_type;
}

uint64_t sub_2096A173C(_krb5_context *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v6;

  if (!a3)
    return 0;
  v3 = a3;
  while (1)
  {
    v6 = krb5_storage_write(a2);
    if (v6 <= 0)
      break;
    v3 -= v6;
    if (!v3)
      return 0;
  }
  return krb5_enomem(a1);
}

uint64_t sub_2096A17C0(_krb5_context *a1, const krb5_keyblock *a2, int a3, uint64_t a4, uint64_t a5, void *a6, size_t a7)
{
  uint64_t checksum;
  uint64_t v14;
  uint64_t v15;
  void *__src;
  krb5_keyblock **v17;

  __src = 0;
  v17 = 0;
  v14 = 0;
  v15 = 0;
  if (a3 == -138)
  {
    checksum = sub_2096A18C8(a1, a2, a4, a5, (uint64_t)&v14);
    if ((_DWORD)checksum)
      return checksum;
  }
  else
  {
    checksum = krb5_crypto_init(a1, a2, 0, &v17);
    if ((_DWORD)checksum)
      return checksum;
    checksum = krb5_create_checksum(a1, (_DWORD **)v17, 0x11u, 0, a4, a5, (uint64_t)&v14);
    krb5_crypto_destroy(a1, (uint64_t)v17);
    if ((_DWORD)checksum)
      return checksum;
  }
  if (v15 == a7)
  {
    memcpy(a6, __src, a7);
    checksum = 0;
  }
  else
  {
    checksum = 22;
    krb5_set_error_message(a1, 22, "pac checksum wrong length", v14);
  }
  sub_2096BB8BC();
  return checksum;
}

uint64_t sub_2096A18C8(_krb5_context *a1, const krb5_keyblock *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v9;
  krb5_keyblock *v11[2];

  v11[0] = 0;
  v11[1] = 0;
  v9 = krb5_copy_keyblock(a1, a2, v11);
  if (!(_DWORD)v9)
  {
    v9 = krb5_data_alloc((size_t *)(a5 + 8), 0x10uLL);
    if (!(_DWORD)v9)
    {
      *(_DWORD *)a5 = -138;
      v9 = sub_2096B4C0C(a1, (uint64_t *)v11, a3, a4, 17, a5);
      if ((_DWORD)v9)
        krb5_data_free((_QWORD *)(a5 + 8));
    }
    krb5_free_keyblock(a1, v11[0]);
  }
  return v9;
}

_DWORD *krb5_find_padata(uint64_t a1, int a2, int a3, int *a4)
{
  int v4;
  _DWORD *result;

  v4 = *a4;
  if (*a4 >= a2)
    return 0;
  for (result = (_DWORD *)(a1 + 24 * v4); *result != a3; result += 6)
  {
    *a4 = ++v4;
    if (a2 == v4)
      return 0;
  }
  return result;
}

uint64_t krb5_padata_add(_krb5_context *a1, unsigned int *a2, int a3, uint64_t a4, uint64_t a5)
{
  char *v10;
  uint64_t v11;
  int v12;
  char *v13;

  v10 = (char *)malloc_type_realloc(*((void **)a2 + 1), 24 * (*a2 + 1), 0x10800404ACF7207uLL);
  if (v10)
  {
    v11 = 0;
    *((_QWORD *)a2 + 1) = v10;
    v12 = *a2;
    v13 = &v10[24 * *a2];
    *(_DWORD *)v13 = a3;
    *((_QWORD *)v13 + 1) = a5;
    *((_QWORD *)v13 + 2) = a4;
    *a2 = v12 + 1;
  }
  else
  {
    v11 = 12;
    krb5_set_error_message(a1, 12, "malloc: out of memory");
  }
  return v11;
}

uint64_t _krb5_pk_find_cert(uint64_t *a1, int a2, uint64_t a3, int *a4, _QWORD *a5)
{
  uint64_t v9;
  uint64_t match_eku;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  _QWORD v17[2];
  _OWORD v18[2];
  _QWORD v19[10];

  v19[9] = *MEMORY[0x24BDAC8D0];
  v19[0] = 0x2096DF386;
  v19[2] = "PKINIT EKU";
  v19[4] = 0x2096DF39ELL;
  v18[0] = xmmword_2096D946C;
  v18[1] = unk_2096D947C;
  v17[0] = 8;
  v17[1] = v18;
  v19[1] = v17;
  v19[3] = &unk_24C1F5750;
  v9 = 2 * (a2 == 0);
  v19[5] = &unk_24C1F57A0;
  v19[6] = "any (or no)";
  v19[7] = 0;
  while (1)
  {
    match_eku = hx509_query_match_eku((uint64_t)a4, v19[v9 + 1]);
    if ((_DWORD)match_eku)
      break;
    v15 = hx509_certs_find(a1[47], a3, a4, a5, v11, v12, v13, v14);
    if ((_DWORD)v15)
    {
      sub_2096A1BCC(a1, v15, "Failed finding certificate with %s OID", (const char *)v19[v9]);
      v9 += 2;
      if (v9 != 8)
        continue;
    }
    return v15;
  }
  v15 = match_eku;
  sub_2096A1BCC(a1, match_eku, "Failed setting %s OID", (const char *)v19[v9]);
  return v15;
}

void sub_2096A1BCC(uint64_t *a1, int a2, char *a3, ...)
{
  char *error_string;
  char *v7;
  char *v8[2];
  va_list va;

  va_start(va, a3);
  v8[0] = 0;
  va_copy((va_list)&v8[1], va);
  if (vasprintf(v8, a3, va) == -1 || v8[0] == 0)
  {
    krb5_clear_error_message((krb5_context)a1);
  }
  else
  {
    error_string = hx509_get_error_string(a1[47], a2);
    if (error_string)
    {
      v7 = error_string;
      krb5_set_error_message((krb5_context)a1, a2, "%s: %s", v8[0], error_string);
      sub_20969D1E8((uint64_t)a1, 5, "%s: %s: %d", v8[0], v7, a2);
      free(v7);
    }
    else
    {
      krb5_clear_error_message((krb5_context)a1);
    }
    free(v8[0]);
  }
}

uint64_t _krb5_pk_mk_ContentInfo(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t result;
  void *v7;
  void *v8;

  result = der_copy_oid();
  if (!(_DWORD)result)
  {
    v7 = malloc_type_calloc(1uLL, 0x10uLL, 0x108004057E67DB5uLL);
    *(_QWORD *)(a4 + 16) = v7;
    if (v7
      && (v8 = malloc_type_malloc(*(_QWORD *)a2, 0x3911C12AuLL), (*(_QWORD *)(*(_QWORD *)(a4 + 16) + 8) = v8) != 0))
    {
      memcpy(v8, *(const void **)(a2 + 8), *(_QWORD *)a2);
      result = 0;
      **(_QWORD **)(a4 + 16) = *(_QWORD *)a2;
    }
    else
    {
      return 12;
    }
  }
  return result;
}

uint64_t sub_2096A1D34(uint64_t *a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, unsigned int *a7, uint64_t a8)
{
  int v9;
  uint64_t checksum;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  BOOL BOOL_default;
  char v36;
  int v37;
  uint64_t v38;
  uint64_t v39;
  void *v40;
  void *v41;
  uint64_t v42;
  _QWORD *v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  int int_default;
  uint64_t **v56;
  _QWORD *v57;
  _QWORD *v58;
  uint64_t *v59;
  uint64_t v60;
  uint64_t *v61;
  uint64_t v62;
  uint64_t v63;
  void *v64;
  void *v65;
  uint64_t signed_1;
  int v67;
  const char *v68;
  _QWORD *v69;
  _QWORD *v70;
  _QWORD *v71;
  krb5_data *v72;
  int v73;
  unsigned int **v74;
  uint64_t v75;
  void *v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  int v82;
  void *v83;
  size_t v84;
  void *v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  void *v89;
  void **v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  krb5_timestamp v100[4];
  __int128 v101;
  __int128 v102;
  __int128 v103;
  krb5_data *v104[2];
  _QWORD v105[2];
  void *v106[2];
  void *v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  _QWORD v111[3];
  __int128 v112;
  __int128 v113;
  __int128 v114;
  __int128 v115;
  __int128 v116;
  uint64_t v117;
  uint64_t v118;
  size_t v119;
  void *v120;
  krb5_int32 v121[2];
  size_t v122;
  const void *v123;
  krb5_int32 v124;
  krb5_timestamp v125[2];
  uint64_t v126;

  v9 = a6;
  if (*(_QWORD *)(*(_QWORD *)a2 + 16) || (*(_BYTE *)(a2 + 52) & 0x20) != 0)
  {
    if (krb5_config_get_BOOL_default((uint64_t)a1, 0, a4, a4, a5, a6, (uint64_t)a7, a8, (uint64_t)"realms"))
    {
      v19 = 1;
      *(_BYTE *)(a2 + 52) = *(_BYTE *)(a2 + 52) & 0xFE | krb5_config_get_BOOL_default((uint64_t)a1, 0, 1, v14, v15, v16, v17, v18, (uint64_t)"realms");
    }
    else
    {
      v19 = 2;
    }
    *(_DWORD *)(a2 + 48) = v19;
    *(_BYTE *)(a2 + 52) = (2
                         * krb5_config_get_BOOL_default((uint64_t)a1, 0, 1, v14, v15, v16, v17, v18, (uint64_t)"realms")) | *(_BYTE *)(a2 + 52) & 0xFD;
    *(_BYTE *)(a2 + 52) = (4
                         * krb5_config_get_BOOL_default((uint64_t)a1, 0, 1, v20, v21, v22, v23, v24, (uint64_t)"realms")) | *(_BYTE *)(a2 + 52) & 0xFB;
    *(_BYTE *)(a2 + 52) = (8
                         * krb5_config_get_BOOL_default((uint64_t)a1, 0, 0, v25, v26, v27, v28, v29, (uint64_t)"realms")) | *(_BYTE *)(a2 + 52) & 0xF7;
    BOOL_default = krb5_config_get_BOOL_default((uint64_t)a1, 0, 1, v30, v31, v32, v33, v34, (uint64_t)"realms");
    v36 = *(_BYTE *)(a2 + 52) & 0xEF | (16 * BOOL_default);
    if ((a3 & 8) != 0)
      v36 = *(_BYTE *)(a2 + 52) & 0xED | (16 * BOOL_default);
    if ((a3 & 0x40) != 0)
      v36 &= ~4u;
    *(_BYTE *)(a2 + 52) = v36;
    if ((*(_BYTE *)(*(_QWORD *)a2 + 48) & 1) != 0)
      *(_BYTE *)(a2 + 52) = v36 & 0xE9;
    v106[1] = 0;
    v107 = 0;
    v105[1] = 0;
    v106[0] = 0;
    v105[0] = 0;
    krb5_data_zero(v106);
    krb5_data_zero(v105);
    v108 = 0;
    v109 = 0;
    v110 = 0;
    v37 = *(_DWORD *)(a2 + 48);
    if (v37 != 2)
    {
      if (v37 != 1)
        goto LABEL_91;
      *(_QWORD *)v100 = 0;
      v121[0] = 0;
      v112 = 0u;
      v113 = 0u;
      v114 = 0u;
      v115 = 0u;
      v38 = sub_2096BB494();
      if ((_DWORD)v38 || (v38 = sub_2096BB420(), (_DWORD)v38))
      {
        checksum = v38;
        sub_2096BC9F8();
        krb5_clear_error_message((krb5_context)a1);
LABEL_116:
        free_ContentInfo();
        return checksum;
      }
      krb5_us_timeofday((krb5_context)a1, v100, v121);
      *((_QWORD *)&v114 + 1) = *(_QWORD *)v100;
      LODWORD(v114) = v121[0];
      LODWORD(v115) = v9;
      v106[0] = (void *)sub_2096BC9E8();
      v106[1] = malloc_type_malloc((size_t)v106[0], 0xA578B99FuLL);
      if (!v106[1])
      {
        checksum = 12;
        goto LABEL_38;
      }
      v63 = sub_2096BC9C8();
      if ((_DWORD)v63)
      {
        checksum = v63;
        free(v106[1]);
        v106[1] = 0;
LABEL_38:
        sub_2096BC9F8();
        krb5_set_error_message((krb5_context)a1, checksum, "Failed encoding AuthPackWin: %d");
        goto LABEL_116;
      }
      sub_2096BC9F8();
      v64 = v106[0];
      if (v106[0] == v107)
      {
        v65 = &asn1_oid_id_pkcs7_data;
        goto LABEL_41;
      }
      goto LABEL_122;
    }
    v103 = 0u;
    *(_OWORD *)v104 = 0u;
    *(_QWORD *)&v101 = 0;
    v102 = 0u;
    *(_OWORD *)v100 = 0u;
    *(_QWORD *)v125 = 0;
    v126 = 0;
    v124 = 0;
    krb5_clear_error_message((krb5_context)a1);
    *(_QWORD *)v121 = 0;
    v122 = 0;
    v123 = 0;
    krb5_us_timeofday((krb5_context)a1, v125, &v124);
    *((_QWORD *)&v101 + 1) = *(_QWORD *)v125;
    LODWORD(v102) = v9;
    v39 = sub_2096BBA18();
    v40 = malloc_type_malloc(v39, 0xC3BDA4CAuLL);
    if (!v40)
      goto LABEL_114;
    v41 = v40;
    v42 = sub_2096BB9F8();
    if ((_DWORD)v42)
    {
      checksum = v42;
      free(v41);
      goto LABEL_115;
    }
    if (v39 != v126)
      krb5_abortx((_krb5_context *)a1, "internal error in ASN.1 encoder");
    checksum = krb5_create_checksum((krb5_context)a1, 0, 0, 14, (uint64_t)v41, v39, (uint64_t)v121);
    free(v41);
    if ((_DWORD)checksum)
      goto LABEL_115;
    v43 = malloc_type_calloc(1uLL, 0x10uLL, 0x108004057E67DB5uLL);
    *((_QWORD *)&v102 + 1) = v43;
    if (!v43)
    {
      checksum = 12;
      krb5_set_error_message((krb5_context)a1, 12, "malloc: out of memory");
      goto LABEL_115;
    }
    checksum = krb5_data_copy(v43, v123, v122);
    sub_2096BB8BC();
    if ((_DWORD)checksum)
    {
LABEL_115:
      sub_2096BC8C8();
      goto LABEL_116;
    }
    if ((*(_DWORD *)(a2 + 8) - 1) > 1)
    {
LABEL_108:
      v90 = (void **)malloc_type_calloc(1uLL, 0x10uLL, 0x1020040D5A9D86FuLL);
      *((_QWORD *)&v103 + 1) = v90;
      if (v90)
      {
        checksum = hx509_crypto_available(a1[47], 0, *(_QWORD *)(*(_QWORD *)a2 + 16), v90 + 1, v90, v91, v92, v93);
        goto LABEL_110;
      }
LABEL_114:
      checksum = 12;
      goto LABEL_115;
    }
    v119 = 0;
    v120 = 0;
    v118 = 0;
    krb5_data_zero(&v119);
    krb5_config_get_string((uint64_t)a1, 0, v44, v45, v46, v47, v48, v49, (uint64_t)"libdefaults");
    int_default = krb5_config_get_int_default((uint64_t)a1, 0, 0, v50, v51, v52, v53, v54, (uint64_t)"libdefaults");
    v56 = (uint64_t **)(a2 + 32);
    checksum = _krb5_parse_moduli();
    if ((_DWORD)checksum)
      goto LABEL_110;
    v57 = sub_2096D4558();
    *(_QWORD *)(a2 + 16) = v57;
    if (v57)
    {
      v58 = v57;
      v59 = *v56;
      v60 = **v56;
      if (int_default)
      {
        if (!v60)
        {
LABEL_33:
          checksum = 22;
          krb5_set_error_message((krb5_context)a1, 22, "Did not find a DH group parameter matching requirement of %lu bits");
          goto LABEL_110;
        }
        v61 = v59 + 1;
        while (*(_QWORD *)(v60 + 8) <= (unint64_t)int_default)
        {
          v62 = *v61++;
          v60 = v62;
          if (!v62)
            goto LABEL_33;
        }
      }
      v69 = sub_2096A4A2C((_krb5_context *)a1, "p", (const void **)(v60 + 16));
      v58[1] = v69;
      if (!v69)
        goto LABEL_89;
      v70 = sub_2096A4A2C((_krb5_context *)a1, "g", (const void **)(v60 + 40));
      v58[2] = v70;
      if (!v70)
        goto LABEL_89;
      v71 = sub_2096A4A2C((_krb5_context *)a1, "q", (const void **)(v60 + 64));
      v58[8] = v71;
      if (!v71)
        goto LABEL_89;
      if (sub_2096D4868(*(_QWORD *)(a2 + 16)) == 1)
      {
        v72 = (krb5_data *)malloc_type_calloc(1uLL, 0x10uLL, 0x108004057E67DB5uLL);
        v104[0] = v72;
        if (v72)
        {
          krb5_data_alloc((size_t *)v72, 0x28uLL);
          krb5_generate_random_block((uint64_t)v104[0]->data, *(_QWORD *)v104[0]);
          checksum = krb5_copy_data((krb5_context)a1, v104[0], (krb5_data **)(a2 + 24));
          if ((_DWORD)checksum)
            goto LABEL_110;
          *(_QWORD *)&v103 = malloc_type_calloc(1uLL, 0x28uLL, 0x10B00401602C2DDuLL);
          if ((_QWORD)v103)
          {
            v73 = *(_DWORD *)(a2 + 8);
            if (v73 == 2)
            {
              checksum = 22;
              goto LABEL_110;
            }
            if (v73 != 1)
              krb5_abortx((_krb5_context *)a1, "internal error");
            v74 = *(unsigned int ***)(a2 + 16);
            memset(v111, 0, sizeof(v111));
            checksum = der_copy_oid();
            if ((_DWORD)checksum)
              goto LABEL_110;
            v117 = 0;
            v115 = 0u;
            v116 = 0u;
            v113 = 0u;
            v114 = 0u;
            v112 = 0u;
            v75 = sub_2096A49AC((_krb5_context *)a1, v74[1], (uint64_t)&v112);
            if ((_DWORD)v75
              || (v75 = sub_2096A49AC((_krb5_context *)a1, v74[2], (uint64_t)&v113 + 8), (_DWORD)v75)
              || (v75 = sub_2096A49AC((_krb5_context *)a1, v74[8], (uint64_t)&v115), (_DWORD)v75))
            {
              checksum = v75;
LABEL_71:
              free_DomainParameters();
              goto LABEL_110;
            }
            *((_QWORD *)&v116 + 1) = 0;
            v117 = 0;
            v83 = malloc_type_malloc(0x10uLL, 0x108004057E67DB5uLL);
            *(_QWORD *)(v103 + 16) = v83;
            if (!v83)
            {
              free_DomainParameters();
              checksum = 0;
              goto LABEL_110;
            }
            v84 = sub_2096D22FC();
            **(_QWORD **)(v103 + 16) = v84;
            v85 = malloc_type_malloc(v84, 0x154B486uLL);
            *(_QWORD *)(*(_QWORD *)(v103 + 16) + 8) = v85;
            if (!v85)
            {
              checksum = 12;
              goto LABEL_71;
            }
            v86 = sub_2096D22DC();
            if ((_DWORD)v86)
            {
              checksum = v86;
              free(*(void **)(*(_QWORD *)(v103 + 16) + 8));
              *(_QWORD *)(*(_QWORD *)(v103 + 16) + 8) = 0;
              goto LABEL_71;
            }
            free_DomainParameters();
            if (v118 != **(_QWORD **)(v103 + 16))
              goto LABEL_123;
            checksum = sub_2096A49AC((_krb5_context *)a1, v74[4], (uint64_t)v111);
            if ((_DWORD)checksum)
            {
LABEL_110:
              if (!(_DWORD)checksum)
              {
                v106[0] = (void *)sub_2096BC8B8();
                v106[1] = malloc_type_malloc((size_t)v106[0], 0x5E8D175uLL);
                if (v106[1])
                {
                  v94 = sub_2096BC898();
                  if (!(_DWORD)v94)
                  {
                    sub_2096BC8C8();
                    v64 = v106[0];
                    if (v106[0] == v107)
                    {
                      v65 = &unk_24C1F5730;
LABEL_41:
                      signed_1 = hx509_cms_create_signed_1(a1[47], 4 * (*(_QWORD *)(*(_QWORD *)a2 + 16) == 0), v65, v106[1], (size_t)v64, 0, *(_QWORD *)(*(_QWORD *)a2 + 16), *(_QWORD *)(a2 + 40), 0, *(_QWORD *)(*(_QWORD *)a2 + 32), v105);
                      if ((_DWORD)signed_1)
                      {
                        checksum = signed_1;
                        sub_2096A1BCC(a1, signed_1, "Create CMS signedData");
                        krb5_data_free(v106);
                        goto LABEL_116;
                      }
                      krb5_data_free(v106);
                      checksum = hx509_cms_wrap_ContentInfo((uint64_t)&asn1_oid_id_pkcs7_signedData, (uint64_t)v105, (uint64_t)v106);
                      krb5_data_free(v105);
                      if ((_DWORD)checksum)
                      {
                        krb5_set_error_message((krb5_context)a1, checksum, "ContentInfo wrapping of signedData failed", v97, v98, v99);
                        goto LABEL_116;
                      }
                      v67 = *(_DWORD *)(a2 + 48);
                      if (v67 != 2)
                      {
                        if (v67 == 1)
                        {
                          v113 = 0uLL;
                          *(_QWORD *)&v114 = 0;
                          v112 = *(_OWORD *)v106;
                          v106[0] = (void *)sub_2096BCA28();
                          v106[1] = malloc_type_malloc((size_t)v106[0], 0xADFB73B4uLL);
                          if (v106[1])
                          {
                            checksum = sub_2096BCA08();
                            if ((_DWORD)checksum)
                            {
                              free(v106[1]);
                              v106[1] = 0;
                            }
                          }
                          else
                          {
                            checksum = 12;
                          }
                          sub_2096BCA38();
                          v82 = 15;
LABEL_79:
                          if ((_DWORD)checksum)
                          {
                            krb5_set_error_message((krb5_context)a1, checksum, "PA-PK-AS-REQ %d");
                            goto LABEL_116;
                          }
                          if (v106[0] == v107)
                          {
                            checksum = krb5_padata_add((_krb5_context *)a1, a7, v82, (uint64_t)v106[1], (uint64_t)v106[0]);
                            if ((_DWORD)checksum)
                              free(v106[1]);
                            else
                              krb5_padata_add((_krb5_context *)a1, a7, 132, 0, 0);
                            goto LABEL_116;
                          }
LABEL_123:
                          krb5_abortx((_krb5_context *)a1, "Internal ASN1 encoder error");
                        }
LABEL_91:
                        krb5_abortx((_krb5_context *)a1, "internal pkinit error");
                      }
                      v113 = 0uLL;
                      v112 = *(_OWORD *)v106;
                      if ((*(_BYTE *)(a2 + 52) & 0x10) == 0)
                      {
LABEL_52:
                        *((_QWORD *)&v113 + 1) = 0;
                        v106[0] = (void *)sub_2096BC878();
                        v106[1] = malloc_type_malloc((size_t)v106[0], 0x89AD289FuLL);
                        if (v106[1])
                        {
                          checksum = sub_2096BC858();
                          if ((_DWORD)checksum)
                          {
                            free(v106[1]);
                            v106[1] = 0;
                          }
                        }
                        else
                        {
                          checksum = 12;
                        }
                        sub_2096BC888();
                        v82 = 16;
                        goto LABEL_79;
                      }
                      v76 = malloc_type_calloc(1uLL, 0x10uLL, 0x1020040D5A9D86FuLL);
                      *(_QWORD *)&v113 = v76;
                      if (v76)
                      {
                        v81 = hx509_certs_iter_f(a1[47], *(_QWORD *)(*(_QWORD *)a2 + 24), (uint64_t (*)(uint64_t, uint64_t))sub_2096A4AA4, (uint64_t)v76, v77, v78, v79, v80);
                        if (!(_DWORD)v81)
                          goto LABEL_52;
                        checksum = v81;
                        krb5_set_error_message((krb5_context)a1, v81, "pk-init: failed to build trustedCertifiers");
                      }
                      else
                      {
                        checksum = 12;
                        krb5_set_error_message((krb5_context)a1, 12, "malloc: out of memory");
                      }
                      sub_2096BC888();
                      goto LABEL_116;
                    }
LABEL_122:
                    krb5_abortx((_krb5_context *)a1, "internal ASN1 encoder error");
                  }
                  checksum = v94;
                  free(v106[1]);
                  v106[1] = 0;
                }
                else
                {
                  checksum = 12;
                }
                sub_2096BC8C8();
                krb5_set_error_message((krb5_context)a1, checksum, "Failed encoding AuthPack: %d", checksum);
                goto LABEL_116;
              }
              goto LABEL_115;
            }
            v119 = length_DHPublicKey();
            v120 = malloc_type_malloc(v119, 0x8C3932C9uLL);
            if (!v120)
            {
              checksum = 12;
              goto LABEL_105;
            }
            v87 = encode_DHPublicKey();
            if ((_DWORD)v87)
            {
              checksum = v87;
              free(v120);
              v120 = 0;
LABEL_105:
              der_free_heim_integer();
              goto LABEL_110;
            }
            der_free_heim_integer();
            if (v118 != v119)
              krb5_abortx((_krb5_context *)a1, "asn1 internal error");
            v88 = v103;
            v89 = v120;
            *(_QWORD *)(v103 + 24) = 8 * v118;
            *(_QWORD *)(v88 + 32) = v89;
            goto LABEL_108;
          }
        }
        else
        {
          krb5_clear_error_message((krb5_context)a1);
        }
LABEL_89:
        checksum = 12;
        goto LABEL_110;
      }
      v68 = "pkinit: failed to generate DH key";
    }
    else
    {
      v68 = "malloc: out of memory";
    }
    checksum = 12;
    krb5_set_error_message((krb5_context)a1, 12, v68, v96, "pkinit_dh_min_bits", 0, 0, *(_QWORD *)v100, *(_QWORD *)&v100[2], v101, v102, v103, v104[0], v104[1]);
    goto LABEL_110;
  }
  checksum = 2314790721;
  krb5_set_error_message((krb5_context)a1, -1980176575, "PKINIT: No user certificate given");
  return checksum;
}

uint64_t sub_2096A2988(uint64_t *a1, char *a2, uint64_t a3, int a4, uint64_t a5, int a6, uint64_t a7, _DWORD *a8, void **a9)
{
  int v15;
  uint64_t v17;
  uint64_t v18;
  const char *v19;
  uint64_t v20;
  _krb5_context *v21;
  krb5_error_code v22;
  uint64_t v23;
  uint64_t v25;
  uint64_t v26;
  _QWORD v27[2];
  uint64_t v28;
  uint64_t v29;
  __int128 v30;
  _OWORD v31[2];
  uint64_t v32;
  uint64_t v33;

  v33 = 0;
  v15 = *(_DWORD *)(a3 + 48);
  if (v15 != 1)
  {
    if (v15 == 2)
    {
      v32 = 0;
      memset(v31, 0, sizeof(v31));
      v28 = 0;
      v29 = 0;
      v27[0] = 0;
      v27[1] = 0;
      if (*a8 == 17)
      {
        v17 = sub_2096BC938();
        if ((_DWORD)v17)
        {
          v18 = v17;
          v19 = "Failed to decode pkinit AS rep";
LABEL_22:
          v21 = (_krb5_context *)a1;
          v22 = v18;
          goto LABEL_23;
        }
        if (LODWORD(v31[0]) == 2)
        {
          sub_20969D1E8((uint64_t)a1, 5, "krb5_get_init_creds: using kinit enc reply key");
          goto LABEL_19;
        }
        if (LODWORD(v31[0]) == 1)
        {
          sub_20969D1E8((uint64_t)a1, 5, "krb5_get_init_creds: using pkinit dh");
LABEL_19:
          v30 = *(_OWORD *)((char *)v31 + 8);
          v23 = hx509_cms_unwrap_ContentInfo((uint64_t)&v30, v27, &v28, 0);
          if ((_DWORD)v23)
          {
            v18 = v23;
            sub_2096BC958();
            goto LABEL_21;
          }
          if (LODWORD(v31[0]) == 2)
          {
            v25 = sub_2096A30FC(a1, 2, &v28, (uint64_t)v27, a2, (_DWORD *)a3, a5, a6, a7, a9);
          }
          else
          {
            if (LODWORD(v31[0]) != 1)
              krb5_abortx((_krb5_context *)a1, "pk-init as-rep case not possible to happen");
            v25 = sub_2096A2CE8((_krb5_context *)a1, &v28, (uint64_t)v27, a2, a3, a4, a5, *(_QWORD *)(a3 + 24), *((uint64_t *)&v31[1] + 1), a6, a9);
          }
          v18 = v25;
          der_free_octet_string();
          der_free_oid();
          sub_2096BC958();
          return v18;
        }
        sub_2096BC958();
        v32 = 0;
        memset(v31, 0, sizeof(v31));
        sub_20969D1E8((uint64_t)a1, 5, "krb5_get_init_creds: using BTMM kinit enc reply key");
        if (sub_2096BCAA8())
        {
          v19 = "PKINIT: -27 reply invalid content type";
        }
        else
        {
          sub_2096BCAC8();
          v19 = "DH mode not supported for BTMM mode";
        }
      }
      else
      {
        v19 = "PKINIT: wrong padata recv";
      }
    }
    else
    {
      v19 = "PKINIT: unknown reply type";
    }
LABEL_17:
    v18 = 22;
    v21 = (_krb5_context *)a1;
    v22 = 22;
LABEL_23:
    krb5_set_error_message(v21, v22, v19, v26);
    return v18;
  }
  memset(v31, 0, 24);
  v20 = sub_2096BCA48();
  if ((_DWORD)v20)
  {
    v18 = v20;
    v26 = v20;
    v19 = "PKINIT: Failed decoding windows pkinit reply %d";
    goto LABEL_22;
  }
  krb5_clear_error_message((krb5_context)a1);
  if (LODWORD(v31[0]) != 2)
  {
    sub_2096BCA68();
    v19 = "PKINIT: win2k reply invalid content type";
    goto LABEL_17;
  }
  v30 = 0uLL;
  v28 = 0;
  v29 = 0;
  v18 = hx509_cms_unwrap_ContentInfo((uint64_t)v31 + 8, &v28, &v30, 0);
  sub_2096BCA68();
  if ((_DWORD)v18)
  {
LABEL_21:
    v19 = "PKINIT: failed to unwrap CI";
    goto LABEL_22;
  }
  v18 = sub_2096A30FC(a1, 1, (uint64_t *)&v30, (uint64_t)&v28, a2, (_DWORD *)a3, a5, a6, a7, a9);
  der_free_octet_string();
  der_free_oid();
  return v18;
}

uint64_t sub_2096A2CE8(_krb5_context *a1, uint64_t *a2, uint64_t a3, char *a4, uint64_t a5, int a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, void **a11)
{
  uint64_t v18;
  uint64_t v19;
  const char *v20;
  uint64_t v21;
  _krb5_context *v22;
  krb5_error_code v23;
  uint64_t v25;
  _QWORD *v26;
  char *v27;
  uint64_t v28;
  char *v29;
  int v30;
  unsigned int v31;
  size_t v32;
  void *v33;
  const void *v34;
  uint64_t v35;
  uint64_t v36;
  size_t v37;
  size_t v38;
  uint64_t v39;
  _QWORD v40[2];
  __int128 v41;
  __int128 v42;
  uint64_t v43;

  v43 = 0;
  v40[0] = 0;
  v40[1] = 0;
  v38 = 0;
  v39 = 0;
  v37 = 0;
  krb5_data_zero(&v38);
  v41 = 0u;
  v42 = 0u;
  if (der_heim_oid_cmp())
  {
    v18 = 22;
    krb5_set_error_message(a1, 22, "PKINIT: Invalid content type");
    return v18;
  }
  v18 = sub_2096A4CF4((uint64_t *)a1, a2[1], *a2, *(_QWORD *)a5, v40, &v38, &v43);
  v19 = v43;
  if (!(_DWORD)v18)
  {
    v18 = sub_2096A4DFC(a1, a4, a7, a5, v43);
    if (!(_DWORD)v18)
    {
      if (der_heim_oid_cmp())
      {
        v18 = 2529638952;
        v20 = "pkinit - dh reply contains wrong oid";
LABEL_15:
        v22 = a1;
        v23 = v18;
LABEL_16:
        krb5_set_error_message(v22, v23, v20, v34, v35, v36, v37);
        goto LABEL_17;
      }
      v21 = sub_2096BC968();
      if ((_DWORD)v21)
      {
        v18 = v21;
        v20 = "pkinit - failed to decode KDC DH Key Info";
        goto LABEL_15;
      }
      if ((_DWORD)v42 != a10)
      {
        v18 = 2529638953;
        v20 = "PKINIT: DH nonce is wrong";
        goto LABEL_15;
      }
      if (*((_QWORD *)&v42 + 1))
      {
        if (!a9)
        {
          v18 = 2529638972;
          v20 = "pkinit; got key expiration without server nonce";
          goto LABEL_24;
        }
        if (!a8)
        {
          v18 = 2529638972;
          v20 = "pkinit; got DH reuse but no client nonce";
LABEL_24:
          v22 = a1;
          v23 = -1765328324;
          goto LABEL_16;
        }
      }
      else
      {
        if (a9)
        {
          v18 = 2529638972;
          v20 = "pkinit: got server nonce without key expiration";
          goto LABEL_24;
        }
        a8 = 0;
      }
      v37 = (unint64_t)(v41 + 7) >> 3;
      if (*(_DWORD *)(a5 + 8) != 1)
      {
        v18 = 22;
        goto LABEL_17;
      }
      v34 = 0;
      v35 = 0;
      v36 = 0;
      v25 = decode_DHPublicKey();
      if ((_DWORD)v25)
      {
        v18 = v25;
        v20 = "pkinit: can't decode without key expiration";
        goto LABEL_15;
      }
      v26 = sub_2096A4A2C(a1, "DHPublicKey", &v34);
      sub_2096D23AC();
      if (!v26)
      {
        v18 = 12;
        goto LABEL_17;
      }
      v37 = (int)sub_2096D46F0(*(_QWORD *)(a5 + 16));
      v27 = (char *)malloc_type_malloc(v37, 0xDEBD8B32uLL);
      if (!v27)
      {
        v18 = 12;
        krb5_set_error_message(a1, 12, "malloc: out of memory", v34, v35, v36);
        sub_2096D4104(v26);
        goto LABEL_17;
      }
      v28 = *(_QWORD *)(a5 + 16);
      v29 = v27;
      v30 = sub_2096D4874((uint64_t)v27, v26, v28);
      if (v30 < 1 || v30 < v37 >> 1)
      {
        v18 = 2529638972;
        krb5_set_error_message(a1, -1765328324, "PKINIT: Can't compute Diffie-Hellman key", v34, v35, v36);
LABEL_35:
        v31 = 0;
LABEL_36:
        sub_2096D4104(v26);
        bzero(v29, v31);
        free(v29);
        goto LABEL_17;
      }
      if (v30 >= (int)v37)
      {
        v31 = v30;
      }
      else
      {
        v32 = v37 - v30;
        memmove(&v29[v32], v29, v30);
        bzero(v29, v32);
        v31 = v37;
        if ((int)v37 <= 0)
        {
          v18 = 22;
          krb5_set_error_message(a1, 22, "PKINIT: resulting DH key <= 0", v34, v35, v36);
          goto LABEL_35;
        }
      }
      v33 = malloc_type_malloc(0x18uLL, 0x10800404ACF7207uLL);
      *a11 = v33;
      if (v33)
      {
        v18 = _krb5_pk_octetstring2key(a1, a6, (uint64_t)v29, v31, a8, a9, (uint64_t)v33);
        if ((_DWORD)v18)
        {
          krb5_set_error_message(a1, v18, "PKINIT: can't create key from DH key", v34, v35, v36);
          free(*a11);
          *a11 = 0;
        }
      }
      else
      {
        v18 = 12;
        krb5_set_error_message(a1, 12, "malloc: out of memory", v34, v35, v36);
      }
      goto LABEL_36;
    }
  }
LABEL_17:
  hx509_cert_free(v19);
  if (v39)
    krb5_data_free(&v38);
  der_free_oid();
  sub_2096BC988();
  return v18;
}

uint64_t sub_2096A30FC(uint64_t *a1, int a2, uint64_t *a3, uint64_t a4, char *a5, _DWORD *a6, uint64_t a7, int a8, uint64_t a9, void **a10)
{
  uint64_t v17;
  char v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  size_t v27;
  const void *v28;
  _QWORD v29[2];
  _QWORD v30[2];
  size_t v31;
  void *v32;
  uint64_t v33;

  v33 = 0;
  v30[0] = 0;
  v30[1] = 0;
  if (!der_heim_oid_cmp())
  {
    v31 = 0;
    v32 = 0;
    if (a6[12] == 1)
      v18 = 3;
    else
      v18 = 1;
    v19 = hx509_cms_unenvelope(a1[47], *(_QWORD *)(*(_QWORD *)a6 + 8), v18, a3[1], *a3, 0, 0, v30, &v31);
    if ((_DWORD)v19)
    {
      v17 = v19;
      sub_2096A1BCC(a1, v19, "Failed to unenvelope CMS data in PK-INIT reply");
      return v17;
    }
    der_free_oid();
    if (a2 == 1)
    {
      v29[0] = 0;
      v29[1] = 0;
      v27 = 0;
      v28 = 0;
      if (hx509_cms_unwrap_ContentInfo((uint64_t)&v31, v29, &v27, 0))
      {
        v20 = der_length_len() + 1;
        v21 = (char *)malloc_type_malloc(v31 + v20, 0xB6CF9422uLL);
        memcpy(&v21[v20], v32, v31);
        v22 = der_put_length_and_tag();
        if ((_DWORD)v22)
          return v22;
        free(v32);
        v31 += v20;
        v32 = v21;
        v23 = hx509_cms_unwrap_ContentInfo((uint64_t)&v31, v29, &v27, 0);
        if ((_DWORD)v23)
        {
          v17 = v23;
LABEL_18:
          v24 = 0;
          goto LABEL_22;
        }
      }
      if (der_heim_oid_cmp())
      {
        v17 = 22;
        krb5_set_error_message((krb5_context)a1, 22, "PKINIT: Invalid content type");
        der_free_oid();
        der_free_octet_string();
        goto LABEL_18;
      }
      der_free_oid();
      krb5_data_free(&v31);
      v17 = krb5_data_copy(&v31, v28, v27);
      der_free_octet_string();
      if ((_DWORD)v17)
      {
        krb5_set_error_message((krb5_context)a1, v17, "malloc: out of memory");
        goto LABEL_18;
      }
    }
    v25 = sub_2096A4CF4(a1, (uint64_t)v32, v31, *(_QWORD *)a6, v30, &v31, &v33);
    v24 = v33;
    if (!(_DWORD)v25)
    {
      v25 = sub_2096A4DFC((_krb5_context *)a1, a5, a7, (uint64_t)a6, v33);
      if (!(_DWORD)v25)
      {
        if (a2 == 2)
        {
          v25 = sub_2096A4F40((_krb5_context *)a1, (uint64_t)&v31, a9, a10);
        }
        else
        {
          if (a2 != 1)
          {
            v17 = 0;
            goto LABEL_22;
          }
          v17 = sub_2096A4F40((_krb5_context *)a1, (uint64_t)&v31, a9, a10);
          if (!(_DWORD)v17 || (a6[13] & 1) != 0)
            goto LABEL_22;
          v25 = sub_2096A50D8((_krb5_context *)a1, (uint64_t)&v31, a8, a10);
        }
      }
    }
    v17 = v25;
LABEL_22:
    hx509_cert_free(v24);
    der_free_oid();
    krb5_data_free(&v31);
    return v17;
  }
  v17 = 22;
  krb5_set_error_message((krb5_context)a1, 22, "PKINIT: Invalid content type");
  return v17;
}

uint64_t sub_2096A3404(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t subject;
  uint64_t serialnumber;
  void **v16;
  void *v18;
  void *v19;
  void *v20;

  v6 = *(_QWORD *)(*a2 + 16);
  if (v6)
    hx509_cert_free(v6);
  v7 = hx509_cert_ref(a3);
  v8 = *a2;
  *(_QWORD *)(v8 + 16) = v7;
  if (*(_QWORD *)(v8 + 8))
  {
    hx509_certs_free((const void **)(v8 + 8));
    v8 = *a2;
    v7 = *(_QWORD *)(*a2 + 16);
  }
  if (!v7)
    return 0;
  subject = hx509_certs_init(*(_QWORD *)(a1 + 376), "MEMORY:pkinit-set-user-id", 0, 0, (_QWORD *)(v8 + 8));
  if ((_DWORD)subject)
    return subject;
  hx509_certs_add(*(_QWORD *)(a1 + 376), *(_QWORD *)(*a2 + 8), a3, v9, v10, v11, v12, v13);
  if (!*(_QWORD *)(*a2 + 16) || !_krb5_have_debug(a1))
    return 0;
  v20 = 0;
  v19 = 0;
  subject = hx509_cert_get_subject(*(_QWORD *)(*a2 + 16), &v20);
  if (!(_DWORD)subject)
  {
    subject = hx509_name_to_string(v20, &v19);
    hx509_name_free(&v20);
    if (!(_DWORD)subject)
    {
      serialnumber = hx509_cert_get_serialnumber();
      if ((_DWORD)serialnumber)
      {
        subject = serialnumber;
        v16 = &v19;
      }
      else
      {
        subject = der_print_hex_heim_integer();
        der_free_heim_integer();
        if (!(_DWORD)subject)
        {
          sub_20969D1E8(a1, 2, "using cert: subject: %s sn: %s", (const char *)v19, 0);
          free(v19);
          v18 = 0;
          goto LABEL_18;
        }
        v16 = &v20;
      }
      v18 = *v16;
LABEL_18:
      free(v18);
    }
  }
  return subject;
}

uint64_t _krb5_pk_load_id(uint64_t *a1, _QWORD *a2, char *a3, char *a4, char **a5, char **a6, uint64_t a7, uint64_t a8, char *__s1)
{
  _QWORD *v17;
  _QWORD *v18;
  uint64_t v19;
  uint64_t inited;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  char *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  char **v30;
  char *v31;
  uint64_t v32;
  uint64_t v33;
  char *v35;
  char **v36;
  uint64_t v37;
  char *v38;
  int v39[2];
  uint64_t *v40;
  uint64_t v41;
  uint64_t v42;

  *a2 = 0;
  if (a4)
  {
    v17 = malloc_type_calloc(1uLL, 0x38uLL, 0x1020040DD5A6BABuLL);
    if (v17)
    {
      v18 = v17;
      v40 = 0;
      v41 = 0;
      v42 = 0;
      if (a3)
      {
        *(_QWORD *)v39 = 0;
        v19 = hx509_lock_init(a1[47], v39);
        if ((_DWORD)v19)
        {
          inited = v19;
          sub_2096A1BCC(a1, v19, "Failed init lock");
          goto LABEL_33;
        }
        if (__s1 && *__s1)
          hx509_lock_add_password(*(uint64_t **)v39, __s1);
        if (a7)
        {
          v40 = a1;
          v41 = a7;
          v42 = a8;
          v22 = hx509_lock_set_prompter(*(uint64_t *)v39, (uint64_t)sub_2096A38A0, (uint64_t)&v40);
          if ((_DWORD)v22)
          {
            inited = v22;
            hx509_lock_free(*(const void ***)v39);
            goto LABEL_33;
          }
        }
        inited = hx509_certs_init(a1[47], a3, 0, *(uint64_t *)v39, v18 + 1);
        hx509_lock_free(*(const void ***)v39);
        if ((_DWORD)inited)
        {
          sub_2096A1BCC(a1, inited, "Failed to init cert certs");
          goto LABEL_33;
        }
      }
      else
      {
        v17[1] = 0;
      }
      v21 = hx509_certs_init(a1[47], a4, 0, 0, v18 + 3);
      if ((_DWORD)v21)
      {
        inited = v21;
        sub_2096A1BCC(a1, v21, "Failed to init anchors");
      }
      else
      {
        v23 = hx509_certs_init(a1[47], "MEMORY:pkinit-cert-chain", 0, 0, v18 + 4);
        if (!(_DWORD)v23)
        {
          if (a5)
          {
            v25 = *a5;
            if (*a5)
            {
              v30 = a5 + 1;
              do
              {
                if (hx509_certs_append(a1[47], v18[4], 0, v25))
                  sub_20969D1E8((uint64_t)a1, 5, "Failed to load cert pool: %s", *(v30 - 1));
                v31 = *v30++;
                v25 = v31;
              }
              while (v31);
            }
          }
          v32 = a1[47];
          if (a6)
          {
            v33 = hx509_revoke_init(v32, v18 + 5, v24, (uint64_t)v25, v26, v27, v28, v29);
            if ((_DWORD)v33)
            {
              inited = v33;
              sub_2096A1BCC(a1, v33, "Failed init revoke list");
              goto LABEL_33;
            }
            v35 = *a6;
            if (*a6)
            {
              v36 = a6 + 1;
              while (1)
              {
                v37 = hx509_revoke_add_crl(a1[47], v18[5], v35);
                if ((_DWORD)v37)
                  break;
                v38 = *v36++;
                v35 = v38;
                if (!v38)
                  goto LABEL_31;
              }
              inited = v37;
              sub_2096A1BCC(a1, v37, "Failed load revoke list");
              goto LABEL_33;
            }
          }
          else
          {
            hx509_context_set_missing_revoke(v32, 1);
          }
LABEL_31:
          inited = hx509_verify_init_ctx(a1[47], v18);
          if (!(_DWORD)inited)
          {
            hx509_verify_attach_anchors((const void **)*v18, (CFTypeRef)v18[3]);
            hx509_verify_attach_revoke(*v18, (CFTypeRef)v18[5]);
            *a2 = v18;
            return inited;
          }
          sub_2096A1BCC(a1, inited, "Failed init verify context");
          goto LABEL_33;
        }
        inited = v23;
        sub_2096A1BCC(a1, v23, "Failed to init chain");
      }
LABEL_33:
      hx509_verify_destroy_ctx((const void **)*v18);
      hx509_certs_free((const void **)v18 + 1);
      hx509_certs_free((const void **)v18 + 3);
      hx509_certs_free((const void **)v18 + 4);
      hx509_revoke_free((CFTypeRef *)v18 + 5);
      free(v18);
      return inited;
    }
    inited = 12;
    krb5_set_error_message((krb5_context)a1, 12, "malloc: out of memory");
  }
  else
  {
    inited = 2314790722;
    krb5_set_error_message((krb5_context)a1, -1980176574, "PKINIT: No anchor given");
  }
  return inited;
}

uint64_t sub_2096A38A0(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;
  int v5;
  int v6;
  uint64_t result;
  _QWORD v8[2];
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  uint64_t v12;

  v11 = 0;
  v12 = 0;
  v4 = a2[3];
  v8[0] = a2[2];
  v8[1] = v4;
  v9 = *a2;
  v10 = 0;
  LODWORD(v10) = hx509_prompt_hidden(*((_DWORD *)a2 + 2));
  v11 = v8;
  v5 = *((_DWORD *)a2 + 2);
  if ((v5 - 1) >= 2)
  {
    if (v5 != 4)
      goto LABEL_6;
    v6 = 5;
  }
  else
  {
    v6 = 1;
  }
  LODWORD(v12) = v6;
LABEL_6:
  result = (*(uint64_t (**)(_QWORD, _QWORD, _QWORD, _QWORD, uint64_t, uint64_t *))(a1 + 8))(*(_QWORD *)a1, *(_QWORD *)(a1 + 16), 0, 0, 1, &v9);
  if ((_DWORD)result)
  {
    bzero((void *)a2[3], a2[2]);
    return 1;
  }
  return result;
}

uint64_t sub_2096A3944(_krb5_context *a1, uint64_t a2, uint64_t a3, char *a4, char ***a5)
{
  char *v6;
  char **v10;
  char **v11;
  char *v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  char *v18;
  char *v19;
  char *v20;
  int v21;
  const char *v22;
  uint64_t v24;
  uint64_t v25;
  char *__stringp;

  v6 = a4;
  __stringp = a4;
  *a5 = 0;
  v10 = (char **)malloc_type_calloc(1uLL, 0x58uLL, 0x109004044CB81CDuLL);
  if (!v10)
  {
    v17 = 12;
    krb5_set_error_message(a1, 12, "malloc: out of memory");
    return v17;
  }
  v11 = v10;
  v12 = __stringp;
  v13 = MEMORY[0x24BDAC740];
  do
  {
    v14 = v12;
    v15 = *v6;
    if (*v6 < 0)
      v16 = __maskrune(*v6, 0x4000uLL);
    else
      v16 = *(_DWORD *)(v13 + 4 * v15 + 60) & 0x4000;
    v12 = ++v6;
  }
  while (v16);
  __stringp = v14;
  if ((_DWORD)v15 != 35)
  {
    v18 = strsep(&__stringp, " \t");
    if (v18)
    {
      v19 = strdup(v18);
      *v11 = v19;
      if (!v19)
      {
        v17 = 12;
        krb5_set_error_message(a1, 12, "malloc: out of memeory");
        goto LABEL_23;
      }
      v20 = strsep(&__stringp, " \t");
      if (v20)
      {
        v21 = atoi(v20);
        v11[1] = (char *)v21;
        if (v21)
        {
          v17 = sub_2096A3B88(a1, &__stringp);
          if (!(_DWORD)v17)
          {
            v17 = sub_2096A3B88(a1, &__stringp);
            if (!(_DWORD)v17)
            {
              v17 = sub_2096A3B88(a1, &__stringp);
              if (!(_DWORD)v17)
              {
                *a5 = v11;
                return v17;
              }
            }
          }
LABEL_23:
          free(*v11);
          der_free_heim_integer();
          der_free_heim_integer();
          der_free_heim_integer();
          free(v11);
          return v17;
        }
        v24 = a2;
        v25 = a3;
        v22 = "moduli file %s have un-parsable bits on line %d";
      }
      else
      {
        v24 = a2;
        v25 = a3;
        v22 = "moduli file %s missing bits on line %d";
      }
    }
    else
    {
      v24 = a2;
      v25 = a3;
      v22 = "moduli file %s missing name on line %d";
    }
    v17 = 22;
    krb5_set_error_message(a1, 22, v22, v24, v25);
    goto LABEL_23;
  }
  free(v11);
  return 0;
}

uint64_t sub_2096A3B88(_krb5_context *a1, char **__stringp)
{
  uint64_t v3;

  if (strsep(__stringp, " \t"))
  {
    v3 = der_parse_hex_heim_integer();
    if ((_DWORD)v3)
      krb5_set_error_message(a1, v3, "moduli file %s failed parsing %s on line %d");
  }
  else
  {
    v3 = 22;
    krb5_set_error_message(a1, 22, "moduli file %s missing %s on line %d");
  }
  return v3;
}

void sub_2096A3C34(void ***a1)
{
  void **v2;
  void **v3;
  void **v4;

  v2 = *a1;
  if (*a1)
  {
    v3 = (void **)a1;
    do
    {
      free(*v2);
      der_free_heim_integer();
      der_free_heim_integer();
      der_free_heim_integer();
      free(*v3);
      v4 = (void **)v3[1];
      ++v3;
      v2 = v4;
    }
    while (v4);
  }
  free(a1);
}

uint64_t _krb5_parse_moduli()
{
  uint64_t v0;
  char ****v1;
  char ****v2;
  char *v3;
  char *v4;
  _krb5_context *v5;
  char ***v6;
  char ***v7;
  uint64_t v8;
  uint64_t v9;
  FILE *v10;
  uint64_t v11;
  uint64_t v12;
  char ***v13;
  char *__filename;
  char __s[4096];
  uint64_t v17;

  v0 = MEMORY[0x24BDAC7A8]();
  v2 = v1;
  v4 = v3;
  v5 = (_krb5_context *)v0;
  v17 = *MEMORY[0x24BDAC8D0];
  *v1 = 0;
  v6 = (char ***)malloc_type_calloc(1uLL, 0x18uLL, 0x2004093837F09uLL);
  if (!v6)
    goto LABEL_19;
  v7 = v6;
  __strlcpy_chk();
  v8 = sub_2096A3944(v5, (uint64_t)"builtin", 1, __s, v7);
  if (!(_DWORD)v8)
  {
    __strlcpy_chk();
    v8 = sub_2096A3944(v5, (uint64_t)"builtin", 1, __s, v7 + 1);
    if (!(_DWORD)v8)
    {
      if (!v4)
        v4 = "/etc/krb5.moduli";
      __filename = 0;
      if (_krb5_expand_default_cc_name_0(v5, v4, (void **)&__filename)
        || (v10 = fopen(__filename, "r"), krb5_xfree(__filename), !v10)
        || (rk_cloexec_file(v10), !fgets(__s, 4096, v10)))
      {
LABEL_8:
        v9 = 0;
        *v2 = v7;
        return v9;
      }
      LODWORD(v11) = 2;
      v12 = 1;
      while (1)
      {
        __filename = 0;
        __s[strcspn(__s, "\n")] = 0;
        v13 = (char ***)malloc_type_realloc(v7, 8 * ((int)v11 + 2), 0x2004093837F09uLL);
        if (!v13)
          break;
        v7 = v13;
        v13[(int)v11] = 0;
        v8 = sub_2096A3944(v5, (uint64_t)v4, v12, __s, (char ***)&__filename);
        if ((_DWORD)v8)
          goto LABEL_4;
        if (__filename)
        {
          v7[(int)v11] = (char **)__filename;
          v11 = (int)v11 + 1;
          v7[v11] = 0;
        }
        v12 = (v12 + 1);
        if (!fgets(__s, 4096, v10))
          goto LABEL_8;
      }
      sub_2096A3C34((void ***)v7);
LABEL_19:
      v9 = 12;
      krb5_set_error_message(v5, 12, "malloc: out of memory");
      return v9;
    }
  }
LABEL_4:
  v9 = v8;
  sub_2096A3C34((void ***)v7);
  return v9;
}

uint64_t _krb5_dh_group_ok(krb5_context a1, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, const char ***a6, char **a7)
{
  const char ***v8;
  const char **v12;
  uint64_t v13;
  char *v15;

  v8 = a6;
  if (a7)
    *a7 = 0;
  if (*a6)
  {
    while (der_heim_integer_cmp()
         || der_heim_integer_cmp()
         || a5 && der_heim_integer_cmp())
    {
      v12 = v8[1];
      ++v8;
      if (!v12)
        goto LABEL_9;
    }
    if (a2 && (unint64_t)(*v8)[1] < a2)
    {
      v13 = 2529638977;
      krb5_set_error_message(a1, -1765328319, "PKINIT: DH group parameter %s no accepted, not enough bits generated");
    }
    else if (a7)
    {
      v15 = strdup(**v8);
      v13 = 0;
      *a7 = v15;
    }
    else
    {
      return 0;
    }
  }
  else
  {
LABEL_9:
    v13 = 2529638977;
    krb5_set_error_message(a1, -1765328319, "PKINIT: DH group parameter no ok");
  }
  return v13;
}

void sub_2096A402C(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  _DWORD *v4;
  krb5_data *v5;
  void ***v6;

  v1 = *(_QWORD *)(a1 + 88);
  if (v1)
  {
    v2 = *(_QWORD *)(v1 + 32);
    if (v2)
    {
      if (*(_DWORD *)(v2 + 8) == 1)
      {
        v4 = *(_DWORD **)(v2 + 16);
        if (v4)
          sub_2096D4620(v4);
      }
      if (*(_QWORD *)v2)
      {
        hx509_verify_destroy_ctx(**(const void ****)v2);
        hx509_certs_free((const void **)(*(_QWORD *)v2 + 8));
        hx509_cert_free(*(_QWORD *)(*(_QWORD *)v2 + 16));
        hx509_certs_free((const void **)(*(_QWORD *)v2 + 24));
        hx509_certs_free((const void **)(*(_QWORD *)v2 + 32));
        v5 = *(krb5_data **)(v2 + 24);
        if (v5)
        {
          krb5_free_data(0, v5);
          *(_QWORD *)(v2 + 24) = 0;
        }
        v6 = *(void ****)(v2 + 32);
        if (v6)
          sub_2096A3C34(v6);
        free(*(void **)v2);
        *(_QWORD *)v2 = 0;
      }
      free(*(void **)(*(_QWORD *)(a1 + 88) + 32));
      *(_QWORD *)(*(_QWORD *)(a1 + 88) + 32) = 0;
    }
  }
}

uint64_t _krb5_get_init_creds_opt_set_pkinit_user_cert(uint64_t *a1, uint64_t a2, uint64_t a3, char *a4, char *a5, char **strings, char **a7, char a8, uint64_t a9, uint64_t a10, char *__s1)
{
  return krb5_get_init_creds_opt_set_pkinit(a1, a2, a3, a4, a5, strings, a7, a8, a9, a10, __s1);
}

uint64_t krb5_get_init_creds_opt_set_pkinit(uint64_t *a1, uint64_t a2, uint64_t a3, char *a4, char *a5, char **strings, char **a7, char a8, uint64_t a9, uint64_t a10, char *__s1)
{
  _BYTE *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  const krb5_data *realm;
  uint64_t v27;
  uint64_t id;
  uint64_t v29;
  const char *v30;
  _krb5_context *v31;
  krb5_error_code v32;
  uint64_t v34;
  _BOOL4 is_lkdc;
  uint64_t v36;
  uint64_t *v37;
  const void *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  int alloc;
  int cert;
  uint64_t v49;
  _DWORD *v50;
  uint64_t v51;
  _DWORD *v52;
  void *v53[3];
  char *ret_value;
  uint64_t v55;

  ret_value = 0;
  if (!*(_QWORD *)(a2 + 88))
  {
    v30 = "PKINIT: on non extendable opt";
LABEL_16:
    v29 = 22;
    v31 = (_krb5_context *)a1;
    v32 = 22;
LABEL_18:
    krb5_set_error_message(v31, v32, v30);
    return v29;
  }
  v19 = malloc_type_calloc(1uLL, 0x38uLL, 0x10A004070047ECAuLL);
  *(_QWORD *)(*(_QWORD *)(a2 + 88) + 32) = v19;
  if (!v19)
  {
    v30 = "malloc: out of memory";
    v29 = 12;
    v31 = (_krb5_context *)a1;
    v32 = 12;
    goto LABEL_18;
  }
  v19[52] &= ~1u;
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a2 + 88) + 32) + 52) |= 2u;
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a2 + 88) + 32) + 52) |= 4u;
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 88) + 32) + 40) = 0;
  if (!strings)
    strings = (char **)krb5_config_get_strings((uint64_t)a1, 0, v20, v21, v22, v23, v24, v25, (uint64_t)"appdefaults");
  if (!strings)
    strings = &off_2545A4DF0;
  if (!a7)
    a7 = (char **)krb5_config_get_strings((uint64_t)a1, 0, v20, v21, v22, v23, v24, v25, (uint64_t)"appdefaults");
  if (!a5)
  {
    realm = (const krb5_data *)krb5_principal_get_realm((uint64_t)a1, a3);
    krb5_appdefault_string((krb5_context)a1, "kinit", realm, "pkinit_anchors", 0, &ret_value);
    a5 = ret_value;
  }
  v27 = *(_QWORD *)(a2 + 88);
  if ((a8 & 4) != 0)
  {
    *(_BYTE *)(*(_QWORD *)(v27 + 32) + 52) |= 0x20u;
    v27 = *(_QWORD *)(a2 + 88);
  }
  id = _krb5_pk_load_id(a1, *(_QWORD **)(v27 + 32), a4, a5, strings, a7, a9, a10, __s1);
  if ((_DWORD)id)
  {
    v29 = id;
    free(*(void **)(*(_QWORD *)(a2 + 88) + 32));
    *(_QWORD *)(*(_QWORD *)(a2 + 88) + 32) = 0;
    return v29;
  }
  if ((a8 & 8) != 0)
  {
    v34 = **(_QWORD **)(*(_QWORD *)(a2 + 88) + 32);
    *(_DWORD *)(v34 + 48) |= 1u;
  }
  if (a3)
  {
    is_lkdc = krb5_principal_is_lkdc((uint64_t)a1, a3);
    v36 = *(_QWORD *)(a2 + 88);
    if (is_lkdc)
      *(_DWORD *)(**(_QWORD **)(v36 + 32) + 48) |= 1u;
  }
  else
  {
    v36 = *(_QWORD *)(a2 + 88);
  }
  v37 = *(uint64_t **)(v36 + 32);
  v38 = *(const void **)(*v37 + 8);
  if (v38)
  {
    v44 = j__heim_retain(v38);
    v53[0] = 0;
    v55 = 0;
    v45 = *v37;
    if (*(_QWORD *)(*v37 + 8))
    {
      hx509_certs_free((const void **)(*v37 + 8));
      v45 = *v37;
    }
    v46 = *(_QWORD *)(v45 + 16);
    if (v46)
    {
      hx509_cert_free(v46);
      v45 = *v37;
      *(_QWORD *)(*v37 + 16) = 0;
    }
    hx509_certs_merge(a1[47], *(_QWORD *)(v45 + 32), v44, v39, v40, v41, v42, v43);
    *(_QWORD *)(*v37 + 8) = v44;
    *((_BYTE *)v37 + 52) &= ~0x20u;
    alloc = hx509_query_alloc(a1[47], v53);
    if (alloc)
    {
      sub_2096A1BCC(a1, alloc, "Allocate query to find signing certificate");
    }
    else
    {
      hx509_query_match_option((_DWORD *)v53[0], 1);
      hx509_query_match_option((_DWORD *)v53[0], 3);
      cert = _krb5_pk_find_cert(a1, *(_DWORD *)(*v37 + 48) & 1, *(_QWORD *)(*v37 + 8), (int *)v53[0], &v55);
      hx509_query_free(a1[47], (void **)v53[0]);
      if (!cert)
      {
        sub_2096A3404((uint64_t)a1, v37, v55);
        hx509_cert_free(v55);
      }
    }
  }
  else
  {
    *(_QWORD *)(*v37 + 16) = 0;
  }
  if ((a8 & 2) != 0)
  {
    v29 = 0;
    v52 = *(_DWORD **)(*(_QWORD *)(a2 + 88) + 32);
    v52[2] = 0;
    if (*(_QWORD *)(*(_QWORD *)v52 + 8))
      return v29;
    v30 = "No anonymous pkinit support in RSA mode";
    goto LABEL_16;
  }
  v49 = a1[47];
  v50 = *(_DWORD **)(*(_QWORD *)(a2 + 88) + 32);
  v51 = *(_QWORD *)(*(_QWORD *)v50 + 16);
  v50[2] = 1;
  if (v51)
  {
    memset(v53, 0, sizeof(v53));
    if (!sub_2096BFD84(v49))
    {
      if (!der_heim_oid_cmp())
        *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 88) + 32) + 8) = 2;
      free_AlgorithmIdentifier();
    }
  }
  return 0;
}

uint64_t krb5_get_init_creds_opt_set_pkinit_user_cert(_krb5_context *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  const char *v6;

  v3 = *(_QWORD *)(a2 + 88);
  if (!v3)
  {
    v6 = "PKINIT: on non extendable opt";
LABEL_6:
    v5 = 22;
    krb5_set_error_message(a1, 22, v6);
    return v5;
  }
  v4 = *(uint64_t **)(v3 + 32);
  if (!v4)
  {
    v6 = "PKINIT: on pkinit context";
    goto LABEL_6;
  }
  sub_2096A3404((uint64_t)a1, v4, a3);
  return 0;
}

uint64_t krb5_pk_enterprise_cert(uint64_t *a1, char *a2, char *a3, _DWORD **a4, _QWORD *a5)
{
  int v9;
  int v10;
  char *v11;
  uint64_t v12;
  krb5_error_code v13;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  int one_cert;
  int v21;
  int principal;
  void *v23;
  void *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;

  v25 = 0;
  *a4 = 0;
  if (a5)
    *a5 = 0;
  if (a2)
  {
    v26 = 0;
    v27 = 0;
    v23 = 0;
    v24 = 0;
    v9 = hx509_certs_init(a1[47], a2, 0, 0, &v27);
    if (v9)
    {
      v10 = v9;
      v11 = "Failed to init cert certs";
LABEL_6:
      sub_2096A1BCC(a1, v10, v11);
      goto LABEL_11;
    }
    v13 = hx509_query_alloc(a1[47], &v24);
    if (v13)
    {
      krb5_set_error_message((krb5_context)a1, v13, "out of memory");
      hx509_certs_free((const void **)&v27);
      goto LABEL_11;
    }
    hx509_query_match_option(v24, 1);
    hx509_query_match_option(v24, 3);
    hx509_query_match_eku((uint64_t)v24, (uint64_t)&unk_24C1F57A0);
    hx509_query_match_cmp_func((uint64_t)v24, (uint64_t)sub_2096A478C, 0);
    v12 = hx509_certs_filter(a1[47], v27, (int *)v24, &v26);
    hx509_query_free(a1[47], (void **)v24);
    hx509_certs_free((const void **)&v27);
    if ((_DWORD)v12)
    {
      sub_2096A1BCC(a1, v12, "Failed to find PKINIT certificate");
      return v12;
    }
    one_cert = hx509_get_one_cert(a1[47], v26, &v25, v15, v16, v17, v18, v19);
    hx509_certs_free((const void **)&v26);
    if (one_cert)
    {
      sub_2096A1BCC(a1, one_cert, "Failed to get one cert");
      goto LABEL_11;
    }
    v21 = sub_2096A47CC(a1[47], v25, &v23);
    if (v21)
    {
      v10 = v21;
      v11 = "Failed to get MS SAN";
      goto LABEL_6;
    }
    principal = krb5_make_principal((krb5_context)a1, a4, a3, v23, 0);
    free(v23);
    if (principal)
    {
LABEL_11:
      v12 = 2529638983;
      hx509_cert_free(v25);
      krb5_set_error_message((krb5_context)a1, -1765328313, "PK-INIT cert didn't contain principal SAN");
      return v12;
    }
    krb5_principal_set_type((uint64_t)a1, *a4, 10);
    if (a5)
      *a5 = hx509_cert_ref(v25);
    hx509_cert_free(v25);
    return 0;
  }
  else
  {
    v12 = 2;
    krb5_set_error_message((krb5_context)a1, 2, "no user id");
  }
  return v12;
}

uint64_t sub_2096A478C(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  void *v4;

  v4 = 0;
  v2 = sub_2096A47CC(a1, a2, &v4);
  if (!(_DWORD)v2)
    free(v4);
  return v2;
}

uint64_t sub_2096A47CC(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  uint64_t v3;
  uint64_t v5;
  _QWORD *v6;

  v5 = 0;
  v6 = 0;
  *a3 = 0;
  if (hx509_cert_find_subjectAltName_otherName(a1, a2, (uint64_t)&unk_24C1F57B0, (uint64_t)&v5))
    return 0;
  if (v5 && *v6)
    v3 = sub_2096BC828();
  else
    v3 = 1;
  hx509_free_octet_string_list((uint64_t)&v5);
  return v3;
}

uint64_t _krb5_pk_match_cert(uint64_t *a1, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t subjectAltName_otherName;
  uint64_t v8;
  unsigned int v9;
  uint64_t v10;
  _BOOL4 v11;
  unint64_t v12;
  char *__s1[2];
  __int128 v15;
  _QWORD v16[2];

  v16[0] = 0;
  v16[1] = 0;
  subjectAltName_otherName = hx509_cert_find_subjectAltName_otherName(a1[47], a3, (uint64_t)&xmmword_24C1F5790, (uint64_t)v16);
  if ((_DWORD)subjectAltName_otherName)
  {
    v8 = subjectAltName_otherName;
    krb5_set_error_message((krb5_context)a1, subjectAltName_otherName, "Failed to find the PK-INIT subjectAltName in the certificate");
  }
  else
  {
    if (v16[0])
    {
      v9 = 1;
      do
      {
        *(_OWORD *)__s1 = 0u;
        v15 = 0u;
        v10 = sub_2096BC8D8();
        if ((_DWORD)v10)
        {
          v8 = v10;
          krb5_set_error_message((krb5_context)a1, v10, "Failed to decode the PK-INIT subjectAltName in the KDC certificate", __s1[0]);
          goto LABEL_16;
        }
        v11 = !sub_2096A6B94((uint64_t)a1, a2, (uint64_t)&__s1[1])
           || a4 && strcmp(__s1[0], *(const char **)(a2 + 24));
        sub_2096BC928();
        if (!v11)
          break;
        v12 = v9++;
      }
      while (v16[0] > v12);
      if (v11)
        goto LABEL_14;
      v8 = 0;
    }
    else
    {
LABEL_14:
      v8 = 2529638983;
      krb5_set_error_message((krb5_context)a1, -1765328313, "PK-INIT cert didn't contain principal SAN", __s1[0]);
    }
LABEL_16:
    hx509_free_octet_string_list((uint64_t)v16);
  }
  return v8;
}

uint64_t sub_2096A49AC(_krb5_context *a1, unsigned int *a2, uint64_t a3)
{
  int v6;
  void *v7;
  _BOOL4 v8;
  uint64_t result;

  v6 = sub_2096D41F8(a2);
  *(_QWORD *)a3 = v6;
  v7 = malloc_type_malloc(v6, 0x1932B0D9uLL);
  *(_QWORD *)(a3 + 8) = v7;
  if (v7)
  {
    sub_2096D42C8((const void **)a2, v7);
    v8 = sub_2096D430C((uint64_t)a2);
    result = 0;
    *(_DWORD *)(a3 + 16) = v8;
  }
  else
  {
    krb5_clear_error_message(a1);
    return 12;
  }
  return result;
}

_QWORD *sub_2096A4A2C(_krb5_context *a1, const char *a2, const void **a3)
{
  _QWORD *v6;
  _QWORD *v7;

  v6 = sub_2096D4200(a3[1], *(unsigned int *)a3, 0);
  v7 = v6;
  if (v6)
    sub_2096D42F8((uint64_t)v6, *((_DWORD *)a3 + 4));
  else
    krb5_set_error_message(a1, 12, "PKINIT: parsing BN failed %s", a2);
  return v7;
}

uint64_t sub_2096A4AA4(uint64_t a1, unsigned int *a2, uint64_t a3)
{
  uint64_t subject;
  void *v6;
  uint64_t v7;
  size_t v9;
  void *v10;
  uint64_t v11;
  char *v12;
  char *v13;
  __int128 v14;
  void *v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  uint64_t v20;
  __int128 v21;
  uint64_t v22;

  v20 = 0;
  if (*a2 <= 0xA)
  {
    v21 = 0uLL;
    v22 = 0;
    subject = hx509_cert_get_subject(a3, (void **)&v20);
    if ((_DWORD)subject)
      return subject;
    if (hx509_name_is_null_p(v20))
    {
      v6 = malloc_type_calloc(1uLL, 0x10uLL, 0x108004057E67DB5uLL);
      *(_QWORD *)&v21 = v6;
      if (!v6)
      {
        hx509_name_free((void **)&v20);
        goto LABEL_15;
      }
      v7 = hx509_name_binary(v20, (uint64_t)v6);
      if ((_DWORD)v7)
      {
        subject = v7;
        hx509_name_free((void **)&v20);
LABEL_13:
        sub_2096BC848();
        return subject;
      }
    }
    hx509_name_free((void **)&v20);
    *((_QWORD *)&v21 + 1) = malloc_type_calloc(1uLL, 0x10uLL, 0x108004057E67DB5uLL);
    if (*((_QWORD *)&v21 + 1))
    {
      v15 = 0;
      v16 = 0u;
      v17 = 0u;
      v18 = 0u;
      v19 = 0u;
      subject = hx509_cert_get_issuer(a3, &v15);
      if ((_DWORD)subject)
        goto LABEL_13;
      subject = hx509_name_to_Name();
      hx509_name_free(&v15);
      if ((_DWORD)subject)
        goto LABEL_13;
      subject = hx509_cert_get_serialnumber();
      if ((_DWORD)subject)
        goto LABEL_12;
      v9 = length_IssuerAndSerialNumber();
      **((_QWORD **)&v21 + 1) = v9;
      v10 = malloc_type_malloc(v9, 0x89212A28uLL);
      *(_QWORD *)(*((_QWORD *)&v21 + 1) + 8) = v10;
      if (!v10)
      {
        subject = 12;
        goto LABEL_12;
      }
      v11 = encode_IssuerAndSerialNumber();
      if ((_DWORD)v11)
      {
        subject = v11;
        free(*(void **)(*((_QWORD *)&v21 + 1) + 8));
        *(_QWORD *)(*((_QWORD *)&v21 + 1) + 8) = 0;
LABEL_12:
        free_IssuerAndSerialNumber();
        goto LABEL_13;
      }
      free_IssuerAndSerialNumber();
      if (**((_QWORD **)&v21 + 1))
        abort();
      v22 = 0;
      v12 = (char *)malloc_type_realloc(*((void **)a2 + 1), 24 * (*a2 + 1), 0x20040960023A9uLL);
      if (v12)
      {
        subject = 0;
        *((_QWORD *)a2 + 1) = v12;
        v13 = &v12[24 * *a2];
        v14 = v21;
        *((_QWORD *)v13 + 2) = v22;
        *(_OWORD *)v13 = v14;
        ++*a2;
        return subject;
      }
    }
LABEL_15:
    sub_2096BC848();
    return 12;
  }
  return 0;
}

uint64_t sub_2096A4CF4(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, _QWORD *a5, size_t *a6, _QWORD *a7)
{
  int v11;
  uint64_t v12;
  uint64_t v13;
  const void *v14;
  const void *v15;
  const void *cert;
  CFArrayRef theArray;

  theArray = 0;
  v11 = ((int)(*(_DWORD *)(a4 + 48) << 31) >> 31) & 0xB;
  *a7 = 0;
  v12 = hx509_cms_verify_signed(a1[47], *(_QWORD *)a4, v11, a2, a3, 0, *(_QWORD *)(a4 + 32), a5, a6, &theArray);
  if (!(_DWORD)v12)
  {
    if (theArray)
    {
      v13 = 2529638982;
      if (!heim_array_get_length(theArray))
      {
        v15 = 0;
        goto LABEL_12;
      }
      v14 = heim_array_copy_value(theArray, 0);
      v15 = v14;
      if (!v14)
        goto LABEL_12;
      if (!hx509_evaluate_get_length((uint64_t)v14))
        goto LABEL_12;
      cert = hx509_evaluate_get_cert((uint64_t)v15, 0);
      *a7 = cert;
      if (!cert)
        goto LABEL_12;
    }
    else
    {
      v15 = 0;
    }
    v13 = 0;
LABEL_12:
    heim_release(theArray);
    heim_release(v15);
    return v13;
  }
  v13 = v12;
  sub_2096A1BCC(a1, v12, "CMS verify signed failed");
  return v13;
}

uint64_t sub_2096A4DFC(_krb5_context *a1, char *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  char v10;
  uint64_t v11;
  uint64_t principal;
  const char *v13;
  int matched;
  krb5_principal v16;

  v10 = *(_BYTE *)(a4 + 52);
  if ((v10 & 2) != 0)
  {
    v11 = hx509_cert_check_eku(*((_QWORD *)a1 + 47), a5);
    if ((_DWORD)v11)
    {
      principal = v11;
      v13 = "No PK-INIT KDC EKU in kdc certificate";
LABEL_9:
      krb5_set_error_message(a1, principal, v13);
      return principal;
    }
    v10 = *(_BYTE *)(a4 + 52);
  }
  if ((v10 & 4) != 0)
  {
    v16 = 0;
    principal = krb5_make_principal(a1, &v16, a2, "krbtgt", a2, 0);
    if ((_DWORD)principal)
      return principal;
    matched = _krb5_pk_match_cert((uint64_t *)a1, (uint64_t)v16, a5, 1);
    krb5_free_principal(a1, v16);
    if (matched)
    {
      principal = 2529638983;
      krb5_set_error_message(a1, -1765328313, "KDC have wrong realm name in the certificate");
      return principal;
    }
  }
  if (!a3)
    return 0;
  principal = hx509_verify_hostname(*((_QWORD *)a1 + 47), a5, (*(_BYTE *)(a4 + 52) & 8) != 0, 0, (const char *)(a3 + 48), *(_QWORD *)(*(_QWORD *)(a3 + 8) + 32), *(_DWORD *)(*(_QWORD *)(a3 + 8) + 16));
  if ((_DWORD)principal)
  {
    v13 = "Address mismatch in the KDC certificate";
    goto LABEL_9;
  }
  return principal;
}

uint64_t sub_2096A4F40(_krb5_context *a1, uint64_t a2, uint64_t a3, void **a4)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  void *v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;

  v13 = 0u;
  v14 = 0u;
  v12 = 0u;
  v7 = sub_2096BC998();
  if ((_DWORD)v7)
  {
    v8 = v7;
    krb5_set_error_message(a1, v7, "PKINIT decoding reply key failed");
LABEL_11:
    sub_2096BC9B8();
    return v8;
  }
  v9 = krb5_enctype_valid(a1, (char *)v12);
  if ((_DWORD)v9)
  {
    v8 = v9;
    goto LABEL_11;
  }
  v8 = sub_2096A5208(a1, (const krb5_keyblock *)&v12, (char *)&v13 + 8, a3);
  if ((_DWORD)v8 && DWORD2(v13) == 12 && (_DWORD)v12 == 18 && (_QWORD)v14 == 20)
  {
    DWORD2(v13) = 16;
    *(_QWORD *)&v14 = 12;
    v8 = sub_2096A5208(a1, (const krb5_keyblock *)&v12, (char *)&v13 + 8, a3);
  }
  if ((_DWORD)v8)
    goto LABEL_11;
  v11 = malloc_type_malloc(0x18uLL, 0x10800404ACF7207uLL);
  *a4 = v11;
  if (v11)
  {
    v8 = copy_EncryptionKey();
    sub_2096BC9B8();
    if ((_DWORD)v8)
    {
      krb5_set_error_message(a1, v8, "PKINIT failed copying reply key");
      free(*a4);
      *a4 = 0;
    }
  }
  else
  {
    sub_2096BC9B8();
    v8 = 12;
    krb5_set_error_message(a1, 12, "malloc: out of memory");
  }
  return v8;
}

uint64_t sub_2096A50D8(_krb5_context *a1, uint64_t a2, int a3, void **a4)
{
  uint64_t v7;
  uint64_t v8;
  void *v9;

  v7 = sub_2096BCA78();
  if ((_DWORD)v7)
  {
    v8 = v7;
    krb5_set_error_message(a1, v7, "PKINIT decoding reply key failed");
    sub_2096BCA98();
  }
  else if (a3)
  {
    krb5_set_error_message(a1, 0, "PKINIT enckey nonce is wrong");
    sub_2096BCA98();
    return 2529638953;
  }
  else
  {
    v9 = malloc_type_malloc(0x18uLL, 0x10800404ACF7207uLL);
    *a4 = v9;
    if (v9)
    {
      v8 = copy_EncryptionKey();
      sub_2096BCA98();
      if ((_DWORD)v8)
      {
        krb5_set_error_message(a1, v8, "PKINIT failed copying reply key");
        free(*a4);
        *a4 = 0;
      }
    }
    else
    {
      sub_2096BCA98();
      v8 = 12;
      krb5_set_error_message(a1, 12, "malloc: out of memory");
    }
  }
  return v8;
}

uint64_t sub_2096A5208(_krb5_context *a1, const krb5_keyblock *a2, const void *a3, uint64_t a4)
{
  size_t v7;
  uint64_t v8;
  krb5_cksumtype ctype[2];

  *(_QWORD *)ctype = 0;
  v8 = krb5_crypto_init(a1, a2, 0, (krb5_keyblock ***)ctype);
  if (!(_DWORD)v8)
  {
    v8 = krb5_verify_checksum(a1, ctype[0], (const krb5_checksum *)6, *(krb5_const_pointer *)(a4 + 8), *(_QWORD *)a4, a3, v7);
    krb5_crypto_destroy(a1, *(uint64_t *)ctype);
  }
  return v8;
}

uint64_t _krb5_plugin_get_symbol(uint64_t a1)
{
  return *(_QWORD *)a1;
}

uint64_t _krb5_plugin_get_next(uint64_t a1)
{
  return *(_QWORD *)(a1 + 8);
}

uint64_t _krb5_plugin_find(_krb5_context *a1, int a2, const char *a3, _QWORD *a4)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char **strings;
  char **v15;
  char *v16;
  void **v17;
  char *v18;
  size_t v19;
  char *v20;
  DIR *v21;
  DIR *v22;
  dirent *v23;
  const char *d_name;
  size_t v25;
  int v26;
  int v27;
  char *v28;
  uint64_t v29;
  _DWORD *v30;
  _QWORD *v31;
  void *v32;
  int v33;
  char *v34;
  uint64_t v35;
  uint64_t v36;
  void *v37;
  void *v38;
  uint64_t v39;
  _QWORD *v40;
  _QWORD *v41;
  int v43;
  void **v44;
  char *__s;
  char *__s2;
  int v47;

  *a4 = 0;
  pthread_mutex_lock((pthread_mutex_t *)&unk_253D3A5E8);
  if ((byte_2545A7DC8 & 1) == 0)
  {
    v43 = a2;
    __s2 = 0;
    byte_2545A7DC8 = 1;
    strings = (char **)krb5_config_get_strings((uint64_t)a1, 0, v8, v9, v10, v11, v12, v13, (uint64_t)"libdefaults");
    v15 = off_2545A4E00;
    if (strings)
      v15 = strings;
    v44 = (void **)v15;
    v16 = *v15;
    if (v16)
    {
      v17 = v44;
      while (1)
      {
        __s = v16;
        if (!_krb5_expand_default_cc_name_0(a1, (char *)*v17, (void **)&__s))
        {
          v18 = __s;
          v19 = strlen(__s);
          if (v19)
          {
            v20 = __s - 1;
            do
            {
              if (v20[v19] != 47)
                break;
              v20[v19--] = 0;
            }
            while (v19);
            v18 = __s;
          }
          v21 = opendir(v18);
          if (v21)
            break;
        }
LABEL_44:
        if (__s != *v17)
          free(__s);
        v34 = (char *)v17[1];
        ++v17;
        v16 = v34;
        if (!v34)
          goto LABEL_47;
      }
      v22 = v21;
      sub_2096791E0(v21);
      while (1)
      {
        do
        {
          v23 = readdir(v22);
          if (!v23)
          {
            closedir(v22);
            goto LABEL_44;
          }
          d_name = v23->d_name;
        }
        while (v23->d_name[0] == 46 && (!v23->d_name[1] || v23->d_name[1] == 46 && !v23->d_name[2]));
        __s2 = 0;
        v25 = strlen(v23->d_name);
        if (v25 < 8)
          goto LABEL_21;
        v26 = v25 - 7;
        if (strcmp(&d_name[v25 - 7], ".bundle"))
          goto LABEL_21;
        v33 = asprintf(&__s2, "%s/%s/%.*s", __s, d_name, v26, d_name);
        v27 = v33;
        v28 = __s2;
        if (v33)
        {
          if (v33 < 0)
            goto LABEL_21;
        }
        else
        {
          if (access(__s2, 1))
          {
            __error();
            free(__s2);
            __s2 = 0;
LABEL_21:
            v27 = asprintf(&__s2, "%s/%s", __s, d_name);
            v28 = __s2;
            goto LABEL_22;
          }
          v28 = __s2;
        }
        if (!v28)
          goto LABEL_21;
LABEL_22:
        if (v27 < 0 || !v28)
        {
          krb5_set_error_message(a1, 12, "malloc: out of memory");
          a2 = v43;
          goto LABEL_50;
        }
        v29 = qword_2545A7DC0;
        if (qword_2545A7DC0)
        {
          while (*(_DWORD *)v29 || strcmp(*(const char **)(v29 + 8), v28))
          {
            v29 = *(_QWORD *)(v29 + 32);
            if (!v29)
              goto LABEL_28;
          }
LABEL_29:
          free(v28);
        }
        else
        {
LABEL_28:
          v47 = 0;
          if (csops())
            goto LABEL_29;
          if ((v47 & 0x2810) == 0x800 && !sub_2096A577C((uint64_t)a1, (uint64_t)v28))
          {
            sub_20969D1E8((uint64_t)a1, 2, "Since binary is restricted skipping plugin %s ", v28);
            goto LABEL_29;
          }
          v30 = malloc_type_calloc(1uLL, 0x28uLL, 0x10B204067CB9950uLL);
          if (!v30)
          {
            krb5_set_error_message(a1, 12, "malloc: out of memory");
            goto LABEL_29;
          }
          v31 = v30;
          *v30 = 0;
          v32 = dlopen(v28, 5);
          v31[1] = v28;
          v31[2] = v32;
          v31[4] = qword_2545A7DC0;
          qword_2545A7DC0 = (uint64_t)v31;
        }
      }
    }
LABEL_47:
    a2 = v43;
    if (v44 != (void **)off_2545A4E00)
      krb5_config_free_strings(v44);
  }
LABEL_50:
  v35 = qword_2545A7DC0;
  if (qword_2545A7DC0)
  {
    v36 = 0;
    while (*(_DWORD *)v35 != 1)
    {
      if (*(_DWORD *)v35)
        goto LABEL_61;
      v37 = *(void **)(v35 + 16);
      if (v37)
      {
        v38 = dlsym(v37, a3);
        if (v38)
        {
          v39 = (uint64_t)v38;
          goto LABEL_60;
        }
        goto LABEL_61;
      }
LABEL_65:
      v35 = *(_QWORD *)(v35 + 32);
      if (!v35)
      {
        pthread_mutex_unlock((pthread_mutex_t *)&unk_253D3A5E8);
        if (!(_DWORD)v36)
          goto LABEL_69;
        return v36;
      }
    }
    if (!strcmp(*(const char **)(v35 + 16), a3) && *(_DWORD *)(v35 + 8) == a2)
    {
      v39 = *(_QWORD *)(v35 + 24);
LABEL_60:
      v36 = sub_2096A56D0(a1, a4, v39);
    }
LABEL_61:
    if ((_DWORD)v36)
    {
      v40 = (_QWORD *)*a4;
      if (*a4)
      {
        do
        {
          v41 = (_QWORD *)v40[1];
          free(v40);
          v40 = v41;
        }
        while (v41);
      }
      *a4 = 0;
    }
    goto LABEL_65;
  }
  pthread_mutex_unlock((pthread_mutex_t *)&unk_253D3A5E8);
LABEL_69:
  if (*a4)
    return 0;
  v36 = 2;
  krb5_set_error_message(a1, 2, "Did not find a plugin for %s", a3);
  return v36;
}

uint64_t sub_2096A56D0(_krb5_context *a1, _QWORD *a2, uint64_t a3)
{
  _QWORD *v6;
  uint64_t v7;

  v6 = malloc_type_calloc(1uLL, 0x10uLL, 0xA0040BD48D6D6uLL);
  if (v6)
  {
    v7 = 0;
    *v6 = a3;
    v6[1] = *a2;
    *a2 = v6;
  }
  else
  {
    v7 = 12;
    krb5_set_error_message(a1, 12, "malloc: out of memory");
  }
  return v7;
}

_QWORD *_krb5_plugin_free(_QWORD *result)
{
  _QWORD *v1;

  if (result)
  {
    do
    {
      v1 = (_QWORD *)result[1];
      free(result);
      result = v1;
    }
    while (v1);
  }
  return result;
}

uint64_t sub_2096A577C(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  OSStatus v4;
  const __CFString *v5;
  const __CFURL *v6;
  const __CFString *PathComponent;
  const char *CStringPtr;
  const char *v9;
  const void *v10;
  SecRequirementRef requirement;
  SecStaticCodeRef staticCode;

  v2 = a2;
  requirement = 0;
  staticCode = 0;
  if (!a2)
  {
    sub_20969D1E8(a1, 2, "path cannot be null %s", 0);
    goto LABEL_23;
  }
  v4 = SecRequirementCreateWithString(CFSTR("anchor apple"), 0, &requirement);
  if (v4 || !requirement)
  {
    sub_20969D1E8(a1, 2, "Error creating requirement %d ", v4);
    v2 = 0;
    goto LABEL_23;
  }
  v5 = CFStringCreateWithCString(0, (const char *)v2, 0x8000100u);
  v6 = CFURLCreateWithFileSystemPath(0, v5, kCFURLPOSIXPathStyle, 0);
  if (SecStaticCodeCreateWithPath(v6, 0, &staticCode) || !staticCode)
  {
    sub_20969D1E8(a1, 2, "Error creating static code for %s: %d ");
  }
  else
  {
    if (!SecStaticCodeCheckValidity(staticCode, 0x15u, requirement))
    {
      v2 = 1;
      if (v6)
        goto LABEL_12;
      goto LABEL_20;
    }
    sub_20969D1E8(a1, 2, "Error checking requirement for %s: %d ");
  }
  v2 = 0;
  if (v6)
  {
LABEL_12:
    PathComponent = CFURLCopyLastPathComponent(v6);
    CStringPtr = CFStringGetCStringPtr(PathComponent, 0x8000100u);
    v9 = "is not";
    if ((_DWORD)v2)
      v9 = "is";
    sub_20969D1E8(a1, 2, "Plugin %s %s signed by Apple", CStringPtr, v9);
    if (PathComponent)
      CFRelease(PathComponent);
    if (v5)
      CFRelease(v5);
    v10 = v6;
    goto LABEL_22;
  }
LABEL_20:
  if (!v5)
    goto LABEL_23;
  v10 = v5;
LABEL_22:
  CFRelease(v10);
LABEL_23:
  if (staticCode)
    CFRelease(staticCode);
  if (requirement)
    CFRelease(requirement);
  return v2;
}

void *sub_2096A593C(uint64_t a1)
{
  void *result;

  heim_release(*(CFTypeRef *)(a1 + 32));
  heim_release(*(CFTypeRef *)(a1 + 48));
  result = *(void **)(a1 + 40);
  if (result)
    return (void *)dlclose(result);
  return result;
}

uint64_t krb5_plugin_register_module(_krb5_context *a1, char *a2, int a3, char *a4, const void *a5)
{
  CFStringRef v10;
  const __CFDictionary *v11;
  CFMutableDictionaryRef v12;
  CFStringRef v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  _QWORD *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  _QWORD *v25;
  __CFDictionary *v26;
  CFStringRef v27;
  uint64_t v28;
  _DWORD *v29;
  _QWORD *v30;
  char *v31;
  uint64_t v32;
  uint64_t v33;
  char *cStr;

  pthread_mutex_lock((pthread_mutex_t *)&unk_253D3A5E8);
  if (!a2)
    goto LABEL_11;
  if (!qword_253D3BA60)
  {
    qword_253D3BA60 = (uint64_t)heim_dict_create();
    if (!qword_253D3BA60)
    {
      pthread_mutex_unlock((pthread_mutex_t *)&unk_253D3A5E8);
      return 1;
    }
  }
  v10 = heim_string_create(a2);
  v11 = (const __CFDictionary *)heim_dict_copy_value((const __CFDictionary *)qword_253D3BA60, v10);
  if (v11)
    goto LABEL_7;
  v12 = heim_dict_create();
  if (!v12)
  {
    pthread_mutex_unlock((pthread_mutex_t *)&unk_253D3A5E8);
    heim_release(v10);
    return 1;
  }
  v11 = v12;
  heim_dict_set_value((__CFDictionary *)qword_253D3BA60, v10, v12);
LABEL_7:
  heim_release(v10);
  cStr = 0;
  asprintf(&cStr, "%p", a5);
  v13 = heim_string_create(cStr);
  v19 = heim_dict_copy_value(v11, v13);
  if (!v19)
  {
    v19 = (_QWORD *)heim_uniq_alloc(0x38uLL, (uint64_t)"krb5-plugin", (uint64_t)sub_2096A593C, v14, v15, v16, v17, v18);
    if (v19)
    {
      v19[6] = heim_dict_create();
      heim_dict_set_value(v11, v13, v19);
      v25 = (_QWORD *)heim_uniq_alloc(0x30uLL, (uint64_t)"struct-plug", (uint64_t)sub_2096A5C04, v20, v21, v22, v23, v24);
      v25[4] = a5;
      v26 = (__CFDictionary *)v19[6];
      v27 = heim_string_create(a4);
      heim_dict_set_value(v26, v27, v25);
    }
  }
  heim_release(v19);
LABEL_11:
  v28 = qword_2545A7DC0;
  if (qword_2545A7DC0)
  {
    while (*(_DWORD *)v28 != 1
         || strcmp(*(const char **)(v28 + 16), a4)
         || *(_DWORD *)(v28 + 8) != a3
         || *(const void **)(v28 + 24) != a5)
    {
      v28 = *(_QWORD *)(v28 + 32);
      if (!v28)
        goto LABEL_17;
    }
    goto LABEL_20;
  }
LABEL_17:
  v29 = malloc_type_calloc(1uLL, 0x28uLL, 0x10B204067CB9950uLL);
  if (!v29)
  {
    pthread_mutex_unlock((pthread_mutex_t *)&unk_253D3A5E8);
LABEL_23:
    v33 = 12;
    krb5_set_error_message(a1, 12, "malloc: out of memory");
    return v33;
  }
  v30 = v29;
  *v29 = 1;
  v29[2] = a3;
  v31 = strdup(a4);
  v30[2] = v31;
  if (!v31)
  {
    pthread_mutex_unlock((pthread_mutex_t *)&unk_253D3A5E8);
    free(v30);
    goto LABEL_23;
  }
  v32 = qword_2545A7DC0;
  v30[3] = a5;
  v30[4] = v32;
  qword_2545A7DC0 = (uint64_t)v30;
LABEL_20:
  pthread_mutex_unlock((pthread_mutex_t *)&unk_253D3A5E8);
  return 0;
}

uint64_t sub_2096A5C04(uint64_t result)
{
  uint64_t v1;

  v1 = *(_QWORD *)(result + 32);
  if (v1)
    return (*(uint64_t (**)(_QWORD))(v1 + 16))(*(_QWORD *)(result + 40));
  return result;
}

uint64_t krb5_plugin_register(_krb5_context *a1, int a2, char *a3, const void *a4)
{
  return krb5_plugin_register_module(a1, 0, a2, a3, a4);
}

uint64_t krb5_plugin_run_f(uint64_t a1, char *cStr, char *a3, unsigned int a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v12;
  CFStringRef v13;
  const __CFDictionary *v14;
  uint64_t v16;
  CFStringRef v17;
  char *v18;
  uint64_t v19;
  const __CFArray *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;

  v12 = 2529639161;
  v13 = heim_string_create(cStr);
  pthread_mutex_lock((pthread_mutex_t *)&unk_253D3A5E8);
  v14 = (const __CFDictionary *)heim_dict_copy_value((const __CFDictionary *)qword_253D3BA60, v13);
  heim_release(v13);
  if (v14)
  {
    v23 = 0;
    v16 = a1;
    v18 = a3;
    v17 = heim_string_create(a3);
    v19 = a4;
    v20 = heim_array_create();
    v21 = a7;
    v22 = a6;
    sub_2096D7820(v14, (uint64_t)&v16, (uint64_t)sub_2096A5D58);
    heim_release(v14);
    pthread_mutex_unlock((pthread_mutex_t *)&unk_253D3A5E8);
    LODWORD(v23) = -1765328135;
    heim_array_iterate_f(v20, (uint64_t)&v16, (uint64_t (*)(const void *, int *, uint64_t))sub_2096A5E3C);
    heim_release(v20);
    heim_release(v17);
    return v23;
  }
  else
  {
    pthread_mutex_unlock((pthread_mutex_t *)&unk_253D3A5E8);
  }
  return v12;
}

void sub_2096A5D58(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  _DWORD *v12;
  _DWORD *v13;

  v5 = heim_dict_copy_value(*(const __CFDictionary **)(a2 + 48), *(const void **)(a3 + 8));
  if (v5)
  {
    v11 = v5;
    v12 = (_DWORD *)v5[4];
    if (!v12)
      goto LABEL_11;
LABEL_9:
    if (*v12 >= *(_DWORD *)(a3 + 24))
      heim_array_append_value(*(__CFArray **)(a3 + 32), v11);
    goto LABEL_11;
  }
  if (!*(_QWORD *)(a2 + 40))
    return;
  v11 = (_QWORD *)heim_uniq_alloc(0x30uLL, (uint64_t)"struct-plug", (uint64_t)sub_2096A5C04, v6, v7, v8, v9, v10);
  v13 = dlsym(*(void **)(a2 + 40), *(const char **)(a3 + 16));
  v12 = v13;
  v11[4] = v13;
  if (v13 && (*((unsigned int (**)(_QWORD, _QWORD *))v13 + 1))(*(_QWORD *)a3, v11 + 5))
  {
    v12 = 0;
    v11[4] = 0;
  }
  heim_dict_set_value(*(__CFDictionary **)(a2 + 48), *(const void **)(a3 + 8), v11);
  if (v12)
    goto LABEL_9;
LABEL_11:
  heim_release(v11);
}

uint64_t sub_2096A5E3C(uint64_t a1, _DWORD *a2, uint64_t a3)
{
  uint64_t result;

  result = (*(uint64_t (**)(_QWORD, _QWORD, _QWORD, _QWORD))(a3 + 40))(*(_QWORD *)a3, *(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40), *(_QWORD *)(a3 + 48));
  *(_DWORD *)(a3 + 56) = result;
  if ((_DWORD)result != -1765328135)
    *a2 = 1;
  return result;
}

void krb5_free_principal(krb5_context a1, krb5_principal a2)
{
  if (a2)
  {
    free_Principal();
    free(a2);
  }
}

void krb5_principal_set_type(uint64_t a1, _DWORD *a2, int a3)
{
  *a2 = a3;
}

uint64_t krb5_principal_get_type(uint64_t a1, unsigned int *a2)
{
  return *a2;
}

uint64_t krb5_principal_get_realm(uint64_t a1, uint64_t a2)
{
  return *(_QWORD *)(a2 + 24);
}

uint64_t krb5_principal_get_comp_string(uint64_t a1, uint64_t a2, unsigned int a3)
{
  if (*(_DWORD *)(a2 + 8) <= a3)
    return 0;
  else
    return *(_QWORD *)(*(_QWORD *)(a2 + 16) + 8 * a3);
}

uint64_t krb5_principal_get_num_comp(uint64_t a1, uint64_t a2)
{
  return *(unsigned int *)(a2 + 8);
}

krb5_error_code krb5_parse_name_flags(krb5_context a1, const char *a2, int a3, krb5_principal *a4)
{
  _krb5_context *v4;
  krb5_error_code v5;
  int v9;
  char *v10;
  char *v11;
  char *v12;
  char *v13;
  unsigned int v14;
  _BOOL4 v15;
  int v16;
  _BOOL4 v17;
  char *v18;
  char *v19;
  uint64_t v20;
  unsigned int v21;
  char *v22;
  unsigned int v23;
  char *v24;
  unsigned int v25;
  void *v26;
  unsigned int v27;
  const char *i;
  unsigned int v29;
  krb5_error_code default_realm;
  size_t v33;
  char *v34;
  char *v35;
  void *v36;
  krb5_principal_data *v37;
  int v38;
  krb5_principal v39;
  unint64_t v40;
  krb5_principal *v41;
  _krb5_context *v42;
  _BOOL4 v43;
  char *v44;
  unsigned int v45;
  _BOOL4 v46;
  char *v47;
  char *v48;
  int v49;
  char *v50;
  char *v51;

  v4 = a1;
  v51 = 0;
  *a4 = 0;
  if ((~a3 & 3) == 0)
  {
    v5 = -1765328138;
    krb5_set_error_message(a1, -1765328138, "Can't require both realm and no realm at the same time");
    return v5;
  }
  v9 = 1;
  if ((a3 & 4) == 0)
  {
    for (i = a2; ; ++i)
    {
      v29 = *(unsigned __int8 *)i;
      if (v29 > 0x3F)
      {
        if (v29 == 92)
        {
          if (!*(unsigned __int8 *)++i)
          {
            v5 = -1765328250;
            krb5_set_error_message(a1, -1765328250, "trailing \\ in principal name");
            return v5;
          }
        }
        else if (v29 == 64)
        {
          break;
        }
      }
      else if (v29 == 47)
      {
        ++v9;
      }
      else if (!*i)
      {
        break;
      }
    }
  }
  v10 = (char *)malloc_type_calloc(v9, 8uLL, 0x10040436913F5uLL);
  if (!v10)
  {
LABEL_50:
    v5 = 12;
    krb5_set_error_message(v4, 12, "malloc: out of memory");
    return v5;
  }
  v11 = v10;
  v12 = strdup(a2);
  if (!v12)
  {
    free(v11);
    goto LABEL_50;
  }
  v13 = v12;
  v41 = a4;
  v14 = *v12;
  if (!*v12)
  {
    v16 = 0;
    v18 = v12;
    v19 = v12;
    if ((a3 & 2) != 0)
      goto LABEL_73;
    goto LABEL_53;
  }
  v42 = v4;
  v15 = 0;
  v16 = 0;
  v17 = 1;
  v18 = v12;
  v19 = v12;
  v50 = v12;
  v47 = v12;
  v48 = v11;
LABEL_8:
  v20 = 0;
  v44 = v18;
  v43 = v15;
  v49 = v16;
  v45 = v14;
  v46 = v17;
  v21 = v17 & (a3 >> 2);
  v22 = &v11[8 * v16];
  v23 = v14;
  while (1)
  {
    v24 = &v50[v20];
    if (v23 == 92)
    {
      v16 = v49 + v20;
      v50 = v24 + 2;
      v27 = v24[1];
      if (v27 > 0x6D)
      {
        v11 = v48;
        v17 = v46;
        if (v27 == 116)
        {
          v27 = 9;
        }
        else if (v27 == 110)
        {
          v27 = 10;
        }
      }
      else
      {
        v11 = v48;
        v17 = v46;
        if (v27 == 48)
        {
          v27 = 0;
        }
        else if (v27 == 98)
        {
          v27 = 8;
        }
        else if (!v24[1])
        {
          v5 = -1765328250;
          krb5_set_error_message(v42, -1765328250, "trailing \\ in principal name");
          v16 = v49 + v20;
          v13 = v47;
          goto LABEL_76;
        }
      }
      v13 = v47;
      if (v15)
        goto LABEL_34;
      goto LABEL_36;
    }
    if (v21)
    {
      v27 = v45;
      v17 = v45 != 64;
      v16 = v49;
      v50 += v20 + 1;
      v15 = v43;
      v18 = v44;
      v13 = v47;
      v11 = v48;
      if (v43)
        goto LABEL_34;
LABEL_36:
      *v19++ = v27;
      v14 = *v50;
      if (*v50)
        goto LABEL_8;
LABEL_59:
      if (v15)
      {
        if ((a3 & 1) != 0)
        {
          v5 = -1765328250;
          krb5_set_error_message(v42, -1765328250, "realm found in 'short' principal expected to be without one", v41);
          goto LABEL_76;
        }
        v33 = v19 - v18;
        v34 = (char *)malloc_type_malloc(v19 - v18 + 1, 0x49A0B1CDuLL);
        v51 = v34;
        v4 = v42;
        if (!v34)
          goto LABEL_71;
        v35 = v34;
        memcpy(v34, v18, v33);
        v35[v33] = 0;
LABEL_66:
        v37 = (krb5_principal_data *)malloc_type_malloc(0x20uLL, 0x10900408A8AD7E9uLL);
        *v41 = v37;
        if (v37)
        {
          if ((a3 & 4) != 0)
            v38 = 10;
          else
            v38 = 1;
          v37->magic = v38;
          v37->realm.data = v11;
          v39 = *v41;
          v39->realm.magic = v16;
          v39->data = (krb5_data *)v51;
          free(v13);
          return 0;
        }
LABEL_71:
        v5 = 12;
        krb5_set_error_message(v4, 12, "malloc: out of memory", v41);
        goto LABEL_76;
      }
      v4 = v42;
      if ((a3 & 2) != 0)
      {
LABEL_73:
        v5 = -1765328250;
        krb5_set_error_message(v4, -1765328250, "realm NOT found in principal expected to be with one", v41);
        goto LABEL_76;
      }
LABEL_53:
      if ((a3 & 1) != 0)
      {
        v51 = 0;
      }
      else
      {
        default_realm = krb5_get_default_realm(v4, &v51);
        if (default_realm)
        {
          v5 = default_realm;
          goto LABEL_76;
        }
      }
      v36 = malloc_type_malloc(v19 - v18 + 1, 0x334428DDuLL);
      *(_QWORD *)&v11[8 * v16] = v36;
      if (!v36)
        goto LABEL_71;
      memcpy(v36, v18, v19 - v18);
      *(_BYTE *)(*(_QWORD *)&v11[8 * v16++] + v19 - v18) = 0;
      goto LABEL_66;
    }
    v25 = (a3 >> 2) & 1;
    if (v23 != 47)
      LOBYTE(v25) = 1;
    if (v23 != 64 && (v25 & 1) != 0)
      break;
    if (v15)
    {
      v5 = -1765328250;
      v16 = v49 + v20;
      krb5_set_error_message(v42, -1765328250, "part after realm in principal name", v41);
LABEL_58:
      v13 = v47;
      v11 = v48;
      goto LABEL_76;
    }
    v26 = malloc_type_malloc(v19 - v18 + 1, 0xA4B919A4uLL);
    *(_QWORD *)&v22[8 * v20] = v26;
    if (!v26)
    {
      v16 = v49 + v20;
      v5 = 12;
      krb5_set_error_message(v42, 12, "malloc: out of memory", v41);
      goto LABEL_58;
    }
    v15 = v23 == 64;
    memcpy(v26, v18, v19 - v18);
    *(_BYTE *)(*(_QWORD *)&v22[8 * v20] + v19 - v18) = 0;
    v23 = v24[1];
    ++v20;
    v18 = v19;
    if (!v24[1])
    {
      v11 = v48;
      v16 = v49 + v20;
      v18 = v19;
      v13 = v47;
      goto LABEL_59;
    }
  }
  v11 = v48;
  v50 += v20 + 1;
  v27 = v23;
  v16 = v49 + v20;
  v13 = v47;
  v17 = v46;
  if (!v15)
    goto LABEL_36;
LABEL_34:
  if (v27 != 47 && v27)
    goto LABEL_36;
  v5 = -1765328250;
  krb5_set_error_message(v42, -1765328250, "part after realm in principal name", v41);
LABEL_76:
  if (v16 >= 1)
  {
    v40 = v16 + 1;
    do
      free(*(void **)&v11[8 * (v40-- - 2)]);
    while (v40 > 1);
  }
  free(v11);
  free(v51);
  free(v13);
  return v5;
}

krb5_error_code krb5_parse_name(krb5_context a1, const char *a2, krb5_principal *a3)
{
  return krb5_parse_name_flags(a1, a2, 0, a3);
}

uint64_t krb5_unparse_name_fixed(_krb5_context *a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  return sub_2096A6478(a1, a2, a3, a4, 0);
}

uint64_t sub_2096A6478(_krb5_context *a1, uint64_t a2, uint64_t a3, unint64_t a4, unsigned int a5)
{
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  uint64_t default_realm;
  uint64_t v14;
  int v15;
  const char *v16;
  char *v17;
  char *__s2;

  if ((a5 & 2) == 0 && !*(_QWORD *)(a2 + 24))
  {
    v16 = "Realm missing from principal, can't unparse";
LABEL_24:
    v14 = 34;
    krb5_set_error_message(a1, 34, v16);
    return v14;
  }
  if (*(_DWORD *)(a2 + 8))
  {
    v10 = 0;
    v11 = 0;
    while (1)
    {
      if (v11 < a4 && v10)
        *(_BYTE *)(a3 + v11++) = 47;
      v12 = sub_2096A7144(*(_BYTE **)(*(_QWORD *)(a2 + 16) + 8 * v10), a3, v11, a4, (a5 >> 2) & 1);
      if (v12 == a4)
        break;
      v11 = v12;
      if (++v10 >= (unint64_t)*(unsigned int *)(a2 + 8))
        goto LABEL_12;
    }
    v16 = "Out of space printing principal";
    goto LABEL_24;
  }
  v11 = 0;
LABEL_12:
  if ((a5 & 3) != 1)
  {
    v15 = a5 & 1;
    goto LABEL_19;
  }
  __s2 = 0;
  default_realm = krb5_get_default_realm(a1, &__s2);
  if (!(_DWORD)default_realm)
  {
    v17 = __s2;
    v15 = strcmp(*(const char **)(a2 + 24), __s2) == 0;
    free(v17);
LABEL_19:
    if (v15 | a5 & 2)
      return 0;
    if (v11 < a4)
      *(_BYTE *)(a3 + v11++) = 64;
    if (sub_2096A7144(*(_BYTE **)(a2 + 24), a3, v11, a4, (a5 >> 2) & 1) != a4)
      return 0;
    v16 = "Out of space printing realm of principal";
    goto LABEL_24;
  }
  return default_realm;
}

uint64_t krb5_unparse_name_fixed_short(_krb5_context *a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  return sub_2096A6478(a1, a2, a3, a4, 1u);
}

uint64_t krb5_unparse_name_fixed_flags(_krb5_context *a1, uint64_t a2, unsigned int a3, uint64_t a4, unint64_t a5)
{
  return sub_2096A6478(a1, a2, a4, a5, a3);
}

krb5_error_code krb5_unparse_name(krb5_context a1, krb5_const_principal a2, char **a3)
{
  return sub_2096A6634(a1, (uint64_t)a2, (void **)a3, 0);
}

uint64_t sub_2096A6634(_krb5_context *a1, uint64_t a2, void **a3, unsigned int a4)
{
  const char *v8;
  size_t v9;
  uint64_t v10;
  uint64_t v11;
  const char **v12;
  const char *v13;
  size_t v14;
  void *v15;
  uint64_t v16;

  v8 = *(const char **)(a2 + 24);
  if (v8)
  {
    v9 = strlen(*(const char **)(a2 + 24));
    v10 = (v9 << (strcspn(v8, " \n\t\b\\/@") != v9)) + 1;
  }
  else
  {
    v10 = 0;
  }
  v11 = *(unsigned int *)(a2 + 8);
  if ((_DWORD)v11)
  {
    v12 = *(const char ***)(a2 + 16);
    do
    {
      v13 = *v12++;
      v14 = strlen(v13);
      v10 += (v14 << (strcspn(v13, " \n\t\b\\/@") != v14)) + 1;
      --v11;
    }
    while (v11);
  }
  v15 = malloc_type_malloc(v10 + 1, 0xD614332AuLL);
  *a3 = v15;
  if (v15)
  {
    v16 = sub_2096A6478(a1, a2, (uint64_t)v15, v10 + 1, a4);
    if ((_DWORD)v16)
    {
      free(*a3);
      *a3 = 0;
    }
  }
  else
  {
    v16 = 12;
    krb5_set_error_message(a1, 12, "malloc: out of memory");
  }
  return v16;
}

krb5_error_code krb5_unparse_name_flags(krb5_context a1, krb5_const_principal a2, int a3, char **a4)
{
  return sub_2096A6634(a1, (uint64_t)a2, (void **)a4, a3);
}

uint64_t krb5_unparse_name_short(_krb5_context *a1, uint64_t a2, void **a3)
{
  return sub_2096A6634(a1, a2, a3, 1u);
}

uint64_t krb5_principal_set_realm(_krb5_context *a1, uint64_t a2, char *__s1)
{
  void *v6;
  char *v7;
  uint64_t v8;

  v6 = *(void **)(a2 + 24);
  if (v6)
    free(v6);
  v7 = strdup(__s1);
  *(_QWORD *)(a2 + 24) = v7;
  if (v7)
    return 0;
  v8 = 12;
  krb5_set_error_message(a1, 12, "malloc: out of memory");
  return v8;
}

krb5_error_code krb5_build_principal(krb5_context a1, krb5_principal *a2, unsigned int a3, const char *a4, ...)
{
  va_list va;

  va_start(va, a4);
  return sub_2096A68C0(a1, a2, a4, (void (*)(_krb5_context *, _QWORD *, uint64_t))sub_2096A6980, (uint64_t)va);
}

uint64_t krb5_build_principal_va(_krb5_context *a1, _QWORD *a2, uint64_t a3, const char *a4, uint64_t a5)
{
  return sub_2096A68C0(a1, a2, a4, (void (*)(_krb5_context *, _QWORD *, uint64_t))sub_2096A6980, a5);
}

uint64_t krb5_make_principal(krb5_context a1, _QWORD *a2, char *a3, ...)
{
  uint64_t default_realm;
  char *v7;
  va_list va;

  va_start(va, a3);
  v7 = 0;
  if (!a3)
  {
    default_realm = krb5_get_default_realm(a1, &v7);
    if ((_DWORD)default_realm)
      return default_realm;
    a3 = v7;
  }
  default_realm = sub_2096A68C0(a1, a2, a3, (void (*)(_krb5_context *, _QWORD *, uint64_t))sub_2096A6980, (uint64_t)va);
  if (v7)
    free(v7);
  return default_realm;
}

uint64_t sub_2096A68C0(_krb5_context *a1, _QWORD *a2, const char *a3, void (*a4)(_krb5_context *, _QWORD *, uint64_t), uint64_t a5)
{
  _DWORD *v10;
  _QWORD *v11;
  char *v12;
  uint64_t v13;

  v10 = malloc_type_calloc(1uLL, 0x20uLL, 0x10900408A8AD7E9uLL);
  if (!v10)
    goto LABEL_5;
  v11 = v10;
  *v10 = 1;
  v12 = strdup(a3);
  v11[3] = v12;
  if (!v12)
  {
    free(v11);
LABEL_5:
    v13 = 12;
    krb5_set_error_message(a1, 12, "malloc: out of memory");
    return v13;
  }
  a4(a1, v11, a5);
  v13 = 0;
  *a2 = v11;
  return v13;
}

void sub_2096A6980(_krb5_context *a1, uint64_t a2, const char **a3)
{
  const char *v3;
  size_t v6;
  const char **v7;
  const char **v8;

  v8 = a3 + 1;
  v3 = *a3;
  if (*a3)
  {
    do
    {
      v6 = strlen(v3);
      sub_2096A723C(a1, a2, v3, v6);
      v7 = v8++;
      v3 = *v7;
    }
    while (*v7);
  }
}

uint64_t krb5_build_principal_va_ext(_krb5_context *a1, _QWORD *a2, uint64_t a3, const char *a4, uint64_t a5)
{
  return sub_2096A68C0(a1, a2, a4, (void (*)(_krb5_context *, _QWORD *, uint64_t))sub_2096A6A00, a5);
}

void sub_2096A6A00(_krb5_context *a1, uint64_t a2, _DWORD *a3)
{
  int i;
  int *v6;
  const void **v7;

  v7 = (const void **)(a3 + 2);
  for (i = *a3; i; i = *v6)
  {
    sub_2096A723C(a1, a2, *v7, i);
    v6 = (int *)(v7 + 1);
    v7 += 2;
  }
}

krb5_error_code krb5_build_principal_ext(krb5_context a1, krb5_principal *a2, unsigned int a3, const char *a4, ...)
{
  va_list va;

  va_start(va, a4);
  return sub_2096A68C0(a1, a2, a4, (void (*)(_krb5_context *, _QWORD *, uint64_t))sub_2096A6A00, (uint64_t)va);
}

krb5_error_code krb5_copy_principal(krb5_context a1, krb5_const_principal a2, krb5_principal *a3)
{
  krb5_principal_data *v5;
  krb5_principal_data *v6;
  krb5_error_code v7;

  v5 = (krb5_principal_data *)malloc_type_malloc(0x20uLL, 0x10900408A8AD7E9uLL);
  if (v5)
  {
    v6 = v5;
    if (!copy_Principal())
    {
      v7 = 0;
      *a3 = v6;
      return v7;
    }
    free(v6);
  }
  v7 = 12;
  krb5_set_error_message(a1, 12, "malloc: out of memory");
  return v7;
}

uint64_t krb5_principal_compare_any_realm(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  const char **v4;
  const char **i;

  v3 = *(unsigned int *)(a2 + 8);
  if ((_DWORD)v3 == *(_DWORD *)(a3 + 8))
  {
    if (!(_DWORD)v3)
      return 1;
    v4 = *(const char ***)(a2 + 16);
    for (i = *(const char ***)(a3 + 16); !strcmp(*v4, *i); ++i)
    {
      ++v4;
      if (!--v3)
        return 1;
    }
  }
  return 0;
}

uint64_t sub_2096A6B94(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  const char **v4;
  const char **i;

  v3 = *(unsigned int *)(a2 + 8);
  if ((_DWORD)v3 == *(_DWORD *)(a3 + 8))
  {
    if (!(_DWORD)v3)
      return 1;
    v4 = *(const char ***)(a2 + 16);
    for (i = *(const char ***)(a3 + 16); !strcmp(*v4, *i); ++i)
    {
      ++v4;
      if (!--v3)
        return 1;
    }
  }
  return 0;
}

krb5_BOOLean krb5_principal_compare(krb5_context a1, krb5_const_principal a2, krb5_const_principal a3)
{
  uint64_t v5;

  v5 = strcmp((const char *)a2->data, (const char *)a3->data);
  if ((_DWORD)v5)
    return 0;
  else
    return krb5_principal_compare_any_realm(v5, (uint64_t)a2, (uint64_t)a3);
}

krb5_BOOLean krb5_realm_compare(krb5_context a1, krb5_const_principal a2, krb5_const_principal a3)
{
  return strcmp((const char *)a2->data, (const char *)a3->data) == 0;
}

uint64_t krb5_principal_match(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v5;
  uint64_t result;
  uint64_t v7;

  if (*(_DWORD *)(a2 + 8) == *(_DWORD *)(a3 + 8))
  {
    v5 = fnmatch(*(const char **)(a3 + 24), *(const char **)(a2 + 24), 0);
    result = 0;
    if (v5)
      return result;
    if (!*(_DWORD *)(a2 + 8))
      return 1;
    v7 = 0;
    while (!fnmatch(*(const char **)(*(_QWORD *)(a3 + 16) + 8 * v7), *(const char **)(*(_QWORD *)(a2 + 16) + 8 * v7), 0))
    {
      if (++v7 >= (unint64_t)*(unsigned int *)(a2 + 8))
        return 1;
    }
  }
  return 0;
}

krb5_error_code krb5_sname_to_principal(krb5_context a1, const char *a2, const char *a3, krb5_int32 a4, krb5_principal *a5)
{
  krb5_error_code v10;
  krb5_error_code host_realm;
  size_t v12;
  void *v14;
  char **v15;
  char __s[256];
  uint64_t v17;

  v17 = *MEMORY[0x24BDAC8D0];
  if (a4 && a4 != 3)
  {
    host_realm = -1765328166;
    krb5_set_error_message(a1, -1765328166, "unsupported name type %d");
    return host_realm;
  }
  v15 = 0;
  if (a2)
  {
    __strlcpy_chk();
  }
  else
  {
    if (gethostname(__s, 0xFFuLL))
    {
      host_realm = *__error();
      krb5_set_error_message(a1, host_realm, "Failed to get local hostname");
      return host_realm;
    }
    __s[255] = 0;
  }
  if (!a3)
    a3 = "host";
  if (a4 == 3)
  {
    v14 = 0;
    v10 = krb5_expand_hostname_realms(a1, __s, (unsigned __int8 **)&v14, &v15);
    if (v10)
      return v10;
    rk_strlwr((unsigned __int8 *)v14);
    __strlcpy_chk();
    free(v14);
  }
  else
  {
    host_realm = krb5_get_host_realm(a1, a2, &v15);
    if (host_realm)
      return host_realm;
  }
  v12 = strlen(__s);
  if (v12 && __s[v12 - 1] == 46)
    __s[v12 - 1] = 0;
  host_realm = krb5_make_principal(a1, a5, *v15, a3, __s, 0);
  krb5_free_host_realm(a1, v15);
  return host_realm;
}

uint64_t krb5_parse_nametype(_krb5_context *a1, char *a2, _DWORD *a3)
{
  uint64_t v6;
  const char *v7;
  uint64_t v8;

  v6 = 0;
  v7 = "UNKNOWN";
  while (strcasecmp(v7, a2))
  {
    v7 = (&off_24C1F2720)[v6 + 2];
    v6 += 2;
    if (v6 == 24)
    {
      v8 = 2529639046;
      krb5_set_error_message(a1, -1765328250, "Failed to find name type %s", a2);
      return v8;
    }
  }
  v8 = 0;
  *a3 = (&off_24C1F2720)[v6 + 1];
  return v8;
}

BOOL krb5_principal_is_null(uint64_t a1, uint64_t a2)
{
  const char **v2;
  _BOOL8 result;

  result = 0;
  if (*(_DWORD *)a2 == 11 && *(_DWORD *)(a2 + 8) == 2)
  {
    v2 = *(const char ***)(a2 + 16);
    if (!strcmp(*v2, "WELLKNOWN") && !strcmp(v2[1], "NULL"))
      return 1;
  }
  return result;
}

BOOL krb5_realm_is_lkdc(const char *a1)
{
  return !strncmp(a1, "LKDC:", 5uLL) || strncmp(a1, "WELLKNOWN:COM.APPLE.LKDC", 0x18uLL) == 0;
}

BOOL krb5_principal_is_lkdc(uint64_t a1, uint64_t a2)
{
  return krb5_realm_is_lkdc(*(const char **)(a2 + 24));
}

BOOL krb5_principal_is_pku2u(uint64_t a1, uint64_t a2)
{
  return strcmp(*(const char **)(a2 + 24), "WELLKNOWN:PKU2U") == 0;
}

BOOL krb5_principal_is_krbtgt(uint64_t a1, uint64_t a2)
{
  return *(_DWORD *)(a2 + 8) == 2 && strcmp(**(const char ***)(a2 + 16), "krbtgt") == 0;
}

BOOL krb5_principal_is_gss_hostbased_service(uint64_t a1, uint64_t a2)
{
  if (!a2)
    return 0;
  if (*(_DWORD *)(a2 + 8) == 2)
    return strcmp(*(const char **)(*(_QWORD *)(a2 + 16) + 8), "WELLKNOWN:ORG.H5L.HOSTBASED-SERVICE") == 0;
  return 0;
}

BOOL krb5_principal_is_root_krbtgt(uint64_t a1, uint64_t a2)
{
  const char **v3;

  if (*(_DWORD *)(a2 + 8) == 2 && (v3 = *(const char ***)(a2 + 16), !strcmp(*v3, "krbtgt")))
    return strcmp(v3[1], *(const char **)(a2 + 24)) == 0;
  else
    return 0;
}

unint64_t sub_2096A7144(_BYTE *a1, uint64_t a2, unint64_t a3, unint64_t a4, int a5)
{
  unint64_t v5;
  char v7;
  _BOOL4 v8;
  BOOL v9;
  unsigned __int8 *v12;
  _BYTE *v13;
  unint64_t v14;
  int v15;

  v5 = a3;
  v7 = *a1;
  v8 = a3 < a4;
  if (*a1)
    v9 = a3 >= a4;
  else
    v9 = 1;
  if (!v9)
  {
    v12 = a1 + 1;
    do
    {
      v13 = memchr(" \n\t\b\\/@", v7, 8uLL);
      if (a5 && v13)
      {
        *(_BYTE *)(a2 + v5++) = aNtb[v13 - " \n\t\b\\/@"];
        goto LABEL_14;
      }
      v14 = v5 + 1;
      if (v13)
      {
        *(_BYTE *)(a2 + v5) = 92;
        if (v14 < a4)
        {
          v5 += 2;
          *(_BYTE *)(a2 + v14) = aNtb[v13 - " \n\t\b\\/@"];
          goto LABEL_14;
        }
      }
      else
      {
        *(_BYTE *)(a2 + v5) = v7;
      }
      ++v5;
LABEL_14:
      v15 = *v12++;
      v7 = v15;
      v8 = v5 < a4;
    }
    while (v15 && v5 < a4);
  }
  if (v8)
    *(_BYTE *)(a2 + v5) = 0;
  return v5;
}

void sub_2096A723C(_krb5_context *a1, uint64_t a2, const void *a3, size_t a4)
{
  uint64_t v8;
  void *v9;
  void *v10;

  v8 = *(unsigned int *)(a2 + 8);
  v9 = malloc_type_realloc(*(void **)(a2 + 16), 8 * v8 + 8, 0x10040436913F5uLL);
  if (v9
    && (*(_QWORD *)(a2 + 16) = v9,
        *(_QWORD *)(*(_QWORD *)(a2 + 16) + 8 * v8) = malloc_type_malloc(a4 + 1, 0x7EE98086uLL),
        (v10 = *(void **)(*(_QWORD *)(a2 + 16) + 8 * v8)) != 0))
  {
    memcpy(v10, a3, a4);
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a2 + 16) + 8 * v8) + a4) = 0;
    ++*(_DWORD *)(a2 + 8);
  }
  else
  {
    krb5_set_error_message(a1, 12, "malloc: out of memory");
  }
}

krb5_error_code krb5_prompter_posix(krb5_context context, void *data, const char *name, const char *banner, int num_prompts, krb5_prompt prompts[])
{
  FILE **v9;
  uint64_t v10;
  int **p_reply;
  FILE **v12;
  FILE **v13;
  const char *v14;

  v9 = (FILE **)MEMORY[0x24BDAC8D8];
  if (name)
  {
    fprintf((FILE *)*MEMORY[0x24BDAC8D8], "%s\n", name);
    if (!banner)
      goto LABEL_6;
    goto LABEL_5;
  }
  if (banner)
  {
LABEL_5:
    fprintf(*v9, "%s\n", banner);
LABEL_6:
    fflush(*v9);
  }
  if (num_prompts < 1)
    return 0;
  v10 = num_prompts;
  p_reply = (int **)&prompts->reply;
  v12 = (FILE **)MEMORY[0x24BDAC8E8];
  v13 = (FILE **)MEMORY[0x24BDAC8E0];
  while (1)
  {
    v14 = (const char *)*((_QWORD *)*p_reply + 1);
    if (!*((_DWORD *)p_reply - 2))
      break;
    if (hc_UI_UTIL_read_pw_string(*((char **)*p_reply + 1), **p_reply, (const char *)*(p_reply - 2), 0))
      return 1;
LABEL_14:
    p_reply += 4;
    if (!--v10)
      return 0;
  }
  fputs((const char *)*(p_reply - 2), *v12);
  fflush(*v12);
  if (fgets(*((char **)*p_reply + 1), **p_reply, *v13))
  {
    v14[strcspn(v14, "\n")] = 0;
    goto LABEL_14;
  }
  return 1;
}

uint64_t krb5_prompter_print_only(uint64_t a1, uint64_t a2, const char *a3, const char *a4, int a5)
{
  FILE **v8;

  v8 = (FILE **)MEMORY[0x24BDAC8D8];
  if (a3)
  {
    fprintf((FILE *)*MEMORY[0x24BDAC8D8], "%s\n", a3);
    if (!a4)
      goto LABEL_6;
  }
  else if (!a4)
  {
    goto LABEL_7;
  }
  fprintf(*v8, "%s\n", a4);
LABEL_6:
  fflush(*v8);
LABEL_7:
  if (!a5)
    return 0;
  sub_20969D1E8(a1, 10, "prompter disabled");
  return 1;
}

krb5_error_code krb5_rd_cred(krb5_context a1, krb5_auth_context a2, krb5_data *a3, krb5_creds ***a4, krb5_replay_data *a5)
{
  krb5_error_code addrport;
  krb5_error_code v10;
  const krb5_keyblock *v11;
  krb5_creds **v12;
  krb5_creds *v13;
  uint64_t v14;
  uint64_t v16;
  __int16 v17;
  uint64_t v18;
  __int16 v19;
  int v20;
  krb5_creds **v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v24;
  uint64_t v25;
  _QWORD *v26;
  _QWORD *v27;
  size_t v28;
  void *v29;
  krb5_error_code v30;
  uint64_t v31;
  const char **v32;
  __int128 *v33;
  const char *v34;
  __int128 v35;
  _DWORD *v36;
  _QWORD *v37;
  _QWORD *v38;
  _QWORD *v39;
  _QWORD *v40;
  uint64_t v41;
  const char **v42;
  __int128 *v43;
  const char *v44;
  __int128 v45;
  krb5_address *const *v46;
  void *v47[2];
  uint64_t v48;
  krb5_keyblock **v49;
  uint64_t v50;
  uint64_t v51;
  __int128 v52;
  __int128 v53;
  __int128 v54;
  const krb5_address *v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  uint64_t v59;
  uint64_t v60;

  v60 = 0;
  v59 = 0;
  v57 = 0u;
  v58 = 0u;
  v56 = 0u;
  v50 = 0;
  v51 = 0;
  v49 = 0;
  v52 = 0u;
  v53 = 0u;
  v54 = 0u;
  v55 = 0;
  krb5_data_zero(&v50);
  if (!a5 && (*(_DWORD *)a2 & 0xA) != 0)
    return -1765328169;
  *a4 = 0;
  v10 = sub_2096BBFC0();
  if (v10)
  {
    addrport = v10;
    krb5_clear_error_message(a1);
    return addrport;
  }
  if ((_DWORD)v56 != 5)
  {
    krb5_clear_error_message(a1);
    addrport = -1765328345;
    goto LABEL_22;
  }
  if (DWORD1(v56) != 22)
  {
    krb5_clear_error_message(a1);
    addrport = -1765328344;
    goto LABEL_22;
  }
  if (DWORD2(v57))
  {
    addrport = krb5_crypto_init(a1, *((const krb5_keyblock **)a2 + 4), 0, &v49);
    if (addrport)
      goto LABEL_22;
    addrport = krb5_decrypt_EncryptedData(a1, (uint64_t)v49, 14, (uint64_t)&v57 + 8, &v50);
    krb5_crypto_destroy(a1, (uint64_t)v49);
    if (addrport)
    {
      v11 = (const krb5_keyblock *)*((_QWORD *)a2 + 6);
      if (!v11)
        goto LABEL_22;
      addrport = krb5_crypto_init(a1, v11, 0, &v49);
      if (addrport)
        goto LABEL_22;
      addrport = krb5_decrypt_EncryptedData(a1, (uint64_t)v49, 14, (uint64_t)&v57 + 8, &v50);
      krb5_crypto_destroy(a1, (uint64_t)v49);
      if (addrport)
        goto LABEL_22;
    }
  }
  else
  {
    v50 = *((_QWORD *)&v58 + 1);
    v51 = v59;
  }
  addrport = sub_2096BC020();
  if (v51 != v59)
    krb5_data_free(&v50);
  if (addrport)
  {
    krb5_set_error_message(a1, addrport, "Failed to decode encrypte credential part");
    goto LABEL_22;
  }
  if (*((_QWORD *)&v54 + 1))
  {
    v16 = *((_QWORD *)a2 + 2);
    if (v16)
    {
      v17 = *((_WORD *)a2 + 13);
      if (v17)
      {
        v47[0] = 0;
        addrport = krb5_make_addrport(a1, v47, v16, v17);
        if (addrport
          || (addrport = sub_2096A7AEC(a1, (const krb5_address *)v47[0], *((const krb5_address **)&v54 + 1), "sender address is wrong in received creds"), krb5_free_address((uint64_t)a1, (uint64_t)v47[0]), free(v47[0]), addrport))
        {
LABEL_22:
          sub_2096BC070();
          sub_2096BC010();
          v12 = *a4;
          if (*a4)
          {
            v13 = *v12;
            if (*v12)
            {
              v14 = 1;
              do
              {
                krb5_free_creds(a1, v13);
                v12 = *a4;
                v13 = (*a4)[v14++];
              }
              while (v13);
            }
            free(v12);
            *a4 = 0;
          }
          return addrport;
        }
      }
    }
  }
  if (v55)
  {
    v18 = *((_QWORD *)a2 + 1);
    if (v18)
    {
      v19 = *((_WORD *)a2 + 12);
      if (v19 && v55->magic == 256)
      {
        v47[0] = 0;
        addrport = krb5_make_addrport(a1, v47, v18, v19);
        if (!addrport)
        {
          addrport = sub_2096A7AEC(a1, (const krb5_address *)v47[0], v55, "receiver address is wrong in received creds");
          krb5_free_address((uint64_t)a1, (uint64_t)v47[0]);
          free(v47[0]);
          if (!addrport)
            goto LABEL_41;
        }
        goto LABEL_22;
      }
      addrport = sub_2096A7AEC(a1, *((const krb5_address **)a2 + 1), v55, "receiver address is wrong in received creds");
      if (addrport)
        goto LABEL_22;
    }
  }
LABEL_41:
  v20 = *(_DWORD *)a2;
  if ((*(_DWORD *)a2 & 1) != 0)
  {
    v47[0] = 0;
    krb5_timeofday(a1, (krb5_timestamp *)v47);
    if (!*((_QWORD *)&v53 + 1)
      || !(_QWORD)v54
      || krb5_time_abs(**((_QWORD **)&v53 + 1), (uint64_t)v47[0]) > *((_QWORD *)a1 + 10))
    {
      krb5_clear_error_message(a1);
      addrport = -1765328347;
      goto LABEL_22;
    }
    v20 = *(_DWORD *)a2;
  }
  if ((v20 & 0xA) != 0)
  {
    *(_QWORD *)&a5->timestamp = 0;
    *(_QWORD *)&a5->seq = 0;
    if (*((_QWORD *)&v53 + 1))
      *(_QWORD *)&a5->timestamp = **((_QWORD **)&v53 + 1);
    if ((_QWORD)v54)
      a5->seq = *(_DWORD *)v54;
    if ((_QWORD)v53)
      a5[1].timestamp = *(_DWORD *)v53;
  }
  v21 = (krb5_creds **)malloc_type_calloc((v52 + 1), 8uLL, 0x2004093837F09uLL);
  *a4 = v21;
  if (!v21)
  {
LABEL_80:
    addrport = 12;
    krb5_set_error_message(a1, 12, "malloc: out of memory");
    goto LABEL_22;
  }
  if ((_DWORD)v52)
  {
    v22 = 0;
    v23 = 0;
    v24 = 0;
    while (1)
    {
      v25 = *((_QWORD *)&v52 + 1);
      v26 = malloc_type_calloc(1uLL, 0x90uLL, 0x10A0040AAA52FDDuLL);
      if (!v26)
        goto LABEL_80;
      v27 = v26;
      v28 = sub_2096BB7F4();
      v27[9] = v28;
      v29 = malloc_type_malloc(v28, 0x40D7D8ACuLL);
      v27[10] = v29;
      if (!v29)
        break;
      v30 = sub_2096BB7D4();
      if (v30)
      {
        addrport = v30;
        free((void *)v27[10]);
        v27[10] = 0;
        goto LABEL_86;
      }
      if (v27[9] != v60)
        krb5_abortx(a1, "internal error in ASN.1 encoder");
      copy_EncryptionKey();
      v31 = v25 + v22;
      v32 = *(const char ***)(v25 + v22 + 24);
      if (v32)
      {
        v33 = *(__int128 **)(v31 + 32);
        if (v33)
        {
          v34 = *v32;
          v35 = *v33;
          v48 = *((_QWORD *)v33 + 2);
          *(_OWORD *)v47 = v35;
          _krb5_principalname2krb5_principal((uint64_t)a1, v27, (uint64_t)v47, v34);
        }
      }
      v36 = *(_DWORD **)(v31 + 40);
      if (v36)
        *((_DWORD *)v27 + 34) = *v36;
      v37 = *(_QWORD **)(v25 + v22 + 48);
      if (v37)
        v27[5] = *v37;
      v38 = *(_QWORD **)(v25 + v22 + 56);
      if (v38)
        v27[6] = *v38;
      v39 = *(_QWORD **)(v25 + v22 + 64);
      if (v39)
        v27[7] = *v39;
      v40 = *(_QWORD **)(v25 + v22 + 72);
      if (v40)
        v27[8] = *v40;
      v41 = v25 + v22;
      v42 = *(const char ***)(v25 + v22 + 80);
      if (v42)
      {
        v43 = *(__int128 **)(v41 + 88);
        if (v43)
        {
          v44 = *v42;
          v45 = *v43;
          v48 = *((_QWORD *)v43 + 2);
          *(_OWORD *)v47 = v45;
          _krb5_principalname2krb5_principal((uint64_t)a1, v27 + 1, (uint64_t)v47, v44);
        }
      }
      v46 = *(krb5_address *const **)(v41 + 96);
      if (v46)
        krb5_copy_addresses(a1, v46, (krb5_address ***)v27 + 15);
      (*a4)[v24++] = (krb5_creds *)v27;
      v23 += 72;
      v22 += 104;
      if (v24 >= v52)
      {
        v21 = *a4;
        goto LABEL_82;
      }
    }
    addrport = 12;
LABEL_86:
    free(v27);
    goto LABEL_22;
  }
  v24 = 0;
LABEL_82:
  v21[v24] = 0;
  sub_2096BC010();
  sub_2096BC070();
  return 0;
}

uint64_t sub_2096A7AEC(_krb5_context *a1, const krb5_address *a2, const krb5_address *a3, const char *a4)
{
  uint64_t v8;
  uint64_t v10;
  char v11[64];
  char __str[64];
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  if (krb5_address_compare(a1, a2, a3))
    return 0;
  v8 = 2529638950;
  v10 = 0;
  krb5_print_address((uint64_t)a2, __str, 0x40uLL, &v10);
  krb5_print_address((uint64_t)a3, v11, 0x40uLL, &v10);
  krb5_set_error_message(a1, -1765328346, "%s: %s != %s", a4, v11, __str);
  return v8;
}

uint64_t krb5_rd_cred2(_krb5_context *a1, _krb5_auth_context *a2, _krb5_ccache *a3, krb5_data *a4)
{
  uint64_t result;
  krb5_creds **v7;
  krb5_creds *v8;
  krb5_creds **v9;
  krb5_creds *v10;
  krb5_creds **v11;

  v11 = 0;
  result = krb5_rd_cred(a1, a2, a4, &v11, 0);
  if (!(_DWORD)result)
  {
    v7 = v11;
    if (v11)
    {
      v8 = *v11;
      if (*v11)
      {
        v9 = v11 + 1;
        do
        {
          krb5_cc_store_cred(a1, a3, v8);
          krb5_free_creds(a1, *(v9 - 1));
          v10 = *v9++;
          v8 = v10;
        }
        while (v10);
      }
    }
    free(v7);
    return 0;
  }
  return result;
}

krb5_error_code krb5_rd_error(krb5_context a1, const krb5_data *a2, krb5_error **a3)
{
  krb5_error_code v5;

  v5 = sub_2096BC080();
  if (v5)
    krb5_clear_error_message(a1);
  else
    *((_DWORD *)a3 + 9) -= 1765328384;
  return v5;
}

double krb5_free_error_contents(uint64_t a1, uint64_t a2)
{
  double result;

  sub_2096BC0D0();
  *(_QWORD *)(a2 + 96) = 0;
  result = 0.0;
  *(_OWORD *)(a2 + 64) = 0u;
  *(_OWORD *)(a2 + 80) = 0u;
  *(_OWORD *)(a2 + 32) = 0u;
  *(_OWORD *)(a2 + 48) = 0u;
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  return result;
}

void krb5_free_error(krb5_context a1, krb5_error *a2)
{
  sub_2096BC0D0();
  a2[1].client = 0;
  *(_OWORD *)&a2->e_data.data = 0u;
  *(_OWORD *)&a2[1].cusec = 0u;
  *(_OWORD *)&a2->server = 0u;
  *(_OWORD *)&a2->text.data = 0u;
  *(_OWORD *)&a2->magic = 0u;
  *(_OWORD *)&a2->stime = 0u;
  free(a2);
}

uint64_t krb5_error_from_rd_error(krb5_context a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v4;
  _BYTE v7[256];
  _BYTE v8[256];
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v4 = *(unsigned int *)(a2 + 36);
  if (*(_QWORD *)(a2 + 88))
  {
    krb5_set_error_message(a1, v4, "Error from KDC: %s");
  }
  else
  {
    if (a3)
    {
      krb5_unparse_name_fixed(a1, *a3, (uint64_t)v8, 0x100uLL);
      krb5_unparse_name_fixed(a1, a3[1], (uint64_t)v7, 0x100uLL);
    }
    switch(v4)
    {
      case 0x96C73A01:
        krb5_set_error_message(a1, -1765328383, "Client %s%s%s expired");
        break;
      case 0x96C73A02:
        krb5_set_error_message(a1, -1765328382, "Server %s%s%s expired");
        break;
      case 0x96C73A06:
        krb5_set_error_message(a1, -1765328378, "Client %s%s%s unknown");
        break;
      case 0x96C73A07:
        krb5_set_error_message(a1, -1765328377, "Server %s%s%s unknown");
        break;
      default:
        krb5_clear_error_message(a1);
        break;
    }
  }
  return v4;
}

krb5_error_code krb5_rd_priv(krb5_context a1, krb5_auth_context a2, const krb5_data *a3, krb5_data *a4, krb5_replay_data *a5)
{
  krb5_error_code v9;
  krb5_error_code v10;
  const krb5_keyblock *v11;
  const krb5_address *v12;
  const krb5_address *v13;
  krb5_magic magic;
  krb5_timestamp v16[2];
  krb5_keyblock **v17;
  _QWORD v18[3];
  __int128 v19;
  __int128 v20;
  krb5_address *v21[2];
  krb5_address *v22;
  _OWORD v23[2];
  uint64_t v24;

  krb5_data_zero(a4);
  if ((*(_BYTE *)a2 & 0xA) == 0)
  {
LABEL_4:
    v22 = 0;
    v20 = 0u;
    *(_OWORD *)v21 = 0u;
    v19 = 0u;
    v17 = 0;
    memset(v18, 0, sizeof(v18));
    memset(v23, 0, sizeof(v23));
    v24 = 0;
    v9 = sub_2096BBF00();
    if (v9)
    {
      v10 = v9;
      goto LABEL_6;
    }
    if (LODWORD(v23[0]) != 5)
    {
      krb5_clear_error_message(a1);
      v10 = -1765328345;
      goto LABEL_29;
    }
    if (DWORD1(v23[0]) != 21)
    {
      krb5_clear_error_message(a1);
      v10 = -1765328344;
      goto LABEL_29;
    }
    v11 = (const krb5_keyblock *)*((_QWORD *)a2 + 6);
    if (!v11)
    {
      v11 = (const krb5_keyblock *)*((_QWORD *)a2 + 5);
      if (!v11)
        v11 = (const krb5_keyblock *)*((_QWORD *)a2 + 4);
    }
    v10 = krb5_crypto_init(a1, v11, 0, &v17);
    if (v10)
      goto LABEL_29;
    v10 = krb5_decrypt_EncryptedData(a1, (uint64_t)v17, 13, (uint64_t)v23 + 8, v18);
    krb5_crypto_destroy(a1, (uint64_t)v17);
    if (v10)
      goto LABEL_29;
    v10 = sub_2096BBF60();
    krb5_data_free(v18);
    if (v10)
    {
LABEL_6:
      krb5_clear_error_message(a1);
LABEL_29:
      sub_2096BBF50();
      return v10;
    }
    if (v21[1] && (v12 = (const krb5_address *)*((_QWORD *)a2 + 2)) != 0 && !krb5_address_compare(a1, v12, v21[1])
      || v22 && (v13 = (const krb5_address *)*((_QWORD *)a2 + 1)) != 0 && !krb5_address_compare(a1, v13, v22))
    {
      v10 = -1765328346;
      krb5_clear_error_message(a1);
      goto LABEL_48;
    }
    if ((*(_DWORD *)a2 & 1) != 0)
    {
      *(_QWORD *)v16 = 0;
      krb5_timeofday(a1, v16);
      if (!(_QWORD)v20
        || !*((_QWORD *)&v20 + 1)
        || krb5_time_abs(*(_QWORD *)v20, *(uint64_t *)v16) > *((_QWORD *)a1 + 10))
      {
        krb5_clear_error_message(a1);
        v10 = -1765328347;
        goto LABEL_48;
      }
      if ((*(_DWORD *)a2 & 4) == 0)
      {
LABEL_37:
        v10 = krb5_data_copy(a4, *((const void **)&v19 + 1), v19);
        if (!v10)
        {
          if ((*(_BYTE *)a2 & 0xA) == 0)
            goto LABEL_47;
          if ((_QWORD)v20)
            *(_QWORD *)&a5->timestamp = *(_QWORD *)v20;
          if (*((_QWORD *)&v20 + 1))
            a5->seq = **((_DWORD **)&v20 + 1);
          if (v21[0])
          {
            v10 = 0;
            a5[1].timestamp = v21[0]->magic;
          }
          else
          {
LABEL_47:
            v10 = 0;
          }
        }
        goto LABEL_48;
      }
    }
    else if ((*(_DWORD *)a2 & 4) == 0)
    {
      goto LABEL_37;
    }
    if (v21[0])
    {
      magic = v21[0]->magic;
      if (v21[0]->magic == *((_DWORD *)a2 + 15))
      {
LABEL_25:
        *((_DWORD *)a2 + 15) = magic + 1;
        goto LABEL_37;
      }
    }
    else
    {
      magic = *((_DWORD *)a2 + 15);
      if (!magic)
        goto LABEL_25;
    }
    krb5_clear_error_message(a1);
    v10 = -1765328342;
LABEL_48:
    sub_2096BBFB0();
    goto LABEL_29;
  }
  if (a5)
  {
    *(_QWORD *)&a5->timestamp = 0;
    *(_QWORD *)&a5->seq = 0;
    goto LABEL_4;
  }
  krb5_clear_error_message(a1);
  return -1765328169;
}

uint64_t sub_2096A8240(_krb5_context *a1, uint64_t a2, const char *a3, __int128 *a4, _QWORD *a5)
{
  size_t v8;
  void *v9;
  void *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  void *v20;
  void *v21;
  uint64_t v22;
  uint64_t v23;
  void *v24;
  NSObject *v25;
  void *v26;
  krb5_error_code v27;
  int v28;
  int v29;
  krb5_error_code v30;
  char v32;
  _QWORD v33[2];
  __int128 v34;
  uint64_t *v35;
  uint64_t v36;
  uint64_t v37;
  _QWORD v38[8];
  uint64_t v39;
  uint64_t *v40;
  uint64_t v41;
  void (*v42)(uint64_t, uint64_t);
  void (*v43)(uint64_t);
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t *v47;
  uint64_t v48;
  int v49;
  __int128 v50;
  __int128 v51;

  v36 = 0;
  v37 = a2;
  v34 = *a4;
  v35 = &v37;
  v8 = length_KDC_PROXY_MESSAGE();
  v33[0] = v8;
  v9 = malloc_type_malloc(v8, 0x4BB3E7AEuLL);
  v33[1] = v9;
  if (!v9)
    return 12;
  v10 = v9;
  v11 = encode_KDC_PROXY_MESSAGE();
  if (!(_DWORD)v11)
  {
    if (v8)
      heim_abort("internal asn1. encoder error:msgdata.length == size", v12, v13, v14, v15, v16, v17, v18, v32);
    v50 = 0u;
    v51 = 0u;
    v46 = 0;
    v47 = &v46;
    v48 = 0x2020000000;
    v49 = 0;
    v45 = 0;
    v20 = (void *)MEMORY[0x20BD125D0]();
    v39 = 0;
    v40 = &v39;
    v41 = 0x3052000000;
    v42 = sub_2096A85F4;
    v43 = sub_2096A8604;
    v44 = 0;
    v21 = (void *)objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", a3);
    sub_20969D1E8((uint64_t)a1, 5, "kkdcp request to url: %s", (const char *)objc_msgSend(v21, "UTF8String"));
    v22 = objc_msgSend(MEMORY[0x24BDBCF48], "URLWithString:", v21);
    if (v22)
    {
      v23 = objc_msgSend(objc_alloc(MEMORY[0x24BDBCE50]), "initWithBytesNoCopy:length:", v10, v8);
      v24 = (void *)objc_msgSend(MEMORY[0x24BDD16B0], "requestWithURL:", v22);
      objc_msgSend(v24, "setHTTPMethod:", CFSTR("POST"));
      objc_msgSend(v24, "setHTTPBody:", v23);
      objc_msgSend(v24, "addValue:forHTTPHeaderField:", CFSTR("application/octet-stream"), CFSTR("Content-Type"));
      objc_msgSend(v24, "addValue:forHTTPHeaderField:", CFSTR("Heimdal 1.5.1apple1"), CFSTR("X-Kerberos-Client"));
      _CFURLRequestSetAllowedProtocolTypes();
      v25 = dispatch_semaphore_create(0);
      v26 = (void *)objc_msgSend(MEMORY[0x24BDD1850], "sessionWithConfiguration:", objc_msgSend(MEMORY[0x24BDD1858], "ephemeralSessionConfiguration"));
      v38[0] = MEMORY[0x24BDAC760];
      v38[1] = 3221225472;
      v38[2] = sub_2096A8610;
      v38[3] = &unk_24C1F27F8;
      v38[6] = &v39;
      v38[7] = a1;
      v38[4] = v25;
      v38[5] = &v46;
      objc_msgSend((id)objc_msgSend(v26, "dataTaskWithRequest:completionHandler:", v24, v38), "resume");
      dispatch_semaphore_wait(v25, 0xFFFFFFFFFFFFFFFFLL);
      objc_msgSend((id)v40[5], "bytes");
      objc_msgSend((id)v40[5], "length");
      v27 = decode_KDC_PROXY_MESSAGE();
      *((_DWORD *)v47 + 6) = v27;
      if (v27)
      {
        krb5_set_error_message(a1, v27, "failed to decode KDC_PROXY_MESSAGE");
        v28 = 0;
      }
      else
      {
        v28 = 1;
      }
    }
    else
    {
      v28 = 0;
      *((_DWORD *)v47 + 6) = 12;
    }
    _Block_object_dispose(&v39, 8);
    objc_autoreleasePoolPop(v20);
    if (v28)
    {
      v29 = krb5_data_copy(a5, *((const void **)&v50 + 1), v50);
      *((_DWORD *)v47 + 6) = v29;
      sub_2096BC3F4();
      v30 = *((_DWORD *)v47 + 6);
      if (!v30)
      {
        v19 = 0;
        *((_DWORD *)v47 + 6) = 0;
LABEL_17:
        _Block_object_dispose(&v46, 8);
        krb5_data_free(v33);
        return v19;
      }
    }
    else
    {
      v30 = *((_DWORD *)v47 + 6);
      if (!v30)
      {
        v19 = 0;
        goto LABEL_17;
      }
    }
    sub_20969D22C((uint64_t *)a1, 10, v30, "kkdcp to url (%s) failed", a3);
    v19 = *((unsigned int *)v47 + 6);
    goto LABEL_17;
  }
  v19 = v11;
  free(v10);
  return v19;
}

void sub_2096A85C4(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 128), 8);
  _Unwind_Resume(a1);
}

void sub_2096A85F4(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

void sub_2096A8604(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

intptr_t sub_2096A8610(uint64_t a1, void *a2, uint64_t a3, void *a4)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  char v12;

  if (a4)
  {
    sub_20969D1E8(*(_QWORD *)(a1 + 56), 5, "kkdcp response error: %s", (const char *)objc_msgSend((id)objc_msgSend(a4, "localizedDescription"), "UTF8String"));
    *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = -1980176635;
    sub_2096895C4(*(_krb5_context **)(a1 + 56), *(unsigned int *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24), (__CFError *)a4, "Failure during kkdcp stream", v7, v8, v9, v10, v12);
  }
  if (a2)
  {
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 40) = objc_msgSend(a2, "copy");
    sub_20969D1E8(*(_QWORD *)(a1 + 56), 5, "kkdcp response received: %lu", objc_msgSend(a2, "length"));
  }
  return dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 32));
}

krb5_error_code krb5_rd_rep(krb5_context a1, krb5_auth_context a2, const krb5_data *a3, krb5_ap_rep_enc_part **a4)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  krb5_error_code v12;
  krb5_ap_rep_enc_part *v14;
  krb5_error_code v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  krb5_ap_rep_enc_part *v20;
  int *v21;
  krb5_keyblock *subkey;
  uint64_t v23;
  krb5_keyblock **v24;
  _QWORD v25[3];
  _OWORD v26[2];
  __int128 v27;

  v27 = 0u;
  memset(v26, 0, sizeof(v26));
  v24 = 0;
  memset(v25, 0, sizeof(v25));
  krb5_data_zero(v25);
  v12 = sub_2096BBDE0();
  if (!v12)
  {
    if (LODWORD(v26[0]) != 5)
    {
      v12 = -1765328345;
      krb5_clear_error_message(a1);
      goto LABEL_13;
    }
    if (DWORD1(v26[0]) != 15)
    {
      krb5_clear_error_message(a1);
      v12 = -1765328344;
      goto LABEL_13;
    }
    if (*((_QWORD *)&v27 + 1) && *((_QWORD *)a2 + 13))
    {
      v12 = sub_2096AF548(a1, (uint64_t)a2, (uint64_t)v26, v7, v8, v9, v10, v11);
      if (v12)
        goto LABEL_13;
    }
    else
    {
      sub_2096AE778(a1, (uint64_t)a2);
    }
    v12 = krb5_crypto_init(a1, *((const krb5_keyblock **)a2 + 4), 0, &v24);
    if (v12)
      goto LABEL_13;
    v12 = krb5_decrypt_EncryptedData(a1, (uint64_t)v24, 12, (uint64_t)v26 + 8, v25);
    krb5_crypto_destroy(a1, (uint64_t)v24);
    if (v12)
      goto LABEL_13;
    v14 = (krb5_ap_rep_enc_part *)malloc_type_malloc(0x20uLL, 0x103004059AAC8DEuLL);
    *a4 = v14;
    if (v14)
    {
      v15 = sub_2096BBE40();
      if (v15)
      {
        v12 = v15;
        krb5_set_error_message(a1, v15, "Failed to decode EncAPRepPart");
        return v12;
      }
      v20 = *a4;
      if ((*(_BYTE *)a2 & 1) != 0)
      {
        v23 = *((_QWORD *)a2 + 8);
        if (*(_QWORD *)&v20->magic != *(_QWORD *)(v23 + 56) || v20->cusec != *(_DWORD *)(v23 + 48))
        {
          sub_2096BBE90();
          free(v20);
          *a4 = 0;
          krb5_clear_error_message(a1);
          v12 = -1765328338;
          goto LABEL_13;
        }
      }
      v21 = *(int **)&v20->seq_number;
      if (v21)
      {
        krb5_auth_con_setremoteseqnumber((uint64_t)a1, (uint64_t)a2, *v21);
        v20 = *a4;
      }
      subkey = v20->subkey;
      if (!subkey)
      {
LABEL_32:
        v12 = 0;
        goto LABEL_13;
      }
      if (!*((_QWORD *)&v27 + 1) || !*((_QWORD *)a2 + 13))
      {
        sub_20969D1E8((uint64_t)a1, 10, "krb5_rd_rep not using PFS", v24);
LABEL_31:
        krb5_auth_con_setremotesubkey(a1, (krb5_keyblock **)a2, (*a4)->subkey);
        goto LABEL_32;
      }
      v12 = sub_2096AE7F0(a1, (uint64_t)a2, "server key", subkey, v16, v17, v18, v19);
      if (!v12)
        goto LABEL_31;
    }
    else
    {
      v12 = 12;
      krb5_set_error_message(a1, 12, "malloc: out of memory");
    }
LABEL_13:
    sub_2096AE778(a1, (uint64_t)a2);
    krb5_data_free(v25);
    sub_2096BBE30();
  }
  return v12;
}

void krb5_free_ap_rep_enc_part(krb5_context a1, krb5_ap_rep_enc_part *a2)
{
  if (a2)
  {
    sub_2096BBE90();
    free(a2);
  }
}

uint64_t krb5_decode_ap_req(_krb5_context *a1, uint64_t a2, _DWORD *a3)
{
  uint64_t v5;

  v5 = sub_2096BBD80();
  if (!(_DWORD)v5)
  {
    v5 = 2529638951;
    if (*a3 == 5)
    {
      if (a3[1] == 14)
      {
        if (a3[4] == 5)
          return 0;
      }
      else
      {
        v5 = 2529638952;
      }
    }
    sub_2096BBDD0();
    krb5_clear_error_message(a1);
  }
  return v5;
}

uint64_t krb5_decrypt_ticket(_krb5_context *a1, uint64_t a2, const krb5_keyblock *a3, uint64_t a4)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  krb5_keyblock **v11;
  krb5_timestamp v12[2];
  _QWORD v13[2];

  v13[0] = 0;
  v13[1] = 0;
  v11 = 0;
  *(_QWORD *)v12 = 0;
  v7 = krb5_crypto_init(a1, a3, 0, &v11);
  if (!(_DWORD)v7)
  {
    v7 = krb5_decrypt_EncryptedData(a1, (uint64_t)v11, 2, a2 + 40, v13);
    krb5_crypto_destroy(a1, (uint64_t)v11);
    if (!(_DWORD)v7)
    {
      v8 = sub_2096BB828();
      if ((_DWORD)v8)
      {
        v7 = v8;
        krb5_set_error_message(a1, v8, "Failed to decode encrypted ticket part");
        krb5_data_free(v13);
      }
      else
      {
        krb5_data_free(v13);
        *(_QWORD *)v12 = 0;
        krb5_timeofday(a1, v12);
        v9 = *((_QWORD *)a1 + 10);
        if (-*(_QWORD *)v12 <= v9)
        {
          if (*(uint64_t *)v12 <= v9)
          {
            if (a4)
            {
              v7 = 0;
              *(_QWORD *)(a4 + 128) = 0;
              *(_OWORD *)(a4 + 96) = 0u;
              *(_OWORD *)(a4 + 112) = 0u;
              *(_OWORD *)(a4 + 32) = 0u;
              *(_OWORD *)(a4 + 48) = 0u;
              *(_OWORD *)(a4 + 64) = 0u;
              *(_OWORD *)(a4 + 80) = 0u;
              *(_OWORD *)a4 = 0u;
              *(_OWORD *)(a4 + 16) = 0u;
            }
            else
            {
              sub_2096BB848();
              return 0;
            }
          }
          else
          {
            sub_2096BB848();
            krb5_clear_error_message(a1);
            return 2529638944;
          }
        }
        else
        {
          sub_2096BB848();
          krb5_clear_error_message(a1);
          return 2529638945;
        }
      }
    }
  }
  return v7;
}

uint64_t krb5_verify_authenticator_checksum(_krb5_context *a1, _krb5_auth_context *a2, const void *a3, size_t a4)
{
  uint64_t v8;
  uint64_t v10;
  size_t v11;
  krb5_keyblock **v12;
  krb5_authenticator v13;

  *(_QWORD *)&v13.magic = 0;
  v13.client = 0;
  v12 = 0;
  v8 = krb5_auth_con_getauthenticator(a1, a2, (krb5_authenticator **)&v13);
  if (!(_DWORD)v8)
  {
    if (*(_QWORD *)(*(_QWORD *)&v13.magic + 40))
    {
      v10 = krb5_auth_con_getkey(a1, a2, (krb5_keyblock **)&v13.client);
      if ((_DWORD)v10)
      {
        v8 = v10;
        krb5_free_authenticator(a1, &v13);
      }
      else
      {
        v8 = krb5_crypto_init(a1, (const krb5_keyblock *)v13.client, 0, &v12);
        if (!(_DWORD)v8)
        {
          v8 = krb5_verify_checksum(a1, (krb5_cksumtype)v12, (const krb5_checksum *)0xA, a3, a4, *(krb5_const_pointer *)(*(_QWORD *)&v13.magic + 40), v11);
          krb5_crypto_destroy(a1, (uint64_t)v12);
        }
        krb5_free_authenticator(a1, &v13);
        krb5_free_keyblock(a1, (krb5_keyblock *)v13.client);
      }
    }
    else
    {
      krb5_free_authenticator(a1, &v13);
      return 4294967279;
    }
  }
  return v8;
}

uint64_t krb5_verify_ap_req(_krb5_context *a1, krb5_auth_context *a2, uint64_t a3, int a4, const krb5_keyblock *a5, int a6, int *a7, _QWORD *a8)
{
  return krb5_verify_ap_req2(a1, a2, a3, a4, a5, a6, a7, a8, 0xBu);
}

uint64_t krb5_verify_ap_req2(krb5_context a1, krb5_auth_context *a2, uint64_t a3, int a4, const krb5_keyblock *a5, int a6, int *a7, _QWORD *a8, unsigned int a9)
{
  uint64_t v15;
  char *v16;
  char *v17;
  const krb5_keyblock *v18;
  const char *v19;
  const char *v20;
  uint64_t v21;
  uint64_t v23;
  const char *v24;
  const char *v25;
  krb5_BOOLean v26;
  krb5_address *const *v27;
  const krb5_address *v28;
  krb5_auth_context v29;
  uint64_t v30;
  int *v31;
  krb5_keyblock *v32;
  uint64_t v33;
  int v34;
  int v35;
  int v36;
  krb5_timestamp v37[4];
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  krb5_auth_context v41;
  krb5_principal v42;
  krb5_principal v43;

  v39 = 0;
  v40 = 0;
  if (a8)
    *a8 = 0;
  v41 = 0;
  if (a2 && *a2)
  {
    v41 = *a2;
  }
  else
  {
    v15 = krb5_auth_con_init(a1, &v41);
    if ((_DWORD)v15)
      return v15;
  }
  v16 = (char *)malloc_type_calloc(1uLL, 0x98uLL, 0x10B0040764A81A9uLL);
  if (!v16)
  {
    krb5_clear_error_message(a1);
    sub_2096BC190();
    v15 = 12;
    if (!a2)
    {
LABEL_25:
      krb5_auth_con_free(a1, v41);
      return v15;
    }
    goto LABEL_24;
  }
  v17 = v16;
  if ((*(_BYTE *)(a3 + 8) & 2) != 0 && (v18 = (const krb5_keyblock *)*((_QWORD *)v41 + 4)) != 0)
  {
    v15 = krb5_decrypt_ticket(a1, a3 + 16, v18, (uint64_t)v16);
    krb5_free_keyblock(a1, *((krb5_keyblock **)v41 + 4));
    *((_QWORD *)v41 + 4) = 0;
    if ((_DWORD)v15)
      goto LABEL_21;
  }
  else
  {
    v15 = krb5_decrypt_ticket(a1, a3 + 16, a5, (uint64_t)v16);
    if ((_DWORD)v15)
      goto LABEL_21;
  }
  v19 = *(const char **)(a3 + 24);
  *(_OWORD *)v37 = *(_OWORD *)(a3 + 32);
  v38 = *(_QWORD *)(a3 + 48);
  v15 = _krb5_principalname2krb5_principal((uint64_t)a1, (_QWORD *)v17 + 18, (uint64_t)v37, v19);
  if (!(_DWORD)v15)
  {
    v20 = (const char *)*((_QWORD *)v17 + 4);
    *(_OWORD *)v37 = *(_OWORD *)(v17 + 40);
    v38 = *((_QWORD *)v17 + 7);
    v15 = _krb5_principalname2krb5_principal((uint64_t)a1, (_QWORD *)v17 + 17, (uint64_t)v37, v20);
    if (!(_DWORD)v15)
    {
      memset(v37, 0, sizeof(v37));
      v42 = 0;
      v43 = 0;
      v15 = krb5_crypto_init(a1, (const krb5_keyblock *)(v17 + 8), 0, (krb5_keyblock ***)&v42);
      if (!(_DWORD)v15)
      {
        v21 = krb5_decrypt_EncryptedData(a1, (uint64_t)v42, a9, a3 + 88, v37);
        v15 = v21;
        if (a9 == 7 && (_DWORD)v21)
          v15 = krb5_decrypt_EncryptedData(a1, (uint64_t)v42, 11, a3 + 88, v37);
        krb5_crypto_destroy(a1, (uint64_t)v42);
        if (!(_DWORD)v15)
        {
          v15 = sub_2096BB8E0();
          krb5_data_free(v37);
          if (!(_DWORD)v15)
          {
            v42 = 0;
            v43 = 0;
            v23 = *((_QWORD *)v41 + 8);
            v24 = *(const char **)(v23 + 8);
            *(_OWORD *)v37 = *(_OWORD *)(v23 + 16);
            v38 = *(_QWORD *)(v23 + 32);
            _krb5_principalname2krb5_principal((uint64_t)a1, &v43, (uint64_t)v37, v24);
            v25 = (const char *)*((_QWORD *)v17 + 4);
            *(_OWORD *)v37 = *(_OWORD *)(v17 + 40);
            v38 = *((_QWORD *)v17 + 7);
            _krb5_principalname2krb5_principal((uint64_t)a1, &v42, (uint64_t)v37, v25);
            v26 = krb5_principal_compare(a1, v43, v42);
            krb5_free_principal(a1, v43);
            krb5_free_principal(a1, v42);
            if (!v26)
            {
              v15 = 2529638948;
              krb5_clear_error_message(a1);
              goto LABEL_21;
            }
            v27 = (krb5_address *const *)*((_QWORD *)v17 + 15);
            if (!v27 || (v28 = (const krb5_address *)*((_QWORD *)v41 + 2)) == 0 || krb5_address_search(a1, v28, v27))
            {
              *(_QWORD *)v37 = 0;
              krb5_timeofday(a1, v37);
              if (krb5_time_abs(*(_QWORD *)(*((_QWORD *)v41 + 8) + 56), *(uint64_t *)v37) > *((_QWORD *)a1 + 10))
              {
                krb5_clear_error_message(a1);
                v15 = 2529638949;
                goto LABEL_21;
              }
              v29 = v41;
              if (*((_QWORD *)v41 + 10))
              {
                v15 = krb5_rc_store((uint64_t)a1, *((_QWORD *)v41 + 10));
                if ((_DWORD)v15)
                  goto LABEL_21;
                v29 = v41;
              }
              v30 = *((_QWORD *)v29 + 8);
              v31 = *(int **)(v30 + 72);
              if (v31)
              {
                krb5_auth_con_setremoteseqnumber((uint64_t)a1, (uint64_t)v29, *v31);
                v29 = v41;
                v30 = *((_QWORD *)v41 + 8);
              }
              v32 = *(krb5_keyblock **)(v30 + 64);
              if (v32)
              {
                v15 = krb5_auth_con_setremotesubkey(a1, (krb5_keyblock **)v29, v32);
                if ((_DWORD)v15)
                  goto LABEL_21;
                v29 = v41;
              }
              v15 = sub_2096A92FC(a1, (uint64_t)v29);
              if (!(_DWORD)v15)
              {
                *((_DWORD *)v41 + 22) = 0;
                if (v40 && (_DWORD)v39)
                {
                  v33 = 0;
                  while (krb5_enctype_valid(a1, (char *)*(unsigned int *)(v40 + 4 * v33)))
                  {
                    if (++v33 >= (unint64_t)v39)
                      goto LABEL_51;
                  }
                  v34 = *(_DWORD *)(v40 + 4 * v33);
                  *((_DWORD *)v41 + 22) = v34;
                  sub_20969D1E8((uint64_t)a1, 10, "ap_req2: upgrading to enctype: %d", v34);
                }
LABEL_51:
                v15 = krb5_copy_keyblock(a1, (const krb5_keyblock *)(v17 + 8), (krb5_keyblock **)v41 + 4);
                if (!(_DWORD)v15)
                {
                  if (a7)
                  {
                    v35 = 4 * (*((_DWORD *)v41 + 22) != 0);
                    *a7 = v35;
                    v36 = *(_DWORD *)(a3 + 8);
                    if ((v36 & 2) != 0)
                    {
                      v35 |= 1u;
                      *a7 = v35;
                      v36 = *(_DWORD *)(a3 + 8);
                    }
                    if ((v36 & 4) != 0)
                      *a7 = v35 | 2;
                  }
                  if (a8)
                    *a8 = v17;
                  else
                    krb5_free_ticket(a1, (krb5_ticket *)v17);
                  if (a2)
                  {
                    if (!*a2)
                      *a2 = v41;
                  }
                  else
                  {
                    krb5_auth_con_free(a1, v41);
                  }
                  sub_2096BC190();
                  return 0;
                }
              }
              goto LABEL_21;
            }
            krb5_clear_error_message(a1);
            v15 = 2529638950;
          }
        }
      }
    }
  }
LABEL_21:
  sub_2096BC190();
  krb5_free_ticket(a1, (krb5_ticket *)v17);
  if (!a2)
    goto LABEL_25;
LABEL_24:
  if (!*a2)
    goto LABEL_25;
  return v15;
}

uint64_t sub_2096A92FC(_krb5_context *a1, uint64_t a2)
{
  uint64_t v3;
  _QWORD v5[2];

  v5[0] = 0;
  v5[1] = 0;
  if (_krb5_get_ad(a1, *(unsigned int **)(*(_QWORD *)(a2 + 64) + 80), 0, 129, v5))
    return 0;
  v3 = sub_2096BC140();
  krb5_data_free(v5);
  if ((_DWORD)v3)
    krb5_clear_error_message(a1);
  return v3;
}

uint64_t krb5_rd_req_in_ctx_alloc(_krb5_context *a1, _QWORD *a2)
{
  _DWORD *v4;
  uint64_t v5;

  v4 = malloc_type_calloc(1uLL, 0x20uLL, 0x1020040261BCE2DuLL);
  *a2 = v4;
  if (v4)
  {
    v5 = 0;
    v4[4] = (*((_DWORD *)a1 + 90) >> 1) & 1;
  }
  else
  {
    v5 = 12;
    krb5_set_error_message(a1, 12, "malloc: out of memory");
  }
  return v5;
}

uint64_t krb5_rd_req_in_set_keytab(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  *a2 = a3;
  return 0;
}

uint64_t krb5_rd_req_in_set_pac_check(uint64_t a1, uint64_t a2, int a3)
{
  *(_DWORD *)(a2 + 16) = a3;
  return 0;
}

uint64_t krb5_rd_req_in_set_as_reply_key(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(a2 + 24) = a3;
  return 0;
}

uint64_t krb5_rd_req_in_set_keyblock(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(a2 + 8) = a3;
  return 0;
}

uint64_t krb5_rd_req_out_get_ap_req_options(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  *a3 = *(_DWORD *)(a2 + 12);
  return 0;
}

uint64_t krb5_rd_req_out_get_ticket(_krb5_context *a1, uint64_t a2, krb5_ticket **a3)
{
  return krb5_copy_ticket(a1, *(const krb5_ticket **)(a2 + 16), a3);
}

uint64_t krb5_rd_req_out_get_keyblock(_krb5_context *a1, const krb5_keyblock **a2, krb5_keyblock **a3)
{
  return krb5_copy_keyblock(a1, *a2, a3);
}

uint64_t krb5_rd_req_out_get_flags(uint64_t a1, uint64_t a2)
{
  return *(unsigned int *)(a2 + 8);
}

CFTypeRef krb5_rd_req_out_copy_pac(uint64_t a1, uint64_t a2)
{
  return heim_retain(*(CFTypeRef *)(a2 + 32));
}

uint64_t krb5_rd_req_out_get_server(_krb5_context *a1, uint64_t a2, krb5_principal *a3)
{
  return krb5_copy_principal(a1, *(krb5_const_principal *)(a2 + 24), a3);
}

void krb5_rd_req_in_ctx_free(int a1, void *a2)
{
  free(a2);
}

void krb5_rd_req_out_ctx_free(krb5_context a1, krb5_keyblock **a2)
{
  krb5_ticket *v4;
  krb5_principal_data *v5;
  krb5_keyblock *v6;

  v4 = (krb5_ticket *)a2[2];
  if (v4)
    krb5_free_ticket(a1, v4);
  if (*a2)
    krb5_free_keyblock(a1, *a2);
  v5 = (krb5_principal_data *)a2[3];
  if (v5)
    krb5_free_principal(a1, v5);
  v6 = a2[4];
  if (v6)
    krb5_pac_free((uint64_t)a1, v6);
  free(a2);
}

krb5_error_code krb5_rd_req(krb5_context a1, krb5_auth_context *a2, const krb5_data *a3, krb5_const_principal a4, krb5_keytab a5, krb5_flags *a6, krb5_ticket **a7)
{
  krb5_error_code v14;
  krb5_keytab *v15;
  uint64_t v16;
  uint64_t v18;
  krb5_keytab *v19;

  v19 = 0;
  v14 = krb5_rd_req_in_ctx_alloc(a1, &v19);
  if (!v14)
  {
    v18 = 0;
    v15 = v19;
    *v19 = a5;
    v14 = krb5_rd_req_ctx(a1, a2, (uint64_t)a3, a4, (uint64_t)v15, &v18);
    free(v15);
    if (!v14)
    {
      v16 = v18;
      if (a6)
        *a6 = *(_DWORD *)(v18 + 12);
      if (a7)
        v14 = krb5_copy_ticket(a1, *(const krb5_ticket **)(v16 + 16), a7);
      else
        v14 = 0;
      krb5_rd_req_out_ctx_free(a1, (krb5_keyblock **)v16);
    }
  }
  return v14;
}

uint64_t krb5_rd_req_ctx(_krb5_context *a1, krb5_auth_context *a2, uint64_t a3, const krb5_principal_data *a4, uint64_t a5, _QWORD *a6)
{
  _DWORD **v12;
  _DWORD **v13;
  uint64_t v14;
  _krb5_kt *v15;
  const krb5_keyblock *v16;
  int v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  const krb5_keyblock *v23;
  uint64_t v24;
  int v25;
  int v26;
  int v27;
  uint64_t v28;
  uint64_t v29;
  _QWORD *v30;
  krb5_principal v31;
  krb5_kt_cursor cursor[3];
  krb5_keytab_entry entry;
  uint64_t v34;
  krb5_principal v35;
  krb5_keytab keytab;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  uint64_t v44;

  v35 = 0;
  keytab = 0;
  *a6 = 0;
  v12 = (_DWORD **)malloc_type_calloc(1uLL, 0x28uLL, 0x10200404A1ECDA0uLL);
  if (!v12)
  {
    v14 = 12;
    krb5_set_error_message(a1, 12, "malloc: out of memory");
    return v14;
  }
  v13 = v12;
  v44 = 0;
  v42 = 0u;
  v43 = 0u;
  v40 = 0u;
  v41 = 0u;
  v38 = 0u;
  v39 = 0u;
  v37 = 0u;
  if (!*a2)
  {
    v14 = krb5_auth_con_init(a1, a2);
    if ((_DWORD)v14)
      goto LABEL_14;
  }
  v14 = krb5_decode_ap_req(a1, a3, &v37);
  if ((_DWORD)v14)
    goto LABEL_14;
  *(_OWORD *)&entry.magic = v39;
  *(_QWORD *)&entry.timestamp = v40;
  v14 = _krb5_principalname2krb5_principal((uint64_t)a1, v13 + 3, (uint64_t)&entry, *((const char **)&v38 + 1));
  if ((_DWORD)v14)
    goto LABEL_14;
  if ((BYTE8(v37) & 2) != 0 && !*((_QWORD *)*a2 + 4))
  {
    v14 = 2529638957;
    krb5_set_error_message(a1, -1765328339, "krb5_rd_req: user to user auth without session key given");
    goto LABEL_14;
  }
  if (a5)
  {
    v15 = *(_krb5_kt **)a5;
    v16 = (const krb5_keyblock *)*((_QWORD *)*a2 + 4);
    if (!v16)
    {
      v16 = *(const krb5_keyblock **)(a5 + 8);
      if (!v16)
      {
        if (v15)
          goto LABEL_39;
        goto LABEL_38;
      }
    }
LABEL_22:
    v14 = krb5_copy_keyblock(a1, v16, (krb5_keyblock **)v13);
    if ((_DWORD)v14)
      goto LABEL_14;
    goto LABEL_23;
  }
  v16 = (const krb5_keyblock *)*((_QWORD *)*a2 + 4);
  if (v16)
  {
    v15 = 0;
    goto LABEL_22;
  }
LABEL_38:
  krb5_kt_default(a1, &keytab);
  v15 = keytab;
  if (!keytab)
    goto LABEL_46;
LABEL_39:
  if (!a4)
  {
    *(_OWORD *)&entry.magic = v39;
    *(_QWORD *)&entry.timestamp = v40;
    v14 = _krb5_principalname2krb5_principal((uint64_t)a1, &v35, (uint64_t)&entry, *((const char **)&v38 + 1));
    if ((_DWORD)v14)
      goto LABEL_14;
    a4 = v35;
  }
  v24 = sub_2096A9BF4(a1, (uint64_t)&v37, a4, v15, (krb5_keyblock **)v13);
  if (!(_DWORD)v24)
  {
LABEL_23:
    if (*v13)
    {
      v14 = krb5_verify_ap_req2(a1, a2, (uint64_t)&v37, v18, (const krb5_keyblock *)*v13, 0, (int *)v13 + 3, v13 + 2, 0xBu);
      if (!(_DWORD)v14)
        goto LABEL_25;
      goto LABEL_14;
    }
    goto LABEL_44;
  }
  if (!v35)
  {
    v14 = v24;
    if ((*((_BYTE *)a1 + 360) & 0x10) == 0)
      goto LABEL_14;
  }
  *v13 = 0;
LABEL_44:
  v34 = 0;
  memset(&entry, 0, sizeof(entry));
  memset(cursor, 0, sizeof(cursor));
  if ((_QWORD)v41)
    v25 = *(_DWORD *)v41;
  else
    v25 = 0;
  v14 = krb5_kt_start_seq_get(a1, v15, cursor);
  if ((_DWORD)v14)
    goto LABEL_14;
  v31 = 0;
  v14 = krb5_kt_next_entry(a1, v15, &entry, cursor);
  if ((_DWORD)v14)
  {
LABEL_56:
    sub_209697338(a1, v14, (uint64_t)v15, (uint64_t)v13[3], (char *)DWORD2(v40), v25);
LABEL_57:
    krb5_kt_end_seq_get(a1, v15, cursor);
    goto LABEL_14;
  }
  v30 = v13 + 2;
  while (1)
  {
    if (entry.timestamp != DWORD2(v40))
      goto LABEL_54;
    v27 = krb5_verify_ap_req2(a1, a2, (uint64_t)&v37, v26, (const krb5_keyblock *)&entry.timestamp, 0, (int *)v13 + 3, v30, 0xBu);
    if (!v27)
      break;
    if (v27 == -1765328221)
    {
      krb5_kt_end_seq_get(a1, v15, cursor);
      krb5_kt_free_entry(a1, (uint64_t)&entry);
      v14 = 2529639075;
      goto LABEL_14;
    }
LABEL_54:
    krb5_kt_free_entry(a1, (uint64_t)&entry);
    v31 = 0;
    v28 = krb5_kt_next_entry(a1, v15, &entry, cursor);
    if ((_DWORD)v28)
    {
      v14 = v28;
      goto LABEL_56;
    }
  }
  v29 = krb5_copy_keyblock(a1, (const krb5_keyblock *)&entry.timestamp, (krb5_keyblock **)v13);
  if ((_DWORD)v29 || (v29 = krb5_copy_principal(a1, *(krb5_const_principal *)&entry.magic, &v31), (_DWORD)v29))
  {
    v14 = v29;
    krb5_kt_free_entry(a1, (uint64_t)&entry);
    goto LABEL_57;
  }
  krb5_free_principal(a1, *(krb5_principal *)(*v30 + 144));
  *(_QWORD *)(*v30 + 144) = v31;
  krb5_kt_free_entry(a1, (uint64_t)&entry);
  krb5_kt_end_seq_get(a1, v15, cursor);
LABEL_25:
  v14 = sub_2096AEC60(a1, (uint64_t)*a2);
  if ((_DWORD)v14)
    goto LABEL_14;
  sub_20969D1E8((uint64_t)a1, 15, "krb5_rd_req: used enctype %d from keytab", **v13);
  if (a5 && !*(_DWORD *)(a5 + 16))
    goto LABEL_46;
  cursor[0] = 0;
  *(_QWORD *)&entry.magic = 0;
  entry.principal = 0;
  if (krb5_ticket_get_authorization_data_type(a1, (uint64_t)v13[2], 128, &entry))
    goto LABEL_46;
  v14 = krb5_pac_parse(a1, entry.principal, *(size_t *)&entry.magic, cursor, v19, v20, v21, v22);
  krb5_data_free(&entry);
  if ((_DWORD)v14)
  {
LABEL_14:
    krb5_rd_req_out_ctx_free(a1, (krb5_keyblock **)v13);
    goto LABEL_15;
  }
  if (!krb5_pac_verify(a1, (uint64_t)cursor[0], *((_QWORD *)v13[2] + 11), *((_QWORD *)v13[2] + 17), (const krb5_keyblock *)*v13, 0))
  {
    *((_DWORD *)v13 + 2) |= 1u;
    v13[4] = heim_retain(cursor[0]);
  }
  if (((_BYTE)v13[1] & 1) != 0)
  {
    v23 = *(const krb5_keyblock **)(a5 + 24);
    if (v23)
    {
      if (!krb5_pac_process_credentials_buffer(a1, (_QWORD *)cursor[0], v23))
        *((_DWORD *)v13 + 2) |= 2u;
    }
  }
  krb5_pac_free((uint64_t)a1, cursor[0]);
LABEL_46:
  v14 = 0;
  *a6 = v13;
LABEL_15:
  sub_2096BBDD0();
  if (v35)
    krb5_free_principal(a1, v35);
  if (keytab)
    krb5_kt_close(a1, keytab);
  return v14;
}

uint64_t krb5_rd_req_with_keyblock(_krb5_context *a1, krb5_auth_context *a2, uint64_t a3, const krb5_principal_data *a4, uint64_t a5, _DWORD *a6, krb5_ticket **a7)
{
  uint64_t v14;
  void *v15;
  uint64_t v16;
  uint64_t v18;
  _QWORD *v19;

  v19 = 0;
  v14 = krb5_rd_req_in_ctx_alloc(a1, &v19);
  if (!(_DWORD)v14)
  {
    v18 = 0;
    v15 = v19;
    v19[1] = a5;
    v14 = krb5_rd_req_ctx(a1, a2, a3, a4, (uint64_t)v15, &v18);
    free(v15);
    if (!(_DWORD)v14)
    {
      v16 = v18;
      if (a6)
        *a6 = *(_DWORD *)(v18 + 12);
      if (a7)
        v14 = krb5_copy_ticket(a1, *(const krb5_ticket **)(v16 + 16), a7);
      else
        v14 = 0;
      krb5_rd_req_out_ctx_free(a1, (krb5_keyblock **)v16);
    }
  }
  return v14;
}

uint64_t sub_2096A9BF4(krb5_context context, uint64_t a2, const krb5_principal_data *a3, krb5_keytab keytab, krb5_keyblock **a5)
{
  krb5_kvno *v8;
  krb5_kvno v9;
  uint64_t entry;
  krb5_keytab_entry v12;
  uint64_t v13;

  v13 = 0;
  memset(&v12, 0, sizeof(v12));
  v8 = *(krb5_kvno **)(a2 + 64);
  if (v8)
    v9 = *v8;
  else
    v9 = 0;
  entry = krb5_kt_get_entry(context, keytab, a3, v9, *(_DWORD *)(a2 + 56), &v12);
  if (!(_DWORD)entry)
  {
    entry = krb5_copy_keyblock(context, (const krb5_keyblock *)&v12.timestamp, a5);
    krb5_kt_free_entry(context, (uint64_t)&v12);
  }
  return entry;
}

krb5_error_code krb5_rd_safe(krb5_context a1, krb5_auth_context a2, const krb5_data *a3, krb5_data *a4, krb5_replay_data *a5)
{
  krb5_error_code v9;
  const krb5_address *v10;
  const krb5_address *v11;
  int v12;
  size_t v14;
  char *v15;
  size_t v16;
  uint64_t v17[2];
  size_t size[2];
  void *__src[2];
  __int128 v20;
  krb5_address *v21[2];
  __int128 v22;
  uint64_t v23;

  krb5_data_zero(a4);
  if ((*(_BYTE *)a2 & 0xA) != 0)
  {
    if (!a5)
    {
      v9 = -1765328169;
      krb5_set_error_message(a1, -1765328169, "rd_safe: need outdata to return data");
      return v9;
    }
    *(_QWORD *)&a5->timestamp = 0;
    *(_QWORD *)&a5->seq = 0;
  }
  v23 = 0;
  *(_OWORD *)v21 = 0u;
  v22 = 0u;
  *(_OWORD *)__src = 0u;
  v20 = 0u;
  *(_OWORD *)size = 0u;
  v17[1] = 0;
  v9 = sub_2096BBEA0();
  if (!v9)
  {
    if (LODWORD(size[0]) == 5)
    {
      if (HIDWORD(size[0]) == 20)
      {
        if (krb5_checksum_is_keyed((uint64_t)a1, v22)
          && krb5_checksum_is_collision_proof((uint64_t)a1, v22))
        {
          if (v21[0]
            && (v10 = (const krb5_address *)*((_QWORD *)a2 + 2)) != 0
            && !krb5_address_compare(a1, v10, v21[0])
            || v21[1]
            && (v11 = (const krb5_address *)*((_QWORD *)a2 + 1)) != 0
            && !krb5_address_compare(a1, v11, v21[1]))
          {
            v9 = -1765328346;
            krb5_clear_error_message(a1);
            goto LABEL_24;
          }
          if ((*(_DWORD *)a2 & 1) != 0)
          {
            v17[0] = 0;
            krb5_timeofday(a1, (krb5_timestamp *)v17);
            if (!__src[1] || !(_QWORD)v20 || krb5_time_abs(*(_QWORD *)__src[1], v17[0]) > *((_QWORD *)a1 + 10))
            {
              krb5_clear_error_message(a1);
              v9 = -1765328347;
              goto LABEL_24;
            }
            if ((*(_DWORD *)a2 & 4) == 0)
            {
LABEL_32:
              v9 = sub_2096A9F7C(a1, a2, (uint64_t)size);
              if (!v9)
              {
                v14 = size[1];
                *(_QWORD *)&a4->magic = size[1];
                v15 = (char *)malloc_type_malloc(v14, 0x8D09A6EuLL);
                a4->data = v15;
                v16 = *(_QWORD *)&a4->magic;
                if (v15 || !v16)
                {
                  memcpy(v15, __src[0], v16);
                  if ((*(_BYTE *)a2 & 0xA) == 0)
                    goto LABEL_45;
                  if (__src[1])
                    *(_QWORD *)&a5->timestamp = *(_QWORD *)__src[1];
                  if ((_QWORD)v20)
                    a5->seq = *(_DWORD *)v20;
                  if (*((_QWORD *)&v20 + 1))
                  {
                    v9 = 0;
                    a5[1].timestamp = **((_DWORD **)&v20 + 1);
                  }
                  else
                  {
LABEL_45:
                    v9 = 0;
                  }
                }
                else
                {
                  v9 = 12;
                  krb5_set_error_message(a1, 12, "malloc: out of memory");
                  krb5_data_zero(a4);
                }
              }
              goto LABEL_24;
            }
          }
          else if ((*(_DWORD *)a2 & 4) == 0)
          {
            goto LABEL_32;
          }
          if (*((_QWORD *)&v20 + 1))
          {
            v12 = **((_DWORD **)&v20 + 1);
            if (**((_DWORD **)&v20 + 1) == *((_DWORD *)a2 + 15))
            {
LABEL_19:
              *((_DWORD *)a2 + 15) = v12 + 1;
              goto LABEL_32;
            }
          }
          else
          {
            v12 = *((_DWORD *)a2 + 15);
            if (!v12)
              goto LABEL_19;
          }
          krb5_clear_error_message(a1);
          v9 = -1765328342;
        }
        else
        {
          krb5_clear_error_message(a1);
          v9 = -1765328334;
        }
      }
      else
      {
        krb5_clear_error_message(a1);
        v9 = -1765328344;
      }
    }
    else
    {
      krb5_clear_error_message(a1);
      v9 = -1765328345;
    }
LABEL_24:
    sub_2096BBEF0();
  }
  return v9;
}

uint64_t sub_2096A9F7C(_krb5_context *a1, _QWORD *a2, uint64_t a3)
{
  size_t v6;
  char *v7;
  void *v8;
  char *v9;
  uint64_t v10;
  const krb5_keyblock *v11;
  uint64_t v12;
  size_t v13;
  krb5_cksumtype ctype[2];
  __int128 seed;
  uint64_t v17;
  size_t in_length;

  seed = *(_OWORD *)(a3 + 64);
  v17 = *(_QWORD *)(a3 + 80);
  in_length = 0;
  *(_DWORD *)(a3 + 64) = 0;
  *(_QWORD *)(a3 + 72) = 0;
  *(_QWORD *)(a3 + 80) = 0;
  v6 = sub_2096BBEE0();
  v7 = (char *)malloc_type_malloc(v6, 0x833A7A7EuLL);
  if (!v7)
    return 12;
  v8 = v7;
  *(_QWORD *)ctype = 0;
  v9 = &v7[v6];
  v10 = sub_2096BBEC0();
  if (!(_DWORD)v10)
  {
    if (v6 != in_length)
      krb5_abortx(a1, "internal error in ASN.1 encoder");
    v11 = (const krb5_keyblock *)a2[6];
    if (!v11)
    {
      v11 = (const krb5_keyblock *)a2[5];
      if (!v11)
        v11 = (const krb5_keyblock *)a2[4];
    }
    v12 = a3 + 64;
    v10 = krb5_crypto_init(a1, v11, 0, (krb5_keyblock ***)ctype);
    if (!(_DWORD)v10)
    {
      v10 = krb5_verify_checksum(a1, ctype[0], (const krb5_checksum *)0xF, &v9[-in_length], in_length, &seed, v13);
      krb5_crypto_destroy(a1, *(uint64_t *)ctype);
    }
    *(_OWORD *)v12 = seed;
    *(_QWORD *)(v12 + 16) = v17;
  }
  free(v8);
  return v10;
}

uint64_t krb5_read_message(_krb5_context *a1, int *a2, uint64_t a3)
{
  ssize_t v6;
  uint64_t v7;
  size_t v8;
  uint64_t v9;
  unsigned int v11;

  krb5_data_zero((_QWORD *)a3);
  v6 = krb5_net_read((int)a1, a2, (char *)&v11, 4uLL);
  if (v6 == -1)
  {
    v7 = *__error();
    goto LABEL_12;
  }
  if (v6 > 3)
  {
    if (v11 >> 4)
    {
      v7 = 34;
      krb5_set_error_message(a1, 34, "packet to large");
      return v7;
    }
    v8 = _byteswap_ulong(v11);
    v9 = krb5_data_alloc((size_t *)a3, v8);
    if ((_DWORD)v9)
    {
      v7 = v9;
    }
    else
    {
      if (krb5_net_read((int)a1, a2, *(char **)(a3 + 8), v8) == v8)
        return 0;
      v7 = *__error();
      krb5_data_free((_QWORD *)a3);
    }
LABEL_12:
    krb5_clear_error_message(a1);
    return v7;
  }
  krb5_clear_error_message(a1);
  return 2314790661;
}

uint64_t krb5_read_priv_message(_krb5_context *a1, _krb5_auth_context *a2, int *a3, krb5_data *a4)
{
  uint64_t message;
  krb5_data v9;

  *(_QWORD *)&v9.magic = 0;
  v9.data = 0;
  message = krb5_read_message(a1, a3, (uint64_t)&v9);
  if (!(_DWORD)message)
  {
    message = krb5_rd_priv(a1, a2, &v9, a4, 0);
    krb5_data_free(&v9);
  }
  return message;
}

uint64_t krb5_read_safe_message(_krb5_context *a1, _krb5_auth_context *a2, int *a3, krb5_data *a4)
{
  uint64_t message;
  krb5_data v9;

  *(_QWORD *)&v9.magic = 0;
  v9.data = 0;
  message = krb5_read_message(a1, a3, (uint64_t)&v9);
  if (!(_DWORD)message)
  {
    message = krb5_rd_safe(a1, a2, &v9, a4, 0);
    krb5_data_free(&v9);
  }
  return message;
}

krb5_error_code krb5_recvauth(krb5_context a1, krb5_auth_context *a2, krb5_pointer a3, char *a4, krb5_principal a5, krb5_int32 a6, krb5_keytab a7, krb5_ticket **a8)
{
  return krb5_recvauth_match_version(a1, a2, (int *)a3, (unsigned int (*)(uint64_t, char *))sub_2096AA798, (uint64_t)a4, a5, a6, a7, a8);
}

uint64_t krb5_recvauth_match_version(krb5_context a1, krb5_auth_context *a2, int *a3, unsigned int (*a4)(uint64_t, char *), uint64_t a5, const krb5_principal_data *a6, char a7, _krb5_kt *a8, krb5_ticket **a9)
{
  _krb5_auth_context *v17;
  uint64_t v18;
  ssize_t v19;
  unsigned int v20;
  ssize_t v21;
  ssize_t v22;
  size_t v23;
  int *v24;
  const char *v25;
  _krb5_context *v26;
  krb5_error_code v27;
  char *v28;
  char *v29;
  ssize_t v30;
  uint64_t message;
  int *v33;
  krb5_data *v34;
  int *v35;
  uint64_t v36;
  char *v37;
  char *v38[2];
  krb5_flags v39;
  krb5_data v40;
  char __buf;
  unsigned int v42;
  char v43[19];
  uint64_t v44;

  v44 = *MEMORY[0x24BDAC8D0];
  v17 = *a2;
  if (!v17)
  {
    v18 = krb5_auth_con_init(a1, a2);
    if ((_DWORD)v18)
      return v18;
    v17 = *a2;
  }
  v18 = krb5_auth_con_setaddrs_from_fd(a1, v17, a3);
  if (!(_DWORD)v18)
  {
    v42 = 0;
    __buf = 0;
    *(_QWORD *)&v40.magic = 0;
    v40.data = 0;
    v39 = 0;
    if ((a7 & 1) == 0)
    {
      v19 = krb5_net_read((int)a1, a3, (char *)&v42, 4uLL);
      if (v19 < 0)
        goto LABEL_16;
      if (!v19)
      {
        v18 = 2529639116;
        krb5_set_error_message(a1, -1765328180, "Failed to receive sendauth data");
        return v18;
      }
      v20 = v42;
      v42 = bswap32(v42);
      if (v20 != 318767104
        || (v21 = krb5_net_read((int)a1, a3, v43, 0x13uLL), v21 != v42)
        || strncmp("KRB5_SENDAUTH_V1.0", v43, v21))
      {
        v18 = 2529639116;
        __buf = 1;
        krb5_net_write((int)a1, a3, &__buf, 1uLL);
        krb5_clear_error_message(a1);
        return v18;
      }
    }
    v22 = krb5_net_read((int)a1, a3, (char *)&v42, 4uLL);
    if ((v22 & 0x8000000000000000) == 0)
    {
      if (!v22)
      {
        krb5_clear_error_message(a1);
        return 2529639117;
      }
      v23 = bswap32(v42);
      v42 = v23;
      if (v23 >> 28)
      {
        v18 = 34;
        krb5_set_error_message(a1, 34, "packet to large");
        return v18;
      }
      v28 = (char *)malloc_type_malloc(v23, 0x2F7A00CAuLL);
      if (!v28)
      {
        __buf = 2;
        krb5_net_write((int)a1, a3, &__buf, 1uLL);
        v25 = "malloc: out of memory";
        v18 = 12;
        v26 = a1;
        v27 = 12;
        goto LABEL_28;
      }
      v29 = v28;
      v30 = krb5_net_read((int)a1, a3, v28, v42);
      if (v30 != v42 || !a4(a5, v29))
      {
        __buf = 2;
        krb5_net_write((int)a1, a3, &__buf, 1uLL);
        v18 = 2529639117;
        krb5_set_error_message(a1, -1765328179, "wrong sendauth version (%s)", v29);
        free(v29);
        return v18;
      }
      free(v29);
      __buf = 0;
      if (krb5_net_write((int)a1, a3, &__buf, 1uLL) != 1)
      {
        v33 = __error();
        v18 = *v33;
        v37 = strerror(*v33);
        v25 = "write: %s";
        goto LABEL_17;
      }
      krb5_data_zero(&v40);
      message = krb5_read_message(a1, a3, (uint64_t)&v40);
      if ((_DWORD)message)
      {
        v18 = message;
        v25 = "krb5_recvauth: client closed connection";
        goto LABEL_17;
      }
      v18 = krb5_rd_req(a1, a2, &v40, a6, a8, &v39, a9);
      krb5_data_free(&v40);
      if ((_DWORD)v18)
      {
        v38[0] = 0;
        v38[1] = 0;
        if (krb5_mk_error(a1, (const krb5_error *)v18, 0))
          return v18;
        krb5_write_message(a1, a3, v38);
        v34 = (krb5_data *)v38;
LABEL_34:
        krb5_data_free(v34);
        return v18;
      }
      v42 = 0;
      if (krb5_net_write((int)a1, a3, (char *)&v42, 4uLL) == 4)
      {
        if ((v39 & 2) == 0)
          return 0;
        v36 = krb5_mk_rep(a1, *a2, &v40);
        if ((_DWORD)v36)
        {
          v18 = v36;
        }
        else
        {
          v18 = krb5_write_message(a1, a3, (char **)&v40);
          if (!(_DWORD)v18)
          {
            v34 = &v40;
            goto LABEL_34;
          }
          krb5_set_error_message(a1, v18, "krb5_recvauth: server closed connection");
        }
      }
      else
      {
        v35 = __error();
        v18 = *v35;
        strerror(*v35);
        krb5_set_error_message(a1, v18, "write: %s");
      }
      krb5_free_ticket(a1, *a9);
      *a9 = 0;
      return v18;
    }
LABEL_16:
    v24 = __error();
    v18 = *v24;
    v37 = strerror(*v24);
    v25 = "read: %s";
LABEL_17:
    v26 = a1;
    v27 = v18;
LABEL_28:
    krb5_set_error_message(v26, v27, v25, v37);
  }
  return v18;
}

BOOL sub_2096AA798(const char *a1, const char *a2)
{
  return strcmp(a1, a2) == 0;
}

uint64_t krb5_rc_resolve(_krb5_context *a1, _QWORD *a2, char *__s1, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char v12;

  if (a2[1])
    krb5_abort(a1, 22, "called krb5_rc_resolve more then once", a4, a5, a6, a7, a8, v12);
  a2[1] = strdup(__s1);
  return (*(uint64_t (**)(_krb5_context *, char *, _QWORD *))(*a2 + 16))(a1, __s1, a2);
}

uint64_t krb5_rc_resolve_type(_krb5_context *a1, _QWORD *a2, const char *a3)
{
  uint64_t v6;
  char i;
  char v8;
  const char **v9;
  size_t v10;
  uint64_t v11;
  _QWORD *v12;

  v6 = 0;
  *a2 = 0;
  for (i = 1; ; i = 0)
  {
    v8 = i;
    v9 = (const char **)&(&off_253D3B920)[9 * v6];
    v10 = strlen(*v9);
    if (!strncmp(a3, *v9, v10) && (!a3[v10] || a3[v10] == 58))
      break;
    v6 = 1;
    if ((v8 & 1) == 0)
    {
      v11 = 2529639073;
      krb5_set_error_message(a1, -1765328223, "replay cache type %s not supported", a3);
      return v11;
    }
  }
  v12 = malloc_type_calloc(1uLL, (size_t)((&off_253D3B920)[9 * v6 + 1] + 16), 0xB0D57357uLL);
  *a2 = v12;
  if (v12)
  {
    v11 = 0;
    *v12 = v9;
    return v11;
  }
  return krb5_enomem(a1);
}

uint64_t krb5_rc_resolve_full(_krb5_context *a1, const char ****a2, const char *a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  const char *v12;

  *a2 = 0;
  v6 = krb5_rc_resolve_type(a1, a2, a3);
  if (!(_DWORD)v6)
  {
    v12 = &a3[strlen(***a2)];
    if (*v12 == 58)
    {
      v6 = krb5_rc_resolve(a1, *a2, (char *)v12 + 1, v7, v8, v9, v10, v11);
      if ((_DWORD)v6)
      {
        krb5_rc_close((uint64_t)a1, *a2);
        *a2 = 0;
      }
    }
    else
    {
      v6 = 2529639073;
      krb5_set_error_message(a1, -1765328223, "replay have bad name: %s", a3);
    }
  }
  return v6;
}

uint64_t krb5_rc_close(uint64_t a1, _QWORD *a2)
{
  void *v3;

  (*(void (**)(void))(*a2 + 64))();
  v3 = (void *)a2[1];
  if (v3)
    free(v3);
  free(a2);
  return 0;
}

const char *krb5_rc_default_name()
{
  return "MEMORY:";
}

const char *krb5_rc_default_type()
{
  return "MEMORY";
}

uint64_t krb5_rc_default(_krb5_context *a1, const char ****a2)
{
  return krb5_rc_resolve_full(a1, a2, "MEMORY:");
}

uint64_t krb5_rc_initialize(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 24))(a1, a3, a2);
}

uint64_t krb5_rc_recover()
{
  return 0;
}

uint64_t krb5_rc_destroy(uint64_t a1, _QWORD *a2)
{
  uint64_t v4;

  v4 = (*(uint64_t (**)(void))(*a2 + 56))();
  if (!(_DWORD)v4)
    krb5_rc_close(a1, a2);
  return v4;
}

uint64_t krb5_rc_store(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)a2 + 40))();
}

uint64_t krb5_rc_expunge(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)a2 + 48))();
}

uint64_t krb5_rc_get_lifespan(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)a2 + 32))();
}

uint64_t krb5_rc_get_name(uint64_t a1, uint64_t a2)
{
  return *(_QWORD *)(a2 + 8);
}

uint64_t krb5_rc_get_type(uint64_t a1, uint64_t a2)
{
  return **(_QWORD **)a2;
}

krb5_error_code krb5_get_server_rcache(krb5_context a1, const krb5_data *a2, krb5_rcache *a3)
{
  return krb5_rc_resolve_full(a1, (const char ****)a3, "MEMORY:");
}

uint64_t sub_2096AAB18()
{
  return 0;
}

uint64_t sub_2096AAB20(_krb5_context *a1, uint64_t a2, uint64_t a3)
{
  FILE *v6;
  FILE *v7;
  uint64_t v8;
  int *v9;
  char __strerrbuf[128];
  uint64_t __ptr;
  __int128 v13;
  __int128 v14;
  uint64_t v15;

  v15 = *MEMORY[0x24BDAC8D0];
  v6 = fopen(*(const char **)(a3 + 8), "w");
  v14 = 0u;
  v13 = 0u;
  if (v6)
  {
    v7 = v6;
    __ptr = a2;
    fwrite(&__ptr, 1uLL, 0x28uLL, v6);
    fclose(v7);
    return 0;
  }
  else
  {
    v9 = __error();
    v8 = *v9;
    strerror_r(*v9, __strerrbuf, 0x80uLL);
    krb5_set_error_message(a1, v8, "open(%s): %s", *(const char **)(a3 + 8), __strerrbuf);
  }
  return v8;
}

uint64_t sub_2096AAC14(_krb5_context *a1, uint64_t a2, _QWORD *a3)
{
  FILE *v5;
  size_t v6;
  uint64_t result;
  _OWORD v8[2];
  uint64_t v9;
  uint64_t v10;

  v10 = *MEMORY[0x24BDAC8D0];
  v5 = fopen(*(const char **)(a2 + 8), "r");
  v9 = 0;
  memset(v8, 0, sizeof(v8));
  v6 = fread(v8, 0x28uLL, 1uLL, v5);
  fclose(v5);
  if (v6)
  {
    result = 0;
    *a3 = *(_QWORD *)&v8[0];
  }
  else
  {
    krb5_clear_error_message(a1);
    return 2529639083;
  }
  return result;
}

uint64_t sub_2096AACD4(_krb5_context *a1, uint64_t a2, uint64_t a3)
{
  FILE *v6;
  FILE *v7;
  time_t v8;
  uint64_t v9;
  uint64_t v10;
  BOOL v11;
  BOOL v12;
  uint64_t v14;
  const char *v15;
  int *v16;
  FILE *v18;
  FILE *v19;
  int *v20;
  uint64_t v21;
  char __strerrbuf[128];
  __int128 __ptr;
  __int128 v24;
  uint64_t v25;
  time_t v26;
  __int128 v27;
  __int128 v28;
  uint64_t v29;

  v29 = *MEMORY[0x24BDAC8D0];
  v28 = 0u;
  v27 = 0u;
  v26 = time(0);
  sub_2096AB324(a3, (uint64_t)&v27);
  v6 = fopen(*(const char **)(a2 + 8), "r");
  if (!v6)
  {
    v16 = __error();
    v14 = *v16;
    strerror_r(*v16, __strerrbuf, 0x80uLL);
    v21 = *(_QWORD *)(a2 + 8);
    v15 = "open(%s): %s";
    goto LABEL_19;
  }
  v7 = v6;
  v25 = 0;
  __ptr = 0u;
  v24 = 0u;
  rk_cloexec_file(v6);
  fread(&__ptr, 0x28uLL, 1uLL, v7);
  v8 = v26;
  v9 = __ptr;
  if (!fread(&__ptr, 0x28uLL, 1uLL, v7))
  {
LABEL_16:
    if (!ferror(v7))
    {
      fclose(v7);
      v18 = fopen(*(const char **)(a2 + 8), "a");
      if (v18)
      {
        v19 = v18;
        fwrite(&v26, 1uLL, 0x28uLL, v18);
        fclose(v19);
        return 0;
      }
      else
      {
        v14 = 2529639083;
        v20 = __error();
        strerror_r(*v20, __strerrbuf, 0x80uLL);
        krb5_set_error_message(a1, -1765328213, "open(%s): %s");
      }
      return v14;
    }
    v14 = *__error();
    fclose(v7);
    strerror_r(v14, __strerrbuf, 0x80uLL);
    v21 = *(_QWORD *)(a2 + 8);
    v15 = "%s: %s";
LABEL_19:
    krb5_set_error_message(a1, v14, v15, v21, __strerrbuf);
    return v14;
  }
  v10 = v8 - v9;
  while (1)
  {
    if ((uint64_t)__ptr >= v10)
    {
      v11 = *((_QWORD *)&__ptr + 1) == (_QWORD)v27 && (_QWORD)v24 == *((_QWORD *)&v27 + 1);
      v12 = v11 && *((_QWORD *)&v24 + 1) == (_QWORD)v28;
      if (v12 && v25 == *((_QWORD *)&v28 + 1))
        break;
    }
    if (!fread(&__ptr, 0x28uLL, 1uLL, v7))
      goto LABEL_16;
  }
  fclose(v7);
  krb5_clear_error_message(a1);
  return 2529639075;
}

uint64_t sub_2096AAF34()
{
  return 0;
}

uint64_t sub_2096AAF3C(_krb5_context *a1, uint64_t a2)
{
  uint64_t v4;
  int *v5;
  char __strerrbuf[128];
  uint64_t v8;

  v8 = *MEMORY[0x24BDAC8D0];
  if ((remove(*(const std::__fs::filesystem::path **)(a2 + 8), (std::error_code *)a2) & 0x80000000) == 0)
    return 0;
  v5 = __error();
  v4 = *v5;
  strerror_r(*v5, __strerrbuf, 0x80uLL);
  krb5_set_error_message(a1, v4, "remove(%s): %s", *(const char **)(a2 + 8), __strerrbuf);
  return v4;
}

uint64_t sub_2096AAFEC()
{
  return 0;
}

uint64_t sub_2096AAFF4(uint64_t a1, uint64_t a2)
{
  pthread_mutex_lock(&stru_2545A4E38);
  if (qword_2545A4E20 != a2)
    qword_2545A4E20 = a2;
  pthread_mutex_unlock(&stru_2545A4E38);
  return 0;
}

uint64_t sub_2096AB044(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  pthread_mutex_lock(&stru_2545A4E38);
  *a3 = qword_2545A4E20;
  pthread_mutex_unlock(&stru_2545A4E38);
  return 0;
}

uint64_t sub_2096AB090(_krb5_context *a1, uint64_t a2, uint64_t a3)
{
  _QWORD *v5;
  _QWORD *v6;
  _QWORD *v7;
  time_t v8;
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  _QWORD *v12;
  BOOL v13;
  BOOL v14;
  _QWORD *v16;
  _QWORD *v17;
  uint64_t v18;
  uint64_t v20;

  v5 = malloc_type_malloc(0x38uLL, 0x10A0040E90C3259uLL);
  if (!v5)
    return krb5_enomem(a1);
  v6 = v5;
  *v5 = *(_QWORD *)(a3 + 56);
  v7 = v5 + 1;
  sub_2096AB324(a3, (uint64_t)(v5 + 1));
  v8 = time(0);
  v9 = qword_2545A4E20;
  pthread_mutex_lock(&stru_2545A4E38);
  v10 = off_2545A4E28;
  if (off_2545A4E28)
  {
    v11 = *(_QWORD *)(a3 + 56);
    do
    {
      v12 = (_QWORD *)v10[5];
      if (*v10 == v11)
      {
        v13 = v10[1] == *v7 && v10[2] == v7[1];
        v14 = v13 && v10[3] == v7[2];
        if (v14 && v10[4] == v7[3])
        {
          v20 = 2529639075;
          pthread_mutex_unlock(&stru_2545A4E38);
          krb5_set_error_message(a1, -1765328221, "replay detected");
          free(v6);
          return v20;
        }
      }
      if (*v10 < v8 - v9)
      {
        v16 = (_QWORD *)v10[6];
        if (v12)
        {
          v12[6] = v16;
          v16 = (_QWORD *)v10[6];
        }
        else
        {
          qword_2545A4E30 = v10[6];
        }
        *v16 = v12;
      }
      v10 = v12;
    }
    while (v12);
    v17 = off_2545A4E28;
    v6[5] = off_2545A4E28;
    v18 = (uint64_t)(v6 + 5);
    if (!v17)
      goto LABEL_25;
    v17[6] = v18;
  }
  else
  {
    v6[5] = 0;
    v18 = (uint64_t)(v6 + 5);
LABEL_25:
    qword_2545A4E30 = v18;
  }
  v6[6] = &off_2545A4E28;
  off_2545A4E28 = v6;
  pthread_mutex_unlock(&stru_2545A4E38);
  return 0;
}

uint64_t sub_2096AB22C()
{
  time_t v0;
  time_t *v1;
  time_t v2;
  time_t *v3;
  time_t **v4;

  pthread_mutex_lock(&stru_2545A4E38);
  v0 = time(0);
  v1 = (time_t *)off_2545A4E28;
  if (off_2545A4E28)
  {
    v2 = v0 - qword_2545A4E20;
    do
    {
      v3 = (time_t *)v1[5];
      if (*v1 < v2)
      {
        v4 = (time_t **)v1[6];
        if (v3)
        {
          v3[6] = (time_t)v4;
          v4 = (time_t **)v1[6];
        }
        else
        {
          qword_2545A4E30 = v1[6];
        }
        *v4 = v3;
      }
      v1 = v3;
    }
    while (v3);
  }
  pthread_mutex_unlock(&stru_2545A4E38);
  return 0;
}

uint64_t sub_2096AB2B4()
{
  _QWORD *i;
  uint64_t v1;
  _QWORD *v2;

  pthread_mutex_lock(&stru_2545A4E38);
  for (i = off_2545A4E28; off_2545A4E28; i = off_2545A4E28)
  {
    v1 = i[5];
    v2 = (_QWORD *)i[6];
    if (v1)
    {
      *(_QWORD *)(v1 + 48) = v2;
      v2 = (_QWORD *)i[6];
    }
    else
    {
      qword_2545A4E30 = i[6];
    }
    *v2 = v1;
  }
  pthread_mutex_unlock(&stru_2545A4E38);
  return 0;
}

uint64_t sub_2096AB324(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  char *v6;
  unint64_t v7;
  _QWORD v9[2];

  v9[1] = *MEMORY[0x24BDAC8D0];
  v4 = ccsha256_di();
  MEMORY[0x24BDAC7A8]();
  v6 = (char *)v9 - v5;
  ccdigest_init();
  strlen(*(const char **)(a1 + 8));
  ccdigest_update();
  if (*(_DWORD *)(a1 + 24))
  {
    v7 = 0;
    do
    {
      strlen(*(const char **)(*(_QWORD *)(a1 + 32) + 8 * v7));
      ccdigest_update();
      ++v7;
    }
    while (v7 < *(unsigned int *)(a1 + 24));
  }
  ccdigest_update();
  ccdigest_update();
  return (*(uint64_t (**)(uint64_t, char *, uint64_t))(v4 + 56))(v4, v6, a2);
}

uint64_t krb5_sendto_ctx_alloc(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  *(_QWORD *)a2 = heim_uniq_alloc(0xF8uLL, (uint64_t)"sendto-context", (uint64_t)sub_2096AB4AC, a4, a5, a6, a7, a8);
  *(_QWORD *)(*(_QWORD *)a2 + 136) = heim_array_create();
  return 0;
}

void sub_2096AB4AC(uint64_t a1)
{
  void *v2;
  void *v3;
  void *v4;

  v2 = *(void **)(a1 + 56);
  if (v2)
    free(v2);
  v3 = *(void **)(a1 + 64);
  if (v3)
    free(v3);
  v4 = *(void **)(a1 + 96);
  if (v4)
    free(v4);
  heim_release(*(CFTypeRef *)(a1 + 136));
  heim_release(*(CFTypeRef *)(a1 + 104));
}

uint64_t krb5_sendto_ctx_add_flags(uint64_t result, int a2)
{
  *(_DWORD *)(result + 32) |= a2;
  return result;
}

uint64_t krb5_sendto_ctx_get_flags(uint64_t a1)
{
  return *(unsigned int *)(a1 + 32);
}

uint64_t krb5_sendto_ctx_set_type(uint64_t result, int a2)
{
  *(_DWORD *)(result + 36) = a2;
  return result;
}

uint64_t krb5_sendto_ctx_set_func(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 40) = a2;
  *(_QWORD *)(result + 48) = a3;
  return result;
}

uint64_t sub_2096AB520(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 160) = a2;
  *(_QWORD *)(result + 168) = a3;
  return result;
}

uint64_t sub_2096AB528(_krb5_context *a1, uint64_t a2, char *__s1)
{
  char *v5;

  v5 = strdup(__s1);
  *(_QWORD *)(a2 + 56) = v5;
  if (v5)
    return 0;
  else
    return krb5_enomem(a1);
}

uint64_t sub_2096AB56C(_krb5_context *a1, uint64_t a2, char *__s1)
{
  char *v5;

  v5 = strdup(__s1);
  *(_QWORD *)(a2 + 64) = v5;
  if (v5)
    return 0;
  else
    return krb5_enomem(a1);
}

uint64_t krb5_sendto_set_delegated_app(uint64_t a1, uint64_t a2, _OWORD *a3, int a4, char *__s1)
{
  const char *v9;
  void *v10;
  uint64_t v12;
  void *v13;

  *(_DWORD *)(a2 + 156) |= 1u;
  if (a3)
  {
    *(_OWORD *)(a2 + 72) = *a3;
    v9 = "passed-in";
  }
  else if (__s1)
  {
    *(_QWORD *)(a2 + 72) = 0;
    *(_QWORD *)(a2 + 80) = 0;
    v12 = NEHelperCacheCopyAppUUIDMapping();
    if (v12)
    {
      v13 = (void *)v12;
      if (MEMORY[0x20BD129CC]() == MEMORY[0x24BDACF78] && xpc_array_get_count(v13))
      {
        *(_OWORD *)(a2 + 72) = *(_OWORD *)xpc_array_get_uuid(v13, 0);
        v9 = "NEHelperCacheCopyAppUUIDMapping";
      }
      else
      {
        v9 = "NEHelperCacheCopyAppUUIDMapping-fail";
      }
      xpc_release(v13);
    }
    else
    {
      v9 = "NEHelperCacheCopyAppUUIDMapping-fail";
    }
  }
  else
  {
    v9 = "unknown";
  }
  v10 = *(void **)(a2 + 96);
  if (v10)
  {
    free(v10);
    *(_QWORD *)(a2 + 96) = 0;
  }
  if (__s1)
    *(_QWORD *)(a2 + 96) = strdup(__s1);
  sub_20969D1E8(a1, 5, "krb5_sendto_set_delegated_app: %s - %s, %d uuid: %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x", v9, __s1, a4, *(unsigned __int8 *)(a2 + 72), *(unsigned __int8 *)(a2 + 73), *(unsigned __int8 *)(a2 + 74), *(unsigned __int8 *)(a2 + 75), *(unsigned __int8 *)(a2 + 76), *(unsigned __int8 *)(a2 + 77), *(unsigned __int8 *)(a2 + 78), *(unsigned __int8 *)(a2 + 79), *(unsigned __int8 *)(a2 + 80), *(unsigned __int8 *)(a2 + 81), *(unsigned __int8 *)(a2 + 82), *(unsigned __int8 *)(a2 + 83), *(unsigned __int8 *)(a2 + 84),
    *(unsigned __int8 *)(a2 + 85),
    *(unsigned __int8 *)(a2 + 86),
    *(unsigned __int8 *)(a2 + 87));
  return 0;
}

void krb5_sendto_ctx_free(uint64_t a1, const void *a2)
{
  heim_release(a2);
}

uint64_t sub_2096AB744(_krb5_context *a1, uint64_t a2, int a3, krb5_data *a4, int *a5)
{
  int v8;
  int v9;
  int v10;
  _OWORD v12[6];
  uint64_t v13;

  v13 = 0;
  memset(v12, 0, sizeof(v12));
  if (!krb5_rd_error(a1, a4, (krb5_error **)v12))
  {
    v8 = krb5_error_from_rd_error(a1, (uint64_t)v12, 0);
    krb5_free_error_contents((uint64_t)a1, (uint64_t)v12);
    if (v8 == -1765328355)
    {
      v10 = 2;
      goto LABEL_7;
    }
    if (v8 == -1765328332)
    {
      v9 = *(_DWORD *)(a2 + 32);
      if ((v9 & 2) == 0)
      {
        *(_DWORD *)(a2 + 32) = v9 | 2;
        v10 = 1;
LABEL_7:
        *a5 = v10;
      }
    }
  }
  return 0;
}

uint64_t krb5_sendto_context(uint64_t a1, uint64_t a2, _DWORD *a3, char *a4, _QWORD *a5)
{
  uint64_t v5;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  const void *v17;
  char *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  int v24;
  int v25;
  uint64_t v26;
  int v27;
  _QWORD *v28;
  int v29;
  uint64_t v30;
  uint64_t v31;
  int v32;
  const void *v33;
  uint64_t (*v34)(uint64_t, uint64_t, _QWORD, _QWORD *, int *);
  int inited;
  char *v36;
  addrinfo *v37;
  const __CFArray *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  int v44;
  uint64_t *v45;
  const __CFArray *v46;
  int v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  int v51;
  int v52;
  const char *v53;
  char *v54;
  char *v55;
  int v56;
  uint64_t v57;
  char *v58;
  char *v59;
  char *v60;
  unsigned int v61;
  uint64_t v62;
  addrinfo *v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  const __CFArray *v68;
  char *v69;
  int v70;
  addrinfo *v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  _QWORD *v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  const void *v90;
  unint64_t v91;
  uint64_t v92;
  int *v93;
  const char *v94;
  char v96;
  uint64_t v97;
  char v98;
  uint64_t v99;
  int v100;
  uint64_t v102;
  char *v104;
  uint64_t v105;
  int v106;
  timeval v107;
  timeval v108;
  timeval v109;
  int v110[2];
  timeval v111;
  void (*v112)(_QWORD *, uint64_t, _DWORD *, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t);
  void *v113;
  _BYTE *v114;
  char *v115;
  uint64_t *v116;
  uint64_t v117;
  uint64_t v118;
  addrinfo *v119[6];
  timeval v120;
  _QWORD *(*v121)(_QWORD *, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, char);
  void *v122;
  uint64_t *v123;
  _BYTE *v124;
  char *v125;
  uint64_t *v126;
  addrinfo *v127;
  uint64_t v128;
  uint64_t v129;
  timeval v130;
  uint64_t v131;
  uint64_t *v132;
  uint64_t v133;
  int v134;
  uint64_t v135;
  uint64_t *v136;
  uint64_t v137;
  int v138;
  uint64_t v139;
  uint64_t *v140;
  uint64_t v141;
  uint64_t v142;
  char __str[8];
  char *v144;
  uint64_t v145;
  __int128 v146;
  __int128 v147;
  __int128 v148;
  __int128 v149;
  __int128 v150;
  __int128 v151;
  __int128 v152;
  __int128 v153;
  _BYTE v154[56];
  __int128 v155;
  __int128 v156;
  __int128 v157;
  __int128 v158;
  __int128 v159;
  __int128 v160;
  uint64_t v161;

  v161 = *MEMORY[0x24BDAC8D0];
  v9 = 2529639068;
  *(_QWORD *)v110 = 0;
  krb5_data_zero(a5);
  heim_warn_blocking("krb5_sendto_context", &qword_2545A7DD0);
  v15 = a2;
  v16 = -1765328228;
  v99 = a2;
  if (!a2)
  {
    v15 = heim_uniq_alloc(0xF8uLL, (uint64_t)"sendto-context", (uint64_t)sub_2096AB4AC, v10, v11, v12, v13, v14);
    v16 = 0;
    *(_QWORD *)(v15 + 136) = heim_array_create();
  }
  *(_OWORD *)(v15 + 176) = 0u;
  *(_OWORD *)(v15 + 208) = 0u;
  *(_OWORD *)(v15 + 224) = 0u;
  *(_OWORD *)(v15 + 192) = 0u;
  gettimeofday((timeval *)(v15 + 176), 0);
  *(_QWORD *)(v15 + 144) = a4;
  v24 = *(_DWORD *)(a1 + 384);
  *(_DWORD *)(a1 + 384) = v24 + 1;
  *(_DWORD *)(v15 + 240) = v24 << 16;
  v100 = *(_DWORD *)(v15 + 36);
  if (!v100)
  {
    if ((*(_BYTE *)(v15 + 32) & 1) != 0)
    {
      v25 = 2;
    }
    else if (*(_DWORD *)(a1 + 224))
    {
      v25 = 2;
    }
    else
    {
      v25 = 1;
    }
    v100 = v25;
  }
  v104 = a4;
  *(_QWORD *)(v15 + 112) = a3;
  if (*(_DWORD *)(a1 + 336) < *a3)
    *(_DWORD *)(v15 + 32) |= 2u;
  v26 = 0;
  v27 = 4;
  v28 = (_QWORD *)(v15 + 120);
  v109.tv_sec = 0;
  *(_QWORD *)&v109.tv_usec = 0;
  v108.tv_sec = 0;
  *(_QWORD *)&v108.tv_usec = 0;
  v107.tv_sec = 0;
  *(_QWORD *)&v107.tv_usec = 0;
  v106 = 4;
  while (1)
  {
    if (v27 == 6)
      goto LABEL_128;
    v105 = 0;
    switch(v27)
    {
      case 1:
        sub_20969D1E8(a1, 5, "krb5_sendto trying over again (reset): %d", v26);
        sub_2096AC5B4(v15);
        v17 = *(const void **)v110;
        if (*(_QWORD *)v110)
        {
          krb5_krbhst_free(a1, *(const void **)v110);
          *(_QWORD *)v110 = 0;
        }
        v16 = 0;
        if ((int)v26 > 1)
          v29 = 6;
        else
          v29 = 7;
        v106 = v29;
        v26 = (v26 + 1);
        goto LABEL_90;
      case 2:
        v30 = v5;
        v139 = 0;
        v140 = &v139;
        v141 = 0x2000000000;
        v142 = 0;
        *(_QWORD *)v154 = 0;
        *(_QWORD *)&v154[8] = v154;
        *(_QWORD *)&v154[16] = 0x9800000000;
        *(_QWORD *)__str = 0;
        v144 = __str;
        v145 = 0x9800000000;
        v135 = 0;
        v136 = &v135;
        v137 = 0x2000000000;
        v138 = 0;
        v131 = 0;
        v132 = &v131;
        v133 = 0x2000000000;
        v134 = 0;
        v130.tv_sec = 0;
        *(_QWORD *)&v130.tv_usec = 0;
        v159 = 0u;
        v160 = 0u;
        memset(&v154[24], 0, 32);
        v155 = 0u;
        v156 = 0u;
        v157 = 0u;
        v158 = 0u;
        v152 = 0u;
        v153 = 0u;
        v146 = 0u;
        v147 = 0u;
        v148 = 0u;
        v149 = 0u;
        v150 = 0u;
        v151 = 0u;
        if (*v28)
        {
          v16 = 0;
          v106 = 5;
          v9 = 2529639068;
          goto LABEL_89;
        }
        v37 = (addrinfo *)time(0);
        v38 = *(const __CFArray **)(v15 + 136);
        v120.tv_sec = MEMORY[0x24BDAC760];
        *(_QWORD *)&v120.tv_usec = 0x40000000;
        v121 = sub_2096AD5D0;
        v122 = &unk_24C1F2848;
        v127 = v37;
        v128 = a1;
        v129 = v15;
        v123 = &v139;
        v124 = v154;
        v125 = __str;
        v126 = &v135;
        heim_array_iterate(v38, (uint64_t)&v120);
        if (!*((_DWORD *)v136 + 6))
        {
          v62 = v140[3];
          if (v62)
          {
            v63 = (addrinfo *)(*(_QWORD *)(v62 + 88) - (_QWORD)v37);
            sub_2096AC7FC(a1, v15, v62, v39, v40, v41, v42, v43);
            sub_2096AD708(v140[3], (char *)(*(_QWORD *)&v154[8] + 24), (uint64_t)(v144 + 24), (_DWORD *)v136 + 6, v64, v65, v66, v67);
            if ((uint64_t)v63 >= 1)
            {
              v68 = *(const __CFArray **)(v15 + 136);
              v119[0] = (addrinfo *)MEMORY[0x24BDAC760];
              v119[1] = (addrinfo *)0x40000000;
              v119[2] = (addrinfo *)sub_2096AD814;
              v119[3] = (addrinfo *)&unk_24C1F2868;
              v119[4] = v63;
              v119[5] = v37;
              heim_array_iterate(v68, (uint64_t)v119);
            }
          }
        }
        heim_array_filter(*(const __CFArray **)(v15 + 136), (uint64_t)&unk_24C1F0090);
        v5 = v30;
        v9 = 2529639068;
        if (heim_array_get_length(*(CFArrayRef *)(v15 + 136)))
        {
          v130.tv_sec = 1;
          v130.tv_usec = 0;
          v44 = select(*((_DWORD *)v136 + 6) + 1, (fd_set *)(*(_QWORD *)&v154[8] + 24), (fd_set *)(v144 + 24), 0, &v130);
          v45 = v132;
          *((_DWORD *)v132 + 6) = v44;
          if ((v44 & 0x80000000) == 0)
          {
            v28 = (_QWORD *)(v15 + 120);
            if (!v44)
              goto LABEL_84;
            *((_DWORD *)v45 + 6) = 0;
            v46 = *(const __CFArray **)(v15 + 136);
            v111.tv_sec = MEMORY[0x24BDAC760];
            *(_QWORD *)&v111.tv_usec = 0x40000000;
            v112 = sub_2096AD854;
            v113 = &unk_24C1F28B0;
            v114 = v154;
            v115 = __str;
            v116 = &v131;
            v117 = a1;
            v118 = v15;
            heim_array_iterate(v46, (uint64_t)&v111);
            v16 = 0;
            if (*((_DWORD *)v132 + 6))
              v47 = 5;
            else
              v47 = 2;
            goto LABEL_85;
          }
          if (*__error() == 35 && *__error() == 4)
          {
            *((_DWORD *)v132 + 6) = 0;
            v28 = (_QWORD *)(v15 + 120);
LABEL_84:
            v16 = 0;
            v47 = 3;
LABEL_85:
            v106 = v47;
            goto LABEL_89;
          }
          v16 = *__error();
          v28 = (_QWORD *)(v15 + 120);
        }
        else
        {
          if ((*(_DWORD *)(v15 + 152) & 1) != 0)
            v69 = "no more hosts to send/recv packets to/from trying to pulling more hosts";
          else
            v69 = "no more hosts to send/recv packets to/from and no more hosts -> failure";
          if ((*(_DWORD *)(v15 + 152) & 1) != 0)
            v70 = 6;
          else
            v70 = 3;
          sub_20969D1E8(a1, 5, v69);
          v16 = 0;
          v106 = v70;
          v28 = (_QWORD *)(v15 + 120);
        }
LABEL_89:
        _Block_object_dispose(&v131, 8);
        _Block_object_dispose(&v135, 8);
        _Block_object_dispose(__str, 8);
        _Block_object_dispose(v154, 8);
        _Block_object_dispose(&v139, 8);
        if (v16)
          goto LABEL_128;
        goto LABEL_90;
      case 3:
        goto LABEL_49;
      case 4:
        v31 = *(_QWORD *)(a1 + 88);
        *(_OWORD *)v154 = (unint64_t)v104;
        *(_QWORD *)&v154[16] = v31;
        *(_QWORD *)&v154[24] = a3;
        *(_QWORD *)&v154[32] = a5;
        v32 = krb5_plugin_run_f(a1, "krb5", "send_to_kdc", 2u, 0, (uint64_t)v154, (uint64_t)sub_2096AC5EC);
        if (v32 != -1765328135)
        {
          v16 = v32;
          v106 = 0;
          goto LABEL_90;
        }
        v106 = 7;
        v16 = -1765328135;
LABEL_25:
        v33 = *(const void **)(v15 + 104);
        if (v33)
        {
          *(_QWORD *)v110 = heim_retain(v33);
        }
        else
        {
          inited = krb5_krbhst_init_flags((_krb5_context *)a1, v104, v100, *(_DWORD *)(v15 + 32), (uint64_t *)v110);
          if (inited
            || (v36 = *(char **)(v15 + 56)) != 0
            && (inited = krb5_krbhst_set_hostname((_krb5_context *)a1, *(uint64_t *)v110, v36)) != 0
            || (v18 = *(char **)(v15 + 64)) != 0
            && (inited = krb5_krbhst_set_sitename((_krb5_context *)a1, *(uint64_t *)v110, v18)) != 0)
          {
LABEL_127:
            v16 = inited;
            goto LABEL_128;
          }
          if ((*(_BYTE *)(v15 + 156) & 1) != 0)
          {
            inited = krb5_krbhst_set_delgated_uuid(a1, *(uint64_t *)v110, (unsigned __int8 *)(v15 + 72));
            if (inited)
              goto LABEL_127;
            v16 = krb5_krbhst_set_delgated_pid(a1, *(uint64_t *)v110, *(_DWORD *)(v15 + 88));
            if (v16)
              goto LABEL_128;
          }
          else
          {
            v16 = 0;
          }
        }
        v106 = 3;
LABEL_49:
        if ((*(_BYTE *)(v15 + 152) & 1) != 0)
        {
          v106 = 2;
          goto LABEL_90;
        }
        gettimeofday(&v109, 0);
        v16 = krb5_krbhst_next(a1, *(uint64_t *)v110, &v105);
        gettimeofday(&v108, 0);
        sub_2096D4088((uint64_t)&v108, (uint64_t)&v109);
        sub_2096D4028(v15 + 208, (uint64_t)&v108);
        v106 = 2;
        if (v16)
        {
          sub_20969D1E8(a1, 5, "out of hosts, waiting for replies");
          *(_DWORD *)(v15 + 152) |= 1u;
          goto LABEL_90;
        }
        sub_20969D1E8(a1, 5, "submissing new requests to new host");
        v48 = v105;
        v120.tv_sec = 0;
        *(_QWORD *)&v120.tv_usec = 0;
        v111.tv_sec = 0;
        *(_QWORD *)&v111.tv_usec = 0;
        v119[0] = 0;
        v49 = *(_QWORD *)(a1 + 88);
        v50 = *(_QWORD *)(v15 + 112);
        *(_QWORD *)v154 = 0;
        *(_QWORD *)&v154[8] = v105;
        *(_QWORD *)&v154[16] = v49;
        *(_QWORD *)&v154[24] = v50;
        *(_QWORD *)&v154[32] = v28;
        v51 = krb5_plugin_run_f(a1, "krb5", "send_to_kdc", 0, 0, (uint64_t)v154, (uint64_t)sub_2096ACA14);
        v102 = v26;
        if (v51 == -1765328135)
        {
          gettimeofday(&v120, 0);
          if (*(_DWORD *)v48 == 3)
          {
            v119[0] = 0;
LABEL_93:
            v98 = 1;
            goto LABEL_94;
          }
          if (*(_DWORD *)v48 != 2 || (v53 = *(const char **)(a1 + 184)) == 0)
          {
            if (krb5_krbhst_get_addrinfo(a1, v48, v119))
              goto LABEL_121;
            goto LABEL_93;
          }
          v54 = strdup(v53);
          if (v54)
          {
            v55 = v54;
            v56 = strncmp(v54, "http://", 7uLL);
            v57 = 7;
            if (v56)
              v57 = 0;
            v58 = &v55[v57];
            v59 = strchr(&v55[v57], 47);
            if (v59)
              *v59 = 0;
            v60 = strchr(v58, 58);
            if (v60)
            {
              *v60 = 0;
              memset(v154, 0, 48);
              *(_DWORD *)&v154[8] = 1;
              LODWORD(v139) = 0;
              sscanf(v60 + 1, "%d", &v139);
              v61 = bswap32((unsigned __int16)v139) >> 16;
            }
            else
            {
              memset(v154, 0, 48);
              v61 = 20480;
              *(_DWORD *)&v154[8] = 1;
            }
            snprintf(__str, 0x20uLL, "%d", __rev16(v61), v97);
            v92 = getaddrinfo(v58, __str, (const addrinfo *)v154, v119);
            free(v55);
            if (!(_DWORD)v92)
            {
              v98 = 0;
LABEL_94:
              gettimeofday(&v111, 0);
              sub_2096D4088((uint64_t)&v111, (uint64_t)&v120);
              sub_2096D4028(v15 + 192, (uint64_t)&v111);
              ++*(_QWORD *)(v15 + 232);
              v71 = v119[0];
              if (!v119[0])
              {
                v72 = 0;
LABEL_108:
                if (*(_DWORD *)v48 == 3)
                {
                  if (v119[0])
                    heim_abort("kkdcp host with ai ?:ai == NULL", (uint64_t)v17, (uint64_t)v18, v19, v20, v21, v22, v23, v96);
                  if (socketpair(1, 1, 0, (int *)v154) < 0)
                    goto LABEL_121;
                  rk_socket_set_nopipe(*(int *)v154, 1);
                  rk_socket_set_nopipe(*(int *)&v154[4], 1);
                  sub_2096B99E8(*(int *)v154, 1);
                  sub_2096B99E8(*(int *)&v154[4], 1);
                  v89 = sub_2096AC61C(a1, v15, (int *)v48, 0, *(unsigned int *)v154, v86, v87, v88);
                  if (!v89)
                  {
                    close(*(int *)v154);
                    close(*(int *)&v154[4]);
LABEL_121:
                    v9 = 2529639068;
                    v28 = (_QWORD *)(v15 + 120);
                    v26 = v102;
LABEL_122:
                    v16 = 0;
                    v106 = 3;
                    goto LABEL_90;
                  }
                  v90 = (const void *)v89;
                  *(_DWORD *)(v89 + 68) = *(_DWORD *)&v154[4];
                  v91 = *(_QWORD *)(a1 + 88) / *(int *)(*(_QWORD *)(v89 + 72) + 24);
                  if (v91 <= 1)
                    v91 = 1;
                  *(_QWORD *)(v89 + 88) = v91;
                  *(_QWORD *)(v89 + 88) += time(0);
                  sub_2096AC924(a1, v15, (uint64_t)v90);
                  ++v72;
                  heim_release(v90);
                }
                if ((v98 & 1) == 0)
                  freeaddrinfo(v119[0]);
                if (!v72)
                  goto LABEL_121;
LABEL_55:
                v16 = 0;
                v9 = 2529639068;
                v28 = (_QWORD *)(v15 + 120);
                v26 = v102;
                goto LABEL_90;
              }
              v72 = 0;
              while (2)
              {
                v73 = socket(v71->ai_family, v71->ai_socktype, v71->ai_protocol);
                if ((v73 & 0x80000000) == 0)
                {
                  v74 = v73;
                  sub_2096B7FDC(v73);
                  rk_socket_set_nopipe(v74, 1);
                  sub_2096B99E8(v74, 1);
                  if (v74 >= 0x400)
                  {
                    sub_20969D1E8(a1, 0, "fd too large for select");
                    goto LABEL_102;
                  }
                  v78 = sub_2096AC61C(a1, v15, (int *)v48, (uint64_t)v71, v74, v75, v76, v77);
                  if (v78)
                  {
                    v85 = (_QWORD *)v78;
                    if (v72)
                    {
                      v97 = v72 + 1;
                      sub_2096AC8F0(a1, v79, v78, "Queuing host in future (in %ds), its the %lu address on the same name", v81, v82, v83, v84, *(_BYTE *)(a1 + 96) * v72);
                      v85[11] = time(0) + *(_QWORD *)(a1 + 96) * v72++;
                    }
                    else
                    {
                      sub_2096AC7FC(a1, v15, v78, v80, v81, v82, v83, v84);
                      v72 = 1;
                    }
                    heim_release(v85);
                  }
                  else
                  {
LABEL_102:
                    close(v74);
                  }
                }
                v71 = v71->ai_next;
                if (!v71)
                  goto LABEL_108;
                continue;
              }
            }
            v93 = __error();
            v52 = krb5_eai_to_heim_errno(v92, *v93);
            v9 = 2529639068;
          }
          else
          {
            v52 = 12;
            v9 = 2529639068;
          }
        }
        else
        {
          v52 = v51;
          if (!v51)
            goto LABEL_55;
          sub_20969D1E8(a1, 5, "send via plugin failed %s: %d", (const char *)(v48 + 48), v51);
          v9 = 2529639068;
          v28 = (_QWORD *)(v15 + 120);
        }
        if (v52)
          goto LABEL_122;
        v16 = 0;
LABEL_90:
        v27 = v106;
        if (!v106)
          goto LABEL_128;
        break;
      case 5:
        v106 = 0;
        v34 = *(uint64_t (**)(uint64_t, uint64_t, _QWORD, _QWORD *, int *))(v15 + 40);
        if (!v34)
          goto LABEL_90;
        inited = v34(a1, v15, *(_QWORD *)(v15 + 48), v28, &v106);
        if (inited)
          goto LABEL_127;
        v16 = v106;
        if ((v106 - 1) < 2)
        {
          krb5_data_free(v28);
          v16 = 0;
          goto LABEL_90;
        }
        if (!v106)
          goto LABEL_90;
        krb5_set_error_message((krb5_context)a1, -1765328228, "sendto filter funcation return unsupported state: %d", v106);
        v16 = -1765328228;
LABEL_128:
        gettimeofday(&v107, 0);
        sub_2096D4088((uint64_t)&v107, v15 + 176);
        if (v16 || !*v28)
        {
          krb5_data_free(v28);
          krb5_clear_error_message((krb5_context)a1);
          v94 = "KDCs";
          if (*(_QWORD *)(v15 + 232) == 1)
            v94 = "KDC";
          krb5_set_error_message((krb5_context)a1, -1765328228, "unable to reach any KDC in realm %s, tried %lu %s", v104, *(_QWORD *)(v15 + 232), v94);
        }
        else
        {
          *(_OWORD *)a5 = *(_OWORD *)v28;
          krb5_data_zero(v28);
          v9 = 0;
        }
        sub_20969D1E8(a1, 1, "krb5_sendto_context %s done: %d hosts %lu packets %lu wc: %lld.%06d nr: %lld.%06d kh: %lld.%06d tid: %08x", *(const char **)(v15 + 144), v9, *(_QWORD *)(v15 + 232), *(_QWORD *)(v15 + 224), v107.tv_sec, v107.tv_usec, *(_QWORD *)(v15 + 192), *(_DWORD *)(v15 + 200), *(_QWORD *)(v15 + 208), *(_DWORD *)(v15 + 216), *(_DWORD *)(v15 + 240));
        if (v99)
          sub_2096AC5B4(v15);
        else
          heim_release((CFTypeRef)v15);
        if (*(_QWORD *)v110)
          krb5_krbhst_free(a1, *(const void **)v110);
        return v9;
      case 7:
        goto LABEL_25;
      default:
        heim_abort("invalid krb5_sendto_context action: %d", (uint64_t)v17, (uint64_t)v18, v19, v20, v21, v22, v23, v27);
    }
  }
}

CFMutableArrayRef sub_2096AC5B4(uint64_t a1)
{
  CFMutableArrayRef result;

  krb5_data_free((_QWORD *)(a1 + 120));
  heim_release(*(CFTypeRef *)(a1 + 136));
  result = heim_array_create();
  *(_QWORD *)(a1 + 136) = result;
  *(_DWORD *)(a1 + 152) = 0;
  return result;
}

uint64_t sub_2096AC5EC(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD *a4)
{
  uint64_t (*v4)(uint64_t, uint64_t, _QWORD, _QWORD, _QWORD, _QWORD);

  v4 = *(uint64_t (**)(uint64_t, uint64_t, _QWORD, _QWORD, _QWORD, _QWORD))(a2 + 32);
  if (v4)
    return v4(a1, a3, *a4, a4[2], a4[3], a4[4]);
  else
    return 2529639161;
}

uint64_t sub_2096AC61C(uint64_t a1, uint64_t a2, int *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8;
  uint64_t v13;
  uint64_t v14;
  unsigned int v15;
  uint64_t v16;
  int *v17;
  int *v18;
  int *v19;
  int *v20;
  char *v21;
  char *v22;

  v8 = a5;
  v13 = heim_uniq_alloc(0x78uLL, (uint64_t)"sendto-host", (uint64_t)sub_2096ACA40, a4, a5, a6, a7, a8);
  v14 = v13;
  if (v13)
  {
    *(_DWORD *)(v13 + 64) = v8;
    *(_DWORD *)(v13 + 68) = -1;
    *(_QWORD *)(v13 + 48) = a3;
    *(_QWORD *)(v13 + 56) = a4;
    *(_QWORD *)(v13 + 32) = a2;
    v15 = ((unsigned __int16)*(_DWORD *)(a2 + 240) + 1) | *(_DWORD *)(a2 + 240) & 0xFFFF0000;
    *(_DWORD *)(a2 + 240) = v15;
    *(_DWORD *)(v13 + 112) = v15;
    *(_DWORD *)(v13 + 40) = 0;
    v16 = *a3;
    if (v16 <= 3)
      *(_QWORD *)(v13 + 72) = off_24C1F28D0[v16];
    if ((*(_BYTE *)(a2 + 156) & 1) != 0)
    {
      v17 = __error();
      sub_20969D1E8(a1, 5, "host_create: setting host delegate uuid", *v17);
      if (setsockopt(*(_DWORD *)(v14 + 64), 0xFFFF, 4360, (const void *)(a2 + 72), 0x10u))
      {
        v18 = __error();
        sub_20969D1E8(a1, 5, "host_create: SO_DELEGATED_UUID failed: %d", *v18);
      }
      if (*(_DWORD *)(a2 + 88))
      {
        v19 = __error();
        sub_20969D1E8(a1, 5, "host_create: setting host delegate process", *v19);
        if (setsockopt(*(_DWORD *)(v14 + 64), 0xFFFF, 4359, (const void *)(a2 + 88), 4u))
        {
          v20 = __error();
          sub_20969D1E8(a1, 5, "host_create: SO_DELEGATED failed: %d", *v20);
        }
      }
    }
    v21 = strdup((const char *)(*(_QWORD *)(v14 + 48) + 48));
    if (v21)
    {
      v22 = v21;
      sub_2096979B0(v21);
      sub_20969D1E8(a1, 5, "host_create: setting hostname %s", v22);
      ne_session_set_socket_attributes();
      free(v22);
    }
    *(_DWORD *)(v14 + 80) = *(_DWORD *)(*(_QWORD *)(v14 + 72) + 24);
    heim_array_append_value(*(__CFArray **)(a2 + 136), (const void *)v14);
  }
  return v14;
}

time_t sub_2096AC7FC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;
  time_t result;
  char v25;

  v11 = *(_QWORD *)(a3 + 56);
  sub_2096AC8F0(a1, a2, a3, "connecting to host", a5, a6, a7, a8, v25);
  if (connect(*(_DWORD *)(a3 + 64), *(const sockaddr **)(v11 + 32), *(_DWORD *)(v11 + 16)) < 0)
  {
    if (*__error() == 36)
    {
      sub_2096AC8F0(a1, v12, a3, "connecting to %d (in progress)", v13, v14, v15, v16, *(_DWORD *)(a3 + 64));
      *(_DWORD *)(a3 + 40) = 1;
    }
    else
    {
      v17 = __error();
      sub_2096AD44C(a1, a3, "failed to connect: %d", v18, v19, v20, v21, v22, *v17);
    }
  }
  else
  {
    sub_2096AC924(a1, a2, a3);
  }
  v23 = *(_QWORD *)(a1 + 88) / *(int *)(*(_QWORD *)(a3 + 72) + 24);
  if (v23 <= 1)
    v23 = 1;
  *(_QWORD *)(a3 + 88) = v23;
  result = time(0);
  *(_QWORD *)(a3 + 88) += result;
  return result;
}

void sub_2096AC8F0(uint64_t a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  sub_2096AD498(a1, a3, a4, &a9);
}

void sub_2096AC924(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  _QWORD v13[2];

  *(_DWORD *)(a3 + 40) = 2;
  if (*(_QWORD *)(a2 + 160))
  {
    v13[0] = 0;
    v13[1] = 0;
    krb5_data_zero(v13);
    v12 = (*(uint64_t (**)(uint64_t, _QWORD, _QWORD, _QWORD, _QWORD *))(a2 + 160))(a1, **(unsigned int **)(a3 + 48), *(_QWORD *)(a2 + 168), *(unsigned int *)(a3 + 64), v13);
    if (!v12)
    {
      if (!v13[0])
      {
        sub_2096AD44C(a1, a3, "prexmit function didn't send data", v7, v8, v9, v10, v11, 0);
        return;
      }
      v12 = (**(uint64_t (***)(uint64_t, uint64_t, _QWORD *))(a3 + 72))(a1, a3, v13);
      krb5_data_free(v13);
    }
  }
  else
  {
    v12 = (**(uint64_t (***)(uint64_t, uint64_t, _QWORD))(a3 + 72))(a1, a3, *(_QWORD *)(a2 + 112));
  }
  if (v12)
    sub_2096AC8F0(a1, v6, a3, "failed to prexmit/prepare", v8, v9, v10, v11, v13[0]);
}

uint64_t sub_2096ACA14(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD *a4)
{
  uint64_t (*v4)(uint64_t, uint64_t, _QWORD, _QWORD, _QWORD, _QWORD);

  v4 = *(uint64_t (**)(uint64_t, uint64_t, _QWORD, _QWORD, _QWORD, _QWORD))(a2 + 24);
  if (v4)
    return v4(a1, a3, a4[1], a4[2], a4[3], a4[4]);
  else
    return 2529639161;
}

void sub_2096ACA40(uint64_t a1)
{
  int v2;
  int v3;

  v2 = *(_DWORD *)(a1 + 64);
  if ((v2 & 0x80000000) == 0)
    close(v2);
  v3 = *(_DWORD *)(a1 + 68);
  if ((v3 & 0x80000000) == 0)
    close(v3);
  krb5_data_free((_QWORD *)(a1 + 96));
  *(_QWORD *)(a1 + 56) = 0;
}

uint64_t sub_2096ACA80(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v10;
  uint64_t result;
  int v12;
  char *v13;
  size_t v14;
  char v15;
  char *__s;
  void *v17;

  __s = 0;
  v17 = 0;
  if (*(_QWORD *)(a2 + 96))
    heim_abort("prepare_http called twice:host->data.length == 0", a2, a3, a4, a5, a6, a7, a8, v15);
  if ((base64_encode(*(_QWORD *)(a3 + 8), *(_DWORD *)a3, (const char **)&v17) & 0x80000000) != 0)
    return 12;
  if (*(_QWORD *)(a1 + 184))
    v10 = asprintf(&__s, "GET http://%s/%s HTTP/1.0\r\n\r\n");
  else
    v10 = asprintf(&__s, "GET /%s HTTP/1.0\r\n\r\n");
  v12 = v10;
  free(v17);
  result = 12;
  if ((v12 & 0x80000000) == 0)
  {
    v13 = __s;
    if (__s)
    {
      *(_QWORD *)(a2 + 104) = __s;
      v14 = strlen(v13);
      result = 0;
      *(_QWORD *)(a2 + 96) = v14;
    }
  }
  return result;
}

uint64_t sub_2096ACB4C(uint64_t a1, uint64_t a2)
{
  _QWORD *v3;
  unint64_t v4;
  unint64_t v5;

  v3 = (_QWORD *)(a2 + 96);
  v4 = write(*(_DWORD *)(a2 + 64), *(const void **)(a2 + 104), *(_QWORD *)(a2 + 96));
  if ((v4 & 0x8000000000000000) != 0)
    return *__error();
  v5 = *v3 - v4;
  if (*v3 <= v4)
  {
    krb5_data_free(v3);
    return 0;
  }
  else
  {
    *(_QWORD *)(a2 + 96) = v5;
    memmove(*(void **)(a2 + 104), (const void *)(*(_QWORD *)(a2 + 104) + v4), v5 - v4);
    return 0xFFFFFFFFLL;
  }
}

uint64_t sub_2096ACBC4(int *a1, uint64_t a2, _OWORD *a3)
{
  uint64_t result;
  char *v6;
  char *v7;
  char *v8;
  unsigned __int8 *v9;
  size_t v10;
  size_t __len;

  result = sub_2096ACC94(a1, a2);
  if (!(_DWORD)result)
  {
    v6 = *(char **)(a2 + 104);
    v7 = strstr(v6, "\r\n\r\n");
    if (!v7)
      return 0xFFFFFFFFLL;
    v8 = v7;
    v9 = (unsigned __int8 *)(v7 + 4);
    v10 = *(_QWORD *)(a2 + 96) + v6 - (char *)v9;
    if (v10 < 4)
      return 2529638973;
    __len = 0;
    _krb5_get_int(v9, &__len, 4);
    if (v10 >= __len)
    {
      memmove(*(void **)(a2 + 104), v8 + 8, __len);
      *(_QWORD *)(a2 + 96) = __len;
      *a3 = *(_OWORD *)(a2 + 96);
      krb5_data_zero((_QWORD *)(a2 + 96));
      return 0;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t sub_2096ACC94(int *a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  BOOL v9;
  uint64_t v10;
  uint64_t v11;
  ssize_t v12;
  int *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  size_t v20;

  LODWORD(v20) = 0;
  if (ioctl(*(_DWORD *)(a2 + 64), 0x4004667FuLL))
    v9 = 1;
  else
    v9 = (int)v20 <= 0;
  if (v9)
  {
    sub_2096AC8F0((uint64_t)a1, v4, a2, "failed to get nbytes from socket, no bytes there?", v5, v6, v7, v8, (char)&v20);
    return 2314790848;
  }
  else
  {
    v11 = *(_QWORD *)(a2 + 96);
    if (a1[85] - v11 >= (unint64_t)v20)
    {
      v10 = krb5_data_realloc(a2 + 96, v20 + v11 + 1);
      if (!(_DWORD)v10)
      {
        v12 = read(*(_DWORD *)(a2 + 64), (void *)(*(_QWORD *)(a2 + 104) + v11), (int)v20);
        if (v12 <= 0)
        {
          v13 = __error();
          v10 = *v13;
          sub_2096AC8F0((uint64_t)a1, v14, a2, "failed to read bytes from stream: %d", v15, v16, v17, v18, *v13);
        }
        else
        {
          v10 = 0;
          *(_QWORD *)(a2 + 96) = v12 + v11;
          *(_BYTE *)(*(_QWORD *)(a2 + 104) + v12 + v11) = 0;
        }
      }
    }
    else
    {
      v10 = 2529638973;
      krb5_set_error_message((krb5_context)a1, -1765328323, "TCP message from KDC too large %d", v20 + v11);
    }
  }
  return v10;
}

uint64_t sub_2096ACDC0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  size_t *v8;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v15;
  char v16;

  v8 = (size_t *)(a2 + 96);
  if (*(_QWORD *)(a2 + 96))
    heim_abort("prepare_kkdcp called twice:host->data.length == 0", a2, a3, a4, a5, a6, a7, a8, v16);
  if (!krb5_config_get_BOOL_default(a1, 0, 1, a4, a5, a6, a7, a8, (uint64_t)"libdefaults"))
    return krb5_data_copy(v8, *(const void **)(a3 + 8), *(_QWORD *)a3);
  v10 = krb5_storage_emem();
  if (!v10)
    return 12;
  v11 = (uint64_t)v10;
  v12 = krb5_store_data((uint64_t)v10, *(_QWORD *)a3, *(_QWORD *)(a3 + 8));
  if ((_DWORD)v12)
  {
    v13 = v12;
    krb5_storage_free(v11);
    return v13;
  }
  v15 = krb5_storage_to_data(v11, v8);
  krb5_storage_free(v11);
  return v15;
}

uint64_t sub_2096ACE98(const void *a1, uint64_t a2)
{
  NSObject *global_queue;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD block[8];
  uint64_t v13;
  uint64_t *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  char *v18;

  v17 = 0;
  v18 = 0;
  v13 = 0;
  v14 = &v13;
  v15 = 0x2800000000;
  v16 = 0;
  global_queue = dispatch_get_global_queue(0, 0);
  heim_retain((CFTypeRef)a2);
  heim_retain(*(CFTypeRef *)(a2 + 32));
  if (*(unsigned __int16 *)(*(_QWORD *)(a2 + 48) + 6) == *(unsigned __int16 *)(*(_QWORD *)(a2 + 48) + 4))
    asprintf(&v18, "https://%s/%s");
  else
    asprintf(&v18, "https://%s:%d/%s");
  if (v18)
  {
    *(_OWORD *)(v14 + 3) = *(_OWORD *)(a2 + 96);
    krb5_data_zero((_QWORD *)(a2 + 96));
    sub_2096AC8F0((uint64_t)a1, v5, a2, "sending request to: %s", v6, v7, v8, v9, (char)v18);
    heim_retain(a1);
    block[0] = MEMORY[0x24BDAC760];
    block[1] = 0x40000000;
    block[2] = sub_2096AD0E0;
    block[3] = &unk_24C1F2820;
    block[6] = a2;
    block[7] = v18;
    block[4] = &v13;
    block[5] = a1;
    dispatch_async(global_queue, block);
    v10 = 0;
  }
  else
  {
    v10 = 12;
  }
  _Block_object_dispose(&v13, 8);
  return v10;
}

uint64_t sub_2096AD004(int *a1, uint64_t a2, _OWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _BOOL4 BOOL_default;
  uint64_t result;
  size_t v13;
  size_t v14;

  BOOL_default = krb5_config_get_BOOL_default((uint64_t)a1, 0, 1, a4, a5, a6, a7, a8, (uint64_t)"libdefaults");
  result = sub_2096ACC94(a1, a2);
  if (!(_DWORD)result)
  {
    if (*(_QWORD *)(a2 + 96) < 4uLL)
      return 0xFFFFFFFFLL;
    v14 = 0;
    if (BOOL_default)
    {
      _krb5_get_int(*(unsigned __int8 **)(a2 + 104), &v14, 4);
      v13 = *(_QWORD *)(a2 + 96) - 4;
      if (v14 > v13)
        return 0xFFFFFFFFLL;
      memmove(*(void **)(a2 + 104), (const void *)(*(_QWORD *)(a2 + 104) + 4), v13);
      *(_QWORD *)(a2 + 96) -= 4;
    }
    *a3 = *(_OWORD *)(a2 + 96);
    krb5_data_zero((_QWORD *)(a2 + 96));
    return 0;
  }
  return result;
}

void sub_2096AD0E0(uint64_t a1)
{
  int v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  size_t v9;
  char *v10;

  v9 = 0;
  v10 = 0;
  krb5_data_zero(&v9);
  v2 = sub_2096A8240(*(_krb5_context **)(a1 + 40), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 32) + 144), *(const char **)(a1 + 56), (__int128 *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24), &v9);
  krb5_data_free((_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24));
  free(*(void **)(a1 + 56));
  if (!v2)
  {
    sub_2096AC8F0(*(_QWORD *)(a1 + 40), v3, *(_QWORD *)(a1 + 48), "kkdcp: got %d bytes, feeding them back", v4, v5, v6, v7, v9);
    krb5_net_write_block(*(_QWORD *)(a1 + 40), (int *)(*(_QWORD *)(a1 + 48) + 68), v10, v9, 2);
    krb5_data_free(&v9);
  }
  close(*(_DWORD *)(*(_QWORD *)(a1 + 48) + 68));
  v8 = *(_QWORD *)(a1 + 48);
  *(_DWORD *)(v8 + 68) = -1;
  heim_release(*(CFTypeRef *)(v8 + 32));
  heim_release(*(CFTypeRef *)(a1 + 48));
  heim_release(*(CFTypeRef *)(a1 + 40));
}

uint64_t sub_2096AD1B4(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  size_t *v8;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  char v14;

  v8 = (size_t *)(a2 + 96);
  if (*(_QWORD *)(a2 + 96))
    heim_abort("prepare_tcp called twice:host->data.length == 0", a2, (uint64_t)a3, a4, a5, a6, a7, a8, v14);
  v10 = krb5_storage_emem();
  if (!v10)
    return 12;
  v11 = (uint64_t)v10;
  v12 = krb5_store_data((uint64_t)v10, *a3, a3[1]);
  if (!(_DWORD)v12)
    v12 = krb5_storage_to_data(v11, v8);
  krb5_storage_free(v11);
  return v12;
}

uint64_t sub_2096AD230(int *a1, uint64_t a2, _OWORD *a3)
{
  uint64_t result;
  size_t v6;
  size_t v7;

  result = sub_2096ACC94(a1, a2);
  if (!(_DWORD)result)
  {
    if (*(_QWORD *)(a2 + 96) >= 4uLL
      && (v7 = 0, _krb5_get_int(*(unsigned __int8 **)(a2 + 104), &v7, 4), v6 = *(_QWORD *)(a2 + 96) - 4, v7 <= v6))
    {
      memmove(*(void **)(a2 + 104), (const void *)(*(_QWORD *)(a2 + 104) + 4), v6);
      *(_QWORD *)(a2 + 96) -= 4;
      *a3 = *(_OWORD *)(a2 + 96);
      krb5_data_zero((_QWORD *)(a2 + 96));
      return 0;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t sub_2096AD2D4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return krb5_data_copy((_QWORD *)(a2 + 96), *(const void **)(a3 + 8), *(_QWORD *)a3);
}

uint64_t sub_2096AD2E0(uint64_t a1, uint64_t a2)
{
  ssize_t v2;
  uint64_t result;

  v2 = send(*(_DWORD *)(a2 + 64), *(const void **)(a2 + 104), *(_QWORD *)(a2 + 96), 0);
  result = 0;
  if (v2 < 0)
    return *__error();
  return result;
}

uint64_t sub_2096AD318(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int v9;

  v9 = 0;
  ioctl(*(_DWORD *)(a2 + 64), 0x4004667FuLL);
  sub_2096AC8F0(a1, 0, a2, "failed to get nbytes from socket, no bytes there?", v4, v5, v6, v7, (char)&v9);
  return 2314790848;
}

uint64_t sub_2096AD44C(uint64_t a1, uint64_t a2, const char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t result;

  sub_2096AD498(a1, a2, a3, &a9);
  result = close(*(_DWORD *)(a2 + 64));
  *(_DWORD *)(a2 + 64) = -1;
  *(_DWORD *)(a2 + 40) = 4;
  return result;
}

void sub_2096AD498(uint64_t a1, uint64_t a2, const char *a3, va_list a4)
{
  uint64_t v8;
  const char *v9;
  uint64_t v10;
  char *v11;
  char v12[32];
  char v13[1025];
  uint64_t v14;

  v14 = *MEMORY[0x24BDAC8D0];
  v11 = 0;
  if (_krb5_have_debug(a1) && vasprintf(&v11, a3, a4) != -1 && v11)
  {
    v8 = **(int **)(a2 + 48);
    if (v8 > 3)
      v9 = "unknown";
    else
      v9 = off_24C1F28F0[v8];
    v10 = *(_QWORD *)(a2 + 56);
    if (!v10 || getnameinfo(*(const sockaddr **)(v10 + 32), *(_DWORD *)(v10 + 16), v13, 0x401u, v12, 0x20u, 10))
    {
      v13[0] = 0;
      v12[0] = 0;
    }
    sub_20969D1E8(a1, 5, "%s: %s %s:%s (%s) tid: %08x", v11, v9, v13, v12, (const char *)(*(_QWORD *)(a2 + 48) + 48), *(_DWORD *)(a2 + 112));
    free(v11);
  }
}

_QWORD *sub_2096AD5D0(_QWORD *result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  int v9;
  _QWORD *v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  int v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;
  char v19;

  v9 = *(_DWORD *)(a2 + 40);
  if (v9 == 4)
    return result;
  v11 = result;
  if (!v9)
  {
    v12 = *(_QWORD *)(a2 + 88);
    if (v12 >= result[8])
    {
      v17 = *(_QWORD *)(result[4] + 8);
      v18 = *(_QWORD *)(v17 + 24);
      if (!v18 || *(_QWORD *)(v18 + 88) > v12)
        *(_QWORD *)(v17 + 24) = a2;
      return result;
    }
    sub_2096AC7FC(result[9], result[10], a2, a4, a5, a6, a7, a8);
  }
  if (*(_QWORD *)(a2 + 88) >= v11[8])
    return (_QWORD *)sub_2096AD708(a2, (char *)(*(_QWORD *)(v11[5] + 8) + 24), *(_QWORD *)(v11[6] + 8) + 24, (_DWORD *)(*(_QWORD *)(v11[7] + 8) + 24), a5, a6, a7, a8);
  v13 = *(_DWORD *)(a2 + 80);
  if (!v13)
    heim_abort("tries should not reach 0:h->tries != 0", a2, a3, a4, a5, a6, a7, a8, v19);
  v14 = v11[9];
  v15 = v13 - 1;
  *(_DWORD *)(a2 + 80) = v15;
  if (v15)
  {
    sub_2096AC8F0(v14, a2, a2, "retrying sending to", a5, a6, a7, a8, v19);
    v16 = *(_QWORD *)(v11[9] + 88) / *(int *)(*(_QWORD *)(a2 + 72) + 24);
    if (v16 <= 1)
      v16 = 1;
    *(_QWORD *)(a2 + 88) = v16;
    *(_QWORD *)(a2 + 88) += time(0);
    sub_2096AC924(v11[9], v11[10], a2);
    return (_QWORD *)sub_2096AD708(a2, (char *)(*(_QWORD *)(v11[5] + 8) + 24), *(_QWORD *)(v11[6] + 8) + 24, (_DWORD *)(*(_QWORD *)(v11[7] + 8) + 24), a5, a6, a7, a8);
  }
  return (_QWORD *)sub_2096AD44C(v14, a2, "host timed out", a4, a5, a6, a7, a8, a9);
}

uint64_t sub_2096AD708(uint64_t result, char *a2, uint64_t a3, _DWORD *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8;
  uint64_t v11;
  int v12;
  char *v13;
  int v14;
  char v15;

  v8 = *(_DWORD *)(result + 64);
  if (v8 >= 1024)
    heim_abort("fd too large:h->fd < FD_SETSIZE", (uint64_t)a2, a3, (uint64_t)a4, a5, a6, a7, a8, v15);
  v11 = result;
  v12 = *(_DWORD *)(result + 40);
  if ((v12 - 1) >= 2)
  {
    if (v12 != 3)
      goto LABEL_10;
    result = __darwin_check_fd_set_overflow(*(_DWORD *)(result + 64), a2, 0);
    v13 = a2;
    if (!(_DWORD)result)
      goto LABEL_10;
    goto LABEL_9;
  }
  v13 = (char *)a3;
  if (__darwin_check_fd_set_overflow(*(_DWORD *)(result + 64), a2, 0))
    *(_DWORD *)&a2[((unint64_t)v8 >> 3) & 0x1FFFFFFFFFFFFFFCLL] |= 1 << v8;
  v8 = *(_DWORD *)(v11 + 64);
  result = __darwin_check_fd_set_overflow(v8, v13, 0);
  if ((_DWORD)result)
LABEL_9:
    *(_DWORD *)&v13[((unint64_t)v8 >> 3) & 0x1FFFFFFFFFFFFFFCLL] |= 1 << v8;
LABEL_10:
  v14 = *(_DWORD *)(v11 + 64);
  if (v14 > *a4)
    *a4 = v14 + 1;
  return result;
}

uint64_t sub_2096AD814(uint64_t result, uint64_t a2)
{
  uint64_t v2;

  if (!*(_DWORD *)(a2 + 40))
  {
    v2 = *(_QWORD *)(a2 + 88) - *(_QWORD *)(result + 32);
    *(_QWORD *)(a2 + 88) = v2;
    if (v2 <= *(_QWORD *)(result + 40))
      v2 = *(_QWORD *)(result + 40);
    *(_QWORD *)(a2 + 88) = v2;
  }
  return result;
}

BOOL sub_2096AD844(uint64_t a1, uint64_t a2)
{
  return *(_DWORD *)(a2 + 40) == 4;
}

void sub_2096AD854(_QWORD *a1, uint64_t a2, _DWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v9;
  const void *v12;
  int v13;
  int v14;
  char *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  uint64_t v22;
  uint64_t v23;
  char v24;
  int v25;
  uint64_t v26;
  int v27;
  int v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  char v34;
  char v35;

  if (*(_DWORD *)(a2 + 40) == 4)
    heim_abort("dead host resurected:h->state != DEAD", a2, (uint64_t)a3, a4, a5, a6, a7, a8, v34);
  v9 = *(int *)(a2 + 64);
  if ((int)v9 >= 1024)
    heim_abort("fd too large:h->fd < FD_SETSIZE", a2, (uint64_t)a3, a4, a5, a6, a7, a8, v34);
  v12 = (const void *)(*(_QWORD *)(a1[4] + 8) + 24);
  if (__darwin_check_fd_set_overflow(*(_DWORD *)(a2 + 64), v12, 0))
    v13 = *(_DWORD *)((_BYTE *)v12 + ((v9 >> 3) & 0x1FFFFFFFFFFFFFFCLL)) & (1 << v9);
  else
    v13 = 0;
  v14 = *(_DWORD *)(a2 + 64);
  v15 = (char *)(*(_QWORD *)(a1[5] + 8) + 24);
  if (__darwin_check_fd_set_overflow(v14, v15, 0))
  {
    v21 = (*(_DWORD *)&v15[((unint64_t)v14 >> 3) & 0x1FFFFFFFFFFFFFFCLL] >> v14) & 1;
    if (v13)
      goto LABEL_11;
  }
  else
  {
    v21 = 0;
    if (v13)
      goto LABEL_11;
  }
  if (!v21)
    goto LABEL_28;
LABEL_11:
  v22 = a1[7];
  v23 = a1[8];
  v24 = v21 ^ 1;
  if (*(_DWORD *)(a2 + 40) != 1)
    v24 = 1;
  if ((v24 & 1) == 0)
    sub_2096AC924(a1[7], a1[8], a2);
  if (!v13
    || (sub_2096AC8F0(v22, v16, a2, "reading packet", v17, v18, v19, v20, v34),
        v25 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(a2 + 72) + 16))(v22, a2, v23 + 120),
        v25 == -1))
  {
LABEL_20:
    if (v21)
    {
      if (*(_DWORD *)(a2 + 40) == 2)
      {
        ++*(_QWORD *)(v23 + 224);
        sub_2096AC8F0(v22, v16, a2, "writing packet", v17, v18, v19, v20, v34);
        v28 = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)(a2 + 72) + 8))(v22, a2);
        if (v28 != -1)
        {
          if (!v28)
          {
            v27 = 0;
            *(_DWORD *)(a2 + 40) = 3;
            goto LABEL_27;
          }
          sub_2096AD44C(v22, a2, "host dead, write failed", v29, v30, v31, v32, v33, v35);
        }
      }
    }
    v27 = 0;
    goto LABEL_27;
  }
  if (v25)
  {
    sub_2096AD44C(v22, a2, "host disconnected", v26, v17, v18, v19, v20, v34);
    goto LABEL_20;
  }
  sub_2096AC8F0(v22, v16, a2, "host completed", v17, v18, v19, v20, v34);
  v27 = 1;
LABEL_27:
  *(_DWORD *)(*(_QWORD *)(a1[6] + 8) + 24) |= v27;
LABEL_28:
  if (*(_DWORD *)(*(_QWORD *)(a1[6] + 8) + 24))
    *a3 = 1;
}

krb5_error_code krb5_sendauth(krb5_context a1, krb5_auth_context *a2, krb5_pointer a3, char *a4, krb5_principal a5, krb5_principal a6, krb5_flags a7, krb5_data *a8, krb5_creds *a9, krb5_ccache cache, krb5_error **a11, krb5_ap_rep_enc_part **a12, krb5_creds **a13)
{
  size_t v21;
  size_t v22;
  ssize_t v23;
  int v24;
  krb5_creds *v26;
  krb5_ccache v27;
  krb5_error_code v28;
  int v29;
  krb5_error_code credentials;
  krb5_creds **v31;
  krb5_error_code message;
  krb5_error **v33;
  _OWORD *v34;
  krb5_data v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  krb5_ap_rep_enc_part **v40;
  krb5_ap_rep_enc_part **v41;
  int v42;
  krb5_ap_rep_enc_part *v43;
  krb5_data v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  uint64_t v50;
  krb5_creds *v51;
  krb5_principal principal;
  _QWORD v53[16];
  __int128 v54;
  krb5_data v55;
  krb5_data v56;
  char v57;
  char __buf[20];

  v57 = 0;
  *(_QWORD *)&v56.magic = 0;
  v56.data = 0;
  *(_QWORD *)&v55.magic = 0;
  v55.data = 0;
  v54 = 0u;
  memset(v53, 0, sizeof(v53));
  v51 = 0;
  principal = 0;
  *(_DWORD *)__buf = 318767104;
  if (krb5_net_write((int)a1, (int *)a3, __buf, 4uLL) != 4
    || krb5_net_write((int)a1, (int *)a3, "KRB5_SENDAUTH_V1.0", 0x13uLL) != 19
    || (v21 = strlen(a4),
        v22 = v21 + 1,
        *(_DWORD *)__buf = bswap32(v21 + 1),
        krb5_net_write((int)a1, (int *)a3, __buf, 4uLL) != 4)
    || krb5_net_write((int)a1, (int *)a3, a4, v22) != v22)
  {
    v24 = *__error();
    strerror(v24);
    krb5_set_error_message(a1, v24, "write: %s");
    return v24;
  }
  v23 = krb5_net_read((int)a1, (int *)a3, &v57, 1uLL);
  if (v23 < 0)
  {
    v24 = *__error();
    strerror(v24);
    krb5_set_error_message(a1, v24, "read: %s");
    return v24;
  }
  if (v23 != 1)
  {
    v24 = -1765328178;
    goto LABEL_13;
  }
  if (v57)
  {
    krb5_clear_error_message(a1);
    return -1765328177;
  }
  v26 = a9;
  if (!a9)
  {
    v27 = cache;
    if (cache)
    {
      v42 = 0;
      if (!a5)
      {
LABEL_19:
        v28 = krb5_cc_get_principal(a1, cache, &principal);
        if (v28)
        {
          v24 = v28;
          if (v27)
            return v24;
LABEL_30:
          krb5_cc_close(a1, cache);
          return v24;
        }
        a5 = principal;
      }
    }
    else
    {
      v24 = krb5_cc_default(a1, &cache);
      if (v24)
        return v24;
      v42 = 1;
      if (!a5)
        goto LABEL_19;
    }
    v54 = 0u;
    memset(&v53[2], 0, 112);
    v53[0] = a5;
    v53[1] = a6;
    v26 = (krb5_creds *)v53;
    v29 = v42;
    goto LABEL_28;
  }
  if (a9->addresses)
  {
    v51 = a9;
    goto LABEL_33;
  }
  v29 = 0;
LABEL_28:
  credentials = krb5_get_credentials(a1, 0, cache, v26, &v51);
  if (credentials)
  {
    v24 = credentials;
    if (!v29)
      return v24;
    goto LABEL_30;
  }
  if (v29)
    krb5_cc_close(a1, cache);
LABEL_33:
  v31 = a13;
  v24 = krb5_mk_req_extended(a1, a2, a7, a8, v51, &v56);
  if (v31)
  {
    *v31 = v51;
  }
  else if (v51)
  {
    krb5_free_creds(a1, v51);
  }
  if (principal)
    krb5_free_principal(a1, principal);
  if (!v24)
  {
    message = krb5_write_message(a1, (int *)a3, (char **)&v56);
    if (message)
      goto LABEL_42;
    krb5_data_free(&v56);
    message = krb5_read_message(a1, (int *)a3, (uint64_t)&v55);
    if (message)
      goto LABEL_42;
    if (*(_QWORD *)&v55.magic)
    {
      v50 = 0;
      v48 = 0u;
      v49 = 0u;
      v46 = 0u;
      v47 = 0u;
      v44 = (krb5_data)0;
      v45 = 0u;
      v24 = krb5_rd_error(a1, &v55, (krb5_error **)&v44);
      krb5_data_free(&v55);
      if (!v24)
      {
        v33 = a11;
        v24 = krb5_error_from_rd_error(a1, (uint64_t)&v44, 0);
        if (v33 && (v34 = malloc_type_malloc(0x68uLL, 0x10B00406D2B8025uLL), (*v33 = (krb5_error *)v34) != 0))
        {
          v35 = v44;
          v36 = v46;
          v34[1] = v45;
          v34[2] = v36;
          *v34 = v35;
          v37 = v47;
          v38 = v48;
          v39 = v49;
          *((_QWORD *)v34 + 12) = v50;
          v34[4] = v38;
          v34[5] = v39;
          v34[3] = v37;
        }
        else
        {
          krb5_free_error_contents((uint64_t)a1, (uint64_t)&v44);
        }
        return v24;
      }
LABEL_13:
      krb5_clear_error_message(a1);
      return v24;
    }
    krb5_data_free(&v55);
    if ((a7 & 2) == 0)
      return 0;
    *(_QWORD *)&v44.magic = 0;
    v44.data = 0;
    v43 = 0;
    krb5_data_zero(&v44);
    message = krb5_read_message(a1, (int *)a3, (uint64_t)&v44);
    if (message)
    {
LABEL_42:
      v24 = message;
      krb5_set_error_message(a1, message, "krb5_sendauth: server closed connection");
      return v24;
    }
    v40 = a12;
    if (a12)
      v41 = a12;
    else
      v41 = &v43;
    v24 = krb5_rd_rep(a1, *a2, &v44, v41);
    krb5_data_free(&v44);
    if (!v24)
    {
      if (!v40)
        krb5_free_ap_rep_enc_part(a1, v43);
      return 0;
    }
  }
  return v24;
}

krb5_error_code krb5_set_default_realm(krb5_context a1, const char *a2)
{
  __CFArray *v4;
  __CFArray *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  char **strings;
  char **v13;
  char *v14;
  uint64_t v15;
  krb5_error_code v16;
  char **v18;

  v18 = 0;
  v4 = heim_array_create();
  v5 = v4;
  if (a2)
  {
    sub_2096AE00C((int)v4, v4, (char *)a2);
  }
  else
  {
    krb5_plugin_run_f((uint64_t)a1, "krb5", "krb5_configuration", 0, 0, (uint64_t)v4, (uint64_t)sub_2096AE054);
    strings = (char **)krb5_config_get_strings((uint64_t)a1, 0, v6, v7, v8, v9, v10, v11, (uint64_t)"libdefaults");
    v13 = strings;
    v18 = strings;
    if (strings)
      goto LABEL_4;
    if (!heim_array_get_length(v5))
    {
      LODWORD(strings) = krb5_get_host_realm(a1, 0, &v18);
      if ((_DWORD)strings)
      {
        v16 = (int)strings;
        heim_release(v5);
        return v16;
      }
      v13 = v18;
      if (v18)
      {
LABEL_4:
        v14 = *v13;
        if (*v13)
        {
          v15 = 1;
          do
          {
            sub_2096AE00C((int)strings, v5, v14);
            v13 = v18;
            v14 = v18[v15++];
          }
          while (v14);
        }
        krb5_free_host_realm(a1, v13);
      }
    }
  }
  heim_release(*((CFTypeRef *)a1 + 9));
  v16 = 0;
  *((_QWORD *)a1 + 9) = v5;
  return v16;
}

void sub_2096AE00C(int a1, __CFArray *a2, char *cStr)
{
  CFStringRef v4;
  CFStringRef v5;

  v4 = heim_string_create(cStr);
  if (v4)
  {
    v5 = v4;
    heim_array_append_value(a2, v4);
    heim_release(v5);
  }
}

uint64_t sub_2096AE054(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t (*v4)(uint64_t, uint64_t, uint64_t, void (*)(int, __CFArray *, char *));

  v4 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, void (*)(int, __CFArray *, char *)))(a2 + 24);
  if (v4)
    return v4(a1, a3, a4, sub_2096AE00C);
  else
    return 2529639161;
}

uint64_t krb5_sock_to_principal(_krb5_context *a1, int a2, const char *a3, krb5_int32 a4, krb5_principal *a5)
{
  uint64_t v9;
  uint64_t v10;
  int *v11;
  uint64_t v12;
  int *v13;
  socklen_t v15;
  char v16[1025];
  sockaddr v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  uint64_t v25;

  v25 = *MEMORY[0x24BDAC8D0];
  v23 = 0u;
  v24 = 0u;
  v21 = 0u;
  v22 = 0u;
  v19 = 0u;
  v20 = 0u;
  v17 = (sockaddr)0;
  v18 = 0u;
  v15 = 128;
  if (getsockname(a2, &v17, &v15) < 0)
  {
    v13 = __error();
    v12 = *v13;
    strerror(*v13);
    krb5_set_error_message(a1, v12, "getsockname: %s");
  }
  else
  {
    v9 = getnameinfo(&v17, v15, v16, 0x401u, 0, 0, 0);
    if ((_DWORD)v9)
    {
      v10 = v9;
      v11 = __error();
      v12 = krb5_eai_to_heim_errno(v10, *v11);
      gai_strerror(v10);
      krb5_set_error_message(a1, v12, "getnameinfo: %s");
    }
    else
    {
      return krb5_sname_to_principal(a1, v16, a3, a4, a5);
    }
  }
  return v12;
}

_QWORD *krb5_storage_emem()
{
  _QWORD *v0;
  _QWORD *v1;
  _QWORD *v2;
  void *v3;
  void *v4;

  v0 = malloc_type_malloc(0x40uLL, 0x10800405C5E1C9BuLL);
  if (v0)
  {
    v1 = malloc_type_malloc(0x20uLL, 0x101004038BDA701uLL);
    if (v1)
    {
      v2 = v1;
      *v0 = v1;
      v0[6] = 0x89F8E70500000000;
      v1[1] = 1024;
      v3 = malloc_type_malloc(0x400uLL, 0xF239CFACuLL);
      *v2 = v3;
      if (v3)
      {
        v2[2] = 0;
        v2[3] = v3;
        v0[1] = sub_2096AE2B0;
        v0[2] = sub_2096AE310;
        v0[3] = sub_2096AE3C4;
        v0[4] = sub_2096AE46C;
        v0[5] = sub_2096AE548;
        v0[7] = 0x1FFFFFFFLL;
        return v0;
      }
      free(v0);
      v4 = v2;
    }
    else
    {
      v4 = v0;
    }
    free(v4);
    return 0;
  }
  return v0;
}

size_t sub_2096AE2B0(_QWORD **a1, void *__dst, size_t a3)
{
  const void *v5;
  size_t v6;

  v5 = (const void *)(*a1)[3];
  if (**a1 + (*a1)[2] - (_QWORD)v5 >= a3)
    v6 = a3;
  else
    v6 = **a1 + (*a1)[2] - (_QWORD)v5;
  memmove(__dst, v5, v6);
  ((void (*)(_QWORD **, size_t, uint64_t))a1[3])(a1, v6, 1);
  return v6;
}

size_t sub_2096AE310(void ***a1, void *__src, size_t __len)
{
  size_t v3;
  void **v6;
  _BYTE *v7;
  char *v8;
  int64_t v9;
  size_t v10;
  char *v11;

  v3 = __len;
  v6 = *a1;
  v7 = **a1;
  v8 = (char *)v6[3];
  if ((char *)v6[1] + (_QWORD)v7 - v8 < __len)
  {
    v9 = v8 - v7;
    v10 = (v8 - v7 + __len) << (v8 - v7 + __len < 0x1000);
    v11 = (char *)malloc_type_realloc(v7, v10, 0x9195CD2BuLL);
    if (!v11)
      return -1;
    *v6 = v11;
    v6[1] = (void *)v10;
    v8 = &v11[v9];
    v6[3] = &v11[v9];
  }
  memmove(v8, __src, v3);
  ((void (*)(void ***, size_t, uint64_t))a1[3])(a1, v3, 1);
  return v3;
}

uint64_t sub_2096AE3C4(uint64_t a1, unint64_t a2, int a3)
{
  _QWORD *v3;
  uint64_t v4;
  unint64_t v5;
  void (*v6)(void);

  v3 = *(_QWORD **)a1;
  switch(a3)
  {
    case 2:
      v6 = *(void (**)(void))(a1 + 24);
LABEL_10:
      v6();
      return v3[3] - *v3;
    case 1:
      v6 = *(void (**)(void))(a1 + 24);
      goto LABEL_10;
    case 0:
      v4 = v3[1];
      if (v4 >= a2)
        v4 = a2;
      v5 = v4 & ~(v4 >> 63);
      v3[3] = *v3 + v5;
      if (v5 > v3[2])
        v3[2] = v5;
      return v3[3] - *v3;
  }
  *__error() = 22;
  return -1;
}

uint64_t sub_2096AE46C(void ***a1, size_t size)
{
  void **v3;
  size_t v4;
  _BYTE *v5;
  char *v6;
  char *v8;
  uint64_t v9;
  char *v10;
  char *v11;
  uint64_t result;

  v3 = *a1;
  if (size)
  {
    v5 = *v3;
    v4 = (size_t)v3[1];
    v6 = (char *)v3[3];
    if (v4 < size || v4 >> 1 > size)
    {
      v8 = (char *)malloc_type_realloc(*v3, size, 0x7DF3B92DuLL);
      if (!v8)
        return 12;
      v11 = v8;
      v9 = v6 - v5;
      v10 = (char *)v3[1];
      if (size > (unint64_t)v10)
        bzero(&v10[(_QWORD)v8], size - (_QWORD)v10);
      *v3 = v11;
      v3[1] = (void *)size;
      v6 = &v11[v9];
      v3[3] = &v11[v9];
    }
    else
    {
      v11 = (char *)*v3;
    }
  }
  else
  {
    free(*v3);
    v11 = 0;
    v6 = 0;
    v3[3] = 0;
    *v3 = 0;
    v3[1] = 0;
  }
  v3[2] = (void *)size;
  result = 0;
  if (v6 - v11 > (uint64_t)size)
    v3[3] = &v11[size];
  return result;
}

void sub_2096AE548(void ***a1)
{
  void **v1;

  v1 = *a1;
  bzero(**a1, (size_t)(*a1)[2]);
  free(*v1);
}

uint64_t _krb5_auth_con_setup_pfs(_krb5_context *a1, uint64_t a2, unsigned int a3)
{
  _QWORD *v6;
  krb5_keyblock *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  krb5_keyblock *v14;
  void **strings;
  void **v16;
  const char *v17;
  uint64_t v18;
  const char **v19;
  const char *v20;
  krb5_octet *v21;

  v6 = (_QWORD *)MEMORY[0x20BD11E74]();
  ccDRBGGetRngState();
  sub_20969D1E8((uint64_t)a1, 20, "Setting up PFS for auth context");
  v7 = (krb5_keyblock *)malloc_type_calloc(1uLL, 0x90uLL, 0x10B0040D51C2B2DuLL);
  if (!v7)
    return krb5_enomem(a1);
  v14 = v7;
  strings = (void **)krb5_config_get_strings((uint64_t)a1, 0, v8, v9, v10, v11, v12, v13, (uint64_t)"libdefaults");
  v16 = strings;
  if (strings)
  {
    v17 = (const char *)*strings;
    if (!*strings)
    {
      krb5_config_free_strings(strings);
      v14[5].magic = 0;
      goto LABEL_18;
    }
    v18 = 0;
    v19 = (const char **)(strings + 1);
    do
    {
      v18 = sub_2096AF7C8((uint64_t)a1, v18, v17);
      v20 = *v19++;
      v17 = v20;
    }
    while (v20);
  }
  else
  {
    LODWORD(v18) = sub_2096AF7C8((uint64_t)a1, 0, "ALL");
  }
  krb5_config_free_strings(v16);
  v14[5].magic = v18;
  if (!(_DWORD)v18)
  {
LABEL_18:
    sub_20969D1E8((uint64_t)a1, 10, "No PFS configuration");
LABEL_19:
    free(v14);
    return 0;
  }
  if (a3 > 0x17 || ((1 << a3) & 0x870000) == 0)
    goto LABEL_19;
  *(_OWORD *)&v14[4].magic = xmmword_24C1F5780;
  v14[4].contents = 0;
  v21 = (krb5_octet *)malloc_type_calloc(1uLL, (32 * *v6) | 0x10, 0x52847D2CuLL);
  v14[2].contents = v21;
  if (!v21)
  {
LABEL_15:
    free(v14);
    return krb5_enomem(a1);
  }
  if (cccurve25519_make_key_pair() || ccec_generate_key_fips())
  {
    krb5_free_keyblock_contents(a1, v14 + 3);
    free(v14[2].contents);
    goto LABEL_15;
  }
  *(_QWORD *)(a2 + 104) = v14;
  return 0;
}

void sub_2096AE778(_krb5_context *a1, uint64_t a2)
{
  uint64_t v2;
  _OWORD *v5;

  v2 = *(_QWORD *)(a2 + 104);
  if (v2)
  {
    free(*(void **)(v2 + 64));
    krb5_free_keyblock_contents(a1, (krb5_keyblock *)(*(_QWORD *)(a2 + 104) + 72));
    krb5_free_principal(a1, *(krb5_principal *)(*(_QWORD *)(a2 + 104) + 128));
    v5 = *(_OWORD **)(a2 + 104);
    v5[7] = 0u;
    v5[8] = 0u;
    v5[5] = 0u;
    v5[6] = 0u;
    v5[3] = 0u;
    v5[4] = 0u;
    v5[1] = 0u;
    v5[2] = 0u;
    *v5 = 0u;
    free(*(void **)(a2 + 104));
    *(_QWORD *)(a2 + 104) = 0;
  }
}

uint64_t sub_2096AE7F0(_krb5_context *a1, uint64_t a2, const char *a3, krb5_keyblock *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  const krb5_keyblock *v9;
  uint64_t result;
  char v14;
  krb5_keyblock v15;

  v8 = *(_QWORD *)(a2 + 104);
  memset(&v15, 0, sizeof(v15));
  if (!v8)
    heim_abort("no PFS requestd:pfs", a2, (uint64_t)a3, (uint64_t)a4, a5, a6, a7, a8, v14);
  v9 = (const krb5_keyblock *)(v8 + 72);
  if (!*(_DWORD *)(v8 + 72))
    heim_abort("shared secret completed:pfs->keyblock.keytype", a2, (uint64_t)a3, (uint64_t)a4, a5, a6, a7, a8, v14);
  if (!*(_DWORD *)(v8 + 136))
    heim_abort("no pfs group selected:pfs->group != KRB5_PFS_INVALID", a2, (uint64_t)a3, (uint64_t)a4, a5, a6, a7, a8, v14);
  sub_20969D1E8((uint64_t)a1, 10, "krb5_pfs: updating to PFS key for direction %s", a3);
  result = _krb5_fast_cf2(a1, a4, "AP PFS shared key", v9, a3, &v15, 0);
  if ((_DWORD)result != -1980176606)
  {
    if ((_DWORD)result)
      return result;
    krb5_free_keyblock_contents(a1, a4);
    *a4 = v15;
    _krb5_debug_keyblock((uint64_t)a1, 20, a3, (uint64_t)a4);
  }
  return 0;
}

uint64_t sub_2096AE8EC(_krb5_context *a1, uint64_t a2, const krb5_principal_data *a3, unsigned int *a4)
{
  uint64_t v8;
  int v9;
  uint64_t v10;
  uint64_t checksum;
  uint64_t v12;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  void *v22;
  uint64_t v23;
  uint64_t v24;
  char v25;
  uint64_t v26;
  void *v27;
  uint64_t v28;
  void *v29;
  _QWORD v30[2];
  krb5_keyblock **v31;
  uint64_t v32;
  size_t v33;
  void *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;

  v8 = *(_QWORD *)(a2 + 104);
  v31 = 0;
  v32 = 0;
  v27 = 0;
  v28 = 0;
  v26 = 0;
  v33 = 0;
  v34 = 0;
  v30[0] = 0;
  v30[1] = 0;
  v29 = 0;
  krb5_data_zero(&v26);
  if (!sub_2096AEBDC(a1, a2))
    return 0;
  v9 = *(_DWORD *)(v8 + 120);
  if ((v9 & 1) == 0)
  {
    if ((v9 & 2) == 0)
      goto LABEL_4;
LABEL_10:
    v35 = 0;
    v36 = 0;
    v37 = 0;
    v12 = sub_2096AF4C4(a1, (uint64_t)&v35);
    if ((_DWORD)v12)
      goto LABEL_11;
    checksum = sub_2096BBB80((unsigned int *)v30);
    sub_2096BBB70();
    if ((_DWORD)checksum)
      goto LABEL_12;
    goto LABEL_4;
  }
  v35 = 2;
  v36 = 0;
  v37 = 0;
  v12 = krb5_data_copy(&v36, (const void *)(v8 + 32), 0x20uLL);
  if ((_DWORD)v12)
  {
LABEL_11:
    checksum = v12;
    sub_2096BBB70();
    goto LABEL_12;
  }
  checksum = sub_2096BBB80((unsigned int *)v30);
  sub_2096BBB70();
  if ((_DWORD)checksum)
    goto LABEL_12;
  if ((*(_DWORD *)(v8 + 120) & 2) != 0)
    goto LABEL_10;
LABEL_4:
  v10 = krb5_copy_principal(a1, a3, (krb5_principal *)(v8 + 128));
  if ((_DWORD)v10)
  {
    checksum = v10;
    sub_2096AE778(a1, a2);
    sub_2096BBC4C();
    return checksum;
  }
  checksum = krb5_crypto_init(a1, *(const krb5_keyblock **)(a2 + 32), 0, &v31);
  if (!(_DWORD)checksum)
  {
    v26 = sub_2096BBC3C();
    v27 = malloc_type_malloc(v26, 0x964C2981uLL);
    if (v27)
    {
      v14 = sub_2096BBC1C();
      if ((_DWORD)v14)
      {
        checksum = v14;
        free(v27);
        v27 = 0;
        goto LABEL_12;
      }
      if (v28 != v26)
        heim_abort("internal asn1 error:size == data.length", v15, v16, v17, v18, v19, v20, v21, v25);
      v22 = malloc_type_calloc(1uLL, 0x18uLL, 0x10800404ACF7207uLL);
      v29 = v22;
      if (!v22)
      {
        v24 = krb5_enomem(a1);
        goto LABEL_30;
      }
      checksum = krb5_create_checksum(a1, (_DWORD **)v31, 0xFFFFFFE5, 0, (uint64_t)v27, v26, (uint64_t)v22);
      if ((_DWORD)checksum)
        goto LABEL_12;
      LODWORD(v32) = 513;
      v33 = sub_2096BBC3C();
      v34 = malloc_type_malloc(v33, 0x85E7BBC6uLL);
      if (v34)
      {
        v23 = sub_2096BBC1C();
        if ((_DWORD)v23)
        {
          checksum = v23;
          free(v34);
          v34 = 0;
          goto LABEL_12;
        }
        if (v33 != v28)
          krb5_abortx(a1, "internal error in ASN.1 encoder");
        v24 = sub_2096BB64C(a4);
LABEL_30:
        checksum = v24;
        goto LABEL_12;
      }
    }
    checksum = 12;
  }
LABEL_12:
  if (v31)
    krb5_crypto_destroy(a1, (uint64_t)v31);
  sub_2096BBC4C();
  sub_2096BB5C8();
  free(v27);
  return checksum;
}

BOOL sub_2096AEBDC(_krb5_context *a1, uint64_t a2)
{
  int v4;
  BOOL v6;
  uint64_t v7;

  v7 = 0;
  v4 = krb5_crypto_prf_length(a1, **(_DWORD **)(a2 + 32), &v7);
  if (v4 == -1980176606)
  {
    sub_20969D1E8((uint64_t)a1, 10, "Enctype %d doesn't support PFS", **(_DWORD **)(a2 + 32));
    return 0;
  }
  else
  {
    if (v4)
      v6 = 1;
    else
      v6 = v7 == 0;
    return !v6;
  }
}

uint64_t sub_2096AEC60(_krb5_context *a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  const krb5_keyblock *v14;
  int *v15;
  size_t v16;
  void *v17;
  void *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  const char *v27;
  uint64_t v28;
  size_t v29;
  _DWORD *v30;
  unint64_t v31;
  int v32;
  uint64_t v33;
  _QWORD *v35;
  uint64_t v36;
  const char *v37;
  krb5_cksumtype ctype[4];
  uint64_t v39;
  uint64_t v40;
  _QWORD v41[2];
  int *v42;
  uint64_t v43;
  _DWORD *v44;
  uint64_t v45;

  v41[0] = 0;
  v41[1] = 0;
  v40 = 0;
  v43 = 0;
  v44 = 0;
  v42 = 0;
  krb5_data_zero(v41);
  v11 = *(_QWORD *)(a2 + 64);
  if (!v11)
    return 0;
  v12 = *(_QWORD *)(v11 + 80);
  if (!v12)
    return v12;
  if (!*(_QWORD *)(a2 + 32))
    heim_abort("pfs: don't have keyblock:auth_context->keyblock", v4, v5, v6, v7, v8, v9, v10, ctype[0]);
  if (!sub_2096AEBDC(a1, a2) || _krb5_get_ad(a1, (unsigned int *)v12, 0, 513, v41))
    return 0;
  v12 = sub_2096BBBFC();
  krb5_data_free(v41);
  if ((_DWORD)v12)
    goto LABEL_18;
  v14 = *(const krb5_keyblock **)(a2 + 32);
  v45 = 0;
  v15 = v42;
  if (!v42)
  {
    v12 = 2314790689;
    v27 = "peer sent no checksum";
LABEL_14:
    krb5_set_error_message(a1, -1980176607, v27, *(_QWORD *)ctype);
    goto LABEL_18;
  }
  v42 = 0;
  v16 = sub_2096BBC3C();
  v17 = malloc_type_malloc(v16, 0xD3F2F2BFuLL);
  if (!v17)
  {
    v12 = 12;
    goto LABEL_17;
  }
  v18 = v17;
  *(_QWORD *)ctype = 0;
  v19 = sub_2096BBC1C();
  if ((_DWORD)v19)
  {
    v12 = v19;
    free(v18);
LABEL_17:
    v42 = v15;
    goto LABEL_18;
  }
  v42 = v15;
  if (v16 != v45)
    heim_abort("internal asn1 encode error:data.length == size", v20, v21, v22, v23, v24, v25, v26, ctype[0]);
  v28 = krb5_crypto_init(a1, v14, 0, (krb5_keyblock ***)ctype);
  if ((_DWORD)v28)
  {
    v12 = v28;
    free(v18);
    goto LABEL_18;
  }
  if (!krb5_checksum_is_keyed((uint64_t)a1, *v15))
  {
    v12 = 2314790689;
    free(v18);
    v27 = "checksum not keyed";
    goto LABEL_14;
  }
  v12 = krb5_verify_checksum(a1, ctype[0], (const krb5_checksum *)0xFFFFFFE5, v18, v16, v15, v29);
  krb5_crypto_destroy(a1, *(uint64_t *)ctype);
  free(v18);
  if ((_DWORD)v12)
    goto LABEL_18;
  v12 = _krb5_auth_con_setup_pfs(a1, a2, **(_DWORD **)(a2 + 32));
  if ((_DWORD)v12)
    goto LABEL_18;
  if (!(_DWORD)v43)
  {
LABEL_44:
    v12 = 2314790688;
    krb5_set_error_message(a1, -1980176608, "No acceptable PFS group sent", *(_QWORD *)ctype);
    goto LABEL_18;
  }
  v30 = v44;
  v31 = 1;
  do
  {
    if (*v30 == 2)
    {
      v32 = 1;
    }
    else
    {
      if (*v30 != 1)
      {
        v33 = 0;
        goto LABEL_35;
      }
      v32 = 2;
    }
    if ((*(_DWORD *)(*(_QWORD *)(a2 + 104) + 120) & v32) != 0)
      v33 = (uint64_t)v30;
    else
      v33 = 0;
LABEL_35:
    if (v33)
      break;
    v30 += 6;
  }
  while (v31++ < v43);
  if (!v33)
    goto LABEL_44;
  v35 = (_QWORD *)(*(_QWORD *)(a2 + 104) + 128);
  v36 = *(_QWORD *)(a2 + 64);
  v37 = *(const char **)(v36 + 8);
  *(_OWORD *)ctype = *(_OWORD *)(v36 + 16);
  v39 = *(_QWORD *)(v36 + 32);
  v12 = _krb5_principalname2krb5_principal((uint64_t)a1, v35, (uint64_t)ctype, v37);
  if (!(_DWORD)v12)
  {
    v12 = sub_2096AEF94(a1, a2, **(unsigned int **)(a2 + 32), v33);
    if (!(_DWORD)v12)
    {
      sub_2096BBC4C();
      sub_20969D1E8((uint64_t)a1, 10, "PFS server made selected");
      return v12;
    }
  }
LABEL_18:
  sub_2096BBC4C();
  sub_2096AE778(a1, a2);
  return v12;
}

uint64_t sub_2096AEF94(_krb5_context *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD *v15;
  uint64_t v16;
  _QWORD *v18;
  const char *v19;
  uint64_t v20;
  char v21;
  size_t v22;
  void *v23;
  uint64_t v24;

  v24 = *MEMORY[0x24BDAC8D0];
  v7 = *(_QWORD *)(a2 + 104);
  ccDRBGGetRngState();
  if (!v7)
    heim_abort("no PFS requestd:pfs", v8, v9, v10, v11, v12, v13, v14, v21);
  v22 = 0;
  v23 = 0;
  v15 = krb5_data_zero(&v22);
  if (*(_DWORD *)a4 == 1)
  {
    if ((*(_BYTE *)(v7 + 120) & 2) != 0)
    {
      v18 = (_QWORD *)MEMORY[0x20BD11E74](v15);
      MEMORY[0x24BDAC7A8]();
      if (ccec_import_pub())
      {
        v19 = "failed to import public key";
      }
      else
      {
        v20 = krb5_data_alloc(&v22, 8 * *v18);
        if ((_DWORD)v20)
        {
          v16 = v20;
          goto LABEL_22;
        }
        if (!ccec_compute_key())
        {
LABEL_20:
          v16 = _krb5_pk_kdf(a1, (__int128 *)(v7 + 96), (uint64_t)v23, v22, *(_QWORD *)(v7 + 128), 0, a3, 0, 0, 0, v7 + 72);
          if (!(_DWORD)v16)
          {
            _krb5_debug_keyblock((uint64_t)a1, 20, "PFS shared keyblock", v7 + 72);
            *(_DWORD *)(v7 + 136) = *(_DWORD *)a4;
          }
          goto LABEL_22;
        }
        v19 = "Failed to complete share key";
      }
      v16 = 2314790688;
      krb5_set_error_message(a1, -1980176608, v19);
      return v16;
    }
LABEL_10:
    v16 = 2314790688;
    krb5_set_error_message(a1, -1980176608, "Group %d not accepted", *(_DWORD *)a4);
    return v16;
  }
  if (*(_DWORD *)a4 != 2 || (*(_BYTE *)(v7 + 120) & 1) == 0)
    goto LABEL_10;
  if (*(_QWORD *)(a4 + 8) != 32)
  {
    v16 = 2314790688;
    krb5_set_error_message(a1, -1980176608, "public key of wrong length");
    return v16;
  }
  v16 = krb5_data_alloc(&v22, 0x20uLL);
  if ((_DWORD)v16)
  {
LABEL_22:
    bzero(v23, v22);
    krb5_data_free(&v22);
    return v16;
  }
  if (!cccurve25519_with_rng())
    goto LABEL_20;
  v16 = 2314790688;
  krb5_set_error_message(a1, -1980176608, "Failed to complete share key");
  return v16;
}

uint64_t sub_2096AF214(_krb5_context *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  _DWORD *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  uint64_t v21;
  uint64_t checksum;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  void *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  krb5_keyblock *v41;
  krb5_keyblock *v42;
  uint64_t v43;
  void *v44;
  krb5_keyblock **v45;

  v8 = *(_QWORD *)(a2 + 104);
  v45 = 0;
  if (!v8)
    heim_abort("no pfs:pfs", a2, a3, a4, a5, a6, a7, a8, 0);
  if (!*(_DWORD *)(v8 + 136))
    heim_abort("no pfs group selected:pfs->group != KRB5_PFS_INVALID", a2, a3, a4, a5, a6, a7, a8, 0);
  v43 = 0;
  v44 = 0;
  krb5_data_zero(&v43);
  v12 = malloc_type_calloc(1uLL, 0x20uLL, 0x10A0040E158D9E9uLL);
  *(_QWORD *)(a3 + 40) = v12;
  if (!v12)
    return krb5_enomem(a1);
  v20 = *(_DWORD *)(v8 + 136);
  if (v20 == 1)
  {
    v21 = sub_2096AF4C4(a1, (uint64_t)(v12 + 2));
  }
  else
  {
    if (v20 != 2)
      heim_abort("Invalid PFS group:0", v13, v14, v15, v16, v17, v18, v19, 0);
    v12[2] = 2;
    v21 = krb5_data_copy((_QWORD *)v12 + 2, (const void *)(v8 + 32), 0x20uLL);
  }
  checksum = v21;
  if (!(_DWORD)v21)
  {
    checksum = krb5_crypto_init(a1, *(const krb5_keyblock **)(a2 + 32), 0, &v45);
    if (!(_DWORD)checksum)
    {
      v43 = sub_2096BBC7C();
      v44 = malloc_type_malloc(v43, 0xA753E2DFuLL);
      if (v44)
      {
        v24 = sub_2096BBC5C();
        if ((_DWORD)v24)
        {
          checksum = v24;
          free(v44);
          v44 = 0;
        }
        else
        {
          if (v43)
            heim_abort("internal asn1 error:size == data.length", v25, v26, v27, v28, v29, v30, v31, 0);
          v32 = malloc_type_calloc(1uLL, 0x18uLL, 0x10800404ACF7207uLL);
          **(_QWORD **)(a3 + 40) = v32;
          if (v32)
          {
            checksum = krb5_create_checksum(a1, (_DWORD **)v45, 0xFFFFFFE3, 0, (uint64_t)v44, v43, (uint64_t)v32);
            if (!(_DWORD)checksum)
            {
              sub_20969D1E8((uint64_t)a1, 20, "PFS deriving new keys on server");
              checksum = sub_2096AE7F0(a1, a2, "session key", *(krb5_keyblock **)(a2 + 32), v33, v34, v35, v36);
              if (!(_DWORD)checksum)
              {
                v41 = *(krb5_keyblock **)(a2 + 40);
                if (!v41
                  || (checksum = sub_2096AE7F0(a1, a2, "server key", v41, v37, v38, v39, v40), !(_DWORD)checksum))
                {
                  v42 = *(krb5_keyblock **)(a2 + 48);
                  if (!v42
                    || (checksum = sub_2096AE7F0(a1, a2, "client key", v42, v37, v38, v39, v40), !(_DWORD)checksum))
                  {
                    checksum = 0;
                    *(_DWORD *)a2 |= 0x100u;
                  }
                }
              }
            }
          }
          else
          {
            checksum = krb5_enomem(a1);
          }
        }
      }
      else
      {
        checksum = 12;
      }
    }
  }
  sub_2096AE778(a1, a2);
  krb5_crypto_destroy(a1, (uint64_t)v45);
  if (v44)
    free(v44);
  if ((_DWORD)checksum && *(_QWORD *)(a3 + 40))
  {
    sub_2096BBC8C();
    free(*(void **)(a3 + 40));
    *(_QWORD *)(a3 + 40) = 0;
  }
  return checksum;
}

uint64_t sub_2096AF4C4(_krb5_context *a1, uint64_t a2)
{
  size_t v4;
  void *v5;

  *(_DWORD *)a2 = 1;
  v4 = ((unint64_t)(cczp_bitlen() + 7) >> 2) | 1;
  *(_QWORD *)(a2 + 8) = v4;
  v5 = malloc_type_malloc(v4, 0xCAF25E8EuLL);
  *(_QWORD *)(a2 + 16) = v5;
  if (!v5)
    return krb5_enomem(a1);
  ccec_export_pub();
  return 0;
}

uint64_t sub_2096AF548(krb5_context a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int **v9;
  const krb5_keyblock *v12;
  int *v13;
  size_t v14;
  void *v15;
  void *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v27;
  size_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  krb5_keyblock *v39;
  char v40;
  krb5_cksumtype ctype[2];

  if (!*(_QWORD *)(a2 + 104))
    heim_abort("no pfs:auth_context->pfs", a2, a3, a4, a5, a6, a7, a8, v40);
  v9 = *(int ***)(a3 + 40);
  if (!v9)
    heim_abort("no pfs from server:ap_rep->pfs", a2, a3, a4, a5, a6, a7, a8, v40);
  v12 = *(const krb5_keyblock **)(a2 + 32);
  v13 = *v9;
  if (!*v9)
  {
    v25 = 2314790689;
    krb5_set_error_message(a1, -1980176607, "peer sent no checksum", 0);
LABEL_10:
    sub_2096AE778(a1, a2);
    return v25;
  }
  *v9 = 0;
  v14 = sub_2096BBC7C();
  v15 = malloc_type_malloc(v14, 0x41B42D71uLL);
  if (!v15)
  {
    v25 = 12;
    goto LABEL_9;
  }
  v16 = v15;
  *(_QWORD *)ctype = 0;
  v17 = sub_2096BBC5C();
  if ((_DWORD)v17)
  {
    v25 = v17;
    free(v16);
LABEL_9:
    *v9 = v13;
    goto LABEL_10;
  }
  *v9 = v13;
  if (v14)
    heim_abort("internal asn1 encode error:data.length == size", v18, v19, v20, v21, v22, v23, v24, 0);
  v27 = krb5_crypto_init(a1, v12, 0, (krb5_keyblock ***)ctype);
  if ((_DWORD)v27)
  {
    v25 = v27;
    free(v16);
    goto LABEL_10;
  }
  if (!krb5_checksum_is_keyed((uint64_t)a1, *v13))
  {
    v25 = 2314790689;
    free(v16);
    krb5_set_error_message(a1, -1980176607, "checksum not keyed", 0);
    goto LABEL_10;
  }
  v25 = krb5_verify_checksum(a1, ctype[0], (const krb5_checksum *)0xFFFFFFE3, v16, v14, v13, v28);
  krb5_crypto_destroy(a1, *(uint64_t *)ctype);
  free(v16);
  if ((_DWORD)v25)
    goto LABEL_10;
  v25 = sub_2096AEF94(a1, a2, **(unsigned int **)(a2 + 32), *(_QWORD *)(a3 + 40) + 8);
  if ((_DWORD)v25)
    goto LABEL_10;
  sub_20969D1E8((uint64_t)a1, 10, "PFS client made secret");
  sub_20969D1E8((uint64_t)a1, 20, "PFS deriving new keys on client");
  v25 = sub_2096AE7F0(a1, a2, "session key", *(krb5_keyblock **)(a2 + 32), v29, v30, v31, v32);
  if ((_DWORD)v25)
    goto LABEL_10;
  v39 = *(krb5_keyblock **)(a2 + 40);
  if (v39)
  {
    v25 = sub_2096AE7F0(a1, a2, "client key", v39, v35, v36, v37, v38);
    if ((_DWORD)v25)
      goto LABEL_10;
  }
  if (!*(_DWORD *)(*(_QWORD *)(a2 + 104) + 136))
    heim_abort("no pfs group selected:auth_context->pfs->group != KRB5_PFS_INVALID", v33, v34, (uint64_t)v39, v35, v36, v37, v38, 0);
  v25 = 0;
  *(_DWORD *)a2 |= 0x100u;
  return v25;
}

uint64_t sub_2096AF7C8(uint64_t a1, uint64_t a2, const char *a3)
{
  int v5;
  const char *v6;
  int v7;
  unsigned int v8;
  unsigned int v9;

  v5 = *(unsigned __int8 *)a3;
  if (v5 == 45)
    v6 = a3 + 1;
  else
    v6 = a3;
  if (!strcasecmp(v6, "ALL"))
  {
    v7 = 3;
  }
  else if (!strcasecmp(v6, "dh25519"))
  {
    v7 = 1;
  }
  else
  {
    if (strcasecmp(v6, "nist-p256") && strcasecmp(v6, "p256") && strcasecmp(v6, "all-nist"))
    {
      sub_20969D1E8(a1, 10, "unsupported dh curve(s): %s", v6);
      return a2;
    }
    v7 = 2;
  }
  v8 = a2 & ~v7;
  v9 = v7 | a2;
  if (v5 == 45)
    return v8;
  else
    return v9;
}

_QWORD *krb5_storage_from_fd(int a1)
{
  int v1;
  int v2;
  _QWORD *v3;
  _DWORD *v4;

  v1 = dup(a1);
  if (v1 < 0)
    return 0;
  v2 = v1;
  v3 = malloc_type_malloc(0x40uLL, 0x10800405C5E1C9BuLL);
  if (!v3)
  {
    close(v2);
    return v3;
  }
  v4 = malloc_type_malloc(4uLL, 0x100004052888210uLL);
  *v3 = v4;
  if (!v4)
  {
    close(v2);
    free(v3);
    return 0;
  }
  v3[6] = 0x89F8E70500000000;
  *v4 = v2;
  v3[1] = sub_2096AF988;
  v3[2] = sub_2096AF994;
  v3[3] = sub_2096AF9A0;
  v3[4] = sub_2096AF9AC;
  v3[5] = sub_2096AF9E0;
  v3[7] = 0x1FFFFFFFLL;
  return v3;
}

ssize_t sub_2096AF988(int **a1, char *a2, size_t a3)
{
  return sub_2096B82F4(**a1, a2, a3);
}

size_t sub_2096AF994(int **a1, char *a2, size_t a3)
{
  return sub_2096B8374(**a1, a2, a3);
}

off_t sub_2096AF9A0(int **a1, off_t a2, int a3)
{
  return lseek(**a1, a2, a3);
}

uint64_t sub_2096AF9AC(int **a1, off_t a2)
{
  if (ftruncate(**a1, a2) == -1)
    return *__error();
  else
    return 0;
}

uint64_t sub_2096AF9E0(int **a1)
{
  return close(**a1);
}

_QWORD *krb5_storage_from_mem(uint64_t a1, uint64_t a2)
{
  _QWORD *v4;
  _QWORD *v5;

  v4 = malloc_type_malloc(0x40uLL, 0x10800405C5E1C9BuLL);
  if (v4)
  {
    v5 = malloc_type_malloc(0x18uLL, 0x10100406AB5462FuLL);
    if (v5)
    {
      v4[6] = 0x89F8E70500000000;
      *v5 = a1;
      v5[1] = a2;
      v5[2] = a1;
      *v4 = v5;
      v4[1] = sub_2096AFAAC;
      v4[2] = sub_2096AFB0C;
      v4[3] = sub_2096AFB64;
      v4[4] = sub_2096AFBE8;
      v4[5] = 0;
      v4[7] = 0x1FFFFFFFLL;
    }
    else
    {
      free(v4);
      return 0;
    }
  }
  return v4;
}

size_t sub_2096AFAAC(_QWORD **a1, void *__dst, size_t a3)
{
  const void *v5;
  size_t v6;

  v5 = (const void *)(*a1)[2];
  if (**a1 + (*a1)[1] - (_QWORD)v5 >= a3)
    v6 = a3;
  else
    v6 = **a1 + (*a1)[1] - (_QWORD)v5;
  memmove(__dst, v5, v6);
  ((void (*)(_QWORD **, size_t, uint64_t))a1[3])(a1, v6, 1);
  return v6;
}

size_t sub_2096AFB0C(_QWORD **a1, const void *a2, size_t a3)
{
  uint64_t v4;
  void *v5;
  size_t v6;

  v4 = **a1 + (*a1)[1];
  v5 = (void *)(*a1)[2];
  if (v4 - (uint64_t)v5 >= a3)
    v6 = a3;
  else
    v6 = v4 - (_QWORD)v5;
  memmove(v5, a2, v6);
  ((void (*)(_QWORD **, size_t, uint64_t))a1[3])(a1, v6, 1);
  return v6;
}

uint64_t sub_2096AFB64(uint64_t a1, unint64_t a2, int a3)
{
  _QWORD *v3;
  uint64_t v4;
  uint64_t result;
  uint64_t (*v6)(void);

  v3 = *(_QWORD **)a1;
  if (a3 == 2)
  {
    v6 = *(uint64_t (**)(void))(a1 + 24);
    return v6();
  }
  if (a3 == 1)
  {
    v6 = *(uint64_t (**)(void))(a1 + 24);
    return v6();
  }
  if (a3)
  {
    *__error() = 22;
    return -1;
  }
  else
  {
    v4 = v3[1];
    if (v4 >= a2)
      v4 = a2;
    result = v4 & ~(v4 >> 63);
    v3[2] = *v3 + result;
  }
  return result;
}

uint64_t sub_2096AFBE8(uint64_t a1, unint64_t a2)
{
  _QWORD *v2;
  uint64_t result;

  v2 = *(_QWORD **)a1;
  if (*(_QWORD *)(*(_QWORD *)a1 + 8) < a2)
    return 34;
  v2[1] = a2;
  result = 0;
  if (v2[2] - *v2 > (int64_t)a2)
    v2[2] = *v2 + a2;
  return result;
}

_QWORD *krb5_storage_from_data(uint64_t *a1)
{
  return krb5_storage_from_mem(a1[1], *a1);
}

_QWORD *krb5_storage_from_readonly_mem(uint64_t a1, uint64_t a2)
{
  _QWORD *v4;
  _QWORD *v5;

  v4 = malloc_type_malloc(0x40uLL, 0x10800405C5E1C9BuLL);
  if (v4)
  {
    v5 = malloc_type_malloc(0x18uLL, 0x10100406AB5462FuLL);
    if (v5)
    {
      v4[6] = 0x89F8E70500000000;
      *v5 = a1;
      v5[1] = a2;
      v5[2] = a1;
      *v4 = v5;
      v4[1] = sub_2096AFAAC;
      v4[2] = sub_2096AFCFC;
      v4[3] = sub_2096AFB64;
      v4[4] = sub_2096AFD04;
      v4[5] = 0;
      v4[7] = 0x1FFFFFFFLL;
    }
    else
    {
      free(v4);
      return 0;
    }
  }
  return v4;
}

uint64_t sub_2096AFCFC()
{
  return -1;
}

uint64_t sub_2096AFD04()
{
  return 22;
}

_QWORD *krb5_storage_from_mem_copy(const void *a1, size_t a2)
{
  _QWORD *v4;
  uint64_t *v5;
  uint64_t *v6;
  void *v7;
  uint64_t v8;
  uint64_t *v9;

  v4 = malloc_type_malloc(0x40uLL, 0x10800405C5E1C9BuLL);
  if (v4)
  {
    v5 = (uint64_t *)malloc_type_malloc(0x18uLL, 0x10100406AB5462FuLL);
    if (v5)
    {
      v6 = v5;
      *v4 = v5;
      v4[6] = 0x89F8E70500000000;
      v7 = malloc_type_malloc(a2, 0x21F6CBB3uLL);
      *v6 = (uint64_t)v7;
      if (v7)
      {
        memcpy(v7, a1, a2);
        v8 = *v6;
        v6[1] = a2;
        v6[2] = v8;
        v4[1] = sub_2096AFAAC;
        v4[2] = sub_2096AFB0C;
        v4[3] = sub_2096AFB64;
        v4[4] = sub_2096AFBE8;
        v4[5] = sub_2096AFE08;
        return v4;
      }
      free(v4);
      v9 = v6;
    }
    else
    {
      v9 = v4;
    }
    free(v9);
    return 0;
  }
  return v4;
}

void sub_2096AFE08(void ***a1)
{
  void **v1;

  v1 = *a1;
  bzero(**a1, (size_t)(*a1)[1]);
  free(*v1);
}

uint64_t krb5_storage_set_flags(uint64_t result, int a2)
{
  *(_DWORD *)(result + 48) |= a2;
  return result;
}

uint64_t krb5_storage_clear_flags(uint64_t result, int a2)
{
  *(_DWORD *)(result + 48) &= ~a2;
  return result;
}

BOOL krb5_storage_is_flags(uint64_t a1, int a2)
{
  return (a2 & ~*(_DWORD *)(a1 + 48)) == 0;
}

uint64_t krb5_storage_set_byteorder(uint64_t result, int a2)
{
  *(_DWORD *)(result + 48) = *(_DWORD *)(result + 48) & 0xFFFFFF9F | a2;
  return result;
}

uint64_t krb5_storage_get_byteorder(uint64_t a1)
{
  return *(_DWORD *)(a1 + 48) & 0x60;
}

uint64_t krb5_storage_seek(uint64_t a1)
{
  return (*(uint64_t (**)(void))(a1 + 24))();
}

uint64_t krb5_storage_truncate(uint64_t a1)
{
  return (*(uint64_t (**)(void))(a1 + 32))();
}

uint64_t krb5_storage_read(uint64_t a1)
{
  return (*(uint64_t (**)(void))(a1 + 8))();
}

uint64_t krb5_storage_write(uint64_t a1)
{
  return (*(uint64_t (**)(void))(a1 + 16))();
}

uint64_t krb5_storage_set_eof_code(uint64_t result, int a2)
{
  *(_DWORD *)(result + 52) = a2;
  return result;
}

uint64_t krb5_storage_get_eof_code(uint64_t a1)
{
  return *(unsigned int *)(a1 + 52);
}

uint64_t krb5_storage_free(uint64_t a1)
{
  void (*v2)(uint64_t);

  v2 = *(void (**)(uint64_t))(a1 + 40);
  if (v2)
    v2(a1);
  free(*(void **)a1);
  free((void *)a1);
  return 0;
}

uint64_t krb5_storage_to_data(uint64_t a1, size_t *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int64_t v7;
  int64_t v8;
  int64_t v9;

  v4 = 2314790665;
  v5 = (*(uint64_t (**)(uint64_t, _QWORD, uint64_t))(a1 + 24))(a1, 0, 1);
  if (v5 < 0)
    return 2314790664;
  v6 = v5;
  v7 = (*(uint64_t (**)(uint64_t, _QWORD, uint64_t))(a1 + 24))(a1, 0, 2);
  if (v7 <= 102400)
  {
    v8 = v7;
    v9 = *(_QWORD *)(a1 + 56);
    if (!v9 || v9 >= v7)
    {
      v4 = krb5_data_alloc(a2, v7);
      if (!(_DWORD)v4)
      {
        if (!v8)
          return 0;
        (*(void (**)(uint64_t, _QWORD, _QWORD))(a1 + 24))(a1, 0, 0);
        (*(void (**)(uint64_t, size_t, size_t))(a1 + 8))(a1, a2[1], *a2);
        v4 = 0;
      }
      (*(void (**)(uint64_t, uint64_t, _QWORD))(a1 + 24))(a1, v6, 0);
    }
  }
  return v4;
}

uint64_t krb5_store_int32(uint64_t a1, unsigned int a2)
{
  if ((*(_DWORD *)(a1 + 48) & 0x60) != 0x40 && (*(_DWORD *)(a1 + 48) & 1) == 0)
  {
    if ((*(_DWORD *)(a1 + 48) & 0x60) == 0x20)
      a2 = sub_2096B9AD0(a2);
  }
  else
  {
    a2 = bswap32(a2);
  }
  return sub_2096B0030(a1, a2, 4);
}

uint64_t sub_2096B0030(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v5;
  int *v7;
  _BYTE v8[16];
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  _krb5_put_int((uint64_t)v8, a2, a3);
  v5 = (*(uint64_t (**)(uint64_t, _BYTE *, uint64_t))(a1 + 16))(a1, v8, a3);
  if (v5 < 0)
  {
    v7 = __error();
  }
  else
  {
    if (v5 == a3)
      return 0;
    v7 = (int *)(a1 + 52);
  }
  return *v7;
}

uint64_t krb5_ret_int32(uint64_t a1, unsigned int *a2)
{
  uint64_t v4;
  unsigned int v6;

  v4 = sub_2096B0140(a1, a2, 4);
  if (!(_DWORD)v4)
  {
    if ((*(_DWORD *)(a1 + 48) & 0x60) == 0x40 || (*(_DWORD *)(a1 + 48) & 1) != 0)
    {
      v6 = bswap32(*a2);
LABEL_9:
      *a2 = v6;
      return v4;
    }
    if ((*(_DWORD *)(a1 + 48) & 0x60) == 0x20)
    {
      v6 = sub_2096B9AD0(*a2);
      goto LABEL_9;
    }
  }
  return v4;
}

uint64_t sub_2096B0140(uint64_t a1, _DWORD *a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t result;
  unint64_t v8;
  unsigned __int8 v9[4];

  v8 = 0;
  v6 = (*(uint64_t (**)(uint64_t, unsigned __int8 *))(a1 + 8))(a1, v9);
  if (v6 < 0)
    return *__error();
  if (v6 != a3)
    return *(unsigned int *)(a1 + 52);
  _krb5_get_int(v9, &v8, a3);
  result = 0;
  *a2 = v8;
  return result;
}

uint64_t krb5_ret_uint32(uint64_t a1, _DWORD *a2)
{
  uint64_t result;
  unsigned int v4;

  v4 = 0;
  result = krb5_ret_int32(a1, &v4);
  if (!(_DWORD)result)
    *a2 = v4;
  return result;
}

uint64_t krb5_store_int16(uint64_t a1, unsigned int a2)
{
  if ((*(_DWORD *)(a1 + 48) & 0x60) != 0x40 && (*(_DWORD *)(a1 + 48) & 1) == 0)
  {
    if ((*(_DWORD *)(a1 + 48) & 0x60) == 0x20)
      LOWORD(a2) = sub_2096B9AD8((unsigned __int16)a2);
  }
  else
  {
    a2 = bswap32(a2) >> 16;
  }
  return sub_2096B0030(a1, (__int16)a2, 2);
}

uint64_t krb5_store_uint16(uint64_t a1, __int16 a2)
{
  return krb5_store_int16(a1, a2);
}

uint64_t krb5_ret_int16(uint64_t a1, _WORD *a2)
{
  uint64_t v4;
  unsigned int v5;
  unsigned int v7;
  unsigned int v9;

  v9 = 0;
  v4 = sub_2096B0140(a1, &v9, 2);
  if (!(_DWORD)v4)
  {
    v5 = v9;
    *a2 = v9;
    if ((*(_DWORD *)(a1 + 48) & 0x60) == 0x40 || (*(_DWORD *)(a1 + 48) & 1) != 0)
    {
      v7 = bswap32(v5) >> 16;
LABEL_9:
      *a2 = v7;
      return v4;
    }
    if ((*(_DWORD *)(a1 + 48) & 0x60) == 0x20)
    {
      LOWORD(v7) = sub_2096B9AD8((unsigned __int16)v5);
      goto LABEL_9;
    }
  }
  return v4;
}

uint64_t krb5_ret_uint16(uint64_t a1, _WORD *a2)
{
  uint64_t result;
  __int16 v4;

  v4 = 0;
  result = krb5_ret_int16(a1, &v4);
  if (!(_DWORD)result)
    *a2 = v4;
  return result;
}

uint64_t krb5_store_int8(uint64_t a1, char a2)
{
  uint64_t v3;
  int *v5;
  char v6;

  v6 = a2;
  v3 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(a1 + 16))(a1, &v6, 1);
  if (v3 == 1)
    return 0;
  if (v3 < 0)
    v5 = __error();
  else
    v5 = (int *)(a1 + 52);
  return *v5;
}

uint64_t krb5_store_uint8(uint64_t a1, char a2)
{
  return krb5_store_int8(a1, a2);
}

uint64_t krb5_ret_int8(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  int *v5;

  v3 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1 + 8))(a1, a2, 1);
  if (v3 == 1)
    return 0;
  if (v3 < 0)
    v5 = __error();
  else
    v5 = (int *)(a1 + 52);
  return *v5;
}

uint64_t krb5_ret_uint8(uint64_t a1, _BYTE *a2)
{
  uint64_t v4;
  int *v5;
  uint64_t result;
  char v7;

  v7 = 0;
  v4 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(a1 + 8))(a1, &v7, 1);
  if (v4 == 1 || (v4 < 0 ? (v5 = __error()) : (v5 = (int *)(a1 + 52)), result = *v5, !(_DWORD)result))
  {
    result = 0;
    *a2 = v7;
  }
  return result;
}

uint64_t krb5_store_data(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v9;
  int *v10;

  result = 2314790665;
  if (a2 <= 102400)
  {
    v6 = *(_QWORD *)(a1 + 56);
    if (!v6 || v6 >= a2)
    {
      result = krb5_store_int32(a1, a2);
      if ((result & 0x80000000) == 0)
      {
        v9 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1 + 16))(a1, a3, a2);
        if (v9 < 0)
        {
          v10 = __error();
        }
        else
        {
          if (v9 == a2)
            return 0;
          v10 = (int *)(a1 + 52);
        }
        return *v10;
      }
    }
  }
  return result;
}

uint64_t krb5_ret_data(uint64_t a1, size_t *a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int *v8;
  int v9;

  v9 = 0;
  result = krb5_ret_int32(a1, (unsigned int *)&v9);
  if (!(_DWORD)result)
  {
    result = 2314790665;
    v5 = v9;
    if (v9 <= 102400)
    {
      v6 = *(_QWORD *)(a1 + 56);
      if (!v6 || v6 >= v9)
      {
        result = krb5_data_alloc(a2, v9);
        if (!(_DWORD)result)
        {
          if ((_DWORD)v5
            && (v7 = (*(uint64_t (**)(uint64_t, size_t, uint64_t))(a1 + 8))(a1, a2[1], v5), v7 != v5))
          {
            if (v7 < 0)
              v8 = __error();
            else
              v8 = (int *)(a1 + 52);
            return *v8;
          }
          else
          {
            return 0;
          }
        }
      }
    }
  }
  return result;
}

uint64_t krb5_store_string(uint64_t a1, char *__s)
{
  int64_t v4;
  int64_t v5;
  _QWORD v8[2];

  v4 = strlen(__s);
  v8[0] = v4;
  v8[1] = __s;
  if (v4 <= 2048)
  {
    v5 = *(_QWORD *)(a1 + 56);
    if (!v5 || v5 >= v4)
      return krb5_store_data(a1, v4, (uint64_t)__s);
  }
  krb5_data_free(v8);
  return 2314790665;
}

uint64_t krb5_ret_string(uint64_t a1, _QWORD *a2)
{
  uint64_t result;
  int64_t v5;
  _BYTE *v6;
  _BYTE *v7;
  uint64_t v8;
  void *ptr;

  v8 = 0;
  ptr = 0;
  result = krb5_ret_data(a1, (size_t *)&v8);
  if (!(_DWORD)result)
  {
    if (v8 > 2048 || (v5 = *(_QWORD *)(a1 + 56)) != 0 && v5 < v8)
    {
      krb5_data_free(&v8);
      return 2314790665;
    }
    else
    {
      v6 = malloc_type_realloc(ptr, v8 + 1, 0x81D058A7uLL);
      *a2 = v6;
      if (v6)
      {
        v7 = v6;
        result = 0;
        v7[v8] = 0;
      }
      else
      {
        free(ptr);
        return 12;
      }
    }
  }
  return result;
}

uint64_t krb5_store_stringz(uint64_t a1, char *__s)
{
  uint64_t v4;
  int64_t v5;
  int64_t v6;
  uint64_t v8;

  v4 = 2314790665;
  v5 = strlen(__s) + 1;
  if (v5 <= 2048)
  {
    v6 = *(_QWORD *)(a1 + 56);
    if (!v6 || v6 >= v5)
    {
      v8 = (*(uint64_t (**)(uint64_t, char *, int64_t))(a1 + 16))(a1, __s, v5);
      if (v8 < 0 || v8 != v5)
        return *(unsigned int *)(a1 + 52);
      else
        return 0;
    }
  }
  return v4;
}

uint64_t krb5_ret_stringz(uint64_t a1, _QWORD *a2)
{
  void *v4;
  uint64_t v5;
  uint64_t v6;
  _BYTE *v7;
  _BYTE *v8;
  uint64_t result;
  char v10;

  v4 = 0;
  v5 = 0;
  v10 = 0;
  while (1)
  {
    if ((*(uint64_t (**)(uint64_t, char *, uint64_t))(a1 + 8))(a1, &v10, 1) != 1)
    {
      free(v4);
      return *(unsigned int *)(a1 + 52);
    }
    if (v5 == 2048 || (v6 = *(_QWORD *)(a1 + 56)) != 0 && v6 <= v5)
    {
      free(v4);
      return 2314790665;
    }
    v7 = malloc_type_realloc(v4, v5 + 1, 0xAB045BA3uLL);
    if (!v7)
      break;
    v8 = v7;
    v7[v5++] = v10;
    v4 = v7;
    if (!v10)
    {
      result = 0;
      *a2 = v8;
      return result;
    }
  }
  free(v4);
  return 12;
}

uint64_t krb5_store_stringnl(uint64_t a1, char *__s)
{
  size_t v4;
  uint64_t v5;

  v4 = strlen(__s);
  v5 = (*(uint64_t (**)(uint64_t, char *, size_t))(a1 + 16))(a1, __s, v4);
  if ((v5 & 0x8000000000000000) == 0
    && v5 == v4
    && (*(uint64_t (**)(uint64_t, const char *, uint64_t))(a1 + 16))(a1, "\n", 1) == 1)
  {
    return 0;
  }
  else
  {
    return *(unsigned int *)(a1 + 52);
  }
}

uint64_t krb5_ret_stringnl(uint64_t a1, _QWORD *a2)
{
  uint64_t v4;
  void *v5;
  int v6;
  uint64_t v7;
  _BYTE *v8;
  _BYTE *v9;
  uint64_t result;
  char v11;

  v11 = 0;
  if ((*(uint64_t (**)(uint64_t, char *, uint64_t))(a1 + 8))(a1, &v11, 1) == 1)
  {
    v4 = 0;
    v5 = 0;
    v6 = 0;
    while (1)
    {
      if (v11 == 13)
      {
        v6 = 1;
      }
      else
      {
        if (v6 && v11 != 10)
        {
          free(v5);
          return 2529639050;
        }
        if (v4 + 1 > 2048 || (v7 = *(_QWORD *)(a1 + 56)) != 0 && v7 < v4 + 1)
        {
          free(v5);
          return 2314790665;
        }
        v8 = malloc_type_realloc(v5, v4 + 1, 0xC251BC83uLL);
        if (!v8)
        {
          free(v5);
          return 12;
        }
        v9 = v8;
        if (v11 == 10)
        {
          result = 0;
          v9[v4] = 0;
          *a2 = v9;
          return result;
        }
        v8[v4] = v11;
        v5 = v8;
        ++v4;
      }
      if ((*(uint64_t (**)(uint64_t, char *, uint64_t))(a1 + 8))(a1, &v11, 1) != 1)
        goto LABEL_16;
    }
  }
  v5 = 0;
LABEL_16:
  free(v5);
  return *(unsigned int *)(a1 + 52);
}

uint64_t krb5_store_principal(uint64_t a1, uint64_t a2)
{
  unsigned int v4;
  uint64_t result;
  unint64_t v6;

  v4 = *(_DWORD *)(a1 + 48);
  if ((v4 & 4) == 0)
  {
    result = krb5_store_int32(a1, *(_DWORD *)a2);
    if ((_DWORD)result)
      return result;
    v4 = *(_DWORD *)(a1 + 48);
  }
  result = krb5_store_int32(a1, *(_DWORD *)(a2 + 8) + ((v4 >> 1) & 1));
  if (!(_DWORD)result)
  {
    result = krb5_store_string(a1, *(char **)(a2 + 24));
    if (!(_DWORD)result)
    {
      if (*(_DWORD *)(a2 + 8))
      {
        v6 = 0;
        do
        {
          result = krb5_store_string(a1, *(char **)(*(_QWORD *)(a2 + 16) + 8 * v6));
          if ((_DWORD)result)
            break;
          ++v6;
        }
        while (v6 < *(unsigned int *)(a2 + 8));
      }
      else
      {
        return 0;
      }
    }
  }
  return result;
}

uint64_t krb5_ret_principal(uint64_t a1, _QWORD *a2)
{
  _DWORD *v4;
  _DWORD *v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  size_t v9;
  unint64_t v10;
  void *v11;
  uint64_t v13;
  uint64_t v14;
  unsigned int v16;
  unsigned int v17;

  v4 = malloc_type_calloc(1uLL, 0x20uLL, 0x10900408A8AD7E9uLL);
  if (!v4)
    return 12;
  v5 = v4;
  v17 = 0;
  if ((*(_BYTE *)(a1 + 48) & 4) != 0)
  {
    v17 = 0;
  }
  else
  {
    v6 = krb5_ret_int32(a1, &v17);
    if ((_DWORD)v6)
    {
LABEL_7:
      v7 = v6;
      goto LABEL_8;
    }
  }
  v16 = 0;
  v6 = krb5_ret_int32(a1, &v16);
  if ((_DWORD)v6)
    goto LABEL_7;
  v8 = *(_DWORD *)(a1 + 48) << 30;
  v9 = v16 + (v8 >> 31);
  if ((int)(v16 + (v8 >> 31)) < 0)
  {
    free(v5);
    return 22;
  }
  v10 = *(_QWORD *)(a1 + 56);
  if (v10 && v10 >> 3 < v9)
  {
    free(v5);
    return 2314790665;
  }
  *v5 = v17;
  v5[2] = v9;
  v6 = krb5_ret_string(a1, (_QWORD *)v5 + 3);
  if ((_DWORD)v6)
    goto LABEL_7;
  v11 = malloc_type_calloc(v9, 8uLL, 0x10040436913F5uLL);
  *((_QWORD *)v5 + 2) = v11;
  if ((_DWORD)v9 && !v11)
  {
    free(*((void **)v5 + 3));
    free(v5);
    return 12;
  }
  if (!(_DWORD)v9)
  {
LABEL_24:
    v7 = 0;
    *a2 = v5;
    return v7;
  }
  v13 = 0;
  while (1)
  {
    v14 = krb5_ret_string(a1, (_QWORD *)(*((_QWORD *)v5 + 2) + 8 * v13));
    if ((_DWORD)v14)
      break;
    if (++v13 == v9)
      goto LABEL_24;
  }
  v7 = v14;
  do
    free(*(void **)(*((_QWORD *)v5 + 2) + 8 * v13));
  while (v13-- > 0);
  free(*((void **)v5 + 3));
LABEL_8:
  free(v5);
  return v7;
}

uint64_t krb5_store_keyblock(uint64_t a1, __int16 *a2)
{
  uint64_t result;

  result = krb5_store_int16(a1, *a2);
  if (!(_DWORD)result)
  {
    if ((*(_BYTE *)(a1 + 48) & 8) == 0)
      return krb5_store_data(a1, *((_QWORD *)a2 + 1), *((_QWORD *)a2 + 2));
    result = krb5_store_int16(a1, *a2);
    if (!(_DWORD)result)
      return krb5_store_data(a1, *((_QWORD *)a2 + 1), *((_QWORD *)a2 + 2));
  }
  return result;
}

uint64_t krb5_ret_keyblock(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  __int16 v5;

  v5 = 0;
  result = krb5_ret_int16(a1, &v5);
  if (!(_DWORD)result)
  {
    *(_DWORD *)a2 = v5;
    if ((*(_BYTE *)(a1 + 48) & 8) == 0)
      return krb5_ret_data(a1, (size_t *)(a2 + 8));
    result = krb5_ret_int16(a1, &v5);
    if (!(_DWORD)result)
      return krb5_ret_data(a1, (size_t *)(a2 + 8));
  }
  return result;
}

uint64_t krb5_store_times(uint64_t a1, unsigned int *a2)
{
  uint64_t result;

  result = krb5_store_int32(a1, *a2);
  if (!(_DWORD)result)
  {
    result = krb5_store_int32(a1, a2[2]);
    if (!(_DWORD)result)
    {
      result = krb5_store_int32(a1, a2[4]);
      if (!(_DWORD)result)
        return krb5_store_int32(a1, a2[6]);
    }
  }
  return result;
}

uint64_t krb5_ret_times(uint64_t a1, _QWORD *a2)
{
  uint64_t result;
  int v5;

  v5 = 0;
  result = krb5_ret_int32(a1, (unsigned int *)&v5);
  *a2 = v5;
  if (!(_DWORD)result)
  {
    result = krb5_ret_int32(a1, (unsigned int *)&v5);
    a2[1] = v5;
    if (!(_DWORD)result)
    {
      result = krb5_ret_int32(a1, (unsigned int *)&v5);
      a2[2] = v5;
      if (!(_DWORD)result)
      {
        result = krb5_ret_int32(a1, (unsigned int *)&v5);
        a2[3] = v5;
      }
    }
  }
  return result;
}

uint64_t krb5_store_address(uint64_t a1, __int16 *a2)
{
  uint64_t result;

  result = krb5_store_int16(a1, *a2);
  if (!(_DWORD)result)
    return krb5_store_data(a1, *((_QWORD *)a2 + 1), *((_QWORD *)a2 + 2));
  return result;
}

uint64_t krb5_ret_address(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  __int16 v5;

  v5 = 0;
  result = krb5_ret_int16(a1, &v5);
  if (!(_DWORD)result)
  {
    *(_DWORD *)a2 = v5;
    return krb5_ret_data(a1, (size_t *)(a2 + 8));
  }
  return result;
}

uint64_t krb5_store_addrs(uint64_t a1, unsigned int a2, __int128 *a3)
{
  uint64_t v4;
  uint64_t result;
  __int128 v7;
  uint64_t v8;

  LODWORD(v4) = a2;
  result = krb5_store_int32(a1, a2);
  if (!(_DWORD)result)
  {
    v4 = v4;
    if ((_DWORD)v4)
    {
      while (1)
      {
        v7 = *a3;
        v8 = *((_QWORD *)a3 + 2);
        result = krb5_store_address(a1, (__int16 *)&v7);
        if ((_DWORD)result)
          break;
        a3 = (__int128 *)((char *)a3 + 24);
        if (!--v4)
          return 0;
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t krb5_ret_addrs(uint64_t a1, unsigned int *a2)
{
  uint64_t result;
  size_t v5;
  unint64_t v6;
  BOOL v7;
  void *v8;
  int v9;
  uint64_t v10;
  unint64_t v11;
  size_t count;

  LODWORD(count) = 0;
  result = krb5_ret_int32(a1, (unsigned int *)&count);
  if (!(_DWORD)result)
  {
    v5 = count;
    v6 = *(_QWORD *)(a1 + 56);
    if (v6)
      v7 = v6 / 0x18 >= (int)count;
    else
      v7 = 1;
    if (v7)
    {
      *a2 = count;
      v8 = malloc_type_calloc(v5, 0x18uLL, 0x10800404ACF7207uLL);
      *((_QWORD *)a2 + 1) = v8;
      v9 = *a2;
      if (v8)
      {
        if (v9)
        {
          v10 = 0;
          v11 = 0;
          while (1)
          {
            result = krb5_ret_address(a1, *((_QWORD *)a2 + 1) + v10);
            if ((_DWORD)result)
              break;
            ++v11;
            v10 += 24;
            if (v11 >= *a2)
              return 0;
          }
        }
        else
        {
          return 0;
        }
      }
      else if (v9)
      {
        return 12;
      }
      else
      {
        return 0;
      }
    }
    else
    {
      return 2314790665;
    }
  }
  return result;
}

uint64_t krb5_store_authdata(uint64_t a1, unsigned int a2, uint64_t a3)
{
  uint64_t result;
  uint64_t v7;
  uint64_t *v8;
  BOOL v9;

  result = krb5_store_int32(a1, a2);
  if (!(_DWORD)result)
  {
    if (a2)
    {
      v7 = a2 - 1;
      v8 = (uint64_t *)(a3 + 16);
      do
      {
        if (krb5_store_int16(a1, *((__int16 *)v8 - 8)))
          break;
        v9 = krb5_store_data(a1, *(v8 - 1), *v8) || v7-- == 0;
        v8 += 3;
      }
      while (!v9);
    }
    return 0;
  }
  return result;
}

uint64_t krb5_ret_authdata(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  uint64_t v5;
  size_t v6;
  unint64_t v7;
  BOOL v8;
  void *v9;
  BOOL v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  __int16 v14;
  int v15;

  v15 = 0;
  result = krb5_ret_int32(a1, (unsigned int *)&v15);
  if (!(_DWORD)result)
  {
    v5 = v15;
    v6 = v15;
    v7 = *(_QWORD *)(a1 + 56);
    if (v7)
      v8 = v7 / 0x18 >= v15;
    else
      v8 = 1;
    if (v8)
    {
      *(_DWORD *)a2 = v15;
      v9 = malloc_type_calloc(v6, 0x18uLL, 0x10800404ACF7207uLL);
      *(_QWORD *)(a2 + 8) = v9;
      if (v9)
        v10 = 1;
      else
        v10 = (_DWORD)v5 == 0;
      if (v10)
      {
        if ((int)v5 < 1)
        {
          return 0;
        }
        else
        {
          v11 = 0;
          v14 = 0;
          v12 = 24 * v5;
          do
          {
            result = krb5_ret_int16(a1, &v14);
            if ((_DWORD)result)
              break;
            v13 = *(_QWORD *)(a2 + 8);
            *(_DWORD *)(v13 + v11) = v14;
            result = krb5_ret_data(a1, (size_t *)(v13 + v11 + 8));
            if ((_DWORD)result)
              break;
            v11 += 24;
          }
          while (v12 != v11);
        }
      }
      else
      {
        return 12;
      }
    }
    else
    {
      return 2314790665;
    }
  }
  return result;
}

uint64_t krb5_store_creds(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  __int128 v5;
  unsigned int v6;
  int v7;
  int v8;
  uint64_t v9;
  __int128 v10;
  __int128 v11;

  result = krb5_store_principal(a1, *(_QWORD *)a2);
  if (!(_DWORD)result)
  {
    result = krb5_store_principal(a1, *(_QWORD *)(a2 + 8));
    if (!(_DWORD)result)
    {
      v10 = *(_OWORD *)(a2 + 16);
      *(_QWORD *)&v11 = *(_QWORD *)(a2 + 32);
      result = krb5_store_keyblock(a1, (__int16 *)&v10);
      if (!(_DWORD)result)
      {
        v5 = *(_OWORD *)(a2 + 56);
        v10 = *(_OWORD *)(a2 + 40);
        v11 = v5;
        result = krb5_store_times(a1, (unsigned int *)&v10);
        if (!(_DWORD)result)
        {
          result = krb5_store_int8(a1, *(_QWORD *)(a2 + 88) != 0);
          if (!(_DWORD)result)
          {
            v6 = *(_DWORD *)(a2 + 136);
            if ((*(_BYTE *)(a1 + 48) & 0x80) != 0)
            {
              v9 = a1;
            }
            else
            {
              v7 = TicketFlags2int(*(unsigned int *)(a2 + 136));
              v6 = 0;
              v8 = 32;
              do
              {
                v6 = v7 & 1 | (2 * v6);
                v7 >>= 1;
                --v8;
              }
              while (v8);
              v9 = a1;
            }
            result = krb5_store_int32(v9, v6);
            if (!(_DWORD)result)
            {
              result = krb5_store_addrs(a1, *(_QWORD *)(a2 + 120), *(__int128 **)(a2 + 128));
              if (!(_DWORD)result)
              {
                result = krb5_store_authdata(a1, *(_QWORD *)(a2 + 104), *(_QWORD *)(a2 + 112));
                if (!(_DWORD)result)
                {
                  result = krb5_store_data(a1, *(_QWORD *)(a2 + 72), *(_QWORD *)(a2 + 80));
                  if (!(_DWORD)result)
                    return krb5_store_data(a1, *(_QWORD *)(a2 + 88), *(_QWORD *)(a2 + 96));
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t krb5_ret_creds(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  uint64_t v5;
  int *v6;
  int v7;
  int v8;
  int v9;
  unsigned int v10;
  char v11;

  *(_OWORD *)(a2 + 112) = 0u;
  *(_OWORD *)(a2 + 128) = 0u;
  *(_OWORD *)(a2 + 80) = 0u;
  *(_OWORD *)(a2 + 96) = 0u;
  *(_OWORD *)(a2 + 48) = 0u;
  *(_OWORD *)(a2 + 64) = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  *(_OWORD *)(a2 + 32) = 0u;
  *(_OWORD *)a2 = 0u;
  result = krb5_ret_principal(a1, (_QWORD *)a2);
  if (!(_DWORD)result)
  {
    result = krb5_ret_principal(a1, (_QWORD *)(a2 + 8));
    if (!(_DWORD)result)
    {
      result = krb5_ret_keyblock(a1, a2 + 16);
      if (!(_DWORD)result)
      {
        result = krb5_ret_times(a1, (_QWORD *)(a2 + 40));
        if (!(_DWORD)result)
        {
          v11 = 0;
          v5 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(a1 + 8))(a1, &v11, 1);
          if (v5 == 1
            || (v5 < 0 ? (v6 = __error()) : (v6 = (int *)(a1 + 52)), result = *v6, !(_DWORD)result))
          {
            v10 = 0;
            result = krb5_ret_int32(a1, &v10);
            if (!(_DWORD)result)
            {
              v7 = v10;
              if (v10 >= 0x10000)
              {
                v8 = 0;
                v9 = 32;
                do
                {
                  v8 = v7 & 1 | (2 * v8);
                  v7 >>= 1;
                  --v9;
                }
                while (v9);
              }
              else
              {
                v8 = v10;
              }
              *(_DWORD *)(a2 + 136) = v8;
              result = krb5_ret_addrs(a1, (unsigned int *)(a2 + 120));
              if (!(_DWORD)result)
              {
                result = krb5_ret_authdata(a1, a2 + 104);
                if (!(_DWORD)result)
                {
                  result = krb5_ret_data(a1, (size_t *)(a2 + 72));
                  if (!(_DWORD)result)
                    return krb5_ret_data(a1, (size_t *)(a2 + 88));
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t krb5_store_creds_tag(uint64_t a1, uint64_t a2)
{
  unsigned int v4;
  __int128 *v5;
  unsigned int v6;
  uint64_t result;
  uint64_t v8;
  __int128 v9;
  int v10;
  unsigned int v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  __int128 v15;
  __int128 v16;

  v4 = *(_QWORD *)a2 != 0;
  if (*(_QWORD *)(a2 + 8))
    v4 |= 2u;
  v5 = (__int128 *)(a2 + 16);
  if (*(_DWORD *)(a2 + 16))
    v4 |= 4u;
  if (*(_QWORD *)(a2 + 80))
    v4 |= 8u;
  if (*(_QWORD *)(a2 + 88))
    v4 |= 0x10u;
  if (*(_DWORD *)(a2 + 104))
    v4 |= 0x20u;
  if (*(_DWORD *)(a2 + 120))
    v6 = v4 | 0x40;
  else
    v6 = v4;
  result = krb5_store_int32(a1, v6);
  if (!(_DWORD)result)
  {
    if (!*(_QWORD *)a2 || (result = krb5_store_principal(a1, *(_QWORD *)a2), !(_DWORD)result))
    {
      v8 = *(_QWORD *)(a2 + 8);
      if (!v8 || (result = krb5_store_principal(a1, v8), !(_DWORD)result))
      {
        if (!*(_DWORD *)v5
          || (v15 = *v5,
              *(_QWORD *)&v16 = *((_QWORD *)v5 + 2),
              result = krb5_store_keyblock(a1, (__int16 *)&v15),
              !(_DWORD)result))
        {
          v9 = *(_OWORD *)(a2 + 56);
          v15 = *(_OWORD *)(a2 + 40);
          v16 = v9;
          result = krb5_store_times(a1, (unsigned int *)&v15);
          if (!(_DWORD)result)
          {
            result = krb5_store_int8(a1, *(_QWORD *)(a2 + 88) != 0);
            if (!(_DWORD)result)
            {
              v10 = TicketFlags2int(*(unsigned int *)(a2 + 136));
              v11 = 0;
              v12 = 32;
              do
              {
                v11 = v10 & 1 | (2 * v11);
                v10 >>= 1;
                --v12;
              }
              while (v12);
              result = krb5_store_int32(a1, v11);
              if (!(_DWORD)result)
              {
                if (!*(_DWORD *)(a2 + 120)
                  || (result = krb5_store_addrs(a1, *(_QWORD *)(a2 + 120), *(__int128 **)(a2 + 128)), !(_DWORD)result))
                {
                  if (!*(_DWORD *)(a2 + 104)
                    || (result = krb5_store_authdata(a1, *(_QWORD *)(a2 + 104), *(_QWORD *)(a2 + 112)), !(_DWORD)result))
                  {
                    v13 = *(_QWORD *)(a2 + 80);
                    if (!v13 || (result = krb5_store_data(a1, *(_QWORD *)(a2 + 72), v13), !(_DWORD)result))
                    {
                      v14 = *(_QWORD *)(a2 + 96);
                      if (!v14)
                        return 0;
                      result = krb5_store_data(a1, *(_QWORD *)(a2 + 88), v14);
                      if (!(_DWORD)result)
                        return 0;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t krb5_ret_creds_tag(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  char v5;
  uint64_t v6;
  int *v7;
  int v8;
  int v9;
  int v10;
  unsigned int v11;
  unsigned int v12;
  char v13;

  v13 = 0;
  v11 = 0;
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  *(_OWORD *)(a2 + 32) = 0u;
  *(_OWORD *)(a2 + 48) = 0u;
  *(_OWORD *)(a2 + 64) = 0u;
  *(_OWORD *)(a2 + 80) = 0u;
  *(_OWORD *)(a2 + 96) = 0u;
  *(_OWORD *)(a2 + 112) = 0u;
  *(_OWORD *)(a2 + 128) = 0u;
  result = krb5_ret_int32(a1, &v11);
  if (!(_DWORD)result)
  {
    v5 = v11;
    if ((v11 & 1) == 0 || (result = krb5_ret_principal(a1, (_QWORD *)a2), !(_DWORD)result))
    {
      if ((v5 & 2) == 0 || (result = krb5_ret_principal(a1, (_QWORD *)(a2 + 8)), !(_DWORD)result))
      {
        if ((v5 & 4) == 0 || (result = krb5_ret_keyblock(a1, a2 + 16), !(_DWORD)result))
        {
          result = krb5_ret_times(a1, (_QWORD *)(a2 + 40));
          if (!(_DWORD)result)
          {
            v6 = (*(uint64_t (**)(uint64_t, char *, uint64_t))(a1 + 8))(a1, &v13, 1);
            if (v6 == 1
              || (v6 < 0 ? (v7 = __error()) : (v7 = (int *)(a1 + 52)), result = *v7, !(_DWORD)result))
            {
              v12 = 0;
              result = krb5_ret_int32(a1, &v12);
              if (!(_DWORD)result)
              {
                v8 = v12;
                if (v12 >= 0x10000)
                {
                  v9 = 0;
                  v10 = 32;
                  do
                  {
                    v9 = v8 & 1 | (2 * v9);
                    v8 >>= 1;
                    --v10;
                  }
                  while (v10);
                }
                else
                {
                  v9 = v12;
                }
                *(_DWORD *)(a2 + 136) = v9;
                if ((v5 & 0x40) == 0 || (result = krb5_ret_addrs(a1, (unsigned int *)(a2 + 120)), !(_DWORD)result))
                {
                  if ((v5 & 0x20) == 0 || (result = krb5_ret_authdata(a1, a2 + 104), !(_DWORD)result))
                  {
                    if ((v5 & 8) == 0 || (result = krb5_ret_data(a1, (size_t *)(a2 + 72)), !(_DWORD)result))
                    {
                      if ((v5 & 0x10) != 0)
                        return krb5_ret_data(a1, (size_t *)(a2 + 88));
                      else
                        return 0;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t krb5_store_uuid(uint64_t a1, uint64_t a2)
{
  if ((*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1 + 16))(a1, a2, 16) == 16)
    return 0;
  else
    return 2314790666;
}

uint64_t krb5_ret_uuid(uint64_t a1, uint64_t a2)
{
  if ((*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1 + 8))(a1, a2, 16) == 16)
    return 0;
  else
    return 2314790666;
}

void krb5_free_ticket(krb5_context a1, krb5_ticket *a2)
{
  sub_2096BB848();
  krb5_free_principal(a1, *(krb5_principal *)&a2[2].enc_part.kvno);
  krb5_free_principal(a1, *(krb5_principal *)&a2[2].enc_part.ciphertext.magic);
  free(a2);
}

krb5_error_code krb5_copy_ticket(krb5_context a1, const krb5_ticket *a2, krb5_ticket **a3)
{
  krb5_principal *v6;
  krb5_principal *v7;
  krb5_error_code v8;
  krb5_error_code v9;
  krb5_error_code v10;

  *a3 = 0;
  v6 = (krb5_principal *)malloc_type_malloc(0x98uLL, 0x10B0040764A81A9uLL);
  if (v6)
  {
    v7 = v6;
    v8 = sub_2096BB858();
    if (v8)
    {
      v9 = v8;
    }
    else
    {
      v10 = krb5_copy_principal(a1, *(krb5_const_principal *)&a2[2].enc_part.kvno, v7 + 17);
      if (v10)
      {
        v9 = v10;
      }
      else
      {
        v9 = krb5_copy_principal(a1, *(krb5_const_principal *)&a2[2].enc_part.ciphertext.magic, v7 + 18);
        if (!v9)
        {
          *a3 = (krb5_ticket *)v7;
          return v9;
        }
        krb5_free_principal(a1, v7[17]);
      }
      sub_2096BB848();
    }
    free(v7);
  }
  else
  {
    v9 = 12;
    krb5_set_error_message(a1, 12, "malloc: out of memory");
  }
  return v9;
}

uint64_t krb5_ticket_get_client(_krb5_context *a1, uint64_t a2, krb5_principal *a3)
{
  return krb5_copy_principal(a1, *(krb5_const_principal *)(a2 + 136), a3);
}

uint64_t krb5_ticket_get_server(_krb5_context *a1, uint64_t a2, krb5_principal *a3)
{
  return krb5_copy_principal(a1, *(krb5_const_principal *)(a2 + 144), a3);
}

uint64_t krb5_ticket_get_endtime(uint64_t a1, uint64_t a2)
{
  return *(_QWORD *)(a2 + 104);
}

uint64_t _krb5_get_ad(_krb5_context *a1, unsigned int *a2, uint64_t a3, uint64_t a4, _QWORD *a5)
{
  uint64_t v9;
  const char *v10;
  uint64_t v12;
  int v13;

  v13 = 0;
  krb5_data_zero(a5);
  if (!a2)
  {
    v10 = "No authorization data";
    goto LABEL_7;
  }
  v9 = sub_2096B1930(a1, a4, a5, &v13, 1, a2, 0);
  if (!(_DWORD)v9)
  {
    if (v13)
      return 0;
    v12 = a4;
    v10 = "Have no authorization data of type %d";
LABEL_7:
    v9 = 2;
    krb5_set_error_message(a1, 2, v10, v12);
  }
  return v9;
}

uint64_t sub_2096B1930(_krb5_context *a1, uint64_t a2, _QWORD *a3, _DWORD *a4, int a5, unsigned int *a6, int a7)
{
  const char *v10;
  uint64_t v11;
  _krb5_context *v12;
  krb5_error_code v13;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  int v20;
  uint64_t v22;
  uint64_t v23;
  uint64_t v25;
  unsigned int v26;
  _QWORD v27[2];

  if (a7 > 9)
  {
    v25 = 10;
    v10 = "Authorization data nested deeper then %d levels, stop searching";
LABEL_3:
    v11 = 2;
    v12 = a1;
    v13 = 2;
    goto LABEL_4;
  }
  if (!*a6)
    return 0;
  v17 = 0;
  v18 = 0;
  v26 = a7 + 1;
  while (1)
  {
    v19 = *((_QWORD *)a6 + 1);
    v20 = *(_DWORD *)(v19 + v17);
    if (*a4 || v20 != (_DWORD)a2)
      break;
    v23 = der_copy_octet_string();
    if ((_DWORD)v23)
    {
      v11 = v23;
      v10 = "malloc: out of memory";
      goto LABEL_29;
    }
    *a4 = 1;
LABEL_23:
    ++v18;
    v17 += 24;
    if (v18 >= *a6)
      return 0;
  }
  if (v20 == 5)
  {
    if (a5)
    {
      v10 = "Authorization data contains AND-OR element that is unknown to the application";
      goto LABEL_3;
    }
    goto LABEL_23;
  }
  if (v20 != 1)
  {
    if (a5)
    {
      v25 = *(unsigned int *)(v19 + v17);
      v10 = "Authorization data contains unknown type (%d) ";
      goto LABEL_3;
    }
    goto LABEL_23;
  }
  v27[0] = 0;
  v27[1] = 0;
  v22 = sub_2096BB5D8();
  if (!(_DWORD)v22)
  {
    v11 = sub_2096B1930(a1, a2, a3, a4, 0, v27, v26);
    sub_2096BB628();
    if ((_DWORD)v11)
      goto LABEL_5;
    goto LABEL_23;
  }
  v11 = v22;
  v25 = v22;
  v10 = "Failed to decode IF_RELEVANT with %d";
LABEL_29:
  v12 = a1;
  v13 = v11;
LABEL_4:
  krb5_set_error_message(v12, v13, v10, v25);
LABEL_5:
  if (*a4)
  {
    krb5_data_free(a3);
    *a4 = 0;
  }
  return v11;
}

uint64_t krb5_ticket_get_authorization_data_type(_krb5_context *a1, uint64_t a2, uint64_t a3, _QWORD *a4)
{
  unsigned int *v8;
  uint64_t v9;
  const char *v10;
  uint64_t v12;
  int v13;

  v13 = 0;
  krb5_data_zero(a4);
  v8 = *(unsigned int **)(a2 + 128);
  if (!v8)
  {
    v10 = "Ticket have not authorization data";
    goto LABEL_7;
  }
  v9 = sub_2096B1930(a1, a3, a4, &v13, 1, v8, 0);
  if (!(_DWORD)v9)
  {
    if (v13)
      return 0;
    v12 = a3;
    v10 = "Ticket have not authorization data of type %d";
LABEL_7:
    v9 = 2;
    krb5_set_error_message(a1, 2, v10, v12);
  }
  return v9;
}

uint64_t sub_2096B1B94(uint64_t a1, uint64_t a2, uint64_t a3, const krb5_keyblock *a4, uint64_t a5, krb5_address *const *a6, int a7, char a8, uint64_t a9, uint64_t (*a10)(_krb5_context *a1, const krb5_keyblock *a2, uint64_t a3, uint64_t a4, uint64_t a5), uint64_t a11)
{
  uint64_t (*v18)(_krb5_context *, const krb5_keyblock *, uint64_t, uint64_t, uint64_t);
  uint64_t v19;
  uint64_t v21;
  uint64_t v22;
  size_t v23;
  const char *v24;
  uint64_t v25;
  const char *v26;
  uint64_t v27;
  const char *v28;
  krb5_principal v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t *v36;
  uint64_t v37;
  uint64_t v38;
  const char *realm;
  const char *v40;
  const char *v41;
  const char *v42;
  _krb5_context *v43;
  krb5_error_code v44;
  _QWORD *v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  krb5_address *const *v49;
  krb5_address ***v50;
  _krb5_context *v51;
  size_t v52;
  void *v53;
  uint64_t v54;
  uint64_t v55;
  const char *v56;
  uint64_t v57;
  int v58;
  __int128 seed;
  uint64_t v60;
  krb5_cksumtype ctype[2];
  krb5_timestamp v62[2];
  uint64_t v63;
  krb5_principal v64;

  v18 = a10;
  v63 = 0;
  v64 = 0;
  *(_QWORD *)v62 = 0;
  if (!a10)
    v18 = sub_2096B215C;
  v19 = v18((_krb5_context *)a1, a4, a5, a11, a2);
  if ((_DWORD)v19)
    goto LABEL_4;
  if ((a8 & 0x20) != 0 && a9 && (*(_DWORD *)(a2 + 208) & 0x8000) != 0)
  {
    *(_QWORD *)ctype = 0;
    seed = 0uLL;
    v60 = 0;
    v58 = 0;
    sub_20969D1E8(a1, 5, "processing enc-ap-rep");
    v21 = *(_QWORD *)(a2 + 288);
    if (!v21 || !krb5_find_padata(*(_QWORD *)(v21 + 8), *(_DWORD *)v21, 149, &v58))
    {
      v19 = 2529638953;
      sub_20969D1E8(a1, 5, "KRB5_PADATA_REQ_ENC_PA_REP missing");
      goto LABEL_4;
    }
    v19 = krb5_crypto_init((_krb5_context *)a1, a4, 0, (krb5_keyblock ***)ctype);
    if ((_DWORD)v19)
    {
LABEL_4:
      sub_20969D1E8(a1, 5, "_krb5_extract_ticket failed with %d", v19);
      goto LABEL_5;
    }
    v22 = sub_2096BB86C();
    if ((_DWORD)v22)
    {
      v19 = v22;
      krb5_crypto_destroy((_krb5_context *)a1, *(uint64_t *)ctype);
      goto LABEL_4;
    }
    v19 = krb5_verify_checksum((krb5_context)a1, ctype[0], (const krb5_checksum *)0x38, *(krb5_const_pointer *)(a9 + 8), *(_QWORD *)a9, &seed, v23);
    krb5_crypto_destroy((_krb5_context *)a1, *(uint64_t *)ctype);
    sub_2096BB8BC();
    v24 = "in";
    if (!(_DWORD)v19)
      v24 = "";
    sub_20969D22C((uint64_t *)a1, 5, v19, "enc-ap-rep: %svalid", v24);
    if ((_DWORD)v19)
      goto LABEL_4;
  }
  *(_QWORD *)(a3 + 32) = 0;
  *(_QWORD *)(a3 + 24) = 0;
  *(_DWORD *)(a3 + 16) = *(_DWORD *)(a2 + 152);
  v25 = krb5_data_copy((_QWORD *)(a3 + 24), *(const void **)(a2 + 168), *(_QWORD *)(a2 + 160));
  if ((_DWORD)v25)
  {
    v19 = v25;
LABEL_20:
    krb5_clear_error_message((krb5_context)a1);
    goto LABEL_4;
  }
  v26 = *(const char **)(a2 + 16);
  seed = *(_OWORD *)(a2 + 24);
  v60 = *(_QWORD *)(a2 + 40);
  v19 = _krb5_principalname2krb5_principal(a1, &v64, (uint64_t)&seed, v26);
  if ((_DWORD)v19)
    goto LABEL_4;
  if ((a8 & 1) == 0)
  {
    v27 = sub_2096B223C((krb5_context)a1, a2, *(krb5_const_principal *)a3, v64, (const krb5_keyblock *)(a3 + 16));
    if ((_DWORD)v27)
      goto LABEL_27;
  }
  krb5_free_principal((krb5_context)a1, *(krb5_principal *)a3);
  *(_QWORD *)a3 = v64;
  v28 = *(const char **)(a2 + 248);
  seed = *(_OWORD *)(a2 + 256);
  v60 = *(_QWORD *)(a2 + 272);
  v19 = _krb5_principalname2krb5_principal(a1, &v64, (uint64_t)&seed, v28);
  if ((_DWORD)v19)
    goto LABEL_4;
  if ((a8 & 2) == 0)
  {
    v27 = sub_2096B24D4((krb5_context)a1, a2, a8, *(krb5_const_principal *)(a3 + 8), v64, (const krb5_keyblock *)(a3 + 16));
    if ((_DWORD)v27)
    {
LABEL_27:
      v19 = v27;
      krb5_free_principal((krb5_context)a1, v64);
      goto LABEL_4;
    }
  }
  krb5_free_principal((krb5_context)a1, *(krb5_principal *)(a3 + 8));
  v29 = v64;
  *(_QWORD *)(a3 + 8) = v64;
  if ((a8 & 4) != 0)
  {
    realm = (const char *)krb5_principal_get_realm(a1, (uint64_t)v29);
    v40 = (const char *)krb5_principal_get_realm(a1, *(_QWORD *)a3);
    v41 = *(const char **)(a2 + 248);
    if (strcmp(v41, realm) || strcmp(v41, v40))
    {
      v19 = 2529638953;
      krb5_set_error_message((krb5_context)a1, -1765328343, "server realm (%s) doesn't match client's (%s)", realm, v40);
      goto LABEL_20;
    }
  }
  if (*(_DWORD *)(a2 + 192) != a7)
  {
    v19 = 2529638953;
    v42 = "malloc: out of memory";
LABEL_44:
    v43 = (_krb5_context *)a1;
    v44 = -1765328343;
LABEL_55:
    krb5_set_error_message(v43, v44, v42, v55, v56, v57);
    goto LABEL_4;
  }
  krb5_timeofday((krb5_context)a1, v62);
  if ((a8 & 0x10) != 0 && (*(_DWORD *)(a2 + 208) & 0x200) != 0 && !*(_DWORD *)(a1 + 108))
  {
    v56 = "kdc_timesync";
    v57 = 0;
    if (krb5_config_get_BOOL(a1, 0, v30, v31, v32, v33, v34, v35, (uint64_t)"libdefaults"))
    {
      *(_DWORD *)(a1 + 108) = *(_DWORD *)(a2 + 216) - v62[0];
      krb5_timeofday((krb5_context)a1, v62);
    }
  }
  v36 = *(uint64_t **)(a2 + 224);
  if (!v36)
    v36 = (uint64_t *)(a2 + 216);
  v37 = *v36;
  v38 = *(_QWORD *)(a3 + 48);
  if (!v38)
  {
    if (krb5_time_abs(v37, *(uint64_t *)v62) > *(_QWORD *)(a1 + 80))
    {
      krb5_time_abs(v37, *(uint64_t *)v62);
      v19 = 2529638949;
      krb5_set_error_message((krb5_context)a1, -1765328347, "time skew (%ld) larger than max (%d)");
      goto LABEL_4;
    }
    v38 = *(_QWORD *)(a3 + 48);
  }
  if (v38 && v37 != v38)
  {
    v19 = 2529638953;
    krb5_clear_error_message((krb5_context)a1);
    v42 = "startime is not the requested startime";
LABEL_54:
    v43 = (_krb5_context *)a1;
    v44 = 0;
    goto LABEL_55;
  }
  *(_QWORD *)(a3 + 48) = v37;
  v45 = *(_QWORD **)(a2 + 240);
  if (v45)
    v45 = (_QWORD *)*v45;
  v46 = *(_QWORD *)(a3 + 64);
  if (v46 && (uint64_t)v45 > v46)
  {
    v19 = 2529638953;
    krb5_clear_error_message((krb5_context)a1);
    v42 = "renewtime is past the requested renewtime";
    goto LABEL_54;
  }
  *(_QWORD *)(a3 + 64) = v45;
  *(_QWORD *)(a3 + 40) = *(_QWORD *)(a2 + 216);
  v47 = *(_QWORD *)(a3 + 56);
  v48 = *(_QWORD *)(a2 + 232);
  if (v47 && v48 > v47)
  {
    v19 = 2529638953;
    krb5_clear_error_message((krb5_context)a1);
    v42 = "endtime is past the requested endtime";
    goto LABEL_44;
  }
  *(_QWORD *)(a3 + 56) = v48;
  v49 = *(krb5_address *const **)(a2 + 280);
  if (v49)
  {
    v50 = (krb5_address ***)(a3 + 120);
    v51 = (_krb5_context *)a1;
LABEL_64:
    krb5_copy_addresses(v51, v49, v50);
    goto LABEL_65;
  }
  if (a6)
  {
    v50 = (krb5_address ***)(a3 + 120);
    v51 = (_krb5_context *)a1;
    v49 = a6;
    goto LABEL_64;
  }
  *(_DWORD *)(a3 + 120) = 0;
  *(_QWORD *)(a3 + 128) = 0;
LABEL_65:
  *(_DWORD *)(a3 + 136) = *(_DWORD *)(a2 + 208);
  *(_DWORD *)(a3 + 104) = 0;
  *(_QWORD *)(a3 + 112) = 0;
  v52 = sub_2096BB7F4();
  *(_QWORD *)(a3 + 72) = v52;
  v53 = malloc_type_malloc(v52, 0x699259FEuLL);
  *(_QWORD *)(a3 + 80) = v53;
  if (!v53)
  {
    v19 = 12;
    goto LABEL_4;
  }
  v54 = sub_2096BB7D4();
  if ((_DWORD)v54)
  {
    v19 = v54;
    free(*(void **)(a3 + 80));
    *(_QWORD *)(a3 + 80) = 0;
    goto LABEL_4;
  }
  if (*(_QWORD *)(a3 + 72) != v63)
    krb5_abortx((_krb5_context *)a1, "internal error in ASN.1 encoder");
  v19 = 0;
  *(_QWORD *)(a3 + 88) = 0;
  *(_QWORD *)(a3 + 96) = 0;
LABEL_5:
  bzero(*(void **)(a2 + 168), *(_QWORD *)(a2 + 160));
  return v19;
}

uint64_t sub_2096B215C(_krb5_context *a1, const krb5_keyblock *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v8;
  krb5_keyblock **v10[2];
  _QWORD v11[2];

  v11[0] = 0;
  v11[1] = 0;
  v10[0] = 0;
  v10[1] = 0;
  v8 = krb5_crypto_init(a1, a2, 0, v10);
  if (!(_DWORD)v8)
  {
    v8 = krb5_decrypt_EncryptedData(a1, (uint64_t)v10[0], a3, a5 + 120, v11);
    krb5_crypto_destroy(a1, (uint64_t)v10[0]);
    if (!(_DWORD)v8)
    {
      if (sub_2096BBD20())
      {
        v8 = sub_2096BBD50();
        krb5_data_free(v11);
        if ((_DWORD)v8)
          krb5_set_error_message(a1, v8, "Failed to decode encpart in ticket");
      }
      else
      {
        krb5_data_free(v11);
        return 0;
      }
    }
  }
  return v8;
}

uint64_t sub_2096B223C(krb5_context a1, uint64_t a2, krb5_const_principal a3, krb5_const_principal a4, const krb5_keyblock *a5)
{
  uint64_t v9;
  uint64_t v11;
  uint64_t v12;
  const char *v13;
  _krb5_context *v14;
  krb5_error_code v15;
  char *v16;
  size_t v17;
  void *v18;
  void *v19;
  uint64_t v20;
  size_t v21;
  krb5_data *data;
  char *v24;
  int v25;
  uint64_t v26;
  krb5_cksumtype ctype[2];
  _OWORD v28[3];
  __int128 v29;
  uint64_t v30;

  v30 = 0;
  v29 = 0u;
  memset(v28, 0, sizeof(v28));
  v26 = 0;
  *(_QWORD *)ctype = 0;
  v25 = 0;
  v9 = *(_QWORD *)(a2 + 8);
  if (v9 && krb5_find_padata(*(_QWORD *)(v9 + 8), *(_DWORD *)v9, 133, &v25))
  {
    v11 = sub_2096BC230();
    if ((_DWORD)v11)
    {
      v12 = v11;
      data = a3->data;
      v13 = "Failed to decode ClientCanonicalized from realm %s";
      v14 = a1;
      v15 = v12;
LABEL_5:
      krb5_set_error_message(v14, v15, v13, data);
      return v12;
    }
    v17 = sub_2096BC220();
    v18 = malloc_type_malloc(v17, 0xB2513FC4uLL);
    if (!v18)
    {
      v12 = 12;
      goto LABEL_17;
    }
    v19 = v18;
    v20 = sub_2096BC200();
    if ((_DWORD)v20)
      goto LABEL_15;
    if (v17 != v26)
      krb5_abortx(a1, "internal asn.1 error");
    v20 = krb5_crypto_init(a1, a5, 0, (krb5_keyblock ***)ctype);
    if ((_DWORD)v20)
    {
LABEL_15:
      v12 = v20;
      free(v19);
LABEL_17:
      sub_2096BC250();
      return v12;
    }
    v12 = krb5_verify_checksum(a1, ctype[0], (const krb5_checksum *)0xFFFFFFE9, v19, v17, &v29, v21);
    krb5_crypto_destroy(a1, *(uint64_t *)ctype);
    free(v19);
    if ((_DWORD)v12)
    {
      krb5_set_error_message(a1, v12, "Failed to verify client canonicalized data from realm %s", (const char *)a3->data);
      goto LABEL_17;
    }
    if (sub_2096A6B94((uint64_t)a1, (uint64_t)a3, (uint64_t)v28))
    {
      if (sub_2096A6B94((uint64_t)a1, (uint64_t)a4, (uint64_t)&v28[1] + 8))
        return 0;
      v12 = 2529639058;
      sub_2096BC250();
      v13 = "Mapped name doesn't match in client referral";
    }
    else
    {
      v12 = 2529639058;
      sub_2096BC250();
      v13 = "Requested name doesn't match in client referral";
    }
    v14 = a1;
    v15 = -1765328238;
    goto LABEL_5;
  }
  if (krb5_principal_compare(a1, a3, a4) || (*(_BYTE *)(a2 + 209) & 0x80) != 0)
    return 0;
  v24 = 0;
  krb5_unparse_name(a1, a4, &v24);
  v16 = v24;
  if (!v24)
    v16 = "<unknown name>";
  v12 = 2529638953;
  krb5_set_error_message(a1, -1765328343, "Not same client principal returned (%s)as requested", v16);
  krb5_xfree(v24);
  return v12;
}

uint64_t sub_2096B24D4(krb5_context a1, uint64_t a2, char a3, krb5_const_principal a4, krb5_const_principal a5, const krb5_keyblock *a6)
{
  uint64_t v9;
  _DWORD *padata;
  _DWORD *v13;
  uint64_t v14;
  uint64_t v15;
  int v17;
  _QWORD v18[2];
  uint64_t v19;
  _OWORD v20[2];
  krb5_keyblock **v21;
  __int128 v22;
  __int128 v23;

  v21 = 0;
  v18[1] = 0;
  v19 = 0;
  v18[0] = 0;
  v17 = 0;
  v9 = *(_QWORD *)(a2 + 8);
  if (!v9 || (padata = krb5_find_padata(*(_QWORD *)(v9 + 8), *(_DWORD *)v9, 25, &v17)) == 0)
  {
    if (krb5_principal_compare(a1, a4, a5) != 1
      && krb5_realm_compare(a1, a4, a5) != 1
      && !krb5_principal_is_krbtgt((uint64_t)a1, (uint64_t)a5))
    {
      v14 = 2529638953;
      krb5_set_error_message(a1, -1765328343, "Not same server principal returned as requested");
      return v14;
    }
    return 0;
  }
  v13 = padata;
  memset(v20, 0, sizeof(v20));
  v22 = 0u;
  v23 = 0u;
  v14 = sub_2096BB6E0();
  if (!(_DWORD)v14)
  {
    if (v19 != *((_QWORD *)v13 + 1))
    {
      v14 = 2529638953;
      sub_2096BB730();
      krb5_set_error_message(a1, -1765328343, "Referral EncryptedData wrong for realm %s");
      return v14;
    }
    v15 = krb5_crypto_init(a1, a6, 0, &v21);
    if ((_DWORD)v15)
    {
      v14 = v15;
      sub_2096BB730();
      return v14;
    }
    v14 = krb5_decrypt_EncryptedData(a1, (uint64_t)v21, 26, (uint64_t)v20, v18);
    sub_2096BB730();
    krb5_crypto_destroy(a1, (uint64_t)v21);
    if (!(_DWORD)v14)
    {
      v14 = sub_2096BC260();
      krb5_data_free(v18);
      if (!(_DWORD)v14)
      {
        if (strcmp((const char *)a4->data, (const char *)a5->data))
        {
          v14 = 2529638953;
          sub_2096BC280();
          krb5_set_error_message(a1, -1765328343, "server ref realm mismatch, requested realm %s got back %s");
          return v14;
        }
        if (krb5_principal_is_krbtgt((uint64_t)a1, (uint64_t)a5))
        {
          if (!(_QWORD)v22 || strcmp(*(const char **)v22, *((const char **)a5->realm.data + 1)))
          {
            v14 = 2529638953;
            sub_2096BC280();
            krb5_set_error_message(a1, -1765328343, "tgt returned with wrong ref");
            return v14;
          }
        }
        else if (!krb5_principal_compare(a1, a5, a4))
        {
          v14 = 2529638953;
          sub_2096BC280();
          krb5_set_error_message(a1, -1765328343, "req princ no same as returned");
          return v14;
        }
        if ((_QWORD)v23)
        {
          if (!sub_2096A6B94((uint64_t)a1, (uint64_t)a4, v23))
          {
            v14 = 2529638953;
            sub_2096BC280();
            krb5_set_error_message(a1, -1765328343, "referred principal not same as requested");
            return v14;
          }
        }
        else if ((a3 & 8) != 0)
        {
          v14 = 2529638953;
          sub_2096BC280();
          krb5_set_error_message(a1, -1765328343, "Requested principal missing on AS-REQ");
          return v14;
        }
        sub_2096BC280();
        return 0;
      }
    }
  }
  return v14;
}

krb5_error_code krb5_set_real_time(krb5_context a1, krb5_timestamp a2, krb5_int32 a3)
{
  __darwin_suseconds_t tv_usec;
  int v7;
  int v8;
  timeval v10;

  v10.tv_sec = 0;
  *(_QWORD *)&v10.tv_usec = 0;
  gettimeofday(&v10, 0);
  tv_usec = v10.tv_usec;
  v7 = a2 - LODWORD(v10.tv_sec);
  *((_DWORD *)a1 + 27) = a2 - LODWORD(v10.tv_sec);
  if (a3 < 0)
    goto LABEL_4;
  v8 = a3 - tv_usec;
  *((_DWORD *)a1 + 28) = v8;
  if (v8 < 0)
  {
    tv_usec = v8 + 1000000;
    *((_DWORD *)a1 + 27) = v7 - 1;
LABEL_4:
    *((_DWORD *)a1 + 28) = tv_usec;
  }
  return 0;
}

krb5_error_code krb5_timeofday(krb5_context a1, krb5_timestamp *a2)
{
  time_t v4;

  v4 = time(0);
  *(_QWORD *)a2 = v4;
  if (a1)
    *(_QWORD *)a2 = v4 + *((int *)a1 + 27);
  return 0;
}

krb5_error_code krb5_us_timeofday(krb5_context a1, krb5_timestamp *a2, krb5_int32 *a3)
{
  __darwin_time_t tv_sec;
  timeval v8;

  v8.tv_sec = 0;
  *(_QWORD *)&v8.tv_usec = 0;
  gettimeofday(&v8, 0);
  tv_sec = v8.tv_sec;
  *(_QWORD *)a2 = v8.tv_sec;
  if (a1)
    *(_QWORD *)a2 = tv_sec + *((int *)a1 + 27);
  *a3 = v8.tv_usec;
  return 0;
}

uint64_t krb5_format_time(uint64_t a1, time_t a2, char *a3, size_t a4, int a5)
{
  tm *v9;
  uint64_t v10;
  time_t v12;

  v12 = a2;
  if (*(_DWORD *)(a1 + 200))
    v9 = gmtime(&v12);
  else
    v9 = localtime(&v12);
  if (!v9)
    goto LABEL_8;
  v10 = 192;
  if (!a5)
    v10 = 272;
  if (!strftime(a3, a4, *(const char **)(a1 + v10), v9))
LABEL_8:
    snprintf(a3, a4, "%ld", v12);
  return 0;
}

krb5_error_code krb5_string_to_deltat(char *a1, krb5_deltat *a2)
{
  int v3;

  v3 = parse_time(a1, "s");
  *(_QWORD *)a2 = v3;
  if (v3 == -1)
    return -1765328136;
  else
    return 0;
}

uint64_t krb5_time_abs(uint64_t a1, uint64_t a2)
{
  if (a1 - a2 >= 0)
    return a1 - a2;
  else
    return a2 - a1;
}

uint64_t krb5_domain_x500_decode(_krb5_context *a1, uint64_t a2, char *a3, _QWORD *a4, _DWORD *a5, const char *a6, const char *a7)
{
  void *v11;
  uint64_t v12;
  int v13;
  _BYTE *v14;
  char *v15;
  int v16;
  unsigned __int8 *v17;
  unsigned __int8 *v18;
  _BYTE *v19;
  _BYTE *v20;
  _BYTE *v21;
  _BYTE *v22;
  size_t v23;
  unsigned __int8 *v24;
  unsigned __int8 *v25;
  _BYTE *v26;
  _BYTE *v27;
  _BYTE *v28;
  _BYTE *v29;
  uint64_t v30;
  const char *v31;
  const char **v32;
  size_t v33;
  size_t v34;
  char *v35;
  char *v36;
  size_t v37;
  size_t v38;
  char *v39;
  const char **v40;
  const char **v41;
  const char *v42;
  size_t v43;
  size_t v44;
  char *v45;
  char *v46;
  size_t v47;
  int64_t v48;
  char **v49;
  char **v50;
  char *v51;
  char *v52;
  char **v53;
  char *v54;
  uint64_t v55;
  char *v56;
  void **v57;
  unsigned int v58;
  _QWORD *v59;
  _QWORD *v60;
  _QWORD *v61;
  _QWORD *v62;
  void *v67;

  if (!a2)
  {
    v30 = 0;
    *a4 = 0;
    *a5 = 0;
    return v30;
  }
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = a3;
  do
  {
    if (v13)
    {
LABEL_4:
      v13 = 0;
      goto LABEL_5;
    }
    v15 = &a3[v12];
    v16 = a3[v12];
    if (v16 == 92)
    {
      v13 = 1;
    }
    else
    {
      if (v16 != 44)
        goto LABEL_4;
      v17 = (unsigned __int8 *)malloc_type_malloc(v15 - v14 + 1, 0xBD2F6DFCuLL);
      if (!v17)
      {
        v67 = v11;
        goto LABEL_31;
      }
      v18 = v17;
      memcpy(v17, v14, v15 - v14);
      v18[v15 - v14] = 0;
      v19 = sub_2096B3274(v18);
      if (!v19)
      {
        v67 = v11;
        goto LABEL_30;
      }
      if (v11)
      {
        v20 = v11;
        do
        {
          v21 = v20;
          v20 = (_BYTE *)*((_QWORD *)v20 + 2);
        }
        while (v20);
        v22 = v19;
      }
      else
      {
        v22 = 0;
        v21 = v19;
        v11 = v19;
      }
      v13 = 0;
      *((_QWORD *)v21 + 2) = v22;
      v14 = v15 + 1;
    }
LABEL_5:
    ++v12;
  }
  while (v12 != a2);
  v67 = v11;
  v23 = &a3[a2] - v14;
  v24 = (unsigned __int8 *)malloc_type_malloc(v23 + 1, 0x9DCDE67DuLL);
  if (!v24)
  {
    free(v11);
    goto LABEL_31;
  }
  v25 = v24;
  memcpy(v24, v14, v23);
  v25[v23] = 0;
  v26 = sub_2096B3274(v25);
  if (v26)
  {
    if (v11)
    {
      v27 = v11;
      do
      {
        v28 = v27;
        v27 = (_BYTE *)*((_QWORD *)v27 + 2);
      }
      while (v27);
      v29 = v26;
      v26 = v11;
    }
    else
    {
      v29 = 0;
      v28 = v26;
      v11 = v26;
    }
    *((_QWORD *)v28 + 2) = v29;
    v67 = v26;
    goto LABEL_32;
  }
LABEL_30:
  sub_2096B336C((uint64_t)v11);
LABEL_31:
  v30 = krb5_enomem(a1);
  if ((_DWORD)v30)
    return v30;
LABEL_32:
  if (!v11)
  {
    *a5 = 0;
LABEL_83:
    v58 = 1;
    goto LABEL_84;
  }
  v31 = 0;
  v32 = (const char **)v11;
  while (2)
  {
    if (((_BYTE)v32[1] & 4) == 0)
    {
      if (((_BYTE)v32[1] & 2) != 0 && ((_BYTE)v32[1] & 1) == 0 && v31)
      {
        v33 = strlen(*v32);
        v34 = v33 + strlen(v31) + 1;
        v35 = (char *)malloc_type_malloc(v34, 0x7E620E67uLL);
        if (!v35)
          break;
        v36 = v35;
        strlcpy(v35, v31, v34);
        strlcat(v36, *v32, v34);
        free((void *)*v32);
        *v32 = v36;
      }
      goto LABEL_44;
    }
    if (!v31)
      v31 = a6;
    v37 = strlen(*v32);
    v38 = v37 + strlen(v31) + 1;
    v39 = (char *)malloc_type_realloc((void *)*v32, v38, 0xC2ED25DAuLL);
    if (v39)
    {
      *v32 = v39;
      strlcat(v39, v31, v38);
LABEL_44:
      v31 = *v32;
      v32 = (const char **)v32[2];
      if (!v32)
        goto LABEL_45;
      continue;
    }
    break;
  }
  sub_2096B336C((uint64_t)v11);
  v30 = krb5_enomem(a1);
  if ((_DWORD)v30)
    return v30;
LABEL_45:
  v40 = (const char **)v11;
  do
  {
    if (!**v40)
    {
      while (1)
      {
        v41 = v40;
        v40 = (const char **)v40[2];
        if (!v40)
          break;
        v42 = *v40;
        if (**v40)
          goto LABEL_52;
      }
      v42 = a7;
LABEL_52:
      v43 = strlen(a6);
      v44 = strlen(v42);
      if (v43 >= v44)
        v45 = (char *)a6;
      else
        v45 = (char *)v42;
      if (v43 >= v44)
        a6 = v42;
      v46 = &v45[strlen(v45)];
      v47 = strlen(a6);
      if (!strcmp(&v46[-v47], a6))
      {
        while (1)
        {
          v52 = strchr(v45, 46);
          if (!v52)
            break;
          v45 = v52 + 1;
          if (!strcmp(v52 + 1, a6))
            goto LABEL_73;
          v53 = (char **)malloc_type_calloc(1uLL, 0x18uLL, 0x10300401532B4FEuLL);
          if (!v53)
            goto LABEL_72;
          v50 = v53;
          v53[2] = (char *)v41[2];
          v41[2] = (const char *)v53;
          v54 = strdup(v45);
          *v50 = v54;
          if (!v54)
          {
LABEL_71:
            v41[2] = v50[2];
            free(v50);
LABEL_72:
            v55 = krb5_enomem(a1);
            if (!(_DWORD)v55)
              goto LABEL_73;
            v30 = v55;
            goto LABEL_93;
          }
        }
      }
      else if (!strncmp(v45, a6, v47))
      {
        while (1)
        {
          if (v46 < v45 || *v46 == 47)
          {
            v48 = v46 - v45;
            if (v46 == v45)
            {
              v30 = 2529638924;
              goto LABEL_93;
            }
            if (!strncmp(a6, v45, v46 - v45))
              goto LABEL_73;
            v49 = (char **)malloc_type_calloc(1uLL, 0x18uLL, 0x10300401532B4FEuLL);
            if (!v49)
              goto LABEL_72;
            v50 = v49;
            v49[2] = (char *)v41[2];
            v41[2] = (const char *)v49;
            v51 = (char *)malloc_type_malloc(v48 + 1, 0xBAD9D264uLL);
            *v50 = v51;
            if (!v51)
              goto LABEL_71;
            memcpy(v51, v45, v46 - v45);
            (*v50)[v48] = 0;
          }
          --v46;
        }
      }
      v30 = 2529638924;
      krb5_clear_error_message(a1);
LABEL_93:
      sub_2096B336C((uint64_t)v11);
      return v30;
    }
    v41 = v40;
LABEL_73:
    a6 = *v41;
    v40 = (const char **)v41[2];
  }
  while (v40);
  v56 = (char *)v67;
  *a5 = 0;
  if (!v56)
    goto LABEL_83;
  v57 = &v67;
  do
  {
    if (**(_BYTE **)v56)
    {
      ++*a5;
      v57 = (void **)(v56 + 16);
    }
    else
    {
      *v57 = (void *)*((_QWORD *)v56 + 2);
      free(*(void **)v56);
      free(v56);
    }
    v56 = (char *)*v57;
  }
  while (*v57);
  v58 = *a5 + 1;
  if (v58 >> 29)
    return 34;
LABEL_84:
  v59 = malloc_type_malloc(8 * v58, 0x10040436913F5uLL);
  if (!v59)
    return krb5_enomem(a1);
  v60 = v59;
  *a4 = v59;
  v61 = v67;
  if (v67)
  {
    do
    {
      *v60++ = *v61;
      v62 = (_QWORD *)v61[2];
      free(v61);
      v61 = v62;
    }
    while (v62);
  }
  return 0;
}

uint64_t krb5_domain_x500_encode(const char **a1, unsigned int a2, size_t *a3)
{
  int v6;
  uint64_t v7;
  uint64_t v8;
  const char **v9;
  const char *v10;
  int v11;
  int v12;
  size_t v13;
  char *v14;
  char *v15;
  uint64_t v16;
  const char *v17;
  size_t v18;
  uint64_t result;

  krb5_data_zero(a3);
  if (!a2)
    return 0;
  v6 = 0;
  v7 = a2;
  v8 = a2;
  v9 = a1;
  do
  {
    v10 = *v9++;
    v11 = v6 + strlen(v10);
    if (*v10 == 47)
      v6 = v11 + 1;
    else
      v6 = v11;
    --v8;
  }
  while (v8);
  v12 = v6 + a2;
  v13 = (int)(v6 + a2);
  v14 = (char *)malloc_type_malloc(v12, 0xD07C6E37uLL);
  if (!v14)
    return 12;
  v15 = v14;
  v16 = 0;
  *v14 = 0;
  do
  {
    if (v16 * 8)
      strlcat(v15, ",", v13);
    v17 = a1[v16];
    if (*v17 == 47)
    {
      strlcat(v15, " ", v13);
      v17 = a1[v16];
    }
    strlcat(v15, v17, v13);
    ++v16;
  }
  while (v7 != v16);
  a3[1] = (size_t)v15;
  v18 = strlen(v15);
  result = 0;
  *a3 = v18;
  return result;
}

uint64_t krb5_check_transited(_krb5_context *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, _DWORD *a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  void **strings;
  uint64_t v13;
  const char **v14;
  const char *v15;

  v8 = a5;
  if ((_DWORD)a5)
  {
    strings = (void **)krb5_config_get_strings((uint64_t)a1, 0, a3, a4, a5, (uint64_t)a6, a7, a8, (uint64_t)"capaths");
    v13 = 0;
LABEL_3:
    if (strings)
    {
      v14 = (const char **)strings;
      while (1)
      {
        v15 = *v14;
        if (!*v14)
          break;
        ++v14;
        if (!strcmp(v15, *(const char **)(a4 + 8 * v13)))
        {
          if (++v13 != v8)
            goto LABEL_3;
          krb5_config_free_strings(strings);
          return 0;
        }
      }
    }
    else
    {
      v13 = 0;
    }
    v8 = 2529638955;
    krb5_config_free_strings(strings);
    krb5_set_error_message(a1, -1765328341, "no transit allowed through realm %s", *(const char **)(a4 + 8 * v13));
    if (a6)
      *a6 = v13;
  }
  return v8;
}

uint64_t krb5_check_transited_realms(_krb5_context *a1, uint64_t a2, uint64_t a3, _DWORD *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v9;
  void **strings;
  void **v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  const char *v16;
  const char *v17;
  const char **v18;
  const char *v19;

  v9 = a3;
  strings = (void **)krb5_config_get_strings((uint64_t)a1, 0, a3, (uint64_t)a4, a5, a6, a7, a8, (uint64_t)"libdefaults");
  if (!strings)
    return 0;
  v12 = strings;
  v13 = 0;
  if (v9)
  {
    v14 = 0;
    v15 = v9;
    do
    {
      v16 = (const char *)*v12;
      if (*v12)
      {
        v17 = *(const char **)(a2 + 8 * v14);
        v18 = (const char **)(v12 + 1);
        while (strcmp(v16, v17))
        {
          v19 = *v18++;
          v16 = v19;
          if (!v19)
            goto LABEL_11;
        }
        krb5_set_error_message(a1, -1765328341, "no transit allowed through realm %s", v16);
        v13 = 2529638955;
        if (a4)
          *a4 = v14;
      }
LABEL_11:
      ++v14;
    }
    while (v14 != v15);
  }
  krb5_config_free_strings(v12);
  return v13;
}

_BYTE *sub_2096B3274(unsigned __int8 *a1)
{
  _BYTE *v2;
  _BYTE *v3;
  int v4;
  int v5;
  unsigned __int8 *v6;
  unsigned __int8 *v7;
  int v8;
  int v9;

  v2 = malloc_type_calloc(1uLL, 0x18uLL, 0x10300401532B4FEuLL);
  v3 = v2;
  if (v2)
  {
    *(_QWORD *)v2 = a1;
    v4 = *a1;
    if (*a1)
    {
      v5 = 0;
      v6 = a1;
      do
      {
        v7 = *(unsigned __int8 **)v2;
        if (v4 == 32 && v6 == v7)
        {
          v2[8] |= 1u;
        }
        else
        {
          if (v4 == 47 && a1 == v7)
            v2[8] |= 2u;
          v8 = *v6;
          if (v5)
            goto LABEL_17;
          if (v8 != 92)
          {
            if (v8 == 46)
            {
              if (v6[1])
              {
                LOBYTE(v8) = 46;
              }
              else
              {
                v2[8] |= 4u;
                LOBYTE(v8) = *v6;
              }
            }
LABEL_17:
            v5 = 0;
            *a1++ = v8;
            goto LABEL_18;
          }
          v5 = 1;
        }
LABEL_18:
        v9 = *++v6;
        v4 = v9;
      }
      while (v9);
    }
    *a1 = 0;
  }
  else
  {
    free(a1);
  }
  return v3;
}

void sub_2096B336C(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;

  if (a1)
  {
    v1 = a1;
    do
    {
      v2 = *(_QWORD *)(v1 + 16);
      free(*(void **)v1);
      free((void *)v1);
      v1 = v2;
    }
    while (v2);
  }
}

void krb5_verify_init_creds_opt_init(krb5_verify_init_creds_opt *k5_vic_options)
{
  *k5_vic_options = 0;
  k5_vic_options[1] = 0;
}

void krb5_verify_init_creds_opt_set_ap_req_nofail(krb5_verify_init_creds_opt *k5_vic_options, int ap_req_nofail)
{
  k5_vic_options->flags |= 1u;
  k5_vic_options->ap_req_nofail = ap_req_nofail;
}

uint64_t sub_2096B33C0(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 8) = a2;
  return result;
}

krb5_error_code krb5_verify_init_creds(krb5_context context, krb5_creds *creds, krb5_principal ap_req_server, krb5_keytab ap_req_keytab, krb5_ccache *ccache, krb5_verify_init_creds_opt *k5_vic_options)
{
  const char *v12;
  krb5_error_code v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  krb5_error_code v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  krb5_error_code credentials;
  _BYTE v30[128];
  __int128 v31;
  krb5_keytab v32;
  krb5_principal v33;
  krb5_auth_context v34;
  krb5_creds *v35;
  krb5_ccache id;
  krb5_data v37;

  v35 = 0;
  id = 0;
  v33 = 0;
  v34 = 0;
  v12 = "host";
  v32 = 0;
  if (k5_vic_options && *(_QWORD *)&k5_vic_options[1])
    v12 = (const char *)k5_vic_options[1];
  *(_QWORD *)&v37.magic = 0;
  v37.data = 0;
  krb5_data_zero(&v37);
  if (ap_req_server)
  {
    v33 = ap_req_server;
  }
  else
  {
    v21 = krb5_sname_to_principal(context, 0, v12, 3, &v33);
    if (v21)
    {
      v13 = v21;
      if (sub_2096B3684((uint64_t)context, (uint64_t)k5_vic_options, v22, v23, v24, v25, v26, v27))
        v13 = 0;
      goto LABEL_29;
    }
  }
  if (ap_req_keytab)
  {
    v32 = ap_req_keytab;
  }
  else
  {
    v13 = krb5_kt_default(context, &v32);
    if (v13)
      goto LABEL_29;
  }
  if (ccache && *ccache)
  {
    id = *ccache;
  }
  else
  {
    v13 = krb5_cc_new_unique(context, krb5_cc_type_memory[0], 0, &id);
    if (v13)
      goto LABEL_29;
    v13 = krb5_cc_initialize(context, id, *(krb5_principal *)&creds->magic);
    if (v13)
      goto LABEL_29;
    v13 = krb5_cc_store_cred(context, id, creds);
    if (v13)
      goto LABEL_29;
  }
  if (!krb5_principal_compare(context, v33, creds->client))
  {
    v31 = 0u;
    memset(&v30[16], 0, 112);
    *(_QWORD *)v30 = *(_QWORD *)&creds->magic;
    *(_QWORD *)&v30[8] = v33;
    credentials = krb5_get_credentials(context, 0, id, (krb5_creds *)v30, &v35);
    if (credentials)
    {
      v14 = credentials;
LABEL_26:
      if (sub_2096B3684((uint64_t)context, (uint64_t)k5_vic_options, v15, v16, v17, v18, v19, v20))
        v13 = 0;
      else
        v13 = v14;
      goto LABEL_29;
    }
    creds = v35;
  }
  v13 = krb5_mk_req_extended(context, &v34, 0, 0, creds, &v37);
  krb5_auth_con_free(context, v34);
  v34 = 0;
  if (v13)
    goto LABEL_31;
  v14 = -1765328203;
  v13 = krb5_rd_req(context, &v34, &v37, v33, v32, 0, 0);
  if (v13 == -1765328203)
    goto LABEL_26;
LABEL_29:
  if (v34)
    krb5_auth_con_free(context, v34);
LABEL_31:
  krb5_data_free(&v37);
  if (v35)
    krb5_free_creds(context, v35);
  if (!ap_req_server && v33)
    krb5_free_principal(context, v33);
  if (!ap_req_keytab && v32)
    krb5_kt_close(context, v32);
  if (!id)
    goto LABEL_44;
  if (!ccache)
    goto LABEL_43;
  if (v13)
  {
    if (*ccache)
      return v13;
LABEL_43:
    krb5_cc_destroy(context, id);
  }
LABEL_44:
  if (ccache && !v13 && !*ccache)
    *ccache = id;
  return v13;
}

BOOL sub_2096B3684(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return ((*(_BYTE *)a2 & 1) == 0 || !*(_DWORD *)(a2 + 4))
      && !krb5_config_get_BOOL(a1, 0, a3, a4, a5, a6, a7, a8, (uint64_t)"libdefaults");
}

krb5_error_code krb5_get_validated_creds(krb5_context context, krb5_creds *creds, krb5_principal client, krb5_ccache ccache, char *in_tkt_service)
{
  krb5_error_code inited;
  krb5_principal ap_req_server;
  krb5_verify_init_creds_opt k5_vic_options;
  uint64_t v12;

  if (krb5_principal_compare(context, *(krb5_const_principal *)&creds->magic, client) == 1)
  {
    ap_req_server = 0;
    inited = krb5_sname_to_principal(context, 0, in_tkt_service, 3, &ap_req_server);
    if (!inited)
    {
      k5_vic_options = 0;
      v12 = 0;
      inited = krb5_verify_init_creds(context, creds, ap_req_server, 0, 0, &k5_vic_options);
      krb5_free_principal(context, ap_req_server);
    }
  }
  else
  {
    inited = -1765328238;
    krb5_set_error_message(context, -1765328238, "Validation credentials and client doesn't match");
  }
  return inited;
}

double krb5_verify_opt_init(uint64_t a1)
{
  double result;

  result = 0.0;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 24) = 1;
  *(_QWORD *)(a1 + 32) = "host";
  *(_QWORD *)(a1 + 48) = krb5_prompter_posix;
  return result;
}

uint64_t krb5_verify_opt_alloc(_krb5_context *a1, _QWORD *a2)
{
  _OWORD *v4;
  uint64_t v5;

  v4 = malloc_type_calloc(1uLL, 0x40uLL, 0x10F0040986054B4uLL);
  *a2 = v4;
  if (v4)
  {
    v5 = 0;
    v4[2] = 0u;
    v4[3] = 0u;
    *v4 = 0u;
    v4[1] = 0u;
    *((_DWORD *)v4 + 6) = 1;
    *((_QWORD *)v4 + 4) = "host";
    *((_QWORD *)v4 + 6) = krb5_prompter_posix;
  }
  else
  {
    v5 = 12;
    krb5_set_error_message(a1, 12, "malloc: out of memory");
  }
  return v5;
}

uint64_t krb5_verify_opt_set_ccache(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 8) = a2;
  return result;
}

uint64_t krb5_verify_opt_set_server(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = a2;
  return result;
}

uint64_t krb5_verify_opt_set_keytab(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 16) = a2;
  return result;
}

uint64_t krb5_verify_opt_set_secure(uint64_t result, int a2)
{
  *(_DWORD *)(result + 24) = a2;
  return result;
}

uint64_t krb5_verify_opt_set_service(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 32) = a2;
  return result;
}

_DWORD *krb5_verify_opt_set_flags(_DWORD *result, int a2)
{
  *result |= a2;
  return result;
}

uint64_t krb5_verify_opt_set_prompter(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 48) = a2;
  *(_QWORD *)(result + 56) = a3;
  return result;
}

uint64_t krb5_verify_user_opt(_krb5_context *a1, krb5_principal_data *a2, char *a3, _BYTE *a4)
{
  uint64_t default_realms;
  char *v10;
  char **v11;
  uint64_t v12;
  char *v13;
  char **v15;

  if (!a4 || (*a4 & 1) == 0)
    return sub_2096B39A4(a1, a2, a3, (uint64_t)a4);
  v15 = 0;
  default_realms = krb5_get_default_realms((CFArrayRef *)a1, (char *const **)&v15);
  if (!(_DWORD)default_realms)
  {
    v10 = *v15;
    if (*v15)
    {
      v11 = v15 + 1;
      do
      {
        v12 = krb5_principal_set_realm(a1, (uint64_t)a2, v10);
        if ((_DWORD)v12)
          break;
        v12 = sub_2096B39A4(a1, a2, a3, (uint64_t)a4);
        v13 = *v11++;
        v10 = v13;
      }
      while (v13 && (_DWORD)v12 != 0);
      default_realms = v12;
      krb5_free_host_realm(a1, v15);
    }
    else
    {
      krb5_free_host_realm(a1, v15);
      return 2529639136;
    }
  }
  return default_realms;
}

uint64_t sub_2096B39A4(_krb5_context *a1, krb5_principal_data *a2, char *a3, uint64_t a4)
{
  uint64_t init_creds_opt_alloc;
  const krb5_data *realm;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  _krb5_kt *v14;
  _krb5_ccache *v15;
  int v16;
  krb5_principal_data *v17;
  const char *v18;
  _krb5_ccache *v19;
  _BYTE creds[144];
  krb5_get_init_creds_opt *opt;
  krb5_ccache v23;
  krb5_verify_init_creds_opt k5_vic_options;
  uint64_t v25;

  opt = 0;
  memset(creds, 0, sizeof(creds));
  init_creds_opt_alloc = krb5_get_init_creds_opt_alloc(a1, &opt);
  if (!(_DWORD)init_creds_opt_alloc)
  {
    realm = (const krb5_data *)krb5_principal_get_realm((uint64_t)a1, (uint64_t)a2);
    krb5_get_init_creds_opt_set_default_flags(a1, 0, realm, (uint64_t)opt, v10, v11, v12, v13);
    init_creds_opt_alloc = krb5_get_init_creds_password(a1, (krb5_creds *)creds, a2, a3, *(krb5_prompter_fct *)(a4 + 48), *(void **)(a4 + 56), 0, 0, opt);
    if ((_DWORD)init_creds_opt_alloc)
    {
LABEL_15:
      krb5_get_init_creds_opt_free(a1, opt);
      return init_creds_opt_alloc;
    }
    v15 = *(_krb5_ccache **)(a4 + 8);
    v14 = *(_krb5_kt **)(a4 + 16);
    v16 = *(_DWORD *)(a4 + 24);
    v17 = *(krb5_principal_data **)(a4 + 40);
    if (*(_QWORD *)(a4 + 32))
      v18 = *(const char **)(a4 + 32);
    else
      v18 = "host";
    k5_vic_options = 0;
    v25 = 0;
    v23 = 0;
    krb5_verify_init_creds_opt_init(&k5_vic_options);
    krb5_verify_init_creds_opt_set_ap_req_nofail(&k5_vic_options, v16);
    sub_2096B33C0((uint64_t)&k5_vic_options, (uint64_t)v18);
    init_creds_opt_alloc = krb5_verify_init_creds(a1, (krb5_creds *)creds, v17, v14, 0, &k5_vic_options);
    if (!(_DWORD)init_creds_opt_alloc)
    {
      if (v15)
      {
        v23 = v15;
        v19 = v15;
LABEL_9:
        init_creds_opt_alloc = krb5_cc_initialize(a1, v19, a2);
        if (!(_DWORD)init_creds_opt_alloc)
          init_creds_opt_alloc = krb5_cc_store_cred(a1, v23, (krb5_creds *)creds);
        if (!v15)
          krb5_cc_close(a1, v23);
        goto LABEL_14;
      }
      init_creds_opt_alloc = krb5_cc_default(a1, &v23);
      if (!(_DWORD)init_creds_opt_alloc)
      {
        v19 = v23;
        goto LABEL_9;
      }
    }
LABEL_14:
    krb5_free_cred_contents(a1, (krb5_creds *)creds);
    goto LABEL_15;
  }
  return init_creds_opt_alloc;
}

uint64_t krb5_verify_user(_krb5_context *a1, krb5_principal_data *a2, uint64_t a3, char *a4, int a5, unint64_t a6)
{
  _QWORD v7[2];
  __int128 v8;
  __int128 v9;
  krb5_error_code (__cdecl *v10)(krb5_context, void *, const char *, const char *, int, krb5_prompt[]);
  uint64_t v11;

  v7[0] = 0;
  v8 = 0u;
  v11 = 0;
  v7[1] = a3;
  DWORD2(v8) = a5;
  v10 = krb5_prompter_posix;
  v9 = a6;
  return krb5_verify_user_opt(a1, a2, a4, v7);
}

uint64_t krb5_verify_user_lrealm(_krb5_context *a1, krb5_principal_data *a2, uint64_t a3, char *a4, int a5, unint64_t a6)
{
  _QWORD v7[2];
  __int128 v8;
  __int128 v9;
  krb5_error_code (__cdecl *v10)(krb5_context, void *, const char *, const char *, int, krb5_prompt[]);
  uint64_t v11;

  v8 = 0u;
  v11 = 0;
  v7[1] = a3;
  DWORD2(v8) = a5;
  v10 = krb5_prompter_posix;
  v9 = a6;
  v7[0] = 1;
  return krb5_verify_user_opt(a1, a2, a4, v7);
}

uint64_t krb5_vwarn(_krb5_context *a1, krb5_error_code a2, const char *a3, va_list a4)
{
  return sub_2096B3C0C(a1, 1, a2, 1, 0, a3, a4);
}

uint64_t sub_2096B3C0C(_krb5_context *a1, int a2, krb5_error_code a3, int a4, void (*a5)(char *), const char *a6, va_list a7)
{
  int v14;
  uint64_t result;
  char **v16;
  const char *v17;
  const char *error_message;
  const char *v19;
  uint64_t v20;
  char *v21;
  uint64_t v22;
  char *v23;
  uint64_t v24;
  char *v25;
  char v26[8];

  *(_DWORD *)&v26[3] = 0;
  *(_DWORD *)v26 = 0;
  v23 = 0;
  v24 = 0;
  v25 = 0;
  if (!a6)
  {
    v16 = &v25;
    goto LABEL_8;
  }
  __strlcat_chk();
  if (a2)
    __strlcat_chk();
  v14 = vasprintf(&v23, a6, a7);
  result = 12;
  if ((v14 & 0x80000000) == 0 && v23)
  {
    v25 = v23;
    v16 = (char **)&v24;
LABEL_8:
    v17 = 0;
    if (a1 && a2)
    {
      __strlcat_chk();
      error_message = krb5_get_error_message(a1, a3);
      v17 = error_message;
      v19 = "<unknown error>";
      if (error_message)
        v19 = error_message;
      *v16 = (char *)v19;
    }
    if (a5)
    {
      a5(v26);
LABEL_18:
      free(v23);
      krb5_free_error_message(a1, v17);
      return 0;
    }
    if (a1)
    {
      v20 = *((_QWORD *)a1 + 19);
      v22 = v24;
      v21 = v25;
      if (v20)
      {
        krb5_log((uint64_t)a1, v20, a4, v26, v25, v24);
        goto LABEL_18;
      }
    }
    else
    {
      v22 = v24;
      v21 = v25;
    }
    warnx(v26, v21, v22);
    goto LABEL_18;
  }
  return result;
}

uint64_t krb5_warn(_krb5_context *a1, krb5_error_code a2, const char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  return sub_2096B3C0C(a1, 1, a2, 1, 0, a3, &a9);
}

uint64_t krb5_vwarnx(_krb5_context *a1, const char *a2, va_list a3)
{
  return sub_2096B3C0C(a1, 0, 0, 1, 0, a2, a3);
}

uint64_t krb5_warnx(_krb5_context *a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  return sub_2096B3C0C(a1, 0, 0, 1, 0, a2, &a9);
}

void krb5_verr(_krb5_context *a1, int a2, krb5_error_code a3, const char *a4, va_list a5)
{
  sub_2096B3C0C(a1, 1, a3, 0, 0, a4, a5);
  exit(a2);
}

void krb5_err(_krb5_context *a1, int a2, krb5_error_code a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  sub_2096B3C0C(a1, 1, a3, 0, 0, a4, &a9);
  exit(a2);
}

void krb5_verrx(_krb5_context *a1, int a2, const char *a3, va_list a4)
{
  sub_2096B3C0C(a1, 0, 0, 0, 0, a3, a4);
  exit(a2);
}

void krb5_errx(_krb5_context *a1, int a2, const char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  sub_2096B3C0C(a1, 0, 0, 0, 0, a3, &a9);
  exit(a2);
}

void krb5_vabort(_krb5_context *a1, krb5_error_code a2, const char *a3, va_list a4)
{
  sub_2096B3C0C(a1, 1, a2, 0, 0, a3, a4);
  abort();
}

void krb5_abort(_krb5_context *a1, krb5_error_code a2, const char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  sub_2096B3C0C(a1, 1, a2, 0, (void (*)(char *))heim_abort, a3, &a9);
  abort();
}

void krb5_vabortx(_krb5_context *a1, const char *a2, va_list a3)
{
  sub_2096B3C0C(a1, 0, 0, 0, (void (*)(char *))heim_abort, a2, a3);
  abort();
}

void krb5_abortx(_krb5_context *a1, const char *a2, ...)
{
  va_list va;

  va_start(va, a2);
  sub_2096B3C0C(a1, 0, 0, 0, 0, a2, va);
  abort();
}

uint64_t krb5_set_warn_dest(uint64_t a1, uint64_t a2)
{
  uint64_t v4;

  v4 = *(_QWORD *)(a1 + 152);
  if (v4)
    krb5_closelog(a1, v4);
  *(_QWORD *)(a1 + 152) = a2;
  return 0;
}

uint64_t krb5_get_warn_dest(uint64_t a1)
{
  return *(_QWORD *)(a1 + 152);
}

uint64_t krb5_set_debug_dest(uint64_t a1, uint64_t a2)
{
  uint64_t v4;

  v4 = *(_QWORD *)(a1 + 160);
  if (v4)
    krb5_closelog(a1, v4);
  *(_QWORD *)(a1 + 160) = a2;
  return 0;
}

uint64_t krb5_get_debug_dest(uint64_t a1)
{
  return *(_QWORD *)(a1 + 160);
}

uint64_t krb5_write_message(_krb5_context *a1, int *a2, char **a3)
{
  unint64_t v6;
  uint64_t v7;
  int *v8;
  char *v9;
  char __buf[4];

  v6 = *(unsigned int *)a3;
  _krb5_put_int((uint64_t)__buf, v6, 4);
  if (krb5_net_write((int)a1, a2, __buf, 4uLL) == 4 && krb5_net_write((int)a1, a2, a3[1], v6) == v6)
    return 0;
  v8 = __error();
  v7 = *v8;
  v9 = strerror(*v8);
  krb5_set_error_message(a1, v7, "write: %s", v9);
  return v7;
}

uint64_t krb5_write_priv_message(_krb5_context *a1, _krb5_auth_context *a2, int *a3, krb5_data *a4)
{
  uint64_t v6;
  krb5_data v8;

  *(_QWORD *)&v8.magic = 0;
  v8.data = 0;
  v6 = krb5_mk_priv(a1, a2, a4, &v8, 0);
  if (!(_DWORD)v6)
  {
    v6 = krb5_write_message(a1, a3, (char **)&v8);
    krb5_data_free(&v8);
  }
  return v6;
}

uint64_t krb5_write_safe_message(_krb5_context *a1, _krb5_auth_context *a2, int *a3, krb5_data *a4)
{
  uint64_t v6;
  krb5_data v8;

  *(_QWORD *)&v8.magic = 0;
  v8.data = 0;
  v6 = krb5_mk_safe(a1, a2, a4, &v8, 0);
  if (!(_DWORD)v6)
  {
    v6 = krb5_write_message(a1, a3, (char **)&v8);
    krb5_data_free(&v8);
  }
  return v6;
}

uint64_t _krb5_expand_default_cc_name_0(_krb5_context *a1, char *__s1, void **a3)
{
  uint64_t v4;
  uint64_t v5;
  char *v6;
  uint64_t v7;
  char *v8;
  char *v9;
  char *v10;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  void *v16;
  size_t v17;
  char *v18;
  _krb5_context *v19;
  char *__s;

  if (!__s1 || (v4 = (uint64_t)__s1, !*__s1))
  {
    v4 = 0;
    *a3 = strdup("");
    return v4;
  }
  __s = 0;
  v5 = 0;
  *a3 = 0;
  while (1)
  {
    if (!*(_BYTE *)v4)
      return 0;
    v6 = strstr((char *)v4, "%{");
    v7 = (uint64_t)v6;
    if (!v6)
      break;
    v8 = &v6[-v4];
    if (v6 == (char *)v4)
      break;
    v9 = (char *)malloc_type_malloc((size_t)(v8 + 1), 0x6366017CuLL);
    __s = v9;
    if (!v9)
    {
      v16 = *a3;
LABEL_39:
      if (v16)
        free(v16);
      *a3 = 0;
      if (a1)
      {
        v4 = 12;
        v19 = a1;
        goto LABEL_43;
      }
      return 12;
    }
    memcpy(v9, (const void *)v4, v7 - v4);
    v8[(_QWORD)__s] = 0;
LABEL_22:
    v14 = __s;
    v4 = v7;
LABEL_23:
    v16 = *a3;
    if (!v14)
      goto LABEL_39;
    v17 = strlen(v14);
    v18 = (char *)malloc_type_realloc(v16, v17 + v5 + 1, 0x354F9AA8uLL);
    if (!v18)
    {
      free(__s);
      if (*a3)
        free(*a3);
      *a3 = 0;
      v19 = a1;
      if (a1)
      {
        v4 = 12;
LABEL_43:
        krb5_set_error_message(v19, 12, "malloc - out of memory");
        return v4;
      }
      return 12;
    }
    *a3 = v18;
    memcpy(&v18[v5], __s, v17 + 1);
    free(__s);
    v5 += v17;
    if (!v4)
      return v4;
  }
  if (!v6)
  {
    v14 = strdup((const char *)v4);
    v4 = 0;
    __s = v14;
    goto LABEL_23;
  }
  v10 = strchr(v6, 125);
  if (v10)
  {
    v11 = v10;
    v12 = (uint64_t)&v10[-v7];
    __s = 0;
    if (*(_BYTE *)v7 != 37 || *(_BYTE *)(v7 + 1) != 123 || v12 < 3 || *v10 != 125)
    {
LABEL_28:
      v4 = 22;
      if (a1)
        krb5_set_error_message(a1, 22, "Invalid token: %.*s", v12, (const char *)v7);
      goto LABEL_30;
    }
    v13 = 0;
    while (strncmp((const char *)(v7 + 2), (&off_24C1F1D00)[v13], v12 - 2))
    {
      v13 += 4;
      if (v13 == 44)
        goto LABEL_28;
    }
    v15 = ((uint64_t (*)(_krb5_context *, _QWORD, char *, char **))(&off_24C1F1D00)[v13 + 3])(a1, 0, (&off_24C1F1D00)[v13 + 2], &__s);
    if ((_DWORD)v15)
    {
      v4 = v15;
LABEL_30:
      if (*a3)
        free(*a3);
      *a3 = 0;
      return v4;
    }
    v7 = (uint64_t)(v11 + 1);
    goto LABEL_22;
  }
  if (*a3)
    free(*a3);
  *a3 = 0;
  v4 = 22;
  if (a1)
    krb5_set_error_message(a1, 22, "variable missing }");
  return v4;
}

uint64_t sub_2096B44AC(uint64_t a1, uint64_t a2, uint64_t a3, char **a4)
{
  uint64_t v5;
  __CFBundle *MainBundle;
  __CFBundle *v7;
  const __CFDictionary *InfoDictionary;
  const __CFURL *v9;
  const __CFURL *v10;
  int v11;
  char *v12;
  UInt8 buffer[1024];
  uint64_t v15;

  v15 = *MEMORY[0x24BDAC8D0];
  v5 = 2529639048;
  MainBundle = CFBundleGetMainBundle();
  if (MainBundle)
  {
    v7 = MainBundle;
    InfoDictionary = CFBundleGetInfoDictionary(MainBundle);
    if (InfoDictionary)
    {
      if (CFDictionaryGetCount(InfoDictionary))
      {
        v9 = CFBundleCopyResourcesDirectoryURL(v7);
        if (v9)
        {
          v10 = v9;
          v11 = CFURLGetFileSystemRepresentation(v9, 1u, buffer, 1024);
          CFRelease(v10);
          v5 = 12;
          if (v11)
          {
            v12 = strdup((const char *)buffer);
            *a4 = v12;
            if (v12)
              return 0;
            else
              return 12;
          }
        }
      }
    }
  }
  return v5;
}

uint64_t sub_2096B457C(int a1, int a2, char *a3, char **a4)
{
  char *v5;
  char *v6;

  v5 = getenv(a3);
  if (!v5)
    v5 = "";
  v6 = strdup(v5);
  *a4 = v6;
  if (v6)
    return 0;
  else
    return 12;
}

uint64_t sub_2096B45C0(_krb5_context *a1, int a2, char *__s1, char **a4)
{
  char *v6;
  uint64_t v7;

  v6 = strdup(__s1);
  *a4 = v6;
  if (v6)
    return 0;
  v7 = 12;
  krb5_set_error_message(a1, 12, "malloc - out of memory");
  return v7;
}

uint64_t sub_2096B4614(uint64_t a1, uint64_t a2, uint64_t a3, char **a4)
{
  char *v5;
  char *v6;

  if (issuid() || (v5 = getenv("TEMP")) == 0)
    v5 = "/tmp";
  v6 = strdup(v5);
  *a4 = v6;
  if (v6)
    return 0;
  else
    return 12;
}

uint64_t sub_2096B4664(uint64_t a1, uint64_t a2, uint64_t a3, char **a4)
{
  uid_t v5;
  int v6;
  uint64_t result;

  v5 = getuid();
  v6 = asprintf(a4, "%ld", v5);
  result = 12;
  if ((v6 & 0x80000000) == 0)
  {
    if (*a4)
      return 0;
    else
      return 12;
  }
  return result;
}

uint64_t sub_2096B46BC(_krb5_context *a1, uint64_t a2, uint64_t a3, char **a4)
{
  uint64_t v6;
  auditinfo_addr v8;

  memset(&v8, 0, sizeof(v8));
  if (getaudit_addr(&v8, 48))
  {
    if (asprintf(a4, "%ld", v8.ai_asid) < 0 || !*a4)
      return krb5_enomem(a1);
    else
      return 0;
  }
  else
  {
    v6 = *__error();
    krb5_set_error_message(a1, v6, "cant get audit information for the session");
  }
  return v6;
}

uint64_t sub_2096B475C(_krb5_context *a1, uint64_t a2, uint64_t a3, char **a4)
{
  char *v6;
  uint64_t v7;

  v6 = strdup("");
  *a4 = v6;
  if (v6)
    return 0;
  v7 = 12;
  if (a1)
    krb5_set_error_message(a1, 12, "Out of memory");
  return v7;
}

uint64_t sub_2096B47C0(_krb5_context *a1, _QWORD *a2, void *dataOut, size_t size, int a5, uint64_t a6, const void *a7)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  _CCCryptor *v19;
  char *v20;
  char *v21;
  const void *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  size_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  char dataOuta;
  char dataOutb;
  size_t dataOutMoved;

  v7 = *(_QWORD *)(a2[1] + 8);
  dataOutMoved = 0;
  if (size > 0xF)
  {
    if (size == 16)
    {
      if (CCCrypt(a5 == 0, *(_DWORD *)(*(_QWORD *)(v7 + 16) + 80), 0, *(const void **)(*a2 + 16), *(_QWORD *)(*a2 + 8), 0, dataOut, 0x10uLL, dataOut, 0x10uLL, &dataOutMoved))
      {
        heim_abort("CCCrypt failed:s == 0", v11, v12, v13, v14, v15, v16, v17, dataOutb);
      }
      if (dataOutMoved != 16)
        heim_abort("moved == len:moved == len", v11, v12, v13, v14, v15, v16, v17, dataOutb);
    }
    else
    {
      v19 = *(_CCCryptor **)(v7 + 8 * (a5 == 0));
      v20 = (char *)malloc_type_malloc(size, 0xE680274DuLL);
      if (!v20)
        return 12;
      v21 = v20;
      if (a7)
        v22 = a7;
      else
        v22 = &unk_2096D94F8;
      CCCryptorReset(v19, v22);
      if (CCCryptorUpdate(v19, dataOut, size, v21, size, &dataOutMoved))
        heim_abort("CCCryptorUpdate failed:s == 0", v23, v24, v25, v26, v27, v28, v29, dataOuta);
      v30 = size - dataOutMoved;
      if (CCCryptorFinal(v19, &v21[dataOutMoved], size - dataOutMoved, &dataOutMoved))
        heim_abort("CCCryptorFinal failed:s == 0", v31, v32, v33, v34, v35, v36, v37, dataOuta);
      if (v30 != dataOutMoved)
        heim_abort("plen == 0:plen == 0", v31, v32, v33, v34, v35, v36, v37, dataOuta);
      memcpy(dataOut, v21, size);
      free(v21);
    }
    return 0;
  }
  else
  {
    v8 = 22;
    krb5_set_error_message(a1, 22, "message block too short");
  }
  return v8;
}

uint64_t sub_2096B496C(_krb5_context *a1, const krb5_keyblock **a2, _QWORD *a3, size_t *a4)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  const krb5_keyblock *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  size_t contents;
  size_t v20;
  krb5_octet *v21;
  CCAlgorithm v22;
  krb5_octet *v23;
  size_t v24;
  void *v25;
  char dataOut;
  size_t dataOutMoved;
  krb5_keyblock *v29;
  uint64_t v30;
  size_t v31;
  void *dataIn;

  v8 = *(_QWORD *)&(*a2)[2].magic;
  v30 = 0;
  v31 = 0;
  dataIn = 0;
  LODWORD(v30) = *(_DWORD *)v8;
  v9 = krb5_data_alloc(&v31, *(_QWORD *)(v8 + 24));
  if ((_DWORD)v9)
  {
    v10 = v9;
    krb5_set_error_message(a1, v9, "malloc: out memory");
  }
  else
  {
    v11 = (*(uint64_t (**)(_krb5_context *, _QWORD, _QWORD, _QWORD, _QWORD, uint64_t *))(v8 + 40))(a1, 0, a3[1], *a3, 0, &v30);
    if ((_DWORD)v11)
    {
      v10 = v11;
      krb5_data_free(&v31);
    }
    else
    {
      v12 = *a2;
      if ((krb5_octet *)v31 < (*a2)->contents)
        krb5_abortx(a1, "internal prf error");
      v29 = 0;
      if (krb5_derive_key(a1, a2[1], (krb5_keyblock *)v12->magic, "prf", 3uLL, &v29))
        krb5_abortx(a1, "krb5_derive_key");
      contents = (size_t)(*a2)->contents;
      v20 = v31 / contents * contents;
      if (v20 != *(_QWORD *)&(*a2)[3].length)
        heim_abort("prfsize not same ?:prfsize == crypto->et->prf_length", contents, v13, v14, v15, v16, v17, v18, dataOut);
      if (krb5_data_alloc(a4, contents))
        krb5_abortx(a1, "malloc failed");
      v21 = (*a2)[1].contents;
      v22 = *((_DWORD *)v21 + 20);
      v23 = v29->contents;
      v24 = *((_QWORD *)v21 + 3);
      v25 = (void *)a4[1];
      dataOutMoved = 0;
      if (CCCrypt(0, v22, 0, v23, v24, 0, dataIn, v20, v25, v20, &dataOutMoved) || dataOutMoved != v20)
        krb5_abortx(a1, "encrypt failed");
      krb5_data_free(&v31);
      krb5_free_keyblock(a1, v29);
      return 0;
    }
  }
  return v10;
}

uint64_t sub_2096B4B40(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  uint64_t v4;
  uint64_t cryptorRef;
  CCAlgorithm v6;
  uint64_t result;

  v4 = *a3;
  cryptorRef = *(_QWORD *)(a3[1] + 8);
  v6 = *(_DWORD *)(a2 + 80);
  *(_QWORD *)(cryptorRef + 16) = a2;
  if (CCCryptorCreateWithMode(0, 2u, v6, 0xCu, 0, *(const void **)(v4 + 16), *(_QWORD *)(v4 + 8), 0, 0, 0, 0, (CCCryptorRef *)cryptorRef)|| (result = CCCryptorCreateWithMode(1u, 2u, v6, 0xCu, 0, *(const void **)(*a3 + 16),
                   *(_QWORD *)(*a3 + 8),
                   0,
                   0,
                   0,
                   0,
                   (CCCryptorRef *)(cryptorRef + 8)),
        (_DWORD)result))
  {
    abort();
  }
  return result;
}

uint64_t sub_2096B4BE0(uint64_t a1, uint64_t a2)
{
  CCCryptorRef *v2;

  v2 = *(CCCryptorRef **)(*(_QWORD *)(a2 + 8) + 8);
  CCCryptorRelease(*v2);
  return CCCryptorRelease(v2[1]);
}

uint64_t sub_2096B4C0C(_krb5_context *a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  _DWORD *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v13;
  __int128 v14;
  uint64_t v15[2];
  _BYTE v16[24];
  char v17;
  _BYTE v18[16];
  char v19[16];
  uint64_t v20;

  v20 = *MEMORY[0x24BDAC8D0];
  v9 = sub_209683FE0(7);
  strcpy(v19, "signaturekey");
  if (CCDigestCreate())
  {
    v15[1] = 0;
    v13 = 0;
    *(_OWORD *)v16 = xmmword_2096D9520;
    *(_QWORD *)&v16[16] = &v17;
    v10 = sub_209683D50((uint64_t)a1, (uint64_t)v9, v19, 0xDuLL, 0, a2, (uint64_t)v16);
    if ((_DWORD)v10)
    {
      v11 = v10;
      CCDigestDestroy();
    }
    else
    {
      v15[0] = (uint64_t)&v13;
      v14 = *(_OWORD *)&v16[8];
      CCDigestUpdate();
      CCDigestUpdate();
      CCDigestFinal();
      CCDigestDestroy();
      return sub_209683D50((uint64_t)a1, (uint64_t)v9, v18, 0x10uLL, 0, v15, a6);
    }
  }
  else
  {
    v11 = 12;
    krb5_set_error_message(a1, 12, "malloc: out of memory");
  }
  return v11;
}

uint64_t sub_2096B4D98(uint64_t a1, int *a2)
{
  int v2;
  int v3;

  v2 = *a2;
  if (*a2 > 22)
  {
    if (v2 == 23)
    {
      v3 = 15;
      goto LABEL_10;
    }
    if (v2 == 24)
    {
      v3 = 0;
      goto LABEL_10;
    }
  }
  else
  {
    if (v2 == 3)
    {
      v3 = 8;
      goto LABEL_10;
    }
    if (v2 == 22)
    {
      v3 = 13;
LABEL_10:
      *a2 = v3;
    }
  }
  return 0;
}

uint64_t sub_2096B4DEC(_krb5_context *a1, uint64_t *a2, unsigned __int8 *a3, uint64_t a4, int a5, int a6)
{
  int v6;
  _DWORD *v11;
  uint64_t v12;
  void *v13;
  uint64_t result;
  _DWORD *v15;
  uint64_t v16;
  void *v17;
  int v18;
  uint64_t v19;
  __int128 v20;
  uint64_t *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unsigned __int8 *v25;
  uint64_t v26;
  uint64_t v27;
  int v28[2];
  _BYTE v29[24];
  _DWORD v30[4];
  _QWORD v31[2];
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  uint64_t v44;
  uint64_t v45;

  v6 = a6;
  v45 = *MEMORY[0x24BDAC8D0];
  if (a6 > 22)
  {
    if (a6 == 23)
    {
      v6 = 15;
    }
    else if (a6 == 24)
    {
      v6 = 0;
    }
  }
  else if (a6 == 3)
  {
    v6 = 8;
  }
  else if (a6 == 22)
  {
    v6 = 13;
  }
  if (a5)
  {
    v44 = 0;
    v42 = 0u;
    v43 = 0u;
    v40 = 0u;
    v41 = 0u;
    v38 = 0u;
    v39 = 0u;
    v36 = 0u;
    v37 = 0u;
    v34 = 0u;
    v35 = 0u;
    v11 = sub_209683FE0(7);
    v26 = 0;
    v27 = 0;
    *(_QWORD *)v28 = 0;
    v22 = 0;
    v23 = 0;
    v19 = 0;
    v30[0] = v6;
    *(_OWORD *)v29 = xmmword_2096D9520;
    *(_QWORD *)&v29[16] = &v33;
    if (!sub_209683D50(0, (uint64_t)v11, v30, 4uLL, 0, a2, (uint64_t)v29))
    {
      v32 = v33;
      *(_QWORD *)&v20 = 16;
      *((_QWORD *)&v20 + 1) = &v32;
      v21 = &v19;
      v24 = 16;
      v25 = a3;
      if (!sub_209683D50(0, (uint64_t)v11, a3 + 16, a4 - 16, 0, (uint64_t *)&v21, (uint64_t)&v23))
      {
        v21 = &v19;
        v20 = *(_OWORD *)&v29[8];
        v27 = 16;
        *(_QWORD *)v28 = v31;
        if (!sub_209683D50(0, (uint64_t)v11, a3, 0x10uLL, 0, (uint64_t *)&v21, (uint64_t)&v26))
        {
          hc_EVP_CIPHER_CTX_init((uint64_t)&v34);
          v13 = hc_EVP_rc4(v12);
          hc_EVP_CipherInit_ex((uint64_t)&v34, (uint64_t)v13, 0, *(uint64_t *)v28, 0, 1);
          hc_EVP_Cipher((uint64_t)&v34);
          hc_EVP_CIPHER_CTX_cleanup((uint64_t *)&v34);
          return 0;
        }
      }
    }
LABEL_21:
    krb5_abortx(a1, "hmac failed");
  }
  v44 = 0;
  v42 = 0u;
  v43 = 0u;
  v40 = 0u;
  v41 = 0u;
  v38 = 0u;
  v39 = 0u;
  v36 = 0u;
  v37 = 0u;
  v34 = 0u;
  v35 = 0u;
  v15 = sub_209683FE0(7);
  v26 = 0;
  v27 = 0;
  *(_QWORD *)v28 = 0;
  v23 = 0;
  v24 = 0;
  v25 = 0;
  v22 = 0;
  v19 = 0;
  v18 = v6;
  *(_OWORD *)v29 = xmmword_2096D9520;
  *(_QWORD *)&v29[16] = &v33;
  if (sub_209683D50(0, (uint64_t)v15, &v18, 4uLL, 0, a2, (uint64_t)v29))
    goto LABEL_21;
  v32 = v33;
  v21 = &v19;
  v20 = *(_OWORD *)&v29[8];
  v27 = 16;
  *(_QWORD *)v28 = v31;
  if (sub_209683D50(0, (uint64_t)v15, a3, 0x10uLL, 0, (uint64_t *)&v21, (uint64_t)&v26))
    goto LABEL_21;
  hc_EVP_CIPHER_CTX_init((uint64_t)&v34);
  v17 = hc_EVP_rc4(v16);
  hc_EVP_CipherInit_ex((uint64_t)&v34, (uint64_t)v17, 0, *(uint64_t *)v28, 0, 0);
  hc_EVP_Cipher((uint64_t)&v34);
  hc_EVP_CIPHER_CTX_cleanup((uint64_t *)&v34);
  *(_QWORD *)&v20 = 16;
  *((_QWORD *)&v20 + 1) = &v32;
  v21 = &v19;
  v24 = 16;
  v25 = (unsigned __int8 *)v30;
  if (sub_209683D50(0, (uint64_t)v15, a3 + 16, a4 - 16, 0, (uint64_t *)&v21, (uint64_t)&v23))
    goto LABEL_21;
  v33 = 0uLL;
  v32 = 0uLL;
  v31[0] = 0;
  v31[1] = 0;
  result = ct_memcmp(v25, a3, 16);
  if ((_DWORD)result)
  {
    krb5_clear_error_message(a1);
    return 2529638943;
  }
  return result;
}

uint64_t sub_2096B5190(uint64_t a1, uint64_t a2, uint64_t a3, size_t *a4)
{
  _DWORD *v8;
  uint64_t v9;
  size_t v10;
  _QWORD v12[3];

  v8 = sub_209683FE0(14);
  v9 = krb5_data_alloc(a4, *((_QWORD *)v8 + 3));
  if (!(_DWORD)v9)
  {
    v10 = a4[1];
    v12[1] = *a4;
    v12[2] = v10;
    v12[0] = 0;
    if (sub_209683D50(a1, (uint64_t)v8, *(const void **)(a3 + 8), *(_QWORD *)a3, 0, (uint64_t *)(a2 + 8), (uint64_t)v12))krb5_data_free(a4);
  }
  return v9;
}

_BYTE *sub_2096B5228(_BYTE *result, _BYTE *a2)
{
  *result ^= *a2;
  result[1] ^= a2[1];
  result[2] ^= a2[2];
  result[3] ^= a2[3];
  result[4] ^= a2[4];
  result[5] ^= a2[5];
  result[6] ^= a2[6];
  result[7] ^= a2[7];
  return result;
}

uint64_t sub_2096B52AC(_krb5_context *a1)
{
  uint64_t result;

  result = CCDigest();
  if ((_DWORD)result)
    krb5_abortx(a1, "md5 checksum failed");
  return result;
}

uint64_t sub_2096B52F4(_krb5_context *a1, const krb5_keyblock **a2, _QWORD *a3, size_t *a4)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  const krb5_keyblock *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  krb5_keyblock *v22;
  uint64_t v23;
  size_t v24[2];
  _OWORD v25[10];
  uint64_t v26;
  uint64_t v27;

  v27 = *MEMORY[0x24BDAC8D0];
  v8 = *(_QWORD *)&(*a2)[2].magic;
  v23 = 0;
  v24[0] = 0;
  v24[1] = 0;
  LODWORD(v23) = *(_DWORD *)v8;
  v9 = krb5_data_alloc(v24, *(_QWORD *)(v8 + 24));
  if ((_DWORD)v9)
  {
    v10 = v9;
    krb5_set_error_message(a1, v9, "malloc: out memory");
  }
  else
  {
    v11 = (*(uint64_t (**)(_krb5_context *, _QWORD, _QWORD, _QWORD, _QWORD, uint64_t *))(v8 + 40))(a1, 0, a3[1], *a3, 0, &v23);
    if ((_DWORD)v11)
    {
      v10 = v11;
      krb5_data_free(v24);
    }
    else
    {
      v12 = *a2;
      if ((krb5_octet *)v24[0] < (*a2)->contents)
        krb5_abortx(a1, "internal prf error");
      v22 = 0;
      if (krb5_derive_key(a1, a2[1], (krb5_keyblock *)v12->magic, "prf", 3uLL, &v22))
        krb5_abortx(a1, "krb5_derive_key");
      if (v24[0] / (size_t)(*a2)->contents * (size_t)(*a2)->contents != *(_QWORD *)&(*a2)[3].length)
        heim_abort("prfsize not same ?:prfsize == crypto->et->prf_length", v13, v14, v15, v16, v17, v18, v19, (char)v22);
      if (krb5_data_alloc(a4, v24[0] / (size_t)(*a2)->contents * (size_t)(*a2)->contents))
        krb5_abortx(a1, "malloc failed");
      v20 = (*((uint64_t (**)(void))(*a2)[1].contents + 10))();
      v26 = 0;
      memset(v25, 0, sizeof(v25));
      hc_EVP_CIPHER_CTX_init((uint64_t)v25);
      hc_EVP_CipherInit_ex((uint64_t)v25, v20, 0, (uint64_t)v22->contents, 0, 1);
      hc_EVP_Cipher((uint64_t)v25);
      hc_EVP_CIPHER_CTX_cleanup((uint64_t *)v25);
      krb5_data_free(v24);
      krb5_free_keyblock(a1, v22);
      return 0;
    }
  }
  return v10;
}

_BYTE *sub_2096B5514(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t i;
  char v10;
  uint64_t j;
  uint64_t v12;
  uint64_t v13;
  _BYTE *result;

  if (a4 <= 0x14)
    abort();
  bzero(*(void **)(a2 + 16), *(_QWORD *)(a2 + 8));
  v6 = 0;
  v7 = *(_QWORD *)(a2 + 16);
  v8 = v7;
  do
  {
    for (i = 0; i != 7; ++i)
      *(_BYTE *)(v8 + i) = *(_BYTE *)(a3 + i);
    v10 = 0;
    for (j = 6; j != -1; --j)
      v10 = 2 * (*(_BYTE *)(a3 + j) & 1 | v10);
    *(_BYTE *)(v7 + ((8 * v6++) | 7)) = v10;
    v8 += 8;
    a3 += 7;
  }
  while (v6 != 3);
  v12 = 0;
  v13 = *(_QWORD *)(a2 + 16);
  do
  {
    MEMORY[0x20BD1173C](v13 + v12, 8);
    result = (_BYTE *)MEMORY[0x20BD11730](v13 + v12, 8);
    if ((_DWORD)result)
      result = sub_2096B5228((_BYTE *)(v13 + v12), byte_2096D9530);
    v12 += 8;
  }
  while (v12 != 24);
  return result;
}

uint64_t sub_2096B5600(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t i;
  uint64_t result;

  v3 = *(_QWORD *)(a2 + 16);
  for (i = v3; ; i = *(_QWORD *)(a2 + 16))
  {
    krb5_generate_random_block(i, *(_QWORD *)(a2 + 8));
    MEMORY[0x20BD1173C](v3, 8);
    MEMORY[0x20BD1173C](v3 + 8, 8);
    MEMORY[0x20BD1173C](v3 + 16, 8);
    if (!MEMORY[0x20BD11730](v3, 8) && !MEMORY[0x20BD11730](v3 + 8, 8))
    {
      result = MEMORY[0x20BD11730](v3 + 16, 8);
      if (!(_DWORD)result)
        break;
    }
  }
  return result;
}

uint64_t sub_2096B5698(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  uint64_t v4;
  uint64_t v5;

  v4 = *(_QWORD *)(a3[1] + 8);
  v5 = (*(uint64_t (**)(void))(a2 + 80))();
  hc_EVP_CIPHER_CTX_init(v4);
  hc_EVP_CIPHER_CTX_init(v4 + 168);
  hc_EVP_CipherInit_ex(v4, v5, 0, *(_QWORD *)(*a3 + 16), 0, 1);
  return hc_EVP_CipherInit_ex(v4 + 168, v5, 0, *(_QWORD *)(*a3 + 16), 0, 0);
}

uint64_t sub_2096B5720(uint64_t a1, uint64_t a2)
{
  uint64_t *v2;

  v2 = *(uint64_t **)(*(_QWORD *)(a2 + 8) + 8);
  hc_EVP_CIPHER_CTX_cleanup(v2);
  return hc_EVP_CIPHER_CTX_cleanup(v2 + 21);
}

uint64_t sub_2096B574C(_krb5_context *a1, uint64_t a2, int a3, int a4, int a5, int a6, void *__src)
{
  uint64_t v7;
  size_t v9;
  void *v10;
  void *v11;

  if (a5)
    v7 = *(_QWORD *)(*(_QWORD *)(a2 + 8) + 8);
  else
    v7 = *(_QWORD *)(*(_QWORD *)(a2 + 8) + 8) + 168;
  if (__src)
  {
    hc_EVP_CipherInit_ex(v7, 0, 0, 0, __src, 0xFFFFFFFFLL);
LABEL_8:
    hc_EVP_Cipher(v7);
    return 0;
  }
  v9 = hc_EVP_CIPHER_CTX_iv_length(v7);
  v10 = malloc_type_malloc(v9, 0x84297860uLL);
  if (v10)
  {
    v11 = v10;
    bzero(v10, v9);
    hc_EVP_CipherInit_ex(v7, 0, 0, 0, v11, 0xFFFFFFFFLL);
    free(v11);
    goto LABEL_8;
  }
  krb5_clear_error_message(a1);
  return 12;
}

uint64_t sub_2096B582C()
{
  return 0;
}

uint64_t sub_2096B5834()
{
  return 0;
}

uint64_t _krb5_pk_octetstring2key(_krb5_context *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  _DWORD *v12;
  size_t v13;
  _QWORD *v14;
  _QWORD *v15;
  size_t v16;
  unint64_t v17;
  size_t v18;
  uint64_t v19;
  int v21;
  uint64_t v22;
  char v23;
  _QWORD __src[2];
  int v25;
  uint64_t v26;

  v26 = *MEMORY[0x24BDAC8D0];
  v12 = sub_209683B8C(a2);
  if (!v12)
  {
    v19 = 2529639062;
    krb5_set_error_message(a1, -1765328234, "encryption type %d not supported");
    return v19;
  }
  v13 = (unint64_t)(*(_QWORD *)(*((_QWORD *)v12 + 5) + 16) + 7) >> 3;
  v14 = malloc_type_malloc(v13, 0x11B00E76uLL);
  if (!v14)
  {
LABEL_16:
    v19 = 12;
    krb5_set_error_message(a1, 12, "malloc: out of memory");
    return v19;
  }
  v15 = v14;
  if (!CCDigestCreate())
  {
    free(v15);
    goto LABEL_16;
  }
  v21 = a2;
  v22 = a7;
  v16 = 0;
  v23 = 0;
  v17 = v13;
  do
  {
    CCDigestReset();
    CCDigestUpdate();
    CCDigestUpdate();
    if (a5)
      CCDigestUpdate();
    if (a6)
      CCDigestUpdate();
    CCDigestFinal();
    if (v17 >= 0x14)
      v18 = 20;
    else
      v18 = v17;
    memcpy((char *)v15 + v16, __src, v18);
    v16 += 20;
    ++v23;
    v17 -= 20;
  }
  while (v16 < v13);
  __src[0] = 0;
  __src[1] = 0;
  v25 = 0;
  CCDigestDestroy();
  v19 = krb5_random_to_key(a1, v21, v15, v13, v22);
  *v15 = 0;
  free(v15);
  return v19;
}

uint64_t _krb5_pk_kdf(_krb5_context *a1, __int128 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v17;
  const char *v18;
  uint64_t v19;
  uint64_t v20;
  _DWORD *v21;
  size_t v22;
  _QWORD *v23;
  size_t v24;
  void *v25;
  void *v26;
  uint64_t v27;
  void *v29;
  uint64_t v30;
  uint64_t v31;
  unint64_t v32;
  unsigned int v33;
  size_t v34;
  size_t v35;
  uint64_t v36;
  size_t v37;
  unint64_t v38;
  _QWORD *v39;
  size_t v40;
  void *v41;
  uint64_t v42;
  size_t v43;
  void *v44;
  _QWORD v45[4];
  __int128 __src;
  __int128 v47;
  void *v48[2];
  void *v49[2];
  uint64_t v50;
  uint64_t v51;

  v51 = *MEMORY[0x24BDAC8D0];
  if (!der_heim_oid_cmp())
  {
    v19 = 20;
LABEL_6:
    v40 = 0;
    v41 = 0;
    v20 = *((_QWORD *)a2 + 2);
    if (v20 && (*(_QWORD *)v20 != 2 || **(_WORD **)(v20 + 8) != 5))
    {
      v17 = 2529639062;
      v18 = "kdf params not NULL or the NULL-type";
      goto LABEL_16;
    }
    v21 = sub_209683B8C(a7);
    if (!v21)
    {
      v17 = 2529639062;
      v36 = a7;
      v18 = "encryption type %d not supported";
      goto LABEL_16;
    }
    v22 = (unint64_t)(*(_QWORD *)(*((_QWORD *)v21 + 5) + 16) + 7) >> 3;
    v23 = malloc_type_malloc(v22, 0x6D5FFD54uLL);
    if (v23)
    {
      v37 = v19;
      v38 = v22;
      v39 = v23;
      v42 = 0;
      krb5_data_zero(&v40);
      v50 = 0;
      *(_OWORD *)v48 = 0u;
      *(_OWORD *)v49 = 0u;
      __src = 0u;
      v47 = 0u;
      v45[1] = a8;
      v45[0] = a7;
      v45[2] = a9;
      v45[3] = a10;
      v24 = sub_2096BCB28();
      v43 = v24;
      v25 = malloc_type_malloc(v24, 0x89238B24uLL);
      v44 = v25;
      if (!v25)
      {
        v17 = 12;
        goto LABEL_19;
      }
      v26 = v25;
      v27 = sub_2096BCB08();
      if ((_DWORD)v27)
      {
        v17 = v27;
        free(v26);
LABEL_19:
        krb5_set_error_message(a1, v17, "malloc: out of memory");
LABEL_20:
        v29 = v39;
LABEL_21:
        free(v29);
        return v17;
      }
      if (v24 != v42)
        goto LABEL_45;
      if (a5)
      {
        v30 = sub_2096B5E60(a1, a5, (uint64_t)&v47 + 8);
        if ((_DWORD)v30)
        {
          v17 = v30;
LABEL_29:
          free(v26);
          goto LABEL_20;
        }
      }
      if (a6)
      {
        v31 = sub_2096B5E60(a1, a6, (uint64_t)&v48[1]);
        if ((_DWORD)v31)
        {
          v17 = v31;
          free(v48[0]);
          goto LABEL_29;
        }
      }
      __src = *a2;
      *(_QWORD *)&v47 = *((_QWORD *)a2 + 2);
      v49[1] = &v43;
      v40 = sub_2096BCAF8();
      v41 = malloc_type_malloc(v40, 0xC54595E5uLL);
      if (v41)
      {
        v17 = sub_2096BCAD8();
        if ((_DWORD)v17)
        {
          free(v41);
          v41 = 0;
        }
      }
      else
      {
        v17 = 12;
      }
      free(v48[0]);
      free(v49[0]);
      free(v44);
      if ((_DWORD)v17)
        goto LABEL_19;
      if (v40 != v42)
LABEL_45:
        krb5_abortx(a1, "asn1 compiler internal error");
      if (CCDigestCreate())
      {
        v32 = 0;
        v33 = 1;
        v34 = v38;
        do
        {
          CCDigestReset();
          _krb5_put_int((uint64_t)v45, v33, 4);
          CCDigestUpdate();
          CCDigestUpdate();
          CCDigestUpdate();
          CCDigestFinal();
          if (v34 >= v37)
            v35 = v37;
          else
            v35 = v34;
          memcpy((char *)v39 + v32, &__src, v35);
          v32 += v37;
          ++v33;
          v34 -= v37;
        }
        while (v32 < v38);
        *(_OWORD *)v48 = 0u;
        *(_OWORD *)v49 = 0u;
        __src = 0u;
        v47 = 0u;
        CCDigestDestroy();
        free(v41);
        v17 = krb5_random_to_key(a1, a7, v39, v38, a11);
        *v39 = 0;
        v29 = v39;
        goto LABEL_21;
      }
      free(v39);
      free(v41);
    }
    v17 = 12;
    krb5_set_error_message(a1, 12, "malloc: out of memory");
    return v17;
  }
  if (!der_heim_oid_cmp())
  {
    v19 = 64;
    goto LABEL_6;
  }
  v17 = 2529639062;
  v18 = "KDF not supported";
LABEL_16:
  krb5_set_error_message(a1, -1765328234, v18, v36);
  return v17;
}

uint64_t sub_2096B5E60(_krb5_context *a1, uint64_t a2, uint64_t a3)
{
  size_t v5;
  void *v6;
  uint64_t v7;
  uint64_t v8;

  v5 = sub_2096BC918();
  *(_QWORD *)a3 = v5;
  v6 = malloc_type_malloc(v5, 0x408ADE4AuLL);
  *(_QWORD *)(a3 + 8) = v6;
  if (!v6)
  {
    v8 = 12;
    goto LABEL_5;
  }
  v7 = sub_2096BC8F8();
  if ((_DWORD)v7)
  {
    v8 = v7;
    free(*(void **)(a3 + 8));
    *(_QWORD *)(a3 + 8) = 0;
LABEL_5:
    krb5_data_zero((_QWORD *)a3);
    krb5_set_error_message(a1, v8, "Failed to encode KRB5PrincipalName");
    return v8;
  }
  if (*(_QWORD *)a3)
    krb5_abortx(a1, "asn1 compiler internal error");
  return 0;
}

uint64_t krb5_generate_random_block(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  result = CCRandomCopyBytes();
  if ((_DWORD)result)
    krb5_abortx(0, "Failed reading %lu random bytes", a2);
  return result;
}

uint64_t sub_2096B5F94(_krb5_context *a1, int a2, size_t a3, const char *a4, uint64_t a5, uint64_t a6, unsigned __int8 *a7, krb5_keyblock *a8)
{
  uint64_t v14;
  unsigned int v15;
  _DWORD *v16;
  uint64_t v17;
  void *v18;
  uint8_t **v19;
  uint64_t v20;
  uint64_t v21;
  krb5_keyblock *v23[2];

  v14 = 2529639063;
  if (a6 == 4)
  {
    v23[0] = 0;
    _krb5_get_int(a7, (unint64_t *)v23, 4);
    v15 = v23[0];
  }
  else
  {
    if (a6)
      return v14;
    v15 = _krb5_AES_string_to_default_iterator;
  }
  v16 = sub_209683B8C(a2);
  if (v16)
  {
    v17 = (uint64_t)v16;
    v23[1] = 0;
    v18 = malloc_type_calloc(1uLL, 0x18uLL, 0x10800404ACF7207uLL);
    v23[0] = (krb5_keyblock *)v18;
    if (v18)
    {
      v19 = (uint8_t **)v18;
      *(_DWORD *)v18 = a2;
      v20 = krb5_data_alloc((size_t *)v18 + 1, *(_QWORD *)(*(_QWORD *)(v17 + 40) + 24));
      if ((_DWORD)v20)
      {
        v21 = v20;
        krb5_set_error_message(a1, v20, "malloc: out of memory");
        return v21;
      }
      else if (hc_PKCS5_PBKDF2_HMAC_SHA1(a4, a3, *(uint8_t **)(a5 + 16), *(_QWORD *)(a5 + 8), v15, *(_QWORD *)(*(_QWORD *)(v17 + 40) + 24), v19[2]))
      {
        v14 = sub_209686428(a1, v17, (uint64_t)v23, "kerberos", 8uLL);
        if (!(_DWORD)v14)
          v14 = krb5_copy_keyblock_contents(a1, v23[0], a8);
        sub_209686774(a1, (uint64_t)v23, v17);
      }
      else
      {
        sub_209686774(a1, (uint64_t)v23, v17);
        krb5_set_error_message(a1, -1765328233, "Error calculating s2k", v23[0]);
      }
    }
    else
    {
      v14 = 12;
      krb5_set_error_message(a1, 12, "malloc: out of memory", 0);
    }
  }
  return v14;
}

uint64_t sub_2096B614C(_krb5_context *a1, int a2, size_t a3, char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  BOOL v13;
  uint64_t v14;
  char *v15;
  char *v16;
  uint64_t v17;
  void *v18;
  void *v19;
  uint64_t v21;
  size_t i;
  size_t v23;
  char v24;

  v23 = 0;
  if (getenv("KRB5_USE_BROKEN_ARCFOUR_STRING2KEY"))
    v13 = 0;
  else
    v13 = krb5_heim_use_broken_arcfour_string2key == 0;
  if (v13)
  {
    v15 = (char *)malloc_type_malloc(a3 + 1, 0x17AA4DEAuLL);
    if (!v15)
    {
      v14 = 12;
      krb5_set_error_message(a1, 12, "malloc: out of memory");
      return v14;
    }
    v16 = v15;
    memcpy(v15, a4, a3);
    v16[a3] = 0;
    if (CCDigestCreate())
    {
      v17 = wind_utf8ucs2_length(v16, &v23);
      if ((_DWORD)v17)
      {
        v14 = v17;
        krb5_set_error_message(a1, v17, "Password not an UCS2 string");
LABEL_21:
        CCDigestDestroy();
LABEL_22:
        free(v16);
        return v14;
      }
      v18 = malloc_type_malloc(2 * v23, 0x1000040BDFB0063uLL);
      v19 = v18;
      if (!v23 || v18)
      {
        v21 = wind_utf8ucs2(v16, (uint64_t)v18, &v23);
        if ((_DWORD)v21)
        {
          v14 = v21;
          krb5_set_error_message(a1, v21, "Password not an UCS2 string");
        }
        else
        {
          if (v23)
          {
            for (i = 0; i < v23; ++i)
            {
              CCDigestUpdate();
              CCDigestUpdate();
            }
          }
          *(_DWORD *)a8 = a2;
          v14 = krb5_data_alloc((size_t *)(a8 + 8), 0x10uLL);
          if ((_DWORD)v14)
            krb5_set_error_message(a1, 12, "malloc: out of memory");
          else
            CCDigestFinal();
        }
        CCDigestDestroy();
        if (v19)
        {
          bzero(v19, v23);
          free(v19);
        }
        goto LABEL_22;
      }
    }
    v14 = 12;
    krb5_set_error_message(a1, 12, "malloc: out of memory");
    goto LABEL_21;
  }
  if (CCDigestCreate())
  {
    for (; a3; --a3)
    {
      ++a4;
      CCDigestUpdate();
      v24 = 0;
      CCDigestUpdate();
    }
    *(_DWORD *)a8 = a2;
    v14 = krb5_data_alloc((size_t *)(a8 + 8), 0x10uLL);
    if ((_DWORD)v14)
      krb5_set_error_message(a1, 12, "malloc: out of memory");
    else
      CCDigestFinal();
  }
  else
  {
    v14 = 12;
    krb5_set_error_message(a1, 12, "malloc: out of memory");
  }
  CCDigestDestroy();
  return v14;
}

uint64_t sub_2096B640C(_krb5_context *a1, int a2, size_t a3, const void *a4, uint64_t a5, uint64_t a6, uint64_t a7, krb5_keyblock *a8)
{
  size_t v14;
  char *v15;
  BOOL v16;
  char *v17;
  uint64_t v18;

  v14 = *(_QWORD *)(a5 + 8) + a3;
  v15 = (char *)malloc_type_malloc(v14, 0xD3990A69uLL);
  if (v14)
    v16 = v15 == 0;
  else
    v16 = 0;
  if (v16)
  {
    krb5_set_error_message(a1, 12, "malloc: out of memory");
    return 12;
  }
  else
  {
    v17 = v15;
    memcpy(v15, a4, a3);
    memcpy(&v17[a3], *(const void **)(a5 + 16), *(_QWORD *)(a5 + 8));
    v18 = krb5_string_to_key_derived(a1, v17, v14, a2, a8);
    bzero(v17, v14);
    free(v17);
    return v18;
  }
}

krb5_error_code krb5_salttype_to_string(krb5_int32 a1, char *a2, size_t a3)
{
  char **v3;
  char **v4;
  int v5;
  _krb5_context *v6;
  _DWORD *v7;
  _DWORD *v8;
  int v9;
  const char **v10;
  int v11;
  krb5_error_code v12;
  char *v14;

  v4 = v3;
  v5 = a3;
  v6 = *(_krb5_context **)&a1;
  v7 = sub_209683B8C((int)a2);
  if (v7)
  {
    v8 = *(_DWORD **)(*((_QWORD *)v7 + 5) + 56);
    if (v8 && (v9 = *v8) != 0)
    {
      v10 = (const char **)(v8 + 6);
      while (v9 != v5)
      {
        v11 = *(_DWORD *)v10;
        v10 += 3;
        v9 = v11;
        if (!v11)
          goto LABEL_7;
      }
      v14 = strdup(*(v10 - 2));
      *v4 = v14;
      if (v14)
      {
        return 0;
      }
      else
      {
        v12 = 12;
        krb5_set_error_message(v6, 12, "malloc: out of memory");
      }
    }
    else
    {
LABEL_7:
      v12 = -1980176638;
      krb5_set_error_message(v6, -1980176638, "salttype %d not supported");
    }
  }
  else
  {
    v12 = -1765328234;
    krb5_set_error_message(v6, -1765328234, "encryption type %d not supported");
  }
  return v12;
}

krb5_error_code krb5_string_to_salttype(char *a1, krb5_int32 *a2)
{
  const char *v2;
  _DWORD *v3;
  _DWORD *v4;
  const char *v5;
  _DWORD *v7;
  _DWORD *v8;
  int v9;
  const char **v10;
  int v11;
  krb5_error_code v12;

  v4 = v3;
  v5 = v2;
  v7 = sub_209683B8C((int)a2);
  if (v7)
  {
    v8 = *(_DWORD **)(*((_QWORD *)v7 + 5) + 56);
    if (v8 && (v9 = *v8) != 0)
    {
      v10 = (const char **)(v8 + 6);
      while (strcasecmp(*(v10 - 2), v5))
      {
        v11 = *(_DWORD *)v10;
        v10 += 3;
        v9 = v11;
        if (!v11)
          goto LABEL_7;
      }
      v12 = 0;
      *v4 = v9;
    }
    else
    {
LABEL_7:
      v12 = -1980176638;
      krb5_set_error_message((krb5_context)a1, -1980176638, "salttype %s not supported");
    }
  }
  else
  {
    v12 = -1765328234;
    krb5_set_error_message((krb5_context)a1, -1765328234, "encryption type %d not supported");
  }
  return v12;
}

uint64_t krb5_get_pw_salt(uint64_t a1, uint64_t a2, uint64_t a3)
{
  size_t v5;
  uint64_t v6;
  const char **v7;
  const char *v8;
  uint64_t result;
  char *v10;
  size_t v11;
  unint64_t v12;
  char *v13;
  uint64_t v14;
  const char *v15;
  size_t v16;

  *(_DWORD *)a3 = 3;
  v5 = strlen(*(const char **)(a2 + 24));
  v6 = *(unsigned int *)(a2 + 8);
  if ((_DWORD)v6)
  {
    v7 = *(const char ***)(a2 + 16);
    do
    {
      v8 = *v7++;
      v5 += strlen(v8);
      --v6;
    }
    while (v6);
  }
  result = krb5_data_alloc((size_t *)(a3 + 8), v5);
  if (!(_DWORD)result)
  {
    v10 = *(char **)(a3 + 16);
    v11 = strlen(*(const char **)(a2 + 24));
    memcpy(v10, *(const void **)(a2 + 24), v11);
    if (*(_DWORD *)(a2 + 8))
    {
      v12 = 0;
      v13 = &v10[strlen(*(const char **)(a2 + 24))];
      v14 = *(_QWORD *)(a2 + 16);
      do
      {
        v15 = *(const char **)(v14 + 8 * v12);
        v16 = strlen(v15);
        memcpy(v13, v15, v16);
        v14 = *(_QWORD *)(a2 + 16);
        v13 += strlen(*(const char **)(v14 + 8 * v12++));
      }
      while (v12 < *(unsigned int *)(a2 + 8));
    }
    return 0;
  }
  return result;
}

uint64_t krb5_free_salt(uint64_t a1, uint64_t a2)
{
  krb5_data_free((_QWORD *)(a2 + 8));
  return 0;
}

uint64_t krb5_string_to_key_data(_krb5_context *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t pw_salt;
  __int128 v13;
  uint64_t v14;
  __int128 v15;
  uint64_t v16;

  v15 = 0uLL;
  v16 = 0;
  pw_salt = krb5_get_pw_salt((uint64_t)a1, a5, (uint64_t)&v15);
  if (!(_DWORD)pw_salt)
  {
    v13 = v15;
    v14 = v16;
    pw_salt = krb5_string_to_key_data_salt(a1, a2, a3, a4, (uint64_t)&v13, a6);
    v13 = v15;
    v14 = v16;
    krb5_data_free((_QWORD *)&v13 + 1);
  }
  return pw_salt;
}

uint64_t krb5_string_to_key_data_salt(_krb5_context *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  __int128 v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;

  v15 = 0;
  v16 = 0;
  krb5_data_zero(&v15);
  v13 = *(_OWORD *)a5;
  v14 = *(_QWORD *)(a5 + 16);
  return krb5_string_to_key_data_salt_opaque(a1, a2, a3, a4, &v13, v15, v16, a6);
}

krb5_error_code krb5_string_to_key(krb5_context context, const krb5_encrypt_block *eblock, krb5_keyblock *keyblock, const krb5_data *data, const krb5_data *salt)
{
  size_t v10;

  v10 = strlen((const char *)keyblock);
  return krb5_string_to_key_data(context, (uint64_t)eblock, v10, (uint64_t)keyblock, (uint64_t)data, (uint64_t)salt);
}

uint64_t krb5_string_to_key_data_salt_opaque(_krb5_context *a1, uint64_t a2, uint64_t a3, uint64_t a4, __int128 *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _DWORD *v16;
  int *v17;
  int v18;
  _DWORD *v19;
  int v20;
  uint64_t v21;
  uint64_t (*v23)(_krb5_context *, uint64_t, uint64_t, uint64_t, __int128 *, uint64_t, uint64_t, uint64_t);
  __int128 v24;
  uint64_t v25;

  v16 = sub_209683B8C(a2);
  if (v16)
  {
    v17 = *(int **)(*((_QWORD *)v16 + 5) + 56);
    if (v17 && (v18 = *v17) != 0)
    {
      v19 = v17 + 6;
      while (v18 != *(_DWORD *)a5)
      {
        v20 = *v19;
        v19 += 6;
        v18 = v20;
        if (!v20)
          goto LABEL_7;
      }
      v23 = (uint64_t (*)(_krb5_context *, uint64_t, uint64_t, uint64_t, __int128 *, uint64_t, uint64_t, uint64_t))*((_QWORD *)v19 - 1);
      v24 = *a5;
      v25 = *((_QWORD *)a5 + 2);
      return v23(a1, a2, a3, a4, &v24, a6, a7, a8);
    }
    else
    {
LABEL_7:
      v21 = 2314790658;
      krb5_set_error_message(a1, -1980176638, "salt type %d not supported");
    }
  }
  else
  {
    v21 = 2529639062;
    krb5_set_error_message(a1, -1765328234, "encryption type %d not supported");
  }
  return v21;
}

uint64_t krb5_string_to_key_salt(_krb5_context *a1, uint64_t a2, char *__s, __int128 *a4, uint64_t a5)
{
  size_t v10;
  __int128 v12;
  uint64_t v13;

  v10 = strlen(__s);
  v12 = *a4;
  v13 = *((_QWORD *)a4 + 2);
  return krb5_string_to_key_data_salt(a1, a2, v10, (uint64_t)__s, (uint64_t)&v12, a5);
}

uint64_t krb5_string_to_key_salt_opaque(_krb5_context *a1, uint64_t a2, char *__s, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  size_t v14;
  __int128 v16;
  uint64_t v17;

  v14 = strlen(__s);
  v16 = *(_OWORD *)a4;
  v17 = *(_QWORD *)(a4 + 16);
  return krb5_string_to_key_data_salt_opaque(a1, a2, v14, (uint64_t)__s, &v16, a5, a6, a7);
}

uint64_t krb5_string_to_key_derived(_krb5_context *a1, const void *a2, size_t a3, int a4, krb5_keyblock *a5)
{
  _DWORD *v10;
  uint64_t v11;
  unint64_t v12;
  void *v13;
  krb5_keyblock *v14;
  uint64_t v15;
  uint64_t v16;
  size_t v17;
  char *v18;
  char *v19;
  uint64_t v20;
  uint64_t v22;
  krb5_keyblock *v23[2];

  v10 = sub_209683B8C(a4);
  if (!v10)
  {
    v16 = 2529639062;
    krb5_set_error_message(a1, -1765328234, "encryption type %d not supported");
    return v16;
  }
  v11 = (uint64_t)v10;
  v12 = *(_QWORD *)(*((_QWORD *)v10 + 5) + 16);
  v13 = malloc_type_calloc(1uLL, 0x18uLL, 0x10800404ACF7207uLL);
  v23[0] = (krb5_keyblock *)v13;
  if (!v13)
    goto LABEL_10;
  v14 = (krb5_keyblock *)v13;
  v15 = krb5_data_alloc((size_t *)v13 + 1, *(_QWORD *)(*(_QWORD *)(v11 + 40) + 24));
  if ((_DWORD)v15)
  {
    v16 = v15;
    free(v14);
    return v16;
  }
  v17 = v12 >> 3;
  v14->magic = a4;
  v18 = (char *)malloc_type_malloc(v17, 0xB3724923uLL);
  if (!v18)
  {
    krb5_free_keyblock(a1, v14);
LABEL_10:
    v16 = 12;
    goto LABEL_11;
  }
  v19 = v18;
  v20 = sub_20969FB10(a2, a3, v18, v17);
  if ((_DWORD)v20)
  {
    v16 = v20;
    free(v19);
LABEL_11:
    krb5_set_error_message(a1, 12, "malloc: out of memory");
    return v16;
  }
  v23[1] = 0;
  sub_2096B5514((uint64_t)a1, (uint64_t)v14, (uint64_t)v19, v17);
  bzero(v19, v17);
  free(v19);
  v22 = sub_209686428(a1, v11, (uint64_t)v23, "kerberos", 8uLL);
  if (!(_DWORD)v22)
    v22 = krb5_copy_keyblock_contents(a1, v23[0], a5);
  v16 = v22;
  sub_209686774(a1, (uint64_t)v23, v11);
  return v16;
}

uint64_t _krb5_put_int(uint64_t a1, unint64_t a2, uint64_t a3)
{
  uint64_t v3;

  if (a3 - 1 >= 0)
  {
    v3 = a3;
    do
    {
      *(_BYTE *)(a1 - 1 + v3) = a2;
      a2 >>= 8;
      --v3;
    }
    while (v3);
  }
  return a3;
}

uint64_t _krb5_get_int(unsigned __int8 *a1, unint64_t *a2, uint64_t a3)
{
  unint64_t v3;
  uint64_t v4;
  unsigned int v5;

  v3 = 0;
  if (a3)
  {
    v4 = a3;
    do
    {
      v5 = *a1++;
      v3 = v5 | (v3 << 8);
      --v4;
    }
    while (v4);
  }
  *a2 = v3;
  return a3;
}

uint64_t sub_2096B6D84(uint64_t a1)
{
  unsigned int v2;

  v2 = 0;
  krb5_plugin_run_f(a1, "krb5", "ccache_ops", 0, 0, (uint64_t)&v2, (uint64_t)sub_2096B6DCC);
  return v2;
}

uint64_t sub_2096B6DCC(uint64_t a1, int *a2, uint64_t a3, _DWORD *a4)
{
  int v5;

  if (!a2 || *a2 <= 7)
  {
    v5 = krb5_cc_register(a1, (uint64_t)a2, 1);
    if (v5)
      *a4 = v5;
  }
  return 2529639161;
}

uint64_t _krb5_fast_cf2(_krb5_context *a1, const krb5_keyblock *a2, const char *a3, const krb5_keyblock *a4, const char *a5, krb5_keyblock *a6, krb5_keyblock ***a7)
{
  uint64_t v14;
  uint64_t v15;
  _QWORD v17[2];
  _QWORD v18[2];
  krb5_keyblock **v19;
  krb5_keyblock **v20;

  v19 = 0;
  v20 = 0;
  v14 = krb5_crypto_init(a1, a2, 0, &v20);
  if (!(_DWORD)v14)
  {
    v15 = krb5_crypto_init(a1, a4, 0, &v19);
    if ((_DWORD)v15)
    {
      v14 = v15;
      krb5_crypto_destroy(a1, (uint64_t)v20);
    }
    else
    {
      v18[1] = a3;
      v17[1] = a5;
      v18[0] = strlen(a3);
      v17[0] = strlen(a5);
      v14 = krb5_crypto_fx_cf2(a1, (uint64_t *)v20, (uint64_t *)v19, (uint64_t)v18, (uint64_t)v17, (char *)a2->magic, a6);
      krb5_crypto_destroy(a1, (uint64_t)v20);
      krb5_crypto_destroy(a1, (uint64_t)v19);
      if (!(_DWORD)v14)
      {
        if (a7)
        {
          v14 = krb5_crypto_init(a1, a6, 0, a7);
          if ((_DWORD)v14)
            krb5_free_keyblock_contents(a1, a6);
        }
        else
        {
          return 0;
        }
      }
    }
  }
  return v14;
}

uint64_t _krb5_fast_armor_key(_krb5_context *a1, const krb5_keyblock *a2, const krb5_keyblock *a3, krb5_keyblock *a4, krb5_keyblock ***a5)
{
  return _krb5_fast_cf2(a1, a2, "subkeyarmor", a3, "ticketarmor", a4, a5);
}

uint64_t sub_2096B6F5C(_krb5_context *a1, _krb5_ccache *a2, krb5_data *a3, krb5_keyblock *a4, krb5_keyblock ***a5)
{
  uint64_t credentials;
  uint64_t v11;
  _QWORD v13[2];
  krb5_creds *v14;
  krb5_principal principal[2];
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  krb5_auth_context v24;

  v24 = 0;
  v13[1] = 0;
  v14 = 0;
  v13[0] = 0;
  krb5_data_zero(v13);
  v22 = 0u;
  v23 = 0u;
  v20 = 0u;
  v21 = 0u;
  v18 = 0u;
  v19 = 0u;
  v16 = 0u;
  v17 = 0u;
  *(_OWORD *)principal = 0u;
  credentials = krb5_auth_con_init(a1, &v24);
  if (!(_DWORD)credentials)
  {
    credentials = krb5_cc_get_principal(a1, a2, principal);
    if (!(_DWORD)credentials)
    {
      v11 = krb5_make_principal(a1, &principal[1], (char *)principal[0]->data, "krbtgt", principal[0]->data, 0);
      if ((_DWORD)v11)
      {
        credentials = v11;
        krb5_free_principal(a1, principal[0]);
      }
      else
      {
        credentials = krb5_get_credentials(a1, 0, a2, (krb5_creds *)principal, &v14);
        krb5_free_principal(a1, principal[1]);
        krb5_free_principal(a1, principal[0]);
        if (!(_DWORD)credentials)
        {
          credentials = krb5_auth_con_add_AuthorizationData(a1, (uint64_t)v24);
          if (!(_DWORD)credentials)
          {
            credentials = krb5_mk_req_extended(a1, &v24, 4, 0, v14, a3);
            if (!(_DWORD)credentials)
              credentials = _krb5_fast_cf2(a1, *((const krb5_keyblock **)v24 + 5), "subkeyarmor", *((const krb5_keyblock **)v24 + 4), "ticketarmor", a4, a5);
          }
        }
      }
    }
  }
  if (v24)
    krb5_auth_con_free(a1, v24);
  if (v14)
    krb5_free_creds(a1, v14);
  return credentials;
}

uint64_t sub_2096B710C(krb5_context a1, uint64_t a2, const char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v11;
  krb5_keyblock ***v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  char *v25;
  void *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  char v30;
  _QWORD v31[2];
  _QWORD v32[2];
  __int128 v33;
  _OWORD v34[2];

  v12 = (krb5_keyblock ***)(a2 + 48);
  v11 = *(_QWORD *)(a2 + 48);
  if (v11)
  {
    if (*(_DWORD *)a2 != 1)
      heim_abort("unknown state type: %d", v11, (uint64_t)a3, a4, a5, a6, a7, a8, *(_DWORD *)a2);
    krb5_crypto_destroy(a1, v11);
  }
  else
  {
    if (!*(_QWORD *)(a2 + 16) && !*(_QWORD *)(a2 + 24))
    {
      v13 = *(_DWORD *)(a2 + 4);
      if ((v13 & 0x100) == 0)
      {
        if ((v13 & 0x20) == 0)
          return 0;
        v14 = 2529638953;
        krb5_set_error_message(a1, -1765328343, "Expected FAST, but no FAST was in the response from the KDC");
        return v14;
      }
    }
    *(_DWORD *)a2 = 1;
  }
  krb5_free_keyblock_contents(a1, (krb5_keyblock *)(a2 + 56));
  v22 = *(_QWORD *)(a2 + 24);
  v23 = *(_DWORD *)(a2 + 4);
  if (!v22)
  {
    if ((v23 & 0x1000) == 0)
      heim_abort("FAST TGS without AC:(state->flags & KRB5_FAST_AS_REQ) != 0", v15, v16, v17, v18, v19, v20, v21, v30);
    if (*(_QWORD *)(a2 + 32))
    {
      sub_2096BC2D0();
      free(*(void **)(a2 + 32));
    }
    v25 = (char *)malloc_type_calloc(1uLL, 0x18uLL, 0x10800404ACF7207uLL);
    if (!v25)
      return 12;
    v26 = v25;
    if ((*(_BYTE *)(a2 + 5) & 1) != 0)
    {
      memset(v34, 0, sizeof(v34));
      v33 = 0u;
      v31[0] = 0;
      v31[1] = 0;
      heim_base_once_f(&qword_2545A7DD8, &qword_2545A7DE0, (dispatch_function_t)sub_2096B7D74);
      if (!qword_2545A7DE0)
      {
        free(v26);
        v14 = 2;
        krb5_set_error_message(a1, 2, "Failed to open fast armor service");
        return v14;
      }
      krb5_data_zero(v31);
      v32[1] = a3;
      v32[0] = strlen(a3);
      v28 = heim_ipc_call((_QWORD *)qword_2545A7DE0, (uint64_t)v32, (uint64_t)v31, 0);
      if ((_DWORD)v28)
      {
        v14 = v28;
        krb5_set_error_message(a1, v28, "Failed to get armor service credential");
        goto LABEL_32;
      }
      v14 = sub_2096BC414();
      krb5_data_free(v31);
      if ((_DWORD)v14)
        goto LABEL_32;
      v29 = sub_2096BC2E0();
      if ((_DWORD)v29)
      {
        v14 = v29;
        sub_2096BC434();
        goto LABEL_32;
      }
      v14 = krb5_copy_keyblock_contents(a1, (const krb5_keyblock *)((char *)v34 + 8), (krb5_keyblock *)(a2 + 56));
      sub_2096BC434();
      if ((_DWORD)v14)
        goto LABEL_32;
      v27 = krb5_crypto_init(a1, (const krb5_keyblock *)(a2 + 56), 0, v12);
    }
    else
    {
      *(_DWORD *)v25 = 1;
      v27 = sub_2096B6F5C(a1, *(_krb5_ccache **)(a2 + 16), (krb5_data *)(v25 + 8), (krb5_keyblock *)(a2 + 56), v12);
    }
    v14 = v27;
    if (!(_DWORD)v27)
    {
      v14 = 0;
      *(_QWORD *)(a2 + 32) = v26;
      return v14;
    }
LABEL_32:
    sub_2096BC2D0();
    free(v26);
    return v14;
  }
  if ((v23 & 0x1000) != 0)
    heim_abort("FAST AS with AC:(state->flags & KRB5_FAST_AS_REQ) == 0", v15, v16, v17, v18, v19, v20, v21, v30);
  return _krb5_fast_cf2(a1, *(const krb5_keyblock **)(v22 + 40), "subkeyarmor", *(const krb5_keyblock **)(v22 + 32), "ticketarmor", (krb5_keyblock *)(a2 + 56), v12);
}

uint64_t sub_2096B7400(_krb5_context *a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  int v8;
  uint64_t checksum;
  char *v11;
  _DWORD *v12;
  _QWORD *v13;
  char **v14;
  _QWORD *v15;
  uint64_t v16;
  void *v17;
  void *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  _DWORD **v27;
  _QWORD *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  char v51;
  size_t v52;
  void *v53;
  uint64_t v54;
  void *v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  __int128 v61;
  __int128 v62;
  __int128 v63;
  __int128 v64;
  _OWORD v65[3];
  uint64_t v66;

  if ((*(_BYTE *)(a2 + 4) & 0x80) != 0)
  {
    sub_20969D1E8((uint64_t)a1, 10, "fast disabled, not doing any fast wrapping");
    return 0;
  }
  v54 = 0;
  v55 = 0;
  v52 = 0;
  v53 = 0;
  v64 = 0u;
  memset(v65, 0, sizeof(v65));
  v66 = 0;
  v56 = 0u;
  v57 = 0u;
  v58 = 0u;
  v59 = 0u;
  v60 = 0u;
  v61 = 0u;
  v62 = 0u;
  v63 = 0u;
  krb5_data_zero(&v54);
  krb5_data_zero(&v52);
  v8 = *(_DWORD *)(a2 + 4);
  if (!*(_QWORD *)(a2 + 48))
  {
    if ((v8 & 0x20) != 0)
    {
      checksum = 2529638953;
      krb5_set_error_message(a1, -1765328343, "Expected FAST, but no FAST was in the response from the KDC");
      return checksum;
    }
    return 0;
  }
  *(_DWORD *)(a2 + 4) = v8 | 0x20;
  LODWORD(v56) = v56 | 2;
  checksum = sub_2096BBA38();
  if (!(_DWORD)checksum)
  {
    if ((*(_BYTE *)(a2 + 5) & 0x10) == 0)
    {
LABEL_11:
      if (*(_QWORD *)(a4 + 8))
      {
        checksum = sub_2096BB9E4();
        sub_2096BB9D4();
        if ((_DWORD)checksum)
          goto LABEL_4;
LABEL_21:
        v54 = sub_2096BC2B0();
        v55 = malloc_type_malloc(v54, 0xDBBE9656uLL);
        if (v55)
        {
          v19 = sub_2096BC290();
          if ((_DWORD)v19)
          {
LABEL_23:
            checksum = v19;
            free(v55);
            v55 = 0;
            goto LABEL_4;
          }
          if (v54)
LABEL_47:
            heim_abort("ASN.1 internal error:data.length == size", v20, v21, v22, v23, v24, v25, v26, v51);
          LODWORD(v64) = *(_DWORD *)a2;
          if ((_DWORD)v64 != 1)
          {
            krb5_data_free(&v54);
            heim_abort("unknown FAST type, internal error:false", v44, v45, v46, v47, v48, v49, v50, v51);
          }
          *((_QWORD *)&v64 + 1) = *(_QWORD *)(a2 + 32);
          *(_QWORD *)(a2 + 32) = 0;
          v27 = *(_DWORD ***)(a2 + 48);
          if (!v27)
            heim_abort("FAST armor key missing when FAST started:state->armor_crypto != NULL", 0, v21, v22, v23, v24, v25, v26, v51);
          checksum = krb5_create_checksum(a1, v27, 0x32u, 0, a3[1], *a3, (uint64_t)v65);
          if ((_DWORD)checksum)
            goto LABEL_4;
          checksum = krb5_encrypt_EncryptedData(a1, *(_DWORD ***)(a2 + 48), 51, v55, v54, 0, (uint64_t)&v65[1] + 8);
          krb5_data_free(&v54);
          if ((_DWORD)checksum)
            goto LABEL_4;
          v54 = sub_2096BC314();
          v55 = malloc_type_malloc(v54, 0x9C6D5AFAuLL);
          if (v55)
          {
            v19 = sub_2096BC2F4();
            if ((_DWORD)v19)
              goto LABEL_23;
            v23 = v54;
            if (!v54)
            {
              checksum = krb5_padata_add(a1, *(unsigned int **)(a4 + 8), 136, (uint64_t)v55, 0);
              if (!(_DWORD)checksum)
                krb5_data_zero(&v54);
              goto LABEL_4;
            }
            goto LABEL_47;
          }
        }
LABEL_43:
        checksum = 12;
        goto LABEL_4;
      }
      v18 = malloc_type_calloc(1uLL, 0x10uLL, 0x1020040D5A9D86FuLL);
      *(_QWORD *)(a4 + 8) = v18;
      if (v18)
        goto LABEL_21;
LABEL_24:
      checksum = krb5_enomem(a1);
      goto LABEL_4;
    }
    sub_2096BBA28();
    v11 = strdup("WELLKNOWN:ANONYMOUS");
    *(_QWORD *)(a4 + 32) = v11;
    if (!v11)
      goto LABEL_24;
    v12 = malloc_type_calloc(1uLL, 0x18uLL, 0x10800407C14B876uLL);
    *(_QWORD *)(a4 + 24) = v12;
    if (v12)
    {
      *v12 = 1;
      v12[2] = 2;
      *(_QWORD *)(*(_QWORD *)(a4 + 24) + 16) = malloc_type_calloc(2uLL, 8uLL, 0x10040436913F5uLL);
      v13 = *(_QWORD **)(a4 + 24);
      v14 = (char **)v13[2];
      if (v14)
      {
        *v14 = strdup("WELLKNOWN");
        v15 = *(_QWORD **)(*(_QWORD *)(a4 + 24) + 16);
        if (*v15)
        {
          v15[1] = strdup("ANONYMOUS");
          v16 = *(_QWORD *)(*(_QWORD *)(a4 + 24) + 16);
          if (*(_QWORD *)(v16 + 8))
          {
LABEL_39:
            v28 = malloc_type_calloc(1uLL, 8uLL, 0x100004000313F17uLL);
            *(_QWORD *)(a4 + 56) = v28;
            *v28 = 0;
            if (a3)
              heim_abort("checksum data not NULL:checksum_data == NULL", v29, v30, v31, v32, v33, v34, v35, v51);
            v52 = sub_2096BBA18();
            v53 = malloc_type_malloc(v52, 0x8595DF09uLL);
            if (!v53)
              goto LABEL_43;
            v36 = sub_2096BB9F8();
            if ((_DWORD)v36)
            {
              checksum = v36;
              free(v53);
              v53 = 0;
              goto LABEL_4;
            }
            if (v52)
              heim_abort("ASN.1 internal error:aschecksum_data.length == size", v37, v38, v39, v40, v41, v42, v43, v51);
            a3 = (uint64_t *)&v52;
            goto LABEL_11;
          }
          v17 = *(void **)v16;
        }
        else
        {
          v17 = 0;
        }
        free(v17);
        free(*(void **)(*(_QWORD *)(*(_QWORD *)(a4 + 24) + 16) + 8));
        free(*(void **)(*(_QWORD *)(a4 + 24) + 16));
        v13 = *(_QWORD **)(a4 + 24);
      }
      free(v13);
    }
    checksum = krb5_enomem(a1);
    if ((_DWORD)checksum)
      goto LABEL_4;
    goto LABEL_39;
  }
LABEL_4:
  sub_2096BC2C0();
  sub_2096BC324();
  krb5_data_free(&v54);
  krb5_data_free(&v52);
  return checksum;
}

uint64_t sub_2096B78BC(_krb5_context *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8;
  _DWORD *padata;
  _DWORD *v10;
  _QWORD *v11;
  int v13;
  __int128 v14;
  __int128 v15;
  uint64_t v16;

  if (*(_QWORD *)(a2 + 48))
  {
    v16 = 0;
    v14 = 0u;
    v15 = 0u;
    if (*(_DWORD *)(a4 + 36) != -1765328293)
      sub_20969D1E8((uint64_t)a1, 10, "using fast but no FAST error code ?");
    v13 = 0;
    if (krb5_find_padata(*(_QWORD *)(a3 + 8), *(_DWORD *)a3, 136, &v13))
    {
      v8 = sub_2096B7A64(a1, a2);
      if ((_DWORD)v8)
      {
LABEL_15:
        sub_2096BC354();
        return v8;
      }
      v13 = 0;
      padata = krb5_find_padata(*((uint64_t *)&v14 + 1), v14, 137, &v13);
      if (padata)
      {
        v10 = padata;
        sub_2096BC0D0();
        v8 = krb5_rd_error(a1, (const krb5_data *)(v10 + 2), (krb5_error **)a4);
        if (!(_DWORD)v8)
        {
          v11 = *(_QWORD **)(a4 + 96);
          if (v11)
            sub_20969D1E8((uint64_t)a1, 10, "FAST wrapped KBB_ERROR contained e_data: %d", *v11);
          sub_2096BB9D4();
          v8 = 0;
          *(_QWORD *)(a3 + 8) = *((_QWORD *)&v14 + 1);
          *(_DWORD *)a3 = v14;
          *((_QWORD *)&v14 + 1) = 0;
          LODWORD(v14) = 0;
        }
        goto LABEL_15;
      }
      krb5_set_error_message(a1, -1765328237, "No wrapped error");
    }
    else
    {
      krb5_set_error_message(a1, -1765328237, "FAST fast respons is missing fx-fast data");
    }
    v8 = 2529639059;
    goto LABEL_15;
  }
  if ((*(_BYTE *)(a2 + 4) & 0x20) == 0)
    return 0;
  v8 = 2529638953;
  krb5_set_error_message(a1, -1765328343, "Expected FAST, but no FAST was in the response from the KDC");
  return v8;
}

uint64_t sub_2096B7A64(_krb5_context *a1, uint64_t a2)
{
  uint64_t v4;
  _QWORD v6[8];

  memset(&v6[2], 0, 40);
  v4 = sub_2096BC364();
  if (!(_DWORD)v4)
  {
    if (LODWORD(v6[2]) == 1)
    {
      v6[0] = 0;
      v6[1] = 0;
      v4 = krb5_decrypt_EncryptedData(a1, *(_QWORD *)(a2 + 48), 52, (uint64_t)&v6[3], v6);
      if (!(_DWORD)v4)
      {
        v4 = sub_2096BC334();
        krb5_data_free(v6);
      }
    }
    else
    {
      v4 = 2529638936;
    }
    sub_2096BC384();
  }
  return v4;
}

uint64_t sub_2096B7B24(krb5_context a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v8;
  uint64_t v11;
  const krb5_keyblock *v13;
  krb5_keyblock *v14;
  krb5_keyblock **v15;
  krb5_keyblock *v16;
  int v17;
  __int128 v18;
  krb5_keyblock *v19[2];
  uint64_t v20;

  v17 = 0;
  if (!a4)
    return 0;
  if (!*(_QWORD *)(a4 + 48)
    || (v8 = *(_QWORD *)(a5 + 8)) == 0
    || !krb5_find_padata(*(_QWORD *)(v8 + 8), *(_DWORD *)v8, 136, &v17))
  {
    if ((*(_BYTE *)(a4 + 4) & 0x20) != 0)
    {
      v11 = 2529638953;
      krb5_set_error_message(a1, -1765328343, "Expected FAST, but no FAST was in the response from the KDC");
      return v11;
    }
    return 0;
  }
  v20 = 0;
  v18 = 0u;
  *(_OWORD *)v19 = 0u;
  v11 = sub_2096B7A64(a1, a4);
  if (!(_DWORD)v11)
  {
    sub_2096BB9D4();
    v11 = sub_2096BB9E4();
    if (!(_DWORD)v11)
    {
      v13 = v19[0];
      if (!v19[0])
        goto LABEL_16;
      v16 = *(krb5_keyblock **)(a4 + 80);
      v15 = (krb5_keyblock **)(a4 + 80);
      v14 = v16;
      if (v16)
      {
        krb5_free_keyblock(a1, v14);
        v13 = v19[0];
      }
      v11 = krb5_copy_keyblock(a1, v13, v15);
      if (!(_DWORD)v11)
      {
LABEL_16:
        v11 = 2529638936;
        if ((_DWORD)v20 == a2)
        {
          if (v19[1])
          {
            v11 = sub_2096BB420();
            if (!(_DWORD)v11)
            {
              sub_2096BB410();
              *(_QWORD *)(a5 + 16) = 0;
              v11 = sub_2096BB494();
              if (!(_DWORD)v11)
              {
                sub_2096BB484();
                *(_OWORD *)(a5 + 24) = 0uLL;
                *(_QWORD *)(a5 + 40) = 0;
              }
            }
          }
          else if (a3)
          {
            v11 = 2529638936;
          }
          else
          {
            v11 = 0;
          }
        }
      }
    }
  }
  sub_2096BC354();
  return v11;
}

double sub_2096B7CE0(krb5_context a1, uint64_t a2)
{
  _krb5_ccache *v4;
  krb5_principal_data *v5;
  uint64_t v6;
  krb5_keyblock *v7;
  double result;

  v4 = *(_krb5_ccache **)(a2 + 16);
  if (v4)
    krb5_cc_close(a1, v4);
  v5 = *(krb5_principal_data **)(a2 + 40);
  if (v5)
    krb5_free_principal(a1, v5);
  v6 = *(_QWORD *)(a2 + 48);
  if (v6)
    krb5_crypto_destroy(a1, v6);
  v7 = *(krb5_keyblock **)(a2 + 80);
  if (v7)
    krb5_free_keyblock(a1, v7);
  krb5_free_keyblock_contents(a1, (krb5_keyblock *)(a2 + 56));
  if (*(_QWORD *)(a2 + 32))
  {
    sub_2096BC2D0();
    free(*(void **)(a2 + 32));
  }
  *(_QWORD *)(a2 + 80) = 0;
  result = 0.0;
  *(_OWORD *)(a2 + 48) = 0u;
  *(_OWORD *)(a2 + 64) = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  *(_OWORD *)(a2 + 32) = 0u;
  *(_OWORD *)a2 = 0u;
  return result;
}

uint64_t sub_2096B7D74(_QWORD *a1)
{
  return heim_ipc_init_context("ANY:org.h5l.armor-service", a1);
}

size_t base64_encode(uint64_t a1, unsigned int a2, const char **a3)
{
  const char *v6;
  char *v7;
  unint64_t v8;
  int v9;
  unint64_t v10;
  unint64_t v11;
  char v12;

  if (a2 >> 29 || (v6 = (const char *)malloc_type_malloc(4 * a2 / 3 + 4, 0x89873ABCuLL)) == 0)
  {
    *a3 = 0;
    return 0xFFFFFFFFLL;
  }
  else
  {
    v7 = (char *)v6;
    if (a2)
    {
      v8 = 1;
      v7 = (char *)v6;
      do
      {
        v9 = *(unsigned __int8 *)(a1 + v8 - 1) << 8;
        if (v8 < a2)
          v9 |= *(unsigned __int8 *)(a1 + v8);
        v10 = (v9 << 8);
        if (v8 + 1 < a2)
          v10 = v10 | *(unsigned __int8 *)(a1 + v8 + 1);
        v11 = v8 + 2;
        *v7 = aAbcdefghijklmn[(unint64_t)v10 >> 18];
        v7[1] = aAbcdefghijklmn[(v10 >> 12) & 0x3F];
        v7[2] = aAbcdefghijklmn[(v10 >> 6) & 0x3F];
        v12 = aAbcdefghijklmn[v10 & 0x3F];
        if (v8 + 2 > a2)
          v12 = 61;
        v7[3] = v12;
        if (v8 + 1 > a2)
          v7[2] = 61;
        v7 += 4;
        v8 += 3;
      }
      while (v11 < a2);
    }
    *v7 = 0;
    *a3 = v6;
    return strlen(v6);
  }
}

uint64_t base64_decode(char *__s, _BYTE *a2)
{
  int v2;
  _BYTE *v4;
  int v5;
  uint64_t v6;
  int v7;
  int v8;
  int v9;
  uint64_t v10;
  int v11;
  unsigned int v12;

  v2 = (int)a2;
  v4 = a2;
  while (1)
  {
    v5 = *__s;
    if (v5 != 61
      && (!*__s || !memchr("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", (char)v5, 0x41uLL)))
    {
      return ((_DWORD)v4 - v2);
    }
    if (strlen(__s) < 4)
      return 0xFFFFFFFFLL;
    v6 = 0;
    v7 = 0;
    v8 = 0;
    do
    {
      v8 <<= 6;
      v9 = __s[v6];
      if (v9 == 61)
      {
        ++v7;
      }
      else
      {
        if (v7 > 0)
          return 0xFFFFFFFFLL;
        v10 = 0;
        v11 = 65;
        while (v11 != v9)
        {
          v11 = aAbcdefghijklmn[++v10];
          if (v10 == 64)
          {
            LODWORD(v10) = -1;
            break;
          }
        }
        v8 += v10;
      }
      ++v6;
    }
    while (v6 != 4);
    if (v7 > 2)
      return 0xFFFFFFFFLL;
    v12 = v8 | (v7 << 24);
    if (v12 == -1)
      return 0xFFFFFFFFLL;
    *v4 = BYTE2(v8);
    if (v12 >> 25)
    {
      ++v4;
    }
    else
    {
      v4[1] = BYTE1(v8);
      if (HIBYTE(v12))
      {
        v4 += 2;
      }
      else
      {
        v4[2] = v8;
        v4 += 3;
      }
    }
    __s += 4;
  }
}

uint64_t sub_2096B7FDC(int a1)
{
  uint64_t result;

  result = fcntl(a1, 1);
  if ((_DWORD)result != -1)
    return fcntl(a1, 2, result | 1);
  return result;
}

uint64_t rk_cloexec_file(FILE *a1)
{
  int v1;

  v1 = fileno(a1);
  return sub_2096B7FDC(v1);
}

void *sub_2096B8038(size_t a1, size_t a2)
{
  void *result;

  result = malloc_type_calloc(a1, a2, 0x8B05E375uLL);
  if (!result)
  {
    if (a2 * a1)
      errx(1, "calloc %lu failed", a2 * a1);
  }
  return result;
}

void *sub_2096B808C(size_t a1)
{
  void *result;

  result = malloc_type_malloc(a1, 0xF09CB13uLL);
  if (a1)
  {
    if (!result)
      errx(1, "malloc %lu failed", a1);
  }
  return result;
}

void *sub_2096B80D8(void *a1, size_t a2)
{
  void *result;

  result = malloc_type_realloc(a1, a2, 0x3AE5F225uLL);
  if (a2)
  {
    if (!result)
      errx(1, "realloc %lu failed", a2);
  }
  return result;
}

char *rk_estrdup(const char *a1)
{
  char *result;

  result = strdup(a1);
  if (!result)
    sub_2096D7DC4();
  return result;
}

uint64_t rk_hex_encode(char *a1, uint64_t a2, _QWORD *a3)
{
  return sub_2096B8150(a1, a2, (uint64_t)&unk_2096D957A, a3);
}

uint64_t sub_2096B8150(char *a1, uint64_t a2, uint64_t a3, _QWORD *a4)
{
  uint64_t v6;
  char *v8;
  uint64_t v9;
  _BYTE *v10;
  char v11;

  if (a2 < 0)
  {
    v8 = 0;
    goto LABEL_8;
  }
  v6 = a2;
  v8 = (char *)malloc_type_malloc((2 * a2) | 1, 0x1E2051BBuLL);
  if (!v8)
  {
LABEL_8:
    v9 = -1;
    goto LABEL_11;
  }
  if (v6)
  {
    v9 = 2 * v6;
    v10 = v8 + 1;
    do
    {
      *(v10 - 1) = *(_BYTE *)(a3 + ((unint64_t)*a1 >> 4));
      v11 = *a1++;
      *v10 = *(_BYTE *)(a3 + (v11 & 0xF));
      v10 += 2;
      --v6;
    }
    while (v6);
  }
  else
  {
    v9 = 0;
  }
  v8[v9] = 0;
LABEL_11:
  *a4 = v8;
  return v9;
}

uint64_t rk_hex_decode(const char *a1, _BYTE *a2, size_t a3)
{
  unsigned __int8 *v5;
  size_t v6;
  size_t v7;
  unint64_t v9;
  unsigned __int8 v10;
  uint64_t v11;
  unsigned __int8 *v12;
  uint64_t v13;
  char v14;

  v5 = (unsigned __int8 *)a1;
  v6 = strlen(a1);
  v7 = v6 & 1;
  if (v7 + (v6 >> 1) > a3)
    return -1;
  v9 = v6;
  if ((v6 & 1) != 0)
  {
    v10 = *v5++;
    *a2++ = sub_2096B82A4(v10);
  }
  if (v9 >= 2)
  {
    if (v9 >> 1 <= 1)
      v11 = 1;
    else
      v11 = v9 >> 1;
    v12 = v5 + 1;
    v13 = v11;
    do
    {
      v14 = sub_2096B82A4(*(v12 - 1));
      *a2++ = sub_2096B82A4(*v12) | (16 * v14);
      v12 += 2;
      --v13;
    }
    while (v13);
  }
  else
  {
    v11 = 0;
  }
  return v11 + v7;
}

uint64_t sub_2096B82A4(unsigned __int8 a1)
{
  char v1;
  uint64_t result;
  int v3;

  v1 = __toupper(a1);
  result = 0;
  LOBYTE(v3) = 48;
  while (v1 != (char)v3)
  {
    v3 = byte_2096D957A[++result];
    if (!v3)
      return 0xFFFFFFFFLL;
  }
  return result;
}

ssize_t sub_2096B82F4(int a1, char *a2, size_t a3)
{
  size_t v6;
  ssize_t v7;
  ssize_t v8;

  if (!a3)
    return a3;
  v6 = a3;
  while (1)
  {
    while (1)
    {
      v7 = read(a1, a2, v6);
      v8 = v7;
      if ((v7 & 0x8000000000000000) == 0)
        break;
      if (*__error() != 4)
        return v8;
    }
    if (!v7)
      break;
    a2 += v7;
    v6 -= v7;
    if (!v6)
      return a3;
  }
  return v8;
}

size_t sub_2096B8374(int __fd, char *__buf, size_t __nbyte)
{
  size_t v3;
  size_t v6;
  ssize_t v7;
  ssize_t v8;

  v3 = __nbyte;
  if (__nbyte)
  {
    v6 = __nbyte;
    do
    {
      while (1)
      {
        v7 = write(__fd, __buf, v6);
        v8 = v7;
        if (v7 < 0)
          break;
        __buf += v7;
        v6 -= v7;
        if (!v6)
          return v3;
      }
    }
    while (*__error() == 4);
    return v8;
  }
  return v3;
}

uint64_t parse_bytes(char *a1, char *a2)
{
  return parse_units(a1, (const char **)&off_2545A4F88, a2);
}

uint64_t unparse_bytes(int a1, char *__str, size_t __size)
{
  return sub_2096B8748(a1, (uint64_t)&off_2545A4F88, __str, __size);
}

uint64_t unparse_bytes_short(int a1, char *__str, size_t __size)
{
  return sub_2096B886C(a1, (uint64_t)&off_2545A5028, __str, __size);
}

uint64_t parse_time(char *a1, char *a2)
{
  return parse_units(a1, (const char **)&off_2545A5068, a2);
}

uint64_t unparse_time(int a1, char *__str, size_t __size)
{
  return (int)sub_2096B8748(a1, (uint64_t)&off_2545A5068, __str, __size);
}

const char *print_time_table(FILE *a1)
{
  return sub_2096B8918((const char *)&off_2545A5068, a1);
}

uint64_t parse_units(char *a1, const char **a2, char *a3)
{
  return sub_2096B8488(a1, a2, a3, (uint64_t (*)(uint64_t, uint64_t, _QWORD))sub_2096B8700, 0, 0);
}

uint64_t sub_2096B8488(char *a1, const char **a2, char *a3, uint64_t (*a4)(uint64_t, uint64_t, _QWORD), uint64_t a5, int a6)
{
  const char *v9;
  const char **v11;
  const char *v12;
  int v13;
  uint64_t v14;
  char *v15;
  uint64_t v16;
  int v17;
  unsigned int v19;
  char *v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  BOOL v24;
  size_t v25;
  size_t v26;
  const char *v27;
  int v28;
  const char **v29;
  const char **v30;
  const char *v31;
  unsigned int v33;
  char *__endptr;

  if (a3)
  {
    v9 = *a2;
    if (!*a2)
      return 0xFFFFFFFFLL;
    v11 = a2 + 2;
    while (strcasecmp(v9, a3))
    {
      v12 = *v11;
      v11 += 2;
      v9 = v12;
      if (!v12)
        return 0xFFFFFFFFLL;
    }
    v13 = *((_DWORD *)v11 - 2);
  }
  else
  {
    v13 = 1;
  }
  if (!*a1)
    return a5;
  v33 = v13;
  v14 = MEMORY[0x24BDAC740];
  while (2)
  {
    __endptr = 0;
    v15 = a1 - 1;
    do
    {
      v16 = v15[1];
      if (v15[1] < 0)
        v17 = __maskrune(v15[1], 0x4000uLL);
      else
        v17 = *(_DWORD *)(v14 + 4 * v16 + 60) & 0x4000;
      ++v15;
    }
    while ((_DWORD)v16 == 44 || v17 != 0);
    v19 = strtol(v15, &__endptr, 0);
    v20 = __endptr;
    if (v15 == __endptr)
      v21 = 0;
    else
      v21 = v19;
    if (!a6 && v15 == __endptr)
      return 0xFFFFFFFFLL;
    a1 = __endptr;
    do
    {
      v22 = *a1;
      if (*a1 < 0)
        v23 = __maskrune(*a1, 0x4000uLL);
      else
        v23 = *(_DWORD *)(v14 + 4 * v22 + 60) & 0x4000;
      ++a1;
    }
    while (v23);
    switch((_DWORD)v22)
    {
      case 0x2B:
        LODWORD(v21) = 1;
        break;
      case 0x2D:
        LODWORD(v21) = -1;
        break;
      case 0:
        return a4(a5, v21, v33);
      default:
        --a1;
        break;
    }
    if ((_DWORD)v21)
      v24 = 0;
    else
      v24 = v15 == v20;
    if (v24)
      v21 = 1;
    else
      v21 = v21;
    v25 = strcspn(a1, ", \t");
    v26 = v25;
    if (v25 >= 2 && a1[v25 - 1] == 115)
      v26 = v25 - 1;
    v27 = *a2;
    if (!*a2)
      return 0xFFFFFFFFLL;
    v28 = 0;
    v29 = 0;
    v30 = a2;
    while (strncasecmp(a1, v27, v26))
    {
LABEL_50:
      v31 = v30[2];
      v30 += 2;
      v27 = v31;
      if (!v31)
        goto LABEL_51;
    }
    if (v26 != strlen(v27))
    {
      ++v28;
      v29 = v30;
      goto LABEL_50;
    }
    a5 = a4(a5, v21, *((unsigned int *)v30 + 2));
    if ((a5 & 0x80000000) != 0)
      return a5;
    a1 += v26;
    if (*v30)
      goto LABEL_54;
LABEL_51:
    if (v28 != 1)
      return 0xFFFFFFFFLL;
    a5 = a4(a5, v21, *((unsigned int *)v29 + 2));
    if ((a5 & 0x80000000) != 0)
      return a5;
    a1 += v26;
LABEL_54:
    if (*a1 == 115)
      ++a1;
    if (*a1)
      continue;
    return a5;
  }
}

uint64_t sub_2096B8700(int a1, int a2, int a3)
{
  return (a1 + a3 * a2);
}

uint64_t parse_flags(char *a1, const char **a2, uint64_t a3)
{
  return sub_2096B8488(a1, a2, 0, (uint64_t (*)(uint64_t, uint64_t, _QWORD))sub_2096B8720, a3, 1);
}

uint64_t sub_2096B8720(int a1, int a2, unsigned int a3)
{
  unsigned int v3;

  if (a2 == 1)
    v3 = a3 | a1;
  else
    v3 = -1;
  if (!a2)
    v3 = a3;
  if (a2 == -1)
    return a1 & ~a3;
  else
    return v3;
}

uint64_t sub_2096B8748(int a1, uint64_t a2, char *__str, size_t __size)
{
  size_t v4;
  char *v5;
  int v6;
  uint64_t v8;
  unsigned int v9;
  int v10;
  const char *v11;
  const char *v12;
  uint64_t v13;
  BOOL v14;

  v4 = __size;
  v5 = __str;
  if (!a1)
    return snprintf(__str, __size, "%s", "0");
  v6 = a1;
  if (a1 < 1)
    return 0;
  v8 = 0;
  while (*(_QWORD *)a2)
  {
    v9 = *(_DWORD *)(a2 + 8);
    if (v9 <= v6)
    {
      v10 = v6 / v9;
      v6 %= v9;
      if (v10 == 1)
        v11 = "";
      else
        v11 = "s";
      if (v6 <= 0)
        v12 = "";
      else
        v12 = " ";
      v13 = snprintf(v5, v4, "%u %s%s%s", v10, *(const char **)a2, v11, v12);
      if ((v13 & 0x80000000) != 0)
        return v13;
      v14 = (int)v13 <= (int)v4;
      if ((int)v13 <= (int)v4)
        v4 -= v13;
      else
        v4 = 0;
      if (v14)
        v5 += v13;
      else
        v5 = 0;
      v8 = (v13 + v8);
    }
    a2 += 16;
    if (v6 <= 0)
      return v8;
  }
  return v8;
}

uint64_t sub_2096B886C(int a1, uint64_t a2, char *__str, size_t __size)
{
  unsigned int v4;
  unsigned int *i;
  unsigned int v6;

  if (!a1)
    return snprintf(__str, __size, "%s");
  if (a1 >= 1 && *(_QWORD *)a2)
  {
    v4 = *(_DWORD *)(a2 + 8);
    if (v4 <= a1)
      return snprintf(__str, __size, "%u %s%s%s");
    for (i = (unsigned int *)(a2 + 24); *((_QWORD *)i - 1); i += 4)
    {
      v6 = *i;
      if (v6 <= a1)
        return snprintf(__str, __size, "%u %s%s%s");
    }
  }
  return 0;
}

const char *sub_2096B8918(const char *result, FILE *a2)
{
  uint64_t v2;
  const char *v4;
  size_t v5;
  uint64_t v6;
  size_t v7;
  const char *v8;
  const char *v9;
  unsigned int v10;
  const char *v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  char __str[1024];
  uint64_t v16;

  v16 = *MEMORY[0x24BDAC8D0];
  v2 = *(_QWORD *)result;
  if (*(_QWORD *)result)
  {
    v4 = result;
    v5 = 0;
    v6 = 16;
    result = *(const char **)result;
    do
    {
      v7 = strlen(result);
      if (v5 <= v7)
        v5 = v7;
      result = *(const char **)&v4[v6];
      v6 += 16;
    }
    while (result);
    if (v2)
    {
      do
      {
        v8 = v4;
        v9 = v4 + 16;
        do
        {
          v4 = v9;
          if (!*(_QWORD *)v9)
          {
            result = (const char *)fprintf(a2, "1 %s\n");
            goto LABEL_18;
          }
          v10 = *((_DWORD *)v8 + 2);
          v9 += 16;
        }
        while (*((_DWORD *)v4 + 2) == v10);
        v11 = v4;
        do
        {
          v12 = v10 % *((_DWORD *)v11 + 2);
          if (!v12)
            break;
          v13 = *((_QWORD *)v11 + 2);
          v11 += 16;
        }
        while (v13);
        if (v12)
          v14 = -1;
        else
          v14 = 0;
        sub_2096B8748(v10, (uint64_t)&v11[16 * v14], __str, 0x400uLL);
        result = (const char *)fprintf(a2, "1 %*s = %s\n");
LABEL_18:
        ;
      }
      while (*(_QWORD *)v4);
    }
  }
  return result;
}

uint64_t unparse_flags(int a1, uint64_t a2, char *__str, size_t __size)
{
  size_t v4;
  char *v5;
  uint64_t v7;
  unsigned int v8;
  int v9;
  const char *v10;
  uint64_t v11;
  BOOL v12;

  v4 = __size;
  v5 = __str;
  if (!a1)
    return snprintf(__str, __size, "%s", "");
  if (a1 < 1)
    return 0;
  v7 = 0;
  while (*(_QWORD *)a2)
  {
    v8 = *(_DWORD *)(a2 + 8);
    v9 = a1 - v8;
    if (a1 >= v8)
    {
      if (v9 <= 0)
        v10 = "";
      else
        v10 = ", ";
      v11 = snprintf(v5, v4, "%s%s", *(const char **)a2, v10);
      if ((v11 & 0x80000000) != 0)
        return v11;
      v12 = (int)v11 <= (int)v4;
      if ((int)v11 <= (int)v4)
        v4 -= v11;
      else
        v4 = 0;
      if (v12)
        v5 += v11;
      else
        v5 = 0;
      v7 = (v11 + v7);
      a1 = v9;
    }
    a2 += 16;
    if (a1 <= 0)
      return v7;
  }
  return v7;
}

const char **print_flags_table(const char **result, FILE *a2)
{
  const char *v2;
  const char **v4;
  const char *v5;
  const char *v6;

  v2 = *result;
  if (*result)
  {
    v4 = result + 2;
    do
    {
      if (*v4)
        v5 = ", ";
      else
        v5 = "\n";
      result = (const char **)fprintf(a2, "%s%s", v2, v5);
      v6 = *v4;
      v4 += 2;
      v2 = v6;
    }
    while (v6);
  }
  return result;
}

unsigned __int8 *rk_strlwr(unsigned __int8 *a1)
{
  __darwin_ct_rune_t v2;
  unsigned __int8 *v3;
  __darwin_ct_rune_t v4;

  v2 = *a1;
  if (v2)
  {
    v3 = a1 + 1;
    do
    {
      *(v3 - 1) = __tolower(v2);
      v4 = *v3++;
      v2 = v4;
    }
    while (v4);
  }
  return a1;
}

void sub_2096B8C14(void **a1)
{
  void *v2;

  v2 = *a1;
  if (v2)
    free(v2);
  free(a1);
}

void **rk_strpoolprintf(void **a1, char *a2, ...)
{
  void **v3;
  void **v4;
  int v5;
  int v6;
  char *v7;
  void *__src[2];
  va_list va;

  va_start(va, a2);
  v3 = a1;
  if (!a1)
  {
    v4 = (void **)malloc_type_malloc(0x10uLL, 0x1010040FDD9F14CuLL);
    v3 = v4;
    if (!v4)
      return v3;
    *v4 = 0;
    v4[1] = 0;
  }
  __src[0] = 0;
  va_copy((va_list)&__src[1], va);
  v5 = vasprintf((char **)__src, a2, va);
  if (__src[0] && (v6 = v5, (v7 = (char *)malloc_type_realloc(*v3, (size_t)v3[1] + v5 + 1, 0x21DB7AF2uLL)) != 0))
  {
    *v3 = v7;
    memcpy((char *)v3[1] + (_QWORD)v7, __src[0], v6 + 1);
    v3[1] = (char *)v3[1] + v6;
    free(__src[0]);
  }
  else
  {
    sub_2096B8C14(v3);
    return 0;
  }
  return v3;
}

char *rk_strpoolcollect(uint64_t *a1)
{
  uint64_t v1;

  if (!a1)
    return strdup("");
  v1 = *a1;
  free(a1);
  return (char *)v1;
}

uint64_t rk_strsep_copy(const char **a1, const char *a2, void *a3, size_t a4)
{
  const char *v4;
  size_t v8;
  const char *v9;
  uint64_t result;
  const char *v11;
  int v12;

  v4 = *a1;
  if (!*a1)
    return -1;
  v8 = strcspn(*a1, a2);
  v9 = &v4[v8];
  *a1 = &v4[v8];
  if (a4)
  {
    if (v8 < a4)
      a4 = v8;
    memcpy(a3, v4, a4);
    *((_BYTE *)a3 + a4) = 0;
    v9 = *a1;
  }
  result = v9 - v4;
  v12 = *(unsigned __int8 *)v9;
  v11 = v9 + 1;
  if (!v12)
    v11 = 0;
  *a1 = v11;
  return result;
}

unsigned __int8 *rk_strupr(unsigned __int8 *a1)
{
  __darwin_ct_rune_t v2;
  unsigned __int8 *v3;
  __darwin_ct_rune_t v4;

  v2 = *a1;
  if (v2)
  {
    v3 = a1 + 1;
    do
    {
      *(v3 - 1) = __toupper(v2);
      v4 = *v3++;
      v2 = v4;
    }
    while (v4);
  }
  return a1;
}

void sub_2096B8E14(_QWORD *a1)
{
  void *v2;
  uint64_t v3;
  uint64_t v4;

  v2 = (void *)a1[4];
  if (v2)
    free(v2);
  v3 = a1[6];
  if (v3)
  {
    do
    {
      v4 = *(_QWORD *)(v3 + 32);
      sub_2096B8E58((void **)v3);
      v3 = v4;
    }
    while (v4);
  }
  free(a1);
}

void sub_2096B8E58(void **a1)
{
  void *v2;
  void *v3;

  v2 = *a1;
  if (v2)
    free(v2);
  v3 = a1[3];
  if (v3)
    free(v3);
  free(a1);
}

_DWORD *sub_2096B8E90(const u_char *a1, uint64_t a2)
{
  _DWORD *v4;
  _DWORD *v5;
  int v6;
  u_char v7;
  unsigned int v8;
  unsigned int v9;
  const u_char *v10;
  int v11;
  unsigned int v12;
  char *v13;
  const u_char *v14;
  void ***v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  const u_char *v20;
  char __s1[1025];
  uint64_t v22;

  v22 = *MEMORY[0x24BDAC8D0];
  v4 = malloc_type_calloc(1uLL, 0x38uLL, 0x1030040EB7735E0uLL);
  v5 = v4;
  if (!v4)
    return v5;
  v20 = a1;
  *v4 = __rev16(*(unsigned __int16 *)a1);
  v4[1] = 0;
  v6 = a1[2] & 1;
  v4[1] = v6;
  v4[2] = (a1[2] >> 1) & 0xF;
  v7 = a1[2];
  if ((v7 & 0x20) == 0)
  {
    if ((a1[2] & 0x40) == 0)
      goto LABEL_4;
LABEL_15:
    v6 |= 4u;
    v4[1] = v6;
    if ((a1[2] & 0x80) == 0)
      goto LABEL_5;
    goto LABEL_16;
  }
  v6 |= 2u;
  v4[1] = v6;
  v7 = a1[2];
  if ((v7 & 0x40) != 0)
    goto LABEL_15;
LABEL_4:
  if ((v7 & 0x80) == 0)
    goto LABEL_5;
LABEL_16:
  v6 |= 8u;
  v4[1] = v6;
LABEL_5:
  v8 = a1[3];
  if ((v8 & 1) == 0)
  {
    if ((v8 & 4) == 0)
      goto LABEL_7;
LABEL_18:
    v6 |= 2u;
    v4[1] = v6;
    v8 = a1[3];
    if ((v8 & 8) == 0)
      goto LABEL_9;
    goto LABEL_8;
  }
  v6 |= 0x10u;
  v4[1] = v6;
  v8 = a1[3];
  if ((v8 & 4) != 0)
    goto LABEL_18;
LABEL_7:
  if ((v8 & 8) != 0)
  {
LABEL_8:
    v4[1] = v6 | 0x40;
    v8 = a1[3];
  }
LABEL_9:
  v4[3] = v8 >> 4;
  v9 = __rev16(*((unsigned __int16 *)a1 + 2));
  v4[4] = v9;
  v4[5] = __rev16(*((unsigned __int16 *)a1 + 3));
  v4[6] = __rev16(*((unsigned __int16 *)a1 + 4));
  v4[7] = __rev16(*((unsigned __int16 *)a1 + 5));
  if (v9 == 1)
  {
    v10 = &a1[a2];
    v11 = res_9_dn_expand(a1, v10, a1 + 12, __s1, 1025);
    if ((v11 & 0x80000000) == 0)
    {
      v12 = v11;
      v13 = strdup(__s1);
      *((_QWORD *)v5 + 4) = v13;
      if (v13)
      {
        v14 = &a1[v12 + 12];
        if (v14 + 4 <= v10)
        {
          v5[10] = __rev16(*(unsigned __int16 *)v14);
          v5[11] = __rev16(*((unsigned __int16 *)v14 + 1));
          v20 = v14 + 4;
          v16 = (void ***)(v5 + 12);
          if (v5[5])
          {
            v17 = 0;
            while (!sub_2096B913C(a1, v10, &v20, v16))
            {
              v16 = (void ***)(*v16 + 4);
              if (++v17 >= (unint64_t)v5[5])
                goto LABEL_27;
            }
          }
          else
          {
LABEL_27:
            if (v5[6])
            {
              v18 = 0;
              while (!sub_2096B913C(a1, v10, &v20, v16))
              {
                v16 = (void ***)(*v16 + 4);
                if (++v18 >= (unint64_t)v5[6])
                  goto LABEL_31;
              }
            }
            else
            {
LABEL_31:
              if (!v5[7])
              {
LABEL_35:
                *v16 = 0;
                return v5;
              }
              v19 = 0;
              while (!sub_2096B913C(a1, v10, &v20, v16))
              {
                v16 = (void ***)(*v16 + 4);
                if (++v19 >= (unint64_t)v5[7])
                  goto LABEL_35;
              }
            }
          }
        }
      }
    }
    sub_2096B8E14(v5);
  }
  else
  {
    free(v4);
  }
  return 0;
}

uint64_t sub_2096B913C(const u_char *a1, const u_char *a2, const u_char **a3, void ***a4)
{
  const u_char *v8;
  unsigned int v9;
  const u_char *v10;
  unsigned __int8 *v11;
  size_t v12;
  unsigned int v13;
  unsigned int v14;
  unsigned int v15;
  _DWORD *v16;
  char *v17;
  int v18;
  unsigned int v19;
  size_t v20;
  _DWORD *v21;
  char *v22;
  _DWORD *v23;
  void **v24;
  void *v25;
  const void *v26;
  char *v28;
  _DWORD *v29;
  uint64_t v30;
  char *v31;
  unsigned int v32;
  uint64_t v33;
  size_t v34;
  size_t v35;
  _DWORD *v36;
  size_t v37;
  size_t v38;
  malloc_type_id_t v39;
  unsigned int v40;
  void **v41;
  uint64_t result;
  _DWORD *v43;
  _DWORD *v44;
  const u_char *v45;
  _DWORD *v46;
  char __s1[1025];
  uint64_t v48;

  v48 = *MEMORY[0x24BDAC8D0];
  v8 = *a3;
  *a4 = 0;
  v9 = res_9_dn_expand(a1, a2, v8, __s1, 1025);
  if ((v9 & 0x80000000) != 0)
    return 0xFFFFFFFFLL;
  v10 = &v8[v9];
  v11 = (unsigned __int8 *)(v10 + 10);
  if (v10 + 10 > a2)
    return 0xFFFFFFFFLL;
  v12 = __rev16(*((unsigned __int16 *)v10 + 4));
  if (&v11[v12] > a2)
    return 0xFFFFFFFFLL;
  v45 = &v11[v12];
  v13 = *(unsigned __int16 *)v10;
  v14 = *((unsigned __int16 *)v10 + 1);
  v15 = *((_DWORD *)v10 + 1);
  v16 = malloc_type_calloc(1uLL, 0x28uLL, 0x10B2040F871B7ADuLL);
  if (!v16)
    return 0xFFFFFFFFLL;
  v46 = v16;
  v17 = strdup(__s1);
  *(_QWORD *)v46 = v17;
  if (!v17)
    goto LABEL_50;
  v18 = __rev16(v13);
  v46[2] = v18;
  v46[3] = __rev16(v14);
  v46[4] = bswap32(v15);
  v46[5] = v12;
  if (v18 <= 32)
  {
    switch(v18)
    {
      case 12:
        goto LABEL_23;
      case 13:
      case 14:
      case 17:
      case 19:
      case 20:
      case 21:
      case 22:
      case 23:
        goto LABEL_31;
      case 15:
      case 18:
        v19 = res_9_dn_expand(a1, a2, v10 + 12, __s1, 1025);
        if ((v19 & 0x80000000) != 0 || (unint64_t)v19 + 2 > v12)
          goto LABEL_48;
        v20 = strlen(__s1);
        v21 = malloc_type_malloc(v20 + 8, 0xFBC82BA4uLL);
        *((_QWORD *)v46 + 3) = v21;
        if (v21)
        {
          *v21 = __rev16(*((unsigned __int16 *)v10 + 5));
          v22 = (char *)(*((_QWORD *)v46 + 3) + 4);
          goto LABEL_59;
        }
        v41 = (void **)v46;
        goto LABEL_51;
      case 16:
        if (!(_DWORD)v12)
          goto LABEL_50;
        v30 = *v11;
        if (v12 <= v30)
          goto LABEL_50;
        v31 = (char *)malloc_type_malloc(v30 + 1, 0x969AA4F7uLL);
        *((_QWORD *)v46 + 3) = v31;
        if (v31)
        {
          strncpy(v31, (const char *)v10 + 11, v10[10]);
          v24 = (void **)v46;
          *(_BYTE *)(*((_QWORD *)v46 + 3) + v10[10]) = 0;
          goto LABEL_62;
        }
        v41 = (void **)v46;
        break;
      case 24:
        if (v12 <= 0x12)
          goto LABEL_50;
        v32 = res_9_dn_expand(a1, a2, v10 + 28, __s1, 1025);
        if ((v32 & 0x80000000) != 0)
          goto LABEL_48;
        v33 = v32;
        if ((unint64_t)v32 + 18 > v12)
          goto LABEL_48;
        v34 = v12 - v32 - 18;
        v35 = strlen(__s1);
        v36 = malloc_type_malloc(v34 + v35 + 56, 0xF7A76091uLL);
        v24 = (void **)v46;
        *((_QWORD *)v46 + 3) = v36;
        if (!v36)
          goto LABEL_63;
        *v36 = __rev16(*((unsigned __int16 *)v10 + 5));
        *(_DWORD *)(*((_QWORD *)v46 + 3) + 4) = v10[12];
        *(_DWORD *)(*((_QWORD *)v46 + 3) + 8) = v10[13];
        *(_DWORD *)(*((_QWORD *)v46 + 3) + 12) = bswap32(*(_DWORD *)(v10 + 14));
        *(_DWORD *)(*((_QWORD *)v46 + 3) + 16) = bswap32(*(_DWORD *)(v10 + 18));
        *(_DWORD *)(*((_QWORD *)v46 + 3) + 20) = bswap32(*(_DWORD *)(v10 + 22));
        *(_DWORD *)(*((_QWORD *)v46 + 3) + 24) = __rev16(*((unsigned __int16 *)v10 + 13));
        *(_QWORD *)(*((_QWORD *)v46 + 3) + 40) = v34;
        memcpy((void *)(*((_QWORD *)v46 + 3) + 48), &v10[v33 + 28], v34);
        *(_QWORD *)(*((_QWORD *)v46 + 3) + 32) = *((_QWORD *)v46 + 3) + v34 + 48;
        v22 = *(char **)(*((_QWORD *)v46 + 3) + 32);
        v37 = v35 + 1;
        goto LABEL_60;
      case 25:
        if (v12 <= 3)
          goto LABEL_50;
        v12 = (v12 - 4);
        v38 = v12 + 31;
        v39 = 399493579;
        goto LABEL_54;
      default:
        if (v18 != 2 && v18 != 5)
          goto LABEL_31;
LABEL_23:
        if (res_9_dn_expand(a1, a2, v10 + 10, __s1, 1025) < 0)
          goto LABEL_48;
        v28 = strdup(__s1);
        v24 = (void **)v46;
        *((_QWORD *)v46 + 3) = v28;
        if (!v28)
          goto LABEL_63;
        goto LABEL_62;
    }
    goto LABEL_51;
  }
  if (v18 > 42)
  {
    if (v18 == 43)
    {
      if (v12 > 3)
      {
        v12 = (v12 - 4);
        v38 = v12 + 31;
        v39 = 2013406956;
LABEL_54:
        v43 = malloc_type_malloc(v38, v39);
        v24 = (void **)v46;
        *((_QWORD *)v46 + 3) = v43;
        if (v43)
        {
          *v43 = __rev16(*((unsigned __int16 *)v10 + 5));
          *(_DWORD *)(*((_QWORD *)v46 + 3) + 4) = v10[12];
          *(_DWORD *)(*((_QWORD *)v46 + 3) + 8) = v10[13];
          *(_QWORD *)(*((_QWORD *)v46 + 3) + 16) = v12;
          v25 = (void *)(*((_QWORD *)v46 + 3) + 24);
          v26 = v10 + 14;
          goto LABEL_56;
        }
        goto LABEL_63;
      }
    }
    else
    {
      if (v18 != 44)
        goto LABEL_31;
      if (v12 > 1)
      {
        v12 = (v12 - 2);
        v29 = malloc_type_malloc(v12 + 23, 0x2A1AF827uLL);
        v24 = (void **)v46;
        *((_QWORD *)v46 + 3) = v29;
        if (v29)
        {
          *v29 = v10[10];
          *(_DWORD *)(*((_QWORD *)v46 + 3) + 4) = v10[11];
          *(_QWORD *)(*((_QWORD *)v46 + 3) + 8) = v12;
          v25 = (void *)(*((_QWORD *)v46 + 3) + 16);
          v26 = v10 + 12;
          goto LABEL_56;
        }
        goto LABEL_63;
      }
    }
LABEL_50:
    v41 = (void **)v46;
    goto LABEL_51;
  }
  if (v18 == 33)
  {
    v40 = res_9_dn_expand(a1, a2, v10 + 16, __s1, 1025);
    if ((v40 & 0x80000000) != 0 || (unint64_t)v40 + 6 > v12)
    {
LABEL_48:
      v41 = (void **)v46;
LABEL_51:
      sub_2096B8E58(v41);
      return 0xFFFFFFFFLL;
    }
    v20 = strlen(__s1);
    v44 = malloc_type_malloc(v20 + 16, 0xD5BF297uLL);
    v24 = (void **)v46;
    *((_QWORD *)v46 + 3) = v44;
    if (v44)
    {
      *v44 = __rev16(*((unsigned __int16 *)v10 + 5));
      *(_DWORD *)(*((_QWORD *)v46 + 3) + 4) = __rev16(*((unsigned __int16 *)v10 + 6));
      *(_DWORD *)(*((_QWORD *)v46 + 3) + 8) = __rev16(*((unsigned __int16 *)v10 + 7));
      v22 = (char *)(*((_QWORD *)v46 + 3) + 12);
LABEL_59:
      v37 = v20 + 1;
LABEL_60:
      strlcpy(v22, __s1, v37);
      goto LABEL_61;
    }
LABEL_63:
    v41 = v24;
    goto LABEL_51;
  }
  if (v18 == 37)
  {
    if (v12 > 4)
    {
      v12 = (v12 - 5);
      v23 = malloc_type_malloc(v12 + 31, 0xD3DF6AB1uLL);
      v24 = (void **)v46;
      *((_QWORD *)v46 + 3) = v23;
      if (v23)
      {
        *v23 = __rev16(*((unsigned __int16 *)v10 + 5));
        *(_DWORD *)(*((_QWORD *)v46 + 3) + 4) = __rev16(*((unsigned __int16 *)v10 + 6));
        *(_DWORD *)(*((_QWORD *)v46 + 3) + 8) = v10[14];
        *(_QWORD *)(*((_QWORD *)v46 + 3) + 16) = v12;
        v25 = (void *)(*((_QWORD *)v46 + 3) + 24);
        v26 = v10 + 15;
LABEL_56:
        memcpy(v25, v26, v12);
LABEL_61:
        v24 = (void **)v46;
        goto LABEL_62;
      }
      goto LABEL_63;
    }
    goto LABEL_50;
  }
LABEL_31:
  v25 = malloc_type_malloc(v12, 0xDB077A38uLL);
  v24 = (void **)v46;
  *((_QWORD *)v46 + 3) = v25;
  if ((_DWORD)v12 && !v25)
    goto LABEL_63;
  if ((_DWORD)v12)
  {
    v26 = v10 + 10;
    goto LABEL_56;
  }
LABEL_62:
  result = 0;
  *a3 = v45;
  *a4 = v24;
  return result;
}

_DWORD *sub_2096B9700(const char *a1, char *a2)
{
  const char *v4;
  char **v5;
  char *v6;
  uint32_t v7;
  dns_handle_t v8;
  const __dns_handle_private_struct *v9;
  char *v10;
  int32_t v11;
  FILE **v12;
  int v13;
  const char *v14;
  int *v15;
  int v16;
  char *v17;
  const char *v18;
  int *v19;
  int v20;
  _DWORD *v21;
  uint32_t fromlen;
  sockaddr from;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  uint64_t v32;

  v32 = *MEMORY[0x24BDAC8D0];
  v4 = "a";
  v5 = &off_24C1F2920;
  while (strcasecmp(a2, v4))
  {
    v6 = *v5;
    v5 += 2;
    v4 = v6;
    if (!v6)
      goto LABEL_29;
  }
  v7 = *((_DWORD *)v5 - 2);
  if (v7 == -1)
  {
LABEL_29:
    if (dword_2545A807C)
    return 0;
  }
  fromlen = 128;
  v8 = dns_open(0);
  if (v8)
  {
    v9 = v8;
    v10 = 0;
    v30 = 0u;
    v31 = 0u;
    v28 = 0u;
    v29 = 0u;
    v26 = 0u;
    v27 = 0u;
    v11 = 1500;
    from = (sockaddr)0;
    v25 = 0u;
    v12 = (FILE **)MEMORY[0x24BDAC8D8];
    while (1)
    {
      do
      {
        v13 = v11;
        if (v10)
          free(v10);
        if (dword_2545A807C)
        {
          dns_set_debug(v9, 1u);
          v14 = "a";
          if (v7 != 1)
          {
            v15 = &dword_24C1F2928;
            do
            {
              v14 = (const char *)*((_QWORD *)v15 - 1);
              if (!v14)
                break;
              v16 = *v15;
              v15 += 4;
            }
            while (v16 != v7);
          }
          fprintf(*v12, "dns_lookup(%s, %d, %s), buffer size %d\n", a1, 1, v14, v11);
        }
        v17 = (char *)malloc_type_malloc(v11, 0x29A30C81uLL);
        if (!v17)
        {
          dns_free(v9);
          return 0;
        }
        v10 = v17;
        v11 = dns_search(v9, a1, 1u, v7, v17, v11, &from, &fromlen);
        if (dword_2545A807C)
        {
          v18 = "a";
          if (v7 != 1)
          {
            v19 = &dword_24C1F2928;
            do
            {
              v18 = (const char *)*((_QWORD *)v19 - 1);
              if (!v18)
                break;
              v20 = *v19;
              v19 += 4;
            }
            while (v20 != v7);
          }
          fprintf(*v12, "dns_lookup(%s, %d, %s) --> %d\n", a1, 1, v18, v11);
        }
      }
      while (v11 > v13);
      if (v11 > 0)
      {
        v21 = sub_2096B8E90((const u_char *)v10, v11);
        free(v10);
        dns_free(v9);
        return v21;
      }
      if (v13 > 65534)
        break;
      if ((2 * v13) >= 0xFFFF)
        v11 = 0xFFFF;
      else
        v11 = 2 * v13;
    }
    dns_free(v9);
    free(v10);
  }
  return 0;
}

uint64_t sub_2096B9984(uint64_t a1)
{
  int v1;

  v1 = *(unsigned __int8 *)(a1 + 1);
  if (v1 == 2)
    return 4;
  else
    return 16 * (v1 == 30);
}

uint64_t rk_socket_sockaddr_size(uint64_t a1)
{
  int v1;
  unsigned int v2;

  v1 = *(unsigned __int8 *)(a1 + 1);
  if (v1 == 30)
    v2 = 28;
  else
    v2 = 0;
  if (v1 == 2)
    return 16;
  else
    return v2;
}

uint64_t sub_2096B99C4(uint64_t a1)
{
  int v1;

  v1 = *(unsigned __int8 *)(a1 + 1);
  if (v1 == 30 || v1 == 2)
    return *(unsigned __int16 *)(a1 + 2);
  else
    return 0;
}

uint64_t sub_2096B99E8(int a1, int a2)
{
  uint64_t result;

  result = fcntl(a1, 3, 0);
  if ((_DWORD)result != -1)
    return fcntl(a1, 4, result & 0xFFFFFFFB | (4 * (a2 != 0)));
  return result;
}

uint64_t rk_socket_set_nopipe(int a1, int a2)
{
  int v3;

  v3 = a2;
  return setsockopt(a1, 0xFFFF, 4130, &v3, 4u);
}

uint64_t rk_socket_set_reuseaddr(int a1, int a2)
{
  int v3;

  v3 = a2;
  return setsockopt(a1, 0xFFFF, 4, &v3, 4u);
}

uint64_t rk_socket_set_ipv6only(int a1, int a2)
{
  int v3;

  v3 = a2;
  return setsockopt(a1, 41, 27, &v3, 4u);
}

uint64_t sub_2096B9AD0(unsigned int a1)
{
  return bswap32(a1);
}

uint64_t sub_2096B9AD8(unsigned int a1)
{
  return __rev16(a1);
}

uint64_t sub_2096B9AE0(char *a1, const char *a2)
{
  const char *v3;
  unsigned int v4;
  const char *v5;
  unsigned int v6;
  uint64_t v7;
  unsigned int v9;
  void *v10;
  void *v11;
  unsigned int v12;
  char *v13;

  v13 = 0;
  v12 = 0;
  v10 = 0;
  v11 = 0;
  v9 = 0;
  sub_2096B9C4C(a2, (char **)&v11, &v9, (char **)&v10);
  v3 = (const char *)v10;
  if (v10)
  {
    if (a1)
    {
      sub_2096B9C4C(a1, &v13, &v12, 0);
      a1 = v13;
      v4 = v12;
      v3 = (const char *)v10;
    }
    else
    {
      v4 = 0;
    }
    v5 = (const char *)v11;
    v6 = v9;
    xmmword_2545A7DE8 = 0uLL;
    if (qword_2545A7DF8)
      free((void *)qword_2545A7DF8);
    qword_2545A7DF8 = 0;
    if (a1)
    {
      if (sub_2096B9F7C(a1))
        goto LABEL_13;
      WORD1(xmmword_2545A7DE8) = bswap32(v4) >> 16;
      if (asprintf((char **)&qword_2545A7DF8, "http://%s:%d%s", v5, (__int16)v6, v3) < 0)
        goto LABEL_13;
LABEL_16:
      v7 = 0;
      BYTE1(xmmword_2545A7DE8) = 2;
      goto LABEL_14;
    }
    if (!sub_2096B9F7C(v5))
    {
      WORD1(xmmword_2545A7DE8) = bswap32(v6) >> 16;
      asprintf((char **)&qword_2545A7DF8, "%s", v3);
      goto LABEL_16;
    }
  }
  a1 = 0;
LABEL_13:
  v7 = 0xFFFFFFFFLL;
LABEL_14:
  free(a1);
  free(v11);
  free(v10);
  return v7;
}

char *sub_2096B9C4C(const char *a1, char **a2, _DWORD *a3, char **a4)
{
  char *v7;
  char *v8;
  char *v9;
  char *result;
  char *v11;

  v7 = strdup(a1);
  *a2 = v7;
  v8 = strchr(v7, 58);
  if (!v8)
  {
    v9 = v7;
    goto LABEL_5;
  }
  *v8 = 0;
  v9 = v8 + 1;
  if (sscanf(v8 + 1, "%d", a3) != 1)
LABEL_5:
    *a3 = 80;
  result = strchr(v9, 47);
  if (result)
  {
    v11 = result;
    if (a4)
    {
      result = strdup(result);
      *a4 = result;
    }
    *v11 = 0;
  }
  else if (a4)
  {
    *a4 = 0;
  }
  return result;
}

uint64_t *sub_2096B9D00(const char *a1)
{
  uint64_t *result;

  result = (uint64_t *)gethostbyname(a1);
  if (!result)
    return sub_2096B9D34(a1);
  return result;
}

uint64_t *sub_2096B9D34(const char *a1)
{
  uint64_t *v1;
  int v2;
  int v3;
  size_t v4;
  int v5;
  char *v6;
  ssize_t v7;
  char *v8;
  char *v9;
  char *v10;
  unint64_t v11;
  _QWORD *v12;
  char *v13;
  unsigned int v14;
  in_addr v16;
  char *__lasts;
  char *__s;
  char __s1[1024];
  sockaddr v20;
  uint64_t v21;

  v21 = *MEMORY[0x24BDAC8D0];
  __s = 0;
  if (!BYTE1(xmmword_2545A7DE8))
    return 0;
  v20 = (sockaddr)xmmword_2545A7DE8;
  v1 = 0;
  if (asprintf(&__s, "GET %s?%s HTTP/1.0\r\n\r\n", (const char *)qword_2545A7DF8, a1) < 0 || !__s)
    return v1;
  v2 = socket(2, 1, 0);
  if (v2 < 0)
    goto LABEL_17;
  v3 = v2;
  rk_socket_set_nopipe(v2, 1);
  if (connect(v3, &v20, 0x10u) < 0 || (v4 = strlen(__s), write(v3, __s, v4) != v4))
  {
    close(v3);
LABEL_17:
    free(__s);
    return 0;
  }
  free(__s);
  v5 = 0;
  do
  {
    v6 = &__s1[v5];
    v7 = read(v3, v6, 1024 - v5);
    v5 += v7;
  }
  while (v7 > 0);
  *v6 = 0;
  close(v3);
  v8 = strstr(__s1, "\r\n\r\n");
  if (!v8)
    return 0;
  __lasts = 0;
  v9 = strtok_r(v8 + 4, " \t\r\n", &__lasts);
  if (!v9)
    return 0;
  v1 = &qword_2545A7E00;
  qword_2545A7E00 = (uint64_t)v9;
  *(_QWORD *)algn_2545A7E08 = 0;
  qword_2545A7E10 = 0x400000002;
  v10 = strtok_r(0, " \t\r\n", &__lasts);
  if (v10)
  {
    v11 = 0;
    v12 = &unk_2545A7E68;
    v13 = &byte_2545A7E20;
    do
    {
      v16.s_addr = 0;
      inet_aton(v10, &v16);
      v14 = bswap32(v16.s_addr);
      *(v12 - 1) = v13;
      *v12 = 0;
      *v13 = HIBYTE(v14);
      v13[1] = BYTE2(v14);
      v13[2] = BYTE1(v14);
      v13[3] = v14;
      v10 = strtok_r(0, " \t\r\n", &__lasts);
      if (v11 > 0xE)
        break;
      ++v11;
      ++v12;
      v13 += 4;
    }
    while (v10);
  }
  qword_2545A7E18 = (uint64_t)&qword_2545A7E60;
  return v1;
}

uint64_t sub_2096B9F7C(const char *a1)
{
  uint64_t result;
  hostent *v3;
  hostent *v4;

  if (inet_aton(a1, (in_addr *)&xmmword_2545A7DE8 + 1))
    return 0;
  v3 = gethostbyname(a1);
  if (!v3)
    return 0xFFFFFFFFLL;
  v4 = v3;
  result = 0;
  DWORD1(xmmword_2545A7DE8) = bswap32(**(_DWORD **)v4->h_addr_list);
  return result;
}

void *rtbl_create()
{
  return malloc_type_calloc(1uLL, 0x28uLL, 0x10900401E39FAC2uLL);
}

uint64_t rtbl_set_flags(uint64_t result, int a2)
{
  *(_DWORD *)(result + 24) = a2;
  return result;
}

uint64_t rtbl_get_flags(uint64_t a1)
{
  return *(unsigned int *)(a1 + 24);
}

void rtbl_destroy(uint64_t a1)
{
  unint64_t v2;
  uint64_t v3;
  unint64_t v4;

  if (*(_QWORD *)(a1 + 8))
  {
    v2 = 0;
    do
    {
      v3 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 8 * v2);
      if (*(_QWORD *)(v3 + 24))
      {
        v4 = 0;
        do
          free(*(void **)(*(_QWORD *)(v3 + 32) + 8 * v4++));
        while (v4 < *(_QWORD *)(v3 + 24));
      }
      free(*(void **)(v3 + 32));
      free(*(void **)v3);
      free(*(void **)(v3 + 8));
      free(*(void **)(v3 + 48));
      free((void *)v3);
      ++v2;
    }
    while (v2 < *(_QWORD *)(a1 + 8));
  }
  free(*(void **)a1);
  free(*(void **)(a1 + 32));
  free(*(void **)(a1 + 16));
  free((void *)a1);
}

uint64_t rtbl_add_column_by_id(uint64_t a1, int a2, const char *a3, int a4)
{
  void *v8;
  char **v9;
  char **v10;
  char *v11;
  uint64_t result;
  uint64_t v13;
  uint64_t v14;

  v8 = malloc_type_realloc(*(void **)(a1 + 16), 8 * *(_QWORD *)(a1 + 8) + 8, 0x2004093837F09uLL);
  if (v8)
  {
    *(_QWORD *)(a1 + 16) = v8;
    v9 = (char **)malloc_type_malloc(0x38uLL, 0x10300402987294FuLL);
    if (v9)
    {
      v10 = v9;
      v11 = strdup(a3);
      *v10 = v11;
      if (v11)
      {
        result = 0;
        v10[1] = 0;
        *((_DWORD *)v10 + 4) = 0;
        *((_DWORD *)v10 + 5) = a4;
        v10[3] = 0;
        v10[4] = 0;
        *((_DWORD *)v10 + 10) = a2;
        v10[6] = 0;
        v14 = *(_QWORD *)(a1 + 8);
        v13 = *(_QWORD *)(a1 + 16);
        *(_QWORD *)(a1 + 8) = v14 + 1;
        *(_QWORD *)(v13 + 8 * v14) = v10;
        return result;
      }
      free(v10);
    }
  }
  return 12;
}

uint64_t rtbl_add_column(uint64_t a1, const char *a2, int a3)
{
  return rtbl_add_column_by_id(a1, 0, a2, a3);
}

uint64_t rtbl_new_row(uint64_t a1)
{
  unint64_t v1;
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD *v9;
  _QWORD *v10;
  uint64_t v11;
  unint64_t v12;
  char *v13;

  v1 = *(_QWORD *)(a1 + 8);
  if (!v1)
    return 0;
  v3 = 0;
  v4 = 0;
  do
  {
    v5 = *(_QWORD *)(a1 + 16);
    if (*(_QWORD *)(*(_QWORD *)(v5 + 8 * v3) + 24) > v4)
      v4 = *(_QWORD *)(*(_QWORD *)(v5 + 8 * v3) + 24);
    ++v3;
  }
  while (v1 != v3);
  v6 = 0;
  v7 = *(_QWORD *)(a1 + 16);
  while (1)
  {
    v8 = *(_QWORD *)(v7 + 8 * v6);
    if (*(_QWORD *)(v8 + 24) != v4)
      break;
LABEL_14:
    if (++v6 >= v1)
      return 0;
  }
  v9 = malloc_type_realloc(*(void **)(v8 + 32), 8 * v4, 0x10040436913F5uLL);
  if (v9)
  {
    v10 = v9;
    v7 = *(_QWORD *)(a1 + 16);
    *(_QWORD *)(*(_QWORD *)(v7 + 8 * v6) + 32) = v9;
    while (1)
    {
      v11 = *(_QWORD *)(v7 + 8 * v6);
      v12 = *(_QWORD *)(v11 + 24);
      if (v12 >= v4)
        break;
      v13 = strdup("");
      *(_QWORD *)(v11 + 24) = v12 + 1;
      v10[v12] = v13;
      if (!v13)
        return 12;
    }
    v1 = *(_QWORD *)(a1 + 8);
    goto LABEL_14;
  }
  return 12;
}

uint64_t rtbl_set_prefix(void **a1, char *__s1)
{
  void *v4;
  char *v5;

  v4 = *a1;
  if (v4)
    free(v4);
  v5 = strdup(__s1);
  *a1 = v5;
  if (v5)
    return 0;
  else
    return 12;
}

uint64_t rtbl_set_separator(uint64_t a1, char *__s1)
{
  void *v4;
  char *v5;

  v4 = *(void **)(a1 + 32);
  if (v4)
    free(v4);
  v5 = strdup(__s1);
  *(_QWORD *)(a1 + 32) = v5;
  if (v5)
    return 0;
  else
    return 12;
}

uint64_t rtbl_set_column_prefix(uint64_t a1, char *a2, const char *a3)
{
  const char **v4;
  const char **v5;
  char *v6;
  char *v7;

  v4 = sub_2096BA384(a1, a2);
  if (!v4)
    return 0xFFFFFFFFLL;
  v5 = v4;
  v6 = (char *)v4[1];
  if (v6)
    free(v6);
  v7 = strdup(a3);
  v5[1] = v7;
  if (v7)
    return 0;
  else
    return 12;
}

const char **sub_2096BA384(uint64_t a1, char *__s2)
{
  uint64_t v2;
  const char ***i;
  const char **v5;

  v2 = *(_QWORD *)(a1 + 8);
  if (!v2)
    return 0;
  for (i = *(const char ****)(a1 + 16); ; ++i)
  {
    v5 = *i;
    if (!strcmp(**i, __s2))
      break;
    if (!--v2)
      return 0;
  }
  return v5;
}

uint64_t rtbl_set_column_affix_by_id(uint64_t a1, int a2, char *__s1, const char *a4)
{
  uint64_t v4;
  uint64_t *i;
  uint64_t v8;
  void *v10;
  char *v11;
  void *v12;
  char *v13;

  v4 = *(_QWORD *)(a1 + 8);
  if (!v4)
    return 0xFFFFFFFFLL;
  for (i = *(uint64_t **)(a1 + 16); ; ++i)
  {
    v8 = *i;
    if (*(_DWORD *)(*i + 40) == a2)
      break;
    if (!--v4)
      return 0xFFFFFFFFLL;
  }
  v10 = *(void **)(v8 + 8);
  if (v10)
    free(v10);
  if (__s1)
  {
    v11 = strdup(__s1);
    *(_QWORD *)(v8 + 8) = v11;
    if (!v11)
      return 12;
  }
  else
  {
    *(_QWORD *)(v8 + 8) = 0;
  }
  v12 = *(void **)(v8 + 48);
  if (v12)
    free(v12);
  if (a4)
  {
    v13 = strdup(a4);
    *(_QWORD *)(v8 + 48) = v13;
    if (!v13)
      return 12;
  }
  else
  {
    *(_QWORD *)(v8 + 48) = 0;
  }
  return 0;
}

uint64_t rtbl_add_column_entry_by_id(uint64_t a1, int a2, char *__s1)
{
  uint64_t v3;
  uint64_t *i;

  v3 = *(_QWORD *)(a1 + 8);
  if (!v3)
    return 0xFFFFFFFFLL;
  for (i = *(uint64_t **)(a1 + 16); *(_DWORD *)(*i + 40) != a2; ++i)
  {
    if (!--v3)
      return 0xFFFFFFFFLL;
  }
  return sub_2096BA4C4(*i, __s1);
}

uint64_t sub_2096BA4C4(uint64_t a1, char *__s1)
{
  char *v3;
  char *v4;
  _QWORD *v5;
  _QWORD *v6;
  uint64_t result;
  uint64_t v8;

  v3 = strdup(__s1);
  if (v3)
  {
    v4 = v3;
    v5 = malloc_type_realloc(*(void **)(a1 + 32), 8 * *(_QWORD *)(a1 + 24) + 8, 0x10040436913F5uLL);
    if (v5)
    {
      v6 = v5;
      result = 0;
      v8 = *(_QWORD *)(a1 + 24);
      *(_QWORD *)(a1 + 24) = v8 + 1;
      *(_QWORD *)(a1 + 32) = v6;
      v6[v8] = v4;
      return result;
    }
    free(v4);
  }
  return 12;
}

uint64_t rtbl_add_column_entryv_by_id(uint64_t a1, int a2, char *a3, ...)
{
  uint64_t v5;
  char *__s1[2];
  va_list va;

  va_start(va, a3);
  __s1[0] = 0;
  va_copy((va_list)&__s1[1], va);
  if (vasprintf(__s1, a3, va) == -1)
    return 0xFFFFFFFFLL;
  v5 = rtbl_add_column_entry_by_id(a1, a2, __s1[0]);
  free(__s1[0]);
  return v5;
}

uint64_t rtbl_add_column_entry(uint64_t a1, char *a2, char *a3)
{
  const char **v4;

  v4 = sub_2096BA384(a1, a2);
  if (v4)
    return sub_2096BA4C4((uint64_t)v4, a3);
  else
    return 0xFFFFFFFFLL;
}

uint64_t rtbl_add_column_entryv(uint64_t a1, char *a2, char *a3, ...)
{
  const char **v5;
  uint64_t v6;
  char *__s1[2];
  va_list va;

  va_start(va, a3);
  __s1[0] = 0;
  va_copy((va_list)&__s1[1], va);
  if (vasprintf(__s1, a3, va) == -1)
    return 0xFFFFFFFFLL;
  v5 = sub_2096BA384(a1, a2);
  if (v5)
    v6 = sub_2096BA4C4((uint64_t)v5, __s1[0]);
  else
    v6 = 0xFFFFFFFFLL;
  free(__s1[0]);
  return v6;
}

uint64_t rtbl_format(uint64_t a1, FILE *a2)
{
  char *v3;
  char *v4;

  v3 = rtbl_format_str(a1);
  if (!v3)
    return 12;
  v4 = v3;
  fputs(v3, a2);
  free(v4);
  return 0;
}

char *rtbl_format_str(uint64_t a1)
{
  int v2;
  unint64_t v3;
  uint64_t v4;
  int v5;
  uint64_t v6;
  const char **v7;
  const char *v8;
  int v9;
  unint64_t v10;
  void **v11;
  unint64_t i;
  uint64_t v13;
  const char *v14;
  void **v15;
  uint64_t v16;
  void **v17;
  const char *v18;
  void **v19;
  uint64_t v20;
  unint64_t v21;
  uint64_t v22;
  uint64_t v23;
  const char *v24;
  void **v25;
  unint64_t v26;
  int v27;
  unint64_t j;
  _QWORD *v29;
  uint64_t v30;
  unsigned int v31;
  int v32;
  const char *v33;
  uint64_t *v34;
  unint64_t v35;
  uint64_t v36;
  unint64_t v37;
  uint64_t v38;
  int v39;
  const char *v40;
  void **v41;
  const char *v42;

  v2 = *(_DWORD *)(a1 + 24);
  if ((v2 & 2) == 0)
  {
    if (*(_QWORD *)(a1 + 8))
    {
      v3 = 0;
      do
      {
        v4 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 8 * v3);
        if ((*(_BYTE *)(a1 + 24) & 1) != 0)
          v5 = 0;
        else
          v5 = strlen(*(const char **)v4);
        *(_DWORD *)(v4 + 16) = v5;
        v6 = *(_QWORD *)(v4 + 24);
        if (v6)
        {
          v7 = *(const char ***)(v4 + 32);
          do
          {
            v8 = *v7++;
            v9 = strlen(v8);
            if (v5 <= v9)
              v5 = v9;
            *(_DWORD *)(v4 + 16) = v5;
            --v6;
          }
          while (v6);
        }
        ++v3;
        v10 = *(_QWORD *)(a1 + 8);
      }
      while (v3 < v10);
      if ((*(_BYTE *)(a1 + 24) & 1) != 0)
      {
        v34 = 0;
        if (!v10)
          return rk_strpoolcollect(v34);
        goto LABEL_60;
      }
      v11 = 0;
      if (v10)
      {
        for (i = 0; i < *(_QWORD *)(a1 + 8); ++i)
        {
          v13 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 8 * i);
          if (i && *(_QWORD *)(a1 + 32))
            v11 = rk_strpoolprintf(v11, "%s", *(const char **)(a1 + 32));
          if (v13)
          {
            v14 = *(const char **)(v13 + 8);
            if (!v14)
            {
              v14 = *(const char **)a1;
              if (!*(_QWORD *)a1)
                v14 = "";
            }
            v15 = rk_strpoolprintf(v11, "%s", v14);
            if (i != *(_QWORD *)(a1 + 8) - 1 || (v16 = *(_QWORD *)(v13 + 48)) != 0)
              LODWORD(v16) = *(_DWORD *)(v13 + 16);
            v17 = rk_strpoolprintf(v15, "%-*s", v16, *(const char **)v13);
            v18 = *(const char **)(v13 + 48);
            if (v18)
              goto LABEL_30;
          }
          else
          {
            v17 = rk_strpoolprintf(v11, "%s", "");
          }
          v18 = "";
LABEL_30:
          v11 = rk_strpoolprintf(v17, "%s", v18);
        }
      }
    }
    else
    {
      v11 = 0;
      v34 = 0;
      if ((v2 & 1) != 0)
        return rk_strpoolcollect(v34);
    }
    v34 = (uint64_t *)rk_strpoolprintf(v11, "\n");
    v10 = *(_QWORD *)(a1 + 8);
    if (!v10)
      return rk_strpoolcollect(v34);
LABEL_60:
    v35 = 0;
    do
    {
      v36 = 0;
      while (*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 8 * v36) + 24) <= v35)
      {
        if (v10 == ++v36)
          return rk_strpoolcollect(v34);
      }
      v37 = 0;
      do
      {
        v38 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 8 * v37);
        if (v37 && *(_QWORD *)(a1 + 32))
          v34 = (uint64_t *)rk_strpoolprintf((void **)v34, "%s", *(const char **)(a1 + 32));
        v39 = *(_DWORD *)(v38 + 16);
        if ((*(_BYTE *)(v38 + 20) & 1) == 0)
        {
          if (v37 == *(_QWORD *)(a1 + 8) - 1 && !*(_QWORD *)(v38 + 48))
            v39 = 0;
          else
            v39 = -v39;
        }
        v40 = *(const char **)(v38 + 8);
        if (!v40)
        {
          v40 = *(const char **)a1;
          if (!*(_QWORD *)a1)
            v40 = "";
        }
        rk_strpoolprintf((void **)v34, "%s", v40);
        if (*(_QWORD *)(v38 + 24) <= v35)
          v41 = rk_strpoolprintf((void **)v34, "%*s", v39, "");
        else
          v41 = rk_strpoolprintf((void **)v34, "%*s", v39, *(const char **)(*(_QWORD *)(v38 + 32) + 8 * v35));
        v42 = *(const char **)(v38 + 48);
        if (!v42)
          v42 = "";
        v34 = (uint64_t *)rk_strpoolprintf(v41, "%s", v42);
        ++v37;
      }
      while (v37 < *(_QWORD *)(a1 + 8));
      v34 = (uint64_t *)rk_strpoolprintf((void **)v34, "\n");
      ++v35;
      v10 = *(_QWORD *)(a1 + 8);
    }
    while (v10);
    return rk_strpoolcollect(v34);
  }
  v19 = rk_strpoolprintf(0, "[");
  v20 = *(_QWORD *)(a1 + 8);
  if (v20)
  {
    v21 = 0;
    v22 = MEMORY[0x24BDAC740];
    do
    {
      v23 = *(_QWORD *)(a1 + 16);
      while (*(_QWORD *)(*(_QWORD *)v23 + 24) <= v21)
      {
        v23 += 8;
        if (!--v20)
          goto LABEL_55;
      }
      if (v21)
        v24 = ",";
      else
        v24 = "";
      v25 = rk_strpoolprintf(v19, "%s{", v24);
      v26 = *(_QWORD *)(a1 + 8);
      if (v26)
      {
        v27 = 0;
        for (j = 0; j < v26; ++j)
        {
          v29 = *(_QWORD **)(*(_QWORD *)(a1 + 16) + 8 * j);
          if (v29[3] > v21)
          {
            v30 = *v29 - 1;
            do
            {
              v31 = *(char *)(v30 + 1);
              if ((v31 & 0x80000000) != 0)
                v32 = __maskrune(v31, 0x4000uLL);
              else
                v32 = *(_DWORD *)(v22 + 4 * v31 + 60) & 0x4000;
              ++v30;
            }
            while (v32);
            if (v27)
              v33 = ",";
            else
              v33 = "";
            v25 = rk_strpoolprintf(v25, "%s\"%s\" : \"%s\"", v33, (const char *)v30, *(const char **)(v29[4] + 8 * v21));
            v26 = *(_QWORD *)(a1 + 8);
            v27 = 1;
          }
        }
      }
      v19 = rk_strpoolprintf(v25, "}");
      ++v21;
      v20 = *(_QWORD *)(a1 + 8);
    }
    while (v20);
  }
LABEL_55:
  v34 = (uint64_t *)rk_strpoolprintf(v19, "]");
  return rk_strpoolcollect(v34);
}

uint64_t rk_dumpdata(const char *a1, char *a2, size_t a3)
{
  uint64_t result;
  int v6;

  result = open(a1, 1537, 416);
  if ((result & 0x80000000) == 0)
  {
    v6 = result;
    sub_2096B8374(result, a2, a3);
    return close(v6);
  }
  return result;
}

uint64_t rk_undumpdata(const char *a1, void **a2, off_t *a3)
{
  int v5;
  int v6;
  uint64_t v7;
  char *v9;
  off_t st_size;
  ssize_t v11;
  stat v12;

  memset(&v12, 0, sizeof(v12));
  *a2 = 0;
  v5 = open(a1, 0, 0);
  if (v5 < 0)
    return *__error();
  v6 = v5;
  if (!fstat(v5, &v12))
  {
    v9 = (char *)malloc_type_malloc(v12.st_size, 0xD05A572EuLL);
    *a2 = v9;
    if (!v9)
    {
      v7 = 12;
      goto LABEL_4;
    }
    st_size = v12.st_size;
    *a3 = v12.st_size;
    v11 = sub_2096B82F4(v6, v9, st_size);
    if ((v11 & 0x8000000000000000) == 0)
    {
      if (v11 == *a3)
      {
        v7 = 0;
      }
      else
      {
        free(*a2);
        *a2 = 0;
        v7 = 22;
      }
      goto LABEL_4;
    }
  }
  v7 = *__error();
LABEL_4:
  close(v6);
  return v7;
}

BOOL ct_memcmp(unsigned __int8 *a1, unsigned __int8 *a2, uint64_t a3)
{
  int v3;
  int v4;
  int v5;
  int v6;

  if (!a3)
    return 0;
  v3 = 0;
  do
  {
    v5 = *a1++;
    v4 = v5;
    v6 = *a2++;
    v3 |= v6 ^ v4;
    --a3;
  }
  while (a3);
  return v3 != 0;
}

char *rk_cfstring2cstring(const __CFString *a1)
{
  const char *CStringPtr;
  CFIndex Length;
  CFIndex v5;
  void *v6;

  CStringPtr = CFStringGetCStringPtr(a1, 0x8000100u);
  if (CStringPtr)
    return strdup(CStringPtr);
  Length = CFStringGetLength(a1);
  v5 = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u) + 1;
  v6 = malloc_type_malloc(v5, 0xCC12B4F2uLL);
  if (v6)
  {
    if (!CFStringGetCString(a1, (char *)v6, v5, 0x8000100u))
    {
      free(v6);
      return 0;
    }
  }
  return (char *)v6;
}

uint64_t wind_utf8ucs4(char *a1, uint64_t a2, unint64_t *a3)
{
  unint64_t v5;
  uint64_t result;
  int v8;
  char *v9;

  v9 = a1;
  if (*a1)
  {
    v5 = 0;
    while (1)
    {
      v8 = 0;
      result = sub_2096BADD4(&v9, &v8);
      if ((_DWORD)result)
        break;
      if (a2)
      {
        if (v5 >= *a3)
          return 3325697538;
        *(_DWORD *)(a2 + 4 * v5) = v8;
      }
      ++v5;
      if (!*++v9)
        goto LABEL_10;
    }
  }
  else
  {
    v5 = 0;
LABEL_10:
    result = 0;
    *a3 = v5;
  }
  return result;
}

uint64_t sub_2096BADD4(char **a1, int *a2)
{
  char *v2;
  int v3;
  uint64_t v4;
  char v6;
  char v7;
  char v8;
  char v9;
  char v10;
  char v11;
  char v12;
  char v13;
  char v14;

  v2 = *a1;
  v3 = **a1;
  if ((**a1 & 0x80000000) == 0)
    goto LABEL_2;
  v4 = 3325697542;
  if ((v3 & 0xE0) == 0xC0)
  {
    v7 = *++v2;
    v6 = v7;
    if ((v7 & 0xC0) != 0x80)
      return v4;
    v3 = v6 & 0x3F | ((v3 & 0x1F) << 6);
    goto LABEL_2;
  }
  if ((v3 & 0xF0) == 0xE0)
  {
    v8 = v2[1];
    if ((v8 & 0xC0) == 0x80)
    {
      v10 = v2[2];
      v2 += 2;
      v9 = v10;
      if ((v10 & 0xC0) == 0x80)
      {
        v3 = ((v3 & 0xF) << 12) | ((v8 & 0x3F) << 6) | v9 & 0x3F;
LABEL_2:
        v4 = 0;
        *a2 = v3;
        *a1 = v2;
      }
    }
  }
  else if ((v3 & 0xF8) == 0xF0)
  {
    v11 = v2[1];
    if ((v11 & 0xC0) == 0x80)
    {
      v12 = v2[2];
      if ((v12 & 0xC0) == 0x80)
      {
        v14 = v2[3];
        v2 += 3;
        v13 = v14;
        if ((v14 & 0xC0) == 0x80)
        {
          v3 = ((v3 & 7) << 18) | ((v11 & 0x3F) << 12) | ((v12 & 0x3F) << 6) | v13 & 0x3F;
          goto LABEL_2;
        }
      }
    }
  }
  return v4;
}

uint64_t sub_2096BAEB8(char *a1, unint64_t *a2)
{
  return wind_utf8ucs4(a1, 0, a2);
}

uint64_t wind_utf8ucs4_copy(char *a1, void **a2, unint64_t *a3)
{
  uint64_t v6;
  unint64_t v7;
  void *v8;

  v6 = wind_utf8ucs4(a1, 0, a3);
  if (!(_DWORD)v6)
  {
    v7 = *a3;
    if (!(*a3 >> 30))
    {
      if (!v7)
        return 0;
      v8 = malloc_type_malloc(4 * v7, 0x100004052888210uLL);
      *a2 = v8;
      if (v8)
      {
        v6 = wind_utf8ucs4(a1, (uint64_t)v8, a3);
        if (!(_DWORD)v6)
          return v6;
        free(*a2);
        *a2 = 0;
      }
      else
      {
        v6 = 12;
      }
      *a3 = 0;
      return v6;
    }
    return 34;
  }
  return v6;
}

uint64_t wind_ucs4utf8(unsigned int *a1, uint64_t a2, _BYTE *a3, unint64_t *a4)
{
  uint64_t result;
  unint64_t i;
  unsigned int v7;
  unsigned int v8;
  uint64_t v9;
  char v10;

  result = 3325697538;
  for (i = 0; a2; --a2)
  {
    v8 = *a1++;
    v7 = v8;
    if (v8 >= 0x80)
    {
      if (v7 >= 0x800)
      {
        if (v7 >= 0x10000)
        {
          if (HIWORD(v7) > 0x10u)
            return 3325697544;
          v9 = 4u;
        }
        else
        {
          v9 = 3u;
        }
      }
      else
      {
        v9 = 2u;
      }
    }
    else
    {
      v9 = 1u;
    }
    i += v9;
    if (a3)
    {
      if (i >= *a4)
        return result;
      switch(v9)
      {
        case 1:
          goto LABEL_16;
        case 2:
          goto LABEL_15;
        case 3:
          goto LABEL_14;
        case 4:
          a3[3] = v7 & 0x3F | 0x80;
          LOBYTE(v7) = (_BYTE)v7 << 6;
LABEL_14:
          v10 = v7 & 0x3F | 0x80;
          LOBYTE(v7) = 0;
          a3[2] = v10;
LABEL_15:
          a3[1] = v7 & 0x3F | 0x80;
          LOBYTE(v7) = (_BYTE)v7 << 6;
LABEL_16:
          *a3 = *((_BYTE *)&unk_2096D95A4 + v9 - 1) | v7;
          break;
        default:
          break;
      }
      a3 += v9;
    }
  }
  if (a3)
  {
    if (i >= *a4)
      return result;
    *a3 = 0;
  }
  result = 0;
  *a4 = i;
  return result;
}

uint64_t sub_2096BB080(unsigned int *a1, uint64_t a2, unint64_t *a3)
{
  return wind_ucs4utf8(a1, a2, 0, a3);
}

uint64_t wind_ucs4utf8_copy(unsigned int *a1, uint64_t a2, void **a3, _QWORD *a4)
{
  uint64_t v8;
  _BYTE *v10;
  uint64_t v11;
  unint64_t v12;

  v12 = 0;
  v8 = wind_ucs4utf8(a1, a2, 0, &v12);
  if (!(_DWORD)v8)
  {
    v10 = malloc_type_malloc(++v12, 0xACAFD664uLL);
    *a3 = v10;
    if (v10)
    {
      v11 = wind_ucs4utf8(a1, a2, v10, &v12);
      if ((_DWORD)v11)
      {
        v8 = v11;
        free(*a3);
        *a3 = 0;
      }
      else
      {
        v8 = 0;
        if (a4)
          *a4 = v12;
      }
    }
    else
    {
      return 12;
    }
  }
  return v8;
}

uint64_t sub_2096BB150(unsigned __int16 *a1, uint64_t a2, unsigned int *a3, _WORD *a4, uint64_t *a5)
{
  uint64_t result;
  unsigned int v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  unsigned int v11;
  unsigned int v13;
  int v14;
  uint64_t v15;
  unsigned int v16;
  int v17;
  unsigned __int8 *v18;
  unsigned __int8 *v19;

  if (!a2)
  {
    v15 = 0;
LABEL_30:
    result = 0;
    *a5 = v15;
    return result;
  }
  result = 3325697538;
  if ((a2 & 1) != 0)
    return 3325697540;
  v7 = *a3;
  v8 = *a3 & 1;
  v9 = *a5;
  v10 = *a5;
  if ((*a3 & 4) == 0)
    goto LABEL_21;
  v11 = __rev16(*a1);
  if (v11 == 65279 || v11 == 65534)
  {
    v8 = v11 == 65534;
    v13 = v7 & 0xFFFFFFF8;
    if (v11 == 65534)
      v14 = 1;
    else
      v14 = 2;
    *a3 = v14 | v13;
    a2 -= 2;
    if (a2)
    {
      ++a1;
      goto LABEL_21;
    }
LABEL_29:
    v15 = v9 - v10;
    goto LABEL_30;
  }
  if ((v7 & 3) == 0)
    return 3325697545;
  v16 = v7 & 0xFFFFFFF8;
  if (v8)
    v17 = 1;
  else
    v17 = 2;
  *a3 = v17 | v16;
LABEL_21:
  while (v10)
  {
    if (v8)
      v18 = (unsigned __int8 *)a1;
    else
      v18 = (unsigned __int8 *)a1 + 1;
    if (v8)
      v19 = (unsigned __int8 *)a1 + 1;
    else
      v19 = (unsigned __int8 *)a1;
    *a4++ = *v18 | (*v19 << 8);
    ++a1;
    --v10;
    a2 -= 2;
    if (!a2)
      goto LABEL_29;
  }
  return result;
}

uint64_t wind_utf8ucs2(char *a1, uint64_t a2, unint64_t *a3)
{
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unsigned int v10;
  char *v11;

  v11 = a1;
  if (*a1)
  {
    v5 = 0;
    v6 = 3325697538;
    while (1)
    {
      v10 = 0;
      v7 = sub_2096BADD4(&v11, (int *)&v10);
      if ((_DWORD)v7)
        return v7;
      if (HIWORD(v10))
        return 3325697546;
      if (a2)
      {
        if (v5 >= *a3)
          return v6;
        *(_WORD *)(a2 + 2 * v5) = v10;
      }
      ++v5;
      if (!*++v11)
        goto LABEL_11;
    }
  }
  else
  {
    v5 = 0;
LABEL_11:
    v6 = 0;
    *a3 = v5;
  }
  return v6;
}

uint64_t wind_utf8ucs2_length(char *a1, unint64_t *a2)
{
  return wind_utf8ucs2(a1, 0, a2);
}

uint64_t wind_ucs2utf8(unsigned __int16 *a1, uint64_t a2, _BYTE *a3, unint64_t *a4)
{
  unint64_t i;
  unsigned int v5;
  unsigned int v6;
  uint64_t v7;
  char v8;
  uint64_t result;

  for (i = 0; a2; --a2)
  {
    v6 = *a1++;
    v5 = v6;
    if (v6 < 0x800)
      v7 = 2;
    else
      v7 = 3;
    if (v5 < 0x80)
      v7 = 1;
    i += v7;
    if (a3)
    {
      if (i >= *a4)
        return 3325697538;
      if (v7 != 1)
      {
        if (v7 != 2)
        {
          v8 = v5 & 0x3F | 0x80;
          LOBYTE(v5) = 0;
          a3[2] = v8;
        }
        a3[1] = v5 & 0x3F | 0x80;
        LOBYTE(v5) = (_BYTE)v5 << 6;
      }
      *a3 = *((_BYTE *)&unk_2096D95A4 + v7 - 1) | v5;
      a3 += v7;
    }
  }
  if (!a3)
    goto LABEL_18;
  if (i < *a4)
  {
    *a3 = 0;
LABEL_18:
    result = 0;
    *a4 = i;
    return result;
  }
  return 3325697538;
}

uint64_t wind_ucs2utf8_length(unsigned __int16 *a1, uint64_t a2, unint64_t *a3)
{
  return wind_ucs2utf8(a1, a2, 0, a3);
}

uint64_t sub_2096BB3C0()
{
  return _asn1_decode_top();
}

uint64_t sub_2096BB3E0()
{
  return _asn1_encode();
}

uint64_t sub_2096BB400()
{
  return _asn1_length();
}

uint64_t sub_2096BB410()
{
  return _asn1_free_top();
}

uint64_t sub_2096BB420()
{
  return _asn1_copy_top();
}

uint64_t sub_2096BB434()
{
  return _asn1_decode_top();
}

uint64_t sub_2096BB454()
{
  return _asn1_encode();
}

uint64_t sub_2096BB474()
{
  return _asn1_length();
}

uint64_t sub_2096BB484()
{
  return _asn1_free_top();
}

uint64_t sub_2096BB494()
{
  return _asn1_copy_top();
}

uint64_t decode_Principal()
{
  return _asn1_decode_top();
}

uint64_t encode_Principal()
{
  return _asn1_encode();
}

uint64_t length_Principal()
{
  return _asn1_length();
}

uint64_t free_Principal()
{
  return _asn1_free_top();
}

uint64_t copy_Principal()
{
  return _asn1_copy_top();
}

uint64_t sub_2096BB51C()
{
  return _asn1_free_top();
}

uint64_t sub_2096BB52C()
{
  return _asn1_copy_top();
}

uint64_t sub_2096BB540()
{
  return _asn1_copy_top();
}

uint64_t decode_KerberosTime()
{
  return _asn1_decode_top();
}

uint64_t encode_KerberosTime()
{
  return _asn1_encode();
}

uint64_t length_KerberosTime()
{
  return _asn1_length();
}

uint64_t free_KerberosTime()
{
  return _asn1_free_top();
}

uint64_t copy_KerberosTime()
{
  return _asn1_copy_top();
}

uint64_t sub_2096BB5C8()
{
  return _asn1_free_top();
}

uint64_t sub_2096BB5D8()
{
  return _asn1_decode_top();
}

uint64_t sub_2096BB5F8()
{
  return _asn1_encode();
}

uint64_t sub_2096BB618()
{
  return _asn1_length();
}

uint64_t sub_2096BB628()
{
  return _asn1_free_top();
}

uint64_t sub_2096BB638()
{
  return _asn1_copy_top();
}

uint64_t sub_2096BB64C(unsigned int *a1)
{
  void *v2;
  uint64_t result;

  v2 = malloc_type_realloc(*((void **)a1 + 1), 24 * *a1 + 24, 0xD518BC0uLL);
  if (!v2)
    return 12;
  *((_QWORD *)a1 + 1) = v2;
  result = _asn1_copy_top();
  if (!(_DWORD)result)
    ++*a1;
  return result;
}

uint64_t TicketFlags2int(uint64_t result)
{
  return (unsigned __int16)result;
}

uint64_t sub_2096BB6D0(int a1)
{
  return a1 & 0xDC01817F;
}

uint64_t sub_2096BB6E0()
{
  return _asn1_decode_top();
}

uint64_t sub_2096BB700()
{
  return _asn1_encode();
}

uint64_t sub_2096BB720()
{
  return _asn1_length();
}

uint64_t sub_2096BB730()
{
  return _asn1_free_top();
}

uint64_t decode_EncryptionKey()
{
  return _asn1_decode_top();
}

uint64_t encode_EncryptionKey()
{
  return _asn1_encode();
}

uint64_t length_EncryptionKey()
{
  return _asn1_length();
}

uint64_t free_EncryptionKey()
{
  return _asn1_free_top();
}

uint64_t copy_EncryptionKey()
{
  return _asn1_copy_top();
}

uint64_t decode_Ticket()
{
  return _asn1_decode_top();
}

uint64_t sub_2096BB7D4()
{
  return _asn1_encode();
}

uint64_t sub_2096BB7F4()
{
  return _asn1_length();
}

uint64_t free_Ticket()
{
  return _asn1_free_top();
}

uint64_t sub_2096BB814()
{
  return _asn1_copy_top();
}

uint64_t sub_2096BB828()
{
  return _asn1_decode_top();
}

uint64_t sub_2096BB848()
{
  return _asn1_free_top();
}

uint64_t sub_2096BB858()
{
  return _asn1_copy_top();
}

uint64_t sub_2096BB86C()
{
  return _asn1_decode_top();
}

uint64_t sub_2096BB88C()
{
  return _asn1_encode();
}

uint64_t sub_2096BB8AC()
{
  return _asn1_length();
}

uint64_t sub_2096BB8BC()
{
  return _asn1_free_top();
}

uint64_t sub_2096BB8CC()
{
  return _asn1_copy_top();
}

uint64_t sub_2096BB8E0()
{
  return _asn1_decode_top();
}

uint64_t sub_2096BB900()
{
  return _asn1_encode();
}

uint64_t sub_2096BB920()
{
  return _asn1_length();
}

uint64_t sub_2096BB930()
{
  return _asn1_free_top();
}

uint64_t sub_2096BB940()
{
  return _asn1_copy_top();
}

uint64_t sub_2096BB954()
{
  return _asn1_decode_top();
}

uint64_t sub_2096BB974()
{
  return _asn1_free_top();
}

uint64_t sub_2096BB984()
{
  return _asn1_decode_top();
}

uint64_t sub_2096BB9A4()
{
  return _asn1_free_top();
}

uint64_t sub_2096BB9B4()
{
  return _asn1_decode_top();
}

uint64_t sub_2096BB9D4()
{
  return _asn1_free_top();
}

uint64_t sub_2096BB9E4()
{
  return _asn1_copy_top();
}

uint64_t sub_2096BB9F8()
{
  return _asn1_encode();
}

uint64_t sub_2096BBA18()
{
  return _asn1_length();
}

uint64_t sub_2096BBA28()
{
  return _asn1_free_top();
}

uint64_t sub_2096BBA38()
{
  return _asn1_copy_top();
}

uint64_t sub_2096BBA4C()
{
  return _asn1_encode();
}

uint64_t sub_2096BBA6C()
{
  return _asn1_length();
}

uint64_t sub_2096BBA7C()
{
  return _asn1_free_top();
}

uint64_t sub_2096BBA8C()
{
  return _asn1_copy_top();
}

uint64_t sub_2096BBAA0()
{
  return _asn1_encode();
}

uint64_t sub_2096BBAC0()
{
  return _asn1_length();
}

uint64_t sub_2096BBAD0()
{
  return _asn1_free_top();
}

uint64_t sub_2096BBAE0()
{
  return _asn1_decode_top();
}

uint64_t sub_2096BBB00()
{
  return _asn1_encode();
}

uint64_t sub_2096BBB20()
{
  return _asn1_length();
}

uint64_t sub_2096BBB30()
{
  return _asn1_free_top();
}

uint64_t sub_2096BBB40()
{
  return _asn1_encode();
}

uint64_t sub_2096BBB60()
{
  return _asn1_length();
}

uint64_t sub_2096BBB70()
{
  return _asn1_free_top();
}

uint64_t sub_2096BBB80(unsigned int *a1)
{
  void *v2;
  uint64_t result;

  v2 = malloc_type_realloc(*((void **)a1 + 1), 24 * *a1 + 24, 0x581C3A74uLL);
  if (!v2)
    return 12;
  *((_QWORD *)a1 + 1) = v2;
  result = _asn1_copy_top();
  if (!(_DWORD)result)
    ++*a1;
  return result;
}

uint64_t sub_2096BBBFC()
{
  return _asn1_decode_top();
}

uint64_t sub_2096BBC1C()
{
  return _asn1_encode();
}

uint64_t sub_2096BBC3C()
{
  return _asn1_length();
}

uint64_t sub_2096BBC4C()
{
  return _asn1_free_top();
}

uint64_t sub_2096BBC5C()
{
  return _asn1_encode();
}

uint64_t sub_2096BBC7C()
{
  return _asn1_length();
}

uint64_t sub_2096BBC8C()
{
  return _asn1_free_top();
}

uint64_t sub_2096BBC9C()
{
  return _asn1_free_top();
}

uint64_t sub_2096BBCAC()
{
  return _asn1_decode_top();
}

uint64_t sub_2096BBCCC()
{
  return _asn1_free_top();
}

uint64_t sub_2096BBCDC()
{
  return _asn1_decode_top();
}

uint64_t sub_2096BBCFC()
{
  return _asn1_free_top();
}

uint64_t sub_2096BBD0C()
{
  return _asn1_copy_top();
}

uint64_t sub_2096BBD20()
{
  return _asn1_decode_top();
}

uint64_t sub_2096BBD40()
{
  return _asn1_free_top();
}

uint64_t sub_2096BBD50()
{
  return _asn1_decode_top();
}

uint64_t sub_2096BBD70()
{
  return _asn1_free_top();
}

uint64_t sub_2096BBD80()
{
  return _asn1_decode_top();
}

uint64_t sub_2096BBDA0()
{
  return _asn1_encode();
}

uint64_t sub_2096BBDC0()
{
  return _asn1_length();
}

uint64_t sub_2096BBDD0()
{
  return _asn1_free_top();
}

uint64_t sub_2096BBDE0()
{
  return _asn1_decode_top();
}

uint64_t sub_2096BBE00()
{
  return _asn1_encode();
}

uint64_t sub_2096BBE20()
{
  return _asn1_length();
}

uint64_t sub_2096BBE30()
{
  return _asn1_free_top();
}

uint64_t sub_2096BBE40()
{
  return _asn1_decode_top();
}

uint64_t sub_2096BBE60()
{
  return _asn1_encode();
}

uint64_t sub_2096BBE80()
{
  return _asn1_length();
}

uint64_t sub_2096BBE90()
{
  return _asn1_free_top();
}

uint64_t sub_2096BBEA0()
{
  return _asn1_decode_top();
}

uint64_t sub_2096BBEC0()
{
  return _asn1_encode();
}

uint64_t sub_2096BBEE0()
{
  return _asn1_length();
}

uint64_t sub_2096BBEF0()
{
  return _asn1_free_top();
}

uint64_t sub_2096BBF00()
{
  return _asn1_decode_top();
}

uint64_t sub_2096BBF20()
{
  return _asn1_encode();
}

uint64_t sub_2096BBF40()
{
  return _asn1_length();
}

uint64_t sub_2096BBF50()
{
  return _asn1_free_top();
}

uint64_t sub_2096BBF60()
{
  return _asn1_decode_top();
}

uint64_t sub_2096BBF80()
{
  return _asn1_encode();
}

uint64_t sub_2096BBFA0()
{
  return _asn1_length();
}

uint64_t sub_2096BBFB0()
{
  return _asn1_free_top();
}

uint64_t sub_2096BBFC0()
{
  return _asn1_decode_top();
}

uint64_t sub_2096BBFE0()
{
  return _asn1_encode();
}

uint64_t sub_2096BC000()
{
  return _asn1_length();
}

uint64_t sub_2096BC010()
{
  return _asn1_free_top();
}

uint64_t sub_2096BC020()
{
  return _asn1_decode_top();
}

uint64_t sub_2096BC040()
{
  return _asn1_encode();
}

uint64_t sub_2096BC060()
{
  return _asn1_length();
}

uint64_t sub_2096BC070()
{
  return _asn1_free_top();
}

uint64_t sub_2096BC080()
{
  return _asn1_decode_top();
}

uint64_t sub_2096BC0A0()
{
  return _asn1_encode();
}

uint64_t sub_2096BC0C0()
{
  return _asn1_length();
}

uint64_t sub_2096BC0D0()
{
  return _asn1_free_top();
}

uint64_t decode_ChangePasswdDataMS()
{
  return _asn1_decode_top();
}

uint64_t sub_2096BC100()
{
  return _asn1_encode();
}

uint64_t sub_2096BC120()
{
  return _asn1_length();
}

uint64_t free_ChangePasswdDataMS()
{
  return _asn1_free_top();
}

uint64_t sub_2096BC140()
{
  return _asn1_decode_top();
}

uint64_t sub_2096BC160()
{
  return _asn1_encode();
}

uint64_t sub_2096BC180()
{
  return _asn1_length();
}

uint64_t sub_2096BC190()
{
  return _asn1_free_top();
}

uint64_t sub_2096BC1A0()
{
  return _asn1_encode();
}

uint64_t sub_2096BC1C0()
{
  return _asn1_length();
}

uint64_t sub_2096BC1D0()
{
  return _asn1_encode();
}

uint64_t sub_2096BC1F0()
{
  return _asn1_length();
}

uint64_t sub_2096BC200()
{
  return _asn1_encode();
}

uint64_t sub_2096BC220()
{
  return _asn1_length();
}

uint64_t sub_2096BC230()
{
  return _asn1_decode_top();
}

uint64_t sub_2096BC250()
{
  return _asn1_free_top();
}

uint64_t sub_2096BC260()
{
  return _asn1_decode_top();
}

uint64_t sub_2096BC280()
{
  return _asn1_free_top();
}

uint64_t sub_2096BC290()
{
  return _asn1_encode();
}

uint64_t sub_2096BC2B0()
{
  return _asn1_length();
}

uint64_t sub_2096BC2C0()
{
  return _asn1_free_top();
}

uint64_t sub_2096BC2D0()
{
  return _asn1_free_top();
}

uint64_t sub_2096BC2E0()
{
  return _asn1_copy_top();
}

uint64_t sub_2096BC2F4()
{
  return _asn1_encode();
}

uint64_t sub_2096BC314()
{
  return _asn1_length();
}

uint64_t sub_2096BC324()
{
  return _asn1_free_top();
}

uint64_t sub_2096BC334()
{
  return _asn1_decode_top();
}

uint64_t sub_2096BC354()
{
  return _asn1_free_top();
}

uint64_t sub_2096BC364()
{
  return _asn1_decode_top();
}

uint64_t sub_2096BC384()
{
  return _asn1_free_top();
}

uint64_t free_KDCSRPState()
{
  return _asn1_free_top();
}

uint64_t decode_KDC_PROXY_MESSAGE()
{
  return _asn1_decode_top();
}

uint64_t encode_KDC_PROXY_MESSAGE()
{
  return _asn1_encode();
}

uint64_t length_KDC_PROXY_MESSAGE()
{
  return _asn1_length();
}

uint64_t sub_2096BC3F4()
{
  return _asn1_free_top();
}

uint64_t sub_2096BC404()
{
  return _asn1_free_top();
}

uint64_t sub_2096BC414()
{
  return _asn1_decode_top();
}

uint64_t sub_2096BC434()
{
  return _asn1_free_top();
}

uint64_t decode_KRB5_SRP_PA()
{
  return _asn1_decode_top();
}

uint64_t encode_KRB5_SRP_PA()
{
  return _asn1_encode();
}

uint64_t length_KRB5_SRP_PA()
{
  return _asn1_length();
}

uint64_t free_KRB5_SRP_PA()
{
  return _asn1_free_top();
}

uint64_t copy_KRB5_SRP_PA()
{
  return _asn1_copy_top();
}

uint64_t sub_2096BC4B8()
{
  return _asn1_decode_top();
}

uint64_t sub_2096BC4D8()
{
  return _asn1_free_top();
}

uint64_t sub_2096BC4E8()
{
  return _asn1_encode();
}

uint64_t sub_2096BC508()
{
  return _asn1_length();
}

uint64_t sub_2096BC518()
{
  return _asn1_free_top();
}

uint64_t sub_2096BC528()
{
  return _asn1_decode_top();
}

uint64_t sub_2096BC548()
{
  return _asn1_free_top();
}

uint64_t sub_2096BC558()
{
  return _asn1_encode();
}

uint64_t sub_2096BC578()
{
  return _asn1_length();
}

uint64_t sub_2096BC588()
{
  return _asn1_free_top();
}

uint64_t sub_2096BC598()
{
  return _asn1_decode_top();
}

uint64_t sub_2096BC5B8()
{
  return _asn1_free_top();
}

uint64_t sub_2096BC5C8()
{
  return _asn1_decode_top();
}

uint64_t sub_2096BC5E8()
{
  return _asn1_encode();
}

uint64_t sub_2096BC608()
{
  return _asn1_length();
}

uint64_t sub_2096BC618()
{
  return _asn1_free_top();
}

uint64_t sub_2096BC628()
{
  return _asn1_decode_top();
}

uint64_t sub_2096BC648()
{
  return _asn1_free_top();
}

uint64_t sub_2096BC658()
{
  return _asn1_decode_top();
}

uint64_t sub_2096BC678()
{
  return _asn1_free_top();
}

uint64_t sub_2096BC688()
{
  return _asn1_decode_top();
}

uint64_t sub_2096BC6A8()
{
  return _asn1_encode();
}

uint64_t sub_2096BC6C8()
{
  return _asn1_length();
}

uint64_t sub_2096BC6D8()
{
  return _asn1_free_top();
}

uint64_t sub_2096BC6E8()
{
  return _asn1_decode_top();
}

uint64_t sub_2096BC708()
{
  return _asn1_encode();
}

uint64_t sub_2096BC728()
{
  return _asn1_length();
}

uint64_t sub_2096BC738()
{
  return _asn1_free_top();
}

uint64_t sub_2096BC748()
{
  return _asn1_decode_top();
}

uint64_t sub_2096BC768()
{
  return _asn1_free_top();
}

uint64_t sub_2096BC778()
{
  return _asn1_decode_top();
}

uint64_t sub_2096BC798()
{
  return _asn1_encode();
}

uint64_t sub_2096BC7B8()
{
  return _asn1_length();
}

uint64_t sub_2096BC7C8()
{
  return _asn1_free_top();
}

uint64_t sub_2096BC7D8()
{
  return _asn1_decode_top();
}

uint64_t sub_2096BC7F8()
{
  return _asn1_encode();
}

uint64_t sub_2096BC818()
{
  return _asn1_length();
}

uint64_t sub_2096BC828()
{
  return _asn1_decode_top();
}

uint64_t sub_2096BC848()
{
  return _asn1_free_top();
}

uint64_t sub_2096BC858()
{
  return _asn1_encode();
}

uint64_t sub_2096BC878()
{
  return _asn1_length();
}

uint64_t sub_2096BC888()
{
  return _asn1_free_top();
}

uint64_t sub_2096BC898()
{
  return _asn1_encode();
}

uint64_t sub_2096BC8B8()
{
  return _asn1_length();
}

uint64_t sub_2096BC8C8()
{
  return _asn1_free_top();
}

uint64_t sub_2096BC8D8()
{
  return _asn1_decode_top();
}

uint64_t sub_2096BC8F8()
{
  return _asn1_encode();
}

uint64_t sub_2096BC918()
{
  return _asn1_length();
}

uint64_t sub_2096BC928()
{
  return _asn1_free_top();
}

uint64_t sub_2096BC938()
{
  return _asn1_decode_top();
}

uint64_t sub_2096BC958()
{
  return _asn1_free_top();
}

uint64_t sub_2096BC968()
{
  return _asn1_decode_top();
}

uint64_t sub_2096BC988()
{
  return _asn1_free_top();
}

uint64_t sub_2096BC998()
{
  return _asn1_decode_top();
}

uint64_t sub_2096BC9B8()
{
  return _asn1_free_top();
}

uint64_t sub_2096BC9C8()
{
  return _asn1_encode();
}

uint64_t sub_2096BC9E8()
{
  return _asn1_length();
}

uint64_t sub_2096BC9F8()
{
  return _asn1_free_top();
}

uint64_t sub_2096BCA08()
{
  return _asn1_encode();
}

uint64_t sub_2096BCA28()
{
  return _asn1_length();
}

uint64_t sub_2096BCA38()
{
  return _asn1_free_top();
}

uint64_t sub_2096BCA48()
{
  return _asn1_decode_top();
}

uint64_t sub_2096BCA68()
{
  return _asn1_free_top();
}

uint64_t sub_2096BCA78()
{
  return _asn1_decode_top();
}

uint64_t sub_2096BCA98()
{
  return _asn1_free_top();
}

uint64_t sub_2096BCAA8()
{
  return _asn1_decode_top();
}

uint64_t sub_2096BCAC8()
{
  return _asn1_free_top();
}

uint64_t sub_2096BCAD8()
{
  return _asn1_encode();
}

uint64_t sub_2096BCAF8()
{
  return _asn1_length();
}

uint64_t sub_2096BCB08()
{
  return _asn1_encode();
}

uint64_t sub_2096BCB28()
{
  return _asn1_length();
}

const char *__cdecl error_message(errcode_t code)
{
  _BYTE *v2;

  v2 = com_right((_QWORD *)qword_2545A8080, code);
  if (!v2)
  {
    if (code < 0)
    {
      snprintf(byte_2545A7EE8, 0x80uLL, "Unknown error %ld", code);
      goto LABEL_8;
    }
    v2 = strerror(code);
    if (!v2)
      goto LABEL_8;
  }
  if (!*v2)
  {
LABEL_8:
    snprintf(byte_2545A7EE8, 0x80uLL, "Unknown error %ld", code);
    return byte_2545A7EE8;
  }
  __strlcpy_chk();
  return byte_2545A7EE8;
}

uint64_t init_error_table(uint64_t a1, uint64_t a2, int a3)
{
  initialize_error_table_r(&qword_2545A8080, a1, a3, a2);
  return 0;
}

void com_err_va(const char *progname, errcode_t code, const char *format, va_list args)
{
  off_253D3AEB8((int)progname, code, (char *)format, args);
}

void com_err(const char *progname, errcode_t code, const char *format, ...)
{
  va_list va;

  va_start(va, format);
  off_253D3AEB8((int)progname, code, (char *)format, va);
}

com_err_handler_t set_com_err_hook(com_err_handler_t handler)
{
  void (__cdecl *v1)(const char *, errcode_t, const char *, va_list);
  uint64_t (*v2)(int, errcode_t, char *, va_list);

  v1 = (void (__cdecl *)(const char *, errcode_t, const char *, va_list))off_253D3AEB8;
  v2 = (uint64_t (*)(int, errcode_t, char *, va_list))sub_2096BCC74;
  if (handler)
    v2 = (uint64_t (*)(int, errcode_t, char *, va_list))handler;
  off_253D3AEB8 = v2;
  return v1;
}

size_t sub_2096BCC74(const char *a1, errcode_t code, char *a3, va_list a4)
{
  FILE **v7;
  FILE *v8;

  v7 = (FILE **)MEMORY[0x24BDAC8D8];
  if (a1)
    fprintf((FILE *)*MEMORY[0x24BDAC8D8], "%s: ", a1);
  if (code)
  {
    v8 = *v7;
    error_message(code);
    fprintf(v8, "%s ", byte_2545A7EE8);
  }
  if (a3)
    vfprintf(*v7, a3, a4);
  return fwrite("\r\n", 2uLL, 1uLL, *v7);
}

com_err_handler_t reset_com_err_hook(void)
{
  com_err_handler_t result;

  result = (com_err_handler_t)off_253D3AEB8;
  off_253D3AEB8 = (uint64_t (*)(int, errcode_t, char *, va_list))sub_2096BCC74;
  return result;
}

_QWORD *com_right(_QWORD *result, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;

  if (result)
  {
    while (1)
    {
      v2 = result[1];
      v3 = *(_QWORD *)(v2 + 8);
      if (a2 >= v3 && v3 + *(int *)(v2 + 16) > a2)
        break;
      result = (_QWORD *)*result;
      if (!result)
        return result;
    }
    return *(_QWORD **)(*(_QWORD *)v2 + 8 * (a2 - v3));
  }
  return result;
}

char *com_right_r(_QWORD *a1, uint64_t a2, char *__dst, size_t __size)
{
  char *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  const char *v9;

  if (!a1)
    return 0;
  v4 = __dst;
  while (1)
  {
    v5 = a1[1];
    v6 = *(_QWORD *)(v5 + 8);
    v7 = a2 - v6;
    if (a2 >= v6 && v6 + *(int *)(v5 + 16) > a2)
      break;
    a1 = (_QWORD *)*a1;
    if (!a1)
      return 0;
  }
  v9 = *(const char **)(*(_QWORD *)v5 + 8 * v7);
  if (v9)
    strlcpy(__dst, v9, __size);
  else
    snprintf(__dst, __size, "Reserved error code %ld in base %ld", v7, v6);
  return v4;
}

_QWORD *initialize_error_table_r(_QWORD *result, uint64_t a2, int a3, uint64_t a4)
{
  _QWORD *v7;
  _QWORD *v8;

  v7 = result;
  while (1)
  {
    v8 = (_QWORD *)*v7;
    if (!*v7)
      break;
    v7 = (_QWORD *)*v7;
    if (*(_QWORD *)v8[1] == a2)
      return result;
  }
  result = malloc_type_malloc(0x28uLL, 0x10E00406AA87185uLL);
  if (result)
  {
    result[2] = a2;
    *((_DWORD *)result + 8) = a3;
    result[3] = a4;
    *result = 0;
    result[1] = result + 2;
    *v7 = result;
  }
  return result;
}

_QWORD *sub_2096BCE90(_QWORD *result)
{
  _QWORD *v1;

  if (result)
  {
    do
    {
      v1 = (_QWORD *)*result;
      free(result);
      result = v1;
    }
    while (v1);
  }
  return result;
}

void initialize_asn1_error_table(void)
{
  init_error_table((uint64_t)off_2545A5480, 1859794432, 21);
}

_QWORD *initialize_gk5_error_table_r(_QWORD *a1)
{
  return initialize_error_table_r(a1, (uint64_t)off_2545A5530, 137, 35224064);
}

uint64_t initialize_gk5_error_table()
{
  return init_error_table((uint64_t)off_2545A5530, 35224064, 137);
}

_QWORD *initialize_hdb_error_table_r(_QWORD *a1)
{
  return initialize_error_table_r(a1, (uint64_t)&unk_2545A5980, 18, 36150272);
}

_QWORD *initialize_heim_error_table_r(_QWORD *a1)
{
  return initialize_error_table_r(a1, (uint64_t)off_2545A5A18, 226, -1980176640);
}

uint64_t initialize_heim_error_table()
{
  return init_error_table((uint64_t)off_2545A5A18, -1980176640, 226);
}

_QWORD *initialize_hx_error_table_r(_QWORD *a1)
{
  return initialize_error_table_r(a1, (uint64_t)off_2545A6130, 135, 569856);
}

uint64_t initialize_hx_error_table()
{
  return init_error_table((uint64_t)off_2545A6130, 569856, 135);
}

_QWORD *initialize_k524_error_table_r(_QWORD *a1)
{
  return initialize_error_table_r(a1, (uint64_t)off_2545A6570, 8, -1750206208);
}

void initialize_k524_error_table(void)
{
  init_error_table((uint64_t)off_2545A6570, -1750206208, 8);
}

_QWORD *initialize_krb5_error_table_r(_QWORD *a1)
{
  return initialize_error_table_r(a1, (uint64_t)off_2545A65B8, 251, -1765328384);
}

void initialize_krb5_error_table(void)
{
  init_error_table((uint64_t)off_2545A65B8, -1765328384, 251);
}

_QWORD *initialize_wind_error_table_r(_QWORD *a1)
{
  return initialize_error_table_r(a1, (uint64_t)off_2545A6D98, 11, -969269760);
}

uint64_t initialize_wind_error_table()
{
  return init_error_table((uint64_t)off_2545A6D98, -969269760, 11);
}

_QWORD *initialize_krb_error_table_r(_QWORD *a1)
{
  return initialize_error_table_r(a1, (uint64_t)off_2545A6DF8, 82, 39525376);
}

uint64_t initialize_krb_error_table()
{
  return init_error_table((uint64_t)off_2545A6DF8, 39525376, 82);
}

uint64_t hx509_ca_tbs_init(uint64_t a1, _QWORD *a2)
{
  void *v3;

  v3 = malloc_type_calloc(1uLL, 0xC0uLL, 0x10B004050FA1AF2uLL);
  *a2 = v3;
  if (v3)
    return 0;
  else
    return 12;
}

void hx509_ca_tbs_free(void ***a1)
{
  void **v2;

  if (a1)
  {
    if (*a1)
    {
      free_SubjectPublicKeyInfo();
      sub_2096D2480();
      sub_2096D272C();
      der_free_heim_integer();
      sub_2096D27FC();
      der_free_bit_string();
      der_free_bit_string();
      hx509_name_free(*a1);
      v2 = *a1;
      *((_OWORD *)v2 + 10) = 0u;
      *((_OWORD *)v2 + 11) = 0u;
      *((_OWORD *)v2 + 8) = 0u;
      *((_OWORD *)v2 + 9) = 0u;
      *((_OWORD *)v2 + 6) = 0u;
      *((_OWORD *)v2 + 7) = 0u;
      *((_OWORD *)v2 + 4) = 0u;
      *((_OWORD *)v2 + 5) = 0u;
      *((_OWORD *)v2 + 2) = 0u;
      *((_OWORD *)v2 + 3) = 0u;
      *(_OWORD *)v2 = 0u;
      *((_OWORD *)v2 + 1) = 0u;
      free(*a1);
      *a1 = 0;
    }
  }
}

uint64_t hx509_ca_tbs_set_notBefore(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(a2 + 120) = a3;
  return 0;
}

uint64_t hx509_ca_tbs_set_notAfter(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(a2 + 128) = a3;
  return 0;
}

uint64_t hx509_ca_tbs_set_notAfter_lifetime(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(a2 + 128) = time(0) + a3;
  return 0;
}

char **hx509_ca_tbs_template_units()
{
  return &off_24C1F63B0;
}

uint64_t hx509_ca_tbs_set_template(uint64_t a1, uint64_t a2, char a3, uint64_t a4)
{
  uint64_t subject;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t SPKI;
  const char *v14;
  uint64_t serialnumber;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  _QWORD v21[2];

  if ((a3 & 1) != 0)
  {
    if (*(_QWORD *)a2)
      hx509_name_free((void **)a2);
    subject = hx509_cert_get_subject(a4, (void **)a2);
    if ((_DWORD)subject)
    {
      SPKI = subject;
      v14 = "Failed to get subject from template";
LABEL_9:
      hx509_set_error_string(a1, 0, SPKI, v14, v9, v10, v11, v12, v21[0]);
      return SPKI;
    }
  }
  if ((a3 & 2) != 0)
  {
    der_free_heim_integer();
    serialnumber = hx509_cert_get_serialnumber();
    *(_BYTE *)(a2 + 112) = *(_BYTE *)(a2 + 112) & 0xF7 | (8 * ((_DWORD)serialnumber == 0));
    if ((_DWORD)serialnumber)
    {
      SPKI = serialnumber;
      v14 = "Failed to copy serial number";
      goto LABEL_9;
    }
  }
  if ((a3 & 4) != 0)
  {
    *(_QWORD *)(a2 + 120) = hx509_cert_get_notBefore(a4);
    if ((a3 & 8) == 0)
    {
LABEL_12:
      if ((a3 & 0x10) == 0)
        goto LABEL_17;
      goto LABEL_16;
    }
  }
  else if ((a3 & 8) == 0)
  {
    goto LABEL_12;
  }
  *(_QWORD *)(a2 + 128) = hx509_cert_get_notAfter(a4);
  if ((a3 & 0x10) == 0)
    goto LABEL_17;
LABEL_16:
  free_SubjectPublicKeyInfo();
  SPKI = hx509_cert_get_SPKI(a1);
  *(_BYTE *)(a2 + 112) = *(_BYTE *)(a2 + 112) & 0xFB | (4 * ((_DWORD)SPKI == 0));
  if ((_DWORD)SPKI)
    return SPKI;
LABEL_17:
  if ((a3 & 0x20) != 0)
  {
    LODWORD(v21[0]) = 0;
    v16 = sub_2096C1BE0(a1, a4, v21);
    if ((_DWORD)v16)
      return v16;
    *(_DWORD *)(a2 + 80) = sub_2096D255C(v21[0]);
  }
  if ((a3 & 0x40) == 0)
    return 0;
  v21[0] = 0;
  v21[1] = 0;
  SPKI = sub_2096C1C68(a1, a4, v21);
  if ((_DWORD)SPKI)
    return SPKI;
  if (!LODWORD(v21[0]))
  {
LABEL_27:
    sub_2096D272C();
    return 0;
  }
  v17 = 0;
  v18 = 0;
  while (1)
  {
    v19 = hx509_ca_tbs_add_eku(a1, a2);
    if ((_DWORD)v19)
      break;
    ++v18;
    v17 += 16;
    if (v18 >= LODWORD(v21[0]))
      goto LABEL_27;
  }
  SPKI = v19;
  sub_2096D272C();
  return SPKI;
}

uint64_t hx509_ca_tbs_add_eku(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  size_t v7;
  void *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  char v17;

  if (*(_DWORD *)(a2 + 48))
  {
    v4 = 0;
    v5 = 0;
    while (der_heim_oid_cmp())
    {
      ++v5;
      v6 = *(unsigned int *)(a2 + 48);
      v4 += 16;
      if (v5 >= v6)
      {
        v7 = 16 * (v6 + 1);
        goto LABEL_7;
      }
    }
    return 0;
  }
  else
  {
    v7 = 16;
LABEL_7:
    v8 = malloc_type_realloc(*(void **)(a2 + 56), v7, 0x1010040466105CCuLL);
    if (v8)
    {
      *(_QWORD *)(a2 + 56) = v8;
      v13 = der_copy_oid();
      if (!(_DWORD)v13)
      {
        ++*(_DWORD *)(a2 + 48);
        return v13;
      }
      v14 = a1;
      v15 = v13;
    }
    else
    {
      v13 = 12;
      v14 = a1;
      v15 = 12;
    }
    hx509_set_error_string(v14, 0, v15, "out of memory", v9, v10, v11, v12, v17);
  }
  return v13;
}

uint64_t hx509_ca_tbs_set_ca(uint64_t a1, uint64_t a2, int a3)
{
  *(_BYTE *)(a2 + 112) |= 2u;
  *(_DWORD *)(a2 + 136) = a3;
  return 0;
}

uint64_t hx509_ca_tbs_set_proxy(uint64_t a1, uint64_t a2, int a3)
{
  *(_BYTE *)(a2 + 112) |= 1u;
  *(_DWORD *)(a2 + 136) = a3;
  return 0;
}

uint64_t hx509_ca_tbs_set_domaincontroller(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)(a2 + 112) |= 0x10u;
  return 0;
}

uint64_t hx509_ca_tbs_set_spki(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  free_SubjectPublicKeyInfo();
  result = copy_SubjectPublicKeyInfo();
  *(_BYTE *)(a2 + 112) = *(_BYTE *)(a2 + 112) & 0xFB | (4 * ((_DWORD)result == 0));
  return result;
}

uint64_t hx509_ca_tbs_set_serialnumber(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  der_free_heim_integer();
  result = der_copy_heim_integer();
  *(_BYTE *)(a2 + 112) = *(_BYTE *)(a2 + 112) & 0xF7 | (8 * ((_DWORD)result == 0));
  return result;
}

uint64_t hx509_ca_tbs_add_crl_dp_uri(uint64_t a1, uint64_t a2, const char *a3, uint64_t a4)
{
  _QWORD *v8;
  size_t v9;
  void *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  const char *v24;
  char v26;
  _OWORD v27[2];
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  _OWORD *v31;
  _QWORD *v32;
  uint64_t v33;
  uint64_t v34;

  v33 = 0;
  v34 = 0;
  v8 = sub_2096B8038(1uLL, 0x10uLL);
  v32 = v8;
  v27[0] = 0u;
  v29 = 1;
  v30 = 1;
  v31 = v27;
  LODWORD(v27[0]) = 5;
  v28 = 0;
  v27[1] = (unint64_t)a3;
  *((_QWORD *)&v27[0] + 1) = strlen(a3);
  v9 = sub_2096D277C();
  *v8 = v9;
  v10 = malloc_type_malloc(v9, 0xDDCF4B98uLL);
  v8[1] = v10;
  if (!v10)
  {
    v23 = 12;
    goto LABEL_5;
  }
  v15 = sub_2096D275C();
  if ((_DWORD)v15)
  {
    v23 = v15;
    free((void *)v32[1]);
    v32[1] = 0;
LABEL_5:
    v24 = "Failed to encoded DistributionPointName";
LABEL_6:
    hx509_set_error_string(a1, 0, v23, v24, v11, v12, v13, v14, v26);
    goto LABEL_7;
  }
  if (*v32)
    sub_2096C1D6C("internal ASN.1 encoder error", v16, v17, v18, v19, v20, v21, v22, v26);
  if (a4)
  {
    v23 = 22;
    hx509_set_error_string(a1, 0, 22, "CRLDistributionPoints.name.issuername not yet supported", v19, v20, v21, v22, v26);
    return v23;
  }
  v23 = sub_2096D280C((unsigned int *)(a2 + 144));
  if ((_DWORD)v23)
  {
    v24 = "out of memory";
    goto LABEL_6;
  }
LABEL_7:
  sub_2096D279C();
  return v23;
}

uint64_t hx509_ca_tbs_add_san_otherName(uint64_t a1, uint64_t a2)
{
  return sub_2096D2490((unsigned int *)(a2 + 64));
}

uint64_t hx509_ca_tbs_add_san_pkinit(uint64_t a1, uint64_t a2, const char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  int v11;
  const char *i;
  unsigned int v13;
  int v14;
  void *v15;
  char **v16;
  char *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  char *v22;
  char *v23;
  char *v24;
  char **v25;
  char *v26;
  size_t v27;
  void *v28;
  void *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  const char *v39;
  int v40;
  const char *v41;
  uint64_t v42;
  int v43;
  char v45;
  void *v46[2];

  v10 = a1;
  *(_OWORD *)v46 = 0u;
  v11 = 1;
  for (i = a3; ; ++i)
  {
    v13 = *(unsigned __int8 *)i;
    if (v13 > 0x3F)
      break;
    if (v13 == 47)
    {
      ++v11;
    }
    else if (!*i)
    {
      goto LABEL_12;
    }
LABEL_11:
    ;
  }
  if (v13 == 92)
  {
    v14 = *(unsigned __int8 *)++i;
    if ((v14 | 0x40) != 0x40)
      goto LABEL_11;
    v38 = 569968;
    v39 = "trailing \\ in principal name";
    v40 = 569968;
LABEL_22:
    hx509_set_error_string(a1, 0, v40, v39, a5, a6, a7, a8, v45);
    v22 = 0;
    goto LABEL_28;
  }
  if (v13 != 64)
    goto LABEL_11;
LABEL_12:
  v15 = malloc_type_calloc(v11, 8uLL, 0x10040436913F5uLL);
  v46[1] = v15;
  if (!v15)
  {
    v39 = "malloc: out of memory";
    v38 = 12;
    a1 = v10;
    v40 = 12;
    goto LABEL_22;
  }
  v16 = (char **)v15;
  v17 = strdup(a3);
  v22 = v17;
  if (!v17)
  {
    v41 = "malloc: out of memory";
    v38 = 12;
    v42 = v10;
    v43 = 12;
LABEL_27:
    hx509_set_error_string(v42, 0, v43, v41, v18, v19, v20, v21, v45);
    goto LABEL_28;
  }
  v23 = strrchr(v17, 64);
  if (!v23)
  {
    v38 = 569968;
    v41 = "Missing @ in principal";
    v42 = v10;
    v43 = 569968;
    goto LABEL_27;
  }
  *v23 = 0;
  *v16 = v22;
  v24 = strchr(v22, 47);
  if (v24)
  {
    v25 = v16 + 1;
    do
    {
      *v24 = 0;
      v26 = v24 + 1;
      *v25++ = v26;
      v24 = strchr(v26, 47);
    }
    while (v24);
  }
  v27 = sub_2096BC918();
  v28 = malloc_type_malloc(v27, 0x53A31F73uLL);
  if (!v28)
  {
    v38 = 12;
LABEL_26:
    v41 = "Out of memory";
    v42 = v10;
    v43 = v38;
    goto LABEL_27;
  }
  v29 = v28;
  v30 = sub_2096BC8F8();
  if ((_DWORD)v30)
  {
    v38 = v30;
    free(v29);
    goto LABEL_26;
  }
  if (v27)
    sub_2096C1D6C("internal ASN.1 encoder error", v31, v32, v33, v34, v35, v36, v37, v45);
  v38 = sub_2096D2490((unsigned int *)(a2 + 64));
  free(v29);
LABEL_28:
  if (v46[1])
    free(v46[1]);
  if (v22)
    free(v22);
  return v38;
}

uint64_t hx509_ca_tbs_add_san_ms_upn(uint64_t a1, uint64_t a2)
{
  return sub_2096BD9B4(a1, a2);
}

uint64_t sub_2096BD9B4(uint64_t a1, uint64_t a2)
{
  size_t v4;
  void *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  void *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  char v21;

  v4 = sub_2096D2B00();
  v5 = malloc_type_malloc(v4, 0x4ABD8A49uLL);
  if (!v5)
  {
    v19 = 12;
    goto LABEL_5;
  }
  v10 = v5;
  v11 = sub_2096D2AE0();
  if ((_DWORD)v11)
  {
    v19 = v11;
    free(v10);
LABEL_5:
    hx509_set_error_string(a1, 0, v19, "Out of memory", v6, v7, v8, v9, v21);
    return v19;
  }
  if (v4)
    sub_2096C1D6C("internal ASN.1 encoder error", v12, v13, v14, v15, v16, v17, v18, v21);
  v19 = sub_2096D2490((unsigned int *)(a2 + 64));
  free(v10);
  return v19;
}

uint64_t hx509_ca_tbs_add_san_jid(uint64_t a1, uint64_t a2)
{
  return sub_2096BD9B4(a1, a2);
}

uint64_t hx509_ca_tbs_add_san_hostname(int a1, uint64_t a2, char *__s)
{
  strlen(__s);
  return sub_2096D2490((unsigned int *)(a2 + 64));
}

uint64_t hx509_ca_tbs_add_san_rfc822name(int a1, uint64_t a2, char *__s)
{
  strlen(__s);
  return sub_2096D2490((unsigned int *)(a2 + 64));
}

uint64_t hx509_ca_tbs_set_subject(uint64_t a1, void **a2, uint64_t a3)
{
  if (*a2)
    hx509_name_free(a2);
  return hx509_name_copy(a1, a3, a2);
}

uint64_t hx509_ca_tbs_subject_expand(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return hx509_name_expand(a1, *a2, a3, a4, a5, a6, a7, a8);
}

uint64_t hx509_ca_sign(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  _DWORD *v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  char v22;
  void *v23;
  _DWORD *v24;
  void *v25;
  __int128 v26;
  _OWORD v27[2];
  __int128 v28;
  __int128 v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  _QWORD v33[2];

  v23 = 0;
  v24 = 0;
  v25 = 0;
  v8 = sub_2096BEAC8(a3);
  v33[0] = 0;
  v33[1] = 0;
  if (!sub_2096BEF3C(v8, v33))
  {
    v23 = malloc_type_calloc(1uLL, 0x10uLL, 0x108004057E67DB5uLL);
    if (!v23)
    {
      sub_2096D2614();
      v13 = 12;
      v16 = a1;
      v17 = 12;
      goto LABEL_13;
    }
    v13 = der_copy_octet_string();
    sub_2096D2614();
    if (!(_DWORD)v13)
    {
LABEL_17:
      v19 = _hx509_cert_private_key(a3);
      v13 = sub_2096BDDAC(a1, a2, v19, (uint64_t)&v23, v8 + 144, a4, v20, v21);
      goto LABEL_15;
    }
LABEL_12:
    v16 = a1;
    v17 = v13;
LABEL_13:
    hx509_set_error_string(v16, 0, v17, "Out of memory", v9, v10, v11, v12, v22);
    goto LABEL_14;
  }
  v31 = 0;
  v32 = 0;
  v26 = 0u;
  memset(v27, 0, 24);
  v24 = malloc_type_calloc(1uLL, 0x10uLL, 0x1020040D5A9D86FuLL);
  if (!v24)
    goto LABEL_9;
  v25 = malloc_type_calloc(1uLL, 0x18uLL, 0x10800409070E284uLL);
  if (!v25)
    goto LABEL_9;
  v13 = hx509_name_to_Name_0();
  if ((_DWORD)v13)
    goto LABEL_12;
  v28 = 0u;
  v29 = *(_OWORD *)((char *)v27 + 8);
  v30 = 0;
  LODWORD(v28) = 4;
  DWORD2(v28) = 1;
  v13 = sub_2096D2490((unsigned int *)&v31);
  if ((_DWORD)v13)
    goto LABEL_12;
  v14 = v24;
  *((_QWORD *)v24 + 1) = v32;
  *v14 = v31;
  v15 = der_copy_heim_integer();
  if (!v25)
  {
LABEL_9:
    v13 = 12;
    goto LABEL_12;
  }
  v13 = v15;
  if (!(_DWORD)v15)
    goto LABEL_17;
LABEL_14:
  sub_2096D25B4();
LABEL_15:
  sub_2096D25B4();
  return v13;
}

uint64_t sub_2096BDDAC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  void *v13;
  time_t v14;
  time_t v15;
  int v16;
  char v17;
  const char *v18;
  int v19;
  _DWORD *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  void *v25;
  char v26;
  uint64_t v27;
  const char *v28;
  uint64_t v29;
  int v30;
  uint64_t v31;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  void *v37;
  uint64_t v38;
  void *v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  _DWORD *v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  CFTypeRef *v56;
  int v58;
  _QWORD v59[2];
  uint64_t v60;
  __int128 v61;
  __int128 v62;
  __int128 v63;
  __int128 v64;
  _OWORD v65[3];
  __int128 v66;
  __int128 v67;
  _BYTE v68[80];
  __int128 v69;
  _QWORD v70[4];
  __int128 v71;
  size_t v72;
  void *v73;
  _OWORD v74[2];
  uint64_t v75;

  v75 = *MEMORY[0x24BDAC8D0];
  v60 = 0;
  v13 = off_2545A7090;
  v61 = 0u;
  v62 = 0u;
  v63 = 0u;
  v64 = 0u;
  memset(v65, 0, sizeof(v65));
  v66 = 0u;
  v67 = 0u;
  memset(v68, 0, sizeof(v68));
  v69 = 0u;
  memset(v70, 0, sizeof(v70));
  v71 = 0u;
  v14 = *(_QWORD *)(a2 + 120);
  if (!v14)
    v14 = time(0) - 86400;
  v15 = *(_QWORD *)(a2 + 128);
  if (!v15)
    v15 = time(0) + 31536000;
  v16 = *(_DWORD *)(a2 + 80);
  if (!v16)
    LOWORD(v16) = sub_2096D255C(5);
  v17 = *(_BYTE *)(a2 + 112);
  if ((v17 & 2) != 0)
  {
    LOWORD(v16) = sub_2096D255C(96) | v16;
    v17 = *(_BYTE *)(a2 + 112);
  }
  if ((v17 & 4) != 0)
  {
    if ((v17 & 1) == 0)
    {
      if (!*(_QWORD *)a2)
      {
        v18 = "No subject name set";
        goto LABEL_29;
      }
      if (hx509_name_is_null_p(*(_QWORD *)a2) && !*(_DWORD *)(a2 + 64))
      {
        v18 = "NULL subject and no SubjectAltNames";
        goto LABEL_29;
      }
    }
    v19 = *(unsigned __int8 *)(a2 + 112);
    if ((~v19 & 3) == 0)
    {
      v18 = "Can't be proxy and CA at the same time";
      goto LABEL_29;
    }
    if ((v19 & 1) != 0 && *(_DWORD *)(a2 + 64))
    {
      v18 = "Proxy certificate is not allowed to have SubjectAltNames";
      goto LABEL_29;
    }
    v72 = 0;
    v73 = 0;
    v20 = malloc_type_calloc(1uLL, 4uLL, 0x100004052888210uLL);
    *(_QWORD *)&v62 = v20;
    if (!v20)
    {
LABEL_60:
      v28 = "Out of memory";
      v27 = 12;
      v29 = a1;
      v26 = 0;
      goto LABEL_61;
    }
    *v20 = 2;
    if ((*(_BYTE *)(a2 + 112) & 8) != 0)
    {
      v56 = (CFTypeRef *)a6;
      v31 = der_copy_heim_integer();
      if ((_DWORD)v31)
      {
        v27 = v31;
        v28 = "Failed to copy integer";
LABEL_38:
        v29 = a1;
        v26 = 0;
        v30 = v27;
        goto LABEL_62;
      }
    }
    else
    {
      *((_QWORD *)&v62 + 1) = 20;
      v25 = malloc_type_malloc(0x14uLL, 0x1348069CuLL);
      v26 = (char)v25;
      *(_QWORD *)&v63 = v25;
      if (!v25)
        goto LABEL_53;
      v56 = (CFTypeRef *)a6;
      if (CCRandomCopyBytes())
      {
        v27 = 569935;
        v28 = "Out of random";
        v29 = a1;
        v26 = 0;
        v30 = 569935;
LABEL_62:
        hx509_set_error_string(v29, v26, v30, v28, v21, v22, v23, v24, (char)v56);
        goto LABEL_63;
      }
    }
    v33 = copy_AlgorithmIdentifier();
    if ((_DWORD)v33)
    {
      v27 = v33;
      v28 = "Failed to copy sigature alg";
      goto LABEL_38;
    }
    if (a5)
      v34 = hx509_name_to_Name_0();
    else
      v34 = hx509_name_to_Name();
    v27 = v34;
    if ((_DWORD)v34)
    {
      v28 = "Failed to copy issuer name";
      goto LABEL_38;
    }
    *((_QWORD *)&v66 + 1) = v14;
    LODWORD(v66) = 2;
    LODWORD(v67) = 2;
    *((_QWORD *)&v67 + 1) = v15;
    if ((*(_BYTE *)(a2 + 112) & 1) != 0)
    {
      v27 = sub_2096BE818(a1, (uint64_t)v65 + 8, (uint64_t)v68);
      if ((_DWORD)v27)
      {
LABEL_63:
        sub_2096D2298();
        return v27;
      }
    }
    else
    {
      v35 = hx509_name_to_Name();
      if ((_DWORD)v35)
      {
        v27 = v35;
        v28 = "Failed to copy subject name";
        goto LABEL_38;
      }
    }
    v36 = copy_SubjectPublicKeyInfo();
    if ((_DWORD)v36)
    {
      v27 = v36;
      v28 = "Failed to copy spki";
      goto LABEL_38;
    }
    if (*(_QWORD *)(a2 + 176))
    {
      v37 = malloc_type_calloc(1uLL, 0x10uLL, 0x108004057E67DB5uLL);
      v26 = (char)v37;
      *(_QWORD *)&v69 = v37;
      if (!v37)
        goto LABEL_53;
      v38 = der_copy_bit_string();
      if ((_DWORD)v38)
      {
LABEL_51:
        v27 = v38;
LABEL_52:
        v28 = "Out of memory";
        goto LABEL_38;
      }
    }
    if (!*(_QWORD *)(a2 + 160))
      goto LABEL_54;
    v39 = malloc_type_calloc(1uLL, 0x10uLL, 0x108004057E67DB5uLL);
    v26 = (char)v39;
    *((_QWORD *)&v69 + 1) = v39;
    if (v39)
    {
      v38 = der_copy_bit_string();
      if ((_DWORD)v38)
        goto LABEL_51;
LABEL_54:
      v70[0] = malloc_type_calloc(1uLL, 0x10uLL, 0x1020040D5A9D86FuLL);
      if (v70[0])
      {
        if ((*(_BYTE *)(a2 + 112) & 0x10) != 0)
        {
          v72 = 34;
          v73 = &unk_2096D9AD8;
          v27 = sub_2096BE8F0(a1, (uint64_t)&v61, 0);
          if ((_DWORD)v27)
            goto LABEL_63;
        }
        LODWORD(v74[0]) = 0;
        LODWORD(v74[0]) = sub_2096D255C(v16);
        v72 = sub_2096D254C();
        v73 = malloc_type_malloc(v72, 0xDE3B8E58uLL);
        if (!v73)
          goto LABEL_106;
        v40 = sub_2096D252C();
        if ((_DWORD)v40)
        {
LABEL_59:
          v27 = v40;
          free(v73);
          v73 = 0;
          goto LABEL_52;
        }
        if (v60 != v72)
          goto LABEL_119;
        v27 = sub_2096BE8F0(a1, (uint64_t)&v61, 1);
        free(v73);
        if ((_DWORD)v27)
          goto LABEL_63;
        if (*(_DWORD *)(a2 + 48))
        {
          v72 = sub_2096D271C();
          v73 = malloc_type_malloc(v72, 0xFA1A7F73uLL);
          if (!v73)
            goto LABEL_106;
          v40 = sub_2096D26FC();
          if ((_DWORD)v40)
            goto LABEL_59;
          if (v60 != v72)
            goto LABEL_119;
          v27 = sub_2096BE8F0(a1, (uint64_t)&v61, 0);
          free(v73);
          if ((_DWORD)v27)
            goto LABEL_63;
        }
        if (*(_DWORD *)(a2 + 64))
        {
          v72 = sub_2096D2470();
          v73 = malloc_type_malloc(v72, 0x93098172uLL);
          if (!v73)
            goto LABEL_106;
          v40 = sub_2096D2450();
          if ((_DWORD)v40)
            goto LABEL_59;
          if (v60 != v72)
            goto LABEL_119;
          v27 = sub_2096BE8F0(a1, (uint64_t)&v61, 0);
          free(v73);
          if ((_DWORD)v27)
            goto LABEL_63;
        }
        if (a4)
        {
          v72 = sub_2096D25A4();
          v73 = malloc_type_malloc(v72, 0x6E1B4676uLL);
          if (!v73)
            goto LABEL_106;
          v40 = sub_2096D2584();
          if ((_DWORD)v40)
            goto LABEL_59;
          if (v60 != v72)
            goto LABEL_119;
          v27 = sub_2096BE8F0(a1, (uint64_t)&v61, 0);
          free(v73);
          if ((_DWORD)v27)
            goto LABEL_63;
        }
        CCDigestCreate();
        CCDigestUpdate();
        CCDigestFinal();
        CCDigestDestroy();
        v59[0] = 20;
        v59[1] = v74;
        v72 = sub_2096D2604();
        v73 = malloc_type_malloc(v72, 0x10E7F71BuLL);
        if (!v73)
          goto LABEL_106;
        v40 = sub_2096D25E4();
        if ((_DWORD)v40)
          goto LABEL_59;
        if (v60 != v72)
          goto LABEL_119;
        v27 = sub_2096BE8F0(a1, (uint64_t)&v61, 0);
        free(v73);
        if ((_DWORD)v27)
          goto LABEL_63;
        v58 = 0;
        LODWORD(v59[0]) = 1;
        v74[0] = 0uLL;
        if ((*(_BYTE *)(a2 + 112) & 2) != 0)
        {
          *(_QWORD *)&v74[0] = v59;
          if ((*(_DWORD *)(a2 + 136) & 0x80000000) == 0)
          {
            v58 = *(_DWORD *)(a2 + 136);
            *((_QWORD *)&v74[0] + 1) = &v58;
          }
        }
        v72 = sub_2096D2678();
        v73 = malloc_type_malloc(v72, 0x7D64F027uLL);
        if (!v73)
        {
LABEL_106:
          v27 = 12;
          goto LABEL_52;
        }
        v40 = sub_2096D2658();
        if ((_DWORD)v40)
          goto LABEL_59;
        if (v60 != v72)
          goto LABEL_119;
        v27 = sub_2096BE8F0(a1, (uint64_t)&v61, (*(unsigned __int8 *)(a2 + 112) >> 1) & 1);
        free(v73);
        if ((_DWORD)v27)
          goto LABEL_63;
        if ((*(_BYTE *)(a2 + 112) & 1) == 0)
        {
LABEL_93:
          if (!*(_DWORD *)(a2 + 144))
          {
LABEL_98:
            v72 = sub_2096D2238();
            v73 = malloc_type_malloc(v72, 0x31CFE0C3uLL);
            if (!v73)
            {
              v27 = 12;
              goto LABEL_111;
            }
            v48 = sub_2096D2218();
            if ((_DWORD)v48)
            {
              v27 = v48;
              free(v73);
              v73 = 0;
LABEL_111:
              v28 = "malloc out of memory";
              goto LABEL_38;
            }
            if (v72 == v60)
            {
              v27 = sub_2096C5050(a1, a3, (uint64_t)v13, (uint64_t)&v72, (uint64_t)&v70[1], &v71);
              free(v73);
              if (!(_DWORD)v27)
                v27 = hx509_cert_init(a1, (uint64_t)&v61, v56, v51, v52, v53, v54, v55);
              goto LABEL_63;
            }
LABEL_119:
            sub_2096C1D6C("internal ASN.1 encoder error", v41, v42, v43, v44, v45, v46, v47, (char)v56);
          }
          v72 = sub_2096D27EC();
          v73 = malloc_type_malloc(v72, 0x99F2EA55uLL);
          if (v73)
          {
            v40 = sub_2096D27CC();
            if ((_DWORD)v40)
              goto LABEL_59;
            if (v60 != v72)
              goto LABEL_119;
            v27 = sub_2096BE8F0(a1, (uint64_t)&v61, 0);
            free(v73);
            if ((_DWORD)v27)
              goto LABEL_63;
            goto LABEL_98;
          }
          goto LABEL_106;
        }
        memset(v74, 0, sizeof(v74));
        if ((*(_DWORD *)(a2 + 136) & 0x80000000) == 0)
        {
          v49 = malloc_type_malloc(4uLL, 0x100004052888210uLL);
          *(_QWORD *)&v74[0] = v49;
          if (!v49)
            goto LABEL_106;
          *v49 = *(_DWORD *)(a2 + 136);
        }
        v27 = der_copy_oid();
        if (!(_DWORD)v27)
        {
          v72 = sub_2096D2B90();
          v73 = malloc_type_malloc(v72, 0xA5282E40uLL);
          if (v73)
          {
            v50 = sub_2096D2B70();
            if (!(_DWORD)v50)
            {
              sub_2096D2BA0();
              if (v60 != v72)
                goto LABEL_119;
              v27 = sub_2096BE8F0(a1, (uint64_t)&v61, 0);
              free(v73);
              if ((_DWORD)v27)
                goto LABEL_63;
              goto LABEL_93;
            }
            v27 = v50;
            free(v73);
            v73 = 0;
          }
          else
          {
            v27 = 12;
          }
        }
        sub_2096D2BA0();
        goto LABEL_52;
      }
      goto LABEL_60;
    }
LABEL_53:
    v28 = "Out of memory";
    v27 = 12;
    v29 = a1;
LABEL_61:
    v30 = 12;
    goto LABEL_62;
  }
  v18 = "No public key set";
LABEL_29:
  v27 = 22;
  hx509_set_error_string(a1, 0, 22, v18, a5, a6, a7, a8, (char)v56);
  return v27;
}

uint64_t hx509_ca_sign_self(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return sub_2096BDDAC(a1, a2, a3, 0, 0, a4, a7, a8);
}

uint64_t sub_2096BE818(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  char *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  time_t v14;
  char v15;
  char *v16;

  v5 = hx509_name_to_Name_0();
  if ((_DWORD)v5)
  {
    v10 = v5;
    v11 = a1;
    v12 = v10;
LABEL_3:
    hx509_set_error_string(v11, 0, v12, "Failed to copy subject name", (uint64_t)v6, v7, v8, v9, v15);
    return v10;
  }
  v16 = 0;
  v14 = time(0);
  asprintf(&v16, "ts-%lu", v14);
  v6 = v16;
  if (!v16)
  {
    v10 = 12;
    v11 = a1;
    v12 = 12;
    goto LABEL_3;
  }
  v10 = sub_2096CD0E4(a1, a3, 1, (uint64_t)&unk_24C1F7B88, v16);
  free(v16);
  if ((_DWORD)v10)
    sub_2096D200C();
  return v10;
}

uint64_t sub_2096BE8F0(uint64_t a1, uint64_t a2, int a3)
{
  _DWORD *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;

  if (a3)
  {
    v5 = malloc_type_malloc(4uLL, 0x100004052888210uLL);
    if (!v5)
    {
      v11 = 12;
      v12 = a1;
      v13 = 12;
      goto LABEL_9;
    }
    *v5 = 1;
  }
  v10 = der_copy_oid();
  if ((_DWORD)v10 || (v10 = der_copy_octet_string(), (_DWORD)v10))
  {
    v11 = v10;
  }
  else
  {
    v11 = sub_2096D219C(*(unsigned int **)(a2 + 240));
    if (!(_DWORD)v11)
      goto LABEL_10;
  }
  v12 = a1;
  v13 = v11;
LABEL_9:
  hx509_set_error_string(v12, 0, v13, "Out of memory", v6, v7, v8, v9, 0);
LABEL_10:
  sub_2096D2118();
  return v11;
}

uint64_t hx509_context_init(uint64_t *a1)
{
  void *v2;
  _QWORD *v3;
  uint64_t v4;
  uint64_t v5;

  v2 = malloc_type_calloc(1uLL, 0x38uLL, 0x10B0040F8078E03uLL);
  *a1 = (uint64_t)v2;
  if (!v2)
    return 12;
  ((void (*)(void))nullsub_1)();
  sub_2096CAE14(*a1);
  sub_2096C9494(*a1);
  sub_2096CB6F4(*a1);
  nullsub_1(*a1);
  nullsub_1(*a1);
  v3 = sub_2096CA5FC(*a1);
  v4 = hc_ENGINE_add_conf_module(v3);
  hc_OpenSSL_add_all_algorithms(v4);
  v5 = *a1;
  *(_DWORD *)(v5 + 16) = 300;
  initialize_hx_error_table_r((_QWORD *)(v5 + 32));
  initialize_asn1_error_table_r((_QWORD *)(*a1 + 32));
  hx509_certs_init(*a1, "KEYCHAIN:system-anchors", 0, 0, (_QWORD *)(*a1 + 48));
  return 0;
}

uint64_t hx509_context_set_missing_revoke(uint64_t result, int a2)
{
  *(_DWORD *)(result + 12) = *(_DWORD *)(result + 12) & 0xFFFFFFFE | (a2 != 0);
  return result;
}

uint64_t sub_2096BEAC8(uint64_t a1)
{
  return *(_QWORD *)(a1 + 56);
}

uint64_t sub_2096BEAD0(uint64_t a1)
{
  _DWORD *v1;

  v1 = *(_DWORD **)(a1 + 16);
  if (v1)
    return (*v1 + 1);
  else
    return 1;
}

uint64_t hx509_cert_init(uint64_t a1, uint64_t a2, CFTypeRef *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;

  v9 = heim_uniq_alloc(0x70uLL, (uint64_t)"hx509-cert", (uint64_t)sub_2096BEBBC, a4, a5, a6, a7, a8);
  *a3 = (CFTypeRef)v9;
  if (!v9)
    return 12;
  *(_QWORD *)(v9 + 32) = 0;
  v10 = *a3;
  v10[9] = 0;
  v10[10] = 0;
  *((_QWORD *)*a3 + 8) = 0;
  *((_QWORD *)*a3 + 11) = 0;
  *((_QWORD *)*a3 + 12) = 0;
  *((_QWORD *)*a3 + 13) = 0;
  *((_QWORD *)*a3 + 7) = malloc_type_calloc(1uLL, 0x120uLL, 0x10B004094F02C90uLL);
  if (!*((_QWORD *)*a3 + 7))
  {
    heim_release(*a3);
    v11 = 12;
    goto LABEL_7;
  }
  v11 = sub_2096D22A8();
  if ((_DWORD)v11)
  {
    heim_release(*a3);
LABEL_7:
    *a3 = 0;
  }
  return v11;
}

uint64_t sub_2096BEBBC(uint64_t a1)
{
  void (*v2)(uint64_t, _QWORD);
  unint64_t v3;

  v2 = *(void (**)(uint64_t, _QWORD))(a1 + 96);
  if (v2)
    v2(a1, *(_QWORD *)(a1 + 104));
  if (*(_QWORD *)(a1 + 64))
    hx509_private_key_free((const void **)(a1 + 64));
  if (*(_QWORD *)(a1 + 56))
  {
    sub_2096D2298();
    free(*(void **)(a1 + 56));
  }
  if (*(_QWORD *)(a1 + 72))
  {
    v3 = 0;
    do
    {
      der_free_octet_string();
      der_free_oid();
      free(*(void **)(*(_QWORD *)(a1 + 80) + 8 * v3++));
    }
    while (v3 < *(_QWORD *)(a1 + 72));
  }
  free(*(void **)(a1 + 80));
  free(*(void **)(a1 + 32));
  if (*(_QWORD *)(a1 + 88))
    hx509_name_free((void **)(a1 + 88));
  return der_free_octet_string();
}

uint64_t hx509_cert_init_data(uint64_t a1, uint64_t a2, uint64_t a3, CFTypeRef *a4)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  const char *v14;
  uint64_t v15;
  int v16;
  char v18;
  _OWORD v19[18];

  memset(v19, 0, sizeof(v19));
  v7 = sub_2096D2248();
  if ((_DWORD)v7)
  {
    v13 = v7;
    v14 = "Failed to decode certificate";
    v15 = a1;
    v16 = v13;
LABEL_6:
    hx509_set_error_string(v15, 0, v16, v14, v9, v10, v11, v12, v18);
    return v13;
  }
  if (a3)
  {
    v13 = 569876;
    sub_2096D2298();
    v14 = "Extra data after certificate";
    v15 = a1;
    v16 = 569876;
    goto LABEL_6;
  }
  v13 = hx509_cert_init(v7, (uint64_t)v19, a4, v8, v9, v10, v11, v12);
  sub_2096D2298();
  return v13;
}

uint64_t sub_2096BED70(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 96) = a2;
  *(_QWORD *)(result + 104) = a3;
  return result;
}

uint64_t _hx509_cert_set_key(uint64_t a1, uint64_t a2)
{
  _QWORD *v3;

  v3 = (_QWORD *)(a1 + 64);
  if (*(_QWORD *)(a1 + 64))
    hx509_private_key_free((const void **)(a1 + 64));
  *v3 = _hx509_private_key_ref(a2);
  return 0;
}

uint64_t hx509_verify_init_ctx(uint64_t a1, _QWORD *a2)
{
  _DWORD *v3;
  _DWORD *v4;
  uint64_t result;

  v3 = malloc_type_calloc(1uLL, 0x28uLL, 0x1020040C34EC329uLL);
  if (!v3)
    return 12;
  v4 = v3;
  result = 0;
  v4[6] = 30;
  *a2 = v4;
  return result;
}

void hx509_verify_destroy_ctx(const void **a1)
{
  if (a1)
  {
    hx509_certs_free(a1);
    hx509_revoke_free(a1 + 4);
    a1[4] = 0;
    *(_OWORD *)a1 = 0u;
    *((_OWORD *)a1 + 1) = 0u;
  }
  free(a1);
}

const void *hx509_verify_attach_anchors(const void **a1, CFTypeRef cf)
{
  const void *result;

  if (*a1)
    hx509_certs_free(a1);
  result = (const void *)j__heim_retain(cf);
  *a1 = result;
  return result;
}

uint64_t hx509_verify_attach_revoke(uint64_t a1, CFTypeRef cf)
{
  _QWORD *v3;
  uint64_t result;

  v3 = (_QWORD *)(a1 + 32);
  if (*(_QWORD *)(a1 + 32))
    hx509_revoke_free((CFTypeRef *)(a1 + 32));
  result = j__heim_retain(cf);
  *v3 = result;
  return result;
}

uint64_t hx509_verify_set_time(uint64_t result, uint64_t a2)
{
  *(_DWORD *)(result + 8) |= 1u;
  *(_QWORD *)(result + 16) = a2;
  return result;
}

uint64_t sub_2096BEEE4(uint64_t a1)
{
  return *(_QWORD *)(a1 + 16);
}

uint64_t hx509_verify_set_max_depth(uint64_t result, int a2)
{
  *(_DWORD *)(result + 24) = a2;
  return result;
}

uint64_t hx509_verify_set_proxy_certificate(uint64_t result, int a2)
{
  *(_DWORD *)(result + 8) = *(_DWORD *)(result + 8) & 0xFFFFFFFD | (2 * (a2 != 0));
  return result;
}

uint64_t hx509_verify_set_strict_rfc3280_verification(uint64_t result, int a2)
{
  *(_DWORD *)(result + 8) = *(_DWORD *)(result + 8) & 0xFFFFFFFB | (4 * (a2 != 0));
  return result;
}

uint64_t hx509_verify_ctx_f_allow_default_trustanchors(uint64_t result, int a2)
{
  *(_DWORD *)(result + 8) = *(_DWORD *)(result + 8) & 0xFFFFFFEF | (16 * (a2 == 0));
  return result;
}

uint64_t sub_2096BEF3C(uint64_t a1, _QWORD *a2)
{
  unint64_t v3[2];

  v3[0] = 0;
  v3[1] = 0;
  *a2 = 0;
  a2[1] = 0;
  if (sub_2096BEF9C(a1, (uint64_t)&unk_24C1F8828, v3))
    return sub_2096D25C4();
  else
    return 569857;
}

uint64_t sub_2096BEF9C(uint64_t a1, uint64_t a2, unint64_t *a3)
{
  _DWORD *v3;
  unsigned int *v5;
  unint64_t v7;
  uint64_t v9;
  unint64_t v10;

  v3 = *(_DWORD **)(a1 + 16);
  if (!v3)
    return 0;
  if (*v3 < 2u)
    return 0;
  v5 = *(unsigned int **)(a1 + 240);
  if (!v5 || *a3 >= *v5)
    return 0;
  while (der_heim_oid_cmp())
  {
    v7 = *a3 + 1;
    *a3 = v7;
    if (v7 >= **(unsigned int **)(a1 + 240))
      return 0;
  }
  v9 = *(_QWORD *)(*(_QWORD *)(a1 + 240) + 8);
  v10 = (*a3)++;
  return v9 + 40 * v10;
}

void hx509_free_octet_string_list(uint64_t a1)
{
  uint64_t v2;
  unint64_t v3;

  if (*(_QWORD *)a1)
  {
    v2 = 0;
    v3 = 0;
    do
    {
      der_free_octet_string();
      ++v3;
      v2 += 16;
    }
    while (v3 < *(_QWORD *)a1);
  }
  free(*(void **)(a1 + 8));
  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = 0;
}

uint64_t hx509_cert_find_subjectAltName_otherName(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  void *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char v22;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;

  v24 = 0;
  v25 = 0;
  *(_QWORD *)a4 = 0;
  *(_QWORD *)(a4 + 8) = 0;
  v23 = 0;
  while (1)
  {
    v7 = sub_2096BF240(*(_QWORD *)(a2 + 56), &v23, &v24);
    ++v23;
    if ((_DWORD)v7)
    {
      v20 = v7;
      if ((_DWORD)v7 == 569857)
        return 0;
      hx509_set_error_string(a1, 0, v7, "Error searching for SAN", v8, v9, v10, v11, v22);
      hx509_free_octet_string_list(a4);
      return v20;
    }
    if ((_DWORD)v24)
      break;
LABEL_11:
    sub_2096D2480();
  }
  v12 = 0;
  v13 = 0;
  while (1)
  {
    if (*(_DWORD *)(v25 + v12) != 1 || der_heim_oid_cmp())
      goto LABEL_10;
    v14 = malloc_type_realloc(*(void **)(a4 + 8), 16 * *(_QWORD *)a4 + 16, 0x108004057E67DB5uLL);
    if (!v14)
    {
      v20 = 12;
      goto LABEL_14;
    }
    *(_QWORD *)(a4 + 8) = v14;
    v19 = der_copy_octet_string();
    if ((_DWORD)v19)
      break;
    ++*(_QWORD *)a4;
LABEL_10:
    ++v13;
    v12 += 40;
    if (v13 >= v24)
      goto LABEL_11;
  }
  v20 = v19;
LABEL_14:
  hx509_set_error_string(a1, 0, v20, "Error adding an exra SAN to return list", v15, v16, v17, v18, v22);
  hx509_free_octet_string_list(a4);
  sub_2096D2480();
  return v20;
}

uint64_t sub_2096BF240(uint64_t a1, unint64_t *a2, _QWORD *a3)
{
  *a3 = 0;
  a3[1] = 0;
  if (sub_2096BEF9C(a1, (uint64_t)&unk_24C1F89D8, a2))
    return sub_2096D2430();
  else
    return 569857;
}

uint64_t sub_2096BF2A0(uint64_t a1, uint64_t a2, int a3, int a4)
{
  return sub_2096BF2A8(a1, *(_QWORD *)(a2 + 56), a3, a4);
}

uint64_t sub_2096BF2A8(uint64_t a1, uint64_t a2, int a3, int a4)
{
  _DWORD *v4;
  uint64_t v5;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  char v20;
  void *v21;
  unint64_t v22[2];
  int v23;
  char __str[256];
  uint64_t v25;

  v25 = *MEMORY[0x24BDAC8D0];
  v22[0] = 0;
  v4 = *(_DWORD **)(a2 + 16);
  if (!v4)
    return 0;
  v5 = 0;
  v23 = 0;
  v22[1] = 0;
  if (*v4 + 1 >= 3)
  {
    if (!sub_2096BEF9C(a2, (uint64_t)&unk_24C1F8728, v22))
    {
      if (a4)
      {
        v5 = 569872;
        hx509_set_error_string(a1, 0, 569872, "Required extension key usage missing from certifiate", v10, v11, v12, v13, v20);
        return v5;
      }
      return 0;
    }
    v5 = sub_2096D250C();
    if (!(_DWORD)v5)
    {
      v14 = sub_2096D255C(v23);
      if ((a3 & ~v14) != 0)
      {
        v5 = 569872;
        v21 = 0;
        unparse_flags(a3 & ~v14, (uint64_t)off_2545A7680, __str, 0x100uLL);
        sub_2096CD938(a2 + 144, &v21);
        hx509_set_error_string(a1, 0, 569872, "Key usage %s required but missing from certifiate %s", v15, v16, v17, v18, (char)__str);
        free(v21);
        return v5;
      }
      return 0;
    }
  }
  return v5;
}

uint64_t sub_2096BF41C(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v6;
  uint64_t result;
  int v8;
  int v9;
  int v10;
  uint64_t v11;
  _QWORD v12[2];
  uint64_t v13;
  __int128 v14;
  _QWORD v15[2];
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unsigned int v19;

  v19 = 0;
  v6 = a2 + 144;
  result = sub_2096CCD90(a2 + 144, a1 + 72, (int *)&v19);
  if (!(_DWORD)result)
  {
    result = v19;
    if (!v19)
    {
      v16 = 0;
      v17 = 0;
      v18 = 0;
      v15[0] = 0;
      v15[1] = 0;
      v8 = sub_2096BF5A4(a1, &v16);
      v9 = v8;
      if (v8 != 569857 && v8)
        return 1;
      v10 = sub_2096BEF3C(a2, v15);
      if (v10 == 569857 || !v10)
      {
        if (v9)
        {
LABEL_9:
          sub_2096D25B4();
          sub_2096D2614();
          return v19;
        }
        if (v10)
        {
          if (a3)
          {
LABEL_13:
            v19 = 0;
            goto LABEL_9;
          }
          if (v16)
          {
            v19 = -1;
            goto LABEL_9;
          }
        }
        else if (v16)
        {
          v19 = der_heim_octet_string_cmp();
          goto LABEL_9;
        }
        v12[0] = 0;
        v12[1] = 0;
        v13 = 0;
        if (v17 && v18)
        {
          result = der_heim_integer_cmp();
          v19 = result;
          if ((_DWORD)result)
            return result;
          if (*(_DWORD *)v17 == 1)
          {
            v11 = *(_QWORD *)(v17 + 8);
            if (*(_DWORD *)v11 == 4)
            {
              LODWORD(v13) = *(_DWORD *)(v11 + 8);
              v14 = *(_OWORD *)(v11 + 16);
              result = sub_2096CCD90(v6, (uint64_t)v12, (int *)&v19);
              if ((_DWORD)result)
                return result;
              result = v19;
              if (v19)
                return result;
              goto LABEL_13;
            }
          }
        }
      }
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t sub_2096BF5A4(uint64_t a1, _QWORD *a2)
{
  unint64_t v3[2];

  v3[0] = 0;
  v3[1] = 0;
  a2[1] = 0;
  a2[2] = 0;
  *a2 = 0;
  if (sub_2096BEF9C(a1, (uint64_t)&unk_24C1F8778, v3))
    return sub_2096D2564();
  else
    return 569857;
}

uint64_t sub_2096BF608(uint64_t a1, uint64_t *a2, const void *a3)
{
  void *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  CFTypeRef v11;
  uint64_t v12;
  uint64_t v13;
  char v15;

  v6 = malloc_type_realloc((void *)a2[1], 8 * *a2 + 8, 0x2004093837F09uLL);
  if (v6)
  {
    a2[1] = (uint64_t)v6;
    v11 = heim_retain(a3);
    v12 = 0;
    v13 = *a2;
    *(_QWORD *)(a2[1] + 8 * *a2) = v11;
    *a2 = v13 + 1;
  }
  else
  {
    v12 = 12;
    hx509_set_error_string(a1, 0, 12, "out of memory", v7, v8, v9, v10, v15);
  }
  return v12;
}

void sub_2096BF69C(uint64_t a1)
{
  uint64_t v2;
  unsigned int v3;

  if (*(_QWORD *)a1)
  {
    v2 = 0;
    v3 = 1;
    do
    {
      heim_release(*(CFTypeRef *)(*(_QWORD *)(a1 + 8) + 8 * v2));
      v2 = v3;
    }
    while (*(_QWORD *)a1 > (unint64_t)v3++);
  }
  free(*(void **)(a1 + 8));
  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = 0;
}

uint64_t sub_2096BF6F4(uint64_t a1, char a2, uint64_t a3, uint64_t a4, int a5, const void *a6, uint64_t a7, uint64_t *a8)
{
  unint64_t v11;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  _QWORD *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  int v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  int v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  const char *v40;
  char v42;
  const void *v43;
  void *v44;
  void *v45;
  _OWORD v46[2];
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  uint64_t v53;
  _QWORD v54[4];

  LODWORD(v11) = a5;
  v16 = sub_2096BF608(a1, a8, a6);
  if ((_DWORD)v16)
    return v16;
  v43 = 0;
  if ((_DWORD)v11)
    v11 = v11;
  else
    v11 = 30;
  v22 = heim_retain(a6);
  while (!sub_2096BF9E0(a1, a4, (uint64_t)v22, v17, v18, v19, v20, v21))
  {
    v43 = 0;
    memset(v54, 0, 24);
    v53 = 0;
    v51 = 0u;
    v52 = 0u;
    v49 = 0u;
    v50 = 0u;
    memset(v46, 0, sizeof(v46));
    v47 = 0u;
    v48 = 0u;
    v28 = v22[7];
    if (*(_DWORD *)(v28 + 168))
    {
      *((_QWORD *)&v46[0] + 1) = v22[7];
      v29 = 1;
    }
    else
    {
      if (sub_2096BF5A4(v28, v54))
      {
        v16 = 569880;
        v40 = "Subjectless certificate missing AuthKeyID";
LABEL_31:
        hx509_set_error_string(a1, 0, 569880, v40, v24, v25, v26, v27, v42);
LABEL_33:
        heim_release(v22);
        return v16;
      }
      if (!v54[0])
      {
        v16 = 569880;
        sub_2096D25B4();
        v40 = "Subjectless certificate missing keyIdentifier inside AuthKeyID";
        goto LABEL_31;
      }
      *(_QWORD *)&v47 = v54[0];
      v29 = 16;
    }
    *(_QWORD *)&v49 = a8;
    LODWORD(v46[0]) = v29 | 0x20000;
    if (a7)
    {
      *((_QWORD *)&v51 + 1) = a3;
      LODWORD(v46[0]) = v29 | 0x220000;
      if (!hx509_certs_find(a1, a7, (int *)v46, &v43, v24, v25, v26, v27))
        goto LABEL_17;
      LODWORD(v46[0]) &= ~0x200000u;
    }
    if (!a4 || hx509_certs_find(a1, a4, (int *)v46, &v43, v24, v25, v26, v27))
    {
      sub_2096D25B4();
      v44 = 0;
      v45 = 0;
      if (hx509_name_from_Name(v22[7] + 144, &v45)
        || (v35 = hx509_name_to_string(v45, &v44), hx509_name_free(&v45), v35))
      {
        hx509_clear_error_string(a1);
        v16 = 569867;
      }
      else
      {
        v16 = 569867;
        hx509_set_error_string(a1, 0, 569867, "Failed to find issuer for certificate with subject: '%s'", v36, v37, v38, v39, (char)v44);
        free(v44);
      }
      goto LABEL_33;
    }
LABEL_17:
    sub_2096D25B4();
    heim_release(v22);
    v30 = sub_2096BF608(a1, a8, v43);
    if ((_DWORD)v30)
      return v30;
    v22 = v43;
    if (*a8 > v11)
    {
      heim_release(v43);
      v16 = 569871;
      hx509_set_error_string(a1, 0, 569871, "Path too long while bulding certificate chain", v31, v32, v33, v34, v42);
      return v16;
    }
  }
  if ((a2 & 1) != 0 && *a8 && sub_2096BF9E0(a1, a4, *(_QWORD *)(a8[1] + 8 * *a8 - 8), v23, v24, v25, v26, v27))
  {
    heim_release(*(CFTypeRef *)(a8[1] + 8 * *a8 - 8));
    --*a8;
  }
  heim_release(v22);
  return 0;
}

BOOL sub_2096BF9E0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8;
  CFTypeRef v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  uint64_t v19;

  if (!a2)
    return 0;
  v10 = 0;
  v11 = 0u;
  v12 = 0u;
  v13 = 0u;
  v14 = 0u;
  v15 = 0u;
  v16 = 0u;
  v17 = 0u;
  v18 = 0u;
  v19 = 0;
  LODWORD(v11) = 0x8000;
  *(_QWORD *)&v12 = *(_QWORD *)(a3 + 56);
  v8 = hx509_certs_find(a1, a2, (int *)&v11, &v10, a5, a6, a7, a8);
  if (!v8)
    heim_release(v10);
  return v8 == 0;
}

uint64_t sub_2096BFA5C(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  uint64_t v5;

  result = der_heim_oid_cmp();
  if (!(_DWORD)result)
  {
    v5 = *(_QWORD *)(a2 + 16);
    if (*(_QWORD *)(a1 + 16))
    {
      if (v5)
        return der_heim_octet_string_cmp();
      else
        return 1;
    }
    else if (v5)
    {
      return 0xFFFFFFFFLL;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t sub_2096BFAB4(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  result = der_heim_bit_string_cmp();
  if (!(_DWORD)result)
  {
    result = sub_2096BFA5C(a1 + 248, a2 + 248);
    if (!(_DWORD)result)
      return der_heim_octet_string_cmp();
  }
  return result;
}

uint64_t hx509_cert_cmp(uint64_t a1, uint64_t a2)
{
  return sub_2096BFAB4(*(_QWORD *)(a1 + 56), *(_QWORD *)(a2 + 56));
}

uint64_t hx509_cert_get_issuer(uint64_t a1, void **a2)
{
  return hx509_name_from_Name(*(_QWORD *)(a1 + 56) + 72, a2);
}

uint64_t hx509_cert_get_subject(uint64_t a1, void **a2)
{
  return hx509_name_from_Name(*(_QWORD *)(a1 + 56) + 144, a2);
}

uint64_t hx509_cert_get_base_subject(uint64_t a1, uint64_t a2, void **a3)
{
  uint64_t v6;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  char v12;

  v6 = *(_QWORD *)(a2 + 88);
  if (v6)
    return hx509_name_copy(a1, v6, a3);
  if (sub_2096BFBCC(a1, *(_QWORD *)(a2 + 56), 0))
    return hx509_name_from_Name(*(_QWORD *)(a2 + 56) + 144, a3);
  hx509_set_error_string(a1, 0, 569882, "Proxy certificate have not been canonicalize yet, no base name", v8, v9, v10, v11, v12);
  return 569882;
}

uint64_t sub_2096BFBCC(uint64_t a1, uint64_t a2, _OWORD *a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  __int128 v10;
  unint64_t v11;
  uint64_t v12;
  __int128 v13;
  __int128 v14;

  v11 = 0;
  if (a3)
  {
    *a3 = 0u;
    a3[1] = 0u;
  }
  v13 = 0u;
  v14 = 0u;
  v12 = 0;
  v5 = sub_2096BEF9C(a2, (uint64_t)&unk_24C1F9088, &v11);
  if (!v5)
  {
    v8 = 569857;
    goto LABEL_7;
  }
  v6 = v5;
  v7 = sub_2096D2B50();
  if ((_DWORD)v7)
  {
    v8 = v7;
LABEL_7:
    hx509_clear_error_string(a1);
    return v8;
  }
  if (v12 == *(_QWORD *)(v6 + 24))
  {
    if (a3)
    {
      v8 = 0;
      v10 = v14;
      *a3 = v13;
      a3[1] = v10;
    }
    else
    {
      sub_2096D2BA0();
      return 0;
    }
  }
  else
  {
    sub_2096D2BA0();
    hx509_clear_error_string(a1);
    return 569876;
  }
  return v8;
}

uint64_t hx509_cert_get_serialnumber()
{
  return der_copy_heim_integer();
}

uint64_t hx509_cert_get_notBefore(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 56);
  if ((*(_DWORD *)(v1 + 112) - 1) > 1)
    return 0;
  else
    return *(_QWORD *)(v1 + 120);
}

uint64_t sub_2096BFCF0(uint64_t a1)
{
  if ((*(_DWORD *)a1 - 1) > 1)
    return 0;
  else
    return *(_QWORD *)(a1 + 8);
}

uint64_t hx509_cert_get_notAfter(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 56);
  if ((*(_DWORD *)(v1 + 128) - 1) > 1)
    return 0;
  else
    return *(_QWORD *)(v1 + 136);
}

uint64_t hx509_cert_get_SPKI(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  char v8;

  v6 = copy_SubjectPublicKeyInfo();
  if ((_DWORD)v6)
    hx509_set_error_string(a1, 0, v6, "Failed to copy SPKI", v2, v3, v4, v5, v8);
  return v6;
}

uint64_t sub_2096BFD84(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  char v8;

  v6 = copy_AlgorithmIdentifier();
  if ((_DWORD)v6)
    hx509_set_error_string(a1, 0, v6, "Failed to copy SPKI AlgorithmIdentifier", v2, v3, v4, v5, v8);
  return v6;
}

uint64_t _hx509_cert_private_key(uint64_t a1)
{
  return *(_QWORD *)(a1 + 64);
}

uint64_t sub_2096BFDDC(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 64);
  if (result)
    return sub_2096C58E4(result);
  return result;
}

uint64_t sub_2096BFDEC(uint64_t a1, unsigned int *a2, uint64_t a3, uint64_t a4, _QWORD *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  char vars0;

  *a5 = 0;
  a5[1] = 0;
  v8 = *(_QWORD *)(a4 + 64);
  if (v8)
    return sub_2096C51E4(a1, a2, a3, v8, a5, a6, a7, a8);
  hx509_set_error_string(a1, 0, 569865, "Private key missing", (uint64_t)a5, a6, a7, a8, vars0);
  return 569865;
}

uint64_t sub_2096BFE30(uint64_t a1, unsigned int *a2, uint64_t a3, uint64_t a4, _QWORD *a5)
{
  return sub_2096C5090(a1, a2, *(_QWORD *)(a3 + 56), a4, a5);
}

_QWORD *sub_2096BFE38(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _QWORD *v8;
  CFMutableArrayRef v9;

  v8 = (_QWORD *)heim_uniq_alloc(0x28uLL, (uint64_t)"hx509-evaluate", (uint64_t)sub_2096BFE8C, a4, a5, a6, a7, a8);
  if (v8)
  {
    v9 = heim_array_create();
    v8[4] = v9;
    if (!v9)
    {
      heim_release(v8);
      return 0;
    }
  }
  return v8;
}

void sub_2096BFE8C(uint64_t a1)
{
  heim_release(*(CFTypeRef *)(a1 + 32));
}

CFIndex hx509_evaluate_get_length(uint64_t a1)
{
  return heim_array_get_length(*(CFArrayRef *)(a1 + 32));
}

const void *hx509_evaluate_get_cert(uint64_t a1, CFIndex a2)
{
  return heim_array_copy_value(*(const __CFArray **)(a1 + 32), a2);
}

const void *hx509_evaluate_get_ta(uint64_t a1)
{
  const void *result;

  result = (const void *)heim_array_get_length(*(CFArrayRef *)(a1 + 32));
  if (result)
    return heim_array_copy_value(*(const __CFArray **)(a1 + 32), (CFIndex)result - 1);
  return result;
}

uint64_t hx509_verify_path(uint64_t a1, uint64_t a2, void **a3, uint64_t a4)
{
  return sub_2096BFEF0(a1, a2, a3, a4, 0);
}

uint64_t sub_2096BFEF0(uint64_t a1, uint64_t a2, void **a3, uint64_t a4, CFTypeRef *a5)
{
  CFMutableArrayRef Mutable;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t inited;
  SecCertificateRef v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  SecPolicyRef BasicX509;
  OSStatus v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  int v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  CFIndex CertificateCount;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  _QWORD *v44;
  CFIndex v45;
  __SecCertificate *CertificateAtIndex;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  const __CFData *v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  const __CFData *v62;
  const UInt8 *BytePtr;
  CFIndex Length;
  const void *v65;
  const void *v66;
  const void *v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  unint64_t v76;
  unsigned int v77;
  uint64_t v78;
  unint64_t v79;
  uint64_t v80;
  int v81;
  uint64_t v82;
  _DWORD *v83;
  unint64_t v84;
  uint64_t v85;
  unint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  BOOL v91;
  uint64_t *v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t *v98;
  uint64_t *v99;
  uint64_t v100;
  char *v101;
  char *v102;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  unint64_t v111;
  unint64_t v112;
  uint64_t v113;
  const char *v114;
  uint64_t v115;
  char v116;
  uint64_t v117;
  const char *v118;
  uint64_t v119;
  const char *v120;
  unint64_t v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124;
  _QWORD *v125;
  unint64_t i;
  uint64_t v127;
  char v128;
  uint64_t v129;
  int v130;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  uint64_t v135;
  uint64_t v136;
  char v137;
  char v138;
  void **v139;
  unint64_t v140;
  int ptr;
  uint64_t *ptra;
  int v143;
  uint64_t v144;
  int v145;
  SecTrustRef trust;
  _QWORD v147[7];
  uint64_t v148;
  uint64_t *v149;
  uint64_t v150;
  uint64_t v151;
  uint64_t v152;
  uint64_t *v153;
  uint64_t v154;
  uint64_t v155;
  _OWORD v156[2];
  const void *v157;
  __int128 v158;
  __int128 v159;
  uint64_t v160;
  int v161;
  unint64_t v162;
  uint64_t v163;
  void *v164;
  unint64_t v165;
  unint64_t v166[3];

  v152 = 0;
  v153 = &v152;
  v154 = 0x2000000000;
  v148 = 0;
  v149 = &v148;
  v150 = 0x2000000000;
  if (a5)
    *a5 = 0;
  v155 = 0;
  v151 = 0;
  Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x24BDBD690]);
  v153[3] = (uint64_t)Mutable;
  if (!Mutable)
    heim_abort("out of memory:certs != NULL", v11, v12, v13, v14, v15, v16, v17, v137);
  inited = 569878;
  v19 = sub_2096C0CD0(a1, (uint64_t)a3);
  v149[3] = (uint64_t)v19;
  CFArrayAppendValue((CFMutableArrayRef)v153[3], v19);
  CFRelease((CFTypeRef)v149[3]);
  v147[0] = MEMORY[0x24BDAC760];
  v147[1] = 0x40000000;
  v147[2] = sub_2096C0D5C;
  v147[3] = &unk_24C1F6438;
  v147[4] = &v148;
  v147[5] = &v152;
  v147[6] = a1;
  hx509_certs_iter(a1, a4, (uint64_t)v147, v20, v21, v22, v23, v24);
  BasicX509 = SecPolicyCreateBasicX509();
  trust = 0;
  v26 = SecTrustCreateWithCertificates((CFTypeRef)v153[3], BasicX509, &trust);
  CFRelease(BasicX509);
  CFRelease((CFTypeRef)v153[3]);
  if (v26)
  {
    hx509_set_error_string(a1, 0, 569867, "Failed to create trust", v27, v28, v29, v30, v137);
    CFRelease(trust);
  }
  v145 = 0;
  v31 = MEMORY[0x20BD11C28](trust, &v145);
  if (v31)
  {
    inited = 569867;
    hx509_set_error_string(a1, 0, 569867, "Failed to validate trust: %d", v32, v33, v34, v35, v31);
    CFRelease(trust);
    goto LABEL_135;
  }
  if (v145 != 1 && v145 != 4)
  {
    hx509_set_error_string(a1, 0, 569867, "Failed to validate trust", v32, v33, v34, v35, v137);
    CFRelease(trust);
    if (qword_2545A7F68 != -1)
      dispatch_once(&qword_2545A7F68, &unk_24C1F00B0);
    if (!byte_2545A7F70)
    {
      inited = 569867;
      goto LABEL_135;
    }
    v157 = 0;
    v158 = 0u;
    v159 = 0u;
    v160 = 0;
    if (a5)
      *a5 = 0;
    v162 = 0;
    v163 = 0;
    if ((*(_BYTE *)(a2 + 8) & 1) == 0)
      *(_QWORD *)(a2 + 16) = time(0);
    v161 = 0;
    v66 = *(const void **)a2;
    if (*(_QWORD *)a2 || (v66 = *(const void **)(a1 + 48)) != 0 && (*(_BYTE *)(a2 + 8) & 0x10) == 0)
    {
      v67 = (const void *)j__heim_retain(v66);
      v157 = v67;
    }
    else
    {
      v68 = hx509_certs_init(a1, "MEMORY:no-TA", 0, 0, &v157);
      if ((_DWORD)v68)
        goto LABEL_130;
      v67 = v157;
    }
    v68 = sub_2096BF6F4(a1, 0, *(_QWORD *)(a2 + 16), (uint64_t)v67, *(_DWORD *)(a2 + 24), a3, a4, (uint64_t *)&v162);
    if ((_DWORD)v68)
    {
LABEL_130:
      v101 = 0;
      v90 = 0;
      inited = v68;
      goto LABEL_131;
    }
    if (!v162)
      goto LABEL_136;
    v76 = 0;
    ptr = 0;
    v143 = 0;
    v77 = ((*(_DWORD *)(a2 + 8) >> 1) & 1) == 0;
    v139 = a3 + 11;
    while (1)
    {
      v78 = *(_QWORD *)(*(_QWORD *)(v163 + 8 * v76) + 56);
      if (!v77)
        break;
      if (v77 == 1)
        goto LABEL_38;
      v79 = v76;
      v68 = sub_2096BF2A8(a1, v78, 32, (*(_DWORD *)(a2 + 8) >> 2) & 1);
      if ((_DWORD)v68)
      {
        v113 = v68;
        v114 = "Key usage missing from CA certificate";
        v115 = a1;
        v116 = 1;
        goto LABEL_154;
      }
      if (v79 + 1 != v162)
      {
        LODWORD(v156[0]) = 0;
        v68 = sub_2096C20D4(a1, v78, v156);
        if (LODWORD(v156[0]))
          v81 = ptr + 1;
        else
          v81 = ptr;
        ptr = v81;
        if ((_DWORD)v68)
          goto LABEL_130;
        v77 = 2;
LABEL_65:
        v76 = v79;
        goto LABEL_66;
      }
      v76 = v79;
      v77 = 2;
LABEL_66:
      v165 = 0;
      v83 = *(_DWORD **)(v78 + 16);
      if (v83)
      {
        v156[0] = 0uLL;
        v166[0] = 0;
        if (*v83 + 1 >= 3)
        {
          v84 = v76;
          v68 = sub_2096BEF9C(v78, (uint64_t)&unk_24C1F8858, &v165);
          if (v68)
          {
            v85 = sub_2096D2638();
            if ((_DWORD)v85)
            {
              inited = v85;
              goto LABEL_207;
            }
            if (v77 == 2)
            {
              if (!*(_QWORD *)&v156[0] || !**(_DWORD **)&v156[0])
              {
                inited = 569859;
                goto LABEL_206;
              }
              if (*((_QWORD *)&v156[0] + 1) && ~(ptr + (uint64_t)v143) + v84 > **((_DWORD **)&v156[0] + 1))
              {
                inited = 569860;
LABEL_206:
                sub_2096D2688();
LABEL_207:
                v101 = 0;
                v90 = 0;
                goto LABEL_131;
              }
            }
            else if (!v77 && *(_QWORD *)&v156[0] && **(_DWORD **)&v156[0])
            {
              inited = 569875;
              goto LABEL_206;
            }
            v68 = sub_2096D2688();
            v76 = v84;
          }
          else
          {
            v76 = v84;
            if (v77 >= 2)
            {
              v164 = 0;
              if (sub_2096CD938(v78 + 144, &v164))
                sub_2096D7DDC();
              inited = 569857;
              hx509_set_error_string(a1, 0, 569857, "basicConstraints missing from CA certifiacte %s", v132, v133, v134, v135, (char)v164);
              free(v164);
              goto LABEL_207;
            }
          }
        }
      }
      ++v76;
      v86 = v162;
      if (v76 != v162 || (*(_BYTE *)(a2 + 8) & 8) != 0)
      {
        if ((*(_DWORD *)(v78 + 112) - 1) > 1)
          v87 = 0;
        else
          v87 = *(_QWORD *)(v78 + 120);
        v88 = *(_QWORD *)(a2 + 16);
        if (v87 > v88)
        {
          hx509_clear_error_string(a1);
          v101 = 0;
          v90 = 0;
          inited = 569863;
          goto LABEL_131;
        }
        v89 = (*(_DWORD *)(v78 + 128) - 1) > 1 ? 0 : *(_QWORD *)(v78 + 136);
        if (v89 < v88)
        {
          hx509_clear_error_string(a1);
          v101 = 0;
          v90 = 0;
          inited = 569864;
          goto LABEL_131;
        }
      }
      if (v77 == 1)
      {
        v77 = 2;
      }
      else if (!v77)
      {
        ++v143;
      }
      if (v76 >= v162)
      {
        if (v162)
        {
          v90 = 0;
          ptra = 0;
          while (1)
          {
            LODWORD(v164) = 0;
            v140 = v86 - 1;
            v144 = *(_QWORD *)(*(_QWORD *)(v163 + 8 * (v86 - 1)) + 56);
            v68 = sub_2096C20D4(a1, v144, &v164);
            if ((_DWORD)v68)
            {
LABEL_188:
              inited = v68;
              goto LABEL_204;
            }
            v91 = (_DWORD)v164 && v86 == v162;
            if (!v91 && v90)
              break;
LABEL_114:
            v165 = 0;
            v166[0] = 0;
            v156[0] = 0uLL;
            v68 = sub_2096BEF9C(v144, (uint64_t)&unk_24C1F88B8, &v165);
            if (v68)
            {
              v68 = sub_2096D2698();
              if ((_DWORD)v68)
              {
                v97 = v68;
                if ((_DWORD)v68 != 569857)
                {
                  hx509_set_error_string(a1, 0, v68, "Failed getting NameConstraints", v72, v73, v74, v75, v138);
                  inited = v97;
                  goto LABEL_204;
                }
              }
              else
              {
                if (!v140)
                {
                  inited = 569868;
                  hx509_set_error_string(a1, 0, 569868, "Not a CA and have NameConstraints", v72, v73, v74, v75, v138);
LABEL_213:
                  sub_2096D26B8();
                  goto LABEL_204;
                }
                v98 = (uint64_t *)malloc_type_realloc(ptra, 16 * v90 + 16, 0x20040A4A59CD2uLL);
                if (!v98)
                {
                  hx509_clear_error_string(a1);
                  inited = 12;
                  goto LABEL_213;
                }
                v99 = v98;
                v100 = sub_2096D26C8();
                if ((_DWORD)v100)
                {
                  v136 = v100;
                  hx509_clear_error_string(a1);
                  ptra = v99;
                  inited = v136;
                  goto LABEL_213;
                }
                ++v90;
                v68 = sub_2096D26B8();
                ptra = v99;
              }
            }
            v86 = v140;
            if (!v140)
              goto LABEL_137;
          }
          LODWORD(v166[0]) = 0;
          v92 = ptra + 1;
          v93 = v90;
          while (1)
          {
            v156[0] = 0uLL;
            v94 = *(v92 - 1);
            if (v94)
            {
              LODWORD(v156[0]) = *(_DWORD *)v94;
              *((_QWORD *)&v156[0] + 1) = *(_QWORD *)(v94 + 8);
              v95 = sub_2096C2164((unsigned int *)v156, v144, v166);
              if ((_DWORD)v95)
                goto LABEL_158;
              if (!LODWORD(v166[0]) && *(_DWORD *)(v144 + 168))
                break;
            }
            v96 = *v92;
            if (*v92)
            {
              LODWORD(v156[0]) = *(_DWORD *)v96;
              *((_QWORD *)&v156[0] + 1) = *(_QWORD *)(v96 + 8);
              v95 = sub_2096C2164((unsigned int *)v156, v144, v166);
              if ((_DWORD)v95)
              {
LABEL_158:
                v117 = v95;
                hx509_clear_error_string(a1);
                inited = v117;
                goto LABEL_204;
              }
              if (LODWORD(v166[0]))
              {
                inited = 569868;
                v120 = "Error verify constraints, certificate included in excluded subtree";
                goto LABEL_202;
              }
            }
            v92 += 2;
            if (!--v93)
              goto LABEL_114;
          }
          inited = 569868;
          v120 = "Error verify constraints, certificate didn't match any permitted subtree";
LABEL_202:
          v127 = a1;
          v128 = 0;
LABEL_203:
          hx509_set_error_string(v127, v128, inited, v120, v72, v73, v74, v75, v138);
LABEL_204:
          v101 = (char *)ptra;
LABEL_131:
          hx509_certs_free(&v157);
          sub_2096D200C();
          if (v90)
          {
            v102 = v101;
            do
            {
              sub_2096D26B8();
              v102 += 16;
              --v90;
            }
            while (v90);
          }
          free(v101);
          sub_2096BF69C((uint64_t)&v162);
          goto LABEL_135;
        }
LABEL_136:
        v90 = 0;
        ptra = 0;
LABEL_137:
        if (*(_QWORD *)(a2 + 32))
        {
          *(_QWORD *)&v156[0] = 0;
          inited = hx509_certs_init(a1, "MEMORY:revoke-certs", 0, 0, v156);
          if ((_DWORD)inited)
            goto LABEL_204;
          if (v162)
          {
            v109 = 0;
            while (1)
            {
              v110 = hx509_certs_add(a1, *(uint64_t *)&v156[0], *(_QWORD *)(v163 + 8 * v109), v104, v105, v106, v107, v108);
              if ((_DWORD)v110)
                break;
              if (++v109 >= v162)
                goto LABEL_143;
            }
LABEL_147:
            inited = v110;
            goto LABEL_148;
          }
LABEL_143:
          inited = hx509_certs_merge(a1, *(uint64_t *)&v156[0], a4, v104, v105, v106, v107, v108);
          if ((_DWORD)inited)
          {
LABEL_148:
            hx509_certs_free((const void **)v156);
            goto LABEL_204;
          }
          v111 = 0;
          while (v111 < v162 - 1)
          {
            v112 = v111 + 1;
            v110 = hx509_revoke_verify(a1, *(_QWORD **)(a2 + 32), *(uint64_t *)&v156[0], *(_QWORD *)(a2 + 16), *(_QWORD *)(v163 + 8 * v111), *(_QWORD *)(v163 + 8 * v111 + 8));
            v111 = v112;
            if ((_DWORD)v110)
              goto LABEL_147;
          }
          hx509_certs_free((const void **)v156);
        }
        v121 = v162;
        if (!v162)
        {
LABEL_182:
          if (a5)
          {
            v125 = sub_2096BFE38(v68, v69, v70, v71, v72, v73, v74, v75);
            *a5 = v125;
            if (!v125)
            {
              inited = 12;
              goto LABEL_204;
            }
            if (v162)
            {
              for (i = 0; i < v162; ++i)
                heim_array_append_value(*((__CFArray **)*a5 + 4), *(const void **)(v163 + 8 * i));
            }
          }
          inited = 0;
          goto LABEL_204;
        }
        while (2)
        {
          v122 = *(_QWORD *)(v163 + 8 * v121 - 8);
          v123 = *(_QWORD *)(v122 + 56);
          if (v121 == v162)
          {
            LODWORD(v156[0]) = 0;
            v68 = sub_2096C20D4(a1, v123, v156);
            if ((_DWORD)v68)
              goto LABEL_188;
            if (!LODWORD(v156[0]))
            {
LABEL_181:
              if (!--v121)
                goto LABEL_182;
              continue;
            }
          }
          else
          {
            v122 = *(_QWORD *)(v163 + 8 * v121);
          }
          break;
        }
        v68 = sub_2096C0E48(a1, v122, v123 + 248, v123, (_QWORD *)(v123 + 272), v73, v74, v75);
        if ((_DWORD)v68)
        {
          inited = v68;
          v120 = "Failed to verify signature of certificate";
          v127 = a1;
          v128 = 1;
          goto LABEL_203;
        }
        if (v121 == 1)
          goto LABEL_182;
        if ((*(_BYTE *)(a2 + 8) & 0x20) == 0)
        {
          v124 = (*(_DWORD *)(v123 + 112) - 1) > 1 ? 0 : *(_QWORD *)(v123 + 120);
          v68 = sub_2096C4C7C(a1, v123 + 248, v124);
          if ((_DWORD)v68)
            goto LABEL_188;
        }
        goto LABEL_181;
      }
    }
    v79 = v76;
    memset(v156, 0, sizeof(v156));
    v68 = sub_2096BFBCC(a1, v78, v156);
    if (!(_DWORD)v68)
    {
      if (*(_QWORD *)&v156[0] && v79 > **(_DWORD **)&v156[0])
      {
        sub_2096D2BA0();
        inited = 569871;
        v118 = "Proxy certificate chain longer then allowed";
        goto LABEL_197;
      }
      sub_2096D2BA0();
      v166[0] = 0;
      if (sub_2096BEF9C(v78, (uint64_t)&unk_24C1F89D8, v166))
      {
        inited = 569877;
        v118 = "Proxy certificate have explicity forbidden subjectAltName";
LABEL_197:
        v129 = a1;
        v130 = inited;
        goto LABEL_200;
      }
      v166[0] = 0;
      if (sub_2096BEF9C(v78, (uint64_t)&unk_24C1F89E8, v166))
      {
        inited = 569877;
        v118 = "Proxy certificate have explicity forbidden issuerAltName";
        goto LABEL_197;
      }
      if (v143)
      {
        v68 = sub_2096CCD90((uint64_t)&v158, v78 + 144, &v161);
        if ((_DWORD)v68)
          goto LABEL_165;
        if (v161)
        {
          v118 = "Base proxy name not right";
LABEL_199:
          v129 = a1;
          v130 = 569878;
LABEL_200:
          hx509_set_error_string(v129, 0, v130, v118, v72, v73, v74, v75, v138);
          goto LABEL_207;
        }
      }
      sub_2096D200C();
      v82 = hx509_name_to_Name_0();
      if ((_DWORD)v82)
      {
        v119 = v82;
        hx509_clear_error_string(a1);
LABEL_194:
        inited = v119;
        goto LABEL_207;
      }
      if (DWORD2(v159) < 2 || *(_DWORD *)(v160 + 16 * (DWORD2(v159) - 1)) > 1u || der_heim_oid_cmp())
      {
        v118 = "Proxy name too short or does not have Common name at the top";
        goto LABEL_199;
      }
      sub_2096D1FAC();
      --DWORD2(v159);
      v68 = sub_2096CCD90((uint64_t)&v158, v78 + 72, &v161);
      if ((_DWORD)v68)
      {
LABEL_165:
        v119 = v68;
        hx509_set_error_string(a1, 0, v68, "Out of memory", v72, v73, v74, v75, v138);
        goto LABEL_194;
      }
      if (v161)
      {
        v118 = "Proxy issuer name not as expected";
        goto LABEL_199;
      }
      v77 = 0;
      goto LABEL_65;
    }
    v76 = v79;
LABEL_38:
    if (v143)
    {
      v79 = v76;
      v80 = sub_2096CCD90((uint64_t)&v158, v78 + 144, &v161);
      if ((_DWORD)v80)
      {
        v113 = v80;
        v114 = "out of memory";
        v115 = a1;
        v116 = 0;
LABEL_154:
        hx509_set_error_string(v115, v116, v113, v114, v72, v73, v74, v75, v138);
        goto LABEL_157;
      }
      if (v161)
      {
        hx509_clear_error_string(a1);
        goto LABEL_207;
      }
      if (*v139)
        hx509_name_free(v139);
      v68 = hx509_name_from_Name((uint64_t)&v158, v139);
      if ((_DWORD)v68)
      {
        v113 = v68;
        hx509_clear_error_string(a1);
LABEL_157:
        v101 = 0;
        v90 = 0;
        inited = v113;
        goto LABEL_131;
      }
      v77 = 1;
      goto LABEL_65;
    }
    v77 = 1;
    goto LABEL_66;
  }
  if (!a5)
    goto LABEL_18;
  CertificateCount = SecTrustGetCertificateCount(trust);
  v44 = sub_2096BFE38(CertificateCount, v37, v38, v39, v40, v41, v42, v43);
  *a5 = v44;
  if (!v44)
  {
    CFRelease(trust);
    inited = 12;
    goto LABEL_135;
  }
  if (CertificateCount >= 1)
  {
    v45 = 0;
    while (1)
    {
      CertificateAtIndex = SecTrustGetCertificateAtIndex(trust, v45);
      if (!CertificateAtIndex)
        heim_abort("SecTrustGetCertificateAtIndex didn't return a cert:tc != NULL", v47, v48, v49, v50, v51, v52, v53, v137);
      v54 = SecCertificateCopyData(CertificateAtIndex);
      if (!v54)
        heim_abort("cert w/o data ?:data != NULL", v55, v56, v57, v58, v59, v60, v61, v137);
      v62 = v54;
      *(_QWORD *)&v158 = 0;
      BytePtr = CFDataGetBytePtr(v54);
      Length = CFDataGetLength(v62);
      inited = hx509_cert_init_data(a1, (uint64_t)BytePtr, Length, (CFTypeRef *)&v158);
      CFRelease(v62);
      if ((_DWORD)inited)
        break;
      v65 = (const void *)v158;
      heim_array_append_value(*((__CFArray **)*a5 + 4), (const void *)v158);
      heim_release(v65);
      if (CertificateCount == ++v45)
        goto LABEL_18;
    }
    CFRelease(trust);
    heim_release(*a5);
    *a5 = 0;
  }
  else
  {
LABEL_18:
    CFRelease(trust);
    inited = 0;
  }
LABEL_135:
  _Block_object_dispose(&v148, 8);
  _Block_object_dispose(&v152, 8);
  return inited;
}

SecCertificateRef sub_2096C0CD0(uint64_t a1, uint64_t a2)
{
  SecCertificateRef v2;
  UInt8 *v3;
  const __CFData *v4;
  const __CFData *v5;
  CFIndex v7;
  UInt8 *v8;

  v7 = 0;
  v8 = 0;
  v2 = 0;
  if (!hx509_cert_binary(a1, a2, (uint64_t)&v7))
  {
    v3 = v8;
    v4 = CFDataCreateWithBytesNoCopy(0, v8, v7, (CFAllocatorRef)*MEMORY[0x24BDBD258]);
    if (v4)
    {
      v5 = v4;
      v2 = SecCertificateCreateWithData(0, v4);
      CFRelease(v5);
    }
    else
    {
      v2 = 0;
    }
    free(v3);
  }
  return v2;
}

uint64_t sub_2096C0D5C(_QWORD *a1, uint64_t a2)
{
  *(_QWORD *)(*(_QWORD *)(a1[4] + 8) + 24) = sub_2096C0CD0(a1[6], a2);
  CFArrayAppendValue(*(CFMutableArrayRef *)(*(_QWORD *)(a1[5] + 8) + 24), *(const void **)(*(_QWORD *)(a1[4] + 8) + 24));
  CFRelease(*(CFTypeRef *)(*(_QWORD *)(a1[4] + 8) + 24));
  return 0;
}

void sub_2096C0DB8()
{
  const __CFBoolean *v0;
  const __CFBoolean *v1;
  CFTypeID TypeID;

  v0 = (const __CFBoolean *)CFPreferencesCopyValue(CFSTR("AllowHX509Validation"), CFSTR("org.h5l.hx509"), (CFStringRef)*MEMORY[0x24BDBD590], (CFStringRef)*MEMORY[0x24BDBD570]);
  if (v0)
  {
    v1 = v0;
    TypeID = CFBooleanGetTypeID();
    if (TypeID == CFGetTypeID(v1))
      byte_2545A7F70 = CFBooleanGetValue(v1) != 0;
    CFRelease(v1);
  }
}

uint64_t sub_2096C0E48(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, _QWORD *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  _QWORD v11[2];

  if ((*a5 & 7) != 0)
  {
    v8 = 569925;
    hx509_set_error_string(a1, 0, 569925, "signature not multiple of 8 bits", (uint64_t)a5, a6, a7, a8, v11[0]);
  }
  else
  {
    v9 = a5[1];
    v11[0] = *a5 >> 3;
    v11[1] = v9;
    return hx509_verify_signature_0(a1, a2, a3, a4, (uint64_t)v11);
  }
  return v8;
}

uint64_t hx509_verify_hostname(uint64_t a1, uint64_t a2, char a3, uint64_t a4, const char *a5, uint64_t a6, int a7)
{
  uint64_t result;
  int v11;
  unint64_t v12;
  uint64_t v13;
  unint64_t i;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  unsigned int v21;
  int v22;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;

  if (a6 && a7 < 1)
    return 22;
  v24 = 0;
  v25 = 0;
  v23 = 0;
  while (1)
  {
    v11 = sub_2096BF240(*(_QWORD *)(a2 + 56), &v23, &v24);
    if (v11)
      break;
    v12 = v24;
    if ((_DWORD)v24)
    {
      v13 = 0;
      for (i = 0; i < v12; ++i)
      {
        if (*(_DWORD *)(v25 + v13) == 3)
        {
          strlen(a5);
          if (!der_printable_string_cmp())
          {
            sub_2096D2480();
            return 0;
          }
          v12 = v24;
        }
        v13 += 40;
      }
    }
    sub_2096D2480();
  }
  if (v11 != 569857)
    return 569968;
  v15 = *(_QWORD *)(a2 + 56);
  v16 = *(unsigned int *)(v15 + 168);
  if (!(_DWORD)v16)
  {
    v21 = 0;
    goto LABEL_33;
  }
  while (1)
  {
    --v16;
    v17 = *(_QWORD *)(v15 + 176);
    if (*(_DWORD *)(v17 + 16 * v16))
      break;
LABEL_20:
    if (!v16)
    {
      v21 = 0;
      goto LABEL_33;
    }
  }
  v18 = 0;
  v19 = 0;
  while (1)
  {
    v20 = *(_QWORD *)(v17 + 16 * v16 + 8);
    if (!der_heim_oid_cmp())
      break;
    ++v19;
    v17 = *(_QWORD *)(v15 + 176);
    v18 += 40;
    if (v19 >= *(unsigned int *)(v17 + 16 * v16))
      goto LABEL_20;
  }
  v22 = *(_DWORD *)(v20 + v18 + 16);
  switch(v22)
  {
    case 1:
      strlen(a5);
      result = der_ia5_string_cmp();
      goto LABEL_30;
    case 5:
      result = strcasecmp(*(const char **)(v20 + v18 + 24), a5);
LABEL_30:
      v21 = 569870;
      if (!(_DWORD)result)
        return result;
      goto LABEL_33;
    case 3:
      strlen(a5);
      result = der_printable_string_cmp();
      goto LABEL_30;
  }
  v21 = 569870;
LABEL_33:
  if ((a3 & 1) != 0)
    return v21;
  else
    return 569870;
}

uint64_t sub_2096C10F0(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  void *v5;
  void *v6;
  void *v7;
  uint64_t v8;

  if (hx509_cert_get_attribute(a2))
    return 0;
  v5 = malloc_type_realloc(*(void **)(a2 + 80), 8 * *(_QWORD *)(a2 + 72) + 8, 0x2004093837F09uLL);
  if (v5)
  {
    *(_QWORD *)(a2 + 80) = v5;
    v6 = malloc_type_malloc(0x20uLL, 0x10900401C8C3F62uLL);
    if (v6)
    {
      v7 = v6;
      der_copy_octet_string();
      der_copy_oid();
      result = 0;
      v8 = *(_QWORD *)(a2 + 72);
      *(_QWORD *)(*(_QWORD *)(a2 + 80) + 8 * v8) = v7;
      *(_QWORD *)(a2 + 72) = v8 + 1;
      return result;
    }
  }
  else
  {
    hx509_clear_error_string(a1);
  }
  return 12;
}

uint64_t hx509_cert_get_attribute(uint64_t a1)
{
  uint64_t v2;

  if (!*(_QWORD *)(a1 + 72))
    return 0;
  v2 = 0;
  while (der_heim_oid_cmp())
  {
    if ((unint64_t)++v2 >= *(_QWORD *)(a1 + 72))
      return 0;
  }
  return *(_QWORD *)(*(_QWORD *)(a1 + 80) + 8 * v2);
}

uint64_t hx509_cert_set_friendly_name(uint64_t a1, char *__s1)
{
  void *v4;
  char *v5;

  v4 = *(void **)(a1 + 32);
  if (v4)
    free(v4);
  v5 = strdup(__s1);
  *(_QWORD *)(a1 + 32) = v5;
  if (v5)
    return 0;
  else
    return 12;
}

uint64_t hx509_cert_get_friendly_name(uint64_t a1)
{
  uint64_t result;
  uint64_t v3;
  int v4;
  int v5;
  void *v6[4];

  v3 = a1 + 32;
  result = *(_QWORD *)(a1 + 32);
  if (!result)
  {
    memset(&v6[1], 0, 24);
    if (hx509_cert_get_attribute(a1))
    {
      if (!sub_2096BC658())
        sub_2096BC678();
    }
    else
    {
      v6[0] = 0;
      v4 = hx509_name_from_Name(*(_QWORD *)(a1 + 56) + 144, v6);
      result = 0;
      if (v4)
        return result;
      v5 = hx509_name_to_string(v6[0], v3);
      hx509_name_free(v6);
      if (!v5)
        return *(_QWORD *)v3;
    }
    return 0;
  }
  return result;
}

uint64_t hx509_cert_get_persistent(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  uint64_t v4;
  void *v5;
  _QWORD v6[2];

  if (*(_QWORD *)(a1 + 40))
    return der_copy_octet_string();
  v4 = *(_QWORD *)(*(_QWORD *)(a1 + 56) + 216);
  v6[0] = *(_QWORD *)(*(_QWORD *)(a1 + 56) + 208) >> 3;
  v6[1] = v4;
  v5 = hx509_signature_sha1();
  result = sub_2096C4F38(0, 0, (uint64_t)v5, (uint64_t)v6, 0, a2);
  if (!(_DWORD)result)
  {
    der_free_octet_string();
    der_copy_octet_string();
    return 0;
  }
  return result;
}

double sub_2096C1430(uint64_t a1)
{
  double result;

  *(_QWORD *)(a1 + 128) = 0;
  result = 0.0;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  return result;
}

uint64_t hx509_query_alloc(uint64_t a1, _QWORD *a2)
{
  void *v3;

  v3 = malloc_type_calloc(1uLL, 0x88uLL, 0x10B004077450F5CuLL);
  *a2 = v3;
  if (v3)
    return 0;
  else
    return 12;
}

_DWORD *hx509_query_match_option(_DWORD *result, int a2)
{
  if ((a2 - 1) <= 3)
    *result |= dword_2096D9B20[a2 - 1];
  return result;
}

uint64_t hx509_query_match_issuer_serial(uint64_t a1)
{
  void *v2;
  uint64_t v3;
  uint64_t v4;
  void *v5;

  if (*(_QWORD *)(a1 + 24))
  {
    der_free_heim_integer();
    free(*(void **)(a1 + 24));
  }
  v2 = malloc_type_malloc(0x18uLL, 0x10800409070E284uLL);
  *(_QWORD *)(a1 + 24) = v2;
  if (!v2)
    return 12;
  v3 = der_copy_heim_integer();
  if ((_DWORD)v3)
  {
    v4 = v3;
    free(*(void **)(a1 + 24));
    *(_QWORD *)(a1 + 24) = 0;
    return v4;
  }
  if (*(_QWORD *)(a1 + 48))
  {
    sub_2096D200C();
    free(*(void **)(a1 + 48));
  }
  v5 = malloc_type_malloc(0x28uLL, 0x10A0040F20C3E80uLL);
  *(_QWORD *)(a1 + 48) = v5;
  if (!v5)
    return 12;
  v4 = hx509_name_to_Name_0();
  if ((_DWORD)v4)
  {
    free(*(void **)(a1 + 48));
    *(_QWORD *)(a1 + 48) = 0;
  }
  else
  {
    *(_DWORD *)a1 |= 6u;
  }
  return v4;
}

uint64_t hx509_query_match_friendly_name(uint64_t a1, char *__s1)
{
  void *v4;
  char *v5;
  uint64_t result;

  v4 = *(void **)(a1 + 72);
  if (v4)
    free(v4);
  v5 = strdup(__s1);
  *(_QWORD *)(a1 + 72) = v5;
  if (!v5)
    return 12;
  result = 0;
  *(_DWORD *)a1 |= 0x40000u;
  return result;
}

uint64_t hx509_query_match_eku(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  unsigned int v4;
  void *v5;
  uint64_t v6;
  uint64_t v7;

  v3 = *(_QWORD *)(a1 + 112);
  if (!a2)
  {
    if (v3)
    {
      der_free_oid();
      free(*(void **)(a1 + 112));
      *(_QWORD *)(a1 + 112) = 0;
    }
    v4 = *(_DWORD *)a1 & 0xFFBFFFFF;
    goto LABEL_11;
  }
  if (v3)
  {
    der_free_oid();
  }
  else
  {
    v5 = malloc_type_calloc(1uLL, 0x10uLL, 0x1010040466105CCuLL);
    *(_QWORD *)(a1 + 112) = v5;
    if (!v5)
      return 12;
  }
  v6 = der_copy_oid();
  if (!(_DWORD)v6)
  {
    v4 = *(_DWORD *)a1 | 0x400000;
LABEL_11:
    v7 = 0;
    *(_DWORD *)a1 = v4;
    return v7;
  }
  v7 = v6;
  free(*(void **)(a1 + 112));
  *(_QWORD *)(a1 + 112) = 0;
  return v7;
}

uint64_t hx509_query_match_cmp_func(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_DWORD *)a1 = *(_DWORD *)a1 & 0xFFF7FFFF | ((a2 != 0) << 19);
  *(_QWORD *)(a1 + 80) = a2;
  *(_QWORD *)(a1 + 88) = a3;
  return 0;
}

uint64_t hx509_query_match_persistent(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)a1 = *(_DWORD *)a1 & 0xFEFFFFFF | ((a2 != 0) << 24);
  *(_QWORD *)(a1 + 128) = a2;
  return 0;
}

void hx509_query_free(int a1, void **a2)
{
  void *v3;

  if (a2)
  {
    if (a2[3])
    {
      der_free_heim_integer();
      free(a2[3]);
    }
    if (a2[6])
    {
      sub_2096D200C();
      free(a2[6]);
    }
    if (a2[14])
    {
      der_free_oid();
      free(a2[14]);
    }
    v3 = a2[9];
    if (v3)
      free(v3);
    a2[16] = 0;
    *((_OWORD *)a2 + 6) = 0u;
    *((_OWORD *)a2 + 7) = 0u;
    *((_OWORD *)a2 + 4) = 0u;
    *((_OWORD *)a2 + 5) = 0u;
    *((_OWORD *)a2 + 2) = 0u;
    *((_OWORD *)a2 + 3) = 0u;
    *(_OWORD *)a2 = 0u;
    *((_OWORD *)a2 + 1) = 0u;
    free(a2);
  }
}

const char *sub_2096C1788(uint64_t a1, int *a2, uint64_t a3)
{
  uint64_t v6;
  unsigned int v7;
  int v8;
  const char *result;
  int v10;
  int v11;
  int v12;
  unint64_t *v13;
  unint64_t v14;
  int v15;
  uint64_t v16;
  void *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  uint64_t v22;
  uint64_t v23;
  int v24;

  v6 = *(_QWORD *)(a3 + 56);
  v7 = *a2;
  if ((*a2 & 1) != 0)
  {
    v8 = sub_2096BF41C(*((_QWORD *)a2 + 1), *(_QWORD *)(a3 + 56), 0);
    result = 0;
    if (v8)
      return result;
    v7 = *a2;
  }
  if ((v7 & 0x8000) != 0)
  {
    if (sub_2096BFAB4(*((_QWORD *)a2 + 2), v6))
      return 0;
    v7 = *a2;
  }
  if ((v7 & 2) != 0)
  {
    if (der_heim_integer_cmp())
      return 0;
    v7 = *a2;
  }
  v24 = 0;
  if ((v7 & 4) != 0)
  {
    v10 = sub_2096CCD90(v6 + 72, *((_QWORD *)a2 + 6), &v24);
    if (v10 | v24)
      return 0;
    v7 = *a2;
  }
  if ((v7 & 8) != 0)
  {
    v11 = sub_2096CCD90(v6 + 144, *((_QWORD *)a2 + 7), &v24);
    if (v11 | v24)
      return 0;
    v7 = *a2;
  }
  if ((v7 & 0x10) != 0)
  {
    v22 = 0;
    v23 = 0;
    if (sub_2096BEF3C(v6, &v22))
      return 0;
    v15 = der_heim_octet_string_cmp();
    sub_2096D2614();
    if (v15)
      return 0;
    v7 = *a2;
    if ((*a2 & 0x20) != 0)
      return 0;
  }
  else if ((v7 & 0x20) != 0)
  {
    return 0;
  }
  if ((v7 & 0x40) != 0 && !*(_QWORD *)(a3 + 64))
    return 0;
  v12 = (v7 >> 10) & 2 | (v7 >> 8) & 1 | (v7 >> 5) & 4 | (v7 >> 10) & 8 | (v7 >> 8) & 0x10 | (v7 >> 4) & 0x60;
  if (v12)
  {
    if (sub_2096BF2A8(a1, v6, v12, 1))
      return 0;
    v7 = *a2;
  }
  if ((v7 & 0x4000) != 0)
    return 0;
  if ((v7 & 0x10000) != 0)
  {
    result = (const char *)hx509_cert_get_attribute(a3);
    if (!result)
      return result;
    if (der_heim_octet_string_cmp())
      return 0;
    v7 = *a2;
    if ((*a2 & 0x20000) == 0)
    {
LABEL_38:
      if ((v7 & 0x40000) != 0)
      {
        result = (const char *)hx509_cert_get_friendly_name(a3);
        if (!result)
          return result;
        if (strcasecmp(*((const char **)a2 + 9), result))
          return 0;
        v7 = *a2;
        if ((*a2 & 0x80000) != 0)
          goto LABEL_40;
      }
      else if ((v7 & 0x80000) != 0)
      {
LABEL_40:
        if ((*((unsigned int (**)(uint64_t, uint64_t, _QWORD))a2 + 10))(a1, a3, *((_QWORD *)a2 + 11)))
          return 0;
        v7 = *a2;
      }
      if ((v7 & 0x100000) != 0)
      {
        v16 = *(_QWORD *)(v6 + 216);
        v22 = *(_QWORD *)(v6 + 208) >> 3;
        v23 = v16;
        v17 = hx509_signature_sha1();
        if (hx509_verify_signature_0(a1, 0, (uint64_t)v17, (uint64_t)&v22, *((_QWORD *)a2 + 12)))
          return 0;
        v7 = *a2;
      }
      if ((v7 & 0x200000) != 0)
      {
        v18 = (*(_DWORD *)(v6 + 112) - 1) > 1 ? 0 : *(_QWORD *)(v6 + 120);
        v19 = *((_QWORD *)a2 + 13);
        if (v18 > v19)
          return 0;
        v20 = (*(_DWORD *)(v6 + 128) - 1) > 1 ? 0 : *(_QWORD *)(v6 + 136);
        if (v20 < v19)
          return 0;
      }
      if ((v7 & 0x400000) != 0)
      {
        if (hx509_cert_check_eku(a1, a3))
          return 0;
        v7 = *a2;
      }
      if ((v7 & 0x800000) == 0)
      {
        if ((v7 & 0x1000000) == 0)
          return (const char *)(v7 >> 25 == 0);
        v22 = 0;
        v23 = 0;
        if (!hx509_cert_get_persistent(a3, (uint64_t)&v22))
        {
          v21 = der_heim_octet_string_cmp();
          der_free_octet_string();
          if (!v21)
          {
            v7 = *a2;
            return (const char *)(v7 >> 25 == 0);
          }
        }
      }
      return 0;
    }
  }
  else if ((v7 & 0x20000) == 0)
  {
    goto LABEL_38;
  }
  v13 = (unint64_t *)*((_QWORD *)a2 + 8);
  if (!*v13)
    goto LABEL_38;
  v14 = 0;
  while (1)
  {
    result = (const char *)sub_2096BFAB4(*(_QWORD *)(*(_QWORD *)(v13[1] + 8 * v14) + 56), *(_QWORD *)(a3 + 56));
    if (!(_DWORD)result)
      return result;
    ++v14;
    v13 = (unint64_t *)*((_QWORD *)a2 + 8);
    if (v14 >= *v13)
    {
      v7 = *a2;
      goto LABEL_38;
    }
  }
}

uint64_t hx509_cert_check_eku(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  _QWORD v8[2];

  v8[0] = 0;
  v8[1] = 0;
  v3 = sub_2096C1B80(*(_QWORD *)(a2 + 56), v8);
  if ((_DWORD)v3)
  {
    v4 = v3;
    hx509_clear_error_string(a1);
  }
  else if (LODWORD(v8[0]))
  {
    v5 = 0;
    v6 = 0;
    while (der_heim_oid_cmp())
    {
      ++v6;
      v5 += 16;
      if (v6 >= LODWORD(v8[0]))
        goto LABEL_7;
    }
    sub_2096D272C();
    return 0;
  }
  else
  {
LABEL_7:
    sub_2096D272C();
    hx509_clear_error_string(a1);
    return 569881;
  }
  return v4;
}

uint64_t sub_2096C1B80(uint64_t a1, _QWORD *a2)
{
  unint64_t v3[2];

  v3[0] = 0;
  v3[1] = 0;
  *a2 = 0;
  a2[1] = 0;
  if (sub_2096BEF9C(a1, (uint64_t)&unk_24C1F8A18, v3))
    return sub_2096D26DC();
  else
    return 569857;
}

uint64_t sub_2096C1BE0(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  uint64_t v3;
  _DWORD *v4;
  unint64_t v6[2];

  v6[0] = 0;
  *a3 = 0;
  v3 = *(_QWORD *)(a2 + 56);
  v4 = *(_DWORD **)(v3 + 16);
  if (!v4)
    return 0;
  v6[1] = 0;
  if (*v4 + 1 < 3)
    return 0;
  if (sub_2096BEF9C(v3, (uint64_t)&unk_24C1F8728, v6))
    return sub_2096D250C();
  return 569872;
}

uint64_t sub_2096C1C68(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  uint64_t v4;
  BOOL v5;
  uint64_t v6;

  *a3 = 0;
  a3[1] = 0;
  v4 = sub_2096C1B80(*(_QWORD *)(a2 + 56), a3);
  if ((_DWORD)v4)
    v5 = (_DWORD)v4 == 569857;
  else
    v5 = 1;
  if (v5)
    return 0;
  v6 = v4;
  hx509_clear_error_string(a1);
  return v6;
}

uint64_t hx509_cert_binary(uint64_t a1, uint64_t a2, uint64_t a3)
{
  size_t v4;
  void *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  char v16;

  *(_QWORD *)a3 = 0;
  *(_QWORD *)(a3 + 8) = 0;
  v4 = sub_2096D2288();
  *(_QWORD *)a3 = v4;
  v5 = malloc_type_malloc(v4, 0xEE4CC4E8uLL);
  *(_QWORD *)(a3 + 8) = v5;
  if (!v5)
  {
    v14 = 12;
    goto LABEL_5;
  }
  v6 = sub_2096D2268();
  if ((_DWORD)v6)
  {
    v14 = v6;
    free(*(void **)(a3 + 8));
LABEL_5:
    *(_QWORD *)a3 = 0;
    *(_QWORD *)(a3 + 8) = 0;
    return v14;
  }
  if (*(_QWORD *)a3)
    sub_2096C1D6C("internal ASN.1 encoder error", v7, v8, v9, v10, v11, v12, v13, v16);
  return 0;
}

void sub_2096C1D6C(char *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  sub_2096D7418(a1, &a9);
}

uint64_t hx509_print_cert(uint64_t a1, uint64_t a2, FILE *a3)
{
  FILE *v5;
  uint64_t result;
  uint64_t v7;
  char *v8;
  uint64_t v9;
  void *v10;
  void *v11;

  v11 = 0;
  v10 = 0;
  if (a3)
    v5 = a3;
  else
    v5 = (FILE *)*MEMORY[0x24BDAC8D8];
  result = hx509_name_from_Name(*(_QWORD *)(a2 + 56) + 72, &v11);
  if (!(_DWORD)result)
  {
    hx509_name_to_string(v11, &v10);
    hx509_name_free(&v11);
    fprintf(v5, "    issuer:  \"%s\"\n", (const char *)v10);
    free(v10);
    result = hx509_name_from_Name(*(_QWORD *)(a2 + 56) + 144, &v11);
    if (!(_DWORD)result)
    {
      hx509_name_to_string(v11, &v10);
      hx509_name_free(&v11);
      fprintf(v5, "    subject: \"%s\"\n", (const char *)v10);
      free(v10);
      v7 = 0;
      v8 = 0;
      v9 = 0;
      result = der_copy_heim_integer();
      if (!(_DWORD)result)
      {
        result = der_print_hex_heim_integer();
        if (!(_DWORD)result)
        {
          der_free_heim_integer();
          fprintf(v5, "    serial: %s\n", (const char *)v10);
          free(v10);
          fwrite("    keyusage: ", 0xEuLL, 1uLL, v5);
          if (hx509_cert_keyusage_print(a1, a2, (char **)&v10))
          {
            fwrite("no\n", 3uLL, 1uLL, v5);
          }
          else
          {
            fprintf(v5, "%s\n", (const char *)v10);
            free(v10);
          }
          v7 = 0;
          v8 = 0;
          fwrite("    persistent: ", 0x10uLL, 1uLL, v5);
          if (hx509_cert_get_persistent(a2, (uint64_t)&v7))
          {
            fwrite("no\n", 3uLL, 1uLL, v5);
          }
          else
          {
            if ((int)rk_hex_encode(v8, v7, &v10) < 1)
            {
              fwrite("out of memory\n", 0xEuLL, 1uLL, v5);
            }
            else
            {
              fprintf(v5, "%s\n", (const char *)v10);
              free(v10);
            }
            der_free_octet_string();
          }
          return 0;
        }
      }
    }
  }
  return result;
}

uint64_t hx509_cert_get_appleid(uint64_t a1, uint64_t a2, char **a3)
{
  uint64_t v5;
  void *v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  _OWORD *v11;
  _OWORD v12[2];
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  v12[0] = xmmword_2096D9B00;
  v12[1] = unk_2096D9B10;
  v10 = 8;
  v11 = v12;
  v9 = 0;
  v7 = 0;
  v8 = 0;
  *a3 = 0;
  v5 = hx509_cert_check_eku(a1, a2);
  if (!(_DWORD)v5)
  {
    v5 = hx509_name_from_Name(*(_QWORD *)(a2 + 56) + 144, (void **)&v8);
    if (!(_DWORD)v5)
    {
      v5 = sub_2096CCEDC(v8, 3u, (uint64_t)&unk_24C1F7B88, &v9, &v7);
      hx509_name_free((void **)&v8);
      if (!(_DWORD)v5)
      {
        asprintf(a3, "%s@me.com", (const char *)v7);
        free(v7);
        if (*a3)
          return 0;
        else
          return 12;
      }
    }
  }
  return v5;
}

uint64_t sub_2096C20D4(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  char v12;
  int v13;

  v13 = 0;
  v5 = sub_2096CCD90(a2 + 144, a2 + 72, &v13);
  *a3 = v13 == 0;
  if (!(_DWORD)v5)
    return sub_2096C4D44(a1);
  v10 = v5;
  hx509_set_error_string(a1, 0, v5, "Failed to check if self signed", v6, v7, v8, v9, v12);
  return v10;
}

uint64_t sub_2096C2164(unsigned int *a1, uint64_t a2, _DWORD *a3)
{
  unint64_t v5;
  int v6;
  __int128 *v7;
  uint64_t v8;
  _DWORD *v9;
  int v10;
  _DWORD *v11;
  uint64_t result;
  unint64_t v13;
  uint64_t v14;
  unint64_t v15;
  __int128 v17;
  __int128 v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;

  *a3 = 0;
  v20 = 0;
  if (!*a1)
    return 0;
  v5 = 0;
  v6 = 0;
  v7 = (__int128 *)(a2 + 168);
  do
  {
    v8 = *((_QWORD *)a1 + 1);
    if (*(_QWORD *)(v8 + 56 * v5 + 40) && *(_QWORD *)(v8 + 56 * v5 + 48))
      return 569869;
    v9 = (_DWORD *)(v8 + 56 * v5);
    if (*v9 == 4 && *(_DWORD *)v7)
    {
      v19 = 0;
      v17 = 0u;
      v18 = 0u;
      v10 = *(_DWORD *)(a2 + 160);
      LODWORD(v17) = 4;
      DWORD2(v17) = v10;
      v18 = *v7;
      sub_2096C2310((uint64_t)v9, (uint64_t)&v17, (_DWORD *)&v20 + 1);
      v8 = *((_QWORD *)a1 + 1);
    }
    v11 = (_DWORD *)(v8 + 56 * v5);
    v17 = 0uLL;
    v21 = 0;
    while (1)
    {
      LODWORD(result) = sub_2096BF240(a2, &v21, &v17);
      if ((_DWORD)result)
        break;
      v13 = v17;
      if ((_DWORD)v17)
      {
        v14 = 0;
        v15 = 0;
        do
        {
          if (*v11 == *(_DWORD *)(*((_QWORD *)&v17 + 1) + v14))
          {
            sub_2096C2310((uint64_t)v11, *((_QWORD *)&v17 + 1) + v14, &v20);
            v13 = v17;
            v6 = 1;
          }
          ++v15;
          v14 += 40;
        }
        while (v15 < v13);
      }
      sub_2096D2480();
    }
    if ((_DWORD)result == 569857)
      result = 0;
    else
      result = result;
    ++v5;
  }
  while (v5 < *a1);
  if (HIDWORD(v20) && (!v6 || (_DWORD)v20))
    *a3 = 1;
  return result;
}

uint64_t sub_2096C2310(uint64_t result, uint64_t a2, _DWORD *a3)
{
  size_t v5;
  void *v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  int v11;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  _DWORD *v17;
  int v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  char *v26;
  size_t v27;
  uint64_t v28;
  char *v29;
  int v30;

  if (*(_DWORD *)result != *(_DWORD *)a2)
    sub_2096D7E04();
  switch(*(_DWORD *)result)
  {
    case 1:
      result = der_heim_oid_cmp();
      if (!(_DWORD)result)
      {
        result = der_heim_octet_string_cmp();
        if (!(_DWORD)result)
          goto LABEL_19;
      }
      return result;
    case 2:
      v5 = *(_QWORD *)(result + 8);
      v6 = *(void **)(result + 16);
      if (memchr(v6, 64, v5))
      {
        result = der_printable_string_cmp();
        if (!(_DWORD)result)
          goto LABEL_19;
      }
      else
      {
        v27 = *(_QWORD *)(a2 + 8);
        v26 = *(char **)(a2 + 16);
        result = (uint64_t)memchr(v26, 64, v27);
        if (result)
        {
          v28 = result;
          v29 = &v26[v27 - result];
          if ((unint64_t)v29 >= v5)
          {
            result = memcmp(&v29[result - v5 + 1], v6, v5);
            if (!(_DWORD)result)
            {
              if ((unint64_t)v29 <= v5)
                goto LABEL_19;
              v11 = v29[v28 - v5 + 1];
              goto LABEL_13;
            }
          }
        }
      }
      return result;
    case 3:
      v7 = *(_QWORD *)(result + 8);
      v8 = *(_QWORD *)(a2 + 8);
      v9 = v8 - v7;
      if (v8 >= v7)
      {
        v10 = *(_QWORD *)(a2 + 16);
        result = memcmp((const void *)(v10 + v9), *(const void **)(result + 16), *(_QWORD *)(result + 8));
        if (!(_DWORD)result)
        {
          if (v8 == v7)
            goto LABEL_19;
          v11 = *(unsigned __int8 *)(v9 + v10 - 1);
LABEL_13:
          if (v11 == 46)
            goto LABEL_19;
        }
      }
      return result;
    case 4:
      if (*(_DWORD *)(result + 8) != 1 || *(_DWORD *)(a2 + 8) != 1)
        goto LABEL_19;
      v13 = *(unsigned int *)(result + 16);
      if (v13 <= *(_DWORD *)(a2 + 16))
      {
        if (!(_DWORD)v13)
        {
LABEL_19:
          *a3 = 1;
          return result;
        }
        v14 = 0;
        v15 = *(_QWORD *)(result + 24);
        v16 = *(_QWORD *)(a2 + 24);
        while (1)
        {
          v17 = (_DWORD *)(v16 + 16 * v14);
          v18 = *(_DWORD *)(v15 + 16 * v14);
          if (v18 != *v17)
            break;
          if (v18)
          {
            v19 = 0;
            v20 = 16;
            do
            {
              v30 = 0;
              result = der_heim_oid_cmp();
              if ((_DWORD)result)
                return result;
              result = sub_2096CC9E4(*(_QWORD *)(v15 + 16 * v14 + 8) + v20, *(_QWORD *)(v16 + 16 * v14 + 8) + v20, &v30, v21, v22, v23, v24, v25);
              if ((_DWORD)result || v30)
                return result;
              ++v19;
              v20 += 40;
            }
            while (v19 < *v17);
          }
          if (++v14 == v13)
            goto LABEL_19;
        }
      }
      return result;
    default:
      return result;
  }
}

uint64_t hx509_cms_wrap_ContentInfo(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  void *v6;
  size_t v7;
  void *v8;
  uint64_t v9;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  _QWORD *v18;

  *(_QWORD *)a3 = 0;
  *(_QWORD *)(a3 + 8) = 0;
  v5 = der_copy_oid();
  if ((_DWORD)v5)
    return v5;
  if (a2)
  {
    v18 = malloc_type_calloc(1uLL, 0x10uLL, 0x108004057E67DB5uLL);
    if (!v18)
      goto LABEL_9;
    v6 = malloc_type_malloc(*(_QWORD *)a2, 0xCF26A46EuLL);
    v18[1] = v6;
    if (!v6)
      goto LABEL_9;
    memcpy(v6, *(const void **)(a2 + 8), *(_QWORD *)a2);
    *v18 = *(_QWORD *)a2;
  }
  v7 = length_ContentInfo();
  *(_QWORD *)a3 = v7;
  v8 = malloc_type_malloc(v7, 0xBFBFC088uLL);
  *(_QWORD *)(a3 + 8) = v8;
  if (!v8)
  {
LABEL_9:
    v5 = 12;
    goto LABEL_10;
  }
  v9 = encode_ContentInfo();
  if ((_DWORD)v9)
  {
    v5 = v9;
    free(*(void **)(a3 + 8));
    *(_QWORD *)(a3 + 8) = 0;
LABEL_10:
    free_ContentInfo();
    return v5;
  }
  free_ContentInfo();
  if (*(_QWORD *)a3)
    sub_2096C1D6C("internal ASN.1 encoder error", v11, v12, v13, v14, v15, v16, v17, 0);
  return 0;
}

uint64_t hx509_cms_unwrap_ContentInfo(uint64_t a1, _QWORD *a2, _QWORD *a3, _DWORD *a4)
{
  uint64_t v6;

  *a2 = 0;
  a2[1] = 0;
  *a3 = 0;
  a3[1] = 0;
  v6 = sub_2096D1B1C();
  if (!(_DWORD)v6)
  {
    v6 = der_copy_oid();
    if (!(_DWORD)v6)
    {
      *a3 = 0;
      a3[1] = 0;
      v6 = 0;
      if (a4)
        *a4 = 0;
    }
    free_ContentInfo();
  }
  return v6;
}

uint64_t hx509_cms_unenvelope(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, time_t a7, _QWORD *a8, size_t *a9)
{
  int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  const char *v21;
  uint64_t v22;
  int v23;
  unint64_t v25;
  int v26;
  uint64_t v27;
  unsigned int *v28;
  int *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  int v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  const char *v41;
  uint64_t *v42;
  uint64_t v43;
  _QWORD *v44;
  char v45;
  uint64_t v46;
  char *v47[2];
  _QWORD v48[2];
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  __int128 v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  uint64_t v57;
  size_t v58;
  const void *v59;

  v49 = 0;
  v50 = 0;
  v47[1] = 0;
  v48[0] = 0;
  v58 = 0;
  v59 = 0;
  v52 = 0u;
  v53 = 0u;
  v54 = 0u;
  v55 = 0u;
  v56 = 0u;
  v57 = 0;
  v48[1] = 0;
  *a9 = 0;
  a9[1] = 0;
  if ((a3 & 1) != 0)
    v14 = 64;
  else
    v14 = 192;
  *a8 = 0;
  a8[1] = 0;
  v15 = sub_2096D1CD4();
  if ((_DWORD)v15)
  {
    v20 = v15;
    hx509_set_error_string(a1, 0, v15, "Failed to decode EnvelopedData", v16, v17, v18, v19, v45);
    return v20;
  }
  if ((_DWORD)v53)
  {
    if (*((_QWORD *)&v56 + 1))
    {
      if (a6)
      {
        v20 = 569891;
        v21 = "Both internal and external encrypted data";
LABEL_13:
        v22 = a1;
        v23 = v20;
        goto LABEL_14;
      }
      a6 = *((_QWORD *)&v56 + 1);
    }
    else if (!a6)
    {
      v20 = 569891;
      v21 = "Content missing from encrypted data";
      goto LABEL_13;
    }
    v46 = a6;
    v25 = 0;
    v26 = 0;
    v51 = 0;
    v27 = 104;
    do
    {
      v47[0] = 0;
      v28 = (unsigned int *)(*((_QWORD *)&v53 + 1) + v27);
      v29 = (int *)(*((_QWORD *)&v53 + 1) + v27 - 96);
      if (!sub_2096C2B2C(a1, v29, a2, a7, &v51, v14))
      {
        v34 = v51;
        v35 = sub_2096BFDEC(a1, v28, (uint64_t)(v28 - 6), v51, &v58, v31, v32, v33);
        hx509_cert_free(v34);
        if (!v35)
          goto LABEL_29;
        v51 = 0;
        v26 = 1;
        if (!sub_2096C2CB0(v29, v47))
        {
          hx509_set_error_string(a1, 1, v35, "Failed to decrypt with %s", v30, v31, v32, v33, (char)v47[0]);
          free(v47[0]);
        }
      }
      ++v25;
      v27 += 120;
    }
    while (v25 < v53);
    if (v26)
    {
      v34 = v51;
LABEL_29:
      if (v34)
      {
        v36 = der_copy_oid();
        if ((_DWORD)v36)
        {
          v20 = v36;
          hx509_set_error_string(a1, 0, v36, "Failed to copy EnvelopedData content oid", v37, v38, v39, v40, v45);
          goto LABEL_15;
        }
        if ((_QWORD)v56)
        {
          v50 = *(_QWORD *)(v56 + 8);
          v49 = *(_QWORD *)v56;
          v42 = &v49;
        }
        else
        {
          v42 = 0;
        }
        v47[0] = 0;
        v20 = hx509_crypto_init(a1, 0, (uint64_t)&v55, (_QWORD **)v47);
        if ((_DWORD)v20)
          goto LABEL_15;
        if ((a3 & 2) != 0)
          sub_2096C5AFC((uint64_t)v47[0]);
        if (v42)
        {
          v43 = hx509_crypto_set_params(a1, (uint64_t)v47[0], (uint64_t)v42);
          if ((_DWORD)v43)
          {
            v20 = v43;
            hx509_crypto_destroy((_QWORD *)v47[0]);
            goto LABEL_15;
          }
        }
        v20 = hx509_crypto_set_key_data((uint64_t *)v47[0], v59, v58);
        if ((_DWORD)v20)
        {
          hx509_crypto_destroy((_QWORD *)v47[0]);
          v21 = "Failed to set key for decryption of EnvelopedData";
        }
        else
        {
          if (v48[0])
            v44 = v48;
          else
            v44 = 0;
          v20 = hx509_crypto_decrypt((uint64_t)v47[0], *(_QWORD *)(v46 + 8), *(_QWORD *)v46, v44, a9);
          hx509_crypto_destroy((_QWORD *)v47[0]);
          if (!(_DWORD)v20)
            goto LABEL_15;
          v21 = "Failed to decrypt EnvelopedData";
        }
        goto LABEL_13;
      }
      v20 = 569894;
      v41 = "No private key decrypted the transfer key";
    }
    else
    {
      v20 = 569894;
      v41 = "No matching certificate found in the enveloped data";
    }
    hx509_set_error_string(a1, 1, 569894, v41, v30, v31, v32, v33, v45);
    goto LABEL_15;
  }
  v20 = 569894;
  v21 = "No recipient info in enveloped data";
  v22 = a1;
  v23 = 569894;
LABEL_14:
  hx509_set_error_string(v22, 0, v23, v21, v16, v17, v18, v19, v45);
LABEL_15:
  sub_2096D1D24();
  der_free_octet_string();
  if (v48[0])
    der_free_octet_string();
  if ((_DWORD)v20)
  {
    der_free_oid();
    der_free_octet_string();
  }
  return v20;
}

uint64_t sub_2096C2B2C(uint64_t a1, int *a2, uint64_t a3, time_t a4, _QWORD *a5, int a6)
{
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  int v17;
  uint64_t v18;
  const char *v19;
  int v20;
  uint64_t v21;
  char v22;
  char v24;
  char *v25;
  uint64_t v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  uint64_t v35;

  v35 = 0;
  v33 = 0u;
  v34 = 0u;
  v31 = 0u;
  v32 = 0u;
  v29 = 0u;
  v30 = 0u;
  v27 = 0u;
  v28 = 0u;
  v26 = 0;
  sub_2096C1430((uint64_t)&v27);
  *a5 = 0;
  v16 = *a2;
  if (!*a2)
  {
    v18 = 569894;
    v19 = "unknown CMS identifier element";
LABEL_17:
    v21 = a1;
    v22 = 0;
    goto LABEL_18;
  }
  if (v16 == 1)
  {
    *((_QWORD *)&v28 + 1) = a2 + 12;
    *(_QWORD *)&v30 = a2 + 2;
    v17 = 6;
  }
  else if (v16 == 2)
  {
    *(_QWORD *)&v29 = a2 + 2;
    v17 = 16;
  }
  else
  {
    v17 = v27;
  }
  LODWORD(v27) = v17 | a6 | 0x200000;
  if (!a4)
    a4 = time(0);
  *((_QWORD *)&v33 + 1) = a4;
  v20 = hx509_certs_find(a1, a3, (int *)&v27, &v26, v12, v13, v14, v15);
  if (!v20)
  {
    v18 = 0;
    *a5 = v26;
    return v18;
  }
  v18 = 569894;
  if (v20 != 569873)
  {
    v19 = "Failed to find CMS id in cert store";
    v21 = a1;
    v22 = 1;
LABEL_18:
    hx509_set_error_string(v21, v22, 569894, v19, v12, v13, v14, v15, v24);
    return v18;
  }
  v25 = 0;
  if (!sub_2096C2CB0(a2, &v25))
  {
    v24 = (char)v25;
    v19 = "Failed to find %s";
    goto LABEL_17;
  }
  hx509_clear_error_string(a1);
  return v18;
}

uint64_t sub_2096C2CB0(int *a1, char **a2)
{
  int v3;
  uint64_t v4;
  void *v6;
  void *v7;

  *a2 = 0;
  v3 = *a1;
  if (*a1)
  {
    if (v3 == 2)
    {
      v7 = 0;
      if (rk_hex_encode(*((char **)a1 + 2), *((_QWORD *)a1 + 1), &v7) < 0)
        return 12;
      asprintf(a2, "certificate with id %s", (const char *)v7);
    }
    else
    {
      if (v3 != 1)
        goto LABEL_11;
      v6 = 0;
      v7 = 0;
      v4 = sub_2096CC4D4((uint64_t)(a1 + 2), &v6);
      if ((_DWORD)v4)
        return v4;
      v4 = der_print_hex_heim_integer();
      if ((_DWORD)v4)
      {
        free(v6);
        return v4;
      }
      asprintf(a2, "certificate issued by %s with serial number %s", (const char *)v6, (const char *)v7);
      free(v6);
    }
    free(v7);
  }
  else
  {
    asprintf(a2, "certificate have unknown CMSidentifier type");
  }
LABEL_11:
  if (*a2)
    return 0;
  else
    return 12;
}

uint64_t hx509_cms_envelope_1(uint64_t a1, unsigned int a2, uint64_t a3, const void *a4, size_t a5, void *a6, uint64_t a7, uint64_t a8)
{
  void *v14;
  uint64_t params;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  const char *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  char v26;
  int v27;
  _DWORD *v29;
  uint64_t v30;
  _DWORD *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  size_t v35;
  void *v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  char v45;
  __int128 v46;
  uint64_t v47;
  _QWORD *v48;
  _QWORD v49[2];
  _QWORD v50[2];

  v48 = 0;
  v49[0] = 0;
  v50[0] = 0;
  v50[1] = 0;
  v49[1] = 0;
  v46 = 0u;
  v47 = 0;
  if (a6)
    v14 = a6;
  else
    v14 = &unk_24C1F7B08;
  *(_QWORD *)a8 = 0;
  *(_QWORD *)(a8 + 8) = 0;
  if ((a2 & 1) == 0)
  {
    params = sub_2096BF2A0(a1, a3, 4, 1);
    if ((_DWORD)params)
      goto LABEL_20;
  }
  params = hx509_crypto_init(a1, 0, (uint64_t)v14, &v48);
  if ((_DWORD)params)
    goto LABEL_20;
  if ((a2 & 2) != 0)
    sub_2096C5AFC((uint64_t)v48);
  v16 = hx509_crypto_set_random_key((uint64_t)v48, (uint64_t)v49);
  if ((_DWORD)v16)
  {
    params = v16;
    v21 = "Create random key for EnvelopedData content";
LABEL_17:
    v25 = a1;
    v26 = 0;
LABEL_18:
    v27 = params;
LABEL_19:
    hx509_set_error_string(v25, v26, v27, v21, v17, v18, v19, v20, v45);
    goto LABEL_20;
  }
  v22 = sub_2096C5C7C((uint64_t)v48, (uint64_t)v50);
  if ((_DWORD)v22)
  {
    params = v22;
    v21 = "Failed to create a random iv";
    goto LABEL_17;
  }
  v23 = hx509_crypto_encrypt((uint64_t)v48, a4, a5, (uint64_t)v50, (void ***)&v46 + 1);
  if ((_DWORD)v23)
  {
    params = v23;
    v21 = "Failed to encrypt EnvelopedData content";
    goto LABEL_17;
  }
  v24 = der_copy_oid();
  if ((_DWORD)v24)
  {
    params = v24;
    v21 = "Failed to set crypto oid for EnvelopedData";
    goto LABEL_17;
  }
  if (!malloc_type_calloc(1uLL, 0x10uLL, 0x108004057E67DB5uLL))
  {
    v21 = "Failed to allocate crypto paramaters for EnvelopedData";
LABEL_31:
    params = 12;
    v25 = a1;
    v26 = 0;
    v27 = 12;
    goto LABEL_19;
  }
  params = hx509_crypto_get_params(a1, (uint64_t)v48);
  if ((_DWORD)params)
    goto LABEL_20;
  v29 = malloc_type_calloc(1uLL, 0x78uLL, 0x10B00405CFCCFD2uLL);
  if (!v29)
  {
    v21 = "Failed to allocate recipients info for EnvelopedData";
    goto LABEL_31;
  }
  v31 = v29;
  *v29 = ((a2 & 4) >> 1) ^ 2;
  v32 = sub_2096C3118(a3, (a2 >> 2) & 1, (uint64_t)(v29 + 2), v30, v17, v18, v19, v20);
  if ((_DWORD)v32)
  {
    params = v32;
    v21 = "Failed to set CMS identifier info for EnvelopedData";
    goto LABEL_17;
  }
  v33 = sub_2096BFE30(a1, (unsigned int *)v49, a3, (uint64_t)(v31 + 20), (_QWORD *)v31 + 13);
  if ((_DWORD)v33)
  {
    params = v33;
    v21 = "Failed to encrypt transport key for EnvelopedData";
    v25 = a1;
    v26 = 1;
    goto LABEL_18;
  }
  v34 = der_copy_oid();
  if ((_DWORD)v34)
  {
    params = v34;
    v21 = "Failed to copy content oid for EnvelopedData";
    goto LABEL_17;
  }
  v47 = 0;
  v35 = sub_2096D1D14();
  *(_QWORD *)a8 = v35;
  v36 = malloc_type_malloc(v35, 0xC9B3D09FuLL);
  *(_QWORD *)(a8 + 8) = v36;
  if (!v36)
  {
    params = 12;
    goto LABEL_41;
  }
  v37 = sub_2096D1CF4();
  if ((_DWORD)v37)
  {
    params = v37;
    free(*(void **)(a8 + 8));
    *(_QWORD *)(a8 + 8) = 0;
LABEL_41:
    v21 = "Failed to encode EnvelopedData";
    goto LABEL_17;
  }
  if (*(_QWORD *)a8)
    sub_2096C1D6C("internal ASN.1 encoder error", v38, v39, v40, v41, v42, v43, v44, v45);
  params = 0;
LABEL_20:
  if (v48)
    hx509_crypto_destroy(v48);
  if ((_DWORD)params)
    der_free_octet_string();
  der_free_octet_string();
  der_free_octet_string();
  sub_2096D1D24();
  return params;
}

uint64_t sub_2096C3118(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  uint64_t issuer;
  char v13;
  void *v14;

  if ((_DWORD)a2 == 1)
    goto LABEL_4;
  if ((_DWORD)a2)
    sub_2096C1D6C("CMS fill identifier with unknown type", a2, a3, a4, a5, a6, a7, a8, v13);
  *(_DWORD *)a3 = 2;
  v10 = sub_2096BEAC8(a1);
  if (!sub_2096BEF3C(v10, (_QWORD *)(a3 + 8)))
    return 0;
LABEL_4:
  v14 = 0;
  *(_DWORD *)a3 = 1;
  issuer = hx509_cert_get_issuer(a1, &v14);
  if (!(_DWORD)issuer)
  {
    issuer = hx509_name_to_Name();
    hx509_name_free(&v14);
    if (!(_DWORD)issuer)
      return hx509_cert_get_serialnumber();
  }
  return issuer;
}

uint64_t hx509_cms_verify_signed(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, _QWORD *a8, size_t *a9, __CFArray **a10)
{
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t appended;
  const char *v21;
  uint64_t v22;
  int v23;
  CFMutableArrayRef v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  int *v31;
  uint64_t v32;
  time_t v33;
  uint64_t v34;
  uint64_t v35;
  time_t v36;
  uint64_t v37;
  _QWORD *v38;
  uint64_t v39;
  _DWORD *v40;
  uint64_t v41;
  unint64_t v42;
  void *v43;
  _QWORD *v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  char v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  char v56;
  int v57;
  const char *v58;
  uint64_t v59;
  int v60;
  const char *v61;
  void **v62;
  uint64_t v63;
  __CFArray **v64;
  int v65;
  uint64_t v66;
  unint64_t v67;
  _QWORD *v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  char v78;
  int v79;
  _QWORD *v80;
  _QWORD *v81;
  uint64_t v82;
  _QWORD v83[2];
  uint64_t v84;
  uint64_t v85;
  __CFArray **v86;
  _QWORD v87[2];
  size_t v88;
  void *v89;
  uint64_t v90;
  _OWORD v91[2];
  __int128 v92;
  __int128 v93;
  __int128 v94;
  uint64_t v95;
  void **v96[2];

  v95 = 0;
  v96[0] = 0;
  v90 = 0;
  *a10 = 0;
  *a9 = 0;
  a9[1] = 0;
  *a8 = 0;
  a8[1] = 0;
  memset(v91, 0, sizeof(v91));
  v92 = 0u;
  v93 = 0u;
  v94 = 0u;
  v15 = sub_2096D1C44();
  if ((_DWORD)v15)
  {
    appended = v15;
    v21 = "Failed to decode SignedData";
    goto LABEL_3;
  }
  if (!(a6 | *((_QWORD *)&v92 + 1)))
  {
    appended = 569891;
    v21 = "No content data in SignedData";
LABEL_9:
    v22 = a1;
    v23 = 569891;
    goto LABEL_10;
  }
  if (a6 && *((_QWORD *)&v92 + 1))
  {
    appended = 569891;
    v21 = "Both external and internal SignedData";
    goto LABEL_9;
  }
  appended = der_copy_octet_string();
  if ((_DWORD)appended)
  {
    v21 = "malloc: out of memory";
    goto LABEL_3;
  }
  appended = hx509_certs_init(a1, "MEMORY:cms-cert-buffer", 0, 0, &v95);
  if (!(_DWORD)appended)
  {
    v25 = heim_array_create();
    *a10 = v25;
    if (!v25)
    {
      appended = 12;
      goto LABEL_11;
    }
    appended = sub_2096C3934(a1, (uint64_t)v91, v95);
    if (!(_DWORD)appended)
    {
      if (!a7 || (appended = hx509_certs_merge(a1, v95, a7, v26, v16, v17, v18, v19), !(_DWORD)appended))
      {
        if (!(_DWORD)v94)
        {
          if ((a3 & 4) == 0)
            goto LABEL_106;
          goto LABEL_107;
        }
        v27 = 0;
        v79 = 0;
        while (1)
        {
          v88 = 0;
          v89 = 0;
          v87[0] = 0;
          v87[1] = 0;
          v86 = 0;
          v28 = *((_QWORD *)&v94 + 1) + 160 * v27;
          v30 = *(_QWORD *)(v28 + 136);
          v29 = v28 + 136;
          if (v30)
          {
            v82 = *((_QWORD *)&v94 + 1);
            v31 = (int *)(*((_QWORD *)&v94 + 1) + 160 * v27 + 8);
            v32 = v95;
            v33 = sub_2096BEEE4(a2);
            v34 = sub_2096C2B2C(a1, v31, v32, v33, v96, 256);
            if (!(_DWORD)v34
              || (a3 & 2) != 0
              && (v35 = v95, v36 = sub_2096BEEE4(a2), v34 = sub_2096C2B2C(a1, v31, v35, v36, v96, 0), !(_DWORD)v34))
            {
              v37 = v82 + 160 * v27;
              v39 = *(_QWORD *)(v37 + 104);
              v38 = (_QWORD *)(v37 + 104);
              v81 = v38;
              if (!v39)
              {
                v43 = (void *)a9[1];
                v88 = *a9;
                v89 = v43;
                v44 = &asn1_oid_id_pkcs7_data;
                goto LABEL_42;
              }
              v84 = 0;
              v85 = 0;
              v83[0] = 0;
              v83[1] = 0;
              v40 = (_DWORD *)*v38;
              v85 = *(_QWORD *)(*v38 + 8);
              LODWORD(v84) = *v40;
              if (!(_DWORD)v84)
                goto LABEL_48;
              v41 = 0;
              v42 = 0;
              while (der_heim_oid_cmp())
              {
                ++v42;
                v41 += 32;
                if (v42 >= v84)
                  goto LABEL_48;
              }
              if (v85)
              {
                if (*(_DWORD *)(v85 + v41 + 16) == 1)
                {
                  v50 = sub_2096D1ACC();
                  if ((_DWORD)v50)
                  {
                    appended = v50;
                    v55 = a1;
                    v56 = 0;
                    v57 = appended;
                    v58 = "Failed to decode messageDigest (signature)";
                    goto LABEL_78;
                  }
                  appended = hx509_verify_signature_0(a1, 0, v82 + 160 * v27 + 80, (uint64_t)a9, (uint64_t)v83);
                  der_free_octet_string();
                  if ((_DWORD)appended)
                  {
                    v55 = a1;
                    v56 = 1;
                    v57 = appended;
                    v58 = "Failed to verify messageDigest";
LABEL_78:
                    hx509_set_error_string(v55, v56, v57, v58, v51, v52, v53, v54, v78);
LABEL_59:
                    v62 = v96[0];
                    if (v96[0])
LABEL_60:
                      hx509_cert_free(v62);
LABEL_61:
                    v96[0] = 0;
                    goto LABEL_62;
                  }
                  if (!(_DWORD)v84)
                    goto LABEL_88;
                  v66 = 0;
                  v67 = 0;
                  while (der_heim_oid_cmp())
                  {
                    ++v67;
                    v66 += 32;
                    if (v67 >= v84)
                      goto LABEL_88;
                  }
                  if (v85)
                  {
                    if (*(_DWORD *)(v85 + v66 + 16) != 1)
                    {
                      appended = 569895;
                      v59 = a1;
                      v60 = 569895;
                      v61 = "More then one oid in signedAttrs";
                      goto LABEL_49;
                    }
                    v68 = v87;
                    v69 = sub_2096D1A7C();
                    if ((_DWORD)v69)
                    {
                      appended = v69;
                      v59 = a1;
                      v60 = appended;
                      v61 = "Failed to decode oid in signedAttrs";
                      goto LABEL_49;
                    }
                  }
                  else
                  {
LABEL_88:
                    v68 = &asn1_oid_id_pkcs7_data;
                  }
                  v88 = sub_2096D1C24();
                  v89 = malloc_type_malloc(v88, 0x34E3E92EuLL);
                  if (!v89)
                  {
                    appended = 12;
                    goto LABEL_93;
                  }
                  v70 = sub_2096D1C04();
                  if ((_DWORD)v70)
                  {
                    appended = v70;
                    free(v89);
                    v89 = 0;
LABEL_93:
                    if (v68 == v87)
                      der_free_oid();
                    hx509_clear_error_string(a1);
                    goto LABEL_59;
                  }
                  if (v90 != v88)
                    sub_2096C1D6C("internal ASN.1 encoder error", v71, v72, v73, v74, v75, v76, v77, v78);
                  v44 = v68;
LABEL_42:
                  v80 = v44;
                  v45 = der_heim_oid_cmp();
                  v49 = a3 | ((_DWORD)v45 == 0);
                  if (a3 & 1 | ((_DWORD)v45 == 0))
                  {
                    appended = 0;
                  }
                  else
                  {
                    appended = 569895;
                    hx509_set_error_string(a1, 0, 569895, "Oid in message mismatch from the expected", v16, v17, v18, v19, v78);
                  }
                  if (v80 == v87)
                    v45 = der_free_oid();
                  if ((v49 & 1) != 0)
                  {
                    v45 = hx509_verify_signature(a1, (uint64_t)v96[0], v82 + 160 * v27 + 112, (uint64_t)&v88, v29);
                    appended = v45;
                    if ((_DWORD)v45)
                      hx509_set_error_string(a1, 1, v45, "Failed to verify signature in CMS SignedData", v16, v17, v18, v19, v78);
                  }
                  if (*v81)
                  {
                    free(v89);
                    v89 = 0;
                  }
                  if ((_DWORD)appended)
                    goto LABEL_59;
                  if ((a3 & 8) != 0)
                  {
                    v64 = (__CFArray **)sub_2096BFE38(v45, v46, v47, v48, v16, v17, v18, v19);
                    v86 = v64;
                    if (!v64)
                    {
                      appended = 0;
                      goto LABEL_59;
                    }
                    appended = heim_array_append_value(v64[4], v96[0]);
                    if (!(_DWORD)appended)
                      goto LABEL_70;
                  }
                  else
                  {
                    v62 = v96[0];
                    v63 = sub_2096BFEF0(a1, a2, v96[0], v95, (CFTypeRef *)&v86);
                    if ((_DWORD)v63)
                    {
                      appended = v63;
                      if (v62)
                        goto LABEL_60;
                      goto LABEL_61;
                    }
LABEL_70:
                    appended = heim_array_append_value(*a10, v86);
                  }
                  heim_release(v86);
                  v65 = v79;
                  if (!(_DWORD)appended)
                    v65 = v79 + 1;
                  v79 = v65;
                  goto LABEL_59;
                }
                appended = 569922;
                v59 = a1;
                v60 = 569922;
                v61 = "SignerInfo have more then one messageDigest (signature)";
              }
              else
              {
LABEL_48:
                appended = 569922;
                v59 = a1;
                v60 = 569922;
                v61 = "SignerInfo have signed attributes but messageDigest (signature) is missing";
              }
LABEL_49:
              hx509_set_error_string(v59, 0, v60, v61, v16, v17, v18, v19, v78);
              goto LABEL_59;
            }
            appended = v34;
          }
          else
          {
            appended = 569889;
            hx509_set_error_string(a1, 0, 569889, "SignerInfo %d in SignedData missing sigature", v16, v17, v18, v19, v27);
          }
LABEL_62:
          if (++v27 >= (unint64_t)v94)
          {
            if ((a3 & 4) == 0 || (_DWORD)v94)
            {
              if (!v79)
              {
                if (!(_DWORD)appended)
                {
LABEL_106:
                  appended = 569890;
                  v21 = "No signers where found";
LABEL_3:
                  v22 = a1;
                  v23 = appended;
LABEL_10:
                  hx509_set_error_string(v22, 0, v23, v21, v16, v17, v18, v19, v78);
                }
                break;
              }
LABEL_108:
              appended = der_copy_oid();
              if ((_DWORD)appended)
                hx509_clear_error_string(a1);
              break;
            }
LABEL_107:
            heim_release(*a10);
            *a10 = 0;
            goto LABEL_108;
          }
        }
      }
    }
  }
LABEL_11:
  sub_2096D1C94();
  if (v95)
    hx509_certs_free((const void **)&v95);
  if ((_DWORD)appended)
  {
    if (a9[1])
      der_free_octet_string();
    if (*a10)
    {
      heim_release(*a10);
      *a10 = 0;
    }
    der_free_oid();
    der_free_octet_string();
  }
  return appended;
}

uint64_t sub_2096C3934(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unsigned int *v3;
  uint64_t v7;
  unint64_t v8;
  uint64_t inited;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v17;

  v3 = *(unsigned int **)(a2 + 48);
  if (!v3 || !*v3)
    return 0;
  v7 = 0;
  v8 = 0;
  while (1)
  {
    v17 = 0;
    inited = hx509_cert_init_data(a1, *(_QWORD *)(*((_QWORD *)v3 + 1) + v7 + 8), *(_QWORD *)(*((_QWORD *)v3 + 1) + v7), (CFTypeRef *)&v17);
    if ((_DWORD)inited)
      break;
    v15 = hx509_certs_add(a1, a3, v17, v10, v11, v12, v13, v14);
    hx509_cert_free(v17);
    if ((_DWORD)v15)
      return v15;
    ++v8;
    v3 = *(unsigned int **)(a2 + 48);
    v7 += 16;
    if (v8 >= *v3)
      return 0;
  }
  return inited;
}

uint64_t hx509_cms_create_signed_1(uint64_t a1, char a2, void *a3, const void *a4, size_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, _QWORD *a11)
{
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v26;

  v26 = 0;
  *a11 = 0;
  a11[1] = 0;
  v24 = hx509_certs_init(a1, "MEMORY:certs", 0, 0, &v26);
  if (!(_DWORD)v24)
  {
    v24 = hx509_certs_add(a1, v26, a7, v19, v20, v21, v22, v23);
    if (!(_DWORD)v24)
      v24 = hx509_cms_create_signed(a1, a2, a3, a4, a5, a6, v26, a8, a9, a10, (uint64_t)a11);
    hx509_certs_free((const void **)&v26);
  }
  return v24;
}

uint64_t hx509_cms_create_signed(uint64_t a1, char a2, void *a3, const void *a4, size_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  void *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  void *v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  size_t v31;
  void *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  _OWORD v42[2];
  __int128 v43;
  __int128 v44;
  __int128 v45;
  uint64_t v46;
  void *v47;
  size_t v48;
  const void *v49;
  uint64_t v50;
  int8x8_t v51;
  __int128 v52;
  uint64_t v53;
  uint64_t v54;

  v54 = 0;
  if (a3)
    v16 = a3;
  else
    v16 = &asn1_oid_id_pkcs7_data;
  v53 = 0;
  v52 = 0u;
  v45 = 0u;
  v43 = 0u;
  v44 = 0u;
  memset(v42, 0, sizeof(v42));
  v48 = a5;
  v49 = a4;
  v46 = a6;
  v47 = v16;
  v50 = a8;
  v51 = vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(a2), (uint32x2_t)0xFFFFFFFDFFFFFFFFLL), (int8x8_t)0x100000001);
  if ((a2 & 0x10) != 0 || (v17 = hx509_certs_init(a1, "MEMORY:certs", 0, 0, &v52), !(_DWORD)v17))
  {
    *((_QWORD *)&v52 + 1) = a9;
    v53 = a10;
    LODWORD(v42[0]) = 3;
    der_copy_oid();
    if ((a2 & 1) == 0)
    {
      *((_QWORD *)&v43 + 1) = malloc_type_calloc(1uLL, 0x10uLL, 0x108004057E67DB5uLL);
      if (!*((_QWORD *)&v43 + 1))
        goto LABEL_27;
      v22 = malloc_type_malloc(a5, 0xCE3E4B8EuLL);
      *(_QWORD *)(*((_QWORD *)&v43 + 1) + 8) = v22;
      if (!v22)
        goto LABEL_27;
      memcpy(v22, a4, a5);
      **((_QWORD **)&v43 + 1) = a5;
    }
    if ((a2 & 4) == 0)
    {
      v17 = hx509_certs_iter_f(a1, a7, (uint64_t (*)(uint64_t, uint64_t))sub_2096C3DB4, (uint64_t)v42, v18, v19, v20, v21);
      if ((_DWORD)v17)
        goto LABEL_30;
    }
    if ((_DWORD)v45)
    {
      v23 = 0;
      while (1)
      {
        if (!DWORD2(v42[0]))
          goto LABEL_37;
        v24 = 0;
        v25 = 0;
        do
        {
          if (!der_heim_oid_cmp())
            break;
          ++v25;
          v24 += 24;
        }
        while (v25 < DWORD2(v42[0]));
        if (DWORD2(v42[0]) == (_DWORD)v25)
        {
LABEL_37:
          v26 = sub_2096D1A00((unsigned int *)v42 + 2);
          if ((_DWORD)v26)
            break;
        }
        if (++v23 >= (unint64_t)v45)
          goto LABEL_21;
      }
      v17 = v26;
      goto LABEL_29;
    }
LABEL_21:
    if (!(_QWORD)v52)
      goto LABEL_24;
    *(_QWORD *)&v44 = malloc_type_calloc(1uLL, 0x10uLL, 0x1020040D5A9D86FuLL);
    if ((_QWORD)v44)
    {
      v17 = hx509_certs_iter_f(a1, v52, (uint64_t (*)(uint64_t, uint64_t))sub_2096C429C, (uint64_t)v42, v27, v28, v29, v30);
      if ((_DWORD)v17)
      {
LABEL_30:
        hx509_certs_free((const void **)&v52);
        sub_2096D1C94();
        return v17;
      }
LABEL_24:
      v31 = sub_2096D1C84();
      *(_QWORD *)a11 = v31;
      v32 = malloc_type_malloc(v31, 0xAB1A4366uLL);
      *(_QWORD *)(a11 + 8) = v32;
      if (v32)
      {
        v33 = sub_2096D1C64();
        if (!(_DWORD)v33)
        {
          if (*(_QWORD *)a11 != v54)
            sub_2096C1D6C("internal ASN.1 encoder error", v34, v35, v36, v37, v38, v39, v40, v42[0]);
          v17 = 0;
          goto LABEL_30;
        }
        v17 = v33;
        free(*(void **)(a11 + 8));
        *(_QWORD *)(a11 + 8) = 0;
        goto LABEL_29;
      }
    }
LABEL_27:
    v17 = 12;
LABEL_29:
    hx509_clear_error_string(a1);
    goto LABEL_30;
  }
  return v17;
}

uint64_t sub_2096C3DB4(uint64_t a1, uint64_t a2, const void *a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  char *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  char *v22;
  int v23;
  char *v24;
  uint64_t v25;
  char *v26;
  _DWORD **v27;
  _DWORD *v29;
  size_t v30;
  void *v31;
  void *v32;
  uint64_t v33;
  void *v34;
  char *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  size_t v53;
  void *v54;
  uint64_t v55;
  time_t v56;
  uint64_t v57;
  unsigned int v58;
  _DWORD *v60;
  uint64_t v61;
  char v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  _QWORD v66[2];
  unint64_t v67;
  uint64_t v68;
  uint64_t v69;
  _QWORD v70[3];
  size_t v71;
  void *v72;
  size_t v73;
  void *v74;

  v71 = 0;
  v72 = 0;
  v69 = 0;
  memset(v70, 0, sizeof(v70));
  v67 = 0;
  v68 = 0;
  if (!_hx509_cert_private_key((uint64_t)a3))
  {
    v11 = 569865;
    hx509_set_error_string(a1, 0, 569865, "Private key missing for signing", v6, v7, v8, v9, v62);
    return v11;
  }
  if (!*(_QWORD *)(a2 + 80))
  {
    v12 = (char *)_hx509_cert_private_key((uint64_t)a3);
    v11 = hx509_crypto_select(a1, 1, v12, *(_QWORD *)(a2 + 112), v70, v13, v14, v15);
    if ((_DWORD)v11)
      goto LABEL_15;
LABEL_8:
    v16 = (char *)malloc_type_realloc(*(void **)(a2 + 72), 160 * (*(_DWORD *)(a2 + 64) + 1), 0x10B0040C24DB5AAuLL);
    if (!v16)
    {
      v11 = 12;
      goto LABEL_15;
    }
    v22 = v16;
    *(_QWORD *)(a2 + 72) = v16;
    v23 = *(_DWORD *)(a2 + 64);
    v24 = &v16[160 * v23];
    *((_OWORD *)v24 + 8) = 0u;
    *((_OWORD *)v24 + 9) = 0u;
    *((_OWORD *)v24 + 6) = 0u;
    *((_OWORD *)v24 + 7) = 0u;
    *((_OWORD *)v24 + 4) = 0u;
    *((_OWORD *)v24 + 5) = 0u;
    *((_OWORD *)v24 + 2) = 0u;
    *((_OWORD *)v24 + 3) = 0u;
    *(_OWORD *)v24 = 0u;
    *((_OWORD *)v24 + 1) = 0u;
    *(_DWORD *)v24 = 1;
    v25 = sub_2096C3118((uint64_t)a3, *(unsigned int *)(a2 + 120), (uint64_t)(v24 + 8), v17, v18, v19, v20, v21);
    if ((_DWORD)v25
      || (v26 = &v22[160 * v23],
          *((_QWORD *)v26 + 13) = 0,
          v27 = (_DWORD **)(v26 + 104),
          v27[6] = 0,
          v25 = copy_AlgorithmIdentifier(),
          (_DWORD)v25))
    {
      v11 = v25;
LABEL_12:
      hx509_clear_error_string(a1);
      goto LABEL_13;
    }
    if (der_heim_oid_cmp())
    {
      v63 = 0;
      v64 = 0;
      v66[0] = 0;
      v66[1] = 0;
      v29 = malloc_type_calloc(1uLL, 0x10uLL, 0x1020040D5A9D86FuLL);
      *v27 = v29;
      if (!v29)
        goto LABEL_39;
      v11 = sub_2096C4F38(a1, 0, (uint64_t)v70, a2 + 96, 0, (uint64_t)v66);
      if ((_DWORD)v11)
        goto LABEL_13;
      v73 = 0;
      v74 = 0;
      v30 = sub_2096D1B0C();
      v73 = v30;
      v31 = malloc_type_malloc(v30, 0x10D79C97uLL);
      v74 = v31;
      if (!v31)
      {
        v11 = 12;
        goto LABEL_32;
      }
      v32 = v31;
      v33 = sub_2096D1AEC();
      if ((_DWORD)v33)
      {
        v11 = v33;
        free(v32);
LABEL_32:
        der_free_octet_string();
        goto LABEL_12;
      }
      der_free_octet_string();
      if (v69 != v30)
        goto LABEL_54;
      v52 = sub_2096C4474((void **)*v27 + 1, *v27, (uint64_t)&unk_24C1F5320, (uint64_t *)&v73);
      if ((_DWORD)v52)
      {
LABEL_35:
        v11 = v52;
        free(v32);
        goto LABEL_12;
      }
      v53 = sub_2096D1ABC();
      v73 = v53;
      v54 = malloc_type_malloc(v53, 0x97F8D380uLL);
      v74 = v54;
      if (!v54)
      {
LABEL_39:
        v11 = 12;
        goto LABEL_13;
      }
      v32 = v54;
      v55 = sub_2096D1A9C();
      if ((_DWORD)v55)
      {
        v11 = v55;
        free(v32);
        goto LABEL_13;
      }
      if (v69 != v53)
        goto LABEL_54;
      v52 = sub_2096C4474((void **)*v27 + 1, *v27, (uint64_t)&unk_24C1F5310, (uint64_t *)&v73);
      if ((_DWORD)v52)
        goto LABEL_35;
      v60 = *v27;
      v64 = *((_QWORD *)*v27 + 1);
      LODWORD(v63) = *v60;
      v71 = sub_2096D1C24();
      v72 = malloc_type_malloc(v71, 0x374F05E2uLL);
      if (!v72)
      {
        v11 = 12;
        goto LABEL_12;
      }
      v61 = sub_2096D1C04();
      if ((_DWORD)v61)
      {
        v11 = v61;
        free(v72);
        v72 = 0;
        goto LABEL_12;
      }
      if (v69 != v71)
LABEL_54:
        sub_2096C1D6C("internal ASN.1 encoder error", v45, v46, v47, v48, v49, v50, v51, v62);
    }
    else
    {
      v34 = *(void **)(a2 + 104);
      v71 = *(_QWORD *)(a2 + 96);
      v72 = v34;
    }
    v63 = 0;
    v64 = 0;
    v65 = 0;
    v35 = (char *)_hx509_cert_private_key((uint64_t)a3);
    v11 = hx509_crypto_select(a1, 2, v35, *(_QWORD *)(a2 + 112), &v63, v36, v37, v38);
    if (!(_DWORD)v11)
    {
      v39 = _hx509_cert_private_key((uint64_t)a3);
      v11 = sub_2096C4F38(a1, v39, (uint64_t)&v63, (uint64_t)&v71, (uint64_t)&v22[160 * v23 + 112], (uint64_t)&v22[160 * v23 + 136]);
      free_AlgorithmIdentifier();
      if (!(_DWORD)v11)
      {
        ++*(_DWORD *)(a2 + 64);
        if (*(_QWORD *)(a2 + 144) && !*(_DWORD *)(a2 + 124))
        {
          v56 = time(0);
          sub_2096BF6F4(a1, 1, v56, *(_QWORD *)(a2 + 136), 0, a3, *(_QWORD *)(a2 + 144), (uint64_t *)&v67);
        }
        else
        {
          sub_2096BF608(a1, (uint64_t *)&v67, a3);
        }
        if (!v67)
        {
          v11 = 0;
          goto LABEL_15;
        }
        v57 = 0;
        v58 = 1;
        while (1)
        {
          v11 = hx509_certs_add(a1, *(_QWORD *)(a2 + 128), *(_QWORD *)(v68 + 8 * v57), v40, v41, v42, v43, v44);
          if ((_DWORD)v11)
            goto LABEL_5;
          v57 = v58;
          if (v67 <= v58++)
            goto LABEL_15;
        }
      }
    }
LABEL_13:
    sub_2096D1C34();
    goto LABEL_15;
  }
  v10 = copy_AlgorithmIdentifier();
  if (!(_DWORD)v10)
    goto LABEL_8;
  v11 = v10;
LABEL_5:
  hx509_clear_error_string(a1);
LABEL_15:
  if (v72 != *(void **)(a2 + 104))
    der_free_octet_string();
  sub_2096BF69C((uint64_t)&v67);
  free_AlgorithmIdentifier();
  return v11;
}

uint64_t sub_2096C429C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  void **v6;
  uint64_t v7;
  void *v8;
  uint64_t result;

  v6 = *(void ***)(a2 + 48);
  v7 = *(unsigned int *)v6;
  v8 = malloc_type_realloc(v6[1], 16 * (v7 + 1), 0x108004057E67DB5uLL);
  if (!v8)
    return 12;
  *(_QWORD *)(*(_QWORD *)(a2 + 48) + 8) = v8;
  result = hx509_cert_binary(a1, a3, (uint64_t)v8 + 16 * v7);
  if (!(_DWORD)result)
    ++**(_DWORD **)(a2 + 48);
  return result;
}

uint64_t hx509_cms_decrypt_encrypted(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, _QWORD *a6)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  void *v23[2];

  v21 = 0u;
  v22 = 0u;
  v20 = 0u;
  *a6 = 0;
  a6[1] = 0;
  v23[0] = 0;
  v23[1] = 0;
  v9 = sub_2096D1CA4();
  if ((_DWORD)v9)
  {
    v14 = v9;
    hx509_set_error_string(a1, 0, v9, "Failed to decode CMSEncryptedData", v10, v11, v12, v13, 0);
  }
  else
  {
    if ((_QWORD)v22)
    {
      v15 = der_copy_oid();
      if ((_DWORD)v15)
      {
        v14 = v15;
        hx509_clear_error_string(a1);
      }
      else if (*((_QWORD *)&v21 + 1))
      {
        v14 = sub_2096C6168(a1, a2, (uint64_t)&v20 + 8, v22, v23, v16, v17, v18);
        if ((_DWORD)v14)
        {
          if (v23[1])
            free(v23[1]);
        }
        else
        {
          *(_OWORD *)a6 = *(_OWORD *)v23;
        }
      }
      else
      {
        hx509_clear_error_string(a1);
        v14 = 569866;
      }
    }
    else
    {
      v14 = 569891;
      hx509_set_error_string(a1, 0, 569891, "No content in EncryptedData", v10, v11, v12, v13, 0);
    }
    sub_2096D1CC4();
  }
  return v14;
}

uint64_t sub_2096C4474(void **a1, _DWORD *a2, uint64_t a3, uint64_t *a4)
{
  void *v7;
  uint64_t result;
  void *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  v7 = malloc_type_realloc(*a1, 32 * (*a2 + 1), 0x10300406495394CuLL);
  if (v7)
  {
    *a1 = v7;
    result = der_copy_oid();
    if ((_DWORD)result)
      return result;
    *((_DWORD *)*a1 + 8 * *a2 + 4) = 1;
    v9 = malloc_type_calloc(1uLL, 0x10uLL, 0x108004057E67DB5uLL);
    v10 = *a2;
    *((_QWORD *)*a1 + 4 * v10 + 3) = v9;
    v11 = *((_QWORD *)*a1 + 4 * v10 + 3);
    if (v11)
    {
      result = 0;
      v12 = *a4;
      *(_QWORD *)(v11 + 8) = a4[1];
      **((_QWORD **)*a1 + 4 * v10 + 3) = v12;
      *a2 = v10 + 1;
      return result;
    }
    der_free_oid();
  }
  return 12;
}

uint64_t sub_2096C4564(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  const void **v12;
  uint64_t v13;
  uint64_t v14;
  char v16;

  *a3 = 0;
  v6 = malloc_type_calloc(1uLL, 0x28uLL, 0x10A0040688ABBCCuLL);
  if (v6)
  {
    v11 = v6;
    *v6 = a2;
    v12 = (const void **)(v6 + 1);
    v13 = hx509_certs_init(a1, "MEMORY:collector-unenvelop-cert", 0, 0, v6 + 1);
    if ((_DWORD)v13)
    {
      v14 = v13;
    }
    else
    {
      v11[3] = 0;
      v11[4] = 0;
      v14 = hx509_certs_init(a1, "MEMORY:collector-tmp-store", 0, 0, v11 + 2);
      if (!(_DWORD)v14)
      {
        *a3 = v11;
        return v14;
      }
      hx509_certs_free(v12);
    }
    free(v11);
  }
  else
  {
    v14 = 12;
    hx509_set_error_string(a1, 0, 12, "out of memory", v7, v8, v9, v10, v16);
  }
  return v14;
}

uint64_t sub_2096C4654(uint64_t a1)
{
  return *(_QWORD *)a1;
}

uint64_t sub_2096C465C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return hx509_certs_add(a1, *(_QWORD *)(a2 + 16), a3, a4, a5, a6, a7, a8);
}

uint64_t sub_2096C4664(uint64_t a1, uint64_t a2, uint64_t a3, const void *a4, uint64_t *a5, uint64_t a6)
{
  CFTypeRef *v12;
  CFTypeRef *v13;
  void *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  const char *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  char v29;

  v12 = (CFTypeRef *)malloc_type_calloc(1uLL, 0x30uLL, 0x10B0040D89DD10BuLL);
  if (!v12)
    return 12;
  v13 = v12;
  v14 = malloc_type_realloc(*(void **)(a2 + 24), 8 * *(_QWORD *)(a2 + 32) + 8, 0x2004093837F09uLL);
  if (!v14)
  {
    free(v13);
    v20 = 12;
    hx509_set_error_string(a1, 0, 12, "Out of memory", v22, v23, v24, v25, v29);
    return v20;
  }
  *(_QWORD *)(a2 + 24) = v14;
  v15 = copy_AlgorithmIdentifier();
  if (!(_DWORD)v15)
  {
    if (a4)
    {
      v13[3] = a4;
    }
    else
    {
      v20 = sub_2096C5308(a1, a3, a5[1], *a5, 1, v13 + 3);
      if ((_DWORD)v20)
        goto LABEL_6;
    }
    if (a6)
    {
      v26 = der_copy_octet_string();
      if ((_DWORD)v26)
      {
        v20 = v26;
        v21 = "Failed to copy localKeyId";
        goto LABEL_5;
      }
    }
    else
    {
      v13[4] = 0;
      v13[5] = 0;
    }
    v20 = 0;
    v27 = *(_QWORD *)(a2 + 32);
    *(_QWORD *)(*(_QWORD *)(a2 + 24) + 8 * v27) = v13;
    *(_QWORD *)(a2 + 32) = v27 + 1;
    return v20;
  }
  v20 = v15;
  v21 = "Failed to copy AlgorithmIdentifier";
LABEL_5:
  hx509_set_error_string(a1, 0, v20, v21, v16, v17, v18, v19, v29);
LABEL_6:
  sub_2096C47CC(v13);
  return v20;
}

void sub_2096C47CC(const void **a1)
{
  free_AlgorithmIdentifier();
  if (a1[3])
    hx509_private_key_free(a1 + 3);
  der_free_octet_string();
  free(a1);
}

uint64_t sub_2096C4808(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  unsigned int v35;
  int cert;
  BOOL v37;
  char v39;
  uint64_t v40;
  _OWORD v41[2];
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  uint64_t v48;
  uint64_t v49[2];

  v40 = 0;
  *a3 = 0;
  v11 = hx509_certs_init(a1, "MEMORY:collector-store", 0, 0, &v40);
  if (!(_DWORD)v11)
  {
    v12 = hx509_certs_merge(a1, v40, a2[2], v6, v7, v8, v9, v10);
    if ((_DWORD)v12)
    {
      v11 = v12;
      hx509_certs_free((const void **)&v40);
      return v11;
    }
    if (!a2[4])
    {
LABEL_28:
      v11 = 0;
      *a3 = v40;
      return v11;
    }
    v17 = 0;
    while (1)
    {
      v18 = *(_QWORD *)(a2[3] + 8 * v17);
      if (!*(_QWORD *)(v18 + 32))
        break;
      v19 = v40;
      v49[0] = 0;
      memset(v41, 0, sizeof(v41));
      v42 = 0u;
      v43 = 0u;
      v44 = 0u;
      v45 = 0u;
      v46 = 0u;
      v47 = 0u;
      v48 = 0;
      sub_2096C1430((uint64_t)v41);
      LODWORD(v41[0]) |= 0x10000u;
      *((_QWORD *)&v42 + 1) = v18 + 32;
      if (hx509_certs_find(a1, v19, (int *)v41, v49, v20, v21, v22, v23))
        goto LABEL_12;
      v29 = *(_QWORD *)(v18 + 24);
      if (v29)
        _hx509_cert_set_key(v49[0], v29);
      hx509_cert_free(v49[0]);
LABEL_25:
      if (++v17 >= (unint64_t)a2[4])
        goto LABEL_28;
    }
    hx509_set_error_string(a1, 0, 569964, "No local key attribute on private key", v13, v14, v15, v16, v39);
LABEL_12:
    v30 = *(_QWORD *)(a2[3] + 8 * v17);
    if (*(_QWORD *)(v30 + 24))
    {
      v31 = v40;
      *(_QWORD *)&v41[0] = 0;
      if (!hx509_certs_start_seq(a1, v40, (uint64_t)v41, v24, v25, v26, v27, v28))
      {
        v49[0] = 0;
        if (hx509_certs_next_cert(a1, v31, *(uint64_t *)&v41[0], v49) || (v32 = v49[0]) == 0)
        {
LABEL_23:
          hx509_certs_end_seq(a1, v31, *(uint64_t *)&v41[0]);
          hx509_clear_error_string(a1);
        }
        else
        {
          while (1)
          {
            v33 = _hx509_cert_private_key(v32);
            v34 = v49[0];
            if (!v33)
            {
              v35 = sub_2096C619C(v49[0], *(_QWORD *)(v30 + 24));
              v34 = v49[0];
              if (v35)
                break;
            }
            hx509_cert_free(v34);
            cert = hx509_certs_next_cert(a1, v31, *(uint64_t *)&v41[0], v49);
            v32 = v49[0];
            if (cert)
              v37 = 1;
            else
              v37 = v49[0] == 0;
            if (v37)
              goto LABEL_23;
          }
          _hx509_cert_set_key(v49[0], *(_QWORD *)(v30 + 24));
          hx509_cert_free(v49[0]);
          hx509_certs_end_seq(a1, v31, *(uint64_t *)&v41[0]);
        }
      }
    }
    else
    {
      hx509_set_error_string(a1, 0, 569865, "No private key to compare with", v25, v26, v27, v28, v39);
    }
    goto LABEL_25;
  }
  return v11;
}

uint64_t sub_2096C4A74(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  size_t v10;
  _QWORD *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  char v23;

  *a3 = 0;
  v6 = *(_QWORD *)(a2 + 32);
  if (v6)
  {
    v7 = 0;
    v8 = *(uint64_t **)(a2 + 24);
    do
    {
      v9 = *v8++;
      if (*(_QWORD *)(v9 + 24))
        ++v7;
      --v6;
    }
    while (v6);
    v10 = v7 + 1;
  }
  else
  {
    v10 = 1;
  }
  v11 = malloc_type_calloc(v10, 8uLL, 0x2004093837F09uLL);
  *a3 = v11;
  if (v11)
  {
    v16 = *(_QWORD *)(a2 + 32);
    if (v16)
    {
      v17 = 0;
      v18 = 0;
      v19 = *(_QWORD *)(a2 + 24);
      do
      {
        v20 = *(_QWORD *)(*(_QWORD *)(v19 + 8 * v18) + 24);
        if (v20)
        {
          *(_QWORD *)(*a3 + 8 * v17++) = v20;
          v19 = *(_QWORD *)(a2 + 24);
          *(_QWORD *)(*(_QWORD *)(v19 + 8 * v18) + 24) = 0;
        }
        ++v18;
      }
      while (v16 != v18);
      v11 = (_QWORD *)*a3;
    }
    else
    {
      v17 = 0;
    }
    v21 = 0;
    v11[v17] = 0;
  }
  else
  {
    v21 = 12;
    hx509_set_error_string(a1, 0, 12, "malloc - out of memory", v12, v13, v14, v15, v23);
  }
  return v21;
}

void sub_2096C4B74(char *a1)
{
  const void **v2;
  uint64_t v3;
  unint64_t v4;
  void *v5;

  v3 = *((_QWORD *)a1 + 1);
  v2 = (const void **)(a1 + 8);
  if (v3)
    hx509_certs_free(v2);
  if (*((_QWORD *)a1 + 2))
    hx509_certs_free((const void **)a1 + 2);
  if (*((_QWORD *)a1 + 4))
  {
    v4 = 0;
    do
      sub_2096C47CC(*(const void ***)(*((_QWORD *)a1 + 3) + 8 * v4++));
    while (v4 < *((_QWORD *)a1 + 4));
  }
  v5 = (void *)*((_QWORD *)a1 + 3);
  if (v5)
    free(v5);
  free(a1);
}

_QWORD *sub_2096C4BE4(const void **a1)
{
  _QWORD *v2;

  v2 = sub_2096D4200(a1[1], *(unsigned int *)a1, 0);
  sub_2096D42F8((uint64_t)v2, *((_DWORD *)a1 + 4));
  return v2;
}

uint64_t sub_2096C4C20()
{
  uint64_t v0;
  uint64_t v1;

  v0 = 0;
  while (1)
  {
    v1 = *(uint64_t *)((char *)&off_24C1F6638 + v0);
    if (*(_QWORD *)(v1 + 16))
    {
      if (!der_heim_oid_cmp())
        break;
    }
    v0 += 8;
    if (v0 == 16)
      return 0;
  }
  return v1;
}

uint64_t sub_2096C4C7C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  char **v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  BOOL v13;

  v5 = 0;
  while (1)
  {
    v6 = (&off_24C1F6650)[v5];
    if (!der_heim_oid_cmp())
      break;
    if (++v5 == 15)
    {
      hx509_clear_error_string(a1);
      return 569861;
    }
  }
  v12 = v6[6];
  if (v12)
    v13 = (uint64_t)v12 < a3;
  else
    v13 = 0;
  if (!v13)
    return 0;
  v11 = 569933;
  hx509_set_error_string(a1, 0, 569933, "Algorithm %s has passed it best before date", v7, v8, v9, v10, (char)*v6);
  return v11;
}

uint64_t sub_2096C4D44(uint64_t a1)
{
  uint64_t v2;
  char **v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  v2 = 0;
  while (1)
  {
    v3 = (&off_24C1F6650)[v2];
    if (!der_heim_oid_cmp())
      break;
    if (++v2 == 15)
    {
      hx509_clear_error_string(a1);
      return 569861;
    }
  }
  if (((_BYTE)v3[5] & 4) != 0)
    return 0;
  v8 = 569933;
  hx509_set_error_string(a1, 0, 569933, "Algorithm %s not trusted for self signatures", v4, v5, v6, v7, (char)*v3);
  return v8;
}

uint64_t hx509_verify_signature_0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v9;
  uint64_t v10;
  char **v11;
  uint64_t v12;
  int v13;

  if (a2)
    v9 = sub_2096BEAC8(a2);
  else
    v9 = 0;
  v10 = 0;
  while (1)
  {
    v11 = (&off_24C1F6650)[v10];
    if (!der_heim_oid_cmp())
      break;
    if (++v10 == 15)
    {
      v12 = 569861;
      hx509_clear_error_string(a1);
      return v12;
    }
  }
  v13 = *((_DWORD *)v11 + 10);
  if (v9)
  {
    if ((v13 & 1) == 0)
    {
      hx509_clear_error_string(a1);
      return 569924;
    }
    if (v11[3] && der_heim_oid_cmp())
    {
      hx509_clear_error_string(a1);
      return 569862;
    }
  }
  else if ((v13 & 2) != 0)
  {
    hx509_clear_error_string(a1);
    return 569928;
  }
  return ((uint64_t (*)(uint64_t, char **, uint64_t, uint64_t, uint64_t, uint64_t))v11[8])(a1, v11, v9, a3, a4, a5);
}

uint64_t sub_2096C4F38(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v12;
  char **v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  char v20;

  v12 = 0;
  while (1)
  {
    v13 = (&off_24C1F6650)[v12];
    if (!der_heim_oid_cmp())
      break;
    if (++v12 == 15)
    {
      v18 = 569861;
      hx509_set_error_string(a1, 0, 569861, "algorithm no supported", v14, v15, v16, v17, v20);
      return v18;
    }
  }
  if (a2 && ((_BYTE)v13[5] & 1) == 0)
  {
    hx509_set_error_string(a1, 0, 569861, "algorithm provides no conf", v14, v15, v16, v17, v20);
    return 569924;
  }
  return ((uint64_t (*)(uint64_t, char **, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))v13[9])(a1, v13, a2, a3, a4, a5, a6);
}

uint64_t sub_2096C5050(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, _QWORD *a6)
{
  uint64_t result;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  v9 = 0;
  v10 = 0;
  result = sub_2096C4F38(a1, a2, a3, a4, a5, (uint64_t)&v9);
  if (!(_DWORD)result)
  {
    v8 = v10;
    *a6 = 8 * v9;
    a6[1] = v8;
  }
  return result;
}

uint64_t sub_2096C5090(uint64_t a1, unsigned int *a2, uint64_t a3, uint64_t a4, _QWORD *a5)
{
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _DWORD *v13;
  int v14;
  void *v15;
  void *v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  char v31;
  uint64_t v32;

  *a5 = 0;
  a5[1] = 0;
  v32 = *(_QWORD *)(a3 + 216);
  v8 = sub_2096D5CE4(0, &v32);
  if (v8)
  {
    v13 = v8;
    v14 = sub_2096D5658((uint64_t)v8);
    v15 = malloc_type_malloc(v14, 0xC77C482EuLL);
    if (v15)
    {
      v16 = v15;
      v17 = sub_2096D5678(*a2, *((_QWORD *)a2 + 1), (uint64_t)v15, (uint64_t)v13);
      sub_2096D540C(v13);
      if (v17 <= 0)
      {
        v25 = 569929;
        free(v16);
        hx509_set_error_string(a1, 0, 569929, "RSA public encrypt failed with %d", v27, v28, v29, v30, v17);
        return v25;
      }
      if (v17 > v14)
        sub_2096C1D6C("internal rsa decryption failure: ret > tosize", v18, v19, v20, v21, v22, v23, v24, v31);
      *a5 = v17;
      a5[1] = v16;
      if (!der_copy_oid())
        return 0;
      der_free_octet_string();
    }
    else
    {
      sub_2096D540C(v13);
    }
  }
  v25 = 12;
  hx509_set_error_string(a1, 0, 12, "out of memory", v9, v10, v11, v12, v31);
  return v25;
}

uint64_t sub_2096C51E4(uint64_t a1, unsigned int *a2, uint64_t a3, uint64_t a4, _QWORD *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  int v13;
  void *v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  char v23;
  uint64_t v24;
  const char *v25;
  uint64_t v26;
  int v27;
  char v29;

  *a5 = 0;
  a5[1] = 0;
  v9 = *(_QWORD *)(a4 + 56);
  if (!v9)
  {
    v24 = 569865;
    v25 = "Private RSA key missing";
    v26 = a1;
    v27 = 569865;
LABEL_9:
    hx509_set_error_string(v26, 0, v27, v25, (uint64_t)a5, a6, a7, a8, v29);
    return v24;
  }
  v13 = sub_2096D5658(v9);
  *a5 = v13;
  v14 = malloc_type_malloc(v13, 0xD912861BuLL);
  a5[1] = v14;
  if (!v14)
  {
    v25 = "out of memory";
    v24 = 12;
    v26 = a1;
    v27 = 12;
    goto LABEL_9;
  }
  v15 = sub_2096D5684(*a2, *((_QWORD *)a2 + 1), (uint64_t)v14, *(_QWORD *)(a4 + 56));
  v23 = v15;
  if (v15 <= 0)
  {
    der_free_octet_string();
    v24 = 569932;
    v29 = v23;
    v25 = "Failed to decrypt using private key: %d";
    v26 = a1;
    v27 = 569932;
    goto LABEL_9;
  }
  if (*a5 < (unint64_t)v15)
    sub_2096C1D6C("internal rsa decryption failure: ret > tosize", v16, v17, v18, v19, v20, v21, v22, v29);
  v24 = 0;
  *a5 = v15;
  return v24;
}

uint64_t sub_2096C5308(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, CFTypeRef *a6)
{
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  char v26;

  *a6 = 0;
  v12 = sub_2096C4C20();
  if (v12)
  {
    v18 = v12;
    v19 = heim_uniq_alloc(0x48uLL, (uint64_t)"hx509-private-key", (uint64_t)sub_2096C5780, v13, v14, v15, v16, v17);
    *a6 = (CFTypeRef)v19;
    if (v19)
    {
      *(_QWORD *)(v19 + 64) = v18;
      *((_QWORD *)*a6 + 7) = 0;
      *((_DWORD *)*a6 + 12) = *(_DWORD *)v18;
      v24 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(v18 + 48))(a1, a2, a3, a4, a5);
      if ((_DWORD)v24 && *a6)
      {
        heim_release(*a6);
        *a6 = 0;
      }
    }
    else
    {
      v24 = 12;
      hx509_set_error_string(a1, 0, 12, "out of memory", v20, v21, v22, v23, v26);
    }
  }
  else
  {
    hx509_clear_error_string(a1);
    return 569861;
  }
  return v24;
}

uint64_t sub_2096C5408(uint64_t a1, int *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v11;
  int v12;
  uint64_t result;

  v11 = heim_uniq_alloc(0x48uLL, (uint64_t)"hx509-private-key", (uint64_t)sub_2096C5780, a4, a5, a6, a7, a8);
  *(_QWORD *)a1 = v11;
  if (!v11)
    return 12;
  *(_QWORD *)(v11 + 64) = a2;
  *(_QWORD *)(*(_QWORD *)a1 + 56) = a3;
  if (a2)
    v12 = *a2;
  else
    v12 = 2;
  result = 0;
  *(_DWORD *)(*(_QWORD *)a1 + 48) = v12;
  return result;
}

uint64_t hx509_private_key_free(const void **a1)
{
  const void *v2;

  if (a1)
  {
    v2 = *a1;
    if (v2)
    {
      heim_release(v2);
      *a1 = 0;
    }
  }
  return 0;
}

uint64_t hx509_private_key2SPKI(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t (*v9)(void);
  char vars0;

  v8 = *(_QWORD *)(a2 + 64);
  if (v8)
  {
    v9 = *(uint64_t (**)(void))(v8 + 32);
    if (v9)
      return v9();
  }
  hx509_set_error_string(a1, 0, 569967, "Private key have no key2SPKI function", a5, a6, a7, a8, vars0);
  return 569967;
}

uint64_t _hx509_generate_private_key_init(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  const char *v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  _QWORD *v14;
  char v16;

  *a3 = 0;
  if (der_heim_oid_cmp())
  {
    v10 = "private key not an RSA key";
    v11 = 22;
    v12 = a1;
    v13 = 22;
  }
  else
  {
    v14 = malloc_type_calloc(1uLL, 0x18uLL, 0x1060040C052FB36uLL);
    *a3 = v14;
    if (v14)
    {
      v11 = 0;
      *v14 = a2;
      return v11;
    }
    v10 = "out of memory";
    v11 = 12;
    v12 = a1;
    v13 = 12;
  }
  hx509_set_error_string(v12, 0, v13, v10, v6, v7, v8, v9, v16);
  return v11;
}

uint64_t _hx509_generate_private_key_is_ca(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a2 + 8) = 1;
  return 0;
}

uint64_t _hx509_generate_private_key_bits(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(a2 + 16) = a3;
  return 0;
}

void _hx509_generate_private_key_free(void **a1)
{
  free(*a1);
  *a1 = 0;
}

uint64_t _hx509_generate_private_key(uint64_t a1, uint64_t a2, CFTypeRef *a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  char v20;

  *a3 = 0;
  v6 = sub_2096C4C20();
  if (v6)
  {
    v12 = v6;
    v13 = heim_uniq_alloc(0x48uLL, (uint64_t)"hx509-private-key", (uint64_t)sub_2096C5780, v7, v8, v9, v10, v11);
    *a3 = (CFTypeRef)v13;
    if (v13)
    {
      *(_QWORD *)(v13 + 64) = v12;
      *((_QWORD *)*a3 + 7) = 0;
      *((_DWORD *)*a3 + 12) = *(_DWORD *)v12;
      v18 = (*(uint64_t (**)(uint64_t, uint64_t))(v12 + 56))(a1, a2);
      if ((_DWORD)v18 && *a3)
      {
        heim_release(*a3);
        *a3 = 0;
      }
    }
    else
    {
      v18 = 12;
      hx509_set_error_string(a1, 0, 12, "out of memory", v14, v15, v16, v17, v20);
    }
  }
  else
  {
    hx509_clear_error_string(a1);
    return 569861;
  }
  return v18;
}

void *hx509_signature_sha512()
{
  return &unk_24C1F6488;
}

void *hx509_signature_sha384()
{
  return &unk_24C1F64A0;
}

void *hx509_signature_sha256()
{
  return &unk_24C1F64B8;
}

void *hx509_signature_sha1()
{
  return &unk_24C1F64D0;
}

void *hx509_signature_md5()
{
  return &unk_24C1F64E8;
}

void *sub_2096C5708()
{
  return &unk_24C1F6500;
}

void *hx509_signature_rsa_with_sha512()
{
  return &unk_24C1F6548;
}

void *hx509_signature_rsa_with_sha384()
{
  return &unk_24C1F6560;
}

void *hx509_signature_rsa_with_sha256()
{
  return &unk_24C1F6578;
}

void *hx509_signature_rsa_with_sha1()
{
  return &unk_24C1F6590;
}

void *hx509_signature_rsa_with_md5()
{
  return &unk_24C1F65A8;
}

void *hx509_signature_rsa()
{
  return &unk_24C1F65C0;
}

void *hx509_crypto_des_rsdi_ede3_cbc()
{
  return &unk_24C1F65F0;
}

void *hx509_crypto_aes128_cbc()
{
  return &unk_24C1F6608;
}

void *hx509_crypto_aes256_cbc()
{
  return &unk_24C1F6620;
}

void sub_2096C5780(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8;
  _DWORD *v9;
  _DWORD *v10;

  v8 = *(_DWORD *)(a1 + 48);
  if (v8 == 3)
  {
    v10 = *(_DWORD **)(a1 + 56);
    if (v10)
      sub_2096D6D00(v10);
  }
  else if (v8 != 2)
  {
    if (v8 != 1)
      sub_2096C1D6C("unsupported keytype %d", a2, a3, a4, a5, a6, a7, a8, *(_DWORD *)(a1 + 48));
    v9 = *(_DWORD **)(a1 + 56);
    if (v9)
      sub_2096D540C(v9);
  }
}

uint64_t sub_2096C57F0(uint64_t a1)
{
  return *(_QWORD *)(*(_QWORD *)(a1 + 64) + 8);
}

void sub_2096C57FC(uint64_t a1, uint64_t a2)
{
  _DWORD *v4;

  v4 = *(_DWORD **)(a1 + 56);
  if (v4)
    sub_2096D540C(v4);
  *(_DWORD *)(a1 + 48) = 1;
  *(_QWORD *)(a1 + 56) = a2;
  *(_QWORD *)(a1 + 32) = &off_24C1F18B8;
  *(_QWORD *)(a1 + 40) = &unk_24C1F7A48;
}

void sub_2096C5848(uint64_t a1, uint64_t a2)
{
  _DWORD *v4;

  v4 = *(_DWORD **)(a1 + 56);
  if (v4)
    sub_2096D6D00(v4);
  *(_DWORD *)(a1 + 48) = 3;
  *(_QWORD *)(a1 + 56) = a2;
  *(_QWORD *)(a1 + 32) = &off_24C1F0CC8;
  *(_QWORD *)(a1 + 40) = &unk_24C1F7B58;
}

uint64_t sub_2096C5894(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  char v8;

  v6 = der_copy_oid();
  if ((_DWORD)v6)
    hx509_set_error_string(a1, 0, v6, "malloc out of memory", v2, v3, v4, v5, v8);
  return v6;
}

BOOL sub_2096C58E4(uint64_t a1)
{
  return *(_QWORD *)(*(_QWORD *)(a1 + 64) + 40) != 0;
}

uint64_t sub_2096C58F8(uint64_t a1, uint64_t a2)
{
  uint64_t (*v2)(void);

  v2 = *(uint64_t (**)(void))(*(_QWORD *)(a2 + 64) + 40);
  if (v2)
    return v2();
  hx509_clear_error_string(a1);
  return 569967;
}

char *hx509_crypto_enctype_by_name(char *a1)
{
  uint64_t v2;

  v2 = 0;
  while (strcasecmp(a1, (&off_24C1F0B08)[v2]))
  {
    v2 += 7;
    if (v2 == 35)
      return 0;
  }
  return (&off_24C1F0B08)[v2 + 2];
}

uint64_t hx509_crypto_init(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD **a4)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  char v14;

  v6 = 0;
  *a4 = 0;
  while (der_heim_oid_cmp())
  {
    v6 += 7;
    if (v6 == 35)
    {
      v11 = 569866;
      hx509_set_error_string(a1, 0, 569866, "Algorithm not supported", v7, v8, v9, v10, v14);
      return v11;
    }
  }
  v12 = malloc_type_calloc(1uLL, 0x48uLL, 0x10F0040F8F4EDAFuLL);
  *a4 = v12;
  if (v12)
  {
    *((_DWORD *)v12 + 2) = 4;
    v12[2] = &(&off_24C1F0B08)[v6];
    (*a4)[3] = ((uint64_t (*)(void))(&off_24C1F0B08)[v6 + 4])();
    if (!der_copy_oid())
      return 0;
    hx509_crypto_destroy(*a4);
    *a4 = 0;
  }
  hx509_clear_error_string(a1);
  return 12;
}

void hx509_crypto_destroy(_QWORD *a1)
{
  void *v2;
  void *v3;
  void *v4;

  v2 = (void *)*a1;
  if (v2)
    free(v2);
  v3 = (void *)a1[5];
  if (v3)
    free(v3);
  v4 = (void *)a1[8];
  if (v4)
    free(v4);
  der_free_oid();
  a1[8] = 0;
  *((_OWORD *)a1 + 2) = 0u;
  *((_OWORD *)a1 + 3) = 0u;
  *(_OWORD *)a1 = 0u;
  *((_OWORD *)a1 + 1) = 0u;
  free(a1);
}

const char *hx509_crypto_provider()
{
  return "unknown";
}

uint64_t hx509_crypto_set_key_name()
{
  return 0;
}

uint64_t sub_2096C5AFC(uint64_t result)
{
  *(_DWORD *)(result + 8) |= 1u;
  return result;
}

uint64_t hx509_crypto_set_key_data(uint64_t *a1, const void *a2, size_t a3)
{
  uint64_t result;
  size_t *v7;
  void *v8;
  void *v9;

  if (hc_EVP_CIPHER_key_length(a1[3]) > a3)
    return 569920;
  v7 = (size_t *)(a1 + 4);
  v8 = (void *)a1[5];
  if (v8)
  {
    free(v8);
    *v7 = 0;
    a1[5] = 0;
  }
  v9 = malloc_type_malloc(a3, 0x162E7664uLL);
  a1[5] = (uint64_t)v9;
  if (!v9)
    return 12;
  memcpy(v9, a2, a3);
  result = 0;
  *v7 = a3;
  return result;
}

uint64_t hx509_crypto_set_random_key(uint64_t a1, uint64_t a2)
{
  _QWORD *v4;
  void *v5;
  size_t v6;
  void *v7;

  v4 = (_QWORD *)(a1 + 32);
  v5 = *(void **)(a1 + 40);
  if (v5)
  {
    free(v5);
    *v4 = 0;
  }
  v6 = hc_EVP_CIPHER_key_length(*(_QWORD *)(a1 + 24));
  *(_QWORD *)(a1 + 32) = v6;
  v7 = malloc_type_malloc(v6, 0x7E1481AFuLL);
  *(_QWORD *)(a1 + 40) = v7;
  if (v7)
  {
    if (CCRandomCopyBytes())
    {
      free(*(void **)(a1 + 40));
      *v4 = 0;
      v4[1] = 0;
      return 569920;
    }
    else if (a2)
    {
      return der_copy_octet_string();
    }
    else
    {
      return 0;
    }
  }
  else
  {
    *v4 = 0;
    return 12;
  }
}

uint64_t hx509_crypto_set_params(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(a2 + 16) + 48))(a1, a3, a2);
}

uint64_t hx509_crypto_get_params(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a2 + 16) + 40))();
}

uint64_t sub_2096C5C7C(uint64_t a1, uint64_t a2)
{
  size_t v3;
  void *v4;
  uint64_t result;

  v3 = hc_EVP_CIPHER_iv_length(*(_QWORD *)(a1 + 24));
  *(_QWORD *)a2 = v3;
  v4 = malloc_type_malloc(v3, 0x96D9D869uLL);
  *(_QWORD *)(a2 + 8) = v4;
  if (v4)
  {
    result = CCRandomCopyBytes();
    if ((_DWORD)result)
    {
      free(*(void **)(a2 + 8));
      *(_QWORD *)a2 = 0;
      *(_QWORD *)(a2 + 8) = 0;
      return 569920;
    }
  }
  else
  {
    *(_QWORD *)a2 = 0;
    return 12;
  }
  return result;
}

uint64_t hx509_crypto_encrypt(uint64_t a1, const void *a2, size_t a3, uint64_t a4, void ***a5)
{
  uint64_t v10;
  void **v11;
  unint64_t v12;
  int v13;
  size_t v14;
  void **v15;
  _OWORD v17[10];
  uint64_t v18;
  uint64_t v19;

  v19 = *MEMORY[0x24BDAC8D0];
  v18 = 0;
  memset(v17, 0, sizeof(v17));
  *a5 = 0;
  if ((*(_BYTE *)(*(_QWORD *)(a1 + 16) + 8) & 1) == 0 || (*(_BYTE *)(a1 + 8) & 1) != 0)
  {
    if (hc_EVP_CIPHER_iv_length(*(_QWORD *)(a1 + 24)) != *(_QWORD *)a4)
      sub_2096D7E54();
    hc_EVP_CIPHER_CTX_init((uint64_t)v17);
    if (hc_EVP_CipherInit_ex((uint64_t)v17, *(_QWORD *)(a1 + 24), 0, *(_QWORD *)(a1 + 40), *(void **)(a4 + 8), 1) == 1)
    {
      v11 = (void **)malloc_type_calloc(1uLL, 0x10uLL, 0x108004057E67DB5uLL);
      *a5 = v11;
      if (!v11)
      {
        v10 = 12;
LABEL_29:
        hc_EVP_CIPHER_CTX_cleanup((uint64_t *)v17);
        return v10;
      }
      if ((*(_BYTE *)(a1 + 8) & 6) == 0)
        sub_2096D7E2C();
      v12 = hc_EVP_CIPHER_block_size(*(_QWORD *)(a1 + 24));
      v13 = *(_DWORD *)(a1 + 8);
      if ((v13 & 2) != 0)
      {
        if (v12 != 1 && a3 % v12)
          return 569893;
        v14 = 0;
      }
      else
      {
        v14 = 0;
        if ((v13 & 4) != 0 && v12 != 1)
          v14 = v12 + a3 / v12 * v12 - a3;
      }
      **a5 = (void *)(v14 + a3);
      (*a5)[1] = malloc_type_malloc(v14 + a3, 0xAA266111uLL);
      v15 = *a5;
      if (!(*a5)[1])
      {
        v10 = 12;
        goto LABEL_26;
      }
      memcpy((*a5)[1], a2, a3);
      if (v14)
        memset((char *)(*a5)[1] + a3, v14, v14);
      if (hc_EVP_Cipher((uint64_t)v17) == 1)
      {
        v10 = 0;
        goto LABEL_29;
      }
    }
    else
    {
      hc_EVP_CIPHER_CTX_cleanup((uint64_t *)v17);
    }
    v10 = 569920;
    v15 = *a5;
    if (!*a5)
      goto LABEL_29;
LABEL_26:
    if (v15[1])
    {
      free(v15[1]);
      v15 = *a5;
    }
    free(v15);
    *a5 = 0;
    goto LABEL_29;
  }
  return 569933;
}

uint64_t hx509_crypto_decrypt(uint64_t a1, uint64_t a2, size_t a3, _QWORD *a4, size_t *a5)
{
  uint64_t v9;
  void *v10;
  void *v11;
  int v12;
  int v13;
  char *v14;
  size_t v15;
  char *v17;
  uint64_t v18;
  int v19;
  _OWORD v20[10];
  uint64_t v21;
  uint64_t v22;

  v22 = *MEMORY[0x24BDAC8D0];
  v21 = 0;
  memset(v20, 0, sizeof(v20));
  *a5 = 0;
  a5[1] = 0;
  if ((*(_BYTE *)(*(_QWORD *)(a1 + 16) + 8) & 1) != 0 && (*(_BYTE *)(a1 + 8) & 1) == 0)
    return 569933;
  if (a4)
  {
    if ((unint64_t)hc_EVP_CIPHER_iv_length(*(_QWORD *)(a1 + 24)) < *a4 || !*(_QWORD *)(a1 + 40))
      return 569920;
    v10 = (void *)a4[1];
  }
  else
  {
    if (!*(_QWORD *)(a1 + 40))
      return 569920;
    v10 = 0;
  }
  hc_EVP_CIPHER_CTX_init((uint64_t)v20);
  if (hc_EVP_CipherInit_ex((uint64_t)v20, *(_QWORD *)(a1 + 24), 0, *(_QWORD *)(a1 + 40), v10, 0) != 1)
  {
    hc_EVP_CIPHER_CTX_cleanup((uint64_t *)v20);
    return 569920;
  }
  *a5 = a3;
  v11 = malloc_type_malloc(a3, 0x51F77A67uLL);
  a5[1] = (size_t)v11;
  if (!v11)
  {
    hc_EVP_CIPHER_CTX_cleanup((uint64_t *)v20);
    *a5 = 0;
    return 12;
  }
  v12 = hc_EVP_Cipher((uint64_t)v20);
  v9 = 569920;
  if (v12 == 1)
  {
    hc_EVP_CIPHER_CTX_cleanup((uint64_t *)v20);
    if ((*(_BYTE *)(a1 + 8) & 4) != 0 && (unint64_t)hc_EVP_CIPHER_block_size(*(_QWORD *)(a1 + 24)) >= 2)
    {
      v13 = hc_EVP_CIPHER_block_size(*(_QWORD *)(a1 + 24));
      v15 = *a5;
      v14 = (char *)a5[1];
      if ((int)*a5 < v13)
        goto LABEL_16;
      v17 = &v14[v15 - 1];
      v18 = *v17;
      if ((int)v18 > v13)
      {
LABEL_23:
        free(v14);
LABEL_24:
        *a5 = 0;
        a5[1] = 0;
        return 569893;
      }
      *a5 = v15 - v18;
      if ((_DWORD)v18)
      {
        v19 = v18;
        while (*v17 == (_DWORD)v18)
        {
          v9 = 0;
          --v17;
          if (!--v19)
            return v9;
        }
LABEL_16:
        if (!v14)
          goto LABEL_24;
        goto LABEL_23;
      }
    }
    return 0;
  }
  return v9;
}

uint64_t sub_2096C6168(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, _QWORD *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char vars0;

  *a5 = 0;
  a5[1] = 0;
  hx509_set_error_string(a1, 0, 569866, "String to key algorithm not supported", (uint64_t)a5, a6, a7, a8, vars0);
  return 569866;
}

_QWORD *sub_2096C619C(uint64_t a1, uint64_t a2)
{
  _QWORD *result;
  _QWORD *v6;
  _QWORD *v7;
  _QWORD *v8;
  _QWORD *v9;
  _BOOL4 v10;

  if (der_heim_oid_cmp())
    return (_QWORD *)(der_heim_oid_cmp() == 0);
  if (*(_DWORD *)(a2 + 48) != 1)
    return 0;
  v6 = *(_QWORD **)(a2 + 56);
  if (!v6 || !v6[6] || !v6[7] || !v6[8])
    return 0;
  sub_2096BEAC8(a1);
  result = sub_2096D5344();
  if (!result)
    return result;
  v7 = result;
  if (sub_2096D2888())
    goto LABEL_13;
  v8 = sub_2096D4200(0, 0, 0);
  sub_2096D42F8((uint64_t)v8, 0);
  v7[4] = v8;
  v9 = sub_2096D4200(0, 0, 0);
  sub_2096D42F8((uint64_t)v9, 0);
  v7[5] = v9;
  sub_2096D28D8();
  v7[6] = sub_2096D4164();
  v7[7] = sub_2096D4164();
  v7[8] = sub_2096D4164();
  v7[9] = sub_2096D4164();
  v7[10] = sub_2096D4164();
  v7[11] = sub_2096D4164();
  if (!v7[4] || !v7[5] || !v7[6] || !v7[7] || !v7[8] || !v7[9] || !v7[10])
  {
LABEL_13:
    sub_2096D540C(v7);
    return 0;
  }
  v10 = sub_2096D5550(v7);
  sub_2096D540C(v7);
  return (_QWORD *)v10;
}

uint64_t hx509_crypto_select(uint64_t a1, int a2, char *a3, uint64_t a4, _QWORD *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  int v11;
  uint64_t v12;
  char *v13;
  char *v14;
  unint64_t v15;
  char **v16;
  uint64_t v17;
  uint64_t v18;
  void (**v19)(void);
  uint64_t v20;
  uint64_t v22;
  char v23;

  v10 = a1;
  *a5 = 0;
  a5[1] = 0;
  a5[2] = 0;
  if (a2 == 4)
  {
    v23 = 0;
    v11 = 1024;
    if (a4)
    {
LABEL_14:
      v13 = sub_2096C6664(a3);
      if (*(_QWORD *)(a4 + 16))
      {
        v14 = v13;
        v15 = 0;
        v16 = &off_24C1F0CC8;
        v22 = v10;
LABEL_16:
        v17 = 1u;
        while (((_DWORD)v16[5] & v11) == 0
             || der_heim_oid_cmp()
             || v14 && v16[3] && der_heim_oid_cmp())
        {
          v16 = (&off_24C1F6650)[v17++];
          if (v17 == 16)
          {
            if ((v23 & 1) != 0)
              goto LABEL_30;
            v18 = 0;
            v19 = (void (**)(void))&qword_24C1F0B20;
            while (der_heim_oid_cmp())
            {
              ++v18;
              v19 += 7;
              if (v18 == 5)
                goto LABEL_30;
            }
            if (!v18 || v18 == 3)
            {
LABEL_30:
              ++v15;
              v10 = v22;
              v16 = &off_24C1F0CC8;
              if (v15 < *(_QWORD *)(a4 + 16))
                goto LABEL_16;
              break;
            }
            (*v19)();
            v12 = copy_AlgorithmIdentifier();
            if (!(_DWORD)v12)
              return v12;
            v20 = v22;
            goto LABEL_33;
          }
        }
      }
    }
  }
  else
  {
    if (a2 == 2)
    {
      if (a3)
        sub_2096C65C0((uint64_t)a3, 2);
      v11 = 512;
    }
    else
    {
      if (a2 != 1)
      {
        v12 = 22;
        hx509_set_error_string(a1, 0, 22, "Unknown type %d of selection", (uint64_t)a5, a6, a7, a8, a2);
        return v12;
      }
      if (a3)
        sub_2096C65C0((uint64_t)a3, 1);
      v11 = 256;
    }
    v23 = 1;
    if (a4)
      goto LABEL_14;
  }
  v12 = copy_AlgorithmIdentifier();
  if ((_DWORD)v12)
  {
    v20 = v10;
LABEL_33:
    hx509_clear_error_string(v20);
  }
  return v12;
}

char *sub_2096C65C0(uint64_t a1, int a2)
{
  uint64_t v4;
  char **v5;
  unsigned int (*v6)(uint64_t, char *);
  uint64_t v8;

  if (!*(_QWORD *)(a1 + 64))
    return 0;
  v4 = 0;
  while (1)
  {
    v5 = (&off_24C1F6650)[v4];
    if (v5[3])
    {
      if (!der_heim_oid_cmp())
      {
        v6 = *(unsigned int (**)(uint64_t, char *))(*(_QWORD *)(a1 + 64) + 24);
        if (!v6 || v6(a1, v5[2]))
          break;
      }
    }
    if (++v4 == 15)
      return 0;
  }
  v8 = 4;
  if (a2 == 2)
    v8 = 2;
  return v5[v8];
}

char *sub_2096C6664(char *result)
{
  uint64_t v1;
  char **v2;

  if (result)
  {
    v1 = 0;
    while (1)
    {
      v2 = (&off_24C1F6650)[v1];
      if (!der_heim_oid_cmp())
        break;
      if (++v1 == 15)
        return 0;
    }
    return v2[3];
  }
  return result;
}

uint64_t hx509_crypto_available(uint64_t a1, int a2, uint64_t a3, void **a4, _DWORD *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v10;
  char *v11;
  char *v12;
  uint64_t v13;
  char **v14;
  uint64_t v15;
  uint64_t v16;
  void *v17;
  uint64_t v18;
  void (**v19)(void);
  void *v20;
  uint64_t v21;
  uint64_t v22;
  const char *v23;
  int v24;
  char v26;
  uint64_t v27;

  *a4 = 0;
  if (a2)
  {
    if (a2 == 1)
    {
      v27 = a1;
      v10 = 256;
    }
    else
    {
      if (a2 != 2)
      {
        v23 = "Unknown type %d of available";
        v26 = a2;
        v21 = 22;
        v24 = 22;
LABEL_34:
        hx509_set_error_string(a1, 0, v24, v23, (uint64_t)a5, a6, a7, a8, v26);
        return v21;
      }
      v27 = a1;
      v10 = 512;
    }
  }
  else
  {
    v27 = a1;
    v10 = 1792;
  }
  if (a3)
  {
    v11 = (char *)_hx509_cert_private_key(a3);
    v12 = sub_2096C6664(v11);
  }
  else
  {
    v12 = 0;
  }
  v13 = 0;
  v14 = &off_24C1F0CC8;
  v15 = 1u;
  do
  {
    LODWORD(v16) = v13;
    if (((_DWORD)v14[5] & v10) != 0 && v14[2] && (!v12 || !v14[3] || !der_heim_oid_cmp()))
    {
      v13 = (v13 + 1);
      v17 = malloc_type_realloc(*a4, 24 * v13, 0x10300406712BA52uLL);
      if (!v17 || (*a4 = v17, copy_AlgorithmIdentifier()))
      {
LABEL_29:
        if ((_DWORD)v16)
        {
          v22 = 0;
          do
          {
            free_AlgorithmIdentifier();
            v22 += 24;
          }
          while (24 * v16 != v22);
        }
        free(*a4);
        *a4 = 0;
        v23 = "out of memory";
        v21 = 12;
        a1 = v27;
        v24 = 12;
        goto LABEL_34;
      }
    }
    v14 = (&off_24C1F6650)[v15++];
  }
  while (v15 != 16);
  if (!a2)
  {
    v18 = 0;
    v16 = v13;
    v19 = (void (**)(void))&qword_24C1F0B20;
    do
    {
      if ((_DWORD)v18 && (_DWORD)v18 != 3)
      {
        v13 = (v16 + 1);
        v20 = malloc_type_realloc(*a4, 24 * v13, 0x10300406712BA52uLL);
        if (!v20)
          goto LABEL_29;
        *a4 = v20;
        (*v19)();
        if (copy_AlgorithmIdentifier())
          goto LABEL_29;
      }
      else
      {
        v13 = v16;
      }
      ++v18;
      v19 += 7;
      v16 = v13;
    }
    while (v18 != 5);
  }
  v21 = 0;
  *a5 = v13;
  return v21;
}

void hx509_crypto_free_algs(char *a1, unsigned int a2)
{
  uint64_t v3;
  char *v4;

  if (a2)
  {
    v3 = a2;
    v4 = a1;
    do
    {
      free_AlgorithmIdentifier();
      v4 += 24;
      --v3;
    }
    while (v3);
  }
  free(a1);
}

BOOL sub_2096C694C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  char **v10;
  char v12;

  if (*(_DWORD *)(a1 + 48) != 1)
    heim_abort("internal error passing private key to wrong ops:signer->keytype == KEYTYPE_RSA", a2, a3, a4, a5, a6, a7, a8, v12);
  v9 = 0;
  while (1)
  {
    v10 = (&off_24C1F6650)[v9];
    if (!der_heim_oid_cmp())
      break;
    if (++v9 == 15)
      return 0;
  }
  if (*((_DWORD *)v10 + 20))
    return (int)sub_2096D5658(*(_QWORD *)(a1 + 56)) > *((_DWORD *)v10 + 20);
  return 0;
}

uint64_t sub_2096C69E8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v6;
  void *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char v18;
  uint64_t v19;

  *(_QWORD *)(a3 + 32) = 0;
  *(_OWORD *)a3 = 0u;
  *(_OWORD *)(a3 + 16) = 0u;
  v6 = sub_2096D5BD0(*(_QWORD *)(a2 + 56), 0);
  v7 = malloc_type_malloc(v6, 0x6AA5989CuLL);
  *(_QWORD *)(a3 + 32) = v7;
  if (v7)
  {
    *(_QWORD *)(a3 + 24) = 8 * v6;
    v16 = sub_2096C6D6C(a3);
    if ((_DWORD)v16)
    {
      hx509_set_error_string(a1, 0, v16, "malloc - out of memory", v12, v13, v14, v15, v18);
      free(*(void **)(a3 + 32));
      *(_QWORD *)(a3 + 24) = 0;
      *(_QWORD *)(a3 + 32) = 0;
    }
    else
    {
      v19 = *(_QWORD *)(a3 + 32);
      sub_2096D5BD0(*(_QWORD *)(a2 + 56), &v19);
    }
  }
  else
  {
    v16 = 12;
    hx509_set_error_string(a1, 0, 12, "malloc - out of memory", v8, v9, v10, v11, v18);
  }
  return v16;
}

uint64_t sub_2096C6AD8(uint64_t a1, uint64_t a2, int a3, _QWORD *a4)
{
  int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  void *v13;
  uint64_t v14;
  const char *v15;
  uint64_t v16;
  int v17;
  char v19;
  void *v20;

  *a4 = 0;
  a4[1] = 0;
  if (a3 != 1)
    return 569934;
  v7 = sub_2096D59D4(*(unsigned int ***)(a2 + 56), 0);
  if (v7 <= 0)
  {
    v15 = "Private key is not exportable";
    v14 = 22;
    v16 = a1;
    v17 = 22;
LABEL_8:
    hx509_set_error_string(v16, 0, v17, v15, v8, v9, v10, v11, v19);
    return v14;
  }
  v12 = v7;
  v13 = malloc_type_malloc(v7, 0x4659A2F0uLL);
  a4[1] = v13;
  if (!v13)
  {
    v15 = "malloc out of memory";
    v14 = 12;
    v16 = a1;
    v17 = 12;
    goto LABEL_8;
  }
  *a4 = v12;
  v20 = v13;
  sub_2096D59D4(*(unsigned int ***)(a2 + 56), &v20);
  return 0;
}

uint64_t sub_2096C6BAC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, uint64_t a6)
{
  uint64_t v6;
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char v15;
  uint64_t v16;

  v6 = 569965;
  if (a5 != 1)
    return 569934;
  v16 = a3;
  v9 = sub_2096D5848(0, &v16);
  *(_QWORD *)(a6 + 56) = v9;
  if (v9)
  {
    v6 = 0;
    *(_QWORD *)(a6 + 40) = &unk_24C1F7A48;
  }
  else
  {
    hx509_set_error_string(a1, 0, 569965, "Failed to parse RSA key", v10, v11, v12, v13, v15);
  }
  return v6;
}

uint64_t sub_2096C6C44(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  int v11;
  uint64_t v12;
  char v14;

  v5 = sub_2096D5344();
  *(_QWORD *)(a3 + 56) = v5;
  if (v5
    && (v10 = sub_2096D40E8(),
        sub_2096D4360(v10, 0x10001uLL),
        v11 = sub_2096D5830(*(_QWORD *)(a3 + 56)),
        sub_2096D4104(v10),
        v11 == 1))
  {
    v12 = 0;
    *(_QWORD *)(a3 + 40) = &unk_24C1F7A48;
  }
  else
  {
    v12 = 569965;
    hx509_set_error_string(a1, 0, 569965, "Failed to generate RSA key", v6, v7, v8, v9, v14);
  }
  return v12;
}

void *sub_2096C6CFC(int a1, int a2, char *a3)
{
  if (!strcasecmp(a3, "rsa-modulus") || !strcasecmp(a3, "rsa-exponent"))
    return sub_2096D4164();
  else
    return 0;
}

uint64_t sub_2096C6D6C(uint64_t a1)
{
  void *v2;
  _WORD *v3;
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;

  v2 = malloc_type_malloc(0x10uLL, 0x108004057E67DB5uLL);
  *(_QWORD *)(a1 + 16) = v2;
  if (!v2)
    return 12;
  v3 = malloc_type_malloc(2uLL, 0x3C53B193uLL);
  v4 = *(_QWORD **)(a1 + 16);
  v4[1] = v3;
  if (!v3)
  {
    free(v4);
    v5 = 12;
    goto LABEL_8;
  }
  *v3 = 5;
  **(_QWORD **)(a1 + 16) = 2;
  v5 = der_copy_oid();
  if ((_DWORD)v5)
  {
    v6 = *(_QWORD *)(a1 + 16);
    if (v6)
    {
      free(*(void **)(v6 + 8));
      free(*(void **)(a1 + 16));
LABEL_8:
      *(_QWORD *)(a1 + 16) = 0;
    }
  }
  return v5;
}

BOOL sub_2096C6E28(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  char **v9;
  char v11;

  if (*(_DWORD *)(a1 + 48) != 3)
    sub_2096C1D6C("internal error passing private key to wrong ops", a2, a3, a4, a5, a6, a7, a8, v11);
  v8 = 0;
  while (1)
  {
    v9 = (&off_24C1F6650)[v8];
    if (!der_heim_oid_cmp())
      break;
    if (++v8 == 15)
      return 0;
  }
  return *((_DWORD *)v9 + 20) != 0;
}

uint64_t sub_2096C6EA4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unsigned int *a6)
{
  uint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  _DWORD *v17;
  int v18;
  void *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  void *v24;
  int v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  const char *v31;
  uint64_t v32;
  int v33;
  char v35;
  uint64_t v36;
  uint64_t v37;
  __int128 v38;
  __int128 v39;
  uint64_t v40;

  v38 = 0u;
  v39 = 0u;
  v40 = 0;
  v10 = *(_QWORD *)(a3 + 216);
  v11 = *(_QWORD *)(a3 + 208) >> 3;
  v36 = v10;
  v37 = v11;
  v12 = sub_2096D5CE4(0, &v36);
  if (v12)
  {
    v17 = v12;
    v18 = sub_2096D5658((uint64_t)v12);
    v19 = malloc_type_malloc(v18, 0x178515CCuLL);
    if (!v19)
    {
      v31 = "out of memory";
      v30 = 12;
      v32 = a1;
      v33 = 12;
      goto LABEL_16;
    }
    v24 = v19;
    v25 = sub_2096D566C(*a6, *((_QWORD *)a6 + 1), (uint64_t)v19, (uint64_t)v17);
    if (v25 <= 0)
    {
      v30 = 569925;
      hx509_set_error_string(a1, 0, 569925, "RSA public decrypt failed: %d", v20, v21, v22, v23, v25);
      free(v24);
LABEL_17:
      sub_2096D2998();
      sub_2096D540C(v17);
      return v30;
    }
    if (v25 > v18)
      sub_2096C1D6C("internal rsa decryption failure: ret > tosize", v26, v27, v28, v20, v21, v22, v23, v35);
    v29 = v25;
    if ((*(_BYTE *)(a2 + 43) & 1) == 0)
    {
      if (*(_QWORD *)a5 == v25 && !ct_memcmp((unsigned __int8 *)v24, *(unsigned __int8 **)(a5 + 8), v25))
      {
        free(v24);
        v30 = 0;
        goto LABEL_17;
      }
      v30 = 569925;
      v31 = "RSA Signature incorrect";
      goto LABEL_9;
    }
    v30 = sub_2096D2948();
    free(v24);
    if ((_DWORD)v30)
    {
      v31 = "Failed to decode RSA DigestInfo";
LABEL_15:
      v32 = a1;
      v33 = v30;
      goto LABEL_16;
    }
    if (v37 == v29)
    {
      if (*(_QWORD *)(a2 + 32) && der_heim_oid_cmp())
      {
        v30 = 569926;
        v31 = "object identifier in RSA sig mismatch";
        goto LABEL_15;
      }
      if (!(_QWORD)v39 || *(_QWORD *)v39 == 2 && **(_WORD **)(v39 + 8) == 5)
      {
        v30 = hx509_verify_signature_0(a1, 0, (uint64_t)&v38, a5, (uint64_t)&v39 + 8);
        goto LABEL_17;
      }
      v30 = 569925;
      v31 = "Extra parameters inside RSA signature";
    }
    else
    {
      v30 = 569925;
      v31 = "size from decryption mismatch";
    }
LABEL_9:
    v32 = a1;
    v33 = 569925;
LABEL_16:
    hx509_set_error_string(v32, 0, v33, v31, v20, v21, v22, v23, v35);
    goto LABEL_17;
  }
  v30 = 12;
  hx509_set_error_string(a1, 0, 12, "out of memory", v13, v14, v15, v16, v35);
  sub_2096D2998();
  return v30;
}

uint64_t sub_2096C713C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t *a5, uint64_t a6, _QWORD *a7)
{
  uint64_t v12;
  void *v13;
  uint64_t v14;
  char v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  void *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  int v35;
  char v37;
  int v38;
  __int128 v39;

  if (*(_QWORD *)(a3 + 64) && der_heim_oid_cmp())
    return 569866;
  if (!der_heim_oid_cmp())
  {
    v15 = 0;
    v14 = 7;
    v13 = &unk_24C1F6488;
    if (!a6)
      goto LABEL_25;
    goto LABEL_23;
  }
  if (!der_heim_oid_cmp())
  {
    v15 = 0;
    v14 = 6;
    v13 = &unk_24C1F64A0;
    if (!a6)
      goto LABEL_25;
    goto LABEL_23;
  }
  if (!der_heim_oid_cmp())
  {
    v15 = 0;
    v14 = 5;
    v13 = &unk_24C1F64B8;
    if (!a6)
      goto LABEL_25;
    goto LABEL_23;
  }
  if (!der_heim_oid_cmp())
    goto LABEL_18;
  if (!der_heim_oid_cmp())
  {
    v15 = 0;
    v14 = 2;
    v13 = &unk_24C1F64E8;
    if (!a6)
      goto LABEL_25;
LABEL_23:
    v16 = sub_2096C6D6C(a6);
    if ((_DWORD)v16)
    {
      v12 = v16;
      hx509_clear_error_string(a1);
      return v12;
    }
    goto LABEL_25;
  }
  if (!der_heim_oid_cmp() || !der_heim_oid_cmp())
  {
LABEL_18:
    v15 = 0;
    v14 = 4;
    v13 = &unk_24C1F64D0;
    if (!a6)
      goto LABEL_25;
    goto LABEL_23;
  }
  if (der_heim_oid_cmp())
    return 569866;
  v13 = 0;
  v14 = 0;
  v15 = 1;
  if (a6)
    goto LABEL_23;
LABEL_25:
  v39 = 0uLL;
  if ((v15 & 1) != 0)
  {
    v17 = *a5;
    if (v17 > (int)sub_2096D5658(*(_QWORD *)(a3 + 56)))
    {
      v12 = 569888;
      hx509_set_error_string(a1, 0, 569888, "RSA private decrypt failed: %d", v18, v19, v20, v21, 32);
      return v12;
    }
    v39 = *(_OWORD *)a5;
  }
  else
  {
    v12 = sub_2096C4F38(a1, 0, (uint64_t)v13, (uint64_t)a5, 0, (uint64_t)&v39);
    if ((_DWORD)v12)
      return v12;
  }
  v22 = sub_2096D5658(*(_QWORD *)(a3 + 56));
  *a7 = v22;
  v23 = malloc_type_malloc(v22, 0x7E0EBE16uLL);
  a7[1] = v23;
  if (v23)
  {
    if ((v15 & 1) != 0)
    {
      v35 = sub_2096D5660(v39, *((uint64_t *)&v39 + 1), (uint64_t)v23, *(_QWORD *)(a3 + 56));
    }
    else
    {
      v38 = 0;
      if (sub_2096D5690(v14, *((uint64_t *)&v39 + 1), v39, (uint64_t)v23, &v38, *(_QWORD *)(a3 + 56)) == 1)v35 = v38;
      else
        v35 = -1;
    }
    if (a5[1] != *((_QWORD *)&v39 + 1))
      der_free_octet_string();
    if (v35 <= 0)
    {
      v12 = 569888;
      hx509_set_error_string(a1, 0, 569888, "RSA private encrypt failed: %d", v31, v32, v33, v34, 32);
    }
    else
    {
      if (*a7 < (unint64_t)v35)
        sub_2096C1D6C("RSA signature prelen longer the output len", v28, v29, v30, v31, v32, v33, v34, v37);
      v12 = 0;
      *a7 = v35;
    }
  }
  else
  {
    if (a5[1] != *((_QWORD *)&v39 + 1))
      der_free_octet_string();
    v12 = 12;
    hx509_set_error_string(a1, 0, 12, "out of memory", v24, v25, v26, v27, v37);
  }
  return v12;
}

uint64_t sub_2096C74A8()
{
  return 0;
}

uint64_t sub_2096C74B0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, _QWORD *a7)
{
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  int v24;
  void *v25;
  int v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  const char *v34;
  uint64_t v35;
  int v36;
  char v38;
  unsigned int v39;
  uint64_t v40;
  uint64_t v41;

  if (*(_QWORD *)(a3 + 64) && der_heim_oid_cmp())
    sub_2096C1D6C("internal error passing private key to wrong ops", v13, v14, v15, v16, v17, v18, v19, v38);
  v40 = 0;
  v41 = 0;
  v39 = 0;
  v20 = *(_QWORD *)(a2 + 32);
  if (a6)
  {
    v21 = sub_2096C6D6C(a6);
    if ((_DWORD)v21)
    {
      v22 = v21;
      hx509_clear_error_string(a1);
LABEL_17:
      free_AlgorithmIdentifier();
      return v22;
    }
    v23 = sub_2096C4F38(a1, 0, v20, a5, 0, (uint64_t)&v40);
    if ((_DWORD)v23)
    {
      v22 = v23;
      free_AlgorithmIdentifier();
      goto LABEL_17;
    }
  }
  else
  {
    v22 = sub_2096C4F38(a1, 0, *(_QWORD *)(a2 + 32), a5, 0, (uint64_t)&v40);
    if ((_DWORD)v22)
      return v22;
  }
  v24 = sub_2096D6DF0();
  *a7 = v24;
  v25 = malloc_type_malloc(v24, 0x6C4BCFAFuLL);
  a7[1] = v25;
  if (v25)
  {
    v26 = sub_2096D6DD8(0xFFFFFFFFLL, v41, v40, (uint64_t)v25, (uint64_t)&v39, *(_QWORD *)(a3 + 56));
    der_free_octet_string();
    if (v26 == 1)
    {
      if (*a7 < (unint64_t)v39)
        sub_2096C1D6C("ECDSA signature prelen longer the output len", v27, v28, v29, v30, v31, v32, v33, v38);
      v22 = 0;
      *a7 = v39;
      return v22;
    }
    v22 = 569888;
    v38 = 32;
    v34 = "ECDSA sign failed: %d";
    v35 = a1;
    v36 = 569888;
  }
  else
  {
    der_free_octet_string();
    v34 = "out of memory";
    v22 = 12;
    v35 = a1;
    v36 = 12;
  }
  hx509_set_error_string(v35, 0, v36, v34, v30, v31, v32, v33, v38);
  if (a6)
    goto LABEL_17;
  return v22;
}

uint64_t sub_2096C7688(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  uint64_t v12;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unsigned __int8 v19[128];
  uint64_t v20;

  v20 = *MEMORY[0x24BDAC8D0];
  v10 = *(int *)(a2 + 80);
  if (v10 <= 0x80 && *(_QWORD *)a6 == v10)
  {
    if (CCDigestCreate())
    {
      CCDigestUpdate();
      CCDigestFinal();
      CCDigestDestroy();
      if (ct_memcmp(v19, *(unsigned __int8 **)(a6 + 8), v10))
      {
        v12 = 569923;
        hx509_set_error_string(a1, 0, 569923, "Bad %s sigature", v14, v15, v16, v17, *(_QWORD *)a2);
      }
      else
      {
        return 0;
      }
    }
    else
    {
      return 12;
    }
  }
  else
  {
    v12 = 569925;
    hx509_set_error_string(a1, 0, 569925, "%s sigature have wrong length (%lu)", a5, a6, a7, a8, *(_QWORD *)a2);
  }
  return v12;
}

uint64_t sub_2096C77B4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, size_t *a7)
{
  uint64_t v9;
  uint64_t v10;
  size_t v11;
  void *v12;

  *a7 = 0;
  a7[1] = 0;
  if (!CCDigestCreate())
    return 12;
  if (!a6 || (v9 = sub_2096C6D6C(a6), !(_DWORD)v9))
  {
    v11 = CCDigestOutputSize();
    *a7 = v11;
    v12 = malloc_type_malloc(v11, 0xF32FC355uLL);
    a7[1] = (size_t)v12;
    if (v12)
    {
      CCDigestUpdate();
      CCDigestFinal();
      CCDigestDestroy();
      return 0;
    }
    CCDigestDestroy();
    *a7 = 0;
    return 12;
  }
  v10 = v9;
  CCDigestDestroy();
  return v10;
}

uint64_t sub_2096C7880(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  size_t v7;
  void *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char v18;

  if (*(_QWORD *)(a2 + 64))
    sub_2096D7E7C();
  v4 = a3;
  if (a3)
  {
    v7 = sub_2096D1D74();
    *(_QWORD *)a4 = v7;
    v8 = malloc_type_malloc(v7, 0x17E651FEuLL);
    *(_QWORD *)(a4 + 8) = v8;
    if (!v8)
    {
      v4 = 12;
      goto LABEL_7;
    }
    v9 = sub_2096D1D54();
    if ((_DWORD)v9)
    {
      v4 = v9;
      free(*(void **)(a4 + 8));
      *(_QWORD *)(a4 + 8) = 0;
LABEL_7:
      hx509_clear_error_string(a1);
      return v4;
    }
    if (*(_QWORD *)a4)
      sub_2096C1D6C("Internal asn1 encoder failure", v10, v11, v12, v13, v14, v15, v16, v18);
    return 0;
  }
  return v4;
}

uint64_t sub_2096C794C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;

  if (!a4)
    return 0;
  v5 = sub_2096D1D34();
  if ((_DWORD)v5)
    hx509_clear_error_string(a1);
  return v5;
}

uint64_t hx509_env_add(uint64_t a1, uint64_t *a2, const char *a3, const char *a4)
{
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  char *v14;
  char *v15;
  char *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  char v21;

  v8 = malloc_type_malloc(0x20uLL, 0x1032040EBA6683AuLL);
  if (!v8)
  {
    v19 = 12;
    hx509_set_error_string(a1, 0, 12, "out of memory", v9, v10, v11, v12, v21);
    return v19;
  }
  v13 = v8;
  *(_DWORD *)v8 = 0;
  v8[2] = 0;
  v14 = strdup(a3);
  v13[1] = v14;
  if (!v14)
  {
LABEL_9:
    free(v13);
    return 12;
  }
  v15 = v14;
  v16 = strdup(a4);
  v13[3] = v16;
  if (!v16)
  {
    free(v15);
    goto LABEL_9;
  }
  v17 = *a2;
  if (*a2)
  {
    do
    {
      v18 = v17;
      v17 = *(_QWORD *)(v17 + 16);
    }
    while (v17);
    v19 = 0;
    *(_QWORD *)(v18 + 16) = v13;
  }
  else
  {
    v19 = 0;
    *a2 = (uint64_t)v13;
  }
  return v19;
}

uint64_t hx509_env_add_binding(uint64_t a1, uint64_t *a2, const char *a3, uint64_t a4)
{
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  char v19;

  v8 = malloc_type_malloc(0x20uLL, 0x1032040EBA6683AuLL);
  if (v8)
  {
    v13 = v8;
    *(_DWORD *)v8 = 1;
    v8[2] = 0;
    v14 = strdup(a3);
    v13[1] = v14;
    if (v14)
    {
      v13[3] = a4;
      v15 = *a2;
      if (*a2)
      {
        do
        {
          v16 = v15;
          v15 = *(_QWORD *)(v15 + 16);
        }
        while (v15);
        v17 = 0;
        *(_QWORD *)(v16 + 16) = v13;
      }
      else
      {
        v17 = 0;
        *a2 = (uint64_t)v13;
      }
    }
    else
    {
      free(v13);
      return 12;
    }
  }
  else
  {
    v17 = 12;
    hx509_set_error_string(a1, 0, 12, "out of memory", v9, v10, v11, v12, v19);
  }
  return v17;
}

uint64_t hx509_env_lfind(int a1, uint64_t a2, char *__s1, size_t __n)
{
  uint64_t v6;
  const char *v7;

  if (!a2)
    return 0;
  v6 = a2;
  while (1)
  {
    v7 = *(const char **)(v6 + 8);
    if (!strncmp(__s1, v7, __n) && !v7[__n] && !*(_DWORD *)v6)
      break;
    v6 = *(_QWORD *)(v6 + 16);
    if (!v6)
      return 0;
  }
  return *(_QWORD *)(v6 + 24);
}

uint64_t hx509_env_find(int a1, uint64_t a2, char *__s1)
{
  uint64_t v4;

  if (!a2)
    return 0;
  v4 = a2;
  while (strcmp(__s1, *(const char **)(v4 + 8)) || *(_DWORD *)v4)
  {
    v4 = *(_QWORD *)(v4 + 16);
    if (!v4)
      return 0;
  }
  return *(_QWORD *)(v4 + 24);
}

uint64_t hx509_env_find_binding(int a1, uint64_t a2, char *__s1)
{
  uint64_t v4;

  if (!a2)
    return 0;
  v4 = a2;
  while (strcmp(__s1, *(const char **)(v4 + 8)) || *(_DWORD *)v4 != 1)
  {
    v4 = *(_QWORD *)(v4 + 16);
    if (!v4)
      return 0;
  }
  return *(_QWORD *)(v4 + 24);
}

void hx509_env_free(_QWORD **a1)
{
  _QWORD *v2;

  v2 = *a1;
  if (v2)
    sub_2096C7CA8(v2);
  *a1 = 0;
}

void sub_2096C7CA8(_QWORD *a1)
{
  _QWORD *v1;
  void *v2;

  if (a1)
  {
    v1 = a1;
    do
    {
      v2 = v1;
      v1 = (_QWORD *)v1[2];
      if (*(_DWORD *)v2 == 1)
      {
        sub_2096C7CA8(*((_QWORD *)v2 + 3));
      }
      else if (!*(_DWORD *)v2)
      {
        free(*((void **)v2 + 3));
      }
      free(*((void **)v2 + 1));
      free(v2);
    }
    while (v1);
  }
}

void hx509_clear_error_string(uint64_t a1)
{
  if (a1)
  {
    heim_release(*(CFTypeRef *)(a1 + 24));
    *(_QWORD *)(a1 + 24) = 0;
  }
}

void hx509_set_error_stringv(uint64_t a1, char a2, int a3, const char *a4, va_list a5)
{
  uint64_t v7;
  uint64_t v8;

  if (a1)
  {
    v7 = heim_error_createv(a3, a4, a5);
    v8 = v7;
    if (v7)
    {
      if ((a2 & 1) != 0)
        heim_error_append(v7, *(CFTypeRef *)(a1 + 24));
      heim_release(*(CFTypeRef *)(a1 + 24));
    }
    *(_QWORD *)(a1 + 24) = v8;
  }
}

void hx509_set_error_string(uint64_t a1, char a2, int a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  hx509_set_error_stringv(a1, a2, a3, a4, &a9);
}

char *hx509_get_error_string(uint64_t a1, int a2)
{
  uint64_t v4;
  char *result;
  char *v6;
  char *v7;
  char *v8;
  char *v9;
  char __dst[256];
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  v4 = *(_QWORD *)(a1 + 24);
  v9 = 0;
  if (v4 && heim_error_get_code(v4) == a2)
  {
    result = (char *)heim_error_copy_string(v4);
    if (result)
    {
      v6 = result;
      v7 = heim_string_copy_utf8((const __CFString *)result);
      heim_release(v6);
      return v7;
    }
  }
  else
  {
    v8 = com_right_r(*(_QWORD **)(a1 + 32), a2, __dst, 0x100uLL);
    if (v8)
      return strdup(v8);
    v8 = strerror(a2);
    if (v8)
    {
      return strdup(v8);
    }
    else if (asprintf(&v9, "<unknown error: %d>", a2) == -1)
    {
      return 0;
    }
    else
    {
      return v9;
    }
  }
  return result;
}

void hx509_err(uint64_t a1, int a2, int a3, char *a4, ...)
{
  char *error_string;
  const char *v8;
  char *v9[2];
  va_list va;

  va_start(va, a4);
  v9[0] = 0;
  va_copy((va_list)&v9[1], va);
  vasprintf(v9, a4, va);
  error_string = hx509_get_error_string(a1, a3);
  v8 = "no error";
  if (error_string)
    v8 = error_string;
  errx(a2, "%s: %s", v9[0], v8);
}

uint64_t _hx509_map_file_os(const char *a1, _QWORD *a2)
{
  uint64_t result;
  void *v4;
  void *v5;
  off_t v6;

  v5 = 0;
  v6 = 0;
  result = rk_undumpdata(a1, &v5, &v6);
  v4 = v5;
  *a2 = v6;
  a2[1] = v4;
  return result;
}

void _hx509_unmap_file_os(uint64_t a1)
{
  j__free(*(void **)(a1 + 8));
}

uint64_t _hx509_write_file(const char *a1, char *a2, size_t a3)
{
  rk_dumpdata(a1, a2, a3);
  return 0;
}

uint64_t hx509_pem_write(uint64_t a1, const char *a2, uint64_t **a3, FILE *a4, uint64_t a5, unint64_t a6)
{
  const char *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  char v20;
  void *v21;

  v21 = 0;
  fprintf(a4, "-----%s %s-----\n", "BEGIN", a2);
  for (; a3; a3 = (uint64_t **)*a3)
  {
    if (*a3)
      v12 = "";
    else
      v12 = "\n";
    fprintf(a4, "%s: %s\n%s", (const char *)a3[1], (const char *)a3[2], v12);
  }
  if (a6)
  {
    while (1)
    {
      v13 = a6 >= 0x36 ? 54 : a6;
      if ((base64_encode(a5, v13, (const char **)&v21) & 0x80000000) != 0)
        break;
      a6 -= v13;
      fprintf(a4, "%s\n", (const char *)v21);
      a5 += v13;
      free(v21);
      if (!a6)
        goto LABEL_12;
    }
    v18 = 12;
    hx509_set_error_string(a1, 0, 12, "malloc - out of memory", v14, v15, v16, v17, v20);
  }
  else
  {
LABEL_12:
    fprintf(a4, "-----%s %s-----\n", "END", a2);
    return 0;
  }
  return v18;
}

uint64_t hx509_pem_add_header(_QWORD *a1, const char *a2, const char *a3)
{
  _QWORD *v6;
  _QWORD *v7;
  char *v8;
  char *v9;
  char *v10;
  uint64_t result;

  v6 = malloc_type_calloc(1uLL, 0x18uLL, 0x30040F310086FuLL);
  if (v6)
  {
    v7 = v6;
    v8 = strdup(a2);
    v7[1] = v8;
    if (v8)
    {
      v9 = v8;
      v10 = strdup(a3);
      v7[2] = v10;
      if (v10)
      {
        result = 0;
        *v7 = *a1;
        *a1 = v7;
        return result;
      }
      free(v9);
    }
    free(v7);
  }
  return 12;
}

void hx509_pem_free_header(void **a1)
{
  void **v1;
  void **v2;

  if (a1)
  {
    v1 = a1;
    do
    {
      v2 = (void **)*v1;
      free(v1[1]);
      free(v1[2]);
      free(v1);
      v1 = v2;
    }
    while (v2);
  }
}

uint64_t hx509_pem_find_header(uint64_t result, char *__s1)
{
  uint64_t v3;

  if (result)
  {
    v3 = result;
    while (strcmp(__s1, *(const char **)(v3 + 8)))
    {
      v3 = *(_QWORD *)v3;
      if (!v3)
        return 0;
    }
    return *(_QWORD *)(v3 + 16);
  }
  return result;
}

size_t hx509_pem_read(uint64_t a1, FILE *a2, uint64_t (*a3)(uint64_t, char *, void **, char *, size_t, uint64_t), uint64_t a4)
{
  size_t v7;
  size_t v8;
  char *v9;
  char *v10;
  int v11;
  int v12;
  BOOL v13;
  char *v14;
  const char *v15;
  unsigned int v16;
  unsigned int v17;
  _BYTE *v19;
  unsigned int v20;
  char *v21;
  uint64_t (*v22)(uint64_t, char *, void **, char *, size_t, uint64_t);
  size_t v23;
  char *v24;
  char *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  unsigned int v32;
  void **v33;
  _BYTE __s[11];
  char v35[1013];
  uint64_t v36;

  v36 = *MEMORY[0x24BDAC8D0];
  v7 = 569965;
  v33 = 0;
  if (fgets(__s, 1024, a2))
  {
    LODWORD(v7) = 0;
    v8 = 0;
    v9 = 0;
    v10 = 0;
    v32 = 569965;
    while (2)
    {
      v11 = strcspn(__s, "\n");
      v12 = v11;
      if (__s[v11] == 10)
      {
        __s[v11] = 0;
        v12 = v11 - (v11 > 0);
      }
      if (__s[v12] == 13)
      {
        __s[v12] = 0;
        v12 -= v12 > 0;
      }
      switch((int)v7)
      {
        case 0:
          v13 = *(_QWORD *)__s == 0x4745422D2D2D2D2DLL && *(_QWORD *)&__s[3] == 0x204E494745422D2DLL;
          if (v13 && (v24 = strdup(v35), (v10 = v24) != 0))
          {
            v25 = strchr(v24, 45);
            if (v25)
              *v25 = 0;
            LODWORD(v7) = 1;
          }
          else
          {
            LODWORD(v7) = 0;
          }
          goto LABEL_39;
        case 1:
          if (strchr(__s, 58))
            goto LABEL_14;
          goto LABEL_23;
        case 2:
LABEL_14:
          if (!__s[0])
          {
            LODWORD(v7) = 3;
            goto LABEL_39;
          }
          v14 = strchr(__s, 58);
          if (!v14)
            goto LABEL_39;
          v15 = v14;
          *v14 = 0;
          do
          {
            while (1)
            {
              v17 = *++v15;
              v16 = v17;
              if ((v17 & 0x80000000) != 0)
                break;
              if ((*(_DWORD *)(MEMORY[0x24BDAC740] + 4 * v16 + 60) & 0x4000) == 0)
                goto LABEL_21;
            }
          }
          while (__maskrune(v16, 0x4000uLL));
LABEL_21:
          if (hx509_pem_add_header(&v33, __s, v15))
            abort();
          goto LABEL_38;
        case 3:
LABEL_23:
          if (*(_QWORD *)__s == 0x444E452D2D2D2D2DLL && __s[8] == 32)
          {
            v7 = a3(a1, v10, v33, v9, v8, a4);
          }
          else
          {
            v19 = sub_2096B808C(v12);
            v20 = base64_decode(__s, v19);
            if ((v20 & 0x80000000) == 0)
            {
              v7 = v20;
              v21 = v10;
              v22 = a3;
              v23 = v8;
              v8 += v20;
              v9 = (char *)sub_2096B80D8(v9, v8);
              memcpy(&v9[v23], v19, v7);
              free(v19);
              LODWORD(v7) = 3;
              a3 = v22;
              v10 = v21;
              goto LABEL_39;
            }
            free(v19);
            v7 = v32;
          }
          free(v9);
          free(v10);
          hx509_pem_free_header(v33);
          v33 = 0;
          if ((_DWORD)v7)
            return v7;
          v10 = 0;
          v9 = 0;
          v8 = 0;
LABEL_38:
          v32 = 0;
LABEL_39:
          if (fgets(__s, 1024, a2))
            continue;
          if ((_DWORD)v7)
          {
            hx509_set_error_string(a1, 0, 569965, "File ends before end of PEM end tag", v26, v27, v28, v29, (char)v35);
            v32 = 569965;
          }
          if (v9)
            free(v9);
          if (v10)
            free(v10);
          v7 = v32;
          if (v33)
            hx509_pem_free_header(v33);
          break;
        default:
          goto LABEL_39;
      }
      break;
    }
  }
  return v7;
}

const char **sub_2096C85A4(uint64_t a1, char *a2)
{
  uint64_t v2;
  const char ***i;
  const char **v5;

  v2 = *(unsigned int *)(a1 + 8);
  if ((int)v2 < 1)
    return 0;
  for (i = *(const char ****)a1; ; ++i)
  {
    v5 = *i;
    if (!strcasecmp(a2, **i))
      break;
    if (!--v2)
      return 0;
  }
  return v5;
}

uint64_t hx509_certs_init(uint64_t a1, char *__s, uint64_t a3, uint64_t a4, _QWORD *a5)
{
  const char *v8;
  char *v10;
  char *v11;
  size_t v12;
  char *v13;
  char *v14;
  const char *v15;
  int v16;
  const char **v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  const char **v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  const void *v29;
  uint64_t v30;

  v8 = __s;
  *a5 = 0;
  v10 = strchr(__s, 58);
  if (v10)
  {
    v11 = v10;
    v12 = v10 - v8 + 1;
    v13 = (char *)malloc_type_malloc(v12, 0x794DCE47uLL);
    v14 = v13;
    if (v13)
      strlcpy(v13, v8, v12);
    v16 = v11[1];
    v15 = v11 + 1;
    if (v16)
      v8 = v15;
    else
      v8 = 0;
    if (!v14)
      goto LABEL_14;
  }
  else
  {
    v14 = strdup("MEMORY");
    if (!v14)
    {
LABEL_14:
      hx509_clear_error_string(a1);
      return 12;
    }
  }
  v17 = sub_2096C85A4(a1, v14);
  if (!v17)
  {
    v30 = 2;
    hx509_set_error_string(a1, 0, 2, "Keyset type %s is not supported", v18, v19, v20, v21, (char)v14);
    free(v14);
    return v30;
  }
  v22 = v17;
  free(v14);
  v28 = heim_uniq_alloc(0x30uLL, (uint64_t)"hx509-certs", (uint64_t)sub_2096C8774, v23, v24, v25, v26, v27);
  if (!v28)
    goto LABEL_14;
  v29 = (const void *)v28;
  *(_QWORD *)(v28 + 32) = v22;
  v30 = ((uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, const char *, uint64_t))v22[2])(a1, v28, v28 + 40, a3, v8, a4);
  if ((_DWORD)v30)
    heim_release(v29);
  else
    *a5 = v29;
  return v30;
}

uint64_t sub_2096C8774(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)(a1 + 32) + 32))(a1, *(_QWORD *)(a1 + 40));
}

uint64_t hx509_certs_store(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _QWORD *v8;
  uint64_t (*v9)(uint64_t, uint64_t, _QWORD, uint64_t, uint64_t);

  v8 = *(_QWORD **)(a2 + 32);
  v9 = (uint64_t (*)(uint64_t, uint64_t, _QWORD, uint64_t, uint64_t))v8[3];
  if (v9)
    return v9(a1, a2, *(_QWORD *)(a2 + 40), a3, a4);
  hx509_set_error_string(a1, 0, 569966, "keystore if type %s doesn't support store operation", a5, 0, a7, a8, *v8);
  return 569966;
}

void hx509_certs_free(const void **a1)
{
  const void *v2;

  if (a1)
  {
    v2 = *a1;
    if (v2)
    {
      heim_release(v2);
      *a1 = 0;
    }
  }
}

uint64_t hx509_certs_start_seq(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _QWORD *v8;
  uint64_t (*v9)(uint64_t, uint64_t, _QWORD, uint64_t);

  v8 = *(_QWORD **)(a2 + 32);
  v9 = (uint64_t (*)(uint64_t, uint64_t, _QWORD, uint64_t))v8[7];
  if (v9)
    return v9(a1, a2, *(_QWORD *)(a2 + 40), a3);
  hx509_set_error_string(a1, 0, 569966, "Keyset type %s doesn't support iteration", 0, a6, a7, a8, *v8);
  return 569966;
}

uint64_t hx509_certs_next_cert(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD *a4)
{
  *a4 = 0;
  return (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t))(*(_QWORD *)(a2 + 32) + 64))(a1, a2, *(_QWORD *)(a2 + 40), a3);
}

uint64_t hx509_certs_end_seq(uint64_t a1, uint64_t a2, uint64_t a3)
{
  (*(void (**)(uint64_t, uint64_t, _QWORD, uint64_t))(*(_QWORD *)(a2 + 32) + 72))(a1, a2, *(_QWORD *)(a2 + 40), a3);
  return 0;
}

uint64_t hx509_certs_iter_f(uint64_t a1, uint64_t a2, uint64_t (*a3)(uint64_t, uint64_t), uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t started;
  uint64_t v13;
  uint64_t v15;
  uint64_t v16;

  v16 = 0;
  started = hx509_certs_start_seq(a1, a2, (uint64_t)&v16, a4, a5, a6, a7, a8);
  if (!(_DWORD)started)
  {
    while (1)
    {
      v15 = 0;
      v13 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, uint64_t *))(*(_QWORD *)(a2 + 32) + 64))(a1, a2, *(_QWORD *)(a2 + 40), v16, &v15);
      if ((_DWORD)v13)
      {
        started = v13;
        goto LABEL_8;
      }
      if (!v15)
        break;
      started = a3(a1, a4);
      hx509_cert_free(v15);
      if ((_DWORD)started)
        goto LABEL_8;
    }
    started = 0;
LABEL_8:
    (*(void (**)(uint64_t, uint64_t, _QWORD, uint64_t))(*(_QWORD *)(a2 + 32) + 72))(a1, a2, *(_QWORD *)(a2 + 40), v16);
  }
  return started;
}

uint64_t hx509_certs_iter(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return hx509_certs_iter_f(a1, a2, (uint64_t (*)(uint64_t, uint64_t))sub_2096C898C, a3, a5, a6, a7, a8);
}

uint64_t sub_2096C898C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a3);
}

uint64_t hx509_ci_print_names(uint64_t a1, FILE *a2, uint64_t a3)
{
  uint64_t v4;
  void *v6;
  void *v7;
  void *v8;

  v8 = 0;
  v6 = 0;
  v7 = 0;
  v4 = sub_2096BEAC8(a3);
  hx509_name_from_Name(v4 + 144, &v8);
  hx509_name_to_string(v8, &v7);
  hx509_name_free(&v8);
  hx509_name_from_Name(v4 + 72, &v8);
  hx509_name_to_string(v8, &v6);
  hx509_name_free(&v8);
  fprintf(a2, "subject: %s\nissuer: %s\n", (const char *)v7, (const char *)v6);
  free(v7);
  free(v6);
  return 0;
}

uint64_t hx509_certs_add(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _QWORD *v8;
  uint64_t (*v9)(uint64_t, uint64_t, _QWORD, uint64_t);

  v8 = *(_QWORD **)(a2 + 32);
  v9 = (uint64_t (*)(uint64_t, uint64_t, _QWORD, uint64_t))v8[5];
  if (v9)
    return v9(a1, a2, *(_QWORD *)(a2 + 40), a3);
  hx509_set_error_string(a1, 0, 2, "Keyset type %s doesn't support add operation", 0, a6, a7, a8, *v8);
  return 2;
}

uint64_t hx509_certs_find(uint64_t a1, uint64_t a2, int *a3, _QWORD *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t (*v12)(uint64_t, uint64_t, _QWORD, int *, _QWORD *);
  uint64_t started;
  uint64_t v14;
  BOOL v15;
  BOOL v16;
  uint64_t v18;
  uint64_t v19;

  *a4 = 0;
  v12 = *(uint64_t (**)(uint64_t, uint64_t, _QWORD, int *, _QWORD *))(*(_QWORD *)(a2 + 32) + 48);
  if (!v12 || (started = v12(a1, a2, *(_QWORD *)(a2 + 40), a3, a4), (_DWORD)started == 569967))
  {
    v19 = 0;
    started = hx509_certs_start_seq(a1, a2, (uint64_t)&v19, (uint64_t)a4, a5, a6, a7, a8);
    if (!(_DWORD)started)
    {
      while (1)
      {
        v18 = 0;
        v14 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, uint64_t *))(*(_QWORD *)(a2 + 32) + 64))(a1, a2, *(_QWORD *)(a2 + 40), v19, &v18);
        v15 = (_DWORD)v14 != 0;
        if ((_DWORD)v14)
          v16 = 1;
        else
          v16 = v18 == 0;
        if (v16)
        {
          started = v14;
          goto LABEL_14;
        }
        if (sub_2096C1788(a1, a3, v18))
          break;
        hx509_cert_free(v18);
      }
      started = 0;
      v15 = 0;
      *a4 = v18;
LABEL_14:
      (*(void (**)(uint64_t, uint64_t, _QWORD, uint64_t))(*(_QWORD *)(a2 + 32) + 72))(a1, a2, *(_QWORD *)(a2 + 40), v19);
      if (!v15)
      {
        if (v18)
        {
          return 0;
        }
        else
        {
          started = 569873;
          hx509_clear_error_string(a1);
        }
      }
    }
  }
  return started;
}

uint64_t hx509_certs_filter(uint64_t a1, uint64_t a2, int *a3, uint64_t *a4)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t started;
  uint64_t v16;
  _BOOL4 v17;
  uint64_t v18;
  BOOL v19;
  int v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  BOOL v27;
  uint64_t v28;
  uint64_t v29;

  v13 = hx509_certs_init(a1, "MEMORY:filter-certs", 0, 0, a4);
  if ((_DWORD)v13)
    return v13;
  v29 = 0;
  started = hx509_certs_start_seq(a1, a2, (uint64_t)&v29, v8, v9, v10, v11, v12);
  if ((_DWORD)started)
  {
    v13 = started;
LABEL_20:
    if (a4 && *a4)
    {
      heim_release((CFTypeRef)*a4);
      *a4 = 0;
    }
    return v13;
  }
  v28 = 0;
  v16 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, uint64_t *))(*(_QWORD *)(a2 + 32) + 64))(a1, a2, *(_QWORD *)(a2 + 40), v29, &v28);
  v17 = v16 != 0;
  v18 = v28;
  if ((_DWORD)v16)
    v19 = 1;
  else
    v19 = v28 == 0;
  if (v19)
  {
    v13 = v16;
    v20 = 0;
  }
  else
  {
    v20 = 0;
    do
    {
      if (sub_2096C1788(a1, a3, v18))
      {
        hx509_certs_add(a1, *a4, v28, v21, v22, v23, v24, v25);
        v20 = 1;
      }
      hx509_cert_free(v28);
      v28 = 0;
      v26 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, uint64_t *))(*(_QWORD *)(a2 + 32) + 64))(a1, a2, *(_QWORD *)(a2 + 40), v29, &v28);
      v17 = v26 != 0;
      v18 = v28;
      if ((_DWORD)v26)
        v27 = 1;
      else
        v27 = v28 == 0;
    }
    while (!v27);
    v13 = v26;
  }
  (*(void (**)(uint64_t, uint64_t, _QWORD, uint64_t))(*(_QWORD *)(a2 + 32) + 72))(a1, a2, *(_QWORD *)(a2 + 40), v29);
  if (v17)
    goto LABEL_20;
  if (v20)
    return 0;
  if (a4 && *a4)
  {
    heim_release((CFTypeRef)*a4);
    *a4 = 0;
  }
  hx509_clear_error_string(a1);
  return 569873;
}

uint64_t hx509_certs_merge(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a3)
    return hx509_certs_iter_f(a1, a3, (uint64_t (*)(uint64_t, uint64_t))j__hx509_certs_add, a2, a5, a6, a7, a8);
  else
    return 0;
}

uint64_t hx509_certs_append(uint64_t a1, uint64_t a2, uint64_t a3, char *__s)
{
  uint64_t result;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  const void *v11;
  uint64_t v12;
  const void *v13;

  v13 = 0;
  result = hx509_certs_init(a1, __s, 0, a3, &v13);
  if (!(_DWORD)result)
  {
    v11 = v13;
    if (v13)
    {
      v12 = hx509_certs_iter_f(a1, (uint64_t)v13, (uint64_t (*)(uint64_t, uint64_t))j__hx509_certs_add, a2, v7, v8, v9, v10);
      heim_release(v11);
      return v12;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t hx509_get_one_cert(uint64_t a1, uint64_t a2, _QWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result;
  uint64_t v12;
  uint64_t v13;

  v13 = 0;
  *a3 = 0;
  result = hx509_certs_start_seq(a1, a2, (uint64_t)&v13, a4, a5, a6, a7, a8);
  if (!(_DWORD)result)
  {
    v12 = v13;
    *a3 = 0;
    result = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, _QWORD *))(*(_QWORD *)(a2 + 32) + 64))(a1, a2, *(_QWORD *)(a2 + 40), v12, a3);
    if (!(_DWORD)result)
    {
      (*(void (**)(uint64_t, uint64_t, _QWORD, uint64_t))(*(_QWORD *)(a2 + 32) + 72))(a1, a2, *(_QWORD *)(a2 + 40), v13);
      return 0;
    }
  }
  return result;
}

uint64_t hx509_certs_info(uint64_t a1, uint64_t a2, uint64_t (*a3)(FILE *a1, const char *a2), FILE *a4)
{
  unint64_t v5;
  uint64_t (*v6)(FILE *, const char *);
  FILE *v7;
  uint64_t (*v8)(uint64_t, uint64_t, _QWORD, uint64_t (*)(FILE *, const char *), FILE *);

  v5 = (unint64_t)a3 | (unint64_t)a4;
  if (a3)
    v6 = a3;
  else
    v6 = sub_2096C8F1C;
  if (v5)
    v7 = a4;
  else
    v7 = (FILE *)*MEMORY[0x24BDAC8E8];
  v8 = *(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t (*)(FILE *, const char *), FILE *))(*(_QWORD *)(a2 + 32) + 80);
  if (v8)
    return v8(a1, a2, *(_QWORD *)(a2 + 40), v6, v7);
  v6(v7, "No info function for certs");
  return 0;
}

uint64_t sub_2096C8F1C(FILE *a1, const char *a2)
{
  fprintf(a1, "%s\n", a2);
  return 0;
}

uint64_t _hx509_certs_keys_get(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  uint64_t (*v3)(uint64_t, uint64_t, _QWORD, _QWORD *);

  v3 = *(uint64_t (**)(uint64_t, uint64_t, _QWORD, _QWORD *))(*(_QWORD *)(a2 + 32) + 88);
  if (v3)
    return v3(a1, a2, *(_QWORD *)(a2 + 40), a3);
  *a3 = 0;
  return 0;
}

uint64_t sub_2096C8F6C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _QWORD *v8;
  uint64_t (*v9)(uint64_t, uint64_t, _QWORD, uint64_t);

  v8 = *(_QWORD **)(a2 + 32);
  v9 = (uint64_t (*)(uint64_t, uint64_t, _QWORD, uint64_t))v8[12];
  if (v9)
    return v9(a1, a2, *(_QWORD *)(a2 + 40), a3);
  hx509_set_error_string(a1, 0, 22, "keystore if type %s doesn't support key add operation", 0, a6, a7, a8, *v8);
  return 22;
}

void _hx509_certs_keys_free(int a1, const void **a2)
{
  const void **v3;
  const void *v4;

  if (*a2)
  {
    v3 = a2;
    do
    {
      hx509_private_key_free(v3);
      v4 = v3[1];
      ++v3;
    }
    while (v4);
  }
  free(a2);
}

uint64_t sub_2096C9000(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t inited;
  uint64_t v15;

  v15 = 0;
  inited = hx509_cert_init_data(a1, a5, a6, (CFTypeRef *)&v15);
  if (!(_DWORD)inited)
  {
    inited = sub_2096C465C(a1, a3, v15, v8, v9, v10, v11, v12);
    hx509_cert_free(v15);
  }
  return inited;
}

uint64_t sub_2096C906C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v10;
  _QWORD v12[2];
  __int128 v13;
  _OWORD v14[2];
  __int128 v15;
  uint64_t v16;

  v16 = 0;
  v15 = 0u;
  v13 = 0u;
  memset(v14, 0, sizeof(v14));
  v10 = sub_2096BC5C8();
  if (!(_DWORD)v10)
  {
    v12[0] = a6;
    v12[1] = a5;
    v10 = sub_2096C4664(a1, a3, (uint64_t)v14 + 8, 0, (uint64_t *)&v15, (uint64_t)v12);
    sub_2096BC618();
  }
  return v10;
}

uint64_t sub_2096C910C(uint64_t a1, char a2, uint64_t a3, uint64_t a4, uint64_t a5, size_t a6, uint64_t a7)
{
  uint64_t header;
  const char *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  const char *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  char *v32;
  char *v33;
  char *v34;
  const char *v35;
  size_t v36;
  _BYTE *v37;
  _BYTE *v38;
  uint64_t v39;
  const char *v40;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  char *v46;
  _QWORD *v47;
  _QWORD *v48;
  uint64_t v49;
  size_t v50;
  size_t v51;
  char size;
  uint64_t cipherbyname;
  char __s[8];
  uint64_t v55;
  uint64_t v56;

  v56 = *MEMORY[0x24BDAC8D0];
  header = hx509_pem_find_header(a4, "Proc-Type");
  if (!header)
  {
    *(_QWORD *)__s = a6;
    v55 = a5;
    return sub_2096C4664(a1, a3, a7, 0, (uint64_t *)__s, 0);
  }
  v15 = (const char *)header;
  v16 = sub_2096C4654(a3);
  if (!v16)
  {
    v26 = 569866;
    hx509_set_error_string(a1, 0, 569866, "Failed to get password for password protected file %s", v17, v18, v19, v20, a2);
    return v26;
  }
  v21 = v16;
  if (!strcmp(v15, "4,ENCRYPTED"))
  {
    v27 = (const char *)hx509_pem_find_header(a4, "DEK-Info");
    if (v27)
    {
      v32 = strdup(v27);
      if (v32)
      {
        v33 = v32;
        v34 = strchr(v32, 44);
        if (!v34)
        {
          v26 = 569965;
          free(v33);
          v40 = "IV missing";
          goto LABEL_18;
        }
        *v34 = 0;
        v35 = v34 + 1;
        v36 = strlen(v34 + 1);
        v37 = malloc_type_malloc(v36, 0xE5F0364DuLL);
        if (v37)
        {
          v38 = v37;
          cipherbyname = hc_EVP_get_cipherbyname(v33);
          if (cipherbyname)
          {
            v39 = rk_hex_decode(v35, v38, v36);
            free(v33);
            if (v39 < 8 || v39 < (unint64_t)hc_EVP_CIPHER_iv_length(cipherbyname))
            {
              v26 = 569965;
              free(v38);
              v40 = "Salt have wrong length in private key file";
LABEL_18:
              hx509_set_error_string(a1, 0, 569965, v40, v28, v29, v30, v31, size);
              return v26;
            }
            v47 = (_QWORD *)nullsub_1(v21);
            if (v47 && (v48 = v47, *v47))
            {
              v49 = 0;
              while (1)
              {
                v50 = strlen(*(const char **)(v48[1] + 8 * v49));
                if (!sub_2096C94D8(a1, a3, a7, cipherbyname, v38, *(_QWORD *)(v48[1] + 8 * v49), v50, a5, a6))break;
                if ((unint64_t)++v49 >= *v48)
                  goto LABEL_28;
              }
              v26 = 0;
            }
            else
            {
LABEL_28:
              v26 = hx509_lock_prompt(v21);
              if (!(_DWORD)v26)
              {
                v51 = strlen(__s);
                v26 = sub_2096C94D8(a1, a3, a7, cipherbyname, v38, (uint64_t)__s, v51, a5, a6);
              }
            }
            v46 = v38;
          }
          else
          {
            free(v38);
            v26 = 569866;
            hx509_set_error_string(a1, 0, 569866, "Private key encrypted with unsupported cipher: %s", v42, v43, v44, v45, (char)v33);
            v46 = v33;
          }
          free(v46);
          return v26;
        }
        hx509_clear_error_string(a1);
        free(v33);
      }
      else
      {
        hx509_clear_error_string(a1);
      }
      return 12;
    }
    v26 = 569965;
    v40 = "Encrypted private key missing DEK-Info";
    goto LABEL_18;
  }
  v26 = 569965;
  hx509_set_error_string(a1, 0, 569965, "Private key encrypted in unknown method %s in file %s", v22, v23, v24, v25, (char)v15);
  hx509_clear_error_string(a1);
  return v26;
}

_QWORD *sub_2096C9494(uint64_t a1)
{
  sub_209679060(a1, &off_253D3B040);
  sub_209679060(a1, &off_253D3B178);
  return sub_209679060(a1, &off_253D3AFD8);
}

uint64_t sub_2096C94D8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5, uint64_t a6, uint64_t a7, int a8, size_t size)
{
  size_t v16;
  void *v17;
  void *v18;
  int *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  size_t v30;
  void *v31;
  _OWORD v32[10];
  uint64_t v33;
  uint64_t v34;

  v34 = *MEMORY[0x24BDAC8D0];
  v16 = hc_EVP_CIPHER_key_length(a4);
  v17 = malloc_type_malloc(v16, 0x29FA73EAuLL);
  if (v17)
  {
    v18 = v17;
    v19 = (int *)hc_EVP_md5((uint64_t)v17);
    if ((int)sub_2096D5064(a4, v19, (uint64_t)a5, a6, a7, 1, (char *)v18, 0) <= 0)
    {
      v28 = 569920;
      hx509_set_error_string(a1, 0, 569920, "Failed to do string2key for private key", v20, v21, v22, v23, v30);
    }
    else
    {
      v31 = malloc_type_malloc(size, 0x15545EC3uLL);
      if (v31)
      {
        v30 = size;
        v33 = 0;
        memset(v32, 0, sizeof(v32));
        hc_EVP_CIPHER_CTX_init((uint64_t)v32);
        hc_EVP_CipherInit_ex((uint64_t)v32, a4, 0, (uint64_t)v18, a5, 0);
        hc_EVP_Cipher((uint64_t)v32);
        hc_EVP_CIPHER_CTX_cleanup((uint64_t *)v32);
        v28 = sub_2096C4664(a1, a2, a3, 0, (uint64_t *)&v30, 0);
        bzero(v31, v30);
        free(v31);
      }
      else
      {
        v28 = 12;
        hx509_set_error_string(a1, 0, 12, "Out of memory to decrypt for private key", v24, v25, v26, v27, v30);
      }
      bzero(v18, v16);
      free(v18);
    }
  }
  else
  {
    hx509_clear_error_string(a1);
    return 12;
  }
  return v28;
}

uint64_t sub_2096C96D4(uint64_t a1, uint64_t a2, _QWORD *a3, unsigned int a4, const char *a5, void *a6)
{
  return sub_2096C9814(a1, a3, a4, a5, a6, 0);
}

uint64_t sub_2096C96EC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  FILE *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v16;
  FILE *v17;
  uint64_t v18;

  v5 = fopen(*(const char **)(a3 + 8), "w");
  v17 = v5;
  if (v5)
  {
    v18 = 0;
    rk_cloexec_file(v5);
    LODWORD(v18) = *(_DWORD *)(a3 + 16);
    v14 = hx509_certs_iter_f(a1, *(_QWORD *)a3, (uint64_t (*)(uint64_t, uint64_t))sub_2096C9C20, (uint64_t)&v17, v10, v11, v12, v13);
    fclose(v17);
  }
  else
  {
    v16 = *(_QWORD *)(a3 + 8);
    v14 = 2;
    hx509_set_error_string(a1, 0, 2, "Failed to open file %s for writing", v6, v7, v8, v9, v16);
  }
  return v14;
}

uint64_t sub_2096C978C(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    hx509_certs_free((const void **)a2);
    free(*(void **)(a2 + 8));
    free((void *)a2);
  }
  return 0;
}

uint64_t sub_2096C97C8(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return hx509_certs_add(a1, *a3, a4, a4, a5, a6, a7, a8);
}

uint64_t sub_2096C97D4(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return hx509_certs_start_seq(a1, *a3, a4, a4, a5, a6, a7, a8);
}

uint64_t sub_2096C97E0(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, _QWORD *a5)
{
  return hx509_certs_next_cert(a1, *a3, a4, a5);
}

uint64_t sub_2096C97F0(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  return hx509_certs_end_seq(a1, *a3, a4);
}

uint64_t sub_2096C97FC(uint64_t a1, uint64_t a2, uint64_t *a3, _QWORD *a4)
{
  return _hx509_certs_keys_get(a1, *a3, a4);
}

uint64_t sub_2096C9808(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return sub_2096C8F6C(a1, *a3, a4, a4, a5, a6, a7, a8);
}

uint64_t sub_2096C9814(uint64_t a1, _QWORD *a2, unsigned int a3, const char *a4, void *a5, int a6)
{
  char v8;
  void *v11;
  _QWORD *v12;
  _QWORD *v13;
  char *v14;
  size_t v15;
  char *v16;
  char *v17;
  char *v18;
  FILE *v19;
  FILE *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t (*v23)(void);
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  const void **v31;
  uint64_t v32;
  uint64_t v33;
  void *v34;
  int *v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  void *v41;
  off_t v42;
  uint64_t v43;
  void *v44;
  void *v45;

  v8 = a3;
  v44 = 0;
  v45 = 0;
  v43 = a3;
  *a2 = 0;
  if (a5)
    v11 = a5;
  else
    v11 = off_2545A70A8;
  v12 = malloc_type_calloc(1uLL, 0x18uLL, 0x10300409B68AA8EuLL);
  if (v12)
  {
    v13 = v12;
    *((_DWORD *)v12 + 4) = a6;
    v14 = strdup(a4);
    v13[1] = v14;
    if (!v14)
    {
      hx509_clear_error_string(a1);
      v15 = 12;
      goto LABEL_35;
    }
    if ((v8 & 1) != 0)
    {
      v15 = hx509_certs_init(a1, "MEMORY:ks-file-create", 0, (uint64_t)v11, v13);
      if ((_DWORD)v15)
        goto LABEL_35;
      *a2 = v13;
    }
    else
    {
      v15 = sub_2096C4564(a1, (uint64_t)v11, &v44);
      if ((_DWORD)v15)
        goto LABEL_35;
      v16 = (char *)v13[1];
      if (v16)
      {
        do
        {
          v17 = strchr(v16, 44);
          v18 = v17;
          if (v17)
          {
            *v17 = 0;
            v18 = v17 + 1;
          }
          v19 = fopen(v16, "r");
          if (!v19)
          {
            v36 = __error();
            strerror(*v36);
            v15 = 2;
            hx509_set_error_string(a1, 0, 2, "Failed to open PEM file \"%s\": %s", v37, v38, v39, v40, (char)v16);
            goto LABEL_35;
          }
          v20 = v19;
          rk_cloexec_file(v19);
          v15 = hx509_pem_read(a1, v20, (uint64_t (*)(uint64_t, char *, void **, char *, size_t, uint64_t))sub_2096C9B0C, (uint64_t)&v43);
          fclose(v20);
          if ((_DWORD)v15)
          {
            if ((_DWORD)v15 != 569965)
              goto LABEL_35;
            v41 = 0;
            v42 = 0;
            v21 = rk_undumpdata(v16, &v41, &v42);
            if ((_DWORD)v21)
            {
              v15 = v21;
LABEL_34:
              hx509_clear_error_string(a1);
LABEL_35:
              v34 = (void *)v13[1];
              if (v34)
                free(v34);
              free(v13);
              goto LABEL_38;
            }
            v22 = 0;
            while (1)
            {
              v23 = (uint64_t (*)(void))(&off_253D3AF08)[v22 + 2];
              v24 = v23 ? v23() : 0;
              v25 = ((uint64_t (*)(uint64_t, char *, void *, _QWORD, void *, off_t, uint64_t))(&off_253D3AF08)[v22 + 1])(a1, v16, v44, 0, v41, v42, v24);
              if (!(_DWORD)v25)
                break;
              v15 = v25;
              v22 += 3;
              if (v22 == 12)
              {
                j__free(v41);
                goto LABEL_34;
              }
            }
            j__free(v41);
          }
          v16 = v18;
        }
        while (v18);
      }
      v15 = sub_2096C4808(a1, (uint64_t *)v44, v13);
      if ((_DWORD)v15)
        goto LABEL_35;
      v15 = sub_2096C4A74(a1, (uint64_t)v44, &v45);
      if ((_DWORD)v15)
        goto LABEL_35;
      v31 = (const void **)v45;
      v32 = *(_QWORD *)v45;
      if (*(_QWORD *)v45)
      {
        v33 = 8;
        do
        {
          sub_2096C8F6C(a1, *v13, v32, v26, v27, v28, v29, v30);
          v31 = (const void **)v45;
          v32 = *(_QWORD *)((char *)v45 + v33);
          v33 += 8;
        }
        while (v32);
      }
      _hx509_certs_keys_free(a1, v31);
      v15 = 0;
      *a2 = v13;
LABEL_38:
      if (v44)
        sub_2096C4B74((char *)v44);
    }
  }
  else
  {
    hx509_clear_error_string(a1);
    return 12;
  }
  return v15;
}

uint64_t sub_2096C9B0C(uint64_t a1, char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  char **v18;
  uint64_t (*v19)(void);
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;

  v12 = 0;
  while (strcasecmp(a2, (&off_253D3AF08)[v12]))
  {
    v12 += 3;
    if (v12 == 12)
    {
      v17 = 569966;
      hx509_set_error_string(a1, 0, 569966, "Found no matching PEM format for %s", v13, v14, v15, v16, (char)a2);
      return v17;
    }
  }
  v18 = &(&off_253D3AF08)[v12];
  v19 = (uint64_t (*)(void))v18[2];
  if (v19)
    v20 = v19();
  else
    v20 = 0;
  v17 = ((uint64_t (*)(uint64_t, _QWORD, _QWORD, uint64_t, uint64_t, uint64_t, uint64_t))v18[1])(a1, 0, *(_QWORD *)(a6 + 8), a3, a4, a5, v20);
  if ((_DWORD)v17)
  {
    if ((*(_BYTE *)a6 & 2) != 0)
      hx509_set_error_string(a1, 1, v17, "Failed parseing PEM format %s", v21, v22, v23, v24, (char)a2);
    else
      return 0;
  }
  return v17;
}

uint64_t sub_2096C9C20(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  int v8;
  uint64_t v9;
  const char *v10;
  size_t v11;
  void *v12;

  v11 = 0;
  v12 = 0;
  v6 = hx509_cert_binary(a1, a3, (uint64_t)&v11);
  if (!(_DWORD)v6)
  {
    v8 = *(_DWORD *)(a2 + 8);
    if (v8)
    {
      if (v8 != 1)
        return v6;
      fwrite(v12, v11, 1uLL, *(FILE **)a2);
    }
    else
    {
      hx509_pem_write(a1, "CERTIFICATE", 0, *(FILE **)a2, (uint64_t)v12, v11);
      free(v12);
      if (!sub_2096BFDDC(a3))
        return v6;
      v9 = _hx509_cert_private_key(a3);
      if (sub_2096C58F8(a1, v9))
        return v6;
      v10 = (const char *)sub_2096C57F0(v9);
      hx509_pem_write(a1, v10, 0, *(FILE **)a2, (uint64_t)v12, v11);
    }
    free(v12);
  }
  return v6;
}

uint64_t sub_2096C9D14(uint64_t a1, uint64_t a2, _QWORD *a3, unsigned int a4, const char *a5, void *a6)
{
  return sub_2096C9814(a1, a3, a4, a5, a6, 1);
}

uint64_t sub_2096C9D2C()
{
  return 1;
}

uint64_t sub_2096C9D34(int a1, const UInt8 *a2, void *a3, uint64_t a4, int a5)
{
  uint64_t v9;
  unint64_t v10;
  __SecKey *v11;
  const __CFData *v12;
  const __CFData *DecryptedData;
  const __CFData *v14;
  unint64_t Length;
  size_t v16;
  const UInt8 *BytePtr;

  v9 = sub_2096D5548(a4);
  if (a5 != 1)
    return 0xFFFFFFFFLL;
  v10 = *(_QWORD *)(v9 + 8);
  v11 = (__SecKey *)sub_2096C9E34(*(_QWORD *)v9, *(const void **)(v9 + 16));
  v12 = CFDataCreate((CFAllocatorRef)*MEMORY[0x24BDBD240], a2, a1);
  DecryptedData = SecKeyCreateDecryptedData(v11, (SecKeyAlgorithm)*MEMORY[0x24BDE9328], v12, 0);
  v14 = DecryptedData;
  if (DecryptedData)
  {
    Length = CFDataGetLength(DecryptedData);
    if (Length <= v10)
    {
      v16 = Length;
      BytePtr = CFDataGetBytePtr(v14);
      memcpy(a3, BytePtr, v16);
      if (!v11)
        goto LABEL_6;
      goto LABEL_5;
    }
  }
  v16 = 0xFFFFFFFFLL;
  if (v11)
LABEL_5:
    CFRelease(v11);
LABEL_6:
  if (v12)
    CFRelease(v12);
  if (v14)
    CFRelease(v14);
  return v16;
}

uint64_t sub_2096C9E34(uint64_t a1, const void *a2)
{
  uint64_t Duplicate;
  CFTypeID v4;

  Duplicate = SecKeyCreateDuplicate();
  if (!a2 || (v4 = CFGetTypeID(a2), v4 != CFBooleanGetTypeID()) || !CFBooleanGetValue((CFBooleanRef)a2))
    SecKeySetParameter();
  return Duplicate;
}

uint64_t sub_2096C9EC8()
{
  return 0xFFFFFFFFLL;
}

uint64_t sub_2096C9ED0()
{
  return 0xFFFFFFFFLL;
}

uint64_t sub_2096C9ED8()
{
  return 1;
}

uint64_t sub_2096C9EE0()
{
  return 1;
}

uint64_t sub_2096C9EE8(uint64_t a1)
{
  CFTypeRef *v1;
  CFTypeRef *v2;
  CFTypeRef v3;

  v1 = (CFTypeRef *)sub_2096D6DD0(a1);
  if (v1)
  {
    v2 = v1;
    CFRelease(*v1);
    v3 = v2[2];
    if (v3)
      CFRelease(v3);
    free(v2);
  }
  return 1;
}

uint64_t sub_2096C9F2C(uint64_t a1, const UInt8 *a2, unsigned int a3, void *a4, _DWORD *a5, uint64_t a6)
{
  uint64_t *v10;
  const void *v11;
  unint64_t v12;
  uint64_t v13;
  const __CFString *v14;
  __SecKey *v15;
  const __CFData *v16;
  const __CFData *v17;
  const __CFData *v18;
  unint64_t Length;
  uint64_t v20;
  size_t v22;
  const UInt8 *BytePtr;
  CFErrorRef error;

  v10 = (uint64_t *)sub_2096D6DD0(a6);
  v12 = v10[1];
  v11 = (const void *)v10[2];
  v13 = *v10;
  error = 0;
  v14 = (const __CFString *)*MEMORY[0x24BDE9298];
  v15 = (__SecKey *)sub_2096C9E34(v13, v11);
  v16 = CFDataCreate((CFAllocatorRef)*MEMORY[0x24BDBD240], a2, a3);
  v17 = SecKeyCreateSignature(v15, v14, v16, &error);
  v18 = v17;
  if (!v17 || (Length = CFDataGetLength(v17), Length > v12))
  {
    v20 = 0xFFFFFFFFLL;
    if (!v15)
      goto LABEL_5;
    goto LABEL_4;
  }
  v22 = Length;
  *a5 = Length;
  BytePtr = CFDataGetBytePtr(v18);
  memcpy(a4, BytePtr, v22);
  v20 = 1;
  if (v15)
LABEL_4:
    CFRelease(v15);
LABEL_5:
  if (v16)
    CFRelease(v16);
  if (v18)
    CFRelease(v18);
  if (error)
    CFRelease(error);
  return v20;
}

uint64_t sub_2096CA04C(uint64_t a1, uint64_t a2, _QWORD *a3, uint64_t a4, _BYTE *a5)
{
  void *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char v15;

  v8 = malloc_type_calloc(1uLL, 4uLL, 0x100004052888210uLL);
  if (v8)
  {
    if (a5 && *a5)
    {
      free(v8);
      v15 = (char)a5;
      v9 = 2;
      hx509_set_error_string(a1, 0, 2, "Unknown subtype %s", v10, v11, v12, v13, v15);
    }
    else
    {
      v9 = 0;
      *a3 = v8;
    }
  }
  else
  {
    hx509_clear_error_string(a1);
    return 12;
  }
  return v9;
}

uint64_t sub_2096CA0F0(int a1, _DWORD *a2)
{
  if (a2)
  {
    *a2 = 0;
    free(a2);
  }
  return 0;
}

uint64_t sub_2096CA114(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int *a4, _QWORD *a5)
{
  uint64_t v5;
  __CFDictionary *Mutable;
  unsigned int v10;
  const void **v11;
  char v12;
  CFDataRef v13;
  OSStatus v14;
  CFTypeID TypeID;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  CFIndex Count;
  CFIndex v24;
  CFIndex v25;
  const void *ValueAtIndex;
  uint64_t v28;
  CFTypeRef result;

  v5 = 569873;
  v28 = 0;
  result = 0;
  if ((*a4 & 0x1000040) == 0)
    return 569967;
  Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
  v10 = *a4;
  if ((~*a4 & 0x40040) == 0 && !strcmp(*((const char **)a4 + 9), "O=System Identity,CN=com.apple.kerberos.kdc"))
  {
    v12 = 0;
    *a4 = v10 & 0xFFFFFFBF;
    v11 = (const void **)MEMORY[0x24BDE9228];
  }
  else
  {
    v11 = (const void **)MEMORY[0x24BDE9228];
    if ((v10 & 0x1000000) == 0)
      v11 = (const void **)MEMORY[0x24BDE9238];
    v12 = 1;
  }
  CFDictionaryAddValue(Mutable, (const void *)*MEMORY[0x24BDE9220], *v11);
  CFDictionaryAddValue(Mutable, (const void *)*MEMORY[0x24BDE94D8], (const void *)*MEMORY[0x24BDBD270]);
  CFDictionaryAddValue(Mutable, (const void *)*MEMORY[0x24BDE93B0], (const void *)*MEMORY[0x24BDE93B8]);
  if ((*((_BYTE *)a4 + 3) & 1) != 0)
  {
    v13 = CFDataCreateWithBytesNoCopy(0, *(const UInt8 **)(*((_QWORD *)a4 + 16) + 8), **((_QWORD **)a4 + 16), (CFAllocatorRef)*MEMORY[0x24BDBD258]);
    CFDictionaryAddValue(Mutable, (const void *)*MEMORY[0x24BDE9558], v13);
    CFRelease(v13);
  }
  v14 = SecItemCopyMatching(Mutable, &result);
  CFRelease(Mutable);
  if (v14 || !result)
    goto LABEL_22;
  TypeID = CFArrayGetTypeID();
  if (TypeID != CFGetTypeID(result))
    heim_abort("return value not an array:CFArrayGetTypeID() == CFGetTypeID(identities)", v16, v17, v18, v19, v20, v21, v22, v28);
  Count = CFArrayGetCount((CFArrayRef)result);
  if (Count < 1)
  {
LABEL_18:
    if ((v12 & 1) != 0)
      goto LABEL_20;
    goto LABEL_19;
  }
  v24 = Count;
  v25 = 0;
  while (1)
  {
    ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)result, v25);
    if (!hx509_cert_init_SecFrameworkAuth(a1, ValueAtIndex, &v28, 0))
      break;
LABEL_17:
    if (v24 == ++v25)
      goto LABEL_18;
  }
  if (!sub_2096C1788(a1, (int *)a4, v28))
  {
    hx509_cert_free(v28);
    goto LABEL_17;
  }
  *a5 = v28;
  if ((v12 & 1) == 0)
LABEL_19:
    *a4 |= 0x40u;
LABEL_20:
  CFRelease(result);
  if (!*a5)
  {
LABEL_22:
    hx509_clear_error_string(a1);
    return v5;
  }
  return 0;
}

uint64_t sub_2096CA38C(uint64_t a1, uint64_t a2, uint64_t a3, CFTypeRef **a4)
{
  CFTypeRef *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  CFTypeRef *v11;
  void *v12;
  void *v13;
  const __CFDictionary *v14;
  OSStatus v15;
  uint64_t v16;
  char v18;
  void *values[3];
  void *keys[4];

  keys[3] = *(void **)MEMORY[0x24BDAC8D0];
  v6 = (CFTypeRef *)malloc_type_calloc(1uLL, 0x20uLL, 0x10E00401B1F1DBBuLL);
  if (v6)
  {
    v11 = v6;
    v12 = (void *)*MEMORY[0x24BDE94D8];
    keys[0] = *(void **)MEMORY[0x24BDE9220];
    keys[1] = v12;
    keys[2] = *(void **)MEMORY[0x24BDE93B0];
    v13 = (void *)*MEMORY[0x24BDBD270];
    values[0] = *(void **)MEMORY[0x24BDE9228];
    values[1] = v13;
    values[2] = *(void **)MEMORY[0x24BDE93B8];
    v14 = CFDictionaryCreate(0, (const void **)keys, (const void **)values, 3, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
    v15 = SecItemCopyMatching(v14, v11 + 2);
    CFRelease(v14);
    if (v15)
    {
      free(v11);
      return 12;
    }
    else
    {
      v16 = 0;
      *a4 = v11;
    }
  }
  else
  {
    v16 = 12;
    hx509_set_error_string(a1, 0, 12, "out of memory", v7, v8, v9, v10, v18);
  }
  return v16;
}

uint64_t sub_2096CA4E0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5)
{
  CFIndex v9;
  const void *ValueAtIndex;
  unsigned int inited;
  CFIndex v12;
  uint64_t v13;

  if (*(_QWORD *)a4)
    return hx509_certs_next_cert(a1, *(_QWORD *)a4, *(_QWORD *)(a4 + 8), a5);
  *a5 = 0;
  v9 = *(_QWORD *)(a4 + 24);
  if (v9 >= CFArrayGetCount(*(CFArrayRef *)(a4 + 16)))
  {
    inited = 0;
  }
  else
  {
    do
    {
      ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a4 + 16), *(_QWORD *)(a4 + 24));
      inited = hx509_cert_init_SecFrameworkAuth(a1, ValueAtIndex, a5, 0);
      v12 = *(_QWORD *)(a4 + 24) + 1;
      *(_QWORD *)(a4 + 24) = v12;
    }
    while (inited && v12 < CFArrayGetCount(*(CFArrayRef *)(a4 + 16)));
  }
  v13 = *(_QWORD *)(a4 + 24);
  if (v13 == CFArrayGetCount(*(CFArrayRef *)(a4 + 16)))
    return 0;
  else
    return inited;
}

uint64_t sub_2096CA5A8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (*(_QWORD *)a4)
  {
    hx509_certs_end_seq(a1, *(_QWORD *)a4, *(_QWORD *)(a4 + 8));
    hx509_certs_free((const void **)a4);
  }
  else
  {
    CFRelease(*(CFTypeRef *)(a4 + 16));
  }
  *(_OWORD *)a4 = 0u;
  *(_OWORD *)(a4 + 16) = 0u;
  free((void *)a4);
  return 0;
}

_QWORD *sub_2096CA5FC(uint64_t a1)
{
  return sub_209679060(a1, &off_253D3B0A8);
}

uint64_t hx509_cert_init_SecFrameworkAuth(uint64_t a1, CFTypeRef cf, uint64_t *a3, const void *a4)
{
  void *v6;
  CFTypeID v8;
  void *v9;
  uint64_t v10;
  void *v11;
  const __CFDictionary *v12;
  OSStatus v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  OSStatus v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  char v23;
  uint64_t inited;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  const __CFData *v29;
  const __CFData *v30;
  const UInt8 *BytePtr;
  CFIndex Length;
  __SecKey *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  __SecKey *v40;
  const __CFDictionary *v41;
  const void *Value;
  const void *v43;
  int v44;
  uint64_t v45;
  SecKeyRef v46;
  int *v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  SecKeyRef *v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  SecKeyRef *v61;
  _QWORD *v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  void **v71;
  uint64_t v72;
  SecKeyRef v73;
  SecKeyRef *v74;
  SecKeyRef *v75;
  _QWORD *v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  char v85;
  uint64_t v86;
  SecKeyRef privateKeyRef;
  CFTypeRef result;
  SecCertificateRef certificateRef[2];
  void *values[4];
  void *keys[2];
  _OWORD v92[2];
  uint64_t v93;

  v6 = (void *)cf;
  v93 = *MEMORY[0x24BDAC8D0];
  v8 = CFGetTypeID(cf);
  privateKeyRef = 0;
  result = 0;
  if (a3)
    *a3 = 0;
  certificateRef[0] = 0;
  v86 = 0;
  if (CFDataGetTypeID() == v8)
  {
    v9 = (void *)*MEMORY[0x24BDE94D8];
    keys[0] = *(void **)MEMORY[0x24BDE9220];
    keys[1] = v9;
    v10 = *MEMORY[0x24BDE9558];
    *(_QWORD *)&v92[0] = *MEMORY[0x24BDE93B0];
    *((_QWORD *)&v92[0] + 1) = v10;
    v11 = (void *)*MEMORY[0x24BDBD270];
    values[0] = *(void **)MEMORY[0x24BDE9238];
    values[1] = v11;
    values[2] = *(void **)MEMORY[0x24BDE93C0];
    values[3] = v6;
    v12 = CFDictionaryCreate(0, (const void **)keys, (const void **)values, 4, MEMORY[0x24BDBD6A0], MEMORY[0x24BDBD6B0]);
    v13 = SecItemCopyMatching(v12, &result);
    CFRelease(v12);
    if (v13 || !result)
    {
      inited = 569969;
      hx509_set_error_string(a1, 0, 569969, "Failed to turn persistent reference into a certifiate: %d", v14, v15, v16, v17, v13);
      return inited;
    }
    v8 = CFGetTypeID(result);
    v6 = (void *)result;
  }
  if (SecIdentityGetTypeID() == v8)
  {
    v18 = SecIdentityCopyCertificate((SecIdentityRef)v6, certificateRef);
    if (v18)
    {
      v23 = v18;
      if (result)
        CFRelease(result);
      inited = 569969;
      hx509_set_error_string(a1, 0, 569969, "Failed to convert the identity to a certificate: %d", v19, v20, v21, v22, v23);
      return inited;
    }
  }
  else
  {
    if (SecCertificateGetTypeID() != v8)
    {
      if (result)
        CFRelease(result);
      inited = 569969;
      hx509_set_error_string(a1, 0, 569969, "Data from persistent ref not a identity or certificate", v25, v26, v27, v28, v85);
      return inited;
    }
    certificateRef[0] = (SecCertificateRef)v6;
    CFRetain(v6);
  }
  v29 = SecCertificateCopyData(certificateRef[0]);
  if (v29)
  {
    v30 = v29;
    BytePtr = CFDataGetBytePtr(v29);
    Length = CFDataGetLength(v30);
    inited = hx509_cert_init_data(a1, (uint64_t)BytePtr, Length, (CFTypeRef *)&v86);
    CFRelease(v30);
    if ((_DWORD)inited)
    {
      if (result)
        CFRelease(result);
      CFRelease(certificateRef[0]);
      return inited;
    }
    if (SecIdentityGetTypeID() == v8)
      SecIdentityCopyPrivateKey((SecIdentityRef)v6, &privateKeyRef);
    if (!privateKeyRef)
      goto LABEL_55;
    v34 = SecCertificateCopyKey(certificateRef[0]);
    if (v34)
    {
      v40 = v34;
      v41 = SecKeyCopyAttributes(v34);
      CFRelease(v40);
      if (v41)
      {
        Value = CFDictionaryGetValue(v41, (const void *)*MEMORY[0x24BDE9050]);
        if (Value)
        {
          v43 = Value;
          CFRetain(Value);
          CFRelease(v41);
          v44 = CFEqual(v43, (CFTypeRef)*MEMORY[0x24BDE9060]);
          CFRelease(v43);
          if (v44)
          {
            v45 = v86;
            v46 = privateKeyRef;
            hx509_set_error_string(a1, 0, 12, "kc4", v36, v37, v38, v39, v85);
            v47 = (int *)sub_2096C4C20();
            if (!v47)
            {
              hx509_clear_error_string(a1);
              goto LABEL_54;
            }
            keys[0] = 0;
            if (!sub_2096C5408((uint64_t)keys, v47, 0, v48, v49, v50, v51, v52))
            {
              v53 = (SecKeyRef *)malloc_type_calloc(1uLL, 0x18uLL, 0x10E004027590099uLL);
              if (v53)
              {
                v61 = v53;
                CFRetain(v46);
                *v61 = v46;
                v61[1] = (SecKeyRef)72;
                if (a4)
                {
                  CFRetain(a4);
                  v61[2] = (SecKeyRef)a4;
                }
                v62 = sub_2096D6C38();
                if (v62)
                {
                  v63 = (uint64_t)v62;
                  sub_2096D6D74((uint64_t)v62, (uint64_t)&off_24C1F10A0);
                  if (sub_2096D6DC4(v63, (uint64_t)v61) != 1)
                    sub_2096C1D6C("ECDSA_set_app_data", v64, v65, v66, v67, v68, v69, v70, v85);
                  sub_2096BEAC8(v45);
                  sub_2096C5848((uint64_t)keys[0], v63);
                  _hx509_cert_set_key(v45, (uint64_t)keys[0]);
                  v71 = keys;
                  goto LABEL_52;
                }
              }
LABEL_59:
              sub_2096C1D6C("out of memory", v54, v55, v56, v57, v58, v59, v60, v85);
            }
            goto LABEL_54;
          }
        }
        else
        {
          CFRelease(v41);
        }
      }
    }
    v72 = v86;
    v73 = privateKeyRef;
    memset(v92, 0, sizeof(v92));
    *(_OWORD *)keys = 0u;
    certificateRef[1] = 0;
    values[0] = 0;
    if (!sub_2096C5408((uint64_t)values, 0, 0, v35, v36, v37, v38, v39))
    {
      v74 = (SecKeyRef *)malloc_type_calloc(1uLL, 0x18uLL, 0x10E004027590099uLL);
      if (!v74)
        goto LABEL_59;
      v75 = v74;
      CFRetain(v73);
      *v75 = v73;
      if (a4)
      {
        CFRetain(a4);
        v75[2] = (SecKeyRef)a4;
      }
      v76 = sub_2096D5344();
      if (!v76)
        goto LABEL_59;
      v77 = (uint64_t)v76;
      sub_2096D54EC((uint64_t)v76, (uint64_t)&off_24C1F10F0);
      if (sub_2096D553C(v77, (uint64_t)v75) != 1)
        sub_2096C1D6C("RSA_set_app_data", v78, v79, v80, v81, v82, v83, v84, v85);
      sub_2096BEAC8(v72);
      if (!sub_2096D2888())
      {
        *(_QWORD *)(v77 + 32) = sub_2096C4BE4((const void **)keys);
        *(_QWORD *)(v77 + 40) = sub_2096C4BE4((const void **)v92 + 1);
        sub_2096D28D8();
        v75[1] = (SecKeyRef)(int)sub_2096D41F8(*(unsigned int **)(v77 + 32));
        sub_2096C57FC((uint64_t)values[0], v77);
        _hx509_cert_set_key(v72, (uint64_t)values[0]);
        v71 = values;
LABEL_52:
        hx509_private_key_free((const void **)v71);
        goto LABEL_54;
      }
      sub_2096D540C((_DWORD *)v77);
    }
LABEL_54:
    CFRelease(privateKeyRef);
LABEL_55:
    sub_2096BED70(v86, (uint64_t)sub_2096CAB78, (uint64_t)certificateRef[0]);
    if (result)
      CFRelease(result);
    inited = 0;
    if (a3)
      *a3 = v86;
    return inited;
  }
  if (result)
    CFRelease(result);
  CFRelease(certificateRef[0]);
  return 12;
}

void sub_2096CAB78(int a1, CFTypeRef cf)
{
  CFRelease(cf);
}

uint64_t hx509_cert_init_SecFramework(uint64_t a1, const void *a2, uint64_t *a3)
{
  return hx509_cert_init_SecFrameworkAuth(a1, a2, a3, 0);
}

uint64_t sub_2096CAB88()
{
  return 0xFFFFFFFFLL;
}

uint64_t sub_2096CAB90()
{
  return 0xFFFFFFFFLL;
}

uint64_t sub_2096CAB98(int a1, const UInt8 *a2, void *a3, uint64_t a4, int a5)
{
  uint64_t v9;
  unint64_t v10;
  __SecKey *v11;
  const __CFData *v12;
  const __CFData *Signature;
  const __CFData *v14;
  unint64_t Length;
  size_t v16;
  const UInt8 *BytePtr;

  v9 = sub_2096D5548(a4);
  if (a5 != 1)
    return 0xFFFFFFFFLL;
  v10 = *(_QWORD *)(v9 + 8);
  v11 = (__SecKey *)sub_2096C9E34(*(_QWORD *)v9, *(const void **)(v9 + 16));
  v12 = CFDataCreate((CFAllocatorRef)*MEMORY[0x24BDBD240], a2, a1);
  Signature = SecKeyCreateSignature(v11, (SecKeyAlgorithm)*MEMORY[0x24BDE9370], v12, 0);
  v14 = Signature;
  if (Signature)
  {
    Length = CFDataGetLength(Signature);
    if (Length <= v10)
    {
      v16 = Length;
      BytePtr = CFDataGetBytePtr(v14);
      memcpy(a3, BytePtr, v16);
      if (!v11)
        goto LABEL_6;
      goto LABEL_5;
    }
  }
  v16 = 0xFFFFFFFFLL;
  if (v11)
LABEL_5:
    CFRelease(v11);
LABEL_6:
  if (v12)
    CFRelease(v12);
  if (v14)
    CFRelease(v14);
  return v16;
}

uint64_t sub_2096CAC98()
{
  return 1;
}

uint64_t sub_2096CACA0(uint64_t a1)
{
  CFTypeRef *v1;
  CFTypeRef *v2;
  CFTypeRef v3;

  v1 = (CFTypeRef *)sub_2096D5548(a1);
  if (v1)
  {
    v2 = v1;
    CFRelease(*v1);
    v3 = v2[2];
    if (v3)
      CFRelease(v3);
    free(v2);
  }
  return 1;
}

uint64_t sub_2096CACE4(int a1, const UInt8 *a2, unsigned int a3, void *a4, _DWORD *a5, uint64_t a6)
{
  uint64_t v11;
  int v12;
  uint64_t v13;
  unint64_t v15;
  const __CFString *v16;
  __SecKey *v17;
  const __CFData *v18;
  const __CFData *Signature;
  const __CFData *v20;
  unint64_t Length;
  size_t v22;
  const UInt8 *BytePtr;

  v11 = sub_2096D5548(a6);
  v12 = a1 - 2;
  if ((a1 - 2) > 5 || ((0x3Du >> v12) & 1) == 0)
    return 0xFFFFFFFFLL;
  v15 = *(_QWORD *)(v11 + 8);
  v16 = (const __CFString *)**((_QWORD **)&unk_24C1F66D0 + v12);
  v17 = (__SecKey *)sub_2096C9E34(*(_QWORD *)v11, *(const void **)(v11 + 16));
  v18 = CFDataCreate((CFAllocatorRef)*MEMORY[0x24BDBD240], a2, a3);
  Signature = SecKeyCreateSignature(v17, v16, v18, 0);
  v20 = Signature;
  if (Signature)
  {
    Length = CFDataGetLength(Signature);
    if (Length <= v15)
    {
      v22 = Length;
      *a5 = Length;
      BytePtr = CFDataGetBytePtr(v20);
      memcpy(a4, BytePtr, v22);
      v13 = 1;
      if (!v17)
        goto LABEL_9;
      goto LABEL_8;
    }
  }
  v13 = 0xFFFFFFFFLL;
  if (v17)
LABEL_8:
    CFRelease(v17);
LABEL_9:
  if (v18)
    CFRelease(v18);
  if (v20)
    CFRelease(v20);
  return v13;
}

_QWORD *sub_2096CAE14(uint64_t a1)
{
  return sub_209679060(a1, &off_253D3B110);
}

uint64_t sub_2096CAE20(uint64_t a1, uint64_t a2, char ***a3, uint64_t a4, const char *a5)
{
  char **v7;
  char **v8;
  char *v9;
  uint64_t result;

  v7 = (char **)malloc_type_calloc(1uLL, 0x20uLL, 0x10900401DE5F086uLL);
  if (v7)
  {
    v8 = v7;
    if (!a5 || !*a5)
      a5 = "anonymous";
    v9 = strdup(a5);
    *v8 = v9;
    if (v9)
    {
      result = 0;
      *a3 = v8;
      return result;
    }
    free(v8);
  }
  return 12;
}

uint64_t sub_2096CAEA8(uint64_t a1, uint64_t a2)
{
  unint64_t v3;
  char *v4;
  uint64_t v5;

  if (*(_QWORD *)(a2 + 8))
  {
    v3 = 0;
    do
      hx509_cert_free(*(_QWORD *)(*(_QWORD *)(a2 + 16) + 8 * v3++));
    while (v3 < *(_QWORD *)(a2 + 8));
  }
  free(*(void **)(a2 + 16));
  v4 = *(char **)(a2 + 24);
  if (v4)
  {
    v5 = 0;
    do
    {
      if (!*(_QWORD *)&v4[v5])
        break;
      hx509_private_key_free((const void **)&v4[v5]);
      v4 = *(char **)(a2 + 24);
      v5 += 8;
    }
    while (v4);
  }
  free(v4);
  free(*(void **)a2);
  free((void *)a2);
  return 0;
}

uint64_t sub_2096CAF38(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  void *v6;
  uint64_t v7;
  uint64_t result;
  uint64_t v9;

  v6 = malloc_type_realloc(*(void **)(a3 + 16), 8 * *(_QWORD *)(a3 + 8) + 8, 0x2004093837F09uLL);
  if (!v6)
    return 12;
  *(_QWORD *)(a3 + 16) = v6;
  v7 = hx509_cert_ref(a4);
  result = 0;
  v9 = *(_QWORD *)(a3 + 8);
  *(_QWORD *)(*(_QWORD *)(a3 + 16) + 8 * v9) = v7;
  *(_QWORD *)(a3 + 8) = v9 + 1;
  return result;
}

uint64_t sub_2096CAFA8(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD *a4)
{
  _QWORD *v5;
  _QWORD *v6;
  uint64_t result;

  v5 = malloc_type_malloc(8uLL, 0x100004000313F17uLL);
  if (!v5)
    return 12;
  v6 = v5;
  result = 0;
  *v6 = 0;
  *a4 = v6;
  return result;
}

uint64_t sub_2096CAFF8(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD *a4, uint64_t *a5)
{
  uint64_t v7;

  if (*a4 >= *(_QWORD *)(a3 + 8))
  {
    v7 = 0;
  }
  else
  {
    v7 = hx509_cert_ref(*(_QWORD *)(*(_QWORD *)(a3 + 16) + 8 * *a4));
    ++*a4;
  }
  *a5 = v7;
  return 0;
}

uint64_t sub_2096CB050(int a1, int a2, int a3, void *a4)
{
  free(a4);
  return 0;
}

uint64_t sub_2096CB06C(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD *a4)
{
  uint64_t v7;
  uint64_t v8;
  size_t v10;
  _QWORD *v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v22;
  char v23;

  v7 = *(_QWORD *)(a3 + 24);
  if (v7)
  {
    v8 = 0;
    while (*(_QWORD *)(v7 + 8 * v8++))
      ;
    v10 = v8;
  }
  else
  {
    v10 = 1;
  }
  v11 = malloc_type_calloc(v10, 8uLL, 0x2004093837F09uLL);
  *a4 = v11;
  v12 = *(_QWORD *)(a3 + 24);
  if (v12 && (v12 = *(_QWORD *)v12) != 0)
  {
    v13 = 0;
    while (1)
    {
      v14 = v13;
      *(_QWORD *)(*a4 + 8 * v13) = _hx509_private_key_ref(v12);
      v11 = (_QWORD *)*a4;
      if (!*(_QWORD *)(*a4 + 8 * v14))
        break;
      v19 = *(_QWORD *)(a3 + 24);
      if (v19)
      {
        v12 = *(_QWORD *)(v19 + 8 * v14 + 8);
        v13 = v14 + 1;
        if (v12)
          continue;
      }
      v12 = (v14 + 1);
      goto LABEL_13;
    }
    if ((_DWORD)v14)
    {
      v22 = v14 + 1;
      do
        hx509_private_key_free((const void **)(*a4 + 8 * (v22-- - 2)));
      while (v22 > 1);
    }
    v20 = 12;
    hx509_set_error_string(a1, 0, 12, "out of memory", v15, v16, v17, v18, v23);
  }
  else
  {
LABEL_13:
    v20 = 0;
    v11[v12] = 0;
  }
  return v20;
}

uint64_t sub_2096CB178(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  void *v7;
  unsigned int v8;
  uint64_t *v9;
  uint64_t v10;
  void *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  char v19;

  v7 = *(void **)(a3 + 24);
  if (v7)
  {
    v8 = -1;
    v9 = *(uint64_t **)(a3 + 24);
    do
    {
      v10 = *v9++;
      ++v8;
    }
    while (v10);
  }
  else
  {
    v8 = 0;
  }
  v11 = malloc_type_realloc(v7, 8 * (v8 + 2), 0x2004093837F09uLL);
  if (v11)
  {
    *(_QWORD *)(a3 + 24) = v11;
    v16 = _hx509_private_key_ref(a4);
    v17 = 0;
    *(_QWORD *)(*(_QWORD *)(a3 + 24) + 8 * v8) = v16;
    *(_QWORD *)(*(_QWORD *)(a3 + 24) + 8 * (v8 + 1)) = 0;
  }
  else
  {
    v17 = 12;
    hx509_set_error_string(a1, 0, 12, "out of memory", v12, v13, v14, v15, v19);
  }
  return v17;
}

uint64_t sub_2096CB230(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int *a5)
{
  unsigned int *v7;
  uint64_t v8;
  uint64_t v9;
  _OWORD v11[2];
  __int128 v12;
  uint64_t v13;

  v13 = 0;
  v12 = 0u;
  memset(v11, 0, sizeof(v11));
  v7 = sub_2096CB700(a5);
  v8 = sub_2096BC5C8();
  if (!(_DWORD)v8)
  {
    if (v7)
      v9 = (uint64_t)(v7 + 4);
    else
      v9 = 0;
    sub_2096C4664(a1, a2, (uint64_t)v11 + 8, 0, (uint64_t *)&v12, v9);
    sub_2096BC618();
  }
  return v8;
}

uint64_t sub_2096CB2E4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int *a5)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v14;
  uint64_t v15;
  __int128 v16;
  __int128 v17;
  uint64_t v18;

  v14 = 0;
  v15 = 0;
  v16 = 0u;
  v17 = 0u;
  v18 = 0;
  v8 = sub_2096BC628();
  if (!(_DWORD)v8)
  {
    v9 = sub_2096C4654(a2);
    v8 = sub_2096C6168(a1, v9, (uint64_t)&v16, (uint64_t)&v17 + 8, &v14, v10, v11, v12);
    sub_2096BC648();
    if (!(_DWORD)v8)
    {
      v8 = sub_2096CB230(a1, a2, v15, v14, a5);
      der_free_octet_string();
    }
  }
  return v8;
}

uint64_t sub_2096CB3A8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int *a5)
{
  uint64_t inited;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  char v16;
  char v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;

  v19 = 0;
  v20 = 0;
  v18 = 0;
  inited = sub_2096BC778();
  if (!(_DWORD)inited)
  {
    if (der_heim_oid_cmp())
    {
      sub_2096BC7C8();
      return 0;
    }
    inited = sub_2096BC7D8();
    sub_2096BC7C8();
    if (!(_DWORD)inited)
    {
      inited = hx509_cert_init_data(a1, v20, v19, (CFTypeRef *)&v18);
      der_free_octet_string();
      if (!(_DWORD)inited)
      {
        v14 = sub_2096C465C(a1, a2, v18, v9, v10, v11, v12, v13);
        if ((_DWORD)v14)
        {
          inited = v14;
          hx509_cert_free(v18);
          return inited;
        }
        v16 = 1;
        do
        {
          v17 = v16;
          if (sub_2096CB700(a5))
            sub_2096C10F0(a1, v18);
          v16 = 0;
        }
        while ((v17 & 1) != 0);
        hx509_cert_free(v18);
        return 0;
      }
    }
  }
  return inited;
}

uint64_t sub_2096CB4F0()
{
  uint64_t v0;

  v0 = sub_2096BC7D8();
  if (!(_DWORD)v0)
  {
    v0 = sub_2096CB774();
    der_free_octet_string();
  }
  return v0;
}

uint64_t sub_2096CB564(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7;
  uint64_t v8;
  _QWORD v10[2];
  _QWORD v11[2];

  v11[0] = 0;
  v11[1] = 0;
  v10[0] = 0;
  v10[1] = 0;
  v7 = sub_2096C4654(a2);
  v8 = hx509_cms_decrypt_encrypted(a1, v7, a3, a4, (uint64_t)v10, v11);
  if (!(_DWORD)v8)
  {
    if (der_heim_oid_cmp())
      v8 = 0;
    else
      v8 = sub_2096CB774();
    der_free_octet_string();
    der_free_oid();
  }
  return v8;
}

uint64_t sub_2096CB614(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  char v16;
  _QWORD v17[2];
  size_t v18[2];

  v18[0] = 0;
  v18[1] = 0;
  v17[0] = 0;
  v17[1] = 0;
  v7 = sub_2096C4654(a2);
  v8 = sub_2096BEEE4(v7);
  v9 = hx509_cms_unenvelope(a1, v8, 0, a3, a4, 0, 0, v17, v18);
  if ((_DWORD)v9)
  {
    v14 = v9;
    hx509_set_error_string(a1, 1, v9, "PKCS12 failed to unenvelope", v10, v11, v12, v13, v16);
  }
  else
  {
    if (der_heim_oid_cmp())
      v14 = 0;
    else
      v14 = sub_2096CB774();
    der_free_octet_string();
    der_free_oid();
  }
  return v14;
}

_QWORD *sub_2096CB6F4(uint64_t a1)
{
  return sub_209679060(a1, &off_253D3B1E0);
}

unsigned int *sub_2096CB700(unsigned int *result)
{
  unsigned int *v1;
  uint64_t v2;
  unint64_t v3;

  if (result)
  {
    v1 = result;
    if (*result)
    {
      v2 = 0;
      v3 = 0;
      while (der_heim_oid_cmp())
      {
        ++v3;
        v2 += 32;
        if (v3 >= *v1)
          return 0;
      }
      return (unsigned int *)(*((_QWORD *)v1 + 1) + v2);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t sub_2096CB774()
{
  uint64_t result;

  result = sub_2096BC748();
  if (!(_DWORD)result)
  {
    sub_2096BC768();
    return 0;
  }
  return result;
}

uint64_t sub_2096CB810(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t i;
  uint64_t result;

  for (i = 0; i != 96; i += 16)
  {
    result = der_heim_oid_cmp();
    if (!(_DWORD)result)
      result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((char *)&off_253D3AAF8 + i + 8))(a1, a2, a4, a5, a6);
  }
  return result;
}

uint64_t sub_2096CB8A0(uint64_t a1, uint64_t a2, uint64_t **a3, char a4, const char *a5, void *a6)
{
  void *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t *v16;
  char *v17;
  uint64_t v18;
  const char *v19;
  uint64_t v20;
  int v21;
  void *v22;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t v30;
  char v31;
  void *v32;
  uint64_t v33;
  uint64_t v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  uint64_t v38;
  void *v39;
  off_t v40;

  v39 = 0;
  v40 = 0;
  v38 = 0;
  v36 = 0u;
  v37 = 0u;
  v35 = 0u;
  v33 = 0;
  v34 = 0;
  v32 = 0;
  *a3 = 0;
  if (a6)
    v10 = a6;
  else
    v10 = off_2545A70A8;
  v11 = sub_2096C4564(a1, (uint64_t)v10, &v32);
  if ((_DWORD)v11)
    return v11;
  v16 = (uint64_t *)malloc_type_calloc(1uLL, 0x10uLL, 0x30040E4270A41uLL);
  if (!v16 || (v17 = strdup(a5), (v16[1] = (uint64_t)v17) == 0))
  {
    v19 = "out of memory";
    v11 = 12;
    v20 = a1;
    v21 = 12;
LABEL_12:
    hx509_set_error_string(v20, 0, v21, v19, v12, v13, v14, v15, v31);
    goto LABEL_13;
  }
  if ((a4 & 1) != 0)
  {
    v24 = hx509_certs_init(a1, "MEMORY:ks-file-create", 0, (uint64_t)v10, v16);
    goto LABEL_22;
  }
  v18 = rk_undumpdata(a5, &v39, &v40);
  if (!(_DWORD)v18)
  {
    v11 = sub_2096BC688();
    j__free(v39);
    if ((_DWORD)v11)
    {
      hx509_set_error_string(a1, 0, v11, "Failed to decode the PFX in %s", v25, v26, v27, v28, (char)a5);
      goto LABEL_13;
    }
    if (der_heim_oid_cmp())
    {
      sub_2096BC6D8();
      v19 = "PKCS PFX isn't a pkcs7-data container";
LABEL_28:
      v11 = 22;
      v20 = a1;
      v21 = 22;
      goto LABEL_12;
    }
    if (!*((_QWORD *)&v37 + 1))
    {
      sub_2096BC6D8();
      v19 = "PKCS PFX missing data";
      goto LABEL_28;
    }
    v11 = sub_2096BC7D8();
    sub_2096BC6D8();
    if ((_DWORD)v11)
      goto LABEL_10;
    v11 = sub_2096BC6E8();
    der_free_octet_string();
    if ((_DWORD)v11)
      goto LABEL_10;
    if ((_DWORD)v33)
    {
      v29 = 0;
      v30 = 0;
      do
      {
        sub_2096CB810(a1, (uint64_t)v32, v34 + v29, *(_QWORD *)(*(_QWORD *)(v34 + v29 + 16) + 8), **(_QWORD **)(v34 + v29 + 16), 0);
        ++v30;
        v29 += 24;
      }
      while (v30 < v33);
    }
    sub_2096BC738();
    v24 = sub_2096C4808(a1, (uint64_t *)v32, v16);
LABEL_22:
    v11 = v24;
    if (!(_DWORD)v24)
      *a3 = v16;
    goto LABEL_13;
  }
  v11 = v18;
LABEL_10:
  hx509_clear_error_string(a1);
LABEL_13:
  sub_2096C4B74((char *)v32);
  if (v16 && (_DWORD)v11)
  {
    v22 = (void *)v16[1];
    if (v22)
      free(v22);
    if (*v16)
      hx509_certs_free((const void **)v16);
    free(v16);
  }
  return v11;
}

uint64_t sub_2096CBB44(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  void *v10;
  void *v11;
  uint64_t v12;
  uint64_t v14;
  void *v15;
  size_t v16;
  void *v17;
  uint64_t v18;
  size_t v19;
  size_t v20;
  void *v21;
  _QWORD v22[2];
  __int128 v23;
  __int128 v24;
  __int128 v25;
  uint64_t v26;

  v22[0] = 0;
  v22[1] = 0;
  v23 = 0u;
  v24 = 0u;
  v25 = 0u;
  v26 = 0;
  v9 = hx509_certs_iter_f(a1, *(_QWORD *)a3, (uint64_t (*)(uint64_t, uint64_t))sub_2096CBDD4, (uint64_t)v22, a5, a6, a7, a8);
  if ((_DWORD)v9)
    goto LABEL_2;
  v19 = sub_2096BC728();
  v10 = malloc_type_malloc(v19, 0x9FE18BD6uLL);
  v21 = v10;
  if (!v10)
  {
    v9 = 12;
    goto LABEL_7;
  }
  v11 = v10;
  v12 = sub_2096BC708();
  if ((_DWORD)v12)
  {
    v9 = v12;
    free(v11);
LABEL_7:
    sub_2096BC738();
    return v9;
  }
  sub_2096BC738();
  v14 = der_parse_hex_heim_integer();
  if ((_DWORD)v14)
  {
    v9 = v14;
    v15 = v11;
  }
  else
  {
    *((_QWORD *)&v25 + 1) = malloc_type_calloc(1uLL, 0x10uLL, 0x108004057E67DB5uLL);
    v16 = sub_2096BC818();
    **((_QWORD **)&v25 + 1) = v16;
    v17 = malloc_type_malloc(v16, 0xA91B0023uLL);
    *(_QWORD *)(*((_QWORD *)&v25 + 1) + 8) = v17;
    if (v17)
    {
      v18 = sub_2096BC7F8();
      if ((_DWORD)v18)
      {
        v9 = v18;
        free(*(void **)(*((_QWORD *)&v25 + 1) + 8));
        *(_QWORD *)(*((_QWORD *)&v25 + 1) + 8) = 0;
      }
      else
      {
        free(v21);
        v9 = der_copy_oid();
        if ((_DWORD)v9)
          goto LABEL_2;
        v20 = sub_2096BC6C8();
        v21 = malloc_type_malloc(v20, 0x79E37B29uLL);
        if (!v21)
        {
          v9 = 12;
          goto LABEL_2;
        }
        v9 = sub_2096BC6A8();
        if ((_DWORD)v9)
        {
          free(v21);
          goto LABEL_2;
        }
        rk_dumpdata(*(const char **)(a3 + 8), (char *)v21, v20);
      }
    }
    else
    {
      v9 = 12;
    }
    v15 = v21;
  }
  free(v15);
LABEL_2:
  sub_2096BC738();
  sub_2096BC6D8();
  return v9;
}

uint64_t sub_2096CBD68(uint64_t a1, uint64_t a2)
{
  hx509_certs_free((const void **)a2);
  free(*(void **)(a2 + 8));
  free((void *)a2);
  return 0;
}

uint64_t sub_2096CBDA0(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return hx509_certs_add(a1, *a3, a4, a4, a5, a6, a7, a8);
}

uint64_t sub_2096CBDAC(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return hx509_certs_start_seq(a1, *a3, a4, a4, a5, a6, a7, a8);
}

uint64_t sub_2096CBDB8(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, _QWORD *a5)
{
  return hx509_certs_next_cert(a1, *a3, a4, a5);
}

uint64_t sub_2096CBDC8(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  return hx509_certs_end_seq(a1, *a3, a4);
}

uint64_t sub_2096CBDD4(uint64_t a1, unsigned int *a2, uint64_t a3)
{
  uint64_t v6;
  void *v7;
  void *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  size_t v15;
  uint64_t v16;
  void *v17;

  v16 = 0;
  v17 = 0;
  v6 = hx509_cert_binary(a1, a3, (uint64_t)&v16);
  if (!(_DWORD)v6)
  {
    v15 = sub_2096BC818();
    v7 = malloc_type_malloc(v15, 0x834C70E1uLL);
    if (!v7)
    {
      v6 = 12;
      goto LABEL_6;
    }
    v8 = v7;
    v9 = sub_2096BC7F8();
    if ((_DWORD)v9)
    {
      v6 = v9;
      free(v8);
LABEL_6:
      free(v17);
      return v6;
    }
    free(v17);
    v10 = der_copy_oid();
    if ((_DWORD)v10)
    {
      v6 = v10;
LABEL_9:
      sub_2096BC7C8();
      return v6;
    }
    v16 = sub_2096BC7B8();
    v17 = malloc_type_malloc(v16, 0xED47DADBuLL);
    if (!v17)
    {
      v6 = 12;
      goto LABEL_9;
    }
    v12 = sub_2096BC798();
    if ((_DWORD)v12)
    {
      v6 = v12;
      free(v17);
      v17 = 0;
      goto LABEL_9;
    }
    sub_2096BC7C8();
    v6 = sub_2096CC04C(a1, a2, (uint64_t)&unk_24C1F5400, (uint64_t)v17, v16);
    if (sub_2096BFDDC(a3))
    {
      _hx509_cert_private_key(a3);
      v6 = der_parse_hex_heim_integer();
      if (!(_DWORD)v6)
      {
        v6 = sub_2096C5894(a1);
        if (!(_DWORD)v6)
        {
          v13 = _hx509_cert_private_key(a3);
          v6 = sub_2096C58F8(a1, v13);
          if (!(_DWORD)v6)
          {
            v16 = sub_2096BC608();
            v17 = malloc_type_malloc(v16, 0x58EE68ACuLL);
            if (v17)
            {
              v14 = sub_2096BC5E8();
              if (!(_DWORD)v14)
              {
                sub_2096BC618();
                return sub_2096CC04C(a1, a2, (uint64_t)&unk_24C1F53E0, (uint64_t)v17, v16);
              }
              v6 = v14;
              free(v17);
              v17 = 0;
            }
            else
            {
              v6 = 12;
            }
          }
        }
        sub_2096BC618();
      }
    }
  }
  return v6;
}

uint64_t sub_2096CC04C(uint64_t a1, unsigned int *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  void *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  const char *v16;
  uint64_t v17;
  int v18;
  _QWORD *v19;
  int v20;
  char v22;

  v9 = malloc_type_realloc(*((void **)a2 + 1), 24 * (*a2 + 1), 0x10300406712BA52uLL);
  if (!v9)
  {
    v16 = "out of memory";
LABEL_8:
    v15 = 12;
    v17 = a1;
    v18 = 12;
    goto LABEL_9;
  }
  *((_QWORD *)a2 + 1) = v9;
  v14 = der_copy_oid();
  if ((_DWORD)v14)
  {
    v15 = v14;
    v16 = "out of memory";
    v17 = a1;
    v18 = v15;
LABEL_9:
    hx509_set_error_string(v17, 0, v18, v16, v10, v11, v12, v13, v22);
    return v15;
  }
  v19 = malloc_type_calloc(1uLL, 0x10uLL, 0x108004057E67DB5uLL);
  v20 = *a2;
  *(_QWORD *)(*((_QWORD *)a2 + 1) + 24 * *a2 + 16) = v19;
  if (!v19)
  {
    der_free_oid();
    v16 = "malloc out of memory";
    goto LABEL_8;
  }
  v15 = 0;
  *v19 = a5;
  v19[1] = a4;
  *a2 = v20 + 1;
  return v15;
}

uint64_t hx509_lock_init(uint64_t a1, _QWORD *a2)
{
  void *v4;
  void *v5;
  uint64_t v6;

  *a2 = 0;
  v4 = malloc_type_calloc(1uLL, 0x28uLL, 0x10A00405C9B045DuLL);
  if (!v4)
    return 12;
  v5 = v4;
  v6 = hx509_certs_init(a1, "MEMORY:locks-internal", 0, 0, (_QWORD *)v4 + 2);
  if ((_DWORD)v6)
    free(v5);
  else
    *a2 = v5;
  return v6;
}

uint64_t hx509_lock_add_password(uint64_t *a1, char *__s1)
{
  char *v3;
  char *v4;
  _QWORD *v5;
  _QWORD *v6;
  uint64_t result;
  uint64_t v8;
  uint64_t v9;

  v3 = strdup(__s1);
  if (v3)
  {
    v4 = v3;
    v5 = malloc_type_realloc((void *)a1[1], 8 * *a1 + 8, 0x10040436913F5uLL);
    if (v5)
    {
      v6 = v5;
      result = 0;
      v8 = *a1;
      v9 = *a1 + 1;
      a1[1] = (uint64_t)v6;
      v6[v8] = v4;
      *a1 = v9;
      return result;
    }
    free(v4);
  }
  return 12;
}

void hx509_lock_reset_passwords(uint64_t a1)
{
  unint64_t v2;

  if (*(_QWORD *)a1)
  {
    v2 = 0;
    do
      free(*(void **)(*(_QWORD *)(a1 + 8) + 8 * v2++));
    while (v2 < *(_QWORD *)a1);
  }
  free(*(void **)(a1 + 8));
  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = 0;
}

uint64_t hx509_lock_add_cert(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return hx509_certs_add(a1, *(_QWORD *)(a2 + 16), a3, a4, a5, a6, a7, a8);
}

uint64_t hx509_lock_add_certs(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return hx509_certs_merge(a1, *(_QWORD *)(a2 + 16), a3, a4, a5, a6, a7, a8);
}

void hx509_lock_reset_certs(uint64_t a1, uint64_t a2)
{
  _QWORD *v2;
  const void *v3;
  const void *v4;

  v2 = (_QWORD *)(a2 + 16);
  v3 = *(const void **)(a2 + 16);
  v4 = v3;
  if (hx509_certs_init(a1, "MEMORY:locks-internal", 0, 0, (_QWORD *)(a2 + 16)))
    *v2 = v3;
  else
    hx509_certs_free(&v4);
}

uint64_t hx509_lock_set_prompter(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(a1 + 24) = a2;
  *(_QWORD *)(a1 + 32) = a3;
  return 0;
}

uint64_t hx509_lock_reset_promper(uint64_t result)
{
  *(_QWORD *)(result + 24) = 0;
  *(_QWORD *)(result + 32) = 0;
  return result;
}

uint64_t hx509_lock_prompt(uint64_t a1)
{
  uint64_t (*v1)(_QWORD);

  v1 = *(uint64_t (**)(_QWORD))(a1 + 24);
  if (v1)
    return v1(*(_QWORD *)(a1 + 32));
  else
    return 569927;
}

void hx509_lock_free(const void **a1)
{
  if (a1)
  {
    hx509_certs_free(a1 + 2);
    hx509_lock_reset_passwords((uint64_t)a1);
    a1[4] = 0;
    *(_OWORD *)a1 = 0u;
    *((_OWORD *)a1 + 1) = 0u;
    free(a1);
  }
}

BOOL hx509_prompt_hidden(int a1)
{
  return a1 == 1;
}

uint64_t hx509_lock_command_string(uint64_t *a1, char *a2)
{
  uint64_t result;

  if (!strncasecmp(a2, "PASS:", 5uLL))
  {
    hx509_lock_add_password(a1, a2 + 5);
    return 0;
  }
  else
  {
    result = strcasecmp(a2, "PROMPT");
    if ((_DWORD)result)
    {
      return 569874;
    }
    else
    {
      a1[3] = (uint64_t)sub_2096CC428;
      a1[4] = 0;
    }
  }
  return result;
}

uint64_t sub_2096CC428(uint64_t a1, uint64_t a2)
{
  char *v3;
  FILE **v4;

  v3 = *(char **)(a2 + 24);
  if (*(_DWORD *)(a2 + 8) == 1)
  {
    if (!hc_UI_UTIL_read_pw_string(v3, *(_DWORD *)(a2 + 16), *(const char **)a2, 0))
      return 0;
  }
  else
  {
    v4 = (FILE **)MEMORY[0x24BDAC8E8];
    fputs(*(const char **)a2, (FILE *)*MEMORY[0x24BDAC8E8]);
    fflush(*v4);
    if (fgets(*(char **)(a2 + 24), *(_DWORD *)(a2 + 16), (FILE *)*MEMORY[0x24BDAC8E0]))
    {
      v3[strcspn(v3, "\n")] = 0;
      return 0;
    }
  }
  return 1;
}

uint64_t sub_2096CC4D4(uint64_t a1, void **a2)
{
  char *v4;
  uint64_t v5;
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _DWORD *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  char *v18;
  uint64_t v19;
  char *v20;
  uint64_t v21;
  unsigned int *v22;
  uint64_t v23;
  uint64_t v24;
  char *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  unsigned __int16 *v35;
  uint64_t v36;
  char *v37;
  size_t v38;
  unint64_t v39;
  uint64_t v40;
  char v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  unint64_t v46;

  v45 = 0;
  v4 = strdup("");
  *a2 = v4;
  if (!v4)
    return 12;
  v44 = *(unsigned int *)(a1 + 24);
  if ((_DWORD)v44)
  {
    v43 = a1;
    while (1)
    {
      v5 = *(_QWORD *)(a1 + 32);
      --v44;
      if (*(_DWORD *)(v5 + 16 * v44))
      {
        v6 = 0;
        v7 = 0;
        while (1)
        {
          v8 = 0;
          v9 = *(_QWORD *)(v5 + 16 * v44 + 8);
          v10 = (_DWORD *)(v9 + 40 * v7 + 16);
          do
          {
            if (!der_heim_oid_cmp())
            {
              v18 = strdup((&off_24C1F6710)[v8]);
              goto LABEL_13;
            }
            v8 += 3;
          }
          while (v8 != 39);
          v46 = 0;
          if (der_print_heim_oid())
            v18 = 0;
          else
            v18 = (char *)v46;
LABEL_13:
          switch(*v10)
          {
            case 0:
              sub_2096C1D6C("unknown directory type: %d", v11, v12, v13, v14, v15, v16, v17, 0);
            case 1:
            case 3:
              v19 = v9 + 40 * v7;
              v6 = *(_QWORD *)(v19 + 24);
              v20 = *(char **)(v19 + 32);
              goto LABEL_25;
            case 2:
            case 5:
              v20 = *(char **)(v9 + 40 * v7 + 24);
              v6 = strlen(v20);
              goto LABEL_25;
            case 4:
              v21 = v9 + 40 * v7;
              v23 = *(_QWORD *)(v21 + 24);
              v22 = *(unsigned int **)(v21 + 32);
              v46 = 0;
              v24 = sub_2096BB080(v22, v23, &v46);
              if ((_DWORD)v24)
                return v24;
              v25 = (char *)malloc_type_malloc(++v46, 0x759BA998uLL);
              if (!v25)
                goto LABEL_37;
              v20 = v25;
              v33 = wind_ucs4utf8(v22, v23, v25, &v46);
              if ((_DWORD)v33)
                goto LABEL_35;
              goto LABEL_24;
            case 6:
              v34 = v9 + 40 * v7;
              v36 = *(_QWORD *)(v34 + 24);
              v35 = *(unsigned __int16 **)(v34 + 32);
              v46 = 0;
              v24 = wind_ucs2utf8_length(v35, v36, &v46);
              if ((_DWORD)v24)
                return v24;
              v37 = (char *)malloc_type_malloc(v46 + 1, 0x96120BB7uLL);
              if (!v37)
LABEL_37:
                sub_2096C1D6C("allocation failure", v26, v27, v28, v29, v30, v31, v32, v42);
              v20 = v37;
              v33 = wind_ucs2utf8(v35, v36, v37, &v46);
              if ((_DWORD)v33)
              {
LABEL_35:
                v40 = v33;
                free(v20);
                return v40;
              }
LABEL_24:
              v20[v46] = 0;
              v6 = v46;
              a1 = v43;
LABEL_25:
              v38 = strlen(v18);
              sub_2096CC81C(a2, &v45, v18, v38, 0);
              free(v18);
              sub_2096CC81C(a2, &v45, "=", 1uLL, 0);
              sub_2096CC81C(a2, &v45, v20, v6, 1);
              if ((*v10 | 2) == 6)
                free(v20);
              ++v7;
              v5 = *(_QWORD *)(a1 + 32);
              v39 = *(unsigned int *)(v5 + 16 * v44);
              if (v7 < v39)
              {
                sub_2096CC81C(a2, &v45, "+", 1uLL, 0);
                v5 = *(_QWORD *)(a1 + 32);
                v39 = *(unsigned int *)(v5 + 16 * v44);
              }
              if (v7 >= v39)
                goto LABEL_30;
              break;
            default:
              v20 = 0;
              goto LABEL_25;
          }
        }
      }
LABEL_30:
      if (!v44)
        break;
      sub_2096CC81C(a2, &v45, ",", 1uLL, 0);
    }
  }
  return 0;
}

void sub_2096CC81C(void **a1, _QWORD *a2, _BYTE *a3, size_t a4, int a5)
{
  size_t v5;
  _BYTE *v9;
  size_t v10;
  uint64_t v11;
  uint64_t v12;
  _BYTE *v13;
  uint64_t v14;
  char *v15;
  uint64_t v16;
  _BYTE *v17;
  char *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  _BYTE *v26;
  char v27;
  unint64_t v28;

  v5 = a4;
  if (a5)
  {
    v9 = malloc_type_malloc(3 * a4 + 1, 0x763C70C3uLL);
    if (v9)
    {
      v28 = 3 * v5 + 1;
      v10 = 0;
      if (v5)
      {
        v11 = 0;
        do
        {
          v12 = a3[v11];
          if (v11 || (byte_2545A70B0[v12] & 4) == 0)
          {
            v14 = v11 + 1;
            if (v11 + 1 == v5 && (byte_2545A70B0[v12] & 8) != 0)
            {
              v17 = &v9[v10];
              *v17 = 92;
              v10 += 2;
              v17[1] = a3[v11];
              break;
            }
            v15 = &v9[v10];
            if ((byte_2545A70B0[v12] & 0x10) == 0)
            {
              if ((byte_2545A70B0[v12] & 0x20) != 0)
              {
                v16 = snprintf(v15, 3 * v5 - v10, "#%02x", a3[v11]);
              }
              else
              {
                *v15 = v12;
                v16 = 1;
              }
              goto LABEL_15;
            }
            *v15 = 92;
            v15[1] = a3[v11];
          }
          else
          {
            v13 = &v9[v10];
            *v13 = 92;
            v13[1] = *a3;
            v14 = 1;
          }
          v16 = 2;
LABEL_15:
          v10 += v16;
          v11 = v14;
        }
        while (v14 != v5);
      }
      v9[v10] = 0;
      v5 = v10;
      if (v10 >= v28)
        sub_2096D7EA4();
    }
  }
  else
  {
    v9 = a3;
  }
  v18 = (char *)malloc_type_realloc(*a1, v5 + *a2 + 1, 0x753CB74uLL);
  if (!v18)
    sub_2096C1D6C("allocation failure", v19, v20, v21, v22, v23, v24, v25, v27);
  v26 = v18;
  memcpy(&v18[*a2], v9, v5);
  if (v9 != a3)
    free(v9);
  v26[*a2 + v5] = 0;
  *a1 = v26;
  *a2 += v5;
}

uint64_t sub_2096CC9E4(uint64_t a1, uint64_t a2, int *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  _DWORD *v17;
  _DWORD *v18;
  uint64_t v19;
  size_t v20;
  int v21;
  BOOL v22;
  size_t v24;
  size_t v25;
  _DWORD *v26;
  void *v27;

  v27 = 0;
  v25 = 0;
  v15 = sub_2096CCAB4(a1, &v27, &v25, a4, a5, a6, a7, a8);
  if (!(_DWORD)v15)
  {
    v26 = 0;
    v24 = 0;
    v16 = sub_2096CCAB4(a2, (void **)&v26, &v24, v10, v11, v12, v13, v14);
    if ((_DWORD)v16)
    {
      v15 = v16;
      v17 = v27;
    }
    else
    {
      if (v25 == v24)
      {
        v17 = v26;
        v18 = v27;
        if (v25)
        {
          v19 = 0;
          v20 = v25 - 1;
          do
          {
            v21 = v18[v19] - v17[v19];
            *a3 = v21;
            if (v21)
              v22 = 1;
            else
              v22 = v20 == v19;
            ++v19;
          }
          while (!v22);
        }
      }
      else
      {
        *a3 = v25 - v24;
        v17 = v26;
        v18 = v27;
      }
      free(v18);
      v15 = 0;
    }
    free(v17);
  }
  return v15;
}

uint64_t sub_2096CCAB4(uint64_t a1, void **a2, size_t *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  size_t v11;
  void *v12;
  void *v13;
  uint64_t i;
  void *v15;
  uint64_t j;
  void *v17;
  uint64_t k;
  void *v19;
  uint64_t m;
  uint64_t v21;
  void *v22;
  uint64_t v23;
  void *v24;
  uint64_t n;
  void *v26;
  size_t v28;

  v28 = 0;
  *a2 = 0;
  *a3 = 0;
  switch(*(_DWORD *)a1)
  {
    case 0:
      sub_2096C1D6C("unknown directory type: %d", (uint64_t)a2, (uint64_t)a3, a4, a5, a6, a7, a8, 0);
    case 1:
      v11 = *(_QWORD *)(a1 + 8);
      v28 = v11;
      v12 = malloc_type_malloc(4 * v11, 0x100004052888210uLL);
      if (!v12)
        return 12;
      v13 = v12;
      if (v11)
      {
        for (i = 0; i != v11; ++i)
          *((_DWORD *)v12 + i) = *(unsigned __int8 *)(*(_QWORD *)(a1 + 16) + i);
      }
      goto LABEL_31;
    case 2:
      v11 = strlen(*(const char **)(a1 + 8));
      v28 = v11;
      v15 = malloc_type_malloc(4 * v11, 0x100004052888210uLL);
      if (!v15)
        return 12;
      v13 = v15;
      if (v11)
      {
        for (j = 0; j != v11; ++j)
          *((_DWORD *)v15 + j) = *(char *)(*(_QWORD *)(a1 + 8) + j);
      }
      goto LABEL_31;
    case 3:
      v11 = *(_QWORD *)(a1 + 8);
      v28 = v11;
      v17 = malloc_type_malloc(4 * v11, 0x100004052888210uLL);
      if (!v17)
        return 12;
      v13 = v17;
      if (v11)
      {
        for (k = 0; k != v11; ++k)
          *((_DWORD *)v17 + k) = *(unsigned __int8 *)(*(_QWORD *)(a1 + 16) + k);
      }
      goto LABEL_31;
    case 4:
      v11 = *(_QWORD *)(a1 + 8);
      v28 = v11;
      v19 = malloc_type_malloc(4 * v11, 0x100004052888210uLL);
      if (!v19)
        return 12;
      v13 = v19;
      if (v11)
      {
        for (m = 0; m != v11; ++m)
          *((_DWORD *)v19 + m) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + 4 * m);
      }
      goto LABEL_31;
    case 5:
      v21 = sub_2096BAEB8(*(char **)(a1 + 8), &v28);
      if ((_DWORD)v21)
        return v21;
      v22 = malloc_type_malloc(4 * v28, 0x100004052888210uLL);
      if (!v22)
        return 12;
      v13 = v22;
      v23 = wind_utf8ucs4(*(char **)(a1 + 8), (uint64_t)v22, &v28);
      if ((_DWORD)v23)
      {
        v21 = v23;
        free(v13);
      }
      else
      {
        v11 = v28;
LABEL_31:
        *a3 = v11;
        v26 = malloc_type_malloc(4 * v11, 0x100004052888210uLL);
        *a2 = v26;
        if (v26)
        {
          memcpy(v26, v13, 4 * v28);
          *a3 = v28;
          free(v13);
          return 0;
        }
        else
        {
          free(v13);
          if (*a2)
            free(*a2);
          *a2 = 0;
          *a3 = 0;
          return 12;
        }
      }
      return v21;
    case 6:
      v11 = *(_QWORD *)(a1 + 8);
      v28 = v11;
      v24 = malloc_type_malloc(4 * v11, 0x100004052888210uLL);
      if (!v24)
        return 12;
      v13 = v24;
      if (v11)
      {
        for (n = 0; n != v11; ++n)
          *((_DWORD *)v24 + n) = *(unsigned __int16 *)(*(_QWORD *)(a1 + 16) + 2 * n);
      }
      goto LABEL_31;
    default:
      v11 = 0;
      v13 = 0;
      goto LABEL_31;
  }
}

uint64_t sub_2096CCD90(uint64_t a1, uint64_t a2, int *a3)
{
  int v3;
  uint64_t v7;
  uint64_t v8;
  int v9;
  unint64_t v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t result;

  v3 = *(_DWORD *)(a1 + 24) - *(_DWORD *)(a2 + 24);
  *a3 = v3;
  if (!v3)
  {
    if (!*(_DWORD *)(a1 + 24))
    {
LABEL_12:
      result = 0;
      *a3 = 0;
      return result;
    }
    v7 = 0;
    v8 = *(_QWORD *)(a1 + 32);
    while (1)
    {
      v9 = *(_DWORD *)(v8 + 16 * v7) - *(_DWORD *)(*(_QWORD *)(a2 + 32) + 16 * v7);
      *a3 = v9;
      if (v9)
        break;
      v8 = *(_QWORD *)(a1 + 32);
      if (*(_DWORD *)(v8 + 16 * v7))
      {
        v10 = 0;
        v11 = 16;
        do
        {
          v12 = der_heim_oid_cmp();
          *a3 = v12;
          if (v12)
            return 0;
          result = sub_2096CC9E4(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 16 * v7 + 8) + v11, *(_QWORD *)(*(_QWORD *)(a2 + 32) + 16 * v7 + 8) + v11, a3, v13, v14, v15, v16, v17);
          if ((_DWORD)result)
            return result;
          if (*a3)
            return 0;
          ++v10;
          v8 = *(_QWORD *)(a1 + 32);
          v11 += 40;
        }
        while (v10 < *(unsigned int *)(v8 + 16 * v7));
      }
      if (++v7 >= (unint64_t)*(unsigned int *)(a1 + 24))
        goto LABEL_12;
    }
  }
  return 0;
}

uint64_t hx509_name_cmp(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  unsigned int v3;

  v3 = 0;
  LODWORD(result) = sub_2096CCD90(a1, a2, (int *)&v3);
  if ((_DWORD)result)
    return result;
  else
    return v3;
}

uint64_t sub_2096CCEDC(uint64_t a1, unsigned int a2, uint64_t a3, _DWORD *a4, void **a5)
{
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unsigned int *v19;
  uint64_t v20;
  uint64_t v21;
  _BYTE *v22;
  unsigned int *v23;
  unint64_t v24;
  uint64_t v25;

  if (a5)
    *a5 = 0;
  if (*(_DWORD *)(a1 + 24) <= a2)
    return 34;
  v24 = 0;
  v8 = *a4;
  if (v8 >= *(_DWORD *)(*(_QWORD *)(a1 + 32) + 16 * a2))
  {
LABEL_8:
    if (a5)
      return 569879;
    else
      return 0;
  }
  else
  {
    v9 = a2;
    v10 = 40 * v8;
    v11 = 16 * a2;
    while (der_heim_oid_cmp())
    {
      ++v8;
      v10 += 40;
      if (v8 >= *(unsigned int *)(*(_QWORD *)(a1 + 32) + v11))
        goto LABEL_8;
    }
    *a4 = v8 + 1;
    if (a5)
    {
      v25 = 0;
      v23 = 0;
      v17 = sub_2096CCAB4(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 16 * v9 + 8) + v10 + 16, (void **)&v23, (size_t *)&v25, v12, v13, v14, v15, v16);
      if (!(_DWORD)v17)
      {
        v19 = v23;
        v20 = v25;
        v21 = sub_2096BB080(v23, v25, &v24);
        if ((_DWORD)v21)
        {
          v17 = v21;
          free(v19);
        }
        else
        {
          v22 = malloc_type_malloc(++v24, 0x97534287uLL);
          *a5 = v22;
          v17 = wind_ucs4utf8(v19, v20, v22, &v24);
          free(v19);
          if ((_DWORD)v17)
          {
            free(*a5);
            *a5 = 0;
          }
        }
      }
    }
    else
    {
      return 569879;
    }
  }
  return v17;
}

uint64_t hx509_name_from_Name(uint64_t a1, void **a2)
{
  void *v3;
  uint64_t v4;

  v3 = malloc_type_calloc(1uLL, 0x28uLL, 0x10A0040F20C3E80uLL);
  *a2 = v3;
  if (!v3)
    return 12;
  v4 = hx509_name_to_Name_0();
  if ((_DWORD)v4)
  {
    free(*a2);
    *a2 = 0;
  }
  return v4;
}

uint64_t sub_2096CD0E4(uint64_t a1, uint64_t a2, int a3, uint64_t a4, const char *a5)
{
  char *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  void *v16;
  uint64_t v17;
  char v19;

  v9 = (char *)malloc_type_realloc(*(void **)(a2 + 32), 16 * (*(_DWORD *)(a2 + 24) + 1), 0x1020040D5A9D86FuLL);
  if (v9)
  {
    *(_QWORD *)(a2 + 32) = v9;
    if (a3)
    {
      v14 = &v9[16 * *(unsigned int *)(a2 + 24)];
    }
    else
    {
      memmove(v9 + 16, v9, 16 * *(unsigned int *)(a2 + 24));
      v14 = *(char **)(a2 + 32);
    }
    v16 = malloc_type_malloc(0x28uLL, 0x1092040826AA3E3uLL);
    *((_QWORD *)v14 + 1) = v16;
    if (!v16)
      return 12;
    *(_DWORD *)v14 = 1;
    v15 = der_copy_oid();
    if (!(_DWORD)v15)
    {
      v17 = *((_QWORD *)v14 + 1);
      *(_DWORD *)(v17 + 16) = 5;
      *(_QWORD *)(v17 + 24) = strdup(a5);
      if (*(_QWORD *)(*((_QWORD *)v14 + 1) + 24))
      {
        v15 = 0;
        ++*(_DWORD *)(a2 + 24);
        return v15;
      }
      return 12;
    }
  }
  else
  {
    v15 = 12;
    hx509_set_error_string(a1, 0, 12, "Out of memory", v10, v11, v12, v13, v19);
  }
  return v15;
}

uint64_t hx509_parse_name(uint64_t a1, const char *a2, _QWORD *a3)
{
  _QWORD *v3;
  _DWORD *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  void *v11;
  char *v12;
  char *v13;
  int v14;
  char *v15;
  size_t v16;
  unint64_t i;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  size_t v24;
  size_t v25;
  uint64_t v26;
  _BYTE *v27;
  _BYTE *v28;
  int v29;
  char *v30;
  char *v31;
  int v32;
  uint64_t v33;
  const char *v34;
  uint64_t v35;
  int v36;
  char v38;
  _QWORD *v39;
  char *v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;

  v3 = a3;
  *a3 = 0;
  v6 = malloc_type_calloc(1uLL, 0x28uLL, 0x10A0040F20C3E80uLL);
  v43 = (uint64_t)v6;
  if (!v6)
    goto LABEL_30;
  v11 = v6;
  v6[4] = 1;
  v12 = strdup(a2);
  if (!v12)
  {
    free(v11);
LABEL_30:
    v33 = 12;
    hx509_set_error_string(a1, 0, 12, "out of memory", v7, v8, v9, v10, v38);
    return v33;
  }
  v13 = v12;
  v14 = *v12;
  if (!*v12)
  {
LABEL_28:
    free(v13);
    v33 = 0;
    *v3 = v11;
    return v33;
  }
  v39 = v3;
  v15 = &v12[strlen(v12)];
  v40 = v13;
  while (2)
  {
    v16 = 0;
    v41 = 0;
    v42 = 0;
    for (i = ~(unint64_t)v13; ; --i)
    {
      if (v14 == 92)
      {
        if (v13[v16 + 1])
        {
          memmove(&v13[v16], &v13[v16 + 1], (size_t)&v15[i]);
          *--v15 = 0;
        }
        goto LABEL_12;
      }
      if (!v14)
        break;
      if (v14 == 44)
      {
        v18 = 1;
        goto LABEL_14;
      }
LABEL_12:
      v14 = v13[++v16];
    }
    v16 = strlen(v13);
    v18 = 0;
LABEL_14:
    v19 = strchr(v13, 61);
    if (!v19)
    {
      v38 = (char)v13;
      v34 = "missing = in %s";
LABEL_35:
      v35 = a1;
      v36 = 569968;
      goto LABEL_36;
    }
    v24 = v19 - v13;
    if (v19 == v13)
    {
      v38 = (char)v13;
      v34 = "missing name before = in %s";
      goto LABEL_35;
    }
    v25 = v16 - v24;
    if (v16 < v24)
    {
      v38 = (char)v13;
      v34 = " = after , in %s";
      goto LABEL_35;
    }
    v26 = 0;
    v41 = 0;
    v42 = 0;
    while (strncasecmp((&off_24C1F6710)[v26], v13, v24))
    {
      v26 += 3;
      if (v26 == 39)
      {
        v27 = malloc_type_malloc(v24 + 1, 0x9C46D030uLL);
        if (v27)
        {
          v28 = v27;
          memcpy(v27, v13, v24);
          v28[v24] = 0;
          v29 = der_parse_heim_oid();
          free(v28);
          goto LABEL_23;
        }
        goto LABEL_31;
      }
    }
    v29 = der_copy_oid();
LABEL_23:
    if (v29)
    {
LABEL_31:
      v38 = v24;
      v34 = "unknown type: %.*s";
      goto LABEL_35;
    }
    v30 = (char *)malloc_type_malloc(v16 - v24, 0x2BB3E5AuLL);
    if (v30)
    {
      v31 = v30;
      memcpy(v30, &v13[v24 + 1], v25 - 1);
      v31[v25 - 1] = 0;
      v11 = (void *)v43;
      v32 = sub_2096CD0E4(a1, v43, 0, (uint64_t)&v41, v31);
      free(v31);
      der_free_oid();
      if (v32)
        goto LABEL_37;
      v13 += v18 + v16;
      v14 = *v13;
      if (!*v13)
      {
        v3 = v39;
        v13 = v40;
        goto LABEL_28;
      }
      continue;
    }
    break;
  }
  der_free_oid();
  v34 = "out of memory";
  v35 = a1;
  v36 = 12;
LABEL_36:
  hx509_set_error_string(v35, 0, v36, v34, v20, v21, v22, v23, v38);
LABEL_37:
  free(v40);
  hx509_name_free((void **)&v43);
  return 569879;
}

void hx509_name_free(void **a1)
{
  _QWORD *v2;

  sub_2096D200C();
  v2 = *a1;
  v2[4] = 0;
  *(_OWORD *)v2 = 0u;
  *((_OWORD *)v2 + 1) = 0u;
  free(*a1);
  *a1 = 0;
}

uint64_t hx509_name_copy(uint64_t a1, uint64_t a2, void **a3)
{
  void *v4;
  uint64_t result;

  v4 = malloc_type_calloc(1uLL, 0x28uLL, 0x10A0040F20C3E80uLL);
  *a3 = v4;
  if (v4)
  {
    result = hx509_name_to_Name_0();
    if (!(_DWORD)result)
      return result;
    free(*a3);
    *a3 = 0;
  }
  return 12;
}

uint64_t hx509_name_normalize()
{
  return 0;
}

uint64_t hx509_name_expand(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v10;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  void **v17;
  const char *v18;
  char *v19;
  char *v20;
  char *v21;
  void **v22;
  char *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  char *v28;
  char *v29;
  char v30;
  const char *v31;
  void **v32;
  void **v33;
  void **v34;
  char *v35;
  uint64_t v36;
  const char *v37;
  uint64_t v38;
  int v39;
  const char *v41;
  char v42;

  if (!a3)
    return 0;
  if (*(_DWORD *)(a2 + 16) == 1)
  {
    v10 = *(unsigned int *)(a2 + 24);
    if ((_DWORD)v10)
    {
      v12 = 0;
      v13 = *(_QWORD *)(a2 + 32);
      while (!*(_DWORD *)(v13 + 16 * v12))
      {
LABEL_24:
        v36 = 0;
        if (++v12 >= v10)
          return v36;
      }
      v14 = 0;
      while (1)
      {
        v15 = *(_QWORD *)(v13 + 16 * v12 + 8);
        if (*(_DWORD *)(v15 + 40 * v14 + 16) != 5)
          break;
        v16 = v15 + 40 * v14;
        v19 = *(char **)(v16 + 24);
        v17 = (void **)(v16 + 24);
        v18 = v19;
        v20 = strstr(v19, "${");
        v21 = v20;
        if (v20)
        {
          v22 = rk_strpoolprintf(0, "%.*s", (int)v20 - (int)v18, v18);
          if (v22)
          {
            while (1)
            {
              if (!v21)
                goto LABEL_20;
              v23 = strchr(v21, 125);
              if (!v23)
                break;
              v28 = v23;
              v29 = v21 + 2;
              v30 = (_BYTE)v23 - (_BYTE)v29;
              v31 = (const char *)hx509_env_lfind(a1, a3, v29, v23 - v29);
              if (!v31)
              {
                v41 = "variable %.*s missing";
                v42 = v30;
                goto LABEL_34;
              }
              v32 = rk_strpoolprintf(v22, "%s", v31);
              if (v32)
              {
                v33 = v32;
                v21 = strstr(v28 + 1, "${");
                v34 = v21 ? rk_strpoolprintf(v33, "%.*s") : rk_strpoolprintf(v33, "%s");
                v22 = v34;
                if (v34)
                  continue;
              }
              goto LABEL_29;
            }
            v41 = "missing }";
LABEL_34:
            v36 = 22;
            hx509_set_error_string(a1, 0, 22, v41, v24, v25, v26, v27, v42);
            sub_2096B8C14(v22);
            return v36;
          }
LABEL_29:
          v37 = "out of memory";
          v36 = 12;
          v38 = a1;
          v39 = 12;
          goto LABEL_30;
        }
        v22 = 0;
LABEL_20:
        if (v22)
        {
          free(*v17);
          v35 = rk_strpoolcollect((uint64_t *)v22);
          *v17 = v35;
          if (!v35)
            goto LABEL_29;
        }
        ++v14;
        v13 = *(_QWORD *)(a2 + 32);
        if (v14 >= *(unsigned int *)(v13 + 16 * v12))
        {
          v10 = *(unsigned int *)(a2 + 24);
          goto LABEL_24;
        }
      }
      v37 = "unsupported type";
      goto LABEL_28;
    }
    return 0;
  }
  v37 = "RDN not of supported type";
LABEL_28:
  v36 = 22;
  v38 = a1;
  v39 = 22;
LABEL_30:
  hx509_set_error_string(v38, 0, v39, v37, a5, a6, a7, a8, v42);
  return v36;
}

uint64_t hx509_unparse_der_name(uint64_t a1, uint64_t a2, void **a3)
{
  uint64_t v4;
  _OWORD v6[2];
  uint64_t v7;

  v7 = 0;
  memset(v6, 0, sizeof(v6));
  *a3 = 0;
  v4 = sub_2096D1FBC();
  if (!(_DWORD)v4)
  {
    v4 = sub_2096CC4D4((uint64_t)v6, a3);
    sub_2096D200C();
  }
  return v4;
}

uint64_t hx509_name_binary(uint64_t a1, uint64_t a2)
{
  size_t v3;
  void *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char v15;

  v3 = sub_2096D1FFC();
  *(_QWORD *)a2 = v3;
  v4 = malloc_type_malloc(v3, 0x11AC1F61uLL);
  *(_QWORD *)(a2 + 8) = v4;
  if (!v4)
    return 12;
  v5 = sub_2096D1FDC();
  if ((_DWORD)v5)
  {
    v13 = v5;
    free(*(void **)(a2 + 8));
    *(_QWORD *)(a2 + 8) = 0;
  }
  else
  {
    if (*(_QWORD *)a2)
      sub_2096C1D6C("internal ASN.1 encoder error", v6, v7, v8, v9, v10, v11, v12, v15);
    return 0;
  }
  return v13;
}

uint64_t sub_2096CD938(uint64_t a1, void **a2)
{
  uint64_t result;
  uint64_t v4;
  uint64_t v5;

  v5 = 0;
  result = hx509_name_from_Name(a1, (void **)&v5);
  if (!(_DWORD)result)
  {
    v4 = sub_2096CC4D4(v5, a2);
    hx509_name_free((void **)&v5);
    return v4;
  }
  return result;
}

BOOL hx509_name_is_null_p(uint64_t a1)
{
  return *(_DWORD *)(a1 + 24) == 0;
}

uint64_t hx509_general_name_unparse(int *a1, char **a2)
{
  int v2;
  uint64_t result;
  void **v6;
  char *v7;
  uint64_t *v8;
  unsigned __int8 *v9;
  void **v10;
  uint64_t v11;
  char *v12;
  const char *v13;
  _QWORD v14[2];
  uint64_t v15;
  __int128 v16;

  *a2 = 0;
  v2 = *a1;
  result = 22;
  switch(v2)
  {
    case 0:
      return result;
    case 1:
    case 7:
      hx509_oid_sprint();
      return 12;
    case 2:
      v6 = rk_strpoolprintf(0, "rfc822Name: %.*s\n");
      goto LABEL_8;
    case 3:
      v6 = rk_strpoolprintf(0, "dNSName: %.*s\n");
      goto LABEL_8;
    case 4:
      v13 = 0;
      v14[0] = 0;
      v14[1] = 0;
      v15 = 0;
      LODWORD(v15) = a1[2];
      v16 = *((_OWORD *)a1 + 1);
      result = sub_2096CD938((uint64_t)v14, (void **)&v13);
      if ((_DWORD)result)
        return result;
      v7 = (char *)v13;
      v8 = (uint64_t *)rk_strpoolprintf(0, "directoryName: %s", v13);
      free(v7);
      if (v8)
        goto LABEL_15;
      return 12;
    case 5:
      v6 = rk_strpoolprintf(0, "URI: %.*s");
      goto LABEL_8;
    case 6:
      v9 = (unsigned __int8 *)*((_QWORD *)a1 + 2);
      v10 = rk_strpoolprintf(0, "IPAddress: ");
      if (!v10)
        return 12;
      v11 = *((_QWORD *)a1 + 1);
      if (v11 == 16)
      {
        v6 = rk_strpoolprintf(v10, "%02X:%02X:%02X:%02X:%02X:%02X:%02X:%02X:%02X:%02X:%02X:%02X:%02X:%02X:%02X:%02X", *v9, v9[1], v9[2], v9[3], v9[4]);
      }
      else if (v11 == 4)
      {
        v6 = rk_strpoolprintf(v10, "%d.%d.%d.%d");
      }
      else
      {
        v6 = rk_strpoolprintf(v10, "unknown IP address of length %lu");
      }
LABEL_8:
      v8 = (uint64_t *)v6;
      if (!v6)
        return 12;
LABEL_15:
      v12 = rk_strpoolcollect(v8);
      result = 0;
      *a2 = v12;
      return result;
    default:
      return 12;
  }
}

uint64_t hx509_peer_info_alloc(uint64_t a1, _QWORD *a2)
{
  void *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v11;

  v4 = malloc_type_calloc(1uLL, 0x18uLL, 0x102004062D53EE8uLL);
  *a2 = v4;
  if (v4)
    return 0;
  v9 = 12;
  hx509_set_error_string(a1, 0, 12, "out of memory", v5, v6, v7, v8, v11);
  return v9;
}

void hx509_peer_info_free(uint64_t *a1)
{
  uint64_t v2;

  if (a1)
  {
    v2 = *a1;
    if (v2)
      hx509_cert_free(v2);
    sub_2096CDC88((uint64_t)a1);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
    free(a1);
  }
}

void sub_2096CDC88(uint64_t a1)
{
  void *v2;
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;

  v3 = a1 + 8;
  v2 = *(void **)(a1 + 8);
  if (v2)
  {
    if (*(_QWORD *)(a1 + 16))
    {
      v4 = 0;
      v5 = 0;
      do
      {
        free_AlgorithmIdentifier();
        ++v5;
        v4 += 24;
      }
      while (v5 < *(_QWORD *)(a1 + 16));
      v2 = *(void **)v3;
    }
    free(v2);
    *(_QWORD *)v3 = 0;
    *(_QWORD *)(v3 + 8) = 0;
  }
}

uint64_t hx509_peer_info_set_cert(_QWORD *a1, uint64_t a2)
{
  if (*a1)
    hx509_cert_free();
  *a1 = hx509_cert_ref(a2);
  return 0;
}

uint64_t hx509_peer_info_add_cms_alg(uint64_t a1, uint64_t a2)
{
  void *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  char v13;

  v4 = malloc_type_realloc(*(void **)(a2 + 8), 24 * *(_QWORD *)(a2 + 16) + 24, 0x10300406712BA52uLL);
  if (v4)
  {
    *(_QWORD *)(a2 + 8) = v4;
    v9 = copy_AlgorithmIdentifier();
    if (!(_DWORD)v9)
    {
      ++*(_QWORD *)(a2 + 16);
      return v9;
    }
    v10 = a1;
    v11 = v9;
  }
  else
  {
    v9 = 12;
    v10 = a1;
    v11 = 12;
  }
  hx509_set_error_string(v10, 0, v11, "out of memory", v5, v6, v7, v8, v13);
  return v9;
}

uint64_t hx509_peer_info_set_cms_algs(uint64_t a1, uint64_t a2, uint64_t a3, size_t a4)
{
  void *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t i;
  uint64_t v13;
  uint64_t v14;
  char v16;

  sub_2096CDC88(a2);
  v7 = malloc_type_calloc(a4, 0x18uLL, 0x10300406712BA52uLL);
  *(_QWORD *)(a2 + 8) = v7;
  if (v7)
  {
    *(_QWORD *)(a2 + 16) = a4;
    if (a4)
    {
      for (i = 0; ; i += 24)
      {
        v13 = copy_AlgorithmIdentifier();
        if ((_DWORD)v13)
          break;
        if (!--a4)
          return 0;
      }
      v14 = v13;
      hx509_clear_error_string(a1);
      sub_2096CDC88(a2);
    }
    else
    {
      return 0;
    }
  }
  else
  {
    *(_QWORD *)(a2 + 16) = 0;
    v14 = 12;
    hx509_set_error_string(a1, 0, 12, "out of memory", v8, v9, v10, v11, v16);
  }
  return v14;
}

uint64_t hx509_print_stdout(FILE *a1, const char *a2, va_list a3)
{
  if (!a1)
    a1 = (FILE *)*MEMORY[0x24BDAC8E8];
  return vfprintf(a1, a2, a3);
}

uint64_t hx509_oid_sprint()
{
  return der_print_heim_oid();
}

void hx509_oid_print(uint64_t a1, uint64_t (*a2)(uint64_t, uint64_t, uint64_t *), uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  der_print_heim_oid();
  sub_2096CDF40(a2, a3, (uint64_t)"%s", v5, v6, v7, v8, v9, 0);
  free(0);
}

uint64_t sub_2096CDF40(uint64_t (*a1)(uint64_t, uint64_t, uint64_t *), uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  return a1(a2, a3, &a9);
}

uint64_t hx509_bitstring_print(uint64_t *a1, uint64_t (*a2)(uint64_t, uint64_t, uint64_t *), uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;

  result = sub_2096CDF40(a2, a3, (uint64_t)"\tlength: %d\n\t", a4, a5, a6, a7, a8, *a1);
  if ((unint64_t)(*a1 + 7) >= 8)
  {
    v17 = 0;
    do
      result = sub_2096CDF40(a2, a3, (uint64_t)"%02x%s%s", v12, v13, v14, v15, v16, *(unsigned __int8 *)(a1[1] + v17++));
    while (v17 < (unint64_t)(*a1 + 7) >> 3);
  }
  return result;
}

uint64_t hx509_cert_keyusage_print(uint64_t a1, uint64_t a2, char **a3)
{
  uint64_t v5;
  int v6;
  char *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  char v13;
  int v14;
  char __s1[256];
  uint64_t v16;

  v16 = *MEMORY[0x24BDAC8D0];
  v14 = 0;
  *a3 = 0;
  v5 = sub_2096C1BE0(a1, a2, &v14);
  if (!(_DWORD)v5)
  {
    v6 = sub_2096D255C(v14);
    unparse_flags(v6, (uint64_t)off_2545A7680, __s1, 0x100uLL);
    v7 = strdup(__s1);
    *a3 = v7;
    if (v7)
    {
      return 0;
    }
    else
    {
      v5 = 12;
      hx509_set_error_string(a1, 0, 12, "out of memory", v8, v9, v10, v11, v13);
    }
  }
  return v5;
}

uint64_t sub_2096CE14C(uint64_t a1, _QWORD *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  const char *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v18;

  v4 = sub_2096BC8D8();
  if ((_DWORD)v4)
  {
    v18 = v4;
    v10 = "Decoding kerberos name in SAN failed: %d";
LABEL_6:
    v16 = 1;
    sub_2096CF108(a1, 1, (uint64_t)v10, v5, v6, v7, v8, v9, v18);
    return v16;
  }
  if (*a2)
  {
    v10 = "Decoding kerberos name have extra bits on the end";
    goto LABEL_6;
  }
  sub_2096CF108(a1, 2, (uint64_t)"@", v5, v6, v7, v8, v9, v18);
  sub_2096CF108(a1, 2, (uint64_t)"%s", v11, v12, v13, v14, v15, 0);
  sub_2096BC928();
  return 0;
}

uint64_t sub_2096CE27C(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  v2 = sub_2096D2AC0();
  if ((_DWORD)v2)
  {
    v8 = 1;
    sub_2096CF108(a1, 1, (uint64_t)"Decoding JID in SAN failed: %d", v3, v4, v5, v6, v7, v2);
  }
  else
  {
    sub_2096CF108(a1, 2, (uint64_t)"%s", v3, v4, v5, v6, v7, 0);
    sub_2096D2B10();
    return 0;
  }
  return v8;
}

uint64_t sub_2096CE304()
{
  return 0;
}

uint64_t sub_2096CE30C(uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  const char *v9;

  switch(a3)
  {
    case 1:
      if (!*(_QWORD *)(a4 + 16))
      {
        v9 = "\tCritical not set on SHOULD\n";
        goto LABEL_10;
      }
      break;
    case 2:
      if (*(_QWORD *)(a4 + 16))
      {
        v9 = "\tCritical set on SHOULD NOT\n";
        goto LABEL_10;
      }
      break;
    case 3:
      if (!*(_QWORD *)(a4 + 16))
      {
        v9 = "\tCritical not set on MUST\n";
        goto LABEL_10;
      }
      break;
    case 4:
      if (*(_QWORD *)(a4 + 16))
      {
        v9 = "\tCritical set on MUST NOT\n";
LABEL_10:
        sub_2096CF108(a1, 1, (uint64_t)v9, a4, a5, a6, a7, a8, v8);
      }
      break;
    default:
      return 0;
  }
  return 0;
}

uint64_t sub_2096CE398(uint64_t a1, _BYTE *a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  const char *v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v25;
  void *v26;
  uint64_t v27;
  unint64_t v28;
  char *v29;

  v28 = 0;
  v29 = 0;
  v27 = 0;
  *a2 |= 0x20u;
  sub_2096CE30C(a1, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
  v10 = sub_2096D25C4();
  if ((_DWORD)v10)
  {
    v25 = v10;
    v16 = "Decoding SubjectKeyIdentifier failed: %d";
LABEL_12:
    v23 = 1;
    sub_2096CF108(a1, 1, (uint64_t)v16, v11, v12, v13, v14, v15, v25);
    return v23;
  }
  if (v27 != *(_QWORD *)(a4 + 24))
  {
    v16 = "Decoding SKI ahve extra bits on the end";
    goto LABEL_12;
  }
  v17 = v28;
  if (!v28)
  {
    sub_2096CF108(a1, 1, (uint64_t)"SKI is too short (0 bytes)", v11, v12, v13, v14, v15, v25);
    v17 = 0;
  }
  if (v17 >= 0x15)
  {
    sub_2096CF108(a1, 1, (uint64_t)"SKI is too long", v11, v12, v13, v14, v15, v25);
    v17 = v28;
  }
  v26 = 0;
  rk_hex_encode(v29, v17, &v26);
  if (v26)
  {
    sub_2096CF108(a1, 2, (uint64_t)"\tsubject key id: %s\n", v18, v19, v20, v21, v22, (uint64_t)v26);
    free(v26);
  }
  sub_2096D2614();
  return 0;
}

uint64_t sub_2096CE4B0(uint64_t a1, _BYTE *a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  *a2 |= 8u;
  return sub_2096CF1D8(a1, (uint64_t)a2, (uint64_t)"subject", a3, a4, a6, a7, a8);
}

uint64_t sub_2096CE4D0(uint64_t a1, _BYTE *a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  *a2 |= 0x10u;
  return sub_2096CF1D8(a1, (uint64_t)a2, (uint64_t)"issuer", a3, a4, a6, a7, a8);
}

uint64_t sub_2096CE4F0(uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;

  sub_2096CE30C(a1, a2, a3, a4, a5, a6, a7, a8);
  v10 = sub_2096D2638();
  if (v10)
  {
    printf("\tret = %d while decoding BasicConstraints\n", v10);
  }
  else
  {
    if (*(_QWORD *)(a4 + 24))
      puts("\tlength of der data isn't same as extension");
    sub_2096CF108(a1, 2, (uint64_t)"\tis %sa CA\n", v11, v12, v13, v14, v15, (uint64_t)"NOT ");
    sub_2096D2688();
  }
  return 0;
}

uint64_t sub_2096CE630(uint64_t a1, _BYTE *a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;

  v20 = 0;
  v21 = 0;
  v19 = 0;
  sub_2096CE30C(a1, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
  v10 = sub_2096D27AC();
  if ((_DWORD)v10)
  {
    v16 = 1;
    sub_2096CF108(a1, 1, (uint64_t)"Decoding CRL Distribution Points failed: %d\n", v11, v12, v13, v14, v15, v10);
  }
  else
  {
    sub_2096CF108(a1, 2, (uint64_t)"CRL Distribution Points:\n", v11, v12, v13, v14, v15, v18);
    sub_2096D27FC();
    v16 = 0;
    *a2 |= 0x80u;
  }
  return v16;
}

uint64_t sub_2096CE830(uint64_t a1, _BYTE *a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  const char *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v24;
  void *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;

  v27 = 0;
  v28 = 0;
  v29 = 0;
  v26 = 0;
  *a2 |= 0x40u;
  sub_2096CE30C(a1, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
  v10 = sub_2096D2564();
  if ((_DWORD)v10)
  {
    v24 = v10;
    v16 = "Decoding AuthorityKeyIdentifier failed: %d";
LABEL_9:
    v22 = 1;
    sub_2096CF108(a1, 1, (uint64_t)v16, v11, v12, v13, v14, v15, v24);
    return v22;
  }
  if (v26 != *(_QWORD *)(a4 + 24))
  {
    v16 = "Decoding SKI ahve extra bits on the end";
    goto LABEL_9;
  }
  if (v27)
  {
    v25 = 0;
    rk_hex_encode(*(char **)(v27 + 8), *(_QWORD *)v27, &v25);
    if (v25)
    {
      sub_2096CF108(a1, 2, (uint64_t)"\tauthority key id: %s\n", v17, v18, v19, v20, v21, (uint64_t)v25);
      free(v25);
    }
  }
  return 0;
}

uint64_t sub_2096CE90C(uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  const char *v16;
  uint64_t v18;

  sub_2096CE30C(a1, a2, a3, a4, a5, a6, a7, a8);
  v10 = sub_2096D26DC();
  if ((_DWORD)v10)
  {
    v18 = v10;
    v16 = "Decoding ExtKeyUsage failed: %d";
  }
  else
  {
    if (*(_QWORD *)(a4 + 24))
    {
      sub_2096CF108(a1, 1, (uint64_t)"Padding data in EKU", v11, v12, v13, v14, v15, v18);
      sub_2096D272C();
      return 1;
    }
    v16 = "ExtKeyUsage length is 0";
  }
  sub_2096CF108(a1, 1, (uint64_t)v16, v11, v12, v13, v14, v15, v18);
  return 1;
}

uint64_t sub_2096CEA44(uint64_t a1, _BYTE *a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_2096CE30C(a1, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
  *a2 |= 4u;
  return 0;
}

uint64_t sub_2096CEA74(uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  v11 = 0;
  v12 = 0;
  v10 = 0;
  sub_2096CE30C(a1, a2, a3, a4, a5, a6, a7, a8);
  v8 = sub_2096D2B20();
  if (v8)
    printf("\tret = %d while decoding AuthorityInfoAccessSyntax\n", v8);
  else
    sub_2096D2B40();
  return 0;
}

uint64_t hx509_validate_ctx_init(uint64_t a1, _QWORD *a2)
{
  _QWORD *v3;
  _QWORD *v4;
  uint64_t result;

  v3 = malloc_type_malloc(0x18uLL, 0x1080040C4643742uLL);
  *a2 = v3;
  if (!v3)
    return 12;
  v4 = v3;
  result = 0;
  *v4 = 0;
  v4[1] = 0;
  v4[2] = 0;
  return result;
}

uint64_t hx509_validate_ctx_set_print(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 8) = a2;
  *(_QWORD *)(result + 16) = a3;
  return result;
}

_DWORD *hx509_validate_ctx_add_flags(_DWORD *result, int a2)
{
  *result |= a2;
  return result;
}

uint64_t hx509_validate_cert(uint64_t a1, _DWORD *a2, uint64_t a3)
{
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _DWORD *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  _DWORD *v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t *v50;
  int v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  const char *v57;
  int v58;
  _BOOL4 is_null_p;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  int v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  const char *v71;
  uint64_t v72;
  int v73;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  int v80;
  void *v81;
  uint64_t v82;
  uint64_t v83;

  v5 = (_QWORD *)sub_2096BEAC8(a3);
  v80 = 0;
  if (sub_2096BEAD0((uint64_t)v5) != 3)
    sub_2096CF108((uint64_t)a2, 2, (uint64_t)"Not version 3 certificate\n", v6, v7, v8, v9, v10, v75);
  v82 = 0;
  v83 = 0;
  v81 = 0;
  v11 = (_DWORD *)v5[2];
  if ((!v11 || *v11 <= 1u) && v5[30])
    sub_2096CF108((uint64_t)a2, 1, (uint64_t)"Not version 3 certificate with extensions\n", v6, v7, v8, v9, v10, v75);
  if ((int)sub_2096BEAD0((uint64_t)v5) >= 3 && !v5[30])
    sub_2096CF108((uint64_t)a2, 1, (uint64_t)"Version 3 certificate without extensions\n", v12, v13, v14, v15, v16, v75);
  if (hx509_cert_get_subject(a3, (void **)&v82)
    || (hx509_name_to_string(v82, &v81),
        sub_2096CF108((uint64_t)a2, 2, (uint64_t)"subject name: %s\n", v17, v18, v19, v20, v21, (uint64_t)v81),
        free(v81),
        hx509_cert_get_issuer(a3, (void **)&v83)))
  {
    abort();
  }
  hx509_name_to_string(v83, &v81);
  sub_2096CF108((uint64_t)a2, 2, (uint64_t)"issuer name: %s\n", v22, v23, v24, v25, v26, (uint64_t)v81);
  free(v81);
  if (!hx509_name_cmp(v82, v83))
  {
    LOBYTE(v80) = v80 | 1;
    sub_2096CF108((uint64_t)a2, 2, (uint64_t)"\tis a self-signed certificate\n", v27, v28, v29, v30, v31, v76);
  }
  sub_2096CF108((uint64_t)a2, 2, (uint64_t)"Validity:\n", v27, v28, v29, v30, v31, v76);
  sub_2096CF150((uint64_t)(v5 + 14), (char **)&v81);
  sub_2096CF108((uint64_t)a2, 2, (uint64_t)"\tnotBefore %s\n", v32, v33, v34, v35, v36, (uint64_t)v81);
  free(v81);
  sub_2096CF150((uint64_t)(v5 + 16), (char **)&v81);
  sub_2096CF108((uint64_t)a2, 2, (uint64_t)"\tnotAfter  %s\n", v37, v38, v39, v40, v41, (uint64_t)v81);
  free(v81);
  v47 = (_DWORD *)v5[30];
  if (v47)
  {
    if (*v47
      || (sub_2096CF108((uint64_t)a2, 3, (uint64_t)"The empty extensions list is not allowed by PKIX\n", v42, v43, v44, v45, v46, v77), *(_DWORD *)v5[30]))
    {
      v48 = 0;
      while (1)
      {
        if (!off_253D3AB58)
          goto LABEL_24;
        v49 = 0;
        v50 = (uint64_t *)&off_253D3AB58;
        if (der_heim_oid_cmp())
          break;
LABEL_22:
        if (!*v50)
          goto LABEL_24;
        sub_2096CF108((uint64_t)a2, 3, (uint64_t)"checking extention: %s\n", v42, v43, v44, v45, v46, *v50);
        ((void (*)(_DWORD *, int *, _QWORD, uint64_t))(&off_253D3AB58)[4 * v49 + 2])(a2, &v80, LODWORD((&off_253D3AB58)[4 * v49 + 3]), *(_QWORD *)(v5[30] + 8) + 40 * v48);
LABEL_32:
        if (++v48 >= (unint64_t)*(unsigned int *)v5[30])
          goto LABEL_35;
      }
      while (v50[4])
      {
        v50 += 4;
        ++v49;
        if (!der_heim_oid_cmp())
          goto LABEL_22;
      }
LABEL_24:
      if (*(_QWORD *)(*(_QWORD *)(v5[30] + 8) + 40 * v48 + 16))
        v51 = 3;
      else
        v51 = 2;
      sub_2096CF108((uint64_t)a2, v51, (uint64_t)"don't know what ", v42, v43, v44, v45, v46, v77);
      if (*(_QWORD *)(*(_QWORD *)(v5[30] + 8) + 40 * v48 + 16))
        sub_2096CF108((uint64_t)a2, v51, (uint64_t)"and is CRITICAL ", v52, v53, v54, v55, v56, v78);
      if ((*a2 & v51) != 0)
        hx509_oid_print(*(_QWORD *)(v5[30] + 8) + 40 * v48, (uint64_t (*)(uint64_t, uint64_t, uint64_t *))sub_2096CF1C4, (uint64_t)a2);
      sub_2096CF108((uint64_t)a2, v51, (uint64_t)" is\n", v52, v53, v54, v55, v56, v78);
      goto LABEL_32;
    }
  }
  else
  {
    sub_2096CF108((uint64_t)a2, 2, (uint64_t)"no extentions\n", v42, v43, v44, v45, v46, v77);
  }
LABEL_35:
  if ((v80 & 2) != 0)
  {
    if ((v80 & 0x20) != 0)
      goto LABEL_41;
    v57 = "CA certificate have no SubjectKeyIdentifier\n";
  }
  else
  {
    if ((v80 & 0x40) != 0)
      goto LABEL_41;
    v57 = "Is not CA and doesn't have AuthorityKeyIdentifier\n";
  }
  sub_2096CF108((uint64_t)a2, 1, (uint64_t)v57, v42, v43, v44, v45, v46, v77);
LABEL_41:
  v58 = v80;
  if ((v80 & 0x20) == 0)
  {
    sub_2096CF108((uint64_t)a2, 1, (uint64_t)"Doesn't have SubjectKeyIdentifier\n", v42, v43, v44, v45, v46, v77);
    v58 = v80;
  }
  if ((~v58 & 6) == 0)
  {
    sub_2096CF108((uint64_t)a2, 1, (uint64_t)"Proxy and CA at the same time!\n", v42, v43, v44, v45, v46, v77);
    LOBYTE(v58) = v80;
  }
  if ((v58 & 4) != 0)
  {
    if ((v58 & 8) != 0)
    {
      sub_2096CF108((uint64_t)a2, 1, (uint64_t)"Proxy and have SAN\n", v42, v43, v44, v45, v46, v77);
      LOBYTE(v58) = v80;
    }
    if ((v58 & 0x10) != 0)
      sub_2096CF108((uint64_t)a2, 1, (uint64_t)"Proxy and have IAN\n", v42, v43, v44, v45, v46, v77);
  }
  is_null_p = hx509_name_is_null_p(v82);
  v65 = v80;
  if (is_null_p && (v80 & 8) == 0)
  {
    sub_2096CF108((uint64_t)a2, 1, (uint64_t)"NULL subject DN and doesn't have a SAN\n", v60, v61, v62, v63, v64, v77);
    v65 = v80;
  }
  if ((v65 & 0xFFFFFF81) != 0)
  {
    if ((v65 & 1) == 0)
      goto LABEL_61;
  }
  else
  {
    sub_2096CF108((uint64_t)a2, 1, (uint64_t)"Not a CA nor PROXY and doesn't haveCRL Dist Point\n", v60, v61, v62, v63, v64, v77);
    if ((v80 & 1) == 0)
      goto LABEL_61;
  }
  if (sub_2096C0E48(a1, a3, (uint64_t)(v5 + 31), (uint64_t)v5, v5 + 34, v62, v63, v64))
  {
    v71 = "Could NOT verify self-signed certificate self-signature!\n";
    v72 = (uint64_t)a2;
    v73 = 1;
  }
  else
  {
    v71 = "Self-signed certificate was self-signed\n";
    v72 = (uint64_t)a2;
    v73 = 2;
  }
  sub_2096CF108(v72, v73, (uint64_t)v71, v66, v67, v68, v69, v70, v77);
LABEL_61:
  hx509_name_free((void **)&v82);
  hx509_name_free((void **)&v83);
  return 0;
}

uint64_t sub_2096CF108(uint64_t result, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t (*v9)(_QWORD, uint64_t, uint64_t *);

  if ((*(_DWORD *)result & a2) != 0)
  {
    v9 = *(uint64_t (**)(_QWORD, uint64_t, uint64_t *))(result + 8);
    if (v9)
      return v9(*(_QWORD *)(result + 16), a3, &a9);
  }
  return result;
}

char *sub_2096CF150(uint64_t a1, char **a2)
{
  tm *v3;
  char *result;
  char *v5;
  time_t v6;

  *a2 = 0;
  v6 = sub_2096BFCF0(a1);
  v3 = gmtime(&v6);
  result = (char *)malloc_type_malloc(0x1EuLL, 0x43CAEAE5uLL);
  if (result)
  {
    v5 = result;
    result = (char *)strftime(result, 0x1EuLL, "%Y-%m-%d %H:%M:%S", v3);
    *a2 = v5;
  }
  return result;
}

uint64_t sub_2096CF1C4(uint64_t result)
{
  uint64_t (*v1)(_QWORD);

  v1 = *(uint64_t (**)(_QWORD))(result + 8);
  if (v1)
    return v1(*(_QWORD *)(result + 16));
  return result;
}

uint64_t sub_2096CF1D8(uint64_t a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  const char *v17;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;

  sub_2096CE30C(a1, a2, a4, a5, a5, a6, a7, a8);
  if (*(_QWORD *)(a5 + 24))
  {
    v21 = 0;
    v22 = 0;
    v20 = 0;
    v16 = sub_2096D2430();
    if ((_DWORD)v16)
    {
      v19 = v16;
      v17 = "\tret = %d while decoding %s GeneralNames\n";
    }
    else
    {
      v19 = a3;
      v17 = "%sAltName generalName empty, not allowed\n";
    }
  }
  else
  {
    v19 = a3;
    v17 = "%sAltName empty, not allowed";
  }
  sub_2096CF108(a1, 1, (uint64_t)v17, v11, v12, v13, v14, v15, v19);
  return 1;
}

uint64_t hx509_request_init(uint64_t a1, _QWORD *a2)
{
  void *v3;

  v3 = malloc_type_calloc(1uLL, 0x50uLL, 0x10B0040751154FDuLL);
  *a2 = v3;
  if (v3)
    return 0;
  else
    return 12;
}

void hx509_request_free(void **a1)
{
  void **v2;
  _OWORD *v3;

  v2 = (void **)*a1;
  if (*v2)
    hx509_name_free(v2);
  free_SubjectPublicKeyInfo();
  sub_2096D272C();
  sub_2096D2480();
  v3 = *a1;
  v3[3] = 0u;
  v3[4] = 0u;
  v3[1] = 0u;
  v3[2] = 0u;
  *v3 = 0u;
  free(*a1);
  *a1 = 0;
}

uint64_t hx509_request_set_name(uint64_t a1, void **a2, uint64_t a3)
{
  uint64_t result;

  if (*a2)
    hx509_name_free(a2);
  if (!a3)
    return 0;
  result = hx509_name_copy(a1, a3, a2);
  if (!(_DWORD)result)
    return 0;
  return result;
}

uint64_t hx509_request_get_name(uint64_t a1, uint64_t *a2, void **a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  char vars0;

  v8 = *a2;
  if (v8)
    return hx509_name_copy(a1, v8, a3);
  hx509_set_error_string(a1, 0, 22, "Request have no name", a5, a6, a7, a8, vars0);
  return 22;
}

uint64_t hx509_request_set_SubjectPublicKeyInfo()
{
  free_SubjectPublicKeyInfo();
  return copy_SubjectPublicKeyInfo();
}

uint64_t hx509_request_get_SubjectPublicKeyInfo()
{
  return copy_SubjectPublicKeyInfo();
}

uint64_t _hx509_request_add_dns_name(int a1, uint64_t a2, char *__s)
{
  strlen(__s);
  return sub_2096D2490((unsigned int *)(a2 + 64));
}

uint64_t _hx509_request_add_email(int a1, uint64_t a2, char *__s)
{
  strlen(__s);
  return sub_2096D2490((unsigned int *)(a2 + 64));
}

uint64_t _hx509_request_to_pkcs10(uint64_t a1, _QWORD *a2, uint64_t a3, _QWORD *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v11;
  void *v12;
  void *v13;
  void *v14;
  uint64_t v15;
  void *v16;
  uint64_t v17;
  char v19;
  uint64_t v20;
  uint64_t v21;
  void *v22[2];
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  uint64_t v32;

  if (*a2)
  {
    v22[0] = 0;
    v22[1] = 0;
    v20 = 0;
    v21 = 0;
    v23 = 0u;
    v24 = 0u;
    v25 = 0u;
    v26 = 0u;
    v27 = 0u;
    v28 = 0u;
    v29 = 0u;
    v30 = 0u;
    v31 = 0u;
    v32 = 0;
    *a4 = 0;
    a4[1] = 0;
    LODWORD(v24) = 0;
    v11 = hx509_name_to_Name_0();
    if ((_DWORD)v11)
      goto LABEL_16;
    v11 = copy_SubjectPublicKeyInfo();
    if ((_DWORD)v11)
      goto LABEL_16;
    *((_QWORD *)&v29 + 1) = malloc_type_calloc(1uLL, 0x10uLL, 0x1020040D5A9D86FuLL);
    if (*((_QWORD *)&v29 + 1))
    {
      v12 = (void *)sub_2096D1E54();
      v22[0] = v12;
      v13 = malloc_type_malloc((size_t)v12, 0x54E1B5AuLL);
      v22[1] = v13;
      if (v13)
      {
        v14 = v13;
        v15 = sub_2096D1E34();
        if ((_DWORD)v15)
        {
          v11 = v15;
          v16 = v14;
LABEL_8:
          free(v16);
          v22[1] = 0;
LABEL_16:
          sub_2096D1EB4();
          return v11;
        }
        if (v12)
LABEL_20:
          abort();
        v11 = sub_2096C4F38(a1, a3, (uint64_t)off_2545A7090, (uint64_t)v22, (uint64_t)&v30, (uint64_t)&v20);
        free(v22[1]);
        if ((_DWORD)v11)
          goto LABEL_16;
        *((_QWORD *)&v31 + 1) = 8 * v20;
        v32 = v21;
        v22[0] = (void *)sub_2096D1EA4();
        v22[1] = malloc_type_malloc((size_t)v22[0], 0xCDD8BB95uLL);
        if (v22[1])
        {
          v17 = sub_2096D1E84();
          if ((_DWORD)v17)
          {
            v11 = v17;
            v16 = v22[1];
            goto LABEL_8;
          }
          if (!v22[0])
          {
            v11 = 0;
            *(_OWORD *)a4 = *(_OWORD *)v22;
            goto LABEL_16;
          }
          goto LABEL_20;
        }
      }
    }
    v11 = 12;
    goto LABEL_16;
  }
  v11 = 22;
  hx509_set_error_string(a1, 0, 22, "PKCS10 needs to have a subject", a5, a6, a7, a8, v19);
  return v11;
}

uint64_t _hx509_request_parse(uint64_t a1, char *__s1, void ***a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  const char *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  const char *v17;
  void **v19;
  uint64_t v20;
  char v21;
  void *v22[2];
  off_t v23;
  uint64_t v24;
  __int128 v25;
  _OWORD v26[8];
  uint64_t v27;

  if (strncmp(__s1, "PKCS10:", 7uLL))
  {
    v10 = 569966;
    hx509_set_error_string(a1, 0, 569966, "unsupport type in %s", v6, v7, v8, v9, (char)__s1);
    return v10;
  }
  v27 = 0;
  memset(v26, 0, sizeof(v26));
  v25 = 0u;
  v23 = 0;
  v24 = 0;
  v22[0] = 0;
  v22[1] = 0;
  v11 = __s1 + 7;
  v12 = rk_undumpdata(v11, v22, &v23);
  if ((_DWORD)v12)
  {
    v10 = v12;
    v21 = (char)v11;
    v17 = "Failed to map file %s";
LABEL_7:
    hx509_set_error_string(a1, 0, v10, v17, v13, v14, v15, v16, v21);
    return v10;
  }
  v10 = sub_2096D1E64();
  j__free(v22[0]);
  if ((_DWORD)v10)
  {
    v21 = (char)v11;
    v17 = "Failed to decode %s";
    goto LABEL_7;
  }
  v19 = (void **)malloc_type_calloc(1uLL, 0x50uLL, 0x10B0040751154FDuLL);
  *a3 = v19;
  if (v19)
  {
    free_SubjectPublicKeyInfo();
    v20 = copy_SubjectPublicKeyInfo();
    if ((_DWORD)v20 || (v20 = hx509_name_from_Name((uint64_t)v26 + 8, (void **)&v24), (_DWORD)v20))
    {
      v10 = v20;
      sub_2096D1EB4();
    }
    else
    {
      v10 = hx509_request_set_name(a1, *a3, v24);
      hx509_name_free((void **)&v24);
      sub_2096D1EB4();
      if (!(_DWORD)v10)
        return v10;
    }
    hx509_request_free((void **)a3);
  }
  else
  {
    sub_2096D1EB4();
    return 12;
  }
  return v10;
}

uint64_t _hx509_request_print(uint64_t a1, uint64_t *a2, FILE *a3)
{
  uint64_t v4;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  char v12;
  void *v13;

  v4 = *a2;
  if (!*a2)
    return 0;
  v13 = 0;
  v10 = hx509_name_to_string(v4, &v13);
  if ((_DWORD)v10)
  {
    hx509_set_error_string(a1, 0, v10, "Failed to print name", v6, v7, v8, v9, v12);
  }
  else
  {
    fprintf(a3, "name: %s\n", (const char *)v13);
    free(v13);
  }
  return v10;
}

uint64_t hx509_revoke_init(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t result;
  uint64_t v12;

  v9 = heim_uniq_alloc(0x40uLL, (uint64_t)"hx509-revoke", (uint64_t)sub_2096CFAEC, a4, a5, a6, a7, a8);
  *a2 = v9;
  if (!v9)
    return 12;
  v10 = v9;
  result = 0;
  *(_QWORD *)(v10 + 32) = 0;
  *(_QWORD *)(v10 + 40) = 0;
  v12 = *a2;
  *(_QWORD *)(v12 + 48) = 0;
  *(_QWORD *)(v12 + 56) = 0;
  return result;
}

void sub_2096CFAEC(uint64_t a1)
{
  uint64_t v2;
  unint64_t v3;
  uint64_t v4;
  unint64_t v5;

  if (*(_QWORD *)(a1 + 40))
  {
    v2 = 0;
    v3 = 0;
    do
    {
      free(*(void **)(*(_QWORD *)(a1 + 32) + v2));
      sub_2096D2A3C();
      ++v3;
      v2 += 192;
    }
    while (v3 < *(_QWORD *)(a1 + 40));
  }
  if (*(_QWORD *)(a1 + 56))
  {
    v4 = 0;
    v5 = 0;
    do
    {
      sub_2096D10A4(*(_QWORD *)(a1 + 48) + v4);
      ++v5;
      v4 += 184;
    }
    while (v5 < *(_QWORD *)(a1 + 56));
  }
  free(*(void **)(a1 + 48));
  free(*(void **)(a1 + 32));
}

void hx509_revoke_free(CFTypeRef *a1)
{
  if (a1)
  {
    heim_release(*a1);
    *a1 = 0;
  }
}

uint64_t hx509_revoke_add_ocsp(uint64_t a1, uint64_t a2, char *__s1)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  const char *v11;
  const char **v12;
  uint64_t v13;
  char *v14;
  char *v15;
  char *v16;
  char **v17;

  if (!strncmp(__s1, "FILE:", 5uLL))
  {
    v11 = __s1 + 5;
    v12 = *(const char ***)(a2 + 48);
    v13 = *(_QWORD *)(a2 + 56);
    if (v13 && !strcmp(*v12, v11))
    {
      return 0;
    }
    else
    {
      v14 = (char *)malloc_type_realloc(v12, 184 * v13 + 184, 0x10B0040DF19FAC3uLL);
      if (!v14)
        goto LABEL_9;
      *(_QWORD *)(a2 + 48) = v14;
      v15 = &v14[184 * *(_QWORD *)(a2 + 56)];
      *((_QWORD *)v15 + 22) = 0;
      *((_OWORD *)v15 + 9) = 0u;
      *((_OWORD *)v15 + 10) = 0u;
      *((_OWORD *)v15 + 7) = 0u;
      *((_OWORD *)v15 + 8) = 0u;
      *((_OWORD *)v15 + 5) = 0u;
      *((_OWORD *)v15 + 6) = 0u;
      *((_OWORD *)v15 + 3) = 0u;
      *((_OWORD *)v15 + 4) = 0u;
      *((_OWORD *)v15 + 1) = 0u;
      *((_OWORD *)v15 + 2) = 0u;
      *(_OWORD *)v15 = 0u;
      v16 = strdup(v11);
      v17 = (char **)(*(_QWORD *)(a2 + 48) + 184 * *(_QWORD *)(a2 + 56));
      *v17 = v16;
      if (v16)
      {
        v10 = sub_2096CFD14(a1, (uint64_t)v17);
        if ((_DWORD)v10)
          free(*(void **)(*(_QWORD *)(a2 + 48) + 184 * *(_QWORD *)(a2 + 56)));
        else
          ++*(_QWORD *)(a2 + 56);
      }
      else
      {
LABEL_9:
        hx509_clear_error_string(a1);
        return 12;
      }
    }
  }
  else
  {
    v10 = 569966;
    hx509_set_error_string(a1, 0, 569966, "unsupport type in %s", v6, v7, v8, v9, (char)__s1);
  }
  return v10;
}

uint64_t sub_2096CFD14(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  _DWORD *v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  uint64_t v24;
  void *v25;
  stat v26;
  off_t v27;
  uint64_t v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  _DWORD *v38;

  v38 = 0;
  v36 = 0u;
  v37 = 0u;
  v34 = 0u;
  v35 = 0u;
  v32 = 0u;
  v33 = 0u;
  v30 = 0u;
  v31 = 0u;
  v29 = 0u;
  v27 = 0;
  v28 = 0;
  memset(&v26, 0, sizeof(v26));
  v25 = 0;
  v4 = rk_undumpdata(*(const char **)a2, &v25, &v27);
  if (!(_DWORD)v4)
  {
    if (stat(*(const char **)a2, &v26))
    {
      return *__error();
    }
    else
    {
      v4 = sub_2096D1354((uint64_t)v25, v27, (uint64_t)&v29);
      j__free(v25);
      if (!(_DWORD)v4)
      {
        if (v38)
        {
          v9 = hx509_certs_init(a1, "MEMORY:ocsp-certs", 0, 0, &v28);
          if ((_DWORD)v9)
          {
            v4 = v9;
            sub_2096D1E24();
            return v4;
          }
          v15 = v38;
          if (*v38)
          {
            v16 = 0;
            v17 = 0;
            do
            {
              v24 = 0;
              if (!hx509_cert_init(a1, *((_QWORD *)v15 + 1) + v16, (CFTypeRef *)&v24, v10, v11, v12, v13, v14))
              {
                hx509_certs_add(a1, v28, v24, v10, v11, v12, v13, v14);
                hx509_cert_free(v24);
              }
              ++v17;
              v15 = v38;
              v16 += 288;
            }
            while (v17 < *v38);
          }
        }
        *(_QWORD *)(a2 + 8) = v26.st_mtimespec.tv_sec;
        sub_2096D1E24();
        hx509_certs_free((const void **)(a2 + 168));
        hx509_cert_free(*(_QWORD *)(a2 + 176));
        v4 = 0;
        v18 = v28;
        *(_QWORD *)(a2 + 160) = v38;
        *(_QWORD *)(a2 + 168) = v18;
        v19 = v36;
        *(_OWORD *)(a2 + 112) = v35;
        *(_OWORD *)(a2 + 128) = v19;
        *(_OWORD *)(a2 + 144) = v37;
        v20 = v32;
        *(_OWORD *)(a2 + 48) = v31;
        *(_OWORD *)(a2 + 64) = v20;
        v21 = v34;
        *(_OWORD *)(a2 + 80) = v33;
        *(_OWORD *)(a2 + 96) = v21;
        v22 = v30;
        *(_OWORD *)(a2 + 16) = v29;
        *(_OWORD *)(a2 + 32) = v22;
        *(_QWORD *)(a2 + 176) = 0;
        return v4;
      }
      hx509_set_error_string(a1, 0, v4, "Failed to parse OCSP response", v5, v6, v7, v8, v24);
    }
  }
  return v4;
}

uint64_t hx509_revoke_add_crl(uint64_t a1, uint64_t a2, char *__s1)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  const char *v11;
  const char **v12;
  uint64_t v13;
  char *v14;
  char *v15;
  char *v16;
  uint64_t v17;
  uint64_t v18;

  if (!strncmp(__s1, "FILE:", 5uLL))
  {
    v11 = __s1 + 5;
    v12 = *(const char ***)(a2 + 32);
    v13 = *(_QWORD *)(a2 + 40);
    if (v13 && !strcmp(*v12, v11))
    {
      return 0;
    }
    else
    {
      v14 = (char *)malloc_type_realloc(v12, 192 * v13 + 192, 0x10B00404ADEA4C8uLL);
      if (!v14)
        goto LABEL_9;
      *(_QWORD *)(a2 + 32) = v14;
      v15 = &v14[192 * *(_QWORD *)(a2 + 40)];
      *((_OWORD *)v15 + 10) = 0u;
      *((_OWORD *)v15 + 11) = 0u;
      *((_OWORD *)v15 + 8) = 0u;
      *((_OWORD *)v15 + 9) = 0u;
      *((_OWORD *)v15 + 6) = 0u;
      *((_OWORD *)v15 + 7) = 0u;
      *((_OWORD *)v15 + 4) = 0u;
      *((_OWORD *)v15 + 5) = 0u;
      *((_OWORD *)v15 + 2) = 0u;
      *((_OWORD *)v15 + 3) = 0u;
      *(_OWORD *)v15 = 0u;
      *((_OWORD *)v15 + 1) = 0u;
      v16 = strdup(v11);
      v17 = *(_QWORD *)(a2 + 32);
      v18 = *(_QWORD *)(a2 + 40);
      *(_QWORD *)(v17 + 192 * v18) = v16;
      if (v16)
      {
        v10 = sub_2096D0054(v11, (__darwin_time_t *)(v17 + 192 * v18 + 8), v17 + 192 * v18 + 16);
        if ((_DWORD)v10)
          free(*(void **)(*(_QWORD *)(a2 + 32) + 192 * *(_QWORD *)(a2 + 40)));
        else
          ++*(_QWORD *)(a2 + 40);
      }
      else
      {
LABEL_9:
        hx509_clear_error_string(a1);
        return 12;
      }
    }
  }
  else
  {
    v10 = 569966;
    hx509_set_error_string(a1, 0, 569966, "unsupport type in %s", v6, v7, v8, v9, (char)__s1);
  }
  return v10;
}

uint64_t sub_2096D0054(const char *a1, __darwin_time_t *a2, uint64_t a3)
{
  uint64_t v6;
  void *v8;
  stat v9;
  uint64_t v10;
  off_t v11;

  v10 = 0;
  v11 = 0;
  memset(&v9, 0, sizeof(v9));
  v8 = 0;
  *(_OWORD *)a3 = 0u;
  *(_OWORD *)(a3 + 16) = 0u;
  *(_OWORD *)(a3 + 32) = 0u;
  *(_OWORD *)(a3 + 48) = 0u;
  *(_OWORD *)(a3 + 64) = 0u;
  *(_OWORD *)(a3 + 80) = 0u;
  *(_OWORD *)(a3 + 96) = 0u;
  *(_OWORD *)(a3 + 112) = 0u;
  *(_OWORD *)(a3 + 128) = 0u;
  *(_OWORD *)(a3 + 144) = 0u;
  *(_QWORD *)(a3 + 160) = 0;
  v6 = rk_undumpdata(a1, &v8, &v11);
  if (!(_DWORD)v6)
  {
    if (stat(a1, &v9))
    {
      return *__error();
    }
    else
    {
      *a2 = v9.st_mtimespec.tv_sec;
      v6 = sub_2096D29EC();
      j__free(v8);
      if (!(_DWORD)v6)
      {
        if ((*(_BYTE *)(a3 + 152) & 7) != 0)
        {
          sub_2096D2A3C();
          return 569925;
        }
        else
        {
          return 0;
        }
      }
    }
  }
  return v6;
}

uint64_t hx509_revoke_verify(uint64_t a1, _QWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  const char **v16;
  uint64_t v17;
  _QWORD *v18;
  uint64_t v19;
  uint64_t v20;
  unsigned int *v21;
  int v22;
  uint64_t v23;
  unint64_t v24;
  _QWORD *v25;
  __darwin_ino64_t v26;
  int v27;
  uint64_t v29;
  uint64_t *v30;
  uint64_t v31;
  int v32;
  dev_t v33;
  off_t *p_st_size;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  char v38;
  int v39;
  const char *v40;
  int v41;
  int v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  int v47;
  uint64_t v48;
  uint64_t v49;
  __darwin_time_t *v50;
  uint64_t v51;
  __int128 v52;
  timespec st_atimespec;
  timespec st_mtimespec;
  timespec st_ctimespec;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  uint64_t v60;
  _DWORD *v61;
  int v62;
  uint64_t v63;
  _DWORD *v64;
  int v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  char v71;
  int v72;
  const char *v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  int v79;
  uint64_t v80;
  int v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  int v86;
  uint64_t v87;
  const char *v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  int v93;
  int v94;
  uint64_t v95;
  const char *v96;
  uint64_t v97;
  char v98;
  int v99;
  unsigned int *v100;
  uint64_t v101;
  _QWORD *v102;
  _DWORD *v103;
  uint64_t v104;
  uint64_t i;
  unsigned int *v107;
  uint64_t v108;
  _QWORD *v109;
  char v110;
  int v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v115;
  stat v117;
  __int128 v118;
  uint64_t v119;
  int v120;
  stat v121;
  uint64_t v122;
  uint64_t v123[2];

  v113 = sub_2096BEAC8(a5);
  v115 = a6;
  v9 = sub_2096BEAC8(a6);
  hx509_clear_error_string(a1);
  if (a2[7])
  {
    v14 = 0;
    v111 = 569859;
    do
    {
      v15 = a2[6];
      v16 = (const char **)(v15 + 184 * v14);
      memset(&v117, 0, sizeof(v117));
      if (!stat(*v16, &v117)
        && *(_QWORD *)(v15 + 184 * v14 + 8) != v117.st_mtimespec.tv_sec
        && sub_2096CFD14(a1, (uint64_t)v16))
      {
        goto LABEL_42;
      }
      v17 = v15 + 184 * v14;
      v19 = *(_QWORD *)(v17 + 176);
      v18 = (_QWORD *)(v17 + 176);
      if (v19)
        goto LABEL_7;
      v123[0] = 0;
      memset(&v121, 0, 136);
      sub_2096C1430((uint64_t)&v121);
      v121.st_dev = 4;
      v121.st_mtimespec.tv_sec = sub_2096BEAC8(v115) + 72;
      v31 = v15 + 184 * v14;
      v32 = *(_DWORD *)(v31 + 40);
      switch(v32)
      {
        case 0:
          goto LABEL_42;
        case 2:
          v33 = v121.st_dev | 0x100000;
          p_st_size = &v121.st_size;
          break;
        case 1:
          v33 = v121.st_dev | 8;
          p_st_size = &v121.st_mtimespec.tv_nsec;
          break;
        default:
          goto LABEL_28;
      }
      v121.st_dev = v33;
      *p_st_size = v15 + 184 * v14 + 48;
LABEL_28:
      if (hx509_certs_find(a1, a3, &v121.st_dev, v123, v10, v11, v12, v13))
      {
        v35 = *(_QWORD *)(v15 + 184 * v14 + 168);
        if (!v35 || hx509_certs_find(a1, v35, &v121.st_dev, v123, v10, v11, v12, v13))
          goto LABEL_40;
      }
      if (hx509_cert_cmp(v123[0], v115))
      {
        v112 = sub_2096BEAC8(v115);
        v36 = sub_2096BEAC8(v123[0]);
        if (sub_2096BF41C(v36, v112, 0))
        {
          v37 = a1;
          v38 = 0;
          v39 = v111;
          v40 = "Revoke OCSP signer is doesn't have CA as signer certificate";
LABEL_39:
          hx509_set_error_string(v37, v38, v39, v40, v10, v11, v12, v13, v110);
LABEL_40:
          if (v123[0])
            hx509_cert_free(v123[0]);
          goto LABEL_42;
        }
        v41 = sub_2096C0E48(a1, v115, v36 + 248, v36, (_QWORD *)(v36 + 272), v11, v12, v13);
        if (v41)
        {
          v39 = v41;
          v37 = a1;
          v38 = 1;
          v40 = "OCSP signer signature invalid";
          goto LABEL_39;
        }
        if (hx509_cert_check_eku(a1, v123[0]))
          goto LABEL_40;
      }
      v42 = sub_2096C0E48(a1, v123[0], v15 + 184 * v14 + 120, v31 + 16, (_QWORD *)(v15 + 184 * v14 + 144), v11, v12, v13);
      if (v42)
      {
        v39 = v42;
        v37 = a1;
        v38 = 1;
        v40 = "OCSP signature invalid";
        goto LABEL_39;
      }
      *v18 = v123[0];
LABEL_7:
      v20 = v15 + 184 * v14;
      v22 = *(_DWORD *)(v20 + 96);
      v21 = (unsigned int *)(v20 + 96);
      if (v22)
      {
        v23 = 0;
        v24 = 0;
        v25 = (_QWORD *)(v15 + 184 * v14 + 104);
        do
        {
          *(_QWORD *)&v121.st_dev = 0;
          v121.st_ino = 0;
          if (!der_heim_integer_cmp()
            && !hx509_verify_signature_0(a1, 0, *v25 + (v14 << 7), v113 + 72, *v25 + (v14 << 7) + 24))
          {
            v26 = *(_QWORD *)(v9 + 216);
            *(_QWORD *)&v121.st_dev = *(_QWORD *)(v9 + 208) >> 3;
            v121.st_ino = v26;
            if (!hx509_verify_signature_0(a1, 0, *v25 + v23, (uint64_t)&v121, *v25 + v23 + 40))
            {
              v27 = *(_DWORD *)(*v25 + v23 + 80);
              if (v27 != 3)
              {
                if (v27 == 2 || v27 == 0)
                {
                  hx509_set_error_string(a1, 0, 569955, "Certificate revoked by issuer in OCSP", v10, v11, v12, v13, v110);
                  return 569955;
                }
                v29 = *v25 + v23;
                if (*(_QWORD *)(v29 + 104) <= *(int *)(a1 + 16) + a4)
                {
                  v30 = *(uint64_t **)(v29 + 112);
                  if (!v30 || *v30 >= a4)
                    return 0;
                }
              }
            }
          }
          ++v24;
          v23 += 128;
        }
        while (v24 < *v21);
      }
LABEL_42:
      ++v14;
    }
    while (v14 < a2[7]);
  }
  if (!a2[5])
  {
LABEL_79:
    if ((*(_BYTE *)(a1 + 12) & 1) == 0)
    {
      v95 = 569956;
      v96 = "No revoke status found for certificates";
      v97 = a1;
      v98 = 1;
      goto LABEL_81;
    }
    return 0;
  }
  v43 = 0;
  while (1)
  {
    v44 = a2[4];
    v45 = v44 + 192 * v43;
    memset(&v121, 0, sizeof(v121));
    v120 = 0;
    v46 = v45 + 64;
    v47 = sub_2096CCD90(v113 + 72, v45 + 64, &v120);
    if (v47 | v120)
      goto LABEL_65;
    v48 = v45 + 16;
    if (!stat(*(const char **)v45, &v121))
    {
      v49 = v44 + 192 * v43;
      v51 = *(_QWORD *)(v49 + 8);
      v50 = (__darwin_time_t *)(v49 + 8);
      if (v51 != v121.st_mtimespec.tv_sec)
      {
        v119 = 0;
        v118 = 0u;
        memset(&v117, 0, sizeof(v117));
        if (!sub_2096D0054(*(const char **)v45, v50, (uint64_t)&v117))
        {
          sub_2096D2A3C();
          v52 = *(_OWORD *)&v117.st_dev;
          st_atimespec = v117.st_atimespec;
          *(_OWORD *)(v45 + 32) = *(_OWORD *)&v117.st_uid;
          *(timespec *)(v45 + 48) = st_atimespec;
          *(_OWORD *)v48 = v52;
          st_mtimespec = v117.st_mtimespec;
          st_ctimespec = v117.st_ctimespec;
          v56 = *(_OWORD *)&v117.st_size;
          *(timespec *)(v45 + 96) = v117.st_birthtimespec;
          *(_OWORD *)(v45 + 112) = v56;
          *(timespec *)(v45 + 64) = st_mtimespec;
          *(timespec *)(v45 + 80) = st_ctimespec;
          v57 = *(_OWORD *)&v117.st_blksize;
          v58 = *(_OWORD *)v117.st_qspare;
          v59 = v118;
          *(_QWORD *)(v45 + 176) = v119;
          *(_OWORD *)(v45 + 144) = v58;
          *(_OWORD *)(v45 + 160) = v59;
          *(_OWORD *)(v45 + 128) = v57;
          *(_QWORD *)(v44 + 192 * v43 + 184) = 0;
        }
      }
    }
    v60 = v44 + 192 * v43;
    v62 = *(_DWORD *)(v60 + 188);
    v61 = (_DWORD *)(v60 + 188);
    if (v62)
      goto LABEL_65;
    v63 = v44 + 192 * v43;
    v65 = *(_DWORD *)(v63 + 184);
    v64 = (_DWORD *)(v63 + 184);
    if (v65)
      goto LABEL_85;
    v123[0] = 0;
    memset(&v117, 0, 136);
    if (sub_2096BFCF0(v48 + 88) <= a4)
      break;
    v70 = a1;
    v71 = 0;
    v72 = 569952;
    v73 = "CRL used before time";
LABEL_63:
    hx509_set_error_string(v70, v71, v72, v73, v66, v67, v68, v69, v110);
LABEL_64:
    *v61 = 1;
LABEL_65:
    if ((unint64_t)++v43 >= a2[5])
      goto LABEL_79;
  }
  v74 = *(_QWORD *)(v48 + 104);
  if (!v74)
  {
    v70 = a1;
    v71 = 0;
    v72 = 569954;
    v73 = "CRL missing nextUpdate";
    goto LABEL_63;
  }
  if (sub_2096BFCF0(v74) < a4)
  {
    v70 = a1;
    v71 = 0;
    v72 = 569953;
    v73 = "CRL used after time";
    goto LABEL_63;
  }
  sub_2096C1430((uint64_t)&v117);
  if (!sub_2096BF2A0(a1, v115, 64, 0))
  {
    v80 = hx509_cert_ref(v115);
    v123[0] = v80;
    goto LABEL_69;
  }
  v117.st_dev = 1032;
  v117.st_mtimespec.tv_nsec = v46;
  v79 = hx509_certs_find(a1, a3, &v117.st_dev, v123, v75, v76, v77, v78);
  if (v79)
  {
    v72 = v79;
    v70 = a1;
    v71 = 1;
    v73 = "Failed to find certificate for CRL";
    goto LABEL_63;
  }
  v80 = v123[0];
LABEL_69:
  v81 = sub_2096C0E48(a1, v80, v44 + 192 * v43 + 144, v48, (_QWORD *)(v44 + 192 * v43 + 168), v67, v68, v69);
  if (v81)
  {
    v86 = v81;
    v87 = a1;
    v88 = "CRL signature invalid";
LABEL_71:
    hx509_set_error_string(v87, 1, v86, v88, v82, v83, v84, v85, v110);
    hx509_cert_free(v123[0]);
    goto LABEL_64;
  }
  if (sub_2096BF2A0(a1, v123[0], 32, 1))
  {
    while (1)
    {
      v122 = 0;
      sub_2096C1430((uint64_t)&v117);
      v117.st_dev = 1032;
      v117.st_mtimespec.tv_nsec = sub_2096BEAC8(v123[0]) + 72;
      v93 = hx509_certs_find(a1, a3, &v117.st_dev, &v122, v89, v90, v91, v92);
      if (v93)
      {
        v86 = v93;
        v87 = a1;
        v88 = "Failed to find parent of CRL signer";
        goto LABEL_71;
      }
      v94 = hx509_revoke_verify(a1, a2, a3, a4, v123[0], v122);
      hx509_cert_free(v123[0]);
      v123[0] = v122;
      v87 = a1;
      if (v94)
        break;
      if (!sub_2096BF2A0(a1, v122, 32, 1))
        goto LABEL_84;
    }
    v86 = v94;
    v88 = "Failed to verify revoke status of CRL signer";
    goto LABEL_71;
  }
LABEL_84:
  hx509_cert_free(v123[0]);
  *v64 = 1;
LABEL_85:
  v100 = *(unsigned int **)(v48 + 120);
  if (v100)
  {
    v101 = *v100;
    if ((_DWORD)v101)
    {
      v102 = (_QWORD *)(*((_QWORD *)v100 + 1) + 16);
      while (!*v102)
      {
        v102 += 5;
        if (!--v101)
          goto LABEL_90;
      }
      v95 = 569957;
      v96 = "Unknown CRL extension";
      v97 = a1;
      v98 = 0;
LABEL_81:
      v99 = v95;
LABEL_82:
      hx509_set_error_string(v97, v98, v99, v96, v10, v11, v12, v13, v110);
      return v95;
    }
  }
LABEL_90:
  v103 = *(_DWORD **)(v48 + 112);
  if (!v103 || !*v103)
    return 0;
  v104 = 0;
  for (i = 40;
        der_heim_integer_cmp() || sub_2096BFCF0(*(_QWORD *)(*(_QWORD *)(v48 + 112) + 8) + i - 16) > a4;
        i += 48)
  {
    if (++v104 >= (unint64_t)**(unsigned int **)(v48 + 112))
      return 0;
  }
  v107 = *(unsigned int **)(*(_QWORD *)(*(_QWORD *)(v48 + 112) + 8) + i);
  v95 = 569955;
  if (!v107 || (v108 = *v107, !(_DWORD)v108))
  {
LABEL_104:
    v96 = "Certificate revoked by issuer in CRL";
    v97 = a1;
    v98 = 0;
    v99 = 569955;
    goto LABEL_82;
  }
  v109 = (_QWORD *)(*((_QWORD *)v107 + 1) + 16);
  while (!*v109)
  {
    v109 += 5;
    if (!--v108)
      goto LABEL_104;
  }
  return 569957;
}

uint64_t hx509_ocsp_request(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  void *v10;
  uint64_t v11;
  _DWORD *v12;
  _DWORD *v13;
  void *v14;
  void *v15;
  uint64_t v16;
  size_t v17;
  void *v18;
  uint64_t v19;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  char v28;
  _QWORD v29[3];
  uint64_t v30;
  uint64_t v31;
  _OWORD v32[3];
  __int128 v33;

  v31 = 0;
  memset(v32, 0, sizeof(v32));
  v33 = 0u;
  v10 = off_2545A7098;
  if (a5)
    v10 = (void *)a5;
  v29[0] = v32;
  v29[1] = a3;
  v29[2] = v10;
  v30 = 0;
  v11 = hx509_certs_iter_f(a1, a2, (uint64_t (*)(uint64_t, uint64_t))sub_2096D0BF4, (uint64_t)v29, a5, a6, a7, a8);
  hx509_cert_free(v30);
  if ((_DWORD)v11)
    goto LABEL_19;
  if (!a7)
    goto LABEL_14;
  v12 = malloc_type_calloc(1uLL, 0x10uLL, 0x1020040D5A9D86FuLL);
  *(_QWORD *)&v33 = v12;
  if (!v12)
    goto LABEL_12;
  v13 = v12;
  *v12 = 1;
  v14 = malloc_type_calloc(1uLL, 0x28uLL, 0x1090040B832695BuLL);
  *((_QWORD *)v13 + 1) = v14;
  if (!v14)
  {
    *v13 = 0;
    goto LABEL_12;
  }
  v11 = der_copy_oid();
  if ((_DWORD)v11)
  {
LABEL_19:
    sub_2096D1DC4();
    return v11;
  }
  v15 = malloc_type_malloc(0xAuLL, 0xBE068C00uLL);
  v16 = *((_QWORD *)v13 + 1);
  *(_QWORD *)(v16 + 32) = v15;
  if (!v15)
    goto LABEL_12;
  *(_QWORD *)(v16 + 24) = 10;
  if (CCRandomGenerateBytes(v15, 0xAuLL))
  {
    v11 = 569920;
    goto LABEL_19;
  }
  if (der_copy_octet_string())
  {
LABEL_12:
    v11 = 12;
    goto LABEL_19;
  }
LABEL_14:
  v17 = sub_2096D1DB4();
  *(_QWORD *)a6 = v17;
  v18 = malloc_type_malloc(v17, 0xD5368271uLL);
  *(_QWORD *)(a6 + 8) = v18;
  if (!v18)
  {
    v11 = 12;
    goto LABEL_18;
  }
  v19 = sub_2096D1D94();
  if ((_DWORD)v19)
  {
    v11 = v19;
    free(*(void **)(a6 + 8));
    *(_QWORD *)(a6 + 8) = 0;
LABEL_18:
    sub_2096D1DC4();
    goto LABEL_19;
  }
  sub_2096D1DC4();
  if (v31 != *(_QWORD *)a6)
    sub_2096C1D6C("internal ASN.1 encoder error", v21, v22, v23, v24, v25, v26, v27, v28);
  return 0;
}

uint64_t sub_2096D0BF4(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v5;
  void *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  _OWORD v22[8];
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;

  v26 = 0;
  v5 = sub_2096BEAC8(a3);
  v23 = 0;
  memset(v22, 0, sizeof(v22));
  v6 = malloc_type_realloc(*(void **)(*a2 + 40), 88 * (*(_DWORD *)(*a2 + 32) + 1), 0x10B0040E743F4D9uLL);
  if (!v6)
    return 12;
  v24 = 0;
  v25 = 0;
  v7 = *a2;
  *(_QWORD *)(v7 + 40) = v6;
  v8 = (uint64_t)v6 + 88 * *(unsigned int *)(v7 + 32);
  *(_QWORD *)(v8 + 80) = 0;
  *(_OWORD *)(v8 + 48) = 0u;
  *(_OWORD *)(v8 + 64) = 0u;
  *(_OWORD *)(v8 + 16) = 0u;
  *(_OWORD *)(v8 + 32) = 0u;
  *(_OWORD *)v8 = 0u;
  sub_2096C1430((uint64_t)v22);
  LODWORD(v22[0]) |= 1u;
  *((_QWORD *)&v22[0] + 1) = v5;
  v13 = hx509_certs_find(a1, a2[1], (int *)v22, &v26, v9, v10, v11, v12);
  if (!(_DWORD)v13)
  {
    v15 = a2[3];
    if (v15)
    {
      if (hx509_cert_cmp(v15, v26))
      {
        v13 = 569959;
        hx509_set_error_string(a1, 0, 569959, "Not same parent certifate as last certificate in request", v16, v17, v18, v19, v22[0]);
        goto LABEL_3;
      }
    }
    else
    {
      a2[3] = hx509_cert_ref(v26);
    }
    v20 = sub_2096BEAC8(v26);
    v13 = copy_AlgorithmIdentifier();
    if (!(_DWORD)v13)
    {
      v13 = sub_2096C4F38(a1, 0, v8, v5 + 72, 0, v8 + 24);
      if (!(_DWORD)v13)
      {
        v21 = *(_QWORD *)(v20 + 216);
        v24 = *(_QWORD *)(v20 + 208) >> 3;
        v25 = v21;
        v13 = sub_2096C4F38(a1, 0, v8, (uint64_t)&v24, 0, v8 + 40);
        if (!(_DWORD)v13)
        {
          v13 = sub_2096D2090();
          if (!(_DWORD)v13)
          {
            ++*(_DWORD *)(*a2 + 32);
            hx509_cert_free(v26);
            return v13;
          }
        }
      }
    }
  }
LABEL_3:
  hx509_cert_free(v26);
  sub_2096D1D84();
  *(_QWORD *)(v8 + 80) = 0;
  *(_OWORD *)(v8 + 48) = 0u;
  *(_OWORD *)(v8 + 64) = 0u;
  *(_OWORD *)(v8 + 16) = 0u;
  *(_OWORD *)(v8 + 32) = 0u;
  *(_OWORD *)v8 = 0u;
  return v13;
}

uint64_t hx509_revoke_ocsp_print(uint64_t a1, char *__s1, FILE *a3)
{
  FILE *v4;
  FILE *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;
  const char *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  char v24;
  char *v25;
  void *v26;
  char *v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;

  v4 = (FILE *)*MEMORY[0x24BDAC8E8];
  v28 = 0u;
  v29 = 0u;
  if (a3)
    v5 = a3;
  else
    v5 = v4;
  v30 = 0uLL;
  v31 = 0uLL;
  v32 = 0uLL;
  v33 = 0uLL;
  v34 = 0uLL;
  v35 = 0uLL;
  v36 = 0uLL;
  v37 = 0uLL;
  v38 = 0uLL;
  v27 = strdup(__s1);
  if (v27)
  {
    v6 = sub_2096CFD14(a1, (uint64_t)&v27);
    if ((_DWORD)v6)
    {
LABEL_25:
      sub_2096D10A4((uint64_t)&v27);
      return v6;
    }
    fwrite("signer: ", 8uLL, 1uLL, v5);
    switch((_DWORD)v30)
    {
      case 1:
        v25 = 0;
        v26 = 0;
        hx509_name_from_Name((uint64_t)&v30 + 8, &v26);
        hx509_name_to_string(v26, &v25);
        hx509_name_free(&v26);
        fprintf(v5, " byName: %s\n", v25);
        v14 = v25;
        break;
      case 2:
        v26 = 0;
        rk_hex_encode((char *)v31, *((uint64_t *)&v30 + 1), &v26);
        fprintf(v5, " byKey: %s\n", (const char *)v26);
        v14 = (char *)v26;
        break;
      case 0:
        sub_2096C1D6C("choice_OCSPResponderID unknown", v7, v8, v9, v10, v11, v12, v13, v24);
      default:
        goto LABEL_14;
    }
    free(v14);
LABEL_14:
    sub_2096D10DC(v33);
    fprintf(v5, "producedAt: %s\n", byte_2545A7FA0);
    fprintf(v5, "replies: %d\n", DWORD2(v33));
    if (DWORD2(v33))
    {
      v15 = 0;
      v16 = 0;
      do
      {
        v17 = *(int *)(v34 + v15 + 80);
        if (v17 > 3)
          v18 = 0;
        else
          v18 = off_24C1F6848[v17];
        fprintf(v5, "\t%zu. status: %s\n", v16, v18);
        sub_2096D10DC(*(_QWORD *)(v34 + v15 + 104));
        fprintf(v5, "\tthisUpdate: %s\n", byte_2545A7FA0);
        if (*(_QWORD *)(v34 + v15 + 112))
        {
          sub_2096D10DC(*(_QWORD *)(v34 + v15 + 104));
          fprintf(v5, "\tproducedAt: %s\n", byte_2545A7FA0);
        }
        ++v16;
        v15 += 128;
      }
      while (v16 < DWORD2(v33));
    }
    fwrite("appended certs:\n", 0x10uLL, 1uLL, v5);
    if ((_QWORD)v38)
      v6 = hx509_certs_iter_f(a1, v38, (uint64_t (*)(uint64_t, uint64_t))hx509_ci_print_names, (uint64_t)v5, v19, v20, v21, v22);
    else
      v6 = 0;
    goto LABEL_25;
  }
  return 12;
}

uint64_t sub_2096D10A4(uint64_t a1)
{
  free(*(void **)a1);
  sub_2096D1E24();
  hx509_certs_free((const void **)(a1 + 168));
  return hx509_cert_free(*(_QWORD *)(a1 + 176));
}

uint64_t sub_2096D10DC(time_t a1)
{
  uint64_t result;
  time_t v2;

  v2 = a1;
  if (!ctime(&v2))
    return __strlcpy_chk();
  result = __strlcpy_chk();
  byte_2545A7FB4 = 0;
  return result;
}

uint64_t hx509_ocsp_verify(uint64_t a1, time_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, time_t *a7)
{
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  uint64_t v22;
  unsigned int v23;
  BOOL v24;
  time_t *v25;
  time_t v26;
  int v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  char v33;
  void *v34;
  void *v35;
  _OWORD v36[5];
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  uint64_t v41;

  v13 = sub_2096BEAC8(a3);
  if (!a2)
    a2 = time(0);
  v41 = 0;
  v39 = 0u;
  v40 = 0u;
  v37 = 0u;
  v38 = 0u;
  memset(v36, 0, sizeof(v36));
  *a7 = 0;
  v14 = sub_2096D1354(a5, a6, (uint64_t)v36);
  if ((_DWORD)v14)
  {
    v19 = v14;
    hx509_set_error_string(a1, 0, v14, "Failed to parse OCSP response", v15, v16, v17, v18, v33);
  }
  else if ((_DWORD)v37)
  {
    v20 = 0;
    v21 = 0;
    v22 = v13 + 72;
    while (1)
    {
      if (!der_heim_integer_cmp()
        && !hx509_verify_signature_0(a1, 0, *((_QWORD *)&v37 + 1) + v20, v22, *((_QWORD *)&v37 + 1) + v20 + 24))
      {
        v23 = *(_DWORD *)(*((_QWORD *)&v37 + 1) + v20 + 80);
        v24 = v23 > 3 || v23 == 1;
        if (v24 && *(_QWORD *)(*((_QWORD *)&v37 + 1) + v20 + 104) <= a2 + *(int *)(a1 + 16))
        {
          v25 = *(time_t **)(*((_QWORD *)&v37 + 1) + v20 + 112);
          if (!v25)
            goto LABEL_19;
          v26 = *v25;
          if (v26 >= a2)
            break;
        }
      }
      ++v21;
      v20 += 128;
      if (v21 >= v37)
        goto LABEL_20;
    }
    a2 = v26;
LABEL_19:
    *a7 = a2;
    sub_2096D1E24();
    return 0;
  }
  else
  {
LABEL_20:
    v19 = 569960;
    sub_2096D1E24();
    v34 = 0;
    v35 = 0;
    if (hx509_cert_get_subject(a3, &v35)
      || (v27 = hx509_name_to_string(v35, &v34), hx509_name_free(&v35), v27))
    {
      hx509_clear_error_string(a1);
    }
    else
    {
      hx509_set_error_string(a1, 0, 569960, "Certificate %s not in OCSP response or not good", v28, v29, v30, v31, (char)v34);
      free(v34);
    }
  }
  return v19;
}

uint64_t sub_2096D1354(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;

  *(_OWORD *)a3 = 0u;
  *(_OWORD *)(a3 + 16) = 0u;
  *(_OWORD *)(a3 + 32) = 0u;
  *(_OWORD *)(a3 + 48) = 0u;
  *(_OWORD *)(a3 + 64) = 0u;
  *(_OWORD *)(a3 + 80) = 0u;
  *(_OWORD *)(a3 + 96) = 0u;
  *(_OWORD *)(a3 + 112) = 0u;
  *(_OWORD *)(a3 + 128) = 0u;
  *(_QWORD *)(a3 + 144) = 0;
  v4 = sub_2096D1DD4();
  if (!(_DWORD)v4)
  {
    if (a2)
    {
      v4 = 1859794442;
      sub_2096D1DF4();
    }
    else
    {
      sub_2096D1DF4();
      return 22;
    }
  }
  return v4;
}

uint64_t hx509_crl_alloc(uint64_t a1, _QWORD *a2)
{
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  char v12;

  v4 = malloc_type_calloc(1uLL, 0x10uLL, 0x1020040EDED9539uLL);
  *a2 = v4;
  if (v4)
  {
    v9 = hx509_certs_init(a1, "MEMORY:crl", 0, 0, v4);
    v10 = (_QWORD *)*a2;
    if ((_DWORD)v9)
    {
      free(v10);
      *a2 = 0;
    }
    else
    {
      v10[1] = 0;
    }
  }
  else
  {
    v9 = 12;
    hx509_set_error_string(a1, 0, 12, "out of memory", v5, v6, v7, v8, v12);
  }
  return v9;
}

uint64_t hx509_crl_add_revoked_certs(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return hx509_certs_merge(a1, *a2, a3, a4, a5, a6, a7, a8);
}

uint64_t hx509_crl_lifetime(uint64_t a1, uint64_t a2, int a3)
{
  *(_QWORD *)(a2 + 8) = time(0) + a3;
  return 0;
}

void hx509_crl_free(uint64_t a1, const void ***a2)
{
  const void **v3;

  if (*a2)
  {
    hx509_certs_free(*a2);
    v3 = *a2;
    *v3 = 0;
    v3[1] = 0;
    free(*a2);
    *a2 = 0;
  }
}

uint64_t hx509_crl_sign(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  void *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  _DWORD *v15;
  uint64_t v16;
  uint64_t v17;
  const char *v18;
  uint64_t v19;
  int v20;
  _QWORD *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  time_t v27;
  size_t v28;
  void *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  const char *v38;
  uint64_t v39;
  int v40;
  size_t v41;
  void *v42;
  uint64_t v43;
  char v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  void *v52[2];
  __int128 v53;
  __int128 v54;
  uint64_t v55;

  v8 = off_2545A7090;
  v45 = 0u;
  v46 = 0u;
  v47 = 0u;
  v48 = 0u;
  v49 = 0u;
  v50 = 0u;
  v51 = 0u;
  *(_OWORD *)v52 = 0u;
  v53 = 0u;
  v54 = 0u;
  v55 = 0;
  v9 = _hx509_cert_private_key(a2);
  if (!v9)
  {
    v17 = 569865;
    v18 = "Private key missing for CRL signing";
    v19 = a1;
    v20 = 569865;
LABEL_9:
    hx509_set_error_string(v19, 0, v20, v18, v10, v11, v12, v13, v44);
    return v17;
  }
  v14 = v9;
  v15 = malloc_type_malloc(4uLL, 0x100004052888210uLL);
  *(_QWORD *)&v46 = v15;
  if (!v15)
  {
    v18 = "out of memory";
    v17 = 12;
    v19 = a1;
    v20 = 12;
    goto LABEL_9;
  }
  *v15 = 1;
  v16 = copy_AlgorithmIdentifier();
  if (!(_DWORD)v16)
  {
    sub_2096BEAC8(a2);
    v16 = hx509_name_to_Name_0();
    if (!(_DWORD)v16)
    {
      DWORD2(v50) = 2;
      *(_QWORD *)&v51 = time(0) - 86400;
      v22 = malloc_type_malloc(0x10uLL, 0x1000040F7F8B94BuLL);
      *((_QWORD *)&v51 + 1) = v22;
      if (!v22)
        goto LABEL_21;
      v27 = a3[1];
      if (!v27)
      {
        v27 = time(0) + 31536000;
        v22 = (_QWORD *)*((_QWORD *)&v51 + 1);
      }
      *(_DWORD *)v22 = 2;
      v22[1] = v27;
      v52[0] = malloc_type_calloc(1uLL, 0x10uLL, 0x1020040D5A9D86FuLL);
      if (!v52[0])
      {
LABEL_21:
        v38 = "out of memory";
        v17 = 12;
        v39 = a1;
        v40 = 12;
LABEL_22:
        hx509_set_error_string(v39, 0, v40, v38, v23, v24, v25, v26, v44);
        goto LABEL_6;
      }
      v52[1] = 0;
      v17 = hx509_certs_iter_f(a1, *a3, sub_2096D1910, (uint64_t)&v45, v23, v24, v25, v26);
      if ((_DWORD)v17)
        goto LABEL_6;
      if (!*(_DWORD *)v52[0])
      {
        free(v52[0]);
        v52[0] = 0;
      }
      v28 = sub_2096D29DC();
      *(_QWORD *)a4 = v28;
      v29 = malloc_type_malloc(v28, 0xEE5AB767uLL);
      *(_QWORD *)(a4 + 8) = v29;
      if (!v29)
      {
        v17 = 12;
        goto LABEL_24;
      }
      v30 = sub_2096D29BC();
      if ((_DWORD)v30)
      {
        v17 = v30;
        free(*(void **)(a4 + 8));
        *(_QWORD *)(a4 + 8) = 0;
LABEL_24:
        v38 = "failed to encode tbsCRL";
LABEL_25:
        v39 = a1;
        v40 = v17;
        goto LABEL_22;
      }
      if (!*(_QWORD *)a4)
      {
        v17 = sub_2096C5050(a1, v14, (uint64_t)v8, a4, (uint64_t)&v53, (_QWORD *)&v54 + 1);
        free(*(void **)(a4 + 8));
        if ((_DWORD)v17)
        {
          v38 = "Failed to sign CRL";
          goto LABEL_25;
        }
        v41 = sub_2096D2A2C();
        *(_QWORD *)a4 = v41;
        v42 = malloc_type_malloc(v41, 0xD477AAF3uLL);
        *(_QWORD *)(a4 + 8) = v42;
        if (!v42)
        {
          v17 = 12;
          goto LABEL_33;
        }
        v43 = sub_2096D2A0C();
        if ((_DWORD)v43)
        {
          v17 = v43;
          free(*(void **)(a4 + 8));
          *(_QWORD *)(a4 + 8) = 0;
LABEL_33:
          v38 = "failed to encode CRL";
          goto LABEL_25;
        }
        if (!*(_QWORD *)a4)
        {
          sub_2096D2A3C();
          return 0;
        }
      }
      sub_2096C1D6C("internal ASN.1 encoder error", v31, v32, v33, v34, v35, v36, v37, v44);
    }
  }
  v17 = v16;
  hx509_clear_error_string(a1);
LABEL_6:
  sub_2096D2A3C();
  return v17;
}

uint64_t sub_2096D1910(uint64_t a1, uint64_t a2)
{
  void **v4;
  uint64_t v5;
  void *v6;
  uint64_t serialnumber;
  uint64_t v8;

  v4 = *(void ***)(a2 + 112);
  v5 = *(unsigned int *)v4;
  v6 = malloc_type_realloc(v4[1], 48 * (v5 + 1), 0x10A00401C1B0557uLL);
  if (v6)
  {
    *(_QWORD *)(*(_QWORD *)(a2 + 112) + 8) = v6;
    serialnumber = hx509_cert_get_serialnumber();
    if ((_DWORD)serialnumber)
    {
      hx509_clear_error_string(a1);
    }
    else
    {
      *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 112) + 8) + 48 * v5 + 24) = 2;
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 112) + 8) + 48 * v5 + 32) = time(0) - 86400;
      v8 = *(_QWORD *)(a2 + 112);
      *(_QWORD *)(*(_QWORD *)(v8 + 8) + 48 * v5 + 40) = 0;
      ++*(_DWORD *)v8;
    }
  }
  else
  {
    hx509_clear_error_string(a1);
    return 12;
  }
  return serialnumber;
}

uint64_t sub_2096D1A00(unsigned int *a1)
{
  void *v2;
  uint64_t result;

  v2 = malloc_type_realloc(*((void **)a1 + 1), 24 * *a1 + 24, 0x7EF1AAFAuLL);
  if (!v2)
    return 12;
  *((_QWORD *)a1 + 1) = v2;
  result = _asn1_copy_top();
  if (!(_DWORD)result)
    ++*a1;
  return result;
}

uint64_t sub_2096D1A7C()
{
  return _asn1_decode_top();
}

uint64_t sub_2096D1A9C()
{
  return _asn1_encode();
}

uint64_t sub_2096D1ABC()
{
  return _asn1_length();
}

uint64_t sub_2096D1ACC()
{
  return _asn1_decode_top();
}

uint64_t sub_2096D1AEC()
{
  return _asn1_encode();
}

uint64_t sub_2096D1B0C()
{
  return _asn1_length();
}

uint64_t sub_2096D1B1C()
{
  return _asn1_decode_top();
}

uint64_t encode_ContentInfo()
{
  return _asn1_encode();
}

uint64_t length_ContentInfo()
{
  return _asn1_length();
}

uint64_t free_ContentInfo()
{
  return _asn1_free_top();
}

uint64_t sub_2096D1B7C()
{
  return _asn1_copy_top();
}

uint64_t decode_IssuerAndSerialNumber()
{
  return _asn1_decode_top();
}

uint64_t encode_IssuerAndSerialNumber()
{
  return _asn1_encode();
}

uint64_t length_IssuerAndSerialNumber()
{
  return _asn1_length();
}

uint64_t free_IssuerAndSerialNumber()
{
  return _asn1_free_top();
}

uint64_t copy_IssuerAndSerialNumber()
{
  return _asn1_copy_top();
}

uint64_t sub_2096D1C04()
{
  return _asn1_encode();
}

uint64_t sub_2096D1C24()
{
  return _asn1_length();
}

uint64_t sub_2096D1C34()
{
  return _asn1_free_top();
}

uint64_t sub_2096D1C44()
{
  return _asn1_decode_top();
}

uint64_t sub_2096D1C64()
{
  return _asn1_encode();
}

uint64_t sub_2096D1C84()
{
  return _asn1_length();
}

uint64_t sub_2096D1C94()
{
  return _asn1_free_top();
}

uint64_t sub_2096D1CA4()
{
  return _asn1_decode_top();
}

uint64_t sub_2096D1CC4()
{
  return _asn1_free_top();
}

uint64_t sub_2096D1CD4()
{
  return _asn1_decode_top();
}

uint64_t sub_2096D1CF4()
{
  return _asn1_encode();
}

uint64_t sub_2096D1D14()
{
  return _asn1_length();
}

uint64_t sub_2096D1D24()
{
  return _asn1_free_top();
}

uint64_t sub_2096D1D34()
{
  return _asn1_decode_top();
}

uint64_t sub_2096D1D54()
{
  return _asn1_encode();
}

uint64_t sub_2096D1D74()
{
  return _asn1_length();
}

uint64_t sub_2096D1D84()
{
  return _asn1_free_top();
}

uint64_t sub_2096D1D94()
{
  return _asn1_encode();
}

uint64_t sub_2096D1DB4()
{
  return _asn1_length();
}

uint64_t sub_2096D1DC4()
{
  return _asn1_free_top();
}

uint64_t sub_2096D1DD4()
{
  return _asn1_decode_top();
}

uint64_t sub_2096D1DF4()
{
  return _asn1_free_top();
}

uint64_t sub_2096D1E04()
{
  return _asn1_decode_top();
}

uint64_t sub_2096D1E24()
{
  return _asn1_free_top();
}

uint64_t sub_2096D1E34()
{
  return _asn1_encode();
}

uint64_t sub_2096D1E54()
{
  return _asn1_length();
}

uint64_t sub_2096D1E64()
{
  return _asn1_decode_top();
}

uint64_t sub_2096D1E84()
{
  return _asn1_encode();
}

uint64_t sub_2096D1EA4()
{
  return _asn1_length();
}

uint64_t sub_2096D1EB4()
{
  return _asn1_free_top();
}

uint64_t decode_AlgorithmIdentifier()
{
  return _asn1_decode_top();
}

uint64_t encode_AlgorithmIdentifier()
{
  return _asn1_encode();
}

uint64_t length_AlgorithmIdentifier()
{
  return _asn1_length();
}

uint64_t free_AlgorithmIdentifier()
{
  return _asn1_free_top();
}

uint64_t copy_AlgorithmIdentifier()
{
  return _asn1_copy_top();
}

uint64_t sub_2096D1F38()
{
  return _asn1_decode_top();
}

uint64_t sub_2096D1F58()
{
  return _asn1_encode();
}

uint64_t sub_2096D1F78()
{
  return _asn1_length();
}

uint64_t sub_2096D1F88()
{
  return _asn1_free_top();
}

uint64_t sub_2096D1F98()
{
  return _asn1_copy_top();
}

uint64_t sub_2096D1FAC()
{
  return _asn1_free_top();
}

uint64_t sub_2096D1FBC()
{
  return _asn1_decode_top();
}

uint64_t sub_2096D1FDC()
{
  return _asn1_encode();
}

uint64_t sub_2096D1FFC()
{
  return _asn1_length();
}

uint64_t sub_2096D200C()
{
  return _asn1_free_top();
}

uint64_t hx509_name_to_Name_0()
{
  return _asn1_copy_top();
}

uint64_t sub_2096D2030()
{
  return _asn1_decode_top();
}

uint64_t sub_2096D2050()
{
  return _asn1_encode();
}

uint64_t sub_2096D2070()
{
  return _asn1_length();
}

uint64_t sub_2096D2080()
{
  return _asn1_free_top();
}

uint64_t sub_2096D2090()
{
  return _asn1_copy_top();
}

uint64_t decode_SubjectPublicKeyInfo()
{
  return _asn1_decode_top();
}

uint64_t encode_SubjectPublicKeyInfo()
{
  return _asn1_encode();
}

uint64_t length_SubjectPublicKeyInfo()
{
  return _asn1_length();
}

uint64_t free_SubjectPublicKeyInfo()
{
  return _asn1_free_top();
}

uint64_t copy_SubjectPublicKeyInfo()
{
  return _asn1_copy_top();
}

uint64_t sub_2096D2118()
{
  return _asn1_free_top();
}

uint64_t sub_2096D2128()
{
  return _asn1_decode_top();
}

uint64_t sub_2096D2148()
{
  return _asn1_encode();
}

uint64_t sub_2096D2168()
{
  return _asn1_length();
}

uint64_t sub_2096D2178()
{
  return _asn1_free_top();
}

uint64_t sub_2096D2188()
{
  return _asn1_copy_top();
}

uint64_t sub_2096D219C(unsigned int *a1)
{
  void *v2;
  uint64_t result;

  v2 = malloc_type_realloc(*((void **)a1 + 1), 40 * *a1 + 40, 0x78E804E3uLL);
  if (!v2)
    return 12;
  *((_QWORD *)a1 + 1) = v2;
  result = _asn1_copy_top();
  if (!(_DWORD)result)
    ++*a1;
  return result;
}

uint64_t sub_2096D2218()
{
  return _asn1_encode();
}

uint64_t sub_2096D2238()
{
  return _asn1_length();
}

uint64_t sub_2096D2248()
{
  return _asn1_decode_top();
}

uint64_t sub_2096D2268()
{
  return _asn1_encode();
}

uint64_t sub_2096D2288()
{
  return _asn1_length();
}

uint64_t sub_2096D2298()
{
  return _asn1_free_top();
}

uint64_t sub_2096D22A8()
{
  return _asn1_copy_top();
}

uint64_t decode_DomainParameters()
{
  return _asn1_decode_top();
}

uint64_t sub_2096D22DC()
{
  return _asn1_encode();
}

uint64_t sub_2096D22FC()
{
  return _asn1_length();
}

uint64_t free_DomainParameters()
{
  return _asn1_free_top();
}

uint64_t sub_2096D231C()
{
  return _asn1_encode();
}

uint64_t sub_2096D233C()
{
  return _asn1_length();
}

uint64_t sub_2096D234C()
{
  return _asn1_free_top();
}

uint64_t decode_DHPublicKey()
{
  return _asn1_decode_top();
}

uint64_t encode_DHPublicKey()
{
  return _asn1_encode();
}

uint64_t length_DHPublicKey()
{
  return _asn1_length();
}

uint64_t sub_2096D23AC()
{
  return _asn1_free_top();
}

uint64_t decode_GeneralName()
{
  return _asn1_decode_top();
}

uint64_t encode_GeneralName()
{
  return _asn1_encode();
}

uint64_t length_GeneralName()
{
  return _asn1_length();
}

uint64_t free_GeneralName()
{
  return _asn1_free_top();
}

uint64_t copy_GeneralName()
{
  return _asn1_copy_top();
}

uint64_t sub_2096D2430()
{
  return _asn1_decode_top();
}

uint64_t sub_2096D2450()
{
  return _asn1_encode();
}

uint64_t sub_2096D2470()
{
  return _asn1_length();
}

uint64_t sub_2096D2480()
{
  return _asn1_free_top();
}

uint64_t sub_2096D2490(unsigned int *a1)
{
  void *v2;
  uint64_t result;

  v2 = malloc_type_realloc(*((void **)a1 + 1), 40 * *a1 + 40, 0xA85F3D3FuLL);
  if (!v2)
    return 12;
  *((_QWORD *)a1 + 1) = v2;
  result = _asn1_copy_top();
  if (!(_DWORD)result)
    ++*a1;
  return result;
}

uint64_t sub_2096D250C()
{
  return _asn1_decode_top();
}

uint64_t sub_2096D252C()
{
  return _asn1_encode();
}

uint64_t sub_2096D254C()
{
  return _asn1_length();
}

uint64_t sub_2096D255C(__int16 a1)
{
  return a1 & 0x1FF;
}

uint64_t sub_2096D2564()
{
  return _asn1_decode_top();
}

uint64_t sub_2096D2584()
{
  return _asn1_encode();
}

uint64_t sub_2096D25A4()
{
  return _asn1_length();
}

uint64_t sub_2096D25B4()
{
  return _asn1_free_top();
}

uint64_t sub_2096D25C4()
{
  return _asn1_decode_top();
}

uint64_t sub_2096D25E4()
{
  return _asn1_encode();
}

uint64_t sub_2096D2604()
{
  return _asn1_length();
}

uint64_t sub_2096D2614()
{
  return _asn1_free_top();
}

uint64_t sub_2096D2624()
{
  return _asn1_copy_top();
}

uint64_t sub_2096D2638()
{
  return _asn1_decode_top();
}

uint64_t sub_2096D2658()
{
  return _asn1_encode();
}

uint64_t sub_2096D2678()
{
  return _asn1_length();
}

uint64_t sub_2096D2688()
{
  return _asn1_free_top();
}

uint64_t sub_2096D2698()
{
  return _asn1_decode_top();
}

uint64_t sub_2096D26B8()
{
  return _asn1_free_top();
}

uint64_t sub_2096D26C8()
{
  return _asn1_copy_top();
}

uint64_t sub_2096D26DC()
{
  return _asn1_decode_top();
}

uint64_t sub_2096D26FC()
{
  return _asn1_encode();
}

uint64_t sub_2096D271C()
{
  return _asn1_length();
}

uint64_t sub_2096D272C()
{
  return _asn1_free_top();
}

uint64_t sub_2096D273C()
{
  return _asn1_decode_top();
}

uint64_t sub_2096D275C()
{
  return _asn1_encode();
}

uint64_t sub_2096D277C()
{
  return _asn1_length();
}

uint64_t sub_2096D278C()
{
  return _asn1_free_top();
}

uint64_t sub_2096D279C()
{
  return _asn1_free_top();
}

uint64_t sub_2096D27AC()
{
  return _asn1_decode_top();
}

uint64_t sub_2096D27CC()
{
  return _asn1_encode();
}

uint64_t sub_2096D27EC()
{
  return _asn1_length();
}

uint64_t sub_2096D27FC()
{
  return _asn1_free_top();
}

uint64_t sub_2096D280C(unsigned int *a1)
{
  void *v2;
  uint64_t result;

  v2 = malloc_type_realloc(*((void **)a1 + 1), 24 * *a1 + 24, 0x181077C6uLL);
  if (!v2)
    return 12;
  *((_QWORD *)a1 + 1) = v2;
  result = _asn1_copy_top();
  if (!(_DWORD)result)
    ++*a1;
  return result;
}

uint64_t sub_2096D2888()
{
  return _asn1_decode_top();
}

uint64_t sub_2096D28A8()
{
  return _asn1_encode();
}

uint64_t sub_2096D28C8()
{
  return _asn1_length();
}

uint64_t sub_2096D28D8()
{
  return _asn1_free_top();
}

uint64_t sub_2096D28E8()
{
  return _asn1_decode_top();
}

uint64_t sub_2096D2908()
{
  return _asn1_encode();
}

uint64_t sub_2096D2928()
{
  return _asn1_length();
}

uint64_t sub_2096D2938()
{
  return _asn1_free_top();
}

uint64_t sub_2096D2948()
{
  return _asn1_decode_top();
}

uint64_t sub_2096D2968()
{
  return _asn1_encode();
}

uint64_t sub_2096D2988()
{
  return _asn1_length();
}

uint64_t sub_2096D2998()
{
  return _asn1_free_top();
}

uint64_t sub_2096D29A8()
{
  return _asn1_copy_top();
}

uint64_t sub_2096D29BC()
{
  return _asn1_encode();
}

uint64_t sub_2096D29DC()
{
  return _asn1_length();
}

uint64_t sub_2096D29EC()
{
  return _asn1_decode_top();
}

uint64_t sub_2096D2A0C()
{
  return _asn1_encode();
}

uint64_t sub_2096D2A2C()
{
  return _asn1_length();
}

uint64_t sub_2096D2A3C()
{
  return _asn1_free_top();
}

uint64_t sub_2096D2A4C()
{
  return _asn1_decode_top();
}

uint64_t sub_2096D2A6C()
{
  return _asn1_encode();
}

uint64_t sub_2096D2A8C()
{
  return _asn1_length();
}

uint64_t sub_2096D2A9C()
{
  return _asn1_free_top();
}

uint64_t sub_2096D2AAC()
{
  return _asn1_copy_top();
}

uint64_t sub_2096D2AC0()
{
  return _asn1_decode_top();
}

uint64_t sub_2096D2AE0()
{
  return _asn1_encode();
}

uint64_t sub_2096D2B00()
{
  return _asn1_length();
}

uint64_t sub_2096D2B10()
{
  return _asn1_free_top();
}

uint64_t sub_2096D2B20()
{
  return _asn1_decode_top();
}

uint64_t sub_2096D2B40()
{
  return _asn1_free_top();
}

uint64_t sub_2096D2B50()
{
  return _asn1_decode_top();
}

uint64_t sub_2096D2B70()
{
  return _asn1_encode();
}

uint64_t sub_2096D2B90()
{
  return _asn1_length();
}

uint64_t sub_2096D2BA0()
{
  return _asn1_free_top();
}

uint64_t sub_2096D2BB0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int a5, uint64_t a6, unsigned int a7)
{
  dispatch_source_t *specific;
  dispatch_source_t *v13;
  uint64_t v14;
  uint64_t v16;
  uint64_t v17;

  specific = (dispatch_source_t *)dispatch_get_specific(sub_2096D2BB0);
  v13 = specific;
  v16 = 0;
  v17 = 0;
  if ((_DWORD)a3)
  {
    v16 = 0;
    v17 = 0;
  }
  else
  {
    if (a7)
    {
      v14 = a7;
      v17 = a6;
    }
    else
    {
      v14 = a5;
      v17 = a4;
    }
    v16 = v14;
  }
  ((void (*)(dispatch_source_t, uint64_t, uint64_t *, _QWORD))specific[3])(specific[4], a3, &v16, 0);
  if (a7)
    MEMORY[0x20BD128AC](*MEMORY[0x24BDAEC58], a6, a7);
  dispatch_source_cancel(v13[1]);
  return 0;
}

uint64_t sub_2096D2C6C(const char *a1, uint64_t *a2)
{
  uint64_t result;
  _DWORD *v5;
  uint64_t v6;
  char *v7;

  if (qword_2545A8020 != -1)
    dispatch_once(&qword_2545A8020, &unk_24C1F00D0);
  result = bootstrap_look_up2();
  if (!(_DWORD)result)
  {
    v5 = malloc_type_malloc(0x10uLL, 0x101004082113244uLL);
    if (v5)
    {
      v6 = (uint64_t)v5;
      *v5 = 0;
      v7 = strdup(a1);
      *(_QWORD *)(v6 + 8) = v7;
      if (v7)
      {
        result = 0;
        *a2 = v6;
        return result;
      }
      sub_2096D2D5C(v6);
    }
    else
    {
      mach_port_mod_refs(*MEMORY[0x24BDAEC58], 0, 0, -1);
    }
    return 12;
  }
  return result;
}

uint64_t sub_2096D2D5C(uint64_t a1)
{
  if (*(_DWORD *)a1)
    mach_port_deallocate(*MEMORY[0x24BDAEC58], *(_DWORD *)a1);
  free(*(void **)(a1 + 8));
  free((void *)a1);
  return 0;
}

uint64_t sub_2096D2DA4()
{
  uint64_t v0;
  vm_size_t *v1;
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;
  vm_size_t v5;
  uint64_t v6;
  char v7;
  uint64_t v8;
  char v9;
  uint64_t v10;
  uint64_t v12;
  void *v14;
  void *v15;
  _QWORD *v16;
  _QWORD v17[6];
  int v18;
  int v19;
  _QWORD block[6];
  uint64_t v21;
  uint64_t *v22;
  uint64_t v23;
  int v24;
  unsigned int v25;
  _DWORD __n[3];
  size_t size;
  vm_offset_t data;
  _BYTE __src[2048];
  _BYTE v30[2056];
  uint64_t v31;

  v0 = MEMORY[0x24BDAC7A8]();
  v3 = v2;
  v4 = v0;
  v31 = *MEMORY[0x24BDAC8D0];
  memset(v30, 0, 512);
  data = 0;
  memset(__src, 0, 512);
  size = 0;
  v25 = -1;
  memset(__n, 0, sizeof(__n));
  v5 = *v1;
  if (*v1 > 0x7FF)
  {
    if (vm_read(*MEMORY[0x24BDAEC58], v1[1], v5, &data, (mach_msg_type_number_t *)&size + 1))
      return 12;
    v16 = v3;
    LODWORD(v5) = 0;
  }
  else
  {
    v16 = v2;
    __memcpy_chk();
  }
  v7 = 1;
  v8 = MEMORY[0x24BDAC760];
  while (1)
  {
    v9 = v7;
    v21 = 0;
    v22 = &v21;
    v23 = 0x2000000000;
    v24 = 0;
    block[0] = v8;
    block[1] = 0x40000000;
    block[2] = sub_2096D3904;
    block[3] = &unk_24C1F91B0;
    block[4] = &v21;
    block[5] = v4;
    dispatch_sync((dispatch_queue_t)qword_2545A8030, block);
    v10 = sub_2096D3A28(*((_DWORD *)v22 + 6), (uint64_t)v30, v5, data, HIDWORD(size), &v25, __src, &size, &__n[1], __n);
    if ((_DWORD)v10 != -308 && (_DWORD)v10 != 268435459)
      break;
    v19 = 0;
    v12 = bootstrap_look_up2();
    if ((_DWORD)v12)
    {
      v6 = v12;
      goto LABEL_20;
    }
    v17[0] = v8;
    v17[1] = 0x40000000;
    v17[2] = sub_2096D3918;
    v17[3] = &unk_24C1F91D8;
    v17[4] = &v21;
    v17[5] = v4;
    v18 = v19;
    dispatch_sync((dispatch_queue_t)qword_2545A8030, v17);
    _Block_object_dispose(&v21, 8);
    v7 = 0;
    if ((v9 & 1) == 0)
      return 22;
  }
  v6 = v10;
  if ((_DWORD)v10)
  {
LABEL_20:
    _Block_object_dispose(&v21, 8);
    return v6;
  }
  _Block_object_dispose(&v21, 8);
  v6 = v25;
  if (!v25)
  {
    if (__n[0])
    {
      v14 = malloc_type_malloc(__n[0], 0x9F4ADF19uLL);
      v16[1] = v14;
      if (v14)
      {
        memcpy(v14, *(const void **)&__n[1], __n[0]);
        *v16 = __n[0];
        MEMORY[0x20BD128AC](*MEMORY[0x24BDAEC58], *(_QWORD *)&__n[1]);
        return 0;
      }
      MEMORY[0x20BD128AC](*MEMORY[0x24BDAEC58], *(_QWORD *)&__n[1], __n[0]);
    }
    else
    {
      v15 = malloc_type_malloc(size, 0x753626FDuLL);
      v16[1] = v15;
      if (v15)
      {
        memcpy(v15, __src, size);
        v6 = 0;
        *v16 = size;
        return v6;
      }
    }
    return 12;
  }
  if (__n[0])
  {
    MEMORY[0x20BD128AC](*MEMORY[0x24BDAEC58], *(_QWORD *)&__n[1]);
    return v25;
  }
  return v6;
}

uint64_t sub_2096D318C(mach_port_name_t *a1, vm_size_t *a2, NSObject *a3, NSObject *a4)
{
  mach_port_name_t *v8;
  NSObject **v9;
  vm_map_read_t *v10;
  uint64_t v11;
  NSObject *v12;
  uint64_t v13;
  NSObject *v14;
  NSObject *v15;
  vm_size_t v16;
  char i;
  char v18;
  uint64_t v19;
  uint64_t v20;
  _QWORD v22[6];
  uint64_t v23;
  uint64_t *v24;
  uint64_t v25;
  int v26;
  _QWORD v27[5];
  _QWORD handler[5];
  mach_msg_type_number_t dataCnt;
  vm_offset_t data;
  _OWORD v31[128];
  uint64_t v32;

  v32 = *MEMORY[0x24BDAC8D0];
  data = 0;
  dataCnt = 0;
  v8 = (mach_port_name_t *)malloc_type_malloc(0x28uLL, 0x10A0040C3F9F442uLL);
  if (!v8)
    return 12;
  v9 = (NSObject **)v8;
  v10 = (vm_map_read_t *)MEMORY[0x24BDAEC58];
  if (mach_port_allocate(*MEMORY[0x24BDAEC58], 1u, v8))
  {
    free(v9);
    return 22;
  }
  memset(v31, 0, 512);
  v12 = dispatch_queue_create("heim-ipc-async-client", 0);
  v9[2] = v12;
  v9[1] = dispatch_source_create(MEMORY[0x24BDAC9E0], *(unsigned int *)v9, 0, v12);
  dispatch_queue_set_specific(v9[2], sub_2096D2BB0, v9, 0);
  v13 = MEMORY[0x24BDAC760];
  v14 = v9[1];
  handler[0] = MEMORY[0x24BDAC760];
  handler[1] = 0x40000000;
  handler[2] = sub_2096D3978;
  handler[3] = &unk_24C1F91F8;
  handler[4] = v9;
  dispatch_source_set_event_handler(v14, handler);
  v15 = v9[1];
  v27[0] = v13;
  v27[1] = 0x40000000;
  v27[2] = sub_2096D3990;
  v27[3] = &unk_24C1F9218;
  v27[4] = v9;
  dispatch_source_set_cancel_handler(v15, v27);
  v9[3] = a4;
  v9[4] = a3;
  dispatch_resume(v9[1]);
  v16 = *a2;
  if (*a2 <= 0x7FF)
  {
    __memcpy_chk();
    goto LABEL_10;
  }
  if (vm_read(*v10, a2[1], *a2, &data, &dataCnt))
    return 12;
  LODWORD(v16) = 0;
LABEL_10:
  for (i = 1; ; i = 0)
  {
    v18 = i;
    v23 = 0;
    v24 = &v23;
    v25 = 0x2000000000;
    v26 = 0;
    v22[0] = MEMORY[0x24BDAC760];
    v22[1] = 0x40000000;
    v22[2] = sub_2096D39E8;
    v22[3] = &unk_24C1F9240;
    v22[4] = &v23;
    v22[5] = a1;
    dispatch_sync((dispatch_queue_t)qword_2545A8030, v22);
    v19 = sub_2096D3D00(*((_DWORD *)v24 + 6), *(_DWORD *)v9, (uint64_t)v31, v16, data, dataCnt);
    if ((_DWORD)v19 != 268435459)
      break;
    v20 = bootstrap_look_up2();
    if ((_DWORD)v20)
    {
      v11 = v20;
      goto LABEL_18;
    }
    mach_port_deallocate(*v10, *a1);
    *a1 = *((_DWORD *)v24 + 6);
    _Block_object_dispose(&v23, 8);
    if ((v18 & 1) == 0)
    {
      dispatch_source_cancel(v9[1]);
      return 22;
    }
  }
  v11 = v19;
  if (!(_DWORD)v19)
    goto LABEL_19;
LABEL_18:
  dispatch_source_cancel(v9[1]);
LABEL_19:
  _Block_object_dispose(&v23, 8);
  return v11;
}

uint64_t sub_2096D34C0(const char *a1, uint64_t *a2)
{
  _DWORD *v4;
  _DWORD *v5;
  int v6;
  uint64_t v7;
  sockaddr v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  _WORD v14[13];
  uint64_t v15;

  v15 = *MEMORY[0x24BDAC8D0];
  v4 = malloc_type_malloc(0x10uLL, 0x1010040A1D9428BuLL);
  if (!v4)
    return 12;
  v5 = v4;
  v4[2] = -1;
  asprintf((char **)v4, "/var/run/.heim_%s-%s", a1, "socket");
  *a2 = (uint64_t)v5;
  v13 = 0u;
  memset(v14, 0, sizeof(v14));
  v11 = 0u;
  v12 = 0u;
  v9 = (sockaddr)0;
  v10 = 0u;
  v9.sa_family = 1;
  __strlcpy_chk();
  v6 = socket(1, 1, 0);
  v5[2] = v6;
  if ((v6 & 0x80000000) == 0)
  {
    sub_2096B7FDC(v6);
    rk_socket_set_nopipe(v5[2], 1);
    if (!connect(v5[2], &v9, 0x6Au))
      return 0;
    close(v5[2]);
    v5[2] = -1;
  }
  v7 = *__error();
  if ((_DWORD)v7)
    sub_2096D3608(*a2);
  return v7;
}

uint64_t sub_2096D3608(uint64_t a1)
{
  int v2;

  v2 = *(_DWORD *)(a1 + 8);
  if ((v2 & 0x80000000) == 0)
    close(v2);
  free(*(void **)a1);
  free((void *)a1);
  return 0;
}

uint64_t sub_2096D3644(uint64_t a1, uint64_t a2, size_t *a3, _QWORD *a4)
{
  unsigned int v7;
  size_t v8;
  char *v10;
  unsigned int v11;
  unsigned int v12;
  unsigned int __buf;

  __buf = bswap32(*(_DWORD *)a2);
  if (a4)
    *a4 = 0;
  v12 = 0;
  *a3 = 0;
  a3[1] = 0;
  if (sub_2096B8374(*(_DWORD *)(a1 + 8), (char *)&__buf, 4uLL) != 4
    || sub_2096B8374(*(_DWORD *)(a1 + 8), *(char **)(a2 + 8), *(_QWORD *)a2) != *(_QWORD *)a2
    || sub_2096B82F4(*(_DWORD *)(a1 + 8), (char *)&__buf, 4uLL) != 4
    || sub_2096B82F4(*(_DWORD *)(a1 + 8), (char *)&v12, 4uLL) != 4)
  {
    return 0xFFFFFFFFLL;
  }
  v7 = v12;
  v8 = bswap32(__buf);
  *a3 = v8;
  if (v8 > 0x20000)
  {
    *a3 = 0;
    return 22;
  }
  v10 = (char *)malloc_type_malloc(v8, 0xEA37C0CFuLL);
  a3[1] = (size_t)v10;
  if (!v10)
    return 0xFFFFFFFFLL;
  v11 = bswap32(v7);
  if (sub_2096B82F4(*(_DWORD *)(a1 + 8), v10, *a3) == *a3)
    return v11;
  else
    return 0xFFFFFFFFLL;
}

uint64_t heim_ipc_init_context(const char *a1, _QWORD *a2)
{
  uint64_t v3;
  int v4;
  const char *v5;
  char i;
  char v7;
  const char **v8;
  size_t v9;
  _QWORD *v10;
  void *v11;
  uint64_t v12;

  v3 = 0;
  v4 = 0;
  v5 = a1 + 1;
  for (i = 1; ; i = 0)
  {
    v7 = i;
    v8 = (const char **)&(&off_253D3AF88)[5 * v3];
    v9 = strlen(*v8);
    if (!strncmp(*v8, a1, v9) && a1[v9] == 58)
      break;
    if (!strncmp("ANY:", a1, 4uLL))
    {
      v4 = 1;
      v9 = 3;
      break;
    }
LABEL_10:
    v3 = 1;
    if ((v7 & 1) == 0)
      return 2;
  }
  v10 = malloc_type_calloc(1uLL, 0x10uLL, 0xA0040AFF93C70uLL);
  if (!v10)
    return 12;
  v11 = v10;
  *v10 = v8;
  v12 = ((uint64_t (*)(const char *, _QWORD *))(&off_253D3AF88)[5 * v3 + 1])(&v5[v9], v10 + 1);
  if ((_DWORD)v12)
  {
    free(v11);
    if (!v4)
      return v12;
    v4 = 1;
    goto LABEL_10;
  }
  *a2 = v11;
  return v12;
}

void heim_ipc_free_context(_QWORD *a1)
{
  (*(void (**)(_QWORD))(*a1 + 16))(a1[1]);
  free(a1);
}

uint64_t heim_ipc_call(_QWORD *a1, uint64_t a2, uint64_t a3, _QWORD *a4)
{
  if (a4)
    *a4 = 0;
  return (*(uint64_t (**)(_QWORD))(*a1 + 24))(a1[1]);
}

dispatch_queue_t sub_2096D38C8()
{
  dispatch_queue_t result;

  qword_2545A8028 = (uint64_t)dispatch_get_global_queue(0, 0);
  result = dispatch_queue_create("heim-ipc-syncq", 0);
  qword_2545A8030 = (uint64_t)result;
  return result;
}

uint64_t sub_2096D3904(uint64_t result)
{
  *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) = **(_DWORD **)(result + 40);
  return result;
}

uint64_t sub_2096D3918(uint64_t a1)
{
  mach_port_name_t v2;
  int v3;
  ipc_space_t v4;
  uint64_t result;

  v2 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  v3 = **(_DWORD **)(a1 + 40);
  v4 = *MEMORY[0x24BDAEC58];
  if (v2 != v3)
    return mach_port_deallocate(v4, *(_DWORD *)(a1 + 48));
  result = mach_port_deallocate(v4, v2);
  **(_DWORD **)(a1 + 40) = *(_DWORD *)(a1 + 48);
  return result;
}

uint64_t sub_2096D3978()
{
  return dispatch_mig_server();
}

void sub_2096D3990(uint64_t a1)
{
  mach_port_mod_refs(*MEMORY[0x24BDAEC58], **(_DWORD **)(a1 + 32), 1u, -1);
  dispatch_release(*(dispatch_object_t *)(*(_QWORD *)(a1 + 32) + 16));
  dispatch_release(*(dispatch_object_t *)(*(_QWORD *)(a1 + 32) + 8));
  free(*(void **)(a1 + 32));
}

uint64_t sub_2096D39E8(uint64_t result)
{
  *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) = **(_DWORD **)(result + 40);
  return result;
}

void heim_ipc_free_data(_QWORD *a1)
{
  void *v2;

  v2 = (void *)a1[1];
  if (v2)
    free(v2);
  *a1 = 0;
  a1[1] = 0;
}

uint64_t sub_2096D3A28(mach_port_t a1, uint64_t a2, unsigned int a3, uint64_t a4, unsigned int a5, _DWORD *a6, void *a7, _DWORD *a8, _QWORD *a9, _DWORD *a10)
{
  uint64_t v10;
  uint64_t v17;
  mach_msg_size_t v18;
  mach_port_t reply_port;
  uint64_t v20;
  size_t v21;
  unsigned int v22;
  char *v23;
  mach_msg_header_t rcv_name;
  int v26;
  uint64_t v27;
  int v28;
  _BYTE v29[24];
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  uint64_t v58;

  v58 = *MEMORY[0x24BDAC8D0];
  v56 = 0u;
  v57 = 0u;
  v54 = 0u;
  v55 = 0u;
  v52 = 0u;
  v53 = 0u;
  v50 = 0u;
  v51 = 0u;
  v48 = 0u;
  v49 = 0u;
  v46 = 0u;
  v47 = 0u;
  v44 = 0u;
  v45 = 0u;
  v42 = 0u;
  v43 = 0u;
  v40 = 0u;
  v41 = 0u;
  v38 = 0u;
  v39 = 0u;
  v36 = 0u;
  v37 = 0u;
  v34 = 0u;
  v35 = 0u;
  v32 = 0u;
  v33 = 0u;
  v30 = 0u;
  v31 = 0u;
  *(_OWORD *)&v29[8] = 0u;
  memset(&rcv_name, 0, sizeof(rcv_name));
  v26 = 1;
  v27 = a4;
  v28 = 16777472;
  *(_QWORD *)v29 = a5;
  *(_QWORD *)&v29[4] = *MEMORY[0x24BDAC470];
  if (a3 > 0x800)
    return 4294966989;
  __memcpy_chk();
  *(_DWORD *)&v29[12] = a3;
  v17 = (a3 + 3) & 0xFFFFFFFC;
  v18 = v17 + 60;
  *(_DWORD *)((char *)&rcv_name + v17 + 56) = a5;
  reply_port = mig_get_reply_port();
  rcv_name.msgh_remote_port = a1;
  rcv_name.msgh_local_port = reply_port;
  rcv_name.msgh_bits = -2147478253;
  *(_QWORD *)&rcv_name.msgh_voucher_port = 0x100000000;
  if (MEMORY[0x24BDB0418])
  {
    voucher_mach_msg_set(&rcv_name);
    reply_port = rcv_name.msgh_local_port;
  }
  v20 = mach_msg(&rcv_name, 3, v18, 0x848u, reply_port, 0, 0);
  v10 = v20;
  if ((v20 - 268435458) <= 0xE && ((1 << (v20 - 2)) & 0x4003) != 0)
  {
    mig_put_reply_port(rcv_name.msgh_local_port);
  }
  else
  {
    if (!(_DWORD)v20)
    {
      if (rcv_name.msgh_id == 71)
      {
        v10 = 4294966988;
      }
      else if (rcv_name.msgh_id == 101)
      {
        if ((rcv_name.msgh_bits & 0x80000000) != 0)
        {
          v10 = 4294966996;
          if (v26 == 1
            && rcv_name.msgh_size >= 0x40
            && rcv_name.msgh_size <= 0x840
            && !rcv_name.msgh_remote_port
            && HIBYTE(v28) == 1)
          {
            v21 = *(unsigned int *)&v29[16];
            if (*(_DWORD *)&v29[16] <= 0x800u && rcv_name.msgh_size - 64 >= *(_DWORD *)&v29[16])
            {
              v22 = (*(_DWORD *)&v29[16] + 3) & 0xFFFFFFFC;
              if (rcv_name.msgh_size == v22 + 64)
              {
                v23 = (char *)&rcv_name + v22 - 2048;
                if (*(_DWORD *)v29 == *((_DWORD *)v23 + 527))
                {
                  *a6 = *(_DWORD *)&v29[12];
                  memcpy(a7, &v29[20], v21);
                  v10 = 0;
                  *a8 = v21;
                  *a9 = v27;
                  *a10 = *((_DWORD *)v23 + 527);
                  return v10;
                }
              }
            }
          }
        }
        else if (rcv_name.msgh_size == 36)
        {
          v10 = 4294966996;
          if (HIDWORD(v27))
          {
            if (rcv_name.msgh_remote_port)
              v10 = 4294966996;
            else
              v10 = HIDWORD(v27);
          }
        }
        else
        {
          v10 = 4294966996;
        }
      }
      else
      {
        v10 = 4294966995;
      }
      mach_msg_destroy(&rcv_name);
      return v10;
    }
    mig_dealloc_reply_port(rcv_name.msgh_local_port);
  }
  return v10;
}

uint64_t sub_2096D3D00(unsigned int a1, int a2, uint64_t a3, unsigned int a4, uint64_t a5, int a6)
{
  uint64_t v10;
  mach_msg_size_t v11;
  int v12;
  __int128 v13;
  __int128 v14;
  int v15;
  uint64_t v16;
  int v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  _DWORD v45[7];
  uint64_t v46;

  v46 = *MEMORY[0x24BDAC8D0];
  v44 = 0u;
  memset(v45, 0, sizeof(v45));
  v42 = 0u;
  v43 = 0u;
  v40 = 0u;
  v41 = 0u;
  v38 = 0u;
  v39 = 0u;
  v36 = 0u;
  v37 = 0u;
  v34 = 0u;
  v35 = 0u;
  v32 = 0u;
  v33 = 0u;
  v31 = 0u;
  v30 = 0u;
  v29 = 0u;
  v28 = 0u;
  v27 = 0u;
  v26 = 0u;
  v25 = 0u;
  v24 = 0u;
  v23 = 0u;
  v22 = 0u;
  v21 = 0u;
  v20 = 0u;
  v19 = 0u;
  v18 = 0u;
  v14 = 0u;
  v13 = 0u;
  DWORD1(v14) = 2;
  DWORD2(v14) = a2;
  v15 = 1376256;
  v16 = a5;
  v17 = 16777472;
  LODWORD(v18) = a6;
  *(_QWORD *)((char *)&v18 + 4) = *MEMORY[0x24BDAC470];
  if (a4 > 0x800)
    return 4294966989;
  __memcpy_chk();
  v10 = (a4 + 3) & 0xFFFFFFFC;
  v11 = v10 + 72;
  *(int *)((char *)&v12 + v10 + 68) = a6;
  v12 = -2147483629;
  *(_QWORD *)((char *)&v13 + 4) = a1;
  HIDWORD(v18) = a4;
  HIDWORD(v13) = 0;
  LODWORD(v14) = 2;
  if (MEMORY[0x24BDB0418])
    voucher_mach_msg_set((mach_msg_header_t *)&v12);
  return mach_msg((mach_msg_header_t *)&v12, 1, v11, 0, 0, 0, 0);
}

void sub_2096D3E94(uint64_t a1, uint64_t a2)
{
  int v2;
  uint64_t v4;
  unsigned int v5;
  unsigned int v6;
  unsigned int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  __int128 v12;
  _OWORD v13[2];

  if ((*(_DWORD *)a1 & 0x80000000) == 0)
    goto LABEL_2;
  v2 = -304;
  if (*(_DWORD *)(a1 + 24) != 1)
    goto LABEL_3;
  v4 = *(unsigned int *)(a1 + 4);
  if (v4 < 0x40 || v4 > 0x840)
    goto LABEL_3;
  if (*(_BYTE *)(a1 + 39) != 1)
    goto LABEL_16;
  v5 = *(_DWORD *)(a1 + 56);
  if (v5 > 0x800)
  {
LABEL_2:
    v2 = -304;
    goto LABEL_3;
  }
  v2 = -304;
  if ((int)v4 - 64 < v5)
    goto LABEL_3;
  v6 = (v5 + 3) & 0xFFFFFFFC;
  if ((_DWORD)v4 != v6 + 64)
    goto LABEL_3;
  v7 = *(_DWORD *)(a1 + 40);
  if (v7 != *(_DWORD *)(a1 + v6 + 60))
  {
LABEL_16:
    v2 = -300;
    goto LABEL_3;
  }
  v8 = ((v4 + 3) & 0x1FFFFFFFCLL) + a1;
  if (!*(_DWORD *)v8 && *(_DWORD *)(v8 + 4) > 0x1Fu)
  {
    v9 = *(unsigned int *)(a1 + 12);
    v10 = *(unsigned int *)(a1 + 52);
    v11 = *(_QWORD *)(a1 + 28);
    v12 = *(_OWORD *)(v8 + 36);
    v13[0] = *(_OWORD *)(v8 + 20);
    v13[1] = v12;
    *(_DWORD *)(a2 + 32) = sub_2096D2BB0(v9, (uint64_t)v13, v10, a1 + 60, v5, v11, v7);
    mig_deallocate(*(_QWORD *)(a1 + 28), *(unsigned int *)(a1 + 40));
    *(_QWORD *)(a1 + 28) = 0;
    *(_DWORD *)(a1 + 40) = 0;
    return;
  }
  v2 = -309;
LABEL_3:
  *(_DWORD *)(a2 + 32) = v2;
  *(_QWORD *)(a2 + 24) = *MEMORY[0x24BDAC470];
}

uint64_t sub_2096D3FC0(_DWORD *a1, uint64_t a2)
{
  unsigned int v2;
  int v3;
  uint64_t result;

  v2 = a1[2];
  *(_DWORD *)a2 = *a1 & 0x1F;
  *(_DWORD *)(a2 + 4) = 36;
  v3 = a1[5] + 100;
  *(_QWORD *)(a2 + 8) = v2;
  *(_DWORD *)(a2 + 16) = 0;
  *(_DWORD *)(a2 + 20) = v3;
  if (a1[5] == 201)
  {
    sub_2096D3E94((uint64_t)a1, a2);
    return 1;
  }
  else
  {
    result = 0;
    *(_QWORD *)(a2 + 24) = *MEMORY[0x24BDAC470];
    *(_DWORD *)(a2 + 32) = -303;
  }
  return result;
}

uint64_t sub_2096D4028(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  int v3;
  int v4;
  uint64_t v5;

  v2 = *(_QWORD *)result + *(_QWORD *)a2;
  *(_QWORD *)result = v2;
  v3 = *(_DWORD *)(result + 8) + *(_DWORD *)(a2 + 8);
  *(_DWORD *)(result + 8) = v3;
  if (v3 < 0)
  {
    v4 = 1000000;
    v5 = -1;
  }
  else
  {
    if (v3 <= 0xF423F)
      return result;
    v4 = -1000000;
    v5 = 1;
  }
  *(_QWORD *)result = v5 + v2;
  *(_DWORD *)(result + 8) = v4 + v3;
  return result;
}

uint64_t sub_2096D4088(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  int v3;
  int v4;
  uint64_t v5;

  v2 = *(_QWORD *)result - *(_QWORD *)a2;
  *(_QWORD *)result = v2;
  v3 = *(_DWORD *)(result + 8) - *(_DWORD *)(a2 + 8);
  *(_DWORD *)(result + 8) = v3;
  if (v3 < 0)
  {
    v4 = 1000000;
    v5 = -1;
  }
  else
  {
    if (v3 <= 0xF423F)
      return result;
    v4 = -1000000;
    v5 = 1;
  }
  *(_QWORD *)result = v5 + v2;
  *(_DWORD *)(result + 8) = v4 + v3;
  return result;
}

void *sub_2096D40E8()
{
  return malloc_type_calloc(1uLL, 0x18uLL, 0x10800409070E284uLL);
}

void sub_2096D4104(void *a1)
{
  sub_2096D4128((uint64_t)a1);
  free(a1);
}

void sub_2096D4128(uint64_t a1)
{
  void *v2;

  v2 = *(void **)(a1 + 8);
  if (v2)
  {
    bzero(v2, *(_QWORD *)a1);
    free(*(void **)(a1 + 8));
  }
  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
}

void *sub_2096D4164()
{
  void *v0;

  v0 = malloc_type_calloc(1uLL, 0x18uLL, 0x10800409070E284uLL);
  if (der_copy_heim_integer())
  {
    sub_2096D4128((uint64_t)v0);
    free(v0);
    return 0;
  }
  return v0;
}

uint64_t sub_2096D41C8(uint64_t a1)
{
  if (*(_QWORD *)a1)
    return byte_2096DA1F8[**(unsigned __int8 **)(a1 + 8)] + 8 * *(_QWORD *)a1 - 8;
  else
    return 0;
}

uint64_t sub_2096D41F8(unsigned int *a1)
{
  return *a1;
}

_QWORD *sub_2096D4200(const void *a1, size_t size, _QWORD *a3)
{
  unsigned int v4;
  _QWORD *v6;
  void *v7;

  if ((size & 0x80000000) != 0)
    return 0;
  v4 = size;
  v6 = a3;
  if (a3 || (v6 = malloc_type_calloc(1uLL, 0x18uLL, 0x10800409070E284uLL)) != 0)
  {
    if (v6[1])
      sub_2096D4128((uint64_t)v6);
    *((_DWORD *)v6 + 4) = 0;
    v7 = malloc_type_malloc(v4, 0xFE7460B8uLL);
    v6[1] = v7;
    if (!v4 || v7)
    {
      *v6 = v4;
      memcpy(v7, a1, v4);
      return v6;
    }
    if (!a3)
    {
      sub_2096D4128((uint64_t)v6);
      free(v6);
    }
    return 0;
  }
  return v6;
}

uint64_t sub_2096D42C8(const void **a1, void *__dst)
{
  memcpy(__dst, a1[1], (size_t)*a1);
  return *(unsigned int *)a1;
}

uint64_t sub_2096D42F8(uint64_t result, int a2)
{
  *(_DWORD *)(result + 16) = a2 != 0;
  return result;
}

BOOL sub_2096D430C(uint64_t a1)
{
  return *(_DWORD *)(a1 + 16) != 0;
}

uint64_t sub_2096D431C(_QWORD *a1, unsigned int a2)
{
  unint64_t v2;

  if ((a2 & 0x80000000) != 0)
    return 0;
  v2 = a2 >> 3;
  if (*a1 <= v2)
    return 0;
  else
    return (byte_2096DA2F8[a2 & 7] & *(_BYTE *)(a1[1] + *a1 + ~v2));
}

BOOL sub_2096D4360(_QWORD *a1, unint64_t a2)
{
  uint64_t v2;
  unint64_t v3;
  BOOL v4;
  size_t v5;
  unint64_t v6;
  _BYTE v8[8];
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  if (a2)
  {
    v2 = -1;
    v3 = a2;
    do
    {
      ++v2;
      v4 = v3 >= 0x100;
      v3 >>= 8;
    }
    while (v4);
    v5 = v2 + 1;
    do
    {
      v8[v2] = a2;
      a2 >>= 8;
      v6 = v2-- + 1;
    }
    while (v6 > 1);
  }
  else
  {
    v5 = 0;
  }
  return sub_2096D4200(v8, v5, a1) != 0;
}

uint64_t sub_2096D4404(size_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;
  uint64_t *v5;
  size_t v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t v9;
  unsigned __int8 *v10;
  uint64_t v11;
  _BYTE *v12;
  uint64_t v13;
  _BOOL4 v14;
  uint64_t v15;
  unsigned int v16;
  uint64_t v17;
  unint64_t v18;
  int v19;
  unsigned int v20;

  if (*(_DWORD *)(a2 + 16) && *(_DWORD *)(a3 + 16))
    return 0;
  if (*(_QWORD *)a2 >= *(_QWORD *)a3)
    v5 = (uint64_t *)a3;
  else
    v5 = (uint64_t *)a2;
  if (*(_QWORD *)a2 <= *(_QWORD *)a3)
    v6 = *(_QWORD *)a3;
  else
    v6 = *(_QWORD *)a2;
  if (*(_QWORD *)a2 >= *(_QWORD *)a3)
    v7 = (uint64_t *)a2;
  else
    v7 = (uint64_t *)a3;
  result = (uint64_t)malloc_type_malloc(v6 + 1, 0xD1DB4B73uLL);
  if (result)
  {
    v8 = result;
    v9 = *v7;
    v10 = (unsigned __int8 *)(*v7 + v7[1] - 1);
    v11 = *v5;
    v12 = (_BYTE *)(result + v6);
    if (*v5 < 1)
    {
      v14 = 0;
    }
    else
    {
      v13 = 0;
      v14 = 0;
      v15 = v11 + v5[1] - 1;
      do
      {
        v16 = v14 + v10[v13] + *(unsigned __int8 *)(v15 + v13);
        v12[v13] = v16;
        v14 = v16 > 0xFF;
        --v13;
      }
      while ((unint64_t)(v11 + v13 + 1) > 1);
      v9 = *v7;
      v11 = *v5;
      v12 += v13;
      v10 += v13;
    }
    v17 = v9 - v11;
    if (v17 >= 1)
    {
      v18 = v17 + 1;
      do
      {
        v19 = *v10--;
        v20 = v14 + v19;
        *v12-- = v20;
        v14 = v20 > 0xFF;
        --v18;
      }
      while (v18 > 1);
    }
    if (v14)
    {
      *v12 = 1;
      ++v6;
    }
    else
    {
      memmove(v12, v12 + 1, v6);
    }
    sub_2096D4128((uint64_t)a1);
    *a1 = v6;
    a1[1] = v8;
    result = 1;
    a1[2] = 0;
  }
  return result;
}

_QWORD *sub_2096D4558()
{
  return sub_2096D4560(0);
}

_QWORD *sub_2096D4560(_DWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t default_DH;
  char **DH;

  v2 = malloc_type_calloc(1uLL, 0x90uLL, 0x10E00401D4DFF02uLL);
  v3 = v2;
  if (v2)
  {
    *((_DWORD *)v2 + 26) = 1;
    if (a1)
    {
      hc_ENGINE_up_ref(a1);
      v3[17] = a1;
      default_DH = (uint64_t)a1;
    }
    else
    {
      default_DH = hc_ENGINE_get_default_DH();
      v3[17] = default_DH;
      if (!default_DH)
      {
        DH = (char **)v3[16];
        if (!DH)
        {
          DH = off_2545A7948[0];
          v3[16] = off_2545A7948[0];
        }
LABEL_6:
        ((void (*)(_QWORD *))DH[4])(v3);
        return v3;
      }
    }
    DH = (char **)hc_ENGINE_get_DH(default_DH);
    v3[16] = DH;
    if (!DH)
    {
      hc_ENGINE_finish(a1);
      free(v3);
      return 0;
    }
    goto LABEL_6;
  }
  return v3;
}

void sub_2096D4620(_DWORD *a1)
{
  int v1;
  int v3;
  _QWORD *v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;
  void *v10;
  void *v11;

  v1 = a1[26];
  if (v1 <= 0)
    abort();
  v3 = v1 - 1;
  a1[26] = v3;
  if (!v3)
  {
    (*(void (**)(_DWORD *))(*((_QWORD *)a1 + 16) + 40))(a1);
    v4 = (_QWORD *)*((_QWORD *)a1 + 17);
    if (v4)
      hc_ENGINE_finish(v4);
    v5 = (void *)*((_QWORD *)a1 + 1);
    if (v5)
      sub_2096D4104(v5);
    v6 = (void *)*((_QWORD *)a1 + 2);
    if (v6)
      sub_2096D4104(v6);
    v7 = (void *)*((_QWORD *)a1 + 4);
    if (v7)
      sub_2096D4104(v7);
    v8 = (void *)*((_QWORD *)a1 + 5);
    if (v8)
      sub_2096D4104(v8);
    v9 = (void *)*((_QWORD *)a1 + 8);
    if (v9)
      sub_2096D4104(v9);
    v10 = (void *)*((_QWORD *)a1 + 9);
    if (v10)
      sub_2096D4104(v10);
    v11 = (void *)*((_QWORD *)a1 + 12);
    if (v11)
      sub_2096D4104(v11);
    *((_OWORD *)a1 + 7) = 0u;
    *((_OWORD *)a1 + 8) = 0u;
    *((_OWORD *)a1 + 5) = 0u;
    *((_OWORD *)a1 + 6) = 0u;
    *((_OWORD *)a1 + 3) = 0u;
    *((_OWORD *)a1 + 4) = 0u;
    *((_OWORD *)a1 + 1) = 0u;
    *((_OWORD *)a1 + 2) = 0u;
    *(_OWORD *)a1 = 0u;
    free(a1);
  }
}

uint64_t sub_2096D46F0(uint64_t a1)
{
  return sub_2096D41F8(*(unsigned int **)(a1 + 8));
}

uint64_t sub_2096D46F8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(a1 + 112) = a3;
  return 1;
}

uint64_t sub_2096D4704(uint64_t a1)
{
  return *(_QWORD *)(a1 + 112);
}

uint64_t sub_2096D470C(uint64_t a1, _QWORD *a2, _DWORD *a3)
{
  uint64_t v5;
  _QWORD *v6;
  _QWORD *v7;
  size_t *v8;
  size_t *v9;
  unsigned int v10;
  unsigned int v11;
  unsigned int v12;

  *a3 = 0;
  v5 = 0;
  if (!sub_2096D430C((uint64_t)a2))
  {
    v6 = sub_2096D40E8();
    if (v6)
    {
      v7 = v6;
      if (!sub_2096D4360(v6, 1uLL))
        goto LABEL_17;
      if ((j__der_heim_integer_cmp() & 0x80000000) == 0)
        *a3 |= 1u;
      v8 = (size_t *)sub_2096D40E8();
      if (v8)
      {
        v9 = v8;
        sub_2096D4404(v8, (uint64_t)a2, (uint64_t)v7);
        if ((j__der_heim_integer_cmp() & 0x80000000) == 0)
          *a3 |= 2u;
        if (sub_2096D4360(v7, 2uLL))
        {
          if (j__der_heim_integer_cmp())
            goto LABEL_19;
          v10 = sub_2096D41C8((uint64_t)a2);
          v11 = 0;
          v12 = 0;
          do
          {
            if (sub_2096D431C(a2, v12))
              ++v11;
            ++v12;
          }
          while (v12 <= v10);
          if (v11 > 1)
          {
LABEL_19:
            v5 = 1;
          }
          else
          {
            v5 = 0;
            *a3 |= 1u;
          }
        }
        else
        {
          v5 = 0;
        }
        sub_2096D4104(v7);
      }
      else
      {
LABEL_17:
        v5 = 0;
        v9 = v7;
      }
      sub_2096D4104(v9);
    }
    else
    {
      return 0;
    }
  }
  return v5;
}

uint64_t sub_2096D4868(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 128) + 8))();
}

uint64_t sub_2096D4874(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  int v7;

  v7 = 0;
  if (!sub_2096D470C(a3, a2, &v7) || v7)
    return 0xFFFFFFFFLL;
  else
    return (*(uint64_t (**)(uint64_t, _QWORD *, uint64_t))(*(_QWORD *)(a3 + 128) + 16))(a1, a2, a3);
}

uint64_t sub_2096D48F0(uint64_t *a1)
{
  uint64_t v2;
  void (*v3)(uint64_t *);

  v2 = *a1;
  if (*a1)
  {
    v3 = *(void (**)(uint64_t *))(v2 + 40);
    if (v3)
      v3(a1);
    else
      bzero((void *)a1[2], *(int *)(v2 + 8));
  }
  *a1 = 0;
  a1[1] = 0;
  free((void *)a1[2]);
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  return 1;
}

uint64_t sub_2096D494C(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;
  uint64_t result;

  if (!a2)
    sub_2096D7ECC();
  v4 = a2;
  if (*a1 == a2 && a1[1] == a3)
  {
    result = a1[2];
  }
  else
  {
    sub_2096D48F0(a1);
    *a1 = v4;
    a1[1] = a3;
    result = (uint64_t)malloc_type_calloc(1uLL, *(int *)(v4 + 8), 0xD1CCB196uLL);
    a1[2] = result;
    if (!result)
      return result;
    v4 = *a1;
  }
  (*(void (**)(uint64_t))(v4 + 16))(result);
  return 1;
}

void *hc_EVP_md5(uint64_t a1)
{
  nullsub_1(a1);
  return sub_2096D6F70();
}

void *hc_EVP_md_null()
{
  return &unk_24C1F0FB8;
}

uint64_t hc_EVP_CIPHER_block_size(uint64_t a1)
{
  return *(int *)(a1 + 4);
}

uint64_t hc_EVP_CIPHER_key_length(uint64_t a1)
{
  return *(int *)(a1 + 8);
}

uint64_t hc_EVP_CIPHER_iv_length(uint64_t a1)
{
  return *(unsigned int *)(a1 + 12);
}

double hc_EVP_CIPHER_CTX_init(uint64_t a1)
{
  double result;

  *(_QWORD *)(a1 + 160) = 0;
  result = 0.0;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  return result;
}

uint64_t hc_EVP_CIPHER_CTX_cleanup(uint64_t *a1)
{
  uint64_t v1;
  size_t v3;
  void *v4;
  void (*v5)(uint64_t *);

  v1 = *a1;
  if (*a1)
  {
    v3 = *(int *)(v1 + 48);
    v4 = (void *)a1[15];
    v5 = *(void (**)(uint64_t *))(v1 + 40);
    if (v5)
      v5(a1);
    if (v4)
    {
      bzero(v4, v3);
      free(v4);
    }
    a1[20] = 0;
    *((_OWORD *)a1 + 8) = 0u;
    *((_OWORD *)a1 + 9) = 0u;
    *((_OWORD *)a1 + 6) = 0u;
    *((_OWORD *)a1 + 7) = 0u;
    *((_OWORD *)a1 + 4) = 0u;
    *((_OWORD *)a1 + 5) = 0u;
    *((_OWORD *)a1 + 2) = 0u;
    *((_OWORD *)a1 + 3) = 0u;
    *(_OWORD *)a1 = 0u;
    *((_OWORD *)a1 + 1) = 0u;
  }
  return 1;
}

uint64_t hc_EVP_CIPHER_CTX_set_key_length(_DWORD *a1, int a2)
{
  uint64_t result;

  result = 0;
  if (a2 >= 1 && (*(_QWORD *)(*(_QWORD *)a1 + 16) & 8) != 0)
  {
    a1[26] = a2;
    return 1;
  }
  return result;
}

uint64_t hc_EVP_CIPHER_CTX_cipher(uint64_t a1)
{
  return *(_QWORD *)a1;
}

uint64_t hc_EVP_CIPHER_CTX_block_size(uint64_t a1)
{
  return *(int *)(*(_QWORD *)a1 + 4);
}

uint64_t hc_EVP_CIPHER_CTX_key_length(uint64_t a1)
{
  return *(int *)(*(_QWORD *)a1 + 8);
}

uint64_t hc_EVP_CIPHER_CTX_iv_length(uint64_t a1)
{
  return *(unsigned int *)(*(_QWORD *)a1 + 12);
}

uint64_t hc_EVP_CIPHER_CTX_flags(uint64_t a1)
{
  return *(_QWORD *)(*(_QWORD *)a1 + 16);
}

uint64_t hc_EVP_CIPHER_CTX_mode(uint64_t a1)
{
  return *(_DWORD *)(*(_QWORD *)a1 + 16) & 7;
}

uint64_t hc_EVP_CIPHER_CTX_get_app_data(uint64_t a1)
{
  return *(_QWORD *)(a1 + 96);
}

uint64_t hc_EVP_CIPHER_CTX_set_app_data(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 96) = a2;
  return result;
}

uint64_t hc_EVP_CipherInit_ex(uint64_t a1, uint64_t a2, int a3, uint64_t a4, void *__src, uint64_t a6)
{
  uint64_t v8;
  uint64_t v10;
  uint64_t v11;
  void *v12;
  int v13;
  BOOL v14;
  void *v15;
  size_t v16;
  const void *v17;

  v8 = a2;
  *(_DWORD *)(a1 + 20) = 0;
  if ((_DWORD)a6 == -1)
  {
    v10 = *(unsigned int *)(a1 + 16);
  }
  else
  {
    v10 = a6;
    *(_DWORD *)(a1 + 16) = a6 != 0;
  }
  v11 = *(_QWORD *)a1;
  if (a2)
  {
    if (v11 != a2)
    {
      hc_EVP_CIPHER_CTX_cleanup((uint64_t *)a1);
      *(_QWORD *)a1 = v8;
      *(_DWORD *)(a1 + 104) = *(_DWORD *)(v8 + 8);
      v12 = malloc_type_calloc(1uLL, *(int *)(v8 + 48), 0x1B7796uLL);
      *(_QWORD *)(a1 + 120) = v12;
      if (!v12 && *(_DWORD *)(v8 + 48))
        return 0;
      *(_DWORD *)(a1 + 132) = *(_DWORD *)(v8 + 4) - 1;
      v8 = *(_QWORD *)a1;
    }
  }
  else
  {
    v8 = *(_QWORD *)a1;
    if (!v11)
      return 0;
  }
  v13 = *(_DWORD *)(v8 + 16) & 7;
  if (v13)
    v14 = v13 == 4;
  else
    v14 = 1;
  if (!v14)
  {
    if (v13 == 2)
    {
      v16 = *(unsigned int *)(v8 + 12);
      if (v16 >= 0x11)
        sub_2096D7EF4();
      if (__src)
      {
        memcpy((void *)(a1 + 24), __src, v16);
        v16 = *(unsigned int *)(v8 + 12);
      }
      v15 = (void *)(a1 + 40);
      v17 = (const void *)(a1 + 24);
      goto LABEL_21;
    }
    return 0;
  }
  if (!__src)
    goto LABEL_22;
  v15 = (void *)(a1 + 40);
  v16 = *(unsigned int *)(v8 + 12);
  v17 = __src;
LABEL_21:
  memcpy(v15, v17, v16);
LABEL_22:
  if (a4 || (*(_BYTE *)(v8 + 16) & 0x20) != 0)
    (*(void (**)(uint64_t, uint64_t, void *, uint64_t))(v8 + 24))(a1, a4, __src, v10);
  return 1;
}

uint64_t hc_EVP_CipherUpdate(int *a1, uint64_t a2, _DWORD *a3, char *__src, size_t __n)
{
  size_t v5;
  char *v6;
  uint64_t v8;
  uint64_t v10;
  size_t v11;
  size_t v12;
  char *v13;
  size_t v14;
  uint64_t v15;
  int v16;
  size_t v17;
  uint64_t v18;
  int v19;

  v5 = __n;
  v6 = __src;
  v8 = a2;
  *a3 = 0;
  v10 = a1[5];
  if (!(_DWORD)v10)
  {
    v15 = *(_QWORD *)a1;
    if ((a1[33] & __n) == 0)
    {
      v18 = (*(uint64_t (**)(int *, uint64_t, char *, size_t))(v15 + 32))(a1, a2, __src, __n);
      if ((_DWORD)v18 == 1)
        v19 = v5;
      else
        v19 = 0;
      *a3 = v19;
      return v18;
    }
    if (*(_DWORD *)(v15 + 4))
    {
      if (!__n)
        return 1;
      goto LABEL_8;
    }
LABEL_18:
    sub_2096D7F1C();
  }
  v11 = *(int *)(*(_QWORD *)a1 + 4);
  if ((_DWORD)v11 == (_DWORD)v10)
    goto LABEL_18;
  v12 = v11 - v10;
  v13 = (char *)a1 + v10 + 56;
  v14 = __n - (v11 - v10);
  if (__n < v11 - v10)
  {
    memcpy(v13, __src, __n);
    a1[5] += v5;
    return 1;
  }
  memcpy(v13, __src, v11 - v10);
  v18 = (*(uint64_t (**)(int *, uint64_t, int *, size_t))(*(_QWORD *)a1 + 32))(a1, v8, a1 + 14, v11);
  bzero(a1 + 14, v11);
  if ((_DWORD)v18 == 1)
  {
    *a3 += v11;
    v6 += v12;
    v8 += v11;
    a1[5] = 0;
    v5 = v14;
    if (!v14)
      return 1;
LABEL_8:
    v16 = a1[33];
    a1[5] = v16 & v5;
    v17 = v5 & ~v16;
    v18 = (*(uint64_t (**)(int *, uint64_t, char *, size_t))(*(_QWORD *)a1 + 32))(a1, v8, v6, v17);
    if ((_DWORD)v18 == 1)
    {
      *a3 += v17;
      memcpy(a1 + 14, &v6[v17], a1[5]);
    }
  }
  return v18;
}

uint64_t hc_EVP_CipherFinal_ex(int *a1, uint64_t a2, _DWORD *a3)
{
  uint64_t v3;
  size_t v6;
  uint64_t v8;

  *a3 = 0;
  v3 = a1[5];
  if (!(_DWORD)v3)
    return 1;
  v6 = *(int *)(*(_QWORD *)a1 + 4);
  if ((int)v6 <= (int)v3)
    sub_2096D7F44();
  bzero((char *)a1 + v3 + 56, (v6 - v3));
  v8 = (*(uint64_t (**)(int *, uint64_t, int *, size_t))(*(_QWORD *)a1 + 32))(a1, a2, a1 + 14, v6);
  bzero(a1 + 14, v6);
  if ((_DWORD)v8 == 1)
    *a3 += v6;
  return v8;
}

uint64_t hc_EVP_Cipher(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 32))(a1);
}

void *hc_EVP_enc_null()
{
  return &unk_24C1F0F60;
}

uint64_t sub_2096D4EF8()
{
  return 1;
}

uint64_t sub_2096D4F00(int a1, void *__dst, void *__src, size_t __len)
{
  memmove(__dst, __src, __len);
  return 1;
}

uint64_t sub_2096D4F28()
{
  return 1;
}

void *hc_EVP_rc4(uint64_t a1)
{
  nullsub_1(a1);
  return sub_2096D6F84();
}

void *hc_EVP_des_cbc(uint64_t a1)
{
  nullsub_1(a1);
  return sub_2096D6EF4();
}

void *hc_EVP_des_ede3_cbc(uint64_t a1)
{
  nullsub_1(a1);
  return sub_2096D6E28();
}

void *hc_EVP_aes_128_cbc(uint64_t a1)
{
  nullsub_1(a1);
  return sub_2096D6F24();
}

void *hc_EVP_aes_192_cbc(uint64_t a1)
{
  nullsub_1(a1);
  return sub_2096D6F58();
}

void *hc_EVP_aes_256_cbc(uint64_t a1)
{
  nullsub_1(a1);
  return sub_2096D6F64();
}

uint64_t hc_EVP_aes_128_cfb8()
{
  return 0;
}

uint64_t hc_EVP_aes_192_cfb8()
{
  return 0;
}

uint64_t hc_EVP_aes_256_cfb8()
{
  return 0;
}

uint64_t sub_2096D4FC0(uint64_t a1)
{
  nullsub_1(a1);
  return sub_2096D6F7C();
}

uint64_t sub_2096D4FD4(uint64_t a1)
{
  nullsub_1(a1);
  return sub_2096D6F7C();
}

uint64_t sub_2096D4FE8(uint64_t a1)
{
  nullsub_1(a1);
  return sub_2096D6F7C();
}

uint64_t hc_EVP_get_cipherbyname(char *a1)
{
  uint64_t v2;

  v2 = 0;
  while (strcasecmp((&off_24C1F0A68)[v2], a1))
  {
    v2 += 2;
    if (v2 == 20)
      return 0;
  }
  return ((uint64_t (*)(void))(&off_24C1F0A68)[v2 + 1])();
}

uint64_t sub_2096D5064(uint64_t a1, int *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, char *a7, char *a8)
{
  uint64_t v8;
  uint64_t v12;
  unsigned int v16;
  char *v17;
  char *v18;
  char v19;
  int v20;
  size_t v21;
  unsigned int v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  size_t v26;
  uint64_t v28;
  char *v29;
  int v31;
  uint64_t v32;
  uint64_t v33[2];
  uint64_t v34;

  v8 = *(unsigned int *)(a1 + 8);
  if (a4)
  {
    v12 = a4;
    v16 = *(_DWORD *)(a1 + 12);
    v17 = (char *)malloc_type_malloc(*a2, 0x3861185CuLL);
    if (!v17)
      return 0xFFFFFFFFLL;
    v18 = v17;
    v32 = a3;
    v33[0] = 0;
    v28 = a1;
    LODWORD(a3) = 0;
    v19 = 0;
    v33[1] = 0;
    v34 = 0;
    v31 = a6 - 1;
    while (1)
    {
      sub_2096D494C(v33, (uint64_t)a2, 0);
      if ((v19 & 1) != 0)
        (*(void (**)(uint64_t, char *, _QWORD))(v33[0] + 24))(v34, v18, a3);
      (*(void (**)(uint64_t, uint64_t, uint64_t))(v33[0] + 24))(v34, v12, a5);
      if (v32)
        (*(void (**)(uint64_t, uint64_t, uint64_t))(v33[0] + 24))(v34, v32, 8);
      (*(void (**)(char *, uint64_t))(v33[0] + 32))(v18, v34);
      a3 = *(unsigned int *)v33[0];
      if (*a2 != a3)
        sub_2096D7F94();
      v20 = v31;
      if (a6 >= 2)
      {
        do
        {
          sub_2096D494C(v33, (uint64_t)a2, 0);
          (*(void (**)(uint64_t, char *, _QWORD))(v33[0] + 24))(v34, v18, a3);
          (*(void (**)(char *, uint64_t))(v33[0] + 32))(v18, v34);
          a3 = *(unsigned int *)v33[0];
          if (*a2 != a3)
            sub_2096D7F6C();
          --v20;
        }
        while (v20);
      }
      if ((_DWORD)v8)
        break;
      LODWORD(v21) = 0;
      if (v16)
        goto LABEL_21;
LABEL_29:
      v19 = 1;
      if (!(v8 | v16))
      {
        sub_2096D48F0(v33);
        free(v18);
        return *(unsigned int *)(v28 + 8);
      }
    }
    if (v8 >= a3)
      v21 = a3;
    else
      v21 = v8;
    if (a7)
    {
      memcpy(a7, v18, v21);
      a7 += v21;
    }
    LODWORD(v8) = v8 - v21;
    if (!v16)
      goto LABEL_29;
LABEL_21:
    v22 = a3 - v21;
    if (a3 > v21)
    {
      v29 = a7;
      v23 = v12;
      v24 = a5;
      v25 = a6;
      if (v16 >= v22)
        v26 = v22;
      else
        v26 = v16;
      if (a8)
      {
        memcpy(a8, &v18[v21], v26);
        a8 += v26;
      }
      else
      {
        a8 = 0;
      }
      v16 -= v26;
      a6 = v25;
      a5 = v24;
      v12 = v23;
      a7 = v29;
    }
    goto LABEL_29;
  }
  return v8;
}

uint64_t hc_EVP_CIPHER_CTX_rand_key(uint64_t a1)
{
  uint64_t (*v2)(void);

  if ((*(_BYTE *)(*(_QWORD *)a1 + 17) & 2) == 0)
    return CCRandomCopyBytes() == 0;
  v2 = *(uint64_t (**)(void))(*(_QWORD *)a1 + 72);
  if (v2)
    return v2();
  else
    return 0;
}

uint64_t hc_EVP_CIPHER_CTX_ctrl(uint64_t a1)
{
  uint64_t (*v1)(void);

  if (*(_QWORD *)a1 && (v1 = *(uint64_t (**)(void))(*(_QWORD *)a1 + 72)) != 0)
    return v1();
  else
    return 0;
}

_QWORD *sub_2096D5344()
{
  return sub_2096D534C(0);
}

_QWORD *sub_2096D534C(_DWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t default_RSA;
  char **RSA;

  v2 = malloc_type_calloc(1uLL, 0xA8uLL, 0x10F00409343F5F1uLL);
  v3 = v2;
  if (v2)
  {
    *((_DWORD *)v2 + 28) = 1;
    if (a1)
    {
      hc_ENGINE_up_ref(a1);
      v3[3] = a1;
      default_RSA = (uint64_t)a1;
    }
    else
    {
      default_RSA = hc_ENGINE_get_default_RSA();
      v3[3] = default_RSA;
      if (!default_RSA)
      {
        RSA = (char **)v3[2];
        if (!RSA)
        {
          RSA = off_2545A7950;
          v3[2] = off_2545A7950;
        }
LABEL_6:
        ((void (*)(_QWORD *))RSA[7])(v3);
        return v3;
      }
    }
    RSA = (char **)hc_ENGINE_get_RSA(default_RSA);
    v3[2] = RSA;
    if (!RSA)
    {
      hc_ENGINE_finish(a1);
      free(v3);
      return 0;
    }
    goto LABEL_6;
  }
  return v3;
}

void sub_2096D540C(_DWORD *a1)
{
  int v1;
  int v3;
  _QWORD *v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;
  void *v10;
  void *v11;
  void *v12;

  v1 = a1[28];
  if (v1 <= 0)
    abort();
  v3 = v1 - 1;
  a1[28] = v3;
  if (!v3)
  {
    (*(void (**)(_DWORD *))(*((_QWORD *)a1 + 2) + 64))(a1);
    v4 = (_QWORD *)*((_QWORD *)a1 + 3);
    if (v4)
      hc_ENGINE_finish(v4);
    v5 = (void *)*((_QWORD *)a1 + 4);
    if (v5)
      sub_2096D4104(v5);
    v6 = (void *)*((_QWORD *)a1 + 5);
    if (v6)
      sub_2096D4104(v6);
    v7 = (void *)*((_QWORD *)a1 + 6);
    if (v7)
      sub_2096D4104(v7);
    v8 = (void *)*((_QWORD *)a1 + 7);
    if (v8)
      sub_2096D4104(v8);
    v9 = (void *)*((_QWORD *)a1 + 8);
    if (v9)
      sub_2096D4104(v9);
    v10 = (void *)*((_QWORD *)a1 + 9);
    if (v10)
      sub_2096D4104(v10);
    v11 = (void *)*((_QWORD *)a1 + 10);
    if (v11)
      sub_2096D4104(v11);
    v12 = (void *)*((_QWORD *)a1 + 11);
    if (v12)
      sub_2096D4104(v12);
    *((_QWORD *)a1 + 20) = 0;
    *((_OWORD *)a1 + 8) = 0u;
    *((_OWORD *)a1 + 9) = 0u;
    *((_OWORD *)a1 + 6) = 0u;
    *((_OWORD *)a1 + 7) = 0u;
    *((_OWORD *)a1 + 4) = 0u;
    *((_OWORD *)a1 + 5) = 0u;
    *((_OWORD *)a1 + 2) = 0u;
    *((_OWORD *)a1 + 3) = 0u;
    *(_OWORD *)a1 = 0u;
    *((_OWORD *)a1 + 1) = 0u;
    free(a1);
  }
}

uint64_t sub_2096D54EC(uint64_t a1, uint64_t a2)
{
  _QWORD *v4;

  (*(void (**)(void))(*(_QWORD *)(a1 + 16) + 64))();
  v4 = *(_QWORD **)(a1 + 24);
  if (v4)
  {
    hc_ENGINE_finish(v4);
    *(_QWORD *)(a1 + 24) = 0;
  }
  *(_QWORD *)(a1 + 16) = a2;
  (*(void (**)(uint64_t))(a2 + 56))(a1);
  return 1;
}

uint64_t sub_2096D553C(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)(a1 + 96) = a2;
  return 1;
}

uint64_t sub_2096D5548(uint64_t a1)
{
  return *(_QWORD *)(a1 + 96);
}

BOOL sub_2096D5550(_QWORD *a1)
{
  unsigned int *v2;
  int v3;
  unsigned __int8 *v4;
  unsigned __int8 *v5;
  uint64_t v6;
  _BOOL8 v7;

  if (!a1[6] || (v2 = (unsigned int *)a1[4]) == 0)
  {
    if (!a1[7] || a1[8] || !a1[9] || !a1[10] || !a1[11])
      return 0;
    v2 = (unsigned int *)a1[4];
  }
  v3 = sub_2096D41F8(v2);
  v4 = (unsigned __int8 *)malloc_type_malloc(v3, 0xE1D5972EuLL);
  if (!v4)
    return 0;
  v5 = v4;
  v6 = (*(uint64_t (**)(uint64_t, const char *, unsigned __int8 *, _QWORD *, uint64_t))(a1[2] + 24))(14, "hello, world!", v4, a1, 1);
  v7 = (_DWORD)v6 != -1
    && (*(unsigned int (**)(uint64_t, unsigned __int8 *, unsigned __int8 *, _QWORD *, uint64_t))(a1[2] + 16))(v6, v5, v5, a1, 1) == 14&& !ct_memcmp(v5, "hello, world!", 14);
  free(v5);
  return v7;
}

uint64_t sub_2096D5658(uint64_t a1)
{
  return sub_2096D41F8(*(unsigned int **)(a1 + 32));
}

uint64_t sub_2096D5660(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a4 + 16) + 24))();
}

uint64_t sub_2096D566C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a4 + 16) + 16))();
}

uint64_t sub_2096D5678(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a4 + 16) + 8))();
}

uint64_t sub_2096D5684(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a4 + 16) + 32))();
}

uint64_t sub_2096D5690(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int *a5, uint64_t a6)
{
  uint64_t v9;
  uint64_t (*v10)(uint64_t, uint64_t, uint64_t, uint64_t, int *, uint64_t);
  uint64_t v12;
  size_t v13;
  void *v14;
  void *v15;
  uint64_t v16;
  int v17;

  v9 = *(_QWORD *)(a6 + 16);
  v10 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, int *, uint64_t))(v9 + 88);
  if (v10)
    return v10(a1, a2, a3, a4, a5, a6);
  if (!*(_QWORD *)(v9 + 24))
    return 0;
  v12 = 0xFFFFFFFFLL;
  switch((int)a1)
  {
    case 2:
    case 4:
    case 5:
    case 6:
    case 7:
      v13 = sub_2096D2988();
      v14 = malloc_type_malloc(v13, 0xE8D1A73FuLL);
      if (v14)
      {
        v15 = v14;
        v16 = sub_2096D2968();
        if ((_DWORD)v16)
        {
          v12 = v16;
          free(v15);
        }
        else
        {
          if (v13)
            abort();
          v17 = (*(uint64_t (**)(_QWORD, void *, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(a6 + 16) + 24))(0, v15, a4, a6, 1);
          free(v15);
          if (v17 < 1)
            return 0;
          *a5 = v17;
          v12 = 1;
        }
      }
      else
      {
        v12 = 12;
      }
      break;
    default:
      return v12;
  }
  return v12;
}

uint64_t sub_2096D5830(uint64_t a1)
{
  uint64_t (*v1)(void);

  v1 = *(uint64_t (**)(void))(*(_QWORD *)(a1 + 16) + 104);
  if (v1)
    return v1();
  else
    return 0;
}

_QWORD *sub_2096D5848(_QWORD *a1, _QWORD *a2)
{
  int v4;
  _QWORD *result;
  _OWORD v6[2];
  _OWORD v7[3];
  _OWORD v8[3];
  _OWORD v9[3];
  __int128 v10;
  uint64_t v11;

  v11 = 0;
  v10 = 0u;
  memset(v9, 0, sizeof(v9));
  memset(v8, 0, sizeof(v8));
  memset(v7, 0, sizeof(v7));
  memset(v6, 0, sizeof(v6));
  v4 = sub_2096D28E8();
  result = 0;
  if (!v4)
  {
    *a2 = *a2;
    if (a1 || (a1 = sub_2096D534C(0)) != 0)
    {
      a1[4] = sub_2096D70B8((const void **)v6 + 1, 0);
      a1[5] = sub_2096D70B8((const void **)v7, 0);
      a1[6] = sub_2096D70B8((const void **)&v7[1] + 1, 0);
      a1[7] = sub_2096D70B8((const void **)v8, 0);
      a1[8] = sub_2096D70B8((const void **)&v8[1] + 1, 0);
      a1[9] = sub_2096D70B8((const void **)v9, 0);
      a1[10] = sub_2096D70B8((const void **)&v9[1] + 1, 0);
      a1[11] = sub_2096D70B8((const void **)&v10, 0);
      sub_2096D2938();
      if (a1[4] && a1[5] && a1[6] && a1[7] && a1[8] && a1[9] && a1[10] && a1[11])
        return a1;
      sub_2096D540C(a1);
    }
    else
    {
      sub_2096D2938();
    }
    return 0;
  }
  return result;
}

uint64_t sub_2096D59D4(unsigned int **a1, _QWORD *a2)
{
  unsigned int *v3;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  size_t v12;
  size_t v14;
  void *v15;
  void *v16;
  _OWORD v17[2];
  _OWORD v18[3];
  _OWORD v19[3];
  _OWORD v20[3];
  __int128 v21;
  uint64_t v22;

  v3 = a1[4];
  if (!v3 || !a1[5] || !a1[6] || !a1[7] || !a1[8] || !a1[9] || !a1[10] || !a1[11])
    return 0xFFFFFFFFLL;
  v22 = 0;
  v21 = 0u;
  memset(v20, 0, sizeof(v20));
  memset(v19, 0, sizeof(v19));
  memset(v18, 0, sizeof(v18));
  memset(v17, 0, sizeof(v17));
  v5 = sub_2096D7050(v3, (uint64_t)v17 + 8);
  v6 = sub_2096D7050(a1[5], (uint64_t)v18) | v5;
  v7 = sub_2096D7050(a1[6], (uint64_t)&v18[1] + 8);
  v8 = v6 | v7 | sub_2096D7050(a1[7], (uint64_t)v19);
  v9 = sub_2096D7050(a1[8], (uint64_t)&v19[1] + 8);
  v10 = v9 | sub_2096D7050(a1[9], (uint64_t)v20);
  v11 = v8 | v10 | sub_2096D7050(a1[10], (uint64_t)&v20[1] + 8);
  if (v11 | sub_2096D7050(a1[11], (uint64_t)&v21))
    goto LABEL_10;
  v14 = sub_2096D2928();
  v12 = v14;
  if (!a2)
  {
    sub_2096D2938();
    return v12;
  }
  v15 = malloc_type_malloc(v14, 0xA53095EFuLL);
  if (!v15)
  {
LABEL_10:
    sub_2096D2938();
    return 0xFFFFFFFFLL;
  }
  v16 = v15;
  if (sub_2096D2908())
  {
    free(v16);
    goto LABEL_10;
  }
  sub_2096D2938();
  if (v12)
    abort();
  free(v16);
  v12 = 0;
  *a2 = *a2;
  return v12;
}

uint64_t sub_2096D5BD0(uint64_t a1, _QWORD *a2)
{
  size_t v4;
  size_t v6;
  void *v7;
  void *v8;
  _OWORD v9[3];

  memset(v9, 0, sizeof(v9));
  if (sub_2096D7050(*(unsigned int **)(a1 + 32), (uint64_t)v9)
    || sub_2096D7050(*(unsigned int **)(a1 + 40), (uint64_t)&v9[1] + 8))
  {
    goto LABEL_3;
  }
  v6 = sub_2096D28C8();
  v4 = v6;
  if (!a2)
  {
    sub_2096D28D8();
    return v4;
  }
  v7 = malloc_type_malloc(v6, 0x1925860BuLL);
  if (!v7)
    goto LABEL_3;
  v8 = v7;
  if (sub_2096D28A8())
  {
    free(v8);
LABEL_3:
    sub_2096D28D8();
    return 0xFFFFFFFFLL;
  }
  sub_2096D28D8();
  if (v4)
    abort();
  free(v8);
  v4 = 0;
  *a2 = *a2;
  return v4;
}

_QWORD *sub_2096D5CE4(_QWORD *a1, _QWORD *a2)
{
  int v4;
  _QWORD *result;
  _OWORD v6[3];

  memset(v6, 0, sizeof(v6));
  v4 = sub_2096D2888();
  result = 0;
  if (!v4)
  {
    *a2 = *a2;
    if (a1 || (a1 = sub_2096D534C(0)) != 0)
    {
      a1[4] = sub_2096D70B8((const void **)v6, 0);
      a1[5] = sub_2096D70B8((const void **)&v6[1] + 1, 0);
      sub_2096D28D8();
      if (a1[4] && a1[5])
        return a1;
      sub_2096D540C(a1);
    }
    else
    {
      sub_2096D28D8();
    }
    return 0;
  }
  return result;
}

uint64_t hc_UI_UTIL_read_pw_string(char *a1, int a2, const char *a3, int a4)
{
  size_t v7;
  uint64_t v8;
  char *v10;
  char *v11;

  v7 = a2;
  v8 = sub_2096D5E88("", a3, a1, a2);
  if (!(_DWORD)v8)
  {
    if (a4)
    {
      v10 = (char *)malloc_type_malloc(v7, 0x1322778CuLL);
      if (v10)
      {
        v11 = v10;
        v8 = sub_2096D5E88("Verify password - ", a3, v10, v7);
        if (!(_DWORD)v8)
          v8 = strcmp(v11, a1) != 0;
        free(v11);
      }
      else
      {
        return 1;
      }
    }
    else
    {
      return 0;
    }
  }
  return v8;
}

uint64_t sub_2096D5E88(const char *a1, const char *a2, _BYTE *a3, uint64_t a4)
{
  uint64_t v7;
  uint64_t v8;
  char v9;
  char *v10;
  _DWORD *v11;
  FILE *v12;
  FILE **v13;
  FILE *v14;
  FILE **v15;
  int v16;
  int v17;
  _BOOL4 v18;
  _BYTE *v19;
  int v20;
  _BOOL4 v21;
  int v22;
  const sigaction *v23;
  uint64_t i;
  int v25;
  unsigned int v26;
  sigaction v29;
  termios v30;
  termios v31;
  _OWORD v32[9];
  _QWORD v33[64];

  v33[62] = *MEMORY[0x24BDAC8D0];
  memset(&v31, 0, sizeof(v31));
  memset(&v30, 0, sizeof(v30));
  memset(v32, 0, 128);
  v7 = 1;
  *(_QWORD *)&v29.sa_mask = 0;
  do
  {
    v8 = 0;
    v29.sa_flags = 0;
    v29.__sigaction_u.__sa_handler = (void (__cdecl *)(int))sub_2096D6180;
    v9 = 1;
    while (2)
    {
      v10 = (char *)&unk_2545A7958 + 8 * v8++;
      v11 = v10 + 4;
      while (1)
      {
        if (*(v11 - 1) == (_DWORD)v7)
        {
          if (!*v11)
          {
            v29.__sigaction_u.__sa_handler = (void (__cdecl *)(int))1;
            v29.sa_flags = 2;
            goto LABEL_9;
          }
          if (*v11 == 1)
            break;
        }
LABEL_9:
        ++v8;
        v11 += 2;
        if (v8 == 5)
        {
          if ((v9 & 1) != 0 && !sigaction(v7, &v29, (sigaction *)&v32[v7 + 8]))
            *((_DWORD *)v32 + v7) = 1;
          goto LABEL_16;
        }
      }
      v9 = 0;
      if (v8 != 4)
        continue;
      break;
    }
LABEL_16:
    ++v7;
  }
  while (v7 != 32);
  v12 = fopen("/dev/tty", "r");
  v13 = (FILE **)MEMORY[0x24BDAC8E0];
  if (v12)
  {
    v14 = v12;
    rk_cloexec_file(v12);
  }
  else
  {
    v14 = (FILE *)*MEMORY[0x24BDAC8E0];
  }
  v15 = (FILE **)MEMORY[0x24BDAC8D8];
  fprintf((FILE *)*MEMORY[0x24BDAC8D8], "%s%s", a1, a2);
  fflush(*v15);
  v16 = fileno(v14);
  tcgetattr(v16, &v30);
  *(_OWORD *)v31.c_cc = *(_OWORD *)v30.c_cc;
  *(_OWORD *)&v31.c_cc[16] = *(_OWORD *)&v30.c_cc[16];
  v31.c_ospeed = v30.c_ospeed;
  *(_OWORD *)&v31.c_iflag = *(_OWORD *)&v30.c_iflag;
  v31.c_cflag = v30.c_cflag;
  v31.c_lflag = v30.c_lflag & 0xFFFFFFFFFFFFFFF7;
  v17 = fileno(v14);
  tcsetattr(v17, 0, &v31);
  v18 = 0;
  dword_2545A8038 = 0;
  v19 = &a3[a4];
  while (1)
  {
    v20 = getc(v14);
    if (v20 == 10)
    {
LABEL_26:
      v21 = 1;
      goto LABEL_28;
    }
    if (v20 == -1)
      break;
    if (!v18)
      *a3++ = v20;
    v18 = a3 == v19;
    if (dword_2545A8038)
      goto LABEL_26;
  }
  v21 = ferror(v14) != 0;
LABEL_28:
  a3[-v18] = 0;
  fputc(10, *v15);
  v22 = fileno(v14);
  tcsetattr(v22, 0, &v30);
  if (v14 != *v13)
    fclose(v14);
  v23 = (const sigaction *)v33;
  for (i = 1; i != 32; ++i)
  {
    if (*((_DWORD *)v32 + i))
      sigaction(i, v23, 0);
    ++v23;
  }
  if (v18)
    v25 = -1;
  else
    v25 = 0;
  if (dword_2545A8038)
    v26 = -2;
  else
    v26 = v25;
  if (v21)
    return v26;
  else
    return 4294967293;
}

void sub_2096D6180()
{
  ++dword_2545A8038;
}

uint64_t hc_ENGINE_finish(_QWORD *a1)
{
  int v1;
  void *v3;
  void *v4;
  void (*v5)(_QWORD *);

  v1 = (*(_DWORD *)a1)--;
  if (v1 <= 0)
    abort();
  if (v1 == 1)
  {
    v3 = (void *)a1[1];
    if (v3)
      free(v3);
    v4 = (void *)a1[2];
    if (v4)
      free(v4);
    v5 = (void (*)(_QWORD *))a1[3];
    if (v5)
      v5(a1);
    *((_OWORD *)a1 + 2) = 0u;
    *((_OWORD *)a1 + 3) = 0u;
    *(_OWORD *)a1 = 0u;
    *((_OWORD *)a1 + 1) = 0u;
    free(a1);
  }
  return 1;
}

uint64_t hc_ENGINE_up_ref(_DWORD *a1)
{
  if ((*a1 & 0x80000000) != 0)
    abort();
  ++*a1;
  return 1;
}

BOOL hc_ENGINE_set_id(uint64_t a1, char *__s1)
{
  char *v3;

  v3 = strdup(__s1);
  *(_QWORD *)(a1 + 16) = v3;
  return v3 != 0;
}

BOOL hc_ENGINE_set_name(uint64_t a1, char *__s1)
{
  char *v3;

  v3 = strdup(__s1);
  *(_QWORD *)(a1 + 8) = v3;
  return v3 != 0;
}

uint64_t hc_ENGINE_set_destroy_function(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)(a1 + 24) = a2;
  return 1;
}

uint64_t hc_ENGINE_get_id(uint64_t a1)
{
  return *(_QWORD *)(a1 + 16);
}

uint64_t hc_ENGINE_get_name(uint64_t a1)
{
  return *(_QWORD *)(a1 + 8);
}

uint64_t hc_ENGINE_get_RSA(uint64_t a1)
{
  return *(_QWORD *)(a1 + 32);
}

uint64_t sub_2096D62BC(uint64_t a1)
{
  return *(_QWORD *)(a1 + 40);
}

uint64_t hc_ENGINE_get_DH(uint64_t a1)
{
  return *(_QWORD *)(a1 + 48);
}

uint64_t hc_ENGINE_get_RAND(uint64_t a1)
{
  return *(_QWORD *)(a1 + 56);
}

uint64_t hc_ENGINE_get_default_RSA()
{
  uint64_t result;

  result = qword_2545A8040;
  if (qword_2545A8040)
  {
    if ((*(_DWORD *)qword_2545A8040 & 0x80000000) != 0)
      abort();
    ++*(_DWORD *)qword_2545A8040;
  }
  return result;
}

uint64_t sub_2096D6304()
{
  uint64_t result;

  result = qword_2545A8048;
  if (qword_2545A8048)
  {
    if ((*(_DWORD *)qword_2545A8048 & 0x80000000) != 0)
      abort();
    ++*(_DWORD *)qword_2545A8048;
  }
  return result;
}

uint64_t hc_ENGINE_get_default_DH()
{
  uint64_t result;

  result = qword_2545A8050;
  if (qword_2545A8050)
  {
    if ((*(_DWORD *)qword_2545A8050 & 0x80000000) != 0)
      abort();
    ++*(_DWORD *)qword_2545A8050;
  }
  return result;
}

uint64_t hc_ENGINE_load_builtin_engines()
{
  _QWORD *v0;
  uint64_t result;

  v0 = malloc_type_calloc(1uLL, 0x40uLL, 0x10F0040DCD6B6ADuLL);
  *(_DWORD *)v0 = 1;
  v0[2] = strdup("builtin");
  v0[1] = strdup("Heimdal crypto builtin engine version 1.3.99");
  v0[4] = sub_2096D69B8();
  v0[6] = sub_2096D73F0();
  result = sub_2096D63F0((uint64_t)v0);
  if (!(_DWORD)result)
    return hc_ENGINE_finish(v0);
  return result;
}

uint64_t sub_2096D63F0(uint64_t a1)
{
  _QWORD *v3;
  uint64_t v4;

  if (hc_ENGINE_by_id(*(char **)(a1 + 16)))
    return 0;
  v3 = malloc_type_realloc((void *)qword_2545A8060, 8 * (dword_2545A8058 + 1), 0x2004093837F09uLL);
  if (v3)
  {
    qword_2545A8060 = (uint64_t)v3;
    v4 = dword_2545A8058++;
    v3[v4] = a1;
  }
  return 1;
}

_DWORD *hc_ENGINE_by_dso(const char *a1, uint64_t a2)
{
  _DWORD *v4;
  void *v5;
  void *v6;
  uint64_t (*v7)(uint64_t);
  void *v8;

  v4 = malloc_type_calloc(1uLL, 0x40uLL, 0x10F0040DCD6B6ADuLL);
  if (!v4)
    return v4;
  v5 = dlopen(a1, 2);
  if (!v5)
  {
LABEL_11:
    free(v4);
    return 0;
  }
  v6 = v5;
  v7 = (uint64_t (*)(uint64_t))dlsym(v5, "v_check");
  if (!v7
    || !v7(0x20000)
    || (v8 = dlsym(v6, "bind_engine")) == 0
    || ((unsigned int (*)(_DWORD *, uint64_t, _QWORD))v8)(v4, a2, 0) != 1)
  {
    dlclose(v6);
    goto LABEL_11;
  }
  if ((*v4 & 0x80000000) != 0)
    abort();
  ++*v4;
  if (!sub_2096D63F0((uint64_t)v4))
  {
    dlclose(v6);
    hc_ENGINE_finish(v4);
    return 0;
  }
  return v4;
}

_DWORD *hc_ENGINE_by_id(char *__s1)
{
  uint64_t v1;
  uint64_t i;
  _DWORD *v4;

  v1 = dword_2545A8058;
  if (!dword_2545A8058)
    return 0;
  for (i = qword_2545A8060; ; i += 8)
  {
    v4 = *(_DWORD **)i;
    if (!strcmp(__s1, *(const char **)(*(_QWORD *)i + 16)))
      break;
    if (!--v1)
      return 0;
  }
  if ((*v4 & 0x80000000) != 0)
    abort();
  ++*v4;
  return v4;
}

uint64_t sub_2096D65E8(int a1, const uint8_t *a2, uint8_t *a3, unsigned int **a4, int a5)
{
  __SecKey *v10;
  uint64_t result;
  OSStatus v12;
  size_t v13;
  size_t cipherTextLen;

  v10 = (__SecKey *)sub_2096D69C4(a4, 1);
  cipherTextLen = (int)sub_2096D5658((uint64_t)a4);
  result = 0xFFFFFFFFLL;
  if (a5 == 1 && v10)
  {
    v12 = SecKeyEncrypt(v10, 1u, a2, a1, a3, &cipherTextLen);
    CFRelease(v10);
    if (v12)
    {
      return 0xFFFFFFFFLL;
    }
    else
    {
      v13 = cipherTextLen;
      if (v13 > (int)sub_2096D5658((uint64_t)a4))
        abort();
      return cipherTextLen;
    }
  }
  return result;
}

uint64_t sub_2096D66AC(int a1, const uint8_t *a2, uint8_t *a3, unsigned int **a4, int a5)
{
  __SecKey *v10;
  uint64_t v11;
  OSStatus v12;
  size_t v14;
  size_t v15;
  uint64_t v16;
  int v17;
  size_t plainTextLen;

  v10 = (__SecKey *)sub_2096D69C4(a4, 1);
  plainTextLen = (int)sub_2096D5658((uint64_t)a4);
  v11 = 0xFFFFFFFFLL;
  if (a5 == 1 && v10)
  {
    v12 = SecKeyDecrypt(v10, 0, a2, a1, a3, &plainTextLen);
    CFRelease(v10);
    if (!v12)
    {
      v14 = plainTextLen;
      if (v14 > (int)sub_2096D5658((uint64_t)a4))
        abort();
      v15 = plainTextLen;
      if (plainTextLen)
      {
        if (*a3 == 1)
        {
          v16 = 1;
          while (plainTextLen != v16)
          {
            v17 = a3[v16++];
            if (v17 != 255)
            {
              if (v17)
                return 0xFFFFFFFFLL;
              v11 = plainTextLen - v16;
              plainTextLen -= v16;
              memmove(a3, &a3[v16], v15 - v16);
              return v11;
            }
          }
        }
      }
    }
    return 0xFFFFFFFFLL;
  }
  return v11;
}

uint64_t sub_2096D67C4(int a1, const uint8_t *a2, uint8_t *a3, unsigned int **a4, int a5)
{
  __SecKey *v10;
  uint64_t result;
  OSStatus v12;
  size_t v13;
  size_t cipherTextLen;

  v10 = (__SecKey *)sub_2096D69C4(a4, 0);
  cipherTextLen = (int)sub_2096D5658((uint64_t)a4);
  result = 0xFFFFFFFFLL;
  if (a5 == 1 && v10)
  {
    v12 = SecKeyEncrypt(v10, 1u, a2, a1, a3, &cipherTextLen);
    CFRelease(v10);
    if (v12)
    {
      return 0xFFFFFFFFLL;
    }
    else
    {
      v13 = cipherTextLen;
      if (v13 > (int)sub_2096D5658((uint64_t)a4))
        abort();
      return cipherTextLen;
    }
  }
  return result;
}

uint64_t sub_2096D6888(int a1, const uint8_t *a2, uint8_t *a3, unsigned int **a4, int a5)
{
  __SecKey *v10;
  uint64_t v11;
  OSStatus v12;
  size_t v14;
  size_t v15;
  uint64_t v16;
  int v17;
  size_t plainTextLen;

  v10 = (__SecKey *)sub_2096D69C4(a4, 0);
  plainTextLen = (int)sub_2096D5658((uint64_t)a4);
  v11 = 0xFFFFFFFFLL;
  if (a5 == 1 && v10)
  {
    v12 = SecKeyDecrypt(v10, 0, a2, a1, a3, &plainTextLen);
    CFRelease(v10);
    if (!v12)
    {
      v14 = plainTextLen;
      if (v14 > (int)sub_2096D5658((uint64_t)a4))
        abort();
      v15 = plainTextLen;
      if (plainTextLen)
      {
        if (*a3 == 1)
        {
          v16 = 1;
          while (plainTextLen != v16)
          {
            v17 = a3[v16++];
            if (v17 != 255)
            {
              if (v17)
                return 0xFFFFFFFFLL;
              v11 = plainTextLen - v16;
              plainTextLen -= v16;
              memmove(a3, &a3[v16], v15 - v16);
              return v11;
            }
          }
        }
      }
    }
    return 0xFFFFFFFFLL;
  }
  return v11;
}

uint64_t sub_2096D69A0()
{
  return 1;
}

uint64_t sub_2096D69A8()
{
  return 1;
}

uint64_t sub_2096D69B0()
{
  return 0xFFFFFFFFLL;
}

char **sub_2096D69B8()
{
  return &off_24C1F0218;
}

uint64_t sub_2096D69C4(unsigned int **a1, int a2)
{
  uint64_t v3;
  size_t v5;
  void *v6;
  void *v7;
  uint64_t v8;
  size_t v9;
  void *v10;
  __int128 v11;
  __int128 v12;
  _OWORD v13[3];
  _OWORD v14[3];
  _OWORD v15[3];
  __int128 v16;
  uint64_t v17;
  uint64_t v18;

  v18 = 0;
  if (!a2)
  {
    v17 = 0;
    v16 = 0uLL;
    memset(v15, 0, sizeof(v15));
    memset(v14, 0, sizeof(v14));
    memset(v13, 0, sizeof(v13));
    v11 = 0uLL;
    v12 = 0uLL;
    LODWORD(v11) = 1;
    if (!sub_2096D7050(a1[4], (uint64_t)&v11 + 8)
      && !sub_2096D7050(a1[5], (uint64_t)v13)
      && !sub_2096D7050(a1[6], (uint64_t)&v13[1] + 8)
      && !sub_2096D7050(a1[7], (uint64_t)v14)
      && !sub_2096D7050(a1[8], (uint64_t)&v14[1] + 8)
      && !sub_2096D7050(a1[9], (uint64_t)v15)
      && !sub_2096D7050(a1[10], (uint64_t)&v15[1] + 8)
      && !sub_2096D7050(a1[11], (uint64_t)&v16))
    {
      v9 = sub_2096D2928();
      v10 = malloc_type_malloc(v9, 0xF1D325A5uLL);
      if (v10)
      {
        v7 = v10;
        if (!sub_2096D2908())
        {
          sub_2096D2938();
          if (v18 == v9)
          {
            v8 = MEMORY[0x24BDE8B20](0, v7, v9, 1);
            goto LABEL_21;
          }
LABEL_27:
          abort();
        }
        free(v7);
      }
    }
    sub_2096D2938();
    return 0;
  }
  v12 = 0uLL;
  v13[0] = 0uLL;
  v11 = 0uLL;
  if (sub_2096D7050(a1[4], (uint64_t)&v11))
    goto LABEL_4;
  if (sub_2096D7050(a1[5], (uint64_t)&v12 + 8))
    goto LABEL_4;
  v5 = sub_2096D28C8();
  v6 = malloc_type_malloc(v5, 0x7E6D9746uLL);
  if (!v6)
    goto LABEL_4;
  v7 = v6;
  if (!sub_2096D28A8())
  {
    sub_2096D28D8();
    if (v18 == v5)
    {
      v8 = MEMORY[0x24BDE8B28](0, v7, v5, 1);
LABEL_21:
      v3 = v8;
      free(v7);
      return v3;
    }
    goto LABEL_27;
  }
  free(v7);
LABEL_4:
  sub_2096D28D8();
  return 0;
}

BOOL hc_PKCS5_PBKDF2_HMAC_SHA1(const char *a1, size_t passwordLen, uint8_t *salt, size_t saltLen, unsigned int rounds, size_t derivedKeyLen, uint8_t *derivedKey)
{
  const char *v12;

  if (a1)
    v12 = a1;
  else
    v12 = "";
  return CCKeyDerivationPBKDF(2u, v12, passwordLen, salt, saltLen, 1u, rounds, derivedKey, derivedKeyLen) == 0;
}

_QWORD *sub_2096D6C38()
{
  return sub_2096D6C40(0);
}

_QWORD *sub_2096D6C40(_DWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;
  char **v5;

  v2 = malloc_type_calloc(1uLL, 0x38uLL, 0x10E0040DB20BB55uLL);
  v3 = v2;
  if (v2)
  {
    *((_DWORD *)v2 + 12) = 1;
    if (a1)
    {
      hc_ENGINE_up_ref(a1);
      v3[3] = a1;
      v4 = (uint64_t)a1;
    }
    else
    {
      v4 = sub_2096D6304();
      v3[3] = v4;
      if (!v4)
      {
        v5 = (char **)v3[2];
        if (!v5)
        {
          v5 = off_2545A7978;
          v3[2] = off_2545A7978;
        }
LABEL_6:
        ((void (*)(_QWORD *))v5[5])(v3);
        return v3;
      }
    }
    v5 = (char **)sub_2096D62BC(v4);
    v3[2] = v5;
    if (!v5)
    {
      hc_ENGINE_finish(a1);
      free(v3);
      return 0;
    }
    goto LABEL_6;
  }
  return v3;
}

void sub_2096D6D00(_DWORD *a1)
{
  int v1;
  int v3;
  _QWORD *v4;

  v1 = a1[12];
  if (v1 <= 0)
    abort();
  v3 = v1 - 1;
  a1[12] = v3;
  if (!v3)
  {
    (*(void (**)(_DWORD *))(*((_QWORD *)a1 + 2) + 48))(a1);
    v4 = (_QWORD *)*((_QWORD *)a1 + 3);
    if (v4)
      hc_ENGINE_finish(v4);
    *((_QWORD *)a1 + 6) = 0;
    *((_OWORD *)a1 + 1) = 0u;
    *((_OWORD *)a1 + 2) = 0u;
    *(_OWORD *)a1 = 0u;
    free(a1);
  }
}

uint64_t sub_2096D6D74(uint64_t a1, uint64_t a2)
{
  _QWORD *v4;

  (*(void (**)(void))(*(_QWORD *)(a1 + 16) + 48))();
  v4 = *(_QWORD **)(a1 + 24);
  if (v4)
  {
    hc_ENGINE_finish(v4);
    *(_QWORD *)(a1 + 24) = 0;
  }
  *(_QWORD *)(a1 + 16) = a2;
  (*(void (**)(uint64_t))(a2 + 40))(a1);
  return 1;
}

uint64_t sub_2096D6DC4(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)(a1 + 32) = a2;
  return 1;
}

uint64_t sub_2096D6DD0(uint64_t a1)
{
  return *(_QWORD *)(a1 + 32);
}

uint64_t sub_2096D6DD8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t (*v6)(void);

  v6 = *(uint64_t (**)(void))(*(_QWORD *)(a6 + 16) + 64);
  if (v6)
    return v6();
  else
    return 0;
}

uint64_t sub_2096D6DF0()
{
  return 72;
}

uint64_t sub_2096D6DF8()
{
  return 0xFFFFFFFFLL;
}

uint64_t sub_2096D6E00()
{
  return 0xFFFFFFFFLL;
}

uint64_t sub_2096D6E08()
{
  return 0xFFFFFFFFLL;
}

uint64_t sub_2096D6E10()
{
  return 0xFFFFFFFFLL;
}

uint64_t sub_2096D6E18()
{
  return 1;
}

uint64_t sub_2096D6E20()
{
  return 1;
}

void *sub_2096D6E28()
{
  return &unk_24C1F0E80;
}

BOOL sub_2096D6E34(uint64_t a1, void *key, void *iv, int a4)
{
  return sub_2096D6FB4(a4, 2u, 0, key, 0x18uLL, iv, *(CCCryptorRef **)(a1 + 120));
}

BOOL sub_2096D6E58(uint64_t a1, void *__dst, void *__src, size_t __n)
{
  CCCryptorRef *v6;
  size_t v7;
  size_t dataOutMoved;

  v6 = *(CCCryptorRef **)(a1 + 120);
  dataOutMoved = 0;
  v7 = __n;
  memcpy(__dst, __src, __n);
  return !CCCryptorUpdate(*v6, __src, v7, __dst, v7, &dataOutMoved) && dataOutMoved == v7;
}

uint64_t sub_2096D6ED0(uint64_t a1)
{
  _CCCryptor *v1;

  v1 = **(_CCCryptor ***)(a1 + 120);
  if (v1)
    CCCryptorRelease(v1);
  return 1;
}

void *sub_2096D6EF4()
{
  return &unk_24C1F0E28;
}

BOOL sub_2096D6F00(uint64_t a1, void *key, void *iv, int a4)
{
  return sub_2096D6FB4(a4, 1u, 0, key, 8uLL, iv, *(CCCryptorRef **)(a1 + 120));
}

void *sub_2096D6F24()
{
  return &unk_24C1F0D20;
}

BOOL sub_2096D6F30(CCCryptorRef **a1, void *key, void *iv, int a4)
{
  return sub_2096D6FB4(a4, 0, 0, key, *((int *)*a1 + 2), iv, a1[15]);
}

void *sub_2096D6F58()
{
  return &unk_24C1F0D78;
}

void *sub_2096D6F64()
{
  return &unk_24C1F0DD0;
}

void *sub_2096D6F70()
{
  return &unk_24C1F0ED8;
}

uint64_t sub_2096D6F7C()
{
  return 0;
}

void *sub_2096D6F84()
{
  return &unk_24C1F0F08;
}

BOOL sub_2096D6F90(uint64_t a1, void *key, void *iv, int a4)
{
  return sub_2096D6FB4(a4, 4u, 0, key, *(int *)(a1 + 104), iv, *(CCCryptorRef **)(a1 + 120));
}

BOOL sub_2096D6FB4(int a1, CCAlgorithm alg, CCOptions options, void *key, size_t keyLength, void *iv, CCCryptorRef *cryptorRef)
{
  CCOperation v13;
  _CCCryptor *v14;

  v13 = a1 == 0;
  v14 = *cryptorRef;
  if (*cryptorRef)
  {
    if (!key && iv)
    {
      CCCryptorReset(v14, iv);
      return 1;
    }
    CCCryptorRelease(v14);
  }
  return CCCryptorCreate(v13, alg, options, key, keyLength, iv, cryptorRef) == 0;
}

uint64_t sub_2096D7050(unsigned int *a1, uint64_t a2)
{
  int v4;
  void *v5;
  _BOOL4 v6;
  uint64_t result;

  v4 = sub_2096D41F8(a1);
  *(_QWORD *)a2 = v4;
  v5 = malloc_type_malloc(v4, 0x43BE570AuLL);
  *(_QWORD *)(a2 + 8) = v5;
  if (!v5)
    return 12;
  sub_2096D42C8((const void **)a1, v5);
  v6 = sub_2096D430C((uint64_t)a1);
  result = 0;
  *(_DWORD *)(a2 + 16) = v6;
  return result;
}

_QWORD *sub_2096D70B8(const void **a1, _QWORD *a2)
{
  _QWORD *v3;
  _QWORD *v4;

  v3 = sub_2096D4200(a1[1], *(unsigned int *)a1, a2);
  v4 = v3;
  if (v3)
    sub_2096D42F8((uint64_t)v3, *((_DWORD *)a1 + 4));
  return v4;
}

unsigned int *sub_2096D70FC(uint64_t a1)
{
  _QWORD *v2;
  unsigned int *result;
  size_t v4;
  void *v5;
  void *v6;
  void *v7;
  _QWORD *v8;
  _OWORD v9[3];
  uint64_t v10;
  size_t v11;
  size_t v12;

  v2 = (_QWORD *)sub_2096D4704(a1);
  v11 = 0;
  result = *(unsigned int **)(a1 + 8);
  if (!result)
    return result;
  if (!*(_QWORD *)(a1 + 16))
    return 0;
  v10 = 0;
  memset(v9, 0, sizeof(v9));
  if (sub_2096D7050(result, (uint64_t)v9)
    || sub_2096D7050(*(unsigned int **)(a1 + 16), (uint64_t)&v9[1] + 8)
    || (v10 = 0, v4 = sub_2096D233C(), v12 = v4, (v5 = malloc_type_malloc(v4, 0x769DC8CCuLL)) == 0))
  {
LABEL_5:
    sub_2096D234C();
    return 0;
  }
  v6 = v5;
  if (sub_2096D231C())
  {
    free(v6);
    goto LABEL_5;
  }
  sub_2096D234C();
  if (v11 != v4)
    abort();
  if (*v2)
  {
    SecDHDestroy();
    *v2 = 0;
  }
  if (!SecDHCreateFromParameters())
  {
    free(v6);
    v12 = (int)sub_2096D41F8(*(unsigned int **)(a1 + 8));
    v7 = malloc_type_malloc(v11, 0xA459750FuLL);
    if (!v7)
      goto LABEL_16;
    v6 = v7;
    if (!SecDHGenerateKeypair())
    {
      v8 = sub_2096D4200(v6, v12, 0);
      *(_QWORD *)(a1 + 32) = v8;
      if (v8)
      {
        free(v6);
        return (unsigned int *)1;
      }
    }
  }
  free(v6);
LABEL_16:
  if (*v2)
    SecDHDestroy();
  result = 0;
  *v2 = 0;
  return result;
}

void *sub_2096D729C(uint64_t a1, unsigned int *a2, uint64_t a3)
{
  int v5;
  void *result;
  void *v7;
  int v8;
  unsigned int v9;

  sub_2096D4704(a3);
  v9 = sub_2096D41F8(*(unsigned int **)(a3 + 8));
  v5 = sub_2096D41F8(a2);
  result = malloc_type_malloc(v5, 0xB4F3A5E3uLL);
  if (result)
  {
    v7 = result;
    sub_2096D42C8((const void **)a2, result);
    v8 = SecDHComputeKey();
    free(v7);
    if (v8)
      return 0;
    else
      return (void *)v9;
  }
  return result;
}

uint64_t sub_2096D735C(uint64_t a1)
{
  uint64_t result;

  result = (uint64_t)malloc_type_calloc(1uLL, 8uLL, 0x2004093837F09uLL);
  if (result)
  {
    sub_2096D46F8(a1, 0, result);
    return 1;
  }
  return result;
}

uint64_t sub_2096D73AC(uint64_t a1)
{
  _QWORD *v1;

  v1 = (_QWORD *)sub_2096D4704(a1);
  if (*v1)
    SecDHDestroy();
  free(v1);
  return 1;
}

uint64_t sub_2096D73E8()
{
  return 0;
}

char **sub_2096D73F0()
{
  return &off_24C1F01D0;
}

void heim_abort(char *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  sub_2096D7418(a1, &a9);
}

void sub_2096D7418(char *a1, va_list a2)
{
  char *v3;

  v3 = 0;
  if (vasprintf(&v3, a1, a2) >= 1 && v3 != 0)
  {
    syslog(3, "heim_abort: %s", v3);
    __crashreporter_info__ = (uint64_t)v3;
  }
  abort();
}

void heim_warn_blocking(void *a1, dispatch_once_t *a2)
{
  heim_base_once_f(&qword_2545A8068, 0, (dispatch_function_t)sub_2096D7508);
  if (byte_2545A8070 && pthread_is_threaded_np())
  {
    if (pthread_main_np())
      heim_base_once_f(a2, a1, (dispatch_function_t)sub_2096D74DC);
  }
}

void sub_2096D74DC(const char *a1)
{
  syslog(5, "%s is called on main thread, its a blocking api", a1);
}

uint64_t sub_2096D7508()
{
  uint64_t result;

  result = vproc_swap_integer();
  byte_2545A8070 = 0;
  return result;
}

void heim_base_once_f(dispatch_once_t *predicate, void *context, dispatch_function_t function)
{
  if (*predicate != -1)
    dispatch_once_f(predicate, context, function);
}

CFTypeRef heim_retain(CFTypeRef cf)
{
  if (cf)
    CFRetain(cf);
  return cf;
}

void heim_release(CFTypeRef cf)
{
  if (cf)
    CFRelease(cf);
}

CFTypeID heim_get_tid(const void *a1)
{
  return CFGetTypeID(a1);
}

CFMutableArrayRef heim_array_create()
{
  return CFArrayCreateMutable(0, 0, MEMORY[0x24BDBD690]);
}

uint64_t heim_array_append_value(__CFArray *a1, const void *a2)
{
  CFArrayAppendValue(a1, a2);
  return 0;
}

CFIndex heim_array_iterate_f(const __CFArray *a1, uint64_t a2, uint64_t (*a3)(const void *, int *, uint64_t))
{
  CFIndex result;
  CFIndex v7;
  CFIndex v8;
  const void *ValueAtIndex;
  BOOL v10;
  int v11;

  result = CFArrayGetCount(a1);
  v11 = 0;
  if (result >= 1)
  {
    v7 = result;
    v8 = 0;
    do
    {
      ValueAtIndex = CFArrayGetValueAtIndex(a1, v8);
      result = a3(ValueAtIndex, &v11, a2);
      ++v8;
      if (v11)
        v10 = 0;
      else
        v10 = v8 < v7;
    }
    while (v10);
  }
  return result;
}

CFIndex heim_array_iterate(const __CFArray *a1, uint64_t a2)
{
  CFIndex result;
  CFIndex v5;
  CFIndex v6;
  const void *ValueAtIndex;
  BOOL v8;
  int v9;

  result = CFArrayGetCount(a1);
  v9 = 0;
  if (result >= 1)
  {
    v5 = result;
    v6 = 0;
    do
    {
      ValueAtIndex = CFArrayGetValueAtIndex(a1, v6);
      result = (*(uint64_t (**)(uint64_t, const void *, int *))(a2 + 16))(a2, ValueAtIndex, &v9);
      ++v6;
      if (v9)
        v8 = 0;
      else
        v8 = v6 < v5;
    }
    while (v8);
  }
  return result;
}

const void *heim_array_copy_value(const __CFArray *a1, CFIndex a2)
{
  const void *ValueAtIndex;
  const void *v3;

  ValueAtIndex = CFArrayGetValueAtIndex(a1, a2);
  v3 = ValueAtIndex;
  if (ValueAtIndex)
    CFRetain(ValueAtIndex);
  return v3;
}

CFIndex heim_array_filter(const __CFArray *a1, uint64_t a2)
{
  CFIndex result;
  CFIndex v5;
  const void *ValueAtIndex;

  result = CFArrayGetCount(a1);
  if (result >= 1)
  {
    v5 = 0;
    do
    {
      ValueAtIndex = CFArrayGetValueAtIndex(a1, v5);
      if ((*(unsigned int (**)(uint64_t, const void *))(a2 + 16))(a2, ValueAtIndex))
        CFArrayRemoveValueAtIndex(a1, v5);
      else
        ++v5;
      result = CFArrayGetCount(a1);
    }
    while (v5 < result);
  }
  return result;
}

uint64_t sub_2096D7788(const __CFArray *a1, const void *a2)
{
  CFRange v5;

  v5.length = CFArrayGetCount(a1);
  v5.location = 0;
  return CFArrayContainsValue(a1, v5, a2);
}

CFTypeID heim_dict_get_type_id()
{
  return CFDictionaryGetTypeID();
}

const void *heim_dict_copy_value(const __CFDictionary *a1, const void *a2)
{
  const void *Value;
  const void *v3;

  Value = CFDictionaryGetValue(a1, a2);
  v3 = Value;
  if (Value)
    CFRetain(Value);
  return v3;
}

uint64_t heim_dict_set_value(__CFDictionary *a1, const void *a2, const void *a3)
{
  CFDictionarySetValue(a1, a2, a3);
  return 0;
}

void sub_2096D7820(const __CFDictionary *a1, uint64_t a2, uint64_t a3)
{
  _QWORD v3[2];

  v3[0] = a3;
  v3[1] = a2;
  CFDictionaryApplyFunction(a1, (CFDictionaryApplierFunction)sub_2096D784C, v3);
}

uint64_t sub_2096D784C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, _QWORD))a3)(a1, a2, *(_QWORD *)(a3 + 8));
}

void heim_dict_iterate(const __CFDictionary *a1, uint64_t a2)
{
  _QWORD v2[2];

  v2[0] = a2;
  v2[1] = 0;
  CFDictionaryApplyFunction(a1, (CFDictionaryApplierFunction)sub_2096D7880, v2);
}

uint64_t sub_2096D7880(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)a3 + 16))();
}

CFStringRef heim_string_create(char *cStr)
{
  return CFStringCreateWithCString(0, cStr, 0x8000100u);
}

CFTypeID heim_string_get_type_id()
{
  return CFStringGetTypeID();
}

char *heim_string_copy_utf8(const __CFString *a1)
{
  const char *CStringPtr;
  CFIndex Length;
  CFIndex v5;
  void *v6;

  CStringPtr = CFStringGetCStringPtr(a1, 0x8000100u);
  if (CStringPtr)
    return strdup(CStringPtr);
  Length = CFStringGetLength(a1);
  v5 = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u) + 1;
  v6 = malloc_type_malloc(v5, 0xBC9E6F27uLL);
  if (v6)
  {
    if (!CFStringGetCString(a1, (char *)v6, v5, 0x8000100u))
    {
      free(v6);
      return 0;
    }
  }
  return (char *)v6;
}

CFDataRef heim_data_create(UInt8 *bytes, CFIndex length)
{
  return CFDataCreate(0, bytes, length);
}

CFTypeID heim_data_get_type_id()
{
  return CFDataGetTypeID();
}

uint64_t heim_uniq_alloc(unint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result;
  char v12;

  if (qword_253D3BA70 != -1)
    dispatch_once(&qword_253D3BA70, &unk_24C1F00F0);
  if (a1 <= 0x1F)
    heim_abort("uniq: size too small:size >= sizeof(struct heim_base_uniq)", a2, a3, a4, a5, a6, a7, a8, v12);
  result = qword_253D3BA68;
  if (qword_253D3BA68)
  {
    result = sub_2096D7A18(qword_253D3BA68, a1, (uint64_t)"base-uniq", a4, a5, a6, a7, a8);
    if (result)
    {
      *(_QWORD *)(result + 16) = a2;
      *(_QWORD *)(result + 24) = a3;
    }
  }
  return result;
}

uint64_t sub_2096D7A18(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  size_t v8;
  uint64_t Instance;
  uint64_t v10;
  char v12;

  if (a2 <= 0xF)
    heim_abort("cf runtime size too small:size >= sizeof(CFRuntimeBase)", a2, a3, a4, a5, a6, a7, a8, v12);
  v8 = a2 - 16;
  Instance = _CFRuntimeCreateInstance();
  v10 = Instance;
  if (Instance)
    bzero((void *)(Instance + 16), v8);
  return v10;
}

uint64_t heim_error_createv(int a1, const char *a2, va_list a3)
{
  uint64_t v6;
  char *v7;
  char *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  CFStringRef v15;

  if (qword_253D3BA50 != -1)
    dispatch_once(&qword_253D3BA50, &unk_24C1F9328);
  v6 = qword_253D3BA48;
  if (!qword_253D3BA48)
    return 0;
  v7 = (char *)malloc_type_malloc(0x400uLL, 0x2B255905uLL);
  if (!v7)
    return 0;
  v8 = v7;
  if (vsnprintf(v7, 0x400uLL, a2, a3) < 0)
  {
    v14 = 0;
  }
  else
  {
    v14 = sub_2096D7A18(v6, 0x28uLL, (uint64_t)"heim-error", v9, v10, v11, v12, v13);
    if (v14)
    {
      v15 = CFStringCreateWithCString(0, v8, 0x8000100u);
      *(_DWORD *)(v14 + 16) = a1;
      *(_QWORD *)(v14 + 24) = v15;
      *(_QWORD *)(v14 + 32) = 0;
    }
  }
  free(v8);
  return v14;
}

uint64_t heim_error_copy_string(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 24);
  if (v1)
    CFRetain(*(CFTypeRef *)(a1 + 24));
  return v1;
}

uint64_t heim_error_get_code(uint64_t a1)
{
  return *(unsigned int *)(a1 + 16);
}

uint64_t heim_error_append(uint64_t a1, CFTypeRef cf)
{
  const void *v4;

  v4 = *(const void **)(a1 + 32);
  if (v4)
    CFRelease(v4);
  if (cf)
    CFRetain(cf);
  *(_QWORD *)(a1 + 32) = cf;
  return a1;
}

CFNumberRef heim_number_create(int a1)
{
  int valuePtr;

  valuePtr = a1;
  return CFNumberCreate(0, kCFNumberIntType, &valuePtr);
}

CFTypeID heim_number_get_type_id()
{
  return CFNumberGetTypeID();
}

uint64_t heim_number_get_int(const __CFNumber *a1)
{
  unsigned int valuePtr;

  valuePtr = 0;
  CFNumberGetValue(a1, kCFNumberIntType, &valuePtr);
  return valuePtr;
}

dispatch_queue_t sub_2096D7C40(const char *a1)
{
  return dispatch_queue_create(a1, 0);
}

void sub_2096D7C48(dispatch_object_t object)
{
  if (object)
    dispatch_release(object);
}

intptr_t sub_2096D7C5C(NSObject *a1, uint64_t a2)
{
  dispatch_time_t v3;

  v3 = dispatch_time(0, 1000000000 * a2);
  return dispatch_semaphore_wait(a1, v3);
}

uint64_t sub_2096D7C94()
{
  uint64_t result;

  result = _CFRuntimeRegisterClass();
  qword_253D3BA68 = result;
  return result;
}

uint64_t sub_2096D7CB8(uint64_t result)
{
  uint64_t (*v1)(void);

  v1 = *(uint64_t (**)(void))(result + 24);
  if (v1)
    return v1();
  return result;
}

uint64_t sub_2096D7CC8()
{
  uint64_t result;

  result = _CFRuntimeRegisterClass();
  qword_253D3BA48 = result;
  return result;
}

void sub_2096D7CEC(uint64_t a1)
{
  const void *v2;
  const void *v3;

  v2 = *(const void **)(a1 + 24);
  if (v2)
    CFRelease(v2);
  v3 = *(const void **)(a1 + 32);
  if (v3)
    CFRelease(v3);
}

void sub_2096D7D28()
{
  __assert_rtn("_krb5_decrypt_tkt_with_subkey", "tkt.c", 391, "usage == 0");
}

void sub_2096D7D50(uint64_t a1, NSObject *a2)
{
  int v2;
  uint64_t v3;
  uint64_t v4;

  v4 = *MEMORY[0x24BDAC8D0];
  v2 = 136446210;
  v3 = a1;
  _os_log_debug_impl(&dword_209677000, a2, OS_LOG_TYPE_DEBUG, "%{public}s", (uint8_t *)&v2, 0xCu);
}

void sub_2096D7DC4()
{
  errx(1, "strdup failed");
}

void sub_2096D7DDC()
{
  __assert_rtn("check_basic_constraints", "cert.c", 875, "ret == 0");
}

void sub_2096D7E04()
{
  __assert_rtn("match_general_name", "cert.c", 1801, "c->element == n->element");
}

void sub_2096D7E2C()
{
  __assert_rtn("hx509_crypto_encrypt", "crypto.c", 2708, "crypto->flags & PADDING_FLAGS");
}

void sub_2096D7E54()
{
  __assert_rtn("hx509_crypto_encrypt", "crypto.c", 2690, "(size_t)EVP_CIPHER_iv_length(crypto->c) == ivec->length");
}

void sub_2096D7E7C()
{
  __assert_rtn("CMSCBCParam_get", "crypto.c", 2254, "crypto->param == NULL");
}

void sub_2096D7EA4()
{
  __assert_rtn("quote_string", "name.c", 119, "j < tolen");
}

void sub_2096D7ECC()
{
  __assert_rtn("hc_EVP_DigestInit_ex", "evp.c", 252, "md != NULL");
}

void sub_2096D7EF4()
{
  __assert_rtn("hc_EVP_CipherInit_ex", "evp.c", 791, "EVP_CIPHER_CTX_iv_length(ctx) <= sizeof(ctx->iv)");
}

void sub_2096D7F1C()
{
  __assert_rtn("hc_EVP_CipherUpdate", "evp.c", 860, "left > 0");
}

void sub_2096D7F44()
{
  __assert_rtn("hc_EVP_CipherFinal_ex", "evp.c", 930, "left > 0");
}

void sub_2096D7F6C()
{
  __assert_rtn("hc_EVP_BytesToKey", "evp.c", 1391, "mds == EVP_MD_size(md)");
}

void sub_2096D7F94()
{
  __assert_rtn("hc_EVP_BytesToKey", "evp.c", 1385, "mds == EVP_MD_size(md)");
}

uint64_t AnalyticsSendEventLazy()
{
  return MEMORY[0x24BE1A1C8]();
}

CCCryptorStatus CCCrypt(CCOperation op, CCAlgorithm alg, CCOptions options, const void *key, size_t keyLength, const void *iv, const void *dataIn, size_t dataInLength, void *dataOut, size_t dataOutAvailable, size_t *dataOutMoved)
{
  return MEMORY[0x24BDAC0E8](*(_QWORD *)&op, *(_QWORD *)&alg, *(_QWORD *)&options, key, keyLength, iv, dataIn, dataInLength);
}

CCCryptorStatus CCCryptorCreate(CCOperation op, CCAlgorithm alg, CCOptions options, const void *key, size_t keyLength, const void *iv, CCCryptorRef *cryptorRef)
{
  return MEMORY[0x24BDAC110](*(_QWORD *)&op, *(_QWORD *)&alg, *(_QWORD *)&options, key, keyLength, iv, cryptorRef);
}

CCCryptorStatus CCCryptorCreateWithMode(CCOperation op, CCMode mode, CCAlgorithm alg, CCPadding padding, const void *iv, const void *key, size_t keyLength, const void *tweak, size_t tweakLength, int numRounds, CCModeOptions options, CCCryptorRef *cryptorRef)
{
  return MEMORY[0x24BDAC118](*(_QWORD *)&op, *(_QWORD *)&mode, *(_QWORD *)&alg, *(_QWORD *)&padding, iv, key, keyLength, tweak);
}

CCCryptorStatus CCCryptorFinal(CCCryptorRef cryptorRef, void *dataOut, size_t dataOutAvailable, size_t *dataOutMoved)
{
  return MEMORY[0x24BDAC130](cryptorRef, dataOut, dataOutAvailable, dataOutMoved);
}

CCCryptorStatus CCCryptorRelease(CCCryptorRef cryptorRef)
{
  return MEMORY[0x24BDAC188](cryptorRef);
}

CCCryptorStatus CCCryptorReset(CCCryptorRef cryptorRef, const void *iv)
{
  return MEMORY[0x24BDAC190](cryptorRef, iv);
}

CCCryptorStatus CCCryptorUpdate(CCCryptorRef cryptorRef, const void *dataIn, size_t dataInLength, void *dataOut, size_t dataOutAvailable, size_t *dataOutMoved)
{
  return MEMORY[0x24BDAC198](cryptorRef, dataIn, dataInLength, dataOut, dataOutAvailable, dataOutMoved);
}

uint64_t CCDesIsWeakKey()
{
  return MEMORY[0x24BDAC1A8]();
}

uint64_t CCDesSetOddParity()
{
  return MEMORY[0x24BDAC1B0]();
}

uint64_t CCDigest()
{
  return MEMORY[0x24BDAC1B8]();
}

uint64_t CCDigestCreate()
{
  return MEMORY[0x24BDAC1C0]();
}

uint64_t CCDigestDestroy()
{
  return MEMORY[0x24BDAC1C8]();
}

uint64_t CCDigestFinal()
{
  return MEMORY[0x24BDAC1D0]();
}

uint64_t CCDigestOutputSize()
{
  return MEMORY[0x24BDAC1E8]();
}

uint64_t CCDigestReset()
{
  return MEMORY[0x24BDAC1F0]();
}

uint64_t CCDigestUpdate()
{
  return MEMORY[0x24BDAC1F8]();
}

int CCKeyDerivationPBKDF(CCPBKDFAlgorithm algorithm, const char *password, size_t passwordLen, const uint8_t *salt, size_t saltLen, CCPseudoRandomAlgorithm prf, unsigned int rounds, uint8_t *derivedKey, size_t derivedKeyLen)
{
  return MEMORY[0x24BDAC280](*(_QWORD *)&algorithm, password, passwordLen, salt, saltLen, *(_QWORD *)&prf, *(_QWORD *)&rounds, derivedKey);
}

uint64_t CCRandomCopyBytes()
{
  return MEMORY[0x24BDAC2C8]();
}

CCRNGStatus CCRandomGenerateBytes(void *bytes, size_t count)
{
  return MEMORY[0x24BDAC2D0](bytes, count);
}

CFAbsoluteTime CFAbsoluteTimeGetCurrent(void)
{
  CFAbsoluteTime result;

  MEMORY[0x24BDBB780]();
  return result;
}

void CFArrayAppendValue(CFMutableArrayRef theArray, const void *value)
{
  MEMORY[0x24BDBB7C8](theArray, value);
}

void CFArrayApplyFunction(CFArrayRef theArray, CFRange range, CFArrayApplierFunction applier, void *context)
{
  MEMORY[0x24BDBB7D8](theArray, range.location, range.length, applier, context);
}

Boolean CFArrayContainsValue(CFArrayRef theArray, CFRange range, const void *value)
{
  return MEMORY[0x24BDBB7E8](theArray, range.location, range.length, value);
}

CFMutableArrayRef CFArrayCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFArrayCallBacks *callBacks)
{
  return (CFMutableArrayRef)MEMORY[0x24BDBB808](allocator, capacity, callBacks);
}

CFIndex CFArrayGetCount(CFArrayRef theArray)
{
  return MEMORY[0x24BDBB820](theArray);
}

CFTypeID CFArrayGetTypeID(void)
{
  return MEMORY[0x24BDBB850]();
}

const void *__cdecl CFArrayGetValueAtIndex(CFArrayRef theArray, CFIndex idx)
{
  return (const void *)MEMORY[0x24BDBB860](theArray, idx);
}

void CFArrayRemoveValueAtIndex(CFMutableArrayRef theArray, CFIndex idx)
{
  MEMORY[0x24BDBB880](theArray, idx);
}

CFTypeID CFBooleanGetTypeID(void)
{
  return MEMORY[0x24BDBBA18]();
}

Boolean CFBooleanGetValue(CFBooleanRef BOOLean)
{
  return MEMORY[0x24BDBBA20](BOOLean);
}

CFURLRef CFBundleCopyResourcesDirectoryURL(CFBundleRef bundle)
{
  return (CFURLRef)MEMORY[0x24BDBBA90](bundle);
}

CFStringRef CFBundleGetIdentifier(CFBundleRef bundle)
{
  return (CFStringRef)MEMORY[0x24BDBBAC0](bundle);
}

CFDictionaryRef CFBundleGetInfoDictionary(CFBundleRef bundle)
{
  return (CFDictionaryRef)MEMORY[0x24BDBBAC8](bundle);
}

CFBundleRef CFBundleGetMainBundle(void)
{
  return (CFBundleRef)MEMORY[0x24BDBBAD8]();
}

CFDataRef CFDataCreate(CFAllocatorRef allocator, const UInt8 *bytes, CFIndex length)
{
  return (CFDataRef)MEMORY[0x24BDBBC98](allocator, bytes, length);
}

CFDataRef CFDataCreateWithBytesNoCopy(CFAllocatorRef allocator, const UInt8 *bytes, CFIndex length, CFAllocatorRef bytesDeallocator)
{
  return (CFDataRef)MEMORY[0x24BDBBCC0](allocator, bytes, length, bytesDeallocator);
}

const UInt8 *__cdecl CFDataGetBytePtr(CFDataRef theData)
{
  return (const UInt8 *)MEMORY[0x24BDBBCE0](theData);
}

CFIndex CFDataGetLength(CFDataRef theData)
{
  return MEMORY[0x24BDBBCF8](theData);
}

CFTypeID CFDataGetTypeID(void)
{
  return MEMORY[0x24BDBBD08]();
}

CFDateRef CFDateCreate(CFAllocatorRef allocator, CFAbsoluteTime at)
{
  return (CFDateRef)MEMORY[0x24BDBBD30](allocator, at);
}

void CFDictionaryAddValue(CFMutableDictionaryRef theDict, const void *key, const void *value)
{
  MEMORY[0x24BDBBDB0](theDict, key, value);
}

void CFDictionaryApplyFunction(CFDictionaryRef theDict, CFDictionaryApplierFunction applier, void *context)
{
  MEMORY[0x24BDBBDB8](theDict, applier, context);
}

Boolean CFDictionaryContainsKey(CFDictionaryRef theDict, const void *key)
{
  return MEMORY[0x24BDBBDC0](theDict, key);
}

CFDictionaryRef CFDictionaryCreate(CFAllocatorRef allocator, const void **keys, const void **values, CFIndex numValues, const CFDictionaryKeyCallBacks *keyCallBacks, const CFDictionaryValueCallBacks *valueCallBacks)
{
  return (CFDictionaryRef)MEMORY[0x24BDBBDD8](allocator, keys, values, numValues, keyCallBacks, valueCallBacks);
}

CFMutableDictionaryRef CFDictionaryCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFDictionaryKeyCallBacks *keyCallBacks, const CFDictionaryValueCallBacks *valueCallBacks)
{
  return (CFMutableDictionaryRef)MEMORY[0x24BDBBDF0](allocator, capacity, keyCallBacks, valueCallBacks);
}

CFMutableDictionaryRef CFDictionaryCreateMutableCopy(CFAllocatorRef allocator, CFIndex capacity, CFDictionaryRef theDict)
{
  return (CFMutableDictionaryRef)MEMORY[0x24BDBBDF8](allocator, capacity, theDict);
}

CFIndex CFDictionaryGetCount(CFDictionaryRef theDict)
{
  return MEMORY[0x24BDBBE00](theDict);
}

CFTypeID CFDictionaryGetTypeID(void)
{
  return MEMORY[0x24BDBBE18]();
}

const void *__cdecl CFDictionaryGetValue(CFDictionaryRef theDict, const void *key)
{
  return (const void *)MEMORY[0x24BDBBE30](theDict, key);
}

void CFDictionaryRemoveValue(CFMutableDictionaryRef theDict, const void *key)
{
  MEMORY[0x24BDBBE48](theDict, key);
}

void CFDictionarySetValue(CFMutableDictionaryRef theDict, const void *key, const void *value)
{
  MEMORY[0x24BDBBE60](theDict, key, value);
}

Boolean CFEqual(CFTypeRef cf1, CFTypeRef cf2)
{
  return MEMORY[0x24BDBBE68](cf1, cf2);
}

CFStringRef CFErrorCopyDescription(CFErrorRef err)
{
  return (CFStringRef)MEMORY[0x24BDBBE70](err);
}

CFDictionaryRef CFErrorCopyUserInfo(CFErrorRef err)
{
  return (CFDictionaryRef)MEMORY[0x24BDBBE80](err);
}

CFErrorRef CFErrorCreateWithUserInfoKeysAndValues(CFAllocatorRef allocator, CFErrorDomain domain, CFIndex code, const void *const *userInfoKeys, const void *const *userInfoValues, CFIndex numUserInfoValues)
{
  return (CFErrorRef)MEMORY[0x24BDBBE90](allocator, domain, code, userInfoKeys, userInfoValues, numUserInfoValues);
}

CFIndex CFErrorGetCode(CFErrorRef err)
{
  return MEMORY[0x24BDBBE98](err);
}

CFTypeID CFGetTypeID(CFTypeRef cf)
{
  return MEMORY[0x24BDBBEF8](cf);
}

CFNumberRef CFNumberCreate(CFAllocatorRef allocator, CFNumberType theType, const void *valuePtr)
{
  return (CFNumberRef)MEMORY[0x24BDBC0A0](allocator, theType, valuePtr);
}

CFTypeID CFNumberGetTypeID(void)
{
  return MEMORY[0x24BDBC118]();
}

Boolean CFNumberGetValue(CFNumberRef number, CFNumberType theType, void *valuePtr)
{
  return MEMORY[0x24BDBC130](number, theType, valuePtr);
}

CFPropertyListRef CFPreferencesCopyAppValue(CFStringRef key, CFStringRef applicationID)
{
  return (CFPropertyListRef)MEMORY[0x24BDBC160](key, applicationID);
}

CFPropertyListRef CFPreferencesCopyValue(CFStringRef key, CFStringRef applicationID, CFStringRef userName, CFStringRef hostName)
{
  return (CFPropertyListRef)MEMORY[0x24BDBC178](key, applicationID, userName, hostName);
}

CFPropertyListRef CFPropertyListCreateWithStream(CFAllocatorRef allocator, CFReadStreamRef stream, CFIndex streamLength, CFOptionFlags options, CFPropertyListFormat *format, CFErrorRef *error)
{
  return (CFPropertyListRef)MEMORY[0x24BDBC1F0](allocator, stream, streamLength, options, format, error);
}

CFReadStreamRef CFReadStreamCreateWithFile(CFAllocatorRef alloc, CFURLRef fileURL)
{
  return (CFReadStreamRef)MEMORY[0x24BDBC230](alloc, fileURL);
}

Boolean CFReadStreamOpen(CFReadStreamRef stream)
{
  return MEMORY[0x24BDBC258](stream);
}

void CFRelease(CFTypeRef cf)
{
  MEMORY[0x24BDBC298](cf);
}

CFTypeRef CFRetain(CFTypeRef cf)
{
  return (CFTypeRef)MEMORY[0x24BDBC2A8](cf);
}

CFStringRef CFStringCreateWithCString(CFAllocatorRef alloc, const char *cStr, CFStringEncoding encoding)
{
  return (CFStringRef)MEMORY[0x24BDBC568](alloc, cStr, *(_QWORD *)&encoding);
}

CFStringRef CFStringCreateWithFormat(CFAllocatorRef alloc, CFDictionaryRef formatOptions, CFStringRef format, ...)
{
  return (CFStringRef)MEMORY[0x24BDBC598](alloc, formatOptions, format);
}

CFStringRef CFStringCreateWithFormatAndArguments(CFAllocatorRef alloc, CFDictionaryRef formatOptions, CFStringRef format, va_list arguments)
{
  return (CFStringRef)MEMORY[0x24BDBC5A0](alloc, formatOptions, format, arguments);
}

Boolean CFStringGetCString(CFStringRef theString, char *buffer, CFIndex bufferSize, CFStringEncoding encoding)
{
  return MEMORY[0x24BDBC600](theString, buffer, bufferSize, *(_QWORD *)&encoding);
}

const char *__cdecl CFStringGetCStringPtr(CFStringRef theString, CFStringEncoding encoding)
{
  return (const char *)MEMORY[0x24BDBC610](theString, *(_QWORD *)&encoding);
}

CFIndex CFStringGetLength(CFStringRef theString)
{
  return MEMORY[0x24BDBC658](theString);
}

CFIndex CFStringGetMaximumSizeForEncoding(CFIndex length, CFStringEncoding encoding)
{
  return MEMORY[0x24BDBC660](length, *(_QWORD *)&encoding);
}

CFTypeID CFStringGetTypeID(void)
{
  return MEMORY[0x24BDBC698]();
}

CFStringRef CFURLCopyLastPathComponent(CFURLRef url)
{
  return (CFStringRef)MEMORY[0x24BDBC7A8](url);
}

CFURLRef CFURLCreateFromFileSystemRepresentation(CFAllocatorRef allocator, const UInt8 *buffer, CFIndex bufLen, Boolean isDirectory)
{
  return (CFURLRef)MEMORY[0x24BDBC828](allocator, buffer, bufLen, isDirectory);
}

CFURLRef CFURLCreateWithFileSystemPath(CFAllocatorRef allocator, CFStringRef filePath, CFURLPathStyle pathStyle, Boolean isDirectory)
{
  return (CFURLRef)MEMORY[0x24BDBC858](allocator, filePath, pathStyle, isDirectory);
}

Boolean CFURLGetFileSystemRepresentation(CFURLRef url, Boolean resolveAgainstBase, UInt8 *buffer, CFIndex maxBufLen)
{
  return MEMORY[0x24BDBC898](url, resolveAgainstBase, buffer, maxBufLen);
}

CFUUIDRef CFUUIDCreateFromUUIDBytes(CFAllocatorRef alloc, CFUUIDBytes bytes)
{
  return (CFUUIDRef)MEMORY[0x24BDBC8E0](alloc, *(_QWORD *)&bytes.byte0, *(_QWORD *)&bytes.byte8);
}

CFTypeID CFUUIDGetTypeID(void)
{
  return MEMORY[0x24BDBC900]();
}

CFUUIDBytes CFUUIDGetUUIDBytes(CFUUIDRef uuid)
{
  uint64_t v1;
  uint64_t v2;
  CFUUIDBytes result;

  v1 = MEMORY[0x24BDBC908](uuid);
  result.byte8 = v2;
  result.byte9 = BYTE1(v2);
  result.byte10 = BYTE2(v2);
  result.byte11 = BYTE3(v2);
  result.byte12 = BYTE4(v2);
  result.byte13 = BYTE5(v2);
  result.byte14 = BYTE6(v2);
  result.byte15 = HIBYTE(v2);
  result.byte0 = v1;
  result.byte1 = BYTE1(v1);
  result.byte2 = BYTE2(v1);
  result.byte3 = BYTE3(v1);
  result.byte4 = BYTE4(v1);
  result.byte5 = BYTE5(v1);
  result.byte6 = BYTE6(v1);
  result.byte7 = HIBYTE(v1);
  return result;
}

DNSServiceErrorType DNSServiceCreateConnection(DNSServiceRef *sdRef)
{
  return MEMORY[0x24BDAC3F8](sdRef);
}

uint64_t DNSServiceCreateDelegateConnection()
{
  return MEMORY[0x24BDAC400]();
}

DNSServiceErrorType DNSServiceGetAddrInfo(DNSServiceRef *sdRef, DNSServiceFlags flags, uint32_t interfaceIndex, DNSServiceProtocol protocol, const char *hostname, DNSServiceGetAddrInfoReply callBack, void *context)
{
  return MEMORY[0x24BDAC408](sdRef, *(_QWORD *)&flags, *(_QWORD *)&interfaceIndex, *(_QWORD *)&protocol, hostname, callBack, context);
}

DNSServiceErrorType DNSServiceQueryRecord(DNSServiceRef *sdRef, DNSServiceFlags flags, uint32_t interfaceIndex, const char *fullname, uint16_t rrtype, uint16_t rrclass, DNSServiceQueryRecordReply callBack, void *context)
{
  return MEMORY[0x24BDAC418](sdRef, *(_QWORD *)&flags, *(_QWORD *)&interfaceIndex, fullname, rrtype, rrclass, callBack, context);
}

void DNSServiceRefDeallocate(DNSServiceRef sdRef)
{
  MEMORY[0x24BDAC428](sdRef);
}

DNSServiceErrorType DNSServiceSetDispatchQueue(DNSServiceRef service, dispatch_queue_t queue)
{
  return MEMORY[0x24BDAC450](service, queue);
}

uint64_t NEHelperCacheCopyAppUUIDMapping()
{
  return MEMORY[0x24BDAC480]();
}

CFDataRef SecCertificateCopyData(SecCertificateRef certificate)
{
  return (CFDataRef)MEMORY[0x24BDE8850](certificate);
}

SecKeyRef SecCertificateCopyKey(SecCertificateRef certificate)
{
  return (SecKeyRef)MEMORY[0x24BDE8888](certificate);
}

SecCertificateRef SecCertificateCreateWithData(CFAllocatorRef allocator, CFDataRef data)
{
  return (SecCertificateRef)MEMORY[0x24BDE8918](allocator, data);
}

CFTypeID SecCertificateGetTypeID(void)
{
  return MEMORY[0x24BDE8948]();
}

uint64_t SecDHComputeKey()
{
  return MEMORY[0x24BDE8A10]();
}

uint64_t SecDHCreateFromParameters()
{
  return MEMORY[0x24BDE8A18]();
}

uint64_t SecDHDestroy()
{
  return MEMORY[0x24BDE8A20]();
}

uint64_t SecDHGenerateKeypair()
{
  return MEMORY[0x24BDE8A28]();
}

OSStatus SecIdentityCopyCertificate(SecIdentityRef identityRef, SecCertificateRef *certificateRef)
{
  return MEMORY[0x24BDE8A48](identityRef, certificateRef);
}

OSStatus SecIdentityCopyPrivateKey(SecIdentityRef identityRef, SecKeyRef *privateKeyRef)
{
  return MEMORY[0x24BDE8A50](identityRef, privateKeyRef);
}

CFTypeID SecIdentityGetTypeID(void)
{
  return MEMORY[0x24BDE8A60]();
}

OSStatus SecItemCopyMatching(CFDictionaryRef query, CFTypeRef *result)
{
  return MEMORY[0x24BDE8A78](query, result);
}

CFDictionaryRef SecKeyCopyAttributes(SecKeyRef key)
{
  return (CFDictionaryRef)MEMORY[0x24BDE8A98](key);
}

CFDataRef SecKeyCreateDecryptedData(SecKeyRef key, SecKeyAlgorithm algorithm, CFDataRef ciphertext, CFErrorRef *error)
{
  return (CFDataRef)MEMORY[0x24BDE8AE8](key, algorithm, ciphertext, error);
}

uint64_t SecKeyCreateDuplicate()
{
  return MEMORY[0x24BDE8AF8]();
}

CFDataRef SecKeyCreateSignature(SecKeyRef key, SecKeyAlgorithm algorithm, CFDataRef dataToSign, CFErrorRef *error)
{
  return (CFDataRef)MEMORY[0x24BDE8B38](key, algorithm, dataToSign, error);
}

OSStatus SecKeyDecrypt(SecKeyRef key, SecPadding padding, const uint8_t *cipherText, size_t cipherTextLen, uint8_t *plainText, size_t *plainTextLen)
{
  return MEMORY[0x24BDE8B48](key, *(_QWORD *)&padding, cipherText, cipherTextLen, plainText, plainTextLen);
}

OSStatus SecKeyEncrypt(SecKeyRef key, SecPadding padding, const uint8_t *plainText, size_t plainTextLen, uint8_t *cipherText, size_t *cipherTextLen)
{
  return MEMORY[0x24BDE8B50](key, *(_QWORD *)&padding, plainText, plainTextLen, cipherText, cipherTextLen);
}

uint64_t SecKeySetParameter()
{
  return MEMORY[0x24BDE8BA0]();
}

SecPolicyRef SecPolicyCreateBasicX509(void)
{
  return (SecPolicyRef)MEMORY[0x24BDE8C28]();
}

OSStatus SecRequirementCreateWithString(CFStringRef text, SecCSFlags flags, SecRequirementRef *requirement)
{
  return MEMORY[0x24BDE8CE0](text, *(_QWORD *)&flags, requirement);
}

OSStatus SecStaticCodeCheckValidity(SecStaticCodeRef staticCode, SecCSFlags flags, SecRequirementRef requirement)
{
  return MEMORY[0x24BDE8D20](staticCode, *(_QWORD *)&flags, requirement);
}

OSStatus SecStaticCodeCreateWithPath(CFURLRef path, SecCSFlags flags, SecStaticCodeRef *staticCode)
{
  return MEMORY[0x24BDE8D28](path, *(_QWORD *)&flags, staticCode);
}

OSStatus SecTrustCreateWithCertificates(CFTypeRef certificates, CFTypeRef policies, SecTrustRef *trust)
{
  return MEMORY[0x24BDE8DD8](certificates, policies, trust);
}

OSStatus SecTrustEvaluate(SecTrustRef trust, SecTrustResultType *result)
{
  return MEMORY[0x24BDE8DE0](trust, result);
}

SecCertificateRef SecTrustGetCertificateAtIndex(SecTrustRef trust, CFIndex ix)
{
  return (SecCertificateRef)MEMORY[0x24BDE8DF8](trust, ix);
}

CFIndex SecTrustGetCertificateCount(SecTrustRef trust)
{
  return MEMORY[0x24BDE8E00](trust);
}

void _Block_object_assign(void *a1, const void *a2, const int a3)
{
  MEMORY[0x24BDAC728](a1, a2, *(_QWORD *)&a3);
}

void _Block_object_dispose(const void *a1, const int a2)
{
  MEMORY[0x24BDAC730](a1, *(_QWORD *)&a2);
}

uint64_t _CFRuntimeCreateInstance()
{
  return MEMORY[0x24BDBD0A8]();
}

uint64_t _CFRuntimeRegisterClass()
{
  return MEMORY[0x24BDBD0B0]();
}

uint64_t _CFURLRequestSetAllowedProtocolTypes()
{
  return MEMORY[0x24BDB75A8]();
}

uint64_t _CFXPCCreateCFObjectFromXPCObject()
{
  return MEMORY[0x24BDBD138]();
}

uint64_t _CFXPCCreateXPCObjectFromCFObject()
{
  return MEMORY[0x24BDBD148]();
}

void _Unwind_Resume(_Unwind_Exception *exception_object)
{
  MEMORY[0x24BDAC780](exception_object);
}

void __assert_rtn(const char *a1, const char *a2, int a3, const char *a4)
{
  MEMORY[0x24BDAC7A0](a1, a2, *(_QWORD *)&a3, a4);
}

int __darwin_check_fd_set_overflow(int a1, const void *a2, int a3)
{
  return MEMORY[0x24BDAC7B8](*(_QWORD *)&a1, a2, *(_QWORD *)&a3);
}

int *__error(void)
{
  return (int *)MEMORY[0x24BDAC7D0]();
}

int __maskrune(__darwin_ct_rune_t a1, unint64_t a2)
{
  return MEMORY[0x24BDAC838](*(_QWORD *)&a1, a2);
}

uint64_t __memcpy_chk()
{
  return MEMORY[0x24BDAC848]();
}

uint64_t __strlcat_chk()
{
  return MEMORY[0x24BDAC908]();
}

uint64_t __strlcpy_chk()
{
  return MEMORY[0x24BDAC910]();
}

__darwin_ct_rune_t __tolower(__darwin_ct_rune_t a1)
{
  return MEMORY[0x24BDAC930](*(_QWORD *)&a1);
}

__darwin_ct_rune_t __toupper(__darwin_ct_rune_t a1)
{
  return MEMORY[0x24BDAC938](*(_QWORD *)&a1);
}

uint64_t _asn1_copy_top()
{
  return MEMORY[0x24BEDBD58]();
}

uint64_t _asn1_decode_top()
{
  return MEMORY[0x24BEDBD60]();
}

uint64_t _asn1_encode()
{
  return MEMORY[0x24BEDBD68]();
}

uint64_t _asn1_free_top()
{
  return MEMORY[0x24BEDBD70]();
}

uint64_t _asn1_length()
{
  return MEMORY[0x24BEDBD78]();
}

void _os_log_debug_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
  MEMORY[0x24BDACB68](dso, log, type, format, buf, *(_QWORD *)&size);
}

void _os_log_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
  MEMORY[0x24BDACB90](dso, log, type, format, buf, *(_QWORD *)&size);
}

void abort(void)
{
  MEMORY[0x24BDAD008]();
}

int access(const char *a1, int a2)
{
  return MEMORY[0x24BDAD038](a1, *(_QWORD *)&a2);
}

uint32_t arc4random(void)
{
  return MEMORY[0x24BDAD158]();
}

void asl_close(asl_object_t obj)
{
  MEMORY[0x24BDAD1B0](obj);
}

void asl_free(asl_object_t obj)
{
  MEMORY[0x24BDAD1B8](obj);
}

int asl_log(asl_object_t client, asl_object_t msg, int level, const char *format, ...)
{
  return MEMORY[0x24BDAD1C0](client, msg, *(_QWORD *)&level, format);
}

asl_object_t asl_new(uint32_t type)
{
  return (asl_object_t)MEMORY[0x24BDAD1C8](*(_QWORD *)&type);
}

asl_object_t asl_open(const char *ident, const char *facility, uint32_t opts)
{
  return (asl_object_t)MEMORY[0x24BDAD1D0](ident, facility, *(_QWORD *)&opts);
}

int asl_set(asl_object_t obj, const char *key, const char *value)
{
  return MEMORY[0x24BDAD1E8](obj, key, value);
}

int asprintf(char **a1, const char *a2, ...)
{
  return MEMORY[0x24BDAD200](a1, a2);
}

int atoi(const char *a1)
{
  return MEMORY[0x24BDAD258](a1);
}

uint64_t bootstrap_look_up2()
{
  return MEMORY[0x24BDAD2E8]();
}

void bzero(void *a1, size_t a2)
{
  MEMORY[0x24BDAD320](a1, a2);
}

uint64_t ccDRBGGetRngState()
{
  return MEMORY[0x24BDAD340]();
}

uint64_t cccurve25519_make_key_pair()
{
  return MEMORY[0x24BDAD3E8]();
}

uint64_t cccurve25519_with_rng()
{
  return MEMORY[0x24BDAD3F8]();
}

uint64_t ccdh_ccn_size()
{
  return MEMORY[0x24BDAD528]();
}

uint64_t ccdh_gp_n()
{
  return MEMORY[0x24BDAD530]();
}

uint64_t ccdigest_init()
{
  return MEMORY[0x24BDAD540]();
}

uint64_t ccdigest_update()
{
  return MEMORY[0x24BDAD548]();
}

uint64_t ccec_compute_key()
{
  return MEMORY[0x24BDAD580]();
}

uint64_t ccec_cp_256()
{
  return MEMORY[0x24BDAD590]();
}

uint64_t ccec_export_pub()
{
  return MEMORY[0x24BDAD5B0]();
}

uint64_t ccec_generate_key_fips()
{
  return MEMORY[0x24BDAD5C0]();
}

uint64_t ccec_import_pub()
{
  return MEMORY[0x24BDAD5D0]();
}

uint64_t ccpbkdf2_hmac()
{
  return MEMORY[0x24BDAD750]();
}

uint64_t ccsha256_di()
{
  return MEMORY[0x24BDAD828]();
}

uint64_t ccsrp_client_process_challenge()
{
  return MEMORY[0x24BDAD850]();
}

uint64_t ccsrp_client_start_authentication()
{
  return MEMORY[0x24BDAD860]();
}

uint64_t ccsrp_client_verify_session()
{
  return MEMORY[0x24BDAD868]();
}

uint64_t ccsrp_ctx_init()
{
  return MEMORY[0x24BDAD870]();
}

uint64_t ccsrp_generate_verifier()
{
  return MEMORY[0x24BDAD890]();
}

uint64_t cczp_bitlen()
{
  return MEMORY[0x24BDAD928]();
}

int close(int a1)
{
  return MEMORY[0x24BDAD9D8](*(_QWORD *)&a1);
}

int closedir(DIR *a1)
{
  return MEMORY[0x24BDAD9F0](a1);
}

void closelog(void)
{
  MEMORY[0x24BDAD9F8]();
}

int connect(int a1, const sockaddr *a2, socklen_t a3)
{
  return MEMORY[0x24BDADA10](*(_QWORD *)&a1, a2, *(_QWORD *)&a3);
}

uint64_t csops()
{
  return MEMORY[0x24BDADC00]();
}

char *__cdecl ctime(const time_t *a1)
{
  return (char *)MEMORY[0x24BDADC18](a1);
}

uint64_t der_copy_bit_string()
{
  return MEMORY[0x24BEDBD80]();
}

uint64_t der_copy_heim_integer()
{
  return MEMORY[0x24BEDBD88]();
}

uint64_t der_copy_octet_string()
{
  return MEMORY[0x24BEDBD90]();
}

uint64_t der_copy_oid()
{
  return MEMORY[0x24BEDBD98]();
}

uint64_t der_free_bit_string()
{
  return MEMORY[0x24BEDBDA0]();
}

uint64_t der_free_heim_integer()
{
  return MEMORY[0x24BEDBDA8]();
}

uint64_t der_free_octet_string()
{
  return MEMORY[0x24BEDBDB0]();
}

uint64_t der_free_oid()
{
  return MEMORY[0x24BEDBDB8]();
}

uint64_t der_heim_bit_string_cmp()
{
  return MEMORY[0x24BEDBDD0]();
}

uint64_t der_heim_integer_cmp()
{
  return MEMORY[0x24BEDBDD8]();
}

uint64_t der_heim_octet_string_cmp()
{
  return MEMORY[0x24BEDBDE0]();
}

uint64_t der_heim_oid_cmp()
{
  return MEMORY[0x24BEDBDE8]();
}

uint64_t der_ia5_string_cmp()
{
  return MEMORY[0x24BEDBDF0]();
}

uint64_t der_length_len()
{
  return MEMORY[0x24BEDBDF8]();
}

uint64_t der_parse_heim_oid()
{
  return MEMORY[0x24BEDBE08]();
}

uint64_t der_parse_hex_heim_integer()
{
  return MEMORY[0x24BEDBE10]();
}

uint64_t der_print_heim_oid()
{
  return MEMORY[0x24BEDBE18]();
}

uint64_t der_print_hex_heim_integer()
{
  return MEMORY[0x24BEDBE20]();
}

uint64_t der_printable_string_cmp()
{
  return MEMORY[0x24BEDBE28]();
}

uint64_t der_put_length_and_tag()
{
  return MEMORY[0x24BEDBE38]();
}

int dirfd(DIR *dirp)
{
  return MEMORY[0x24BDADC38](dirp);
}

void dispatch_async(dispatch_queue_t queue, dispatch_block_t block)
{
  MEMORY[0x24BDADCC0](queue, block);
}

dispatch_queue_global_t dispatch_get_global_queue(intptr_t identifier, uintptr_t flags)
{
  return (dispatch_queue_global_t)MEMORY[0x24BDADDA8](identifier, flags);
}

void *__cdecl dispatch_get_specific(const void *key)
{
  return (void *)MEMORY[0x24BDADDB0](key);
}

uint64_t dispatch_mig_server()
{
  return MEMORY[0x24BDADE90]();
}

void dispatch_once(dispatch_once_t *predicate, dispatch_block_t block)
{
  MEMORY[0x24BDADE98](predicate, block);
}

void dispatch_once_f(dispatch_once_t *predicate, void *context, dispatch_function_t function)
{
  MEMORY[0x24BDADEA0](predicate, context, function);
}

dispatch_queue_t dispatch_queue_create(const char *label, dispatch_queue_attr_t attr)
{
  return (dispatch_queue_t)MEMORY[0x24BDADED0](label, attr);
}

void dispatch_queue_set_specific(dispatch_queue_t queue, const void *key, void *context, dispatch_function_t destructor)
{
  MEMORY[0x24BDADF00](queue, key, context, destructor);
}

void dispatch_release(dispatch_object_t object)
{
  MEMORY[0x24BDADF10](object);
}

void dispatch_resume(dispatch_object_t object)
{
  MEMORY[0x24BDADF18](object);
}

dispatch_semaphore_t dispatch_semaphore_create(intptr_t value)
{
  return (dispatch_semaphore_t)MEMORY[0x24BDADF28](value);
}

intptr_t dispatch_semaphore_signal(dispatch_semaphore_t dsema)
{
  return MEMORY[0x24BDADF30](dsema);
}

intptr_t dispatch_semaphore_wait(dispatch_semaphore_t dsema, dispatch_time_t timeout)
{
  return MEMORY[0x24BDADF38](dsema, timeout);
}

void dispatch_source_cancel(dispatch_source_t source)
{
  MEMORY[0x24BDADF68](source);
}

dispatch_source_t dispatch_source_create(dispatch_source_type_t type, uintptr_t handle, uintptr_t mask, dispatch_queue_t queue)
{
  return (dispatch_source_t)MEMORY[0x24BDADF70](type, handle, mask, queue);
}

void dispatch_source_set_cancel_handler(dispatch_source_t source, dispatch_block_t handler)
{
  MEMORY[0x24BDADFA0](source, handler);
}

void dispatch_source_set_event_handler(dispatch_source_t source, dispatch_block_t handler)
{
  MEMORY[0x24BDADFB0](source, handler);
}

void dispatch_sync(dispatch_queue_t queue, dispatch_block_t block)
{
  MEMORY[0x24BDADFE8](queue, block);
}

dispatch_time_t dispatch_time(dispatch_time_t when, int64_t delta)
{
  return MEMORY[0x24BDADFF8](when, delta);
}

int dlclose(void *__handle)
{
  return MEMORY[0x24BDAE060](__handle);
}

void *__cdecl dlopen(const char *__path, int __mode)
{
  return (void *)MEMORY[0x24BDAE070](__path, *(_QWORD *)&__mode);
}

void *__cdecl dlsym(void *__handle, const char *__symbol)
{
  return (void *)MEMORY[0x24BDAE088](__handle, __symbol);
}

void dns_free(dns_handle_t dns)
{
  MEMORY[0x24BEDDC70](dns);
}

dns_handle_t dns_open(const char *name)
{
  return (dns_handle_t)MEMORY[0x24BEDDC78](name);
}

int32_t dns_search(dns_handle_t dns, const char *name, uint32_t dnsclass, uint32_t dnstype, char *buf, uint32_t len, sockaddr *from, uint32_t *fromlen)
{
  return MEMORY[0x24BEDDC80](dns, name, *(_QWORD *)&dnsclass, *(_QWORD *)&dnstype, buf, *(_QWORD *)&len, from, fromlen);
}

void dns_set_debug(dns_handle_t dns, uint32_t flag)
{
  MEMORY[0x24BEDDC88](dns, *(_QWORD *)&flag);
}

int dup(int a1)
{
  return MEMORY[0x24BDAE0B8](*(_QWORD *)&a1);
}

void errx(int a1, const char *a2, ...)
{
  MEMORY[0x24BDAE1D0](*(_QWORD *)&a1, a2);
}

void exit(int a1)
{
  MEMORY[0x24BDAE268](*(_QWORD *)&a1);
}

int fclose(FILE *a1)
{
  return MEMORY[0x24BDAE2E0](a1);
}

int fcntl(int a1, int a2, ...)
{
  return MEMORY[0x24BDAE2E8](*(_QWORD *)&a1, *(_QWORD *)&a2);
}

FILE *__cdecl fdopen(int a1, const char *a2)
{
  return (FILE *)MEMORY[0x24BDAE300](*(_QWORD *)&a1, a2);
}

int ferror(FILE *a1)
{
  return MEMORY[0x24BDAE330](a1);
}

int fflush(FILE *a1)
{
  return MEMORY[0x24BDAE350](a1);
}

int fgetc(FILE *a1)
{
  return MEMORY[0x24BDAE368](a1);
}

char *__cdecl fgets(char *a1, int a2, FILE *a3)
{
  return (char *)MEMORY[0x24BDAE380](a1, *(_QWORD *)&a2, a3);
}

int fileno(FILE *a1)
{
  return MEMORY[0x24BDAE390](a1);
}

int fnmatch(const char *a1, const char *a2, int a3)
{
  return MEMORY[0x24BDAE408](a1, a2, *(_QWORD *)&a3);
}

FILE *__cdecl fopen(const char *__filename, const char *__mode)
{
  return (FILE *)MEMORY[0x24BDAE410](__filename, __mode);
}

int fprintf(FILE *a1, const char *a2, ...)
{
  return MEMORY[0x24BDAE428](a1, a2);
}

int fputc(int a1, FILE *a2)
{
  return MEMORY[0x24BDAE438](*(_QWORD *)&a1, a2);
}

int fputs(const char *a1, FILE *a2)
{
  return MEMORY[0x24BDAE440](a1, a2);
}

size_t fread(void *__ptr, size_t __size, size_t __nitems, FILE *__stream)
{
  return MEMORY[0x24BDAE448](__ptr, __size, __nitems, __stream);
}

void free(void *a1)
{
  MEMORY[0x24BDAE450](a1);
}

void freeaddrinfo(addrinfo *a1)
{
  MEMORY[0x24BDAE458](a1);
}

void freeifaddrs(ifaddrs *a1)
{
  MEMORY[0x24BDAE468](a1);
}

int fstat(int a1, stat *a2)
{
  return MEMORY[0x24BDAE508](*(_QWORD *)&a1, a2);
}

int fsync(int a1)
{
  return MEMORY[0x24BDAE528](*(_QWORD *)&a1);
}

int ftruncate(int a1, off_t a2)
{
  return MEMORY[0x24BDAE548](*(_QWORD *)&a1, a2);
}

size_t fwrite(const void *__ptr, size_t __size, size_t __nitems, FILE *__stream)
{
  return MEMORY[0x24BDAE590](__ptr, __size, __nitems, __stream);
}

const char *__cdecl gai_strerror(int a1)
{
  return (const char *)MEMORY[0x24BDAE598](*(_QWORD *)&a1);
}

int getaddrinfo(const char *a1, const char *a2, const addrinfo *a3, addrinfo **a4)
{
  return MEMORY[0x24BDAE5A0](a1, a2, a3, a4);
}

int getaudit_addr(auditinfo_addr *a1, int a2)
{
  return MEMORY[0x24BDAE5C0](a1, *(_QWORD *)&a2);
}

int getc(FILE *a1)
{
  return MEMORY[0x24BDAE5C8](a1);
}

char *__cdecl getenv(const char *a1)
{
  return (char *)MEMORY[0x24BDAE5F0](a1);
}

uid_t geteuid(void)
{
  return MEMORY[0x24BDAE5F8]();
}

hostent *__cdecl gethostbyname(const char *a1)
{
  return (hostent *)MEMORY[0x24BDAE640](a1);
}

int gethostname(char *a1, size_t a2)
{
  return MEMORY[0x24BDAE650](a1, a2);
}

int getifaddrs(ifaddrs **a1)
{
  return MEMORY[0x24BDAE660](a1);
}

char *getlogin(void)
{
  return (char *)MEMORY[0x24BDAE680]();
}

int getnameinfo(const sockaddr *a1, socklen_t a2, char *a3, socklen_t a4, char *a5, socklen_t a6, int a7)
{
  return MEMORY[0x24BDAE6A0](a1, *(_QWORD *)&a2, a3, *(_QWORD *)&a4, a5, *(_QWORD *)&a6, *(_QWORD *)&a7);
}

int getpeername(int a1, sockaddr *a2, socklen_t *a3)
{
  return MEMORY[0x24BDAE6C0](*(_QWORD *)&a1, a2, a3);
}

pid_t getpid(void)
{
  return MEMORY[0x24BDAE6D0]();
}

const char *getprogname(void)
{
  return (const char *)MEMORY[0x24BDAE6E8]();
}

passwd *__cdecl getpwnam(const char *a1)
{
  return (passwd *)MEMORY[0x24BDAE710](a1);
}

passwd *__cdecl getpwuid(uid_t a1)
{
  return (passwd *)MEMORY[0x24BDAE720](*(_QWORD *)&a1);
}

servent *__cdecl getservbyname(const char *a1, const char *a2)
{
  return (servent *)MEMORY[0x24BDAE758](a1, a2);
}

int getsockname(int a1, sockaddr *a2, socklen_t *a3)
{
  return MEMORY[0x24BDAE770](*(_QWORD *)&a1, a2, a3);
}

int gettimeofday(timeval *a1, void *a2)
{
  return MEMORY[0x24BDAE780](a1, a2);
}

uid_t getuid(void)
{
  return MEMORY[0x24BDAE788]();
}

tm *__cdecl gmtime(const time_t *a1)
{
  return (tm *)MEMORY[0x24BDAE7B0](a1);
}

uint64_t heim_any_cmp()
{
  return MEMORY[0x24BEDBE48]();
}

int inet_aton(const char *a1, in_addr *a2)
{
  return MEMORY[0x24BDAE898](a1, a2);
}

char *__cdecl inet_ntoa(in_addr a1)
{
  return (char *)MEMORY[0x24BDAE8A8](*(_QWORD *)&a1.s_addr);
}

const char *__cdecl inet_ntop(int a1, const void *a2, char *a3, socklen_t a4)
{
  return (const char *)MEMORY[0x24BDAE8B0](*(_QWORD *)&a1, a2, a3, *(_QWORD *)&a4);
}

int inet_pton(int a1, const char *a2, void *a3)
{
  return MEMORY[0x24BDAE8B8](*(_QWORD *)&a1, a2, a3);
}

int ioctl(int a1, unint64_t a2, ...)
{
  return MEMORY[0x24BDAE8C8](*(_QWORD *)&a1, a2);
}

int issetugid(void)
{
  return MEMORY[0x24BDAE908]();
}

tm *__cdecl localtime(const time_t *a1)
{
  return (tm *)MEMORY[0x24BDAEA98](a1);
}

off_t lseek(int a1, off_t a2, int a3)
{
  return MEMORY[0x24BDAEB20](*(_QWORD *)&a1, a2, *(_QWORD *)&a3);
}

int lstat(const char *a1, stat *a2)
{
  return MEMORY[0x24BDAEB28](a1, a2);
}

mach_msg_return_t mach_msg(mach_msg_header_t *msg, mach_msg_option_t option, mach_msg_size_t send_size, mach_msg_size_t rcv_size, mach_port_name_t rcv_name, mach_msg_timeout_t timeout, mach_port_name_t notify)
{
  return MEMORY[0x24BDAEB80](msg, *(_QWORD *)&option, *(_QWORD *)&send_size, *(_QWORD *)&rcv_size, *(_QWORD *)&rcv_name, *(_QWORD *)&timeout, *(_QWORD *)&notify);
}

void mach_msg_destroy(mach_msg_header_t *a1)
{
  MEMORY[0x24BDAEB90](a1);
}

kern_return_t mach_port_allocate(ipc_space_t task, mach_port_right_t right, mach_port_name_t *name)
{
  return MEMORY[0x24BDAEBA0](*(_QWORD *)&task, *(_QWORD *)&right, name);
}

kern_return_t mach_port_deallocate(ipc_space_t task, mach_port_name_t name)
{
  return MEMORY[0x24BDAEBB0](*(_QWORD *)&task, *(_QWORD *)&name);
}

kern_return_t mach_port_mod_refs(ipc_space_t task, mach_port_name_t name, mach_port_right_t right, mach_port_delta_t delta)
{
  return MEMORY[0x24BDAEBF8](*(_QWORD *)&task, *(_QWORD *)&name, *(_QWORD *)&right, *(_QWORD *)&delta);
}

void *__cdecl malloc_type_calloc(size_t count, size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x24BDAED70](count, size, type_id);
}

void *__cdecl malloc_type_malloc(size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x24BDAED78](size, type_id);
}

void *__cdecl malloc_type_realloc(void *ptr, size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x24BDAED88](ptr, size, type_id);
}

int mbr_identifier_to_uuid(int id_type, const void *identifier, size_t identifier_size, uuid_t uu)
{
  return MEMORY[0x24BDAEE18](*(_QWORD *)&id_type, identifier, identifier_size, uu);
}

void *__cdecl memchr(void *__s, int __c, size_t __n)
{
  return (void *)MEMORY[0x24BDAEE70](__s, *(_QWORD *)&__c, __n);
}

int memcmp(const void *__s1, const void *__s2, size_t __n)
{
  return MEMORY[0x24BDAEE78](__s1, __s2, __n);
}

void *__cdecl memcpy(void *__dst, const void *__src, size_t __n)
{
  return (void *)MEMORY[0x24BDAEE80](__dst, __src, __n);
}

void *__cdecl memmove(void *__dst, const void *__src, size_t __len)
{
  return (void *)MEMORY[0x24BDAEE98](__dst, __src, __len);
}

void *__cdecl memset(void *__b, int __c, size_t __len)
{
  return (void *)MEMORY[0x24BDAEEA8](__b, *(_QWORD *)&__c, __len);
}

void mig_dealloc_reply_port(mach_port_t reply_port)
{
  MEMORY[0x24BDAEEE0](*(_QWORD *)&reply_port);
}

void mig_deallocate(vm_address_t a1, vm_size_t a2)
{
  MEMORY[0x24BDAEEF0](a1, a2);
}

mach_port_t mig_get_reply_port(void)
{
  return MEMORY[0x24BDAEEF8]();
}

void mig_put_reply_port(mach_port_t reply_port)
{
  MEMORY[0x24BDAEF08](*(_QWORD *)&reply_port);
}

int mkstemp(char *a1)
{
  return MEMORY[0x24BDAEF70](a1);
}

uint64_t ne_session_service_get_dns_service_id()
{
  return MEMORY[0x24BDAF058]();
}

uint64_t ne_session_set_socket_attributes()
{
  return MEMORY[0x24BDAF068]();
}

uint32_t notify_check(int token, int *check)
{
  return MEMORY[0x24BDAF140](*(_QWORD *)&token, check);
}

uint32_t notify_register_check(const char *name, int *out_token)
{
  return MEMORY[0x24BDAF168](name, out_token);
}

nw_endpoint_t nw_endpoint_create_host(const char *hostname, const char *port)
{
  return (nw_endpoint_t)MEMORY[0x24BDE0E88](hostname, port);
}

uint32_t nw_interface_get_index(nw_interface_t interface)
{
  return MEMORY[0x24BDE13A8](interface);
}

nw_parameters_t nw_parameters_create(void)
{
  return (nw_parameters_t)MEMORY[0x24BDE1558]();
}

uint64_t nw_parameters_set_e_proc_uuid()
{
  return MEMORY[0x24BDE1670]();
}

uint64_t nw_parameters_set_pid()
{
  return MEMORY[0x24BDE1700]();
}

uint64_t nw_path_copy_scoped_interface()
{
  return MEMORY[0x24BDE17E0]();
}

uint64_t nw_path_create_evaluator_for_endpoint()
{
  return MEMORY[0x24BDE17F0]();
}

uint64_t nw_path_evaluator_copy_path()
{
  return MEMORY[0x24BDE1828]();
}

uint64_t nw_path_get_vpn_config_id()
{
  return MEMORY[0x24BDE1958]();
}

uint64_t nw_path_is_flow_divert()
{
  return MEMORY[0x24BDE19D0]();
}

uint64_t nw_path_is_per_app_vpn()
{
  return MEMORY[0x24BDE19E0]();
}

void nw_release(void *obj)
{
  MEMORY[0x24BDE2380](obj);
}

id objc_alloc(Class a1)
{
  return (id)MEMORY[0x24BEDCF68](a1);
}

void objc_autoreleasePoolPop(void *context)
{
  MEMORY[0x24BEDCFB0](context);
}

void *objc_autoreleasePoolPush(void)
{
  return (void *)MEMORY[0x24BEDCFC0]();
}

int open(const char *a1, int a2, ...)
{
  return MEMORY[0x24BDAF228](a1, *(_QWORD *)&a2);
}

DIR *__cdecl opendir(const char *a1)
{
  return (DIR *)MEMORY[0x24BDAF258](a1);
}

void openlog(const char *a1, int a2, int a3)
{
  MEMORY[0x24BDAF260](a1, *(_QWORD *)&a2, *(_QWORD *)&a3);
}

os_log_t os_log_create(const char *subsystem, const char *category)
{
  return (os_log_t)MEMORY[0x24BDAF368](subsystem, category);
}

BOOL os_log_type_enabled(os_log_t oslog, os_log_type_t type)
{
  return MEMORY[0x24BDAF398](oslog, type);
}

void os_release(void *object)
{
  MEMORY[0x24BDAF3F0](object);
}

int printf(const char *a1, ...)
{
  return MEMORY[0x24BDAF6A8](a1);
}

int pthread_is_threaded_np(void)
{
  return MEMORY[0x24BDAF878]();
}

int pthread_main_np(void)
{
  return MEMORY[0x24BDAF8B0]();
}

int pthread_mutex_destroy(pthread_mutex_t *a1)
{
  return MEMORY[0x24BDAF8C0](a1);
}

int pthread_mutex_init(pthread_mutex_t *a1, const pthread_mutexattr_t *a2)
{
  return MEMORY[0x24BDAF8C8](a1, a2);
}

int pthread_mutex_lock(pthread_mutex_t *a1)
{
  return MEMORY[0x24BDAF8D0](a1);
}

int pthread_mutex_unlock(pthread_mutex_t *a1)
{
  return MEMORY[0x24BDAF8E0](a1);
}

int puts(const char *a1)
{
  return MEMORY[0x24BDAF9F8](a1);
}

void qsort(void *__base, size_t __nel, size_t __width, int (__cdecl *__compar)(const void *, const void *))
{
  MEMORY[0x24BDAFA18](__base, __nel, __width, __compar);
}

ssize_t read(int a1, void *a2, size_t a3)
{
  return MEMORY[0x24BDAFA80](*(_QWORD *)&a1, a2, a3);
}

dirent *__cdecl readdir(DIR *a1)
{
  return (dirent *)MEMORY[0x24BDAFA88](a1);
}

ssize_t recv(int a1, void *a2, size_t a3, int a4)
{
  return MEMORY[0x24BDAFAE0](*(_QWORD *)&a1, a2, a3, *(_QWORD *)&a4);
}

BOOL remove(const std::__fs::filesystem::path *__p, std::error_code *__ec)
{
  return MEMORY[0x24BDAFB38](__p, __ec);
}

void rename(const std::__fs::filesystem::path *__from, const std::__fs::filesystem::path *__to, std::error_code *__ec)
{
  MEMORY[0x24BDAFB80](__from, __to, __ec);
}

int res_9_dn_expand(const u_char *a1, const u_char *a2, const u_char *a3, char *a4, int a5)
{
  return MEMORY[0x24BEDDC90](a1, a2, a3, a4, *(_QWORD *)&a5);
}

int select(int a1, fd_set *a2, fd_set *a3, fd_set *a4, timeval *a5)
{
  return MEMORY[0x24BDAFC70](*(_QWORD *)&a1, a2, a3, a4, a5);
}

ssize_t send(int a1, const void *a2, size_t a3, int a4)
{
  return MEMORY[0x24BDAFCE8](*(_QWORD *)&a1, a2, a3, *(_QWORD *)&a4);
}

int setsockopt(int a1, int a2, int a3, const void *a4, socklen_t a5)
{
  return MEMORY[0x24BDAFD78](*(_QWORD *)&a1, *(_QWORD *)&a2, *(_QWORD *)&a3, a4, *(_QWORD *)&a5);
}

int sigaction(int a1, const sigaction *a2, sigaction *a3)
{
  return MEMORY[0x24BDAFDE8](*(_QWORD *)&a1, a2, a3);
}

int snprintf(char *__str, size_t __size, const char *__format, ...)
{
  return MEMORY[0x24BDAFE40](__str, __size, __format);
}

int socket(int a1, int a2, int a3)
{
  return MEMORY[0x24BDAFE50](*(_QWORD *)&a1, *(_QWORD *)&a2, *(_QWORD *)&a3);
}

int socketpair(int a1, int a2, int a3, int *a4)
{
  return MEMORY[0x24BDAFE58](*(_QWORD *)&a1, *(_QWORD *)&a2, *(_QWORD *)&a3, a4);
}

int sscanf(const char *a1, const char *a2, ...)
{
  return MEMORY[0x24BDAFEA0](a1, a2);
}

int stat(const char *a1, stat *a2)
{
  return MEMORY[0x24BDAFEA8](a1, a2);
}

int strcasecmp(const char *a1, const char *a2)
{
  return MEMORY[0x24BDAFED0](a1, a2);
}

char *__cdecl strchr(char *__s, int __c)
{
  return (char *)MEMORY[0x24BDAFEE8](__s, *(_QWORD *)&__c);
}

int strcmp(const char *__s1, const char *__s2)
{
  return MEMORY[0x24BDAFEF0](__s1, __s2);
}

size_t strcspn(const char *__s, const char *__charset)
{
  return MEMORY[0x24BDAFF08](__s, __charset);
}

char *__cdecl strdup(const char *__s1)
{
  return (char *)MEMORY[0x24BDAFF10](__s1);
}

char *__cdecl strerror(int __errnum)
{
  return (char *)MEMORY[0x24BDAFF18](*(_QWORD *)&__errnum);
}

int strerror_r(int __errnum, char *__strerrbuf, size_t __buflen)
{
  return MEMORY[0x24BDAFF20](*(_QWORD *)&__errnum, __strerrbuf, __buflen);
}

size_t strftime(char *a1, size_t a2, const char *a3, const tm *a4)
{
  return MEMORY[0x24BDAFF28](a1, a2, a3, a4);
}

size_t strlcat(char *__dst, const char *__source, size_t __size)
{
  return MEMORY[0x24BDAFF30](__dst, __source, __size);
}

size_t strlcpy(char *__dst, const char *__source, size_t __size)
{
  return MEMORY[0x24BDAFF38](__dst, __source, __size);
}

size_t strlen(const char *__s)
{
  return MEMORY[0x24BDAFF40](__s);
}

int strncasecmp(const char *a1, const char *a2, size_t a3)
{
  return MEMORY[0x24BDAFF50](a1, a2, a3);
}

int strncmp(const char *__s1, const char *__s2, size_t __n)
{
  return MEMORY[0x24BDAFF68](__s1, __s2, __n);
}

char *__cdecl strncpy(char *__dst, const char *__src, size_t __n)
{
  return (char *)MEMORY[0x24BDAFF70](__dst, __src, __n);
}

char *__cdecl strrchr(char *__s, int __c)
{
  return (char *)MEMORY[0x24BDAFFA8](__s, *(_QWORD *)&__c);
}

char *__cdecl strsep(char **__stringp, const char *__delim)
{
  return (char *)MEMORY[0x24BDAFFB0](__stringp, __delim);
}

char *__cdecl strstr(char *__s1, const char *__s2)
{
  return (char *)MEMORY[0x24BDAFFC8](__s1, __s2);
}

char *__cdecl strtok_r(char *__str, const char *__sep, char **__lasts)
{
  return (char *)MEMORY[0x24BDAFFF8](__str, __sep, __lasts);
}

uint64_t strtol(const char *__str, char **__endptr, int __base)
{
  return MEMORY[0x24BDB0000](__str, __endptr, *(_QWORD *)&__base);
}

int strvisx(char *a1, const char *a2, size_t a3, int a4)
{
  return MEMORY[0x24BDB0068](a1, a2, a3, *(_QWORD *)&a4);
}

void syslog(int a1, const char *a2, ...)
{
  MEMORY[0x24BDB0128](*(_QWORD *)&a1, a2);
}

int tcgetattr(int a1, termios *a2)
{
  return MEMORY[0x24BDB01E0](*(_QWORD *)&a1, a2);
}

int tcsetattr(int a1, int a2, const termios *a3)
{
  return MEMORY[0x24BDB01E8](*(_QWORD *)&a1, *(_QWORD *)&a2, a3);
}

time_t time(time_t *a1)
{
  return MEMORY[0x24BDB0240](a1);
}

int unlink(const char *a1)
{
  return MEMORY[0x24BDB02B0](a1);
}

int uuid_compare(const uuid_t uu1, const uuid_t uu2)
{
  return MEMORY[0x24BDB0308](uu1, uu2);
}

int uuid_parse(const uuid_string_t in, uuid_t uu)
{
  return MEMORY[0x24BDB0330](in, uu);
}

void uuid_unparse(const uuid_t uu, uuid_string_t out)
{
  MEMORY[0x24BDB0338](uu, out);
}

int vasprintf(char **a1, const char *a2, va_list a3)
{
  return MEMORY[0x24BDB0358](a1, a2, a3);
}

int vfprintf(FILE *a1, const char *a2, va_list a3)
{
  return MEMORY[0x24BDB0370](a1, a2, a3);
}

kern_return_t vm_deallocate(vm_map_t target_task, vm_address_t address, vm_size_t size)
{
  return MEMORY[0x24BDB0390](*(_QWORD *)&target_task, address, size);
}

kern_return_t vm_read(vm_map_read_t target_task, vm_address_t address, vm_size_t size, vm_offset_t *data, mach_msg_type_number_t *dataCnt)
{
  return MEMORY[0x24BDB03E0](*(_QWORD *)&target_task, address, size, data, dataCnt);
}

BOOLean_t voucher_mach_msg_set(mach_msg_header_t *msg)
{
  return MEMORY[0x24BDB0418](msg);
}

uint64_t vproc_swap_integer()
{
  return MEMORY[0x24BDB0438]();
}

int vsnprintf(char *__str, size_t __size, const char *__format, va_list a4)
{
  return MEMORY[0x24BDB0448](__str, __size, __format, a4);
}

void warnx(const char *a1, ...)
{
  MEMORY[0x24BDB0490](a1);
}

ssize_t write(int __fd, const void *__buf, size_t __nbyte)
{
  return MEMORY[0x24BDB0558](*(_QWORD *)&__fd, __buf, __nbyte);
}

BOOL xpc_array_apply(xpc_object_t xarray, xpc_array_applier_t applier)
{
  return MEMORY[0x24BDB0638](xarray, applier);
}

size_t xpc_array_get_count(xpc_object_t xarray)
{
  return MEMORY[0x24BDB0660](xarray);
}

const uint8_t *__cdecl xpc_array_get_uuid(xpc_object_t xarray, size_t index)
{
  return (const uint8_t *)MEMORY[0x24BDB0698](xarray, index);
}

BOOL xpc_BOOL_get_value(xpc_object_t xBOOL)
{
  return MEMORY[0x24BDB06E0](xBOOL);
}

xpc_connection_t xpc_connection_create_mach_service(const char *name, dispatch_queue_t targetq, uint64_t flags)
{
  return (xpc_connection_t)MEMORY[0x24BDB0740](name, targetq, flags);
}

void xpc_connection_resume(xpc_connection_t connection)
{
  MEMORY[0x24BDB0798](connection);
}

void xpc_connection_send_message(xpc_connection_t connection, xpc_object_t message)
{
  MEMORY[0x24BDB07A8](connection, message);
}

xpc_object_t xpc_connection_send_message_with_reply_sync(xpc_connection_t connection, xpc_object_t message)
{
  return (xpc_object_t)MEMORY[0x24BDB07B8](connection, message);
}

void xpc_connection_set_event_handler(xpc_connection_t connection, xpc_handler_t handler)
{
  MEMORY[0x24BDB07C8](connection, handler);
}

xpc_object_t xpc_dictionary_create(const char *const *keys, xpc_object_t *values, size_t count)
{
  return (xpc_object_t)MEMORY[0x24BDB08C0](keys, values, count);
}

const uint8_t *__cdecl xpc_dictionary_get_uuid(xpc_object_t xdict, const char *key)
{
  return (const uint8_t *)MEMORY[0x24BDB0960](xdict, key);
}

xpc_object_t xpc_dictionary_get_value(xpc_object_t xdict, const char *key)
{
  return (xpc_object_t)MEMORY[0x24BDB0968](xdict, key);
}

void xpc_dictionary_set_data(xpc_object_t xdict, const char *key, const void *bytes, size_t length)
{
  MEMORY[0x24BDB0988](xdict, key, bytes, length);
}

void xpc_dictionary_set_int64(xpc_object_t xdict, const char *key, int64_t value)
{
  MEMORY[0x24BDB09A8](xdict, key, value);
}

void xpc_dictionary_set_string(xpc_object_t xdict, const char *key, const char *string)
{
  MEMORY[0x24BDB09C8](xdict, key, string);
}

void xpc_dictionary_set_uuid(xpc_object_t xdict, const char *key, const unsigned __int8 *uuid)
{
  MEMORY[0x24BDB09D8](xdict, key, uuid);
}

void xpc_dictionary_set_value(xpc_object_t xdict, const char *key, xpc_object_t value)
{
  MEMORY[0x24BDB09E0](xdict, key, value);
}

xpc_type_t xpc_get_type(xpc_object_t object)
{
  return (xpc_type_t)MEMORY[0x24BDB0A70](object);
}

void xpc_release(xpc_object_t object)
{
  MEMORY[0x24BDB0AE0](object);
}

