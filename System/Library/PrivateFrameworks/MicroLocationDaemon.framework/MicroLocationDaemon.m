void CLMicroLocationProto::AppLaunch::CopyFrom(CLMicroLocationProto::AppLaunch *this, const CLMicroLocationProto::AppLaunch *a2)
{
  if (a2 != this)
  {
    (*(void (**)(CLMicroLocationProto::AppLaunch *))(*(_QWORD *)this + 32))(this);
    CLMicroLocationProto::AppLaunch::MergeFrom(this, a2);
  }
}

uint64_t CLMicroLocationProto::AppLaunch::Clear(uint64_t this)
{
  char v1;
  uint64_t v2;
  uint64_t v3;
  int v4;
  uint64_t v5;
  uint64_t v6;

  v1 = *(_BYTE *)(this + 40);
  if (v1)
  {
    *(_DWORD *)(this + 32) = 2;
    v2 = MEMORY[0x24BEDD958];
    if ((v1 & 2) != 0)
    {
      v3 = *(_QWORD *)(this + 8);
      if (v3 != MEMORY[0x24BEDD958])
      {
        if (*(char *)(v3 + 23) < 0)
        {
          **(_BYTE **)v3 = 0;
          *(_QWORD *)(v3 + 8) = 0;
        }
        else
        {
          *(_BYTE *)v3 = 0;
          *(_BYTE *)(v3 + 23) = 0;
        }
      }
    }
    v4 = *(_DWORD *)(this + 40);
    if ((v4 & 4) != 0)
    {
      v5 = *(_QWORD *)(this + 16);
      if (v5)
      {
        if (*(_BYTE *)(v5 + 16))
          *(_WORD *)(v5 + 8) = 0;
        *(_DWORD *)(v5 + 16) = 0;
        v4 = *(_DWORD *)(this + 40);
      }
    }
    if ((v4 & 8) != 0)
    {
      v6 = *(_QWORD *)(this + 24);
      if (v6 != v2)
      {
        if (*(char *)(v6 + 23) < 0)
        {
          **(_BYTE **)v6 = 0;
          *(_QWORD *)(v6 + 8) = 0;
        }
        else
        {
          *(_BYTE *)v6 = 0;
          *(_BYTE *)(v6 + 23) = 0;
        }
      }
    }
  }
  *(_DWORD *)(this + 40) = 0;
  return this;
}

void CLMicroLocationProto::ReceivedEvent::~ReceivedEvent(CLMicroLocationProto::ReceivedEvent *this)
{
  *(_QWORD *)this = &off_2511D8090;
  CLMicroLocationProto::ReceivedEvent::SharedDtor(this);
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(this);
}

{
  CLMicroLocationProto::ReceivedEvent::~ReceivedEvent(this);
  JUMPOUT(0x2426A04D4);
}

CLMicroLocationProto::ReceivedEvent *CLMicroLocationProto::ReceivedEvent::ReceivedEvent(CLMicroLocationProto::ReceivedEvent *this, const CLMicroLocationProto::ReceivedEvent *a2)
{
  *(_QWORD *)this = &off_2511D8090;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 40) = 0u;
  *(_OWORD *)((char *)this + 56) = 0u;
  *(_OWORD *)((char *)this + 72) = 0u;
  *(_OWORD *)((char *)this + 88) = 0u;
  *(_OWORD *)((char *)this + 104) = 0u;
  *(_OWORD *)((char *)this + 120) = 0u;
  *(_OWORD *)((char *)this + 136) = 0u;
  *(_OWORD *)((char *)this + 152) = 0u;
  *(_OWORD *)((char *)this + 168) = 0u;
  *(_OWORD *)((char *)this + 184) = 0u;
  *(_OWORD *)((char *)this + 200) = 0u;
  *(_OWORD *)((char *)this + 216) = 0u;
  *(_OWORD *)((char *)this + 232) = 0u;
  *(_OWORD *)((char *)this + 248) = 0u;
  *((_DWORD *)this + 74) = 0;
  *(_OWORD *)((char *)this + 8) = 0u;
  *(_OWORD *)((char *)this + 264) = 0u;
  *(_OWORD *)((char *)this + 280) = 0u;
  CLMicroLocationProto::ReceivedEvent::MergeFrom(this, a2);
  return this;
}

void sub_2419DB354(_Unwind_Exception *a1)
{
  wireless_diagnostics::google::protobuf::MessageLite *v1;

  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(v1);
  _Unwind_Resume(a1);
}

void CLMicroLocationProto::ReceivedEvent::MergeFrom(CLMicroLocationProto::ReceivedEvent *this, const CLMicroLocationProto::ReceivedEvent *a2)
{
  CLMicroLocationProto::ReceivedEvent *v3;
  unsigned int v4;
  CLMicroLocationProto::ReceivedEventAction *v5;
  uint64_t v6;
  const CLMicroLocationProto::ReceivedEventAction *v7;
  CLMicroLocationProto::AppLaunch *v8;
  uint64_t v9;
  const CLMicroLocationProto::AppLaunch *v10;
  CLMicroLocationProto::BacklightOn *v11;
  uint64_t v12;
  const CLMicroLocationProto::BacklightOn *v13;
  CLMicroLocationProto::BatteryChargerConnected *v14;
  const CLMicroLocationProto::BatteryChargerConnected *v15;
  CLMicroLocationProto::ForcedRecording *v16;
  const CLMicroLocationProto::ForcedRecording *v17;
  CLMicroLocationProto::HomeKitAccessory *v18;
  uint64_t v19;
  const CLMicroLocationProto::HomeKitAccessory *v20;
  CLMicroLocationProto::HomeKitScene *v21;
  uint64_t v22;
  const CLMicroLocationProto::HomeKitScene *v23;
  CLMicroLocationProto::NowPlaying *v24;
  uint64_t v25;
  const CLMicroLocationProto::NowPlaying *v26;
  CLMicroLocationProto::RecordingRequest *v27;
  uint64_t v28;
  const CLMicroLocationProto::RecordingRequest *v29;
  CLMicroLocationProto::TruthLabelDonation *v30;
  uint64_t v31;
  const CLMicroLocationProto::TruthLabelDonation *v32;
  CLMicroLocationProto::LearnModel *v33;
  const CLMicroLocationProto::LearnModel *v34;
  CLMicroLocationProto::LearnCompleted *v35;
  const CLMicroLocationProto::LearnCompleted *v36;
  CLMicroLocationProto::SensorsScanComplete *v37;
  const CLMicroLocationProto::SensorsScanComplete *v38;
  CLMicroLocationProto::StartSpectating *v39;
  const CLMicroLocationProto::StartSpectating *v40;
  CLMicroLocationProto::StopSpectating *v41;
  const CLMicroLocationProto::StopSpectating *v42;
  CLMicroLocationProto::ServiceCreate *v43;
  uint64_t v44;
  const CLMicroLocationProto::ServiceCreate *v45;
  CLMicroLocationProto::ServiceDelete *v46;
  uint64_t v47;
  const CLMicroLocationProto::ServiceDelete *v48;
  CLMicroLocationProto::ServiceConnect *v49;
  uint64_t v50;
  const CLMicroLocationProto::ServiceConnect *v51;
  CLMicroLocationProto::ServiceDisconnect *v52;
  uint64_t v53;
  const CLMicroLocationProto::ServiceDisconnect *v54;
  CLMicroLocationProto::ServiceStartUpdating *v55;
  uint64_t v56;
  const CLMicroLocationProto::ServiceStartUpdating *v57;
  CLMicroLocationProto::ServiceStopUpdating *v58;
  uint64_t v59;
  const CLMicroLocationProto::ServiceStopUpdating *v60;
  CLMicroLocationProto::RequestObservation *v61;
  uint64_t v62;
  const CLMicroLocationProto::RequestObservation *v63;
  CLMicroLocationProto::RequestPrediction *v64;
  uint64_t v65;
  const CLMicroLocationProto::RequestPrediction *v66;
  CLMicroLocationProto::MiloInit *v67;
  uint64_t v68;
  const CLMicroLocationProto::MiloInit *v69;
  CLMicroLocationProto::MotionEvent *v70;
  uint64_t v71;
  const CLMicroLocationProto::MotionEvent *v72;
  CLMicroLocationProto::LegacyThrottle *v73;
  uint64_t v74;
  const CLMicroLocationProto::LegacyThrottle *v75;
  CLMicroLocationProto::RetrievedLoi *v76;
  uint64_t v77;
  const CLMicroLocationProto::RetrievedLoi *v78;
  CLMicroLocationProto::TriggerEvent *v79;
  uint64_t v80;
  const CLMicroLocationProto::TriggerEvent *v81;
  CLMicroLocationProto::LegacyClientStatusUpdate *v82;
  const CLMicroLocationProto::LegacyClientStatusUpdate *v83;
  CLMicroLocationProto::SpectatingMotionUpdate *v84;
  const CLMicroLocationProto::SpectatingMotionUpdate *v85;
  CLMicroLocationProto::EnabledStateUpdate *v86;
  const CLMicroLocationProto::EnabledStateUpdate *v87;
  CLMicroLocationProto::ScreenStateUpdate *v88;
  const CLMicroLocationProto::ScreenStateUpdate *v89;
  int v90;
  CLMicroLocationProto::CloudBackupExport *v91;
  const CLMicroLocationProto::CloudBackupExport *v92;
  CLMicroLocationProto::CloudBackupImport *v93;
  const CLMicroLocationProto::CloudBackupImport *v94;
  CLMicroLocationProto::DataMigration *v95;
  const CLMicroLocationProto::DataMigration *v96;
  _BYTE v97[48];

  v3 = this;
  if (a2 == this)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
    wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v97);
  }
  v4 = *((_DWORD *)a2 + 73);
  if (!(_BYTE)v4)
    goto LABEL_53;
  if ((v4 & 1) != 0)
  {
    *((_DWORD *)v3 + 73) |= 1u;
    v5 = (CLMicroLocationProto::ReceivedEventAction *)*((_QWORD *)v3 + 1);
    if (!v5)
    {
      this = (CLMicroLocationProto::ReceivedEvent *)operator new();
      v5 = this;
      *(_QWORD *)this = &off_2511D7370;
      *((_QWORD *)this + 1) = 0x100000001;
      v6 = MEMORY[0x24BEDD958];
      *((_QWORD *)this + 2) = MEMORY[0x24BEDD958];
      *((_QWORD *)this + 3) = v6;
      *((_QWORD *)this + 4) = v6;
      *((_QWORD *)this + 5) = 0;
      *((_QWORD *)v3 + 1) = this;
    }
    v7 = (const CLMicroLocationProto::ReceivedEventAction *)*((_QWORD *)a2 + 1);
    if (!v7)
    {
      CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto(this);
      v7 = *(const CLMicroLocationProto::ReceivedEventAction **)(CLMicroLocationProto::ReceivedEvent::default_instance_
                                                               + 8);
    }
    CLMicroLocationProto::ReceivedEventAction::MergeFrom(v5, v7);
    v4 = *((_DWORD *)a2 + 73);
    if ((v4 & 2) == 0)
    {
LABEL_6:
      if ((v4 & 4) == 0)
        goto LABEL_7;
      goto LABEL_23;
    }
  }
  else if ((v4 & 2) == 0)
  {
    goto LABEL_6;
  }
  *((_DWORD *)v3 + 73) |= 2u;
  v8 = (CLMicroLocationProto::AppLaunch *)*((_QWORD *)v3 + 2);
  if (!v8)
  {
    this = (CLMicroLocationProto::ReceivedEvent *)operator new();
    v8 = this;
    *((_QWORD *)this + 4) = 2;
    v9 = MEMORY[0x24BEDD958];
    *(_QWORD *)this = &off_2511D7460;
    *((_QWORD *)this + 1) = v9;
    *((_QWORD *)this + 2) = 0;
    *((_QWORD *)this + 3) = v9;
    *((_DWORD *)this + 10) = 0;
    *((_QWORD *)v3 + 2) = this;
  }
  v10 = (const CLMicroLocationProto::AppLaunch *)*((_QWORD *)a2 + 2);
  if (!v10)
  {
    CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto(this);
    v10 = *(const CLMicroLocationProto::AppLaunch **)(CLMicroLocationProto::ReceivedEvent::default_instance_ + 16);
  }
  CLMicroLocationProto::AppLaunch::MergeFrom(v8, v10);
  v4 = *((_DWORD *)a2 + 73);
  if ((v4 & 4) == 0)
  {
LABEL_7:
    if ((v4 & 8) == 0)
      goto LABEL_8;
    goto LABEL_28;
  }
LABEL_23:
  *((_DWORD *)v3 + 73) |= 4u;
  v11 = (CLMicroLocationProto::BacklightOn *)*((_QWORD *)v3 + 3);
  if (!v11)
  {
    this = (CLMicroLocationProto::ReceivedEvent *)operator new();
    v11 = this;
    *((_QWORD *)this + 2) = 4;
    v12 = MEMORY[0x24BEDD958];
    *(_QWORD *)this = &off_2511D74D8;
    *((_QWORD *)this + 1) = v12;
    *((_DWORD *)this + 6) = 0;
    *((_QWORD *)v3 + 3) = this;
  }
  v13 = (const CLMicroLocationProto::BacklightOn *)*((_QWORD *)a2 + 3);
  if (!v13)
  {
    CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto(this);
    v13 = *(const CLMicroLocationProto::BacklightOn **)(CLMicroLocationProto::ReceivedEvent::default_instance_ + 24);
  }
  CLMicroLocationProto::BacklightOn::MergeFrom(v11, v13);
  v4 = *((_DWORD *)a2 + 73);
  if ((v4 & 8) == 0)
  {
LABEL_8:
    if ((v4 & 0x10) == 0)
      goto LABEL_9;
    goto LABEL_33;
  }
LABEL_28:
  *((_DWORD *)v3 + 73) |= 8u;
  v14 = (CLMicroLocationProto::BatteryChargerConnected *)*((_QWORD *)v3 + 4);
  if (!v14)
  {
    this = (CLMicroLocationProto::ReceivedEvent *)operator new();
    v14 = this;
    *(_QWORD *)this = &off_2511D7550;
    *((_QWORD *)this + 1) = 5;
    *((_DWORD *)this + 4) = 0;
    *((_QWORD *)v3 + 4) = this;
  }
  v15 = (const CLMicroLocationProto::BatteryChargerConnected *)*((_QWORD *)a2 + 4);
  if (!v15)
  {
    CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto(this);
    v15 = *(const CLMicroLocationProto::BatteryChargerConnected **)(CLMicroLocationProto::ReceivedEvent::default_instance_
                                                                  + 32);
  }
  CLMicroLocationProto::BatteryChargerConnected::MergeFrom(v14, v15);
  v4 = *((_DWORD *)a2 + 73);
  if ((v4 & 0x10) == 0)
  {
LABEL_9:
    if ((v4 & 0x20) == 0)
      goto LABEL_10;
LABEL_38:
    *((_DWORD *)v3 + 73) |= 0x20u;
    v18 = (CLMicroLocationProto::HomeKitAccessory *)*((_QWORD *)v3 + 6);
    if (!v18)
    {
      this = (CLMicroLocationProto::ReceivedEvent *)operator new();
      v18 = this;
      v19 = MEMORY[0x24BEDD958];
      *((_DWORD *)this + 16) = 9;
      *(_QWORD *)this = &off_2511D76B8;
      *((_QWORD *)this + 1) = v19;
      *((_QWORD *)this + 2) = v19;
      *((_QWORD *)this + 3) = v19;
      *((_QWORD *)this + 4) = v19;
      *((_QWORD *)this + 5) = v19;
      *((_QWORD *)this + 6) = v19;
      *((_QWORD *)this + 7) = v19;
      *((_QWORD *)this + 9) = v19;
      *((_QWORD *)this + 10) = v19;
      *((_WORD *)this + 34) = 0;
      *((_QWORD *)this + 11) = v19;
      *((_QWORD *)this + 12) = v19;
      *((_QWORD *)this + 13) = v19;
      *((_QWORD *)this + 14) = 0;
      *((_QWORD *)v3 + 6) = this;
    }
    v20 = (const CLMicroLocationProto::HomeKitAccessory *)*((_QWORD *)a2 + 6);
    if (!v20)
    {
      CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto(this);
      v20 = *(const CLMicroLocationProto::HomeKitAccessory **)(CLMicroLocationProto::ReceivedEvent::default_instance_
                                                             + 48);
    }
    CLMicroLocationProto::HomeKitAccessory::MergeFrom(v18, v20);
    v4 = *((_DWORD *)a2 + 73);
    if ((v4 & 0x40) == 0)
    {
LABEL_11:
      if ((v4 & 0x80) == 0)
        goto LABEL_53;
      goto LABEL_48;
    }
    goto LABEL_43;
  }
LABEL_33:
  *((_DWORD *)v3 + 73) |= 0x10u;
  v16 = (CLMicroLocationProto::ForcedRecording *)*((_QWORD *)v3 + 5);
  if (!v16)
  {
    this = (CLMicroLocationProto::ReceivedEvent *)operator new();
    v16 = this;
    *(_QWORD *)this = &off_2511D7640;
    *((_QWORD *)this + 1) = 7;
    *((_DWORD *)this + 4) = 0;
    *((_QWORD *)v3 + 5) = this;
  }
  v17 = (const CLMicroLocationProto::ForcedRecording *)*((_QWORD *)a2 + 5);
  if (!v17)
  {
    CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto(this);
    v17 = *(const CLMicroLocationProto::ForcedRecording **)(CLMicroLocationProto::ReceivedEvent::default_instance_ + 40);
  }
  CLMicroLocationProto::ForcedRecording::MergeFrom(v16, v17);
  v4 = *((_DWORD *)a2 + 73);
  if ((v4 & 0x20) != 0)
    goto LABEL_38;
LABEL_10:
  if ((v4 & 0x40) == 0)
    goto LABEL_11;
LABEL_43:
  *((_DWORD *)v3 + 73) |= 0x40u;
  v21 = (CLMicroLocationProto::HomeKitScene *)*((_QWORD *)v3 + 7);
  if (!v21)
  {
    this = (CLMicroLocationProto::ReceivedEvent *)operator new();
    v21 = this;
    *((_DWORD *)this + 12) = 10;
    v22 = MEMORY[0x24BEDD958];
    *(_QWORD *)this = &off_2511D7730;
    *((_QWORD *)this + 1) = v22;
    *((_QWORD *)this + 2) = v22;
    *((_QWORD *)this + 3) = v22;
    *((_QWORD *)this + 4) = v22;
    *((_QWORD *)this + 5) = v22;
    *((_QWORD *)this + 7) = v22;
    *((_QWORD *)this + 8) = v22;
    *((_WORD *)this + 26) = 0;
    *((_QWORD *)this + 9) = v22;
    *((_QWORD *)this + 10) = 0;
    *((_QWORD *)v3 + 7) = this;
  }
  v23 = (const CLMicroLocationProto::HomeKitScene *)*((_QWORD *)a2 + 7);
  if (!v23)
  {
    CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto(this);
    v23 = *(const CLMicroLocationProto::HomeKitScene **)(CLMicroLocationProto::ReceivedEvent::default_instance_ + 56);
  }
  CLMicroLocationProto::HomeKitScene::MergeFrom(v21, v23);
  v4 = *((_DWORD *)a2 + 73);
  if ((v4 & 0x80) != 0)
  {
LABEL_48:
    *((_DWORD *)v3 + 73) |= 0x80u;
    v24 = (CLMicroLocationProto::NowPlaying *)*((_QWORD *)v3 + 8);
    if (!v24)
    {
      this = (CLMicroLocationProto::ReceivedEvent *)operator new();
      v24 = this;
      *((_QWORD *)this + 5) = 0;
      v25 = MEMORY[0x24BEDD958];
      *((_DWORD *)this + 12) = 0;
      *(_QWORD *)this = &off_2511D7820;
      *((_QWORD *)this + 1) = v25;
      *((_QWORD *)this + 2) = 12;
      *((_QWORD *)this + 3) = v25;
      *((_QWORD *)this + 4) = 0;
      *((_QWORD *)this + 7) = 0;
      *((_QWORD *)this + 8) = 0;
      *((_QWORD *)v3 + 8) = this;
    }
    v26 = (const CLMicroLocationProto::NowPlaying *)*((_QWORD *)a2 + 8);
    if (!v26)
    {
      CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto(this);
      v26 = *(const CLMicroLocationProto::NowPlaying **)(CLMicroLocationProto::ReceivedEvent::default_instance_ + 64);
    }
    CLMicroLocationProto::NowPlaying::MergeFrom(v24, v26);
    v4 = *((_DWORD *)a2 + 73);
  }
LABEL_53:
  if ((v4 & 0xFF00) == 0)
    goto LABEL_103;
  if ((v4 & 0x100) != 0)
  {
    *((_DWORD *)v3 + 73) |= 0x100u;
    v27 = (CLMicroLocationProto::RecordingRequest *)*((_QWORD *)v3 + 9);
    if (!v27)
    {
      this = (CLMicroLocationProto::ReceivedEvent *)operator new();
      v27 = this;
      *(_QWORD *)this = &off_2511D73E8;
      *((_QWORD *)this + 1) = 0x10000000DLL;
      v28 = MEMORY[0x24BEDD958];
      *((_QWORD *)this + 2) = MEMORY[0x24BEDD958];
      *((_QWORD *)this + 3) = v28;
      *((_QWORD *)this + 4) = v28;
      *((_QWORD *)this + 5) = 0;
      *((_QWORD *)v3 + 9) = this;
    }
    v29 = (const CLMicroLocationProto::RecordingRequest *)*((_QWORD *)a2 + 9);
    if (!v29)
    {
      CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto(this);
      v29 = *(const CLMicroLocationProto::RecordingRequest **)(CLMicroLocationProto::ReceivedEvent::default_instance_
                                                             + 72);
    }
    CLMicroLocationProto::RecordingRequest::MergeFrom(v27, v29);
    v4 = *((_DWORD *)a2 + 73);
    if ((v4 & 0x200) == 0)
    {
LABEL_56:
      if ((v4 & 0x400) == 0)
        goto LABEL_57;
      goto LABEL_73;
    }
  }
  else if ((v4 & 0x200) == 0)
  {
    goto LABEL_56;
  }
  *((_DWORD *)v3 + 73) |= 0x200u;
  v30 = (CLMicroLocationProto::TruthLabelDonation *)*((_QWORD *)v3 + 10);
  if (!v30)
  {
    this = (CLMicroLocationProto::ReceivedEvent *)operator new();
    v30 = this;
    *((_QWORD *)this + 4) = 14;
    v31 = MEMORY[0x24BEDD958];
    *(_QWORD *)this = &off_2511D75C8;
    *((_QWORD *)this + 1) = v31;
    *((_QWORD *)this + 2) = v31;
    *((_QWORD *)this + 3) = v31;
    *((_DWORD *)this + 10) = 0;
    *((_QWORD *)v3 + 10) = this;
  }
  v32 = (const CLMicroLocationProto::TruthLabelDonation *)*((_QWORD *)a2 + 10);
  if (!v32)
  {
    CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto(this);
    v32 = *(const CLMicroLocationProto::TruthLabelDonation **)(CLMicroLocationProto::ReceivedEvent::default_instance_
                                                             + 80);
  }
  CLMicroLocationProto::TruthLabelDonation::MergeFrom(v30, v32);
  v4 = *((_DWORD *)a2 + 73);
  if ((v4 & 0x400) == 0)
  {
LABEL_57:
    if ((v4 & 0x800) == 0)
      goto LABEL_58;
    goto LABEL_78;
  }
LABEL_73:
  *((_DWORD *)v3 + 73) |= 0x400u;
  v33 = (CLMicroLocationProto::LearnModel *)*((_QWORD *)v3 + 11);
  if (!v33)
  {
    this = (CLMicroLocationProto::ReceivedEvent *)operator new();
    v33 = this;
    *(_QWORD *)this = &off_2511D7898;
    *((_QWORD *)this + 1) = 31;
    *((_DWORD *)this + 4) = 0;
    *((_QWORD *)v3 + 11) = this;
  }
  v34 = (const CLMicroLocationProto::LearnModel *)*((_QWORD *)a2 + 11);
  if (!v34)
  {
    CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto(this);
    v34 = *(const CLMicroLocationProto::LearnModel **)(CLMicroLocationProto::ReceivedEvent::default_instance_ + 88);
  }
  CLMicroLocationProto::LearnModel::MergeFrom(v33, v34);
  v4 = *((_DWORD *)a2 + 73);
  if ((v4 & 0x800) == 0)
  {
LABEL_58:
    if ((v4 & 0x1000) == 0)
      goto LABEL_59;
    goto LABEL_83;
  }
LABEL_78:
  *((_DWORD *)v3 + 73) |= 0x800u;
  v35 = (CLMicroLocationProto::LearnCompleted *)*((_QWORD *)v3 + 12);
  if (!v35)
  {
    this = (CLMicroLocationProto::ReceivedEvent *)operator new();
    v35 = this;
    *(_QWORD *)this = &off_2511D7910;
    *((_QWORD *)this + 1) = 32;
    *((_DWORD *)this + 4) = 0;
    *((_QWORD *)v3 + 12) = this;
  }
  v36 = (const CLMicroLocationProto::LearnCompleted *)*((_QWORD *)a2 + 12);
  if (!v36)
  {
    CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto(this);
    v36 = *(const CLMicroLocationProto::LearnCompleted **)(CLMicroLocationProto::ReceivedEvent::default_instance_ + 96);
  }
  CLMicroLocationProto::LearnCompleted::MergeFrom(v35, v36);
  v4 = *((_DWORD *)a2 + 73);
  if ((v4 & 0x1000) == 0)
  {
LABEL_59:
    if ((v4 & 0x2000) == 0)
      goto LABEL_60;
    goto LABEL_88;
  }
LABEL_83:
  *((_DWORD *)v3 + 73) |= 0x1000u;
  v37 = (CLMicroLocationProto::SensorsScanComplete *)*((_QWORD *)v3 + 13);
  if (!v37)
  {
    this = (CLMicroLocationProto::ReceivedEvent *)operator new();
    v37 = this;
    *(_QWORD *)this = &off_2511D7988;
    *((_QWORD *)this + 1) = 33;
    *((_DWORD *)this + 4) = 0;
    *((_QWORD *)v3 + 13) = this;
  }
  v38 = (const CLMicroLocationProto::SensorsScanComplete *)*((_QWORD *)a2 + 13);
  if (!v38)
  {
    CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto(this);
    v38 = *(const CLMicroLocationProto::SensorsScanComplete **)(CLMicroLocationProto::ReceivedEvent::default_instance_
                                                              + 104);
  }
  CLMicroLocationProto::SensorsScanComplete::MergeFrom(v37, v38);
  v4 = *((_DWORD *)a2 + 73);
  if ((v4 & 0x2000) == 0)
  {
LABEL_60:
    if ((v4 & 0x4000) == 0)
      goto LABEL_61;
    goto LABEL_93;
  }
LABEL_88:
  *((_DWORD *)v3 + 73) |= 0x2000u;
  v39 = (CLMicroLocationProto::StartSpectating *)*((_QWORD *)v3 + 14);
  if (!v39)
  {
    this = (CLMicroLocationProto::ReceivedEvent *)operator new();
    v39 = this;
    *(_QWORD *)this = &off_2511D7A00;
    *((_QWORD *)this + 1) = 34;
    *((_DWORD *)this + 4) = 0;
    *((_QWORD *)v3 + 14) = this;
  }
  v40 = (const CLMicroLocationProto::StartSpectating *)*((_QWORD *)a2 + 14);
  if (!v40)
  {
    CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto(this);
    v40 = *(const CLMicroLocationProto::StartSpectating **)(CLMicroLocationProto::ReceivedEvent::default_instance_ + 112);
  }
  CLMicroLocationProto::StartSpectating::MergeFrom(v39, v40);
  v4 = *((_DWORD *)a2 + 73);
  if ((v4 & 0x4000) == 0)
  {
LABEL_61:
    if ((v4 & 0x8000) == 0)
      goto LABEL_103;
    goto LABEL_98;
  }
LABEL_93:
  *((_DWORD *)v3 + 73) |= 0x4000u;
  v41 = (CLMicroLocationProto::StopSpectating *)*((_QWORD *)v3 + 15);
  if (!v41)
  {
    this = (CLMicroLocationProto::ReceivedEvent *)operator new();
    v41 = this;
    *(_QWORD *)this = &off_2511D7A78;
    *((_QWORD *)this + 1) = 35;
    *((_DWORD *)this + 4) = 0;
    *((_QWORD *)v3 + 15) = this;
  }
  v42 = (const CLMicroLocationProto::StopSpectating *)*((_QWORD *)a2 + 15);
  if (!v42)
  {
    CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto(this);
    v42 = *(const CLMicroLocationProto::StopSpectating **)(CLMicroLocationProto::ReceivedEvent::default_instance_ + 120);
  }
  CLMicroLocationProto::StopSpectating::MergeFrom(v41, v42);
  v4 = *((_DWORD *)a2 + 73);
  if ((v4 & 0x8000) != 0)
  {
LABEL_98:
    *((_DWORD *)v3 + 73) |= 0x8000u;
    v43 = (CLMicroLocationProto::ServiceCreate *)*((_QWORD *)v3 + 16);
    if (!v43)
    {
      this = (CLMicroLocationProto::ReceivedEvent *)operator new();
      v43 = this;
      v44 = MEMORY[0x24BEDD958];
      *((_QWORD *)this + 3) = 36;
      *(_QWORD *)this = &off_2511D7AF0;
      *((_QWORD *)this + 1) = v44;
      *((_QWORD *)this + 2) = 0;
      *((_DWORD *)this + 8) = 0;
      *((_QWORD *)v3 + 16) = this;
    }
    v45 = (const CLMicroLocationProto::ServiceCreate *)*((_QWORD *)a2 + 16);
    if (!v45)
    {
      CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto(this);
      v45 = *(const CLMicroLocationProto::ServiceCreate **)(CLMicroLocationProto::ReceivedEvent::default_instance_ + 128);
    }
    CLMicroLocationProto::ServiceCreate::MergeFrom(v43, v45);
    v4 = *((_DWORD *)a2 + 73);
  }
LABEL_103:
  if ((v4 & 0xFF0000) == 0)
    goto LABEL_153;
  if ((v4 & 0x10000) != 0)
  {
    *((_DWORD *)v3 + 73) |= 0x10000u;
    v46 = (CLMicroLocationProto::ServiceDelete *)*((_QWORD *)v3 + 17);
    if (!v46)
    {
      this = (CLMicroLocationProto::ReceivedEvent *)operator new();
      v46 = this;
      v47 = MEMORY[0x24BEDD958];
      *((_QWORD *)this + 3) = 37;
      *(_QWORD *)this = &off_2511D7B68;
      *((_QWORD *)this + 1) = v47;
      *((_QWORD *)this + 2) = v47;
      *((_DWORD *)this + 8) = 0;
      *((_QWORD *)v3 + 17) = this;
    }
    v48 = (const CLMicroLocationProto::ServiceDelete *)*((_QWORD *)a2 + 17);
    if (!v48)
    {
      CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto(this);
      v48 = *(const CLMicroLocationProto::ServiceDelete **)(CLMicroLocationProto::ReceivedEvent::default_instance_ + 136);
    }
    CLMicroLocationProto::ServiceDelete::MergeFrom(v46, v48);
    v4 = *((_DWORD *)a2 + 73);
    if ((v4 & 0x20000) == 0)
    {
LABEL_106:
      if ((v4 & 0x40000) == 0)
        goto LABEL_107;
      goto LABEL_123;
    }
  }
  else if ((v4 & 0x20000) == 0)
  {
    goto LABEL_106;
  }
  *((_DWORD *)v3 + 73) |= 0x20000u;
  v49 = (CLMicroLocationProto::ServiceConnect *)*((_QWORD *)v3 + 18);
  if (!v49)
  {
    this = (CLMicroLocationProto::ReceivedEvent *)operator new();
    v49 = this;
    v50 = MEMORY[0x24BEDD958];
    *((_QWORD *)this + 3) = 38;
    *(_QWORD *)this = &off_2511D7BE0;
    *((_QWORD *)this + 1) = v50;
    *((_QWORD *)this + 2) = v50;
    *((_DWORD *)this + 8) = 0;
    *((_QWORD *)v3 + 18) = this;
  }
  v51 = (const CLMicroLocationProto::ServiceConnect *)*((_QWORD *)a2 + 18);
  if (!v51)
  {
    CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto(this);
    v51 = *(const CLMicroLocationProto::ServiceConnect **)(CLMicroLocationProto::ReceivedEvent::default_instance_ + 144);
  }
  CLMicroLocationProto::ServiceConnect::MergeFrom(v49, v51);
  v4 = *((_DWORD *)a2 + 73);
  if ((v4 & 0x40000) == 0)
  {
LABEL_107:
    if ((v4 & 0x80000) == 0)
      goto LABEL_108;
    goto LABEL_128;
  }
LABEL_123:
  *((_DWORD *)v3 + 73) |= 0x40000u;
  v52 = (CLMicroLocationProto::ServiceDisconnect *)*((_QWORD *)v3 + 19);
  if (!v52)
  {
    this = (CLMicroLocationProto::ReceivedEvent *)operator new();
    v52 = this;
    v53 = MEMORY[0x24BEDD958];
    *((_QWORD *)this + 3) = 39;
    *(_QWORD *)this = &off_2511D7C58;
    *((_QWORD *)this + 1) = v53;
    *((_QWORD *)this + 2) = v53;
    *((_DWORD *)this + 8) = 0;
    *((_QWORD *)v3 + 19) = this;
  }
  v54 = (const CLMicroLocationProto::ServiceDisconnect *)*((_QWORD *)a2 + 19);
  if (!v54)
  {
    CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto(this);
    v54 = *(const CLMicroLocationProto::ServiceDisconnect **)(CLMicroLocationProto::ReceivedEvent::default_instance_
                                                            + 152);
  }
  CLMicroLocationProto::ServiceDisconnect::MergeFrom(v52, v54);
  v4 = *((_DWORD *)a2 + 73);
  if ((v4 & 0x80000) == 0)
  {
LABEL_108:
    if ((v4 & 0x100000) == 0)
      goto LABEL_109;
    goto LABEL_133;
  }
LABEL_128:
  *((_DWORD *)v3 + 73) |= 0x80000u;
  v55 = (CLMicroLocationProto::ServiceStartUpdating *)*((_QWORD *)v3 + 20);
  if (!v55)
  {
    this = (CLMicroLocationProto::ReceivedEvent *)operator new();
    v55 = this;
    *((_DWORD *)this + 4) = 40;
    v56 = MEMORY[0x24BEDD958];
    *(_QWORD *)this = &off_2511D7CD0;
    *((_QWORD *)this + 1) = v56;
    *((_QWORD *)this + 3) = v56;
    *((_QWORD *)this + 4) = 0;
    *((_BYTE *)this + 20) = 0;
    *((_QWORD *)v3 + 20) = this;
  }
  v57 = (const CLMicroLocationProto::ServiceStartUpdating *)*((_QWORD *)a2 + 20);
  if (!v57)
  {
    CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto(this);
    v57 = *(const CLMicroLocationProto::ServiceStartUpdating **)(CLMicroLocationProto::ReceivedEvent::default_instance_
                                                               + 160);
  }
  CLMicroLocationProto::ServiceStartUpdating::MergeFrom(v55, v57);
  v4 = *((_DWORD *)a2 + 73);
  if ((v4 & 0x100000) == 0)
  {
LABEL_109:
    if ((v4 & 0x200000) == 0)
      goto LABEL_110;
    goto LABEL_138;
  }
LABEL_133:
  *((_DWORD *)v3 + 73) |= 0x100000u;
  v58 = (CLMicroLocationProto::ServiceStopUpdating *)*((_QWORD *)v3 + 21);
  if (!v58)
  {
    this = (CLMicroLocationProto::ReceivedEvent *)operator new();
    v58 = this;
    v59 = MEMORY[0x24BEDD958];
    *((_QWORD *)this + 3) = 41;
    *(_QWORD *)this = &off_2511D7D48;
    *((_QWORD *)this + 1) = v59;
    *((_QWORD *)this + 2) = v59;
    *((_DWORD *)this + 8) = 0;
    *((_QWORD *)v3 + 21) = this;
  }
  v60 = (const CLMicroLocationProto::ServiceStopUpdating *)*((_QWORD *)a2 + 21);
  if (!v60)
  {
    CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto(this);
    v60 = *(const CLMicroLocationProto::ServiceStopUpdating **)(CLMicroLocationProto::ReceivedEvent::default_instance_
                                                              + 168);
  }
  CLMicroLocationProto::ServiceStopUpdating::MergeFrom(v58, v60);
  v4 = *((_DWORD *)a2 + 73);
  if ((v4 & 0x200000) == 0)
  {
LABEL_110:
    if ((v4 & 0x400000) == 0)
      goto LABEL_111;
    goto LABEL_143;
  }
LABEL_138:
  *((_DWORD *)v3 + 73) |= 0x200000u;
  v61 = (CLMicroLocationProto::RequestObservation *)*((_QWORD *)v3 + 22);
  if (!v61)
  {
    this = (CLMicroLocationProto::ReceivedEvent *)operator new();
    v61 = this;
    *((_QWORD *)this + 5) = 42;
    v62 = MEMORY[0x24BEDD958];
    *(_QWORD *)this = &off_2511D7DC0;
    *((_QWORD *)this + 1) = v62;
    *((_QWORD *)this + 2) = v62;
    *((_QWORD *)this + 3) = v62;
    *((_QWORD *)this + 4) = v62;
    *((_DWORD *)this + 12) = 0;
    *((_QWORD *)v3 + 22) = this;
  }
  v63 = (const CLMicroLocationProto::RequestObservation *)*((_QWORD *)a2 + 22);
  if (!v63)
  {
    CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto(this);
    v63 = *(const CLMicroLocationProto::RequestObservation **)(CLMicroLocationProto::ReceivedEvent::default_instance_
                                                             + 176);
  }
  CLMicroLocationProto::RequestObservation::MergeFrom(v61, v63);
  v4 = *((_DWORD *)a2 + 73);
  if ((v4 & 0x400000) == 0)
  {
LABEL_111:
    if ((v4 & 0x800000) == 0)
      goto LABEL_153;
    goto LABEL_148;
  }
LABEL_143:
  *((_DWORD *)v3 + 73) |= 0x400000u;
  v64 = (CLMicroLocationProto::RequestPrediction *)*((_QWORD *)v3 + 23);
  if (!v64)
  {
    this = (CLMicroLocationProto::ReceivedEvent *)operator new();
    v64 = this;
    *((_QWORD *)this + 4) = 43;
    v65 = MEMORY[0x24BEDD958];
    *(_QWORD *)this = &off_2511D7E38;
    *((_QWORD *)this + 1) = v65;
    *((_QWORD *)this + 2) = v65;
    *((_QWORD *)this + 3) = v65;
    *((_DWORD *)this + 10) = 0;
    *((_QWORD *)v3 + 23) = this;
  }
  v66 = (const CLMicroLocationProto::RequestPrediction *)*((_QWORD *)a2 + 23);
  if (!v66)
  {
    CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto(this);
    v66 = *(const CLMicroLocationProto::RequestPrediction **)(CLMicroLocationProto::ReceivedEvent::default_instance_
                                                            + 184);
  }
  CLMicroLocationProto::RequestPrediction::MergeFrom(v64, v66);
  v4 = *((_DWORD *)a2 + 73);
  if ((v4 & 0x800000) != 0)
  {
LABEL_148:
    *((_DWORD *)v3 + 73) |= 0x800000u;
    v67 = (CLMicroLocationProto::MiloInit *)*((_QWORD *)v3 + 24);
    if (!v67)
    {
      this = (CLMicroLocationProto::ReceivedEvent *)operator new();
      v67 = this;
      *((_QWORD *)this + 2) = 44;
      v68 = MEMORY[0x24BEDD958];
      *(_QWORD *)this = &off_2511D7EB0;
      *((_QWORD *)this + 1) = v68;
      *((_DWORD *)this + 6) = 0;
      *((_QWORD *)v3 + 24) = this;
    }
    v69 = (const CLMicroLocationProto::MiloInit *)*((_QWORD *)a2 + 24);
    if (!v69)
    {
      CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto(this);
      v69 = *(const CLMicroLocationProto::MiloInit **)(CLMicroLocationProto::ReceivedEvent::default_instance_ + 192);
    }
    CLMicroLocationProto::MiloInit::MergeFrom(v67, v69);
    v4 = *((_DWORD *)a2 + 73);
  }
LABEL_153:
  if (!HIBYTE(v4))
    goto LABEL_203;
  if ((v4 & 0x1000000) != 0)
  {
    *((_DWORD *)v3 + 73) |= 0x1000000u;
    v70 = (CLMicroLocationProto::MotionEvent *)*((_QWORD *)v3 + 25);
    if (!v70)
    {
      this = (CLMicroLocationProto::ReceivedEvent *)operator new();
      v70 = this;
      v71 = MEMORY[0x24BEDD958];
      *(_QWORD *)this = &off_2511D7F28;
      *((_QWORD *)this + 1) = v71;
      *((_QWORD *)this + 2) = 45;
      *((_QWORD *)this + 3) = v71;
      *((_QWORD *)this + 4) = 0;
      *((_QWORD *)this + 5) = 0;
      *((_QWORD *)v3 + 25) = this;
    }
    v72 = (const CLMicroLocationProto::MotionEvent *)*((_QWORD *)a2 + 25);
    if (!v72)
    {
      CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto(this);
      v72 = *(const CLMicroLocationProto::MotionEvent **)(CLMicroLocationProto::ReceivedEvent::default_instance_ + 200);
    }
    CLMicroLocationProto::MotionEvent::MergeFrom(v70, v72);
    v4 = *((_DWORD *)a2 + 73);
    if ((v4 & 0x2000000) == 0)
    {
LABEL_156:
      if ((v4 & 0x4000000) == 0)
        goto LABEL_157;
      goto LABEL_173;
    }
  }
  else if ((v4 & 0x2000000) == 0)
  {
    goto LABEL_156;
  }
  *((_DWORD *)v3 + 73) |= 0x2000000u;
  v73 = (CLMicroLocationProto::LegacyThrottle *)*((_QWORD *)v3 + 26);
  if (!v73)
  {
    this = (CLMicroLocationProto::ReceivedEvent *)operator new();
    v73 = this;
    *((_QWORD *)this + 2) = 46;
    v74 = MEMORY[0x24BEDD958];
    *(_QWORD *)this = &off_2511D7FA0;
    *((_QWORD *)this + 1) = v74;
    *((_DWORD *)this + 6) = 0;
    *((_QWORD *)v3 + 26) = this;
  }
  v75 = (const CLMicroLocationProto::LegacyThrottle *)*((_QWORD *)a2 + 26);
  if (!v75)
  {
    CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto(this);
    v75 = *(const CLMicroLocationProto::LegacyThrottle **)(CLMicroLocationProto::ReceivedEvent::default_instance_ + 208);
  }
  CLMicroLocationProto::LegacyThrottle::MergeFrom(v73, v75);
  v4 = *((_DWORD *)a2 + 73);
  if ((v4 & 0x4000000) == 0)
  {
LABEL_157:
    if ((v4 & 0x8000000) == 0)
      goto LABEL_158;
    goto LABEL_178;
  }
LABEL_173:
  *((_DWORD *)v3 + 73) |= 0x4000000u;
  v76 = (CLMicroLocationProto::RetrievedLoi *)*((_QWORD *)v3 + 27);
  if (!v76)
  {
    this = (CLMicroLocationProto::ReceivedEvent *)operator new();
    v76 = this;
    v77 = MEMORY[0x24BEDD958];
    *(_QWORD *)this = &off_2511D8018;
    *((_QWORD *)this + 1) = v77;
    *((_QWORD *)this + 2) = v77;
    *((_QWORD *)this + 4) = v77;
    *((_QWORD *)this + 3) = 0x10000002FLL;
    *((_BYTE *)this + 40) = 0;
    *((_DWORD *)this + 11) = 0;
    *((_DWORD *)this + 12) = 0;
    *((_QWORD *)v3 + 27) = this;
  }
  v78 = (const CLMicroLocationProto::RetrievedLoi *)*((_QWORD *)a2 + 27);
  if (!v78)
  {
    CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto(this);
    v78 = *(const CLMicroLocationProto::RetrievedLoi **)(CLMicroLocationProto::ReceivedEvent::default_instance_ + 216);
  }
  CLMicroLocationProto::RetrievedLoi::MergeFrom(v76, v78);
  v4 = *((_DWORD *)a2 + 73);
  if ((v4 & 0x8000000) == 0)
  {
LABEL_158:
    if ((v4 & 0x10000000) == 0)
      goto LABEL_159;
    goto LABEL_183;
  }
LABEL_178:
  *((_DWORD *)v3 + 73) |= 0x8000000u;
  v79 = (CLMicroLocationProto::TriggerEvent *)*((_QWORD *)v3 + 28);
  if (!v79)
  {
    this = (CLMicroLocationProto::ReceivedEvent *)operator new();
    v79 = this;
    *((_DWORD *)this + 6) = 48;
    *(_QWORD *)this = &off_2511D81F8;
    *((_QWORD *)this + 1) = 0;
    *((_WORD *)this + 14) = 0;
    v80 = MEMORY[0x24BEDD958];
    *((_QWORD *)this + 2) = MEMORY[0x24BEDD958];
    *((_QWORD *)this + 4) = v80;
    *((_QWORD *)this + 5) = v80;
    *((_QWORD *)this + 6) = v80;
    *((_QWORD *)this + 7) = 0;
    *((_QWORD *)this + 8) = v80;
    *((_QWORD *)this + 9) = 0;
    *((_QWORD *)this + 10) = 0;
    *((_QWORD *)v3 + 28) = this;
  }
  v81 = (const CLMicroLocationProto::TriggerEvent *)*((_QWORD *)a2 + 28);
  if (!v81)
  {
    CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto(this);
    v81 = *(const CLMicroLocationProto::TriggerEvent **)(CLMicroLocationProto::ReceivedEvent::default_instance_ + 224);
  }
  CLMicroLocationProto::TriggerEvent::MergeFrom(v79, v81);
  v4 = *((_DWORD *)a2 + 73);
  if ((v4 & 0x10000000) == 0)
  {
LABEL_159:
    if ((v4 & 0x20000000) == 0)
      goto LABEL_160;
    goto LABEL_188;
  }
LABEL_183:
  *((_DWORD *)v3 + 73) |= 0x10000000u;
  v82 = (CLMicroLocationProto::LegacyClientStatusUpdate *)*((_QWORD *)v3 + 29);
  if (!v82)
  {
    this = (CLMicroLocationProto::ReceivedEvent *)operator new();
    v82 = this;
    *(_QWORD *)this = &off_2511D8270;
    *(_OWORD *)((char *)this + 8) = xmmword_241BB7110;
    *((_DWORD *)this + 6) = 0;
    *((_QWORD *)v3 + 29) = this;
  }
  v83 = (const CLMicroLocationProto::LegacyClientStatusUpdate *)*((_QWORD *)a2 + 29);
  if (!v83)
  {
    CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto(this);
    v83 = *(const CLMicroLocationProto::LegacyClientStatusUpdate **)(CLMicroLocationProto::ReceivedEvent::default_instance_
                                                                   + 232);
  }
  CLMicroLocationProto::LegacyClientStatusUpdate::MergeFrom(v82, v83);
  v4 = *((_DWORD *)a2 + 73);
  if ((v4 & 0x20000000) == 0)
  {
LABEL_160:
    if ((v4 & 0x40000000) == 0)
      goto LABEL_161;
    goto LABEL_193;
  }
LABEL_188:
  *((_DWORD *)v3 + 73) |= 0x20000000u;
  v84 = (CLMicroLocationProto::SpectatingMotionUpdate *)*((_QWORD *)v3 + 30);
  if (!v84)
  {
    this = (CLMicroLocationProto::ReceivedEvent *)operator new();
    v84 = this;
    *(_QWORD *)this = &off_2511D82E8;
    *((_DWORD *)this + 2) = 50;
    *((_BYTE *)this + 12) = 0;
    *((_QWORD *)this + 2) = 0;
    *((_QWORD *)v3 + 30) = this;
  }
  v85 = (const CLMicroLocationProto::SpectatingMotionUpdate *)*((_QWORD *)a2 + 30);
  if (!v85)
  {
    CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto(this);
    v85 = *(const CLMicroLocationProto::SpectatingMotionUpdate **)(CLMicroLocationProto::ReceivedEvent::default_instance_
                                                                 + 240);
  }
  CLMicroLocationProto::SpectatingMotionUpdate::MergeFrom(v84, v85);
  v4 = *((_DWORD *)a2 + 73);
  if ((v4 & 0x40000000) == 0)
  {
LABEL_161:
    if ((v4 & 0x80000000) == 0)
      goto LABEL_203;
    goto LABEL_198;
  }
LABEL_193:
  *((_DWORD *)v3 + 73) |= 0x40000000u;
  v86 = (CLMicroLocationProto::EnabledStateUpdate *)*((_QWORD *)v3 + 31);
  if (!v86)
  {
    this = (CLMicroLocationProto::ReceivedEvent *)operator new();
    v86 = this;
    *(_QWORD *)this = &off_2511D8360;
    *((_DWORD *)this + 2) = 51;
    *((_DWORD *)this + 5) = 0;
    *((_DWORD *)this + 6) = 0;
    *(_QWORD *)((char *)this + 12) = 0;
    *((_QWORD *)v3 + 31) = this;
  }
  v87 = (const CLMicroLocationProto::EnabledStateUpdate *)*((_QWORD *)a2 + 31);
  if (!v87)
  {
    CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto(this);
    v87 = *(const CLMicroLocationProto::EnabledStateUpdate **)(CLMicroLocationProto::ReceivedEvent::default_instance_
                                                             + 248);
  }
  CLMicroLocationProto::EnabledStateUpdate::MergeFrom(v86, v87);
  if ((*((_DWORD *)a2 + 73) & 0x80000000) != 0)
  {
LABEL_198:
    *((_DWORD *)v3 + 73) |= 0x80000000;
    v88 = (CLMicroLocationProto::ScreenStateUpdate *)*((_QWORD *)v3 + 32);
    if (!v88)
    {
      this = (CLMicroLocationProto::ReceivedEvent *)operator new();
      v88 = this;
      *(_QWORD *)this = &off_2511D83D8;
      *((_DWORD *)this + 2) = 52;
      *((_BYTE *)this + 12) = 0;
      *((_QWORD *)this + 2) = 0;
      *((_QWORD *)v3 + 32) = this;
    }
    v89 = (const CLMicroLocationProto::ScreenStateUpdate *)*((_QWORD *)a2 + 32);
    if (!v89)
    {
      CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto(this);
      v89 = *(const CLMicroLocationProto::ScreenStateUpdate **)(CLMicroLocationProto::ReceivedEvent::default_instance_
                                                              + 256);
    }
    CLMicroLocationProto::ScreenStateUpdate::MergeFrom(v88, v89);
  }
LABEL_203:
  LOBYTE(v90) = *((_BYTE *)a2 + 296);
  if (!(_BYTE)v90)
    return;
  if ((*((_BYTE *)a2 + 296) & 1) != 0)
  {
    *((_DWORD *)v3 + 74) |= 1u;
    v91 = (CLMicroLocationProto::CloudBackupExport *)*((_QWORD *)v3 + 33);
    if (!v91)
    {
      this = (CLMicroLocationProto::ReceivedEvent *)operator new();
      v91 = this;
      *(_QWORD *)this = &off_2511D8450;
      *((_QWORD *)this + 1) = 53;
      *((_DWORD *)this + 4) = 0;
      *((_QWORD *)v3 + 33) = this;
    }
    v92 = (const CLMicroLocationProto::CloudBackupExport *)*((_QWORD *)a2 + 33);
    if (!v92)
    {
      CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto(this);
      v92 = *(const CLMicroLocationProto::CloudBackupExport **)(CLMicroLocationProto::ReceivedEvent::default_instance_
                                                              + 264);
    }
    CLMicroLocationProto::CloudBackupExport::MergeFrom(v91, v92);
    v90 = *((_DWORD *)a2 + 74);
    if ((v90 & 2) == 0)
    {
LABEL_206:
      if ((v90 & 4) == 0)
        return;
      goto LABEL_218;
    }
  }
  else if ((*((_BYTE *)a2 + 296) & 2) == 0)
  {
    goto LABEL_206;
  }
  *((_DWORD *)v3 + 74) |= 2u;
  v93 = (CLMicroLocationProto::CloudBackupImport *)*((_QWORD *)v3 + 34);
  if (!v93)
  {
    this = (CLMicroLocationProto::ReceivedEvent *)operator new();
    v93 = this;
    *(_QWORD *)this = &off_2511D84C8;
    *((_QWORD *)this + 1) = 54;
    *((_DWORD *)this + 4) = 0;
    *((_QWORD *)v3 + 34) = this;
  }
  v94 = (const CLMicroLocationProto::CloudBackupImport *)*((_QWORD *)a2 + 34);
  if (!v94)
  {
    CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto(this);
    v94 = *(const CLMicroLocationProto::CloudBackupImport **)(CLMicroLocationProto::ReceivedEvent::default_instance_
                                                            + 272);
  }
  CLMicroLocationProto::CloudBackupImport::MergeFrom(v93, v94);
  if ((*((_DWORD *)a2 + 74) & 4) != 0)
  {
LABEL_218:
    *((_DWORD *)v3 + 74) |= 4u;
    v95 = (CLMicroLocationProto::DataMigration *)*((_QWORD *)v3 + 35);
    if (!v95)
    {
      this = (CLMicroLocationProto::ReceivedEvent *)operator new();
      v95 = this;
      *(_QWORD *)this = &off_2511D8540;
      *((_QWORD *)this + 1) = 55;
      *((_DWORD *)this + 4) = 0;
      *((_QWORD *)v3 + 35) = this;
    }
    v96 = (const CLMicroLocationProto::DataMigration *)*((_QWORD *)a2 + 35);
    if (!v96)
    {
      CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto(this);
      v96 = *(const CLMicroLocationProto::DataMigration **)(CLMicroLocationProto::ReceivedEvent::default_instance_ + 280);
    }
    CLMicroLocationProto::DataMigration::MergeFrom(v95, v96);
  }
}

void sub_2419DC614(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void CLMicroLocationLegacyEventAppLaunch::handleEvent(uint64_t a1@<X1>, double *a2@<X2>, _BYTE *a3@<X8>)
{
  void *v3;
  void *v4;
  void *v5;
  id v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t i;
  std::vector<std::string>::pointer end;
  __int128 v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  std::string *v15;
  std::string *v16;
  __int128 v17;
  std::string *v18;
  std::vector<std::string>::pointer begin;
  uint64_t j;
  std::vector<std::string>::pointer v21;
  __int128 v22;
  unint64_t v23;
  unint64_t v24;
  unint64_t v25;
  std::string *v26;
  std::string *v27;
  __int128 v28;
  std::string *v29;
  double *v30;
  NSObject *v31;
  char v32;
  std::string *v33;
  NSObject *v34;
  std::string *v35;
  double v36;
  id v37;
  void *v41;
  void *v42;
  void *v43;
  std::vector<std::string>::pointer v44;
  std::__split_buffer<std::string> __v;
  void *v46[2];
  __int128 v47;
  __int128 v48;
  __int128 v49;
  std::vector<std::string> v50;
  std::vector<std::string> v51;
  std::vector<std::string> __p;
  std::__split_buffer<std::string> v53;
  uint64_t v54;

  v54 = *MEMORY[0x24BDAC8D0];
  +[ULDefaultsSingleton shared](ULDefaultsSingleton, "shared");
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v3, "defaultsDictionary");
  v4 = (void *)objc_claimAutoreleasedReturnValue();

  v41 = v4;
  objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "ULAppDenyList");
  v42 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v4, "objectForKey:", v42);
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  v43 = v5;
  if (v5 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
  {
    memset(&v51, 0, sizeof(v51));
    v37 = v5;
    std::vector<std::string>::reserve(&v51, objc_msgSend(v37, "count"));
    v48 = 0u;
    v49 = 0u;
    *(_OWORD *)v46 = 0u;
    v47 = 0u;
    v6 = v37;
    v7 = objc_msgSend(v6, "countByEnumeratingWithState:objects:count:", v46, &v53, 16);
    if (v7)
    {
      v8 = *(_QWORD *)v47;
      do
      {
        for (i = 0; i != v7; ++i)
        {
          if (*(_QWORD *)v47 != v8)
            objc_enumerationMutation(v6);
          std::string::basic_string[abi:ne180100]<0>(&__p, (char *)objc_msgSend(objc_retainAutorelease(*((id *)v46[1] + i)), "UTF8String"));
          end = v51.__end_;
          if (v51.__end_ >= v51.__end_cap_.__value_)
          {
            v12 = 0xAAAAAAAAAAAAAAABLL * (((char *)v51.__end_ - (char *)v51.__begin_) >> 3);
            v13 = v12 + 1;
            if (v12 + 1 > 0xAAAAAAAAAAAAAAALL)
              std::vector<CLMicroLocationProto::ConfidenceReason>::__throw_length_error[abi:ne180100]();
            if (0x5555555555555556 * (((char *)v51.__end_cap_.__value_ - (char *)v51.__begin_) >> 3) > v13)
              v13 = 0x5555555555555556 * (((char *)v51.__end_cap_.__value_ - (char *)v51.__begin_) >> 3);
            if (0xAAAAAAAAAAAAAAABLL * (((char *)v51.__end_cap_.__value_ - (char *)v51.__begin_) >> 3) >= 0x555555555555555)
              v14 = 0xAAAAAAAAAAAAAAALL;
            else
              v14 = v13;
            __v.__end_cap_.__value_ = (std::allocator<std::string> *)&v51.__end_cap_;
            if (v14)
              v15 = (std::string *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::string>>((uint64_t)&v51.__end_cap_, v14);
            else
              v15 = 0;
            v16 = v15 + v12;
            __v.__first_ = v15;
            __v.__begin_ = v16;
            __v.__end_cap_.__value_ = &v15[v14];
            v17 = *(_OWORD *)&__p.__begin_;
            v16->__r_.__value_.__r.__words[2] = (std::string::size_type)__p.__end_cap_.__value_;
            *(_OWORD *)&v16->__r_.__value_.__l.__data_ = v17;
            memset(&__p, 0, sizeof(__p));
            __v.__end_ = v16 + 1;
            std::vector<std::string>::__swap_out_circular_buffer(&v51, &__v);
            v18 = v51.__end_;
            std::__split_buffer<std::string>::~__split_buffer(&__v);
            v51.__end_ = v18;
            v5 = v43;
            if (SHIBYTE(__p.__end_cap_.__value_) < 0)
              operator delete(__p.__begin_);
          }
          else
          {
            v11 = *(_OWORD *)&__p.__begin_;
            v51.__end_->__r_.__value_.__r.__words[2] = (std::string::size_type)__p.__end_cap_.__value_;
            *(_OWORD *)&end->__r_.__value_.__l.__data_ = v11;
            v51.__end_ = end + 1;
          }
        }
        v7 = objc_msgSend(v6, "countByEnumeratingWithState:objects:count:", v46, &v53, 16);
      }
      while (v7);
    }

    begin = v51.__begin_;
    v50 = v51;
    v44 = v51.__end_;
    memset(&v51, 0, sizeof(v51));
    v53.__first_ = (std::__split_buffer<std::string>::pointer)&v51;
    std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)&v53);

  }
  else
  {
    memset(&__v, 0, 24);
    memset(&__p, 0, sizeof(__p));
    std::vector<std::string>::reserve(&__p, 0x12uLL);
    for (j = 0; j != 18; ++j)
    {
      std::string::basic_string[abi:ne180100]<0>(v46, _ZGRN10ULSettings14SettingsTraitsINS_11AppDenyListEE12defaultValueE_[j]);
      v21 = __p.__end_;
      if (__p.__end_ >= __p.__end_cap_.__value_)
      {
        v23 = 0xAAAAAAAAAAAAAAABLL * (((char *)__p.__end_ - (char *)__p.__begin_) >> 3);
        v24 = v23 + 1;
        if (v23 + 1 > 0xAAAAAAAAAAAAAAALL)
          std::vector<CLMicroLocationProto::ConfidenceReason>::__throw_length_error[abi:ne180100]();
        if (0x5555555555555556 * (((char *)__p.__end_cap_.__value_ - (char *)__p.__begin_) >> 3) > v24)
          v24 = 0x5555555555555556 * (((char *)__p.__end_cap_.__value_ - (char *)__p.__begin_) >> 3);
        if (0xAAAAAAAAAAAAAAABLL * (((char *)__p.__end_cap_.__value_ - (char *)__p.__begin_) >> 3) >= 0x555555555555555)
          v25 = 0xAAAAAAAAAAAAAAALL;
        else
          v25 = v24;
        v53.__end_cap_.__value_ = (std::allocator<std::string> *)&__p.__end_cap_;
        if (v25)
          v26 = (std::string *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::string>>((uint64_t)&__p.__end_cap_, v25);
        else
          v26 = 0;
        v27 = v26 + v23;
        v53.__first_ = v26;
        v53.__begin_ = v27;
        v53.__end_cap_.__value_ = &v26[v25];
        v28 = *(_OWORD *)v46;
        v27->__r_.__value_.__r.__words[2] = v47;
        *(_OWORD *)&v27->__r_.__value_.__l.__data_ = v28;
        v46[1] = 0;
        *(_QWORD *)&v47 = 0;
        v46[0] = 0;
        v53.__end_ = v27 + 1;
        std::vector<std::string>::__swap_out_circular_buffer(&__p, &v53);
        v29 = __p.__end_;
        std::__split_buffer<std::string>::~__split_buffer(&v53);
        __p.__end_ = v29;
        v5 = v43;
        if (SBYTE7(v47) < 0)
          operator delete(v46[0]);
      }
      else
      {
        v22 = *(_OWORD *)v46;
        __p.__end_->__r_.__value_.__r.__words[2] = v47;
        *(_OWORD *)&v21->__r_.__value_.__l.__data_ = v22;
        __p.__end_ = v21 + 1;
      }
    }
    std::vector<std::string>::__vdeallocate((std::vector<std::string> *)&__v);
    *(_OWORD *)&__v.__first_ = *(_OWORD *)&__p.__begin_;
    __v.__end_ = __p.__end_cap_.__value_;
    memset(&__p, 0, sizeof(__p));
    v53.__first_ = (std::__split_buffer<std::string>::pointer)&__p;
    std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)&v53);
    begin = __v.__first_;
    v50.__begin_ = __v.__first_;
    v44 = __v.__begin_;
    *(_OWORD *)&v50.__end_ = *(_OWORD *)&__v.__begin_;
    memset(&__v, 0, 24);
    v53.__first_ = (std::__split_buffer<std::string>::pointer)&__v;
    std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)&v53);
  }

  if ((std::vector<std::string>::pointer)std::__find_impl[abi:ne180100]<std::string const*,std::string const*,std::string,std::__identity>((uint64_t)begin, (uint64_t)v44, (unsigned __int8 **)a1) == v44)
  {
    v30 = a2;
    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_56);
    v34 = logObject_MicroLocation_Default;
    if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT))
    {
      if (*(char *)(a1 + 23) >= 0)
        v35 = (std::string *)a1;
      else
        v35 = *(std::string **)a1;
      v53.__first_ = (std::__split_buffer<std::string>::pointer)68289283;
      LOWORD(v53.__begin_) = 2082;
      *(std::__split_buffer<std::string>::pointer *)((char *)&v53.__begin_ + 2) = (std::__split_buffer<std::string>::pointer)"";
      WORD1(v53.__end_) = 2081;
      *(std::__split_buffer<std::string>::pointer *)((char *)&v53.__end_ + 4) = v35;
      _os_log_impl(&dword_2419D9000, v34, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"appLaunch\", \"bundleIdentifier\":%{private, location:escape_only}s}", (uint8_t *)&v53, 0x1Cu);
    }
    v32 = 1;
  }
  else
  {
    v30 = a2;
    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_56);
    v31 = logObject_MicroLocation_Default;
    v32 = 0;
    if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT))
    {
      if (*(char *)(a1 + 23) >= 0)
        v33 = (std::string *)a1;
      else
        v33 = *(std::string **)a1;
      LODWORD(v53.__first_) = 136380675;
      *(std::__split_buffer<std::string>::pointer *)((char *)&v53.__first_ + 4) = v33;
      _os_log_impl(&dword_2419D9000, v31, OS_LOG_TYPE_DEFAULT, "App launch denied for bundleIdentifier: %{private}s", (uint8_t *)&v53, 0xCu);
      v32 = 0;
    }
  }
  v36 = *v30;
  CLMicroLocationProto::AppLaunch::AppLaunch((CLMicroLocationProto::AppLaunch *)&__v);
  CLMicroLocationProtobufHelper::createRecordingEvent<CLMicroLocationProto::AppLaunch>((CLMicroLocationProto::RecordingEvent *)&__v, 0, 0, 0, (CLMicroLocationProto *)3, (uint64_t)v46, v36);
  LOBYTE(v53.__first_) = v32;
  CLMicroLocationProto::RecordingEvent::RecordingEvent((CLMicroLocationProto::RecordingEvent *)&v53.__begin_, (const CLMicroLocationProto::RecordingEvent *)v46);
  *a3 = v53.__first_;
  CLMicroLocationProto::RecordingEvent::RecordingEvent((CLMicroLocationProto::RecordingEvent *)(a3 + 8), (const CLMicroLocationProto::RecordingEvent *)&v53.__begin_);
  CLMicroLocationProto::RecordingEvent::~RecordingEvent((CLMicroLocationProto::RecordingEvent *)&v53.__begin_);
  CLMicroLocationProto::RecordingEvent::~RecordingEvent((CLMicroLocationProto::RecordingEvent *)v46);
  CLMicroLocationProto::AppLaunch::~AppLaunch((CLMicroLocationProto::AppLaunch *)&__v);
  v53.__first_ = (std::__split_buffer<std::string>::pointer)&v50;
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)&v53);
}

void sub_2419DCCD0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, std::__split_buffer<std::string> *a9, uint64_t a10, void *__p, uint64_t a12, void *a13, void *a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *__pa,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29,uint64_t a30,uint64_t a31,char a32,uint64_t a33,uint64_t a34,void *a35,uint64_t a36,int a37,__int16 a38,char a39,char a40,uint64_t a41,std::__split_buffer<std::string> *a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,char a47,uint64_t a48,uint64_t a49,void *a50)
{
  void *v50;
  void *v51;

  a50 = &a47;
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)&a50);

  _Unwind_Resume(a1);
}

void CLMicroLocationProto::RecordingEvent::~RecordingEvent(CLMicroLocationProto::RecordingEvent *this)
{
  uint64_t v2;

  *(_QWORD *)this = &off_2511D8180;
  CLMicroLocationProto::RecordingEvent::SharedDtor(this);
  v2 = *((_QWORD *)this + 13);
  if (v2)
    MEMORY[0x2426A04BC](v2, 0x1000C8052888210);
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(this);
}

{
  CLMicroLocationProto::RecordingEvent::~RecordingEvent(this);
  JUMPOUT(0x2426A04D4);
}

CLMicroLocationProto::RecordingEvent *CLMicroLocationProto::RecordingEvent::RecordingEvent(CLMicroLocationProto::RecordingEvent *this, const CLMicroLocationProto::RecordingEvent *a2)
{
  *(_QWORD *)this = &off_2511D8180;
  *((_QWORD *)this + 13) = 0;
  *((_DWORD *)this + 18) = 1;
  *((_WORD *)this + 38) = 0;
  *((_QWORD *)this + 16) = 0;
  *((_QWORD *)this + 17) = 0;
  *(_OWORD *)((char *)this + 8) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 40) = 0u;
  *(_OWORD *)((char *)this + 56) = 0u;
  *((_QWORD *)this + 11) = 0;
  *((_QWORD *)this + 12) = 0;
  *((_QWORD *)this + 10) = 0;
  *((_QWORD *)this + 14) = 0;
  *((_QWORD *)this + 15) = 0;
  CLMicroLocationProto::RecordingEvent::MergeFrom(this, a2);
  return this;
}

void sub_2419DCEE4(_Unwind_Exception *a1)
{
  wireless_diagnostics::google::protobuf::MessageLite *v1;
  _QWORD *v2;
  _QWORD *v3;

  v3 = v2;
  if (*v3)
    MEMORY[0x2426A04BC](*v3, 0x1000C8052888210);
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(v1);
  _Unwind_Resume(a1);
}

void CLMicroLocationProto::RecordingEvent::MergeFrom(CLMicroLocationProto::RecordingEvent *this, const CLMicroLocationProto::RecordingEvent *a2)
{
  CLMicroLocationProto::RecordingEvent *v3;
  int v4;
  int v5;
  unsigned int v6;
  uint64_t v7;
  CLMicroLocationProto::ReceivedEventAction *v8;
  uint64_t v9;
  const CLMicroLocationProto::ReceivedEventAction *v10;
  CLMicroLocationProto::AppLaunch *v11;
  uint64_t v12;
  const CLMicroLocationProto::AppLaunch *v13;
  CLMicroLocationProto::BacklightOn *v14;
  uint64_t v15;
  const CLMicroLocationProto::BacklightOn *v16;
  CLMicroLocationProto::BatteryChargerConnected *v17;
  const CLMicroLocationProto::BatteryChargerConnected *v18;
  CLMicroLocationProto::ForcedRecording *v19;
  const CLMicroLocationProto::ForcedRecording *v20;
  CLMicroLocationProto::HomeKitAccessory *v21;
  uint64_t v22;
  const CLMicroLocationProto::HomeKitAccessory *v23;
  CLMicroLocationProto::HomeKitScene *v24;
  uint64_t v25;
  const CLMicroLocationProto::HomeKitScene *v26;
  CLMicroLocationProto::NowPlaying *v27;
  uint64_t v28;
  const CLMicroLocationProto::NowPlaying *v29;
  CLMicroLocationProto::RecordingRequest *v30;
  uint64_t v31;
  const CLMicroLocationProto::RecordingRequest *v32;
  char v33;
  CLMicroLocationProto::TruthLabelDonation *v34;
  uint64_t v35;
  const CLMicroLocationProto::TruthLabelDonation *v36;
  char v37;
  unsigned int v38;
  CLMicroLocationProto::AssociatedAccessPointInfo *v39;
  const CLMicroLocationProto::AssociatedAccessPointInfo *v40;
  unsigned int v41;
  _BYTE v42[48];

  v3 = this;
  if (a2 == this)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
    wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v42);
  }
  v4 = *((_DWORD *)a2 + 28);
  if (v4)
  {
    wireless_diagnostics::google::protobuf::RepeatedField<int>::Reserve((_DWORD *)v3 + 26, *((_DWORD *)v3 + 28) + v4);
    this = (CLMicroLocationProto::RecordingEvent *)memcpy((void *)(*((_QWORD *)v3 + 13) + 4 * *((int *)v3 + 28)), *((const void **)a2 + 13), 4 * *((int *)a2 + 28));
    *((_DWORD *)v3 + 28) += *((_DWORD *)a2 + 28);
  }
  v5 = *((_DWORD *)a2 + 35);
  if (!(_BYTE)v5)
    goto LABEL_50;
  if ((v5 & 1) != 0)
  {
    v6 = *((_DWORD *)a2 + 18);
    if (v6 - 31 >= 0x19 && (v6 > 0xE || ((1 << v6) & 0x76B6) == 0))
      CLMicroLocationProto::RecordingEvent::MergeFrom();
    *((_DWORD *)v3 + 35) |= 1u;
    *((_DWORD *)v3 + 18) = v6;
    v5 = *((_DWORD *)a2 + 35);
  }
  if ((v5 & 2) != 0)
  {
    v7 = *((_QWORD *)a2 + 1);
    *((_DWORD *)v3 + 35) |= 2u;
    *((_QWORD *)v3 + 1) = v7;
    v5 = *((_DWORD *)a2 + 35);
    if ((v5 & 4) == 0)
    {
LABEL_13:
      if ((v5 & 8) == 0)
        goto LABEL_14;
      goto LABEL_25;
    }
  }
  else if ((v5 & 4) == 0)
  {
    goto LABEL_13;
  }
  *((_DWORD *)v3 + 35) |= 4u;
  v8 = (CLMicroLocationProto::ReceivedEventAction *)*((_QWORD *)v3 + 2);
  if (!v8)
  {
    this = (CLMicroLocationProto::RecordingEvent *)operator new();
    v8 = this;
    *(_QWORD *)this = &off_2511D7370;
    *((_QWORD *)this + 1) = 0x100000001;
    v9 = MEMORY[0x24BEDD958];
    *((_QWORD *)this + 2) = MEMORY[0x24BEDD958];
    *((_QWORD *)this + 3) = v9;
    *((_QWORD *)this + 4) = v9;
    *((_QWORD *)this + 5) = 0;
    *((_QWORD *)v3 + 2) = this;
  }
  v10 = (const CLMicroLocationProto::ReceivedEventAction *)*((_QWORD *)a2 + 2);
  if (!v10)
  {
    CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto(this);
    v10 = *(const CLMicroLocationProto::ReceivedEventAction **)(CLMicroLocationProto::RecordingEvent::default_instance_
                                                              + 16);
  }
  CLMicroLocationProto::ReceivedEventAction::MergeFrom(v8, v10);
  v5 = *((_DWORD *)a2 + 35);
  if ((v5 & 8) == 0)
  {
LABEL_14:
    if ((v5 & 0x10) == 0)
      goto LABEL_15;
    goto LABEL_30;
  }
LABEL_25:
  *((_DWORD *)v3 + 35) |= 8u;
  v11 = (CLMicroLocationProto::AppLaunch *)*((_QWORD *)v3 + 3);
  if (!v11)
  {
    this = (CLMicroLocationProto::RecordingEvent *)operator new();
    v11 = this;
    *((_QWORD *)this + 4) = 2;
    v12 = MEMORY[0x24BEDD958];
    *(_QWORD *)this = &off_2511D7460;
    *((_QWORD *)this + 1) = v12;
    *((_QWORD *)this + 2) = 0;
    *((_QWORD *)this + 3) = v12;
    *((_DWORD *)this + 10) = 0;
    *((_QWORD *)v3 + 3) = this;
  }
  v13 = (const CLMicroLocationProto::AppLaunch *)*((_QWORD *)a2 + 3);
  if (!v13)
  {
    CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto(this);
    v13 = *(const CLMicroLocationProto::AppLaunch **)(CLMicroLocationProto::RecordingEvent::default_instance_ + 24);
  }
  CLMicroLocationProto::AppLaunch::MergeFrom(v11, v13);
  v5 = *((_DWORD *)a2 + 35);
  if ((v5 & 0x10) == 0)
  {
LABEL_15:
    if ((v5 & 0x20) == 0)
      goto LABEL_16;
LABEL_35:
    *((_DWORD *)v3 + 35) |= 0x20u;
    v17 = (CLMicroLocationProto::BatteryChargerConnected *)*((_QWORD *)v3 + 5);
    if (!v17)
    {
      this = (CLMicroLocationProto::RecordingEvent *)operator new();
      v17 = this;
      *(_QWORD *)this = &off_2511D7550;
      *((_QWORD *)this + 1) = 5;
      *((_DWORD *)this + 4) = 0;
      *((_QWORD *)v3 + 5) = this;
    }
    v18 = (const CLMicroLocationProto::BatteryChargerConnected *)*((_QWORD *)a2 + 5);
    if (!v18)
    {
      CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto(this);
      v18 = *(const CLMicroLocationProto::BatteryChargerConnected **)(CLMicroLocationProto::RecordingEvent::default_instance_
                                                                    + 40);
    }
    CLMicroLocationProto::BatteryChargerConnected::MergeFrom(v17, v18);
    v5 = *((_DWORD *)a2 + 35);
    if ((v5 & 0x40) == 0)
    {
LABEL_17:
      if ((v5 & 0x80) == 0)
        goto LABEL_50;
      goto LABEL_45;
    }
    goto LABEL_40;
  }
LABEL_30:
  *((_DWORD *)v3 + 35) |= 0x10u;
  v14 = (CLMicroLocationProto::BacklightOn *)*((_QWORD *)v3 + 4);
  if (!v14)
  {
    this = (CLMicroLocationProto::RecordingEvent *)operator new();
    v14 = this;
    *((_QWORD *)this + 2) = 4;
    v15 = MEMORY[0x24BEDD958];
    *(_QWORD *)this = &off_2511D74D8;
    *((_QWORD *)this + 1) = v15;
    *((_DWORD *)this + 6) = 0;
    *((_QWORD *)v3 + 4) = this;
  }
  v16 = (const CLMicroLocationProto::BacklightOn *)*((_QWORD *)a2 + 4);
  if (!v16)
  {
    CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto(this);
    v16 = *(const CLMicroLocationProto::BacklightOn **)(CLMicroLocationProto::RecordingEvent::default_instance_ + 32);
  }
  CLMicroLocationProto::BacklightOn::MergeFrom(v14, v16);
  v5 = *((_DWORD *)a2 + 35);
  if ((v5 & 0x20) != 0)
    goto LABEL_35;
LABEL_16:
  if ((v5 & 0x40) == 0)
    goto LABEL_17;
LABEL_40:
  *((_DWORD *)v3 + 35) |= 0x40u;
  v19 = (CLMicroLocationProto::ForcedRecording *)*((_QWORD *)v3 + 6);
  if (!v19)
  {
    this = (CLMicroLocationProto::RecordingEvent *)operator new();
    v19 = this;
    *(_QWORD *)this = &off_2511D7640;
    *((_QWORD *)this + 1) = 7;
    *((_DWORD *)this + 4) = 0;
    *((_QWORD *)v3 + 6) = this;
  }
  v20 = (const CLMicroLocationProto::ForcedRecording *)*((_QWORD *)a2 + 6);
  if (!v20)
  {
    CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto(this);
    v20 = *(const CLMicroLocationProto::ForcedRecording **)(CLMicroLocationProto::RecordingEvent::default_instance_ + 48);
  }
  CLMicroLocationProto::ForcedRecording::MergeFrom(v19, v20);
  v5 = *((_DWORD *)a2 + 35);
  if ((v5 & 0x80) != 0)
  {
LABEL_45:
    *((_DWORD *)v3 + 35) |= 0x80u;
    v21 = (CLMicroLocationProto::HomeKitAccessory *)*((_QWORD *)v3 + 7);
    if (!v21)
    {
      this = (CLMicroLocationProto::RecordingEvent *)operator new();
      v21 = this;
      v22 = MEMORY[0x24BEDD958];
      *((_DWORD *)this + 16) = 9;
      *(_QWORD *)this = &off_2511D76B8;
      *((_QWORD *)this + 1) = v22;
      *((_QWORD *)this + 2) = v22;
      *((_QWORD *)this + 3) = v22;
      *((_QWORD *)this + 4) = v22;
      *((_QWORD *)this + 5) = v22;
      *((_QWORD *)this + 6) = v22;
      *((_QWORD *)this + 7) = v22;
      *((_QWORD *)this + 9) = v22;
      *((_QWORD *)this + 10) = v22;
      *((_WORD *)this + 34) = 0;
      *((_QWORD *)this + 11) = v22;
      *((_QWORD *)this + 12) = v22;
      *((_QWORD *)this + 13) = v22;
      *((_QWORD *)this + 14) = 0;
      *((_QWORD *)v3 + 7) = this;
    }
    v23 = (const CLMicroLocationProto::HomeKitAccessory *)*((_QWORD *)a2 + 7);
    if (!v23)
    {
      CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto(this);
      v23 = *(const CLMicroLocationProto::HomeKitAccessory **)(CLMicroLocationProto::RecordingEvent::default_instance_
                                                             + 56);
    }
    CLMicroLocationProto::HomeKitAccessory::MergeFrom(v21, v23);
    v5 = *((_DWORD *)a2 + 35);
  }
LABEL_50:
  if ((v5 & 0xFF00) == 0)
    goto LABEL_83;
  if ((v5 & 0x100) != 0)
  {
    *((_DWORD *)v3 + 35) |= 0x100u;
    v24 = (CLMicroLocationProto::HomeKitScene *)*((_QWORD *)v3 + 8);
    if (!v24)
    {
      this = (CLMicroLocationProto::RecordingEvent *)operator new();
      v24 = this;
      *((_DWORD *)this + 12) = 10;
      v25 = MEMORY[0x24BEDD958];
      *(_QWORD *)this = &off_2511D7730;
      *((_QWORD *)this + 1) = v25;
      *((_QWORD *)this + 2) = v25;
      *((_QWORD *)this + 3) = v25;
      *((_QWORD *)this + 4) = v25;
      *((_QWORD *)this + 5) = v25;
      *((_QWORD *)this + 7) = v25;
      *((_QWORD *)this + 8) = v25;
      *((_WORD *)this + 26) = 0;
      *((_QWORD *)this + 9) = v25;
      *((_QWORD *)this + 10) = 0;
      *((_QWORD *)v3 + 8) = this;
    }
    v26 = (const CLMicroLocationProto::HomeKitScene *)*((_QWORD *)a2 + 8);
    if (!v26)
    {
      CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto(this);
      v26 = *(const CLMicroLocationProto::HomeKitScene **)(CLMicroLocationProto::RecordingEvent::default_instance_ + 64);
    }
    CLMicroLocationProto::HomeKitScene::MergeFrom(v24, v26);
    v5 = *((_DWORD *)a2 + 35);
    if ((v5 & 0x200) == 0)
    {
LABEL_53:
      if ((v5 & 0x400) == 0)
        goto LABEL_54;
      goto LABEL_69;
    }
  }
  else if ((v5 & 0x200) == 0)
  {
    goto LABEL_53;
  }
  *((_DWORD *)v3 + 35) |= 0x200u;
  v27 = (CLMicroLocationProto::NowPlaying *)*((_QWORD *)v3 + 10);
  if (!v27)
  {
    this = (CLMicroLocationProto::RecordingEvent *)operator new();
    v27 = this;
    *((_QWORD *)this + 5) = 0;
    v28 = MEMORY[0x24BEDD958];
    *((_DWORD *)this + 12) = 0;
    *(_QWORD *)this = &off_2511D7820;
    *((_QWORD *)this + 1) = v28;
    *((_QWORD *)this + 2) = 12;
    *((_QWORD *)this + 3) = v28;
    *((_QWORD *)this + 4) = 0;
    *((_QWORD *)this + 7) = 0;
    *((_QWORD *)this + 8) = 0;
    *((_QWORD *)v3 + 10) = this;
  }
  v29 = (const CLMicroLocationProto::NowPlaying *)*((_QWORD *)a2 + 10);
  if (!v29)
  {
    CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto(this);
    v29 = *(const CLMicroLocationProto::NowPlaying **)(CLMicroLocationProto::RecordingEvent::default_instance_ + 80);
  }
  CLMicroLocationProto::NowPlaying::MergeFrom(v27, v29);
  v5 = *((_DWORD *)a2 + 35);
  if ((v5 & 0x400) == 0)
  {
LABEL_54:
    if ((v5 & 0x800) == 0)
      goto LABEL_55;
    goto LABEL_74;
  }
LABEL_69:
  *((_DWORD *)v3 + 35) |= 0x400u;
  v30 = (CLMicroLocationProto::RecordingRequest *)*((_QWORD *)v3 + 11);
  if (!v30)
  {
    this = (CLMicroLocationProto::RecordingEvent *)operator new();
    v30 = this;
    *(_QWORD *)this = &off_2511D73E8;
    *((_QWORD *)this + 1) = 0x10000000DLL;
    v31 = MEMORY[0x24BEDD958];
    *((_QWORD *)this + 2) = MEMORY[0x24BEDD958];
    *((_QWORD *)this + 3) = v31;
    *((_QWORD *)this + 4) = v31;
    *((_QWORD *)this + 5) = 0;
    *((_QWORD *)v3 + 11) = this;
  }
  v32 = (const CLMicroLocationProto::RecordingRequest *)*((_QWORD *)a2 + 11);
  if (!v32)
  {
    CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto(this);
    v32 = *(const CLMicroLocationProto::RecordingRequest **)(CLMicroLocationProto::RecordingEvent::default_instance_ + 88);
  }
  CLMicroLocationProto::RecordingRequest::MergeFrom(v30, v32);
  v5 = *((_DWORD *)a2 + 35);
  if ((v5 & 0x800) == 0)
  {
LABEL_55:
    if ((v5 & 0x1000) == 0)
      goto LABEL_56;
    goto LABEL_75;
  }
LABEL_74:
  v33 = *((_BYTE *)a2 + 76);
  *((_DWORD *)v3 + 35) |= 0x800u;
  *((_BYTE *)v3 + 76) = v33;
  v5 = *((_DWORD *)a2 + 35);
  if ((v5 & 0x1000) == 0)
  {
LABEL_56:
    if ((v5 & 0x2000) == 0)
      goto LABEL_57;
    goto LABEL_80;
  }
LABEL_75:
  *((_DWORD *)v3 + 35) |= 0x1000u;
  v34 = (CLMicroLocationProto::TruthLabelDonation *)*((_QWORD *)v3 + 12);
  if (!v34)
  {
    this = (CLMicroLocationProto::RecordingEvent *)operator new();
    v34 = this;
    *((_QWORD *)this + 4) = 14;
    v35 = MEMORY[0x24BEDD958];
    *(_QWORD *)this = &off_2511D75C8;
    *((_QWORD *)this + 1) = v35;
    *((_QWORD *)this + 2) = v35;
    *((_QWORD *)this + 3) = v35;
    *((_DWORD *)this + 10) = 0;
    *((_QWORD *)v3 + 12) = this;
  }
  v36 = (const CLMicroLocationProto::TruthLabelDonation *)*((_QWORD *)a2 + 12);
  if (!v36)
  {
    CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto(this);
    v36 = *(const CLMicroLocationProto::TruthLabelDonation **)(CLMicroLocationProto::RecordingEvent::default_instance_
                                                             + 96);
  }
  CLMicroLocationProto::TruthLabelDonation::MergeFrom(v34, v36);
  v5 = *((_DWORD *)a2 + 35);
  if ((v5 & 0x2000) == 0)
  {
LABEL_57:
    if ((v5 & 0x4000) == 0)
      goto LABEL_83;
    goto LABEL_81;
  }
LABEL_80:
  v37 = *((_BYTE *)a2 + 77);
  *((_DWORD *)v3 + 35) |= 0x2000u;
  *((_BYTE *)v3 + 77) = v37;
  v5 = *((_DWORD *)a2 + 35);
  if ((v5 & 0x4000) == 0)
    goto LABEL_83;
LABEL_81:
  v38 = *((_DWORD *)a2 + 30);
  if (v38 >= 4 && v38 != 15)
    CLMicroLocationLocalizationController::LocalizationRequest::finalizeTriggerConfidence();
  *((_DWORD *)v3 + 35) |= 0x4000u;
  *((_DWORD *)v3 + 30) = v38;
  v5 = *((_DWORD *)a2 + 35);
LABEL_83:
  if ((v5 & 0xFF0000) != 0)
  {
    if ((v5 & 0x10000) != 0)
    {
      *((_DWORD *)v3 + 35) |= 0x10000u;
      v39 = (CLMicroLocationProto::AssociatedAccessPointInfo *)*((_QWORD *)v3 + 16);
      if (!v39)
      {
        this = (CLMicroLocationProto::RecordingEvent *)operator new();
        v39 = this;
        *((_QWORD *)this + 1) = 0;
        *((_QWORD *)this + 2) = 0;
        *(_QWORD *)this = &off_2511D8108;
        *((_DWORD *)this + 6) = 0;
        *((_QWORD *)v3 + 16) = this;
      }
      v40 = (const CLMicroLocationProto::AssociatedAccessPointInfo *)*((_QWORD *)a2 + 16);
      if (!v40)
      {
        CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto(this);
        v40 = *(const CLMicroLocationProto::AssociatedAccessPointInfo **)(CLMicroLocationProto::RecordingEvent::default_instance_
                                                                        + 128);
      }
      CLMicroLocationProto::AssociatedAccessPointInfo::MergeFrom(v39, v40);
      v5 = *((_DWORD *)a2 + 35);
    }
    if ((v5 & 0x20000) != 0)
    {
      v41 = *((_DWORD *)a2 + 31);
      if (v41 >= 4)
        CLMicroLocationProto::RecordingEvent::MergeFrom();
      *((_DWORD *)v3 + 35) |= 0x20000u;
      *((_DWORD *)v3 + 31) = v41;
    }
  }
}

void sub_2419DD6B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void CLMicroLocationProto::AppLaunch::MergeFrom(CLMicroLocationProto::AppLaunch *this, const CLMicroLocationProto::AppLaunch *a2)
{
  CLMicroLocationProto::AppLaunch *v3;
  int v4;
  unsigned int v5;
  const std::string *v6;
  std::string *v7;
  CLMicroLocationProto::BundleIdFeatures *v8;
  const CLMicroLocationProto::BundleIdFeatures *v9;
  const std::string *v10;
  std::string *v11;
  _BYTE v12[48];

  v3 = this;
  if (a2 == this)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
    wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v12);
  }
  LOBYTE(v4) = *((_BYTE *)a2 + 40);
  if ((_BYTE)v4)
  {
    if ((*((_BYTE *)a2 + 40) & 1) != 0)
    {
      v5 = *((_DWORD *)a2 + 8);
      if (v5 - 31 >= 0x19 && (v5 > 0xE || ((1 << v5) & 0x76B6) == 0))
        CLMicroLocationProto::AppLaunch::MergeFrom();
      *((_DWORD *)v3 + 10) |= 1u;
      *((_DWORD *)v3 + 8) = v5;
      v4 = *((_DWORD *)a2 + 10);
    }
    if ((v4 & 2) != 0)
    {
      v6 = (const std::string *)*((_QWORD *)a2 + 1);
      *((_DWORD *)v3 + 10) |= 2u;
      v7 = (std::string *)*((_QWORD *)v3 + 1);
      if (v7 == (std::string *)MEMORY[0x24BEDD958])
      {
        v7 = (std::string *)operator new();
        v7->__r_.__value_.__l.__size_ = 0;
        v7->__r_.__value_.__r.__words[2] = 0;
        v7->__r_.__value_.__r.__words[0] = 0;
        *((_QWORD *)v3 + 1) = v7;
      }
      this = (CLMicroLocationProto::AppLaunch *)std::string::operator=(v7, v6);
      v4 = *((_DWORD *)a2 + 10);
      if ((v4 & 4) == 0)
      {
LABEL_11:
        if ((v4 & 8) == 0)
          return;
        goto LABEL_21;
      }
    }
    else if ((v4 & 4) == 0)
    {
      goto LABEL_11;
    }
    *((_DWORD *)v3 + 10) |= 4u;
    v8 = (CLMicroLocationProto::BundleIdFeatures *)*((_QWORD *)v3 + 2);
    if (!v8)
    {
      this = (CLMicroLocationProto::AppLaunch *)operator new();
      v8 = this;
      *(_QWORD *)this = &off_2511D72F8;
      *((_WORD *)this + 4) = 0;
      *((_DWORD *)this + 3) = 0;
      *((_DWORD *)this + 4) = 0;
      *((_QWORD *)v3 + 2) = this;
    }
    v9 = (const CLMicroLocationProto::BundleIdFeatures *)*((_QWORD *)a2 + 2);
    if (!v9)
    {
      CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto(this);
      v9 = *(const CLMicroLocationProto::BundleIdFeatures **)(CLMicroLocationProto::AppLaunch::default_instance_ + 16);
    }
    CLMicroLocationProto::BundleIdFeatures::MergeFrom(v8, v9);
    if ((*((_DWORD *)a2 + 10) & 8) != 0)
    {
LABEL_21:
      v10 = (const std::string *)*((_QWORD *)a2 + 3);
      *((_DWORD *)v3 + 10) |= 8u;
      v11 = (std::string *)*((_QWORD *)v3 + 3);
      if (v11 == (std::string *)MEMORY[0x24BEDD958])
      {
        v11 = (std::string *)operator new();
        v11->__r_.__value_.__l.__size_ = 0;
        v11->__r_.__value_.__r.__words[2] = 0;
        v11->__r_.__value_.__r.__words[0] = 0;
        *((_QWORD *)v3 + 3) = v11;
      }
      std::string::operator=(v11, v10);
    }
  }
}

void sub_2419DD8B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)va);
  _Unwind_Resume(a1);
}

void CLMicroLocationProto::RecordingEvent::SharedDtor(CLMicroLocationProto::RecordingEvent *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto(this);
  if ((CLMicroLocationProto::RecordingEvent *)CLMicroLocationProto::RecordingEvent::default_instance_ != this)
  {
    v2 = *((_QWORD *)this + 2);
    if (v2)
      (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
    v3 = *((_QWORD *)this + 3);
    if (v3)
      (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
    v4 = *((_QWORD *)this + 4);
    if (v4)
      (*(void (**)(uint64_t))(*(_QWORD *)v4 + 8))(v4);
    v5 = *((_QWORD *)this + 5);
    if (v5)
      (*(void (**)(uint64_t))(*(_QWORD *)v5 + 8))(v5);
    v6 = *((_QWORD *)this + 6);
    if (v6)
      (*(void (**)(uint64_t))(*(_QWORD *)v6 + 8))(v6);
    v7 = *((_QWORD *)this + 7);
    if (v7)
      (*(void (**)(uint64_t))(*(_QWORD *)v7 + 8))(v7);
    v8 = *((_QWORD *)this + 8);
    if (v8)
      (*(void (**)(uint64_t))(*(_QWORD *)v8 + 8))(v8);
    v9 = *((_QWORD *)this + 10);
    if (v9)
      (*(void (**)(uint64_t))(*(_QWORD *)v9 + 8))(v9);
    v10 = *((_QWORD *)this + 11);
    if (v10)
      (*(void (**)(uint64_t))(*(_QWORD *)v10 + 8))(v10);
    v11 = *((_QWORD *)this + 12);
    if (v11)
      (*(void (**)(uint64_t))(*(_QWORD *)v11 + 8))(v11);
    v12 = *((_QWORD *)this + 16);
    if (v12)
      (*(void (**)(uint64_t))(*(_QWORD *)v12 + 8))(v12);
  }
}

void CLMicroLocationProto::ReceivedEvent::SharedDtor(CLMicroLocationProto::ReceivedEvent *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;

  CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto(this);
  if ((CLMicroLocationProto::ReceivedEvent *)CLMicroLocationProto::ReceivedEvent::default_instance_ != this)
  {
    v2 = *((_QWORD *)this + 1);
    if (v2)
      (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
    v3 = *((_QWORD *)this + 2);
    if (v3)
      (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
    v4 = *((_QWORD *)this + 3);
    if (v4)
      (*(void (**)(uint64_t))(*(_QWORD *)v4 + 8))(v4);
    v5 = *((_QWORD *)this + 4);
    if (v5)
      (*(void (**)(uint64_t))(*(_QWORD *)v5 + 8))(v5);
    v6 = *((_QWORD *)this + 5);
    if (v6)
      (*(void (**)(uint64_t))(*(_QWORD *)v6 + 8))(v6);
    v7 = *((_QWORD *)this + 6);
    if (v7)
      (*(void (**)(uint64_t))(*(_QWORD *)v7 + 8))(v7);
    v8 = *((_QWORD *)this + 7);
    if (v8)
      (*(void (**)(uint64_t))(*(_QWORD *)v8 + 8))(v8);
    v9 = *((_QWORD *)this + 8);
    if (v9)
      (*(void (**)(uint64_t))(*(_QWORD *)v9 + 8))(v9);
    v10 = *((_QWORD *)this + 9);
    if (v10)
      (*(void (**)(uint64_t))(*(_QWORD *)v10 + 8))(v10);
    v11 = *((_QWORD *)this + 10);
    if (v11)
      (*(void (**)(uint64_t))(*(_QWORD *)v11 + 8))(v11);
    v12 = *((_QWORD *)this + 11);
    if (v12)
      (*(void (**)(uint64_t))(*(_QWORD *)v12 + 8))(v12);
    v13 = *((_QWORD *)this + 12);
    if (v13)
      (*(void (**)(uint64_t))(*(_QWORD *)v13 + 8))(v13);
    v14 = *((_QWORD *)this + 13);
    if (v14)
      (*(void (**)(uint64_t))(*(_QWORD *)v14 + 8))(v14);
    v15 = *((_QWORD *)this + 14);
    if (v15)
      (*(void (**)(uint64_t))(*(_QWORD *)v15 + 8))(v15);
    v16 = *((_QWORD *)this + 15);
    if (v16)
      (*(void (**)(uint64_t))(*(_QWORD *)v16 + 8))(v16);
    v17 = *((_QWORD *)this + 16);
    if (v17)
      (*(void (**)(uint64_t))(*(_QWORD *)v17 + 8))(v17);
    v18 = *((_QWORD *)this + 17);
    if (v18)
      (*(void (**)(uint64_t))(*(_QWORD *)v18 + 8))(v18);
    v19 = *((_QWORD *)this + 18);
    if (v19)
      (*(void (**)(uint64_t))(*(_QWORD *)v19 + 8))(v19);
    v20 = *((_QWORD *)this + 19);
    if (v20)
      (*(void (**)(uint64_t))(*(_QWORD *)v20 + 8))(v20);
    v21 = *((_QWORD *)this + 20);
    if (v21)
      (*(void (**)(uint64_t))(*(_QWORD *)v21 + 8))(v21);
    v22 = *((_QWORD *)this + 21);
    if (v22)
      (*(void (**)(uint64_t))(*(_QWORD *)v22 + 8))(v22);
    v23 = *((_QWORD *)this + 22);
    if (v23)
      (*(void (**)(uint64_t))(*(_QWORD *)v23 + 8))(v23);
    v24 = *((_QWORD *)this + 23);
    if (v24)
      (*(void (**)(uint64_t))(*(_QWORD *)v24 + 8))(v24);
    v25 = *((_QWORD *)this + 24);
    if (v25)
      (*(void (**)(uint64_t))(*(_QWORD *)v25 + 8))(v25);
    v26 = *((_QWORD *)this + 25);
    if (v26)
      (*(void (**)(uint64_t))(*(_QWORD *)v26 + 8))(v26);
    v27 = *((_QWORD *)this + 26);
    if (v27)
      (*(void (**)(uint64_t))(*(_QWORD *)v27 + 8))(v27);
    v28 = *((_QWORD *)this + 27);
    if (v28)
      (*(void (**)(uint64_t))(*(_QWORD *)v28 + 8))(v28);
    v29 = *((_QWORD *)this + 28);
    if (v29)
      (*(void (**)(uint64_t))(*(_QWORD *)v29 + 8))(v29);
    v30 = *((_QWORD *)this + 29);
    if (v30)
      (*(void (**)(uint64_t))(*(_QWORD *)v30 + 8))(v30);
    v31 = *((_QWORD *)this + 30);
    if (v31)
      (*(void (**)(uint64_t))(*(_QWORD *)v31 + 8))(v31);
    v32 = *((_QWORD *)this + 31);
    if (v32)
      (*(void (**)(uint64_t))(*(_QWORD *)v32 + 8))(v32);
    v33 = *((_QWORD *)this + 32);
    if (v33)
      (*(void (**)(uint64_t))(*(_QWORD *)v33 + 8))(v33);
    v34 = *((_QWORD *)this + 33);
    if (v34)
      (*(void (**)(uint64_t))(*(_QWORD *)v34 + 8))(v34);
    v35 = *((_QWORD *)this + 34);
    if (v35)
      (*(void (**)(uint64_t))(*(_QWORD *)v35 + 8))(v35);
    v36 = *((_QWORD *)this + 35);
    if (v36)
      (*(void (**)(uint64_t))(*(_QWORD *)v36 + 8))(v36);
  }
}

void CLMicroLocationProto::AppLaunch::~AppLaunch(CLMicroLocationProto::AppLaunch *this)
{
  CLMicroLocationProto::AppLaunch::~AppLaunch(this);
  JUMPOUT(0x2426A04D4);
}

{
  *(_QWORD *)this = &off_2511D7460;
  CLMicroLocationProto::AppLaunch::SharedDtor(this);
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(this);
}

void CLMicroLocationProto::AppLaunch::SharedDtor(CLMicroLocationProto::AppLaunch *this)
{
  CLMicroLocationProto::AppLaunch *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v5;
  uint64_t v7;

  v1 = this;
  v2 = *((_QWORD *)this + 1);
  v3 = MEMORY[0x24BEDD958];
  if (v2 != MEMORY[0x24BEDD958] && v2 != 0)
  {
    if (*(char *)(v2 + 23) < 0)
      operator delete(*(void **)v2);
    this = (CLMicroLocationProto::AppLaunch *)MEMORY[0x2426A04D4](v2, 0x1012C40EC159624);
  }
  v5 = *((_QWORD *)v1 + 3);
  if (v5 != v3 && v5 != 0)
  {
    if (*(char *)(v5 + 23) < 0)
      operator delete(*(void **)v5);
    this = (CLMicroLocationProto::AppLaunch *)MEMORY[0x2426A04D4](v5, 0x1012C40EC159624);
  }
  CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto(this);
  if ((CLMicroLocationProto::AppLaunch *)CLMicroLocationProto::AppLaunch::default_instance_ != v1)
  {
    v7 = *((_QWORD *)v1 + 2);
    if (v7)
      (*(void (**)(uint64_t))(*(_QWORD *)v7 + 8))(v7);
  }
}

void CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto(CLMicroLocationProto *this)
{
  uint64_t v1;
  _QWORD v2[2];
  char v3;

  v1 = CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto_once_;
  __dmb(0xBu);
  if (v1 != 2)
  {
    v2[0] = MEMORY[0x24BEDDBA8] + 16;
    v2[1] = CLMicroLocationProto::protobuf_AddDesc_microlocation_2eproto_impl;
    v3 = 0;
    wireless_diagnostics::google::protobuf::GoogleOnceInitImpl();
    wireless_diagnostics::google::protobuf::internal::FunctionClosure0::~FunctionClosure0((wireless_diagnostics::google::protobuf::internal::FunctionClosure0 *)v2);
  }
}

void sub_2419DDE64(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  wireless_diagnostics::google::protobuf::internal::FunctionClosure0::~FunctionClosure0((wireless_diagnostics::google::protobuf::internal::FunctionClosure0 *)va);
  _Unwind_Resume(a1);
}

void sub_2419DE18C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  void *v16;
  void *v17;

  v17 = v16;

  _Unwind_Resume(a1);
}

boost::uuids::detail::random_provider_base *boost::uuids::detail::random_provider_base::random_provider_base(boost::uuids::detail::random_provider_base *this)
{
  int v2;
  uint64_t v4;
  std::runtime_error *v5;
  int8x16_t v6;
  uint64_t v7;
  std::string v8;
  std::runtime_error v9;
  uint64_t v10;

  *(_DWORD *)this = -1;
  v2 = open("/dev/urandom", 0x1000000);
  *(_DWORD *)this = v2;
  if (v2 == -1)
  {
    v4 = *__error();
    std::string::basic_string[abi:ne180100]<0>(&v8, "open /dev/urandom");
    v5 = std::runtime_error::runtime_error(&v9, &v8);
    v9.__vftable = (std::runtime_error_vtbl *)&unk_2511D2A00;
    v10 = v4;
    v6.i64[0] = (uint64_t)"/AppleInternal/Library/BuildRoots/ae269ea5-5122-11ef-a621-12147c76fa9d/Applications/Xcode.app/C"
                         "ontents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS18.0.Internal.sdk/usr/loca"
                         "l/include/boost/uuid/detail/random_provider_posix.ipp";
    v6.i64[1] = (uint64_t)"boost::uuids::detail::random_provider_base::random_provider_base()";
    v7 = 60;
    boost::throw_exception<boost::uuids::entropy_error>(v5, &v6);
  }
  return this;
}

void sub_2419DE29C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  uint64_t v18;

  std::runtime_error::~runtime_error((std::runtime_error *)(v18 - 40));
  if (a18 < 0)
    operator delete(__p);
  _Unwind_Resume(a1);
}

uint64_t boost::uuids::detail::random_provider_base::destroy(boost::uuids::detail::random_provider_base *this)
{
  uint64_t result;

  result = *(unsigned int *)this;
  if ((result & 0x80000000) == 0)
    return close(result);
  return result;
}

uint64_t boost::uuids::detail::random_provider_base::get_random_bytes(uint64_t this, char *a2, unint64_t a3)
{
  int *v5;
  unint64_t v6;
  uint64_t v7;
  int8x16_t v8;
  uint64_t v9;
  std::string v10;
  std::runtime_error v11;
  uint64_t v12;

  if (a3)
  {
    v5 = (int *)this;
    v6 = 0;
    do
    {
      this = read(*v5, &a2[v6], a3 - v6);
      if (this < 0)
      {
        this = (uint64_t)__error();
        if (*(_DWORD *)this != 4)
        {
          v7 = *(int *)this;
          std::string::basic_string[abi:ne180100]<0>(&v10, "read");
          std::runtime_error::runtime_error(&v11, &v10);
          v11.__vftable = (std::runtime_error_vtbl *)&unk_2511D2A00;
          v12 = v7;
          v8.i64[0] = (uint64_t)"/AppleInternal/Library/BuildRoots/ae269ea5-5122-11ef-a621-12147c76fa9d/Applications/Xcode"
                               ".app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS18.0.Internal."
                               "sdk/usr/local/include/boost/uuid/detail/random_provider_posix.ipp";
          v8.i64[1] = (uint64_t)"void boost::uuids::detail::random_provider_base::get_random_bytes(void *, std::size_t)";
          v9 = 98;
          boost::throw_exception<boost::uuids::entropy_error>(&v11, &v8);
        }
      }
      else
      {
        v6 += this;
      }
    }
    while (v6 < a3);
  }
  return this;
}

void sub_2419DE3BC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, std::runtime_error a19)
{
  std::runtime_error::~runtime_error(&a19);
  if (a18 < 0)
    operator delete(__p);
  _Unwind_Resume(a1);
}

uint64_t boost::uuids::random_generator_pure::operator()(uint64_t a1)
{
  _QWORD v2[3];

  v2[2] = *MEMORY[0x24BDAC8D0];
  boost::uuids::detail::random_provider_base::get_random_bytes(a1, (char *)v2, 0x10uLL);
  BYTE6(v2[0]) = BYTE6(v2[0]) & 0xF | 0x40;
  return v2[0];
}

uint64_t CLMicroLocationLoggedEventsTable::Entry::Entry(uint64_t a1, _OWORD *a2, int a3, CLMicroLocationProto::ReceivedEvent *a4, double a5)
{
  *(_OWORD *)a1 = *a2;
  *(double *)(a1 + 16) = a5;
  *(_DWORD *)(a1 + 24) = a3;
  CLMicroLocationProto::ReceivedEvent::ReceivedEvent((CLMicroLocationProto::ReceivedEvent *)(a1 + 32), a4);
  return a1;
}

void CLMicroLocationProtobufHelper::setSpecificLoggedEvent(CLMicroLocationProtobufHelper *this, CLMicroLocationProto::ReceivedEvent *a2, const CLMicroLocationProto::AppLaunch *a3)
{
  CLMicroLocationProto::AppLaunch *v4;

  *((_DWORD *)this + 73) |= 2u;
  v4 = (CLMicroLocationProto::AppLaunch *)*((_QWORD *)this + 2);
  if (!v4)
  {
    v4 = (CLMicroLocationProto::AppLaunch *)operator new();
    CLMicroLocationProto::AppLaunch::AppLaunch(v4);
    *((_QWORD *)this + 2) = v4;
  }
  CLMicroLocationProto::AppLaunch::CopyFrom(v4, a2);
}

void sub_2419DE500(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x2426A04D4](v1, 0x10A1C406601F8D4);
  _Unwind_Resume(a1);
}

void CLMicroLocationProtobufHelper::createLoggedEvent<CLMicroLocationProto::AppLaunch>(_OWORD *a1@<X0>, int *a2@<X1>, uint64_t a3@<X8>, double a4@<D0>)
{
  const CLMicroLocationProto::AppLaunch *v8;
  _BYTE v9[304];

  CLMicroLocationProto::ReceivedEvent::ReceivedEvent((CLMicroLocationProto::ReceivedEvent *)v9);
  CLMicroLocationProtobufHelper::setSpecificLoggedEvent((CLMicroLocationProtobufHelper *)v9, (CLMicroLocationProto::ReceivedEvent *)a2, v8);
  CLMicroLocationLoggedEventsTable::Entry::Entry(a3, a1, a2[8], (CLMicroLocationProto::ReceivedEvent *)v9, a4);
  CLMicroLocationProto::ReceivedEvent::~ReceivedEvent((CLMicroLocationProto::ReceivedEvent *)v9);
}

void sub_2419DE598(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  CLMicroLocationProto::ReceivedEvent::~ReceivedEvent((CLMicroLocationProto::ReceivedEvent *)&a9);
  _Unwind_Resume(a1);
}

uint64_t CLMicroLocationLegacyClient::requestLocalizationOrRecordingIfPossible(CLMicroLocationLegacyClient *this, const CLMicroLocationProto::RecordingEvent *a2)
{
  CLMicroLocationProto::RecordingEvent *v4;
  int v5;
  uint64_t v6;
  char *v7;
  CLMicroLocationProto::RecordingEvent *v8;
  unsigned int v9;
  uint64_t v10;
  char *v11;
  uint64_t v13;
  __int128 *v14;
  __int128 v15;
  uint64_t v16;
  __int128 *v17;
  __int128 v18;
  void *__p[2];
  char v20;
  void *v21[2];
  char v22;
  void *v23[2];
  char v24;
  std::string v25;

  if (*((_BYTE *)this + 105))
  {
    v4 = (CLMicroLocationProto::RecordingEvent *)CLMicroLocationLegacyClient::requestLocalizationIfPossible(this, a2);
    v5 = (int)v4;
    if ((*((_BYTE *)a2 + 140) & 4) == 0)
      goto LABEL_6;
    v6 = *((_QWORD *)a2 + 2);
    if (!v6)
    {
      v4 = (CLMicroLocationProto::RecordingEvent *)CLMicroLocationProto::RecordingEvent::default_instance(v4);
      v6 = *((_QWORD *)v4 + 2);
    }
    if ((*(_BYTE *)(v6 + 44) & 4) != 0)
    {
      v13 = *((_QWORD *)a2 + 2);
      if (!v13)
        v13 = *(_QWORD *)(CLMicroLocationProto::RecordingEvent::default_instance(v4) + 16);
      v14 = *(__int128 **)(v13 + 16);
      if (*((char *)v14 + 23) < 0)
      {
        std::string::__init_copy_ctor_external(&v25, *(const std::string::value_type **)v14, *((_QWORD *)v14 + 1));
      }
      else
      {
        v15 = *v14;
        v25.__r_.__value_.__r.__words[2] = *((_QWORD *)v14 + 2);
        *(_OWORD *)&v25.__r_.__value_.__l.__data_ = v15;
      }
    }
    else
    {
LABEL_6:
      std::string::basic_string[abi:ne180100]<0>(&v25, "");
    }
    std::string::basic_string[abi:ne180100]<0>(v23, "localization");
    std::string::basic_string[abi:ne180100]<0>(v21, "home");
    if (v5)
      v7 = "success";
    else
      v7 = "fail";
    std::string::basic_string[abi:ne180100]<0>(__p, v7);
    CLMicroLocationLegacyEventDisplayState::getDisplayState((CLMicroLocationLegacyClient *)((char *)this + 2));
    CLMicroLocationCoreAnalyticsPublishHelper::sendTriggerEvent();
    if (v20 < 0)
      operator delete(__p[0]);
    if (v22 < 0)
      operator delete(v21[0]);
    if (v24 < 0)
      operator delete(v23[0]);
    if (SHIBYTE(v25.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v25.__r_.__value_.__l.__data_);
  }
  else
  {
    v5 = 0;
  }
  if (*((_BYTE *)this + 104))
  {
    v8 = (CLMicroLocationProto::RecordingEvent *)CLMicroLocationLegacyClient::requestRecordingIfPossible(this, a2);
    v9 = v8;
    if ((*((_BYTE *)a2 + 141) & 4) == 0)
      goto LABEL_24;
    v10 = *((_QWORD *)a2 + 11);
    if (!v10)
    {
      v8 = (CLMicroLocationProto::RecordingEvent *)CLMicroLocationProto::RecordingEvent::default_instance(v8);
      v10 = *((_QWORD *)v8 + 11);
    }
    if ((*(_BYTE *)(v10 + 44) & 4) != 0)
    {
      v16 = *((_QWORD *)a2 + 11);
      if (!v16)
        v16 = *(_QWORD *)(CLMicroLocationProto::RecordingEvent::default_instance(v8) + 88);
      v17 = *(__int128 **)(v16 + 16);
      if (*((char *)v17 + 23) < 0)
      {
        std::string::__init_copy_ctor_external(&v25, *(const std::string::value_type **)v17, *((_QWORD *)v17 + 1));
      }
      else
      {
        v18 = *v17;
        v25.__r_.__value_.__r.__words[2] = *((_QWORD *)v17 + 2);
        *(_OWORD *)&v25.__r_.__value_.__l.__data_ = v18;
      }
    }
    else
    {
LABEL_24:
      std::string::basic_string[abi:ne180100]<0>(&v25, "");
    }
    std::string::basic_string[abi:ne180100]<0>(v23, "recording");
    std::string::basic_string[abi:ne180100]<0>(v21, "home");
    if (v9)
      v11 = "success";
    else
      v11 = "fail";
    std::string::basic_string[abi:ne180100]<0>(__p, v11);
    CLMicroLocationLegacyEventDisplayState::getDisplayState((CLMicroLocationLegacyClient *)((char *)this + 2));
    CLMicroLocationCoreAnalyticsPublishHelper::sendTriggerEvent();
    if (v20 < 0)
      operator delete(__p[0]);
    if (v22 < 0)
      operator delete(v21[0]);
    if (v24 < 0)
      operator delete(v23[0]);
    if (SHIBYTE(v25.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v25.__r_.__value_.__l.__data_);
  }
  else
  {
    v9 = 0;
  }
  return v5 | v9;
}

void sub_2419DE840(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33)
{
  if (a21 < 0)
    operator delete(__p);
  if (a27 < 0)
    operator delete(a22);
  if (a33 < 0)
    operator delete(a28);
  _Unwind_Resume(exception_object);
}

void CLMicroLocationLegacyClient::onAppLaunch(CLMicroLocationLegacyClient *a1, uint64_t a2, double *a3)
{
  CLMicroLocationEventLogger *v5;
  CLMicroLocationProto::RecordingEvent *v6;
  uint64_t v7;
  double v8;
  int *v9;
  int v10;
  _BYTE v11[8];
  _BYTE v12[24];
  int *v13;
  __int128 v14;
  Entry v15;
  _QWORD v16[39];

  v16[38] = *MEMORY[0x24BDAC8D0];
  CLMicroLocationLegacyEventAppLaunch::handleEvent(a2, a3, v11);
  if (v11[0])
  {
    v5 = (CLMicroLocationEventLogger *)*((_QWORD *)a1 + 11);
    v10 = 0;
    boost::uuids::detail::random_provider_base::random_provider_base((boost::uuids::detail::random_provider_base *)&v10);
    v6 = (CLMicroLocationProto::RecordingEvent *)boost::uuids::random_generator_pure::operator()((uint64_t)&v10);
    *(_QWORD *)&v14 = v6;
    *((_QWORD *)&v14 + 1) = v7;
    v8 = *a3;
    v9 = v13;
    if (!v13)
      v9 = *(int **)(CLMicroLocationProto::RecordingEvent::default_instance(v6) + 24);
    CLMicroLocationProtobufHelper::createLoggedEvent<CLMicroLocationProto::AppLaunch>(&v14, v9, (uint64_t)&v15, v8);
    CLMicroLocationEventLogger::logEvent(v5, &v15);
    CLMicroLocationProto::ReceivedEvent::~ReceivedEvent((CLMicroLocationProto::ReceivedEvent *)v16);
    boost::uuids::detail::random_provider_base::destroy((boost::uuids::detail::random_provider_base *)&v10);
    CLMicroLocationLegacyClient::requestLocalizationOrRecordingIfPossible(a1, (const CLMicroLocationProto::RecordingEvent *)v12);
  }
  CLMicroLocationProto::RecordingEvent::~RecordingEvent((CLMicroLocationProto::RecordingEvent *)v12);
}

void sub_2419DE9B4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, int a10, char a11)
{
  CLMicroLocationProto::RecordingEvent *v11;

  CLMicroLocationProto::RecordingEvent::~RecordingEvent(v11);
  _Unwind_Resume(a1);
}

void CLMicroLocationEventLogger::logEvent(CLMicroLocationEventLogger *this, Entry *a2)
{
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  int v8;
  int v9;
  unint64_t v10;
  __int128 v11;
  uint64_t v12;
  unint64_t v13;

  +[ULDefaultsSingleton shared](ULDefaultsSingleton, "shared");
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v4, "defaultsDictionary");
  v5 = (void *)objc_claimAutoreleasedReturnValue();

  objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "ULEnableEventLogging");
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v5, "objectForKey:", v6);
  v7 = (void *)objc_claimAutoreleasedReturnValue();
  if (v7 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
    v8 = objc_msgSend(v7, "BOOLValue");
  else
    v8 = objc_msgSend(MEMORY[0x24BDBD1C8], "BOOLValue");
  v9 = v8;

  if (v9)
  {
    v10 = *((_QWORD *)this + 1);
    if (v10 >= *((_QWORD *)this + 2))
    {
      v12 = std::vector<CLMicroLocationLoggedEventsTable::Entry>::__emplace_back_slow_path<CLMicroLocationLoggedEventsTable::Entry const&>((uint64_t *)this, (__int128 *)a2);
    }
    else
    {
      v11 = (__int128)*a2;
      *(Entry *)(v10 + 12) = *(Entry *)((char *)a2 + 12);
      *(_OWORD *)v10 = v11;
      CLMicroLocationProto::ReceivedEvent::ReceivedEvent((CLMicroLocationProto::ReceivedEvent *)(v10 + 32), (const CLMicroLocationProto::ReceivedEvent *)&a2[2]);
      v12 = v10 + 336;
      *((_QWORD *)this + 1) = v10 + 336;
    }
    *((_QWORD *)this + 1) = v12;
    v13 = 0xCF3CF3CF3CF3CF3DLL * ((v12 - *(_QWORD *)this) >> 4);
    if (v13 >= ULSettings::get<ULSettings::EventLoggerMaxBufferSize>())
      CLMicroLocationEventLogger::flushToDisk(this);
  }
}

void sub_2419DEB4C(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  uint64_t v2;

  *(_QWORD *)(v1 + 8) = v2;
  _Unwind_Resume(exception_object);
}

double CLMicroLocationProto::AppLaunch::AppLaunch(CLMicroLocationProto::AppLaunch *this)
{
  double result;
  uint64_t v2;

  *(_QWORD *)&result = 2;
  *((_QWORD *)this + 4) = 2;
  v2 = MEMORY[0x24BEDD958];
  *(_QWORD *)this = &off_2511D7460;
  *((_QWORD *)this + 1) = v2;
  *((_QWORD *)this + 2) = 0;
  *((_QWORD *)this + 3) = v2;
  *((_DWORD *)this + 10) = 0;
  return result;
}

double CLMicroLocationProto::ReceivedEvent::ReceivedEvent(CLMicroLocationProto::ReceivedEvent *this)
{
  double result;

  *(_QWORD *)this = &off_2511D8090;
  result = 0.0;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 40) = 0u;
  *(_OWORD *)((char *)this + 56) = 0u;
  *(_OWORD *)((char *)this + 72) = 0u;
  *(_OWORD *)((char *)this + 88) = 0u;
  *(_OWORD *)((char *)this + 104) = 0u;
  *(_OWORD *)((char *)this + 120) = 0u;
  *(_OWORD *)((char *)this + 136) = 0u;
  *(_OWORD *)((char *)this + 152) = 0u;
  *(_OWORD *)((char *)this + 168) = 0u;
  *(_OWORD *)((char *)this + 184) = 0u;
  *(_OWORD *)((char *)this + 200) = 0u;
  *(_OWORD *)((char *)this + 216) = 0u;
  *(_OWORD *)((char *)this + 232) = 0u;
  *(_OWORD *)((char *)this + 248) = 0u;
  *((_DWORD *)this + 74) = 0;
  *(_OWORD *)((char *)this + 8) = 0u;
  *(_OWORD *)((char *)this + 264) = 0u;
  *(_OWORD *)((char *)this + 280) = 0u;
  return result;
}

uint64_t ULSettings::get<ULSettings::EventLoggerMaxBufferSize>()
{
  void *v0;
  void *v1;
  void *v2;
  void *v3;
  uint64_t v4;
  uint64_t v5;

  +[ULDefaultsSingleton shared](ULDefaultsSingleton, "shared");
  v0 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v0, "defaultsDictionary");
  v1 = (void *)objc_claimAutoreleasedReturnValue();

  objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "ULEventLoggerMaxBufferSize");
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v1, "objectForKey:", v2);
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  if (v3 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
    v4 = objc_msgSend(v3, "unsignedIntValue");
  else
    v4 = objc_msgSend(&unk_2511EE308, "unsignedIntValue");
  v5 = v4;

  return v5;
}

void sub_2419DECEC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_2419DEE3C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

void sub_2419DEF18(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void CLMicroLocationCosineSimilarityLocalizationAlgorithm::localize(CLMicroLocationModel *this@<X1>, uint64_t a2@<X2>, uint64_t a3@<X5>, char **a4@<X8>)
{
  NSObject *v7;
  int v8;
  int v9;
  NSObject *v10;
  char *v11;
  double *v12;
  double v13;
  NSObject *v14;
  void *v15;
  void *v16;
  void *v17;
  void *v18;
  float v19;
  float v20;
  unint64_t v21;
  char *v22;
  char *v23;
  char *v24;
  uint64_t v25;
  unint64_t v26;
  uint64_t v27;
  unint64_t v28;
  char *v29;
  char *v30;
  char *v31;
  int v32;
  NSObject *v33;
  double *v34;
  uint64_t i;
  int v36;
  NSObject *v37;
  unsigned int *v38;
  unsigned int *v39;
  NSObject *v40;
  _OWORD *v41;
  void **v42;
  uint64_t v43;
  uint64_t v44;
  char *v45;
  char *v46;
  char *v47;
  NSObject *v49;
  _OWORD *v50;
  void **v51;
  NSObject *v52;
  _OWORD *v53;
  void **v54;
  NSObject *v55;
  int v56;
  int v57;
  int *v58;
  uint64_t v59;
  uint64_t v60;
  int v61;
  uint64_t *v62;
  uint64_t v63;
  uint64_t v64;
  char *v65;
  char *v66;
  void *v67;
  char *v68;
  uint64_t v69;
  unint64_t v70;
  uint64_t v71;
  unint64_t v72;
  char *v73;
  uint64_t v74;
  char *v75;
  void *v76;
  char *v77;
  char *v78;
  char *v79;
  __int128 v80;
  int *v81;
  NSObject *v82;
  NSObject *v83;
  int v84;
  int v85;
  NSObject *v86;
  NSObject *v87;
  uint64_t v88;
  void *v89;
  uint64_t v90;
  char *v91;
  char *v92;
  char *v93;
  NSObject *v94;
  uint8_t *v95;
  NSObject *v96;
  uint8_t *v97;
  NSObject *v98;
  NSObject *v99;
  uint64_t v100;
  int *v101;
  int v102;
  NSObject *v103;
  uint64_t v104;
  int *v105;
  int v106;
  NSObject *v107;
  uint64_t v108;
  int *v109;
  int v110;
  void **v111;
  uint64_t v113;
  char v114;
  int v115;
  int v116;
  char v117;
  void *__p;
  __int128 v119;
  char v120;
  char v121[8];
  _QWORD *v122;
  id v123;
  _BYTE v124[32];
  char v125;
  _QWORD v126[3];
  uint8_t v127[8];
  __int16 v128;
  const char *v129;
  __int16 v130;
  _BYTE v131[10];
  _BYTE v132[24];
  uint8_t buf[8];
  _BYTE v134[10];
  __int16 v135;
  _BYTE v136[10];
  _BYTE v137[10];
  const char *v138;
  void *v139;
  void *v140;
  char v141;
  uint64_t v142;

  v142 = *MEMORY[0x24BDAC8D0];
  if (!CLMicroLocationModel::isValid(this))
  {
    CLMicroLocationCosineSimilarityLocalizationAlgorithm::localize();
    goto LABEL_233;
  }
  if (*((_DWORD *)this + 1) != 2)
  {
    _CLLogObjectForCategory_MicroLocation_Default();
    v94 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v94, OS_LOG_TYPE_FAULT))
    {
      CLMicroLocationProtobufHelper::modelTypeToString(*((_DWORD *)this + 1), v127);
      v95 = v131[3] >= 0 ? v127 : *(uint8_t **)v127;
      *(_QWORD *)buf = 68289795;
      *(_WORD *)v134 = 2082;
      *(_QWORD *)&v134[2] = "";
      v135 = 2082;
      *(_QWORD *)v136 = v95;
      *(_WORD *)&v136[8] = 2082;
      *(_QWORD *)v137 = "assert";
      *(_WORD *)&v137[8] = 2081;
      v138 = "model.modelType == CLMicroLocationProto::Model::SIMILARITY_LIST";
      _os_log_impl(&dword_2419D9000, v94, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"CosineSimilarityLocalization, model type is not similarity list!\", \"Model Type\":%{public, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x30u);
      if ((v131[3] & 0x80000000) != 0)
        operator delete(*(void **)v127);
    }

    _CLLogObjectForCategory_MicroLocation_Default();
    v96 = objc_claimAutoreleasedReturnValue();
    if (os_signpost_enabled(v96))
    {
      CLMicroLocationProtobufHelper::modelTypeToString(*((_DWORD *)this + 1), v127);
      v97 = v131[3] >= 0 ? v127 : *(uint8_t **)v127;
      *(_QWORD *)buf = 68289795;
      *(_WORD *)v134 = 2082;
      *(_QWORD *)&v134[2] = "";
      v135 = 2082;
      *(_QWORD *)v136 = v97;
      *(_WORD *)&v136[8] = 2082;
      *(_QWORD *)v137 = "assert";
      *(_WORD *)&v137[8] = 2081;
      v138 = "model.modelType == CLMicroLocationProto::Model::SIMILARITY_LIST";
      _os_signpost_emit_with_name_impl(&dword_2419D9000, v96, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "CosineSimilarityLocalization, model type is not similarity list!", "{\"msg%{public}.0s\":\"CosineSimilarityLocalization, model type is not similarity list!\", \"Model Type\":%{public, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x30u);
      if ((v131[3] & 0x80000000) != 0)
        operator delete(*(void **)v127);
    }

    _CLLogObjectForCategory_MicroLocation_Default();
    v98 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v98, OS_LOG_TYPE_INFO))
    {
      CLMicroLocationProtobufHelper::modelTypeToString(*((_DWORD *)this + 1), v127);
      CLMicroLocationCosineSimilarityLocalizationAlgorithm::localize((char *)v127, buf, v98);
    }

    abort_report_np();
    goto LABEL_233;
  }
  *a4 = 0;
  a4[1] = 0;
  a4[2] = 0;
  a4[4] = 0;
  *((_BYTE *)a4 + 80) = 0;
  a4[5] = 0;
  a4[6] = 0;
  *((_BYTE *)a4 + 56) = 0;
  *((_DWORD *)a4 + 6) = *(_DWORD *)(a2 + 160);
  v111 = (void **)(a4 + 4);
  std::vector<CLMicroLocationProto::ConfidenceReason>::__insert_with_size[abi:ne180100]<std::__wrap_iter<CLMicroLocationProto::ConfidenceReason const*>,std::__wrap_iter<CLMicroLocationProto::ConfidenceReason const*>>((uint64_t)(a4 + 4), 0, *(char **)(a2 + 168), *(char **)(a2 + 176), (uint64_t)(*(_QWORD *)(a2 + 176) - *(_QWORD *)(a2 + 168)) >> 2);
  if (*((_BYTE *)this + 192) && *((_QWORD *)this + 13) != *((_QWORD *)this + 12))
  {
    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global);
    v7 = (id)logObject_MicroLocation_Default;
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      v8 = *((unsigned __int8 *)this + 144);
      if (*((_BYTE *)this + 144))
      {
        v9 = *((_DWORD *)this + 33);
        if (*((_BYTE *)this + 129))
          v8 = *((_DWORD *)this + 34);
        else
          v8 = *((_DWORD *)this + 33);
        if (!*((_BYTE *)this + 129))
          v9 = *((_DWORD *)this + 34);
      }
      else
      {
        v9 = 0;
      }
      *(_QWORD *)buf = 68289538;
      *(_WORD *)v134 = 2082;
      *(_QWORD *)&v134[2] = "";
      v135 = 1026;
      *(_DWORD *)v136 = v8;
      *(_WORD *)&v136[4] = 1026;
      *(_DWORD *)&v136[6] = v9;
      _os_log_impl(&dword_2419D9000, v7, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CosineSimilarityLocalization, running localization\", \"LSL Length\":%{public}d, \"LSL Num Clusters\":%{public}d}", buf, 0x1Eu);
    }

    if (*((_BYTE *)this + 129))
      v11 = (char *)this + 132;
    else
      v11 = (char *)this + 136;
    CLMicroLocationUtils::ProbabilityMatrix::ProbabilityMatrix((CLMicroLocationUtils::ProbabilityMatrix *)v126, 1, *(_DWORD *)v11 + 1);
    v124[0] = 0;
    v125 = 0;
    std::string::basic_string[abi:ne180100]<0>(buf, "com.apple.magicalmoments");
    CLMicroLocationLocalizationSettings::CLMicroLocationLocalizationSettings((uint64_t)v121, buf);
    if ((v136[3] & 0x80000000) != 0)
      operator delete(*(void **)buf);
    CLMicroLocationLocalizer::localize((const CLMicroLocationProto::AssociatedAccessPointInfo *)v124, (uint64_t)this, a2, (CLMicroLocationLocalizationSettings *)v121, 0, 0, (uint64_t)buf);
    v12 = *(double **)buf;
    if (*(_QWORD *)buf != *(_QWORD *)v134)
    {
      while (*(_OWORD *)v12 != 0)
      {
        v12 += 4;
        if (v12 == *(double **)v134)
          goto LABEL_32;
      }
    }
    if (v12 == *(double **)v134)
    {
LABEL_32:
      if (onceToken_MicroLocation_Default != -1)
        dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global);
      v14 = (id)logObject_MicroLocation_Default;
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)v127 = 0;
        _os_log_impl(&dword_2419D9000, v14, OS_LOG_TYPE_ERROR, "CosineSimilarityLocalization, did not find null space probability", v127, 2u);
      }

      v13 = 0.0;
    }
    else
    {
      v13 = v12[2];
    }
    +[ULDefaultsSingleton shared](ULDefaultsSingleton, "shared");
    v15 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v15, "defaultsDictionary");
    v16 = (void *)objc_claimAutoreleasedReturnValue();

    objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "ULNullClusterThresholdForLowConfidence");
    v17 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v16, "objectForKey:", v17);
    v18 = (void *)objc_claimAutoreleasedReturnValue();
    if (v18 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
      objc_msgSend(v18, "floatValue");
    else
      objc_msgSend(&unk_2511ECD08, "floatValue");
    v20 = v19;

    if (v13 > v20)
    {
      v21 = (unint64_t)a4[6];
      *((_DWORD *)a4 + 6) = 0;
      v22 = a4[5];
      if ((unint64_t)v22 >= v21)
      {
        v24 = (char *)*v111;
        v25 = (v22 - (_BYTE *)*v111) >> 2;
        v26 = v25 + 1;
        if ((unint64_t)(v25 + 1) >> 62)
          std::vector<CLMicroLocationProto::ConfidenceReason>::__throw_length_error[abi:ne180100]();
        v27 = v21 - (_QWORD)v24;
        if (v27 >> 1 > v26)
          v26 = v27 >> 1;
        if ((unint64_t)v27 >= 0x7FFFFFFFFFFFFFFCLL)
          v28 = 0x3FFFFFFFFFFFFFFFLL;
        else
          v28 = v26;
        if (v28)
        {
          v29 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<CLMicroLocationProto::ConfidenceReason>>((uint64_t)(a4 + 6), v28);
          v24 = a4[4];
          v22 = a4[5];
        }
        else
        {
          v29 = 0;
        }
        v30 = &v29[4 * v25];
        v31 = &v29[4 * v28];
        *(_DWORD *)v30 = 7;
        v23 = v30 + 4;
        while (v22 != v24)
        {
          v32 = *((_DWORD *)v22 - 1);
          v22 -= 4;
          *((_DWORD *)v30 - 1) = v32;
          v30 -= 4;
        }
        a4[4] = v30;
        a4[5] = v23;
        a4[6] = v31;
        if (v24)
          operator delete(v24);
      }
      else
      {
        *(_DWORD *)v22 = 7;
        v23 = v22 + 4;
      }
      a4[5] = v23;
      if (onceToken_MicroLocation_Default != -1)
        dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global);
      v33 = (id)logObject_MicroLocation_Default;
      if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)v127 = 68289283;
        *(_DWORD *)&v127[4] = 0;
        v128 = 2082;
        v129 = "";
        v130 = 2049;
        *(double *)v131 = v13;
        _os_log_impl(&dword_2419D9000, v33, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CosineSimilarityLocalization, setting invalid confidence due to high null cluster probability\", \"nullClusterProbability\":\"%{private}.6f\"}", v127, 0x1Cu);
      }

    }
    if (a3)
    {
      v34 = *(double **)buf;
      if (*(_QWORD *)buf != *(_QWORD *)v134)
      {
        for (i = *(_QWORD *)buf + 32; i != *(_QWORD *)v134; i += 32)
        {
          if (v34[2] < *(double *)(i + 16) || *(_OWORD *)v34 == 0)
            v34 = (double *)i;
        }
      }
      if (*(_OWORD *)v34 != 0)
      {
        v36 = *(unsigned __int8 *)(a3 + 16);
        *(_OWORD *)a3 = *(_OWORD *)v34;
        if (!v36)
          *(_BYTE *)(a3 + 16) = 1;
      }
    }
    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global);
    v37 = (id)logObject_MicroLocation_Default;
    if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)v127 = 68289282;
      *(_DWORD *)&v127[4] = 0;
      v128 = 2082;
      v129 = "";
      v130 = 2050;
      *(_QWORD *)v131 = (uint64_t)(*(_QWORD *)v134 - *(_QWORD *)buf) >> 5;
      _os_log_impl(&dword_2419D9000, v37, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CosineSimilarityLocalization, internalLocalizer results\", \"numInternalResults\":%{public}lu}", v127, 0x1Cu);
    }

    v39 = *(unsigned int **)buf;
    v38 = *(unsigned int **)v134;
    if (*(_QWORD *)v134 == *(_QWORD *)buf)
      goto LABEL_178;
    do
    {
      if (onceToken_MicroLocation_Default != -1)
        dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global);
      v40 = (id)logObject_MicroLocation_Default;
      if (os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT))
      {
        v41 = operator new(0x28uLL);
        __p = v41;
        v119 = xmmword_241BB2320;
        *v41 = 0u;
        v41[1] = 0u;
        *(_QWORD *)((char *)v41 + 29) = 0;
        boost::uuids::to_chars<char *>((uint64_t)v39, v41);
        v42 = v119 >= 0 ? &__p : (void **)__p;
        v43 = *((_QWORD *)v39 + 2);
        v44 = v39[6];
        *(_DWORD *)v127 = 68289795;
        *(_DWORD *)&v127[4] = 0;
        v128 = 2082;
        v129 = "";
        v130 = 2081;
        *(_QWORD *)v131 = v42;
        *(_WORD *)&v131[8] = 2049;
        *(_QWORD *)v132 = v43;
        *(_WORD *)&v132[8] = 2049;
        *(_QWORD *)&v132[10] = v44;
        _os_log_impl(&dword_2419D9000, v40, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CosineSimilarityLocalization, internalLocalizer result\", \"MicrolocationId\":%{private, location:escape_only}s, \"Probability\":\"%{private}.6f\", \"ConfidenceLevel\":%{private}lu}", v127, 0x30u);
        if (SHIBYTE(v119) < 0)
          operator delete(__p);
      }

      if (*(_OWORD *)v39 == 0)
      {
        CLMicroLocationUtils::ProbabilityMatrix::setValue((CLMicroLocationUtils::ProbabilityMatrix *)v126, 0, 0, *((double *)v39 + 2));
      }
      else
      {
        v45 = (char *)*((_QWORD *)this + 9);
        v46 = (char *)*((_QWORD *)this + 10);
        v47 = v45;
        if (v45 != v46)
        {
          while (*(_QWORD *)v47 != *(_QWORD *)v39 || *((_QWORD *)v47 + 1) != *((_QWORD *)v39 + 1))
          {
            v47 += 16;
            if (v47 == v46)
            {
              v47 = (char *)*((_QWORD *)this + 10);
              break;
            }
          }
        }
        if (v47 == v46)
        {
          if (onceToken_MicroLocation_Default != -1)
            dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global);
          v49 = (id)logObject_MicroLocation_Default;
          if (os_log_type_enabled(v49, OS_LOG_TYPE_ERROR))
          {
            v50 = operator new(0x28uLL);
            __p = v50;
            v119 = xmmword_241BB2320;
            *v50 = 0u;
            v50[1] = 0u;
            *(_QWORD *)((char *)v50 + 29) = 0;
            boost::uuids::to_chars<char *>((uint64_t)v39, v50);
            v51 = v119 >= 0 ? &__p : (void **)__p;
            *(_DWORD *)v127 = 68289282;
            *(_DWORD *)&v127[4] = 0;
            v128 = 2082;
            v129 = "";
            v130 = 2082;
            *(_QWORD *)v131 = v51;
            _os_log_impl(&dword_2419D9000, v49, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"CosineSimilarityLocalization, unexpected identifier\", \"cluster ID\":%{public, location:escape_only}s}", v127, 0x1Cu);
            if (SHIBYTE(v119) < 0)
              operator delete(__p);
          }

          if (onceToken_MicroLocation_Default != -1)
            dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global);
          v52 = (id)logObject_MicroLocation_Default;
          if (os_signpost_enabled(v52))
          {
            v53 = operator new(0x28uLL);
            __p = v53;
            v119 = xmmword_241BB2320;
            *v53 = 0u;
            v53[1] = 0u;
            *(_QWORD *)((char *)v53 + 29) = 0;
            boost::uuids::to_chars<char *>((uint64_t)v39, v53);
            v54 = v119 >= 0 ? &__p : (void **)__p;
            *(_DWORD *)v127 = 68289282;
            *(_DWORD *)&v127[4] = 0;
            v128 = 2082;
            v129 = "";
            v130 = 2082;
            *(_QWORD *)v131 = v54;
            _os_signpost_emit_with_name_impl(&dword_2419D9000, v52, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "CosineSimilarityLocalization, unexpected identifier", "{\"msg%{public}.0s\":\"CosineSimilarityLocalization, unexpected identifier\", \"cluster ID\":%{public, location:escape_only}s}", v127, 0x1Cu);
            if (SHIBYTE(v119) < 0)
              operator delete(__p);
          }

        }
        else
        {
          CLMicroLocationUtils::ProbabilityMatrix::setValue((CLMicroLocationUtils::ProbabilityMatrix *)v126, 0, ((unint64_t)(v47 - v45) >> 4) + 1, *((double *)v39 + 2));
        }
      }
      v39 += 8;
    }
    while (v39 != v38);
    if ((CLMicroLocationUtils::ProbabilityMatrix::normalizeRows((CLMicroLocationUtils::ProbabilityMatrix *)v126) & 1) == 0)
    {
      if (onceToken_MicroLocation_Default != -1)
        dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global);
      v82 = (id)logObject_MicroLocation_Default;
      if (os_log_type_enabled(v82, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)v127 = 68289026;
        *(_DWORD *)&v127[4] = 0;
        v128 = 2082;
        v129 = "";
        _os_log_impl(&dword_2419D9000, v82, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"CosineSimilarityLocalization, error normalizing currentLocalizationVec!\"}", v127, 0x12u);
      }

      if (onceToken_MicroLocation_Default != -1)
        dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global);
      v83 = (id)logObject_MicroLocation_Default;
      if (os_signpost_enabled(v83))
      {
        *(_DWORD *)v127 = 68289026;
        *(_DWORD *)&v127[4] = 0;
        v128 = 2082;
        v129 = "";
        _os_signpost_emit_with_name_impl(&dword_2419D9000, v83, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "CosineSimilarityLocalization, error normalizing currentLocalizationVec!", "{\"msg%{public}.0s\":\"CosineSimilarityLocalization, error normalizing currentLocalizationVec!\"}", v127, 0x12u);
      }

      v84 = 0;
      v85 = 1;
      goto LABEL_179;
    }
    CLMicroLocationUtils::ProbabilityMatrix::removeFirstCols(v126, 1u, (uint64_t)&__p);
    BYTE1(v119) = 1;
    CLMicroLocationUtils::ProbabilityMatrix::multByVec((CLMicroLocationModel *)((char *)this + 120), (const CLMicroLocationUtils::ProbabilityMatrix *)&__p, (uint64_t)&v113);
    if (!v117)
    {
      if (onceToken_MicroLocation_Default != -1)
        dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global);
      v86 = (id)logObject_MicroLocation_Default;
      if (os_log_type_enabled(v86, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)v127 = 68289026;
        *(_DWORD *)&v127[4] = 0;
        v128 = 2082;
        v129 = "";
        _os_log_impl(&dword_2419D9000, v86, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"CosineSimilarityLocalization, multByVec failed!\"}", v127, 0x12u);
      }

      if (onceToken_MicroLocation_Default != -1)
        dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global);
      v87 = (id)logObject_MicroLocation_Default;
      if (os_signpost_enabled(v87))
      {
        *(_DWORD *)v127 = 68289026;
        *(_DWORD *)&v127[4] = 0;
        v128 = 2082;
        v129 = "";
        _os_signpost_emit_with_name_impl(&dword_2419D9000, v87, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "CosineSimilarityLocalization, multByVec failed!", "{\"msg%{public}.0s\":\"CosineSimilarityLocalization, multByVec failed!\"}", v127, 0x12u);
      }

      goto LABEL_172;
    }
    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global);
    v55 = (id)logObject_MicroLocation_Default;
    if (os_log_type_enabled(v55, OS_LOG_TYPE_DEFAULT))
    {
      v56 = v115;
      if (v114)
        v57 = v116;
      else
        v57 = v115;
      if (!v114)
        v56 = v116;
      *(_DWORD *)v127 = 68289538;
      *(_DWORD *)&v127[4] = 0;
      v128 = 2082;
      v129 = "";
      v130 = 1026;
      *(_DWORD *)v131 = v57;
      *(_WORD *)&v131[4] = 1026;
      *(_DWORD *)&v131[6] = v56;
      _os_log_impl(&dword_2419D9000, v55, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"cosine similarity results shape\", \"Rows\":%{public}d, \"Cols\":%{public}d}", v127, 0x1Eu);
    }

    if (v114)
      v58 = &v116;
    else
      v58 = &v115;
    v59 = *v58;
    if (v59 == (uint64_t)(*((_QWORD *)this + 20) - *((_QWORD *)this + 19)) >> 2)
    {
      if ((int)v59 >= 1)
      {
        v60 = 0;
        do
        {
          if (*(_DWORD *)(a2 + 160) >= *(_DWORD *)(*((_QWORD *)this + 19) + 4 * v60))
            v61 = *(_DWORD *)(*((_QWORD *)this + 19) + 4 * v60);
          else
            v61 = *(_DWORD *)(a2 + 160);
          *(_QWORD *)v127 = 0;
          CLMicroLocationUtils::ProbabilityMatrix::getValue((CLMicroLocationUtils::ProbabilityMatrix *)&v113, v60, 0, (double *)v127);
          v62 = (uint64_t *)(*((_QWORD *)this + 12) + 16 * v60);
          v64 = *v62;
          v63 = v62[1];
          v65 = a4[1];
          v66 = a4[2];
          if (v65 >= v66)
          {
            v69 = (v65 - *a4) >> 5;
            v70 = v69 + 1;
            if ((unint64_t)(v69 + 1) >> 59)
              std::vector<CLMicroLocationProto::ConfidenceReason>::__throw_length_error[abi:ne180100]();
            v71 = v66 - *a4;
            if (v71 >> 4 > v70)
              v70 = v71 >> 4;
            if ((unint64_t)v71 >= 0x7FFFFFFFFFFFFFE0)
              v72 = 0x7FFFFFFFFFFFFFFLL;
            else
              v72 = v70;
            v73 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<CLMicroLocationResultInternal>>((uint64_t)(a4 + 2), v72);
            v75 = &v73[32 * v69];
            v76 = *(void **)v127;
            *(_QWORD *)v75 = v64;
            *((_QWORD *)v75 + 1) = v63;
            *((_QWORD *)v75 + 2) = v76;
            *((_DWORD *)v75 + 6) = v61;
            v78 = *a4;
            v77 = a4[1];
            v79 = v75;
            if (v77 != *a4)
            {
              do
              {
                v80 = *((_OWORD *)v77 - 2);
                *(_OWORD *)(v79 - 20) = *(_OWORD *)(v77 - 20);
                *((_OWORD *)v79 - 2) = v80;
                v79 -= 32;
                v77 -= 32;
              }
              while (v77 != v78);
              v77 = *a4;
            }
            v68 = v75 + 32;
            *a4 = v79;
            a4[1] = v75 + 32;
            a4[2] = &v73[32 * v74];
            if (v77)
              operator delete(v77);
          }
          else
          {
            v67 = *(void **)v127;
            *(_QWORD *)v65 = v64;
            *((_QWORD *)v65 + 1) = v63;
            *((_QWORD *)v65 + 2) = v67;
            *((_DWORD *)v65 + 6) = v61;
            v68 = v65 + 32;
          }
          a4[1] = v68;
          ++v60;
          if (v114)
            v81 = &v116;
          else
            v81 = &v115;
        }
        while (v60 < *v81);
      }
LABEL_172:
      if (v117)
      {
        v88 = v113;
        v113 = 0;
        if (v88)
          MEMORY[0x2426A04BC](v88, 0x1000C8000313F17);
      }
      if (v120)
      {
        v89 = __p;
        __p = 0;
        if (v89)
          MEMORY[0x2426A04BC](v89, 0x1000C8000313F17);
      }
LABEL_178:
      std::optional<std::vector<CLMicroLocationResultInternal>>::operator=[abi:ne180100]<std::vector<CLMicroLocationResultInternal>,void>((uint64_t)(a4 + 7), (__n128 *)buf);
      v85 = 0;
      v84 = 1;
LABEL_179:
      if (v141 && v139)
      {
        v140 = v139;
        operator delete(v139);
      }
      if (*(_QWORD *)&v137[2])
      {
        v138 = *(const char **)&v137[2];
        operator delete(*(void **)&v137[2]);
      }
      if (*(_QWORD *)buf)
      {
        *(_QWORD *)v134 = *(_QWORD *)buf;
        operator delete(*(void **)buf);
      }

      std::__tree<std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>,std::__map_value_compare<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>,std::less<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes>,true>,std::allocator<std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>>>::destroy((uint64_t)v121, v122);
      if (v125)
        CLMicroLocationProto::AssociatedAccessPointInfo::~AssociatedAccessPointInfo((CLMicroLocationProto::AssociatedAccessPointInfo *)v124);
      v90 = v126[0];
      v126[0] = 0;
      if (v90)
        MEMORY[0x2426A04BC](v90, 0x1000C8000313F17);
      if (((v85 | v84) & 1) == 0)
      {
        if (*((_BYTE *)a4 + 80))
        {
          v91 = a4[7];
          if (v91)
          {
            a4[8] = v91;
            operator delete(v91);
          }
        }
        v92 = (char *)*v111;
        if (*v111)
        {
          a4[5] = v92;
          operator delete(v92);
        }
        v93 = *a4;
        if (*a4)
        {
          a4[1] = v93;
          operator delete(v93);
        }
      }
      return;
    }
    _CLLogObjectForCategory_MicroLocation_Default();
    v99 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v99, OS_LOG_TYPE_FAULT))
    {
      v100 = (uint64_t)(*((_QWORD *)this + 20) - *((_QWORD *)this + 19)) >> 2;
      if (v114)
        v101 = &v116;
      else
        v101 = &v115;
      v102 = *v101;
      *(_DWORD *)v127 = 68290051;
      *(_DWORD *)&v127[4] = 0;
      v128 = 2082;
      v129 = "";
      v130 = 2050;
      *(_QWORD *)v131 = v100;
      *(_WORD *)&v131[8] = 1026;
      *(_DWORD *)v132 = v102;
      *(_WORD *)&v132[4] = 2082;
      *(_QWORD *)&v132[6] = "assert";
      *(_WORD *)&v132[14] = 2081;
      *(_QWORD *)&v132[16] = "lslEventConfidences.size() == static_cast<size_t>(cosineSimilarityOpt->getNumRows())";
      _os_log_impl(&dword_2419D9000, v99, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"CosineSimilarityLocalization, confidence vector size not equal to prob matrix row number!\", \"confidence vector size\":%{public}lu, \"number of prob matrix rows\":%{public}d, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", v127, 0x36u);
    }

    _CLLogObjectForCategory_MicroLocation_Default();
    v103 = objc_claimAutoreleasedReturnValue();
    if (os_signpost_enabled(v103))
    {
      v104 = (uint64_t)(*((_QWORD *)this + 20) - *((_QWORD *)this + 19)) >> 2;
      if (v114)
        v105 = &v116;
      else
        v105 = &v115;
      v106 = *v105;
      *(_DWORD *)v127 = 68290051;
      *(_DWORD *)&v127[4] = 0;
      v128 = 2082;
      v129 = "";
      v130 = 2050;
      *(_QWORD *)v131 = v104;
      *(_WORD *)&v131[8] = 1026;
      *(_DWORD *)v132 = v106;
      *(_WORD *)&v132[4] = 2082;
      *(_QWORD *)&v132[6] = "assert";
      *(_WORD *)&v132[14] = 2081;
      *(_QWORD *)&v132[16] = "lslEventConfidences.size() == static_cast<size_t>(cosineSimilarityOpt->getNumRows())";
      _os_signpost_emit_with_name_impl(&dword_2419D9000, v103, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "CosineSimilarityLocalization, confidence vector size not equal to prob matrix row number!", "{\"msg%{public}.0s\":\"CosineSimilarityLocalization, confidence vector size not equal to prob matrix row number!\", \"confidence vector size\":%{public}lu, \"number of prob matrix rows\":%{public}d, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", v127, 0x36u);
    }

    _CLLogObjectForCategory_MicroLocation_Default();
    v107 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v107, OS_LOG_TYPE_INFO))
    {
      v108 = (uint64_t)(*((_QWORD *)this + 20) - *((_QWORD *)this + 19)) >> 2;
      if (v114)
        v109 = &v116;
      else
        v109 = &v115;
      v110 = *v109;
      *(_DWORD *)v127 = 68290051;
      *(_DWORD *)&v127[4] = 0;
      v128 = 2082;
      v129 = "";
      v130 = 2050;
      *(_QWORD *)v131 = v108;
      *(_WORD *)&v131[8] = 1026;
      *(_DWORD *)v132 = v110;
      *(_WORD *)&v132[4] = 2082;
      *(_QWORD *)&v132[6] = "assert";
      *(_WORD *)&v132[14] = 2081;
      *(_QWORD *)&v132[16] = "lslEventConfidences.size() == static_cast<size_t>(cosineSimilarityOpt->getNumRows())";
      _os_log_impl(&dword_2419D9000, v107, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"CosineSimilarityLocalization, confidence vector size not equal to prob matrix row number!\", \"confidence vector size\":%{public}lu, \"number of prob matrix rows\":%{public}d, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", v127, 0x36u);
    }

    abort_report_np();
LABEL_233:
    __break(1u);
    return;
  }
  if (onceToken_MicroLocation_Default != -1)
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global);
  v10 = logObject_MicroLocation_Default;
  if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT))
  {
    *(_QWORD *)buf = 68289026;
    *(_WORD *)v134 = 2082;
    *(_QWORD *)&v134[2] = "";
    _os_log_impl(&dword_2419D9000, v10, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CosineSimilarityLocalization, model with empty LSL, publishing empty results\"}", buf, 0x12u);
  }
}

void sub_2419E0444(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31,id a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,char a37,uint64_t a38,uint64_t a39,uint64_t a40,char a41,uint64_t a42)
{
  CLMicroLocationAlgorithms::LocalizerResults *v42;
  uint64_t v43;
  uint64_t v45;

  if (a31 && a28)
    MEMORY[0x2426A04BC](a28, 0x1000C8000313F17);
  CLMicroLocationAlgorithms::LocalizerResults::~LocalizerResults((CLMicroLocationAlgorithms::LocalizerResults *)(v43 - 208));
  CLMicroLocationLocalizationSettings::~CLMicroLocationLocalizationSettings(&a32);
  if (a41)
    CLMicroLocationProto::AssociatedAccessPointInfo::~AssociatedAccessPointInfo((CLMicroLocationProto::AssociatedAccessPointInfo *)&a37);
  v45 = a42;
  a42 = 0;
  if (v45)
    MEMORY[0x2426A04BC](v45, 0x1000C8000313F17);
  CLMicroLocationAlgorithms::LocalizerResults::~LocalizerResults(v42);
  _Unwind_Resume(a1);
}

id _CLLogObjectForCategory_MicroLocation_Default(void)
{
  if (onceToken_MicroLocation_Default != -1)
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global);
  return (id)logObject_MicroLocation_Default;
}

{
  if (onceToken_MicroLocation_Default != -1)
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_3);
  return (id)logObject_MicroLocation_Default;
}

{
  if (onceToken_MicroLocation_Default != -1)
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_5);
  return (id)logObject_MicroLocation_Default;
}

{
  if (onceToken_MicroLocation_Default != -1)
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_7);
  return (id)logObject_MicroLocation_Default;
}

{
  if (onceToken_MicroLocation_Default != -1)
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_9);
  return (id)logObject_MicroLocation_Default;
}

{
  if (onceToken_MicroLocation_Default != -1)
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_10);
  return (id)logObject_MicroLocation_Default;
}

{
  if (onceToken_MicroLocation_Default != -1)
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_12);
  return (id)logObject_MicroLocation_Default;
}

{
  if (onceToken_MicroLocation_Default != -1)
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_18);
  return (id)logObject_MicroLocation_Default;
}

{
  if (onceToken_MicroLocation_Default != -1)
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_21);
  return (id)logObject_MicroLocation_Default;
}

{
  if (onceToken_MicroLocation_Default != -1)
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_24);
  return (id)logObject_MicroLocation_Default;
}

{
  if (onceToken_MicroLocation_Default != -1)
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_26);
  return (id)logObject_MicroLocation_Default;
}

{
  if (onceToken_MicroLocation_Default != -1)
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_330);
  return (id)logObject_MicroLocation_Default;
}

{
  if (onceToken_MicroLocation_Default != -1)
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_31);
  return (id)logObject_MicroLocation_Default;
}

{
  if (onceToken_MicroLocation_Default != -1)
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_16);
  return (id)logObject_MicroLocation_Default;
}

{
  if (onceToken_MicroLocation_Default != -1)
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_39);
  return (id)logObject_MicroLocation_Default;
}

{
  if (onceToken_MicroLocation_Default != -1)
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_41);
  return (id)logObject_MicroLocation_Default;
}

{
  if (onceToken_MicroLocation_Default != -1)
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_45);
  return (id)logObject_MicroLocation_Default;
}

{
  if (onceToken_MicroLocation_Default != -1)
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_46);
  return (id)logObject_MicroLocation_Default;
}

{
  if (onceToken_MicroLocation_Default != -1)
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_48);
  return (id)logObject_MicroLocation_Default;
}

{
  if (onceToken_MicroLocation_Default != -1)
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_55);
  return (id)logObject_MicroLocation_Default;
}

{
  if (onceToken_MicroLocation_Default != -1)
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_58);
  return (id)logObject_MicroLocation_Default;
}

{
  if (onceToken_MicroLocation_Default != -1)
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_60);
  return (id)logObject_MicroLocation_Default;
}

{
  if (onceToken_MicroLocation_Default != -1)
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_61);
  return (id)logObject_MicroLocation_Default;
}

{
  if (onceToken_MicroLocation_Default != -1)
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_62);
  return (id)logObject_MicroLocation_Default;
}

{
  if (onceToken_MicroLocation_Default != -1)
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_66);
  return (id)logObject_MicroLocation_Default;
}

{
  if (onceToken_MicroLocation_Default != -1)
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_69);
  return (id)logObject_MicroLocation_Default;
}

{
  if (onceToken_MicroLocation_Default != -1)
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_73);
  return (id)logObject_MicroLocation_Default;
}

{
  if (onceToken_MicroLocation_Default != -1)
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_75);
  return (id)logObject_MicroLocation_Default;
}

{
  if (onceToken_MicroLocation_Default != -1)
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_97);
  return (id)logObject_MicroLocation_Default;
}

{
  if (onceToken_MicroLocation_Default != -1)
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_99);
  return (id)logObject_MicroLocation_Default;
}

{
  if (onceToken_MicroLocation_Default != -1)
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_101);
  return (id)logObject_MicroLocation_Default;
}

{
  if (onceToken_MicroLocation_Default != -1)
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_104);
  return (id)logObject_MicroLocation_Default;
}

{
  if (onceToken_MicroLocation_Default != -1)
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_105);
  return (id)logObject_MicroLocation_Default;
}

{
  if (onceToken_MicroLocation_Default != -1)
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_106);
  return (id)logObject_MicroLocation_Default;
}

{
  if (onceToken_MicroLocation_Default != -1)
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_107);
  return (id)logObject_MicroLocation_Default;
}

{
  if (onceToken_MicroLocation_Default != -1)
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_110);
  return (id)logObject_MicroLocation_Default;
}

{
  if (onceToken_MicroLocation_Default != -1)
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_608);
  return (id)logObject_MicroLocation_Default;
}

{
  if (onceToken_MicroLocation_Default != -1)
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_120);
  return (id)logObject_MicroLocation_Default;
}

uint64_t std::optional<std::vector<CLMicroLocationResultInternal>>::operator=[abi:ne180100]<std::vector<CLMicroLocationResultInternal>,void>(uint64_t a1, __n128 *a2)
{
  if (*(_BYTE *)(a1 + 24))
  {
    std::vector<CLMicroLocationResultInternal>::__move_assign(a1, a2);
  }
  else
  {
    *(_QWORD *)a1 = 0;
    *(_QWORD *)(a1 + 8) = 0;
    *(_QWORD *)(a1 + 16) = 0;
    *(__n128 *)a1 = *a2;
    *(_QWORD *)(a1 + 16) = a2[1].n128_u64[0];
    a2->n128_u64[0] = 0;
    a2->n128_u64[1] = 0;
    a2[1].n128_u64[0] = 0;
    *(_BYTE *)(a1 + 24) = 1;
  }
  return a1;
}

void CLMicroLocationAlgorithms::LocalizerResults::~LocalizerResults(CLMicroLocationAlgorithms::LocalizerResults *this)
{
  void *v2;
  void *v3;
  void *v4;

  if (*((_BYTE *)this + 80))
  {
    v2 = (void *)*((_QWORD *)this + 7);
    if (v2)
    {
      *((_QWORD *)this + 8) = v2;
      operator delete(v2);
    }
  }
  v3 = (void *)*((_QWORD *)this + 4);
  if (v3)
  {
    *((_QWORD *)this + 5) = v3;
    operator delete(v3);
  }
  v4 = *(void **)this;
  if (*(_QWORD *)this)
  {
    *((_QWORD *)this + 1) = v4;
    operator delete(v4);
  }
}

void CLMicroLocationLocalizationSettings::~CLMicroLocationLocalizationSettings(id *this)
{

  std::__tree<std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>,std::__map_value_compare<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>,std::less<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes>,true>,std::allocator<std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>>>::destroy((uint64_t)this, this[1]);
}

void CLMicroLocationCosineSimilarityLocalizationAlgorithm::~CLMicroLocationCosineSimilarityLocalizationAlgorithm(CLMicroLocationCosineSimilarityLocalizationAlgorithm *this)
{
  JUMPOUT(0x2426A04D4);
}

void ___ZL45_CLLogObjectForCategory_MicroLocation_Defaultv_block_invoke()
{
  os_log_t v0;
  void *v1;

  v0 = os_log_create("com.apple.MicroLocation", "MicroLocation");
  v1 = (void *)logObject_MicroLocation_Default;
  logObject_MicroLocation_Default = (uint64_t)v0;

}

_BYTE *boost::uuids::to_chars<char *>(uint64_t a1, _BYTE *a2)
{
  unint64_t i;
  _BYTE *v3;
  char v4;
  unsigned int v5;
  char v6;

  for (i = 0; i != 16; ++i)
  {
    v3 = a2;
    if (*(unsigned __int8 *)(a1 + i) >= 0xA0u)
      v4 = 87;
    else
      v4 = 48;
    *a2 = v4 + (*(_BYTE *)(a1 + i) >> 4);
    a2 += 2;
    v5 = *(_BYTE *)(a1 + i) & 0xF;
    if (v5 >= 0xA)
      v6 = 87;
    else
      v6 = 48;
    v3[1] = v6 + v5;
    if (i <= 9 && ((1 << i) & 0x2A8) != 0)
    {
      a2 = v3 + 3;
      v3[2] = 45;
    }
  }
  return a2;
}

void std::string::__throw_length_error[abi:ne180100]()
{
  std::__throw_length_error[abi:ne180100]("basic_string");
}

void std::__throw_length_error[abi:ne180100](const char *a1)
{
  std::logic_error *exception;

  exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
  std::length_error::length_error[abi:ne180100](exception, a1);
  __cxa_throw(exception, (struct type_info *)off_2511D18F0, MEMORY[0x24BEDAAF0]);
}

void sub_2419E083C(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

std::logic_error *std::length_error::length_error[abi:ne180100](std::logic_error *a1, const char *a2)
{
  std::logic_error *result;

  result = std::logic_error::logic_error(a1, a2);
  result->__vftable = (std::logic_error_vtbl *)(MEMORY[0x24BEDB8B8] + 16);
  return result;
}

void std::__throw_bad_array_new_length[abi:ne180100]()
{
  std::bad_array_new_length *exception;
  std::bad_array_new_length *v1;

  exception = (std::bad_array_new_length *)__cxa_allocate_exception(8uLL);
  v1 = std::bad_array_new_length::bad_array_new_length(exception);
  __cxa_throw(v1, MEMORY[0x24BEDB748], MEMORY[0x24BEDABB8]);
}

void std::__tree<std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>,std::__map_value_compare<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>,std::less<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes>,true>,std::allocator<std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>>>::destroy(uint64_t a1, _QWORD *a2)
{
  if (a2)
  {
    std::__tree<std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>,std::__map_value_compare<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>,std::less<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes>,true>,std::allocator<std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>>>::destroy(a1, *a2);
    std::__tree<std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>,std::__map_value_compare<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>,std::less<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes>,true>,std::allocator<std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>>>::destroy(a1, a2[1]);
    operator delete(a2);
  }
}

_QWORD *std::string::basic_string[abi:ne180100]<0>(_QWORD *a1, char *__s)
{
  size_t v4;
  size_t v5;
  void *v6;
  uint64_t v7;
  uint64_t v8;

  v4 = strlen(__s);
  if (v4 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v5 = v4;
  if (v4 >= 0x17)
  {
    v7 = (v4 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v4 | 7) != 0x17)
      v7 = v4 | 7;
    v8 = v7 + 1;
    v6 = operator new(v7 + 1);
    a1[1] = v5;
    a1[2] = v8 | 0x8000000000000000;
    *a1 = v6;
  }
  else
  {
    *((_BYTE *)a1 + 23) = v4;
    v6 = a1;
    if (!v4)
      goto LABEL_9;
  }
  memmove(v6, __s, v5);
LABEL_9:
  *((_BYTE *)v6 + v5) = 0;
  return a1;
}

char *std::vector<CLMicroLocationProto::ConfidenceReason>::__insert_with_size[abi:ne180100]<std::__wrap_iter<CLMicroLocationProto::ConfidenceReason const*>,std::__wrap_iter<CLMicroLocationProto::ConfidenceReason const*>>(uint64_t a1, uint64_t __dst, char *__src, char *a4, uint64_t a5)
{
  char *v5;
  char *v7;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  void *v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  char *v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  int64_t v22;
  char *v23;
  char *v24;
  char *v25;
  char *v26;
  int v27;
  char *v28;
  uint64_t v29;
  char *v30;
  int v31;
  void *__p;
  char *v34;
  char *v35;
  char *v36;
  uint64_t v37;

  v5 = (char *)__dst;
  if (a5 < 1)
    return v5;
  v7 = __src;
  v11 = *(_QWORD *)(a1 + 16);
  v9 = a1 + 16;
  v10 = v11;
  v12 = *(_QWORD *)(v9 - 8);
  if (a5 > (uint64_t)(v11 - v12) >> 2)
  {
    v13 = *(void **)a1;
    v14 = a5 + ((uint64_t)(v12 - *(_QWORD *)a1) >> 2);
    if (v14 >> 62)
      std::vector<CLMicroLocationProto::ConfidenceReason>::__throw_length_error[abi:ne180100]();
    v15 = (__dst - (uint64_t)v13) >> 2;
    v16 = v10 - (_QWORD)v13;
    if (v16 >> 1 > v14)
      v14 = v16 >> 1;
    if ((unint64_t)v16 >= 0x7FFFFFFFFFFFFFFCLL)
      v17 = 0x3FFFFFFFFFFFFFFFLL;
    else
      v17 = v14;
    v37 = v9;
    if (v17)
      v18 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<CLMicroLocationProto::ConfidenceReason>>(v9, v17);
    else
      v18 = 0;
    v28 = &v18[4 * v15];
    __p = v18;
    v34 = v28;
    v36 = &v18[4 * v17];
    v29 = 4 * a5;
    v30 = &v28[4 * a5];
    do
    {
      v31 = *(_DWORD *)v7;
      v7 += 4;
      *(_DWORD *)v28 = v31;
      v28 += 4;
      v29 -= 4;
    }
    while (v29);
    v35 = v30;
    v5 = std::vector<CLMicroLocationProto::ConfidenceReason>::__swap_out_circular_buffer((void **)a1, (uint64_t)&__p, v5);
    if (v35 != v34)
      v35 += (v34 - v35 + 3) & 0xFFFFFFFFFFFFFFFCLL;
    if (__p)
      operator delete(__p);
    return v5;
  }
  v19 = v12 - __dst;
  v20 = (uint64_t)(v12 - __dst) >> 2;
  if (v20 >= a5)
  {
    v21 = &__src[4 * a5];
    v23 = *(char **)(v9 - 8);
LABEL_17:
    v24 = &v5[4 * a5];
    v25 = &v23[-4 * a5];
    v26 = v23;
    if ((unint64_t)v25 < v12)
    {
      v26 = v23;
      do
      {
        v27 = *(_DWORD *)v25;
        v25 += 4;
        *(_DWORD *)v26 = v27;
        v26 += 4;
      }
      while ((unint64_t)v25 < v12);
    }
    *(_QWORD *)(a1 + 8) = v26;
    if (v23 != v24)
      memmove(&v23[-4 * ((v23 - v24) >> 2)], v5, v23 - v24);
    if (v21 != v7)
      memmove(v5, v7, v21 - v7);
    return v5;
  }
  v21 = &__src[4 * v20];
  v22 = a4 - v21;
  if (a4 != v21)
    memmove(*(void **)(v9 - 8), &__src[4 * v20], a4 - v21);
  v23 = (char *)(v12 + v22);
  *(_QWORD *)(a1 + 8) = v12 + v22;
  if (v19 >= 1)
    goto LABEL_17;
  return v5;
}

void sub_2419E0B60(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

char *std::vector<CLMicroLocationProto::ConfidenceReason>::__swap_out_circular_buffer(void **a1, uint64_t a2, char *__src)
{
  char *v5;
  char *v6;
  char *v7;
  char *v8;
  int v9;
  _BYTE *v10;
  uint64_t v11;
  int64_t v12;
  char *v13;
  void *v14;
  void *v15;

  v5 = *(char **)(a2 + 8);
  v6 = (char *)*a1;
  v7 = v5;
  if (*a1 != __src)
  {
    v8 = __src;
    v7 = *(char **)(a2 + 8);
    do
    {
      v9 = *((_DWORD *)v8 - 1);
      v8 -= 4;
      *((_DWORD *)v7 - 1) = v9;
      v7 -= 4;
    }
    while (v8 != v6);
  }
  *(_QWORD *)(a2 + 8) = v7;
  v10 = a1[1];
  v11 = *(_QWORD *)(a2 + 16);
  v12 = v10 - __src;
  if (v10 != __src)
  {
    memmove(*(void **)(a2 + 16), __src, v10 - __src);
    v7 = *(char **)(a2 + 8);
  }
  *(_QWORD *)(a2 + 16) = v11 + v12;
  v13 = (char *)*a1;
  *a1 = v7;
  *(_QWORD *)(a2 + 8) = v13;
  v14 = a1[1];
  a1[1] = *(void **)(a2 + 16);
  *(_QWORD *)(a2 + 16) = v14;
  v15 = a1[2];
  a1[2] = *(void **)(a2 + 24);
  *(_QWORD *)(a2 + 24) = v15;
  *(_QWORD *)a2 = *(_QWORD *)(a2 + 8);
  return v5;
}

void std::vector<CLMicroLocationProto::ConfidenceReason>::__throw_length_error[abi:ne180100]()
{
  std::__throw_length_error[abi:ne180100]("vector");
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<CLMicroLocationProto::ConfidenceReason>>(uint64_t a1, unint64_t a2)
{
  if (a2 >> 62)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(4 * a2);
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<CLMicroLocationResultInternal>>(uint64_t a1, unint64_t a2)
{
  if (a2 >> 59)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(32 * a2);
}

__n128 std::vector<CLMicroLocationResultInternal>::__move_assign(uint64_t a1, __n128 *a2)
{
  void *v4;
  __n128 result;

  v4 = *(void **)a1;
  if (v4)
  {
    *(_QWORD *)(a1 + 8) = v4;
    operator delete(v4);
    *(_QWORD *)a1 = 0;
    *(_QWORD *)(a1 + 8) = 0;
    *(_QWORD *)(a1 + 16) = 0;
  }
  result = *a2;
  *(__n128 *)a1 = *a2;
  *(_QWORD *)(a1 + 16) = a2[1].n128_u64[0];
  a2->n128_u64[0] = 0;
  a2->n128_u64[1] = 0;
  a2[1].n128_u64[0] = 0;
  return result;
}

void sub_2419E0DBC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_2419E0E8C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_2419E0F5C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_2419E1014(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;
  void *v11;
  void *v12;

  v12 = v11;

  _Unwind_Resume(a1);
}

void sub_2419E10F0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;
  void *v11;

  _Unwind_Resume(a1);
}

void sub_2419E1158(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_2419E11F0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_2419E12B8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

void sub_2419E137C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_2419E1490(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

void sub_2419E15DC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

void sub_2419E1728(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

void sub_2419E1884(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;
  void *v11;

  _Unwind_Resume(a1);
}

void sub_2419E19F0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;
  void *v11;

  _Unwind_Resume(a1);
}

void std::vector<CLMiLoOdometryTable::Entry>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v1;
  id *v2;
  id *v4;
  void *v5;
  id *v6;

  v1 = *a1;
  v2 = (id *)**a1;
  if (v2)
  {
    v4 = (id *)v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v6 = v4 - 4;

        v4 = v6;
      }
      while (v6 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

char *std::vector<CLMiLoOdometryTable::Entry>::__init_with_size[abi:ne180100]<CLMiLoOdometryTable::Entry*,CLMiLoOdometryTable::Entry*>(char *result, __int128 *a2, __int128 *a3, unint64_t a4)
{
  char *v6;
  uint64_t v7;
  __int128 v8;

  if (a4)
  {
    v6 = result;
    result = std::vector<CLMiLoOdometryTable::Entry>::__vallocate[abi:ne180100](result, a4);
    v7 = *((_QWORD *)v6 + 1);
    while (a2 != a3)
    {
      v8 = *a2;
      *(_QWORD *)(v7 + 16) = *((_QWORD *)a2 + 2);
      *(_OWORD *)v7 = v8;
      result = (char *)*((id *)a2 + 3);
      *(_QWORD *)(v7 + 24) = result;
      v7 += 32;
      a2 += 2;
    }
    *((_QWORD *)v6 + 1) = v7;
  }
  return result;
}

void sub_2419E1C2C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  std::vector<CLMiLoOdometryTable::Entry>::__destroy_vector::operator()[abi:ne180100](&a9);
  _Unwind_Resume(a1);
}

char *std::vector<CLMiLoOdometryTable::Entry>::__vallocate[abi:ne180100](_QWORD *a1, unint64_t a2)
{
  char *result;
  uint64_t v4;

  if (a2 >> 59)
    std::vector<CLMicroLocationProto::ConfidenceReason>::__throw_length_error[abi:ne180100]();
  result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<CLMicroLocationResultInternal>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[32 * v4];
  return result;
}

id _CLLogObjectForCategory_MicroLocation_Default()
{
  if (onceToken_MicroLocation_Default != -1)
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_23);
  return (id)logObject_MicroLocation_Default;
}

void OUTLINED_FUNCTION_1(void *a1, int a2, int a3, int a4, const char *a5, const char *a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint8_t buf)
{
  NSObject *v13;

  _os_signpost_emit_with_name_impl(a1, v13, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, a5, a6, &buf, 0x26u);
}

void OUTLINED_FUNCTION_2(void *a1, int a2, int a3, const char *a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint8_t buf)
{
  NSObject *v13;

  _os_log_impl(a1, v13, OS_LOG_TYPE_INFO, a4, &buf, 0x26u);
}

void OUTLINED_FUNCTION_3(void *a1, int a2, int a3, const char *a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint8_t buf)
{
  NSObject *v13;

  _os_log_impl(a1, v13, OS_LOG_TYPE_FAULT, a4, &buf, 0x26u);
}

BOOL OUTLINED_FUNCTION_4(NSObject *a1)
{
  return os_log_type_enabled(a1, OS_LOG_TYPE_INFO);
}

BOOL OUTLINED_FUNCTION_5(NSObject *a1)
{
  return os_log_type_enabled(a1, OS_LOG_TYPE_FAULT);
}

uint64_t ULHomeNearbyRangingSupport::isUwbRangingSupportedOnDevice(ULHomeNearbyRangingSupport *this)
{
  void *v1;
  int v2;
  CLHomeNearbyObjectInternal *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  uint64_t v8;
  uint64_t v10;

  +[CLMicroLocationEnvironment shared](CLMicroLocationEnvironment, "shared");
  v1 = (void *)objc_claimAutoreleasedReturnValue();
  v2 = objc_msgSend(v1, "isTestingEnvironment");

  if (!v2)
    return CLHomeNearbyObjectInternal::isNearbyObjectUwbRangingSupportedOnDevice(v3);
  +[ULDefaultsSingleton shared](ULDefaultsSingleton, "shared");
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v4, "defaultsDictionary");
  v5 = (void *)objc_claimAutoreleasedReturnValue();

  objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "ULMeasurementProcessingUwbRangeEnable");
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v5, "objectForKey:", v6);
  v7 = (void *)objc_claimAutoreleasedReturnValue();
  if (v7 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
    v8 = objc_msgSend(v7, "BOOLValue");
  else
    v8 = objc_msgSend(MEMORY[0x24BDBD1C8], "BOOLValue");
  v10 = v8;

  return v10;
}

void sub_2419E20A0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_2419E2440(_Unwind_Exception *a1)
{
  id *v1;
  uint64_t v2;

  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v2 - 40));
  _Unwind_Resume(a1);
}

void sub_2419E2A20(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
  id *v14;

  objc_destroyWeak(v14);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_2419E34CC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

uint64_t ULDBUtils::insertEntries<CLMicroLocationRecordingLabelsTable,ULLabelMO>(void *a1, uint64_t a2)
{
  id v3;
  void *v4;
  id v5;
  uint64_t v6;
  _QWORD v8[4];
  id v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  char v15;

  v3 = a1;
  v12 = 0;
  v13 = &v12;
  v14 = 0x2020000000;
  v15 = 0;
  objc_msgSend(v3, "managedObjectContext");
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  v8[0] = MEMORY[0x24BDAC760];
  v8[1] = 3221225472;
  v8[2] = ___ZN9ULDBUtils13insertEntriesI35CLMicroLocationRecordingLabelsTable9ULLabelMOEEbP7ULStoreRKNSt3__16vectorINT_5EntryENS5_9allocatorIS8_EEEE_block_invoke;
  v8[3] = &unk_2511D22D0;
  v11 = a2;
  v5 = v3;
  v9 = v5;
  v10 = &v12;
  objc_msgSend(v4, "performBlockAndWait:", v8);

  v6 = *((unsigned __int8 *)v13 + 24);
  _Block_object_dispose(&v12, 8);

  return v6;
}

void sub_2419E35F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, void *a7, uint64_t a8, uint64_t a9, ...)
{
  void *v9;
  void *v10;
  va_list va;

  va_start(va, a9);

  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void ULDBUtils::fetchEntries<CLMicroLocationRecordingLabelsTable,ULLabelMO>(void *a1@<X0>, void *a2@<X1>, void *a3@<X2>, uint64_t a4@<X3>, _QWORD *a5@<X8>)
{
  id v9;
  id v10;
  id v11;
  void *v12;
  id v13;
  id v14;
  id v15;
  uint64_t *v16;
  _QWORD v17[4];
  id v18;
  id v19;
  id v20;
  uint64_t *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t *v24;
  uint64_t v25;
  __n128 (*v26)(__n128 *, __n128 *);
  void (*v27)(uint64_t);
  void *v28;
  _QWORD v29[3];
  void **v30;

  v9 = a1;
  v10 = a2;
  v11 = a3;
  v23 = 0;
  v24 = &v23;
  v25 = 0x4812000000;
  v26 = __Block_byref_object_copy_;
  v27 = __Block_byref_object_dispose_;
  v28 = &unk_241BEBD1D;
  memset(v29, 0, sizeof(v29));
  objc_msgSend(v9, "managedObjectContext");
  v12 = (void *)objc_claimAutoreleasedReturnValue();
  v17[0] = MEMORY[0x24BDAC760];
  v17[1] = 3221225472;
  v17[2] = ___ZN9ULDBUtils12fetchEntriesI35CLMicroLocationRecordingLabelsTable9ULLabelMOEENSt3__16vectorINT_5EntryENS3_9allocatorIS6_EEEEP7ULStoreP7NSArrayIP11NSPredicateEPSC_IP16NSSortDescriptorEm_block_invoke;
  v17[3] = &unk_2511D22F8;
  v13 = v10;
  v18 = v13;
  v14 = v11;
  v19 = v14;
  v22 = a4;
  v15 = v9;
  v20 = v15;
  v21 = &v23;
  objc_msgSend(v12, "performBlockAndWait:", v17);

  v16 = v24;
  a5[1] = 0;
  a5[2] = 0;
  *a5 = 0;
  std::vector<CLMicroLocationRecordingLabelsTable::Entry>::__init_with_size[abi:ne180100]<CLMicroLocationRecordingLabelsTable::Entry*,CLMicroLocationRecordingLabelsTable::Entry*>(a5, (__int128 *)v16[6], (__int128 *)v16[7], (v16[7] - v16[6]) >> 6);

  _Block_object_dispose(&v23, 8);
  v30 = (void **)v29;
  std::vector<CLMicroLocationRecordingLabelsTable::Entry>::__destroy_vector::operator()[abi:ne180100](&v30);

}

void sub_2419E37A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, void *a6, void *a7, void *a8, uint64_t a9, uint64_t a10, ...)
{
  void *v10;
  void *v11;
  void *v12;
  uint64_t v13;
  uint64_t v14;
  va_list va;

  va_start(va, a10);

  _Block_object_dispose(va, 8);
  *(_QWORD *)(v14 - 96) = v13;
  std::vector<CLMicroLocationRecordingLabelsTable::Entry>::__destroy_vector::operator()[abi:ne180100]((void ***)(v14 - 96));

  _Unwind_Resume(a1);
}

void ULDBUtils::fetchAllWithLimit<CLMicroLocationRecordingLabelsTable,ULLabelMO>(void *a1@<X0>, unsigned int a2@<W1>, _QWORD *a3@<X8>)
{
  id v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;
  _QWORD v10[2];

  v10[1] = *MEMORY[0x24BDAC8D0];
  v5 = a1;
  v6 = (void *)MEMORY[0x24BDD17C0];
  objc_msgSend((id)objc_opt_class(), "defaultSortProperty");
  v7 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v6, "sortDescriptorWithKey:ascending:", v7, 0);
  v8 = (void *)objc_claimAutoreleasedReturnValue();

  v10[0] = v8;
  objc_msgSend(MEMORY[0x24BDBCE30], "arrayWithObjects:count:", v10, 1);
  v9 = (void *)objc_claimAutoreleasedReturnValue();
  ULDBUtils::fetchEntries<CLMicroLocationRecordingLabelsTable,ULLabelMO>(v5, 0, v9, a2, a3);

}

void sub_2419E3904(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_2419E3AA0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_2419E3C18(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_2419E3D98(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

uint64_t ULSettings::get<ULSettings::DatabaseSelectionLimit>()
{
  void *v0;
  void *v1;
  void *v2;
  void *v3;
  uint64_t v4;
  uint64_t v5;

  +[ULDefaultsSingleton shared](ULDefaultsSingleton, "shared");
  v0 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v0, "defaultsDictionary");
  v1 = (void *)objc_claimAutoreleasedReturnValue();

  objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "ULDatabaseSelectionLimit");
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v1, "objectForKey:", v2);
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  if (v3 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
    v4 = objc_msgSend(v3, "unsignedIntValue");
  else
    v4 = objc_msgSend(&unk_2511ED138, "unsignedIntValue");
  v5 = v4;

  return v5;
}

{
  void *v0;
  void *v1;
  void *v2;
  void *v3;
  uint64_t v4;
  uint64_t v5;

  +[ULDefaultsSingleton shared](ULDefaultsSingleton, "shared");
  v0 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v0, "defaultsDictionary");
  v1 = (void *)objc_claimAutoreleasedReturnValue();

  objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "ULDatabaseSelectionLimit");
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v1, "objectForKey:", v2);
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  if (v3 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
    v4 = objc_msgSend(v3, "unsignedIntValue");
  else
    v4 = objc_msgSend(&unk_2511ED480, "unsignedIntValue");
  v5 = v4;

  return v5;
}

{
  void *v0;
  void *v1;
  void *v2;
  void *v3;
  uint64_t v4;
  uint64_t v5;

  +[ULDefaultsSingleton shared](ULDefaultsSingleton, "shared");
  v0 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v0, "defaultsDictionary");
  v1 = (void *)objc_claimAutoreleasedReturnValue();

  objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "ULDatabaseSelectionLimit");
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v1, "objectForKey:", v2);
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  if (v3 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
    v4 = objc_msgSend(v3, "unsignedIntValue");
  else
    v4 = objc_msgSend(&unk_2511ED888, "unsignedIntValue");
  v5 = v4;

  return v5;
}

{
  void *v0;
  void *v1;
  void *v2;
  void *v3;
  uint64_t v4;
  uint64_t v5;

  +[ULDefaultsSingleton shared](ULDefaultsSingleton, "shared");
  v0 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v0, "defaultsDictionary");
  v1 = (void *)objc_claimAutoreleasedReturnValue();

  objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "ULDatabaseSelectionLimit");
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v1, "objectForKey:", v2);
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  if (v3 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
    v4 = objc_msgSend(v3, "unsignedIntValue");
  else
    v4 = objc_msgSend(&unk_2511ED8E8, "unsignedIntValue");
  v5 = v4;

  return v5;
}

{
  void *v0;
  void *v1;
  void *v2;
  void *v3;
  uint64_t v4;
  uint64_t v5;

  +[ULDefaultsSingleton shared](ULDefaultsSingleton, "shared");
  v0 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v0, "defaultsDictionary");
  v1 = (void *)objc_claimAutoreleasedReturnValue();

  objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "ULDatabaseSelectionLimit");
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v1, "objectForKey:", v2);
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  if (v3 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
    v4 = objc_msgSend(v3, "unsignedIntValue");
  else
    v4 = objc_msgSend(&unk_2511EDE40, "unsignedIntValue");
  v5 = v4;

  return v5;
}

{
  void *v0;
  void *v1;
  void *v2;
  void *v3;
  uint64_t v4;
  uint64_t v5;

  +[ULDefaultsSingleton shared](ULDefaultsSingleton, "shared");
  v0 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v0, "defaultsDictionary");
  v1 = (void *)objc_claimAutoreleasedReturnValue();

  objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "ULDatabaseSelectionLimit");
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v1, "objectForKey:", v2);
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  if (v3 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
    v4 = objc_msgSend(v3, "unsignedIntValue");
  else
    v4 = objc_msgSend(&unk_2511EE080, "unsignedIntValue");
  v5 = v4;

  return v5;
}

{
  void *v0;
  void *v1;
  void *v2;
  void *v3;
  uint64_t v4;
  uint64_t v5;

  +[ULDefaultsSingleton shared](ULDefaultsSingleton, "shared");
  v0 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v0, "defaultsDictionary");
  v1 = (void *)objc_claimAutoreleasedReturnValue();

  objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "ULDatabaseSelectionLimit");
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v1, "objectForKey:", v2);
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  if (v3 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
    v4 = objc_msgSend(v3, "unsignedIntValue");
  else
    v4 = objc_msgSend(&unk_2511EE350, "unsignedIntValue");
  v5 = v4;

  return v5;
}

void sub_2419E3E88(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_2419E400C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_2419E4260(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  _Unwind_Resume(a1);
}

void sub_2419E44D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, ...)
{
  void *v12;
  void *v13;
  void *v14;
  va_list va;

  va_start(va, a12);

  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)va);
  _Unwind_Resume(a1);
}

void std::vector<std::string>::reserve(std::vector<std::string> *this, std::vector<std::string>::size_type __n)
{
  std::__compressed_pair<std::string *> *p_end_cap;
  std::string *value;
  int64_t v5;
  uint64_t v6;
  std::__split_buffer<std::string> __v;

  value = this->__end_cap_.__value_;
  p_end_cap = &this->__end_cap_;
  if (0xAAAAAAAAAAAAAAABLL * (((char *)value - (char *)this->__begin_) >> 3) < __n)
  {
    if (__n >= 0xAAAAAAAAAAAAAABLL)
      std::vector<CLMicroLocationProto::ConfidenceReason>::__throw_length_error[abi:ne180100]();
    v5 = (char *)this->__end_ - (char *)this->__begin_;
    __v.__end_cap_.__value_ = (std::allocator<std::string> *)p_end_cap;
    __v.__first_ = (std::__split_buffer<std::string>::pointer)std::__allocate_at_least[abi:ne180100]<std::allocator<std::string>>((uint64_t)p_end_cap, __n);
    __v.__begin_ = (std::__split_buffer<std::string>::pointer)((char *)__v.__first_ + v5);
    __v.__end_ = (std::__split_buffer<std::string>::pointer)((char *)__v.__first_ + v5);
    __v.__end_cap_.__value_ = &__v.__first_[v6];
    std::vector<std::string>::__swap_out_circular_buffer(this, &__v);
    std::__split_buffer<std::string>::~__split_buffer(&__v);
  }
}

void sub_2419E45DC(_Unwind_Exception *a1, std::__split_buffer<std::string> *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  std::__split_buffer<std::string>::~__split_buffer((std::__split_buffer<std::string> *)&a10);
  _Unwind_Resume(a1);
}

void sub_2419E4738(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  _Unwind_Resume(a1);
}

void sub_2419E48D0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  _Unwind_Resume(a1);
}

void ___ZL45_CLLogObjectForCategory_MicroLocation_Defaultv_block_invoke_0()
{
  os_log_t v0;
  void *v1;

  v0 = os_log_create("com.apple.MicroLocation", "MicroLocation");
  v1 = (void *)logObject_MicroLocation_Default;
  logObject_MicroLocation_Default = (uint64_t)v0;

}

void __clang_call_terminate(void *a1)
{
  __cxa_begin_catch(a1);
  std::terminate();
}

void std::vector<std::string>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v2;

  v2 = *a1;
  if (*v2)
  {
    std::vector<std::string>::__clear[abi:ne180100]((uint64_t *)v2);
    operator delete(**a1);
  }
}

void std::vector<std::string>::__clear[abi:ne180100](uint64_t *a1)
{
  uint64_t v2;
  uint64_t i;

  v2 = *a1;
  for (i = a1[1]; i != v2; i -= 24)
  {
    if (*(char *)(i - 1) < 0)
      operator delete(*(void **)(i - 24));
  }
  a1[1] = v2;
}

void std::vector<std::string>::__swap_out_circular_buffer(std::vector<std::string> *this, std::__split_buffer<std::string> *__v)
{
  std::string *v4;
  std::string *begin;
  std::string *end;
  std::string *value;

  std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::string>,std::reverse_iterator<std::string*>,std::reverse_iterator<std::string*>,std::reverse_iterator<std::string*>>((uint64_t)&this->__end_cap_, (uint64_t)this->__end_, (uint64_t)this->__end_, (uint64_t)this->__begin_, (uint64_t)this->__begin_, (uint64_t)__v->__begin_, (uint64_t)__v->__begin_);
  __v->__begin_ = v4;
  begin = this->__begin_;
  this->__begin_ = v4;
  __v->__begin_ = begin;
  end = this->__end_;
  this->__end_ = __v->__end_;
  __v->__end_ = end;
  value = this->__end_cap_.__value_;
  this->__end_cap_.__value_ = __v->__end_cap_.__value_;
  __v->__end_cap_.__value_ = value;
  __v->__first_ = __v->__begin_;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<std::string>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0xAAAAAAAAAAAAAABLL)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(24 * a2);
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::string>,std::reverse_iterator<std::string*>,std::reverse_iterator<std::string*>,std::reverse_iterator<std::string*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7;
  uint64_t v9;
  __int128 v10;
  _QWORD v12[3];
  char v13;
  __int128 v14;
  __int128 v15;

  v7 = a7;
  *(_QWORD *)&v15 = a6;
  *((_QWORD *)&v15 + 1) = a7;
  v14 = v15;
  v12[0] = a1;
  v12[1] = &v14;
  v12[2] = &v15;
  if (a3 != a5)
  {
    v9 = a7;
    do
    {
      v10 = *(_OWORD *)(a3 - 24);
      *(_QWORD *)(v9 - 8) = *(_QWORD *)(a3 - 8);
      *(_OWORD *)(v9 - 24) = v10;
      v9 -= 24;
      *(_QWORD *)(a3 - 16) = 0;
      *(_QWORD *)(a3 - 8) = 0;
      *(_QWORD *)(a3 - 24) = 0;
      v7 -= 24;
      a3 -= 24;
    }
    while (a3 != a5);
    *((_QWORD *)&v15 + 1) = v9;
  }
  v13 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::string>,std::reverse_iterator<std::string*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v12);
  return a6;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::string>,std::reverse_iterator<std::string*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24))
    std::_AllocatorDestroyRangeReverse<std::allocator<std::string>,std::reverse_iterator<std::string*>>::operator()[abi:ne180100](a1);
  return a1;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<std::string>,std::reverse_iterator<std::string*>>::operator()[abi:ne180100](uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;

  v1 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 8);
  v2 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8);
  while (v1 != v2)
  {
    if (*(char *)(v1 + 23) < 0)
      operator delete(*(void **)v1);
    v1 += 24;
  }
}

void std::__split_buffer<std::string>::~__split_buffer(std::__split_buffer<std::string> *this)
{
  std::__split_buffer<std::string>::__destruct_at_end[abi:ne180100]((uint64_t)this, (void **)&this->__begin_->__r_.__value_.__l.__data_);
  if (this->__first_)
    operator delete(this->__first_);
}

void std::__split_buffer<std::string>::__destruct_at_end[abi:ne180100](uint64_t a1, void **a2)
{
  void **v2;
  void **v5;

  v2 = *(void ***)(a1 + 16);
  if (v2 != a2)
  {
    do
    {
      v5 = v2 - 3;
      *(_QWORD *)(a1 + 16) = v2 - 3;
      if (*((char *)v2 - 1) < 0)
      {
        operator delete(*v5);
        v5 = *(void ***)(a1 + 16);
      }
      v2 = v5;
    }
    while (v5 != a2);
  }
}

void ___ZN9ULDBUtils13insertEntriesI35CLMicroLocationRecordingLabelsTable9ULLabelMOEEbP7ULStoreRKNSt3__16vectorINT_5EntryENS5_9allocatorIS8_EEEE_block_invoke(uint64_t a1)
{
  uint64_t *v2;
  uint64_t v3;
  uint64_t v4;
  void *v5;
  void *v6;
  NSObject *v7;
  void *v8;
  void *v9;
  NSObject *v10;
  void *v11;
  void *v12;
  void *v13;
  int v14;
  int v15;
  __int16 v16;
  const char *v17;
  __int16 v18;
  void *v19;
  uint64_t v20;

  v20 = *MEMORY[0x24BDAC8D0];
  v2 = *(uint64_t **)(a1 + 48);
  v3 = *v2;
  v4 = v2[1];
  if (*v2 == v4)
  {
LABEL_4:
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = objc_msgSend(*(id *)(a1 + 32), "commitChangesToStore");
    objc_msgSend(*(id *)(a1 + 32), "deleteOldestRecordsIfFull");
  }
  else
  {
    while (1)
    {
      objc_msgSend(*(id *)(a1 + 32), "managedObjectContext");
      v5 = (void *)objc_claimAutoreleasedReturnValue();
      +[ULLabelMO createFromEntry:inManagedObjectContext:](ULLabelMO, "createFromEntry:inManagedObjectContext:", v3, v5);
      v6 = (void *)objc_claimAutoreleasedReturnValue();

      if (!v6)
        break;

      v3 += 64;
      if (v3 == v4)
        goto LABEL_4;
    }
    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_2);
    v7 = (id)logObject_MicroLocation_Default;
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      +[ULLabelMO entity](ULLabelMO, "entity");
      v8 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v8, "name");
      v9 = (void *)objc_claimAutoreleasedReturnValue();
      v14 = 68289283;
      v15 = 0;
      v16 = 2082;
      v17 = "";
      v18 = 2113;
      v19 = v9;
      _os_log_impl(&dword_2419D9000, v7, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"Failed to create entry from MO\", \"MO\":%{private, location:escape_only}@}", (uint8_t *)&v14, 0x1Cu);

    }
    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_2);
    v10 = (id)logObject_MicroLocation_Default;
    if (os_signpost_enabled(v10))
    {
      +[ULLabelMO entity](ULLabelMO, "entity");
      v11 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v11, "name");
      v12 = (void *)objc_claimAutoreleasedReturnValue();
      v14 = 68289283;
      v15 = 0;
      v16 = 2082;
      v17 = "";
      v18 = 2113;
      v19 = v12;
      _os_signpost_emit_with_name_impl(&dword_2419D9000, v10, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Failed to create entry from MO", "{\"msg%{public}.0s\":\"Failed to create entry from MO\", \"MO\":%{private, location:escape_only}@}", (uint8_t *)&v14, 0x1Cu);

    }
    objc_msgSend(*(id *)(a1 + 32), "managedObjectContext");
    v13 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v13, "reset");

  }
}

void sub_2419E4EE4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

__n128 __Block_byref_object_copy_(__n128 *a1, __n128 *a2)
{
  __n128 result;

  a1[3].n128_u64[0] = 0;
  a1[3].n128_u64[1] = 0;
  a1[4].n128_u64[0] = 0;
  result = a2[3];
  a1[3] = result;
  a1[4].n128_u64[0] = a2[4].n128_u64[0];
  a2[3].n128_u64[0] = 0;
  a2[3].n128_u64[1] = 0;
  a2[4].n128_u64[0] = 0;
  return result;
}

void __Block_byref_object_dispose_(uint64_t a1)
{
  void **v1;

  v1 = (void **)(a1 + 48);
  std::vector<CLMicroLocationRecordingLabelsTable::Entry>::__destroy_vector::operator()[abi:ne180100](&v1);
}

void ___ZN9ULDBUtils12fetchEntriesI35CLMicroLocationRecordingLabelsTable9ULLabelMOEENSt3__16vectorINT_5EntryENS3_9allocatorIS6_EEEEP7ULStoreP7NSArrayIP11NSPredicateEPSC_IP16NSSortDescriptorEm_block_invoke(uint64_t a1)
{
  void *v2;
  objc_class *v3;
  void *v4;
  void *v5;
  uint64_t v6;
  void *v7;
  __int128 v8;
  uint64_t v9;
  void **v10;

  v2 = *(void **)(a1 + 48);
  v3 = (objc_class *)objc_opt_class();
  NSStringFromClass(v3);
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v2, "fetchManagedObjectsWithEntityName:byAndPredicates:sortDescriptors:andLimit:", v4, *(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 64));
  v5 = (void *)objc_claimAutoreleasedReturnValue();

  ULDBUtils::convertManagedObjectsToEntries<CLMicroLocationRecordingLabelsTable,ULLabelMO>(v5, (uint64_t *)&v8);
  v6 = *(_QWORD *)(*(_QWORD *)(a1 + 56) + 8);
  std::vector<CLMicroLocationRecordingLabelsTable::Entry>::__vdeallocate((uint64_t *)(v6 + 48));
  *(_OWORD *)(v6 + 48) = v8;
  *(_QWORD *)(v6 + 64) = v9;
  v9 = 0;
  v8 = 0uLL;
  v10 = (void **)&v8;
  std::vector<CLMicroLocationRecordingLabelsTable::Entry>::__destroy_vector::operator()[abi:ne180100](&v10);
  objc_msgSend(*(id *)(a1 + 48), "managedObjectContext");
  v7 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v7, "reset");

}

void sub_2419E504C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void ULDBUtils::convertManagedObjectsToEntries<CLMicroLocationRecordingLabelsTable,ULLabelMO>(void *a1@<X0>, uint64_t *a2@<X8>)
{
  id v3;
  id v4;
  uint64_t v5;
  char v6;
  uint64_t v7;
  uint64_t v8;
  id v9;
  void *v10;
  char v11;
  NSObject *v12;
  void *v13;
  void *v14;
  NSObject *v15;
  void *v16;
  void *v17;
  id v18;
  uint64_t *v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  uint8_t buf[4];
  int v25;
  __int16 v26;
  const char *v27;
  __int16 v28;
  void *v29;
  __int128 v30;
  void *__p[2];
  __int128 v32;
  __int128 v33;
  uint64_t v34;
  _BYTE v35[128];
  uint64_t v36;

  v36 = *MEMORY[0x24BDAC8D0];
  v3 = a1;
  a2[1] = 0;
  a2[2] = 0;
  *a2 = 0;
  std::vector<CLMicroLocationRecordingLabelsTable::Entry>::reserve(a2, objc_msgSend(v3, "count"));
  v22 = 0u;
  v23 = 0u;
  v20 = 0u;
  v21 = 0u;
  v4 = v3;
  v5 = objc_msgSend(v4, "countByEnumeratingWithState:objects:count:", &v20, v35, 16);
  if (!v5)
  {

    goto LABEL_28;
  }
  v18 = v3;
  v19 = a2;
  v6 = 0;
  v7 = *(_QWORD *)v21;
  do
  {
    v8 = 0;
    do
    {
      if (*(_QWORD *)v21 != v7)
        objc_enumerationMutation(v4);
      v9 = *(id *)(*((_QWORD *)&v20 + 1) + 8 * v8);
      v10 = v9;
      if (v9)
      {
        objc_msgSend(v9, "convertToEntry", v18);
        if ((_BYTE)v34)
        {
          std::vector<CLMicroLocationRecordingLabelsTable::Entry>::push_back[abi:ne180100](v19, (uint64_t)&v30);
          v11 = 0;
          goto LABEL_19;
        }
      }
      else
      {
        v34 = 0;
        v32 = 0u;
        v33 = 0u;
        v30 = 0u;
        *(_OWORD *)__p = 0u;
      }
      if (onceToken_MicroLocation_Default != -1)
        dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_2);
      v12 = (id)logObject_MicroLocation_Default;
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
      {
        objc_msgSend(v10, "entity");
        v13 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v13, "name");
        v14 = (void *)objc_claimAutoreleasedReturnValue();
        *(_DWORD *)buf = 68289283;
        v25 = 0;
        v26 = 2082;
        v27 = "";
        v28 = 2113;
        v29 = v14;
        _os_log_impl(&dword_2419D9000, v12, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"Failed to convert MO to entry\", \"MO\":%{private, location:escape_only}@}", buf, 0x1Cu);

      }
      if (onceToken_MicroLocation_Default != -1)
        dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_2);
      v15 = (id)logObject_MicroLocation_Default;
      if (os_signpost_enabled(v15))
      {
        objc_msgSend(v10, "entity");
        v16 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v16, "name");
        v17 = (void *)objc_claimAutoreleasedReturnValue();
        *(_DWORD *)buf = 68289283;
        v25 = 0;
        v26 = 2082;
        v27 = "";
        v28 = 2113;
        v29 = v17;
        _os_signpost_emit_with_name_impl(&dword_2419D9000, v15, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Failed to convert MO to entry", "{\"msg%{public}.0s\":\"Failed to convert MO to entry\", \"MO\":%{private, location:escape_only}@}", buf, 0x1Cu);

      }
      v11 = 1;
      v6 = 1;
LABEL_19:
      if ((_BYTE)v34 && SBYTE7(v32) < 0)
        operator delete(__p[0]);

      if ((v11 & 1) != 0)
        goto LABEL_25;
      ++v8;
    }
    while (v5 != v8);
    v5 = objc_msgSend(v4, "countByEnumeratingWithState:objects:count:", &v20, v35, 16);
  }
  while (v5);
LABEL_25:

  if ((v6 & 1) != 0)
    std::vector<CLMicroLocationRecordingLabelsTable::Entry>::__clear[abi:ne180100](v19);
LABEL_28:

}

void sub_2419E53A8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,void *__p,uint64_t a28,int a29,__int16 a30,char a31,char a32,uint64_t a33,uint64_t a34,uint64_t a35,char a36)
{
  void *v36;

  a25 = a10;
  std::vector<CLMicroLocationRecordingLabelsTable::Entry>::__destroy_vector::operator()[abi:ne180100]((void ***)&a25);

  _Unwind_Resume(a1);
}

uint64_t std::vector<CLMicroLocationRecordingLabelsTable::Entry>::reserve(uint64_t *a1, unint64_t a2)
{
  uint64_t result;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  _QWORD v7[5];

  v4 = a1[2];
  result = (uint64_t)(a1 + 2);
  if (a2 > (v4 - *a1) >> 6)
  {
    if (a2 >> 58)
      std::vector<CLMicroLocationProto::ConfidenceReason>::__throw_length_error[abi:ne180100]();
    v5 = a1[1] - *a1;
    v7[4] = result;
    v7[0] = std::__allocate_at_least[abi:ne180100]<std::allocator<CLMicroLocationRecordingLabelsTable::Entry>>(result, a2);
    v7[1] = v7[0] + v5;
    v7[2] = v7[0] + v5;
    v7[3] = v7[0] + (v6 << 6);
    std::vector<CLMicroLocationRecordingLabelsTable::Entry>::__swap_out_circular_buffer(a1, v7);
    return std::__split_buffer<CLMicroLocationRecordingLabelsTable::Entry>::~__split_buffer((uint64_t)v7);
  }
  return result;
}

void sub_2419E54C8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__split_buffer<CLMicroLocationRecordingLabelsTable::Entry>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t std::vector<CLMicroLocationRecordingLabelsTable::Entry>::push_back[abi:ne180100](uint64_t *a1, uint64_t a2)
{
  uint64_t result;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  __int128 v8;
  __int128 v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  unint64_t v14;
  char *v15;
  char *v16;
  __int128 v17;
  __int128 v18;
  _QWORD v19[5];

  v6 = a1[2];
  result = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(_QWORD *)(result - 8);
  if (v7 >= v6)
  {
    v11 = (uint64_t)(v7 - *a1) >> 6;
    v12 = v11 + 1;
    if ((unint64_t)(v11 + 1) >> 58)
      std::vector<CLMicroLocationProto::ConfidenceReason>::__throw_length_error[abi:ne180100]();
    v13 = v5 - *a1;
    if (v13 >> 5 > v12)
      v12 = v13 >> 5;
    if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFC0)
      v14 = 0x3FFFFFFFFFFFFFFLL;
    else
      v14 = v12;
    v19[4] = result;
    if (v14)
      v15 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<CLMicroLocationRecordingLabelsTable::Entry>>(result, v14);
    else
      v15 = 0;
    v16 = &v15[64 * v11];
    v19[0] = v15;
    v19[1] = v16;
    v19[3] = &v15[64 * v14];
    *(_OWORD *)v16 = *(_OWORD *)a2;
    v17 = *(_OWORD *)(a2 + 16);
    *((_QWORD *)v16 + 4) = *(_QWORD *)(a2 + 32);
    *((_OWORD *)v16 + 1) = v17;
    *(_QWORD *)(a2 + 24) = 0;
    *(_QWORD *)(a2 + 32) = 0;
    *(_QWORD *)(a2 + 16) = 0;
    v18 = *(_OWORD *)(a2 + 40);
    *((_QWORD *)v16 + 7) = *(_QWORD *)(a2 + 56);
    *(_OWORD *)(v16 + 40) = v18;
    v19[2] = v16 + 64;
    std::vector<CLMicroLocationRecordingLabelsTable::Entry>::__swap_out_circular_buffer(a1, v19);
    v10 = a1[1];
    result = std::__split_buffer<CLMicroLocationRecordingLabelsTable::Entry>::~__split_buffer((uint64_t)v19);
  }
  else
  {
    *(_OWORD *)v7 = *(_OWORD *)a2;
    v8 = *(_OWORD *)(a2 + 16);
    *(_QWORD *)(v7 + 32) = *(_QWORD *)(a2 + 32);
    *(_OWORD *)(v7 + 16) = v8;
    *(_QWORD *)(a2 + 24) = 0;
    *(_QWORD *)(a2 + 32) = 0;
    *(_QWORD *)(a2 + 16) = 0;
    v9 = *(_OWORD *)(a2 + 40);
    *(_QWORD *)(v7 + 56) = *(_QWORD *)(a2 + 56);
    *(_OWORD *)(v7 + 40) = v9;
    v10 = v7 + 64;
    a1[1] = v7 + 64;
  }
  a1[1] = v10;
  return result;
}

void sub_2419E5610(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__split_buffer<CLMicroLocationRecordingLabelsTable::Entry>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t std::vector<CLMicroLocationRecordingLabelsTable::Entry>::__swap_out_circular_buffer(uint64_t *a1, _QWORD *a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<CLMicroLocationRecordingLabelsTable::Entry>,std::reverse_iterator<CLMicroLocationRecordingLabelsTable::Entry*>,std::reverse_iterator<CLMicroLocationRecordingLabelsTable::Entry*>,std::reverse_iterator<CLMicroLocationRecordingLabelsTable::Entry*>>((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<CLMicroLocationRecordingLabelsTable::Entry>>(uint64_t a1, unint64_t a2)
{
  if (a2 >> 58)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(a2 << 6);
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<CLMicroLocationRecordingLabelsTable::Entry>,std::reverse_iterator<CLMicroLocationRecordingLabelsTable::Entry*>,std::reverse_iterator<CLMicroLocationRecordingLabelsTable::Entry*>,std::reverse_iterator<CLMicroLocationRecordingLabelsTable::Entry*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7;
  __int128 v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD v12[3];
  char v13;
  __int128 v14;
  __int128 v15;

  v7 = a7;
  *(_QWORD *)&v15 = a6;
  *((_QWORD *)&v15 + 1) = a7;
  v14 = v15;
  v12[0] = a1;
  v12[1] = &v14;
  v12[2] = &v15;
  if (a3 == a5)
  {
    v10 = a6;
  }
  else
  {
    do
    {
      *(_OWORD *)(v7 - 64) = *(_OWORD *)(a3 - 64);
      v8 = *(_OWORD *)(a3 - 48);
      *(_QWORD *)(v7 - 32) = *(_QWORD *)(a3 - 32);
      *(_OWORD *)(v7 - 48) = v8;
      *(_QWORD *)(a3 - 40) = 0;
      *(_QWORD *)(a3 - 32) = 0;
      *(_QWORD *)(a3 - 48) = 0;
      v9 = *(_QWORD *)(a3 - 8);
      *(_OWORD *)(v7 - 24) = *(_OWORD *)(a3 - 24);
      *(_QWORD *)(v7 - 8) = v9;
      v7 = *((_QWORD *)&v15 + 1) - 64;
      *((_QWORD *)&v15 + 1) -= 64;
      a3 -= 64;
    }
    while (a3 != a5);
    v10 = v15;
  }
  v13 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<CLMicroLocationRecordingLabelsTable::Entry>,std::reverse_iterator<CLMicroLocationRecordingLabelsTable::Entry*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v12);
  return v10;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<CLMicroLocationRecordingLabelsTable::Entry>,std::reverse_iterator<CLMicroLocationRecordingLabelsTable::Entry*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24))
    std::_AllocatorDestroyRangeReverse<std::allocator<CLMicroLocationRecordingLabelsTable::Entry>,std::reverse_iterator<CLMicroLocationRecordingLabelsTable::Entry*>>::operator()[abi:ne180100](a1);
  return a1;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<CLMicroLocationRecordingLabelsTable::Entry>,std::reverse_iterator<CLMicroLocationRecordingLabelsTable::Entry*>>::operator()[abi:ne180100](uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;

  v1 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 8);
  v2 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8);
  while (v1 != v2)
  {
    if (*(char *)(v1 + 39) < 0)
      operator delete(*(void **)(v1 + 16));
    v1 += 64;
  }
}

uint64_t std::__split_buffer<CLMicroLocationRecordingLabelsTable::Entry>::~__split_buffer(uint64_t a1)
{
  std::__split_buffer<CLMicroLocationRecordingLabelsTable::Entry>::__destruct_at_end[abi:ne180100](a1, *(_QWORD *)(a1 + 8));
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

void std::__split_buffer<CLMicroLocationRecordingLabelsTable::Entry>::__destruct_at_end[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v5;

  v2 = *(_QWORD *)(a1 + 16);
  if (v2 != a2)
  {
    do
    {
      v5 = v2 - 64;
      *(_QWORD *)(a1 + 16) = v2 - 64;
      if (*(char *)(v2 - 25) < 0)
      {
        operator delete(*(void **)(v2 - 48));
        v5 = *(_QWORD *)(a1 + 16);
      }
      v2 = v5;
    }
    while (v5 != a2);
  }
}

void std::vector<CLMicroLocationRecordingLabelsTable::Entry>::__clear[abi:ne180100](uint64_t *a1)
{
  uint64_t v2;
  uint64_t i;

  v2 = *a1;
  for (i = a1[1]; i != v2; i -= 64)
  {
    if (*(char *)(i - 25) < 0)
      operator delete(*(void **)(i - 48));
  }
  a1[1] = v2;
}

void std::vector<CLMicroLocationRecordingLabelsTable::Entry>::__vdeallocate(uint64_t *a1)
{
  if (*a1)
  {
    std::vector<CLMicroLocationRecordingLabelsTable::Entry>::__clear[abi:ne180100](a1);
    operator delete((void *)*a1);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

_QWORD *std::vector<CLMicroLocationRecordingLabelsTable::Entry>::__init_with_size[abi:ne180100]<CLMicroLocationRecordingLabelsTable::Entry*,CLMicroLocationRecordingLabelsTable::Entry*>(_QWORD *result, __int128 *a2, __int128 *a3, unint64_t a4)
{
  _QWORD *v6;

  if (a4)
  {
    v6 = result;
    std::vector<CLMicroLocationRecordingLabelsTable::Entry>::__vallocate[abi:ne180100](result, a4);
    result = (_QWORD *)std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<CLMicroLocationRecordingLabelsTable::Entry>,CLMicroLocationRecordingLabelsTable::Entry*,CLMicroLocationRecordingLabelsTable::Entry*,CLMicroLocationRecordingLabelsTable::Entry*>((uint64_t)(v6 + 2), a2, a3, v6[1]);
    v6[1] = result;
  }
  return result;
}

void sub_2419E596C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  uint64_t v9;
  uint64_t v10;

  *(_QWORD *)(v9 + 8) = v10;
  std::vector<CLMicroLocationRecordingLabelsTable::Entry>::__destroy_vector::operator()[abi:ne180100](&a9);
  _Unwind_Resume(a1);
}

char *std::vector<CLMicroLocationRecordingLabelsTable::Entry>::__vallocate[abi:ne180100](_QWORD *a1, unint64_t a2)
{
  char *result;
  uint64_t v4;

  if (a2 >> 58)
    std::vector<CLMicroLocationProto::ConfidenceReason>::__throw_length_error[abi:ne180100]();
  result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<CLMicroLocationRecordingLabelsTable::Entry>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[64 * v4];
  return result;
}

uint64_t std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<CLMicroLocationRecordingLabelsTable::Entry>,CLMicroLocationRecordingLabelsTable::Entry*,CLMicroLocationRecordingLabelsTable::Entry*,CLMicroLocationRecordingLabelsTable::Entry*>(uint64_t a1, __int128 *a2, __int128 *a3, uint64_t a4)
{
  uint64_t v4;
  __int128 *v6;
  std::string *v7;
  __int128 v8;
  uint64_t v9;
  __int128 *v10;
  __int128 v11;
  _QWORD v13[3];
  char v14;
  uint64_t v15;
  uint64_t v16;

  v4 = a4;
  v15 = a4;
  v16 = a4;
  v13[0] = a1;
  v13[1] = &v15;
  v13[2] = &v16;
  v14 = 0;
  if (a2 != a3)
  {
    v6 = a2 + 1;
    do
    {
      *(_OWORD *)v4 = *(v6 - 1);
      v7 = (std::string *)(v4 + 16);
      if (*((char *)v6 + 23) < 0)
      {
        std::string::__init_copy_ctor_external(v7, *(const std::string::value_type **)v6, *((_QWORD *)v6 + 1));
        v9 = v16;
      }
      else
      {
        v8 = *v6;
        *(_QWORD *)(v4 + 32) = *((_QWORD *)v6 + 2);
        *(_OWORD *)&v7->__r_.__value_.__l.__data_ = v8;
        v9 = v4;
      }
      v10 = v6 - 1;
      v11 = *(__int128 *)((char *)v6 + 24);
      *(_QWORD *)(v4 + 56) = *((_QWORD *)v6 + 5);
      *(_OWORD *)(v4 + 40) = v11;
      v4 = v9 + 64;
      v16 = v9 + 64;
      v6 += 4;
    }
    while (v10 + 4 != a3);
  }
  v14 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<CLMicroLocationRecordingLabelsTable::Entry>,CLMicroLocationRecordingLabelsTable::Entry*>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v13);
  return v4;
}

void sub_2419E5A98(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<CLMicroLocationRecordingLabelsTable::Entry>,CLMicroLocationRecordingLabelsTable::Entry*>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void std::string::__init_copy_ctor_external(std::string *this, const std::string::value_type *__s, std::string::size_type __sz)
{
  std::string *v5;
  std::string::size_type v6;
  std::string::size_type v7;
  std::string *v8;

  v5 = this;
  if (__sz > 0x16)
  {
    if (__sz >= 0x7FFFFFFFFFFFFFF8)
      std::string::__throw_length_error[abi:ne180100]();
    v6 = (__sz & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((__sz | 7) != 0x17)
      v6 = __sz | 7;
    v7 = v6 + 1;
    v8 = (std::string *)operator new(v6 + 1);
    v5->__r_.__value_.__l.__size_ = __sz;
    v5->__r_.__value_.__r.__words[2] = v7 | 0x8000000000000000;
    v5->__r_.__value_.__r.__words[0] = (std::string::size_type)v8;
    v5 = v8;
  }
  else
  {
    *((_BYTE *)&this->__r_.__value_.__s + 23) = __sz;
  }
  memmove(v5, __s, __sz + 1);
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<CLMicroLocationRecordingLabelsTable::Entry>,CLMicroLocationRecordingLabelsTable::Entry*>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24))
    std::_AllocatorDestroyRangeReverse<std::allocator<CLMicroLocationRecordingLabelsTable::Entry>,CLMicroLocationRecordingLabelsTable::Entry*>::operator()[abi:ne180100](a1);
  return a1;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<CLMicroLocationRecordingLabelsTable::Entry>,CLMicroLocationRecordingLabelsTable::Entry*>::operator()[abi:ne180100](uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;

  v1 = **(_QWORD **)(a1 + 16);
  v2 = **(_QWORD **)(a1 + 8);
  while (v1 != v2)
  {
    if (*(char *)(v1 - 25) < 0)
      operator delete(*(void **)(v1 - 48));
    v1 -= 64;
  }
}

void std::vector<CLMicroLocationRecordingLabelsTable::Entry>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v2;

  v2 = *a1;
  if (*v2)
  {
    std::vector<CLMicroLocationRecordingLabelsTable::Entry>::__clear[abi:ne180100]((uint64_t *)v2);
    operator delete(**a1);
  }
}

uint64_t std::vector<std::string>::__emplace_back_slow_path<char const*>(uint64_t *a1, char **a2)
{
  uint64_t v3;
  unint64_t v4;
  unint64_t v5;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  std::string *v10;
  uint64_t v11;
  std::__split_buffer<std::string> __v;

  v3 = *a1;
  v4 = 0xAAAAAAAAAAAAAAABLL * ((a1[1] - *a1) >> 3);
  v5 = v4 + 1;
  if (v4 + 1 > 0xAAAAAAAAAAAAAAALL)
    std::vector<CLMicroLocationProto::ConfidenceReason>::__throw_length_error[abi:ne180100]();
  v7 = (uint64_t)(a1 + 2);
  v8 = 0xAAAAAAAAAAAAAAABLL * ((a1[2] - v3) >> 3);
  if (2 * v8 > v5)
    v5 = 2 * v8;
  if (v8 >= 0x555555555555555)
    v9 = 0xAAAAAAAAAAAAAAALL;
  else
    v9 = v5;
  __v.__end_cap_.__value_ = (std::allocator<std::string> *)(a1 + 2);
  if (v9)
    v10 = (std::string *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::string>>(v7, v9);
  else
    v10 = 0;
  __v.__first_ = v10;
  __v.__begin_ = v10 + v4;
  __v.__end_ = __v.__begin_;
  __v.__end_cap_.__value_ = &v10[v9];
  std::string::basic_string[abi:ne180100]<0>(__v.__begin_->__r_.__value_.__r.__words, *a2);
  __v.__end_ = __v.__begin_ + 1;
  std::vector<std::string>::__swap_out_circular_buffer((std::vector<std::string> *)a1, &__v);
  v11 = a1[1];
  std::__split_buffer<std::string>::~__split_buffer(&__v);
  return v11;
}

void sub_2419E5CE0(_Unwind_Exception *a1, std::__split_buffer<std::string> *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  std::__split_buffer<std::string>::~__split_buffer((std::__split_buffer<std::string> *)&a10);
  _Unwind_Resume(a1);
}

CLMicroLocationLogic::State *CLMicroLocationLogic::State::State(CLMicroLocationLogic::State *this)
{
  *(_DWORD *)this = 0;
  *((_WORD *)this + 2) = 1;
  *((_BYTE *)this + 6) = 0;
  std::string::basic_string[abi:ne180100]<0>((_QWORD *)this + 1, "unknown");
  *((_QWORD *)this + 4) = 0;
  *((_QWORD *)this + 5) = 0;
  *((_BYTE *)this + 48) = 1;
  *(_QWORD *)((char *)this + 52) = 0;
  *((_BYTE *)this + 60) = 1;
  *((_QWORD *)this + 8) = 0;
  *((_QWORD *)this + 9) = 0x1010000000101;
  return this;
}

void CLMicroLocationLogic::State::setScanActivity(uint64_t a1, char a2)
{
  NSObject *v4;
  int v5;
  void **v6;
  void **v7;
  _BYTE *v8;
  NSObject *v9;
  int v10;
  void **v11;
  void **v12;
  _BYTE *v13;
  NSObject *v14;
  int v15;
  void **v16;
  void **v17;
  _BYTE *v18;
  NSObject *v19;
  int v20;
  uint8_t *v21;
  uint8_t *v22;
  void **v23;
  NSObject *v24;
  int v25;
  void **v26;
  void **v27;
  _BYTE *v28;
  NSObject *v29;
  int v30;
  void **v31;
  void **v32;
  _BYTE *v33;
  int v34;
  void **v35;
  void **v36;
  _BYTE *v37;
  void *v38[2];
  char v39;
  _BYTE __p[12];
  __int16 v41;
  void **v42;
  char v43;
  uint8_t buf[8];
  __int16 v45;
  const char *v46;
  __int16 v47;
  void **v48;
  __int16 v49;
  _BYTE *v50;
  __int16 v51;
  const char *v52;
  __int16 v53;
  const char *v54;
  uint64_t v55;

  v55 = *MEMORY[0x24BDAC8D0];
  if (*(_BYTE *)(a1 + 5))
  {
    if (*(unsigned __int8 *)(a1 + 5) - 1 < 2)
    {
      _CLLogObjectForCategory_MicroLocation_Default();
      v4 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT))
      {
        CLMicroLocationUtils::scanActivityToString(*(_BYTE *)(a1 + 5), v38);
        v5 = v39;
        v6 = (void **)v38[0];
        CLMicroLocationUtils::scanActivityToString(a2, __p);
        v7 = v38;
        if (v5 < 0)
          v7 = v6;
        if (v43 >= 0)
          v8 = __p;
        else
          v8 = *(_BYTE **)__p;
        *(_DWORD *)buf = 68290051;
        *(_DWORD *)&buf[4] = 0;
        v45 = 2082;
        v46 = "";
        v47 = 2082;
        v48 = v7;
        v49 = 2082;
        v50 = v8;
        v51 = 2082;
        v52 = "assert";
        v53 = 2081;
        v54 = "false";
        _os_log_impl(&dword_2419D9000, v4, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Can't set new activity\", \"currentActivity\":%{public, location:escape_only}s, \"providedNextActivity\":%{public, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v43 < 0)
          operator delete(*(void **)__p);
        if (v39 < 0)
          operator delete(v38[0]);
      }

      _CLLogObjectForCategory_MicroLocation_Default();
      v9 = objc_claimAutoreleasedReturnValue();
      if (os_signpost_enabled(v9))
      {
        CLMicroLocationUtils::scanActivityToString(*(_BYTE *)(a1 + 5), v38);
        v10 = v39;
        v11 = (void **)v38[0];
        CLMicroLocationUtils::scanActivityToString(a2, __p);
        v12 = v38;
        if (v10 < 0)
          v12 = v11;
        if (v43 >= 0)
          v13 = __p;
        else
          v13 = *(_BYTE **)__p;
        *(_DWORD *)buf = 68290051;
        *(_DWORD *)&buf[4] = 0;
        v45 = 2082;
        v46 = "";
        v47 = 2082;
        v48 = v12;
        v49 = 2082;
        v50 = v13;
        v51 = 2082;
        v52 = "assert";
        v53 = 2081;
        v54 = "false";
        _os_signpost_emit_with_name_impl(&dword_2419D9000, v9, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Can't set new activity", "{\"msg%{public}.0s\":\"Can't set new activity\", \"currentActivity\":%{public, location:escape_only}s, \"providedNextActivity\":%{public, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v43 < 0)
          operator delete(*(void **)__p);
        if (v39 < 0)
          operator delete(v38[0]);
      }

      _CLLogObjectForCategory_MicroLocation_Default();
      v14 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v14, OS_LOG_TYPE_INFO))
      {
        CLMicroLocationUtils::scanActivityToString(*(_BYTE *)(a1 + 5), v38);
        v15 = v39;
        v16 = (void **)v38[0];
        CLMicroLocationUtils::scanActivityToString(a2, __p);
        v17 = v38;
        if (v15 < 0)
          v17 = v16;
        if (v43 >= 0)
          v18 = __p;
        else
          v18 = *(_BYTE **)__p;
        *(_DWORD *)buf = 68290051;
        *(_DWORD *)&buf[4] = 0;
        v45 = 2082;
        v46 = "";
        v47 = 2082;
        v48 = v17;
        v49 = 2082;
        v50 = v18;
        v51 = 2082;
        v52 = "assert";
        v53 = 2081;
        v54 = "false";
        _os_log_impl(&dword_2419D9000, v14, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Can't set new activity\", \"currentActivity\":%{public, location:escape_only}s, \"providedNextActivity\":%{public, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
        if (v43 < 0)
          operator delete(*(void **)__p);
        if (v39 < 0)
          operator delete(v38[0]);
      }
      goto LABEL_78;
    }
  }
  else if ((a2 - 3) <= 0xFDu)
  {
    _CLLogObjectForCategory_MicroLocation_Default();
    v24 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v24, OS_LOG_TYPE_FAULT))
    {
      CLMicroLocationUtils::scanActivityToString(*(_BYTE *)(a1 + 5), v38);
      v25 = v39;
      v26 = (void **)v38[0];
      CLMicroLocationUtils::scanActivityToString(a2, __p);
      v27 = v38;
      if (v25 < 0)
        v27 = v26;
      if (v43 >= 0)
        v28 = __p;
      else
        v28 = *(_BYTE **)__p;
      *(_DWORD *)buf = 68290051;
      *(_DWORD *)&buf[4] = 0;
      v45 = 2082;
      v46 = "";
      v47 = 2082;
      v48 = v27;
      v49 = 2082;
      v50 = v28;
      v51 = 2082;
      v52 = "assert";
      v53 = 2081;
      v54 = "scanActivity == CLMicroLocationUtils::ScanActivity::Localizing || scanActivity == CLMicroLocationUtils::Scan"
            "Activity::Recording";
      _os_log_impl(&dword_2419D9000, v24, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Can't set new activity\", \"currentActivity\":%{public, location:escape_only}s, \"providedNextActivity\":%{public, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
      if (v43 < 0)
        operator delete(*(void **)__p);
      if (v39 < 0)
        operator delete(v38[0]);
    }

    _CLLogObjectForCategory_MicroLocation_Default();
    v29 = objc_claimAutoreleasedReturnValue();
    if (os_signpost_enabled(v29))
    {
      CLMicroLocationUtils::scanActivityToString(*(_BYTE *)(a1 + 5), v38);
      v30 = v39;
      v31 = (void **)v38[0];
      CLMicroLocationUtils::scanActivityToString(a2, __p);
      v32 = v38;
      if (v30 < 0)
        v32 = v31;
      if (v43 >= 0)
        v33 = __p;
      else
        v33 = *(_BYTE **)__p;
      *(_DWORD *)buf = 68290051;
      *(_DWORD *)&buf[4] = 0;
      v45 = 2082;
      v46 = "";
      v47 = 2082;
      v48 = v32;
      v49 = 2082;
      v50 = v33;
      v51 = 2082;
      v52 = "assert";
      v53 = 2081;
      v54 = "scanActivity == CLMicroLocationUtils::ScanActivity::Localizing || scanActivity == CLMicroLocationUtils::Scan"
            "Activity::Recording";
      _os_signpost_emit_with_name_impl(&dword_2419D9000, v29, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Can't set new activity", "{\"msg%{public}.0s\":\"Can't set new activity\", \"currentActivity\":%{public, location:escape_only}s, \"providedNextActivity\":%{public, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
      if (v43 < 0)
        operator delete(*(void **)__p);
      if (v39 < 0)
        operator delete(v38[0]);
    }

    _CLLogObjectForCategory_MicroLocation_Default();
    v14 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_INFO))
    {
      CLMicroLocationUtils::scanActivityToString(*(_BYTE *)(a1 + 5), v38);
      v34 = v39;
      v35 = (void **)v38[0];
      CLMicroLocationUtils::scanActivityToString(a2, __p);
      v36 = v38;
      if (v34 < 0)
        v36 = v35;
      if (v43 >= 0)
        v37 = __p;
      else
        v37 = *(_BYTE **)__p;
      *(_DWORD *)buf = 68290051;
      *(_DWORD *)&buf[4] = 0;
      v45 = 2082;
      v46 = "";
      v47 = 2082;
      v48 = v36;
      v49 = 2082;
      v50 = v37;
      v51 = 2082;
      v52 = "assert";
      v53 = 2081;
      v54 = "scanActivity == CLMicroLocationUtils::ScanActivity::Localizing || scanActivity == CLMicroLocationUtils::Scan"
            "Activity::Recording";
      _os_log_impl(&dword_2419D9000, v14, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Can't set new activity\", \"currentActivity\":%{public, location:escape_only}s, \"providedNextActivity\":%{public, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
      if (v43 < 0)
        operator delete(*(void **)__p);
      if (v39 < 0)
        operator delete(v38[0]);
    }
LABEL_78:

    abort_report_np();
    __break(1u);
  }
  if (onceToken_MicroLocation_Default != -1)
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_3);
  v19 = (id)logObject_MicroLocation_Default;
  if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
  {
    CLMicroLocationUtils::scanActivityToString(*(_BYTE *)(a1 + 5), buf);
    v20 = SBYTE3(v48);
    v21 = *(uint8_t **)buf;
    CLMicroLocationUtils::scanActivityToString(a2, v38);
    v22 = buf;
    if (v20 < 0)
      v22 = v21;
    if (v39 >= 0)
      v23 = v38;
    else
      v23 = (void **)v38[0];
    *(_DWORD *)__p = 136446466;
    *(_QWORD *)&__p[4] = v22;
    v41 = 2082;
    v42 = v23;
    _os_log_impl(&dword_2419D9000, v19, OS_LOG_TYPE_DEFAULT, "Advanced from %{public}s to %{public}s", __p, 0x16u);
    if (v39 < 0)
      operator delete(v38[0]);
    if (SBYTE3(v48) < 0)
      operator delete(*(void **)buf);
  }

  *(_BYTE *)(a1 + 5) = a2;
}

void sub_2419E6510(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  void *v27;

  if (a17 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

void CLMicroLocationLogic::State::clearScanActivity(CLMicroLocationLogic::State *this)
{
  NSObject *v2;
  int v3;
  uint8_t *v4;
  uint8_t *v5;
  void **v6;
  NSObject *v7;
  void **v8;
  NSObject *v9;
  void **v10;
  NSObject *v11;
  void *__p[2];
  char v13;
  uint8_t buf[4];
  uint8_t *v15;
  __int16 v16;
  void **v17;
  uint8_t v18[8];
  __int16 v19;
  const char *v20;
  __int16 v21;
  void **v22;
  __int16 v23;
  const char *v24;
  __int16 v25;
  const char *v26;
  uint64_t v27;

  v27 = *MEMORY[0x24BDAC8D0];
  if (!*((_BYTE *)this + 5))
  {
    _CLLogObjectForCategory_MicroLocation_Default();
    v7 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_FAULT))
    {
      CLMicroLocationUtils::scanActivityToString(*((_BYTE *)this + 5), __p);
      v8 = v13 >= 0 ? __p : (void **)__p[0];
      *(_DWORD *)v18 = 68289795;
      *(_DWORD *)&v18[4] = 0;
      v19 = 2082;
      v20 = "";
      v21 = 2082;
      v22 = v8;
      v23 = 2082;
      v24 = "assert";
      v25 = 2081;
      v26 = "false";
      _os_log_impl(&dword_2419D9000, v7, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Can't clear current activity as it is already invalid\", \"currentActivity\":%{public, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", v18, 0x30u);
      if (v13 < 0)
        operator delete(__p[0]);
    }

    _CLLogObjectForCategory_MicroLocation_Default();
    v9 = objc_claimAutoreleasedReturnValue();
    if (os_signpost_enabled(v9))
    {
      CLMicroLocationUtils::scanActivityToString(*((_BYTE *)this + 5), __p);
      v10 = v13 >= 0 ? __p : (void **)__p[0];
      *(_DWORD *)v18 = 68289795;
      *(_DWORD *)&v18[4] = 0;
      v19 = 2082;
      v20 = "";
      v21 = 2082;
      v22 = v10;
      v23 = 2082;
      v24 = "assert";
      v25 = 2081;
      v26 = "false";
      _os_signpost_emit_with_name_impl(&dword_2419D9000, v9, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Can't clear current activity as it is already invalid", "{\"msg%{public}.0s\":\"Can't clear current activity as it is already invalid\", \"currentActivity\":%{public, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", v18, 0x30u);
      if (v13 < 0)
        operator delete(__p[0]);
    }

    _CLLogObjectForCategory_MicroLocation_Default();
    v11 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_INFO))
    {
      CLMicroLocationUtils::scanActivityToString(*((_BYTE *)this + 5), __p);
      CLMicroLocationLogic::State::clearScanActivity();
    }

    abort_report_np();
    __break(1u);
  }
  if (onceToken_MicroLocation_Default != -1)
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_3);
  v2 = (id)logObject_MicroLocation_Default;
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    CLMicroLocationUtils::scanActivityToString(*((_BYTE *)this + 5), v18);
    v3 = SBYTE3(v22);
    v4 = *(uint8_t **)v18;
    CLMicroLocationUtils::scanActivityToString(0, __p);
    v5 = v18;
    if (v3 < 0)
      v5 = v4;
    if (v13 >= 0)
      v6 = __p;
    else
      v6 = (void **)__p[0];
    *(_DWORD *)buf = 136446466;
    v15 = v5;
    v16 = 2082;
    v17 = v6;
    _os_log_impl(&dword_2419D9000, v2, OS_LOG_TYPE_DEFAULT, "Reversed from %{public}s to %{public}s", buf, 0x16u);
    if (v13 < 0)
      operator delete(__p[0]);
    if (SBYTE3(v22) < 0)
      operator delete(*(void **)v18);
  }

  *((_BYTE *)this + 5) = 0;
}

void sub_2419E6908(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24)
{
  void *v24;

  _Unwind_Resume(a1);
}

void CLMicroLocationLogic::State::setRapportSessionRunning(CLMicroLocationLogic::State *this, int a2)
{
  NSObject *v4;
  const char *v5;
  _DWORD v6[2];
  __int16 v7;
  const char *v8;
  __int16 v9;
  const char *v10;
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  if (onceToken_MicroLocation_Default != -1)
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_3);
  v4 = logObject_MicroLocation_Default;
  if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT))
  {
    v5 = "not running";
    v6[0] = 68289282;
    v6[1] = 0;
    v7 = 2082;
    v8 = "";
    if (a2)
      v5 = "running";
    v9 = 2082;
    v10 = v5;
    _os_log_impl(&dword_2419D9000, v4, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"Rapport, setRapportSessionRunning\", \"session set to\":%{public, location:escape_only}s}", (uint8_t *)v6, 0x1Cu);
  }
  *((_BYTE *)this + 6) = a2;
}

BOOL CLMicroLocationLogic::State::isAtHomeLoi(CLMicroLocationLogic::State *this)
{
  _DWORD *v1;
  int v2;

  v1 = (_DWORD *)((char *)this + 8);
  v2 = *((char *)this + 31);
  if ((v2 & 0x80000000) == 0)
  {
    if (v2 != 4)
      return 0;
    return *v1 == 1701670760;
  }
  if (*((_QWORD *)this + 2) == 4)
  {
    v1 = *(_DWORD **)v1;
    return *v1 == 1701670760;
  }
  return 0;
}

uint64_t CLMicroLocationLogic::CLMicroLocationLogic(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  void *v12;
  void *v13;
  void *v14;
  void *v15;
  unsigned int v16;
  unsigned int v17;
  unint64_t v18;
  CLMiLoCustomLoiRecordingManager *v19;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;

  *(_QWORD *)(a1 + 8) = &unk_2511D24F8;
  v8 = a1 + 8;
  *(_QWORD *)(a1 + 16) = &unk_2511D25B8;
  v9 = a1 + 16;
  *(_QWORD *)(a1 + 32) = &unk_2511D26A0;
  v10 = a1 + 32;
  *(_QWORD *)a1 = &off_2511D2328;
  *(_QWORD *)(a1 + 24) = &unk_2511D2618;
  *(_QWORD *)(a1 + 40) = &unk_2511D26D8;
  CLMicroLocationLogic::State::State((CLMicroLocationLogic::State *)(a1 + 48));
  *(_QWORD *)(a1 + 136) = 0;
  *(_QWORD *)(a1 + 128) = a3;
  *(_QWORD *)(a1 + 144) = 0;
  *(_QWORD *)(a1 + 152) = 0;
  std::vector<CLMicroLocationLoggedEventsTable::Entry>::__init_with_size[abi:ne180100]<CLMicroLocationLoggedEventsTable::Entry*,CLMicroLocationLoggedEventsTable::Entry*>((_QWORD *)(a1 + 136), *a4, a4[1], 0xCF3CF3CF3CF3CF3DLL * ((a4[1] - *a4) >> 4));
  v21 = a2;
  v22 = a3;
  v11 = a4[3];
  *(_BYTE *)(a1 + 168) = 0;
  *(_QWORD *)(a1 + 160) = v11;
  *(_BYTE *)(a1 + 200) = 0;
  *(_BYTE *)(a1 + 656) = 0;
  *(_OWORD *)(a1 + 208) = 0u;
  *(_OWORD *)(a1 + 224) = 0u;
  *(_OWORD *)(a1 + 240) = 0u;
  *(_BYTE *)(a1 + 256) = 0;
  CLMicroLocationRecorder::CLMicroLocationRecorder((CLMicroLocationRecorder *)(a1 + 664), *(ULDatabase **)(a1 + 128));
  CLMicroLocationSensorsLogic::CLMicroLocationSensorsLogic((CLMicroLocationSensorsLogic *)(a1 + 712), (CLMicroLocationLogic *)a1, *(ULDatabase **)(a1 + 128));
  v23 = *(_QWORD *)(a1 + 128);
  +[ULDefaultsSingleton shared](ULDefaultsSingleton, "shared");
  v12 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v12, "defaultsDictionary");
  v13 = (void *)objc_claimAutoreleasedReturnValue();

  objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "ULRapportMonitorMaxEntries");
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v13, "objectForKey:", v14);
  v15 = (void *)objc_claimAutoreleasedReturnValue();
  if (v15 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
    v16 = objc_msgSend(v15, "unsignedIntValue");
  else
    v16 = objc_msgSend(&unk_2511ED1F8, "unsignedIntValue");
  v17 = v16;

  *(_OWORD *)(a1 + 1464) = 0u;
  *(_OWORD *)(a1 + 1480) = 0u;
  *(_DWORD *)(a1 + 1496) = 1065353216;
  *(_QWORD *)(a1 + 1504) = v23;
  *(_QWORD *)(a1 + 1512) = 0;
  *(_QWORD *)(a1 + 1528) = 0;
  *(_QWORD *)(a1 + 1520) = 0;
  *(_QWORD *)(a1 + 1552) = v17;
  CLMicroLocationTriggerManager::CLMicroLocationTriggerManager(a1 + 1560, v8);
  CLMiLoServiceManager::CLMiLoServiceManager(a1 + 1768, v9, *(_QWORD *)(a1 + 128));
  CLMacAddress::newFromUint64((CLMacAddress *)(a1 + 2016), v18);
  CLMicroLocationLoiManager::CLMicroLocationLoiManager(a1 + 2024, v10, v22);
  *(_OWORD *)(a1 + 2568) = 0u;
  *(_QWORD *)(a1 + 2584) = v21;
  *(_QWORD *)(a1 + 2600) = 0;
  *(_OWORD *)(a1 + 2608) = 0u;
  v19 = (CLMiLoCustomLoiRecordingManager *)operator new();
  CLMiLoCustomLoiRecordingManager::CLMiLoCustomLoiRecordingManager(v19, a1 + 1560);
  *(_QWORD *)(a1 + 2560) = v19;
  CLMicroLocationTriggerManager::setupCustomLoiRecordingManager((_QWORD *)(a1 + 1560), v19);
  CLMicroLocationLogic::reloadAnchorDeviceModelAllowedList((CLMicroLocationLogic *)a1);
  return a1;
}

void sub_2419E6D38(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, CLMicroLocationRapportMonitor *a9, CLMicroLocationSensorsLogic *a10, CLMicroLocationRecorder *a11, CLMicroLocationEventLogger *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16)
{
  uint64_t v16;
  void *v17;
  CLMicroLocationLocalizationController *v18;
  void *v19;
  void *v20;

  CLMicroLocationSensorsLogic::~CLMicroLocationSensorsLogic(a10);
  CLMicroLocationRecorder::~CLMicroLocationRecorder(a11);
  CLMicroLocationLocalizationController::~CLMicroLocationLocalizationController(v18);
  CLMicroLocationEventLogger::~CLMicroLocationEventLogger(a12);
  if (*(char *)(v16 + 79) < 0)
    operator delete(*(void **)(v16 + 56));
  _Unwind_Resume(a1);
}

__n128 CLMicroLocationLogic::reloadAnchorDeviceModelAllowedList(CLMicroLocationLogic *this)
{
  void *v1;
  void *v2;
  id v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t i;
  std::vector<std::string>::pointer end;
  __int128 v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  std::string *v12;
  std::string *v13;
  __int128 v14;
  std::string *v15;
  std::vector<std::string>::pointer begin;
  uint64_t j;
  std::vector<std::string>::pointer v18;
  __int128 v19;
  unint64_t v20;
  unint64_t v21;
  unint64_t v22;
  std::string *v23;
  std::string *v24;
  __int128 v25;
  std::string *v26;
  __n128 result;
  id v28;
  __int128 v29;
  void *v31;
  void *v32;
  void *v33;
  std::vector<std::string> v34;
  std::vector<std::string> __p;
  void *v36[2];
  __int128 v37;
  __int128 v38;
  __int128 v39;
  std::__split_buffer<std::string> __v;
  std::__split_buffer<std::string> v41;
  uint64_t v42;

  v42 = *MEMORY[0x24BDAC8D0];
  +[ULDefaultsSingleton shared](ULDefaultsSingleton, "shared");
  v1 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v1, "defaultsDictionary");
  v2 = (void *)objc_claimAutoreleasedReturnValue();

  v31 = v2;
  objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "ULAnchorDeviceModelAllowedList");
  v32 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v2, "objectForKey:");
  v33 = (void *)objc_claimAutoreleasedReturnValue();
  if (v33 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
  {
    memset(&v34, 0, sizeof(v34));
    v28 = v33;
    std::vector<std::string>::reserve(&v34, objc_msgSend(v28, "count"));
    v38 = 0u;
    v39 = 0u;
    *(_OWORD *)v36 = 0u;
    v37 = 0u;
    v3 = v28;
    v4 = objc_msgSend(v3, "countByEnumeratingWithState:objects:count:", v36, &v41, 16);
    if (v4)
    {
      v5 = *(_QWORD *)v37;
      do
      {
        for (i = 0; i != v4; ++i)
        {
          if (*(_QWORD *)v37 != v5)
            objc_enumerationMutation(v3);
          std::string::basic_string[abi:ne180100]<0>(&__p, (char *)objc_msgSend(objc_retainAutorelease(*((id *)v36[1] + i)), "UTF8String"));
          end = v34.__end_;
          if (v34.__end_ >= v34.__end_cap_.__value_)
          {
            v9 = 0xAAAAAAAAAAAAAAABLL * (((char *)v34.__end_ - (char *)v34.__begin_) >> 3);
            v10 = v9 + 1;
            if (v9 + 1 > 0xAAAAAAAAAAAAAAALL)
              std::vector<CLMicroLocationProto::ConfidenceReason>::__throw_length_error[abi:ne180100]();
            if (0x5555555555555556 * (((char *)v34.__end_cap_.__value_ - (char *)v34.__begin_) >> 3) > v10)
              v10 = 0x5555555555555556 * (((char *)v34.__end_cap_.__value_ - (char *)v34.__begin_) >> 3);
            if (0xAAAAAAAAAAAAAAABLL * (((char *)v34.__end_cap_.__value_ - (char *)v34.__begin_) >> 3) >= 0x555555555555555)
              v11 = 0xAAAAAAAAAAAAAAALL;
            else
              v11 = v10;
            __v.__end_cap_.__value_ = (std::allocator<std::string> *)&v34.__end_cap_;
            if (v11)
              v12 = (std::string *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::string>>((uint64_t)&v34.__end_cap_, v11);
            else
              v12 = 0;
            v13 = v12 + v9;
            __v.__first_ = v12;
            __v.__begin_ = v13;
            __v.__end_cap_.__value_ = &v12[v11];
            v14 = *(_OWORD *)&__p.__begin_;
            v13->__r_.__value_.__r.__words[2] = (std::string::size_type)__p.__end_cap_.__value_;
            *(_OWORD *)&v13->__r_.__value_.__l.__data_ = v14;
            memset(&__p, 0, sizeof(__p));
            __v.__end_ = v13 + 1;
            std::vector<std::string>::__swap_out_circular_buffer(&v34, &__v);
            v15 = v34.__end_;
            std::__split_buffer<std::string>::~__split_buffer(&__v);
            v34.__end_ = v15;
            if (SHIBYTE(__p.__end_cap_.__value_) < 0)
              operator delete(__p.__begin_);
          }
          else
          {
            v8 = *(_OWORD *)&__p.__begin_;
            v34.__end_->__r_.__value_.__r.__words[2] = (std::string::size_type)__p.__end_cap_.__value_;
            *(_OWORD *)&end->__r_.__value_.__l.__data_ = v8;
            v34.__end_ = end + 1;
          }
        }
        v4 = objc_msgSend(v3, "countByEnumeratingWithState:objects:count:", v36, &v41, 16);
      }
      while (v4);
    }

    begin = v34.__begin_;
    v41.__first_ = v34.__begin_;
    v29 = *(_OWORD *)&v34.__end_;
    v41.__begin_ = v34.__end_;
    memset(&v34, 0, sizeof(v34));
    v36[0] = &v34;
    std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)v36);

  }
  else
  {
    memset(&__v, 0, 24);
    memset(&__p, 0, sizeof(__p));
    std::vector<std::string>::reserve(&__p, 0xAuLL);
    for (j = 0; j != 10; ++j)
    {
      std::string::basic_string[abi:ne180100]<0>(v36, _ZGRN10ULSettings14SettingsTraitsINS_28AnchorDeviceModelAllowedListEE12defaultValueE_[j]);
      v18 = __p.__end_;
      if (__p.__end_ >= __p.__end_cap_.__value_)
      {
        v20 = 0xAAAAAAAAAAAAAAABLL * (((char *)__p.__end_ - (char *)__p.__begin_) >> 3);
        v21 = v20 + 1;
        if (v20 + 1 > 0xAAAAAAAAAAAAAAALL)
          std::vector<CLMicroLocationProto::ConfidenceReason>::__throw_length_error[abi:ne180100]();
        if (0x5555555555555556 * (((char *)__p.__end_cap_.__value_ - (char *)__p.__begin_) >> 3) > v21)
          v21 = 0x5555555555555556 * (((char *)__p.__end_cap_.__value_ - (char *)__p.__begin_) >> 3);
        if (0xAAAAAAAAAAAAAAABLL * (((char *)__p.__end_cap_.__value_ - (char *)__p.__begin_) >> 3) >= 0x555555555555555)
          v22 = 0xAAAAAAAAAAAAAAALL;
        else
          v22 = v21;
        v41.__end_cap_.__value_ = (std::allocator<std::string> *)&__p.__end_cap_;
        if (v22)
          v23 = (std::string *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::string>>((uint64_t)&__p.__end_cap_, v22);
        else
          v23 = 0;
        v24 = v23 + v20;
        v41.__first_ = v23;
        v41.__begin_ = v24;
        v41.__end_cap_.__value_ = &v23[v22];
        v25 = *(_OWORD *)v36;
        v24->__r_.__value_.__r.__words[2] = v37;
        *(_OWORD *)&v24->__r_.__value_.__l.__data_ = v25;
        v36[1] = 0;
        *(_QWORD *)&v37 = 0;
        v36[0] = 0;
        v41.__end_ = v24 + 1;
        std::vector<std::string>::__swap_out_circular_buffer(&__p, &v41);
        v26 = __p.__end_;
        std::__split_buffer<std::string>::~__split_buffer(&v41);
        __p.__end_ = v26;
        if (SBYTE7(v37) < 0)
          operator delete(v36[0]);
      }
      else
      {
        v19 = *(_OWORD *)v36;
        __p.__end_->__r_.__value_.__r.__words[2] = v37;
        *(_OWORD *)&v18->__r_.__value_.__l.__data_ = v19;
        __p.__end_ = v18 + 1;
      }
    }
    std::vector<std::string>::__vdeallocate((std::vector<std::string> *)&__v);
    *(_OWORD *)&__v.__first_ = *(_OWORD *)&__p.__begin_;
    __v.__end_ = __p.__end_cap_.__value_;
    memset(&__p, 0, sizeof(__p));
    v41.__first_ = (std::__split_buffer<std::string>::pointer)&__p;
    std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)&v41);
    begin = __v.__first_;
    v41.__first_ = __v.__first_;
    v29 = *(_OWORD *)&__v.__begin_;
    memset(&__v, 0, 24);
    v36[0] = &__v;
    std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)v36);
  }

  std::vector<std::string>::__vdeallocate((std::vector<std::string> *)((char *)this + 2600));
  *((_QWORD *)this + 325) = begin;
  *((_OWORD *)this + 163) = v29;
  memset(&v41, 0, 24);
  v36[0] = &v41;
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)v36);
  return result;
}

void sub_2419E7310(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, char a8, void *a9, uint64_t a10, void *a11, uint64_t a12, void *a13, void *a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,uint64_t *a22,uint64_t a23,uint64_t a24,uint64_t a25,std::__split_buffer<std::string> *__pa,uint64_t a27,std::__split_buffer<std::string> *a28)
{
  void *v28;

  a22 = &a16;
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)&a22);

  _Unwind_Resume(a1);
}

void CLMiLoServiceManager::~CLMiLoServiceManager(CLMiLoServiceManager *this)
{
  void **v2;

  *(_QWORD *)this = off_2511D41B8;
  v2 = (void **)((char *)this + 224);
  std::vector<CLMiLoServiceManager::ConnectionRequestParams>::__destroy_vector::operator()[abi:ne180100](&v2);
  std::deque<CLMiLoServiceManager::OutstandingEnableCustomLoiRequest>::~deque[abi:ne180100]((_QWORD *)this + 22);
  std::__hash_table<std::__hash_value_type<boost::uuids::uuid,std::weak_ptr<CLMicroLocationFingerprint>>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::weak_ptr<CLMicroLocationFingerprint>>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::weak_ptr<CLMicroLocationFingerprint>>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,std::weak_ptr<CLMicroLocationFingerprint>>>>::~__hash_table((uint64_t)this + 136);
  std::__tree<std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>,std::__map_value_compare<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>,std::less<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes>,true>,std::allocator<std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>>>::destroy((uint64_t)this + 64, *((_QWORD **)this + 9));
  std::__list_imp<CLMiLoService>::clear((uint64_t *)this + 5);
  v2 = (void **)((char *)this + 16);
  std::vector<std::shared_ptr<CLMiLoService::ModelAndConf>>::__destroy_vector::operator()[abi:ne180100](&v2);
}

{
  void **v2;

  *(_QWORD *)this = off_2511D41B8;
  v2 = (void **)((char *)this + 224);
  std::vector<CLMiLoServiceManager::ConnectionRequestParams>::__destroy_vector::operator()[abi:ne180100](&v2);
  std::deque<CLMiLoServiceManager::OutstandingEnableCustomLoiRequest>::~deque[abi:ne180100]((_QWORD *)this + 22);
  std::__hash_table<std::__hash_value_type<boost::uuids::uuid,std::weak_ptr<CLMicroLocationFingerprint>>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::weak_ptr<CLMicroLocationFingerprint>>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::weak_ptr<CLMicroLocationFingerprint>>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,std::weak_ptr<CLMicroLocationFingerprint>>>>::~__hash_table((uint64_t)this + 136);
  std::__tree<std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>,std::__map_value_compare<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>,std::less<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes>,true>,std::allocator<std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>>>::destroy((uint64_t)this + 64, *((_QWORD **)this + 9));
  std::__list_imp<CLMiLoService>::clear((uint64_t *)this + 5);
  v2 = (void **)((char *)this + 16);
  std::vector<std::shared_ptr<CLMiLoService::ModelAndConf>>::__destroy_vector::operator()[abi:ne180100](&v2);
  MEMORY[0x2426A04D4](this, 0x10A1C40F48E508FLL);
}

void CLMicroLocationTriggerManager::~CLMicroLocationTriggerManager(CLMicroLocationTriggerManager *this)
{
  char *v2;
  void **v3;

  *(_QWORD *)this = off_2511D91A8;
  v2 = (char *)this + 16;
  v3 = (void **)((char *)this + 80);
  std::vector<CLMicroLocationProto::RecordingEvent>::__destroy_vector::operator()[abi:ne180100](&v3);
  v3 = (void **)((char *)this + 56);
  std::vector<CLMicroLocationProto::RecordingEvent>::__destroy_vector::operator()[abi:ne180100](&v3);
  std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>>>::~__hash_table((uint64_t)v2);
}

{
  char *v2;
  void **v3;

  *(_QWORD *)this = off_2511D91A8;
  v2 = (char *)this + 16;
  v3 = (void **)((char *)this + 80);
  std::vector<CLMicroLocationProto::RecordingEvent>::__destroy_vector::operator()[abi:ne180100](&v3);
  v3 = (void **)((char *)this + 56);
  std::vector<CLMicroLocationProto::RecordingEvent>::__destroy_vector::operator()[abi:ne180100](&v3);
  std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>>>::~__hash_table((uint64_t)v2);
  MEMORY[0x2426A04D4](this, 0x10A1C407A5E7BEFLL);
}

void CLMicroLocationRapportMonitor::~CLMicroLocationRapportMonitor(void **this)
{
  if (*((char *)this + 71) < 0)
    operator delete(this[6]);
  std::__hash_table<CLMicroLocationRapportMonitor::Item,CLMicroLocationRapportMonitor::Item::HashItem,CLMicroLocationRapportMonitor::Item::PredicateItem,std::allocator<CLMicroLocationRapportMonitor::Item>>::~__hash_table((uint64_t)this);
}

void CLMicroLocationLocalizationController::~CLMicroLocationLocalizationController(CLMicroLocationLocalizationController *this)
{
  void **v2;

  std::__optional_destruct_base<CLMicroLocationLocalizationController::LocalizationInput,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)this + 88);
  v2 = (void **)((char *)this + 64);
  std::vector<CLMicroLocationLocalizationController::LocalizationRequest>::__destroy_vector::operator()[abi:ne180100](&v2);
  v2 = (void **)((char *)this + 40);
  std::vector<CLMiLoProtobufWrapper::Measurement>::__destroy_vector::operator()[abi:ne180100](&v2);
  if (*((_BYTE *)this + 32))
    CLMicroLocationProto::AssociatedAccessPointInfo::~AssociatedAccessPointInfo(this);
}

void CLMicroLocationLogic::~CLMicroLocationLogic(CLMicroLocationLogic *this)
{
  NSObject *v2;
  void **v3[2];

  *(_QWORD *)this = &off_2511D2328;
  *((_QWORD *)this + 1) = &unk_2511D24F8;
  *((_QWORD *)this + 2) = &unk_2511D25B8;
  *((_QWORD *)this + 3) = &unk_2511D2618;
  *((_QWORD *)this + 4) = &unk_2511D26A0;
  *((_QWORD *)this + 5) = &unk_2511D26D8;
  if (onceToken_MicroLocation_Default != -1)
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_3);
  v2 = logObject_MicroLocation_Default;
  if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v3[0]) = 0;
    _os_log_impl(&dword_2419D9000, v2, OS_LOG_TYPE_DEFAULT, "CLMicroLocationLogic: DTOR", (uint8_t *)v3, 2u);
  }
  CLMicroLocationRapportMonitor::backup((CLMicroLocationLogic *)((char *)this + 1464));
  CLMicroLocationSensorsLogic::backupBleIdentities((CLMicroLocationLogic *)((char *)this + 712));
  v3[0] = (void **)((char *)this + 2600);
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100](v3);

  CLMicroLocationLoiManager::~CLMicroLocationLoiManager((CLMicroLocationLogic *)((char *)this + 2024));
  *((_QWORD *)this + 221) = off_2511D41B8;
  v3[0] = (void **)((char *)this + 1992);
  std::vector<CLMiLoServiceManager::ConnectionRequestParams>::__destroy_vector::operator()[abi:ne180100](v3);
  std::deque<CLMiLoServiceManager::OutstandingEnableCustomLoiRequest>::~deque[abi:ne180100]((_QWORD *)this + 243);
  std::__hash_table<std::__hash_value_type<boost::uuids::uuid,std::weak_ptr<CLMicroLocationFingerprint>>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::weak_ptr<CLMicroLocationFingerprint>>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::weak_ptr<CLMicroLocationFingerprint>>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,std::weak_ptr<CLMicroLocationFingerprint>>>>::~__hash_table((uint64_t)this + 1904);
  std::__tree<std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>,std::__map_value_compare<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>,std::less<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes>,true>,std::allocator<std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>>>::destroy((uint64_t)this + 1832, *((_QWORD **)this + 230));
  std::__list_imp<CLMiLoService>::clear((uint64_t *)this + 226);
  v3[0] = (void **)((char *)this + 1784);
  std::vector<std::shared_ptr<CLMiLoService::ModelAndConf>>::__destroy_vector::operator()[abi:ne180100](v3);
  *((_QWORD *)this + 195) = off_2511D91A8;
  v3[0] = (void **)((char *)this + 1640);
  std::vector<CLMicroLocationProto::RecordingEvent>::__destroy_vector::operator()[abi:ne180100](v3);
  v3[0] = (void **)((char *)this + 1616);
  std::vector<CLMicroLocationProto::RecordingEvent>::__destroy_vector::operator()[abi:ne180100](v3);
  std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>>>::~__hash_table((uint64_t)this + 1576);
  if (*((char *)this + 1535) < 0)
    operator delete(*((void **)this + 189));
  std::__hash_table<CLMicroLocationRapportMonitor::Item,CLMicroLocationRapportMonitor::Item::HashItem,CLMicroLocationRapportMonitor::Item::PredicateItem,std::allocator<CLMicroLocationRapportMonitor::Item>>::~__hash_table((uint64_t)this + 1464);
  CLMicroLocationSensorsLogic::~CLMicroLocationSensorsLogic((CLMicroLocationLogic *)((char *)this + 712));
  CLMicroLocationRecorder::~CLMicroLocationRecorder((CLMicroLocationLogic *)((char *)this + 664));
  std::__optional_destruct_base<CLMicroLocationLocalizationController::LocalizationInput,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)this + 256);
  v3[0] = (void **)((char *)this + 232);
  std::vector<CLMicroLocationLocalizationController::LocalizationRequest>::__destroy_vector::operator()[abi:ne180100](v3);
  v3[0] = (void **)((char *)this + 208);
  std::vector<CLMiLoProtobufWrapper::Measurement>::__destroy_vector::operator()[abi:ne180100](v3);
  if (*((_BYTE *)this + 200))
    CLMicroLocationProto::AssociatedAccessPointInfo::~AssociatedAccessPointInfo((CLMicroLocationLogic *)((char *)this + 168));
  CLMicroLocationEventLogger::~CLMicroLocationEventLogger((CLMicroLocationLogic *)((char *)this + 136));
  if (*((char *)this + 79) < 0)
    operator delete(*((void **)this + 7));
}

{
  CLMicroLocationLogic::~CLMicroLocationLogic(this);
  JUMPOUT(0x2426A04D4);
}

void `non-virtual thunk to'CLMicroLocationLogic::~CLMicroLocationLogic(CLMicroLocationLogic *this)
{
  CLMicroLocationLogic::~CLMicroLocationLogic((CLMicroLocationLogic *)((char *)this - 8));
}

{
  CLMicroLocationLogic::~CLMicroLocationLogic((CLMicroLocationLogic *)((char *)this - 16));
}

{
  CLMicroLocationLogic::~CLMicroLocationLogic((CLMicroLocationLogic *)((char *)this - 24));
}

{
  CLMicroLocationLogic::~CLMicroLocationLogic((CLMicroLocationLogic *)((char *)this - 32));
}

{
  CLMicroLocationLogic::~CLMicroLocationLogic((CLMicroLocationLogic *)((char *)this - 40));
}

{
  CLMicroLocationLogic::~CLMicroLocationLogic((CLMicroLocationLogic *)((char *)this - 8));
  JUMPOUT(0x2426A04D4);
}

{
  CLMicroLocationLogic::~CLMicroLocationLogic((CLMicroLocationLogic *)((char *)this - 16));
  JUMPOUT(0x2426A04D4);
}

{
  CLMicroLocationLogic::~CLMicroLocationLogic((CLMicroLocationLogic *)((char *)this - 24));
  JUMPOUT(0x2426A04D4);
}

{
  CLMicroLocationLogic::~CLMicroLocationLogic((CLMicroLocationLogic *)((char *)this - 32));
  JUMPOUT(0x2426A04D4);
}

{
  CLMicroLocationLogic::~CLMicroLocationLogic((CLMicroLocationLogic *)((char *)this - 40));
  JUMPOUT(0x2426A04D4);
}

_QWORD *CLMicroLocationLogic::setWifiLink(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _QWORD *result;
  uint64_t v4;
  _BYTE v5[24];
  _BYTE *v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v2 = a1 + 712;
  std::__function::__value_func<ULWiFiScanProvider * ()(objc_object  {objcproto26ULWiFiScanProviderDelegate}*)>::__value_func[abi:ne180100]((uint64_t)v5, a2);
  CLMicroLocationSensorsLogic::setWifiLink(v2, (uint64_t)v5);
  result = v6;
  if (v6 == v5)
  {
    v4 = 4;
    result = v5;
  }
  else
  {
    if (!v6)
      return result;
    v4 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v4))();
}

void sub_2419E7944(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13)
{
  char *v13;
  char *v15;
  uint64_t v16;

  v15 = a13;
  if (a13 == v13)
  {
    v16 = 4;
    v15 = &a10;
  }
  else
  {
    if (!a13)
      goto LABEL_6;
    v16 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v15 + 8 * v16))();
LABEL_6:
  _Unwind_Resume(exception_object);
}

uint64_t CLMicroLocationLogic::setBleLink(uint64_t a1, uint64_t a2)
{
  return CLMicroLocationSensorsLogic::setBleLink(a1 + 712, a2);
}

uint64_t CLMicroLocationLogic::setUwbLink(uint64_t a1, uint64_t a2)
{
  return CLMicroLocationSensorsLogic::setUwbLink(a1 + 712, a2);
}

_QWORD *CLMicroLocationLogic::setOdometryLink(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _QWORD *result;
  uint64_t v4;
  _BYTE v5[24];
  _BYTE *v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v2 = a1 + 712;
  std::__function::__value_func<ULOdometryProvider * ()(objc_object  {objcproto26ULOdometryProviderDelegate}*)>::__value_func[abi:ne180100]((uint64_t)v5, a2);
  CLMicroLocationSensorsLogic::setOdometryLink(v2, (uint64_t)v5);
  result = v6;
  if (v6 == v5)
  {
    v4 = 4;
    result = v5;
  }
  else
  {
    if (!v6)
      return result;
    v4 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v4))();
}

void sub_2419E7A20(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13)
{
  char *v13;
  char *v15;
  uint64_t v16;

  v15 = a13;
  if (a13 == v13)
  {
    v16 = 4;
    v15 = &a10;
  }
  else
  {
    if (!a13)
      goto LABEL_6;
    v16 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v15 + 8 * v16))();
LABEL_6:
  _Unwind_Resume(exception_object);
}

uint64_t CLMicroLocationLogic::setMotionLink(uint64_t a1, uint64_t a2)
{
  return CLMicroLocationSensorsLogic::setMotionLink(a1 + 712, a2);
}

uint64_t CLMicroLocationLogic::setStopMotionLink(uint64_t a1, uint64_t a2)
{
  return CLMicroLocationSensorsLogic::setStopMotionLink(a1 + 712, a2);
}

uint64_t CLMicroLocationLogic::setCustomLoiRecordingFenceLink(uint64_t a1, uint64_t a2)
{
  return CLMicroLocationSensorsLogic::setCustomLoiRecordingFenceLink(a1 + 712, a2);
}

void CLMicroLocationLogic::setLoiBridge(id *this, CLMicroLocationLoiBridge *a2)
{
  CLMicroLocationLoiManager::setupWithLoiBridge(this + 253, a2);
}

void CLMicroLocationLogic::refreshSettings(CLMicroLocationLogic *this)
{
  NSObject *v2;
  uint8_t v3[16];

  if (onceToken_MicroLocation_Default != -1)
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_3);
  v2 = logObject_MicroLocation_Default;
  if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)v3 = 0;
    _os_log_impl(&dword_2419D9000, v2, OS_LOG_TYPE_DEFAULT, "CLMicroLocationLogic: Settings updated so updating wifi strategies, allowed anchor models, and checking enabled flags", v3, 2u);
  }
  CLMicroLocationLogic::reloadAnchorDeviceModelAllowedList(this);
  CLMicroLocationLogic::updateEnabled(this);
}

void CLMicroLocationLogic::updateEnabled(CLMicroLocationLogic *this)
{
  int v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  int v7;
  int v8;
  unsigned __int8 v9;
  unsigned __int8 v10;
  int v11;
  int v12;
  int v13;
  int v14;
  int v15;
  int v16;
  NSObject *v17;
  NSObject *v18;
  NSObject *v19;
  uint64_t v20;
  double v21;
  int v22;
  int v23[3];
  char v24;
  unsigned __int8 v25;
  __int16 v26;
  unsigned __int8 v27;
  char v28;
  unsigned __int8 v29;
  unsigned __int8 v30;
  int v31;
  unsigned __int8 v32;
  unsigned __int8 v33;
  unsigned __int8 v34;
  __int16 v35;
  unsigned __int8 v36;
  __int128 v37;
  uint8_t buf[4];
  int v39;
  __int16 v40;
  int v41;
  __int16 v42;
  int v43;
  __int16 v44;
  int v45;
  __int16 v46;
  int v47;
  __int16 v48;
  int v49;
  __int16 v50;
  int v51;
  __int16 v52;
  int v53;
  uint64_t v54;

  v54 = *MEMORY[0x24BDAC8D0];
  v2 = *((unsigned __int8 *)this + 48);
  +[ULDefaultsSingleton shared](ULDefaultsSingleton, "shared");
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v3, "defaultsDictionary");
  v4 = (void *)objc_claimAutoreleasedReturnValue();

  objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "ULEnabled");
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v4, "objectForKey:", v5);
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  if (v6 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
    v7 = objc_msgSend(v6, "BOOLValue");
  else
    v7 = objc_msgSend(MEMORY[0x24BDBD1C8], "BOOLValue");
  v8 = v7;

  v9 = *((_BYTE *)this + 122);
  v32 = v9;
  v10 = *((_BYTE *)this + 123);
  v33 = v10;
  v34 = *((_BYTE *)this + 50);
  v11 = *((unsigned __int8 *)this + 51);
  LOBYTE(v35) = *((_BYTE *)this + 51);
  v12 = *((unsigned __int8 *)this + 52);
  HIBYTE(v35) = *((_BYTE *)this + 52);
  v13 = *((unsigned __int8 *)this + 124);
  if (v34)
    v14 = v8;
  else
    v14 = 0;
  if (!v11)
    v14 = 0;
  if (!v12)
    v14 = 0;
  if (v10 | v9)
    v15 = 0;
  else
    v15 = v14;
  v36 = *((_BYTE *)this + 124);
  if (v13)
    v16 = v15;
  else
    v16 = 0;
  *((_BYTE *)this + 48) = v16;
  CLMiLoServiceManager::setMiLoEnabled((CLMicroLocationLogic *)((char *)this + 1768), v16, (uint64_t)&v32);
  if (onceToken_MicroLocation_Default != -1)
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_3);
  v17 = logObject_MicroLocation_Default;
  if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 67241984;
    v39 = v8;
    v40 = 1026;
    v41 = v34;
    v42 = 1026;
    v43 = v35;
    v44 = 1026;
    v45 = HIBYTE(v35);
    v46 = 1026;
    v47 = v32;
    v48 = 1026;
    v49 = v33;
    v50 = 1026;
    v51 = v36;
    v52 = 1026;
    v53 = v16;
    _os_log_impl(&dword_2419D9000, v17, OS_LOG_TYPE_DEFAULT, "Enabled state: microlocations defaults enabled: %{public}d; location services enabled: %{public}d; significant loc"
      "ations enabled: %{public}d; platform supported %{public}d; LowPowerMode %{public}d; AirplaneMode %{public}d; buddy"
      "Complete %{public}d; overall enabled: %{public}d",
      buf,
      0x32u);
  }
  if ((v16 & 1) != 0 || !v2)
  {
    if (!v2 && v16)
    {
      if (onceToken_MicroLocation_Default != -1)
        dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_3);
      v19 = logObject_MicroLocation_Default;
      if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl(&dword_2419D9000, v19, OS_LOG_TYPE_DEFAULT, "MicroLocations are now re-enabled. Clients should begin getting notifications again", buf, 2u);
      }
      ULDatabase::connectIfNecessary(*((ULDatabase **)this + 16));
    }
  }
  else
  {
    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_3);
    v18 = logObject_MicroLocation_Default;
    if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_2419D9000, v18, OS_LOG_TYPE_DEFAULT, "MicroLocations have been disabled. Clients will no longer get notifications until we are enabled again.", buf, 2u);
    }
  }
  if ((v2 != 0) != v16)
  {
    CLMicroLocationProto::EnabledStateUpdate::EnabledStateUpdate((uint64_t)v23);
    v24 = v8;
    v25 = v34;
    v26 = v35;
    v27 = v32;
    v30 = v33;
    v29 = v36;
    v31 |= 0x1FEu;
    v28 = v16;
    v22 = 0;
    boost::uuids::detail::random_provider_base::random_provider_base((boost::uuids::detail::random_provider_base *)&v22);
    *(_QWORD *)&v37 = boost::uuids::random_generator_pure::operator()((uint64_t)&v22);
    *((_QWORD *)&v37 + 1) = v20;
    v21 = cl::chrono::CFAbsoluteTimeClock::now();
    CLMicroLocationProtobufHelper::createLoggedEvent<CLMicroLocationProto::EnabledStateUpdate>(&v37, v23, (uint64_t)buf, v21);
    (*(void (**)(CLMicroLocationLogic *, uint8_t *))(*(_QWORD *)this + 120))(this, buf);
    CLMicroLocationProto::ReceivedEvent::~ReceivedEvent((CLMicroLocationProto::ReceivedEvent *)&v48);
    boost::uuids::detail::random_provider_base::destroy((boost::uuids::detail::random_provider_base *)&v22);
    CLMicroLocationProto::EnabledStateUpdate::~EnabledStateUpdate((CLMicroLocationProto::EnabledStateUpdate *)v23);
  }
}

void sub_2419E7EE0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void CLMicroLocationLogic::logState(CLMicroLocationLogic *this)
{
  NSObject *v2;
  _QWORD *v3;
  int v4;
  char *v5;
  int v6;
  int v7;
  void **v8;
  int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  int v18;
  int v19;
  _BOOL4 v20;
  void *__p[2];
  char v22;
  uint8_t buf[4];
  int v24;
  __int16 v25;
  const char *v26;
  __int16 v27;
  int v28;
  __int16 v29;
  _QWORD *v30;
  __int16 v31;
  char *v32;
  __int16 v33;
  int v34;
  __int16 v35;
  int v36;
  __int16 v37;
  void **v38;
  __int16 v39;
  int v40;
  __int16 v41;
  int v42;
  __int16 v43;
  int v44;
  __int16 v45;
  int v46;
  __int16 v47;
  int v48;
  __int16 v49;
  int v50;
  __int16 v51;
  int v52;
  __int16 v53;
  int v54;
  __int16 v55;
  int v56;
  __int16 v57;
  int v58;
  __int16 v59;
  int v60;
  __int16 v61;
  _BOOL4 v62;
  uint64_t v63;

  v63 = *MEMORY[0x24BDAC8D0];
  if (onceToken_MicroLocation_Default != -1)
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_3);
  v2 = (id)logObject_MicroLocation_Default;
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    v3 = (_QWORD *)((char *)this + 56);
    if (*((char *)this + 79) < 0)
      v3 = (_QWORD *)*v3;
    v4 = *((unsigned __int8 *)this + 48);
    v5 = (char *)operator new(0x28uLL);
    *(_QWORD *)(v5 + 29) = 0;
    *(_OWORD *)v5 = 0u;
    *((_OWORD *)v5 + 1) = 0u;
    boost::uuids::to_chars<char *>((uint64_t)this + 80, v5);
    v6 = *((unsigned __int8 *)this + 50);
    v7 = *((unsigned __int8 *)this + 51);
    CLMicroLocationUtils::scanActivityToString(*((_BYTE *)this + 53), __p);
    if (v22 >= 0)
      v8 = __p;
    else
      v8 = (void **)__p[0];
    v9 = *((_DWORD *)this + 25);
    v10 = *((_DWORD *)this + 26);
    v11 = *((unsigned __int8 *)this + 108);
    v12 = *((unsigned __int8 *)this + 125);
    v13 = *((unsigned __int8 *)this + 120);
    v14 = *((_DWORD *)this + 28);
    v15 = *((_DWORD *)this + 29);
    v16 = *((unsigned __int8 *)this + 121);
    v17 = *((unsigned __int8 *)this + 122);
    v18 = *((unsigned __int8 *)this + 123);
    v19 = *((unsigned __int8 *)this + 124);
    v20 = *((_BYTE *)this + 126) == 0;
    *(_DWORD *)buf = 68293635;
    v24 = 0;
    v25 = 2082;
    v26 = "";
    v27 = 1026;
    v28 = v4;
    v29 = 2081;
    v30 = v3;
    v31 = 2081;
    v32 = v5;
    v33 = 1026;
    v34 = v6;
    v35 = 1026;
    v36 = v7;
    v37 = 2081;
    v38 = v8;
    v39 = 1026;
    v40 = v9;
    v41 = 1026;
    v42 = v10;
    v43 = 1026;
    v44 = v11;
    v45 = 1026;
    v46 = v12;
    v47 = 1026;
    v48 = v13;
    v49 = 1026;
    v50 = v14;
    v51 = 1026;
    v52 = v15;
    v53 = 1026;
    v54 = v16;
    v55 = 1026;
    v56 = v17;
    v57 = 1026;
    v58 = v18;
    v59 = 1026;
    v60 = v19;
    v61 = 1026;
    v62 = v20;
    _os_log_impl(&dword_2419D9000, v2, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLMicroLocationLogic State\", \"enabled\":%{public}hhd, \"LOI Type\":%{private, location:escape_only}s, \"LOI ID\":%{private, location:escape_only}s, \"locationServicesEnabled\":%{public}hhd, \"significantLocationsEnabled\":%{public}hhd, \"ScanActivity\":%{private, location:escape_only}s, \"Localizing Counter\":%{public}d, \"Recording Counter\":%{public}d, \"displayOn\":%{public}hhd, \"isOnLockScreen\":%{public}hhd, \"isWiFiErrorRetryEnabled\":%{public}hhd, \"WiFi Error Retry Counter\":%{public}d, \"WiFi Error Retry Disabled Period Counter\":%{public}d, \"isLowNumberOfObservation\":%{public}hhd, \"isLowPowerMode\":%{public}hhd, \"isAirplaneMode\":%{public}hhd, \"isBuddyComplete\":%{public}hhd, \"isBluetoothDisabled\":%{public}hhd}", buf, 0x8Au);
    if (v22 < 0)
      operator delete(__p[0]);
    operator delete(v5);
  }

  CLMiLoServiceManager::logState((CLMicroLocationLogic *)((char *)this + 1768));
}

void sub_2419E81A0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  operator delete(v2);

  _Unwind_Resume(a1);
}

uint64_t CLMicroLocationLogic::getAnchorDeviceModelAllowedList(CLMicroLocationLogic *this)
{
  return (uint64_t)this + 2600;
}

uint64_t CLMicroLocationLogic::donateTruthTagLabelForRecordingEventsBetweenDates(uint64_t a1, const std::string *a2, void *a3, void *a4, void *a5)
{
  id v9;
  id v10;
  id v11;
  NSObject *v12;
  const std::string *v13;
  uint64_t v14;
  _DWORD v16[2];
  __int16 v17;
  const char *v18;
  __int16 v19;
  const std::string *v20;
  uint64_t v21;

  v21 = *MEMORY[0x24BDAC8D0];
  v9 = a3;
  v10 = a4;
  v11 = a5;
  if (onceToken_MicroLocation_Default != -1)
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_3);
  v12 = logObject_MicroLocation_Default;
  if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT))
  {
    if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v13 = a2;
    else
      v13 = (const std::string *)a2->__r_.__value_.__r.__words[0];
    v16[0] = 68289282;
    v16[1] = 0;
    v17 = 2082;
    v18 = "";
    v19 = 2082;
    v20 = v13;
    _os_log_impl(&dword_2419D9000, v12, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLMicroLocationLogic: client request donate truth label (time window based)\", \"client\":%{public, location:escape_only}s}", (uint8_t *)v16, 0x1Cu);
  }
  v14 = CLMicroLocationRecorder::recordTruthLabelBetweenDates(a1 + 664, a2, v9, v10, v11);

  return v14;
}

void sub_2419E8328(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

uint64_t CLMicroLocationLogic::createInternalLocalizationEvent@<X0>(uint64_t a1@<X8>)
{
  uint64_t v4;
  uint64_t v5;
  _QWORD *v6;
  int v7;
  _QWORD *v8;
  int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  v10 = 0;
  boost::uuids::detail::random_provider_base::random_provider_base((boost::uuids::detail::random_provider_base *)&v10);
  v11 = boost::uuids::random_generator_pure::operator()((uint64_t)&v10);
  v12 = v4;
  boost::uuids::detail::random_provider_base::destroy((boost::uuids::detail::random_provider_base *)&v10);
  CLMicroLocationProto::ReceivedEventAction::ReceivedEventAction((CLMicroLocationProto::ReceivedEventAction *)a1);
  *(_DWORD *)(a1 + 44) |= 4u;
  v5 = MEMORY[0x24BEDD958];
  if (*(_QWORD *)(a1 + 16) == MEMORY[0x24BEDD958])
  {
    v6 = (_QWORD *)operator new();
    *v6 = 0;
    v6[1] = 0;
    v6[2] = 0;
    *(_QWORD *)(a1 + 16) = v6;
  }
  MEMORY[0x2426A02C4]();
  if (!CLMicroLocationProto::ReceivedEventActionType_IsValid((CLMicroLocationProto *)1))
    __assert_rtn("set_receivedeventactiontype", "microlocation.pb.h", 13294, "::CLMicroLocationProto::ReceivedEventActionType_IsValid(value)");
  v7 = *(_DWORD *)(a1 + 44);
  *(_DWORD *)(a1 + 12) = 1;
  *(_DWORD *)(a1 + 44) = v7 | 0xA;
  if (*(_QWORD *)(a1 + 24) == v5)
  {
    v8 = (_QWORD *)operator new();
    *v8 = 0;
    v8[1] = 0;
    v8[2] = 0;
    *(_QWORD *)(a1 + 24) = v8;
  }
  return MEMORY[0x2426A02D0]();
}

void sub_2419E849C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9, char a10)
{
  boost::uuids::detail::random_provider_base::destroy((boost::uuids::detail::random_provider_base *)&a10);
  _Unwind_Resume(a1);
}

uint64_t CLMicroLocationLogic::logEvent(CLMicroLocationLogic *this, const Entry *a2)
{
  return (*(uint64_t (**)(_QWORD, const Entry *))(**((_QWORD **)this + 323) + 72))(*((_QWORD *)this + 323), a2);
}

uint64_t `non-virtual thunk to'CLMicroLocationLogic::logEvent(CLMicroLocationLogic *this, const Entry *a2)
{
  return (*(uint64_t (**)(_QWORD, const Entry *))(**((_QWORD **)this + 322) + 72))(*((_QWORD *)this + 322), a2);
}

{
  return (*(uint64_t (**)(_QWORD, const Entry *))(**((_QWORD **)this + 321) + 72))(*((_QWORD *)this + 321), a2);
}

void CLMicroLocationLogic::onStartRecordingOrLocalizing(uint64_t a1, const CLMicroLocationProto::RecordingEvent *a2, uint64_t a3, uint64_t *a4, void *a5)
{
  id v9;
  char v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  double v14;
  NSObject *v15;
  void *p_p;
  NSObject *v17;
  NSObject *v18;
  NSObject *v19;
  NSObject *v20;
  NSObject *v21;
  std::string v22;
  void *__p;
  _BYTE v24[10];
  __int16 v25;
  const char *v26;
  __int16 v27;
  const char *v28;
  uint8_t buf[4];
  void *v30;
  int v31;
  int v32;
  __int128 v33;
  char v34;
  __int128 v35;
  char v36;
  uint64_t v37;
  uuid v38;
  uuid v39;

  v37 = *MEMORY[0x24BDAC8D0];
  v9 = a5;
  if (!*(_BYTE *)(a1 + 48))
  {
    _CLLogObjectForCategory_MicroLocation_Default();
    v17 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v17, OS_LOG_TYPE_FAULT))
    {
      __p = (void *)68289539;
      *(_WORD *)v24 = 2082;
      *(_QWORD *)&v24[2] = "";
      v25 = 2082;
      v26 = "assert";
      v27 = 2081;
      v28 = "fState.enabled()";
      _os_log_impl(&dword_2419D9000, v17, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"MiLo must be enabled\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", (uint8_t *)&__p, 0x26u);
    }

    _CLLogObjectForCategory_MicroLocation_Default();
    v18 = objc_claimAutoreleasedReturnValue();
    if (os_signpost_enabled(v18))
    {
      __p = (void *)68289539;
      *(_WORD *)v24 = 2082;
      *(_QWORD *)&v24[2] = "";
      v25 = 2082;
      v26 = "assert";
      v27 = 2081;
      v28 = "fState.enabled()";
      _os_signpost_emit_with_name_impl(&dword_2419D9000, v18, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "MiLo must be enabled", "{\"msg%{public}.0s\":\"MiLo must be enabled\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", (uint8_t *)&__p, 0x26u);
    }

    _CLLogObjectForCategory_MicroLocation_Default();
    v19 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v19, OS_LOG_TYPE_INFO))
    {
      __p = (void *)68289539;
      *(_WORD *)v24 = 2082;
      *(_QWORD *)&v24[2] = "";
      v25 = 2082;
      v26 = "assert";
      v27 = 2081;
      v28 = "fState.enabled()";
      _os_log_impl(&dword_2419D9000, v19, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"MiLo must be enabled\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", (uint8_t *)&__p, 0x26u);
    }
LABEL_39:

    abort_report_np();
    __break(1u);
  }
  v10 = (_DWORD)a3 == 1;
  if ((a3 - 3) <= 0xFDu)
  {
    _CLLogObjectForCategory_MicroLocation_Default();
    v20 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v20, OS_LOG_TYPE_FAULT))
    {
      __p = (void *)68289539;
      *(_WORD *)v24 = 2082;
      *(_QWORD *)&v24[2] = "";
      v25 = 2082;
      v26 = "assert";
      v27 = 2081;
      v28 = "scanActivity == ScanActivity::Recording || scanActivity == ScanActivity::Localizing";
      _os_log_impl(&dword_2419D9000, v20, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Must contain valid scan activity\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", (uint8_t *)&__p, 0x26u);
    }

    _CLLogObjectForCategory_MicroLocation_Default();
    v21 = objc_claimAutoreleasedReturnValue();
    if (os_signpost_enabled(v21))
    {
      __p = (void *)68289539;
      *(_WORD *)v24 = 2082;
      *(_QWORD *)&v24[2] = "";
      v25 = 2082;
      v26 = "assert";
      v27 = 2081;
      v28 = "scanActivity == ScanActivity::Recording || scanActivity == ScanActivity::Localizing";
      _os_signpost_emit_with_name_impl(&dword_2419D9000, v21, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Must contain valid scan activity", "{\"msg%{public}.0s\":\"Must contain valid scan activity\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", (uint8_t *)&__p, 0x26u);
    }

    _CLLogObjectForCategory_MicroLocation_Default();
    v19 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v19, OS_LOG_TYPE_INFO))
    {
      __p = (void *)68289539;
      *(_WORD *)v24 = 2082;
      *(_QWORD *)&v24[2] = "";
      v25 = 2082;
      v26 = "assert";
      v27 = 2081;
      v28 = "scanActivity == ScanActivity::Recording || scanActivity == ScanActivity::Localizing";
      _os_log_impl(&dword_2419D9000, v19, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Must contain valid scan activity\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", (uint8_t *)&__p, 0x26u);
    }
    goto LABEL_39;
  }
  CLMicroLocationProtobufHelper::getTriggerUuidFromEvent((uint64_t)a2, &v35);
  if (*(char *)(a1 + 79) < 0)
    std::string::__init_copy_ctor_external(&v22, *(const std::string::value_type **)(a1 + 56), *(_QWORD *)(a1 + 64));
  else
    v22 = *(std::string *)(a1 + 56);
  v11 = *(_QWORD *)(a1 + 80);
  v12 = *(_QWORD *)(a1 + 88);
  v33 = v35;
  v34 = v36;
  CLMicroLocationRecorder::start(a1 + 664, (uint64_t)&v22, v11, v12, (uint64_t)&v33);
  if (SHIBYTE(v22.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v22.__r_.__value_.__l.__data_);
  CLMicroLocationRecorder::recordEvent((CLMicroLocationRecorder *)(a1 + 664), a2);
  CLMicroLocationLogic::State::setScanActivity(a1 + 48, a3);
  CLMicroLocationSensorsLogic::startRecordingOrLocalizing((_BYTE *)(a1 + 712), a2, a3, a4, v9);
  if ((_DWORD)a3 == 2)
  {
    v10 = ULSettings::get<ULSettings::LocalizeWithRecordingMeasurements>();
    v13 = 2;
  }
  else
  {
    if ((*((_BYTE *)a2 + 140) & 4) != 0)
    {
LABEL_14:
      CLMicroLocationTriggerManager::getCurrentLocalizationUUID((CLMicroLocationTriggerManager *)(a1 + 1560), (__n128 *)&__p);
      if (!v24[8]
        || (*(_QWORD *)v39.var0 = __p,
            *(_QWORD *)&v39.var0[8] = *(_QWORD *)v24,
            CLMicroLocationLocalizationController::start((CLMicroLocationLocalizationController *)(a1 + 168), a2, v39),
            !v24[8]))
      {
        std::__throw_bad_optional_access[abi:ne180100]();
      }
      *(_QWORD *)v38.var0 = __p;
      *(_QWORD *)&v38.var0[8] = *(_QWORD *)v24;
      CLMiLoServiceManager::onLocalizationStart((CLMiLoServiceManager *)(a1 + 1768), v38);
      goto LABEL_17;
    }
    v13 = 4;
  }
  CLMicroLocationProto::ReceivedEventAction::ReceivedEventAction((CLMicroLocationProto::ReceivedEventAction *)buf);
  if (!CLMicroLocationProto::ReceivedEventActionType_IsValid((CLMicroLocationProto *)v13))
    __assert_rtn("set_receivedeventactiontype", "microlocation.pb.h", 13294, "::CLMicroLocationProto::ReceivedEventActionType_IsValid(value)");
  v32 |= 2u;
  v31 = v13;
  v14 = cl::chrono::CFAbsoluteTimeClock::now();
  CLMicroLocationProtobufHelper::createRecordingEvent<CLMicroLocationProto::ReceivedEventAction>((CLMicroLocationProto::RecordingEvent *)buf, 0, 0, 0, (CLMicroLocationProto *)3, (uint64_t)&__p, v14);
  CLMicroLocationRecorder::recordEvent((CLMicroLocationRecorder *)(a1 + 664), (const CLMicroLocationProto::RecordingEvent *)&__p);
  CLMicroLocationProto::RecordingEvent::~RecordingEvent((CLMicroLocationProto::RecordingEvent *)&__p);
  CLMicroLocationProto::ReceivedEventAction::~ReceivedEventAction((CLMicroLocationProto::ReceivedEventAction *)buf);
  if ((v10 & 1) != 0)
    goto LABEL_14;
LABEL_17:
  if (onceToken_MicroLocationQE_Default != -1)
    dispatch_once(&onceToken_MicroLocationQE_Default, &__block_literal_global_428);
  v15 = (id)logObject_MicroLocationQE_Default;
  if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
  {
    CLMicroLocationUtils::scanActivityToString(a3, &__p);
    if (SBYTE3(v26) >= 0)
      p_p = &__p;
    else
      p_p = __p;
    *(_DWORD *)buf = 136315138;
    v30 = p_p;
    _os_log_impl(&dword_2419D9000, v15, OS_LOG_TYPE_DEFAULT, "%s started", buf, 0xCu);
    if (SBYTE3(v26) < 0)
      operator delete(__p);
  }

}

void sub_2419E8B64(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, char a20)
{
  void *v20;
  void *v21;

  _Unwind_Resume(a1);
}

uint64_t ULSettings::get<ULSettings::LocalizeWithRecordingMeasurements>()
{
  void *v0;
  void *v1;
  void *v2;
  void *v3;
  uint64_t v4;
  uint64_t v5;

  +[ULDefaultsSingleton shared](ULDefaultsSingleton, "shared");
  v0 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v0, "defaultsDictionary");
  v1 = (void *)objc_claimAutoreleasedReturnValue();

  objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "ULLocalizeWithRecordingMeasurements");
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v1, "objectForKey:", v2);
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  if (v3 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
    v4 = objc_msgSend(v3, "BOOLValue");
  else
    v4 = objc_msgSend(MEMORY[0x24BDBD1C0], "BOOLValue");
  v5 = v4;

  return v5;
}

void sub_2419E8C94(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void CLMicroLocationProtobufHelper::createRecordingEvent<CLMicroLocationProto::ReceivedEventAction>(CLMicroLocationProto::RecordingEvent *a1@<X0>, CLMicroLocationProto *a2@<X1>, char a3@<W2>, char a4@<W3>, CLMicroLocationProto *a5@<X4>, uint64_t a6@<X8>, double a7@<D0>)
{
  unsigned int v14;
  int v15;
  const CLMicroLocationProto::ReceivedEventAction *v16;
  const char *v17;
  int v18;
  const char *v19;

  CLMicroLocationProto::RecordingEvent::RecordingEvent((CLMicroLocationProto::RecordingEvent *)a6);
  v14 = *((_DWORD *)a1 + 2);
  if (!CLMicroLocationProto::EventType_IsValid((CLMicroLocationProto *)v14))
  {
    v17 = "::CLMicroLocationProto::EventType_IsValid(value)";
    v18 = 20192;
    v19 = "set_eventtype";
    goto LABEL_10;
  }
  v15 = *(_DWORD *)(a6 + 140);
  *(_DWORD *)(a6 + 72) = v14;
  *(double *)(a6 + 8) = a7;
  *(_BYTE *)(a6 + 77) = a3;
  *(_DWORD *)(a6 + 140) = v15 | 0x2803;
  *(_BYTE *)(a6 + 76) = a4;
  if (!CLMicroLocationProto::ConfidenceLevel_IsValid(a5))
  {
    v17 = "::CLMicroLocationProto::ConfidenceLevel_IsValid(value)";
    v18 = 20701;
    v19 = "set_confidencelevel";
    goto LABEL_10;
  }
  *(_DWORD *)(a6 + 140) |= 0x4000u;
  *(_DWORD *)(a6 + 120) = (_DWORD)a5;
  if (((unint64_t)a2 & 0xFF00000000) != 0)
  {
    if (CLMicroLocationProto::MotionState_IsValid(a2))
    {
      *(_DWORD *)(a6 + 140) |= 0x20000u;
      *(_DWORD *)(a6 + 124) = (_DWORD)a2;
      goto LABEL_6;
    }
    v17 = "::CLMicroLocationProto::MotionState_IsValid(value)";
    v18 = 20793;
    v19 = "set_motionstate";
LABEL_10:
    __assert_rtn(v19, "microlocation.pb.h", v18, v17);
  }
LABEL_6:
  CLMicroLocationProtobufHelper::setSpecificRecordingEvent((CLMicroLocationProtobufHelper *)a6, a1, v16);
}

void sub_2419E8DFC(_Unwind_Exception *a1)
{
  CLMicroLocationProto::RecordingEvent *v1;

  CLMicroLocationProto::RecordingEvent::~RecordingEvent(v1);
  _Unwind_Resume(a1);
}

void `non-virtual thunk to'CLMicroLocationLogic::onStartRecordingOrLocalizing(uint64_t a1, const CLMicroLocationProto::RecordingEvent *a2, uint64_t a3, uint64_t *a4, void *a5)
{
  CLMicroLocationLogic::onStartRecordingOrLocalizing(a1 - 8, a2, a3, a4, a5);
}

void CLMicroLocationLogic::onRequestInProgress(CLMicroLocationLogic *this, const CLMicroLocationProto::RecordingEvent *a2, int a3)
{
  uuid v5;
  char v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  CLMicroLocationRecorder::recordEvent((CLMicroLocationLogic *)((char *)this + 664), a2);
  if (a3)
  {
    CLMicroLocationTriggerManager::getCurrentLocalizationUUID((CLMicroLocationLogic *)((char *)this + 1560), (__n128 *)&v5);
    if (v6)
      CLMicroLocationLocalizationController::onStopMotion((CLMicroLocationLogic *)((char *)this + 168), &v5);
  }
}

void `non-virtual thunk to'CLMicroLocationLogic::onRequestInProgress(CLMicroLocationLogic *this, const CLMicroLocationProto::RecordingEvent *a2, int a3)
{
  CLMicroLocationLogic::onRequestInProgress((CLMicroLocationLogic *)((char *)this - 8), a2, a3);
}

void CLMicroLocationLogic::onRequestPending(CLMicroLocationLogic *this, const CLMicroLocationProto::RecordingEvent *a2)
{
  CLMicroLocationRecorder::addPendingRecordEvent((CLMicroLocationLogic *)((char *)this + 664), a2);
}

void `non-virtual thunk to'CLMicroLocationLogic::onRequestPending(CLMicroLocationLogic *this, const CLMicroLocationProto::RecordingEvent *a2)
{
  CLMicroLocationRecorder::addPendingRecordEvent((CLMicroLocationLogic *)((char *)this + 656), a2);
}

void CLMicroLocationLogic::onRequestInterrupted(uint64_t a1, int a2)
{
  int v4;
  _QWORD v5[3];
  uint64_t *v6;
  _QWORD *v7[2];
  int v8;

  CLMicroLocationSensorsLogic::onRecordingOrLocalizingInterrupted((CLMicroLocationSensorsLogic *)(a1 + 712));
  if (a2 == 2)
  {
    v7[0] = 0;
    v7[1] = 0;
    memset(v5, 0, sizeof(v5));
    v6 = (uint64_t *)v7;
    v8 = 3;
    v4 = 3;
    std::__tree<CLMicroLocationRecordingCompletionMetaInformation::RecordingError>::__emplace_unique_key_args<CLMicroLocationRecordingCompletionMetaInformation::RecordingError,CLMicroLocationRecordingCompletionMetaInformation::RecordingError>(&v6, &v4, &v4);
    CLMicroLocationLogic::stopRecording(a1, (uint64_t)v5);
    std::__tree<std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>,std::__map_value_compare<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>,std::less<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes>,true>,std::allocator<std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>>>::destroy((uint64_t)&v6, v7[0]);
  }
  else
  {
    CLMicroLocationLogic::stopLocalizing(a1, 2u);
  }
}

void sub_2419E8F4C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, _QWORD *a14)
{
  uint64_t v14;

  std::__tree<std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>,std::__map_value_compare<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>,std::less<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes>,true>,std::allocator<std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>>>::destroy(v14, a14);
  _Unwind_Resume(a1);
}

uint64_t CLMicroLocationLogic::stopRecording(uint64_t a1, uint64_t a2)
{
  uint64_t **ModelsVector;
  NSObject *v5;
  unsigned int v6;
  __CFString *v7;
  void **v9[3];
  uint8_t buf[8];
  uint64_t v11;
  uint64_t v12;
  unsigned int v13;
  void *__p;
  void *v15;
  uint64_t v16;
  uuid v17;
  char v18;
  uuid v19;
  char v20;
  uint64_t v21;

  v21 = *MEMORY[0x24BDAC8D0];
  CLMicroLocationSensorsLogic::onRecordingOrLocalizationStop((CLMicroLocationSensorsLogic *)(a1 + 712));
  CLMicroLocationLogic::ignoreSensorMeasurementsIfNecessary((CLMicroLocationLogic *)a1);
  if (CLMicroLocationSensorsLogic::State::receivedWiFiScanError((CLMicroLocationSensorsLogic::State *)(a1 + 720)))
  {
    *(_DWORD *)buf = 0;
    std::__tree<CLMicroLocationRecordingCompletionMetaInformation::RecordingError>::__emplace_unique_key_args<CLMicroLocationRecordingCompletionMetaInformation::RecordingError,CLMicroLocationRecordingCompletionMetaInformation::RecordingError>((uint64_t **)(a2 + 24), (int *)buf, buf);
  }
  if (*(_DWORD *)(a2 + 48) == 4)
  {
    CLMicroLocationFingerprintConfiguration::getRecordingConfigurationFromSettings((uint64_t)buf);
    CLMicroLocationRecorder::updateFingerprintMetaInfoOfCurrentRecording(a1 + 664, (unint64_t *)buf, a2);
    std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>>>::~__hash_table((uint64_t)&v12);
  }
  if (ULSettings::get<ULSettings::LocalizeWithRecordingMeasurements>())
  {
    CLMicroLocationTriggerManager::getCurrentLocalizationUUID((CLMicroLocationTriggerManager *)(a1 + 1560), (__n128 *)&v19);
    v17 = v19;
    v18 = v20;
    *(_QWORD *)buf = 0;
    v11 = 0;
    v12 = 0;
    memset(v9, 0, sizeof(v9));
    CLMicroLocationLogic::updateConfidenceAndReasonsOfLocalizationRequestIfNeeded(a1, (uint64_t)&v17, (uint64_t *)buf, (uint64_t *)v9, 0);
    __p = 0;
    v15 = 0;
    v16 = 0;
    v11 = 0;
    v12 = 0;
    *(_QWORD *)buf = 0;
    v13 = 0;
    if (!v20
      || (ModelsVector = (uint64_t **)CLMiLoServiceManager::getModelsVector((CLMiLoServiceManager *)(a1 + 1768)),
          CLMicroLocationLocalizationController::stop((_QWORD *)(a1 + 168), &v19, ModelsVector, (uint64_t)buf),
          !v20))
    {
      std::__throw_bad_optional_access[abi:ne180100]();
    }
    CLMiLoServiceManager::ingestLocalizationResults((CLMiLoServiceManager *)(a1 + 1768), (const CLMiLoServiceManager::LocalizationResults *)buf, v19);
    CLMicroLocationRecorder::setConfidenceAndReasons(a1 + 664, v13, (int **)&__p);
    if (__p)
    {
      v15 = __p;
      operator delete(__p);
    }
    v9[0] = (void **)buf;
    std::vector<CLMiLoServiceManager::LocalizationResultsPerModel>::__destroy_vector::operator()[abi:ne180100](v9);
  }
  CLMicroLocationRecorder::stop((CLMicroLocationRecorder *)(a1 + 664));
  *(_DWORD *)(a1 + 104) = 0;
  CLMicroLocationLogic::State::clearScanActivity((CLMicroLocationLogic::State *)(a1 + 48));
  if (onceToken_MicroLocationQE_Default != -1)
    dispatch_once(&onceToken_MicroLocationQE_Default, &__block_literal_global_428);
  v5 = logObject_MicroLocationQE_Default;
  if (os_log_type_enabled((os_log_t)logObject_MicroLocationQE_Default, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_2419D9000, v5, OS_LOG_TYPE_DEFAULT, "Recording stopped", buf, 2u);
  }
  CLMiLoServiceManager::didRecordingStop(a1 + 1768, a2);
  CLMicroLocationTriggerManager::stopTrigger(a1 + 1560, *(_DWORD *)(a2 + 48) != 2, (CLMicroLocationProto *)5);
  v6 = *(_DWORD *)(a2 + 48) - 1;
  if (v6 > 3)
    v7 = 0;
  else
    v7 = off_2511D2C30[v6];
  return (*(uint64_t (**)(_QWORD, __CFString *))(**(_QWORD **)(a1 + 2584) + 80))(*(_QWORD *)(a1 + 2584), v7);
}

void sub_2419E91D4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13)
{
  _Unwind_Resume(exception_object);
}

void CLMicroLocationLogic::stopLocalizing(uint64_t a1, unsigned int a2)
{
  uint64_t **ModelsVector;
  NSObject *v5;
  _BOOL4 isCurrentTriggerMotionTrigger;
  int isCurrentlyInMotion;
  NSObject *v8;
  void *v9;
  void *v10;
  void *v11;
  void *v12;
  double v13;
  double v14;
  double v15;
  double v16;
  double v17;
  _BOOL4 v18;
  NSObject *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unsigned int v23;
  void *__p;
  void *v25;
  uint64_t v26;
  uint8_t buf[8];
  __int128 v28;
  uuid v29;
  char v30;
  uuid v31;
  char v32;
  uint64_t v33;

  v33 = *MEMORY[0x24BDAC8D0];
  CLMicroLocationSensorsLogic::onRecordingOrLocalizationStop((CLMicroLocationSensorsLogic *)(a1 + 712));
  CLMicroLocationTriggerManager::getCurrentLocalizationUUID((CLMicroLocationTriggerManager *)(a1 + 1560), (__n128 *)&v31);
  CLMicroLocationLogic::ignoreSensorMeasurementsIfNecessary((CLMicroLocationLogic *)a1);
  v29 = v31;
  v30 = v32;
  *(_QWORD *)buf = 0;
  v28 = 0uLL;
  v20 = 0;
  v21 = 0;
  v22 = 0;
  CLMicroLocationLogic::updateConfidenceAndReasonsOfLocalizationRequestIfNeeded(a1, (uint64_t)&v29, (uint64_t *)buf, &v20, a2);
  __p = 0;
  v25 = 0;
  v26 = 0;
  v21 = 0;
  v22 = 0;
  v20 = 0;
  v23 = 0;
  if (!v32)
    goto LABEL_30;
  ModelsVector = (uint64_t **)CLMiLoServiceManager::getModelsVector((CLMiLoServiceManager *)(a1 + 1768));
  CLMicroLocationLocalizationController::stop((_QWORD *)(a1 + 168), &v31, ModelsVector, (uint64_t)&v20);
  CLMicroLocationRecorder::setConfidenceAndReasons(a1 + 664, v23, (int **)&__p);
  *(_DWORD *)(a1 + 100) = 0;
  CLMicroLocationLogic::State::clearScanActivity((CLMicroLocationLogic::State *)(a1 + 48));
  if (onceToken_MicroLocationQE_Default != -1)
    dispatch_once(&onceToken_MicroLocationQE_Default, &__block_literal_global_428);
  v5 = logObject_MicroLocationQE_Default;
  if (os_log_type_enabled((os_log_t)logObject_MicroLocationQE_Default, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_2419D9000, v5, OS_LOG_TYPE_DEFAULT, "Localization stopped", buf, 2u);
  }
  isCurrentTriggerMotionTrigger = CLMicroLocationTriggerManager::isCurrentTriggerMotionTrigger((CLMicroLocationTriggerManager *)(a1 + 1560));
  isCurrentlyInMotion = CLMicroLocationTriggerManager::isCurrentlyInMotion((CLMicroLocationTriggerManager *)(a1 + 1560));
  if (CLMicroLocationLogic::shouldRescheduleLocalization(a1, (uint64_t)&v20, isCurrentTriggerMotionTrigger, isCurrentlyInMotion))
  {
    if (*(_BYTE *)(a1 + 49) && !CLMicroLocationUtils::stopReasonIndicatesMiLoDisabled(a2))
    {
      +[ULDefaultsSingleton shared](ULDefaultsSingleton, "shared");
      v9 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v9, "defaultsDictionary");
      v10 = (void *)objc_claimAutoreleasedReturnValue();

      objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "ULLocalizationRescheduleDelay");
      v11 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v10, "objectForKey:", v11);
      v12 = (void *)objc_claimAutoreleasedReturnValue();
      if (v12 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
        objc_msgSend(v12, "doubleValue");
      else
        objc_msgSend(&unk_2511ED180, "doubleValue");
      v14 = v13;

      v15 = *(double *)(a1 + 1672);
      v16 = cl::chrono::CFAbsoluteTimeClock::now();
      v17 = 0.0;
      if (v16 - v15 < v14)
        v17 = (v14 - (v16 - v15)) * 1000.0;
      (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 288))(a1, (uint64_t)v17);
      CLMicroLocationLogic::createLocalizationTriggerWithOptAssociatedAccessPointInfo(a1, (uint64_t)"InternalClientLogic", 0, (uint64_t)buf, v16);
      CLMicroLocationTriggerManager::expectRescheduledTrigger((_BYTE *)(a1 + 1560), (const CLMicroLocationProto::RecordingEvent *)buf, 1);
      CLMicroLocationProto::RecordingEvent::~RecordingEvent((CLMicroLocationProto::RecordingEvent *)buf);
    }
    else
    {
      if (onceToken_MicroLocation_Default != -1)
        dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_3);
      v8 = logObject_MicroLocation_Default;
      if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 68289026;
        *(_DWORD *)&buf[4] = 0;
        LOWORD(v28) = 2082;
        *(_QWORD *)((char *)&v28 + 2) = "";
        _os_log_impl(&dword_2419D9000, v8, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"decided to reschedule a localization but not rescheduling because not spectating\"}", buf, 0x12u);
      }
    }
  }
  CLMicroLocationRecorder::stop((CLMicroLocationRecorder *)(a1 + 664));
  if (!v32)
LABEL_30:
    std::__throw_bad_optional_access[abi:ne180100]();
  CLMiLoServiceManager::ingestLocalizationResults((CLMiLoServiceManager *)(a1 + 1768), (const CLMiLoServiceManager::LocalizationResults *)&v20, v31);
  v18 = CLMicroLocationUtils::stopReasonIndicatesMiLoDisabled(a2);
  if ((CLMicroLocationTriggerManager::stopTrigger(a1 + 1560, !v18, (CLMicroLocationProto *)5) & 1) == 0)
  {
    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_3);
    v19 = logObject_MicroLocation_Default;
    if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_2419D9000, v19, OS_LOG_TYPE_DEFAULT, "Cannot serve queued record requests because we're no longer enabled", buf, 2u);
    }
    (*(void (**)(_QWORD, const __CFString *))(**(_QWORD **)(a1 + 2584) + 80))(*(_QWORD *)(a1 + 2584), CFSTR("requestMicroLocationRecordingScan failed internally, MicroLocation is not enabled"));
  }
  if (__p)
  {
    v25 = __p;
    operator delete(__p);
  }
  *(_QWORD *)buf = &v20;
  std::vector<CLMiLoServiceManager::LocalizationResultsPerModel>::__destroy_vector::operator()[abi:ne180100]((void ***)buf);
}

void sub_2419E966C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  void *v2;
  void *v3;
  void *v4;
  va_list va;

  va_start(va, a2);

  CLMiLoServiceManager::LocalizationResults::~LocalizationResults((CLMiLoServiceManager::LocalizationResults *)va);
  _Unwind_Resume(a1);
}

void `non-virtual thunk to'CLMicroLocationLogic::onRequestInterrupted(uint64_t a1, int a2)
{
  CLMicroLocationLogic::onRequestInterrupted(a1 - 8, a2);
}

void CLMicroLocationLogic::updateLocalizationConfidenceAndReasonsIfNeeded(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  NSObject *v6;
  NSObject *v7;
  int v8;
  int v9;
  __int16 v10;
  const char *v11;
  __n128 v12;
  char v13;
  __n128 v14;
  char v15;
  uint64_t v16;

  v16 = *MEMORY[0x24BDAC8D0];
  CLMicroLocationTriggerManager::getCurrentLocalizationUUID((CLMicroLocationTriggerManager *)(a1 + 1560), &v14);
  if (v15)
  {
    v12 = v14;
    v13 = v15;
    CLMicroLocationLogic::updateConfidenceAndReasonsOfLocalizationRequestIfNeeded(a1, (uint64_t)&v12, a2, a3, 0);
  }
  else
  {
    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_3);
    v6 = logObject_MicroLocation_Default;
    if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_ERROR))
    {
      v8 = 68289026;
      v9 = 0;
      v10 = 2082;
      v11 = "";
      _os_log_impl(&dword_2419D9000, v6, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"updateLocalizationConfidenceAndReasonsIfNeeded, no current localization\"}", (uint8_t *)&v8, 0x12u);
    }
    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_3);
    v7 = logObject_MicroLocation_Default;
    if (os_signpost_enabled((os_log_t)logObject_MicroLocation_Default))
    {
      v8 = 68289026;
      v9 = 0;
      v10 = 2082;
      v11 = "";
      _os_signpost_emit_with_name_impl(&dword_2419D9000, v7, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "updateLocalizationConfidenceAndReasonsIfNeeded, no current localization", "{\"msg%{public}.0s\":\"updateLocalizationConfidenceAndReasonsIfNeeded, no current localization\"}", (uint8_t *)&v8, 0x12u);
    }
  }
}

void CLMicroLocationLogic::updateConfidenceAndReasonsOfLocalizationRequestIfNeeded(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t *a4, unsigned int a5)
{
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  unint64_t v13;
  char *v14;
  char *v15;
  char *v16;
  char *v17;
  char *v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t v21;
  unint64_t v22;
  char *v23;
  char *v24;
  char *v25;
  int v26;
  NSObject *v27;
  char *v28;
  char *v29;
  NSObject *v30;
  NSObject *v31;
  char *v32;
  uint64_t v33;
  unint64_t v34;
  uint64_t v35;
  unint64_t v36;
  char *v37;
  char *v38;
  char *v39;
  int v40;
  uint64_t v41;
  int v42;
  char *v43;
  char *v44;
  char *v45;
  uint64_t v46;
  unint64_t v47;
  uint64_t v48;
  unint64_t v49;
  char *v50;
  char *v51;
  char *v52;
  int v53;
  NSObject *v54;
  uint64_t v55;
  uint64_t v56;
  unint64_t v57;
  char *v58;
  char *v59;
  char *v60;
  uint64_t v61;
  unint64_t v62;
  uint64_t v63;
  unint64_t v64;
  char *v65;
  char *v66;
  int v67;
  uint64_t v68;
  char *v69;
  char *v70;
  char *v71;
  uint64_t v72;
  unint64_t v73;
  uint64_t v74;
  unint64_t v75;
  char *v76;
  char *v77;
  int v78;
  NSObject *v79;
  int v80;
  void *v81;
  char *v82;
  char *v83;
  void *__p;
  char *v85;
  char *v86;
  uint8_t buf[4];
  int v88;
  __int16 v89;
  const char *v90;
  __int16 v91;
  uint64_t v92;
  __int16 v93;
  int v94;
  uint64_t v95;

  v95 = *MEMORY[0x24BDAC8D0];
  if (*(_BYTE *)(a2 + 16))
  {
    __p = 0;
    v85 = 0;
    v86 = 0;
    v81 = 0;
    v82 = 0;
    v83 = 0;
    if (CLMicroLocationSensorsLogic::State::receivedWiFiScanError((CLMicroLocationSensorsLogic::State *)(a1 + 720)))
    {
      v10 = (v85 - (_BYTE *)__p) >> 2;
      v11 = v10 + 1;
      if ((unint64_t)(v10 + 1) >> 62)
        std::vector<CLMicroLocationProto::ConfidenceReason>::__throw_length_error[abi:ne180100]();
      v12 = v86 - (_BYTE *)__p;
      if ((v86 - (_BYTE *)__p) >> 1 > v11)
        v11 = v12 >> 1;
      if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFFCLL)
        v13 = 0x3FFFFFFFFFFFFFFFLL;
      else
        v13 = v11;
      if (v13)
        v14 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<CLMicroLocationProto::ConfidenceReason>>((uint64_t)&v86, v13);
      else
        v14 = 0;
      v15 = &v14[4 * v10];
      *(_DWORD *)v15 = 0;
      __p = v15;
      v86 = &v14[4 * v13];
      v85 = v15 + 4;
      v16 = v82;
      if (v82 >= v83)
      {
        v18 = (char *)v81;
        v19 = (v82 - (_BYTE *)v81) >> 2;
        v20 = v19 + 1;
        if ((unint64_t)(v19 + 1) >> 62)
          std::vector<CLMicroLocationProto::ConfidenceReason>::__throw_length_error[abi:ne180100]();
        v21 = v83 - (_BYTE *)v81;
        if ((v83 - (_BYTE *)v81) >> 1 > v20)
          v20 = v21 >> 1;
        if ((unint64_t)v21 >= 0x7FFFFFFFFFFFFFFCLL)
          v22 = 0x3FFFFFFFFFFFFFFFLL;
        else
          v22 = v20;
        if (v22)
        {
          v23 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<CLMicroLocationProto::ConfidenceReason>>((uint64_t)&v83, v22);
          v18 = (char *)v81;
          v16 = v82;
        }
        else
        {
          v23 = 0;
        }
        v24 = &v23[4 * v19];
        v25 = &v23[4 * v22];
        *(_DWORD *)v24 = 0;
        v17 = v24 + 4;
        while (v16 != v18)
        {
          v26 = *((_DWORD *)v16 - 1);
          v16 -= 4;
          *((_DWORD *)v24 - 1) = v26;
          v24 -= 4;
        }
        v81 = v24;
        v82 = v17;
        v83 = v25;
        if (v18)
          operator delete(v18);
      }
      else
      {
        *(_DWORD *)v82 = 0;
        v17 = v16 + 4;
      }
      v82 = v17;
      if (onceToken_MicroLocation_Default != -1)
        dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_3);
      v27 = logObject_MicroLocation_Default;
      if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 68289026;
        v88 = 0;
        v89 = 2082;
        v90 = "";
        _os_log_impl(&dword_2419D9000, v27, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"update confidence of localization request due to wifi scan error\"}", buf, 0x12u);
      }
    }
    if (a5)
    {
      if ((CLMicroLocationUtils::stopReasonToConfidenceReason(a5) & 0xFF00000000) != 0)
      {
        v28 = v85;
        if (v85 >= v86)
        {
          v32 = (char *)__p;
          v33 = (v85 - (_BYTE *)__p) >> 2;
          v34 = v33 + 1;
          if ((unint64_t)(v33 + 1) >> 62)
            std::vector<CLMicroLocationProto::ConfidenceReason>::__throw_length_error[abi:ne180100]();
          v35 = v86 - (_BYTE *)__p;
          if ((v86 - (_BYTE *)__p) >> 1 > v34)
            v34 = v35 >> 1;
          if ((unint64_t)v35 >= 0x7FFFFFFFFFFFFFFCLL)
            v36 = 0x3FFFFFFFFFFFFFFFLL;
          else
            v36 = v34;
          if (v36)
          {
            v37 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<CLMicroLocationProto::ConfidenceReason>>((uint64_t)&v86, v36);
            v32 = (char *)__p;
            v28 = v85;
          }
          else
          {
            v37 = 0;
          }
          v38 = &v37[4 * v33];
          v39 = &v37[4 * v36];
          *(_DWORD *)v38 = 1;
          v29 = v38 + 4;
          while (v28 != v32)
          {
            v40 = *((_DWORD *)v28 - 1);
            v28 -= 4;
            *((_DWORD *)v38 - 1) = v40;
            v38 -= 4;
          }
          __p = v38;
          v85 = v29;
          v86 = v39;
          if (v32)
            operator delete(v32);
        }
        else
        {
          *(_DWORD *)v85 = 1;
          v29 = v28 + 4;
        }
        v85 = v29;
        v41 = CLMicroLocationUtils::stopReasonToConfidenceReason(a5);
        v42 = v41;
        if ((v41 & 0xFF00000000) == 0)
          std::__throw_bad_optional_access[abi:ne180100]();
        v43 = v82;
        if (v82 >= v83)
        {
          v45 = (char *)v81;
          v46 = (v82 - (_BYTE *)v81) >> 2;
          v47 = v46 + 1;
          if ((unint64_t)(v46 + 1) >> 62)
            std::vector<CLMicroLocationProto::ConfidenceReason>::__throw_length_error[abi:ne180100]();
          v48 = v83 - (_BYTE *)v81;
          if ((v83 - (_BYTE *)v81) >> 1 > v47)
            v47 = v48 >> 1;
          if ((unint64_t)v48 >= 0x7FFFFFFFFFFFFFFCLL)
            v49 = 0x3FFFFFFFFFFFFFFFLL;
          else
            v49 = v47;
          if (v49)
          {
            v50 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<CLMicroLocationProto::ConfidenceReason>>((uint64_t)&v83, v49);
            v45 = (char *)v81;
            v43 = v82;
          }
          else
          {
            v50 = 0;
          }
          v51 = &v50[4 * v46];
          v52 = &v50[4 * v49];
          *(_DWORD *)v51 = v42;
          v44 = v51 + 4;
          while (v43 != v45)
          {
            v53 = *((_DWORD *)v43 - 1);
            v43 -= 4;
            *((_DWORD *)v51 - 1) = v53;
            v51 -= 4;
          }
          v81 = v51;
          v82 = v44;
          v83 = v52;
          if (v45)
            operator delete(v45);
        }
        else
        {
          *(_DWORD *)v82 = v41;
          v44 = v43 + 4;
        }
        v82 = v44;
        if (onceToken_MicroLocation_Default != -1)
          dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_3);
        v54 = logObject_MicroLocation_Default;
        if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 68289538;
          v88 = 0;
          v89 = 2082;
          v90 = "";
          v91 = 2050;
          v92 = a5;
          v93 = 1026;
          v94 = 1;
          _os_log_impl(&dword_2419D9000, v54, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"update confidence of localization request due to localization stop reason\", \"stopReason\":%{public}lu, \"confidence level\":%{public}d}", buf, 0x22u);
        }
      }
      else
      {
        if (onceToken_MicroLocation_Default != -1)
          dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_3);
        v30 = logObject_MicroLocation_Default;
        if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 68289282;
          v88 = 0;
          v89 = 2082;
          v90 = "";
          v91 = 2050;
          v92 = a5;
          _os_log_impl(&dword_2419D9000, v30, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"stopReason != LocalizationStopReason::CompletedSuccessfully, but stopReasonToConfidenceReason returned nullopt! shouldn't happen\", \"stopReason\":%{public}lu}", buf, 0x1Cu);
        }
        if (onceToken_MicroLocation_Default != -1)
          dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_3);
        v31 = logObject_MicroLocation_Default;
        if (os_signpost_enabled((os_log_t)logObject_MicroLocation_Default))
        {
          *(_DWORD *)buf = 68289282;
          v88 = 0;
          v89 = 2082;
          v90 = "";
          v91 = 2050;
          v92 = a5;
          _os_signpost_emit_with_name_impl(&dword_2419D9000, v31, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "stopReason != LocalizationStopReason::CompletedSuccessfully, but stopReasonToConfidenceReason returned nullopt! shouldn't happen", "{\"msg%{public}.0s\":\"stopReason != LocalizationStopReason::CompletedSuccessfully, but stopReasonToConfidenceReason returned nullopt! shouldn't happen\", \"stopReason\":%{public}lu}", buf, 0x1Cu);
        }
      }
    }
    v56 = *a3;
    v55 = a3[1];
    if (*a3 != v55 && v55 - v56 == a4[1] - *a4)
    {
      v57 = 0;
      do
      {
        v58 = v85;
        if (v85 >= v86)
        {
          v60 = (char *)__p;
          v61 = (v85 - (_BYTE *)__p) >> 2;
          v62 = v61 + 1;
          if ((unint64_t)(v61 + 1) >> 62)
            std::vector<CLMicroLocationProto::ConfidenceReason>::__throw_length_error[abi:ne180100]();
          v63 = v86 - (_BYTE *)__p;
          if ((v86 - (_BYTE *)__p) >> 1 > v62)
            v62 = v63 >> 1;
          if ((unint64_t)v63 >= 0x7FFFFFFFFFFFFFFCLL)
            v64 = 0x3FFFFFFFFFFFFFFFLL;
          else
            v64 = v62;
          if (v64)
          {
            v65 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<CLMicroLocationProto::ConfidenceReason>>((uint64_t)&v86, v64);
            v60 = (char *)__p;
            v58 = v85;
          }
          else
          {
            v65 = 0;
          }
          v66 = &v65[4 * v61];
          *(_DWORD *)v66 = *(_DWORD *)(v56 + 4 * v57);
          v59 = v66 + 4;
          while (v58 != v60)
          {
            v67 = *((_DWORD *)v58 - 1);
            v58 -= 4;
            *((_DWORD *)v66 - 1) = v67;
            v66 -= 4;
          }
          __p = v66;
          v85 = v59;
          v86 = &v65[4 * v64];
          if (v60)
            operator delete(v60);
        }
        else
        {
          *(_DWORD *)v85 = *(_DWORD *)(v56 + 4 * v57);
          v59 = v58 + 4;
        }
        v85 = v59;
        v68 = *a4;
        v69 = v82;
        if (v82 >= v83)
        {
          v71 = (char *)v81;
          v72 = (v82 - (_BYTE *)v81) >> 2;
          v73 = v72 + 1;
          if ((unint64_t)(v72 + 1) >> 62)
            std::vector<CLMicroLocationProto::ConfidenceReason>::__throw_length_error[abi:ne180100]();
          v74 = v83 - (_BYTE *)v81;
          if ((v83 - (_BYTE *)v81) >> 1 > v73)
            v73 = v74 >> 1;
          if ((unint64_t)v74 >= 0x7FFFFFFFFFFFFFFCLL)
            v75 = 0x3FFFFFFFFFFFFFFFLL;
          else
            v75 = v73;
          if (v75)
          {
            v76 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<CLMicroLocationProto::ConfidenceReason>>((uint64_t)&v83, v75);
            v71 = (char *)v81;
            v69 = v82;
          }
          else
          {
            v76 = 0;
          }
          v77 = &v76[4 * v72];
          *(_DWORD *)v77 = *(_DWORD *)(v68 + 4 * v57);
          v70 = v77 + 4;
          while (v69 != v71)
          {
            v78 = *((_DWORD *)v69 - 1);
            v69 -= 4;
            *((_DWORD *)v77 - 1) = v78;
            v77 -= 4;
          }
          v81 = v77;
          v82 = v70;
          v83 = &v76[4 * v75];
          if (v71)
            operator delete(v71);
        }
        else
        {
          *(_DWORD *)v82 = *(_DWORD *)(v68 + 4 * v57);
          v70 = v69 + 4;
        }
        v82 = v70;
        if (onceToken_MicroLocation_Default != -1)
          dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_3);
        v79 = logObject_MicroLocation_Default;
        if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT))
        {
          v80 = *(_DWORD *)(*a3 + 4 * v57);
          *(_DWORD *)buf = 68289282;
          v88 = 0;
          v89 = 2082;
          v90 = "";
          v91 = 1026;
          LODWORD(v92) = v80;
          _os_log_impl(&dword_2419D9000, v79, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"update confidence of localization request\", \"confidence level\":%{public}d}", buf, 0x18u);
        }
        ++v57;
        v56 = *a3;
      }
      while (v57 < (a3[1] - *a3) >> 2);
    }
    if (!*(_BYTE *)(a2 + 16))
      std::__throw_bad_optional_access[abi:ne180100]();
    CLMicroLocationLocalizationController::setConfidenceAndReasons(a1 + 168, (_QWORD *)a2, (uint64_t *)&__p, &v81);
    if (v81)
    {
      v82 = (char *)v81;
      operator delete(v81);
    }
    if (__p)
    {
      v85 = (char *)__p;
      operator delete(__p);
    }
  }
}

void sub_2419EA16C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, uint64_t a17, void *a18, uint64_t a19)
{
  if (__p)
    operator delete(__p);
  if (a18)
    operator delete(a18);
  _Unwind_Resume(exception_object);
}

void `non-virtual thunk to'CLMicroLocationLogic::updateLocalizationConfidenceAndReasonsIfNeeded(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  CLMicroLocationLogic::updateLocalizationConfidenceAndReasonsIfNeeded(a1 - 8, a2, a3);
}

void CLMicroLocationLogic::startRescheduledLocalizationTimer(uint64_t a1, uint64_t a2)
{
  double v4;
  double v5;
  NSObject *v6;
  double v7;
  uint64_t v8;
  void *v9;
  _QWORD v10[5];
  uint8_t buf[4];
  int v12;
  __int16 v13;
  const char *v14;
  __int16 v15;
  double v16;
  __int16 v17;
  double v18;
  __int16 v19;
  double v20;
  uint64_t v21;

  v21 = *MEMORY[0x24BDAC8D0];
  if (!*(_QWORD *)(a1 + 2568))
  {
    v4 = cl::chrono::CFAbsoluteTimeClock::now();
    v5 = (double)a2;
    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_3);
    v6 = logObject_MicroLocation_Default;
    v7 = v5 / 1000.0;
    if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 68289794;
      v12 = 0;
      v13 = 2082;
      v14 = "";
      v15 = 2050;
      v16 = v4;
      v17 = 2050;
      v18 = v7;
      v19 = 2050;
      v20 = v7 + v4;
      _os_log_impl(&dword_2419D9000, v6, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"ULLogicAdapter, Starting Rescheduled Localization Timer\", \"now\":\"%{public}.3f\", \"durationInS\":\"%{public}.3f\", \"expected end time\":\"%{public}.3f\"}", buf, 0x30u);
    }
    v10[0] = MEMORY[0x24BDAC760];
    v10[1] = 3221225472;
    v10[2] = ___ZN20CLMicroLocationLogic33startRescheduledLocalizationTimerENSt3__16chrono8durationIxNS0_5ratioILl1ELl1000EEEEE_block_invoke;
    v10[3] = &__block_descriptor_40_e5_v8__0l;
    v10[4] = a1;
    +[ULTimerFactory timerOnPrimaryQueueWithInterval:repeats:block:](ULTimerFactory, "timerOnPrimaryQueueWithInterval:repeats:block:", 0, v10, v7);
    v8 = objc_claimAutoreleasedReturnValue();
    v9 = *(void **)(a1 + 2568);
    *(_QWORD *)(a1 + 2568) = v8;

  }
}

void ___ZN20CLMicroLocationLogic33startRescheduledLocalizationTimerENSt3__16chrono8durationIxNS0_5ratioILl1ELl1000EEEEE_block_invoke(uint64_t a1)
{
  CLMicroLocationLogic::onStopRescheduledLocalizationTimer(*(id **)(a1 + 32));
}

void CLMicroLocationLogic::onStopRescheduledLocalizationTimer(id *this)
{
  CFAbsoluteTime v2;
  NSObject *v3;
  id v4;
  _DWORD v5[2];
  __int16 v6;
  const char *v7;
  __int16 v8;
  CFAbsoluteTime v9;
  uint64_t v10;

  v10 = *MEMORY[0x24BDAC8D0];
  v2 = cl::chrono::CFAbsoluteTimeClock::now();
  if (onceToken_MicroLocation_Default != -1)
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_3);
  v3 = logObject_MicroLocation_Default;
  if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT))
  {
    v5[0] = 68289282;
    v5[1] = 0;
    v6 = 2082;
    v7 = "";
    v8 = 2050;
    v9 = v2;
    _os_log_impl(&dword_2419D9000, v3, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"ULLogicAdapter, Rescheduled Localization Timer stopped\", \"now\":\"%{public}.3f\"}", (uint8_t *)v5, 0x1Cu);
  }
  objc_msgSend(this[321], "invalidate");
  v4 = this[321];
  this[321] = 0;

  CLMicroLocationTriggerManager::onDelayedLocalizationTrigger((uint64_t)(this + 195), 2);
}

void `non-virtual thunk to'CLMicroLocationLogic::startRescheduledLocalizationTimer(uint64_t a1, uint64_t a2)
{
  CLMicroLocationLogic::startRescheduledLocalizationTimer(a1 - 8, a2);
}

void CLMicroLocationLogic::setFence(CLMicroLocationLogic *this, int a2)
{
  CLMicroLocationSensorsLogic::setFence((CLMicroLocationLogic *)((char *)this + 712), a2);
}

void `non-virtual thunk to'CLMicroLocationLogic::setFence(CLMicroLocationLogic *this, int a2)
{
  CLMicroLocationSensorsLogic::setFence((CLMicroLocationLogic *)((char *)this + 704), a2);
}

void CLMicroLocationLogic::startMotionBasedTriggers(CLMicroLocationLogic *this)
{
  CLMicroLocationSensorsLogic *v1;

  v1 = (CLMicroLocationLogic *)((char *)this + 712);
  CLMicroLocationSensorsLogic::startSpectatingMotion((CLMicroLocationLogic *)((char *)this + 712));
  CLMicroLocationSensorsLogic::setFence(v1, 0);
}

void `non-virtual thunk to'CLMicroLocationLogic::startMotionBasedTriggers(CLMicroLocationLogic *this)
{
  CLMicroLocationSensorsLogic *v1;

  v1 = (CLMicroLocationLogic *)((char *)this + 704);
  CLMicroLocationSensorsLogic::startSpectatingMotion((CLMicroLocationLogic *)((char *)this + 704));
  CLMicroLocationSensorsLogic::setFence(v1, 0);
}

void CLMicroLocationLogic::stopMotionBasedTriggers(CLMicroLocationLogic *this)
{
  CLMicroLocationSensorsLogic *v1;

  v1 = (CLMicroLocationLogic *)((char *)this + 712);
  CLMicroLocationSensorsLogic::stopMotionSM((CLMicroLocationLogic *)((char *)this + 712));
  CLMicroLocationSensorsLogic::stopSpectatingMotion(v1);
}

void `non-virtual thunk to'CLMicroLocationLogic::stopMotionBasedTriggers(CLMicroLocationLogic *this)
{
  CLMicroLocationSensorsLogic *v1;

  v1 = (CLMicroLocationLogic *)((char *)this + 704);
  CLMicroLocationSensorsLogic::stopMotionSM((CLMicroLocationLogic *)((char *)this + 704));
  CLMicroLocationSensorsLogic::stopSpectatingMotion(v1);
}

uint64_t CLMicroLocationLogic::ignoreSensorMeasurementsIfNecessary(CLMicroLocationLogic *this)
{
  int v2;
  int v3;
  int v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  int v9;
  uint64_t v10;
  uint64_t result;
  int v12;
  NSObject *v13;
  NSObject *v14;
  int v15;
  int v16;
  __int16 v17;
  const char *v18;
  __int16 v19;
  _BOOL4 v20;
  uint64_t v21;

  v21 = *MEMORY[0x24BDAC8D0];
  v2 = *((unsigned __int8 *)this + 53);
  if (v2 == 1)
  {
    v3 = 1;
  }
  else if (v2 == 2)
  {
    v3 = ULSettings::get<ULSettings::LocalizeWithRecordingMeasurements>();
  }
  else
  {
    v3 = 0;
  }
  v4 = *((unsigned __int8 *)this + 108);
  +[ULDefaultsSingleton shared](ULDefaultsSingleton, "shared");
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v5, "defaultsDictionary");
  v6 = (void *)objc_claimAutoreleasedReturnValue();

  objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "ULUwbRangeLocalizationMinValidSessionTime");
  v7 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v6, "objectForKey:", v7);
  v8 = (void *)objc_claimAutoreleasedReturnValue();
  if (v8 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
    v9 = objc_msgSend(v8, "intValue");
  else
    v9 = objc_msgSend(&unk_2511ED1C8, "intValue");
  v10 = v9;

  result = CLMicroLocationSensorsLogic::isNiSessionNotResumedForPeriod((uint64_t)this + 712, v10);
  v12 = result;
  if (!v4 || !*((_BYTE *)this + 126))
  {
    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_3);
    v13 = logObject_MicroLocation_Default;
    if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT))
    {
      v15 = 68289282;
      v16 = 0;
      v17 = 2082;
      v18 = "";
      v19 = 1026;
      v20 = v4 == 0;
      _os_log_impl(&dword_2419D9000, v13, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"Setting all BLE measurements as ignored\", \"displayStateOff\":%{public}hhd}", (uint8_t *)&v15, 0x18u);
    }
    if (v3)
    {
      CLMicroLocationTriggerManager::getCurrentLocalizationUUID((CLMicroLocationLogic *)((char *)this + 1560), (__n128 *)&v15);
      if (!BYTE6(v18))
        std::__throw_bad_optional_access[abi:ne180100]();
      CLMicroLocationLocalizationController::setIgnoreBleRssiMeasurements((CLMicroLocationLogic *)((char *)this + 168), (const uuid *)&v15);
    }
    result = CLMicroLocationRecorder::setIgnoreBleRssiMeasurements((uint64_t)this + 664);
  }
  if (v12)
  {
    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_3);
    v14 = logObject_MicroLocation_Default;
    if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT))
    {
      v15 = 68289282;
      v16 = 0;
      v17 = 2082;
      v18 = "";
      v19 = 1026;
      v20 = 1;
      _os_log_impl(&dword_2419D9000, v14, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"Setting all UWB measurements as ignored\", \"NI session not resumed\":%{public}hhd}", (uint8_t *)&v15, 0x18u);
    }
    if (v3)
    {
      CLMicroLocationTriggerManager::getCurrentLocalizationUUID((CLMicroLocationLogic *)((char *)this + 1560), (__n128 *)&v15);
      if (!BYTE6(v18))
        std::__throw_bad_optional_access[abi:ne180100]();
      CLMicroLocationLocalizationController::setIgnoreUwbRangeMeasurements((CLMicroLocationLogic *)((char *)this + 168), (const uuid *)&v15);
    }
    return CLMicroLocationRecorder::setIgnoreUwbRangeMeasurements((uint64_t)this + 664);
  }
  return result;
}

void sub_2419EA814(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

uint64_t CLMicroLocationLogic::shouldRescheduleLocalization(uint64_t a1, uint64_t a2, int a3, int a4)
{
  NSObject *v4;
  _BOOL4 v5;
  uint64_t v6;
  uint64_t v8;
  int v9;
  _DWORD *v10;
  _DWORD *v11;
  _DWORD *v12;
  int v14;
  NSObject *v16;
  NSObject *v17;
  _BOOL4 isLowLatencyMode;
  int *v19;
  int *i;
  int v21;
  NSObject *v22;
  void **v23;
  NSObject *v24;
  int v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  int v30;
  int v31;
  NSObject *v32;
  int v33;
  int v34;
  void *v35;
  void *v36;
  void *v37;
  void *v38;
  int v39;
  NSObject *v40;
  int v41;
  int v42;
  NSObject *v43;
  int v44;
  NSObject *v45;
  int v46;
  unsigned int v48;
  uint64_t v49;
  void *__p[2];
  char v51;
  uint8_t buf[4];
  int v53;
  __int16 v54;
  const char *v55;
  __int16 v56;
  _BYTE v57[10];
  __int16 v58;
  _BOOL4 v59;
  uint64_t v60;

  v60 = *MEMORY[0x24BDAC8D0];
  if (a4)
  {
    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_3);
    v4 = logObject_MicroLocation_Default;
    v5 = os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT);
    v6 = 0;
    if (v5)
    {
      *(_DWORD *)buf = 68289026;
      v53 = 0;
      v54 = 2082;
      v55 = "";
      _os_log_impl(&dword_2419D9000, v4, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"shouldRescheduleLocalization, will not reschedule, currently in motion\"}", buf, 0x12u);
      return 0;
    }
    return v6;
  }
  v8 = a1;
  v9 = *(_DWORD *)(a2 + 24);
  v11 = *(_DWORD **)(a2 + 32);
  v10 = *(_DWORD **)(a2 + 40);
  if (v11 == v10)
  {
    v14 = 0;
    v48 = 0;
  }
  else
  {
    v12 = *(_DWORD **)(a2 + 32);
    do
    {
      if (*v12 == 1)
        goto LABEL_11;
      ++v12;
    }
    while (v12 != v10);
    v12 = *(_DWORD **)(a2 + 40);
    do
    {
LABEL_11:
      if (*v11 <= 7u && ((1 << *v11) & 0x89) != 0)
      {
        v14 = 1;
        goto LABEL_18;
      }
      ++v11;
    }
    while (v11 != v10);
    v14 = 0;
LABEL_18:
    if (v9 == 3 || v12 == v10)
    {
      v48 = 0;
    }
    else if (a3)
    {
      if (onceToken_MicroLocation_Default != -1)
        dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_3);
      v16 = logObject_MicroLocation_Default;
      if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 68289026;
        v53 = 0;
        v54 = 2082;
        v55 = "";
        _os_log_impl(&dword_2419D9000, v16, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"shouldRescheduleLocalization, will not reschedule a motion trigger due to motion reason\"}", buf, 0x12u);
      }
      v48 = 0;
      v8 = a1;
    }
    else
    {
      if (onceToken_MicroLocation_Default != -1)
        dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_3);
      v17 = logObject_MicroLocation_Default;
      if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 68289026;
        v53 = 0;
        v54 = 2082;
        v55 = "";
        _os_log_impl(&dword_2419D9000, v17, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"shouldRescheduleLocalization, will reschedule a localization trigger due to motion during prediction\"}", buf, 0x12u);
      }
      v48 = 1;
    }
  }
  v49 = v8;
  isLowLatencyMode = CLMicroLocationTriggerManager::isLowLatencyMode((CLMicroLocationTriggerManager *)(v8 + 1560));
  if (((v9 != 3) & v14 & isLowLatencyMode) != 1)
  {
    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_3);
    v24 = logObject_MicroLocation_Default;
    if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 68289794;
      v53 = 0;
      v54 = 2082;
      v55 = "";
      v56 = 1026;
      *(_DWORD *)v57 = v9 != 3;
      *(_WORD *)&v57[4] = 1026;
      *(_DWORD *)&v57[6] = v14;
      v58 = 1026;
      v59 = isLowLatencyMode;
      _os_log_impl(&dword_2419D9000, v24, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"shouldRescheduleLocalization, result is valid or low latency mode is disabled, resetting retry states\", \"confidenceLevelAllowReschedule\":%{public}hhd, \"localizationRetryReasonExists\":%{public}hhd, \"isLowLatencyMode\":%{public}hhd}", buf, 0x24u);
    }
    *(_QWORD *)(v49 + 112) = 0;
    *(_BYTE *)(v49 + 120) = 1;
    return v48;
  }
  v19 = *(int **)(a2 + 32);
  for (i = *(int **)(a2 + 40); v19 != i; ++v19)
  {
    v21 = *v19;
    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_3);
    v22 = (id)logObject_MicroLocation_Default;
    if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
    {
      CLMicroLocationUtils::placeConfidenceReasonToString(v21, __p);
      v23 = __p;
      if (v51 < 0)
        v23 = (void **)__p[0];
      *(_DWORD *)buf = 68289282;
      v53 = 0;
      v54 = 2082;
      v55 = "";
      v56 = 2082;
      *(_QWORD *)v57 = v23;
      _os_log_impl(&dword_2419D9000, v22, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"shouldRescheduleLocalization, result contains reason:\", \"reason\":%{public, location:escape_only}s}", buf, 0x1Cu);
      if (v51 < 0)
        operator delete(__p[0]);
    }

  }
  if (!*(_BYTE *)(v49 + 120))
  {
    v34 = *(_DWORD *)(v49 + 116);
    *(_DWORD *)(v49 + 116) = v34 + 1;
    +[ULDefaultsSingleton shared](ULDefaultsSingleton, "shared");
    v35 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v35, "defaultsDictionary");
    v36 = (void *)objc_claimAutoreleasedReturnValue();

    objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "ULMaximumLocalizeNumRetryDisabledDueToWiFiError");
    v37 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v36, "objectForKey:", v37);
    v38 = (void *)objc_claimAutoreleasedReturnValue();
    if (v38 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
      v39 = objc_msgSend(v38, "intValue");
    else
      v39 = objc_msgSend(&unk_2511ED1B0, "intValue");
    v42 = v39;

    if (v34 >= v42)
    {
      if (onceToken_MicroLocation_Default != -1)
        dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_3);
      v45 = logObject_MicroLocation_Default;
      if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_INFO))
      {
        v46 = *(_DWORD *)(v49 + 116) - 1;
        *(_DWORD *)buf = 68289282;
        v53 = 0;
        v54 = 2082;
        v55 = "";
        v56 = 1026;
        *(_DWORD *)v57 = v46;
        _os_log_impl(&dword_2419D9000, v45, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"shouldRescheduleLocalization, reached invalid result retry disabled count limit\", \"retry disabled trigger count\":%{public}d}", buf, 0x18u);
      }
      *(_BYTE *)(v49 + 120) = 1;
      *(_DWORD *)(v49 + 116) = 0;
    }
    else
    {
      if (onceToken_MicroLocation_Default != -1)
        dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_3);
      v43 = logObject_MicroLocation_Default;
      if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_INFO))
      {
        v44 = *(_DWORD *)(v49 + 116);
        *(_DWORD *)buf = 68289282;
        v53 = 0;
        v54 = 2082;
        v55 = "";
        v56 = 1026;
        *(_DWORD *)v57 = v44;
        _os_log_impl(&dword_2419D9000, v43, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"shouldRescheduleLocalization, will not retry\", \"retry disabled trigger count\":%{public}d}", buf, 0x18u);
      }
    }
    return v48;
  }
  v25 = *(_DWORD *)(v49 + 112);
  *(_DWORD *)(v49 + 112) = v25 + 1;
  +[ULDefaultsSingleton shared](ULDefaultsSingleton, "shared");
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v26, "defaultsDictionary");
  v27 = (void *)objc_claimAutoreleasedReturnValue();

  objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "ULMaximumLocalizeNumRetryDueToWiFiError");
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v27, "objectForKey:", v28);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  if (v29 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
    v30 = objc_msgSend(v29, "intValue");
  else
    v30 = objc_msgSend(&unk_2511ED180, "intValue");
  v31 = v30;

  if (v25 >= v31)
  {
    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_3);
    v40 = logObject_MicroLocation_Default;
    if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_INFO))
    {
      v41 = *(_DWORD *)(v49 + 112) - 1;
      *(_DWORD *)buf = 68289282;
      v53 = 0;
      v54 = 2082;
      v55 = "";
      v56 = 1026;
      *(_DWORD *)v57 = v41;
      _os_log_impl(&dword_2419D9000, v40, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"shouldRescheduleLocalization, reached invalid result reschedule limit\", \"retried number\":%{public}d}", buf, 0x18u);
    }
    *(_BYTE *)(v49 + 120) = 0;
    *(_DWORD *)(v49 + 112) = 0;
    return v48;
  }
  if (onceToken_MicroLocation_Default != -1)
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_3);
  v32 = logObject_MicroLocation_Default;
  if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT))
  {
    v33 = *(_DWORD *)(v49 + 112);
    *(_DWORD *)buf = 68289282;
    v53 = 0;
    v54 = 2082;
    v55 = "";
    v56 = 1026;
    *(_DWORD *)v57 = v33;
    _os_log_impl(&dword_2419D9000, v32, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"shouldRescheduleLocalization, will reschedule a localization trigger due to invalid result\", \"retried count\":%{public}d}", buf, 0x18u);
  }
  return 1;
}

void sub_2419EB0FC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void CLMicroLocationLogic::createLocalizationTriggerWithOptAssociatedAccessPointInfo(uint64_t a1@<X0>, uint64_t a2@<X1>, CLMicroLocationProto *a3@<X2>, uint64_t a4@<X8>, double a5@<D0>)
{
  id *v10;
  void *v11;
  uint64_t v12;
  uint64_t v13;
  id v14;
  uint64_t v15;
  unint64_t v16;
  NSObject *v17;
  id v18;
  uint64_t v19;
  uint64_t v20;
  NSObject *v21;
  CLMacAddress v22;
  void *__p;
  __int16 v24;
  const char *v25;
  __int16 v26;
  uint64_t v27;
  __int16 v28;
  double v29;
  __int16 v30;
  uint64_t v31;
  uint64_t v32;

  v32 = *MEMORY[0x24BDAC8D0];
  CLMicroLocationLogic::createInternalLocalizationEvent((uint64_t)&__p);
  CLMicroLocationProtobufHelper::createRecordingEvent<CLMicroLocationProto::ReceivedEventAction>((CLMicroLocationProto::RecordingEvent *)&__p, a3, 0, 0, (CLMicroLocationProto *)3, a4, a5);
  CLMicroLocationProto::ReceivedEventAction::~ReceivedEventAction((CLMicroLocationProto::ReceivedEventAction *)&__p);
  v10 = (id *)(a1 + 720);
  if (CLMicroLocationSensorsLogic::State::isAssociatedToWifi((CLMicroLocationSensorsLogic::State *)v10))
  {
    CLMicroLocationSensorsLogic::State::currentAssociatedWiFiAPInfo(v10);
    v11 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)(a4 + 140) |= 0x10000u;
    v12 = *(_QWORD *)(a4 + 128);
    if (!v12)
    {
      v12 = operator new();
      CLMicroLocationProto::AssociatedAccessPointInfo::AssociatedAccessPointInfo(v12);
      *(_QWORD *)(a4 + 128) = v12;
    }
    v13 = objc_msgSend(v11, "RSSI");
    *(_DWORD *)(v12 + 24) |= 2u;
    *(float *)(v12 + 16) = (float)v13;
    objc_msgSend(v11, "BSSID");
    v14 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
    std::string::basic_string[abi:ne180100]<0>(&__p, (char *)objc_msgSend(v14, "UTF8String"));
    v22.var0 = CLMacAddress::newFromCLStr((uint64_t *)&__p);
    if (SBYTE3(v27) < 0)
      operator delete(__p);

    *(_DWORD *)(a4 + 140) |= 0x10000u;
    v15 = *(_QWORD *)(a4 + 128);
    if (!v15)
    {
      v15 = operator new();
      CLMicroLocationProto::AssociatedAccessPointInfo::AssociatedAccessPointInfo(v15);
      *(_QWORD *)(a4 + 128) = v15;
    }
    v16 = CLMacAddress::toUint64(&v22);
    *(_DWORD *)(v15 + 24) |= 1u;
    *(_QWORD *)(v15 + 8) = v16;
    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_3);
    v17 = (id)logObject_MicroLocation_Default;
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
    {
      objc_msgSend(v11, "BSSID");
      v18 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
      v19 = objc_msgSend(v18, "UTF8String");
      v20 = objc_msgSend(v11, "RSSI");
      __p = (void *)68289795;
      v24 = 2082;
      v25 = "";
      v26 = 2081;
      v27 = v19;
      v28 = 2050;
      v29 = (float)v20;
      v30 = 2082;
      v31 = a2;
      _os_log_impl(&dword_2419D9000, v17, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"set associated AP for a recording event\", \"MAC Address\":%{private, location:escape_only}s, \"Rssi\":\"%{public}f\", \"client name\":%{public, location:escape_only}s}", (uint8_t *)&__p, 0x30u);

    }
  }
  else
  {
    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_3);
    v21 = logObject_MicroLocation_Default;
    if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT))
    {
      __p = (void *)68289282;
      v24 = 2082;
      v25 = "";
      v26 = 2082;
      v27 = a2;
      _os_log_impl(&dword_2419D9000, v21, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"not set associated AP for a recording event, not associated\", \"client name\":%{public, location:escape_only}s}", (uint8_t *)&__p, 0x1Cu);
    }
  }
}

void sub_2419EB494(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  CLMicroLocationProto::RecordingEvent *v16;
  void *v17;
  uint64_t v18;

  MEMORY[0x2426A04D4](v18, 0x1081C40DCAC275BLL);

  CLMicroLocationProto::RecordingEvent::~RecordingEvent(v16);
  _Unwind_Resume(a1);
}

void CLMiLoServiceManager::LocalizationResults::~LocalizationResults(CLMiLoServiceManager::LocalizationResults *this)
{
  void *v2;
  void **v3;

  v2 = (void *)*((_QWORD *)this + 4);
  if (v2)
  {
    *((_QWORD *)this + 5) = v2;
    operator delete(v2);
  }
  v3 = (void **)this;
  std::vector<CLMiLoServiceManager::LocalizationResultsPerModel>::__destroy_vector::operator()[abi:ne180100](&v3);
}

CLMicroLocationProto::Measurement *CLMicroLocationLogic::onAvailableMeasurements(CLMicroLocationProto::Measurement *result, CLMicroLocationProto::Measurement **a2)
{
  CLMicroLocationProto::Measurement *v3;
  int v4;
  __int128 v5;
  __int128 v6;

  v3 = result;
  v4 = *((unsigned __int8 *)result + 53);
  if (v4 == 1)
  {
    CLMicroLocationRecorder::ScanMetadata::ScanMetadata((uint64_t)&v5, 0);
    CLMicroLocationRecorder::recordMeasurementBatch((uint64_t)v3 + 664, &v5, a2);
    return CLMicroLocationLocalizationController::update((CLMicroLocationProto::Measurement *)((char *)v3 + 168), (uint64_t)a2);
  }
  if (v4 == 2)
  {
    CLMicroLocationRecorder::ScanMetadata::ScanMetadata((uint64_t)&v6, 0);
    CLMicroLocationRecorder::recordMeasurementBatch((uint64_t)v3 + 664, &v6, a2);
    result = (CLMicroLocationProto::Measurement *)ULSettings::get<ULSettings::LocalizeWithRecordingMeasurements>();
    if ((result & 1) != 0)
      return CLMicroLocationLocalizationController::update((CLMicroLocationProto::Measurement *)((char *)v3 + 168), (uint64_t)a2);
  }
  return result;
}

void CLMicroLocationLogic::onScanActivityCompleted(NSObject *this, void **a2)
{
  uint64_t v4;
  double v5;
  int v6;
  NSObject *v7;
  void **v8;
  NSObject *v9;
  void **v10;
  void *__p[2];
  char v12;
  int v13;
  __int128 v14;
  uint8_t buf[8];
  _BYTE v16[32];
  const char *v17;
  int v18;
  uint64_t v19;

  v19 = *MEMORY[0x24BDAC8D0];
  v13 = 0;
  boost::uuids::detail::random_provider_base::random_provider_base((boost::uuids::detail::random_provider_base *)&v13);
  *(_QWORD *)&v14 = boost::uuids::random_generator_pure::operator()((uint64_t)&v13);
  *((_QWORD *)&v14 + 1) = v4;
  v5 = cl::chrono::CFAbsoluteTimeClock::now();
  CLMicroLocationProto::SensorsScanComplete::SensorsScanComplete((CLMicroLocationProto::SensorsScanComplete *)__p);
  CLMicroLocationProtobufHelper::createLoggedEvent<CLMicroLocationProto::SensorsScanComplete>(&v14, (int *)__p, (uint64_t)buf, v5);
  (*((void (**)(NSObject *, uint8_t *))this->isa + 15))(this, buf);
  CLMicroLocationProto::ReceivedEvent::~ReceivedEvent((CLMicroLocationProto::ReceivedEvent *)&v16[24]);
  CLMicroLocationProto::SensorsScanComplete::~SensorsScanComplete((CLMicroLocationProto::SensorsScanComplete *)__p);
  boost::uuids::detail::random_provider_base::destroy((boost::uuids::detail::random_provider_base *)&v13);
  v6 = BYTE5(this[6].isa);
  if (v6 == 1)
  {
    CLMicroLocationLogic::stopLocalizing((uint64_t)this, 0);
    goto LABEL_21;
  }
  if (v6 == 2)
    goto LABEL_19;
  if (!BYTE5(this[6].isa))
  {
    _CLLogObjectForCategory_MicroLocation_Default();
    v7 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_FAULT))
    {
      a2 = __p;
      CLMicroLocationUtils::scanActivityToString(0, __p);
      v8 = v12 >= 0 ? __p : (void **)__p[0];
      *(_DWORD *)buf = 68289795;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)v16 = 2082;
      *(_QWORD *)&v16[2] = "";
      *(_WORD *)&v16[10] = 2082;
      *(_QWORD *)&v16[12] = v8;
      *(_WORD *)&v16[20] = 2082;
      *(_QWORD *)&v16[22] = "assert";
      *(_WORD *)&v16[30] = 2081;
      v17 = "false";
      _os_log_impl(&dword_2419D9000, v7, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Invalid MiLo current activity\", \"state\":%{public, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x30u);
      if (v12 < 0)
        operator delete(__p[0]);
    }

    _CLLogObjectForCategory_MicroLocation_Default();
    v9 = objc_claimAutoreleasedReturnValue();
    if (os_signpost_enabled(v9))
    {
      a2 = __p;
      CLMicroLocationUtils::scanActivityToString(0, __p);
      v10 = v12 >= 0 ? __p : (void **)__p[0];
      *(_DWORD *)buf = 68289795;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)v16 = 2082;
      *(_QWORD *)&v16[2] = "";
      *(_WORD *)&v16[10] = 2082;
      *(_QWORD *)&v16[12] = v10;
      *(_WORD *)&v16[20] = 2082;
      *(_QWORD *)&v16[22] = "assert";
      *(_WORD *)&v16[30] = 2081;
      v17 = "false";
      _os_signpost_emit_with_name_impl(&dword_2419D9000, v9, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Invalid MiLo current activity", "{\"msg%{public}.0s\":\"Invalid MiLo current activity\", \"state\":%{public, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x30u);
      if (v12 < 0)
        operator delete(__p[0]);
    }

    _CLLogObjectForCategory_MicroLocation_Default();
    this = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(this, OS_LOG_TYPE_INFO))
    {
      CLMicroLocationUtils::scanActivityToString(0, __p);
      CLMicroLocationLogic::onScanActivityCompleted();
    }

    abort_report_np();
    __break(1u);
LABEL_19:
    *(_QWORD *)&v16[24] = 0;
    v17 = 0;
    *(_QWORD *)buf = 0;
    *(_QWORD *)v16 = 0;
    *(_QWORD *)&v16[8] = 0;
    *(_QWORD *)&v16[16] = &v16[24];
    v18 = 4;
    CLMicroLocationLogic::stopRecording((uint64_t)this, (uint64_t)buf);
    std::__tree<std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>,std::__map_value_compare<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>,std::less<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes>,true>,std::allocator<std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>>>::destroy((uint64_t)&v16[16], *(_QWORD **)&v16[24]);
  }
LABEL_21:
  CLMicroLocationLogic::sendScanEventPowerLog((uint64_t)this, v6, (CLMicroLocationProto::RecordingEvent *)a2);
}

void sub_2419EB954(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void CLMicroLocationProtobufHelper::createLoggedEvent<CLMicroLocationProto::SensorsScanComplete>(_OWORD *a1@<X0>, int *a2@<X1>, uint64_t a3@<X8>, double a4@<D0>)
{
  const CLMicroLocationProto::SensorsScanComplete *v8;
  _BYTE v9[304];

  CLMicroLocationProto::ReceivedEvent::ReceivedEvent((CLMicroLocationProto::ReceivedEvent *)v9);
  CLMicroLocationProtobufHelper::setSpecificLoggedEvent((CLMicroLocationProtobufHelper *)v9, (CLMicroLocationProto::ReceivedEvent *)a2, v8);
  CLMicroLocationLoggedEventsTable::Entry::Entry(a3, a1, a2[2], (CLMicroLocationProto::ReceivedEvent *)v9, a4);
  CLMicroLocationProto::ReceivedEvent::~ReceivedEvent((CLMicroLocationProto::ReceivedEvent *)v9);
}

void sub_2419EBA40(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  CLMicroLocationProto::ReceivedEvent::~ReceivedEvent((CLMicroLocationProto::ReceivedEvent *)&a9);
  _Unwind_Resume(a1);
}

void CLMicroLocationLogic::sendScanEventPowerLog(uint64_t a1, int a2, CLMicroLocationProto::RecordingEvent *a3)
{
  uint64_t v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;
  void *v10;
  void *v11;
  void *v12;
  void *v13;
  NSDictionary *v14;
  void *v15;
  void *v16;
  void *v17;
  void *v18;
  std::string __p;
  _QWORD v20[6];
  _QWORD v21[8];

  v21[6] = *MEMORY[0x24BDAC8D0];
  CLMicroLocationTriggerManager::getClientTypeStr(a3, &__p);
  v5 = CLMicroLocationTriggerManager::enumerateClientIdToTriggerType((uint64_t)&__p);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  memset(&__p, 0, sizeof(__p));
  objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "TriggerType", CLMicroLocationSensorsLogic::getPowerMetrics((CLMicroLocationSensorsLogic *)(a1 + 712), (__n128 *)&__p).n128_f64[0]);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  v20[0] = v18;
  objc_msgSend(MEMORY[0x24BDD16E0], "numberWithInt:", v5);
  v21[0] = objc_claimAutoreleasedReturnValue();
  v17 = (void *)v21[0];
  objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "NumLocalizations");
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  v20[1] = v16;
  objc_msgSend(MEMORY[0x24BDD16E0], "numberWithBool:", a2 == 1);
  v15 = (void *)objc_claimAutoreleasedReturnValue();
  v21[1] = v15;
  objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "NumRecordings");
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  v20[2] = v6;
  objc_msgSend(MEMORY[0x24BDD16E0], "numberWithBool:", a2 == 2);
  v7 = (void *)objc_claimAutoreleasedReturnValue();
  v21[2] = v7;
  objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "WiFiScanDuration");
  v8 = (void *)objc_claimAutoreleasedReturnValue();
  v20[3] = v8;
  objc_msgSend(MEMORY[0x24BDD16E0], "numberWithDouble:", *(double *)&__p.__r_.__value_.__l.__data_);
  v9 = (void *)objc_claimAutoreleasedReturnValue();
  v21[3] = v9;
  objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "BTScanDuration");
  v10 = (void *)objc_claimAutoreleasedReturnValue();
  v20[4] = v10;
  objc_msgSend(MEMORY[0x24BDD16E0], "numberWithDouble:", *(double *)&__p.__r_.__value_.__l.__size_);
  v11 = (void *)objc_claimAutoreleasedReturnValue();
  v21[4] = v11;
  objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "BleActiveScanRate");
  v12 = (void *)objc_claimAutoreleasedReturnValue();
  v20[5] = v12;
  objc_msgSend(MEMORY[0x24BDD16E0], "numberWithInt:", LODWORD(__p.__r_.__value_.__r.__words[2]));
  v13 = (void *)objc_claimAutoreleasedReturnValue();
  v21[5] = v13;
  objc_msgSend(MEMORY[0x24BDBCE70], "dictionaryWithObjects:forKeys:count:", v21, v20, 6);
  v14 = (NSDictionary *)objc_claimAutoreleasedReturnValue();

  CLMicroLocationPowerLog::logMetrics((CLMicroLocationPowerLog *)(a1 + 2016), CFSTR("ScanEvent"), v14);
  CLMicroLocationSensorsLogic::clrPowerMetrics((CLMicroLocationSensorsLogic *)(a1 + 712));

}

void sub_2419EBCDC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, void *a11, void *a12, void *a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19)
{
  void *v19;
  void *v20;
  void *v21;
  void *v22;
  void *v23;
  void *v24;
  void *v25;
  void *v26;

  _Unwind_Resume(a1);
}

void CLMicroLocationLogic::startMotionTriggerBasedLocalization(uint64_t a1, double *a2, uint64_t a3, unsigned int a4, int a5, unsigned int a6)
{
  _BYTE v9[144];

  CLMicroLocationLogic::createLocalizationTriggerWithOptAssociatedAccessPointInfo(a1, (uint64_t)"InternalClientMotion", (CLMicroLocationProto *)(a4 | 0x100000000), (uint64_t)v9, *a2);
  CLMicroLocationTriggerManager::requestLocalization(a1 + 1560, (const CLMicroLocationProto::RecordingEvent *)v9, 1, a5, a6);
  CLMicroLocationProto::RecordingEvent::~RecordingEvent((CLMicroLocationProto::RecordingEvent *)v9);
}

void sub_2419EBE18(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  CLMicroLocationProto::RecordingEvent::~RecordingEvent((CLMicroLocationProto::RecordingEvent *)&a9);
  _Unwind_Resume(a1);
}

void CLMicroLocationLogic::invalidateCaches(uint64_t a1, int a2)
{
  uint64_t v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  int v9;
  int v10;
  void *v11;
  void *v12;
  void *v13;
  void *v14;
  int v15;
  int v16;

  CLMicroLocationLocalizationController::invalidateCachedLocalizationInput((CLMicroLocationLocalizationController *)(a1 + 168));
  v4 = a1 + 1768;
  CLMiLoServiceManager::invalidateCachedPredictions((CLMiLoServiceManager *)(a1 + 1768));
  +[ULDefaultsSingleton shared](ULDefaultsSingleton, "shared");
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v5, "defaultsDictionary");
  v6 = (void *)objc_claimAutoreleasedReturnValue();

  objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "ULMotionStopDetectionModuleEnable");
  v7 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v6, "objectForKey:", v7);
  v8 = (void *)objc_claimAutoreleasedReturnValue();
  if (v8 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
    v9 = objc_msgSend(v8, "BOOLValue");
  else
    v9 = objc_msgSend(MEMORY[0x24BDBD1C8], "BOOLValue");
  v10 = v9;

  if (v10)
  {
    +[ULDefaultsSingleton shared](ULDefaultsSingleton, "shared");
    v11 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v11, "defaultsDictionary");
    v12 = (void *)objc_claimAutoreleasedReturnValue();

    objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "ULMotionInvalidateConfidenceOnMotion");
    v13 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v12, "objectForKey:", v13);
    v14 = (void *)objc_claimAutoreleasedReturnValue();
    if (v14 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
      v15 = objc_msgSend(v14, "BOOLValue");
    else
      v15 = objc_msgSend(MEMORY[0x24BDBD1C8], "BOOLValue");
    v16 = v15;

    if (!a2)
    {
      if (v16)
        CLMiLoServiceManager::notifyInvalidConfidence(v4, 1);
    }
  }
}

void sub_2419EBFD4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void CLMicroLocationLogic::onInMotion(uint64_t a1, unsigned int a2)
{
  double v4;
  int v5;
  NSObject *v6;
  uint64_t v7;
  uint64_t v8;
  unsigned int v9;
  const char *v10;
  int v11;
  const char *v12;
  int v13;
  int v14[11];
  int v15;
  double v16;
  __int128 v17;
  uint8_t buf[4];
  int v19;
  __int16 v20;
  const char *v21;
  __int16 v22;
  int v23;
  _QWORD v24[40];

  v24[39] = *MEMORY[0x24BDAC8D0];
  v4 = cl::chrono::CFAbsoluteTimeClock::now();
  v16 = v4;
  v5 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 176))(a1);
  if (onceToken_MicroLocation_Default != -1)
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_3);
  v6 = logObject_MicroLocation_Default;
  if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 68289282;
    v19 = 0;
    v20 = 2082;
    v21 = "";
    v22 = 1026;
    v23 = v5;
    _os_log_impl(&dword_2419D9000, v6, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"onInMotion - setting medium confidence and resetting localization error retries\", \"ScreenOn\":%{public}hhd}", buf, 0x18u);
  }
  *(_QWORD *)(a1 + 112) = 0;
  *(_BYTE *)(a1 + 120) = 1;
  CLMicroLocationProto::MotionEvent::MotionEvent((CLMicroLocationProto::MotionEvent *)v14);
  if (!CLMicroLocationProto::MotionEvent_Status_IsValid(0))
  {
    v10 = "::CLMicroLocationProto::MotionEvent_Status_IsValid(value)";
    v11 = 18149;
    v12 = "set_status";
    goto LABEL_20;
  }
  v15 |= 4u;
  v14[5] = 0;
  if (v5)
    v7 = 1;
  else
    v7 = 2;
  if (!CLMicroLocationProto::ConfigurationType_IsValid((CLMicroLocationProto *)v7))
  {
    v10 = "::CLMicroLocationProto::MotionEvent_ScreenStatus_IsValid(value)";
    v11 = 18242;
    v12 = "set_screenon";
LABEL_20:
    __assert_rtn(v12, "microlocation.pb.h", v11, v10);
  }
  v15 |= 0x10u;
  v14[8] = v7;
  v13 = 0;
  boost::uuids::detail::random_provider_base::random_provider_base((boost::uuids::detail::random_provider_base *)&v13);
  *(_QWORD *)&v17 = boost::uuids::random_generator_pure::operator()((uint64_t)&v13);
  *((_QWORD *)&v17 + 1) = v8;
  CLMicroLocationProtobufHelper::createLoggedEvent<CLMicroLocationProto::MotionEvent>(&v17, v14, (uint64_t)buf, v4);
  (*(void (**)(uint64_t, uint8_t *))(*(_QWORD *)a1 + 120))(a1, buf);
  CLMicroLocationProto::ReceivedEvent::~ReceivedEvent((CLMicroLocationProto::ReceivedEvent *)v24);
  boost::uuids::detail::random_provider_base::destroy((boost::uuids::detail::random_provider_base *)&v13);
  CLMicroLocationTriggerManager::onInMotion((CLMicroLocationTriggerManager *)(a1 + 1560));
  if (a2)
  {
    if (a2 == 1)
    {
      v9 = 0;
    }
    else if (a2 == 2)
    {
      v9 = 1;
    }
    else
    {
      v9 = 0;
      a2 = 0;
    }
  }
  else
  {
    CLMicroLocationLogic::invalidateCaches(a1, 0);
    v9 = 0;
  }
  CLMicroLocationLogic::startMotionTriggerBasedLocalization(a1, &v16, 0, a2, 1, v9);
  CLMicroLocationProto::MotionEvent::~MotionEvent((CLMicroLocationProto::MotionEvent *)v14);
}

void sub_2419EC298(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9, char a10, __int16 a11, char a12)
{
  uint64_t v12;

  CLMicroLocationProto::ReceivedEvent::~ReceivedEvent((CLMicroLocationProto::ReceivedEvent *)(v12 + 32));
  boost::uuids::detail::random_provider_base::destroy((boost::uuids::detail::random_provider_base *)&a10);
  CLMicroLocationProto::MotionEvent::~MotionEvent((CLMicroLocationProto::MotionEvent *)&a12);
  _Unwind_Resume(a1);
}

void CLMicroLocationProtobufHelper::createLoggedEvent<CLMicroLocationProto::MotionEvent>(_OWORD *a1@<X0>, int *a2@<X1>, uint64_t a3@<X8>, double a4@<D0>)
{
  const CLMicroLocationProto::MotionEvent *v8;
  _BYTE v9[304];

  CLMicroLocationProto::ReceivedEvent::ReceivedEvent((CLMicroLocationProto::ReceivedEvent *)v9);
  CLMicroLocationProtobufHelper::setSpecificLoggedEvent((CLMicroLocationProtobufHelper *)v9, (CLMicroLocationProto::ReceivedEvent *)a2, v8);
  CLMicroLocationLoggedEventsTable::Entry::Entry(a3, a1, a2[4], (CLMicroLocationProto::ReceivedEvent *)v9, a4);
  CLMicroLocationProto::ReceivedEvent::~ReceivedEvent((CLMicroLocationProto::ReceivedEvent *)v9);
}

void sub_2419EC350(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  CLMicroLocationProto::ReceivedEvent::~ReceivedEvent((CLMicroLocationProto::ReceivedEvent *)&a9);
  _Unwind_Resume(a1);
}

void CLMicroLocationLogic::onStopMotion(CLMicroLocationLogic *this)
{
  double v2;
  int v3;
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  const char *v7;
  int v8;
  const char *v9;
  int v10;
  int v11[11];
  int v12;
  double v13;
  __int128 v14;
  uint8_t buf[4];
  int v16;
  __int16 v17;
  const char *v18;
  __int16 v19;
  int v20;
  _QWORD v21[40];

  v21[39] = *MEMORY[0x24BDAC8D0];
  v2 = cl::chrono::CFAbsoluteTimeClock::now();
  v13 = v2;
  v3 = (*(uint64_t (**)(CLMicroLocationLogic *))(*(_QWORD *)this + 176))(this);
  if (onceToken_MicroLocation_Default != -1)
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_3);
  v4 = logObject_MicroLocation_Default;
  if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 68289282;
    v16 = 0;
    v17 = 2082;
    v18 = "";
    v19 = 1026;
    v20 = v3;
    _os_log_impl(&dword_2419D9000, v4, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"onStopMotion\", \"ScreenOn\":%{public}hhd}", buf, 0x18u);
  }
  CLMicroLocationProto::MotionEvent::MotionEvent((CLMicroLocationProto::MotionEvent *)v11);
  if (!CLMicroLocationProto::MotionEvent_Status_IsValid((CLMicroLocationProto *)1))
  {
    v7 = "::CLMicroLocationProto::MotionEvent_Status_IsValid(value)";
    v8 = 18149;
    v9 = "set_status";
    goto LABEL_16;
  }
  v12 |= 4u;
  v11[5] = 1;
  if (v3)
    v5 = 1;
  else
    v5 = 2;
  if (!CLMicroLocationProto::ConfigurationType_IsValid((CLMicroLocationProto *)v5))
  {
    v7 = "::CLMicroLocationProto::MotionEvent_ScreenStatus_IsValid(value)";
    v8 = 18242;
    v9 = "set_screenon";
LABEL_16:
    __assert_rtn(v9, "microlocation.pb.h", v8, v7);
  }
  v12 |= 0x10u;
  v11[8] = v5;
  v10 = 0;
  boost::uuids::detail::random_provider_base::random_provider_base((boost::uuids::detail::random_provider_base *)&v10);
  *(_QWORD *)&v14 = boost::uuids::random_generator_pure::operator()((uint64_t)&v10);
  *((_QWORD *)&v14 + 1) = v6;
  CLMicroLocationProtobufHelper::createLoggedEvent<CLMicroLocationProto::MotionEvent>(&v14, v11, (uint64_t)buf, v2);
  (*(void (**)(CLMicroLocationLogic *, uint8_t *))(*(_QWORD *)this + 120))(this, buf);
  CLMicroLocationProto::ReceivedEvent::~ReceivedEvent((CLMicroLocationProto::ReceivedEvent *)v21);
  boost::uuids::detail::random_provider_base::destroy((boost::uuids::detail::random_provider_base *)&v10);
  CLMicroLocationTriggerManager::onStopMotion((uint64_t)this + 1560);
  if (v3)
  {
    CLMicroLocationTriggerManager::requestMotion((CLMicroLocationLogic *)((char *)this + 1560), 0);
    CLMicroLocationLogic::startMotionTriggerBasedLocalization((uint64_t)this, &v13, 0, 3u, 0, 0);
  }
  else
  {
    CLMicroLocationLogic::invalidateCaches((uint64_t)this, 0);
  }
  CLMicroLocationProto::MotionEvent::~MotionEvent((CLMicroLocationProto::MotionEvent *)v11);
}

void sub_2419EC5A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9, char a10, __int16 a11, char a12)
{
  uint64_t v12;

  CLMicroLocationProto::ReceivedEvent::~ReceivedEvent((CLMicroLocationProto::ReceivedEvent *)(v12 + 32));
  boost::uuids::detail::random_provider_base::destroy((boost::uuids::detail::random_provider_base *)&a10);
  CLMicroLocationProto::MotionEvent::~MotionEvent((CLMicroLocationProto::MotionEvent *)&a12);
  _Unwind_Resume(a1);
}

void CLMicroLocationLogic::onCustomLoiRecordingFenceBreach(CLMiLoCustomLoiRecordingManager **this)
{
  CLMiLoCustomLoiRecordingManager::recordingFenceBreached(this[320]);
}

void CLMicroLocationLogic::onMacInternalTrigger(CLMicroLocationLogic *this)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;
  _QWORD *v5;
  double v6;
  _DWORD v7[36];
  _BYTE v8[12];
  int v9;
  _QWORD *v10;
  _QWORD *v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x24BDAC8D0];
  if (*((_BYTE *)this + 49))
  {
    CLMicroLocationProto::RecordingRequest::RecordingRequest((CLMicroLocationProto::RecordingRequest *)v8);
    v12 |= 4u;
    v2 = (_QWORD *)MEMORY[0x24BEDD958];
    if (v10 == (_QWORD *)MEMORY[0x24BEDD958])
    {
      v3 = (_QWORD *)operator new();
      *v3 = 0;
      v3[1] = 0;
      v3[2] = 0;
      v10 = v3;
    }
    MEMORY[0x2426A02C4]();
    if (!CLMicroLocationProto::RecordingRequestType_IsValid((CLMicroLocationProto *)1))
      __assert_rtn("set_recordingrequesttype", "microlocation.pb.h", 13554, "::CLMicroLocationProto::RecordingRequestType_IsValid(value)");
    v12 |= 2u;
    v9 = 1;
    v7[0] = 0;
    boost::uuids::detail::random_provider_base::random_provider_base((boost::uuids::detail::random_provider_base *)v7);
    v13 = boost::uuids::random_generator_pure::operator()((uint64_t)v7);
    v14 = v4;
    boost::uuids::detail::random_provider_base::destroy((boost::uuids::detail::random_provider_base *)v7);
    v12 |= 8u;
    if (v11 == v2)
    {
      v5 = (_QWORD *)operator new();
      *v5 = 0;
      v5[1] = 0;
      v5[2] = 0;
      v11 = v5;
    }
    MEMORY[0x2426A02D0]();
    v6 = cl::chrono::CFAbsoluteTimeClock::now();
    CLMicroLocationProtobufHelper::createRecordingEvent<CLMicroLocationProto::RecordingRequest>((CLMicroLocationProto::RecordingEvent *)v8, 0, 0, 0, (CLMicroLocationProto *)3, (uint64_t)v7, v6);
    CLMicroLocationTriggerManager::requestRecording((CLMicroLocationLogic *)((char *)this + 1560), (const CLMicroLocationProto::RecordingEvent *)v7);
    CLMicroLocationProto::RecordingEvent::~RecordingEvent((CLMicroLocationProto::RecordingEvent *)v7);
    CLMicroLocationProto::RecordingRequest::~RecordingRequest((CLMicroLocationProto::RecordingRequest *)v8);
  }
}

void sub_2419EC790(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v2;
  va_list va;

  va_start(va, a2);
  CLMicroLocationProto::RecordingEvent::~RecordingEvent((CLMicroLocationProto::RecordingEvent *)va);
  CLMicroLocationProto::RecordingRequest::~RecordingRequest((CLMicroLocationProto::RecordingRequest *)(v2 - 104));
  _Unwind_Resume(a1);
}

void CLMicroLocationProtobufHelper::createRecordingEvent<CLMicroLocationProto::RecordingRequest>(CLMicroLocationProto::RecordingEvent *a1@<X0>, CLMicroLocationProto *a2@<X1>, char a3@<W2>, char a4@<W3>, CLMicroLocationProto *a5@<X4>, uint64_t a6@<X8>, double a7@<D0>)
{
  unsigned int v14;
  int v15;
  const CLMicroLocationProto::RecordingRequest *v16;
  const char *v17;
  int v18;
  const char *v19;

  CLMicroLocationProto::RecordingEvent::RecordingEvent((CLMicroLocationProto::RecordingEvent *)a6);
  v14 = *((_DWORD *)a1 + 2);
  if (!CLMicroLocationProto::EventType_IsValid((CLMicroLocationProto *)v14))
  {
    v17 = "::CLMicroLocationProto::EventType_IsValid(value)";
    v18 = 20192;
    v19 = "set_eventtype";
    goto LABEL_10;
  }
  v15 = *(_DWORD *)(a6 + 140);
  *(_DWORD *)(a6 + 72) = v14;
  *(double *)(a6 + 8) = a7;
  *(_BYTE *)(a6 + 77) = a3;
  *(_DWORD *)(a6 + 140) = v15 | 0x2803;
  *(_BYTE *)(a6 + 76) = a4;
  if (!CLMicroLocationProto::ConfidenceLevel_IsValid(a5))
  {
    v17 = "::CLMicroLocationProto::ConfidenceLevel_IsValid(value)";
    v18 = 20701;
    v19 = "set_confidencelevel";
    goto LABEL_10;
  }
  *(_DWORD *)(a6 + 140) |= 0x4000u;
  *(_DWORD *)(a6 + 120) = (_DWORD)a5;
  if (((unint64_t)a2 & 0xFF00000000) != 0)
  {
    if (CLMicroLocationProto::MotionState_IsValid(a2))
    {
      *(_DWORD *)(a6 + 140) |= 0x20000u;
      *(_DWORD *)(a6 + 124) = (_DWORD)a2;
      goto LABEL_6;
    }
    v17 = "::CLMicroLocationProto::MotionState_IsValid(value)";
    v18 = 20793;
    v19 = "set_motionstate";
LABEL_10:
    __assert_rtn(v19, "microlocation.pb.h", v18, v17);
  }
LABEL_6:
  CLMicroLocationProtobufHelper::setSpecificRecordingEvent((CLMicroLocationProtobufHelper *)a6, a1, v16);
}

void sub_2419EC904(_Unwind_Exception *a1)
{
  CLMicroLocationProto::RecordingEvent *v1;

  CLMicroLocationProto::RecordingEvent::~RecordingEvent(v1);
  _Unwind_Resume(a1);
}

uint64_t CLMicroLocationLogic::onMacPowerChange(CLMicroLocationLogic *this, char a2)
{
  return CLMicroLocationTriggerManager::setMacAcPower((uint64_t)this + 1560, a2);
}

void CLMicroLocationLogic::onMacExternalScreenChange(CLMicroLocationLogic *this, char a2)
{
  int v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;
  double v10;
  double v11;
  uint64_t v12;
  void *v13;
  _QWORD v14[5];

  CLMicroLocationTriggerManager::setMacExternalDisplay((uint64_t)this + 1560, a2);
  if ((a2 & 1) == 0)
  {
    v4 = *((unsigned __int8 *)this + 121);
    +[ULDefaultsSingleton shared](ULDefaultsSingleton, "shared");
    v5 = (void *)objc_claimAutoreleasedReturnValue();
    v6 = v5;
    if (v4)
    {
      objc_msgSend(v5, "defaultsDictionary");
      v7 = (void *)objc_claimAutoreleasedReturnValue();

      objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "ULPeriodicTriggerDelayUnstableModel");
      v8 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v7, "objectForKey:", v8);
      v9 = (void *)objc_claimAutoreleasedReturnValue();
      if (v9)
      {
        objc_opt_class();
        if ((objc_opt_isKindOfClass() & 1) != 0)
        {
LABEL_5:
          objc_msgSend(v9, "doubleValue");
          goto LABEL_10;
        }
      }
      objc_msgSend(&unk_2511ECD48, "doubleValue");
    }
    else
    {
      objc_msgSend(v5, "defaultsDictionary");
      v7 = (void *)objc_claimAutoreleasedReturnValue();

      objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "ULPeriodicTriggerDelay");
      v8 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v7, "objectForKey:", v8);
      v9 = (void *)objc_claimAutoreleasedReturnValue();
      if (v9)
      {
        objc_opt_class();
        if ((objc_opt_isKindOfClass() & 1) != 0)
          goto LABEL_5;
      }
      objc_msgSend(&unk_2511ECD38, "doubleValue");
    }
LABEL_10:
    v11 = v10;

    if (!*((_QWORD *)this + 322))
    {
      v14[0] = MEMORY[0x24BDAC760];
      v14[1] = 3221225472;
      v14[2] = ___ZN20CLMicroLocationLogic25onMacExternalScreenChangeEb_block_invoke;
      v14[3] = &__block_descriptor_40_e5_v8__0l;
      v14[4] = this;
      +[ULTimerFactory timerOnPrimaryQueueWithInterval:repeats:block:](ULTimerFactory, "timerOnPrimaryQueueWithInterval:repeats:block:", 0, v14, v11);
      v12 = objc_claimAutoreleasedReturnValue();
      v13 = (void *)*((_QWORD *)this + 322);
      *((_QWORD *)this + 322) = v12;

    }
  }
}

void sub_2419ECAEC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void ___ZN20CLMicroLocationLogic25onMacExternalScreenChangeEb_block_invoke(uint64_t a1)
{
  CLMicroLocationLogic::onPeriodicTriggerEventTimer(*(id **)(a1 + 32));
}

void CLMicroLocationLogic::onPeriodicTriggerEventTimer(id *this)
{
  CFAbsoluteTime v2;
  NSObject *v3;
  id v4;
  _DWORD v5[2];
  __int16 v6;
  const char *v7;
  __int16 v8;
  CFAbsoluteTime v9;
  uint64_t v10;

  v10 = *MEMORY[0x24BDAC8D0];
  v2 = cl::chrono::CFAbsoluteTimeClock::now();
  if (onceToken_MicroLocation_Default != -1)
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_3);
  v3 = logObject_MicroLocation_Default;
  if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT))
  {
    v5[0] = 68289282;
    v5[1] = 0;
    v6 = 2082;
    v7 = "";
    v8 = 2050;
    v9 = v2;
    _os_log_impl(&dword_2419D9000, v3, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"Periodic Event Timer elapsed\", \"now\":\"%{public}.3f\"}", (uint8_t *)v5, 0x1Cu);
  }
  objc_msgSend(this[322], "invalidate");
  v4 = this[322];
  this[322] = 0;

  CLMicroLocationLogic::onPeriodicTrigger((CLMicroLocationLogic *)this);
}

void CLMicroLocationLogic::onPeriodicTrigger(CLMicroLocationLogic *this)
{
  int v2;
  BOOL v3;
  _QWORD *v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  double v8;
  _DWORD v9[36];
  _BYTE v10[12];
  int v11;
  _QWORD *v12;
  _QWORD *v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x24BDAC8D0];
  v2 = (*(uint64_t (**)(CLMicroLocationLogic *))(*(_QWORD *)this + 176))(this);
  if (*((_BYTE *)this + 49))
    v3 = v2 == 0;
  else
    v3 = 1;
  if (!v3)
  {
    CLMicroLocationProto::RecordingRequest::RecordingRequest((CLMicroLocationProto::RecordingRequest *)v10);
    v14 |= 4u;
    v4 = (_QWORD *)MEMORY[0x24BEDD958];
    if (v12 == (_QWORD *)MEMORY[0x24BEDD958])
    {
      v5 = (_QWORD *)operator new();
      *v5 = 0;
      v5[1] = 0;
      v5[2] = 0;
      v12 = v5;
    }
    MEMORY[0x2426A02C4]();
    if (!CLMicroLocationProto::RecordingRequestType_IsValid((CLMicroLocationProto *)1))
      __assert_rtn("set_recordingrequesttype", "microlocation.pb.h", 13554, "::CLMicroLocationProto::RecordingRequestType_IsValid(value)");
    v14 |= 2u;
    v11 = 1;
    v9[0] = 0;
    boost::uuids::detail::random_provider_base::random_provider_base((boost::uuids::detail::random_provider_base *)v9);
    v15 = boost::uuids::random_generator_pure::operator()((uint64_t)v9);
    v16 = v6;
    boost::uuids::detail::random_provider_base::destroy((boost::uuids::detail::random_provider_base *)v9);
    v14 |= 8u;
    if (v13 == v4)
    {
      v7 = (_QWORD *)operator new();
      *v7 = 0;
      v7[1] = 0;
      v7[2] = 0;
      v13 = v7;
    }
    MEMORY[0x2426A02D0]();
    v8 = cl::chrono::CFAbsoluteTimeClock::now();
    CLMicroLocationProtobufHelper::createRecordingEvent<CLMicroLocationProto::RecordingRequest>((CLMicroLocationProto::RecordingEvent *)v10, 0, 0, 0, (CLMicroLocationProto *)3, (uint64_t)v9, v8);
    CLMicroLocationTriggerManager::requestRecording((CLMicroLocationLogic *)((char *)this + 1560), (const CLMicroLocationProto::RecordingEvent *)v9);
    CLMicroLocationProto::RecordingEvent::~RecordingEvent((CLMicroLocationProto::RecordingEvent *)v9);
    CLMicroLocationProto::RecordingRequest::~RecordingRequest((CLMicroLocationProto::RecordingRequest *)v10);
  }
}

void sub_2419ECE14(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v2;
  va_list va;

  va_start(va, a2);
  CLMicroLocationProto::RecordingEvent::~RecordingEvent((CLMicroLocationProto::RecordingEvent *)va);
  CLMicroLocationProto::RecordingRequest::~RecordingRequest((CLMicroLocationProto::RecordingRequest *)(v2 - 104));
  _Unwind_Resume(a1);
}

uint64_t CLMicroLocationLogic::requestWifiScanExtension(uint64_t a1, uint64_t a2, unint64_t a3)
{
  uint64_t v6;
  int v7;
  unint64_t v8;
  uint64_t **v9;
  int v10;
  uint64_t v11;
  const char *v12;
  NSObject *v13;
  os_log_type_t v14;
  uint64_t **v15;
  int v16;
  uint64_t v17;
  int v18;
  int v19;
  void *v21;
  void *v22;
  void *v23;
  void *v24;
  int v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  int v30;
  int v31;
  int v32;
  int v33;
  int v34;
  int v35;
  void *v37;
  void *v38;
  void *v39;
  void *v40;
  int v41;
  void *v42;
  void *v43;
  void *v44;
  void *v45;
  int v46;
  int v47;
  int v48;
  NSObject *v49;
  void *v50;
  void *v51;
  uint64_t v52;
  uint64_t v53;
  NSObject *v54;
  uint64_t v55;
  void *v57;
  void *v58;
  int v59;
  _BYTE v60[20];
  __int16 v61;
  unint64_t v62;
  __int16 v63;
  uint64_t v64;
  __int16 v65;
  uint64_t v66;
  __int16 v67;
  uint64_t v68;
  __int16 v69;
  uint64_t v70;
  __int16 v71;
  uint64_t v72;
  __int16 v73;
  uint64_t v74;
  uint64_t v75;

  v75 = *MEMORY[0x24BDAC8D0];
  v6 = ULSettings::get<ULSettings::MinimumWiFiNumberOfMeasurementsForScanExtension>();
  if (!a2)
    return 0;
  v7 = *(unsigned __int8 *)(a1 + 53);
  if (!*(_BYTE *)(a1 + 53))
  {
    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_3);
    v11 = logObject_MicroLocation_Default;
    if (!os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_ERROR))
      return 0;
    LOWORD(v59) = 0;
    v12 = "Logic, shouldExtendWifiScan was called when activity is NotSet";
    v13 = v11;
    v14 = OS_LOG_TYPE_ERROR;
LABEL_66:
    _os_log_impl(&dword_2419D9000, v13, v14, v12, (uint8_t *)&v59, 2u);
    return 0;
  }
  v8 = v6;
  if (v7 != 1)
  {
    if (v7 != 2)
    {
      if (a2 >= 1)
      {
        v17 = 0;
LABEL_48:
        if (onceToken_MicroLocation_Default != -1)
          dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_3);
        v49 = (id)logObject_MicroLocation_Default;
        if (os_log_type_enabled(v49, OS_LOG_TYPE_INFO))
        {
          objc_msgSend(MEMORY[0x24BDD16E0], "numberWithLongLong:", a2);
          v50 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(MEMORY[0x24BDD16E0], "numberWithLongLong:", v17);
          v51 = (void *)objc_claimAutoreleasedReturnValue();
          v59 = 138412546;
          *(_QWORD *)v60 = v50;
          *(_WORD *)&v60[8] = 2112;
          *(_QWORD *)&v60[10] = v51;
          _os_log_impl(&dword_2419D9000, v49, OS_LOG_TYPE_INFO, "requestWifiScanExtension: extension request (%@) > max allowed extension (%@)", (uint8_t *)&v59, 0x16u);

        }
        return 0;
      }
      goto LABEL_62;
    }
    v9 = (uint64_t **)(a1 + 56);
    v10 = *(char *)(a1 + 79);
    if (v10 < 0)
    {
      if (*(_QWORD *)(a1 + 64) != 6)
        goto LABEL_23;
      v9 = (uint64_t **)*v9;
    }
    else if (v10 != 6)
    {
      goto LABEL_23;
    }
    v18 = *(_DWORD *)v9;
    v19 = *((unsigned __int16 *)v9 + 2);
    if (v18 == 1953723747 && v19 == 28015)
    {
      +[ULDefaultsSingleton shared](ULDefaultsSingleton, "shared");
      v57 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v57, "defaultsDictionary");
      v22 = (void *)objc_claimAutoreleasedReturnValue();

      objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "ULRecordingDurationDualBands");
      v23 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v22, "objectForKey:", v23);
      v24 = (void *)objc_claimAutoreleasedReturnValue();
      if (v24)
      {
        objc_opt_class();
        if ((objc_opt_isKindOfClass() & 1) != 0)
          goto LABEL_25;
      }
      v25 = objc_msgSend(&unk_2511ED228, "intValue");
      goto LABEL_27;
    }
LABEL_23:
    +[ULDefaultsSingleton shared](ULDefaultsSingleton, "shared");
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v21, "defaultsDictionary");
    v22 = (void *)objc_claimAutoreleasedReturnValue();

    objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "ULRecordingDuration");
    v23 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v22, "objectForKey:", v23);
    v24 = (void *)objc_claimAutoreleasedReturnValue();
    if (v24)
    {
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) != 0)
      {
LABEL_25:
        v25 = objc_msgSend(v24, "intValue");
        goto LABEL_27;
      }
    }
    v25 = objc_msgSend(&unk_2511ED210, "intValue");
LABEL_27:
    LODWORD(v17) = v25;

    +[ULDefaultsSingleton shared](ULDefaultsSingleton, "shared");
    v26 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v26, "defaultsDictionary");
    v27 = (void *)objc_claimAutoreleasedReturnValue();

    objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "ULRecordingDurationMaximumIncrements");
    v28 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v27, "objectForKey:", v28);
    v29 = (void *)objc_claimAutoreleasedReturnValue();
    if (v29 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
      v30 = objc_msgSend(v29, "intValue");
    else
      v30 = objc_msgSend(&unk_2511ED150, "intValue");
    v31 = v30;

    v32 = *(_DWORD *)(a1 + 104);
    v33 = v31 - v32;
    *(_DWORD *)(a1 + 104) = v32 + 1;
    goto LABEL_47;
  }
  v15 = (uint64_t **)(a1 + 56);
  v16 = *(char *)(a1 + 79);
  if (v16 < 0)
  {
    if (*(_QWORD *)(a1 + 64) != 6)
      goto LABEL_38;
    v15 = (uint64_t **)*v15;
  }
  else if (v16 != 6)
  {
    goto LABEL_38;
  }
  v34 = *(_DWORD *)v15;
  v35 = *((unsigned __int16 *)v15 + 2);
  if (v34 == 1953723747 && v35 == 28015)
  {
    +[ULDefaultsSingleton shared](ULDefaultsSingleton, "shared");
    v58 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v58, "defaultsDictionary");
    v38 = (void *)objc_claimAutoreleasedReturnValue();

    objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "ULLocalizingDurationMinimumDualBands");
    v39 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v38, "objectForKey:", v39);
    v40 = (void *)objc_claimAutoreleasedReturnValue();
    if (v40)
    {
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) != 0)
        goto LABEL_40;
    }
    v41 = objc_msgSend(&unk_2511ED240, "intValue");
    goto LABEL_42;
  }
LABEL_38:
  +[ULDefaultsSingleton shared](ULDefaultsSingleton, "shared");
  v37 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v37, "defaultsDictionary");
  v38 = (void *)objc_claimAutoreleasedReturnValue();

  objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "ULLocalizingDurationMinimum");
  v39 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v38, "objectForKey:", v39);
  v40 = (void *)objc_claimAutoreleasedReturnValue();
  if (v40)
  {
    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) != 0)
    {
LABEL_40:
      v41 = objc_msgSend(v40, "intValue");
      goto LABEL_42;
    }
  }
  v41 = objc_msgSend(&unk_2511ED1E0, "intValue");
LABEL_42:
  LODWORD(v17) = v41;

  +[ULDefaultsSingleton shared](ULDefaultsSingleton, "shared");
  v42 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v42, "defaultsDictionary");
  v43 = (void *)objc_claimAutoreleasedReturnValue();

  objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "ULLocalizingDurationMaximumIncrements");
  v44 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v43, "objectForKey:", v44);
  v45 = (void *)objc_claimAutoreleasedReturnValue();
  if (v45 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
    v46 = objc_msgSend(v45, "intValue");
  else
    v46 = objc_msgSend(&unk_2511ED150, "intValue");
  v47 = v46;

  v48 = *(_DWORD *)(a1 + 100);
  v33 = v47 - v48;
  *(_DWORD *)(a1 + 100) = v48 + 1;
LABEL_47:
  v17 = (int)v17;
  if ((int)v17 < a2)
    goto LABEL_48;
  if (v33 <= 0)
  {
LABEL_62:
    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_3);
    v55 = logObject_MicroLocation_Default;
    if (!os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_INFO))
      return 0;
    LOWORD(v59) = 0;
    v12 = "requestWifiScanExtension: no remaining extensions";
    v13 = v55;
    v14 = OS_LOG_TYPE_INFO;
    goto LABEL_66;
  }
  if (v8 > a3)
    v52 = a2;
  else
    v52 = 0;
  v53 = *(unsigned __int8 *)(a1 + 53);
  if (onceToken_MicroLocation_Default != -1)
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_3);
  v54 = (id)logObject_MicroLocation_Default;
  if (os_log_type_enabled(v54, OS_LOG_TYPE_INFO))
  {
    v59 = 68291074;
    *(_DWORD *)v60 = 0;
    *(_WORD *)&v60[4] = 2082;
    *(_QWORD *)&v60[6] = "";
    *(_WORD *)&v60[14] = 1026;
    *(_DWORD *)&v60[16] = v8 <= a3;
    v61 = 2050;
    v62 = a3;
    v63 = 2050;
    v64 = ULSettings::get<ULSettings::MinimumWiFiNumberOfMeasurementsForScanExtension>();
    v65 = 2050;
    v66 = a2;
    v67 = 2050;
    v68 = a2;
    v69 = 2050;
    v70 = v33;
    v71 = 2050;
    v72 = v52;
    v73 = 2050;
    v74 = v53;
    _os_log_impl(&dword_2419D9000, v54, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"CLMicroLocationLogic:requestWifiScanExtension\", \"requirement for min num measurements met\":%{public}hhd, \"Num measurements\":%{public}lu, \"Minimum num of measurements for scan extension\":%{public}lu, \"requestedExtension\":%{public}lld, \"singleScanIncrement\":%{public}lld, \"remainingExtensions\":%{public}lu, \"extendDuration\":%{public}lld, \"scanActivity\":%{public, location:CLMicroLocationUtils::ScanActivity}lld}", (uint8_t *)&v59, 0x5Eu);
  }

  return v52;
}

void sub_2419ED5DC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

uint64_t ULSettings::get<ULSettings::MinimumWiFiNumberOfMeasurementsForScanExtension>()
{
  void *v0;
  void *v1;
  void *v2;
  void *v3;
  uint64_t v4;
  uint64_t v5;

  +[ULDefaultsSingleton shared](ULDefaultsSingleton, "shared");
  v0 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v0, "defaultsDictionary");
  v1 = (void *)objc_claimAutoreleasedReturnValue();

  objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "ULMinimumWiFiNumberOfMeasurementsForScanExtension");
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v1, "objectForKey:", v2);
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  if (v3 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
    v4 = objc_msgSend(v3, "unsignedLongValue");
  else
    v4 = objc_msgSend(&unk_2511ED168, "unsignedLongValue");
  v5 = v4;

  return v5;
}

void sub_2419ED774(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void CLMicroLocationLogic::setCurrentRTLOI(CLMicroLocationLogic *this, uint64_t a2, uint64_t a3, uint64_t a4, CLMicroLocationProto *a5)
{
  uint64_t v6;
  std::string::size_type v8;
  __int128 v9;
  int v10;
  uint64_t v11;
  int v12;
  int v13;
  char v15;
  int v16;
  std::string *v17;
  std::string *v18;
  std::string *v19;
  std::string::size_type v20;
  double v21;
  int v22;
  _DWORD *v23;
  void *v24;
  NSObject *v25;
  int v26;
  std::string::size_type v27;
  std::string *p_p;
  std::string *p_str;
  std::bad_cast *v30;
  std::string __p;
  int v32[4];
  std::string *v33;
  int v34;
  std::string *v35;
  char v36;
  int v37;
  std::string v38;
  uint8_t buf[8];
  _BYTE v40[20];
  __int16 v41;
  std::string *v42;
  __int16 v43;
  std::string *v44;
  __int16 v45;
  int v46;
  __int128 v47;
  std::string __str;
  uint64_t v49;

  v6 = a2;
  v49 = *MEMORY[0x24BDAC8D0];
  *(_QWORD *)&v47 = a3;
  *((_QWORD *)&v47 + 1) = a4;
  if (*(char *)(a2 + 23) < 0)
    std::string::__init_copy_ctor_external(&v38, *(const std::string::value_type **)a2, *(_QWORD *)(a2 + 8));
  else
    v38 = *(std::string *)a2;
  v8 = *((_QWORD *)this + 9);
  v9 = *(_OWORD *)((char *)this + 56);
  *(std::string *)((char *)this + 56) = v38;
  *(_OWORD *)&v38.__r_.__value_.__l.__data_ = v9;
  v38.__r_.__value_.__r.__words[2] = v8;
  if (SHIBYTE(v8) < 0)
    operator delete(v38.__r_.__value_.__l.__data_);
  *((_OWORD *)this + 5) = v47;
  CLMicroLocationLogic::reloadWifiChannelHistogram(this);
  CLMiLoServiceManager::enterLocation((uint64_t)this + 1768, (uint64_t *)v6, v47, *((uint64_t *)&v47 + 1));
  v10 = *(char *)(v6 + 23);
  if (v10 < 0)
  {
    if (*(_QWORD *)(v6 + 8) != 6)
    {
LABEL_15:
      v15 = 0;
      goto LABEL_16;
    }
    v11 = *(_QWORD *)v6;
  }
  else
  {
    v11 = v6;
    if (v10 != 6)
      goto LABEL_15;
  }
  v12 = *(_DWORD *)v11;
  v13 = *(unsigned __int16 *)(v11 + 4);
  if (v12 != 1953723747 || v13 != 28015)
    goto LABEL_15;
  v15 = 1;
LABEL_16:
  CLMicroLocationSensorsLogic::setDeviceIsInCustomLoi((uint64_t)this + 712, v15);
  v16 = *((unsigned __int8 *)this + 49);
  CLMicroLocationProto::RetrievedLoi::RetrievedLoi((CLMicroLocationProto::RetrievedLoi *)v32);
  if (!CLMicroLocationProto::ChangedLoiReason_IsValid(a5))
    __assert_rtn("set_reason", "microlocation.pb.h", 18621, "::CLMicroLocationProto::ChangedLoiReason_IsValid(value)");
  v34 = (int)a5;
  v37 |= 0x14u;
  v17 = v33;
  v18 = (std::string *)MEMORY[0x24BEDD958];
  if (v33 == (std::string *)MEMORY[0x24BEDD958])
  {
    v17 = (std::string *)operator new();
    v17->__r_.__value_.__r.__words[0] = 0;
    v17->__r_.__value_.__l.__size_ = 0;
    v17->__r_.__value_.__r.__words[2] = 0;
    v33 = v17;
  }
  std::string::operator=(v17, (const std::string *)v6);
  memset(&__str, 0, sizeof(__str));
  if ((boost::conversion::detail::try_lexical_convert<std::string,boost::uuids::uuid>((uint64_t)&v47, &__str) & 1) == 0)
  {
    std::bad_cast::bad_cast((std::bad_cast *)buf);
    *(_QWORD *)buf = &unk_2511D2C18;
    boost::throw_exception<boost::bad_lexical_cast>((uint64_t)buf);
  }
  v37 |= 8u;
  v19 = v35;
  if (v35 == v18)
  {
    v19 = (std::string *)operator new();
    v19->__r_.__value_.__r.__words[0] = 0;
    v19->__r_.__value_.__l.__size_ = 0;
    v19->__r_.__value_.__r.__words[2] = 0;
    v35 = v19;
  }
  std::string::operator=(v19, &__str);
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__str.__r_.__value_.__l.__data_);
  v37 |= 0x20u;
  v36 = v16;
  LODWORD(__p.__r_.__value_.__l.__data_) = 0;
  boost::uuids::detail::random_provider_base::random_provider_base((boost::uuids::detail::random_provider_base *)&__p);
  __str.__r_.__value_.__r.__words[0] = boost::uuids::random_generator_pure::operator()((uint64_t)&__p);
  __str.__r_.__value_.__l.__size_ = v20;
  v21 = cl::chrono::CFAbsoluteTimeClock::now();
  CLMicroLocationProtobufHelper::createLoggedEvent<CLMicroLocationProto::RetrievedLoi>(&__str, v32, (uint64_t)buf, v21);
  (*(void (**)(CLMicroLocationLogic *, uint8_t *))(*(_QWORD *)this + 120))(this, buf);
  CLMicroLocationProto::ReceivedEvent::~ReceivedEvent((CLMicroLocationProto::ReceivedEvent *)((char *)&v42 + 2));
  boost::uuids::detail::random_provider_base::destroy((boost::uuids::detail::random_provider_base *)&__p);
  v22 = *(char *)(v6 + 23);
  if (v22 < 0)
  {
    if (*(_QWORD *)(v6 + 8) != 4)
    {
LABEL_30:
      +[ULHomeSlamAnalytics shared](ULHomeSlamAnalytics, "shared");
      v24 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v24, "logEventExitHomeLOIAtTimestamp:", cl::chrono::CFAbsoluteTimeClock::now());
      goto LABEL_31;
    }
    v23 = *(_DWORD **)v6;
  }
  else
  {
    v23 = (_DWORD *)v6;
    if (v22 != 4)
      goto LABEL_30;
  }
  if (*v23 != 1701670760)
    goto LABEL_30;
  +[ULHomeSlamAnalytics shared](ULHomeSlamAnalytics, "shared");
  v24 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v24, "logEventEnterHomeLOIAtTimestamp:", cl::chrono::CFAbsoluteTimeClock::now());
LABEL_31:

  if (onceToken_MicroLocation_Default != -1)
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_3);
  v25 = (id)logObject_MicroLocation_Default;
  if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
  {
    if (*(char *)(v6 + 23) < 0)
      v6 = *(_QWORD *)v6;
    memset(&__p, 0, sizeof(__p));
    if ((boost::conversion::detail::try_lexical_convert<std::string,boost::uuids::uuid>((uint64_t)&v47, &__p) & 1) == 0)
    {
      v30 = std::bad_cast::bad_cast((std::bad_cast *)&__str);
      __str.__r_.__value_.__r.__words[0] = (std::string::size_type)&unk_2511D2C18;
      boost::throw_exception<boost::bad_lexical_cast>((uint64_t)v30);
    }
    v26 = SHIBYTE(__p.__r_.__value_.__r.__words[2]);
    v27 = __p.__r_.__value_.__r.__words[0];
    CLMicroLocationProtobufHelper::convertChangedLoiReasonToMessage((int)a5, &__str);
    p_p = &__p;
    if (v26 < 0)
      p_p = (std::string *)v27;
    if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      p_str = &__str;
    else
      p_str = (std::string *)__str.__r_.__value_.__r.__words[0];
    *(_DWORD *)buf = 68290051;
    *(_DWORD *)&buf[4] = 0;
    *(_WORD *)v40 = 2082;
    *(_QWORD *)&v40[2] = "";
    *(_WORD *)&v40[10] = 2081;
    *(_QWORD *)&v40[12] = v6;
    v41 = 2081;
    v42 = p_p;
    v43 = 2081;
    v44 = p_str;
    v45 = 1025;
    v46 = v16;
    _os_log_impl(&dword_2419D9000, v25, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"Set current LOI.\", \"type\":%{private, location:escape_only}s, \"id\":%{private, location:escape_only}s, \"reason\":%{private, location:escape_only}s, \"is spectating\":%{private}hhd}", buf, 0x36u);
    if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__str.__r_.__value_.__l.__data_);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p.__r_.__value_.__l.__data_);
  }

  CLMicroLocationProto::RetrievedLoi::~RetrievedLoi((CLMicroLocationProto::RetrievedLoi *)v32);
}

void sub_2419EDC80(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,std::exception a30)
{
  void *v30;

  CLMicroLocationProto::RetrievedLoi::~RetrievedLoi((CLMicroLocationProto::RetrievedLoi *)&a15);
  _Unwind_Resume(a1);
}

void CLMicroLocationLogic::reloadWifiChannelHistogram(CLMicroLocationLogic *this)
{
  id v2;
  void *v3;
  NSObject *v4;
  void *p_p;
  std::string *v6;
  id v7;
  void *v8;
  NSObject *v9;
  std::string *v10;
  _OWORD *v11;
  std::string *v12;
  int data;
  int v14;
  NSObject *v16;
  uint64_t v17;
  uint64_t i;
  _QWORD *v19;
  _QWORD *v20;
  NSObject *v21;
  void *v22;
  uint64_t v23;
  void *v24;
  char v25;
  std::string v26;
  void *__p;
  _BYTE v28[20];
  uint8_t __src[16];
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  _OWORD v37[5];
  uint64_t v38;
  uint8_t buf[32];
  _BYTE v40[112];
  uint64_t v41;
  __int128 v42;
  uint64_t v43;

  v43 = *MEMORY[0x24BDAC8D0];
  v42 = *((_OWORD *)this + 5);
  if (*((char *)this + 79) < 0)
    std::string::__init_copy_ctor_external(&v26, *((const std::string::value_type **)this + 7), *((_QWORD *)this + 8));
  else
    v26 = *(std::string *)((char *)this + 56);
  v2 = *(id *)(*((_QWORD *)this + 16) + 32);
  v3 = v2;
  if (v2)
  {
    objc_msgSend(v2, "fetchMostRecentWifiChannelHistogramAtLoi:", &v42);
  }
  else
  {
    v41 = 0;
    memset(v40, 0, sizeof(v40));
  }

  if (!(_BYTE)v41)
  {
    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_3);
    v4 = (id)logObject_MicroLocation_Default;
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
    {
      __p = 0;
      *(_QWORD *)v28 = 0;
      *(_QWORD *)&v28[8] = 0;
      if ((boost::conversion::detail::try_lexical_convert<std::string,boost::uuids::uuid>((uint64_t)&v42, (std::string *)&__p) & 1) == 0)
      {
        std::bad_cast::bad_cast((std::bad_cast *)__src);
        *(_QWORD *)__src = &unk_2511D2C18;
        boost::throw_exception<boost::bad_lexical_cast>((uint64_t)__src);
      }
      p_p = &__p;
      if (v28[15] < 0)
        p_p = __p;
      v6 = &v26;
      if ((v26.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
        v6 = (std::string *)v26.__r_.__value_.__r.__words[0];
      *(_DWORD *)buf = 136380931;
      *(_QWORD *)&buf[4] = p_p;
      *(_WORD *)&buf[12] = 2081;
      *(_QWORD *)&buf[14] = v6;
      _os_log_impl(&dword_2419D9000, v4, OS_LOG_TYPE_DEBUG, "Don't have a current wifi channel histogram for this LOI id %{private}s. Using histogram using LOI type only %{private}s.", buf, 0x16u);
      if ((v28[15] & 0x80000000) != 0)
        operator delete(__p);
    }

    v7 = *(id *)(*((_QWORD *)this + 16) + 32);
    v8 = v7;
    __p = 0;
    *(_QWORD *)v28 = 0;
    if (v7)
    {
      objc_msgSend(v7, "fetchMostRecentWifiChannelHistogramAtLoi:", &__p);
    }
    else
    {
      *(_QWORD *)&v36 = 0;
      v34 = 0u;
      v35 = 0u;
      v32 = 0u;
      v33 = 0u;
      v30 = 0u;
      v31 = 0u;
      *(_OWORD *)__src = 0u;
    }
    std::__optional_storage_base<CLMicroLocationConfigurationTable::Entry,false>::__assign_from[abi:ne180100]<std::__optional_move_assign_base<CLMicroLocationConfigurationTable::Entry,false>>((uint64_t)v40, (uint64_t)__src);
    std::__optional_destruct_base<CLMicroLocationConfigurationTable::Entry,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)__src);

    if (!(_BYTE)v41)
    {
      if (onceToken_MicroLocation_Default != -1)
        dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_3);
      v9 = logObject_MicroLocation_Default;
      if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEBUG))
      {
        v10 = &v26;
        if ((v26.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
          v10 = (std::string *)v26.__r_.__value_.__r.__words[0];
        *(_DWORD *)__src = 136380675;
        *(_QWORD *)&__src[4] = v10;
        _os_log_impl(&dword_2419D9000, v9, OS_LOG_TYPE_DEBUG, "Don't have wifi channel histogram for current LOI type %{private}s. Using default wifi histogram", __src, 0xCu);
      }
    }
  }
  v11 = operator new(0x68uLL);
  *(_QWORD *)&buf[16] = (char *)v11 + 104;
  *v11 = xmmword_241BB2420;
  v11[1] = xmmword_241BB2430;
  v11[2] = xmmword_241BB2440;
  v11[3] = xmmword_241BB2450;
  v11[4] = xmmword_241BB2460;
  v11[5] = xmmword_241BB2470;
  *((_QWORD *)v11 + 12) = 13;
  *(_QWORD *)buf = v11;
  *(_QWORD *)&buf[8] = (char *)v11 + 104;
  if (SHIBYTE(v26.__r_.__value_.__r.__words[2]) < 0)
  {
    if (v26.__r_.__value_.__l.__size_ != 6)
      goto LABEL_39;
    v12 = (std::string *)v26.__r_.__value_.__r.__words[0];
  }
  else
  {
    if (SHIBYTE(v26.__r_.__value_.__r.__words[2]) != 6)
      goto LABEL_39;
    v12 = &v26;
  }
  data = (int)v12->__r_.__value_.__l.__data_;
  v14 = WORD2(v12->__r_.__value_.__r.__words[0]);
  if (data == 1953723747 && v14 == 28015)
  {
    *(_OWORD *)__src = xmmword_241BB2420;
    v30 = xmmword_241BB2430;
    v31 = xmmword_241BB2440;
    v32 = xmmword_241BB2450;
    v33 = xmmword_241BB2460;
    v34 = xmmword_241BB2470;
    v35 = xmmword_241BB2480;
    v36 = xmmword_241BB2490;
    v37[0] = xmmword_241BB24A0;
    v37[1] = xmmword_241BB24B0;
    v37[2] = xmmword_241BB24C0;
    v37[3] = xmmword_241BB24D0;
    v37[4] = xmmword_241BB24E0;
    std::vector<CLMicroLocationWiFiChannelHistogram>::__assign_with_size[abi:ne180100]<CLMicroLocationWiFiChannelHistogram const*,CLMicroLocationWiFiChannelHistogram const*>((char *)buf, (char *)__src, (uint64_t)&v38, 0x1AuLL);
  }
LABEL_39:
  if ((_BYTE)v41)
  {
    CLMicroLocationWiFiChannelHistogramAnalyzer::histogramFromProtobuf((uint64_t)&v40[56], (unsigned __int8 *)&v26, (void **)__src);
    if (*(_QWORD *)buf)
    {
      *(_QWORD *)&buf[8] = *(_QWORD *)buf;
      operator delete(*(void **)buf);
    }
    *(_OWORD *)buf = *(_OWORD *)__src;
    *(_QWORD *)&buf[16] = v30;
  }
  CLMicroLocationSensorsLogic::reloadWifiChannelHistogram((uint64_t)this + 712, (uint64_t)buf);
  if (onceToken_MicroLocation_Default != -1)
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_3);
  v16 = logObject_MicroLocation_Default;
  if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)__src = 0;
    _os_log_impl(&dword_2419D9000, v16, OS_LOG_TYPE_DEFAULT, "Reloaded wifi channel histogram", __src, 2u);
  }
  if (onceToken_MicroLocation_Default != -1)
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_3);
  if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_INFO))
  {
    std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)__src);
    v17 = *(_QWORD *)buf;
    for (i = *(_QWORD *)&buf[8]; v17 != i; v17 += 8)
    {
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v30, (uint64_t)"channel: ", 9);
      v19 = (_QWORD *)std::ostream::operator<<();
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v19, (uint64_t)" count: ", 8);
      v20 = (_QWORD *)std::ostream::operator<<();
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v20, (uint64_t)", ", 2);
    }
    std::stringbuf::str();
    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_3);
    v21 = logObject_MicroLocation_Default;
    if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_INFO))
    {
      v22 = &v24;
      if (v25 < 0)
        v22 = v24;
      __p = (void *)68289283;
      *(_WORD *)v28 = 2082;
      *(_QWORD *)&v28[2] = "";
      *(_WORD *)&v28[10] = 2081;
      *(_QWORD *)&v28[12] = v22;
      _os_log_impl(&dword_2419D9000, v21, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Wifi channel histogram:\", \"Histogram\":%{private, location:escape_only}s}", (uint8_t *)&__p, 0x1Cu);
    }
    if (v25 < 0)
      operator delete(v24);
    *(_QWORD *)__src = *MEMORY[0x24BEDB7F0];
    v23 = *(_QWORD *)(MEMORY[0x24BEDB7F0] + 72);
    *(_QWORD *)&__src[*(_QWORD *)(*(_QWORD *)__src - 24)] = *(_QWORD *)(MEMORY[0x24BEDB7F0] + 64);
    *(_QWORD *)&v30 = v23;
    *((_QWORD *)&v30 + 1) = MEMORY[0x24BEDB848] + 16;
    if (SHIBYTE(v35) < 0)
      operator delete(*((void **)&v34 + 1));
    std::streambuf::~streambuf();
    std::iostream::~basic_iostream();
    MEMORY[0x2426A0444](v37);
  }
  if (*(_QWORD *)buf)
  {
    *(_QWORD *)&buf[8] = *(_QWORD *)buf;
    operator delete(*(void **)buf);
  }
  std::__optional_destruct_base<CLMicroLocationConfigurationTable::Entry,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)v40);
  if (SHIBYTE(v26.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v26.__r_.__value_.__l.__data_);
}

void sub_2419EE3CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, void *a20,uint64_t a21,uint64_t a22,uint64_t a23,std::exception a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,void *__p)
{
  uint64_t v60;

  if (__p)
    operator delete(__p);
  std::__optional_destruct_base<CLMicroLocationConfigurationTable::Entry,false>::~__optional_destruct_base[abi:ne180100](v60 - 240);
  if (a18 < 0)
    operator delete(a13);
  _Unwind_Resume(a1);
}

void CLMicroLocationProtobufHelper::createLoggedEvent<CLMicroLocationProto::RetrievedLoi>(_OWORD *a1@<X0>, int *a2@<X1>, uint64_t a3@<X8>, double a4@<D0>)
{
  const CLMicroLocationProto::RetrievedLoi *v8;
  _BYTE v9[304];

  CLMicroLocationProto::ReceivedEvent::ReceivedEvent((CLMicroLocationProto::ReceivedEvent *)v9);
  CLMicroLocationProtobufHelper::setSpecificLoggedEvent((CLMicroLocationProtobufHelper *)v9, (CLMicroLocationProto::ReceivedEvent *)a2, v8);
  CLMicroLocationLoggedEventsTable::Entry::Entry(a3, a1, a2[6], (CLMicroLocationProto::ReceivedEvent *)v9, a4);
  CLMicroLocationProto::ReceivedEvent::~ReceivedEvent((CLMicroLocationProto::ReceivedEvent *)v9);
}

void sub_2419EE4F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  CLMicroLocationProto::ReceivedEvent::~ReceivedEvent((CLMicroLocationProto::ReceivedEvent *)&a9);
  _Unwind_Resume(a1);
}

void CLMicroLocationLogic::startRapportSessionIfStopped(CLMicroLocationLogic *this)
{
  CLMicroLocationRapportMonitor *v2;
  NSObject *v3;
  NSObject *v4;
  uint8_t v5[16];
  uint8_t buf[16];

  v2 = (CLMicroLocationLogic *)((char *)this + 1464);
  CLMicroLocationRapportMonitor::setCurrentLOIType((std::string *)this + 61, (const std::string *)((char *)this + 56));
  CLMicroLocationRapportMonitor::setCurrentLoiGroupId(v2, (__n128 *)this + 5);
  if (*((_BYTE *)this + 54))
  {
    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_3);
    v3 = logObject_MicroLocation_Default;
    if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_2419D9000, v3, OS_LOG_TYPE_DEFAULT, "Rapport, rapport session already running", buf, 2u);
    }
  }
  else
  {
    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_3);
    v4 = logObject_MicroLocation_Default;
    if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)v5 = 0;
      _os_log_impl(&dword_2419D9000, v4, OS_LOG_TYPE_DEFAULT, "Rapport, start rapport session", v5, 2u);
    }
    (*(void (**)(_QWORD))(**((_QWORD **)this + 323) + 88))(*((_QWORD *)this + 323));
    CLMicroLocationLogic::State::setRapportSessionRunning((CLMicroLocationLogic *)((char *)this + 48), 1);
  }
}

double CLMicroLocationLogic::stopRapportSessionIfRunning(CLMicroLocationLogic *this)
{
  NSObject *v2;
  NSObject *v3;
  double result;
  uint8_t v5[16];
  uint8_t buf[16];

  if (*((_BYTE *)this + 54))
  {
    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_3);
    v2 = logObject_MicroLocation_Default;
    if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_2419D9000, v2, OS_LOG_TYPE_DEFAULT, "Rapport, stopping rapport session", buf, 2u);
    }
    (*(void (**)(_QWORD))(**((_QWORD **)this + 323) + 96))(*((_QWORD *)this + 323));
    CLMicroLocationRapportMonitor::backup((CLMicroLocationLogic *)((char *)this + 1464));
    CLMicroLocationRapportMonitor::reset((CLMicroLocationLogic *)((char *)this + 1464));
    CLMicroLocationLogic::State::setRapportSessionRunning((CLMicroLocationLogic *)((char *)this + 48), 0);
  }
  else
  {
    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_3);
    v3 = logObject_MicroLocation_Default;
    if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)v5 = 0;
      _os_log_impl(&dword_2419D9000, v3, OS_LOG_TYPE_DEFAULT, "Rapport, rapport session already stopped", v5, 2u);
    }
  }
  CLMicroLocationRapportMonitor::setCurrentLOIType((std::string *)this + 61, (const std::string *)((char *)this + 56));
  *(_QWORD *)&result = CLMicroLocationRapportMonitor::setCurrentLoiGroupId((CLMicroLocationLogic *)((char *)this + 1464), (__n128 *)this + 5).n128_u64[0];
  return result;
}

void CLMicroLocationLogic::onUpdateSpectating(CLMicroLocationLogic *this, int a2)
{
  int v3;
  void *v4;
  NSObject *v5;
  uint64_t v6;
  double v7;
  void *v8;
  void *v9;
  void *v10;
  void *v11;
  int v12;
  NSObject *v13;
  uint64_t v14;
  double v15;
  void *v16;
  NSObject *v17;
  uint64_t v18;
  double v19;
  int v20;
  NSObject *v21;
  uint64_t v22;
  double v23;
  int v24[5];
  int v25;
  int v26;
  int v27;
  __int128 v28;
  uint8_t buf[32];
  _QWORD v30[40];

  v30[39] = *MEMORY[0x24BDAC8D0];
  v3 = *((unsigned __int8 *)this + 49);
  if (a2)
  {
    if (!*((_BYTE *)this + 49))
    {
      +[ULTransactionManager shared](ULTransactionManager, "shared");
      v4 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v4, "beginTransaction:", CFSTR("com.apple.milod.CLMicroLocationLogic.Spectating"));

      if (onceToken_MicroLocation_Default != -1)
        dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_3);
      v5 = logObject_MicroLocation_Default;
      if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl(&dword_2419D9000, v5, OS_LOG_TYPE_DEFAULT, "CLMicroLocationLogic: startSpectating", buf, 2u);
      }
      v27 = 0;
      boost::uuids::detail::random_provider_base::random_provider_base((boost::uuids::detail::random_provider_base *)&v27);
      *(_QWORD *)&v28 = boost::uuids::random_generator_pure::operator()((uint64_t)&v27);
      *((_QWORD *)&v28 + 1) = v6;
      v7 = cl::chrono::CFAbsoluteTimeClock::now();
      CLMicroLocationProto::StartSpectating::StartSpectating((CLMicroLocationProto::StartSpectating *)v24);
      CLMicroLocationProtobufHelper::createLoggedEvent<CLMicroLocationProto::StartSpectating>(&v28, v24, (uint64_t)buf, v7);
      (*(void (**)(CLMicroLocationLogic *, uint8_t *))(*(_QWORD *)this + 120))(this, buf);
      CLMicroLocationProto::ReceivedEvent::~ReceivedEvent((CLMicroLocationProto::ReceivedEvent *)v30);
      CLMicroLocationProto::StartSpectating::~StartSpectating((CLMicroLocationProto::StartSpectating *)v24);
      boost::uuids::detail::random_provider_base::destroy((boost::uuids::detail::random_provider_base *)&v27);
    }
    CLMicroLocationSensorsLogic::startSpectatingSensors((id *)this + 89);
    +[ULDefaultsSingleton shared](ULDefaultsSingleton, "shared");
    v8 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v8, "defaultsDictionary");
    v9 = (void *)objc_claimAutoreleasedReturnValue();

    objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "ULRapportUsageEnabled");
    v10 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v9, "objectForKey:", v10);
    v11 = (void *)objc_claimAutoreleasedReturnValue();
    if (v11 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
      v12 = objc_msgSend(v11, "BOOLValue");
    else
      v12 = objc_msgSend(MEMORY[0x24BDBD1C8], "BOOLValue");
    v20 = v12;

    if (v20)
      CLMicroLocationLogic::startRapportSessionIfStopped(this);
    else
      CLMicroLocationLogic::stopRapportSessionIfRunning(this);
    *((_BYTE *)this + 49) = 1;
    CLMicroLocationTriggerManager::setSpectatingEnabled((CLMicroLocationLogic *)((char *)this + 1560), 1);
    if (ULSettings::get<ULSettings::PedestrianFenceWhenSpectatingEnabled>())
    {
      (*(void (**)(CLMicroLocationLogic *))(*(_QWORD *)this + 304))(this);
      (*(void (**)(CLMicroLocationLogic *))(*(_QWORD *)this + 320))(this);
      if (onceToken_MicroLocation_Default != -1)
        dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_3);
      v21 = logObject_MicroLocation_Default;
      if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl(&dword_2419D9000, v21, OS_LOG_TYPE_DEFAULT, "Starting Motion Session MiLo is starting spectating", buf, 2u);
      }
      CLMicroLocationProto::MotionEvent::MotionEvent((CLMicroLocationProto::MotionEvent *)v24);
      if (!CLMicroLocationProto::MotionEvent_Status_IsValid((CLMicroLocationProto *)2))
        __assert_rtn("set_status", "microlocation.pb.h", 18149, "::CLMicroLocationProto::MotionEvent_Status_IsValid(value)");
      v26 |= 4u;
      v25 = 2;
      v27 = 0;
      boost::uuids::detail::random_provider_base::random_provider_base((boost::uuids::detail::random_provider_base *)&v27);
      *(_QWORD *)&v28 = boost::uuids::random_generator_pure::operator()((uint64_t)&v27);
      *((_QWORD *)&v28 + 1) = v22;
      v23 = cl::chrono::CFAbsoluteTimeClock::now();
      CLMicroLocationProtobufHelper::createLoggedEvent<CLMicroLocationProto::MotionEvent>(&v28, v24, (uint64_t)buf, v23);
      (*(void (**)(CLMicroLocationLogic *, uint8_t *))(*(_QWORD *)this + 120))(this, buf);
      CLMicroLocationProto::ReceivedEvent::~ReceivedEvent((CLMicroLocationProto::ReceivedEvent *)v30);
      boost::uuids::detail::random_provider_base::destroy((boost::uuids::detail::random_provider_base *)&v27);
      CLMicroLocationProto::MotionEvent::~MotionEvent((CLMicroLocationProto::MotionEvent *)v24);
    }
  }
  else
  {
    CLMicroLocationSensorsLogic::stopSpectatingSensors((CLMicroLocationLogic *)((char *)this + 712));
    CLMicroLocationLogic::stopRapportSessionIfRunning(this);
    CLMicroLocationLogic::stopCurrentRecordingOrLocalization((unsigned __int8 *)this, 1u);
    CLMicroLocationLocalizationController::invalidateCachedLocalizationInput((CLMicroLocationLogic *)((char *)this + 168));
    *((_BYTE *)this + 49) = 0;
    CLMicroLocationTriggerManager::setSpectatingEnabled((CLMicroLocationLogic *)((char *)this + 1560), 0);
    if (ULSettings::get<ULSettings::PedestrianFenceWhenSpectatingEnabled>())
    {
      if (onceToken_MicroLocation_Default != -1)
        dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_3);
      v13 = logObject_MicroLocation_Default;
      if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl(&dword_2419D9000, v13, OS_LOG_TYPE_DEFAULT, "Stopping PDR Fence because MiLo is no longer spectating", buf, 2u);
      }
      CLMicroLocationProto::MotionEvent::MotionEvent((CLMicroLocationProto::MotionEvent *)v24);
      if (!CLMicroLocationProto::MotionEvent_Status_IsValid((CLMicroLocationProto *)3))
        __assert_rtn("set_status", "microlocation.pb.h", 18149, "::CLMicroLocationProto::MotionEvent_Status_IsValid(value)");
      v26 |= 4u;
      v25 = 3;
      v27 = 0;
      boost::uuids::detail::random_provider_base::random_provider_base((boost::uuids::detail::random_provider_base *)&v27);
      *(_QWORD *)&v28 = boost::uuids::random_generator_pure::operator()((uint64_t)&v27);
      *((_QWORD *)&v28 + 1) = v14;
      v15 = cl::chrono::CFAbsoluteTimeClock::now();
      CLMicroLocationProtobufHelper::createLoggedEvent<CLMicroLocationProto::MotionEvent>(&v28, v24, (uint64_t)buf, v15);
      (*(void (**)(CLMicroLocationLogic *, uint8_t *))(*(_QWORD *)this + 120))(this, buf);
      CLMicroLocationProto::ReceivedEvent::~ReceivedEvent((CLMicroLocationProto::ReceivedEvent *)v30);
      boost::uuids::detail::random_provider_base::destroy((boost::uuids::detail::random_provider_base *)&v27);
      CLMicroLocationProto::MotionEvent::~MotionEvent((CLMicroLocationProto::MotionEvent *)v24);
    }
    if (v3)
    {
      +[ULTransactionManager shared](ULTransactionManager, "shared");
      v16 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v16, "endTransaction:", CFSTR("com.apple.milod.CLMicroLocationLogic.Spectating"));

      if (onceToken_MicroLocation_Default != -1)
        dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_3);
      v17 = logObject_MicroLocation_Default;
      if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl(&dword_2419D9000, v17, OS_LOG_TYPE_DEFAULT, "CLMicroLocationLogic: Stop Spectating", buf, 2u);
      }
      v27 = 0;
      boost::uuids::detail::random_provider_base::random_provider_base((boost::uuids::detail::random_provider_base *)&v27);
      *(_QWORD *)&v28 = boost::uuids::random_generator_pure::operator()((uint64_t)&v27);
      *((_QWORD *)&v28 + 1) = v18;
      v19 = cl::chrono::CFAbsoluteTimeClock::now();
      CLMicroLocationProto::StopSpectating::StopSpectating((CLMicroLocationProto::StopSpectating *)v24);
      CLMicroLocationProtobufHelper::createLoggedEvent<CLMicroLocationProto::StopSpectating>(&v28, v24, (uint64_t)buf, v19);
      (*(void (**)(CLMicroLocationLogic *, uint8_t *))(*(_QWORD *)this + 120))(this, buf);
      CLMicroLocationProto::ReceivedEvent::~ReceivedEvent((CLMicroLocationProto::ReceivedEvent *)v30);
      CLMicroLocationProto::StopSpectating::~StopSpectating((CLMicroLocationProto::StopSpectating *)v24);
      boost::uuids::detail::random_provider_base::destroy((boost::uuids::detail::random_provider_base *)&v27);
    }
  }
}

void sub_2419EED50(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void CLMicroLocationProtobufHelper::createLoggedEvent<CLMicroLocationProto::StartSpectating>(_OWORD *a1@<X0>, int *a2@<X1>, uint64_t a3@<X8>, double a4@<D0>)
{
  const CLMicroLocationProto::StartSpectating *v8;
  _BYTE v9[304];

  CLMicroLocationProto::ReceivedEvent::ReceivedEvent((CLMicroLocationProto::ReceivedEvent *)v9);
  CLMicroLocationProtobufHelper::setSpecificLoggedEvent((CLMicroLocationProtobufHelper *)v9, (CLMicroLocationProto::ReceivedEvent *)a2, v8);
  CLMicroLocationLoggedEventsTable::Entry::Entry(a3, a1, a2[2], (CLMicroLocationProto::ReceivedEvent *)v9, a4);
  CLMicroLocationProto::ReceivedEvent::~ReceivedEvent((CLMicroLocationProto::ReceivedEvent *)v9);
}

void sub_2419EEEC0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  CLMicroLocationProto::ReceivedEvent::~ReceivedEvent((CLMicroLocationProto::ReceivedEvent *)&a9);
  _Unwind_Resume(a1);
}

uint64_t ULSettings::get<ULSettings::PedestrianFenceWhenSpectatingEnabled>()
{
  void *v0;
  void *v1;
  void *v2;
  void *v3;
  uint64_t v4;
  uint64_t v5;

  +[ULDefaultsSingleton shared](ULDefaultsSingleton, "shared");
  v0 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v0, "defaultsDictionary");
  v1 = (void *)objc_claimAutoreleasedReturnValue();

  objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "ULPedestrianFenceWhenSpectatingEnabled");
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v1, "objectForKey:", v2);
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  if (v3 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
    v4 = objc_msgSend(v3, "BOOLValue");
  else
    v4 = objc_msgSend(MEMORY[0x24BDBD1C0], "BOOLValue");
  v5 = v4;

  return v5;
}

{
  void *v0;
  void *v1;
  void *v2;
  void *v3;
  uint64_t v4;
  uint64_t v5;

  +[ULDefaultsSingleton shared](ULDefaultsSingleton, "shared");
  v0 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v0, "defaultsDictionary");
  v1 = (void *)objc_claimAutoreleasedReturnValue();

  objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "ULPedestrianFenceWhenSpectatingEnabled");
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v1, "objectForKey:", v2);
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  if (v3 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
    v4 = objc_msgSend(v3, "BOOLValue");
  else
    v4 = objc_msgSend(MEMORY[0x24BDBD1C0], "BOOLValue");
  v5 = v4;

  return v5;
}

void sub_2419EEF94(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void CLMicroLocationLogic::stopCurrentRecordingOrLocalization(unsigned __int8 *a1, unsigned int a2)
{
  int v3;
  NSObject *v4;
  NSObject *v6;
  int v7;
  uint8_t buf[8];
  __int128 v9;
  uint64_t *v10;
  _QWORD *v11[2];
  int v12;
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  v3 = a1[53];
  if (v3 == 2)
  {
    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_3);
    v4 = logObject_MicroLocation_Default;
    if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 68289026;
      *(_DWORD *)&buf[4] = 0;
      LOWORD(v9) = 2082;
      *(_QWORD *)((char *)&v9 + 2) = "";
      _os_log_impl(&dword_2419D9000, v4, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"interrupting an ongoing recording\"}", buf, 0x12u);
    }
    CLMicroLocationSensorsLogic::onRecordingOrLocalizingInterrupted((CLMicroLocationSensorsLogic *)(a1 + 712));
    v11[0] = 0;
    v11[1] = 0;
    *(_QWORD *)buf = 0;
    v9 = 0uLL;
    v10 = (uint64_t *)v11;
    v12 = 2;
    v7 = 2;
    std::__tree<CLMicroLocationRecordingCompletionMetaInformation::RecordingError>::__emplace_unique_key_args<CLMicroLocationRecordingCompletionMetaInformation::RecordingError,CLMicroLocationRecordingCompletionMetaInformation::RecordingError>(&v10, &v7, &v7);
    CLMicroLocationLogic::stopRecording((uint64_t)a1, (uint64_t)buf);
    std::__tree<std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>,std::__map_value_compare<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>,std::less<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes>,true>,std::allocator<std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>>>::destroy((uint64_t)&v10, v11[0]);
  }
  else if (v3 == 1)
  {
    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_3);
    v6 = logObject_MicroLocation_Default;
    if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 68289026;
      *(_DWORD *)&buf[4] = 0;
      LOWORD(v9) = 2082;
      *(_QWORD *)((char *)&v9 + 2) = "";
      _os_log_impl(&dword_2419D9000, v6, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"interrupting an ongoing localization\"}", buf, 0x12u);
    }
    CLMicroLocationSensorsLogic::onRecordingOrLocalizingInterrupted((CLMicroLocationSensorsLogic *)(a1 + 712));
    CLMicroLocationLogic::stopLocalizing((uint64_t)a1, a2);
  }
  else if (!a1[53])
  {
    CLMicroLocationRecorder::clearPendingRecordsBuff((CLMicroLocationRecorder *)(a1 + 664));
  }
}

void sub_2419EF1F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, _QWORD *a15)
{
  uint64_t v15;

  std::__tree<std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>,std::__map_value_compare<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>,std::less<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes>,true>,std::allocator<std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>>>::destroy(v15, a15);
  _Unwind_Resume(a1);
}

void CLMicroLocationProtobufHelper::createLoggedEvent<CLMicroLocationProto::StopSpectating>(_OWORD *a1@<X0>, int *a2@<X1>, uint64_t a3@<X8>, double a4@<D0>)
{
  const CLMicroLocationProto::StopSpectating *v8;
  _BYTE v9[304];

  CLMicroLocationProto::ReceivedEvent::ReceivedEvent((CLMicroLocationProto::ReceivedEvent *)v9);
  CLMicroLocationProtobufHelper::setSpecificLoggedEvent((CLMicroLocationProtobufHelper *)v9, (CLMicroLocationProto::ReceivedEvent *)a2, v8);
  CLMicroLocationLoggedEventsTable::Entry::Entry(a3, a1, a2[2], (CLMicroLocationProto::ReceivedEvent *)v9, a4);
  CLMicroLocationProto::ReceivedEvent::~ReceivedEvent((CLMicroLocationProto::ReceivedEvent *)v9);
}

void sub_2419EF288(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  CLMicroLocationProto::ReceivedEvent::~ReceivedEvent((CLMicroLocationProto::ReceivedEvent *)&a9);
  _Unwind_Resume(a1);
}

void `non-virtual thunk to'CLMicroLocationLogic::onUpdateSpectating(CLMicroLocationLogic *this, int a2)
{
  CLMicroLocationLogic::onUpdateSpectating((CLMicroLocationLogic *)((char *)this - 24), a2);
}

void CLMicroLocationLogic::onRapportCompanionDeviceFound(uint64_t a1, uint64_t a2, uint64_t a3, __int128 *a4)
{
  NSObject *v8;
  uint8_t v9[16];

  if (!*(_BYTE *)(a1 + 54))
  {
    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_3);
    v8 = logObject_MicroLocation_Default;
    if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)v9 = 0;
      _os_log_impl(&dword_2419D9000, v8, OS_LOG_TYPE_DEBUG, "Rapport device found while session is not running", v9, 2u);
    }
  }
  if (CLMicroLocationsMeasurementFilters::isAnchorModelValid(a3, (std::locale::__imp **)(a1 + 2600)))
    CLMicroLocationRapportMonitor::deviceFound(a1 + 1464, a2, a4);
}

void CLMicroLocationLogic::setLocationServicesEnabled(CLMicroLocationLogic *this, int a2)
{
  NSObject *v4;
  const char *v5;
  int v6;
  const char *v7;
  uint64_t v8;

  v8 = *MEMORY[0x24BDAC8D0];
  if (onceToken_MicroLocation_Default != -1)
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_3);
  v4 = logObject_MicroLocation_Default;
  if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEBUG))
  {
    v5 = "disabled";
    if (a2)
      v5 = "enabled";
    v6 = 136446210;
    v7 = v5;
    _os_log_impl(&dword_2419D9000, v4, OS_LOG_TYPE_DEBUG, "Location services set to %{public}s", (uint8_t *)&v6, 0xCu);
  }
  *((_BYTE *)this + 50) = a2;
  CLMicroLocationLogic::updateEnabled(this);
}

void CLMicroLocationLogic::setSignificantLocationsEnabled(CLMicroLocationLogic *this, int a2)
{
  NSObject *v4;
  const char *v5;
  int v6;
  const char *v7;
  uint64_t v8;

  v8 = *MEMORY[0x24BDAC8D0];
  if (onceToken_MicroLocation_Default != -1)
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_3);
  v4 = logObject_MicroLocation_Default;
  if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEBUG))
  {
    v5 = "disabled";
    if (a2)
      v5 = "enabled";
    v6 = 136446210;
    v7 = v5;
    _os_log_impl(&dword_2419D9000, v4, OS_LOG_TYPE_DEBUG, "Significant locations set to %{public}s", (uint8_t *)&v6, 0xCu);
  }
  *((_BYTE *)this + 51) = a2;
  CLMicroLocationLogic::updateEnabled(this);
}

void CLMicroLocationLogic::setPlatformSupport(CLMicroLocationLogic *this, int a2)
{
  NSObject *v4;
  const char *v5;
  int v6;
  const char *v7;
  uint64_t v8;

  v8 = *MEMORY[0x24BDAC8D0];
  if (onceToken_MicroLocation_Default != -1)
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_3);
  v4 = logObject_MicroLocation_Default;
  if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_INFO))
  {
    v5 = "False";
    if (a2)
      v5 = "True";
    v6 = 136446210;
    v7 = v5;
    _os_log_impl(&dword_2419D9000, v4, OS_LOG_TYPE_INFO, "Platform support for milo is set to %{public}s", (uint8_t *)&v6, 0xCu);
  }
  *((_BYTE *)this + 52) = a2;
}

uint64_t CLMicroLocationLogic::onResetLocationData(CLMicroLocationLogic *this)
{
  NSObject *v2;
  void *v3;
  uint64_t v4;
  _QWORD v6[6];
  uint8_t buf[8];
  uint8_t *v8;
  uint64_t v9;
  char v10;

  if (onceToken_MicroLocation_Default != -1)
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_3);
  v2 = logObject_MicroLocation_Default;
  if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_2419D9000, v2, OS_LOG_TYPE_DEFAULT, "Got request to reset Location data. Dropping microlocation tables", buf, 2u);
  }
  *(_QWORD *)buf = 0;
  v8 = buf;
  v9 = 0x2020000000;
  v10 = 0;
  +[ULTransactionManager shared](ULTransactionManager, "shared");
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  v6[0] = MEMORY[0x24BDAC760];
  v6[1] = 3221225472;
  v6[2] = ___ZN20CLMicroLocationLogic19onResetLocationDataEv_block_invoke;
  v6[3] = &unk_2511D2718;
  v6[4] = buf;
  v6[5] = this;
  objc_msgSend(v3, "performUnderTransaction:block:", CFSTR("com.apple.milod.deleteLocationData"), v6);

  CLMiLoServiceManager::updateAllModels((CLMicroLocationLogic *)((char *)this + 1768));
  CLMicroLocationLoiManager::fetchPlaceInferenceForReason((uint64_t)this + 2024, 12);
  v4 = v8[24];
  _Block_object_dispose(buf, 8);
  return v4;
}

void sub_2419EF778(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  void *v7;
  va_list va;

  va_start(va, a7);

  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void ___ZN20CLMicroLocationLogic19onResetLocationDataEv_block_invoke(uint64_t a1)
{
  uint64_t v1;
  ULBackupAndRestore *v2;

  v1 = *(_QWORD *)(a1 + 40);
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = ULDatabase::dropTables(*(ULDatabase **)(v1 + 128));
  v2 = -[ULBackupAndRestore initWithDatabase:andEventLogger:]([ULBackupAndRestore alloc], "initWithDatabase:andEventLogger:", *(_QWORD *)(v1 + 128), v1 + 136);
  -[ULBackupAndRestore deleteBackupFiles](v2, "deleteBackupFiles");

}

void sub_2419EF7FC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void CLMicroLocationLogic::setDisplayState(_BYTE *a1, int a2, double *a3)
{
  void *v6;

  a1[108] = a2;
  if (a2)
  {
    CLMicroLocationLogic::requestLocalizationIfWiFiErrorRetryLimitReached((CLMicroLocationLogic *)a1, "display on");
    CLMicroLocationLogic::triggerFallbackLocalization((CLMicroLocationLogic *)a1);
    +[ULHomeSlamAnalytics shared](ULHomeSlamAnalytics, "shared");
    v6 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v6, "logEventScreenOnAtTimestamp:", *a3);
  }
  else
  {
    CLMicroLocationLogic::stopCurrentRecordingOrLocalization(a1, 4u);
    +[ULHomeSlamAnalytics shared](ULHomeSlamAnalytics, "shared");
    v6 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v6, "logEventScreenOffAtTimestamp:", *a3);
  }

  CLMicroLocationSensorsLogic::onDisplayStateChange((uint64_t)(a1 + 712), a2, a3);
  CLMicroLocationTriggerManager::onDisplayState((CLMicroLocationTriggerManager *)(a1 + 1560), a2);
}

void sub_2419EF8C0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void CLMicroLocationLogic::requestLocalizationIfWiFiErrorRetryLimitReached(CLMicroLocationLogic *this, const char *a2)
{
  NSObject *v4;
  double v5;
  _DWORD v6[2];
  __int16 v7;
  const char *v8;
  __int16 v9;
  const char *v10;
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  if (*((_BYTE *)this + 49) && !*((_BYTE *)this + 120))
  {
    *((_QWORD *)this + 14) = 0;
    *((_BYTE *)this + 120) = 1;
    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_3);
    v4 = logObject_MicroLocation_Default;
    if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_INFO))
    {
      v6[0] = 68289282;
      v6[1] = 0;
      v7 = 2082;
      v8 = "";
      v9 = 2082;
      v10 = a2;
      _os_log_impl(&dword_2419D9000, v4, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"localization retries have been exhausted, reset counters and trying another localization\", \"reason\":%{public, location:escape_only}s}", (uint8_t *)v6, 0x1Cu);
    }
    v5 = cl::chrono::CFAbsoluteTimeClock::now();
    CLMicroLocationLogic::createLocalizationTriggerWithOptAssociatedAccessPointInfo((uint64_t)this, (uint64_t)"InternalClientLogic", 0, (uint64_t)v6, v5);
    CLMicroLocationTriggerManager::requestLocalization((uint64_t)this + 1560, (const CLMicroLocationProto::RecordingEvent *)v6, 1, 0, 0);
    CLMicroLocationProto::RecordingEvent::~RecordingEvent((CLMicroLocationProto::RecordingEvent *)v6);
  }
}

void sub_2419EFA18(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  CLMicroLocationProto::RecordingEvent::~RecordingEvent((CLMicroLocationProto::RecordingEvent *)&a9);
  _Unwind_Resume(a1);
}

void CLMicroLocationLogic::triggerFallbackLocalization(CLMicroLocationLogic *this)
{
  double v2;
  _BYTE v3[144];

  if (*((_BYTE *)this + 49))
  {
    v2 = cl::chrono::CFAbsoluteTimeClock::now();
    CLMicroLocationLogic::createLocalizationTriggerWithOptAssociatedAccessPointInfo((uint64_t)this, (uint64_t)"InternalClientScreenOnFallback", 0, (uint64_t)v3, v2);
    CLMicroLocationTriggerManager::triggerFallbackLocalizationEvent((CLMicroLocationLogic *)((char *)this + 1560), (const CLMicroLocationProto::RecordingEvent *)v3);
    CLMicroLocationProto::RecordingEvent::~RecordingEvent((CLMicroLocationProto::RecordingEvent *)v3);
  }
}

void sub_2419EFA90(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  CLMicroLocationProto::RecordingEvent::~RecordingEvent((CLMicroLocationProto::RecordingEvent *)&a9);
  _Unwind_Resume(a1);
}

uint64_t CLMicroLocationLogic::getDisplayState(CLMicroLocationLogic *this)
{
  return *((unsigned __int8 *)this + 108);
}

uint64_t `non-virtual thunk to'CLMicroLocationLogic::getDisplayState(CLMicroLocationLogic *this)
{
  return *((unsigned __int8 *)this + 100);
}

void *CLMicroLocationLogic::currentAssociatedState(CLMicroLocationLogic *this)
{
  return CLMicroLocationSensorsLogic::State::isAssociatedToWifi((CLMicroLocationLogic *)((char *)this + 720));
}

void *`non-virtual thunk to'CLMicroLocationLogic::currentAssociatedState(CLMicroLocationLogic *this)
{
  return CLMicroLocationSensorsLogic::State::isAssociatedToWifi((CLMicroLocationLogic *)((char *)this + 712));
}

id CLMicroLocationLogic::currentAssociatedWifiAPInfo(id *this)
{
  return CLMicroLocationSensorsLogic::State::currentAssociatedWiFiAPInfo(this + 90);
}

id `non-virtual thunk to'CLMicroLocationLogic::currentAssociatedWifiAPInfo(id *this)
{
  return CLMicroLocationSensorsLogic::State::currentAssociatedWiFiAPInfo(this + 89);
}

void CLMicroLocationLogic::startStaticDetector(CLMicroLocationLogic *this)
{
  *((_BYTE *)this + 2592) = 1;
  CLMicroLocationTriggerManager::onDeviceStaticState((CLMiLoCustomLoiRecordingManager **)this + 195, *((_BYTE *)this + 127));
}

void `non-virtual thunk to'CLMicroLocationLogic::startStaticDetector(CLMicroLocationLogic *this)
{
  *((_BYTE *)this + 2584) = 1;
  CLMicroLocationTriggerManager::onDeviceStaticState((CLMiLoCustomLoiRecordingManager **)this + 194, *((_BYTE *)this + 119));
}

uint64_t CLMicroLocationLogic::stopStaticDetector(uint64_t this)
{
  *(_BYTE *)(this + 2592) = 0;
  return this;
}

uint64_t `non-virtual thunk to'CLMicroLocationLogic::stopStaticDetector(uint64_t this)
{
  *(_BYTE *)(this + 2584) = 0;
  return this;
}

uint64_t CLMicroLocationLogic::setRecordingFence(CLMicroLocationLogic *this)
{
  return CLMicroLocationSensorsLogic::startCustomLoiRecordingFence((CLMicroLocationLogic *)((char *)this + 712));
}

uint64_t `non-virtual thunk to'CLMicroLocationLogic::setRecordingFence(CLMicroLocationLogic *this)
{
  return CLMicroLocationSensorsLogic::startCustomLoiRecordingFence((CLMicroLocationLogic *)((char *)this + 704));
}

uint64_t CLMicroLocationLogic::clearRecordingFence(CLMicroLocationLogic *this)
{
  return CLMicroLocationSensorsLogic::teardownCustomLoiRecordingFence((CLMicroLocationLogic *)((char *)this + 712));
}

uint64_t `non-virtual thunk to'CLMicroLocationLogic::clearRecordingFence(CLMicroLocationLogic *this)
{
  return CLMicroLocationSensorsLogic::teardownCustomLoiRecordingFence((CLMicroLocationLogic *)((char *)this + 704));
}

void CLMicroLocationLogic::onCustomLoiRecordingSessionCompleted(CLMicroLocationLogic *this)
{
  std::string *p_p;
  int data;
  int v4;
  NSObject *v6;
  std::string *v7;
  NSObject *v8;
  std::string *v9;
  std::string __p;
  uint8_t buf[4];
  int v12;
  __int16 v13;
  const char *v14;
  __int16 v15;
  std::string *v16;
  uint64_t v17;

  v17 = *MEMORY[0x24BDAC8D0];
  if (*((char *)this + 79) < 0)
    std::string::__init_copy_ctor_external(&__p, *((const std::string::value_type **)this + 7), *((_QWORD *)this + 8));
  else
    __p = *(std::string *)((char *)this + 56);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    if (__p.__r_.__value_.__l.__size_ != 6)
      goto LABEL_13;
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  else
  {
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) != 6)
      goto LABEL_13;
    p_p = &__p;
  }
  data = (int)p_p->__r_.__value_.__l.__data_;
  v4 = WORD2(p_p->__r_.__value_.__r.__words[0]);
  if (data == 1953723747 && v4 == 28015)
  {
    (*(void (**)(_QWORD, char *))(**((_QWORD **)this + 323) + 112))(*((_QWORD *)this + 323), (char *)this + 80);
    goto LABEL_26;
  }
LABEL_13:
  if (onceToken_MicroLocation_Default != -1)
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_3);
  v6 = logObject_MicroLocation_Default;
  if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_ERROR))
  {
    v7 = &__p;
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
      v7 = (std::string *)__p.__r_.__value_.__r.__words[0];
    *(_DWORD *)buf = 68289282;
    v12 = 0;
    v13 = 2082;
    v14 = "";
    v15 = 2082;
    v16 = v7;
    _os_log_impl(&dword_2419D9000, v6, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"onCustomLoiRecordingSessionCompleted while current LOI is not custom\", \"current LOI type\":%{public, location:escape_only}s}", buf, 0x1Cu);
  }
  if (onceToken_MicroLocation_Default != -1)
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_3);
  v8 = logObject_MicroLocation_Default;
  if (os_signpost_enabled((os_log_t)logObject_MicroLocation_Default))
  {
    v9 = &__p;
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
      v9 = (std::string *)__p.__r_.__value_.__r.__words[0];
    *(_DWORD *)buf = 68289282;
    v12 = 0;
    v13 = 2082;
    v14 = "";
    v15 = 2082;
    v16 = v9;
    _os_signpost_emit_with_name_impl(&dword_2419D9000, v8, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "onCustomLoiRecordingSessionCompleted while current LOI is not custom", "{\"msg%{public}.0s\":\"onCustomLoiRecordingSessionCompleted while current LOI is not custom\", \"current LOI type\":%{public, location:escape_only}s}", buf, 0x1Cu);
  }
LABEL_26:
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
}

void sub_2419EFD78(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void `non-virtual thunk to'CLMicroLocationLogic::onCustomLoiRecordingSessionCompleted(CLMicroLocationLogic *this)
{
  CLMicroLocationLogic::onCustomLoiRecordingSessionCompleted((CLMicroLocationLogic *)((char *)this - 8));
}

void CLMicroLocationLogic::setLockScreenState(CLMicroLocationLogic *this, char a2)
{
  uint64_t v4;
  double v5;
  NSObject *v6;
  int v7;
  int v8[3];
  char v9;
  int v10;
  __int128 v11;
  uint8_t buf[32];
  _QWORD v13[40];

  v13[39] = *MEMORY[0x24BDAC8D0];
  CLMicroLocationProto::ScreenStateUpdate::ScreenStateUpdate((uint64_t)v8);
  v10 |= 2u;
  v9 = a2;
  v7 = 0;
  boost::uuids::detail::random_provider_base::random_provider_base((boost::uuids::detail::random_provider_base *)&v7);
  *(_QWORD *)&v11 = boost::uuids::random_generator_pure::operator()((uint64_t)&v7);
  *((_QWORD *)&v11 + 1) = v4;
  v5 = cl::chrono::CFAbsoluteTimeClock::now();
  CLMicroLocationProtobufHelper::createLoggedEvent<CLMicroLocationProto::ScreenStateUpdate>(&v11, v8, (uint64_t)buf, v5);
  (*(void (**)(CLMicroLocationLogic *, uint8_t *))(*(_QWORD *)this + 120))(this, buf);
  CLMicroLocationProto::ReceivedEvent::~ReceivedEvent((CLMicroLocationProto::ReceivedEvent *)v13);
  boost::uuids::detail::random_provider_base::destroy((boost::uuids::detail::random_provider_base *)&v7);
  if (*((_BYTE *)this + 125) && (a2 & 1) == 0)
  {
    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_3);
    v6 = logObject_MicroLocation_Default;
    if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_2419D9000, v6, OS_LOG_TYPE_INFO, "FBSDisplay, lock screen transition to unlock screen", buf, 2u);
    }
    CLMicroLocationLogic::onScreenUnlocked(this);
  }
  *((_BYTE *)this + 125) = a2;
  CLMicroLocationProto::ScreenStateUpdate::~ScreenStateUpdate((CLMicroLocationProto::ScreenStateUpdate *)v8);
}

void sub_2419EFEF4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  CLMicroLocationProto::ScreenStateUpdate::~ScreenStateUpdate((CLMicroLocationProto::ScreenStateUpdate *)va);
  _Unwind_Resume(a1);
}

void CLMicroLocationProtobufHelper::createLoggedEvent<CLMicroLocationProto::ScreenStateUpdate>(_OWORD *a1@<X0>, int *a2@<X1>, uint64_t a3@<X8>, double a4@<D0>)
{
  const CLMicroLocationProto::ScreenStateUpdate *v8;
  _BYTE v9[304];

  CLMicroLocationProto::ReceivedEvent::ReceivedEvent((CLMicroLocationProto::ReceivedEvent *)v9);
  CLMicroLocationProtobufHelper::setSpecificLoggedEvent((CLMicroLocationProtobufHelper *)v9, (CLMicroLocationProto::ReceivedEvent *)a2, v8);
  CLMicroLocationLoggedEventsTable::Entry::Entry(a3, a1, a2[2], (CLMicroLocationProto::ReceivedEvent *)v9, a4);
  CLMicroLocationProto::ReceivedEvent::~ReceivedEvent((CLMicroLocationProto::ReceivedEvent *)v9);
}

void sub_2419EFFA8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  CLMicroLocationProto::ReceivedEvent::~ReceivedEvent((CLMicroLocationProto::ReceivedEvent *)&a9);
  _Unwind_Resume(a1);
}

void CLMicroLocationLogic::onScreenUnlocked(CLMicroLocationLogic *this)
{
  double v2;
  int v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  int v8;
  int v9;
  _BYTE v10[144];

  CLMicroLocationLogic::migrateFromLocationdIfNecessary(this);
  v2 = cl::chrono::CFAbsoluteTimeClock::now();
  CLMicroLocationLogic::createLocalizationTriggerWithOptAssociatedAccessPointInfo((uint64_t)this, (uint64_t)"InternalClientScreenUnlock", 0, (uint64_t)v10, v2);
  v3 = CLMicroLocationTriggerManager::triggerScreenUnlockLocalizationIfNeeded((CLMicroLocationLogic *)((char *)this + 1560), (const CLMicroLocationProto::RecordingEvent *)v10);
  +[ULDefaultsSingleton shared](ULDefaultsSingleton, "shared");
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v4, "defaultsDictionary");
  v5 = (void *)objc_claimAutoreleasedReturnValue();

  objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "ULNotifyInvalidResultsUponScreenUnlockLocalization");
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v5, "objectForKey:", v6);
  v7 = (void *)objc_claimAutoreleasedReturnValue();
  if (v7 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
    v8 = objc_msgSend(v7, "BOOLValue");
  else
    v8 = objc_msgSend(MEMORY[0x24BDBD1C0], "BOOLValue");
  v9 = v8;

  if (v9 && !v3)
    CLMiLoServiceManager::notifyInvalidConfidence((uint64_t)this + 1768, 3);
  CLMicroLocationProto::RecordingEvent::~RecordingEvent((CLMicroLocationProto::RecordingEvent *)v10);
}

void sub_2419F00D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  void *v9;
  void *v10;
  void *v11;

  CLMicroLocationProto::RecordingEvent::~RecordingEvent((CLMicroLocationProto::RecordingEvent *)&a9);
  _Unwind_Resume(a1);
}

void CLMicroLocationLogic::setPowerMode(CLMicroLocationLogic *this, char a2)
{
  *((_BYTE *)this + 122) = a2;
  CLMicroLocationLogic::updateEnabled(this);
}

void CLMicroLocationLogic::setAirplaneMode(CLMicroLocationLogic *this, char a2)
{
  *((_BYTE *)this + 123) = a2;
  CLMicroLocationLogic::updateEnabled(this);
}

void CLMicroLocationLogic::onBuddyComplete(CLMicroLocationLogic *this, char a2)
{
  *((_BYTE *)this + 124) = a2;
  CLMicroLocationLogic::migrateFromLocationdIfNecessary(this);
  CLMicroLocationLogic::updateEnabled(this);
}

void CLMicroLocationLogic::migrateFromLocationdIfNecessary(CLMicroLocationLogic *this)
{
  ULDatabase *v2;
  ULDataMigrator *v3;

  if (*((_BYTE *)this + 124)
    && ULDatabase::isDatabaseConnected(*((ULDatabase **)this + 16))
    && (*(unsigned int (**)(CLMicroLocationLogic *))(*(_QWORD *)this + 240))(this))
  {
    v2 = (ULDatabase *)*((_QWORD *)this + 16);
    if (*((_BYTE *)this + 52))
    {
      if (ULDatabase::getMigrationStatus(v2, 0) == 2)
      {
        v3 = -[ULDataMigrator initWithLocalDb:dataProtectionDelegate:andEventLogger:]([ULDataMigrator alloc], "initWithLocalDb:dataProtectionDelegate:andEventLogger:", *((_QWORD *)this + 16), (char *)this + 40, (char *)this + 136);
        -[ULDataMigrator migrateMiloData](v3, "migrateMiloData");
        ULDatabase::getMigrationStatus(*((ULDatabase **)this + 16), 1);
        ULDatabase::handleMigrationIterationCompleted(*((ULDatabase **)this + 16));

      }
    }
    else
    {
      ULDatabase::handleMigrationIterationCompleted(v2);
    }
  }
}

void sub_2419F0220(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

uint64_t CLMicroLocationLogic::setBluetoothPower(uint64_t this, char a2)
{
  *(_BYTE *)(this + 126) = a2;
  return this;
}

void CLMicroLocationLogic::onDisplayStateChange_OSX(CLMicroLocationLogic *this, int a2)
{
  NSObject *v4;
  const __CFString *v5;
  _BYTE v6[24];
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  if (onceToken_MicroLocation_Default != -1)
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_3);
  v4 = logObject_MicroLocation_Default;
  if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT))
  {
    v5 = CFSTR("Off");
    if (a2)
      v5 = CFSTR("On");
    *(_DWORD *)v6 = 138412290;
    *(_QWORD *)&v6[4] = v5;
    _os_log_impl(&dword_2419D9000, v4, OS_LOG_TYPE_DEFAULT, "onDisplayStateChange_OSX: screen: %@", v6, 0xCu);
  }
  *(_QWORD *)v6 = cl::chrono::CFAbsoluteTimeClock::now();
  CLMicroLocationLogic::setDisplayState(this, a2, (double *)v6);
  if (a2)
  {
    if (!CLMicroLocationLogic::State::isAtHomeLoi((CLMicroLocationLogic *)((char *)this + 48)))
      CLMicroLocationLoiManager::fetchPlaceInferenceForReason((uint64_t)this + 2024, 4);
    CLMicroLocationLogic::onMacInternalTrigger(this);
  }
}

void CLMicroLocationLogic::onModelGenerated(uint64_t a1, unsigned int a2)
{
  NSObject *v4;
  uint64_t **v5;
  int v6;
  int v7;
  int v8;
  NSObject *v10;
  char *v11;
  char *v12;
  _QWORD *v13;
  _QWORD *v14;
  NSObject *v15;
  void *p_p;
  uint64_t v17;
  void *__p;
  char v19;
  void *v20;
  char *v21;
  uint64_t v22;
  void *v23;
  _BYTE *v24;
  char v25;
  uint8_t v26[4];
  int v27;
  __int16 v28;
  const char *v29;
  __int16 v30;
  void *v31;
  uint8_t buf[8];
  __int16 v33;
  _BYTE v34[22];
  void *v35;
  char v36;
  _QWORD v37[20];
  uuid v38;

  v37[19] = *MEMORY[0x24BDAC8D0];
  if (onceToken_MicroLocation_Default != -1)
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_3);
  v4 = logObject_MicroLocation_Default;
  if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 68289282;
    *(_DWORD *)&buf[4] = 0;
    v33 = 2082;
    *(_QWORD *)v34 = "";
    *(_WORD *)&v34[8] = 2050;
    *(_QWORD *)&v34[10] = a2;
    _os_log_impl(&dword_2419D9000, v4, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"Models have been regenerated\", \"model-type\":%{public}lu}", buf, 0x1Cu);
  }
  if (a2 == 3)
  {
    v5 = (uint64_t **)(a1 + 56);
    v6 = *(char *)(a1 + 79);
    if (v6 < 0)
    {
      if (*(_QWORD *)(a1 + 64) != 6)
        return;
      v5 = (uint64_t **)*v5;
    }
    else if (v6 != 6)
    {
      return;
    }
    v7 = *(_DWORD *)v5;
    v8 = *((unsigned __int16 *)v5 + 2);
    if (v7 == 1953723747 && v8 == 28015)
    {
      *(_QWORD *)v38.var0 = *(_QWORD *)(a1 + 88);
      *(_QWORD *)&v38.var0[8] = *(_QWORD *)(a1 + 128);
      CLMicroLocationAnalytics::generateWiFiChannelHistogramForBlueAtlas(*(CLMicroLocationAnalytics **)(a1 + 80), v38, (uint64_t)&v23);
      if (v25)
      {
        v20 = 0;
        v21 = 0;
        v22 = 0;
        std::vector<CLMicroLocationWiFiChannelHistogram>::__init_with_size[abi:ne180100]<CLMicroLocationWiFiChannelHistogram*,CLMicroLocationWiFiChannelHistogram*>(&v20, v23, (uint64_t)v24, (v24 - (_BYTE *)v23) >> 3);
        if (onceToken_MicroLocation_Default != -1)
          dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_3);
        v10 = logObject_MicroLocation_Default;
        if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_INFO))
        {
          *(_DWORD *)buf = 68289026;
          *(_DWORD *)&buf[4] = 0;
          v33 = 2082;
          *(_QWORD *)v34 = "";
          _os_log_impl(&dword_2419D9000, v10, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"updating Blue Atlas wifi channel histogram\"}", buf, 0x12u);
        }
        std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)buf);
        v11 = (char *)v20;
        v12 = v21;
        if (v20 != v21)
        {
          do
          {
            std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v34[6], (uint64_t)"channel: ", 9);
            v13 = (_QWORD *)std::ostream::operator<<();
            std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v13, (uint64_t)" count: ", 8);
            v14 = (_QWORD *)std::ostream::operator<<();
            std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v14, (uint64_t)", ", 2);
            v11 += 8;
          }
          while (v11 != v12);
        }
        std::stringbuf::str();
        if (onceToken_MicroLocation_Default != -1)
          dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_3);
        v15 = logObject_MicroLocation_Default;
        if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_INFO))
        {
          p_p = &__p;
          if (v19 < 0)
            p_p = __p;
          *(_DWORD *)v26 = 68289283;
          v27 = 0;
          v28 = 2082;
          v29 = "";
          v30 = 2081;
          v31 = p_p;
          _os_log_impl(&dword_2419D9000, v15, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Wifi channel histogram:\", \"Histogram\":%{private, location:escape_only}s}", v26, 0x1Cu);
        }
        CLMicroLocationSensorsLogic::reloadWifiChannelHistogram(a1 + 712, (uint64_t)&v20);
        if (v19 < 0)
          operator delete(__p);
        *(_QWORD *)buf = *MEMORY[0x24BEDB7F0];
        v17 = *(_QWORD *)(MEMORY[0x24BEDB7F0] + 72);
        *(_QWORD *)&buf[*(_QWORD *)(*(_QWORD *)buf - 24)] = *(_QWORD *)(MEMORY[0x24BEDB7F0] + 64);
        *(_QWORD *)&v34[6] = v17;
        *(_QWORD *)&v34[14] = MEMORY[0x24BEDB848] + 16;
        if (v36 < 0)
          operator delete(v35);
        std::streambuf::~streambuf();
        std::iostream::~basic_iostream();
        MEMORY[0x2426A0444](v37);
        if (v20)
        {
          v21 = (char *)v20;
          operator delete(v20);
        }
        if (v25)
        {
          if (v23)
          {
            v24 = v23;
            operator delete(v23);
          }
        }
      }
    }
  }
}

void sub_2419F0740(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, uint64_t a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  if (a14 < 0)
    operator delete(__p);
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream((uint64_t)&a26);
  if (a15)
    operator delete(a15);
  if (a21)
  {
    if (a18)
      operator delete(a18);
  }
  _Unwind_Resume(a1);
}

uint64_t std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100](uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  std::ios_base *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v2 = MEMORY[0x24BEDB858];
  v3 = MEMORY[0x24BEDB858] + 104;
  *(_QWORD *)(a1 + 128) = MEMORY[0x24BEDB858] + 104;
  *(_QWORD *)(a1 + 16) = v2 + 64;
  v4 = a1 + 16;
  v5 = (_QWORD *)MEMORY[0x24BEDB7F0];
  v6 = *(_QWORD *)(MEMORY[0x24BEDB7F0] + 16);
  v7 = *(_QWORD *)(MEMORY[0x24BEDB7F0] + 24);
  *(_QWORD *)a1 = v6;
  *(_QWORD *)(a1 + *(_QWORD *)(v6 - 24)) = v7;
  *(_QWORD *)(a1 + 8) = 0;
  v8 = (std::ios_base *)(a1 + *(_QWORD *)(*(_QWORD *)a1 - 24));
  std::ios_base::init(v8, (void *)(a1 + 24));
  v8[1].__vftable = 0;
  v8[1].__fmtflags_ = -1;
  v9 = v5[4];
  v10 = v5[5];
  *(_QWORD *)(a1 + 16) = v9;
  *(_QWORD *)(v4 + *(_QWORD *)(v9 - 24)) = v10;
  v11 = v5[1];
  *(_QWORD *)a1 = v11;
  *(_QWORD *)(a1 + *(_QWORD *)(v11 - 24)) = v5[6];
  *(_QWORD *)a1 = v2 + 24;
  *(_QWORD *)(a1 + 128) = v3;
  *(_QWORD *)(a1 + 16) = v2 + 64;
  std::streambuf::basic_streambuf();
  *(_QWORD *)(a1 + 24) = MEMORY[0x24BEDB848] + 16;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_DWORD *)(a1 + 120) = 24;
  return a1;
}

void sub_2419F08B4(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::iostream::~basic_iostream();
  MEMORY[0x2426A0444](v1);
  _Unwind_Resume(a1);
}

uint64_t std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  v2 = MEMORY[0x24BEDB7F0];
  v3 = *MEMORY[0x24BEDB7F0];
  *(_QWORD *)a1 = *MEMORY[0x24BEDB7F0];
  v4 = *(_QWORD *)(v2 + 72);
  *(_QWORD *)(a1 + *(_QWORD *)(v3 - 24)) = *(_QWORD *)(v2 + 64);
  *(_QWORD *)(a1 + 24) = MEMORY[0x24BEDB848] + 16;
  *(_QWORD *)(a1 + 16) = v4;
  if (*(char *)(a1 + 111) < 0)
    operator delete(*(void **)(a1 + 88));
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x2426A0444](a1 + 128);
  return a1;
}

void CLMicroLocationLogic::onLearningBegin(CLMicroLocationLogic *this)
{
  NSObject *v2;
  uint8_t v3[16];

  if (onceToken_MicroLocation_Default != -1)
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_3);
  v2 = logObject_MicroLocation_Default;
  if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)v3 = 0;
    _os_log_impl(&dword_2419D9000, v2, OS_LOG_TYPE_DEBUG, "CLMicroLocationLogic::onLearningBegin", v3, 2u);
  }
  CLMiLoServiceManager::onLearningBegin((CLMicroLocationLogic *)((char *)this + 1768));
}

void CLMicroLocationLogic::onLearningCompleted(CLMicroLocationLogic *this)
{
  NSObject *v2;
  uint8_t v3[16];

  if (onceToken_MicroLocation_Default != -1)
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_3);
  v2 = logObject_MicroLocation_Default;
  if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)v3 = 0;
    _os_log_impl(&dword_2419D9000, v2, OS_LOG_TYPE_DEBUG, "Models have been regenerated, Letting service Manager know", v3, 2u);
  }
  CLMicroLocationLogic::stopRapportSessionIfRunning(this);
  CLMiLoServiceManager::onLearningCompleted((CLMicroLocationLogic *)((char *)this + 1768));
  CLMicroLocationSensorsLogic::backupBleIdentities((CLMicroLocationLogic *)((char *)this + 712));
}

void CLMicroLocationLogic::onAssociatedState(CLMicroLocationLogic *this, ULWiFiAssociatedState *a2)
{
  ULWiFiAssociatedState *v3;
  void *v4;
  void *v5;
  uint64_t v6;
  NSObject *v7;
  NSObject *v8;
  unsigned int v9;
  uint64_t v10;
  NSObject *v12;
  id v13;
  void *v14;
  _QWORD *v15;
  NSObject *v16;
  char *v17;
  id v18;
  uint64_t v19;
  uint64_t v20;
  void *v21;
  int v22;
  uint64_t v23;
  uint64_t v24;
  unsigned __int8 v25;
  CFAbsoluteTime v26;
  unsigned int v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint8_t buf[8];
  __int16 v32;
  const char *v33;
  __int16 v34;
  _QWORD *v35;
  __int16 v36;
  char *v37;
  __int16 v38;
  int v39;
  __int16 v40;
  uint64_t v41;
  __int16 v42;
  uint64_t v43;
  __int16 v44;
  int v45;
  uint64_t v46;

  v46 = *MEMORY[0x24BDAC8D0];
  v3 = a2;
  -[ULWiFiAssociatedState BSSID](v3, "BSSID");
  v4 = (void *)objc_claimAutoreleasedReturnValue();

  if (v4)
  {
    if (*((_BYTE *)this + 80))
    {
LABEL_3:
      v28 = 0;
      v29 = 0;
      v30 = 0;
      v27 = 0;
      -[ULWiFiAssociatedState channel](v3, "channel");
      v5 = (void *)objc_claimAutoreleasedReturnValue();
      v6 = objc_msgSend(v5, "band");

      switch(v6)
      {
        case 0:
          if (onceToken_MicroLocation_Default != -1)
            dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_3);
          v7 = logObject_MicroLocation_Default;
          if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 68289026;
            *(_DWORD *)&buf[4] = 0;
            v32 = 2082;
            v33 = "";
            _os_log_impl(&dword_2419D9000, v7, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"CLMicroLocationLogic, onAssociatedState event invalid band\"}", buf, 0x12u);
          }
          if (onceToken_MicroLocation_Default != -1)
            dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_3);
          v8 = logObject_MicroLocation_Default;
          if (os_signpost_enabled((os_log_t)logObject_MicroLocation_Default))
          {
            *(_DWORD *)buf = 68289026;
            *(_DWORD *)&buf[4] = 0;
            v32 = 2082;
            v33 = "";
            _os_signpost_emit_with_name_impl(&dword_2419D9000, v8, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "CLMicroLocationLogic, onAssociatedState event invalid band", "{\"msg%{public}.0s\":\"CLMicroLocationLogic, onAssociatedState event invalid band\"}", buf, 0x12u);
          }
          goto LABEL_12;
        case 1:
LABEL_12:
          v9 = 2;
          goto LABEL_23;
        case 2:
          v9 = 5;
          goto LABEL_23;
        case 3:
          v9 = 6;
LABEL_23:
          v27 = v9;
          break;
        default:
          break;
      }
      v26 = cl::chrono::CFAbsoluteTimeClock::now();
      v25 = 1;
      -[ULWiFiAssociatedState BSSID](v3, "BSSID");
      v13 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
      std::string::basic_string[abi:ne180100]<0>(buf, (char *)objc_msgSend(v13, "UTF8String"));
      v24 = CLMacAddress::newFromCLStr((uint64_t *)buf);
      -[ULWiFiAssociatedState channel](v3, "channel");
      v14 = (void *)objc_claimAutoreleasedReturnValue();
      v15 = (_QWORD *)((char *)this + 56);
      v23 = objc_msgSend(v14, "channelNumber");
      v29 = std::vector<CLMicroLocationAssociatedStateTable::Entry>::__emplace_back_slow_path<std::string const&,boost::uuids::uuid const&,std::chrono::time_point<cl::chrono::CFAbsoluteTimeClock,std::chrono::duration<long double,std::ratio<1l,1l>>>,BOOL,CLMacAddress,CLMicroLocationAssociatedStateTable::Entry::Band &,unsigned long>(&v28, (uint64_t)this + 56, (uint64_t)this + 80, (uint64_t)&v26, &v25, (uint64_t)&v24, &v27, (unsigned int *)&v23);

      if (SBYTE3(v35) < 0)
        operator delete(*(void **)buf);

      if (onceToken_MicroLocation_Default != -1)
        dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_3);
      v16 = (id)logObject_MicroLocation_Default;
      if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
      {
        if (*((char *)this + 79) < 0)
          v15 = (_QWORD *)*v15;
        v17 = (char *)operator new(0x28uLL);
        *(_QWORD *)(v17 + 29) = 0;
        *(_OWORD *)v17 = 0u;
        *((_OWORD *)v17 + 1) = 0u;
        boost::uuids::to_chars<char *>((uint64_t)this + 80, v17);
        -[ULWiFiAssociatedState BSSID](v3, "BSSID", v23);
        v18 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
        v19 = objc_msgSend(v18, "UTF8String");
        v20 = v27;
        -[ULWiFiAssociatedState channel](v3, "channel");
        v21 = (void *)objc_claimAutoreleasedReturnValue();
        v22 = objc_msgSend(v21, "channelNumber");
        *(_DWORD *)buf = 68290563;
        *(_DWORD *)&buf[4] = 0;
        v32 = 2082;
        v33 = "";
        v34 = 2081;
        v35 = v15;
        v36 = 2081;
        v37 = v17;
        v38 = 1026;
        v39 = 1;
        v40 = 2081;
        v41 = v19;
        v42 = 2050;
        v43 = v20;
        v44 = 1026;
        v45 = v22;
        _os_log_impl(&dword_2419D9000, v16, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLMicroLocationLogic, onAssociatedState event\", \"currentRTLOIType\":%{private, location:escape_only}s, \"currentRtLoiId\":%{private, location:escape_only}s, \"IsAssociated\":%{public}hhd, \"MAC Address\":%{private, location:escape_only}s, \"Band\":%{public}lu, \"Channel\":%{public}d}", buf, 0x46u);

        operator delete(v17);
      }

      objc_msgSend(*(id *)(*((_QWORD *)this + 16) + 16), "insertEntries:", &v28);
      *(_QWORD *)buf = &v28;
      std::vector<CLMicroLocationAssociatedStateTable::Entry>::__destroy_vector::operator()[abi:ne180100]((void ***)buf);
    }
    else
    {
      v10 = 0;
      while (v10 != 15)
      {
        if (*((unsigned __int8 *)this + v10++ + 81))
        {
          if ((unint64_t)(v10 - 1) < 0xF)
            goto LABEL_3;
          break;
        }
      }
      if (onceToken_MicroLocation_Default != -1)
        dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_3);
      v12 = logObject_MicroLocation_Default;
      if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 68289026;
        *(_DWORD *)&buf[4] = 0;
        v32 = 2082;
        v33 = "";
        _os_log_impl(&dword_2419D9000, v12, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLMicroLocationLogic, onAssociatedState event ignored - nil currentRtLoiId\"}", buf, 0x12u);
      }
    }
  }

}

void sub_2419F0F98(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14, uint64_t a15, uint64_t a16, char *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  void *v22;
  void *v23;
  void *v24;
  void *v25;
  void *v26;

  operator delete(v25);
  __p = &a14;
  std::vector<CLMicroLocationAssociatedStateTable::Entry>::__destroy_vector::operator()[abi:ne180100]((void ***)&__p);

  _Unwind_Resume(a1);
}

void CLMicroLocationLogic::refreshLocationOnInterval(CLMicroLocationLogic *this)
{
  CLMicroLocationLoiManager::handleRefreshLocationIntervalNotificaion((CLMicroLocationLogic *)((char *)this + 2024));
}

void CLMicroLocationProtobufHelper::createLoggedEvent<CLMicroLocationProto::EnabledStateUpdate>(_OWORD *a1@<X0>, int *a2@<X1>, uint64_t a3@<X8>, double a4@<D0>)
{
  const CLMicroLocationProto::EnabledStateUpdate *v8;
  _BYTE v9[304];

  CLMicroLocationProto::ReceivedEvent::ReceivedEvent((CLMicroLocationProto::ReceivedEvent *)v9);
  CLMicroLocationProtobufHelper::setSpecificLoggedEvent((CLMicroLocationProtobufHelper *)v9, (CLMicroLocationProto::ReceivedEvent *)a2, v8);
  CLMicroLocationLoggedEventsTable::Entry::Entry(a3, a1, a2[2], (CLMicroLocationProto::ReceivedEvent *)v9, a4);
  CLMicroLocationProto::ReceivedEvent::~ReceivedEvent((CLMicroLocationProto::ReceivedEvent *)v9);
}

void sub_2419F10E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  CLMicroLocationProto::ReceivedEvent::~ReceivedEvent((CLMicroLocationProto::ReceivedEvent *)&a9);
  _Unwind_Resume(a1);
}

uint64_t CLMicroLocationLogic::enabled(CLMicroLocationLogic *this)
{
  return *((unsigned __int8 *)this + 48);
}

void CLMicroLocationLogic::onKeybagUnlocked(ULDatabase **this)
{
  ULDatabase::connectIfNecessary(this[16]);
  CLMicroLocationLogic::migrateFromLocationdIfNecessary((CLMicroLocationLogic *)this);
  if ((*((unsigned int (**)(ULDatabase *))this[16]->var0 + 2))(this[16]))
    CLMicroLocationSensorsLogic::loadBleIdentitiesFromDb((CLMicroLocationSensorsLogic *)(this + 89));
}

void CLMicroLocationLogic::onDatabaseBecameValid(CLMicroLocationLogic *this)
{
  CLMicroLocationLoiManager *v2;

  v2 = (CLMicroLocationLogic *)((char *)this + 2024);
  CLMicroLocationLoiManager::fetchPlaceInferenceForReason((uint64_t)this + 2024, 6);
  CLMicroLocationLoiManager::setupRegionMonitoring(v2);
  CLMiLoServiceManager::processConnectionRequestsAwaitingDb((CLMicroLocationLogic *)((char *)this + 1768));
  CLMicroLocationSensorsLogic::loadBleIdentitiesFromDb((CLMicroLocationLogic *)((char *)this + 712));
}

uint64_t CLMicroLocationLogic::isDataAvailable(CLMicroLocationLogic *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 323) + 128))(*((_QWORD *)this + 323));
}

uint64_t `non-virtual thunk to'CLMicroLocationLogic::isDataAvailable(CLMicroLocationLogic *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 318) + 128))(*((_QWORD *)this + 318));
}

uint64_t CLMicroLocationLogic::resetAndGetDevicesSinceLearnEventTimeForLoi@<X0>(uint64_t a1@<X0>, uint64_t *a2@<X1>, _QWORD *a3@<X2>, _QWORD *a4@<X8>, double a5@<D0>)
{
  CLMicroLocationRapportMonitor *v6;
  _QWORD *v7;
  unint64_t v8;
  _QWORD *v9;
  _QWORD v11[5];
  double v12;

  v12 = a5;
  v6 = (CLMicroLocationRapportMonitor *)(a1 + 1464);
  CLMicroLocationRapportMonitor::getDevicesSinceLearnEventTimeAtLoi(a1 + 1464, &v12, a2, a3, (uint64_t)v11);
  CLMicroLocationRapportMonitor::backup(v6);
  CLMicroLocationRapportMonitor::reset(v6);
  v7 = (_QWORD *)v11[2];
  a4[1] = 0;
  a4[2] = 0;
  *a4 = 0;
  v8 = 0;
  if (v7)
  {
    v9 = v7;
    do
    {
      ++v8;
      v9 = (_QWORD *)*v9;
    }
    while (v9);
  }
  std::vector<CLMicroLocationRapportMonitor::Item>::__init_with_size[abi:ne180100]<std::__hash_const_iterator<std::__hash_node<CLMicroLocationRapportMonitor::Item,void *> *>,std::__hash_const_iterator<std::__hash_node<CLMicroLocationRapportMonitor::Item,void *> *>>(a4, v7, 0, v8);
  return std::__hash_table<CLMicroLocationRapportMonitor::Item,CLMicroLocationRapportMonitor::Item::HashItem,CLMicroLocationRapportMonitor::Item::PredicateItem,std::allocator<CLMicroLocationRapportMonitor::Item>>::~__hash_table((uint64_t)v11);
}

void sub_2419F123C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::__hash_table<CLMicroLocationRapportMonitor::Item,CLMicroLocationRapportMonitor::Item::HashItem,CLMicroLocationRapportMonitor::Item::PredicateItem,std::allocator<CLMicroLocationRapportMonitor::Item>>::~__hash_table((uint64_t)&a9);
  _Unwind_Resume(a1);
}

BOOL CLMicroLocationLogic::onRecordingRequest(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, __int128 *a5, double *a6)
{
  void *v9;
  uint64_t v10;
  int v11;
  int v13;
  std::string v14;
  char v15;
  int v16[12];
  __int128 v17;
  _BYTE v18[32];
  uint64_t v19;
  __int128 v20;
  char v21;
  uint64_t v22;

  v22 = *MEMORY[0x24BDAC8D0];
  v20 = *a5;
  v21 = *((_BYTE *)a5 + 16);
  CLMicroLocationProtobufHelper::createRecordingRequestDictionary(1, a3, a4, (uint64_t)&v20);
  v9 = (void *)objc_claimAutoreleasedReturnValue();
  if (*(char *)(a2 + 23) < 0)
    std::string::__init_copy_ctor_external(&v14, *(const std::string::value_type **)a2, *(_QWORD *)(a2 + 8));
  else
    v14 = *(std::string *)a2;
  v15 = 1;
  CLMicroLocationProtobufHelper::getClientRecordingRequest((uint64_t)&v14, v9, (uint64_t)v16);
  if (v15 && SHIBYTE(v14.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v14.__r_.__value_.__l.__data_);
  v13 = 0;
  boost::uuids::detail::random_provider_base::random_provider_base((boost::uuids::detail::random_provider_base *)&v13);
  *(_QWORD *)&v17 = boost::uuids::random_generator_pure::operator()((uint64_t)&v13);
  *((_QWORD *)&v17 + 1) = v10;
  CLMicroLocationProtobufHelper::createLoggedEvent<CLMicroLocationProto::RecordingRequest>(&v17, v16, (uint64_t)v18, *a6);
  (*(void (**)(uint64_t, _BYTE *))(*(_QWORD *)a1 + 120))(a1, v18);
  CLMicroLocationProto::ReceivedEvent::~ReceivedEvent((CLMicroLocationProto::ReceivedEvent *)&v19);
  boost::uuids::detail::random_provider_base::destroy((boost::uuids::detail::random_provider_base *)&v13);
  CLMicroLocationProtobufHelper::createRecordingEvent<CLMicroLocationProto::RecordingRequest>((CLMicroLocationProto::RecordingEvent *)v16, 0, 0, 0, (CLMicroLocationProto *)3, (uint64_t)v18, *a6);
  v11 = CLMicroLocationTriggerManager::requestRecording((CLMicroLocationTriggerManager *)(a1 + 1560), (const CLMicroLocationProto::RecordingEvent *)v18);
  CLMicroLocationProto::RecordingEvent::~RecordingEvent((CLMicroLocationProto::RecordingEvent *)v18);
  CLMicroLocationProto::RecordingRequest::~RecordingRequest((CLMicroLocationProto::RecordingRequest *)v16);

  return v11 != 5;
}

void sub_2419F13E8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, int a10, char a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, char a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,char a30)
{
  void *v30;

  _Unwind_Resume(a1);
}

void CLMicroLocationProtobufHelper::createLoggedEvent<CLMicroLocationProto::RecordingRequest>(_OWORD *a1@<X0>, int *a2@<X1>, uint64_t a3@<X8>, double a4@<D0>)
{
  const CLMicroLocationProto::RecordingRequest *v8;
  _BYTE v9[304];

  CLMicroLocationProto::ReceivedEvent::ReceivedEvent((CLMicroLocationProto::ReceivedEvent *)v9);
  CLMicroLocationProtobufHelper::setSpecificLoggedEvent((CLMicroLocationProtobufHelper *)v9, (CLMicroLocationProto::ReceivedEvent *)a2, v8);
  CLMicroLocationLoggedEventsTable::Entry::Entry(a3, a1, a2[2], (CLMicroLocationProto::ReceivedEvent *)v9, a4);
  CLMicroLocationProto::ReceivedEvent::~ReceivedEvent((CLMicroLocationProto::ReceivedEvent *)v9);
}

void sub_2419F14D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  CLMicroLocationProto::ReceivedEvent::~ReceivedEvent((CLMicroLocationProto::ReceivedEvent *)&a9);
  _Unwind_Resume(a1);
}

BOOL `non-virtual thunk to'CLMicroLocationLogic::onRecordingRequest(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, __int128 *a5, double *a6)
{
  return CLMicroLocationLogic::onRecordingRequest(a1 - 24, a2, a3, a4, a5, a6);
}

void CLMicroLocationLogic::onLocalizationRequest(uint64_t a1@<X0>, const std::string *a2@<X1>, unint64_t a3@<X2>, unint64_t a4@<X3>, uint64_t a5@<X4>, double *a6@<X5>, int a7@<W6>, __n128 *a8@<X8>)
{
  std::string *v14;
  _QWORD *v15;
  _QWORD *v16;
  _QWORD *v17;
  uint64_t v18;
  CLMicroLocationTriggerManager *v19;
  int v20;
  char v21;
  int v22;
  int v23[4];
  std::string *v24;
  _QWORD *v25;
  _QWORD *v26;
  int v27;
  __int128 v28;
  _BYTE v29[32];
  uint64_t v30;
  __n128 v31;
  uint64_t v32;

  v32 = *MEMORY[0x24BDAC8D0];
  v31.n128_u64[0] = a3;
  v31.n128_u64[1] = a4;
  CLMicroLocationProto::ReceivedEventAction::ReceivedEventAction((CLMicroLocationProto::ReceivedEventAction *)v23);
  v27 |= 4u;
  v14 = v24;
  v15 = (_QWORD *)MEMORY[0x24BEDD958];
  if (v24 == (std::string *)MEMORY[0x24BEDD958])
  {
    v14 = (std::string *)operator new();
    v14->__r_.__value_.__r.__words[0] = 0;
    v14->__r_.__value_.__l.__size_ = 0;
    v14->__r_.__value_.__r.__words[2] = 0;
    v24 = v14;
  }
  std::string::operator=(v14, a2);
  if (!CLMicroLocationProto::ReceivedEventActionType_IsValid((CLMicroLocationProto *)1))
    __assert_rtn("set_receivedeventactiontype", "microlocation.pb.h", 13294, "::CLMicroLocationProto::ReceivedEventActionType_IsValid(value)");
  v23[3] = 1;
  v27 |= 0xAu;
  if (v25 == v15)
  {
    v16 = (_QWORD *)operator new();
    *v16 = 0;
    v16[1] = 0;
    v16[2] = 0;
    v25 = v16;
  }
  MEMORY[0x2426A02D0]();
  if (*(_BYTE *)(a5 + 16))
  {
    v27 |= 0x10u;
    if (v26 == v15)
    {
      v17 = (_QWORD *)operator new();
      *v17 = 0;
      v17[1] = 0;
      v17[2] = 0;
      v26 = v17;
    }
    MEMORY[0x2426A02D0]();
  }
  v22 = 0;
  boost::uuids::detail::random_provider_base::random_provider_base((boost::uuids::detail::random_provider_base *)&v22);
  *(_QWORD *)&v28 = boost::uuids::random_generator_pure::operator()((uint64_t)&v22);
  *((_QWORD *)&v28 + 1) = v18;
  CLMicroLocationProtobufHelper::createLoggedEvent<CLMicroLocationProto::ReceivedEventAction>(&v28, v23, (uint64_t)v29, *a6);
  (*(void (**)(uint64_t, _BYTE *))(*(_QWORD *)a1 + 120))(a1, v29);
  CLMicroLocationProto::ReceivedEvent::~ReceivedEvent((CLMicroLocationProto::ReceivedEvent *)&v30);
  boost::uuids::detail::random_provider_base::destroy((boost::uuids::detail::random_provider_base *)&v22);
  CLMicroLocationProtobufHelper::createRecordingEvent<CLMicroLocationProto::ReceivedEventAction>((CLMicroLocationProto::RecordingEvent *)v23, 0, 0, 0, (CLMicroLocationProto *)3, (uint64_t)v29, *a6);
  v19 = (CLMicroLocationTriggerManager *)(a1 + 1560);
  v20 = CLMicroLocationTriggerManager::requestLocalization((uint64_t)v19, (const CLMicroLocationProto::RecordingEvent *)v29, a7, 0, 0);
  if (v20 == 3)
  {
    CLMicroLocationTriggerManager::getRescheduledLocalizationUUID(v19, a8);
LABEL_15:
    v21 = 0;
    goto LABEL_16;
  }
  if (v20 != 4)
  {
    CLMicroLocationTriggerManager::getCurrentLocalizationUUID(v19, a8);
    goto LABEL_15;
  }
  *a8 = v31;
  v21 = 1;
  a8[1].n128_u8[0] = 1;
LABEL_16:
  a8[1].n128_u8[1] = v21;
  CLMicroLocationProto::RecordingEvent::~RecordingEvent((CLMicroLocationProto::RecordingEvent *)v29);
  CLMicroLocationProto::ReceivedEventAction::~ReceivedEventAction((CLMicroLocationProto::ReceivedEventAction *)v23);
}

void sub_2419F1790(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  CLMicroLocationProto::ReceivedEventAction::~ReceivedEventAction((CLMicroLocationProto::ReceivedEventAction *)va);
  _Unwind_Resume(a1);
}

void CLMicroLocationProtobufHelper::createLoggedEvent<CLMicroLocationProto::ReceivedEventAction>(_OWORD *a1@<X0>, int *a2@<X1>, uint64_t a3@<X8>, double a4@<D0>)
{
  const CLMicroLocationProto::ReceivedEventAction *v8;
  _BYTE v9[304];

  CLMicroLocationProto::ReceivedEvent::ReceivedEvent((CLMicroLocationProto::ReceivedEvent *)v9);
  CLMicroLocationProtobufHelper::setSpecificLoggedEvent((CLMicroLocationProtobufHelper *)v9, (CLMicroLocationProto::ReceivedEvent *)a2, v8);
  CLMicroLocationLoggedEventsTable::Entry::Entry(a3, a1, a2[2], (CLMicroLocationProto::ReceivedEvent *)v9, a4);
  CLMicroLocationProto::ReceivedEvent::~ReceivedEvent((CLMicroLocationProto::ReceivedEvent *)v9);
}

void sub_2419F1858(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  CLMicroLocationProto::ReceivedEvent::~ReceivedEvent((CLMicroLocationProto::ReceivedEvent *)&a9);
  _Unwind_Resume(a1);
}

void `non-virtual thunk to'CLMicroLocationLogic::onLocalizationRequest(uint64_t a1@<X0>, const std::string *a2@<X1>, unint64_t a3@<X2>, unint64_t a4@<X3>, uint64_t a5@<X4>, double *a6@<X5>, int a7@<W6>, __n128 *a8@<X8>)
{
  CLMicroLocationLogic::onLocalizationRequest(a1 - 24, a2, a3, a4, a5, a6, a7, a8);
}

uint64_t CLMicroLocationLogic::onTruthLabel(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  void *v8;
  CLMicroLocationProtobufHelper *v9;
  uint64_t v10;
  _QWORD v12[2];
  _QWORD v13[3];

  v13[2] = *MEMORY[0x24BDAC8D0];
  v13[0] = a3;
  v13[1] = a4;
  v12[0] = a5;
  v12[1] = a6;
  v8 = (void *)objc_msgSend(objc_alloc(MEMORY[0x24BDD1880]), "initWithUUIDBytes:", v13);
  v9 = (CLMicroLocationProtobufHelper *)objc_msgSend(objc_alloc(MEMORY[0x24BDD1880]), "initWithUUIDBytes:", v12);
  v10 = CLMicroLocationRecorder::recordTruthLabel(a1 + 664, a2, v8, v9);

  return v10;
}

void sub_2419F1928(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

uint64_t `non-virtual thunk to'CLMicroLocationLogic::onTruthLabel(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  return CLMicroLocationLogic::onTruthLabel(a1 - 24, a2, a3, a4, a5, a6);
}

uint64_t CLMicroLocationLogic::onTruthTagLabelForBetweenDates(uint64_t a1, const std::string *a2, uint64_t a3, void *a4, void *a5)
{
  id v9;
  id v10;
  void *v11;
  uint64_t v12;

  v9 = a4;
  v10 = a5;
  v11 = (void *)objc_msgSend(objc_alloc(MEMORY[0x24BDD1880]), "initWithUUIDBytes:", a3);
  v12 = CLMicroLocationLogic::donateTruthTagLabelForRecordingEventsBetweenDates(a1, a2, v11, v9, v10);

  return v12;
}

void sub_2419F19E0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

uint64_t `non-virtual thunk to'CLMicroLocationLogic::onTruthTagLabelForBetweenDates(uint64_t a1, const std::string *a2, uint64_t a3, void *a4, void *a5)
{
  return CLMicroLocationLogic::onTruthTagLabelForBetweenDates(a1 - 24, a2, a3, a4, a5);
}

uint64_t CLMicroLocationLogic::addTriggerUuidForCachedTrigger(uint64_t a1, const std::string *a2, _OWORD *a3, __int128 *a4)
{
  return CLMicroLocationRecorder::addTriggerUuidForCachedTrigger(a1 + 664, a2, a3, a4);
}

uint64_t `non-virtual thunk to'CLMicroLocationLogic::addTriggerUuidForCachedTrigger(uint64_t a1, const std::string *a2, _OWORD *a3, __int128 *a4)
{
  return CLMicroLocationRecorder::addTriggerUuidForCachedTrigger(a1 + 640, a2, a3, a4);
}

uint64_t CLMicroLocationLogic::addTriggerEventForFutureLabeling(uint64_t a1, const std::string *a2, uint64_t *a3)
{
  uint64_t v6;
  uint64_t v7;
  std::string __p;

  v6 = a1 + 664;
  if (*(char *)(a1 + 79) < 0)
    std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)(a1 + 56), *(_QWORD *)(a1 + 64));
  else
    __p = *(std::string *)(a1 + 56);
  v7 = CLMicroLocationRecorder::addTriggerEventForFutureLabeling(v6, a2, a3, (uint64_t)&__p, (_QWORD *)(a1 + 80));
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  return v7;
}

void sub_2419F1AAC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t `non-virtual thunk to'CLMicroLocationLogic::addTriggerEventForFutureLabeling(uint64_t a1, const std::string *a2, uint64_t *a3)
{
  return CLMicroLocationLogic::addTriggerEventForFutureLabeling(a1 - 24, a2, a3);
}

uint64_t CLMicroLocationLogic::startLowLatencyUpdates(CLMicroLocationLogic *this, uuid *a2)
{
  char *v4;
  _BOOL4 isLowLatencyMode;
  uint64_t v6;
  _BOOL4 v7;
  NSObject *v8;
  char *v9;
  NSObject *v10;
  char *v11;
  double v12;
  NSObject *v13;
  char *v14;
  int v16;
  uint8_t buf[4];
  int v18;
  __int16 v19;
  const char *v20;
  __int16 v21;
  char *v22;
  __int16 v23;
  int v24;
  uint64_t v25;

  v25 = *MEMORY[0x24BDAC8D0];
  v16 = 1;
  v4 = (char *)this + 1560;
  isLowLatencyMode = CLMicroLocationTriggerManager::isLowLatencyMode((CLMicroLocationLogic *)((char *)this + 1560));
  v6 = CLMicroLocationTriggerManager::addPolicy((uint64_t)v4, a2, &v16);
  if (!(_DWORD)v6)
    goto LABEL_15;
  if (!isLowLatencyMode)
  {
    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_3);
    v10 = (id)logObject_MicroLocation_Default;
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      v11 = (char *)operator new(0x28uLL);
      *(_QWORD *)(v11 + 29) = 0;
      *(_OWORD *)v11 = 0u;
      *((_OWORD *)v11 + 1) = 0u;
      boost::uuids::to_chars<char *>((uint64_t)a2, v11);
      *(_DWORD *)buf = 68289282;
      v18 = 0;
      v19 = 2082;
      v20 = "";
      v21 = 2082;
      v22 = v11;
      _os_log_impl(&dword_2419D9000, v10, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"first service to connect to low-latency: invalidating caches\", \"ServiceUUID\":%{public, location:escape_only}s}", buf, 0x1Cu);
      operator delete(v11);
    }

    CLMicroLocationLogic::invalidateCaches((uint64_t)this, 1);
    goto LABEL_14;
  }
  v7 = CLMicroLocationLogic::calcCachedLocalizationResults(this, *a2);
  if (onceToken_MicroLocation_Default != -1)
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_3);
  v8 = (id)logObject_MicroLocation_Default;
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    v9 = (char *)operator new(0x28uLL);
    *(_QWORD *)(v9 + 29) = 0;
    *(_OWORD *)v9 = 0u;
    *((_OWORD *)v9 + 1) = 0u;
    boost::uuids::to_chars<char *>((uint64_t)a2, v9);
    *(_DWORD *)buf = 68289538;
    v18 = 0;
    v19 = 2082;
    v20 = "";
    v21 = 2082;
    v22 = v9;
    v23 = 1026;
    v24 = v7;
    _os_log_impl(&dword_2419D9000, v8, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"service connects to low-latency while already in low-latency\", \"ServiceUUID\":%{public, location:escape_only}s, \"CachedLocalizationSuccess\":%{public}hhd}", buf, 0x22u);
    operator delete(v9);
  }

  if (!v7)
  {
LABEL_14:
    v12 = cl::chrono::CFAbsoluteTimeClock::now();
    CLMicroLocationLogic::createLocalizationTriggerWithOptAssociatedAccessPointInfo((uint64_t)this, (uint64_t)"InternalClientMotion", 0, (uint64_t)buf, v12);
    CLMicroLocationTriggerManager::requestLocalization((uint64_t)v4, (const CLMicroLocationProto::RecordingEvent *)buf, 1, 0, 0);
    CLMicroLocationProto::RecordingEvent::~RecordingEvent((CLMicroLocationProto::RecordingEvent *)buf);
  }
LABEL_15:
  if (onceToken_MicroLocation_Default != -1)
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_3);
  v13 = (id)logObject_MicroLocation_Default;
  if (os_log_type_enabled(v13, OS_LOG_TYPE_INFO))
  {
    v14 = (char *)operator new(0x28uLL);
    *(_QWORD *)(v14 + 29) = 0;
    *(_OWORD *)v14 = 0u;
    *((_OWORD *)v14 + 1) = 0u;
    boost::uuids::to_chars<char *>((uint64_t)a2, v14);
    *(_DWORD *)buf = 68289539;
    v18 = 0;
    v19 = 2082;
    v20 = "";
    v21 = 2081;
    v22 = v14;
    v23 = 1025;
    v24 = v6;
    _os_log_impl(&dword_2419D9000, v13, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Adding Low Latency policy to trigger manager\", \"\":%{private, location:escape_only}s, \"Success\":%{private}hhd}", buf, 0x22u);
    operator delete(v14);
  }

  return v6;
}

void sub_2419F1E34(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  void *v11;
  void *v12;

  operator delete(v12);

  _Unwind_Resume(a1);
}

BOOL CLMicroLocationLogic::calcCachedLocalizationResults(CLMicroLocationLogic *this, uuid a2)
{
  CLMiLoServiceManager *v3;
  _BOOL8 v4;
  NSObject *v5;
  char *v6;
  NSObject *v7;
  char *v8;
  std::__shared_weak_count *v9;
  unint64_t *p_shared_owners;
  unint64_t v11;
  uint64_t v13;
  std::__shared_weak_count *v14;
  uint8_t *v15;
  uint8_t buf[8];
  _QWORD v17[3];
  void *__p;
  void *v19;
  uint64_t v20;
  uuid v21;
  char v22;
  uuid v23;
  uint64_t v24;

  v24 = *MEMORY[0x24BDAC8D0];
  v23 = a2;
  v3 = (CLMicroLocationLogic *)((char *)this + 1768);
  CLMiLoServiceManager::getModelOfService((uint64_t)this + 1768, a2, &v13);
  if (v13)
  {
    v21.var0[0] = 0;
    v22 = 0;
    __p = 0;
    v19 = 0;
    v20 = 0;
    memset(v17, 0, 20);
    *(_QWORD *)buf = 0;
    v4 = CLMicroLocationLocalizationController::calculateLocalizationResultsOnLastInputs((uint64_t)this + 168, &v13, (uint64_t)&v21, (uint64_t)buf);
    if (v4)
    {
      if (!v22)
        std::__throw_bad_optional_access[abi:ne180100]();
      CLMiLoServiceManager::ingestLocalizationResults(v3, (const CLMiLoServiceManager::LocalizationResults *)buf, v21);
    }
    if (__p)
    {
      v19 = __p;
      operator delete(__p);
    }
    v15 = buf;
    std::vector<CLMiLoServiceManager::LocalizationResultsPerModel>::__destroy_vector::operator()[abi:ne180100]((void ***)&v15);
  }
  else
  {
    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_3);
    v5 = (id)logObject_MicroLocation_Default;
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      v6 = (char *)operator new(0x28uLL);
      *(_QWORD *)(v6 + 29) = 0;
      *(_OWORD *)v6 = 0u;
      *((_OWORD *)v6 + 1) = 0u;
      boost::uuids::to_chars<char *>((uint64_t)&v23, v6);
      *(_DWORD *)buf = 68289282;
      *(_DWORD *)&buf[4] = 0;
      LOWORD(v17[0]) = 2082;
      *(_QWORD *)((char *)v17 + 2) = "";
      WORD1(v17[1]) = 2082;
      *(_QWORD *)((char *)&v17[1] + 4) = v6;
      _os_log_impl(&dword_2419D9000, v5, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"calcCachedLocalizationResults, didn't find model for requested service\", \"Service Uuid\":%{public, location:escape_only}s}", buf, 0x1Cu);
      operator delete(v6);
    }

    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_3);
    v7 = (id)logObject_MicroLocation_Default;
    if (os_signpost_enabled(v7))
    {
      v8 = (char *)operator new(0x28uLL);
      *(_QWORD *)(v8 + 29) = 0;
      *(_OWORD *)v8 = 0u;
      *((_OWORD *)v8 + 1) = 0u;
      boost::uuids::to_chars<char *>((uint64_t)&v23, v8);
      *(_DWORD *)buf = 68289282;
      *(_DWORD *)&buf[4] = 0;
      LOWORD(v17[0]) = 2082;
      *(_QWORD *)((char *)v17 + 2) = "";
      WORD1(v17[1]) = 2082;
      *(_QWORD *)((char *)&v17[1] + 4) = v8;
      _os_signpost_emit_with_name_impl(&dword_2419D9000, v7, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "calcCachedLocalizationResults, didn't find model for requested service", "{\"msg%{public}.0s\":\"calcCachedLocalizationResults, didn't find model for requested service\", \"Service Uuid\":%{public, location:escape_only}s}", buf, 0x1Cu);
      operator delete(v8);
    }

    v4 = 0;
  }
  v9 = v14;
  if (v14)
  {
    p_shared_owners = (unint64_t *)&v14->__shared_owners_;
    do
      v11 = __ldaxr(p_shared_owners);
    while (__stlxr(v11 - 1, p_shared_owners));
    if (!v11)
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
  }
  return v4;
}

void sub_2419F2164(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char a13)
{
  void *v13;
  void *v14;
  void *v15;

  v15 = v14;
  operator delete(v15);

  std::shared_ptr<CLMiLoService::ModelAndConf>::~shared_ptr[abi:ne180100]((uint64_t)&a10);
  _Unwind_Resume(a1);
}

uint64_t `non-virtual thunk to'CLMicroLocationLogic::startLowLatencyUpdates(CLMicroLocationLogic *this, uuid *a2)
{
  return CLMicroLocationLogic::startLowLatencyUpdates((CLMicroLocationLogic *)((char *)this - 24), a2);
}

BOOL CLMicroLocationLogic::stopLowLatencyUpdates(CLMicroLocationLogic *this, uuid *a2)
{
  return CLMicroLocationTriggerManager::removePolicy((CLMicroLocationLogic *)((char *)this + 1560), a2);
}

BOOL `non-virtual thunk to'CLMicroLocationLogic::stopLowLatencyUpdates(CLMicroLocationLogic *this, uuid *a2)
{
  return CLMicroLocationTriggerManager::removePolicy((CLMicroLocationLogic *)((char *)this + 1536), a2);
}

uint64_t CLMicroLocationLogic::isInRoomDetectionInCustomLoiEnabled(CLMicroLocationLogic *this)
{
  return *((unsigned __int8 *)this + 96);
}

uint64_t `non-virtual thunk to'CLMicroLocationLogic::isInRoomDetectionInCustomLoiEnabled(CLMicroLocationLogic *this)
{
  return *((unsigned __int8 *)this + 72);
}

uint64_t CLMicroLocationLogic::enableMiLoAtCurrentLocation(CLMicroLocationLogic *this, const uuid *a2)
{
  CLMicroLocationLoiManager::enableMicroLocationAtCurrentLocationForService((CLMicroLocationLogic *)((char *)this + 2024), a2);
  return 1;
}

uint64_t `non-virtual thunk to'CLMicroLocationLogic::enableMiLoAtCurrentLocation(CLMicroLocationLogic *this, const uuid *a2)
{
  CLMicroLocationLoiManager::enableMicroLocationAtCurrentLocationForService((CLMicroLocationLogic *)((char *)this + 2000), a2);
  return 1;
}

uint64_t CLMicroLocationLogic::disableMiLoAtLocationWithIdentifier(CLMicroLocationLogic *this, const uuid *a2, const uuid *a3)
{
  CLMicroLocationLoiManager::disableMicroLocationAtLocationForService((CLMicroLocationLogic *)((char *)this + 2024), *a2, a3);
  return 1;
}

uint64_t `non-virtual thunk to'CLMicroLocationLogic::disableMiLoAtLocationWithIdentifier(CLMicroLocationLogic *this, const uuid *a2, const uuid *a3)
{
  CLMicroLocationLoiManager::disableMicroLocationAtLocationForService((CLMicroLocationLogic *)((char *)this + 2000), *a2, a3);
  return 1;
}

void CLMicroLocationLogic::deleteService(uint64_t a1@<X0>, unsigned __int8 *a2@<X1>, uuid a3@<X3:X2>, uint64_t *a4@<X4>, uint64_t a5@<X8>)
{
  unsigned __int8 *v6;
  NSObject *v8;
  uint64_t *v9;
  char *v10;
  uint64_t v11;
  _DWORD v12[2];
  __int16 v13;
  const char *v14;
  __int16 v15;
  unsigned __int8 *v16;
  __int16 v17;
  uint64_t *v18;
  __int16 v19;
  char *v20;
  __int16 v21;
  int v22;
  uuid v23;
  uint64_t v24;

  v6 = a2;
  v24 = *MEMORY[0x24BDAC8D0];
  v23 = a3;
  CLMiLoServiceManager::deleteService(a3, (CLMiLoServiceManager *)(a1 + 1768), a2, a5);
  if (onceToken_MicroLocation_Default != -1)
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_3);
  v8 = (id)logObject_MicroLocation_Default;
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    if ((v6[23] & 0x80u) != 0)
      v6 = *(unsigned __int8 **)v6;
    if (*((char *)a4 + 23) >= 0)
      v9 = a4;
    else
      v9 = (uint64_t *)*a4;
    v10 = (char *)operator new(0x28uLL);
    *(_QWORD *)(v10 + 29) = 0;
    *(_OWORD *)v10 = 0u;
    *((_OWORD *)v10 + 1) = 0u;
    boost::uuids::to_chars<char *>((uint64_t)&v23, v10);
    v11 = *(_QWORD *)(a5 + 40);
    v12[0] = 68290051;
    v13 = 2082;
    v12[1] = 0;
    v14 = "";
    v15 = 2081;
    v16 = v6;
    v17 = 2081;
    v18 = v9;
    v19 = 2081;
    v20 = v10;
    v21 = 1025;
    v22 = v11;
    _os_log_impl(&dword_2419D9000, v8, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLMicroLocationLogic::deleteService\", \"clientId\":%{private, location:escape_only}s, \"userId\":%{private, location:escape_only}s, \"serviceId\":%{private, location:escape_only}s, \"result\":%{private}d}", (uint8_t *)v12, 0x36u);
    operator delete(v10);
  }

}

void sub_2419F23F8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  operator delete(v2);

  _Unwind_Resume(a1);
}

void CLMicroLocationLogic::queryServices(uint64_t a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  CLMiLoServiceManager::queryServices(a1 + 1768, a2, a3, a4);
}

uint64_t CLMicroLocationLogic::connectToService(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, __int128 *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  __int128 v9;
  char v10;
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  v9 = *a5;
  v10 = *((_BYTE *)a5 + 16);
  return CLMiLoServiceManager::connect(a1 + 1768, a2, a3, a4, (uint64_t)&v9, a6, a7, a8);
}

uint64_t CLMicroLocationLogic::disconnectFromService(uint64_t a1, const std::string *a2, uint64_t a3, uint64_t a4, unsigned __int8 *a5)
{
  return CLMiLoServiceManager::disconnect((_QWORD *)(a1 + 1768), a2, a3, a4, a5);
}

uint64_t CLMicroLocationLogic::predictionRequest(uint64_t a1, uuid a2, const uuid *a3, double *a4, int a5)
{
  return CLMiLoServiceManager::predictionRequest((CLMiLoServiceManager *)(a1 + 1768), a2, a3, a4, a5);
}

uint64_t CLMicroLocationLogic::requestObservation(uint64_t a1, uuid a2, uint64_t a3, uint64_t a4, __int128 *a5, double *a6)
{
  __int128 v7;
  char v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v7 = *a5;
  v8 = *((_BYTE *)a5 + 16);
  return CLMiLoServiceManager::requestObservation((CLMiLoServiceManager *)(a1 + 1768), a2, a3, a4, (uint64_t)&v7, a6);
}

uint64_t CLMicroLocationLogic::onSendStatusToClient(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 2584) + 16))(*(_QWORD *)(a1 + 2584));
}

uint64_t `non-virtual thunk to'CLMicroLocationLogic::onSendStatusToClient(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 2568) + 16))(*(_QWORD *)(a1 + 2568));
}

uint64_t CLMicroLocationLogic::onSendRequestResponseToClient(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 2584) + 24))(*(_QWORD *)(a1 + 2584));
}

uint64_t `non-virtual thunk to'CLMicroLocationLogic::onSendRequestResponseToClient(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 2568) + 24))(*(_QWORD *)(a1 + 2568));
}

uint64_t CLMicroLocationLogic::onSendRecordingMetaInfoToClient(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 2584) + 32))(*(_QWORD *)(a1 + 2584));
}

uint64_t `non-virtual thunk to'CLMicroLocationLogic::onSendRecordingMetaInfoToClient(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 2568) + 32))(*(_QWORD *)(a1 + 2568));
}

uint64_t CLMicroLocationLogic::onSendPredictionMetaInfoToClient(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 2584) + 40))(*(_QWORD *)(a1 + 2584));
}

uint64_t `non-virtual thunk to'CLMicroLocationLogic::onSendPredictionMetaInfoToClient(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 2568) + 40))(*(_QWORD *)(a1 + 2568));
}

uint64_t CLMicroLocationLogic::onSendPredictionResultsToClient(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t a5)
{
  NSObject *v8;
  const char *v9;
  std::string *v10;
  _OWORD *v11;
  std::string *v12;
  int v13;
  char *v14;
  void **v15;
  uint64_t v16;
  void **v17;
  void *v18;
  void *v19;
  void *v20;
  void *v21;
  unsigned int v22;
  unsigned int v23;
  unsigned int v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  NSObject *v28;
  char *v29;
  int v30;
  std::string::size_type v31;
  std::string *v32;
  std::string *v33;
  std::string *v34;
  unint64_t v35;
  uint64_t v36;
  unsigned int v37;
  NSObject *v38;
  char *v39;
  int v40;
  std::string::size_type v41;
  std::string *v42;
  std::string *v43;
  std::string *v44;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  void *__p[2];
  uint64_t v52;
  void **v53;
  __int128 v54;
  void *v55;
  __int128 v56;
  std::string v57;
  std::string v58;
  uint64_t buf;
  __int16 v60;
  const char *v61;
  __int16 v62;
  std::string *v63;
  __int16 v64;
  std::string *v65;
  __int16 v66;
  std::string *v67;
  __int16 v68;
  void **v69;
  __int16 v70;
  uint64_t v71;
  uint64_t v72;

  v72 = *MEMORY[0x24BDAC8D0];
  if (onceToken_MicroLocationQE_Default != -1)
    dispatch_once(&onceToken_MicroLocationQE_Default, &__block_literal_global_428);
  v8 = (id)logObject_MicroLocationQE_Default;
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    if (*((_BYTE *)a4 + 48))
      v9 = "YES";
    else
      v9 = "NO";
    memset(&v57, 0, sizeof(v57));
    std::optional<std::string>::value_or[abi:ne180100]<std::string>((uint64_t)(a4 + 7), (uint64_t)&v57, &v58);
    if ((v58.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v10 = &v58;
    else
      v10 = (std::string *)v58.__r_.__value_.__r.__words[0];
    v11 = operator new(0x28uLL);
    v55 = v11;
    v56 = xmmword_241BB2320;
    *v11 = 0u;
    v11[1] = 0u;
    *(_QWORD *)((char *)v11 + 29) = 0;
    boost::uuids::to_chars<char *>(a2, v11);
    if (v56 >= 0)
      v12 = (std::string *)&v55;
    else
      v12 = (std::string *)v55;
    v13 = *(unsigned __int8 *)(a3 + 16);
    if (*(_BYTE *)(a3 + 16))
    {
      v14 = (char *)operator new(0x28uLL);
      v53 = (void **)v14;
      v54 = xmmword_241BB2320;
      *(_OWORD *)v14 = 0u;
      *((_OWORD *)v14 + 1) = 0u;
      *(_QWORD *)(v14 + 29) = 0;
      boost::uuids::to_chars<char *>(a3, v14);
      v15 = (void **)&v53;
      if (v54 < 0)
        v15 = v53;
    }
    else
    {
      __p[0] = 0;
      __p[1] = 0;
      v15 = __p;
      v52 = 0;
    }
    v16 = (a4[1] - *a4) >> 5;
    buf = 68290307;
    v60 = 2082;
    v61 = "";
    v62 = 2081;
    v63 = (std::string *)v9;
    v64 = 2081;
    v65 = v10;
    v66 = 2081;
    v67 = v12;
    v68 = 2081;
    v69 = v15;
    v70 = 2049;
    v71 = v16;
    _os_log_impl(&dword_2419D9000, v8, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"Localizer results, model\", \"isStable\":%{private, location:escape_only}s, \"clientIdentifier\":%{private, location:escape_only}s, \"serviceUUID\":%{private, location:escape_only}s, \"requestId\":%{private, location:escape_only}s, \"numberOfMicroLocations\":%{private}lu}", (uint8_t *)&buf, 0x44u);
    if (v13)
    {
      if (SHIBYTE(v54) < 0)
      {
        v17 = v53;
LABEL_23:
        operator delete(v17);
      }
    }
    else if (SHIBYTE(v52) < 0)
    {
      v17 = (void **)__p[0];
      goto LABEL_23;
    }
    if (SHIBYTE(v56) < 0)
      operator delete(v55);
    if (SHIBYTE(v58.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v58.__r_.__value_.__l.__data_);
    if (SHIBYTE(v57.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v57.__r_.__value_.__l.__data_);
  }
  v46 = a2;
  v47 = a3;
  v48 = a5;

  +[ULDefaultsSingleton shared](ULDefaultsSingleton, "shared");
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v18, "defaultsDictionary");
  v19 = (void *)objc_claimAutoreleasedReturnValue();

  objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "ULNumberOfLoggedProbabilityResults");
  v20 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v19, "objectForKey:", v20);
  v21 = (void *)objc_claimAutoreleasedReturnValue();
  if (v21 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
    v22 = objc_msgSend(v21, "unsignedIntValue");
  else
    v22 = objc_msgSend(&unk_2511ED198, "unsignedIntValue", a2, v47, v48);
  v23 = v22;

  v24 = 0;
  v25 = *a4;
  v26 = a4[1];
  if (*a4 != v26 && v23)
  {
    v24 = 0;
    v27 = v25 + 32;
    do
    {
      if (onceToken_MicroLocationQE_Default != -1)
        dispatch_once(&onceToken_MicroLocationQE_Default, &__block_literal_global_428);
      v28 = (id)logObject_MicroLocationQE_Default;
      if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
      {
        v29 = (char *)operator new(0x28uLL);
        v58.__r_.__value_.__r.__words[0] = (std::string::size_type)v29;
        *(_OWORD *)&v58.__r_.__value_.__r.__words[1] = xmmword_241BB2320;
        *(_OWORD *)v29 = 0u;
        *((_OWORD *)v29 + 1) = 0u;
        *(_QWORD *)(v29 + 29) = 0;
        boost::uuids::to_chars<char *>(v27 - 32, v29);
        v30 = SHIBYTE(v58.__r_.__value_.__r.__words[2]);
        v31 = v58.__r_.__value_.__r.__words[0];
        v32 = *(std::string **)(v27 - 16);
        v55 = 0;
        v56 = 0uLL;
        std::optional<std::string>::value_or[abi:ne180100]<std::string>((uint64_t)(a4 + 7), (uint64_t)&v55, &v57);
        v33 = &v58;
        if (v30 < 0)
          v33 = (std::string *)v31;
        v34 = &v57;
        if ((v57.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
          v34 = (std::string *)v57.__r_.__value_.__r.__words[0];
        buf = 68289795;
        v60 = 2082;
        v61 = "";
        v62 = 2081;
        v63 = v33;
        v64 = 2049;
        v65 = v32;
        v66 = 2081;
        v67 = v34;
        _os_log_impl(&dword_2419D9000, v28, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"Localizer results, cluster\", \"microLocationId\":%{private, location:escape_only}s, \"probability\":\"%{private}.6f\", \"clientIdentifier\":%{private, location:escape_only}s}", (uint8_t *)&buf, 0x30u);
        if (SHIBYTE(v57.__r_.__value_.__r.__words[2]) < 0)
          operator delete(v57.__r_.__value_.__l.__data_);
        if (SHIBYTE(v56) < 0)
          operator delete(v55);
        if (SHIBYTE(v58.__r_.__value_.__r.__words[2]) < 0)
          operator delete(v58.__r_.__value_.__l.__data_);
      }

      ++v24;
      if (v27 == v26)
        break;
      v27 += 32;
    }
    while (v24 < v23);
    v25 = *a4;
    v26 = a4[1];
  }
  v35 = v24;
  if (v24 < (unint64_t)((v26 - v25) >> 5))
  {
    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_3);
    if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEBUG))
    {
      v36 = *a4;
      if (v24 < (unint64_t)((a4[1] - *a4) >> 5))
      {
        v37 = v24 + 1;
        do
        {
          if (onceToken_MicroLocationQE_Default != -1)
            dispatch_once(&onceToken_MicroLocationQE_Default, &__block_literal_global_428);
          v38 = (id)logObject_MicroLocationQE_Default;
          if (os_log_type_enabled(v38, OS_LOG_TYPE_DEBUG))
          {
            v39 = (char *)operator new(0x28uLL);
            v58.__r_.__value_.__r.__words[0] = (std::string::size_type)v39;
            *(_OWORD *)&v58.__r_.__value_.__r.__words[1] = xmmword_241BB2320;
            *(_OWORD *)v39 = 0u;
            *((_OWORD *)v39 + 1) = 0u;
            *(_QWORD *)(v39 + 29) = 0;
            boost::uuids::to_chars<char *>(v36 + 32 * v35, v39);
            v40 = SHIBYTE(v58.__r_.__value_.__r.__words[2]);
            v41 = v58.__r_.__value_.__r.__words[0];
            v42 = *(std::string **)(v36 + 32 * v35 + 16);
            v55 = 0;
            v56 = 0uLL;
            std::optional<std::string>::value_or[abi:ne180100]<std::string>((uint64_t)(a4 + 7), (uint64_t)&v55, &v57);
            v43 = &v58;
            if (v40 < 0)
              v43 = (std::string *)v41;
            v44 = &v57;
            if ((v57.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
              v44 = (std::string *)v57.__r_.__value_.__r.__words[0];
            buf = 68289795;
            v60 = 2082;
            v61 = "";
            v62 = 2081;
            v63 = v43;
            v64 = 2049;
            v65 = v42;
            v66 = 2081;
            v67 = v44;
            _os_log_impl(&dword_2419D9000, v38, OS_LOG_TYPE_DEBUG, "{\"msg%{public}.0s\":\"Localizer results, cluster\", \"microLocationId\":%{private, location:escape_only}s, \"probability\":\"%{private}.6f\", \"clientIdentifier\":%{private, location:escape_only}s}", (uint8_t *)&buf, 0x30u);
            if (SHIBYTE(v57.__r_.__value_.__r.__words[2]) < 0)
              operator delete(v57.__r_.__value_.__l.__data_);
            if (SHIBYTE(v56) < 0)
              operator delete(v55);
            if (SHIBYTE(v58.__r_.__value_.__r.__words[2]) < 0)
              operator delete(v58.__r_.__value_.__l.__data_);
          }

          v35 = v37;
          v36 = *a4;
          ++v37;
        }
        while (v35 < (a4[1] - *a4) >> 5);
      }
    }
  }
  return (*(uint64_t (**)(_QWORD, uint64_t, uint64_t, uint64_t *, uint64_t))(**(_QWORD **)(a1 + 2584) + 48))(*(_QWORD *)(a1 + 2584), v46, v47, a4, v48);
}

void sub_2419F2C8C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,void *__p,uint64_t a25,int a26,__int16 a27,char a28,char a29,void *a30,uint64_t a31,int a32,__int16 a33,char a34,char a35,void *a36,uint64_t a37,int a38,__int16 a39,char a40,char a41)
{
  void *v41;
  void *v42;
  void *v43;

  _Unwind_Resume(a1);
}

void std::optional<std::string>::value_or[abi:ne180100]<std::string>(uint64_t a1@<X0>, uint64_t a2@<X1>, std::string *a3@<X8>)
{
  if (*(_BYTE *)(a1 + 24))
  {
    if (*(char *)(a1 + 23) < 0)
    {
      std::string::__init_copy_ctor_external(a3, *(const std::string::value_type **)a1, *(_QWORD *)(a1 + 8));
    }
    else
    {
      *(_OWORD *)&a3->__r_.__value_.__l.__data_ = *(_OWORD *)a1;
      a3->__r_.__value_.__r.__words[2] = *(_QWORD *)(a1 + 16);
    }
  }
  else
  {
    *(_OWORD *)&a3->__r_.__value_.__l.__data_ = *(_OWORD *)a2;
    a3->__r_.__value_.__r.__words[2] = *(_QWORD *)(a2 + 16);
    *(_QWORD *)(a2 + 8) = 0;
    *(_QWORD *)(a2 + 16) = 0;
    *(_QWORD *)a2 = 0;
  }
}

uint64_t `non-virtual thunk to'CLMicroLocationLogic::onSendPredictionResultsToClient(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t a5)
{
  return CLMicroLocationLogic::onSendPredictionResultsToClient(a1 - 16, a2, a3, a4, a5);
}

uint64_t CLMicroLocationLogic::onSendGenericEventResponseToClient(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 2584) + 56))(*(_QWORD *)(a1 + 2584));
}

uint64_t `non-virtual thunk to'CLMicroLocationLogic::onSendGenericEventResponseToClient(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 2568) + 56))(*(_QWORD *)(a1 + 2568));
}

uint64_t CLMicroLocationLogic::onEnableMiLoAtCurrentLocationCompleted(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  NSObject *v5;
  uint8_t v6[16];

  result = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 2584) + 64))(*(_QWORD *)(a1 + 2584));
  if (a2 == -1 && *(_BYTE *)(a1 + 96))
  {
    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_3);
    v5 = logObject_MicroLocation_Default;
    if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)v6 = 0;
      _os_log_impl(&dword_2419D9000, v5, OS_LOG_TYPE_DEFAULT, "starting custom LOI recording scan", v6, 2u);
    }
    return CLMicroLocationTriggerManager::startCustomLoiRecordingSession((CLMicroLocationTriggerManager *)(a1 + 1560));
  }
  return result;
}

uint64_t `non-virtual thunk to'CLMicroLocationLogic::onEnableMiLoAtCurrentLocationCompleted(uint64_t a1, uint64_t a2)
{
  return CLMicroLocationLogic::onEnableMiLoAtCurrentLocationCompleted(a1 - 16, a2);
}

BOOL CLMicroLocationLogic::labelObservation(CLMicroLocationLogic *this, uuid a2, uuid a3, uuid a4)
{
  return CLMiLoServiceManager::labelObservation((CLMicroLocationLogic *)((char *)this + 1768), a2, a3, a4);
}

BOOL CLMicroLocationLogic::labelObservationsBetweenDates(CLMicroLocationLogic *this, uuid a2, const uuid *a3, const uuid *a4, NSDate *a5, NSDate *a6)
{
  return CLMiLoServiceManager::labelObservationsBetweenDates((CLMicroLocationLogic *)((char *)this + 1768), a2, a3, a4, a5, a6);
}

BOOL CLMicroLocationLogic::isLowLatencyMode(CLMicroLocationLogic *this)
{
  return CLMicroLocationTriggerManager::isLowLatencyMode((CLMicroLocationLogic *)((char *)this + 1560));
}

BOOL CLMicroLocationLogic::requestMicroLocationLearning(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, const uuid *a5)
{
  return CLMiLoServiceManager::requestMicroLocationLearning((CLMiLoServiceManager *)(a1 + 1768), a2, a3, a4, a5);
}

void CLMicroLocationLogic::triggerLearning(CLMicroLocationLogic *this)
{
  std::string *p_p;
  int data;
  int v4;
  std::string __p;

  if (*((char *)this + 79) < 0)
    std::string::__init_copy_ctor_external(&__p, *((const std::string::value_type **)this + 7), *((_QWORD *)this + 8));
  else
    __p = *(std::string *)((char *)this + 56);
  if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) == 6)
    {
      p_p = &__p;
      goto LABEL_9;
    }
LABEL_13:
    (*(void (**)(_QWORD))(**((_QWORD **)this + 323) + 104))(*((_QWORD *)this + 323));
    goto LABEL_14;
  }
  if (__p.__r_.__value_.__l.__size_ != 6)
    goto LABEL_13;
  p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
LABEL_9:
  data = (int)p_p->__r_.__value_.__l.__data_;
  v4 = WORD2(p_p->__r_.__value_.__r.__words[0]);
  if (data != 1953723747 || v4 != 28015)
    goto LABEL_13;
  (*(void (**)(_QWORD, char *))(**((_QWORD **)this + 323) + 112))(*((_QWORD *)this + 323), (char *)this + 80);
LABEL_14:
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
}

void sub_2419F2F98(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void `non-virtual thunk to'CLMicroLocationLogic::triggerLearning(CLMicroLocationLogic *this)
{
  CLMicroLocationLogic::triggerLearning((CLMicroLocationLogic *)((char *)this - 24));
}

BOOL CLMicroLocationLogic::startUpdating(CLMicroLocationLogic *this, uuid a2, int a3)
{
  uuid v4;
  uint64_t v5;

  v5 = *MEMORY[0x24BDAC8D0];
  v4 = a2;
  return CLMiLoServiceManager::startUpdating((CLMicroLocationLogic *)((char *)this + 1768), &v4, a3);
}

BOOL CLMicroLocationLogic::stopUpdating(CLMicroLocationLogic *this, const uuid *a2)
{
  return CLMiLoServiceManager::stopUpdating((CLMicroLocationLogic *)((char *)this + 1768), a2);
}

uint64_t CLMicroLocationLogic::createCustomLoiAtCurrentLocation(uint64_t a1, const uuid *a2, void *a3)
{
  id v5;
  NSObject *v6;
  char *v7;
  int v8;
  int v9;
  uint64_t v10;
  _DWORD v12[2];
  __int16 v13;
  const char *v14;
  __int16 v15;
  char *v16;
  __int16 v17;
  int v18;
  __int16 v19;
  int v20;
  uint64_t v21;

  v21 = *MEMORY[0x24BDAC8D0];
  v5 = a3;
  *(_BYTE *)(a1 + 96) = objc_msgSend(v5, "isInRoomDetectionEnabled");
  if (onceToken_MicroLocation_Default != -1)
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_3);
  v6 = (id)logObject_MicroLocation_Default;
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    v7 = (char *)operator new(0x28uLL);
    *(_QWORD *)(v7 + 29) = 0;
    *(_OWORD *)v7 = 0u;
    *((_OWORD *)v7 + 1) = 0u;
    boost::uuids::to_chars<char *>((uint64_t)a2, v7);
    v8 = objc_msgSend(v5, "isInRoomDetectionEnabled");
    v9 = *(unsigned __int8 *)(a1 + 96);
    v12[0] = 68289795;
    v12[1] = 0;
    v13 = 2082;
    v14 = "";
    v15 = 2081;
    v16 = v7;
    v17 = 1026;
    v18 = v8;
    v19 = 1026;
    v20 = v9;
    _os_log_impl(&dword_2419D9000, v6, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"createCustomLoiAtCurrentLocation\", \"connectionId\":%{private, location:escape_only}s, \"In room enabled\":%{public}hhd, \"state\":%{public}hhd}", (uint8_t *)v12, 0x28u);
    operator delete(v7);
  }

  v10 = CLMiLoServiceManager::enableMiLoAtCurrentLocation((CLMiLoServiceManager *)(a1 + 1768), a2);
  return v10;
}

void sub_2419F3190(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  operator delete(v3);

  _Unwind_Resume(a1);
}

uint64_t CLMicroLocationLogic::removeCustomLoiWithIdentifier(CLMicroLocationLogic *this, const uuid *a2, uuid a3)
{
  NSObject *v5;
  char *v6;
  char *v7;
  _DWORD v9[2];
  __int16 v10;
  const char *v11;
  __int16 v12;
  char *v13;
  __int16 v14;
  char *v15;
  uuid v16;
  uint64_t v17;

  v17 = *MEMORY[0x24BDAC8D0];
  v16 = a3;
  if (onceToken_MicroLocation_Default != -1)
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_3);
  v5 = (id)logObject_MicroLocation_Default;
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    v6 = (char *)operator new(0x28uLL);
    *(_QWORD *)(v6 + 29) = 0;
    *(_OWORD *)v6 = 0u;
    *((_OWORD *)v6 + 1) = 0u;
    boost::uuids::to_chars<char *>((uint64_t)a2, v6);
    v7 = (char *)operator new(0x28uLL);
    *(_QWORD *)(v7 + 29) = 0;
    *(_OWORD *)v7 = 0u;
    *((_OWORD *)v7 + 1) = 0u;
    boost::uuids::to_chars<char *>((uint64_t)&v16, v7);
    v9[0] = 68289539;
    v9[1] = 0;
    v10 = 2082;
    v11 = "";
    v12 = 2081;
    v13 = v6;
    v14 = 2081;
    v15 = v7;
    _os_log_impl(&dword_2419D9000, v5, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"removeCustomLoiWithIdentifier\", \"identifier\":%{private, location:escape_only}s, \"connectionId\":%{private, location:escape_only}s}", (uint8_t *)v9, 0x26u);
    operator delete(v7);
    operator delete(v6);
  }

  return CLMiLoServiceManager::removeCustomLoiWithIdentifier((CLMicroLocationLogic *)((char *)this + 1768), a2, &v16);
}

void sub_2419F333C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  operator delete(v3);
  operator delete(v2);

  _Unwind_Resume(a1);
}

void CLMicroLocationLogic::updateBleOobKeys(uint64_t a1, void *a2)
{
  CLMicroLocationSensorsLogic::updateBleOobKeys(a1 + 712, a2);
}

void CLMicroLocationLogic::startOdometryMonitoring(id *this)
{
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  int v6;
  int v7;
  NSObject *v8;
  _DWORD v9[2];
  __int16 v10;
  const char *v11;
  uint64_t v12;

  v12 = *MEMORY[0x24BDAC8D0];
  +[ULDefaultsSingleton shared](ULDefaultsSingleton, "shared");
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v2, "defaultsDictionary");
  v3 = (void *)objc_claimAutoreleasedReturnValue();

  objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "ULOdometryTrackingEnabled");
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v3, "objectForKey:", v4);
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  if (v5 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
    v6 = objc_msgSend(v5, "BOOLValue");
  else
    v6 = objc_msgSend(MEMORY[0x24BDBD1C8], "BOOLValue");
  v7 = v6;

  if (v7)
  {
    CLMicroLocationSensorsLogic::startOdometryMonitoringIfStopped(this + 89);
  }
  else
  {
    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_3);
    v8 = logObject_MicroLocation_Default;
    if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT))
    {
      v9[0] = 68289026;
      v9[1] = 0;
      v10 = 2082;
      v11 = "";
      _os_log_impl(&dword_2419D9000, v8, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"Got odometry start request, but odometry monitor setting disabled\"}", (uint8_t *)v9, 0x12u);
    }
    CLMicroLocationSensorsLogic::stopOdometryMonitoringIfRunning(this + 89);
  }
}

void sub_2419F3544(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void `non-virtual thunk to'CLMicroLocationLogic::startOdometryMonitoring(id *this)
{
  CLMicroLocationLogic::startOdometryMonitoring(this - 1);
}

void CLMicroLocationLogic::stopOdometryMonitoring(id *this)
{
  CLMicroLocationSensorsLogic::stopOdometryMonitoringIfRunning(this + 89);
}

void `non-virtual thunk to'CLMicroLocationLogic::stopOdometryMonitoring(id *this)
{
  CLMicroLocationSensorsLogic::stopOdometryMonitoringIfRunning(this + 88);
}

void CLMicroLocationLogic::removePendingConnectionRequestsByConnectionToken(CLMicroLocationLogic *this, uuid a2)
{
  CLMiLoServiceManager::removePendingConnectionRequestsByConnectionToken((CLMicroLocationLogic *)((char *)this + 1768), a2);
}

void CLMicroLocationLogic::didEnableMicroLocationAtCurrentLocationWithResponse(uint64_t a1, uint64_t a2)
{
  CLMiLoServiceManager::onEnableMiLoAtCurrentLocationResponse((int64x2_t *)(a1 + 1768), a2);
}

void `non-virtual thunk to'CLMicroLocationLogic::didEnableMicroLocationAtCurrentLocationWithResponse(uint64_t a1, uint64_t a2)
{
  CLMiLoServiceManager::onEnableMiLoAtCurrentLocationResponse((int64x2_t *)(a1 + 1736), a2);
}

void CLMicroLocationLogic::setCurrentLoi(CLMicroLocationLogic *this, uint64_t a2, uint64_t a3, uint64_t a4, CLMicroLocationProto *a5)
{
  std::string __p;

  if (*(char *)(a2 + 23) < 0)
    std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)a2, *(_QWORD *)(a2 + 8));
  else
    __p = *(std::string *)a2;
  CLMicroLocationLogic::setCurrentRTLOI(this, (uint64_t)&__p, a3, a4, a5);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
}

void sub_2419F364C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void `non-virtual thunk to'CLMicroLocationLogic::setCurrentLoi(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, CLMicroLocationProto *a5)
{
  CLMicroLocationLogic::setCurrentLoi((CLMicroLocationLogic *)(a1 - 32), a2, a3, a4, a5);
}

void CLMicroLocationLogic::onOdometryUpdate(CLMicroLocationLogic *this, Entry a2)
{
  __int128 *v2;
  id v3;
  id v4;
  _QWORD *v5;
  id v6;
  __int128 v7;
  uint64_t v8;
  _QWORD *v9;
  char *v10;
  char *v11;
  void **v12;
  char v13;

  v2 = *(__int128 **)a2.var0.var0;
  v3 = *(id *)(*((_QWORD *)this + 16) + 120);
  v7 = *v2;
  v8 = *((_QWORD *)v2 + 2);
  v4 = *((id *)v2 + 3);
  v10 = 0;
  v11 = 0;
  v9 = 0;
  v12 = (void **)&v9;
  v13 = 0;
  v5 = operator new(0x20uLL);
  v9 = v5;
  v10 = (char *)v5;
  v11 = (char *)(v5 + 4);
  *(_OWORD *)v5 = v7;
  v5[2] = v8;
  v6 = v4;
  v5[3] = v6;
  v10 = (char *)(v5 + 4);
  objc_msgSend(v3, "insertEntries:", &v9);
  v12 = (void **)&v9;
  std::vector<CLMiLoOdometryTable::Entry>::__destroy_vector::operator()[abi:ne180100](&v12);

}

void sub_2419F3744(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  uint64_t v7;
  void *v8;
  void *v9;
  va_list va;

  va_start(va, a7);
  std::vector<CLMiLoOdometryTable::Entry>::__destroy_vector::operator()[abi:ne180100]((void ***)va);

  _Unwind_Resume(a1);
}

void CLMicroLocationLogic::onOdometryError(CLMicroLocationLogic *this, Entry a2)
{
  __int128 *v2;
  id v3;
  id v4;
  _QWORD *v5;
  id v6;
  __int128 v7;
  uint64_t v8;
  _QWORD *v9;
  char *v10;
  char *v11;
  void **v12;
  char v13;

  v2 = *(__int128 **)a2.var0.var0;
  v3 = *(id *)(*((_QWORD *)this + 16) + 120);
  v7 = *v2;
  v8 = *((_QWORD *)v2 + 2);
  v4 = *((id *)v2 + 3);
  v10 = 0;
  v11 = 0;
  v9 = 0;
  v12 = (void **)&v9;
  v13 = 0;
  v5 = operator new(0x20uLL);
  v9 = v5;
  v10 = (char *)v5;
  v11 = (char *)(v5 + 4);
  *(_OWORD *)v5 = v7;
  v5[2] = v8;
  v6 = v4;
  v5[3] = v6;
  v10 = (char *)(v5 + 4);
  objc_msgSend(v3, "insertEntries:", &v9);
  v12 = (void **)&v9;
  std::vector<CLMiLoOdometryTable::Entry>::__destroy_vector::operator()[abi:ne180100](&v12);

}

void sub_2419F3848(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  uint64_t v7;
  void *v8;
  void *v9;
  va_list va;

  va_start(va, a7);
  std::vector<CLMiLoOdometryTable::Entry>::__destroy_vector::operator()[abi:ne180100]((void ***)va);

  _Unwind_Resume(a1);
}

void ___ZL45_CLLogObjectForCategory_MicroLocation_Defaultv_block_invoke_1()
{
  os_log_t v0;
  void *v1;

  v0 = os_log_create("com.apple.MicroLocation", "MicroLocation");
  v1 = (void *)logObject_MicroLocation_Default;
  logObject_MicroLocation_Default = (uint64_t)v0;

}

_QWORD *std::vector<CLMicroLocationLoggedEventsTable::Entry>::__init_with_size[abi:ne180100]<CLMicroLocationLoggedEventsTable::Entry*,CLMicroLocationLoggedEventsTable::Entry*>(_QWORD *result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  _QWORD *v6;

  if (a4)
  {
    v6 = result;
    std::vector<CLMicroLocationLoggedEventsTable::Entry>::__vallocate[abi:ne180100](result, a4);
    result = (_QWORD *)std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<CLMicroLocationLoggedEventsTable::Entry>,CLMicroLocationLoggedEventsTable::Entry*,CLMicroLocationLoggedEventsTable::Entry*,CLMicroLocationLoggedEventsTable::Entry*>((uint64_t)(v6 + 2), a2, a3, v6[1]);
    v6[1] = result;
  }
  return result;
}

void sub_2419F390C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  uint64_t v9;
  uint64_t v10;

  *(_QWORD *)(v9 + 8) = v10;
  std::vector<CLMicroLocationLoggedEventsTable::Entry>::__destroy_vector::operator()[abi:ne180100](&a9);
  _Unwind_Resume(a1);
}

char *std::vector<CLMicroLocationLoggedEventsTable::Entry>::__vallocate[abi:ne180100](_QWORD *a1, unint64_t a2)
{
  char *result;
  uint64_t v4;

  if (a2 >= 0xC30C30C30C30C4)
    std::vector<CLMicroLocationProto::ConfidenceReason>::__throw_length_error[abi:ne180100]();
  result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<CLMicroLocationLoggedEventsTable::Entry>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[336 * v4];
  return result;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<CLMicroLocationLoggedEventsTable::Entry>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0xC30C30C30C30C4)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(336 * a2);
}

uint64_t std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<CLMicroLocationLoggedEventsTable::Entry>,CLMicroLocationLoggedEventsTable::Entry*,CLMicroLocationLoggedEventsTable::Entry*,CLMicroLocationLoggedEventsTable::Entry*>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7;
  _OWORD *v8;
  __int128 v9;

  if (a2 != a3)
  {
    v7 = 0;
    do
    {
      v8 = (_OWORD *)(a4 + v7);
      v9 = *(_OWORD *)(a2 + v7);
      *(_OWORD *)((char *)v8 + 12) = *(_OWORD *)(a2 + v7 + 12);
      *v8 = v9;
      CLMicroLocationProto::ReceivedEvent::ReceivedEvent((CLMicroLocationProto::ReceivedEvent *)(a4 + v7 + 32), (const CLMicroLocationProto::ReceivedEvent *)(a2 + v7 + 32));
      v7 += 336;
    }
    while (a2 + v7 != a3);
    a4 += v7;
  }
  return a4;
}

void sub_2419F3A3C(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v4;

  if (v2)
  {
    v4 = v1 - 304;
    do
    {
      CLMicroLocationProto::ReceivedEvent::~ReceivedEvent((CLMicroLocationProto::ReceivedEvent *)(v4 + v2));
      v2 -= 336;
    }
    while (v2);
  }
  _Unwind_Resume(exception_object);
}

void std::vector<CLMicroLocationLoggedEventsTable::Entry>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v1;
  char *v2;
  char *v4;
  void *v5;
  char *v6;

  v1 = *a1;
  v2 = (char *)**a1;
  if (v2)
  {
    v4 = (char *)v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v6 = v4 - 336;
        CLMicroLocationProto::ReceivedEvent::~ReceivedEvent((CLMicroLocationProto::ReceivedEvent *)(v4 - 304));
        v4 = v6;
      }
      while (v6 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void std::vector<CLMiLoServiceManager::ConnectionRequestParams>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v1;
  void *v2;
  uint64_t v4;
  void *v5;

  v1 = *a1;
  v2 = **a1;
  if (v2)
  {
    v4 = (uint64_t)v1[1];
    v5 = **a1;
    if ((void *)v4 != v2)
    {
      do
      {
        v4 -= 104;
        std::allocator<CLMiLoServiceManager::ConnectionRequestParams>::destroy[abi:ne180100]((uint64_t)(v1 + 2), v4);
      }
      while ((void *)v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void std::allocator<CLMiLoServiceManager::ConnectionRequestParams>::destroy[abi:ne180100](uint64_t a1, uint64_t a2)
{
  if (*(char *)(a2 + 103) < 0)
    operator delete(*(void **)(a2 + 80));
  if (*(char *)(a2 + 23) < 0)
    operator delete(*(void **)a2);
}

uint64_t std::deque<CLMiLoServiceManager::OutstandingEnableCustomLoiRequest>::~deque[abi:ne180100](_QWORD *a1)
{
  void **v2;
  void **v3;
  unint64_t v4;
  unint64_t v5;
  uint64_t v6;
  void *v7;

  v2 = (void **)a1[1];
  v3 = (void **)a1[2];
  a1[5] = 0;
  v4 = (char *)v3 - (char *)v2;
  if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
  {
    do
    {
      operator delete(*v2);
      v3 = (void **)a1[2];
      v2 = (void **)(a1[1] + 8);
      a1[1] = v2;
      v4 = (char *)v3 - (char *)v2;
    }
    while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
  }
  v5 = v4 >> 3;
  if (v5 == 1)
  {
    v6 = 128;
  }
  else
  {
    if (v5 != 2)
      goto LABEL_9;
    v6 = 256;
  }
  a1[4] = v6;
LABEL_9:
  while (v2 != v3)
  {
    v7 = *v2++;
    operator delete(v7);
  }
  return std::__split_buffer<CLMiLoServiceManager::OutstandingEnableCustomLoiRequest *>::~__split_buffer((uint64_t)a1);
}

uint64_t std::__split_buffer<CLMiLoServiceManager::OutstandingEnableCustomLoiRequest *>::~__split_buffer(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  void *v4;

  v3 = *(_QWORD *)(a1 + 8);
  v2 = *(_QWORD *)(a1 + 16);
  if (v2 != v3)
    *(_QWORD *)(a1 + 16) = v2 + ((v3 - v2 + 7) & 0xFFFFFFFFFFFFFFF8);
  v4 = *(void **)a1;
  if (*(_QWORD *)a1)
    operator delete(v4);
  return a1;
}

uint64_t std::__hash_table<std::__hash_value_type<boost::uuids::uuid,std::weak_ptr<CLMicroLocationFingerprint>>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::weak_ptr<CLMicroLocationFingerprint>>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::weak_ptr<CLMicroLocationFingerprint>>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,std::weak_ptr<CLMicroLocationFingerprint>>>>::~__hash_table(uint64_t a1)
{
  void *v2;

  std::__hash_table<std::__hash_value_type<boost::uuids::uuid,std::weak_ptr<CLMicroLocationFingerprint>>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::weak_ptr<CLMicroLocationFingerprint>>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::weak_ptr<CLMicroLocationFingerprint>>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,std::weak_ptr<CLMicroLocationFingerprint>>>>::__deallocate_node(a1, *(_QWORD **)(a1 + 16));
  v2 = *(void **)a1;
  *(_QWORD *)a1 = 0;
  if (v2)
    operator delete(v2);
  return a1;
}

void std::__hash_table<std::__hash_value_type<boost::uuids::uuid,std::weak_ptr<CLMicroLocationFingerprint>>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::weak_ptr<CLMicroLocationFingerprint>>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::weak_ptr<CLMicroLocationFingerprint>>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,std::weak_ptr<CLMicroLocationFingerprint>>>>::__deallocate_node(int a1, _QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;
  std::__shared_weak_count *v4;

  if (__p)
  {
    v2 = __p;
    do
    {
      v3 = (_QWORD *)*v2;
      v4 = (std::__shared_weak_count *)v2[5];
      if (v4)
        std::__shared_weak_count::__release_weak(v4);
      operator delete(v2);
      v2 = v3;
    }
    while (v3);
  }
}

void std::__list_imp<CLMiLoService>::clear(uint64_t *a1)
{
  uint64_t v2;
  uint64_t *v3;
  uint64_t v4;
  uint64_t *v5;

  if (a1[2])
  {
    v2 = *a1;
    v3 = (uint64_t *)a1[1];
    v4 = *v3;
    *(_QWORD *)(v4 + 8) = *(_QWORD *)(*a1 + 8);
    **(_QWORD **)(v2 + 8) = v4;
    a1[2] = 0;
    if (v3 != a1)
    {
      do
      {
        v5 = (uint64_t *)v3[1];
        std::__destroy_at[abi:ne180100]<CLMiLoService,0>((uint64_t)(v3 + 2));
        operator delete(v3);
        v3 = v5;
      }
      while (v5 != a1);
    }
  }
}

void std::__destroy_at[abi:ne180100]<CLMiLoService,0>(uint64_t a1)
{
  std::deque<CLMiLoService::OutstandingRequest>::~deque[abi:ne180100]((_QWORD *)(a1 + 376));
  std::deque<CLMiLoService::OutstandingRequest>::~deque[abi:ne180100]((_QWORD *)(a1 + 304));
  std::__optional_destruct_base<CachedPrediction,false>::~__optional_destruct_base[abi:ne180100](a1 + 112);
  std::shared_ptr<CLMiLoService::ModelAndConf>::~shared_ptr[abi:ne180100](a1 + 96);
  if (*(char *)(a1 + 87) < 0)
    operator delete(*(void **)(a1 + 64));
  if (*(char *)(a1 + 63) < 0)
    operator delete(*(void **)(a1 + 40));
}

uint64_t std::deque<CLMiLoService::OutstandingRequest>::~deque[abi:ne180100](_QWORD *a1)
{
  void **v2;
  void **v3;
  unint64_t v4;
  unint64_t v5;
  uint64_t v6;
  void *v7;

  v2 = (void **)a1[1];
  v3 = (void **)a1[2];
  a1[5] = 0;
  v4 = (char *)v3 - (char *)v2;
  if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
  {
    do
    {
      operator delete(*v2);
      v3 = (void **)a1[2];
      v2 = (void **)(a1[1] + 8);
      a1[1] = v2;
      v4 = (char *)v3 - (char *)v2;
    }
    while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
  }
  v5 = v4 >> 3;
  if (v5 == 1)
  {
    v6 = 60;
  }
  else
  {
    if (v5 != 2)
      goto LABEL_9;
    v6 = 120;
  }
  a1[4] = v6;
LABEL_9:
  while (v2 != v3)
  {
    v7 = *v2++;
    operator delete(v7);
  }
  return std::__split_buffer<CLMiLoServiceManager::OutstandingEnableCustomLoiRequest *>::~__split_buffer((uint64_t)a1);
}

uint64_t std::__optional_destruct_base<CachedPrediction,false>::~__optional_destruct_base[abi:ne180100](uint64_t a1)
{
  void *v2;
  void *v3;

  if (*(_BYTE *)(a1 + 184))
  {
    v2 = *(void **)(a1 + 144);
    if (v2)
    {
      *(_QWORD *)(a1 + 152) = v2;
      operator delete(v2);
    }
    if (*(_BYTE *)(a1 + 128))
      std::__hash_table<std::__hash_value_type<std::string,AnchorValueStatistics>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,AnchorValueStatistics>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,AnchorValueStatistics>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,AnchorValueStatistics>>>::~__hash_table(a1 + 88);
    if (*(_BYTE *)(a1 + 80) && *(char *)(a1 + 79) < 0)
      operator delete(*(void **)(a1 + 56));
    v3 = *(void **)a1;
    if (*(_QWORD *)a1)
    {
      *(_QWORD *)(a1 + 8) = v3;
      operator delete(v3);
    }
  }
  return a1;
}

uint64_t std::__hash_table<std::__hash_value_type<std::string,AnchorValueStatistics>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,AnchorValueStatistics>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,AnchorValueStatistics>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,AnchorValueStatistics>>>::~__hash_table(uint64_t a1)
{
  void *v2;

  std::__hash_table<std::__hash_value_type<std::string,AnchorValueStatistics>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,AnchorValueStatistics>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,AnchorValueStatistics>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,AnchorValueStatistics>>>::__deallocate_node(a1, *(void ***)(a1 + 16));
  v2 = *(void **)a1;
  *(_QWORD *)a1 = 0;
  if (v2)
    operator delete(v2);
  return a1;
}

void std::__hash_table<std::__hash_value_type<std::string,AnchorValueStatistics>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,AnchorValueStatistics>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,AnchorValueStatistics>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,AnchorValueStatistics>>>::__deallocate_node(int a1, void **__p)
{
  void **v2;
  void **v3;

  if (__p)
  {
    v2 = __p;
    do
    {
      v3 = (void **)*v2;
      if (*((char *)v2 + 39) < 0)
        operator delete(v2[2]);
      operator delete(v2);
      v2 = v3;
    }
    while (v3);
  }
}

void std::vector<std::shared_ptr<CLMiLoService::ModelAndConf>>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v1;
  void *v2;
  uint64_t v4;
  void *v5;

  v1 = *a1;
  v2 = **a1;
  if (v2)
  {
    v4 = (uint64_t)v1[1];
    v5 = v2;
    if ((void *)v4 != v2)
    {
      do
        v4 = std::shared_ptr<CLMiLoService::ModelAndConf>::~shared_ptr[abi:ne180100](v4 - 16);
      while ((void *)v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void std::vector<CLMicroLocationProto::RecordingEvent>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v1;
  char *v2;
  char *v4;
  void *v5;
  char *v6;
  char *v7;
  void (**v8)(char *);
  BOOL v9;

  v1 = *a1;
  v2 = (char *)**a1;
  if (v2)
  {
    v4 = (char *)v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      v6 = v4 - 144;
      v7 = v4 - 144;
      do
      {
        v8 = *(void (***)(char *))v7;
        v7 -= 144;
        (*v8)(v6);
        v9 = v6 == v2;
        v6 = v7;
      }
      while (!v9);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>>>::~__hash_table(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  void *v4;

  v2 = *(_QWORD **)(a1 + 16);
  if (v2)
  {
    do
    {
      v3 = (_QWORD *)*v2;
      operator delete(v2);
      v2 = v3;
    }
    while (v3);
  }
  v4 = *(void **)a1;
  *(_QWORD *)a1 = 0;
  if (v4)
    operator delete(v4);
  return a1;
}

uint64_t std::__optional_destruct_base<CLMicroLocationLocalizationController::LocalizationInput,false>::~__optional_destruct_base[abi:ne180100](uint64_t a1)
{
  void *v2;

  if (*(_BYTE *)(a1 + 400))
  {
    CLMicroLocationProto::RecordingEvent::~RecordingEvent((CLMicroLocationProto::RecordingEvent *)(a1 + 248));
    std::__optional_destruct_base<CLMicroLocationFingerprint,false>::~__optional_destruct_base[abi:ne180100](a1 + 48);
    v2 = *(void **)(a1 + 24);
    if (v2)
    {
      *(_QWORD *)(a1 + 32) = v2;
      operator delete(v2);
    }
  }
  return a1;
}

uint64_t std::__optional_destruct_base<CLMicroLocationFingerprint,false>::~__optional_destruct_base[abi:ne180100](uint64_t a1)
{
  void *v2;

  if (*(_BYTE *)(a1 + 192))
  {
    v2 = *(void **)(a1 + 168);
    if (v2)
    {
      *(_QWORD *)(a1 + 176) = v2;
      operator delete(v2);
    }
    std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>>>::~__hash_table(a1 + 104);
    std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>>>::~__hash_table(a1 + 64);
    std::__hash_table<CLMicroLocationFingerprint::Measurement,CLMicroLocationFingerprint::Measurement::HashMeasurement,CLMicroLocationFingerprint::Measurement::PredicateMeasurement,std::allocator<CLMicroLocationFingerprint::Measurement>>::~__hash_table(a1);
  }
  return a1;
}

uint64_t std::__hash_table<CLMicroLocationFingerprint::Measurement,CLMicroLocationFingerprint::Measurement::HashMeasurement,CLMicroLocationFingerprint::Measurement::PredicateMeasurement,std::allocator<CLMicroLocationFingerprint::Measurement>>::~__hash_table(uint64_t a1)
{
  void *v2;

  std::__hash_table<CLMicroLocationFingerprint::Measurement,CLMicroLocationFingerprint::Measurement::HashMeasurement,CLMicroLocationFingerprint::Measurement::PredicateMeasurement,std::allocator<CLMicroLocationFingerprint::Measurement>>::__deallocate_node(a1, *(_QWORD **)(a1 + 16));
  v2 = *(void **)a1;
  *(_QWORD *)a1 = 0;
  if (v2)
    operator delete(v2);
  return a1;
}

void std::__hash_table<CLMicroLocationFingerprint::Measurement,CLMicroLocationFingerprint::Measurement::HashMeasurement,CLMicroLocationFingerprint::Measurement::PredicateMeasurement,std::allocator<CLMicroLocationFingerprint::Measurement>>::__deallocate_node(uint64_t a1, _QWORD *a2)
{
  _QWORD *v2;
  _QWORD *v3;

  if (a2)
  {
    v2 = a2;
    do
    {
      v3 = (_QWORD *)*v2;
      std::__variant_detail::__dtor<std::__variant_detail::__traits<unsigned long long,boost::uuids::uuid,std::string>,(std::__variant_detail::_Trait)1>::~__dtor((uint64_t)(v2 + 4));
      operator delete(v2);
      v2 = v3;
    }
    while (v3);
  }
}

uint64_t std::__variant_detail::__dtor<std::__variant_detail::__traits<unsigned long long,boost::uuids::uuid,std::string>,(std::__variant_detail::_Trait)1>::~__dtor(uint64_t a1)
{
  uint64_t v2;
  char v4;

  v2 = *(unsigned int *)(a1 + 24);
  if ((_DWORD)v2 != -1)
    ((void (*)(char *, uint64_t))off_2511D2858[v2])(&v4, a1);
  *(_DWORD *)(a1 + 24) = -1;
  return a1;
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm2EEE10__dispatchB8ne180100IOZNS0_6__dtorINS0_8__traitsIJyN5boost5uuids4uuidENS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEEEELNS0_6_TraitE1EE9__destroyB8ne180100EvEUlRT_E_JRNS0_6__baseILSI_1EJySA_SG_EEEEEEDcSK_DpT0_(uint64_t a1, uint64_t a2)
{
  if (*(char *)(a2 + 23) < 0)
    operator delete(*(void **)a2);
}

void std::vector<CLMicroLocationLocalizationController::LocalizationRequest>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v1;
  char *v2;
  char *v4;
  void *v5;

  v1 = *a1;
  v2 = (char *)**a1;
  if (v2)
  {
    v4 = (char *)v1[1];
    v5 = v2;
    if (v4 != v2)
    {
      do
        CLMicroLocationLocalizationController::LocalizationRequest::~LocalizationRequest((CLMicroLocationLocalizationController::LocalizationRequest *)(v4 - 200));
      while (v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void std::vector<CLMiLoProtobufWrapper::Measurement>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v1;
  char *v2;
  char *v4;
  void *v5;

  v1 = *a1;
  v2 = (char *)**a1;
  if (v2)
  {
    v4 = (char *)v1[1];
    v5 = v2;
    if (v4 != v2)
    {
      do
        CLMicroLocationProto::Measurement::~Measurement((CLMicroLocationProto::Measurement *)(v4 - 88));
      while (v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

_QWORD *std::string::basic_string[abi:ne180100](_QWORD *__b, size_t __len, int __c)
{
  void *v6;
  size_t v7;
  size_t v8;

  if (__len >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  if (__len >= 0x17)
  {
    v7 = (__len & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((__len | 7) != 0x17)
      v7 = __len | 7;
    v8 = v7 + 1;
    v6 = operator new(v7 + 1);
    __b[1] = __len;
    __b[2] = v8 | 0x8000000000000000;
    *__b = v6;
  }
  else
  {
    *((_BYTE *)__b + 23) = __len;
    v6 = __b;
    if (!__len)
      goto LABEL_9;
  }
  memset(v6, __c, __len);
LABEL_9:
  *((_BYTE *)v6 + __len) = 0;
  return __b;
}

void boost::throw_exception<boost::uuids::entropy_error>(const std::runtime_error *a1, int8x16_t *a2)
{
  void *exception;

  exception = __cxa_allocate_exception(0x48uLL);
  boost::wrapexcept<boost::uuids::entropy_error>::wrapexcept((uint64_t)exception, a1, a2);
}

void sub_2419F43DC(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t boost::wrapexcept<boost::uuids::entropy_error>::wrapexcept(uint64_t a1, const std::runtime_error *a2, int8x16_t *a3)
{
  std::runtime_error_vtbl *v6;

  *(_QWORD *)a1 = &unk_2511D29D0;
  std::runtime_error::runtime_error((std::runtime_error *)(a1 + 8), a2);
  *(_QWORD *)a1 = &unk_2511D2950;
  *(_QWORD *)(a1 + 8) = &unk_2511D2980;
  v6 = a2[1].__vftable;
  *(_QWORD *)(a1 + 48) = 0;
  *(_QWORD *)(a1 + 56) = 0;
  *(_QWORD *)(a1 + 24) = v6;
  *(_QWORD *)(a1 + 32) = &unk_2511D29B0;
  *(_QWORD *)(a1 + 40) = 0;
  *(_DWORD *)(a1 + 64) = a3[1].i32[0];
  *(int8x16_t *)(a1 + 48) = vextq_s8(*a3, *a3, 8uLL);
  return a1;
}

uint64_t boost::wrapexcept<boost::uuids::entropy_error>::~wrapexcept(uint64_t a1)
{
  *(_QWORD *)(a1 + 32) = &unk_2511D2A30;
  boost::exception_detail::refcount_ptr<boost::exception_detail::error_info_container>::~refcount_ptr((uint64_t *)(a1 + 40));
  std::runtime_error::~runtime_error((std::runtime_error *)(a1 + 8));
  return a1;
}

uint64_t boost::wrapexcept<boost::uuids::entropy_error>::clone(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;

  v2 = operator new();
  *(_QWORD *)v2 = &unk_2511D29D0;
  std::runtime_error::runtime_error((std::runtime_error *)(v2 + 8), (const std::runtime_error *)(a1 + 8));
  *(_QWORD *)(v2 + 8) = &unk_2511D2A00;
  *(_QWORD *)(v2 + 24) = *(_QWORD *)(a1 + 24);
  *(_QWORD *)(v2 + 32) = &unk_2511D2A30;
  v3 = *(_QWORD *)(a1 + 40);
  *(_QWORD *)(v2 + 40) = v3;
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 24))(v3);
  *(_OWORD *)(v2 + 48) = *(_OWORD *)(a1 + 48);
  *(_DWORD *)(v2 + 64) = *(_DWORD *)(a1 + 64);
  *(_QWORD *)v2 = &unk_2511D2950;
  *(_QWORD *)(v2 + 8) = &unk_2511D2980;
  *(_QWORD *)(v2 + 32) = &unk_2511D29B0;
  boost::exception_detail::copy_boost_exception(v2 + 32, a1 + 32);
  return v2;
}

void sub_2419F4594(_Unwind_Exception *a1)
{
  uint64_t v1;
  std::runtime_error *v2;

  std::runtime_error::~runtime_error(v2);
  MEMORY[0x2426A04D4](v1, 0x10F1C40261F87E4);
  _Unwind_Resume(a1);
}

void boost::wrapexcept<boost::uuids::entropy_error>::rethrow(uint64_t a1)
{
  void *exception;

  exception = __cxa_allocate_exception(0x48uLL);
  boost::wrapexcept<boost::uuids::entropy_error>::wrapexcept((uint64_t)exception, a1);
}

void sub_2419F4614(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void boost::wrapexcept<boost::uuids::entropy_error>::~wrapexcept(uint64_t a1)
{
  *(_QWORD *)(a1 + 32) = &unk_2511D2A30;
  boost::exception_detail::refcount_ptr<boost::exception_detail::error_info_container>::~refcount_ptr((uint64_t *)(a1 + 40));
  std::runtime_error::~runtime_error((std::runtime_error *)(a1 + 8));
  JUMPOUT(0x2426A04D4);
}

void `non-virtual thunk to'boost::wrapexcept<boost::uuids::entropy_error>::~wrapexcept(uint64_t a1)
{
  *(_QWORD *)(a1 + 24) = &unk_2511D2A30;
  boost::exception_detail::refcount_ptr<boost::exception_detail::error_info_container>::~refcount_ptr((uint64_t *)(a1 + 32));
  std::runtime_error::~runtime_error((std::runtime_error *)a1);
}

{
  *(_QWORD *)(a1 + 24) = &unk_2511D2A30;
  boost::exception_detail::refcount_ptr<boost::exception_detail::error_info_container>::~refcount_ptr((uint64_t *)(a1 + 32));
  std::runtime_error::~runtime_error((std::runtime_error *)a1);
  JUMPOUT(0x2426A04D4);
}

uint64_t boost::uuids::entropy_error::errcode(boost::uuids::entropy_error *this)
{
  return *((_QWORD *)this + 2);
}

void `non-virtual thunk to'boost::wrapexcept<boost::uuids::entropy_error>::~wrapexcept(_QWORD *a1)
{
  *a1 = &unk_2511D2A30;
  boost::exception_detail::refcount_ptr<boost::exception_detail::error_info_container>::~refcount_ptr(a1 + 1);
  std::runtime_error::~runtime_error((std::runtime_error *)(a1 - 3));
}

{
  *a1 = &unk_2511D2A30;
  boost::exception_detail::refcount_ptr<boost::exception_detail::error_info_container>::~refcount_ptr(a1 + 1);
  std::runtime_error::~runtime_error((std::runtime_error *)(a1 - 3));
  JUMPOUT(0x2426A04D4);
}

void boost::uuids::entropy_error::~entropy_error(std::runtime_error *this)
{
  std::runtime_error::~runtime_error(this);
  JUMPOUT(0x2426A04D4);
}

uint64_t *boost::exception_detail::refcount_ptr<boost::exception_detail::error_info_container>::~refcount_ptr(uint64_t *a1)
{
  uint64_t v2;

  v2 = *a1;
  if (v2 && (*(unsigned int (**)(uint64_t))(*(_QWORD *)v2 + 32))(v2))
    *a1 = 0;
  return a1;
}

uint64_t boost::wrapexcept<boost::uuids::entropy_error>::wrapexcept(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  __int128 v5;

  *(_QWORD *)a1 = &unk_2511D29D0;
  std::runtime_error::runtime_error((std::runtime_error *)(a1 + 8), (const std::runtime_error *)(a2 + 8));
  *(_QWORD *)(a1 + 8) = &unk_2511D2A00;
  *(_QWORD *)(a1 + 24) = *(_QWORD *)(a2 + 24);
  *(_QWORD *)(a1 + 32) = &unk_2511D2A30;
  v4 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a1 + 40) = v4;
  if (v4)
    (*(void (**)(uint64_t))(*(_QWORD *)v4 + 24))(v4);
  v5 = *(_OWORD *)(a2 + 48);
  *(_DWORD *)(a1 + 64) = *(_DWORD *)(a2 + 64);
  *(_OWORD *)(a1 + 48) = v5;
  *(_QWORD *)a1 = &unk_2511D2950;
  *(_QWORD *)(a1 + 8) = &unk_2511D2980;
  *(_QWORD *)(a1 + 32) = &unk_2511D29B0;
  return a1;
}

void sub_2419F48B0(_Unwind_Exception *a1)
{
  std::runtime_error *v1;

  std::runtime_error::~runtime_error(v1);
  _Unwind_Resume(a1);
}

uint64_t boost::exception_detail::copy_boost_exception(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t result;
  uint64_t v7;

  v4 = *(_QWORD *)(a2 + 8);
  if (v4)
  {
    (*(void (**)(uint64_t *__return_ptr))(*(_QWORD *)v4 + 40))(&v7);
    v5 = v7;
    if (v7)
    {
      (*(void (**)(uint64_t))(*(_QWORD *)v7 + 24))(v7);
      if (v7)
        (*(void (**)(uint64_t))(*(_QWORD *)v7 + 32))(v7);
    }
  }
  else
  {
    v5 = 0;
  }
  *(_DWORD *)(a1 + 32) = *(_DWORD *)(a2 + 32);
  *(_OWORD *)(a1 + 16) = *(_OWORD *)(a2 + 16);
  result = *(_QWORD *)(a1 + 8);
  if (result)
    result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 32))(result);
  *(_QWORD *)(a1 + 8) = v5;
  if (v5)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v5 + 24))(v5);
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v5 + 32))(v5);
  }
  return result;
}

void sub_2419F4990(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  uint64_t v10;

  if (a10)
    (*(void (**)(uint64_t))(*(_QWORD *)a10 + 32))(a10);
  if (v10)
    (*(void (**)(uint64_t))(*(_QWORD *)v10 + 32))(v10);
  _Unwind_Resume(exception_object);
}

void std::__throw_bad_optional_access[abi:ne180100]()
{
  _QWORD *exception;

  exception = __cxa_allocate_exception(8uLL);
  *exception = MEMORY[0x24BEDB8E0] + 16;
  __cxa_throw(exception, MEMORY[0x24BEDB740], MEMORY[0x24BEDABA8]);
}

void ___ZL47_CLLogObjectForCategory_MicroLocationQE_Defaultv_block_invoke()
{
  os_log_t v0;
  void *v1;

  v0 = os_log_create("com.apple.MicroLocation", "MicroLocationQE");
  v1 = (void *)logObject_MicroLocationQE_Default;
  logObject_MicroLocationQE_Default = (uint64_t)v0;

}

void std::vector<CLMiLoServiceManager::LocalizationResultsPerModel>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v1;
  void *v2;
  uint64_t v4;
  void *v5;

  v1 = *a1;
  v2 = **a1;
  if (v2)
  {
    v4 = (uint64_t)v1[1];
    v5 = **a1;
    if ((void *)v4 != v2)
    {
      do
      {
        v4 -= 216;
        std::allocator<CLMiLoServiceManager::LocalizationResultsPerModel>::destroy[abi:ne180100]((uint64_t)(v1 + 2), v4);
      }
      while ((void *)v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void std::allocator<CLMiLoServiceManager::LocalizationResultsPerModel>::destroy[abi:ne180100](uint64_t a1, uint64_t a2)
{
  void *v3;
  void *v4;
  void *v5;

  if (*(_BYTE *)(a2 + 208))
  {
    v3 = *(void **)(a2 + 184);
    if (v3)
    {
      *(_QWORD *)(a2 + 192) = v3;
      operator delete(v3);
    }
  }
  v4 = *(void **)(a2 + 144);
  if (v4)
  {
    *(_QWORD *)(a2 + 152) = v4;
    operator delete(v4);
  }
  if (*(_BYTE *)(a2 + 128))
    std::__hash_table<std::__hash_value_type<std::string,AnchorValueStatistics>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,AnchorValueStatistics>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,AnchorValueStatistics>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,AnchorValueStatistics>>>::~__hash_table(a2 + 88);
  if (*(_BYTE *)(a2 + 80) && *(char *)(a2 + 79) < 0)
    operator delete(*(void **)(a2 + 56));
  v5 = *(void **)a2;
  if (*(_QWORD *)a2)
  {
    *(_QWORD *)(a2 + 8) = v5;
    operator delete(v5);
  }
}

void std::__optional_storage_base<CLMicroLocationConfigurationTable::Entry,false>::__assign_from[abi:ne180100]<std::__optional_move_assign_base<CLMicroLocationConfigurationTable::Entry,false>>(uint64_t a1, uint64_t a2)
{
  void **v4;
  __int128 v5;
  __int128 v6;

  if (*(unsigned __int8 *)(a1 + 112) == *(unsigned __int8 *)(a2 + 112))
  {
    if (*(_BYTE *)(a1 + 112))
    {
      *(_QWORD *)a1 = *(_QWORD *)a2;
      v4 = (void **)(a1 + 8);
      if (*(char *)(a1 + 31) < 0)
        operator delete(*v4);
      v5 = *(_OWORD *)(a2 + 8);
      *(_QWORD *)(a1 + 24) = *(_QWORD *)(a2 + 24);
      *(_OWORD *)v4 = v5;
      *(_BYTE *)(a2 + 31) = 0;
      *(_BYTE *)(a2 + 8) = 0;
      v6 = *(_OWORD *)(a2 + 32);
      *(_DWORD *)(a1 + 48) = *(_DWORD *)(a2 + 48);
      *(_OWORD *)(a1 + 32) = v6;
      CLMicroLocationProto::Configuration::CopyFrom((CLMicroLocationProto::Configuration *)(a1 + 56), (const CLMicroLocationProto::Configuration *)(a2 + 56));
    }
  }
  else if (*(_BYTE *)(a1 + 112))
  {
    std::__optional_destruct_base<CLMicroLocationConfigurationTable::Entry,false>::reset[abi:ne180100](a1);
  }
  else
  {
    std::__construct_at[abi:ne180100]<CLMicroLocationConfigurationTable::Entry,CLMicroLocationConfigurationTable::Entry,CLMicroLocationConfigurationTable::Entry*>(a1, a2);
    *(_BYTE *)(a1 + 112) = 1;
  }
}

void std::__optional_destruct_base<CLMicroLocationConfigurationTable::Entry,false>::reset[abi:ne180100](uint64_t a1)
{
  if (*(_BYTE *)(a1 + 112))
  {
    CLMicroLocationProto::Configuration::~Configuration((CLMicroLocationProto::Configuration *)(a1 + 56));
    if (*(char *)(a1 + 31) < 0)
      operator delete(*(void **)(a1 + 8));
    *(_BYTE *)(a1 + 112) = 0;
  }
}

uint64_t std::__construct_at[abi:ne180100]<CLMicroLocationConfigurationTable::Entry,CLMicroLocationConfigurationTable::Entry,CLMicroLocationConfigurationTable::Entry*>(uint64_t a1, uint64_t a2)
{
  __int128 v3;
  __int128 v4;

  *(_QWORD *)a1 = *(_QWORD *)a2;
  v3 = *(_OWORD *)(a2 + 8);
  *(_QWORD *)(a1 + 24) = *(_QWORD *)(a2 + 24);
  *(_OWORD *)(a1 + 8) = v3;
  *(_QWORD *)(a2 + 16) = 0;
  *(_QWORD *)(a2 + 24) = 0;
  *(_QWORD *)(a2 + 8) = 0;
  v4 = *(_OWORD *)(a2 + 32);
  *(_DWORD *)(a1 + 48) = *(_DWORD *)(a2 + 48);
  *(_OWORD *)(a1 + 32) = v4;
  CLMicroLocationProto::Configuration::Configuration((CLMicroLocationProto::Configuration *)(a1 + 56), (const CLMicroLocationProto::Configuration *)(a2 + 56));
  return a1;
}

void sub_2419F4CBC(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void **v2;

  if (*(char *)(v1 + 31) < 0)
    operator delete(*v2);
  _Unwind_Resume(exception_object);
}

uint64_t std::__optional_destruct_base<CLMicroLocationConfigurationTable::Entry,false>::~__optional_destruct_base[abi:ne180100](uint64_t a1)
{
  if (*(_BYTE *)(a1 + 112))
  {
    CLMicroLocationProto::Configuration::~Configuration((CLMicroLocationProto::Configuration *)(a1 + 56));
    if (*(char *)(a1 + 31) < 0)
      operator delete(*(void **)(a1 + 8));
  }
  return a1;
}

uint64_t std::__hash_table<CLMicroLocationRapportMonitor::Item,CLMicroLocationRapportMonitor::Item::HashItem,CLMicroLocationRapportMonitor::Item::PredicateItem,std::allocator<CLMicroLocationRapportMonitor::Item>>::~__hash_table(uint64_t a1)
{
  void *v2;

  std::__hash_table<CLMicroLocationRapportMonitor::Item,CLMicroLocationRapportMonitor::Item::HashItem,CLMicroLocationRapportMonitor::Item::PredicateItem,std::allocator<CLMicroLocationRapportMonitor::Item>>::__deallocate_node(a1, *(_QWORD **)(a1 + 16));
  v2 = *(void **)a1;
  *(_QWORD *)a1 = 0;
  if (v2)
    operator delete(v2);
  return a1;
}

void std::__hash_table<CLMicroLocationRapportMonitor::Item,CLMicroLocationRapportMonitor::Item::HashItem,CLMicroLocationRapportMonitor::Item::PredicateItem,std::allocator<CLMicroLocationRapportMonitor::Item>>::__deallocate_node(uint64_t a1, _QWORD *a2)
{
  _QWORD *v2;
  _QWORD *v3;

  if (a2)
  {
    v2 = a2;
    do
    {
      v3 = (_QWORD *)*v2;
      std::__destroy_at[abi:ne180100]<CLMicroLocationRapportMonitor::Item,0>((uint64_t)(v2 + 2));
      operator delete(v2);
      v2 = v3;
    }
    while (v3);
  }
}

void std::__destroy_at[abi:ne180100]<CLMicroLocationRapportMonitor::Item,0>(uint64_t a1)
{
  if (*(char *)(a1 + 63) < 0)
    operator delete(*(void **)(a1 + 40));
  if (*(char *)(a1 + 39) < 0)
    operator delete(*(void **)(a1 + 16));
}

uint64_t std::__function::__value_func<ULWiFiScanProvider * ()(objc_object  {objcproto26ULWiFiScanProviderDelegate}*)>::__value_func[abi:ne180100](uint64_t a1, uint64_t a2)
{
  _QWORD *v3;
  uint64_t v4;

  v3 = (_QWORD *)(a2 + 24);
  v4 = *(_QWORD *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(_QWORD *)(a1 + 24) = a1;
      (*(void (**)(_QWORD, uint64_t))(*(_QWORD *)*v3 + 24))(*v3, a1);
      return a1;
    }
    *(_QWORD *)(a1 + 24) = v4;
  }
  else
  {
    v3 = (_QWORD *)(a1 + 24);
  }
  *v3 = 0;
  return a1;
}

uint64_t std::__function::__value_func<ULOdometryProvider * ()(objc_object  {objcproto26ULOdometryProviderDelegate}*)>::__value_func[abi:ne180100](uint64_t a1, uint64_t a2)
{
  _QWORD *v3;
  uint64_t v4;

  v3 = (_QWORD *)(a2 + 24);
  v4 = *(_QWORD *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(_QWORD *)(a1 + 24) = a1;
      (*(void (**)(_QWORD, uint64_t))(*(_QWORD *)*v3 + 24))(*v3, a1);
      return a1;
    }
    *(_QWORD *)(a1 + 24) = v4;
  }
  else
  {
    v3 = (_QWORD *)(a1 + 24);
  }
  *v3 = 0;
  return a1;
}

void std::vector<std::string>::__vdeallocate(std::vector<std::string> *this)
{
  if (this->__begin_)
  {
    std::vector<std::string>::__clear[abi:ne180100]((uint64_t *)this);
    operator delete(this->__begin_);
    this->__begin_ = 0;
    this->__end_ = 0;
    this->__end_cap_.__value_ = 0;
  }
}

uint64_t **std::__tree<CLMicroLocationRecordingCompletionMetaInformation::RecordingError>::__emplace_unique_key_args<CLMicroLocationRecordingCompletionMetaInformation::RecordingError,CLMicroLocationRecordingCompletionMetaInformation::RecordingError>(uint64_t **a1, int *a2, _DWORD *a3)
{
  uint64_t *v5;
  uint64_t **v6;
  int v7;
  uint64_t **v8;
  int v9;
  uint64_t *v10;

  v6 = a1 + 1;
  v5 = a1[1];
  if (v5)
  {
    v7 = *a2;
    while (1)
    {
      while (1)
      {
        v8 = (uint64_t **)v5;
        v9 = *((_DWORD *)v5 + 7);
        if (v7 >= v9)
          break;
        v5 = *v8;
        v6 = v8;
        if (!*v8)
          goto LABEL_10;
      }
      if (v9 >= v7)
        break;
      v5 = v8[1];
      if (!v5)
      {
        v6 = v8 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    v8 = a1 + 1;
LABEL_10:
    v10 = (uint64_t *)operator new(0x20uLL);
    *((_DWORD *)v10 + 7) = *a3;
    std::__tree<CLMicroLocationRecordingCompletionMetaInformation::RecordingError>::__insert_node_at(a1, (uint64_t)v8, v6, v10);
    return (uint64_t **)v10;
  }
  return v8;
}

uint64_t *std::__tree<CLMicroLocationRecordingCompletionMetaInformation::RecordingError>::__insert_node_at(uint64_t **a1, uint64_t a2, uint64_t **a3, uint64_t *a4)
{
  uint64_t *v5;
  uint64_t *result;

  *a4 = 0;
  a4[1] = 0;
  a4[2] = a2;
  *a3 = a4;
  v5 = (uint64_t *)**a1;
  if (v5)
  {
    *a1 = v5;
    a4 = *a3;
  }
  result = std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(a1[1], a4);
  a1[2] = (uint64_t *)((char *)a1[2] + 1);
  return result;
}

uint64_t *std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(uint64_t *result, uint64_t *a2)
{
  uint64_t *v2;
  uint64_t *v3;
  uint64_t *v4;
  _BYTE *v5;
  int v6;
  uint64_t v7;
  int v8;
  uint64_t **v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  *((_BYTE *)a2 + 24) = a2 == result;
  if (a2 != result)
  {
    do
    {
      v2 = (uint64_t *)a2[2];
      if (*((_BYTE *)v2 + 24))
        return result;
      v3 = (uint64_t *)v2[2];
      v4 = (uint64_t *)*v3;
      if ((uint64_t *)*v3 == v2)
      {
        v7 = v3[1];
        if (!v7 || (v8 = *(unsigned __int8 *)(v7 + 24), v5 = (_BYTE *)(v7 + 24), v8))
        {
          if ((uint64_t *)*v2 == a2)
          {
            v9 = (uint64_t **)a2[2];
          }
          else
          {
            v9 = (uint64_t **)v2[1];
            v10 = *v9;
            v2[1] = (uint64_t)*v9;
            if (v10)
            {
              v10[2] = (uint64_t)v2;
              v3 = (uint64_t *)v2[2];
            }
            v9[2] = v3;
            *(_QWORD *)(v2[2] + 8 * (*(_QWORD *)v2[2] != (_QWORD)v2)) = v9;
            *v9 = v2;
            v2[2] = (uint64_t)v9;
            v3 = v9[2];
            v2 = (uint64_t *)*v3;
          }
          *((_BYTE *)v9 + 24) = 1;
          *((_BYTE *)v3 + 24) = 0;
          v13 = v2[1];
          *v3 = v13;
          if (v13)
            *(_QWORD *)(v13 + 16) = v3;
          v2[2] = v3[2];
          *(_QWORD *)(v3[2] + 8 * (*(_QWORD *)v3[2] != (_QWORD)v3)) = v2;
          v2[1] = (uint64_t)v3;
          goto LABEL_27;
        }
      }
      else if (!v4 || (v6 = *((unsigned __int8 *)v4 + 24), v5 = v4 + 3, v6))
      {
        if ((uint64_t *)*v2 == a2)
        {
          v11 = a2[1];
          *v2 = v11;
          if (v11)
          {
            *(_QWORD *)(v11 + 16) = v2;
            v3 = (uint64_t *)v2[2];
          }
          a2[2] = (uint64_t)v3;
          *(_QWORD *)(v2[2] + 8 * (*(_QWORD *)v2[2] != (_QWORD)v2)) = a2;
          a2[1] = (uint64_t)v2;
          v2[2] = (uint64_t)a2;
          v3 = (uint64_t *)a2[2];
        }
        else
        {
          a2 = (uint64_t *)a2[2];
        }
        *((_BYTE *)a2 + 24) = 1;
        *((_BYTE *)v3 + 24) = 0;
        v2 = (uint64_t *)v3[1];
        v12 = *v2;
        v3[1] = *v2;
        if (v12)
          *(_QWORD *)(v12 + 16) = v3;
        v2[2] = v3[2];
        *(_QWORD *)(v3[2] + 8 * (*(_QWORD *)v3[2] != (_QWORD)v3)) = v2;
        *v2 = (uint64_t)v3;
LABEL_27:
        v3[2] = (uint64_t)v2;
        return result;
      }
      *((_BYTE *)v2 + 24) = 1;
      a2 = v3;
      *((_BYTE *)v3 + 24) = v3 == result;
      *v5 = 1;
    }
    while (v3 != result);
  }
  return result;
}

uint64_t boost::conversion::detail::try_lexical_convert<std::string,boost::uuids::uuid>(uint64_t a1, std::string *a2)
{
  uint64_t v3;
  uint64_t v4;
  __n128 v6[4];
  void *__p;
  char v8;
  std::string::value_type *v9;
  std::string::value_type *v10;

  boost::detail::lexical_istream_limited_src<char,std::char_traits<char>,true,2ul>::lexical_istream_limited_src((uint64_t)v6);
  boost::detail::lexical_istream_limited_src<char,std::char_traits<char>,true,2ul>::shl_input_streamable<boost::uuids::uuid const>(v6);
  v4 = v3;
  if ((v3 & 1) != 0)
    std::string::__assign_trivial[abi:ne180100]<char const*,char const*>(a2, v9, v10, v10 - v9);
  std::ostream::~ostream();
  v6[0].n128_u64[0] = MEMORY[0x24BEDB848] + 16;
  if (v8 < 0)
    operator delete(__p);
  std::streambuf::~streambuf();
  return v4;
}

void sub_2419F5208(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  std::ostream::~ostream();
  if (a22 < 0)
    operator delete(__p);
  std::streambuf::~streambuf();
  _Unwind_Resume(a1);
}

uint64_t boost::detail::lexical_istream_limited_src<char,std::char_traits<char>,true,2ul>::lexical_istream_limited_src(uint64_t a1)
{
  uint64_t v2;

  *(_QWORD *)(a1 + 96) = 0;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  std::streambuf::basic_streambuf();
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_DWORD *)(a1 + 96) = 24;
  *(_QWORD *)(a1 + 24) = 0;
  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)a1 = off_2511D2A70;
  v2 = MEMORY[0x24BEDB828];
  *(_QWORD *)(a1 + 112) = MEMORY[0x24BEDB828] + 64;
  *(_QWORD *)(a1 + 104) = v2 + 24;
  std::ios_base::init((std::ios_base *)(a1 + 112), (void *)a1);
  *(_QWORD *)(a1 + 248) = 0;
  *(_DWORD *)(a1 + 256) = -1;
  *(_QWORD *)(a1 + 272) = a1 + 264;
  *(_QWORD *)(a1 + 280) = a1 + 266;
  return a1;
}

uint64_t boost::detail::basic_unlockedbuf<std::stringbuf,char>::~basic_unlockedbuf(uint64_t a1)
{
  *(_QWORD *)a1 = MEMORY[0x24BEDB848] + 16;
  if (*(char *)(a1 + 87) < 0)
    operator delete(*(void **)(a1 + 64));
  return std::streambuf::~streambuf();
}

void boost::detail::basic_unlockedbuf<std::stringbuf,char>::~basic_unlockedbuf(uint64_t a1)
{
  *(_QWORD *)a1 = MEMORY[0x24BEDB848] + 16;
  if (*(char *)(a1 + 87) < 0)
    operator delete(*(void **)(a1 + 64));
  std::streambuf::~streambuf();
  JUMPOUT(0x2426A04D4);
}

_QWORD *boost::detail::basic_pointerbuf<char,std::stringbuf>::setbuf(_QWORD *result, uint64_t a2, uint64_t a3)
{
  result[2] = a2;
  result[3] = a2;
  result[4] = a2 + a3;
  return result;
}

double boost::detail::basic_pointerbuf<char,std::stringbuf>::seekoff@<D0>(_QWORD *a1@<X0>, uint64_t a2@<X1>, int a3@<W2>, char a4@<W3>, uint64_t a5@<X8>)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  double result;

  if ((a4 & 0x10) != 0)
  {
    v7 = -1;
    goto LABEL_19;
  }
  v5 = a1[2];
  v6 = a1[4] - v5;
  if (!a3)
  {
    v7 = -1;
    if (a2 < 0 || v6 < a2)
      goto LABEL_19;
    v9 = v5 + a2;
LABEL_15:
    v8 = a1[4];
    goto LABEL_16;
  }
  if (a3 == 1)
  {
    v7 = -1;
    v10 = a1[3] - v5 + a2;
    if (v10 < 0 || v10 > v6)
      goto LABEL_19;
    v9 = a1[3] + a2;
    goto LABEL_15;
  }
  if (a3 != 2)
  {
    v9 = a1[3];
    goto LABEL_18;
  }
  v7 = -1;
  if ((a2 & 0x8000000000000000) == 0 && v6 >= a2)
  {
    v8 = a1[4];
    v9 = v8 - a2;
LABEL_16:
    a1[3] = v9;
    a1[4] = v8;
LABEL_18:
    v7 = v9 - v5;
  }
LABEL_19:
  result = 0.0;
  *(_OWORD *)(a5 + 96) = 0u;
  *(_OWORD *)(a5 + 112) = 0u;
  *(_OWORD *)(a5 + 64) = 0u;
  *(_OWORD *)(a5 + 80) = 0u;
  *(_OWORD *)(a5 + 32) = 0u;
  *(_OWORD *)(a5 + 48) = 0u;
  *(_OWORD *)a5 = 0u;
  *(_OWORD *)(a5 + 16) = 0u;
  *(_QWORD *)(a5 + 128) = v7;
  return result;
}

double boost::detail::basic_pointerbuf<char,std::stringbuf>::seekpos@<D0>(_QWORD *a1@<X0>, uint64_t a2@<X1>, char a3@<W2>, uint64_t a4@<X8>)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  double result;

  if ((a3 & 0x10) == 0)
  {
    v4 = a1[2];
    v5 = *(_QWORD *)(a2 + 128);
    if (v5 <= a1[4] - v4)
    {
      v6 = v4 + v5;
      v7 = a1[4];
      a1[3] = v6;
      a1[4] = v7;
    }
  }
  result = 0.0;
  *(_OWORD *)(a4 + 96) = 0u;
  *(_OWORD *)(a4 + 112) = 0u;
  *(_OWORD *)(a4 + 64) = 0u;
  *(_OWORD *)(a4 + 80) = 0u;
  *(_OWORD *)(a4 + 32) = 0u;
  *(_OWORD *)(a4 + 48) = 0u;
  *(_OWORD *)a4 = 0u;
  *(_OWORD *)(a4 + 16) = 0u;
  *(_QWORD *)(a4 + 128) = -1;
  return result;
}

__n128 boost::detail::lexical_istream_limited_src<char,std::char_traits<char>,true,2ul>::shl_input_streamable<boost::uuids::uuid const>(__n128 *a1)
{
  uint64_t *v2;
  std::ios_base *v3;
  __n128 result;

  v2 = &a1[6].n128_i64[1];
  v3 = (std::ios_base *)&a1[6].n128_i8[*(_QWORD *)(a1[6].n128_u64[1] - 24) + 8];
  v3->__exceptions_ = 1;
  std::ios_base::clear(v3, v3->__rdstate_);
  boost::uuids::operator<<<char,std::char_traits<char>>(v2);
  result = *(__n128 *)(*(uint64_t *)((char *)v2 + *(_QWORD *)(a1[6].n128_u64[1] - 24) + 40) + 40);
  a1[17] = result;
  return result;
}

uint64_t *boost::uuids::operator<<<char,std::char_traits<char>>(uint64_t *a1)
{
  std::ios_base *v2;
  std::ios_base::fmtflags fmtflags;
  uint64_t v4;
  char *v5;
  uint64_t v6;
  const std::ios_base *v7;
  std::ios_base::fmtflags v8;
  std::ios_base::fmtflags v9;
  const std::locale::facet *v10;
  uint64_t v11;
  uint64_t v12;
  const std::ios_base *v13;
  const std::locale::facet *v14;
  std::ios_base::fmtflags v15;
  const std::locale::facet *v16;
  std::ios_base::fmtflags v17;
  unint64_t v18;
  std::locale::id *v19;
  const std::locale::facet *v20;
  char v21;
  uint64_t v22;
  char v24;
  uint64_t v25;
  std::ios_base::fmtflags v26;
  std::ios_base *v27;
  _BYTE v28[16];
  _BYTE v29[16];
  std::locale v30;

  v2 = (std::ios_base *)((char *)a1 + *(_QWORD *)(*a1 - 24));
  fmtflags = v2->__fmtflags_;
  boost::io::basic_ios_fill_saver<char,std::char_traits<char>>::basic_ios_fill_saver((uint64_t)v29, v2);
  MEMORY[0x2426A0330](v28, a1);
  if (v28[0])
  {
    v26 = fmtflags;
    v27 = v2;
    v4 = *a1;
    v5 = (char *)a1 + *(_QWORD *)(*a1 - 24);
    v6 = *((_QWORD *)v5 + 3);
    *((_QWORD *)v5 + 3) = 0;
    v7 = (const std::ios_base *)((char *)a1 + *(_QWORD *)(v4 - 24));
    v8 = v7->__fmtflags_;
    v9 = v7[1].__fmtflags_;
    if (v9 == -1)
    {
      std::ios_base::getloc(v7);
      v10 = std::locale::use_facet(&v30, MEMORY[0x24BEDB350]);
      v9 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v10->__vftable[2].~facet_0)(v10, 32);
      std::locale::~locale(&v30);
      v7[1].__fmtflags_ = v9;
    }
    if ((v8 & 0x90) != 0 && v6 >= 37)
    {
      v11 = v6 - 36;
      do
      {
        LOBYTE(v30.__locale_) = v9;
        std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a1, (uint64_t)&v30, 1);
        --v11;
      }
      while (v11);
    }
    v12 = *a1;
    *(_DWORD *)((char *)a1 + *(_QWORD *)(*a1 - 24) + 8) = *(_DWORD *)((_BYTE *)a1 + *(_QWORD *)(*a1 - 24) + 8) & 0xFFFFFFB5 | 8;
    *(_DWORD *)((char *)a1 + *(_QWORD *)(v12 - 24) + 8) = *(_DWORD *)((_BYTE *)a1 + *(_QWORD *)(v12 - 24) + 8) & 0xFFFFFF4F | 0x80;
    v13 = (const std::ios_base *)((char *)a1 + *(_QWORD *)(v12 - 24));
    std::ios_base::getloc(v13);
    v24 = v8;
    v25 = v6;
    v14 = std::locale::use_facet(&v30, MEMORY[0x24BEDB350]);
    v15 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v14->__vftable[2].~facet_0)(v14, 48);
    std::locale::~locale(&v30);
    if (v13[1].__fmtflags_ == -1)
    {
      std::ios_base::getloc(v13);
      v16 = std::locale::use_facet(&v30, MEMORY[0x24BEDB350]);
      v17 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v16->__vftable[2].~facet_0)(v16, 32);
      std::locale::~locale(&v30);
      v13[1].__fmtflags_ = v17;
    }
    v18 = 0;
    v13[1].__fmtflags_ = v15;
    v19 = (std::locale::id *)MEMORY[0x24BEDB350];
    do
    {
      *(uint64_t *)((char *)a1 + *(_QWORD *)(*a1 - 24) + 24) = 2;
      std::ostream::operator<<();
      if (v18 <= 9 && ((1 << v18) & 0x2A8) != 0)
      {
        std::ios_base::getloc((const std::ios_base *)((char *)a1 + *(_QWORD *)(*a1 - 24)));
        v20 = std::locale::use_facet(&v30, v19);
        v21 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v20->__vftable[2].~facet_0)(v20, 45);
        std::locale::~locale(&v30);
        LOBYTE(v30.__locale_) = v21;
        std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a1, (uint64_t)&v30, 1);
      }
      ++v18;
    }
    while (v18 != 16);
    if ((v24 & 0x20) != 0 && v25 >= 37)
    {
      v22 = v25 - 36;
      do
      {
        LOBYTE(v30.__locale_) = v9;
        std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a1, (uint64_t)&v30, 1);
        --v22;
      }
      while (v22);
    }
    *(uint64_t *)((char *)a1 + *(_QWORD *)(*a1 - 24) + 24) = 0;
    v2 = v27;
    fmtflags = v26;
  }
  MEMORY[0x2426A033C](v28);
  boost::io::basic_ios_fill_saver<char,std::char_traits<char>>::restore((uint64_t)v29);
  v2->__fmtflags_ = fmtflags;
  return a1;
}

void sub_2419F5834(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, int a12, int a13, uint64_t a14, char a15, uint64_t a16, char a17, uint64_t a18, std::locale a19)
{
  std::locale::~locale(&a19);
  MEMORY[0x2426A033C](&a15);
  boost::io::basic_ios_fill_saver<char,std::char_traits<char>>::restore((uint64_t)&a17);
  *(_DWORD *)(a14 + 8) = a13;
  _Unwind_Resume(a1);
}

uint64_t boost::io::basic_ios_fill_saver<char,std::char_traits<char>>::basic_ios_fill_saver(uint64_t a1, std::ios_base *this)
{
  std::ios_base::fmtflags fmtflags;
  const std::locale::facet *v5;
  std::locale v7;

  *(_QWORD *)a1 = this;
  fmtflags = this[1].__fmtflags_;
  if (fmtflags == -1)
  {
    std::ios_base::getloc(this);
    v5 = std::locale::use_facet(&v7, MEMORY[0x24BEDB350]);
    fmtflags = ((uint64_t (*)(const std::locale::facet *, uint64_t))v5->__vftable[2].~facet_0)(v5, 32);
    std::locale::~locale(&v7);
    this[1].__fmtflags_ = fmtflags;
  }
  *(_BYTE *)(a1 + 8) = fmtflags;
  return a1;
}

void sub_2419F5930(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::locale a10)
{
  std::locale::~locale(&a10);
  _Unwind_Resume(a1);
}

_QWORD *std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  int v8;
  int v9;
  const std::locale::facet *v10;
  uint64_t v11;
  _BYTE v13[16];
  std::locale v14;

  MEMORY[0x2426A0330](v13, a1);
  if (v13[0])
  {
    v6 = (uint64_t)a1 + *(_QWORD *)(*a1 - 24);
    v7 = *(_QWORD *)(v6 + 40);
    v8 = *(_DWORD *)(v6 + 8);
    v9 = *(_DWORD *)(v6 + 144);
    if (v9 == -1)
    {
      std::ios_base::getloc((const std::ios_base *)((char *)a1 + *(_QWORD *)(*a1 - 24)));
      v10 = std::locale::use_facet(&v14, MEMORY[0x24BEDB350]);
      v9 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v10->__vftable[2].~facet_0)(v10, 32);
      std::locale::~locale(&v14);
      *(_DWORD *)(v6 + 144) = v9;
    }
    if ((v8 & 0xB0) == 0x20)
      v11 = a2 + a3;
    else
      v11 = a2;
    if (!std::__pad_and_output[abi:ne180100]<char,std::char_traits<char>>(v7, a2, v11, a2 + a3, v6, (char)v9))
      std::ios_base::clear((std::ios_base *)((char *)a1 + *(_QWORD *)(*a1 - 24)), *(_DWORD *)((char *)a1 + *(_QWORD *)(*a1 - 24) + 32) | 5);
  }
  MEMORY[0x2426A033C](v13);
  return a1;
}

void sub_2419F5A4C(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, std::locale a12)
{
  _QWORD *v12;

  MEMORY[0x2426A033C](&a10);
  __cxa_begin_catch(a1);
  std::ios_base::__set_badbit_and_consider_rethrow((std::ios_base *)((char *)v12 + *(_QWORD *)(*v12 - 24)));
  __cxa_end_catch();
  JUMPOUT(0x2419F5A2CLL);
}

void sub_2419F5A94(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

uint64_t std::__pad_and_output[abi:ne180100]<char,std::char_traits<char>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int __c)
{
  uint64_t v6;
  uint64_t v11;
  int64_t v12;
  void **v13;
  uint64_t v14;
  uint64_t v15;
  void *__p[2];
  char v18;

  v6 = a1;
  if (a1)
  {
    v11 = *(_QWORD *)(a5 + 24);
    if (v11 <= a4 - a2)
      v12 = 0;
    else
      v12 = v11 - (a4 - a2);
    if (a3 - a2 >= 1 && (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 96))(a1) != a3 - a2)
      return 0;
    if (v12 >= 1)
    {
      std::string::basic_string[abi:ne180100](__p, v12, __c);
      v13 = v18 >= 0 ? __p : (void **)__p[0];
      v14 = (*(uint64_t (**)(uint64_t, void **, int64_t))(*(_QWORD *)v6 + 96))(v6, v13, v12);
      if (v18 < 0)
        operator delete(__p[0]);
      if (v14 != v12)
        return 0;
    }
    v15 = a4 - a3;
    if (v15 < 1 || (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v6 + 96))(v6, a3, v15) == v15)
      *(_QWORD *)(a5 + 24) = 0;
    else
      return 0;
  }
  return v6;
}

void sub_2419F5BC8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void boost::io::basic_ios_fill_saver<char,std::char_traits<char>>::restore(uint64_t a1)
{
  const std::ios_base *v1;
  std::ios_base::fmtflags v2;
  const std::locale::facet *v3;
  std::ios_base::fmtflags v4;
  std::locale v5;

  v1 = *(const std::ios_base **)a1;
  v2 = *(char *)(a1 + 8);
  if (*(_DWORD *)(*(_QWORD *)a1 + 144) == -1)
  {
    std::ios_base::getloc(*(const std::ios_base **)a1);
    v3 = std::locale::use_facet(&v5, MEMORY[0x24BEDB350]);
    v4 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v3->__vftable[2].~facet_0)(v3, 32);
    std::locale::~locale(&v5);
    v1[1].__fmtflags_ = v4;
  }
  v1[1].__fmtflags_ = v2;
}

void sub_2419F5C60(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::locale a10)
{
  std::locale::~locale(&a10);
  _Unwind_Resume(a1);
}

void std::string::__assign_trivial[abi:ne180100]<char const*,char const*>(std::string *this, std::string::value_type *a2, std::string::value_type *a3, std::string::size_type a4)
{
  std::string *v8;
  std::string::size_type size;
  std::string::size_type v10;
  unint64_t v11;
  unint64_t v12;
  std::string::value_type v13;

  if ((SHIBYTE(this->__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    v8 = this;
    if (a4 <= 0x16)
      goto LABEL_11;
    size = HIBYTE(this->__r_.__value_.__r.__words[2]);
    v10 = 22;
    goto LABEL_6;
  }
  v11 = this->__r_.__value_.__r.__words[2];
  v10 = (v11 & 0x7FFFFFFFFFFFFFFFLL) - 1;
  if (v10 < a4)
  {
    size = this->__r_.__value_.__l.__size_;
LABEL_6:
    std::string::__grow_by(this, v10, a4 - v10, size, 0, size, 0);
    this->__r_.__value_.__l.__size_ = 0;
    LOBYTE(v12) = *((_BYTE *)&this->__r_.__value_.__s + 23);
    goto LABEL_8;
  }
  v12 = HIBYTE(v11);
LABEL_8:
  v8 = this;
  if ((v12 & 0x80) != 0)
    v8 = (std::string *)this->__r_.__value_.__r.__words[0];
LABEL_11:
  while (a2 != a3)
  {
    v13 = *a2++;
    v8->__r_.__value_.__s.__data_[0] = v13;
    v8 = (std::string *)((char *)v8 + 1);
  }
  v8->__r_.__value_.__s.__data_[0] = 0;
  if (SHIBYTE(this->__r_.__value_.__r.__words[2]) < 0)
    this->__r_.__value_.__l.__size_ = a4;
  else
    *((_BYTE *)&this->__r_.__value_.__s + 23) = a4 & 0x7F;
}

void boost::throw_exception<boost::bad_lexical_cast>(uint64_t a1)
{
  __n128 *exception;

  exception = (__n128 *)__cxa_allocate_exception(0x48uLL);
  boost::wrapexcept<boost::bad_lexical_cast>::wrapexcept(exception, a1);
}

void sub_2419F5D7C(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

__n128 boost::wrapexcept<boost::bad_lexical_cast>::wrapexcept(__n128 *a1, uint64_t a2)
{
  __n128 result;

  a1->n128_u64[0] = (unint64_t)&unk_2511D29D0;
  a1->n128_u64[1] = (unint64_t)&unk_2511D2C18;
  result = *(__n128 *)(a2 + 8);
  a1[1] = result;
  a1[3].n128_u64[0] = 0;
  a1[3].n128_u64[1] = 0;
  a1[4].n128_u32[0] = -1;
  a1->n128_u64[0] = (unint64_t)&unk_2511D2BA0;
  a1->n128_u64[1] = (unint64_t)&unk_2511D2BD0;
  a1[2].n128_u64[0] = (unint64_t)&unk_2511D2BF8;
  a1[2].n128_u64[1] = 0;
  return result;
}

uint64_t boost::wrapexcept<boost::bad_lexical_cast>::~wrapexcept(uint64_t a1)
{
  *(_QWORD *)(a1 + 32) = &unk_2511D2A30;
  boost::exception_detail::refcount_ptr<boost::exception_detail::error_info_container>::~refcount_ptr((uint64_t *)(a1 + 40));
  std::exception::~exception((std::exception *)(a1 + 8));
  return a1;
}

uint64_t boost::wrapexcept<boost::bad_lexical_cast>::clone(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;

  v2 = operator new();
  *(_QWORD *)v2 = &unk_2511D29D0;
  *(_QWORD *)(v2 + 8) = &unk_2511D2C18;
  *(_OWORD *)(v2 + 16) = *(_OWORD *)(a1 + 16);
  *(_QWORD *)(v2 + 32) = &unk_2511D2A30;
  v3 = *(_QWORD *)(a1 + 40);
  *(_QWORD *)(v2 + 40) = v3;
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 24))(v3);
  *(_OWORD *)(v2 + 48) = *(_OWORD *)(a1 + 48);
  *(_DWORD *)(v2 + 64) = *(_DWORD *)(a1 + 64);
  *(_QWORD *)v2 = &unk_2511D2BA0;
  *(_QWORD *)(v2 + 8) = &unk_2511D2BD0;
  *(_QWORD *)(v2 + 32) = &unk_2511D2BF8;
  boost::exception_detail::copy_boost_exception(v2 + 32, a1 + 32);
  return v2;
}

void sub_2419F5EF8(_Unwind_Exception *a1)
{
  uint64_t v1;
  std::exception *v2;

  std::exception::~exception(v2);
  MEMORY[0x2426A04D4](v1, 0x10F1C405FFD4875);
  _Unwind_Resume(a1);
}

void boost::wrapexcept<boost::bad_lexical_cast>::rethrow(uint64_t a1)
{
  void *exception;

  exception = __cxa_allocate_exception(0x48uLL);
  boost::wrapexcept<boost::bad_lexical_cast>::wrapexcept((uint64_t)exception, a1);
}

void sub_2419F5F78(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void boost::wrapexcept<boost::bad_lexical_cast>::~wrapexcept(uint64_t a1)
{
  *(_QWORD *)(a1 + 32) = &unk_2511D2A30;
  boost::exception_detail::refcount_ptr<boost::exception_detail::error_info_container>::~refcount_ptr((uint64_t *)(a1 + 40));
  std::exception::~exception((std::exception *)(a1 + 8));
  JUMPOUT(0x2426A04D4);
}

void `non-virtual thunk to'boost::wrapexcept<boost::bad_lexical_cast>::~wrapexcept(uint64_t a1)
{
  *(_QWORD *)(a1 + 24) = &unk_2511D2A30;
  boost::exception_detail::refcount_ptr<boost::exception_detail::error_info_container>::~refcount_ptr((uint64_t *)(a1 + 32));
  std::exception::~exception((std::exception *)a1);
}

{
  *(_QWORD *)(a1 + 24) = &unk_2511D2A30;
  boost::exception_detail::refcount_ptr<boost::exception_detail::error_info_container>::~refcount_ptr((uint64_t *)(a1 + 32));
  std::exception::~exception((std::exception *)a1);
  JUMPOUT(0x2426A04D4);
}

const char *boost::bad_lexical_cast::what(boost::bad_lexical_cast *this)
{
  return "bad lexical cast: source type value could not be interpreted as target";
}

void `non-virtual thunk to'boost::wrapexcept<boost::bad_lexical_cast>::~wrapexcept(_QWORD *a1)
{
  *a1 = &unk_2511D2A30;
  boost::exception_detail::refcount_ptr<boost::exception_detail::error_info_container>::~refcount_ptr(a1 + 1);
  std::exception::~exception((std::exception *)a1 - 3);
}

{
  *a1 = &unk_2511D2A30;
  boost::exception_detail::refcount_ptr<boost::exception_detail::error_info_container>::~refcount_ptr(a1 + 1);
  std::exception::~exception((std::exception *)a1 - 3);
  JUMPOUT(0x2426A04D4);
}

void boost::bad_lexical_cast::~bad_lexical_cast(std::exception *this)
{
  std::exception::~exception(this);
  JUMPOUT(0x2426A04D4);
}

uint64_t boost::wrapexcept<boost::bad_lexical_cast>::wrapexcept(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  __int128 v5;

  *(_QWORD *)a1 = &unk_2511D29D0;
  *(_QWORD *)(a1 + 8) = &unk_2511D2C18;
  *(_OWORD *)(a1 + 16) = *(_OWORD *)(a2 + 16);
  v4 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a1 + 32) = &unk_2511D2A30;
  *(_QWORD *)(a1 + 40) = v4;
  if (v4)
    (*(void (**)(uint64_t))(*(_QWORD *)v4 + 24))(v4);
  v5 = *(_OWORD *)(a2 + 48);
  *(_DWORD *)(a1 + 64) = *(_DWORD *)(a2 + 64);
  *(_OWORD *)(a1 + 48) = v5;
  *(_QWORD *)a1 = &unk_2511D2BA0;
  *(_QWORD *)(a1 + 8) = &unk_2511D2BD0;
  *(_QWORD *)(a1 + 32) = &unk_2511D2BF8;
  return a1;
}

void sub_2419F61CC(_Unwind_Exception *a1)
{
  std::exception *v1;

  std::exception::~exception(v1);
  _Unwind_Resume(a1);
}

_QWORD *std::vector<CLMicroLocationWiFiChannelHistogram>::__init_with_size[abi:ne180100]<CLMicroLocationWiFiChannelHistogram*,CLMicroLocationWiFiChannelHistogram*>(_QWORD *result, const void *a2, uint64_t a3, unint64_t a4)
{
  _QWORD *v6;
  uint64_t v7;
  size_t v8;

  if (a4)
  {
    v6 = result;
    result = std::vector<CLMicroLocationWiFiChannelHistogram>::__vallocate[abi:ne180100](result, a4);
    v7 = v6[1];
    v8 = a3 - (_QWORD)a2;
    if (v8)
      result = memmove((void *)v6[1], a2, v8);
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_2419F623C(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *std::vector<CLMicroLocationWiFiChannelHistogram>::__vallocate[abi:ne180100](_QWORD *a1, unint64_t a2)
{
  char *result;
  uint64_t v4;

  if (a2 >> 61)
    std::vector<CLMicroLocationProto::ConfidenceReason>::__throw_length_error[abi:ne180100]();
  result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<CLMicroLocationWiFiChannelHistogram>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[8 * v4];
  return result;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<CLMicroLocationWiFiChannelHistogram>>(uint64_t a1, unint64_t a2)
{
  if (a2 >> 61)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(8 * a2);
}

void std::vector<CLMicroLocationAssociatedStateTable::Entry>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v2;

  v2 = *a1;
  if (*v2)
  {
    std::vector<CLMicroLocationAssociatedStateTable::Entry>::__clear[abi:ne180100]((uint64_t *)v2);
    operator delete(**a1);
  }
}

void std::vector<CLMicroLocationAssociatedStateTable::Entry>::__clear[abi:ne180100](uint64_t *a1)
{
  uint64_t v2;
  uint64_t i;

  v2 = *a1;
  for (i = a1[1]; i != v2; i -= 72)
  {
    if (*(char *)(i - 49) < 0)
      operator delete(*(void **)(i - 72));
  }
  a1[1] = v2;
}

uint64_t std::vector<CLMicroLocationAssociatedStateTable::Entry>::__emplace_back_slow_path<std::string const&,boost::uuids::uuid const&,std::chrono::time_point<cl::chrono::CFAbsoluteTimeClock,std::chrono::duration<long double,std::ratio<1l,1l>>>,BOOL,CLMacAddress,CLMicroLocationAssociatedStateTable::Entry::Band &,unsigned long>(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned __int8 *a5, uint64_t a6, unsigned int *a7, unsigned int *a8)
{
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v19;
  unint64_t v20;
  unint64_t v21;
  char *v22;
  uint64_t v23;
  char *v25;
  char *v26;
  char *v27;
  char *v28;
  uint64_t *v29;

  v9 = *a1;
  v10 = 0x8E38E38E38E38E39 * ((a1[1] - *a1) >> 3);
  v11 = v10 + 1;
  if (v10 + 1 > 0x38E38E38E38E38ELL)
    std::vector<CLMicroLocationProto::ConfidenceReason>::__throw_length_error[abi:ne180100]();
  v19 = (uint64_t)(a1 + 2);
  v20 = 0x8E38E38E38E38E39 * ((a1[2] - v9) >> 3);
  if (2 * v20 > v11)
    v11 = 2 * v20;
  if (v20 >= 0x1C71C71C71C71C7)
    v21 = 0x38E38E38E38E38ELL;
  else
    v21 = v11;
  v29 = a1 + 2;
  if (v21)
    v22 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<CLMicroLocationAssociatedStateTable::Entry>>(v19, v21);
  else
    v22 = 0;
  v25 = v22;
  v26 = &v22[72 * v10];
  v27 = v26;
  v28 = &v22[72 * v21];
  CLMicroLocationAssociatedStateTable::Entry::Entry(v26, a2, a3, a4, *a5, a6, *a7, *a8);
  v27 = v26 + 72;
  std::vector<CLMicroLocationAssociatedStateTable::Entry>::__swap_out_circular_buffer(a1, &v25);
  v23 = a1[1];
  std::__split_buffer<CLMicroLocationAssociatedStateTable::Entry>::~__split_buffer((uint64_t)&v25);
  return v23;
}

void sub_2419F64A8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__split_buffer<CLMicroLocationAssociatedStateTable::Entry>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t std::vector<CLMicroLocationAssociatedStateTable::Entry>::__swap_out_circular_buffer(uint64_t *a1, _QWORD *a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<CLMicroLocationAssociatedStateTable::Entry>,std::reverse_iterator<CLMicroLocationAssociatedStateTable::Entry*>,std::reverse_iterator<CLMicroLocationAssociatedStateTable::Entry*>,std::reverse_iterator<CLMicroLocationAssociatedStateTable::Entry*>>((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<CLMicroLocationAssociatedStateTable::Entry>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x38E38E38E38E38FLL)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(72 * a2);
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<CLMicroLocationAssociatedStateTable::Entry>,std::reverse_iterator<CLMicroLocationAssociatedStateTable::Entry*>,std::reverse_iterator<CLMicroLocationAssociatedStateTable::Entry*>,std::reverse_iterator<CLMicroLocationAssociatedStateTable::Entry*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7;
  uint64_t v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  _QWORD v14[3];
  char v15;
  __int128 v16;
  __int128 v17;

  v7 = a7;
  *(_QWORD *)&v17 = a6;
  *((_QWORD *)&v17 + 1) = a7;
  v16 = v17;
  v14[0] = a1;
  v14[1] = &v16;
  v14[2] = &v17;
  if (a3 != a5)
  {
    v9 = a7;
    do
    {
      v10 = *(_OWORD *)(a3 - 72);
      *(_QWORD *)(v9 - 56) = *(_QWORD *)(a3 - 56);
      *(_OWORD *)(v9 - 72) = v10;
      *(_QWORD *)(a3 - 64) = 0;
      *(_QWORD *)(a3 - 56) = 0;
      *(_QWORD *)(a3 - 72) = 0;
      v11 = *(_OWORD *)(a3 - 48);
      v12 = *(_OWORD *)(a3 - 16);
      *(_OWORD *)(v9 - 32) = *(_OWORD *)(a3 - 32);
      *(_OWORD *)(v9 - 16) = v12;
      *(_OWORD *)(v9 - 48) = v11;
      v9 -= 72;
      v7 -= 72;
      a3 -= 72;
    }
    while (a3 != a5);
    *((_QWORD *)&v17 + 1) = v9;
  }
  v15 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<CLMicroLocationAssociatedStateTable::Entry>,std::reverse_iterator<CLMicroLocationAssociatedStateTable::Entry*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v14);
  return a6;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<CLMicroLocationAssociatedStateTable::Entry>,std::reverse_iterator<CLMicroLocationAssociatedStateTable::Entry*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24))
    std::_AllocatorDestroyRangeReverse<std::allocator<CLMicroLocationAssociatedStateTable::Entry>,std::reverse_iterator<CLMicroLocationAssociatedStateTable::Entry*>>::operator()[abi:ne180100](a1);
  return a1;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<CLMicroLocationAssociatedStateTable::Entry>,std::reverse_iterator<CLMicroLocationAssociatedStateTable::Entry*>>::operator()[abi:ne180100](uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;

  v1 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 8);
  v2 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8);
  while (v1 != v2)
  {
    if (*(char *)(v1 + 23) < 0)
      operator delete(*(void **)v1);
    v1 += 72;
  }
}

uint64_t std::__split_buffer<CLMicroLocationAssociatedStateTable::Entry>::~__split_buffer(uint64_t a1)
{
  std::__split_buffer<CLMicroLocationAssociatedStateTable::Entry>::__destruct_at_end[abi:ne180100](a1, *(void ***)(a1 + 8));
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

void std::__split_buffer<CLMicroLocationAssociatedStateTable::Entry>::__destruct_at_end[abi:ne180100](uint64_t a1, void **a2)
{
  void **v2;
  void **v5;

  v2 = *(void ***)(a1 + 16);
  if (v2 != a2)
  {
    do
    {
      v5 = v2 - 9;
      *(_QWORD *)(a1 + 16) = v2 - 9;
      if (*((char *)v2 - 49) < 0)
      {
        operator delete(*v5);
        v5 = *(void ***)(a1 + 16);
      }
      v2 = v5;
    }
    while (v5 != a2);
  }
}

char *std::vector<CLMicroLocationWiFiChannelHistogram>::__assign_with_size[abi:ne180100]<CLMicroLocationWiFiChannelHistogram const*,CLMicroLocationWiFiChannelHistogram const*>(char *result, char *__src, uint64_t a3, unint64_t a4)
{
  _QWORD *v7;
  uint64_t v8;
  char *v9;
  uint64_t v10;
  unint64_t v11;
  void **v12;
  char *v13;
  _BYTE *v14;
  unint64_t v15;
  char *v16;
  size_t v17;
  void *v18;
  char *v19;

  v7 = result;
  v8 = *((_QWORD *)result + 2);
  v9 = *(char **)result;
  if (a4 > (v8 - *(_QWORD *)result) >> 3)
  {
    if (v9)
    {
      *((_QWORD *)result + 1) = v9;
      operator delete(v9);
      v8 = 0;
      *v7 = 0;
      v7[1] = 0;
      v7[2] = 0;
    }
    if (a4 >> 61)
      std::vector<CLMicroLocationProto::ConfidenceReason>::__throw_length_error[abi:ne180100]();
    v10 = v8 >> 2;
    if (v8 >> 2 <= a4)
      v10 = a4;
    if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF8)
      v11 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v11 = v10;
    result = std::vector<CLMicroLocationWiFiChannelHistogram>::__vallocate[abi:ne180100](v7, v11);
    v13 = (char *)v7[1];
    v12 = (void **)(v7 + 1);
    v9 = v13;
LABEL_16:
    v17 = a3 - (_QWORD)__src;
    if (v17)
    {
      v18 = v9;
      v19 = __src;
      goto LABEL_18;
    }
    goto LABEL_19;
  }
  v12 = (void **)(result + 8);
  v14 = (_BYTE *)*((_QWORD *)result + 1);
  v15 = (v14 - v9) >> 3;
  if (v15 >= a4)
    goto LABEL_16;
  v16 = &__src[8 * v15];
  if (v14 != v9)
  {
    result = (char *)memmove(*(void **)result, __src, v14 - v9);
    v9 = (char *)*v12;
  }
  v17 = a3 - (_QWORD)v16;
  if (v17)
  {
    v18 = v9;
    v19 = v16;
LABEL_18:
    result = (char *)memmove(v18, v19, v17);
  }
LABEL_19:
  *v12 = &v9[v17];
  return result;
}

_QWORD *std::vector<CLMicroLocationRapportMonitor::Item>::__init_with_size[abi:ne180100]<std::__hash_const_iterator<std::__hash_node<CLMicroLocationRapportMonitor::Item,void *> *>,std::__hash_const_iterator<std::__hash_node<CLMicroLocationRapportMonitor::Item,void *> *>>(_QWORD *result, _QWORD *a2, _QWORD *a3, unint64_t a4)
{
  _QWORD *v6;

  if (a4)
  {
    v6 = result;
    std::vector<CLMicroLocationRapportMonitor::Item>::__vallocate[abi:ne180100](result, a4);
    result = (_QWORD *)std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<CLMicroLocationRapportMonitor::Item>,std::__hash_const_iterator<std::__hash_node<CLMicroLocationRapportMonitor::Item,void *> *>,std::__hash_const_iterator<std::__hash_node<CLMicroLocationRapportMonitor::Item,void *> *>,CLMicroLocationRapportMonitor::Item*>((uint64_t)(v6 + 2), a2, a3, v6[1]);
    v6[1] = result;
  }
  return result;
}

void sub_2419F6890(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  uint64_t v9;
  uint64_t v10;

  *(_QWORD *)(v9 + 8) = v10;
  std::vector<CLMicroLocationRapportMonitor::Item>::__destroy_vector::operator()[abi:ne180100](&a9);
  _Unwind_Resume(a1);
}

char *std::vector<CLMicroLocationRapportMonitor::Item>::__vallocate[abi:ne180100](_QWORD *a1, unint64_t a2)
{
  char *result;
  uint64_t v4;

  if (a2 >= 0x333333333333334)
    std::vector<CLMicroLocationProto::ConfidenceReason>::__throw_length_error[abi:ne180100]();
  result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<CLMicroLocationRapportMonitor::Item>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[80 * v4];
  return result;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<CLMicroLocationRapportMonitor::Item>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x333333333333334)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(80 * a2);
}

uint64_t std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<CLMicroLocationRapportMonitor::Item>,std::__hash_const_iterator<std::__hash_node<CLMicroLocationRapportMonitor::Item,void *> *>,std::__hash_const_iterator<std::__hash_node<CLMicroLocationRapportMonitor::Item,void *> *>,CLMicroLocationRapportMonitor::Item*>(uint64_t a1, _QWORD *a2, _QWORD *a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD *v6;
  _QWORD v9[3];
  char v10;
  uint64_t v11;
  uint64_t v12;

  v4 = a4;
  v11 = a4;
  v12 = a4;
  v9[0] = a1;
  v9[1] = &v11;
  v9[2] = &v12;
  v10 = 0;
  if (a2 != a3)
  {
    v6 = a2;
    do
    {
      std::allocator<CLMicroLocationRapportMonitor::Item>::construct[abi:ne180100]<CLMicroLocationRapportMonitor::Item,CLMicroLocationRapportMonitor::Item const&>(a1, v4, (uint64_t)(v6 + 2));
      v6 = (_QWORD *)*v6;
      v4 = v12 + 80;
      v12 += 80;
    }
    while (v6 != a3);
  }
  v10 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<CLMicroLocationRapportMonitor::Item>,CLMicroLocationRapportMonitor::Item*>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v9);
  return v4;
}

void sub_2419F69D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<CLMicroLocationRapportMonitor::Item>,CLMicroLocationRapportMonitor::Item*>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

__n128 std::allocator<CLMicroLocationRapportMonitor::Item>::construct[abi:ne180100]<CLMicroLocationRapportMonitor::Item,CLMicroLocationRapportMonitor::Item const&>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  std::string *v5;
  __int128 v6;
  std::string *v7;
  __int128 v8;
  __n128 result;

  *(_OWORD *)a2 = *(_OWORD *)a3;
  v5 = (std::string *)(a2 + 16);
  if (*(char *)(a3 + 39) < 0)
  {
    std::string::__init_copy_ctor_external(v5, *(const std::string::value_type **)(a3 + 16), *(_QWORD *)(a3 + 24));
  }
  else
  {
    v6 = *(_OWORD *)(a3 + 16);
    *(_QWORD *)(a2 + 32) = *(_QWORD *)(a3 + 32);
    *(_OWORD *)&v5->__r_.__value_.__l.__data_ = v6;
  }
  v7 = (std::string *)(a2 + 40);
  if (*(char *)(a3 + 63) < 0)
  {
    std::string::__init_copy_ctor_external(v7, *(const std::string::value_type **)(a3 + 40), *(_QWORD *)(a3 + 48));
  }
  else
  {
    v8 = *(_OWORD *)(a3 + 40);
    *(_QWORD *)(a2 + 56) = *(_QWORD *)(a3 + 56);
    *(_OWORD *)&v7->__r_.__value_.__l.__data_ = v8;
  }
  result = *(__n128 *)(a3 + 64);
  *(__n128 *)(a2 + 64) = result;
  return result;
}

void sub_2419F6A80(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void **v2;

  if (*(char *)(v1 + 39) < 0)
    operator delete(*v2);
  _Unwind_Resume(exception_object);
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<CLMicroLocationRapportMonitor::Item>,CLMicroLocationRapportMonitor::Item*>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24))
    std::_AllocatorDestroyRangeReverse<std::allocator<CLMicroLocationRapportMonitor::Item>,CLMicroLocationRapportMonitor::Item*>::operator()[abi:ne180100]((uint64_t *)a1);
  return a1;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<CLMicroLocationRapportMonitor::Item>,CLMicroLocationRapportMonitor::Item*>::operator()[abi:ne180100](uint64_t *a1)
{
  uint64_t *v1;
  uint64_t *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  v2 = (uint64_t *)a1[1];
  v1 = (uint64_t *)a1[2];
  v3 = *v1;
  v4 = *v2;
  if (*v1 != *v2)
  {
    v5 = *a1;
    do
    {
      v3 -= 80;
      std::allocator<CLMicroLocationRapportMonitor::Item>::destroy[abi:ne180100](v5, v3);
    }
    while (v3 != v4);
  }
}

void std::allocator<CLMicroLocationRapportMonitor::Item>::destroy[abi:ne180100](uint64_t a1, uint64_t a2)
{
  if (*(char *)(a2 + 63) < 0)
    operator delete(*(void **)(a2 + 40));
  if (*(char *)(a2 + 39) < 0)
    operator delete(*(void **)(a2 + 16));
}

void std::vector<CLMicroLocationRapportMonitor::Item>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v1;
  void *v2;
  uint64_t v4;
  void *v5;

  v1 = *a1;
  v2 = **a1;
  if (v2)
  {
    v4 = (uint64_t)v1[1];
    v5 = **a1;
    if ((void *)v4 != v2)
    {
      do
      {
        v4 -= 80;
        std::allocator<CLMicroLocationRapportMonitor::Item>::destroy[abi:ne180100]((uint64_t)(v1 + 2), v4);
      }
      while ((void *)v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t std::shared_ptr<CLMiLoService::ModelAndConf>::~shared_ptr[abi:ne180100](uint64_t a1)
{
  std::__shared_weak_count *v2;
  unint64_t *p_shared_owners;
  unint64_t v4;

  v2 = *(std::__shared_weak_count **)(a1 + 8);
  if (v2)
  {
    p_shared_owners = (unint64_t *)&v2->__shared_owners_;
    do
      v4 = __ldaxr(p_shared_owners);
    while (__stlxr(v4 - 1, p_shared_owners));
    if (!v4)
    {
      ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
      std::__shared_weak_count::__release_weak(v2);
    }
  }
  return a1;
}

void OUTLINED_FUNCTION_0_0(void *a1, int a2, os_log_t log, const char *a4, uint8_t *a5)
{
  _os_log_impl(a1, log, OS_LOG_TYPE_INFO, a4, a5, 0x30u);
}

void OUTLINED_FUNCTION_2_0(uint64_t a1@<X1>, uint64_t a2@<X8>)
{
  __int16 v2;
  uint64_t v3;

  *(_QWORD *)(a1 + 10) = v3;
  *(_WORD *)(a1 + 18) = v2;
  *(_QWORD *)(a1 + 20) = a2;
  *(_WORD *)(a1 + 28) = v2;
}

void OUTLINED_FUNCTION_3_0(float a1, uint64_t a2, uint64_t a3)
{
  *(float *)a3 = a1;
  *(_DWORD *)(a3 + 4) = 0;
  *(_WORD *)(a3 + 8) = 2082;
}

void sub_2419F7448(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, id location)
{
  id *v20;
  id *v21;

  objc_destroyWeak(v21);
  objc_destroyWeak(v20);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_2419F78B8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, id location)
{
  id *v17;

  objc_destroyWeak(v17);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void CLMicroLocationModel::CLMicroLocationModel(CLMicroLocationModel *this)
{
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  char v6;
  uint64_t v7;
  _BYTE v8[24];
  _BYTE v9[15];
  uint64_t v10;

  v10 = *MEMORY[0x24BDAC8D0];
  *((_DWORD *)this + 3) = 0;
  *(_QWORD *)this = 0;
  *((_BYTE *)this + 8) = 0;
  CLMicroLocationAnchorAppearanceMap::CLMicroLocationAnchorAppearanceMap((CLMicroLocationModel *)((char *)this + 16));
  *((_BYTE *)this + 72) = 0;
  *((_BYTE *)this + 192) = 0;
  *((_BYTE *)this + 200) = 0;
  *((_BYTE *)this + 288) = 0;
  *((_QWORD *)this + 38) = 0;
  *((_QWORD *)this + 39) = 0;
  *((_QWORD *)this + 37) = 0;
  *((_DWORD *)this + 80) = 0;
  *(_OWORD *)((char *)this + 328) = 0u;
  *(_OWORD *)((char *)this + 344) = 0u;
  *(_OWORD *)((char *)this + 360) = 0u;
  *((_QWORD *)this + 47) = 0;
  *((_DWORD *)this + 96) = 1065353216;
  *(_OWORD *)((char *)this + 392) = 0u;
  *(_OWORD *)((char *)this + 408) = 0u;
  +[ULDefaultsSingleton shared](ULDefaultsSingleton, "shared");
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v2, "defaultsDictionary");
  v3 = (void *)objc_claimAutoreleasedReturnValue();

  objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "ULVersion");
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v3, "objectForKey:", v4);
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  if (v5 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
  {
    ULSettings::convert<NSString * {__strong},std::string>(v5, v8);
    *(_OWORD *)((char *)this + 424) = *(_OWORD *)v8;
    *((_QWORD *)this + 55) = *(_QWORD *)&v8[16];
  }
  else
  {
    ULSettings::convert<NSString * {__strong},std::string>(CFSTR("3.0.40"), v8);
    *(_QWORD *)&v9[7] = *(_QWORD *)&v8[15];
    *(_QWORD *)v9 = *(_QWORD *)&v8[8];
    v6 = v8[23];
    v7 = *(_QWORD *)&v8[8];
    *((_QWORD *)this + 53) = *(_QWORD *)v8;
    *((_QWORD *)this + 54) = v7;
    *(_QWORD *)((char *)this + 439) = *(_QWORD *)&v9[7];
    *((_BYTE *)this + 447) = v6;
  }

}

void sub_2419F8774(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  void *v13;
  void *v14;
  void *v15;
  void *v17;

  v17 = *(void **)(v9 + 400);
  if (v17)
  {
    *(_QWORD *)(v9 + 408) = v17;
    operator delete(v17);
  }
  std::__hash_table<std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>>>::~__hash_table(v9 + 352);
  a9 = (void **)(v11 + 256);
  std::vector<std::pair<std::shared_ptr<CLMicroLocationFingerprint>,boost::uuids::uuid>>::__destroy_vector::operator()[abi:ne180100](&a9);
  std::__optional_destruct_base<CLMicroLocationModel::BlueAtlasData,false>::~__optional_destruct_base[abi:ne180100](v12);
  std::__optional_destruct_base<CLMicroLocationModel::SimilarityListData,false>::~__optional_destruct_base[abi:ne180100](v11);
  std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>>>::~__hash_table(v10);
  _Unwind_Resume(a1);
}

void CLMicroLocationModel::toProtobuf(CLMicroLocationModel *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v5;
  uint64_t i;
  int v7;
  uint64_t v8;
  uint64_t v9;
  CLMicroLocationProto::Fingerprint *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  _QWORD *j;
  int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  std::string *v22;
  wireless_diagnostics::google::protobuf::internal::StringTypeHandlerBase *v23;
  uint64_t k;
  uint64_t v25;
  uint64_t v26;
  int v27;
  uint64_t v28;
  uint64_t v29;
  std::string *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  int v34;
  unsigned int v35;
  NSObject *v36;
  _BOOL4 isStable;
  BOOL v38;
  int v39;
  CLMicroLocationProto::anchorAppearancesVector *v40;
  unsigned int v41;
  unsigned int v42;
  unsigned int *v43;
  unsigned int *m;
  unsigned int v45;
  int v46;
  uint64_t v47;
  CLMicroLocationProto::LocationSimilarityListData *v48;
  int v49;
  std::string *v50;
  CLMicroLocationProto::BlueAtlasData *v51;
  const char *v52;
  int v53;
  const char *v54;
  int v55;
  const char *v56;
  __int128 v57;
  char v58;
  std::string __str;
  uint64_t v60;

  v60 = *MEMORY[0x24BDAC8D0];
  CLMicroLocationProto::Model::Model((CLMicroLocationProto::Model *)a2);
  v5 = *((_QWORD *)this + 41);
  for (i = *((_QWORD *)this + 42); v5 != i; v5 += 32)
  {
    v7 = *(_DWORD *)(a2 + 20);
    v8 = *(int *)(a2 + 16);
    if ((int)v8 >= v7)
    {
      if (v7 == *(_DWORD *)(a2 + 24))
      {
        wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(a2 + 8));
        v7 = *(_DWORD *)(a2 + 20);
      }
      *(_DWORD *)(a2 + 20) = v7 + 1;
      v10 = (CLMicroLocationProto::Fingerprint *)wireless_diagnostics::google::protobuf::internal::GenericTypeHandler<CLMicroLocationProto::Fingerprint>::New();
      v11 = *(_QWORD *)(a2 + 8);
      v12 = *(int *)(a2 + 16);
      *(_DWORD *)(a2 + 16) = v12 + 1;
      *(_QWORD *)(v11 + 8 * v12) = v10;
    }
    else
    {
      v9 = *(_QWORD *)(a2 + 8);
      *(_DWORD *)(a2 + 16) = v8 + 1;
      v10 = *(CLMicroLocationProto::Fingerprint **)(v9 + 8 * v8);
    }
    v13 = *(_QWORD *)v5;
    v57 = *(_OWORD *)(v5 + 16);
    v58 = 1;
    CLMicroLocationFingerprint::toProtobuf(v13, (uint64_t)&v57, (uint64_t)&__str);
    CLMicroLocationProto::Fingerprint::CopyFrom(v10, (const CLMicroLocationProto::Fingerprint *)&__str);
    CLMicroLocationProto::Fingerprint::~Fingerprint((CLMicroLocationProto::Fingerprint *)&__str);
  }
  for (j = (_QWORD *)*((_QWORD *)this + 46); j; j = (_QWORD *)*j)
  {
    v15 = *(_DWORD *)(a2 + 68);
    v16 = *(int *)(a2 + 64);
    if ((int)v16 >= v15)
    {
      if (v15 == *(_DWORD *)(a2 + 72))
      {
        wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(a2 + 56));
        v15 = *(_DWORD *)(a2 + 68);
      }
      *(_DWORD *)(a2 + 68) = v15 + 1;
      v18 = wireless_diagnostics::google::protobuf::internal::GenericTypeHandler<CLMicroLocationProto::ClusterRecordings>::New();
      v19 = *(_QWORD *)(a2 + 56);
      v20 = *(int *)(a2 + 64);
      *(_DWORD *)(a2 + 64) = v20 + 1;
      *(_QWORD *)(v19 + 8 * v20) = v18;
    }
    else
    {
      v17 = *(_QWORD *)(a2 + 56);
      *(_DWORD *)(a2 + 64) = v16 + 1;
      v18 = *(_QWORD *)(v17 + 8 * v16);
    }
    v21 = 0;
    *((_BYTE *)&__str.__r_.__value_.__s + 23) = 16;
    do
    {
      __str.__r_.__value_.__s.__data_[v21] = *((_BYTE *)j + v21 + 16);
      ++v21;
    }
    while (v21 != 16);
    __str.__r_.__value_.__s.__data_[16] = 0;
    *(_DWORD *)(v18 + 44) |= 1u;
    v22 = *(std::string **)(v18 + 8);
    if (v22 == (std::string *)MEMORY[0x24BEDD958])
    {
      v22 = (std::string *)operator new();
      v22->__r_.__value_.__r.__words[0] = 0;
      v22->__r_.__value_.__l.__size_ = 0;
      v22->__r_.__value_.__r.__words[2] = 0;
      *(_QWORD *)(v18 + 8) = v22;
    }
    v23 = (wireless_diagnostics::google::protobuf::internal::StringTypeHandlerBase *)std::string::operator=(v22, &__str);
    if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__str.__r_.__value_.__l.__data_);
    v25 = j[4];
    for (k = j[5]; v25 != k; v25 += 16)
    {
      v26 = 0;
      *((_BYTE *)&__str.__r_.__value_.__s + 23) = 16;
      do
      {
        __str.__r_.__value_.__s.__data_[v26] = *(_BYTE *)(v25 + v26);
        ++v26;
      }
      while (v26 != 16);
      __str.__r_.__value_.__s.__data_[16] = 0;
      v27 = *(_DWORD *)(v18 + 28);
      v28 = *(int *)(v18 + 24);
      if ((int)v28 >= v27)
      {
        if (v27 == *(_DWORD *)(v18 + 32))
        {
          v23 = (wireless_diagnostics::google::protobuf::internal::StringTypeHandlerBase *)wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(v18 + 16));
          v27 = *(_DWORD *)(v18 + 28);
        }
        *(_DWORD *)(v18 + 28) = v27 + 1;
        v30 = (std::string *)wireless_diagnostics::google::protobuf::internal::StringTypeHandlerBase::New(v23);
        v31 = *(_QWORD *)(v18 + 16);
        v32 = *(int *)(v18 + 24);
        *(_DWORD *)(v18 + 24) = v32 + 1;
        *(_QWORD *)(v31 + 8 * v32) = v30;
      }
      else
      {
        v29 = *(_QWORD *)(v18 + 16);
        *(_DWORD *)(v18 + 24) = v28 + 1;
        v30 = *(std::string **)(v29 + 8 * v28);
      }
      v23 = (wireless_diagnostics::google::protobuf::internal::StringTypeHandlerBase *)std::string::operator=(v30, &__str);
      if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__str.__r_.__value_.__l.__data_);
    }
  }
  v33 = *((_QWORD *)this + 47);
  *(_DWORD *)(a2 + 200) |= 2u;
  *(_QWORD *)(a2 + 32) = v33;
  v34 = *(_DWORD *)this;
  if (!CLMicroLocationProto::TriggerReason_IsValid((CLMicroLocationProto *)*(unsigned int *)this))
  {
    v52 = "::CLMicroLocationProto::Model_GenerationAlgorithm_IsValid(value)";
    v53 = 12656;
    v54 = "set_generationalgorithm";
    goto LABEL_63;
  }
  *(_DWORD *)(a2 + 200) |= 8u;
  *(_DWORD *)(a2 + 48) = v34;
  v35 = *((_DWORD *)this + 1);
  if (!CLMicroLocationProto::MotionState_IsValid((CLMicroLocationProto *)v35))
  {
    v52 = "::CLMicroLocationProto::Model_ModelType_IsValid(value)";
    v53 = 12679;
    v54 = "set_modeltype";
LABEL_63:
    __assert_rtn(v54, "microlocation.pb.h", v53, v52);
  }
  *(_DWORD *)(a2 + 200) |= 0x10u;
  *(_DWORD *)(a2 + 52) = v35;
  if (onceToken_MicroLocation_Default != -1)
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_5);
  v36 = (id)logObject_MicroLocation_Default;
  if (os_log_type_enabled(v36, OS_LOG_TYPE_DEBUG))
  {
    isStable = CLMicroLocationModel::isStable(this);
    __str.__r_.__value_.__r.__words[0] = 68289282;
    LOWORD(__str.__r_.__value_.__r.__words[1]) = 2082;
    *(std::string::size_type *)((char *)&__str.__r_.__value_.__r.__words[1] + 2) = (std::string::size_type)"";
    WORD1(__str.__r_.__value_.__r.__words[2]) = 1026;
    HIDWORD(__str.__r_.__value_.__r.__words[2]) = isStable;
    _os_log_impl(&dword_2419D9000, v36, OS_LOG_TYPE_DEBUG, "{\"msg%{public}.0s\":\"isStable, toProtobuf\", \"isStableflag\":%{public}hhd}", (uint8_t *)&__str, 0x18u);
  }

  v38 = CLMicroLocationModel::isStable(this);
  v39 = *(_DWORD *)(a2 + 200);
  *(_BYTE *)(a2 + 104) = v38;
  *(_DWORD *)(a2 + 108) = *((_DWORD *)this + 3);
  *(_DWORD *)(a2 + 200) = v39 | 0x380;
  v40 = *(CLMicroLocationProto::anchorAppearancesVector **)(a2 + 112);
  if (!v40)
  {
    v40 = (CLMicroLocationProto::anchorAppearancesVector *)operator new();
    CLMicroLocationProto::anchorAppearancesVector::anchorAppearancesVector((uint64_t)v40);
    *(_QWORD *)(a2 + 112) = v40;
  }
  CLMicroLocationAnchorAppearanceMap::toProtobuf((CLMicroLocationModel *)((char *)this + 16), (int *)&__str);
  CLMicroLocationProto::anchorAppearancesVector::CopyFrom(v40, (const CLMicroLocationProto::anchorAppearancesVector *)&__str);
  CLMicroLocationProto::anchorAppearancesVector::~anchorAppearancesVector((CLMicroLocationProto::anchorAppearancesVector *)&__str);
  v41 = *((_DWORD *)this + 98);
  if (!CLMicroLocationProto::MotionState_IsValid((CLMicroLocationProto *)v41))
  {
    v55 = 12880;
    v56 = "set_qualityindicator";
    goto LABEL_66;
  }
  *(_DWORD *)(a2 + 200) |= 0x800u;
  *(_DWORD *)(a2 + 128) = v41;
  v42 = *((_DWORD *)this + 99);
  if (!CLMicroLocationProto::MotionState_IsValid((CLMicroLocationProto *)v42))
  {
    v55 = 12903;
    v56 = "set_candidatequalityindicator";
LABEL_66:
    __assert_rtn(v56, "microlocation.pb.h", v55, "::CLMicroLocationProto::Model_ModelQualityLevel_IsValid(value)");
  }
  *(_DWORD *)(a2 + 200) |= 0x1000u;
  *(_DWORD *)(a2 + 132) = v42;
  v43 = (unsigned int *)*((_QWORD *)this + 50);
  for (m = (unsigned int *)*((_QWORD *)this + 51); v43 != m; ++v43)
  {
    v45 = *v43;
    if (!CLMicroLocationProto::ServiceQualityReasonEnum_IsValid((CLMicroLocationProto *)*v43))
      __assert_rtn("add_candidatequalityreasons", "microlocation.pb.h", 12923, "::CLMicroLocationProto::ServiceQualityReasonEnum_IsValid(value)");
    v46 = *(_DWORD *)(a2 + 144);
    if (v46 == *(_DWORD *)(a2 + 148))
    {
      wireless_diagnostics::google::protobuf::RepeatedField<int>::Reserve((_DWORD *)(a2 + 136), v46 + 1);
      v46 = *(_DWORD *)(a2 + 144);
    }
    v47 = *(_QWORD *)(a2 + 136);
    *(_DWORD *)(a2 + 144) = v46 + 1;
    *(_DWORD *)(v47 + 4 * v46) = v45;
  }
  if (*((_DWORD *)this + 1) == 2 && *((_BYTE *)this + 192))
  {
    *(_DWORD *)(a2 + 200) |= 0x400u;
    v48 = *(CLMicroLocationProto::LocationSimilarityListData **)(a2 + 120);
    if (!v48)
    {
      v48 = (CLMicroLocationProto::LocationSimilarityListData *)operator new();
      CLMicroLocationProto::LocationSimilarityListData::LocationSimilarityListData((uint64_t)v48);
      *(_QWORD *)(a2 + 120) = v48;
    }
    CLMicroLocationModel::SimilarityListData::toProtobuf((CLMicroLocationModel *)((char *)this + 72), (int *)&__str);
    CLMicroLocationProto::LocationSimilarityListData::CopyFrom(v48, (const CLMicroLocationProto::LocationSimilarityListData *)&__str);
    CLMicroLocationProto::LocationSimilarityListData::~LocationSimilarityListData((CLMicroLocationProto::LocationSimilarityListData *)&__str);
  }
  v49 = *(_DWORD *)(a2 + 200);
  *(_OWORD *)(a2 + 152) = *(_OWORD *)((char *)this + 296);
  *(_QWORD *)(a2 + 168) = *((_QWORD *)this + 39);
  *(_DWORD *)(a2 + 192) = *((_DWORD *)this + 80);
  *(_DWORD *)(a2 + 200) = v49 | 0x3FC000;
  v50 = *(std::string **)(a2 + 176);
  if (v50 == (std::string *)MEMORY[0x24BEDD958])
  {
    v50 = (std::string *)operator new();
    v50->__r_.__value_.__r.__words[0] = 0;
    v50->__r_.__value_.__l.__size_ = 0;
    v50->__r_.__value_.__r.__words[2] = 0;
    *(_QWORD *)(a2 + 176) = v50;
  }
  std::string::operator=(v50, (const std::string *)((char *)this + 424));
  if (*((_DWORD *)this + 1) == 3 && *((_BYTE *)this + 288))
  {
    *(_DWORD *)(a2 + 200) |= 0x400000u;
    v51 = *(CLMicroLocationProto::BlueAtlasData **)(a2 + 184);
    if (!v51)
    {
      v51 = (CLMicroLocationProto::BlueAtlasData *)operator new();
      CLMicroLocationProto::BlueAtlasData::BlueAtlasData(v51);
      *(_QWORD *)(a2 + 184) = v51;
    }
    CLMicroLocationModel::BlueAtlasData::toProtobuf((CLMacAddress *)this + 25, (uint64_t)&__str);
    CLMicroLocationProto::BlueAtlasData::CopyFrom(v51, (const CLMicroLocationProto::BlueAtlasData *)&__str);
    CLMicroLocationProto::BlueAtlasData::~BlueAtlasData((CLMicroLocationProto::BlueAtlasData *)&__str);
  }
}

void sub_2419F8EB8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  CLMicroLocationProto::Model *v18;
  uint64_t v19;

  MEMORY[0x2426A04D4](v19, 0x10B1C400E3A2C2ELL);
  CLMicroLocationProto::Model::~Model(v18);
  _Unwind_Resume(a1);
}

uint64_t CLMicroLocationModel::numClusters(CLMicroLocationModel *this)
{
  return *((_QWORD *)this + 47);
}

BOOL CLMicroLocationModel::isStable(CLMicroLocationModel *this)
{
  _QWORD *v3;
  unint64_t v4;
  NSObject *v5;
  uint64_t v6;
  int v7;
  void *v8;
  void *v9;
  void *v10;
  void *v11;
  uint64_t v12;
  unint64_t v13;
  unint64_t v14;
  void *v15;
  void *v16;
  void *v17;
  void *v18;
  uint64_t v19;
  unint64_t v20;
  _DWORD v21[2];
  __int16 v22;
  const char *v23;
  __int16 v24;
  unint64_t v25;
  __int16 v26;
  uint64_t v27;
  __int16 v28;
  int v29;
  uint64_t v30;

  v30 = *MEMORY[0x24BDAC8D0];
  if (*((_DWORD *)this + 1) == 2)
    return *((_BYTE *)this + 8) != 0;
  v3 = (_QWORD *)*((_QWORD *)this + 46);
  if (v3)
  {
    v4 = 0;
    do
    {
      v4 += (uint64_t)(v3[5] - v3[4]) >> 4;
      v3 = (_QWORD *)*v3;
    }
    while (v3);
  }
  else
  {
    v4 = 0;
  }
  if (onceToken_MicroLocation_Default != -1)
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_5);
  v5 = logObject_MicroLocation_Default;
  if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEBUG))
  {
    v6 = *((unsigned int *)this + 3);
    v7 = *((unsigned __int8 *)this + 8);
    v21[0] = 68289794;
    v21[1] = 0;
    v22 = 2082;
    v23 = "";
    v24 = 2050;
    v25 = v4;
    v26 = 2050;
    v27 = v6;
    v28 = 1026;
    v29 = v7;
    _os_log_impl(&dword_2419D9000, v5, OS_LOG_TYPE_DEBUG, "{\"msg%{public}.0s\":\"isStable, getter\", \"numRecordingsBeforePruning\":%{public}llu, \"numDaysWithRecordings\":%{public}ld, \"fIsStable\":%{public}hhd}", (uint8_t *)v21, 0x2Cu);
  }
  if (*((_BYTE *)this + 8))
    return 1;
  +[ULDefaultsSingleton shared](ULDefaultsSingleton, "shared");
  v8 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v8, "defaultsDictionary");
  v9 = (void *)objc_claimAutoreleasedReturnValue();

  objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "ULMinimumNumberOfRecordingsInStableModel");
  v10 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v9, "objectForKey:", v10);
  v11 = (void *)objc_claimAutoreleasedReturnValue();
  if (!v11)
    goto LABEL_16;
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0)
    v12 = objc_msgSend(v11, "unsignedLongValue");
  else
LABEL_16:
    v12 = objc_msgSend(&unk_2511ED360, "unsignedLongValue");
  v13 = v12;

  if (v4 >= v13)
    return 1;
  v14 = *((unsigned int *)this + 3);
  +[ULDefaultsSingleton shared](ULDefaultsSingleton, "shared");
  v15 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v15, "defaultsDictionary");
  v16 = (void *)objc_claimAutoreleasedReturnValue();

  objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "ULMinimumNumberOfDaysWithRecordingsInStableModel");
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v16, "objectForKey:", v17);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  if (v18 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
    v19 = objc_msgSend(v18, "unsignedLongValue");
  else
    v19 = objc_msgSend(&unk_2511ED330, "unsignedLongValue");
  v20 = v19;

  return v20 <= v14;
}

void sub_2419F92BC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

uint64_t CLMicroLocationModel::getQualityIndicator(CLMicroLocationModel *this)
{
  return *((unsigned int *)this + 98);
}

uint64_t CLMicroLocationModel::getCandidateQualityIndicator(CLMicroLocationModel *this)
{
  return *((unsigned int *)this + 99);
}

uint64_t CLMicroLocationModel::getCandidateQualityReasons(CLMicroLocationModel *this)
{
  return (uint64_t)this + 400;
}

void CLMicroLocationModel::SimilarityListData::toProtobuf(CLMicroLocationModel::SimilarityListData *this@<X0>, int *a2@<X8>)
{
  wireless_diagnostics::google::protobuf::internal::StringTypeHandlerBase *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  std::string *v11;
  uint64_t v12;
  uint64_t v13;
  unsigned int *v14;
  unsigned int *i;
  unsigned int v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  std::string *v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  _QWORD *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  std::string *v31;
  unint64_t v32;
  std::string::size_type v33;
  int v34;
  uint64_t v35;
  std::string __str;

  v4 = (wireless_diagnostics::google::protobuf::internal::StringTypeHandlerBase *)CLMicroLocationProto::LocationSimilarityListData::LocationSimilarityListData((uint64_t)a2);
  v5 = *(_QWORD *)this;
  v6 = *((_QWORD *)this + 1);
  if (*(_QWORD *)this != v6)
  {
    do
    {
      v7 = 0;
      *((_BYTE *)&__str.__r_.__value_.__s + 23) = 16;
      do
      {
        __str.__r_.__value_.__s.__data_[v7] = *(_BYTE *)(v5 + v7);
        ++v7;
      }
      while (v7 != 16);
      __str.__r_.__value_.__s.__data_[16] = 0;
      v8 = a2[5];
      v9 = a2[4];
      if ((int)v9 >= v8)
      {
        if (v8 == a2[6])
        {
          v4 = (wireless_diagnostics::google::protobuf::internal::StringTypeHandlerBase *)wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(a2 + 2));
          v8 = a2[5];
        }
        a2[5] = v8 + 1;
        v11 = (std::string *)wireless_diagnostics::google::protobuf::internal::StringTypeHandlerBase::New(v4);
        v12 = *((_QWORD *)a2 + 1);
        v13 = a2[4];
        a2[4] = v13 + 1;
        *(_QWORD *)(v12 + 8 * v13) = v11;
      }
      else
      {
        v10 = *((_QWORD *)a2 + 1);
        a2[4] = v9 + 1;
        v11 = *(std::string **)(v10 + 8 * v9);
      }
      v4 = (wireless_diagnostics::google::protobuf::internal::StringTypeHandlerBase *)std::string::operator=(v11, &__str);
      if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__str.__r_.__value_.__l.__data_);
      v5 += 16;
    }
    while (v5 != v6);
  }
  v14 = (unsigned int *)*((_QWORD *)this + 10);
  for (i = (unsigned int *)*((_QWORD *)this + 11); v14 != i; ++v14)
  {
    v16 = *v14;
    if ((CLMicroLocationProto::ConfidenceLevel_IsValid((CLMicroLocationProto *)*v14) & 1) == 0)
      __assert_rtn("add_eventconfidences", "microlocation.pb.h", 12438, "::CLMicroLocationProto::ConfidenceLevel_IsValid(value)");
    v17 = a2[16];
    if (v17 == a2[17])
    {
      wireless_diagnostics::google::protobuf::RepeatedField<int>::Reserve(a2 + 14, v17 + 1);
      v17 = a2[16];
    }
    v18 = *((_QWORD *)a2 + 7);
    a2[16] = v17 + 1;
    *(_DWORD *)(v18 + 4 * v17) = v16;
  }
  v19 = *((_QWORD *)this + 3);
  if (*((_QWORD *)this + 4) != v19)
  {
    v20 = 0;
    v21 = 0;
    v22 = (std::string *)MEMORY[0x24BEDD958];
    do
    {
      v23 = a2[11];
      v24 = a2[10];
      if ((int)v24 >= v23)
      {
        if (v23 == a2[12])
        {
          wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(a2 + 8));
          v23 = a2[11];
        }
        a2[11] = v23 + 1;
        v26 = wireless_diagnostics::google::protobuf::internal::GenericTypeHandler<CLMicroLocationProto::LocationSimilarityListElement>::New();
        v27 = *((_QWORD *)a2 + 4);
        v28 = a2[10];
        a2[10] = v28 + 1;
        *(_QWORD *)(v27 + 8 * v28) = v26;
        v19 = *((_QWORD *)this + 3);
      }
      else
      {
        v25 = *((_QWORD *)a2 + 4);
        a2[10] = v24 + 1;
        v26 = *(_QWORD **)(v25 + 8 * v24);
      }
      v29 = 0;
      *((_BYTE *)&__str.__r_.__value_.__s + 23) = 16;
      v30 = v19 + v20;
      do
      {
        __str.__r_.__value_.__s.__data_[v29] = *(_BYTE *)(v30 + v29);
        ++v29;
      }
      while (v29 != 16);
      __str.__r_.__value_.__s.__data_[16] = 0;
      *((_DWORD *)v26 + 9) |= 1u;
      v31 = (std::string *)v26[1];
      if (v31 == v22)
      {
        v31 = (std::string *)operator new();
        v31->__r_.__value_.__r.__words[0] = 0;
        v31->__r_.__value_.__l.__size_ = 0;
        v31->__r_.__value_.__r.__words[2] = 0;
        v26[1] = v31;
      }
      std::string::operator=(v31, &__str);
      if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__str.__r_.__value_.__l.__data_);
      if (*((_QWORD *)this + 1) != *(_QWORD *)this)
      {
        v32 = 0;
        do
        {
          __str.__r_.__value_.__r.__words[0] = 0;
          CLMicroLocationUtils::ProbabilityMatrix::getValue((CLMicroLocationModel::SimilarityListData *)((char *)this + 48), v21, v32, (double *)&__str);
          v33 = __str.__r_.__value_.__r.__words[0];
          v34 = *((_DWORD *)v26 + 6);
          if (v34 == *((_DWORD *)v26 + 7))
          {
            wireless_diagnostics::google::protobuf::RepeatedField<double>::Reserve((_DWORD *)v26 + 4, v34 + 1);
            v34 = *((_DWORD *)v26 + 6);
          }
          v35 = v26[2];
          *((_DWORD *)v26 + 6) = v34 + 1;
          *(_QWORD *)(v35 + 8 * v34) = v33;
          ++v32;
        }
        while (v32 < (uint64_t)(*((_QWORD *)this + 1) - *(_QWORD *)this) >> 4);
      }
      ++v21;
      v19 = *((_QWORD *)this + 3);
      v20 += 16;
    }
    while (v21 < (*((_QWORD *)this + 4) - v19) >> 4);
  }
}

void sub_2419F9670(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  CLMicroLocationProto::LocationSimilarityListData *v15;

  CLMicroLocationProto::LocationSimilarityListData::~LocationSimilarityListData(v15);
  _Unwind_Resume(a1);
}

float CLMicroLocationModel::BlueAtlasData::toProtobuf@<S0>(CLMacAddress *this@<X0>, uint64_t a2@<X8>)
{
  wireless_diagnostics::google::protobuf::internal::StringTypeHandlerBase *v4;
  double v5;
  unint64_t var0;
  unint64_t v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  std::string *v12;
  uint64_t v13;
  uint64_t v14;
  CLMacAddress *v15;
  CLMacAddress *i;
  unint64_t v17;
  int v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  uint64_t v22;
  std::string __str;

  v5 = CLMicroLocationProto::BlueAtlasData::BlueAtlasData((CLMicroLocationProto::BlueAtlasData *)a2);
  var0 = this->var0;
  v7 = this[1].var0;
  if (this->var0 != v7)
  {
    do
    {
      v8 = 0;
      *((_BYTE *)&__str.__r_.__value_.__s + 23) = 16;
      do
      {
        __str.__r_.__value_.__s.__data_[v8] = *(_BYTE *)(var0 + v8);
        ++v8;
      }
      while (v8 != 16);
      __str.__r_.__value_.__s.__data_[16] = 0;
      v9 = *(_DWORD *)(a2 + 20);
      v10 = *(int *)(a2 + 16);
      if ((int)v10 >= v9)
      {
        if (v9 == *(_DWORD *)(a2 + 24))
        {
          v4 = (wireless_diagnostics::google::protobuf::internal::StringTypeHandlerBase *)wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve((wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(a2 + 8));
          v9 = *(_DWORD *)(a2 + 20);
        }
        *(_DWORD *)(a2 + 20) = v9 + 1;
        v12 = (std::string *)wireless_diagnostics::google::protobuf::internal::StringTypeHandlerBase::New(v4);
        v13 = *(_QWORD *)(a2 + 8);
        v14 = *(int *)(a2 + 16);
        *(_DWORD *)(a2 + 16) = v14 + 1;
        *(_QWORD *)(v13 + 8 * v14) = v12;
      }
      else
      {
        v11 = *(_QWORD *)(a2 + 8);
        *(_DWORD *)(a2 + 16) = v10 + 1;
        v12 = *(std::string **)(v11 + 8 * v10);
      }
      v4 = (wireless_diagnostics::google::protobuf::internal::StringTypeHandlerBase *)std::string::operator=(v12, &__str);
      if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__str.__r_.__value_.__l.__data_);
      var0 += 16;
    }
    while (var0 != v7);
  }
  v15 = (CLMacAddress *)this[3].var0;
  for (i = (CLMacAddress *)this[4].var0; v15 != i; ++v15)
  {
    v17 = CLMacAddress::toUint64(v15);
    v18 = *(_DWORD *)(a2 + 40);
    if (v18 == *(_DWORD *)(a2 + 44))
    {
      wireless_diagnostics::google::protobuf::RepeatedField<double>::Reserve((_DWORD *)(a2 + 32), v18 + 1);
      v18 = *(_DWORD *)(a2 + 40);
    }
    v19 = *(_QWORD *)(a2 + 32);
    *(_DWORD *)(a2 + 40) = v18 + 1;
    *(_QWORD *)(v19 + 8 * v18) = v17;
  }
  if (LOBYTE(this[9].var0))
  {
    *(_DWORD *)(a2 + 60) |= 4u;
    v20 = *(_QWORD *)(a2 + 48);
    if (!v20)
    {
      v20 = operator new();
      CLMicroLocationProto::AssociatedAccessPointInfo::AssociatedAccessPointInfo(v20);
      *(_QWORD *)(a2 + 48) = v20;
      if (!LOBYTE(this[9].var0))
        std::__throw_bad_optional_access[abi:ne180100]();
    }
    v21 = CLMacAddress::toUint64(this + 8);
    *(_DWORD *)(v20 + 24) |= 1u;
    *(_QWORD *)(v20 + 8) = v21;
    *(_DWORD *)(a2 + 60) |= 4u;
    v22 = *(_QWORD *)(a2 + 48);
    if (!v22)
    {
      v22 = operator new();
      CLMicroLocationProto::AssociatedAccessPointInfo::AssociatedAccessPointInfo(v22);
      *(_QWORD *)(a2 + 48) = v22;
    }
    LODWORD(v5) = this[10].var0;
    *(_DWORD *)(v22 + 24) |= 2u;
    *(_DWORD *)(v22 + 16) = LODWORD(v5);
  }
  return *(float *)&v5;
}

void sub_2419F98B8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  CLMicroLocationProto::BlueAtlasData *v15;
  uint64_t v16;

  MEMORY[0x2426A04D4](v16, 0x1081C40DCAC275BLL);
  CLMicroLocationProto::BlueAtlasData::~BlueAtlasData(v15);
  _Unwind_Resume(a1);
}

void CLMicroLocationModel::fromProtobuf(const CLMicroLocationProto::Fingerprint ***this@<X0>, const CLMicroLocationProto::Model *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v7;
  const CLMicroLocationProto::Fingerprint **v8;
  uint64_t v9;
  const CLMicroLocationProto::Fingerprint *v10;
  int v11;
  NSObject *v12;
  uint64_t **v13;
  int v14;
  NSObject *v15;
  NSObject *v16;
  uint64_t v17;
  uint64_t *v18;
  uint64_t *v19;
  uint64_t v20;
  uint64_t **v21;
  int v22;
  uint64_t v23;
  uint64_t ***v24;
  uint64_t v25;
  uint64_t **v26;
  int v27;
  NSObject *v28;
  NSObject *v29;
  int v30;
  NSObject *v31;
  int v32;
  CLMicroLocationProto::Model *v33;
  CLMicroLocationModel *v34;
  const CLMicroLocationProto::anchorAppearancesVector *v35;
  int v36;
  _QWORD *v37;
  unint64_t v38;
  void *v39;
  void *v40;
  void *v41;
  void *v42;
  unsigned int v43;
  unsigned int v44;
  int v45;
  NSObject *v46;
  int v47;
  uint64_t v48;
  char *v49;
  int *v50;
  int *v51;
  int v52;
  uint64_t v53;
  char *v54;
  uint64_t v55;
  unint64_t v56;
  uint64_t v57;
  unint64_t v58;
  char *v59;
  char *v60;
  int v61;
  unint64_t v62;
  uint64_t *v63;
  uint64_t v64;
  CLMicroLocationModel::SimilarityListData *v65;
  uint64_t v66;
  unint64_t v67;
  NSObject *v68;
  uint64_t ****v69;
  int v70;
  CLMicroLocationModel *v71;
  uint64_t v72[3];
  void *v73;
  void *v74;
  uint64_t v75;
  _BYTE v76[16];
  uint64_t *v77;
  void *__src;
  char *v79;
  char *v80;
  uint8_t buf[32];
  _OWORD v82[2];
  __int128 v83;
  void *v84;
  void *v85;
  uint64_t v86;
  _BYTE v87[64];
  void *__p;
  void *v89;
  uuid v90;
  uuid v91;
  uint64_t v92;

  v92 = *MEMORY[0x24BDAC8D0];
  CLMicroLocationModel::CLMicroLocationModel((CLMicroLocationModel *)a3);
  *(_QWORD *)v91.var0 = 0;
  *(_QWORD *)&v91.var0[8] = 0;
  *(_QWORD *)v90.var0 = 0;
  *(_QWORD *)&v90.var0[8] = 0;
  v71 = (CLMicroLocationModel *)this;
  v7 = *((int *)this + 4);
  if ((_DWORD)v7)
  {
    v8 = this[1];
    v9 = 8 * v7;
    while (1)
    {
      v10 = *v8;
      v11 = *((_DWORD *)*v8 + 26);
      if ((v11 & 0x20) != 0)
        break;
      if ((v11 & 2) != 0)
      {
        if (onceToken_MicroLocation_Default != -1)
          dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_5);
        v15 = (id)logObject_MicroLocation_Default;
        if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl(&dword_2419D9000, v15, OS_LOG_TYPE_DEFAULT, "#Warning The protobuf fingerprint is using a deprecated uint64 cluster label", buf, 2u);
        }

        *(_QWORD *)v91.var0 = *((_QWORD *)v10 + 4);
LABEL_21:
        CLMicroLocationFingerprint::CLMicroLocationFingerprint((CLMicroLocationFingerprint *)buf, v10);
        CLMicroLocationModel::addFingerprint((CLMicroLocationModel *)a3, (const CLMicroLocationFingerprint *)buf, &v91, a2);
        if (__p)
        {
          v89 = __p;
          operator delete(__p);
        }
        std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>>>::~__hash_table((uint64_t)v87);
        std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>>>::~__hash_table((uint64_t)&v83);
        std::__hash_table<CLMicroLocationFingerprint::Measurement,CLMicroLocationFingerprint::Measurement::HashMeasurement,CLMicroLocationFingerprint::Measurement::PredicateMeasurement,std::allocator<CLMicroLocationFingerprint::Measurement>>::~__hash_table((uint64_t)buf);
        goto LABEL_29;
      }
      if (onceToken_MicroLocation_Default != -1)
        dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_5);
      v12 = (id)logObject_MicroLocation_Default;
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl(&dword_2419D9000, v12, OS_LOG_TYPE_DEFAULT, "#Warning The protobuf fingerprint does not have a cluster identifer", buf, 2u);
      }

LABEL_29:
      ++v8;
      v9 -= 8;
      if (!v9)
        goto LABEL_30;
    }
    v13 = (uint64_t **)*((_QWORD *)v10 + 8);
    v14 = *((char *)v13 + 23);
    if (v14 < 0)
    {
      if (v13[1] != (uint64_t *)16)
      {
LABEL_24:
        if (onceToken_MicroLocation_Default != -1)
          dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_5);
        v16 = (id)logObject_MicroLocation_Default;
        if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl(&dword_2419D9000, v16, OS_LOG_TYPE_DEFAULT, "#Warning The protobuf fingerprint does not have a valid cluster label uuid", buf, 2u);
        }

        goto LABEL_29;
      }
      v13 = (uint64_t **)*v13;
    }
    else if (v14 != 16)
    {
      goto LABEL_24;
    }
    v91 = *(uuid *)v13;
    goto LABEL_21;
  }
LABEL_30:
  v17 = *((int *)v71 + 16);
  if ((_DWORD)v17)
  {
    v18 = (uint64_t *)*((_QWORD *)v71 + 7);
    v19 = &v18[v17];
    while (1)
    {
      v20 = *v18;
      v21 = *(uint64_t ***)(*v18 + 8);
      v22 = *((char *)v21 + 23);
      if (v22 < 0)
      {
        if (v21[1] != (uint64_t *)16)
        {
LABEL_52:
          if (onceToken_MicroLocation_Default != -1)
            dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_5);
          v29 = (id)logObject_MicroLocation_Default;
          if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)buf = 0;
            _os_log_impl(&dword_2419D9000, v29, OS_LOG_TYPE_DEFAULT, "#Warning The protobuf cluster recording does not have a valid cluster label uuid", buf, 2u);
          }

          goto LABEL_57;
        }
        v21 = (uint64_t **)*v21;
      }
      else if (v22 != 16)
      {
        goto LABEL_52;
      }
      v91 = *(uuid *)v21;
      v23 = *(int *)(v20 + 24);
      if ((_DWORD)v23)
        break;
LABEL_57:
      if (++v18 == v19)
        goto LABEL_58;
    }
    v24 = *(uint64_t ****)(v20 + 16);
    v25 = 8 * v23;
    while (1)
    {
      v26 = *v24;
      v27 = *((char *)*v24 + 23);
      if (v27 < 0)
      {
        if (v26[1] != (uint64_t *)16)
        {
LABEL_45:
          if (onceToken_MicroLocation_Default != -1)
            dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_5);
          v28 = (id)logObject_MicroLocation_Default;
          if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)buf = 0;
            _os_log_impl(&dword_2419D9000, v28, OS_LOG_TYPE_DEFAULT, "#Warning The protobuf cluster recording does not have a valid recording uuid", buf, 2u);
          }

          goto LABEL_50;
        }
        v26 = (uint64_t **)*v26;
      }
      else if (v27 != 16)
      {
        goto LABEL_45;
      }
      v90 = *(uuid *)v26;
      CLMicroLocationModel::addRecording((CLMicroLocationModel *)a3, &v91, &v90);
LABEL_50:
      ++v24;
      v25 -= 8;
      if (!v25)
        goto LABEL_57;
    }
  }
LABEL_58:
  v30 = *((_DWORD *)v71 + 13) & ((int)(*((_DWORD *)v71 + 50) << 27) >> 31);
  *(_DWORD *)a3 = *((_DWORD *)v71 + 12);
  *(_DWORD *)(a3 + 4) = v30;
  if (onceToken_MicroLocation_Default != -1)
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_5);
  v31 = (id)logObject_MicroLocation_Default;
  if (os_log_type_enabled(v31, OS_LOG_TYPE_DEBUG))
  {
    v32 = *((unsigned __int8 *)v71 + 104);
    *(_DWORD *)buf = 68289282;
    *(_DWORD *)&buf[4] = 0;
    *(_WORD *)&buf[8] = 2082;
    *(_QWORD *)&buf[10] = "";
    *(_WORD *)&buf[18] = 1026;
    *(_DWORD *)&buf[20] = v32;
    _os_log_impl(&dword_2419D9000, v31, OS_LOG_TYPE_DEBUG, "{\"msg%{public}.0s\":\"isStable, fromProtobuf\", \"isStableFlag\":%{public}hhd}", buf, 0x18u);
  }

  v34 = v71;
  *(_BYTE *)(a3 + 8) = *((_BYTE *)v71 + 104);
  *(_DWORD *)(a3 + 12) = *((_DWORD *)v71 + 27);
  if ((*((_BYTE *)v71 + 201) & 1) != 0)
  {
    v35 = (const CLMicroLocationProto::anchorAppearancesVector *)*((_QWORD *)v71 + 14);
    if (!v35)
      v35 = *(const CLMicroLocationProto::anchorAppearancesVector **)(CLMicroLocationProto::Model::default_instance(v33)
                                                                    + 112);
    CLMicroLocationAnchorAppearanceMap::CLMicroLocationAnchorAppearanceMap((CLMicroLocationAnchorAppearanceMap *)buf, v35);
    if ((uint8_t *)(a3 + 16) != buf)
    {
      *(_DWORD *)(a3 + 48) = v82[0];
      std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>>>::__assign_multi<std::__hash_const_iterator<std::__hash_node<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,void *> *>>((_QWORD *)(a3 + 16), *(uint64_t **)&buf[16], 0);
    }
    *(_OWORD *)(a3 + 56) = *(_OWORD *)((char *)v82 + 8);
    std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>>>::~__hash_table((uint64_t)buf);
    v34 = v71;
  }
  v36 = *((_DWORD *)v34 + 32);
  *(_DWORD *)(a3 + 392) = v36;
  if (!v36)
  {
    v37 = *(_QWORD **)(a3 + 368);
    if (v37)
    {
      v38 = 0;
      do
      {
        v38 += (uint64_t)(v37[5] - v37[4]) >> 4;
        v37 = (_QWORD *)*v37;
      }
      while (v37);
    }
    else
    {
      v38 = 0;
    }
    +[ULDefaultsSingleton shared](ULDefaultsSingleton, "shared");
    v39 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v39, "defaultsDictionary");
    v40 = (void *)objc_claimAutoreleasedReturnValue();

    objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "ULModelQualityNumFingerprintsWiFiOnlyThreshold");
    v41 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v40, "objectForKey:", v41);
    v42 = (void *)objc_claimAutoreleasedReturnValue();
    if (v42 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
      v43 = objc_msgSend(v42, "unsignedIntValue");
    else
      v43 = objc_msgSend(&unk_2511ED360, "unsignedIntValue");
    v44 = v43;

    if (v38 <= v44)
      v45 = 1;
    else
      v45 = 3;
    *(_DWORD *)(a3 + 392) = v45;
    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_5);
    v46 = (id)logObject_MicroLocation_Default;
    if (os_log_type_enabled(v46, OS_LOG_TYPE_DEFAULT))
    {
      v47 = *(_DWORD *)(a3 + 392);
      *(_DWORD *)buf = 68289282;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(_QWORD *)&buf[10] = "";
      *(_WORD *)&buf[18] = 1026;
      *(_DWORD *)&buf[20] = v47;
      _os_log_impl(&dword_2419D9000, v46, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"Loaded model doesn't have model quality, calculate on the fly\", \"QualityIndicator\":%{public}d}", buf, 0x18u);
    }

    v34 = v71;
  }
  v70 = v30;
  *(_DWORD *)(a3 + 396) = *((_DWORD *)v34 + 33);
  __src = 0;
  v79 = 0;
  v80 = 0;
  v48 = *((int *)v34 + 36);
  if ((_DWORD)v48)
  {
    v49 = 0;
    v50 = (int *)*((_QWORD *)v34 + 17);
    v51 = &v50[v48];
    do
    {
      v52 = *v50;
      if (v49 >= v80)
      {
        v54 = (char *)__src;
        v55 = (v49 - (_BYTE *)__src) >> 2;
        v56 = v55 + 1;
        if ((unint64_t)(v55 + 1) >> 62)
          std::vector<CLMicroLocationProto::ConfidenceReason>::__throw_length_error[abi:ne180100]();
        v57 = v80 - (_BYTE *)__src;
        if ((v80 - (_BYTE *)__src) >> 1 > v56)
          v56 = v57 >> 1;
        if ((unint64_t)v57 >= 0x7FFFFFFFFFFFFFFCLL)
          v58 = 0x3FFFFFFFFFFFFFFFLL;
        else
          v58 = v56;
        if (v58)
        {
          v59 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<CLMicroLocationProto::ConfidenceReason>>((uint64_t)&v80, v58);
          v54 = (char *)__src;
          v49 = v79;
        }
        else
        {
          v59 = 0;
        }
        v60 = &v59[4 * v55];
        *(_DWORD *)v60 = v52;
        v53 = (uint64_t)(v60 + 4);
        while (v49 != v54)
        {
          v61 = *((_DWORD *)v49 - 1);
          v49 -= 4;
          *((_DWORD *)v60 - 1) = v61;
          v60 -= 4;
        }
        __src = v60;
        v79 = (char *)v53;
        v80 = &v59[4 * v58];
        if (v54)
          operator delete(v54);
      }
      else
      {
        *(_DWORD *)v49 = v52;
        v53 = (uint64_t)(v49 + 4);
      }
      v79 = (char *)v53;
      ++v50;
      v49 = (char *)v53;
    }
    while (v50 != v51);
  }
  else
  {
    v53 = 0;
  }
  if ((void **)(a3 + 400) != &__src)
    std::vector<CLMicroLocationProto::ConfidenceLevel>::__assign_with_size[abi:ne180100]<CLMicroLocationProto::ConfidenceLevel*,CLMicroLocationProto::ConfidenceLevel*>((char *)(a3 + 400), (char *)__src, v53, (v53 - (uint64_t)__src) >> 2);
  if ((*((_BYTE *)v71 + 201) & 4) != 0)
  {
    v65 = (CLMicroLocationModel::SimilarityListData *)*((_QWORD *)v71 + 15);
    if (!v65)
      v65 = *(CLMicroLocationModel::SimilarityListData **)(CLMicroLocationProto::Model::default_instance(0) + 120);
    CLMicroLocationModel::SimilarityListData::fromProtobuf(v65, (uint64_t)buf);
    std::optional<CLMicroLocationModel::SimilarityListData>::operator=[abi:ne180100]<CLMicroLocationModel::SimilarityListData,void>(a3 + 72, (uint64_t)buf);
    if (v84)
    {
      v85 = v84;
      operator delete(v84);
    }
    if (BYTE8(v83))
    {
      v66 = *(_QWORD *)&v82[1];
      *(_QWORD *)&v82[1] = 0;
      if (v66)
        MEMORY[0x2426A04BC](v66, 0x1000C8000313F17);
    }
    if (*(_QWORD *)&buf[24])
    {
      *(_QWORD *)&v82[0] = *(_QWORD *)&buf[24];
      operator delete(*(void **)&buf[24]);
    }
    if (*(_QWORD *)buf)
    {
      *(_QWORD *)&buf[8] = *(_QWORD *)buf;
      operator delete(*(void **)buf);
    }
  }
  else if (v70 == 2)
  {
    CLMicroLocationModel::getIdentifiers((_QWORD *)a3, (uint64_t)v76);
    v74 = 0;
    v75 = 0;
    v73 = 0;
    v62 = 0;
    if (v77)
    {
      v63 = v77;
      do
      {
        ++v62;
        v63 = (uint64_t *)*v63;
      }
      while (v63);
    }
    std::vector<boost::uuids::uuid>::__init_with_size[abi:ne180100]<std::__hash_const_iterator<std::__hash_node<boost::uuids::uuid,void *> *>,std::__hash_const_iterator<std::__hash_node<boost::uuids::uuid,void *> *>>((char *)&v73, v77, 0, v62);
    BYTE8(v83) = 0;
    v87[8] = 0;
    memset(buf, 0, sizeof(buf));
    memset(v82, 0, 17);
    v85 = 0;
    v86 = 0;
    v84 = 0;
    v87[0] = 0;
    memset(v72, 0, sizeof(v72));
    CLMicroLocationModel::SimilarityListData::prepareWithClustersInformationOfEvents((uint64_t)buf, (unint64_t **)&v73, v72);
    std::optional<CLMicroLocationModel::SimilarityListData>::operator=[abi:ne180100]<CLMicroLocationModel::SimilarityListData&,void>((CLMicroLocationModel::SimilarityListData *)(a3 + 72), (CLMicroLocationModel::SimilarityListData *)buf);
    if (v84)
    {
      v85 = v84;
      operator delete(v84);
    }
    if (BYTE8(v83))
    {
      v64 = *(_QWORD *)&v82[1];
      *(_QWORD *)&v82[1] = 0;
      if (v64)
        MEMORY[0x2426A04BC](v64, 0x1000C8000313F17);
    }
    if (*(_QWORD *)&buf[24])
    {
      *(_QWORD *)&v82[0] = *(_QWORD *)&buf[24];
      operator delete(*(void **)&buf[24]);
    }
    if (*(_QWORD *)buf)
    {
      *(_QWORD *)&buf[8] = *(_QWORD *)buf;
      operator delete(*(void **)buf);
    }
    if (v73)
    {
      v74 = v73;
      operator delete(v73);
    }
    std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>>>::~__hash_table((uint64_t)v76);
  }
  *(_OWORD *)(a3 + 296) = *(_OWORD *)((char *)v71 + 152);
  *(_QWORD *)(a3 + 312) = *((_QWORD *)v71 + 21);
  *(_DWORD *)(a3 + 320) = *((_DWORD *)v71 + 48);
  std::string::operator=((std::string *)(a3 + 424), *((const std::string **)v71 + 22));
  if ((*((_BYTE *)v71 + 202) & 0x40) != 0)
  {
    v69 = (uint64_t ****)*((_QWORD *)v71 + 23);
    if (!v69)
      v69 = *(uint64_t *****)(CLMicroLocationProto::Model::default_instance(0) + 184);
    CLMicroLocationModel::BlueAtlasData::fromProtobuf(v69, v67, (char **)buf);
    std::optional<CLMicroLocationModel::BlueAtlasData>::operator=[abi:ne180100]<CLMicroLocationModel::BlueAtlasData,void>(a3 + 200, (uint64_t)buf);
  }
  else
  {
    if (v70 != 3)
      goto LABEL_151;
    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_5);
    v68 = (id)logObject_MicroLocation_Default;
    if (os_log_type_enabled(v68, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_2419D9000, v68, OS_LOG_TYPE_ERROR, "Loaded Blue Atlas model doesn't have Blue Atlas data structure, create empty", buf, 2u);
    }

    v83 = 0u;
    memset(v82, 0, sizeof(v82));
    memset(buf, 0, sizeof(buf));
    v84 = (void *)4286578687;
    std::optional<CLMicroLocationModel::BlueAtlasData>::operator=[abi:ne180100]<CLMicroLocationModel::BlueAtlasData,void>(a3 + 200, (uint64_t)buf);
  }
  if (*(_QWORD *)&buf[24])
  {
    *(_QWORD *)&v82[0] = *(_QWORD *)&buf[24];
    operator delete(*(void **)&buf[24]);
  }
  if (*(_QWORD *)buf)
  {
    *(_QWORD *)&buf[8] = *(_QWORD *)buf;
    operator delete(*(void **)buf);
  }
LABEL_151:
  if (__src)
  {
    v79 = (char *)__src;
    operator delete(__src);
  }
}

void sub_2419FA3A0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,uint64_t a24,char a25)
{
  void **v25;
  void *v26;
  void *v27;
  void *v28;

  CLMicroLocationModel::~CLMicroLocationModel(v25);
  _Unwind_Resume(a1);
}

void CLMicroLocationModel::addFingerprint(CLMicroLocationModel *this, const CLMicroLocationFingerprint *a2, const uuid *a3, CLMicroLocationFingerprintPool *a4)
{
  unint64_t *p_shared_owners;
  unint64_t v7;
  std::__shared_weak_count *v8;
  unint64_t *v9;
  unint64_t v10;
  std::__shared_weak_count *v11;
  unint64_t *v12;
  unint64_t v13;
  uint64_t v14;
  std::__shared_weak_count *v15;
  uint64_t v16;
  std::__shared_weak_count *v17;
  __int128 v18;
  uint64_t v19;

  v19 = *MEMORY[0x24BDAC8D0];
  CLMicroLocationFingerprintPool::add(a4, (uuid *)((char *)a2 + 40), a2, &v14);
  v16 = v14;
  v17 = v15;
  if (v15)
  {
    p_shared_owners = (unint64_t *)&v15->__shared_owners_;
    do
      v7 = __ldxr(p_shared_owners);
    while (__stxr(v7 + 1, p_shared_owners));
  }
  v18 = (__int128)*a3;
  std::vector<std::pair<std::shared_ptr<CLMicroLocationFingerprint>,boost::uuids::uuid>>::emplace_back<std::pair<std::shared_ptr<CLMicroLocationFingerprint>,boost::uuids::uuid>>((uint64_t *)this + 41, (uint64_t)&v16);
  v8 = v17;
  if (v17)
  {
    v9 = (unint64_t *)&v17->__shared_owners_;
    do
      v10 = __ldaxr(v9);
    while (__stlxr(v10 - 1, v9));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
  }
  v11 = v15;
  if (v15)
  {
    v12 = (unint64_t *)&v15->__shared_owners_;
    do
      v13 = __ldaxr(v12);
    while (__stlxr(v13 - 1, v12));
    if (!v13)
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
    }
  }
}

void sub_2419FA5B0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v3;
  va_list va;
  uint64_t v5;
  va_list va1;

  va_start(va1, a2);
  va_start(va, a2);
  v3 = va_arg(va1, _QWORD);
  v5 = va_arg(va1, _QWORD);
  std::shared_ptr<CLMiLoService::ModelAndConf>::~shared_ptr[abi:ne180100]((uint64_t)va1);
  std::shared_ptr<CLMiLoService::ModelAndConf>::~shared_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void CLMicroLocationFingerprint::~CLMicroLocationFingerprint(CLMicroLocationFingerprint *this)
{
  void *v2;

  v2 = (void *)*((_QWORD *)this + 21);
  if (v2)
  {
    *((_QWORD *)this + 22) = v2;
    operator delete(v2);
  }
  std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>>>::~__hash_table((uint64_t)this + 104);
  std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>>>::~__hash_table((uint64_t)this + 64);
  std::__hash_table<CLMicroLocationFingerprint::Measurement,CLMicroLocationFingerprint::Measurement::HashMeasurement,CLMicroLocationFingerprint::Measurement::PredicateMeasurement,std::allocator<CLMicroLocationFingerprint::Measurement>>::~__hash_table((uint64_t)this);
}

void CLMicroLocationModel::addRecording(CLMicroLocationModel *this, uuid *a2, const uuid *a3)
{
  _QWORD *v4;
  uuid *v5;
  unint64_t v6;
  uuid *v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char *v13;
  uuid *v14;
  char *v15;
  uuid *v16;
  uuid *v17;
  _OWORD *v18;

  v18 = a2;
  v4 = std::__hash_table<std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>>>::__emplace_unique_key_args<boost::uuids::uuid,std::piecewise_construct_t const&,std::tuple<boost::uuids::uuid const&>,std::tuple<>>((uint64_t)this + 352, a2, (uint64_t)&std::piecewise_construct, &v18);
  v5 = (uuid *)v4[5];
  v6 = v4[6];
  if ((unint64_t)v5 >= v6)
  {
    v8 = v4[4];
    v9 = ((uint64_t)v5 - v8) >> 4;
    v10 = v9 + 1;
    if ((unint64_t)(v9 + 1) >> 60)
      std::vector<CLMicroLocationProto::ConfidenceReason>::__throw_length_error[abi:ne180100]();
    v11 = v6 - v8;
    if (v11 >> 3 > v10)
      v10 = v11 >> 3;
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF0)
      v12 = 0xFFFFFFFFFFFFFFFLL;
    else
      v12 = v10;
    if (v12)
      v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<boost::uuids::uuid>>((uint64_t)(v4 + 6), v12);
    else
      v13 = 0;
    v14 = (uuid *)&v13[16 * v9];
    v15 = &v13[16 * v12];
    *v14 = *a3;
    v7 = v14 + 1;
    v17 = (uuid *)v4[4];
    v16 = (uuid *)v4[5];
    if (v16 != v17)
    {
      do
      {
        v14[-1] = v16[-1];
        --v14;
        --v16;
      }
      while (v16 != v17);
      v16 = (uuid *)v4[4];
    }
    v4[4] = v14;
    v4[5] = v7;
    v4[6] = v15;
    if (v16)
      operator delete(v16);
  }
  else
  {
    *v5 = *a3;
    v7 = v5 + 1;
  }
  v4[5] = v7;
}

uint64_t CLMicroLocationModel::setQualityIndicator(uint64_t result, int a2)
{
  *(_DWORD *)(result + 392) = a2;
  return result;
}

uint64_t CLMicroLocationModel::numRecordingsBeforePruning(CLMicroLocationModel *this)
{
  _QWORD *v1;
  uint64_t result;

  v1 = (_QWORD *)*((_QWORD *)this + 46);
  if (!v1)
    return 0;
  result = 0;
  do
  {
    result += (uint64_t)(v1[5] - v1[4]) >> 4;
    v1 = (_QWORD *)*v1;
  }
  while (v1);
  return result;
}

uint64_t CLMicroLocationModel::setCandidateQualityIndicator(uint64_t result, int a2)
{
  *(_DWORD *)(result + 396) = a2;
  return result;
}

char *CLMicroLocationModel::setCandidateQualityReasons(uint64_t a1, uint64_t a2)
{
  char *result;

  result = (char *)(a1 + 400);
  if (result != (char *)a2)
    return std::vector<CLMicroLocationProto::ConfidenceLevel>::__assign_with_size[abi:ne180100]<CLMicroLocationProto::ConfidenceLevel*,CLMicroLocationProto::ConfidenceLevel*>(result, *(char **)a2, *(_QWORD *)(a2 + 8), (uint64_t)(*(_QWORD *)(a2 + 8) - *(_QWORD *)a2) >> 2);
  return result;
}

void CLMicroLocationModel::SimilarityListData::fromProtobuf(CLMicroLocationModel::SimilarityListData *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4;
  uint64_t ***v5;
  uint64_t ***v6;
  char *v7;
  char *v8;
  NSObject *v9;
  NSObject *v10;
  char *v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  unint64_t v15;
  char *v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  char *v20;
  char *v21;
  char *v22;
  char *v23;
  char *v24;
  int v25;
  int v26;
  uint64_t v27;
  NSObject *v28;
  NSObject *v29;
  uint64_t v30;
  NSObject *v31;
  NSObject *v32;
  int v33;
  NSObject *v34;
  _OWORD *v35;
  void *p_p;
  _OWORD *v37;
  __int128 v38;
  char *v39;
  unint64_t v40;
  unint64_t v41;
  unint64_t v42;
  char *v43;
  char *v44;
  __int128 v45;
  char *v46;
  char *v47;
  char *v48;
  __int128 v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t i;
  void *__p;
  __int128 v57;
  void *v58;
  char *v59;
  char *v60;
  __int128 v61;
  char v62;
  __int128 v63;
  int v64;
  __int128 v65;
  char *v66;
  uint8_t buf[8];
  __int16 v68;
  const char *v69;
  __int16 v70;
  int v71;
  __int16 v72;
  void *v73;
  __int16 v74;
  int v75;
  uint64_t v76;

  v76 = *MEMORY[0x24BDAC8D0];
  v58 = 0;
  v59 = 0;
  v60 = 0;
  v4 = *((int *)this + 4);
  if ((_DWORD)v4)
  {
    v5 = (uint64_t ***)*((_QWORD *)this + 1);
    v6 = &v5[v4];
    do
    {
      CLMicroLocationProtobufHelper::uuidFromProtobuf(*v5, &v65);
      if ((_BYTE)v66)
      {
        v7 = v59;
        if (v59 >= v60)
        {
          v12 = (v59 - (_BYTE *)v58) >> 4;
          v13 = v12 + 1;
          if ((unint64_t)(v12 + 1) >> 60)
            std::vector<CLMicroLocationProto::ConfidenceReason>::__throw_length_error[abi:ne180100]();
          v14 = v60 - (_BYTE *)v58;
          if ((v60 - (_BYTE *)v58) >> 3 > v13)
            v13 = v14 >> 3;
          if ((unint64_t)v14 >= 0x7FFFFFFFFFFFFFF0)
            v15 = 0xFFFFFFFFFFFFFFFLL;
          else
            v15 = v13;
          if (v15)
            v16 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<boost::uuids::uuid>>((uint64_t)&v60, v15);
          else
            v16 = 0;
          v20 = &v16[16 * v12];
          *(_OWORD *)v20 = v65;
          v22 = (char *)v58;
          v21 = v59;
          v23 = v20;
          if (v59 != v58)
          {
            do
            {
              *((_OWORD *)v23 - 1) = *((_OWORD *)v21 - 1);
              v23 -= 16;
              v21 -= 16;
            }
            while (v21 != v22);
            goto LABEL_39;
          }
          goto LABEL_40;
        }
        *(_OWORD *)v59 = v65;
        v8 = v7 + 16;
      }
      else
      {
        if (onceToken_MicroLocation_Default != -1)
          dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_5);
        v9 = logObject_MicroLocation_Default;
        if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_ERROR))
        {
          *(_QWORD *)buf = 68289026;
          v68 = 2082;
          v69 = "";
          _os_log_impl(&dword_2419D9000, v9, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"CLMicroLocationSimilarityListData fromProtobuf - invalid clusterUuid conversion!\"}", buf, 0x12u);
        }
        if (onceToken_MicroLocation_Default != -1)
          dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_5);
        v10 = logObject_MicroLocation_Default;
        if (os_signpost_enabled((os_log_t)logObject_MicroLocation_Default))
        {
          *(_QWORD *)buf = 68289026;
          v68 = 2082;
          v69 = "";
          _os_signpost_emit_with_name_impl(&dword_2419D9000, v10, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "CLMicroLocationSimilarityListData fromProtobuf - invalid clusterUuid conversion!", "{\"msg%{public}.0s\":\"CLMicroLocationSimilarityListData fromProtobuf - invalid clusterUuid conversion!\"}", buf, 0x12u);
        }
        v11 = v59;
        if (v59 >= v60)
        {
          v17 = (v59 - (_BYTE *)v58) >> 4;
          v18 = v17 + 1;
          if ((unint64_t)(v17 + 1) >> 60)
            std::vector<CLMicroLocationProto::ConfidenceReason>::__throw_length_error[abi:ne180100]();
          v19 = v60 - (_BYTE *)v58;
          if ((v60 - (_BYTE *)v58) >> 3 > v18)
            v18 = v19 >> 3;
          if ((unint64_t)v19 >= 0x7FFFFFFFFFFFFFF0)
            v15 = 0xFFFFFFFFFFFFFFFLL;
          else
            v15 = v18;
          if (v15)
            v16 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<boost::uuids::uuid>>((uint64_t)&v60, v15);
          else
            v16 = 0;
          v20 = &v16[16 * v17];
          *(_QWORD *)v20 = 0;
          *((_QWORD *)v20 + 1) = 0;
          v24 = (char *)v58;
          v21 = v59;
          v23 = v20;
          if (v59 != v58)
          {
            do
            {
              *((_OWORD *)v23 - 1) = *((_OWORD *)v21 - 1);
              v23 -= 16;
              v21 -= 16;
            }
            while (v21 != v24);
LABEL_39:
            v21 = (char *)v58;
          }
LABEL_40:
          v8 = v20 + 16;
          v58 = v23;
          v59 = v20 + 16;
          v60 = &v16[16 * v15];
          if (v21)
            operator delete(v21);
          goto LABEL_42;
        }
        v8 = v59 + 16;
        *(_QWORD *)v59 = 0;
        *((_QWORD *)v11 + 1) = 0;
      }
LABEL_42:
      v59 = v8;
      ++v5;
    }
    while (v5 != v6);
  }
  v65 = 0uLL;
  v66 = 0;
  v25 = *((_DWORD *)this + 10);
  v26 = *((_DWORD *)this + 16);
  LODWORD(v27) = v25;
  if (v25 != v26)
  {
    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_5);
    v28 = logObject_MicroLocation_Default;
    if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_ERROR))
    {
      *(_QWORD *)buf = 68289026;
      v68 = 2082;
      v69 = "";
      _os_log_impl(&dword_2419D9000, v28, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"CLMicroLocationSimilarityListData fromProtobuf - size of confidences doesn't equal event number, setting all event's confidence to invalid\"}", buf, 0x12u);
    }
    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_5);
    v29 = logObject_MicroLocation_Default;
    if (os_signpost_enabled((os_log_t)logObject_MicroLocation_Default))
    {
      *(_QWORD *)buf = 68289026;
      v68 = 2082;
      v69 = "";
      _os_signpost_emit_with_name_impl(&dword_2419D9000, v29, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "CLMicroLocationSimilarityListData fromProtobuf - size of confidences doesn't equal event number, setting all event's confidence to invalid", "{\"msg%{public}.0s\":\"CLMicroLocationSimilarityListData fromProtobuf - size of confidences doesn't equal event number, setting all event's confidence to invalid\"}", buf, 0x12u);
    }
    LODWORD(v27) = *((_DWORD *)this + 10);
  }
  if ((int)v27 >= 1)
  {
    v30 = 0;
    do
    {
      if (v30 >= (int)v27)
      {
        wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
        wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
        wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
        wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)buf);
      }
      CLMicroLocationProtobufHelper::uuidFromProtobuf(*(uint64_t ***)(*(_QWORD *)(*((_QWORD *)this + 4) + 8 * v30) + 8), &v61);
      if (v62)
      {
        v63 = v61;
      }
      else
      {
        if (onceToken_MicroLocation_Default != -1)
          dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_5);
        v31 = logObject_MicroLocation_Default;
        if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_ERROR))
        {
          *(_QWORD *)buf = 68289026;
          v68 = 2082;
          v69 = "";
          _os_log_impl(&dword_2419D9000, v31, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"CLMicroLocationSimilarityListData fromProtobuf - invalid LabelUuid conversion!\"}", buf, 0x12u);
        }
        if (onceToken_MicroLocation_Default != -1)
          dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_5);
        v32 = logObject_MicroLocation_Default;
        if (os_signpost_enabled((os_log_t)logObject_MicroLocation_Default))
        {
          *(_QWORD *)buf = 68289026;
          v68 = 2082;
          v69 = "";
          _os_signpost_emit_with_name_impl(&dword_2419D9000, v32, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "CLMicroLocationSimilarityListData fromProtobuf - invalid LabelUuid conversion!", "{\"msg%{public}.0s\":\"CLMicroLocationSimilarityListData fromProtobuf - invalid LabelUuid conversion!\"}", buf, 0x12u);
        }
        v63 = 0uLL;
      }
      if (v25 == v26)
      {
        if (v30 >= *((int *)this + 16))
        {
          wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
          wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
          wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
          wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)buf);
        }
        v33 = *(_DWORD *)(*((_QWORD *)this + 7) + 4 * v30);
      }
      else
      {
        v33 = 0;
      }
      v64 = v33;
      if (onceToken_MicroLocation_Default != -1)
        dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_5);
      v34 = (id)logObject_MicroLocation_Default;
      if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
      {
        v35 = operator new(0x28uLL);
        __p = v35;
        v57 = xmmword_241BB2320;
        *v35 = 0u;
        v35[1] = 0u;
        *(_QWORD *)((char *)v35 + 29) = 0;
        boost::uuids::to_chars<char *>((uint64_t)&v63, v35);
        p_p = &__p;
        if (v57 < 0)
          p_p = __p;
        *(_QWORD *)buf = 68289794;
        v68 = 2082;
        v69 = "";
        v70 = 1026;
        v71 = v30;
        v72 = 2082;
        v73 = p_p;
        v74 = 1026;
        v75 = v64;
        _os_log_impl(&dword_2419D9000, v34, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLMicroLocationSimilarityListData fromProtobuf\", \"listElementInx\":%{public}d, \"event label\":%{public, location:escape_only}s, \"confidence level\":%{public}d}", buf, 0x28u);
        if (SHIBYTE(v57) < 0)
          operator delete(__p);
      }

      v37 = (_OWORD *)*((_QWORD *)&v65 + 1);
      if (*((_QWORD *)&v65 + 1) >= (unint64_t)v66)
      {
        v40 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*((_QWORD *)&v65 + 1) - v65) >> 2);
        v41 = v40 + 1;
        if (v40 + 1 > 0xCCCCCCCCCCCCCCCLL)
          std::vector<CLMicroLocationProto::ConfidenceReason>::__throw_length_error[abi:ne180100]();
        if (0x999999999999999ALL * ((uint64_t)&v66[-v65] >> 2) > v41)
          v41 = 0x999999999999999ALL * ((uint64_t)&v66[-v65] >> 2);
        if (0xCCCCCCCCCCCCCCCDLL * ((uint64_t)&v66[-v65] >> 2) >= 0x666666666666666)
          v42 = 0xCCCCCCCCCCCCCCCLL;
        else
          v42 = v41;
        if (v42)
          v43 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<CLMicroLocationModel::SimilarityListData::EventInformation>>((uint64_t)&v66, v42);
        else
          v43 = 0;
        v44 = &v43[20 * v40];
        v45 = v63;
        *((_DWORD *)v44 + 4) = v64;
        *(_OWORD *)v44 = v45;
        v46 = (char *)*((_QWORD *)&v65 + 1);
        v47 = (char *)v65;
        v48 = v44;
        if (*((_QWORD *)&v65 + 1) != (_QWORD)v65)
        {
          do
          {
            v49 = *(_OWORD *)(v46 - 20);
            *((_DWORD *)v48 - 1) = *((_DWORD *)v46 - 1);
            *(_OWORD *)(v48 - 20) = v49;
            v48 -= 20;
            v46 -= 20;
          }
          while (v46 != v47);
          v46 = (char *)v65;
        }
        v39 = v44 + 20;
        *(_QWORD *)&v65 = v48;
        *((_QWORD *)&v65 + 1) = v44 + 20;
        v66 = &v43[20 * v42];
        if (v46)
          operator delete(v46);
      }
      else
      {
        v38 = v63;
        *(_DWORD *)(*((_QWORD *)&v65 + 1) + 16) = v64;
        *v37 = v38;
        v39 = (char *)v37 + 20;
      }
      *((_QWORD *)&v65 + 1) = v39;
      ++v30;
      v27 = *((int *)this + 10);
    }
    while (v30 < v27);
  }
  *(_BYTE *)(a2 + 72) = 0;
  *(_BYTE *)(a2 + 112) = 0;
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  *(_OWORD *)(a2 + 32) = 0u;
  *(_BYTE *)(a2 + 48) = 0;
  *(_QWORD *)(a2 + 88) = 0;
  *(_QWORD *)(a2 + 96) = 0;
  *(_QWORD *)(a2 + 80) = 0;
  *(_BYTE *)(a2 + 104) = 0;
  CLMicroLocationModel::SimilarityListData::prepareWithClustersInformationOfEvents(a2, (unint64_t **)&v58, (uint64_t *)&v65);
  LODWORD(v50) = *((_DWORD *)this + 10);
  if ((int)v50 >= 1)
  {
    v51 = 0;
    do
    {
      if (v51 >= (int)v50)
      {
        wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
        wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
        wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
        wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)buf);
      }
      v52 = *(_QWORD *)(*((_QWORD *)this + 4) + 8 * v51);
      v53 = *(int *)(v52 + 24);
      if (v53 != (v59 - (_BYTE *)v58) >> 4)
      {
        CLMicroLocationModel::SimilarityListData::fromProtobuf((NSObject **)buf);

        abort_report_np();
        __break(1u);
      }
      if ((int)v53 >= 1)
      {
        for (i = 0; i < v53; ++i)
        {
          if (i >= (int)v53)
          {
            wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage();
            wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<();
            wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=();
            wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)buf);
          }
          CLMicroLocationUtils::ProbabilityMatrix::setValue((CLMicroLocationUtils::ProbabilityMatrix *)(a2 + 48), v51, i, *(double *)(*(_QWORD *)(v52 + 16) + 8 * i));
          v53 = *(int *)(v52 + 24);
        }
      }
      ++v51;
      v50 = *((int *)this + 10);
    }
    while (v51 < v50);
  }
  if ((_QWORD)v65)
  {
    *((_QWORD *)&v65 + 1) = v65;
    operator delete((void *)v65);
  }
  if (v58)
  {
    v59 = (char *)v58;
    operator delete(v58);
  }
}

void sub_2419FB1AC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, CLMicroLocationModel::SimilarityListData *a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,void *__p,uint64_t a26)
{
  uint64_t v26;
  void *v28;

  CLMicroLocationModel::SimilarityListData::~SimilarityListData(a13);
  v28 = *(void **)(v26 - 184);
  if (v28)
  {
    *(_QWORD *)(v26 - 176) = v28;
    operator delete(v28);
  }
  if (__p)
    operator delete(__p);
  _Unwind_Resume(a1);
}

uint64_t std::optional<CLMicroLocationModel::SimilarityListData>::operator=[abi:ne180100]<CLMicroLocationModel::SimilarityListData,void>(uint64_t a1, uint64_t a2)
{
  uint64_t v4;

  if (*(_BYTE *)(a1 + 120))
  {
    std::vector<CLMicroLocationResultInternal>::__move_assign(a1, (__n128 *)a2);
    std::vector<CLMicroLocationResultInternal>::__move_assign(a1 + 24, (__n128 *)(a2 + 24));
    std::__optional_storage_base<CLMicroLocationUtils::ProbabilityMatrix,false>::__assign_from[abi:ne180100]<std::__optional_move_assign_base<CLMicroLocationUtils::ProbabilityMatrix,false>>((uint64_t *)(a1 + 48), a2 + 48);
    std::vector<CLMicroLocationResultInternal>::__move_assign(a1 + 80, (__n128 *)(a2 + 80));
    v4 = *(_QWORD *)(a2 + 104);
    *(_BYTE *)(a1 + 112) = *(_BYTE *)(a2 + 112);
    *(_QWORD *)(a1 + 104) = v4;
  }
  else
  {
    std::__construct_at[abi:ne180100]<CLMicroLocationModel::SimilarityListData,CLMicroLocationModel::SimilarityListData,CLMicroLocationModel::SimilarityListData*>(a1, a2);
    *(_BYTE *)(a1 + 120) = 1;
  }
  return a1;
}

void CLMicroLocationModel::SimilarityListData::~SimilarityListData(CLMicroLocationModel::SimilarityListData *this)
{
  void *v2;
  uint64_t v3;
  void *v4;
  void *v5;

  v2 = (void *)*((_QWORD *)this + 10);
  if (v2)
  {
    *((_QWORD *)this + 11) = v2;
    operator delete(v2);
  }
  if (*((_BYTE *)this + 72))
  {
    v3 = *((_QWORD *)this + 6);
    *((_QWORD *)this + 6) = 0;
    if (v3)
      MEMORY[0x2426A04BC](v3, 0x1000C8000313F17);
  }
  v4 = (void *)*((_QWORD *)this + 3);
  if (v4)
  {
    *((_QWORD *)this + 4) = v4;
    operator delete(v4);
  }
  v5 = *(void **)this;
  if (*(_QWORD *)this)
  {
    *((_QWORD *)this + 1) = v5;
    operator delete(v5);
  }
}

_QWORD *CLMicroLocationModel::getIdentifiers@<X0>(_QWORD *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3;
  uint64_t v4;

  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  *(_DWORD *)(a2 + 32) = 1065353216;
  v3 = this[41];
  v4 = this[42];
  while (v3 != v4)
  {
    this = std::__hash_table<boost::uuids::uuid,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,std::allocator<boost::uuids::uuid>>::__emplace_unique_key_args<boost::uuids::uuid,boost::uuids::uuid const&>(a2, (_QWORD *)(v3 + 16), (_OWORD *)(v3 + 16));
    v3 += 32;
  }
  return this;
}

void sub_2419FB3C0(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>>>::~__hash_table(v1);
  _Unwind_Resume(a1);
}

void CLMicroLocationModel::SimilarityListData::prepareWithClustersInformationOfEvents(uint64_t a1, unint64_t **a2, uint64_t *a3)
{
  _QWORD *v6;
  uint64_t v7;
  void *v8;
  uint64_t v9;
  char **v10;
  void **v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  _OWORD *v15;
  _OWORD *v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  unint64_t v20;
  char *v21;
  char *v22;
  char *v23;
  char *v24;
  char *v25;
  unint64_t v26;
  char *v27;
  _DWORD *v28;
  char *v29;
  uint64_t v30;
  unint64_t v31;
  uint64_t v32;
  unint64_t v33;
  char *v34;
  char *v35;
  int v36;
  __int128 v37;
  uint64_t v38;
  _QWORD *v39;
  _QWORD *v40;
  char v41;

  CLMicroLocationUtils::ProbabilityMatrix::ProbabilityMatrix((CLMicroLocationUtils::ProbabilityMatrix *)&v37, -858993459 * ((unint64_t)(a3[1] - *a3) >> 2), (unint64_t)((char *)a2[1] - (char *)*a2) >> 4);
  CLMicroLocationUtils::ProbabilityMatrix::ProbabilityMatrix(&v39);
  v41 = 1;
  std::__optional_storage_base<CLMicroLocationUtils::ProbabilityMatrix,false>::__assign_from[abi:ne180100]<std::__optional_move_assign_base<CLMicroLocationUtils::ProbabilityMatrix,false>>((uint64_t *)(a1 + 48), (uint64_t)&v39);
  if (v41)
  {
    v6 = v39;
    v39 = 0;
    if (v6)
      MEMORY[0x2426A04BC](v6, 0x1000C8000313F17);
  }
  v7 = v37;
  *(_QWORD *)&v37 = 0;
  if (v7)
    MEMORY[0x2426A04BC](v7, 0x1000C8000313F17);
  std::set<boost::uuids::uuid>::set[abi:ne180100]<std::__wrap_iter<boost::uuids::uuid const*>>((uint64_t)&v39, *a2, a2[1]);
  std::vector<boost::uuids::uuid>::vector<std::__tree_const_iterator<boost::uuids::uuid,std::__tree_node<boost::uuids::uuid,void *> *,long>,0>(&v37, v39, &v40);
  v8 = *(void **)a1;
  if (*(_QWORD *)a1)
  {
    *(_QWORD *)(a1 + 8) = v8;
    operator delete(v8);
    *(_QWORD *)a1 = 0;
    *(_QWORD *)(a1 + 8) = 0;
    *(_QWORD *)(a1 + 16) = 0;
  }
  *(_OWORD *)a1 = v37;
  v10 = (char **)(a1 + 24);
  v9 = *(_QWORD *)(a1 + 24);
  *(_QWORD *)(a1 + 16) = v38;
  *(_QWORD *)(a1 + 32) = v9;
  v11 = (void **)(a1 + 80);
  *(_QWORD *)(a1 + 88) = *(_QWORD *)(a1 + 80);
  std::vector<boost::uuids::uuid>::reserve((void **)(a1 + 24), 0xCCCCCCCCCCCCCCCDLL * ((a3[1] - *a3) >> 2));
  std::vector<CLMicroLocationProto::ConfidenceLevel>::reserve((std::vector<int> *)(a1 + 80), 0xCCCCCCCCCCCCCCCDLL * ((a3[1] - *a3) >> 2));
  v12 = *a3;
  v13 = a3[1];
  if (*a3 != v13)
  {
    do
    {
      v15 = *(_OWORD **)(a1 + 32);
      v14 = *(_QWORD *)(a1 + 40);
      if ((unint64_t)v15 >= v14)
      {
        v17 = ((char *)v15 - *v10) >> 4;
        v18 = v17 + 1;
        if ((unint64_t)(v17 + 1) >> 60)
          std::vector<CLMicroLocationProto::ConfidenceReason>::__throw_length_error[abi:ne180100]();
        v19 = v14 - (_QWORD)*v10;
        if (v19 >> 3 > v18)
          v18 = v19 >> 3;
        if ((unint64_t)v19 >= 0x7FFFFFFFFFFFFFF0)
          v20 = 0xFFFFFFFFFFFFFFFLL;
        else
          v20 = v18;
        if (v20)
          v21 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<boost::uuids::uuid>>(a1 + 40, v20);
        else
          v21 = 0;
        v22 = &v21[16 * v17];
        *(_OWORD *)v22 = *(_OWORD *)v12;
        v24 = *(char **)(a1 + 24);
        v23 = *(char **)(a1 + 32);
        v25 = v22;
        if (v23 != v24)
        {
          do
          {
            *((_OWORD *)v25 - 1) = *((_OWORD *)v23 - 1);
            v25 -= 16;
            v23 -= 16;
          }
          while (v23 != v24);
          v23 = *v10;
        }
        v16 = v22 + 16;
        *(_QWORD *)(a1 + 24) = v25;
        *(_QWORD *)(a1 + 32) = v22 + 16;
        *(_QWORD *)(a1 + 40) = &v21[16 * v20];
        if (v23)
          operator delete(v23);
      }
      else
      {
        *v15 = *(_OWORD *)v12;
        v16 = v15 + 1;
      }
      *(_QWORD *)(a1 + 32) = v16;
      v27 = *(char **)(a1 + 88);
      v26 = *(_QWORD *)(a1 + 96);
      if ((unint64_t)v27 >= v26)
      {
        v29 = (char *)*v11;
        v30 = (v27 - (_BYTE *)*v11) >> 2;
        v31 = v30 + 1;
        if ((unint64_t)(v30 + 1) >> 62)
          std::vector<CLMicroLocationProto::ConfidenceReason>::__throw_length_error[abi:ne180100]();
        v32 = v26 - (_QWORD)v29;
        if (v32 >> 1 > v31)
          v31 = v32 >> 1;
        if ((unint64_t)v32 >= 0x7FFFFFFFFFFFFFFCLL)
          v33 = 0x3FFFFFFFFFFFFFFFLL;
        else
          v33 = v31;
        if (v33)
        {
          v34 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<CLMicroLocationProto::ConfidenceReason>>(a1 + 96, v33);
          v29 = *(char **)(a1 + 80);
          v27 = *(char **)(a1 + 88);
        }
        else
        {
          v34 = 0;
        }
        v35 = &v34[4 * v30];
        *(_DWORD *)v35 = *(_DWORD *)(v12 + 16);
        v28 = v35 + 4;
        while (v27 != v29)
        {
          v36 = *((_DWORD *)v27 - 1);
          v27 -= 4;
          *((_DWORD *)v35 - 1) = v36;
          v35 -= 4;
        }
        *(_QWORD *)(a1 + 80) = v35;
        *(_QWORD *)(a1 + 88) = v28;
        *(_QWORD *)(a1 + 96) = &v34[4 * v33];
        if (v29)
          operator delete(v29);
      }
      else
      {
        *(_DWORD *)v27 = *(_DWORD *)(v12 + 16);
        v28 = v27 + 4;
      }
      *(_QWORD *)(a1 + 88) = v28;
      v12 += 20;
    }
    while (v12 != v13);
  }
  std::__tree<std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>,std::__map_value_compare<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>,std::less<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes>,true>,std::allocator<std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>>>::destroy((uint64_t)&v39, v40);
}

void sub_2419FB704(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, _QWORD *a14)
{
  std::__tree<std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>,std::__map_value_compare<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>,std::less<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes>,true>,std::allocator<std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>>>::destroy((uint64_t)&a13, a14);
  _Unwind_Resume(a1);
}

CLMicroLocationModel::SimilarityListData *std::optional<CLMicroLocationModel::SimilarityListData>::operator=[abi:ne180100]<CLMicroLocationModel::SimilarityListData&,void>(CLMicroLocationModel::SimilarityListData *this, CLMicroLocationModel::SimilarityListData *a2)
{
  uint64_t v4;

  if (*((_BYTE *)this + 120))
  {
    if (this == a2)
    {
      std::__optional_storage_base<CLMicroLocationUtils::ProbabilityMatrix,false>::__assign_from[abi:ne180100]<std::__optional_copy_assign_base<CLMicroLocationUtils::ProbabilityMatrix,false> const&>((uint64_t *)this + 6, (unsigned __int8 *)this + 48);
    }
    else
    {
      std::vector<boost::uuids::uuid>::__assign_with_size[abi:ne180100]<boost::uuids::uuid*,boost::uuids::uuid*>((char *)this, *(char **)a2, *((_QWORD *)a2 + 1), (uint64_t)(*((_QWORD *)a2 + 1) - *(_QWORD *)a2) >> 4);
      std::vector<boost::uuids::uuid>::__assign_with_size[abi:ne180100]<boost::uuids::uuid*,boost::uuids::uuid*>((char *)this + 24, *((char **)a2 + 3), *((_QWORD *)a2 + 4), (uint64_t)(*((_QWORD *)a2 + 4) - *((_QWORD *)a2 + 3)) >> 4);
      std::__optional_storage_base<CLMicroLocationUtils::ProbabilityMatrix,false>::__assign_from[abi:ne180100]<std::__optional_copy_assign_base<CLMicroLocationUtils::ProbabilityMatrix,false> const&>((uint64_t *)this + 6, (unsigned __int8 *)a2 + 48);
      std::vector<CLMicroLocationProto::ConfidenceLevel>::__assign_with_size[abi:ne180100]<CLMicroLocationProto::ConfidenceLevel*,CLMicroLocationProto::ConfidenceLevel*>((char *)this + 80, *((char **)a2 + 10), *((_QWORD *)a2 + 11), (uint64_t)(*((_QWORD *)a2 + 11) - *((_QWORD *)a2 + 10)) >> 2);
    }
    v4 = *((_QWORD *)a2 + 13);
    *((_BYTE *)this + 112) = *((_BYTE *)a2 + 112);
    *((_QWORD *)this + 13) = v4;
  }
  else
  {
    CLMicroLocationModel::SimilarityListData::SimilarityListData(this, a2);
    *((_BYTE *)this + 120) = 1;
  }
  return this;
}

float CLMicroLocationModel::BlueAtlasData::fromProtobuf@<S0>(uint64_t ****this@<X0>, unint64_t a2@<X1>, char **a3@<X8>)
{
  __int128 v4;
  uint64_t v5;
  uint64_t ***v6;
  uint64_t ***v7;
  unint64_t v8;
  char *v9;
  char *v10;
  NSObject *v11;
  NSObject *v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t ****v16;
  char *v17;
  char *v18;
  uint64_t ****v19;
  uint64_t v20;
  CLMacAddress **v21;
  CLMacAddress **v22;
  CLMicroLocationModel::BlueAtlasData **v23;
  CLMicroLocationModel::BlueAtlasData *v24;
  unint64_t v25;
  CLMicroLocationModel::BlueAtlasData *v26;
  char *v27;
  uint64_t v28;
  unint64_t v29;
  uint64_t v30;
  char *v31;
  CLMicroLocationModel::BlueAtlasData **v32;
  CLMicroLocationModel::BlueAtlasData *v33;
  uint64_t v34;
  CLMicroLocationProto::BlueAtlasData *v35;
  uint64_t v36;
  CLMicroLocationModel::BlueAtlasData *v38;
  uint8_t buf[4];
  int v40;
  __int16 v41;
  const char *v42;
  __int128 v43;
  char v44;
  uint64_t v45;

  v45 = *MEMORY[0x24BDAC8D0];
  *((_BYTE *)a3 + 56) = 0;
  *((_BYTE *)a3 + 64) = 0;
  *((_BYTE *)a3 + 72) = 0;
  LODWORD(v4) = 0;
  *(_OWORD *)a3 = 0u;
  *((_OWORD *)a3 + 1) = 0u;
  *((_OWORD *)a3 + 2) = 0u;
  *((_BYTE *)a3 + 48) = 0;
  *((_DWORD *)a3 + 20) = -8388609;
  v38 = (CLMicroLocationModel::BlueAtlasData *)this;
  v5 = *((int *)this + 4);
  if ((_DWORD)v5)
  {
    v6 = this[1];
    v7 = &v6[v5];
    do
    {
      this = (uint64_t ****)CLMicroLocationProtobufHelper::uuidFromProtobuf(*v6, &v43);
      if (v44)
      {
        v9 = a3[1];
        v8 = (unint64_t)a3[2];
        if ((unint64_t)v9 >= v8)
        {
          v13 = (v9 - *a3) >> 4;
          v14 = v13 + 1;
          if ((unint64_t)(v13 + 1) >> 60)
            std::vector<CLMicroLocationProto::ConfidenceReason>::__throw_length_error[abi:ne180100]();
          v15 = v8 - (_QWORD)*a3;
          if (v15 >> 3 > v14)
            v14 = v15 >> 3;
          if ((unint64_t)v15 >= 0x7FFFFFFFFFFFFFF0)
            a2 = 0xFFFFFFFFFFFFFFFLL;
          else
            a2 = v14;
          if (a2)
            this = (uint64_t ****)std::__allocate_at_least[abi:ne180100]<std::allocator<boost::uuids::uuid>>((uint64_t)(a3 + 2), a2);
          else
            this = 0;
          v16 = &this[2 * v13];
          LODWORD(v4) = v43;
          *(_OWORD *)v16 = v43;
          v18 = *a3;
          v17 = a3[1];
          v19 = v16;
          if (v17 != *a3)
          {
            do
            {
              v4 = *((_OWORD *)v17 - 1);
              *((_OWORD *)v19 - 1) = v4;
              v19 -= 2;
              v17 -= 16;
            }
            while (v17 != v18);
            v17 = *a3;
          }
          v10 = (char *)(v16 + 2);
          *a3 = (char *)v19;
          a3[1] = (char *)(v16 + 2);
          a3[2] = (char *)&this[2 * a2];
          if (v17)
            operator delete(v17);
        }
        else
        {
          LODWORD(v4) = v43;
          *(_OWORD *)v9 = v43;
          v10 = v9 + 16;
        }
        a3[1] = v10;
      }
      else
      {
        if (onceToken_MicroLocation_Default != -1)
          dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_5);
        v11 = logObject_MicroLocation_Default;
        if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 68289026;
          v40 = 0;
          v41 = 2082;
          v42 = "";
          _os_log_impl(&dword_2419D9000, v11, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"CLMicroLocationModel::BlueAtlasData fromProtobuf - invalid LabelUuid conversion!\"}", buf, 0x12u);
        }
        if (onceToken_MicroLocation_Default != -1)
          dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_5);
        v12 = logObject_MicroLocation_Default;
        this = (uint64_t ****)os_signpost_enabled((os_log_t)logObject_MicroLocation_Default);
        if ((_DWORD)this)
        {
          *(_DWORD *)buf = 68289026;
          v40 = 0;
          v41 = 2082;
          v42 = "";
          _os_signpost_emit_with_name_impl(&dword_2419D9000, v12, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "CLMicroLocationModel::BlueAtlasData fromProtobuf - invalid LabelUuid conversion!", "{\"msg%{public}.0s\":\"CLMicroLocationModel::BlueAtlasData fromProtobuf - invalid LabelUuid conversion!\"}", buf, 0x12u);
        }
      }
      ++v6;
    }
    while (v6 != v7);
  }
  v20 = *((int *)v38 + 10);
  if ((_DWORD)v20)
  {
    v21 = (CLMacAddress **)*((_QWORD *)v38 + 4);
    v22 = &v21[v20];
    v23 = (CLMicroLocationModel::BlueAtlasData **)(a3 + 3);
    do
    {
      this = (uint64_t ****)CLMacAddress::newFromUint64(*v21, a2);
      v24 = (CLMicroLocationModel::BlueAtlasData *)this;
      v26 = (CLMicroLocationModel::BlueAtlasData *)a3[4];
      v25 = (unint64_t)a3[5];
      if ((unint64_t)v26 >= v25)
      {
        this = (uint64_t ****)*v23;
        v28 = (v26 - *v23) >> 3;
        v29 = v28 + 1;
        if ((unint64_t)(v28 + 1) >> 61)
          std::vector<CLMicroLocationProto::ConfidenceReason>::__throw_length_error[abi:ne180100]();
        v30 = v25 - (_QWORD)this;
        if (v30 >> 2 > v29)
          v29 = v30 >> 2;
        if ((unint64_t)v30 >= 0x7FFFFFFFFFFFFFF8)
          a2 = 0x1FFFFFFFFFFFFFFFLL;
        else
          a2 = v29;
        if (a2)
        {
          v31 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<CLMicroLocationWiFiChannelHistogram>>((uint64_t)(a3 + 5), a2);
          this = (uint64_t ****)a3[3];
          v26 = (CLMicroLocationModel::BlueAtlasData *)a3[4];
        }
        else
        {
          v31 = 0;
        }
        v32 = (CLMicroLocationModel::BlueAtlasData **)&v31[8 * v28];
        *v32 = v24;
        v27 = (char *)(v32 + 1);
        while (v26 != (CLMicroLocationModel::BlueAtlasData *)this)
        {
          v33 = (CLMicroLocationModel::BlueAtlasData *)*((_QWORD *)v26 - 1);
          v26 = (CLMicroLocationModel::BlueAtlasData *)((char *)v26 - 8);
          *--v32 = v33;
        }
        a3[3] = (char *)v32;
        a3[4] = v27;
        a3[5] = &v31[8 * a2];
        if (this)
          operator delete(this);
      }
      else
      {
        *(_QWORD *)v26 = this;
        v27 = (char *)v26 + 8;
      }
      a3[4] = v27;
      ++v21;
    }
    while (v21 != v22);
  }
  if ((*((_BYTE *)v38 + 60) & 4) != 0)
  {
    v34 = *((_QWORD *)v38 + 6);
    if (!v34)
      v34 = *(_QWORD *)(CLMicroLocationProto::BlueAtlasData::default_instance((CLMicroLocationProto::BlueAtlasData *)this)
                      + 48);
    v35 = (CLMicroLocationProto::BlueAtlasData *)CLMacAddress::newFromUint64(*(CLMacAddress **)(v34 + 8), a2);
    if (!*((_BYTE *)a3 + 72))
      *((_BYTE *)a3 + 72) = 1;
    a3[8] = (char *)v35;
    v36 = *((_QWORD *)v38 + 6);
    if (!v36)
      v36 = *(_QWORD *)(CLMicroLocationProto::BlueAtlasData::default_instance(v35) + 48);
    LODWORD(v4) = *(_DWORD *)(v36 + 16);
    *((_DWORD *)a3 + 20) = v4;
  }
  return *(float *)&v4;
}

void sub_2419FBC24(_Unwind_Exception *a1)
{
  CLMicroLocationModel::BlueAtlasData *v1;

  CLMicroLocationModel::BlueAtlasData::~BlueAtlasData(v1);
  _Unwind_Resume(a1);
}

uint64_t std::optional<CLMicroLocationModel::BlueAtlasData>::operator=[abi:ne180100]<CLMicroLocationModel::BlueAtlasData,void>(uint64_t a1, uint64_t a2)
{
  __int128 v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;

  if (*(_BYTE *)(a1 + 88))
  {
    std::vector<CLMicroLocationResultInternal>::__move_assign(a1, (__n128 *)a2);
    std::vector<CLMicroLocationResultInternal>::__move_assign(a1 + 24, (__n128 *)(a2 + 24));
    v4 = *(_OWORD *)(a2 + 48);
    v5 = *(_OWORD *)(a2 + 64);
    *(_DWORD *)(a1 + 80) = *(_DWORD *)(a2 + 80);
    *(_OWORD *)(a1 + 48) = v4;
    *(_OWORD *)(a1 + 64) = v5;
  }
  else
  {
    *(_QWORD *)a1 = 0;
    *(_QWORD *)(a1 + 8) = 0;
    *(_QWORD *)(a1 + 16) = 0;
    *(_OWORD *)a1 = *(_OWORD *)a2;
    *(_QWORD *)(a1 + 16) = *(_QWORD *)(a2 + 16);
    *(_QWORD *)a2 = 0;
    *(_QWORD *)(a2 + 8) = 0;
    *(_QWORD *)(a2 + 16) = 0;
    *(_QWORD *)(a1 + 24) = 0;
    *(_QWORD *)(a1 + 32) = 0;
    *(_QWORD *)(a1 + 40) = 0;
    *(_OWORD *)(a1 + 24) = *(_OWORD *)(a2 + 24);
    *(_QWORD *)(a1 + 40) = *(_QWORD *)(a2 + 40);
    *(_QWORD *)(a2 + 24) = 0;
    *(_QWORD *)(a2 + 32) = 0;
    *(_QWORD *)(a2 + 40) = 0;
    v6 = *(_OWORD *)(a2 + 48);
    v7 = *(_OWORD *)(a2 + 64);
    *(_DWORD *)(a1 + 80) = *(_DWORD *)(a2 + 80);
    *(_OWORD *)(a1 + 48) = v6;
    *(_OWORD *)(a1 + 64) = v7;
    *(_BYTE *)(a1 + 88) = 1;
  }
  return a1;
}

void CLMicroLocationModel::BlueAtlasData::~BlueAtlasData(CLMicroLocationModel::BlueAtlasData *this)
{
  void *v2;
  void *v3;

  v2 = (void *)*((_QWORD *)this + 3);
  if (v2)
  {
    *((_QWORD *)this + 4) = v2;
    operator delete(v2);
  }
  v3 = *(void **)this;
  if (*(_QWORD *)this)
  {
    *((_QWORD *)this + 1) = v3;
    operator delete(v3);
  }
}

void CLMicroLocationModel::~CLMicroLocationModel(void **this)
{
  void *v2;
  void **v3;

  if (*((char *)this + 447) < 0)
    operator delete(this[53]);
  v2 = this[50];
  if (v2)
  {
    this[51] = v2;
    operator delete(v2);
  }
  std::__hash_table<std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>>>::~__hash_table((uint64_t)(this + 44));
  v3 = this + 41;
  std::vector<std::pair<std::shared_ptr<CLMicroLocationFingerprint>,boost::uuids::uuid>>::__destroy_vector::operator()[abi:ne180100](&v3);
  std::__optional_destruct_base<CLMicroLocationModel::BlueAtlasData,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)(this + 25));
  std::__optional_destruct_base<CLMicroLocationModel::SimilarityListData,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)(this + 9));
  std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>>>::~__hash_table((uint64_t)(this + 2));
}

_QWORD *CLMicroLocationModel::getPredictionClasses@<X0>(_QWORD *this@<X0>, uint64_t a2@<X8>)
{
  unsigned int v3;
  const void *v4;
  uint64_t v5;
  uint64_t *v6;
  _Unwind_Exception *PredictionClasses;
  void *v8;
  _BYTE v9[16];
  uint64_t *v10;
  void **i;

  v3 = *((_DWORD *)this + 1);
  if (v3 < 2)
  {
    CLMicroLocationModel::getIdentifiers(this, (uint64_t)v9);
    *(_QWORD *)a2 = 0;
    *(_QWORD *)(a2 + 8) = 0;
    *(_QWORD *)(a2 + 16) = 0;
    v6 = v10;
    for (i = (void **)a2; v6; v6 = (uint64_t *)*v6)
      std::back_insert_iterator<std::vector<boost::uuids::uuid>>::operator=[abi:ne180100](&i, (_OWORD *)v6 + 1);
    return (_QWORD *)std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>>>::~__hash_table((uint64_t)v9);
  }
  else
  {
    if (v3 == 2)
    {
      if (*((_BYTE *)this + 192))
      {
        *(_QWORD *)a2 = 0;
        *(_QWORD *)(a2 + 8) = 0;
        *(_QWORD *)(a2 + 16) = 0;
        v4 = (const void *)this[12];
        v5 = this[13];
        return std::vector<boost::uuids::uuid>::__init_with_size[abi:ne180100]<boost::uuids::uuid*,boost::uuids::uuid*>((_QWORD *)a2, v4, v5, (v5 - (uint64_t)v4) >> 4);
      }
    }
    else
    {
      if (v3 != 3)
      {
        PredictionClasses = (_Unwind_Exception *)CLMicroLocationModel::getPredictionClasses();
        v8 = *(void **)a2;
        if (*(_QWORD *)a2)
        {
          *(_QWORD *)(a2 + 8) = v8;
          operator delete(v8);
        }
        std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>>>::~__hash_table((uint64_t)v9);
        _Unwind_Resume(PredictionClasses);
      }
      if (*((_BYTE *)this + 288))
      {
        *(_QWORD *)a2 = 0;
        *(_QWORD *)(a2 + 8) = 0;
        *(_QWORD *)(a2 + 16) = 0;
        v4 = (const void *)this[25];
        v5 = this[26];
        return std::vector<boost::uuids::uuid>::__init_with_size[abi:ne180100]<boost::uuids::uuid*,boost::uuids::uuid*>((_QWORD *)a2, v4, v5, (v5 - (uint64_t)v4) >> 4);
      }
    }
    *(_QWORD *)a2 = 0;
    *(_QWORD *)(a2 + 8) = 0;
    *(_QWORD *)(a2 + 16) = 0;
  }
  return this;
}

BOOL CLMicroLocationModel::isValid(CLMicroLocationModel *this)
{
  uint64_t v1;
  uint64_t v2;
  _BOOL8 v3;
  _QWORD *v5;
  _QWORD *v6;
  _BYTE v8[16];
  _QWORD *v9;
  uint64_t v10;

  v1 = *((_QWORD *)this + 41);
  v2 = *((_QWORD *)this + 42);
  v3 = v1 == v2 && *((_DWORD *)this + 1) == 3;
  if (v1 != v2)
  {
    if (*((_QWORD *)this + 47))
    {
      CLMicroLocationModel::getIdentifiers(this, (uint64_t)v8);
      if (v10 == *((_QWORD *)this + 47))
      {
        v5 = v9;
        if (v9)
        {
          v6 = (_QWORD *)((char *)this + 352);
          LOBYTE(v3) = 1;
          do
          {
            v3 = v3
              && std::__hash_table<std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>>>::find<boost::uuids::uuid>(v6, v5 + 2) != 0;
            v5 = (_QWORD *)*v5;
          }
          while (v5);
        }
        else
        {
          v3 = 1;
        }
      }
      else
      {
        v3 = 0;
      }
      std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>>>::~__hash_table((uint64_t)v8);
    }
    else
    {
      return 0;
    }
  }
  return v3;
}

void sub_2419FBF74(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>>>::~__hash_table((uint64_t)va);
  _Unwind_Resume(a1);
}

_QWORD *CLMicroLocationModel::mapIdentifiers(_QWORD *result, _QWORD *a2)
{
  _QWORD *v3;
  _QWORD *i;
  char v6;
  _QWORD *v7;
  _QWORD *v8;
  _QWORD *v9;
  _QWORD *v10;
  CLMicroLocationModel *v11;
  unint64_t v12;

  v3 = result;
  for (i = (_QWORD *)a2[2]; i; i = (_QWORD *)*i)
  {
    if (i[2] != i[4] || i[3] != i[5])
    {
      result = std::__hash_table<std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>>>::find<boost::uuids::uuid>(v3 + 44, i + 2);
      if (result)
      {
        std::__hash_table<std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>>>::__emplace_unique_key_args<boost::uuids::uuid,boost::uuids::uuid const&,std::vector<boost::uuids::uuid>>((uint64_t)(v3 + 44), i + 4, (_OWORD *)i + 2, (__int128 *)result + 2);
        if ((v6 & 1) == 0)
        {
          v11 = (CLMicroLocationModel *)CLMicroLocationModel::mapIdentifiers();
          return (_QWORD *)CLMicroLocationModel::generateRandomIdentifiers(v11, v12);
        }
        result = std::__hash_table<std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>>>::__erase_unique<boost::uuids::uuid>(v3 + 44, i + 2);
      }
    }
  }
  v7 = (_QWORD *)v3[41];
  v8 = (_QWORD *)v3[42];
  if (v7 != v8)
  {
    v9 = v7 + 2;
    do
    {
      result = std::__hash_table<std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>>>::find<boost::uuids::uuid>(a2, v9);
      if (result)
        *(_OWORD *)v9 = *((_OWORD *)result + 2);
      v10 = v9 + 2;
      v9 += 4;
    }
    while (v10 != v8);
  }
  return result;
}

uint64_t CLMicroLocationModel::generateRandomIdentifiers@<X0>(unint64_t this@<X0>, void **a2@<X8>)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t *v9;
  _QWORD *v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  unint64_t v14;
  char *v15;
  uint64_t *v16;
  char *v17;
  char *v18;
  uint64_t *v19;
  int v21;

  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  v21 = 0;
  boost::uuids::detail::random_provider_base::random_provider_base((boost::uuids::detail::random_provider_base *)&v21);
  if (this)
  {
    do
    {
      v4 = boost::uuids::random_generator_pure::operator()((uint64_t)&v21);
      v6 = v4;
      v7 = v5;
      v9 = (uint64_t *)a2[1];
      v8 = (unint64_t)a2[2];
      if ((unint64_t)v9 >= v8)
      {
        v11 = ((char *)v9 - (_BYTE *)*a2) >> 4;
        v12 = v11 + 1;
        if ((unint64_t)(v11 + 1) >> 60)
          std::vector<CLMicroLocationProto::ConfidenceReason>::__throw_length_error[abi:ne180100]();
        v13 = v8 - (_QWORD)*a2;
        if (v13 >> 3 > v12)
          v12 = v13 >> 3;
        if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF0)
          v14 = 0xFFFFFFFFFFFFFFFLL;
        else
          v14 = v12;
        if (v14)
          v15 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<boost::uuids::uuid>>((uint64_t)(a2 + 2), v14);
        else
          v15 = 0;
        v16 = (uint64_t *)&v15[16 * v11];
        *v16 = v6;
        v16[1] = v7;
        v18 = (char *)*a2;
        v17 = (char *)a2[1];
        v19 = v16;
        if (v17 != *a2)
        {
          do
          {
            *((_OWORD *)v19 - 1) = *((_OWORD *)v17 - 1);
            v19 -= 2;
            v17 -= 16;
          }
          while (v17 != v18);
          v17 = (char *)*a2;
        }
        v10 = v16 + 2;
        *a2 = v19;
        a2[1] = v16 + 2;
        a2[2] = &v15[16 * v14];
        if (v17)
          operator delete(v17);
      }
      else
      {
        *v9 = v4;
        v9[1] = v5;
        v10 = v9 + 2;
      }
      a2[1] = v10;
    }
    while (this > ((char *)v10 - (_BYTE *)*a2) >> 4);
  }
  return boost::uuids::detail::random_provider_base::destroy((boost::uuids::detail::random_provider_base *)&v21);
}

void sub_2419FC1AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, char a11)
{
  uint64_t v11;
  void *v13;

  boost::uuids::detail::random_provider_base::destroy((boost::uuids::detail::random_provider_base *)&a11);
  v13 = *(void **)v11;
  if (*(_QWORD *)v11)
  {
    *(_QWORD *)(v11 + 8) = v13;
    operator delete(v13);
  }
  _Unwind_Resume(a1);
}

void CLMicroLocationModel::mapIdentifiersFromOldModel(CLMicroLocationModel *this, const CLMicroLocationModel *a2, NSMutableDictionary *a3)
{
  _QWORD *i;
  uint64_t *v6;
  __int128 *v7;
  _QWORD *v8;
  _QWORD *v9;
  void *v10;
  void *v11;
  void *v12;
  void *v13;
  int v14;
  int v15;
  void *v16;
  void *v17;
  void *v18;
  void *v19;
  double v20;
  double v21;
  uint64_t *v22;
  double v23;
  double v24;
  _QWORD *v25;
  _QWORD *v26;
  _QWORD *v27;
  _QWORD *v28;
  _QWORD *v29;
  unint64_t v30;
  double v31;
  _QWORD *v32;
  _QWORD *v33;
  BOOL v34;
  double v36;
  void *v37;
  void *v38;
  __int128 v39;
  uint64_t *v40;
  uint64_t *v43;
  uint64_t *v44;
  uint64_t v45;
  uint64_t *v46;
  _QWORD *v47;
  uint64_t *v48;
  _QWORD *v49;
  uint64_t v50;
  uint64_t **v51;
  uint64_t **v52;
  uint64_t **v53;
  __int128 *v54;
  uint64_t v55;
  void *v56;
  uint64_t **v57;
  NSMutableDictionary *v58;
  uint64_t *v59;
  _QWORD *v60;
  uint64_t v61;
  uint64_t *v62;
  _QWORD *v63;
  uint64_t v64;
  _BYTE v65[16];
  _QWORD *v66;
  uint64_t v67;
  _QWORD v68[2];
  uint64_t *v69;
  CLMicroLocationModel *v70;
  _QWORD v71[2];
  void *__p[2];
  __int128 v73;
  __int128 v74;
  __int128 v75;
  int v76;
  __int128 v77;
  char v78;
  __int128 v79;
  __int128 v80;
  uint64_t v81;

  v81 = *MEMORY[0x24BDAC8D0];
  v58 = a3;
  CLMicroLocationModel::getIdentifiers(this, (uint64_t)v68);
  CLMicroLocationModel::getIdentifiers(a2, (uint64_t)v65);
  if (v70 == *((CLMicroLocationModel **)this + 47) && v67 == *((_QWORD *)a2 + 47))
  {
    for (i = v66; v66; i = v66)
    {
      while (!std::__hash_table<std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>>>::find<boost::uuids::uuid>(v68, i + 2))
      {
        i = (_QWORD *)*i;
        if (!i)
          goto LABEL_16;
      }
      CLMicroLocationModel::generateRandomIdentifiers((unint64_t)v70, __p);
      v74 = 0u;
      v75 = 0u;
      v76 = 1065353216;
      v6 = v69;
      if (v69)
      {
        v7 = (__int128 *)__p[0];
        do
        {
          v79 = *((_OWORD *)v6 + 1);
          v80 = *v7;
          std::__hash_table<std::__hash_value_type<boost::uuids::uuid,boost::uuids::uuid>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,boost::uuids::uuid>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,boost::uuids::uuid>>>::__emplace_unique_key_args<boost::uuids::uuid,std::pair<boost::uuids::uuid const,boost::uuids::uuid>>((uint64_t)&v74, &v79, &v79);
          v6 = (uint64_t *)*v6;
          ++v7;
        }
        while (v6);
      }
      CLMicroLocationModel::mapIdentifiers(this, &v74);
      std::__hash_table<boost::uuids::uuid,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,std::allocator<boost::uuids::uuid>>::clear(v68);
      v8 = __p[0];
      v9 = __p[1];
      while (v8 != v9)
      {
        std::__hash_table<boost::uuids::uuid,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,std::allocator<boost::uuids::uuid>>::__emplace_unique_key_args<boost::uuids::uuid,boost::uuids::uuid const&>((uint64_t)v68, v8, v8);
        v8 += 2;
      }
      std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>>>::~__hash_table((uint64_t)&v74);
      if (__p[0])
      {
        __p[1] = __p[0];
        operator delete(__p[0]);
      }
    }
LABEL_16:
    v63 = 0;
    v64 = 0;
    v62 = (uint64_t *)&v63;
    +[ULDefaultsSingleton shared](ULDefaultsSingleton, "shared");
    v10 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v10, "defaultsDictionary");
    v11 = (void *)objc_claimAutoreleasedReturnValue();

    objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "ULFingerprintDistanceFunctionType");
    v12 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v11, "objectForKey:", v12);
    v13 = (void *)objc_claimAutoreleasedReturnValue();
    if (v13 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
      v14 = objc_msgSend(v13, "unsignedIntValue");
    else
      v14 = objc_msgSend(&unk_2511ED348, "unsignedIntValue");
    v15 = v14;

    ULSettings::getFingerprintDistanceFunctionParamsForType(v15);
    v56 = (void *)objc_claimAutoreleasedReturnValue();
    std::unordered_map<boost::uuids::uuid,CLMicroLocationAnchorAppearance>::unordered_map((uint64_t)&v74, (uint64_t)this + 16);
    v77 = *(_OWORD *)((char *)this + 56);
    v78 = 1;
    CLMicroLocationAlgorithms::createLearnFingerprintDistanceFunction(v15, v56);
    if (v78)
      std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>>>::~__hash_table((uint64_t)&v74);
    +[ULDefaultsSingleton shared](ULDefaultsSingleton, "shared");
    v16 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v16, "defaultsDictionary");
    v17 = (void *)objc_claimAutoreleasedReturnValue();

    objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "ULClusterPersistenceDistanceThreshold");
    v18 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v17, "objectForKey:", v18);
    v19 = (void *)objc_claimAutoreleasedReturnValue();
    if (v19 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
      objc_msgSend(v19, "doubleValue");
    else
      objc_msgSend(&unk_2511ECD58, "doubleValue");
    v21 = v20;

    v22 = v69;
    if (v69)
    {
      v23 = 0.0;
      v24 = 1.79769313e308;
      while (1)
      {
        v25 = v66;
        v57 = (uint64_t **)v22;
        if (v66)
          break;
        v36 = v24;
LABEL_60:
        v22 = *v57;
        v24 = v36;
        if (!*v57)
          goto LABEL_61;
      }
      v26 = v22 + 2;
      while (1)
      {
        v27 = v25 + 2;
        v28 = (_QWORD *)*((_QWORD *)this + 41);
        v29 = (_QWORD *)*((_QWORD *)this + 42);
        if (v28 == v29)
        {
          v30 = 0;
          v31 = 0.0;
        }
        else
        {
          v30 = 0;
          v31 = 0.0;
          do
          {
            v33 = (_QWORD *)*((_QWORD *)a2 + 41);
            v32 = (_QWORD *)*((_QWORD *)a2 + 42);
            while (v33 != v32)
            {
              v34 = v28[2] == *v26 && v28[3] == v26[1];
              if (v34 && v33[2] == *v27 && v33[3] == v25[3])
              {
                if (!*((_QWORD *)&v80 + 1))
                  std::__throw_bad_function_call[abi:ne180100]();
                ++v30;
                v31 = v31
                    + (*(double (**)(_QWORD, _QWORD, _QWORD))(**((_QWORD **)&v80 + 1) + 48))(*((_QWORD *)&v80 + 1), *v28, *v33);
              }
              v33 += 4;
            }
            v28 += 4;
          }
          while (v28 != v29);
        }
        v36 = v31 / (double)v30;
        __p[0] = *(void **)&v36;
        if (v36 >= v21)
        {
          if (v36 >= v24)
          {
LABEL_56:
            v36 = v24;
            goto LABEL_57;
          }
          objc_msgSend(MEMORY[0x24BDD16E0], "numberWithDouble:", v36);
          v38 = (void *)objc_claimAutoreleasedReturnValue();
          -[NSMutableDictionary setObject:forKeyedSubscript:](v58, "setObject:forKeyedSubscript:", v38, CFSTR("minDistanceAbovePersistenceThreshold"));
        }
        else
        {
          v74 = *(_OWORD *)v26;
          v75 = *(_OWORD *)v27;
          std::__tree<std::__value_type<double,std::pair<boost::uuids::uuid const,boost::uuids::uuid>>,std::__map_value_compare<double,std::__value_type<double,std::pair<boost::uuids::uuid const,boost::uuids::uuid>>,std::less<double>,true>,std::allocator<std::__value_type<double,std::pair<boost::uuids::uuid const,boost::uuids::uuid>>>>::__emplace_multi<double &,std::pair<boost::uuids::uuid const,boost::uuids::uuid>>(&v62, (double *)__p, &v74);
          v37 = __p[0];
          if (*(double *)__p <= v23)
            goto LABEL_56;
          objc_msgSend(MEMORY[0x24BDD16E0], "numberWithDouble:", *(double *)__p);
          v38 = (void *)objc_claimAutoreleasedReturnValue();
          -[NSMutableDictionary setObject:forKeyedSubscript:](v58, "setObject:forKeyedSubscript:", v38, CFSTR("maxDistanceBelowPersistenceThreshold"));
          v36 = v24;
          v23 = *(double *)&v37;
        }

LABEL_57:
        v25 = (_QWORD *)*v25;
        v24 = v36;
        if (!v25)
          goto LABEL_60;
      }
    }
LABEL_61:
    v74 = 0u;
    v75 = 0u;
    v76 = 1065353216;
    while (v64)
    {
      v39 = *(_OWORD *)(v62 + 7);
      *(_OWORD *)__p = *(_OWORD *)(v62 + 5);
      v73 = v39;
      std::__hash_table<std::__hash_value_type<boost::uuids::uuid,boost::uuids::uuid>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,boost::uuids::uuid>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,boost::uuids::uuid>>>::__emplace_unique_key_args<boost::uuids::uuid,std::pair<boost::uuids::uuid const,boost::uuids::uuid> const&>((uint64_t)&v74, __p, __p);
      v60 = 0;
      v61 = 0;
      v59 = (uint64_t *)&v60;
      v40 = v62;
      v71[0] = &v59;
      v71[1] = &v60;
      if (v62 == (uint64_t *)&v63)
      {
        v45 = 0;
        v47 = 0;
        v48 = (uint64_t *)&v60;
        v46 = (uint64_t *)&v63;
      }
      else
      {
        do
        {
          if (((void *)v40[5] != __p[0] || (void *)v40[6] != __p[1])
            && (v40[7] != (_QWORD)v73 || v40[8] != *((_QWORD *)&v73 + 1)))
          {
            std::insert_iterator<std::multimap<double,std::pair<boost::uuids::uuid const,boost::uuids::uuid>>>::operator=[abi:ne180100]((uint64_t)v71, (uint64_t)(v40 + 4));
          }
          v43 = (uint64_t *)v40[1];
          if (v43)
          {
            do
            {
              v44 = v43;
              v43 = (uint64_t *)*v43;
            }
            while (v43);
          }
          else
          {
            do
            {
              v44 = (uint64_t *)v40[2];
              v34 = *v44 == (_QWORD)v40;
              v40 = v44;
            }
            while (!v34);
          }
          v40 = v44;
        }
        while (v44 != (uint64_t *)&v63);
        v45 = v61;
        v46 = v62;
        v48 = v59;
        v47 = v60;
      }
      v49 = v63;
      v50 = v64;
      v62 = v48;
      v63 = v47;
      v59 = v46;
      v60 = v49;
      v64 = v45;
      v61 = v50;
      v51 = (uint64_t **)(v47 + 2);
      if (v45)
        v52 = v51;
      else
        v52 = &v62;
      *v52 = (uint64_t *)&v63;
      v53 = (uint64_t **)(v49 + 2);
      if (!v50)
        v53 = &v59;
      *v53 = (uint64_t *)&v60;
      std::__tree<std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>,std::__map_value_compare<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>,std::less<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes>,true>,std::allocator<std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>>>::destroy((uint64_t)&v59, v49);
    }
    CLMicroLocationModel::mapIdentifiers(this, &v74);
    std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>>>::~__hash_table((uint64_t)&v74);
    v54 = (__int128 *)*((_QWORD *)&v80 + 1);
    if (*((__int128 **)&v80 + 1) == &v79)
    {
      v55 = 4;
      v54 = &v79;
    }
    else
    {
      if (!*((_QWORD *)&v80 + 1))
      {
LABEL_91:

        std::__tree<std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>,std::__map_value_compare<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>,std::less<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes>,true>,std::allocator<std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>>>::destroy((uint64_t)&v62, v63);
        goto LABEL_92;
      }
      v55 = 5;
    }
    (*(void (**)(void))(*(_QWORD *)v54 + 8 * v55))();
    goto LABEL_91;
  }
LABEL_92:
  std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>>>::~__hash_table((uint64_t)v65);
  std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>>>::~__hash_table((uint64_t)v68);

}

void sub_2419FC858(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, char a15, uint64_t a16, uint64_t a17, char a18, _QWORD *a19, uint64_t a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,void *__p,uint64_t a34,uint64_t a35,uint64_t a36,char a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,char a44)
{
  void *v44;
  void *v45;
  void *v46;
  uint64_t v47;
  _QWORD *v49;
  uint64_t v50;

  v49 = *(_QWORD **)(v47 - 152);
  if (v49 == (_QWORD *)(v47 - 176))
  {
    v50 = 4;
    v49 = (_QWORD *)(v47 - 176);
  }
  else
  {
    if (!v49)
      goto LABEL_6;
    v50 = 5;
  }
  (*(void (**)(void))(*v49 + 8 * v50))();
LABEL_6:

  std::__tree<std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>,std::__map_value_compare<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>,std::less<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes>,true>,std::allocator<std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>>>::destroy((uint64_t)&a18, a19);
  std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>>>::~__hash_table((uint64_t)&a21);
  std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>>>::~__hash_table((uint64_t)&a26);

  _Unwind_Resume(a1);
}

void CLMicroLocationModel::pruneSmallClusters(uint64_t *a1, uint64_t a2, unint64_t a3)
{
  uint64_t *v4;
  _QWORD *v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD *v9;
  uint64_t *v10;
  NSObject *v11;
  _OWORD *v12;
  void *p_p;
  uint64_t v14;
  uint64_t v15;
  BOOL v16;
  uint64_t v17;
  __int128 *v19;
  NSObject *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  void *__p;
  __int128 v26;
  uint8_t buf[4];
  int v28;
  __int16 v29;
  const char *v30;
  __int16 v31;
  unint64_t v32;
  __int16 v33;
  uint64_t v34;
  __int16 v35;
  unint64_t v36;
  uint64_t v37;

  v37 = *MEMORY[0x24BDAC8D0];
  v4 = a1 + 41;
  v5 = *(_QWORD **)(a2 + 16);
  v23 = a1[42];
  v22 = a1[41];
  if (v5)
  {
    v6 = a1 + 44;
    v7 = a1[42];
    do
    {
      v8 = v7;
      v9 = v5 + 2;
      v10 = std::__hash_table<std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>>>::find<boost::uuids::uuid>(v6, v5 + 2);
      if (onceToken_MicroLocation_Default != -1)
        dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_5);
      v11 = (id)logObject_MicroLocation_Default;
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        v12 = operator new(0x28uLL);
        __p = v12;
        v26 = xmmword_241BB2320;
        *v12 = 0u;
        v12[1] = 0u;
        *(_QWORD *)((char *)v12 + 29) = 0;
        boost::uuids::to_chars<char *>((uint64_t)(v5 + 2), v12);
        p_p = &__p;
        if (v26 < 0)
          p_p = __p;
        v14 = (v10[5] - v10[4]) >> 4;
        *(_DWORD *)buf = 68289794;
        v28 = 0;
        v29 = 2082;
        v30 = "";
        v31 = 2082;
        v32 = (unint64_t)p_p;
        v33 = 2050;
        v34 = v14;
        v35 = 2050;
        v36 = a3;
        _os_log_impl(&dword_2419D9000, v11, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"pruneSmallClusters\", \"cluster ID\":%{public, location:escape_only}s, \"cluster size\":%{public}lu, \"threshold\":%{public}lu}", buf, 0x30u);
        if (SHIBYTE(v26) < 0)
          operator delete(__p);
      }

      if (a3 <= (v10[5] - v10[4]) >> 4
        || (std::__hash_table<std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>>>::erase(v6, v10), v7 = *v4, *v4 == v8))
      {
LABEL_18:
        v7 = v8;
      }
      else
      {
        v15 = v7 + 48;
        while (1)
        {
          v16 = *(_QWORD *)(v7 + 16) == *v9 && *(_QWORD *)(v7 + 24) == v5[3];
          v17 = v7 + 32;
          if (v16)
            break;
          v15 += 32;
          v7 += 32;
          if (v17 == v8)
            goto LABEL_18;
        }
        while (v17 != v8)
        {
          if (*(_QWORD *)v15 != *v9 || *(_QWORD *)(v15 + 8) != v5[3])
          {
            std::shared_ptr<CLMicroLocationFingerprint>::operator=[abi:ne180100](v7, (__int128 *)(v15 - 16));
            *(_OWORD *)(v7 + 16) = *(_OWORD *)v15;
            v7 += 32;
          }
          v17 = v15 + 16;
          v15 += 32;
        }
      }
      v5 = (_QWORD *)*v5;
    }
    while (v5);
    v19 = (__int128 *)a1[42];
  }
  else
  {
    v7 = a1[42];
    v19 = (__int128 *)v7;
  }
  std::vector<std::pair<std::shared_ptr<CLMicroLocationFingerprint>,boost::uuids::uuid>>::erase((uint64_t)v4, v7, v19);
  if (onceToken_MicroLocation_Default != -1)
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_5);
  v20 = logObject_MicroLocation_Default;
  if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT))
  {
    v21 = (a1[42] - a1[41]) >> 5;
    *(_DWORD *)buf = 68289794;
    v28 = 0;
    v29 = 2082;
    v30 = "";
    v31 = 2050;
    v32 = a3;
    v33 = 2050;
    v34 = (v23 - v22) >> 5;
    v35 = 2050;
    v36 = v21;
    _os_log_impl(&dword_2419D9000, v20, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"pruneSmallClusters\", \"clusterSizeThreshold\":%{public}lu, \"numFingerprintsPrePruning\":%{public}lu, \"numFingerprintsPostPruning\":%{public}lu}", buf, 0x30u);
  }
}

void sub_2419FCD40(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  operator delete(v2);

  _Unwind_Resume(a1);
}

uint64_t std::vector<std::pair<std::shared_ptr<CLMicroLocationFingerprint>,boost::uuids::uuid>>::erase(uint64_t a1, uint64_t a2, __int128 *a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  if ((__int128 *)a2 != a3)
  {
    std::__unwrap_and_dispatch[abi:ne180100]<std::__overload<std::__move_loop<std::_ClassicAlgPolicy>,std::__move_trivial>,std::pair<std::shared_ptr<CLMicroLocationFingerprint>,boost::uuids::uuid> *,std::pair<std::shared_ptr<CLMicroLocationFingerprint>,boost::uuids::uuid> *,std::pair<std::shared_ptr<CLMicroLocationFingerprint>,boost::uuids::uuid> *,0>(a3, *(__int128 **)(a1 + 8), a2);
    v6 = v5;
    v7 = *(_QWORD *)(a1 + 8);
    if (v7 != v5)
    {
      do
        v7 = std::shared_ptr<CLMiLoService::ModelAndConf>::~shared_ptr[abi:ne180100](v7 - 32);
      while (v7 != v6);
    }
    *(_QWORD *)(a1 + 8) = v6;
  }
  return a2;
}

uint64_t CLMicroLocationModel::pruneSmallClusters(CLMicroLocationModel *this)
{
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  uint64_t v6;
  unint64_t v7;
  _BYTE v9[40];

  +[ULDefaultsSingleton shared](ULDefaultsSingleton, "shared");
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v2, "defaultsDictionary");
  v3 = (void *)objc_claimAutoreleasedReturnValue();

  objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "ULClusterSizeThreshold");
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v3, "objectForKey:", v4);
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  if (v5 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
    v6 = objc_msgSend(v5, "unsignedLongValue");
  else
    v6 = objc_msgSend(&unk_2511ED300, "unsignedLongValue");
  v7 = v6;

  CLMicroLocationModel::getIdentifiers(this, (uint64_t)v9);
  CLMicroLocationModel::pruneSmallClusters((uint64_t *)this, (uint64_t)v9, v7);
  return std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>>>::~__hash_table((uint64_t)v9);
}

void sub_2419FCEC8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void CLMicroLocationModel::mapIdentifiersFromOldModelAndPruneNoiseClusters(CLMicroLocationModel *a1, uint64_t a2, int a3, void *a4)
{
  NSMutableDictionary *v7;
  void *v8;
  void *v9;
  void *v10;
  void *v11;
  double v12;
  double v13;
  _QWORD *v14;
  _QWORD *v15;
  unint64_t v16;
  NSObject *v17;
  const CLMicroLocationModel *v18;
  uint64_t *v19;
  uint64_t v20;
  NSObject *v21;
  _QWORD v22[5];
  uint64_t buf;
  __int16 v24;
  _BYTE v25[18];
  uint64_t v26;

  v26 = *MEMORY[0x24BDAC8D0];
  v7 = a4;
  if (CLMicroLocationModel::isValid(a1))
  {
    +[ULDefaultsSingleton shared](ULDefaultsSingleton, "shared");
    v8 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v8, "defaultsDictionary");
    v9 = (void *)objc_claimAutoreleasedReturnValue();

    objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "ULClusterSizeRatio");
    v10 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v9, "objectForKey:", v10);
    v11 = (void *)objc_claimAutoreleasedReturnValue();
    if (v11 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
      objc_msgSend(v11, "doubleValue");
    else
      objc_msgSend(&unk_2511ECD68, "doubleValue");
    v13 = v12;

    v14 = (_QWORD *)*((_QWORD *)a1 + 46);
    v15 = (_QWORD *)*v14;
    if (*v14)
    {
      do
      {
        if (v14[5] - v14[4] < v15[5] - v15[4])
          v14 = v15;
        v15 = (_QWORD *)*v15;
      }
      while (v15);
    }
    v16 = (unint64_t)(v13 * (double)(unint64_t)((uint64_t)(v14[5] - v14[4]) >> 4));
    if (v16 > (int)ULSettings::get<ULSettings::ClusterMaximalSizeForRelativePruning>())
      v16 = (int)ULSettings::get<ULSettings::ClusterMaximalSizeForRelativePruning>();
    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_5);
    v17 = logObject_MicroLocation_Default;
    if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT))
    {
      buf = 68289282;
      v24 = 2082;
      *(_QWORD *)v25 = "";
      *(_WORD *)&v25[8] = 2050;
      *(double *)&v25[10] = (double)v16;
      _os_log_impl(&dword_2419D9000, v17, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"Using relative cluster size threshold : \", \"size\":\"%{public}.5f\"}", (uint8_t *)&buf, 0x1Cu);
    }
    CLMicroLocationModel::pruneSmallClusters(a1);
    if (CLMicroLocationModel::isValid(a1))
    {
      CLMicroLocationModel::getIdentifiers(a1, (uint64_t)&buf);
      if (a3)
        CLMicroLocationModel::pruneSmallClusters((uint64_t *)a1, (uint64_t)&buf, v16);
      if (*(_BYTE *)(a2 + 8))
      {
        v18 = *(const CLMicroLocationModel **)a2;
        if (CLMicroLocationModel::isValid(v18))
        {
          CLMicroLocationModel::mapIdentifiersFromOldModel(a1, v18, v7);
          CLMicroLocationModel::getIdentifiers(a1, (uint64_t)v22);
          v19 = *(uint64_t **)&v25[6];
          if (*(_QWORD *)&v25[6])
          {
            do
            {
              v20 = *v19;
              if (!std::__hash_table<std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>>>::find<boost::uuids::uuid>(v22, v19 + 2))std::__hash_table<boost::uuids::uuid,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,std::allocator<boost::uuids::uuid>>::erase(&buf, v19);
              v19 = (uint64_t *)v20;
            }
            while (v20);
          }
          std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>>>::~__hash_table((uint64_t)v22);
        }
      }
      if ((a3 & 1) == 0)
        CLMicroLocationModel::pruneSmallClusters((uint64_t *)a1, (uint64_t)&buf, v16);
      std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>>>::~__hash_table((uint64_t)&buf);
    }
    else
    {
      if (onceToken_MicroLocation_Default != -1)
        dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_5);
      v21 = logObject_MicroLocation_Default;
      if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(buf) = 0;
        _os_log_impl(&dword_2419D9000, v21, OS_LOG_TYPE_DEFAULT, "Model has become invalid after pruning clusters with absolute size threshold", (uint8_t *)&buf, 2u);
      }
    }
  }

}

void sub_2419FD250(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  void *v7;
  va_list va;

  va_start(va, a7);
  std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>>>::~__hash_table((uint64_t)va);

  _Unwind_Resume(a1);
}

uint64_t ULSettings::get<ULSettings::ClusterMaximalSizeForRelativePruning>()
{
  void *v0;
  void *v1;
  void *v2;
  void *v3;
  uint64_t v4;
  uint64_t v5;

  +[ULDefaultsSingleton shared](ULDefaultsSingleton, "shared");
  v0 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v0, "defaultsDictionary");
  v1 = (void *)objc_claimAutoreleasedReturnValue();

  objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "ULClusterMaximalSizeForRelativePruning");
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v1, "objectForKey:", v2);
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  if (v3 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
    v4 = objc_msgSend(v3, "intValue");
  else
    v4 = objc_msgSend(&unk_2511ED318, "intValue");
  v5 = v4;

  return v5;
}

void sub_2419FD394(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

uint64_t CLMicroLocationModel::getClusterPairwiseDistances@<X0>(_QWORD *a1@<X0>, uint64_t a2@<X1>, unint64_t *a3@<X8>)
{
  unint64_t v6;
  uint64_t *i;
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  uint64_t v14;
  double v15;
  unint64_t v16;
  _OWORD *v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t v20;
  unint64_t v21;
  _DWORD *v22;
  char *v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t v26;
  unint64_t v27;
  char *v28;
  char *v29;
  int v30;
  double v31;
  uint64_t v33;
  uint64_t v34;
  uint64_t *v35;
  _QWORD *v36[2];
  _BYTE v37[16];
  uint64_t *v38;
  std::vector<int>::value_type __x[2];
  void *__p[2];
  _DWORD *v41;
  uint64_t v42;
  uint64_t v43;

  v43 = *MEMORY[0x24BDAC8D0];
  v6 = a1[47];
  CLMicroLocationModel::getIdentifiers(a1, (uint64_t)v37);
  v36[0] = 0;
  v36[1] = 0;
  v34 = 0;
  v35 = (uint64_t *)v36;
  for (i = v38; i; i = (uint64_t *)*i)
  {
    *(_OWORD *)__p = *((_OWORD *)i + 1);
    std::__tree<std::__value_type<boost::uuids::uuid,unsigned long>,std::__map_value_compare<boost::uuids::uuid,std::__value_type<boost::uuids::uuid,unsigned long>,std::less<boost::uuids::uuid>,true>,std::allocator<std::__value_type<boost::uuids::uuid,unsigned long>>>::__emplace_unique_key_args<boost::uuids::uuid,boost::uuids::uuid&,unsigned long &>(&v35, (unint64_t *)__p, __p, &v34);
    ++v34;
  }
  a3[1] = 0;
  v8 = (uint64_t *)(a3 + 1);
  a3[2] = 0;
  a3[3] = 0;
  __p[1] = 0;
  v41 = 0;
  v42 = 0;
  *a3 = v6;
  *(_QWORD *)__x = 0;
  std::vector<double>::resize((uint64_t)(a3 + 1), (v6 + v6 * v6) >> 1, __x);
  __p[0] = (void *)v6;
  __x[0] = 0;
  std::vector<int>::resize((std::vector<int> *)&__p[1], (v6 + v6 * v6) >> 1, __x);
  v10 = a1[41];
  v9 = a1[42];
  if (v9 != v10)
  {
    v11 = 0;
    v12 = 0;
    do
    {
      if (v12 >= (v9 - v10) >> 5)
      {
        v21 = (v9 - v10) >> 5;
      }
      else
      {
        v33 = v11;
        v13 = v12;
        do
        {
          v14 = *(_QWORD *)(a2 + 24);
          if (!v14)
            std::__throw_bad_function_call[abi:ne180100]();
          v15 = (*(double (**)(uint64_t, _QWORD, _QWORD))(*(_QWORD *)v14 + 48))(v14, *(_QWORD *)(v10 + 32 * v12), *(_QWORD *)(v10 + v11));
          *(_QWORD *)__x = v10 + 32 * v12 + 16;
          v16 = *((_QWORD *)std::__tree<std::__value_type<boost::uuids::uuid,unsigned long>,std::__map_value_compare<boost::uuids::uuid,std::__value_type<boost::uuids::uuid,unsigned long>,std::less<boost::uuids::uuid>,true>,std::allocator<std::__value_type<boost::uuids::uuid,unsigned long>>>::__emplace_unique_key_args<boost::uuids::uuid,std::piecewise_construct_t const&,std::tuple<boost::uuids::uuid const&>,std::tuple<>>(&v35, *(unint64_t **)__x, (uint64_t)&std::piecewise_construct, (_OWORD **)__x)+ 6);
          *(_QWORD *)__x = v10 + v11 + 16;
          v17 = std::__tree<std::__value_type<boost::uuids::uuid,unsigned long>,std::__map_value_compare<boost::uuids::uuid,std::__value_type<boost::uuids::uuid,unsigned long>,std::less<boost::uuids::uuid>,true>,std::allocator<std::__value_type<boost::uuids::uuid,unsigned long>>>::__emplace_unique_key_args<boost::uuids::uuid,std::piecewise_construct_t const&,std::tuple<boost::uuids::uuid const&>,std::tuple<>>(&v35, *(unint64_t **)__x, (uint64_t)&std::piecewise_construct, (_OWORD **)__x);
          v18 = *((_QWORD *)v17 + 6);
          if (v16 <= v18)
            v19 = *((_QWORD *)v17 + 6);
          else
            v19 = v16;
          if (v16 < v18)
            v18 = v16;
          v20 = v18 + ((v19 + v19 * v19) >> 1);
          *(double *)(*v8 + 8 * v20) = v15 + *(double *)(*v8 + 8 * v20);
          ++*((_DWORD *)__p[1] + v20);
          ++v13;
          v10 = a1[41];
          v9 = a1[42];
          v11 += 32;
        }
        while (v13 < (v9 - v10) >> 5);
        v21 = (v9 - v10) >> 5;
        v11 = v33;
      }
      ++v12;
      v11 += 32;
    }
    while (v12 < v21);
  }
  v22 = __p[1];
  if (v6)
  {
    v23 = 0;
    v24 = *v8;
    do
    {
      v25 = *v8;
      v26 = (unint64_t)v23;
      do
      {
        if ((unint64_t)v23 <= v26)
          v27 = v26;
        else
          v27 = (unint64_t)v23;
        if ((unint64_t)v23 >= v26)
          v28 = (char *)v26;
        else
          v28 = v23;
        v29 = &v28[(v27 + v27 * v27) >> 1];
        v30 = v22[(_QWORD)v29];
        if (v30)
          v31 = *(double *)(v25 + 8 * (_QWORD)v29) / (double)v30;
        else
          v31 = 0.0;
        *(double *)(v24 + 8 * (_QWORD)v29) = v31;
        ++v26;
      }
      while (v26 < v6);
      ++v23;
    }
    while (v23 != (char *)v6);
    goto LABEL_33;
  }
  if (__p[1])
  {
LABEL_33:
    v41 = v22;
    operator delete(v22);
  }
  std::__tree<std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>,std::__map_value_compare<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>,std::less<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes>,true>,std::allocator<std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>>>::destroy((uint64_t)&v35, v36[0]);
  return std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>>>::~__hash_table((uint64_t)v37);
}

void sub_2419FD694(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,void *__p,uint64_t a25)
{
  _Unwind_Resume(exception_object);
}

double CLMicroLocationModel::representativeFPsRatio(CLMicroLocationModel *this)
{
  _QWORD *v2;
  unint64_t v3;
  NSObject *v5;
  _DWORD v6[2];
  __int16 v7;
  const char *v8;
  __int16 v9;
  _BOOL4 isValid;
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  v2 = (_QWORD *)*((_QWORD *)this + 46);
  if (v2)
  {
    v3 = 0;
    do
    {
      v3 += (uint64_t)(v2[5] - v2[4]) >> 4;
      v2 = (_QWORD *)*v2;
    }
    while (v2);
    if (v3)
      return (double)(unint64_t)((uint64_t)(*((_QWORD *)this + 42) - *((_QWORD *)this + 41)) >> 5) / (double)v3;
  }
  if (onceToken_MicroLocation_Default != -1)
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_5);
  v5 = (id)logObject_MicroLocation_Default;
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    v6[0] = 68289282;
    v6[1] = 0;
    v7 = 2082;
    v8 = "";
    v9 = 1026;
    isValid = CLMicroLocationModel::isValid(this);
    _os_log_impl(&dword_2419D9000, v5, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"representativeFPsRatio, called with empty model\", \"isValid\":%{public}hhd}", (uint8_t *)v6, 0x18u);
  }

  return 1.0;
}

void sub_2419FD834(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

_OWORD *std::vector<std::pair<std::shared_ptr<CLMicroLocationFingerprint>,boost::uuids::uuid>>::emplace_back<std::pair<std::shared_ptr<CLMicroLocationFingerprint>,boost::uuids::uuid>>(uint64_t *a1, uint64_t a2)
{
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  _OWORD *v7;
  _OWORD *v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char *v13;
  char *v14;
  _QWORD v16[5];

  v6 = a1[2];
  v4 = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(_OWORD **)(v4 - 8);
  if ((unint64_t)v7 >= v6)
  {
    v9 = ((uint64_t)v7 - *a1) >> 5;
    v10 = v9 + 1;
    if ((unint64_t)(v9 + 1) >> 59)
      std::vector<CLMicroLocationProto::ConfidenceReason>::__throw_length_error[abi:ne180100]();
    v11 = v5 - *a1;
    if (v11 >> 4 > v10)
      v10 = v11 >> 4;
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFE0)
      v12 = 0x7FFFFFFFFFFFFFFLL;
    else
      v12 = v10;
    v16[4] = v4;
    if (v12)
      v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<CLMicroLocationResultInternal>>(v4, v12);
    else
      v13 = 0;
    v14 = &v13[32 * v9];
    v16[0] = v13;
    v16[1] = v14;
    v16[3] = &v13[32 * v12];
    *(_OWORD *)v14 = *(_OWORD *)a2;
    *(_QWORD *)a2 = 0;
    *(_QWORD *)(a2 + 8) = 0;
    *((_OWORD *)v14 + 1) = *(_OWORD *)(a2 + 16);
    v16[2] = v14 + 32;
    std::vector<std::pair<std::shared_ptr<CLMicroLocationFingerprint>,boost::uuids::uuid>>::__swap_out_circular_buffer(a1, v16);
    v8 = (_OWORD *)a1[1];
    std::__split_buffer<std::pair<std::shared_ptr<CLMicroLocationFingerprint>,boost::uuids::uuid>>::~__split_buffer((uint64_t)v16);
  }
  else
  {
    *v7 = *(_OWORD *)a2;
    *(_QWORD *)a2 = 0;
    *(_QWORD *)(a2 + 8) = 0;
    v7[1] = *(_OWORD *)(a2 + 16);
    v8 = v7 + 2;
    a1[1] = (uint64_t)(v7 + 2);
  }
  a1[1] = (uint64_t)v8;
  return v8 - 2;
}

void sub_2419FD94C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__split_buffer<std::pair<std::shared_ptr<CLMicroLocationFingerprint>,boost::uuids::uuid>>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

void std::vector<boost::uuids::uuid>::reserve(void **a1, unint64_t a2)
{
  uint64_t v3;
  _BYTE *v4;
  int64_t v5;
  char *v6;
  char *v7;
  uint64_t v8;
  char *v9;
  char *v10;
  char *v11;
  char *v12;

  v4 = a1[2];
  v3 = (uint64_t)(a1 + 2);
  if (a2 > (v4 - (_BYTE *)*a1) >> 4)
  {
    if (a2 >> 60)
      std::vector<CLMicroLocationProto::ConfidenceReason>::__throw_length_error[abi:ne180100]();
    v5 = (_BYTE *)a1[1] - (_BYTE *)*a1;
    v6 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<boost::uuids::uuid>>(v3, a2);
    v7 = &v6[v5 & 0xFFFFFFFFFFFFFFF0];
    v9 = &v6[16 * v8];
    v11 = (char *)*a1;
    v10 = (char *)a1[1];
    v12 = v7;
    if (v10 != *a1)
    {
      do
      {
        *((_OWORD *)v12 - 1) = *((_OWORD *)v10 - 1);
        v12 -= 16;
        v10 -= 16;
      }
      while (v10 != v11);
      v10 = (char *)*a1;
    }
    *a1 = v12;
    a1[1] = v7;
    a1[2] = v9;
    if (v10)
      operator delete(v10);
  }
}

void std::vector<CLMicroLocationProto::ConfidenceLevel>::reserve(std::vector<int> *this, std::vector<int>::size_type __n)
{
  std::__compressed_pair<int *> *p_end_cap;
  int *value;
  int64_t v5;
  char *v6;
  int *v7;
  uint64_t v8;
  int *v9;
  std::vector<int>::pointer begin;
  int *end;
  int *v12;
  int v13;

  value = this->__end_cap_.__value_;
  p_end_cap = &this->__end_cap_;
  if (__n > value - this->__begin_)
  {
    if (__n >> 62)
      std::vector<CLMicroLocationProto::ConfidenceReason>::__throw_length_error[abi:ne180100]();
    v5 = (char *)this->__end_ - (char *)this->__begin_;
    v6 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<CLMicroLocationProto::ConfidenceReason>>((uint64_t)p_end_cap, __n);
    v7 = (int *)&v6[v5 & 0xFFFFFFFFFFFFFFFCLL];
    v9 = (int *)&v6[4 * v8];
    begin = this->__begin_;
    end = this->__end_;
    v12 = v7;
    if (end != this->__begin_)
    {
      v12 = v7;
      do
      {
        v13 = *--end;
        *--v12 = v13;
      }
      while (end != begin);
    }
    this->__begin_ = v12;
    this->__end_ = v7;
    this->__end_cap_.__value_ = v9;
    if (begin)
      operator delete(begin);
  }
}

void CLMicroLocationModel::SimilarityListData::calculateNormalizedProbabilitiesWithoutNullCluster(_QWORD *a1, uint64_t a2, CLMicroLocationFingerprintVector *a3, _QWORD *a4, _QWORD *a5, _QWORD *a6)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  _QWORD *v12;
  _QWORD *v13;
  _QWORD *v14;
  _QWORD *v15;
  char *v16;
  char *v17;
  int v18;
  _QWORD *v19;
  _QWORD *v20;
  NSObject *v22;
  _OWORD *v23;
  void *p_p;
  NSObject *v25;
  _OWORD *v26;
  void *v27;
  NSObject *v28;
  _OWORD *v29;
  void *v30;
  NSObject *v31;
  _OWORD *v32;
  void *v33;
  NSObject *v34;
  NSObject *v35;
  void *v36;
  _BYTE *v37;
  _QWORD *v38;
  _BYTE *v39;
  int64_t v40;
  _QWORD *v45;
  void *__p;
  __int128 v47;
  _QWORD v48[2];
  _QWORD v49[2];
  char v50[8];
  _QWORD *v51;
  id v52;
  void *v53[2];
  char v54;
  _BYTE v55[32];
  char v56;
  uint8_t buf[8];
  __int16 v58;
  const char *v59;
  __int16 v60;
  void *v61;
  uint8_t v62[8];
  _QWORD v63[2];
  char v64;
  void *v65;
  void *v66;
  void *v67;
  void *v68;
  char v69;
  uint64_t v70;

  v70 = *MEMORY[0x24BDAC8D0];
  v55[0] = 0;
  v56 = 0;
  CLMicroLocationProtobufHelper::ModelTypeToDomain(0, v53);
  CLMicroLocationLocalizationSettings::CLMicroLocationLocalizationSettings((uint64_t)v50, v53);
  v49[0] = CLMicroLocationFingerprintVector::begin(a3);
  v49[1] = v8;
  v48[0] = CLMicroLocationFingerprintVector::end(a3);
  v48[1] = v9;
  while (CLMicroLocationFingerprintVector::Iterator::operator!=(v49, v48))
  {
    v10 = CLMicroLocationFingerprintVector::Iterator::operator*(v49);
    v11 = std::__hash_table<std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>>>::find<boost::uuids::uuid>(a4, (_QWORD *)(v10 + 40));
    if (!v11)
      std::__throw_out_of_range[abi:ne180100]("unordered_map::at: key not found");
    v12 = std::__hash_table<std::__hash_value_type<boost::uuids::uuid,boost::uuids::uuid>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,boost::uuids::uuid>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,boost::uuids::uuid>>>::__equal_range_multi<boost::uuids::uuid>(a5, v11 + 4);
    v45 = v13;
    v14 = v12;
    CLMicroLocationLocalizer::localize((const CLMicroLocationProto::AssociatedAccessPointInfo *)v55, a2, v10, (CLMicroLocationLocalizationSettings *)v50, 0, 0, (uint64_t)v62);
    if (v63[0] == *(_QWORD *)v62)
    {
      CLMicroLocationModel::SimilarityListData::calculateNormalizedProbabilitiesWithoutNullCluster((NSObject **)buf);

      abort_report_np();
      __break(1u);
    }
    while (v14 != v45)
    {
      v15 = std::__hash_table<std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>>>::find<boost::uuids::uuid>(a6, v14 + 4);
      if (v15)
      {
        v17 = *(char **)v62;
        v16 = (char *)v63[0];
        if (*(_QWORD *)v62 != v63[0])
        {
          v18 = *((_DWORD *)v15 + 8);
          do
          {
            v19 = (_QWORD *)a1[1];
            v20 = (_QWORD *)*a1;
            if ((_QWORD *)*a1 != v19)
            {
              while (*v20 != *(_QWORD *)v17 || v20[1] != *((_QWORD *)v17 + 1))
              {
                v20 += 2;
                if (v20 == v19)
                {
                  v20 = (_QWORD *)a1[1];
                  break;
                }
              }
            }
            if (v20 == v19)
            {
              if (onceToken_MicroLocation_Default != -1)
                dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_5);
              v22 = (id)logObject_MicroLocation_Default;
              if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
              {
                v23 = operator new(0x28uLL);
                __p = v23;
                v47 = xmmword_241BB2320;
                *v23 = 0u;
                v23[1] = 0u;
                *(_QWORD *)((char *)v23 + 29) = 0;
                boost::uuids::to_chars<char *>((uint64_t)v17, v23);
                p_p = &__p;
                if (v47 < 0)
                  p_p = __p;
                *(_QWORD *)buf = 68289282;
                v58 = 2082;
                v59 = "";
                v60 = 2082;
                v61 = p_p;
                _os_log_impl(&dword_2419D9000, v22, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"Similarity List Model Learning, unexpected identifier\", \"cluster ID\":%{public, location:escape_only}s}", buf, 0x1Cu);
                if (SHIBYTE(v47) < 0)
                  operator delete(__p);
              }

              if (onceToken_MicroLocation_Default != -1)
                dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_5);
              v25 = (id)logObject_MicroLocation_Default;
              if (os_signpost_enabled(v25))
              {
                v26 = operator new(0x28uLL);
                __p = v26;
                v47 = xmmword_241BB2320;
                *v26 = 0u;
                v26[1] = 0u;
                *(_QWORD *)((char *)v26 + 29) = 0;
                boost::uuids::to_chars<char *>((uint64_t)v17, v26);
                v27 = &__p;
                if (v47 < 0)
                  v27 = __p;
                *(_QWORD *)buf = 68289282;
                v58 = 2082;
                v59 = "";
                v60 = 2082;
                v61 = v27;
                _os_signpost_emit_with_name_impl(&dword_2419D9000, v25, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Similarity List Model Learning, unexpected identifier", "{\"msg%{public}.0s\":\"Similarity List Model Learning, unexpected identifier\", \"cluster ID\":%{public, location:escape_only}s}", buf, 0x1Cu);
                if (SHIBYTE(v47) < 0)
                  operator delete(__p);
              }

            }
            else
            {
              CLMicroLocationUtils::ProbabilityMatrix::setValue((CLMicroLocationUtils::ProbabilityMatrix *)(a1 + 6), v18, ((unint64_t)v20 - *a1) >> 4, *((double *)v17 + 2));
            }
            v17 += 32;
          }
          while (v17 != v16);
        }
      }
      else
      {
        if (onceToken_MicroLocation_Default != -1)
          dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_5);
        v28 = (id)logObject_MicroLocation_Default;
        if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
        {
          v29 = operator new(0x28uLL);
          __p = v29;
          v47 = xmmword_241BB2320;
          *v29 = 0u;
          v29[1] = 0u;
          *(_QWORD *)((char *)v29 + 29) = 0;
          boost::uuids::to_chars<char *>((uint64_t)(v14 + 4), v29);
          v30 = &__p;
          if (v47 < 0)
            v30 = __p;
          *(_QWORD *)buf = 68289282;
          v58 = 2082;
          v59 = "";
          v60 = 2082;
          v61 = v30;
          _os_log_impl(&dword_2419D9000, v28, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"Similarity List Model Learning, unexpectedly couldn't find LSL row for label identifier\", \"Label UUID\":%{public, location:escape_only}s}", buf, 0x1Cu);
          if (SHIBYTE(v47) < 0)
            operator delete(__p);
        }

        if (onceToken_MicroLocation_Default != -1)
          dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_5);
        v31 = (id)logObject_MicroLocation_Default;
        if (os_signpost_enabled(v31))
        {
          v32 = operator new(0x28uLL);
          __p = v32;
          v47 = xmmword_241BB2320;
          *v32 = 0u;
          v32[1] = 0u;
          *(_QWORD *)((char *)v32 + 29) = 0;
          boost::uuids::to_chars<char *>((uint64_t)(v14 + 4), v32);
          v33 = &__p;
          if (v47 < 0)
            v33 = __p;
          *(_QWORD *)buf = 68289282;
          v58 = 2082;
          v59 = "";
          v60 = 2082;
          v61 = v33;
          _os_signpost_emit_with_name_impl(&dword_2419D9000, v31, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Similarity List Model Learning, unexpectedly couldn't find LSL row for label identifier", "{\"msg%{public}.0s\":\"Similarity List Model Learning, unexpectedly couldn't find LSL row for label identifier\", \"Label UUID\":%{public, location:escape_only}s}", buf, 0x1Cu);
          if (SHIBYTE(v47) < 0)
            operator delete(__p);
        }

      }
      v14 = (_QWORD *)*v14;
    }
    if (v69 && v67)
    {
      v68 = v67;
      operator delete(v67);
    }
    if (v65)
    {
      v66 = v65;
      operator delete(v65);
    }
    if (*(_QWORD *)v62)
    {
      v63[0] = *(_QWORD *)v62;
      operator delete(*(void **)v62);
    }
    CLMicroLocationFingerprintVector::Iterator::operator++((uint64_t)v49);
  }
  if ((CLMicroLocationUtils::ProbabilityMatrix::normalizeRows((CLMicroLocationUtils::ProbabilityMatrix *)(a1 + 6)) & 1) == 0)
  {
    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_5);
    v34 = logObject_MicroLocation_Default;
    if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_ERROR))
    {
      *(_QWORD *)v62 = 68289026;
      LOWORD(v63[0]) = 2082;
      *(_QWORD *)((char *)v63 + 2) = "";
      _os_log_impl(&dword_2419D9000, v34, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"Similarity List Model Learning, error normalizing probability matrix\"}", v62, 0x12u);
    }
    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_5);
    v35 = logObject_MicroLocation_Default;
    if (os_signpost_enabled((os_log_t)logObject_MicroLocation_Default))
    {
      *(_QWORD *)v62 = 68289026;
      LOWORD(v63[0]) = 2082;
      *(_QWORD *)((char *)v63 + 2) = "";
      _os_signpost_emit_with_name_impl(&dword_2419D9000, v35, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Similarity List Model Learning, error normalizing probability matrix", "{\"msg%{public}.0s\":\"Similarity List Model Learning, error normalizing probability matrix\"}", v62, 0x12u);
    }
  }
  if (*(_OWORD *)*a1 == 0)
  {
    CLMicroLocationUtils::ProbabilityMatrix::removeFirstCols((_DWORD *)a1 + 12, 1u, (uint64_t)v62);
    std::__optional_storage_base<CLMicroLocationUtils::ProbabilityMatrix,false>::__assign_from[abi:ne180100]<std::__optional_move_assign_base<CLMicroLocationUtils::ProbabilityMatrix,false>>(a1 + 6, (uint64_t)v62);
    if (v64)
    {
      v36 = *(void **)v62;
      *(_QWORD *)v62 = 0;
      if (v36)
        MEMORY[0x2426A04BC](v36, 0x1000C8000313F17);
    }
    v38 = (_QWORD *)*a1;
    v37 = (_BYTE *)a1[1];
    v39 = (_BYTE *)(*a1 + 16);
    v40 = v37 - v39;
    if (v37 != v39)
      memmove((void *)*a1, v39, v37 - v39);
    a1[1] = (char *)v38 + v40;
  }

  std::__tree<std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>,std::__map_value_compare<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>,std::less<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes>,true>,std::allocator<std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>>>::destroy((uint64_t)v50, v51);
  if (v54 < 0)
    operator delete(v53[0]);
  if (v56)
    CLMicroLocationProto::AssociatedAccessPointInfo::~AssociatedAccessPointInfo((CLMicroLocationProto::AssociatedAccessPointInfo *)v55);
}

void sub_2419FE29C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,char a28,_QWORD *a29,uint64_t a30,void *a31,uint64_t a32,void *__p,uint64_t a34,int a35,__int16 a36,char a37,char a38,char a39,uint64_t a40,uint64_t a41,uint64_t a42,char a43)
{
  uint64_t v43;
  uint64_t v45;

  if (*(_BYTE *)(v43 - 168))
  {
    v45 = *(_QWORD *)(v43 - 192);
    *(_QWORD *)(v43 - 192) = 0;
    if (v45)
      MEMORY[0x2426A04BC](v45, 0x1000C8000313F17);
  }

  std::__tree<std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>,std::__map_value_compare<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>,std::less<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes>,true>,std::allocator<std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>>>::destroy((uint64_t)&a28, a29);
  if (a38 < 0)
    operator delete(__p);
  if (a43)
    CLMicroLocationProto::AssociatedAccessPointInfo::~AssociatedAccessPointInfo((CLMicroLocationProto::AssociatedAccessPointInfo *)&a39);
  _Unwind_Resume(a1);
}

void CLMicroLocationModel::SimilarityListData::appendNewEvents(uint64_t a1, uint64_t a2, _QWORD *a3, uint64_t *a4)
{
  int v7;
  unint64_t v8;
  uint64_t v9;
  void **v10;
  _QWORD *v11;
  double *v12;
  double *v13;
  _QWORD *v14;
  _QWORD *v15;
  int v17;
  NSObject *v18;
  int v19;
  int v20;
  uint64_t v21;
  int v22;
  int v23;
  NSObject *v24;
  NSObject *v25;
  int v26;
  int v27;
  uint64_t v28;
  int v29;
  int v30;
  NSObject *v31;
  NSObject *v32;
  const char *v33;
  const char *v34;
  NSObject *v35;
  unint64_t v36;
  uint64_t v37;
  NSObject *v38;
  unint64_t v39;
  uint64_t v40;
  NSObject *v41;
  _OWORD *v42;
  void **v43;
  NSObject *v44;
  char *v45;
  NSObject *v46;
  NSObject *v47;
  NSObject *v48;
  signed int v49;
  uint64_t v50;
  uint64_t v51;
  void *v52;
  NSObject *v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  void *v58;
  __int128 v59;
  void *v60;
  __int128 v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  NSObject *v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t *v68;
  void **v69;
  void *__p[3];
  uint64_t v72;
  char v73;
  int v74;
  int v75;
  char v76[8];
  _QWORD *v77;
  id v78;
  void *v79[2];
  char v80;
  _BYTE v81[32];
  char v82;
  int v83;
  uint8_t buf[8];
  __int16 v85;
  const char *v86;
  __int16 v87;
  void **v88;
  __int16 v89;
  int v90;
  __int16 v91;
  int v92;
  __int16 v93;
  int v94;
  uint8_t v95[8];
  _BYTE v96[10];
  __int16 v97;
  unint64_t v98;
  __int16 v99;
  _BYTE v100[10];
  uint64_t v101;
  void *v102;
  void *v103;
  char v104;
  uint64_t v105;

  v105 = *MEMORY[0x24BDAC8D0];
  v81[0] = 0;
  v82 = 0;
  v7 = ULSettings::get<ULSettings::SimilarityListMaxNumberOfItems>();
  CLMicroLocationProtobufHelper::ModelTypeToDomain(0, v79);
  CLMicroLocationLocalizationSettings::CLMicroLocationLocalizationSettings((uint64_t)v76, v79);
  v8 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(a3[1] - *a3) >> 6);
  if (v8 == (a4[1] - *a4) >> 4)
  {
    v68 = a4;
    if (v7 >= (int)v8)
      v7 = -1431655765 * ((uint64_t)(a3[1] - *a3) >> 6);
    v9 = 60;
    if (!*(_BYTE *)(a1 + 57))
      v9 = 64;
    CLMicroLocationUtils::ProbabilityMatrix::ProbabilityMatrix((CLMicroLocationUtils::ProbabilityMatrix *)&v72, v7, *(_DWORD *)(a1 + v9) + 1);
    if (v7)
    {
      v10 = 0;
      v69 = (void **)v7;
      do
      {
        v11 = a3;
        CLMicroLocationLocalizer::localize((const CLMicroLocationProto::AssociatedAccessPointInfo *)v81, a2, *a3 + 192 * (_QWORD)v10, (CLMicroLocationLocalizationSettings *)v76, 0, 0, (uint64_t)v95);
        v12 = *(double **)v95;
        v13 = *(double **)v96;
        while (v12 != v13)
        {
          if (*(_OWORD *)v12 == 0)
          {
            if ((CLMicroLocationUtils::ProbabilityMatrix::setValue((CLMicroLocationUtils::ProbabilityMatrix *)&v72, (int)v10, 0, v12[2]) & 1) == 0)
            {
              if (onceToken_MicroLocation_Default != -1)
                dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_5);
              v25 = logObject_MicroLocation_Default;
              if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_ERROR))
              {
                v26 = v74;
                if (v73)
                  v27 = v75;
                else
                  v27 = v74;
                if (!v73)
                  v26 = v75;
                *(_DWORD *)buf = 68290050;
                *(_DWORD *)&buf[4] = 0;
                v85 = 2082;
                v86 = "";
                v87 = 2050;
                v88 = v10;
                v89 = 1026;
                v90 = 0;
                v91 = 1026;
                v92 = v27;
                v93 = 1026;
                v94 = v26;
                _os_log_impl(&dword_2419D9000, v25, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"appendNewEvents, set value error\", \"row\":%{public}lu, \"col\":%{public}d, \"numRows\":%{public}d, \"numCols\":%{public}d}", buf, 0x2Eu);
              }
              if (onceToken_MicroLocation_Default != -1)
                dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_5);
              v28 = logObject_MicroLocation_Default;
              if (os_signpost_enabled((os_log_t)logObject_MicroLocation_Default))
              {
                v29 = v74;
                if (v73)
                  v30 = v75;
                else
                  v30 = v74;
                if (!v73)
                  v29 = v75;
                *(_DWORD *)buf = 68290050;
                *(_DWORD *)&buf[4] = 0;
                v85 = 2082;
                v86 = "";
                v87 = 2050;
                v88 = v10;
                v89 = 1026;
                v90 = 0;
                v91 = 1026;
                v92 = v30;
                v93 = 1026;
                v94 = v29;
                v24 = v28;
                goto LABEL_57;
              }
            }
          }
          else
          {
            v14 = *(_QWORD **)(a1 + 8);
            v15 = *(_QWORD **)a1;
            if (*(_QWORD **)a1 != v14)
            {
              while (*v15 != *(_QWORD *)v12 || v15[1] != *((_QWORD *)v12 + 1))
              {
                v15 += 2;
                if (v15 == v14)
                {
                  v15 = *(_QWORD **)(a1 + 8);
                  break;
                }
              }
            }
            if (v15 == v14)
            {
              if (onceToken_MicroLocation_Default != -1)
                dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_5);
              v41 = (id)logObject_MicroLocation_Default;
              if (os_log_type_enabled(v41, OS_LOG_TYPE_ERROR))
              {
                v42 = operator new(0x28uLL);
                __p[0] = v42;
                *(_OWORD *)&__p[1] = xmmword_241BB2320;
                *v42 = 0u;
                v42[1] = 0u;
                *(_QWORD *)((char *)v42 + 29) = 0;
                boost::uuids::to_chars<char *>((uint64_t)v12, v42);
                v43 = __p;
                if (SHIBYTE(__p[2]) < 0)
                  v43 = (void **)__p[0];
                *(_DWORD *)buf = 68289282;
                *(_DWORD *)&buf[4] = 0;
                v85 = 2082;
                v86 = "";
                v87 = 2082;
                v88 = v43;
                _os_log_impl(&dword_2419D9000, v41, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"Similarity List fail to append new event, unexpected identifier\", \"cluster ID\":%{public, location:escape_only}s}", buf, 0x1Cu);
                if (SHIBYTE(__p[2]) < 0)
                  operator delete(__p[0]);
              }

              if (onceToken_MicroLocation_Default != -1)
                dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_5);
              v44 = (id)logObject_MicroLocation_Default;
              if (os_signpost_enabled(v44))
              {
                v45 = (char *)operator new(0x28uLL);
                *(_QWORD *)(v45 + 29) = 0;
                *(_OWORD *)v45 = 0u;
                *((_OWORD *)v45 + 1) = 0u;
                boost::uuids::to_chars<char *>((uint64_t)v12, v45);
                *(_DWORD *)buf = 68289282;
                *(_DWORD *)&buf[4] = 0;
                v85 = 2082;
                v86 = "";
                v87 = 2082;
                v88 = (void **)v45;
                _os_signpost_emit_with_name_impl(&dword_2419D9000, v44, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Similarity List fail to append new event, unexpected identifier", "{\"msg%{public}.0s\":\"Similarity List fail to append new event, unexpected identifier\", \"cluster ID\":%{public, location:escape_only}s}", buf, 0x1Cu);
                operator delete(v45);
              }

              if (v104 && v102)
              {
                v103 = v102;
                operator delete(v102);
              }
              if (*(_QWORD *)&v100[2])
              {
                v101 = *(_QWORD *)&v100[2];
                operator delete(*(void **)&v100[2]);
              }
              if (*(_QWORD *)v95)
              {
                *(_QWORD *)v96 = *(_QWORD *)v95;
                operator delete(*(void **)v95);
              }
              goto LABEL_136;
            }
            v17 = (((unint64_t)v15 - *(_QWORD *)a1) >> 4) + 1;
            if ((CLMicroLocationUtils::ProbabilityMatrix::setValue((CLMicroLocationUtils::ProbabilityMatrix *)&v72, (int)v10, v17, v12[2]) & 1) == 0)
            {
              if (onceToken_MicroLocation_Default != -1)
                dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_5);
              v18 = logObject_MicroLocation_Default;
              if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_ERROR))
              {
                v19 = v74;
                if (v73)
                  v20 = v75;
                else
                  v20 = v74;
                if (!v73)
                  v19 = v75;
                *(_DWORD *)buf = 68290050;
                *(_DWORD *)&buf[4] = 0;
                v85 = 2082;
                v86 = "";
                v87 = 2050;
                v88 = v10;
                v89 = 1026;
                v90 = v17;
                v91 = 1026;
                v92 = v20;
                v93 = 1026;
                v94 = v19;
                _os_log_impl(&dword_2419D9000, v18, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"appendNewEvents, set value error\", \"row\":%{public}lu, \"col\":%{public}d, \"numRows\":%{public}d, \"numCols\":%{public}d}", buf, 0x2Eu);
              }
              if (onceToken_MicroLocation_Default != -1)
                dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_5);
              v21 = logObject_MicroLocation_Default;
              if (os_signpost_enabled((os_log_t)logObject_MicroLocation_Default))
              {
                v22 = v74;
                if (v73)
                  v23 = v75;
                else
                  v23 = v74;
                if (!v73)
                  v22 = v75;
                *(_DWORD *)buf = 68290050;
                *(_DWORD *)&buf[4] = 0;
                v85 = 2082;
                v86 = "";
                v87 = 2050;
                v88 = v10;
                v89 = 1026;
                v90 = v17;
                v91 = 1026;
                v92 = v23;
                v93 = 1026;
                v94 = v22;
                v24 = v21;
LABEL_57:
                _os_signpost_emit_with_name_impl(&dword_2419D9000, v24, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "appendNewEvents, set value error", "{\"msg%{public}.0s\":\"appendNewEvents, set value error\", \"row\":%{public}lu, \"col\":%{public}d, \"numRows\":%{public}d, \"numCols\":%{public}d}", buf, 0x2Eu);
              }
            }
          }
          v12 += 4;
        }
        if (v104 && v102)
        {
          v103 = v102;
          operator delete(v102);
        }
        a3 = v11;
        if (*(_QWORD *)&v100[2])
        {
          v101 = *(_QWORD *)&v100[2];
          operator delete(*(void **)&v100[2]);
        }
        if (*(_QWORD *)v95)
        {
          *(_QWORD *)v96 = *(_QWORD *)v95;
          operator delete(*(void **)v95);
        }
        v10 = (void **)((char *)v10 + 1);
      }
      while (v10 != v69);
    }
    if (!CLMicroLocationUtils::ProbabilityMatrix::normalizeRows((CLMicroLocationUtils::ProbabilityMatrix *)&v72))
    {
      if (onceToken_MicroLocation_Default != -1)
        dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_5);
      v46 = logObject_MicroLocation_Default;
      if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_ERROR))
      {
        *(_QWORD *)v95 = 68289026;
        *(_WORD *)v96 = 2082;
        *(_QWORD *)&v96[2] = "";
        _os_log_impl(&dword_2419D9000, v46, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"Similarity List appending new events, fail to normalize rows\"}", v95, 0x12u);
      }
      if (onceToken_MicroLocation_Default != -1)
        dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_5);
      v47 = logObject_MicroLocation_Default;
      if (os_signpost_enabled((os_log_t)logObject_MicroLocation_Default))
      {
        *(_QWORD *)v95 = 68289026;
        *(_WORD *)v96 = 2082;
        *(_QWORD *)&v96[2] = "";
        _os_signpost_emit_with_name_impl(&dword_2419D9000, v47, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Similarity List appending new events, fail to normalize rows", "{\"msg%{public}.0s\":\"Similarity List appending new events, fail to normalize rows\"}", v95, 0x12u);
      }
      goto LABEL_136;
    }
    CLMicroLocationUtils::ProbabilityMatrix::removeFirstCols(&v72, 1u, (uint64_t)buf);
    if (BYTE4(v88))
    {
      if (*(_BYTE *)(a1 + 57))
      {
        if (onceToken_MicroLocation_Default != -1)
          dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_5);
        v31 = logObject_MicroLocation_Default;
        if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_ERROR))
        {
          *(_QWORD *)v95 = 68289026;
          *(_WORD *)v96 = 2082;
          *(_QWORD *)&v96[2] = "";
          _os_log_impl(&dword_2419D9000, v31, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"Does not support appending new events to a transposed matrix!\"}", v95, 0x12u);
        }
        if (onceToken_MicroLocation_Default != -1)
          dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_5);
        v32 = logObject_MicroLocation_Default;
        if (!os_signpost_enabled((os_log_t)logObject_MicroLocation_Default))
          goto LABEL_133;
        *(_QWORD *)v95 = 68289026;
        *(_WORD *)v96 = 2082;
        *(_QWORD *)&v96[2] = "";
        v33 = "Does not support appending new events to a transposed matrix!";
        v34 = "{\"msg%{public}.0s\":\"Does not support appending new events to a transposed matrix!\"}";
      }
      else
      {
        v49 = ULSettings::get<ULSettings::SimilarityListMaxNumberOfItems>();
        if (CLMicroLocationUtils::ProbabilityMatrix::appendRows((CLMicroLocationUtils::ProbabilityMatrix *)(a1 + 48), (const CLMicroLocationUtils::ProbabilityMatrix *)buf, v49))
        {
          memset(__p, 0, sizeof(__p));
          v50 = *a3;
          v51 = a3[1];
          *(_QWORD *)v95 = __p;
          if (v50 == v51)
          {
            v52 = 0;
          }
          else
          {
            do
            {
              v83 = *(_DWORD *)(v50 + 160);
              std::back_insert_iterator<std::vector<CLMicroLocationProto::ConfidenceLevel>>::operator=[abi:ne180100]((uint64_t *)v95, &v83);
              v50 += 192;
            }
            while (v50 != v51);
            v52 = __p[1];
          }
          v56 = *(_QWORD *)(a1 + 24);
          v57 = *(_QWORD *)(a1 + 32);
          std::vector<CLMicroLocationProto::ConfidenceLevel>::__insert_with_size[abi:ne180100]<std::__wrap_iter<CLMicroLocationProto::ConfidenceLevel*>,std::__wrap_iter<CLMicroLocationProto::ConfidenceLevel*>>((uint64_t)__p, (uint64_t)v52, *(char **)(a1 + 80), *(char **)(a1 + 88), (uint64_t)(*(_QWORD *)(a1 + 88) - *(_QWORD *)(a1 + 80)) >> 2);
          v58 = __p[0];
          v59 = *(_OWORD *)(a1 + 80);
          *(void **)(a1 + 80) = __p[0];
          v60 = *(void **)(a1 + 96);
          v61 = *(_OWORD *)&__p[1];
          *(_OWORD *)__p = v59;
          __p[2] = v60;
          *(_OWORD *)(a1 + 88) = v61;
          if (v49 < (unint64_t)((uint64_t)(v61 - (_QWORD)v58) >> 2))
            std::vector<CLMicroLocationProto::ConfidenceLevel>::resize(a1 + 80, v49);
          std::vector<boost::uuids::uuid>::__insert_with_size[abi:ne180100]<std::__wrap_iter<boost::uuids::uuid*>,std::__wrap_iter<boost::uuids::uuid*>>((uint64_t)v68, v68[1], *(char **)(a1 + 24), *(char **)(a1 + 32), (uint64_t)(*(_QWORD *)(a1 + 32) - *(_QWORD *)(a1 + 24)) >> 4);
          v62 = *v68;
          *v68 = *(_QWORD *)(a1 + 24);
          *(_QWORD *)(a1 + 24) = v62;
          v63 = v68[1];
          v68[1] = *(_QWORD *)(a1 + 32);
          *(_QWORD *)(a1 + 32) = v63;
          v64 = v68[2];
          v68[2] = *(_QWORD *)(a1 + 40);
          *(_QWORD *)(a1 + 40) = v64;
          if (v49 < (unint64_t)((uint64_t)(*(_QWORD *)(a1 + 32) - *(_QWORD *)(a1 + 24)) >> 4))
            std::vector<boost::uuids::uuid>::resize(a1 + 24, v49);
          if (onceToken_MicroLocation_Default != -1)
            dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_5);
          v65 = logObject_MicroLocation_Default;
          if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT))
          {
            v66 = (v68[1] - *v68) >> 4;
            v67 = (uint64_t)(*(_QWORD *)(a1 + 32) - *(_QWORD *)(a1 + 24)) >> 4;
            *(_QWORD *)v95 = 68289794;
            *(_WORD *)v96 = 2082;
            *(_QWORD *)&v96[2] = "";
            v97 = 2050;
            v98 = v66;
            v99 = 2050;
            *(_QWORD *)v100 = (v57 - v56) >> 4;
            *(_WORD *)&v100[8] = 2050;
            v101 = v67;
            _os_log_impl(&dword_2419D9000, v65, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"Similarity List appended new events\", \"Num new Labels\":%{public}lu, \"Old LSL length\":%{public}lu, \"New LSL length\":%{public}lu}", v95, 0x30u);
          }
          if (__p[0])
          {
            __p[1] = __p[0];
            operator delete(__p[0]);
          }
          goto LABEL_133;
        }
        if (onceToken_MicroLocation_Default != -1)
          dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_5);
        v53 = logObject_MicroLocation_Default;
        if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_ERROR))
        {
          *(_QWORD *)v95 = 68289026;
          *(_WORD *)v96 = 2082;
          *(_QWORD *)&v96[2] = "";
          _os_log_impl(&dword_2419D9000, v53, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"Similarity List appending new events, fail to append rows\"}", v95, 0x12u);
        }
        if (onceToken_MicroLocation_Default != -1)
          dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_5);
        v32 = logObject_MicroLocation_Default;
        if (!os_signpost_enabled((os_log_t)logObject_MicroLocation_Default))
          goto LABEL_133;
        *(_QWORD *)v95 = 68289026;
        *(_WORD *)v96 = 2082;
        *(_QWORD *)&v96[2] = "";
        v33 = "Similarity List appending new events, fail to append rows";
        v34 = "{\"msg%{public}.0s\":\"Similarity List appending new events, fail to append rows\"}";
      }
    }
    else
    {
      if (onceToken_MicroLocation_Default != -1)
        dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_5);
      v48 = logObject_MicroLocation_Default;
      if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_ERROR))
      {
        *(_QWORD *)v95 = 68289026;
        *(_WORD *)v96 = 2082;
        *(_QWORD *)&v96[2] = "";
        _os_log_impl(&dword_2419D9000, v48, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"Similarity List appending new events, fail to remove nullspace column\"}", v95, 0x12u);
      }
      if (onceToken_MicroLocation_Default != -1)
        dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_5);
      v32 = logObject_MicroLocation_Default;
      if (!os_signpost_enabled((os_log_t)logObject_MicroLocation_Default))
        goto LABEL_133;
      *(_QWORD *)v95 = 68289026;
      *(_WORD *)v96 = 2082;
      *(_QWORD *)&v96[2] = "";
      v33 = "Similarity List appending new events, fail to remove nullspace column";
      v34 = "{\"msg%{public}.0s\":\"Similarity List appending new events, fail to remove nullspace column\"}";
    }
    _os_signpost_emit_with_name_impl(&dword_2419D9000, v32, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, v33, v34, v95, 0x12u);
LABEL_133:
    if (BYTE4(v88))
    {
      v54 = *(_QWORD *)buf;
      *(_QWORD *)buf = 0;
      if (v54)
        MEMORY[0x2426A04BC](v54, 0x1000C8000313F17);
    }
LABEL_136:
    v55 = v72;
    v72 = 0;
    if (v55)
      MEMORY[0x2426A04BC](v55, 0x1000C8000313F17);
    goto LABEL_138;
  }
  if (onceToken_MicroLocation_Default != -1)
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_5);
  v35 = logObject_MicroLocation_Default;
  if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_ERROR))
  {
    v36 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(a3[1] - *a3) >> 6);
    v37 = (a4[1] - *a4) >> 4;
    *(_QWORD *)v95 = 68289538;
    *(_WORD *)v96 = 2082;
    *(_QWORD *)&v96[2] = "";
    v97 = 2050;
    v98 = v36;
    v99 = 2050;
    *(_QWORD *)v100 = v37;
    _os_log_impl(&dword_2419D9000, v35, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"SimilarityListData, appendNewEvents, fingerprints size not equal labelUuids size!\", \"Num Fingerprints\":%{public}lu, \"Num Labels\":%{public}lu}", v95, 0x26u);
  }
  if (onceToken_MicroLocation_Default != -1)
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_5);
  v38 = logObject_MicroLocation_Default;
  if (os_signpost_enabled((os_log_t)logObject_MicroLocation_Default))
  {
    v39 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(a3[1] - *a3) >> 6);
    v40 = (a4[1] - *a4) >> 4;
    *(_QWORD *)v95 = 68289538;
    *(_WORD *)v96 = 2082;
    *(_QWORD *)&v96[2] = "";
    v97 = 2050;
    v98 = v39;
    v99 = 2050;
    *(_QWORD *)v100 = v40;
    _os_signpost_emit_with_name_impl(&dword_2419D9000, v38, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "SimilarityListData, appendNewEvents, fingerprints size not equal labelUuids size!", "{\"msg%{public}.0s\":\"SimilarityListData, appendNewEvents, fingerprints size not equal labelUuids size!\", \"Num Fingerprints\":%{public}lu, \"Num Labels\":%{public}lu}", v95, 0x26u);
  }
LABEL_138:

  std::__tree<std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>,std::__map_value_compare<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>,std::less<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes>,true>,std::allocator<std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>>>::destroy((uint64_t)v76, v77);
  if (v80 < 0)
    operator delete(v79[0]);
  if (v82)
    CLMicroLocationProto::AssociatedAccessPointInfo::~AssociatedAccessPointInfo((CLMicroLocationProto::AssociatedAccessPointInfo *)v81);
}

void sub_2419FF3C0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,id a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,void *a26,uint64_t a27,int a28,__int16 a29,char a30,char a31,char a32,uint64_t a33,uint64_t a34,uint64_t a35,char a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,char a41)
{
  uint64_t v42;

  if (__p)
    operator delete(__p);
  if (a41)
  {
    v42 = a38;
    a38 = 0;
    if (v42)
      MEMORY[0x2426A04BC](v42, 0x1000C8000313F17);
  }
  if (a18)
    MEMORY[0x2426A04BC](a18, 0x1000C8000313F17);
  CLMicroLocationLocalizationSettings::~CLMicroLocationLocalizationSettings(&a21);
  if (a31 < 0)
    operator delete(a26);
  if (a36)
    CLMicroLocationProto::AssociatedAccessPointInfo::~AssociatedAccessPointInfo((CLMicroLocationProto::AssociatedAccessPointInfo *)&a32);
  _Unwind_Resume(a1);
}

uint64_t ULSettings::get<ULSettings::SimilarityListMaxNumberOfItems>()
{
  void *v0;
  void *v1;
  void *v2;
  void *v3;
  uint64_t v4;
  uint64_t v5;

  +[ULDefaultsSingleton shared](ULDefaultsSingleton, "shared");
  v0 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v0, "defaultsDictionary");
  v1 = (void *)objc_claimAutoreleasedReturnValue();

  objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "ULSimilarityListMaxNumberOfItems");
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v1, "objectForKey:", v2);
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  if (v3 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
    v4 = objc_msgSend(v3, "intValue");
  else
    v4 = objc_msgSend(&unk_2511ED2E8, "intValue");
  v5 = v4;

  return v5;
}

{
  void *v0;
  void *v1;
  void *v2;
  void *v3;
  uint64_t v4;
  uint64_t v5;

  +[ULDefaultsSingleton shared](ULDefaultsSingleton, "shared");
  v0 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v0, "defaultsDictionary");
  v1 = (void *)objc_claimAutoreleasedReturnValue();

  objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "ULSimilarityListMaxNumberOfItems");
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v1, "objectForKey:", v2);
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  if (v3 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
    v4 = objc_msgSend(v3, "intValue");
  else
    v4 = objc_msgSend(&unk_2511ED9F0, "intValue");
  v5 = v4;

  return v5;
}

void sub_2419FF5A4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void std::vector<CLMicroLocationProto::ConfidenceLevel>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v2;

  v2 = (uint64_t)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 2;
  if (a2 <= v2)
  {
    if (a2 < v2)
      *(_QWORD *)(a1 + 8) = *(_QWORD *)a1 + 4 * a2;
  }
  else
  {
    std::vector<CLMicroLocationProto::ConfidenceLevel>::__append((char **)a1, a2 - v2);
  }
}

void std::vector<boost::uuids::uuid>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v2;

  v2 = (uint64_t)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 4;
  if (a2 <= v2)
  {
    if (a2 < v2)
      *(_QWORD *)(a1 + 8) = *(_QWORD *)a1 + 16 * a2;
  }
  else
  {
    std::vector<boost::uuids::uuid>::__append((void **)a1, a2 - v2);
  }
}

void ULSettings::convert<NSString * {__strong},std::string>(void *a1@<X0>, _QWORD *a2@<X8>)
{
  id v3;

  v3 = objc_retainAutorelease(a1);
  std::string::basic_string[abi:ne180100]<0>(a2, (char *)objc_msgSend(v3, "UTF8String"));

}

{
  id v3;

  v3 = objc_retainAutorelease(a1);
  std::string::basic_string[abi:ne180100]<0>(a2, (char *)objc_msgSend(v3, "UTF8String"));

}

{
  id v3;

  v3 = objc_retainAutorelease(a1);
  std::string::basic_string[abi:ne180100]<0>(a2, (char *)objc_msgSend(v3, "UTF8String"));

}

void sub_2419FF684(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

uint64_t std::__optional_destruct_base<CLMicroLocationModel::BlueAtlasData,false>::~__optional_destruct_base[abi:ne180100](uint64_t a1)
{
  void *v2;
  void *v3;

  if (*(_BYTE *)(a1 + 88))
  {
    v2 = *(void **)(a1 + 24);
    if (v2)
    {
      *(_QWORD *)(a1 + 32) = v2;
      operator delete(v2);
    }
    v3 = *(void **)a1;
    if (*(_QWORD *)a1)
    {
      *(_QWORD *)(a1 + 8) = v3;
      operator delete(v3);
    }
  }
  return a1;
}

uint64_t std::__optional_destruct_base<CLMicroLocationModel::SimilarityListData,false>::~__optional_destruct_base[abi:ne180100](uint64_t a1)
{
  void *v2;
  uint64_t v3;
  void *v4;
  void *v5;

  if (*(_BYTE *)(a1 + 120))
  {
    v2 = *(void **)(a1 + 80);
    if (v2)
    {
      *(_QWORD *)(a1 + 88) = v2;
      operator delete(v2);
    }
    if (*(_BYTE *)(a1 + 72))
    {
      v3 = *(_QWORD *)(a1 + 48);
      *(_QWORD *)(a1 + 48) = 0;
      if (v3)
        MEMORY[0x2426A04BC](v3, 0x1000C8000313F17);
    }
    v4 = *(void **)(a1 + 24);
    if (v4)
    {
      *(_QWORD *)(a1 + 32) = v4;
      operator delete(v4);
    }
    v5 = *(void **)a1;
    if (*(_QWORD *)a1)
    {
      *(_QWORD *)(a1 + 8) = v5;
      operator delete(v5);
    }
  }
  return a1;
}

uint64_t wireless_diagnostics::google::protobuf::internal::GenericTypeHandler<CLMicroLocationProto::Fingerprint>::New()
{
  uint64_t v0;

  v0 = operator new();
  CLMicroLocationProto::Fingerprint::Fingerprint(v0);
  return v0;
}

void sub_2419FF79C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x2426A04D4](v1, 0x10A1C40FC75E0FCLL);
  _Unwind_Resume(a1);
}

uint64_t wireless_diagnostics::google::protobuf::internal::GenericTypeHandler<CLMicroLocationProto::ClusterRecordings>::New()
{
  uint64_t v0;

  v0 = operator new();
  CLMicroLocationProto::ClusterRecordings::ClusterRecordings(v0);
  return v0;
}

void sub_2419FF7FC(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x2426A04D4](v1, 0x10A1C40F1948F29);
  _Unwind_Resume(a1);
}

void ___ZL45_CLLogObjectForCategory_MicroLocation_Defaultv_block_invoke_2()
{
  os_log_t v0;
  void *v1;

  v0 = os_log_create("com.apple.MicroLocation", "MicroLocation");
  v1 = (void *)logObject_MicroLocation_Default;
  logObject_MicroLocation_Default = (uint64_t)v0;

}

_DWORD *wireless_diagnostics::google::protobuf::RepeatedField<int>::Reserve(_DWORD *result, int a2)
{
  int v2;
  _DWORD *v3;
  const void *v4;
  int v5;

  v2 = result[3];
  if (v2 < a2)
  {
    v3 = result;
    v4 = *(const void **)result;
    v5 = 2 * v2;
    if (v5 <= a2)
      v5 = a2;
    if (v5 <= 4)
      v5 = 4;
    result[3] = v5;
    result = (_DWORD *)operator new[]();
    *(_QWORD *)v3 = result;
    if (v4)
    {
      memcpy(result, v4, 4 * (int)v3[2]);
      JUMPOUT(0x2426A04BCLL);
    }
  }
  return result;
}

void std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>>>::__assign_multi<std::__hash_const_iterator<std::__hash_node<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,void *> *>>(_QWORD *a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t v6;
  uint64_t i;
  uint64_t *v8;
  __int128 v9;
  uint64_t *v10;
  uint64_t *v11;

  v6 = a1[1];
  if (!v6)
    goto LABEL_9;
  for (i = 0; i != v6; *(_QWORD *)(*a1 + 8 * i++) = 0)
    ;
  v8 = (uint64_t *)a1[2];
  a1[2] = 0;
  a1[3] = 0;
  if (v8)
  {
    while (a2 != a3)
    {
      *((_OWORD *)v8 + 1) = *((_OWORD *)a2 + 1);
      v9 = *((_OWORD *)a2 + 2);
      *((_DWORD *)v8 + 12) = *((_DWORD *)a2 + 12);
      *((_OWORD *)v8 + 2) = v9;
      v10 = (uint64_t *)*v8;
      std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>>>::__node_insert_multi(a1, v8);
      a2 = (uint64_t *)*a2;
      v8 = v10;
      if (!v10)
        goto LABEL_9;
    }
    do
    {
      v11 = (uint64_t *)*v8;
      operator delete(v8);
      v8 = v11;
    }
    while (v11);
  }
  else
  {
LABEL_9:
    while (a2 != a3)
    {
      std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>>>::__emplace_multi<std::pair<boost::uuids::uuid const,CLMicroLocationAnchorAppearance> const&>(a1, (uint64_t)(a2 + 2));
      a2 = (uint64_t *)*a2;
    }
  }
}

void sub_2419FF9B8(void *a1)
{
  _QWORD *v1;
  _QWORD *v2;

  __cxa_begin_catch(a1);
  do
  {
    v2 = (_QWORD *)*v1;
    operator delete(v1);
    v1 = v2;
  }
  while (v2);
  __cxa_rethrow();
}

void sub_2419FF9D8(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

_QWORD *std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>>>::__node_insert_multi(_QWORD *a1, _QWORD *a2)
{
  unint64_t v4;
  uint64_t i;
  _QWORD *inserted;

  v4 = 0;
  for (i = 16; i != 32; ++i)
    v4 ^= (v4 << 6) + (v4 >> 2) + 2654435769u + *((unsigned __int8 *)a2 + i);
  a2[1] = v4;
  inserted = std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>>>::__node_insert_multi_prepare((uint64_t)a1, v4, a2 + 2);
  std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>>>::__node_insert_multi_perform(a1, a2, inserted);
  return a2;
}

_QWORD *std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>>>::__node_insert_multi_prepare(uint64_t a1, unint64_t a2, _QWORD *a3)
{
  unint64_t v6;
  float v7;
  float v8;
  uint64_t v9;
  _BOOL8 v10;
  size_t v11;
  unint64_t v12;
  size_t v13;
  uint8x8_t v14;
  unint64_t v15;
  _QWORD *v16;
  int v17;
  _QWORD *result;
  unint64_t v19;
  unint64_t v20;
  BOOL v21;
  _BOOL4 v22;
  int v23;

  v6 = *(_QWORD *)(a1 + 8);
  v7 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v8 = *(float *)(a1 + 32);
  if (!v6 || (float)(v8 * (float)v6) < v7)
  {
    v9 = 2 * v6;
    v10 = v6 < 3 || (v6 & (v6 - 1)) != 0;
    v11 = v10 | v9;
    v12 = vcvtps_u32_f32(v7 / v8);
    if (v11 <= v12)
      v13 = v12;
    else
      v13 = v11;
    std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>>>::__rehash<false>(a1, v13);
    v6 = *(_QWORD *)(a1 + 8);
  }
  v14 = (uint8x8_t)vcnt_s8((int8x8_t)v6);
  v14.i16[0] = vaddlv_u8(v14);
  if (v14.u32[0] > 1uLL)
  {
    v15 = a2;
    if (v6 <= a2)
      v15 = a2 % v6;
  }
  else
  {
    v15 = (v6 - 1) & a2;
  }
  v16 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v15);
  if (!v16)
    return 0;
  v17 = 0;
  do
  {
    result = v16;
    v16 = (_QWORD *)*v16;
    if (!v16)
      break;
    v19 = v16[1];
    if (v14.u32[0] > 1uLL)
    {
      v20 = v16[1];
      if (v19 >= v6)
        v20 = v19 % v6;
    }
    else
    {
      v20 = v19 & (v6 - 1);
    }
    if (v20 != v15)
      break;
    if (v19 == a2)
    {
      v21 = v16[2] == *a3 && v16[3] == a3[1];
      v22 = v21;
    }
    else
    {
      v22 = 0;
    }
    v23 = v17 & !v22;
    v17 |= v22;
  }
  while (v23 != 1);
  return result;
}

_QWORD *std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>>>::__node_insert_multi_perform(_QWORD *result, _QWORD *a2, _QWORD *a3)
{
  int8x8_t v3;
  unint64_t v4;
  uint8x8_t v5;
  unint64_t v6;

  v3 = (int8x8_t)result[1];
  v4 = a2[1];
  v5 = (uint8x8_t)vcnt_s8(v3);
  v5.i16[0] = vaddlv_u8(v5);
  if (v5.u32[0] > 1uLL)
  {
    if (v4 >= *(_QWORD *)&v3)
      v4 %= *(_QWORD *)&v3;
  }
  else
  {
    v4 &= *(_QWORD *)&v3 - 1;
  }
  if (!a3)
  {
    *a2 = result[2];
    result[2] = a2;
    *(_QWORD *)(*result + 8 * v4) = result + 2;
    if (!*a2)
      goto LABEL_19;
    v6 = *(_QWORD *)(*a2 + 8);
    if (v5.u32[0] > 1uLL)
    {
      if (v6 >= *(_QWORD *)&v3)
        v6 %= *(_QWORD *)&v3;
    }
    else
    {
      v6 &= *(_QWORD *)&v3 - 1;
    }
LABEL_18:
    *(_QWORD *)(*result + 8 * v6) = a2;
    goto LABEL_19;
  }
  *a2 = *a3;
  *a3 = a2;
  if (*a2)
  {
    v6 = *(_QWORD *)(*a2 + 8);
    if (v5.u32[0] > 1uLL)
    {
      if (v6 >= *(_QWORD *)&v3)
        v6 %= *(_QWORD *)&v3;
    }
    else
    {
      v6 &= *(_QWORD *)&v3 - 1;
    }
    if (v6 != v4)
      goto LABEL_18;
  }
LABEL_19:
  ++result[3];
  return result;
}

void std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>>>::__rehash<false>(uint64_t a1, size_t __n)
{
  size_t prime;
  int8x8_t v4;
  unint64_t v5;
  uint8x8_t v6;
  uint64_t v7;

  if (__n == 1)
  {
    prime = 2;
  }
  else
  {
    prime = __n;
    if ((__n & (__n - 1)) != 0)
      prime = std::__next_prime(__n);
  }
  v4 = *(int8x8_t *)(a1 + 8);
  if (prime > *(_QWORD *)&v4)
    goto LABEL_16;
  if (prime < *(_QWORD *)&v4)
  {
    v5 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
    if (*(_QWORD *)&v4 < 3uLL || (v6 = (uint8x8_t)vcnt_s8(v4), v6.i16[0] = vaddlv_u8(v6), v6.u32[0] > 1uLL))
    {
      v5 = std::__next_prime(v5);
    }
    else
    {
      v7 = 1 << -(char)__clz(v5 - 1);
      if (v5 >= 2)
        v5 = v7;
    }
    if (prime <= v5)
      prime = v5;
    if (prime < *(_QWORD *)&v4)
LABEL_16:
      std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>>>::__do_rehash<false>(a1, prime);
  }
}

void std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>>>::__do_rehash<false>(uint64_t a1, unint64_t a2)
{
  void *v4;
  void *v5;
  uint64_t v6;
  _QWORD *v7;
  unint64_t v8;
  uint8x8_t v9;
  void *v10;
  _QWORD *i;
  unint64_t v12;
  _QWORD *v13;
  _QWORD *v14;

  if (a2)
  {
    if (a2 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v4 = operator new(8 * a2);
    v5 = *(void **)a1;
    *(_QWORD *)a1 = v4;
    if (v5)
      operator delete(v5);
    v6 = 0;
    *(_QWORD *)(a1 + 8) = a2;
    do
      *(_QWORD *)(*(_QWORD *)a1 + 8 * v6++) = 0;
    while (a2 != v6);
    v7 = *(_QWORD **)(a1 + 16);
    if (v7)
    {
      v8 = v7[1];
      v9 = (uint8x8_t)vcnt_s8((int8x8_t)a2);
      v9.i16[0] = vaddlv_u8(v9);
      if (v9.u32[0] > 1uLL)
      {
        if (v8 >= a2)
          v8 %= a2;
      }
      else
      {
        v8 &= a2 - 1;
      }
      *(_QWORD *)(*(_QWORD *)a1 + 8 * v8) = a1 + 16;
      for (i = (_QWORD *)*v7; *v7; i = (_QWORD *)*v7)
      {
        v12 = i[1];
        if (v9.u32[0] > 1uLL)
        {
          if (v12 >= a2)
            v12 %= a2;
        }
        else
        {
          v12 &= a2 - 1;
        }
        if (v12 == v8)
        {
          v7 = i;
        }
        else
        {
          v13 = i;
          if (*(_QWORD *)(*(_QWORD *)a1 + 8 * v12))
          {
            do
            {
              v14 = v13;
              v13 = (_QWORD *)*v13;
              if (!v13)
                break;
            }
            while (i[2] == v13[2] && i[3] == v13[3]);
            *v7 = v13;
            *v14 = **(_QWORD **)(*(_QWORD *)a1 + 8 * v12);
            **(_QWORD **)(*(_QWORD *)a1 + 8 * v12) = i;
          }
          else
          {
            *(_QWORD *)(*(_QWORD *)a1 + 8 * v12) = v7;
            v7 = i;
            v8 = v12;
          }
        }
      }
    }
  }
  else
  {
    v10 = *(void **)a1;
    *(_QWORD *)a1 = 0;
    if (v10)
      operator delete(v10);
    *(_QWORD *)(a1 + 8) = 0;
  }
}

_QWORD *std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>>>::__emplace_multi<std::pair<boost::uuids::uuid const,CLMicroLocationAnchorAppearance> const&>(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;

  std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>>>::__construct_node<std::pair<boost::uuids::uuid const,CLMicroLocationAnchorAppearance> const&>((uint64_t)a1, a2, (uint64_t)&v4);
  return std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>>>::__node_insert_multi(a1, v4);
}

void sub_2419FFF2C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

_OWORD *std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>>>::__construct_node<std::pair<boost::uuids::uuid const,CLMicroLocationAnchorAppearance> const&>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v5;
  _OWORD *result;
  uint64_t v7;
  unint64_t v8;
  __int128 v9;

  v5 = a1 + 16;
  result = operator new(0x38uLL);
  v7 = 0;
  v8 = 0;
  *(_QWORD *)a3 = result;
  *(_QWORD *)(a3 + 8) = v5;
  *(_BYTE *)(a3 + 16) = 1;
  *(_QWORD *)result = 0;
  v9 = *(_OWORD *)(a2 + 16);
  result[1] = *(_OWORD *)a2;
  result[2] = v9;
  *((_QWORD *)result + 6) = *(_QWORD *)(a2 + 32);
  do
    v8 ^= (v8 << 6) + (v8 >> 2) + 2654435769u + *((unsigned __int8 *)result + v7++ + 16);
  while (v7 != 16);
  *((_QWORD *)result + 1) = v8;
  return result;
}

uint64_t std::unordered_map<boost::uuids::uuid,CLMicroLocationAnchorAppearance>::unordered_map(uint64_t a1, uint64_t a2)
{
  _QWORD *i;

  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 32) = *(_DWORD *)(a2 + 32);
  std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>>>::__rehash<true>(a1, *(_QWORD *)(a2 + 8));
  for (i = *(_QWORD **)(a2 + 16); i; i = (_QWORD *)*i)
    std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>>>::__emplace_unique_key_args<boost::uuids::uuid,std::pair<boost::uuids::uuid const,CLMicroLocationAnchorAppearance> const&>(a1, i + 2, (uint64_t)(i + 2));
  return a1;
}

void sub_241A00034(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>>>::~__hash_table(v1);
  _Unwind_Resume(a1);
}

void std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>>>::__rehash<true>(uint64_t a1, size_t __n)
{
  size_t prime;
  int8x8_t v4;
  unint64_t v5;
  uint8x8_t v6;
  uint64_t v7;

  if (__n == 1)
  {
    prime = 2;
  }
  else
  {
    prime = __n;
    if ((__n & (__n - 1)) != 0)
      prime = std::__next_prime(__n);
  }
  v4 = *(int8x8_t *)(a1 + 8);
  if (prime > *(_QWORD *)&v4)
    goto LABEL_16;
  if (prime < *(_QWORD *)&v4)
  {
    v5 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
    if (*(_QWORD *)&v4 < 3uLL || (v6 = (uint8x8_t)vcnt_s8(v4), v6.i16[0] = vaddlv_u8(v6), v6.u32[0] > 1uLL))
    {
      v5 = std::__next_prime(v5);
    }
    else
    {
      v7 = 1 << -(char)__clz(v5 - 1);
      if (v5 >= 2)
        v5 = v7;
    }
    if (prime <= v5)
      prime = v5;
    if (prime < *(_QWORD *)&v4)
LABEL_16:
      std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>>>::__do_rehash<true>(a1, prime);
  }
}

void std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>>>::__do_rehash<true>(uint64_t a1, unint64_t a2)
{
  void *v4;
  void *v5;
  uint64_t v6;
  _QWORD *v7;
  unint64_t v8;
  uint8x8_t v9;
  void *v10;
  _QWORD *v11;
  unint64_t v12;

  if (a2)
  {
    if (a2 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v4 = operator new(8 * a2);
    v5 = *(void **)a1;
    *(_QWORD *)a1 = v4;
    if (v5)
      operator delete(v5);
    v6 = 0;
    *(_QWORD *)(a1 + 8) = a2;
    do
      *(_QWORD *)(*(_QWORD *)a1 + 8 * v6++) = 0;
    while (a2 != v6);
    v7 = *(_QWORD **)(a1 + 16);
    if (v7)
    {
      v8 = v7[1];
      v9 = (uint8x8_t)vcnt_s8((int8x8_t)a2);
      v9.i16[0] = vaddlv_u8(v9);
      if (v9.u32[0] > 1uLL)
      {
        if (v8 >= a2)
          v8 %= a2;
      }
      else
      {
        v8 &= a2 - 1;
      }
      *(_QWORD *)(*(_QWORD *)a1 + 8 * v8) = a1 + 16;
      v11 = (_QWORD *)*v7;
      if (*v7)
      {
        do
        {
          v12 = v11[1];
          if (v9.u32[0] > 1uLL)
          {
            if (v12 >= a2)
              v12 %= a2;
          }
          else
          {
            v12 &= a2 - 1;
          }
          if (v12 != v8)
          {
            if (!*(_QWORD *)(*(_QWORD *)a1 + 8 * v12))
            {
              *(_QWORD *)(*(_QWORD *)a1 + 8 * v12) = v7;
              goto LABEL_24;
            }
            *v7 = *v11;
            *v11 = **(_QWORD **)(*(_QWORD *)a1 + 8 * v12);
            **(_QWORD **)(*(_QWORD *)a1 + 8 * v12) = v11;
            v11 = v7;
          }
          v12 = v8;
LABEL_24:
          v7 = v11;
          v11 = (_QWORD *)*v11;
          v8 = v12;
        }
        while (v11);
      }
    }
  }
  else
  {
    v10 = *(void **)a1;
    *(_QWORD *)a1 = 0;
    if (v10)
      operator delete(v10);
    *(_QWORD *)(a1 + 8) = 0;
  }
}

_QWORD *std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>>>::__emplace_unique_key_args<boost::uuids::uuid,std::pair<boost::uuids::uuid const,CLMicroLocationAnchorAppearance> const&>(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  unint64_t v3;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  uint8x8_t v9;
  void **v10;
  _QWORD *v11;
  unint64_t v12;
  __int128 v14;
  float v15;
  float v16;
  _BOOL8 v17;
  unint64_t v18;
  unint64_t v19;
  size_t v20;
  uint64_t v21;
  _QWORD *v22;
  unint64_t v23;

  v6 = 0;
  v7 = 0;
  do
    v7 ^= (v7 << 6) + (v7 >> 2) + 2654435769u + *((unsigned __int8 *)a2 + v6++);
  while (v6 != 16);
  v8 = *(_QWORD *)(a1 + 8);
  if (v8)
  {
    v9 = (uint8x8_t)vcnt_s8((int8x8_t)v8);
    v9.i16[0] = vaddlv_u8(v9);
    if (v9.u32[0] > 1uLL)
    {
      v3 = v7;
      if (v7 >= v8)
        v3 = v7 % v8;
    }
    else
    {
      v3 = (v8 - 1) & v7;
    }
    v10 = *(void ***)(*(_QWORD *)a1 + 8 * v3);
    if (v10)
    {
      v11 = *v10;
      if (*v10)
      {
        do
        {
          v12 = v11[1];
          if (v12 == v7)
          {
            if (v11[2] == *a2 && v11[3] == a2[1])
              return v11;
          }
          else
          {
            if (v9.u32[0] > 1uLL)
            {
              if (v12 >= v8)
                v12 %= v8;
            }
            else
            {
              v12 &= v8 - 1;
            }
            if (v12 != v3)
              break;
          }
          v11 = (_QWORD *)*v11;
        }
        while (v11);
      }
    }
  }
  v11 = operator new(0x38uLL);
  *v11 = 0;
  v11[1] = v7;
  v14 = *(_OWORD *)(a3 + 16);
  *((_OWORD *)v11 + 1) = *(_OWORD *)a3;
  *((_OWORD *)v11 + 2) = v14;
  v11[6] = *(_QWORD *)(a3 + 32);
  v15 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v16 = *(float *)(a1 + 32);
  if (!v8 || (float)(v16 * (float)v8) < v15)
  {
    v17 = 1;
    if (v8 >= 3)
      v17 = (v8 & (v8 - 1)) != 0;
    v18 = v17 | (2 * v8);
    v19 = vcvtps_u32_f32(v15 / v16);
    if (v18 <= v19)
      v20 = v19;
    else
      v20 = v18;
    std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>>>::__rehash<true>(a1, v20);
    v8 = *(_QWORD *)(a1 + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v7 >= v8)
        v3 = v7 % v8;
      else
        v3 = v7;
    }
    else
    {
      v3 = (v8 - 1) & v7;
    }
  }
  v21 = *(_QWORD *)a1;
  v22 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v3);
  if (v22)
  {
    *v11 = *v22;
LABEL_44:
    *v22 = v11;
    goto LABEL_45;
  }
  *v11 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = v11;
  *(_QWORD *)(v21 + 8 * v3) = a1 + 16;
  if (*v11)
  {
    v23 = *(_QWORD *)(*v11 + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v23 >= v8)
        v23 %= v8;
    }
    else
    {
      v23 &= v8 - 1;
    }
    v22 = (_QWORD *)(*(_QWORD *)a1 + 8 * v23);
    goto LABEL_44;
  }
LABEL_45:
  ++*(_QWORD *)(a1 + 24);
  return v11;
}

void sub_241A004C4(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t *std::__optional_storage_base<CLMicroLocationUtils::ProbabilityMatrix,false>::__assign_from[abi:ne180100]<std::__optional_move_assign_base<CLMicroLocationUtils::ProbabilityMatrix,false>>(uint64_t *result, uint64_t a2)
{
  uint64_t *v2;

  v2 = result;
  if (*((unsigned __int8 *)result + 24) == *(unsigned __int8 *)(a2 + 24))
  {
    if (*((_BYTE *)result + 24))
      return CLMicroLocationUtils::ProbabilityMatrix::operator=(result, (uint64_t *)a2);
  }
  else if (*((_BYTE *)result + 24))
  {
    result = (uint64_t *)*result;
    *v2 = 0;
    if (result)
      result = (uint64_t *)MEMORY[0x2426A04BC](result, 0x1000C8000313F17);
    *((_BYTE *)v2 + 24) = 0;
  }
  else
  {
    result = (uint64_t *)CLMicroLocationUtils::ProbabilityMatrix::ProbabilityMatrix(result);
    *((_BYTE *)v2 + 24) = 1;
  }
  return result;
}

_QWORD *wireless_diagnostics::google::protobuf::internal::GenericTypeHandler<CLMicroLocationProto::LocationSimilarityListElement>::New()
{
  _QWORD *v0;

  v0 = (_QWORD *)operator new();
  CLMicroLocationProto::LocationSimilarityListElement::LocationSimilarityListElement(v0);
  return v0;
}

void sub_241A00590(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x2426A04D4](v1, 0x10A1C407F42033CLL);
  _Unwind_Resume(a1);
}

_DWORD *wireless_diagnostics::google::protobuf::RepeatedField<double>::Reserve(_DWORD *result, int a2)
{
  int v2;
  _DWORD *v3;
  const void *v4;
  int v5;

  v2 = result[3];
  if (v2 < a2)
  {
    v3 = result;
    v4 = *(const void **)result;
    v5 = 2 * v2;
    if (v5 <= a2)
      v5 = a2;
    if (v5 <= 4)
      v5 = 4;
    result[3] = v5;
    result = (_DWORD *)operator new[]();
    *(_QWORD *)v3 = result;
    if (v4)
    {
      memcpy(result, v4, 8 * (int)v3[2]);
      JUMPOUT(0x2426A04BCLL);
    }
  }
  return result;
}

void std::vector<std::pair<std::shared_ptr<CLMicroLocationFingerprint>,boost::uuids::uuid>>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v1;
  void *v2;
  uint64_t v4;
  void *v5;

  v1 = *a1;
  v2 = **a1;
  if (v2)
  {
    v4 = (uint64_t)v1[1];
    v5 = v2;
    if ((void *)v4 != v2)
    {
      do
        v4 = std::shared_ptr<CLMiLoService::ModelAndConf>::~shared_ptr[abi:ne180100](v4 - 32);
      while ((void *)v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t std::__hash_table<std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>>>::~__hash_table(uint64_t a1)
{
  void *v2;

  std::__hash_table<std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>>>::__deallocate_node(a1, *(_QWORD **)(a1 + 16));
  v2 = *(void **)a1;
  *(_QWORD *)a1 = 0;
  if (v2)
    operator delete(v2);
  return a1;
}

void std::__hash_table<std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>>>::__deallocate_node(int a1, _QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;
  void *v4;

  if (__p)
  {
    v2 = __p;
    do
    {
      v3 = (_QWORD *)*v2;
      v4 = (void *)v2[4];
      if (v4)
      {
        v2[5] = v4;
        operator delete(v4);
      }
      operator delete(v2);
      v2 = v3;
    }
    while (v3);
  }
}

uint64_t std::__construct_at[abi:ne180100]<CLMicroLocationModel::SimilarityListData,CLMicroLocationModel::SimilarityListData,CLMicroLocationModel::SimilarityListData*>(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(_QWORD *)(a1 + 16) = *(_QWORD *)(a2 + 16);
  *(_QWORD *)a2 = 0;
  *(_QWORD *)(a2 + 8) = 0;
  *(_QWORD *)(a2 + 16) = 0;
  *(_QWORD *)(a1 + 24) = 0;
  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 40) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)(a2 + 24);
  *(_QWORD *)(a1 + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 24) = 0;
  *(_QWORD *)(a2 + 32) = 0;
  *(_QWORD *)(a2 + 40) = 0;
  std::__optional_move_base<CLMicroLocationUtils::ProbabilityMatrix,false>::__optional_move_base[abi:ne180100]((_BYTE *)(a1 + 48), a2 + 48);
  *(_QWORD *)(a1 + 80) = 0;
  *(_QWORD *)(a1 + 88) = 0;
  *(_QWORD *)(a1 + 96) = 0;
  *(_OWORD *)(a1 + 80) = *(_OWORD *)(a2 + 80);
  *(_QWORD *)(a1 + 96) = *(_QWORD *)(a2 + 96);
  *(_QWORD *)(a2 + 80) = 0;
  *(_QWORD *)(a2 + 88) = 0;
  *(_QWORD *)(a2 + 96) = 0;
  *(_OWORD *)(a1 + 104) = *(_OWORD *)(a2 + 104);
  return a1;
}

void sub_241A007DC(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void **v2;
  void *v4;
  void *v5;

  v4 = *v2;
  if (*v2)
  {
    *(_QWORD *)(v1 + 32) = v4;
    operator delete(v4);
  }
  v5 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v5;
    operator delete(v5);
  }
  _Unwind_Resume(exception_object);
}

_BYTE *std::__optional_move_base<CLMicroLocationUtils::ProbabilityMatrix,false>::__optional_move_base[abi:ne180100](_BYTE *a1, uint64_t a2)
{
  *a1 = 0;
  a1[24] = 0;
  if (*(_BYTE *)(a2 + 24))
  {
    CLMicroLocationUtils::ProbabilityMatrix::ProbabilityMatrix(a1);
    a1[24] = 1;
  }
  return a1;
}

void sub_241A00848(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (*(_BYTE *)(v1 + 24))
    std::__optional_move_base<CLMicroLocationUtils::ProbabilityMatrix,false>::__optional_move_base[abi:ne180100]((uint64_t *)v1);
  _Unwind_Resume(exception_object);
}

char *std::vector<boost::uuids::uuid>::__init_with_size[abi:ne180100]<std::__hash_const_iterator<std::__hash_node<boost::uuids::uuid,void *> *>,std::__hash_const_iterator<std::__hash_node<boost::uuids::uuid,void *> *>>(char *result, uint64_t *a2, uint64_t *a3, unint64_t a4)
{
  char *v6;
  _OWORD *v7;

  if (a4)
  {
    v6 = result;
    result = std::vector<boost::uuids::uuid>::__vallocate[abi:ne180100](result, a4);
    v7 = (_OWORD *)*((_QWORD *)v6 + 1);
    while (a2 != a3)
    {
      *v7++ = *((_OWORD *)a2 + 1);
      a2 = (uint64_t *)*a2;
    }
    *((_QWORD *)v6 + 1) = v7;
  }
  return result;
}

void sub_241A008BC(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *std::vector<boost::uuids::uuid>::__vallocate[abi:ne180100](_QWORD *a1, unint64_t a2)
{
  char *result;
  uint64_t v4;

  if (a2 >> 60)
    std::vector<CLMicroLocationProto::ConfidenceReason>::__throw_length_error[abi:ne180100]();
  result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<boost::uuids::uuid>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[16 * v4];
  return result;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<boost::uuids::uuid>>(uint64_t a1, unint64_t a2)
{
  if (a2 >> 60)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(16 * a2);
}

char *std::vector<boost::uuids::uuid>::__assign_with_size[abi:ne180100]<boost::uuids::uuid*,boost::uuids::uuid*>(char *result, char *__src, uint64_t a3, unint64_t a4)
{
  _QWORD *v7;
  uint64_t v8;
  char *v9;
  uint64_t v10;
  unint64_t v11;
  void **v12;
  char *v13;
  _BYTE *v14;
  unint64_t v15;
  char *v16;
  size_t v17;
  void *v18;
  char *v19;

  v7 = result;
  v8 = *((_QWORD *)result + 2);
  v9 = *(char **)result;
  if (a4 > (v8 - *(_QWORD *)result) >> 4)
  {
    if (v9)
    {
      *((_QWORD *)result + 1) = v9;
      operator delete(v9);
      v8 = 0;
      *v7 = 0;
      v7[1] = 0;
      v7[2] = 0;
    }
    if (a4 >> 60)
      std::vector<CLMicroLocationProto::ConfidenceReason>::__throw_length_error[abi:ne180100]();
    v10 = v8 >> 3;
    if (v8 >> 3 <= a4)
      v10 = a4;
    if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF0)
      v11 = 0xFFFFFFFFFFFFFFFLL;
    else
      v11 = v10;
    result = std::vector<boost::uuids::uuid>::__vallocate[abi:ne180100](v7, v11);
    v13 = (char *)v7[1];
    v12 = (void **)(v7 + 1);
    v9 = v13;
LABEL_16:
    v17 = a3 - (_QWORD)__src;
    if (v17)
    {
      v18 = v9;
      v19 = __src;
      goto LABEL_18;
    }
    goto LABEL_19;
  }
  v12 = (void **)(result + 8);
  v14 = (_BYTE *)*((_QWORD *)result + 1);
  v15 = (v14 - v9) >> 4;
  if (v15 >= a4)
    goto LABEL_16;
  v16 = &__src[16 * v15];
  if (v14 != v9)
  {
    result = (char *)memmove(*(void **)result, __src, v14 - v9);
    v9 = (char *)*v12;
  }
  v17 = a3 - (_QWORD)v16;
  if (v17)
  {
    v18 = v9;
    v19 = v16;
LABEL_18:
    result = (char *)memmove(v18, v19, v17);
  }
LABEL_19:
  *v12 = &v9[v17];
  return result;
}

uint64_t *std::__optional_storage_base<CLMicroLocationUtils::ProbabilityMatrix,false>::__assign_from[abi:ne180100]<std::__optional_copy_assign_base<CLMicroLocationUtils::ProbabilityMatrix,false> const&>(uint64_t *this, unsigned __int8 *a2)
{
  uint64_t *v2;

  v2 = this;
  if (*((unsigned __int8 *)this + 24) == a2[24])
  {
    if (*((_BYTE *)this + 24))
      return CLMicroLocationUtils::ProbabilityMatrix::operator=(this, (uint64_t)a2);
  }
  else if (*((_BYTE *)this + 24))
  {
    this = (uint64_t *)*this;
    *v2 = 0;
    if (this)
      this = (uint64_t *)MEMORY[0x2426A04BC](this, 0x1000C8000313F17);
    *((_BYTE *)v2 + 24) = 0;
  }
  else
  {
    this = (uint64_t *)CLMicroLocationUtils::ProbabilityMatrix::ProbabilityMatrix((CLMicroLocationUtils::ProbabilityMatrix *)this, (const CLMicroLocationUtils::ProbabilityMatrix *)a2);
    *((_BYTE *)v2 + 24) = 1;
  }
  return this;
}

char *std::vector<CLMicroLocationProto::ConfidenceLevel>::__assign_with_size[abi:ne180100]<CLMicroLocationProto::ConfidenceLevel*,CLMicroLocationProto::ConfidenceLevel*>(char *result, char *__src, uint64_t a3, unint64_t a4)
{
  _QWORD *v7;
  uint64_t v8;
  char *v9;
  uint64_t v10;
  unint64_t v11;
  void **v12;
  char *v13;
  _BYTE *v14;
  unint64_t v15;
  char *v16;
  size_t v17;
  void *v18;
  char *v19;

  v7 = result;
  v8 = *((_QWORD *)result + 2);
  v9 = *(char **)result;
  if (a4 > (v8 - *(_QWORD *)result) >> 2)
  {
    if (v9)
    {
      *((_QWORD *)result + 1) = v9;
      operator delete(v9);
      v8 = 0;
      *v7 = 0;
      v7[1] = 0;
      v7[2] = 0;
    }
    if (a4 >> 62)
      std::vector<CLMicroLocationProto::ConfidenceReason>::__throw_length_error[abi:ne180100]();
    v10 = v8 >> 1;
    if (v8 >> 1 <= a4)
      v10 = a4;
    if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFFCLL)
      v11 = 0x3FFFFFFFFFFFFFFFLL;
    else
      v11 = v10;
    result = std::vector<CLMicroLocationProto::ConfidenceLevel>::__vallocate[abi:ne180100](v7, v11);
    v13 = (char *)v7[1];
    v12 = (void **)(v7 + 1);
    v9 = v13;
LABEL_16:
    v17 = a3 - (_QWORD)__src;
    if (v17)
    {
      v18 = v9;
      v19 = __src;
      goto LABEL_18;
    }
    goto LABEL_19;
  }
  v12 = (void **)(result + 8);
  v14 = (_BYTE *)*((_QWORD *)result + 1);
  v15 = (v14 - v9) >> 2;
  if (v15 >= a4)
    goto LABEL_16;
  v16 = &__src[4 * v15];
  if (v14 != v9)
  {
    result = (char *)memmove(*(void **)result, __src, v14 - v9);
    v9 = (char *)*v12;
  }
  v17 = a3 - (_QWORD)v16;
  if (v17)
  {
    v18 = v9;
    v19 = v16;
LABEL_18:
    result = (char *)memmove(v18, v19, v17);
  }
LABEL_19:
  *v12 = &v9[v17];
  return result;
}

char *std::vector<CLMicroLocationProto::ConfidenceLevel>::__vallocate[abi:ne180100](_QWORD *a1, unint64_t a2)
{
  char *result;
  uint64_t v4;

  if (a2 >> 62)
    std::vector<CLMicroLocationProto::ConfidenceReason>::__throw_length_error[abi:ne180100]();
  result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<CLMicroLocationProto::ConfidenceReason>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[4 * v4];
  return result;
}

CLMicroLocationModel::SimilarityListData *CLMicroLocationModel::SimilarityListData::SimilarityListData(CLMicroLocationModel::SimilarityListData *this, const CLMicroLocationModel::SimilarityListData *a2)
{
  *(_QWORD *)this = 0;
  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 2) = 0;
  std::vector<boost::uuids::uuid>::__init_with_size[abi:ne180100]<boost::uuids::uuid*,boost::uuids::uuid*>(this, *(const void **)a2, *((_QWORD *)a2 + 1), (uint64_t)(*((_QWORD *)a2 + 1) - *(_QWORD *)a2) >> 4);
  *((_QWORD *)this + 3) = 0;
  *((_QWORD *)this + 4) = 0;
  *((_QWORD *)this + 5) = 0;
  std::vector<boost::uuids::uuid>::__init_with_size[abi:ne180100]<boost::uuids::uuid*,boost::uuids::uuid*>((_QWORD *)this + 3, *((const void **)a2 + 3), *((_QWORD *)a2 + 4), (uint64_t)(*((_QWORD *)a2 + 4) - *((_QWORD *)a2 + 3)) >> 4);
  std::__optional_copy_base<CLMicroLocationUtils::ProbabilityMatrix,false>::__optional_copy_base[abi:ne180100]((CLMicroLocationModel::SimilarityListData *)((char *)this + 48), (const CLMicroLocationModel::SimilarityListData *)((char *)a2 + 48));
  *((_QWORD *)this + 10) = 0;
  *((_QWORD *)this + 11) = 0;
  *((_QWORD *)this + 12) = 0;
  std::vector<CLMicroLocationProto::ConfidenceLevel>::__init_with_size[abi:ne180100]<CLMicroLocationProto::ConfidenceLevel*,CLMicroLocationProto::ConfidenceLevel*>((_QWORD *)this + 10, *((const void **)a2 + 10), *((_QWORD *)a2 + 11), (uint64_t)(*((_QWORD *)a2 + 11) - *((_QWORD *)a2 + 10)) >> 2);
  *(_OWORD *)((char *)this + 104) = *(_OWORD *)((char *)a2 + 104);
  return this;
}

void sub_241A00CB4(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void **v2;
  uint64_t *v3;
  uint64_t v5;
  void *v6;
  void *v7;

  if (*(_BYTE *)(v1 + 72))
  {
    v5 = *v3;
    *v3 = 0;
    if (v5)
      MEMORY[0x2426A04BC](v5, 0x1000C8000313F17);
  }
  v6 = *v2;
  if (*v2)
  {
    *(_QWORD *)(v1 + 32) = v6;
    operator delete(v6);
  }
  v7 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v7;
    operator delete(v7);
  }
  _Unwind_Resume(exception_object);
}

CLMicroLocationUtils::ProbabilityMatrix *std::__optional_copy_base<CLMicroLocationUtils::ProbabilityMatrix,false>::__optional_copy_base[abi:ne180100](CLMicroLocationUtils::ProbabilityMatrix *this, const CLMicroLocationUtils::ProbabilityMatrix *a2)
{
  *(_BYTE *)this = 0;
  *((_BYTE *)this + 24) = 0;
  if (*((_BYTE *)a2 + 24))
  {
    CLMicroLocationUtils::ProbabilityMatrix::ProbabilityMatrix(this, a2);
    *((_BYTE *)this + 24) = 1;
  }
  return this;
}

void sub_241A00D58(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (*(_BYTE *)(v1 + 24))
    std::__optional_move_base<CLMicroLocationUtils::ProbabilityMatrix,false>::__optional_move_base[abi:ne180100]((uint64_t *)v1);
  _Unwind_Resume(exception_object);
}

_QWORD *std::vector<CLMicroLocationProto::ConfidenceLevel>::__init_with_size[abi:ne180100]<CLMicroLocationProto::ConfidenceLevel*,CLMicroLocationProto::ConfidenceLevel*>(_QWORD *result, const void *a2, uint64_t a3, unint64_t a4)
{
  _QWORD *v6;
  uint64_t v7;
  size_t v8;

  if (a4)
  {
    v6 = result;
    result = std::vector<CLMicroLocationProto::ConfidenceLevel>::__vallocate[abi:ne180100](result, a4);
    v7 = v6[1];
    v8 = a3 - (_QWORD)a2;
    if (v8)
      result = memmove((void *)v6[1], a2, v8);
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_241A00DD0(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

_QWORD *std::__hash_table<boost::uuids::uuid,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,std::allocator<boost::uuids::uuid>>::__emplace_unique_key_args<boost::uuids::uuid,boost::uuids::uuid const&>(uint64_t a1, _QWORD *a2, _OWORD *a3)
{
  unint64_t v3;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  uint8x8_t v9;
  _QWORD **v10;
  _QWORD *i;
  unint64_t v12;
  float v14;
  float v15;
  _BOOL8 v16;
  unint64_t v17;
  unint64_t v18;
  size_t v19;
  uint64_t v20;
  _QWORD *v21;
  unint64_t v22;

  v6 = 0;
  v7 = 0;
  do
    v7 ^= (v7 << 6) + (v7 >> 2) + 2654435769u + *((unsigned __int8 *)a2 + v6++);
  while (v6 != 16);
  v8 = *(_QWORD *)(a1 + 8);
  if (v8)
  {
    v9 = (uint8x8_t)vcnt_s8((int8x8_t)v8);
    v9.i16[0] = vaddlv_u8(v9);
    if (v9.u32[0] > 1uLL)
    {
      v3 = v7;
      if (v7 >= v8)
        v3 = v7 % v8;
    }
    else
    {
      v3 = (v8 - 1) & v7;
    }
    v10 = *(_QWORD ***)(*(_QWORD *)a1 + 8 * v3);
    if (v10)
    {
      for (i = *v10; i; i = (_QWORD *)*i)
      {
        v12 = i[1];
        if (v12 == v7)
        {
          if (i[2] == *a2 && i[3] == a2[1])
            return i;
        }
        else
        {
          if (v9.u32[0] > 1uLL)
          {
            if (v12 >= v8)
              v12 %= v8;
          }
          else
          {
            v12 &= v8 - 1;
          }
          if (v12 != v3)
            break;
        }
      }
    }
  }
  i = operator new(0x20uLL);
  *i = 0;
  i[1] = v7;
  *((_OWORD *)i + 1) = *a3;
  v14 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v15 = *(float *)(a1 + 32);
  if (!v8 || (float)(v15 * (float)v8) < v14)
  {
    v16 = 1;
    if (v8 >= 3)
      v16 = (v8 & (v8 - 1)) != 0;
    v17 = v16 | (2 * v8);
    v18 = vcvtps_u32_f32(v14 / v15);
    if (v17 <= v18)
      v19 = v18;
    else
      v19 = v17;
    std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>>>::__rehash<true>(a1, v19);
    v8 = *(_QWORD *)(a1 + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v7 >= v8)
        v3 = v7 % v8;
      else
        v3 = v7;
    }
    else
    {
      v3 = (v8 - 1) & v7;
    }
  }
  v20 = *(_QWORD *)a1;
  v21 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v3);
  if (v21)
  {
    *i = *v21;
LABEL_44:
    *v21 = i;
    goto LABEL_45;
  }
  *i = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = i;
  *(_QWORD *)(v20 + 8 * v3) = a1 + 16;
  if (*i)
  {
    v22 = *(_QWORD *)(*i + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v22 >= v8)
        v22 %= v8;
    }
    else
    {
      v22 &= v8 - 1;
    }
    v21 = (_QWORD *)(*(_QWORD *)a1 + 8 * v22);
    goto LABEL_44;
  }
LABEL_45:
  ++*(_QWORD *)(a1 + 24);
  return i;
}

void sub_241A01028(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

void ***std::back_insert_iterator<std::vector<boost::uuids::uuid>>::operator=[abi:ne180100](void ***a1, _OWORD *a2)
{
  void **v4;
  _OWORD *v5;
  void **v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  _OWORD *v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  unint64_t v14;
  char *v15;
  char *v16;
  char *v17;
  char *v18;
  char *v19;

  v4 = *a1;
  v5 = (*a1)[1];
  v6 = *a1;
  v9 = (unint64_t)v6[2];
  v7 = (uint64_t)(v6 + 2);
  v8 = v9;
  if ((unint64_t)v5 >= v9)
  {
    v11 = ((char *)v5 - (_BYTE *)*v4) >> 4;
    v12 = v11 + 1;
    if ((unint64_t)(v11 + 1) >> 60)
      std::vector<CLMicroLocationProto::ConfidenceReason>::__throw_length_error[abi:ne180100]();
    v13 = v8 - (_QWORD)*v4;
    if (v13 >> 3 > v12)
      v12 = v13 >> 3;
    if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF0)
      v14 = 0xFFFFFFFFFFFFFFFLL;
    else
      v14 = v12;
    if (v14)
      v15 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<boost::uuids::uuid>>(v7, v14);
    else
      v15 = 0;
    v16 = &v15[16 * v11];
    v17 = &v15[16 * v14];
    *(_OWORD *)v16 = *a2;
    v10 = v16 + 16;
    v19 = (char *)*v4;
    v18 = (char *)v4[1];
    if (v18 != *v4)
    {
      do
      {
        *((_OWORD *)v16 - 1) = *((_OWORD *)v18 - 1);
        v16 -= 16;
        v18 -= 16;
      }
      while (v18 != v19);
      v18 = (char *)*v4;
    }
    *v4 = v16;
    v4[1] = v10;
    v4[2] = v17;
    if (v18)
      operator delete(v18);
  }
  else
  {
    *v5 = *a2;
    v10 = v5 + 1;
  }
  v4[1] = v10;
  return a1;
}

_QWORD *std::vector<boost::uuids::uuid>::__init_with_size[abi:ne180100]<boost::uuids::uuid*,boost::uuids::uuid*>(_QWORD *result, const void *a2, uint64_t a3, unint64_t a4)
{
  _QWORD *v6;
  uint64_t v7;
  size_t v8;

  if (a4)
  {
    v6 = result;
    result = std::vector<boost::uuids::uuid>::__vallocate[abi:ne180100](result, a4);
    v7 = v6[1];
    v8 = a3 - (_QWORD)a2;
    if (v8)
      result = memmove((void *)v6[1], a2, v8);
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_241A01190(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

_QWORD *std::__hash_table<std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>>>::find<boost::uuids::uuid>(_QWORD *a1, _QWORD *a2)
{
  uint64_t v2;
  unint64_t v3;
  int8x8_t v4;
  uint8x8_t v5;
  unint64_t v6;
  _QWORD *v7;
  _QWORD *result;
  unint64_t v9;

  v2 = 0;
  v3 = 0;
  do
    v3 ^= (v3 << 6) + (v3 >> 2) + 2654435769u + *((unsigned __int8 *)a2 + v2++);
  while (v2 != 16);
  v4 = (int8x8_t)a1[1];
  if (!*(_QWORD *)&v4)
    return 0;
  v5 = (uint8x8_t)vcnt_s8(v4);
  v5.i16[0] = vaddlv_u8(v5);
  if (v5.u32[0] > 1uLL)
  {
    v6 = v3;
    if (v3 >= *(_QWORD *)&v4)
      v6 = v3 % *(_QWORD *)&v4;
  }
  else
  {
    v6 = (*(_QWORD *)&v4 - 1) & v3;
  }
  v7 = *(_QWORD **)(*a1 + 8 * v6);
  if (!v7)
    return 0;
  result = (_QWORD *)*v7;
  if (*v7)
  {
    do
    {
      v9 = result[1];
      if (v3 == v9)
      {
        if (result[2] == *a2 && result[3] == a2[1])
          return result;
      }
      else
      {
        if (v5.u32[0] > 1uLL)
        {
          if (v9 >= *(_QWORD *)&v4)
            v9 %= *(_QWORD *)&v4;
        }
        else
        {
          v9 &= *(_QWORD *)&v4 - 1;
        }
        if (v9 != v6)
          return 0;
      }
      result = (_QWORD *)*result;
    }
    while (result);
  }
  return result;
}

{
  uint64_t v2;
  unint64_t v3;
  int8x8_t v4;
  uint8x8_t v5;
  unint64_t v6;
  _QWORD *v7;
  _QWORD *result;
  unint64_t v9;

  v2 = 0;
  v3 = 0;
  do
    v3 ^= (v3 << 6) + (v3 >> 2) + 2654435769u + *((unsigned __int8 *)a2 + v2++);
  while (v2 != 16);
  v4 = (int8x8_t)a1[1];
  if (!*(_QWORD *)&v4)
    return 0;
  v5 = (uint8x8_t)vcnt_s8(v4);
  v5.i16[0] = vaddlv_u8(v5);
  if (v5.u32[0] > 1uLL)
  {
    v6 = v3;
    if (v3 >= *(_QWORD *)&v4)
      v6 = v3 % *(_QWORD *)&v4;
  }
  else
  {
    v6 = (*(_QWORD *)&v4 - 1) & v3;
  }
  v7 = *(_QWORD **)(*a1 + 8 * v6);
  if (!v7)
    return 0;
  result = (_QWORD *)*v7;
  if (*v7)
  {
    do
    {
      v9 = result[1];
      if (v9 == v3)
      {
        if (result[2] == *a2 && result[3] == a2[1])
          return result;
      }
      else
      {
        if (v5.u32[0] > 1uLL)
        {
          if (v9 >= *(_QWORD *)&v4)
            v9 %= *(_QWORD *)&v4;
        }
        else
        {
          v9 &= *(_QWORD *)&v4 - 1;
        }
        if (v9 != v6)
          return 0;
      }
      result = (_QWORD *)*result;
    }
    while (result);
  }
  return result;
}

_QWORD *std::__hash_table<std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>>>::__emplace_unique_key_args<boost::uuids::uuid,boost::uuids::uuid const&,std::vector<boost::uuids::uuid>>(uint64_t a1, _QWORD *a2, _OWORD *a3, __int128 *a4)
{
  unint64_t v4;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  uint8x8_t v11;
  void **v12;
  _QWORD *v13;
  unint64_t v14;
  _QWORD *v16;
  __int128 v17;
  float v18;
  float v19;
  _BOOL8 v20;
  unint64_t v21;
  unint64_t v22;
  size_t v23;
  uint64_t v24;
  _QWORD *v25;
  unint64_t v26;

  v8 = 0;
  v9 = 0;
  do
    v9 ^= (v9 << 6) + (v9 >> 2) + 2654435769u + *((unsigned __int8 *)a2 + v8++);
  while (v8 != 16);
  v10 = *(_QWORD *)(a1 + 8);
  if (v10)
  {
    v11 = (uint8x8_t)vcnt_s8((int8x8_t)v10);
    v11.i16[0] = vaddlv_u8(v11);
    if (v11.u32[0] > 1uLL)
    {
      v4 = v9;
      if (v9 >= v10)
        v4 = v9 % v10;
    }
    else
    {
      v4 = (v10 - 1) & v9;
    }
    v12 = *(void ***)(*(_QWORD *)a1 + 8 * v4);
    if (v12)
    {
      v13 = *v12;
      if (*v12)
      {
        do
        {
          v14 = v13[1];
          if (v14 == v9)
          {
            if (v13[2] == *a2 && v13[3] == a2[1])
              return v13;
          }
          else
          {
            if (v11.u32[0] > 1uLL)
            {
              if (v14 >= v10)
                v14 %= v10;
            }
            else
            {
              v14 &= v10 - 1;
            }
            if (v14 != v4)
              break;
          }
          v13 = (_QWORD *)*v13;
        }
        while (v13);
      }
    }
  }
  v16 = (_QWORD *)(a1 + 16);
  v13 = operator new(0x38uLL);
  *v13 = 0;
  v13[1] = v9;
  v17 = *a4;
  *((_OWORD *)v13 + 1) = *a3;
  *((_OWORD *)v13 + 2) = v17;
  v13[6] = *((_QWORD *)a4 + 2);
  *(_QWORD *)a4 = 0;
  *((_QWORD *)a4 + 1) = 0;
  *((_QWORD *)a4 + 2) = 0;
  v18 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v19 = *(float *)(a1 + 32);
  if (!v10 || (float)(v19 * (float)v10) < v18)
  {
    v20 = 1;
    if (v10 >= 3)
      v20 = (v10 & (v10 - 1)) != 0;
    v21 = v20 | (2 * v10);
    v22 = vcvtps_u32_f32(v18 / v19);
    if (v21 <= v22)
      v23 = v22;
    else
      v23 = v21;
    std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>>>::__rehash<true>(a1, v23);
    v10 = *(_QWORD *)(a1 + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v9 >= v10)
        v4 = v9 % v10;
      else
        v4 = v9;
    }
    else
    {
      v4 = (v10 - 1) & v9;
    }
  }
  v24 = *(_QWORD *)a1;
  v25 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v4);
  if (v25)
  {
    *v13 = *v25;
LABEL_44:
    *v25 = v13;
    goto LABEL_45;
  }
  *v13 = *v16;
  *v16 = v13;
  *(_QWORD *)(v24 + 8 * v4) = v16;
  if (*v13)
  {
    v26 = *(_QWORD *)(*v13 + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v26 >= v10)
        v26 %= v10;
    }
    else
    {
      v26 &= v10 - 1;
    }
    v25 = (_QWORD *)(*(_QWORD *)a1 + 8 * v26);
    goto LABEL_44;
  }
LABEL_45:
  ++*(_QWORD *)(a1 + 24);
  return v13;
}

void sub_241A015FC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  _QWORD *v10;
  uint64_t v11;

  std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,void *>>>::operator()[abi:ne180100](v11, v10);
  _Unwind_Resume(a1);
}

void std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,void *>>>::operator()[abi:ne180100](uint64_t a1, _QWORD *__p)
{
  void *v3;

  if (*(_BYTE *)(a1 + 8))
  {
    v3 = (void *)__p[4];
    if (v3)
    {
      __p[5] = v3;
      operator delete(v3);
    }
  }
  else if (!__p)
  {
    return;
  }
  operator delete(__p);
}

uint64_t *std::__hash_table<std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>>>::__erase_unique<boost::uuids::uuid>(_QWORD *a1, _QWORD *a2)
{
  uint64_t *result;

  result = std::__hash_table<std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>>>::find<boost::uuids::uuid>(a1, a2);
  if (result)
  {
    std::__hash_table<std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>>>::erase(a1, result);
    return (uint64_t *)1;
  }
  return result;
}

uint64_t std::__hash_table<std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>>>::erase(_QWORD *a1, uint64_t *a2)
{
  uint64_t v2;
  _QWORD *v3;
  void *__p;
  uint64_t v6;

  v2 = *a2;
  std::__hash_table<std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>>>::remove(a1, a2, (uint64_t)&__p);
  v3 = __p;
  __p = 0;
  if (v3)
    std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,void *>>>::operator()[abi:ne180100]((uint64_t)&v6, v3);
  return v2;
}

_QWORD *std::__hash_table<std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>>>::remove@<X0>(_QWORD *result@<X0>, _QWORD *a2@<X1>, uint64_t a3@<X8>)
{
  int8x8_t v3;
  unint64_t v4;
  uint8x8_t v5;
  _QWORD *v6;
  _QWORD *v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;

  v3 = (int8x8_t)result[1];
  v4 = a2[1];
  v5 = (uint8x8_t)vcnt_s8(v3);
  v5.i16[0] = vaddlv_u8(v5);
  if (v5.u32[0] > 1uLL)
  {
    if (v4 >= *(_QWORD *)&v3)
      v4 %= *(_QWORD *)&v3;
  }
  else
  {
    v4 &= *(_QWORD *)&v3 - 1;
  }
  v6 = *(_QWORD **)(*result + 8 * v4);
  do
  {
    v7 = v6;
    v6 = (_QWORD *)*v6;
  }
  while (v6 != a2);
  if (v7 == result + 2)
    goto LABEL_18;
  v8 = v7[1];
  if (v5.u32[0] > 1uLL)
  {
    if (v8 >= *(_QWORD *)&v3)
      v8 %= *(_QWORD *)&v3;
  }
  else
  {
    v8 &= *(_QWORD *)&v3 - 1;
  }
  if (v8 != v4)
  {
LABEL_18:
    if (!*a2)
      goto LABEL_19;
    v9 = *(_QWORD *)(*a2 + 8);
    if (v5.u32[0] > 1uLL)
    {
      if (v9 >= *(_QWORD *)&v3)
        v9 %= *(_QWORD *)&v3;
    }
    else
    {
      v9 &= *(_QWORD *)&v3 - 1;
    }
    if (v9 != v4)
LABEL_19:
      *(_QWORD *)(*result + 8 * v4) = 0;
  }
  v10 = *a2;
  if (*a2)
  {
    v11 = *(_QWORD *)(v10 + 8);
    if (v5.u32[0] > 1uLL)
    {
      if (v11 >= *(_QWORD *)&v3)
        v11 %= *(_QWORD *)&v3;
    }
    else
    {
      v11 &= *(_QWORD *)&v3 - 1;
    }
    if (v11 != v4)
    {
      *(_QWORD *)(*result + 8 * v11) = v7;
      v10 = *a2;
    }
  }
  *v7 = v10;
  *a2 = 0;
  --result[3];
  *(_QWORD *)a3 = a2;
  *(_QWORD *)(a3 + 8) = result + 2;
  *(_BYTE *)(a3 + 16) = 1;
  return result;
}

_QWORD *std::__hash_table<std::__hash_value_type<boost::uuids::uuid,boost::uuids::uuid>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,boost::uuids::uuid>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,boost::uuids::uuid>>>::__emplace_unique_key_args<boost::uuids::uuid,std::pair<boost::uuids::uuid const,boost::uuids::uuid>>(uint64_t a1, _QWORD *a2, _OWORD *a3)
{
  unint64_t v3;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  uint8x8_t v9;
  void **v10;
  _QWORD *v11;
  unint64_t v12;
  __int128 v14;
  float v15;
  float v16;
  _BOOL8 v17;
  unint64_t v18;
  unint64_t v19;
  size_t v20;
  uint64_t v21;
  _QWORD *v22;
  unint64_t v23;

  v6 = 0;
  v7 = 0;
  do
    v7 ^= (v7 << 6) + (v7 >> 2) + 2654435769u + *((unsigned __int8 *)a2 + v6++);
  while (v6 != 16);
  v8 = *(_QWORD *)(a1 + 8);
  if (v8)
  {
    v9 = (uint8x8_t)vcnt_s8((int8x8_t)v8);
    v9.i16[0] = vaddlv_u8(v9);
    if (v9.u32[0] > 1uLL)
    {
      v3 = v7;
      if (v7 >= v8)
        v3 = v7 % v8;
    }
    else
    {
      v3 = (v8 - 1) & v7;
    }
    v10 = *(void ***)(*(_QWORD *)a1 + 8 * v3);
    if (v10)
    {
      v11 = *v10;
      if (*v10)
      {
        do
        {
          v12 = v11[1];
          if (v12 == v7)
          {
            if (v11[2] == *a2 && v11[3] == a2[1])
              return v11;
          }
          else
          {
            if (v9.u32[0] > 1uLL)
            {
              if (v12 >= v8)
                v12 %= v8;
            }
            else
            {
              v12 &= v8 - 1;
            }
            if (v12 != v3)
              break;
          }
          v11 = (_QWORD *)*v11;
        }
        while (v11);
      }
    }
  }
  v11 = operator new(0x30uLL);
  *v11 = 0;
  v11[1] = v7;
  v14 = a3[1];
  *((_OWORD *)v11 + 1) = *a3;
  *((_OWORD *)v11 + 2) = v14;
  v15 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v16 = *(float *)(a1 + 32);
  if (!v8 || (float)(v16 * (float)v8) < v15)
  {
    v17 = 1;
    if (v8 >= 3)
      v17 = (v8 & (v8 - 1)) != 0;
    v18 = v17 | (2 * v8);
    v19 = vcvtps_u32_f32(v15 / v16);
    if (v18 <= v19)
      v20 = v19;
    else
      v20 = v18;
    std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>>>::__rehash<true>(a1, v20);
    v8 = *(_QWORD *)(a1 + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v7 >= v8)
        v3 = v7 % v8;
      else
        v3 = v7;
    }
    else
    {
      v3 = (v8 - 1) & v7;
    }
  }
  v21 = *(_QWORD *)a1;
  v22 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v3);
  if (v22)
  {
    *v11 = *v22;
LABEL_44:
    *v22 = v11;
    goto LABEL_45;
  }
  *v11 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = v11;
  *(_QWORD *)(v21 + 8 * v3) = a1 + 16;
  if (*v11)
  {
    v23 = *(_QWORD *)(*v11 + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v23 >= v8)
        v23 %= v8;
    }
    else
    {
      v23 &= v8 - 1;
    }
    v22 = (_QWORD *)(*(_QWORD *)a1 + 8 * v23);
    goto LABEL_44;
  }
LABEL_45:
  ++*(_QWORD *)(a1 + 24);
  return v11;
}

void sub_241A01A50(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

_QWORD *std::__hash_table<boost::uuids::uuid,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,std::allocator<boost::uuids::uuid>>::clear(_QWORD *result)
{
  _QWORD *v1;
  _QWORD *v2;
  uint64_t v3;
  uint64_t i;

  if (result[3])
  {
    v1 = result;
    result = (_QWORD *)result[2];
    if (result)
    {
      do
      {
        v2 = (_QWORD *)*result;
        operator delete(result);
        result = v2;
      }
      while (v2);
    }
    v1[2] = 0;
    v3 = v1[1];
    if (v3)
    {
      for (i = 0; i != v3; ++i)
        *(_QWORD *)(*v1 + 8 * i) = 0;
    }
    v1[3] = 0;
  }
  return result;
}

void std::__throw_bad_function_call[abi:ne180100]()
{
  _QWORD *exception;

  exception = __cxa_allocate_exception(8uLL);
}

void std::bad_function_call::~bad_function_call(std::bad_function_call *this)
{
  std::exception::~exception(this);
  JUMPOUT(0x2426A04D4);
}

char *std::__tree<std::__value_type<double,std::pair<boost::uuids::uuid const,boost::uuids::uuid>>,std::__map_value_compare<double,std::__value_type<double,std::pair<boost::uuids::uuid const,boost::uuids::uuid>>,std::less<double>,true>,std::allocator<std::__value_type<double,std::pair<boost::uuids::uuid const,boost::uuids::uuid>>>>::__emplace_multi<double &,std::pair<boost::uuids::uuid const,boost::uuids::uuid>>(uint64_t **a1, double *a2, _OWORD *a3)
{
  char *v6;
  double v7;
  __int128 v8;
  uint64_t **v9;
  uint64_t *v10;
  uint64_t **v11;

  v6 = (char *)operator new(0x48uLL);
  v7 = *a2;
  *((double *)v6 + 4) = *a2;
  v8 = a3[1];
  *(_OWORD *)(v6 + 40) = *a3;
  *(_OWORD *)(v6 + 56) = v8;
  v9 = a1 + 1;
  v10 = a1[1];
  if (v10)
  {
    do
    {
      while (1)
      {
        v9 = (uint64_t **)v10;
        if (v7 >= *((double *)v10 + 4))
          break;
        v10 = (uint64_t *)*v10;
        v11 = v9;
        if (!*v9)
          goto LABEL_8;
      }
      v10 = (uint64_t *)v10[1];
    }
    while (v10);
    v11 = v9 + 1;
  }
  else
  {
    v11 = a1 + 1;
  }
LABEL_8:
  std::__tree<CLMicroLocationRecordingCompletionMetaInformation::RecordingError>::__insert_node_at(a1, (uint64_t)v9, v11, (uint64_t *)v6);
  return v6;
}

_QWORD *std::__hash_table<std::__hash_value_type<boost::uuids::uuid,boost::uuids::uuid>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,boost::uuids::uuid>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,boost::uuids::uuid>>>::__emplace_unique_key_args<boost::uuids::uuid,std::pair<boost::uuids::uuid const,boost::uuids::uuid> const&>(uint64_t a1, _QWORD *a2, _OWORD *a3)
{
  unint64_t v3;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  uint8x8_t v9;
  void **v10;
  _QWORD *v11;
  unint64_t v12;
  __int128 v14;
  float v15;
  float v16;
  _BOOL8 v17;
  unint64_t v18;
  unint64_t v19;
  size_t v20;
  uint64_t v21;
  _QWORD *v22;
  unint64_t v23;

  v6 = 0;
  v7 = 0;
  do
    v7 ^= (v7 << 6) + (v7 >> 2) + 2654435769u + *((unsigned __int8 *)a2 + v6++);
  while (v6 != 16);
  v8 = *(_QWORD *)(a1 + 8);
  if (v8)
  {
    v9 = (uint8x8_t)vcnt_s8((int8x8_t)v8);
    v9.i16[0] = vaddlv_u8(v9);
    if (v9.u32[0] > 1uLL)
    {
      v3 = v7;
      if (v7 >= v8)
        v3 = v7 % v8;
    }
    else
    {
      v3 = (v8 - 1) & v7;
    }
    v10 = *(void ***)(*(_QWORD *)a1 + 8 * v3);
    if (v10)
    {
      v11 = *v10;
      if (*v10)
      {
        do
        {
          v12 = v11[1];
          if (v12 == v7)
          {
            if (v11[2] == *a2 && v11[3] == a2[1])
              return v11;
          }
          else
          {
            if (v9.u32[0] > 1uLL)
            {
              if (v12 >= v8)
                v12 %= v8;
            }
            else
            {
              v12 &= v8 - 1;
            }
            if (v12 != v3)
              break;
          }
          v11 = (_QWORD *)*v11;
        }
        while (v11);
      }
    }
  }
  v11 = operator new(0x30uLL);
  *v11 = 0;
  v11[1] = v7;
  v14 = a3[1];
  *((_OWORD *)v11 + 1) = *a3;
  *((_OWORD *)v11 + 2) = v14;
  v15 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v16 = *(float *)(a1 + 32);
  if (!v8 || (float)(v16 * (float)v8) < v15)
  {
    v17 = 1;
    if (v8 >= 3)
      v17 = (v8 & (v8 - 1)) != 0;
    v18 = v17 | (2 * v8);
    v19 = vcvtps_u32_f32(v15 / v16);
    if (v18 <= v19)
      v20 = v19;
    else
      v20 = v18;
    std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>>>::__rehash<true>(a1, v20);
    v8 = *(_QWORD *)(a1 + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v7 >= v8)
        v3 = v7 % v8;
      else
        v3 = v7;
    }
    else
    {
      v3 = (v8 - 1) & v7;
    }
  }
  v21 = *(_QWORD *)a1;
  v22 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v3);
  if (v22)
  {
    *v11 = *v22;
LABEL_44:
    *v22 = v11;
    goto LABEL_45;
  }
  *v11 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = v11;
  *(_QWORD *)(v21 + 8 * v3) = a1 + 16;
  if (*v11)
  {
    v23 = *(_QWORD *)(*v11 + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v23 >= v8)
        v23 %= v8;
    }
    else
    {
      v23 &= v8 - 1;
    }
    v22 = (_QWORD *)(*(_QWORD *)a1 + 8 * v23);
    goto LABEL_44;
  }
LABEL_45:
  ++*(_QWORD *)(a1 + 24);
  return v11;
}

void sub_241A01DFC(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t std::insert_iterator<std::multimap<double,std::pair<boost::uuids::uuid const,boost::uuids::uuid>>>::operator=[abi:ne180100](uint64_t a1, uint64_t a2)
{
  _QWORD *v3;
  _QWORD *v4;
  _QWORD *v5;
  BOOL v6;

  v3 = std::__tree<std::__value_type<double,std::pair<boost::uuids::uuid const,boost::uuids::uuid>>,std::__map_value_compare<double,std::__value_type<double,std::pair<boost::uuids::uuid const,boost::uuids::uuid>>,std::less<double>,true>,std::allocator<std::__value_type<double,std::pair<boost::uuids::uuid const,boost::uuids::uuid>>>>::__emplace_hint_multi<std::pair<double const,std::pair<boost::uuids::uuid const,boost::uuids::uuid>> const&>(*(uint64_t ***)a1, *(double **)(a1 + 8), a2);
  *(_QWORD *)(a1 + 8) = v3;
  v4 = (_QWORD *)v3[1];
  if (v4)
  {
    do
    {
      v5 = v4;
      v4 = (_QWORD *)*v4;
    }
    while (v4);
  }
  else
  {
    do
    {
      v5 = (_QWORD *)v3[2];
      v6 = *v5 == (_QWORD)v3;
      v3 = v5;
    }
    while (!v6);
  }
  *(_QWORD *)(a1 + 8) = v5;
  return a1;
}

void *std::__tree<std::__value_type<double,std::pair<boost::uuids::uuid const,boost::uuids::uuid>>,std::__map_value_compare<double,std::__value_type<double,std::pair<boost::uuids::uuid const,boost::uuids::uuid>>,std::less<double>,true>,std::allocator<std::__value_type<double,std::pair<boost::uuids::uuid const,boost::uuids::uuid>>>>::__emplace_hint_multi<std::pair<double const,std::pair<boost::uuids::uuid const,boost::uuids::uuid>> const&>(uint64_t **a1, double *a2, uint64_t a3)
{
  void *v6;
  __int128 v7;
  double *leaf;
  double *v10;

  v6 = operator new(0x48uLL);
  v7 = *(_OWORD *)(a3 + 16);
  *((_OWORD *)v6 + 2) = *(_OWORD *)a3;
  *((_OWORD *)v6 + 3) = v7;
  *((_QWORD *)v6 + 8) = *(_QWORD *)(a3 + 32);
  leaf = std::__tree<std::__value_type<double,std::pair<boost::uuids::uuid const,boost::uuids::uuid>>,std::__map_value_compare<double,std::__value_type<double,std::pair<boost::uuids::uuid const,boost::uuids::uuid>>,std::less<double>,true>,std::allocator<std::__value_type<double,std::pair<boost::uuids::uuid const,boost::uuids::uuid>>>>::__find_leaf(a1, a2, &v10, (double *)v6 + 4);
  std::__tree<CLMicroLocationRecordingCompletionMetaInformation::RecordingError>::__insert_node_at(a1, (uint64_t)v10, (uint64_t **)leaf, (uint64_t *)v6);
  return v6;
}

void sub_241A01EF0(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

double *std::__tree<std::__value_type<double,std::pair<boost::uuids::uuid const,boost::uuids::uuid>>,std::__map_value_compare<double,std::__value_type<double,std::pair<boost::uuids::uuid const,boost::uuids::uuid>>,std::less<double>,true>,std::allocator<std::__value_type<double,std::pair<boost::uuids::uuid const,boost::uuids::uuid>>>>::__find_leaf(_QWORD *a1, double *a2, double **a3, double *a4)
{
  double *v4;
  uint64_t v5;
  double v6;
  double v7;
  double *v8;
  double *v9;
  BOOL v10;
  uint64_t v11;

  v4 = (double *)(a1 + 1);
  if (a1 + 1 != (_QWORD *)a2 && a2[4] < *a4)
  {
    while (1)
    {
      v5 = *(_QWORD *)v4;
      a2 = v4;
      if (!*(_QWORD *)v4)
        break;
      while (1)
      {
        v4 = (double *)v5;
        if (*(double *)(v5 + 32) >= *a4)
          break;
        v5 = *(_QWORD *)(v5 + 8);
        if (!v5)
          goto LABEL_19;
      }
    }
LABEL_20:
    *a3 = v4;
    return a2;
  }
  v6 = *a2;
  if ((double *)*a1 == a2)
  {
    v8 = a2;
  }
  else
  {
    if (v6 == 0.0)
    {
      v9 = a2;
      do
      {
        v8 = (double *)*((_QWORD *)v9 + 2);
        v10 = *(_QWORD *)v8 == (_QWORD)v9;
        v9 = v8;
      }
      while (v10);
    }
    else
    {
      v7 = *a2;
      do
      {
        v8 = *(double **)&v7;
        v7 = *(double *)(*(_QWORD *)&v7 + 8);
      }
      while (v7 != 0.0);
    }
    if (*a4 < v8[4])
    {
      while (1)
      {
        v11 = *(_QWORD *)v4;
        a2 = v4;
        if (!*(_QWORD *)v4)
          goto LABEL_20;
        while (1)
        {
          v4 = (double *)v11;
          if (*a4 < *(double *)(v11 + 32))
            break;
          v11 = *(_QWORD *)(v11 + 8);
          if (!v11)
          {
LABEL_19:
            a2 = v4 + 1;
            goto LABEL_20;
          }
        }
      }
    }
  }
  if (v6 == 0.0)
  {
    *a3 = a2;
  }
  else
  {
    *a3 = v8;
    return v8 + 1;
  }
  return a2;
}

uint64_t std::shared_ptr<CLMicroLocationFingerprint>::operator=[abi:ne180100](uint64_t a1, __int128 *a2)
{
  __int128 v3;
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;

  v3 = *a2;
  *(_QWORD *)a2 = 0;
  *((_QWORD *)a2 + 1) = 0;
  v4 = *(std::__shared_weak_count **)(a1 + 8);
  *(_OWORD *)a1 = v3;
  if (v4)
  {
    p_shared_owners = (unint64_t *)&v4->__shared_owners_;
    do
      v6 = __ldaxr(p_shared_owners);
    while (__stlxr(v6 - 1, p_shared_owners));
    if (!v6)
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
  return a1;
}

__int128 *std::__unwrap_and_dispatch[abi:ne180100]<std::__overload<std::__move_loop<std::_ClassicAlgPolicy>,std::__move_trivial>,std::pair<std::shared_ptr<CLMicroLocationFingerprint>,boost::uuids::uuid> *,std::pair<std::shared_ptr<CLMicroLocationFingerprint>,boost::uuids::uuid> *,std::pair<std::shared_ptr<CLMicroLocationFingerprint>,boost::uuids::uuid> *,0>(__int128 *a1, __int128 *a2, uint64_t a3)
{
  __int128 *v4;
  __int128 *v5;

  v4 = a1;
  if (a1 == a2)
    return a1;
  v5 = a2;
  do
  {
    std::shared_ptr<CLMicroLocationFingerprint>::operator=[abi:ne180100](a3, v4);
    *(_OWORD *)(a3 + 16) = v4[1];
    a3 += 32;
    v4 += 2;
  }
  while (v4 != v5);
  return v5;
}

uint64_t std::__hash_table<boost::uuids::uuid,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,std::allocator<boost::uuids::uuid>>::erase(_QWORD *a1, uint64_t *a2)
{
  uint64_t v2;
  void *v3;
  void *__p;

  v2 = *a2;
  std::__hash_table<std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>>>::remove(a1, a2, (uint64_t)&__p);
  v3 = __p;
  __p = 0;
  if (v3)
    operator delete(v3);
  return v2;
}

_OWORD *std::__tree<std::__value_type<boost::uuids::uuid,unsigned long>,std::__map_value_compare<boost::uuids::uuid,std::__value_type<boost::uuids::uuid,unsigned long>,std::less<boost::uuids::uuid>,true>,std::allocator<std::__value_type<boost::uuids::uuid,unsigned long>>>::__emplace_unique_key_args<boost::uuids::uuid,boost::uuids::uuid&,unsigned long &>(uint64_t **a1, unint64_t *a2, _OWORD *a3, _QWORD *a4)
{
  void **v7;
  _OWORD *v8;
  uint64_t **v9;
  uint64_t v11;

  v7 = (void **)std::__tree<std::__value_type<boost::uuids::uuid,unsigned long>,std::__map_value_compare<boost::uuids::uuid,std::__value_type<boost::uuids::uuid,unsigned long>,std::less<boost::uuids::uuid>,true>,std::allocator<std::__value_type<boost::uuids::uuid,unsigned long>>>::__find_equal<boost::uuids::uuid>((uint64_t)a1, &v11, a2);
  v8 = *v7;
  if (!*v7)
  {
    v9 = (uint64_t **)v7;
    v8 = operator new(0x38uLL);
    v8[2] = *a3;
    *((_QWORD *)v8 + 6) = *a4;
    std::__tree<CLMicroLocationRecordingCompletionMetaInformation::RecordingError>::__insert_node_at(a1, v11, v9, (uint64_t *)v8);
  }
  return v8;
}

_QWORD *std::__tree<std::__value_type<boost::uuids::uuid,unsigned long>,std::__map_value_compare<boost::uuids::uuid,std::__value_type<boost::uuids::uuid,unsigned long>,std::less<boost::uuids::uuid>,true>,std::allocator<std::__value_type<boost::uuids::uuid,unsigned long>>>::__find_equal<boost::uuids::uuid>(uint64_t a1, _QWORD *a2, unint64_t *a3)
{
  _QWORD *result;
  _QWORD *v4;
  _QWORD *v5;
  _QWORD *v6;
  unint64_t v7;
  unint64_t v8;
  int v9;
  unint64_t v10;
  unint64_t v11;
  int v12;

  v5 = *(_QWORD **)(a1 + 8);
  result = (_QWORD *)(a1 + 8);
  v4 = v5;
  if (v5)
  {
    do
    {
      while (1)
      {
        v6 = v4;
        v7 = bswap64(*a3);
        v8 = bswap64(v6[4]);
        if (v7 == v8)
        {
          v7 = bswap64(a3[1]);
          v8 = bswap64(v6[5]);
          if (v7 == v8)
            break;
        }
        v9 = v7 < v8 ? -1 : 1;
        if ((v9 & 0x80000000) == 0)
          break;
        v4 = (_QWORD *)*v6;
        result = v6;
        if (!*v6)
          goto LABEL_20;
      }
      v10 = bswap64(v6[4]);
      v11 = bswap64(*a3);
      if (v10 == v11)
      {
        v10 = bswap64(v6[5]);
        v11 = bswap64(a3[1]);
        if (v10 == v11)
          break;
      }
      v12 = v10 < v11 ? -1 : 1;
      if ((v12 & 0x80000000) == 0)
        break;
      result = v6 + 1;
      v4 = (_QWORD *)v6[1];
    }
    while (v4);
  }
  else
  {
    v6 = result;
  }
LABEL_20:
  *a2 = v6;
  return result;
}

void std::vector<double>::resize(uint64_t a1, unint64_t a2, _QWORD *a3)
{
  unint64_t v3;

  v3 = (uint64_t)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 3;
  if (a2 <= v3)
  {
    if (a2 < v3)
      *(_QWORD *)(a1 + 8) = *(_QWORD *)a1 + 8 * a2;
  }
  else
  {
    std::vector<double>::__append((void **)a1, a2 - v3, a3);
  }
}

void std::vector<double>::__append(void **a1, unint64_t a2, _QWORD *a3)
{
  uint64_t v6;
  _BYTE *v7;
  _BYTE *v8;
  _QWORD *v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  char *v15;
  uint64_t v16;
  _QWORD *v17;
  char *v18;
  char *v19;
  uint64_t v20;
  char *v21;
  char *v22;
  char *v23;
  char *i;
  uint64_t v25;

  v8 = a1[2];
  v6 = (uint64_t)(a1 + 2);
  v7 = v8;
  v9 = *(_QWORD **)(v6 - 8);
  if (a2 <= (v8 - (_BYTE *)v9) >> 3)
  {
    if (a2)
    {
      v16 = 8 * a2;
      v17 = &v9[a2];
      do
      {
        *v9++ = *a3;
        v16 -= 8;
      }
      while (v16);
      v9 = v17;
    }
    a1[1] = v9;
  }
  else
  {
    v10 = (char *)v9 - (_BYTE *)*a1;
    v11 = a2 + (v10 >> 3);
    if (v11 >> 61)
      std::vector<CLMicroLocationProto::ConfidenceReason>::__throw_length_error[abi:ne180100]();
    v12 = v10 >> 3;
    v13 = v7 - (_BYTE *)*a1;
    if (v13 >> 2 > v11)
      v11 = v13 >> 2;
    if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8)
      v14 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v14 = v11;
    if (v14)
      v15 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<CLMicroLocationWiFiChannelHistogram>>(v6, v14);
    else
      v15 = 0;
    v18 = &v15[8 * v12];
    v19 = &v18[8 * a2];
    v20 = 8 * a2;
    v21 = v18;
    do
    {
      *(_QWORD *)v21 = *a3;
      v21 += 8;
      v20 -= 8;
    }
    while (v20);
    v22 = &v15[8 * v14];
    v23 = (char *)*a1;
    for (i = (char *)a1[1]; i != v23; i -= 8)
    {
      v25 = *((_QWORD *)i - 1);
      *((_QWORD *)v18 - 1) = v25;
      v18 -= 8;
    }
    *a1 = v18;
    a1[1] = v19;
    a1[2] = v22;
    if (v23)
      operator delete(v23);
  }
}

void std::vector<int>::resize(std::vector<int> *this, std::vector<int>::size_type __sz, std::vector<int>::const_reference __x)
{
  std::vector<int>::size_type v3;

  v3 = this->__end_ - this->__begin_;
  if (__sz <= v3)
  {
    if (__sz < v3)
      this->__end_ = &this->__begin_[__sz];
  }
  else
  {
    std::vector<int>::__append(this, __sz - v3, __x);
  }
}

void std::vector<int>::__append(std::vector<int> *this, std::vector<int>::size_type __n, std::vector<int>::const_reference __x)
{
  std::__compressed_pair<int *> *p_end_cap;
  int *v7;
  int *value;
  int *v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  char *v15;
  std::vector<int>::size_type v16;
  int *v17;
  int *v18;
  int *v19;
  std::vector<int>::size_type v20;
  int *v21;
  int *v22;
  std::vector<int>::pointer begin;
  std::vector<int>::pointer i;
  int v25;

  value = this->__end_cap_.__value_;
  p_end_cap = &this->__end_cap_;
  v7 = value;
  v9 = p_end_cap[-1].__value_;
  if (__n <= value - v9)
  {
    if (__n)
    {
      v16 = 4 * __n;
      v17 = &v9[__n];
      do
      {
        *v9++ = *__x;
        v16 -= 4;
      }
      while (v16);
      v9 = v17;
    }
    this->__end_ = v9;
  }
  else
  {
    v10 = (char *)v9 - (char *)this->__begin_;
    v11 = __n + (v10 >> 2);
    if (v11 >> 62)
      std::vector<CLMicroLocationProto::ConfidenceReason>::__throw_length_error[abi:ne180100]();
    v12 = v10 >> 2;
    v13 = (char *)v7 - (char *)this->__begin_;
    if (v13 >> 1 > v11)
      v11 = v13 >> 1;
    if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFFCLL)
      v14 = 0x3FFFFFFFFFFFFFFFLL;
    else
      v14 = v11;
    if (v14)
      v15 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<CLMicroLocationProto::ConfidenceReason>>((uint64_t)p_end_cap, v14);
    else
      v15 = 0;
    v18 = (int *)&v15[4 * v12];
    v19 = &v18[__n];
    v20 = 4 * __n;
    v21 = v18;
    do
    {
      *v21++ = *__x;
      v20 -= 4;
    }
    while (v20);
    v22 = (int *)&v15[4 * v14];
    begin = this->__begin_;
    for (i = this->__end_; i != begin; --i)
    {
      v25 = *(i - 1);
      *--v18 = v25;
    }
    this->__begin_ = v18;
    this->__end_ = v19;
    this->__end_cap_.__value_ = v22;
    if (begin)
      operator delete(begin);
  }
}

_OWORD *std::__tree<std::__value_type<boost::uuids::uuid,unsigned long>,std::__map_value_compare<boost::uuids::uuid,std::__value_type<boost::uuids::uuid,unsigned long>,std::less<boost::uuids::uuid>,true>,std::allocator<std::__value_type<boost::uuids::uuid,unsigned long>>>::__emplace_unique_key_args<boost::uuids::uuid,std::piecewise_construct_t const&,std::tuple<boost::uuids::uuid const&>,std::tuple<>>(uint64_t **a1, unint64_t *a2, uint64_t a3, _OWORD **a4)
{
  void **v6;
  _OWORD *v7;
  uint64_t **v8;
  uint64_t v10;

  v6 = (void **)std::__tree<std::__value_type<boost::uuids::uuid,unsigned long>,std::__map_value_compare<boost::uuids::uuid,std::__value_type<boost::uuids::uuid,unsigned long>,std::less<boost::uuids::uuid>,true>,std::allocator<std::__value_type<boost::uuids::uuid,unsigned long>>>::__find_equal<boost::uuids::uuid>((uint64_t)a1, &v10, a2);
  v7 = *v6;
  if (!*v6)
  {
    v8 = (uint64_t **)v6;
    v7 = operator new(0x38uLL);
    v7[2] = **a4;
    *((_QWORD *)v7 + 6) = 0;
    std::__tree<CLMicroLocationRecordingCompletionMetaInformation::RecordingError>::__insert_node_at(a1, v10, v8, (uint64_t *)v7);
  }
  return v7;
}

uint64_t *std::vector<std::pair<std::shared_ptr<CLMicroLocationFingerprint>,boost::uuids::uuid>>::__swap_out_circular_buffer(uint64_t *result, _QWORD *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  __int128 v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  v3 = *result;
  v2 = result[1];
  v4 = a2[1];
  while (v2 != v3)
  {
    v5 = *(_OWORD *)(v2 - 32);
    v2 -= 32;
    *(_OWORD *)(v4 - 32) = v5;
    v4 -= 32;
    *(_QWORD *)v2 = 0;
    *(_QWORD *)(v2 + 8) = 0;
    *(_OWORD *)(v4 + 16) = *(_OWORD *)(v2 + 16);
  }
  a2[1] = v4;
  v6 = *result;
  *result = v4;
  a2[1] = v6;
  v7 = result[1];
  result[1] = a2[2];
  a2[2] = v7;
  v8 = result[2];
  result[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t std::__split_buffer<std::pair<std::shared_ptr<CLMicroLocationFingerprint>,boost::uuids::uuid>>::~__split_buffer(uint64_t a1)
{
  uint64_t i;
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 8);
  for (i = *(_QWORD *)(a1 + 16); i != v3; i = *(_QWORD *)(a1 + 16))
  {
    *(_QWORD *)(a1 + 16) = i - 32;
    std::shared_ptr<CLMiLoService::ModelAndConf>::~shared_ptr[abi:ne180100](i - 32);
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

_QWORD *std::__hash_table<std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>>>::__emplace_unique_key_args<boost::uuids::uuid,std::piecewise_construct_t const&,std::tuple<boost::uuids::uuid const&>,std::tuple<>>(uint64_t a1, _QWORD *a2, uint64_t a3, _OWORD **a4)
{
  unint64_t v4;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint8x8_t v10;
  _QWORD **v11;
  _QWORD *i;
  unint64_t v13;
  _QWORD *v15;
  float v16;
  float v17;
  _BOOL8 v18;
  unint64_t v19;
  unint64_t v20;
  size_t v21;
  uint64_t v22;
  _QWORD *v23;
  unint64_t v24;

  v7 = 0;
  v8 = 0;
  do
    v8 ^= (v8 << 6) + (v8 >> 2) + 2654435769u + *((unsigned __int8 *)a2 + v7++);
  while (v7 != 16);
  v9 = *(_QWORD *)(a1 + 8);
  if (v9)
  {
    v10 = (uint8x8_t)vcnt_s8((int8x8_t)v9);
    v10.i16[0] = vaddlv_u8(v10);
    if (v10.u32[0] > 1uLL)
    {
      v4 = v8;
      if (v8 >= v9)
        v4 = v8 % v9;
    }
    else
    {
      v4 = (v9 - 1) & v8;
    }
    v11 = *(_QWORD ***)(*(_QWORD *)a1 + 8 * v4);
    if (v11)
    {
      for (i = *v11; i; i = (_QWORD *)*i)
      {
        v13 = i[1];
        if (v13 == v8)
        {
          if (i[2] == *a2 && i[3] == a2[1])
            return i;
        }
        else
        {
          if (v10.u32[0] > 1uLL)
          {
            if (v13 >= v9)
              v13 %= v9;
          }
          else
          {
            v13 &= v9 - 1;
          }
          if (v13 != v4)
            break;
        }
      }
    }
  }
  v15 = (_QWORD *)(a1 + 16);
  i = operator new(0x38uLL);
  *i = 0;
  i[1] = v8;
  *((_OWORD *)i + 1) = **a4;
  i[5] = 0;
  i[6] = 0;
  i[4] = 0;
  v16 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v17 = *(float *)(a1 + 32);
  if (!v9 || (float)(v17 * (float)v9) < v16)
  {
    v18 = 1;
    if (v9 >= 3)
      v18 = (v9 & (v9 - 1)) != 0;
    v19 = v18 | (2 * v9);
    v20 = vcvtps_u32_f32(v16 / v17);
    if (v19 <= v20)
      v21 = v20;
    else
      v21 = v19;
    std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>>>::__rehash<true>(a1, v21);
    v9 = *(_QWORD *)(a1 + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v8 >= v9)
        v4 = v8 % v9;
      else
        v4 = v8;
    }
    else
    {
      v4 = (v9 - 1) & v8;
    }
  }
  v22 = *(_QWORD *)a1;
  v23 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v4);
  if (v23)
  {
    *i = *v23;
LABEL_44:
    *v23 = i;
    goto LABEL_45;
  }
  *i = *v15;
  *v15 = i;
  *(_QWORD *)(v22 + 8 * v4) = v15;
  if (*i)
  {
    v24 = *(_QWORD *)(*i + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v24 >= v9)
        v24 %= v9;
    }
    else
    {
      v24 &= v9 - 1;
    }
    v23 = (_QWORD *)(*(_QWORD *)a1 + 8 * v24);
    goto LABEL_44;
  }
LABEL_45:
  ++*(_QWORD *)(a1 + 24);
  return i;
}

void sub_241A02878(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  _QWORD *v10;
  uint64_t v11;

  std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,void *>>>::operator()[abi:ne180100](v11, v10);
  _Unwind_Resume(a1);
}

uint64_t std::set<boost::uuids::uuid>::set[abi:ne180100]<std::__wrap_iter<boost::uuids::uuid const*>>(uint64_t a1, unint64_t *a2, unint64_t *a3)
{
  _QWORD *v4;
  unint64_t *v6;

  *(_QWORD *)(a1 + 8) = 0;
  v4 = (_QWORD *)(a1 + 8);
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)a1 = a1 + 8;
  if (a2 != a3)
  {
    v6 = a2;
    do
    {
      std::__tree<boost::uuids::uuid>::__emplace_hint_unique_key_args<boost::uuids::uuid,boost::uuids::uuid const&>((uint64_t **)a1, v4, v6, v6);
      v6 += 2;
    }
    while (v6 != a3);
  }
  return a1;
}

void sub_241A028FC(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::__tree<std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>,std::__map_value_compare<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>,std::less<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes>,true>,std::allocator<std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>>>::destroy(v1, *(_QWORD **)(v1 + 8));
  _Unwind_Resume(a1);
}

char *std::__tree<boost::uuids::uuid>::__emplace_hint_unique_key_args<boost::uuids::uuid,boost::uuids::uuid const&>(uint64_t **a1, _QWORD *a2, unint64_t *a3, _OWORD *a4)
{
  void **v6;
  char *v7;
  uint64_t **v8;
  uint64_t v10;
  uint64_t v11;

  v6 = (void **)std::__tree<boost::uuids::uuid>::__find_equal<boost::uuids::uuid>(a1, a2, &v11, &v10, a3);
  v7 = (char *)*v6;
  if (!*v6)
  {
    v8 = (uint64_t **)v6;
    v7 = (char *)operator new(0x30uLL);
    *(_OWORD *)(v7 + 25) = *a4;
    std::__tree<CLMicroLocationRecordingCompletionMetaInformation::RecordingError>::__insert_node_at(a1, v11, v8, (uint64_t *)v7);
  }
  return v7;
}

_QWORD *std::__tree<boost::uuids::uuid>::__find_equal<boost::uuids::uuid>(_QWORD *a1, _QWORD *a2, _QWORD *a3, _QWORD *a4, unint64_t *a5)
{
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  _QWORD *v9;
  int v10;
  unint64_t v11;
  unint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  int v15;
  _QWORD *v16;
  BOOL v17;
  unint64_t v18;
  unint64_t v19;
  int v20;
  _QWORD *v21;
  unint64_t v22;
  unint64_t v23;
  int v24;

  if (a1 + 1 == a2
    || ((v5 = bswap64(*a5), v6 = bswap64(*(_QWORD *)((char *)a2 + 25)), v5 != v6)
     || (v5 = bswap64(a5[1]), v6 = bswap64(*(_QWORD *)((char *)a2 + 33)), v5 != v6))
    && (v5 < v6 ? (v10 = -1) : (v10 = 1), v10 < 0))
  {
    v7 = *a2;
    if ((_QWORD *)*a1 == a2)
    {
      v9 = a2;
    }
    else
    {
      if (v7)
      {
        v8 = (_QWORD *)*a2;
        do
        {
          v9 = v8;
          v8 = (_QWORD *)v8[1];
        }
        while (v8);
      }
      else
      {
        v16 = a2;
        do
        {
          v9 = (_QWORD *)v16[2];
          v17 = *v9 == (_QWORD)v16;
          v16 = v9;
        }
        while (v17);
      }
      v18 = bswap64(*(_QWORD *)((char *)v9 + 25));
      v19 = bswap64(*a5);
      if (v18 == v19)
      {
        v18 = bswap64(*(_QWORD *)((char *)v9 + 33));
        v19 = bswap64(a5[1]);
        if (v18 == v19)
          return std::__tree<boost::uuids::uuid>::__find_equal<boost::uuids::uuid>((uint64_t)a1, a3, a5);
      }
      v20 = v18 < v19 ? -1 : 1;
      if ((v20 & 0x80000000) == 0)
        return std::__tree<boost::uuids::uuid>::__find_equal<boost::uuids::uuid>((uint64_t)a1, a3, a5);
    }
    if (v7)
    {
      *a3 = v9;
      return v9 + 1;
    }
    else
    {
      *a3 = a2;
      return a2;
    }
  }
  v11 = bswap64(*(_QWORD *)((char *)a2 + 25));
  v12 = bswap64(*a5);
  if (v11 != v12 || (v11 = bswap64(*(_QWORD *)((char *)a2 + 33)), v12 = bswap64(a5[1]), v11 != v12))
  {
    v15 = v11 < v12 ? -1 : 1;
    if (v15 < 0)
    {
      v13 = a2[1];
      if (v13)
      {
        v14 = (_QWORD *)a2[1];
        do
        {
          a4 = v14;
          v14 = (_QWORD *)*v14;
        }
        while (v14);
      }
      else
      {
        v21 = a2;
        do
        {
          a4 = (_QWORD *)v21[2];
          v17 = *a4 == (_QWORD)v21;
          v21 = a4;
        }
        while (!v17);
      }
      if (a4 == a1 + 1
        || ((v22 = bswap64(*a5), v23 = bswap64(*(_QWORD *)((char *)a4 + 25)), v22 != v23)
         || (v22 = bswap64(a5[1]), v23 = bswap64(*(_QWORD *)((char *)a4 + 33)), v22 != v23)
          ? (v22 < v23
           ? (v24 = -1)
           : (v24 = 1))
          : (v24 = 0),
            v24 < 0))
      {
        if (v13)
        {
          *a3 = a4;
        }
        else
        {
          *a3 = a2;
          return a2 + 1;
        }
        return a4;
      }
      return std::__tree<boost::uuids::uuid>::__find_equal<boost::uuids::uuid>((uint64_t)a1, a3, a5);
    }
  }
  *a3 = a2;
  *a4 = a2;
  return a4;
}

_QWORD *std::__tree<boost::uuids::uuid>::__find_equal<boost::uuids::uuid>(uint64_t a1, _QWORD *a2, unint64_t *a3)
{
  _QWORD *result;
  _QWORD *v4;
  _QWORD *v5;
  _QWORD *v6;
  unint64_t v7;
  unint64_t v8;
  int v9;
  unint64_t v10;
  unint64_t v11;
  int v12;

  v5 = *(_QWORD **)(a1 + 8);
  result = (_QWORD *)(a1 + 8);
  v4 = v5;
  if (v5)
  {
    do
    {
      while (1)
      {
        v6 = v4;
        v7 = bswap64(*a3);
        v8 = bswap64(*(_QWORD *)((char *)v6 + 25));
        if (v7 == v8)
        {
          v7 = bswap64(a3[1]);
          v8 = bswap64(*(_QWORD *)((char *)v6 + 33));
          if (v7 == v8)
            break;
        }
        v9 = v7 < v8 ? -1 : 1;
        if ((v9 & 0x80000000) == 0)
          break;
        v4 = (_QWORD *)*v6;
        result = v6;
        if (!*v6)
          goto LABEL_20;
      }
      v10 = bswap64(*(_QWORD *)((char *)v6 + 25));
      v11 = bswap64(*a3);
      if (v10 == v11)
      {
        v10 = bswap64(*(_QWORD *)((char *)v6 + 33));
        v11 = bswap64(a3[1]);
        if (v10 == v11)
          break;
      }
      v12 = v10 < v11 ? -1 : 1;
      if ((v12 & 0x80000000) == 0)
        break;
      result = v6 + 1;
      v4 = (_QWORD *)v6[1];
    }
    while (v4);
  }
  else
  {
    v6 = result;
  }
LABEL_20:
  *a2 = v6;
  return result;
}

_QWORD *std::vector<boost::uuids::uuid>::vector<std::__tree_const_iterator<boost::uuids::uuid,std::__tree_node<boost::uuids::uuid,void *> *,long>,0>(_QWORD *a1, _QWORD *a2, _QWORD *a3)
{
  unint64_t v4;
  _QWORD *v5;
  _QWORD *v6;
  _QWORD *v7;
  BOOL v8;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2 == a3)
  {
    v4 = 0;
  }
  else
  {
    v4 = 0;
    v5 = a2;
    do
    {
      v6 = (_QWORD *)v5[1];
      if (v6)
      {
        do
        {
          v7 = v6;
          v6 = (_QWORD *)*v6;
        }
        while (v6);
      }
      else
      {
        do
        {
          v7 = (_QWORD *)v5[2];
          v8 = *v7 == (_QWORD)v5;
          v5 = v7;
        }
        while (!v8);
      }
      ++v4;
      v5 = v7;
    }
    while (v7 != a3);
  }
  std::vector<boost::uuids::uuid>::__init_with_size[abi:ne180100]<std::__tree_const_iterator<boost::uuids::uuid,std::__tree_node<boost::uuids::uuid,void *> *,long>,std::__tree_const_iterator<boost::uuids::uuid,std::__tree_node<boost::uuids::uuid,void *> *,long>>(a1, a2, a3, v4);
  return a1;
}

_QWORD *std::vector<boost::uuids::uuid>::__init_with_size[abi:ne180100]<std::__tree_const_iterator<boost::uuids::uuid,std::__tree_node<boost::uuids::uuid,void *> *,long>,std::__tree_const_iterator<boost::uuids::uuid,std::__tree_node<boost::uuids::uuid,void *> *,long>>(_QWORD *result, _QWORD *a2, _QWORD *a3, unint64_t a4)
{
  uint64_t v6;

  if (a4)
  {
    v6 = (uint64_t)result;
    std::vector<boost::uuids::uuid>::__vallocate[abi:ne180100](result, a4);
    return (_QWORD *)std::vector<boost::uuids::uuid>::__construct_at_end<std::__tree_const_iterator<boost::uuids::uuid,std::__tree_node<boost::uuids::uuid,void *> *,long>,std::__tree_const_iterator<boost::uuids::uuid,std::__tree_node<boost::uuids::uuid,void *> *,long>>(v6, a2, a3);
  }
  return result;
}

void sub_241A02D3C(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::vector<boost::uuids::uuid>::__construct_at_end<std::__tree_const_iterator<boost::uuids::uuid,std::__tree_node<boost::uuids::uuid,void *> *,long>,std::__tree_const_iterator<boost::uuids::uuid,std::__tree_node<boost::uuids::uuid,void *> *,long>>(uint64_t result, _QWORD *a2, _QWORD *a3)
{
  _OWORD *v3;
  _QWORD *v4;
  _QWORD *v5;
  BOOL v6;

  v3 = *(_OWORD **)(result + 8);
  if (a2 != a3)
  {
    do
    {
      *v3 = *(_OWORD *)((char *)a2 + 25);
      v4 = (_QWORD *)a2[1];
      if (v4)
      {
        do
        {
          v5 = v4;
          v4 = (_QWORD *)*v4;
        }
        while (v4);
      }
      else
      {
        do
        {
          v5 = (_QWORD *)a2[2];
          v6 = *v5 == (_QWORD)a2;
          a2 = v5;
        }
        while (!v6);
      }
      ++v3;
      a2 = v5;
    }
    while (v5 != a3);
  }
  *(_QWORD *)(result + 8) = v3;
  return result;
}

void std::__throw_out_of_range[abi:ne180100](const char *a1)
{
  std::logic_error *exception;

  exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
  std::out_of_range::out_of_range[abi:ne180100](exception, a1);
  __cxa_throw(exception, (struct type_info *)off_2511D18F8, MEMORY[0x24BEDAB00]);
}

void sub_241A02DEC(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

std::logic_error *std::out_of_range::out_of_range[abi:ne180100](std::logic_error *a1, const char *a2)
{
  std::logic_error *result;

  result = std::logic_error::logic_error(a1, a2);
  result->__vftable = (std::logic_error_vtbl *)(MEMORY[0x24BEDB8C0] + 16);
  return result;
}

_QWORD *std::__hash_table<std::__hash_value_type<boost::uuids::uuid,boost::uuids::uuid>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,boost::uuids::uuid>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,boost::uuids::uuid>>>::__equal_range_multi<boost::uuids::uuid>(_QWORD *a1, _QWORD *a2)
{
  _QWORD *result;
  _QWORD *v4;

  result = std::__hash_table<std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>>>::find<boost::uuids::uuid>(a1, a2);
  if (result)
  {
    v4 = result;
    do
    {
      v4 = (_QWORD *)*v4;
      if (!v4)
        break;
    }
    while (v4[2] == *a2 && v4[3] == a2[1]);
  }
  return result;
}

{
  _QWORD *result;
  _QWORD *v4;

  result = std::__hash_table<std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>>>::find<boost::uuids::uuid>(a1, a2);
  if (result)
  {
    v4 = result;
    do
    {
      v4 = (_QWORD *)*v4;
      if (!v4)
        break;
    }
    while (v4[2] == *a2 && v4[3] == a2[1]);
  }
  return result;
}

uint64_t *std::back_insert_iterator<std::vector<CLMicroLocationProto::ConfidenceLevel>>::operator=[abi:ne180100](uint64_t *a1, _DWORD *a2)
{
  uint64_t v4;
  _DWORD *v5;
  _QWORD *v6;
  _DWORD *v7;
  _DWORD *v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char *v13;
  char *v14;
  char *v15;
  int v16;

  v4 = *a1;
  v5 = *(_DWORD **)(*a1 + 8);
  v6 = (_QWORD *)(*a1 + 16);
  if ((unint64_t)v5 >= *v6)
  {
    v8 = *(_DWORD **)v4;
    v9 = ((uint64_t)v5 - *(_QWORD *)v4) >> 2;
    v10 = v9 + 1;
    if ((unint64_t)(v9 + 1) >> 62)
      std::vector<CLMicroLocationProto::ConfidenceReason>::__throw_length_error[abi:ne180100]();
    v11 = *v6 - (_QWORD)v8;
    if (v11 >> 1 > v10)
      v10 = v11 >> 1;
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFFCLL)
      v12 = 0x3FFFFFFFFFFFFFFFLL;
    else
      v12 = v10;
    if (v12)
    {
      v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<CLMicroLocationProto::ConfidenceReason>>((uint64_t)v6, v12);
      v8 = *(_DWORD **)v4;
      v5 = *(_DWORD **)(v4 + 8);
    }
    else
    {
      v13 = 0;
    }
    v14 = &v13[4 * v9];
    v15 = &v13[4 * v12];
    *(_DWORD *)v14 = *a2;
    v7 = v14 + 4;
    while (v5 != v8)
    {
      v16 = *--v5;
      *((_DWORD *)v14 - 1) = v16;
      v14 -= 4;
    }
    *(_QWORD *)v4 = v14;
    *(_QWORD *)(v4 + 8) = v7;
    *(_QWORD *)(v4 + 16) = v15;
    if (v8)
      operator delete(v8);
  }
  else
  {
    *v5 = *a2;
    v7 = v5 + 1;
  }
  *(_QWORD *)(v4 + 8) = v7;
  return a1;
}

char *std::vector<CLMicroLocationProto::ConfidenceLevel>::__insert_with_size[abi:ne180100]<std::__wrap_iter<CLMicroLocationProto::ConfidenceLevel*>,std::__wrap_iter<CLMicroLocationProto::ConfidenceLevel*>>(uint64_t a1, uint64_t __dst, char *__src, char *a4, uint64_t a5)
{
  char *v5;
  char *v7;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  void *v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  char *v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  int64_t v22;
  char *v23;
  char *v24;
  char *v25;
  char *v26;
  int v27;
  char *v28;
  uint64_t v29;
  char *v30;
  int v31;
  void *__p;
  char *v34;
  char *v35;
  char *v36;
  uint64_t v37;

  v5 = (char *)__dst;
  if (a5 < 1)
    return v5;
  v7 = __src;
  v11 = *(_QWORD *)(a1 + 16);
  v9 = a1 + 16;
  v10 = v11;
  v12 = *(_QWORD *)(v9 - 8);
  if (a5 > (uint64_t)(v11 - v12) >> 2)
  {
    v13 = *(void **)a1;
    v14 = a5 + ((uint64_t)(v12 - *(_QWORD *)a1) >> 2);
    if (v14 >> 62)
      std::vector<CLMicroLocationProto::ConfidenceReason>::__throw_length_error[abi:ne180100]();
    v15 = (__dst - (uint64_t)v13) >> 2;
    v16 = v10 - (_QWORD)v13;
    if (v16 >> 1 > v14)
      v14 = v16 >> 1;
    if ((unint64_t)v16 >= 0x7FFFFFFFFFFFFFFCLL)
      v17 = 0x3FFFFFFFFFFFFFFFLL;
    else
      v17 = v14;
    v37 = v9;
    if (v17)
      v18 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<CLMicroLocationProto::ConfidenceReason>>(v9, v17);
    else
      v18 = 0;
    v28 = &v18[4 * v15];
    __p = v18;
    v34 = v28;
    v36 = &v18[4 * v17];
    v29 = 4 * a5;
    v30 = &v28[4 * a5];
    do
    {
      v31 = *(_DWORD *)v7;
      v7 += 4;
      *(_DWORD *)v28 = v31;
      v28 += 4;
      v29 -= 4;
    }
    while (v29);
    v35 = v30;
    v5 = std::vector<CLMicroLocationProto::ConfidenceReason>::__swap_out_circular_buffer((void **)a1, (uint64_t)&__p, v5);
    if (v35 != v34)
      v35 += (v34 - v35 + 3) & 0xFFFFFFFFFFFFFFFCLL;
    if (__p)
      operator delete(__p);
    return v5;
  }
  v19 = v12 - __dst;
  v20 = (uint64_t)(v12 - __dst) >> 2;
  if (v20 >= a5)
  {
    v21 = &__src[4 * a5];
    v23 = *(char **)(v9 - 8);
LABEL_17:
    v24 = &v5[4 * a5];
    v25 = &v23[-4 * a5];
    v26 = v23;
    if ((unint64_t)v25 < v12)
    {
      v26 = v23;
      do
      {
        v27 = *(_DWORD *)v25;
        v25 += 4;
        *(_DWORD *)v26 = v27;
        v26 += 4;
      }
      while ((unint64_t)v25 < v12);
    }
    *(_QWORD *)(a1 + 8) = v26;
    if (v23 != v24)
      memmove(&v23[-4 * ((v23 - v24) >> 2)], v5, v23 - v24);
    if (v21 != v7)
      memmove(v5, v7, v21 - v7);
    return v5;
  }
  v21 = &__src[4 * v20];
  v22 = a4 - v21;
  if (a4 != v21)
    memmove(*(void **)(v9 - 8), &__src[4 * v20], a4 - v21);
  v23 = (char *)(v12 + v22);
  *(_QWORD *)(a1 + 8) = v12 + v22;
  if (v19 >= 1)
    goto LABEL_17;
  return v5;
}

void sub_241A03130(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void std::vector<CLMicroLocationProto::ConfidenceLevel>::__append(char **a1, unint64_t a2)
{
  uint64_t v4;
  char *v5;
  char *v6;
  char *v7;
  char *v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  char *v14;
  char *v15;
  char *v16;
  char *v17;
  int v18;

  v6 = a1[2];
  v4 = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(char **)(v4 - 8);
  if (a2 <= (v6 - v7) >> 2)
  {
    if (a2)
    {
      bzero(*(void **)(v4 - 8), 4 * a2);
      v7 += 4 * a2;
    }
    a1[1] = v7;
  }
  else
  {
    v8 = *a1;
    v9 = v7 - *a1;
    v10 = a2 + (v9 >> 2);
    if (v10 >> 62)
      std::vector<CLMicroLocationProto::ConfidenceReason>::__throw_length_error[abi:ne180100]();
    v11 = v9 >> 2;
    v12 = v5 - v8;
    if (v12 >> 1 > v10)
      v10 = v12 >> 1;
    if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFFCLL)
      v13 = 0x3FFFFFFFFFFFFFFFLL;
    else
      v13 = v10;
    if (v13)
    {
      v14 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<CLMicroLocationProto::ConfidenceReason>>(v4, v13);
      v8 = *a1;
      v7 = a1[1];
    }
    else
    {
      v14 = 0;
    }
    v15 = &v14[4 * v11];
    v16 = &v14[4 * v13];
    bzero(v15, 4 * a2);
    v17 = &v15[4 * a2];
    while (v7 != v8)
    {
      v18 = *((_DWORD *)v7 - 1);
      v7 -= 4;
      *((_DWORD *)v15 - 1) = v18;
      v15 -= 4;
    }
    *a1 = v15;
    a1[1] = v17;
    a1[2] = v16;
    if (v8)
      operator delete(v8);
  }
}

char *std::vector<boost::uuids::uuid>::__insert_with_size[abi:ne180100]<std::__wrap_iter<boost::uuids::uuid*>,std::__wrap_iter<boost::uuids::uuid*>>(uint64_t a1, uint64_t __dst, char *__src, char *a4, uint64_t a5)
{
  char *v5;
  char *v7;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  void *v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  char *v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  int64_t v22;
  char *v23;
  char *v24;
  char *v25;
  char *v26;
  __int128 v27;
  char *v28;
  uint64_t v29;
  char *v30;
  __int128 v31;
  void *__p;
  char *v34;
  char *v35;
  char *v36;
  uint64_t v37;

  v5 = (char *)__dst;
  if (a5 < 1)
    return v5;
  v7 = __src;
  v11 = *(_QWORD *)(a1 + 16);
  v9 = a1 + 16;
  v10 = v11;
  v12 = *(_QWORD *)(v9 - 8);
  if (a5 > (uint64_t)(v11 - v12) >> 4)
  {
    v13 = *(void **)a1;
    v14 = a5 + ((uint64_t)(v12 - *(_QWORD *)a1) >> 4);
    if (v14 >> 60)
      std::vector<CLMicroLocationProto::ConfidenceReason>::__throw_length_error[abi:ne180100]();
    v15 = (__dst - (uint64_t)v13) >> 4;
    v16 = v10 - (_QWORD)v13;
    if (v16 >> 3 > v14)
      v14 = v16 >> 3;
    if ((unint64_t)v16 >= 0x7FFFFFFFFFFFFFF0)
      v17 = 0xFFFFFFFFFFFFFFFLL;
    else
      v17 = v14;
    v37 = v9;
    if (v17)
      v18 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<boost::uuids::uuid>>(v9, v17);
    else
      v18 = 0;
    v28 = &v18[16 * v15];
    __p = v18;
    v34 = v28;
    v36 = &v18[16 * v17];
    v29 = 16 * a5;
    v30 = &v28[16 * a5];
    do
    {
      v31 = *(_OWORD *)v7;
      v7 += 16;
      *(_OWORD *)v28 = v31;
      v28 += 16;
      v29 -= 16;
    }
    while (v29);
    v35 = v30;
    v5 = (char *)std::vector<boost::uuids::uuid>::__swap_out_circular_buffer((void **)a1, (uint64_t)&__p, v5);
    if (v35 != v34)
      v35 += (v34 - v35 + 15) & 0xFFFFFFFFFFFFFFF0;
    if (__p)
      operator delete(__p);
    return v5;
  }
  v19 = v12 - __dst;
  v20 = (uint64_t)(v12 - __dst) >> 4;
  if (v20 >= a5)
  {
    v21 = &__src[16 * a5];
    v23 = *(char **)(v9 - 8);
LABEL_17:
    v24 = &v5[16 * a5];
    v25 = &v23[-16 * a5];
    v26 = v23;
    if ((unint64_t)v25 < v12)
    {
      v26 = v23;
      do
      {
        v27 = *(_OWORD *)v25;
        v25 += 16;
        *(_OWORD *)v26 = v27;
        v26 += 16;
      }
      while ((unint64_t)v25 < v12);
    }
    *(_QWORD *)(a1 + 8) = v26;
    if (v23 != v24)
      memmove(&v23[-16 * ((v23 - v24) >> 4)], v5, v23 - v24);
    if (v21 != v7)
      memmove(v5, v7, v21 - v7);
    return v5;
  }
  v21 = &__src[16 * v20];
  v22 = a4 - v21;
  if (a4 != v21)
    memmove(*(void **)(v9 - 8), &__src[16 * v20], a4 - v21);
  v23 = (char *)(v12 + v22);
  *(_QWORD *)(a1 + 8) = v12 + v22;
  if (v19 >= 1)
    goto LABEL_17;
  return v5;
}

void sub_241A03444(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void *std::vector<boost::uuids::uuid>::__swap_out_circular_buffer(void **a1, uint64_t a2, char *__src)
{
  void *v5;
  char *v6;
  void *v7;
  char *v8;
  uint64_t v9;
  _BYTE *v10;
  uint64_t v11;
  int64_t v12;
  char *v13;
  void *v14;
  void *v15;

  v5 = *(void **)(a2 + 8);
  v6 = (char *)*a1;
  v7 = v5;
  if (*a1 != __src)
  {
    v8 = __src;
    v9 = *(_QWORD *)(a2 + 8);
    do
    {
      v7 = (void *)(v9 - 16);
      *(_OWORD *)(v9 - 16) = *((_OWORD *)v8 - 1);
      v8 -= 16;
      v9 -= 16;
    }
    while (v8 != v6);
  }
  *(_QWORD *)(a2 + 8) = v7;
  v10 = a1[1];
  v11 = *(_QWORD *)(a2 + 16);
  v12 = v10 - __src;
  if (v10 != __src)
  {
    memmove(*(void **)(a2 + 16), __src, v10 - __src);
    v7 = *(void **)(a2 + 8);
  }
  *(_QWORD *)(a2 + 16) = v11 + v12;
  v13 = (char *)*a1;
  *a1 = v7;
  *(_QWORD *)(a2 + 8) = v13;
  v14 = a1[1];
  a1[1] = *(void **)(a2 + 16);
  *(_QWORD *)(a2 + 16) = v14;
  v15 = a1[2];
  a1[2] = *(void **)(a2 + 24);
  *(_QWORD *)(a2 + 24) = v15;
  *(_QWORD *)a2 = *(_QWORD *)(a2 + 8);
  return v5;
}

void std::vector<boost::uuids::uuid>::__append(void **a1, unint64_t a2)
{
  uint64_t v4;
  _BYTE *v5;
  _BYTE *v6;
  char *v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char *v13;
  char *v14;
  char *v15;
  char *v16;
  char *v17;
  char *v18;

  v6 = a1[2];
  v4 = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(char **)(v4 - 8);
  if (a2 <= (v6 - v7) >> 4)
  {
    if (a2)
    {
      bzero(*(void **)(v4 - 8), 16 * a2);
      v7 += 16 * a2;
    }
    a1[1] = v7;
  }
  else
  {
    v8 = v7 - (_BYTE *)*a1;
    v9 = a2 + (v8 >> 4);
    if (v9 >> 60)
      std::vector<CLMicroLocationProto::ConfidenceReason>::__throw_length_error[abi:ne180100]();
    v10 = v8 >> 4;
    v11 = v5 - (_BYTE *)*a1;
    if (v11 >> 3 > v9)
      v9 = v11 >> 3;
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF0)
      v12 = 0xFFFFFFFFFFFFFFFLL;
    else
      v12 = v9;
    if (v12)
      v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<boost::uuids::uuid>>(v4, v12);
    else
      v13 = 0;
    v14 = &v13[16 * v10];
    v15 = &v13[16 * v12];
    bzero(v14, 16 * a2);
    v16 = &v14[16 * a2];
    v18 = (char *)*a1;
    v17 = (char *)a1[1];
    if (v17 != *a1)
    {
      do
      {
        *((_OWORD *)v14 - 1) = *((_OWORD *)v17 - 1);
        v14 -= 16;
        v17 -= 16;
      }
      while (v17 != v18);
      v17 = (char *)*a1;
    }
    *a1 = v14;
    a1[1] = v16;
    a1[2] = v15;
    if (v17)
      operator delete(v17);
  }
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<CLMicroLocationModel::SimilarityListData::EventInformation>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0xCCCCCCCCCCCCCCDLL)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(20 * a2);
}

void OUTLINED_FUNCTION_3_1(void *a1, NSObject *a2, uint64_t a3, uint64_t a4, const char *a5, const char *a6, uint8_t *a7)
{
  _os_signpost_emit_with_name_impl(a1, a2, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, a5, a6, a7, 0x26u);
}

void OUTLINED_FUNCTION_4_0()
{
  JUMPOUT(0x2426A04BCLL);
}

void OUTLINED_FUNCTION_5_0(void *a1, NSObject *a2, os_log_type_t a3, const char *a4, uint8_t *a5)
{
  _os_log_impl(a1, a2, a3, a4, a5, 0x26u);
}

BOOL OUTLINED_FUNCTION_7(NSObject *a1)
{
  return os_log_type_enabled(a1, OS_LOG_TYPE_FAULT);
}

BOOL OUTLINED_FUNCTION_8(NSObject *a1)
{
  return os_log_type_enabled(a1, OS_LOG_TYPE_INFO);
}

BOOL OUTLINED_FUNCTION_9(os_log_t log)
{
  return os_signpost_enabled(log);
}

void sub_241A03CD0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
  id *v14;

  objc_destroyWeak(v14);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_241A043BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_241A04B20(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__0(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__0(uint64_t a1)
{

}

uint64_t CLMutexDubiousLock(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
}

uint64_t CLMutexDubiousUnlock(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 24))(a1);
}

void BasicMutex::BasicMutex(BasicMutex *this, const char *a2, int a3, char a4)
{
  uint64_t v8;
  char *v9;
  int v10;
  pthread_mutexattr_t v11;
  uint64_t v12;

  v12 = *MEMORY[0x24BDAC8D0];
  *(_QWORD *)this = &off_2511D2E80;
  v8 = operator new();
  *((_QWORD *)this + 1) = v8;
  *(_DWORD *)(v8 + 64) = 0;
  *(_QWORD *)(v8 + 72) = 0;
  *(_BYTE *)(v8 + 80) = a4;
  if (a2)
    v9 = strdup(a2);
  else
    v9 = 0;
  *(_QWORD *)(v8 + 88) = v9;
  pthread_mutexattr_init(&v11);
  if (a3)
    v10 = 2;
  else
    v10 = 0;
  pthread_mutexattr_settype(&v11, v10);
  pthread_mutex_init(*((pthread_mutex_t **)this + 1), &v11);
  pthread_mutexattr_destroy(&v11);
}

void BasicMutex::~BasicMutex(pthread_mutex_t **this)
{
  pthread_mutex_t *v2;

  *this = (pthread_mutex_t *)&off_2511D2E80;
  pthread_mutex_destroy(this[1]);
  v2 = this[1];
  if (*(_QWORD *)&v2[1].__opaque[16])
  {
    free(*(void **)&v2[1].__opaque[16]);
    *(_QWORD *)&this[1][1].__opaque[16] = 0;
  }
  MEMORY[0x2426A04D4]();
}

{
  BasicMutex::~BasicMutex(this);
  JUMPOUT(0x2426A04D4);
}

pthread_t BasicMutex::lock(pthread_mutex_t **this)
{
  pthread_t result;
  pthread_mutex_t *v3;
  int sig;
  _opaque_pthread_t *v5;

  if (pthread_mutex_lock(this[1]))
  {
    result = (pthread_t)BasicMutex::lock();
    goto LABEL_9;
  }
  result = pthread_self();
  v3 = this[1];
  sig = v3[1].__sig;
  if (sig < 0)
  {
LABEL_9:
    result = (pthread_t)BasicMutex::lock(result);
    goto LABEL_10;
  }
  v5 = *(_opaque_pthread_t **)v3[1].__opaque;
  if (sig)
  {
    if (v5 == result)
    {
LABEL_7:
      LODWORD(v3[1].__sig) = sig + 1;
      *(_QWORD *)v3[1].__opaque = result;
      return result;
    }
    result = (pthread_t)BasicMutex::lock();
  }
  if (!v5)
    goto LABEL_7;
LABEL_10:
  BasicMutex::lock(result);
  return (pthread_t)_CLLogObjectForCategory_MicroLocation_Default();
}

uint64_t BasicMutex::unlock(BasicMutex *this)
{
  uint64_t v1;
  int v2;
  int v3;
  uint64_t result;
  BasicMutex *v5;

  v1 = *((_QWORD *)this + 1);
  v2 = *(_DWORD *)(v1 + 64);
  if (v2 <= 0)
  {
    result = BasicMutex::unlock();
LABEL_7:
    v5 = (BasicMutex *)BasicMutex::unlock(result);
    return BasicMutex::__assertOwned(v5);
  }
  v3 = v2 - 1;
  *(_DWORD *)(v1 + 64) = v3;
  if (!v3)
    *(_QWORD *)(v1 + 72) = 0;
  result = pthread_mutex_unlock((pthread_mutex_t *)v1);
  if ((_DWORD)result)
    goto LABEL_7;
  return result;
}

BOOL BasicMutex::__assertOwned(BasicMutex *this)
{
  pthread_t v1;

  v1 = *(pthread_t *)(*((_QWORD *)this + 1) + 72);
  return v1 == pthread_self();
}

BOOL BasicMutex::__assertNotOwned(BasicMutex *this)
{
  pthread_t v1;

  v1 = *(pthread_t *)(*((_QWORD *)this + 1) + 72);
  return v1 != pthread_self();
}

void ___ZL45_CLLogObjectForCategory_MicroLocation_Defaultv_block_invoke_3()
{
  os_log_t v0;
  void *v1;

  v0 = os_log_create("com.apple.MicroLocation", "MicroLocation");
  v1 = (void *)logObject_MicroLocation_Default;
  logObject_MicroLocation_Default = (uint64_t)v0;

}

BOOL OUTLINED_FUNCTION_6_0(os_log_t log)
{
  return os_signpost_enabled(log);
}

uint64_t CLMicroLocationMigrationTable::Entry::Entry(uint64_t result, int a2, _QWORD *a3)
{
  *(_QWORD *)result = *a3;
  *(_DWORD *)(result + 8) = a2;
  return result;
}

void sub_241A05790(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_241A05B4C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  void *v14;
  void *v15;

  _Unwind_Resume(a1);
}

void sub_241A05CD0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void ___ZL45_CLLogObjectForCategory_MicroLocation_Defaultv_block_invoke_4()
{
  os_log_t v0;
  void *v1;

  v0 = os_log_create("com.apple.MicroLocation", "MicroLocation");
  v1 = (void *)logObject_MicroLocation_Default;
  logObject_MicroLocation_Default = (uint64_t)v0;

}

void sub_241A05D5C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_241A05DA8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_241A05E14(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

void sub_241A05E6C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_241A05EB8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_241A05F1C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

void sub_241A06068(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;
  void *v11;

  _Unwind_Resume(a1);
}

void sub_241A060F8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;
  void *v11;

  _Unwind_Resume(a1);
}

uint64_t CLMicroLocationSensorsDriver::CLMicroLocationSensorsDriver(uint64_t a1, uint64_t a2)
{
  _OWORD *v4;
  _OWORD *v5;

  *(_QWORD *)a1 = &off_2511D2FC0;
  *(_QWORD *)(a1 + 8) = &unk_2511D3088;
  *(_QWORD *)(a1 + 16) = &unk_2511D30B8;
  *(_QWORD *)(a1 + 24) = &unk_2511D30E8;
  *(_QWORD *)(a1 + 32) = &unk_2511D3130;
  *(_QWORD *)(a1 + 40) = &unk_2511D3168;
  *(_QWORD *)(a1 + 48) = &unk_2511D31A0;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_QWORD *)(a1 + 88) = 0;
  v4 = operator new(0x68uLL);
  *v4 = xmmword_241BB2420;
  v4[1] = xmmword_241BB2430;
  v4[2] = xmmword_241BB2440;
  v4[3] = xmmword_241BB2450;
  v4[4] = xmmword_241BB2460;
  v4[5] = xmmword_241BB2470;
  *((_QWORD *)v4 + 12) = 13;
  *(_QWORD *)(a1 + 72) = v4;
  *(_QWORD *)(a1 + 80) = (char *)v4 + 104;
  *(_QWORD *)(a1 + 88) = (char *)v4 + 104;
  *(_QWORD *)(a1 + 96) = 0;
  *(_QWORD *)(a1 + 104) = 0;
  *(_QWORD *)(a1 + 112) = 0;
  v5 = operator new(0x68uLL);
  *v5 = xmmword_241BB2420;
  v5[1] = xmmword_241BB2430;
  v5[2] = xmmword_241BB2440;
  v5[3] = xmmword_241BB2450;
  v5[4] = xmmword_241BB2460;
  v5[5] = xmmword_241BB2470;
  *((_QWORD *)v5 + 12) = 13;
  *(_QWORD *)(a1 + 96) = v5;
  *(_QWORD *)(a1 + 104) = (char *)v5 + 104;
  *(_QWORD *)(a1 + 112) = (char *)v5 + 104;
  *(_QWORD *)(a1 + 120) = 0;
  *(_BYTE *)(a1 + 128) = 0;
  *(_QWORD *)(a1 + 136) = 0;
  *(_BYTE *)(a1 + 144) = 0;
  *(_OWORD *)(a1 + 152) = 0u;
  *(_OWORD *)(a1 + 168) = 0u;
  *(_OWORD *)(a1 + 184) = 0u;
  *(_QWORD *)(a1 + 200) = 0;
  *(_QWORD *)(a1 + 208) = a2;
  CLMicroLocationSensorsDriver::createAndRegisterWiFiScanDelegateAdapter((CLMicroLocationSensorsDriver *)a1);
  CLMicroLocationSensorsDriver::createAndRegisterOdometryDelegateAdapter((CLMicroLocationSensorsDriver *)a1);
  return a1;
}

void sub_241A062C8(_Unwind_Exception *a1)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)(v1 + 72);
  if (v3)
  {
    *(_QWORD *)(v1 + 80) = v3;
    operator delete(v3);
  }

  _Unwind_Resume(a1);
}

uint64_t CLMicroLocationSensorsDriver::createAndRegisterWiFiScanDelegateAdapter(CLMicroLocationSensorsDriver *this)
{
  ULWiFiScanClientAdapter *v2;
  void *v3;
  uint64_t v4;
  _QWORD v6[5];
  _QWORD v7[5];
  _QWORD v8[5];
  _QWORD v9[5];
  _QWORD v10[5];
  _QWORD v11[5];

  v2 = objc_alloc_init(ULWiFiScanClientAdapter);
  v3 = (void *)*((_QWORD *)this + 8);
  *((_QWORD *)this + 8) = v2;

  v4 = MEMORY[0x24BDAC760];
  v11[0] = MEMORY[0x24BDAC760];
  v11[1] = 3221225472;
  v11[2] = ___ZN28CLMicroLocationSensorsDriver40createAndRegisterWiFiScanDelegateAdapterEv_block_invoke;
  v11[3] = &__block_descriptor_40_e5_v8__0l;
  v11[4] = this;
  objc_msgSend(*((id *)this + 8), "setDidStopWifiRssiScanningBlock:", v11);
  v10[0] = v4;
  v10[1] = 3221225472;
  v10[2] = ___ZN28CLMicroLocationSensorsDriver40createAndRegisterWiFiScanDelegateAdapterEv_block_invoke_2;
  v10[3] = &__block_descriptor_40_e5_v8__0l;
  v10[4] = this;
  objc_msgSend(*((id *)this + 8), "setDidStopWifiScanTimerBlock:", v10);
  v9[0] = v4;
  v9[1] = 3221225472;
  v9[2] = ___ZN28CLMicroLocationSensorsDriver40createAndRegisterWiFiScanDelegateAdapterEv_block_invoke_3;
  v9[3] = &__block_descriptor_40_e20_v24__0_v8__NSDate_16l;
  v9[4] = this;
  objc_msgSend(*((id *)this + 8), "setDidUpdateWifiAPsBlock:", v9);
  v8[0] = v4;
  v8[1] = 3221225472;
  v8[2] = ___ZN28CLMicroLocationSensorsDriver40createAndRegisterWiFiScanDelegateAdapterEv_block_invoke_4;
  v8[3] = &__block_descriptor_40_e5_v8__0l;
  v8[4] = this;
  objc_msgSend(*((id *)this + 8), "setDidReceiveWifiScanErrorBlock:", v8);
  v7[0] = v4;
  v7[1] = 3221225472;
  v7[2] = ___ZN28CLMicroLocationSensorsDriver40createAndRegisterWiFiScanDelegateAdapterEv_block_invoke_5;
  v7[3] = &__block_descriptor_40_e5_v8__0l;
  v7[4] = this;
  objc_msgSend(*((id *)this + 8), "setDidReceiveWifiScanErrorBusyBlock:", v7);
  v6[0] = v4;
  v6[1] = 3221225472;
  v6[2] = ___ZN28CLMicroLocationSensorsDriver40createAndRegisterWiFiScanDelegateAdapterEv_block_invoke_6;
  v6[3] = &__block_descriptor_40_e31_v16__0__ULWiFiAssociatedState_8l;
  v6[4] = this;
  return objc_msgSend(*((id *)this + 8), "setDidUpdateWiFiAssociatedStateBlock:", v6);
}

uint64_t CLMicroLocationSensorsDriver::createAndRegisterOdometryDelegateAdapter(CLMicroLocationSensorsDriver *this)
{
  ULOdometryClientAdapter *v2;
  void *v3;
  uint64_t v4;
  _QWORD v6[5];
  _QWORD v7[5];

  v2 = objc_alloc_init(ULOdometryClientAdapter);
  v3 = (void *)*((_QWORD *)this + 22);
  *((_QWORD *)this + 22) = v2;

  v4 = MEMORY[0x24BDAC760];
  v7[0] = MEMORY[0x24BDAC760];
  v7[1] = 3221225472;
  v7[2] = ___ZN28CLMicroLocationSensorsDriver40createAndRegisterOdometryDelegateAdapterEv_block_invoke;
  v7[3] = &__block_descriptor_40_e28_v24__0__NSError_8__NSDate_16l;
  v7[4] = this;
  objc_msgSend(*((id *)this + 22), "setDidReceiveOdometryErrorBlock:", v7);
  v6[0] = v4;
  v6[1] = 3221225472;
  v6[2] = ___ZN28CLMicroLocationSensorsDriver40createAndRegisterOdometryDelegateAdapterEv_block_invoke_111;
  v6[3] = &__block_descriptor_40_e37_v24__0__ULOdometryStatus_8__NSUUID_16l;
  v6[4] = this;
  return objc_msgSend(*((id *)this + 22), "setDidReceiveOdometryUpdateBlock:", v6);
}

uint64_t ___ZN28CLMicroLocationSensorsDriver40createAndRegisterWiFiScanDelegateAdapterEv_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 32) + 48))(*(_QWORD *)(a1 + 32));
}

uint64_t ___ZN28CLMicroLocationSensorsDriver40createAndRegisterWiFiScanDelegateAdapterEv_block_invoke_2(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 32) + 56))(*(_QWORD *)(a1 + 32));
}

void ___ZN28CLMicroLocationSensorsDriver40createAndRegisterWiFiScanDelegateAdapterEv_block_invoke_3(uint64_t a1, uint64_t a2, void *a3)
{
  id v5;
  uint64_t v6;
  id v7;

  v5 = a3;
  v6 = *(_QWORD *)(a1 + 32);
  v7 = v5;
  objc_msgSend(v5, "timeIntervalSinceReferenceDate");
  (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v6 + 16))(v6, a2);

}

void sub_241A06610(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

uint64_t ___ZN28CLMicroLocationSensorsDriver40createAndRegisterWiFiScanDelegateAdapterEv_block_invoke_4(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 32) + 32))(*(_QWORD *)(a1 + 32));
}

uint64_t ___ZN28CLMicroLocationSensorsDriver40createAndRegisterWiFiScanDelegateAdapterEv_block_invoke_5(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 32) + 40))(*(_QWORD *)(a1 + 32));
}

uint64_t ___ZN28CLMicroLocationSensorsDriver40createAndRegisterWiFiScanDelegateAdapterEv_block_invoke_6(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 32) + 24))(*(_QWORD *)(a1 + 32));
}

void ___ZN28CLMicroLocationSensorsDriver40createAndRegisterOdometryDelegateAdapterEv_block_invoke(uint64_t a1, void *a2, void *a3)
{
  id v5;
  id v6;
  uint64_t v7;
  NSObject *v8;
  double v9;
  double v10;
  void *v11;
  _BYTE v12[32];
  uint8_t buf[4];
  id v14;
  __int16 v15;
  id v16;
  uint64_t v17;

  v17 = *MEMORY[0x24BDAC8D0];
  v5 = a2;
  v6 = a3;
  v7 = *(_QWORD *)(a1 + 32);
  if (onceToken_MicroLocation_Default != -1)
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_9);
  v8 = logObject_MicroLocation_Default;
  if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 138412546;
    v14 = v6;
    v15 = 2112;
    v16 = v5;
    _os_log_impl(&dword_2419D9000, v8, OS_LOG_TYPE_ERROR, "SensorsDriver, got odometry error, timestamp: %@, error: %@", buf, 0x16u);
  }
  objc_msgSend(v6, "timeIntervalSinceReferenceDate");
  v10 = v9;
  objc_msgSend(MEMORY[0x24BDD1880], "nilUUID");
  v11 = (void *)objc_claimAutoreleasedReturnValue();
  CLMiLoOdometryTable::Entry::Entry((uint64_t)v12, v11, 0.0, 0.0, 0.0, v10);
  (*(void (**)(uint64_t, _BYTE *))(*(_QWORD *)v7 + 88))(v7, v12);

}

void sub_241A067A8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void ___ZN28CLMicroLocationSensorsDriver40createAndRegisterOdometryDelegateAdapterEv_block_invoke_111(uint64_t a1, void *a2, void *a3)
{
  id v5;
  id v6;
  uint64_t v7;
  NSObject *v8;
  void *v9;
  void *v10;
  void *v11;
  void *v12;
  void *v13;
  double v14;
  double v15;
  void *v16;
  float v17;
  float v18;
  void *v19;
  float v20;
  float v21;
  void *v22;
  float v23;
  float v24;
  _BYTE v25[32];
  uint8_t buf[4];
  void *v27;
  __int16 v28;
  void *v29;
  __int16 v30;
  void *v31;
  __int16 v32;
  void *v33;
  __int16 v34;
  id v35;
  uint64_t v36;

  v36 = *MEMORY[0x24BDAC8D0];
  v5 = a2;
  v6 = a3;
  v7 = *(_QWORD *)(a1 + 32);
  if (onceToken_MicroLocation_Default != -1)
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_9);
  v8 = (id)logObject_MicroLocation_Default;
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    objc_msgSend(v5, "statusDate");
    v9 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v5, "deltaPositionX");
    v10 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v5, "deltaPositionY");
    v11 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v5, "deltaPositionZ");
    v12 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 138413314;
    v27 = v9;
    v28 = 2112;
    v29 = v10;
    v30 = 2112;
    v31 = v11;
    v32 = 2112;
    v33 = v12;
    v34 = 2112;
    v35 = v6;
    _os_log_impl(&dword_2419D9000, v8, OS_LOG_TYPE_DEFAULT, "SensorsDriver, odometry update, timestamp: %@, deltaX: %@, deltaY: %@, deltaZ: %@, uuid: %@", buf, 0x34u);

  }
  objc_msgSend(v5, "statusDate");
  v13 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v13, "timeIntervalSinceReferenceDate");
  v15 = v14;

  objc_msgSend(v5, "deltaPositionX");
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v16, "floatValue");
  v18 = v17;

  objc_msgSend(v5, "deltaPositionY");
  v19 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v19, "floatValue");
  v21 = v20;

  objc_msgSend(v5, "deltaPositionZ");
  v22 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v22, "floatValue");
  v24 = v23;

  CLMiLoOdometryTable::Entry::Entry((uint64_t)v25, v6, v18, v21, v24, v15);
  (*(void (**)(uint64_t, _BYTE *))(*(_QWORD *)v7 + 80))(v7, v25);

}

void sub_241A06A3C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;

  _Unwind_Resume(a1);
}

void CLMicroLocationSensorsDriver::setWifiLink(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  void *v4;

  std::function<ULWiFiScanProvider * ()(objc_object  {objcproto26ULWiFiScanProviderDelegate}*)>::operator()(a2, *(void **)(a1 + 64));
  v3 = objc_claimAutoreleasedReturnValue();
  v4 = *(void **)(a1 + 56);
  *(_QWORD *)(a1 + 56) = v3;

}

id std::function<ULWiFiScanProvider * ()(objc_object  {objcproto26ULWiFiScanProviderDelegate}*)>::operator()(uint64_t a1, void *a2)
{
  uint64_t v3;
  void *v4;
  id v6;

  v6 = a2;
  v3 = *(_QWORD *)(a1 + 24);
  if (!v3)
    std::__throw_bad_function_call[abi:ne180100]();
  (*(void (**)(uint64_t, id *))(*(_QWORD *)v3 + 48))(v3, &v6);
  v4 = (void *)objc_claimAutoreleasedReturnValue();

  return v4;
}

void sub_241A06B5C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{

  _Unwind_Resume(a1);
}

uint64_t CLMicroLocationSensorsDriver::setBleLink(uint64_t a1, uint64_t *a2)
{
  uint64_t v3;
  uint64_t result;

  v3 = *a2;
  *a2 = 0;
  result = *(_QWORD *)(a1 + 152);
  *(_QWORD *)(a1 + 152) = v3;
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

uint64_t CLMicroLocationSensorsDriver::setUwbLink(uint64_t a1, uint64_t *a2)
{
  uint64_t v3;
  uint64_t result;

  v3 = *a2;
  *a2 = 0;
  result = *(_QWORD *)(a1 + 160);
  *(_QWORD *)(a1 + 160) = v3;
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

void CLMicroLocationSensorsDriver::setOdometryLink(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  void *v4;

  std::function<ULOdometryProvider * ()(objc_object  {objcproto26ULOdometryProviderDelegate}*)>::operator()(a2, *(void **)(a1 + 176));
  v3 = objc_claimAutoreleasedReturnValue();
  v4 = *(void **)(a1 + 168);
  *(_QWORD *)(a1 + 168) = v3;

}

id std::function<ULOdometryProvider * ()(objc_object  {objcproto26ULOdometryProviderDelegate}*)>::operator()(uint64_t a1, void *a2)
{
  uint64_t v3;
  void *v4;
  id v6;

  v6 = a2;
  v3 = *(_QWORD *)(a1 + 24);
  if (!v3)
    std::__throw_bad_function_call[abi:ne180100]();
  (*(void (**)(uint64_t, id *))(*(_QWORD *)v3 + 48))(v3, &v6);
  v4 = (void *)objc_claimAutoreleasedReturnValue();

  return v4;
}

void sub_241A06C58(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{

  _Unwind_Resume(a1);
}

uint64_t CLMicroLocationSensorsDriver::setMotionLink(uint64_t a1, uint64_t *a2)
{
  uint64_t v3;
  uint64_t result;

  v3 = *a2;
  *a2 = 0;
  result = *(_QWORD *)(a1 + 184);
  *(_QWORD *)(a1 + 184) = v3;
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

uint64_t CLMicroLocationSensorsDriver::setStopMotionLink(uint64_t a1, uint64_t *a2)
{
  uint64_t v3;
  uint64_t result;

  v3 = *a2;
  *a2 = 0;
  result = *(_QWORD *)(a1 + 192);
  *(_QWORD *)(a1 + 192) = v3;
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

uint64_t CLMicroLocationSensorsDriver::setCustomLoiRecordingFenceLink(uint64_t a1, uint64_t *a2)
{
  uint64_t v3;
  uint64_t result;

  v3 = *a2;
  *a2 = 0;
  result = *(_QWORD *)(a1 + 200);
  *(_QWORD *)(a1 + 200) = v3;
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

void CLMicroLocationSensorsDriver::requestWifiScan(uint64_t a1, unsigned __int8 *a2)
{
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  int v8;
  int v9;
  NSObject *v10;
  uint64_t v11;
  void *v12;
  NSObject *v13;
  uint8_t v14[16];
  uint8_t buf[16];

  *(_BYTE *)(a1 + 128) = *a2;
  *(_QWORD *)(a1 + 120) = *((_QWORD *)a2 + 1);
  *(_BYTE *)(a1 + 129) = a2[16];
  objc_msgSend(*(id *)(a1 + 56), "startScanTimerWithInterval:", (double)(uint64_t)CLMicroLocationSensorsDriver::recordingDuration((CLMicroLocationSensorsDriver *)a1) / 1000.0);
  *(_BYTE *)(a1 + 144) = 0;
  +[ULDefaultsSingleton shared](ULDefaultsSingleton, "shared");
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v4, "defaultsDictionary");
  v5 = (void *)objc_claimAutoreleasedReturnValue();

  objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "ULScanWifiRSSIEnabled");
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v5, "objectForKey:", v6);
  v7 = (void *)objc_claimAutoreleasedReturnValue();
  if (v7 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
    v8 = objc_msgSend(v7, "BOOLValue");
  else
    v8 = objc_msgSend(MEMORY[0x24BDBD1C8], "BOOLValue");
  v9 = v8;

  if (v9)
  {
    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_9);
    v10 = logObject_MicroLocation_Default;
    if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_2419D9000, v10, OS_LOG_TYPE_DEFAULT, "SensorsDriver, wifi, start scanning", buf, 2u);
    }
    ULWiFiStrategyBuilder::buildScanStartegy(*a2, (_QWORD *)(a1 + 72), (unsigned int **)(a1 + 96), *((_QWORD *)a2 + 3));
    v11 = objc_claimAutoreleasedReturnValue();
    v12 = *(void **)(a1 + 136);
    *(_QWORD *)(a1 + 136) = v11;

    objc_msgSend(*(id *)(a1 + 56), "startScanWithStrategyType:initialDelay:", *(_QWORD *)(a1 + 136), *((double *)a2 + 1));
  }
  else
  {
    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_9);
    v13 = logObject_MicroLocation_Default;
    if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)v14 = 0;
      _os_log_impl(&dword_2419D9000, v13, OS_LOG_TYPE_DEBUG, "SensorsDriver, Not scanning Wifi RSSI because it's not enabled", v14, 2u);
    }
  }
}

void sub_241A06EF4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

CLMicroLocationSensorsDriver *CLMicroLocationSensorsDriver::recordingDuration(CLMicroLocationSensorsDriver *this)
{
  CLMicroLocationSensorsDriver *v1;
  int v2;
  int v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  int v9;
  int v10;
  void *v11;
  void *v12;
  void *v13;
  void *v14;
  void *v15;
  int v16;
  int v17;

  v1 = this;
  v2 = *((unsigned __int8 *)this + 128);
  if (v2 == 1)
  {
LABEL_5:
    v3 = *((unsigned __int8 *)v1 + 129);
    +[ULDefaultsSingleton shared](ULDefaultsSingleton, "shared");
    v4 = (void *)objc_claimAutoreleasedReturnValue();
    v5 = v4;
    if (v3)
    {
      objc_msgSend(v4, "defaultsDictionary");
      v6 = (void *)objc_claimAutoreleasedReturnValue();

      objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "ULLocalizingDurationMinimumDualBands");
      v7 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v6, "objectForKey:", v7);
      v8 = (void *)objc_claimAutoreleasedReturnValue();
      if (!v8 || (objc_opt_class(), (objc_opt_isKindOfClass() & 1) == 0))
      {
        v9 = objc_msgSend(&unk_2511ED420, "intValue");
        goto LABEL_22;
      }
    }
    else
    {
      objc_msgSend(v4, "defaultsDictionary");
      v6 = (void *)objc_claimAutoreleasedReturnValue();

      objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "ULLocalizingDurationMinimum");
      v7 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v6, "objectForKey:", v7);
      v8 = (void *)objc_claimAutoreleasedReturnValue();
      if (!v8 || (objc_opt_class(), (objc_opt_isKindOfClass() & 1) == 0))
      {
        v9 = objc_msgSend(&unk_2511ED3C0, "intValue");
        goto LABEL_22;
      }
    }
    v9 = objc_msgSend(v8, "intValue");
LABEL_22:
    v17 = v9;

    return (CLMicroLocationSensorsDriver *)((uint64_t)(*((double *)v1 + 15) * 1000.0) + v17);
  }
  if (v2 == 2)
  {
    v10 = *((unsigned __int8 *)this + 129);
    +[ULDefaultsSingleton shared](ULDefaultsSingleton, "shared");
    v11 = (void *)objc_claimAutoreleasedReturnValue();
    v12 = v11;
    if (v10)
    {
      objc_msgSend(v11, "defaultsDictionary");
      v13 = (void *)objc_claimAutoreleasedReturnValue();

      objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "ULRecordingDurationDualBands");
      v14 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v13, "objectForKey:", v14);
      v15 = (void *)objc_claimAutoreleasedReturnValue();
      if (!v15 || (objc_opt_class(), (objc_opt_isKindOfClass() & 1) == 0))
      {
        v16 = objc_msgSend(&unk_2511ED408, "intValue");
        goto LABEL_24;
      }
    }
    else
    {
      objc_msgSend(v11, "defaultsDictionary");
      v13 = (void *)objc_claimAutoreleasedReturnValue();

      objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "ULRecordingDuration");
      v14 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v13, "objectForKey:", v14);
      v15 = (void *)objc_claimAutoreleasedReturnValue();
      if (!v15 || (objc_opt_class(), (objc_opt_isKindOfClass() & 1) == 0))
      {
        v16 = objc_msgSend(&unk_2511ED3D8, "intValue");
        goto LABEL_24;
      }
    }
    v16 = objc_msgSend(v15, "intValue");
LABEL_24:
    v1 = (CLMicroLocationSensorsDriver *)v16;

    return v1;
  }
  if (!*((_BYTE *)this + 128))
  {
    CLMicroLocationSensorsDriver::recordingDuration();
    goto LABEL_5;
  }
  return v1;
}

void sub_241A071E8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void CLMicroLocationSensorsDriver::onWifiAPs(uint64_t a1, CLMicroLocationProto::WiFiRssi **a2, double a3)
{
  _QWORD *v6;
  CLMicroLocationProto::WiFiRssi *v7;
  CLMicroLocationProto::WiFiRssi *v8;
  uint64_t v9;
  unsigned int v10;
  _QWORD **v11;
  _QWORD *v12;
  _QWORD *v13;
  _QWORD **v14;
  unsigned int v15;
  CLMicroLocationProto::WiFiRssi *v16;
  CLMicroLocationProto::WiFiRssi *v17;
  CLMicroLocationProto::WiFiRssi *v18;
  _QWORD *v19;
  unsigned int v20;
  _QWORD **v21;
  _QWORD *v22;
  _QWORD **v23;
  unsigned int v24;
  _QWORD *v25;
  CLMicroLocationProto::WiFiRssi *v26;
  uint64_t v27;
  uint64_t v28;
  int v29;
  NSObject *v30;
  int v31;
  NSObject *v32;
  int v33;
  _QWORD **v34;
  _QWORD *v35;
  _QWORD *v36;
  _QWORD **v37;
  _QWORD *v38[2];
  _BYTE buf[32];
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  uint64_t v44;
  uint64_t v45;

  v45 = *MEMORY[0x24BDAC8D0];
  *(_BYTE *)(a1 + 144) = 0;
  *(_OWORD *)buf = xmmword_241BB2870;
  *(_OWORD *)&buf[16] = unk_241BB2880;
  v40 = xmmword_241BB2890;
  LODWORD(v41) = 13;
  std::set<unsigned int>::set[abi:ne180100]((uint64_t)&v37, (unsigned int *)buf, 13);
  if (*(_BYTE *)(a1 + 129))
  {
    v40 = xmmword_241BB28C4;
    v41 = unk_241BB28D4;
    v42 = xmmword_241BB28E4;
    v43 = unk_241BB28F4;
    *(_OWORD *)buf = xmmword_241BB28A4;
    *(_OWORD *)&buf[16] = unk_241BB28B4;
    v44 = 0xB1000000ADLL;
    std::set<unsigned int>::set[abi:ne180100]((uint64_t)&v34, (unsigned int *)buf, 26);
    std::__tree<std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>,std::__map_value_compare<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>,std::less<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes>,true>,std::allocator<std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>>>::destroy((uint64_t)&v37, v38[0]);
    v6 = v35;
    v37 = v34;
    v38[0] = v35;
    v38[1] = v36;
    if (v36)
    {
      v35[2] = v38;
      v34 = &v35;
      v35 = 0;
      v36 = 0;
      v6 = 0;
    }
    else
    {
      v37 = v38;
    }
    std::__tree<std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>,std::__map_value_compare<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>,std::less<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes>,true>,std::allocator<std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>>>::destroy((uint64_t)&v34, v6);
  }
  v8 = *a2;
  v7 = a2[1];
  v9 = v7 - *a2;
  if (v7 == *a2)
    goto LABEL_34;
  if (v38[0])
  {
    while (1)
    {
      v10 = *((_DWORD *)v8 + 8);
      v11 = v38;
      v12 = v38[0];
      do
      {
        v13 = v12;
        v14 = v11;
        v15 = *((_DWORD *)v12 + 7);
        if (v15 >= v10)
          v11 = (_QWORD **)v12;
        else
          ++v12;
        v12 = (_QWORD *)*v12;
      }
      while (v12);
      if (v11 == v38)
        break;
      if (v15 < v10)
        v13 = v14;
      if (v10 < *((_DWORD *)v13 + 7))
        break;
      v8 = (CLMicroLocationProto::WiFiRssi *)((char *)v8 + 56);
      if (v8 == v7)
        goto LABEL_34;
    }
  }
  if (v8 == v7)
  {
LABEL_34:
    v26 = a2[1];
  }
  else
  {
    v16 = (CLMicroLocationProto::WiFiRssi *)((char *)v8 + 56);
    if ((CLMicroLocationProto::WiFiRssi *)((char *)v8 + 56) == v7)
    {
      v26 = a2[1];
      v7 = v8;
    }
    else
    {
      v17 = v8;
      do
      {
        v18 = v8;
        v8 = v16;
        v19 = v38[0];
        if (v38[0])
        {
          v20 = *((_DWORD *)v18 + 22);
          v21 = v38;
          do
          {
            v22 = v19;
            v23 = v21;
            v24 = *((_DWORD *)v19 + 7);
            v25 = v19 + 1;
            if (v24 >= v20)
            {
              v25 = v22;
              v21 = (_QWORD **)v22;
            }
            v19 = (_QWORD *)*v25;
          }
          while (v19);
          if (v21 != v38)
          {
            if (v24 < v20)
              v22 = v23;
            if (v20 >= *((_DWORD *)v22 + 7))
            {
              CLMicroLocationProto::WiFiRssi::CopyFrom(v17, v8);
              *((_DWORD *)v17 + 12) = *((_DWORD *)v18 + 26);
              v17 = (CLMicroLocationProto::WiFiRssi *)((char *)v17 + 56);
            }
          }
        }
        v16 = (CLMicroLocationProto::WiFiRssi *)((char *)v8 + 56);
      }
      while ((CLMicroLocationProto::WiFiRssi *)((char *)v8 + 56) != v7);
      v26 = a2[1];
      v7 = v17;
    }
  }
  std::vector<CLMiLoProtobufWrapper::WiFiRssi>::erase((uint64_t)a2, v7, v26);
  v27 = 0x6DB6DB6DB6DB6DB7 * (v9 >> 3);
  v28 = 0x6DB6DB6DB6DB6DB7 * ((a2[1] - *a2) >> 3);
  v29 = v27 - v28;
  if (v27 != v28)
  {
    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_9);
    v30 = logObject_MicroLocation_Default;
    if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_ERROR))
    {
      v31 = *(unsigned __int8 *)(a1 + 129);
      *(_DWORD *)buf = 68289538;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(_QWORD *)&buf[10] = "";
      *(_WORD *)&buf[18] = 1026;
      *(_DWORD *)&buf[20] = v29;
      *(_WORD *)&buf[24] = 1026;
      *(_DWORD *)&buf[26] = v31;
      _os_log_impl(&dword_2419D9000, v30, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"wifi measurements with unexpected channel received\", \"number of invalid measurements\":%{public}u, \"is scanning dual bands?\":%{public}hhd}", buf, 0x1Eu);
    }
    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_9);
    v32 = logObject_MicroLocation_Default;
    if (os_signpost_enabled((os_log_t)logObject_MicroLocation_Default))
    {
      v33 = *(unsigned __int8 *)(a1 + 129);
      *(_DWORD *)buf = 68289538;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(_QWORD *)&buf[10] = "";
      *(_WORD *)&buf[18] = 1026;
      *(_DWORD *)&buf[20] = v29;
      *(_WORD *)&buf[24] = 1026;
      *(_DWORD *)&buf[26] = v33;
      _os_signpost_emit_with_name_impl(&dword_2419D9000, v32, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "wifi measurements with unexpected channel received", "{\"msg%{public}.0s\":\"wifi measurements with unexpected channel received\", \"number of invalid measurements\":%{public}u, \"is scanning dual bands?\":%{public}hhd}", buf, 0x1Eu);
    }
  }
  (*(void (**)(_QWORD, CLMicroLocationProto::WiFiRssi **, double))(**(_QWORD **)(a1 + 208) + 16))(*(_QWORD *)(a1 + 208), a2, a3);
  objc_msgSend(*(id *)(a1 + 56), "issueNextScanIterrationOrStopScan:", *(_QWORD *)(a1 + 136));
  std::__tree<std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>,std::__map_value_compare<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>,std::less<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes>,true>,std::allocator<std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>>>::destroy((uint64_t)&v37, v38[0]);
}

void sub_241A076A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14, _QWORD *a15)
{
  std::__tree<std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>,std::__map_value_compare<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>,std::less<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes>,true>,std::allocator<std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>>>::destroy((uint64_t)&a14, a15);
  _Unwind_Resume(a1);
}

CLMicroLocationProto::WiFiRssi *std::vector<CLMiLoProtobufWrapper::WiFiRssi>::erase(uint64_t a1, CLMicroLocationProto::WiFiRssi *this, CLMicroLocationProto::WiFiRssi *a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  if (this != a3)
  {
    std::__unwrap_and_dispatch[abi:ne180100]<std::__overload<std::__move_loop<std::_ClassicAlgPolicy>,std::__move_trivial>,CLMiLoProtobufWrapper::WiFiRssi *,CLMiLoProtobufWrapper::WiFiRssi *,CLMiLoProtobufWrapper::WiFiRssi *,0>(a3, *(CLMicroLocationProto::WiFiRssi **)(a1 + 8), this);
    v6 = v5;
    v7 = *(_QWORD *)(a1 + 8);
    if (v7 != v5)
    {
      do
        CLMicroLocationProto::WiFiRssi::~WiFiRssi((CLMicroLocationProto::WiFiRssi *)(v7 - 56));
      while (v7 != v6);
    }
    *(_QWORD *)(a1 + 8) = v6;
  }
  return this;
}

uint64_t CLMicroLocationSensorsDriver::onWifiScanError(CLMicroLocationSensorsDriver *this)
{
  *((_BYTE *)this + 144) = 1;
  (*(void (**)(_QWORD))(**((_QWORD **)this + 26) + 128))(*((_QWORD *)this + 26));
  return objc_msgSend(*((id *)this + 7), "stopScanTimer");
}

uint64_t CLMicroLocationSensorsDriver::onWifiScanErrorBusy(CLMicroLocationSensorsDriver *this)
{
  *((_BYTE *)this + 144) = 1;
  (*(void (**)(_QWORD))(**((_QWORD **)this + 26) + 136))(*((_QWORD *)this + 26));
  return objc_msgSend(*((id *)this + 7), "stopScanTimer");
}

uint64_t CLMicroLocationSensorsDriver::onWiFiAssociatedState(CLMicroLocationSensorsDriver *this, ULWiFiAssociatedState *a2)
{
  return (*(uint64_t (**)(_QWORD, ULWiFiAssociatedState *))(**((_QWORD **)this + 26) + 40))(*((_QWORD *)this + 26), a2);
}

uint64_t CLMicroLocationSensorsDriver::onStopWifiRssiScanning(uint64_t this)
{
  *(_QWORD *)(this + 120) = 0;
  *(_BYTE *)(this + 128) = 0;
  return this;
}

uint64_t CLMicroLocationSensorsDriver::onStopWifiScanTimer(CLMicroLocationSensorsDriver *this, const ULWiFiScanStrategy *a2)
{
  uint64_t v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  int v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  BOOL v12;
  void *v13;
  void *v14;
  void *v15;
  void *v16;
  void *v17;
  int v18;
  uint64_t v19;
  uint64_t v20;
  NSObject *v21;
  int v23;
  NSObject *v24;
  int v25;
  int v26;
  __int16 v27;
  const char *v28;
  __int16 v29;
  double v30;
  __int16 v31;
  uint64_t v32;
  uint64_t v33;

  v33 = *MEMORY[0x24BDAC8D0];
  v3 = ULWiFiStrategyBuilder::expectedScanDuration(*((ULWiFiStrategyBuilder **)this + 17), a2);
  +[ULDefaultsSingleton shared](ULDefaultsSingleton, "shared");
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v4, "defaultsDictionary");
  v5 = (void *)objc_claimAutoreleasedReturnValue();

  objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "ULWiFiScanExtensionInterfaceSlackTime");
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v5, "objectForKey:", v6);
  v7 = (void *)objc_claimAutoreleasedReturnValue();
  if (v7 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
    v8 = objc_msgSend(v7, "intValue");
  else
    v8 = objc_msgSend(&unk_2511ED3F0, "intValue");
  v9 = v8;

  v10 = (*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)this + 26) + 32))(*((_QWORD *)this + 26), v3 + v9);
  if (v10)
  {
    v11 = v10;
    v12 = *((_BYTE *)this + 144) == 0;
    +[ULDefaultsSingleton shared](ULDefaultsSingleton, "shared");
    v13 = (void *)objc_claimAutoreleasedReturnValue();
    v14 = v13;
    if (v12)
    {
      objc_msgSend(v13, "defaultsDictionary");
      v15 = (void *)objc_claimAutoreleasedReturnValue();

      objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "ULWifiRetryInitialDelay");
      v16 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v15, "objectForKey:", v16);
      v17 = (void *)objc_claimAutoreleasedReturnValue();
      if (!v17 || (objc_opt_class(), (objc_opt_isKindOfClass() & 1) == 0))
      {
        v18 = objc_msgSend(&unk_2511ED3A8, "intValue");
        goto LABEL_20;
      }
    }
    else
    {
      objc_msgSend(v13, "defaultsDictionary");
      v15 = (void *)objc_claimAutoreleasedReturnValue();

      objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "ULWifiErrorRetryDelay");
      v16 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v15, "objectForKey:", v16);
      v17 = (void *)objc_claimAutoreleasedReturnValue();
      if (!v17 || (objc_opt_class(), (objc_opt_isKindOfClass() & 1) == 0))
      {
        v18 = objc_msgSend(&unk_2511ED390, "intValue");
        goto LABEL_20;
      }
    }
    v18 = objc_msgSend(v17, "intValue");
LABEL_20:
    v23 = v18;

    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_9);
    v24 = logObject_MicroLocation_Default;
    if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEBUG))
    {
      v25 = 68289538;
      v26 = 0;
      v27 = 2082;
      v28 = "";
      v29 = 2050;
      *(_QWORD *)&v30 = v11 + v23;
      v31 = 2050;
      v32 = v23;
      _os_log_impl(&dword_2419D9000, v24, OS_LOG_TYPE_DEBUG, "{\"msg%{public}.0s\":\"SensorDriver, Wifi scan timer stopped but but scanned AP requirements not met, extend timer\", \"by duration (ms)\":%{public}lld, \"initial delay(ms)\":%{public}lld}", (uint8_t *)&v25, 0x26u);
    }
    objc_msgSend(*((id *)this + 7), "startScanTimerWithInterval:", (double)(v11 + v23) / 1000.0);
    return objc_msgSend(*((id *)this + 7), "startScanWithStrategyType:initialDelay:", *((_QWORD *)this + 17), (double)v23 / 1000.0);
  }
  v19 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 26) + 120))(*((_QWORD *)this + 26));
  if (v19)
  {
    v20 = v19;
    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_9);
    v21 = logObject_MicroLocation_Default;
    if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT))
    {
      v25 = 68289282;
      v26 = 0;
      v27 = 2082;
      v28 = "";
      v29 = 2050;
      v30 = (double)v20;
      _os_log_impl(&dword_2419D9000, v21, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"SensorsLogic, WiFi scan extention due to backlight on\", \"backlightOnExtention_s\":\"%{public}.09f\"}", (uint8_t *)&v25, 0x1Cu);
    }
    objc_msgSend(*((id *)this + 7), "startScanTimerWithInterval:", (double)v20 / 1000.0);
    return objc_msgSend(*((id *)this + 7), "startScanWithStrategyType:initialDelay:", *((_QWORD *)this + 17), 0.0);
  }
  else
  {
    (*(void (**)(_QWORD))(**((_QWORD **)this + 26) + 152))(*((_QWORD *)this + 26));
    objc_msgSend(*((id *)this + 7), "stopScan");
    return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 26) + 24))(*((_QWORD *)this + 26));
  }
}

void sub_241A07C2C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

uint64_t CLMicroLocationSensorsDriver::cancelWifiScan(CLMicroLocationSensorsDriver *this)
{
  CLMicroLocationSensorsDriver *v1;
  NSObject *v2;
  void **v3;
  void *__p[2];
  char v6;
  uint8_t buf[4];
  int v8;
  __int16 v9;
  const char *v10;
  __int16 v11;
  void **v12;
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  if (*((_BYTE *)this + 128))
  {
    v1 = this;
    if (onceToken_MicroLocation_Default == -1)
      goto LABEL_3;
  }
  else
  {
    CLMicroLocationSensorsDriver::cancelWifiScan();
    __break(1u);
  }
  dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_9);
LABEL_3:
  v2 = (id)logObject_MicroLocation_Default;
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG))
  {
    CLMicroLocationUtils::scanActivityToString(*((_BYTE *)v1 + 128), __p);
    if (v6 >= 0)
      v3 = __p;
    else
      v3 = (void **)__p[0];
    *(_DWORD *)buf = 68289282;
    v8 = 0;
    v9 = 2082;
    v10 = "";
    v11 = 2082;
    v12 = v3;
    _os_log_impl(&dword_2419D9000, v2, OS_LOG_TYPE_DEBUG, "{\"msg%{public}.0s\":\"SensorsDriver, received cancel wifi scan\", \"scan activity\":%{public, location:escape_only}s}", buf, 0x1Cu);
    if (v6 < 0)
      operator delete(__p[0]);
  }

  return objc_msgSend(*((id *)v1 + 7), "stopScan");
}

void sub_241A07DD8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

char *CLMicroLocationSensorsDriver::setCurrentWifiChannelHistogram(uint64_t a1, uint64_t a2)
{
  std::vector<CLMicroLocationWiFiChannelHistogram>::__assign_with_size[abi:ne180100]<std::__wrap_iter<CLMicroLocationWiFiChannelHistogram*>,std::__wrap_iter<CLMicroLocationWiFiChannelHistogram*>>((char *)(a1 + 72), *(char **)a2, *(_QWORD *)(a2 + 8), (uint64_t)(*(_QWORD *)(a2 + 8) - *(_QWORD *)a2) >> 3);
  return std::vector<CLMicroLocationWiFiChannelHistogram>::__assign_with_size[abi:ne180100]<std::__wrap_iter<CLMicroLocationWiFiChannelHistogram*>,std::__wrap_iter<CLMicroLocationWiFiChannelHistogram*>>((char *)(a1 + 96), *(char **)a2, *(_QWORD *)(a2 + 8), (uint64_t)(*(_QWORD *)(a2 + 8) - *(_QWORD *)a2) >> 3);
}

uint64_t CLMicroLocationSensorsDriver::onBleRssiMeasurement(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 208) + 48))(*(_QWORD *)(a1 + 208));
}

uint64_t `non-virtual thunk to'CLMicroLocationSensorsDriver::onBleRssiMeasurement(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 200) + 48))(*(_QWORD *)(a1 + 200));
}

uint64_t CLMicroLocationSensorsDriver::onBleIdentityItem(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 208) + 56))(*(_QWORD *)(a1 + 208));
}

uint64_t `non-virtual thunk to'CLMicroLocationSensorsDriver::onBleIdentityItem(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 200) + 56))(*(_QWORD *)(a1 + 200));
}

uint64_t CLMicroLocationSensorsDriver::startBleRssiSession(CLMicroLocationSensorsDriver *this, const CLMicroLocationUtils::BleScanConfiguration *a2)
{
  NSObject *v4;
  CLMicroLocationSensorsDriver *started;
  uint8_t v7[16];

  if (onceToken_MicroLocation_Default != -1)
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_9);
  v4 = logObject_MicroLocation_Default;
  if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)v7 = 0;
    _os_log_impl(&dword_2419D9000, v4, OS_LOG_TYPE_DEFAULT, "SensorsDriver, ble, start session", v7, 2u);
  }
  if (*((_BYTE *)a2 + 9))
    return (*(uint64_t (**)(_QWORD, const CLMicroLocationUtils::BleScanConfiguration *))(**((_QWORD **)this + 19)
                                                                                                 + 16))(*((_QWORD *)this + 19), a2);
  if (!*((_BYTE *)this + 128))
  {
    *((_BYTE *)this + 128) = *((_BYTE *)a2 + 8);
    return (*(uint64_t (**)(_QWORD, const CLMicroLocationUtils::BleScanConfiguration *))(**((_QWORD **)this + 19)
                                                                                                 + 16))(*((_QWORD *)this + 19), a2);
  }
  started = (CLMicroLocationSensorsDriver *)CLMicroLocationSensorsDriver::startBleRssiSession();
  return CLMicroLocationSensorsDriver::stopBleRssiSession(started);
}

uint64_t CLMicroLocationSensorsDriver::stopBleRssiSession(CLMicroLocationSensorsDriver *this)
{
  NSObject *v2;
  uint8_t v4[16];

  if (onceToken_MicroLocation_Default != -1)
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_9);
  v2 = logObject_MicroLocation_Default;
  if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)v4 = 0;
    _os_log_impl(&dword_2419D9000, v2, OS_LOG_TYPE_DEFAULT, "SensorsDriver, ble, stop session", v4, 2u);
  }
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 19) + 24))(*((_QWORD *)this + 19));
}

uint64_t CLMicroLocationSensorsDriver::activateBleScannersIfNeeded(CLMicroLocationSensorsDriver *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 19) + 32))(*((_QWORD *)this + 19));
}

uint64_t CLMicroLocationSensorsDriver::onUwbRangeMeasurements(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 208) + 64))(*(_QWORD *)(a1 + 208));
}

uint64_t `non-virtual thunk to'CLMicroLocationSensorsDriver::onUwbRangeMeasurements(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 184) + 64))(*(_QWORD *)(a1 + 184));
}

uint64_t CLMicroLocationSensorsDriver::setRangingRate(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 160) + 32))(*(_QWORD *)(a1 + 160));
}

uint64_t CLMicroLocationSensorsDriver::resetRangingRate(CLMicroLocationSensorsDriver *this)
{
  NSObject *v2;
  uint8_t v4[16];

  if (onceToken_MicroLocation_Default != -1)
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_9);
  v2 = logObject_MicroLocation_Default;
  if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)v4 = 0;
    _os_log_impl(&dword_2419D9000, v2, OS_LOG_TYPE_DEFAULT, "SensorsDriver, uwb, reset ranging rate", v4, 2u);
  }
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 20) + 40))(*((_QWORD *)this + 20));
}

uint64_t CLMicroLocationSensorsDriver::startRanging(CLMicroLocationSensorsDriver *this)
{
  NSObject *v2;
  uint8_t v4[16];

  if (onceToken_MicroLocation_Default != -1)
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_9);
  v2 = logObject_MicroLocation_Default;
  if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)v4 = 0;
    _os_log_impl(&dword_2419D9000, v2, OS_LOG_TYPE_DEFAULT, "SensorsDriver, uwb, start session", v4, 2u);
  }
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 20) + 16))(*((_QWORD *)this + 20));
}

uint64_t CLMicroLocationSensorsDriver::stopRanging(CLMicroLocationSensorsDriver *this)
{
  NSObject *v2;
  uint8_t v4[16];

  if (onceToken_MicroLocation_Default != -1)
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_9);
  v2 = logObject_MicroLocation_Default;
  if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)v4 = 0;
    _os_log_impl(&dword_2419D9000, v2, OS_LOG_TYPE_DEFAULT, "SensorsDriver, uwb, stop session", v4, 2u);
  }
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 20) + 24))(*((_QWORD *)this + 20));
}

uint64_t CLMicroLocationSensorsDriver::onHomeNearbySessionStopped(CLMicroLocationSensorsDriver *this)
{
  CFAbsoluteTime v2;

  v2 = cl::chrono::CFAbsoluteTimeClock::now();
  return (*(uint64_t (**)(_QWORD, _QWORD, double))(**((_QWORD **)this + 26) + 112))(*((_QWORD *)this + 26), 0, v2);
}

uint64_t `non-virtual thunk to'CLMicroLocationSensorsDriver::onHomeNearbySessionStopped(CLMicroLocationSensorsDriver *this)
{
  CFAbsoluteTime v2;

  v2 = cl::chrono::CFAbsoluteTimeClock::now();
  return (*(uint64_t (**)(_QWORD, _QWORD, double))(**((_QWORD **)this + 23) + 112))(*((_QWORD *)this + 23), 0, v2);
}

uint64_t CLMicroLocationSensorsDriver::onHomeNearbySessionCreated(CLMicroLocationSensorsDriver *this)
{
  CFAbsoluteTime v2;

  v2 = cl::chrono::CFAbsoluteTimeClock::now();
  return (*(uint64_t (**)(_QWORD, uint64_t, CFAbsoluteTime))(**((_QWORD **)this + 26) + 112))(*((_QWORD *)this + 26), 1, v2);
}

uint64_t `non-virtual thunk to'CLMicroLocationSensorsDriver::onHomeNearbySessionCreated(CLMicroLocationSensorsDriver *this)
{
  CFAbsoluteTime v2;

  v2 = cl::chrono::CFAbsoluteTimeClock::now();
  return (*(uint64_t (**)(_QWORD, uint64_t, CFAbsoluteTime))(**((_QWORD **)this + 23) + 112))(*((_QWORD *)this + 23), 1, v2);
}

uint64_t CLMicroLocationSensorsDriver::onHomeNearbySessionSuspended(CLMicroLocationSensorsDriver *this)
{
  CFAbsoluteTime v2;

  v2 = cl::chrono::CFAbsoluteTimeClock::now();
  return (*(uint64_t (**)(_QWORD, uint64_t, CFAbsoluteTime))(**((_QWORD **)this + 26) + 112))(*((_QWORD *)this + 26), 2, v2);
}

uint64_t `non-virtual thunk to'CLMicroLocationSensorsDriver::onHomeNearbySessionSuspended(CLMicroLocationSensorsDriver *this)
{
  CFAbsoluteTime v2;

  v2 = cl::chrono::CFAbsoluteTimeClock::now();
  return (*(uint64_t (**)(_QWORD, uint64_t, CFAbsoluteTime))(**((_QWORD **)this + 23) + 112))(*((_QWORD *)this + 23), 2, v2);
}

uint64_t CLMicroLocationSensorsDriver::onHomeNearbySessionResumed(CLMicroLocationSensorsDriver *this)
{
  CFAbsoluteTime v2;

  v2 = cl::chrono::CFAbsoluteTimeClock::now();
  return (*(uint64_t (**)(_QWORD, uint64_t, CFAbsoluteTime))(**((_QWORD **)this + 26) + 112))(*((_QWORD *)this + 26), 1, v2);
}

uint64_t `non-virtual thunk to'CLMicroLocationSensorsDriver::onHomeNearbySessionResumed(CLMicroLocationSensorsDriver *this)
{
  CFAbsoluteTime v2;

  v2 = cl::chrono::CFAbsoluteTimeClock::now();
  return (*(uint64_t (**)(_QWORD, uint64_t, CFAbsoluteTime))(**((_QWORD **)this + 23) + 112))(*((_QWORD *)this + 23), 1, v2);
}

void CLMicroLocationSensorsDriver::onOdometryError(CLMicroLocationSensorsDriver *this, Entry a2)
{
  uint64_t v2;
  uint64_t v3;
  void *v4;
  __int128 v5;
  uint64_t v6;
  id v7;

  v2 = *(_QWORD *)a2.var0.var0;
  v3 = *((_QWORD *)this + 26);
  v5 = *(_OWORD *)*(_QWORD *)a2.var0.var0;
  v4 = *(void **)(*(_QWORD *)a2.var0.var0 + 24);
  v6 = *(_QWORD *)(*(_QWORD *)a2.var0.var0 + 16);
  v7 = v4;
  (*(void (**)(uint64_t, __int128 *))(*(_QWORD *)v3 + 80))(v3, &v5);

}

void sub_241A083CC(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Unwind_Resume(a1);
}

void `non-virtual thunk to'CLMicroLocationSensorsDriver::onOdometryError(CLMicroLocationSensorsDriver *this, Entry a2)
{
  CLMicroLocationSensorsDriver::onOdometryError((CLMicroLocationSensorsDriver *)((char *)this - 16), a2);
}

void CLMicroLocationSensorsDriver::onOdometryUpdate(CLMicroLocationSensorsDriver *this, Entry a2)
{
  uint64_t v2;
  uint64_t v3;
  void *v4;
  __int128 v5;
  uint64_t v6;
  id v7;

  v2 = *(_QWORD *)a2.var0.var0;
  v3 = *((_QWORD *)this + 26);
  v5 = *(_OWORD *)*(_QWORD *)a2.var0.var0;
  v4 = *(void **)(*(_QWORD *)a2.var0.var0 + 24);
  v6 = *(_QWORD *)(*(_QWORD *)a2.var0.var0 + 16);
  v7 = v4;
  (*(void (**)(uint64_t, __int128 *))(*(_QWORD *)v3 + 72))(v3, &v5);

}

void sub_241A08444(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Unwind_Resume(a1);
}

void `non-virtual thunk to'CLMicroLocationSensorsDriver::onOdometryUpdate(CLMicroLocationSensorsDriver *this, Entry a2)
{
  CLMicroLocationSensorsDriver::onOdometryUpdate((CLMicroLocationSensorsDriver *)((char *)this - 16), a2);
}

uint64_t CLMicroLocationSensorsDriver::startOdometryBackgroundUpdates(id *this)
{
  NSObject *v2;
  _DWORD v4[2];
  __int16 v5;
  const char *v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  if (onceToken_MicroLocation_Default != -1)
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_9);
  v2 = logObject_MicroLocation_Default;
  if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEBUG))
  {
    v4[0] = 68289026;
    v4[1] = 0;
    v5 = 2082;
    v6 = "";
    _os_log_impl(&dword_2419D9000, v2, OS_LOG_TYPE_DEBUG, "{\"msg%{public}.0s\":\"CLMicroLocationSensorsDriver, startOdometryBackgroundUpdates\"}", (uint8_t *)v4, 0x12u);
  }
  return objc_msgSend(this[21], "startBackgroundUpdates");
}

uint64_t CLMicroLocationSensorsDriver::stopOdometryBackgroundUpdates(id *this)
{
  NSObject *v2;
  _DWORD v4[2];
  __int16 v5;
  const char *v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  if (onceToken_MicroLocation_Default != -1)
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_9);
  v2 = logObject_MicroLocation_Default;
  if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEBUG))
  {
    v4[0] = 68289026;
    v4[1] = 0;
    v5 = 2082;
    v6 = "";
    _os_log_impl(&dword_2419D9000, v2, OS_LOG_TYPE_DEBUG, "{\"msg%{public}.0s\":\"stopOdometryBackgroundUpdates, stopOdometryBackgroundUpdates\"}", (uint8_t *)v4, 0x12u);
  }
  return objc_msgSend(this[21], "stopBackgroundUpdates");
}

uint64_t CLMicroLocationSensorsDriver::onMotionMeasurements(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 208) + 88))(*(_QWORD *)(a1 + 208));
}

{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 208) + 88))(*(_QWORD *)(a1 + 208));
}

uint64_t `non-virtual thunk to'CLMicroLocationSensorsDriver::onMotionMeasurements(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 176) + 88))(*(_QWORD *)(a1 + 176));
}

{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 168) + 88))(*(_QWORD *)(a1 + 168));
}

uint64_t CLMicroLocationSensorsDriver::onFailureToReceiveGeofenceStatusReports(CLMicroLocationSensorsDriver *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 26) + 96))(*((_QWORD *)this + 26));
}

uint64_t `non-virtual thunk to'CLMicroLocationSensorsDriver::onFailureToReceiveGeofenceStatusReports(CLMicroLocationSensorsDriver *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 22) + 96))(*((_QWORD *)this + 22));
}

uint64_t CLMicroLocationSensorsDriver::onStopMotionMeasurements(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 208) + 104))(*(_QWORD *)(a1 + 208));
}

uint64_t `non-virtual thunk to'CLMicroLocationSensorsDriver::onStopMotionMeasurements(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 168) + 104))(*(_QWORD *)(a1 + 168));
}

uint64_t CLMicroLocationSensorsDriver::logEvent(CLMicroLocationSensorsDriver *this, const Entry *a2)
{
  return (*(uint64_t (**)(_QWORD, const Entry *))(**((_QWORD **)this + 26) + 144))(*((_QWORD *)this + 26), a2);
}

uint64_t `non-virtual thunk to'CLMicroLocationSensorsDriver::logEvent(CLMicroLocationSensorsDriver *this, const Entry *a2)
{
  return (*(uint64_t (**)(_QWORD, const Entry *))(**((_QWORD **)this + 22) + 144))(*((_QWORD *)this + 22), a2);
}

{
  return (*(uint64_t (**)(_QWORD, const Entry *))(**((_QWORD **)this + 21) + 144))(*((_QWORD *)this + 21), a2);
}

{
  return (*(uint64_t (**)(_QWORD, const Entry *))(**((_QWORD **)this + 20) + 144))(*((_QWORD *)this + 20), a2);
}

uint64_t CLMicroLocationSensorsDriver::setMotionFence(CLMicroLocationSensorsDriver *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 23) + 16))(*((_QWORD *)this + 23));
}

uint64_t CLMicroLocationSensorsDriver::clearMotionFence(CLMicroLocationSensorsDriver *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 23) + 24))(*((_QWORD *)this + 23));
}

uint64_t CLMicroLocationSensorsDriver::startMotionSession(CLMicroLocationSensorsDriver *this)
{
  (*(void (**)(_QWORD))(**((_QWORD **)this + 23) + 32))(*((_QWORD *)this + 23));
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 24) + 32))(*((_QWORD *)this + 24));
}

uint64_t CLMicroLocationSensorsDriver::stopMotionSession(CLMicroLocationSensorsDriver *this)
{
  (*(void (**)(_QWORD))(**((_QWORD **)this + 23) + 40))(*((_QWORD *)this + 23));
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 24) + 40))(*((_QWORD *)this + 24));
}

uint64_t CLMicroLocationSensorsDriver::setStopDetection(CLMicroLocationSensorsDriver *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 24) + 24))(*((_QWORD *)this + 24));
}

uint64_t CLMicroLocationSensorsDriver::clearStopDetection(CLMicroLocationSensorsDriver *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 24) + 16))(*((_QWORD *)this + 24));
}

uint64_t CLMicroLocationSensorsDriver::startCustomLoiRecordingFence(CLMicroLocationSensorsDriver *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 25) + 16))(*((_QWORD *)this + 25));
}

uint64_t CLMicroLocationSensorsDriver::teardownCustomLoiRecordingFence(CLMicroLocationSensorsDriver *this)
{
  uint64_t result;

  result = *((_QWORD *)this + 25);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 24))(result);
  return result;
}

uint64_t CLMicroLocationSensorsDriver::onRecordingFenceBreach(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 208) + 160))(*(_QWORD *)(a1 + 208));
}

uint64_t `non-virtual thunk to'CLMicroLocationSensorsDriver::onRecordingFenceBreach(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 160) + 160))(*(_QWORD *)(a1 + 160));
}

uint64_t CLMicroLocationSensorsDriver::getWiFiScanExpectedDuration(ULWiFiStrategyBuilder **this, const ULWiFiScanStrategy *a2)
{
  return ULWiFiStrategyBuilder::expectedScanDuration(this[17], a2);
}

void CLMicroLocationSensorsDriver::~CLMicroLocationSensorsDriver(CLMicroLocationSensorsDriver *this)
{
  CLMicroLocationSensorsDriver::~CLMicroLocationSensorsDriver(this);
  JUMPOUT(0x2426A04D4);
}

{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  void *v7;
  void *v8;

  *(_QWORD *)this = &off_2511D2FC0;
  *((_QWORD *)this + 1) = &unk_2511D3088;
  *((_QWORD *)this + 2) = &unk_2511D30B8;
  *((_QWORD *)this + 3) = &unk_2511D30E8;
  *((_QWORD *)this + 4) = &unk_2511D3130;
  *((_QWORD *)this + 5) = &unk_2511D3168;
  *((_QWORD *)this + 6) = &unk_2511D31A0;
  v2 = *((_QWORD *)this + 25);
  *((_QWORD *)this + 25) = 0;
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  v3 = *((_QWORD *)this + 24);
  *((_QWORD *)this + 24) = 0;
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  v4 = *((_QWORD *)this + 23);
  *((_QWORD *)this + 23) = 0;
  if (v4)
    (*(void (**)(uint64_t))(*(_QWORD *)v4 + 8))(v4);

  v5 = *((_QWORD *)this + 20);
  *((_QWORD *)this + 20) = 0;
  if (v5)
    (*(void (**)(uint64_t))(*(_QWORD *)v5 + 8))(v5);
  v6 = *((_QWORD *)this + 19);
  *((_QWORD *)this + 19) = 0;
  if (v6)
    (*(void (**)(uint64_t))(*(_QWORD *)v6 + 8))(v6);

  v7 = (void *)*((_QWORD *)this + 12);
  if (v7)
  {
    *((_QWORD *)this + 13) = v7;
    operator delete(v7);
  }
  v8 = (void *)*((_QWORD *)this + 9);
  if (v8)
  {
    *((_QWORD *)this + 10) = v8;
    operator delete(v8);
  }

}

void `non-virtual thunk to'CLMicroLocationSensorsDriver::~CLMicroLocationSensorsDriver(CLMicroLocationSensorsDriver *this)
{
  CLMicroLocationSensorsDriver::~CLMicroLocationSensorsDriver((CLMicroLocationSensorsDriver *)((char *)this - 8));
}

{
  CLMicroLocationSensorsDriver::~CLMicroLocationSensorsDriver((CLMicroLocationSensorsDriver *)((char *)this - 8));
  JUMPOUT(0x2426A04D4);
}

{
  CLMicroLocationSensorsDriver::~CLMicroLocationSensorsDriver((CLMicroLocationSensorsDriver *)((char *)this - 16));
}

{
  CLMicroLocationSensorsDriver::~CLMicroLocationSensorsDriver((CLMicroLocationSensorsDriver *)((char *)this - 16));
  JUMPOUT(0x2426A04D4);
}

{
  CLMicroLocationSensorsDriver::~CLMicroLocationSensorsDriver((CLMicroLocationSensorsDriver *)((char *)this - 24));
}

{
  CLMicroLocationSensorsDriver::~CLMicroLocationSensorsDriver((CLMicroLocationSensorsDriver *)((char *)this - 24));
  JUMPOUT(0x2426A04D4);
}

{
  CLMicroLocationSensorsDriver::~CLMicroLocationSensorsDriver((CLMicroLocationSensorsDriver *)((char *)this - 32));
}

{
  CLMicroLocationSensorsDriver::~CLMicroLocationSensorsDriver((CLMicroLocationSensorsDriver *)((char *)this - 32));
  JUMPOUT(0x2426A04D4);
}

{
  CLMicroLocationSensorsDriver::~CLMicroLocationSensorsDriver((CLMicroLocationSensorsDriver *)((char *)this - 40));
}

{
  CLMicroLocationSensorsDriver::~CLMicroLocationSensorsDriver((CLMicroLocationSensorsDriver *)((char *)this - 40));
  JUMPOUT(0x2426A04D4);
}

{
  CLMicroLocationSensorsDriver::~CLMicroLocationSensorsDriver((CLMicroLocationSensorsDriver *)((char *)this - 48));
}

{
  CLMicroLocationSensorsDriver::~CLMicroLocationSensorsDriver((CLMicroLocationSensorsDriver *)((char *)this - 48));
  JUMPOUT(0x2426A04D4);
}

void ___ZL45_CLLogObjectForCategory_MicroLocation_Defaultv_block_invoke_5()
{
  os_log_t v0;
  void *v1;

  v0 = os_log_create("com.apple.MicroLocation", "MicroLocation");
  v1 = (void *)logObject_MicroLocation_Default;
  logObject_MicroLocation_Default = (uint64_t)v0;

}

uint64_t std::set<unsigned int>::set[abi:ne180100](uint64_t a1, unsigned int *a2, uint64_t a3)
{
  uint64_t *v4;
  uint64_t v6;

  *(_QWORD *)(a1 + 8) = 0;
  v4 = (uint64_t *)(a1 + 8);
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)a1 = a1 + 8;
  if (a3)
  {
    v6 = 4 * a3;
    do
    {
      std::__tree<unsigned int>::__emplace_hint_unique_key_args<unsigned int,unsigned int const&>((uint64_t **)a1, v4, a2, a2);
      ++a2;
      v6 -= 4;
    }
    while (v6);
  }
  return a1;
}

void sub_241A08ACC(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::__tree<std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>,std::__map_value_compare<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>,std::less<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes>,true>,std::allocator<std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>>>::destroy(v1, *(_QWORD **)(v1 + 8));
  _Unwind_Resume(a1);
}

uint64_t *std::__tree<unsigned int>::__emplace_hint_unique_key_args<unsigned int,unsigned int const&>(uint64_t **a1, uint64_t *a2, unsigned int *a3, _DWORD *a4)
{
  uint64_t *v6;
  uint64_t *v7;
  uint64_t **v8;
  uint64_t v10;
  uint64_t *v11;

  v6 = std::__tree<unsigned int>::__find_equal<unsigned int>(a1, a2, &v11, &v10, a3);
  v7 = (uint64_t *)*v6;
  if (!*v6)
  {
    v8 = (uint64_t **)v6;
    v7 = (uint64_t *)operator new(0x20uLL);
    *((_DWORD *)v7 + 7) = *a4;
    std::__tree<CLMicroLocationRecordingCompletionMetaInformation::RecordingError>::__insert_node_at(a1, (uint64_t)v11, v8, v7);
  }
  return v7;
}

uint64_t *std::__tree<unsigned int>::__find_equal<unsigned int>(_QWORD *a1, uint64_t *a2, uint64_t **a3, uint64_t *a4, unsigned int *a5)
{
  uint64_t *v5;
  unsigned int v6;
  unsigned int v7;
  uint64_t *v8;
  uint64_t *v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t *v12;
  uint64_t *v13;
  BOOL v14;
  unsigned int v15;
  uint64_t v16;
  uint64_t *v17;
  unsigned int v18;
  uint64_t *v19;
  uint64_t v20;
  uint64_t *v21;
  unsigned int v22;

  v5 = a1 + 1;
  if (a1 + 1 == a2 || (v6 = *a5, v7 = *((_DWORD *)a2 + 7), *a5 < v7))
  {
    v8 = (uint64_t *)*a2;
    if ((uint64_t *)*a1 == a2)
    {
      v10 = a2;
LABEL_17:
      if (v8)
      {
        *a3 = v10;
        return v10 + 1;
      }
      else
      {
        *a3 = a2;
        return a2;
      }
    }
    if (v8)
    {
      v9 = (uint64_t *)*a2;
      do
      {
        v10 = v9;
        v9 = (uint64_t *)v9[1];
      }
      while (v9);
    }
    else
    {
      v13 = a2;
      do
      {
        v10 = (uint64_t *)v13[2];
        v14 = *v10 == (_QWORD)v13;
        v13 = v10;
      }
      while (v14);
    }
    v15 = *a5;
    if (*((_DWORD *)v10 + 7) < *a5)
      goto LABEL_17;
    v16 = *v5;
    if (*v5)
    {
      do
      {
        while (1)
        {
          v17 = (uint64_t *)v16;
          v18 = *(_DWORD *)(v16 + 28);
          if (v15 >= v18)
            break;
          v16 = *v17;
          v5 = v17;
          if (!*v17)
            goto LABEL_29;
        }
        if (v18 >= v15)
          break;
        v5 = v17 + 1;
        v16 = v17[1];
      }
      while (v16);
    }
    else
    {
      v17 = a1 + 1;
    }
LABEL_29:
    *a3 = v17;
    return v5;
  }
  if (v7 >= v6)
  {
    *a3 = a2;
    *a4 = (uint64_t)a2;
    return a4;
  }
  v11 = a2[1];
  if (v11)
  {
    v12 = (uint64_t *)a2[1];
    do
    {
      a4 = v12;
      v12 = (uint64_t *)*v12;
    }
    while (v12);
  }
  else
  {
    v19 = a2;
    do
    {
      a4 = (uint64_t *)v19[2];
      v14 = *a4 == (_QWORD)v19;
      v19 = a4;
    }
    while (!v14);
  }
  if (a4 != v5 && v6 >= *((_DWORD *)a4 + 7))
  {
    v20 = *v5;
    if (*v5)
    {
      do
      {
        while (1)
        {
          v21 = (uint64_t *)v20;
          v22 = *(_DWORD *)(v20 + 28);
          if (v6 >= v22)
            break;
          v20 = *v21;
          v5 = v21;
          if (!*v21)
            goto LABEL_48;
        }
        if (v22 >= v6)
          break;
        v5 = v21 + 1;
        v20 = v21[1];
      }
      while (v20);
    }
    else
    {
      v21 = a1 + 1;
    }
LABEL_48:
    *a3 = v21;
    return v5;
  }
  if (v11)
  {
    *a3 = a4;
  }
  else
  {
    *a3 = a2;
    return a2 + 1;
  }
  return a4;
}

CLMicroLocationProto::WiFiRssi *std::__unwrap_and_dispatch[abi:ne180100]<std::__overload<std::__move_loop<std::_ClassicAlgPolicy>,std::__move_trivial>,CLMiLoProtobufWrapper::WiFiRssi *,CLMiLoProtobufWrapper::WiFiRssi *,CLMiLoProtobufWrapper::WiFiRssi *,0>(CLMicroLocationProto::WiFiRssi *a1, CLMicroLocationProto::WiFiRssi *a2, CLMicroLocationProto::WiFiRssi *this)
{
  CLMicroLocationProto::WiFiRssi *v4;
  CLMicroLocationProto::WiFiRssi *v5;

  v4 = a1;
  if (a1 == a2)
    return a1;
  v5 = a2;
  do
  {
    CLMicroLocationProto::WiFiRssi::CopyFrom(this, v4);
    *((_DWORD *)this + 12) = *((_DWORD *)v4 + 12);
    this = (CLMicroLocationProto::WiFiRssi *)((char *)this + 56);
    v4 = (CLMicroLocationProto::WiFiRssi *)((char *)v4 + 56);
  }
  while (v4 != v5);
  return v5;
}

char *std::vector<CLMicroLocationWiFiChannelHistogram>::__assign_with_size[abi:ne180100]<std::__wrap_iter<CLMicroLocationWiFiChannelHistogram*>,std::__wrap_iter<CLMicroLocationWiFiChannelHistogram*>>(char *result, char *__src, uint64_t a3, unint64_t a4)
{
  _QWORD *v7;
  uint64_t v8;
  char *v9;
  uint64_t v10;
  unint64_t v11;
  void **v12;
  char *v13;
  _BYTE *v14;
  unint64_t v15;
  char *v16;
  size_t v17;
  void *v18;
  char *v19;

  v7 = result;
  v8 = *((_QWORD *)result + 2);
  v9 = *(char **)result;
  if (a4 > (v8 - *(_QWORD *)result) >> 3)
  {
    if (v9)
    {
      *((_QWORD *)result + 1) = v9;
      operator delete(v9);
      v8 = 0;
      *v7 = 0;
      v7[1] = 0;
      v7[2] = 0;
    }
    if (a4 >> 61)
      std::vector<CLMicroLocationProto::ConfidenceReason>::__throw_length_error[abi:ne180100]();
    v10 = v8 >> 2;
    if (v8 >> 2 <= a4)
      v10 = a4;
    if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF8)
      v11 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v11 = v10;
    result = std::vector<CLMicroLocationWiFiChannelHistogram>::__vallocate[abi:ne180100](v7, v11);
    v13 = (char *)v7[1];
    v12 = (void **)(v7 + 1);
    v9 = v13;
LABEL_16:
    v17 = a3 - (_QWORD)__src;
    if (v17)
    {
      v18 = v9;
      v19 = __src;
      goto LABEL_18;
    }
    goto LABEL_19;
  }
  v12 = (void **)(result + 8);
  v14 = (_BYTE *)*((_QWORD *)result + 1);
  v15 = (v14 - v9) >> 3;
  if (v15 >= a4)
    goto LABEL_16;
  v16 = &__src[8 * v15];
  if (v14 != v9)
  {
    result = (char *)memmove(*(void **)result, __src, 8 * v15);
    v9 = (char *)*v12;
  }
  v17 = a3 - (_QWORD)v16;
  if (v17)
  {
    v18 = v9;
    v19 = v16;
LABEL_18:
    result = (char *)memmove(v18, v19, v17);
  }
LABEL_19:
  *v12 = &v9[v17];
  return result;
}

double CLMicroLocationFingerprintDistanceFunction::euclideanLike(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  double v4;
  unint64_t v5;

  v4 = COERCE_DOUBLE(CLMicroLocationFingerprintDistanceFunction::computeSumSquaredDifferenceAndNumIntersect(a1, a2, a3, a4));
  if (v5)
    return sqrt(v4 / (double)v5);
  else
    return 1.79769313e308;
}

uint64_t CLMicroLocationFingerprintDistanceFunction::computeSumSquaredDifferenceAndNumIntersect(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  uint64_t v10;
  uint64_t (**v11)();
  __int128 v12;
  uint64_t v13;
  uint64_t (**v14)();
  __int128 v15;
  uint64_t v16;

  v14 = &off_2511D3368;
  __asm { FMOV            V0.2D, #1.0 }
  v15 = _Q0;
  v16 = 0x4008000000000000;
  v12 = _Q0;
  v13 = 0x3FF0000000000000;
  v11 = &off_2511D33B8;
  CLMicroLocationFingerprintDistanceFunction::computeWeightedEuclideanComponentsAndNumItersect(a1, a2, a3, (uint64_t)&v14, (uint64_t)&v11, a4, (uint64_t)&v10);
  return v10;
}

double CLMicroLocationFingerprintDistanceFunction::jaccardLike(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  double *v11;
  uint64_t v12;
  uint64_t v14;

  v8 = *(_QWORD *)a3;
  if (*(_BYTE *)(a3 + 8))
    v8 = (~*(_BYTE *)(a1 + 56) & ~*(_DWORD *)(a2 + 56)) & v8 & 0x7F;
  v14 = v8;
  v9 = *(_QWORD **)(a1 + 16);
  if (v9)
  {
    v10 = 0;
    do
    {
      v11 = (double *)std::__hash_table<CLMicroLocationFingerprint::Measurement,CLMicroLocationFingerprint::Measurement::HashMeasurement,CLMicroLocationFingerprint::Measurement::PredicateMeasurement,std::allocator<CLMicroLocationFingerprint::Measurement>>::find<CLMicroLocationFingerprint::Measurement>((_QWORD *)a2, (uint64_t)(v9 + 2));
      if (v11)
        v10 += CLMicroLocationFingerprintDistanceFunction::shouldAccountMeasurements(&v14, a4, (uint64_t)(v9 + 2), v11[2]);
      v9 = (_QWORD *)*v9;
    }
    while (v9);
  }
  else
  {
    v10 = 0;
  }
  v12 = CLMicroLocationFingerprintDistanceFunction::computeNumUnion(a1, a2, v10, (uint64_t *)a3, a4);
  if (v12)
    return (double)(unint64_t)(v12 - v10) / (double)(unint64_t)v12;
  else
    return 1.79769313e308;
}

uint64_t CLMicroLocationFingerprintDistanceFunction::computeNumUnion(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t a5)
{
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  _QWORD *i;
  uint64_t v14;

  v9 = *a4;
  if (*((_BYTE *)a4 + 8))
    v9 = (~*(_BYTE *)(a1 + 56) & ~*(_DWORD *)(a2 + 56)) & v9 & 0x7F;
  v14 = v9;
  v10 = *(_QWORD **)(a1 + 16);
  if (v10)
  {
    v11 = 0;
    do
    {
      v11 += CLMicroLocationFingerprintDistanceFunction::shouldAccountMeasurements(&v14, a5, (uint64_t)(v10 + 2), *(double *)(a2 + 144));
      v10 = (_QWORD *)*v10;
    }
    while (v10);
  }
  else
  {
    v11 = 0;
  }
  for (i = *(_QWORD **)(a2 + 16); i; i = (_QWORD *)*i)
    v11 += CLMicroLocationFingerprintDistanceFunction::shouldAccountMeasurements(&v14, a5, (uint64_t)(i + 2), *(double *)(a1 + 144));
  return v11 - a3;
}

uint64_t CLMicroLocationFingerprintDistanceFunction::combinedEuclideanJaccard(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  uint64_t v8;

  CLMicroLocationFingerprintDistanceFunction::computeSumSquaredDifferenceAndNumIntersect(a1, a2, a3, a4);
  return CLMicroLocationFingerprintDistanceFunction::computeNumUnion(a1, a2, v8, a3, a4);
}

double CLMicroLocationFingerprintDistanceFunction::weightedEuclideanJaccardDistance(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, double a9, double a10, uint64_t a11)
{
  double v11;
  uint64_t v19;
  _QWORD *v20;
  double v21;
  double v22;
  _QWORD *i;
  double v24;
  double v25;
  NSObject *v27;
  double v28;
  double v29;
  uint64_t v30;
  uint8_t buf[16];

  if (!(*(_QWORD *)(a1 + 24) | *(_QWORD *)(a2 + 24)))
    return 1.79769313e308;
  v11 = a9;
  CLMicroLocationFingerprintDistanceFunction::computeWeightedEuclideanComponentsAndNumItersect(a1, a2, (uint64_t *)a8, a3, a4, a11, (uint64_t)&v28);
  if (!v30)
    return v11;
  v19 = *(_QWORD *)a8;
  if (*(_BYTE *)(a8 + 8))
    v19 = (~*(_BYTE *)(a1 + 56) & ~*(_DWORD *)(a2 + 56)) & v19 & 0x7F;
  *(_QWORD *)buf = v19;
  v20 = *(_QWORD **)(a1 + 16);
  if (v20)
  {
    v21 = 0.0;
    v22 = 0.0;
    do
    {
      if (CLMicroLocationFingerprintDistanceFunction::shouldAccountMeasurements(buf, a11, (uint64_t)(v20 + 2), *(double *)(a2 + 144)))
      {
        if (std::__hash_table<CLMicroLocationFingerprint::Measurement,CLMicroLocationFingerprint::Measurement::HashMeasurement,CLMicroLocationFingerprint::Measurement::PredicateMeasurement,std::allocator<CLMicroLocationFingerprint::Measurement>>::find<CLMicroLocationFingerprint::Measurement>((_QWORD *)a2, (uint64_t)(v20 + 2)))
        {
          v22 = v22 + (*(double (**)(uint64_t, _QWORD *))(*(_QWORD *)a5 + 16))(a5, v20 + 2);
        }
        else
        {
          v21 = v21 + (*(double (**)(uint64_t, _QWORD *))(*(_QWORD *)a6 + 16))(a6, v20 + 2);
        }
      }
      v20 = (_QWORD *)*v20;
    }
    while (v20);
  }
  else
  {
    v22 = 0.0;
    v21 = 0.0;
  }
  for (i = *(_QWORD **)(a2 + 16); i; i = (_QWORD *)*i)
  {
    if (CLMicroLocationFingerprintDistanceFunction::shouldAccountMeasurements(buf, a11, (uint64_t)(i + 2), *(double *)(a1 + 144))&& !std::__hash_table<CLMicroLocationFingerprint::Measurement,CLMicroLocationFingerprint::Measurement::HashMeasurement,CLMicroLocationFingerprint::Measurement::PredicateMeasurement,std::allocator<CLMicroLocationFingerprint::Measurement>>::find<CLMicroLocationFingerprint::Measurement>((_QWORD *)a1, (uint64_t)(i + 2))&& ((*(uint64_t (**)(uint64_t, _QWORD *))(*(_QWORD *)a7 + 16))(a7, i + 2) & 1) == 0)
    {
      v21 = v21 + (*(double (**)(uint64_t, _QWORD *))(*(_QWORD *)a6 + 16))(a6, i + 2);
    }
  }
  if (v29 == 0.0 || (v24 = v22 + v21, v22 + v21 == 0.0))
  {
    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_10);
    v27 = logObject_MicroLocation_Default;
    if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_2419D9000, v27, OS_LOG_TYPE_ERROR, "euclidean denominator or jaccardDenominator are 0, this can only happen if weights are 0, check configuration!", buf, 2u);
    }
    return 1.79769313e308;
  }
  if (a10 <= 0.0 || a10 > 1.0)
    CLMicroLocationFingerprintDistanceFunction::weightedEuclideanJaccardDistance();
  v25 = v29 / (v24 + v29);
  if (a10 < 1.0)
    v25 = fmin(v25 / a10, 1.0);
  return v21 / v24 * v11 * (1.0 - v25) + sqrt(v28 / (double)(unint64_t)v29) * v25;
}

uint64_t CLMicroLocationFingerprintDistanceFunction::computeWeightedEuclideanComponentsAndNumItersect@<X0>(uint64_t result@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X8>)
{
  uint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  double v15;
  double v16;
  uint64_t v17;
  double v18;
  double v19;
  double v20;
  uint64_t v21;

  v12 = *a3;
  if (*((_BYTE *)a3 + 8))
    v12 = (~*(_BYTE *)(result + 56) & ~*(_DWORD *)(a2 + 56)) & v12 & 0x7F;
  v21 = v12;
  v13 = *(uint64_t **)(result + 16);
  if (v13)
  {
    v14 = 0;
    v15 = 0.0;
    v16 = 0.0;
    do
    {
      result = (uint64_t)std::__hash_table<CLMicroLocationFingerprint::Measurement,CLMicroLocationFingerprint::Measurement::HashMeasurement,CLMicroLocationFingerprint::Measurement::PredicateMeasurement,std::allocator<CLMicroLocationFingerprint::Measurement>>::find<CLMicroLocationFingerprint::Measurement>((_QWORD *)a2, (uint64_t)(v13 + 2));
      if (result)
      {
        v17 = result;
        result = CLMicroLocationFingerprintDistanceFunction::shouldAccountMeasurements(&v21, a6, (uint64_t)(v13 + 2), *(double *)(result + 16));
        if ((_DWORD)result)
        {
          v18 = (*(double (**)(uint64_t, uint64_t *))(*(_QWORD *)a5 + 16))(a5, v13 + 2);
          result = (*(uint64_t (**)(uint64_t, uint64_t *))(*(_QWORD *)a4 + 16))(a4, v13 + 2);
          if (*((_DWORD *)v13 + 6) != *(_DWORD *)(v17 + 24))
            CLMicroLocationFingerprintDistanceFunction::computeWeightedEuclideanComponentsAndNumItersect();
          v20 = (float)(*((float *)v13 + 7) - *(float *)(v17 + 28));
          v16 = v16 + v19 * v20 * (v19 * v20) * v18;
          ++v14;
          v15 = v15 + v18;
        }
      }
      v13 = (uint64_t *)*v13;
    }
    while (v13);
  }
  else
  {
    v14 = 0;
    v16 = 0.0;
    v15 = 0.0;
  }
  *(double *)a7 = v16;
  *(double *)(a7 + 8) = v15;
  *(_QWORD *)(a7 + 16) = v14;
  return result;
}

void CLMicroLocationFingerprintDistanceFunction::tanimotoLike(CLMicroLocationFingerprintDistanceFunction *this, const CLMicroLocationFingerprint *a2, const CLMicroLocationFingerprint *a3, long double a4)
{
  float *v7;
  double v8;
  double v9;
  double v10;
  double v11;
  float *v12;
  long double v13;
  float *i;
  long double v15;

  v7 = (float *)*((_QWORD *)this + 2);
  if (v7)
  {
    v8 = 0.0;
    v9 = 0.0;
    v10 = 0.0;
    do
    {
      v11 = pow(a4, v7[7]);
      v12 = (float *)std::__hash_table<CLMicroLocationFingerprint::Measurement,CLMicroLocationFingerprint::Measurement::HashMeasurement,CLMicroLocationFingerprint::Measurement::PredicateMeasurement,std::allocator<CLMicroLocationFingerprint::Measurement>>::find<CLMicroLocationFingerprint::Measurement>(a2, (uint64_t)(v7 + 4));
      if (v12)
      {
        v13 = pow(a4, v12[7]);
        v9 = v9 + v11 * v13;
        v10 = v10 + v13 * v13;
      }
      v8 = v8 + v11 * v11;
      v7 = *(float **)v7;
    }
    while (v7);
  }
  else
  {
    v10 = 0.0;
  }
  for (i = (float *)*((_QWORD *)a2 + 2); i; i = *(float **)i)
  {
    if (!std::__hash_table<CLMicroLocationFingerprint::Measurement,CLMicroLocationFingerprint::Measurement::HashMeasurement,CLMicroLocationFingerprint::Measurement::PredicateMeasurement,std::allocator<CLMicroLocationFingerprint::Measurement>>::find<CLMicroLocationFingerprint::Measurement>(this, (uint64_t)(i + 4)))
    {
      v15 = pow(a4, i[7]);
      v10 = v10 + v15 * v15;
    }
  }
}

void CLMicroLocationUtils::PerSourceWeights<double>::~PerSourceWeights()
{
  JUMPOUT(0x2426A04D4);
}

double CLMicroLocationUtils::PerSourceWeights<double>::operator[](double *a1, uint64_t a2)
{
  int v2;
  double v3;
  NSObject *v4;
  uint8_t v6[16];

  v2 = *(_DWORD *)(a2 + 8);
  switch(v2)
  {
    case 6:
      return a1[3];
    case 5:
      return a1[2];
    case 1:
      return a1[1];
  }
  if (onceToken_MicroLocation_Default != -1)
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_10);
  v4 = logObject_MicroLocation_Default;
  v3 = 0.0;
  if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)v6 = 0;
    _os_log_impl(&dword_2419D9000, v4, OS_LOG_TYPE_ERROR, "Datatype not supported", v6, 2u);
  }
  return v3;
}

void CLMicroLocationUtils::ConstantWeight<double>::~ConstantWeight()
{
  JUMPOUT(0x2426A04D4);
}

BOOL CLMicroLocationFingerprintDistanceFunction::shouldAccountMeasurements(_QWORD *a1, uint64_t a2, uint64_t a3, double a4)
{
  unsigned int v4;
  double v6;

  v6 = a4;
  v4 = *(_DWORD *)(a3 + 8);
  if (v4 >= 7)
    std::__throw_out_of_range[abi:ne180100]("bitset test argument out of range");
  return ((*a1 >> v4) & 1) != 0
      && (!*(_BYTE *)(a2 + 56) || (CLMicroLocationAnchorAppearanceMap::isAnchorValid(a2, a3, &v6) & 1) != 0);
}

void ___ZL45_CLLogObjectForCategory_MicroLocation_Defaultv_block_invoke_6()
{
  os_log_t v0;
  void *v1;

  v0 = os_log_create("com.apple.MicroLocation", "MicroLocation");
  v1 = (void *)logObject_MicroLocation_Default;
  logObject_MicroLocation_Default = (uint64_t)v0;

}

_QWORD *std::__hash_table<CLMicroLocationFingerprint::Measurement,CLMicroLocationFingerprint::Measurement::HashMeasurement,CLMicroLocationFingerprint::Measurement::PredicateMeasurement,std::allocator<CLMicroLocationFingerprint::Measurement>>::find<CLMicroLocationFingerprint::Measurement>(_QWORD *a1, uint64_t a2)
{
  unint64_t v4;
  int8x8_t v5;
  unint64_t v6;
  uint8x8_t v7;
  unint64_t v8;
  unint64_t v9;
  _QWORD *v10;
  _QWORD *v11;
  uint64_t v12;
  unint64_t v13;

  v4 = CLMicroLocationFingerprint::Measurement::HashMeasurement::operator()((uint64_t)(a1 + 3), a2);
  v5 = (int8x8_t)a1[1];
  if (!*(_QWORD *)&v5)
    return 0;
  v6 = v4;
  v7 = (uint8x8_t)vcnt_s8(v5);
  v7.i16[0] = vaddlv_u8(v7);
  v8 = v7.u32[0];
  if (v7.u32[0] > 1uLL)
  {
    v9 = v4;
    if (v4 >= *(_QWORD *)&v5)
      v9 = v4 % *(_QWORD *)&v5;
  }
  else
  {
    v9 = (*(_QWORD *)&v5 - 1) & v4;
  }
  v10 = *(_QWORD **)(*a1 + 8 * v9);
  if (!v10)
    return 0;
  v11 = (_QWORD *)*v10;
  if (*v10)
  {
    v12 = (uint64_t)(a1 + 4);
    do
    {
      v13 = v11[1];
      if (v6 == v13)
      {
        if ((CLMicroLocationFingerprint::Measurement::PredicateMeasurement::operator()(v12, (uint64_t)(v11 + 2), a2) & 1) != 0)
          return v11;
      }
      else
      {
        if (v8 > 1)
        {
          if (v13 >= *(_QWORD *)&v5)
            v13 %= *(_QWORD *)&v5;
        }
        else
        {
          v13 &= *(_QWORD *)&v5 - 1;
        }
        if (v13 != v9)
          return 0;
      }
      v11 = (_QWORD *)*v11;
    }
    while (v11);
  }
  return v11;
}

void sub_241A09CD0(_Unwind_Exception *a1)
{
  id *v1;
  id *v2;
  id *v3;
  id *v4;
  uint64_t v5;

  objc_destroyWeak(v4);
  objc_destroyWeak(v3);
  objc_destroyWeak(v2);
  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v5 - 136));
  _Unwind_Resume(a1);
}

void *CLMacAddress::newFromStrStrict(const std::string *a1)
{
  const std::string *v1;
  std::string::size_type size;
  uint64_t i;
  void *v4;
  uint64_t v5;
  uint64_t v6;
  void *v8[2];
  uint64_t v9;
  uint64_t v10;
  void *__p;
  char v12;
  uint64_t v13;
  void *v14[2];
  char v15;

  if (SHIBYTE(a1->__r_.__value_.__r.__words[2]) < 0)
  {
    size = a1->__r_.__value_.__l.__size_;
    if (!size)
      goto LABEL_15;
    if (size != 12)
      goto LABEL_17;
    v1 = (const std::string *)a1->__r_.__value_.__r.__words[0];
  }
  else
  {
    v1 = a1;
    if (*((_BYTE *)&a1->__r_.__value_.__s + 23) != 12)
    {
      if (*((_BYTE *)&a1->__r_.__value_.__s + 23))
      {
LABEL_17:
        std::string::basic_string[abi:ne180100]<0>(v8, "size");
        v6 = CLMacAddress::newFromMalformedMac();
LABEL_19:
        v4 = (void *)v6;
        goto LABEL_20;
      }
LABEL_15:
      std::string::basic_string[abi:ne180100]<0>(v8, "empty");
      std::string::basic_string[abi:ne180100]<0>(v14, " ");
      v4 = (void *)CLMacAddress::newFromMalformedMac();
      if (v15 < 0)
        operator delete(v14[0]);
LABEL_20:
      if (SHIBYTE(v9) < 0)
        operator delete(v8[0]);
      return v4;
    }
  }
  for (i = 0; i != 12; ++i)
  {
    if (v1->__r_.__value_.__s.__data_[i] < 0
      || (*(_DWORD *)(MEMORY[0x24BDAC740] + 4 * v1->__r_.__value_.__s.__data_[i] + 60) & 0x10000) == 0)
    {
      std::string::basic_string[abi:ne180100]<0>(v8, "nonhex");
      v6 = CLMacAddress::newFromMalformedMac();
      goto LABEL_19;
    }
  }
  v14[0] = 0;
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100](v8, a1, 24);
  *(_DWORD *)((char *)&v8[1] + *((_QWORD *)v8[0] - 3)) = *(_DWORD *)((_BYTE *)&v8[1] + *((_QWORD *)v8[0] - 3)) & 0xFFFFFFB5 | 8;
  MEMORY[0x2426A0324](v8, v14);
  v4 = v14[0];
  v8[0] = *(void **)MEMORY[0x24BEDB7F0];
  v5 = *(_QWORD *)(MEMORY[0x24BEDB7F0] + 72);
  *(void **)((char *)v8 + *((_QWORD *)v8[0] - 3)) = *(void **)(MEMORY[0x24BEDB7F0] + 64);
  v9 = v5;
  v10 = MEMORY[0x24BEDB848] + 16;
  if (v12 < 0)
    operator delete(__p);
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x2426A0444](&v13);
  return v4;
}

void sub_241A0A5C0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream((uint64_t)&__p);
  _Unwind_Resume(a1);
}

uint64_t CLMacAddress::newFromMalformedMac()
{
  uint64_t v0;
  void *__p[2];
  char v3;

  std::string::basic_string[abi:ne180100]<0>(__p, "ff:ff:ff:ff:ff:ff");
  v0 = CLMacAddress::newFromCLStr(__p);
  if (v3 < 0)
    operator delete(__p[0]);
  return v0;
}

void sub_241A0A65C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

_QWORD *std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100](_QWORD *a1, const std::string *a2, int a3)
{
  uint64_t v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;
  std::ios_base *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;

  v5 = MEMORY[0x24BEDB858];
  v6 = MEMORY[0x24BEDB858] + 104;
  a1[16] = MEMORY[0x24BEDB858] + 104;
  a1[2] = v5 + 64;
  v7 = a1 + 2;
  v8 = (uint64_t)(a1 + 3);
  v9 = (_QWORD *)MEMORY[0x24BEDB7F0];
  v10 = *(_QWORD *)(MEMORY[0x24BEDB7F0] + 16);
  v11 = *(_QWORD *)(MEMORY[0x24BEDB7F0] + 24);
  *a1 = v10;
  *(_QWORD *)((char *)a1 + *(_QWORD *)(v10 - 24)) = v11;
  a1[1] = 0;
  v12 = (std::ios_base *)((char *)a1 + *(_QWORD *)(*a1 - 24));
  std::ios_base::init(v12, a1 + 3);
  v12[1].__vftable = 0;
  v12[1].__fmtflags_ = -1;
  v13 = v9[4];
  v14 = v9[5];
  a1[2] = v13;
  *(_QWORD *)((char *)v7 + *(_QWORD *)(v13 - 24)) = v14;
  v15 = v9[1];
  *a1 = v15;
  *(_QWORD *)((char *)a1 + *(_QWORD *)(v15 - 24)) = v9[6];
  *a1 = v5 + 24;
  a1[16] = v6;
  a1[2] = v5 + 64;
  std::stringbuf::basic_stringbuf[abi:ne180100](v8, a2, a3);
  return a1;
}

void sub_241A0A770(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::iostream::~basic_iostream();
  MEMORY[0x2426A0444](v1);
  _Unwind_Resume(a1);
}

uint64_t CLMacAddress::newFromStr(char *a1)
{
  char *v1;
  uint64_t v2;
  uint64_t v3;
  unsigned int v4;
  std::string::value_type v5;
  std::string::size_type size;
  std::string::size_type v7;
  _BOOL4 v8;
  std::string::size_type v9;
  uint64_t v10;
  unint64_t v11;
  std::string *p_str;
  uint64_t v13;
  std::string __p;
  std::string __str;

  v1 = a1;
  if ((a1[23] & 0x80000000) == 0)
  {
    v2 = a1[23];
    if (a1[23])
    {
      memset(&__str, 0, sizeof(__str));
      goto LABEL_6;
    }
LABEL_18:
    std::string::basic_string[abi:ne180100]<0>(&__str, "empty");
    std::string::basic_string[abi:ne180100]<0>(&__p, " ");
    v10 = CLMacAddress::newFromMalformedMac();
    goto LABEL_30;
  }
  v2 = *((_QWORD *)a1 + 1);
  if (!v2)
    goto LABEL_18;
  memset(&__str, 0, sizeof(__str));
  v1 = *(char **)a1;
LABEL_6:
  v3 = MEMORY[0x24BDAC740];
  do
  {
    v4 = *v1;
    if ((v4 & 0x80000000) != 0 || (*(_DWORD *)(v3 + 4 * v4 + 60) & 0x10000) == 0)
    {
      std::string::basic_string[abi:ne180100]<0>(&__p, "nonhex");
      v10 = CLMacAddress::newFromMalformedMac();
      goto LABEL_30;
    }
    v5 = __tolower(v4);
    std::string::push_back(&__str, v5);
    ++v1;
    --v2;
  }
  while (v2);
  size = __str.__r_.__value_.__l.__size_;
  v7 = HIBYTE(__str.__r_.__value_.__r.__words[2]);
  memset(&__p, 0, sizeof(__p));
  if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
    v7 = __str.__r_.__value_.__l.__size_;
  if (v7 > 0xB)
  {
    std::string::operator=(&__p, &__str);
  }
  else
  {
    v8 = (__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0;
    if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      size = HIBYTE(__str.__r_.__value_.__r.__words[2]);
    if (size == 12)
    {
      v9 = 12;
    }
    else
    {
      v11 = 0;
      do
      {
        std::string::push_back(&__p, 48);
        ++v11;
        v8 = (__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0;
        if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v9 = HIBYTE(__str.__r_.__value_.__r.__words[2]);
        else
          v9 = __str.__r_.__value_.__l.__size_;
      }
      while (v11 < 12 - v9);
    }
    if (v8)
      p_str = (std::string *)__str.__r_.__value_.__r.__words[0];
    else
      p_str = &__str;
    std::string::append(&__p, (const std::string::value_type *)p_str, v9);
  }
  v10 = (uint64_t)CLMacAddress::newFromStrStrict(&__p);
LABEL_30:
  v13 = v10;
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__str.__r_.__value_.__l.__data_);
  return v13;
}

void sub_241A0A948(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a14 < 0)
    operator delete(__p);
  if (a20 < 0)
    operator delete(a15);
  _Unwind_Resume(exception_object);
}

uint64_t CLMacAddress::newFromCLStr(uint64_t *a1)
{
  uint64_t v1;
  int v2;
  uint64_t v3;
  char v4;
  int v5;
  int v6;
  int v7;
  uint64_t v8;
  void *__p;
  char v11;
  void *v12[2];
  char v13;

  if (*((char *)a1 + 23) < 0)
  {
    v1 = a1[1];
    if (!v1)
    {
LABEL_24:
      std::string::basic_string[abi:ne180100]<0>(v12, "empty");
      std::string::basic_string[abi:ne180100]<0>(&__p, " ");
      v3 = CLMacAddress::newFromMalformedMac();
      if (v11 < 0)
        operator delete(__p);
LABEL_29:
      if (v13 < 0)
        operator delete(v12[0]);
      return v3;
    }
    a1 = (uint64_t *)*a1;
  }
  else
  {
    v1 = *((unsigned __int8 *)a1 + 23);
    if (!*((_BYTE *)a1 + 23))
      goto LABEL_24;
  }
  v2 = 0;
  v3 = 0;
  v4 = 0;
  v5 = 0;
  do
  {
    v6 = *((char *)a1 + v1 - 1);
    if (v6 == 58)
    {
      ++v5;
      if (v2 == 2)
      {
        v2 = 0;
        goto LABEL_20;
      }
      if (v2 != 1)
      {
        std::string::basic_string[abi:ne180100]<0>(v12, "multibyte");
        v8 = CLMacAddress::newFromMalformedMac();
        goto LABEL_28;
      }
      v2 = 0;
    }
    else
    {
      v7 = v6 - 48;
      if ((v6 - 48) > 9)
      {
        if ((v6 - 65) > 5)
        {
          if ((v6 - 97) > 5)
            goto LABEL_26;
          v7 = v6 - 87;
        }
        else
        {
          v7 = v6 - 55;
        }
      }
      if (v7 == -1)
      {
LABEL_26:
        std::string::basic_string[abi:ne180100]<0>(v12, "nonhex");
        v8 = CLMacAddress::newFromMalformedMac();
        goto LABEL_28;
      }
      v3 += (uint64_t)v7 << v4;
      ++v2;
    }
    v4 += 4;
LABEL_20:
    --v1;
  }
  while (v1);
  if (v5 && v5 != 5)
  {
    std::string::basic_string[abi:ne180100]<0>(v12, "colons");
    v8 = CLMacAddress::newFromMalformedMac();
LABEL_28:
    v3 = v8;
    goto LABEL_29;
  }
  return v3;
}

void sub_241A0AB0C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a20 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

BOOL CLMacAddress::operator==(_QWORD *a1, _QWORD *a2)
{
  return *a1 == *a2;
}

uint64_t CLMacAddress::str(CLMacAddress *this)
{
  uint64_t *v1;
  uint64_t v2;
  uint64_t v3;
  char v5;
  _QWORD v6[2];
  _QWORD v7[11];
  char v8;
  uint64_t v9;

  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)v6);
  v5 = 48;
  v1 = std::operator<<[abi:ne180100]<std::char_traits<char>>(v7, &v5);
  v2 = *v1;
  *(uint64_t *)((char *)v1 + *(_QWORD *)(*v1 - 24) + 24) = 12;
  *(_DWORD *)((char *)v1 + *(_QWORD *)(v2 - 24) + 8) = *(_DWORD *)((_BYTE *)v1 + *(_QWORD *)(v2 - 24) + 8) & 0xFFFFFFB5 | 8;
  std::ostream::operator<<();
  std::stringbuf::str();
  v6[0] = *MEMORY[0x24BEDB7F0];
  v3 = *(_QWORD *)(MEMORY[0x24BEDB7F0] + 72);
  *(_QWORD *)((char *)v6 + *(_QWORD *)(v6[0] - 24)) = *(_QWORD *)(MEMORY[0x24BEDB7F0] + 64);
  v7[0] = v3;
  v7[1] = MEMORY[0x24BEDB848] + 16;
  if (v8 < 0)
    operator delete((void *)v7[9]);
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return MEMORY[0x2426A0444](&v9);
}

void sub_241A0AC58(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream((uint64_t)va);
  _Unwind_Resume(a1);
}

_QWORD *std::operator<<[abi:ne180100]<std::char_traits<char>>(_QWORD *a1, char *a2)
{
  char *v3;
  int v4;
  const std::locale::facet *v5;
  int v6;
  std::locale v8;

  v3 = (char *)a1 + *(_QWORD *)(*a1 - 24);
  v4 = *a2;
  if (*((_DWORD *)v3 + 36) == -1)
  {
    std::ios_base::getloc((const std::ios_base *)((char *)a1 + *(_QWORD *)(*a1 - 24)));
    v5 = std::locale::use_facet(&v8, MEMORY[0x24BEDB350]);
    v6 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v5->__vftable[2].~facet_0)(v5, 32);
    std::locale::~locale(&v8);
    *((_DWORD *)v3 + 36) = v6;
  }
  *((_DWORD *)v3 + 36) = v4;
  return a1;
}

void sub_241A0AD00(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::locale a10)
{
  std::locale::~locale(&a10);
  _Unwind_Resume(a1);
}

void CLMacAddress::toPrettyStr(CLMacAddress *this@<X0>, std::string *a2@<X8>)
{
  char *v3;
  unsigned __int8 v4;
  void **v5;
  void **v6;
  void *__p[2];
  unsigned __int8 v8;

  CLMacAddress::str((uint64_t *)__p, this);
  v3 = 0;
  a2->__r_.__value_.__r.__words[0] = 0;
  a2->__r_.__value_.__l.__size_ = 0;
  a2->__r_.__value_.__r.__words[2] = 0;
  while (1)
  {
    v4 = v8;
    if ((char)v8 < 0)
      break;
    if ((unint64_t)v3 >= v8)
      return;
LABEL_6:
    if (v3)
    {
      std::string::push_back(a2, 58);
      v4 = v8;
    }
    if ((v4 & 0x80u) == 0)
      v5 = __p;
    else
      v5 = (void **)__p[0];
    std::string::push_back(a2, v3[(_QWORD)v5]);
    if ((v8 & 0x80u) == 0)
      v6 = __p;
    else
      v6 = (void **)__p[0];
    std::string::push_back(a2, v3[(_QWORD)v6 + 1]);
    v3 += 2;
  }
  if (v3 < __p[1])
    goto LABEL_6;
  operator delete(__p[0]);
}

void sub_241A0ADDC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  uint64_t v15;

  if (*(char *)(v15 + 23) < 0)
    operator delete(*(void **)v15);
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void CLMacAddress::toCLStr(CLMacAddress *this@<X0>, std::string *a2@<X8>)
{
  unsigned __int8 *v3;
  unsigned __int8 v4;
  void **v5;
  void **v6;
  int v7;
  void **v8;
  void *__p[2];
  unsigned __int8 v10;

  CLMacAddress::str((uint64_t *)__p, this);
  v3 = 0;
  a2->__r_.__value_.__r.__words[0] = 0;
  a2->__r_.__value_.__l.__size_ = 0;
  a2->__r_.__value_.__r.__words[2] = 0;
  while (1)
  {
    v4 = v10;
    if ((char)v10 < 0)
      break;
    if ((unint64_t)v3 >= v10)
      return;
LABEL_6:
    if (v3)
    {
      std::string::push_back(a2, 58);
      v4 = v10;
    }
    v5 = (void **)__p[0];
    if ((v4 & 0x80u) == 0)
      v6 = __p;
    else
      v6 = (void **)__p[0];
    v7 = v3[(_QWORD)v6];
    if (v7 != 48)
    {
      std::string::push_back(a2, v7);
      v4 = v10;
      v5 = (void **)__p[0];
    }
    if ((v4 & 0x80u) == 0)
      v8 = __p;
    else
      v8 = v5;
    std::string::push_back(a2, v3[(_QWORD)v8 + 1]);
    v3 += 2;
  }
  if (v3 < __p[1])
    goto LABEL_6;
  operator delete(__p[0]);
}

void sub_241A0AEE0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  uint64_t v15;

  if (*(char *)(v15 + 23) < 0)
    operator delete(*(void **)v15);
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

unint64_t CLMacAddress::toUint64(CLMacAddress *this)
{
  return this->var0;
}

uint64_t std::stringbuf::basic_stringbuf[abi:ne180100](uint64_t a1, const std::string *a2, int a3)
{
  uint64_t v6;

  v6 = std::streambuf::basic_streambuf();
  *(_QWORD *)v6 = MEMORY[0x24BEDB848] + 16;
  *(_OWORD *)(v6 + 64) = 0u;
  *(_OWORD *)(v6 + 80) = 0u;
  *(_DWORD *)(v6 + 96) = a3;
  std::string::operator=((std::string *)(v6 + 64), a2);
  std::stringbuf::__init_buf_ptrs[abi:ne180100](a1);
  return a1;
}

void sub_241A0AF80(_Unwind_Exception *a1)
{
  uint64_t v1;
  void **v2;

  if (*(char *)(v1 + 87) < 0)
    operator delete(*v2);
  std::streambuf::~streambuf();
  _Unwind_Resume(a1);
}

void std::stringbuf::__init_buf_ptrs[abi:ne180100](uint64_t a1)
{
  std::string *v2;
  char v3;
  std::string *v4;
  unint64_t v5;
  int v6;
  std::string::size_type v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;

  *(_QWORD *)(a1 + 88) = 0;
  v2 = (std::string *)(a1 + 64);
  v3 = *(_BYTE *)(a1 + 87);
  if (v3 < 0)
  {
    v4 = *(std::string **)(a1 + 64);
    v5 = *(_QWORD *)(a1 + 72);
  }
  else
  {
    v4 = v2;
    v5 = *(unsigned __int8 *)(a1 + 87);
  }
  v6 = *(_DWORD *)(a1 + 96);
  if ((v6 & 8) != 0)
  {
    *(_QWORD *)(a1 + 88) = (char *)v4 + v5;
    *(_QWORD *)(a1 + 16) = v4;
    *(_QWORD *)(a1 + 24) = v4;
    *(_QWORD *)(a1 + 32) = (char *)v4 + v5;
  }
  if ((v6 & 0x10) != 0)
  {
    *(_QWORD *)(a1 + 88) = (char *)v4 + v5;
    v7 = v3 < 0 ? (*(_QWORD *)(a1 + 80) & 0x7FFFFFFFFFFFFFFFLL) - 1 : 22;
    std::string::resize(v2, v7, 0);
    v8 = *(char *)(a1 + 87) < 0 ? *(_QWORD *)(a1 + 72) : *(unsigned __int8 *)(a1 + 87);
    *(_QWORD *)(a1 + 40) = v4;
    *(_QWORD *)(a1 + 48) = v4;
    *(_QWORD *)(a1 + 56) = (char *)v4 + v8;
    if ((*(_BYTE *)(a1 + 96) & 3) != 0)
    {
      if (v5 >> 31)
      {
        v9 = ((v5 - 0x80000000) * (unsigned __int128)0x200000005uLL) >> 64;
        v10 = 0x7FFFFFFF * ((v9 + ((v5 - 0x80000000 - v9) >> 1)) >> 30);
        v4 = (std::string *)((char *)v4 + v10 + 0x7FFFFFFF);
        v5 = v5 - v10 - 0x7FFFFFFF;
        *(_QWORD *)(a1 + 48) = v4;
      }
      if (v5)
        *(_QWORD *)(a1 + 48) = (char *)v4 + v5;
    }
  }
}

uint64_t CLMicroLocationNullSpaceAlgorithm::localize@<X0>(CLMicroLocationModel *this@<X1>, uint64_t a2@<X0>, uint64_t a3@<X2>, uint64_t a4@<X3>, id *a5@<X4>, char **a6@<X8>)
{
  _QWORD *v12;
  _QWORD *i;
  uint64_t **v14;
  uint64_t v15;
  CLMicroLocationAlgorithms *v16;
  NSDictionary *v17;
  uint64_t *j;
  double v19;
  double v20;
  _OWORD *v21;
  char *v22;
  char *v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;
  unint64_t v27;
  char *v28;
  char *v29;
  char *v30;
  char *v31;
  char *v32;
  NSObject *v33;
  _OWORD *v34;
  void *p_p;
  uint64_t v36;
  uint64_t v37;
  int v38;
  char *v39;
  char *v40;
  char *v41;
  double v42;
  _QWORD *v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  unint64_t v49;
  char *v50;
  uint64_t v51;
  char *v52;
  char *v53;
  char *v54;
  char *v55;
  __int128 v56;
  double *v57;
  double k;
  _QWORD *v59;
  char *v60;
  double v61;
  uint64_t v62;
  char *v63;
  char *v64;
  char *v65;
  char *v66;
  __int128 v67;
  double *m;
  uint64_t v69;
  uint64_t v70;
  double v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  unint64_t v75;
  char *v76;
  uint64_t v77;
  char *v78;
  char *v79;
  char *v80;
  char *v81;
  __int128 v82;
  uint64_t v83;
  void *__p;
  __int128 v86;
  uint64_t v87;
  void *v88;
  char *v89;
  char *v90;
  __int128 v91;
  __int128 v92;
  int v93;
  _QWORD v94[2];
  uint64_t *v95;
  _BYTE v96[32];
  int v97;
  uint8_t buf[8];
  __int16 v99;
  const char *v100;
  __int16 v101;
  void *v102;
  __int16 v103;
  uint64_t v104;
  __int16 v105;
  double v106;
  __int16 v107;
  uint64_t v108;
  uint64_t v109;

  v109 = *MEMORY[0x24BDAC8D0];
  if (!CLMicroLocationModel::isValid(this))
  {
    CLMicroLocationNullSpaceAlgorithm::localize();
    goto LABEL_85;
  }
  if (!*(_BYTE *)(a4 + 32))
  {
    CLMicroLocationNullSpaceAlgorithm::localize();
LABEL_85:
    __break(1u);
  }
  memset(v96, 0, sizeof(v96));
  v97 = 1065353216;
  v12 = (_QWORD *)*((_QWORD *)this + 41);
  for (i = (_QWORD *)*((_QWORD *)this + 42); v12 != i; v12 += 4)
  {
    *(_QWORD *)buf = v12 + 2;
    v14 = (uint64_t **)std::__hash_table<std::__hash_value_type<boost::uuids::uuid,std::multiset<double>>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::multiset<double>>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::multiset<double>>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,std::multiset<double>>>>::__emplace_unique_key_args<boost::uuids::uuid,std::piecewise_construct_t const&,std::tuple<boost::uuids::uuid const&>,std::tuple<>>((uint64_t)v96, v12 + 2, (uint64_t)&std::piecewise_construct, (_OWORD **)buf);
    v15 = *(_QWORD *)(a4 + 24);
    if (!v15)
      std::__throw_bad_function_call[abi:ne180100]();
    *(_QWORD *)buf = (*(double (**)(uint64_t, _QWORD, uint64_t))(*(_QWORD *)v15 + 48))(v15, *v12, a3);
    std::__tree<double>::__emplace_multi<double>(v14 + 4, (double *)buf);
  }
  (*(void (**)(_QWORD *__return_ptr, uint64_t, _BYTE *, id *))(*(_QWORD *)a2 + 24))(v94, a2, v96, a5);
  v91 = 0u;
  v92 = 0u;
  v93 = 1065353216;
  v88 = 0;
  v89 = 0;
  v90 = 0;
  CLMicroLocationLocalizationSettings::getKernelFuncSettings(a5);
  v16 = (CLMicroLocationAlgorithms *)objc_claimAutoreleasedReturnValue();
  CLMicroLocationAlgorithms::createKernelFunction(v16, v17);

  for (j = v95; j; j = (uint64_t *)*j)
  {
    v19 = (*(double (**)(uint64_t, double))(*(_QWORD *)v87 + 24))(v87, *((double *)j + 4));
    v20 = v19;
    v21 = j + 2;
    if (v19 >= 0.0)
    {
      if (v19 >= 0.999)
      {
        v22 = v89;
        if (v89 >= v90)
        {
          v24 = (v89 - (_BYTE *)v88) >> 4;
          v25 = v24 + 1;
          if ((unint64_t)(v24 + 1) >> 60)
            std::vector<CLMicroLocationProto::ConfidenceReason>::__throw_length_error[abi:ne180100]();
          v26 = v90 - (_BYTE *)v88;
          if ((v90 - (_BYTE *)v88) >> 3 > v25)
            v25 = v26 >> 3;
          if ((unint64_t)v26 >= 0x7FFFFFFFFFFFFFF0)
            v27 = 0xFFFFFFFFFFFFFFFLL;
          else
            v27 = v25;
          if (v27)
            v28 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<boost::uuids::uuid>>((uint64_t)&v90, v27);
          else
            v28 = 0;
          v29 = &v28[16 * v24];
          *(_OWORD *)v29 = *v21;
          v31 = (char *)v88;
          v30 = v89;
          v32 = v29;
          if (v89 != v88)
          {
            do
            {
              *((_OWORD *)v32 - 1) = *((_OWORD *)v30 - 1);
              v32 -= 16;
              v30 -= 16;
            }
            while (v30 != v31);
            v30 = (char *)v88;
          }
          v23 = v29 + 16;
          v88 = v32;
          v89 = v29 + 16;
          v90 = &v28[16 * v27];
          if (v30)
            operator delete(v30);
        }
        else
        {
          *(_OWORD *)v89 = *v21;
          v23 = v22 + 16;
        }
        v89 = v23;
      }
      else
      {
        *(_QWORD *)buf = j + 2;
        *((double *)std::__hash_table<std::__hash_value_type<boost::uuids::uuid,double>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,double>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,double>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,double>>>::__emplace_unique_key_args<boost::uuids::uuid,std::piecewise_construct_t const&,std::tuple<boost::uuids::uuid const&>,std::tuple<>>((uint64_t)&v91, j + 2, (uint64_t)&std::piecewise_construct, (_OWORD **)buf)+ 4) = v19 / (1.0 - v19);
      }
    }
    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_12);
    v33 = (id)logObject_MicroLocation_Default;
    if (os_log_type_enabled(v33, OS_LOG_TYPE_DEBUG))
    {
      v34 = operator new(0x28uLL);
      __p = v34;
      v86 = xmmword_241BB2320;
      *v34 = 0u;
      v34[1] = 0u;
      *(_QWORD *)((char *)v34 + 29) = 0;
      boost::uuids::to_chars<char *>((uint64_t)(j + 2), v34);
      p_p = &__p;
      if (v86 < 0)
        p_p = __p;
      v37 = j[4];
      v36 = j[5];
      *(_QWORD *)buf = 68290051;
      v99 = 2082;
      v100 = "";
      v101 = 2081;
      v102 = p_p;
      v103 = 2049;
      v104 = v36;
      v105 = 2049;
      v106 = v20;
      v107 = 2049;
      v108 = v37;
      _os_log_impl(&dword_2419D9000, v33, OS_LOG_TYPE_DEBUG, "{\"msg%{public}.0s\":\"nullspace\", \"identifier\":%{private, location:escape_only}s, \"weight\":\"%{private}f\", \"phat\":\"%{private}f\", \"reducedDistance\":\"%{private}f\"}", buf, 0x3Au);
      if (SHIBYTE(v86) < 0)
        operator delete(__p);
    }

  }
  v38 = *(_DWORD *)(a3 + 160);
  a6[1] = 0;
  a6[2] = 0;
  *a6 = 0;
  *((_DWORD *)a6 + 6) = 3;
  *((_BYTE *)a6 + 80) = 0;
  a6[5] = 0;
  a6[6] = 0;
  a6[4] = 0;
  *((_BYTE *)a6 + 56) = 0;
  v39 = (char *)v88;
  v40 = v89;
  if (v88 == v89)
  {
    v57 = (double *)v92;
    for (k = 1.0; v57; v57 = *(double **)v57)
      k = k + v57[4];
    v59 = a6 + 2;
    v60 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<CLMicroLocationResultInternal>>((uint64_t)(a6 + 2), 1uLL);
    v61 = 1.0 / k;
    v63 = &v60[32 * v62];
    *(_QWORD *)v60 = 0;
    *((_QWORD *)v60 + 1) = 0;
    *((double *)v60 + 2) = 1.0 / k;
    *((_DWORD *)v60 + 6) = v38;
    v64 = v60 + 32;
    v66 = *a6;
    v65 = a6[1];
    if (v65 != *a6)
    {
      do
      {
        v67 = *((_OWORD *)v65 - 2);
        *(_OWORD *)(v60 - 20) = *(_OWORD *)(v65 - 20);
        *((_OWORD *)v60 - 2) = v67;
        v60 -= 32;
        v65 -= 32;
      }
      while (v65 != v66);
      v65 = *a6;
    }
    *a6 = v60;
    a6[1] = v64;
    a6[2] = v63;
    if (v65)
      operator delete(v65);
    a6[1] = v64;
    for (m = (double *)v92; m; m = *(double **)m)
    {
      v70 = *((_QWORD *)m + 2);
      v69 = *((_QWORD *)m + 3);
      v71 = v61 * m[4];
      if ((unint64_t)v64 >= *v59)
      {
        v72 = (v64 - *a6) >> 5;
        if ((unint64_t)(v72 + 1) >> 59)
          std::vector<CLMicroLocationProto::ConfidenceReason>::__throw_length_error[abi:ne180100]();
        v73 = *v59 - (_QWORD)*a6;
        v74 = v73 >> 4;
        if (v73 >> 4 <= (unint64_t)(v72 + 1))
          v74 = v72 + 1;
        if ((unint64_t)v73 >= 0x7FFFFFFFFFFFFFE0)
          v75 = 0x7FFFFFFFFFFFFFFLL;
        else
          v75 = v74;
        v76 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<CLMicroLocationResultInternal>>((uint64_t)(a6 + 2), v75);
        v78 = &v76[32 * v72];
        *(_QWORD *)v78 = v70;
        *((_QWORD *)v78 + 1) = v69;
        *((double *)v78 + 2) = v71;
        *((_DWORD *)v78 + 6) = v38;
        v80 = *a6;
        v79 = a6[1];
        v81 = v78;
        if (v79 != *a6)
        {
          do
          {
            v82 = *((_OWORD *)v79 - 2);
            *(_OWORD *)(v81 - 20) = *(_OWORD *)(v79 - 20);
            *((_OWORD *)v81 - 2) = v82;
            v81 -= 32;
            v79 -= 32;
          }
          while (v79 != v80);
          v79 = *a6;
        }
        v64 = v78 + 32;
        *a6 = v81;
        a6[1] = v78 + 32;
        a6[2] = &v76[32 * v77];
        if (v79)
          operator delete(v79);
      }
      else
      {
        *(_QWORD *)v64 = v70;
        *((_QWORD *)v64 + 1) = v69;
        *((double *)v64 + 2) = v71;
        *((_DWORD *)v64 + 6) = v38;
        v64 += 32;
      }
      a6[1] = v64;
    }
  }
  else
  {
    v41 = 0;
    v42 = 1.0 / (double)(unint64_t)((v89 - (_BYTE *)v88) >> 4);
    v43 = a6 + 2;
    do
    {
      v45 = *(_QWORD *)v39;
      v44 = *((_QWORD *)v39 + 1);
      if ((unint64_t)v41 >= *v43)
      {
        v46 = (v41 - *a6) >> 5;
        if ((unint64_t)(v46 + 1) >> 59)
          std::vector<CLMicroLocationProto::ConfidenceReason>::__throw_length_error[abi:ne180100]();
        v47 = *v43 - (_QWORD)*a6;
        v48 = v47 >> 4;
        if (v47 >> 4 <= (unint64_t)(v46 + 1))
          v48 = v46 + 1;
        if ((unint64_t)v47 >= 0x7FFFFFFFFFFFFFE0)
          v49 = 0x7FFFFFFFFFFFFFFLL;
        else
          v49 = v48;
        v50 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<CLMicroLocationResultInternal>>((uint64_t)(a6 + 2), v49);
        v52 = &v50[32 * v46];
        *(_QWORD *)v52 = v45;
        *((_QWORD *)v52 + 1) = v44;
        *((double *)v52 + 2) = v42;
        *((_DWORD *)v52 + 6) = v38;
        v54 = *a6;
        v53 = a6[1];
        v55 = v52;
        if (v53 != *a6)
        {
          do
          {
            v56 = *((_OWORD *)v53 - 2);
            *(_OWORD *)(v55 - 20) = *(_OWORD *)(v53 - 20);
            *((_OWORD *)v55 - 2) = v56;
            v55 -= 32;
            v53 -= 32;
          }
          while (v53 != v54);
          v53 = *a6;
        }
        v41 = v52 + 32;
        *a6 = v55;
        a6[1] = v52 + 32;
        a6[2] = &v50[32 * v51];
        if (v53)
          operator delete(v53);
      }
      else
      {
        *(_QWORD *)v41 = v45;
        *((_QWORD *)v41 + 1) = v44;
        *((double *)v41 + 2) = v42;
        *((_DWORD *)v41 + 6) = v38;
        v41 += 32;
      }
      a6[1] = v41;
      v39 += 16;
    }
    while (v39 != v40);
  }
  v83 = v87;
  v87 = 0;
  if (v83)
    (*(void (**)(uint64_t))(*(_QWORD *)v83 + 8))(v83);
  if (v88)
  {
    v89 = (char *)v88;
    operator delete(v88);
  }
  std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>>>::~__hash_table((uint64_t)&v91);
  std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>>>::~__hash_table((uint64_t)v94);
  return std::__hash_table<std::__hash_value_type<boost::uuids::uuid,std::multiset<double>>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::multiset<double>>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::multiset<double>>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,std::multiset<double>>>>::~__hash_table((uint64_t)v96);
}

void sub_241A0B7B8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21,uint64_t a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,char a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,char a33)
{
  CLMicroLocationAlgorithms::LocalizerResults *v33;

  CLMicroLocationAlgorithms::LocalizerResults::~LocalizerResults(v33);
  if (a19)
    (*(void (**)(uint64_t))(*(_QWORD *)a19 + 8))(a19);
  if (__p)
    operator delete(__p);
  std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>>>::~__hash_table((uint64_t)&a23);
  std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>>>::~__hash_table((uint64_t)&a28);
  std::__hash_table<std::__hash_value_type<boost::uuids::uuid,std::multiset<double>>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::multiset<double>>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::multiset<double>>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,std::multiset<double>>>>::~__hash_table((uint64_t)&a33);
  _Unwind_Resume(a1);
}

_QWORD *CLMicroLocationNullSpaceAlgorithm::createReducedDistancesMap@<X0>(CLMicroLocationLocalizationSettings *this@<X2>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  _QWORD *v6;
  unint64_t v7;
  double MinPercentileForReducerFunction;
  double MaxPercentileForReducerFunction;
  void *v10;
  void *v11;
  void *v12;
  void *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t *i;
  double v17;
  unint64_t v18;
  double *v19;
  _QWORD *result;
  uint64_t v21;
  _QWORD *v22[3];
  _OWORD *v23;
  _BYTE v24[24];
  _BYTE *v25;
  uint64_t v26;

  v26 = *MEMORY[0x24BDAC8D0];
  v6 = *(_QWORD **)(a2 + 16);
  if (v6)
  {
    v7 = 0;
    do
    {
      v7 += v6[6];
      v6 = (_QWORD *)*v6;
    }
    while (v6);
  }
  else
  {
    v7 = 0;
  }
  MinPercentileForReducerFunction = CLMicroLocationLocalizationSettings::getMinPercentileForReducerFunction(this);
  MaxPercentileForReducerFunction = CLMicroLocationLocalizationSettings::getMaxPercentileForReducerFunction(this);
  +[ULDefaultsSingleton shared](ULDefaultsSingleton, "shared");
  v10 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v10, "defaultsDictionary");
  v11 = (void *)objc_claimAutoreleasedReturnValue();

  objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "ULNullSpaceDistanceReductionFunction");
  v12 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v11, "objectForKey:", v12);
  v13 = (void *)objc_claimAutoreleasedReturnValue();
  if (v13 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
    v14 = objc_msgSend(v13, "unsignedIntValue");
  else
    v14 = objc_msgSend(&unk_2511ED438, "unsignedIntValue");
  v15 = v14;

  CLMicroLocationAlgorithms::createReducerFunction<std::multiset<double>,double>(v15, 0, (uint64_t)v24, MinPercentileForReducerFunction, MaxPercentileForReducerFunction);
  *(_OWORD *)a3 = 0u;
  *(_OWORD *)(a3 + 16) = 0u;
  *(_DWORD *)(a3 + 32) = 1065353216;
  for (i = *(uint64_t **)(a2 + 16); i; i = (uint64_t *)*i)
  {
    std::multiset<double>::multiset[abi:ne180100]((uint64_t)v22, (uint64_t)(i + 4));
    if (!v25)
      std::__throw_bad_function_call[abi:ne180100]();
    v17 = (*(double (**)(_BYTE *, _QWORD **))(*(_QWORD *)v25 + 48))(v25, v22);
    v18 = i[6];
    v23 = i + 2;
    v19 = (double *)std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationNullSpaceAlgorithm::ReducedDistanceAndWeight>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationNullSpaceAlgorithm::ReducedDistanceAndWeight>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationNullSpaceAlgorithm::ReducedDistanceAndWeight>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationNullSpaceAlgorithm::ReducedDistanceAndWeight>>>::__emplace_unique_key_args<boost::uuids::uuid,std::piecewise_construct_t const&,std::tuple<boost::uuids::uuid const&>,std::tuple<>>(a3, i + 2, (uint64_t)&std::piecewise_construct, &v23);
    v19[4] = v17;
    v19[5] = (double)v18 / (double)v7;
    std::__tree<std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>,std::__map_value_compare<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>,std::less<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes>,true>,std::allocator<std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>>>::destroy((uint64_t)v22, v22[1]);
  }
  result = v25;
  if (v25 == v24)
  {
    v21 = 4;
    result = v24;
  }
  else
  {
    if (!v25)
      return result;
    v21 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v21))();
}

void sub_241A0BAE0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

uint64_t CLMicroLocationAlgorithms::createReducerFunction<std::multiset<double>,double>@<X0>(uint64_t result@<X0>, int a2@<W1>, uint64_t a3@<X8>, double a4@<D0>, double a5@<D1>)
{
  void *v5;

  switch((int)result)
  {
    case 0:
      if (a2 == 1)
      {
        v5 = CLReducerFunction<std::multiset<double>,double>::minimumValue;
      }
      else if (a2)
      {
LABEL_5:
        v5 = CLReducerFunction<std::multiset<double>,double>::meanValue;
      }
      else
      {
        v5 = CLReducerFunction<std::multiset<double>,double>::minimumValueSorted;
      }
      goto LABEL_23;
    case 1:
      goto LABEL_5;
    case 2:
      if (a2 == 1)
      {
        v5 = CLReducerFunction<std::multiset<double>,double>::maximumValue;
      }
      else
      {
        if (a2)
          goto LABEL_17;
        v5 = CLReducerFunction<std::multiset<double>,double>::maximumValueSorted;
      }
      goto LABEL_23;
    case 3:
      if (!a2)
      {
        v5 = CLReducerFunction<std::multiset<double>,double>::firstQuartileValueSorted;
LABEL_23:
        *(_QWORD *)a3 = &unk_2511D3520;
        *(_QWORD *)(a3 + 8) = v5;
        goto LABEL_24;
      }
      if (a2 != 1)
      {
LABEL_17:
        *(_QWORD *)(a3 + 24) = 0;
        return result;
      }
      result = CLMicroLocationAlgorithms::createReducerFunction<std::multiset<double>,double>();
LABEL_12:
      if (!a2)
      {
        v5 = CLReducerFunction<std::multiset<double>,double>::medianValueSorted;
        goto LABEL_23;
      }
      if (a2 != 1)
        goto LABEL_17;
      result = CLMicroLocationAlgorithms::createReducerFunction<std::multiset<double>,double>();
LABEL_15:
      if (a2)
      {
        if (a2 == 1)
        {
LABEL_27:
          CLMicroLocationAlgorithms::createReducerFunction<std::multiset<double>,double>();
          JUMPOUT(0x241A0BCC4);
        }
        goto LABEL_17;
      }
      *(_QWORD *)a3 = &off_2511D35D0;
      *(double *)(a3 + 8) = a4;
      *(double *)(a3 + 16) = a5;
LABEL_24:
      *(_QWORD *)(a3 + 24) = a3;
      return result;
    case 4:
      goto LABEL_12;
    case 5:
      goto LABEL_15;
    default:
      CLMicroLocationAlgorithms::createReducerFunction<std::multiset<double>,double>();
      goto LABEL_27;
  }
}

void CLMicroLocationNullSpaceAlgorithm::~CLMicroLocationNullSpaceAlgorithm(CLMicroLocationNullSpaceAlgorithm *this)
{
  JUMPOUT(0x2426A04D4);
}

void ___ZL45_CLLogObjectForCategory_MicroLocation_Defaultv_block_invoke_7()
{
  os_log_t v0;
  void *v1;

  v0 = os_log_create("com.apple.MicroLocation", "MicroLocation");
  v1 = (void *)logObject_MicroLocation_Default;
  logObject_MicroLocation_Default = (uint64_t)v0;

}

uint64_t std::__hash_table<std::__hash_value_type<boost::uuids::uuid,std::multiset<double>>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::multiset<double>>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::multiset<double>>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,std::multiset<double>>>>::~__hash_table(uint64_t a1)
{
  void *v2;

  std::__hash_table<std::__hash_value_type<boost::uuids::uuid,std::multiset<double>>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::multiset<double>>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::multiset<double>>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,std::multiset<double>>>>::__deallocate_node(a1, *(_QWORD ***)(a1 + 16));
  v2 = *(void **)a1;
  *(_QWORD *)a1 = 0;
  if (v2)
    operator delete(v2);
  return a1;
}

void std::__hash_table<std::__hash_value_type<boost::uuids::uuid,std::multiset<double>>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::multiset<double>>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::multiset<double>>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,std::multiset<double>>>>::__deallocate_node(uint64_t a1, _QWORD **a2)
{
  _QWORD **v2;
  _QWORD *v3;

  if (a2)
  {
    v2 = a2;
    do
    {
      v3 = *v2;
      std::__tree<std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>,std::__map_value_compare<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>,std::less<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes>,true>,std::allocator<std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>>>::destroy((uint64_t)(v2 + 4), v2[5]);
      operator delete(v2);
      v2 = (_QWORD **)v3;
    }
    while (v3);
  }
}

_QWORD *std::__hash_table<std::__hash_value_type<boost::uuids::uuid,std::multiset<double>>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::multiset<double>>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::multiset<double>>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,std::multiset<double>>>>::__emplace_unique_key_args<boost::uuids::uuid,std::piecewise_construct_t const&,std::tuple<boost::uuids::uuid const&>,std::tuple<>>(uint64_t a1, _QWORD *a2, uint64_t a3, _OWORD **a4)
{
  unint64_t v4;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint8x8_t v10;
  _QWORD **v11;
  _QWORD *i;
  unint64_t v13;
  _QWORD *v15;
  float v16;
  float v17;
  _BOOL8 v18;
  unint64_t v19;
  unint64_t v20;
  size_t v21;
  uint64_t v22;
  _QWORD *v23;
  unint64_t v24;

  v7 = 0;
  v8 = 0;
  do
    v8 ^= (v8 << 6) + (v8 >> 2) + 2654435769u + *((unsigned __int8 *)a2 + v7++);
  while (v7 != 16);
  v9 = *(_QWORD *)(a1 + 8);
  if (v9)
  {
    v10 = (uint8x8_t)vcnt_s8((int8x8_t)v9);
    v10.i16[0] = vaddlv_u8(v10);
    if (v10.u32[0] > 1uLL)
    {
      v4 = v8;
      if (v8 >= v9)
        v4 = v8 % v9;
    }
    else
    {
      v4 = (v9 - 1) & v8;
    }
    v11 = *(_QWORD ***)(*(_QWORD *)a1 + 8 * v4);
    if (v11)
    {
      for (i = *v11; i; i = (_QWORD *)*i)
      {
        v13 = i[1];
        if (v13 == v8)
        {
          if (i[2] == *a2 && i[3] == a2[1])
            return i;
        }
        else
        {
          if (v10.u32[0] > 1uLL)
          {
            if (v13 >= v9)
              v13 %= v9;
          }
          else
          {
            v13 &= v9 - 1;
          }
          if (v13 != v4)
            break;
        }
      }
    }
  }
  v15 = (_QWORD *)(a1 + 16);
  i = operator new(0x38uLL);
  *i = 0;
  i[1] = v8;
  *((_OWORD *)i + 1) = **a4;
  i[6] = 0;
  i[5] = 0;
  i[4] = i + 5;
  v16 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v17 = *(float *)(a1 + 32);
  if (!v9 || (float)(v17 * (float)v9) < v16)
  {
    v18 = 1;
    if (v9 >= 3)
      v18 = (v9 & (v9 - 1)) != 0;
    v19 = v18 | (2 * v9);
    v20 = vcvtps_u32_f32(v16 / v17);
    if (v19 <= v20)
      v21 = v20;
    else
      v21 = v19;
    std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>>>::__rehash<true>(a1, v21);
    v9 = *(_QWORD *)(a1 + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v8 >= v9)
        v4 = v8 % v9;
      else
        v4 = v8;
    }
    else
    {
      v4 = (v9 - 1) & v8;
    }
  }
  v22 = *(_QWORD *)a1;
  v23 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v4);
  if (v23)
  {
    *i = *v23;
LABEL_44:
    *v23 = i;
    goto LABEL_45;
  }
  *i = *v15;
  *v15 = i;
  *(_QWORD *)(v22 + 8 * v4) = v15;
  if (*i)
  {
    v24 = *(_QWORD *)(*i + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v24 >= v9)
        v24 %= v9;
    }
    else
    {
      v24 &= v9 - 1;
    }
    v23 = (_QWORD *)(*(_QWORD *)a1 + 8 * v24);
    goto LABEL_44;
  }
LABEL_45:
  ++*(_QWORD *)(a1 + 24);
  return i;
}

void sub_241A0BFF8(_Unwind_Exception *a1)
{
  _QWORD **v1;
  uint64_t v2;

  std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<boost::uuids::uuid,std::multiset<double>>,void *>>>::operator()[abi:ne180100](v2, v1);
  _Unwind_Resume(a1);
}

void std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<boost::uuids::uuid,std::multiset<double>>,void *>>>::operator()[abi:ne180100](uint64_t a1, _QWORD **a2)
{
  if (*(_BYTE *)(a1 + 8))
  {
    std::__tree<std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>,std::__map_value_compare<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>,std::less<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes>,true>,std::allocator<std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>>>::destroy((uint64_t)(a2 + 4), a2[5]);
  }
  else if (!a2)
  {
    return;
  }
  operator delete(a2);
}

uint64_t *std::__tree<double>::__emplace_multi<double>(uint64_t **a1, double *a2)
{
  uint64_t *v4;
  double v5;
  uint64_t **v6;
  uint64_t *v7;
  uint64_t **v8;

  v4 = (uint64_t *)operator new(0x28uLL);
  v5 = *a2;
  v4[4] = *(_QWORD *)a2;
  v6 = a1 + 1;
  v7 = a1[1];
  if (v7)
  {
    do
    {
      while (1)
      {
        v6 = (uint64_t **)v7;
        if (v5 >= *((double *)v7 + 4))
          break;
        v7 = (uint64_t *)*v7;
        v8 = v6;
        if (!*v6)
          goto LABEL_8;
      }
      v7 = (uint64_t *)v7[1];
    }
    while (v7);
    v8 = v6 + 1;
  }
  else
  {
    v8 = a1 + 1;
  }
LABEL_8:
  std::__tree<CLMicroLocationRecordingCompletionMetaInformation::RecordingError>::__insert_node_at(a1, (uint64_t)v6, v8, v4);
  return v4;
}

_QWORD *std::__hash_table<std::__hash_value_type<boost::uuids::uuid,double>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,double>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,double>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,double>>>::__emplace_unique_key_args<boost::uuids::uuid,std::piecewise_construct_t const&,std::tuple<boost::uuids::uuid const&>,std::tuple<>>(uint64_t a1, _QWORD *a2, uint64_t a3, _OWORD **a4)
{
  unint64_t v4;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint8x8_t v10;
  _QWORD **v11;
  _QWORD *i;
  unint64_t v13;
  float v15;
  float v16;
  _BOOL8 v17;
  unint64_t v18;
  unint64_t v19;
  size_t v20;
  uint64_t v21;
  _QWORD *v22;
  unint64_t v23;

  v7 = 0;
  v8 = 0;
  do
    v8 ^= (v8 << 6) + (v8 >> 2) + 2654435769u + *((unsigned __int8 *)a2 + v7++);
  while (v7 != 16);
  v9 = *(_QWORD *)(a1 + 8);
  if (v9)
  {
    v10 = (uint8x8_t)vcnt_s8((int8x8_t)v9);
    v10.i16[0] = vaddlv_u8(v10);
    if (v10.u32[0] > 1uLL)
    {
      v4 = v8;
      if (v8 >= v9)
        v4 = v8 % v9;
    }
    else
    {
      v4 = (v9 - 1) & v8;
    }
    v11 = *(_QWORD ***)(*(_QWORD *)a1 + 8 * v4);
    if (v11)
    {
      for (i = *v11; i; i = (_QWORD *)*i)
      {
        v13 = i[1];
        if (v13 == v8)
        {
          if (i[2] == *a2 && i[3] == a2[1])
            return i;
        }
        else
        {
          if (v10.u32[0] > 1uLL)
          {
            if (v13 >= v9)
              v13 %= v9;
          }
          else
          {
            v13 &= v9 - 1;
          }
          if (v13 != v4)
            break;
        }
      }
    }
  }
  i = operator new(0x28uLL);
  *i = 0;
  i[1] = v8;
  *((_OWORD *)i + 1) = **a4;
  i[4] = 0;
  v15 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v16 = *(float *)(a1 + 32);
  if (!v9 || (float)(v16 * (float)v9) < v15)
  {
    v17 = 1;
    if (v9 >= 3)
      v17 = (v9 & (v9 - 1)) != 0;
    v18 = v17 | (2 * v9);
    v19 = vcvtps_u32_f32(v15 / v16);
    if (v18 <= v19)
      v20 = v19;
    else
      v20 = v18;
    std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>>>::__rehash<true>(a1, v20);
    v9 = *(_QWORD *)(a1 + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v8 >= v9)
        v4 = v8 % v9;
      else
        v4 = v8;
    }
    else
    {
      v4 = (v9 - 1) & v8;
    }
  }
  v21 = *(_QWORD *)a1;
  v22 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v4);
  if (v22)
  {
    *i = *v22;
LABEL_44:
    *v22 = i;
    goto LABEL_45;
  }
  *i = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = i;
  *(_QWORD *)(v21 + 8 * v4) = a1 + 16;
  if (*i)
  {
    v23 = *(_QWORD *)(*i + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v23 >= v9)
        v23 %= v9;
    }
    else
    {
      v23 &= v9 - 1;
    }
    v22 = (_QWORD *)(*(_QWORD *)a1 + 8 * v23);
    goto LABEL_44;
  }
LABEL_45:
  ++*(_QWORD *)(a1 + 24);
  return i;
}

void sub_241A0C32C(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

double CLReducerFunction<std::multiset<double>,double>::minimumValueSorted(_QWORD *a1)
{
  if (!a1[2])
    CLReducerFunction<std::multiset<double>,double>::minimumValueSorted();
  return *(double *)(*a1 + 32);
}

double CLReducerFunction<std::multiset<double>,double>::minimumValue(_QWORD *a1)
{
  double *v1;
  double *v2;
  double *v3;
  double *v4;
  double *v5;
  double *v6;
  BOOL v7;

  if (!a1[2])
    CLReducerFunction<std::multiset<double>,double>::minimumValue();
  v3 = (double *)*a1;
  v1 = (double *)(a1 + 1);
  v2 = v3;
  if (v3 != v1)
  {
    v4 = v2;
    while (1)
    {
      v5 = (double *)*((_QWORD *)v4 + 1);
      v6 = v4;
      if (v5)
      {
        do
        {
          v4 = v5;
          v5 = *(double **)v5;
        }
        while (v5);
      }
      else
      {
        do
        {
          v4 = (double *)*((_QWORD *)v6 + 2);
          v7 = *(_QWORD *)v4 == (_QWORD)v6;
          v6 = v4;
        }
        while (!v7);
      }
      if (v4 == v1)
        break;
      if (v4[4] < v2[4])
        v2 = v4;
    }
  }
  return v2[4];
}

double CLReducerFunction<std::multiset<double>,double>::meanValue(_QWORD *a1)
{
  unint64_t v1;
  _QWORD *v2;
  _QWORD *v3;
  _QWORD *v4;
  double v5;
  _QWORD *v6;
  _QWORD *v7;
  _QWORD *v8;
  BOOL v9;

  v1 = a1[2];
  if (!v1)
    CLReducerFunction<std::multiset<double>,double>::meanValue();
  v4 = (_QWORD *)*a1;
  v2 = a1 + 1;
  v3 = v4;
  v5 = 0.0;
  if (v4 != v2)
  {
    do
    {
      v6 = (_QWORD *)v3[1];
      v7 = v3;
      if (v6)
      {
        do
        {
          v8 = v6;
          v6 = (_QWORD *)*v6;
        }
        while (v6);
      }
      else
      {
        do
        {
          v8 = (_QWORD *)v7[2];
          v9 = *v8 == (_QWORD)v7;
          v7 = v8;
        }
        while (!v9);
      }
      v5 = v5 + *((double *)v3 + 4);
      v3 = v8;
    }
    while (v8 != v2);
  }
  return v5 / (double)v1;
}

double CLReducerFunction<std::multiset<double>,double>::maximumValueSorted(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  BOOL v5;

  if (!*(_QWORD *)(a1 + 16))
    CLReducerFunction<std::multiset<double>,double>::maximumValueSorted();
  v3 = *(_QWORD *)(a1 + 8);
  v1 = a1 + 8;
  v2 = v3;
  if (v3)
  {
    do
    {
      v4 = v2;
      v2 = *(_QWORD *)(v2 + 8);
    }
    while (v2);
  }
  else
  {
    do
    {
      v4 = *(_QWORD *)(v1 + 16);
      v5 = *(_QWORD *)v4 == v1;
      v1 = v4;
    }
    while (v5);
  }
  return *(double *)(v4 + 32);
}

double CLReducerFunction<std::multiset<double>,double>::maximumValue(_QWORD *a1)
{
  double *v1;
  double *v2;
  double *v3;
  double *v4;
  double *v5;
  double *v6;
  BOOL v7;

  if (!a1[2])
    CLReducerFunction<std::multiset<double>,double>::maximumValue();
  v3 = (double *)*a1;
  v1 = (double *)(a1 + 1);
  v2 = v3;
  if (v3 != v1)
  {
    v4 = v2;
    while (1)
    {
      v5 = (double *)*((_QWORD *)v4 + 1);
      v6 = v4;
      if (v5)
      {
        do
        {
          v4 = v5;
          v5 = *(double **)v5;
        }
        while (v5);
      }
      else
      {
        do
        {
          v4 = (double *)*((_QWORD *)v6 + 2);
          v7 = *(_QWORD *)v4 == (_QWORD)v6;
          v6 = v4;
        }
        while (!v7);
      }
      if (v4 == v1)
        break;
      if (v2[4] < v4[4])
        v2 = v4;
    }
  }
  return v2[4];
}

double CLReducerFunction<std::multiset<double>,double>::firstQuartileValueSorted(uint64_t a1)
{
  unint64_t v1;
  double *v3;

  v1 = *(_QWORD *)(a1 + 16);
  if (!v1)
    CLReducerFunction<std::multiset<double>,double>::firstQuartileValueSorted();
  v3 = *(double **)a1;
  std::__advance[abi:ne180100]<std::__tree_const_iterator<double,std::__tree_node<double,void *> *,long>>((_QWORD **)&v3, llround((double)v1 * 0.25));
  return v3[4];
}

double CLReducerFunction<std::multiset<double>,double>::medianValueSorted(uint64_t a1)
{
  unint64_t v1;
  double *v3;

  v1 = *(_QWORD *)(a1 + 16);
  if (!v1)
    CLReducerFunction<std::multiset<double>,double>::medianValueSorted();
  v3 = *(double **)a1;
  std::__advance[abi:ne180100]<std::__tree_const_iterator<double,std::__tree_node<double,void *> *,long>>((_QWORD **)&v3, llround((double)v1 * 0.5));
  return v3[4];
}

void std::__function::__func<double (*)(std::multiset<double> const&),std::allocator<double (*)(std::multiset<double> const&)>,double ()(std::multiset<double>)>::~__func()
{
  JUMPOUT(0x2426A04D4);
}

_QWORD *std::__function::__func<double (*)(std::multiset<double> const&),std::allocator<double (*)(std::multiset<double> const&)>,double ()(std::multiset<double>)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &unk_2511D3520;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<double (*)(std::multiset<double> const&),std::allocator<double (*)(std::multiset<double> const&)>,double ()(std::multiset<double>)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &unk_2511D3520;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<double (*)(std::multiset<double> const&),std::allocator<double (*)(std::multiset<double> const&)>,double ()(std::multiset<double>)>::operator()(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t))(a1 + 8))(a2);
}

uint64_t std::__function::__func<double (*)(std::multiset<double> const&),std::allocator<double (*)(std::multiset<double> const&)>,double ()(std::multiset<double>)>::target(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else
    return 0;
}

void *std::__function::__func<double (*)(std::multiset<double> const&),std::allocator<double (*)(std::multiset<double> const&)>,double ()(std::multiset<double>)>::target_type()
{
}

BOOL std::type_info::operator==[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;

  v2 = *(_QWORD *)(a1 + 8);
  v3 = *(_QWORD *)(a2 + 8);
  if (v2 == v3)
    return 1;
  if ((v3 & v2) < 0 != __OFSUB__(v2, v3))
    return strcmp((const char *)(v2 & 0x7FFFFFFFFFFFFFFFLL), (const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL)) == 0;
  return 0;
}

_QWORD **std::__advance[abi:ne180100]<std::__tree_const_iterator<double,std::__tree_node<double,void *> *,long>>(_QWORD **result, uint64_t a2)
{
  _QWORD *v2;
  _QWORD *v3;
  _QWORD *v4;
  BOOL v5;
  _QWORD *v7;
  _QWORD *v8;

  if (a2 < 0)
  {
    v7 = *result;
    do
    {
      v8 = (_QWORD *)*v7;
      if (*v7)
      {
        do
        {
          v4 = v8;
          v8 = (_QWORD *)v8[1];
        }
        while (v8);
      }
      else
      {
        do
        {
          v4 = (_QWORD *)v7[2];
          v5 = *v4 == (_QWORD)v7;
          v7 = v4;
        }
        while (v5);
      }
      v7 = v4;
    }
    while (!__CFADD__(a2++, 1));
  }
  else
  {
    if (!a2)
      return result;
    v2 = *result;
    do
    {
      v3 = (_QWORD *)v2[1];
      if (v3)
      {
        do
        {
          v4 = v3;
          v3 = (_QWORD *)*v3;
        }
        while (v3);
      }
      else
      {
        do
        {
          v4 = (_QWORD *)v2[2];
          v5 = *v4 == (_QWORD)v2;
          v2 = v4;
        }
        while (!v5);
      }
      v2 = v4;
    }
    while (a2-- > 1);
  }
  *result = v4;
  return result;
}

void std::__function::__func<std::function<double ()(std::multiset<double>)> CLMicroLocationAlgorithms::createReducerFunction<std::multiset<double>,double>(CLMicroLocationAlgorithms::ReducerFunctionType,CLMicroLocationAlgorithms::SortedContainer,double,double)::{lambda(std::multiset<double> const&)#1},std::allocator<std::function<double ()(std::multiset<double>)> CLMicroLocationAlgorithms::createReducerFunction<std::multiset<double>,double>(CLMicroLocationAlgorithms::ReducerFunctionType,CLMicroLocationAlgorithms::SortedContainer,double,double)::{lambda(std::multiset<double> const&)#1}>,double ()(std::multiset<double>)>::~__func()
{
  JUMPOUT(0x2426A04D4);
}

__n128 std::__function::__func<std::function<double ()(std::multiset<double>)> CLMicroLocationAlgorithms::createReducerFunction<std::multiset<double>,double>(CLMicroLocationAlgorithms::ReducerFunctionType,CLMicroLocationAlgorithms::SortedContainer,double,double)::{lambda(std::multiset<double> const&)#1},std::allocator<std::function<double ()(std::multiset<double>)> CLMicroLocationAlgorithms::createReducerFunction<std::multiset<double>,double>(CLMicroLocationAlgorithms::ReducerFunctionType,CLMicroLocationAlgorithms::SortedContainer,double,double)::{lambda(std::multiset<double> const&)#1}>,double ()(std::multiset<double>)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x18uLL);
  *(_QWORD *)v2 = &off_2511D35D0;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 std::__function::__func<std::function<double ()(std::multiset<double>)> CLMicroLocationAlgorithms::createReducerFunction<std::multiset<double>,double>(CLMicroLocationAlgorithms::ReducerFunctionType,CLMicroLocationAlgorithms::SortedContainer,double,double)::{lambda(std::multiset<double> const&)#1},std::allocator<std::function<double ()(std::multiset<double>)> CLMicroLocationAlgorithms::createReducerFunction<std::multiset<double>,double>(CLMicroLocationAlgorithms::ReducerFunctionType,CLMicroLocationAlgorithms::SortedContainer,double,double)::{lambda(std::multiset<double> const&)#1}>,double ()(std::multiset<double>)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_2511D35D0;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

double std::__function::__func<std::function<double ()(std::multiset<double>)> CLMicroLocationAlgorithms::createReducerFunction<std::multiset<double>,double>(CLMicroLocationAlgorithms::ReducerFunctionType,CLMicroLocationAlgorithms::SortedContainer,double,double)::{lambda(std::multiset<double> const&)#1},std::allocator<std::function<double ()(std::multiset<double>)> CLMicroLocationAlgorithms::createReducerFunction<std::multiset<double>,double>(CLMicroLocationAlgorithms::ReducerFunctionType,CLMicroLocationAlgorithms::SortedContainer,double,double)::{lambda(std::multiset<double> const&)#1}>,double ()(std::multiset<double>)>::operator()(uint64_t a1, uint64_t a2)
{
  return CLReducerFunction<std::multiset<double>,double>::parameterizedTruncatedMeanValueSorted(a2, *(double *)(a1 + 8), *(double *)(a1 + 16));
}

uint64_t std::__function::__func<std::function<double ()(std::multiset<double>)> CLMicroLocationAlgorithms::createReducerFunction<std::multiset<double>,double>(CLMicroLocationAlgorithms::ReducerFunctionType,CLMicroLocationAlgorithms::SortedContainer,double,double)::{lambda(std::multiset<double> const&)#1},std::allocator<std::function<double ()(std::multiset<double>)> CLMicroLocationAlgorithms::createReducerFunction<std::multiset<double>,double>(CLMicroLocationAlgorithms::ReducerFunctionType,CLMicroLocationAlgorithms::SortedContainer,double,double)::{lambda(std::multiset<double> const&)#1}>,double ()(std::multiset<double>)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<std::function<double ()(std::multiset<double>)> CLMicroLocationAlgorithms::createReducerFunction<std::multiset<double>,double>(CLMicroLocationAlgorithms::ReducerFunctionType,CLMicroLocationAlgorithms::SortedContainer,double,double)::{lambda(std::multiset<double> const&)#1},std::allocator<std::function<double ()(std::multiset<double>)> CLMicroLocationAlgorithms::createReducerFunction<std::multiset<double>,double>(CLMicroLocationAlgorithms::ReducerFunctionType,CLMicroLocationAlgorithms::SortedContainer,double,double)::{lambda(std::multiset<double> const&)#1}>,double ()(std::multiset<double>)>::target_type()
{
}

double CLReducerFunction<std::multiset<double>,double>::parameterizedTruncatedMeanValueSorted(uint64_t a1, double a2, double a3)
{
  unint64_t v3;
  BOOL v4;
  BOOL v5;
  uint64_t v6;
  int64_t v7;
  uint64_t v8;
  double *v9;
  double v10;
  double *v11;
  double *v12;
  double *v13;
  BOOL v14;
  double *v16;

  v3 = *(_QWORD *)(a1 + 16);
  if (!v3)
    CLReducerFunction<std::multiset<double>,double>::parameterizedTruncatedMeanValueSorted();
  if (a3 > 1.0 || (a2 >= 0.0 ? (v4 = a2 > 1.0) : (v4 = 1), !v4 ? (v5 = a3 < a2) : (v5 = 1), v5))
    CLReducerFunction<std::multiset<double>,double>::parameterizedTruncatedMeanValueSorted();
  v6 = llround(floor((double)v3 * a2));
  v7 = llround(ceil((double)v3 * a3));
  v8 = v7 - v6;
  if (v7 <= v6)
    CLReducerFunction<std::multiset<double>,double>::parameterizedTruncatedMeanValueSorted();
  v16 = *(double **)a1;
  std::__advance[abi:ne180100]<std::__tree_const_iterator<double,std::__tree_node<double,void *> *,long>>((_QWORD **)&v16, v6);
  v9 = v16;
  std::__advance[abi:ne180100]<std::__tree_const_iterator<double,std::__tree_node<double,void *> *,long>>((_QWORD **)&v16, v8);
  v10 = 0.0;
  if (v9 != v16)
  {
    do
    {
      v11 = (double *)*((_QWORD *)v9 + 1);
      v12 = v9;
      if (v11)
      {
        do
        {
          v13 = v11;
          v11 = *(double **)v11;
        }
        while (v11);
      }
      else
      {
        do
        {
          v13 = (double *)*((_QWORD *)v12 + 2);
          v14 = *(_QWORD *)v13 == (_QWORD)v12;
          v12 = v13;
        }
        while (!v14);
      }
      v10 = v10 + v9[4];
      v9 = v13;
    }
    while (v13 != v16);
  }
  return v10 / (double)v8;
}

_QWORD *std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationNullSpaceAlgorithm::ReducedDistanceAndWeight>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationNullSpaceAlgorithm::ReducedDistanceAndWeight>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationNullSpaceAlgorithm::ReducedDistanceAndWeight>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationNullSpaceAlgorithm::ReducedDistanceAndWeight>>>::__emplace_unique_key_args<boost::uuids::uuid,std::piecewise_construct_t const&,std::tuple<boost::uuids::uuid const&>,std::tuple<>>(uint64_t a1, _QWORD *a2, uint64_t a3, _OWORD **a4)
{
  unint64_t v4;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint8x8_t v10;
  _QWORD **v11;
  _QWORD *i;
  unint64_t v13;
  float v15;
  float v16;
  _BOOL8 v17;
  unint64_t v18;
  unint64_t v19;
  size_t v20;
  uint64_t v21;
  _QWORD *v22;
  unint64_t v23;

  v7 = 0;
  v8 = 0;
  do
    v8 ^= (v8 << 6) + (v8 >> 2) + 2654435769u + *((unsigned __int8 *)a2 + v7++);
  while (v7 != 16);
  v9 = *(_QWORD *)(a1 + 8);
  if (v9)
  {
    v10 = (uint8x8_t)vcnt_s8((int8x8_t)v9);
    v10.i16[0] = vaddlv_u8(v10);
    if (v10.u32[0] > 1uLL)
    {
      v4 = v8;
      if (v8 >= v9)
        v4 = v8 % v9;
    }
    else
    {
      v4 = (v9 - 1) & v8;
    }
    v11 = *(_QWORD ***)(*(_QWORD *)a1 + 8 * v4);
    if (v11)
    {
      for (i = *v11; i; i = (_QWORD *)*i)
      {
        v13 = i[1];
        if (v13 == v8)
        {
          if (i[2] == *a2 && i[3] == a2[1])
            return i;
        }
        else
        {
          if (v10.u32[0] > 1uLL)
          {
            if (v13 >= v9)
              v13 %= v9;
          }
          else
          {
            v13 &= v9 - 1;
          }
          if (v13 != v4)
            break;
        }
      }
    }
  }
  i = operator new(0x30uLL);
  *i = 0;
  i[1] = v8;
  *((_OWORD *)i + 1) = **a4;
  i[4] = 0;
  i[5] = 0;
  v15 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v16 = *(float *)(a1 + 32);
  if (!v9 || (float)(v16 * (float)v9) < v15)
  {
    v17 = 1;
    if (v9 >= 3)
      v17 = (v9 & (v9 - 1)) != 0;
    v18 = v17 | (2 * v9);
    v19 = vcvtps_u32_f32(v15 / v16);
    if (v18 <= v19)
      v20 = v19;
    else
      v20 = v18;
    std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>>>::__rehash<true>(a1, v20);
    v9 = *(_QWORD *)(a1 + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v8 >= v9)
        v4 = v8 % v9;
      else
        v4 = v8;
    }
    else
    {
      v4 = (v9 - 1) & v8;
    }
  }
  v21 = *(_QWORD *)a1;
  v22 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v4);
  if (v22)
  {
    *i = *v22;
LABEL_44:
    *v22 = i;
    goto LABEL_45;
  }
  *i = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = i;
  *(_QWORD *)(v21 + 8 * v4) = a1 + 16;
  if (*i)
  {
    v23 = *(_QWORD *)(*i + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v23 >= v9)
        v23 %= v9;
    }
    else
    {
      v23 &= v9 - 1;
    }
    v22 = (_QWORD *)(*(_QWORD *)a1 + 8 * v23);
    goto LABEL_44;
  }
LABEL_45:
  ++*(_QWORD *)(a1 + 24);
  return i;
}

void sub_241A0CB50(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t std::multiset<double>::multiset[abi:ne180100](uint64_t a1, uint64_t a2)
{
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)a1 = a1 + 8;
  std::multiset<double>::insert[abi:ne180100]<std::__tree_const_iterator<double,std::__tree_node<double,void *> *,long>>((char *)a1, *(_QWORD **)a2, (_QWORD *)(a2 + 8));
  return a1;
}

void sub_241A0CBA0(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::__tree<std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>,std::__map_value_compare<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>,std::less<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes>,true>,std::allocator<std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>>>::destroy(v1, *(_QWORD **)(v1 + 8));
  _Unwind_Resume(a1);
}

char *std::multiset<double>::insert[abi:ne180100]<std::__tree_const_iterator<double,std::__tree_node<double,void *> *,long>>(char *result, _QWORD *a2, _QWORD *a3)
{
  _QWORD *v4;
  uint64_t **v5;
  double *v6;
  _QWORD *v7;
  _QWORD *v8;
  BOOL v9;

  if (a2 != a3)
  {
    v4 = a2;
    v5 = (uint64_t **)result;
    v6 = (double *)(result + 8);
    do
    {
      result = (char *)std::__tree<double>::__emplace_hint_multi<double const&>(v5, v6, v4 + 4);
      v7 = (_QWORD *)v4[1];
      if (v7)
      {
        do
        {
          v8 = v7;
          v7 = (_QWORD *)*v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          v8 = (_QWORD *)v4[2];
          v9 = *v8 == (_QWORD)v4;
          v4 = v8;
        }
        while (!v9);
      }
      v4 = v8;
    }
    while (v8 != a3);
  }
  return result;
}

void *std::__tree<double>::__emplace_hint_multi<double const&>(uint64_t **a1, double *a2, _QWORD *a3)
{
  void *v6;
  double *leaf;
  double *v9;

  v6 = operator new(0x28uLL);
  *((_QWORD *)v6 + 4) = *a3;
  leaf = std::__tree<std::__value_type<double,std::pair<boost::uuids::uuid const,boost::uuids::uuid>>,std::__map_value_compare<double,std::__value_type<double,std::pair<boost::uuids::uuid const,boost::uuids::uuid>>,std::less<double>,true>,std::allocator<std::__value_type<double,std::pair<boost::uuids::uuid const,boost::uuids::uuid>>>>::__find_leaf(a1, a2, &v9, (double *)v6 + 4);
  std::__tree<CLMicroLocationRecordingCompletionMetaInformation::RecordingError>::__insert_node_at(a1, (uint64_t)v9, (uint64_t **)leaf, (uint64_t *)v6);
  return v6;
}

void sub_241A0CCAC(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

void CLMicroLocationLegacyEventDisplayState::handleEvent(_BYTE *a1@<X0>, char a2@<W1>, double *a3@<X2>, _BYTE *a4@<X8>)
{
  _QWORD *v7;
  _BYTE v8[144];
  char v9;
  _BYTE v10[144];
  _BYTE v11[8];
  _QWORD *v12;
  int v13;

  *a1 = a2;
  CLMicroLocationProto::BacklightOn::BacklightOn((CLMicroLocationProto::BacklightOn *)v11);
  v13 |= 2u;
  if (v12 == (_QWORD *)MEMORY[0x24BEDD958])
  {
    v7 = (_QWORD *)operator new();
    *v7 = 0;
    v7[1] = 0;
    v7[2] = 0;
    v12 = v7;
  }
  MEMORY[0x2426A02C4]();
  CLMicroLocationProtobufHelper::createRecordingEvent<CLMicroLocationProto::BacklightOn>((CLMicroLocationProto::RecordingEvent *)v11, 0, 0, 0, (CLMicroLocationProto *)3, (uint64_t)v8, *a3);
  v9 = a2;
  CLMicroLocationProto::RecordingEvent::RecordingEvent((CLMicroLocationProto::RecordingEvent *)v10, (const CLMicroLocationProto::RecordingEvent *)v8);
  *a4 = v9;
  CLMicroLocationProto::RecordingEvent::RecordingEvent((CLMicroLocationProto::RecordingEvent *)(a4 + 8), (const CLMicroLocationProto::RecordingEvent *)v10);
  CLMicroLocationProto::RecordingEvent::~RecordingEvent((CLMicroLocationProto::RecordingEvent *)v10);
  CLMicroLocationProto::RecordingEvent::~RecordingEvent((CLMicroLocationProto::RecordingEvent *)v8);
  CLMicroLocationProto::BacklightOn::~BacklightOn((CLMicroLocationProto::BacklightOn *)v11);
}

void sub_241A0CE08(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  CLMicroLocationProto::RecordingEvent *v10;
  uint64_t v11;

  CLMicroLocationProto::RecordingEvent::~RecordingEvent(v10);
  CLMicroLocationProto::RecordingEvent::~RecordingEvent((CLMicroLocationProto::RecordingEvent *)&a10);
  CLMicroLocationProto::BacklightOn::~BacklightOn((CLMicroLocationProto::BacklightOn *)(v11 - 80));
  _Unwind_Resume(a1);
}

void CLMicroLocationProtobufHelper::createRecordingEvent<CLMicroLocationProto::BacklightOn>(CLMicroLocationProto::RecordingEvent *a1@<X0>, CLMicroLocationProto *a2@<X1>, char a3@<W2>, char a4@<W3>, CLMicroLocationProto *a5@<X4>, uint64_t a6@<X8>, double a7@<D0>)
{
  unsigned int v14;
  int v15;
  const CLMicroLocationProto::BacklightOn *v16;
  const char *v17;
  int v18;
  const char *v19;

  CLMicroLocationProto::RecordingEvent::RecordingEvent((CLMicroLocationProto::RecordingEvent *)a6);
  v14 = *((_DWORD *)a1 + 4);
  if (!CLMicroLocationProto::EventType_IsValid((CLMicroLocationProto *)v14))
  {
    v17 = "::CLMicroLocationProto::EventType_IsValid(value)";
    v18 = 20192;
    v19 = "set_eventtype";
    goto LABEL_10;
  }
  v15 = *(_DWORD *)(a6 + 140);
  *(_DWORD *)(a6 + 72) = v14;
  *(double *)(a6 + 8) = a7;
  *(_BYTE *)(a6 + 77) = a3;
  *(_DWORD *)(a6 + 140) = v15 | 0x2803;
  *(_BYTE *)(a6 + 76) = a4;
  if (!CLMicroLocationProto::ConfidenceLevel_IsValid(a5))
  {
    v17 = "::CLMicroLocationProto::ConfidenceLevel_IsValid(value)";
    v18 = 20701;
    v19 = "set_confidencelevel";
    goto LABEL_10;
  }
  *(_DWORD *)(a6 + 140) |= 0x4000u;
  *(_DWORD *)(a6 + 120) = (_DWORD)a5;
  if (((unint64_t)a2 & 0xFF00000000) != 0)
  {
    if (CLMicroLocationProto::MotionState_IsValid(a2))
    {
      *(_DWORD *)(a6 + 140) |= 0x20000u;
      *(_DWORD *)(a6 + 124) = (_DWORD)a2;
      goto LABEL_6;
    }
    v17 = "::CLMicroLocationProto::MotionState_IsValid(value)";
    v18 = 20793;
    v19 = "set_motionstate";
LABEL_10:
    __assert_rtn(v19, "microlocation.pb.h", v18, v17);
  }
LABEL_6:
  CLMicroLocationProtobufHelper::setSpecificRecordingEvent((CLMicroLocationProtobufHelper *)a6, a1, v16);
}

void sub_241A0CF6C(_Unwind_Exception *a1)
{
  CLMicroLocationProto::RecordingEvent *v1;

  CLMicroLocationProto::RecordingEvent::~RecordingEvent(v1);
  _Unwind_Resume(a1);
}

uint64_t CLMicroLocationLegacyEventDisplayState::getDisplayState(CLMicroLocationLegacyEventDisplayState *this)
{
  return *(unsigned __int8 *)this;
}

void CLMicroLocationClusterRFDistance::evaluateRFClusterDistances(uint64_t a1@<X1>, float *a2@<X8>)
{
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  int v8;
  int v9;
  void *v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  void *v14;
  unint64_t v15;
  float v16;
  float v17;
  float v18;
  float v19;
  float v20;
  float v21;
  unint64_t v22;
  double v23;
  float v24;
  unint64_t v25;
  unint64_t v26;
  unint64_t v27;
  double v28;
  float v29;
  float v30;
  _QWORD *v31;
  uint64_t v32;
  unint64_t v33;
  void *v34;
  void *v35;
  __int128 v36;
  char v37;
  _BYTE v38[24];
  _BYTE *v39;
  _QWORD v40[3];
  _QWORD *v41;
  uint64_t v42;

  v42 = *MEMORY[0x24BDAC8D0];
  +[ULDefaultsSingleton shared](ULDefaultsSingleton, "shared");
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v4, "defaultsDictionary");
  v5 = (void *)objc_claimAutoreleasedReturnValue();

  objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "ULFingerprintDistanceFunctionType");
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v5, "objectForKey:", v6);
  v7 = (void *)objc_claimAutoreleasedReturnValue();
  if (v7 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
    v8 = objc_msgSend(v7, "unsignedIntValue");
  else
    v8 = objc_msgSend(&unk_2511ED450, "unsignedIntValue");
  v9 = v8;

  ULSettings::getFingerprintDistanceFunctionParamsForType(v9);
  v10 = (void *)objc_claimAutoreleasedReturnValue();
  std::unordered_map<boost::uuids::uuid,CLMicroLocationAnchorAppearance>::unordered_map((uint64_t)&v33, a1 + 16);
  v36 = *(_OWORD *)(a1 + 56);
  v37 = 1;
  CLMicroLocationAlgorithms::createLearnFingerprintDistanceFunction(v9, v10);
  if (v37)
    std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>>>::~__hash_table((uint64_t)&v33);
  v11 = (uint64_t)v41;
  if (!v41)
    goto LABEL_10;
  if (v41 != v40)
  {
    v11 = (*(uint64_t (**)(void))(*v41 + 16))();
LABEL_10:
    v39 = (_BYTE *)v11;
    goto LABEL_12;
  }
  v39 = v38;
  (*(void (**)(_QWORD *, _BYTE *))(v40[0] + 24))(v40, v38);
LABEL_12:
  CLMicroLocationModel::getClusterPairwiseDistances((_QWORD *)a1, (uint64_t)v38, &v33);
  v12 = v39;
  if (v39 == v38)
  {
    v13 = 4;
    v12 = v38;
  }
  else
  {
    if (!v39)
      goto LABEL_17;
    v13 = 5;
  }
  (*(void (**)(void))(*v12 + 8 * v13))();
LABEL_17:
  v14 = v34;
  if (v33)
  {
    v15 = 0;
    v16 = 0.0;
    v17 = 3.4028e38;
    v18 = 1.1755e-38;
    v19 = 3.4028e38;
    v20 = 1.1755e-38;
    v21 = 0.0;
    do
    {
      v22 = v15 + 1;
      v23 = *((double *)v34 + v15 + (((v15 + 1) * v15) >> 1));
      v24 = v23;
      if (v23 > v18)
        v18 = v23;
      if (v23 < v17)
        v17 = v23;
      v25 = v15 + 1;
      if (v22 < v33)
      {
        do
        {
          if (v15 <= v25)
            v26 = v25;
          else
            v26 = v15;
          if (v15 >= v25)
            v27 = v25;
          else
            v27 = v15;
          v28 = *((double *)v34 + v27 + ((v26 + v26 * v26) >> 1));
          v29 = v28;
          v16 = v16 + v29;
          if (v28 > v20)
            v20 = v28;
          if (v28 < v19)
            v19 = v28;
          ++v25;
        }
        while (v33 != v25);
      }
      ++v15;
      v21 = (float)(v21 + v24) / (float)v33;
    }
    while (v22 != v33);
  }
  else
  {
    v21 = 0.0;
    v19 = 3.4028e38;
    v20 = 1.1755e-38;
    v16 = 0.0;
    v17 = 3.4028e38;
    v18 = 1.1755e-38;
  }
  v30 = (float)(((v33 - 1) * v33) >> 1);
  *a2 = v17;
  a2[1] = v18;
  a2[2] = v21;
  a2[3] = v19;
  a2[4] = v20;
  a2[5] = v16 / v30;
  if (v14)
  {
    v35 = v14;
    operator delete(v14);
  }
  v31 = v41;
  if (v41 == v40)
  {
    v32 = 4;
    v31 = v40;
    goto LABEL_44;
  }
  if (v41)
  {
    v32 = 5;
LABEL_44:
    (*(void (**)(void))(*v31 + 8 * v32))();
  }

}

void sub_241A0D2B0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_241A0D458(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

uint64_t ULDBUtils::insertEntries<CLMiLoLoiTable,ULLoiMO>(void *a1, uint64_t a2)
{
  id v3;
  void *v4;
  id v5;
  uint64_t v6;
  _QWORD v8[4];
  id v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  char v15;

  v3 = a1;
  v12 = 0;
  v13 = &v12;
  v14 = 0x2020000000;
  v15 = 0;
  objc_msgSend(v3, "managedObjectContext");
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  v8[0] = MEMORY[0x24BDAC760];
  v8[1] = 3221225472;
  v8[2] = ___ZN9ULDBUtils13insertEntriesI14CLMiLoLoiTable7ULLoiMOEEbP7ULStoreRKNSt3__16vectorINT_5EntryENS5_9allocatorIS8_EEEE_block_invoke;
  v8[3] = &unk_2511D22D0;
  v11 = a2;
  v5 = v3;
  v9 = v5;
  v10 = &v12;
  objc_msgSend(v4, "performBlockAndWait:", v8);

  v6 = *((unsigned __int8 *)v13 + 24);
  _Block_object_dispose(&v12, 8);

  return v6;
}

void sub_241A0D57C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, void *a7, uint64_t a8, uint64_t a9, ...)
{
  void *v9;
  void *v10;
  va_list va;

  va_start(va, a9);

  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void ULDBUtils::fetchEntries<CLMiLoLoiTable,ULLoiMO>(void *a1@<X0>, void *a2@<X1>, void *a3@<X2>, uint64_t a4@<X3>, _QWORD *a5@<X8>)
{
  id v9;
  id v10;
  id v11;
  void *v12;
  id v13;
  id v14;
  id v15;
  uint64_t *v16;
  _QWORD v17[4];
  id v18;
  id v19;
  id v20;
  uint64_t *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t *v24;
  uint64_t v25;
  __n128 (*v26)(__n128 *, __n128 *);
  void (*v27)(uint64_t);
  void *v28;
  _QWORD v29[3];
  void **v30;

  v9 = a1;
  v10 = a2;
  v11 = a3;
  v23 = 0;
  v24 = &v23;
  v25 = 0x4812000000;
  v26 = __Block_byref_object_copy__1;
  v27 = __Block_byref_object_dispose__1;
  v28 = &unk_241BEBD1D;
  memset(v29, 0, sizeof(v29));
  objc_msgSend(v9, "managedObjectContext");
  v12 = (void *)objc_claimAutoreleasedReturnValue();
  v17[0] = MEMORY[0x24BDAC760];
  v17[1] = 3221225472;
  v17[2] = ___ZN9ULDBUtils12fetchEntriesI14CLMiLoLoiTable7ULLoiMOEENSt3__16vectorINT_5EntryENS3_9allocatorIS6_EEEEP7ULStoreP7NSArrayIP11NSPredicateEPSC_IP16NSSortDescriptorEm_block_invoke;
  v17[3] = &unk_2511D22F8;
  v13 = v10;
  v18 = v13;
  v14 = v11;
  v19 = v14;
  v22 = a4;
  v15 = v9;
  v20 = v15;
  v21 = &v23;
  objc_msgSend(v12, "performBlockAndWait:", v17);

  v16 = v24;
  a5[1] = 0;
  a5[2] = 0;
  *a5 = 0;
  std::vector<CLMiLoLoiTable::Entry>::__init_with_size[abi:ne180100]<CLMiLoLoiTable::Entry*,CLMiLoLoiTable::Entry*>(a5, v16[6], v16[7], (v16[7] - v16[6]) >> 6);

  _Block_object_dispose(&v23, 8);
  v30 = (void **)v29;
  std::vector<CLMiLoLoiTable::Entry>::__destroy_vector::operator()[abi:ne180100](&v30);

}

void sub_241A0D730(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, void *a6, void *a7, void *a8, uint64_t a9, uint64_t a10, ...)
{
  void *v10;
  void *v11;
  void *v12;
  uint64_t v13;
  uint64_t v14;
  va_list va;

  va_start(va, a10);

  _Block_object_dispose(va, 8);
  *(_QWORD *)(v14 - 96) = v13;
  std::vector<CLMiLoLoiTable::Entry>::__destroy_vector::operator()[abi:ne180100]((void ***)(v14 - 96));

  _Unwind_Resume(a1);
}

void ULDBUtils::fetchAllWithLimit<CLMiLoLoiTable,ULLoiMO>(void *a1@<X0>, unsigned int a2@<W1>, _QWORD *a3@<X8>)
{
  id v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;
  _QWORD v10[2];

  v10[1] = *MEMORY[0x24BDAC8D0];
  v5 = a1;
  v6 = (void *)MEMORY[0x24BDD17C0];
  objc_msgSend((id)objc_opt_class(), "defaultSortProperty");
  v7 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v6, "sortDescriptorWithKey:ascending:", v7, 0);
  v8 = (void *)objc_claimAutoreleasedReturnValue();

  v10[0] = v8;
  objc_msgSend(MEMORY[0x24BDBCE30], "arrayWithObjects:count:", v10, 1);
  v9 = (void *)objc_claimAutoreleasedReturnValue();
  ULDBUtils::fetchEntries<CLMiLoLoiTable,ULLoiMO>(v5, 0, v9, a2, a3);

}

void sub_241A0D890(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_241A0DA9C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;

  _Unwind_Resume(a1);
}

void sub_241A0DBC0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_241A0DD50(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_241A0DEE0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_241A0E074(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, void *a7, uint64_t a8, uint64_t a9, ...)
{
  void *v9;
  uint64_t v10;
  uint64_t v11;
  va_list va;

  va_start(va, a9);

  _Block_object_dispose(va, 8);
  *(_QWORD *)(v11 - 72) = v10;
  std::vector<CLMiLoLoiTable::Entry>::__destroy_vector::operator()[abi:ne180100]((void ***)(v11 - 72));

  _Unwind_Resume(a1);
}

__n128 __Block_byref_object_copy__1(__n128 *a1, __n128 *a2)
{
  __n128 result;

  a1[3].n128_u64[0] = 0;
  a1[3].n128_u64[1] = 0;
  a1[4].n128_u64[0] = 0;
  result = a2[3];
  a1[3] = result;
  a1[4].n128_u64[0] = a2[4].n128_u64[0];
  a2[3].n128_u64[0] = 0;
  a2[3].n128_u64[1] = 0;
  a2[4].n128_u64[0] = 0;
  return result;
}

void __Block_byref_object_dispose__1(uint64_t a1)
{
  void **v1;

  v1 = (void **)(a1 + 48);
  std::vector<CLMiLoLoiTable::Entry>::__destroy_vector::operator()[abi:ne180100](&v1);
}

void sub_241A0E284(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void ULDBUtils::convertManagedObjectsToEntries<CLMiLoLoiTable,ULLoiMO>(void *a1@<X0>, uint64_t *a2@<X8>)
{
  id v3;
  id v4;
  uint64_t v5;
  char v6;
  uint64_t v7;
  uint64_t v8;
  id v9;
  void *v10;
  char v11;
  NSObject *v12;
  void *v13;
  void *v14;
  NSObject *v15;
  void *v16;
  void *v17;
  id v18;
  uint64_t *v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  uint8_t buf[4];
  int v25;
  __int16 v26;
  const char *v27;
  __int16 v28;
  void *v29;
  __int128 v30[2];
  void *__p[2];
  __int128 v32;
  uint64_t v33;
  _BYTE v34[128];
  uint64_t v35;

  v35 = *MEMORY[0x24BDAC8D0];
  v3 = a1;
  a2[1] = 0;
  a2[2] = 0;
  *a2 = 0;
  std::vector<CLMiLoLoiTable::Entry>::reserve(a2, objc_msgSend(v3, "count"));
  v22 = 0u;
  v23 = 0u;
  v20 = 0u;
  v21 = 0u;
  v4 = v3;
  v5 = objc_msgSend(v4, "countByEnumeratingWithState:objects:count:", &v20, v34, 16);
  if (!v5)
  {

    goto LABEL_28;
  }
  v18 = v3;
  v19 = a2;
  v6 = 0;
  v7 = *(_QWORD *)v21;
  do
  {
    v8 = 0;
    do
    {
      if (*(_QWORD *)v21 != v7)
        objc_enumerationMutation(v4);
      v9 = *(id *)(*((_QWORD *)&v20 + 1) + 8 * v8);
      v10 = v9;
      if (v9)
      {
        objc_msgSend(v9, "convertToEntry", v18);
        if ((_BYTE)v33)
        {
          std::vector<CLMiLoLoiTable::Entry>::push_back[abi:ne180100](v19, v30);
          v11 = 0;
          goto LABEL_19;
        }
      }
      else
      {
        v33 = 0;
        *(_OWORD *)__p = 0u;
        v32 = 0u;
        memset(v30, 0, sizeof(v30));
      }
      if (onceToken_MicroLocation_Default != -1)
        dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_13);
      v12 = (id)logObject_MicroLocation_Default;
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
      {
        objc_msgSend(v10, "entity");
        v13 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v13, "name");
        v14 = (void *)objc_claimAutoreleasedReturnValue();
        *(_DWORD *)buf = 68289283;
        v25 = 0;
        v26 = 2082;
        v27 = "";
        v28 = 2113;
        v29 = v14;
        _os_log_impl(&dword_2419D9000, v12, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"Failed to convert MO to entry\", \"MO\":%{private, location:escape_only}@}", buf, 0x1Cu);

      }
      if (onceToken_MicroLocation_Default != -1)
        dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_13);
      v15 = (id)logObject_MicroLocation_Default;
      if (os_signpost_enabled(v15))
      {
        objc_msgSend(v10, "entity");
        v16 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v16, "name");
        v17 = (void *)objc_claimAutoreleasedReturnValue();
        *(_DWORD *)buf = 68289283;
        v25 = 0;
        v26 = 2082;
        v27 = "";
        v28 = 2113;
        v29 = v17;
        _os_signpost_emit_with_name_impl(&dword_2419D9000, v15, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Failed to convert MO to entry", "{\"msg%{public}.0s\":\"Failed to convert MO to entry\", \"MO\":%{private, location:escape_only}@}", buf, 0x1Cu);

      }
      v11 = 1;
      v6 = 1;
LABEL_19:
      if ((_BYTE)v33 && SHIBYTE(v32) < 0)
        operator delete(__p[1]);

      if ((v11 & 1) != 0)
        goto LABEL_25;
      ++v8;
    }
    while (v5 != v8);
    v5 = objc_msgSend(v4, "countByEnumeratingWithState:objects:count:", &v20, v34, 16);
  }
  while (v5);
LABEL_25:

  if ((v6 & 1) != 0)
    std::vector<CLMiLoLoiTable::Entry>::__clear[abi:ne180100](v19);
LABEL_28:

}

void sub_241A0E60C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,void *__p,uint64_t a31,int a32,__int16 a33,char a34,char a35,char a36)
{
  void *v36;

  a25 = a10;
  std::vector<CLMiLoLoiTable::Entry>::__destroy_vector::operator()[abi:ne180100]((void ***)&a25);

  _Unwind_Resume(a1);
}

void sub_241A0E84C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_241A0E930(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_241A0EA50(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  v4 = v3;

  _Unwind_Resume(a1);
}

void sub_241A0EC0C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_241A0EDF0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_241A0EFE8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_241A0F398(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16, void *a17, void *a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,void *__p,uint64_t a27)
{
  void *v27;
  void *v28;
  void *v29;
  void *v30;
  uint64_t v31;

  _Block_object_dispose(&a22, 8);
  if (__p)
  {
    a27 = (uint64_t)__p;
    operator delete(__p);
  }
  a22 = v31 - 112;
  std::vector<CLMiLoLoiTable::Entry>::__destroy_vector::operator()[abi:ne180100]((void ***)&a22);
  _Unwind_Resume(a1);
}

void sub_241A0F78C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, void *a12)
{

  _Unwind_Resume(a1);
}

void sub_241A0F970(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, void *a7, void *a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  void *v11;
  void *v12;
  void *v13;
  va_list va;

  va_start(va, a11);

  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_241A0FA7C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void ___ZN9ULDBUtils13insertEntriesI14CLMiLoLoiTable7ULLoiMOEEbP7ULStoreRKNSt3__16vectorINT_5EntryENS5_9allocatorIS8_EEEE_block_invoke(uint64_t a1)
{
  uint64_t *v2;
  uint64_t v3;
  uint64_t v4;
  void *v5;
  void *v6;
  NSObject *v7;
  void *v8;
  void *v9;
  NSObject *v10;
  void *v11;
  void *v12;
  void *v13;
  int v14;
  int v15;
  __int16 v16;
  const char *v17;
  __int16 v18;
  void *v19;
  uint64_t v20;

  v20 = *MEMORY[0x24BDAC8D0];
  v2 = *(uint64_t **)(a1 + 48);
  v3 = *v2;
  v4 = v2[1];
  if (*v2 == v4)
  {
LABEL_4:
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = objc_msgSend(*(id *)(a1 + 32), "commitChangesToStore");
    objc_msgSend(*(id *)(a1 + 32), "deleteOldestRecordsIfFull");
  }
  else
  {
    while (1)
    {
      objc_msgSend(*(id *)(a1 + 32), "managedObjectContext");
      v5 = (void *)objc_claimAutoreleasedReturnValue();
      +[ULLoiMO createFromEntry:inManagedObjectContext:](ULLoiMO, "createFromEntry:inManagedObjectContext:", v3, v5);
      v6 = (void *)objc_claimAutoreleasedReturnValue();

      if (!v6)
        break;

      v3 += 64;
      if (v3 == v4)
        goto LABEL_4;
    }
    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_13);
    v7 = (id)logObject_MicroLocation_Default;
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      +[ULLoiMO entity](ULLoiMO, "entity");
      v8 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v8, "name");
      v9 = (void *)objc_claimAutoreleasedReturnValue();
      v14 = 68289283;
      v15 = 0;
      v16 = 2082;
      v17 = "";
      v18 = 2113;
      v19 = v9;
      _os_log_impl(&dword_2419D9000, v7, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"Failed to create entry from MO\", \"MO\":%{private, location:escape_only}@}", (uint8_t *)&v14, 0x1Cu);

    }
    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_13);
    v10 = (id)logObject_MicroLocation_Default;
    if (os_signpost_enabled(v10))
    {
      +[ULLoiMO entity](ULLoiMO, "entity");
      v11 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v11, "name");
      v12 = (void *)objc_claimAutoreleasedReturnValue();
      v14 = 68289283;
      v15 = 0;
      v16 = 2082;
      v17 = "";
      v18 = 2113;
      v19 = v12;
      _os_signpost_emit_with_name_impl(&dword_2419D9000, v10, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Failed to create entry from MO", "{\"msg%{public}.0s\":\"Failed to create entry from MO\", \"MO\":%{private, location:escape_only}@}", (uint8_t *)&v14, 0x1Cu);

    }
    objc_msgSend(*(id *)(a1 + 32), "managedObjectContext");
    v13 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v13, "reset");

  }
}

void sub_241A0FD4C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void ___ZL45_CLLogObjectForCategory_MicroLocation_Defaultv_block_invoke_8()
{
  os_log_t v0;
  void *v1;

  v0 = os_log_create("com.apple.MicroLocation", "MicroLocation");
  v1 = (void *)logObject_MicroLocation_Default;
  logObject_MicroLocation_Default = (uint64_t)v0;

}

void ___ZN9ULDBUtils12fetchEntriesI14CLMiLoLoiTable7ULLoiMOEENSt3__16vectorINT_5EntryENS3_9allocatorIS6_EEEEP7ULStoreP7NSArrayIP11NSPredicateEPSC_IP16NSSortDescriptorEm_block_invoke(uint64_t a1)
{
  void *v2;
  objc_class *v3;
  void *v4;
  void *v5;
  uint64_t v6;
  void *v7;
  __int128 v8;
  uint64_t v9;
  void **v10;

  v2 = *(void **)(a1 + 48);
  v3 = (objc_class *)objc_opt_class();
  NSStringFromClass(v3);
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v2, "fetchManagedObjectsWithEntityName:byAndPredicates:sortDescriptors:andLimit:", v4, *(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 64));
  v5 = (void *)objc_claimAutoreleasedReturnValue();

  ULDBUtils::convertManagedObjectsToEntries<CLMiLoLoiTable,ULLoiMO>(v5, (uint64_t *)&v8);
  v6 = *(_QWORD *)(*(_QWORD *)(a1 + 56) + 8);
  std::vector<CLMiLoLoiTable::Entry>::__vdeallocate((uint64_t *)(v6 + 48));
  *(_OWORD *)(v6 + 48) = v8;
  *(_QWORD *)(v6 + 64) = v9;
  v9 = 0;
  v8 = 0uLL;
  v10 = (void **)&v8;
  std::vector<CLMiLoLoiTable::Entry>::__destroy_vector::operator()[abi:ne180100](&v10);
  objc_msgSend(*(id *)(a1 + 48), "managedObjectContext");
  v7 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v7, "reset");

}

void sub_241A0FE98(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void std::vector<CLMiLoLoiTable::Entry>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v2;

  v2 = *a1;
  if (*v2)
  {
    std::vector<CLMiLoLoiTable::Entry>::__clear[abi:ne180100]((uint64_t *)v2);
    operator delete(**a1);
  }
}

void std::vector<CLMiLoLoiTable::Entry>::__clear[abi:ne180100](uint64_t *a1)
{
  uint64_t v2;
  uint64_t i;

  v2 = *a1;
  for (i = a1[1]; i != v2; i -= 64)
  {
    if (*(char *)(i - 1) < 0)
      operator delete(*(void **)(i - 24));
  }
  a1[1] = v2;
}

uint64_t std::vector<CLMiLoLoiTable::Entry>::reserve(uint64_t *a1, unint64_t a2)
{
  uint64_t result;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  _QWORD v7[5];

  v4 = a1[2];
  result = (uint64_t)(a1 + 2);
  if (a2 > (v4 - *a1) >> 6)
  {
    if (a2 >> 58)
      std::vector<CLMicroLocationProto::ConfidenceReason>::__throw_length_error[abi:ne180100]();
    v5 = a1[1] - *a1;
    v7[4] = result;
    v7[0] = std::__allocate_at_least[abi:ne180100]<std::allocator<CLMicroLocationRecordingLabelsTable::Entry>>(result, a2);
    v7[1] = v7[0] + v5;
    v7[2] = v7[0] + v5;
    v7[3] = v7[0] + (v6 << 6);
    std::vector<CLMiLoLoiTable::Entry>::__swap_out_circular_buffer(a1, v7);
    return std::__split_buffer<CLMiLoLoiTable::Entry>::~__split_buffer((uint64_t)v7);
  }
  return result;
}

void sub_241A0FFCC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__split_buffer<CLMiLoLoiTable::Entry>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t std::vector<CLMiLoLoiTable::Entry>::push_back[abi:ne180100](uint64_t *a1, __int128 *a2)
{
  uint64_t result;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  unint64_t v15;
  char *v16;
  char *v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  _QWORD v21[5];

  v6 = a1[2];
  result = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(_QWORD *)(result - 8);
  if (v7 >= v6)
  {
    v12 = (uint64_t)(v7 - *a1) >> 6;
    v13 = v12 + 1;
    if ((unint64_t)(v12 + 1) >> 58)
      std::vector<CLMicroLocationProto::ConfidenceReason>::__throw_length_error[abi:ne180100]();
    v14 = v5 - *a1;
    if (v14 >> 5 > v13)
      v13 = v14 >> 5;
    if ((unint64_t)v14 >= 0x7FFFFFFFFFFFFFC0)
      v15 = 0x3FFFFFFFFFFFFFFLL;
    else
      v15 = v13;
    v21[4] = result;
    if (v15)
      v16 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<CLMicroLocationRecordingLabelsTable::Entry>>(result, v15);
    else
      v16 = 0;
    v17 = &v16[64 * v12];
    v21[0] = v16;
    v21[1] = v17;
    v21[3] = &v16[64 * v15];
    v18 = *a2;
    v19 = a2[1];
    *((_QWORD *)v17 + 4) = *((_QWORD *)a2 + 4);
    *(_OWORD *)v17 = v18;
    *((_OWORD *)v17 + 1) = v19;
    v20 = *(__int128 *)((char *)a2 + 40);
    *((_QWORD *)v17 + 7) = *((_QWORD *)a2 + 7);
    *(_OWORD *)(v17 + 40) = v20;
    *((_QWORD *)a2 + 6) = 0;
    *((_QWORD *)a2 + 7) = 0;
    *((_QWORD *)a2 + 5) = 0;
    v21[2] = v17 + 64;
    std::vector<CLMiLoLoiTable::Entry>::__swap_out_circular_buffer(a1, v21);
    v11 = a1[1];
    result = std::__split_buffer<CLMiLoLoiTable::Entry>::~__split_buffer((uint64_t)v21);
  }
  else
  {
    v8 = *a2;
    v9 = a2[1];
    *(_QWORD *)(v7 + 32) = *((_QWORD *)a2 + 4);
    *(_OWORD *)v7 = v8;
    *(_OWORD *)(v7 + 16) = v9;
    v10 = *(__int128 *)((char *)a2 + 40);
    *(_QWORD *)(v7 + 56) = *((_QWORD *)a2 + 7);
    *(_OWORD *)(v7 + 40) = v10;
    *((_QWORD *)a2 + 6) = 0;
    *((_QWORD *)a2 + 7) = 0;
    *((_QWORD *)a2 + 5) = 0;
    v11 = v7 + 64;
    a1[1] = v7 + 64;
  }
  a1[1] = v11;
  return result;
}

void sub_241A10104(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__split_buffer<CLMiLoLoiTable::Entry>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t std::vector<CLMiLoLoiTable::Entry>::__swap_out_circular_buffer(uint64_t *a1, _QWORD *a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<CLMiLoLoiTable::Entry>,std::reverse_iterator<CLMiLoLoiTable::Entry*>,std::reverse_iterator<CLMiLoLoiTable::Entry*>,std::reverse_iterator<CLMiLoLoiTable::Entry*>>((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<CLMiLoLoiTable::Entry>,std::reverse_iterator<CLMiLoLoiTable::Entry*>,std::reverse_iterator<CLMiLoLoiTable::Entry*>,std::reverse_iterator<CLMiLoLoiTable::Entry*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7;
  uint64_t v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  _QWORD v14[3];
  char v15;
  __int128 v16;
  __int128 v17;

  v7 = a7;
  *(_QWORD *)&v17 = a6;
  *((_QWORD *)&v17 + 1) = a7;
  v16 = v17;
  v14[0] = a1;
  v14[1] = &v16;
  v14[2] = &v17;
  if (a3 != a5)
  {
    v9 = a7;
    do
    {
      v10 = *(_OWORD *)(a3 - 64);
      v11 = *(_OWORD *)(a3 - 48);
      *(_QWORD *)(v9 - 32) = *(_QWORD *)(a3 - 32);
      *(_OWORD *)(v9 - 64) = v10;
      *(_OWORD *)(v9 - 48) = v11;
      v12 = *(_OWORD *)(a3 - 24);
      *(_QWORD *)(v9 - 8) = *(_QWORD *)(a3 - 8);
      *(_OWORD *)(v9 - 24) = v12;
      v9 -= 64;
      *(_QWORD *)(a3 - 16) = 0;
      *(_QWORD *)(a3 - 8) = 0;
      *(_QWORD *)(a3 - 24) = 0;
      v7 -= 64;
      a3 -= 64;
    }
    while (a3 != a5);
    *((_QWORD *)&v17 + 1) = v9;
  }
  v15 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<CLMiLoLoiTable::Entry>,std::reverse_iterator<CLMiLoLoiTable::Entry*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v14);
  return a6;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<CLMiLoLoiTable::Entry>,std::reverse_iterator<CLMiLoLoiTable::Entry*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24))
    std::_AllocatorDestroyRangeReverse<std::allocator<CLMiLoLoiTable::Entry>,std::reverse_iterator<CLMiLoLoiTable::Entry*>>::operator()[abi:ne180100](a1);
  return a1;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<CLMiLoLoiTable::Entry>,std::reverse_iterator<CLMiLoLoiTable::Entry*>>::operator()[abi:ne180100](uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;

  v1 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 8);
  v2 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8);
  while (v1 != v2)
  {
    if (*(char *)(v1 + 63) < 0)
      operator delete(*(void **)(v1 + 40));
    v1 += 64;
  }
}

uint64_t std::__split_buffer<CLMiLoLoiTable::Entry>::~__split_buffer(uint64_t a1)
{
  std::__split_buffer<CLMiLoLoiTable::Entry>::__destruct_at_end[abi:ne180100](a1, *(_QWORD *)(a1 + 8));
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

void std::__split_buffer<CLMiLoLoiTable::Entry>::__destruct_at_end[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v5;

  v2 = *(_QWORD *)(a1 + 16);
  if (v2 != a2)
  {
    do
    {
      v5 = v2 - 64;
      *(_QWORD *)(a1 + 16) = v2 - 64;
      if (*(char *)(v2 - 1) < 0)
      {
        operator delete(*(void **)(v2 - 24));
        v5 = *(_QWORD *)(a1 + 16);
      }
      v2 = v5;
    }
    while (v5 != a2);
  }
}

void std::vector<CLMiLoLoiTable::Entry>::__vdeallocate(uint64_t *a1)
{
  if (*a1)
  {
    std::vector<CLMiLoLoiTable::Entry>::__clear[abi:ne180100](a1);
    operator delete((void *)*a1);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

_QWORD *std::vector<CLMiLoLoiTable::Entry>::__init_with_size[abi:ne180100]<CLMiLoLoiTable::Entry*,CLMiLoLoiTable::Entry*>(_QWORD *result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  _QWORD *v6;

  if (a4)
  {
    v6 = result;
    std::vector<CLMicroLocationRecordingLabelsTable::Entry>::__vallocate[abi:ne180100](result, a4);
    result = (_QWORD *)std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<CLMiLoLoiTable::Entry>,CLMiLoLoiTable::Entry*,CLMiLoLoiTable::Entry*,CLMiLoLoiTable::Entry*>((uint64_t)(v6 + 2), a2, a3, v6[1]);
    v6[1] = result;
  }
  return result;
}

void sub_241A103D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  uint64_t v9;
  uint64_t v10;

  *(_QWORD *)(v9 + 8) = v10;
  std::vector<CLMiLoLoiTable::Entry>::__destroy_vector::operator()[abi:ne180100](&a9);
  _Unwind_Resume(a1);
}

uint64_t std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<CLMiLoLoiTable::Entry>,CLMiLoLoiTable::Entry*,CLMiLoLoiTable::Entry*,CLMiLoLoiTable::Entry*>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  __int128 *v6;
  __int128 v7;
  __int128 v8;
  std::string *v9;
  __int128 v10;
  uint64_t v11;
  _QWORD v13[3];
  char v14;
  uint64_t v15;
  uint64_t v16;

  v4 = a4;
  v15 = a4;
  v16 = a4;
  v13[0] = a1;
  v13[1] = &v15;
  v13[2] = &v16;
  v14 = 0;
  if (a2 != a3)
  {
    v6 = (__int128 *)(a2 + 40);
    do
    {
      v7 = *(__int128 *)((char *)v6 - 40);
      v8 = *(__int128 *)((char *)v6 - 24);
      *(_QWORD *)(v4 + 32) = *((_QWORD *)v6 - 1);
      *(_OWORD *)v4 = v7;
      *(_OWORD *)(v4 + 16) = v8;
      v9 = (std::string *)(v4 + 40);
      if (*((char *)v6 + 23) < 0)
      {
        std::string::__init_copy_ctor_external(v9, *(const std::string::value_type **)v6, *((_QWORD *)v6 + 1));
        v4 = v16;
      }
      else
      {
        v10 = *v6;
        *(_QWORD *)(v4 + 56) = *((_QWORD *)v6 + 2);
        *(_OWORD *)&v9->__r_.__value_.__l.__data_ = v10;
      }
      v11 = (uint64_t)v6 - 40;
      v4 += 64;
      v16 = v4;
      v6 += 4;
    }
    while (v11 + 64 != a3);
  }
  v14 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<CLMiLoLoiTable::Entry>,CLMiLoLoiTable::Entry*>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v13);
  return v4;
}

void sub_241A104B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<CLMiLoLoiTable::Entry>,CLMiLoLoiTable::Entry*>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<CLMiLoLoiTable::Entry>,CLMiLoLoiTable::Entry*>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24))
    std::_AllocatorDestroyRangeReverse<std::allocator<CLMiLoLoiTable::Entry>,CLMiLoLoiTable::Entry*>::operator()[abi:ne180100](a1);
  return a1;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<CLMiLoLoiTable::Entry>,CLMiLoLoiTable::Entry*>::operator()[abi:ne180100](uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;

  v1 = **(_QWORD **)(a1 + 16);
  v2 = **(_QWORD **)(a1 + 8);
  while (v1 != v2)
  {
    if (*(char *)(v1 - 1) < 0)
      operator delete(*(void **)(v1 - 24));
    v1 -= 64;
  }
}

void std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,boost::uuids::uuid *,false>(unint64_t *a1, unint64_t *a2, uint64_t a3, uint64_t a4, char a5)
{
  unint64_t *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t *v15;
  unint64_t v16;
  unint64_t v17;
  int v18;
  unint64_t *v19;
  char v20;
  BOOL v21;
  unint64_t *v22;
  unint64_t v23;
  unint64_t v24;
  unint64_t v25;
  int v26;
  __int128 v27;
  __int128 v28;

LABEL_1:
  v9 = a1;
LABEL_2:
  v10 = 1 - a4;
  while (2)
  {
    a1 = v9;
    v11 = v10;
    v12 = (char *)a2 - (char *)v9;
    v13 = ((char *)a2 - (char *)v9) >> 4;
    switch(v13)
    {
      case 0uLL:
      case 1uLL:
        return;
      case 2uLL:
        v23 = *(a2 - 2);
        v22 = a2 - 2;
        v24 = bswap64(v23);
        v25 = bswap64(*v9);
        if (v24 == v25 && (v24 = bswap64(v22[1]), v25 = bswap64(v9[1]), v24 == v25))
        {
          v26 = 0;
        }
        else if (v24 < v25)
        {
          v26 = -1;
        }
        else
        {
          v26 = 1;
        }
        if (v26 < 0)
        {
          v28 = *(_OWORD *)v9;
          *(_OWORD *)v9 = *(_OWORD *)v22;
          *(_OWORD *)v22 = v28;
        }
        return;
      case 3uLL:
        std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,boost::uuids::uuid *>(v9, v9 + 2, a2 - 2);
        return;
      case 4uLL:
        std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,boost::uuids::uuid *>(v9, v9 + 2, v9 + 4, a2 - 2);
        return;
      case 5uLL:
        std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,boost::uuids::uuid *>(v9, v9 + 2, v9 + 4, v9 + 6, a2 - 2);
        return;
      default:
        if (v12 <= 383)
        {
          if ((a5 & 1) != 0)
            std::__insertion_sort[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,boost::uuids::uuid *>(v9, a2);
          else
            std::__insertion_sort_unguarded[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,boost::uuids::uuid *>(v9, a2);
          return;
        }
        if (v11 != 1)
        {
          v14 = v13 >> 1;
          v15 = &v9[2 * (v13 >> 1)];
          if ((unint64_t)v12 < 0x801)
          {
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,boost::uuids::uuid *>(&v9[2 * (v13 >> 1)], v9, a2 - 2);
            if ((a5 & 1) != 0)
              goto LABEL_17;
          }
          else
          {
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,boost::uuids::uuid *>(v9, &v9[2 * (v13 >> 1)], a2 - 2);
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,boost::uuids::uuid *>(v9 + 2, v15 - 2, a2 - 4);
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,boost::uuids::uuid *>(v9 + 4, &v9[2 * v14 + 2], a2 - 6);
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,boost::uuids::uuid *>(v15 - 2, v15, &v9[2 * v14 + 2]);
            v27 = *(_OWORD *)v9;
            *(_OWORD *)v9 = *(_OWORD *)v15;
            *(_OWORD *)v15 = v27;
            if ((a5 & 1) != 0)
              goto LABEL_17;
          }
          v16 = bswap64(*(v9 - 2));
          v17 = bswap64(*v9);
          if (v16 == v17 && (v16 = bswap64(*(v9 - 1)), v17 = bswap64(v9[1]), v16 == v17))
          {
            v18 = 0;
          }
          else if (v16 < v17)
          {
            v18 = -1;
          }
          else
          {
            v18 = 1;
          }
          if ((v18 & 0x80000000) == 0)
          {
            v9 = std::__partition_with_equals_on_left[abi:ne180100]<std::_ClassicAlgPolicy,boost::uuids::uuid *,std::__less<void,void> &>(v9, a2);
            goto LABEL_22;
          }
LABEL_17:
          v19 = (unint64_t *)std::__partition_with_equals_on_right[abi:ne180100]<std::_ClassicAlgPolicy,boost::uuids::uuid *,std::__less<void,void> &>((__int128 *)v9, (__int128 *)a2);
          if ((v20 & 1) == 0)
            goto LABEL_20;
          v21 = std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,boost::uuids::uuid *>(v9, v19);
          v9 = v19 + 2;
          if (!std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,boost::uuids::uuid *>(v19 + 2, a2))
          {
            v10 = v11 + 1;
            if (v21)
              continue;
LABEL_20:
            std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,boost::uuids::uuid *,false>(a1, v19, a3, -v11, a5 & 1);
            v9 = v19 + 2;
LABEL_22:
            a5 = 0;
            a4 = -v11;
            goto LABEL_2;
          }
          a4 = -v11;
          a2 = v19;
          if (v21)
            return;
          goto LABEL_1;
        }
        if (v9 != a2)
          std::__partial_sort_impl[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,boost::uuids::uuid *,boost::uuids::uuid *>(v9, a2, a2, a3);
        return;
    }
  }
}

  v131 = a2 - 4;
  v7 = a1;
  while (2)
  {
    a1 = v7;
    v8 = (uint64_t)a2 - v7;
    v9 = (uint64_t)((uint64_t)a2 - v7) >> 6;
    switch(v9)
    {
      case 0uLL:
      case 1uLL:
        return;
      case 2uLL:
        v58 = a2 - 4;
        if (*(double *)v7 < a2[-4].n128_f64[0])
        {
          v59 = *(_QWORD *)(v7 + 40);
          v169 = *(_QWORD *)(v7 + 32);
          v153 = *(__n128 *)v7;
          v161 = *(__n128 *)(v7 + 16);
          *(_QWORD *)&v139 = *(_QWORD *)(v7 + 48);
          *(_QWORD *)((char *)&v139 + 7) = *(_QWORD *)(v7 + 55);
          v60 = *(_BYTE *)(v7 + 63);
          *(_QWORD *)(v7 + 40) = 0;
          *(_QWORD *)(v7 + 48) = 0;
          *(_QWORD *)(v7 + 56) = 0;
          v61 = *v58;
          v62 = a2[-3];
          *(_QWORD *)(v7 + 32) = a2[-2].n128_u64[0];
          *(__n128 *)v7 = v61;
          *(__n128 *)(v7 + 16) = v62;
          v63 = *(__int128 *)((char *)&a2[-2] + 8);
          *(_QWORD *)(v7 + 56) = a2[-1].n128_u64[1];
          *(_OWORD *)(v7 + 40) = v63;
          a2[-2].n128_u64[0] = v169;
          *v58 = v153;
          a2[-3] = v161;
          a2[-2].n128_u64[1] = v59;
          *(unint64_t *)((char *)a2[-1].n128_u64 + 7) = *(_QWORD *)((char *)&v139 + 7);
          a2[-1].n128_u64[0] = v139;
          a2[-1].n128_u8[15] = v60;
        }
        return;
      case 3uLL:
        std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,CLMicroLocationLearner::fetchAndFilterUniqueLOIGroups(void)::$_1 &,CLMiLoLoiTable::Entry *>(v7, (__n128 *)(v7 + 64), v131);
        return;
      case 4uLL:
        std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,CLMicroLocationLearner::fetchAndFilterUniqueLOIGroups(void)::$_1 &,CLMiLoLoiTable::Entry *>(v7, v7 + 64, v7 + 128, (uint64_t)v131);
        return;
      case 5uLL:
        std::__sort5_maybe_branchless[abi:ne180100]<std::_ClassicAlgPolicy,CLMicroLocationLearner::fetchAndFilterUniqueLOIGroups(void)::$_1 &,CLMiLoLoiTable::Entry *,0>(v7, v7 + 64, v7 + 128, v7 + 192, (__int128 *)v131);
        return;
      default:
        if (v8 <= 1535)
        {
          v64 = (__n128 *)(v7 + 64);
          v66 = (__n128 *)v7 == a2 || v64 == a2;
          if ((a4 & 1) != 0)
          {
            if (!v66)
            {
              v67 = 0;
              v68 = v7;
              do
              {
                v69 = v64;
                v70 = *(double *)(v68 + 64);
                if (*(double *)v68 < v70)
                {
                  v154 = *(_OWORD *)(v68 + 72);
                  v162 = *(_OWORD *)(v68 + 88);
                  v71 = *(_QWORD *)(v68 + 104);
                  *(_QWORD *)v140 = *(_QWORD *)(v68 + 112);
                  *(_QWORD *)&v140[7] = *(_QWORD *)(v68 + 119);
                  v72 = *(_BYTE *)(v68 + 127);
                  *(_QWORD *)(v68 + 112) = 0;
                  *(_QWORD *)(v68 + 120) = 0;
                  *(_QWORD *)(v68 + 104) = 0;
                  v73 = v67;
                  v74 = v64[3].n128_u8[15];
                  while (1)
                  {
                    v75 = v73;
                    v76 = a1 + v73;
                    v77 = *(_OWORD *)(a1 + v73 + 16);
                    *(_OWORD *)(v76 + 64) = *(_OWORD *)(a1 + v73);
                    *(_OWORD *)(v76 + 80) = v77;
                    *(_QWORD *)(v76 + 96) = *(_QWORD *)(a1 + v73 + 32);
                    v78 = (void **)(a1 + v73 + 104);
                    if ((v74 & 0x80) != 0)
                      operator delete(*v78);
                    *(_OWORD *)v78 = *(_OWORD *)(v76 + 40);
                    *(_QWORD *)(v76 + 120) = *(_QWORD *)(v76 + 56);
                    *(_BYTE *)(v76 + 63) = 0;
                    *(_BYTE *)(v76 + 40) = 0;
                    if (!v75)
                      break;
                    v74 = 0;
                    v73 = v75 - 64;
                    if (*(double *)(a1 + v75 - 64) >= v70)
                    {
                      v79 = a1 + v75;
                      goto LABEL_81;
                    }
                  }
                  v79 = a1;
LABEL_81:
                  *(double *)v79 = v70;
                  *(_OWORD *)(v79 + 24) = v162;
                  *(_OWORD *)(v79 + 8) = v154;
                  *(_QWORD *)(a1 + v75 + 40) = v71;
                  *(_QWORD *)(v79 + 48) = *(_QWORD *)v140;
                  *(_QWORD *)(v79 + 55) = *(_QWORD *)&v140[7];
                  *(_BYTE *)(v79 + 63) = v72;
                }
                v64 = v69 + 4;
                v67 += 64;
                v68 = (unint64_t)v69;
              }
              while (&v69[4] != a2);
            }
          }
          else if (!v66)
          {
            v122 = v7 + 40;
            do
            {
              v123 = (uint64_t)v64;
              v124 = *(double *)(a1 + 64);
              if (*(double *)a1 < v124)
              {
                v157 = *(_OWORD *)(a1 + 72);
                v165 = *(_OWORD *)(a1 + 88);
                v125 = *(_QWORD *)(a1 + 104);
                *(_QWORD *)v143 = *(_QWORD *)(a1 + 112);
                *(_QWORD *)&v143[7] = *(_QWORD *)(a1 + 119);
                v126 = *(_BYTE *)(a1 + 127);
                *(_QWORD *)(a1 + 112) = 0;
                *(_QWORD *)(a1 + 120) = 0;
                *(_QWORD *)(a1 + 104) = 0;
                v127 = v122;
                v128 = v64[3].n128_u8[15];
                do
                {
                  *(_OWORD *)(v127 + 24) = *(_OWORD *)(v127 - 40);
                  *(_OWORD *)(v127 + 40) = *(_OWORD *)(v127 - 24);
                  *(_QWORD *)(v127 + 56) = *(_QWORD *)(v127 - 8);
                  v129 = (void **)(v127 + 64);
                  if ((v128 & 0x80) != 0)
                    operator delete(*v129);
                  v128 = 0;
                  *(_OWORD *)v129 = *(_OWORD *)v127;
                  *(_QWORD *)(v127 + 80) = *(_QWORD *)(v127 + 16);
                  *(_BYTE *)(v127 + 23) = 0;
                  *(_BYTE *)v127 = 0;
                  v130 = *(double *)(v127 - 104);
                  v127 -= 64;
                }
                while (v130 < v124);
                *(double *)(v127 + 24) = v124;
                *(_OWORD *)(v127 + 32) = v157;
                *(_OWORD *)(v127 + 48) = v165;
                *(_QWORD *)(v127 + 64) = v125;
                *(_QWORD *)(v127 + 79) = *(_QWORD *)&v143[7];
                *(_QWORD *)(v127 + 72) = *(_QWORD *)v143;
                *(_BYTE *)(v127 + 87) = v126;
              }
              v64 = (__n128 *)(v123 + 64);
              v122 += 64;
              a1 = v123;
            }
            while ((__n128 *)(v123 + 64) != a2);
          }
          return;
        }
        if (!a3)
        {
          if ((__n128 *)v7 != a2)
          {
            v80 = (v9 - 2) >> 1;
            v81 = v80;
            do
            {
              v82 = v81;
              if (v80 >= v81)
              {
                v83 = (2 * v81) | 1;
                v84 = v7 + (v83 << 6);
                if (2 * v82 + 2 < (uint64_t)v9 && *(double *)(v84 + 64) < *(double *)v84)
                {
                  v84 += 64;
                  v83 = 2 * v82 + 2;
                }
                v85 = v7 + (v82 << 6);
                v86 = *(double *)v85;
                if (*(double *)v85 >= *(double *)v84)
                {
                  v155 = *(_OWORD *)(v85 + 8);
                  v163 = *(_OWORD *)(v85 + 24);
                  v87 = (_QWORD *)(v7 + (v82 << 6));
                  v88 = v87[5];
                  *(_QWORD *)&v141[7] = *(_QWORD *)((char *)v87 + 55);
                  *(_QWORD *)v141 = v87[6];
                  v89 = *(_BYTE *)(v85 + 63);
                  v87[5] = 0;
                  v87[6] = 0;
                  v87[7] = 0;
                  do
                  {
                    v90 = v85;
                    v85 = v84;
                    v91 = *(_OWORD *)v84;
                    v92 = *(_OWORD *)(v84 + 16);
                    *(_QWORD *)(v90 + 32) = *(_QWORD *)(v84 + 32);
                    *(_OWORD *)v90 = v91;
                    *(_OWORD *)(v90 + 16) = v92;
                    v93 = *(_OWORD *)(v84 + 40);
                    *(_QWORD *)(v90 + 56) = *(_QWORD *)(v84 + 56);
                    *(_OWORD *)(v90 + 40) = v93;
                    *(_BYTE *)(v84 + 63) = 0;
                    *(_BYTE *)(v84 + 40) = 0;
                    if (v80 < v83)
                      break;
                    v94 = 2 * v83;
                    v83 = (2 * v83) | 1;
                    v84 = v7 + (v83 << 6);
                    v95 = v94 + 2;
                    if (v95 < (uint64_t)v9 && *(double *)(v84 + 64) < *(double *)v84)
                    {
                      v84 += 64;
                      v83 = v95;
                    }
                  }
                  while (v86 >= *(double *)v84);
                  *(double *)v85 = v86;
                  *(_OWORD *)(v85 + 8) = v155;
                  *(_OWORD *)(v85 + 24) = v163;
                  *(_QWORD *)(v85 + 40) = v88;
                  *(_QWORD *)(v85 + 48) = *(_QWORD *)v141;
                  *(_QWORD *)(v85 + 55) = *(_QWORD *)&v141[7];
                  *(_BYTE *)(v85 + 63) = v89;
                }
              }
              v81 = v82 - 1;
            }
            while (v82);
            v96 = (unint64_t)v8 >> 6;
            do
            {
              v97 = 0;
              v98 = a2;
              v99 = *(_QWORD *)(v7 + 40);
              v170 = *(_QWORD *)(v7 + 32);
              v156 = *(__n128 *)v7;
              v164 = *(__n128 *)(v7 + 16);
              *(_QWORD *)v135 = *(_QWORD *)(v7 + 48);
              *(_QWORD *)&v135[7] = *(_QWORD *)(v7 + 55);
              v100 = *(_BYTE *)(v7 + 63);
              *(_QWORD *)(v7 + 48) = 0;
              *(_QWORD *)(v7 + 56) = 0;
              v101 = v7;
              *(_QWORD *)(v7 + 40) = 0;
              do
              {
                v102 = v101;
                v101 += (v97 << 6) + 64;
                v103 = 2 * v97;
                v97 = (2 * v97) | 1;
                v104 = v103 + 2;
                if (v104 < v96 && *(double *)(v101 + 64) < *(double *)v101)
                {
                  v101 += 64;
                  v97 = v104;
                }
                v105 = *(_OWORD *)v101;
                v106 = *(_OWORD *)(v101 + 16);
                *(_QWORD *)(v102 + 32) = *(_QWORD *)(v101 + 32);
                *(_OWORD *)v102 = v105;
                *(_OWORD *)(v102 + 16) = v106;
                v107 = *(_OWORD *)(v101 + 40);
                *(_QWORD *)(v102 + 56) = *(_QWORD *)(v101 + 56);
                *(_OWORD *)(v102 + 40) = v107;
                *(_BYTE *)(v101 + 63) = 0;
                *(_BYTE *)(v101 + 40) = 0;
              }
              while (v97 <= (uint64_t)((unint64_t)(v96 - 2) >> 1));
              a2 -= 4;
              if ((__n128 *)v101 == &v98[-4])
              {
                *(__n128 *)v101 = v156;
                *(__n128 *)(v101 + 16) = v164;
                *(_QWORD *)(v101 + 32) = v170;
                *(_QWORD *)(v101 + 40) = v99;
                *(_QWORD *)(v101 + 48) = *(_QWORD *)v135;
                *(_QWORD *)(v101 + 55) = *(_QWORD *)&v135[7];
                *(_BYTE *)(v101 + 63) = v100;
              }
              else
              {
                v108 = *a2;
                v109 = v98[-3];
                *(_QWORD *)(v101 + 32) = v98[-2].n128_u64[0];
                *(__n128 *)v101 = v108;
                *(__n128 *)(v101 + 16) = v109;
                v110 = *(__int128 *)((char *)&v98[-2] + 8);
                *(_QWORD *)(v101 + 56) = v98[-1].n128_u64[1];
                *(_OWORD *)(v101 + 40) = v110;
                v98[-2].n128_u64[0] = v170;
                *a2 = v156;
                v98[-3] = v164;
                v98[-2].n128_u64[1] = v99;
                *(unint64_t *)((char *)v98[-1].n128_u64 + 7) = *(_QWORD *)&v135[7];
                v98[-1].n128_u64[0] = *(_QWORD *)v135;
                v98[-1].n128_u8[15] = v100;
                v111 = v101 - v7 + 64;
                if (v111 >= 65)
                {
                  v112 = (((unint64_t)v111 >> 6) - 2) >> 1;
                  v113 = v7 + (v112 << 6);
                  v114 = *(double *)v101;
                  if (*(double *)v101 < *(double *)v113)
                  {
                    v142 = *(_OWORD *)(v101 + 8);
                    v146 = *(_OWORD *)(v101 + 24);
                    v115 = *(_QWORD *)(v101 + 40);
                    *(_QWORD *)&v149[7] = *(_QWORD *)(v101 + 55);
                    *(_QWORD *)v149 = *(_QWORD *)(v101 + 48);
                    v116 = *(_BYTE *)(v101 + 63);
                    *(_QWORD *)(v101 + 40) = 0;
                    *(_QWORD *)(v101 + 48) = 0;
                    *(_QWORD *)(v101 + 56) = 0;
                    do
                    {
                      v117 = v101;
                      v101 = v113;
                      v118 = *(_OWORD *)v113;
                      v119 = *(_OWORD *)(v113 + 16);
                      *(_QWORD *)(v117 + 32) = *(_QWORD *)(v113 + 32);
                      *(_OWORD *)v117 = v118;
                      *(_OWORD *)(v117 + 16) = v119;
                      v120 = *(_OWORD *)(v113 + 40);
                      *(_QWORD *)(v117 + 56) = *(_QWORD *)(v113 + 56);
                      *(_OWORD *)(v117 + 40) = v120;
                      *(_BYTE *)(v113 + 63) = 0;
                      *(_BYTE *)(v113 + 40) = 0;
                      if (!v112)
                        break;
                      v112 = (v112 - 1) >> 1;
                      v113 = v7 + (v112 << 6);
                    }
                    while (v114 < *(double *)v113);
                    *(double *)v101 = v114;
                    *(_OWORD *)(v101 + 8) = v142;
                    *(_OWORD *)(v101 + 24) = v146;
                    *(_QWORD *)(v101 + 40) = v115;
                    *(_QWORD *)(v101 + 48) = *(_QWORD *)v149;
                    *(_QWORD *)(v101 + 55) = *(_QWORD *)&v149[7];
                    *(_BYTE *)(v101 + 63) = v116;
                  }
                }
              }
            }
            while (v96-- > 2);
          }
          return;
        }
        v10 = v9 >> 1;
        v11 = v7 + (v9 >> 1 << 6);
        if ((unint64_t)v8 <= 0x2000)
        {
          std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,CLMicroLocationLearner::fetchAndFilterUniqueLOIGroups(void)::$_1 &,CLMiLoLoiTable::Entry *>(a1 + (v9 >> 1 << 6), (__n128 *)a1, v131);
        }
        else
        {
          std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,CLMicroLocationLearner::fetchAndFilterUniqueLOIGroups(void)::$_1 &,CLMiLoLoiTable::Entry *>(a1, (__n128 *)(a1 + (v9 >> 1 << 6)), v131);
          std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,CLMicroLocationLearner::fetchAndFilterUniqueLOIGroups(void)::$_1 &,CLMiLoLoiTable::Entry *>(a1 + 64, (__n128 *)(v11 - 64), a2 - 8);
          std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,CLMicroLocationLearner::fetchAndFilterUniqueLOIGroups(void)::$_1 &,CLMiLoLoiTable::Entry *>(a1 + 128, (__n128 *)(a1 + 64 + (v10 << 6)), a2 - 12);
          std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,CLMicroLocationLearner::fetchAndFilterUniqueLOIGroups(void)::$_1 &,CLMiLoLoiTable::Entry *>(v11 - 64, (__n128 *)v11, (__n128 *)(a1 + 64 + (v10 << 6)));
          v12 = *(_QWORD *)(a1 + 40);
          v166 = *(_QWORD *)(a1 + 32);
          v150 = *(__n128 *)a1;
          v158 = *(_OWORD *)(a1 + 16);
          *(_QWORD *)((char *)&v136 + 7) = *(_QWORD *)(a1 + 55);
          *(_QWORD *)&v136 = *(_QWORD *)(a1 + 48);
          v13 = *(_BYTE *)(a1 + 63);
          *(_QWORD *)(a1 + 48) = 0;
          *(_QWORD *)(a1 + 56) = 0;
          v15 = *(__n128 *)v11;
          v14 = *(_OWORD *)(v11 + 16);
          *(_QWORD *)(a1 + 32) = *(_QWORD *)(v11 + 32);
          *(_QWORD *)(a1 + 40) = 0;
          *(__n128 *)a1 = v15;
          *(_OWORD *)(a1 + 16) = v14;
          v16 = *(_QWORD *)(v11 + 56);
          *(_OWORD *)(a1 + 40) = *(_OWORD *)(v11 + 40);
          *(_QWORD *)(a1 + 56) = v16;
          *(__n128 *)v11 = v150;
          *(_OWORD *)(v11 + 16) = v158;
          *(_QWORD *)(v11 + 32) = v166;
          *(_QWORD *)(v11 + 40) = v12;
          *(_QWORD *)(v11 + 55) = *(_QWORD *)((char *)&v136 + 7);
          *(_QWORD *)(v11 + 48) = v136;
          *(_BYTE *)(v11 + 63) = v13;
        }
        --a3;
        v17 = *(double *)a1;
        if ((a4 & 1) == 0 && v17 >= *(double *)(a1 - 64))
        {
          v40 = (void **)(a1 + 40);
          v41 = *(_QWORD *)(a1 + 40);
          v138 = *(_OWORD *)(a1 + 8);
          v145 = *(_OWORD *)(a1 + 24);
          *(_QWORD *)v134 = *(_QWORD *)(a1 + 48);
          *(_QWORD *)&v134[7] = *(_QWORD *)(a1 + 55);
          v42 = *(_BYTE *)(a1 + 63);
          *(_QWORD *)(a1 + 48) = 0;
          *(_QWORD *)(a1 + 56) = 0;
          *(_QWORD *)(a1 + 40) = 0;
          if (v131->n128_f64[0] >= v17)
          {
            v44 = a1 + 64;
            do
            {
              v7 = v44;
              if (v44 >= (unint64_t)a2)
                break;
              v44 += 64;
            }
            while (*(double *)v7 >= v17);
          }
          else
          {
            v7 = a1;
            do
            {
              v43 = *(double *)(v7 + 64);
              v7 += 64;
            }
            while (v43 >= v17);
          }
          v45 = a2;
          if (v7 < (unint64_t)a2)
          {
            v45 = a2;
            do
            {
              v46 = v45[-4].n128_f64[0];
              v45 -= 4;
            }
            while (v46 < v17);
          }
          while (v7 < (unint64_t)v45)
          {
            v47 = *(_QWORD *)(v7 + 40);
            v168 = *(_QWORD *)(v7 + 32);
            v152 = *(__n128 *)v7;
            v160 = *(__n128 *)(v7 + 16);
            *(_QWORD *)&v148 = *(_QWORD *)(v7 + 48);
            *(_QWORD *)((char *)&v148 + 7) = *(_QWORD *)(v7 + 55);
            v48 = *(_BYTE *)(v7 + 63);
            *(_QWORD *)(v7 + 40) = 0;
            *(_QWORD *)(v7 + 48) = 0;
            *(_QWORD *)(v7 + 56) = 0;
            v49 = *v45;
            v50 = v45[1];
            *(_QWORD *)(v7 + 32) = v45[2].n128_u64[0];
            *(__n128 *)v7 = v49;
            *(__n128 *)(v7 + 16) = v50;
            v51 = *(__int128 *)((char *)&v45[2] + 8);
            *(_QWORD *)(v7 + 56) = v45[3].n128_u64[1];
            *(_OWORD *)(v7 + 40) = v51;
            *v45 = v152;
            v45[1] = v160;
            v45[2].n128_u64[0] = v168;
            v45[2].n128_u64[1] = v47;
            v45[3].n128_u64[0] = v148;
            *(unint64_t *)((char *)v45[3].n128_u64 + 7) = *(_QWORD *)((char *)&v148 + 7);
            v45[3].n128_u8[15] = v48;
            do
            {
              v52 = *(double *)(v7 + 64);
              v7 += 64;
            }
            while (v52 >= v17);
            do
            {
              v53 = v45[-4].n128_f64[0];
              v45 -= 4;
            }
            while (v53 < v17);
          }
          if (v7 - 64 == a1)
          {
            v57 = *(char *)(v7 - 1);
            *(double *)a1 = v17;
            *(_OWORD *)(v7 - 40) = v145;
            *(_OWORD *)(v7 - 56) = v138;
            if (v57 < 0)
              operator delete(*(void **)(v7 - 24));
          }
          else
          {
            v54 = *(_OWORD *)(v7 - 64);
            v55 = *(_OWORD *)(v7 - 48);
            *(_QWORD *)(a1 + 32) = *(_QWORD *)(v7 - 32);
            *(_OWORD *)a1 = v54;
            *(_OWORD *)(a1 + 16) = v55;
            if (*(char *)(a1 + 63) < 0)
              operator delete(*v40);
            v56 = *(_OWORD *)(v7 - 24);
            *(_QWORD *)(a1 + 56) = *(_QWORD *)(v7 - 8);
            *(_OWORD *)v40 = v56;
            *(_BYTE *)(v7 - 1) = 0;
            *(_BYTE *)(v7 - 24) = 0;
            *(double *)(v7 - 64) = v17;
            *(_OWORD *)(v7 - 40) = v145;
            *(_OWORD *)(v7 - 56) = v138;
          }
          a4 = 0;
          *(_QWORD *)(v7 - 24) = v41;
          *(_QWORD *)(v7 - 9) = *(_QWORD *)&v134[7];
          *(_QWORD *)(v7 - 16) = *(_QWORD *)v134;
          *(_BYTE *)(v7 - 1) = v42;
          continue;
        }
        v18 = 0;
        v19 = (void **)(a1 + 40);
        v20 = *(_QWORD *)(a1 + 40);
        v137 = *(_OWORD *)(a1 + 8);
        v144 = *(_OWORD *)(a1 + 24);
        *(_QWORD *)v133 = *(_QWORD *)(a1 + 48);
        *(_QWORD *)&v133[7] = *(_QWORD *)(a1 + 55);
        v21 = *(_BYTE *)(a1 + 63);
        *(_QWORD *)(a1 + 48) = 0;
        *(_QWORD *)(a1 + 56) = 0;
        *(_QWORD *)(a1 + 40) = 0;
        do
        {
          v22 = *(double *)(a1 + v18 + 64);
          v18 += 64;
        }
        while (v17 < v22);
        v23 = a1 + v18;
        v24 = a2;
        if (v18 == 64)
        {
          v24 = a2;
          do
          {
            if (v23 >= (unint64_t)v24)
              break;
            v26 = v24[-4].n128_f64[0];
            v24 -= 4;
          }
          while (v17 >= v26);
        }
        else
        {
          do
          {
            v25 = v24[-4].n128_f64[0];
            v24 -= 4;
          }
          while (v17 >= v25);
        }
        v7 = a1 + v18;
        if (v23 < (unint64_t)v24)
        {
          v27 = (unint64_t)v24;
          do
          {
            v28 = *(_QWORD *)(v7 + 40);
            v167 = *(_QWORD *)(v7 + 32);
            v151 = *(__n128 *)v7;
            v159 = *(_OWORD *)(v7 + 16);
            *(_QWORD *)&v147 = *(_QWORD *)(v7 + 48);
            *(_QWORD *)((char *)&v147 + 7) = *(_QWORD *)(v7 + 55);
            v29 = *(_BYTE *)(v7 + 63);
            *(_QWORD *)(v7 + 40) = 0;
            *(_QWORD *)(v7 + 48) = 0;
            *(_QWORD *)(v7 + 56) = 0;
            v30 = *(_OWORD *)v27;
            v31 = *(_OWORD *)(v27 + 16);
            *(_QWORD *)(v7 + 32) = *(_QWORD *)(v27 + 32);
            *(_OWORD *)v7 = v30;
            *(_OWORD *)(v7 + 16) = v31;
            v32 = *(_OWORD *)(v27 + 40);
            *(_QWORD *)(v7 + 56) = *(_QWORD *)(v27 + 56);
            *(_OWORD *)(v7 + 40) = v32;
            *(__n128 *)v27 = v151;
            *(_OWORD *)(v27 + 16) = v159;
            *(_QWORD *)(v27 + 32) = v167;
            *(_QWORD *)(v27 + 40) = v28;
            *(_QWORD *)(v27 + 48) = v147;
            *(_QWORD *)(v27 + 55) = *(_QWORD *)((char *)&v147 + 7);
            *(_BYTE *)(v27 + 63) = v29;
            do
            {
              v33 = *(double *)(v7 + 64);
              v7 += 64;
            }
            while (v17 < v33);
            do
            {
              v34 = *(double *)(v27 - 64);
              v27 -= 64;
            }
            while (v17 >= v34);
          }
          while (v7 < v27);
        }
        if (v7 - 64 == a1)
        {
          v38 = *(char *)(v7 - 1);
          *(double *)a1 = v17;
          *(_OWORD *)(v7 - 40) = v144;
          *(_OWORD *)(v7 - 56) = v137;
          if (v38 < 0)
            operator delete(*(void **)(v7 - 24));
        }
        else
        {
          v35 = *(_OWORD *)(v7 - 64);
          v36 = *(_OWORD *)(v7 - 48);
          *(_QWORD *)(a1 + 32) = *(_QWORD *)(v7 - 32);
          *(_OWORD *)a1 = v35;
          *(_OWORD *)(a1 + 16) = v36;
          if (*(char *)(a1 + 63) < 0)
            operator delete(*v19);
          v37 = *(_OWORD *)(v7 - 24);
          *(_QWORD *)(a1 + 56) = *(_QWORD *)(v7 - 8);
          *(_OWORD *)v19 = v37;
          *(_BYTE *)(v7 - 1) = 0;
          *(_BYTE *)(v7 - 24) = 0;
          *(double *)(v7 - 64) = v17;
          *(_OWORD *)(v7 - 40) = v144;
          *(_OWORD *)(v7 - 56) = v137;
        }
        *(_QWORD *)(v7 - 24) = v20;
        *(_QWORD *)(v7 - 9) = *(_QWORD *)&v133[7];
        *(_QWORD *)(v7 - 16) = *(_QWORD *)v133;
        *(_BYTE *)(v7 - 1) = v21;
        if (v23 < (unint64_t)v24)
        {
LABEL_33:
          std::__introsort<std::_ClassicAlgPolicy,CLMicroLocationLearner::fetchAndFilterUniqueLOIGroups(void)::$_1 &,CLMiLoLoiTable::Entry *,false>(a1, v7 - 64, a3, a4 & 1);
          a4 = 0;
          continue;
        }
        v39 = std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,CLMicroLocationLearner::fetchAndFilterUniqueLOIGroups(void)::$_1 &,CLMiLoLoiTable::Entry *>(a1, v7 - 64);
        if (!std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,CLMicroLocationLearner::fetchAndFilterUniqueLOIGroups(void)::$_1 &,CLMiLoLoiTable::Entry *>(v7, (uint64_t)a2))
        {
          if (v39)
            continue;
          goto LABEL_33;
        }
        a2 = (__n128 *)(v7 - 64);
        if (!v39)
          goto LABEL_1;
        return;
    }
  }
}

  v8 = a1;
  while (2)
  {
    a1 = v8;
    v9 = (uint64_t)a2 - v8;
    v10 = (uint64_t)((uint64_t)a2 - v8) >> 5;
    switch(v10)
    {
      case 0uLL:
      case 1uLL:
        return;
      case 2uLL:
        if (*(double *)(v8 + 24) < a2[-1].n128_f64[1])
        {
          v105 = *(__n128 *)v8;
          v114 = *(__n128 *)(v8 + 16);
          v42 = a2[-1];
          *(__n128 *)v8 = a2[-2];
          *(__n128 *)(v8 + 16) = v42;
          a2[-2] = v105;
          a2[-1] = v114;
        }
        return;
      case 3uLL:
        std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,CLMicroLocationLearner::learnLocationSimilarityListModel(NSMutableDictionary *,std::function<BOOL ()(void)> const&,CLMicroLocationClientUtils::ClientIdAndClientServiceId const&,CLMicroLocationModel &,std::chrono::time_point<cl::chrono::CFAbsoluteTimeClock,std::chrono::duration<long double,std::ratio<1l,1l>>>,boost::uuids::uuid const&,std::vector<CLMicroLocationProto::EventType>,std::vector<CLMicroLocationRecordingEventsTable::Entry> const&,std::optional<CLMicroLocationLearner::ModelStabilityParameters> const&)::$_3 &,CLMicroLocationLearner::learnLocationSimilarityListModel(NSMutableDictionary *,std::function<BOOL ()(void)> const&,CLMicroLocationClientUtils::ClientIdAndClientServiceId const&,CLMicroLocationModel &,std::chrono::time_point<cl::chrono::CFAbsoluteTimeClock,std::chrono::duration<long double,std::ratio<1l,1l>>>,boost::uuids::uuid const&,std::vector<CLMicroLocationProto::EventType>,std::vector<CLMicroLocationRecordingEventsTable::Entry> const&,std::optional<CLMicroLocationLearner::ModelStabilityParameters> const&)::LabelConfidenceAndTime *>((double *)v8, (double *)(v8 + 32), a2[-2].n128_f64);
        return;
      case 4uLL:
        std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,CLMicroLocationLearner::learnLocationSimilarityListModel(NSMutableDictionary *,std::function<BOOL ()(void)> const&,CLMicroLocationClientUtils::ClientIdAndClientServiceId const&,CLMicroLocationModel &,std::chrono::time_point<cl::chrono::CFAbsoluteTimeClock,std::chrono::duration<long double,std::ratio<1l,1l>>>,boost::uuids::uuid const&,std::vector<CLMicroLocationProto::EventType>,std::vector<CLMicroLocationRecordingEventsTable::Entry> const&,std::optional<CLMicroLocationLearner::ModelStabilityParameters> const&)::$_3 &,CLMicroLocationLearner::learnLocationSimilarityListModel(NSMutableDictionary *,std::function<BOOL ()(void)> const&,CLMicroLocationClientUtils::ClientIdAndClientServiceId const&,CLMicroLocationModel &,std::chrono::time_point<cl::chrono::CFAbsoluteTimeClock,std::chrono::duration<long double,std::ratio<1l,1l>>>,boost::uuids::uuid const&,std::vector<CLMicroLocationProto::EventType>,std::vector<CLMicroLocationRecordingEventsTable::Entry> const&,std::optional<CLMicroLocationLearner::ModelStabilityParameters> const&)::LabelConfidenceAndTime *>((__n128 *)v8, (__n128 *)(v8 + 32), (__n128 *)(v8 + 64), a2 - 2);
        return;
      case 5uLL:
        v43 = (__n128 *)(v8 + 32);
        v44 = (__n128 *)(v8 + 64);
        v45 = (__n128 *)(v8 + 96);
        std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,CLMicroLocationLearner::learnLocationSimilarityListModel(NSMutableDictionary *,std::function<BOOL ()(void)> const&,CLMicroLocationClientUtils::ClientIdAndClientServiceId const&,CLMicroLocationModel &,std::chrono::time_point<cl::chrono::CFAbsoluteTimeClock,std::chrono::duration<long double,std::ratio<1l,1l>>>,boost::uuids::uuid const&,std::vector<CLMicroLocationProto::EventType>,std::vector<CLMicroLocationRecordingEventsTable::Entry> const&,std::optional<CLMicroLocationLearner::ModelStabilityParameters> const&)::$_3 &,CLMicroLocationLearner::learnLocationSimilarityListModel(NSMutableDictionary *,std::function<BOOL ()(void)> const&,CLMicroLocationClientUtils::ClientIdAndClientServiceId const&,CLMicroLocationModel &,std::chrono::time_point<cl::chrono::CFAbsoluteTimeClock,std::chrono::duration<long double,std::ratio<1l,1l>>>,boost::uuids::uuid const&,std::vector<CLMicroLocationProto::EventType>,std::vector<CLMicroLocationRecordingEventsTable::Entry> const&,std::optional<CLMicroLocationLearner::ModelStabilityParameters> const&)::LabelConfidenceAndTime *>((__n128 *)v8, (__n128 *)(v8 + 32), (__n128 *)(v8 + 64), (__n128 *)(v8 + 96));
        if (*(double *)(v8 + 120) < a2[-1].n128_f64[1])
        {
          v46 = *v45;
          v115 = *(__n128 *)(v8 + 112);
          v47 = a2[-1];
          *v45 = a2[-2];
          *(__n128 *)(v8 + 112) = v47;
          a2[-2] = v46;
          a2[-1] = v115;
          if (*(double *)(v8 + 88) < *(double *)(v8 + 120))
          {
            v49 = *v44;
            v48 = *(_OWORD *)(v8 + 80);
            v50 = *(_OWORD *)(v8 + 112);
            *v44 = *v45;
            *(_OWORD *)(v8 + 80) = v50;
            *v45 = v49;
            *(_OWORD *)(v8 + 112) = v48;
            if (*(double *)(v8 + 56) < *(double *)(v8 + 88))
            {
              v52 = *v43;
              v51 = *(_OWORD *)(v8 + 48);
              v53 = *(_OWORD *)(v8 + 80);
              *v43 = *v44;
              *(_OWORD *)(v8 + 48) = v53;
              *v44 = v52;
              *(_OWORD *)(v8 + 80) = v51;
              if (*(double *)(v8 + 24) < *(double *)(v8 + 56))
              {
                v106 = *(__n128 *)v8;
                v116 = *(_OWORD *)(v8 + 16);
                v54 = *(_OWORD *)(v8 + 48);
                *(__n128 *)v8 = *v43;
                *(_OWORD *)(v8 + 16) = v54;
                *v43 = v106;
                *(_OWORD *)(v8 + 48) = v116;
              }
            }
          }
        }
        return;
      default:
        if (v9 <= 767)
        {
          v55 = (__n128 *)(v8 + 32);
          v57 = (__n128 *)v8 == a2 || v55 == a2;
          if ((a4 & 1) != 0)
          {
            if (!v57)
            {
              v58 = 0;
              v59 = v8;
              do
              {
                v60 = *(double *)(v59 + 24);
                v61 = *(double *)(v59 + 56);
                v59 = (unint64_t)v55;
                if (v60 < v61)
                {
                  v117 = v55[1].n128_i64[0];
                  v107 = *v55;
                  v62 = v58;
                  while (1)
                  {
                    v63 = v8 + v62;
                    v64 = *(_OWORD *)(v8 + v62 + 16);
                    *(_OWORD *)(v63 + 32) = *(_OWORD *)(v8 + v62);
                    *(_OWORD *)(v63 + 48) = v64;
                    if (!v62)
                      break;
                    v62 -= 32;
                    if (*(double *)(v63 - 8) >= v61)
                    {
                      v65 = v8 + v62 + 32;
                      goto LABEL_78;
                    }
                  }
                  v65 = v8;
LABEL_78:
                  *(_QWORD *)(v65 + 16) = v117;
                  *(__n128 *)v65 = v107;
                  *(double *)(v65 + 24) = v61;
                }
                v55 = (__n128 *)(v59 + 32);
                v58 += 32;
              }
              while ((__n128 *)(v59 + 32) != a2);
            }
          }
          else if (!v57)
          {
            do
            {
              v91 = *(double *)(a1 + 24);
              v92 = *(double *)(a1 + 56);
              a1 = (uint64_t)v55;
              if (v91 < v92)
              {
                v120 = v55[1].n128_i64[0];
                v110 = *v55;
                v93 = v55;
                do
                {
                  v94 = v93[-1];
                  *v93 = v93[-2];
                  v93[1] = v94;
                  v95 = v93[-3].n128_f64[1];
                  v93 -= 2;
                }
                while (v95 < v92);
                v93[1].n128_u64[0] = v120;
                *v93 = v110;
                v93[1].n128_f64[1] = v92;
              }
              v55 += 2;
            }
            while ((__n128 *)(a1 + 32) != a2);
          }
          return;
        }
        if (!a3)
        {
          if ((__n128 *)v8 != a2)
          {
            v66 = (v10 - 2) >> 1;
            v67 = v66;
            do
            {
              v68 = v67;
              if (v66 >= v67)
              {
                v69 = (2 * v67) | 1;
                v70 = v8 + 32 * v69;
                if (2 * v68 + 2 < (uint64_t)v10 && *(double *)(v70 + 56) < *(double *)(v70 + 24))
                {
                  v70 += 32;
                  v69 = 2 * v68 + 2;
                }
                v71 = *(double *)(v8 + 32 * v68 + 24);
                if (v71 >= *(double *)(v70 + 24))
                {
                  v72 = v8 + 32 * v68;
                  v118 = *(_QWORD *)(v72 + 16);
                  v108 = *(_OWORD *)v72;
                  do
                  {
                    v73 = (_OWORD *)v72;
                    v72 = v70;
                    v74 = *(_OWORD *)(v70 + 16);
                    *v73 = *(_OWORD *)v70;
                    v73[1] = v74;
                    if (v66 < v69)
                      break;
                    v75 = 2 * v69;
                    v69 = (2 * v69) | 1;
                    v70 = v8 + 32 * v69;
                    v76 = v75 + 2;
                    if (v76 < (uint64_t)v10 && *(double *)(v70 + 56) < *(double *)(v70 + 24))
                    {
                      v70 += 32;
                      v69 = v76;
                    }
                  }
                  while (v71 >= *(double *)(v70 + 24));
                  *(_QWORD *)(v72 + 16) = v118;
                  *(_OWORD *)v72 = v108;
                  *(double *)(v72 + 24) = v71;
                }
              }
              v67 = v68 - 1;
            }
            while (v68);
            v77 = (unint64_t)v9 >> 5;
            do
            {
              v78 = 0;
              v109 = *(__n128 *)v8;
              v119 = *(__n128 *)(v8 + 16);
              v79 = v8;
              do
              {
                v80 = (_OWORD *)v79;
                v79 += 32 * (v78 + 1);
                v81 = 2 * v78;
                v78 = (2 * v78) | 1;
                v82 = v81 + 2;
                if (v82 < v77 && *(double *)(v79 + 56) < *(double *)(v79 + 24))
                {
                  v79 += 32;
                  v78 = v82;
                }
                v83 = *(_OWORD *)(v79 + 16);
                *v80 = *(_OWORD *)v79;
                v80[1] = v83;
              }
              while (v78 <= (uint64_t)((unint64_t)(v77 - 2) >> 1));
              a2 -= 2;
              if ((__n128 *)v79 == a2)
              {
                *(__n128 *)v79 = v109;
                *(__n128 *)(v79 + 16) = v119;
              }
              else
              {
                v84 = a2[1];
                *(__n128 *)v79 = *a2;
                *(__n128 *)(v79 + 16) = v84;
                *a2 = v109;
                a2[1] = v119;
                v85 = v79 - v8 + 32;
                if (v85 >= 33)
                {
                  v86 = (((unint64_t)v85 >> 5) - 2) >> 1;
                  v87 = *(double *)(v79 + 24);
                  if (v87 < *(double *)(v8 + 32 * v86 + 24))
                  {
                    v101 = *(_QWORD *)(v79 + 16);
                    v98 = *(_OWORD *)v79;
                    do
                    {
                      v88 = (_OWORD *)v79;
                      v79 = v8 + 32 * v86;
                      v89 = *(_OWORD *)(v79 + 16);
                      *v88 = *(_OWORD *)v79;
                      v88[1] = v89;
                      if (!v86)
                        break;
                      v86 = (v86 - 1) >> 1;
                    }
                    while (v87 < *(double *)(v8 + 32 * v86 + 24));
                    *(_QWORD *)(v79 + 16) = v101;
                    *(_OWORD *)v79 = v98;
                    *(double *)(v79 + 24) = v87;
                  }
                }
              }
            }
            while (v77-- > 2);
          }
          return;
        }
        v11 = v10 >> 1;
        v12 = v8 + 32 * (v10 >> 1);
        if ((unint64_t)v9 <= 0x1000)
        {
          std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,CLMicroLocationLearner::learnLocationSimilarityListModel(NSMutableDictionary *,std::function<BOOL ()(void)> const&,CLMicroLocationClientUtils::ClientIdAndClientServiceId const&,CLMicroLocationModel &,std::chrono::time_point<cl::chrono::CFAbsoluteTimeClock,std::chrono::duration<long double,std::ratio<1l,1l>>>,boost::uuids::uuid const&,std::vector<CLMicroLocationProto::EventType>,std::vector<CLMicroLocationRecordingEventsTable::Entry> const&,std::optional<CLMicroLocationLearner::ModelStabilityParameters> const&)::$_3 &,CLMicroLocationLearner::learnLocationSimilarityListModel(NSMutableDictionary *,std::function<BOOL ()(void)> const&,CLMicroLocationClientUtils::ClientIdAndClientServiceId const&,CLMicroLocationModel &,std::chrono::time_point<cl::chrono::CFAbsoluteTimeClock,std::chrono::duration<long double,std::ratio<1l,1l>>>,boost::uuids::uuid const&,std::vector<CLMicroLocationProto::EventType>,std::vector<CLMicroLocationRecordingEventsTable::Entry> const&,std::optional<CLMicroLocationLearner::ModelStabilityParameters> const&)::LabelConfidenceAndTime *>((double *)(a1 + 32 * (v10 >> 1)), (double *)a1, a2[-2].n128_f64);
        }
        else
        {
          std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,CLMicroLocationLearner::learnLocationSimilarityListModel(NSMutableDictionary *,std::function<BOOL ()(void)> const&,CLMicroLocationClientUtils::ClientIdAndClientServiceId const&,CLMicroLocationModel &,std::chrono::time_point<cl::chrono::CFAbsoluteTimeClock,std::chrono::duration<long double,std::ratio<1l,1l>>>,boost::uuids::uuid const&,std::vector<CLMicroLocationProto::EventType>,std::vector<CLMicroLocationRecordingEventsTable::Entry> const&,std::optional<CLMicroLocationLearner::ModelStabilityParameters> const&)::$_3 &,CLMicroLocationLearner::learnLocationSimilarityListModel(NSMutableDictionary *,std::function<BOOL ()(void)> const&,CLMicroLocationClientUtils::ClientIdAndClientServiceId const&,CLMicroLocationModel &,std::chrono::time_point<cl::chrono::CFAbsoluteTimeClock,std::chrono::duration<long double,std::ratio<1l,1l>>>,boost::uuids::uuid const&,std::vector<CLMicroLocationProto::EventType>,std::vector<CLMicroLocationRecordingEventsTable::Entry> const&,std::optional<CLMicroLocationLearner::ModelStabilityParameters> const&)::LabelConfidenceAndTime *>((double *)a1, (double *)(a1 + 32 * (v10 >> 1)), a2[-2].n128_f64);
          std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,CLMicroLocationLearner::learnLocationSimilarityListModel(NSMutableDictionary *,std::function<BOOL ()(void)> const&,CLMicroLocationClientUtils::ClientIdAndClientServiceId const&,CLMicroLocationModel &,std::chrono::time_point<cl::chrono::CFAbsoluteTimeClock,std::chrono::duration<long double,std::ratio<1l,1l>>>,boost::uuids::uuid const&,std::vector<CLMicroLocationProto::EventType>,std::vector<CLMicroLocationRecordingEventsTable::Entry> const&,std::optional<CLMicroLocationLearner::ModelStabilityParameters> const&)::$_3 &,CLMicroLocationLearner::learnLocationSimilarityListModel(NSMutableDictionary *,std::function<BOOL ()(void)> const&,CLMicroLocationClientUtils::ClientIdAndClientServiceId const&,CLMicroLocationModel &,std::chrono::time_point<cl::chrono::CFAbsoluteTimeClock,std::chrono::duration<long double,std::ratio<1l,1l>>>,boost::uuids::uuid const&,std::vector<CLMicroLocationProto::EventType>,std::vector<CLMicroLocationRecordingEventsTable::Entry> const&,std::optional<CLMicroLocationLearner::ModelStabilityParameters> const&)::LabelConfidenceAndTime *>((double *)(a1 + 32), (double *)(v12 - 32), a2[-4].n128_f64);
          std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,CLMicroLocationLearner::learnLocationSimilarityListModel(NSMutableDictionary *,std::function<BOOL ()(void)> const&,CLMicroLocationClientUtils::ClientIdAndClientServiceId const&,CLMicroLocationModel &,std::chrono::time_point<cl::chrono::CFAbsoluteTimeClock,std::chrono::duration<long double,std::ratio<1l,1l>>>,boost::uuids::uuid const&,std::vector<CLMicroLocationProto::EventType>,std::vector<CLMicroLocationRecordingEventsTable::Entry> const&,std::optional<CLMicroLocationLearner::ModelStabilityParameters> const&)::$_3 &,CLMicroLocationLearner::learnLocationSimilarityListModel(NSMutableDictionary *,std::function<BOOL ()(void)> const&,CLMicroLocationClientUtils::ClientIdAndClientServiceId const&,CLMicroLocationModel &,std::chrono::time_point<cl::chrono::CFAbsoluteTimeClock,std::chrono::duration<long double,std::ratio<1l,1l>>>,boost::uuids::uuid const&,std::vector<CLMicroLocationProto::EventType>,std::vector<CLMicroLocationRecordingEventsTable::Entry> const&,std::optional<CLMicroLocationLearner::ModelStabilityParameters> const&)::LabelConfidenceAndTime *>((double *)(a1 + 64), (double *)(a1 + 32 + 32 * v11), a2[-6].n128_f64);
          std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,CLMicroLocationLearner::learnLocationSimilarityListModel(NSMutableDictionary *,std::function<BOOL ()(void)> const&,CLMicroLocationClientUtils::ClientIdAndClientServiceId const&,CLMicroLocationModel &,std::chrono::time_point<cl::chrono::CFAbsoluteTimeClock,std::chrono::duration<long double,std::ratio<1l,1l>>>,boost::uuids::uuid const&,std::vector<CLMicroLocationProto::EventType>,std::vector<CLMicroLocationRecordingEventsTable::Entry> const&,std::optional<CLMicroLocationLearner::ModelStabilityParameters> const&)::$_3 &,CLMicroLocationLearner::learnLocationSimilarityListModel(NSMutableDictionary *,std::function<BOOL ()(void)> const&,CLMicroLocationClientUtils::ClientIdAndClientServiceId const&,CLMicroLocationModel &,std::chrono::time_point<cl::chrono::CFAbsoluteTimeClock,std::chrono::duration<long double,std::ratio<1l,1l>>>,boost::uuids::uuid const&,std::vector<CLMicroLocationProto::EventType>,std::vector<CLMicroLocationRecordingEventsTable::Entry> const&,std::optional<CLMicroLocationLearner::ModelStabilityParameters> const&)::LabelConfidenceAndTime *>((double *)(v12 - 32), (double *)v12, (double *)(a1 + 32 + 32 * v11));
          v102 = *(_OWORD *)a1;
          v111 = *(_OWORD *)(a1 + 16);
          v13 = *(_OWORD *)(v12 + 16);
          *(_OWORD *)a1 = *(_OWORD *)v12;
          *(_OWORD *)(a1 + 16) = v13;
          *(_OWORD *)v12 = v102;
          *(_OWORD *)(v12 + 16) = v111;
        }
        --a3;
        if ((a4 & 1) == 0)
        {
          v14 = *(double *)(a1 + 24);
          if (v14 < *(double *)(a1 - 8))
            goto LABEL_11;
          v100 = *(_QWORD *)(a1 + 16);
          v97 = *(_OWORD *)a1;
          if (a2[-1].n128_f64[1] >= v14)
          {
            v32 = a1 + 32;
            do
            {
              v8 = v32;
              if (v32 >= (unint64_t)a2)
                break;
              v33 = *(double *)(v32 + 24);
              v32 += 32;
            }
            while (v33 >= v14);
          }
          else
          {
            v30 = a1;
            do
            {
              v8 = v30 + 32;
              v31 = *(double *)(v30 + 56);
              v30 += 32;
            }
            while (v31 >= v14);
          }
          v34 = a2;
          if (v8 < (unint64_t)a2)
          {
            v35 = a2;
            do
            {
              v34 = v35 - 2;
              v36 = v35[-1].n128_f64[1];
              v35 -= 2;
            }
            while (v36 < v14);
          }
          while (v8 < (unint64_t)v34)
          {
            v104 = *(__n128 *)v8;
            v113 = *(__n128 *)(v8 + 16);
            v37 = v34[1];
            *(__n128 *)v8 = *v34;
            *(__n128 *)(v8 + 16) = v37;
            *v34 = v104;
            v34[1] = v113;
            do
            {
              v38 = *(double *)(v8 + 56);
              v8 += 32;
            }
            while (v38 >= v14);
            do
            {
              v39 = v34[-1].n128_f64[1];
              v34 -= 2;
            }
            while (v39 < v14);
          }
          v40 = (_OWORD *)(v8 - 32);
          if (v8 - 32 != a1)
          {
            v41 = *(_OWORD *)(v8 - 16);
            *(_OWORD *)a1 = *v40;
            *(_OWORD *)(a1 + 16) = v41;
          }
          a4 = 0;
          *(_QWORD *)(v8 - 16) = v100;
          *v40 = v97;
          *(double *)(v8 - 8) = v14;
          continue;
        }
        v14 = *(double *)(a1 + 24);
LABEL_11:
        v15 = 0;
        v99 = *(_QWORD *)(a1 + 16);
        v96 = *(_OWORD *)a1;
        do
        {
          v16 = *(double *)(a1 + v15 + 56);
          v15 += 32;
        }
        while (v14 < v16);
        v17 = a1 + v15;
        v18 = a2;
        if (v15 == 32)
        {
          v21 = a2;
          while (v17 < (unint64_t)v21)
          {
            v19 = v21 - 2;
            v22 = v21[-1].n128_f64[1];
            v21 -= 2;
            if (v14 < v22)
              goto LABEL_21;
          }
          v19 = v21;
        }
        else
        {
          do
          {
            v19 = v18 - 2;
            v20 = v18[-1].n128_f64[1];
            v18 -= 2;
          }
          while (v14 >= v20);
        }
LABEL_21:
        v8 = v17;
        if (v17 < (unint64_t)v19)
        {
          v23 = v19;
          do
          {
            v103 = *(__n128 *)v8;
            v112 = *(__n128 *)(v8 + 16);
            v24 = v23[1];
            *(__n128 *)v8 = *v23;
            *(__n128 *)(v8 + 16) = v24;
            *v23 = v103;
            v23[1] = v112;
            do
            {
              v25 = *(double *)(v8 + 56);
              v8 += 32;
            }
            while (v14 < v25);
            do
            {
              v26 = v23[-1].n128_f64[1];
              v23 -= 2;
            }
            while (v14 >= v26);
          }
          while (v8 < (unint64_t)v23);
        }
        v27 = (_OWORD *)(v8 - 32);
        if (v8 - 32 != a1)
        {
          v28 = *(_OWORD *)(v8 - 16);
          *(_OWORD *)a1 = *v27;
          *(_OWORD *)(a1 + 16) = v28;
        }
        *(_QWORD *)(v8 - 16) = v99;
        *v27 = v96;
        *(double *)(v8 - 8) = v14;
        if (v17 < (unint64_t)v19)
        {
LABEL_32:
          std::__introsort<std::_ClassicAlgPolicy,CLMicroLocationLearner::learnLocationSimilarityListModel(NSMutableDictionary *,std::function<BOOL ()(void)> const&,CLMicroLocationClientUtils::ClientIdAndClientServiceId const&,CLMicroLocationModel &,std::chrono::time_point<cl::chrono::CFAbsoluteTimeClock,std::chrono::duration<long double,std::ratio<1l,1l>>>,boost::uuids::uuid const&,std::vector<CLMicroLocationProto::EventType>,std::vector<CLMicroLocationRecordingEventsTable::Entry> const&,std::optional<CLMicroLocationLearner::ModelStabilityParameters> const&)::$_3 &,CLMicroLocationLearner::learnLocationSimilarityListModel(NSMutableDictionary *,std::function<BOOL ()(void)> const&,CLMicroLocationClientUtils::ClientIdAndClientServiceId const&,CLMicroLocationModel &,std::chrono::time_point<cl::chrono::CFAbsoluteTimeClock,std::chrono::duration<long double,std::ratio<1l,1l>>>,boost::uuids::uuid const&,std::vector<CLMicroLocationProto::EventType>,std::vector<CLMicroLocationRecordingEventsTable::Entry> const&,std::optional<CLMicroLocationLearner::ModelStabilityParameters> const&)::LabelConfidenceAndTime *,false>(a1, v8 - 32, a3, a4 & 1);
          a4 = 0;
          continue;
        }
        v29 = std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,CLMicroLocationLearner::learnLocationSimilarityListModel(NSMutableDictionary *,std::function<BOOL ()(void)> const&,CLMicroLocationClientUtils::ClientIdAndClientServiceId const&,CLMicroLocationModel &,std::chrono::time_point<cl::chrono::CFAbsoluteTimeClock,std::chrono::duration<long double,std::ratio<1l,1l>>>,boost::uuids::uuid const&,std::vector<CLMicroLocationProto::EventType>,std::vector<CLMicroLocationRecordingEventsTable::Entry> const&,std::optional<CLMicroLocationLearner::ModelStabilityParameters> const&)::$_3 &,CLMicroLocationLearner::learnLocationSimilarityListModel(NSMutableDictionary *,std::function<BOOL ()(void)> const&,CLMicroLocationClientUtils::ClientIdAndClientServiceId const&,CLMicroLocationModel &,std::chrono::time_point<cl::chrono::CFAbsoluteTimeClock,std::chrono::duration<long double,std::ratio<1l,1l>>>,boost::uuids::uuid const&,std::vector<CLMicroLocationProto::EventType>,std::vector<CLMicroLocationRecordingEventsTable::Entry> const&,std::optional<CLMicroLocationLearner::ModelStabilityParameters> const&)::LabelConfidenceAndTime *>(a1, v8 - 32);
        if (!std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,CLMicroLocationLearner::learnLocationSimilarityListModel(NSMutableDictionary *,std::function<BOOL ()(void)> const&,CLMicroLocationClientUtils::ClientIdAndClientServiceId const&,CLMicroLocationModel &,std::chrono::time_point<cl::chrono::CFAbsoluteTimeClock,std::chrono::duration<long double,std::ratio<1l,1l>>>,boost::uuids::uuid const&,std::vector<CLMicroLocationProto::EventType>,std::vector<CLMicroLocationRecordingEventsTable::Entry> const&,std::optional<CLMicroLocationLearner::ModelStabilityParameters> const&)::$_3 &,CLMicroLocationLearner::learnLocationSimilarityListModel(NSMutableDictionary *,std::function<BOOL ()(void)> const&,CLMicroLocationClientUtils::ClientIdAndClientServiceId const&,CLMicroLocationModel &,std::chrono::time_point<cl::chrono::CFAbsoluteTimeClock,std::chrono::duration<long double,std::ratio<1l,1l>>>,boost::uuids::uuid const&,std::vector<CLMicroLocationProto::EventType>,std::vector<CLMicroLocationRecordingEventsTable::Entry> const&,std::optional<CLMicroLocationLearner::ModelStabilityParameters> const&)::LabelConfidenceAndTime *>(v8, (uint64_t)a2))
        {
          if (v29)
            continue;
          goto LABEL_32;
        }
        a2 = (__n128 *)(v8 - 32);
        if (!v29)
          goto LABEL_1;
        return;
    }
  }
}

unint64_t *std::__insertion_sort[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,boost::uuids::uuid *>(unint64_t *result, unint64_t *a2)
{
  unint64_t *v2;
  uint64_t v3;
  unint64_t *v4;
  unint64_t *v5;
  unint64_t v6;
  unint64_t v7;
  int v8;
  uint64_t v9;
  char *v10;
  unint64_t v11;
  unint64_t v12;
  int v13;
  unint64_t *v14;
  __int128 v15;

  if (result != a2)
  {
    v2 = result + 2;
    if (result + 2 != a2)
    {
      v3 = 0;
      v4 = result;
      do
      {
        v5 = v2;
        v6 = bswap64(v4[2]);
        v7 = bswap64(*v4);
        if (v6 != v7 || (v6 = bswap64(v5[1]), v7 = bswap64(v4[1]), v6 != v7))
        {
          v8 = v6 < v7 ? -1 : 1;
          if (v8 < 0)
          {
            v15 = *(_OWORD *)v5;
            v9 = v3;
            while (1)
            {
              v10 = (char *)result + v9;
              *(_OWORD *)((char *)result + v9 + 16) = *(_OWORD *)((char *)result + v9);
              if (!v9)
                break;
              v11 = bswap64(v15);
              v12 = bswap64(*((_QWORD *)v10 - 2));
              if (v11 == v12
                && (v11 = bswap64(*((unint64_t *)&v15 + 1)), v12 = bswap64(*((_QWORD *)v10 - 1)), v11 == v12))
              {
                v13 = 0;
              }
              else if (v11 < v12)
              {
                v13 = -1;
              }
              else
              {
                v13 = 1;
              }
              v9 -= 16;
              if ((v13 & 0x80000000) == 0)
              {
                v14 = (unint64_t *)((char *)result + v9 + 16);
                goto LABEL_21;
              }
            }
            v14 = result;
LABEL_21:
            *(_OWORD *)v14 = v15;
          }
        }
        v2 = v5 + 2;
        v3 += 16;
        v4 = v5;
      }
      while (v5 + 2 != a2);
    }
  }
  return result;
}

unint64_t *std::__insertion_sort_unguarded[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,boost::uuids::uuid *>(unint64_t *result, unint64_t *a2)
{
  unint64_t *v2;
  unint64_t *v3;
  unint64_t *v4;
  unint64_t v5;
  unint64_t v6;
  int v7;
  unint64_t *v8;
  unint64_t v9;
  unint64_t v10;
  int v11;
  __int128 v12;

  if (result != a2)
  {
    v2 = result + 2;
    if (result + 2 != a2)
    {
      v3 = result - 2;
      do
      {
        v4 = v2;
        v5 = bswap64(*v2);
        v6 = bswap64(*result);
        if (v5 != v6 || (v5 = bswap64(v4[1]), v6 = bswap64(result[1]), v5 != v6))
        {
          v7 = v5 < v6 ? -1 : 1;
          if (v7 < 0)
          {
            v12 = *(_OWORD *)v4;
            v8 = v3;
            do
            {
              *((_OWORD *)v8 + 2) = *((_OWORD *)v8 + 1);
              v9 = bswap64(v12);
              v10 = bswap64(*v8);
              if (v9 == v10 && (v9 = bswap64(*((unint64_t *)&v12 + 1)), v10 = bswap64(v8[1]), v9 == v10))
              {
                v11 = 0;
              }
              else if (v9 < v10)
              {
                v11 = -1;
              }
              else
              {
                v11 = 1;
              }
              v8 -= 2;
            }
            while (v11 < 0);
            *((_OWORD *)v8 + 2) = v12;
          }
        }
        v2 = v4 + 2;
        v3 += 2;
        result = v4;
      }
      while (v4 + 2 != a2);
    }
  }
  return result;
}

uint64_t std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,boost::uuids::uuid *>(unint64_t *a1, unint64_t *a2, unint64_t *a3)
{
  unint64_t v3;
  unint64_t v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  int v8;
  __int128 v9;
  unint64_t v10;
  unint64_t v11;
  __int128 v13;
  unint64_t v14;
  unint64_t v15;
  int v16;
  __int128 v17;
  int v18;
  __int128 v19;
  __int128 v20;

  v3 = bswap64(*a2);
  v4 = bswap64(*a1);
  if (v3 == v4 && (v3 = bswap64(a2[1]), v4 = bswap64(a1[1]), v3 == v4))
  {
    v5 = 0;
  }
  else if (v3 < v4)
  {
    v5 = -1;
  }
  else
  {
    v5 = 1;
  }
  v6 = bswap64(*a3);
  v7 = bswap64(*a2);
  if (v6 == v7 && (v6 = bswap64(a3[1]), v7 = bswap64(a2[1]), v6 == v7))
  {
    v8 = 0;
    if (v5 < 0)
      goto LABEL_10;
  }
  else
  {
    if (v6 < v7)
      v8 = -1;
    else
      v8 = 1;
    if (v5 < 0)
    {
LABEL_10:
      if (v8 < 0)
      {
        v20 = *(_OWORD *)a1;
        *(_OWORD *)a1 = *(_OWORD *)a3;
        *(_OWORD *)a3 = v20;
      }
      else
      {
        v9 = *(_OWORD *)a1;
        *(_OWORD *)a1 = *(_OWORD *)a2;
        *(_OWORD *)a2 = v9;
        v10 = bswap64(*a3);
        v11 = bswap64(*a2);
        if (v10 != v11 || (v10 = bswap64(a3[1]), v11 = bswap64(a2[1]), v10 != v11))
        {
          v16 = v10 < v11 ? -1 : 1;
          if (v16 < 0)
          {
            v17 = *(_OWORD *)a2;
            *(_OWORD *)a2 = *(_OWORD *)a3;
            *(_OWORD *)a3 = v17;
            return 2;
          }
        }
      }
      return 1;
    }
  }
  if ((v8 & 0x80000000) == 0)
    return 0;
  v13 = *(_OWORD *)a2;
  *(_OWORD *)a2 = *(_OWORD *)a3;
  *(_OWORD *)a3 = v13;
  v14 = bswap64(*a2);
  v15 = bswap64(*a1);
  if (v14 != v15 || (v14 = bswap64(a2[1]), v15 = bswap64(a1[1]), v14 != v15))
  {
    v18 = v14 < v15 ? -1 : 1;
    if (v18 < 0)
    {
      v19 = *(_OWORD *)a1;
      *(_OWORD *)a1 = *(_OWORD *)a2;
      *(_OWORD *)a2 = v19;
      return 2;
    }
  }
  return 1;
}

unint64_t *std::__partition_with_equals_on_left[abi:ne180100]<std::_ClassicAlgPolicy,boost::uuids::uuid *,std::__less<void,void> &>(unint64_t *a1, unint64_t *a2)
{
  unint64_t v2;
  unint64_t v3;
  unint64_t *v4;
  unint64_t *v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  int v9;
  int v10;
  unint64_t *v11;
  unint64_t v12;
  unint64_t v13;
  int v14;
  unint64_t *v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  int v19;
  unint64_t *v20;
  unint64_t v21;
  unint64_t v22;
  unint64_t v23;
  int v24;
  unint64_t *v25;
  unint64_t v26;
  unint64_t v27;
  unint64_t v28;
  int v29;
  unint64_t *v30;
  __int128 v32;
  __int128 v33;

  v32 = *(_OWORD *)a1;
  v2 = bswap64(*a1);
  v3 = bswap64(*(a2 - 2));
  if (v2 == v3 && (v2 = bswap64(*((unint64_t *)&v32 + 1)), v3 = bswap64(*(a2 - 1)), v2 == v3)
    || (v2 < v3 ? (v10 = -1) : (v10 = 1), (v10 & 0x80000000) == 0))
  {
    v11 = a1 + 2;
    do
    {
      v5 = v11;
      if (v11 >= a2)
        break;
      v12 = bswap64(v32);
      v13 = bswap64(*v5);
      if (v12 == v13 && (v12 = bswap64(*((unint64_t *)&v32 + 1)), v13 = bswap64(v5[1]), v12 == v13))
        v14 = 0;
      else
        v14 = v12 < v13 ? -1 : 1;
      v11 = v5 + 2;
    }
    while ((v14 & 0x80000000) == 0);
  }
  else
  {
    v4 = a1;
    v5 = a1;
    do
    {
      v6 = v5[2];
      v5 += 2;
      v7 = bswap64(v32);
      v8 = bswap64(v6);
      if (v7 == v8 && (v7 = bswap64(*((unint64_t *)&v32 + 1)), v8 = bswap64(v4[3]), v7 == v8))
      {
        v9 = 0;
      }
      else if (v7 < v8)
      {
        v9 = -1;
      }
      else
      {
        v9 = 1;
      }
      v4 = v5;
    }
    while ((v9 & 0x80000000) == 0);
  }
  if (v5 >= a2)
  {
    v15 = a2;
  }
  else
  {
    v15 = a2;
    do
    {
      v16 = *(v15 - 2);
      v15 -= 2;
      v17 = bswap64(v32);
      v18 = bswap64(v16);
      if (v17 == v18 && (v17 = bswap64(*((unint64_t *)&v32 + 1)), v18 = bswap64(*(a2 - 1)), v17 == v18))
      {
        v19 = 0;
      }
      else if (v17 < v18)
      {
        v19 = -1;
      }
      else
      {
        v19 = 1;
      }
      a2 = v15;
    }
    while (v19 < 0);
  }
  while (v5 < v15)
  {
    v33 = *(_OWORD *)v5;
    *(_OWORD *)v5 = *(_OWORD *)v15;
    *(_OWORD *)v15 = v33;
    v20 = v5;
    do
    {
      v21 = v5[2];
      v5 += 2;
      v22 = bswap64(v32);
      v23 = bswap64(v21);
      if (v22 == v23 && (v22 = bswap64(*((unint64_t *)&v32 + 1)), v23 = bswap64(v20[3]), v22 == v23))
      {
        v24 = 0;
      }
      else if (v22 < v23)
      {
        v24 = -1;
      }
      else
      {
        v24 = 1;
      }
      v20 = v5;
    }
    while ((v24 & 0x80000000) == 0);
    v25 = v15;
    do
    {
      v26 = *(v15 - 2);
      v15 -= 2;
      v27 = bswap64(v32);
      v28 = bswap64(v26);
      if (v27 == v28 && (v27 = bswap64(*((unint64_t *)&v32 + 1)), v28 = bswap64(*(v25 - 1)), v27 == v28))
      {
        v29 = 0;
      }
      else if (v27 < v28)
      {
        v29 = -1;
      }
      else
      {
        v29 = 1;
      }
      v25 = v15;
    }
    while (v29 < 0);
  }
  v30 = v5 - 2;
  if (v5 - 2 != a1)
    *(_OWORD *)a1 = *(_OWORD *)v30;
  *(_OWORD *)v30 = v32;
  return v5;
}

__int128 *std::__partition_with_equals_on_right[abi:ne180100]<std::_ClassicAlgPolicy,boost::uuids::uuid *,std::__less<void,void> &>(__int128 *a1, __int128 *a2)
{
  uint64_t v2;
  unint64_t v3;
  unint64_t v4;
  int v5;
  __int128 *v6;
  __int128 *v7;
  __int128 *v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  int v12;
  unint64_t v13;
  unint64_t v14;
  int v15;
  unint64_t v16;
  __int128 *v17;
  __int128 v18;
  unint64_t v19;
  unint64_t v20;
  unint64_t v21;
  unint64_t v22;
  int v23;
  __int128 *v24;
  unint64_t v25;
  unint64_t v26;
  unint64_t v27;
  int v28;
  __int128 v30;

  v2 = 0;
  v30 = *a1;
  do
  {
    v3 = bswap64(*(_QWORD *)&a1[v2 + 1]);
    v4 = bswap64(v30);
    if (v3 == v4
      && (v3 = bswap64(*((_QWORD *)&a1[v2 + 1] + 1)), v4 = bswap64(*((unint64_t *)&v30 + 1)), v3 == v4))
    {
      v5 = 0;
    }
    else if (v3 < v4)
    {
      v5 = -1;
    }
    else
    {
      v5 = 1;
    }
    ++v2;
  }
  while (v5 < 0);
  v6 = &a1[v2];
  v7 = &a1[v2 - 1];
  if (v2 == 1)
  {
    while (v6 < a2)
    {
      v8 = a2 - 1;
      v13 = bswap64(*((_QWORD *)a2 - 2));
      v14 = bswap64(v30);
      if (v13 == v14
        && (v13 = bswap64(*((_QWORD *)a2 - 1)), v14 = bswap64(*((unint64_t *)&v30 + 1)), v13 == v14))
      {
        v15 = 0;
      }
      else if (v13 < v14)
      {
        v15 = -1;
      }
      else
      {
        v15 = 1;
      }
      --a2;
      if (v15 < 0)
        goto LABEL_28;
    }
    v8 = a2;
  }
  else
  {
    v8 = a2;
    do
    {
      v9 = *((_QWORD *)v8-- - 2);
      v10 = bswap64(v9);
      v11 = bswap64(v30);
      if (v10 == v11
        && (v10 = bswap64(*((_QWORD *)a2 - 1)), v11 = bswap64(*((unint64_t *)&v30 + 1)), v10 == v11))
      {
        v12 = 0;
      }
      else if (v10 < v11)
      {
        v12 = -1;
      }
      else
      {
        v12 = 1;
      }
      a2 = v8;
    }
    while ((v12 & 0x80000000) == 0);
  }
LABEL_28:
  if (v6 < v8)
  {
    v16 = (unint64_t)v6;
    v17 = v8;
    do
    {
      v18 = *(_OWORD *)v16;
      *(_OWORD *)v16 = *v17;
      *v17 = v18;
      v19 = v16;
      do
      {
        v20 = *(_QWORD *)(v16 + 16);
        v16 += 16;
        v21 = bswap64(v20);
        v22 = bswap64(v30);
        if (v21 == v22
          && (v21 = bswap64(*(_QWORD *)(v19 + 24)), v22 = bswap64(*((unint64_t *)&v30 + 1)), v21 == v22))
        {
          v23 = 0;
        }
        else if (v21 < v22)
        {
          v23 = -1;
        }
        else
        {
          v23 = 1;
        }
        v19 = v16;
      }
      while (v23 < 0);
      v24 = v17;
      do
      {
        v25 = *((_QWORD *)v17-- - 2);
        v26 = bswap64(v25);
        v27 = bswap64(v30);
        if (v26 == v27
          && (v26 = bswap64(*((_QWORD *)v24 - 1)), v27 = bswap64(*((unint64_t *)&v30 + 1)), v26 == v27))
        {
          v28 = 0;
        }
        else if (v26 < v27)
        {
          v28 = -1;
        }
        else
        {
          v28 = 1;
        }
        v24 = v17;
      }
      while ((v28 & 0x80000000) == 0);
    }
    while (v16 < (unint64_t)v17);
    v7 = (__int128 *)(v16 - 16);
  }
  if (v7 != a1)
    *a1 = *v7;
  *v7 = v30;
  return v7;
}

BOOL std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,boost::uuids::uuid *>(unint64_t *a1, unint64_t *a2)
{
  uint64_t v4;
  _BOOL8 result;
  unint64_t *v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t *v9;
  unint64_t *v10;
  uint64_t v11;
  int v12;
  unint64_t v13;
  unint64_t v14;
  int v15;
  uint64_t v16;
  char *v17;
  unint64_t v18;
  unint64_t v19;
  int v20;
  unint64_t *v21;
  int v22;
  __int128 v23;
  __int128 v24;

  v4 = ((char *)a2 - (char *)a1) >> 4;
  result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      v6 = a2 - 2;
      v7 = bswap64(*(a2 - 2));
      v8 = bswap64(*a1);
      if (v7 != v8 || (v7 = bswap64(*(a2 - 1)), v8 = bswap64(a1[1]), v7 != v8))
      {
        if (v7 < v8)
          v22 = -1;
        else
          v22 = 1;
        if (v22 < 0)
        {
          v23 = *(_OWORD *)a1;
          *(_OWORD *)a1 = *(_OWORD *)v6;
          *(_OWORD *)v6 = v23;
        }
      }
      return result;
    case 3:
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,boost::uuids::uuid *>(a1, a1 + 2, a2 - 2);
      return 1;
    case 4:
      std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,boost::uuids::uuid *>(a1, a1 + 2, a1 + 4, a2 - 2);
      return 1;
    case 5:
      std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,boost::uuids::uuid *>(a1, a1 + 2, a1 + 4, a1 + 6, a2 - 2);
      return 1;
    default:
      v9 = a1 + 4;
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,boost::uuids::uuid *>(a1, a1 + 2, a1 + 4);
      v10 = a1 + 6;
      if (a1 + 6 == a2)
        return 1;
      v11 = 0;
      v12 = 0;
      break;
  }
  while (1)
  {
    v13 = bswap64(*v10);
    v14 = bswap64(*v9);
    if (v13 != v14 || (v13 = bswap64(v10[1]), v14 = bswap64(v9[1]), v13 != v14))
    {
      v15 = v13 < v14 ? -1 : 1;
      if (v15 < 0)
      {
        v24 = *(_OWORD *)v10;
        v16 = v11;
        while (1)
        {
          v17 = (char *)a1 + v16;
          *(_OWORD *)((char *)a1 + v16 + 48) = *(_OWORD *)((char *)a1 + v16 + 32);
          if (v16 == -32)
            break;
          v18 = bswap64(v24);
          v19 = bswap64(*((_QWORD *)v17 + 2));
          if (v18 == v19
            && (v18 = bswap64(*((unint64_t *)&v24 + 1)), v19 = bswap64(*((_QWORD *)v17 + 3)), v18 == v19))
          {
            v20 = 0;
          }
          else if (v18 < v19)
          {
            v20 = -1;
          }
          else
          {
            v20 = 1;
          }
          v16 -= 16;
          if ((v20 & 0x80000000) == 0)
          {
            v21 = (unint64_t *)((char *)a1 + v16 + 48);
            goto LABEL_24;
          }
        }
        v21 = a1;
LABEL_24:
        *(_OWORD *)v21 = v24;
        if (++v12 == 8)
          return v10 + 2 == a2;
      }
    }
    v9 = v10;
    v11 += 16;
    v10 += 2;
    if (v10 == a2)
      return 1;
  }
}

__n128 std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,boost::uuids::uuid *>(unint64_t *a1, unint64_t *a2, unint64_t *a3, unint64_t *a4)
{
  __n128 result;
  unint64_t v9;
  unint64_t v10;
  int v11;
  unint64_t v12;
  unint64_t v13;
  int v14;
  unint64_t v15;
  unint64_t v16;
  int v17;

  std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,boost::uuids::uuid *>(a1, a2, a3);
  v9 = bswap64(*a4);
  v10 = bswap64(*a3);
  if (v9 != v10 || (v9 = bswap64(a4[1]), v10 = bswap64(a3[1]), v9 != v10))
  {
    v11 = v9 < v10 ? -1 : 1;
    if (v11 < 0)
    {
      result = *(__n128 *)a3;
      *(_OWORD *)a3 = *(_OWORD *)a4;
      *(__n128 *)a4 = result;
      v12 = bswap64(*a3);
      v13 = bswap64(*a2);
      if (v12 != v13 || (v12 = bswap64(a3[1]), v13 = bswap64(a2[1]), v12 != v13))
      {
        v14 = v12 < v13 ? -1 : 1;
        if (v14 < 0)
        {
          result = *(__n128 *)a2;
          *(_OWORD *)a2 = *(_OWORD *)a3;
          *(__n128 *)a3 = result;
          v15 = bswap64(*a2);
          v16 = bswap64(*a1);
          if (v15 != v16 || (v15 = bswap64(a2[1]), v16 = bswap64(a1[1]), v15 != v16))
          {
            if (v15 < v16)
              v17 = -1;
            else
              v17 = 1;
            if (v17 < 0)
            {
              result = *(__n128 *)a1;
              *(_OWORD *)a1 = *(_OWORD *)a2;
              *(__n128 *)a2 = result;
            }
          }
        }
      }
    }
  }
  return result;
}

__n128 std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,boost::uuids::uuid *>(unint64_t *a1, unint64_t *a2, unint64_t *a3, unint64_t *a4, unint64_t *a5)
{
  __n128 result;
  unint64_t v11;
  unint64_t v12;
  int v13;
  unint64_t v14;
  unint64_t v15;
  int v16;
  unint64_t v17;
  unint64_t v18;
  int v19;
  unint64_t v20;
  unint64_t v21;
  int v22;

  result.n128_u64[0] = std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,boost::uuids::uuid *>(a1, a2, a3, a4).n128_u64[0];
  v11 = bswap64(*a5);
  v12 = bswap64(*a4);
  if (v11 != v12 || (v11 = bswap64(a5[1]), v12 = bswap64(a4[1]), v11 != v12))
  {
    v13 = v11 < v12 ? -1 : 1;
    if (v13 < 0)
    {
      result = *(__n128 *)a4;
      *(_OWORD *)a4 = *(_OWORD *)a5;
      *(__n128 *)a5 = result;
      v14 = bswap64(*a4);
      v15 = bswap64(*a3);
      if (v14 != v15 || (v14 = bswap64(a4[1]), v15 = bswap64(a3[1]), v14 != v15))
      {
        v16 = v14 < v15 ? -1 : 1;
        if (v16 < 0)
        {
          result = *(__n128 *)a3;
          *(_OWORD *)a3 = *(_OWORD *)a4;
          *(__n128 *)a4 = result;
          v17 = bswap64(*a3);
          v18 = bswap64(*a2);
          if (v17 != v18 || (v17 = bswap64(a3[1]), v18 = bswap64(a2[1]), v17 != v18))
          {
            v19 = v17 < v18 ? -1 : 1;
            if (v19 < 0)
            {
              result = *(__n128 *)a2;
              *(_OWORD *)a2 = *(_OWORD *)a3;
              *(__n128 *)a3 = result;
              v20 = bswap64(*a2);
              v21 = bswap64(*a1);
              if (v20 == v21 && (v20 = bswap64(a2[1]), v21 = bswap64(a1[1]), v20 == v21))
              {
                v22 = 0;
              }
              else if (v20 < v21)
              {
                v22 = -1;
              }
              else
              {
                v22 = 1;
              }
              if (v22 < 0)
              {
                result = *(__n128 *)a1;
                *(_OWORD *)a1 = *(_OWORD *)a2;
                *(__n128 *)a2 = result;
              }
            }
          }
        }
      }
    }
  }
  return result;
}

unint64_t *std::__partial_sort_impl[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,boost::uuids::uuid *,boost::uuids::uuid *>(unint64_t *a1, unint64_t *a2, unint64_t *a3, uint64_t a4)
{
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t *v12;
  unint64_t *v13;
  unint64_t *v14;
  unint64_t v15;
  unint64_t v16;
  int v17;
  __int128 v18;
  uint64_t v19;
  unint64_t *v20;
  unint64_t *v21;
  __int128 v24;

  if (a1 != a2)
  {
    v8 = (char *)a2 - (char *)a1;
    v9 = ((char *)a2 - (char *)a1) >> 4;
    if ((char *)a2 - (char *)a1 >= 17)
    {
      v10 = (unint64_t)(v9 - 2) >> 1;
      v11 = v10 + 1;
      v12 = &a1[2 * v10];
      do
      {
        std::__sift_down[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,boost::uuids::uuid *>((uint64_t)a1, a4, v9, v12);
        v12 -= 2;
        --v11;
      }
      while (v11);
    }
    v13 = a2;
    if (a2 != a3)
    {
      v14 = a2;
      do
      {
        v15 = bswap64(*v14);
        v16 = bswap64(*a1);
        if (v15 != v16 || (v15 = bswap64(v14[1]), v16 = bswap64(a1[1]), v15 != v16))
        {
          v17 = v15 < v16 ? -1 : 1;
          if (v17 < 0)
          {
            v18 = *(_OWORD *)v14;
            *(_OWORD *)v14 = *(_OWORD *)a1;
            *(_OWORD *)a1 = v18;
            std::__sift_down[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,boost::uuids::uuid *>((uint64_t)a1, a4, v9, a1);
          }
        }
        v14 += 2;
      }
      while (v14 != a3);
      v13 = a3;
    }
    if (v8 >= 17)
    {
      v19 = (unint64_t)v8 >> 4;
      v20 = a2 - 2;
      do
      {
        v24 = *(_OWORD *)a1;
        v21 = std::__floyd_sift_down[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,boost::uuids::uuid *>(a1, a4, v19);
        if (v20 == v21)
        {
          *(_OWORD *)v21 = v24;
        }
        else
        {
          *(_OWORD *)v21 = *(_OWORD *)v20;
          *(_OWORD *)v20 = v24;
          std::__sift_up[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,boost::uuids::uuid *>((uint64_t)a1, (uint64_t)(v21 + 2), a4, ((char *)(v21 + 2) - (char *)a1) >> 4);
        }
        v20 -= 2;
      }
      while (v19-- > 2);
    }
    return v13;
  }
  return a3;
}

__n128 std::__sift_down[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,boost::uuids::uuid *>(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t *a4)
{
  uint64_t v4;
  int64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t *v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  int v12;
  unint64_t v13;
  unint64_t v14;
  int v15;
  __n128 *v16;
  uint64_t v17;
  unint64_t v18;
  unint64_t v19;
  int v20;
  unint64_t v21;
  unint64_t v22;
  int v23;
  __n128 result;
  __n128 v25;

  if (a3 >= 2)
  {
    v4 = (uint64_t)a4 - a1;
    v5 = (unint64_t)(a3 - 2) >> 1;
    if (v5 >= ((uint64_t)a4 - a1) >> 4)
    {
      v6 = v4 >> 3;
      v7 = (v4 >> 3) + 1;
      v8 = (unint64_t *)(a1 + 16 * v7);
      v9 = v6 + 2;
      if (v9 < a3)
      {
        v10 = bswap64(*v8);
        v11 = bswap64(v8[2]);
        if (v10 == v11 && (v10 = bswap64(v8[1]), v11 = bswap64(v8[3]), v10 == v11))
          v12 = 0;
        else
          v12 = v10 < v11 ? -1 : 1;
        if (v12 < 0)
        {
          v8 += 2;
          v7 = v9;
        }
      }
      v13 = bswap64(*v8);
      v14 = bswap64(*a4);
      if (v13 == v14 && (v13 = bswap64(v8[1]), v14 = bswap64(a4[1]), v13 == v14)
        || (v13 < v14 ? (v15 = -1) : (v15 = 1), (v15 & 0x80000000) == 0))
      {
        v25 = *(__n128 *)a4;
        do
        {
          v16 = (__n128 *)v8;
          *(_OWORD *)a4 = *(_OWORD *)v8;
          if (v5 < v7)
            break;
          v17 = (2 * v7) | 1;
          v8 = (unint64_t *)(a1 + 16 * v17);
          v7 = 2 * v7 + 2;
          if (v7 >= a3)
          {
            v7 = v17;
          }
          else
          {
            v18 = bswap64(*v8);
            v19 = bswap64(v8[2]);
            if (v18 == v19 && (v18 = bswap64(v8[1]), v19 = bswap64(v8[3]), v18 == v19))
              v20 = 0;
            else
              v20 = v18 < v19 ? -1 : 1;
            if (v20 >= 0)
              v7 = v17;
            else
              v8 += 2;
          }
          v21 = bswap64(*v8);
          v22 = bswap64(v25.n128_u64[0]);
          if (v21 == v22 && (v21 = bswap64(v8[1]), v22 = bswap64(v25.n128_u64[1]), v21 == v22))
            v23 = 0;
          else
            v23 = v21 < v22 ? -1 : 1;
          a4 = (unint64_t *)v16;
        }
        while ((v23 & 0x80000000) == 0);
        result = v25;
        *v16 = v25;
      }
    }
  }
  return result;
}

unint64_t *std::__floyd_sift_down[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,boost::uuids::uuid *>(unint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  unint64_t *v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  int v11;

  v3 = 0;
  v4 = a3 - 2;
  if (a3 < 2)
    v4 = a3 - 1;
  v5 = v4 >> 1;
  do
  {
    v6 = &a1[2 * v3 + 2];
    v7 = (2 * v3) | 1;
    v8 = 2 * v3 + 2;
    if (v8 < a3)
    {
      v9 = bswap64(*v6);
      v10 = bswap64(v6[2]);
      if (v9 == v10 && (v9 = bswap64(v6[1]), v10 = bswap64(v6[3]), v9 == v10))
      {
        v11 = 0;
      }
      else if (v9 < v10)
      {
        v11 = -1;
      }
      else
      {
        v11 = 1;
      }
      if (v11 < 0)
      {
        v6 += 2;
        v7 = v8;
      }
    }
    *(_OWORD *)a1 = *(_OWORD *)v6;
    a1 = v6;
    v3 = v7;
  }
  while (v7 <= v5);
  return v6;
}

__n128 std::__sift_up[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,boost::uuids::uuid *>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v4;
  unint64_t *v5;
  __n128 *v6;
  unint64_t v7;
  unint64_t v8;
  int v9;
  __n128 *v10;
  unint64_t v11;
  unint64_t v12;
  int v13;
  __n128 result;
  __n128 v15;

  if (a4 >= 2)
  {
    v4 = (unint64_t)(a4 - 2) >> 1;
    v5 = (unint64_t *)(a1 + 16 * v4);
    v6 = (__n128 *)(a2 - 16);
    v7 = bswap64(*v5);
    v8 = bswap64(*(_QWORD *)(a2 - 16));
    if (v7 != v8 || (v7 = bswap64(v5[1]), v8 = bswap64(*(_QWORD *)(a2 - 8)), v7 != v8))
    {
      v9 = v7 < v8 ? -1 : 1;
      if (v9 < 0)
      {
        v15 = *v6;
        do
        {
          v10 = (__n128 *)v5;
          *v6 = *(__n128 *)v5;
          if (!v4)
            break;
          v4 = (v4 - 1) >> 1;
          v5 = (unint64_t *)(a1 + 16 * v4);
          v11 = bswap64(*v5);
          v12 = bswap64(v15.n128_u64[0]);
          if (v11 == v12 && (v11 = bswap64(v5[1]), v12 = bswap64(v15.n128_u64[1]), v11 == v12))
            v13 = 0;
          else
            v13 = v11 < v12 ? -1 : 1;
          v6 = v10;
        }
        while (v13 < 0);
        result = v15;
        *v10 = v15;
      }
    }
  }
  return result;
}

_QWORD *std::__unique[abi:ne180100]<std::_ClassicAlgPolicy,std::__wrap_iter<boost::uuids::uuid *>,std::__wrap_iter<boost::uuids::uuid *>,std::__equal_to &>(_QWORD *a1, _QWORD *a2)
{
  _QWORD *v2;
  _QWORD *v3;
  BOOL v4;
  _QWORD *v5;
  _QWORD *v6;

  v2 = a2;
  if (a1 != a2)
  {
    do
    {
      v3 = a1 + 2;
      if (a1 + 2 == a2)
        return a2;
      v4 = *a1 == a1[2] && a1[1] == a1[3];
      a1 += 2;
    }
    while (!v4);
    v5 = v3 + 2;
    v6 = v3 - 2;
    while (v5 != a2)
    {
      if (*v6 != *v5 || v6[1] != v5[1])
      {
        *((_OWORD *)v6 + 1) = *(_OWORD *)v5;
        v6 += 2;
      }
      v5 += 2;
    }
    return v6 + 2;
  }
  return v2;
}

uint64_t CLMicroLocationBluetoothIdentityTable::Entry::Entry(uint64_t a1, uint64_t a2, uint64_t a3, __int128 *a4, __int128 *a5, double a6)
{
  __int128 v9;
  std::string *v10;
  __int128 v11;

  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = a3;
  if (*((char *)a4 + 23) < 0)
  {
    std::string::__init_copy_ctor_external((std::string *)(a1 + 16), *(const std::string::value_type **)a4, *((_QWORD *)a4 + 1));
  }
  else
  {
    v9 = *a4;
    *(_QWORD *)(a1 + 32) = *((_QWORD *)a4 + 2);
    *(_OWORD *)(a1 + 16) = v9;
  }
  v10 = (std::string *)(a1 + 40);
  if (*((char *)a5 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v10, *(const std::string::value_type **)a5, *((_QWORD *)a5 + 1));
  }
  else
  {
    v11 = *a5;
    *(_QWORD *)(a1 + 56) = *((_QWORD *)a5 + 2);
    *(_OWORD *)&v10->__r_.__value_.__l.__data_ = v11;
  }
  *(double *)(a1 + 64) = a6;
  return a1;
}

void sub_241A11F3C(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void **v2;

  if (*(char *)(v1 + 39) < 0)
    operator delete(*v2);
  _Unwind_Resume(exception_object);
}

void sub_241A12114(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  uint64_t v3;
  void *v4;

  MEMORY[0x2426A04BC](v3, 0x1000C8077774924);
  _Unwind_Resume(a1);
}

void sub_241A123F0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,void *__p,uint64_t a48,int a49,__int16 a50,char a51,char a52)
{
  CLMicroLocationProto::ReceivedEvent *v52;

  CLMicroLocationProto::ReceivedEvent::~ReceivedEvent(v52);
  CLMicroLocationProto::ReceivedEvent::~ReceivedEvent((CLMicroLocationProto::ReceivedEvent *)&a9);
  _Unwind_Resume(a1);
}

void ___ZL45_CLLogObjectForCategory_MicroLocation_Defaultv_block_invoke_9()
{
  os_log_t v0;
  void *v1;

  v0 = os_log_create("com.apple.MicroLocation", "MicroLocation");
  v1 = (void *)logObject_MicroLocation_Default;
  logObject_MicroLocation_Default = (uint64_t)v0;

}

void sub_241A12560(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

uint64_t ULDBUtils::insertEntries<CLMicroLocationMigrationTable,ULMigrationMO>(void *a1, uint64_t a2)
{
  id v3;
  void *v4;
  id v5;
  uint64_t v6;
  _QWORD v8[4];
  id v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  char v15;

  v3 = a1;
  v12 = 0;
  v13 = &v12;
  v14 = 0x2020000000;
  v15 = 0;
  objc_msgSend(v3, "managedObjectContext");
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  v8[0] = MEMORY[0x24BDAC760];
  v8[1] = 3221225472;
  v8[2] = ___ZN9ULDBUtils13insertEntriesI29CLMicroLocationMigrationTable13ULMigrationMOEEbP7ULStoreRKNSt3__16vectorINT_5EntryENS5_9allocatorIS8_EEEE_block_invoke;
  v8[3] = &unk_2511D22D0;
  v11 = a2;
  v5 = v3;
  v9 = v5;
  v10 = &v12;
  objc_msgSend(v4, "performBlockAndWait:", v8);

  v6 = *((unsigned __int8 *)v13 + 24);
  _Block_object_dispose(&v12, 8);

  return v6;
}

void sub_241A12684(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, void *a7, uint64_t a8, uint64_t a9, ...)
{
  void *v9;
  void *v10;
  va_list va;

  va_start(va, a9);

  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void ULDBUtils::fetchEntries<CLMicroLocationMigrationTable,ULMigrationMO>(void *a1@<X0>, void *a2@<X1>, void *a3@<X2>, uint64_t a4@<X3>, _QWORD *a5@<X8>)
{
  id v9;
  id v10;
  id v11;
  void *v12;
  id v13;
  id v14;
  id v15;
  uint64_t *v16;
  _QWORD v17[4];
  id v18;
  id v19;
  id v20;
  uint64_t *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t *v24;
  uint64_t v25;
  __n128 (*v26)(__n128 *, __n128 *);
  void (*v27)(uint64_t);
  void *v28;
  void *__p;
  void *v30;
  uint64_t v31;

  v9 = a1;
  v10 = a2;
  v11 = a3;
  v23 = 0;
  v24 = &v23;
  v25 = 0x4812000000;
  v26 = __Block_byref_object_copy__2;
  v27 = __Block_byref_object_dispose__2;
  v28 = &unk_241BEBD1D;
  __p = 0;
  v30 = 0;
  v31 = 0;
  objc_msgSend(v9, "managedObjectContext");
  v12 = (void *)objc_claimAutoreleasedReturnValue();
  v17[0] = MEMORY[0x24BDAC760];
  v17[1] = 3221225472;
  v17[2] = ___ZN9ULDBUtils12fetchEntriesI29CLMicroLocationMigrationTable13ULMigrationMOEENSt3__16vectorINT_5EntryENS3_9allocatorIS6_EEEEP7ULStoreP7NSArrayIP11NSPredicateEPSC_IP16NSSortDescriptorEm_block_invoke;
  v17[3] = &unk_2511D22F8;
  v13 = v10;
  v18 = v13;
  v14 = v11;
  v19 = v14;
  v22 = a4;
  v15 = v9;
  v20 = v15;
  v21 = &v23;
  objc_msgSend(v12, "performBlockAndWait:", v17);

  v16 = v24;
  a5[1] = 0;
  a5[2] = 0;
  *a5 = 0;
  std::vector<CLMicroLocationMigrationTable::Entry>::__init_with_size[abi:ne180100]<CLMicroLocationMigrationTable::Entry*,CLMicroLocationMigrationTable::Entry*>(a5, (const void *)v16[6], v16[7], (v16[7] - v16[6]) >> 4);

  _Block_object_dispose(&v23, 8);
  if (__p)
  {
    v30 = __p;
    operator delete(__p);
  }

}

void sub_241A12838(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, void *a14, void *a15, uint64_t a16, uint64_t a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,void *__p,uint64_t a25)
{
  void *v25;
  void *v26;
  void *v27;

  _Block_object_dispose(&a18, 8);
  if (__p)
  {
    a25 = (uint64_t)__p;
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

void ULDBUtils::fetchAllWithLimit<CLMicroLocationMigrationTable,ULMigrationMO>(void *a1@<X0>, unsigned int a2@<W1>, _QWORD *a3@<X8>)
{
  id v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;
  _QWORD v10[2];

  v10[1] = *MEMORY[0x24BDAC8D0];
  v5 = a1;
  v6 = (void *)MEMORY[0x24BDD17C0];
  objc_msgSend((id)objc_opt_class(), "defaultSortProperty");
  v7 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v6, "sortDescriptorWithKey:ascending:", v7, 0);
  v8 = (void *)objc_claimAutoreleasedReturnValue();

  v10[0] = v8;
  objc_msgSend(MEMORY[0x24BDBCE30], "arrayWithObjects:count:", v10, 1);
  v9 = (void *)objc_claimAutoreleasedReturnValue();
  ULDBUtils::fetchEntries<CLMicroLocationMigrationTable,ULMigrationMO>(v5, 0, v9, a2, a3);

}

void sub_241A1299C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_241A12B58(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void ___ZN9ULDBUtils13insertEntriesI29CLMicroLocationMigrationTable13ULMigrationMOEEbP7ULStoreRKNSt3__16vectorINT_5EntryENS5_9allocatorIS8_EEEE_block_invoke(uint64_t a1)
{
  uint64_t *v2;
  uint64_t v3;
  uint64_t v4;
  void *v5;
  void *v6;
  NSObject *v7;
  void *v8;
  void *v9;
  NSObject *v10;
  void *v11;
  void *v12;
  void *v13;
  int v14;
  int v15;
  __int16 v16;
  const char *v17;
  __int16 v18;
  void *v19;
  uint64_t v20;

  v20 = *MEMORY[0x24BDAC8D0];
  v2 = *(uint64_t **)(a1 + 48);
  v3 = *v2;
  v4 = v2[1];
  if (*v2 == v4)
  {
LABEL_4:
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = objc_msgSend(*(id *)(a1 + 32), "commitChangesToStore");
    objc_msgSend(*(id *)(a1 + 32), "deleteOldestRecordsIfFull");
  }
  else
  {
    while (1)
    {
      objc_msgSend(*(id *)(a1 + 32), "managedObjectContext");
      v5 = (void *)objc_claimAutoreleasedReturnValue();
      +[ULMigrationMO createFromEntry:inManagedObjectContext:](ULMigrationMO, "createFromEntry:inManagedObjectContext:", v3, v5);
      v6 = (void *)objc_claimAutoreleasedReturnValue();

      if (!v6)
        break;

      v3 += 16;
      if (v3 == v4)
        goto LABEL_4;
    }
    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_15);
    v7 = (id)logObject_MicroLocation_Default;
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      +[ULMigrationMO entity](ULMigrationMO, "entity");
      v8 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v8, "name");
      v9 = (void *)objc_claimAutoreleasedReturnValue();
      v14 = 68289283;
      v15 = 0;
      v16 = 2082;
      v17 = "";
      v18 = 2113;
      v19 = v9;
      _os_log_impl(&dword_2419D9000, v7, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"Failed to create entry from MO\", \"MO\":%{private, location:escape_only}@}", (uint8_t *)&v14, 0x1Cu);

    }
    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_15);
    v10 = (id)logObject_MicroLocation_Default;
    if (os_signpost_enabled(v10))
    {
      +[ULMigrationMO entity](ULMigrationMO, "entity");
      v11 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v11, "name");
      v12 = (void *)objc_claimAutoreleasedReturnValue();
      v14 = 68289283;
      v15 = 0;
      v16 = 2082;
      v17 = "";
      v18 = 2113;
      v19 = v12;
      _os_signpost_emit_with_name_impl(&dword_2419D9000, v10, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Failed to create entry from MO", "{\"msg%{public}.0s\":\"Failed to create entry from MO\", \"MO\":%{private, location:escape_only}@}", (uint8_t *)&v14, 0x1Cu);

    }
    objc_msgSend(*(id *)(a1 + 32), "managedObjectContext");
    v13 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v13, "reset");

  }
}

void sub_241A12E58(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void ___ZL45_CLLogObjectForCategory_MicroLocation_Defaultv_block_invoke_10()
{
  os_log_t v0;
  void *v1;

  v0 = os_log_create("com.apple.MicroLocation", "MicroLocation");
  v1 = (void *)logObject_MicroLocation_Default;
  logObject_MicroLocation_Default = (uint64_t)v0;

}

__n128 __Block_byref_object_copy__2(__n128 *a1, __n128 *a2)
{
  __n128 result;

  a1[3].n128_u64[0] = 0;
  a1[3].n128_u64[1] = 0;
  a1[4].n128_u64[0] = 0;
  result = a2[3];
  a1[3] = result;
  a1[4].n128_u64[0] = a2[4].n128_u64[0];
  a2[3].n128_u64[0] = 0;
  a2[3].n128_u64[1] = 0;
  a2[4].n128_u64[0] = 0;
  return result;
}

void __Block_byref_object_dispose__2(uint64_t a1)
{
  void *v2;

  v2 = *(void **)(a1 + 48);
  if (v2)
  {
    *(_QWORD *)(a1 + 56) = v2;
    operator delete(v2);
  }
}

void ___ZN9ULDBUtils12fetchEntriesI29CLMicroLocationMigrationTable13ULMigrationMOEENSt3__16vectorINT_5EntryENS3_9allocatorIS6_EEEEP7ULStoreP7NSArrayIP11NSPredicateEPSC_IP16NSSortDescriptorEm_block_invoke(uint64_t a1)
{
  void *v2;
  objc_class *v3;
  void *v4;
  void *v5;
  _QWORD *v6;
  void *v7;
  void *v8;
  __int128 v9;
  uint64_t v10;

  v2 = *(void **)(a1 + 48);
  v3 = (objc_class *)objc_opt_class();
  NSStringFromClass(v3);
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v2, "fetchManagedObjectsWithEntityName:byAndPredicates:sortDescriptors:andLimit:", v4, *(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 64));
  v5 = (void *)objc_claimAutoreleasedReturnValue();

  ULDBUtils::convertManagedObjectsToEntries<CLMicroLocationMigrationTable,ULMigrationMO>(v5, (uint64_t)&v9);
  v6 = *(_QWORD **)(*(_QWORD *)(a1 + 56) + 8);
  v7 = (void *)v6[6];
  if (v7)
  {
    v6[7] = v7;
    operator delete(v7);
    v6[6] = 0;
    v6[7] = 0;
    v6[8] = 0;
  }
  *((_OWORD *)v6 + 3) = v9;
  v6[8] = v10;
  objc_msgSend(*(id *)(a1 + 48), "managedObjectContext");
  v8 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v8, "reset");

}

void sub_241A12FDC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void ULDBUtils::convertManagedObjectsToEntries<CLMicroLocationMigrationTable,ULMigrationMO>(void *a1@<X0>, uint64_t a2@<X8>)
{
  id v3;
  id v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t i;
  id v8;
  void *v9;
  unint64_t v10;
  _OWORD *v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  unint64_t v15;
  char *v16;
  char *v17;
  char *v18;
  char *v19;
  char *v20;
  uint64_t v21;
  int v22;
  _OWORD *v23;
  NSObject *v24;
  void *v25;
  void *v26;
  NSObject *v27;
  void *v28;
  void *v29;
  id v30;
  __int128 v31;
  char v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  uint8_t buf[4];
  int v38;
  __int16 v39;
  const char *v40;
  __int16 v41;
  void *v42;
  _BYTE v43[128];
  uint64_t v44;

  v44 = *MEMORY[0x24BDAC8D0];
  v3 = a1;
  *(_QWORD *)(a2 + 8) = 0;
  *(_QWORD *)(a2 + 16) = 0;
  *(_QWORD *)a2 = 0;
  std::vector<CLMicroLocationMigrationTable::Entry>::reserve((char **)a2, objc_msgSend(v3, "count"));
  v35 = 0u;
  v36 = 0u;
  v33 = 0u;
  v34 = 0u;
  v4 = v3;
  v5 = objc_msgSend(v4, "countByEnumeratingWithState:objects:count:", &v33, v43, 16);
  if (v5)
  {
    v30 = v3;
    v6 = *(_QWORD *)v34;
    while (2)
    {
      for (i = 0; i != v5; ++i)
      {
        if (*(_QWORD *)v34 != v6)
          objc_enumerationMutation(v4);
        v8 = *(id *)(*((_QWORD *)&v33 + 1) + 8 * i);
        v9 = v8;
        if (!v8 || (objc_msgSend(v8, "convertToEntry", v30), !v32))
        {
          if (onceToken_MicroLocation_Default != -1)
            dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_15);
          v24 = (id)logObject_MicroLocation_Default;
          if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
          {
            objc_msgSend(v9, "entity");
            v25 = (void *)objc_claimAutoreleasedReturnValue();
            objc_msgSend(v25, "name");
            v26 = (void *)objc_claimAutoreleasedReturnValue();
            *(_DWORD *)buf = 68289283;
            v38 = 0;
            v39 = 2082;
            v40 = "";
            v41 = 2113;
            v42 = v26;
            _os_log_impl(&dword_2419D9000, v24, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"Failed to convert MO to entry\", \"MO\":%{private, location:escape_only}@}", buf, 0x1Cu);

          }
          if (onceToken_MicroLocation_Default != -1)
            dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_15);
          v27 = (id)logObject_MicroLocation_Default;
          if (os_signpost_enabled(v27))
          {
            objc_msgSend(v9, "entity");
            v28 = (void *)objc_claimAutoreleasedReturnValue();
            objc_msgSend(v28, "name");
            v29 = (void *)objc_claimAutoreleasedReturnValue();
            *(_DWORD *)buf = 68289283;
            v38 = 0;
            v39 = 2082;
            v40 = "";
            v41 = 2113;
            v42 = v29;
            _os_signpost_emit_with_name_impl(&dword_2419D9000, v27, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Failed to convert MO to entry", "{\"msg%{public}.0s\":\"Failed to convert MO to entry\", \"MO\":%{private, location:escape_only}@}", buf, 0x1Cu);

          }
          *(_QWORD *)(a2 + 8) = *(_QWORD *)a2;
          goto LABEL_38;
        }
        v11 = *(_OWORD **)(a2 + 8);
        v10 = *(_QWORD *)(a2 + 16);
        if ((unint64_t)v11 >= v10)
        {
          v12 = ((uint64_t)v11 - *(_QWORD *)a2) >> 4;
          v13 = v12 + 1;
          if ((unint64_t)(v12 + 1) >> 60)
            std::vector<CLMicroLocationProto::ConfidenceReason>::__throw_length_error[abi:ne180100]();
          v14 = v10 - *(_QWORD *)a2;
          if (v14 >> 3 > v13)
            v13 = v14 >> 3;
          if ((unint64_t)v14 >= 0x7FFFFFFFFFFFFFF0)
            v15 = 0xFFFFFFFFFFFFFFFLL;
          else
            v15 = v13;
          if (v15)
            v16 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<boost::uuids::uuid>>(a2 + 16, v15);
          else
            v16 = 0;
          v17 = &v16[16 * v12];
          *(_OWORD *)v17 = v31;
          v19 = *(char **)a2;
          v18 = *(char **)(a2 + 8);
          v20 = v17;
          if (v18 != *(char **)a2)
          {
            do
            {
              v21 = *((_QWORD *)v18 - 2);
              v18 -= 16;
              v22 = *((_DWORD *)v18 + 2);
              *((_QWORD *)v20 - 2) = v21;
              v20 -= 16;
              *((_DWORD *)v20 + 2) = v22;
            }
            while (v18 != v19);
            v18 = *(char **)a2;
          }
          v23 = v17 + 16;
          *(_QWORD *)a2 = v20;
          *(_QWORD *)(a2 + 8) = v17 + 16;
          *(_QWORD *)(a2 + 16) = &v16[16 * v15];
          if (v18)
            operator delete(v18);
          *(_QWORD *)(a2 + 8) = v23;
        }
        else
        {
          *v11 = v31;
          *(_QWORD *)(a2 + 8) = v11 + 1;
        }

      }
      v5 = objc_msgSend(v4, "countByEnumeratingWithState:objects:count:", &v33, v43, 16);
      if (v5)
        continue;
      break;
    }
  }

LABEL_38:
}

void sub_241A133C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9)
{
  uint64_t v9;
  void *v10;
  void *v12;

  v12 = *(void **)v9;
  if (*(_QWORD *)v9)
  {
    *(_QWORD *)(v9 + 8) = v12;
    operator delete(v12);
  }

  _Unwind_Resume(a1);
}

void std::vector<CLMicroLocationMigrationTable::Entry>::reserve(char **a1, unint64_t a2)
{
  uint64_t v3;
  char *v4;
  uint64_t v5;
  char *v6;
  char *v7;
  uint64_t v8;
  char *v9;
  char *v10;
  char *v11;
  char *v12;
  uint64_t v13;
  int v14;

  v4 = a1[2];
  v3 = (uint64_t)(a1 + 2);
  if (a2 > (v4 - *a1) >> 4)
  {
    if (a2 >> 60)
      std::vector<CLMicroLocationProto::ConfidenceReason>::__throw_length_error[abi:ne180100]();
    v5 = a1[1] - *a1;
    v6 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<boost::uuids::uuid>>(v3, a2);
    v7 = &v6[v5];
    v9 = &v6[16 * v8];
    v11 = *a1;
    v10 = a1[1];
    v12 = v7;
    if (v10 != *a1)
    {
      do
      {
        v13 = *((_QWORD *)v10 - 2);
        v10 -= 16;
        v14 = *((_DWORD *)v10 + 2);
        *((_QWORD *)v12 - 2) = v13;
        v12 -= 16;
        *((_DWORD *)v12 + 2) = v14;
      }
      while (v10 != v11);
      v10 = *a1;
    }
    *a1 = v12;
    a1[1] = v7;
    a1[2] = v9;
    if (v10)
      operator delete(v10);
  }
}

_QWORD *std::vector<CLMicroLocationMigrationTable::Entry>::__init_with_size[abi:ne180100]<CLMicroLocationMigrationTable::Entry*,CLMicroLocationMigrationTable::Entry*>(_QWORD *result, const void *a2, uint64_t a3, unint64_t a4)
{
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;

  if (a4)
  {
    v6 = result;
    result = std::vector<boost::uuids::uuid>::__vallocate[abi:ne180100](result, a4);
    v7 = v6[1];
    v8 = a3 - (_QWORD)a2;
    if (v8)
      result = memmove((void *)v6[1], a2, v8 - 4);
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_241A1354C(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_241A13894(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  uint64_t v3;
  void *v4;

  MEMORY[0x2426A04BC](v3, 0x1000C8077774924);
  _Unwind_Resume(a1);
}

void sub_241A13D44(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,void *a27,uint64_t a28,int a29,__int16 a30,char a31,char a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,char a62)
{
  CLMicroLocationRecordingEventsTable::Entry::~Entry(&a27);
  CLMicroLocationProto::RecordingEvent::~RecordingEvent((CLMicroLocationProto::RecordingEvent *)&a62);
  if (a22 < 0)
    operator delete(__p);
  _Unwind_Resume(a1);
}

void CLMicroLocationRecordingEventsTable::Entry::~Entry(void **this)
{
  CLMicroLocationProto::RecordingEvent::~RecordingEvent((CLMicroLocationProto::RecordingEvent *)(this + 10));
  if (*((char *)this + 47) < 0)
    operator delete(this[3]);
}

void ___ZL45_CLLogObjectForCategory_MicroLocation_Defaultv_block_invoke_11()
{
  os_log_t v0;
  void *v1;

  v0 = os_log_create("com.apple.MicroLocation", "MicroLocation");
  v1 = (void *)logObject_MicroLocation_Default;
  logObject_MicroLocation_Default = (uint64_t)v0;

}

uint64_t std::__optional_destruct_base<CLMicroLocationRecordingEventsTable::Entry,false>::__optional_destruct_base[abi:ne180100]<CLMicroLocationRecordingEventsTable::Entry>(uint64_t a1, __int128 *a2)
{
  __int128 v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;

  v4 = *a2;
  *(_QWORD *)(a1 + 16) = *((_QWORD *)a2 + 2);
  *(_OWORD *)a1 = v4;
  v5 = *(__int128 *)((char *)a2 + 24);
  *(_QWORD *)(a1 + 40) = *((_QWORD *)a2 + 5);
  *(_OWORD *)(a1 + 24) = v5;
  *((_QWORD *)a2 + 4) = 0;
  *((_QWORD *)a2 + 5) = 0;
  *((_QWORD *)a2 + 3) = 0;
  v6 = a2[3];
  *(_OWORD *)(a1 + 60) = *(__int128 *)((char *)a2 + 60);
  *(_OWORD *)(a1 + 48) = v6;
  CLMicroLocationProto::RecordingEvent::RecordingEvent((CLMicroLocationProto::RecordingEvent *)(a1 + 80), (const CLMicroLocationProto::RecordingEvent *)(a2 + 5));
  v7 = a2[14];
  *(_BYTE *)(a1 + 240) = *((_BYTE *)a2 + 240);
  *(_OWORD *)(a1 + 224) = v7;
  *(_BYTE *)(a1 + 248) = 1;
  return a1;
}

void sub_241A13F44(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void **v2;

  if (*(char *)(v1 + 47) < 0)
    operator delete(*v2);
  _Unwind_Resume(exception_object);
}

uint64_t CLMiLoOdometryTable::Entry::Entry(uint64_t a1, void *a2, float a3, float a4, float a5, double a6)
{
  id v11;

  v11 = a2;
  *(float *)a1 = a3;
  *(float *)(a1 + 4) = a4;
  *(float *)(a1 + 8) = a5;
  *(double *)(a1 + 16) = a6;
  *(_QWORD *)(a1 + 24) = v11;
  return a1;
}

void sub_241A14074(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

uint64_t ULDBUtils::insertEntries<CLMicroLocationModelTable,ULModelMO>(void *a1, uint64_t a2)
{
  id v3;
  void *v4;
  id v5;
  uint64_t v6;
  _QWORD v8[4];
  id v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  char v15;

  v3 = a1;
  v12 = 0;
  v13 = &v12;
  v14 = 0x2020000000;
  v15 = 0;
  objc_msgSend(v3, "managedObjectContext");
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  v8[0] = MEMORY[0x24BDAC760];
  v8[1] = 3221225472;
  v8[2] = ___ZN9ULDBUtils13insertEntriesI25CLMicroLocationModelTable9ULModelMOEEbP7ULStoreRKNSt3__16vectorINT_5EntryENS5_9allocatorIS8_EEEE_block_invoke;
  v8[3] = &unk_2511D22D0;
  v11 = a2;
  v5 = v3;
  v9 = v5;
  v10 = &v12;
  objc_msgSend(v4, "performBlockAndWait:", v8);

  v6 = *((unsigned __int8 *)v13 + 24);
  _Block_object_dispose(&v12, 8);

  return v6;
}

void sub_241A14198(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, void *a7, uint64_t a8, uint64_t a9, ...)
{
  void *v9;
  void *v10;
  va_list va;

  va_start(va, a9);

  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void ULDBUtils::fetchEntries<CLMicroLocationModelTable,ULModelMO>(void *a1@<X0>, void *a2@<X1>, void *a3@<X2>, uint64_t a4@<X3>, CLMicroLocationModelTable::Entry *a5@<X8>)
{
  id v9;
  id v10;
  id v11;
  void *v12;
  id v13;
  id v14;
  id v15;
  uint64_t *v16;
  _QWORD v17[4];
  id v18;
  id v19;
  id v20;
  uint64_t *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t *v24;
  uint64_t v25;
  __n128 (*v26)(__n128 *, __n128 *);
  void (*v27)(uint64_t);
  void *v28;
  _QWORD v29[3];
  void **v30;

  v9 = a1;
  v10 = a2;
  v11 = a3;
  v23 = 0;
  v24 = &v23;
  v25 = 0x4812000000;
  v26 = __Block_byref_object_copy__3;
  v27 = __Block_byref_object_dispose__3;
  v28 = &unk_241BEBD1D;
  memset(v29, 0, sizeof(v29));
  objc_msgSend(v9, "managedObjectContext");
  v12 = (void *)objc_claimAutoreleasedReturnValue();
  v17[0] = MEMORY[0x24BDAC760];
  v17[1] = 3221225472;
  v17[2] = ___ZN9ULDBUtils12fetchEntriesI25CLMicroLocationModelTable9ULModelMOEENSt3__16vectorINT_5EntryENS3_9allocatorIS6_EEEEP7ULStoreP7NSArrayIP11NSPredicateEPSC_IP16NSSortDescriptorEm_block_invoke;
  v17[3] = &unk_2511D22F8;
  v13 = v10;
  v18 = v13;
  v14 = v11;
  v19 = v14;
  v22 = a4;
  v15 = v9;
  v20 = v15;
  v21 = &v23;
  objc_msgSend(v12, "performBlockAndWait:", v17);

  v16 = v24;
  *((_QWORD *)a5 + 1) = 0;
  *((_QWORD *)a5 + 2) = 0;
  *(_QWORD *)a5 = 0;
  std::vector<CLMicroLocationModelTable::Entry>::__init_with_size[abi:ne180100]<CLMicroLocationModelTable::Entry*,CLMicroLocationModelTable::Entry*>(a5, (CLMicroLocationModelTable::Entry *)v16[6], (CLMicroLocationModelTable::Entry *)v16[7], 0x6F96F96F96F96F97 * ((v16[7] - v16[6]) >> 3));

  _Block_object_dispose(&v23, 8);
  v30 = (void **)v29;
  std::vector<CLMicroLocationModelTable::Entry>::__destroy_vector::operator()[abi:ne180100](&v30);

}

void sub_241A14360(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, void *a6, void *a7, void *a8, uint64_t a9, uint64_t a10, ...)
{
  void *v10;
  void *v11;
  void *v12;
  uint64_t v13;
  uint64_t v14;
  va_list va;

  va_start(va, a10);

  _Block_object_dispose(va, 8);
  *(_QWORD *)(v14 - 96) = v13;
  std::vector<CLMicroLocationModelTable::Entry>::__destroy_vector::operator()[abi:ne180100]((void ***)(v14 - 96));

  _Unwind_Resume(a1);
}

void ULDBUtils::fetchAllWithLimit<CLMicroLocationModelTable,ULModelMO>(void *a1@<X0>, unsigned int a2@<W1>, CLMicroLocationModelTable::Entry *a3@<X8>)
{
  id v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;
  _QWORD v10[2];

  v10[1] = *MEMORY[0x24BDAC8D0];
  v5 = a1;
  v6 = (void *)MEMORY[0x24BDD17C0];
  objc_msgSend((id)objc_opt_class(), "defaultSortProperty");
  v7 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v6, "sortDescriptorWithKey:ascending:", v7, 0);
  v8 = (void *)objc_claimAutoreleasedReturnValue();

  v10[0] = v8;
  objc_msgSend(MEMORY[0x24BDBCE30], "arrayWithObjects:count:", v10, 1);
  v9 = (void *)objc_claimAutoreleasedReturnValue();
  ULDBUtils::fetchEntries<CLMicroLocationModelTable,ULModelMO>(v5, 0, v9, a2, a3);

}

void sub_241A144C0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_241A1476C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_241A149F8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_241A14B78(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_241A14DEC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, void **a14)
{
  void *v14;
  void *v15;

  a14 = (void **)&a11;
  std::vector<CLMicroLocationModelTable::Entry>::__destroy_vector::operator()[abi:ne180100](&a14);

  _Unwind_Resume(a1);
}

void sub_241A150D0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, void **a14)
{
  void *v14;
  void *v15;

  a14 = (void **)&a11;
  std::vector<CLMicroLocationModelTable::Entry>::__destroy_vector::operator()[abi:ne180100](&a14);

  _Unwind_Resume(a1);
}

void sub_241A152AC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_241A155A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, void **a14)
{
  void *v14;
  void *v15;
  void *v16;
  void *v17;

  a14 = (void **)&a11;
  std::vector<CLMicroLocationModelTable::Entry>::__destroy_vector::operator()[abi:ne180100](&a14);

  _Unwind_Resume(a1);
}

void sub_241A15718(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_list va;

  va_start(va, a6);
  std::__optional_destruct_base<CLMicroLocationModelTable::Entry,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)va);
  std::vector<CLMicroLocationModelTable::Entry>::__destroy_vector::operator()[abi:ne180100]((void ***)va);
  _Unwind_Resume(a1);
}

void sub_241A15894(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  _Unwind_Resume(a1);
}

void sub_241A15A2C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  _Unwind_Resume(a1);
}

void ___ZL45_CLLogObjectForCategory_MicroLocation_Defaultv_block_invoke_12()
{
  os_log_t v0;
  void *v1;

  v0 = os_log_create("com.apple.MicroLocation", "MicroLocation");
  v1 = (void *)logObject_MicroLocation_Default;
  logObject_MicroLocation_Default = (uint64_t)v0;

}

uint64_t std::__optional_destruct_base<CLMicroLocationModelTable::Entry,false>::~__optional_destruct_base[abi:ne180100](uint64_t a1)
{
  if (*(_BYTE *)(a1 + 312))
  {
    if (*(_BYTE *)(a1 + 264) && *(char *)(a1 + 263) < 0)
      operator delete(*(void **)(a1 + 240));
    CLMicroLocationProto::Model::~Model((CLMicroLocationProto::Model *)(a1 + 32));
  }
  return a1;
}

void ___ZN9ULDBUtils13insertEntriesI25CLMicroLocationModelTable9ULModelMOEEbP7ULStoreRKNSt3__16vectorINT_5EntryENS5_9allocatorIS8_EEEE_block_invoke(uint64_t a1)
{
  uint64_t *v2;
  uint64_t v3;
  uint64_t v4;
  void *v5;
  void *v6;
  NSObject *v7;
  void *v8;
  void *v9;
  NSObject *v10;
  void *v11;
  void *v12;
  void *v13;
  int v14;
  int v15;
  __int16 v16;
  const char *v17;
  __int16 v18;
  void *v19;
  uint64_t v20;

  v20 = *MEMORY[0x24BDAC8D0];
  v2 = *(uint64_t **)(a1 + 48);
  v3 = *v2;
  v4 = v2[1];
  if (*v2 == v4)
  {
LABEL_4:
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = objc_msgSend(*(id *)(a1 + 32), "commitChangesToStore");
    objc_msgSend(*(id *)(a1 + 32), "deleteOldestRecordsIfFull");
  }
  else
  {
    while (1)
    {
      objc_msgSend(*(id *)(a1 + 32), "managedObjectContext");
      v5 = (void *)objc_claimAutoreleasedReturnValue();
      +[ULModelMO createFromEntry:inManagedObjectContext:](ULModelMO, "createFromEntry:inManagedObjectContext:", v3, v5);
      v6 = (void *)objc_claimAutoreleasedReturnValue();

      if (!v6)
        break;

      v3 += 312;
      if (v3 == v4)
        goto LABEL_4;
    }
    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_17);
    v7 = (id)logObject_MicroLocation_Default;
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      +[ULModelMO entity](ULModelMO, "entity");
      v8 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v8, "name");
      v9 = (void *)objc_claimAutoreleasedReturnValue();
      v14 = 68289283;
      v15 = 0;
      v16 = 2082;
      v17 = "";
      v18 = 2113;
      v19 = v9;
      _os_log_impl(&dword_2419D9000, v7, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"Failed to create entry from MO\", \"MO\":%{private, location:escape_only}@}", (uint8_t *)&v14, 0x1Cu);

    }
    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_17);
    v10 = (id)logObject_MicroLocation_Default;
    if (os_signpost_enabled(v10))
    {
      +[ULModelMO entity](ULModelMO, "entity");
      v11 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v11, "name");
      v12 = (void *)objc_claimAutoreleasedReturnValue();
      v14 = 68289283;
      v15 = 0;
      v16 = 2082;
      v17 = "";
      v18 = 2113;
      v19 = v12;
      _os_signpost_emit_with_name_impl(&dword_2419D9000, v10, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Failed to create entry from MO", "{\"msg%{public}.0s\":\"Failed to create entry from MO\", \"MO\":%{private, location:escape_only}@}", (uint8_t *)&v14, 0x1Cu);

    }
    objc_msgSend(*(id *)(a1 + 32), "managedObjectContext");
    v13 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v13, "reset");

  }
}

void sub_241A15D98(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

__n128 __Block_byref_object_copy__3(__n128 *a1, __n128 *a2)
{
  __n128 result;

  a1[3].n128_u64[0] = 0;
  a1[3].n128_u64[1] = 0;
  a1[4].n128_u64[0] = 0;
  result = a2[3];
  a1[3] = result;
  a1[4].n128_u64[0] = a2[4].n128_u64[0];
  a2[3].n128_u64[0] = 0;
  a2[3].n128_u64[1] = 0;
  a2[4].n128_u64[0] = 0;
  return result;
}

void __Block_byref_object_dispose__3(uint64_t a1)
{
  void **v1;

  v1 = (void **)(a1 + 48);
  std::vector<CLMicroLocationModelTable::Entry>::__destroy_vector::operator()[abi:ne180100](&v1);
}

void ___ZN9ULDBUtils12fetchEntriesI25CLMicroLocationModelTable9ULModelMOEENSt3__16vectorINT_5EntryENS3_9allocatorIS6_EEEEP7ULStoreP7NSArrayIP11NSPredicateEPSC_IP16NSSortDescriptorEm_block_invoke(uint64_t a1)
{
  void *v2;
  objc_class *v3;
  void *v4;
  void *v5;
  uint64_t v6;
  void *v7;
  __int128 v8;
  uint64_t v9;
  void **v10;

  v2 = *(void **)(a1 + 48);
  v3 = (objc_class *)objc_opt_class();
  NSStringFromClass(v3);
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v2, "fetchManagedObjectsWithEntityName:byAndPredicates:sortDescriptors:andLimit:", v4, *(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 64));
  v5 = (void *)objc_claimAutoreleasedReturnValue();

  ULDBUtils::convertManagedObjectsToEntries<CLMicroLocationModelTable,ULModelMO>(v5, (uint64_t *)&v8);
  v6 = *(_QWORD *)(*(_QWORD *)(a1 + 56) + 8);
  std::vector<CLMicroLocationModelTable::Entry>::__vdeallocate((void **)(v6 + 48));
  *(_OWORD *)(v6 + 48) = v8;
  *(_QWORD *)(v6 + 64) = v9;
  v9 = 0;
  v8 = 0uLL;
  v10 = (void **)&v8;
  std::vector<CLMicroLocationModelTable::Entry>::__destroy_vector::operator()[abi:ne180100](&v10);
  objc_msgSend(*(id *)(a1 + 48), "managedObjectContext");
  v7 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v7, "reset");

}

void sub_241A15F00(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void ULDBUtils::convertManagedObjectsToEntries<CLMicroLocationModelTable,ULModelMO>(void *a1@<X0>, uint64_t *a2@<X8>)
{
  id v3;
  id v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t i;
  id v8;
  void *v9;
  unint64_t v10;
  uint64_t v11;
  NSObject *v12;
  void *v13;
  void *v14;
  NSObject *v15;
  void *v16;
  void *v17;
  uint64_t j;
  uint64_t v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  uint8_t buf[4];
  int v25;
  __int16 v26;
  const char *v27;
  __int16 v28;
  void *v29;
  _OWORD v30[19];
  __int128 v31;
  _BYTE v32[128];
  uint64_t v33;

  v33 = *MEMORY[0x24BDAC8D0];
  v3 = a1;
  a2[1] = 0;
  a2[2] = 0;
  *a2 = 0;
  std::vector<CLMicroLocationModelTable::Entry>::reserve(a2, objc_msgSend(v3, "count"));
  v22 = 0u;
  v23 = 0u;
  v20 = 0u;
  v21 = 0u;
  v4 = v3;
  v5 = objc_msgSend(v4, "countByEnumeratingWithState:objects:count:", &v20, v32, 16);
  if (v5)
  {
    v6 = *(_QWORD *)v21;
    while (2)
    {
      for (i = 0; i != v5; ++i)
      {
        if (*(_QWORD *)v21 != v6)
          objc_enumerationMutation(v4);
        v8 = *(id *)(*((_QWORD *)&v20 + 1) + 8 * i);
        v9 = v8;
        if (!v8)
        {
          v31 = 0u;
          memset(v30, 0, sizeof(v30));
LABEL_16:
          if (onceToken_MicroLocation_Default != -1)
            dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_17);
          v12 = (id)logObject_MicroLocation_Default;
          if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
          {
            objc_msgSend(v9, "entity");
            v13 = (void *)objc_claimAutoreleasedReturnValue();
            objc_msgSend(v13, "name");
            v14 = (void *)objc_claimAutoreleasedReturnValue();
            *(_DWORD *)buf = 68289283;
            v25 = 0;
            v26 = 2082;
            v27 = "";
            v28 = 2113;
            v29 = v14;
            _os_log_impl(&dword_2419D9000, v12, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"Failed to convert MO to entry\", \"MO\":%{private, location:escape_only}@}", buf, 0x1Cu);

          }
          if (onceToken_MicroLocation_Default != -1)
            dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_17);
          v15 = (id)logObject_MicroLocation_Default;
          if (os_signpost_enabled(v15))
          {
            objc_msgSend(v9, "entity");
            v16 = (void *)objc_claimAutoreleasedReturnValue();
            objc_msgSend(v16, "name");
            v17 = (void *)objc_claimAutoreleasedReturnValue();
            *(_DWORD *)buf = 68289283;
            v25 = 0;
            v26 = 2082;
            v27 = "";
            v28 = 2113;
            v29 = v17;
            _os_signpost_emit_with_name_impl(&dword_2419D9000, v15, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Failed to convert MO to entry", "{\"msg%{public}.0s\":\"Failed to convert MO to entry\", \"MO\":%{private, location:escape_only}@}", buf, 0x1Cu);

          }
          std::__optional_destruct_base<CLMicroLocationModelTable::Entry,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)v30);

          v19 = *a2;
          for (j = a2[1];
                j != v19;
                std::allocator<CLMicroLocationModelTable::Entry>::destroy[abi:ne180100]((uint64_t)(a2 + 2), j))
          {
            j -= 312;
          }
          a2[1] = v19;
          goto LABEL_28;
        }
        objc_msgSend(v8, "convertToEntry", (_QWORD)v20);
        if (!BYTE8(v31))
          goto LABEL_16;
        v10 = a2[1];
        if (v10 >= a2[2])
        {
          v11 = std::vector<CLMicroLocationModelTable::Entry>::__push_back_slow_path<CLMicroLocationModelTable::Entry>(a2, (uint64_t)v30);
        }
        else
        {
          CLMicroLocationModelTable::Entry::Entry(a2[1], v30);
          v11 = v10 + 312;
          a2[1] = v10 + 312;
        }
        a2[1] = v11;
        std::__optional_destruct_base<CLMicroLocationModelTable::Entry,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)v30);

      }
      v5 = objc_msgSend(v4, "countByEnumeratingWithState:objects:count:", &v20, v32, 16);
      if (v5)
        continue;
      break;
    }
  }

LABEL_28:
}

void sub_241A1629C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  void *v13;
  void *v14;
  void *v15;
  void *v16;
  void *v17;
  va_list va;

  va_start(va, a13);

  std::__optional_destruct_base<CLMicroLocationModelTable::Entry,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)va);
  std::vector<CLMicroLocationModelTable::Entry>::__destroy_vector::operator()[abi:ne180100]((void ***)va);

  _Unwind_Resume(a1);
}

void **std::vector<CLMicroLocationModelTable::Entry>::reserve(uint64_t *a1, unint64_t a2)
{
  void **result;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  void *v7[5];

  v4 = a1[2];
  result = (void **)(a1 + 2);
  if (0x6F96F96F96F96F97 * ((v4 - *a1) >> 3) < a2)
  {
    if (a2 >= 0xD20D20D20D20D3)
      std::vector<CLMicroLocationProto::ConfidenceReason>::__throw_length_error[abi:ne180100]();
    v5 = a1[1] - *a1;
    v7[4] = result;
    v7[0] = std::__allocate_at_least[abi:ne180100]<std::allocator<CLMicroLocationModelTable::Entry>>((uint64_t)result, a2);
    v7[1] = (char *)v7[0] + v5;
    v7[2] = (char *)v7[0] + v5;
    v7[3] = (char *)v7[0] + 312 * v6;
    std::vector<CLMicroLocationModelTable::Entry>::__swap_out_circular_buffer(a1, v7);
    return std::__split_buffer<CLMicroLocationModelTable::Entry>::~__split_buffer(v7);
  }
  return result;
}

void sub_241A163D4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__split_buffer<CLMicroLocationModelTable::Entry>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

uint64_t std::vector<CLMicroLocationModelTable::Entry>::__swap_out_circular_buffer(uint64_t *a1, _QWORD *a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<CLMicroLocationModelTable::Entry>,std::reverse_iterator<CLMicroLocationModelTable::Entry*>,std::reverse_iterator<CLMicroLocationModelTable::Entry*>,std::reverse_iterator<CLMicroLocationModelTable::Entry*>>((uint64_t)(a1 + 2), a1[1], (const CLMicroLocationModelTable::Entry *)a1[1], *a1, (const CLMicroLocationModelTable::Entry *)*a1, a2[1], a2[1]);
  a2[1] = v5;
  v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<CLMicroLocationModelTable::Entry>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0xD20D20D20D20D3)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(312 * a2);
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<CLMicroLocationModelTable::Entry>,std::reverse_iterator<CLMicroLocationModelTable::Entry*>,std::reverse_iterator<CLMicroLocationModelTable::Entry*>,std::reverse_iterator<CLMicroLocationModelTable::Entry*>>(uint64_t a1, uint64_t a2, const CLMicroLocationModelTable::Entry *a3, uint64_t a4, const CLMicroLocationModelTable::Entry *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7;
  const CLMicroLocationModelTable::Entry *v9;
  uint64_t v10;
  _QWORD v12[3];
  char v13;
  __int128 v14;
  __int128 v15;

  v7 = a7;
  *(_QWORD *)&v15 = a6;
  *((_QWORD *)&v15 + 1) = a7;
  v14 = v15;
  v12[0] = a1;
  v12[1] = &v14;
  v12[2] = &v15;
  v13 = 0;
  if (a3 == a5)
  {
    v10 = a6;
  }
  else
  {
    v9 = a3;
    do
    {
      v9 = (const CLMicroLocationModelTable::Entry *)((char *)v9 - 312);
      CLMicroLocationModelTable::Entry::Entry((CLMicroLocationModelTable::Entry *)(v7 - 312), v9);
      v7 = *((_QWORD *)&v15 + 1) - 312;
      *((_QWORD *)&v15 + 1) -= 312;
    }
    while (v9 != a5);
    v10 = v15;
  }
  v13 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<CLMicroLocationModelTable::Entry>,std::reverse_iterator<CLMicroLocationModelTable::Entry*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v12);
  return v10;
}

void sub_241A16548(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<CLMicroLocationModelTable::Entry>,std::reverse_iterator<CLMicroLocationModelTable::Entry*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

CLMicroLocationModelTable::Entry *CLMicroLocationModelTable::Entry::Entry(CLMicroLocationModelTable::Entry *this, const CLMicroLocationModelTable::Entry *a2)
{
  __int128 v4;
  __int128 v5;
  __int128 v6;

  v4 = *(_OWORD *)a2;
  *(_OWORD *)((char *)this + 12) = *(_OWORD *)((char *)a2 + 12);
  *(_OWORD *)this = v4;
  CLMicroLocationProto::Model::Model((CLMicroLocationModelTable::Entry *)((char *)this + 32), (const CLMicroLocationModelTable::Entry *)((char *)a2 + 32));
  std::__optional_copy_base<std::string,false>::__optional_copy_base[abi:ne180100]((std::string *)this + 10, (__int128 *)a2 + 15);
  v5 = *((_OWORD *)a2 + 17);
  v6 = *((_OWORD *)a2 + 18);
  *((_BYTE *)this + 304) = *((_BYTE *)a2 + 304);
  *((_OWORD *)this + 17) = v5;
  *((_OWORD *)this + 18) = v6;
  return this;
}

void sub_241A165C4(_Unwind_Exception *a1)
{
  CLMicroLocationProto::Model *v1;

  CLMicroLocationProto::Model::~Model(v1);
  _Unwind_Resume(a1);
}

std::string *std::__optional_copy_base<std::string,false>::__optional_copy_base[abi:ne180100](std::string *a1, __int128 *a2)
{
  a1->__r_.__value_.__s.__data_[0] = 0;
  a1[1].__r_.__value_.__s.__data_[0] = 0;
  std::__optional_storage_base<std::string,false>::__construct_from[abi:ne180100]<std::__optional_copy_base<std::string,false> const&>(a1, a2);
  return a1;
}

void sub_241A16604(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (*(_BYTE *)(v1 + 24))
    std::__optional_copy_base<std::string,false>::__optional_copy_base[abi:ne180100](v1);
  _Unwind_Resume(exception_object);
}

void std::__optional_storage_base<std::string,false>::__construct_from[abi:ne180100]<std::__optional_copy_base<std::string,false> const&>(std::string *this, __int128 *a2)
{
  __int128 v3;

  if (*((_BYTE *)a2 + 24))
  {
    if (*((char *)a2 + 23) < 0)
    {
      std::string::__init_copy_ctor_external(this, *(const std::string::value_type **)a2, *((_QWORD *)a2 + 1));
    }
    else
    {
      v3 = *a2;
      this->__r_.__value_.__r.__words[2] = *((_QWORD *)a2 + 2);
      *(_OWORD *)&this->__r_.__value_.__l.__data_ = v3;
    }
    this[1].__r_.__value_.__s.__data_[0] = 1;
  }
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<CLMicroLocationModelTable::Entry>,std::reverse_iterator<CLMicroLocationModelTable::Entry*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24))
    std::_AllocatorDestroyRangeReverse<std::allocator<CLMicroLocationModelTable::Entry>,std::reverse_iterator<CLMicroLocationModelTable::Entry*>>::operator()[abi:ne180100]((uint64_t *)a1);
  return a1;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<CLMicroLocationModelTable::Entry>,std::reverse_iterator<CLMicroLocationModelTable::Entry*>>::operator()[abi:ne180100](uint64_t *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;

  v1 = *(_QWORD *)(a1[2] + 8);
  v2 = *(_QWORD *)(a1[1] + 8);
  if (v1 != v2)
  {
    v3 = *a1;
    do
    {
      std::allocator<CLMicroLocationModelTable::Entry>::destroy[abi:ne180100](v3, v1);
      v1 += 312;
    }
    while (v1 != v2);
  }
}

void std::allocator<CLMicroLocationModelTable::Entry>::destroy[abi:ne180100](uint64_t a1, uint64_t a2)
{
  if (*(_BYTE *)(a2 + 264) && *(char *)(a2 + 263) < 0)
    operator delete(*(void **)(a2 + 240));
  CLMicroLocationProto::Model::~Model((CLMicroLocationProto::Model *)(a2 + 32));
}

void **std::__split_buffer<CLMicroLocationModelTable::Entry>::~__split_buffer(void **a1)
{
  std::__split_buffer<CLMicroLocationModelTable::Entry>::clear[abi:ne180100](a1);
  if (*a1)
    operator delete(*a1);
  return a1;
}

void std::__split_buffer<CLMicroLocationModelTable::Entry>::clear[abi:ne180100](_QWORD *a1)
{
  uint64_t i;
  uint64_t v2;
  uint64_t v4;

  v2 = a1[1];
  for (i = a1[2]; i != v2; i = a1[2])
  {
    v4 = a1[4];
    a1[2] = i - 312;
    std::allocator<CLMicroLocationModelTable::Entry>::destroy[abi:ne180100](v4, i - 312);
  }
}

uint64_t std::vector<CLMicroLocationModelTable::Entry>::__push_back_slow_path<CLMicroLocationModelTable::Entry>(uint64_t *a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  char *v10;
  uint64_t v11;
  void *v13;
  char *v14;
  char *v15;
  char *v16;
  uint64_t *v17;

  v3 = *a1;
  v4 = 0x6F96F96F96F96F97 * ((a1[1] - *a1) >> 3);
  v5 = v4 + 1;
  if ((unint64_t)(v4 + 1) > 0xD20D20D20D20D2)
    std::vector<CLMicroLocationProto::ConfidenceReason>::__throw_length_error[abi:ne180100]();
  v7 = (uint64_t)(a1 + 2);
  v8 = 0x6F96F96F96F96F97 * ((a1[2] - v3) >> 3);
  if (2 * v8 > v5)
    v5 = 2 * v8;
  if (v8 >= 0x69069069069069)
    v9 = 0xD20D20D20D20D2;
  else
    v9 = v5;
  v17 = a1 + 2;
  if (v9)
    v10 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<CLMicroLocationModelTable::Entry>>(v7, v9);
  else
    v10 = 0;
  v13 = v10;
  v14 = &v10[312 * v4];
  v16 = &v10[312 * v9];
  CLMicroLocationModelTable::Entry::Entry(v14, a2);
  v15 = v14 + 312;
  std::vector<CLMicroLocationModelTable::Entry>::__swap_out_circular_buffer(a1, &v13);
  v11 = a1[1];
  std::__split_buffer<CLMicroLocationModelTable::Entry>::~__split_buffer(&v13);
  return v11;
}

void sub_241A168B0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__split_buffer<CLMicroLocationModelTable::Entry>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

void std::vector<CLMicroLocationModelTable::Entry>::__vdeallocate(void **a1)
{
  void *v1;
  uint64_t v3;
  void *v4;

  v1 = *a1;
  if (*a1)
  {
    v3 = (uint64_t)a1[1];
    v4 = *a1;
    if ((void *)v3 != v1)
    {
      do
      {
        v3 -= 312;
        std::allocator<CLMicroLocationModelTable::Entry>::destroy[abi:ne180100]((uint64_t)(a1 + 2), v3);
      }
      while ((void *)v3 != v1);
      v4 = *a1;
    }
    a1[1] = v1;
    operator delete(v4);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

CLMicroLocationModelTable::Entry *std::vector<CLMicroLocationModelTable::Entry>::__init_with_size[abi:ne180100]<CLMicroLocationModelTable::Entry*,CLMicroLocationModelTable::Entry*>(CLMicroLocationModelTable::Entry *result, CLMicroLocationModelTable::Entry *a2, CLMicroLocationModelTable::Entry *a3, unint64_t a4)
{
  CLMicroLocationModelTable::Entry *v6;

  if (a4)
  {
    v6 = result;
    std::vector<CLMicroLocationModelTable::Entry>::__vallocate[abi:ne180100](result, a4);
    result = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<CLMicroLocationModelTable::Entry>,CLMicroLocationModelTable::Entry*,CLMicroLocationModelTable::Entry*,CLMicroLocationModelTable::Entry*>((uint64_t)v6 + 16, a2, a3, *((CLMicroLocationModelTable::Entry **)v6 + 1));
    *((_QWORD *)v6 + 1) = result;
  }
  return result;
}

void sub_241A16994(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  uint64_t v9;
  uint64_t v10;

  *(_QWORD *)(v9 + 8) = v10;
  std::vector<CLMicroLocationModelTable::Entry>::__destroy_vector::operator()[abi:ne180100](&a9);
  _Unwind_Resume(a1);
}

char *std::vector<CLMicroLocationModelTable::Entry>::__vallocate[abi:ne180100](_QWORD *a1, unint64_t a2)
{
  char *result;
  uint64_t v4;

  if (a2 >= 0xD20D20D20D20D3)
    std::vector<CLMicroLocationProto::ConfidenceReason>::__throw_length_error[abi:ne180100]();
  result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<CLMicroLocationModelTable::Entry>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[312 * v4];
  return result;
}

CLMicroLocationModelTable::Entry *std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<CLMicroLocationModelTable::Entry>,CLMicroLocationModelTable::Entry*,CLMicroLocationModelTable::Entry*,CLMicroLocationModelTable::Entry*>(uint64_t a1, CLMicroLocationModelTable::Entry *a2, CLMicroLocationModelTable::Entry *a3, CLMicroLocationModelTable::Entry *this)
{
  CLMicroLocationModelTable::Entry *v4;
  const CLMicroLocationModelTable::Entry *v6;
  _QWORD v8[3];
  char v9;
  CLMicroLocationModelTable::Entry *v10;
  CLMicroLocationModelTable::Entry *v11;

  v4 = this;
  v10 = this;
  v11 = this;
  v8[0] = a1;
  v8[1] = &v10;
  v8[2] = &v11;
  v9 = 0;
  if (a2 != a3)
  {
    v6 = a2;
    do
    {
      CLMicroLocationModelTable::Entry::Entry(v4, v6);
      v6 = (const CLMicroLocationModelTable::Entry *)((char *)v6 + 312);
      v4 = (CLMicroLocationModelTable::Entry *)((char *)v11 + 312);
      v11 = (CLMicroLocationModelTable::Entry *)((char *)v11 + 312);
    }
    while (v6 != a3);
  }
  v9 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<CLMicroLocationModelTable::Entry>,CLMicroLocationModelTable::Entry*>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v8);
  return v4;
}

void sub_241A16A94(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<CLMicroLocationModelTable::Entry>,CLMicroLocationModelTable::Entry*>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<CLMicroLocationModelTable::Entry>,CLMicroLocationModelTable::Entry*>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24))
    std::_AllocatorDestroyRangeReverse<std::allocator<CLMicroLocationModelTable::Entry>,CLMicroLocationModelTable::Entry*>::operator()[abi:ne180100]((uint64_t *)a1);
  return a1;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<CLMicroLocationModelTable::Entry>,CLMicroLocationModelTable::Entry*>::operator()[abi:ne180100](uint64_t *a1)
{
  uint64_t *v1;
  uint64_t *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  v2 = (uint64_t *)a1[1];
  v1 = (uint64_t *)a1[2];
  v3 = *v1;
  v4 = *v2;
  if (*v1 != *v2)
  {
    v5 = *a1;
    do
    {
      v3 -= 312;
      std::allocator<CLMicroLocationModelTable::Entry>::destroy[abi:ne180100](v5, v3);
    }
    while (v3 != v4);
  }
}

void std::vector<CLMicroLocationModelTable::Entry>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v1;
  void *v2;
  uint64_t v4;
  void *v5;

  v1 = *a1;
  v2 = **a1;
  if (v2)
  {
    v4 = (uint64_t)v1[1];
    v5 = **a1;
    if ((void *)v4 != v2)
    {
      do
      {
        v4 -= 312;
        std::allocator<CLMicroLocationModelTable::Entry>::destroy[abi:ne180100]((uint64_t)(v1 + 2), v4);
      }
      while ((void *)v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t std::vector<CLMicroLocationModelTable::Entry>::__push_back_slow_path<CLMicroLocationModelTable::Entry const&>(uint64_t *a1, const CLMicroLocationModelTable::Entry *a2)
{
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  char *v10;
  uint64_t v11;
  void *v13;
  CLMicroLocationModelTable::Entry *v14;
  char *v15;
  char *v16;
  uint64_t *v17;

  v3 = *a1;
  v4 = 0x6F96F96F96F96F97 * ((a1[1] - *a1) >> 3);
  v5 = v4 + 1;
  if ((unint64_t)(v4 + 1) > 0xD20D20D20D20D2)
    std::vector<CLMicroLocationProto::ConfidenceReason>::__throw_length_error[abi:ne180100]();
  v7 = (uint64_t)(a1 + 2);
  v8 = 0x6F96F96F96F96F97 * ((a1[2] - v3) >> 3);
  if (2 * v8 > v5)
    v5 = 2 * v8;
  if (v8 >= 0x69069069069069)
    v9 = 0xD20D20D20D20D2;
  else
    v9 = v5;
  v17 = a1 + 2;
  if (v9)
    v10 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<CLMicroLocationModelTable::Entry>>(v7, v9);
  else
    v10 = 0;
  v13 = v10;
  v14 = (CLMicroLocationModelTable::Entry *)&v10[312 * v4];
  v16 = &v10[312 * v9];
  CLMicroLocationModelTable::Entry::Entry(v14, a2);
  v15 = (char *)v14 + 312;
  std::vector<CLMicroLocationModelTable::Entry>::__swap_out_circular_buffer(a1, &v13);
  v11 = a1[1];
  std::__split_buffer<CLMicroLocationModelTable::Entry>::~__split_buffer(&v13);
  return v11;
}

void sub_241A16CB8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__split_buffer<CLMicroLocationModelTable::Entry>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

uint64_t CLMicroLocationConfigurationTable::Entry::Entry(uint64_t a1, __int128 *a2, CLMicroLocationProto::Configuration *a3, uint64_t a4, uint64_t a5)
{
  __int128 v6;

  *(_QWORD *)a1 = *((_QWORD *)a3 + 1);
  v6 = *a2;
  *(_QWORD *)(a1 + 24) = *((_QWORD *)a2 + 2);
  *(_OWORD *)(a1 + 8) = v6;
  *((_QWORD *)a2 + 1) = 0;
  *((_QWORD *)a2 + 2) = 0;
  *(_QWORD *)a2 = 0;
  *(_QWORD *)(a1 + 32) = a4;
  *(_QWORD *)(a1 + 40) = a5;
  *(_DWORD *)(a1 + 48) = *((_DWORD *)a3 + 10);
  CLMicroLocationProto::Configuration::Configuration((CLMicroLocationProto::Configuration *)(a1 + 56), a3);
  return a1;
}

void sub_241A16D30(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void **v2;

  if (*(char *)(v1 + 31) < 0)
    operator delete(*v2);
  _Unwind_Resume(exception_object);
}

void sub_241A17898(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_241A17974(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

float CLHierarchicalClustering::singleLinkage(uint64_t a1, unint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5, unint64_t a6)
{
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;
  float result;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;

  if (a2 <= a6)
    v6 = a6;
  else
    v6 = a2;
  if (a2 >= a6)
    v7 = a6;
  else
    v7 = a2;
  v8 = v7 + ((v6 + v6 * v6) >> 1);
  v9 = *(_QWORD *)(a1 + 8);
  result = *(float *)(v9 + 4 * v8);
  if (a4 <= a6)
    v11 = a6;
  else
    v11 = a4;
  if (a4 >= a6)
    v12 = a6;
  else
    v12 = a4;
  v13 = v12 + ((v11 + v11 * v11) >> 1);
  if (*(float *)(v9 + 4 * v13) < result)
    return *(float *)(v9 + 4 * v13);
  return result;
}

float CLHierarchicalClustering::averageLinkage(uint64_t a1, unint64_t a2, unint64_t a3, unint64_t a4, unint64_t a5, unint64_t a6)
{
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;
  float v10;
  unint64_t v11;
  unint64_t v12;
  float result;

  if (a2 <= a6)
    v6 = a6;
  else
    v6 = a2;
  if (a2 >= a6)
    v7 = a6;
  else
    v7 = a2;
  v8 = v7 + ((v6 + v6 * v6) >> 1);
  v9 = *(_QWORD *)(a1 + 8);
  v10 = *(float *)(v9 + 4 * v8);
  if (a4 <= a6)
    v11 = a6;
  else
    v11 = a4;
  if (a4 >= a6)
    v12 = a6;
  else
    v12 = a4;
  result = *(float *)(v9 + 4 * (v12 + ((v11 + v11 * v11) >> 1)));
  if (v10 >= 3.4028e38)
  {
    if (result >= 3.4028e38)
      return 3.4028e38;
  }
  else if (result >= 3.4028e38)
  {
    return v10;
  }
  else
  {
    return (float)((float)(result * (float)a5) + (float)((float)a3 * v10)) / (float)(a5 + a3);
  }
  return result;
}

float CLHierarchicalClustering::completeLinkage(uint64_t a1, unint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5, unint64_t a6)
{
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;
  float result;
  unint64_t v11;
  unint64_t v12;
  float v13;

  if (a2 <= a6)
    v6 = a6;
  else
    v6 = a2;
  if (a2 >= a6)
    v7 = a6;
  else
    v7 = a2;
  v8 = v7 + ((v6 + v6 * v6) >> 1);
  v9 = *(_QWORD *)(a1 + 8);
  result = *(float *)(v9 + 4 * v8);
  if (a4 <= a6)
    v11 = a6;
  else
    v11 = a4;
  if (a4 >= a6)
    v12 = a6;
  else
    v12 = a4;
  v13 = *(float *)(v9 + 4 * (v12 + ((v11 + v11 * v11) >> 1)));
  if (result >= 3.4028e38)
  {
    result = 3.4028e38;
    if (v13 < 3.4028e38)
      return *(float *)(v9 + 4 * (v12 + ((v11 + v11 * v11) >> 1)));
  }
  else if (v13 < 3.4028e38 && result < v13)
  {
    return *(float *)(v9 + 4 * (v12 + ((v11 + v11 * v11) >> 1)));
  }
  return result;
}

char **CLHierarchicalClustering::CLHierarchicalClustering(char **a1, unint64_t *a2, uint64_t a3)
{
  char **v5;
  unint64_t v6;
  uint64_t *v7;
  uint64_t *v8;
  uint64_t *v9;
  unint64_t v10;
  float v11;
  uint64_t *v12;
  uint64_t *v13;
  uint64_t *v14;
  uint64_t *v15;
  BOOL v16;
  unint64_t v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t *v20;
  uint64_t *v21;
  uint64_t *v22;
  uint64_t *v23;
  uint64_t *v24;
  uint64_t *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t v30;
  unint64_t v31;
  char *v32;
  char *v33;
  uint64_t v34;
  unint64_t v35;
  uint64_t v36;
  unint64_t v37;
  char *v38;
  uint64_t v39;
  char *v40;
  char *v41;
  char *v42;
  char *v43;
  __int128 v44;
  NSObject *v45;
  uint64_t *v46;
  int v47;
  id v48;
  uint64_t v49;
  uint64_t *v50;
  uint64_t *v51;
  uint64_t v53;
  char **v54;
  uint64_t *v55;
  _QWORD *v56;
  unint64_t v57;
  uint8_t buf[8];
  _BYTE v59[10];
  __int16 v60;
  uint64_t v61;
  __int16 v62;
  uint64_t v63;
  __int16 v64;
  double v65;
  __int16 v66;
  uint64_t v67;
  uint64_t v68;

  v5 = a1;
  v68 = *MEMORY[0x24BDAC8D0];
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  std::vector<CLHierarchicalClustering::GraphEdge>::reserve((void **)a1, *a2 - 1);
  v56 = 0;
  v57 = 0;
  v55 = (uint64_t *)&v56;
  if (*a2)
  {
    v54 = v5;
    v6 = 0;
    do
    {
      *(_QWORD *)buf = v6;
      *(_QWORD *)v59 = 1;
      std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::__emplace_hint_unique_key_args<unsigned long,std::pair<unsigned long,unsigned long>>(&v55, &v56, (unint64_t *)buf, buf);
      ++v6;
    }
    while (v6 < *a2);
    if (v57 >= 2)
    {
      v53 = a3;
      do
      {
        v7 = v55;
        if (v55 == (uint64_t *)&v56)
        {
          v9 = 0;
          v8 = 0;
          v11 = INFINITY;
        }
        else
        {
          v8 = 0;
          v9 = 0;
          v11 = INFINITY;
          do
          {
            v12 = (uint64_t *)v7[1];
            v13 = v12;
            v14 = v7;
            if (v12)
            {
              do
              {
                v15 = v13;
                v13 = (uint64_t *)*v13;
              }
              while (v13);
            }
            else
            {
              do
              {
                v15 = (uint64_t *)v14[2];
                v16 = *v15 == (_QWORD)v14;
                v14 = v15;
              }
              while (!v16);
            }
            if (v15 != (uint64_t *)&v56)
            {
              v17 = v7[4];
              do
              {
                v18 = v15[4];
                if (v17 <= v18)
                  v19 = v15[4];
                else
                  v19 = v7[4];
                if (v17 < v18)
                  v18 = v7[4];
                v10 = a2[1];
                if (*(float *)(v10 + 4 * (v18 + ((unint64_t)(v19 + v19 * v19) >> 1))) < v11)
                {
                  v11 = *(float *)(v10 + 4 * (v18 + ((unint64_t)(v19 + v19 * v19) >> 1)));
                  v9 = v15;
                  v8 = v7;
                }
                v20 = (uint64_t *)v15[1];
                if (v20)
                {
                  do
                  {
                    v21 = v20;
                    v20 = (uint64_t *)*v20;
                  }
                  while (v20);
                }
                else
                {
                  do
                  {
                    v21 = (uint64_t *)v15[2];
                    v16 = *v21 == (_QWORD)v15;
                    v15 = v21;
                  }
                  while (!v16);
                }
                v15 = v21;
              }
              while (v21 != (uint64_t *)&v56);
            }
            if (v12)
            {
              do
              {
                v22 = v12;
                v12 = (uint64_t *)*v12;
              }
              while (v12);
            }
            else
            {
              do
              {
                v22 = (uint64_t *)v7[2];
                v16 = *v22 == (_QWORD)v7;
                v7 = v22;
              }
              while (!v16);
            }
            v7 = v22;
          }
          while (v22 != (uint64_t *)&v56);
        }
        if (fabsf(v11) == INFINITY)
        {
          CLHierarchicalClustering::CLHierarchicalClustering((NSObject **)buf);

          abort_report_np();
          __break(1u);
        }
        v23 = (uint64_t *)v9[1];
        v24 = v9;
        if (v23)
        {
          do
          {
            v25 = v23;
            v23 = (uint64_t *)*v23;
          }
          while (v23);
        }
        else
        {
          do
          {
            v25 = (uint64_t *)v24[2];
            v16 = *v25 == (_QWORD)v24;
            v24 = v25;
          }
          while (!v16);
        }
        v26 = v8[4];
        v27 = v8[5];
        v29 = v9[4];
        v28 = v9[5];
        v30 = (unint64_t)v5[1];
        v31 = (unint64_t)v5[2];
        if (v30 >= v31)
        {
          v33 = *v5;
          v34 = (uint64_t)(v30 - (_QWORD)*v5) >> 5;
          v35 = v34 + 1;
          if ((unint64_t)(v34 + 1) >> 59)
            std::vector<CLMicroLocationProto::ConfidenceReason>::__throw_length_error[abi:ne180100]();
          v36 = v31 - (_QWORD)v33;
          if (v36 >> 4 > v35)
            v35 = v36 >> 4;
          if ((unint64_t)v36 >= 0x7FFFFFFFFFFFFFE0)
            v37 = 0x7FFFFFFFFFFFFFFLL;
          else
            v37 = v35;
          v38 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<CLMicroLocationResultInternal>>((uint64_t)(v54 + 2), v37);
          v40 = &v38[32 * v34];
          *(_QWORD *)v40 = v26;
          *((_QWORD *)v40 + 1) = v29;
          *((float *)v40 + 4) = v11;
          *((_QWORD *)v40 + 3) = v28 + v27;
          v42 = *v54;
          v41 = v54[1];
          v43 = v40;
          if (v41 != *v54)
          {
            do
            {
              v44 = *((_OWORD *)v41 - 1);
              *((_OWORD *)v43 - 2) = *((_OWORD *)v41 - 2);
              *((_OWORD *)v43 - 1) = v44;
              v43 -= 32;
              v41 -= 32;
            }
            while (v41 != v42);
            v41 = *v54;
          }
          v32 = v40 + 32;
          *v54 = v43;
          v54[1] = v40 + 32;
          v54[2] = &v38[32 * v39];
          if (v41)
            operator delete(v41);
        }
        else
        {
          *(_QWORD *)v30 = v26;
          *(_QWORD *)(v30 + 8) = v29;
          *(float *)(v30 + 16) = v11;
          v32 = (char *)(v30 + 32);
          *(_QWORD *)(v30 + 24) = v28 + v27;
        }
        v54[1] = v32;
        if (onceToken_MicroLocation_Default != -1)
          dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_18);
        v45 = logObject_MicroLocation_Default;
        if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 68290050;
          *(_DWORD *)&buf[4] = 0;
          *(_WORD *)v59 = 2082;
          *(_QWORD *)&v59[2] = "";
          v60 = 2050;
          v61 = v26;
          v62 = 2050;
          v63 = v29;
          v64 = 2050;
          v65 = v11;
          v66 = 2050;
          v67 = v28 + v27;
          _os_log_impl(&dword_2419D9000, v45, OS_LOG_TYPE_DEBUG, "{\"msg%{public}.0s\":\"dendrogram\", \"left\":%{public}lu, \"right\":%{public}lu, \"dist\":\"%{public}f\", \"size\":%{public}lu}", buf, 0x3Au);
        }
        *(_QWORD *)buf = v29;
        *(_QWORD *)v59 = v28 + v27;
        std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::__remove_node_pointer(&v55, v8);
        operator delete(v8);
        std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::__remove_node_pointer(&v55, v9);
        operator delete(v9);
        v46 = v55;
        if (v55 != (uint64_t *)&v56)
        {
          do
          {
            std::function<float ()(CLDistanceMatrixTemplate<CLSymmetricMatrixStorage<float>> const&,std::pair<unsigned long,unsigned long>,std::pair<unsigned long,unsigned long>,std::pair<unsigned long,unsigned long>)>::operator()(v53, (uint64_t)a2, v26, v27, v29, v28, v46[4], v46[5]);
            v48 = (id)v46[4];
            if ((unint64_t)v48 <= *(_QWORD *)buf)
              v49 = *(_QWORD *)buf;
            else
              v49 = v46[4];
            if ((unint64_t)v48 >= *(_QWORD *)buf)
              v48 = *(id *)buf;
            *(_DWORD *)(a2[1] + 4 * ((_QWORD)v48 + ((unint64_t)(v49 + v49 * v49) >> 1))) = v47;
            v50 = (uint64_t *)v46[1];
            if (v50)
            {
              do
              {
                v51 = v50;
                v50 = (uint64_t *)*v50;
              }
              while (v50);
            }
            else
            {
              do
              {
                v51 = (uint64_t *)v46[2];
                v16 = *v51 == (_QWORD)v46;
                v46 = v51;
              }
              while (!v16);
            }
            v46 = v51;
          }
          while (v51 != (uint64_t *)&v56);
        }
        std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::__emplace_hint_unique_key_args<unsigned long,std::pair<unsigned long,unsigned long>>(&v55, v25, (unint64_t *)buf, buf);
        v5 = v54;
      }
      while (v57 > 1);
    }
  }
  std::__tree<std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>,std::__map_value_compare<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>,std::less<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes>,true>,std::allocator<std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>>>::destroy((uint64_t)&v55, v56);
  return v5;
}

void sub_241A17FDC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, char a20,uint64_t a21)
{
  uint64_t v21;
  void *v23;

  v23 = *(void **)v21;
  if (*(_QWORD *)v21)
  {
    *(_QWORD *)(v21 + 8) = v23;
    operator delete(v23);
  }
  _Unwind_Resume(exception_object);
}

void std::vector<CLHierarchicalClustering::GraphEdge>::reserve(void **a1, unint64_t a2)
{
  uint64_t v3;
  _BYTE *v4;
  int64_t v5;
  char *v6;
  char *v7;
  uint64_t v8;
  char *v9;
  char *v10;
  char *v11;
  char *v12;
  __int128 v13;

  v4 = a1[2];
  v3 = (uint64_t)(a1 + 2);
  if (a2 > (v4 - (_BYTE *)*a1) >> 5)
  {
    if (a2 >> 59)
      std::vector<CLMicroLocationProto::ConfidenceReason>::__throw_length_error[abi:ne180100]();
    v5 = (_BYTE *)a1[1] - (_BYTE *)*a1;
    v6 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<CLMicroLocationResultInternal>>(v3, a2);
    v7 = &v6[v5 & 0xFFFFFFFFFFFFFFE0];
    v9 = &v6[32 * v8];
    v11 = (char *)*a1;
    v10 = (char *)a1[1];
    v12 = v7;
    if (v10 != *a1)
    {
      do
      {
        v13 = *((_OWORD *)v10 - 1);
        *((_OWORD *)v12 - 2) = *((_OWORD *)v10 - 2);
        *((_OWORD *)v12 - 1) = v13;
        v12 -= 32;
        v10 -= 32;
      }
      while (v10 != v11);
      v10 = (char *)*a1;
    }
    *a1 = v12;
    a1[1] = v7;
    a1[2] = v9;
    if (v10)
      operator delete(v10);
  }
}

uint64_t std::function<float ()(CLDistanceMatrixTemplate<CLSymmetricMatrixStorage<float>> const&,std::pair<unsigned long,unsigned long>,std::pair<unsigned long,unsigned long>,std::pair<unsigned long,unsigned long>)>::operator()(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  _QWORD v10[2];
  _QWORD v11[2];
  _QWORD v12[2];

  v12[0] = a3;
  v12[1] = a4;
  v11[0] = a5;
  v11[1] = a6;
  v10[0] = a7;
  v10[1] = a8;
  v8 = *(_QWORD *)(a1 + 24);
  if (!v8)
    std::__throw_bad_function_call[abi:ne180100]();
  return (*(uint64_t (**)(uint64_t, uint64_t, _QWORD *, _QWORD *, _QWORD *))(*(_QWORD *)v8 + 48))(v8, a2, v12, v11, v10);
}

uint64_t CLHierarchicalClustering::getClusterLabels(uint64_t *a1, _QWORD *a2, _QWORD *a3, unint64_t a4, unint64_t a5, double a6)
{
  _QWORD *v6;
  unint64_t v7;
  unint64_t v8;
  _QWORD *v9;
  uint64_t *v10;
  double v11;
  NSObject *v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  double v17;
  uint64_t v18;
  BOOL v19;
  unint64_t v21;
  uint64_t v22;
  BOOL v23;
  uint64_t v24;
  unint64_t v25;
  double v26;
  double v27;
  uint64_t v28;
  NSObject *v29;
  const char *v30;
  uint64_t v31;
  unint64_t v32;
  double v33;
  double v34;
  uint64_t v35;
  uint64_t v36;
  unint64_t v37;
  double v38;
  BOOL v39;
  unint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint8_t buf[8];
  __int16 v46;
  const char *v47;
  __int16 v48;
  unint64_t v49;
  __int16 v50;
  double v51;
  __int16 v52;
  double v53;
  __int16 v54;
  uint64_t v55;
  uint64_t v56;

  v56 = *MEMORY[0x24BDAC8D0];
  if (*a3 == a3[1])
  {
    CLHierarchicalClustering::getClusterLabels();
  }
  else
  {
    v7 = a5;
    if (*(double *)&a5 != 0.0)
    {
      v8 = a4;
      v11 = a6;
      v9 = a3;
      v6 = a2;
      v10 = a1;
      if (onceToken_MicroLocation_Default == -1)
        goto LABEL_4;
      goto LABEL_48;
    }
    CLHierarchicalClustering::getClusterLabels();
  }
  __break(1u);
LABEL_48:
  dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_18);
LABEL_4:
  v12 = logObject_MicroLocation_Default;
  if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 68289794;
    *(_DWORD *)&buf[4] = 0;
    v46 = 2082;
    v47 = "";
    v48 = 2050;
    v49 = v8;
    v50 = 2050;
    v51 = v11;
    v52 = 2050;
    v53 = *(double *)&v7;
    _os_log_impl(&dword_2419D9000, v12, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"getClusterLabels\", \"smallNodeSize\":%{public}lu, \"distanceThresholdForSmallNode\":\"%{public}f\", \"minNumClusters\":%{public}lu}", buf, 0x30u);
  }
  v6[1] = *v6;
  v13 = ((v10[1] - *v10) >> 5) + 1;
  *(_QWORD *)buf = 0;
  std::vector<unsigned long>::resize((uint64_t)v6, v13, buf);
  v14 = v10[1];
  v15 = *v10;
  if (v14 == *v10)
    return 1;
  v16 = v9[1];
  v17 = *(float *)(v14 - 16);
  if (v16 == *v9)
    v18 = -1;
  else
    v18 = 0;
  v19 = v7 > 1;
  if (*(double *)(*v9 + 8 * v18) < v17 || v7 >= 2)
  {
    v21 = (v16 - *v9) >> 3;
    v40 = 1;
    while (1)
    {
      v22 = *v6;
      v23 = v17 > v11 || *(_QWORD *)(v14 - 8) > v8;
      if (v23 || v19)
      {
        *(_QWORD *)(v22 + 8 * *(_QWORD *)(v14 - 32)) = v40;
        if (onceToken_MicroLocation_Default != -1)
          dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_18);
        ++v40;
        v31 = logObject_MicroLocation_Default;
        if (!os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEBUG))
          goto LABEL_30;
        v32 = *(_QWORD *)(v14 - 32);
        v33 = *(double *)(v14 - 24);
        v34 = *(float *)(v14 - 16);
        v35 = *(_QWORD *)(v14 - 8);
        *(_DWORD *)buf = 68290050;
        *(_DWORD *)&buf[4] = 0;
        v46 = 2082;
        v47 = "";
        v48 = 2050;
        v49 = v32;
        v50 = 2050;
        v51 = v33;
        v52 = 2050;
        v53 = v34;
        v54 = 2050;
        v55 = v35;
        v29 = v31;
        v30 = "{\"msg%{public}.0s\":\"getClusterLabels - split\", \"left\":%{public}lu, \"right\":%{public}lu, \"dist\":\""
              "%{public}f\", \"size\":%{public}lu}";
      }
      else
      {
        *(_QWORD *)(v22 + 8 * *(_QWORD *)(v14 - 32)) = *(_QWORD *)(v22 + 8 * *(_QWORD *)(v14 - 24));
        if (onceToken_MicroLocation_Default != -1)
          dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_18);
        v24 = logObject_MicroLocation_Default;
        if (!os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEBUG))
          goto LABEL_30;
        v25 = *(_QWORD *)(v14 - 32);
        v26 = *(double *)(v14 - 24);
        v27 = *(float *)(v14 - 16);
        v28 = *(_QWORD *)(v14 - 8);
        *(_DWORD *)buf = 68290050;
        *(_DWORD *)&buf[4] = 0;
        v46 = 2082;
        v47 = "";
        v48 = 2050;
        v49 = v25;
        v50 = 2050;
        v51 = v26;
        v52 = 2050;
        v53 = v27;
        v54 = 2050;
        v55 = v28;
        v29 = v24;
        v30 = "{\"msg%{public}.0s\":\"getClusterLabels - don't split\", \"left\":%{public}lu, \"right\":%{public}lu, \"di"
              "st\":\"%{public}f\", \"size\":%{public}lu}";
      }
      _os_log_impl(&dword_2419D9000, v29, OS_LOG_TYPE_DEBUG, v30, buf, 0x3Au);
LABEL_30:
      v36 = v14 - 32;
      v15 = *v10;
      if (v14 - 32 == *v10)
        return v40;
      v17 = *(float *)(v14 - 48);
      if (v21 >= v40)
        v37 = v40;
      else
        v37 = v21;
      v38 = *(double *)(*v9 + 8 * v37 - 8);
      v19 = v40 < v7;
      v39 = v38 >= v17 && v40 >= v7;
      v14 -= 32;
      if (v39)
      {
        v14 = v36;
        goto LABEL_41;
      }
    }
  }
  v40 = 1;
LABEL_41:
  if (v14 != v15)
  {
    v41 = *v6;
    do
    {
      v42 = *(_QWORD *)(v14 - 32);
      v43 = *(_QWORD *)(v14 - 24);
      v14 -= 32;
      *(_QWORD *)(v41 + 8 * v42) = *(_QWORD *)(v41 + 8 * v43);
    }
    while (v14 != v15);
  }
  return v40;
}

void std::vector<unsigned long>::resize(uint64_t a1, unint64_t a2, _QWORD *a3)
{
  unint64_t v3;

  v3 = (uint64_t)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 3;
  if (a2 <= v3)
  {
    if (a2 < v3)
      *(_QWORD *)(a1 + 8) = *(_QWORD *)a1 + 8 * a2;
  }
  else
  {
    std::vector<unsigned long>::__append((void **)a1, a2 - v3, a3);
  }
}

uint64_t CLHierarchicalClustering::getClusterLabels(uint64_t *a1, _QWORD *a2, unint64_t a3, double a4, double a5)
{
  uint64_t ClusterLabels;
  void *__p[3];
  double v12;

  v12 = a4;
  std::vector<double>::vector(__p, 1uLL, &v12);
  ClusterLabels = CLHierarchicalClustering::getClusterLabels(a1, a2, __p, a3, 1uLL, a5);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  return ClusterLabels;
}

void sub_241A18604(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void ___ZL45_CLLogObjectForCategory_MicroLocation_Defaultv_block_invoke_13()
{
  os_log_t v0;
  void *v1;

  v0 = os_log_create("com.apple.MicroLocation", "MicroLocation");
  v1 = (void *)logObject_MicroLocation_Default;
  logObject_MicroLocation_Default = (uint64_t)v0;

}

uint64_t *std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::__emplace_hint_unique_key_args<unsigned long,std::pair<unsigned long,unsigned long>>(uint64_t **a1, _QWORD *a2, unint64_t *a3, _OWORD *a4)
{
  void **v6;
  uint64_t *v7;
  uint64_t **v8;
  uint64_t v10;
  uint64_t v11;

  v6 = (void **)std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::__find_equal<unsigned long>(a1, a2, &v11, &v10, a3);
  v7 = (uint64_t *)*v6;
  if (!*v6)
  {
    v8 = (uint64_t **)v6;
    v7 = (uint64_t *)operator new(0x30uLL);
    *((_OWORD *)v7 + 2) = *a4;
    std::__tree<CLMicroLocationRecordingCompletionMetaInformation::RecordingError>::__insert_node_at(a1, v11, v8, v7);
  }
  return v7;
}

_QWORD *std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::__find_equal<unsigned long>(_QWORD *a1, _QWORD *a2, _QWORD *a3, _QWORD *a4, unint64_t *a5)
{
  _QWORD *v5;
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  _QWORD *v9;
  _QWORD *v10;
  uint64_t v11;
  _QWORD *v12;
  _QWORD *v13;
  BOOL v14;
  unint64_t v15;
  _QWORD *v16;
  _QWORD *v17;
  unint64_t v18;
  _QWORD *v19;
  _QWORD *v20;
  _QWORD *v21;
  unint64_t v22;

  v5 = a1 + 1;
  if (a1 + 1 == a2 || (v6 = *a5, v7 = a2[4], *a5 < v7))
  {
    v8 = *a2;
    if ((_QWORD *)*a1 == a2)
    {
      v10 = a2;
LABEL_17:
      if (v8)
      {
        *a3 = v10;
        return v10 + 1;
      }
      else
      {
        *a3 = a2;
        return a2;
      }
    }
    if (v8)
    {
      v9 = (_QWORD *)*a2;
      do
      {
        v10 = v9;
        v9 = (_QWORD *)v9[1];
      }
      while (v9);
    }
    else
    {
      v13 = a2;
      do
      {
        v10 = (_QWORD *)v13[2];
        v14 = *v10 == (_QWORD)v13;
        v13 = v10;
      }
      while (v14);
    }
    v15 = *a5;
    if (v10[4] < *a5)
      goto LABEL_17;
    v16 = (_QWORD *)*v5;
    if (*v5)
    {
      do
      {
        while (1)
        {
          v17 = v16;
          v18 = v16[4];
          if (v15 >= v18)
            break;
          v16 = (_QWORD *)*v17;
          v5 = v17;
          if (!*v17)
            goto LABEL_29;
        }
        if (v18 >= v15)
          break;
        v5 = v17 + 1;
        v16 = (_QWORD *)v17[1];
      }
      while (v16);
    }
    else
    {
      v17 = a1 + 1;
    }
LABEL_29:
    *a3 = v17;
    return v5;
  }
  if (v7 >= v6)
  {
    *a3 = a2;
    *a4 = a2;
    return a4;
  }
  v11 = a2[1];
  if (v11)
  {
    v12 = (_QWORD *)a2[1];
    do
    {
      a4 = v12;
      v12 = (_QWORD *)*v12;
    }
    while (v12);
  }
  else
  {
    v19 = a2;
    do
    {
      a4 = (_QWORD *)v19[2];
      v14 = *a4 == (_QWORD)v19;
      v19 = a4;
    }
    while (!v14);
  }
  if (a4 != v5 && v6 >= a4[4])
  {
    v20 = (_QWORD *)*v5;
    if (*v5)
    {
      do
      {
        while (1)
        {
          v21 = v20;
          v22 = v20[4];
          if (v6 >= v22)
            break;
          v20 = (_QWORD *)*v21;
          v5 = v21;
          if (!*v21)
            goto LABEL_48;
        }
        if (v22 >= v6)
          break;
        v5 = v21 + 1;
        v20 = (_QWORD *)v21[1];
      }
      while (v20);
    }
    else
    {
      v21 = a1 + 1;
    }
LABEL_48:
    *a3 = v21;
    return v5;
  }
  if (v11)
  {
    *a3 = a4;
  }
  else
  {
    *a3 = a2;
    return a2 + 1;
  }
  return a4;
}

uint64_t *std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::__remove_node_pointer(uint64_t **a1, uint64_t *a2)
{
  uint64_t *v2;
  uint64_t *v3;
  uint64_t *v4;
  BOOL v5;
  uint64_t *v6;

  v2 = (uint64_t *)a2[1];
  if (v2)
  {
    do
    {
      v3 = v2;
      v2 = (uint64_t *)*v2;
    }
    while (v2);
  }
  else
  {
    v4 = a2;
    do
    {
      v3 = (uint64_t *)v4[2];
      v5 = *v3 == (_QWORD)v4;
      v4 = v3;
    }
    while (!v5);
  }
  if (*a1 == a2)
    *a1 = v3;
  v6 = a1[1];
  a1[2] = (uint64_t *)((char *)a1[2] - 1);
  std::__tree_remove[abi:ne180100]<std::__tree_node_base<void *> *>(v6, a2);
  return v3;
}

uint64_t *std::__tree_remove[abi:ne180100]<std::__tree_node_base<void *> *>(uint64_t *result, uint64_t *a2)
{
  uint64_t v2;
  uint64_t *v3;
  uint64_t *v4;
  int v5;
  uint64_t **v6;
  uint64_t *v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  _QWORD *v15;
  uint64_t *v16;
  uint64_t *v17;
  uint64_t v18;
  _QWORD *v19;
  uint64_t *v20;
  BOOL v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;

  v2 = *a2;
  v3 = a2;
  if (*a2)
  {
    v4 = (uint64_t *)a2[1];
    if (!v4)
    {
      v3 = a2;
      goto LABEL_7;
    }
    do
    {
      v3 = v4;
      v4 = (uint64_t *)*v4;
    }
    while (v4);
  }
  v2 = v3[1];
  if (v2)
  {
LABEL_7:
    v5 = 0;
    *(_QWORD *)(v2 + 16) = v3[2];
    goto LABEL_8;
  }
  v5 = 1;
LABEL_8:
  v6 = (uint64_t **)v3[2];
  v7 = *v6;
  if (*v6 == v3)
  {
    *v6 = (uint64_t *)v2;
    if (v3 == result)
    {
      v7 = 0;
      result = (uint64_t *)v2;
    }
    else
    {
      v7 = v6[1];
    }
  }
  else
  {
    v6[1] = (uint64_t *)v2;
  }
  v8 = *((unsigned __int8 *)v3 + 24);
  if (v3 != a2)
  {
    v9 = a2[2];
    v3[2] = v9;
    *(_QWORD *)(v9 + 8 * (*(_QWORD *)a2[2] != (_QWORD)a2)) = v3;
    v11 = *a2;
    v10 = a2[1];
    *(_QWORD *)(v11 + 16) = v3;
    *v3 = v11;
    v3[1] = v10;
    if (v10)
      *(_QWORD *)(v10 + 16) = v3;
    *((_BYTE *)v3 + 24) = *((_BYTE *)a2 + 24);
    if (result == a2)
      result = v3;
  }
  if (!v8 || !result)
    return result;
  if (!v5)
  {
    *(_BYTE *)(v2 + 24) = 1;
    return result;
  }
  while (1)
  {
    v12 = v7[2];
    if (*(uint64_t **)v12 == v7)
      break;
    if (!*((_BYTE *)v7 + 24))
    {
      *((_BYTE *)v7 + 24) = 1;
      *(_BYTE *)(v12 + 24) = 0;
      v13 = *(uint64_t **)(v12 + 8);
      v14 = *v13;
      *(_QWORD *)(v12 + 8) = *v13;
      if (v14)
        *(_QWORD *)(v14 + 16) = v12;
      v13[2] = *(_QWORD *)(v12 + 16);
      *(_QWORD *)(*(_QWORD *)(v12 + 16) + 8 * (**(_QWORD **)(v12 + 16) != v12)) = v13;
      *v13 = v12;
      *(_QWORD *)(v12 + 16) = v13;
      if (result == (uint64_t *)*v7)
        result = v7;
      v7 = *(uint64_t **)(*v7 + 8);
    }
    v15 = (_QWORD *)*v7;
    if (*v7 && !*((_BYTE *)v15 + 24))
    {
      v16 = (uint64_t *)v7[1];
      if (!v16)
        goto LABEL_56;
LABEL_55:
      if (*((_BYTE *)v16 + 24))
      {
LABEL_56:
        *((_BYTE *)v15 + 24) = 1;
        *((_BYTE *)v7 + 24) = 0;
        v22 = v15[1];
        *v7 = v22;
        if (v22)
          *(_QWORD *)(v22 + 16) = v7;
        v15[2] = v7[2];
        *(_QWORD *)(v7[2] + 8 * (*(_QWORD *)v7[2] != (_QWORD)v7)) = v15;
        v15[1] = v7;
        v7[2] = (uint64_t)v15;
        v16 = v7;
      }
      else
      {
        v15 = v7;
      }
      v23 = v15[2];
      *((_BYTE *)v15 + 24) = *(_BYTE *)(v23 + 24);
      *(_BYTE *)(v23 + 24) = 1;
      *((_BYTE *)v16 + 24) = 1;
      v24 = *(uint64_t **)(v23 + 8);
      v25 = *v24;
      *(_QWORD *)(v23 + 8) = *v24;
      if (v25)
        *(_QWORD *)(v25 + 16) = v23;
      v24[2] = *(_QWORD *)(v23 + 16);
      *(_QWORD *)(*(_QWORD *)(v23 + 16) + 8 * (**(_QWORD **)(v23 + 16) != v23)) = v24;
      *v24 = v23;
      goto LABEL_72;
    }
    v16 = (uint64_t *)v7[1];
    if (v16 && !*((_BYTE *)v16 + 24))
      goto LABEL_55;
    *((_BYTE *)v7 + 24) = 0;
    v17 = (uint64_t *)v7[2];
    if (v17 == result)
    {
      v17 = result;
LABEL_53:
      *((_BYTE *)v17 + 24) = 1;
      return result;
    }
    if (!*((_BYTE *)v17 + 24))
      goto LABEL_53;
LABEL_49:
    v7 = *(uint64_t **)(v17[2] + 8 * (*(_QWORD *)v17[2] == (_QWORD)v17));
  }
  if (!*((_BYTE *)v7 + 24))
  {
    *((_BYTE *)v7 + 24) = 1;
    *(_BYTE *)(v12 + 24) = 0;
    v18 = v7[1];
    *(_QWORD *)v12 = v18;
    if (v18)
      *(_QWORD *)(v18 + 16) = v12;
    v7[2] = *(_QWORD *)(v12 + 16);
    *(_QWORD *)(*(_QWORD *)(v12 + 16) + 8 * (**(_QWORD **)(v12 + 16) != v12)) = v7;
    v7[1] = v12;
    *(_QWORD *)(v12 + 16) = v7;
    if (result == (uint64_t *)v12)
      result = v7;
    v7 = *(uint64_t **)v12;
  }
  v19 = (_QWORD *)*v7;
  if (*v7 && !*((_BYTE *)v19 + 24))
    goto LABEL_68;
  v20 = (uint64_t *)v7[1];
  if (!v20 || *((_BYTE *)v20 + 24))
  {
    *((_BYTE *)v7 + 24) = 0;
    v17 = (uint64_t *)v7[2];
    if (*((_BYTE *)v17 + 24))
      v21 = v17 == result;
    else
      v21 = 1;
    if (v21)
      goto LABEL_53;
    goto LABEL_49;
  }
  if (v19 && !*((_BYTE *)v19 + 24))
  {
LABEL_68:
    v20 = v7;
  }
  else
  {
    *((_BYTE *)v20 + 24) = 1;
    *((_BYTE *)v7 + 24) = 0;
    v26 = *v20;
    v7[1] = *v20;
    if (v26)
      *(_QWORD *)(v26 + 16) = v7;
    v20[2] = v7[2];
    *(_QWORD *)(v7[2] + 8 * (*(_QWORD *)v7[2] != (_QWORD)v7)) = v20;
    *v20 = (uint64_t)v7;
    v7[2] = (uint64_t)v20;
    v19 = v7;
  }
  v23 = v20[2];
  *((_BYTE *)v20 + 24) = *(_BYTE *)(v23 + 24);
  *(_BYTE *)(v23 + 24) = 1;
  *((_BYTE *)v19 + 24) = 1;
  v24 = *(uint64_t **)v23;
  v27 = *(_QWORD *)(*(_QWORD *)v23 + 8);
  *(_QWORD *)v23 = v27;
  if (v27)
    *(_QWORD *)(v27 + 16) = v23;
  v24[2] = *(_QWORD *)(v23 + 16);
  *(_QWORD *)(*(_QWORD *)(v23 + 16) + 8 * (**(_QWORD **)(v23 + 16) != v23)) = v24;
  v24[1] = v23;
LABEL_72:
  *(_QWORD *)(v23 + 16) = v24;
  return result;
}

void std::vector<unsigned long>::__append(void **a1, unint64_t a2, _QWORD *a3)
{
  uint64_t v6;
  _BYTE *v7;
  _BYTE *v8;
  _QWORD *v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  char *v15;
  uint64_t v16;
  _QWORD *v17;
  char *v18;
  char *v19;
  uint64_t v20;
  char *v21;
  char *v22;
  char *v23;
  char *i;
  uint64_t v25;

  v8 = a1[2];
  v6 = (uint64_t)(a1 + 2);
  v7 = v8;
  v9 = *(_QWORD **)(v6 - 8);
  if (a2 <= (v8 - (_BYTE *)v9) >> 3)
  {
    if (a2)
    {
      v16 = 8 * a2;
      v17 = &v9[a2];
      do
      {
        *v9++ = *a3;
        v16 -= 8;
      }
      while (v16);
      v9 = v17;
    }
    a1[1] = v9;
  }
  else
  {
    v10 = (char *)v9 - (_BYTE *)*a1;
    v11 = a2 + (v10 >> 3);
    if (v11 >> 61)
      std::vector<CLMicroLocationProto::ConfidenceReason>::__throw_length_error[abi:ne180100]();
    v12 = v10 >> 3;
    v13 = v7 - (_BYTE *)*a1;
    if (v13 >> 2 > v11)
      v11 = v13 >> 2;
    if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8)
      v14 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v14 = v11;
    if (v14)
      v15 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<CLMicroLocationWiFiChannelHistogram>>(v6, v14);
    else
      v15 = 0;
    v18 = &v15[8 * v12];
    v19 = &v18[8 * a2];
    v20 = 8 * a2;
    v21 = v18;
    do
    {
      *(_QWORD *)v21 = *a3;
      v21 += 8;
      v20 -= 8;
    }
    while (v20);
    v22 = &v15[8 * v14];
    v23 = (char *)*a1;
    for (i = (char *)a1[1]; i != v23; i -= 8)
    {
      v25 = *((_QWORD *)i - 1);
      *((_QWORD *)v18 - 1) = v25;
      v18 -= 8;
    }
    *a1 = v18;
    a1[1] = v19;
    a1[2] = v22;
    if (v23)
      operator delete(v23);
  }
}

_QWORD *std::vector<double>::vector(_QWORD *a1, unint64_t a2, _QWORD *a3)
{
  _QWORD *v6;
  _QWORD *v7;
  uint64_t v8;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<CLMicroLocationWiFiChannelHistogram>::__vallocate[abi:ne180100](a1, a2);
    v6 = (_QWORD *)a1[1];
    v7 = &v6[a2];
    v8 = 8 * a2;
    do
    {
      *v6++ = *a3;
      v8 -= 8;
    }
    while (v8);
    a1[1] = v7;
  }
  return a1;
}

void sub_241A18DE4(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

BOOL OUTLINED_FUNCTION_4_1(NSObject *a1)
{
  return os_log_type_enabled(a1, OS_LOG_TYPE_FAULT);
}

_QWORD *CLMicroLocationFingerprintStdVectorSource::CLMicroLocationFingerprintStdVectorSource(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t *v6;
  uint64_t v7;
  _OWORD *v11;
  _OWORD *v12;
  uint64_t v13;
  id v14;
  _OWORD *v15;
  const CLMicroLocationProto::RecordingEvent *v16;
  unint64_t v17;
  uint64_t v18;
  NSObject *v19;
  uint64_t v21[3];
  unint64_t v22[2];
  uint64_t v23;
  __int128 v24;
  char v25;
  _OWORD v26[9];
  char v27;
  uint8_t buf[8];
  _OWORD *v29;
  _OWORD *v30;
  char v31;
  uint64_t v32;

  v32 = *MEMORY[0x24BDAC8D0];
  *a1 = off_2511D37A8;
  a1[1] = 0;
  v6 = a1 + 1;
  a1[2] = 0;
  a1[3] = 0;
  v7 = *(_QWORD *)(a3 + 24);
  if (!v7)
    std::__throw_bad_function_call[abi:ne180100]();
  (*(void (**)(unint64_t *__return_ptr))(*(_QWORD *)v7 + 48))(v22);
  v11 = *(_OWORD **)a4;
  v12 = *(_OWORD **)(a4 + 8);
  if (*(_OWORD **)a4 != v12)
  {
    do
    {
      v13 = *(_QWORD *)(a2 + 24);
      if (!v13)
        std::__throw_bad_function_call[abi:ne180100]();
      if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v13 + 48))(v13))
      {
        if (onceToken_MicroLocation_Default != -1)
          dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_19);
        v19 = logObject_MicroLocation_Default;
        if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl(&dword_2419D9000, v19, OS_LOG_TYPE_DEFAULT, "Data source cancelled learning", buf, 2u);
        }
        break;
      }
      v14 = *(id *)(a5 + 64);
      v26[0] = *v11;
      v15 = operator new(0x10uLL);
      v29 = v15 + 1;
      v30 = v15 + 1;
      *v15 = v26[0];
      *(_QWORD *)buf = v15;
      if (v14)
      {
        objc_msgSend(v14, "fetchMeasurementsForRecordingUUIDs:", buf);
        v15 = *(_OWORD **)buf;
        if (!*(_QWORD *)buf)
          goto LABEL_10;
      }
      else
      {
        memset(v21, 0, sizeof(v21));
      }
      v29 = v15;
      operator delete(v15);
LABEL_10:

      CLMicroLocationsMeasurementFilters::filterStaleWiFiMeasurementsForFingerprint<CLMicroLocationMeasurementTable::Entry>(v21, (uint64_t)v11);
      v16 = (const CLMicroLocationProto::RecordingEvent *)(v11 + 5);
      CLMicroLocationProto::RecordingEvent::RecordingEvent((CLMicroLocationProto::RecordingEvent *)v26, v16);
      v27 = 1;
      v24 = *((_OWORD *)v16 - 5);
      v25 = 1;
      CLMicroLocationFingerprint::create(v21, (uint64_t)v26, (uint64_t)&v24, v22, buf);
      if (v27)
        CLMicroLocationProto::RecordingEvent::~RecordingEvent((CLMicroLocationProto::RecordingEvent *)v26);
      if (v31)
      {
        v17 = a1[2];
        if (v17 >= a1[3])
        {
          v18 = std::vector<CLMicroLocationFingerprint>::__emplace_back_slow_path<CLMicroLocationFingerprint>(v6, (uint64_t)buf);
        }
        else
        {
          std::allocator<CLMicroLocationFingerprint>::construct[abi:ne180100]<CLMicroLocationFingerprint,CLMicroLocationFingerprint>((uint64_t)(a1 + 3), a1[2], (uint64_t)buf);
          v18 = v17 + 192;
        }
        a1[2] = v18;
      }
      std::__optional_destruct_base<CLMicroLocationFingerprint,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)buf);
      *(_QWORD *)buf = v21;
      std::vector<CLMicroLocationMeasurementTable::Entry>::__destroy_vector::operator()[abi:ne180100]((void ***)buf);
      v11 = (_OWORD *)((char *)v16 + 168);
    }
    while (v11 != v12);
  }
  std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>>>::~__hash_table((uint64_t)&v23);
  return a1;
}

void sub_241A19084(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,char a41,uint64_t a42,void *__p,uint64_t a44)
{
  std::vector<CLMicroLocationFingerprint>::__destroy_vector::operator()[abi:ne180100]((void ***)&__p);
  _Unwind_Resume(a1);
}

void CLMicroLocationsMeasurementFilters::filterStaleWiFiMeasurementsForFingerprint<CLMicroLocationMeasurementTable::Entry>(uint64_t *a1, uint64_t a2)
{
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  double v8;
  double v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  NSObject *v13;
  uint64_t v14;
  uint64_t v15;
  char *v16;
  _DWORD v17[2];
  __int16 v18;
  const char *v19;
  __int16 v20;
  unint64_t v21;
  __int16 v22;
  unint64_t v23;
  __int16 v24;
  char *v25;
  uint64_t v26;

  v26 = *MEMORY[0x24BDAC8D0];
  +[ULDefaultsSingleton shared](ULDefaultsSingleton, "shared");
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v4, "defaultsDictionary");
  v5 = (void *)objc_claimAutoreleasedReturnValue();

  objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "ULMaximumAgeForValidity");
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v5, "objectForKey:", v6);
  v7 = (void *)objc_claimAutoreleasedReturnValue();
  if (v7 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
    objc_msgSend(v7, "doubleValue");
  else
    objc_msgSend(&unk_2511ED4E0, "doubleValue");
  v9 = v8;

  v11 = *a1;
  v10 = a1[1];
  v12 = std::remove_if[abi:ne180100]<std::__wrap_iter<CLMicroLocationMeasurementTable::Entry *>,void CLMicroLocationsMeasurementFilters::filterStaleWiFiMeasurementsForFingerprint<CLMicroLocationMeasurementTable::Entry>(std::vector<CLMicroLocationMeasurementTable::Entry> &,CLMicroLocationRecordingEventsTable::Entry const&)::{lambda(CLMicroLocationMeasurementTable::Entry const&)#1}>(*a1, v10, *(double *)(a2 + 16) - v9);
  std::vector<CLMicroLocationMeasurementTable::Entry>::erase((uint64_t)a1, v12, a1[1]);
  if (onceToken_MicroLocation_Default != -1)
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_19);
  v13 = (id)logObject_MicroLocation_Default;
  if (os_log_type_enabled(v13, OS_LOG_TYPE_INFO))
  {
    v15 = *a1;
    v14 = a1[1];
    v16 = (char *)operator new(0x28uLL);
    *(_QWORD *)(v16 + 29) = 0;
    *(_OWORD *)v16 = 0u;
    *((_OWORD *)v16 + 1) = 0u;
    boost::uuids::to_chars<char *>(a2, v16);
    v17[0] = 68289794;
    v17[1] = 0;
    v19 = "";
    v18 = 2082;
    v20 = 2050;
    v21 = 0xEEEEEEEEEEEEEEEFLL * ((v10 - v11) >> 3);
    v22 = 2050;
    v23 = 0xEEEEEEEEEEEEEEEFLL * ((v14 - v15) >> 3);
    v24 = 2082;
    v25 = v16;
    _os_log_impl(&dword_2419D9000, v13, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"filterStaleWiFiMeasurementsForFingerprint\", \"num measurements before\":%{public}lu, \"num measurements after filter\":%{public}lu, \"Recording UUID\":%{public, location:escape_only}s}", (uint8_t *)v17, 0x30u);
    operator delete(v16);
  }

}

void sub_241A19360(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

unint64_t CLMicroLocationFingerprintStdVectorSource::size(CLMicroLocationFingerprintStdVectorSource *this)
{
  return 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((_QWORD *)this + 2) - *((_QWORD *)this + 1)) >> 6);
}

uint64_t CLMicroLocationFingerprintStdVectorSource::at(CLMicroLocationFingerprintStdVectorSource *this, uint64_t a2)
{
  return *((_QWORD *)this + 1) + 192 * a2;
}

uint64_t CLMicroLocationFingerprintStdVectorSource::push_back(CLMicroLocationFingerprintStdVectorSource *this, const CLMicroLocationFingerprint *a2)
{
  char *v3;
  unint64_t v4;
  unint64_t v5;
  uint64_t result;

  v4 = *((_QWORD *)this + 3);
  v3 = (char *)this + 24;
  v5 = *((_QWORD *)v3 - 1);
  if (v5 >= v4)
  {
    result = std::vector<CLMicroLocationFingerprint>::__push_back_slow_path<CLMicroLocationFingerprint const&>((uint64_t *)this + 1, (uint64_t)a2);
  }
  else
  {
    std::allocator<CLMicroLocationFingerprint>::construct[abi:ne180100]<CLMicroLocationFingerprint,CLMicroLocationFingerprint const&>((uint64_t)v3, *((_QWORD *)v3 - 1), (uint64_t)a2);
    result = v5 + 192;
    *((_QWORD *)this + 2) = v5 + 192;
  }
  *((_QWORD *)this + 2) = result;
  return result;
}

void sub_241A1943C(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  *(_QWORD *)(v1 + 16) = v2;
  _Unwind_Resume(a1);
}

void CLMicroLocationFingerprintStdVectorSource::~CLMicroLocationFingerprintStdVectorSource(CLMicroLocationFingerprintStdVectorSource *this)
{
  void **v1;

  *(_QWORD *)this = off_2511D37A8;
  v1 = (void **)((char *)this + 8);
  std::vector<CLMicroLocationFingerprint>::__destroy_vector::operator()[abi:ne180100](&v1);
}

{
  void **v2;

  *(_QWORD *)this = off_2511D37A8;
  v2 = (void **)((char *)this + 8);
  std::vector<CLMicroLocationFingerprint>::__destroy_vector::operator()[abi:ne180100](&v2);
  MEMORY[0x2426A04D4](this, 0xA1C4030951706);
}

void ___ZL45_CLLogObjectForCategory_MicroLocation_Defaultv_block_invoke_14()
{
  os_log_t v0;
  void *v1;

  v0 = os_log_create("com.apple.MicroLocation", "MicroLocation");
  v1 = (void *)logObject_MicroLocation_Default;
  logObject_MicroLocation_Default = (uint64_t)v0;

}

char *std::vector<CLMicroLocationFingerprint>::__vallocate[abi:ne180100](_QWORD *a1, unint64_t a2)
{
  char *result;
  uint64_t v4;

  if (a2 >= 0x155555555555556)
    std::vector<CLMicroLocationProto::ConfidenceReason>::__throw_length_error[abi:ne180100]();
  result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<CLMicroLocationFingerprint>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[192 * v4];
  return result;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<CLMicroLocationFingerprint>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x155555555555556)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(192 * a2);
}

uint64_t std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<CLMicroLocationFingerprint>,CLMicroLocationFingerprint*,CLMicroLocationFingerprint*,CLMicroLocationFingerprint*>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  uint64_t v6;
  _QWORD v9[3];
  char v10;
  uint64_t v11;
  uint64_t v12;

  v4 = a4;
  v11 = a4;
  v12 = a4;
  v9[0] = a1;
  v9[1] = &v11;
  v9[2] = &v12;
  v10 = 0;
  if (a2 != a3)
  {
    v6 = a2;
    do
    {
      std::allocator<CLMicroLocationFingerprint>::construct[abi:ne180100]<CLMicroLocationFingerprint,CLMicroLocationFingerprint&>(a1, v4, v6);
      v6 += 192;
      v4 = v12 + 192;
      v12 += 192;
    }
    while (v6 != a3);
  }
  v10 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<CLMicroLocationFingerprint>,CLMicroLocationFingerprint*>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v9);
  return v4;
}

void sub_241A19638(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<CLMicroLocationFingerprint>,CLMicroLocationFingerprint*>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

_QWORD *std::allocator<CLMicroLocationFingerprint>::construct[abi:ne180100]<CLMicroLocationFingerprint,CLMicroLocationFingerprint&>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  __int128 v5;
  __int128 v6;
  int v7;

  std::unordered_set<CLMicroLocationFingerprint::Measurement,CLMicroLocationFingerprint::Measurement::HashMeasurement,CLMicroLocationFingerprint::Measurement::PredicateMeasurement,std::allocator<CLMicroLocationFingerprint::Measurement>>::unordered_set(a2, a3);
  v5 = *(_OWORD *)(a3 + 40);
  *(_QWORD *)(a2 + 56) = *(_QWORD *)(a3 + 56);
  *(_OWORD *)(a2 + 40) = v5;
  std::unordered_set<CLMicroLocationProto::DataType>::unordered_set(a2 + 64, a3 + 64);
  std::unordered_map<CLMicroLocationProto::DataType,CLMicroLocationFingerprint::StartAndEndTimestamps>::unordered_map(a2 + 104, a3 + 104);
  v6 = *(_OWORD *)(a3 + 144);
  v7 = *(_DWORD *)(a3 + 160);
  *(_QWORD *)(a2 + 168) = 0;
  *(_DWORD *)(a2 + 160) = v7;
  *(_OWORD *)(a2 + 144) = v6;
  *(_QWORD *)(a2 + 176) = 0;
  *(_QWORD *)(a2 + 184) = 0;
  return std::vector<CLMicroLocationProto::ConfidenceReason>::__init_with_size[abi:ne180100]<CLMicroLocationProto::ConfidenceReason*,CLMicroLocationProto::ConfidenceReason*>((_QWORD *)(a2 + 168), *(const void **)(a3 + 168), *(_QWORD *)(a3 + 176), (uint64_t)(*(_QWORD *)(a3 + 176) - *(_QWORD *)(a3 + 168)) >> 2);
}

void sub_241A196DC(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;

  std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>>>::~__hash_table(v3);
  std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>>>::~__hash_table(v2);
  std::__hash_table<CLMicroLocationFingerprint::Measurement,CLMicroLocationFingerprint::Measurement::HashMeasurement,CLMicroLocationFingerprint::Measurement::PredicateMeasurement,std::allocator<CLMicroLocationFingerprint::Measurement>>::~__hash_table(v1);
  _Unwind_Resume(a1);
}

uint64_t std::unordered_set<CLMicroLocationFingerprint::Measurement,CLMicroLocationFingerprint::Measurement::HashMeasurement,CLMicroLocationFingerprint::Measurement::PredicateMeasurement,std::allocator<CLMicroLocationFingerprint::Measurement>>::unordered_set(uint64_t a1, uint64_t a2)
{
  uint64_t *i;

  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 32) = *(_DWORD *)(a2 + 32);
  std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>>>::__rehash<true>(a1, *(_QWORD *)(a2 + 8));
  for (i = *(uint64_t **)(a2 + 16); i; i = (uint64_t *)*i)
    std::__hash_table<CLMicroLocationFingerprint::Measurement,CLMicroLocationFingerprint::Measurement::HashMeasurement,CLMicroLocationFingerprint::Measurement::PredicateMeasurement,std::allocator<CLMicroLocationFingerprint::Measurement>>::__emplace_unique_key_args<CLMicroLocationFingerprint::Measurement,CLMicroLocationFingerprint::Measurement const&>(a1, (uint64_t)(i + 2), (_OWORD *)i + 1);
  return a1;
}

void sub_241A1976C(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::__hash_table<CLMicroLocationFingerprint::Measurement,CLMicroLocationFingerprint::Measurement::HashMeasurement,CLMicroLocationFingerprint::Measurement::PredicateMeasurement,std::allocator<CLMicroLocationFingerprint::Measurement>>::~__hash_table(v1);
  _Unwind_Resume(a1);
}

_QWORD *std::__hash_table<CLMicroLocationFingerprint::Measurement,CLMicroLocationFingerprint::Measurement::HashMeasurement,CLMicroLocationFingerprint::Measurement::PredicateMeasurement,std::allocator<CLMicroLocationFingerprint::Measurement>>::__emplace_unique_key_args<CLMicroLocationFingerprint::Measurement,CLMicroLocationFingerprint::Measurement const&>(uint64_t a1, uint64_t a2, _OWORD *a3)
{
  unint64_t v3;
  _QWORD *v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  uint8x8_t v11;
  unint64_t v12;
  _QWORD *v13;
  _QWORD *v14;
  unint64_t v15;
  float v16;
  float v17;
  _BOOL8 v18;
  unint64_t v19;
  unint64_t v20;
  size_t v21;
  _QWORD *v22;
  unint64_t v23;
  _QWORD v25[3];

  v7 = (_QWORD *)(a1 + 24);
  v8 = CLMicroLocationFingerprint::Measurement::HashMeasurement::operator()(a1 + 24, a2);
  v9 = v8;
  v10 = *(_QWORD *)(a1 + 8);
  if (v10)
  {
    v11 = (uint8x8_t)vcnt_s8((int8x8_t)v10);
    v11.i16[0] = vaddlv_u8(v11);
    v12 = v11.u32[0];
    if (v11.u32[0] > 1uLL)
    {
      v3 = v8;
      if (v8 >= v10)
        v3 = v8 % v10;
    }
    else
    {
      v3 = (v10 - 1) & v8;
    }
    v13 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v3);
    if (v13)
    {
      v14 = (_QWORD *)*v13;
      if (*v13)
      {
        do
        {
          v15 = v14[1];
          if (v15 == v9)
          {
            if ((CLMicroLocationFingerprint::Measurement::PredicateMeasurement::operator()(a1 + 32, (uint64_t)(v14 + 2), a2) & 1) != 0)return v14;
          }
          else
          {
            if (v12 > 1)
            {
              if (v15 >= v10)
                v15 %= v10;
            }
            else
            {
              v15 &= v10 - 1;
            }
            if (v15 != v3)
              break;
          }
          v14 = (_QWORD *)*v14;
        }
        while (v14);
      }
    }
  }
  std::__hash_table<CLMicroLocationFingerprint::Measurement,CLMicroLocationFingerprint::Measurement::HashMeasurement,CLMicroLocationFingerprint::Measurement::PredicateMeasurement,std::allocator<CLMicroLocationFingerprint::Measurement>>::__construct_node_hash<CLMicroLocationFingerprint::Measurement const&>(a1, v9, a3, (uint64_t)v25);
  v16 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v17 = *(float *)(a1 + 32);
  if (!v10 || (float)(v17 * (float)v10) < v16)
  {
    v18 = 1;
    if (v10 >= 3)
      v18 = (v10 & (v10 - 1)) != 0;
    v19 = v18 | (2 * v10);
    v20 = vcvtps_u32_f32(v16 / v17);
    if (v19 <= v20)
      v21 = v20;
    else
      v21 = v19;
    std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>>>::__rehash<true>(a1, v21);
    v10 = *(_QWORD *)(a1 + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v9 >= v10)
        v3 = v9 % v10;
      else
        v3 = v9;
    }
    else
    {
      v3 = (v10 - 1) & v9;
    }
  }
  v22 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v3);
  if (v22)
  {
    *(_QWORD *)v25[0] = *v22;
    *v22 = v25[0];
  }
  else
  {
    *(_QWORD *)v25[0] = *(_QWORD *)(a1 + 16);
    *(_QWORD *)(a1 + 16) = v25[0];
    *(_QWORD *)(*(_QWORD *)a1 + 8 * v3) = a1 + 16;
    if (*(_QWORD *)v25[0])
    {
      v23 = *(_QWORD *)(*(_QWORD *)v25[0] + 8);
      if ((v10 & (v10 - 1)) != 0)
      {
        if (v23 >= v10)
          v23 %= v10;
      }
      else
      {
        v23 &= v10 - 1;
      }
      *(_QWORD *)(*(_QWORD *)a1 + 8 * v23) = v25[0];
    }
  }
  v14 = (_QWORD *)v25[0];
  v25[0] = 0;
  ++*v7;
  std::unique_ptr<std::__hash_node<CLMicroLocationFingerprint::Measurement,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<CLMicroLocationFingerprint::Measurement,void *>>>>::reset[abi:ne180100]((uint64_t)v25, 0);
  return v14;
}

void sub_241A199EC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::unique_ptr<std::__hash_node<CLMicroLocationFingerprint::Measurement,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<CLMicroLocationFingerprint::Measurement,void *>>>>::reset[abi:ne180100]((uint64_t)va, 0);
  _Unwind_Resume(a1);
}

uint64_t std::__hash_table<CLMicroLocationFingerprint::Measurement,CLMicroLocationFingerprint::Measurement::HashMeasurement,CLMicroLocationFingerprint::Measurement::PredicateMeasurement,std::allocator<CLMicroLocationFingerprint::Measurement>>::__construct_node_hash<CLMicroLocationFingerprint::Measurement const&>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, _OWORD *a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v7;
  _QWORD *v8;
  uint64_t result;

  v7 = a1 + 16;
  v8 = operator new(0x40uLL);
  *(_QWORD *)a4 = v8;
  *(_QWORD *)(a4 + 8) = v7;
  *(_BYTE *)(a4 + 16) = 0;
  *v8 = 0;
  v8[1] = a2;
  *((_OWORD *)v8 + 1) = *a3;
  result = std::__variant_detail::__copy_constructor<std::__variant_detail::__traits<unsigned long long,boost::uuids::uuid,std::string>,(std::__variant_detail::_Trait)1>::__copy_constructor((uint64_t)(v8 + 4), (uint64_t)(a3 + 1));
  *(_BYTE *)(a4 + 16) = 1;
  return result;
}

void sub_241A19A64(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::unique_ptr<std::__hash_node<CLMicroLocationFingerprint::Measurement,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<CLMicroLocationFingerprint::Measurement,void *>>>>::reset[abi:ne180100](v1, 0);
  _Unwind_Resume(a1);
}

uint64_t std::__variant_detail::__copy_constructor<std::__variant_detail::__traits<unsigned long long,boost::uuids::uuid,std::string>,(std::__variant_detail::_Trait)1>::__copy_constructor(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)a1 = 0;
  *(_DWORD *)(a1 + 24) = -1;
  std::__variant_detail::__ctor<std::__variant_detail::__traits<unsigned long long,boost::uuids::uuid,std::string>>::__generic_construct[abi:ne180100]<std::__variant_detail::__copy_constructor<std::__variant_detail::__traits<unsigned long long,boost::uuids::uuid,std::string>,(std::__variant_detail::_Trait)1> const&>(a1, a2);
  return a1;
}

void sub_241A19AAC(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::__variant_detail::__dtor<std::__variant_detail::__traits<unsigned long long,boost::uuids::uuid,std::string>,(std::__variant_detail::_Trait)1>::~__dtor(v1);
  _Unwind_Resume(a1);
}

uint64_t std::__variant_detail::__ctor<std::__variant_detail::__traits<unsigned long long,boost::uuids::uuid,std::string>>::__generic_construct[abi:ne180100]<std::__variant_detail::__copy_constructor<std::__variant_detail::__traits<unsigned long long,boost::uuids::uuid,std::string>,(std::__variant_detail::_Trait)1> const&>(uint64_t result, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  char v6;
  char v7;

  v3 = result;
  v4 = *(unsigned int *)(result + 24);
  if ((_DWORD)v4 != -1)
    result = ((uint64_t (*)(char *, uint64_t))off_2511D3810[v4])(&v7, result);
  *(_DWORD *)(v3 + 24) = -1;
  v5 = *(unsigned int *)(a2 + 24);
  if ((_DWORD)v5 != -1)
  {
    result = ((uint64_t (*)(char *, uint64_t, uint64_t))off_2511D3828[v5])(&v6, v3, a2);
    *(_DWORD *)(v3 + 24) = v5;
  }
  return result;
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm0ELm0EEE10__dispatchB8ne180100IOZNS0_6__ctorINS0_8__traitsIJyN5boost5uuids4uuidENS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEEEEE19__generic_constructB8ne180100IRKNS0_18__copy_constructorISH_LNS0_6_TraitE1EEEEEvRSI_OT_EUlRSQ_OT0_E_JRNS0_6__baseILSL_1EJySA_SG_EEERKSY_EEEDcSQ_DpT0_(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  *a2 = *a3;
}

__n128 _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm1ELm1EEE10__dispatchB8ne180100IOZNS0_6__ctorINS0_8__traitsIJyN5boost5uuids4uuidENS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEEEEE19__generic_constructB8ne180100IRKNS0_18__copy_constructorISH_LNS0_6_TraitE1EEEEEvRSI_OT_EUlRSQ_OT0_E_JRNS0_6__baseILSL_1EJySA_SG_EEERKSY_EEEDcSQ_DpT0_(uint64_t a1, __n128 *a2, __n128 *a3)
{
  __n128 result;

  result = *a3;
  *a2 = *a3;
  return result;
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm2ELm2EEE10__dispatchB8ne180100IOZNS0_6__ctorINS0_8__traitsIJyN5boost5uuids4uuidENS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEEEEE19__generic_constructB8ne180100IRKNS0_18__copy_constructorISH_LNS0_6_TraitE1EEEEEvRSI_OT_EUlRSQ_OT0_E_JRNS0_6__baseILSL_1EJySA_SG_EEERKSY_EEEDcSQ_DpT0_(int a1, std::string *this, __int128 *a3)
{
  __int128 v3;

  if (*((char *)a3 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(this, *(const std::string::value_type **)a3, *((_QWORD *)a3 + 1));
  }
  else
  {
    v3 = *a3;
    this->__r_.__value_.__r.__words[2] = *((_QWORD *)a3 + 2);
    *(_OWORD *)&this->__r_.__value_.__l.__data_ = v3;
  }
}

void std::unique_ptr<std::__hash_node<CLMicroLocationFingerprint::Measurement,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<CLMicroLocationFingerprint::Measurement,void *>>>>::reset[abi:ne180100](uint64_t a1, uint64_t a2)
{
  void *v2;

  v2 = *(void **)a1;
  *(_QWORD *)a1 = a2;
  if (v2)
  {
    if (*(_BYTE *)(a1 + 16))
      std::__variant_detail::__dtor<std::__variant_detail::__traits<unsigned long long,boost::uuids::uuid,std::string>,(std::__variant_detail::_Trait)1>::~__dtor((uint64_t)v2 + 32);
    operator delete(v2);
  }
}

uint64_t std::unordered_set<CLMicroLocationProto::DataType>::unordered_set(uint64_t a1, uint64_t a2)
{
  unsigned int *i;

  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 32) = *(_DWORD *)(a2 + 32);
  std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>>>::__rehash<true>(a1, *(_QWORD *)(a2 + 8));
  for (i = *(unsigned int **)(a2 + 16); i; i = *(unsigned int **)i)
    std::__hash_table<CLMicroLocationProto::DataType,std::hash<CLMicroLocationProto::DataType>,std::equal_to<CLMicroLocationProto::DataType>,std::allocator<CLMicroLocationProto::DataType>>::__emplace_unique_key_args<CLMicroLocationProto::DataType,CLMicroLocationProto::DataType const&>(a1, i + 4, i + 4);
  return a1;
}

void sub_241A19C30(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>>>::~__hash_table(v1);
  _Unwind_Resume(a1);
}

_QWORD *std::__hash_table<CLMicroLocationProto::DataType,std::hash<CLMicroLocationProto::DataType>,std::equal_to<CLMicroLocationProto::DataType>,std::allocator<CLMicroLocationProto::DataType>>::__emplace_unique_key_args<CLMicroLocationProto::DataType,CLMicroLocationProto::DataType const&>(uint64_t a1, unsigned int *a2, _DWORD *a3)
{
  unint64_t v3;
  unint64_t v6;
  unint64_t v7;
  uint8x8_t v8;
  void **v9;
  _QWORD *v10;
  unint64_t v11;
  float v12;
  float v13;
  _BOOL8 v14;
  unint64_t v15;
  unint64_t v16;
  size_t v17;
  uint64_t v18;
  _QWORD *v19;
  unint64_t v20;

  v6 = *a2;
  v7 = *(_QWORD *)(a1 + 8);
  if (v7)
  {
    v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      v3 = *a2;
      if (v7 <= v6)
        v3 = v6 % v7;
    }
    else
    {
      v3 = ((_DWORD)v7 - 1) & v6;
    }
    v9 = *(void ***)(*(_QWORD *)a1 + 8 * v3);
    if (v9)
    {
      v10 = *v9;
      if (*v9)
      {
        do
        {
          v11 = v10[1];
          if (v11 == v6)
          {
            if (*((_DWORD *)v10 + 4) == (_DWORD)v6)
              return v10;
          }
          else
          {
            if (v8.u32[0] > 1uLL)
            {
              if (v11 >= v7)
                v11 %= v7;
            }
            else
            {
              v11 &= v7 - 1;
            }
            if (v11 != v3)
              break;
          }
          v10 = (_QWORD *)*v10;
        }
        while (v10);
      }
    }
  }
  v10 = operator new(0x18uLL);
  *v10 = 0;
  v10[1] = v6;
  *((_DWORD *)v10 + 4) = *a3;
  v12 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v13 = *(float *)(a1 + 32);
  if (!v7 || (float)(v13 * (float)v7) < v12)
  {
    v14 = 1;
    if (v7 >= 3)
      v14 = (v7 & (v7 - 1)) != 0;
    v15 = v14 | (2 * v7);
    v16 = vcvtps_u32_f32(v12 / v13);
    if (v15 <= v16)
      v17 = v16;
    else
      v17 = v15;
    std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>>>::__rehash<true>(a1, v17);
    v7 = *(_QWORD *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= v6)
        v3 = v6 % v7;
      else
        v3 = v6;
    }
    else
    {
      v3 = ((_DWORD)v7 - 1) & v6;
    }
  }
  v18 = *(_QWORD *)a1;
  v19 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v3);
  if (v19)
  {
    *v10 = *v19;
LABEL_38:
    *v19 = v10;
    goto LABEL_39;
  }
  *v10 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = v10;
  *(_QWORD *)(v18 + 8 * v3) = a1 + 16;
  if (*v10)
  {
    v20 = *(_QWORD *)(*v10 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v20 >= v7)
        v20 %= v7;
    }
    else
    {
      v20 &= v7 - 1;
    }
    v19 = (_QWORD *)(*(_QWORD *)a1 + 8 * v20);
    goto LABEL_38;
  }
LABEL_39:
  ++*(_QWORD *)(a1 + 24);
  return v10;
}

void sub_241A19E50(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t std::unordered_map<CLMicroLocationProto::DataType,CLMicroLocationFingerprint::StartAndEndTimestamps>::unordered_map(uint64_t a1, uint64_t a2)
{
  unsigned int *i;

  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 32) = *(_DWORD *)(a2 + 32);
  std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>>>::__rehash<true>(a1, *(_QWORD *)(a2 + 8));
  for (i = *(unsigned int **)(a2 + 16); i; i = *(unsigned int **)i)
    std::__hash_table<std::__hash_value_type<CLMicroLocationProto::DataType,CLMicroLocationFingerprint::StartAndEndTimestamps>,std::__unordered_map_hasher<CLMicroLocationProto::DataType,std::__hash_value_type<CLMicroLocationProto::DataType,CLMicroLocationFingerprint::StartAndEndTimestamps>,std::hash<CLMicroLocationProto::DataType>,std::equal_to<CLMicroLocationProto::DataType>,true>,std::__unordered_map_equal<CLMicroLocationProto::DataType,std::__hash_value_type<CLMicroLocationProto::DataType,CLMicroLocationFingerprint::StartAndEndTimestamps>,std::equal_to<CLMicroLocationProto::DataType>,std::hash<CLMicroLocationProto::DataType>,true>,std::allocator<std::__hash_value_type<CLMicroLocationProto::DataType,CLMicroLocationFingerprint::StartAndEndTimestamps>>>::__emplace_unique_key_args<CLMicroLocationProto::DataType,std::pair<CLMicroLocationProto::DataType const,CLMicroLocationFingerprint::StartAndEndTimestamps> const&>(a1, i + 4, (uint64_t)(i + 4));
  return a1;
}

void sub_241A19EC0(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>>>::~__hash_table(v1);
  _Unwind_Resume(a1);
}

_QWORD *std::__hash_table<std::__hash_value_type<CLMicroLocationProto::DataType,CLMicroLocationFingerprint::StartAndEndTimestamps>,std::__unordered_map_hasher<CLMicroLocationProto::DataType,std::__hash_value_type<CLMicroLocationProto::DataType,CLMicroLocationFingerprint::StartAndEndTimestamps>,std::hash<CLMicroLocationProto::DataType>,std::equal_to<CLMicroLocationProto::DataType>,true>,std::__unordered_map_equal<CLMicroLocationProto::DataType,std::__hash_value_type<CLMicroLocationProto::DataType,CLMicroLocationFingerprint::StartAndEndTimestamps>,std::equal_to<CLMicroLocationProto::DataType>,std::hash<CLMicroLocationProto::DataType>,true>,std::allocator<std::__hash_value_type<CLMicroLocationProto::DataType,CLMicroLocationFingerprint::StartAndEndTimestamps>>>::__emplace_unique_key_args<CLMicroLocationProto::DataType,std::pair<CLMicroLocationProto::DataType const,CLMicroLocationFingerprint::StartAndEndTimestamps> const&>(uint64_t a1, unsigned int *a2, uint64_t a3)
{
  unint64_t v3;
  unint64_t v6;
  unint64_t v7;
  uint8x8_t v8;
  void **v9;
  _QWORD *v10;
  unint64_t v11;
  float v12;
  float v13;
  _BOOL8 v14;
  unint64_t v15;
  unint64_t v16;
  size_t v17;
  uint64_t v18;
  _QWORD *v19;
  unint64_t v20;

  v6 = *a2;
  v7 = *(_QWORD *)(a1 + 8);
  if (v7)
  {
    v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      v3 = *a2;
      if (v7 <= v6)
        v3 = v6 % v7;
    }
    else
    {
      v3 = ((_DWORD)v7 - 1) & v6;
    }
    v9 = *(void ***)(*(_QWORD *)a1 + 8 * v3);
    if (v9)
    {
      v10 = *v9;
      if (*v9)
      {
        do
        {
          v11 = v10[1];
          if (v11 == v6)
          {
            if (*((_DWORD *)v10 + 4) == (_DWORD)v6)
              return v10;
          }
          else
          {
            if (v8.u32[0] > 1uLL)
            {
              if (v11 >= v7)
                v11 %= v7;
            }
            else
            {
              v11 &= v7 - 1;
            }
            if (v11 != v3)
              break;
          }
          v10 = (_QWORD *)*v10;
        }
        while (v10);
      }
    }
  }
  v10 = operator new(0x28uLL);
  *v10 = 0;
  v10[1] = v6;
  *((_OWORD *)v10 + 1) = *(_OWORD *)a3;
  v10[4] = *(_QWORD *)(a3 + 16);
  v12 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v13 = *(float *)(a1 + 32);
  if (!v7 || (float)(v13 * (float)v7) < v12)
  {
    v14 = 1;
    if (v7 >= 3)
      v14 = (v7 & (v7 - 1)) != 0;
    v15 = v14 | (2 * v7);
    v16 = vcvtps_u32_f32(v12 / v13);
    if (v15 <= v16)
      v17 = v16;
    else
      v17 = v15;
    std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>>>::__rehash<true>(a1, v17);
    v7 = *(_QWORD *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= v6)
        v3 = v6 % v7;
      else
        v3 = v6;
    }
    else
    {
      v3 = ((_DWORD)v7 - 1) & v6;
    }
  }
  v18 = *(_QWORD *)a1;
  v19 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v3);
  if (v19)
  {
    *v10 = *v19;
LABEL_38:
    *v19 = v10;
    goto LABEL_39;
  }
  *v10 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = v10;
  *(_QWORD *)(v18 + 8 * v3) = a1 + 16;
  if (*v10)
  {
    v20 = *(_QWORD *)(*v10 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v20 >= v7)
        v20 %= v7;
    }
    else
    {
      v20 &= v7 - 1;
    }
    v19 = (_QWORD *)(*(_QWORD *)a1 + 8 * v20);
    goto LABEL_38;
  }
LABEL_39:
  ++*(_QWORD *)(a1 + 24);
  return v10;
}

void sub_241A1A0E8(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

_QWORD *std::vector<CLMicroLocationProto::ConfidenceReason>::__init_with_size[abi:ne180100]<CLMicroLocationProto::ConfidenceReason*,CLMicroLocationProto::ConfidenceReason*>(_QWORD *result, const void *a2, uint64_t a3, unint64_t a4)
{
  _QWORD *v6;
  uint64_t v7;
  size_t v8;

  if (a4)
  {
    v6 = result;
    result = std::vector<CLMicroLocationProto::ConfidenceLevel>::__vallocate[abi:ne180100](result, a4);
    v7 = v6[1];
    v8 = a3 - (_QWORD)a2;
    if (v8)
      result = memmove((void *)v6[1], a2, v8);
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_241A1A158(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<CLMicroLocationFingerprint>,CLMicroLocationFingerprint*>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24))
    std::_AllocatorDestroyRangeReverse<std::allocator<CLMicroLocationFingerprint>,CLMicroLocationFingerprint*>::operator()[abi:ne180100]((uint64_t *)a1);
  return a1;
}

uint64_t *std::_AllocatorDestroyRangeReverse<std::allocator<CLMicroLocationFingerprint>,CLMicroLocationFingerprint*>::operator()[abi:ne180100](uint64_t *result)
{
  uint64_t *v1;
  uint64_t *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  v2 = (uint64_t *)result[1];
  v1 = (uint64_t *)result[2];
  v3 = *v1;
  v4 = *v2;
  if (*v1 != *v2)
  {
    v5 = *result;
    do
    {
      v3 -= 192;
      result = (uint64_t *)std::allocator<CLMicroLocationFingerprint>::destroy[abi:ne180100](v5, v3);
    }
    while (v3 != v4);
  }
  return result;
}

uint64_t std::allocator<CLMicroLocationFingerprint>::destroy[abi:ne180100](uint64_t a1, uint64_t a2)
{
  void *v3;

  v3 = *(void **)(a2 + 168);
  if (v3)
  {
    *(_QWORD *)(a2 + 176) = v3;
    operator delete(v3);
  }
  std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>>>::~__hash_table(a2 + 104);
  std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>>>::~__hash_table(a2 + 64);
  return std::__hash_table<CLMicroLocationFingerprint::Measurement,CLMicroLocationFingerprint::Measurement::HashMeasurement,CLMicroLocationFingerprint::Measurement::PredicateMeasurement,std::allocator<CLMicroLocationFingerprint::Measurement>>::~__hash_table(a2);
}

void std::vector<CLMicroLocationFingerprint>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v1;
  void *v2;
  uint64_t v4;
  void *v5;

  v1 = *a1;
  v2 = **a1;
  if (v2)
  {
    v4 = (uint64_t)v1[1];
    v5 = **a1;
    if ((void *)v4 != v2)
    {
      do
      {
        v4 -= 192;
        std::allocator<CLMicroLocationFingerprint>::destroy[abi:ne180100]((uint64_t)(v1 + 2), v4);
      }
      while ((void *)v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void std::vector<CLMicroLocationMeasurementTable::Entry>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v1;
  char *v2;
  char *v4;
  void *v5;
  char *v6;

  v1 = *a1;
  v2 = (char *)**a1;
  if (v2)
  {
    v4 = (char *)v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v6 = v4 - 120;
        CLMicroLocationProto::Measurement::~Measurement((CLMicroLocationProto::Measurement *)(v4 - 88));
        v4 = v6;
      }
      while (v6 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t std::vector<CLMicroLocationMeasurementTable::Entry>::erase(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  if (a2 != a3)
  {
    std::__unwrap_and_dispatch[abi:ne180100]<std::__overload<std::__move_loop<std::_ClassicAlgPolicy>,std::__move_trivial>,CLMicroLocationMeasurementTable::Entry *,CLMicroLocationMeasurementTable::Entry *,CLMicroLocationMeasurementTable::Entry *,0>(a3, *(_QWORD *)(a1 + 8), a2);
    v6 = v5;
    v7 = *(_QWORD *)(a1 + 8);
    if (v7 != v5)
    {
      do
      {
        v8 = v7 - 120;
        CLMicroLocationProto::Measurement::~Measurement((CLMicroLocationProto::Measurement *)(v7 - 88));
        v7 = v8;
      }
      while (v8 != v6);
    }
    *(_QWORD *)(a1 + 8) = v6;
  }
  return a2;
}

uint64_t std::remove_if[abi:ne180100]<std::__wrap_iter<CLMicroLocationMeasurementTable::Entry *>,void CLMicroLocationsMeasurementFilters::filterStaleWiFiMeasurementsForFingerprint<CLMicroLocationMeasurementTable::Entry>(std::vector<CLMicroLocationMeasurementTable::Entry> &,CLMicroLocationRecordingEventsTable::Entry const&)::{lambda(CLMicroLocationMeasurementTable::Entry const&)#1}>(uint64_t a1, uint64_t a2, double a3)
{
  uint64_t i;
  uint64_t v7;

  if (a1 == a2)
    return a2;
  for (i = a1 + 120; *(_DWORD *)(i - 24) != 1 || *(double *)(i - 80) >= a3; i += 120)
  {
    if (i == a2)
      return a2;
  }
  v7 = i - 120;
  if (i - 120 != a2)
  {
    while (i != a2)
    {
      if (*(_DWORD *)(i + 96) != 1 || *(double *)(i + 40) >= a3)
      {
        CLMicroLocationMeasurementTable::Entry::operator=(v7, i);
        v7 += 120;
      }
      i += 120;
    }
  }
  return v7;
}

uint64_t std::__unwrap_and_dispatch[abi:ne180100]<std::__overload<std::__move_loop<std::_ClassicAlgPolicy>,std::__move_trivial>,CLMicroLocationMeasurementTable::Entry *,CLMicroLocationMeasurementTable::Entry *,CLMicroLocationMeasurementTable::Entry *,0>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;

  v4 = a1;
  if (a1 != a2)
  {
    do
    {
      CLMicroLocationMeasurementTable::Entry::operator=(a3, v4);
      v4 += 120;
      a3 += 120;
    }
    while (v4 != a2);
    return a2;
  }
  return v4;
}

uint64_t std::vector<CLMicroLocationFingerprint>::__emplace_back_slow_path<CLMicroLocationFingerprint>(uint64_t *a1, uint64_t a2)
{
  unint64_t v3;
  unint64_t v4;
  unint64_t v6;
  char *v7;
  uint64_t v8;
  void *v10;
  char *v11;
  char *v12;
  char *v13;
  uint64_t *v14;

  v3 = 0xAAAAAAAAAAAAAAABLL * ((a1[1] - *a1) >> 6);
  v4 = v3 + 1;
  if (v3 + 1 > 0x155555555555555)
    std::vector<CLMicroLocationProto::ConfidenceReason>::__throw_length_error[abi:ne180100]();
  if (0x5555555555555556 * ((a1[2] - *a1) >> 6) > v4)
    v4 = 0x5555555555555556 * ((a1[2] - *a1) >> 6);
  if (0xAAAAAAAAAAAAAAABLL * ((a1[2] - *a1) >> 6) >= 0xAAAAAAAAAAAAAALL)
    v6 = 0x155555555555555;
  else
    v6 = v4;
  v14 = a1 + 2;
  if (v6)
    v7 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<CLMicroLocationFingerprint>>((uint64_t)(a1 + 2), v6);
  else
    v7 = 0;
  v10 = v7;
  v11 = &v7[192 * v3];
  v13 = &v7[192 * v6];
  std::allocator<CLMicroLocationFingerprint>::construct[abi:ne180100]<CLMicroLocationFingerprint,CLMicroLocationFingerprint>((uint64_t)(a1 + 2), (uint64_t)v11, a2);
  v12 = v11 + 192;
  std::vector<CLMicroLocationFingerprint>::__swap_out_circular_buffer(a1, &v10);
  v8 = a1[1];
  std::__split_buffer<CLMicroLocationFingerprint>::~__split_buffer(&v10);
  return v8;
}

void sub_241A1A5A4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__split_buffer<CLMicroLocationFingerprint>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

__n128 std::allocator<CLMicroLocationFingerprint>::construct[abi:ne180100]<CLMicroLocationFingerprint,CLMicroLocationFingerprint>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  __int128 v5;
  __int128 v6;
  __n128 result;

  std::__hash_table<CLMicroLocationFingerprint::Measurement,CLMicroLocationFingerprint::Measurement::HashMeasurement,CLMicroLocationFingerprint::Measurement::PredicateMeasurement,std::allocator<CLMicroLocationFingerprint::Measurement>>::__hash_table(a2, (uint64_t *)a3);
  v5 = *(_OWORD *)(a3 + 40);
  *(_QWORD *)(a2 + 56) = *(_QWORD *)(a3 + 56);
  *(_OWORD *)(a2 + 40) = v5;
  std::__hash_table<CLMicroLocationFingerprint::Measurement,CLMicroLocationFingerprint::Measurement::HashMeasurement,CLMicroLocationFingerprint::Measurement::PredicateMeasurement,std::allocator<CLMicroLocationFingerprint::Measurement>>::__hash_table(a2 + 64, (uint64_t *)(a3 + 64));
  std::__hash_table<CLMicroLocationFingerprint::Measurement,CLMicroLocationFingerprint::Measurement::HashMeasurement,CLMicroLocationFingerprint::Measurement::PredicateMeasurement,std::allocator<CLMicroLocationFingerprint::Measurement>>::__hash_table(a2 + 104, (uint64_t *)(a3 + 104));
  v6 = *(_OWORD *)(a3 + 144);
  *(_DWORD *)(a2 + 160) = *(_DWORD *)(a3 + 160);
  *(_OWORD *)(a2 + 144) = v6;
  *(_QWORD *)(a2 + 176) = 0;
  *(_QWORD *)(a2 + 184) = 0;
  *(_QWORD *)(a2 + 168) = 0;
  result = *(__n128 *)(a3 + 168);
  *(__n128 *)(a2 + 168) = result;
  *(_QWORD *)(a2 + 184) = *(_QWORD *)(a3 + 184);
  *(_QWORD *)(a3 + 168) = 0;
  *(_QWORD *)(a3 + 176) = 0;
  *(_QWORD *)(a3 + 184) = 0;
  return result;
}

uint64_t std::__hash_table<CLMicroLocationFingerprint::Measurement,CLMicroLocationFingerprint::Measurement::HashMeasurement,CLMicroLocationFingerprint::Measurement::PredicateMeasurement,std::allocator<CLMicroLocationFingerprint::Measurement>>::__hash_table(uint64_t result, uint64_t *a2)
{
  uint64_t v2;
  _QWORD *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;

  v2 = *a2;
  *a2 = 0;
  *(_QWORD *)result = v2;
  *(_QWORD *)(result + 8) = a2[1];
  a2[1] = 0;
  v5 = a2[2];
  v3 = a2 + 2;
  v4 = v5;
  *(_QWORD *)(result + 16) = v5;
  v6 = v3[1];
  *(_QWORD *)(result + 24) = v6;
  *(_DWORD *)(result + 32) = *((_DWORD *)v3 + 4);
  if (v6)
  {
    v7 = *(_QWORD *)(v4 + 8);
    v8 = *(_QWORD *)(result + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v7 >= v8)
        v7 %= v8;
    }
    else
    {
      v7 &= v8 - 1;
    }
    *(_QWORD *)(v2 + 8 * v7) = result + 16;
    *v3 = 0;
    v3[1] = 0;
  }
  return result;
}

uint64_t std::vector<CLMicroLocationFingerprint>::__swap_out_circular_buffer(uint64_t *a1, _QWORD *a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<CLMicroLocationFingerprint>,std::reverse_iterator<CLMicroLocationFingerprint*>,std::reverse_iterator<CLMicroLocationFingerprint*>,std::reverse_iterator<CLMicroLocationFingerprint*>>((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<CLMicroLocationFingerprint>,std::reverse_iterator<CLMicroLocationFingerprint*>,std::reverse_iterator<CLMicroLocationFingerprint*>,std::reverse_iterator<CLMicroLocationFingerprint*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7;
  uint64_t v9;
  uint64_t v11;
  _QWORD v13[3];
  char v14;
  __int128 v15;
  __int128 v16;

  v7 = a7;
  *(_QWORD *)&v16 = a6;
  *((_QWORD *)&v16 + 1) = a7;
  v15 = v16;
  v13[0] = a1;
  v13[1] = &v15;
  v13[2] = &v16;
  v14 = 0;
  if (a3 == a5)
  {
    v11 = a6;
  }
  else
  {
    v9 = a3;
    do
    {
      v9 -= 192;
      std::allocator<CLMicroLocationFingerprint>::construct[abi:ne180100]<CLMicroLocationFingerprint,CLMicroLocationFingerprint>(a1, v7 - 192, v9);
      v7 = *((_QWORD *)&v16 + 1) - 192;
      *((_QWORD *)&v16 + 1) -= 192;
    }
    while (v9 != a5);
    v11 = v16;
  }
  v14 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<CLMicroLocationFingerprint>,std::reverse_iterator<CLMicroLocationFingerprint*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v13);
  return v11;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<CLMicroLocationFingerprint>,std::reverse_iterator<CLMicroLocationFingerprint*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24))
    std::_AllocatorDestroyRangeReverse<std::allocator<CLMicroLocationFingerprint>,std::reverse_iterator<CLMicroLocationFingerprint*>>::operator()[abi:ne180100]((uint64_t *)a1);
  return a1;
}

uint64_t *std::_AllocatorDestroyRangeReverse<std::allocator<CLMicroLocationFingerprint>,std::reverse_iterator<CLMicroLocationFingerprint*>>::operator()[abi:ne180100](uint64_t *result)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;

  v1 = *(_QWORD *)(result[2] + 8);
  v2 = *(_QWORD *)(result[1] + 8);
  if (v1 != v2)
  {
    v3 = *result;
    do
    {
      result = (uint64_t *)std::allocator<CLMicroLocationFingerprint>::destroy[abi:ne180100](v3, v1);
      v1 += 192;
    }
    while (v1 != v2);
  }
  return result;
}

void **std::__split_buffer<CLMicroLocationFingerprint>::~__split_buffer(void **a1)
{
  std::__split_buffer<CLMicroLocationFingerprint>::clear[abi:ne180100]((uint64_t)a1);
  if (*a1)
    operator delete(*a1);
  return a1;
}

uint64_t std::__split_buffer<CLMicroLocationFingerprint>::clear[abi:ne180100](uint64_t result)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  v2 = *(_QWORD *)(result + 8);
  v1 = *(_QWORD *)(result + 16);
  if (v1 != v2)
  {
    v3 = result;
    do
    {
      v4 = *(_QWORD *)(v3 + 32);
      *(_QWORD *)(v3 + 16) = v1 - 192;
      result = std::allocator<CLMicroLocationFingerprint>::destroy[abi:ne180100](v4, v1 - 192);
      v1 = *(_QWORD *)(v3 + 16);
    }
    while (v1 != v2);
  }
  return result;
}

uint64_t std::vector<CLMicroLocationFingerprint>::__push_back_slow_path<CLMicroLocationFingerprint const&>(uint64_t *a1, uint64_t a2)
{
  unint64_t v3;
  unint64_t v4;
  unint64_t v6;
  char *v7;
  uint64_t v8;
  void *v10;
  char *v11;
  char *v12;
  char *v13;
  uint64_t *v14;

  v3 = 0xAAAAAAAAAAAAAAABLL * ((a1[1] - *a1) >> 6);
  v4 = v3 + 1;
  if (v3 + 1 > 0x155555555555555)
    std::vector<CLMicroLocationProto::ConfidenceReason>::__throw_length_error[abi:ne180100]();
  if (0x5555555555555556 * ((a1[2] - *a1) >> 6) > v4)
    v4 = 0x5555555555555556 * ((a1[2] - *a1) >> 6);
  if (0xAAAAAAAAAAAAAAABLL * ((a1[2] - *a1) >> 6) >= 0xAAAAAAAAAAAAAALL)
    v6 = 0x155555555555555;
  else
    v6 = v4;
  v14 = a1 + 2;
  if (v6)
    v7 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<CLMicroLocationFingerprint>>((uint64_t)(a1 + 2), v6);
  else
    v7 = 0;
  v10 = v7;
  v11 = &v7[192 * v3];
  v13 = &v7[192 * v6];
  std::allocator<CLMicroLocationFingerprint>::construct[abi:ne180100]<CLMicroLocationFingerprint,CLMicroLocationFingerprint const&>((uint64_t)(a1 + 2), (uint64_t)v11, a2);
  v12 = v11 + 192;
  std::vector<CLMicroLocationFingerprint>::__swap_out_circular_buffer(a1, &v10);
  v8 = a1[1];
  std::__split_buffer<CLMicroLocationFingerprint>::~__split_buffer(&v10);
  return v8;
}

void sub_241A1A9C4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__split_buffer<CLMicroLocationFingerprint>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

_QWORD *std::allocator<CLMicroLocationFingerprint>::construct[abi:ne180100]<CLMicroLocationFingerprint,CLMicroLocationFingerprint const&>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  __int128 v5;
  __int128 v6;
  int v7;

  std::unordered_set<CLMicroLocationFingerprint::Measurement,CLMicroLocationFingerprint::Measurement::HashMeasurement,CLMicroLocationFingerprint::Measurement::PredicateMeasurement,std::allocator<CLMicroLocationFingerprint::Measurement>>::unordered_set(a2, a3);
  v5 = *(_OWORD *)(a3 + 40);
  *(_QWORD *)(a2 + 56) = *(_QWORD *)(a3 + 56);
  *(_OWORD *)(a2 + 40) = v5;
  std::unordered_set<CLMicroLocationProto::DataType>::unordered_set(a2 + 64, a3 + 64);
  std::unordered_map<CLMicroLocationProto::DataType,CLMicroLocationFingerprint::StartAndEndTimestamps>::unordered_map(a2 + 104, a3 + 104);
  v6 = *(_OWORD *)(a3 + 144);
  v7 = *(_DWORD *)(a3 + 160);
  *(_QWORD *)(a2 + 168) = 0;
  *(_DWORD *)(a2 + 160) = v7;
  *(_OWORD *)(a2 + 144) = v6;
  *(_QWORD *)(a2 + 176) = 0;
  *(_QWORD *)(a2 + 184) = 0;
  return std::vector<CLMicroLocationProto::ConfidenceReason>::__init_with_size[abi:ne180100]<CLMicroLocationProto::ConfidenceReason*,CLMicroLocationProto::ConfidenceReason*>((_QWORD *)(a2 + 168), *(const void **)(a3 + 168), *(_QWORD *)(a3 + 176), (uint64_t)(*(_QWORD *)(a3 + 176) - *(_QWORD *)(a3 + 168)) >> 2);
}

void sub_241A1AA68(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;

  std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>>>::~__hash_table(v3);
  std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>>>::~__hash_table(v2);
  std::__hash_table<CLMicroLocationFingerprint::Measurement,CLMicroLocationFingerprint::Measurement::HashMeasurement,CLMicroLocationFingerprint::Measurement::PredicateMeasurement,std::allocator<CLMicroLocationFingerprint::Measurement>>::~__hash_table(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_241A1AAFC()
{
  void *v0;

  return 0;
}

void sub_241A1AF94(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
  id *v14;

  objc_destroyWeak(v14);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void CLMicroLocationFingerprintPool::add(CLMicroLocationFingerprintPool *this@<X0>, uuid *a2@<X1>, const CLMicroLocationFingerprint *a3@<X2>, uint64_t *a4@<X8>)
{
  _QWORD *v6;
  std::__shared_weak_count *v7;
  std::__shared_weak_count *v8;
  uint64_t v9;
  std::__shared_weak_count *v10;
  unint64_t *v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t *v15;
  unint64_t v16;
  std::__shared_weak_count *v17;
  __int128 v18;

  *(_QWORD *)&v18 = a2;
  v6 = std::__hash_table<std::__hash_value_type<boost::uuids::uuid,std::weak_ptr<CLMicroLocationFingerprint>>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::weak_ptr<CLMicroLocationFingerprint>>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::weak_ptr<CLMicroLocationFingerprint>>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,std::weak_ptr<CLMicroLocationFingerprint>>>>::__emplace_unique_key_args<boost::uuids::uuid,std::piecewise_construct_t const&,std::tuple<boost::uuids::uuid const&>,std::tuple<>>((uint64_t)this, a2, (uint64_t)&std::piecewise_construct, (_OWORD **)&v18);
  *a4 = 0;
  a4[1] = 0;
  v7 = (std::__shared_weak_count *)v6[5];
  if (!v7 || (v8 = std::__shared_weak_count::lock(v7), (a4[1] = (uint64_t)v8) == 0) || (v9 = v6[4], (*a4 = v9) == 0))
  {
    std::allocate_shared[abi:ne180100]<CLMicroLocationFingerprint,std::allocator<CLMicroLocationFingerprint>,CLMicroLocationFingerprint const&,void>((uint64_t)a3, &v18);
    std::shared_ptr<CLMicroLocationFingerprint>::operator=[abi:ne180100]((uint64_t)a4, &v18);
    v10 = (std::__shared_weak_count *)*((_QWORD *)&v18 + 1);
    if (*((_QWORD *)&v18 + 1))
    {
      v11 = (unint64_t *)(*((_QWORD *)&v18 + 1) + 8);
      do
        v12 = __ldaxr(v11);
      while (__stlxr(v12 - 1, v11));
      if (!v12)
      {
        ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
        std::__shared_weak_count::__release_weak(v10);
      }
    }
    v14 = *a4;
    v13 = a4[1];
    if (v13)
    {
      v15 = (unint64_t *)(v13 + 16);
      do
        v16 = __ldxr(v15);
      while (__stxr(v16 + 1, v15));
    }
    v17 = (std::__shared_weak_count *)v6[5];
    v6[4] = v14;
    v6[5] = v13;
    if (v17)
      std::__shared_weak_count::__release_weak(v17);
  }
}

void sub_241A1B7A0(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::shared_ptr<CLMiLoService::ModelAndConf>::~shared_ptr[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

void CLMicroLocationFingerprintPool::at(CLMicroLocationFingerprintPool *this@<X0>, uuid *a2@<X1>, _BYTE *a3@<X8>)
{
  _QWORD *v4;
  _QWORD *v5;
  std::__shared_weak_count *v6;
  std::__shared_weak_count *v7;
  std::__shared_weak_count *v8;
  uint64_t v9;
  unint64_t *p_shared_owners;
  unint64_t v11;

  *a3 = 0;
  a3[192] = 0;
  v4 = std::__hash_table<std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>>>::find<boost::uuids::uuid>(this, a2);
  v5 = v4;
  if (v4)
  {
    v6 = (std::__shared_weak_count *)v4[5];
    if (v6)
    {
      v7 = std::__shared_weak_count::lock(v6);
      if (v7)
      {
        v8 = v7;
        v9 = v5[4];
        if (v9)
        {
          std::__optional_destruct_base<CLMicroLocationFingerprint,false>::reset[abi:ne180100]((uint64_t)a3);
          std::__construct_at[abi:ne180100]<CLMicroLocationFingerprint,CLMicroLocationFingerprint&,CLMicroLocationFingerprint*>((uint64_t)a3, v9);
          a3[192] = 1;
        }
        p_shared_owners = (unint64_t *)&v8->__shared_owners_;
        do
          v11 = __ldaxr(p_shared_owners);
        while (__stlxr(v11 - 1, p_shared_owners));
        if (!v11)
        {
          ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
          std::__shared_weak_count::__release_weak(v8);
        }
      }
    }
  }
}

void sub_241A1B864(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v9;

  std::shared_ptr<CLMiLoService::ModelAndConf>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  std::__optional_destruct_base<CLMicroLocationFingerprint,false>::~__optional_destruct_base[abi:ne180100](v9);
  _Unwind_Resume(a1);
}

_QWORD *std::__hash_table<std::__hash_value_type<boost::uuids::uuid,std::weak_ptr<CLMicroLocationFingerprint>>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::weak_ptr<CLMicroLocationFingerprint>>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::weak_ptr<CLMicroLocationFingerprint>>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,std::weak_ptr<CLMicroLocationFingerprint>>>>::__emplace_unique_key_args<boost::uuids::uuid,std::piecewise_construct_t const&,std::tuple<boost::uuids::uuid const&>,std::tuple<>>(uint64_t a1, _QWORD *a2, uint64_t a3, _OWORD **a4)
{
  unint64_t v4;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint8x8_t v10;
  _QWORD **v11;
  _QWORD *i;
  unint64_t v13;
  _QWORD *v15;
  float v16;
  float v17;
  _BOOL8 v18;
  unint64_t v19;
  unint64_t v20;
  size_t v21;
  uint64_t v22;
  _QWORD *v23;
  unint64_t v24;

  v7 = 0;
  v8 = 0;
  do
    v8 ^= (v8 << 6) + (v8 >> 2) + 2654435769u + *((unsigned __int8 *)a2 + v7++);
  while (v7 != 16);
  v9 = *(_QWORD *)(a1 + 8);
  if (v9)
  {
    v10 = (uint8x8_t)vcnt_s8((int8x8_t)v9);
    v10.i16[0] = vaddlv_u8(v10);
    if (v10.u32[0] > 1uLL)
    {
      v4 = v8;
      if (v8 >= v9)
        v4 = v8 % v9;
    }
    else
    {
      v4 = (v9 - 1) & v8;
    }
    v11 = *(_QWORD ***)(*(_QWORD *)a1 + 8 * v4);
    if (v11)
    {
      for (i = *v11; i; i = (_QWORD *)*i)
      {
        v13 = i[1];
        if (v13 == v8)
        {
          if (i[2] == *a2 && i[3] == a2[1])
            return i;
        }
        else
        {
          if (v10.u32[0] > 1uLL)
          {
            if (v13 >= v9)
              v13 %= v9;
          }
          else
          {
            v13 &= v9 - 1;
          }
          if (v13 != v4)
            break;
        }
      }
    }
  }
  v15 = (_QWORD *)(a1 + 16);
  i = operator new(0x30uLL);
  *i = 0;
  i[1] = v8;
  *((_OWORD *)i + 1) = **a4;
  i[4] = 0;
  i[5] = 0;
  v16 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v17 = *(float *)(a1 + 32);
  if (!v9 || (float)(v17 * (float)v9) < v16)
  {
    v18 = 1;
    if (v9 >= 3)
      v18 = (v9 & (v9 - 1)) != 0;
    v19 = v18 | (2 * v9);
    v20 = vcvtps_u32_f32(v16 / v17);
    if (v19 <= v20)
      v21 = v20;
    else
      v21 = v19;
    std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>>>::__rehash<true>(a1, v21);
    v9 = *(_QWORD *)(a1 + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v8 >= v9)
        v4 = v8 % v9;
      else
        v4 = v8;
    }
    else
    {
      v4 = (v9 - 1) & v8;
    }
  }
  v22 = *(_QWORD *)a1;
  v23 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v4);
  if (v23)
  {
    *i = *v23;
LABEL_44:
    *v23 = i;
    goto LABEL_45;
  }
  *i = *v15;
  *v15 = i;
  *(_QWORD *)(v22 + 8 * v4) = v15;
  if (*i)
  {
    v24 = *(_QWORD *)(*i + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v24 >= v9)
        v24 %= v9;
    }
    else
    {
      v24 &= v9 - 1;
    }
    v23 = (_QWORD *)(*(_QWORD *)a1 + 8 * v24);
    goto LABEL_44;
  }
LABEL_45:
  ++*(_QWORD *)(a1 + 24);
  return i;
}

void sub_241A1BAF0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  _QWORD *v10;
  uint64_t v11;

  std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<boost::uuids::uuid,std::weak_ptr<CLMicroLocationFingerprint>>,void *>>>::operator()[abi:ne180100](v11, v10);
  _Unwind_Resume(a1);
}

void std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<boost::uuids::uuid,std::weak_ptr<CLMicroLocationFingerprint>>,void *>>>::operator()[abi:ne180100](uint64_t a1, _QWORD *__p)
{
  std::__shared_weak_count *v3;

  if (*(_BYTE *)(a1 + 8))
  {
    v3 = (std::__shared_weak_count *)__p[5];
    if (v3)
      std::__shared_weak_count::__release_weak(v3);
  }
  else if (!__p)
  {
    return;
  }
  operator delete(__p);
}

_QWORD *std::allocate_shared[abi:ne180100]<CLMicroLocationFingerprint,std::allocator<CLMicroLocationFingerprint>,CLMicroLocationFingerprint const&,void>@<X0>(uint64_t a1@<X1>, _QWORD *a2@<X8>)
{
  _QWORD *v4;
  _QWORD *result;

  v4 = operator new(0xD8uLL);
  result = std::__shared_ptr_emplace<CLMicroLocationFingerprint>::__shared_ptr_emplace[abi:ne180100]<CLMicroLocationFingerprint const&,std::allocator<CLMicroLocationFingerprint>,0>(v4, a1);
  *a2 = v4 + 3;
  a2[1] = v4;
  return result;
}

void sub_241A1BB98(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

_QWORD *std::__shared_ptr_emplace<CLMicroLocationFingerprint>::__shared_ptr_emplace[abi:ne180100]<CLMicroLocationFingerprint const&,std::allocator<CLMicroLocationFingerprint>,0>(_QWORD *a1, uint64_t a2)
{
  char v4;

  a1[1] = 0;
  a1[2] = 0;
  *a1 = &off_2511D3870;
  std::allocator<CLMicroLocationFingerprint>::construct[abi:ne180100]<CLMicroLocationFingerprint,CLMicroLocationFingerprint const&>((uint64_t)&v4, (uint64_t)(a1 + 3), a2);
  return a1;
}

void sub_241A1BBF4(_Unwind_Exception *a1)
{
  std::__shared_weak_count *v1;

  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<CLMicroLocationFingerprint>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_2511D3870;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<CLMicroLocationFingerprint>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_2511D3870;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2426A04D4);
}

uint64_t std::__shared_ptr_emplace<CLMicroLocationFingerprint>::__on_zero_shared(uint64_t a1)
{
  char v2;

  return std::allocator<CLMicroLocationFingerprint>::destroy[abi:ne180100]((uint64_t)&v2, a1 + 24);
}

uint64_t std::__optional_destruct_base<CLMicroLocationFingerprint,false>::reset[abi:ne180100](uint64_t result)
{
  uint64_t v1;
  void *v2;

  if (*(_BYTE *)(result + 192))
  {
    v1 = result;
    v2 = *(void **)(result + 168);
    if (v2)
    {
      *(_QWORD *)(v1 + 176) = v2;
      operator delete(v2);
    }
    std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>>>::~__hash_table(v1 + 104);
    std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>>>::~__hash_table(v1 + 64);
    result = std::__hash_table<CLMicroLocationFingerprint::Measurement,CLMicroLocationFingerprint::Measurement::HashMeasurement,CLMicroLocationFingerprint::Measurement::PredicateMeasurement,std::allocator<CLMicroLocationFingerprint::Measurement>>::~__hash_table(v1);
    *(_BYTE *)(v1 + 192) = 0;
  }
  return result;
}

uint64_t std::__construct_at[abi:ne180100]<CLMicroLocationFingerprint,CLMicroLocationFingerprint&,CLMicroLocationFingerprint*>(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  __int128 v5;
  __int128 v6;
  int v7;

  v4 = std::unordered_set<CLMicroLocationFingerprint::Measurement,CLMicroLocationFingerprint::Measurement::HashMeasurement,CLMicroLocationFingerprint::Measurement::PredicateMeasurement,std::allocator<CLMicroLocationFingerprint::Measurement>>::unordered_set(a1, a2);
  v5 = *(_OWORD *)(a2 + 40);
  *(_QWORD *)(v4 + 56) = *(_QWORD *)(a2 + 56);
  *(_OWORD *)(v4 + 40) = v5;
  std::unordered_set<CLMicroLocationProto::DataType>::unordered_set(v4 + 64, a2 + 64);
  std::unordered_map<CLMicroLocationProto::DataType,CLMicroLocationFingerprint::StartAndEndTimestamps>::unordered_map(a1 + 104, a2 + 104);
  v6 = *(_OWORD *)(a2 + 144);
  v7 = *(_DWORD *)(a2 + 160);
  *(_QWORD *)(a1 + 168) = 0;
  *(_DWORD *)(a1 + 160) = v7;
  *(_OWORD *)(a1 + 144) = v6;
  *(_QWORD *)(a1 + 176) = 0;
  *(_QWORD *)(a1 + 184) = 0;
  std::vector<CLMicroLocationProto::ConfidenceReason>::__init_with_size[abi:ne180100]<CLMicroLocationProto::ConfidenceReason*,CLMicroLocationProto::ConfidenceReason*>((_QWORD *)(a1 + 168), *(const void **)(a2 + 168), *(_QWORD *)(a2 + 176), (uint64_t)(*(_QWORD *)(a2 + 176) - *(_QWORD *)(a2 + 168)) >> 2);
  return a1;
}

void sub_241A1BD4C(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;

  std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>>>::~__hash_table(v3);
  std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>>>::~__hash_table(v2);
  std::__hash_table<CLMicroLocationFingerprint::Measurement,CLMicroLocationFingerprint::Measurement::HashMeasurement,CLMicroLocationFingerprint::Measurement::PredicateMeasurement,std::allocator<CLMicroLocationFingerprint::Measurement>>::~__hash_table(v1);
  _Unwind_Resume(a1);
}

_QWORD *CLMicroLocationAlgorithms::createLearner@<X0>(unsigned int a1@<W0>, _QWORD *a2@<X8>)
{
  _QWORD *result;

  if (a1 >= 2)
  {
    CLMicroLocationAlgorithms::createLearner();
    return _CLLogObjectForCategory_MicroLocation_Default();
  }
  else
  {
    if (a1 == 1)
    {
      result = 0;
    }
    else
    {
      result = (_QWORD *)operator new();
      *result = &unk_2511D6778;
    }
    *a2 = result;
  }
  return result;
}

void CLMicroLocationAlgorithms::getDendrogramLearningParams(int a1@<W0>, _QWORD *a2@<X8>)
{
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  uint64_t v7;
  uint64_t v8;
  void *v9;
  void *v10;
  void *v11;
  void *v12;
  uint64_t v13;
  uint64_t v14;
  void *v15;
  void *v16;
  void *v17;
  void *v18;
  uint64_t v19;
  uint64_t v20;

  if (a1 == 2)
  {
    ULSettings::get<ULSettings::SimilarityListClusterDistanceThresholdVector>((uint64_t)a2);
    +[ULDefaultsSingleton shared](ULDefaultsSingleton, "shared");
    v3 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v3, "defaultsDictionary");
    v4 = (void *)objc_claimAutoreleasedReturnValue();

    objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "ULSimilarityListSmallClusterSize");
    v5 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v4, "objectForKey:", v5);
    v6 = (void *)objc_claimAutoreleasedReturnValue();
    if (v6 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
      v7 = objc_msgSend(v6, "unsignedLongValue");
    else
      v7 = objc_msgSend(&unk_2511ED4F8, "unsignedLongValue");
    v8 = v7;

    a2[3] = v8;
    +[ULDefaultsSingleton shared](ULDefaultsSingleton, "shared");
    v9 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v9, "defaultsDictionary");
    v10 = (void *)objc_claimAutoreleasedReturnValue();

    objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "ULSimilarityListSmallClusterRelativeSize");
    v11 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v10, "objectForKey:", v11);
    v12 = (void *)objc_claimAutoreleasedReturnValue();
    if (v12 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
      objc_msgSend(v12, "doubleValue");
    else
      objc_msgSend(&unk_2511ECD78, "doubleValue");
    v14 = v13;

    a2[4] = v14;
    +[ULDefaultsSingleton shared](ULDefaultsSingleton, "shared");
    v15 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v15, "defaultsDictionary");
    v16 = (void *)objc_claimAutoreleasedReturnValue();

    objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "ULSimilarityListSmallClusterDistanceThreshold");
    v17 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v16, "objectForKey:", v17);
    v18 = (void *)objc_claimAutoreleasedReturnValue();
    if (v18 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
      objc_msgSend(v18, "doubleValue");
    else
      objc_msgSend(&unk_2511ECD88, "doubleValue");
    v20 = v19;

    a2[5] = v20;
  }
  else
  {
    ULSettings::get<ULSettings::MagicalMomentsClusterDistanceThresholdVector>((uint64_t)a2);
    a2[3] = 0;
    a2[4] = 0;
    a2[5] = 0;
  }
}

void sub_241A1C044(_Unwind_Exception *a1)
{
  uint64_t v1;
  void *v2;
  void *v3;
  void *v4;
  void *v6;

  v6 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v6;
    operator delete(v6);
  }
  _Unwind_Resume(a1);
}

void sub_241A1C0C0()
{
  JUMPOUT(0x241A1C0A8);
}

void ULSettings::get<ULSettings::SimilarityListClusterDistanceThresholdVector>(uint64_t a1@<X8>)
{
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  uint64_t v6;
  __int128 v7;
  uint64_t v8;

  +[ULDefaultsSingleton shared](ULDefaultsSingleton, "shared");
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v2, "defaultsDictionary");
  v3 = (void *)objc_claimAutoreleasedReturnValue();

  objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "ULSimilarityListClusterDistanceThresholdVector");
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v3, "objectForKey:", v4);
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  if (v5 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
  {
    ULSettings::convert<NSArray<NSNumber *> * {__strong},std::vector<double>>(v5, (uint64_t)&v7);
    *(_OWORD *)a1 = v7;
    v6 = v8;
  }
  else
  {
    ULSettings::convert<std::initializer_list<double>,std::vector<double>>(&_ZGRN10ULSettings14SettingsTraitsINS_44SimilarityListClusterDistanceThresholdVectorEE12defaultValueE_, 1uLL, (uint64_t)&v7);
    v6 = v8;
    *(_OWORD *)a1 = v7;
  }
  *(_QWORD *)(a1 + 16) = v6;

}

void sub_241A1C1B4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void ULSettings::get<ULSettings::MagicalMomentsClusterDistanceThresholdVector>(uint64_t a1@<X8>)
{
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  uint64_t v6;
  __int128 v7;
  uint64_t v8;

  +[ULDefaultsSingleton shared](ULDefaultsSingleton, "shared");
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v2, "defaultsDictionary");
  v3 = (void *)objc_claimAutoreleasedReturnValue();

  objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "ULMagicalMomentsClusterDistanceThresholdVector");
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v3, "objectForKey:", v4);
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  if (v5 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
  {
    ULSettings::convert<NSArray<NSNumber *> * {__strong},std::vector<double>>(v5, (uint64_t)&v7);
    *(_OWORD *)a1 = v7;
    v6 = v8;
  }
  else
  {
    ULSettings::convert<std::initializer_list<double>,std::vector<double>>(_ZGRN10ULSettings14SettingsTraitsINS_44MagicalMomentsClusterDistanceThresholdVectorEE12defaultValueE_, 3uLL, (uint64_t)&v7);
    v6 = v8;
    *(_OWORD *)a1 = v7;
  }
  *(_QWORD *)(a1 + 16) = v6;

}

void sub_241A1C2DC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

_QWORD *CLMicroLocationAlgorithms::createLocalizerAlgorithm@<X0>(int a1@<W0>, _QWORD *a2@<X8>)
{
  _QWORD *result;
  char *v4;
  CLMicroLocationAlgorithms *LocalizerAlgorithm;
  NSDictionary *v6;

  switch(a1)
  {
    case 0:
      result = (_QWORD *)operator new();
      goto LABEL_8;
    case 1:
      result = (_QWORD *)operator new();
      goto LABEL_8;
    case 2:
      result = (_QWORD *)operator new();
      goto LABEL_8;
    case 3:
      result = (_QWORD *)operator new();
      goto LABEL_8;
    case 4:
      result = (_QWORD *)operator new();
      goto LABEL_8;
    case 5:
      result = (_QWORD *)operator new();
LABEL_8:
      *result = v4 + 16;
      *a2 = result;
      break;
    default:
      LocalizerAlgorithm = (CLMicroLocationAlgorithms *)CLMicroLocationAlgorithms::createLocalizerAlgorithm();
      result = (_QWORD *)CLMicroLocationAlgorithms::createKernelFunction(LocalizerAlgorithm, v6);
      break;
  }
  return result;
}

void CLMicroLocationAlgorithms::createKernelFunction(CLMicroLocationAlgorithms *this, NSDictionary *a2)
{
  void *v2;
  void *v3;
  int v4;
  NSObject *v5;
  NSObject *v6;
  NSObject *v7;
  NSObject *v8;
  NSObject *v9;
  uint64_t v10;
  CLMicroLocationAlgorithms *v11;
  uint8_t buf[4];
  int v13;
  __int16 v14;
  const char *v15;
  __int16 v16;
  const char *v17;
  __int16 v18;
  const char *v19;
  __int16 v20;
  const char *v21;
  uint64_t v22;

  v22 = *MEMORY[0x24BDAC8D0];
  v11 = this;
  -[CLMicroLocationAlgorithms objectForKeyedSubscript:](v11, "objectForKeyedSubscript:", CFSTR("type"));
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  v3 = v2;
  if (v2)
  {
    if ((unint64_t)objc_msgSend(v2, "unsignedLongValue") < 4)
    {
      v4 = objc_msgSend(v3, "unsignedLongValue");
      -[CLMicroLocationAlgorithms objectForKeyedSubscript:](v11, "objectForKeyedSubscript:", CFSTR("sigma"));
      objc_claimAutoreleasedReturnValue();
      -[CLMicroLocationAlgorithms objectForKeyedSubscript:](v11, "objectForKeyedSubscript:", CFSTR("power"));
      objc_claimAutoreleasedReturnValue();
      __asm { BR              X10 }
    }
    _CLLogObjectForCategory_MicroLocation_Default();
    v8 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 68289795;
      v13 = 0;
      v14 = 2082;
      v15 = "";
      v16 = 2050;
      v17 = (const char *)objc_msgSend(v3, "unsignedLongValue");
      v18 = 2082;
      v19 = "assert";
      v20 = 2081;
      v21 = "primitiveType.unsignedLongValue < static_cast<uint32_t>(KernelFunctionType::kTypeCount)";
      _os_log_impl(&dword_2419D9000, v8, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Invalid algorithm chosen\", \"enum value\":%{public}lu, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x30u);
    }

    _CLLogObjectForCategory_MicroLocation_Default();
    v9 = objc_claimAutoreleasedReturnValue();
    if (os_signpost_enabled(v9))
    {
      v10 = objc_msgSend(v3, "unsignedLongValue");
      *(_DWORD *)buf = 68289795;
      v13 = 0;
      v14 = 2082;
      v15 = "";
      v16 = 2050;
      v17 = (const char *)v10;
      v18 = 2082;
      v19 = "assert";
      v20 = 2081;
      v21 = "primitiveType.unsignedLongValue < static_cast<uint32_t>(KernelFunctionType::kTypeCount)";
      _os_signpost_emit_with_name_impl(&dword_2419D9000, v9, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Invalid algorithm chosen", "{\"msg%{public}.0s\":\"Invalid algorithm chosen\", \"enum value\":%{public}lu, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x30u);
    }

    _CLLogObjectForCategory_MicroLocation_Default();
    v7 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
      CLMicroLocationAlgorithms::createKernelFunction((uint64_t)buf, objc_msgSend(v3, "unsignedLongValue"), v7);
  }
  else
  {
    _CLLogObjectForCategory_MicroLocation_Default();
    v5 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 68289539;
      v13 = 0;
      v14 = 2082;
      v15 = "";
      v16 = 2082;
      v17 = "assert";
      v18 = 2081;
      v19 = "primitiveType";
      _os_log_impl(&dword_2419D9000, v5, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"No type provided in dictionary\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x26u);
    }

    _CLLogObjectForCategory_MicroLocation_Default();
    v6 = objc_claimAutoreleasedReturnValue();
    if (os_signpost_enabled(v6))
    {
      *(_DWORD *)buf = 68289539;
      v13 = 0;
      v14 = 2082;
      v15 = "";
      v16 = 2082;
      v17 = "assert";
      v18 = 2081;
      v19 = "primitiveType";
      _os_signpost_emit_with_name_impl(&dword_2419D9000, v6, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "No type provided in dictionary", "{\"msg%{public}.0s\":\"No type provided in dictionary\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x26u);
    }

    _CLLogObjectForCategory_MicroLocation_Default();
    v7 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 68289539;
      v13 = 0;
      v14 = 2082;
      v15 = "";
      v16 = 2082;
      v17 = "assert";
      v18 = 2081;
      v19 = "primitiveType";
      _os_log_impl(&dword_2419D9000, v7, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"No type provided in dictionary\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x26u);
    }
  }

  abort_report_np();
  __break(1u);
  JUMPOUT(0x241A1D280);
}

void sub_241A1D284(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, id a12)
{
  void *v12;
  void *v13;
  void *v14;
  uint64_t v15;

  MEMORY[0x2426A04D4](v15, 0x1081C40468F112ELL);

  _Unwind_Resume(a1);
}

void CLMicroLocationAlgorithms::createLearnFingerprintDistanceFunction(int a1, void *a2)
{
  CLMicroLocationAlgorithms::details::createFingerprintDistanceFunction(a1, a2);
}

{
  CLMicroLocationAlgorithms::details::createFingerprintDistanceFunction(a1, a2);
}

void CLMicroLocationAlgorithms::details::createFingerprintDistanceFunction(int a1, void *a2)
{
  ULHomeNearbyRangingSupport *v3;
  int isUwbRangingSupportedOnDevice;
  CLMicroLocationUtils *v5;
  int v6;
  void *v7;
  void *v8;
  void *v9;
  void *v10;
  id v11;

  v11 = a2;
  v3 = (ULHomeNearbyRangingSupport *)ULSettings::get<ULSettings::MeasurementProcessingUwbRangeEnable>();
  if ((_DWORD)v3)
    isUwbRangingSupportedOnDevice = ULHomeNearbyRangingSupport::isUwbRangingSupportedOnDevice(v3);
  else
    isUwbRangingSupportedOnDevice = 0;
  v5 = (CLMicroLocationUtils *)ULSettings::get<ULSettings::MeasurementProcessingWifiRssiEnable>();
  v6 = ULSettings::get<ULSettings::MeasurementProcessingBleLeechEnable>();
  CLMicroLocationUtils::createEnabledTechnologies(v5, v6, isUwbRangingSupportedOnDevice);
  +[ULDefaultsSingleton shared](ULDefaultsSingleton, "shared");
  v7 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v7, "defaultsDictionary");
  v8 = (void *)objc_claimAutoreleasedReturnValue();

  objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "ULAdaptiveSensorsEnable");
  v9 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v8, "objectForKey:", v9);
  v10 = (void *)objc_claimAutoreleasedReturnValue();
  if (v10 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
    objc_msgSend(v10, "BOOLValue");
  else
    objc_msgSend(MEMORY[0x24BDBD1C8], "BOOLValue");

  CLMicroLocationAlgorithms::details::createFingerprintDistanceFunction(a1, v11);
}

{
  a2;
  __asm { BR              X10 }
}

void sub_241A1D494(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;
  void *v11;
  void *v12;

  _Unwind_Resume(a1);
}

void sub_241A1D55C()
{
  int v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  id v5;
  void *v6;
  uint64_t v7;
  NSString *v8;
  id v9;
  id v10;
  NSString *v11;
  NSString *v12;
  void *v13;
  void *v14;
  char *v15;
  __int128 v16;
  uint64_t v17;
  uint64_t v18;
  NSObject *v19;
  NSObject *v20;
  NSObject *v21;
  NSObject *v22;
  NSObject *v23;
  NSObject *v24;
  NSObject *v25;
  void *v26;
  void *v27;
  void *v28;
  _BYTE v29[18];
  __int16 v30;
  _BYTE v31[20];
  uint64_t v32;
  uint64_t v33;
  __int128 v34;
  uint64_t v35;
  uint64_t v36;
  __int128 v37;
  uint64_t v38;
  uint64_t v39;
  __int128 v40;
  uint64_t v41;
  uint64_t (**v42)();
  __int16 v43;
  char v44;
  __int128 v45;
  _BYTE v46[192];

  v5 = v27;
  objc_msgSend(v5, "objectForKeyedSubscript:", CFSTR("jaccard_scale_factor"));
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v5, "objectForKeyedSubscript:", CFSTR("e2j_kernel_thr"));
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v5, "objectForKeyedSubscript:", CFSTR("per_source_params"));
  v7 = objc_claimAutoreleasedReturnValue();
  if (!v6)
  {
    _CLLogObjectForCategory_MicroLocation_Default();
    v19 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v19, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)v29 = 68289539;
      *(_DWORD *)&v29[4] = 0;
      *(_WORD *)&v29[8] = 2082;
      *(_QWORD *)(v3 + 10) = "";
      v30 = 2082;
      *(_QWORD *)(v3 + 20) = "assert";
      *(_WORD *)&v31[8] = 2081;
      *(_QWORD *)(v3 + 30) = "jaccard_scale_factor";
      _os_log_impl(&dword_2419D9000, v19, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"No jaccard_scale_factor provided in dictionary\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", v29, 0x26u);
    }

    _CLLogObjectForCategory_MicroLocation_Default();
    v20 = objc_claimAutoreleasedReturnValue();
    if (os_signpost_enabled(v20))
    {
      *(_DWORD *)v29 = 68289539;
      *(_DWORD *)&v29[4] = 0;
      *(_WORD *)&v29[8] = 2082;
      *(_QWORD *)(v3 + 10) = "";
      v30 = 2082;
      *(_QWORD *)(v3 + 20) = "assert";
      *(_WORD *)&v31[8] = 2081;
      *(_QWORD *)(v3 + 30) = "jaccard_scale_factor";
      _os_signpost_emit_with_name_impl(&dword_2419D9000, v20, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "No jaccard_scale_factor provided in dictionary", "{\"msg%{public}.0s\":\"No jaccard_scale_factor provided in dictionary\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", v29, 0x26u);
    }

    _CLLogObjectForCategory_MicroLocation_Default();
    v21 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v21, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)v29 = 68289539;
      *(_DWORD *)&v29[4] = 0;
      *(_WORD *)&v29[8] = 2082;
      *(_QWORD *)&v29[10] = "";
      v30 = 2082;
      *(_QWORD *)v31 = "assert";
      *(_WORD *)&v31[8] = 2081;
      *(_QWORD *)&v31[10] = "jaccard_scale_factor";
      _os_log_impl(&dword_2419D9000, v21, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"No jaccard_scale_factor provided in dictionary\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", v29, 0x26u);
    }
    goto LABEL_31;
  }
  if (!v26)
  {
    _CLLogObjectForCategory_MicroLocation_Default();
    v22 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v22, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)v29 = 68289539;
      *(_DWORD *)&v29[4] = 0;
      *(_WORD *)&v29[8] = 2082;
      *(_QWORD *)(v3 + 10) = "";
      v30 = 2082;
      *(_QWORD *)(v3 + 20) = "assert";
      *(_WORD *)&v31[8] = 2081;
      *(_QWORD *)(v3 + 30) = "e2jKernelThr";
      _os_log_impl(&dword_2419D9000, v22, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"No e2j_kernel_thr provided in dictionary\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", v29, 0x26u);
    }

    _CLLogObjectForCategory_MicroLocation_Default();
    v23 = objc_claimAutoreleasedReturnValue();
    if (os_signpost_enabled(v23))
    {
      *(_DWORD *)v29 = 68289539;
      *(_DWORD *)&v29[4] = 0;
      *(_WORD *)&v29[8] = 2082;
      *(_QWORD *)(v3 + 10) = "";
      v30 = 2082;
      *(_QWORD *)(v3 + 20) = "assert";
      *(_WORD *)&v31[8] = 2081;
      *(_QWORD *)(v3 + 30) = "e2jKernelThr";
      _os_signpost_emit_with_name_impl(&dword_2419D9000, v23, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "No e2j_kernel_thr provided in dictionary", "{\"msg%{public}.0s\":\"No e2j_kernel_thr provided in dictionary\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", v29, 0x26u);
    }

    _CLLogObjectForCategory_MicroLocation_Default();
    v21 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v21, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)v29 = 68289539;
      *(_DWORD *)&v29[4] = 0;
      *(_WORD *)&v29[8] = 2082;
      *(_QWORD *)&v29[10] = "";
      v30 = 2082;
      *(_QWORD *)v31 = "assert";
      *(_WORD *)&v31[8] = 2081;
      *(_QWORD *)&v31[10] = "e2jKernelThr";
      _os_log_impl(&dword_2419D9000, v21, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"No e2j_kernel_thr provided in dictionary\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", v29, 0x26u);
    }
    goto LABEL_31;
  }
  if (!v7)
  {
    _CLLogObjectForCategory_MicroLocation_Default();
    v24 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v24, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)v29 = 68289539;
      *(_DWORD *)&v29[4] = 0;
      *(_WORD *)&v29[8] = 2082;
      *(_QWORD *)(v3 + 10) = "";
      v30 = 2082;
      *(_QWORD *)(v3 + 20) = "assert";
      *(_WORD *)&v31[8] = 2081;
      *(_QWORD *)(v3 + 30) = "perSourceParams";
      _os_log_impl(&dword_2419D9000, v24, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"No per_source_params provided in dictionary\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", v29, 0x26u);
    }

    _CLLogObjectForCategory_MicroLocation_Default();
    v25 = objc_claimAutoreleasedReturnValue();
    if (os_signpost_enabled(v25))
    {
      *(_DWORD *)v29 = 68289539;
      *(_DWORD *)&v29[4] = 0;
      *(_WORD *)&v29[8] = 2082;
      *(_QWORD *)(v3 + 10) = "";
      v30 = 2082;
      *(_QWORD *)(v3 + 20) = "assert";
      *(_WORD *)&v31[8] = 2081;
      *(_QWORD *)(v3 + 30) = "perSourceParams";
      _os_signpost_emit_with_name_impl(&dword_2419D9000, v25, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "No per_source_params provided in dictionary", "{\"msg%{public}.0s\":\"No per_source_params provided in dictionary\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", v29, 0x26u);
    }

    _CLLogObjectForCategory_MicroLocation_Default();
    v21 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v21, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)v29 = 68289539;
      *(_DWORD *)&v29[4] = 0;
      *(_WORD *)&v29[8] = 2082;
      *(_QWORD *)&v29[10] = "";
      v30 = 2082;
      *(_QWORD *)v31 = "assert";
      *(_WORD *)&v31[8] = 2081;
      *(_QWORD *)&v31[10] = "perSourceParams";
      _os_log_impl(&dword_2419D9000, v21, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"No per_source_params provided in dictionary\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", v29, 0x26u);
    }
LABEL_31:

    abort_report_np();
LABEL_33:
    __break(1u);
    return;
  }
  v8 = (NSString *)v7;
  v9 = v6;
  *(_QWORD *)v29 = v9;
  v10 = v26;
  *(_QWORD *)&v29[8] = v10;
  CLMicroLocationAlgorithms::details::createPerSourceWeights((CLMicroLocationAlgorithms::details *)CFSTR("value_scale_factor"), v8, &v29[16]);
  CLMicroLocationAlgorithms::details::createPerSourceWeights((CLMicroLocationAlgorithms::details *)CFSTR("euclidean_weight"), v8, &v33);
  CLMicroLocationAlgorithms::details::createPerSourceWeights((CLMicroLocationAlgorithms::details *)CFSTR("jaccard_pos_weight"), v8, &v36);
  CLMicroLocationAlgorithms::details::createPerSourceWeights((CLMicroLocationAlgorithms::details *)CFSTR("jaccard_neg_weight"), v8, &v39);
  v11 = v8;
  v12 = v11;
  if (!v0)
  {
    v42 = &off_2511D3A70;
    v43 = 0;
    v44 = 0;
    goto LABEL_8;
  }
  -[NSString objectForKeyedSubscript:](v11, "objectForKeyedSubscript:", CFSTR("onesided_jaccard"));
  v13 = (void *)objc_claimAutoreleasedReturnValue();
  v14 = v13;
  if (!v13)
  {
    CLMicroLocationAlgorithms::details::createFingerprintDistanceFunction();

    abort_report_np();
    goto LABEL_33;
  }
  CLMicroLocationUtils::PerSourceWeights<BOOL>::fromConfiguration(v13, (uint64_t)&v42);

LABEL_8:
  *(_QWORD *)&v45 = *(_QWORD *)v4;
  BYTE8(v45) = *(_BYTE *)(v4 + 8);
  std::__optional_copy_base<CLMicroLocationAnchorAppearanceMap,false>::__optional_copy_base[abi:ne180100]((uint64_t)v46, v2);
  *(_QWORD *)(v1 + 24) = 0;
  v15 = (char *)operator new(0xF8uLL);
  *(_QWORD *)v15 = &off_2511D3AC0;
  v16 = *(_OWORD *)v29;
  *(_QWORD *)v29 = 0;
  *(_QWORD *)&v29[8] = 0;
  *(_OWORD *)(v15 + 8) = v16;
  *((_QWORD *)v15 + 3) = &off_2511D3368;
  *((_OWORD *)v15 + 2) = *(_OWORD *)&v31[4];
  v17 = v35;
  *((_QWORD *)v15 + 6) = v32;
  *((_QWORD *)v15 + 7) = &off_2511D3368;
  *((_OWORD *)v15 + 4) = v34;
  *((_QWORD *)v15 + 10) = v17;
  *((_QWORD *)v15 + 11) = &off_2511D3368;
  *((_OWORD *)v15 + 6) = v37;
  v18 = v41;
  *((_QWORD *)v15 + 14) = v38;
  *((_QWORD *)v15 + 15) = &off_2511D3368;
  *((_OWORD *)v15 + 8) = v40;
  *((_QWORD *)v15 + 18) = v18;
  *((_QWORD *)v15 + 19) = &off_2511D3A70;
  v15[162] = v44;
  *((_WORD *)v15 + 80) = v43;
  *(_OWORD *)(v15 + 168) = v45;
  std::__optional_copy_base<CLMicroLocationAnchorAppearanceMap,false>::__optional_copy_base[abi:ne180100]((uint64_t)(v15 + 184), (uint64_t)v46);
  *(_QWORD *)(v1 + 24) = v15;
  if (v46[56])
    std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>>>::~__hash_table((uint64_t)v46);

}

void sub_241A1E328(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, void *a8, ...)
{
  void *v8;
  void *v9;
  id *v10;
  va_list va;

  va_start(va, a8);

  operator delete(v10);
  CLMicroLocationAlgorithms::details::createFingerprintDistanceFunction(CLMicroLocationAlgorithms::FingerprintDistanceFunctionType,NSDictionary *,CLMicroLocationFingerprintDistanceFunction::EnabledTechnologiesConfig const&,CLMicroLocationAlgorithms::details::FingerprintDistanceFunctionUsage,std::optional<CLMicroLocationAnchorAppearanceMap> const&)::$_2::~$_2((uint64_t)va);

  _Unwind_Resume(a1);
}

void CLMicroLocationAlgorithms::createLocalizeFingerprintDistanceFunction(int a1, void *a2)
{
  CLMicroLocationAlgorithms::details::createFingerprintDistanceFunction(a1, a2);
}

uint64_t CLMicroLocationAlgorithms::getDataTypeValidForLocalization(CLMicroLocationAlgorithms *this)
{
  uint64_t v1;
  ULHomeNearbyRangingSupport *v2;

  if (ULSettings::get<ULSettings::MeasurementProcessingWifiRssiEnable>())
    v1 = 2;
  else
    v1 = 0;
  if (ULSettings::get<ULSettings::MeasurementProcessingBleLeechEnable>())
    v1 |= 0x20uLL;
  v2 = (ULHomeNearbyRangingSupport *)ULSettings::get<ULSettings::MeasurementProcessingUwbRangeEnable>();
  if ((_DWORD)v2 && ULHomeNearbyRangingSupport::isUwbRangingSupportedOnDevice(v2))
    return v1 | 0x40;
  return v1;
}

uint64_t ULSettings::get<ULSettings::MeasurementProcessingWifiRssiEnable>()
{
  void *v0;
  void *v1;
  void *v2;
  void *v3;
  uint64_t v4;
  uint64_t v5;

  +[ULDefaultsSingleton shared](ULDefaultsSingleton, "shared");
  v0 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v0, "defaultsDictionary");
  v1 = (void *)objc_claimAutoreleasedReturnValue();

  objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "ULMeasurementProcessingWifiRssiEnable");
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v1, "objectForKey:", v2);
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  if (v3 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
    v4 = objc_msgSend(v3, "BOOLValue");
  else
    v4 = objc_msgSend(MEMORY[0x24BDBD1C8], "BOOLValue");
  v5 = v4;

  return v5;
}

{
  void *v0;
  void *v1;
  void *v2;
  void *v3;
  uint64_t v4;
  uint64_t v5;

  +[ULDefaultsSingleton shared](ULDefaultsSingleton, "shared");
  v0 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v0, "defaultsDictionary");
  v1 = (void *)objc_claimAutoreleasedReturnValue();

  objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "ULMeasurementProcessingWifiRssiEnable");
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v1, "objectForKey:", v2);
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  if (v3 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
    v4 = objc_msgSend(v3, "BOOLValue");
  else
    v4 = objc_msgSend(MEMORY[0x24BDBD1C8], "BOOLValue");
  v5 = v4;

  return v5;
}

void sub_241A1E5D0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

uint64_t ULSettings::get<ULSettings::MeasurementProcessingBleLeechEnable>()
{
  void *v0;
  void *v1;
  void *v2;
  void *v3;
  uint64_t v4;
  uint64_t v5;

  +[ULDefaultsSingleton shared](ULDefaultsSingleton, "shared");
  v0 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v0, "defaultsDictionary");
  v1 = (void *)objc_claimAutoreleasedReturnValue();

  objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "ULMeasurementProcessingBleLeechEnable");
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v1, "objectForKey:", v2);
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  if (v3 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
    v4 = objc_msgSend(v3, "BOOLValue");
  else
    v4 = objc_msgSend(MEMORY[0x24BDBD1C8], "BOOLValue");
  v5 = v4;

  return v5;
}

{
  void *v0;
  void *v1;
  void *v2;
  void *v3;
  uint64_t v4;
  uint64_t v5;

  +[ULDefaultsSingleton shared](ULDefaultsSingleton, "shared");
  v0 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v0, "defaultsDictionary");
  v1 = (void *)objc_claimAutoreleasedReturnValue();

  objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "ULMeasurementProcessingBleLeechEnable");
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v1, "objectForKey:", v2);
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  if (v3 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
    v4 = objc_msgSend(v3, "BOOLValue");
  else
    v4 = objc_msgSend(MEMORY[0x24BDBD1C8], "BOOLValue");
  v5 = v4;

  return v5;
}

void sub_241A1E6CC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

uint64_t ULSettings::get<ULSettings::MeasurementProcessingUwbRangeEnable>()
{
  void *v0;
  void *v1;
  void *v2;
  void *v3;
  uint64_t v4;
  uint64_t v5;

  +[ULDefaultsSingleton shared](ULDefaultsSingleton, "shared");
  v0 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v0, "defaultsDictionary");
  v1 = (void *)objc_claimAutoreleasedReturnValue();

  objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "ULMeasurementProcessingUwbRangeEnable");
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v1, "objectForKey:", v2);
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  if (v3 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
    v4 = objc_msgSend(v3, "BOOLValue");
  else
    v4 = objc_msgSend(MEMORY[0x24BDBD1C8], "BOOLValue");
  v5 = v4;

  return v5;
}

{
  void *v0;
  void *v1;
  void *v2;
  void *v3;
  uint64_t v4;
  uint64_t v5;

  +[ULDefaultsSingleton shared](ULDefaultsSingleton, "shared");
  v0 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v0, "defaultsDictionary");
  v1 = (void *)objc_claimAutoreleasedReturnValue();

  objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "ULMeasurementProcessingUwbRangeEnable");
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v1, "objectForKey:", v2);
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  if (v3 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
    v4 = objc_msgSend(v3, "BOOLValue");
  else
    v4 = objc_msgSend(MEMORY[0x24BDBD1C8], "BOOLValue");
  v5 = v4;

  return v5;
}

void sub_241A1E7C8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void CLMicroLocationAlgorithms::createLinkageFunction(unsigned int a1@<W0>, _QWORD *a2@<X8>)
{
  uint64_t (*v2)();
  uint64_t *LinkageFunction;
  unsigned int v4;

  if (a1 >= 3)
  {
    LinkageFunction = (uint64_t *)CLMicroLocationAlgorithms::createLinkageFunction();
    CLMicroLocationAlgorithms::removeImprobableLocations(LinkageFunction, v4);
  }
  else
  {
    v2 = off_2511D3DE0[a1];
    *a2 = &off_2511D3D40;
    a2[1] = v2;
    a2[3] = a2;
  }
}

void CLMicroLocationAlgorithms::removeImprobableLocations(uint64_t *a1, unsigned int a2)
{
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  double v8;
  double v9;
  __int128 *v10;
  __int128 *v11;
  double v12;
  double v13;
  NSObject *v14;
  uint64_t v15;
  NSObject *v16;
  __int128 *v17;
  __int128 *v18;
  __int128 *v19;
  double v20;
  double v21;
  NSObject *v22;
  NSObject *v23;
  __int128 *v24;
  double v25;
  __int128 v26;
  double v27;
  uint8_t buf[4];
  _BYTE v29[14];
  __int16 v30;
  uint64_t v31;
  uint64_t v32;

  v32 = *MEMORY[0x24BDAC8D0];
  if (a2 < 2)
    goto LABEL_4;
  if (a2 == 2)
    return;
  if (a2 == 3)
  {
LABEL_4:
    +[ULDefaultsSingleton shared](ULDefaultsSingleton, "shared");
    v4 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v4, "defaultsDictionary");
    v5 = (void *)objc_claimAutoreleasedReturnValue();

    objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "ULMinimumMicroLocationProbabilityForLocalization");
    v6 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v5, "objectForKey:", v6);
    v7 = (void *)objc_claimAutoreleasedReturnValue();
    if (v7 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
      objc_msgSend(v7, "doubleValue");
    else
      objc_msgSend(&unk_2511ECD98, "doubleValue");
    v9 = v8;

    v10 = (__int128 *)*a1;
    v11 = (__int128 *)a1[1];
    v12 = 0.0;
    if ((__int128 *)*a1 != v11)
    {
      do
      {
        v13 = *((double *)v10 + 2);
        if (v13 < 0.0)
        {
          if (onceToken_MicroLocation_Default != -1)
            dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_21);
          v14 = logObject_MicroLocation_Default;
          if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT))
          {
            v15 = *((_QWORD *)v10 + 2);
            *(_DWORD *)buf = 134349056;
            *(_QWORD *)v29 = v15;
            _os_log_impl(&dword_2419D9000, v14, OS_LOG_TYPE_DEFAULT, "#Warning microlocation probability should be non-negative %{public}f", buf, 0xCu);
          }
          v13 = *((double *)v10 + 2);
        }
        v12 = v12 + v13;
        v10 += 2;
      }
      while (v10 != v11);
    }
    if (fabs(v12 + -1.0) > nextafter(1.0, INFINITY) + -1.0)
    {
      if (onceToken_MicroLocation_Default != -1)
        dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_21);
      v16 = logObject_MicroLocation_Default;
      if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 134349056;
        *(double *)v29 = v12;
        _os_log_impl(&dword_2419D9000, v16, OS_LOG_TYPE_DEFAULT, "#Warning microlocation probability vector should sum to 1.0 %{public}f", buf, 0xCu);
      }
    }
    v18 = (__int128 *)*a1;
    v17 = (__int128 *)a1[1];
    if ((__int128 *)*a1 == v17)
    {
      v21 = 0.0;
      v19 = (__int128 *)*a1;
    }
    else
    {
      v19 = (__int128 *)*a1;
      while (1)
      {
        v20 = *((double *)v19 + 2);
        if (v20 < v9)
          break;
        v19 += 2;
        if (v19 == v17)
        {
          v21 = 0.0;
          goto LABEL_45;
        }
      }
      v21 = v20 + 0.0;
    }
    if (v19 != v17)
    {
      v24 = v19 + 2;
      if (v19 + 2 != v17)
      {
        do
        {
          v25 = *((double *)v24 + 2);
          if (v25 >= v9)
          {
            v26 = *v24;
            *(__int128 *)((char *)v19 + 12) = *(__int128 *)((char *)v24 + 12);
            *v19 = v26;
            v19 += 2;
          }
          else
          {
            v21 = v25 + v21;
          }
          v24 += 2;
        }
        while (v24 != v17);
        v18 = (__int128 *)*a1;
        v17 = (__int128 *)a1[1];
      }
    }
    if (v19 != v17)
    {
      v17 = v19;
      a1[1] = (uint64_t)v19;
    }
LABEL_45:
    if (v18 != v17)
    {
      v27 = v21 / (double)(unint64_t)(((char *)v17 - (char *)v18) >> 5);
      do
      {
        *((double *)v18 + 2) = v27 + *((double *)v18 + 2);
        v18 += 2;
      }
      while (v18 != v17);
    }
  }
  else
  {
    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_21);
    v22 = logObject_MicroLocation_Default;
    if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 68289282;
      *(_DWORD *)v29 = 0;
      *(_WORD *)&v29[4] = 2082;
      *(_QWORD *)&v29[6] = "";
      v30 = 2050;
      v31 = a2;
      _os_log_impl(&dword_2419D9000, v22, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"invalid\", \"localizer type\":%{public}lu}", buf, 0x1Cu);
    }
    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_21);
    v23 = logObject_MicroLocation_Default;
    if (os_signpost_enabled((os_log_t)logObject_MicroLocation_Default))
    {
      *(_DWORD *)buf = 68289282;
      *(_DWORD *)v29 = 0;
      *(_WORD *)&v29[4] = 2082;
      *(_QWORD *)&v29[6] = "";
      v30 = 2050;
      v31 = a2;
      _os_signpost_emit_with_name_impl(&dword_2419D9000, v23, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "invalid", "{\"msg%{public}.0s\":\"invalid\", \"localizer type\":%{public}lu}", buf, 0x1Cu);
    }
  }
}

void sub_241A1ECF8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void ___ZL45_CLLogObjectForCategory_MicroLocation_Defaultv_block_invoke_15()
{
  os_log_t v0;
  void *v1;

  v0 = os_log_create("com.apple.MicroLocation", "MicroLocation");
  v1 = (void *)logObject_MicroLocation_Default;
  logObject_MicroLocation_Default = (uint64_t)v0;

}

void ULSettings::convert<NSArray<NSNumber *> * {__strong},std::vector<double>>(void *a1@<X0>, uint64_t a2@<X8>)
{
  id v3;
  id v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t i;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  _QWORD *v11;
  _QWORD *v12;
  _QWORD *v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t v16;
  unint64_t v17;
  char *v18;
  char *v19;
  uint64_t v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  _BYTE v25[128];
  uint64_t v26;

  v26 = *MEMORY[0x24BDAC8D0];
  v3 = a1;
  *(_QWORD *)(a2 + 8) = 0;
  *(_QWORD *)(a2 + 16) = 0;
  *(_QWORD *)a2 = 0;
  std::vector<double>::reserve((void **)a2, objc_msgSend(v3, "count"));
  v23 = 0u;
  v24 = 0u;
  v21 = 0u;
  v22 = 0u;
  v4 = v3;
  v5 = objc_msgSend(v4, "countByEnumeratingWithState:objects:count:", &v21, v25, 16);
  if (v5)
  {
    v6 = *(_QWORD *)v22;
    do
    {
      for (i = 0; i != v5; ++i)
      {
        if (*(_QWORD *)v22 != v6)
          objc_enumerationMutation(v4);
        objc_msgSend(*(id *)(*((_QWORD *)&v21 + 1) + 8 * i), "doubleValue", (_QWORD)v21);
        v9 = v8;
        v11 = *(_QWORD **)(a2 + 8);
        v10 = *(_QWORD *)(a2 + 16);
        if ((unint64_t)v11 >= v10)
        {
          v13 = *(_QWORD **)a2;
          v14 = ((uint64_t)v11 - *(_QWORD *)a2) >> 3;
          v15 = v14 + 1;
          if ((unint64_t)(v14 + 1) >> 61)
            std::vector<CLMicroLocationProto::ConfidenceReason>::__throw_length_error[abi:ne180100]();
          v16 = v10 - (_QWORD)v13;
          if (v16 >> 2 > v15)
            v15 = v16 >> 2;
          if ((unint64_t)v16 >= 0x7FFFFFFFFFFFFFF8)
            v17 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v17 = v15;
          if (v17)
          {
            v18 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<CLMicroLocationWiFiChannelHistogram>>(a2 + 16, v17);
            v13 = *(_QWORD **)a2;
            v11 = *(_QWORD **)(a2 + 8);
          }
          else
          {
            v18 = 0;
          }
          v19 = &v18[8 * v14];
          *(_QWORD *)v19 = v9;
          v12 = v19 + 8;
          while (v11 != v13)
          {
            v20 = *--v11;
            *((_QWORD *)v19 - 1) = v20;
            v19 -= 8;
          }
          *(_QWORD *)a2 = v19;
          *(_QWORD *)(a2 + 8) = v12;
          *(_QWORD *)(a2 + 16) = &v18[8 * v17];
          if (v13)
            operator delete(v13);
        }
        else
        {
          *v11 = v8;
          v12 = v11 + 1;
        }
        *(_QWORD *)(a2 + 8) = v12;
      }
      v5 = objc_msgSend(v4, "countByEnumeratingWithState:objects:count:", &v21, v25, 16);
    }
    while (v5);
  }

}

{
  id v3;
  id v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t i;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  _QWORD *v11;
  _QWORD *v12;
  _QWORD *v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t v16;
  unint64_t v17;
  char *v18;
  char *v19;
  uint64_t v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  _BYTE v25[128];
  uint64_t v26;

  v26 = *MEMORY[0x24BDAC8D0];
  v3 = a1;
  *(_QWORD *)(a2 + 8) = 0;
  *(_QWORD *)(a2 + 16) = 0;
  *(_QWORD *)a2 = 0;
  std::vector<double>::reserve((void **)a2, objc_msgSend(v3, "count"));
  v23 = 0u;
  v24 = 0u;
  v21 = 0u;
  v22 = 0u;
  v4 = v3;
  v5 = objc_msgSend(v4, "countByEnumeratingWithState:objects:count:", &v21, v25, 16);
  if (v5)
  {
    v6 = *(_QWORD *)v22;
    do
    {
      for (i = 0; i != v5; ++i)
      {
        if (*(_QWORD *)v22 != v6)
          objc_enumerationMutation(v4);
        objc_msgSend(*(id *)(*((_QWORD *)&v21 + 1) + 8 * i), "doubleValue", (_QWORD)v21);
        v9 = v8;
        v11 = *(_QWORD **)(a2 + 8);
        v10 = *(_QWORD *)(a2 + 16);
        if ((unint64_t)v11 >= v10)
        {
          v13 = *(_QWORD **)a2;
          v14 = ((uint64_t)v11 - *(_QWORD *)a2) >> 3;
          v15 = v14 + 1;
          if ((unint64_t)(v14 + 1) >> 61)
            std::vector<CLMicroLocationProto::ConfidenceReason>::__throw_length_error[abi:ne180100]();
          v16 = v10 - (_QWORD)v13;
          if (v16 >> 2 > v15)
            v15 = v16 >> 2;
          if ((unint64_t)v16 >= 0x7FFFFFFFFFFFFFF8)
            v17 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v17 = v15;
          if (v17)
          {
            v18 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<CLMicroLocationWiFiChannelHistogram>>(a2 + 16, v17);
            v13 = *(_QWORD **)a2;
            v11 = *(_QWORD **)(a2 + 8);
          }
          else
          {
            v18 = 0;
          }
          v19 = &v18[8 * v14];
          *(_QWORD *)v19 = v9;
          v12 = v19 + 8;
          while (v11 != v13)
          {
            v20 = *--v11;
            *((_QWORD *)v19 - 1) = v20;
            v19 -= 8;
          }
          *(_QWORD *)a2 = v19;
          *(_QWORD *)(a2 + 8) = v12;
          *(_QWORD *)(a2 + 16) = &v18[8 * v17];
          if (v13)
            operator delete(v13);
        }
        else
        {
          *v11 = v8;
          v12 = v11 + 1;
        }
        *(_QWORD *)(a2 + 8) = v12;
      }
      v5 = objc_msgSend(v4, "countByEnumeratingWithState:objects:count:", &v21, v25, 16);
    }
    while (v5);
  }

}

{
  id v3;
  id v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t i;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  _QWORD *v11;
  _QWORD *v12;
  _QWORD *v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t v16;
  unint64_t v17;
  char *v18;
  char *v19;
  uint64_t v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  _BYTE v25[128];
  uint64_t v26;

  v26 = *MEMORY[0x24BDAC8D0];
  v3 = a1;
  *(_QWORD *)(a2 + 8) = 0;
  *(_QWORD *)(a2 + 16) = 0;
  *(_QWORD *)a2 = 0;
  std::vector<double>::reserve((void **)a2, objc_msgSend(v3, "count"));
  v23 = 0u;
  v24 = 0u;
  v21 = 0u;
  v22 = 0u;
  v4 = v3;
  v5 = objc_msgSend(v4, "countByEnumeratingWithState:objects:count:", &v21, v25, 16);
  if (v5)
  {
    v6 = *(_QWORD *)v22;
    do
    {
      for (i = 0; i != v5; ++i)
      {
        if (*(_QWORD *)v22 != v6)
          objc_enumerationMutation(v4);
        objc_msgSend(*(id *)(*((_QWORD *)&v21 + 1) + 8 * i), "doubleValue", (_QWORD)v21);
        v9 = v8;
        v11 = *(_QWORD **)(a2 + 8);
        v10 = *(_QWORD *)(a2 + 16);
        if ((unint64_t)v11 >= v10)
        {
          v13 = *(_QWORD **)a2;
          v14 = ((uint64_t)v11 - *(_QWORD *)a2) >> 3;
          v15 = v14 + 1;
          if ((unint64_t)(v14 + 1) >> 61)
            std::vector<CLMicroLocationProto::ConfidenceReason>::__throw_length_error[abi:ne180100]();
          v16 = v10 - (_QWORD)v13;
          if (v16 >> 2 > v15)
            v15 = v16 >> 2;
          if ((unint64_t)v16 >= 0x7FFFFFFFFFFFFFF8)
            v17 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v17 = v15;
          if (v17)
          {
            v18 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<CLMicroLocationWiFiChannelHistogram>>(a2 + 16, v17);
            v13 = *(_QWORD **)a2;
            v11 = *(_QWORD **)(a2 + 8);
          }
          else
          {
            v18 = 0;
          }
          v19 = &v18[8 * v14];
          *(_QWORD *)v19 = v9;
          v12 = v19 + 8;
          while (v11 != v13)
          {
            v20 = *--v11;
            *((_QWORD *)v19 - 1) = v20;
            v19 -= 8;
          }
          *(_QWORD *)a2 = v19;
          *(_QWORD *)(a2 + 8) = v12;
          *(_QWORD *)(a2 + 16) = &v18[8 * v17];
          if (v13)
            operator delete(v13);
        }
        else
        {
          *v11 = v8;
          v12 = v11 + 1;
        }
        *(_QWORD *)(a2 + 8) = v12;
      }
      v5 = objc_msgSend(v4, "countByEnumeratingWithState:objects:count:", &v21, v25, 16);
    }
    while (v5);
  }

}

{
  id v3;
  id v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t i;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  _QWORD *v11;
  _QWORD *v12;
  _QWORD *v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t v16;
  unint64_t v17;
  char *v18;
  char *v19;
  uint64_t v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  _BYTE v25[128];
  uint64_t v26;

  v26 = *MEMORY[0x24BDAC8D0];
  v3 = a1;
  *(_QWORD *)(a2 + 8) = 0;
  *(_QWORD *)(a2 + 16) = 0;
  *(_QWORD *)a2 = 0;
  std::vector<double>::reserve((void **)a2, objc_msgSend(v3, "count"));
  v23 = 0u;
  v24 = 0u;
  v21 = 0u;
  v22 = 0u;
  v4 = v3;
  v5 = objc_msgSend(v4, "countByEnumeratingWithState:objects:count:", &v21, v25, 16);
  if (v5)
  {
    v6 = *(_QWORD *)v22;
    do
    {
      for (i = 0; i != v5; ++i)
      {
        if (*(_QWORD *)v22 != v6)
          objc_enumerationMutation(v4);
        objc_msgSend(*(id *)(*((_QWORD *)&v21 + 1) + 8 * i), "doubleValue", (_QWORD)v21);
        v9 = v8;
        v11 = *(_QWORD **)(a2 + 8);
        v10 = *(_QWORD *)(a2 + 16);
        if ((unint64_t)v11 >= v10)
        {
          v13 = *(_QWORD **)a2;
          v14 = ((uint64_t)v11 - *(_QWORD *)a2) >> 3;
          v15 = v14 + 1;
          if ((unint64_t)(v14 + 1) >> 61)
            std::vector<CLMicroLocationProto::ConfidenceReason>::__throw_length_error[abi:ne180100]();
          v16 = v10 - (_QWORD)v13;
          if (v16 >> 2 > v15)
            v15 = v16 >> 2;
          if ((unint64_t)v16 >= 0x7FFFFFFFFFFFFFF8)
            v17 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v17 = v15;
          if (v17)
          {
            v18 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<CLMicroLocationWiFiChannelHistogram>>(a2 + 16, v17);
            v13 = *(_QWORD **)a2;
            v11 = *(_QWORD **)(a2 + 8);
          }
          else
          {
            v18 = 0;
          }
          v19 = &v18[8 * v14];
          *(_QWORD *)v19 = v9;
          v12 = v19 + 8;
          while (v11 != v13)
          {
            v20 = *--v11;
            *((_QWORD *)v19 - 1) = v20;
            v19 -= 8;
          }
          *(_QWORD *)a2 = v19;
          *(_QWORD *)(a2 + 8) = v12;
          *(_QWORD *)(a2 + 16) = &v18[8 * v17];
          if (v13)
            operator delete(v13);
        }
        else
        {
          *v11 = v8;
          v12 = v11 + 1;
        }
        *(_QWORD *)(a2 + 8) = v12;
      }
      v5 = objc_msgSend(v4, "countByEnumeratingWithState:objects:count:", &v21, v25, 16);
    }
    while (v5);
  }

}

void sub_241A1EF48(_Unwind_Exception *a1)
{
  void *v1;
  uint64_t v2;
  void *v3;
  void *v5;

  v5 = *(void **)v2;
  if (*(_QWORD *)v2)
  {
    *(_QWORD *)(v2 + 8) = v5;
    operator delete(v5);
  }

  _Unwind_Resume(a1);
}

void ULSettings::convert<std::initializer_list<double>,std::vector<double>>(uint64_t *a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
  _QWORD *v6;
  _QWORD *v7;
  uint64_t *v8;
  uint64_t v9;
  _QWORD *v10;
  _QWORD *v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  unint64_t v15;
  char *v16;
  char *v17;
  uint64_t v18;

  *(_QWORD *)a3 = 0;
  *(_QWORD *)(a3 + 8) = 0;
  *(_QWORD *)(a3 + 16) = 0;
  std::vector<double>::reserve((void **)a3, a2);
  if (a2)
  {
    v6 = (_QWORD *)(a3 + 16);
    v7 = *(_QWORD **)(a3 + 8);
    v8 = &a1[a2];
    do
    {
      v9 = *a1;
      if ((unint64_t)v7 >= *v6)
      {
        v11 = *(_QWORD **)a3;
        v12 = ((uint64_t)v7 - *(_QWORD *)a3) >> 3;
        v13 = v12 + 1;
        if ((unint64_t)(v12 + 1) >> 61)
          std::vector<CLMicroLocationProto::ConfidenceReason>::__throw_length_error[abi:ne180100]();
        v14 = *v6 - (_QWORD)v11;
        if (v14 >> 2 > v13)
          v13 = v14 >> 2;
        if ((unint64_t)v14 >= 0x7FFFFFFFFFFFFFF8)
          v15 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v15 = v13;
        if (v15)
        {
          v16 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<CLMicroLocationWiFiChannelHistogram>>(a3 + 16, v15);
          v11 = *(_QWORD **)a3;
          v7 = *(_QWORD **)(a3 + 8);
        }
        else
        {
          v16 = 0;
        }
        v17 = &v16[8 * v12];
        *(_QWORD *)v17 = v9;
        v10 = v17 + 8;
        while (v7 != v11)
        {
          v18 = *--v7;
          *((_QWORD *)v17 - 1) = v18;
          v17 -= 8;
        }
        *(_QWORD *)a3 = v17;
        *(_QWORD *)(a3 + 8) = v10;
        *(_QWORD *)(a3 + 16) = &v16[8 * v15];
        if (v11)
          operator delete(v11);
      }
      else
      {
        *v7 = v9;
        v10 = v7 + 1;
      }
      *(_QWORD *)(a3 + 8) = v10;
      ++a1;
      v7 = v10;
    }
    while (a1 != v8);
  }
}

{
  _QWORD *v6;
  _QWORD *v7;
  uint64_t *v8;
  uint64_t v9;
  _QWORD *v10;
  _QWORD *v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  unint64_t v15;
  char *v16;
  char *v17;
  uint64_t v18;

  *(_QWORD *)a3 = 0;
  *(_QWORD *)(a3 + 8) = 0;
  *(_QWORD *)(a3 + 16) = 0;
  std::vector<double>::reserve((void **)a3, a2);
  if (a2)
  {
    v6 = (_QWORD *)(a3 + 16);
    v7 = *(_QWORD **)(a3 + 8);
    v8 = &a1[a2];
    do
    {
      v9 = *a1;
      if ((unint64_t)v7 >= *v6)
      {
        v11 = *(_QWORD **)a3;
        v12 = ((uint64_t)v7 - *(_QWORD *)a3) >> 3;
        v13 = v12 + 1;
        if ((unint64_t)(v12 + 1) >> 61)
          std::vector<CLMicroLocationProto::ConfidenceReason>::__throw_length_error[abi:ne180100]();
        v14 = *v6 - (_QWORD)v11;
        if (v14 >> 2 > v13)
          v13 = v14 >> 2;
        if ((unint64_t)v14 >= 0x7FFFFFFFFFFFFFF8)
          v15 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v15 = v13;
        if (v15)
        {
          v16 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<CLMicroLocationWiFiChannelHistogram>>(a3 + 16, v15);
          v11 = *(_QWORD **)a3;
          v7 = *(_QWORD **)(a3 + 8);
        }
        else
        {
          v16 = 0;
        }
        v17 = &v16[8 * v12];
        *(_QWORD *)v17 = v9;
        v10 = v17 + 8;
        while (v7 != v11)
        {
          v18 = *--v7;
          *((_QWORD *)v17 - 1) = v18;
          v17 -= 8;
        }
        *(_QWORD *)a3 = v17;
        *(_QWORD *)(a3 + 8) = v10;
        *(_QWORD *)(a3 + 16) = &v16[8 * v15];
        if (v11)
          operator delete(v11);
      }
      else
      {
        *v7 = v9;
        v10 = v7 + 1;
      }
      *(_QWORD *)(a3 + 8) = v10;
      ++a1;
      v7 = v10;
    }
    while (a1 != v8);
  }
}

{
  _QWORD *v6;
  _QWORD *v7;
  uint64_t *v8;
  uint64_t v9;
  _QWORD *v10;
  _QWORD *v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  unint64_t v15;
  char *v16;
  char *v17;
  uint64_t v18;

  *(_QWORD *)a3 = 0;
  *(_QWORD *)(a3 + 8) = 0;
  *(_QWORD *)(a3 + 16) = 0;
  std::vector<double>::reserve((void **)a3, a2);
  if (a2)
  {
    v6 = (_QWORD *)(a3 + 16);
    v7 = *(_QWORD **)(a3 + 8);
    v8 = &a1[a2];
    do
    {
      v9 = *a1;
      if ((unint64_t)v7 >= *v6)
      {
        v11 = *(_QWORD **)a3;
        v12 = ((uint64_t)v7 - *(_QWORD *)a3) >> 3;
        v13 = v12 + 1;
        if ((unint64_t)(v12 + 1) >> 61)
          std::vector<CLMicroLocationProto::ConfidenceReason>::__throw_length_error[abi:ne180100]();
        v14 = *v6 - (_QWORD)v11;
        if (v14 >> 2 > v13)
          v13 = v14 >> 2;
        if ((unint64_t)v14 >= 0x7FFFFFFFFFFFFFF8)
          v15 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v15 = v13;
        if (v15)
        {
          v16 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<CLMicroLocationWiFiChannelHistogram>>(a3 + 16, v15);
          v11 = *(_QWORD **)a3;
          v7 = *(_QWORD **)(a3 + 8);
        }
        else
        {
          v16 = 0;
        }
        v17 = &v16[8 * v12];
        *(_QWORD *)v17 = v9;
        v10 = v17 + 8;
        while (v7 != v11)
        {
          v18 = *--v7;
          *((_QWORD *)v17 - 1) = v18;
          v17 -= 8;
        }
        *(_QWORD *)a3 = v17;
        *(_QWORD *)(a3 + 8) = v10;
        *(_QWORD *)(a3 + 16) = &v16[8 * v15];
        if (v11)
          operator delete(v11);
      }
      else
      {
        *v7 = v9;
        v10 = v7 + 1;
      }
      *(_QWORD *)(a3 + 8) = v10;
      ++a1;
      v7 = v10;
    }
    while (a1 != v8);
  }
}

{
  _QWORD *v6;
  _QWORD *v7;
  uint64_t *v8;
  uint64_t v9;
  _QWORD *v10;
  _QWORD *v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  unint64_t v15;
  char *v16;
  char *v17;
  uint64_t v18;

  *(_QWORD *)a3 = 0;
  *(_QWORD *)(a3 + 8) = 0;
  *(_QWORD *)(a3 + 16) = 0;
  std::vector<double>::reserve((void **)a3, a2);
  if (a2)
  {
    v6 = (_QWORD *)(a3 + 16);
    v7 = *(_QWORD **)(a3 + 8);
    v8 = &a1[a2];
    do
    {
      v9 = *a1;
      if ((unint64_t)v7 >= *v6)
      {
        v11 = *(_QWORD **)a3;
        v12 = ((uint64_t)v7 - *(_QWORD *)a3) >> 3;
        v13 = v12 + 1;
        if ((unint64_t)(v12 + 1) >> 61)
          std::vector<CLMicroLocationProto::ConfidenceReason>::__throw_length_error[abi:ne180100]();
        v14 = *v6 - (_QWORD)v11;
        if (v14 >> 2 > v13)
          v13 = v14 >> 2;
        if ((unint64_t)v14 >= 0x7FFFFFFFFFFFFFF8)
          v15 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v15 = v13;
        if (v15)
        {
          v16 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<CLMicroLocationWiFiChannelHistogram>>(a3 + 16, v15);
          v11 = *(_QWORD **)a3;
          v7 = *(_QWORD **)(a3 + 8);
        }
        else
        {
          v16 = 0;
        }
        v17 = &v16[8 * v12];
        *(_QWORD *)v17 = v9;
        v10 = v17 + 8;
        while (v7 != v11)
        {
          v18 = *--v7;
          *((_QWORD *)v17 - 1) = v18;
          v17 -= 8;
        }
        *(_QWORD *)a3 = v17;
        *(_QWORD *)(a3 + 8) = v10;
        *(_QWORD *)(a3 + 16) = &v16[8 * v15];
        if (v11)
          operator delete(v11);
      }
      else
      {
        *v7 = v9;
        v10 = v7 + 1;
      }
      *(_QWORD *)(a3 + 8) = v10;
      ++a1;
      v7 = v10;
    }
    while (a1 != v8);
  }
}

void sub_241A1F0B4(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void std::vector<double>::reserve(void **a1, unint64_t a2)
{
  uint64_t v3;
  _BYTE *v4;
  int64_t v5;
  char *v6;
  char *v7;
  uint64_t v8;
  char *v9;
  char *v10;
  char *v11;
  char *v12;
  uint64_t v13;

  v4 = a1[2];
  v3 = (uint64_t)(a1 + 2);
  if (a2 > (v4 - (_BYTE *)*a1) >> 3)
  {
    if (a2 >> 61)
      std::vector<CLMicroLocationProto::ConfidenceReason>::__throw_length_error[abi:ne180100]();
    v5 = (_BYTE *)a1[1] - (_BYTE *)*a1;
    v6 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<CLMicroLocationWiFiChannelHistogram>>(v3, a2);
    v7 = &v6[v5 & 0xFFFFFFFFFFFFFFF8];
    v9 = &v6[8 * v8];
    v10 = (char *)*a1;
    v11 = (char *)a1[1];
    v12 = v7;
    if (v11 != *a1)
    {
      v12 = v7;
      do
      {
        v13 = *((_QWORD *)v11 - 1);
        v11 -= 8;
        *((_QWORD *)v12 - 1) = v13;
        v12 -= 8;
      }
      while (v11 != v10);
    }
    *a1 = v12;
    a1[1] = v7;
    a1[2] = v9;
    if (v10)
      operator delete(v10);
  }
}

uint64_t CLMicroLocationAlgorithms::details::createFingerprintDistanceFunction(CLMicroLocationAlgorithms::FingerprintDistanceFunctionType,NSDictionary *,CLMicroLocationFingerprintDistanceFunction::EnabledTechnologiesConfig const&,CLMicroLocationAlgorithms::details::FingerprintDistanceFunctionUsage,std::optional<CLMicroLocationAnchorAppearanceMap> const&)::$_2::~$_2(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 88))
    std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>>>::~__hash_table(a1 + 32);

  return a1;
}

uint64_t std::__optional_copy_base<CLMicroLocationAnchorAppearanceMap,false>::__optional_copy_base[abi:ne180100](uint64_t a1, uint64_t a2)
{
  *(_BYTE *)a1 = 0;
  *(_BYTE *)(a1 + 56) = 0;
  if (*(_BYTE *)(a2 + 56))
  {
    std::unordered_map<boost::uuids::uuid,CLMicroLocationAnchorAppearance>::unordered_map(a1, a2);
    *(_OWORD *)(a1 + 40) = *(_OWORD *)(a2 + 40);
    *(_BYTE *)(a1 + 56) = 1;
  }
  return a1;
}

void sub_241A1F1F8(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (*(_BYTE *)(v1 + 56))
    std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>>>::~__hash_table(v1);
  _Unwind_Resume(exception_object);
}

uint64_t std::__function::__func<CLMicroLocationAlgorithms::details::createFingerprintDistanceFunction(CLMicroLocationAlgorithms::FingerprintDistanceFunctionType,NSDictionary *,CLMicroLocationFingerprintDistanceFunction::EnabledTechnologiesConfig const&,CLMicroLocationAlgorithms::details::FingerprintDistanceFunctionUsage,std::optional<CLMicroLocationAnchorAppearanceMap> const&)::$_0,std::allocator<CLMicroLocationAlgorithms::details::createFingerprintDistanceFunction(CLMicroLocationAlgorithms::FingerprintDistanceFunctionType,NSDictionary *,CLMicroLocationFingerprintDistanceFunction::EnabledTechnologiesConfig const&,CLMicroLocationAlgorithms::details::FingerprintDistanceFunctionUsage,std::optional<CLMicroLocationAnchorAppearanceMap> const&)::$_0>,double ()(CLMicroLocationFingerprint const&,CLMicroLocationFingerprint const&)>::~__func(uint64_t a1)
{
  *(_QWORD *)a1 = &off_2511D38E0;
  if (*(_BYTE *)(a1 + 80))
    std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>>>::~__hash_table(a1 + 24);
  return a1;
}

void std::__function::__func<CLMicroLocationAlgorithms::details::createFingerprintDistanceFunction(CLMicroLocationAlgorithms::FingerprintDistanceFunctionType,NSDictionary *,CLMicroLocationFingerprintDistanceFunction::EnabledTechnologiesConfig const&,CLMicroLocationAlgorithms::details::FingerprintDistanceFunctionUsage,std::optional<CLMicroLocationAnchorAppearanceMap> const&)::$_0,std::allocator<CLMicroLocationAlgorithms::details::createFingerprintDistanceFunction(CLMicroLocationAlgorithms::FingerprintDistanceFunctionType,NSDictionary *,CLMicroLocationFingerprintDistanceFunction::EnabledTechnologiesConfig const&,CLMicroLocationAlgorithms::details::FingerprintDistanceFunctionUsage,std::optional<CLMicroLocationAnchorAppearanceMap> const&)::$_0>,double ()(CLMicroLocationFingerprint const&,CLMicroLocationFingerprint const&)>::~__func(uint64_t a1)
{
  *(_QWORD *)a1 = &off_2511D38E0;
  if (*(_BYTE *)(a1 + 80))
    std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>>>::~__hash_table(a1 + 24);
  JUMPOUT(0x2426A04D4);
}

char *std::__function::__func<CLMicroLocationAlgorithms::details::createFingerprintDistanceFunction(CLMicroLocationAlgorithms::FingerprintDistanceFunctionType,NSDictionary *,CLMicroLocationFingerprintDistanceFunction::EnabledTechnologiesConfig const&,CLMicroLocationAlgorithms::details::FingerprintDistanceFunctionUsage,std::optional<CLMicroLocationAnchorAppearanceMap> const&)::$_0,std::allocator<CLMicroLocationAlgorithms::details::createFingerprintDistanceFunction(CLMicroLocationAlgorithms::FingerprintDistanceFunctionType,NSDictionary *,CLMicroLocationFingerprintDistanceFunction::EnabledTechnologiesConfig const&,CLMicroLocationAlgorithms::details::FingerprintDistanceFunctionUsage,std::optional<CLMicroLocationAnchorAppearanceMap> const&)::$_0>,double ()(CLMicroLocationFingerprint const&,CLMicroLocationFingerprint const&)>::__clone(uint64_t a1)
{
  char *v2;

  v2 = (char *)operator new(0x58uLL);
  *(_QWORD *)v2 = &off_2511D38E0;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  std::__optional_copy_base<CLMicroLocationAnchorAppearanceMap,false>::__optional_copy_base[abi:ne180100]((uint64_t)(v2 + 24), a1 + 24);
  return v2;
}

void sub_241A1F2E8(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<CLMicroLocationAlgorithms::details::createFingerprintDistanceFunction(CLMicroLocationAlgorithms::FingerprintDistanceFunctionType,NSDictionary *,CLMicroLocationFingerprintDistanceFunction::EnabledTechnologiesConfig const&,CLMicroLocationAlgorithms::details::FingerprintDistanceFunctionUsage,std::optional<CLMicroLocationAnchorAppearanceMap> const&)::$_0,std::allocator<CLMicroLocationAlgorithms::details::createFingerprintDistanceFunction(CLMicroLocationAlgorithms::FingerprintDistanceFunctionType,NSDictionary *,CLMicroLocationFingerprintDistanceFunction::EnabledTechnologiesConfig const&,CLMicroLocationAlgorithms::details::FingerprintDistanceFunctionUsage,std::optional<CLMicroLocationAnchorAppearanceMap> const&)::$_0>,double ()(CLMicroLocationFingerprint const&,CLMicroLocationFingerprint const&)>::__clone(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)a2 = &off_2511D38E0;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(a1 + 8);
  return std::__optional_copy_base<CLMicroLocationAnchorAppearanceMap,false>::__optional_copy_base[abi:ne180100](a2 + 24, a1 + 24);
}

uint64_t std::__function::__func<CLMicroLocationAlgorithms::details::createFingerprintDistanceFunction(CLMicroLocationAlgorithms::FingerprintDistanceFunctionType,NSDictionary *,CLMicroLocationFingerprintDistanceFunction::EnabledTechnologiesConfig const&,CLMicroLocationAlgorithms::details::FingerprintDistanceFunctionUsage,std::optional<CLMicroLocationAnchorAppearanceMap> const&)::$_0,std::allocator<CLMicroLocationAlgorithms::details::createFingerprintDistanceFunction(CLMicroLocationAlgorithms::FingerprintDistanceFunctionType,NSDictionary *,CLMicroLocationFingerprintDistanceFunction::EnabledTechnologiesConfig const&,CLMicroLocationAlgorithms::details::FingerprintDistanceFunctionUsage,std::optional<CLMicroLocationAnchorAppearanceMap> const&)::$_0>,double ()(CLMicroLocationFingerprint const&,CLMicroLocationFingerprint const&)>::destroy(uint64_t result)
{
  if (*(_BYTE *)(result + 80))
    return std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>>>::~__hash_table(result + 24);
  return result;
}

void std::__function::__func<CLMicroLocationAlgorithms::details::createFingerprintDistanceFunction(CLMicroLocationAlgorithms::FingerprintDistanceFunctionType,NSDictionary *,CLMicroLocationFingerprintDistanceFunction::EnabledTechnologiesConfig const&,CLMicroLocationAlgorithms::details::FingerprintDistanceFunctionUsage,std::optional<CLMicroLocationAnchorAppearanceMap> const&)::$_0,std::allocator<CLMicroLocationAlgorithms::details::createFingerprintDistanceFunction(CLMicroLocationAlgorithms::FingerprintDistanceFunctionType,NSDictionary *,CLMicroLocationFingerprintDistanceFunction::EnabledTechnologiesConfig const&,CLMicroLocationAlgorithms::details::FingerprintDistanceFunctionUsage,std::optional<CLMicroLocationAnchorAppearanceMap> const&)::$_0>,double ()(CLMicroLocationFingerprint const&,CLMicroLocationFingerprint const&)>::destroy_deallocate(_BYTE *__p)
{
  if (__p[80])
    std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>>>::~__hash_table((uint64_t)(__p + 24));
  operator delete(__p);
}

double std::__function::__func<CLMicroLocationAlgorithms::details::createFingerprintDistanceFunction(CLMicroLocationAlgorithms::FingerprintDistanceFunctionType,NSDictionary *,CLMicroLocationFingerprintDistanceFunction::EnabledTechnologiesConfig const&,CLMicroLocationAlgorithms::details::FingerprintDistanceFunctionUsage,std::optional<CLMicroLocationAnchorAppearanceMap> const&)::$_0,std::allocator<CLMicroLocationAlgorithms::details::createFingerprintDistanceFunction(CLMicroLocationAlgorithms::FingerprintDistanceFunctionType,NSDictionary *,CLMicroLocationFingerprintDistanceFunction::EnabledTechnologiesConfig const&,CLMicroLocationAlgorithms::details::FingerprintDistanceFunctionUsage,std::optional<CLMicroLocationAnchorAppearanceMap> const&)::$_0>,double ()(CLMicroLocationFingerprint const&,CLMicroLocationFingerprint const&)>::operator()(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return CLMicroLocationFingerprintDistanceFunction::euclideanLike(a2, a3, (uint64_t *)(a1 + 8), a1 + 24);
}

uint64_t std::__function::__func<CLMicroLocationAlgorithms::details::createFingerprintDistanceFunction(CLMicroLocationAlgorithms::FingerprintDistanceFunctionType,NSDictionary *,CLMicroLocationFingerprintDistanceFunction::EnabledTechnologiesConfig const&,CLMicroLocationAlgorithms::details::FingerprintDistanceFunctionUsage,std::optional<CLMicroLocationAnchorAppearanceMap> const&)::$_0,std::allocator<CLMicroLocationAlgorithms::details::createFingerprintDistanceFunction(CLMicroLocationAlgorithms::FingerprintDistanceFunctionType,NSDictionary *,CLMicroLocationFingerprintDistanceFunction::EnabledTechnologiesConfig const&,CLMicroLocationAlgorithms::details::FingerprintDistanceFunctionUsage,std::optional<CLMicroLocationAnchorAppearanceMap> const&)::$_0>,double ()(CLMicroLocationFingerprint const&,CLMicroLocationFingerprint const&)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<CLMicroLocationAlgorithms::details::createFingerprintDistanceFunction(CLMicroLocationAlgorithms::FingerprintDistanceFunctionType,NSDictionary *,CLMicroLocationFingerprintDistanceFunction::EnabledTechnologiesConfig const&,CLMicroLocationAlgorithms::details::FingerprintDistanceFunctionUsage,std::optional<CLMicroLocationAnchorAppearanceMap> const&)::$_0,std::allocator<CLMicroLocationAlgorithms::details::createFingerprintDistanceFunction(CLMicroLocationAlgorithms::FingerprintDistanceFunctionType,NSDictionary *,CLMicroLocationFingerprintDistanceFunction::EnabledTechnologiesConfig const&,CLMicroLocationAlgorithms::details::FingerprintDistanceFunctionUsage,std::optional<CLMicroLocationAnchorAppearanceMap> const&)::$_0>,double ()(CLMicroLocationFingerprint const&,CLMicroLocationFingerprint const&)>::target_type()
{
}

uint64_t std::__function::__func<CLMicroLocationAlgorithms::details::createFingerprintDistanceFunction(CLMicroLocationAlgorithms::FingerprintDistanceFunctionType,NSDictionary *,CLMicroLocationFingerprintDistanceFunction::EnabledTechnologiesConfig const&,CLMicroLocationAlgorithms::details::FingerprintDistanceFunctionUsage,std::optional<CLMicroLocationAnchorAppearanceMap> const&)::$_1,std::allocator<CLMicroLocationAlgorithms::details::createFingerprintDistanceFunction(CLMicroLocationAlgorithms::FingerprintDistanceFunctionType,NSDictionary *,CLMicroLocationFingerprintDistanceFunction::EnabledTechnologiesConfig const&,CLMicroLocationAlgorithms::details::FingerprintDistanceFunctionUsage,std::optional<CLMicroLocationAnchorAppearanceMap> const&)::$_1>,double ()(CLMicroLocationFingerprint const&,CLMicroLocationFingerprint const&)>::~__func(uint64_t a1)
{
  *(_QWORD *)a1 = &off_2511D3970;
  if (*(_BYTE *)(a1 + 80))
    std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>>>::~__hash_table(a1 + 24);
  return a1;
}

void std::__function::__func<CLMicroLocationAlgorithms::details::createFingerprintDistanceFunction(CLMicroLocationAlgorithms::FingerprintDistanceFunctionType,NSDictionary *,CLMicroLocationFingerprintDistanceFunction::EnabledTechnologiesConfig const&,CLMicroLocationAlgorithms::details::FingerprintDistanceFunctionUsage,std::optional<CLMicroLocationAnchorAppearanceMap> const&)::$_1,std::allocator<CLMicroLocationAlgorithms::details::createFingerprintDistanceFunction(CLMicroLocationAlgorithms::FingerprintDistanceFunctionType,NSDictionary *,CLMicroLocationFingerprintDistanceFunction::EnabledTechnologiesConfig const&,CLMicroLocationAlgorithms::details::FingerprintDistanceFunctionUsage,std::optional<CLMicroLocationAnchorAppearanceMap> const&)::$_1>,double ()(CLMicroLocationFingerprint const&,CLMicroLocationFingerprint const&)>::~__func(uint64_t a1)
{
  *(_QWORD *)a1 = &off_2511D3970;
  if (*(_BYTE *)(a1 + 80))
    std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>>>::~__hash_table(a1 + 24);
  JUMPOUT(0x2426A04D4);
}

char *std::__function::__func<CLMicroLocationAlgorithms::details::createFingerprintDistanceFunction(CLMicroLocationAlgorithms::FingerprintDistanceFunctionType,NSDictionary *,CLMicroLocationFingerprintDistanceFunction::EnabledTechnologiesConfig const&,CLMicroLocationAlgorithms::details::FingerprintDistanceFunctionUsage,std::optional<CLMicroLocationAnchorAppearanceMap> const&)::$_1,std::allocator<CLMicroLocationAlgorithms::details::createFingerprintDistanceFunction(CLMicroLocationAlgorithms::FingerprintDistanceFunctionType,NSDictionary *,CLMicroLocationFingerprintDistanceFunction::EnabledTechnologiesConfig const&,CLMicroLocationAlgorithms::details::FingerprintDistanceFunctionUsage,std::optional<CLMicroLocationAnchorAppearanceMap> const&)::$_1>,double ()(CLMicroLocationFingerprint const&,CLMicroLocationFingerprint const&)>::__clone(uint64_t a1)
{
  char *v2;

  v2 = (char *)operator new(0x58uLL);
  *(_QWORD *)v2 = &off_2511D3970;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  std::__optional_copy_base<CLMicroLocationAnchorAppearanceMap,false>::__optional_copy_base[abi:ne180100]((uint64_t)(v2 + 24), a1 + 24);
  return v2;
}

void sub_241A1F498(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<CLMicroLocationAlgorithms::details::createFingerprintDistanceFunction(CLMicroLocationAlgorithms::FingerprintDistanceFunctionType,NSDictionary *,CLMicroLocationFingerprintDistanceFunction::EnabledTechnologiesConfig const&,CLMicroLocationAlgorithms::details::FingerprintDistanceFunctionUsage,std::optional<CLMicroLocationAnchorAppearanceMap> const&)::$_1,std::allocator<CLMicroLocationAlgorithms::details::createFingerprintDistanceFunction(CLMicroLocationAlgorithms::FingerprintDistanceFunctionType,NSDictionary *,CLMicroLocationFingerprintDistanceFunction::EnabledTechnologiesConfig const&,CLMicroLocationAlgorithms::details::FingerprintDistanceFunctionUsage,std::optional<CLMicroLocationAnchorAppearanceMap> const&)::$_1>,double ()(CLMicroLocationFingerprint const&,CLMicroLocationFingerprint const&)>::__clone(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)a2 = &off_2511D3970;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(a1 + 8);
  return std::__optional_copy_base<CLMicroLocationAnchorAppearanceMap,false>::__optional_copy_base[abi:ne180100](a2 + 24, a1 + 24);
}

uint64_t std::__function::__func<CLMicroLocationAlgorithms::details::createFingerprintDistanceFunction(CLMicroLocationAlgorithms::FingerprintDistanceFunctionType,NSDictionary *,CLMicroLocationFingerprintDistanceFunction::EnabledTechnologiesConfig const&,CLMicroLocationAlgorithms::details::FingerprintDistanceFunctionUsage,std::optional<CLMicroLocationAnchorAppearanceMap> const&)::$_1,std::allocator<CLMicroLocationAlgorithms::details::createFingerprintDistanceFunction(CLMicroLocationAlgorithms::FingerprintDistanceFunctionType,NSDictionary *,CLMicroLocationFingerprintDistanceFunction::EnabledTechnologiesConfig const&,CLMicroLocationAlgorithms::details::FingerprintDistanceFunctionUsage,std::optional<CLMicroLocationAnchorAppearanceMap> const&)::$_1>,double ()(CLMicroLocationFingerprint const&,CLMicroLocationFingerprint const&)>::destroy(uint64_t result)
{
  if (*(_BYTE *)(result + 80))
    return std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>>>::~__hash_table(result + 24);
  return result;
}

void std::__function::__func<CLMicroLocationAlgorithms::details::createFingerprintDistanceFunction(CLMicroLocationAlgorithms::FingerprintDistanceFunctionType,NSDictionary *,CLMicroLocationFingerprintDistanceFunction::EnabledTechnologiesConfig const&,CLMicroLocationAlgorithms::details::FingerprintDistanceFunctionUsage,std::optional<CLMicroLocationAnchorAppearanceMap> const&)::$_1,std::allocator<CLMicroLocationAlgorithms::details::createFingerprintDistanceFunction(CLMicroLocationAlgorithms::FingerprintDistanceFunctionType,NSDictionary *,CLMicroLocationFingerprintDistanceFunction::EnabledTechnologiesConfig const&,CLMicroLocationAlgorithms::details::FingerprintDistanceFunctionUsage,std::optional<CLMicroLocationAnchorAppearanceMap> const&)::$_1>,double ()(CLMicroLocationFingerprint const&,CLMicroLocationFingerprint const&)>::destroy_deallocate(_BYTE *__p)
{
  if (__p[80])
    std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>>>::~__hash_table((uint64_t)(__p + 24));
  operator delete(__p);
}

double std::__function::__func<CLMicroLocationAlgorithms::details::createFingerprintDistanceFunction(CLMicroLocationAlgorithms::FingerprintDistanceFunctionType,NSDictionary *,CLMicroLocationFingerprintDistanceFunction::EnabledTechnologiesConfig const&,CLMicroLocationAlgorithms::details::FingerprintDistanceFunctionUsage,std::optional<CLMicroLocationAnchorAppearanceMap> const&)::$_1,std::allocator<CLMicroLocationAlgorithms::details::createFingerprintDistanceFunction(CLMicroLocationAlgorithms::FingerprintDistanceFunctionType,NSDictionary *,CLMicroLocationFingerprintDistanceFunction::EnabledTechnologiesConfig const&,CLMicroLocationAlgorithms::details::FingerprintDistanceFunctionUsage,std::optional<CLMicroLocationAnchorAppearanceMap> const&)::$_1>,double ()(CLMicroLocationFingerprint const&,CLMicroLocationFingerprint const&)>::operator()(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return CLMicroLocationFingerprintDistanceFunction::jaccardLike(a2, a3, a1 + 8, a1 + 24);
}

uint64_t std::__function::__func<CLMicroLocationAlgorithms::details::createFingerprintDistanceFunction(CLMicroLocationAlgorithms::FingerprintDistanceFunctionType,NSDictionary *,CLMicroLocationFingerprintDistanceFunction::EnabledTechnologiesConfig const&,CLMicroLocationAlgorithms::details::FingerprintDistanceFunctionUsage,std::optional<CLMicroLocationAnchorAppearanceMap> const&)::$_1,std::allocator<CLMicroLocationAlgorithms::details::createFingerprintDistanceFunction(CLMicroLocationAlgorithms::FingerprintDistanceFunctionType,NSDictionary *,CLMicroLocationFingerprintDistanceFunction::EnabledTechnologiesConfig const&,CLMicroLocationAlgorithms::details::FingerprintDistanceFunctionUsage,std::optional<CLMicroLocationAnchorAppearanceMap> const&)::$_1>,double ()(CLMicroLocationFingerprint const&,CLMicroLocationFingerprint const&)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<CLMicroLocationAlgorithms::details::createFingerprintDistanceFunction(CLMicroLocationAlgorithms::FingerprintDistanceFunctionType,NSDictionary *,CLMicroLocationFingerprintDistanceFunction::EnabledTechnologiesConfig const&,CLMicroLocationAlgorithms::details::FingerprintDistanceFunctionUsage,std::optional<CLMicroLocationAnchorAppearanceMap> const&)::$_1,std::allocator<CLMicroLocationAlgorithms::details::createFingerprintDistanceFunction(CLMicroLocationAlgorithms::FingerprintDistanceFunctionType,NSDictionary *,CLMicroLocationFingerprintDistanceFunction::EnabledTechnologiesConfig const&,CLMicroLocationAlgorithms::details::FingerprintDistanceFunctionUsage,std::optional<CLMicroLocationAnchorAppearanceMap> const&)::$_1>,double ()(CLMicroLocationFingerprint const&,CLMicroLocationFingerprint const&)>::target_type()
{
}

uint64_t std::__function::__func<CLMicroLocationAlgorithms::details::createFingerprintDistanceFunction(CLMicroLocationAlgorithms::FingerprintDistanceFunctionType,NSDictionary *,CLMicroLocationFingerprintDistanceFunction::EnabledTechnologiesConfig const&,CLMicroLocationAlgorithms::details::FingerprintDistanceFunctionUsage,std::optional<CLMicroLocationAnchorAppearanceMap> const&)::$_2,std::allocator<CLMicroLocationAlgorithms::details::createFingerprintDistanceFunction(CLMicroLocationAlgorithms::FingerprintDistanceFunctionType,NSDictionary *,CLMicroLocationFingerprintDistanceFunction::EnabledTechnologiesConfig const&,CLMicroLocationAlgorithms::details::FingerprintDistanceFunctionUsage,std::optional<CLMicroLocationAnchorAppearanceMap> const&)::$_2>,double ()(CLMicroLocationFingerprint const&,CLMicroLocationFingerprint const&)>::~__func(uint64_t a1)
{
  *(_QWORD *)a1 = &off_2511D39F0;
  if (*(_BYTE *)(a1 + 96))
    std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>>>::~__hash_table(a1 + 40);

  return a1;
}

void std::__function::__func<CLMicroLocationAlgorithms::details::createFingerprintDistanceFunction(CLMicroLocationAlgorithms::FingerprintDistanceFunctionType,NSDictionary *,CLMicroLocationFingerprintDistanceFunction::EnabledTechnologiesConfig const&,CLMicroLocationAlgorithms::details::FingerprintDistanceFunctionUsage,std::optional<CLMicroLocationAnchorAppearanceMap> const&)::$_2,std::allocator<CLMicroLocationAlgorithms::details::createFingerprintDistanceFunction(CLMicroLocationAlgorithms::FingerprintDistanceFunctionType,NSDictionary *,CLMicroLocationFingerprintDistanceFunction::EnabledTechnologiesConfig const&,CLMicroLocationAlgorithms::details::FingerprintDistanceFunctionUsage,std::optional<CLMicroLocationAnchorAppearanceMap> const&)::$_2>,double ()(CLMicroLocationFingerprint const&,CLMicroLocationFingerprint const&)>::~__func(uint64_t a1)
{
  *(_QWORD *)a1 = &off_2511D39F0;
  if (*(_BYTE *)(a1 + 96))
    std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>>>::~__hash_table(a1 + 40);

  JUMPOUT(0x2426A04D4);
}

_QWORD *std::__function::__func<CLMicroLocationAlgorithms::details::createFingerprintDistanceFunction(CLMicroLocationAlgorithms::FingerprintDistanceFunctionType,NSDictionary *,CLMicroLocationFingerprintDistanceFunction::EnabledTechnologiesConfig const&,CLMicroLocationAlgorithms::details::FingerprintDistanceFunctionUsage,std::optional<CLMicroLocationAnchorAppearanceMap> const&)::$_2,std::allocator<CLMicroLocationAlgorithms::details::createFingerprintDistanceFunction(CLMicroLocationAlgorithms::FingerprintDistanceFunctionType,NSDictionary *,CLMicroLocationFingerprintDistanceFunction::EnabledTechnologiesConfig const&,CLMicroLocationAlgorithms::details::FingerprintDistanceFunctionUsage,std::optional<CLMicroLocationAnchorAppearanceMap> const&)::$_2>,double ()(CLMicroLocationFingerprint const&,CLMicroLocationFingerprint const&)>::__clone(uint64_t a1)
{
  uint64_t v1;
  _QWORD *v2;

  v1 = a1 + 8;
  v2 = operator new(0x68uLL);
  *v2 = &off_2511D39F0;
  std::__compressed_pair_elem<CLMicroLocationAlgorithms::details::createFingerprintDistanceFunction(CLMicroLocationAlgorithms::FingerprintDistanceFunctionType,NSDictionary *,CLMicroLocationFingerprintDistanceFunction::EnabledTechnologiesConfig const&,CLMicroLocationAlgorithms::details::FingerprintDistanceFunctionUsage,std::optional<CLMicroLocationAnchorAppearanceMap> const&)::$_2,0,false>::__compressed_pair_elem[abi:ne180100]<CLMicroLocationAlgorithms::details::createFingerprintDistanceFunction(CLMicroLocationAlgorithms::FingerprintDistanceFunctionType,NSDictionary *,CLMicroLocationFingerprintDistanceFunction::EnabledTechnologiesConfig const&,CLMicroLocationAlgorithms::details::FingerprintDistanceFunctionUsage,std::optional<CLMicroLocationAnchorAppearanceMap> const&)::$_2 const&,0ul>((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_241A1F65C(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<CLMicroLocationAlgorithms::details::createFingerprintDistanceFunction(CLMicroLocationAlgorithms::FingerprintDistanceFunctionType,NSDictionary *,CLMicroLocationFingerprintDistanceFunction::EnabledTechnologiesConfig const&,CLMicroLocationAlgorithms::details::FingerprintDistanceFunctionUsage,std::optional<CLMicroLocationAnchorAppearanceMap> const&)::$_2,std::allocator<CLMicroLocationAlgorithms::details::createFingerprintDistanceFunction(CLMicroLocationAlgorithms::FingerprintDistanceFunctionType,NSDictionary *,CLMicroLocationFingerprintDistanceFunction::EnabledTechnologiesConfig const&,CLMicroLocationAlgorithms::details::FingerprintDistanceFunctionUsage,std::optional<CLMicroLocationAnchorAppearanceMap> const&)::$_2>,double ()(CLMicroLocationFingerprint const&,CLMicroLocationFingerprint const&)>::__clone(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_2511D39F0;
  return std::__compressed_pair_elem<CLMicroLocationAlgorithms::details::createFingerprintDistanceFunction(CLMicroLocationAlgorithms::FingerprintDistanceFunctionType,NSDictionary *,CLMicroLocationFingerprintDistanceFunction::EnabledTechnologiesConfig const&,CLMicroLocationAlgorithms::details::FingerprintDistanceFunctionUsage,std::optional<CLMicroLocationAnchorAppearanceMap> const&)::$_2,0,false>::__compressed_pair_elem[abi:ne180100]<CLMicroLocationAlgorithms::details::createFingerprintDistanceFunction(CLMicroLocationAlgorithms::FingerprintDistanceFunctionType,NSDictionary *,CLMicroLocationFingerprintDistanceFunction::EnabledTechnologiesConfig const&,CLMicroLocationAlgorithms::details::FingerprintDistanceFunctionUsage,std::optional<CLMicroLocationAnchorAppearanceMap> const&)::$_2 const&,0ul>((uint64_t)(a2 + 1), a1 + 8);
}

void std::__function::__func<CLMicroLocationAlgorithms::details::createFingerprintDistanceFunction(CLMicroLocationAlgorithms::FingerprintDistanceFunctionType,NSDictionary *,CLMicroLocationFingerprintDistanceFunction::EnabledTechnologiesConfig const&,CLMicroLocationAlgorithms::details::FingerprintDistanceFunctionUsage,std::optional<CLMicroLocationAnchorAppearanceMap> const&)::$_2,std::allocator<CLMicroLocationAlgorithms::details::createFingerprintDistanceFunction(CLMicroLocationAlgorithms::FingerprintDistanceFunctionType,NSDictionary *,CLMicroLocationFingerprintDistanceFunction::EnabledTechnologiesConfig const&,CLMicroLocationAlgorithms::details::FingerprintDistanceFunctionUsage,std::optional<CLMicroLocationAnchorAppearanceMap> const&)::$_2>,double ()(CLMicroLocationFingerprint const&,CLMicroLocationFingerprint const&)>::destroy(uint64_t a1)
{
  std::__function::__alloc_func<CLMicroLocationAlgorithms::details::createFingerprintDistanceFunction(CLMicroLocationAlgorithms::FingerprintDistanceFunctionType,NSDictionary *,CLMicroLocationFingerprintDistanceFunction::EnabledTechnologiesConfig const&,CLMicroLocationAlgorithms::details::FingerprintDistanceFunctionUsage,std::optional<CLMicroLocationAnchorAppearanceMap> const&)::$_2,std::allocator<CLMicroLocationAlgorithms::details::createFingerprintDistanceFunction(CLMicroLocationAlgorithms::FingerprintDistanceFunctionType,NSDictionary *,CLMicroLocationFingerprintDistanceFunction::EnabledTechnologiesConfig const&,CLMicroLocationAlgorithms::details::FingerprintDistanceFunctionUsage,std::optional<CLMicroLocationAnchorAppearanceMap> const&)::$_2>,double ()(CLMicroLocationFingerprint const&,CLMicroLocationFingerprint const&)>::destroy[abi:ne180100](a1 + 8);
}

void std::__function::__func<CLMicroLocationAlgorithms::details::createFingerprintDistanceFunction(CLMicroLocationAlgorithms::FingerprintDistanceFunctionType,NSDictionary *,CLMicroLocationFingerprintDistanceFunction::EnabledTechnologiesConfig const&,CLMicroLocationAlgorithms::details::FingerprintDistanceFunctionUsage,std::optional<CLMicroLocationAnchorAppearanceMap> const&)::$_2,std::allocator<CLMicroLocationAlgorithms::details::createFingerprintDistanceFunction(CLMicroLocationAlgorithms::FingerprintDistanceFunctionType,NSDictionary *,CLMicroLocationFingerprintDistanceFunction::EnabledTechnologiesConfig const&,CLMicroLocationAlgorithms::details::FingerprintDistanceFunctionUsage,std::optional<CLMicroLocationAnchorAppearanceMap> const&)::$_2>,double ()(CLMicroLocationFingerprint const&,CLMicroLocationFingerprint const&)>::destroy_deallocate(void *a1)
{
  std::__function::__alloc_func<CLMicroLocationAlgorithms::details::createFingerprintDistanceFunction(CLMicroLocationAlgorithms::FingerprintDistanceFunctionType,NSDictionary *,CLMicroLocationFingerprintDistanceFunction::EnabledTechnologiesConfig const&,CLMicroLocationAlgorithms::details::FingerprintDistanceFunctionUsage,std::optional<CLMicroLocationAnchorAppearanceMap> const&)::$_2,std::allocator<CLMicroLocationAlgorithms::details::createFingerprintDistanceFunction(CLMicroLocationAlgorithms::FingerprintDistanceFunctionType,NSDictionary *,CLMicroLocationFingerprintDistanceFunction::EnabledTechnologiesConfig const&,CLMicroLocationAlgorithms::details::FingerprintDistanceFunctionUsage,std::optional<CLMicroLocationAnchorAppearanceMap> const&)::$_2>,double ()(CLMicroLocationFingerprint const&,CLMicroLocationFingerprint const&)>::destroy[abi:ne180100]((uint64_t)a1 + 8);
  operator delete(a1);
}

uint64_t std::__function::__func<CLMicroLocationAlgorithms::details::createFingerprintDistanceFunction(CLMicroLocationAlgorithms::FingerprintDistanceFunctionType,NSDictionary *,CLMicroLocationFingerprintDistanceFunction::EnabledTechnologiesConfig const&,CLMicroLocationAlgorithms::details::FingerprintDistanceFunctionUsage,std::optional<CLMicroLocationAnchorAppearanceMap> const&)::$_2,std::allocator<CLMicroLocationAlgorithms::details::createFingerprintDistanceFunction(CLMicroLocationAlgorithms::FingerprintDistanceFunctionType,NSDictionary *,CLMicroLocationFingerprintDistanceFunction::EnabledTechnologiesConfig const&,CLMicroLocationAlgorithms::details::FingerprintDistanceFunctionUsage,std::optional<CLMicroLocationAnchorAppearanceMap> const&)::$_2>,double ()(CLMicroLocationFingerprint const&,CLMicroLocationFingerprint const&)>::operator()(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t *v6;

  v6 = (uint64_t *)(a1 + 8);
  objc_msgSend(*(id *)(a1 + 24), "doubleValue");
  objc_msgSend(*(id *)(a1 + 32), "doubleValue");
  return CLMicroLocationFingerprintDistanceFunction::combinedEuclideanJaccard(a2, a3, v6, a1 + 40);
}

uint64_t std::__function::__func<CLMicroLocationAlgorithms::details::createFingerprintDistanceFunction(CLMicroLocationAlgorithms::FingerprintDistanceFunctionType,NSDictionary *,CLMicroLocationFingerprintDistanceFunction::EnabledTechnologiesConfig const&,CLMicroLocationAlgorithms::details::FingerprintDistanceFunctionUsage,std::optional<CLMicroLocationAnchorAppearanceMap> const&)::$_2,std::allocator<CLMicroLocationAlgorithms::details::createFingerprintDistanceFunction(CLMicroLocationAlgorithms::FingerprintDistanceFunctionType,NSDictionary *,CLMicroLocationFingerprintDistanceFunction::EnabledTechnologiesConfig const&,CLMicroLocationAlgorithms::details::FingerprintDistanceFunctionUsage,std::optional<CLMicroLocationAnchorAppearanceMap> const&)::$_2>,double ()(CLMicroLocationFingerprint const&,CLMicroLocationFingerprint const&)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<CLMicroLocationAlgorithms::details::createFingerprintDistanceFunction(CLMicroLocationAlgorithms::FingerprintDistanceFunctionType,NSDictionary *,CLMicroLocationFingerprintDistanceFunction::EnabledTechnologiesConfig const&,CLMicroLocationAlgorithms::details::FingerprintDistanceFunctionUsage,std::optional<CLMicroLocationAnchorAppearanceMap> const&)::$_2,std::allocator<CLMicroLocationAlgorithms::details::createFingerprintDistanceFunction(CLMicroLocationAlgorithms::FingerprintDistanceFunctionType,NSDictionary *,CLMicroLocationFingerprintDistanceFunction::EnabledTechnologiesConfig const&,CLMicroLocationAlgorithms::details::FingerprintDistanceFunctionUsage,std::optional<CLMicroLocationAnchorAppearanceMap> const&)::$_2>,double ()(CLMicroLocationFingerprint const&,CLMicroLocationFingerprint const&)>::target_type()
{
}

uint64_t std::__compressed_pair_elem<CLMicroLocationAlgorithms::details::createFingerprintDistanceFunction(CLMicroLocationAlgorithms::FingerprintDistanceFunctionType,NSDictionary *,CLMicroLocationFingerprintDistanceFunction::EnabledTechnologiesConfig const&,CLMicroLocationAlgorithms::details::FingerprintDistanceFunctionUsage,std::optional<CLMicroLocationAnchorAppearanceMap> const&)::$_2,0,false>::__compressed_pair_elem[abi:ne180100]<CLMicroLocationAlgorithms::details::createFingerprintDistanceFunction(CLMicroLocationAlgorithms::FingerprintDistanceFunctionType,NSDictionary *,CLMicroLocationFingerprintDistanceFunction::EnabledTechnologiesConfig const&,CLMicroLocationAlgorithms::details::FingerprintDistanceFunctionUsage,std::optional<CLMicroLocationAnchorAppearanceMap> const&)::$_2 const&,0ul>(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(_QWORD *)(a1 + 16) = *(id *)(a2 + 16);
  *(_QWORD *)(a1 + 24) = *(id *)(a2 + 24);
  std::__optional_copy_base<CLMicroLocationAnchorAppearanceMap,false>::__optional_copy_base[abi:ne180100](a1 + 32, a2 + 32);
  return a1;
}

void sub_241A1F7B8(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Unwind_Resume(a1);
}

void std::__function::__alloc_func<CLMicroLocationAlgorithms::details::createFingerprintDistanceFunction(CLMicroLocationAlgorithms::FingerprintDistanceFunctionType,NSDictionary *,CLMicroLocationFingerprintDistanceFunction::EnabledTechnologiesConfig const&,CLMicroLocationAlgorithms::details::FingerprintDistanceFunctionUsage,std::optional<CLMicroLocationAnchorAppearanceMap> const&)::$_2,std::allocator<CLMicroLocationAlgorithms::details::createFingerprintDistanceFunction(CLMicroLocationAlgorithms::FingerprintDistanceFunctionType,NSDictionary *,CLMicroLocationFingerprintDistanceFunction::EnabledTechnologiesConfig const&,CLMicroLocationAlgorithms::details::FingerprintDistanceFunctionUsage,std::optional<CLMicroLocationAnchorAppearanceMap> const&)::$_2>,double ()(CLMicroLocationFingerprint const&,CLMicroLocationFingerprint const&)>::destroy[abi:ne180100](uint64_t a1)
{
  if (*(_BYTE *)(a1 + 88))
    std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>>>::~__hash_table(a1 + 32);

}

void CLMicroLocationAlgorithms::details::createPerSourceWeights(CLMicroLocationAlgorithms::details *this@<X0>, NSString *a2@<X1>, _QWORD *a3@<X8>)
{
  NSString *v6;
  void *v7;
  void *v8;
  NSObject *v9;
  NSObject *v10;
  uint64_t v11;
  NSObject *v12;
  CLMicroLocationAlgorithms::details *v13;
  uint8_t buf[4];
  int v15;
  __int16 v16;
  const char *v17;
  __int16 v18;
  uint64_t v19;
  __int16 v20;
  const char *v21;
  __int16 v22;
  const char *v23;
  uint64_t v24;

  v24 = *MEMORY[0x24BDAC8D0];
  v13 = this;
  v6 = a2;
  -[NSString objectForKeyedSubscript:](v6, "objectForKeyedSubscript:", v13);
  v7 = (void *)objc_claimAutoreleasedReturnValue();
  v8 = v7;
  if (!v7)
  {
    _CLLogObjectForCategory_MicroLocation_Default();
    v9 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 68289795;
      v15 = 0;
      v16 = 2082;
      v17 = "";
      v18 = 2082;
      v19 = -[CLMicroLocationAlgorithms::details UTF8String](objc_retainAutorelease(v13), "UTF8String");
      v20 = 2082;
      v21 = "assert";
      v22 = 2081;
      v23 = "weightsDict";
      _os_log_impl(&dword_2419D9000, v9, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Couldn't find key: \", \"key\":%{public, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x30u);
    }

    _CLLogObjectForCategory_MicroLocation_Default();
    v10 = objc_claimAutoreleasedReturnValue();
    if (os_signpost_enabled(v10))
    {
      v11 = -[CLMicroLocationAlgorithms::details UTF8String](objc_retainAutorelease(v13), "UTF8String");
      *(_DWORD *)buf = 68289795;
      v15 = 0;
      v16 = 2082;
      v17 = "";
      v18 = 2082;
      v19 = v11;
      v20 = 2082;
      v21 = "assert";
      v22 = 2081;
      v23 = "weightsDict";
      _os_signpost_emit_with_name_impl(&dword_2419D9000, v10, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Couldn't find key: ", "{\"msg%{public}.0s\":\"Couldn't find key: \", \"key\":%{public, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x30u);
    }

    _CLLogObjectForCategory_MicroLocation_Default();
    v12 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_INFO))
      CLMicroLocationAlgorithms::details::createPerSourceWeights(-[CLMicroLocationAlgorithms::details UTF8String](objc_retainAutorelease(v13), "UTF8String"), (uint64_t)buf, v12);

    abort_report_np();
    __break(1u);
  }
  CLMicroLocationUtils::PerSourceWeights<double>::fromConfiguration(v7, a3);

}

void sub_241A1FA4C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, id a12)
{
  void *v12;

  _Unwind_Resume(a1);
}

uint64_t CLMicroLocationAlgorithms::details::createWeightedEuclideanJaccardDistanceFunction(NSDictionary *,CLMicroLocationFingerprintDistanceFunction::EnabledTechnologiesConfig const&,CLMicroLocationAlgorithms::details::FingerprintDistanceFunctionUsage const&,std::optional<CLMicroLocationAnchorAppearanceMap> const&)::$_0::~$_0(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 232))
    std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>>>::~__hash_table(a1 + 176);

  return a1;
}

void CLMicroLocationUtils::PerSourceWeights<double>::fromConfiguration(void *a1@<X0>, _QWORD *a2@<X8>)
{
  void *v3;
  void *v4;
  void *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  NSObject *v11;
  NSObject *v12;
  NSObject *v13;
  NSObject *v14;
  NSObject *v15;
  NSObject *v16;
  NSObject *v17;
  id v18;
  uint8_t buf[4];
  int v20;
  __int16 v21;
  const char *v22;
  __int16 v23;
  const char *v24;
  __int16 v25;
  const char *v26;
  uint64_t v27;

  v27 = *MEMORY[0x24BDAC8D0];
  v18 = a1;
  objc_msgSend(v18, "objectForKeyedSubscript:", CFSTR("wifi"));
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v18, "objectForKeyedSubscript:", CFSTR("ble"));
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v18, "objectForKeyedSubscript:", CFSTR("uwb"));
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  if (!v3 || (objc_opt_class(), (objc_opt_isKindOfClass() & 1) == 0))
  {
    _CLLogObjectForCategory_MicroLocation_Default();
    v11 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 68289539;
      v20 = 0;
      v21 = 2082;
      v22 = "";
      v23 = 2082;
      v24 = "assert";
      v25 = 2081;
      v26 = "wifiValue && [wifiValue isKindOfClass:[NSNumber class]]";
      _os_log_impl(&dword_2419D9000, v11, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"No wifi provided in dictionary\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x26u);
    }

    _CLLogObjectForCategory_MicroLocation_Default();
    v12 = objc_claimAutoreleasedReturnValue();
    if (os_signpost_enabled(v12))
    {
      *(_DWORD *)buf = 68289539;
      v20 = 0;
      v21 = 2082;
      v22 = "";
      v23 = 2082;
      v24 = "assert";
      v25 = 2081;
      v26 = "wifiValue && [wifiValue isKindOfClass:[NSNumber class]]";
      _os_signpost_emit_with_name_impl(&dword_2419D9000, v12, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "No wifi provided in dictionary", "{\"msg%{public}.0s\":\"No wifi provided in dictionary\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x26u);
    }

    _CLLogObjectForCategory_MicroLocation_Default();
    v13 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 68289539;
      v20 = 0;
      v21 = 2082;
      v22 = "";
      v23 = 2082;
      v24 = "assert";
      v25 = 2081;
      v26 = "wifiValue && [wifiValue isKindOfClass:[NSNumber class]]";
      _os_log_impl(&dword_2419D9000, v13, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"No wifi provided in dictionary\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x26u);
    }
LABEL_28:

    abort_report_np();
    __break(1u);
  }
  if (!v4 || (objc_opt_class(), (objc_opt_isKindOfClass() & 1) == 0))
  {
    _CLLogObjectForCategory_MicroLocation_Default();
    v14 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 68289539;
      v20 = 0;
      v21 = 2082;
      v22 = "";
      v23 = 2082;
      v24 = "assert";
      v25 = 2081;
      v26 = "bleValue && [bleValue isKindOfClass:[NSNumber class]]";
      _os_log_impl(&dword_2419D9000, v14, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"No ble provided in dictionary\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x26u);
    }

    _CLLogObjectForCategory_MicroLocation_Default();
    v15 = objc_claimAutoreleasedReturnValue();
    if (os_signpost_enabled(v15))
    {
      *(_DWORD *)buf = 68289539;
      v20 = 0;
      v21 = 2082;
      v22 = "";
      v23 = 2082;
      v24 = "assert";
      v25 = 2081;
      v26 = "bleValue && [bleValue isKindOfClass:[NSNumber class]]";
      _os_signpost_emit_with_name_impl(&dword_2419D9000, v15, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "No ble provided in dictionary", "{\"msg%{public}.0s\":\"No ble provided in dictionary\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x26u);
    }

    _CLLogObjectForCategory_MicroLocation_Default();
    v13 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 68289539;
      v20 = 0;
      v21 = 2082;
      v22 = "";
      v23 = 2082;
      v24 = "assert";
      v25 = 2081;
      v26 = "bleValue && [bleValue isKindOfClass:[NSNumber class]]";
      _os_log_impl(&dword_2419D9000, v13, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"No ble provided in dictionary\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x26u);
    }
    goto LABEL_28;
  }
  if (!v5 || (objc_opt_class(), (objc_opt_isKindOfClass() & 1) == 0))
  {
    _CLLogObjectForCategory_MicroLocation_Default();
    v16 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v16, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 68289539;
      v20 = 0;
      v21 = 2082;
      v22 = "";
      v23 = 2082;
      v24 = "assert";
      v25 = 2081;
      v26 = "uwbValue && [uwbValue isKindOfClass:[NSNumber class]]";
      _os_log_impl(&dword_2419D9000, v16, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"No uwb provided in dictionary\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x26u);
    }

    _CLLogObjectForCategory_MicroLocation_Default();
    v17 = objc_claimAutoreleasedReturnValue();
    if (os_signpost_enabled(v17))
    {
      *(_DWORD *)buf = 68289539;
      v20 = 0;
      v21 = 2082;
      v22 = "";
      v23 = 2082;
      v24 = "assert";
      v25 = 2081;
      v26 = "uwbValue && [uwbValue isKindOfClass:[NSNumber class]]";
      _os_signpost_emit_with_name_impl(&dword_2419D9000, v17, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "No uwb provided in dictionary", "{\"msg%{public}.0s\":\"No uwb provided in dictionary\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x26u);
    }

    _CLLogObjectForCategory_MicroLocation_Default();
    v13 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 68289539;
      v20 = 0;
      v21 = 2082;
      v22 = "";
      v23 = 2082;
      v24 = "assert";
      v25 = 2081;
      v26 = "uwbValue && [uwbValue isKindOfClass:[NSNumber class]]";
      _os_log_impl(&dword_2419D9000, v13, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"No uwb provided in dictionary\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x26u);
    }
    goto LABEL_28;
  }
  objc_msgSend(v3, "doubleValue");
  v7 = v6;
  objc_msgSend(v4, "doubleValue");
  v9 = v8;
  objc_msgSend(v5, "doubleValue");
  *a2 = &off_2511D3368;
  a2[1] = v7;
  a2[2] = v9;
  a2[3] = v10;

}

void sub_241A20164(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, id a12)
{
  void *v12;
  void *v13;

  _Unwind_Resume(a1);
}

void CLMicroLocationUtils::PerSourceWeights<BOOL>::fromConfiguration(void *a1@<X0>, uint64_t a2@<X8>)
{
  void *v3;
  void *v4;
  void *v5;
  double v6;
  double v7;
  double v8;
  double v9;
  double v10;
  NSObject *v11;
  NSObject *v12;
  NSObject *v13;
  NSObject *v14;
  NSObject *v15;
  NSObject *v16;
  NSObject *v17;
  id v18;
  uint8_t buf[4];
  int v20;
  __int16 v21;
  const char *v22;
  __int16 v23;
  const char *v24;
  __int16 v25;
  const char *v26;
  uint64_t v27;

  v27 = *MEMORY[0x24BDAC8D0];
  v18 = a1;
  objc_msgSend(v18, "objectForKeyedSubscript:", CFSTR("wifi"));
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v18, "objectForKeyedSubscript:", CFSTR("ble"));
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v18, "objectForKeyedSubscript:", CFSTR("uwb"));
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  if (!v3 || (objc_opt_class(), (objc_opt_isKindOfClass() & 1) == 0))
  {
    _CLLogObjectForCategory_MicroLocation_Default();
    v11 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 68289539;
      v20 = 0;
      v21 = 2082;
      v22 = "";
      v23 = 2082;
      v24 = "assert";
      v25 = 2081;
      v26 = "wifiValue && [wifiValue isKindOfClass:[NSNumber class]]";
      _os_log_impl(&dword_2419D9000, v11, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"No wifi provided in dictionary\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x26u);
    }

    _CLLogObjectForCategory_MicroLocation_Default();
    v12 = objc_claimAutoreleasedReturnValue();
    if (os_signpost_enabled(v12))
    {
      *(_DWORD *)buf = 68289539;
      v20 = 0;
      v21 = 2082;
      v22 = "";
      v23 = 2082;
      v24 = "assert";
      v25 = 2081;
      v26 = "wifiValue && [wifiValue isKindOfClass:[NSNumber class]]";
      _os_signpost_emit_with_name_impl(&dword_2419D9000, v12, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "No wifi provided in dictionary", "{\"msg%{public}.0s\":\"No wifi provided in dictionary\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x26u);
    }

    _CLLogObjectForCategory_MicroLocation_Default();
    v13 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 68289539;
      v20 = 0;
      v21 = 2082;
      v22 = "";
      v23 = 2082;
      v24 = "assert";
      v25 = 2081;
      v26 = "wifiValue && [wifiValue isKindOfClass:[NSNumber class]]";
      _os_log_impl(&dword_2419D9000, v13, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"No wifi provided in dictionary\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x26u);
    }
LABEL_28:

    abort_report_np();
    __break(1u);
  }
  if (!v4 || (objc_opt_class(), (objc_opt_isKindOfClass() & 1) == 0))
  {
    _CLLogObjectForCategory_MicroLocation_Default();
    v14 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 68289539;
      v20 = 0;
      v21 = 2082;
      v22 = "";
      v23 = 2082;
      v24 = "assert";
      v25 = 2081;
      v26 = "bleValue && [bleValue isKindOfClass:[NSNumber class]]";
      _os_log_impl(&dword_2419D9000, v14, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"No ble provided in dictionary\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x26u);
    }

    _CLLogObjectForCategory_MicroLocation_Default();
    v15 = objc_claimAutoreleasedReturnValue();
    if (os_signpost_enabled(v15))
    {
      *(_DWORD *)buf = 68289539;
      v20 = 0;
      v21 = 2082;
      v22 = "";
      v23 = 2082;
      v24 = "assert";
      v25 = 2081;
      v26 = "bleValue && [bleValue isKindOfClass:[NSNumber class]]";
      _os_signpost_emit_with_name_impl(&dword_2419D9000, v15, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "No ble provided in dictionary", "{\"msg%{public}.0s\":\"No ble provided in dictionary\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x26u);
    }

    _CLLogObjectForCategory_MicroLocation_Default();
    v13 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 68289539;
      v20 = 0;
      v21 = 2082;
      v22 = "";
      v23 = 2082;
      v24 = "assert";
      v25 = 2081;
      v26 = "bleValue && [bleValue isKindOfClass:[NSNumber class]]";
      _os_log_impl(&dword_2419D9000, v13, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"No ble provided in dictionary\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x26u);
    }
    goto LABEL_28;
  }
  if (!v5 || (objc_opt_class(), (objc_opt_isKindOfClass() & 1) == 0))
  {
    _CLLogObjectForCategory_MicroLocation_Default();
    v16 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v16, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 68289539;
      v20 = 0;
      v21 = 2082;
      v22 = "";
      v23 = 2082;
      v24 = "assert";
      v25 = 2081;
      v26 = "uwbValue && [uwbValue isKindOfClass:[NSNumber class]]";
      _os_log_impl(&dword_2419D9000, v16, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"No uwb provided in dictionary\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x26u);
    }

    _CLLogObjectForCategory_MicroLocation_Default();
    v17 = objc_claimAutoreleasedReturnValue();
    if (os_signpost_enabled(v17))
    {
      *(_DWORD *)buf = 68289539;
      v20 = 0;
      v21 = 2082;
      v22 = "";
      v23 = 2082;
      v24 = "assert";
      v25 = 2081;
      v26 = "uwbValue && [uwbValue isKindOfClass:[NSNumber class]]";
      _os_signpost_emit_with_name_impl(&dword_2419D9000, v17, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "No uwb provided in dictionary", "{\"msg%{public}.0s\":\"No uwb provided in dictionary\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x26u);
    }

    _CLLogObjectForCategory_MicroLocation_Default();
    v13 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 68289539;
      v20 = 0;
      v21 = 2082;
      v22 = "";
      v23 = 2082;
      v24 = "assert";
      v25 = 2081;
      v26 = "uwbValue && [uwbValue isKindOfClass:[NSNumber class]]";
      _os_log_impl(&dword_2419D9000, v13, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"No uwb provided in dictionary\", \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x26u);
    }
    goto LABEL_28;
  }
  objc_msgSend(v3, "doubleValue");
  v7 = v6;
  objc_msgSend(v4, "doubleValue");
  v9 = v8;
  objc_msgSend(v5, "doubleValue");
  *(_QWORD *)a2 = &off_2511D3A70;
  *(_BYTE *)(a2 + 8) = v7 != 0.0;
  *(_BYTE *)(a2 + 9) = v9 != 0.0;
  *(_BYTE *)(a2 + 10) = v10 != 0.0;

}

void sub_241A2083C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, id a12)
{
  void *v12;
  void *v13;

  _Unwind_Resume(a1);
}

void CLMicroLocationUtils::PerSourceWeights<BOOL>::~PerSourceWeights()
{
  JUMPOUT(0x2426A04D4);
}

BOOL CLMicroLocationUtils::PerSourceWeights<BOOL>::operator[](unsigned __int8 *a1, uint64_t a2)
{
  int v2;
  int v3;
  _BOOL8 result;
  NSObject *v5;
  uint8_t v6[16];

  v2 = *(_DWORD *)(a2 + 8);
  switch(v2)
  {
    case 6:
      v3 = a1[10];
      return v3 != 0;
    case 5:
      v3 = a1[9];
      return v3 != 0;
    case 1:
      v3 = a1[8];
      return v3 != 0;
  }
  if (onceToken_MicroLocation_Default != -1)
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_21);
  v5 = logObject_MicroLocation_Default;
  result = os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_ERROR);
  if (result)
  {
    *(_WORD *)v6 = 0;
    _os_log_impl(&dword_2419D9000, v5, OS_LOG_TYPE_ERROR, "Datatype not supported", v6, 2u);
    return 0;
  }
  return result;
}

uint64_t std::__function::__func<CLMicroLocationAlgorithms::details::createWeightedEuclideanJaccardDistanceFunction(NSDictionary *,CLMicroLocationFingerprintDistanceFunction::EnabledTechnologiesConfig const&,CLMicroLocationAlgorithms::details::FingerprintDistanceFunctionUsage const&,std::optional<CLMicroLocationAnchorAppearanceMap> const&)::$_0,std::allocator<CLMicroLocationAlgorithms::details::createWeightedEuclideanJaccardDistanceFunction(NSDictionary *,CLMicroLocationFingerprintDistanceFunction::EnabledTechnologiesConfig const&,CLMicroLocationAlgorithms::details::FingerprintDistanceFunctionUsage const&,std::optional<CLMicroLocationAnchorAppearanceMap> const&)::$_0>,double ()(CLMicroLocationFingerprint const&,CLMicroLocationFingerprint const&)>::~__func(uint64_t a1)
{
  *(_QWORD *)a1 = &off_2511D3AC0;
  if (*(_BYTE *)(a1 + 240))
    std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>>>::~__hash_table(a1 + 184);

  return a1;
}

void std::__function::__func<CLMicroLocationAlgorithms::details::createWeightedEuclideanJaccardDistanceFunction(NSDictionary *,CLMicroLocationFingerprintDistanceFunction::EnabledTechnologiesConfig const&,CLMicroLocationAlgorithms::details::FingerprintDistanceFunctionUsage const&,std::optional<CLMicroLocationAnchorAppearanceMap> const&)::$_0,std::allocator<CLMicroLocationAlgorithms::details::createWeightedEuclideanJaccardDistanceFunction(NSDictionary *,CLMicroLocationFingerprintDistanceFunction::EnabledTechnologiesConfig const&,CLMicroLocationAlgorithms::details::FingerprintDistanceFunctionUsage const&,std::optional<CLMicroLocationAnchorAppearanceMap> const&)::$_0>,double ()(CLMicroLocationFingerprint const&,CLMicroLocationFingerprint const&)>::~__func(uint64_t a1)
{
  *(_QWORD *)a1 = &off_2511D3AC0;
  if (*(_BYTE *)(a1 + 240))
    std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>>>::~__hash_table(a1 + 184);

  JUMPOUT(0x2426A04D4);
}

_QWORD *std::__function::__func<CLMicroLocationAlgorithms::details::createWeightedEuclideanJaccardDistanceFunction(NSDictionary *,CLMicroLocationFingerprintDistanceFunction::EnabledTechnologiesConfig const&,CLMicroLocationAlgorithms::details::FingerprintDistanceFunctionUsage const&,std::optional<CLMicroLocationAnchorAppearanceMap> const&)::$_0,std::allocator<CLMicroLocationAlgorithms::details::createWeightedEuclideanJaccardDistanceFunction(NSDictionary *,CLMicroLocationFingerprintDistanceFunction::EnabledTechnologiesConfig const&,CLMicroLocationAlgorithms::details::FingerprintDistanceFunctionUsage const&,std::optional<CLMicroLocationAnchorAppearanceMap> const&)::$_0>,double ()(CLMicroLocationFingerprint const&,CLMicroLocationFingerprint const&)>::__clone(uint64_t a1)
{
  uint64_t v1;
  _QWORD *v2;

  v1 = a1 + 8;
  v2 = operator new(0xF8uLL);
  *v2 = &off_2511D3AC0;
  std::__compressed_pair_elem<CLMicroLocationAlgorithms::details::createWeightedEuclideanJaccardDistanceFunction(NSDictionary *,CLMicroLocationFingerprintDistanceFunction::EnabledTechnologiesConfig const&,CLMicroLocationAlgorithms::details::FingerprintDistanceFunctionUsage const&,std::optional<CLMicroLocationAnchorAppearanceMap> const&)::$_0,0,false>::__compressed_pair_elem[abi:ne180100]<CLMicroLocationAlgorithms::details::createWeightedEuclideanJaccardDistanceFunction(NSDictionary *,CLMicroLocationFingerprintDistanceFunction::EnabledTechnologiesConfig const&,CLMicroLocationAlgorithms::details::FingerprintDistanceFunctionUsage const&,std::optional<CLMicroLocationAnchorAppearanceMap> const&)::$_0 const&,0ul>((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_241A20A40(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<CLMicroLocationAlgorithms::details::createWeightedEuclideanJaccardDistanceFunction(NSDictionary *,CLMicroLocationFingerprintDistanceFunction::EnabledTechnologiesConfig const&,CLMicroLocationAlgorithms::details::FingerprintDistanceFunctionUsage const&,std::optional<CLMicroLocationAnchorAppearanceMap> const&)::$_0,std::allocator<CLMicroLocationAlgorithms::details::createWeightedEuclideanJaccardDistanceFunction(NSDictionary *,CLMicroLocationFingerprintDistanceFunction::EnabledTechnologiesConfig const&,CLMicroLocationAlgorithms::details::FingerprintDistanceFunctionUsage const&,std::optional<CLMicroLocationAnchorAppearanceMap> const&)::$_0>,double ()(CLMicroLocationFingerprint const&,CLMicroLocationFingerprint const&)>::__clone(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_2511D3AC0;
  return std::__compressed_pair_elem<CLMicroLocationAlgorithms::details::createWeightedEuclideanJaccardDistanceFunction(NSDictionary *,CLMicroLocationFingerprintDistanceFunction::EnabledTechnologiesConfig const&,CLMicroLocationAlgorithms::details::FingerprintDistanceFunctionUsage const&,std::optional<CLMicroLocationAnchorAppearanceMap> const&)::$_0,0,false>::__compressed_pair_elem[abi:ne180100]<CLMicroLocationAlgorithms::details::createWeightedEuclideanJaccardDistanceFunction(NSDictionary *,CLMicroLocationFingerprintDistanceFunction::EnabledTechnologiesConfig const&,CLMicroLocationAlgorithms::details::FingerprintDistanceFunctionUsage const&,std::optional<CLMicroLocationAnchorAppearanceMap> const&)::$_0 const&,0ul>((uint64_t)(a2 + 1), a1 + 8);
}

void std::__function::__func<CLMicroLocationAlgorithms::details::createWeightedEuclideanJaccardDistanceFunction(NSDictionary *,CLMicroLocationFingerprintDistanceFunction::EnabledTechnologiesConfig const&,CLMicroLocationAlgorithms::details::FingerprintDistanceFunctionUsage const&,std::optional<CLMicroLocationAnchorAppearanceMap> const&)::$_0,std::allocator<CLMicroLocationAlgorithms::details::createWeightedEuclideanJaccardDistanceFunction(NSDictionary *,CLMicroLocationFingerprintDistanceFunction::EnabledTechnologiesConfig const&,CLMicroLocationAlgorithms::details::FingerprintDistanceFunctionUsage const&,std::optional<CLMicroLocationAnchorAppearanceMap> const&)::$_0>,double ()(CLMicroLocationFingerprint const&,CLMicroLocationFingerprint const&)>::destroy(uint64_t a1)
{
  std::__function::__alloc_func<CLMicroLocationAlgorithms::details::createWeightedEuclideanJaccardDistanceFunction(NSDictionary *,CLMicroLocationFingerprintDistanceFunction::EnabledTechnologiesConfig const&,CLMicroLocationAlgorithms::details::FingerprintDistanceFunctionUsage const&,std::optional<CLMicroLocationAnchorAppearanceMap> const&)::$_0,std::allocator<CLMicroLocationAlgorithms::details::createWeightedEuclideanJaccardDistanceFunction(NSDictionary *,CLMicroLocationFingerprintDistanceFunction::EnabledTechnologiesConfig const&,CLMicroLocationAlgorithms::details::FingerprintDistanceFunctionUsage const&,std::optional<CLMicroLocationAnchorAppearanceMap> const&)::$_0>,double ()(CLMicroLocationFingerprint const&,CLMicroLocationFingerprint const&)>::destroy[abi:ne180100](a1 + 8);
}

void std::__function::__func<CLMicroLocationAlgorithms::details::createWeightedEuclideanJaccardDistanceFunction(NSDictionary *,CLMicroLocationFingerprintDistanceFunction::EnabledTechnologiesConfig const&,CLMicroLocationAlgorithms::details::FingerprintDistanceFunctionUsage const&,std::optional<CLMicroLocationAnchorAppearanceMap> const&)::$_0,std::allocator<CLMicroLocationAlgorithms::details::createWeightedEuclideanJaccardDistanceFunction(NSDictionary *,CLMicroLocationFingerprintDistanceFunction::EnabledTechnologiesConfig const&,CLMicroLocationAlgorithms::details::FingerprintDistanceFunctionUsage const&,std::optional<CLMicroLocationAnchorAppearanceMap> const&)::$_0>,double ()(CLMicroLocationFingerprint const&,CLMicroLocationFingerprint const&)>::destroy_deallocate(void *a1)
{
  std::__function::__alloc_func<CLMicroLocationAlgorithms::details::createWeightedEuclideanJaccardDistanceFunction(NSDictionary *,CLMicroLocationFingerprintDistanceFunction::EnabledTechnologiesConfig const&,CLMicroLocationAlgorithms::details::FingerprintDistanceFunctionUsage const&,std::optional<CLMicroLocationAnchorAppearanceMap> const&)::$_0,std::allocator<CLMicroLocationAlgorithms::details::createWeightedEuclideanJaccardDistanceFunction(NSDictionary *,CLMicroLocationFingerprintDistanceFunction::EnabledTechnologiesConfig const&,CLMicroLocationAlgorithms::details::FingerprintDistanceFunctionUsage const&,std::optional<CLMicroLocationAnchorAppearanceMap> const&)::$_0>,double ()(CLMicroLocationFingerprint const&,CLMicroLocationFingerprint const&)>::destroy[abi:ne180100]((uint64_t)a1 + 8);
  operator delete(a1);
}

void std::__function::__func<CLMicroLocationAlgorithms::details::createWeightedEuclideanJaccardDistanceFunction(NSDictionary *,CLMicroLocationFingerprintDistanceFunction::EnabledTechnologiesConfig const&,CLMicroLocationAlgorithms::details::FingerprintDistanceFunctionUsage const&,std::optional<CLMicroLocationAnchorAppearanceMap> const&)::$_0,std::allocator<CLMicroLocationAlgorithms::details::createWeightedEuclideanJaccardDistanceFunction(NSDictionary *,CLMicroLocationFingerprintDistanceFunction::EnabledTechnologiesConfig const&,CLMicroLocationAlgorithms::details::FingerprintDistanceFunctionUsage const&,std::optional<CLMicroLocationAnchorAppearanceMap> const&)::$_0>,double ()(CLMicroLocationFingerprint const&,CLMicroLocationFingerprint const&)>::operator()(uint64_t a1, uint64_t a2, uint64_t a3)
{
  double v6;
  double v7;
  double v8;

  objc_msgSend(*(id *)(a1 + 8), "doubleValue");
  v7 = v6;
  objc_msgSend(*(id *)(a1 + 16), "doubleValue");
  CLMicroLocationFingerprintDistanceFunction::weightedEuclideanJaccardDistance(a2, a3, a1 + 24, a1 + 56, a1 + 88, a1 + 120, a1 + 152, a1 + 168, v7, v8, a1 + 184);
}

uint64_t std::__function::__func<CLMicroLocationAlgorithms::details::createWeightedEuclideanJaccardDistanceFunction(NSDictionary *,CLMicroLocationFingerprintDistanceFunction::EnabledTechnologiesConfig const&,CLMicroLocationAlgorithms::details::FingerprintDistanceFunctionUsage const&,std::optional<CLMicroLocationAnchorAppearanceMap> const&)::$_0,std::allocator<CLMicroLocationAlgorithms::details::createWeightedEuclideanJaccardDistanceFunction(NSDictionary *,CLMicroLocationFingerprintDistanceFunction::EnabledTechnologiesConfig const&,CLMicroLocationAlgorithms::details::FingerprintDistanceFunctionUsage const&,std::optional<CLMicroLocationAnchorAppearanceMap> const&)::$_0>,double ()(CLMicroLocationFingerprint const&,CLMicroLocationFingerprint const&)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<CLMicroLocationAlgorithms::details::createWeightedEuclideanJaccardDistanceFunction(NSDictionary *,CLMicroLocationFingerprintDistanceFunction::EnabledTechnologiesConfig const&,CLMicroLocationAlgorithms::details::FingerprintDistanceFunctionUsage const&,std::optional<CLMicroLocationAnchorAppearanceMap> const&)::$_0,std::allocator<CLMicroLocationAlgorithms::details::createWeightedEuclideanJaccardDistanceFunction(NSDictionary *,CLMicroLocationFingerprintDistanceFunction::EnabledTechnologiesConfig const&,CLMicroLocationAlgorithms::details::FingerprintDistanceFunctionUsage const&,std::optional<CLMicroLocationAnchorAppearanceMap> const&)::$_0>,double ()(CLMicroLocationFingerprint const&,CLMicroLocationFingerprint const&)>::target_type()
{
}

uint64_t std::__compressed_pair_elem<CLMicroLocationAlgorithms::details::createWeightedEuclideanJaccardDistanceFunction(NSDictionary *,CLMicroLocationFingerprintDistanceFunction::EnabledTechnologiesConfig const&,CLMicroLocationAlgorithms::details::FingerprintDistanceFunctionUsage const&,std::optional<CLMicroLocationAnchorAppearanceMap> const&)::$_0,0,false>::__compressed_pair_elem[abi:ne180100]<CLMicroLocationAlgorithms::details::createWeightedEuclideanJaccardDistanceFunction(NSDictionary *,CLMicroLocationFingerprintDistanceFunction::EnabledTechnologiesConfig const&,CLMicroLocationAlgorithms::details::FingerprintDistanceFunctionUsage const&,std::optional<CLMicroLocationAnchorAppearanceMap> const&)::$_0 const&,0ul>(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  *(_QWORD *)a1 = *(id *)a2;
  *(_QWORD *)(a1 + 8) = *(id *)(a2 + 8);
  *(_QWORD *)(a1 + 16) = &off_2511D3368;
  v4 = *(_QWORD *)(a2 + 40);
  *(_OWORD *)(a1 + 24) = *(_OWORD *)(a2 + 24);
  *(_QWORD *)(a1 + 40) = v4;
  *(_QWORD *)(a1 + 48) = &off_2511D3368;
  v5 = *(_QWORD *)(a2 + 72);
  *(_OWORD *)(a1 + 56) = *(_OWORD *)(a2 + 56);
  *(_QWORD *)(a1 + 72) = v5;
  *(_QWORD *)(a1 + 80) = &off_2511D3368;
  v6 = *(_QWORD *)(a2 + 104);
  *(_OWORD *)(a1 + 88) = *(_OWORD *)(a2 + 88);
  *(_QWORD *)(a1 + 104) = v6;
  *(_QWORD *)(a1 + 112) = &off_2511D3368;
  v7 = *(_QWORD *)(a2 + 136);
  *(_OWORD *)(a1 + 120) = *(_OWORD *)(a2 + 120);
  *(_QWORD *)(a1 + 136) = v7;
  *(_QWORD *)(a1 + 144) = &off_2511D3A70;
  LOBYTE(v7) = *(_BYTE *)(a2 + 154);
  *(_WORD *)(a1 + 152) = *(_WORD *)(a2 + 152);
  *(_BYTE *)(a1 + 154) = v7;
  *(_OWORD *)(a1 + 160) = *(_OWORD *)(a2 + 160);
  std::__optional_copy_base<CLMicroLocationAnchorAppearanceMap,false>::__optional_copy_base[abi:ne180100](a1 + 176, a2 + 176);
  return a1;
}

void sub_241A20C1C(_Unwind_Exception *a1)
{
  id *v1;

  _Unwind_Resume(a1);
}

void std::__function::__alloc_func<CLMicroLocationAlgorithms::details::createWeightedEuclideanJaccardDistanceFunction(NSDictionary *,CLMicroLocationFingerprintDistanceFunction::EnabledTechnologiesConfig const&,CLMicroLocationAlgorithms::details::FingerprintDistanceFunctionUsage const&,std::optional<CLMicroLocationAnchorAppearanceMap> const&)::$_0,std::allocator<CLMicroLocationAlgorithms::details::createWeightedEuclideanJaccardDistanceFunction(NSDictionary *,CLMicroLocationFingerprintDistanceFunction::EnabledTechnologiesConfig const&,CLMicroLocationAlgorithms::details::FingerprintDistanceFunctionUsage const&,std::optional<CLMicroLocationAnchorAppearanceMap> const&)::$_0>,double ()(CLMicroLocationFingerprint const&,CLMicroLocationFingerprint const&)>::destroy[abi:ne180100](uint64_t a1)
{
  if (*(_BYTE *)(a1 + 232))
    std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>>>::~__hash_table(a1 + 176);

}

uint64_t std::__function::__func<CLMicroLocationAlgorithms::details::createFingerprintDistanceFunction(CLMicroLocationAlgorithms::FingerprintDistanceFunctionType,NSDictionary *,CLMicroLocationFingerprintDistanceFunction::EnabledTechnologiesConfig const&,CLMicroLocationAlgorithms::details::FingerprintDistanceFunctionUsage,std::optional<CLMicroLocationAnchorAppearanceMap> const&)::$_3,std::allocator<CLMicroLocationAlgorithms::details::createFingerprintDistanceFunction(CLMicroLocationAlgorithms::FingerprintDistanceFunctionType,NSDictionary *,CLMicroLocationFingerprintDistanceFunction::EnabledTechnologiesConfig const&,CLMicroLocationAlgorithms::details::FingerprintDistanceFunctionUsage,std::optional<CLMicroLocationAnchorAppearanceMap> const&)::$_3>,double ()(CLMicroLocationFingerprint const&,CLMicroLocationFingerprint const&)>::~__func(uint64_t a1)
{

  return a1;
}

void std::__function::__func<CLMicroLocationAlgorithms::details::createFingerprintDistanceFunction(CLMicroLocationAlgorithms::FingerprintDistanceFunctionType,NSDictionary *,CLMicroLocationFingerprintDistanceFunction::EnabledTechnologiesConfig const&,CLMicroLocationAlgorithms::details::FingerprintDistanceFunctionUsage,std::optional<CLMicroLocationAnchorAppearanceMap> const&)::$_3,std::allocator<CLMicroLocationAlgorithms::details::createFingerprintDistanceFunction(CLMicroLocationAlgorithms::FingerprintDistanceFunctionType,NSDictionary *,CLMicroLocationFingerprintDistanceFunction::EnabledTechnologiesConfig const&,CLMicroLocationAlgorithms::details::FingerprintDistanceFunctionUsage,std::optional<CLMicroLocationAnchorAppearanceMap> const&)::$_3>,double ()(CLMicroLocationFingerprint const&,CLMicroLocationFingerprint const&)>::~__func(uint64_t a1)
{

  JUMPOUT(0x2426A04D4);
}

_QWORD *std::__function::__func<CLMicroLocationAlgorithms::details::createFingerprintDistanceFunction(CLMicroLocationAlgorithms::FingerprintDistanceFunctionType,NSDictionary *,CLMicroLocationFingerprintDistanceFunction::EnabledTechnologiesConfig const&,CLMicroLocationAlgorithms::details::FingerprintDistanceFunctionUsage,std::optional<CLMicroLocationAnchorAppearanceMap> const&)::$_3,std::allocator<CLMicroLocationAlgorithms::details::createFingerprintDistanceFunction(CLMicroLocationAlgorithms::FingerprintDistanceFunctionType,NSDictionary *,CLMicroLocationFingerprintDistanceFunction::EnabledTechnologiesConfig const&,CLMicroLocationAlgorithms::details::FingerprintDistanceFunctionUsage,std::optional<CLMicroLocationAnchorAppearanceMap> const&)::$_3>,double ()(CLMicroLocationFingerprint const&,CLMicroLocationFingerprint const&)>::__clone(uint64_t a1)
{
  _QWORD *v2;

  v2 = operator new(0x10uLL);
  *v2 = &off_2511D3B40;
  v2[1] = *(id *)(a1 + 8);
  return v2;
}

id std::__function::__func<CLMicroLocationAlgorithms::details::createFingerprintDistanceFunction(CLMicroLocationAlgorithms::FingerprintDistanceFunctionType,NSDictionary *,CLMicroLocationFingerprintDistanceFunction::EnabledTechnologiesConfig const&,CLMicroLocationAlgorithms::details::FingerprintDistanceFunctionUsage,std::optional<CLMicroLocationAnchorAppearanceMap> const&)::$_3,std::allocator<CLMicroLocationAlgorithms::details::createFingerprintDistanceFunction(CLMicroLocationAlgorithms::FingerprintDistanceFunctionType,NSDictionary *,CLMicroLocationFingerprintDistanceFunction::EnabledTechnologiesConfig const&,CLMicroLocationAlgorithms::details::FingerprintDistanceFunctionUsage,std::optional<CLMicroLocationAnchorAppearanceMap> const&)::$_3>,double ()(CLMicroLocationFingerprint const&,CLMicroLocationFingerprint const&)>::__clone(uint64_t a1, _QWORD *a2)
{
  id result;

  *a2 = &off_2511D3B40;
  result = *(id *)(a1 + 8);
  a2[1] = result;
  return result;
}

void std::__function::__func<CLMicroLocationAlgorithms::details::createFingerprintDistanceFunction(CLMicroLocationAlgorithms::FingerprintDistanceFunctionType,NSDictionary *,CLMicroLocationFingerprintDistanceFunction::EnabledTechnologiesConfig const&,CLMicroLocationAlgorithms::details::FingerprintDistanceFunctionUsage,std::optional<CLMicroLocationAnchorAppearanceMap> const&)::$_3,std::allocator<CLMicroLocationAlgorithms::details::createFingerprintDistanceFunction(CLMicroLocationAlgorithms::FingerprintDistanceFunctionType,NSDictionary *,CLMicroLocationFingerprintDistanceFunction::EnabledTechnologiesConfig const&,CLMicroLocationAlgorithms::details::FingerprintDistanceFunctionUsage,std::optional<CLMicroLocationAnchorAppearanceMap> const&)::$_3>,double ()(CLMicroLocationFingerprint const&,CLMicroLocationFingerprint const&)>::destroy(uint64_t a1)
{

}

void std::__function::__func<CLMicroLocationAlgorithms::details::createFingerprintDistanceFunction(CLMicroLocationAlgorithms::FingerprintDistanceFunctionType,NSDictionary *,CLMicroLocationFingerprintDistanceFunction::EnabledTechnologiesConfig const&,CLMicroLocationAlgorithms::details::FingerprintDistanceFunctionUsage,std::optional<CLMicroLocationAnchorAppearanceMap> const&)::$_3,std::allocator<CLMicroLocationAlgorithms::details::createFingerprintDistanceFunction(CLMicroLocationAlgorithms::FingerprintDistanceFunctionType,NSDictionary *,CLMicroLocationFingerprintDistanceFunction::EnabledTechnologiesConfig const&,CLMicroLocationAlgorithms::details::FingerprintDistanceFunctionUsage,std::optional<CLMicroLocationAnchorAppearanceMap> const&)::$_3>,double ()(CLMicroLocationFingerprint const&,CLMicroLocationFingerprint const&)>::destroy_deallocate(id *a1)
{

  operator delete(a1);
}

void std::__function::__func<CLMicroLocationAlgorithms::details::createFingerprintDistanceFunction(CLMicroLocationAlgorithms::FingerprintDistanceFunctionType,NSDictionary *,CLMicroLocationFingerprintDistanceFunction::EnabledTechnologiesConfig const&,CLMicroLocationAlgorithms::details::FingerprintDistanceFunctionUsage,std::optional<CLMicroLocationAnchorAppearanceMap> const&)::$_3,std::allocator<CLMicroLocationAlgorithms::details::createFingerprintDistanceFunction(CLMicroLocationAlgorithms::FingerprintDistanceFunctionType,NSDictionary *,CLMicroLocationFingerprintDistanceFunction::EnabledTechnologiesConfig const&,CLMicroLocationAlgorithms::details::FingerprintDistanceFunctionUsage,std::optional<CLMicroLocationAnchorAppearanceMap> const&)::$_3>,double ()(CLMicroLocationFingerprint const&,CLMicroLocationFingerprint const&)>::operator()(uint64_t a1, CLMicroLocationFingerprintDistanceFunction *a2, const CLMicroLocationFingerprint *a3)
{
  const CLMicroLocationFingerprint *v5;
  long double v6;

  objc_msgSend(*(id *)(a1 + 8), "doubleValue");
  CLMicroLocationFingerprintDistanceFunction::tanimotoLike(a2, a3, v5, v6);
}

uint64_t std::__function::__func<CLMicroLocationAlgorithms::details::createFingerprintDistanceFunction(CLMicroLocationAlgorithms::FingerprintDistanceFunctionType,NSDictionary *,CLMicroLocationFingerprintDistanceFunction::EnabledTechnologiesConfig const&,CLMicroLocationAlgorithms::details::FingerprintDistanceFunctionUsage,std::optional<CLMicroLocationAnchorAppearanceMap> const&)::$_3,std::allocator<CLMicroLocationAlgorithms::details::createFingerprintDistanceFunction(CLMicroLocationAlgorithms::FingerprintDistanceFunctionType,NSDictionary *,CLMicroLocationFingerprintDistanceFunction::EnabledTechnologiesConfig const&,CLMicroLocationAlgorithms::details::FingerprintDistanceFunctionUsage,std::optional<CLMicroLocationAnchorAppearanceMap> const&)::$_3>,double ()(CLMicroLocationFingerprint const&,CLMicroLocationFingerprint const&)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<CLMicroLocationAlgorithms::details::createFingerprintDistanceFunction(CLMicroLocationAlgorithms::FingerprintDistanceFunctionType,NSDictionary *,CLMicroLocationFingerprintDistanceFunction::EnabledTechnologiesConfig const&,CLMicroLocationAlgorithms::details::FingerprintDistanceFunctionUsage,std::optional<CLMicroLocationAnchorAppearanceMap> const&)::$_3,std::allocator<CLMicroLocationAlgorithms::details::createFingerprintDistanceFunction(CLMicroLocationAlgorithms::FingerprintDistanceFunctionType,NSDictionary *,CLMicroLocationFingerprintDistanceFunction::EnabledTechnologiesConfig const&,CLMicroLocationAlgorithms::details::FingerprintDistanceFunctionUsage,std::optional<CLMicroLocationAnchorAppearanceMap> const&)::$_3>,double ()(CLMicroLocationFingerprint const&,CLMicroLocationFingerprint const&)>::target_type()
{
}

void CLLaplacianKernelFunction::~CLLaplacianKernelFunction(CLLaplacianKernelFunction *this)
{
  JUMPOUT(0x2426A04D4);
}

uint64_t CLKernelFunction::operator()(uint64_t a1, uint64_t *a2, _QWORD *a3)
{
  double v4;
  void (**v6)(CLEuclideanSquaredDistanceFunction *__hidden);

  v6 = &off_2511D3C28;
  v4 = CLEuclideanSquaredDistanceFunction::operator()((uint64_t)&v6, a2, a3);
  return (*(uint64_t (**)(uint64_t, double))(*(_QWORD *)a1 + 24))(a1, sqrt(v4));
}

double CLLaplacianKernelFunction::operator()(uint64_t a1, double a2)
{
  return exp(-(*(double *)(a1 + 8) * a2));
}

double CLEuclideanSquaredDistanceFunction::operator()(uint64_t a1, uint64_t *a2, _QWORD *a3)
{
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  double result;
  double v8;

  v3 = *a2;
  v4 = a2[1];
  v5 = (v4 - *a2) >> 3;
  if (v5 != (uint64_t)(a3[1] - *a3) >> 3)
    CLEuclideanSquaredDistanceFunction::operator()();
  if (v4 == v3)
    return 0.0;
  v6 = 0;
  result = 0.0;
  do
  {
    v8 = *(double *)(v3 + 8 * v6) - *(double *)(*a3 + 8 * v6);
    result = result + v8 * v8;
    ++v6;
  }
  while (v5 > v6);
  return result;
}

void CLEuclideanSquaredDistanceFunction::~CLEuclideanSquaredDistanceFunction(CLEuclideanSquaredDistanceFunction *this)
{
  JUMPOUT(0x2426A04D4);
}

void CLGaussianKernelFunction::CLGaussianKernelFunction(CLGaussianKernelFunction *this, double a2)
{
  *(_QWORD *)this = &off_2511D3C68;
  *((_QWORD *)this + 1) = 0x3FE0000000000000;
  if (a2 <= 0.0)
    CLGaussianKernelFunction::CLGaussianKernelFunction();
  *((double *)this + 1) = 1.0 / ((a2 + a2) * a2);
}

void CLGaussianKernelFunction::~CLGaussianKernelFunction(CLGaussianKernelFunction *this)
{
  JUMPOUT(0x2426A04D4);
}

double CLGaussianKernelFunction::operator()(uint64_t a1, uint64_t *a2, _QWORD *a3)
{
  double v3;
  long double v4;
  void (**v6)(CLEuclideanSquaredDistanceFunction *__hidden);

  v3 = *(double *)(a1 + 8);
  v6 = &off_2511D3C28;
  v4 = -(v3 * CLEuclideanSquaredDistanceFunction::operator()((uint64_t)&v6, a2, a3));
  return exp(v4);
}

double CLGaussianKernelFunction::operator()(uint64_t a1, double a2)
{
  return exp(-(*(double *)(a1 + 8) * a2) * a2);
}

void CLExponentialKernelFunction::CLExponentialKernelFunction(CLExponentialKernelFunction *this, long double a2, long double a3)
{
  *(_QWORD *)this = &off_2511D3CB0;
  __asm { FMOV            V2.2D, #1.0 }
  *(_OWORD *)((char *)this + 8) = _Q2;
  if (a3 <= 0.0)
    CLExponentialKernelFunction::CLExponentialKernelFunction();
  if (a2 <= 0.0)
    CLExponentialKernelFunction::CLExponentialKernelFunction();
  *((long double *)this + 1) = a3;
  *((long double *)this + 2) = 1.0 / pow(a2, a3);
}

void CLExponentialKernelFunction::~CLExponentialKernelFunction(CLExponentialKernelFunction *this)
{
  JUMPOUT(0x2426A04D4);
}

double CLExponentialKernelFunction::operator()(uint64_t a1, long double a2)
{
  double v2;
  long double v3;

  v2 = *(double *)(a1 + 16);
  v3 = -(v2 * pow(a2, *(long double *)(a1 + 8)));
  return exp(v3);
}

void CLUniformKernelFunction::~CLUniformKernelFunction(CLUniformKernelFunction *this)
{
  JUMPOUT(0x2426A04D4);
}

double CLUniformKernelFunction::operator()(uint64_t a1, double a2)
{
  BOOL v2;
  double result;

  v2 = *(double *)(a1 + 8) <= a2;
  result = 0.0;
  if (!v2)
    return 1.0;
  return result;
}

void std::__function::__func<float (*)(CLDistanceMatrixTemplate<CLSymmetricMatrixStorage<float>> const&,std::pair<unsigned long,unsigned long>,std::pair<unsigned long,unsigned long>,std::pair<unsigned long,unsigned long>),std::allocator<float (*)(CLDistanceMatrixTemplate<CLSymmetricMatrixStorage<float>> const&,std::pair<unsigned long,unsigned long>,std::pair<unsigned long,unsigned long>,std::pair<unsigned long,unsigned long>)>,float ()(CLDistanceMatrixTemplate<CLSymmetricMatrixStorage<float>> const&,std::pair<unsigned long,unsigned long>,std::pair<unsigned long,unsigned long>,std::pair<unsigned long,unsigned long>)>::~__func()
{
  JUMPOUT(0x2426A04D4);
}

_QWORD *std::__function::__func<float (*)(CLDistanceMatrixTemplate<CLSymmetricMatrixStorage<float>> const&,std::pair<unsigned long,unsigned long>,std::pair<unsigned long,unsigned long>,std::pair<unsigned long,unsigned long>),std::allocator<float (*)(CLDistanceMatrixTemplate<CLSymmetricMatrixStorage<float>> const&,std::pair<unsigned long,unsigned long>,std::pair<unsigned long,unsigned long>,std::pair<unsigned long,unsigned long>)>,float ()(CLDistanceMatrixTemplate<CLSymmetricMatrixStorage<float>> const&,std::pair<unsigned long,unsigned long>,std::pair<unsigned long,unsigned long>,std::pair<unsigned long,unsigned long>)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_2511D3D40;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<float (*)(CLDistanceMatrixTemplate<CLSymmetricMatrixStorage<float>> const&,std::pair<unsigned long,unsigned long>,std::pair<unsigned long,unsigned long>,std::pair<unsigned long,unsigned long>),std::allocator<float (*)(CLDistanceMatrixTemplate<CLSymmetricMatrixStorage<float>> const&,std::pair<unsigned long,unsigned long>,std::pair<unsigned long,unsigned long>,std::pair<unsigned long,unsigned long>)>,float ()(CLDistanceMatrixTemplate<CLSymmetricMatrixStorage<float>> const&,std::pair<unsigned long,unsigned long>,std::pair<unsigned long,unsigned long>,std::pair<unsigned long,unsigned long>)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_2511D3D40;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<float (*)(CLDistanceMatrixTemplate<CLSymmetricMatrixStorage<float>> const&,std::pair<unsigned long,unsigned long>,std::pair<unsigned long,unsigned long>,std::pair<unsigned long,unsigned long>),std::allocator<float (*)(CLDistanceMatrixTemplate<CLSymmetricMatrixStorage<float>> const&,std::pair<unsigned long,unsigned long>,std::pair<unsigned long,unsigned long>,std::pair<unsigned long,unsigned long>)>,float ()(CLDistanceMatrixTemplate<CLSymmetricMatrixStorage<float>> const&,std::pair<unsigned long,unsigned long>,std::pair<unsigned long,unsigned long>,std::pair<unsigned long,unsigned long>)>::operator()(uint64_t a1, uint64_t a2, _QWORD *a3, _QWORD *a4, _QWORD *a5)
{
  return (*(uint64_t (**)(uint64_t, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD))(a1 + 8))(a2, *a3, a3[1], *a4, a4[1], *a5, a5[1]);
}

uint64_t std::__function::__func<float (*)(CLDistanceMatrixTemplate<CLSymmetricMatrixStorage<float>> const&,std::pair<unsigned long,unsigned long>,std::pair<unsigned long,unsigned long>,std::pair<unsigned long,unsigned long>),std::allocator<float (*)(CLDistanceMatrixTemplate<CLSymmetricMatrixStorage<float>> const&,std::pair<unsigned long,unsigned long>,std::pair<unsigned long,unsigned long>,std::pair<unsigned long,unsigned long>)>,float ()(CLDistanceMatrixTemplate<CLSymmetricMatrixStorage<float>> const&,std::pair<unsigned long,unsigned long>,std::pair<unsigned long,unsigned long>,std::pair<unsigned long,unsigned long>)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<float (*)(CLDistanceMatrixTemplate<CLSymmetricMatrixStorage<float>> const&,std::pair<unsigned long,unsigned long>,std::pair<unsigned long,unsigned long>,std::pair<unsigned long,unsigned long>),std::allocator<float (*)(CLDistanceMatrixTemplate<CLSymmetricMatrixStorage<float>> const&,std::pair<unsigned long,unsigned long>,std::pair<unsigned long,unsigned long>,std::pair<unsigned long,unsigned long>)>,float ()(CLDistanceMatrixTemplate<CLSymmetricMatrixStorage<float>> const&,std::pair<unsigned long,unsigned long>,std::pair<unsigned long,unsigned long>,std::pair<unsigned long,unsigned long>)>::target_type()
{
}

void OUTLINED_FUNCTION_3_2(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, const char *a5, const char *a6, uint8_t *a7)
{
  NSObject *v7;

  _os_signpost_emit_with_name_impl(a1, v7, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, a5, a6, a7, 0x2Cu);
}

void OUTLINED_FUNCTION_5_1(void *a1, uint64_t a2, uint64_t a3, const char *a4, uint8_t *a5)
{
  NSObject *v5;

  _os_log_impl(a1, v5, OS_LOG_TYPE_FAULT, a4, a5, 0x2Cu);
}

void OUTLINED_FUNCTION_6_1(void *a1, uint64_t a2, uint64_t a3, const char *a4, uint8_t *a5)
{
  NSObject *v5;

  _os_log_impl(a1, v5, OS_LOG_TYPE_INFO, a4, a5, 0x2Cu);
}

void OUTLINED_FUNCTION_7_1(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, const char *a5, const char *a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  NSObject *v9;

  _os_signpost_emit_with_name_impl(a1, v9, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, a5, a6, &a9, 0x26u);
}

BOOL OUTLINED_FUNCTION_8_0(NSObject *a1)
{
  NSObject **v1;

  *v1 = a1;
  return os_log_type_enabled(a1, OS_LOG_TYPE_INFO);
}

void OUTLINED_FUNCTION_12(void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  NSObject *v9;

  _os_log_impl(a1, v9, OS_LOG_TYPE_FAULT, a4, &a9, 0x26u);
}

void OUTLINED_FUNCTION_13(void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  NSObject *v9;

  _os_log_impl(a1, v9, OS_LOG_TYPE_INFO, a4, &a9, 0x26u);
}

void sub_241A21250(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_241A214A8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  uint64_t v3;
  void *v4;

  MEMORY[0x2426A04BC](v3, 0x1000C8077774924);
  _Unwind_Resume(a1);
}

void sub_241A2176C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25,uint64_t a26,void *a27,uint64_t a28,int a29,__int16 a30,char a31,char a32)
{
  CLMicroLocationProto::RapportDevice::~RapportDevice((CLMicroLocationProto::RapportDevice *)&a16);
  if (a25 < 0)
    operator delete(__p);
  _Unwind_Resume(a1);
}

void CLMicroLocationRapportTable::Entry::~Entry(void **this)
{
  CLMicroLocationProto::RapportDevice::~RapportDevice((CLMicroLocationProto::RapportDevice *)(this + 4));
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

void ___ZL45_CLLogObjectForCategory_MicroLocation_Defaultv_block_invoke_16()
{
  os_log_t v0;
  void *v1;

  v0 = os_log_create("com.apple.MicroLocation", "MicroLocation");
  v1 = (void *)logObject_MicroLocation_Default;
  logObject_MicroLocation_Default = (uint64_t)v0;

}

uint64_t std::__optional_destruct_base<CLMicroLocationRapportTable::Entry,false>::__optional_destruct_base[abi:ne180100]<CLMicroLocationRapportTable::Entry>(uint64_t a1, uint64_t a2)
{
  __int128 v4;

  *(_QWORD *)a1 = *(_QWORD *)a2;
  v4 = *(_OWORD *)(a2 + 8);
  *(_QWORD *)(a1 + 24) = *(_QWORD *)(a2 + 24);
  *(_OWORD *)(a1 + 8) = v4;
  *(_QWORD *)(a2 + 16) = 0;
  *(_QWORD *)(a2 + 24) = 0;
  *(_QWORD *)(a2 + 8) = 0;
  CLMicroLocationProto::RapportDevice::RapportDevice((CLMicroLocationProto::RapportDevice *)(a1 + 32), (const CLMicroLocationProto::RapportDevice *)(a2 + 32));
  *(_OWORD *)(a1 + 64) = *(_OWORD *)(a2 + 64);
  *(_BYTE *)(a1 + 80) = 1;
  return a1;
}

void sub_241A218EC(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void **v2;

  if (*(char *)(v1 + 31) < 0)
    operator delete(*v2);
  _Unwind_Resume(exception_object);
}

uint64_t sub_241A21928()
{
  void *v0;

  return 0;
}

void sub_241A21C0C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location)
{
  id *v16;

  objc_destroyWeak(v16);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

id ULLogicAdapterHelper::createULPrediction(uint64_t *a1, uint64_t a2)
{
  id v4;
  void *v5;
  int v6;
  id v7;
  void *v8;
  void *v9;
  uint64_t ULConfidence;
  const CLMicroLocationResultToPublish *v11;
  void *v12;
  void *v13;

  v4 = objc_alloc(MEMORY[0x24BE66958]);
  ULLogicAdapterHelper::createULPlaces(a1);
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  v6 = *(unsigned __int8 *)(a2 + 16);
  if (*(_BYTE *)(a2 + 16))
  {
    v7 = objc_alloc(MEMORY[0x24BDD1880]);
    if (!*(_BYTE *)(a2 + 16))
      std::__throw_bad_optional_access[abi:ne180100]();
    v8 = (void *)objc_msgSend(v7, "initWithUUIDBytes:", a2);
  }
  else
  {
    v8 = 0;
  }
  objc_msgSend(MEMORY[0x24BDBCE60], "date");
  v9 = (void *)objc_claimAutoreleasedReturnValue();
  ULConfidence = ULLogicAdapterHelper::getULConfidence((uint64_t)a1);
  ULLogicAdapterHelper::getULConfidenceReasons((ULLogicAdapterHelper *)a1, v11);
  v12 = (void *)objc_claimAutoreleasedReturnValue();
  v13 = (void *)objc_msgSend(v4, "initWithPlaces:error:requestIdentifier:time:confidence:confidenceReasons:", v5, 0, v8, v9, ULConfidence, v12);

  if (v6)
  return v13;
}

void sub_241A220CC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  int v5;

  if (v5)
  _Unwind_Resume(a1);
}

id ULLogicAdapterHelper::createULPlaces(uint64_t *a1)
{
  void *v2;
  uint64_t v3;
  uint64_t v4;
  id v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;

  objc_msgSend(MEMORY[0x24BDBCEB8], "array");
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  v3 = *a1;
  v4 = a1[1];
  if (*a1 != v4)
  {
    do
    {
      v5 = objc_alloc(MEMORY[0x24BE66950]);
      v6 = (void *)objc_msgSend(objc_alloc(MEMORY[0x24BDD1880]), "initWithUUIDBytes:", v3);
      objc_msgSend(MEMORY[0x24BDD16E0], "numberWithDouble:", *(double *)(v3 + 16));
      v7 = (void *)objc_claimAutoreleasedReturnValue();
      v8 = (void *)objc_msgSend(v5, "initWithIdentifier:score:", v6, v7);

      objc_msgSend(v2, "addObject:", v8);
      v3 += 32;
    }
    while (v3 != v4);
  }
  objc_msgSend(MEMORY[0x24BDBCE30], "arrayWithArray:", v2);
  v9 = (void *)objc_claimAutoreleasedReturnValue();

  return v9;
}

void sub_241A221F8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t ULLogicAdapterHelper::getULConfidence(uint64_t a1)
{
  uint64_t v1;
  NSObject *v3;
  uint8_t v4[16];

  v1 = *(int *)(a1 + 136);
  if (v1 < 4)
    return qword_241BB3F88[v1];
  if (onceToken_MicroLocation_Default != -1)
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_24);
  v3 = logObject_MicroLocation_Default;
  if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)v4 = 0;
    _os_log_impl(&dword_2419D9000, v3, OS_LOG_TYPE_ERROR, "unknown protobuf confidence level, deprecated?", v4, 2u);
  }
  return 0;
}

id ULLogicAdapterHelper::getULConfidenceReasons(ULLogicAdapterHelper *this, const CLMicroLocationResultToPublish *a2)
{
  void *v3;
  unsigned int *v4;
  unsigned int *v5;
  uint64_t v6;
  void *v7;
  void *v8;
  id result;
  NSObject *v10;

  objc_msgSend(MEMORY[0x24BDBCEB8], "array");
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  v4 = (unsigned int *)*((_QWORD *)this + 18);
  v5 = (unsigned int *)*((_QWORD *)this + 19);
  if (v4 == v5)
  {
LABEL_4:
    objc_msgSend(MEMORY[0x24BDBCE30], "arrayWithArray:", v3);
    v8 = (void *)objc_claimAutoreleasedReturnValue();

    return v8;
  }
  else
  {
    while (1)
    {
      v6 = *v4;
      if (v6 >= 8)
        break;
      v7 = (void *)objc_msgSend(objc_alloc(MEMORY[0x24BE66928]), "initWithConfidenceReasonEnum:", v6);
      objc_msgSend(v3, "addObject:", v7);

      if (++v4 == v5)
        goto LABEL_4;
    }
    ULLogicAdapterHelper::getULConfidenceReasons(&v10);

    result = (id)abort_report_np();
    __break(1u);
  }
  return result;
}

void sub_241A223C8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

id ULLogicAdapterHelper::ulServiceStatusFromInternalStatus(ULLogicAdapterHelper *this, const CLMiLoService::ServiceStatus *a2)
{
  id v3;
  uint64_t i;
  void *v5;
  uint64_t v6;
  id v7;
  uint64_t v8;
  void *v9;
  id v10;
  _QWORD *v11;
  _QWORD *j;
  void *v13;
  id v14;
  _QWORD *v15;
  _QWORD *k;
  void *v17;
  id v18;
  uint64_t v19;
  void *v20;
  uint64_t v21;
  id v22;
  uint64_t v23;
  id v24;
  id v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  void *v30;
  void *v32;
  void *v33;
  void *v34;
  void *v35;
  void *v36;
  void *v37;
  void *v38;
  void *v39;
  void *v40;
  void *v41;
  void *v42;
  void *v43;
  void *v44;
  void *v45;

  v3 = objc_alloc_init(MEMORY[0x24BDBCEB8]);
  for (i = 0; i != 32; ++i)
  {
    if (((*((_QWORD *)this + 7) >> i) & 1) != 0)
    {
      v5 = (void *)objc_msgSend(objc_alloc(MEMORY[0x24BE66948]), "initWithLocationTypeEnum:", i);
      objc_msgSend(v3, "addObject:", v5);

    }
  }
  v6 = objc_msgSend(objc_alloc(MEMORY[0x24BDD1880]), "initWithUUIDBytes:", (char *)this + 32);
  v7 = objc_alloc(MEMORY[0x24BE66960]);
  v8 = *((_QWORD *)this + 6);
  v9 = (void *)objc_msgSend(v3, "copy");
  v42 = v3;
  v43 = (void *)v6;
  v44 = (void *)objc_msgSend(v7, "initWithServiceIdentifier:serviceType:locationTypes:", v6, v8, v9);

  v10 = objc_alloc_init(MEMORY[0x24BDBCEB8]);
  v11 = (_QWORD *)*((_QWORD *)this + 1);
  for (j = (_QWORD *)*((_QWORD *)this + 2); v11 != j; ++v11)
  {
    v13 = (void *)objc_msgSend(objc_alloc(MEMORY[0x24BE66988]), "initWithSuspendReasonEnum:", *v11);
    objc_msgSend(v10, "addObject:", v13);

  }
  v14 = objc_alloc_init(MEMORY[0x24BDBCEB8]);
  v15 = (_QWORD *)*((_QWORD *)this + 10);
  for (k = (_QWORD *)*((_QWORD *)this + 11); v15 != k; ++v15)
  {
    v17 = (void *)objc_msgSend(objc_alloc(MEMORY[0x24BE66978]), "initWithQualityReasonEnum:", *v15);
    objc_msgSend(v14, "addObject:", v17);

  }
  v18 = objc_alloc(MEMORY[0x24BE66970]);
  v19 = *((_QWORD *)this + 9);
  v20 = (void *)objc_msgSend(v14, "copy");
  v21 = objc_msgSend(v18, "initServiceWithQuality:andReasons:", v19, v20);

  v41 = (void *)v21;
  v39 = v14;
  if (*((_BYTE *)this + 152))
  {
    v22 = objc_alloc(MEMORY[0x24BDD1880]);
    if (!*((_BYTE *)this + 152))
      std::__throw_bad_optional_access[abi:ne180100]();
    v23 = objc_msgSend(v22, "initWithUUIDBytes:", (char *)this + 136);
    v24 = objc_alloc(MEMORY[0x24BE66948]);
    if (!*((_BYTE *)this + 152))
      std::__throw_bad_optional_access[abi:ne180100]();
    v38 = (void *)objc_msgSend(v24, "initWithLocationTypeEnum:", *((_QWORD *)this + 16));
    v40 = (void *)v23;
  }
  else
  {
    v40 = 0;
    v38 = 0;
  }
  v25 = objc_alloc(MEMORY[0x24BE66968]);
  objc_msgSend(MEMORY[0x24BDD16E0], "numberWithUnsignedInt:", *((unsigned int *)this + 40));
  v45 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x24BDD16E0], "numberWithUnsignedInt:", *((unsigned int *)this + 41));
  v37 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x24BDD16E0], "numberWithUnsignedInt:", *((unsigned int *)this + 42));
  v36 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x24BDD16E0], "numberWithUnsignedInt:", *((unsigned int *)this + 44));
  v35 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x24BDD16E0], "numberWithUnsignedInt:", *((unsigned int *)this + 43));
  v34 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x24BDD16E0], "numberWithUnsignedInt:", *((unsigned int *)this + 45));
  v33 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x24BDD16E0], "numberWithUnsignedInt:", *((unsigned int *)this + 46));
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x24BDD16E0], "numberWithUnsignedInt:", *((unsigned int *)this + 47));
  v27 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x24BDD16E0], "numberWithUnsignedInt:", *((unsigned int *)this + 48));
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x24BDD16E0], "numberWithUnsignedInt:", *((unsigned int *)this + 49));
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  v32 = (void *)objc_msgSend(v25, "initWithNumClustersLearnedInModel:numRecordingTriggersAtCurrentLOI:numInputValidFingerprints:numInputValidFingerprintsLabeled:numInputValidFingerprintsUnlabeled:numFingerprintsBeforePruning:numFingerprintsAfterPruning:numWiFiAccessPoints:numBLESources:numUWBSources:", v45, v37, v36, v35, v34, v33, v26, v27, v28, v29);

  v30 = (void *)objc_msgSend(objc_alloc(MEMORY[0x24BE66980]), "initWithServiceState:serviceSuspendReasons:serviceDescriptor:currentLocationOfInterestUuid:currentLocationOfInterestType:error:serviceQualityInfo:metaInfo:", *(_QWORD *)this, v10, v44, v40, v38, 0, v41, v32);
  return v30;
}

void sub_241A22840(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *a15, void *a16, void *a17, void *a18, void *a19, void *a20,void *a21,void *a22,void *a23,void *a24)
{
  void *v24;
  void *v25;
  void *v26;
  void *v27;
  uint64_t v28;
  void *v30;
  void *v31;

  v31 = *(void **)(v28 - 112);
  v30 = *(void **)(v28 - 104);

  _Unwind_Resume(a1);
}

uint64_t ULLogicAdapterHelper::ulFingerprintErrorFromRecordingError(unsigned int a1)
{
  uint64_t v1;
  NSObject *v2;
  uint8_t v4[16];

  if (a1 < 4)
    return qword_241BB3FA8[a1];
  if (onceToken_MicroLocation_Default != -1)
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_24);
  v2 = logObject_MicroLocation_Default;
  if (!os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_ERROR))
    return 2;
  *(_WORD *)v4 = 0;
  v1 = 2;
  _os_log_impl(&dword_2419D9000, v2, OS_LOG_TYPE_ERROR, "Unexpected recording error", v4, 2u);
  return v1;
}

id ULLogicAdapterHelper::getFingerprintErrorsFromPredictionResults(ULLogicAdapterHelper *this, const CLMicroLocationResultToPublish *a2)
{
  void *v3;
  const CLMicroLocationResultToPublish *v4;
  id v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  void *v10;
  void *v11;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  _BYTE v17[128];
  uint64_t v18;

  v18 = *MEMORY[0x24BDAC8D0];
  objc_msgSend(MEMORY[0x24BDBCEB8], "array");
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  ULLogicAdapterHelper::getULConfidenceReasons(this, v4);
  v15 = 0u;
  v16 = 0u;
  v13 = 0u;
  v14 = 0u;
  v5 = (id)objc_claimAutoreleasedReturnValue();
  v6 = objc_msgSend(v5, "countByEnumeratingWithState:objects:count:", &v13, v17, 16);
  if (v6)
  {
    v7 = *(_QWORD *)v14;
    do
    {
      v8 = 0;
      do
      {
        if (*(_QWORD *)v14 != v7)
          objc_enumerationMutation(v5);
        v9 = objc_msgSend(*(id *)(*((_QWORD *)&v13 + 1) + 8 * v8), "confidenceReasonEnum", (_QWORD)v13);
        if (v9 <= 7)
        {
          v10 = (void *)objc_msgSend(objc_alloc(MEMORY[0x24BE66938]), "initWithFingerprintErrorEnum:", objc_msgSend(off_2511D3E80[v9], "integerValue"));
          objc_msgSend(v3, "addObject:", v10);

        }
        ++v8;
      }
      while (v6 != v8);
      v6 = objc_msgSend(v5, "countByEnumeratingWithState:objects:count:", &v13, v17, 16);
    }
    while (v6);
  }

  objc_msgSend(MEMORY[0x24BDBCE30], "arrayWithArray:", v3);
  v11 = (void *)objc_claimAutoreleasedReturnValue();

  return v11;
}

void sub_241A22BD8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void ___ZL45_CLLogObjectForCategory_MicroLocation_Defaultv_block_invoke_17()
{
  os_log_t v0;
  void *v1;

  v0 = os_log_create("com.apple.MicroLocation", "MicroLocation");
  v1 = (void *)logObject_MicroLocation_Default;
  logObject_MicroLocation_Default = (uint64_t)v0;

}

void sub_241A22D00(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  v3 = v2;

  _Unwind_Resume(a1);
}

void sub_241A22FEC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, id a20)
{
  _Block_object_dispose(&a15, 8);

  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__4(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__4(uint64_t a1)
{

}

void sub_241A230F0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_241A234C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, void *a11, void *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, void *a18, void *a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,char a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,id a30,char a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,id a36)
{
  uint64_t v36;

  _Block_object_dispose(&a25, 8);
  _Block_object_dispose(&a31, 8);

  _Block_object_dispose((const void *)(v36 - 208), 8);
  _Unwind_Resume(a1);
}

void sub_241A236C0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_241A23844(_Unwind_Exception *a1, uint64_t a2, void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, void *a10, void *a11, void *a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
  void *v15;
  void *v16;
  void *v17;
  void *v18;
  va_list va;

  va_start(va, a15);

  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_241A23958(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_241A23B28(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16, uint64_t a17, void *a18, void *a19, void *a20,void *a21,uint64_t a22,uint64_t a23,char a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,id a29)
{
  void *v29;
  void *v30;
  void *v31;
  void *v32;

  _Block_object_dispose(&a24, 8);
  _Unwind_Resume(a1);
}

void sub_241A23E28(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, void *a13)
{
  void *v13;
  void *v14;

  _Unwind_Resume(a1);
}

void sub_241A242EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, void *a10, void *a11, void *a12, void *a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20,void *a21,void *a22,void *a23,void *a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,id a36,char a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,id a42)
{
  uint64_t v42;

  _Block_object_dispose(&a31, 8);
  _Block_object_dispose(&a37, 8);

  _Block_object_dispose((const void *)(v42 - 208), 8);
  _Unwind_Resume(a1);
}

void sub_241A2455C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_241A2469C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  _Unwind_Resume(a1);
}

void sub_241A24AB4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, void *a11, void *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, void *a18, void *a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,char a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,id a34,char a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,id a40)
{
  void *v40;

  _Block_object_dispose(&a25, 8);
  _Block_object_dispose(&a29, 8);

  _Block_object_dispose(&a35, 8);
  _Unwind_Resume(a1);
}

void sub_241A24C88(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_241A25040(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16, void *a17, void *a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,id a28,char a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,id a34)
{
  void *v34;

  _Block_object_dispose(&a23, 8);
  _Block_object_dispose(&a29, 8);

  _Unwind_Resume(a1);
}

void sub_241A25208(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_241A254C0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_241A257B0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;

  _Unwind_Resume(a1);
}

void sub_241A259F4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_241A25A98(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_241A25B24(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_241A25BC4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_241A25C50(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_241A26054(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, void *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, void *a19, void *a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,id a32,char a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,id a38)
{
  void *v38;
  uint64_t v39;

  _Block_object_dispose(&a27, 8);
  _Block_object_dispose(&a33, 8);

  _Block_object_dispose((const void *)(v39 - 208), 8);
  _Unwind_Resume(a1);
}

void sub_241A2625C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_241A2634C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, void *a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  void *v9;
  void *v10;
  va_list va;

  va_start(va, a9);

  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_241A265EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13)
{

  _Unwind_Resume(a1);
}

void sub_241A26A18(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, void *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, void *a18, void *a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,id a28,char a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,id a34)
{
  void *v34;

  _Block_object_dispose(&a23, 8);
  _Block_object_dispose(&a29, 8);

  _Unwind_Resume(a1);
}

void sub_241A26BAC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_241A26C14(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void ___ZL45_CLLogObjectForCategory_MicroLocation_Defaultv_block_invoke_18()
{
  os_log_t v0;
  void *v1;

  v0 = os_log_create("com.apple.MicroLocation", "MicroLocation");
  v1 = (void *)logObject_MicroLocation_Default;
  logObject_MicroLocation_Default = (uint64_t)v0;

}

void CLMicroLocationBlueAtlasLocalizationAlgorithm::localize(CLMicroLocationModel *this@<X1>, const CLMicroLocationModel *a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X6>, char **a5@<X8>)
{
  CLMicroLocationModel *v7;
  void *v9;
  void *v10;
  void *v11;
  void *v12;
  unint64_t v13;
  int v14;
  int v15;
  double v16;
  _BOOL4 isValidAssociatedAccessPointBasedDecision;
  BOOL v18;
  NSObject *v19;
  CLMacAddress *v20;
  uint64_t v21;
  CLMacAddress *v22;
  std::string *p_p;
  double v24;
  uint64_t v25;
  const CLMicroLocationFingerprint *v26;
  uint64_t *v27;
  uint64_t *v28;
  _QWORD *v29;
  char *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  unint64_t v36;
  char *v37;
  uint64_t v38;
  char *v39;
  char *v40;
  char *v41;
  char *v42;
  __int128 v43;
  uint64_t *v44;
  uint64_t *v45;
  uint64_t v46;
  __int128 v47;
  __int128 v48;
  _QWORD *v49;
  _QWORD *v50;
  uint64_t v51;
  double v52;
  void *v53;
  void *v54;
  NSDictionary *v55;
  CLMicroLocationBlueAtlasLocalizationAlgorithm *v56;
  NSObject *v57;
  uint64_t *v58;
  uint64_t v59;
  double v60;
  double v61;
  unint64_t v62;
  uint64_t *v63;
  char v64;
  _BYTE *v65;
  uint64_t v66;
  _QWORD *v67;
  _QWORD *v68;
  CLMicroLocationModel *v69;
  NSObject *v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  unint64_t var0;
  NSObject *v75;
  uint64_t v76;
  void *v77;
  void *v78;
  void *v79;
  void *v80;
  uint64_t v81;
  void *v82;
  void *v83;
  void *v84;
  void *v85;
  void *v86;
  uint64_t v87;
  double v88;
  CLMacAddress *v89;
  uint64_t v90;
  uint64_t v91;
  unsigned int v92;
  void *v93;
  void *v94;
  void *v95;
  void *v96;
  std::string::size_type v97;
  void *v98;
  void *v99;
  void *v100;
  void *v101;
  void *v102;
  uint64_t v103;
  double v104;
  double v105;
  double v106;
  double v107;
  NSObject *v108;
  uint64_t v109;
  uint64_t *v110;
  uint64_t *v111;
  _QWORD *v112;
  char *v113;
  uint64_t v114;
  uint64_t v115;
  int v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  unint64_t v120;
  char *v121;
  uint64_t v122;
  char *v123;
  int v124;
  char *v125;
  char *v126;
  char *v127;
  __int128 v128;
  NSObject *v129;
  std::string *v130;
  NSObject *v131;
  std::string *v132;
  NSObject *v133;
  uint64_t v134;
  void *v135;
  void *v136;
  void *v137;
  void *v138;
  CLMicroLocationModel *v139;
  __int128 v141;
  uint64_t v142;
  __int128 v143;
  uint64_t v144;
  uint64_t v145[3];
  uint64_t v146;
  uint64_t v147;
  uint64_t v148;
  _QWORD v149[3];
  _BYTE v150[40];
  _QWORD v151[4];
  _QWORD v152[4];
  CLMacAddress v153;
  char v154;
  CLMacAddress *v155;
  _BYTE v156[28];
  __int16 v157;
  uint64_t v158;
  __int16 v159;
  uint64_t v160;
  __int16 v161;
  unint64_t v162;
  _BYTE buf[38];
  __int16 v164;
  _BYTE v165[28];
  __int16 v166;
  uint64_t v167;
  void *v168;
  _BYTE v169[24];
  _OWORD v170[2];
  int v171;
  void *v172;
  void *v173;
  uint64_t v174;
  std::string __p;
  uint64_t v176;
  uint64_t v177;
  uint64_t v178;
  void *v179;
  void *v180;
  uint64_t v181;

  v7 = this;
  v181 = *MEMORY[0x24BDAC8D0];
  if (CLMicroLocationModel::isValid(this))
  {
    if (*((_DWORD *)v7 + 1) == 3)
    {
      if (*(_BYTE *)(a3 + 32))
      {
        *a5 = 0;
        a5[1] = 0;
        a5[2] = 0;
        *((_DWORD *)a5 + 6) = 3;
        *((_BYTE *)a5 + 80) = 0;
        a5[5] = 0;
        a5[6] = 0;
        a5[4] = 0;
        *((_BYTE *)a5 + 56) = 0;
        +[ULDefaultsSingleton shared](ULDefaultsSingleton, "shared");
        v9 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v9, "defaultsDictionary");
        v10 = (void *)objc_claimAutoreleasedReturnValue();

        objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "ULBlueAtlasAssociatedAccessPointLocalizerEnabled");
        v11 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v10, "objectForKey:", v11);
        v12 = (void *)objc_claimAutoreleasedReturnValue();
        v13 = 0x24BDD1000uLL;
        if (v12 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
          v14 = objc_msgSend(v12, "BOOLValue");
        else
          v14 = objc_msgSend(MEMORY[0x24BDBD1C8], "BOOLValue");
        v15 = v14;

        v16 = 0.0;
        if (v15)
        {
          std::__optional_copy_base<CLMicroLocationProto::AssociatedAccessPointInfo,false>::__optional_copy_base[abi:ne180100]((CLMicroLocationProto::AssociatedAccessPointInfo *)v150, (const CLMicroLocationProto::AssociatedAccessPointInfo *)a4);
          isValidAssociatedAccessPointBasedDecision = CLMicroLocationBlueAtlasLocalizationAlgorithm::isValidAssociatedAccessPointBasedDecision((uint64_t)v7, (uint64_t)v150);
          v18 = isValidAssociatedAccessPointBasedDecision;
          if (v150[32])
          {
            CLMicroLocationProto::AssociatedAccessPointInfo::~AssociatedAccessPointInfo((CLMicroLocationProto::AssociatedAccessPointInfo *)v150);
            if (v18)
              goto LABEL_11;
          }
          else if (isValidAssociatedAccessPointBasedDecision)
          {
LABEL_11:
            if (onceToken_MicroLocation_Default != -1)
              dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_26);
            v134 = a3;
            v19 = (id)logObject_MicroLocation_Default;
            if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
            {
              if (!*((_BYTE *)v7 + 288) || !*((_BYTE *)v7 + 272))
                std::__throw_bad_optional_access[abi:ne180100]();
              v20 = (CLMacAddress *)v7;
              v21 = *((unsigned int *)v7 + 1);
              v22 = v20;
              CLMacAddress::toCLStr(v20 + 33, &__p);
              if (!*(_BYTE *)(a4 + 32) || !LOBYTE(v22[36].var0))
                std::__throw_bad_optional_access[abi:ne180100]();
              p_p = &__p;
              if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
                p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
              v24 = *(float *)(a4 + 16);
              v25 = (uint64_t)(v22[26].var0 - v22[25].var0) >> 4;
              *(_DWORD *)buf = 68290051;
              *(_WORD *)&buf[8] = 2082;
              *(_DWORD *)&buf[4] = 0;
              *(_QWORD *)&buf[10] = "";
              *(_WORD *)&buf[18] = 2050;
              *(_QWORD *)&buf[20] = v21;
              *(_WORD *)&buf[28] = 2081;
              *(_QWORD *)&buf[30] = p_p;
              v164 = 2050;
              *(double *)v165 = v24;
              *(_WORD *)&v165[8] = 2050;
              *(_QWORD *)&v165[10] = v25;
              _os_log_impl(&dword_2419D9000, v19, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"localizationRequestResultsPerModel, found matching strong associated AP\", \"ModelType\":%{public}lu, \"MAC Address\":%{private, location:escape_only}s, \"Rssi\":\"%{public}f\", \"Num labels\":%{public}lu}", buf, 0x3Au);
              if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
                operator delete(__p.__r_.__value_.__l.__data_);
              v7 = (CLMicroLocationModel *)v22;
            }

            *((_DWORD *)a5 + 6) = 3;
            if (!*((_BYTE *)v7 + 288))
              std::__throw_bad_optional_access[abi:ne180100]();
            v27 = (uint64_t *)*((_QWORD *)v7 + 25);
            v28 = (uint64_t *)*((_QWORD *)v7 + 26);
            v139 = v7;
            if (v27 != v28)
            {
              v29 = a5 + 2;
              v30 = a5[1];
              do
              {
                v32 = *v27;
                v31 = v27[1];
                if ((unint64_t)v30 >= *v29)
                {
                  v33 = (v30 - *a5) >> 5;
                  if ((unint64_t)(v33 + 1) >> 59)
                    std::vector<CLMicroLocationProto::ConfidenceReason>::__throw_length_error[abi:ne180100]();
                  v34 = *v29 - (_QWORD)*a5;
                  v35 = v34 >> 4;
                  if (v34 >> 4 <= (unint64_t)(v33 + 1))
                    v35 = v33 + 1;
                  if ((unint64_t)v34 >= 0x7FFFFFFFFFFFFFE0)
                    v36 = 0x7FFFFFFFFFFFFFFLL;
                  else
                    v36 = v35;
                  v37 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<CLMicroLocationResultInternal>>((uint64_t)(a5 + 2), v36);
                  v39 = &v37[32 * v33];
                  *(_QWORD *)v39 = v32;
                  *((_QWORD *)v39 + 1) = v31;
                  *((_QWORD *)v39 + 2) = 0x3FF0000000000000;
                  *((_DWORD *)v39 + 6) = 3;
                  v41 = *a5;
                  v40 = a5[1];
                  v42 = v39;
                  v13 = 0x24BDD1000;
                  if (v40 != *a5)
                  {
                    do
                    {
                      v43 = *((_OWORD *)v40 - 2);
                      *(_OWORD *)(v42 - 20) = *(_OWORD *)(v40 - 20);
                      *((_OWORD *)v42 - 2) = v43;
                      v42 -= 32;
                      v40 -= 32;
                    }
                    while (v40 != v41);
                    v40 = *a5;
                  }
                  v30 = v39 + 32;
                  *a5 = v42;
                  a5[1] = v39 + 32;
                  a5[2] = &v37[32 * v38];
                  if (v40)
                    operator delete(v40);
                }
                else
                {
                  *(_QWORD *)v30 = v32;
                  *((_QWORD *)v30 + 1) = v31;
                  *((_QWORD *)v30 + 2) = 0x3FF0000000000000;
                  *((_DWORD *)v30 + 6) = 3;
                  v30 += 32;
                  v13 = 0x24BDD1000;
                }
                a5[1] = v30;
                v27 += 2;
              }
              while (v27 != v28);
              if (!*((_BYTE *)v7 + 288))
                goto LABEL_54;
            }
            if (*((_QWORD *)v7 + 25) == *((_QWORD *)v7 + 26))
            {
LABEL_54:
              if (onceToken_MicroLocation_Default != -1)
                dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_26);
              v57 = logObject_MicroLocation_Default;
              v52 = 1.0;
              if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)buf = 68289026;
                *(_DWORD *)&buf[4] = 0;
                *(_WORD *)&buf[8] = 2082;
                *(_QWORD *)&buf[10] = "";
                _os_log_impl(&dword_2419D9000, v57, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"BlueAtlasLocalization, model with empty Blue Atlas Data, publishing empty results\"}", buf, 0x12u);
              }
LABEL_155:
              v51 = MEMORY[0x24BDBD1C8];
              goto LABEL_53;
            }
            v44 = (uint64_t *)*((_QWORD *)v7 + 41);
            v45 = (uint64_t *)*((_QWORD *)v7 + 42);
            if (v44 == v45)
            {
              v60 = 0.0;
              v61 = 0.0;
              v13 = 0x24BDD1000;
              goto LABEL_120;
            }
            memset(v149, 0, sizeof(v149));
            *(_QWORD *)v156 = v149;
            do
            {
              v46 = *v44;
              std::unordered_set<CLMicroLocationFingerprint::Measurement,CLMicroLocationFingerprint::Measurement::HashMeasurement,CLMicroLocationFingerprint::Measurement::PredicateMeasurement,std::allocator<CLMicroLocationFingerprint::Measurement>>::unordered_set((uint64_t)buf, *v44);
              v47 = *(_OWORD *)(v46 + 40);
              *(_QWORD *)&v165[16] = *(_QWORD *)(v46 + 56);
              *(_OWORD *)v165 = v47;
              std::unordered_set<CLMicroLocationProto::DataType>::unordered_set((uint64_t)&v165[24], v46 + 64);
              std::unordered_map<CLMicroLocationProto::DataType,CLMicroLocationFingerprint::StartAndEndTimestamps>::unordered_map((uint64_t)v169, v46 + 104);
              v48 = *(_OWORD *)(v46 + 144);
              v171 = *(_DWORD *)(v46 + 160);
              v170[1] = v48;
              v173 = 0;
              v174 = 0;
              v172 = 0;
              std::vector<CLMicroLocationProto::ConfidenceReason>::__init_with_size[abi:ne180100]<CLMicroLocationProto::ConfidenceReason*,CLMicroLocationProto::ConfidenceReason*>(&v172, *(const void **)(v46 + 168), *(_QWORD *)(v46 + 176), (uint64_t)(*(_QWORD *)(v46 + 176) - *(_QWORD *)(v46 + 168)) >> 2);
              std::back_insert_iterator<std::vector<CLMicroLocationFingerprint>>::operator=[abi:ne180100]((uint64_t **)v156, (uint64_t)buf);
              if (v172)
              {
                v173 = v172;
                operator delete(v172);
              }
              std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>>>::~__hash_table((uint64_t)v169);
              std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>>>::~__hash_table((uint64_t)&v165[24]);
              std::__hash_table<CLMicroLocationFingerprint::Measurement,CLMicroLocationFingerprint::Measurement::HashMeasurement,CLMicroLocationFingerprint::Measurement::PredicateMeasurement,std::allocator<CLMicroLocationFingerprint::Measurement>>::~__hash_table((uint64_t)buf);
              v44 += 4;
            }
            while (v44 != v45);
            v146 = 0;
            v147 = 0;
            v148 = 0;
            if (!*((_BYTE *)v7 + 288))
              std::__throw_bad_optional_access[abi:ne180100]();
            v49 = (_QWORD *)*((_QWORD *)v7 + 28);
            v50 = (_QWORD *)*((_QWORD *)v139 + 29);
            while (v49 != v50)
            {
              *(_QWORD *)v156 = *v49;
              *(_QWORD *)buf = CLMacAddress::toUint64((CLMacAddress *)v156);
              *(_DWORD *)&buf[24] = 0;
              std::vector<std::variant<unsigned long long,boost::uuids::uuid,std::string>>::push_back[abi:ne180100](&v146, (uint64_t)buf);
              std::__variant_detail::__dtor<std::__variant_detail::__traits<unsigned long long,boost::uuids::uuid,std::string>,(std::__variant_detail::_Trait)1>::~__dtor((uint64_t)buf);
              ++v49;
            }
            CLMicroLocationFingerprint::CLMicroLocationFingerprint(&__p, v149);
            v58 = (uint64_t *)__p.__r_.__value_.__r.__words[2];
            if (__p.__r_.__value_.__r.__words[2])
            {
              v59 = 0;
              do
              {
                if (*((_DWORD *)v58 + 6) == 1)
                  ++v59;
                v58 = (uint64_t *)*v58;
              }
              while (v58);
            }
            else
            {
              v59 = 0;
            }
            memset(v145, 0, sizeof(v145));
            std::vector<std::variant<unsigned long long,boost::uuids::uuid,std::string>>::__init_with_size[abi:ne180100]<std::variant<unsigned long long,boost::uuids::uuid,std::string>*,std::variant<unsigned long long,boost::uuids::uuid,std::string>*>(v145, v146, v147, (v147 - v146) >> 5);
            CLMicroLocationFingerprint::removeMeasurementsFromSourcesOtherThan(&__p, 1, v145);
            *(_QWORD *)buf = v145;
            std::vector<std::variant<unsigned long long,boost::uuids::uuid,std::string>>::__destroy_vector::operator()[abi:ne180100]((void ***)buf);
            std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)buf);
            v63 = (uint64_t *)__p.__r_.__value_.__r.__words[2];
            if (__p.__r_.__value_.__r.__words[2])
            {
              v64 = 1;
              do
              {
                if (*((_DWORD *)v63 + 6) == 1)
                {
                  if (*((_DWORD *)v63 + 14))
                    std::__throw_bad_variant_access[abi:ne180100]();
                  v153.var0 = CLMacAddress::newFromUint64((CLMacAddress *)v63[4], v62);
                  if ((v64 & 1) == 0)
                    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&buf[16], (uint64_t)", ", 2);
                  CLMacAddress::toPrettyStr(&v153, (std::string *)v156);
                  if (v156[23] >= 0)
                    v65 = v156;
                  else
                    v65 = *(_BYTE **)v156;
                  if (v156[23] >= 0)
                    v66 = v156[23];
                  else
                    v66 = *(_QWORD *)&v156[8];
                  v67 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&buf[16], (uint64_t)v65, v66);
                  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v67, (uint64_t)" (", 2);
                  v68 = (_QWORD *)std::ostream::operator<<();
                  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v68, (uint64_t)")", 1);
                  if ((v156[23] & 0x80000000) != 0)
                    operator delete(*(void **)v156);
                  v64 = 0;
                }
                v63 = (uint64_t *)*v63;
              }
              while (v63);
            }
            if (onceToken_MicroLocation_Default != -1)
              dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_26);
            v69 = v139;
            v13 = 0x24BDD1000;
            v70 = (id)logObject_MicroLocation_Default;
            if (os_log_type_enabled(v70, OS_LOG_TYPE_DEFAULT))
            {
              v72 = v146;
              v71 = v147;
              v73 = v176;
              std::stringbuf::str();
              if (v154 >= 0)
                var0 = (unint64_t)&v153;
              else
                var0 = v153.var0;
              *(_DWORD *)v156 = 68290050;
              *(_DWORD *)&v156[4] = 0;
              *(_WORD *)&v156[8] = 2082;
              *(_QWORD *)&v156[10] = "";
              *(_WORD *)&v156[18] = 2050;
              *(_QWORD *)&v156[20] = (v71 - v72) >> 5;
              v157 = 2050;
              v158 = v59;
              v159 = 2050;
              v160 = v73;
              v161 = 2082;
              v162 = var0;
              _os_log_impl(&dword_2419D9000, v70, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"BlueAtlasLocalization - Model Super fingerprint\", \"num dominant sources\":%{public}lu, \"super fingerprint size before filtering dominant sources\":%{public}lu, \"super fingerprint size\":%{public}lu, \"values\":%{public, location:escape_only}s}", v156, 0x3Au);
              if (v154 < 0)
                operator delete((void *)v153.var0);
              v69 = v139;
            }

            if (!*(_BYTE *)(v134 + 32))
              std::__throw_bad_optional_access[abi:ne180100]();
            std::__function::__value_func<double ()(CLMicroLocationFingerprint const&,CLMicroLocationFingerprint const&)>::__value_func[abi:ne180100]((uint64_t)&v153, v134);
            if (!v155)
              std::__throw_bad_function_call[abi:ne180100]();
            v60 = (*(double (**)(CLMacAddress *, std::string *, const CLMicroLocationModel *))(v155->var0 + 48))(v155, &__p, a2);
            if (onceToken_MicroLocation_Default != -1)
              dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_26);
            v75 = (id)logObject_MicroLocation_Default;
            if (os_log_type_enabled(v75, OS_LOG_TYPE_DEFAULT))
            {
              if (!*((_BYTE *)v69 + 288))
                std::__throw_bad_optional_access[abi:ne180100]();
              v76 = (uint64_t)(*((_QWORD *)v69 + 26) - *((_QWORD *)v69 + 25)) >> 4;
              *(_DWORD *)v156 = 68289794;
              *(_DWORD *)&v156[4] = 0;
              *(_WORD *)&v156[8] = 2082;
              *(_QWORD *)&v156[10] = "";
              *(_WORD *)&v156[18] = 2050;
              *(double *)&v156[20] = v60;
              v157 = 2050;
              v158 = 0;
              v159 = 2050;
              v160 = v76;
              _os_log_impl(&dword_2419D9000, v75, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"BlueAtlasLocalization\", \"euclideanDistance\":\"%{public}f\", \"euclideanScore\":\"%{public}f\", \"Num labels\":%{public}lu}", v156, 0x30u);
            }

            +[ULDefaultsSingleton shared](ULDefaultsSingleton, "shared");
            v77 = (void *)objc_claimAutoreleasedReturnValue();
            objc_msgSend(v77, "defaultsDictionary");
            v78 = (void *)objc_claimAutoreleasedReturnValue();

            objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "ULBlueAtlasLocalizerEuclideanThresholds");
            v79 = (void *)objc_claimAutoreleasedReturnValue();
            objc_msgSend(v78, "objectForKey:", v79);
            v80 = (void *)objc_claimAutoreleasedReturnValue();
            if (v80 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
            {
              ULSettings::convert<NSArray<NSNumber *> * {__strong},std::vector<double>>(v80, (uint64_t)v156);
              v135 = *(void **)v156;
              v143 = *(_OWORD *)v156;
              v81 = *(_QWORD *)&v156[16];
            }
            else
            {
              ULSettings::convert<std::initializer_list<double>,std::vector<double>>((uint64_t *)&_ZGRN10ULSettings14SettingsTraitsINS_37BlueAtlasLocalizerEuclideanThresholdsEE12defaultValueE_, 2uLL, (uint64_t)v156);
              v81 = *(_QWORD *)&v156[16];
              v135 = *(void **)v156;
              v143 = *(_OWORD *)v156;
            }
            v144 = v81;

            v82 = v135;
            +[ULDefaultsSingleton shared](ULDefaultsSingleton, "shared");
            v83 = (void *)objc_claimAutoreleasedReturnValue();
            objc_msgSend(v83, "defaultsDictionary");
            v84 = (void *)objc_claimAutoreleasedReturnValue();

            objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "ULBlueAtlasLocalizerEuclideanSimilarityScores");
            v85 = (void *)objc_claimAutoreleasedReturnValue();
            objc_msgSend(v84, "objectForKey:", v85);
            v86 = (void *)objc_claimAutoreleasedReturnValue();
            if (v86 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
            {
              ULSettings::convert<NSArray<NSNumber *> * {__strong},std::vector<double>>(v86, (uint64_t)v156);
              v136 = *(void **)v156;
              v141 = *(_OWORD *)v156;
              v87 = *(_QWORD *)&v156[16];
            }
            else
            {
              ULSettings::convert<std::initializer_list<double>,std::vector<double>>((uint64_t *)&_ZGRN10ULSettings14SettingsTraitsINS_43BlueAtlasLocalizerEuclideanSimilarityScoresEE12defaultValueE_, 2uLL, (uint64_t)v156);
              v87 = *(_QWORD *)&v156[16];
              v136 = *(void **)v156;
              v141 = *(_OWORD *)v156;
            }
            v142 = v87;

            CLMicroLocationBlueAtlasAlgorithms::calculateScoreForValue<double>((double **)&v143, (uint64_t *)&v141, 0, v60);
            v61 = v88;
            if (v136)
              operator delete(v136);
            if (v82)
              operator delete(v82);
            v89 = v155;
            if (v155 == &v153)
            {
              v90 = 4;
              v89 = &v153;
            }
            else
            {
              if (!v155)
              {
LABEL_115:
                *(_QWORD *)buf = *MEMORY[0x24BEDB7F0];
                v91 = *(_QWORD *)(MEMORY[0x24BEDB7F0] + 72);
                *(_QWORD *)&buf[*(_QWORD *)(*(_QWORD *)buf - 24)] = *(_QWORD *)(MEMORY[0x24BEDB7F0] + 64);
                *(_QWORD *)&buf[16] = v91;
                *(_QWORD *)&buf[24] = MEMORY[0x24BEDB848] + 16;
                if ((v169[7] & 0x80000000) != 0)
                  operator delete(v168);
                std::streambuf::~streambuf();
                std::iostream::~basic_iostream();
                MEMORY[0x2426A0444](v170);
                if (v179)
                {
                  v180 = v179;
                  operator delete(v179);
                }
                std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>>>::~__hash_table((uint64_t)&v178);
                std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>>>::~__hash_table((uint64_t)&v177);
                std::__hash_table<CLMicroLocationFingerprint::Measurement,CLMicroLocationFingerprint::Measurement::HashMeasurement,CLMicroLocationFingerprint::Measurement::PredicateMeasurement,std::allocator<CLMicroLocationFingerprint::Measurement>>::~__hash_table((uint64_t)&__p);
                *(_QWORD *)buf = &v146;
                std::vector<std::variant<unsigned long long,boost::uuids::uuid,std::string>>::__destroy_vector::operator()[abi:ne180100]((void ***)buf);
                *(_QWORD *)buf = v149;
                std::vector<CLMicroLocationFingerprint>::__destroy_vector::operator()[abi:ne180100]((void ***)buf);
                v7 = v139;
LABEL_120:
                v92 = CLMicroLocationBlueAtlasLocalizationAlgorithm::countSharedAPsInModelAndTestFingerprint(v7, a2, v26);
                +[ULDefaultsSingleton shared](ULDefaultsSingleton, "shared");
                v93 = (void *)objc_claimAutoreleasedReturnValue();
                objc_msgSend(v93, "defaultsDictionary");
                v94 = (void *)objc_claimAutoreleasedReturnValue();

                objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "ULBlueAtlasLocalizerRssiScaleNumberOfAps");
                v95 = (void *)objc_claimAutoreleasedReturnValue();
                objc_msgSend(v94, "objectForKey:", v95);
                v96 = (void *)objc_claimAutoreleasedReturnValue();
                if (v96 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
                {
                  ULSettings::convert<NSArray<NSNumber *> * {__strong},std::vector<double>>(v96, (uint64_t)buf);
                  v137 = *(void **)buf;
                  *(_OWORD *)&__p.__r_.__value_.__l.__data_ = *(_OWORD *)buf;
                  v97 = *(_QWORD *)&buf[16];
                }
                else
                {
                  ULSettings::convert<std::initializer_list<double>,std::vector<double>>((uint64_t *)&_ZGRN10ULSettings14SettingsTraitsINS_38BlueAtlasLocalizerRssiScaleNumberOfApsEE12defaultValueE_, 2uLL, (uint64_t)buf);
                  v97 = *(_QWORD *)&buf[16];
                  v137 = *(void **)buf;
                  *(_OWORD *)&__p.__r_.__value_.__l.__data_ = *(_OWORD *)buf;
                }
                __p.__r_.__value_.__r.__words[2] = v97;

                v98 = v137;
                +[ULDefaultsSingleton shared](ULDefaultsSingleton, "shared");
                v99 = (void *)objc_claimAutoreleasedReturnValue();
                objc_msgSend(v99, "defaultsDictionary");
                v100 = (void *)objc_claimAutoreleasedReturnValue();

                objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "ULBlueAtlasLocalizerRssiScaleFactor");
                v101 = (void *)objc_claimAutoreleasedReturnValue();
                objc_msgSend(v100, "objectForKey:", v101);
                v102 = (void *)objc_claimAutoreleasedReturnValue();
                if (v102 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
                {
                  ULSettings::convert<NSArray<NSNumber *> * {__strong},std::vector<double>>(v102, (uint64_t)buf);
                  v138 = *(void **)buf;
                  *(_OWORD *)v156 = *(_OWORD *)buf;
                  v103 = *(_QWORD *)&buf[16];
                }
                else
                {
                  ULSettings::convert<std::initializer_list<double>,std::vector<double>>((uint64_t *)&_ZGRN10ULSettings14SettingsTraitsINS_33BlueAtlasLocalizerRssiScaleFactorEE12defaultValueE_, 2uLL, (uint64_t)buf);
                  v103 = *(_QWORD *)&buf[16];
                  v138 = *(void **)buf;
                  *(_OWORD *)v156 = *(_OWORD *)buf;
                }
                *(_QWORD *)&v156[16] = v103;

                v104 = (double)v92;
                CLMicroLocationBlueAtlasAlgorithms::calculateScoreForValue<double>((double **)&__p, (uint64_t *)v156, 1, (double)v92);
                v106 = v105;
                if (v138)
                  operator delete(v138);
                if (v98)
                  operator delete(v98);
                v107 = 0.5;
                if (onceToken_MicroLocation_Default != -1)
                {
                  dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_26);
                  v107 = 0.5;
                }
                v16 = v107 + (v61 + -0.5) * v106;
                v108 = (id)logObject_MicroLocation_Default;
                if (os_log_type_enabled(v108, OS_LOG_TYPE_DEFAULT))
                {
                  if (!*((_BYTE *)v7 + 288))
                    std::__throw_bad_optional_access[abi:ne180100]();
                  v109 = (uint64_t)(*((_QWORD *)v7 + 26) - *((_QWORD *)v7 + 25)) >> 4;
                  *(_DWORD *)buf = 68290562;
                  *(_DWORD *)&buf[4] = 0;
                  *(_WORD *)&buf[8] = 2082;
                  *(_QWORD *)&buf[10] = "";
                  *(_WORD *)&buf[18] = 2050;
                  *(double *)&buf[20] = v60;
                  *(_WORD *)&buf[28] = 2050;
                  *(double *)&buf[30] = v61;
                  v164 = 2050;
                  *(double *)v165 = v104;
                  *(_WORD *)&v165[8] = 2050;
                  *(double *)&v165[10] = v106;
                  *(_WORD *)&v165[18] = 2050;
                  *(double *)&v165[20] = v16;
                  v166 = 2050;
                  v167 = v109;
                  _os_log_impl(&dword_2419D9000, v108, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"BlueAtlasLocalization\", \"euclideanDistance\":\"%{public}f\", \"euclideanScore\":\"%{public}f\", \"numSharedAPs\":\"%{public}f\", \"rssiScaleFactor\":\"%{public}f\", \"similarityScore\":\"%{public}f\", \"Num labels\":%{public}lu}", buf, 0x4Eu);
                }

                if (!*((_BYTE *)v7 + 288))
                  std::__throw_bad_optional_access[abi:ne180100]();
                v110 = (uint64_t *)*((_QWORD *)v7 + 25);
                v111 = (uint64_t *)*((_QWORD *)v7 + 26);
                v52 = 1.0;
                if (v110 != v111)
                {
                  v112 = a5 + 2;
                  v113 = a5[1];
                  v51 = MEMORY[0x24BDBD1C8];
                  do
                  {
                    v115 = *v110;
                    v114 = v110[1];
                    if ((unint64_t)v113 >= *v112)
                    {
                      v117 = (v113 - *a5) >> 5;
                      if ((unint64_t)(v117 + 1) >> 59)
                        std::vector<CLMicroLocationProto::ConfidenceReason>::__throw_length_error[abi:ne180100]();
                      v118 = *v112 - (_QWORD)*a5;
                      v119 = v118 >> 4;
                      if (v118 >> 4 <= (unint64_t)(v117 + 1))
                        v119 = v117 + 1;
                      if ((unint64_t)v118 >= 0x7FFFFFFFFFFFFFE0)
                        v120 = 0x7FFFFFFFFFFFFFFLL;
                      else
                        v120 = v119;
                      v121 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<CLMicroLocationResultInternal>>((uint64_t)(a5 + 2), v120);
                      v123 = &v121[32 * v117];
                      v124 = *((_DWORD *)a2 + 40);
                      *(_QWORD *)v123 = v115;
                      *((_QWORD *)v123 + 1) = v114;
                      *((double *)v123 + 2) = v16;
                      *((_DWORD *)v123 + 6) = v124;
                      v126 = *a5;
                      v125 = a5[1];
                      v127 = v123;
                      v13 = 0x24BDD1000;
                      if (v125 != *a5)
                      {
                        do
                        {
                          v128 = *((_OWORD *)v125 - 2);
                          *(_OWORD *)(v127 - 20) = *(_OWORD *)(v125 - 20);
                          *((_OWORD *)v127 - 2) = v128;
                          v127 -= 32;
                          v125 -= 32;
                        }
                        while (v125 != v126);
                        v125 = *a5;
                      }
                      v113 = v123 + 32;
                      *a5 = v127;
                      a5[1] = v123 + 32;
                      a5[2] = &v121[32 * v122];
                      if (v125)
                        operator delete(v125);
                    }
                    else
                    {
                      v116 = *((_DWORD *)a2 + 40);
                      *(_QWORD *)v113 = v115;
                      *((_QWORD *)v113 + 1) = v114;
                      *((double *)v113 + 2) = v16;
                      *((_DWORD *)v113 + 6) = v116;
                      v113 += 32;
                      v13 = 0x24BDD1000;
                    }
                    a5[1] = v113;
                    v110 += 2;
                  }
                  while (v110 != v111);
                  goto LABEL_53;
                }
                goto LABEL_155;
              }
              v90 = 5;
            }
            (*(void (**)(void))(v89->var0 + 8 * v90))();
            goto LABEL_115;
          }
        }
        v51 = MEMORY[0x24BDBD1C0];
        v52 = 0.0;
LABEL_53:
        v152[0] = &unk_2511ED5E8;
        v151[0] = CFSTR("LocalizationEventCount");
        v151[1] = CFSTR("AssociatedApSimilarity");
        objc_msgSend(*(id *)(v13 + 1760), "numberWithDouble:", v52);
        v53 = (void *)objc_claimAutoreleasedReturnValue();
        v152[1] = v53;
        v151[2] = CFSTR("RfSimilarity");
        objc_msgSend(*(id *)(v13 + 1760), "numberWithDouble:", v16);
        v54 = (void *)objc_claimAutoreleasedReturnValue();
        v151[3] = CFSTR("isValidAssociatedAccessPointBasedDecision");
        v152[2] = v54;
        v152[3] = v51;
        objc_msgSend(MEMORY[0x24BDBCE70], "dictionaryWithObjects:forKeys:count:", v152, v151, 4);
        v55 = (NSDictionary *)objc_claimAutoreleasedReturnValue();

        CLMicroLocationBlueAtlasLocalizationAlgorithm::sendBlueAtlasLocalizationAnalytics(v56, v55);
        return;
      }
      CLMicroLocationBlueAtlasLocalizationAlgorithm::localize();
    }
    else
    {
      _CLLogObjectForCategory_MicroLocation_Default();
      v129 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v129, OS_LOG_TYPE_FAULT))
      {
        CLMicroLocationProtobufHelper::modelTypeToString(*((_DWORD *)v7 + 1), &__p);
        v130 = (__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
             ? &__p
             : (std::string *)__p.__r_.__value_.__r.__words[0];
        *(_DWORD *)buf = 68289795;
        *(_DWORD *)&buf[4] = 0;
        *(_WORD *)&buf[8] = 2082;
        *(_QWORD *)&buf[10] = "";
        *(_WORD *)&buf[18] = 2082;
        *(_QWORD *)&buf[20] = v130;
        *(_WORD *)&buf[28] = 2082;
        *(_QWORD *)&buf[30] = "assert";
        v164 = 2081;
        *(_QWORD *)v165 = "model.modelType == CLMicroLocationProto::Model::BLUE_ATLAS";
        _os_log_impl(&dword_2419D9000, v129, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Blue Atlas Localization, model type is not BLUE_ATLAS!\", \"Model Type\":%{public, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x30u);
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
          operator delete(__p.__r_.__value_.__l.__data_);
      }

      _CLLogObjectForCategory_MicroLocation_Default();
      v131 = objc_claimAutoreleasedReturnValue();
      if (os_signpost_enabled(v131))
      {
        CLMicroLocationProtobufHelper::modelTypeToString(*((_DWORD *)v7 + 1), &__p);
        v132 = (__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
             ? &__p
             : (std::string *)__p.__r_.__value_.__r.__words[0];
        *(_DWORD *)buf = 68289795;
        *(_DWORD *)&buf[4] = 0;
        *(_WORD *)&buf[8] = 2082;
        *(_QWORD *)&buf[10] = "";
        *(_WORD *)&buf[18] = 2082;
        *(_QWORD *)&buf[20] = v132;
        *(_WORD *)&buf[28] = 2082;
        *(_QWORD *)&buf[30] = "assert";
        v164 = 2081;
        *(_QWORD *)v165 = "model.modelType == CLMicroLocationProto::Model::BLUE_ATLAS";
        _os_signpost_emit_with_name_impl(&dword_2419D9000, v131, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Blue Atlas Localization, model type is not BLUE_ATLAS!", "{\"msg%{public}.0s\":\"Blue Atlas Localization, model type is not BLUE_ATLAS!\", \"Model Type\":%{public, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x30u);
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
          operator delete(__p.__r_.__value_.__l.__data_);
      }

      _CLLogObjectForCategory_MicroLocation_Default();
      v133 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v133, OS_LOG_TYPE_INFO))
      {
        CLMicroLocationProtobufHelper::modelTypeToString(*((_DWORD *)v7 + 1), &__p);
        CLMicroLocationBlueAtlasLocalizationAlgorithm::localize((char *)&__p, buf, v133);
      }

      abort_report_np();
    }
  }
  else
  {
    CLMicroLocationBlueAtlasLocalizationAlgorithm::localize();
  }
  __break(1u);
}

void sub_241A27F78(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,char a28,uint64_t a29,uint64_t a30,char a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,char a47,uint64_t a48,uint64_t a49,uint64_t a50,void *a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59)
{
  CLMicroLocationAlgorithms::LocalizerResults *v59;
  void *v60;
  void *v61;
  void *v62;
  void *v63;
  _QWORD *v65;
  uint64_t v66;

  if (v60)
    operator delete(v60);
  v65 = (_QWORD *)a50;
  if ((char *)a50 == &a47)
  {
    v66 = 4;
    v65 = &a47;
  }
  else
  {
    if (!a50)
      goto LABEL_8;
    v66 = 5;
  }
  (*(void (**)(void))(*v65 + 8 * v66))();
LABEL_8:
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream((uint64_t)&a59);
  CLMicroLocationFingerprint::~CLMicroLocationFingerprint((CLMicroLocationFingerprint *)&STACK[0x2B0]);
  STACK[0x2B0] = (unint64_t)&a28;
  std::vector<std::variant<unsigned long long,boost::uuids::uuid,std::string>>::__destroy_vector::operator()[abi:ne180100]((void ***)&STACK[0x2B0]);
  STACK[0x2B0] = (unint64_t)&a31;
  std::vector<CLMicroLocationFingerprint>::__destroy_vector::operator()[abi:ne180100]((void ***)&STACK[0x2B0]);
  CLMicroLocationAlgorithms::LocalizerResults::~LocalizerResults(v59);
  _Unwind_Resume(a1);
}

BOOL CLMicroLocationBlueAtlasLocalizationAlgorithm::isValidAssociatedAccessPointBasedDecision(uint64_t a1, uint64_t a2)
{
  BOOL v2;
  unint64_t v4;
  float v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;
  float v10;
  float v11;

  v2 = *(_DWORD *)(a1 + 4) != 3 || *(_BYTE *)(a1 + 288) == 0;
  if (v2 || !*(_BYTE *)(a1 + 272) || !*(_BYTE *)(a2 + 32))
    return 0;
  v4 = CLMacAddress::toUint64((CLMacAddress *)(a1 + 264));
  if (!*(_BYTE *)(a2 + 32))
    std::__throw_bad_optional_access[abi:ne180100]();
  if (v4 != *(_QWORD *)(a2 + 8))
    return 0;
  v5 = *(float *)(a2 + 16);
  +[ULDefaultsSingleton shared](ULDefaultsSingleton, "shared");
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v6, "defaultsDictionary");
  v7 = (void *)objc_claimAutoreleasedReturnValue();

  objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "ULBlueAtlasStrongAssociatedAccessPointThreshold");
  v8 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v7, "objectForKey:", v8);
  v9 = (void *)objc_claimAutoreleasedReturnValue();
  if (!v9)
    goto LABEL_12;
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0)
    objc_msgSend(v9, "floatValue");
  else
LABEL_12:
    objc_msgSend(&unk_2511ECDB8, "floatValue");
  v11 = v10;

  return v5 > v11;
}

void sub_241A2844C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

double **CLMicroLocationBlueAtlasAlgorithms::calculateScoreForValue<double>(double **result, uint64_t *a2, int a3, double a4)
{
  double *v4;
  double *v5;
  uint64_t v6;
  uint64_t v7;
  double *v8;
  double v9;
  _BOOL4 v10;
  double *v11;
  uint64_t v12;
  double v13;
  BOOL v14;
  CLMicroLocationBlueAtlasLocalizationAlgorithm *v15;
  const CLMicroLocationModel *v16;
  const CLMicroLocationFingerprint *v17;

  v5 = *result;
  v4 = result[1];
  v7 = *a2;
  v6 = a2[1];
  if ((char *)v4 - (char *)*result == v6 - *a2)
  {
    if (v5 != v4)
    {
      v8 = v5 + 1;
      while (v8 != v4)
      {
        v9 = *(v8 - 1);
        v10 = *v8 > v9;
        if (!a3)
          v10 = *v8 < v9;
        ++v8;
        if (v10)
        {
          result = (double **)CLMicroLocationBlueAtlasAlgorithms::calculateScoreForValue<double>();
          break;
        }
      }
    }
    if (v5 != v4 && v7 != v6)
    {
      v11 = v5 + 1;
      v12 = v7 + 8;
      do
      {
        v13 = *(v11 - 1);
        if (a3)
        {
          if (v13 < a4)
            return result;
        }
        else if (v13 > a4)
        {
          return result;
        }
        if (v11 == v4)
          break;
        ++v11;
        v14 = v12 == v6;
        v12 += 8;
      }
      while (!v14);
    }
  }
  else
  {
    CLMicroLocationBlueAtlasAlgorithms::calculateScoreForValue<double>();
    return (double **)CLMicroLocationBlueAtlasLocalizationAlgorithm::countSharedAPsInModelAndTestFingerprint(v15, v16, v17);
  }
  return result;
}

uint64_t CLMicroLocationBlueAtlasLocalizationAlgorithm::countSharedAPsInModelAndTestFingerprint(CLMicroLocationBlueAtlasLocalizationAlgorithm *this, const CLMicroLocationModel *a2, const CLMicroLocationFingerprint *a3)
{
  uint64_t v4;
  unint64_t v6;
  uint64_t *v7;
  char v8;
  _QWORD *v9;
  _QWORD *v10;
  _QWORD *v11;
  uint8_t *v12;
  uint64_t v13;
  NSObject *v14;
  void **v15;
  uint64_t v16;
  void *__p[2];
  char v19;
  _QWORD v20[2];
  _QWORD v21[11];
  char v22;
  uint64_t v23;
  _QWORD *v24;
  _QWORD *v25;
  uint64_t v26;
  uint8_t buf[8];
  _BYTE v28[10];
  __int16 v29;
  uint64_t v30;
  __int16 v31;
  void **v32;
  uint64_t v33;

  v33 = *MEMORY[0x24BDAC8D0];
  if (*((_DWORD *)this + 1) != 3 || *((_BYTE *)this + 288) == 0)
    return 0;
  v24 = 0;
  v25 = 0;
  v26 = 0;
  std::vector<CLMacAddress>::__init_with_size[abi:ne180100]<CLMacAddress*,CLMacAddress*>(&v24, *((const void **)this + 28), *((_QWORD *)this + 29), (uint64_t)(*((_QWORD *)this + 29) - *((_QWORD *)this + 28)) >> 3);
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)v20);
  v7 = (uint64_t *)*((_QWORD *)a2 + 2);
  if (v7)
  {
    v4 = 0;
    v8 = 1;
    do
    {
      if (*((_DWORD *)v7 + 6) == 1)
      {
        if (*((_DWORD *)v7 + 14))
          std::__throw_bad_variant_access[abi:ne180100]();
        __p[0] = (void *)CLMacAddress::newFromUint64((CLMacAddress *)v7[4], v6);
        v9 = v24;
        v10 = v25;
        if (v24 == v25)
        {
          v11 = v24;
        }
        else
        {
          while (!CLMacAddress::operator==(v9, __p))
          {
            if (++v9 == v10)
            {
              v9 = v10;
              break;
            }
          }
          v11 = v9;
          v9 = v25;
        }
        if (v11 != v9)
        {
          if ((v8 & 1) == 0)
            std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v21, (uint64_t)", ", 2);
          CLMacAddress::toPrettyStr((CLMacAddress *)__p, (std::string *)buf);
          if ((v30 & 0x80000000) == 0)
            v12 = buf;
          else
            v12 = *(uint8_t **)buf;
          if ((v30 & 0x80000000) == 0)
            v13 = BYTE3(v30);
          else
            v13 = *(_QWORD *)v28;
          std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v21, (uint64_t)v12, v13);
          if (SBYTE3(v30) < 0)
            operator delete(*(void **)buf);
          v8 = 0;
          v4 = (v4 + 1);
        }
      }
      v7 = (uint64_t *)*v7;
    }
    while (v7);
  }
  else
  {
    v4 = 0;
  }
  if (onceToken_MicroLocation_Default != -1)
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_26);
  v14 = (id)logObject_MicroLocation_Default;
  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
  {
    std::stringbuf::str();
    v15 = v19 >= 0 ? __p : (void **)__p[0];
    *(_DWORD *)buf = 68289538;
    *(_DWORD *)&buf[4] = 0;
    *(_WORD *)v28 = 2082;
    *(_QWORD *)&v28[2] = "";
    v29 = 2050;
    v30 = v4;
    v31 = 2082;
    v32 = v15;
    _os_log_impl(&dword_2419D9000, v14, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"countSharedAPsInTestFingerprintAndModel\", \"number of shared APs\":%{public}lu, \"shared AP addresses\":%{public, location:escape_only}s}", buf, 0x26u);
    if (v19 < 0)
      operator delete(__p[0]);
  }

  v20[0] = *MEMORY[0x24BEDB7F0];
  v16 = *(_QWORD *)(MEMORY[0x24BEDB7F0] + 72);
  *(_QWORD *)((char *)v20 + *(_QWORD *)(v20[0] - 24)) = *(_QWORD *)(MEMORY[0x24BEDB7F0] + 64);
  v21[0] = v16;
  v21[1] = MEMORY[0x24BEDB848] + 16;
  if (v22 < 0)
    operator delete((void *)v21[9]);
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x2426A0444](&v23);
  if (v24)
  {
    v25 = v24;
    operator delete(v24);
  }
  return v4;
}

void sub_241A28848(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  void *v5;
  uint64_t v6;
  void *v8;
  va_list va;

  va_start(va, a5);

  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream((uint64_t)va);
  v8 = *(void **)(v6 - 152);
  if (v8)
  {
    *(_QWORD *)(v6 - 144) = v8;
    operator delete(v8);
  }
  _Unwind_Resume(a1);
}

void CLMicroLocationBlueAtlasLocalizationAlgorithm::sendBlueAtlasLocalizationAnalytics(CLMicroLocationBlueAtlasLocalizationAlgorithm *this, NSDictionary *a2)
{
  NSDictionary *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  int v7;
  int v8;
  NSObject *v9;
  NSObject *v10;
  int v11;
  int v12;
  __int16 v13;
  const char *v14;
  __int16 v15;
  uint64_t v16;
  __int16 v17;
  NSDictionary *v18;
  uint64_t v19;

  v19 = *MEMORY[0x24BDAC8D0];
  v2 = a2;
  +[ULDefaultsSingleton shared](ULDefaultsSingleton, "shared");
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v3, "defaultsDictionary");
  v4 = (void *)objc_claimAutoreleasedReturnValue();

  objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "ULAnalyticsSendEventEnabled");
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v4, "objectForKey:", v5);
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  if (v6 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
    v7 = objc_msgSend(v6, "BOOLValue");
  else
    v7 = objc_msgSend(MEMORY[0x24BDBD1C8], "BOOLValue");
  v8 = v7;

  if (v8)
  {
    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_26);
    v9 = (id)logObject_MicroLocation_Default;
    if (os_log_type_enabled(v9, OS_LOG_TYPE_INFO))
    {
      v11 = 68289539;
      v12 = 0;
      v13 = 2082;
      v14 = "";
      v15 = 2081;
      v16 = objc_msgSend(CFSTR("com.apple.MicroLocation.CustomLoiModelLocalize"), "UTF8String");
      v17 = 2113;
      v18 = v2;
      _os_log_impl(&dword_2419D9000, v9, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"BlueAtlasLocalization, sending core analytics\", \"event\":%{private, location:escape_only}s, \"eventFields\":%{private, location:escape_only}@}", (uint8_t *)&v11, 0x26u);
    }

    +[ULSendEvent sendEvent:withEventName:](ULSendEvent, "sendEvent:withEventName:", v2, CFSTR("com.apple.MicroLocation.CustomLoiModelLocalize"));
  }
  else
  {
    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_26);
    v10 = logObject_MicroLocation_Default;
    if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT))
    {
      v11 = 68289026;
      v12 = 0;
      v13 = 2082;
      v14 = "";
      _os_log_impl(&dword_2419D9000, v10, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"BlueAtlasLocalization, CoreAnalytics Disabled\"}", (uint8_t *)&v11, 0x12u);
    }
  }

}

void sub_241A28B00(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void CLMicroLocationBlueAtlasLocalizationAlgorithm::~CLMicroLocationBlueAtlasLocalizationAlgorithm(CLMicroLocationBlueAtlasLocalizationAlgorithm *this)
{
  JUMPOUT(0x2426A04D4);
}

void ___ZL45_CLLogObjectForCategory_MicroLocation_Defaultv_block_invoke_19()
{
  os_log_t v0;
  void *v1;

  v0 = os_log_create("com.apple.MicroLocation", "MicroLocation");
  v1 = (void *)logObject_MicroLocation_Default;
  logObject_MicroLocation_Default = (uint64_t)v0;

}

CLMicroLocationProto::AssociatedAccessPointInfo *std::__optional_copy_base<CLMicroLocationProto::AssociatedAccessPointInfo,false>::__optional_copy_base[abi:ne180100](CLMicroLocationProto::AssociatedAccessPointInfo *this, const CLMicroLocationProto::AssociatedAccessPointInfo *a2)
{
  *(_BYTE *)this = 0;
  *((_BYTE *)this + 32) = 0;
  if (*((_BYTE *)a2 + 32))
  {
    CLMicroLocationProto::AssociatedAccessPointInfo::AssociatedAccessPointInfo(this, a2);
    *((_BYTE *)this + 32) = 1;
  }
  return this;
}

void sub_241A28BDC(_Unwind_Exception *exception_object)
{
  CLMicroLocationProto::AssociatedAccessPointInfo *v1;

  if (*((_BYTE *)v1 + 32))
    CLMicroLocationProto::AssociatedAccessPointInfo::~AssociatedAccessPointInfo(v1);
  _Unwind_Resume(exception_object);
}

void std::__throw_bad_variant_access[abi:ne180100]()
{
  _QWORD *exception;

  exception = __cxa_allocate_exception(8uLL);
  *exception = MEMORY[0x24BEDB8D8] + 16;
  __cxa_throw(exception, MEMORY[0x24BEDB738], (void (*)(void *))std::bad_variant_access::~bad_variant_access);
}

void sub_241A28E0C(_Unwind_Exception *a1)
{
  void *v1;
  uint64_t v2;
  void *v3;
  void *v5;

  v5 = *(void **)v2;
  if (*(_QWORD *)v2)
  {
    *(_QWORD *)(v2 + 8) = v5;
    operator delete(v5);
  }

  _Unwind_Resume(a1);
}

void sub_241A28F78(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t **std::back_insert_iterator<std::vector<CLMicroLocationFingerprint>>::operator=[abi:ne180100](uint64_t **a1, uint64_t a2)
{
  uint64_t *v3;
  unint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;

  v3 = *a1;
  v4 = (*a1)[1];
  v5 = *a1;
  v7 = v5[2];
  v6 = (uint64_t)(v5 + 2);
  if (v4 >= v7)
  {
    v8 = std::vector<CLMicroLocationFingerprint>::__push_back_slow_path<CLMicroLocationFingerprint>(v3, a2);
  }
  else
  {
    std::allocator<CLMicroLocationFingerprint>::construct[abi:ne180100]<CLMicroLocationFingerprint,CLMicroLocationFingerprint>(v6, v4, a2);
    v8 = v4 + 192;
  }
  v3[1] = v8;
  return a1;
}

uint64_t std::vector<CLMicroLocationFingerprint>::__push_back_slow_path<CLMicroLocationFingerprint>(uint64_t *a1, uint64_t a2)
{
  unint64_t v3;
  unint64_t v4;
  unint64_t v6;
  char *v7;
  uint64_t v8;
  void *v10;
  char *v11;
  char *v12;
  char *v13;
  uint64_t *v14;

  v3 = 0xAAAAAAAAAAAAAAABLL * ((a1[1] - *a1) >> 6);
  v4 = v3 + 1;
  if (v3 + 1 > 0x155555555555555)
    std::vector<CLMicroLocationProto::ConfidenceReason>::__throw_length_error[abi:ne180100]();
  if (0x5555555555555556 * ((a1[2] - *a1) >> 6) > v4)
    v4 = 0x5555555555555556 * ((a1[2] - *a1) >> 6);
  if (0xAAAAAAAAAAAAAAABLL * ((a1[2] - *a1) >> 6) >= 0xAAAAAAAAAAAAAALL)
    v6 = 0x155555555555555;
  else
    v6 = v4;
  v14 = a1 + 2;
  if (v6)
    v7 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<CLMicroLocationFingerprint>>((uint64_t)(a1 + 2), v6);
  else
    v7 = 0;
  v10 = v7;
  v11 = &v7[192 * v3];
  v13 = &v7[192 * v6];
  std::allocator<CLMicroLocationFingerprint>::construct[abi:ne180100]<CLMicroLocationFingerprint,CLMicroLocationFingerprint>((uint64_t)(a1 + 2), (uint64_t)v11, a2);
  v12 = v11 + 192;
  std::vector<CLMicroLocationFingerprint>::__swap_out_circular_buffer(a1, &v10);
  v8 = a1[1];
  std::__split_buffer<CLMicroLocationFingerprint>::~__split_buffer(&v10);
  return v8;
}

void sub_241A290F4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__split_buffer<CLMicroLocationFingerprint>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

void std::vector<std::variant<unsigned long long,boost::uuids::uuid,std::string>>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v1;
  void *v2;
  uint64_t v4;
  void *v5;

  v1 = *a1;
  v2 = **a1;
  if (v2)
  {
    v4 = (uint64_t)v1[1];
    v5 = v2;
    if ((void *)v4 != v2)
    {
      do
        v4 = std::__variant_detail::__dtor<std::__variant_detail::__traits<unsigned long long,boost::uuids::uuid,std::string>,(std::__variant_detail::_Trait)1>::~__dtor(v4 - 32);
      while ((void *)v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t std::vector<std::variant<unsigned long long,boost::uuids::uuid,std::string>>::push_back[abi:ne180100](uint64_t *a1, uint64_t a2)
{
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  uint64_t result;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  char *v14;
  char *v15;
  char *v16;
  char *v17;
  char *v18;
  uint64_t v19;

  v6 = a1[2];
  v4 = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(_QWORD *)(v4 - 8);
  if (v7 >= v6)
  {
    v10 = (uint64_t)(v7 - *a1) >> 5;
    if ((unint64_t)(v10 + 1) >> 59)
      std::vector<CLMicroLocationProto::ConfidenceReason>::__throw_length_error[abi:ne180100]();
    v11 = v5 - *a1;
    v12 = v11 >> 4;
    if (v11 >> 4 <= (unint64_t)(v10 + 1))
      v12 = v10 + 1;
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFE0)
      v13 = 0x7FFFFFFFFFFFFFFLL;
    else
      v13 = v12;
    v19 = v4;
    if (v13)
      v14 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<CLMicroLocationResultInternal>>(v4, v13);
    else
      v14 = 0;
    v15 = v14;
    v16 = &v14[32 * v10];
    v18 = &v14[32 * v13];
    std::__variant_detail::__move_constructor<std::__variant_detail::__traits<unsigned long long,boost::uuids::uuid,std::string>,(std::__variant_detail::_Trait)1>::__move_constructor((uint64_t)v16, a2);
    v17 = v16 + 32;
    std::vector<std::variant<unsigned long long,boost::uuids::uuid,std::string>>::__swap_out_circular_buffer(a1, &v15);
    v9 = a1[1];
    result = std::__split_buffer<std::variant<unsigned long long,boost::uuids::uuid,std::string>>::~__split_buffer((uint64_t)&v15);
  }
  else
  {
    result = std::__variant_detail::__move_constructor<std::__variant_detail::__traits<unsigned long long,boost::uuids::uuid,std::string>,(std::__variant_detail::_Trait)1>::__move_constructor(*(_QWORD *)(v4 - 8), a2);
    v9 = v7 + 32;
    a1[1] = v7 + 32;
  }
  a1[1] = v9;
  return result;
}

void sub_241A29264(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__split_buffer<std::variant<unsigned long long,boost::uuids::uuid,std::string>>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t std::__variant_detail::__move_constructor<std::__variant_detail::__traits<unsigned long long,boost::uuids::uuid,std::string>,(std::__variant_detail::_Trait)1>::__move_constructor(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)a1 = 0;
  *(_DWORD *)(a1 + 24) = -1;
  std::__variant_detail::__ctor<std::__variant_detail::__traits<unsigned long long,boost::uuids::uuid,std::string>>::__generic_construct[abi:ne180100]<std::__variant_detail::__move_constructor<std::__variant_detail::__traits<unsigned long long,boost::uuids::uuid,std::string>,(std::__variant_detail::_Trait)1>>(a1, a2);
  return a1;
}

uint64_t std::__variant_detail::__ctor<std::__variant_detail::__traits<unsigned long long,boost::uuids::uuid,std::string>>::__generic_construct[abi:ne180100]<std::__variant_detail::__move_constructor<std::__variant_detail::__traits<unsigned long long,boost::uuids::uuid,std::string>,(std::__variant_detail::_Trait)1>>(uint64_t result, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  char v6;
  char v7;

  v3 = result;
  v4 = *(unsigned int *)(result + 24);
  if ((_DWORD)v4 != -1)
    result = ((uint64_t (*)(char *, uint64_t))off_2511D40A8[v4])(&v7, result);
  *(_DWORD *)(v3 + 24) = -1;
  v5 = *(unsigned int *)(a2 + 24);
  if ((_DWORD)v5 != -1)
  {
    result = ((uint64_t (*)(char *, uint64_t, uint64_t))off_2511D40C0[v5])(&v6, v3, a2);
    *(_DWORD *)(v3 + 24) = v5;
  }
  return result;
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm0ELm0EEE10__dispatchB8ne180100IOZNS0_6__ctorINS0_8__traitsIJyN5boost5uuids4uuidENS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEEEEE19__generic_constructB8ne180100INS0_18__move_constructorISH_LNS0_6_TraitE1EEEEEvRSI_OT_EUlRSO_OT0_E_JRNS0_6__baseILSL_1EJySA_SG_EEEOSW_EEEDcSO_DpT0_(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  *a2 = *a3;
}

__n128 _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm1ELm1EEE10__dispatchB8ne180100IOZNS0_6__ctorINS0_8__traitsIJyN5boost5uuids4uuidENS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEEEEE19__generic_constructB8ne180100INS0_18__move_constructorISH_LNS0_6_TraitE1EEEEEvRSI_OT_EUlRSO_OT0_E_JRNS0_6__baseILSL_1EJySA_SG_EEEOSW_EEEDcSO_DpT0_(uint64_t a1, __n128 *a2, __n128 *a3)
{
  __n128 result;

  result = *a3;
  *a2 = *a3;
  return result;
}

__n128 _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm2ELm2EEE10__dispatchB8ne180100IOZNS0_6__ctorINS0_8__traitsIJyN5boost5uuids4uuidENS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEEEEE19__generic_constructB8ne180100INS0_18__move_constructorISH_LNS0_6_TraitE1EEEEEvRSI_OT_EUlRSO_OT0_E_JRNS0_6__baseILSL_1EJySA_SG_EEEOSW_EEEDcSO_DpT0_(uint64_t a1, __n128 *a2, __n128 *a3)
{
  __n128 result;

  result = *a3;
  a2[1].n128_u64[0] = a3[1].n128_u64[0];
  *a2 = result;
  a3->n128_u64[1] = 0;
  a3[1].n128_u64[0] = 0;
  a3->n128_u64[0] = 0;
  return result;
}

uint64_t std::vector<std::variant<unsigned long long,boost::uuids::uuid,std::string>>::__swap_out_circular_buffer(uint64_t *a1, _QWORD *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t result;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  v5 = *a1;
  v4 = a1[1];
  result = a2[1];
  while (v4 != v5)
  {
    v4 -= 32;
    result = std::__variant_detail::__move_constructor<std::__variant_detail::__traits<unsigned long long,boost::uuids::uuid,std::string>,(std::__variant_detail::_Trait)1>::__move_constructor(result - 32, v4);
  }
  a2[1] = result;
  v7 = *a1;
  *a1 = result;
  a2[1] = v7;
  v8 = a1[1];
  a1[1] = a2[2];
  a2[2] = v8;
  v9 = a1[2];
  a1[2] = a2[3];
  a2[3] = v9;
  *a2 = a2[1];
  return result;
}

uint64_t std::__split_buffer<std::variant<unsigned long long,boost::uuids::uuid,std::string>>::~__split_buffer(uint64_t a1)
{
  uint64_t i;
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 8);
  for (i = *(_QWORD *)(a1 + 16); i != v3; i = *(_QWORD *)(a1 + 16))
  {
    *(_QWORD *)(a1 + 16) = i - 32;
    std::__variant_detail::__dtor<std::__variant_detail::__traits<unsigned long long,boost::uuids::uuid,std::string>,(std::__variant_detail::_Trait)1>::~__dtor(i - 32);
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

_QWORD *std::vector<std::variant<unsigned long long,boost::uuids::uuid,std::string>>::__init_with_size[abi:ne180100]<std::variant<unsigned long long,boost::uuids::uuid,std::string>*,std::variant<unsigned long long,boost::uuids::uuid,std::string>*>(_QWORD *result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  _QWORD *v6;

  if (a4)
  {
    v6 = result;
    std::vector<CLMiLoOdometryTable::Entry>::__vallocate[abi:ne180100](result, a4);
    result = (_QWORD *)std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::variant<unsigned long long,boost::uuids::uuid,std::string>>,std::variant<unsigned long long,boost::uuids::uuid,std::string>*,std::variant<unsigned long long,boost::uuids::uuid,std::string>*,std::variant<unsigned long long,boost::uuids::uuid,std::string>*>((uint64_t)(v6 + 2), a2, a3, v6[1]);
    v6[1] = result;
  }
  return result;
}

void sub_241A294A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  uint64_t v9;
  uint64_t v10;

  *(_QWORD *)(v9 + 8) = v10;
  std::vector<std::variant<unsigned long long,boost::uuids::uuid,std::string>>::__destroy_vector::operator()[abi:ne180100](&a9);
  _Unwind_Resume(a1);
}

uint64_t std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::variant<unsigned long long,boost::uuids::uuid,std::string>>,std::variant<unsigned long long,boost::uuids::uuid,std::string>*,std::variant<unsigned long long,boost::uuids::uuid,std::string>*,std::variant<unsigned long long,boost::uuids::uuid,std::string>*>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7;

  if (a2 != a3)
  {
    v7 = 0;
    do
    {
      std::__variant_detail::__copy_constructor<std::__variant_detail::__traits<unsigned long long,boost::uuids::uuid,std::string>,(std::__variant_detail::_Trait)1>::__copy_constructor(a4 + v7, a2 + v7);
      v7 += 32;
    }
    while (a2 + v7 != a3);
    a4 += v7;
  }
  return a4;
}

void sub_241A2951C(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v4;

  if (v2)
  {
    v4 = v1 - 32;
    do
    {
      std::__variant_detail::__dtor<std::__variant_detail::__traits<unsigned long long,boost::uuids::uuid,std::string>,(std::__variant_detail::_Trait)1>::~__dtor(v4 + v2);
      v2 -= 32;
    }
    while (v2);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::__function::__value_func<double ()(CLMicroLocationFingerprint const&,CLMicroLocationFingerprint const&)>::__value_func[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  v3 = *(_QWORD *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(_QWORD *)(a1 + 24) = a1;
      (*(void (**)(_QWORD, uint64_t))(**(_QWORD **)(a2 + 24) + 24))(*(_QWORD *)(a2 + 24), a1);
    }
    else
    {
      *(_QWORD *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v3 + 16))(v3);
    }
  }
  else
  {
    *(_QWORD *)(a1 + 24) = 0;
  }
  return a1;
}

{
  _QWORD *v3;
  uint64_t v4;

  v3 = (_QWORD *)(a2 + 24);
  v4 = *(_QWORD *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(_QWORD *)(a1 + 24) = a1;
      (*(void (**)(_QWORD, uint64_t))(*(_QWORD *)*v3 + 24))(*v3, a1);
      return a1;
    }
    *(_QWORD *)(a1 + 24) = v4;
  }
  else
  {
    v3 = (_QWORD *)(a1 + 24);
  }
  *v3 = 0;
  return a1;
}

_QWORD *std::vector<CLMacAddress>::__init_with_size[abi:ne180100]<CLMacAddress*,CLMacAddress*>(_QWORD *result, const void *a2, uint64_t a3, unint64_t a4)
{
  _QWORD *v6;
  uint64_t v7;
  size_t v8;

  if (a4)
  {
    v6 = result;
    result = std::vector<CLMicroLocationWiFiChannelHistogram>::__vallocate[abi:ne180100](result, a4);
    v7 = v6[1];
    v8 = a3 - (_QWORD)a2;
    if (v8)
      result = memmove((void *)v6[1], a2, v8);
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_241A29600(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_241A29848(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_241A29B84(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, int a15, char a16, __int16 a17, char a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,void *__p,uint64_t a25)
{
  void *v25;

  _Block_object_dispose(&__p, 8);
  _Unwind_Resume(a1);
}

void CLMicroLocationProtobufHelper::createLoggedEvent<CLMicroLocationProto::DataMigration>(_OWORD *a1@<X0>, int *a2@<X1>, uint64_t a3@<X8>, double a4@<D0>)
{
  const CLMicroLocationProto::DataMigration *v8;
  _BYTE v9[304];

  CLMicroLocationProto::ReceivedEvent::ReceivedEvent((CLMicroLocationProto::ReceivedEvent *)v9);
  CLMicroLocationProtobufHelper::setSpecificLoggedEvent((CLMicroLocationProtobufHelper *)v9, (CLMicroLocationProto::ReceivedEvent *)a2, v8);
  CLMicroLocationLoggedEventsTable::Entry::Entry(a3, a1, a2[2], (CLMicroLocationProto::ReceivedEvent *)v9, a4);
  CLMicroLocationProto::ReceivedEvent::~ReceivedEvent((CLMicroLocationProto::ReceivedEvent *)v9);
}

void sub_241A29CA8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  CLMicroLocationProto::ReceivedEvent::~ReceivedEvent((CLMicroLocationProto::ReceivedEvent *)&a9);
  _Unwind_Resume(a1);
}

void sub_241A2A010(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12)
{
  void *v12;
  void *v13;

  if (__p)
    operator delete(__p);

  _Unwind_Resume(a1);
}

void sub_241A2A2C8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_241A2A45C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, void *a12, uint64_t a13)
{
  void *v13;

  if (__p)
    operator delete(__p);
  if (a12)
    operator delete(a12);

  _Unwind_Resume(a1);
}

void sub_241A2A600(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12)
{
  void *v12;

  if (__p)
    operator delete(__p);

  _Unwind_Resume(a1);
}

void sub_241A2AB48(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, void *__p, uint64_t a14)
{
  void *v14;
  void *v15;
  void *v16;
  void *v17;
  void *v18;

  _Unwind_Resume(a1);
}

void sub_241A2AD60(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_241A2B074(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,id a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,id a28)
{
  void *v28;
  void *v29;
  void *v30;
  void *v31;
  void *v32;

  _Block_object_dispose(&a17, 8);
  _Block_object_dispose(&a23, 8);

  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__5(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__5(uint64_t a1)
{

}

void sub_241A2B54C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_241A2B96C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  void *v11;
  void *v12;
  void *v13;
  void *v14;

  if (__p)
    operator delete(__p);

  _Unwind_Resume(a1);
}

void ___ZL45_CLLogObjectForCategory_MicroLocation_Defaultv_block_invoke_20()
{
  os_log_t v0;
  void *v1;

  v0 = os_log_create("com.apple.MicroLocation", "MicroLocation");
  v1 = (void *)logObject_MicroLocation_Default;
  logObject_MicroLocation_Default = (uint64_t)v0;

}

void sub_241A2BBB4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_241A2BEBC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  if (a20 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void ___ZL45_CLLogObjectForCategory_MicroLocation_Defaultv_block_invoke_21()
{
  os_log_t v0;
  void *v1;

  v0 = os_log_create("com.apple.MicroLocation", "MicroLocation");
  v1 = (void *)logObject_MicroLocation_Default;
  logObject_MicroLocation_Default = (uint64_t)v0;

}

void CLMicroLocationPowerLog::logMetrics(CLMicroLocationPowerLog *this, NSString *a2, NSDictionary *a3)
{
  NSString *v4;
  NSDictionary *v5;
  void *v6;
  uint64_t v7;
  const char *v8;
  NSObject *v9;
  uint32_t v10;
  uint64_t v11;
  int v12;
  NSDictionary *v13;
  uint64_t v14;

  v14 = *MEMORY[0x24BDAC8D0];
  v4 = a2;
  v5 = a3;
  if (+[ULPowerLogBridge ULPowerLogEnabled](ULPowerLogBridge, "ULPowerLogEnabled"))
  {
    objc_msgSend(CFSTR("MiLo"), "stringByAppendingString:", v4);
    v6 = (void *)objc_claimAutoreleasedReturnValue();
    +[ULPowerLogBridge ULPowerLogTimeInsensitive:event:](ULPowerLogBridge, "ULPowerLogTimeInsensitive:event:", v5, v6);

    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_29);
    v7 = logObject_MicroLocation_Default;
    if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEBUG))
    {
      v12 = 138412290;
      v13 = v5;
      v8 = "Wrote microlocation metrics to power log: %@";
      v9 = v7;
      v10 = 12;
LABEL_10:
      _os_log_impl(&dword_2419D9000, v9, OS_LOG_TYPE_DEBUG, v8, (uint8_t *)&v12, v10);
    }
  }
  else
  {
    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_29);
    v11 = logObject_MicroLocation_Default;
    if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEBUG))
    {
      LOWORD(v12) = 0;
      v8 = "PowerLog is not enabled so not writing microlocation metrics";
      v9 = v11;
      v10 = 2;
      goto LABEL_10;
    }
  }

}

void sub_241A2C10C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  v4 = v3;

  _Unwind_Resume(a1);
}

void ___ZL45_CLLogObjectForCategory_MicroLocation_Defaultv_block_invoke_22()
{
  os_log_t v0;
  void *v1;

  v0 = os_log_create("com.apple.MicroLocation", "MicroLocation");
  v1 = (void *)logObject_MicroLocation_Default;
  logObject_MicroLocation_Default = (uint64_t)v0;

}

void sub_241A2C2B4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  void *v15;
  void *v16;
  void *v17;

  if (a15 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

void sub_241A2C540(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  if (a17 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void ___ZL45_CLLogObjectForCategory_MicroLocation_Defaultv_block_invoke_23()
{
  os_log_t v0;
  void *v1;

  v0 = os_log_create("com.apple.MicroLocation", "MicroLocation");
  v1 = (void *)logObject_MicroLocation_Default;
  logObject_MicroLocation_Default = (uint64_t)v0;

}

double CLMiLoServiceManager::CLMiLoServiceManager(uint64_t a1, uint64_t a2, uint64_t a3)
{
  double result;

  *(_QWORD *)a1 = off_2511D41B8;
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 11) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 24) = 0;
  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 40) = a1 + 40;
  *(_QWORD *)(a1 + 72) = 0;
  *(_QWORD *)(a1 + 48) = a1 + 40;
  *(_QWORD *)(a1 + 56) = 0;
  *(_QWORD *)(a1 + 64) = a1 + 72;
  *(_QWORD *)(a1 + 80) = 0;
  *(_QWORD *)(a1 + 88) = a3;
  *(_BYTE *)(a1 + 96) = 0;
  *(_BYTE *)(a1 + 120) = 0;
  *(_QWORD *)(a1 + 128) = a2;
  result = 0.0;
  *(_OWORD *)(a1 + 152) = 0u;
  *(_OWORD *)(a1 + 136) = 0u;
  *(_DWORD *)(a1 + 168) = 1065353216;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 208) = 0u;
  *(_OWORD *)(a1 + 224) = 0u;
  *(_QWORD *)(a1 + 240) = 0;
  return result;
}

void CLMiLoServiceManager::queryServices(uint64_t a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  id v7;
  void *v8;
  uint64_t *v9;
  void *v10;
  uint64_t *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t i;
  void *v15;
  id v16;
  void *v17;
  __objc2_class *v18;
  NSObject *v19;
  uint64_t *v20;
  uint64_t *v21;
  uint64_t v22;
  NSObject *v23;
  __objc2_class *v24;
  uint64_t *v25;
  uint64_t v26;
  _OWORD *v27;
  void *p_p;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  void *v33;
  void *v34;
  id obj;
  void *__p;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  uint64_t *v42;
  uint64_t *v43;
  uint64_t v44;
  void **v45;
  uint8_t buf[8];
  _BYTE v47[20];
  __int16 v48;
  uint64_t v49;
  __int16 v50;
  void *v51;
  _BYTE v52[128];
  uint64_t v53;

  v53 = *MEMORY[0x24BDAC8D0];
  v7 = *(id *)(*(_QWORD *)(a1 + 88) + 96);
  v8 = v7;
  if (v7)
  {
    objc_msgSend(v7, "fetchAllServicesForClientId:andUserId:", a2, a3);
  }
  else
  {
    v42 = 0;
    v43 = 0;
    v44 = 0;
  }

  ULSettings::get<ULSettings::ClientIdLocationdToMilodMapping>();
  v33 = (void *)objc_claimAutoreleasedReturnValue();
  if (*((char *)a2 + 23) >= 0)
    v9 = a2;
  else
    v9 = (uint64_t *)*a2;
  objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", v9);
  v10 = (void *)objc_claimAutoreleasedReturnValue();
  ___ZN20CLMiLoServiceManager13queryServicesERKNSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEES8__block_invoke((uint64_t)v10, v33, v10);
  v34 = (void *)objc_claimAutoreleasedReturnValue();

  v11 = a2;
  if (objc_msgSend(v34, "count"))
  {
    v40 = 0u;
    v41 = 0u;
    v38 = 0u;
    v39 = 0u;
    obj = v34;
    v12 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v38, v52, 16);
    if (v12)
    {
      v13 = *(_QWORD *)v39;
      do
      {
        for (i = 0; i != v12; ++i)
        {
          if (*(_QWORD *)v39 != v13)
            objc_enumerationMutation(obj);
          v15 = *(void **)(*((_QWORD *)&v38 + 1) + 8 * i);
          v16 = *(id *)(*(_QWORD *)(a1 + 88) + 96);
          v17 = v15;
          a2 = v11;
          std::string::basic_string[abi:ne180100]<0>(&__p, (char *)objc_msgSend(objc_retainAutorelease(v17), "UTF8String"));
          if (v16)
          {
            objc_msgSend(v16, "fetchAllServicesForClientId:andUserId:", &__p, a3);
          }
          else
          {
            *(_QWORD *)buf = 0;
            *(_QWORD *)v47 = 0;
            *(_QWORD *)&v47[8] = 0;
          }
          if (SHIBYTE(v37) < 0)
            operator delete(__p);

          if (*(_QWORD *)buf != *(_QWORD *)v47)
          {
            std::vector<CLMiLoServiceTable::Entry>::reserve((uint64_t *)&v42, 0x2E8BA2E8BA2E8BA3 * ((uint64_t)(*(_QWORD *)v47 - *(_QWORD *)buf) >> 3)+ 0x2E8BA2E8BA2E8BA3 * (v43 - v42));
            std::vector<CLMiLoServiceTable::Entry>::__insert_with_size[abi:ne180100]<std::__wrap_iter<CLMiLoServiceTable::Entry*>,std::__wrap_iter<CLMiLoServiceTable::Entry*>>((uint64_t *)&v42, (uint64_t)v43, *(uint64_t *)buf, *(uint64_t *)v47, 0x2E8BA2E8BA2E8BA3 * ((uint64_t)(*(_QWORD *)v47 - *(_QWORD *)buf) >> 3));
          }
          __p = buf;
          std::vector<CLMiLoServiceTable::Entry>::__destroy_vector::operator()[abi:ne180100]((void ***)&__p);
        }
        v12 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v38, v52, 16);
      }
      while (v12);
    }

  }
  *(_QWORD *)a4 = 0;
  *(_QWORD *)(a4 + 8) = 0;
  *(_QWORD *)(a4 + 16) = 0;
  v18 = ULRapportMonitor;
  if (onceToken_MicroLocation_Default != -1)
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_330);
  v19 = logObject_MicroLocation_Default;
  if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT))
  {
    if (*((char *)a2 + 23) >= 0)
      v20 = a2;
    else
      v20 = (uint64_t *)*a2;
    *(_DWORD *)buf = 68289538;
    *(_DWORD *)&buf[4] = 0;
    *(_WORD *)v47 = 2082;
    *(_QWORD *)&v47[2] = "";
    *(_WORD *)&v47[10] = 2082;
    *(_QWORD *)&v47[12] = v20;
    v48 = 2050;
    v49 = 0x2E8BA2E8BA2E8BA3 * (v43 - v42);
    _os_log_impl(&dword_2419D9000, v19, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLMiLoServiceManager Client queried services\", \"ClientId\":%{public, location:escape_only}s, \"NumServicesFound\":%{public}llu}", buf, 0x26u);
  }
  v21 = v42;
  v22 = (uint64_t)v43;
  if (v42 != v43)
  {
    do
    {
      if (v18[97].isa != (__objc2_class *)-1)
        dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_330);
      v23 = (id)logObject_MicroLocation_Default;
      if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
      {
        v24 = v18;
        if (*((char *)a2 + 23) >= 0)
          v25 = a2;
        else
          v25 = (uint64_t *)*a2;
        v26 = *v21;
        v27 = operator new(0x28uLL);
        __p = v27;
        v37 = xmmword_241BB2320;
        *v27 = 0u;
        v27[1] = 0u;
        *(_QWORD *)((char *)v27 + 29) = 0;
        boost::uuids::to_chars<char *>((uint64_t)(v21 + 1), v27);
        p_p = &__p;
        if (v37 < 0)
          p_p = __p;
        *(_DWORD *)buf = 68289794;
        *(_DWORD *)&buf[4] = 0;
        *(_WORD *)v47 = 2082;
        *(_QWORD *)&v47[2] = "";
        *(_WORD *)&v47[10] = 2082;
        *(_QWORD *)&v47[12] = v25;
        v48 = 2050;
        v49 = v26;
        v50 = 2082;
        v51 = p_p;
        _os_log_impl(&dword_2419D9000, v23, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLMiLoServiceManager Client query result\", \"ClientId\":%{public, location:escape_only}s, \"ServiceType\":%{public}llu, \"ServiceUuid\":%{public, location:escape_only}s}", buf, 0x30u);
        if (SHIBYTE(v37) < 0)
          operator delete(__p);
        a2 = v11;
        v18 = v24;
      }

      v21 += 11;
    }
    while (v21 != (uint64_t *)v22);
    v29 = (uint64_t)v42;
    v30 = (uint64_t)v43;
    v45 = (void **)a4;
    while (v29 != v30)
    {
      v31 = v29 + 8;
      CLMiLoService::ServiceDescriptor::ServiceDescriptor((__n128 *)buf, (__n128 *)(v29 + 8), *(_QWORD *)v29, *(unsigned int *)(v29 + 56));
      std::back_insert_iterator<std::vector<CLMiLoService::ServiceDescriptor>>::operator=[abi:ne180100](&v45, buf);
      v29 = v31 + 80;
    }
  }

  *(_QWORD *)buf = &v42;
  std::vector<CLMiLoServiceTable::Entry>::__destroy_vector::operator()[abi:ne180100]((void ***)buf);
}

void sub_241A2CB4C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, void *a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, char *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,char a32,uint64_t a33,uint64_t a34,uint64_t a35,char a36)
{

  __p = &a32;
  std::vector<CLMiLoServiceTable::Entry>::__destroy_vector::operator()[abi:ne180100]((void ***)&__p);
  _Unwind_Resume(a1);
}

id ULSettings::get<ULSettings::ClientIdLocationdToMilodMapping>()
{
  void *v0;
  void *v1;
  void *v2;
  void *v3;
  id v4;

  +[ULDefaultsSingleton shared](ULDefaultsSingleton, "shared");
  v0 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v0, "defaultsDictionary");
  v1 = (void *)objc_claimAutoreleasedReturnValue();

  objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "ULClientIdLocationdToMilodMapping");
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v1, "objectForKey:", v2);
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  if (v3 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
    v4 = v3;
  else
    v4 = &unk_2511EE8C8;

  return v4;
}

void sub_241A2CCF4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

id ___ZN20CLMiLoServiceManager13queryServicesERKNSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEES8__block_invoke(uint64_t a1, void *a2, void *a3)
{
  id v4;
  id v5;
  id v6;
  id v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t i;
  uint64_t v11;
  void *v12;
  int v13;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  _BYTE v19[128];
  uint64_t v20;

  v20 = *MEMORY[0x24BDAC8D0];
  v4 = a2;
  v5 = a3;
  v6 = objc_alloc_init(MEMORY[0x24BDBCEB8]);
  v17 = 0u;
  v18 = 0u;
  v15 = 0u;
  v16 = 0u;
  v7 = v4;
  v8 = objc_msgSend(v7, "countByEnumeratingWithState:objects:count:", &v15, v19, 16);
  if (v8)
  {
    v9 = *(_QWORD *)v16;
    do
    {
      for (i = 0; i != v8; ++i)
      {
        if (*(_QWORD *)v16 != v9)
          objc_enumerationMutation(v7);
        v11 = *(_QWORD *)(*((_QWORD *)&v15 + 1) + 8 * i);
        objc_msgSend(v7, "objectForKey:", v11, (_QWORD)v15);
        v12 = (void *)objc_claimAutoreleasedReturnValue();
        v13 = objc_msgSend(v12, "isEqualToString:", v5);

        if (v13)
          objc_msgSend(v6, "addObject:", v11);
      }
      v8 = objc_msgSend(v7, "countByEnumeratingWithState:objects:count:", &v15, v19, 16);
    }
    while (v8);
  }

  return v6;
}

void sub_241A2CE7C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void **std::vector<CLMiLoServiceTable::Entry>::reserve(uint64_t *a1, unint64_t a2)
{
  void **result;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  void *v7[5];

  v4 = a1[2];
  result = (void **)(a1 + 2);
  if (0x2E8BA2E8BA2E8BA3 * ((v4 - *a1) >> 3) < a2)
  {
    if (a2 >= 0x2E8BA2E8BA2E8BBLL)
      std::vector<CLMicroLocationProto::ConfidenceReason>::__throw_length_error[abi:ne180100]();
    v5 = a1[1] - *a1;
    v7[4] = result;
    v7[0] = std::__allocate_at_least[abi:ne180100]<std::allocator<CLMiLoServiceTable::Entry>>((uint64_t)result, a2);
    v7[1] = (char *)v7[0] + v5;
    v7[2] = (char *)v7[0] + v5;
    v7[3] = (char *)v7[0] + 88 * v6;
    std::vector<CLMiLoServiceTable::Entry>::__swap_out_circular_buffer(a1, v7);
    return std::__split_buffer<CLMiLoServiceTable::Entry>::~__split_buffer(v7);
  }
  return result;
}

void sub_241A2CF64(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__split_buffer<CLMiLoServiceTable::Entry>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

_BYTE *boost::uuids::to_string@<X0>(boost::uuids *this@<X0>, uint64_t a2@<X8>)
{
  char *v5;

  v5 = (char *)operator new(0x28uLL);
  *(_QWORD *)a2 = v5;
  *(_OWORD *)(a2 + 8) = xmmword_241BB2320;
  *(_OWORD *)v5 = 0u;
  *((_OWORD *)v5 + 1) = 0u;
  *(_QWORD *)(v5 + 29) = 0;
  return boost::uuids::to_chars<char *>((uint64_t)this, v5);
}

void sub_241A2D008(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (*(char *)(v1 + 23) < 0)
    operator delete(*(void **)v1);
  _Unwind_Resume(exception_object);
}

void CLMiLoServiceManager::createService(uuid this@<X2:X1>, uuid a2@<0:X3, 8:X4>, uint64_t a3@<X0>, uint64_t a4@<X5>, uint64_t *a5@<X6>, uint64_t a6@<X8>)
{
  unint64_t v8;
  uint64_t *v9;
  char v12;
  id v13;
  void *v14;
  NSObject *v15;
  uint64_t *v16;
  uint64_t v17;
  NSObject *v18;
  uint64_t *v19;
  unint64_t v20;
  uint64_t *v21;
  uint64_t *v22;
  unint64_t v23;
  uint64_t v25;
  uint64_t v26;
  id v27;
  __n128 v28;
  double v29;
  NSObject *v30;
  uint64_t *v31;
  char *v32;
  __int128 v33;
  uint64_t v34;
  NSObject *v35;
  uint64_t *v36;
  NSObject *v37;
  char *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  unint64_t v42;
  uint64_t *v43;
  uint64_t *v44;
  uint64_t v45;
  void **v46;
  char v47;
  _BYTE buf[40];
  unint64_t v49;
  __int16 v50;
  char *v51;
  void *__p;
  char v53;
  __n128 v54;
  uint64_t v55;

  v8 = *(_QWORD *)&a2.var0[8];
  v9 = *(uint64_t **)this.var0;
  v55 = *MEMORY[0x24BDAC8D0];
  v54.n128_u64[0] = *(_QWORD *)&this.var0[8];
  v54.n128_u64[1] = *(_QWORD *)a2.var0;
  *(_QWORD *)this.var0 = *(_QWORD *)a2.var0;
  if (!v12)
  {
    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_330);
    v15 = logObject_MicroLocation_Default;
    if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT))
    {
      if (*((char *)v9 + 23) >= 0)
        v16 = v9;
      else
        v16 = (uint64_t *)*v9;
      *(_DWORD *)buf = 68289538;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(_QWORD *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2082;
      *(_QWORD *)&buf[20] = v16;
      *(_WORD *)&buf[28] = 2050;
      *(_QWORD *)&buf[30] = v8;
      _os_log_impl(&dword_2419D9000, v15, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"MiLoServiceManager cannot create service since only static tokens are supported\", \"ClientId\":%{public, location:escape_only}s, \"ServiceType\":%{public}llu}", buf, 0x26u);
    }
    *(_BYTE *)a6 = 0;
    *(_BYTE *)(a6 + 32) = 0;
    v17 = 21;
    goto LABEL_21;
  }
  if (((*(uint64_t (**)(_QWORD))(**(_QWORD **)(a3 + 88) + 16))(*(_QWORD *)(a3 + 88)) & 1) == 0)
  {
    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_330);
    v18 = logObject_MicroLocation_Default;
    if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT))
    {
      if (*((char *)v9 + 23) >= 0)
        v19 = v9;
      else
        v19 = (uint64_t *)*v9;
      *(_DWORD *)buf = 68289538;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(_QWORD *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2082;
      *(_QWORD *)&buf[20] = v19;
      *(_WORD *)&buf[28] = 2050;
      *(_QWORD *)&buf[30] = v8;
      _os_log_impl(&dword_2419D9000, v18, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"MiLoServiceManager cannot create service since database is not available\", \"ClientId\":%{public, location:escape_only}s, \"ServiceType\":%{public}llu}", buf, 0x26u);
    }
    *(_BYTE *)a6 = 0;
    *(_BYTE *)(a6 + 32) = 0;
    v17 = 22;
LABEL_21:
    *(_QWORD *)(a6 + 40) = v17;
    return;
  }
  v13 = *(id *)(*(_QWORD *)(a3 + 88) + 96);
  v14 = v13;
  if (v13)
  {
    objc_msgSend(v13, "fetchAllServicesForClientId:andUserId:", v9, a5);
  }
  else
  {
    v43 = 0;
    v44 = 0;
    v45 = 0;
  }

  v20 = CLMiLoService::locationTypesBitsetFromVector(a4);
  v42 = v20;
  v21 = v43;
  v22 = v44;
  if (v43 == v44)
  {
    v23 = 0;
LABEL_35:
    if (CLMiLoServiceManager::isNewServiceAllowed(v20, v8, v23))
    {
      v27 = *(id *)(*(_QWORD *)(a3 + 88) + 96);
      v28 = v54;
      v29 = cl::chrono::CFAbsoluteTimeClock::now();
      CLMiLoServiceTable::Entry::Entry(buf, v28.n128_u64[0], v28.n128_u64[1], v8, v9, v42, a5, v29);
      v39 = 0;
      v40 = 0;
      v41 = 0;
      v46 = (void **)&v39;
      v47 = 0;
      v39 = (uint64_t)operator new(0x58uLL);
      v40 = v39;
      v41 = v39 + 88;
      v40 = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<CLMiLoServiceTable::Entry>,CLMiLoServiceTable::Entry const*,CLMiLoServiceTable::Entry const*,CLMiLoServiceTable::Entry*>((uint64_t)&v41, (uint64_t)buf, (uint64_t)&v54, v39);
      objc_msgSend(v27, "insertEntries:", &v39);
      v46 = (void **)&v39;
      std::vector<CLMiLoServiceTable::Entry>::__destroy_vector::operator()[abi:ne180100](&v46);
      if (v53 < 0)
        operator delete(__p);
      if (SBYTE5(v51) < 0)
        operator delete(*(void **)&buf[32]);

      if (onceToken_MicroLocation_Default != -1)
        dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_330);
      v30 = (id)logObject_MicroLocation_Default;
      if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
      {
        if (*((char *)v9 + 23) >= 0)
          v31 = v9;
        else
          v31 = (uint64_t *)*v9;
        if (*((char *)a5 + 23) < 0)
          a5 = (uint64_t *)*a5;
        v32 = (char *)operator new(0x28uLL);
        *(_QWORD *)(v32 + 29) = 0;
        *(_OWORD *)v32 = 0u;
        *((_OWORD *)v32 + 1) = 0u;
        boost::uuids::to_chars<char *>((uint64_t)&v54, v32);
        *(_DWORD *)buf = 68290050;
        *(_DWORD *)&buf[4] = 0;
        *(_WORD *)&buf[8] = 2082;
        *(_QWORD *)&buf[10] = "";
        *(_WORD *)&buf[18] = 2082;
        *(_QWORD *)&buf[20] = v31;
        *(_WORD *)&buf[28] = 2082;
        *(_QWORD *)&buf[30] = a5;
        *(_WORD *)&buf[38] = 2050;
        v49 = v8;
        v50 = 2082;
        v51 = v32;
        _os_log_impl(&dword_2419D9000, v30, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"MiLoServiceManager new service created for client\", \"ClientId\":%{public, location:escape_only}s, \"UserId\":%{public, location:escape_only}s, \"ServiceType\":%{public}llu, \"ServiceUuid\":%{public, location:escape_only}s}", buf, 0x3Au);
        operator delete(v32);
      }

      CLMiLoService::ServiceDescriptor::ServiceDescriptor((__n128 *)buf, &v54, v8, v42);
      v33 = *(_OWORD *)&buf[16];
      *(_OWORD *)a6 = *(_OWORD *)buf;
      *(_OWORD *)(a6 + 16) = v33;
      *(_BYTE *)(a6 + 32) = 1;
      v34 = -1;
    }
    else
    {
      if (onceToken_MicroLocation_Default != -1)
        dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_330);
      v35 = logObject_MicroLocation_Default;
      if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT))
      {
        if (*((char *)v9 + 23) >= 0)
          v36 = v9;
        else
          v36 = (uint64_t *)*v9;
        *(_DWORD *)buf = 68289794;
        *(_DWORD *)&buf[4] = 0;
        *(_WORD *)&buf[8] = 2082;
        *(_QWORD *)&buf[10] = "";
        *(_WORD *)&buf[18] = 2082;
        *(_QWORD *)&buf[20] = v36;
        *(_WORD *)&buf[28] = 2050;
        *(_QWORD *)&buf[30] = v8;
        *(_WORD *)&buf[38] = 2050;
        v49 = v23;
        _os_log_impl(&dword_2419D9000, v35, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"MiLoServiceManager Client tried to create service, failed since not allowed\", \"ClientId\":%{public, location:escape_only}s, \"ServiceType\":%{public}llu, \"NumIdenticalServices\":%{public}llu}", buf, 0x30u);
      }
      *(_BYTE *)a6 = 0;
      *(_BYTE *)(a6 + 32) = 0;
      v34 = 21;
    }
  }
  else
  {
    v23 = 0;
    while (1)
    {
      v39 = CLMiLoService::uint64ToLocationTypesBitset(v21[7]);
      v20 = std::__equal_aligned[abi:ne180100]<std::__bitset<1ul,32ul>,true,true>(&v42, 0, (uint64_t)&v42, 0x20u, &v39);
      if (v21[1] == v54.n128_u64[0] && v21[2] == v54.n128_u64[1])
        break;
      v25 = *v21;
      v21 += 11;
      if (v25 == v8)
        v26 = v20;
      else
        v26 = 0;
      v23 += v26;
      if (v21 == v22)
        goto LABEL_35;
    }
    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_330);
    v37 = (id)logObject_MicroLocation_Default;
    if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
    {
      v38 = (char *)operator new(0x28uLL);
      *(_QWORD *)(v38 + 29) = 0;
      *(_OWORD *)v38 = 0u;
      *((_OWORD *)v38 + 1) = 0u;
      boost::uuids::to_chars<char *>((uint64_t)&v54, v38);
      *(_DWORD *)buf = 68289282;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(_QWORD *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2082;
      *(_QWORD *)&buf[20] = v38;
      _os_log_impl(&dword_2419D9000, v37, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"MiLoServiceManager client tried to create an already existing service\", \"ServiceUuid\":%{public, location:escape_only}s}", buf, 0x1Cu);
      operator delete(v38);
    }

    *(_BYTE *)a6 = 0;
    *(_BYTE *)(a6 + 32) = 0;
    v34 = 5;
  }
  *(_QWORD *)(a6 + 40) = v34;
  *(_QWORD *)buf = &v43;
  std::vector<CLMiLoServiceTable::Entry>::__destroy_vector::operator()[abi:ne180100]((void ***)buf);
}

void sub_241A2D6A4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char *a19)
{
  void *v19;
  void *v20;

  operator delete(v20);

  a19 = &a14;
  std::vector<CLMiLoServiceTable::Entry>::__destroy_vector::operator()[abi:ne180100]((void ***)&a19);
  _Unwind_Resume(a1);
}

unint64_t `anonymous namespace'::_findStaticServiceTypeById(_anonymous_namespace_ *this, uuid a2)
{
  char *v2;
  size_t v3;
  uint64_t v4;
  char *v5;
  size_t v6;
  uint64_t v7;
  char *v8;
  size_t v9;
  uint64_t v10;
  char *v11;
  size_t v12;
  uint64_t v13;
  char *v14;
  size_t v15;
  uint64_t v16;
  char *v17;
  size_t v18;
  uint64_t v19;
  char *v20;
  size_t v21;
  uint64_t v22;
  char *v23;
  size_t v24;
  uint64_t v25;
  char *v26;
  size_t v27;
  uint64_t v28;
  char *v29;
  size_t v30;
  uint64_t v31;
  char *v32;
  size_t v33;
  uint64_t v34;
  char *v35;
  size_t v36;
  uint64_t v37;
  char *v38;
  size_t v39;
  uint64_t v40;
  char *v41;
  size_t v42;
  uint64_t v43;
  char *v44;
  size_t v45;
  uint64_t v46;
  char *v47;
  size_t v48;
  uint64_t v49;
  char *v50;
  size_t v51;
  uint64_t v52;
  char *v53;
  size_t v54;
  uint64_t v55;
  char *v56;
  size_t v57;
  uint64_t v58;
  char *v59;
  size_t v60;
  uint64_t v61;
  char *v62;
  size_t v63;
  uint64_t v64;
  _QWORD *v65;
  unint64_t v66;
  uint64_t v67;
  char v69;
  char v70;
  char v71;
  char v72;
  char v73;
  char v74;
  char v75;
  char v76;
  char v77;
  char v78;
  char v79;
  char v80;
  char v81;
  char v82;
  char v83;
  char v84;
  char v85;
  char v86;
  char v87;
  char v88;
  char v89;
  _QWORD v90[5];
  _QWORD v91[63];
  _QWORD v92[3];

  v92[2] = *MEMORY[0x24BDAC8D0];
  v92[0] = this;
  v92[1] = *(_QWORD *)a2.var0;
  v2 = (char *)objc_msgSend(CFSTR("00000000-0000-0000-0000-000000000001"), "UTF8String", *(_QWORD *)&a2.var0[8]);
  v3 = strlen(v2);
  v91[0] = boost::uuids::string_generator::operator()<char const*>((boost::uuids::string_generator *)&v89, (unsigned __int8 *)v2, (unsigned __int8 *)&v2[v3]);
  v91[1] = v4;
  v91[2] = 4;
  v5 = (char *)objc_msgSend(CFSTR("00000000-0000-0000-0000-000000000002"), "UTF8String");
  v6 = strlen(v5);
  v91[3] = boost::uuids::string_generator::operator()<char const*>((boost::uuids::string_generator *)&v88, (unsigned __int8 *)v5, (unsigned __int8 *)&v5[v6]);
  v91[4] = v7;
  v91[5] = 4;
  v8 = (char *)objc_msgSend(CFSTR("00000000-0000-0000-0000-000000000003"), "UTF8String");
  v9 = strlen(v8);
  v91[6] = boost::uuids::string_generator::operator()<char const*>((boost::uuids::string_generator *)&v87, (unsigned __int8 *)v8, (unsigned __int8 *)&v8[v9]);
  v91[7] = v10;
  v91[8] = 4;
  v11 = (char *)objc_msgSend(CFSTR("00000000-0000-0000-0000-000000000004"), "UTF8String");
  v12 = strlen(v11);
  v91[9] = boost::uuids::string_generator::operator()<char const*>((boost::uuids::string_generator *)&v86, (unsigned __int8 *)v11, (unsigned __int8 *)&v11[v12]);
  v91[10] = v13;
  v91[11] = 4;
  v14 = (char *)objc_msgSend(CFSTR("00000000-0000-0000-0000-000000000005"), "UTF8String");
  v15 = strlen(v14);
  v91[12] = boost::uuids::string_generator::operator()<char const*>((boost::uuids::string_generator *)&v85, (unsigned __int8 *)v14, (unsigned __int8 *)&v14[v15]);
  v91[13] = v16;
  v91[14] = 4;
  v17 = (char *)objc_msgSend(CFSTR("00000000-0000-0000-0000-000000000006"), "UTF8String");
  v18 = strlen(v17);
  v91[15] = boost::uuids::string_generator::operator()<char const*>((boost::uuids::string_generator *)&v84, (unsigned __int8 *)v17, (unsigned __int8 *)&v17[v18]);
  v91[16] = v19;
  v91[17] = 4;
  v20 = (char *)objc_msgSend(CFSTR("00000000-0000-0000-0000-000000000007"), "UTF8String");
  v21 = strlen(v20);
  v91[18] = boost::uuids::string_generator::operator()<char const*>((boost::uuids::string_generator *)&v83, (unsigned __int8 *)v20, (unsigned __int8 *)&v20[v21]);
  v91[19] = v22;
  v91[20] = 4;
  v23 = (char *)objc_msgSend(CFSTR("00000000-0000-0000-0000-000000000008"), "UTF8String");
  v24 = strlen(v23);
  v91[21] = boost::uuids::string_generator::operator()<char const*>((boost::uuids::string_generator *)&v82, (unsigned __int8 *)v23, (unsigned __int8 *)&v23[v24]);
  v91[22] = v25;
  v91[23] = 4;
  v26 = (char *)objc_msgSend(CFSTR("00000000-0000-0000-0000-000000000009"), "UTF8String");
  v27 = strlen(v26);
  v91[24] = boost::uuids::string_generator::operator()<char const*>((boost::uuids::string_generator *)&v81, (unsigned __int8 *)v26, (unsigned __int8 *)&v26[v27]);
  v91[25] = v28;
  v91[26] = 4;
  v29 = (char *)objc_msgSend(CFSTR("00000000-0000-0000-0000-000000000010"), "UTF8String");
  v30 = strlen(v29);
  v91[27] = boost::uuids::string_generator::operator()<char const*>((boost::uuids::string_generator *)&v80, (unsigned __int8 *)v29, (unsigned __int8 *)&v29[v30]);
  v91[28] = v31;
  v91[29] = 4;
  v32 = (char *)objc_msgSend(CFSTR("00000000-0000-0000-0000-000000000011"), "UTF8String");
  v33 = strlen(v32);
  v91[30] = boost::uuids::string_generator::operator()<char const*>((boost::uuids::string_generator *)&v79, (unsigned __int8 *)v32, (unsigned __int8 *)&v32[v33]);
  v91[31] = v34;
  v91[32] = 4;
  v35 = (char *)objc_msgSend(CFSTR("00000000-0000-0000-0000-000000000012"), "UTF8String");
  v36 = strlen(v35);
  v91[33] = boost::uuids::string_generator::operator()<char const*>((boost::uuids::string_generator *)&v78, (unsigned __int8 *)v35, (unsigned __int8 *)&v35[v36]);
  v91[34] = v37;
  v91[35] = 1;
  v38 = (char *)objc_msgSend(CFSTR("00000000-0000-0000-0000-000000000013"), "UTF8String");
  v39 = strlen(v38);
  v91[36] = boost::uuids::string_generator::operator()<char const*>((boost::uuids::string_generator *)&v77, (unsigned __int8 *)v38, (unsigned __int8 *)&v38[v39]);
  v91[37] = v40;
  v91[38] = 2;
  v41 = (char *)objc_msgSend(CFSTR("00000000-0000-0000-0000-000000000014"), "UTF8String");
  v42 = strlen(v41);
  v91[39] = boost::uuids::string_generator::operator()<char const*>((boost::uuids::string_generator *)&v76, (unsigned __int8 *)v41, (unsigned __int8 *)&v41[v42]);
  v91[40] = v43;
  v91[41] = 3;
  v44 = (char *)objc_msgSend(CFSTR("00000000-0000-0000-0000-000000000015"), "UTF8String");
  v45 = strlen(v44);
  v91[42] = boost::uuids::string_generator::operator()<char const*>((boost::uuids::string_generator *)&v75, (unsigned __int8 *)v44, (unsigned __int8 *)&v44[v45]);
  v91[43] = v46;
  v91[44] = 4;
  v47 = (char *)objc_msgSend(CFSTR("00000000-0000-0000-0000-000000000016"), "UTF8String");
  v48 = strlen(v47);
  v91[45] = boost::uuids::string_generator::operator()<char const*>((boost::uuids::string_generator *)&v74, (unsigned __int8 *)v47, (unsigned __int8 *)&v47[v48]);
  v91[46] = v49;
  v91[47] = 1;
  v50 = (char *)objc_msgSend(CFSTR("00000000-0000-0000-0000-000000000017"), "UTF8String");
  v51 = strlen(v50);
  v91[48] = boost::uuids::string_generator::operator()<char const*>((boost::uuids::string_generator *)&v73, (unsigned __int8 *)v50, (unsigned __int8 *)&v50[v51]);
  v91[49] = v52;
  v91[50] = 2;
  v53 = (char *)objc_msgSend(CFSTR("00000000-0000-0000-0000-000000000018"), "UTF8String");
  v54 = strlen(v53);
  v91[51] = boost::uuids::string_generator::operator()<char const*>((boost::uuids::string_generator *)&v72, (unsigned __int8 *)v53, (unsigned __int8 *)&v53[v54]);
  v91[52] = v55;
  v91[53] = 4;
  v56 = (char *)objc_msgSend(CFSTR("00000000-0000-0000-0000-000000000019"), "UTF8String");
  v57 = strlen(v56);
  v91[54] = boost::uuids::string_generator::operator()<char const*>((boost::uuids::string_generator *)&v71, (unsigned __int8 *)v56, (unsigned __int8 *)&v56[v57]);
  v91[55] = v58;
  v91[56] = 1;
  v59 = (char *)objc_msgSend(CFSTR("00000000-0000-0000-0000-000000000020"), "UTF8String");
  v60 = strlen(v59);
  v91[57] = boost::uuids::string_generator::operator()<char const*>((boost::uuids::string_generator *)&v70, (unsigned __int8 *)v59, (unsigned __int8 *)&v59[v60]);
  v91[58] = v61;
  v91[59] = 4;
  v62 = (char *)objc_msgSend(CFSTR("00000000-0000-0000-0000-000000000021"), "UTF8String");
  v63 = strlen(v62);
  v91[60] = boost::uuids::string_generator::operator()<char const*>((boost::uuids::string_generator *)&v69, (unsigned __int8 *)v62, (unsigned __int8 *)&v62[v63]);
  v91[61] = v64;
  v91[62] = 4;
  std::unordered_map<boost::uuids::uuid,ULServiceType>::unordered_map((uint64_t)v90, v91, 21);
  v65 = std::__hash_table<std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>>>::find<boost::uuids::uuid>(v90, v92);
  if (v65)
  {
    v66 = v65[4] & 0xFFFFFFFFFFFFFF00;
    v67 = v65[4];
  }
  else
  {
    v67 = 0;
    v66 = 0;
  }
  std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>>>::~__hash_table((uint64_t)v90);
  return v66 | v67;
}

void sub_241A2DC7C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_list va;

  va_start(va, a4);
  std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>>>::~__hash_table((uint64_t)va);
  _Unwind_Resume(a1);
}

BOOL CLMiLoServiceManager::isNewServiceAllowed(uint64_t a1, uint64_t a2, unint64_t a3)
{
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  NSObject *v9;
  NSObject *v10;
  _BOOL8 v11;
  void *v12;
  void *v13;
  void *v14;
  uint64_t v15;
  unint64_t v16;
  NSObject *v17;
  int v19;
  int v20;
  __int16 v21;
  const char *v22;
  __int16 v23;
  uint64_t v24;
  __int16 v25;
  uint64_t v26;
  __int16 v27;
  uint64_t v28;
  __int16 v29;
  _BOOL4 v30;
  uint64_t v31;

  v31 = *MEMORY[0x24BDAC8D0];
  switch(a2)
  {
    case 1:
      +[ULDefaultsSingleton shared](ULDefaultsSingleton, "shared");
      v5 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v5, "defaultsDictionary");
      v6 = (void *)objc_claimAutoreleasedReturnValue();

      objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "ULMaximumNumberOfCreatedUnsupervisedServicesPerClient");
      v7 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v6, "objectForKey:", v7);
      v8 = (void *)objc_claimAutoreleasedReturnValue();
      if (!v8)
        goto LABEL_23;
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) == 0)
        goto LABEL_23;
      goto LABEL_22;
    case 2:
      +[ULDefaultsSingleton shared](ULDefaultsSingleton, "shared");
      v12 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v12, "defaultsDictionary");
      v6 = (void *)objc_claimAutoreleasedReturnValue();

      objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "ULMaximumNumberOfCreatedBinaryRoiServicesPerClient");
      v7 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v6, "objectForKey:", v7);
      v8 = (void *)objc_claimAutoreleasedReturnValue();
      if (v8)
      {
        objc_opt_class();
        if ((objc_opt_isKindOfClass() & 1) != 0)
          goto LABEL_22;
      }
      goto LABEL_23;
    case 3:
      +[ULDefaultsSingleton shared](ULDefaultsSingleton, "shared");
      v13 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v13, "defaultsDictionary");
      v6 = (void *)objc_claimAutoreleasedReturnValue();

      objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "ULMaximumNumberOfCreatedMulticlassServicesPerClient");
      v7 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v6, "objectForKey:", v7);
      v8 = (void *)objc_claimAutoreleasedReturnValue();
      if (v8)
      {
        objc_opt_class();
        if ((objc_opt_isKindOfClass() & 1) != 0)
          goto LABEL_22;
      }
LABEL_23:
      v15 = objc_msgSend(&unk_2511ED648, "unsignedLongValue");
      goto LABEL_25;
    case 4:
      +[ULDefaultsSingleton shared](ULDefaultsSingleton, "shared");
      v14 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v14, "defaultsDictionary");
      v6 = (void *)objc_claimAutoreleasedReturnValue();

      objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "ULMaximumNumberOfCreatedSimilarityListServicesPerClient");
      v7 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v6, "objectForKey:", v7);
      v8 = (void *)objc_claimAutoreleasedReturnValue();
      if (v8 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
LABEL_22:
        v15 = objc_msgSend(v8, "unsignedLongValue");
      else
        v15 = objc_msgSend(&unk_2511ED678, "unsignedLongValue");
LABEL_25:
      v16 = v15;

      v11 = v16 > a3;
      if (onceToken_MicroLocation_Default != -1)
        dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_330);
      v17 = logObject_MicroLocation_Default;
      if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT))
      {
        v19 = 68290050;
        v20 = 0;
        v21 = 2082;
        v22 = "";
        v23 = 2050;
        v24 = a2;
        v25 = 2050;
        v26 = v16;
        v27 = 2050;
        v28 = a3;
        v29 = 1026;
        v30 = v16 > a3;
        _os_log_impl(&dword_2419D9000, v17, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLMiLoServiceManager::isNewServiceAllowed\", \"ServiceType\":%{public}lu, \"Allowed\":%{public}lu, \"AlreadyCreated\":%{public}lu, \"Verdict\":%{public}hhd}", (uint8_t *)&v19, 0x36u);
      }
      break;
    default:
      if (onceToken_MicroLocation_Default != -1)
        dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_330);
      v9 = logObject_MicroLocation_Default;
      if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_ERROR))
      {
        v19 = 68289282;
        v20 = 0;
        v21 = 2082;
        v22 = "";
        v23 = 2050;
        v24 = a2;
        _os_log_impl(&dword_2419D9000, v9, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"unhandled serviceType\", \"ServiceType\":%{public}lu}", (uint8_t *)&v19, 0x1Cu);
      }
      if (onceToken_MicroLocation_Default != -1)
        dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_330);
      v10 = logObject_MicroLocation_Default;
      if (os_signpost_enabled((os_log_t)logObject_MicroLocation_Default))
      {
        v19 = 68289282;
        v20 = 0;
        v21 = 2082;
        v22 = "";
        v23 = 2050;
        v24 = a2;
        _os_signpost_emit_with_name_impl(&dword_2419D9000, v10, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "unhandled serviceType", "{\"msg%{public}.0s\":\"unhandled serviceType\", \"ServiceType\":%{public}lu}", (uint8_t *)&v19, 0x1Cu);
      }
      v11 = 0;
      break;
  }
  return v11;
}

void sub_241A2E178(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void CLMiLoServiceTable::Entry::~Entry(void **this)
{
  if (*((char *)this + 87) < 0)
    operator delete(this[8]);
  if (*((char *)this + 55) < 0)
    operator delete(this[4]);
}

unint64_t CLMiLoServiceManager::deleteService@<X0>(uuid a1@<0:X2, 8:X3>, CLMiLoServiceManager *a2@<X0>, unsigned __int8 *a3@<X1>, uint64_t a4@<X8>)
{
  uint64_t v4;
  uint64_t v5;
  unint64_t result;
  char v10;
  id v11;
  void *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unsigned __int8 *v16;
  unsigned __int8 *v17;
  uint64_t v18;
  void *v19;
  __int128 *v20;
  void *v21;
  void *v22;
  id v23;
  const char *v24;
  size_t v25;
  size_t v26;
  const void *v27;
  NSObject *v28;
  const void *v29;
  char *v30;
  __int128 *v31;
  __int128 v32;
  _BYTE v33[38];
  __int16 v34;
  __int128 *v35;
  unint64_t v36[4];
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  uuid v41;
  uint64_t v42;

  v4 = *(_QWORD *)&a1.var0[8];
  v5 = *(_QWORD *)a1.var0;
  v42 = *MEMORY[0x24BDAC8D0];
  v41 = a1;
  result = CLMiLoServiceManager::loadedServiceByUuid(a2, a1);
  if (v10)
  {
    *(_BYTE *)a4 = 0;
    *(_BYTE *)(a4 + 32) = 0;
    *(_QWORD *)(a4 + 40) = 23;
    return result;
  }
  v11 = *(id *)(*((_QWORD *)a2 + 11) + 96);
  v12 = v11;
  if (v11)
  {
    objc_msgSend(v11, "fetchServiceByUUID:", v5, v4);
  }
  else
  {
    v39 = 0u;
    v40 = 0u;
    v37 = 0u;
    v38 = 0u;
    memset(v36, 0, sizeof(v36));
  }

  if (BYTE8(v40))
  {
    v13 = a3[23];
    if ((v13 & 0x80u) == 0)
      v14 = a3[23];
    else
      v14 = *((_QWORD *)a3 + 1);
    v15 = BYTE7(v38);
    if (SBYTE7(v38) < 0)
      v15 = *((_QWORD *)&v37 + 1);
    if (v14 != v15)
      goto LABEL_24;
    if ((SBYTE7(v38) & 0x80u) == 0)
      v16 = (unsigned __int8 *)&v37;
    else
      v16 = (unsigned __int8 *)v37;
    if ((v13 & 0x80) != 0)
    {
      if (memcmp(*(const void **)a3, v16, *((_QWORD *)a3 + 1)))
        goto LABEL_24;
    }
    else if (a3[23])
    {
      v17 = a3;
      while (*v17 == *v16)
      {
        ++v17;
        ++v16;
        if (!--v13)
          goto LABEL_50;
      }
LABEL_24:
      ULSettings::get<ULSettings::ClientIdLocationdToMilodMapping>();
      v19 = (void *)objc_claimAutoreleasedReturnValue();
      if (!BYTE8(v40))
        std::__throw_bad_optional_access[abi:ne180100]();
      if ((SBYTE7(v38) & 0x80u) == 0)
        v20 = &v37;
      else
        v20 = (__int128 *)v37;
      objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", v20);
      v21 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v19, "objectForKey:", v21);
      v22 = (void *)objc_claimAutoreleasedReturnValue();

      if (!v22)
        goto LABEL_37;
      v23 = objc_retainAutorelease(v22);
      v24 = (const char *)objc_msgSend(v23, "UTF8String");
      v25 = strlen(v24);
      v26 = v25;
      if ((char)a3[23] < 0)
      {
        if (v25 == *((_QWORD *)a3 + 1))
        {
          if (v25 == -1)
            goto LABEL_58;
          v27 = *(const void **)a3;
LABEL_36:
          if (memcmp(v27, v24, v26))
            goto LABEL_37;

          goto LABEL_50;
        }
      }
      else if (v25 == a3[23])
      {
        v27 = a3;
        if (v26 == -1)
LABEL_58:
          std::string::__throw_out_of_range[abi:ne180100]();
        goto LABEL_36;
      }
LABEL_37:
      if (onceToken_MicroLocation_Default != -1)
        dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_330);
      v28 = (id)logObject_MicroLocation_Default;
      if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
      {
        if ((a3[23] & 0x80u) == 0)
          v29 = a3;
        else
          v29 = *(const void **)a3;
        v30 = (char *)operator new(0x28uLL);
        *(_QWORD *)(v30 + 29) = 0;
        *(_OWORD *)v30 = 0u;
        *((_OWORD *)v30 + 1) = 0u;
        boost::uuids::to_chars<char *>((uint64_t)&v41, v30);
        if (!BYTE8(v40))
          std::__throw_bad_optional_access[abi:ne180100]();
        if ((SBYTE7(v38) & 0x80u) == 0)
          v31 = &v37;
        else
          v31 = (__int128 *)v37;
        *(_QWORD *)v33 = 68289794;
        *(_WORD *)&v33[8] = 2082;
        *(_QWORD *)&v33[10] = "";
        *(_WORD *)&v33[18] = 2082;
        *(_QWORD *)&v33[20] = v29;
        *(_WORD *)&v33[28] = 2082;
        *(_QWORD *)&v33[30] = v30;
        v34 = 2082;
        v35 = v31;
        _os_log_impl(&dword_2419D9000, v28, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"MiLoServiceManager cannot delete  service since client unauthorised to delete\", \"ClientId\":%{public, location:escape_only}s, \"ServiceUuid\":%{public, location:escape_only}s, \"Expected ClientId\":%{public, location:escape_only}s}", v33, 0x30u);
        operator delete(v30);
      }

      *(_BYTE *)a4 = 0;
      *(_BYTE *)(a4 + 32) = 0;
      *(_QWORD *)(a4 + 40) = 25;

      return std::__optional_destruct_base<CLMiLoServiceTable::Entry,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)v36);
    }
LABEL_50:
    if (objc_msgSend(*(id *)(*((_QWORD *)a2 + 11) + 96), "deleteServiceForUUID:", *(_QWORD *)v41.var0, *(_QWORD *)&v41.var0[8]))
    {
      if (!BYTE8(v40))
        std::__throw_bad_optional_access[abi:ne180100]();
      CLMiLoService::ServiceDescriptor::ServiceDescriptor((__n128 *)v33, (__n128 *)&v41, v36[0], DWORD2(v38));
      v32 = *(_OWORD *)&v33[16];
      *(_OWORD *)a4 = *(_OWORD *)v33;
      *(_OWORD *)(a4 + 16) = v32;
      *(_BYTE *)(a4 + 32) = 1;
      v18 = -1;
    }
    else
    {
      *(_BYTE *)a4 = 0;
      *(_BYTE *)(a4 + 32) = 0;
      v18 = 26;
    }
    goto LABEL_54;
  }
  *(_BYTE *)a4 = 0;
  *(_BYTE *)(a4 + 32) = 0;
  v18 = 24;
LABEL_54:
  *(_QWORD *)(a4 + 40) = v18;
  return std::__optional_destruct_base<CLMiLoServiceTable::Entry,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)v36);
}

void sub_241A2E634(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15)
{
  if (a2)
    __clang_call_terminate(exception_object);
  _Unwind_Resume(exception_object);
}

unint64_t CLMiLoServiceManager::loadedServiceByUuid(CLMiLoServiceManager *this, uuid a2)
{
  unint64_t v2;
  char *v3;
  char *v4;
  unsigned __int8 v5;
  uint64_t v6;
  uint64_t v7;

  v3 = (char *)this + 40;
  v4 = (char *)*((_QWORD *)this + 6);
  if (v4 == (char *)this + 40)
    return 0;
  v5 = 0;
  do
  {
    v6 = CLMiLoService::uuid((CLMiLoService *)(v4 + 16));
    if (v6 == *(_QWORD *)a2.var0 && v7 == *(_QWORD *)&a2.var0[8])
    {
      v5 = (_BYTE)v4 + 16;
      v2 = (unint64_t)(v4 + 16) >> 8;
    }
    v4 = (char *)*((_QWORD *)v4 + 1);
  }
  while (v4 != v3);
  return v5 | (v2 << 8);
}

uint64_t CLMiLoServiceManager::connect(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  NSObject *v12;
  uint64_t v13;
  char *v14;
  _BYTE *v15;
  uint64_t v16;
  _OWORD *v17;
  void *p_p;
  uuid v19;
  NSObject *v20;
  char *v21;
  uint64_t isClientAllowedToConnect;
  unint64_t StaticServiceTypeById;
  char v25;
  char v26;
  uint64_t v27;
  uint64_t v28;
  int v29;
  unsigned __int8 *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  unsigned __int8 *v34;
  uint64_t v35;
  NSObject *v36;
  uint64_t v37;
  char *v38;
  NSObject *v39;
  char *v40;
  NSObject *v41;
  char *v42;
  __int128 v43;
  char *v44;
  _BYTE *v45;
  char v46;
  char v47;
  NSObject *v48;
  int v49;
  uint64_t v50;
  uint64_t v51;
  void **v52;
  _QWORD *v53;
  char v54;
  NSObject *v55;
  uint64_t v56;
  int v57;
  void **v58;
  void **v59;
  void **v60;
  NSObject *v61;
  int v62;
  void **v63;
  void **v64;
  void **v65;
  _QWORD v66[6];
  void *v67[2];
  char v68;
  void *__p;
  __int128 v70;
  _BYTE buf[38];
  __int16 v72;
  void **v73;
  __int16 v74;
  unint64_t v75;
  _QWORD v76[12];
  _BYTE v77[24];
  _QWORD v78[2];
  unsigned __int8 v79;
  char v80;
  __int128 v81;
  char v82;
  __int128 v83;
  char v84;
  __int128 v85;
  uuid v86;
  uint64_t v87;

  v87 = *MEMORY[0x24BDAC8D0];
  *(_QWORD *)v86.var0 = a3;
  *(_QWORD *)&v86.var0[8] = a4;
  *(_QWORD *)&v85 = a6;
  *((_QWORD *)&v85 + 1) = a7;
  if (onceToken_MicroLocation_Default != -1)
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_330);
  v12 = (id)logObject_MicroLocation_Default;
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
  {
    if (*(char *)(a2 + 23) >= 0)
      v13 = a2;
    else
      v13 = *(_QWORD *)a2;
    v14 = (char *)operator new(0x28uLL);
    *(_QWORD *)v77 = v14;
    *(_OWORD *)&v77[8] = xmmword_241BB2320;
    *(_OWORD *)v14 = 0u;
    *((_OWORD *)v14 + 1) = 0u;
    *(_QWORD *)(v14 + 29) = 0;
    boost::uuids::to_chars<char *>((uint64_t)&v86, v14);
    if (v77[23] >= 0)
      v15 = v77;
    else
      v15 = *(_BYTE **)v77;
    if (*(char *)(a8 + 23) >= 0)
      v16 = a8;
    else
      v16 = *(_QWORD *)a8;
    v17 = operator new(0x28uLL);
    __p = v17;
    v70 = xmmword_241BB2320;
    *v17 = 0u;
    v17[1] = 0u;
    *(_QWORD *)((char *)v17 + 29) = 0;
    boost::uuids::to_chars<char *>((uint64_t)&v85, v17);
    p_p = &__p;
    if (v70 < 0)
      p_p = __p;
    *(_DWORD *)buf = 68290050;
    *(_DWORD *)&buf[4] = 0;
    *(_WORD *)&buf[8] = 2082;
    *(_QWORD *)&buf[10] = "";
    *(_WORD *)&buf[18] = 2082;
    *(_QWORD *)&buf[20] = v13;
    *(_WORD *)&buf[28] = 2082;
    *(_QWORD *)&buf[30] = v15;
    v72 = 2082;
    v73 = (void **)v16;
    v74 = 2082;
    v75 = (unint64_t)p_p;
    _os_log_impl(&dword_2419D9000, v12, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"MiLoServiceManager connection parameters: \", \"ClientId\":%{public, location:escape_only}s, \"ServiceUuid\":%{public, location:escape_only}s, \"UserID\":%{public, location:escape_only}s, \"connectionToken\":%{public, location:escape_only}s}", buf, 0x3Au);
    if (SHIBYTE(v70) < 0)
      operator delete(__p);
    if ((v77[23] & 0x80000000) != 0)
      operator delete(*(void **)v77);
  }

  CLMiLoServiceManager::loadedServiceByUuid((CLMiLoServiceManager *)a1, v86);
  if (v19.var0[0])
  {
    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_330);
    v20 = (id)logObject_MicroLocation_Default;
    if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
    {
      if (*(char *)(a2 + 23) < 0)
        a2 = *(_QWORD *)a2;
      v21 = (char *)operator new(0x28uLL);
      *(_QWORD *)(v21 + 29) = 0;
      *(_OWORD *)v21 = 0u;
      *((_OWORD *)v21 + 1) = 0u;
      boost::uuids::to_chars<char *>((uint64_t)&v86, v21);
      *(_DWORD *)buf = 68289538;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(_QWORD *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2082;
      *(_QWORD *)&buf[20] = a2;
      *(_WORD *)&buf[28] = 2082;
      *(_QWORD *)&buf[30] = v21;
      _os_log_impl(&dword_2419D9000, v20, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"MiLoServiceManager cannot connect to service since service already has active connection\", \"ClientId\":%{public, location:escape_only}s, \"ServiceUuid\":%{public, location:escape_only}s}", buf, 0x26u);
      operator delete(v21);
    }

    return 18;
  }
  *(_QWORD *)v19.var0 = *(_QWORD *)&v86.var0[8];
  v26 = v25;
  if (v25)
  {
    v27 = StaticServiceTypeById;
    if (((*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 88) + 16))(*(_QWORD *)(a1 + 88)) & 1) == 0)
    {
      v83 = *(_OWORD *)a5;
      v84 = *(_BYTE *)(a5 + 16);
      if (CLMiLoServiceManager::addToRequestsAwaitingDb(a1, a2, *(uint64_t *)v86.var0, *(uint64_t *)&v86.var0[8], &v83, v85, *((uint64_t *)&v85 + 1), a8))return -1;
      else
        return 18;
    }
    v81 = *(_OWORD *)a5;
    v82 = *(_BYTE *)(a5 + 16);
    if (CLMiLoServiceManager::migrateLegacyServiceIdToServiceId(a1, *(uint64_t *)v86.var0, *(uint64_t *)&v86.var0[8], (boost::uuids *)&v81))
    {
      CLMiLoServiceManager::findOrCreateServiceEntryWithServiceId(a1, *(uint64_t *)v86.var0, *(uint64_t *)&v86.var0[8], (void **)a2, v27, v26, 1, (uint64_t)v77);
      if (v80)
      {
        v28 = *(_QWORD *)(a1 + 48);
        if (v28 != a1 + 40)
        {
          v29 = 0;
          while (1)
          {
            v30 = (unsigned __int8 *)CLMiLoService::clientId((CLMiLoService *)(v28 + 16));
            v31 = v30[23];
            if ((v31 & 0x80u) == 0)
              v32 = v30[23];
            else
              v32 = *((_QWORD *)v30 + 1);
            v33 = v79;
            if ((v79 & 0x80u) != 0)
              v33 = v78[1];
            if (v32 != v33)
              goto LABEL_50;
            v34 = (v79 & 0x80u) == 0 ? (unsigned __int8 *)v78 : (unsigned __int8 *)v78[0];
            if ((v31 & 0x80) == 0)
              break;
            if (!memcmp(*(const void **)v30, v34, *((_QWORD *)v30 + 1)))
              goto LABEL_49;
LABEL_50:
            v28 = *(_QWORD *)(v28 + 8);
            if (v28 == a1 + 40)
              goto LABEL_78;
          }
          if (v30[23])
          {
            while (*v30 == *v34)
            {
              ++v30;
              ++v34;
              if (!--v31)
                goto LABEL_49;
            }
            goto LABEL_50;
          }
LABEL_49:
          v35 = CLMiLoService::serviceType((CLMiLoService *)(v28 + 16));
          v29 += v35 == *(_QWORD *)v77;
          goto LABEL_50;
        }
        v29 = 0;
LABEL_78:
        CLMiLoServiceManager::migrateLegacyClientIdToClientIdIfNecessary(a1, (uint64_t)v77, (const std::string *)a2);
        v45 = std::__optional_copy_base<CLMiLoServiceTable::Entry,false>::__optional_copy_base[abi:ne180100](v76, (uint64_t)v77);
        isClientAllowedToConnect = CLMiLoServiceManager::isClientAllowedToConnect((uint64_t)v45, v76, (uint64_t *)a2, *(uint64_t *)v86.var0, *(uint64_t *)&v86.var0[8], v29);
        v47 = v46;
        std::__optional_destruct_base<CLMiLoServiceTable::Entry,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)v76);
        if (!v47)
        {
          _CLLogObjectForCategory_MicroLocation_Default();
          v48 = objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v48, OS_LOG_TYPE_DEFAULT))
          {
            v49 = *(char *)(a2 + 23);
            v50 = *(_QWORD *)a2;
            boost::uuids::to_string((boost::uuids *)&v86, (uint64_t)&__p);
            v51 = v49 >= 0 ? a2 : v50;
            v52 = v70 >= 0 ? &__p : (void **)__p;
            *(_DWORD *)buf = 68290050;
            *(_DWORD *)&buf[4] = 0;
            *(_WORD *)&buf[8] = 2082;
            *(_QWORD *)&buf[10] = "";
            *(_WORD *)&buf[18] = 2082;
            *(_QWORD *)&buf[20] = v51;
            *(_WORD *)&buf[28] = 2082;
            *(_QWORD *)&buf[30] = v52;
            v72 = 2050;
            v73 = (void **)*(unsigned int *)v77;
            v74 = 2050;
            v75 = (v29 + 1);
            _os_log_impl(&dword_2419D9000, v48, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"MiLoServiceManager client connected to service\", \"ClientId\":%{public, location:escape_only}s, \"ServiceUuid\":%{public, location:escape_only}s, \"ServiceType\":%{public}lu, \"NumberOfConnectionsToServiceType\":%{public}lu}", buf, 0x3Au);
            if (SHIBYTE(v70) < 0)
              operator delete(__p);
          }

          if (!v80)
            std::__throw_bad_optional_access[abi:ne180100]();
          CLMiLoService::CLMiLoService((uint64_t)buf, a1, (uint64_t)v77, a1 + 8);
          v53 = std::list<CLMiLoService>::emplace_back<CLMiLoService>((uint64_t *)(a1 + 40), (__int128 *)buf);
          CLMiLoService::~CLMiLoService((CLMiLoService *)buf);
          *(uuid *)buf = v86;
          *(_OWORD *)&buf[16] = v85;
          std::__tree<std::pair<boost::uuids::uuid,boost::uuids::uuid>>::__emplace_unique_key_args<std::pair<boost::uuids::uuid,boost::uuids::uuid>,std::pair<boost::uuids::uuid,boost::uuids::uuid>>((uint64_t **)(a1 + 64), (unint64_t *)buf, buf);
          if ((v54 & 1) != 0)
          {
            +[ULTransactionManager shared](ULTransactionManager, "shared");
            v61 = objc_claimAutoreleasedReturnValue();
            v66[0] = MEMORY[0x24BDAC760];
            v66[1] = 3221225472;
            v66[2] = ___ZN20CLMiLoServiceManager7connectERKNSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEEN5boost5uuids4uuidENS0_8optionalISB_EESB_S8__block_invoke;
            v66[3] = &__block_descriptor_48_e5_v8__0l;
            v66[4] = a1;
            v66[5] = v53;
            -[NSObject performUnderTransaction:block:](v61, "performUnderTransaction:block:", CFSTR("com.apple.locationd.microlocation-service-connect"), v66);
            isClientAllowedToConnect = -1;
          }
          else
          {
            _CLLogObjectForCategory_MicroLocation_Default();
            v55 = objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v55, OS_LOG_TYPE_ERROR))
            {
              if (*(char *)(a2 + 23) >= 0)
                v56 = a2;
              else
                v56 = *(_QWORD *)a2;
              boost::uuids::to_string((boost::uuids *)&v86, (uint64_t)&__p);
              v57 = SHIBYTE(v70);
              v58 = (void **)__p;
              boost::uuids::to_string((boost::uuids *)&v85, (uint64_t)v67);
              v59 = &__p;
              if (v57 < 0)
                v59 = v58;
              if (v68 >= 0)
                v60 = v67;
              else
                v60 = (void **)v67[0];
              *(_DWORD *)buf = 68289794;
              *(_DWORD *)&buf[4] = 0;
              *(_WORD *)&buf[8] = 2082;
              *(_QWORD *)&buf[10] = "";
              *(_WORD *)&buf[18] = 2082;
              *(_QWORD *)&buf[20] = v56;
              *(_WORD *)&buf[28] = 2082;
              *(_QWORD *)&buf[30] = v59;
              v72 = 2082;
              v73 = v60;
              _os_log_impl(&dword_2419D9000, v55, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"MiLoServiceManager, failed to insert to fServiceIdToConnectionIdMap\", \"ClientId\":%{public, location:escape_only}s, \"ServiceUuid\":%{public, location:escape_only}s, \"ConnectionToken\":%{public, location:escape_only}s}", buf, 0x30u);
              if (v68 < 0)
                operator delete(v67[0]);
              if (SHIBYTE(v70) < 0)
                operator delete(__p);
            }

            _CLLogObjectForCategory_MicroLocation_Default();
            v61 = objc_claimAutoreleasedReturnValue();
            if (os_signpost_enabled(v61))
            {
              if (*(char *)(a2 + 23) < 0)
                a2 = *(_QWORD *)a2;
              boost::uuids::to_string((boost::uuids *)&v86, (uint64_t)&__p);
              v62 = SHIBYTE(v70);
              v63 = (void **)__p;
              boost::uuids::to_string((boost::uuids *)&v85, (uint64_t)v67);
              v64 = &__p;
              if (v62 < 0)
                v64 = v63;
              if (v68 >= 0)
                v65 = v67;
              else
                v65 = (void **)v67[0];
              *(_DWORD *)buf = 68289794;
              *(_DWORD *)&buf[4] = 0;
              *(_WORD *)&buf[8] = 2082;
              *(_QWORD *)&buf[10] = "";
              *(_WORD *)&buf[18] = 2082;
              *(_QWORD *)&buf[20] = a2;
              *(_WORD *)&buf[28] = 2082;
              *(_QWORD *)&buf[30] = v64;
              v72 = 2082;
              v73 = v65;
              _os_signpost_emit_with_name_impl(&dword_2419D9000, v61, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "MiLoServiceManager, failed to insert to fServiceIdToConnectionIdMap", "{\"msg%{public}.0s\":\"MiLoServiceManager, failed to insert to fServiceIdToConnectionIdMap\", \"ClientId\":%{public, location:escape_only}s, \"ServiceUuid\":%{public, location:escape_only}s, \"ConnectionToken\":%{public, location:escape_only}s}", buf, 0x30u);
              if (v68 < 0)
                operator delete(v67[0]);
              if (SHIBYTE(v70) < 0)
                operator delete(__p);
            }
            isClientAllowedToConnect = 0;
          }

        }
      }
      else
      {
        isClientAllowedToConnect = 19;
      }
      std::__optional_destruct_base<CLMiLoServiceTable::Entry,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)v77);
      return isClientAllowedToConnect;
    }
    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_330);
    v41 = (id)logObject_MicroLocation_Default;
    if (os_log_type_enabled(v41, OS_LOG_TYPE_DEFAULT))
    {
      v42 = (char *)operator new(0x28uLL);
      *(_QWORD *)(v42 + 29) = 0;
      *(_OWORD *)v42 = 0u;
      *((_OWORD *)v42 + 1) = 0u;
      boost::uuids::to_chars<char *>((uint64_t)&v86, v42);
      v43 = 0uLL;
      if (*(_BYTE *)(a5 + 16))
        v43 = *(_OWORD *)a5;
      *(_OWORD *)v77 = v43;
      v44 = (char *)operator new(0x28uLL);
      *(_QWORD *)(v44 + 29) = 0;
      *(_OWORD *)v44 = 0u;
      *((_OWORD *)v44 + 1) = 0u;
      boost::uuids::to_chars<char *>((uint64_t)v77, v44);
      *(_DWORD *)buf = 68289538;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(_QWORD *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2082;
      *(_QWORD *)&buf[20] = v42;
      *(_WORD *)&buf[28] = 2082;
      *(_QWORD *)&buf[30] = v44;
      _os_log_impl(&dword_2419D9000, v41, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"MiLoServiceManager failed to migrate legacy service UUID to static ID\", \"Service UUID\":%{public, location:escape_only}s, \"Legacy service UUID\":%{public, location:escape_only}s}", buf, 0x26u);
      operator delete(v44);
      operator delete(v42);
    }

    return 33;
  }
  else
  {
    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_330);
    v36 = (id)logObject_MicroLocation_Default;
    if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
    {
      if (*(char *)(a2 + 23) >= 0)
        v37 = a2;
      else
        v37 = *(_QWORD *)a2;
      v38 = (char *)operator new(0x28uLL);
      *(_QWORD *)(v38 + 29) = 0;
      *(_OWORD *)v38 = 0u;
      *((_OWORD *)v38 + 1) = 0u;
      boost::uuids::to_chars<char *>((uint64_t)&v86, v38);
      *(_DWORD *)buf = 68289538;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(_QWORD *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2082;
      *(_QWORD *)&buf[20] = v37;
      *(_WORD *)&buf[28] = 2082;
      *(_QWORD *)&buf[30] = v38;
      _os_log_impl(&dword_2419D9000, v36, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"MiLoServiceManager cannot connect to service, only connection with static token is allowed\", \"ClientId\":%{public, location:escape_only}s, \"ServiceUuid\":%{public, location:escape_only}s}", buf, 0x26u);
      operator delete(v38);
    }

    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_330);
    v39 = (id)logObject_MicroLocation_Default;
    if (os_signpost_enabled(v39))
    {
      if (*(char *)(a2 + 23) < 0)
        a2 = *(_QWORD *)a2;
      v40 = (char *)operator new(0x28uLL);
      *(_QWORD *)(v40 + 29) = 0;
      *(_OWORD *)v40 = 0u;
      *((_OWORD *)v40 + 1) = 0u;
      boost::uuids::to_chars<char *>((uint64_t)&v86, v40);
      *(_DWORD *)buf = 68289538;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(_QWORD *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2082;
      *(_QWORD *)&buf[20] = a2;
      *(_WORD *)&buf[28] = 2082;
      *(_QWORD *)&buf[30] = v40;
      _os_signpost_emit_with_name_impl(&dword_2419D9000, v39, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "MiLoServiceManager cannot connect to service, only connection with static token is allowed", "{\"msg%{public}.0s\":\"MiLoServiceManager cannot connect to service, only connection with static token is allowed\", \"ClientId\":%{public, location:escape_only}s, \"ServiceUuid\":%{public, location:escape_only}s}", buf, 0x26u);
      operator delete(v40);
    }

    return 20;
  }
}

void sub_241A2F2B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  void *v25;

  if (a25 < 0)
    operator delete(__p);

  std::__optional_destruct_base<CLMiLoServiceTable::Entry,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)&STACK[0x2A0]);
  _Unwind_Resume(a1);
}

uint64_t CLMiLoServiceManager::addToRequestsAwaitingDb(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, __int128 *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v11;
  uint64_t *v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  const std::string::value_type *v17;
  uint64_t v18;
  BOOL v19;
  const std::string::value_type *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  NSObject *v29;
  _BOOL4 v30;
  uint64_t result;
  NSObject *v32;
  uint64_t v33;
  uint64_t v35;
  _BYTE buf[40];
  __int128 v37;
  char v38;
  __int128 v39;
  std::string __p;
  __int128 v41;
  __int128 v42;
  uint64_t v43;

  v11 = a1;
  v43 = *MEMORY[0x24BDAC8D0];
  *(_QWORD *)&v42 = a3;
  *((_QWORD *)&v42 + 1) = a4;
  *(_QWORD *)&v41 = a6;
  *((_QWORD *)&v41 + 1) = a7;
  v13 = *(_QWORD *)(a1 + 224);
  v14 = *(_QWORD *)(a1 + 232);
  v12 = (uint64_t *)(a1 + 224);
  if (v13 != v14)
  {
    v15 = *(char *)(a2 + 23);
    if (v15 >= 0)
      v16 = *(unsigned __int8 *)(a2 + 23);
    else
      v16 = *(_QWORD *)(a2 + 8);
    if (v15 >= 0)
      v17 = (const std::string::value_type *)a2;
    else
      v17 = *(const std::string::value_type **)a2;
    v18 = *(unsigned __int8 *)(a8 + 23);
    v19 = (v18 & 0x80u) != 0;
    if ((v18 & 0x80u) != 0)
      v18 = *(_QWORD *)(a8 + 8);
    v35 = v18;
    if (v19)
      v20 = *(const std::string::value_type **)a8;
    else
      v20 = (const std::string::value_type *)a8;
    while (1)
    {
      v21 = *(unsigned __int8 *)(v13 + 23);
      if ((v21 & 0x80u) == 0)
        v22 = *(unsigned __int8 *)(v13 + 23);
      else
        v22 = *(_QWORD *)(v13 + 8);
      if (v22 == v16)
      {
        if ((v21 & 0x80) != 0)
        {
          if (!memcmp(*(const void **)v13, v17, *(_QWORD *)(v13 + 8)))
          {
LABEL_24:
            if (*(_QWORD *)(v13 + 24) == (_QWORD)v42
              && *(_QWORD *)(v13 + 32) == *((_QWORD *)&v42 + 1)
              && *(_QWORD *)(v13 + 57) == (_QWORD)v41
              && *(_QWORD *)(v13 + 65) == *((_QWORD *)&v41 + 1))
            {
              v26 = *(unsigned __int8 *)(v13 + 103);
              v27 = (v26 & 0x80u) == 0 ? *(unsigned __int8 *)(v13 + 103) : *(_QWORD *)(v13 + 88);
              if (v27 == v35)
              {
                if ((v26 & 0x80) != 0)
                {
                  if (!memcmp(*(const void **)(v13 + 80), v20, *(_QWORD *)(v13 + 88)))
                  {
LABEL_48:
                    v11 = a1;
                    break;
                  }
                }
                else
                {
                  if (!*(_BYTE *)(v13 + 103))
                    goto LABEL_48;
                  v28 = 0;
                  while (*(unsigned __int8 *)(v13 + v28 + 80) == v20[v28])
                  {
                    if (v26 == ++v28)
                      goto LABEL_48;
                  }
                }
              }
            }
          }
        }
        else
        {
          if (!*(_BYTE *)(v13 + 23))
            goto LABEL_24;
          v23 = 0;
          while (*(unsigned __int8 *)(v13 + v23) == v17[v23])
          {
            if (v21 == ++v23)
              goto LABEL_24;
          }
        }
      }
      v13 += 104;
      if (v13 == v14)
      {
        v11 = a1;
        if ((v15 & 0x80) != 0)
          goto LABEL_55;
LABEL_47:
        *(_OWORD *)buf = *(_OWORD *)a2;
        *(_QWORD *)&buf[16] = *(_QWORD *)(a2 + 16);
        goto LABEL_56;
      }
    }
  }
  if (v13 == v14)
  {
    if ((*(_BYTE *)(a2 + 23) & 0x80) == 0)
      goto LABEL_47;
LABEL_55:
    std::string::__init_copy_ctor_external((std::string *)buf, *(const std::string::value_type **)a2, *(_QWORD *)(a2 + 8));
LABEL_56:
    *(_OWORD *)&buf[24] = v42;
    v37 = *a5;
    v38 = *((_BYTE *)a5 + 16);
    v39 = v41;
    if (*(char *)(a8 + 23) < 0)
      std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)a8, *(_QWORD *)(a8 + 8));
    else
      __p = *(std::string *)a8;
    std::vector<CLMiLoServiceManager::ConnectionRequestParams>::emplace_back<CLMiLoServiceManager::ConnectionRequestParams>(v12, (__int128 *)buf);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p.__r_.__value_.__l.__data_);
    if ((buf[23] & 0x80000000) != 0)
      operator delete(*(void **)buf);
    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_330);
    v32 = logObject_MicroLocation_Default;
    if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT))
    {
      v33 = 0x4EC4EC4EC4EC4EC5 * ((uint64_t)(*(_QWORD *)(v11 + 232) - *(_QWORD *)(v11 + 224)) >> 3);
      *(_DWORD *)buf = 68289282;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(_QWORD *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2050;
      *(_QWORD *)&buf[20] = v33;
      _os_log_impl(&dword_2419D9000, v32, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLMiLoServiceManager adding a pending connection requests\", \"NumRequests cached\":%{public}lu}", buf, 0x1Cu);
    }
    return 1;
  }
  else
  {
    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_330);
    v29 = logObject_MicroLocation_Default;
    v30 = os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT);
    result = 0;
    if (v30)
    {
      *(_DWORD *)buf = 68289026;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(_QWORD *)&buf[10] = "";
      _os_log_impl(&dword_2419D9000, v29, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLMiLoServiceManager adding a pending connection requests failed, request already cached\"}", buf, 0x12u);
      return 0;
    }
  }
  return result;
}

void sub_241A2F7E8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

BOOL CLMiLoServiceManager::migrateLegacyServiceIdToServiceId(uint64_t a1, uint64_t a2, uint64_t a3, boost::uuids *a4)
{
  id v9;
  void *v10;
  char v11;
  id v12;
  void *v13;
  char v14;
  id v15;
  void *v16;
  char v17;
  id v18;
  void *v19;
  char v20;
  NSObject *v21;
  NSObject *v22;
  int v23;
  void **v24;
  void **v25;
  void **v26;
  _BOOL8 result;
  NSObject *v28;
  const char *v29;
  void *__p[2];
  char v31;
  void *v32[2];
  char v33;
  uint8_t buf[4];
  int v35;
  __int16 v36;
  const char *v37;
  __int16 v38;
  void **v39;
  __int16 v40;
  void **v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;

  v44 = *MEMORY[0x24BDAC8D0];
  v42 = a2;
  v43 = a3;
  if (!*((_BYTE *)a4 + 16))
    return 1;
  if (v42 == *(_QWORD *)a4 && v43 == *((_QWORD *)a4 + 1))
    return 1;
  v9 = *(id *)(*(_QWORD *)(a1 + 88) + 96);
  v10 = v9;
  if (!*((_BYTE *)a4 + 16))
    std::__throw_bad_optional_access[abi:ne180100]();
  v11 = objc_msgSend(v9, "updateAllServicesWithMatchingServiceUUID:withNewServiceUUID:", *(_QWORD *)a4, *((_QWORD *)a4 + 1), a2, a3);

  if ((v11 & 1) == 0)
  {
    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_330);
    v28 = logObject_MicroLocation_Default;
    result = os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_FAULT);
    if (!result)
      return result;
    *(_WORD *)buf = 0;
    v29 = "MiLoServiceManager static tokens: updateAllServicesWithMatchingServiceUUID failed";
LABEL_39:
    _os_log_impl(&dword_2419D9000, v28, OS_LOG_TYPE_FAULT, v29, buf, 2u);
    return 0;
  }
  v12 = *(id *)(*(_QWORD *)(a1 + 88) + 72);
  v13 = v12;
  if (!*((_BYTE *)a4 + 16))
    std::__throw_bad_optional_access[abi:ne180100]();
  v14 = objc_msgSend(v12, "updateAllModelsWithMatchingServiceUUID:withNewServiceUUID:", *(_QWORD *)a4, *((_QWORD *)a4 + 1), a2, a3);

  if ((v14 & 1) == 0)
  {
    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_330);
    v28 = logObject_MicroLocation_Default;
    result = os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_FAULT);
    if (!result)
      return result;
    *(_WORD *)buf = 0;
    v29 = "MiLoServiceManager static tokens: updateAllModelsWithMatchingServiceUUID failed";
    goto LABEL_39;
  }
  v15 = *(id *)(*(_QWORD *)(a1 + 88) + 40);
  v16 = v15;
  if (!*((_BYTE *)a4 + 16))
    std::__throw_bad_optional_access[abi:ne180100]();
  v17 = objc_msgSend(v15, "updateAllLabelsWithMatchingServiceUUID:withNewServiceUUID:", *(_QWORD *)a4, *((_QWORD *)a4 + 1), a2, a3);

  if ((v17 & 1) != 0)
  {
    v18 = *(id *)(*(_QWORD *)(a1 + 88) + 104);
    v19 = v18;
    if (!*((_BYTE *)a4 + 16))
      std::__throw_bad_optional_access[abi:ne180100]();
    v20 = objc_msgSend(v18, "updateAllCustomLoiIdsWithMatchingServiceUUID:withNewServiceUUID:", a4, &v42);

    _CLLogObjectForCategory_MicroLocation_Default();
    v21 = objc_claimAutoreleasedReturnValue();
    v22 = v21;
    if ((v20 & 1) != 0)
    {
      if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
      {
        if (!*((_BYTE *)a4 + 16))
          std::__throw_bad_optional_access[abi:ne180100]();
        boost::uuids::to_string(a4, (uint64_t)v32);
        v23 = v33;
        v24 = (void **)v32[0];
        boost::uuids::to_string((boost::uuids *)&v42, (uint64_t)__p);
        v25 = v32;
        if (v23 < 0)
          v25 = v24;
        if (v31 >= 0)
          v26 = __p;
        else
          v26 = (void **)__p[0];
        *(_DWORD *)buf = 68289538;
        v35 = 0;
        v36 = 2082;
        v37 = "";
        v38 = 2082;
        v39 = v25;
        v40 = 2082;
        v41 = v26;
        _os_log_impl(&dword_2419D9000, v22, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"MiLoServiceManager static tokens update completed\", \"legacyServiceIdentifier\":%{public, location:escape_only}s, \"newServiceIdentifier\":%{public, location:escape_only}s}", buf, 0x26u);
        if (v31 < 0)
          operator delete(__p[0]);
        if (v33 < 0)
          operator delete(v32[0]);
      }

      return 1;
    }
    if (os_log_type_enabled(v21, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_2419D9000, v22, OS_LOG_TYPE_FAULT, "MiLoServiceManager static tokens: updateAllCustomLoiIdsWithMatchingServiceUUID failed", buf, 2u);
    }

    return 0;
  }
  if (onceToken_MicroLocation_Default != -1)
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_330);
  v28 = logObject_MicroLocation_Default;
  result = os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_FAULT);
  if (result)
  {
    *(_WORD *)buf = 0;
    v29 = "MiLoServiceManager static tokens: updateAllLabelsWithMatchingServiceUUID failed";
    goto LABEL_39;
  }
  return result;
}

void sub_241A2FBE8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  void *v17;

  if (a17 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

void CLMiLoServiceManager::findOrCreateServiceEntryWithServiceId(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, void **a4@<X3>, uint64_t a5@<X4>, char a6@<W5>, int a7@<W6>, uint64_t a8@<X8>)
{
  id v16;
  void *v17;
  int v18;
  _QWORD *v19;
  uuid v20;
  NSObject *v21;
  id v22;
  void *v23;
  NSObject *v24;
  char *v25;
  void *v26;
  void *v27;
  _QWORD *v28;
  void *__p[6];
  __int128 v30;
  __int128 v31;
  __int128 v32;
  _BYTE v33[40];
  uint64_t v34;
  _QWORD v35[3];
  uuid v36;

  v35[2] = *MEMORY[0x24BDAC8D0];
  v35[0] = a2;
  v35[1] = a3;
  v16 = *(id *)(*(_QWORD *)(a1 + 88) + 96);
  v17 = v16;
  if (v16)
  {
    objc_msgSend(v16, "fetchServiceByUUID:", a2, a3);
  }
  else
  {
    *(_OWORD *)(a8 + 64) = 0u;
    *(_OWORD *)(a8 + 80) = 0u;
    *(_OWORD *)(a8 + 32) = 0u;
    *(_OWORD *)(a8 + 48) = 0u;
    *(_OWORD *)a8 = 0u;
    *(_OWORD *)(a8 + 16) = 0u;
  }

  v18 = *(unsigned __int8 *)(a8 + 88);
  if (!*(_BYTE *)(a8 + 88) && a7)
  {
    if (!a6)
      std::__throw_bad_optional_access[abi:ne180100]();
    v19 = operator new(8uLL);
    v26 = v19;
    *v19 = 0;
    v27 = v19 + 1;
    v28 = v19 + 1;
    std::string::basic_string[abi:ne180100]<0>(__p, "");
    *(_QWORD *)v20.var0 = a4;
    *(_QWORD *)&v20.var0[8] = a2;
    *(_QWORD *)v36.var0 = a3;
    *(_QWORD *)&v36.var0[8] = a5;
    CLMiLoServiceManager::createService(v20, v36, a1, (uint64_t)&v26, (uint64_t *)__p, (uint64_t)v33);
    if (SHIBYTE(__p[2]) < 0)
      operator delete(__p[0]);
    if (v26)
    {
      v27 = v26;
      operator delete(v26);
    }
    if (v34 != -1)
    {
      if (onceToken_MicroLocation_Default != -1)
        dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_330);
      v21 = logObject_MicroLocation_Default;
      if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_FAULT))
      {
        LOWORD(__p[0]) = 0;
        _os_log_impl(&dword_2419D9000, v21, OS_LOG_TYPE_FAULT, "create service for static token failed", (uint8_t *)__p, 2u);
      }
    }
    v22 = *(id *)(*(_QWORD *)(a1 + 88) + 96);
    v23 = v22;
    if (v22)
    {
      objc_msgSend(v22, "fetchServiceByUUID:", a2, a3);
    }
    else
    {
      v31 = 0u;
      v32 = 0u;
      v30 = 0u;
      memset(__p, 0, sizeof(__p));
    }
    std::__optional_storage_base<CLMiLoServiceTable::Entry,false>::__assign_from[abi:ne180100]<std::__optional_move_assign_base<CLMiLoServiceTable::Entry,false>>(a8, (uint64_t)__p);
    std::__optional_destruct_base<CLMiLoServiceTable::Entry,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)__p);

    v18 = *(unsigned __int8 *)(a8 + 88);
  }
  if (!v18)
  {
    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_330);
    v24 = (id)logObject_MicroLocation_Default;
    if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
    {
      if (*((char *)a4 + 23) < 0)
        a4 = (void **)*a4;
      v25 = (char *)operator new(0x28uLL);
      *(_QWORD *)(v25 + 29) = 0;
      *(_OWORD *)v25 = 0u;
      *((_OWORD *)v25 + 1) = 0u;
      boost::uuids::to_chars<char *>((uint64_t)v35, v25);
      __p[0] = (void *)68289538;
      LOWORD(__p[1]) = 2082;
      *(void **)((char *)&__p[1] + 2) = "";
      WORD1(__p[2]) = 2082;
      *(void **)((char *)&__p[2] + 4) = a4;
      WORD2(__p[3]) = 2082;
      *(void **)((char *)&__p[3] + 6) = v25;
      _os_log_impl(&dword_2419D9000, v24, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"MiLoServiceManager cannot connect to service since service not found in database\", \"ClientId\":%{public, location:escape_only}s, \"ServiceUuid\":%{public, location:escape_only}s}", (uint8_t *)__p, 0x26u);
      operator delete(v25);
    }

  }
}

void sub_241A2FF40(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  uint64_t v18;
  void *v19;
  void *v20;

  operator delete(v20);

  std::__optional_destruct_base<CLMiLoServiceTable::Entry,false>::~__optional_destruct_base[abi:ne180100](v18);
  _Unwind_Resume(a1);
}

void CLMiLoServiceManager::migrateLegacyClientIdToClientIdIfNecessary(uint64_t a1, uint64_t a2, const std::string *a3)
{
  size_t v5;
  size_t size;
  size_t v7;
  uint64_t v8;
  int v9;
  unsigned __int8 *v10;
  const std::string *i;
  const std::string *v12;
  void *v13;
  void *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  void *v18;
  id v19;
  id v20;
  char v21;
  NSObject *v22;
  id v23;
  id v24;
  char v25;
  NSObject *v26;
  id v27;
  char v28;
  NSObject *v29;
  NSObject *v30;
  const std::string *v31;
  char *v32;
  std::string *v33;
  NSObject *v34;
  const std::string *v35;
  char *v36;
  std::string *v37;
  NSObject *v38;
  const std::string *v39;
  char *v40;
  std::string *v41;
  void *v42;
  void *v43;
  std::string *v44;
  id obj;
  std::string v47;
  void *v48[2];
  char v49;
  std::string v50;
  void *v51[2];
  char v52;
  std::string v53;
  void *__p[2];
  char v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  uint8_t buf[4];
  int v61;
  __int16 v62;
  const char *v63;
  __int16 v64;
  const std::string *v65;
  __int16 v66;
  char *v67;
  __int16 v68;
  std::string *v69;
  _BYTE v70[128];
  uint64_t v71;

  v71 = *MEMORY[0x24BDAC8D0];
  if (*(_BYTE *)(a2 + 88))
  {
    v44 = (std::string *)(a2 + 32);
    v5 = HIBYTE(a3->__r_.__value_.__r.__words[2]);
    size = a3->__r_.__value_.__l.__size_;
    if ((v5 & 0x80u) == 0)
      v7 = v5;
    else
      v7 = size;
    v8 = *(unsigned __int8 *)(a2 + 55);
    v9 = (char)v8;
    if ((v8 & 0x80u) != 0)
      v8 = *(_QWORD *)(a2 + 40);
    if (v7 == v8)
    {
      if (v9 >= 0)
        v10 = (unsigned __int8 *)(a2 + 32);
      else
        v10 = (unsigned __int8 *)v44->__r_.__value_.__r.__words[0];
      if ((v5 & 0x80) != 0)
      {
        if (!memcmp(a3->__r_.__value_.__l.__data_, v10, size))
          return;
      }
      else
      {
        if (!(_DWORD)v5)
          return;
        for (i = a3; i->__r_.__value_.__s.__data_[0] == *v10; i = (const std::string *)((char *)i + 1))
        {
          ++v10;
          if (!--v5)
            return;
        }
      }
    }
    ULSettings::get<ULSettings::ClientIdLocationdToMilodMapping>();
    v43 = (void *)objc_claimAutoreleasedReturnValue();
    if ((a3->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v12 = a3;
    else
      v12 = (const std::string *)a3->__r_.__value_.__r.__words[0];
    objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", v12);
    v13 = (void *)objc_claimAutoreleasedReturnValue();
    ___ZN20CLMiLoServiceManager42migrateLegacyClientIdToClientIdIfNecessaryERNSt3__18optionalIN18CLMiLoServiceTable5EntryEEERKNS0_12basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEE_block_invoke((uint64_t)v13, v43, v13);
    v14 = (void *)objc_claimAutoreleasedReturnValue();

    v42 = v14;
    if (objc_msgSend(v14, "count"))
    {
      v58 = 0u;
      v59 = 0u;
      v56 = 0u;
      v57 = 0u;
      obj = v14;
      v15 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v56, v70, 16);
      if (v15)
      {
        v16 = *(_QWORD *)v57;
        do
        {
          v17 = 0;
          do
          {
            if (*(_QWORD *)v57 != v16)
              objc_enumerationMutation(obj);
            v18 = *(void **)(*((_QWORD *)&v56 + 1) + 8 * v17);
            v19 = *(id *)(*(_QWORD *)(a1 + 88) + 96);
            v20 = objc_retainAutorelease(v18);
            std::string::basic_string[abi:ne180100]<0>(__p, (char *)objc_msgSend(v20, "UTF8String"));
            if (SHIBYTE(a3->__r_.__value_.__r.__words[2]) < 0)
              std::string::__init_copy_ctor_external(&v53, a3->__r_.__value_.__l.__data_, a3->__r_.__value_.__l.__size_);
            else
              v53 = *a3;
            v21 = objc_msgSend(v19, "updateAllServicesWithMatchingClientId:withNewClientId:", __p, &v53);
            if (SHIBYTE(v53.__r_.__value_.__r.__words[2]) < 0)
              operator delete(v53.__r_.__value_.__l.__data_);
            if (v55 < 0)
              operator delete(__p[0]);

            if ((v21 & 1) == 0)
            {
              if (onceToken_MicroLocation_Default != -1)
                dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_330);
              v22 = logObject_MicroLocation_Default;
              if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_FAULT))
              {
                *(_WORD *)buf = 0;
                _os_log_impl(&dword_2419D9000, v22, OS_LOG_TYPE_FAULT, "MiLoServiceManager: updateAllServicesWithMatchingClientId failed on Update services", buf, 2u);
              }
            }
            v23 = *(id *)(*(_QWORD *)(a1 + 88) + 72);
            v24 = objc_retainAutorelease(v20);
            std::string::basic_string[abi:ne180100]<0>(v51, (char *)objc_msgSend(v24, "UTF8String"));
            if (SHIBYTE(a3->__r_.__value_.__r.__words[2]) < 0)
              std::string::__init_copy_ctor_external(&v50, a3->__r_.__value_.__l.__data_, a3->__r_.__value_.__l.__size_);
            else
              v50 = *a3;
            v25 = objc_msgSend(v23, "updateAllModelsWithMatchingClientId:withNewClientId:", v51, &v50);
            if (SHIBYTE(v50.__r_.__value_.__r.__words[2]) < 0)
              operator delete(v50.__r_.__value_.__l.__data_);
            if (v52 < 0)
              operator delete(v51[0]);

            if ((v25 & 1) == 0)
            {
              if (onceToken_MicroLocation_Default != -1)
                dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_330);
              v26 = logObject_MicroLocation_Default;
              if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_FAULT))
              {
                *(_WORD *)buf = 0;
                _os_log_impl(&dword_2419D9000, v26, OS_LOG_TYPE_FAULT, "MiLoServiceManager: updateAllServicesWithMatchingClientId failed on Update models", buf, 2u);
              }
            }
            v27 = *(id *)(*(_QWORD *)(a1 + 88) + 40);
            std::string::basic_string[abi:ne180100]<0>(v48, (char *)objc_msgSend(objc_retainAutorelease(v24), "UTF8String"));
            if (SHIBYTE(a3->__r_.__value_.__r.__words[2]) < 0)
              std::string::__init_copy_ctor_external(&v47, a3->__r_.__value_.__l.__data_, a3->__r_.__value_.__l.__size_);
            else
              v47 = *a3;
            v28 = objc_msgSend(v27, "updateAllLabelsWithMatchingClientId:withNewClientId:", v48, &v47);
            if (SHIBYTE(v47.__r_.__value_.__r.__words[2]) < 0)
              operator delete(v47.__r_.__value_.__l.__data_);
            if (v49 < 0)
              operator delete(v48[0]);

            if ((v28 & 1) == 0)
            {
              if (onceToken_MicroLocation_Default != -1)
                dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_330);
              v29 = logObject_MicroLocation_Default;
              if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_FAULT))
              {
                *(_WORD *)buf = 0;
                _os_log_impl(&dword_2419D9000, v29, OS_LOG_TYPE_FAULT, "MiLoServiceManager: updateAllServicesWithMatchingClientId failed on Update labels", buf, 2u);
              }
            }
            ++v17;
          }
          while (v15 != v17);
          v15 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v56, v70, 16);
        }
        while (v15);
      }

      if (onceToken_MicroLocation_Default != -1)
        dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_330);
      v30 = (id)logObject_MicroLocation_Default;
      if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
      {
        if ((a3->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v31 = a3;
        else
          v31 = (const std::string *)a3->__r_.__value_.__r.__words[0];
        if (!*(_BYTE *)(a2 + 88))
          std::__throw_bad_optional_access[abi:ne180100]();
        v32 = (char *)operator new(0x28uLL);
        *(_QWORD *)(v32 + 29) = 0;
        *(_OWORD *)v32 = 0u;
        *((_OWORD *)v32 + 1) = 0u;
        boost::uuids::to_chars<char *>(a2 + 8, v32);
        if (!*(_BYTE *)(a2 + 88))
          std::__throw_bad_optional_access[abi:ne180100]();
        v33 = v44;
        if (*(char *)(a2 + 55) < 0)
          v33 = *(std::string **)(a2 + 32);
        *(_DWORD *)buf = 68289794;
        v61 = 0;
        v62 = 2082;
        v63 = "";
        v64 = 2082;
        v65 = v31;
        v66 = 2082;
        v67 = v32;
        v68 = 2082;
        v69 = v33;
        _os_log_impl(&dword_2419D9000, v30, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"MiLoServiceManager found mapping from locationd client ID to received ID \", \"ClientId\":%{public, location:escape_only}s, \"ServiceUuid\":%{public, location:escape_only}s, \"Existing ClientId\":%{public, location:escape_only}s}", buf, 0x30u);
        operator delete(v32);
      }

      if (!*(_BYTE *)(a2 + 88))
        std::__throw_bad_optional_access[abi:ne180100]();
      std::string::operator=(v44, a3);
    }
    else
    {
      if (onceToken_MicroLocation_Default != -1)
        dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_330);
      v34 = (id)logObject_MicroLocation_Default;
      if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
      {
        if ((a3->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v35 = a3;
        else
          v35 = (const std::string *)a3->__r_.__value_.__r.__words[0];
        if (!*(_BYTE *)(a2 + 88))
          std::__throw_bad_optional_access[abi:ne180100]();
        v36 = (char *)operator new(0x28uLL);
        *(_QWORD *)(v36 + 29) = 0;
        *(_OWORD *)v36 = 0u;
        *((_OWORD *)v36 + 1) = 0u;
        boost::uuids::to_chars<char *>(a2 + 8, v36);
        if (!*(_BYTE *)(a2 + 88))
          std::__throw_bad_optional_access[abi:ne180100]();
        v37 = v44;
        if (*(char *)(a2 + 55) < 0)
          v37 = *(std::string **)(a2 + 32);
        *(_DWORD *)buf = 68289794;
        v61 = 0;
        v62 = 2082;
        v63 = "";
        v64 = 2082;
        v65 = v35;
        v66 = 2082;
        v67 = v36;
        v68 = 2082;
        v69 = v37;
        _os_log_impl(&dword_2419D9000, v34, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"MiLoServiceManager unable to find mapping for legacy ClientId\", \"ClientId\":%{public, location:escape_only}s, \"ServiceUuid\":%{public, location:escape_only}s, \"Expected ClientId\":%{public, location:escape_only}s}", buf, 0x30u);
        operator delete(v36);
      }

      if (onceToken_MicroLocation_Default != -1)
        dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_330);
      v38 = (id)logObject_MicroLocation_Default;
      if (os_signpost_enabled(v38))
      {
        if ((a3->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v39 = a3;
        else
          v39 = (const std::string *)a3->__r_.__value_.__r.__words[0];
        if (!*(_BYTE *)(a2 + 88))
          std::__throw_bad_optional_access[abi:ne180100]();
        v40 = (char *)operator new(0x28uLL);
        *(_QWORD *)(v40 + 29) = 0;
        *(_OWORD *)v40 = 0u;
        *((_OWORD *)v40 + 1) = 0u;
        boost::uuids::to_chars<char *>(a2 + 8, v40);
        if (!*(_BYTE *)(a2 + 88))
          std::__throw_bad_optional_access[abi:ne180100]();
        v41 = v44;
        if (*(char *)(a2 + 55) < 0)
          v41 = *(std::string **)(a2 + 32);
        *(_DWORD *)buf = 68289794;
        v61 = 0;
        v62 = 2082;
        v63 = "";
        v64 = 2082;
        v65 = v39;
        v66 = 2082;
        v67 = v40;
        v68 = 2082;
        v69 = v41;
        _os_signpost_emit_with_name_impl(&dword_2419D9000, v38, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "MiLoServiceManager unable to find mapping for legacy ClientId", "{\"msg%{public}.0s\":\"MiLoServiceManager unable to find mapping for legacy ClientId\", \"ClientId\":%{public, location:escape_only}s, \"ServiceUuid\":%{public, location:escape_only}s, \"Expected ClientId\":%{public, location:escape_only}s}", buf, 0x30u);
        operator delete(v40);
      }

    }
  }
}

void sub_241A30834(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,void *a27,uint64_t a28,int a29,__int16 a30,char a31,char a32,void *__p,uint64_t a34,int a35,__int16 a36,char a37,char a38,void *a39,uint64_t a40,int a41,__int16 a42,char a43,char a44,void *a45,uint64_t a46,int a47,__int16 a48,char a49,char a50)
{
  void *v50;
  void *v51;

  operator delete(v51);

  _Unwind_Resume(a1);
}

uint64_t CLMiLoServiceManager::isClientAllowedToConnect(uint64_t a1, _QWORD *a2, uint64_t *a3, uint64_t a4, uint64_t a5, int a6)
{
  void *v9;
  void *v10;
  void *v11;
  void *v12;
  uint64_t result;
  void *v14;
  void *v15;
  void *v16;
  uint64_t v17;
  unint64_t v18;
  NSObject *v19;
  uint64_t *v20;
  char *v21;
  uint64_t v22;
  _DWORD v23[2];
  __int16 v24;
  const char *v25;
  __int16 v26;
  uint64_t *v27;
  __int16 v28;
  char *v29;
  __int16 v30;
  uint64_t v31;
  _QWORD v32[3];

  v32[2] = *MEMORY[0x24BDAC8D0];
  v32[0] = a4;
  v32[1] = a5;
  switch(*a2)
  {
    case 1:
      +[ULDefaultsSingleton shared](ULDefaultsSingleton, "shared");
      v9 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v9, "defaultsDictionary");
      v10 = (void *)objc_claimAutoreleasedReturnValue();

      objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "ULMaximumNumberOfConnectedUnsupervisedServicesPerClient");
      v11 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v10, "objectForKey:", v11);
      v12 = (void *)objc_claimAutoreleasedReturnValue();
      if (!v12)
        goto LABEL_15;
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) == 0)
        goto LABEL_15;
      goto LABEL_14;
    case 2:
      +[ULDefaultsSingleton shared](ULDefaultsSingleton, "shared");
      v14 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v14, "defaultsDictionary");
      v10 = (void *)objc_claimAutoreleasedReturnValue();

      objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "ULMaximumNumberOfConnectedBinaryRoiServicesPerClient");
      v11 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v10, "objectForKey:", v11);
      v12 = (void *)objc_claimAutoreleasedReturnValue();
      if (v12)
      {
        objc_opt_class();
        if ((objc_opt_isKindOfClass() & 1) != 0)
          goto LABEL_14;
      }
      goto LABEL_15;
    case 3:
      +[ULDefaultsSingleton shared](ULDefaultsSingleton, "shared");
      v15 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v15, "defaultsDictionary");
      v10 = (void *)objc_claimAutoreleasedReturnValue();

      objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "ULMaximumNumberOfConnectedMulticlassServicesPerClient");
      v11 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v10, "objectForKey:", v11);
      v12 = (void *)objc_claimAutoreleasedReturnValue();
      if (v12)
      {
        objc_opt_class();
        if ((objc_opt_isKindOfClass() & 1) != 0)
          goto LABEL_14;
      }
LABEL_15:
      v17 = objc_msgSend(&unk_2511ED648, "unsignedLongValue");
      goto LABEL_17;
    case 4:
      +[ULDefaultsSingleton shared](ULDefaultsSingleton, "shared");
      v16 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v16, "defaultsDictionary");
      v10 = (void *)objc_claimAutoreleasedReturnValue();

      objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "ULMaximumNumberOfConnectedSimilarityListServicesPerClient");
      v11 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v10, "objectForKey:", v11);
      v12 = (void *)objc_claimAutoreleasedReturnValue();
      if (v12 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
LABEL_14:
        v17 = objc_msgSend(v12, "unsignedLongValue");
      else
        v17 = objc_msgSend(&unk_2511ED660, "unsignedLongValue");
LABEL_17:
      v18 = v17;

      if (v18 >= (a6 + 1))
      {
        result = 0;
      }
      else
      {
        if (onceToken_MicroLocation_Default != -1)
          dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_330);
        v19 = (id)logObject_MicroLocation_Default;
        if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
        {
          if (*((char *)a3 + 23) >= 0)
            v20 = a3;
          else
            v20 = (uint64_t *)*a3;
          v21 = (char *)operator new(0x28uLL);
          *(_QWORD *)(v21 + 29) = 0;
          *(_OWORD *)v21 = 0u;
          *((_OWORD *)v21 + 1) = 0u;
          boost::uuids::to_chars<char *>((uint64_t)v32, v21);
          v22 = *(unsigned int *)a2;
          v23[0] = 68289794;
          v23[1] = 0;
          v24 = 2082;
          v25 = "";
          v26 = 2082;
          v27 = v20;
          v28 = 2082;
          v29 = v21;
          v30 = 2050;
          v31 = v22;
          _os_log_impl(&dword_2419D9000, v19, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"MiLoServiceManager cannot connect to service since client has maxed out number of connections\", \"ClientId\":%{public, location:escape_only}s, \"ServiceUuid\":%{public, location:escape_only}s, \"ServiceType\":%{public}lu}", (uint8_t *)v23, 0x30u);
          operator delete(v21);
        }

        result = 32;
      }
      break;
    default:
      result = 3;
      break;
  }
  return result;
}

void sub_241A30D98(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

_QWORD *std::list<CLMiLoService>::emplace_back<CLMiLoService>(uint64_t *a1, __int128 *a2)
{
  _QWORD *v3;
  uint64_t v4;

  v3 = std::__list_imp<CLMiLoService>::__create_node[abi:ne180100]<CLMiLoService>((uint64_t)a1, 0, 0, a2);
  v4 = *a1;
  *v3 = *a1;
  v3[1] = a1;
  *(_QWORD *)(v4 + 8) = v3;
  *a1 = (uint64_t)v3;
  ++a1[2];
  return v3 + 2;
}

void CLMiLoService::~CLMiLoService(CLMiLoService *this)
{
  std::deque<CLMiLoService::OutstandingRequest>::~deque[abi:ne180100]((_QWORD *)this + 47);
  std::deque<CLMiLoService::OutstandingRequest>::~deque[abi:ne180100]((_QWORD *)this + 38);
  std::__optional_destruct_base<CachedPrediction,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)this + 112);
  std::shared_ptr<CLMiLoService::ModelAndConf>::~shared_ptr[abi:ne180100]((uint64_t)this + 96);
  if (*((char *)this + 87) < 0)
    operator delete(*((void **)this + 8));
  if (*((char *)this + 63) < 0)
    operator delete(*((void **)this + 5));
}

uint64_t ___ZN20CLMiLoServiceManager7connectERKNSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEEN5boost5uuids4uuidENS0_8optionalISB_EESB_S8__block_invoke(uint64_t a1)
{
  CLMiLoServiceManager *v2;

  v2 = *(CLMiLoServiceManager **)(a1 + 32);
  CLMiLoServiceManager::updateServiceLastActiveTime(v2, *(const CLMiLoService **)(a1 + 40));
  CLMiLoServiceManager::enterLocationPerService(v2, *(int64x2_t **)(a1 + 40));
  return CLMiLoServiceManager::checkSpectating(v2);
}

uint64_t CLMiLoServiceManager::updateServiceLastActiveTime(CLMiLoServiceManager *this, const CLMiLoService *a2)
{
  id v3;
  double v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  v3 = *(id *)(*((_QWORD *)this + 11) + 96);
  v4 = cl::chrono::CFAbsoluteTimeClock::now();
  v5 = CLMiLoService::uuid(a2);
  v7 = objc_msgSend(v3, "updateLastActiveTime:forService:", v5, v6, v4);

  return v7;
}

void sub_241A30F98(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void CLMiLoServiceManager::enterLocationPerService(CLMiLoServiceManager *this, int64x2_t *a2)
{
  unint64_t *v4;
  int v5;
  __int128 v6;
  std::__shared_weak_count *v7;
  unint64_t *p_shared_owners;
  unint64_t v9;
  std::__shared_weak_count *v10;
  unint64_t *v11;
  unint64_t v12;
  uint64_t v13;
  __int128 v14;
  std::__shared_weak_count *v15;
  unint64_t *v16;
  unint64_t v17;
  std::__shared_weak_count *v18;
  unint64_t *v19;
  unint64_t v20;
  unint64_t *v21;
  unint64_t v22;
  std::__shared_weak_count *v23;
  unint64_t *v24;
  unint64_t v25;
  std::__shared_weak_count *v26;
  unint64_t *v27;
  unint64_t v28;
  std::__shared_weak_count *v29;
  unint64_t *v30;
  unint64_t v31;
  uint64_t v32;
  std::__shared_weak_count *v33;
  __int128 v34;
  __int128 v35;

  v4 = (unint64_t *)((char *)this + 96);
  if (!*((_BYTE *)this + 120) || !CLMiLoService::isLocationTypeEnabled((uint64_t)a2, *v4))
    goto LABEL_8;
  if (!*((_BYTE *)this + 120))
    std::__throw_bad_optional_access[abi:ne180100]();
  if (*v4 != 2)
  {
    v35 = 0uLL;
    goto LABEL_11;
  }
  if (((*(uint64_t (**)(uint64_t))(*(_QWORD *)(*((_QWORD *)this + 16) + 8) + 104))(*((_QWORD *)this + 16) + 8) & 1) == 0)
  {
LABEL_8:
    CLMiLoServiceManager::releaseModel(this, a2);
LABEL_9:
    CLMiLoService::sendStatus(a2, (uint64_t)v4);
    return;
  }
  v5 = *((unsigned __int8 *)this + 120);
  v35 = 0uLL;
  if (!v5)
    std::__throw_bad_optional_access[abi:ne180100]();
LABEL_11:
  CLMiLoServiceManager::modelByServiceAndLocation((CLMiLoService *)a2, (uint64_t)this, &v34);
  v6 = v34;
  v34 = 0uLL;
  v7 = (std::__shared_weak_count *)*((_QWORD *)&v35 + 1);
  v35 = v6;
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      v9 = __ldaxr(p_shared_owners);
    while (__stlxr(v9 - 1, p_shared_owners));
    if (!v9)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }
  v10 = (std::__shared_weak_count *)*((_QWORD *)&v34 + 1);
  if (*((_QWORD *)&v34 + 1))
  {
    v11 = (unint64_t *)(*((_QWORD *)&v34 + 1) + 8);
    do
      v12 = __ldaxr(v11);
    while (__stlxr(v12 - 1, v11));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
  }
  v13 = v35;
  if ((_QWORD)v35)
    goto LABEL_34;
  if (!*((_BYTE *)this + 120))
    std::__throw_bad_optional_access[abi:ne180100]();
  CLMiLoServiceManager::loadModelForServiceOrCreateNewIfNecessary((CLMiLoService *)a2, *((_QWORD *)this + 11), (CLMiLoServiceManager *)((char *)this + 136), (uint64_t *)v4, &v34);
  v14 = v34;
  v34 = 0uLL;
  v15 = (std::__shared_weak_count *)*((_QWORD *)&v35 + 1);
  v35 = v14;
  if (v15)
  {
    v16 = (unint64_t *)&v15->__shared_owners_;
    do
      v17 = __ldaxr(v16);
    while (__stlxr(v17 - 1, v16));
    if (!v17)
    {
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
    }
  }
  v18 = (std::__shared_weak_count *)*((_QWORD *)&v34 + 1);
  if (*((_QWORD *)&v34 + 1))
  {
    v19 = (unint64_t *)(*((_QWORD *)&v34 + 1) + 8);
    do
      v20 = __ldaxr(v19);
    while (__stlxr(v20 - 1, v19));
    if (!v20)
    {
      ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
      std::__shared_weak_count::__release_weak(v18);
    }
  }
  std::vector<std::shared_ptr<CLMiLoService::ModelAndConf>>::push_back[abi:ne180100]((char **)this + 2, &v35);
  v13 = v35;
  if ((_QWORD)v35)
  {
LABEL_34:
    v32 = v13;
    v33 = (std::__shared_weak_count *)*((_QWORD *)&v35 + 1);
    if (*((_QWORD *)&v35 + 1))
    {
      v21 = (unint64_t *)(*((_QWORD *)&v35 + 1) + 8);
      do
        v22 = __ldxr(v21);
      while (__stxr(v22 + 1, v21));
    }
    CLMiLoService::updateModel((uint64_t)a2, &v32);
    v23 = v33;
    if (v33)
    {
      v24 = (unint64_t *)&v33->__shared_owners_;
      do
        v25 = __ldaxr(v24);
      while (__stlxr(v25 - 1, v24));
      if (!v25)
      {
        ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
        std::__shared_weak_count::__release_weak(v23);
      }
    }
    v26 = (std::__shared_weak_count *)*((_QWORD *)&v35 + 1);
    v35 = 0uLL;
    if (v26)
    {
      v27 = (unint64_t *)&v26->__shared_owners_;
      do
        v28 = __ldaxr(v27);
      while (__stlxr(v28 - 1, v27));
      if (!v28)
      {
        ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
        std::__shared_weak_count::__release_weak(v26);
      }
      v29 = (std::__shared_weak_count *)*((_QWORD *)&v35 + 1);
      if (*((_QWORD *)&v35 + 1))
      {
        v30 = (unint64_t *)(*((_QWORD *)&v35 + 1) + 8);
        do
          v31 = __ldaxr(v30);
        while (__stlxr(v31 - 1, v30));
        if (!v31)
        {
          ((void (*)(std::__shared_weak_count *))v29->__on_zero_shared)(v29);
          std::__shared_weak_count::__release_weak(v29);
        }
      }
    }
    goto LABEL_9;
  }
  CLMiLoServiceManager::enterLocationPerService((NSObject **)&v34);

  abort_report_np();
  __break(1u);
}

void sub_241A312B4(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::shared_ptr<CLMiLoService::ModelAndConf>::~shared_ptr[abi:ne180100](v1 - 48);
  _Unwind_Resume(a1);
}

uint64_t CLMiLoServiceManager::checkSpectating(CLMiLoServiceManager *this)
{
  char *v2;
  char *v3;
  int v4;

  v2 = (char *)this + 40;
  v3 = (char *)*((_QWORD *)this + 6);
  if (v3 == (char *)this + 40)
  {
    LOBYTE(v4) = 0;
  }
  else
  {
    v4 = 0;
    do
    {
      v4 |= CLMiLoService::doAllowObservation((CLMiLoService *)(v3 + 16));
      v3 = (char *)*((_QWORD *)v3 + 1);
    }
    while (v3 != v2);
  }
  return (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)(*((_QWORD *)this + 16) + 8) + 72))(*((_QWORD *)this + 16) + 8, v4 & 1);
}

uint64_t CLMiLoServiceManager::disconnect(_QWORD *a1, const std::string *a2, uint64_t a3, uint64_t a4, unsigned __int8 *a5)
{
  CLMiLoService *v8;
  char v9;
  CLMiLoService *v10;
  unsigned __int8 *v11;
  uint64_t v12;
  uint64_t v13;
  std::string::size_type size;
  int v15;
  const std::string *v16;
  NSObject *v17;
  char *v18;
  char *v19;
  unsigned __int8 *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  int v25;
  unsigned __int8 *v26;
  NSObject *v27;
  _OWORD *v28;
  void **v29;
  unsigned __int8 *v30;
  uint64_t v31;
  int v32;
  uint64_t v33;
  int v34;
  unsigned __int8 *v35;
  uint64_t v36;
  unsigned __int8 *v37;
  uint64_t v38;
  uint64_t v39;
  NSObject *v40;
  _OWORD *v41;
  void **v42;
  unsigned __int8 *v43;
  uint64_t v44;
  int v45;
  uint64_t v46;
  int v47;
  unsigned __int8 *v48;
  uint64_t v49;
  unsigned __int8 *v50;
  uint64_t v51;
  uint64_t v52;
  NSObject *v53;
  std::string *v54;
  uint64_t v55;
  uint64_t v56;
  char *v57;
  _QWORD *v58;
  uint64_t v59;
  uint64_t v60;
  double v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  unsigned __int8 *v65;
  unsigned __int8 *v66;
  void **v67;
  void **v68;
  int v69;
  void *__p;
  __int128 v71;
  int v72;
  __int128 v73;
  uint8_t buf[8];
  _BYTE v75[10];
  __int16 v76;
  void **v77;
  __int16 v78;
  unsigned __int8 *v79;
  __int16 v80;
  uint64_t v81;
  __int16 v82;
  unsigned __int8 *v83;
  __int16 v84;
  uint64_t v85;
  uuid v86;
  uuid v87;
  char v88;
  uuid v89;
  uint64_t v90;
  uuid v91;

  v90 = *MEMORY[0x24BDAC8D0];
  *(_QWORD *)v89.var0 = a3;
  *(_QWORD *)&v89.var0[8] = a4;
  CLMiLoServiceManager::BiDirectionalUuidMap::lookupByValue((CLMiLoServiceManager::BiDirectionalUuidMap *)(a1 + 8), &v89, &v87);
  if (!v88)
  {
    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_330);
    v17 = (id)logObject_MicroLocation_Default;
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
    {
      v18 = (char *)operator new(0x28uLL);
      *(_QWORD *)(v18 + 29) = 0;
      *(_OWORD *)v18 = 0u;
      *((_OWORD *)v18 + 1) = 0u;
      boost::uuids::to_chars<char *>((uint64_t)&v89, v18);
      *(_DWORD *)buf = 68289283;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)v75 = 2082;
      *(_QWORD *)&v75[2] = "";
      v76 = 2081;
      v77 = (void **)v18;
      _os_log_impl(&dword_2419D9000, v17, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLMiLoServiceManager::disconnect, failed because can't find serviceId for this connection\", \"connectionToken\":%{private, location:escape_only}s}", buf, 0x1Cu);
      operator delete(v18);
    }
    goto LABEL_26;
  }
  v86 = v87;
  v8 = (CLMiLoService *)CLMiLoServiceManager::loadedServiceByUuid((CLMiLoServiceManager *)a1, v87);
  if (!v9)
  {
    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_330);
    v17 = (id)logObject_MicroLocation_Default;
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
    {
      v19 = (char *)operator new(0x28uLL);
      *(_QWORD *)(v19 + 29) = 0;
      *(_OWORD *)v19 = 0u;
      *((_OWORD *)v19 + 1) = 0u;
      boost::uuids::to_chars<char *>((uint64_t)&v86, v19);
      *(_DWORD *)buf = 68289283;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)v75 = 2082;
      *(_QWORD *)&v75[2] = "";
      v76 = 2081;
      v77 = (void **)v19;
      _os_log_impl(&dword_2419D9000, v17, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLMiLoServiceManager::disconnect, failed because not connected to this service\", \"ServiceUUID\":%{private, location:escape_only}s}", buf, 0x1Cu);
      operator delete(v19);
    }
LABEL_26:

    return 27;
  }
  v10 = v8;
  v11 = (unsigned __int8 *)CLMiLoService::clientId(v8);
  v12 = v11[23];
  if ((v12 & 0x80u) == 0)
    v13 = v11[23];
  else
    v13 = *((_QWORD *)v11 + 1);
  size = HIBYTE(a2->__r_.__value_.__r.__words[2]);
  v15 = (char)size;
  if ((size & 0x80u) != 0)
    size = a2->__r_.__value_.__l.__size_;
  if (v13 != size)
    goto LABEL_43;
  if (v15 >= 0)
    v16 = a2;
  else
    v16 = (const std::string *)a2->__r_.__value_.__r.__words[0];
  if ((v12 & 0x80) != 0)
  {
    if (memcmp(*(const void **)v11, v16, *((_QWORD *)v11 + 1)))
      goto LABEL_43;
  }
  else if (v11[23])
  {
    while (*v11 == v16->__r_.__value_.__s.__data_[0])
    {
      ++v11;
      v16 = (const std::string *)((char *)v16 + 1);
      if (!--v12)
        goto LABEL_28;
    }
    goto LABEL_43;
  }
LABEL_28:
  v21 = (unsigned __int8 *)CLMiLoService::userId(v10);
  v22 = v21[23];
  if ((v22 & 0x80u) == 0)
    v23 = v21[23];
  else
    v23 = *((_QWORD *)v21 + 1);
  v24 = a5[23];
  v25 = (char)v24;
  if ((v24 & 0x80u) != 0)
    v24 = *((_QWORD *)a5 + 1);
  if (v23 != v24)
    goto LABEL_43;
  if (v25 >= 0)
    v26 = a5;
  else
    v26 = *(unsigned __int8 **)a5;
  if ((v22 & 0x80) != 0)
  {
    if (!memcmp(*(const void **)v21, v26, *((_QWORD *)v21 + 1)))
      goto LABEL_84;
LABEL_43:
    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_330);
    v27 = (id)logObject_MicroLocation_Default;
    if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
    {
      v28 = operator new(0x28uLL);
      __p = v28;
      v71 = xmmword_241BB2320;
      *v28 = 0u;
      v28[1] = 0u;
      *(_QWORD *)((char *)v28 + 29) = 0;
      boost::uuids::to_chars<char *>((uint64_t)&v86, v28);
      v29 = v71 >= 0 ? &__p : (void **)__p;
      v30 = (a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
          ? (unsigned __int8 *)a2
          : (unsigned __int8 *)a2->__r_.__value_.__r.__words[0];
      v65 = v30;
      v67 = v29;
      v31 = CLMiLoService::clientId(v10);
      v32 = *(char *)(v31 + 23);
      v33 = *(_QWORD *)v31;
      v34 = (char)a5[23];
      v35 = *(unsigned __int8 **)a5;
      v36 = CLMiLoService::userId(v10);
      v37 = v34 >= 0 ? a5 : v35;
      v38 = v32 >= 0 ? v31 : v33;
      v39 = *(char *)(v36 + 23) >= 0 ? v36 : *(_QWORD *)v36;
      *(_DWORD *)buf = 68290307;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)v75 = 2082;
      *(_QWORD *)&v75[2] = "";
      v76 = 2081;
      v77 = v67;
      v78 = 2081;
      v79 = v65;
      v80 = 2081;
      v81 = v38;
      v82 = 2081;
      v83 = v37;
      v84 = 2081;
      v85 = v39;
      _os_log_impl(&dword_2419D9000, v27, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"CLMiLoServiceManager::disconnect, client ID or user ID does not match!\", \"ServiceUUID\":%{private, location:escape_only}s, \"clientId\":%{private, location:escape_only}s, \"loadedServiceClientId\":%{private, location:escape_only}s, \"userId\":%{private, location:escape_only}s, \"loadedServiceUserId\":%{private, location:escape_only}s}", buf, 0x44u);
      if (SHIBYTE(v71) < 0)
        operator delete(__p);
    }

    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_330);
    v40 = (id)logObject_MicroLocation_Default;
    if (os_signpost_enabled(v40))
    {
      v41 = operator new(0x28uLL);
      __p = v41;
      v71 = xmmword_241BB2320;
      *v41 = 0u;
      v41[1] = 0u;
      *(_QWORD *)((char *)v41 + 29) = 0;
      boost::uuids::to_chars<char *>((uint64_t)&v86, v41);
      v42 = v71 >= 0 ? &__p : (void **)__p;
      v43 = (a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
          ? (unsigned __int8 *)a2
          : (unsigned __int8 *)a2->__r_.__value_.__r.__words[0];
      v66 = v43;
      v68 = v42;
      v44 = CLMiLoService::clientId(v10);
      v45 = *(char *)(v44 + 23);
      v46 = *(_QWORD *)v44;
      v47 = (char)a5[23];
      v48 = *(unsigned __int8 **)a5;
      v49 = CLMiLoService::userId(v10);
      v50 = v47 >= 0 ? a5 : v48;
      v51 = v45 >= 0 ? v44 : v46;
      v52 = *(char *)(v49 + 23) >= 0 ? v49 : *(_QWORD *)v49;
      *(_DWORD *)buf = 68290307;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)v75 = 2082;
      *(_QWORD *)&v75[2] = "";
      v76 = 2081;
      v77 = v68;
      v78 = 2081;
      v79 = v66;
      v80 = 2081;
      v81 = v51;
      v82 = 2081;
      v83 = v50;
      v84 = 2081;
      v85 = v52;
      _os_signpost_emit_with_name_impl(&dword_2419D9000, v40, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "CLMiLoServiceManager::disconnect, client ID or user ID does not match!", "{\"msg%{public}.0s\":\"CLMiLoServiceManager::disconnect, client ID or user ID does not match!\", \"ServiceUUID\":%{private, location:escape_only}s, \"clientId\":%{private, location:escape_only}s, \"loadedServiceClientId\":%{private, location:escape_only}s, \"userId\":%{private, location:escape_only}s, \"loadedServiceUserId\":%{private, location:escape_only}s}", buf, 0x44u);
      if (SHIBYTE(v71) < 0)
        operator delete(__p);
    }

    goto LABEL_84;
  }
  if (v21[23])
  {
    while (*v21 == *v26)
    {
      ++v21;
      ++v26;
      if (!--v22)
        goto LABEL_84;
    }
    goto LABEL_43;
  }
LABEL_84:
  if (onceToken_MicroLocation_Default != -1)
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_330);
  v53 = logObject_MicroLocation_Default;
  if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 68289026;
    *(_DWORD *)&buf[4] = 0;
    *(_WORD *)v75 = 2082;
    *(_QWORD *)&v75[2] = "";
    _os_log_impl(&dword_2419D9000, v53, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLMiLoServiceManager::disconnect, releasing model and updating service time\"}", buf, 0x12u);
  }
  CLMicroLocationProto::ServiceDisconnect::ServiceDisconnect((CLMicroLocationProto::ServiceDisconnect *)&__p);
  v72 |= 2u;
  v54 = (std::string *)v71;
  v55 = MEMORY[0x24BEDD958];
  if ((_QWORD)v71 == MEMORY[0x24BEDD958])
  {
    v54 = (std::string *)operator new();
    v54->__r_.__value_.__r.__words[0] = 0;
    v54->__r_.__value_.__l.__size_ = 0;
    v54->__r_.__value_.__r.__words[2] = 0;
    *(_QWORD *)&v71 = v54;
  }
  std::string::operator=(v54, a2);
  *(_QWORD *)buf = CLMiLoService::uuid(v10);
  *(_QWORD *)v75 = v56;
  v57 = (char *)operator new(0x28uLL);
  *(_QWORD *)(v57 + 29) = 0;
  *(_OWORD *)v57 = 0u;
  *((_OWORD *)v57 + 1) = 0u;
  boost::uuids::to_chars<char *>((uint64_t)buf, v57);
  v72 |= 4u;
  if (*((_QWORD *)&v71 + 1) == v55)
  {
    v58 = (_QWORD *)operator new();
    *v58 = 0;
    v58[1] = 0;
    v58[2] = 0;
    *((_QWORD *)&v71 + 1) = v58;
  }
  MEMORY[0x2426A02C4]();
  operator delete(v57);
  v59 = a1[16];
  v69 = 0;
  boost::uuids::detail::random_provider_base::random_provider_base((boost::uuids::detail::random_provider_base *)&v69);
  *(_QWORD *)&v73 = boost::uuids::random_generator_pure::operator()((uint64_t)&v69);
  *((_QWORD *)&v73 + 1) = v60;
  v61 = cl::chrono::CFAbsoluteTimeClock::now();
  CLMicroLocationProtobufHelper::createLoggedEvent<CLMicroLocationProto::ServiceDisconnect>(&v73, (int *)&__p, (uint64_t)buf, v61);
  (*(void (**)(uint64_t, uint8_t *))(*(_QWORD *)v59 + 72))(v59, buf);
  CLMicroLocationProto::ReceivedEvent::~ReceivedEvent((CLMicroLocationProto::ReceivedEvent *)((char *)&v79 + 2));
  boost::uuids::detail::random_provider_base::destroy((boost::uuids::detail::random_provider_base *)&v69);
  CLMiLoServiceManager::releaseModel((CLMiLoServiceManager *)a1, (int64x2_t *)v10);
  CLMiLoServiceManager::updateServiceLastActiveTime((CLMiLoServiceManager *)a1, v10);
  v62 = CLMiLoService::uuid(v10);
  v64 = v63;
  *(_QWORD *)v91.var0 = v62;
  *(_QWORD *)&v91.var0[8] = v64;
  CLMiLoServiceManager::releaseServiceByUuid((CLMiLoServiceManager *)a1, v91);
  CLMicroLocationProto::ServiceDisconnect::~ServiceDisconnect((CLMicroLocationProto::ServiceDisconnect *)&__p);
  return -1;
}

void sub_241A31B6C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, int a11, char a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  void *v18;
  void *v19;

  operator delete(v19);

  _Unwind_Resume(a1);
}

_QWORD *CLMiLoServiceManager::BiDirectionalUuidMap::lookupByValue@<X0>(CLMiLoServiceManager::BiDirectionalUuidMap *this@<X0>, const uuid *a2@<X1>, _BYTE *a3@<X8>)
{
  _QWORD *result;
  _QWORD *v4;
  _QWORD *v5;
  BOOL v6;
  _QWORD *v7;
  _QWORD *v8;
  char v9;

  v5 = *(_QWORD **)this;
  result = (_QWORD *)((char *)this + 8);
  v4 = v5;
  if (v5 == result)
  {
LABEL_12:
    v9 = 0;
    *a3 = 0;
  }
  else
  {
    while (1)
    {
      v6 = *(_QWORD *)((char *)v4 + 41) == *(_QWORD *)a2->var0
        && *(_QWORD *)((char *)v4 + 49) == *(_QWORD *)&a2->var0[8];
      if (v6)
        break;
      v7 = (_QWORD *)v4[1];
      if (v7)
      {
        do
        {
          v8 = v7;
          v7 = (_QWORD *)*v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          v8 = (_QWORD *)v4[2];
          v6 = *v8 == (_QWORD)v4;
          v4 = v8;
        }
        while (!v6);
      }
      v4 = v8;
      if (v8 == result)
        goto LABEL_12;
    }
    *(_OWORD *)a3 = *(_OWORD *)((char *)v4 + 25);
    v9 = 1;
  }
  a3[16] = v9;
  return result;
}

void CLMicroLocationProtobufHelper::createLoggedEvent<CLMicroLocationProto::ServiceDisconnect>(_OWORD *a1@<X0>, int *a2@<X1>, uint64_t a3@<X8>, double a4@<D0>)
{
  const CLMicroLocationProto::ServiceDisconnect *v8;
  _BYTE v9[304];

  CLMicroLocationProto::ReceivedEvent::ReceivedEvent((CLMicroLocationProto::ReceivedEvent *)v9);
  CLMicroLocationProtobufHelper::setSpecificLoggedEvent((CLMicroLocationProtobufHelper *)v9, (CLMicroLocationProto::ReceivedEvent *)a2, v8);
  CLMicroLocationLoggedEventsTable::Entry::Entry(a3, a1, a2[6], (CLMicroLocationProto::ReceivedEvent *)v9, a4);
  CLMicroLocationProto::ReceivedEvent::~ReceivedEvent((CLMicroLocationProto::ReceivedEvent *)v9);
}

void sub_241A31D4C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  CLMicroLocationProto::ReceivedEvent::~ReceivedEvent((CLMicroLocationProto::ReceivedEvent *)&a9);
  _Unwind_Resume(a1);
}

void CLMiLoServiceManager::releaseModel(CLMiLoServiceManager *this, int64x2_t *a2)
{
  uint64_t *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  BOOL v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  NSObject *v15;
  uint64_t v16;
  char *v17;
  _QWORD v18[2];
  uint8_t buf[4];
  int v20;
  __int16 v21;
  const char *v22;
  __int16 v23;
  char *v24;
  __int16 v25;
  uint64_t v26;
  __int16 v27;
  uint64_t v28;
  uint64_t v29;

  v29 = *MEMORY[0x24BDAC8D0];
  v5 = *((_QWORD *)this + 2);
  v6 = *((_QWORD *)this + 3);
  v4 = (uint64_t *)((char *)this + 16);
  CLMiLoService::releaseModel(a2);
  v8 = *v4;
  v7 = v4[1];
  if (*v4 == v7)
  {
    v7 = *v4;
  }
  else
  {
    v9 = v8 + 16;
    while (1)
    {
      v10 = *(_QWORD *)(v9 - 8);
      if (v10)
      {
        if (!*(_QWORD *)(v10 + 8))
          break;
      }
      v11 = v9 == v7;
      v9 += 16;
      if (v11)
      {
        v8 = v4[1];
        goto LABEL_16;
      }
    }
    v8 = v9 - 16;
    if (v9 - 16 != v7 && v9 != v7)
    {
      do
      {
        v12 = *(_QWORD *)(v9 + 8);
        if (!v12 || *(_QWORD *)(v12 + 8))
        {
          std::shared_ptr<CLMicroLocationFingerprint>::operator=[abi:ne180100](v8, (__int128 *)v9);
          v8 += 16;
        }
        v9 += 16;
      }
      while (v9 != v7);
      v7 = *((_QWORD *)this + 3);
    }
  }
LABEL_16:
  std::vector<std::shared_ptr<CLMiLoService::ModelAndConf>>::erase((uint64_t)v4, v8, v7);
  v14 = *((_QWORD *)this + 2);
  v13 = *((_QWORD *)this + 3);
  if (onceToken_MicroLocation_Default != -1)
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_330);
  v15 = (id)logObject_MicroLocation_Default;
  if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
  {
    v18[0] = CLMiLoService::uuid((CLMiLoService *)a2);
    v18[1] = v16;
    v17 = (char *)operator new(0x28uLL);
    *(_QWORD *)(v17 + 29) = 0;
    *(_OWORD *)v17 = 0u;
    *((_OWORD *)v17 + 1) = 0u;
    boost::uuids::to_chars<char *>((uint64_t)v18, v17);
    *(_DWORD *)buf = 68289795;
    v20 = 0;
    v21 = 2082;
    v22 = "";
    v23 = 2081;
    v24 = v17;
    v25 = 2050;
    v26 = (v6 - v5) >> 4;
    v27 = 2050;
    v28 = (v13 - v14) >> 4;
    _os_log_impl(&dword_2419D9000, v15, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLMiLoServiceManager::releaseModel, released model\", \"ServiceUUID\":%{private, location:escape_only}s, \"NumModelsBefore\":%{public}lu, \"NumModelsAfter\":%{public}lu}", buf, 0x30u);
    operator delete(v17);
  }

}

void sub_241A31F6C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  operator delete(v1);

  _Unwind_Resume(a1);
}

uint64_t CLMiLoServiceManager::releaseServiceByUuid(CLMiLoServiceManager *this, uuid a2)
{
  uint64_t *v3;
  uint64_t *v4;
  uint64_t v5;
  uint64_t v7;
  uuid v9;
  uuid v10;
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  v9 = a2;
  v3 = (uint64_t *)((char *)this + 40);
  v4 = (uint64_t *)*((_QWORD *)this + 6);
  v10 = a2;
  while (v4 != v3)
  {
    if (CLMiLoService::uuid((CLMiLoService *)(v4 + 2)) == *(_QWORD *)v10.var0 && v5 == *(_QWORD *)&v10.var0[8])
    {
      v3 = v4;
      break;
    }
    v4 = (uint64_t *)v4[1];
  }
  v7 = *v3;
  *(_QWORD *)(v7 + 8) = v3[1];
  *(_QWORD *)v3[1] = v7;
  --*((_QWORD *)this + 7);
  std::__destroy_at[abi:ne180100]<CLMiLoService,0>((uint64_t)(v3 + 2));
  operator delete(v3);
  return CLMiLoServiceManager::BiDirectionalUuidMap::eraseByKey((uint64_t **)this + 8, &v9);
}

void CLMiLoServiceManager::enterLocation(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7;
  char v8;
  int v9;

  v7 = CLMiLoServiceManager::rtLoiStringToLocationType(a2);
  if (v8)
  {
    v9 = *(unsigned __int8 *)(a1 + 120);
    *(_QWORD *)(a1 + 96) = v7;
    *(_QWORD *)(a1 + 104) = a3;
    *(_QWORD *)(a1 + 112) = a4;
    if (!v9)
      *(_BYTE *)(a1 + 120) = 1;
  }
  else if (*(_BYTE *)(a1 + 120))
  {
    *(_BYTE *)(a1 + 120) = 0;
  }
  CLMiLoServiceManager::updateAllModels((CLMiLoServiceManager *)a1);
}

uint64_t CLMiLoServiceManager::rtLoiStringToLocationType(uint64_t *a1)
{
  int v1;
  uint64_t v3;

  if ((*((char *)a1 + 23) & 0x80000000) == 0)
  {
    v1 = *((unsigned __int8 *)a1 + 23);
    if (v1 != 4)
    {
      if (v1 != 6)
        return 30;
      if (*(_DWORD *)a1 != 1953723747 || *((_WORD *)a1 + 2) != 28015)
      {
LABEL_25:
        if (v1 == 4)
          goto LABEL_26;
        return 30;
      }
      return 2;
    }
    if (*(_DWORD *)a1 != 1701670760)
    {
      if (*(_DWORD *)a1 != 1802661751)
        goto LABEL_25;
      return 1;
    }
    return 0;
  }
  v3 = a1[1];
  if (v3 == 4)
  {
    if (*(_DWORD *)*a1 == 1701670760)
      return 0;
    if (*(_DWORD *)*a1 == 1802661751)
      return 1;
    v3 = a1[1];
  }
  if (v3 == 6)
  {
    if (*(_DWORD *)*a1 == 1953723747 && *(_WORD *)(*a1 + 4) == 28015)
      return 2;
    v3 = a1[1];
  }
  if (v3 != 4)
    return 30;
  a1 = (uint64_t *)*a1;
LABEL_26:
  if (*(_DWORD *)a1 != 1701736302)
    return 30;
  return 0;
}

void CLMiLoServiceManager::updateAllModels(CLMiLoServiceManager *this)
{
  void *v2;
  _QWORD v3[5];

  +[ULTransactionManager shared](ULTransactionManager, "shared");
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  v3[0] = MEMORY[0x24BDAC760];
  v3[1] = 3221225472;
  v3[2] = ___ZN20CLMiLoServiceManager15updateAllModelsEv_block_invoke;
  v3[3] = &__block_descriptor_40_e5_v8__0l;
  v3[4] = this;
  objc_msgSend(v2, "performUnderTransaction:block:", CFSTR("com.apple.locationd.microlocation-update-all-models"), v3);

}

void sub_241A32278(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t CLMiLoServiceManager::releaseAllModels(CLMiLoServiceManager *this)
{
  int64x2_t *v2;
  int64x2_t *i;
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  v2 = (int64x2_t *)((char *)this + 40);
  for (i = (int64x2_t *)*((_QWORD *)this + 6); i != v2; i = (int64x2_t *)i->i64[1])
    CLMiLoServiceManager::releaseModel(this, i + 1);
  v5 = *((_QWORD *)this + 2);
  result = *((_QWORD *)this + 3);
  if (v5 != result)
  {
    v6 = *((_QWORD *)this + 2);
    do
    {
      v7 = *(_QWORD *)(v6 + 8);
      if (!v7 || *(_QWORD *)(v7 + 8))
      {
        v8 = CLMiLoServiceManager::releaseAllModels();
        return CLMiLoServiceManager::predictionRequest(v8);
      }
      v6 += 16;
    }
    while (v6 != result);
    for (; result != v5; result = std::shared_ptr<CLMiLoService::ModelAndConf>::~shared_ptr[abi:ne180100](result - 16))
      ;
  }
  *((_QWORD *)this + 3) = v5;
  return result;
}

uint64_t CLMiLoServiceManager::predictionRequest(CLMiLoServiceManager *a1, uuid a2, const uuid *a3, double *a4, int a5)
{
  unint64_t v9;
  char v10;
  CLMiLoService *v11;
  uint64_t v12;
  _OWORD *v13;
  std::string *v14;
  _QWORD *v15;
  char *v16;
  std::string *v17;
  const std::string *v18;
  std::string *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  int v24;
  int v25;
  std::string *v26;
  _QWORD *v27;
  std::string *v28;
  int v29;
  void *__p;
  __int128 v31;
  uint64_t v32;
  __int128 v33;
  uint64_t v34;

  v34 = *MEMORY[0x24BDAC8D0];
  v9 = CLMiLoServiceManager::loadedServiceByConnectionToken(a1, a2);
  if (!v10)
    return 0;
  v11 = (CLMiLoService *)v9;
  CLMicroLocationProto::RequestPrediction::RequestPrediction((CLMicroLocationProto::RequestPrediction *)&v25);
  *(_QWORD *)&v33 = CLMiLoService::uuid(v11);
  *((_QWORD *)&v33 + 1) = v12;
  v13 = operator new(0x28uLL);
  __p = v13;
  v31 = xmmword_241BB2320;
  *v13 = 0u;
  v13[1] = 0u;
  *(_QWORD *)((char *)v13 + 29) = 0;
  boost::uuids::to_chars<char *>((uint64_t)&v33, v13);
  v29 |= 4u;
  v14 = (std::string *)MEMORY[0x24BEDD958];
  if (v27 == (_QWORD *)MEMORY[0x24BEDD958])
  {
    v15 = (_QWORD *)operator new();
    *v15 = 0;
    v15[1] = 0;
    v15[2] = 0;
    v27 = v15;
  }
  MEMORY[0x2426A02C4]();
  if (SHIBYTE(v31) < 0)
    operator delete(__p);
  v16 = (char *)operator new(0x28uLL);
  *(_QWORD *)(v16 + 29) = 0;
  *(_OWORD *)v16 = 0u;
  *((_OWORD *)v16 + 1) = 0u;
  boost::uuids::to_chars<char *>((uint64_t)a3, v16);
  v29 |= 8u;
  if (v28 == v14)
  {
    v17 = (std::string *)operator new();
    v17->__r_.__value_.__r.__words[0] = 0;
    v17->__r_.__value_.__l.__size_ = 0;
    v17->__r_.__value_.__r.__words[2] = 0;
    v28 = v17;
  }
  MEMORY[0x2426A02C4]();
  operator delete(v16);
  v18 = (const std::string *)CLMiLoService::clientId(v11);
  v29 |= 2u;
  v19 = v26;
  if (v26 == v14)
  {
    v19 = (std::string *)operator new();
    v19->__r_.__value_.__r.__words[0] = 0;
    v19->__r_.__value_.__l.__size_ = 0;
    v19->__r_.__value_.__r.__words[2] = 0;
    v26 = v19;
  }
  std::string::operator=(v19, v18);
  v20 = *((_QWORD *)a1 + 16);
  v24 = 0;
  boost::uuids::detail::random_provider_base::random_provider_base((boost::uuids::detail::random_provider_base *)&v24);
  *(_QWORD *)&v33 = boost::uuids::random_generator_pure::operator()((uint64_t)&v24);
  *((_QWORD *)&v33 + 1) = v21;
  CLMicroLocationProtobufHelper::createLoggedEvent<CLMicroLocationProto::RequestPrediction>(&v33, &v25, (uint64_t)&__p, *a4);
  (*(void (**)(uint64_t, void **))(*(_QWORD *)v20 + 72))(v20, &__p);
  CLMicroLocationProto::ReceivedEvent::~ReceivedEvent((CLMicroLocationProto::ReceivedEvent *)&v32);
  boost::uuids::detail::random_provider_base::destroy((boost::uuids::detail::random_provider_base *)&v24);
  v22 = CLMiLoService::predictionRequest((uint64_t *)v11, a3, (uint64_t)a4, a5);
  CLMicroLocationProto::RequestPrediction::~RequestPrediction((CLMicroLocationProto::RequestPrediction *)&v25);
  return v22;
}

void sub_241A325A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9, char a10, __int16 a11, char a12)
{
  uint64_t v12;

  CLMicroLocationProto::ReceivedEvent::~ReceivedEvent((CLMicroLocationProto::ReceivedEvent *)(v12 + 32));
  boost::uuids::detail::random_provider_base::destroy((boost::uuids::detail::random_provider_base *)&a10);
  CLMicroLocationProto::RequestPrediction::~RequestPrediction((CLMicroLocationProto::RequestPrediction *)&a12);
  _Unwind_Resume(a1);
}

unint64_t CLMiLoServiceManager::loadedServiceByConnectionToken(CLMiLoServiceManager *this, uuid a2)
{
  unint64_t v2;
  _QWORD *v4;
  unsigned __int8 v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  _QWORD v11[2];
  char v12;
  uuid v13;
  uint64_t v14;

  v14 = *MEMORY[0x24BDAC8D0];
  v13 = a2;
  CLMiLoServiceManager::BiDirectionalUuidMap::lookupByValue((CLMiLoServiceManager *)((char *)this + 64), &v13, v11);
  if (!v12 || (v4 = (_QWORD *)*((_QWORD *)this + 6), v4 == (_QWORD *)((char *)this + 40)))
  {
    v9 = 0;
    v8 = 0;
  }
  else
  {
    v5 = 0;
    do
    {
      v6 = CLMiLoService::uuid((CLMiLoService *)(v4 + 2));
      if (v6 == v11[0] && v7 == v11[1])
      {
        v5 = (_BYTE)v4 + 16;
        v2 = (unint64_t)(v4 + 2) >> 8;
      }
      v4 = (_QWORD *)v4[1];
    }
    while (v4 != (_QWORD *)((char *)this + 40));
    v8 = v2 << 8;
    v9 = v5;
  }
  return v8 | v9;
}

void CLMicroLocationProtobufHelper::createLoggedEvent<CLMicroLocationProto::RequestPrediction>(_OWORD *a1@<X0>, int *a2@<X1>, uint64_t a3@<X8>, double a4@<D0>)
{
  const CLMicroLocationProto::RequestPrediction *v8;
  _BYTE v9[304];

  CLMicroLocationProto::ReceivedEvent::ReceivedEvent((CLMicroLocationProto::ReceivedEvent *)v9);
  CLMicroLocationProtobufHelper::setSpecificLoggedEvent((CLMicroLocationProtobufHelper *)v9, (CLMicroLocationProto::ReceivedEvent *)a2, v8);
  CLMicroLocationLoggedEventsTable::Entry::Entry(a3, a1, a2[8], (CLMicroLocationProto::ReceivedEvent *)v9, a4);
  CLMicroLocationProto::ReceivedEvent::~ReceivedEvent((CLMicroLocationProto::ReceivedEvent *)v9);
}

void sub_241A32788(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  CLMicroLocationProto::ReceivedEvent::~ReceivedEvent((CLMicroLocationProto::ReceivedEvent *)&a9);
  _Unwind_Resume(a1);
}

BOOL CLMiLoServiceManager::startUpdating(CLMiLoServiceManager *this, const uuid *a2, int a3)
{
  unint64_t v5;
  unsigned __int8 v6;
  uint64_t v7;
  CLMiLoService *v8;
  uint64_t v9;
  char *v10;
  std::string *v11;
  _QWORD *v12;
  const std::string *v13;
  std::string *v14;
  uint64_t v15;
  uint64_t v16;
  double v17;
  int v19;
  int v20;
  std::string *v21;
  char v22;
  _QWORD *v23;
  int v24;
  __int128 v25;
  _QWORD v26[4];
  _QWORD v27[39];

  v27[38] = *MEMORY[0x24BDAC8D0];
  v5 = CLMiLoServiceManager::loadedServiceByConnectionToken(this, *a2);
  v7 = v6;
  if (v6)
  {
    v8 = (CLMiLoService *)v5;
    CLMicroLocationProto::ServiceStartUpdating::ServiceStartUpdating((uint64_t)&v20);
    v26[0] = CLMiLoService::uuid(v8);
    v26[1] = v9;
    v10 = (char *)operator new(0x28uLL);
    *(_QWORD *)(v10 + 29) = 0;
    *(_OWORD *)v10 = 0u;
    *((_OWORD *)v10 + 1) = 0u;
    boost::uuids::to_chars<char *>((uint64_t)v26, v10);
    v24 |= 4u;
    v11 = (std::string *)MEMORY[0x24BEDD958];
    if (v23 == (_QWORD *)MEMORY[0x24BEDD958])
    {
      v12 = (_QWORD *)operator new();
      *v12 = 0;
      v12[1] = 0;
      v12[2] = 0;
      v23 = v12;
    }
    MEMORY[0x2426A02C4]();
    operator delete(v10);
    v24 |= 8u;
    v22 = a3;
    v13 = (const std::string *)CLMiLoService::clientId(v8);
    v24 |= 2u;
    v14 = v21;
    if (v21 == v11)
    {
      v14 = (std::string *)operator new();
      v14->__r_.__value_.__r.__words[0] = 0;
      v14->__r_.__value_.__l.__size_ = 0;
      v14->__r_.__value_.__r.__words[2] = 0;
      v21 = v14;
    }
    std::string::operator=(v14, v13);
    v15 = *((_QWORD *)this + 16);
    v19 = 0;
    boost::uuids::detail::random_provider_base::random_provider_base((boost::uuids::detail::random_provider_base *)&v19);
    *(_QWORD *)&v25 = boost::uuids::random_generator_pure::operator()((uint64_t)&v19);
    *((_QWORD *)&v25 + 1) = v16;
    v17 = cl::chrono::CFAbsoluteTimeClock::now();
    CLMicroLocationProtobufHelper::createLoggedEvent<CLMicroLocationProto::ServiceStartUpdating>(&v25, &v20, (uint64_t)v26, v17);
    (*(void (**)(uint64_t, _QWORD *))(*(_QWORD *)v15 + 72))(v15, v26);
    CLMicroLocationProto::ReceivedEvent::~ReceivedEvent((CLMicroLocationProto::ReceivedEvent *)v27);
    boost::uuids::detail::random_provider_base::destroy((boost::uuids::detail::random_provider_base *)&v19);
    CLMiLoService::startUpdating(v8, a3);
    CLMicroLocationProto::ServiceStartUpdating::~ServiceStartUpdating((CLMicroLocationProto::ServiceStartUpdating *)&v20);
  }
  return v7 != 0;
}

void sub_241A32980(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, char a11, __int16 a12, char a13)
{
  uint64_t v13;

  CLMicroLocationProto::ReceivedEvent::~ReceivedEvent((CLMicroLocationProto::ReceivedEvent *)(v13 + 32));
  boost::uuids::detail::random_provider_base::destroy((boost::uuids::detail::random_provider_base *)&a11);
  CLMicroLocationProto::ServiceStartUpdating::~ServiceStartUpdating((CLMicroLocationProto::ServiceStartUpdating *)&a13);
  _Unwind_Resume(a1);
}

void CLMicroLocationProtobufHelper::createLoggedEvent<CLMicroLocationProto::ServiceStartUpdating>(_OWORD *a1@<X0>, int *a2@<X1>, uint64_t a3@<X8>, double a4@<D0>)
{
  const CLMicroLocationProto::ServiceStartUpdating *v8;
  _BYTE v9[304];

  CLMicroLocationProto::ReceivedEvent::ReceivedEvent((CLMicroLocationProto::ReceivedEvent *)v9);
  CLMicroLocationProtobufHelper::setSpecificLoggedEvent((CLMicroLocationProtobufHelper *)v9, (CLMicroLocationProto::ReceivedEvent *)a2, v8);
  CLMicroLocationLoggedEventsTable::Entry::Entry(a3, a1, a2[4], (CLMicroLocationProto::ReceivedEvent *)v9, a4);
  CLMicroLocationProto::ReceivedEvent::~ReceivedEvent((CLMicroLocationProto::ReceivedEvent *)v9);
}

void sub_241A32A4C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  CLMicroLocationProto::ReceivedEvent::~ReceivedEvent((CLMicroLocationProto::ReceivedEvent *)&a9);
  _Unwind_Resume(a1);
}

BOOL CLMiLoServiceManager::stopUpdating(CLMiLoServiceManager *this, const uuid *a2)
{
  CLMiLoService *v3;
  unsigned __int8 v4;
  uint64_t v5;
  CLMiLoService *v6;
  uint64_t v7;
  char *v8;
  std::string *v9;
  _QWORD *v10;
  const std::string *v11;
  std::string *v12;
  uint64_t v13;
  uint64_t v14;
  double v15;
  int v17;
  int v18;
  std::string *v19;
  _QWORD *v20;
  int v21;
  __int128 v22;
  _QWORD v23[4];
  _QWORD v24[39];

  v24[38] = *MEMORY[0x24BDAC8D0];
  v3 = (CLMiLoService *)CLMiLoServiceManager::loadedServiceByConnectionToken(this, *a2);
  v5 = v4;
  if (v4)
  {
    v6 = v3;
    CLMiLoService::stopUpdating(v3);
    CLMicroLocationProto::ServiceStopUpdating::ServiceStopUpdating((CLMicroLocationProto::ServiceStopUpdating *)&v18);
    v23[0] = CLMiLoService::uuid(v6);
    v23[1] = v7;
    v8 = (char *)operator new(0x28uLL);
    *(_QWORD *)(v8 + 29) = 0;
    *(_OWORD *)v8 = 0u;
    *((_OWORD *)v8 + 1) = 0u;
    boost::uuids::to_chars<char *>((uint64_t)v23, v8);
    v21 |= 4u;
    v9 = (std::string *)MEMORY[0x24BEDD958];
    if (v20 == (_QWORD *)MEMORY[0x24BEDD958])
    {
      v10 = (_QWORD *)operator new();
      *v10 = 0;
      v10[1] = 0;
      v10[2] = 0;
      v20 = v10;
    }
    MEMORY[0x2426A02C4]();
    operator delete(v8);
    v11 = (const std::string *)CLMiLoService::clientId(v6);
    v21 |= 2u;
    v12 = v19;
    if (v19 == v9)
    {
      v12 = (std::string *)operator new();
      v12->__r_.__value_.__r.__words[0] = 0;
      v12->__r_.__value_.__l.__size_ = 0;
      v12->__r_.__value_.__r.__words[2] = 0;
      v19 = v12;
    }
    std::string::operator=(v12, v11);
    v13 = *((_QWORD *)this + 16);
    v17 = 0;
    boost::uuids::detail::random_provider_base::random_provider_base((boost::uuids::detail::random_provider_base *)&v17);
    *(_QWORD *)&v22 = boost::uuids::random_generator_pure::operator()((uint64_t)&v17);
    *((_QWORD *)&v22 + 1) = v14;
    v15 = cl::chrono::CFAbsoluteTimeClock::now();
    CLMicroLocationProtobufHelper::createLoggedEvent<CLMicroLocationProto::ServiceStopUpdating>(&v22, &v18, (uint64_t)v23, v15);
    (*(void (**)(uint64_t, _QWORD *))(*(_QWORD *)v13 + 72))(v13, v23);
    CLMicroLocationProto::ReceivedEvent::~ReceivedEvent((CLMicroLocationProto::ReceivedEvent *)v24);
    boost::uuids::detail::random_provider_base::destroy((boost::uuids::detail::random_provider_base *)&v17);
    CLMicroLocationProto::ServiceStopUpdating::~ServiceStopUpdating((CLMicroLocationProto::ServiceStopUpdating *)&v18);
  }
  return v5 != 0;
}

void sub_241A32C20(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, char a11, __int16 a12, char a13)
{
  uint64_t v13;

  CLMicroLocationProto::ReceivedEvent::~ReceivedEvent((CLMicroLocationProto::ReceivedEvent *)(v13 + 32));
  boost::uuids::detail::random_provider_base::destroy((boost::uuids::detail::random_provider_base *)&a11);
  CLMicroLocationProto::ServiceStopUpdating::~ServiceStopUpdating((CLMicroLocationProto::ServiceStopUpdating *)&a13);
  _Unwind_Resume(a1);
}

void CLMicroLocationProtobufHelper::createLoggedEvent<CLMicroLocationProto::ServiceStopUpdating>(_OWORD *a1@<X0>, int *a2@<X1>, uint64_t a3@<X8>, double a4@<D0>)
{
  const CLMicroLocationProto::ServiceStopUpdating *v8;
  _BYTE v9[304];

  CLMicroLocationProto::ReceivedEvent::ReceivedEvent((CLMicroLocationProto::ReceivedEvent *)v9);
  CLMicroLocationProtobufHelper::setSpecificLoggedEvent((CLMicroLocationProtobufHelper *)v9, (CLMicroLocationProto::ReceivedEvent *)a2, v8);
  CLMicroLocationLoggedEventsTable::Entry::Entry(a3, a1, a2[6], (CLMicroLocationProto::ReceivedEvent *)v9, a4);
  CLMicroLocationProto::ReceivedEvent::~ReceivedEvent((CLMicroLocationProto::ReceivedEvent *)v9);
}

void sub_241A32CEC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  CLMicroLocationProto::ReceivedEvent::~ReceivedEvent((CLMicroLocationProto::ReceivedEvent *)&a9);
  _Unwind_Resume(a1);
}

uint64_t CLMiLoServiceManager::enableMiLoAtCurrentLocation(CLMiLoServiceManager *this, const uuid *a2)
{
  unint64_t v4;
  char v5;
  CLMiLoService *v6;
  NSObject *v7;
  uint64_t v8;
  char *v9;
  __n128 v10;
  id v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  _QWORD v17[2];
  _BYTE buf[18];
  __int16 v19;
  char *v20;
  uint64_t v21;

  v21 = *MEMORY[0x24BDAC8D0];
  v4 = CLMiLoServiceManager::loadedServiceByConnectionToken(this, *a2);
  if (!v5)
    return 0;
  v6 = (CLMiLoService *)v4;
  if (onceToken_MicroLocation_Default != -1)
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_330);
  v7 = (id)logObject_MicroLocation_Default;
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    v17[0] = CLMiLoService::uuid(v6);
    v17[1] = v8;
    v9 = (char *)operator new(0x28uLL);
    *(_QWORD *)(v9 + 29) = 0;
    *(_OWORD *)v9 = 0u;
    *((_OWORD *)v9 + 1) = 0u;
    boost::uuids::to_chars<char *>((uint64_t)v17, v9);
    *(_DWORD *)buf = 68289282;
    *(_DWORD *)&buf[4] = 0;
    *(_WORD *)&buf[8] = 2082;
    *(_QWORD *)&buf[10] = "";
    v19 = 2082;
    v20 = v9;
    _os_log_impl(&dword_2419D9000, v7, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"ServiceManager: enableMiLoAtCurrentLocation for service\", \"serviceId\":%{public, location:escape_only}s}", buf, 0x1Cu);
    operator delete(v9);
  }

  *(uuid *)buf = *a2;
  v10 = std::deque<CLMiLoServiceManager::OutstandingEnableCustomLoiRequest>::push_back((_QWORD *)this + 22, (__n128 *)buf);
  if ((*(unsigned int (**)(uint64_t, __n128))(*(_QWORD *)(*((_QWORD *)this + 16) + 8) + 104))(*((_QWORD *)this + 16) + 8, v10))
  {
    if ((CLMiLoService::isLocationTypeEnabled((uint64_t)v6, 2uLL) & 1) == 0)
    {
      CLMiLoService::enableInLocationType((uint64_t)v6, 2uLL);
      v11 = *(id *)(*((_QWORD *)this + 11) + 96);
      v12 = CLMiLoService::uuid(v6);
      objc_msgSend(v11, "updateServiceLocationTypes:withLocationTypes:", v12, v13, CLMiLoService::locationTypes(v6));

    }
  }
  v14 = *((_QWORD *)this + 16);
  *(_QWORD *)buf = CLMiLoService::uuid(v6);
  *(_QWORD *)&buf[8] = v15;
  return (*(uint64_t (**)(uint64_t, _BYTE *))(*(_QWORD *)(v14 + 8) + 96))(v14 + 8, buf);
}

void sub_241A32F00(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t CLMiLoServiceManager::removeCustomLoiWithIdentifier(CLMiLoServiceManager *this, const uuid *a2, const uuid *a3)
{
  unint64_t v5;
  char v6;
  CLMiLoService *v7;
  NSObject *v8;
  char *v9;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  _QWORD v15[2];
  uint8_t buf[8];
  _BYTE v17[10];
  __int16 v18;
  char *v19;
  __int16 v20;
  char *v21;
  uint64_t v22;

  v22 = *MEMORY[0x24BDAC8D0];
  v5 = CLMiLoServiceManager::loadedServiceByConnectionToken(this, *a3);
  if (!v6)
    return 0;
  v7 = (CLMiLoService *)v5;
  if (onceToken_MicroLocation_Default != -1)
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_330);
  v8 = (id)logObject_MicroLocation_Default;
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    v9 = (char *)operator new(0x28uLL);
    *(_QWORD *)(v9 + 29) = 0;
    *(_OWORD *)v9 = 0u;
    *((_OWORD *)v9 + 1) = 0u;
    boost::uuids::to_chars<char *>((uint64_t)a2, v9);
    v15[0] = CLMiLoService::uuid(v7);
    v15[1] = v10;
    v11 = (char *)operator new(0x28uLL);
    *(_QWORD *)(v11 + 29) = 0;
    *(_OWORD *)v11 = 0u;
    *((_OWORD *)v11 + 1) = 0u;
    boost::uuids::to_chars<char *>((uint64_t)v15, v11);
    *(_DWORD *)buf = 68289538;
    *(_DWORD *)&buf[4] = 0;
    *(_WORD *)v17 = 2082;
    *(_QWORD *)&v17[2] = "";
    v18 = 2082;
    v19 = v9;
    v20 = 2082;
    v21 = v11;
    _os_log_impl(&dword_2419D9000, v8, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"ServiceManager: removeCustomLoiWithIdentifier for service\", \"CustomloiId\":%{public, location:escape_only}s, \"serviceId\":%{public, location:escape_only}s}", buf, 0x26u);
    operator delete(v11);
    operator delete(v9);
  }

  if (CLMiLoService::isLocationTypeEnabled((uint64_t)v7, 2uLL))
    CLMiLoService::disableInLocationType((uint64_t)v7, 2uLL);
  v12 = *((_QWORD *)this + 16);
  *(_QWORD *)buf = CLMiLoService::uuid(v7);
  *(_QWORD *)v17 = v13;
  return (*(uint64_t (**)(uint64_t, const uuid *, uint8_t *))(*(_QWORD *)(v12 + 8) + 112))(v12 + 8, a2, buf);
}

void sub_241A330FC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  operator delete(v3);
  operator delete(v2);

  _Unwind_Resume(a1);
}

void CLMiLoServiceManager::ingestLocalizationResults(CLMiLoServiceManager *this, const CLMiLoServiceManager::LocalizationResults *a2, uuid a3)
{
  unint64_t v3;
  unint64_t v4;
  int64x2_t *v5;
  int64x2_t *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t Model;
  char v11;
  unint64_t i;

  v5 = (int64x2_t *)((char *)this + 40);
  v6 = (int64x2_t *)*((_QWORD *)this + 6);
  if (v6 != (int64x2_t *)((char *)this + 40))
  {
    v7 = *(_QWORD *)&a3.var0[8];
    v8 = *(_QWORD *)a3.var0;
    do
    {
      v4 &= 0xFFFFFFFFFFFFFF00;
      v3 &= 0xFFFFFFFFFFFFFF00;
      Model = CLMiLoService::getModel((CLMiLoService *)&v6[1]);
      if (v11)
      {
        for (i = *(_QWORD *)a2; i != *((_QWORD *)a2 + 1); i += 216)
        {
          if (*(_OWORD *)(i + 168) == *(_OWORD *)(Model + 448))
          {
            v4 = i;
            v3 = v3 & 0xFFFFFFFFFFFFFF00 | 1;
          }
        }
      }
      CLMiLoService::ingestLocalizationResults(v6 + 1, (CLMicroLocationResultToPublish *)v4, v3, v8, v7);
      v6 = (int64x2_t *)v6->i64[1];
    }
    while (v6 != v5);
  }
}

void CLMiLoServiceManager::invalidateCachedPredictions(CLMiLoServiceManager *this)
{
  char *v1;
  uint64_t i;

  v1 = (char *)this + 40;
  for (i = *((_QWORD *)this + 6); (char *)i != v1; i = *(_QWORD *)(i + 8))
    CLMiLoService::invalidateCachedPrediction((CLMiLoService *)(i + 16));
}

void CLMiLoServiceManager::notifyInvalidConfidence(uint64_t a1, int a2)
{
  uint64_t v2;
  uint64_t v3;

  v2 = a1 + 40;
  v3 = *(_QWORD *)(a1 + 48);
  if (v3 != a1 + 40)
  {
    do
    {
      CLMiLoService::notifyInvalidConfidence((uint64_t *)(v3 + 16), a2);
      v3 = *(_QWORD *)(v3 + 8);
    }
    while (v3 != v2);
  }
}

uint64_t CLMiLoServiceManager::requestObservation(CLMiLoServiceManager *a1, uuid a2, uint64_t a3, uint64_t a4, uint64_t a5, double *a6)
{
  unint64_t v9;
  char v10;
  CLMiLoService *v11;
  uint64_t v12;
  _OWORD *v13;
  std::string *v14;
  _QWORD *v15;
  _OWORD *v16;
  std::string *v17;
  char *v18;
  std::string *v19;
  const std::string *v20;
  std::string *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  int v26;
  int v27;
  std::string *v28;
  _QWORD *v29;
  std::string *v30;
  std::string *v31;
  int v32;
  void *__p;
  __int128 v34;
  uint64_t v35;
  __int128 v36;
  __int128 v37;
  uint64_t v38;

  v38 = *MEMORY[0x24BDAC8D0];
  *(_QWORD *)&v37 = a3;
  *((_QWORD *)&v37 + 1) = a4;
  v9 = CLMiLoServiceManager::loadedServiceByConnectionToken(a1, a2);
  if (!v10)
    return 0;
  v11 = (CLMiLoService *)v9;
  CLMicroLocationProto::RequestObservation::RequestObservation((CLMicroLocationProto::RequestObservation *)&v27);
  *(_QWORD *)&v36 = CLMiLoService::uuid(v11);
  *((_QWORD *)&v36 + 1) = v12;
  v13 = operator new(0x28uLL);
  __p = v13;
  v34 = xmmword_241BB2320;
  *v13 = 0u;
  v13[1] = 0u;
  *(_QWORD *)((char *)v13 + 29) = 0;
  boost::uuids::to_chars<char *>((uint64_t)&v36, v13);
  v32 |= 4u;
  v14 = (std::string *)MEMORY[0x24BEDD958];
  if (v29 == (_QWORD *)MEMORY[0x24BEDD958])
  {
    v15 = (_QWORD *)operator new();
    *v15 = 0;
    v15[1] = 0;
    v15[2] = 0;
    v29 = v15;
  }
  MEMORY[0x2426A02C4]();
  if (SHIBYTE(v34) < 0)
    operator delete(__p);
  v16 = operator new(0x28uLL);
  __p = v16;
  v34 = xmmword_241BB2320;
  *v16 = 0u;
  v16[1] = 0u;
  *(_QWORD *)((char *)v16 + 29) = 0;
  boost::uuids::to_chars<char *>((uint64_t)&v37, v16);
  v32 |= 8u;
  if (v30 == v14)
  {
    v17 = (std::string *)operator new();
    v17->__r_.__value_.__r.__words[0] = 0;
    v17->__r_.__value_.__l.__size_ = 0;
    v17->__r_.__value_.__r.__words[2] = 0;
    v30 = v17;
  }
  MEMORY[0x2426A02C4]();
  if (SHIBYTE(v34) < 0)
    operator delete(__p);
  v18 = (char *)operator new(0x28uLL);
  *(_QWORD *)(v18 + 29) = 0;
  *(_OWORD *)v18 = 0u;
  *((_OWORD *)v18 + 1) = 0u;
  boost::uuids::to_chars<char *>((uint64_t)&v37, v18);
  v32 |= 0x10u;
  if (v31 == v14)
  {
    v19 = (std::string *)operator new();
    v19->__r_.__value_.__r.__words[0] = 0;
    v19->__r_.__value_.__l.__size_ = 0;
    v19->__r_.__value_.__r.__words[2] = 0;
    v31 = v19;
  }
  MEMORY[0x2426A02C4]();
  operator delete(v18);
  v20 = (const std::string *)CLMiLoService::clientId(v11);
  v32 |= 2u;
  v21 = v28;
  if (v28 == v14)
  {
    v21 = (std::string *)operator new();
    v21->__r_.__value_.__r.__words[0] = 0;
    v21->__r_.__value_.__l.__size_ = 0;
    v21->__r_.__value_.__r.__words[2] = 0;
    v28 = v21;
  }
  std::string::operator=(v21, v20);
  v22 = *((_QWORD *)a1 + 16);
  v26 = 0;
  boost::uuids::detail::random_provider_base::random_provider_base((boost::uuids::detail::random_provider_base *)&v26);
  *(_QWORD *)&v36 = boost::uuids::random_generator_pure::operator()((uint64_t)&v26);
  *((_QWORD *)&v36 + 1) = v23;
  CLMicroLocationProtobufHelper::createLoggedEvent<CLMicroLocationProto::RequestObservation>(&v36, &v27, (uint64_t)&__p, *a6);
  (*(void (**)(uint64_t, void **))(*(_QWORD *)v22 + 72))(v22, &__p);
  CLMicroLocationProto::ReceivedEvent::~ReceivedEvent((CLMicroLocationProto::ReceivedEvent *)&v35);
  boost::uuids::detail::random_provider_base::destroy((boost::uuids::detail::random_provider_base *)&v26);
  v24 = CLMiLoService::observationRequest((uint64_t *)v11, &v37, a5, (uint64_t)a6, 0);
  CLMicroLocationProto::RequestObservation::~RequestObservation((CLMicroLocationProto::RequestObservation *)&v27);
  return v24;
}

void sub_241A335E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, int a12, char a13, __int16 a14, char a15)
{
  uint64_t v15;

  CLMicroLocationProto::ReceivedEvent::~ReceivedEvent((CLMicroLocationProto::ReceivedEvent *)(v15 + 32));
  boost::uuids::detail::random_provider_base::destroy((boost::uuids::detail::random_provider_base *)&a13);
  CLMicroLocationProto::RequestObservation::~RequestObservation((CLMicroLocationProto::RequestObservation *)&a15);
  _Unwind_Resume(a1);
}

void CLMicroLocationProtobufHelper::createLoggedEvent<CLMicroLocationProto::RequestObservation>(_OWORD *a1@<X0>, int *a2@<X1>, uint64_t a3@<X8>, double a4@<D0>)
{
  const CLMicroLocationProto::RequestObservation *v8;
  _BYTE v9[304];

  CLMicroLocationProto::ReceivedEvent::ReceivedEvent((CLMicroLocationProto::ReceivedEvent *)v9);
  CLMicroLocationProtobufHelper::setSpecificLoggedEvent((CLMicroLocationProtobufHelper *)v9, (CLMicroLocationProto::ReceivedEvent *)a2, v8);
  CLMicroLocationLoggedEventsTable::Entry::Entry(a3, a1, a2[10], (CLMicroLocationProto::ReceivedEvent *)v9, a4);
  CLMicroLocationProto::ReceivedEvent::~ReceivedEvent((CLMicroLocationProto::ReceivedEvent *)v9);
}

void sub_241A336D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  CLMicroLocationProto::ReceivedEvent::~ReceivedEvent((CLMicroLocationProto::ReceivedEvent *)&a9);
  _Unwind_Resume(a1);
}

BOOL CLMiLoServiceManager::labelObservation(CLMiLoServiceManager *this, uuid a2, uuid a3, uuid a4)
{
  CLMiLoService *v4;
  unsigned __int8 v5;
  uint64_t v6;
  uuid v8;
  uuid v9;
  uint64_t v10;

  v10 = *MEMORY[0x24BDAC8D0];
  v9 = a3;
  v8 = a4;
  v4 = (CLMiLoService *)CLMiLoServiceManager::loadedServiceByConnectionToken(this, a2);
  v6 = v5;
  if (v5)
    CLMiLoService::labelObservation(v4, &v9, &v8);
  return v6 != 0;
}

BOOL CLMiLoServiceManager::labelObservationsBetweenDates(CLMiLoServiceManager *this, uuid a2, const uuid *a3, const uuid *a4, NSDate *a5, NSDate *a6)
{
  uint64_t v9;
  uint64_t v10;
  NSDate *v12;
  NSDate *v13;
  CLMiLoService *v14;
  unsigned __int8 v15;
  uint64_t v16;
  uuid v18;

  v9 = *(_QWORD *)&a2.var0[8];
  v10 = *(_QWORD *)a2.var0;
  v12 = a5;
  v13 = a6;
  *(_QWORD *)v18.var0 = v10;
  *(_QWORD *)&v18.var0[8] = v9;
  v14 = (CLMiLoService *)CLMiLoServiceManager::loadedServiceByUuid(this, v18);
  v16 = v15;
  if (v15)
    CLMiLoService::labelObservationsBetweenDates(v14, a3, a4, v12, v13);

  return v16 != 0;
}

void sub_241A337F8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

uint64_t CLMiLoServiceManager::onTruthLabel(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)(*(_QWORD *)(a1 + 128) + 8) + 32))(*(_QWORD *)(a1 + 128) + 8);
}

uint64_t CLMiLoServiceManager::onTruthTagLabelForBetweenDates(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)(*(_QWORD *)(a1 + 128) + 8) + 48))(*(_QWORD *)(a1 + 128) + 8);
}

uint64_t CLMiLoServiceManager::addTriggerUuidForCachedTrigger(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)(*(_QWORD *)(a1 + 128) + 8) + 64))(*(_QWORD *)(a1 + 128) + 8);
}

uint64_t CLMiLoServiceManager::addTriggerEventForFutureLabeling(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)(*(_QWORD *)(a1 + 128) + 8) + 56))(*(_QWORD *)(a1 + 128) + 8);
}

uint64_t CLMiLoServiceManager::getModelsVector(CLMiLoServiceManager *this)
{
  return (uint64_t)this + 16;
}

uint64_t CLMiLoServiceManager::getModelOfService@<X0>(uint64_t this@<X0>, uuid a2@<0:X1, 8:X2>, _QWORD *a3@<X8>)
{
  uint64_t v4;
  uint64_t i;
  uint64_t v6;

  v4 = this + 40;
  for (i = *(_QWORD *)(this + 48); ; i = *(_QWORD *)(i + 8))
  {
    if (i == v4)
    {
      *a3 = 0;
      a3[1] = 0;
      return this;
    }
    this = CLMiLoService::uuid((CLMiLoService *)(i + 16));
    if (this == *(_QWORD *)a2.var0 && v6 == *(_QWORD *)&a2.var0[8])
      break;
  }
  return CLMiLoService::getModelPtr(i + 16, a3);
}

uint64_t std::vector<std::shared_ptr<CLMiLoService::ModelAndConf>>::erase(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  if (a2 != a3)
  {
    v5 = a3;
    v6 = *(_QWORD *)(a1 + 8);
    if (a3 == v6)
    {
      v8 = a2;
    }
    else
    {
      v7 = 16 * ((a3 - a2) >> 4);
      v8 = a2;
      do
      {
        std::shared_ptr<CLMicroLocationFingerprint>::operator=[abi:ne180100](v8, (__int128 *)(v8 + v7));
        v8 += 16;
      }
      while (v8 + v7 != v6);
      v5 = *(_QWORD *)(a1 + 8);
    }
    while (v5 != v8)
      v5 = std::shared_ptr<CLMiLoService::ModelAndConf>::~shared_ptr[abi:ne180100](v5 - 16);
    *(_QWORD *)(a1 + 8) = v8;
  }
  return a2;
}

uint64_t CLMiLoServiceManager::BiDirectionalUuidMap::eraseByKey(uint64_t **this, const uuid *a2)
{
  uint64_t *v2;
  uint64_t *v3;
  char v6;
  uint64_t *v8;
  uint64_t *v9;
  uint64_t *v10;

  v3 = (uint64_t *)(this + 1);
  v2 = *this;
  if (*this == (uint64_t *)(this + 1))
  {
    v6 = 0;
  }
  else
  {
    v6 = 0;
    do
    {
      if (*(uint64_t *)((char *)v2 + 25) == *(_QWORD *)a2->var0
        && *(uint64_t *)((char *)v2 + 33) == *(_QWORD *)&a2->var0[8])
      {
        v10 = std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::__remove_node_pointer(this, v2);
        operator delete(v2);
        v6 = 1;
        v2 = v10;
      }
      else
      {
        v8 = (uint64_t *)v2[1];
        if (v8)
        {
          do
          {
            v2 = v8;
            v8 = (uint64_t *)*v8;
          }
          while (v8);
        }
        else
        {
          do
          {
            v9 = v2;
            v2 = (uint64_t *)v2[2];
          }
          while ((uint64_t *)*v2 != v9);
        }
      }
    }
    while (v2 != v3);
  }
  return v6 & 1;
}

uint64_t CLMiLoServiceManager::loadModelForServiceOrCreateNewIfNecessary@<X0>(CLMiLoService *a1@<X0>, uint64_t a2@<X1>, const CLMicroLocationProto::Model *a3@<X2>, uint64_t *a4@<X3>, _QWORD *a5@<X8>)
{
  id v9;
  void *v10;
  id v11;
  uint64_t v12;
  uint64_t v13;
  id v14;
  uint64_t v15;
  uint64_t v16;
  id v17;
  void *v18;
  char *v19;
  uint64_t v20;
  id v22;
  void *v23;
  std::bad_cast_vtbl *v24;
  std::bad_cast_vtbl *v25;
  NSObject *v26;
  std::string *v27;
  void **v28;
  char *v29;
  char *v30;
  uint8_t *v31;
  std::bad_cast_vtbl *v32;
  std::bad_cast_vtbl *v33;
  std::string *v34;
  char *v35;
  char *v36;
  uint8_t *v37;
  NSObject *v38;
  std::string *v39;
  char *v40;
  uint8_t *v41;
  std::string::size_type v42;
  std::string *v43;
  NSObject *v44;
  std::string *v45;
  char *v46;
  uint8_t *v47;
  std::string::size_type v48;
  std::string *v49;
  NSObject *v50;
  std::string *v51;
  char *v52;
  uint8_t *v53;
  std::string::size_type v54;
  std::string *v55;
  std::string::size_type v56;
  std::bad_cast *v57;
  std::bad_cast *v58;
  uint64_t v59;
  uint64_t v60;
  _DWORD *v61;
  uint64_t v62;
  __int128 v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  double v70;
  uint64_t v71;
  id v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  double v76;
  uint64_t v77;
  NSObject *v78;
  std::string *v79;
  char *v80;
  uint64_t v81;
  std::string *v82;
  std::string v85;
  char v86;
  int v87;
  _QWORD v88[2];
  char v89;
  std::string v90;
  std::string v91[8];
  uint8_t buf[8];
  _BYTE v93[20];
  __int16 v94;
  char *v95;
  __int16 v96;
  uint64_t v97;
  __int16 v98;
  std::string *v99;
  void *v100;
  char v101;
  char v102;
  uint64_t v103;
  std::string v104;
  std::string __p[2];
  _OWORD v106[2];
  __int128 v107;
  __int128 v108;
  __int128 v109;
  __int128 v110;
  __int128 v111;
  __int128 v112;
  __int128 v113;
  __int128 v114;
  __int128 v115;
  __int128 v116;
  void *v117[2];
  __int128 v118;
  __int128 v119;
  __int128 v120;
  __int128 v121;
  uint64_t v122;
  uint64_t v123;
  void *v124;
  void *v125;
  void *v126;
  char v127;
  std::bad_cast v128[2];
  _OWORD v129[4];
  __int128 v130;
  __int128 v131;
  __int128 v132;
  __int128 v133;
  CLMicroLocationProto::LocationSimilarityListData *v134[2];
  __int128 v135;
  __int128 v136;
  __int128 v137;
  __int128 v138;
  __int128 v139;
  void *v140[2];
  __int128 v141;
  __int128 v142;
  __int128 v143;
  __int128 v144;
  uint64_t v145;
  uint64_t v146;
  void *v147;
  void *v148;
  void *v149;
  char v150;
  __int128 v151;
  char v152;
  uint64_t v153[2];
  double v154;
  unsigned int v155;
  const CLMicroLocationProto::Fingerprint **v156;
  std::string v157;
  char v158;
  uint64_t v159[2];
  char v160;
  __int128 v161;
  __int128 v162;
  uint64_t v163;

  v163 = *MEMORY[0x24BDAC8D0];
  LOBYTE(v153[0]) = 0;
  v160 = 0;
  if (CLMiLoService::serviceType(a1) == 1)
  {
    v9 = *(id *)(a2 + 72);
    v10 = v9;
    v151 = *(_OWORD *)(a4 + 1);
    v152 = 1;
    if (v9)
    {
      objc_msgSend(v9, "fetchMostRecentModelOfModelType:atLoiGroupId:", 0, &v151);
    }
    else
    {
      v120 = 0u;
      v121 = 0u;
      v118 = 0u;
      v119 = 0u;
      v116 = 0u;
      *(_OWORD *)v117 = 0u;
      v114 = 0u;
      v115 = 0u;
      v112 = 0u;
      v113 = 0u;
      v110 = 0u;
      v111 = 0u;
      v108 = 0u;
      v109 = 0u;
      v107 = 0u;
      memset(v106, 0, sizeof(v106));
      memset(__p, 0, sizeof(__p));
    }
    std::__optional_storage_base<CLMicroLocationModelTable::Entry,false>::__assign_from[abi:ne180100]<std::__optional_move_assign_base<CLMicroLocationModelTable::Entry,false>>((uint64_t)v153, (uint64_t)__p);
    std::__optional_destruct_base<CLMicroLocationModelTable::Entry,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)__p);

    if (!v160)
      goto LABEL_20;
    if (!v158)
    {
      CLMiLoService::modelClientIdentifierString(a1, __p);
      if (!v160)
        std::__throw_bad_optional_access[abi:ne180100]();
      std::optional<std::string>::operator=[abi:ne180100]<std::string const,void>(&v157, __p);
      if (SHIBYTE(__p[0].__r_.__value_.__r.__words[2]) < 0)
        operator delete(__p[0].__r_.__value_.__l.__data_);
      v14 = *(id *)(a2 + 72);
      if (!v160)
        std::__throw_bad_optional_access[abi:ne180100]();
      CLMicroLocationModelTable::Entry::Entry((CLMicroLocationModelTable::Entry *)__p, (const CLMicroLocationModelTable::Entry *)v153);
      v128[1].__vftable = 0;
      v128[0].__vftable = 0;
      *(_QWORD *)&v129[0] = 0;
      v93[0] = 0;
      v128[0].__vftable = (std::bad_cast_vtbl *)operator new(0x138uLL);
      v128[1] = v128[0];
      *(_QWORD *)&v129[0] = v128[0].__vftable + 13;
      v128[1].__vftable = (std::bad_cast_vtbl *)std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<CLMicroLocationModelTable::Entry>,CLMicroLocationModelTable::Entry const*,CLMicroLocationModelTable::Entry const*,CLMicroLocationModelTable::Entry*>((uint64_t)v129, (CLMicroLocationModelTable::Entry *)__p, (CLMicroLocationModelTable::Entry *)((char *)&v121 + 8), (CLMicroLocationModelTable::Entry *)v128[0].__vftable);
      objc_msgSend(v14, "insertEntries:", v128);
      *(_QWORD *)buf = v128;
      std::vector<CLMicroLocationModelTable::Entry>::__destroy_vector::operator()[abi:ne180100]((void ***)buf);
      if (BYTE8(v118) && SBYTE7(v118) < 0)
        operator delete(v117[0]);
      CLMicroLocationProto::Model::~Model((CLMicroLocationProto::Model *)&__p[1].__r_.__value_.__r.__words[1]);

    }
  }
  else
  {
    v11 = *(id *)(a2 + 72);
    v12 = CLMiLoService::uuid(a1);
    if (v11)
    {
      objc_msgSend(v11, "fetchMostRecentModelForServiceUuid:atLoiGroupId:", v12, v13, a4[1], a4[2]);
    }
    else
    {
      v120 = 0u;
      v121 = 0u;
      v118 = 0u;
      v119 = 0u;
      v116 = 0u;
      *(_OWORD *)v117 = 0u;
      v114 = 0u;
      v115 = 0u;
      v112 = 0u;
      v113 = 0u;
      v110 = 0u;
      v111 = 0u;
      v108 = 0u;
      v109 = 0u;
      v107 = 0u;
      memset(v106, 0, sizeof(v106));
      memset(__p, 0, sizeof(__p));
    }
    std::__optional_storage_base<CLMicroLocationModelTable::Entry,false>::__assign_from[abi:ne180100]<std::__optional_move_assign_base<CLMicroLocationModelTable::Entry,false>>((uint64_t)v153, (uint64_t)__p);
    std::__optional_destruct_base<CLMicroLocationModelTable::Entry,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)__p);

  }
  if (v160)
  {
LABEL_92:
    v16 = *a4;
    goto LABEL_93;
  }
LABEL_20:
  v15 = CLMiLoService::serviceType(a1);
  v16 = *a4;
  if (v15 == 4 && v16 != 2)
  {
    v162 = *(_OWORD *)(a4 + 1);
    v17 = *(id *)(a2 + 72);
    v18 = v17;
    *(_OWORD *)&v104.__r_.__value_.__l.__data_ = v162;
    v104.__r_.__value_.__s.__data_[16] = 1;
    if (v17)
    {
      objc_msgSend(v17, "fetchMostRecentModelOfModelType:atLoiGroupId:", 2, &v104);
    }
    else
    {
      v144 = 0u;
      v143 = 0u;
      v142 = 0u;
      v141 = 0u;
      *(_OWORD *)v140 = 0u;
      v139 = 0u;
      v138 = 0u;
      v137 = 0u;
      v136 = 0u;
      v135 = 0u;
      *(_OWORD *)v134 = 0u;
      v133 = 0u;
      v132 = 0u;
      v131 = 0u;
      v130 = 0u;
      memset(v129, 0, sizeof(v129));
      *(_OWORD *)&v128[0].__vftable = 0u;
    }

    std::string::basic_string[abi:ne180100]<0>(buf, "");
    if ((_BYTE)v162)
    {
LABEL_26:
      v19 = (char *)operator new(0x28uLL);
      *(_QWORD *)(v19 + 29) = 0;
      *(_OWORD *)v19 = 0u;
      *((_OWORD *)v19 + 1) = 0u;
      boost::uuids::to_chars<char *>((uint64_t)&v162, v19);
      if ((v93[15] & 0x80000000) != 0)
        operator delete(*(void **)buf);
      *(_QWORD *)buf = v19;
      *(_OWORD *)v93 = xmmword_241BB2320;
    }
    else
    {
      v20 = 1;
      while (v20 != 16)
      {
        if (*((unsigned __int8 *)&v162 + v20++))
        {
          if ((unint64_t)(v20 - 2) <= 0xE)
            goto LABEL_26;
          break;
        }
      }
    }
    if (BYTE8(v144))
    {
      CLMiLoService::getClientIdAndServiceUuid(a1, __p);
      if (!BYTE8(v144))
        std::__throw_bad_optional_access[abi:ne180100]();
      if (BYTE8(v141))
      {
        if (SBYTE7(v141) < 0)
          operator delete(v140[0]);
        *(_OWORD *)v140 = *(_OWORD *)&__p[0].__r_.__value_.__l.__data_;
        *(_QWORD *)&v141 = *((_QWORD *)&__p[0].__r_.__value_.__l + 2);
      }
      else
      {
        *(_OWORD *)v140 = *(_OWORD *)&__p[0].__r_.__value_.__l.__data_;
        *(_QWORD *)&v141 = *((_QWORD *)&__p[0].__r_.__value_.__l + 2);
        BYTE8(v141) = 1;
      }
      if (BYTE8(v144))
      {
        if (v134[1])
        {
          CLMicroLocationProto::LocationSimilarityListData::Clear(v134[1]);
          DWORD2(v139) &= ~0x400u;
          if (!BYTE8(v144))
            std::__throw_bad_optional_access[abi:ne180100]();
        }
        else
        {
          DWORD2(v139) &= ~0x400u;
        }
        *(_OWORD *)&v90.__r_.__value_.__l.__data_ = *(_OWORD *)&v128[0].__vftable;
        LODWORD(__p[0].__r_.__value_.__l.__data_) = 0;
        boost::uuids::detail::random_provider_base::random_provider_base((boost::uuids::detail::random_provider_base *)__p);
        v24 = (std::bad_cast_vtbl *)boost::uuids::random_generator_pure::operator()((uint64_t)__p);
        if (!BYTE8(v144))
          std::__throw_bad_optional_access[abi:ne180100]();
        v128[0].__vftable = v24;
        v128[1].__vftable = v25;
        boost::uuids::detail::random_provider_base::destroy((boost::uuids::detail::random_provider_base *)__p);
        if (onceToken_MicroLocation_Default != -1)
          dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_330);
        v26 = (id)logObject_MicroLocation_Default;
        if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
        {
          CLMiLoService::getClientIdAndServiceUuid(a1, v91);
          if ((v91[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            v27 = v91;
          else
            v27 = (std::string *)v91[0].__r_.__value_.__r.__words[0];
          if (!BYTE8(v144) || !BYTE8(v141))
            std::__throw_bad_optional_access[abi:ne180100]();
          if ((SBYTE7(v141) & 0x80u) == 0)
            v28 = v140;
          else
            v28 = (void **)v140[0];
          v29 = (char *)operator new(0x28uLL);
          *(_QWORD *)(v29 + 29) = 0;
          *(_OWORD *)v29 = 0u;
          *((_OWORD *)v29 + 1) = 0u;
          boost::uuids::to_chars<char *>((uint64_t)&v90, v29);
          if (!BYTE8(v144))
            std::__throw_bad_optional_access[abi:ne180100]();
          v30 = (char *)operator new(0x28uLL);
          *(_QWORD *)(v30 + 29) = 0;
          *(_OWORD *)v30 = 0u;
          *((_OWORD *)v30 + 1) = 0u;
          boost::uuids::to_chars<char *>((uint64_t)v128, v30);
          v31 = buf;
          if (v93[15] < 0)
            v31 = *(uint8_t **)buf;
          __p[0].__r_.__value_.__r.__words[0] = 68290562;
          LOWORD(__p[0].__r_.__value_.__r.__words[1]) = 2082;
          *(std::string::size_type *)((char *)&__p[0].__r_.__value_.__r.__words[1] + 2) = (std::string::size_type)"";
          WORD1(__p[0].__r_.__value_.__r.__words[2]) = 2082;
          *(std::string::size_type *)((char *)&__p[0].__r_.__value_.__r.__words[2] + 4) = (std::string::size_type)"LSL";
          WORD2(__p[1].__r_.__value_.__r.__words[0]) = 2082;
          *(std::string::size_type *)((char *)__p[1].__r_.__value_.__r.__words + 6) = (std::string::size_type)v27;
          HIWORD(__p[1].__r_.__value_.__r.__words[1]) = 2082;
          __p[1].__r_.__value_.__r.__words[2] = (std::string::size_type)v28;
          LOWORD(v106[0]) = 2082;
          *(_QWORD *)((char *)v106 + 2) = v29;
          WORD5(v106[0]) = 2082;
          *(_QWORD *)((char *)v106 + 12) = v30;
          WORD2(v106[1]) = 2082;
          *(_QWORD *)((char *)&v106[1] + 6) = v31;
          _os_log_impl(&dword_2419D9000, v26, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLMiLoServiceManager::findInstantModelForServiceOfTypeLSL, new LSL service looking for unsupervised model\", \"FoundModelType\":%{public, location:escape_only}s, \"ServiceId\":%{public, location:escape_only}s, \"UsingModelOf\":%{public, location:escape_only}s, \"OriginalLSLModelUUID\":%{public, location:escape_only}s, \"UsedModelUUID\":%{public, location:escape_only}s, \"AtLoi\":%{public, location:escape_only}s}", (uint8_t *)__p, 0x4Eu);
          operator delete(v30);
          operator delete(v29);
          if (SHIBYTE(v91[0].__r_.__value_.__r.__words[2]) < 0)
            operator delete(v91[0].__r_.__value_.__l.__data_);
        }
LABEL_88:

LABEL_89:
        if ((v93[15] & 0x80000000) != 0)
          operator delete(*(void **)buf);
        std::__optional_storage_base<CLMicroLocationModelTable::Entry,false>::__assign_from[abi:ne180100]<std::__optional_move_assign_base<CLMicroLocationModelTable::Entry,false>>((uint64_t)v153, (uint64_t)v128);
        std::__optional_destruct_base<CLMicroLocationModelTable::Entry,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)v128);
        goto LABEL_92;
      }
    }
    else
    {
      v22 = *(id *)(a2 + 72);
      v23 = v22;
      *(_OWORD *)&v90.__r_.__value_.__l.__data_ = v162;
      v90.__r_.__value_.__s.__data_[16] = 1;
      if (v22)
      {
        objc_msgSend(v22, "fetchMostRecentModelOfModelType:atLoiGroupId:", 0, &v90);
      }
      else
      {
        v120 = 0u;
        v121 = 0u;
        v118 = 0u;
        v119 = 0u;
        v116 = 0u;
        *(_OWORD *)v117 = 0u;
        v114 = 0u;
        v115 = 0u;
        v112 = 0u;
        v113 = 0u;
        v110 = 0u;
        v111 = 0u;
        v108 = 0u;
        v109 = 0u;
        v107 = 0u;
        memset(v106, 0, sizeof(v106));
        memset(__p, 0, sizeof(__p));
      }
      std::__optional_storage_base<CLMicroLocationModelTable::Entry,false>::__assign_from[abi:ne180100]<std::__optional_move_assign_base<CLMicroLocationModelTable::Entry,false>>((uint64_t)v128, (uint64_t)__p);
      std::__optional_destruct_base<CLMicroLocationModelTable::Entry,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)__p);

      if (!BYTE8(v144))
        goto LABEL_89;
      CLMiLoService::getClientIdAndServiceUuid(a1, __p);
      if (!BYTE8(v144))
        std::__throw_bad_optional_access[abi:ne180100]();
      if (BYTE8(v141))
      {
        if (SBYTE7(v141) < 0)
          operator delete(v140[0]);
        *(_OWORD *)v140 = *(_OWORD *)&__p[0].__r_.__value_.__l.__data_;
        *(_QWORD *)&v141 = *((_QWORD *)&__p[0].__r_.__value_.__l + 2);
      }
      else
      {
        *(_OWORD *)v140 = *(_OWORD *)&__p[0].__r_.__value_.__l.__data_;
        *(_QWORD *)&v141 = *((_QWORD *)&__p[0].__r_.__value_.__l + 2);
        BYTE8(v141) = 1;
      }
      if (BYTE8(v144))
      {
        DWORD2(v129[0]) = 2;
        if (!CLMicroLocationProto::MotionState_IsValid((CLMicroLocationProto *)2))
          __assert_rtn("set_modeltype", "microlocation.pb.h", 12679, "::CLMicroLocationProto::Model_ModelType_IsValid(value)");
        DWORD2(v139) |= 0x10u;
        DWORD1(v130) = 2;
        if (!BYTE8(v144))
          std::__throw_bad_optional_access[abi:ne180100]();
        v161 = *(_OWORD *)&v128[0].__vftable;
        LODWORD(__p[0].__r_.__value_.__l.__data_) = 0;
        boost::uuids::detail::random_provider_base::random_provider_base((boost::uuids::detail::random_provider_base *)__p);
        v32 = (std::bad_cast_vtbl *)boost::uuids::random_generator_pure::operator()((uint64_t)__p);
        if (!BYTE8(v144))
          std::__throw_bad_optional_access[abi:ne180100]();
        v128[0].__vftable = v32;
        v128[1].__vftable = v33;
        boost::uuids::detail::random_provider_base::destroy((boost::uuids::detail::random_provider_base *)__p);
        if (onceToken_MicroLocation_Default != -1)
          dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_330);
        v26 = (id)logObject_MicroLocation_Default;
        if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
        {
          v34 = v91;
          CLMiLoService::getClientIdAndServiceUuid(a1, v91);
          if ((v91[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
            v34 = (std::string *)v91[0].__r_.__value_.__r.__words[0];
          v35 = (char *)operator new(0x28uLL);
          *(_QWORD *)(v35 + 29) = 0;
          *(_OWORD *)v35 = 0u;
          *((_OWORD *)v35 + 1) = 0u;
          boost::uuids::to_chars<char *>((uint64_t)&v161, v35);
          if (!BYTE8(v144))
            std::__throw_bad_optional_access[abi:ne180100]();
          v36 = (char *)operator new(0x28uLL);
          *(_QWORD *)(v36 + 29) = 0;
          *(_OWORD *)v36 = 0u;
          *((_OWORD *)v36 + 1) = 0u;
          boost::uuids::to_chars<char *>((uint64_t)v128, v36);
          v37 = buf;
          if (v93[15] < 0)
            v37 = *(uint8_t **)buf;
          __p[0].__r_.__value_.__r.__words[0] = 68290306;
          LOWORD(__p[0].__r_.__value_.__r.__words[1]) = 2082;
          *(std::string::size_type *)((char *)&__p[0].__r_.__value_.__r.__words[1] + 2) = (std::string::size_type)"";
          WORD1(__p[0].__r_.__value_.__r.__words[2]) = 2082;
          *(std::string::size_type *)((char *)&__p[0].__r_.__value_.__r.__words[2] + 4) = (std::string::size_type)"unsupervised";
          WORD2(__p[1].__r_.__value_.__r.__words[0]) = 2082;
          *(std::string::size_type *)((char *)__p[1].__r_.__value_.__r.__words + 6) = (std::string::size_type)v34;
          HIWORD(__p[1].__r_.__value_.__r.__words[1]) = 2082;
          __p[1].__r_.__value_.__r.__words[2] = (std::string::size_type)v35;
          LOWORD(v106[0]) = 2082;
          *(_QWORD *)((char *)v106 + 2) = v36;
          WORD5(v106[0]) = 2082;
          *(_QWORD *)((char *)v106 + 12) = v37;
          _os_log_impl(&dword_2419D9000, v26, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLMiLoServiceManager::findInstantModelForServiceOfTypeLSL, new LSL service looking for unsupervised model\", \"FoundModelType\":%{public, location:escape_only}s, \"ServiceId\":%{public, location:escape_only}s, \"OriginalUnsupervisedModelUUID\":%{public, location:escape_only}s, \"UsedModelUUID\":%{public, location:escape_only}s, \"AtLoi\":%{public, location:escape_only}s}", (uint8_t *)__p, 0x44u);
          operator delete(v36);
          operator delete(v35);
          if (SHIBYTE(v91[0].__r_.__value_.__r.__words[2]) < 0)
            operator delete(v91[0].__r_.__value_.__l.__data_);
        }
        goto LABEL_88;
      }
    }
    std::__throw_bad_optional_access[abi:ne180100]();
  }
LABEL_93:
  if (v16 == 2 && CLMiLoService::serviceType(a1) == 4)
  {
    if (!v160)
      goto LABEL_169;
    if (v155 != 3)
    {
      if (onceToken_MicroLocation_Default != -1)
        dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_330);
      v38 = (id)logObject_MicroLocation_Default;
      if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR))
      {
        if (!v160 || !v158)
          std::__throw_bad_optional_access[abi:ne180100]();
        if ((v157.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v39 = &v157;
        else
          v39 = (std::string *)v157.__r_.__value_.__r.__words[0];
        v40 = (char *)operator new(0x28uLL);
        *(_QWORD *)buf = v40;
        *(_OWORD *)v93 = xmmword_241BB2320;
        *(_OWORD *)v40 = 0u;
        *((_OWORD *)v40 + 1) = 0u;
        *(_QWORD *)(v40 + 29) = 0;
        boost::uuids::to_chars<char *>((uint64_t)v153, v40);
        if (v93[15] >= 0)
          v41 = buf;
        else
          v41 = *(uint8_t **)buf;
        if (!v160)
          std::__throw_bad_optional_access[abi:ne180100]();
        v42 = v155;
        memset(v91, 0, 24);
        if ((boost::conversion::detail::try_lexical_convert<std::string,boost::uuids::uuid>((uint64_t)v159, v91) & 1) == 0)
        {
          std::bad_cast::bad_cast(v128);
          v128[0].__vftable = (std::bad_cast_vtbl *)&unk_2511D2C18;
          boost::throw_exception<boost::bad_lexical_cast>((uint64_t)v128);
        }
        v43 = v91;
        if ((v91[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
          v43 = (std::string *)v91[0].__r_.__value_.__r.__words[0];
        __p[0].__r_.__value_.__r.__words[0] = 68290051;
        LOWORD(__p[0].__r_.__value_.__r.__words[1]) = 2082;
        *(std::string::size_type *)((char *)&__p[0].__r_.__value_.__r.__words[1] + 2) = (std::string::size_type)"";
        WORD1(__p[0].__r_.__value_.__r.__words[2]) = 2082;
        *(std::string::size_type *)((char *)&__p[0].__r_.__value_.__r.__words[2] + 4) = (std::string::size_type)v39;
        WORD2(__p[1].__r_.__value_.__r.__words[0]) = 2082;
        *(std::string::size_type *)((char *)__p[1].__r_.__value_.__r.__words + 6) = (std::string::size_type)v41;
        HIWORD(__p[1].__r_.__value_.__r.__words[1]) = 2050;
        __p[1].__r_.__value_.__r.__words[2] = v42;
        LOWORD(v106[0]) = 2081;
        *(_QWORD *)((char *)v106 + 2) = v43;
        _os_log_impl(&dword_2419D9000, v38, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"CLMiLoServiceManager loaded incorrect model type for LSL service in custom LOI, this should never happen!!!\", \"ClientId\":%{public, location:escape_only}s, \"ModelUuid\":%{public, location:escape_only}s, \"ModelType\":%{public}lld, \"LOI ID\":%{private, location:escape_only}s}", (uint8_t *)__p, 0x3Au);
        if (SHIBYTE(v91[0].__r_.__value_.__r.__words[2]) < 0)
          operator delete(v91[0].__r_.__value_.__l.__data_);
        if ((v93[15] & 0x80000000) != 0)
          operator delete(*(void **)buf);
      }

      if (onceToken_MicroLocation_Default != -1)
        dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_330);
      v44 = (id)logObject_MicroLocation_Default;
      if (os_signpost_enabled(v44))
      {
        if (!v160 || !v158)
          std::__throw_bad_optional_access[abi:ne180100]();
        if ((v157.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v45 = &v157;
        else
          v45 = (std::string *)v157.__r_.__value_.__r.__words[0];
        v46 = (char *)operator new(0x28uLL);
        *(_QWORD *)buf = v46;
        *(_OWORD *)v93 = xmmword_241BB2320;
        *(_OWORD *)v46 = 0u;
        *((_OWORD *)v46 + 1) = 0u;
        *(_QWORD *)(v46 + 29) = 0;
        boost::uuids::to_chars<char *>((uint64_t)v153, v46);
        if (v93[15] >= 0)
          v47 = buf;
        else
          v47 = *(uint8_t **)buf;
        if (!v160)
          std::__throw_bad_optional_access[abi:ne180100]();
        v48 = v155;
        memset(v91, 0, 24);
        if ((boost::conversion::detail::try_lexical_convert<std::string,boost::uuids::uuid>((uint64_t)v159, v91) & 1) == 0)
        {
          std::bad_cast::bad_cast(v128);
          v128[0].__vftable = (std::bad_cast_vtbl *)&unk_2511D2C18;
          boost::throw_exception<boost::bad_lexical_cast>((uint64_t)v128);
        }
        v49 = v91;
        if ((v91[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
          v49 = (std::string *)v91[0].__r_.__value_.__r.__words[0];
        __p[0].__r_.__value_.__r.__words[0] = 68290051;
        LOWORD(__p[0].__r_.__value_.__r.__words[1]) = 2082;
        *(std::string::size_type *)((char *)&__p[0].__r_.__value_.__r.__words[1] + 2) = (std::string::size_type)"";
        WORD1(__p[0].__r_.__value_.__r.__words[2]) = 2082;
        *(std::string::size_type *)((char *)&__p[0].__r_.__value_.__r.__words[2] + 4) = (std::string::size_type)v45;
        WORD2(__p[1].__r_.__value_.__r.__words[0]) = 2082;
        *(std::string::size_type *)((char *)__p[1].__r_.__value_.__r.__words + 6) = (std::string::size_type)v47;
        HIWORD(__p[1].__r_.__value_.__r.__words[1]) = 2050;
        __p[1].__r_.__value_.__r.__words[2] = v48;
        LOWORD(v106[0]) = 2081;
        *(_QWORD *)((char *)v106 + 2) = v49;
        _os_signpost_emit_with_name_impl(&dword_2419D9000, v44, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "CLMiLoServiceManager loaded incorrect model type for LSL service in custom LOI, this should never happen!!!", "{\"msg%{public}.0s\":\"CLMiLoServiceManager loaded incorrect model type for LSL service in custom LOI, this should never happen!!!\", \"ClientId\":%{public, location:escape_only}s, \"ModelUuid\":%{public, location:escape_only}s, \"ModelType\":%{public}lld, \"LOI ID\":%{private, location:escape_only}s}", (uint8_t *)__p, 0x3Au);
        if (SHIBYTE(v91[0].__r_.__value_.__r.__words[2]) < 0)
          operator delete(v91[0].__r_.__value_.__l.__data_);
        if ((v93[15] & 0x80000000) != 0)
          operator delete(*(void **)buf);
      }

      std::__optional_destruct_base<CLMicroLocationModelTable::Entry,false>::reset[abi:ne180100]((uint64_t)v153);
    }
  }
  if (v160)
  {
    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_330);
    v50 = (id)logObject_MicroLocation_Default;
    if (os_log_type_enabled(v50, OS_LOG_TYPE_DEFAULT))
    {
      if (!v160 || !v158)
        std::__throw_bad_optional_access[abi:ne180100]();
      if ((v157.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v51 = &v157;
      else
        v51 = (std::string *)v157.__r_.__value_.__r.__words[0];
      v52 = (char *)operator new(0x28uLL);
      *(_QWORD *)buf = v52;
      *(_OWORD *)v93 = xmmword_241BB2320;
      *(_OWORD *)v52 = 0u;
      *((_OWORD *)v52 + 1) = 0u;
      *(_QWORD *)(v52 + 29) = 0;
      boost::uuids::to_chars<char *>((uint64_t)v153, v52);
      if (v93[15] >= 0)
        v53 = buf;
      else
        v53 = *(uint8_t **)buf;
      if (!v160)
        std::__throw_bad_optional_access[abi:ne180100]();
      v54 = v155;
      memset(v91, 0, 24);
      if ((boost::conversion::detail::try_lexical_convert<std::string,boost::uuids::uuid>((uint64_t)v159, v91) & 1) == 0)
      {
        std::bad_cast::bad_cast(v128);
        v128[0].__vftable = (std::bad_cast_vtbl *)&unk_2511D2C18;
        boost::throw_exception<boost::bad_lexical_cast>((uint64_t)v128);
      }
      v55 = v91;
      if ((v91[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
        v55 = (std::string *)v91[0].__r_.__value_.__r.__words[0];
      __p[0].__r_.__value_.__r.__words[0] = 68290051;
      LOWORD(__p[0].__r_.__value_.__r.__words[1]) = 2082;
      *(std::string::size_type *)((char *)&__p[0].__r_.__value_.__r.__words[1] + 2) = (std::string::size_type)"";
      WORD1(__p[0].__r_.__value_.__r.__words[2]) = 2082;
      *(std::string::size_type *)((char *)&__p[0].__r_.__value_.__r.__words[2] + 4) = (std::string::size_type)v51;
      WORD2(__p[1].__r_.__value_.__r.__words[0]) = 2082;
      *(std::string::size_type *)((char *)__p[1].__r_.__value_.__r.__words + 6) = (std::string::size_type)v53;
      HIWORD(__p[1].__r_.__value_.__r.__words[1]) = 2050;
      __p[1].__r_.__value_.__r.__words[2] = v54;
      LOWORD(v106[0]) = 2081;
      *(_QWORD *)((char *)v106 + 2) = v55;
      _os_log_impl(&dword_2419D9000, v50, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLMiLoServiceManager loaded model from DB:\", \"ClientId\":%{public, location:escape_only}s, \"ModelUuid\":%{public, location:escape_only}s, \"ModelType\":%{public}lld, \"LOI ID\":%{private, location:escape_only}s}", (uint8_t *)__p, 0x3Au);
      if (SHIBYTE(v91[0].__r_.__value_.__r.__words[2]) < 0)
        operator delete(v91[0].__r_.__value_.__l.__data_);
      if ((v93[15] & 0x80000000) != 0)
        operator delete(*(void **)buf);
    }

    if (!v160)
      std::__throw_bad_optional_access[abi:ne180100]();
    CLMicroLocationModel::fromProtobuf(&v156, a3, (uint64_t)__p);
    if (!v160)
      std::__throw_bad_optional_access[abi:ne180100]();
    CLMiLoService::modelClientIdentifierString(a1, (std::string *)v128);
    v91[0].__r_.__value_.__r.__words[0] = CLMiLoService::uuid(a1);
    v91[0].__r_.__value_.__l.__size_ = v56;
    if (!v160)
      std::__throw_bad_optional_access[abi:ne180100]();
    CLMiLoService::settingsString(a1, buf);
    if (!v160)
      std::__throw_bad_optional_access[abi:ne180100]();
    std::allocate_shared[abi:ne180100]<CLMiLoService::ModelAndConf,std::allocator<CLMiLoService::ModelAndConf>,CLMicroLocationModel,boost::uuids::uuid &,std::string const,boost::uuids::uuid,boost::uuids::uuid &,std::string,std::chrono::time_point<cl::chrono::CFAbsoluteTimeClock,std::chrono::duration<long double,std::ratio<1l,1l>>> &,void>((const CLMicroLocationModel *)__p, v153, (__int128 *)v128, (uint64_t *)v91, v159, (__int128 *)buf, &v154, a5);
    if ((v93[15] & 0x80000000) != 0)
      operator delete(*(void **)buf);
    if (SBYTE7(v129[0]) < 0)
      operator delete(v128[0].__vftable);
    if (v127 < 0)
      operator delete(v126);
    if (v124)
    {
      v125 = v124;
      operator delete(v124);
    }
    v57 = (std::bad_cast *)__p;
    std::__hash_table<std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>>>::~__hash_table((uint64_t)&v123);
    v128[0].__vftable = (std::bad_cast_vtbl *)&v122;
    v58 = v128;
    goto LABEL_203;
  }
LABEL_169:
  CLMicroLocationModel::CLMicroLocationModel((CLMicroLocationModel *)v128);
  v59 = CLMiLoService::serviceType(a1);
  HIDWORD(v128[0].__vftable) = CLMiLoService::modelTypeByServiceAndLocationType(v59, *a4);
  v60 = CLMiLoService::serviceType(a1);
  LODWORD(v128[0].__vftable) = CLMiLoService::generationAlgorithmByServiceAndLocationType(v60, *a4);
  CLMicroLocationModel::setQualityIndicator((uint64_t)v128, 1);
  v61 = operator new(4uLL);
  __p[0].__r_.__value_.__r.__words[0] = (std::string::size_type)v61;
  *v61 = 3;
  __p[0].__r_.__value_.__r.__words[2] = (std::string::size_type)(v61 + 1);
  __p[0].__r_.__value_.__l.__size_ = (std::string::size_type)(v61 + 1);
  CLMicroLocationModel::setCandidateQualityReasons((uint64_t)v128, (uint64_t)__p);
  if (__p[0].__r_.__value_.__r.__words[0])
  {
    __p[0].__r_.__value_.__l.__size_ = __p[0].__r_.__value_.__r.__words[0];
    operator delete(__p[0].__r_.__value_.__l.__data_);
  }
  v161 = 0uLL;
  LODWORD(__p[0].__r_.__value_.__l.__data_) = 0;
  boost::uuids::detail::random_provider_base::random_provider_base((boost::uuids::detail::random_provider_base *)__p);
  *(_QWORD *)&v161 = boost::uuids::random_generator_pure::operator()((uint64_t)__p);
  *((_QWORD *)&v161 + 1) = v62;
  boost::uuids::detail::random_provider_base::destroy((boost::uuids::detail::random_provider_base *)__p);
  v63 = v161;
  CLMiLoService::modelClientIdentifierString(a1, (std::string *)buf);
  v64 = CLMiLoService::uuid(a1);
  v66 = v65;
  v67 = a4[1];
  v69 = a4[2];
  v68 = (uint64_t)(a4 + 1);
  CLMiLoService::settingsString(a1, v91);
  v70 = cl::chrono::CFAbsoluteTimeClock::now();
  CLMiLoService::ModelAndConf::ModelAndConf((uint64_t)__p, (const CLMicroLocationModel *)v128, v63, *((uint64_t *)&v63 + 1), (__int128 *)buf, v64, v66, v70, v71, v67, v69, (__int128 *)v91);
  if (SHIBYTE(v91[0].__r_.__value_.__r.__words[2]) < 0)
    operator delete(v91[0].__r_.__value_.__l.__data_);
  if ((v93[15] & 0x80000000) != 0)
    operator delete(*(void **)buf);
  v72 = *(id *)(a2 + 72);
  v87 = 0;
  boost::uuids::detail::random_provider_base::random_provider_base((boost::uuids::detail::random_provider_base *)&v87);
  v73 = boost::uuids::random_generator_pure::operator()((uint64_t)&v87);
  v75 = v74;
  v76 = cl::chrono::CFAbsoluteTimeClock::now();
  CLMicroLocationModel::toProtobuf((CLMicroLocationModel *)__p, (uint64_t)v91);
  CLMiLoService::modelClientIdentifierString(a1, &v90);
  if (SHIBYTE(v90.__r_.__value_.__r.__words[2]) < 0)
    std::string::__init_copy_ctor_external(&v85, v90.__r_.__value_.__l.__data_, v90.__r_.__value_.__l.__size_);
  else
    v85 = v90;
  v86 = 1;
  v88[0] = CLMiLoService::uuid(a1);
  v88[1] = v77;
  v89 = 1;
  CLMicroLocationModelTable::Entry::Entry(buf, v73, v75, v91, &v85, v88, a4[1], a4[2], v76);
  memset(&v104, 0, sizeof(v104));
  *(_QWORD *)&v162 = &v104;
  BYTE8(v162) = 0;
  v104.__r_.__value_.__r.__words[0] = (std::string::size_type)operator new(0x138uLL);
  v104.__r_.__value_.__l.__size_ = v104.__r_.__value_.__r.__words[0];
  v104.__r_.__value_.__r.__words[2] = v104.__r_.__value_.__r.__words[0] + 312;
  v104.__r_.__value_.__l.__size_ = (std::string::size_type)std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<CLMicroLocationModelTable::Entry>,CLMicroLocationModelTable::Entry const*,CLMicroLocationModelTable::Entry const*,CLMicroLocationModelTable::Entry*>((uint64_t)&v104.__r_.__value_.__r.__words[2], (CLMicroLocationModelTable::Entry *)buf, (CLMicroLocationModelTable::Entry *)&v103, (CLMicroLocationModelTable::Entry *)v104.__r_.__value_.__l.__data_);
  objc_msgSend(v72, "insertEntries:", &v104);
  *(_QWORD *)&v162 = &v104;
  std::vector<CLMicroLocationModelTable::Entry>::__destroy_vector::operator()[abi:ne180100]((void ***)&v162);
  if (v102 && v101 < 0)
    operator delete(v100);
  CLMicroLocationProto::Model::~Model((CLMicroLocationProto::Model *)((char *)&v95 + 2));
  if (v86 && SHIBYTE(v85.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v85.__r_.__value_.__l.__data_);
  if (SHIBYTE(v90.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v90.__r_.__value_.__l.__data_);
  CLMicroLocationProto::Model::~Model((CLMicroLocationProto::Model *)v91);
  boost::uuids::detail::random_provider_base::destroy((boost::uuids::detail::random_provider_base *)&v87);

  if (onceToken_MicroLocation_Default != -1)
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_330);
  v78 = (id)logObject_MicroLocation_Default;
  if (os_log_type_enabled(v78, OS_LOG_TYPE_DEFAULT))
  {
    v79 = &v104;
    CLMiLoService::modelClientIdentifierString(a1, &v104);
    if ((v104.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
      v79 = (std::string *)v104.__r_.__value_.__r.__words[0];
    v80 = (char *)operator new(0x28uLL);
    *(_QWORD *)(v80 + 29) = 0;
    *(_OWORD *)v80 = 0u;
    *((_OWORD *)v80 + 1) = 0u;
    boost::uuids::to_chars<char *>((uint64_t)&v161, v80);
    v81 = HIDWORD(v128[0].__vftable);
    memset(&v90, 0, sizeof(v90));
    if ((boost::conversion::detail::try_lexical_convert<std::string,boost::uuids::uuid>(v68, &v90) & 1) == 0)
    {
      std::bad_cast::bad_cast((std::bad_cast *)v91);
      v91[0].__r_.__value_.__r.__words[0] = (std::string::size_type)&unk_2511D2C18;
      boost::throw_exception<boost::bad_lexical_cast>((uint64_t)v91);
    }
    v82 = &v90;
    if ((v90.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
      v82 = (std::string *)v90.__r_.__value_.__r.__words[0];
    *(_DWORD *)buf = 68290051;
    *(_DWORD *)&buf[4] = 0;
    *(_WORD *)v93 = 2082;
    *(_QWORD *)&v93[2] = "";
    *(_WORD *)&v93[10] = 2082;
    *(_QWORD *)&v93[12] = v79;
    v94 = 2082;
    v95 = v80;
    v96 = 2050;
    v97 = v81;
    v98 = 2081;
    v99 = v82;
    _os_log_impl(&dword_2419D9000, v78, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLMiLoServiceManager created empty model:\", \"ClientId\":%{public, location:escape_only}s, \"ModelUuid\":%{public, location:escape_only}s, \"ModelType\":%{public}lld, \"LOI ID\":%{private, location:escape_only}s}", buf, 0x3Au);
    if (SHIBYTE(v90.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v90.__r_.__value_.__l.__data_);
    operator delete(v80);
    if (SHIBYTE(v104.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v104.__r_.__value_.__l.__data_);
  }

  std::allocate_shared[abi:ne180100]<CLMiLoService::ModelAndConf,std::allocator<CLMiLoService::ModelAndConf>,CLMiLoService::ModelAndConf&,void>((const CLMiLoService::ModelAndConf *)__p, a5);
  CLMiLoService::ModelAndConf::~ModelAndConf((CLMiLoService::ModelAndConf *)__p);
  if (v150 < 0)
    operator delete(v149);
  if (v147)
  {
    v148 = v147;
    operator delete(v147);
  }
  v57 = v128;
  std::__hash_table<std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>>>::~__hash_table((uint64_t)&v146);
  __p[0].__r_.__value_.__r.__words[0] = (std::string::size_type)&v145;
  v58 = (std::bad_cast *)__p;
LABEL_203:
  std::vector<std::pair<std::shared_ptr<CLMicroLocationFingerprint>,boost::uuids::uuid>>::__destroy_vector::operator()[abi:ne180100]((void ***)v58);
  std::__optional_destruct_base<CLMicroLocationModel::BlueAtlasData,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)&v57[25]);
  std::__optional_destruct_base<CLMicroLocationModel::SimilarityListData,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)&v57[9]);
  std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>>>::~__hash_table((uint64_t)&v57[2]);
  return std::__optional_destruct_base<CLMicroLocationModelTable::Entry,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)v153);
}

void sub_241A34F6C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *a21,uint64_t a22,uint64_t a23,uint64_t a24,void *__p,uint64_t a26,int a27,__int16 a28,char a29,char a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,void *a54,uint64_t a55,int a56,__int16 a57,char a58,char a59)
{
  void *v59;
  void *v60;
  void *v61;

  operator delete(v61);
  operator delete(v60);
  if (a30 < 0)
    operator delete(__p);

  if (a59 < 0)
    operator delete(a54);
  std::__optional_destruct_base<CLMicroLocationModelTable::Entry,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)&STACK[0x540]);
  std::__optional_destruct_base<CLMicroLocationModelTable::Entry,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)&STACK[0x720]);
  _Unwind_Resume(a1);
}

void CLMicroLocationModelTable::Entry::~Entry(void **this)
{
  if (*((_BYTE *)this + 264) && *((char *)this + 263) < 0)
    operator delete(this[30]);
  CLMicroLocationProto::Model::~Model((CLMicroLocationProto::Model *)(this + 4));
}

_QWORD *CLMiLoServiceManager::modelByServiceAndLocation@<X0>(CLMiLoService *this@<X1>, uint64_t a2@<X0>, _QWORD *a3@<X8>)
{
  _QWORD *v5;
  _QWORD *v6;
  _QWORD *v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t *v11;
  unint64_t v12;
  _QWORD *v13;
  uint64_t v14;
  _QWORD *result;
  uint64_t v16;
  _BYTE v17[24];
  _BYTE *v18;
  _QWORD v19[3];
  _QWORD *v20;
  _QWORD v21[3];
  _QWORD *v22;
  uint64_t v23;

  v23 = *MEMORY[0x24BDAC8D0];
  v22 = v21;
  v19[0] = &off_2511D4480;
  v19[1] = this;
  v20 = v19;
  v21[0] = &off_2511D43F0;
  v5 = *(_QWORD **)(a2 + 16);
  v6 = *(_QWORD **)(a2 + 24);
  if (CLMiLoService::serviceType(this) == 1)
    v7 = v21;
  else
    v7 = v19;
  std::__function::__value_func<double ()(CLMicroLocationFingerprint const&,CLMicroLocationFingerprint const&)>::__value_func[abi:ne180100]((uint64_t)v17, (uint64_t)v7);
  if (v5 != v6)
  {
    while (1)
    {
      if (!v18)
        std::__throw_bad_function_call[abi:ne180100]();
      if (((*(uint64_t (**)(_BYTE *, _QWORD *))(*(_QWORD *)v18 + 48))(v18, v5) & 1) != 0)
        break;
      v5 += 2;
      if (v5 == v6)
      {
        v5 = v6;
        break;
      }
    }
  }
  v8 = v18;
  if (v18 == v17)
  {
    v9 = 4;
    v8 = v17;
  }
  else
  {
    if (!v18)
      goto LABEL_14;
    v9 = 5;
  }
  (*(void (**)(void))(*v8 + 8 * v9))();
LABEL_14:
  if (v5 == *(_QWORD **)(a2 + 24))
  {
    *a3 = 0;
    a3[1] = 0;
  }
  else
  {
    *a3 = *v5;
    v10 = v5[1];
    a3[1] = v10;
    if (v10)
    {
      v11 = (unint64_t *)(v10 + 8);
      do
        v12 = __ldxr(v11);
      while (__stxr(v12 + 1, v11));
    }
  }
  v13 = v20;
  if (v20 == v19)
  {
    v14 = 4;
    v13 = v19;
  }
  else
  {
    if (!v20)
      goto LABEL_25;
    v14 = 5;
  }
  (*(void (**)(void))(*v13 + 8 * v14))();
LABEL_25:
  result = v22;
  if (v22 == v21)
  {
    v16 = 4;
    result = v21;
  }
  else
  {
    if (!v22)
      return result;
    v16 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v16))();
}

void sub_241A3561C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16, uint64_t a17, uint64_t a18, char *a19, char a20,uint64_t a21,uint64_t a22,char *a23)
{
  char *v24;
  uint64_t v25;
  char *v26;
  uint64_t v27;

  v24 = a19;
  if (a19 == &a16)
  {
    v25 = 4;
    v24 = &a16;
  }
  else
  {
    if (!a19)
      goto LABEL_6;
    v25 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v24 + 8 * v25))();
LABEL_6:
  v26 = a23;
  if (a23 == &a20)
  {
    v27 = 4;
    v26 = &a20;
  }
  else
  {
    if (!a23)
      goto LABEL_11;
    v27 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v26 + 8 * v27))();
LABEL_11:
  std::shared_ptr<CLMiLoService::ModelAndConf>::~shared_ptr[abi:ne180100]((uint64_t)&a10);
  _Unwind_Resume(a1);
}

uint64_t std::vector<std::shared_ptr<CLMiLoService::ModelAndConf>>::push_back[abi:ne180100](char **a1, __int128 *a2)
{
  uint64_t result;
  unint64_t v5;
  unint64_t v6;
  char *v7;
  uint64_t v8;
  unint64_t *v9;
  unint64_t v10;
  char *v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  unint64_t v15;
  char *v16;
  uint64_t v17;
  char *v18;
  __int128 v19;
  unint64_t *v20;
  unint64_t v21;
  char *v22;
  char *v23;
  char *v24;
  __int128 v25;
  int64x2_t v26;
  char *v27;
  uint64_t v28;
  int64x2_t v29;
  char *v30;
  uint64_t v31;

  v6 = (unint64_t)a1[2];
  result = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(char **)(result - 8);
  if ((unint64_t)v7 >= v6)
  {
    v12 = (v7 - *a1) >> 4;
    v13 = v12 + 1;
    if ((unint64_t)(v12 + 1) >> 60)
      std::vector<CLMicroLocationProto::ConfidenceReason>::__throw_length_error[abi:ne180100]();
    v14 = v5 - (_QWORD)*a1;
    if (v14 >> 3 > v13)
      v13 = v14 >> 3;
    if ((unint64_t)v14 >= 0x7FFFFFFFFFFFFFF0)
      v15 = 0xFFFFFFFFFFFFFFFLL;
    else
      v15 = v13;
    v31 = result;
    v16 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<boost::uuids::uuid>>(result, v15);
    v18 = &v16[16 * v12];
    v19 = *a2;
    *(_OWORD *)v18 = *a2;
    if (*((_QWORD *)&v19 + 1))
    {
      v20 = (unint64_t *)(*((_QWORD *)&v19 + 1) + 8);
      do
        v21 = __ldxr(v20);
      while (__stxr(v21 + 1, v20));
    }
    v23 = *a1;
    v22 = a1[1];
    if (v22 == *a1)
    {
      v26 = vdupq_n_s64((unint64_t)v22);
      v24 = &v16[16 * v12];
    }
    else
    {
      v24 = &v16[16 * v12];
      do
      {
        v25 = *((_OWORD *)v22 - 1);
        v22 -= 16;
        *((_OWORD *)v24 - 1) = v25;
        v24 -= 16;
        *(_QWORD *)v22 = 0;
        *((_QWORD *)v22 + 1) = 0;
      }
      while (v22 != v23);
      v26 = *(int64x2_t *)a1;
    }
    v11 = v18 + 16;
    *a1 = v24;
    a1[1] = v18 + 16;
    v29 = v26;
    v27 = a1[2];
    a1[2] = &v16[16 * v17];
    v30 = v27;
    v28 = v26.i64[0];
    result = std::__split_buffer<std::shared_ptr<CLMiLoService::ModelAndConf>>::~__split_buffer((uint64_t)&v28);
  }
  else
  {
    *(_QWORD *)v7 = *(_QWORD *)a2;
    v8 = *((_QWORD *)a2 + 1);
    *((_QWORD *)v7 + 1) = v8;
    if (v8)
    {
      v9 = (unint64_t *)(v8 + 8);
      do
        v10 = __ldxr(v9);
      while (__stxr(v10 + 1, v9));
    }
    v11 = v7 + 16;
  }
  a1[1] = v11;
  return result;
}

uint64_t ___ZN20CLMiLoServiceManager15updateAllModelsEv_block_invoke(uint64_t a1)
{
  CLMiLoServiceManager *v1;
  int64x2_t *i;

  v1 = *(CLMiLoServiceManager **)(a1 + 32);
  CLMiLoServiceManager::releaseAllModels(v1);
  for (i = (int64x2_t *)*((_QWORD *)v1 + 6); i != (int64x2_t *)((char *)v1 + 40); i = (int64x2_t *)i->i64[1])
    CLMiLoServiceManager::enterLocationPerService(v1, i + 1);
  return CLMiLoServiceManager::checkSpectating(v1);
}

void CLMiLoServiceManager::didRecordingStop(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;

  v2 = a1 + 40;
  v3 = *(_QWORD *)(a1 + 48);
  if (v3 != a1 + 40)
  {
    do
    {
      CLMiLoService::didRecordingStop((_QWORD *)(v3 + 16), a2);
      v3 = *(_QWORD *)(v3 + 8);
    }
    while (v3 != v2);
  }
}

uint64_t CLMiLoServiceManager::onLocalizationRequest(uint64_t a1, uint64_t a2, uint64_t *a3, __int128 *a4, uint64_t a5, uint64_t a6)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  __int128 v10;
  char v11;
  uint64_t v12;

  v12 = *MEMORY[0x24BDAC8D0];
  v6 = *(_QWORD *)(a1 + 128);
  v7 = *a3;
  v8 = a3[1];
  v10 = *a4;
  v11 = *((_BYTE *)a4 + 16);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, __int128 *, uint64_t, uint64_t))(*(_QWORD *)(v6 + 8) + 24))(v6 + 8, a2, v7, v8, &v10, a5, a6);
}

uint64_t CLMiLoServiceManager::onSendPredictionResultsToClient(uint64_t a1, const uuid *a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v8;
  _BYTE v10[17];
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  v8 = CLMiLoServiceManager::BiDirectionalUuidMap::lookupByKey((CLMiLoServiceManager::BiDirectionalUuidMap *)(a1 + 64), a2, v10);
  if (!v10[16])
    CLMiLoServiceManager::onSendPredictionResultsToClient(v8);
  return (*(uint64_t (**)(_QWORD, const uuid *, uint64_t, uint64_t, _BYTE *))(**(_QWORD **)(a1 + 128) + 48))(*(_QWORD *)(a1 + 128), a2, a3, a4, v10);
}

_QWORD *CLMiLoServiceManager::BiDirectionalUuidMap::lookupByKey@<X0>(CLMiLoServiceManager::BiDirectionalUuidMap *this@<X0>, const uuid *a2@<X1>, _BYTE *a3@<X8>)
{
  _QWORD *result;
  _QWORD *v4;
  _QWORD *v5;
  BOOL v6;
  _QWORD *v7;
  _QWORD *v8;
  char v9;

  v5 = *(_QWORD **)this;
  result = (_QWORD *)((char *)this + 8);
  v4 = v5;
  if (v5 == result)
  {
LABEL_12:
    v9 = 0;
    *a3 = 0;
  }
  else
  {
    while (1)
    {
      v6 = *(_QWORD *)((char *)v4 + 25) == *(_QWORD *)a2->var0
        && *(_QWORD *)((char *)v4 + 33) == *(_QWORD *)&a2->var0[8];
      if (v6)
        break;
      v7 = (_QWORD *)v4[1];
      if (v7)
      {
        do
        {
          v8 = v7;
          v7 = (_QWORD *)*v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          v8 = (_QWORD *)v4[2];
          v6 = *v8 == (_QWORD)v4;
          v4 = v8;
        }
        while (!v6);
      }
      v4 = v8;
      if (v8 == result)
        goto LABEL_12;
    }
    *(_OWORD *)a3 = *(_OWORD *)((char *)v4 + 41);
    v9 = 1;
  }
  a3[16] = v9;
  return result;
}

uint64_t CLMiLoServiceManager::onSendRequestResponseToClient(uint64_t a1, const uuid *a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v8;
  _BYTE v10[17];
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  v8 = CLMiLoServiceManager::BiDirectionalUuidMap::lookupByKey((CLMiLoServiceManager::BiDirectionalUuidMap *)(a1 + 64), a2, v10);
  if (!v10[16])
    CLMiLoServiceManager::onSendRequestResponseToClient(v8);
  return (*(uint64_t (**)(_QWORD, const uuid *, uint64_t, uint64_t, _BYTE *))(**(_QWORD **)(a1 + 128) + 24))(*(_QWORD *)(a1 + 128), a2, a3, a4, v10);
}

uint64_t CLMiLoServiceManager::onSendRecordingMetaInfoToClient(uint64_t a1, const uuid *a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v8;
  _BYTE v10[17];
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  v8 = CLMiLoServiceManager::BiDirectionalUuidMap::lookupByKey((CLMiLoServiceManager::BiDirectionalUuidMap *)(a1 + 64), a2, v10);
  if (!v10[16])
    CLMiLoServiceManager::onSendRecordingMetaInfoToClient(v8);
  return (*(uint64_t (**)(_QWORD, const uuid *, uint64_t, uint64_t, _BYTE *))(**(_QWORD **)(a1 + 128) + 32))(*(_QWORD *)(a1 + 128), a2, a3, a4, v10);
}

uint64_t CLMiLoServiceManager::onSendPredictionMetaInfoToClient(CLMiLoServiceManager *this, const uuid *a2, const uuid *a3, const CLMicroLocationResultToPublish *a4)
{
  _QWORD *v8;
  _BYTE v10[17];
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  v8 = CLMiLoServiceManager::BiDirectionalUuidMap::lookupByKey((CLMiLoServiceManager *)((char *)this + 64), a2, v10);
  if (!v10[16])
    CLMiLoServiceManager::onSendPredictionMetaInfoToClient(v8);
  return (*(uint64_t (**)(_QWORD, const uuid *, const uuid *, const CLMicroLocationResultToPublish *, _BYTE *))(**((_QWORD **)this + 16) + 40))(*((_QWORD *)this + 16), a2, a3, a4, v10);
}

uint64_t CLMiLoServiceManager::onSendGenericEventResponseToClient(uint64_t a1, const uuid *a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v7;
  _BYTE v9[17];
  uint64_t v10;

  v10 = *MEMORY[0x24BDAC8D0];
  v7 = CLMiLoServiceManager::BiDirectionalUuidMap::lookupByKey((CLMiLoServiceManager::BiDirectionalUuidMap *)(a1 + 64), a2, v9);
  if (!v9[16])
    CLMiLoServiceManager::onSendGenericEventResponseToClient(v7);
  return (*(uint64_t (**)(_QWORD, uint64_t, uint64_t, _BYTE *))(**(_QWORD **)(a1 + 128) + 56))(*(_QWORD *)(a1 + 128), a3, a4, v9);
}

uint64_t CLMiLoServiceManager::onRecordingRequest(uint64_t a1, uint64_t a2, uint64_t *a3, __int128 *a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  __int128 v9;
  char v10;
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  v5 = *(_QWORD *)(a1 + 128);
  v6 = *a3;
  v7 = a3[1];
  v10 = *((_BYTE *)a4 + 16);
  v9 = *a4;
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, __int128 *, uint64_t))(*(_QWORD *)(v5 + 8) + 16))(v5 + 8, a2, v6, v7, &v9, a5);
}

uint64_t CLMiLoServiceManager::onSendStatusToClient(CLMiLoServiceManager *this, const uuid *a2)
{
  _QWORD *v4;
  _BYTE v6[17];
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v4 = CLMiLoServiceManager::BiDirectionalUuidMap::lookupByKey((CLMiLoServiceManager *)((char *)this + 64), a2 + 2, v6);
  if (!v6[16])
    CLMiLoServiceManager::onSendStatusToClient(v4);
  return (*(uint64_t (**)(_QWORD, const uuid *, _BYTE *))(**((_QWORD **)this + 16) + 16))(*((_QWORD *)this + 16), a2, v6);
}

void CLMiLoServiceManager::onEnableMiLoAtCurrentLocationResponse(int64x2_t *a1, uint64_t a2)
{
  NSObject *v4;
  _BOOL4 v5;
  uuid *v6;
  NSObject *v7;
  _OWORD *v8;
  void *p_p;
  CLMiLoService *v10;
  char v11;
  void *__p;
  __int128 v13;
  uuid v14;
  uint8_t buf[4];
  int v16;
  __int16 v17;
  const char *v18;
  __int16 v19;
  _DWORD v20[7];

  *(_QWORD *)&v20[5] = *MEMORY[0x24BDAC8D0];
  if (a1[13].i64[1])
  {
    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_330);
    v4 = logObject_MicroLocation_Default;
    if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT))
    {
      v5 = a1[13].i64[1] != 0;
      *(_DWORD *)buf = 68289538;
      v16 = 0;
      v17 = 2082;
      v18 = "";
      v19 = 1026;
      v20[0] = v5;
      LOWORD(v20[1]) = 1026;
      *(_DWORD *)((char *)&v20[1] + 2) = a2 == -1;
      _os_log_impl(&dword_2419D9000, v4, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLMiLoServiceManager releasing create custom LOI at current location requests: \", \"NumRequests\":%{public}hhd, \"Success\":%{public}hhd}", buf, 0x1Eu);
    }
    while (a1[13].i64[1])
    {
      v6 = (uuid *)(*(_QWORD *)(a1[11].i64[1] + (((unint64_t)a1[13].i64[0] >> 5) & 0x7FFFFFFFFFFFFF8))
                  + 16 * a1[13].i64[0]);
      v14 = *v6;
      if (onceToken_MicroLocation_Default != -1)
        dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_330);
      v7 = (id)logObject_MicroLocation_Default;
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        v8 = operator new(0x28uLL);
        __p = v8;
        v13 = xmmword_241BB2320;
        *v8 = 0u;
        v8[1] = 0u;
        *(_QWORD *)((char *)v8 + 29) = 0;
        boost::uuids::to_chars<char *>((uint64_t)&v14, v8);
        p_p = &__p;
        if (v13 < 0)
          p_p = __p;
        *(_DWORD *)buf = 68289282;
        v16 = 0;
        v17 = 2082;
        v18 = "";
        v19 = 2082;
        *(_QWORD *)v20 = p_p;
        _os_log_impl(&dword_2419D9000, v7, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"enableMiLoAtCurrentLocation completed for connectionToken\", \"connectionToken\":%{public, location:escape_only}s}", buf, 0x1Cu);
        if (SHIBYTE(v13) < 0)
          operator delete(__p);
      }

      if (((a2 == -1) & (*(unsigned int (**)(uint64_t))(*(_QWORD *)(a1[8].i64[0] + 8) + 104))(a1[8].i64[0] + 8)) == 1)
      {
        v10 = (CLMiLoService *)CLMiLoServiceManager::loadedServiceByConnectionToken((CLMiLoServiceManager *)a1, *v6);
        if (v11)
          CLMiLoService::sendInitialBlueAtlasPrediction(v10);
      }
      (*(void (**)(uint64_t, uint64_t, uuid *))(*(_QWORD *)a1[8].i64[0] + 64))(a1[8].i64[0], a2, &v14);
      a1[13] = vaddq_s64(a1[13], (int64x2_t)xmmword_241BB4160);
      std::deque<CLMiLoServiceManager::OutstandingEnableCustomLoiRequest>::__maybe_remove_front_spare[abi:ne180100]((uint64_t)a1[11].i64, 1);
    }
  }
}

void sub_241A36084(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  operator delete(v2);

  _Unwind_Resume(a1);
}

BOOL CLMiLoServiceManager::requestMicroLocationLearning(CLMiLoServiceManager *a1, uint64_t a2, uint64_t a3, uint64_t a4, const uuid *a5)
{
  NSObject *v7;
  char *v8;
  char *v9;
  CLMiLoService *v10;
  char v11;
  NSObject *v13;
  _DWORD v14[2];
  __int16 v15;
  const char *v16;
  __int16 v17;
  char *v18;
  __int16 v19;
  char *v20;
  uuid v21;
  uint64_t v22;

  v22 = *MEMORY[0x24BDAC8D0];
  *(_QWORD *)v21.var0 = a3;
  *(_QWORD *)&v21.var0[8] = a4;
  if (onceToken_MicroLocation_Default != -1)
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_330);
  v7 = (id)logObject_MicroLocation_Default;
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    v8 = (char *)operator new(0x28uLL);
    *(_QWORD *)(v8 + 29) = 0;
    *(_OWORD *)v8 = 0u;
    *((_OWORD *)v8 + 1) = 0u;
    boost::uuids::to_chars<char *>((uint64_t)&v21, v8);
    v9 = (char *)operator new(0x28uLL);
    *(_QWORD *)(v9 + 29) = 0;
    *(_OWORD *)v9 = 0u;
    *((_OWORD *)v9 + 1) = 0u;
    boost::uuids::to_chars<char *>((uint64_t)a5, v9);
    v14[0] = 68289538;
    v14[1] = 0;
    v15 = 2082;
    v16 = "";
    v17 = 2082;
    v18 = v8;
    v19 = 2082;
    v20 = v9;
    _os_log_impl(&dword_2419D9000, v7, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLMiLoServiceManager::requestMicroLocationLearning\", \"connectionToken\":%{public, location:escape_only}s, \"requestId\":%{public, location:escape_only}s}", (uint8_t *)v14, 0x26u);
    operator delete(v9);
    operator delete(v8);
  }

  v10 = (CLMiLoService *)CLMiLoServiceManager::loadedServiceByConnectionToken(a1, v21);
  if (v11)
    return CLMiLoService::requestMicroLocationLearning(v10, a5);
  if (onceToken_MicroLocation_Default != -1)
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_330);
  v13 = logObject_MicroLocation_Default;
  if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v14[0]) = 0;
    _os_log_impl(&dword_2419D9000, v13, OS_LOG_TYPE_DEFAULT, "#requestMicroLocationLearning, can't load service for connectionToken, possibly not connected to a service", (uint8_t *)v14, 2u);
  }
  CLMiLoService::ServiceDescriptor::ServiceDescriptor((uint64_t)v14);
  (*(void (**)(_QWORD *, _DWORD *, const uuid *, uint64_t, uuid *))(**((_QWORD **)a1 + 16) + 24))(*((_QWORD **)a1 + 16), v14, a5, 10, &v21);
  return 0;
}

void sub_241A362C0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  operator delete(v3);
  operator delete(v2);

  _Unwind_Resume(a1);
}

void CLMiLoServiceManager::onLearningBegin(CLMiLoServiceManager *this)
{
  int64x2_t *v2;
  int64x2_t *v3;
  char *v4;

  CLMiLoServiceManager::releaseAllModels(this);
  v2 = (int64x2_t *)((char *)this + 40);
  v3 = (int64x2_t *)*((_QWORD *)this + 6);
  if (v3 != (int64x2_t *)((char *)this + 40))
  {
    v4 = (char *)this + 96;
    do
    {
      CLMiLoService::onLearningBegin(v3 + 1, (uint64_t)v4);
      v3 = (int64x2_t *)v3->i64[1];
    }
    while (v3 != v2);
  }
}

void CLMiLoServiceManager::onLearningCompleted(CLMiLoServiceManager *this)
{
  _QWORD *i;

  CLMiLoServiceManager::updateAllModels(this);
  for (i = (_QWORD *)*((_QWORD *)this + 6); i != (_QWORD *)((char *)this + 40); i = (_QWORD *)i[1])
  {
    CLMiLoServiceManager::updateServiceLastActiveTime(this, (const CLMiLoService *)(i + 2));
    CLMiLoService::onLearningCompleted((_BYTE *)i + 16);
  }
}

void CLMiLoServiceManager::logState(CLMiLoServiceManager *this)
{
  char *v1;
  char *v2;
  char *v3;
  uint64_t v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  void *__p;
  void *v10;
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  v1 = (char *)this + 40;
  v2 = (char *)*((_QWORD *)this + 6);
  if (v2 != (char *)this + 40)
  {
    v3 = (char *)this + 96;
    do
    {
      CLMiLoService::getCurrentStatus((uint64_t)(v2 + 16), (uint64_t)v3, &v4);
      if (__p)
      {
        v10 = __p;
        operator delete(__p);
      }
      if (v7)
      {
        v8 = v7;
        operator delete(v7);
      }
      if (v5)
      {
        v6 = v5;
        operator delete(v5);
      }
      v2 = (char *)*((_QWORD *)v2 + 1);
    }
    while (v2 != v1);
  }
}

void CLMiLoServiceManager::onLocalizationStart(CLMiLoServiceManager *this, uuid a2)
{
  char *v2;
  char *v3;
  uint64_t v4;
  uint64_t v5;
  uuid v6;

  v2 = (char *)this + 40;
  v3 = (char *)*((_QWORD *)this + 6);
  if (v3 != (char *)this + 40)
  {
    v4 = *(_QWORD *)&a2.var0[8];
    v5 = *(_QWORD *)a2.var0;
    do
    {
      *(_QWORD *)v6.var0 = v5;
      *(_QWORD *)&v6.var0[8] = v4;
      CLMiLoService::onLocalizationStart((CLMiLoService *)(v3 + 16), v6);
      v3 = (char *)*((_QWORD *)v3 + 1);
    }
    while (v3 != v2);
  }
}

uint64_t CLMiLoServiceManager::setMiLoEnabled(CLMiLoServiceManager *this, char a2, uint64_t a3)
{
  char *v4;
  char *v5;

  *((_BYTE *)this + 8) = a2;
  *(_DWORD *)((char *)this + 9) = *(_DWORD *)a3;
  *(_WORD *)((char *)this + 13) = *(_WORD *)(a3 + 4);
  v4 = (char *)this + 40;
  v5 = (char *)*((_QWORD *)this + 6);
  if (v5 != (char *)this + 40)
  {
    do
    {
      CLMiLoService::didStateAffectingParametersUpdate((CLMiLoService *)(v5 + 16));
      CLMiLoService::sendStatus((_QWORD *)v5 + 2, (uint64_t)this + 96);
      v5 = (char *)*((_QWORD *)v5 + 1);
    }
    while (v5 != v4);
  }
  return CLMiLoServiceManager::checkSpectating(this);
}

uint64_t CLMiLoServiceManager::triggerLearning(CLMiLoServiceManager *this)
{
  NSObject *v2;
  _DWORD v4[2];
  __int16 v5;
  const char *v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  if (onceToken_MicroLocation_Default != -1)
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_330);
  v2 = logObject_MicroLocation_Default;
  if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT))
  {
    v4[0] = 68289026;
    v4[1] = 0;
    v5 = 2082;
    v6 = "";
    _os_log_impl(&dword_2419D9000, v2, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLMiLoServiceManager::triggerLearning\"}", (uint8_t *)v4, 0x12u);
  }
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)(*((_QWORD *)this + 16) + 8) + 40))(*((_QWORD *)this + 16) + 8);
}

void CLMiLoServiceManager::onRequireFingerprintsForTriggerUuids(uint64_t a1@<X0>, _QWORD *a2@<X1>, uint64_t a3@<X8>)
{
  CLMicroLocationClientUtils::requireFingerprintsForTriggerUuids(*(_QWORD *)(a1 + 88), a2, a3);
}

uint64_t CLMiLoServiceManager::startLowLatencyUpdates(CLMiLoServiceManager *this, const uuid *a2)
{
  return (*(uint64_t (**)(uint64_t, const uuid *))(*(_QWORD *)(*((_QWORD *)this + 16) + 8) + 80))(*((_QWORD *)this + 16) + 8, a2);
}

uint64_t CLMiLoServiceManager::stopLowLatencyUpdates(CLMiLoServiceManager *this, const uuid *a2)
{
  return (*(uint64_t (**)(uint64_t, const uuid *))(*(_QWORD *)(*((_QWORD *)this + 16) + 8) + 88))(*((_QWORD *)this + 16) + 8, a2);
}

void CLMiLoServiceManager::onRequireServiceLabelEntries(uint64_t a1@<X0>, uint64_t a2@<X1>, _QWORD *a3@<X8>, double a4@<D0>)
{
  CLMicroLocationClientUtils::requireServiceLabelEntries(*(_QWORD *)(a1 + 88), a2, a1 + 96, a3, a4);
}

void CLMiLoServiceManager::onRequireAnchorValueStatistics(CLMiLoServiceManager *this@<X0>, const uuid *a2@<X1>, uint64_t a3@<X8>)
{
  id v5;
  id v6;

  v5 = *(id *)(*((_QWORD *)this + 11) + 32);
  v6 = v5;
  if (v5)
  {
    objc_msgSend(v5, "fetchMostRecentClusterAnchorValueStatisticsForModelUUID:", a2);
  }
  else
  {
    *(_QWORD *)(a3 + 112) = 0;
    *(_OWORD *)(a3 + 80) = 0u;
    *(_OWORD *)(a3 + 96) = 0u;
    *(_OWORD *)(a3 + 48) = 0u;
    *(_OWORD *)(a3 + 64) = 0u;
    *(_OWORD *)(a3 + 16) = 0u;
    *(_OWORD *)(a3 + 32) = 0u;
    *(_OWORD *)a3 = 0u;
  }

}

void sub_241A366B8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void CLMiLoServiceManager::processConnectionRequestsAwaitingDb(CLMiLoServiceManager *this)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t i;
  __int128 v10;
  char v11;
  uint8_t buf[4];
  int v13;
  __int16 v14;
  const char *v15;
  __int16 v16;
  uint64_t v17;
  uint64_t v18;

  v18 = *MEMORY[0x24BDAC8D0];
  if (*((_QWORD *)this + 28) != *((_QWORD *)this + 29))
  {
    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_330);
    v2 = logObject_MicroLocation_Default;
    if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT))
    {
      v3 = 0x4EC4EC4EC4EC4EC5 * ((uint64_t)(*((_QWORD *)this + 29) - *((_QWORD *)this + 28)) >> 3);
      *(_DWORD *)buf = 68289282;
      v13 = 0;
      v14 = 2082;
      v15 = "";
      v16 = 2050;
      v17 = v3;
      _os_log_impl(&dword_2419D9000, v2, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLMiLoServiceManager releasing pending connection requests: \", \"NumRequests\":%{public}lu}", buf, 0x1Cu);
    }
    v4 = *((_QWORD *)this + 28);
    if (*((_QWORD *)this + 29) != v4)
    {
      do
      {
        v5 = *(_QWORD *)(v4 + 24);
        v6 = *(_QWORD *)(v4 + 32);
        v10 = *(_OWORD *)(v4 + 40);
        v11 = *(_BYTE *)(v4 + 56);
        CLMiLoServiceManager::connect((uint64_t)this, v4, v5, v6, (uint64_t)&v10, *(_QWORD *)(v4 + 57), *(_QWORD *)(v4 + 65), v4 + 80);
        std::__move_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<CLMiLoServiceManager::ConnectionRequestParams *,CLMiLoServiceManager::ConnectionRequestParams *,CLMiLoServiceManager::ConnectionRequestParams *>((uint64_t)buf, (__int128 *)(v4 + 104), *((__int128 **)this + 29), v4);
        v8 = v7;
        for (i = *((_QWORD *)this + 29);
              i != v8;
              std::allocator<CLMiLoServiceManager::ConnectionRequestParams>::destroy[abi:ne180100]((uint64_t)this + 240, i))
        {
          i -= 104;
        }
        *((_QWORD *)this + 29) = v8;
      }
      while (v8 != v4);
    }
  }
}

uint64_t std::vector<CLMiLoServiceManager::ConnectionRequestParams>::emplace_back<CLMiLoServiceManager::ConnectionRequestParams>(uint64_t *a1, __int128 *a2)
{
  _QWORD *v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  char *v18;
  char *v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  void *v26[5];

  v6 = a1[2];
  v4 = a1 + 2;
  v5 = v6;
  v7 = *(v4 - 1);
  if (v7 >= v6)
  {
    v14 = 0x4EC4EC4EC4EC4EC5 * ((uint64_t)(v7 - *a1) >> 3);
    v15 = v14 + 1;
    if ((unint64_t)(v14 + 1) > 0x276276276276276)
      std::vector<CLMicroLocationProto::ConfidenceReason>::__throw_length_error[abi:ne180100]();
    v16 = 0x4EC4EC4EC4EC4EC5 * ((uint64_t)(v5 - *a1) >> 3);
    if (2 * v16 > v15)
      v15 = 2 * v16;
    if (v16 >= 0x13B13B13B13B13BLL)
      v17 = 0x276276276276276;
    else
      v17 = v15;
    v26[4] = v4;
    if (v17)
      v18 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<CLMiLoServiceManager::ConnectionRequestParams>>((uint64_t)v4, v17);
    else
      v18 = 0;
    v19 = &v18[104 * v14];
    v26[0] = v18;
    v26[1] = v19;
    v26[3] = &v18[104 * v17];
    v20 = *a2;
    *((_QWORD *)v19 + 2) = *((_QWORD *)a2 + 2);
    *(_OWORD *)v19 = v20;
    *((_QWORD *)a2 + 1) = 0;
    *((_QWORD *)a2 + 2) = 0;
    *(_QWORD *)a2 = 0;
    v21 = *(__int128 *)((char *)a2 + 24);
    v22 = *(__int128 *)((char *)a2 + 40);
    v23 = *(__int128 *)((char *)a2 + 56);
    v19[72] = *((_BYTE *)a2 + 72);
    *(_OWORD *)(v19 + 56) = v23;
    *(_OWORD *)(v19 + 40) = v22;
    *(_OWORD *)(v19 + 24) = v21;
    v24 = a2[5];
    *((_QWORD *)v19 + 12) = *((_QWORD *)a2 + 12);
    *((_OWORD *)v19 + 5) = v24;
    *((_QWORD *)a2 + 11) = 0;
    *((_QWORD *)a2 + 12) = 0;
    *((_QWORD *)a2 + 10) = 0;
    v26[2] = v19 + 104;
    std::vector<CLMiLoServiceManager::ConnectionRequestParams>::__swap_out_circular_buffer(a1, v26);
    v13 = a1[1];
    std::__split_buffer<CLMiLoServiceManager::ConnectionRequestParams>::~__split_buffer(v26);
  }
  else
  {
    v8 = *a2;
    *(_QWORD *)(v7 + 16) = *((_QWORD *)a2 + 2);
    *(_OWORD *)v7 = v8;
    *((_QWORD *)a2 + 1) = 0;
    *((_QWORD *)a2 + 2) = 0;
    *(_QWORD *)a2 = 0;
    v9 = *(__int128 *)((char *)a2 + 24);
    v10 = *(__int128 *)((char *)a2 + 40);
    v11 = *(__int128 *)((char *)a2 + 56);
    *(_BYTE *)(v7 + 72) = *((_BYTE *)a2 + 72);
    *(_OWORD *)(v7 + 56) = v11;
    *(_OWORD *)(v7 + 40) = v10;
    *(_OWORD *)(v7 + 24) = v9;
    v12 = a2[5];
    *(_QWORD *)(v7 + 96) = *((_QWORD *)a2 + 12);
    *(_OWORD *)(v7 + 80) = v12;
    *((_QWORD *)a2 + 11) = 0;
    *((_QWORD *)a2 + 12) = 0;
    *((_QWORD *)a2 + 10) = 0;
    v13 = v7 + 104;
    a1[1] = v7 + 104;
  }
  a1[1] = v13;
  return v13 - 104;
}

void sub_241A36A28(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__split_buffer<CLMiLoServiceManager::ConnectionRequestParams>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

void CLMiLoServiceManager::ConnectionRequestParams::~ConnectionRequestParams(void **this)
{
  if (*((char *)this + 103) < 0)
    operator delete(this[10]);
  if (*((char *)this + 23) < 0)
    operator delete(*this);
}

void CLMiLoServiceManager::removePendingConnectionRequestsByConnectionToken(CLMiLoServiceManager *this, uuid a2)
{
  char *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  __int128 *v8;
  __int128 *v9;
  __int128 v11;
  char v12;
  __int128 v13;
  __int128 v14;
  void **v15;
  __int128 v16;
  NSObject *v17;
  uint64_t v18;
  uint64_t v19;
  _BYTE v20[10];
  __int16 v21;
  uint64_t v22;
  uint64_t v23;

  v23 = *MEMORY[0x24BDAC8D0];
  v5 = *((_QWORD *)this + 28);
  v4 = *((_QWORD *)this + 29);
  v3 = (char *)this + 224;
  v19 = *(_QWORD *)a2.var0;
  *(_QWORD *)v20 = *(_QWORD *)&a2.var0[8];
  v6 = v4 - v5;
  if (v4 == v5)
  {
LABEL_7:
    v8 = (__int128 *)v4;
  }
  else
  {
    while (*(_QWORD *)(v5 + 57) != v19 || *(_QWORD *)(v5 + 65) != *(_QWORD *)v20)
    {
      v5 += 104;
      if (v5 == v4)
        goto LABEL_7;
    }
    if (v5 == v4 || (v9 = (__int128 *)(v5 + 104), v5 + 104 == v4))
    {
      v8 = (__int128 *)v4;
    }
    else
    {
      do
      {
        if (*(_QWORD *)((char *)v9 + 57) != v19 || *(_QWORD *)((char *)v9 + 65) != *(_QWORD *)v20)
        {
          if (*(char *)(v5 + 23) < 0)
            operator delete(*(void **)v5);
          v11 = *v9;
          *(_QWORD *)(v5 + 16) = *((_QWORD *)v9 + 2);
          *(_OWORD *)v5 = v11;
          *((_BYTE *)v9 + 23) = 0;
          *(_BYTE *)v9 = 0;
          v12 = *((_BYTE *)v9 + 72);
          v13 = *(__int128 *)((char *)v9 + 56);
          v14 = *(__int128 *)((char *)v9 + 40);
          *(_OWORD *)(v5 + 24) = *(__int128 *)((char *)v9 + 24);
          *(_OWORD *)(v5 + 40) = v14;
          *(_OWORD *)(v5 + 56) = v13;
          *(_BYTE *)(v5 + 72) = v12;
          v15 = (void **)(v5 + 80);
          if (*(char *)(v5 + 103) < 0)
            operator delete(*v15);
          v16 = v9[5];
          *(_QWORD *)(v5 + 96) = *((_QWORD *)v9 + 12);
          *(_OWORD *)v15 = v16;
          *((_BYTE *)v9 + 103) = 0;
          *((_BYTE *)v9 + 80) = 0;
          v5 += 104;
        }
        v9 = (__int128 *)((char *)v9 + 104);
      }
      while (v9 != (__int128 *)v4);
      v8 = (__int128 *)*((_QWORD *)this + 29);
    }
    v4 = v5;
  }
  std::vector<CLMiLoServiceManager::ConnectionRequestParams>::erase((uint64_t)v3, v4, v8);
  if (onceToken_MicroLocation_Default != -1)
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_330);
  v17 = logObject_MicroLocation_Default;
  if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT))
  {
    v18 = 0x4EC4EC4EC4EC4EC5 * (v6 >> 3)
        - 0x4EC4EC4EC4EC4EC5 * ((uint64_t)(*((_QWORD *)this + 29) - *((_QWORD *)this + 28)) >> 3);
    v19 = 68289282;
    *(_WORD *)v20 = 2082;
    *(_QWORD *)&v20[2] = "";
    v21 = 2050;
    v22 = v18;
    _os_log_impl(&dword_2419D9000, v17, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLMiLoServiceManager remove pending connection requests: \", \"NumRequests removed\":%{public}lu}", (uint8_t *)&v19, 0x1Cu);
  }
}

uint64_t std::vector<CLMiLoServiceManager::ConnectionRequestParams>::erase(uint64_t a1, uint64_t a2, __int128 *a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  char v9;

  if ((__int128 *)a2 != a3)
  {
    std::__move_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<CLMiLoServiceManager::ConnectionRequestParams *,CLMiLoServiceManager::ConnectionRequestParams *,CLMiLoServiceManager::ConnectionRequestParams *>((uint64_t)&v9, a3, *(__int128 **)(a1 + 8), a2);
    v6 = v5;
    v7 = *(_QWORD *)(a1 + 8);
    if (v7 != v5)
    {
      do
      {
        v7 -= 104;
        std::allocator<CLMiLoServiceManager::ConnectionRequestParams>::destroy[abi:ne180100](a1 + 16, v7);
      }
      while (v7 != v6);
    }
    *(_QWORD *)(a1 + 8) = v6;
  }
  return a2;
}

id ___ZN20CLMiLoServiceManager42migrateLegacyClientIdToClientIdIfNecessaryERNSt3__18optionalIN18CLMiLoServiceTable5EntryEEERKNS0_12basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEE_block_invoke(uint64_t a1, void *a2, void *a3)
{
  id v4;
  id v5;
  id v6;
  id v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t i;
  uint64_t v11;
  void *v12;
  int v13;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  _BYTE v19[128];
  uint64_t v20;

  v20 = *MEMORY[0x24BDAC8D0];
  v4 = a2;
  v5 = a3;
  v6 = objc_alloc_init(MEMORY[0x24BDBCEB8]);
  v17 = 0u;
  v18 = 0u;
  v15 = 0u;
  v16 = 0u;
  v7 = v4;
  v8 = objc_msgSend(v7, "countByEnumeratingWithState:objects:count:", &v15, v19, 16);
  if (v8)
  {
    v9 = *(_QWORD *)v16;
    do
    {
      for (i = 0; i != v8; ++i)
      {
        if (*(_QWORD *)v16 != v9)
          objc_enumerationMutation(v7);
        v11 = *(_QWORD *)(*((_QWORD *)&v15 + 1) + 8 * i);
        objc_msgSend(v7, "objectForKey:", v11, (_QWORD)v15);
        v12 = (void *)objc_claimAutoreleasedReturnValue();
        v13 = objc_msgSend(v12, "isEqualToString:", v5);

        if (v13)
          objc_msgSend(v6, "addObject:", v11);
      }
      v8 = objc_msgSend(v7, "countByEnumeratingWithState:objects:count:", &v15, v19, 16);
    }
    while (v8);
  }

  return v6;
}

void sub_241A36E9C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void ___ZL45_CLLogObjectForCategory_MicroLocation_Defaultv_block_invoke_24()
{
  os_log_t v0;
  void *v1;

  v0 = os_log_create("com.apple.MicroLocation", "MicroLocation");
  v1 = (void *)logObject_MicroLocation_Default;
  logObject_MicroLocation_Default = (uint64_t)v0;

}

uint64_t std::__optional_destruct_base<CLMiLoServiceTable::Entry,false>::~__optional_destruct_base[abi:ne180100](uint64_t a1)
{
  if (*(_BYTE *)(a1 + 88))
  {
    if (*(char *)(a1 + 87) < 0)
      operator delete(*(void **)(a1 + 64));
    if (*(char *)(a1 + 55) < 0)
      operator delete(*(void **)(a1 + 32));
  }
  return a1;
}

_BYTE *std::__optional_copy_base<CLMiLoServiceTable::Entry,false>::__optional_copy_base[abi:ne180100](_BYTE *a1, uint64_t a2)
{
  *a1 = 0;
  a1[88] = 0;
  if (*(_BYTE *)(a2 + 88))
  {
    std::__construct_at[abi:ne180100]<CLMiLoServiceTable::Entry,CLMiLoServiceTable::Entry const&,CLMiLoServiceTable::Entry*>((uint64_t)a1, a2);
    a1[88] = 1;
  }
  return a1;
}

void sub_241A37020(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::__optional_destruct_base<CLMiLoServiceTable::Entry,false>::~__optional_destruct_base[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

uint64_t std::__construct_at[abi:ne180100]<CLMiLoServiceTable::Entry,CLMiLoServiceTable::Entry const&,CLMiLoServiceTable::Entry*>(uint64_t a1, uint64_t a2)
{
  __int128 v4;
  __int128 v5;
  std::string *v6;
  __int128 v7;

  v4 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(_OWORD *)(a1 + 16) = v4;
  if (*(char *)(a2 + 55) < 0)
  {
    std::string::__init_copy_ctor_external((std::string *)(a1 + 32), *(const std::string::value_type **)(a2 + 32), *(_QWORD *)(a2 + 40));
  }
  else
  {
    v5 = *(_OWORD *)(a2 + 32);
    *(_QWORD *)(a1 + 48) = *(_QWORD *)(a2 + 48);
    *(_OWORD *)(a1 + 32) = v5;
  }
  *(_QWORD *)(a1 + 56) = *(_QWORD *)(a2 + 56);
  v6 = (std::string *)(a1 + 64);
  if (*(char *)(a2 + 87) < 0)
  {
    std::string::__init_copy_ctor_external(v6, *(const std::string::value_type **)(a2 + 64), *(_QWORD *)(a2 + 72));
  }
  else
  {
    v7 = *(_OWORD *)(a2 + 64);
    *(_QWORD *)(a1 + 80) = *(_QWORD *)(a2 + 80);
    *(_OWORD *)&v6->__r_.__value_.__l.__data_ = v7;
  }
  return a1;
}

void sub_241A370CC(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void **v2;

  if (*(char *)(v1 + 55) < 0)
    operator delete(*v2);
  _Unwind_Resume(exception_object);
}

void std::__optional_storage_base<CLMicroLocationModelTable::Entry,false>::__assign_from[abi:ne180100]<std::__optional_move_assign_base<CLMicroLocationModelTable::Entry,false>>(uint64_t a1, uint64_t a2)
{
  if (*(unsigned __int8 *)(a1 + 312) == *(unsigned __int8 *)(a2 + 312))
  {
    if (*(_BYTE *)(a1 + 312))
      CLMicroLocationModelTable::Entry::operator=(a1, a2);
  }
  else if (*(_BYTE *)(a1 + 312))
  {
    std::__optional_destruct_base<CLMicroLocationModelTable::Entry,false>::reset[abi:ne180100](a1);
  }
  else
  {
    *(_BYTE *)(CLMicroLocationModelTable::Entry::Entry() + 312) = 1;
  }
}

void std::__optional_destruct_base<CLMicroLocationModelTable::Entry,false>::reset[abi:ne180100](uint64_t a1)
{
  if (*(_BYTE *)(a1 + 312))
  {
    if (*(_BYTE *)(a1 + 264))
    {
      if (*(char *)(a1 + 263) < 0)
        operator delete(*(void **)(a1 + 240));
    }
    CLMicroLocationProto::Model::~Model((CLMicroLocationProto::Model *)(a1 + 32));
    *(_BYTE *)(a1 + 312) = 0;
  }
}

std::string *std::optional<std::string>::operator=[abi:ne180100]<std::string const,void>(std::string *this, const std::string *a2)
{
  __int128 v3;

  if (this[1].__r_.__value_.__s.__data_[0])
  {
    std::string::operator=(this, a2);
  }
  else
  {
    if (SHIBYTE(a2->__r_.__value_.__r.__words[2]) < 0)
    {
      std::string::__init_copy_ctor_external(this, a2->__r_.__value_.__l.__data_, a2->__r_.__value_.__l.__size_);
    }
    else
    {
      v3 = *(_OWORD *)&a2->__r_.__value_.__l.__data_;
      this->__r_.__value_.__r.__words[2] = a2->__r_.__value_.__r.__words[2];
      *(_OWORD *)&this->__r_.__value_.__l.__data_ = v3;
    }
    this[1].__r_.__value_.__s.__data_[0] = 1;
  }
  return this;
}

uint64_t CLMiLoService::ModelAndConf::ModelAndConf(uint64_t a1, const CLMicroLocationModel *a2, uint64_t a3, uint64_t a4, __int128 *a5, uint64_t a6, uint64_t a7, double a8, uint64_t a9, uint64_t a10, uint64_t a11, __int128 *a12)
{
  uint64_t v20;
  __int128 v21;
  std::string *v22;
  __int128 v23;

  CLMicroLocationModel::CLMicroLocationModel((CLMicroLocationModel *)a1, a2);
  *(_QWORD *)(v20 + 448) = a3;
  *(_QWORD *)(v20 + 456) = a4;
  if (*((char *)a5 + 23) < 0)
  {
    std::string::__init_copy_ctor_external((std::string *)(v20 + 464), *(const std::string::value_type **)a5, *((_QWORD *)a5 + 1));
  }
  else
  {
    v21 = *a5;
    *(_QWORD *)(v20 + 480) = *((_QWORD *)a5 + 2);
    *(_OWORD *)(v20 + 464) = v21;
  }
  *(_BYTE *)(a1 + 488) = 1;
  *(_QWORD *)(a1 + 496) = a6;
  *(_QWORD *)(a1 + 504) = a7;
  *(_QWORD *)(a1 + 512) = a10;
  *(_QWORD *)(a1 + 520) = a11;
  CLMicroLocationLocalizationSettings::CLMicroLocationLocalizationSettings(a1 + 528, a12, *(_DWORD *)a2);
  v22 = (std::string *)(a1 + 568);
  if (*((char *)a12 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v22, *(const std::string::value_type **)a12, *((_QWORD *)a12 + 1));
  }
  else
  {
    v23 = *a12;
    *(_QWORD *)(a1 + 584) = *((_QWORD *)a12 + 2);
    *(_OWORD *)&v22->__r_.__value_.__l.__data_ = v23;
  }
  *(double *)(a1 + 592) = a8;
  *(_BYTE *)(a1 + 600) = 0;
  *(_BYTE *)(a1 + 640) = 0;
  return a1;
}

void sub_241A372D0(_Unwind_Exception *a1)
{
  uint64_t v1;
  void **v2;
  id *v3;

  CLMicroLocationLocalizationSettings::~CLMicroLocationLocalizationSettings(v3);
  if (*(_BYTE *)(v1 + 488))
  {
    if (*(char *)(v1 + 487) < 0)
      operator delete(*v2);
  }
  CLMicroLocationModel::~CLMicroLocationModel((void **)v1);
  _Unwind_Resume(a1);
}

void CLMicroLocationModel::CLMicroLocationModel(CLMicroLocationModel *this, const CLMicroLocationModel *a2)
{
  __int128 v4;
  std::string *v5;
  __int128 v6;

  *(_OWORD *)this = *(_OWORD *)a2;
  std::unordered_map<boost::uuids::uuid,CLMicroLocationAnchorAppearance>::unordered_map((uint64_t)this + 16, (uint64_t)a2 + 16);
  *(_OWORD *)((char *)this + 56) = *(_OWORD *)((char *)a2 + 56);
  std::__optional_copy_base<CLMicroLocationModel::SimilarityListData,false>::__optional_copy_base[abi:ne180100]((CLMicroLocationModel *)((char *)this + 72), (const CLMicroLocationModel *)((char *)a2 + 72));
  std::__optional_copy_base<CLMicroLocationModel::BlueAtlasData,false>::__optional_copy_base[abi:ne180100]((_BYTE *)this + 200, (uint64_t)a2 + 200);
  v4 = *(_OWORD *)((char *)a2 + 296);
  *(_OWORD *)((char *)this + 308) = *(_OWORD *)((char *)a2 + 308);
  *(_OWORD *)((char *)this + 296) = v4;
  *((_QWORD *)this + 42) = 0;
  *((_QWORD *)this + 43) = 0;
  *((_QWORD *)this + 41) = 0;
  std::vector<std::pair<std::shared_ptr<CLMicroLocationFingerprint>,boost::uuids::uuid>>::__init_with_size[abi:ne180100]<std::pair<std::shared_ptr<CLMicroLocationFingerprint>,boost::uuids::uuid>*,std::pair<std::shared_ptr<CLMicroLocationFingerprint>,boost::uuids::uuid>*>((char *)this + 328, *((_QWORD *)a2 + 41), *((_QWORD *)a2 + 42), (uint64_t)(*((_QWORD *)a2 + 42) - *((_QWORD *)a2 + 41)) >> 5);
  std::unordered_map<boost::uuids::uuid,std::vector<boost::uuids::uuid>>::unordered_map((uint64_t)this + 352, (uint64_t)a2 + 352);
  *((_QWORD *)this + 49) = *((_QWORD *)a2 + 49);
  *((_QWORD *)this + 50) = 0;
  *((_QWORD *)this + 51) = 0;
  *((_QWORD *)this + 52) = 0;
  std::vector<CLMicroLocationProto::ServiceQualityReasonEnum>::__init_with_size[abi:ne180100]<CLMicroLocationProto::ServiceQualityReasonEnum*,CLMicroLocationProto::ServiceQualityReasonEnum*>((_QWORD *)this + 50, *((const void **)a2 + 50), *((_QWORD *)a2 + 51), (uint64_t)(*((_QWORD *)a2 + 51) - *((_QWORD *)a2 + 50)) >> 2);
  v5 = (std::string *)((char *)this + 424);
  if (*((char *)a2 + 447) < 0)
  {
    std::string::__init_copy_ctor_external(v5, *((const std::string::value_type **)a2 + 53), *((_QWORD *)a2 + 54));
  }
  else
  {
    v6 = *(_OWORD *)((char *)a2 + 424);
    *((_QWORD *)this + 55) = *((_QWORD *)a2 + 55);
    *(_OWORD *)&v5->__r_.__value_.__l.__data_ = v6;
  }
}

void sub_241A3742C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  void **v7;
  void *v9;
  va_list va;

  va_start(va, a2);
  v9 = *v7;
  if (*v7)
  {
    *(_QWORD *)(v5 + 408) = v9;
    operator delete(v9);
  }
  std::__hash_table<std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>>>::~__hash_table(v6);
  std::vector<std::pair<std::shared_ptr<CLMicroLocationFingerprint>,boost::uuids::uuid>>::__destroy_vector::operator()[abi:ne180100]((void ***)va);
  std::__optional_destruct_base<CLMicroLocationModel::BlueAtlasData,false>::~__optional_destruct_base[abi:ne180100](v4);
  std::__optional_destruct_base<CLMicroLocationModel::SimilarityListData,false>::~__optional_destruct_base[abi:ne180100](v3);
  std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>>>::~__hash_table(v2);
  _Unwind_Resume(a1);
}

void sub_241A37494()
{
  JUMPOUT(0x241A37484);
}

CLMicroLocationModel::SimilarityListData *std::__optional_copy_base<CLMicroLocationModel::SimilarityListData,false>::__optional_copy_base[abi:ne180100](CLMicroLocationModel::SimilarityListData *this, const CLMicroLocationModel::SimilarityListData *a2)
{
  *(_BYTE *)this = 0;
  *((_BYTE *)this + 120) = 0;
  if (*((_BYTE *)a2 + 120))
  {
    CLMicroLocationModel::SimilarityListData::SimilarityListData(this, a2);
    *((_BYTE *)this + 120) = 1;
  }
  return this;
}

void sub_241A374DC(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::__optional_destruct_base<CLMicroLocationModel::SimilarityListData,false>::~__optional_destruct_base[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

_BYTE *std::__optional_copy_base<CLMicroLocationModel::BlueAtlasData,false>::__optional_copy_base[abi:ne180100](_BYTE *a1, uint64_t a2)
{
  *a1 = 0;
  a1[88] = 0;
  if (*(_BYTE *)(a2 + 88))
  {
    std::__construct_at[abi:ne180100]<CLMicroLocationModel::BlueAtlasData,CLMicroLocationModel::BlueAtlasData const&,CLMicroLocationModel::BlueAtlasData*>((uint64_t)a1, a2);
    a1[88] = 1;
  }
  return a1;
}

void sub_241A37530(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::__optional_destruct_base<CLMicroLocationModel::BlueAtlasData,false>::~__optional_destruct_base[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

uint64_t std::__construct_at[abi:ne180100]<CLMicroLocationModel::BlueAtlasData,CLMicroLocationModel::BlueAtlasData const&,CLMicroLocationModel::BlueAtlasData*>(uint64_t a1, uint64_t a2)
{
  __int128 v4;
  __int128 v5;

  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  std::vector<boost::uuids::uuid>::__init_with_size[abi:ne180100]<boost::uuids::uuid*,boost::uuids::uuid*>((_QWORD *)a1, *(const void **)a2, *(_QWORD *)(a2 + 8), (uint64_t)(*(_QWORD *)(a2 + 8) - *(_QWORD *)a2) >> 4);
  *(_QWORD *)(a1 + 24) = 0;
  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 40) = 0;
  std::vector<CLMacAddress>::__init_with_size[abi:ne180100]<CLMacAddress*,CLMacAddress*>((_QWORD *)(a1 + 24), *(const void **)(a2 + 24), *(_QWORD *)(a2 + 32), (uint64_t)(*(_QWORD *)(a2 + 32) - *(_QWORD *)(a2 + 24)) >> 3);
  v4 = *(_OWORD *)(a2 + 48);
  v5 = *(_OWORD *)(a2 + 64);
  *(_DWORD *)(a1 + 80) = *(_DWORD *)(a2 + 80);
  *(_OWORD *)(a1 + 48) = v4;
  *(_OWORD *)(a1 + 64) = v5;
  return a1;
}

void sub_241A375B0(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *std::vector<std::pair<std::shared_ptr<CLMicroLocationFingerprint>,boost::uuids::uuid>>::__init_with_size[abi:ne180100]<std::pair<std::shared_ptr<CLMicroLocationFingerprint>,boost::uuids::uuid>*,std::pair<std::shared_ptr<CLMicroLocationFingerprint>,boost::uuids::uuid>*>(char *result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  char *v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t *v9;
  unint64_t v10;

  if (a4)
  {
    v6 = result;
    result = std::vector<CLMiLoOdometryTable::Entry>::__vallocate[abi:ne180100](result, a4);
    v7 = *((_QWORD *)v6 + 1);
    while (a2 != a3)
    {
      *(_QWORD *)v7 = *(_QWORD *)a2;
      v8 = *(_QWORD *)(a2 + 8);
      *(_QWORD *)(v7 + 8) = v8;
      if (v8)
      {
        v9 = (unint64_t *)(v8 + 8);
        do
          v10 = __ldxr(v9);
        while (__stxr(v10 + 1, v9));
      }
      *(_OWORD *)(v7 + 16) = *(_OWORD *)(a2 + 16);
      a2 += 32;
      v7 += 32;
    }
    *((_QWORD *)v6 + 1) = v7;
  }
  return result;
}

void sub_241A37660(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  std::vector<std::pair<std::shared_ptr<CLMicroLocationFingerprint>,boost::uuids::uuid>>::__destroy_vector::operator()[abi:ne180100](&a9);
  _Unwind_Resume(a1);
}

uint64_t std::unordered_map<boost::uuids::uuid,std::vector<boost::uuids::uuid>>::unordered_map(uint64_t a1, uint64_t a2)
{
  _QWORD *i;

  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 32) = *(_DWORD *)(a2 + 32);
  std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>>>::__rehash<true>(a1, *(_QWORD *)(a2 + 8));
  for (i = *(_QWORD **)(a2 + 16); i; i = (_QWORD *)*i)
    std::__hash_table<std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>>>::__emplace_unique_key_args<boost::uuids::uuid,std::pair<boost::uuids::uuid const,std::vector<boost::uuids::uuid>> const&>(a1, i + 2, (uint64_t)(i + 2));
  return a1;
}

void sub_241A376D0(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::__hash_table<std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>>>::~__hash_table(v1);
  _Unwind_Resume(a1);
}

_QWORD *std::__hash_table<std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>>>::__emplace_unique_key_args<boost::uuids::uuid,std::pair<boost::uuids::uuid const,std::vector<boost::uuids::uuid>> const&>(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  unint64_t v3;
  uint64_t v5;
  unint64_t v6;
  unint64_t v7;
  uint8x8_t v8;
  _QWORD *v9;
  _QWORD *result;
  unint64_t v11;
  float v13;
  float v14;
  _BOOL8 v15;
  unint64_t v16;
  unint64_t v17;
  size_t v18;
  _QWORD *v19;
  unint64_t v20;
  _QWORD *v21;

  v5 = 0;
  v6 = 0;
  do
    v6 ^= (v6 << 6) + (v6 >> 2) + 2654435769u + *((unsigned __int8 *)a2 + v5++);
  while (v5 != 16);
  v7 = *(_QWORD *)(a1 + 8);
  if (v7)
  {
    v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      v3 = v6;
      if (v6 >= v7)
        v3 = v6 % v7;
    }
    else
    {
      v3 = (v7 - 1) & v6;
    }
    v9 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v3);
    if (v9)
    {
      result = (_QWORD *)*v9;
      if (*v9)
      {
        do
        {
          v11 = result[1];
          if (v11 == v6)
          {
            if (result[2] == *a2 && result[3] == a2[1])
              return result;
          }
          else
          {
            if (v8.u32[0] > 1uLL)
            {
              if (v11 >= v7)
                v11 %= v7;
            }
            else
            {
              v11 &= v7 - 1;
            }
            if (v11 != v3)
              break;
          }
          result = (_QWORD *)*result;
        }
        while (result);
      }
    }
  }
  std::__hash_table<std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>>>::__construct_node_hash<std::pair<boost::uuids::uuid const,std::vector<boost::uuids::uuid>> const&>(a1, v6, a3, (uint64_t)&v21);
  v13 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v14 = *(float *)(a1 + 32);
  if (!v7 || (float)(v14 * (float)v7) < v13)
  {
    v15 = 1;
    if (v7 >= 3)
      v15 = (v7 & (v7 - 1)) != 0;
    v16 = v15 | (2 * v7);
    v17 = vcvtps_u32_f32(v13 / v14);
    if (v16 <= v17)
      v18 = v17;
    else
      v18 = v16;
    std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>>>::__rehash<true>(a1, v18);
    v7 = *(_QWORD *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v6 >= v7)
        v3 = v6 % v7;
      else
        v3 = v6;
    }
    else
    {
      v3 = (v7 - 1) & v6;
    }
  }
  v19 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v3);
  if (v19)
  {
    *v21 = *v19;
    *v19 = v21;
  }
  else
  {
    *v21 = *(_QWORD *)(a1 + 16);
    *(_QWORD *)(a1 + 16) = v21;
    *(_QWORD *)(*(_QWORD *)a1 + 8 * v3) = a1 + 16;
    if (*v21)
    {
      v20 = *(_QWORD *)(*v21 + 8);
      if ((v7 & (v7 - 1)) != 0)
      {
        if (v20 >= v7)
          v20 %= v7;
      }
      else
      {
        v20 &= v7 - 1;
      }
      *(_QWORD *)(*(_QWORD *)a1 + 8 * v20) = v21;
    }
  }
  result = v21;
  ++*(_QWORD *)(a1 + 24);
  return result;
}

void sub_241A37930(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, _QWORD *__p, uint64_t a11)
{
  if (__p)
    std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,void *>>>::operator()[abi:ne180100]((uint64_t)&a11, __p);
  _Unwind_Resume(exception_object);
}

_QWORD *std::__hash_table<std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>>>::__construct_node_hash<std::pair<boost::uuids::uuid const,std::vector<boost::uuids::uuid>> const&>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v7;
  _QWORD *v8;
  _QWORD *result;

  v7 = a1 + 16;
  v8 = operator new(0x38uLL);
  *(_QWORD *)a4 = v8;
  *(_QWORD *)(a4 + 8) = v7;
  *(_BYTE *)(a4 + 16) = 0;
  *v8 = 0;
  v8[1] = a2;
  *((_OWORD *)v8 + 1) = *(_OWORD *)a3;
  v8[5] = 0;
  v8[6] = 0;
  v8[4] = 0;
  result = std::vector<boost::uuids::uuid>::__init_with_size[abi:ne180100]<boost::uuids::uuid*,boost::uuids::uuid*>(v8 + 4, *(const void **)(a3 + 16), *(_QWORD *)(a3 + 24), (uint64_t)(*(_QWORD *)(a3 + 24) - *(_QWORD *)(a3 + 16)) >> 4);
  *(_BYTE *)(a4 + 16) = 1;
  return result;
}

void sub_241A379D4(_Unwind_Exception *a1)
{
  _QWORD *v1;
  _QWORD *v2;
  uint64_t v3;

  *v1 = 0;
  std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,void *>>>::operator()[abi:ne180100](v3, v2);
  _Unwind_Resume(a1);
}

_QWORD *std::vector<CLMicroLocationProto::ServiceQualityReasonEnum>::__init_with_size[abi:ne180100]<CLMicroLocationProto::ServiceQualityReasonEnum*,CLMicroLocationProto::ServiceQualityReasonEnum*>(_QWORD *result, const void *a2, uint64_t a3, unint64_t a4)
{
  _QWORD *v6;
  uint64_t v7;
  size_t v8;

  if (a4)
  {
    v6 = result;
    result = std::vector<CLMicroLocationProto::ConfidenceLevel>::__vallocate[abi:ne180100](result, a4);
    v7 = v6[1];
    v8 = a3 - (_QWORD)a2;
    if (v8)
      result = memmove((void *)v6[1], a2, v8);
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_241A37A4C(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void CLMiLoService::ModelAndConf::~ModelAndConf(CLMiLoService::ModelAndConf *this)
{
  void *v2;
  void **v3;

  if (*((_BYTE *)this + 640))
    std::__hash_table<std::__hash_value_type<boost::uuids::uuid,std::unordered_map<std::string,AnchorValueStatistics>>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::unordered_map<std::string,AnchorValueStatistics>>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::unordered_map<std::string,AnchorValueStatistics>>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,std::unordered_map<std::string,AnchorValueStatistics>>>>::~__hash_table((uint64_t)this + 600);
  if (*((char *)this + 591) < 0)
    operator delete(*((void **)this + 71));

  std::__tree<std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>,std::__map_value_compare<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>,std::less<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes>,true>,std::allocator<std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>>>::destroy((uint64_t)this + 528, *((_QWORD **)this + 67));
  if (*((_BYTE *)this + 488) && *((char *)this + 487) < 0)
    operator delete(*((void **)this + 58));
  if (*((char *)this + 447) < 0)
    operator delete(*((void **)this + 53));
  v2 = (void *)*((_QWORD *)this + 50);
  if (v2)
  {
    *((_QWORD *)this + 51) = v2;
    operator delete(v2);
  }
  std::__hash_table<std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>>>::~__hash_table((uint64_t)this + 352);
  v3 = (void **)((char *)this + 328);
  std::vector<std::pair<std::shared_ptr<CLMicroLocationFingerprint>,boost::uuids::uuid>>::__destroy_vector::operator()[abi:ne180100](&v3);
  std::__optional_destruct_base<CLMicroLocationModel::BlueAtlasData,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)this + 200);
  std::__optional_destruct_base<CLMicroLocationModel::SimilarityListData,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)this + 72);
  std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>>>::~__hash_table((uint64_t)this + 16);
}

uint64_t std::__hash_table<std::__hash_value_type<boost::uuids::uuid,std::unordered_map<std::string,AnchorValueStatistics>>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::unordered_map<std::string,AnchorValueStatistics>>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::unordered_map<std::string,AnchorValueStatistics>>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,std::unordered_map<std::string,AnchorValueStatistics>>>>::~__hash_table(uint64_t a1)
{
  void *v2;

  std::__hash_table<std::__hash_value_type<boost::uuids::uuid,std::unordered_map<std::string,AnchorValueStatistics>>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::unordered_map<std::string,AnchorValueStatistics>>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::unordered_map<std::string,AnchorValueStatistics>>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,std::unordered_map<std::string,AnchorValueStatistics>>>>::__deallocate_node(a1, *(_QWORD **)(a1 + 16));
  v2 = *(void **)a1;
  *(_QWORD *)a1 = 0;
  if (v2)
    operator delete(v2);
  return a1;
}

void std::__hash_table<std::__hash_value_type<boost::uuids::uuid,std::unordered_map<std::string,AnchorValueStatistics>>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::unordered_map<std::string,AnchorValueStatistics>>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::unordered_map<std::string,AnchorValueStatistics>>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,std::unordered_map<std::string,AnchorValueStatistics>>>>::__deallocate_node(uint64_t a1, _QWORD *a2)
{
  _QWORD *v2;
  _QWORD *v3;

  if (a2)
  {
    v2 = a2;
    do
    {
      v3 = (_QWORD *)*v2;
      std::__hash_table<std::__hash_value_type<std::string,AnchorValueStatistics>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,AnchorValueStatistics>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,AnchorValueStatistics>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,AnchorValueStatistics>>>::~__hash_table((uint64_t)(v2 + 4));
      operator delete(v2);
      v2 = v3;
    }
    while (v3);
  }
}

__n128 std::__optional_storage_base<CLMiLoServiceTable::Entry,false>::__assign_from[abi:ne180100]<std::__optional_move_assign_base<CLMiLoServiceTable::Entry,false>>(uint64_t a1, uint64_t a2)
{
  __int128 v4;
  void **v5;
  __int128 *v6;
  __int128 v7;
  void **v8;
  __n128 result;
  __int128 v10;
  __int128 v11;

  if (*(unsigned __int8 *)(a1 + 88) == *(unsigned __int8 *)(a2 + 88))
  {
    if (*(_BYTE *)(a1 + 88))
    {
      v4 = *(_OWORD *)(a2 + 16);
      *(_OWORD *)a1 = *(_OWORD *)a2;
      *(_OWORD *)(a1 + 16) = v4;
      v5 = (void **)(a1 + 32);
      v6 = (__int128 *)(a2 + 32);
      if (*(char *)(a1 + 55) < 0)
        operator delete(*v5);
      v7 = *v6;
      *(_QWORD *)(a1 + 48) = *(_QWORD *)(a2 + 48);
      *(_OWORD *)v5 = v7;
      *(_BYTE *)(a2 + 55) = 0;
      *(_BYTE *)(a2 + 32) = 0;
      *(_QWORD *)(a1 + 56) = *(_QWORD *)(a2 + 56);
      v8 = (void **)(a1 + 64);
      if (*(char *)(a1 + 87) < 0)
        operator delete(*v8);
      result = *(__n128 *)(a2 + 64);
      *(_QWORD *)(a1 + 80) = *(_QWORD *)(a2 + 80);
      *(__n128 *)v8 = result;
      *(_BYTE *)(a2 + 87) = 0;
      *(_BYTE *)(a2 + 64) = 0;
    }
  }
  else if (*(_BYTE *)(a1 + 88))
  {
    std::__optional_destruct_base<CLMiLoServiceTable::Entry,false>::reset[abi:ne180100](a1);
  }
  else
  {
    v10 = *(_OWORD *)(a2 + 16);
    *(_OWORD *)a1 = *(_OWORD *)a2;
    *(_OWORD *)(a1 + 16) = v10;
    v11 = *(_OWORD *)(a2 + 32);
    *(_QWORD *)(a1 + 48) = *(_QWORD *)(a2 + 48);
    *(_OWORD *)(a1 + 32) = v11;
    *(_QWORD *)(a2 + 40) = 0;
    *(_QWORD *)(a2 + 48) = 0;
    *(_QWORD *)(a2 + 32) = 0;
    *(_QWORD *)(a1 + 56) = *(_QWORD *)(a2 + 56);
    result = *(__n128 *)(a2 + 64);
    *(_QWORD *)(a1 + 80) = *(_QWORD *)(a2 + 80);
    *(__n128 *)(a1 + 64) = result;
    *(_QWORD *)(a2 + 72) = 0;
    *(_QWORD *)(a2 + 80) = 0;
    *(_QWORD *)(a2 + 64) = 0;
    *(_BYTE *)(a1 + 88) = 1;
  }
  return result;
}

void std::__optional_destruct_base<CLMiLoServiceTable::Entry,false>::reset[abi:ne180100](uint64_t a1)
{
  if (*(_BYTE *)(a1 + 88))
  {
    if (*(char *)(a1 + 87) < 0)
      operator delete(*(void **)(a1 + 64));
    if (*(char *)(a1 + 55) < 0)
      operator delete(*(void **)(a1 + 32));
    *(_BYTE *)(a1 + 88) = 0;
  }
}

uint64_t boost::uuids::string_generator::operator()<char const*>(boost::uuids::string_generator *this, unsigned __int8 *a2, unsigned __int8 *a3)
{
  signed __int8 *v5;
  int v6;
  signed __int8 v7;
  int v8;
  uint64_t v9;
  signed __int8 v10;
  BOOL v11;
  signed __int8 v12;
  char value;
  int v14;
  int v15;
  _QWORD v17[3];

  v17[2] = *MEMORY[0x24BDAC8D0];
  if (a2 == a3)
    goto LABEL_32;
  v5 = (signed __int8 *)(a2 + 1);
  v6 = *a2;
  if (v6 == 123)
  {
    if (v5 == (signed __int8 *)a3)
      goto LABEL_32;
    v5 = (signed __int8 *)(a2 + 2);
    v7 = a2[1];
  }
  else
  {
    v7 = *a2;
  }
  v8 = 0;
  v9 = 0;
  while (1)
  {
    do
    {
      if ((_DWORD)v9 == 4)
      {
        if (v7 == 45)
        {
          if (v5 == (signed __int8 *)a3)
            goto LABEL_32;
          v8 = 1;
LABEL_22:
          v12 = *v5++;
          v7 = v12;
          goto LABEL_24;
        }
        v8 = 0;
      }
      else
      {
        v11 = (v9 & 0x7FFFFFFD) == 8 || (_DWORD)v9 == 6;
        if (v11 && ((v8 ^ 1) & 1) == 0)
        {
          if (v7 != 45 || v5 == (signed __int8 *)a3)
            goto LABEL_32;
          goto LABEL_22;
        }
      }
LABEL_24:
      value = boost::uuids::string_generator::get_value(this, v7);
      *((_BYTE *)v17 + v9) = value;
      if (v5 == (signed __int8 *)a3)
        goto LABEL_32;
      v14 = *v5++;
      v7 = v14;
      *((_BYTE *)v17 + v9++) = boost::uuids::string_generator::get_value(this, v14) | (16 * value);
    }
    while (!v9);
    if (v9 == 16)
      break;
    if (v5 == (signed __int8 *)a3)
      goto LABEL_32;
    v10 = *v5++;
    v7 = v10;
  }
  if (v6 == 123 && (v5 == (signed __int8 *)a3 || (v15 = *v5, ++v5, v15 != 125))
    || v5 != (signed __int8 *)a3)
  {
LABEL_32:
    boost::uuids::string_generator::throw_invalid(this);
  }
  return v17[0];
}

void boost::uuids::string_generator::throw_invalid(boost::uuids::string_generator *this)
{
  int8x16_t v1;
  uint64_t v2;
  std::runtime_error v3;

  MEMORY[0x2426A0258](&v3, "invalid uuid string");
  v1.i64[0] = (uint64_t)"/AppleInternal/Library/BuildRoots/ae269ea5-5122-11ef-a621-12147c76fa9d/Applications/Xcode.app/Con"
                       "tents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS18.0.Internal.sdk/usr/local/in"
                       "clude/boost/uuid/string_generator.hpp";
  v1.i64[1] = (uint64_t)"void boost::uuids::string_generator::throw_invalid() const";
  v2 = 192;
  boost::throw_exception<std::runtime_error>(&v3, &v1);
}

void sub_241A37EE4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, std::runtime_error a13)
{
  std::runtime_error::~runtime_error(&a13);
  _Unwind_Resume(a1);
}

uint64_t boost::uuids::string_generator::get_value(boost::uuids::string_generator *this, int a2)
{
  unsigned __int8 v3;
  __objc2_class *v4;
  __objc2_class *superclass;
  __objc2_class *v6;
  __objc2_class *v7;
  unint64_t v8;
  int v10;
  int v11;

  v4 = ULRapportMonitor;
  if ((v3 & 1) == 0)
  {
    v11 = a2;
    v4 = ULRapportMonitor;
    a2 = v11;
    if (v10)
    {
      boost::uuids::string_generator::get_value(char)const::digits_end = (uint64_t)&boost::uuids::string_generator::get_value(char)const::digits_begin[(_QWORD)boost::uuids::string_generator::get_value(char)const::digits_len];
      v4 = ULRapportMonitor;
      a2 = v11;
    }
  }
  superclass = v4[96].superclass;
  v6 = (__objc2_class *)memchr("0123456789abcdefABCDEF", a2, (char *)superclass - "0123456789abcdefABCDEF");
  if (v6)
    v7 = v6;
  else
    v7 = superclass;
  v8 = (char *)v7 - "0123456789abcdefABCDEF";
  if (v8 >= (unint64_t)boost::uuids::string_generator::get_value(char)const::digits_len)
    boost::uuids::string_generator::throw_invalid(this);
  return boost::uuids::string_generator::get_value(char)const::values[v8];
}

void boost::throw_exception<std::runtime_error>(const std::runtime_error *a1, int8x16_t *a2)
{
  void *exception;

  exception = __cxa_allocate_exception(0x40uLL);
  boost::wrapexcept<std::runtime_error>::wrapexcept((uint64_t)exception, a1, a2);
}

void sub_241A38008(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t boost::wrapexcept<std::runtime_error>::wrapexcept(uint64_t a1, const std::runtime_error *a2, int8x16_t *a3)
{
  *(_QWORD *)a1 = &unk_2511D29D0;
  std::runtime_error::runtime_error((std::runtime_error *)(a1 + 8), a2);
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 48) = 0;
  *(_QWORD *)a1 = &unk_2511D4328;
  *(_QWORD *)(a1 + 8) = &unk_2511D4358;
  *(_QWORD *)(a1 + 24) = &unk_2511D4380;
  *(_QWORD *)(a1 + 32) = 0;
  *(_DWORD *)(a1 + 56) = a3[1].i32[0];
  *(int8x16_t *)(a1 + 40) = vextq_s8(*a3, *a3, 8uLL);
  return a1;
}

uint64_t boost::wrapexcept<std::runtime_error>::~wrapexcept(uint64_t a1)
{
  *(_QWORD *)(a1 + 24) = &unk_2511D2A30;
  boost::exception_detail::refcount_ptr<boost::exception_detail::error_info_container>::~refcount_ptr((uint64_t *)(a1 + 32));
  std::runtime_error::~runtime_error((std::runtime_error *)(a1 + 8));
  return a1;
}

uint64_t boost::wrapexcept<std::runtime_error>::clone(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;

  v2 = operator new();
  *(_QWORD *)v2 = &unk_2511D29D0;
  std::runtime_error::runtime_error((std::runtime_error *)(v2 + 8), (const std::runtime_error *)(a1 + 8));
  *(_QWORD *)(v2 + 24) = &unk_2511D2A30;
  v3 = *(_QWORD *)(a1 + 32);
  *(_QWORD *)(v2 + 32) = v3;
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 24))(v3);
  *(_OWORD *)(v2 + 40) = *(_OWORD *)(a1 + 40);
  *(_DWORD *)(v2 + 56) = *(_DWORD *)(a1 + 56);
  *(_QWORD *)v2 = &unk_2511D4328;
  *(_QWORD *)(v2 + 8) = &unk_2511D4358;
  *(_QWORD *)(v2 + 24) = &unk_2511D4380;
  boost::exception_detail::copy_boost_exception(v2 + 24, a1 + 24);
  return v2;
}

void sub_241A38190(_Unwind_Exception *a1)
{
  uint64_t v1;
  std::runtime_error *v2;

  std::runtime_error::~runtime_error(v2);
  MEMORY[0x2426A04D4](v1, 0x10F1C40250A9ABCLL);
  _Unwind_Resume(a1);
}

void boost::wrapexcept<std::runtime_error>::rethrow(uint64_t a1)
{
  void *exception;

  exception = __cxa_allocate_exception(0x40uLL);
  boost::wrapexcept<std::runtime_error>::wrapexcept((uint64_t)exception, a1);
}

void sub_241A38210(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void boost::wrapexcept<std::runtime_error>::~wrapexcept(uint64_t a1)
{
  *(_QWORD *)(a1 + 24) = &unk_2511D2A30;
  boost::exception_detail::refcount_ptr<boost::exception_detail::error_info_container>::~refcount_ptr((uint64_t *)(a1 + 32));
  std::runtime_error::~runtime_error((std::runtime_error *)(a1 + 8));
  JUMPOUT(0x2426A04D4);
}

void `non-virtual thunk to'boost::wrapexcept<std::runtime_error>::~wrapexcept(uint64_t a1)
{
  *(_QWORD *)(a1 + 16) = &unk_2511D2A30;
  boost::exception_detail::refcount_ptr<boost::exception_detail::error_info_container>::~refcount_ptr((uint64_t *)(a1 + 24));
  std::runtime_error::~runtime_error((std::runtime_error *)a1);
}

{
  *(_QWORD *)(a1 + 16) = &unk_2511D2A30;
  boost::exception_detail::refcount_ptr<boost::exception_detail::error_info_container>::~refcount_ptr((uint64_t *)(a1 + 24));
  std::runtime_error::~runtime_error((std::runtime_error *)a1);
  JUMPOUT(0x2426A04D4);
}

void `non-virtual thunk to'boost::wrapexcept<std::runtime_error>::~wrapexcept(_QWORD *a1)
{
  *a1 = &unk_2511D2A30;
  boost::exception_detail::refcount_ptr<boost::exception_detail::error_info_container>::~refcount_ptr(a1 + 1);
  std::runtime_error::~runtime_error((std::runtime_error *)a1 - 1);
}

{
  *a1 = &unk_2511D2A30;
  boost::exception_detail::refcount_ptr<boost::exception_detail::error_info_container>::~refcount_ptr(a1 + 1);
  std::runtime_error::~runtime_error((std::runtime_error *)a1 - 1);
  JUMPOUT(0x2426A04D4);
}

uint64_t boost::wrapexcept<std::runtime_error>::wrapexcept(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  __int128 v5;

  *(_QWORD *)a1 = &unk_2511D29D0;
  std::runtime_error::runtime_error((std::runtime_error *)(a1 + 8), (const std::runtime_error *)(a2 + 8));
  v4 = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(a1 + 24) = &unk_2511D2A30;
  *(_QWORD *)(a1 + 32) = v4;
  if (v4)
    (*(void (**)(uint64_t))(*(_QWORD *)v4 + 24))(v4);
  v5 = *(_OWORD *)(a2 + 40);
  *(_DWORD *)(a1 + 56) = *(_DWORD *)(a2 + 56);
  *(_OWORD *)(a1 + 40) = v5;
  *(_QWORD *)a1 = &unk_2511D4328;
  *(_QWORD *)(a1 + 8) = &unk_2511D4358;
  *(_QWORD *)(a1 + 24) = &unk_2511D4380;
  return a1;
}

void sub_241A38428(_Unwind_Exception *a1)
{
  std::runtime_error *v1;

  std::runtime_error::~runtime_error(v1);
  _Unwind_Resume(a1);
}

uint64_t std::unordered_map<boost::uuids::uuid,ULServiceType>::unordered_map(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  uint64_t v5;

  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 32) = 1065353216;
  if (a3)
  {
    v5 = 24 * a3;
    do
    {
      std::__hash_table<std::__hash_value_type<boost::uuids::uuid,ULServiceType>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,ULServiceType>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,ULServiceType>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,ULServiceType>>>::__emplace_unique_key_args<boost::uuids::uuid,std::pair<boost::uuids::uuid const,ULServiceType> const&>(a1, a2, (uint64_t)a2);
      a2 += 3;
      v5 -= 24;
    }
    while (v5);
  }
  return a1;
}

void sub_241A384A0(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>>>::~__hash_table(v1);
  _Unwind_Resume(a1);
}

_QWORD *std::__hash_table<std::__hash_value_type<boost::uuids::uuid,ULServiceType>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,ULServiceType>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,ULServiceType>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,ULServiceType>>>::__emplace_unique_key_args<boost::uuids::uuid,std::pair<boost::uuids::uuid const,ULServiceType> const&>(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  unint64_t v3;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  uint8x8_t v9;
  _QWORD **v10;
  _QWORD *i;
  unint64_t v12;
  float v14;
  float v15;
  _BOOL8 v16;
  unint64_t v17;
  unint64_t v18;
  size_t v19;
  uint64_t v20;
  _QWORD *v21;
  unint64_t v22;

  v6 = 0;
  v7 = 0;
  do
    v7 ^= (v7 << 6) + (v7 >> 2) + 2654435769u + *((unsigned __int8 *)a2 + v6++);
  while (v6 != 16);
  v8 = *(_QWORD *)(a1 + 8);
  if (v8)
  {
    v9 = (uint8x8_t)vcnt_s8((int8x8_t)v8);
    v9.i16[0] = vaddlv_u8(v9);
    if (v9.u32[0] > 1uLL)
    {
      v3 = v7;
      if (v7 >= v8)
        v3 = v7 % v8;
    }
    else
    {
      v3 = (v8 - 1) & v7;
    }
    v10 = *(_QWORD ***)(*(_QWORD *)a1 + 8 * v3);
    if (v10)
    {
      for (i = *v10; i; i = (_QWORD *)*i)
      {
        v12 = i[1];
        if (v12 == v7)
        {
          if (i[2] == *a2 && i[3] == a2[1])
            return i;
        }
        else
        {
          if (v9.u32[0] > 1uLL)
          {
            if (v12 >= v8)
              v12 %= v8;
          }
          else
          {
            v12 &= v8 - 1;
          }
          if (v12 != v3)
            break;
        }
      }
    }
  }
  i = operator new(0x28uLL);
  *i = 0;
  i[1] = v7;
  *((_OWORD *)i + 1) = *(_OWORD *)a3;
  i[4] = *(_QWORD *)(a3 + 16);
  v14 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v15 = *(float *)(a1 + 32);
  if (!v8 || (float)(v15 * (float)v8) < v14)
  {
    v16 = 1;
    if (v8 >= 3)
      v16 = (v8 & (v8 - 1)) != 0;
    v17 = v16 | (2 * v8);
    v18 = vcvtps_u32_f32(v14 / v15);
    if (v17 <= v18)
      v19 = v18;
    else
      v19 = v17;
    std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>>>::__rehash<true>(a1, v19);
    v8 = *(_QWORD *)(a1 + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v7 >= v8)
        v3 = v7 % v8;
      else
        v3 = v7;
    }
    else
    {
      v3 = (v8 - 1) & v7;
    }
  }
  v20 = *(_QWORD *)a1;
  v21 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v3);
  if (v21)
  {
    *i = *v21;
LABEL_44:
    *v21 = i;
    goto LABEL_45;
  }
  *i = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = i;
  *(_QWORD *)(v20 + 8 * v3) = a1 + 16;
  if (*i)
  {
    v22 = *(_QWORD *)(*i + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v22 >= v8)
        v22 %= v8;
    }
    else
    {
      v22 &= v8 - 1;
    }
    v21 = (_QWORD *)(*(_QWORD *)a1 + 8 * v22);
    goto LABEL_44;
  }
LABEL_45:
  ++*(_QWORD *)(a1 + 24);
  return i;
}

void sub_241A386F8(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

void std::vector<CLMiLoServiceTable::Entry>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v1;
  void *v2;
  uint64_t v4;
  void *v5;

  v1 = *a1;
  v2 = **a1;
  if (v2)
  {
    v4 = (uint64_t)v1[1];
    v5 = **a1;
    if ((void *)v4 != v2)
    {
      do
      {
        v4 -= 88;
        std::allocator<CLMiLoServiceTable::Entry>::destroy[abi:ne180100]((uint64_t)(v1 + 2), v4);
      }
      while ((void *)v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void std::allocator<CLMiLoServiceTable::Entry>::destroy[abi:ne180100](uint64_t a1, uint64_t a2)
{
  if (*(char *)(a2 + 87) < 0)
    operator delete(*(void **)(a2 + 64));
  if (*(char *)(a2 + 55) < 0)
    operator delete(*(void **)(a2 + 32));
}

uint64_t std::vector<CLMiLoServiceTable::Entry>::__swap_out_circular_buffer(uint64_t *a1, _QWORD *a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<CLMiLoServiceTable::Entry>,std::reverse_iterator<CLMiLoServiceTable::Entry*>,std::reverse_iterator<CLMiLoServiceTable::Entry*>,std::reverse_iterator<CLMiLoServiceTable::Entry*>>((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<CLMiLoServiceTable::Entry>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x2E8BA2E8BA2E8BBLL)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(88 * a2);
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<CLMiLoServiceTable::Entry>,std::reverse_iterator<CLMiLoServiceTable::Entry*>,std::reverse_iterator<CLMiLoServiceTable::Entry*>,std::reverse_iterator<CLMiLoServiceTable::Entry*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7;
  uint64_t v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  uint64_t v12;
  _QWORD v14[3];
  char v15;
  __int128 v16;
  __int128 v17;

  v7 = a7;
  *(_QWORD *)&v17 = a6;
  *((_QWORD *)&v17 + 1) = a7;
  v16 = v17;
  v14[0] = a1;
  v14[1] = &v16;
  v14[2] = &v17;
  if (a3 == a5)
  {
    v12 = a6;
  }
  else
  {
    v8 = a7;
    do
    {
      v9 = *(_OWORD *)(a3 - 88);
      *(_OWORD *)(v8 - 72) = *(_OWORD *)(a3 - 72);
      *(_OWORD *)(v8 - 88) = v9;
      v10 = *(_OWORD *)(a3 - 56);
      *(_QWORD *)(v8 - 40) = *(_QWORD *)(a3 - 40);
      *(_OWORD *)(v8 - 56) = v10;
      *(_QWORD *)(a3 - 48) = 0;
      *(_QWORD *)(a3 - 40) = 0;
      *(_QWORD *)(a3 - 56) = 0;
      *(_QWORD *)(v8 - 32) = *(_QWORD *)(a3 - 32);
      v11 = *(_OWORD *)(a3 - 24);
      *(_QWORD *)(v8 - 8) = *(_QWORD *)(a3 - 8);
      *(_OWORD *)(v8 - 24) = v11;
      v8 -= 88;
      *(_QWORD *)(a3 - 16) = 0;
      *(_QWORD *)(a3 - 8) = 0;
      *(_QWORD *)(a3 - 24) = 0;
      v7 -= 88;
      a3 -= 88;
    }
    while (a3 != a5);
    *((_QWORD *)&v17 + 1) = v8;
    v12 = v17;
  }
  v15 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<CLMiLoServiceTable::Entry>,std::reverse_iterator<CLMiLoServiceTable::Entry*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v14);
  return v12;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<CLMiLoServiceTable::Entry>,std::reverse_iterator<CLMiLoServiceTable::Entry*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24))
    std::_AllocatorDestroyRangeReverse<std::allocator<CLMiLoServiceTable::Entry>,std::reverse_iterator<CLMiLoServiceTable::Entry*>>::operator()[abi:ne180100]((uint64_t *)a1);
  return a1;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<CLMiLoServiceTable::Entry>,std::reverse_iterator<CLMiLoServiceTable::Entry*>>::operator()[abi:ne180100](uint64_t *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;

  v1 = *(_QWORD *)(a1[2] + 8);
  v2 = *(_QWORD *)(a1[1] + 8);
  if (v1 != v2)
  {
    v3 = *a1;
    do
    {
      std::allocator<CLMiLoServiceTable::Entry>::destroy[abi:ne180100](v3, v1);
      v1 += 88;
    }
    while (v1 != v2);
  }
}

void **std::__split_buffer<CLMiLoServiceTable::Entry>::~__split_buffer(void **a1)
{
  std::__split_buffer<CLMiLoServiceTable::Entry>::clear[abi:ne180100](a1);
  if (*a1)
    operator delete(*a1);
  return a1;
}

void std::__split_buffer<CLMiLoServiceTable::Entry>::clear[abi:ne180100](_QWORD *a1)
{
  uint64_t i;
  uint64_t v2;
  uint64_t v4;

  v2 = a1[1];
  for (i = a1[2]; i != v2; i = a1[2])
  {
    v4 = a1[4];
    a1[2] = i - 88;
    std::allocator<CLMiLoServiceTable::Entry>::destroy[abi:ne180100](v4, i - 88);
  }
}

uint64_t std::vector<CLMiLoServiceTable::Entry>::__insert_with_size[abi:ne180100]<std::__wrap_iter<CLMiLoServiceTable::Entry*>,std::__wrap_iter<CLMiLoServiceTable::Entry*>>(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t v7;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;
  unint64_t v18;
  char *v19;
  uint64_t v20;
  uint64_t v21;
  char *v22;
  uint64_t v23;
  char *v24;
  void *v26[2];
  char *v27;
  char *v28;
  uint64_t v29;

  v5 = a2;
  if (a5 >= 1)
  {
    v7 = a3;
    v11 = a1[2];
    v9 = (uint64_t)(a1 + 2);
    v10 = v11;
    v12 = *(_QWORD *)(v9 - 8);
    if (0x2E8BA2E8BA2E8BA3 * ((uint64_t)(v11 - v12) >> 3) >= a5)
    {
      v20 = v12 - a2;
      if (0x2E8BA2E8BA2E8BA3 * ((uint64_t)(v12 - a2) >> 3) >= a5)
      {
        v21 = a3 + 88 * a5;
      }
      else
      {
        v21 = a3 + 8 * ((uint64_t)(v12 - a2) >> 3);
        a1[1] = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<CLMiLoServiceTable::Entry>,CLMiLoServiceTable::Entry*,CLMiLoServiceTable::Entry*,CLMiLoServiceTable::Entry*>(v9, v21, a4, *(_QWORD *)(v9 - 8));
        if (v20 < 1)
          return v5;
      }
      std::vector<CLMiLoServiceTable::Entry>::__move_range((uint64_t)a1, v5, v12, v5 + 88 * a5);
      std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<CLMiLoServiceTable::Entry *,CLMiLoServiceTable::Entry *,CLMiLoServiceTable::Entry *>((uint64_t)v26, v7, v21, v5);
    }
    else
    {
      v13 = *a1;
      v14 = a5 + 0x2E8BA2E8BA2E8BA3 * ((uint64_t)(v12 - *a1) >> 3);
      if (v14 > 0x2E8BA2E8BA2E8BALL)
        std::vector<CLMicroLocationProto::ConfidenceReason>::__throw_length_error[abi:ne180100]();
      v15 = 0x2E8BA2E8BA2E8BA3 * ((a2 - v13) >> 3);
      v16 = 0x2E8BA2E8BA2E8BA3 * ((v10 - v13) >> 3);
      v17 = 2 * v16;
      if (2 * v16 <= v14)
        v17 = v14;
      if (v16 >= 0x1745D1745D1745DLL)
        v18 = 0x2E8BA2E8BA2E8BALL;
      else
        v18 = v17;
      v29 = v9;
      if (v18)
        v19 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<CLMiLoServiceTable::Entry>>(v9, v18);
      else
        v19 = 0;
      v22 = &v19[88 * v15];
      v26[0] = v19;
      v26[1] = v22;
      v27 = v22;
      v28 = &v19[88 * v18];
      v23 = 88 * a5;
      v24 = &v22[88 * a5];
      do
      {
        std::allocator<CLMiLoServiceTable::Entry>::construct[abi:ne180100]<CLMiLoServiceTable::Entry,CLMiLoServiceTable::Entry&>(v29, (uint64_t)v22, v7);
        v22 += 88;
        v7 += 88;
        v23 -= 88;
      }
      while (v23);
      v27 = v24;
      v5 = std::vector<CLMiLoServiceTable::Entry>::__swap_out_circular_buffer(a1, v26, v5);
      std::__split_buffer<CLMiLoServiceTable::Entry>::~__split_buffer(v26);
    }
  }
  return v5;
}

void sub_241A38C3C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12)
{
  uint64_t v12;
  uint64_t v13;

  *(_QWORD *)(v12 + 8) = v13;
  _Unwind_Resume(exception_object);
}

uint64_t std::vector<CLMiLoServiceTable::Entry>::__move_range(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  unint64_t v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  char v14;

  v6 = *(_QWORD *)(a1 + 8);
  v7 = a2 + v6 - a4;
  v8 = v6;
  if (v7 < a3)
  {
    v9 = v7;
    v8 = *(_QWORD *)(a1 + 8);
    do
    {
      v10 = *(_OWORD *)(v9 + 16);
      *(_OWORD *)v8 = *(_OWORD *)v9;
      *(_OWORD *)(v8 + 16) = v10;
      v11 = *(_OWORD *)(v9 + 32);
      *(_QWORD *)(v8 + 48) = *(_QWORD *)(v9 + 48);
      *(_OWORD *)(v8 + 32) = v11;
      *(_QWORD *)(v9 + 40) = 0;
      *(_QWORD *)(v9 + 48) = 0;
      *(_QWORD *)(v9 + 32) = 0;
      *(_QWORD *)(v8 + 56) = *(_QWORD *)(v9 + 56);
      v12 = *(_OWORD *)(v9 + 64);
      *(_QWORD *)(v8 + 80) = *(_QWORD *)(v9 + 80);
      *(_OWORD *)(v8 + 64) = v12;
      *(_QWORD *)(v9 + 72) = 0;
      *(_QWORD *)(v9 + 80) = 0;
      *(_QWORD *)(v9 + 64) = 0;
      v8 += 88;
      v9 += 88;
    }
    while (v9 < a3);
  }
  *(_QWORD *)(a1 + 8) = v8;
  return std::__move_backward_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<CLMiLoServiceTable::Entry *,CLMiLoServiceTable::Entry *,CLMiLoServiceTable::Entry *>((uint64_t)&v14, a2, v7, v6);
}

uint64_t std::vector<CLMiLoServiceTable::Entry>::__swap_out_circular_buffer(uint64_t *a1, _QWORD *a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v6 = a2[1];
  v7 = (uint64_t)(a1 + 2);
  std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<CLMiLoServiceTable::Entry>,std::reverse_iterator<CLMiLoServiceTable::Entry*>,std::reverse_iterator<CLMiLoServiceTable::Entry*>,std::reverse_iterator<CLMiLoServiceTable::Entry*>>((uint64_t)(a1 + 2), a3, a3, *a1, *a1, v6, v6);
  a2[1] = v8;
  a2[2] = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<CLMiLoServiceTable::Entry>,CLMiLoServiceTable::Entry*,CLMiLoServiceTable::Entry*,CLMiLoServiceTable::Entry*>(v7, a3, a1[1], a2[2]);
  v9 = *a1;
  *a1 = a2[1];
  a2[1] = v9;
  v10 = a1[1];
  a1[1] = a2[2];
  a2[2] = v10;
  v11 = a1[2];
  a1[2] = a2[3];
  a2[3] = v11;
  *a2 = a2[1];
  return v6;
}

uint64_t std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<CLMiLoServiceTable::Entry>,CLMiLoServiceTable::Entry*,CLMiLoServiceTable::Entry*,CLMiLoServiceTable::Entry*>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  uint64_t v6;
  _QWORD v9[3];
  char v10;
  uint64_t v11;
  uint64_t v12;

  v4 = a4;
  v11 = a4;
  v12 = a4;
  v9[0] = a1;
  v9[1] = &v11;
  v9[2] = &v12;
  v10 = 0;
  if (a2 != a3)
  {
    v6 = a2;
    do
    {
      std::allocator<CLMiLoServiceTable::Entry>::construct[abi:ne180100]<CLMiLoServiceTable::Entry,CLMiLoServiceTable::Entry&>(a1, v4, v6);
      v6 += 88;
      v4 = v12 + 88;
      v12 += 88;
    }
    while (v6 != a3);
  }
  v10 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<CLMiLoServiceTable::Entry>,CLMiLoServiceTable::Entry*>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v9);
  return v4;
}

void sub_241A38E48(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<CLMiLoServiceTable::Entry>,CLMiLoServiceTable::Entry*>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void std::allocator<CLMiLoServiceTable::Entry>::construct[abi:ne180100]<CLMiLoServiceTable::Entry,CLMiLoServiceTable::Entry&>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  __int128 v5;
  std::string *v6;
  __int128 v7;
  std::string *v8;
  __int128 v9;

  v5 = *(_OWORD *)(a3 + 16);
  *(_OWORD *)a2 = *(_OWORD *)a3;
  *(_OWORD *)(a2 + 16) = v5;
  v6 = (std::string *)(a2 + 32);
  if (*(char *)(a3 + 55) < 0)
  {
    std::string::__init_copy_ctor_external(v6, *(const std::string::value_type **)(a3 + 32), *(_QWORD *)(a3 + 40));
  }
  else
  {
    v7 = *(_OWORD *)(a3 + 32);
    *(_QWORD *)(a2 + 48) = *(_QWORD *)(a3 + 48);
    *(_OWORD *)&v6->__r_.__value_.__l.__data_ = v7;
  }
  *(_QWORD *)(a2 + 56) = *(_QWORD *)(a3 + 56);
  v8 = (std::string *)(a2 + 64);
  if (*(char *)(a3 + 87) < 0)
  {
    std::string::__init_copy_ctor_external(v8, *(const std::string::value_type **)(a3 + 64), *(_QWORD *)(a3 + 72));
  }
  else
  {
    v9 = *(_OWORD *)(a3 + 64);
    *(_QWORD *)(a2 + 80) = *(_QWORD *)(a3 + 80);
    *(_OWORD *)&v8->__r_.__value_.__l.__data_ = v9;
  }
}

void sub_241A38EF0(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void **v2;

  if (*(char *)(v1 + 55) < 0)
    operator delete(*v2);
  _Unwind_Resume(exception_object);
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<CLMiLoServiceTable::Entry>,CLMiLoServiceTable::Entry*>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24))
    std::_AllocatorDestroyRangeReverse<std::allocator<CLMiLoServiceTable::Entry>,CLMiLoServiceTable::Entry*>::operator()[abi:ne180100]((uint64_t *)a1);
  return a1;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<CLMiLoServiceTable::Entry>,CLMiLoServiceTable::Entry*>::operator()[abi:ne180100](uint64_t *a1)
{
  uint64_t *v1;
  uint64_t *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  v2 = (uint64_t *)a1[1];
  v1 = (uint64_t *)a1[2];
  v3 = *v1;
  v4 = *v2;
  if (*v1 != *v2)
  {
    v5 = *a1;
    do
    {
      v3 -= 88;
      std::allocator<CLMiLoServiceTable::Entry>::destroy[abi:ne180100](v5, v3);
    }
    while (v3 != v4);
  }
}

uint64_t std::__move_backward_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<CLMiLoServiceTable::Entry *,CLMiLoServiceTable::Entry *,CLMiLoServiceTable::Entry *>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  __int128 v10;
  void **v11;
  __int128 v12;
  void **v13;
  uint64_t v14;
  __int128 v15;

  if (a3 != a2)
  {
    v7 = 0;
    do
    {
      v8 = a3 + v7;
      v9 = a4 + v7;
      v10 = *(_OWORD *)(a3 + v7 - 88);
      *(_OWORD *)(v9 - 72) = *(_OWORD *)(a3 + v7 - 72);
      *(_OWORD *)(v9 - 88) = v10;
      v11 = (void **)(a4 + v7 - 56);
      if (*(char *)(a4 + v7 - 33) < 0)
        operator delete(*v11);
      v12 = *(_OWORD *)(v8 - 56);
      *(_QWORD *)(a4 + v7 - 40) = *(_QWORD *)(v8 - 40);
      *(_OWORD *)v11 = v12;
      *(_BYTE *)(v8 - 33) = 0;
      *(_BYTE *)(v8 - 56) = 0;
      *(_QWORD *)(v9 - 32) = *(_QWORD *)(v8 - 32);
      v13 = (void **)(v9 - 24);
      if (*(char *)(v9 - 1) < 0)
        operator delete(*v13);
      v14 = a3 + v7;
      v15 = *(_OWORD *)(a3 + v7 - 24);
      *(_QWORD *)(v9 - 8) = *(_QWORD *)(a3 + v7 - 8);
      *(_OWORD *)v13 = v15;
      *(_BYTE *)(v14 - 1) = 0;
      *(_BYTE *)(v14 - 24) = 0;
      v7 -= 88;
    }
    while (a3 + v7 != a2);
  }
  return a3;
}

uint64_t std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<CLMiLoServiceTable::Entry *,CLMiLoServiceTable::Entry *,CLMiLoServiceTable::Entry *>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;
  uint64_t v6;
  __int128 v7;

  v5 = a2;
  if (a2 == a3)
    return a2;
  v6 = a3;
  do
  {
    v7 = *(_OWORD *)(v5 + 16);
    *(_OWORD *)a4 = *(_OWORD *)v5;
    *(_OWORD *)(a4 + 16) = v7;
    std::string::operator=((std::string *)(a4 + 32), (const std::string *)(v5 + 32));
    *(_QWORD *)(a4 + 56) = *(_QWORD *)(v5 + 56);
    std::string::operator=((std::string *)(a4 + 64), (const std::string *)(v5 + 64));
    a4 += 88;
    v5 += 88;
  }
  while (v5 != v6);
  return v6;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<CLMiLoServiceTable::Entry>,CLMiLoServiceTable::Entry*,CLMiLoServiceTable::Entry*,CLMiLoServiceTable::Entry*>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  _QWORD v9[3];
  char v10;
  uint64_t v11;
  uint64_t v12;

  v4 = a4;
  v12 = a4;
  v11 = a4;
  v9[0] = a1;
  v9[1] = &v11;
  v9[2] = &v12;
  if (a2 != a3)
  {
    do
    {
      v5 = *(_OWORD *)(a2 + 16);
      *(_OWORD *)v4 = *(_OWORD *)a2;
      *(_OWORD *)(v4 + 16) = v5;
      v6 = *(_OWORD *)(a2 + 32);
      *(_QWORD *)(v4 + 48) = *(_QWORD *)(a2 + 48);
      *(_OWORD *)(v4 + 32) = v6;
      *(_QWORD *)(a2 + 40) = 0;
      *(_QWORD *)(a2 + 48) = 0;
      *(_QWORD *)(a2 + 32) = 0;
      *(_QWORD *)(v4 + 56) = *(_QWORD *)(a2 + 56);
      v7 = *(_OWORD *)(a2 + 64);
      *(_QWORD *)(v4 + 80) = *(_QWORD *)(a2 + 80);
      *(_OWORD *)(v4 + 64) = v7;
      *(_QWORD *)(a2 + 72) = 0;
      *(_QWORD *)(a2 + 80) = 0;
      *(_QWORD *)(a2 + 64) = 0;
      v4 += 88;
      a2 += 88;
    }
    while (a2 != a3);
    v12 = v4;
  }
  v10 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<CLMiLoServiceTable::Entry>,CLMiLoServiceTable::Entry*>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v9);
  return v4;
}

void ***std::back_insert_iterator<std::vector<CLMiLoService::ServiceDescriptor>>::operator=[abi:ne180100](void ***a1, _OWORD *a2)
{
  void **v4;
  _OWORD *v5;
  void **v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  __int128 v10;
  _OWORD *v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  unint64_t v15;
  char *v16;
  char *v17;
  char *v18;
  __int128 v19;
  char *v20;
  char *v21;
  __int128 v22;

  v4 = *a1;
  v5 = (*a1)[1];
  v6 = *a1;
  v9 = (unint64_t)v6[2];
  v7 = (uint64_t)(v6 + 2);
  v8 = v9;
  if ((unint64_t)v5 >= v9)
  {
    v12 = ((char *)v5 - (_BYTE *)*v4) >> 5;
    v13 = v12 + 1;
    if ((unint64_t)(v12 + 1) >> 59)
      std::vector<CLMicroLocationProto::ConfidenceReason>::__throw_length_error[abi:ne180100]();
    v14 = v8 - (_QWORD)*v4;
    if (v14 >> 4 > v13)
      v13 = v14 >> 4;
    if ((unint64_t)v14 >= 0x7FFFFFFFFFFFFFE0)
      v15 = 0x7FFFFFFFFFFFFFFLL;
    else
      v15 = v13;
    if (v15)
      v16 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<CLMicroLocationResultInternal>>(v7, v15);
    else
      v16 = 0;
    v17 = &v16[32 * v12];
    v18 = &v16[32 * v15];
    v19 = a2[1];
    *(_OWORD *)v17 = *a2;
    *((_OWORD *)v17 + 1) = v19;
    v11 = v17 + 32;
    v21 = (char *)*v4;
    v20 = (char *)v4[1];
    if (v20 != *v4)
    {
      do
      {
        v22 = *((_OWORD *)v20 - 1);
        *((_OWORD *)v17 - 2) = *((_OWORD *)v20 - 2);
        *((_OWORD *)v17 - 1) = v22;
        v17 -= 32;
        v20 -= 32;
      }
      while (v20 != v21);
      v20 = (char *)*v4;
    }
    *v4 = v17;
    v4[1] = v11;
    v4[2] = v18;
    if (v20)
      operator delete(v20);
  }
  else
  {
    v10 = a2[1];
    *v5 = *a2;
    v5[1] = v10;
    v11 = v5 + 2;
  }
  v4[1] = v11;
  return a1;
}

uint64_t std::__equal_aligned[abi:ne180100]<std::__bitset<1ul,32ul>,true,true>(_QWORD *a1, unsigned int a2, uint64_t a3, unsigned int a4, _QWORD *a5)
{
  int64_t v5;
  unint64_t v6;
  uint64_t v7;
  BOOL v8;

  v5 = a4 - (unint64_t)a2 + 8 * (a3 - (_QWORD)a1);
  if (v5 >= 1)
  {
    if (a2)
    {
      if (v5 >= (unint64_t)(64 - a2))
        v6 = 64 - a2;
      else
        v6 = a4 - (unint64_t)a2 + 8 * (a3 - (_QWORD)a1);
      if (((0xFFFFFFFFFFFFFFFFLL >> (64 - a2 - v6)) & (-1 << a2) & (*a1 ^ *a5)) != 0)
        return 0;
      v5 -= v6;
      ++a5;
      ++a1;
    }
    if (v5 >= 64)
    {
      while (*a5 == *a1)
      {
        v7 = v5 - 64;
        ++a1;
        ++a5;
        v8 = v5 <= 127;
        v5 -= 64;
        if (v8)
          goto LABEL_14;
      }
      return 0;
    }
    v7 = v5;
LABEL_14:
    if (v7 >= 1 && (*a1 ^ *a5) << -(char)v7)
      return 0;
  }
  return 1;
}

uint64_t std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<CLMiLoServiceTable::Entry>,CLMiLoServiceTable::Entry const*,CLMiLoServiceTable::Entry const*,CLMiLoServiceTable::Entry*>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  uint64_t v6;
  _QWORD v9[3];
  char v10;
  uint64_t v11;
  uint64_t v12;

  v4 = a4;
  v11 = a4;
  v12 = a4;
  v9[0] = a1;
  v9[1] = &v11;
  v9[2] = &v12;
  v10 = 0;
  if (a2 != a3)
  {
    v6 = a2;
    do
    {
      std::allocator<CLMiLoServiceTable::Entry>::construct[abi:ne180100]<CLMiLoServiceTable::Entry,CLMiLoServiceTable::Entry const&>(a1, v4, v6);
      v6 += 88;
      v4 = v12 + 88;
      v12 += 88;
    }
    while (v6 != a3);
  }
  v10 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<CLMiLoServiceTable::Entry>,CLMiLoServiceTable::Entry*>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v9);
  return v4;
}

void sub_241A393F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<CLMiLoServiceTable::Entry>,CLMiLoServiceTable::Entry*>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void std::allocator<CLMiLoServiceTable::Entry>::construct[abi:ne180100]<CLMiLoServiceTable::Entry,CLMiLoServiceTable::Entry const&>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  __int128 v5;
  std::string *v6;
  __int128 v7;
  std::string *v8;
  __int128 v9;

  v5 = *(_OWORD *)(a3 + 16);
  *(_OWORD *)a2 = *(_OWORD *)a3;
  *(_OWORD *)(a2 + 16) = v5;
  v6 = (std::string *)(a2 + 32);
  if (*(char *)(a3 + 55) < 0)
  {
    std::string::__init_copy_ctor_external(v6, *(const std::string::value_type **)(a3 + 32), *(_QWORD *)(a3 + 40));
  }
  else
  {
    v7 = *(_OWORD *)(a3 + 32);
    *(_QWORD *)(a2 + 48) = *(_QWORD *)(a3 + 48);
    *(_OWORD *)&v6->__r_.__value_.__l.__data_ = v7;
  }
  *(_QWORD *)(a2 + 56) = *(_QWORD *)(a3 + 56);
  v8 = (std::string *)(a2 + 64);
  if (*(char *)(a3 + 87) < 0)
  {
    std::string::__init_copy_ctor_external(v8, *(const std::string::value_type **)(a3 + 64), *(_QWORD *)(a3 + 72));
  }
  else
  {
    v9 = *(_OWORD *)(a3 + 64);
    *(_QWORD *)(a2 + 80) = *(_QWORD *)(a3 + 80);
    *(_OWORD *)&v8->__r_.__value_.__l.__data_ = v9;
  }
}

void sub_241A39498(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void **v2;

  if (*(char *)(v1 + 55) < 0)
    operator delete(*v2);
  _Unwind_Resume(exception_object);
}

_QWORD *std::__list_imp<CLMiLoService>::__create_node[abi:ne180100]<CLMiLoService>(uint64_t a1, uint64_t a2, uint64_t a3, __int128 *a4)
{
  _QWORD *v7;

  v7 = operator new(0x1E0uLL);
  *v7 = a2;
  v7[1] = a3;
  CLMiLoService::CLMiLoService((uint64_t)(v7 + 2), a4);
  return v7;
}

void sub_241A394FC(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t CLMiLoService::CLMiLoService(uint64_t a1, __int128 *a2)
{
  __int128 v4;
  __int128 v5;
  __int128 v6;
  std::string *v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;

  v4 = *a2;
  v5 = a2[1];
  *(_QWORD *)(a1 + 32) = *((_QWORD *)a2 + 4);
  *(_OWORD *)a1 = v4;
  *(_OWORD *)(a1 + 16) = v5;
  if (*((char *)a2 + 63) < 0)
  {
    std::string::__init_copy_ctor_external((std::string *)(a1 + 40), *((const std::string::value_type **)a2 + 5), *((_QWORD *)a2 + 6));
  }
  else
  {
    v6 = *(__int128 *)((char *)a2 + 40);
    *(_QWORD *)(a1 + 56) = *((_QWORD *)a2 + 7);
    *(_OWORD *)(a1 + 40) = v6;
  }
  v7 = (std::string *)(a1 + 64);
  if (*((char *)a2 + 87) < 0)
  {
    std::string::__init_copy_ctor_external(v7, *((const std::string::value_type **)a2 + 8), *((_QWORD *)a2 + 9));
  }
  else
  {
    v8 = a2[4];
    *(_QWORD *)(a1 + 80) = *((_QWORD *)a2 + 10);
    *(_OWORD *)&v7->__r_.__value_.__l.__data_ = v8;
  }
  *(_QWORD *)(a1 + 88) = *((_QWORD *)a2 + 11);
  *(_OWORD *)(a1 + 96) = a2[6];
  *((_QWORD *)a2 + 12) = 0;
  *((_QWORD *)a2 + 13) = 0;
  *(_BYTE *)(a1 + 112) = 0;
  *(_BYTE *)(a1 + 296) = 0;
  if (*((_BYTE *)a2 + 296))
  {
    std::__construct_at[abi:ne180100]<CachedPrediction,CachedPrediction,CachedPrediction*>(a1 + 112, (uint64_t)(a2 + 7));
    *(_BYTE *)(a1 + 296) = 1;
  }
  *(_QWORD *)(a1 + 304) = *((_QWORD *)a2 + 38);
  *(_QWORD *)(a1 + 312) = *((_QWORD *)a2 + 39);
  *(_QWORD *)(a1 + 320) = *((_QWORD *)a2 + 40);
  *(_QWORD *)(a1 + 328) = *((_QWORD *)a2 + 41);
  a2[19] = 0u;
  a2[20] = 0u;
  *(_QWORD *)(a1 + 336) = *((_QWORD *)a2 + 42);
  *(_QWORD *)(a1 + 344) = *((_QWORD *)a2 + 43);
  *((_QWORD *)a2 + 42) = 0;
  *((_QWORD *)a2 + 43) = 0;
  v9 = a2[22];
  *(_BYTE *)(a1 + 368) = *((_BYTE *)a2 + 368);
  *(_OWORD *)(a1 + 352) = v9;
  *(_QWORD *)(a1 + 376) = *((_QWORD *)a2 + 47);
  *(_QWORD *)(a1 + 384) = *((_QWORD *)a2 + 48);
  *(_QWORD *)(a1 + 392) = *((_QWORD *)a2 + 49);
  *(_QWORD *)(a1 + 400) = *((_QWORD *)a2 + 50);
  *(__int128 *)((char *)a2 + 376) = 0u;
  *(__int128 *)((char *)a2 + 392) = 0u;
  *(_QWORD *)(a1 + 408) = *((_QWORD *)a2 + 51);
  *(_QWORD *)(a1 + 416) = *((_QWORD *)a2 + 52);
  *((_QWORD *)a2 + 51) = 0;
  *((_QWORD *)a2 + 52) = 0;
  v10 = *(__int128 *)((char *)a2 + 424);
  v11 = *(__int128 *)((char *)a2 + 440);
  *(_DWORD *)(a1 + 455) = *(_DWORD *)((char *)a2 + 455);
  *(_OWORD *)(a1 + 424) = v10;
  *(_OWORD *)(a1 + 440) = v11;
  return a1;
}

void sub_241A39680(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void **v2;

  if (*(char *)(v1 + 63) < 0)
    operator delete(*v2);
  _Unwind_Resume(exception_object);
}

uint64_t std::__construct_at[abi:ne180100]<CachedPrediction,CachedPrediction,CachedPrediction*>(uint64_t a1, uint64_t a2)
{
  __int128 v4;
  __int128 v5;
  __int128 v6;
  uint64_t v7;

  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(_QWORD *)(a1 + 16) = *(_QWORD *)(a2 + 16);
  *(_QWORD *)a2 = 0;
  *(_QWORD *)(a2 + 8) = 0;
  *(_QWORD *)(a2 + 16) = 0;
  v4 = *(_OWORD *)(a2 + 24);
  v5 = *(_OWORD *)(a2 + 33);
  *(_BYTE *)(a1 + 56) = 0;
  *(_OWORD *)(a1 + 33) = v5;
  *(_OWORD *)(a1 + 24) = v4;
  *(_BYTE *)(a1 + 80) = 0;
  if (*(_BYTE *)(a2 + 80))
  {
    v6 = *(_OWORD *)(a2 + 56);
    *(_QWORD *)(a1 + 72) = *(_QWORD *)(a2 + 72);
    *(_OWORD *)(a1 + 56) = v6;
    *(_QWORD *)(a2 + 64) = 0;
    *(_QWORD *)(a2 + 72) = 0;
    *(_QWORD *)(a2 + 56) = 0;
    *(_BYTE *)(a1 + 80) = 1;
  }
  *(_BYTE *)(a1 + 88) = 0;
  v7 = a1 + 88;
  *(_BYTE *)(a1 + 128) = 0;
  if (*(_BYTE *)(a2 + 128))
  {
    std::__hash_table<CLMicroLocationFingerprint::Measurement,CLMicroLocationFingerprint::Measurement::HashMeasurement,CLMicroLocationFingerprint::Measurement::PredicateMeasurement,std::allocator<CLMicroLocationFingerprint::Measurement>>::__hash_table(v7, (uint64_t *)(a2 + 88));
    *(_BYTE *)(a1 + 128) = 1;
  }
  *(_DWORD *)(a1 + 136) = *(_DWORD *)(a2 + 136);
  *(_QWORD *)(a1 + 152) = 0;
  *(_QWORD *)(a1 + 160) = 0;
  *(_QWORD *)(a1 + 144) = 0;
  *(_OWORD *)(a1 + 144) = *(_OWORD *)(a2 + 144);
  *(_QWORD *)(a1 + 160) = *(_QWORD *)(a2 + 160);
  *(_QWORD *)(a2 + 144) = 0;
  *(_QWORD *)(a2 + 152) = 0;
  *(_QWORD *)(a2 + 160) = 0;
  *(_OWORD *)(a1 + 168) = *(_OWORD *)(a2 + 168);
  return a1;
}

__n128 std::deque<CLMiLoServiceManager::OutstandingEnableCustomLoiRequest>::push_back(_QWORD *a1, __n128 *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  __n128 result;

  v4 = a1[2];
  v5 = a1[1];
  v6 = 32 * (v4 - v5) - 1;
  if (v4 == v5)
    v6 = 0;
  v7 = a1[5] + a1[4];
  if (v6 == v7)
  {
    std::deque<CLMiLoServiceManager::OutstandingEnableCustomLoiRequest>::__add_back_capacity(a1);
    v5 = a1[1];
    v7 = a1[5] + a1[4];
  }
  result = *a2;
  *(__n128 *)(*(_QWORD *)(v5 + ((v7 >> 5) & 0x7FFFFFFFFFFFFF8)) + 16 * v7) = *a2;
  ++a1[5];
  return result;
}

void std::deque<CLMiLoServiceManager::OutstandingEnableCustomLoiRequest>::__add_back_capacity(_QWORD *a1)
{
  unint64_t v2;
  BOOL v3;
  unint64_t v4;
  uint64_t v5;
  char *v6;
  _QWORD *v7;
  char *v8;
  char *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  BOOL v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  int64_t v20;
  uint64_t v21;
  unint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;
  _QWORD *v27;
  uint64_t v28;
  char *v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  unint64_t v33;
  char *v34;
  char *v35;
  uint64_t v36;
  char *v37;
  uint64_t *v38;
  uint64_t v39;
  uint64_t v40;
  char *v41;
  uint64_t v42;
  char *v43;
  _QWORD *v44;
  uint64_t v45;
  unint64_t v46;
  uint64_t v47;
  uint64_t *v48;
  uint64_t v49;
  uint64_t v50;
  char *v51;
  uint64_t v52;
  void *v53;
  __int128 v54;
  __int128 v55;
  _QWORD *v56;

  v2 = a1[4];
  v3 = v2 >= 0x100;
  v4 = v2 - 256;
  if (v3)
  {
    v5 = (uint64_t)(a1 + 3);
    v6 = (char *)a1[3];
    a1[4] = v4;
    v7 = (_QWORD *)a1[1];
    v8 = (char *)a1[2];
    v11 = *v7;
    v9 = (char *)(v7 + 1);
    v10 = v11;
    a1[1] = v9;
    if (v8 != v6)
    {
LABEL_33:
      *(_QWORD *)v8 = v10;
      a1[2] += 8;
      return;
    }
    v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      if (v8 == (char *)*a1)
        v33 = 1;
      else
        v33 = (uint64_t)&v8[-*a1] >> 2;
      v34 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<CLMicroLocationWiFiChannelHistogram>>(v5, v33);
      v35 = &v34[8 * (v33 >> 2)];
      v37 = &v34[8 * v36];
      v38 = (uint64_t *)a1[1];
      v8 = v35;
      v39 = a1[2] - (_QWORD)v38;
      if (v39)
      {
        v8 = &v35[v39 & 0xFFFFFFFFFFFFFFF8];
        v40 = 8 * (v39 >> 3);
        v41 = &v34[8 * (v33 >> 2)];
        do
        {
          v42 = *v38++;
          *(_QWORD *)v41 = v42;
          v41 += 8;
          v40 -= 8;
        }
        while (v40);
      }
      goto LABEL_30;
    }
LABEL_5:
    v13 = v12 >> 3;
    v14 = v12 >> 3 < -1;
    v15 = (v12 >> 3) + 2;
    if (v14)
      v16 = v15;
    else
      v16 = v13 + 1;
    v17 = -(v16 >> 1);
    v18 = v16 >> 1;
    v19 = &v9[-8 * v18];
    v20 = v8 - v9;
    if (v8 != v9)
    {
      memmove(&v9[-8 * v18], v9, v8 - v9);
      v9 = (char *)a1[1];
    }
    v8 = &v19[v20];
    a1[1] = &v9[8 * v17];
    a1[2] = &v19[v20];
    goto LABEL_33;
  }
  v21 = a1[2];
  v22 = (v21 - a1[1]) >> 3;
  v23 = a1[3];
  v24 = v23 - *a1;
  if (v22 < v24 >> 3)
  {
    if (v23 != v21)
    {
      *(_QWORD *)&v54 = operator new(0x1000uLL);
      std::__split_buffer<CLMiLoServiceManager::OutstandingEnableCustomLoiRequest *>::push_back(a1, &v54);
      return;
    }
    *(_QWORD *)&v54 = operator new(0x1000uLL);
    std::__split_buffer<CLMiLoServiceManager::OutstandingEnableCustomLoiRequest *>::push_front((uint64_t)a1, &v54);
    v44 = (_QWORD *)a1[1];
    v8 = (char *)a1[2];
    v45 = *v44;
    v9 = (char *)(v44 + 1);
    v10 = v45;
    a1[1] = v9;
    if (v8 != (char *)a1[3])
      goto LABEL_33;
    v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      if (v8 == (char *)*a1)
        v46 = 1;
      else
        v46 = (uint64_t)&v8[-*a1] >> 2;
      v34 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<CLMicroLocationWiFiChannelHistogram>>((uint64_t)(a1 + 3), v46);
      v35 = &v34[8 * (v46 >> 2)];
      v37 = &v34[8 * v47];
      v48 = (uint64_t *)a1[1];
      v8 = v35;
      v49 = a1[2] - (_QWORD)v48;
      if (v49)
      {
        v8 = &v35[v49 & 0xFFFFFFFFFFFFFFF8];
        v50 = 8 * (v49 >> 3);
        v51 = &v34[8 * (v46 >> 2)];
        do
        {
          v52 = *v48++;
          *(_QWORD *)v51 = v52;
          v51 += 8;
          v50 -= 8;
        }
        while (v50);
      }
LABEL_30:
      v43 = (char *)*a1;
      *a1 = v34;
      a1[1] = v35;
      a1[2] = v8;
      a1[3] = v37;
      if (v43)
      {
        operator delete(v43);
        v8 = (char *)a1[2];
      }
      goto LABEL_33;
    }
    goto LABEL_5;
  }
  if (v23 == *a1)
    v25 = 1;
  else
    v25 = v24 >> 2;
  v56 = a1 + 3;
  *(_QWORD *)&v54 = std::__allocate_at_least[abi:ne180100]<std::allocator<CLMicroLocationWiFiChannelHistogram>>((uint64_t)(a1 + 3), v25);
  *((_QWORD *)&v54 + 1) = v54 + 8 * v22;
  *(_QWORD *)&v55 = *((_QWORD *)&v54 + 1);
  *((_QWORD *)&v55 + 1) = v54 + 8 * v26;
  v53 = operator new(0x1000uLL);
  std::__split_buffer<CLMiLoServiceManager::OutstandingEnableCustomLoiRequest *>::push_back(&v54, &v53);
  v27 = (_QWORD *)a1[2];
  v28 = -7 - (_QWORD)v27;
  while (v27 != (_QWORD *)a1[1])
  {
    --v27;
    v28 += 8;
    std::__split_buffer<CLMiLoServiceManager::OutstandingEnableCustomLoiRequest *>::push_front((uint64_t)&v54, v27);
  }
  v29 = (char *)*a1;
  v30 = v54;
  v31 = v55;
  *(_QWORD *)&v54 = *a1;
  *((_QWORD *)&v54 + 1) = v27;
  v32 = *((_OWORD *)a1 + 1);
  *(_OWORD *)a1 = v30;
  *((_OWORD *)a1 + 1) = v31;
  v55 = v32;
  if (v27 != (_QWORD *)v32)
    *(_QWORD *)&v55 = v32 + (-(v32 + v28) & 0xFFFFFFFFFFFFFFF8);
  if (v29)
    operator delete(v29);
}

void sub_241A39AC8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  void *v13;

  operator delete(v13);
  if (__p)
    operator delete(__p);
  _Unwind_Resume(a1);
}

void std::__split_buffer<CLMiLoServiceManager::OutstandingEnableCustomLoiRequest *>::push_back(_QWORD *a1, _QWORD *a2)
{
  uint64_t v4;
  char *v5;
  char *v6;
  char *v7;
  uint64_t v8;
  uint64_t v9;
  BOOL v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  int64_t v16;
  char *v17;
  unint64_t v18;
  char *v19;
  uint64_t v20;
  char *v21;
  uint64_t *v22;
  uint64_t v23;
  uint64_t v24;
  char *v25;
  uint64_t v26;
  char *v27;

  v5 = (char *)a1[3];
  v4 = (uint64_t)(a1 + 3);
  v6 = *(char **)(v4 - 8);
  if (v6 == v5)
  {
    v7 = (char *)a1[1];
    v8 = (uint64_t)&v7[-*a1];
    if ((unint64_t)v7 <= *a1)
    {
      if (v6 == (char *)*a1)
        v18 = 1;
      else
        v18 = (uint64_t)&v6[-*a1] >> 2;
      v19 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<CLMicroLocationWiFiChannelHistogram>>(v4, v18);
      v21 = &v19[8 * (v18 >> 2)];
      v22 = (uint64_t *)a1[1];
      v6 = v21;
      v23 = a1[2] - (_QWORD)v22;
      if (v23)
      {
        v6 = &v21[v23 & 0xFFFFFFFFFFFFFFF8];
        v24 = 8 * (v23 >> 3);
        v25 = &v19[8 * (v18 >> 2)];
        do
        {
          v26 = *v22++;
          *(_QWORD *)v25 = v26;
          v25 += 8;
          v24 -= 8;
        }
        while (v24);
      }
      v27 = (char *)*a1;
      *a1 = v19;
      a1[1] = v21;
      a1[2] = v6;
      a1[3] = &v19[8 * v20];
      if (v27)
      {
        operator delete(v27);
        v6 = (char *)a1[2];
      }
    }
    else
    {
      v9 = v8 >> 3;
      v10 = v8 >> 3 < -1;
      v11 = (v8 >> 3) + 2;
      if (v10)
        v12 = v11;
      else
        v12 = v9 + 1;
      v13 = -(v12 >> 1);
      v14 = v12 >> 1;
      v15 = &v7[-8 * v14];
      v16 = v6 - v7;
      if (v6 != v7)
      {
        memmove(&v7[-8 * v14], v7, v6 - v7);
        v6 = (char *)a1[1];
      }
      v17 = &v6[8 * v13];
      v6 = &v15[v16];
      a1[1] = v17;
      a1[2] = &v15[v16];
    }
  }
  *(_QWORD *)v6 = *a2;
  a1[2] += 8;
}

{
  char *v4;
  char *v5;
  uint64_t v6;
  uint64_t v7;
  BOOL v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  int64_t v14;
  char *v15;
  unint64_t v16;
  char *v17;
  uint64_t v18;
  char *v19;
  uint64_t *v20;
  uint64_t v21;
  uint64_t v22;
  char *v23;
  uint64_t v24;
  char *v25;

  v4 = (char *)a1[2];
  if (v4 == (char *)a1[3])
  {
    v5 = (char *)a1[1];
    v6 = (uint64_t)&v5[-*a1];
    if ((unint64_t)v5 <= *a1)
    {
      if (v4 == (char *)*a1)
        v16 = 1;
      else
        v16 = (uint64_t)&v4[-*a1] >> 2;
      v17 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<CLMicroLocationWiFiChannelHistogram>>(a1[4], v16);
      v19 = &v17[8 * (v16 >> 2)];
      v20 = (uint64_t *)a1[1];
      v4 = v19;
      v21 = a1[2] - (_QWORD)v20;
      if (v21)
      {
        v4 = &v19[v21 & 0xFFFFFFFFFFFFFFF8];
        v22 = 8 * (v21 >> 3);
        v23 = &v17[8 * (v16 >> 2)];
        do
        {
          v24 = *v20++;
          *(_QWORD *)v23 = v24;
          v23 += 8;
          v22 -= 8;
        }
        while (v22);
      }
      v25 = (char *)*a1;
      *a1 = v17;
      a1[1] = v19;
      a1[2] = v4;
      a1[3] = &v17[8 * v18];
      if (v25)
      {
        operator delete(v25);
        v4 = (char *)a1[2];
      }
    }
    else
    {
      v7 = v6 >> 3;
      v8 = v6 >> 3 < -1;
      v9 = (v6 >> 3) + 2;
      if (v8)
        v10 = v9;
      else
        v10 = v7 + 1;
      v11 = -(v10 >> 1);
      v12 = v10 >> 1;
      v13 = &v5[-8 * v12];
      v14 = v4 - v5;
      if (v4 != v5)
      {
        memmove(&v5[-8 * v12], v5, v4 - v5);
        v4 = (char *)a1[1];
      }
      v15 = &v4[8 * v11];
      v4 = &v13[v14];
      a1[1] = v15;
      a1[2] = &v13[v14];
    }
  }
  *(_QWORD *)v4 = *a2;
  a1[2] += 8;
}

void std::__split_buffer<CLMiLoServiceManager::OutstandingEnableCustomLoiRequest *>::push_front(uint64_t a1, _QWORD *a2)
{
  char *v4;
  char *v5;
  uint64_t v6;
  _BYTE *v7;
  _BYTE *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  uint64_t *v16;
  char *v17;
  uint64_t v18;
  uint64_t v19;
  char *v20;
  uint64_t v21;
  char *v22;

  v4 = *(char **)(a1 + 8);
  if (v4 == *(char **)a1)
  {
    v6 = a1 + 24;
    v7 = *(_BYTE **)(a1 + 24);
    v8 = *(_BYTE **)(a1 + 16);
    if (v8 >= v7)
    {
      if (v7 == v4)
        v12 = 1;
      else
        v12 = (v7 - v4) >> 2;
      v13 = 2 * v12;
      v14 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<CLMicroLocationWiFiChannelHistogram>>(v6, v12);
      v5 = &v14[(v13 + 6) & 0xFFFFFFFFFFFFFFF8];
      v16 = *(uint64_t **)(a1 + 8);
      v17 = v5;
      v18 = *(_QWORD *)(a1 + 16) - (_QWORD)v16;
      if (v18)
      {
        v17 = &v5[v18 & 0xFFFFFFFFFFFFFFF8];
        v19 = 8 * (v18 >> 3);
        v20 = v5;
        do
        {
          v21 = *v16++;
          *(_QWORD *)v20 = v21;
          v20 += 8;
          v19 -= 8;
        }
        while (v19);
      }
      v22 = *(char **)a1;
      *(_QWORD *)a1 = v14;
      *(_QWORD *)(a1 + 8) = v5;
      *(_QWORD *)(a1 + 16) = v17;
      *(_QWORD *)(a1 + 24) = &v14[8 * v15];
      if (v22)
      {
        operator delete(v22);
        v5 = *(char **)(a1 + 8);
      }
    }
    else
    {
      v9 = (v7 - v8) >> 3;
      if (v9 >= -1)
        v10 = v9 + 1;
      else
        v10 = v9 + 2;
      v11 = v10 >> 1;
      v5 = &v4[8 * (v10 >> 1)];
      if (v8 != v4)
      {
        memmove(&v4[8 * (v10 >> 1)], v4, v8 - v4);
        v4 = *(char **)(a1 + 16);
      }
      *(_QWORD *)(a1 + 8) = v5;
      *(_QWORD *)(a1 + 16) = &v4[8 * v11];
    }
  }
  else
  {
    v5 = *(char **)(a1 + 8);
  }
  *((_QWORD *)v5 - 1) = *a2;
  *(_QWORD *)(a1 + 8) -= 8;
}

{
  char *v4;
  char *v5;
  _BYTE *v6;
  _BYTE *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  uint64_t *v15;
  char *v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  char *v21;

  v4 = *(char **)(a1 + 8);
  if (v4 == *(char **)a1)
  {
    v6 = *(_BYTE **)(a1 + 16);
    v7 = *(_BYTE **)(a1 + 24);
    if (v6 >= v7)
    {
      if (v7 == v4)
        v11 = 1;
      else
        v11 = (v7 - v4) >> 2;
      v12 = 2 * v11;
      v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<CLMicroLocationWiFiChannelHistogram>>(*(_QWORD *)(a1 + 32), v11);
      v5 = &v13[(v12 + 6) & 0xFFFFFFFFFFFFFFF8];
      v15 = *(uint64_t **)(a1 + 8);
      v16 = v5;
      v17 = *(_QWORD *)(a1 + 16) - (_QWORD)v15;
      if (v17)
      {
        v16 = &v5[v17 & 0xFFFFFFFFFFFFFFF8];
        v18 = 8 * (v17 >> 3);
        v19 = v5;
        do
        {
          v20 = *v15++;
          *(_QWORD *)v19 = v20;
          v19 += 8;
          v18 -= 8;
        }
        while (v18);
      }
      v21 = *(char **)a1;
      *(_QWORD *)a1 = v13;
      *(_QWORD *)(a1 + 8) = v5;
      *(_QWORD *)(a1 + 16) = v16;
      *(_QWORD *)(a1 + 24) = &v13[8 * v14];
      if (v21)
      {
        operator delete(v21);
        v5 = *(char **)(a1 + 8);
      }
    }
    else
    {
      v8 = (v7 - v6) >> 3;
      if (v8 >= -1)
        v9 = v8 + 1;
      else
        v9 = v8 + 2;
      v10 = v9 >> 1;
      v5 = &v4[8 * (v9 >> 1)];
      if (v6 != v4)
      {
        memmove(&v4[8 * (v9 >> 1)], v4, v6 - v4);
        v4 = *(char **)(a1 + 16);
      }
      *(_QWORD *)(a1 + 8) = v5;
      *(_QWORD *)(a1 + 16) = &v4[8 * v10];
    }
  }
  else
  {
    v5 = *(char **)(a1 + 8);
  }
  *((_QWORD *)v5 - 1) = *a2;
  *(_QWORD *)(a1 + 8) -= 8;
}

void std::string::__throw_out_of_range[abi:ne180100]()
{
  std::__throw_out_of_range[abi:ne180100]("basic_string");
}

CLMicroLocationModelTable::Entry *std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<CLMicroLocationModelTable::Entry>,CLMicroLocationModelTable::Entry const*,CLMicroLocationModelTable::Entry const*,CLMicroLocationModelTable::Entry*>(uint64_t a1, CLMicroLocationModelTable::Entry *a2, CLMicroLocationModelTable::Entry *a3, CLMicroLocationModelTable::Entry *this)
{
  CLMicroLocationModelTable::Entry *v4;
  const CLMicroLocationModelTable::Entry *v6;
  _QWORD v8[3];
  char v9;
  CLMicroLocationModelTable::Entry *v10;
  CLMicroLocationModelTable::Entry *v11;

  v4 = this;
  v10 = this;
  v11 = this;
  v8[0] = a1;
  v8[1] = &v10;
  v8[2] = &v11;
  v9 = 0;
  if (a2 != a3)
  {
    v6 = a2;
    do
    {
      CLMicroLocationModelTable::Entry::Entry(v4, v6);
      v6 = (const CLMicroLocationModelTable::Entry *)((char *)v6 + 312);
      v4 = (CLMicroLocationModelTable::Entry *)((char *)v11 + 312);
      v11 = (CLMicroLocationModelTable::Entry *)((char *)v11 + 312);
    }
    while (v6 != a3);
  }
  v9 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<CLMicroLocationModelTable::Entry>,CLMicroLocationModelTable::Entry*>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v8);
  return v4;
}

void sub_241A3A010(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<CLMicroLocationModelTable::Entry>,CLMicroLocationModelTable::Entry*>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

_QWORD *std::allocate_shared[abi:ne180100]<CLMiLoService::ModelAndConf,std::allocator<CLMiLoService::ModelAndConf>,CLMicroLocationModel,boost::uuids::uuid &,std::string const,boost::uuids::uuid,boost::uuids::uuid &,std::string,std::chrono::time_point<cl::chrono::CFAbsoluteTimeClock,std::chrono::duration<long double,std::ratio<1l,1l>>> &,void>@<X0>(const CLMicroLocationModel *a1@<X1>, uint64_t *a2@<X2>, __int128 *a3@<X3>, uint64_t *a4@<X4>, uint64_t *a5@<X5>, __int128 *a6@<X6>, double *a7@<X7>, _QWORD *a8@<X8>)
{
  _QWORD *v16;
  _QWORD *result;

  v16 = operator new(0x2A0uLL);
  result = std::__shared_ptr_emplace<CLMiLoService::ModelAndConf>::__shared_ptr_emplace[abi:ne180100]<CLMicroLocationModel,boost::uuids::uuid &,std::string const,boost::uuids::uuid,boost::uuids::uuid &,std::string,std::chrono::time_point<cl::chrono::CFAbsoluteTimeClock,std::chrono::duration<long double,std::ratio<1l,1l>>> &,std::allocator<CLMiLoService::ModelAndConf>,0>(v16, a1, a2, a3, a4, a5, a6, a7);
  *a8 = v16 + 3;
  a8[1] = v16;
  return result;
}

void sub_241A3A0B0(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

_QWORD *std::__shared_ptr_emplace<CLMiLoService::ModelAndConf>::__shared_ptr_emplace[abi:ne180100]<CLMicroLocationModel,boost::uuids::uuid &,std::string const,boost::uuids::uuid,boost::uuids::uuid &,std::string,std::chrono::time_point<cl::chrono::CFAbsoluteTimeClock,std::chrono::duration<long double,std::ratio<1l,1l>>> &,std::allocator<CLMiLoService::ModelAndConf>,0>(_QWORD *a1, const CLMicroLocationModel *a2, uint64_t *a3, __int128 *a4, uint64_t *a5, uint64_t *a6, __int128 *a7, double *a8)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = &off_2511D43A0;
  CLMiLoService::ModelAndConf::ModelAndConf((uint64_t)(a1 + 3), a2, *a3, a3[1], a4, *a5, a5[1], *a8, (uint64_t)a8, *a6, a6[1], a7);
  return a1;
}

void sub_241A3A12C(_Unwind_Exception *a1)
{
  std::__shared_weak_count *v1;

  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<CLMiLoService::ModelAndConf>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_2511D43A0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<CLMiLoService::ModelAndConf>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_2511D43A0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2426A04D4);
}

void std::__shared_ptr_emplace<CLMiLoService::ModelAndConf>::__on_zero_shared(uint64_t a1)
{
  CLMiLoService::ModelAndConf::~ModelAndConf((CLMiLoService::ModelAndConf *)(a1 + 24));
}

_QWORD *std::allocate_shared[abi:ne180100]<CLMiLoService::ModelAndConf,std::allocator<CLMiLoService::ModelAndConf>,CLMiLoService::ModelAndConf&,void>@<X0>(const CLMiLoService::ModelAndConf *a1@<X1>, _QWORD *a2@<X8>)
{
  _QWORD *v4;
  _QWORD *result;

  v4 = operator new(0x2A0uLL);
  result = std::__shared_ptr_emplace<CLMiLoService::ModelAndConf>::__shared_ptr_emplace[abi:ne180100]<CLMiLoService::ModelAndConf&,std::allocator<CLMiLoService::ModelAndConf>,0>(v4, a1);
  *a2 = v4 + 3;
  a2[1] = v4;
  return result;
}

void sub_241A3A1D0(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

_QWORD *std::__shared_ptr_emplace<CLMiLoService::ModelAndConf>::__shared_ptr_emplace[abi:ne180100]<CLMiLoService::ModelAndConf&,std::allocator<CLMiLoService::ModelAndConf>,0>(_QWORD *a1, const CLMiLoService::ModelAndConf *a2)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = &off_2511D43A0;
  CLMiLoService::ModelAndConf::ModelAndConf((CLMiLoService::ModelAndConf *)(a1 + 3), a2);
  return a1;
}

void sub_241A3A218(_Unwind_Exception *a1)
{
  std::__shared_weak_count *v1;

  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

CLMiLoService::ModelAndConf *CLMiLoService::ModelAndConf::ModelAndConf(CLMiLoService::ModelAndConf *this, const CLMiLoService::ModelAndConf *a2)
{
  uint64_t v4;
  __int128 v5;
  __int128 v6;

  CLMicroLocationModel::CLMicroLocationModel(this, a2);
  *(_OWORD *)(v4 + 448) = *((_OWORD *)a2 + 28);
  std::__optional_copy_base<std::string,false>::__optional_copy_base[abi:ne180100]((std::string *)(v4 + 464), (__int128 *)a2 + 29);
  v5 = *((_OWORD *)a2 + 32);
  *((_OWORD *)this + 31) = *((_OWORD *)a2 + 31);
  *((_OWORD *)this + 32) = v5;
  std::map<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>::map[abi:ne180100]((uint64_t *)this + 66, (uint64_t)a2 + 528);
  *((_QWORD *)this + 69) = *((id *)a2 + 69);
  *((_QWORD *)this + 70) = *((_QWORD *)a2 + 70);
  if (*((char *)a2 + 591) < 0)
  {
    std::string::__init_copy_ctor_external((std::string *)((char *)this + 568), *((const std::string::value_type **)a2 + 71), *((_QWORD *)a2 + 72));
  }
  else
  {
    v6 = *(_OWORD *)((char *)a2 + 568);
    *((_QWORD *)this + 73) = *((_QWORD *)a2 + 73);
    *(_OWORD *)((char *)this + 568) = v6;
  }
  *((_QWORD *)this + 74) = *((_QWORD *)a2 + 74);
  std::__optional_copy_base<CLMicroLocationAnchorValueStatisticsMap,false>::__optional_copy_base[abi:ne180100]((_BYTE *)this + 600, (uint64_t)a2 + 600);
  return this;
}

void sub_241A3A2F0(_Unwind_Exception *a1)
{
  uint64_t v1;
  void **v2;
  id *v3;

  CLMicroLocationLocalizationSettings::~CLMicroLocationLocalizationSettings(v3);
  if (*(_BYTE *)(v1 + 488))
  {
    if (*(char *)(v1 + 487) < 0)
      operator delete(*v2);
  }
  CLMicroLocationModel::~CLMicroLocationModel((void **)v1);
  _Unwind_Resume(a1);
}

uint64_t *std::map<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>::map[abi:ne180100](uint64_t *a1, uint64_t a2)
{
  a1[2] = 0;
  a1[1] = 0;
  *a1 = (uint64_t)(a1 + 1);
  std::map<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>::insert[abi:ne180100]<std::__map_const_iterator<std::__tree_const_iterator<std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>,std::__tree_node<std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>,void *> *,long>>>(a1, *(int **)a2, (int *)(a2 + 8));
  return a1;
}

void sub_241A3A388(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::__tree<std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>,std::__map_value_compare<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>,std::less<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes>,true>,std::allocator<std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>>>::destroy(v1, *(_QWORD **)(v1 + 8));
  _Unwind_Resume(a1);
}

uint64_t *std::map<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>::insert[abi:ne180100]<std::__map_const_iterator<std::__tree_const_iterator<std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>,std::__tree_node<std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>,void *> *,long>>>(uint64_t *result, int *a2, int *a3)
{
  int *v4;
  uint64_t **v5;
  uint64_t *v6;
  int *v7;
  int *v8;
  BOOL v9;

  if (a2 != a3)
  {
    v4 = a2;
    v5 = (uint64_t **)result;
    v6 = result + 1;
    do
    {
      result = std::__tree<std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>,std::__map_value_compare<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>,std::less<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes>,true>,std::allocator<std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>>>::__emplace_hint_unique_key_args<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,std::pair<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes const,double> const&>(v5, v6, v4 + 8, (_OWORD *)v4 + 2);
      v7 = (int *)*((_QWORD *)v4 + 1);
      if (v7)
      {
        do
        {
          v8 = v7;
          v7 = *(int **)v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          v8 = (int *)*((_QWORD *)v4 + 2);
          v9 = *(_QWORD *)v8 == (_QWORD)v4;
          v4 = v8;
        }
        while (!v9);
      }
      v4 = v8;
    }
    while (v8 != a3);
  }
  return result;
}

uint64_t *std::__tree<std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>,std::__map_value_compare<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>,std::less<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes>,true>,std::allocator<std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>>>::__emplace_hint_unique_key_args<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,std::pair<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes const,double> const&>(uint64_t **a1, uint64_t *a2, int *a3, _OWORD *a4)
{
  uint64_t *v6;
  uint64_t *v7;
  uint64_t **v8;
  uint64_t v10;
  uint64_t *v11;

  v6 = std::__tree<std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>,std::__map_value_compare<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>,std::less<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes>,true>,std::allocator<std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>>>::__find_equal<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes>(a1, a2, &v11, &v10, a3);
  v7 = (uint64_t *)*v6;
  if (!*v6)
  {
    v8 = (uint64_t **)v6;
    v7 = (uint64_t *)operator new(0x30uLL);
    *((_OWORD *)v7 + 2) = *a4;
    std::__tree<CLMicroLocationRecordingCompletionMetaInformation::RecordingError>::__insert_node_at(a1, (uint64_t)v11, v8, v7);
  }
  return v7;
}

uint64_t *std::__tree<std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>,std::__map_value_compare<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>,std::less<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes>,true>,std::allocator<std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>>>::__find_equal<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes>(_QWORD *a1, uint64_t *a2, uint64_t **a3, uint64_t *a4, int *a5)
{
  uint64_t *v5;
  int v6;
  int v7;
  uint64_t *v8;
  uint64_t *v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t *v12;
  uint64_t *v13;
  BOOL v14;
  int v15;
  uint64_t v16;
  uint64_t *v17;
  int v18;
  uint64_t *v19;
  uint64_t v20;
  uint64_t *v21;
  int v22;

  v5 = a1 + 1;
  if (a1 + 1 == a2 || (v6 = *a5, v7 = *((_DWORD *)a2 + 8), *a5 < v7))
  {
    v8 = (uint64_t *)*a2;
    if ((uint64_t *)*a1 == a2)
    {
      v10 = a2;
LABEL_17:
      if (v8)
      {
        *a3 = v10;
        return v10 + 1;
      }
      else
      {
        *a3 = a2;
        return a2;
      }
    }
    if (v8)
    {
      v9 = (uint64_t *)*a2;
      do
      {
        v10 = v9;
        v9 = (uint64_t *)v9[1];
      }
      while (v9);
    }
    else
    {
      v13 = a2;
      do
      {
        v10 = (uint64_t *)v13[2];
        v14 = *v10 == (_QWORD)v13;
        v13 = v10;
      }
      while (v14);
    }
    v15 = *a5;
    if (*((_DWORD *)v10 + 8) < *a5)
      goto LABEL_17;
    v16 = *v5;
    if (*v5)
    {
      do
      {
        while (1)
        {
          v17 = (uint64_t *)v16;
          v18 = *(_DWORD *)(v16 + 32);
          if (v15 >= v18)
            break;
          v16 = *v17;
          v5 = v17;
          if (!*v17)
            goto LABEL_29;
        }
        if (v18 >= v15)
          break;
        v5 = v17 + 1;
        v16 = v17[1];
      }
      while (v16);
    }
    else
    {
      v17 = a1 + 1;
    }
LABEL_29:
    *a3 = v17;
    return v5;
  }
  if (v7 >= v6)
  {
    *a3 = a2;
    *a4 = (uint64_t)a2;
    return a4;
  }
  v11 = a2[1];
  if (v11)
  {
    v12 = (uint64_t *)a2[1];
    do
    {
      a4 = v12;
      v12 = (uint64_t *)*v12;
    }
    while (v12);
  }
  else
  {
    v19 = a2;
    do
    {
      a4 = (uint64_t *)v19[2];
      v14 = *a4 == (_QWORD)v19;
      v19 = a4;
    }
    while (!v14);
  }
  if (a4 != v5 && v6 >= *((_DWORD *)a4 + 8))
  {
    v20 = *v5;
    if (*v5)
    {
      do
      {
        while (1)
        {
          v21 = (uint64_t *)v20;
          v22 = *(_DWORD *)(v20 + 32);
          if (v6 >= v22)
            break;
          v20 = *v21;
          v5 = v21;
          if (!*v21)
            goto LABEL_48;
        }
        if (v22 >= v6)
          break;
        v5 = v21 + 1;
        v20 = v21[1];
      }
      while (v20);
    }
    else
    {
      v21 = a1 + 1;
    }
LABEL_48:
    *a3 = v21;
    return v5;
  }
  if (v11)
  {
    *a3 = a4;
  }
  else
  {
    *a3 = a2;
    return a2 + 1;
  }
  return a4;
}

_BYTE *std::__optional_copy_base<CLMicroLocationAnchorValueStatisticsMap,false>::__optional_copy_base[abi:ne180100](_BYTE *a1, uint64_t a2)
{
  *a1 = 0;
  a1[40] = 0;
  if (*(_BYTE *)(a2 + 40))
  {
    std::unordered_map<boost::uuids::uuid,std::unordered_map<std::string,AnchorValueStatistics>>::unordered_map((uint64_t)a1, a2);
    a1[40] = 1;
  }
  return a1;
}

void sub_241A3A690(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (*(_BYTE *)(v1 + 40))
    std::__hash_table<std::__hash_value_type<boost::uuids::uuid,std::unordered_map<std::string,AnchorValueStatistics>>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::unordered_map<std::string,AnchorValueStatistics>>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::unordered_map<std::string,AnchorValueStatistics>>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,std::unordered_map<std::string,AnchorValueStatistics>>>>::~__hash_table(v1);
  _Unwind_Resume(exception_object);
}

uint64_t std::unordered_map<boost::uuids::uuid,std::unordered_map<std::string,AnchorValueStatistics>>::unordered_map(uint64_t a1, uint64_t a2)
{
  _QWORD *i;

  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 32) = *(_DWORD *)(a2 + 32);
  std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>>>::__rehash<true>(a1, *(_QWORD *)(a2 + 8));
  for (i = *(_QWORD **)(a2 + 16); i; i = (_QWORD *)*i)
    std::__hash_table<std::__hash_value_type<boost::uuids::uuid,std::unordered_map<std::string,AnchorValueStatistics>>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::unordered_map<std::string,AnchorValueStatistics>>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::unordered_map<std::string,AnchorValueStatistics>>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,std::unordered_map<std::string,AnchorValueStatistics>>>>::__emplace_unique_key_args<boost::uuids::uuid,std::pair<boost::uuids::uuid const,std::unordered_map<std::string,AnchorValueStatistics>> const&>(a1, i + 2, (_OWORD *)i + 1);
  return a1;
}

void sub_241A3A708(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::__hash_table<std::__hash_value_type<boost::uuids::uuid,std::unordered_map<std::string,AnchorValueStatistics>>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::unordered_map<std::string,AnchorValueStatistics>>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::unordered_map<std::string,AnchorValueStatistics>>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,std::unordered_map<std::string,AnchorValueStatistics>>>>::~__hash_table(v1);
  _Unwind_Resume(a1);
}

_QWORD *std::__hash_table<std::__hash_value_type<boost::uuids::uuid,std::unordered_map<std::string,AnchorValueStatistics>>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::unordered_map<std::string,AnchorValueStatistics>>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::unordered_map<std::string,AnchorValueStatistics>>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,std::unordered_map<std::string,AnchorValueStatistics>>>>::__emplace_unique_key_args<boost::uuids::uuid,std::pair<boost::uuids::uuid const,std::unordered_map<std::string,AnchorValueStatistics>> const&>(uint64_t a1, _QWORD *a2, _OWORD *a3)
{
  unint64_t v3;
  uint64_t v5;
  unint64_t v6;
  unint64_t v7;
  uint8x8_t v8;
  _QWORD *v9;
  _QWORD *v10;
  unint64_t v11;
  float v13;
  float v14;
  _BOOL8 v15;
  unint64_t v16;
  unint64_t v17;
  size_t v18;
  _QWORD *v19;
  unint64_t v20;
  _QWORD v22[3];

  v5 = 0;
  v6 = 0;
  do
    v6 ^= (v6 << 6) + (v6 >> 2) + 2654435769u + *((unsigned __int8 *)a2 + v5++);
  while (v5 != 16);
  v7 = *(_QWORD *)(a1 + 8);
  if (v7)
  {
    v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      v3 = v6;
      if (v6 >= v7)
        v3 = v6 % v7;
    }
    else
    {
      v3 = (v7 - 1) & v6;
    }
    v9 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v3);
    if (v9)
    {
      v10 = (_QWORD *)*v9;
      if (*v9)
      {
        do
        {
          v11 = v10[1];
          if (v11 == v6)
          {
            if (v10[2] == *a2 && v10[3] == a2[1])
              return v10;
          }
          else
          {
            if (v8.u32[0] > 1uLL)
            {
              if (v11 >= v7)
                v11 %= v7;
            }
            else
            {
              v11 &= v7 - 1;
            }
            if (v11 != v3)
              break;
          }
          v10 = (_QWORD *)*v10;
        }
        while (v10);
      }
    }
  }
  std::__hash_table<std::__hash_value_type<boost::uuids::uuid,std::unordered_map<std::string,AnchorValueStatistics>>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::unordered_map<std::string,AnchorValueStatistics>>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::unordered_map<std::string,AnchorValueStatistics>>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,std::unordered_map<std::string,AnchorValueStatistics>>>>::__construct_node_hash<std::pair<boost::uuids::uuid const,std::unordered_map<std::string,AnchorValueStatistics>> const&>(a1, v6, a3, (uint64_t)v22);
  v13 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v14 = *(float *)(a1 + 32);
  if (!v7 || (float)(v14 * (float)v7) < v13)
  {
    v15 = 1;
    if (v7 >= 3)
      v15 = (v7 & (v7 - 1)) != 0;
    v16 = v15 | (2 * v7);
    v17 = vcvtps_u32_f32(v13 / v14);
    if (v16 <= v17)
      v18 = v17;
    else
      v18 = v16;
    std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>>>::__rehash<true>(a1, v18);
    v7 = *(_QWORD *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v6 >= v7)
        v3 = v6 % v7;
      else
        v3 = v6;
    }
    else
    {
      v3 = (v7 - 1) & v6;
    }
  }
  v19 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v3);
  if (v19)
  {
    *(_QWORD *)v22[0] = *v19;
    *v19 = v22[0];
  }
  else
  {
    *(_QWORD *)v22[0] = *(_QWORD *)(a1 + 16);
    *(_QWORD *)(a1 + 16) = v22[0];
    *(_QWORD *)(*(_QWORD *)a1 + 8 * v3) = a1 + 16;
    if (*(_QWORD *)v22[0])
    {
      v20 = *(_QWORD *)(*(_QWORD *)v22[0] + 8);
      if ((v7 & (v7 - 1)) != 0)
      {
        if (v20 >= v7)
          v20 %= v7;
      }
      else
      {
        v20 &= v7 - 1;
      }
      *(_QWORD *)(*(_QWORD *)a1 + 8 * v20) = v22[0];
    }
  }
  v10 = (_QWORD *)v22[0];
  v22[0] = 0;
  ++*(_QWORD *)(a1 + 24);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<boost::uuids::uuid,std::unordered_map<std::string,AnchorValueStatistics>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<boost::uuids::uuid,std::unordered_map<std::string,AnchorValueStatistics>>,void *>>>>::reset[abi:ne180100]((uint64_t)v22, 0);
  return v10;
}

void sub_241A3A984(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<boost::uuids::uuid,std::unordered_map<std::string,AnchorValueStatistics>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<boost::uuids::uuid,std::unordered_map<std::string,AnchorValueStatistics>>,void *>>>>::reset[abi:ne180100]((uint64_t)va, 0);
  _Unwind_Resume(a1);
}

uint64_t std::__hash_table<std::__hash_value_type<boost::uuids::uuid,std::unordered_map<std::string,AnchorValueStatistics>>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::unordered_map<std::string,AnchorValueStatistics>>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::unordered_map<std::string,AnchorValueStatistics>>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,std::unordered_map<std::string,AnchorValueStatistics>>>>::__construct_node_hash<std::pair<boost::uuids::uuid const,std::unordered_map<std::string,AnchorValueStatistics>> const&>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, _OWORD *a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v7;
  _QWORD *v8;
  uint64_t result;

  v7 = a1 + 16;
  v8 = operator new(0x48uLL);
  *(_QWORD *)a4 = v8;
  *(_QWORD *)(a4 + 8) = v7;
  *(_BYTE *)(a4 + 16) = 0;
  *v8 = 0;
  v8[1] = a2;
  *((_OWORD *)v8 + 1) = *a3;
  result = std::unordered_map<std::string,AnchorValueStatistics>::unordered_map((uint64_t)(v8 + 4), (uint64_t)(a3 + 1));
  *(_BYTE *)(a4 + 16) = 1;
  return result;
}

void sub_241A3A9FC(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::unique_ptr<std::__hash_node<std::__hash_value_type<boost::uuids::uuid,std::unordered_map<std::string,AnchorValueStatistics>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<boost::uuids::uuid,std::unordered_map<std::string,AnchorValueStatistics>>,void *>>>>::reset[abi:ne180100](v1, 0);
  _Unwind_Resume(a1);
}

uint64_t std::unordered_map<std::string,AnchorValueStatistics>::unordered_map(uint64_t a1, uint64_t a2)
{
  unsigned __int8 *i;

  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 32) = *(_DWORD *)(a2 + 32);
  std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>>>::__rehash<true>(a1, *(_QWORD *)(a2 + 8));
  for (i = *(unsigned __int8 **)(a2 + 16); i; i = *(unsigned __int8 **)i)
    std::__hash_table<std::__hash_value_type<std::string,AnchorValueStatistics>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,AnchorValueStatistics>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,AnchorValueStatistics>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,AnchorValueStatistics>>>::__emplace_unique_key_args<std::string,std::pair<std::string const,AnchorValueStatistics> const&>(a1, i + 16, (uint64_t)(i + 16));
  return a1;
}

void sub_241A3AA70(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::__hash_table<std::__hash_value_type<std::string,AnchorValueStatistics>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,AnchorValueStatistics>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,AnchorValueStatistics>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,AnchorValueStatistics>>>::~__hash_table(v1);
  _Unwind_Resume(a1);
}

unsigned __int8 *std::__hash_table<std::__hash_value_type<std::string,AnchorValueStatistics>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,AnchorValueStatistics>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,AnchorValueStatistics>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,AnchorValueStatistics>>>::__emplace_unique_key_args<std::string,std::pair<std::string const,AnchorValueStatistics> const&>(uint64_t a1, unsigned __int8 *a2, uint64_t a3)
{
  unint64_t v3;
  _QWORD *v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  uint8x8_t v11;
  unint64_t v12;
  unsigned __int8 **v13;
  unsigned __int8 *i;
  unint64_t v15;
  float v16;
  float v17;
  _BOOL8 v18;
  unint64_t v19;
  unint64_t v20;
  size_t v21;
  _QWORD *v22;
  unint64_t v23;
  _QWORD v25[3];

  v7 = (_QWORD *)(a1 + 24);
  v8 = std::__string_hash<char>::operator()[abi:ne180100](a1 + 24, (uint64_t)a2);
  v9 = v8;
  v10 = *(_QWORD *)(a1 + 8);
  if (v10)
  {
    v11 = (uint8x8_t)vcnt_s8((int8x8_t)v10);
    v11.i16[0] = vaddlv_u8(v11);
    v12 = v11.u32[0];
    if (v11.u32[0] > 1uLL)
    {
      v3 = v8;
      if (v8 >= v10)
        v3 = v8 % v10;
    }
    else
    {
      v3 = (v10 - 1) & v8;
    }
    v13 = *(unsigned __int8 ***)(*(_QWORD *)a1 + 8 * v3);
    if (v13)
    {
      for (i = *v13; i; i = *(unsigned __int8 **)i)
      {
        v15 = *((_QWORD *)i + 1);
        if (v15 == v9)
        {
          if ((std::equal_to<std::string>::operator()[abi:ne180100](a1 + 32, i + 16, a2) & 1) != 0)
            return i;
        }
        else
        {
          if (v12 > 1)
          {
            if (v15 >= v10)
              v15 %= v10;
          }
          else
          {
            v15 &= v10 - 1;
          }
          if (v15 != v3)
            break;
        }
      }
    }
  }
  std::__hash_table<std::__hash_value_type<std::string,AnchorValueStatistics>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,AnchorValueStatistics>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,AnchorValueStatistics>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,AnchorValueStatistics>>>::__construct_node_hash<std::pair<std::string const,AnchorValueStatistics> const&>(a1, v9, a3, (uint64_t)v25);
  v16 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v17 = *(float *)(a1 + 32);
  if (!v10 || (float)(v17 * (float)v10) < v16)
  {
    v18 = 1;
    if (v10 >= 3)
      v18 = (v10 & (v10 - 1)) != 0;
    v19 = v18 | (2 * v10);
    v20 = vcvtps_u32_f32(v16 / v17);
    if (v19 <= v20)
      v21 = v20;
    else
      v21 = v19;
    std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>>>::__rehash<true>(a1, v21);
    v10 = *(_QWORD *)(a1 + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v9 >= v10)
        v3 = v9 % v10;
      else
        v3 = v9;
    }
    else
    {
      v3 = (v10 - 1) & v9;
    }
  }
  v22 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v3);
  if (v22)
  {
    *(_QWORD *)v25[0] = *v22;
    *v22 = v25[0];
  }
  else
  {
    *(_QWORD *)v25[0] = *(_QWORD *)(a1 + 16);
    *(_QWORD *)(a1 + 16) = v25[0];
    *(_QWORD *)(*(_QWORD *)a1 + 8 * v3) = a1 + 16;
    if (*(_QWORD *)v25[0])
    {
      v23 = *(_QWORD *)(*(_QWORD *)v25[0] + 8);
      if ((v10 & (v10 - 1)) != 0)
      {
        if (v23 >= v10)
          v23 %= v10;
      }
      else
      {
        v23 &= v10 - 1;
      }
      *(_QWORD *)(*(_QWORD *)a1 + 8 * v23) = v25[0];
    }
  }
  i = (unsigned __int8 *)v25[0];
  ++*v7;
  return i;
}

void sub_241A3ACE0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void **__p, uint64_t a11)
{
  if (__p)
    std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,AnchorValueStatistics>,void *>>>::operator()[abi:ne180100]((uint64_t)&a11, __p);
  _Unwind_Resume(exception_object);
}

__n128 std::__hash_table<std::__hash_value_type<std::string,AnchorValueStatistics>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,AnchorValueStatistics>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,AnchorValueStatistics>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,AnchorValueStatistics>>>::__construct_node_hash<std::pair<std::string const,AnchorValueStatistics> const&>@<Q0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v7;
  char *v8;
  std::string *v9;
  __n128 result;

  v7 = a1 + 16;
  v8 = (char *)operator new(0x38uLL);
  *(_QWORD *)(a4 + 8) = v7;
  *(_QWORD *)a4 = v8;
  *(_BYTE *)(a4 + 16) = 0;
  *(_QWORD *)v8 = 0;
  *((_QWORD *)v8 + 1) = a2;
  v9 = (std::string *)(v8 + 16);
  if (*(char *)(a3 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v9, *(const std::string::value_type **)a3, *(_QWORD *)(a3 + 8));
  }
  else
  {
    *(_OWORD *)&v9->__r_.__value_.__l.__data_ = *(_OWORD *)a3;
    *((_QWORD *)v8 + 4) = *(_QWORD *)(a3 + 16);
  }
  result = *(__n128 *)(a3 + 24);
  *(__n128 *)(v8 + 40) = result;
  *(_BYTE *)(a4 + 16) = 1;
  return result;
}

void sub_241A3AD90(_Unwind_Exception *a1)
{
  _QWORD *v1;
  void **v2;
  uint64_t v3;

  *v1 = 0;
  std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,AnchorValueStatistics>,void *>>>::operator()[abi:ne180100](v3, v2);
  _Unwind_Resume(a1);
}

unint64_t std::__string_hash<char>::operator()[abi:ne180100](uint64_t a1, uint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  char v5;

  v2 = *(_QWORD *)(a2 + 8);
  if (*(char *)(a2 + 23) >= 0)
  {
    v3 = *(unsigned __int8 *)(a2 + 23);
  }
  else
  {
    a2 = *(_QWORD *)a2;
    v3 = v2;
  }
  return std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:ne180100]((uint64_t)&v5, (uint64_t *)a2, v3);
}

unint64_t std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:ne180100](uint64_t a1, uint64_t *a2, unint64_t a3)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  _QWORD *v22;
  uint64_t v23;
  unint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  unint64_t v38;
  unint64_t v39;
  unint64_t v40;
  unint64_t v41;

  if (a3 > 0x20)
  {
    if (a3 > 0x40)
    {
      v4 = *(uint64_t *)((char *)a2 + a3 - 48);
      v5 = *(uint64_t *)((char *)a2 + a3 - 40);
      v6 = *(uint64_t *)((char *)a2 + a3 - 24);
      v8 = *(uint64_t *)((char *)a2 + a3 - 64);
      v7 = *(uint64_t *)((char *)a2 + a3 - 56);
      v9 = *(uint64_t *)((char *)a2 + a3 - 16);
      v10 = *(uint64_t *)((char *)a2 + a3 - 8);
      v11 = v7 + v9;
      v12 = 0x9DDFEA08EB382D69
          * (v6 ^ ((0x9DDFEA08EB382D69 * (v6 ^ (v4 + a3))) >> 47) ^ (0x9DDFEA08EB382D69 * (v6 ^ (v4 + a3))));
      v13 = 0x9DDFEA08EB382D69 * (v12 ^ (v12 >> 47));
      v14 = v8 + a3 + v7 + v4;
      v15 = v14 + v5;
      v16 = __ROR8__(v14, 44) + v8 + a3 + __ROR8__(v5 + v8 + a3 - 0x622015F714C7D297 * (v12 ^ (v12 >> 47)), 21);
      v17 = v7 + v9 + *(uint64_t *)((char *)a2 + a3 - 32) - 0x4B6D499041670D8DLL;
      v18 = v17 + v6 + v9;
      v19 = __ROR8__(v18, 44);
      v20 = v18 + v10;
      v21 = v19 + v17 + __ROR8__(v17 + v5 + v10, 21);
      v23 = *a2;
      v22 = a2 + 4;
      v24 = v23 - 0x4B6D499041670D8DLL * v5;
      v25 = -(uint64_t)((a3 - 1) & 0xFFFFFFFFFFFFFFC0);
      do
      {
        v26 = *(v22 - 3);
        v27 = v24 + v15 + v11 + v26;
        v28 = v22[2];
        v29 = v22[3];
        v30 = v22[1];
        v11 = v30 + v15 - 0x4B6D499041670D8DLL * __ROR8__(v11 + v16 + v28, 42);
        v31 = v13 + v20;
        v32 = *(v22 - 2);
        v33 = *(v22 - 1);
        v34 = *(v22 - 4) - 0x4B6D499041670D8DLL * v16;
        v35 = v34 + v20 + v33;
        v36 = v34 + v26 + v32;
        v15 = v36 + v33;
        v37 = __ROR8__(v36, 44) + v34;
        v38 = (0xB492B66FBE98F273 * __ROR8__(v27, 37)) ^ v21;
        v24 = 0xB492B66FBE98F273 * __ROR8__(v31, 33);
        v16 = v37 + __ROR8__(v35 + v38, 21);
        v39 = v24 + v21 + *v22;
        v20 = v39 + v30 + v28 + v29;
        v21 = __ROR8__(v39 + v30 + v28, 44) + v39 + __ROR8__(v11 + v32 + v39 + v29, 21);
        v22 += 8;
        v13 = v38;
        v25 += 64;
      }
      while (v25);
      v40 = v24
          - 0x622015F714C7D297
          * ((0x9DDFEA08EB382D69
            * (v21 ^ ((0x9DDFEA08EB382D69 * (v21 ^ v16)) >> 47) ^ (0x9DDFEA08EB382D69 * (v21 ^ v16)))) ^ ((0x9DDFEA08EB382D69 * (v21 ^ ((0x9DDFEA08EB382D69 * (v21 ^ v16)) >> 47) ^ (0x9DDFEA08EB382D69 * (v21 ^ v16)))) >> 47));
      v41 = 0x9DDFEA08EB382D69
          * (v40 ^ (v38
                  - 0x4B6D499041670D8DLL * (v11 ^ (v11 >> 47))
                  - 0x622015F714C7D297
                  * ((0x9DDFEA08EB382D69
                    * (v20 ^ ((0x9DDFEA08EB382D69 * (v20 ^ v15)) >> 47) ^ (0x9DDFEA08EB382D69 * (v20 ^ v15)))) ^ ((0x9DDFEA08EB382D69 * (v20 ^ ((0x9DDFEA08EB382D69 * (v20 ^ v15)) >> 47) ^ (0x9DDFEA08EB382D69 * (v20 ^ v15)))) >> 47))));
      return 0x9DDFEA08EB382D69
           * ((0x9DDFEA08EB382D69 * (v40 ^ (v41 >> 47) ^ v41)) ^ ((0x9DDFEA08EB382D69 * (v40 ^ (v41 >> 47) ^ v41)) >> 47));
    }
    else
    {
      return std::__murmur2_or_cityhash<unsigned long,64ul>::__hash_len_33_to_64[abi:ne180100](a2, a3);
    }
  }
  else if (a3 > 0x10)
  {
    return std::__murmur2_or_cityhash<unsigned long,64ul>::__hash_len_17_to_32[abi:ne180100](a2, a3);
  }
  else
  {
    return std::__murmur2_or_cityhash<unsigned long,64ul>::__hash_len_0_to_16[abi:ne180100](a2, a3);
  }
}

unint64_t std::__murmur2_or_cityhash<unsigned long,64ul>::__hash_len_0_to_16[abi:ne180100](_DWORD *a1, unint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  unint64_t result;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;

  if (a2 < 9)
  {
    if (a2 < 4)
    {
      result = 0x9AE16A3B2F90404FLL;
      if (a2)
      {
        v8 = (0xC949D7C7509E6557 * (a2 + 4 * *((unsigned __int8 *)a1 + a2 - 1))) ^ (0x9AE16A3B2F90404FLL
                                                                                      * (*(unsigned __int8 *)a1 | ((unint64_t)*((unsigned __int8 *)a1 + (a2 >> 1)) << 8)));
        return 0x9AE16A3B2F90404FLL * (v8 ^ (v8 >> 47));
      }
    }
    else
    {
      v6 = *(unsigned int *)((char *)a1 + a2 - 4);
      v7 = 0x9DDFEA08EB382D69 * (((8 * *a1) + a2) ^ v6);
      return 0x9DDFEA08EB382D69
           * ((0x9DDFEA08EB382D69 * (v6 ^ (v7 >> 47) ^ v7)) ^ ((0x9DDFEA08EB382D69 * (v6 ^ (v7 >> 47) ^ v7)) >> 47));
    }
  }
  else
  {
    v3 = *(_QWORD *)((char *)a1 + a2 - 8);
    v4 = __ROR8__(v3 + a2, a2);
    return (0x9DDFEA08EB382D69
          * ((0x9DDFEA08EB382D69
            * (v4 ^ ((0x9DDFEA08EB382D69 * (v4 ^ *(_QWORD *)a1)) >> 47) ^ (0x9DDFEA08EB382D69 * (v4 ^ *(_QWORD *)a1)))) ^ ((0x9DDFEA08EB382D69 * (v4 ^ ((0x9DDFEA08EB382D69 * (v4 ^ *(_QWORD *)a1)) >> 47) ^ (0x9DDFEA08EB382D69 * (v4 ^ *(_QWORD *)a1)))) >> 47))) ^ v3;
  }
  return result;
}

unint64_t std::__murmur2_or_cityhash<unsigned long,64ul>::__hash_len_17_to_32[abi:ne180100](_QWORD *a1, uint64_t a2)
{
  uint64_t v2;
  unint64_t v3;
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;

  v2 = a1[1];
  v3 = 0xB492B66FBE98F273 * *a1;
  v4 = __ROR8__(0x9AE16A3B2F90404FLL * *(_QWORD *)((char *)a1 + a2 - 8), 30) + __ROR8__(v3 - v2, 43);
  v5 = v3 + a2 + __ROR8__(v2 ^ 0xC949D7C7509E6557, 20) - 0x9AE16A3B2F90404FLL * *(_QWORD *)((char *)a1 + a2 - 8);
  v6 = 0x9DDFEA08EB382D69 * (v5 ^ (v4 - 0x3C5A37A36834CED9 * *(_QWORD *)((char *)a1 + a2 - 16)));
  return 0x9DDFEA08EB382D69
       * ((0x9DDFEA08EB382D69 * (v5 ^ (v6 >> 47) ^ v6)) ^ ((0x9DDFEA08EB382D69 * (v5 ^ (v6 >> 47) ^ v6)) >> 47));
}

unint64_t std::__murmur2_or_cityhash<unsigned long,64ul>::__hash_len_33_to_64[abi:ne180100](_QWORD *a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;

  v2 = *(_QWORD *)((char *)a1 + a2 - 16);
  v3 = *a1 - 0x3C5A37A36834CED9 * (v2 + a2);
  v5 = a1[2];
  v4 = a1[3];
  v6 = __ROR8__(v3 + v4, 52);
  v7 = v3 + a1[1];
  v8 = __ROR8__(v7, 7);
  v9 = v7 + v5;
  v10 = *(_QWORD *)((char *)a1 + a2 - 32) + v5;
  v11 = v8 + __ROR8__(*a1 - 0x3C5A37A36834CED9 * (v2 + a2), 37) + v6 + __ROR8__(v9, 31);
  v12 = *(_QWORD *)((char *)a1 + a2 - 24) + v10 + v2;
  v13 = 0xC3A5C85C97CB3127 * (v12 + *(_QWORD *)((char *)a1 + a2 - 8) + v4 + v11)
      - 0x651E95C4D06FBFB1
      * (v9
       + v4
       + __ROR8__(v10, 37)
       + __ROR8__(*(_QWORD *)((char *)a1 + a2 - 24) + v10, 7)
       + __ROR8__(*(_QWORD *)((char *)a1 + a2 - 8) + v4 + v10, 52)
       + __ROR8__(v12, 31));
  return 0x9AE16A3B2F90404FLL
       * ((v11 - 0x3C5A37A36834CED9 * (v13 ^ (v13 >> 47))) ^ ((v11 - 0x3C5A37A36834CED9 * (v13 ^ (v13 >> 47))) >> 47));
}

uint64_t std::equal_to<std::string>::operator()[abi:ne180100](uint64_t a1, unsigned __int8 *a2, unsigned __int8 *a3)
{
  unsigned __int8 *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  uint64_t v8;
  int v9;
  int v10;
  int v11;
  int v12;
  BOOL v14;
  uint64_t result;

  v3 = a3;
  v4 = a2[23];
  if ((v4 & 0x80u) == 0)
    v5 = a2[23];
  else
    v5 = *((_QWORD *)a2 + 1);
  v6 = a3[23];
  v7 = (char)v6;
  if ((v6 & 0x80u) != 0)
    v6 = *((_QWORD *)a3 + 1);
  if (v5 != v6)
    return 0;
  if (v7 < 0)
    v3 = *(unsigned __int8 **)a3;
  if ((v4 & 0x80) != 0)
    return memcmp(*(const void **)a2, v3, *((_QWORD *)a2 + 1)) == 0;
  if (!a2[23])
    return 1;
  v8 = v4 - 1;
  do
  {
    v10 = *a2++;
    v9 = v10;
    v12 = *v3++;
    v11 = v12;
    v14 = v8-- != 0;
    result = v9 == v11;
  }
  while (v9 == v11 && v14);
  return result;
}

void std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,AnchorValueStatistics>,void *>>>::operator()[abi:ne180100](uint64_t a1, void **__p)
{
  if (*(_BYTE *)(a1 + 8))
  {
    if (*((char *)__p + 39) < 0)
      operator delete(__p[2]);
  }
  else if (!__p)
  {
    return;
  }
  operator delete(__p);
}

void std::unique_ptr<std::__hash_node<std::__hash_value_type<boost::uuids::uuid,std::unordered_map<std::string,AnchorValueStatistics>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<boost::uuids::uuid,std::unordered_map<std::string,AnchorValueStatistics>>,void *>>>>::reset[abi:ne180100](uint64_t a1, uint64_t a2)
{
  void *v2;

  v2 = *(void **)a1;
  *(_QWORD *)a1 = a2;
  if (v2)
  {
    if (*(_BYTE *)(a1 + 16))
      std::__hash_table<std::__hash_value_type<std::string,AnchorValueStatistics>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,AnchorValueStatistics>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,AnchorValueStatistics>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,AnchorValueStatistics>>>::~__hash_table((uint64_t)v2 + 32);
    operator delete(v2);
  }
}

uint64_t std::__split_buffer<std::shared_ptr<CLMiLoService::ModelAndConf>>::~__split_buffer(uint64_t a1)
{
  uint64_t i;
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 8);
  for (i = *(_QWORD *)(a1 + 16); i != v3; i = *(_QWORD *)(a1 + 16))
  {
    *(_QWORD *)(a1 + 16) = i - 16;
    std::shared_ptr<CLMiLoService::ModelAndConf>::~shared_ptr[abi:ne180100](i - 16);
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

void std::__function::__func<CLMiLoServiceManager::modelByServiceAndLocation(CLMiLoService const&,CLMiLoService::MiLoLocation)::$_0,std::allocator<CLMiLoServiceManager::modelByServiceAndLocation(CLMiLoService const&,CLMiLoService::MiLoLocation)::$_0>,BOOL ()(std::shared_ptr<CLMiLoService::ModelAndConf> const&)>::~__func()
{
  JUMPOUT(0x2426A04D4);
}

_QWORD *std::__function::__func<CLMiLoServiceManager::modelByServiceAndLocation(CLMiLoService const&,CLMiLoService::MiLoLocation)::$_0,std::allocator<CLMiLoServiceManager::modelByServiceAndLocation(CLMiLoService const&,CLMiLoService::MiLoLocation)::$_0>,BOOL ()(std::shared_ptr<CLMiLoService::ModelAndConf> const&)>::__clone()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = &off_2511D43F0;
  return result;
}

void std::__function::__func<CLMiLoServiceManager::modelByServiceAndLocation(CLMiLoService const&,CLMiLoService::MiLoLocation)::$_0,std::allocator<CLMiLoServiceManager::modelByServiceAndLocation(CLMiLoService const&,CLMiLoService::MiLoLocation)::$_0>,BOOL ()(std::shared_ptr<CLMiLoService::ModelAndConf> const&)>::__clone(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_2511D43F0;
}

BOOL std::__function::__func<CLMiLoServiceManager::modelByServiceAndLocation(CLMiLoService const&,CLMiLoService::MiLoLocation)::$_0,std::allocator<CLMiLoServiceManager::modelByServiceAndLocation(CLMiLoService const&,CLMiLoService::MiLoLocation)::$_0>,BOOL ()(std::shared_ptr<CLMiLoService::ModelAndConf> const&)>::operator()(uint64_t a1, uint64_t a2)
{
  return *(_DWORD *)(*(_QWORD *)a2 + 4) == 0;
}

uint64_t std::__function::__func<CLMiLoServiceManager::modelByServiceAndLocation(CLMiLoService const&,CLMiLoService::MiLoLocation)::$_0,std::allocator<CLMiLoServiceManager::modelByServiceAndLocation(CLMiLoService const&,CLMiLoService::MiLoLocation)::$_0>,BOOL ()(std::shared_ptr<CLMiLoService::ModelAndConf> const&)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<CLMiLoServiceManager::modelByServiceAndLocation(CLMiLoService const&,CLMiLoService::MiLoLocation)::$_0,std::allocator<CLMiLoServiceManager::modelByServiceAndLocation(CLMiLoService const&,CLMiLoService::MiLoLocation)::$_0>,BOOL ()(std::shared_ptr<CLMiLoService::ModelAndConf> const&)>::target_type()
{
}

void std::__function::__func<CLMiLoServiceManager::modelByServiceAndLocation(CLMiLoService const&,CLMiLoService::MiLoLocation)::$_1,std::allocator<CLMiLoServiceManager::modelByServiceAndLocation(CLMiLoService const&,CLMiLoService::MiLoLocation)::$_1>,BOOL ()(std::shared_ptr<CLMiLoService::ModelAndConf> const&)>::~__func()
{
  JUMPOUT(0x2426A04D4);
}

_QWORD *std::__function::__func<CLMiLoServiceManager::modelByServiceAndLocation(CLMiLoService const&,CLMiLoService::MiLoLocation)::$_1,std::allocator<CLMiLoServiceManager::modelByServiceAndLocation(CLMiLoService const&,CLMiLoService::MiLoLocation)::$_1>,BOOL ()(std::shared_ptr<CLMiLoService::ModelAndConf> const&)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_2511D4480;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<CLMiLoServiceManager::modelByServiceAndLocation(CLMiLoService const&,CLMiLoService::MiLoLocation)::$_1,std::allocator<CLMiLoServiceManager::modelByServiceAndLocation(CLMiLoService const&,CLMiLoService::MiLoLocation)::$_1>,BOOL ()(std::shared_ptr<CLMiLoService::ModelAndConf> const&)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_2511D4480;
  a2[1] = v2;
  return result;
}

BOOL std::__function::__func<CLMiLoServiceManager::modelByServiceAndLocation(CLMiLoService const&,CLMiLoService::MiLoLocation)::$_1,std::allocator<CLMiLoServiceManager::modelByServiceAndLocation(CLMiLoService const&,CLMiLoService::MiLoLocation)::$_1>,BOOL ()(std::shared_ptr<CLMiLoService::ModelAndConf> const&)>::operator()(uint64_t a1, _QWORD *a2)
{
  unsigned __int8 *v2;
  _BOOL8 v3;
  std::string __p;

  v2 = (unsigned __int8 *)(*a2 + 464);
  CLMiLoService::getClientIdAndServiceUuid(*(CLMiLoService **)(a1 + 8), &__p);
  v3 = std::operator==[abi:ne180100]<std::string,std::string>(v2, (unsigned __int8 *)&__p);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  return v3;
}

uint64_t std::__function::__func<CLMiLoServiceManager::modelByServiceAndLocation(CLMiLoService const&,CLMiLoService::MiLoLocation)::$_1,std::allocator<CLMiLoServiceManager::modelByServiceAndLocation(CLMiLoService const&,CLMiLoService::MiLoLocation)::$_1>,BOOL ()(std::shared_ptr<CLMiLoService::ModelAndConf> const&)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<CLMiLoServiceManager::modelByServiceAndLocation(CLMiLoService const&,CLMiLoService::MiLoLocation)::$_1,std::allocator<CLMiLoServiceManager::modelByServiceAndLocation(CLMiLoService const&,CLMiLoService::MiLoLocation)::$_1>,BOOL ()(std::shared_ptr<CLMiLoService::ModelAndConf> const&)>::target_type()
{
}

BOOL std::operator==[abi:ne180100]<std::string,std::string>(unsigned __int8 *a1, unsigned __int8 *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  int v6;
  uint64_t v7;
  int v8;
  int v9;
  int v10;
  int v11;
  BOOL v13;
  BOOL v14;

  v2 = a1[24];
  if (a1[24])
  {
    v3 = a1[23];
    if ((v3 & 0x80u) == 0)
      v4 = a1[23];
    else
      v4 = *((_QWORD *)a1 + 1);
    v5 = a2[23];
    v6 = (char)v5;
    if ((v5 & 0x80u) != 0)
      v5 = *((_QWORD *)a2 + 1);
    if (v4 == v5)
    {
      if (v6 < 0)
        a2 = *(unsigned __int8 **)a2;
      if ((v3 & 0x80) != 0)
      {
        return memcmp(*(const void **)a1, a2, *((_QWORD *)a1 + 1)) == 0;
      }
      else if (a1[23])
      {
        v7 = v3 - 1;
        do
        {
          v9 = *a1++;
          v8 = v9;
          v11 = *a2++;
          v10 = v11;
          v13 = v7-- != 0;
          v14 = v8 == v10;
          v2 = v8 == v10;
        }
        while (v14 && v13);
      }
      else
      {
        return 1;
      }
    }
    else
    {
      return 0;
    }
  }
  return v2;
}

uint64_t std::deque<CLMiLoServiceManager::OutstandingEnableCustomLoiRequest>::__maybe_remove_front_spare[abi:ne180100](uint64_t a1, int a2)
{
  unint64_t v2;
  int v4;

  v2 = *(_QWORD *)(a1 + 32);
  if (v2 < 0x100)
    a2 = 1;
  if (v2 < 0x200)
    v4 = a2;
  else
    v4 = 0;
  if ((v4 & 1) == 0)
  {
    operator delete(**(void ***)(a1 + 8));
    *(_QWORD *)(a1 + 8) += 8;
    *(_QWORD *)(a1 + 32) -= 256;
  }
  return v4 ^ 1u;
}

char *std::__tree<std::pair<boost::uuids::uuid,boost::uuids::uuid>>::__emplace_unique_key_args<std::pair<boost::uuids::uuid,boost::uuids::uuid>,std::pair<boost::uuids::uuid,boost::uuids::uuid>>(uint64_t **a1, unint64_t *a2, _OWORD *a3)
{
  void **v5;
  char *v6;
  uint64_t **v7;
  __int128 v8;
  uint64_t v10;

  v5 = (void **)std::__tree<std::pair<boost::uuids::uuid,boost::uuids::uuid>>::__find_equal<std::pair<boost::uuids::uuid,boost::uuids::uuid>>((uint64_t)a1, &v10, a2);
  v6 = (char *)*v5;
  if (!*v5)
  {
    v7 = (uint64_t **)v5;
    v6 = (char *)operator new(0x40uLL);
    v8 = a3[1];
    *(_OWORD *)(v6 + 25) = *a3;
    *(_OWORD *)(v6 + 41) = v8;
    std::__tree<CLMicroLocationRecordingCompletionMetaInformation::RecordingError>::__insert_node_at(a1, v10, v7, (uint64_t *)v6);
  }
  return v6;
}

_QWORD *std::__tree<std::pair<boost::uuids::uuid,boost::uuids::uuid>>::__find_equal<std::pair<boost::uuids::uuid,boost::uuids::uuid>>(uint64_t a1, _QWORD *a2, unint64_t *a3)
{
  _QWORD *v4;
  _QWORD *v5;
  uint64_t v7;
  _QWORD *v8;
  unint64_t *v9;

  v5 = (_QWORD *)(a1 + 8);
  v4 = *(_QWORD **)(a1 + 8);
  if (v4)
  {
    v7 = a1 + 16;
    do
    {
      while (1)
      {
        v8 = v4;
        v9 = (_QWORD *)((char *)v4 + 25);
        if (!std::less<std::pair<boost::uuids::uuid,boost::uuids::uuid>>::operator()[abi:ne180100](v7, a3, (_QWORD *)((char *)v4 + 25)))break;
        v4 = (_QWORD *)*v8;
        v5 = v8;
        if (!*v8)
          goto LABEL_10;
      }
      if (!std::less<std::pair<boost::uuids::uuid,boost::uuids::uuid>>::operator()[abi:ne180100](v7, v9, a3))break;
      v5 = v8 + 1;
      v4 = (_QWORD *)v8[1];
    }
    while (v4);
  }
  else
  {
    v8 = (_QWORD *)(a1 + 8);
  }
LABEL_10:
  *a2 = v8;
  return v5;
}

uint64_t std::less<std::pair<boost::uuids::uuid,boost::uuids::uuid>>::operator()[abi:ne180100](uint64_t a1, unint64_t *a2, unint64_t *a3)
{
  unint64_t v3;
  unint64_t v4;
  int v6;
  unint64_t v7;
  unint64_t v8;
  int v9;
  unint64_t v10;
  unint64_t v11;
  unsigned int v12;

  v3 = bswap64(*a2);
  v4 = bswap64(*a3);
  if (v3 != v4 || (v3 = bswap64(a2[1]), v4 = bswap64(a3[1]), v3 != v4))
  {
    v6 = v3 < v4 ? -1 : 1;
    if (v6 < 0)
      return 1;
  }
  v7 = bswap64(*a3);
  v8 = bswap64(*a2);
  if (v7 != v8 || (v7 = bswap64(a3[1]), v8 = bswap64(a2[1]), v7 != v8))
  {
    v9 = v7 < v8 ? -1 : 1;
    if (v9 < 0)
      return 0;
  }
  v10 = bswap64(a2[2]);
  v11 = bswap64(a3[2]);
  if (v10 == v11 && (v10 = bswap64(a2[3]), v11 = bswap64(a3[3]), v10 == v11))
  {
    v12 = 0;
  }
  else if (v10 < v11)
  {
    v12 = -1;
  }
  else
  {
    v12 = 1;
  }
  return v12 >> 31;
}

__int128 *std::__move_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<CLMiLoServiceManager::ConnectionRequestParams *,CLMiLoServiceManager::ConnectionRequestParams *,CLMiLoServiceManager::ConnectionRequestParams *>(uint64_t a1, __int128 *a2, __int128 *a3, uint64_t a4)
{
  __int128 *v5;
  __int128 v7;
  char v8;
  __int128 v9;
  __int128 v10;
  void **v11;
  __int128 v12;

  v5 = a2;
  if (a2 != a3)
  {
    do
    {
      if (*(char *)(a4 + 23) < 0)
        operator delete(*(void **)a4);
      v7 = *v5;
      *(_QWORD *)(a4 + 16) = *((_QWORD *)v5 + 2);
      *(_OWORD *)a4 = v7;
      *((_BYTE *)v5 + 23) = 0;
      *(_BYTE *)v5 = 0;
      v8 = *((_BYTE *)v5 + 72);
      v9 = *(__int128 *)((char *)v5 + 56);
      v10 = *(__int128 *)((char *)v5 + 40);
      *(_OWORD *)(a4 + 24) = *(__int128 *)((char *)v5 + 24);
      *(_OWORD *)(a4 + 40) = v10;
      *(_OWORD *)(a4 + 56) = v9;
      *(_BYTE *)(a4 + 72) = v8;
      v11 = (void **)(a4 + 80);
      if (*(char *)(a4 + 103) < 0)
        operator delete(*v11);
      v12 = v5[5];
      *(_QWORD *)(a4 + 96) = *((_QWORD *)v5 + 12);
      *(_OWORD *)v11 = v12;
      *((_BYTE *)v5 + 103) = 0;
      *((_BYTE *)v5 + 80) = 0;
      a4 += 104;
      v5 = (__int128 *)((char *)v5 + 104);
    }
    while (v5 != a3);
    return a3;
  }
  return v5;
}

uint64_t std::vector<CLMiLoServiceManager::ConnectionRequestParams>::__swap_out_circular_buffer(uint64_t *a1, _QWORD *a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<CLMiLoServiceManager::ConnectionRequestParams>,std::reverse_iterator<CLMiLoServiceManager::ConnectionRequestParams*>,std::reverse_iterator<CLMiLoServiceManager::ConnectionRequestParams*>,std::reverse_iterator<CLMiLoServiceManager::ConnectionRequestParams*>>((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<CLMiLoServiceManager::ConnectionRequestParams>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x276276276276277)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(104 * a2);
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<CLMiLoServiceManager::ConnectionRequestParams>,std::reverse_iterator<CLMiLoServiceManager::ConnectionRequestParams*>,std::reverse_iterator<CLMiLoServiceManager::ConnectionRequestParams*>,std::reverse_iterator<CLMiLoServiceManager::ConnectionRequestParams*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7;
  uint64_t v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  _QWORD v16[3];
  char v17;
  __int128 v18;
  __int128 v19;

  v7 = a7;
  *(_QWORD *)&v19 = a6;
  *((_QWORD *)&v19 + 1) = a7;
  v18 = v19;
  v16[0] = a1;
  v16[1] = &v18;
  v16[2] = &v19;
  if (a3 != a5)
  {
    v9 = a7;
    do
    {
      v10 = *(_OWORD *)(a3 - 104);
      *(_QWORD *)(v9 - 88) = *(_QWORD *)(a3 - 88);
      *(_OWORD *)(v9 - 104) = v10;
      *(_QWORD *)(a3 - 96) = 0;
      *(_QWORD *)(a3 - 88) = 0;
      *(_QWORD *)(a3 - 104) = 0;
      v11 = *(_OWORD *)(a3 - 80);
      v12 = *(_OWORD *)(a3 - 64);
      v13 = *(_OWORD *)(a3 - 48);
      *(_BYTE *)(v9 - 32) = *(_BYTE *)(a3 - 32);
      *(_OWORD *)(v9 - 64) = v12;
      *(_OWORD *)(v9 - 48) = v13;
      *(_OWORD *)(v9 - 80) = v11;
      v14 = *(_OWORD *)(a3 - 24);
      *(_QWORD *)(v9 - 8) = *(_QWORD *)(a3 - 8);
      *(_OWORD *)(v9 - 24) = v14;
      v9 -= 104;
      *(_QWORD *)(a3 - 16) = 0;
      *(_QWORD *)(a3 - 8) = 0;
      *(_QWORD *)(a3 - 24) = 0;
      v7 -= 104;
      a3 -= 104;
    }
    while (a3 != a5);
    *((_QWORD *)&v19 + 1) = v9;
  }
  v17 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<CLMiLoServiceManager::ConnectionRequestParams>,std::reverse_iterator<CLMiLoServiceManager::ConnectionRequestParams*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v16);
  return a6;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<CLMiLoServiceManager::ConnectionRequestParams>,std::reverse_iterator<CLMiLoServiceManager::ConnectionRequestParams*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24))
    std::_AllocatorDestroyRangeReverse<std::allocator<CLMiLoServiceManager::ConnectionRequestParams>,std::reverse_iterator<CLMiLoServiceManager::ConnectionRequestParams*>>::operator()[abi:ne180100]((uint64_t *)a1);
  return a1;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<CLMiLoServiceManager::ConnectionRequestParams>,std::reverse_iterator<CLMiLoServiceManager::ConnectionRequestParams*>>::operator()[abi:ne180100](uint64_t *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;

  v1 = *(_QWORD *)(a1[2] + 8);
  v2 = *(_QWORD *)(a1[1] + 8);
  if (v1 != v2)
  {
    v3 = *a1;
    do
    {
      std::allocator<CLMiLoServiceManager::ConnectionRequestParams>::destroy[abi:ne180100](v3, v1);
      v1 += 104;
    }
    while (v1 != v2);
  }
}

void **std::__split_buffer<CLMiLoServiceManager::ConnectionRequestParams>::~__split_buffer(void **a1)
{
  std::__split_buffer<CLMiLoServiceManager::ConnectionRequestParams>::clear[abi:ne180100](a1);
  if (*a1)
    operator delete(*a1);
  return a1;
}

void std::__split_buffer<CLMiLoServiceManager::ConnectionRequestParams>::clear[abi:ne180100](_QWORD *a1)
{
  uint64_t i;
  uint64_t v2;
  uint64_t v4;

  v2 = a1[1];
  for (i = a1[2]; i != v2; i = a1[2])
  {
    v4 = a1[4];
    a1[2] = i - 104;
    std::allocator<CLMiLoServiceManager::ConnectionRequestParams>::destroy[abi:ne180100](v4, i - 104);
  }
}

BOOL CLMicroLocationWiFiChannelHistogramAnalyzer::histogramSortFunction(uint64_t a1, uint64_t a2)
{
  return HIDWORD(a1) > HIDWORD(a2);
}

_QWORD *CLMicroLocationWiFiChannelHistogramAnalyzer::update(_QWORD *result, uint64_t *a2)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v4;
  unsigned int v5;
  unsigned int *v6;

  v2 = *a2;
  v3 = a2[1];
  if (*a2 != v3)
  {
    v4 = result;
    do
    {
      v5 = *(_DWORD *)(v2 + 32);
      if (!std::__hash_table<std::__hash_value_type<unsigned int,unsigned int>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,unsigned int>>>::find<unsigned int>(v4, &v5))
      {
        v6 = &v5;
        *((_DWORD *)std::__hash_table<std::__hash_value_type<unsigned int,unsigned int>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,unsigned int>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>((uint64_t)v4, &v5, (uint64_t)&std::piecewise_construct, &v6)+ 5) = 0;
      }
      v6 = &v5;
      result = std::__hash_table<std::__hash_value_type<unsigned int,unsigned int>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,unsigned int>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>((uint64_t)v4, &v5, (uint64_t)&std::piecewise_construct, &v6);
      ++*((_DWORD *)result + 5);
      v2 += 48;
    }
    while (v2 != v3);
  }
  return result;
}

BOOL CLMicroLocationWiFiChannelHistogramAnalyzer::isEmpty(CLMicroLocationWiFiChannelHistogramAnalyzer *this)
{
  return *((_QWORD *)this + 3) == 0;
}

void CLMicroLocationWiFiChannelHistogramAnalyzer::getHistogram(uint64_t a1@<X0>, unsigned __int8 *a2@<X1>, uint64_t *a3@<X8>)
{
  _QWORD *v5;
  _QWORD *v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  char *v12;
  uint64_t v13;
  char *v14;
  char *v15;
  char *v16;
  uint64_t v17;
  _QWORD **v18;
  _QWORD *v19;
  uint64_t *v20;
  int v21;
  uint64_t v22;
  uint64_t *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  unint64_t v27;
  char *v28;
  uint64_t v29;
  char *v30;
  char *v31;
  char *v32;
  char *v33;
  uint64_t v34;
  _QWORD *v35;
  _QWORD **v36;
  BOOL v37;
  uint64_t v38;
  unint64_t v39;
  uint64_t v40;
  _QWORD **v41;
  _QWORD *v42[2];
  BOOL (*v43)(uint64_t, uint64_t);

  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  v5 = *(_QWORD **)(a1 + 16);
  if (v5)
  {
    v6 = 0;
    v7 = a3 + 2;
    do
    {
      if ((unint64_t)v6 >= *v7)
      {
        v8 = ((uint64_t)v6 - *a3) >> 3;
        if ((unint64_t)(v8 + 1) >> 61)
          std::vector<CLMicroLocationProto::ConfidenceReason>::__throw_length_error[abi:ne180100]();
        v9 = *v7 - *a3;
        v10 = v9 >> 2;
        if (v9 >> 2 <= (unint64_t)(v8 + 1))
          v10 = v8 + 1;
        if ((unint64_t)v9 >= 0x7FFFFFFFFFFFFFF8)
          v11 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v11 = v10;
        v12 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<CLMicroLocationWiFiChannelHistogram>>((uint64_t)(a3 + 2), v11);
        v14 = &v12[8 * v8];
        *(_QWORD *)v14 = v5[2];
        v6 = v14 + 8;
        v16 = (char *)*a3;
        v15 = (char *)a3[1];
        if (v15 != (char *)*a3)
        {
          do
          {
            v17 = *((_QWORD *)v15 - 1);
            v15 -= 8;
            *((_QWORD *)v14 - 1) = v17;
            v14 -= 8;
          }
          while (v15 != v16);
          v15 = (char *)*a3;
        }
        *a3 = (uint64_t)v14;
        a3[1] = (uint64_t)v6;
        a3[2] = (uint64_t)&v12[8 * v13];
        if (v15)
          operator delete(v15);
      }
      else
      {
        *v6++ = v5[2];
      }
      a3[1] = (uint64_t)v6;
      v5 = (_QWORD *)*v5;
    }
    while (v5);
  }
  CLMicroLocationWiFiChannelHistogramAnalyzer::getValidChannels(a2, (uint64_t *)&v41);
  v18 = v41;
  if (v41 == v42)
  {
    v20 = (uint64_t *)a3[1];
  }
  else
  {
    v19 = a3 + 2;
    v20 = (uint64_t *)a3[1];
    do
    {
      v21 = *((_DWORD *)v18 + 7);
      v22 = *a3;
      v23 = (uint64_t *)*a3;
      if ((uint64_t *)*a3 == v20)
      {
LABEL_22:
        if ((unint64_t)v20 >= *v19)
        {
          v24 = ((uint64_t)v20 - v22) >> 3;
          if ((unint64_t)(v24 + 1) >> 61)
            std::vector<CLMicroLocationProto::ConfidenceReason>::__throw_length_error[abi:ne180100]();
          v25 = *v19 - v22;
          v26 = v25 >> 2;
          if (v25 >> 2 <= (unint64_t)(v24 + 1))
            v26 = v24 + 1;
          if ((unint64_t)v25 >= 0x7FFFFFFFFFFFFFF8)
            v27 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v27 = v26;
          v28 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<CLMicroLocationWiFiChannelHistogram>>((uint64_t)(a3 + 2), v27);
          v30 = &v28[8 * v24];
          *(_DWORD *)v30 = v21;
          *((_DWORD *)v30 + 1) = 0;
          v32 = (char *)*a3;
          v31 = (char *)a3[1];
          v33 = v30;
          if (v31 != (char *)*a3)
          {
            do
            {
              v34 = *((_QWORD *)v31 - 1);
              v31 -= 8;
              *((_QWORD *)v33 - 1) = v34;
              v33 -= 8;
            }
            while (v31 != v32);
            v31 = (char *)*a3;
          }
          v20 = (uint64_t *)(v30 + 8);
          *a3 = (uint64_t)v33;
          a3[1] = (uint64_t)(v30 + 8);
          a3[2] = (uint64_t)&v28[8 * v29];
          if (v31)
            operator delete(v31);
        }
        else
        {
          *(_DWORD *)v20 = v21;
          *((_DWORD *)v20++ + 1) = 0;
        }
        a3[1] = (uint64_t)v20;
      }
      else
      {
        while (*(_DWORD *)v23 != v21)
        {
          if (++v23 == v20)
            goto LABEL_22;
        }
      }
      v35 = v18[1];
      if (v35)
      {
        do
        {
          v36 = (_QWORD **)v35;
          v35 = (_QWORD *)*v35;
        }
        while (v35);
      }
      else
      {
        do
        {
          v36 = (_QWORD **)v18[2];
          v37 = *v36 == v18;
          v18 = v36;
        }
        while (!v37);
      }
      v18 = v36;
    }
    while (v36 != v42);
  }
  v38 = *a3;
  v39 = 126 - 2 * __clz(((uint64_t)v20 - *a3) >> 3);
  v37 = v20 == (uint64_t *)*a3;
  v43 = CLMicroLocationWiFiChannelHistogramAnalyzer::histogramSortFunction;
  if (v37)
    v40 = 0;
  else
    v40 = v39;
  std::__introsort<std::_ClassicAlgPolicy,BOOL (*&)(CLMicroLocationWiFiChannelHistogram,CLMicroLocationWiFiChannelHistogram),CLMicroLocationWiFiChannelHistogram*,false>(v38, v20, (uint64_t (**)(uint64_t, uint64_t))&v43, v40, 1);
  std::__tree<std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>,std::__map_value_compare<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>,std::less<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes>,true>,std::allocator<std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>>>::destroy((uint64_t)&v41, v42[0]);
}

void sub_241A3BF50(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, _QWORD *a10)
{
  uint64_t v10;
  void *v12;

  std::__tree<std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>,std::__map_value_compare<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>,std::less<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes>,true>,std::allocator<std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>>>::destroy((uint64_t)&a9, a10);
  v12 = *(void **)v10;
  if (*(_QWORD *)v10)
  {
    *(_QWORD *)(v10 + 8) = v12;
    operator delete(v12);
  }
  _Unwind_Resume(a1);
}

uint64_t CLMicroLocationWiFiChannelHistogramAnalyzer::getValidChannels@<X0>(unsigned __int8 *a1@<X0>, uint64_t *a2@<X8>)
{
  uint64_t i;
  unsigned __int8 *v5;
  _QWORD **v7;
  _QWORD *v8;
  uint64_t v9;
  _QWORD **v10;
  _QWORD *v11;
  uint64_t v12;
  _QWORD v13[5];
  _OWORD v14[6];
  uint64_t v15;
  _OWORD v16[3];
  int v17;
  _QWORD v18[3];
  _QWORD *v19;
  _QWORD v20[2];
  _QWORD v21[3];
  _QWORD *v22;
  _QWORD v23[3];

  v23[2] = *MEMORY[0x24BDAC8D0];
  v16[0] = xmmword_241BB44A0;
  v16[1] = unk_241BB44B0;
  v16[2] = xmmword_241BB44C0;
  v17 = 13;
  std::set<unsigned int>::set[abi:ne180100]((uint64_t)&v10, (unsigned int *)v16, 13);
  std::string::basic_string[abi:ne180100]<0>(v18, "home");
  v19 = v10;
  v20[0] = v11;
  v20[1] = v12;
  if (v12)
  {
    v11[2] = v20;
    v10 = &v11;
    v11 = 0;
    v12 = 0;
  }
  else
  {
    v19 = v20;
  }
  v14[2] = xmmword_241BB44F4;
  v14[3] = unk_241BB4504;
  v14[4] = xmmword_241BB4514;
  v14[5] = unk_241BB4524;
  v14[0] = xmmword_241BB44D4;
  v14[1] = unk_241BB44E4;
  v15 = 0xB1000000ADLL;
  std::set<unsigned int>::set[abi:ne180100]((uint64_t)&v7, (unsigned int *)v14, 26);
  std::string::basic_string[abi:ne180100]<0>(v21, "custom");
  v22 = v7;
  v23[0] = v8;
  v23[1] = v9;
  if (v9)
  {
    v8[2] = v23;
    v7 = &v8;
    v8 = 0;
    v9 = 0;
  }
  else
  {
    v22 = v23;
  }
  std::unordered_map<std::string,std::set<unsigned int>>::unordered_map((uint64_t)v13, (unsigned __int8 *)v18, 2);
  for (i = 0; i != -12; i -= 6)
  {
    std::__tree<std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>,std::__map_value_compare<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>,std::less<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes>,true>,std::allocator<std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>>>::destroy((uint64_t)&v23[i - 1], (_QWORD *)v23[i]);
    if (SHIBYTE(v21[i + 2]) < 0)
      operator delete((void *)v21[i]);
  }
  std::__tree<std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>,std::__map_value_compare<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>,std::less<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes>,true>,std::allocator<std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>>>::destroy((uint64_t)&v7, v8);
  std::__tree<std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>,std::__map_value_compare<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>,std::less<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes>,true>,std::allocator<std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>>>::destroy((uint64_t)&v10, v11);
  v5 = std::__hash_table<std::__hash_value_type<std::string,std::set<unsigned int>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::set<unsigned int>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::set<unsigned int>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::set<unsigned int>>>>::find<std::string>(v13, a1);
  if (v5)
  {
    std::set<unsigned int>::set[abi:ne180100](a2, (uint64_t)(v5 + 40));
  }
  else
  {
    a2[2] = 0;
    a2[1] = 0;
    *a2 = (uint64_t)(a2 + 1);
  }
  return std::__hash_table<std::__hash_value_type<std::string,std::set<unsigned int>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::set<unsigned int>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::set<unsigned int>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::set<unsigned int>>>>::~__hash_table((uint64_t)v13);
}

void sub_241A3C198(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, _QWORD *a12, uint64_t a13, uint64_t a14, char a15, _QWORD *a16)
{
  uint64_t v16;
  uint64_t i;

  for (i = 48; i != -48; i -= 48)
    std::pair<std::string const,std::set<unsigned int>>::~pair(v16 + i);
  std::__tree<std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>,std::__map_value_compare<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>,std::less<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes>,true>,std::allocator<std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>>>::destroy((uint64_t)&a11, a12);
  std::__tree<std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>,std::__map_value_compare<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>,std::less<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes>,true>,std::allocator<std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>>>::destroy((uint64_t)&a15, a16);
  _Unwind_Resume(a1);
}

void CLMicroLocationWiFiChannelHistogramAnalyzer::histogramFromProtobuf(uint64_t a1@<X0>, unsigned __int8 *a2@<X1>, void **a3@<X8>)
{
  CLMicroLocationProto::Configuration *ValidChannels;
  uint64_t v6;
  uint64_t v7;
  const CLMicroLocationProto::ChannelAndCount **v8;
  const CLMicroLocationProto::ChannelAndCount **v9;
  _QWORD *v10;
  unsigned int v11;
  _QWORD **v12;
  _QWORD *v13;
  _QWORD **v14;
  unsigned int v15;
  _QWORD *v16;
  unsigned int v17;
  unint64_t v18;
  unsigned int *v19;
  _DWORD *v20;
  uint64_t v21;
  unint64_t v22;
  uint64_t v23;
  unint64_t v24;
  char *v25;
  uint64_t v26;
  char *v27;
  char *v28;
  char *v29;
  char *v30;
  uint64_t v31;
  char v32[8];
  uint64_t v33;
  unsigned int v34;
  uint64_t v35;
  _QWORD *v36[2];

  if (*(_DWORD *)(a1 + 40))
  {
    CLMicroLocationWiFiChannelHistogramAnalyzer::histogramFromProtobuf();
LABEL_32:
    std::vector<CLMicroLocationProto::ConfidenceReason>::__throw_length_error[abi:ne180100]();
  }
  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  ValidChannels = (CLMicroLocationProto::Configuration *)CLMicroLocationWiFiChannelHistogramAnalyzer::getValidChannels(a2, &v35);
  v6 = *(_QWORD *)(a1 + 16);
  if (!v6)
    v6 = *(_QWORD *)(CLMicroLocationProto::Configuration::default_instance(ValidChannels) + 16);
  v7 = *(int *)(v6 + 16);
  if ((_DWORD)v7)
  {
    v8 = *(const CLMicroLocationProto::ChannelAndCount ***)(v6 + 8);
    v9 = &v8[v7];
    do
    {
      CLMicroLocationProto::ChannelAndCount::ChannelAndCount((CLMicroLocationProto::ChannelAndCount *)v32, *v8);
      v10 = v36[0];
      if (v36[0])
      {
        v11 = v34;
        v12 = v36;
        do
        {
          v13 = v10;
          v14 = v12;
          v15 = *((_DWORD *)v10 + 7);
          v16 = v10 + 1;
          if (v15 >= v34)
          {
            v16 = v13;
            v12 = (_QWORD **)v13;
          }
          v10 = (_QWORD *)*v16;
        }
        while (v10);
        if (v12 != v36)
        {
          if (v15 < v34)
            v13 = v14;
          if (v34 >= *((_DWORD *)v13 + 7))
          {
            v17 = v33;
            v19 = (unsigned int *)a3[1];
            v18 = (unint64_t)a3[2];
            if ((unint64_t)v19 >= v18)
            {
              v21 = ((char *)v19 - (_BYTE *)*a3) >> 3;
              v22 = v21 + 1;
              if ((unint64_t)(v21 + 1) >> 61)
                goto LABEL_32;
              v23 = v18 - (_QWORD)*a3;
              if (v23 >> 2 > v22)
                v22 = v23 >> 2;
              if ((unint64_t)v23 >= 0x7FFFFFFFFFFFFFF8)
                v24 = 0x1FFFFFFFFFFFFFFFLL;
              else
                v24 = v22;
              v25 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<CLMicroLocationWiFiChannelHistogram>>((uint64_t)(a3 + 2), v24);
              v27 = &v25[8 * v21];
              *(_DWORD *)v27 = v11;
              *((_DWORD *)v27 + 1) = v17;
              v29 = (char *)*a3;
              v28 = (char *)a3[1];
              v30 = v27;
              if (v28 != *a3)
              {
                do
                {
                  v31 = *((_QWORD *)v28 - 1);
                  v28 -= 8;
                  *((_QWORD *)v30 - 1) = v31;
                  v30 -= 8;
                }
                while (v28 != v29);
                v28 = (char *)*a3;
              }
              v20 = v27 + 8;
              *a3 = v30;
              a3[1] = v27 + 8;
              a3[2] = &v25[8 * v26];
              if (v28)
                operator delete(v28);
            }
            else
            {
              *v19 = v34;
              v19[1] = v17;
              v20 = v19 + 2;
            }
            a3[1] = v20;
          }
        }
      }
      CLMicroLocationProto::ChannelAndCount::~ChannelAndCount((CLMicroLocationProto::ChannelAndCount *)v32);
      ++v8;
    }
    while (v8 != v9);
  }
  std::__tree<std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>,std::__map_value_compare<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>,std::less<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes>,true>,std::allocator<std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>>>::destroy((uint64_t)&v35, v36[0]);
}

void sub_241A3C404(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14, _QWORD *a15)
{
  uint64_t v15;
  void *v17;

  std::__tree<std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>,std::__map_value_compare<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>,std::less<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes>,true>,std::allocator<std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>>>::destroy((uint64_t)&a14, a15);
  v17 = *(void **)v15;
  if (*(_QWORD *)v15)
  {
    *(_QWORD *)(v15 + 8) = v17;
    operator delete(v17);
  }
  _Unwind_Resume(a1);
}

uint64_t std::pair<std::string const,std::set<unsigned int>>::~pair(uint64_t a1)
{
  std::__tree<std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>,std::__map_value_compare<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>,std::less<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes>,true>,std::allocator<std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>>>::destroy(a1 + 24, *(_QWORD **)(a1 + 32));
  if (*(char *)(a1 + 23) < 0)
    operator delete(*(void **)a1);
  return a1;
}

void ___ZL45_CLLogObjectForCategory_MicroLocation_Defaultv_block_invoke_25()
{
  os_log_t v0;
  void *v1;

  v0 = os_log_create("com.apple.MicroLocation", "MicroLocation");
  v1 = (void *)logObject_MicroLocation_Default;
  logObject_MicroLocation_Default = (uint64_t)v0;

}

uint64_t *std::__hash_table<std::__hash_value_type<unsigned int,unsigned int>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,unsigned int>>>::find<unsigned int>(_QWORD *a1, unsigned int *a2)
{
  int8x8_t v2;
  unint64_t v3;
  uint8x8_t v4;
  unint64_t v5;
  uint64_t **v6;
  uint64_t *result;
  unint64_t v8;

  v2 = (int8x8_t)a1[1];
  if (!*(_QWORD *)&v2)
    return 0;
  v3 = *a2;
  v4 = (uint8x8_t)vcnt_s8(v2);
  v4.i16[0] = vaddlv_u8(v4);
  if (v4.u32[0] > 1uLL)
  {
    v5 = *a2;
    if (*(_QWORD *)&v2 <= v3)
      v5 = v3 % *(_QWORD *)&v2;
  }
  else
  {
    v5 = (v2.i32[0] - 1) & v3;
  }
  v6 = *(uint64_t ***)(*a1 + 8 * v5);
  if (!v6)
    return 0;
  for (result = *v6; result; result = (uint64_t *)*result)
  {
    v8 = result[1];
    if (v8 == v3)
    {
      if (*((_DWORD *)result + 4) == (_DWORD)v3)
        return result;
    }
    else
    {
      if (v4.u32[0] > 1uLL)
      {
        if (v8 >= *(_QWORD *)&v2)
          v8 %= *(_QWORD *)&v2;
      }
      else
      {
        v8 &= *(_QWORD *)&v2 - 1;
      }
      if (v8 != v5)
        return 0;
    }
  }
  return result;
}

_QWORD *std::__hash_table<std::__hash_value_type<unsigned int,unsigned int>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,unsigned int>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>(uint64_t a1, unsigned int *a2, uint64_t a3, _DWORD **a4)
{
  unint64_t v4;
  unint64_t v7;
  unint64_t v8;
  uint8x8_t v9;
  void **v10;
  _QWORD *v11;
  unint64_t v12;
  float v13;
  float v14;
  _BOOL8 v15;
  unint64_t v16;
  unint64_t v17;
  size_t v18;
  uint64_t v19;
  _QWORD *v20;
  unint64_t v21;

  v7 = *a2;
  v8 = *(_QWORD *)(a1 + 8);
  if (v8)
  {
    v9 = (uint8x8_t)vcnt_s8((int8x8_t)v8);
    v9.i16[0] = vaddlv_u8(v9);
    if (v9.u32[0] > 1uLL)
    {
      v4 = *a2;
      if (v8 <= v7)
        v4 = v7 % v8;
    }
    else
    {
      v4 = ((_DWORD)v8 - 1) & v7;
    }
    v10 = *(void ***)(*(_QWORD *)a1 + 8 * v4);
    if (v10)
    {
      v11 = *v10;
      if (*v10)
      {
        do
        {
          v12 = v11[1];
          if (v12 == v7)
          {
            if (*((_DWORD *)v11 + 4) == (_DWORD)v7)
              return v11;
          }
          else
          {
            if (v9.u32[0] > 1uLL)
            {
              if (v12 >= v8)
                v12 %= v8;
            }
            else
            {
              v12 &= v8 - 1;
            }
            if (v12 != v4)
              break;
          }
          v11 = (_QWORD *)*v11;
        }
        while (v11);
      }
    }
  }
  v11 = operator new(0x18uLL);
  *v11 = 0;
  v11[1] = v7;
  *((_DWORD *)v11 + 4) = **a4;
  *((_DWORD *)v11 + 5) = 0;
  v13 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v14 = *(float *)(a1 + 32);
  if (!v8 || (float)(v14 * (float)v8) < v13)
  {
    v15 = 1;
    if (v8 >= 3)
      v15 = (v8 & (v8 - 1)) != 0;
    v16 = v15 | (2 * v8);
    v17 = vcvtps_u32_f32(v13 / v14);
    if (v16 <= v17)
      v18 = v17;
    else
      v18 = v16;
    std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>>>::__rehash<true>(a1, v18);
    v8 = *(_QWORD *)(a1 + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v8 <= v7)
        v4 = v7 % v8;
      else
        v4 = v7;
    }
    else
    {
      v4 = ((_DWORD)v8 - 1) & v7;
    }
  }
  v19 = *(_QWORD *)a1;
  v20 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v4);
  if (v20)
  {
    *v11 = *v20;
LABEL_38:
    *v20 = v11;
    goto LABEL_39;
  }
  *v11 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = v11;
  *(_QWORD *)(v19 + 8 * v4) = a1 + 16;
  if (*v11)
  {
    v21 = *(_QWORD *)(*v11 + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v21 >= v8)
        v21 %= v8;
    }
    else
    {
      v21 &= v8 - 1;
    }
    v20 = (_QWORD *)(*(_QWORD *)a1 + 8 * v21);
    goto LABEL_38;
  }
LABEL_39:
  ++*(_QWORD *)(a1 + 24);
  return v11;
}

void sub_241A3C7B0(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t std::__introsort<std::_ClassicAlgPolicy,BOOL (*&)(CLMicroLocationWiFiChannelHistogram,CLMicroLocationWiFiChannelHistogram),CLMicroLocationWiFiChannelHistogram*,false>(uint64_t result, uint64_t *a2, uint64_t (**a3)(uint64_t, uint64_t), uint64_t a4, char a5)
{
  uint64_t *v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  unint64_t v14;
  uint64_t *v15;
  uint64_t v16;
  uint64_t *v17;
  char v18;
  BOOL v19;
  uint64_t v20;

  v8 = (uint64_t *)result;
LABEL_2:
  v9 = v8;
LABEL_3:
  v10 = 1 - a4;
  while (2)
  {
    v8 = v9;
    v11 = v10;
    v12 = (char *)a2 - (char *)v9;
    v13 = a2 - v9;
    switch(v13)
    {
      case 0uLL:
      case 1uLL:
        return result;
      case 2uLL:
        result = (*a3)(*(a2 - 1), *v9);
        if ((_DWORD)result)
        {
          v20 = *v9;
          *v9 = *(a2 - 1);
          *(a2 - 1) = v20;
        }
        return result;
      case 3uLL:
        return std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(CLMicroLocationWiFiChannelHistogram,CLMicroLocationWiFiChannelHistogram),CLMicroLocationWiFiChannelHistogram*>(v9, v9 + 1, a2 - 1, (unsigned int (**)(_QWORD))a3);
      case 4uLL:
        return std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(CLMicroLocationWiFiChannelHistogram,CLMicroLocationWiFiChannelHistogram),CLMicroLocationWiFiChannelHistogram*>(v9, v9 + 1, v9 + 2, a2 - 1, (unsigned int (**)(_QWORD))a3);
      case 5uLL:
        return std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(CLMicroLocationWiFiChannelHistogram,CLMicroLocationWiFiChannelHistogram),CLMicroLocationWiFiChannelHistogram*>(v9, v9 + 1, v9 + 2, v9 + 3, a2 - 1, (unsigned int (**)(_QWORD))a3);
      default:
        if (v12 <= 191)
        {
          if ((a5 & 1) != 0)
            return std::__insertion_sort[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(CLMicroLocationWiFiChannelHistogram,CLMicroLocationWiFiChannelHistogram),CLMicroLocationWiFiChannelHistogram*>((uint64_t)v9, a2, a3);
          else
            return std::__insertion_sort_unguarded[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(CLMicroLocationWiFiChannelHistogram,CLMicroLocationWiFiChannelHistogram),CLMicroLocationWiFiChannelHistogram*>((uint64_t)v9, a2, a3);
        }
        if (v11 != 1)
        {
          v14 = v13 >> 1;
          v15 = &v9[v13 >> 1];
          if ((unint64_t)v12 < 0x401)
          {
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(CLMicroLocationWiFiChannelHistogram,CLMicroLocationWiFiChannelHistogram),CLMicroLocationWiFiChannelHistogram*>(&v9[v13 >> 1], v9, a2 - 1, (unsigned int (**)(_QWORD))a3);
            if ((a5 & 1) != 0)
              goto LABEL_12;
          }
          else
          {
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(CLMicroLocationWiFiChannelHistogram,CLMicroLocationWiFiChannelHistogram),CLMicroLocationWiFiChannelHistogram*>(v9, &v9[v13 >> 1], a2 - 1, (unsigned int (**)(_QWORD))a3);
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(CLMicroLocationWiFiChannelHistogram,CLMicroLocationWiFiChannelHistogram),CLMicroLocationWiFiChannelHistogram*>(v9 + 1, v15 - 1, a2 - 2, (unsigned int (**)(_QWORD))a3);
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(CLMicroLocationWiFiChannelHistogram,CLMicroLocationWiFiChannelHistogram),CLMicroLocationWiFiChannelHistogram*>(v9 + 2, &v9[v14 + 1], a2 - 3, (unsigned int (**)(_QWORD))a3);
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(CLMicroLocationWiFiChannelHistogram,CLMicroLocationWiFiChannelHistogram),CLMicroLocationWiFiChannelHistogram*>(v15 - 1, v15, &v9[v14 + 1], (unsigned int (**)(_QWORD))a3);
            v16 = *v9;
            *v9 = *v15;
            *v15 = v16;
            if ((a5 & 1) != 0)
              goto LABEL_12;
          }
          if (((*a3)(*(v9 - 1), *v9) & 1) == 0)
          {
            result = (uint64_t)std::__partition_with_equals_on_left[abi:ne180100]<std::_ClassicAlgPolicy,CLMicroLocationWiFiChannelHistogram *,BOOL (*&)(CLMicroLocationWiFiChannelHistogram,CLMicroLocationWiFiChannelHistogram)>(v9, a2, a3);
            v9 = (uint64_t *)result;
            goto LABEL_17;
          }
LABEL_12:
          v17 = std::__partition_with_equals_on_right[abi:ne180100]<std::_ClassicAlgPolicy,CLMicroLocationWiFiChannelHistogram *,BOOL (*&)(CLMicroLocationWiFiChannelHistogram,CLMicroLocationWiFiChannelHistogram)>(v9, a2, a3);
          if ((v18 & 1) == 0)
            goto LABEL_15;
          v19 = std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(CLMicroLocationWiFiChannelHistogram,CLMicroLocationWiFiChannelHistogram),CLMicroLocationWiFiChannelHistogram*>(v9, v17, (unsigned int (**)(_QWORD))a3);
          v9 = v17 + 1;
          result = std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(CLMicroLocationWiFiChannelHistogram,CLMicroLocationWiFiChannelHistogram),CLMicroLocationWiFiChannelHistogram*>(v17 + 1, a2, (unsigned int (**)(_QWORD))a3);
          if (!(_DWORD)result)
          {
            v10 = v11 + 1;
            if (v19)
              continue;
LABEL_15:
            result = std::__introsort<std::_ClassicAlgPolicy,BOOL (*&)(CLMicroLocationWiFiChannelHistogram,CLMicroLocationWiFiChannelHistogram),CLMicroLocationWiFiChannelHistogram*,false>(v8, v17, a3, -v11, a5 & 1);
            v9 = v17 + 1;
LABEL_17:
            a5 = 0;
            a4 = -v11;
            goto LABEL_3;
          }
          a4 = -v11;
          a2 = v17;
          if (v19)
            return result;
          goto LABEL_2;
        }
        if (v9 != a2)
          return (uint64_t)std::__partial_sort_impl[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(CLMicroLocationWiFiChannelHistogram,CLMicroLocationWiFiChannelHistogram),CLMicroLocationWiFiChannelHistogram*,CLMicroLocationWiFiChannelHistogram*>((char *)v9, (char *)a2, a2, a3);
        return result;
    }
  }
}

uint64_t std::__insertion_sort[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(CLMicroLocationWiFiChannelHistogram,CLMicroLocationWiFiChannelHistogram),CLMicroLocationWiFiChannelHistogram*>(uint64_t result, uint64_t *a2, uint64_t (**a3)(uint64_t, uint64_t))
{
  _QWORD *v4;
  uint64_t *v5;
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD *v13;

  if ((uint64_t *)result != a2)
  {
    v4 = (_QWORD *)result;
    v5 = (uint64_t *)(result + 8);
    if ((uint64_t *)(result + 8) != a2)
    {
      v7 = 0;
      v8 = (uint64_t *)result;
      do
      {
        v10 = *v8;
        v9 = v8[1];
        v8 = v5;
        result = (*a3)(v9, v10);
        if ((_DWORD)result)
        {
          v11 = *v8;
          v12 = v7;
          while (1)
          {
            *(_QWORD *)((char *)v4 + v12 + 8) = *(_QWORD *)((char *)v4 + v12);
            if (!v12)
              break;
            result = (*a3)(v11, *(_QWORD *)((char *)v4 + v12 - 8));
            v12 -= 8;
            if ((result & 1) == 0)
            {
              v13 = (_QWORD *)((char *)v4 + v12 + 8);
              goto LABEL_10;
            }
          }
          v13 = v4;
LABEL_10:
          *v13 = v11;
        }
        v5 = v8 + 1;
        v7 += 8;
      }
      while (v8 + 1 != a2);
    }
  }
  return result;
}

uint64_t std::__insertion_sort_unguarded[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(CLMicroLocationWiFiChannelHistogram,CLMicroLocationWiFiChannelHistogram),CLMicroLocationWiFiChannelHistogram*>(uint64_t result, _QWORD *a2, uint64_t (**a3)(uint64_t, uint64_t))
{
  _QWORD *v4;
  _QWORD *i;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  _QWORD *v11;
  uint64_t v12;

  if ((_QWORD *)result != a2)
  {
    v4 = (_QWORD *)result;
    for (i = (_QWORD *)(result + 8); v4 + 1 != a2; i = v4 + 1)
    {
      v8 = *v4;
      v7 = v4[1];
      v4 = i;
      result = (*a3)(v7, v8);
      if ((_DWORD)result)
      {
        v9 = *v4;
        v10 = v4;
        do
        {
          v11 = v10;
          v12 = *--v10;
          *v11 = v12;
          result = (*a3)(v9, *(v11 - 2));
        }
        while ((result & 1) != 0);
        *v10 = v9;
      }
    }
  }
  return result;
}

uint64_t std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(CLMicroLocationWiFiChannelHistogram,CLMicroLocationWiFiChannelHistogram),CLMicroLocationWiFiChannelHistogram*>(_QWORD *a1, _QWORD *a2, _QWORD *a3, unsigned int (**a4)(_QWORD))
{
  char v8;
  uint64_t result;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  v8 = ((uint64_t (*)(_QWORD, _QWORD))*a4)(*a2, *a1);
  result = ((uint64_t (*)(_QWORD, _QWORD))*a4)(*a3, *a2);
  if ((v8 & 1) == 0)
  {
    if (!(_DWORD)result)
      return result;
    v11 = *a2;
    *a2 = *a3;
    *a3 = v11;
    if (!((unsigned int (*)(_QWORD, _QWORD))*a4)(*a2, *a1))
      return 1;
    v12 = *a1;
    *a1 = *a2;
    *a2 = v12;
    return 2;
  }
  v10 = *a1;
  if (!(_DWORD)result)
  {
    *a1 = *a2;
    *a2 = v10;
    if (!(*a4)(*a3))
      return 1;
    v13 = *a2;
    *a2 = *a3;
    *a3 = v13;
    return 2;
  }
  *a1 = *a3;
  *a3 = v10;
  return 1;
}

uint64_t *std::__partition_with_equals_on_left[abi:ne180100]<std::_ClassicAlgPolicy,CLMicroLocationWiFiChannelHistogram *,BOOL (*&)(CLMicroLocationWiFiChannelHistogram,CLMicroLocationWiFiChannelHistogram)>(uint64_t *a1, uint64_t *a2, uint64_t (**a3)(uint64_t, uint64_t))
{
  uint64_t *v4;
  uint64_t v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  v4 = a2;
  v6 = *a1;
  if (((*a3)(*a1, *(a2 - 1)) & 1) != 0)
  {
    v7 = a1;
    do
    {
      v8 = v7[1];
      ++v7;
    }
    while (((*a3)(v6, v8) & 1) == 0);
  }
  else
  {
    v9 = a1 + 1;
    do
    {
      v7 = v9;
      if (v9 >= v4)
        break;
      ++v9;
    }
    while (!(*a3)(v6, *v7));
  }
  if (v7 < v4)
  {
    do
      v10 = *--v4;
    while (((*a3)(v6, v10) & 1) != 0);
  }
  while (v7 < v4)
  {
    v11 = *v7;
    *v7 = *v4;
    *v4 = v11;
    do
    {
      v12 = v7[1];
      ++v7;
    }
    while (!(*a3)(v6, v12));
    do
      v13 = *--v4;
    while (((*a3)(v6, v13) & 1) != 0);
  }
  if (v7 - 1 != a1)
    *a1 = *(v7 - 1);
  *(v7 - 1) = v6;
  return v7;
}

uint64_t *std::__partition_with_equals_on_right[abi:ne180100]<std::_ClassicAlgPolicy,CLMicroLocationWiFiChannelHistogram *,BOOL (*&)(CLMicroLocationWiFiChannelHistogram,CLMicroLocationWiFiChannelHistogram)>(uint64_t *a1, uint64_t *a2, uint64_t (**a3)(uint64_t, uint64_t))
{
  uint64_t v6;
  uint64_t v7;
  char v8;
  uint64_t *v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t *v13;
  uint64_t *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  v6 = 0;
  v7 = *a1;
  do
    v8 = (*a3)(a1[++v6], v7);
  while ((v8 & 1) != 0);
  v9 = &a1[v6];
  v10 = &a1[v6 - 1];
  if (v6 == 1)
  {
    do
    {
      if (v9 >= a2)
        break;
      v12 = *--a2;
    }
    while (((*a3)(v12, v7) & 1) == 0);
  }
  else
  {
    do
      v11 = *--a2;
    while (!(*a3)(v11, v7));
  }
  if (v9 < a2)
  {
    v13 = &a1[v6];
    v14 = a2;
    do
    {
      v15 = *v13;
      *v13 = *v14;
      *v14 = v15;
      do
      {
        v16 = v13[1];
        ++v13;
      }
      while (((*a3)(v16, v7) & 1) != 0);
      do
        v17 = *--v14;
      while (!(*a3)(v17, v7));
    }
    while (v13 < v14);
    v10 = v13 - 1;
  }
  if (v10 != a1)
    *a1 = *v10;
  *v10 = v7;
  return v10;
}

BOOL std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(CLMicroLocationWiFiChannelHistogram,CLMicroLocationWiFiChannelHistogram),CLMicroLocationWiFiChannelHistogram*>(_QWORD *a1, _QWORD *a2, unsigned int (**a3)(_QWORD))
{
  uint64_t v6;
  _BOOL8 result;
  uint64_t v8;
  _QWORD *v9;
  _QWORD *v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  _QWORD *v16;

  v6 = a2 - a1;
  result = 1;
  switch(v6)
  {
    case 0:
    case 1:
      return result;
    case 2:
      if (((unsigned int (*)(_QWORD, _QWORD))*a3)(*(a2 - 1), *a1))
      {
        v8 = *a1;
        *a1 = *(a2 - 1);
        *(a2 - 1) = v8;
      }
      return 1;
    case 3:
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(CLMicroLocationWiFiChannelHistogram,CLMicroLocationWiFiChannelHistogram),CLMicroLocationWiFiChannelHistogram*>(a1, a1 + 1, a2 - 1, a3);
      return 1;
    case 4:
      std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(CLMicroLocationWiFiChannelHistogram,CLMicroLocationWiFiChannelHistogram),CLMicroLocationWiFiChannelHistogram*>(a1, a1 + 1, a1 + 2, a2 - 1, a3);
      return 1;
    case 5:
      std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(CLMicroLocationWiFiChannelHistogram,CLMicroLocationWiFiChannelHistogram),CLMicroLocationWiFiChannelHistogram*>(a1, a1 + 1, a1 + 2, a1 + 3, a2 - 1, a3);
      return 1;
    default:
      v9 = a1 + 2;
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(CLMicroLocationWiFiChannelHistogram,CLMicroLocationWiFiChannelHistogram),CLMicroLocationWiFiChannelHistogram*>(a1, a1 + 1, a1 + 2, a3);
      v10 = a1 + 3;
      if (a1 + 3 == a2)
        return 1;
      v11 = 0;
      v12 = 0;
      break;
  }
  while (1)
  {
    if (((unsigned int (*)(_QWORD, _QWORD))*a3)(*v10, *v9))
    {
      v13 = *v10;
      v14 = v11;
      while (1)
      {
        v15 = (char *)a1 + v14;
        *(_QWORD *)((char *)a1 + v14 + 24) = *(_QWORD *)((char *)a1 + v14 + 16);
        if (v14 == -16)
          break;
        v14 -= 8;
        if ((((uint64_t (*)(uint64_t, _QWORD))*a3)(v13, *((_QWORD *)v15 + 1)) & 1) == 0)
        {
          v16 = (_QWORD *)((char *)a1 + v14 + 24);
          goto LABEL_12;
        }
      }
      v16 = a1;
LABEL_12:
      *v16 = v13;
      if (++v12 == 8)
        return v10 + 1 == a2;
    }
    v9 = v10;
    v11 += 8;
    if (++v10 == a2)
      return 1;
  }
}

uint64_t std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(CLMicroLocationWiFiChannelHistogram,CLMicroLocationWiFiChannelHistogram),CLMicroLocationWiFiChannelHistogram*>(_QWORD *a1, _QWORD *a2, _QWORD *a3, _QWORD *a4, unsigned int (**a5)(_QWORD))
{
  uint64_t result;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(CLMicroLocationWiFiChannelHistogram,CLMicroLocationWiFiChannelHistogram),CLMicroLocationWiFiChannelHistogram*>(a1, a2, a3, a5);
  result = ((uint64_t (*)(_QWORD, _QWORD))*a5)(*a4, *a3);
  if ((_DWORD)result)
  {
    v11 = *a3;
    *a3 = *a4;
    *a4 = v11;
    result = ((uint64_t (*)(_QWORD, _QWORD))*a5)(*a3, *a2);
    if ((_DWORD)result)
    {
      v12 = *a2;
      *a2 = *a3;
      *a3 = v12;
      result = ((uint64_t (*)(_QWORD, _QWORD))*a5)(*a2, *a1);
      if ((_DWORD)result)
      {
        v13 = *a1;
        *a1 = *a2;
        *a2 = v13;
      }
    }
  }
  return result;
}

uint64_t std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(CLMicroLocationWiFiChannelHistogram,CLMicroLocationWiFiChannelHistogram),CLMicroLocationWiFiChannelHistogram*>(_QWORD *a1, _QWORD *a2, _QWORD *a3, _QWORD *a4, _QWORD *a5, unsigned int (**a6)(_QWORD))
{
  uint64_t result;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;

  std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(CLMicroLocationWiFiChannelHistogram,CLMicroLocationWiFiChannelHistogram),CLMicroLocationWiFiChannelHistogram*>(a1, a2, a3, a4, a6);
  result = ((uint64_t (*)(_QWORD, _QWORD))*a6)(*a5, *a4);
  if ((_DWORD)result)
  {
    v13 = *a4;
    *a4 = *a5;
    *a5 = v13;
    result = ((uint64_t (*)(_QWORD, _QWORD))*a6)(*a4, *a3);
    if ((_DWORD)result)
    {
      v14 = *a3;
      *a3 = *a4;
      *a4 = v14;
      result = ((uint64_t (*)(_QWORD, _QWORD))*a6)(*a3, *a2);
      if ((_DWORD)result)
      {
        v15 = *a2;
        *a2 = *a3;
        *a3 = v15;
        result = ((uint64_t (*)(_QWORD, _QWORD))*a6)(*a2, *a1);
        if ((_DWORD)result)
        {
          v16 = *a1;
          *a1 = *a2;
          *a2 = v16;
        }
      }
    }
  }
  return result;
}

uint64_t *std::__partial_sort_impl[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(CLMicroLocationWiFiChannelHistogram,CLMicroLocationWiFiChannelHistogram),CLMicroLocationWiFiChannelHistogram*,CLMicroLocationWiFiChannelHistogram*>(char *a1, char *a2, uint64_t *a3, uint64_t (**a4)(uint64_t, uint64_t))
{
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  char *v12;
  char *v13;
  uint64_t *v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  uint64_t v18;
  char *v19;

  if (a1 != a2)
  {
    v8 = a2 - a1;
    v9 = (a2 - a1) >> 3;
    if (a2 - a1 >= 9)
    {
      v10 = (unint64_t)(v9 - 2) >> 1;
      v11 = v10 + 1;
      v12 = &a1[8 * v10];
      do
      {
        std::__sift_down[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(CLMicroLocationWiFiChannelHistogram,CLMicroLocationWiFiChannelHistogram),CLMicroLocationWiFiChannelHistogram*>((uint64_t)a1, (unsigned int (**)(_QWORD, _QWORD))a4, v9, v12);
        v12 -= 8;
        --v11;
      }
      while (v11);
    }
    v13 = a2;
    if (a2 != (char *)a3)
    {
      v14 = (uint64_t *)a2;
      do
      {
        if ((*a4)(*v14, *(_QWORD *)a1))
        {
          v15 = *v14;
          *v14 = *(_QWORD *)a1;
          *(_QWORD *)a1 = v15;
          std::__sift_down[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(CLMicroLocationWiFiChannelHistogram,CLMicroLocationWiFiChannelHistogram),CLMicroLocationWiFiChannelHistogram*>((uint64_t)a1, (unsigned int (**)(_QWORD, _QWORD))a4, v9, a1);
        }
        ++v14;
      }
      while (v14 != a3);
      v13 = (char *)a3;
    }
    if (v8 >= 9)
    {
      v16 = (unint64_t)v8 >> 3;
      v17 = a2 - 8;
      do
      {
        v18 = *(_QWORD *)a1;
        v19 = (char *)std::__floyd_sift_down[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(CLMicroLocationWiFiChannelHistogram,CLMicroLocationWiFiChannelHistogram),CLMicroLocationWiFiChannelHistogram*>(a1, (unsigned int (**)(_QWORD, _QWORD))a4, v16);
        if (v17 == v19)
        {
          *(_QWORD *)v19 = v18;
        }
        else
        {
          *(_QWORD *)v19 = *(_QWORD *)v17;
          *(_QWORD *)v17 = v18;
          std::__sift_up[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(CLMicroLocationWiFiChannelHistogram,CLMicroLocationWiFiChannelHistogram),CLMicroLocationWiFiChannelHistogram*>((uint64_t)a1, (uint64_t)(v19 + 8), a4, (v19 + 8 - a1) >> 3);
        }
        v17 -= 8;
      }
      while (v16-- > 2);
    }
    return (uint64_t *)v13;
  }
  return a3;
}

uint64_t std::__sift_down[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(CLMicroLocationWiFiChannelHistogram,CLMicroLocationWiFiChannelHistogram),CLMicroLocationWiFiChannelHistogram*>(uint64_t result, unsigned int (**a2)(_QWORD, _QWORD), uint64_t a3, _QWORD *a4)
{
  unint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  int64_t v7;
  uint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD *v15;
  uint64_t v16;

  v4 = a3 - 2;
  if (a3 >= 2)
  {
    v5 = a4;
    v6 = result;
    v7 = v4 >> 1;
    if ((uint64_t)(v4 >> 1) >= ((uint64_t)a4 - result) >> 3)
    {
      v10 = ((uint64_t)a4 - result) >> 2;
      v11 = v10 + 1;
      v12 = (_QWORD *)(result + 8 * (v10 + 1));
      v13 = v10 + 2;
      if (v10 + 2 < a3 && (*a2)(*v12, v12[1]))
      {
        ++v12;
        v11 = v13;
      }
      result = ((uint64_t (*)(_QWORD, _QWORD))*a2)(*v12, *v5);
      if ((result & 1) == 0)
      {
        v14 = *v5;
        do
        {
          v15 = v12;
          *v5 = *v12;
          if (v7 < v11)
            break;
          v16 = (2 * v11) | 1;
          v12 = (_QWORD *)(v6 + 8 * v16);
          if (2 * v11 + 2 < a3)
          {
            if ((*a2)(*v12, v12[1]))
            {
              ++v12;
              v16 = 2 * v11 + 2;
            }
          }
          result = ((uint64_t (*)(_QWORD, uint64_t))*a2)(*v12, v14);
          v5 = v15;
          v11 = v16;
        }
        while (!(_DWORD)result);
        *v15 = v14;
      }
    }
  }
  return result;
}

_QWORD *std::__floyd_sift_down[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(CLMicroLocationWiFiChannelHistogram,CLMicroLocationWiFiChannelHistogram),CLMicroLocationWiFiChannelHistogram*>(_QWORD *a1, unsigned int (**a2)(_QWORD, _QWORD), uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;

  v6 = 0;
  v7 = a3 - 2;
  if (a3 < 2)
    v7 = a3 - 1;
  v8 = v7 >> 1;
  do
  {
    v9 = &a1[v6 + 1];
    v10 = (2 * v6) | 1;
    v11 = 2 * v6 + 2;
    if (v11 < a3 && (*a2)(a1[v6 + 1], a1[v6 + 2]))
    {
      ++v9;
      v10 = v11;
    }
    *a1 = *v9;
    a1 = v9;
    v6 = v10;
  }
  while (v10 <= v8);
  return v9;
}

uint64_t std::__sift_up[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(CLMicroLocationWiFiChannelHistogram,CLMicroLocationWiFiChannelHistogram),CLMicroLocationWiFiChannelHistogram*>(uint64_t result, uint64_t a2, uint64_t (**a3)(uint64_t, uint64_t), uint64_t a4)
{
  unint64_t v4;
  uint64_t v6;
  unint64_t v7;
  uint64_t *v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t *v11;

  v4 = a4 - 2;
  if (a4 >= 2)
  {
    v6 = result;
    v7 = v4 >> 1;
    v8 = (uint64_t *)(result + 8 * (v4 >> 1));
    v9 = (uint64_t *)(a2 - 8);
    result = (*a3)(*v8, *(_QWORD *)(a2 - 8));
    if ((_DWORD)result)
    {
      v10 = *v9;
      do
      {
        v11 = v8;
        *v9 = *v8;
        if (!v7)
          break;
        v7 = (v7 - 1) >> 1;
        v8 = (uint64_t *)(v6 + 8 * v7);
        result = (*a3)(*v8, v10);
        v9 = v11;
      }
      while ((result & 1) != 0);
      *v11 = v10;
    }
  }
  return result;
}

uint64_t std::unordered_map<std::string,std::set<unsigned int>>::unordered_map(uint64_t a1, unsigned __int8 *a2, uint64_t a3)
{
  uint64_t v5;

  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 32) = 1065353216;
  if (a3)
  {
    v5 = 48 * a3;
    do
    {
      std::__hash_table<std::__hash_value_type<std::string,std::set<unsigned int>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::set<unsigned int>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::set<unsigned int>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::set<unsigned int>>>>::__emplace_unique_key_args<std::string,std::pair<std::string const,std::set<unsigned int>> const&>(a1, a2, (__int128 *)a2);
      a2 += 48;
      v5 -= 48;
    }
    while (v5);
  }
  return a1;
}

void sub_241A3D6B4(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::__hash_table<std::__hash_value_type<std::string,std::set<unsigned int>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::set<unsigned int>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::set<unsigned int>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::set<unsigned int>>>>::~__hash_table(v1);
  _Unwind_Resume(a1);
}

unsigned __int8 *std::__hash_table<std::__hash_value_type<std::string,std::set<unsigned int>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::set<unsigned int>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::set<unsigned int>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::set<unsigned int>>>>::__emplace_unique_key_args<std::string,std::pair<std::string const,std::set<unsigned int>> const&>(uint64_t a1, unsigned __int8 *a2, __int128 *a3)
{
  unint64_t v3;
  _QWORD *v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  uint8x8_t v11;
  unint64_t v12;
  unsigned __int8 **v13;
  unsigned __int8 *i;
  unint64_t v15;
  float v16;
  float v17;
  _BOOL8 v18;
  unint64_t v19;
  unint64_t v20;
  size_t v21;
  _QWORD *v22;
  unint64_t v23;
  _QWORD v25[3];

  v7 = (_QWORD *)(a1 + 24);
  v8 = std::__string_hash<char>::operator()[abi:ne180100](a1 + 24, (uint64_t)a2);
  v9 = v8;
  v10 = *(_QWORD *)(a1 + 8);
  if (v10)
  {
    v11 = (uint8x8_t)vcnt_s8((int8x8_t)v10);
    v11.i16[0] = vaddlv_u8(v11);
    v12 = v11.u32[0];
    if (v11.u32[0] > 1uLL)
    {
      v3 = v8;
      if (v8 >= v10)
        v3 = v8 % v10;
    }
    else
    {
      v3 = (v10 - 1) & v8;
    }
    v13 = *(unsigned __int8 ***)(*(_QWORD *)a1 + 8 * v3);
    if (v13)
    {
      for (i = *v13; i; i = *(unsigned __int8 **)i)
      {
        v15 = *((_QWORD *)i + 1);
        if (v15 == v9)
        {
          if ((std::equal_to<std::string>::operator()[abi:ne180100](a1 + 32, i + 16, a2) & 1) != 0)
            return i;
        }
        else
        {
          if (v12 > 1)
          {
            if (v15 >= v10)
              v15 %= v10;
          }
          else
          {
            v15 &= v10 - 1;
          }
          if (v15 != v3)
            break;
        }
      }
    }
  }
  std::__hash_table<std::__hash_value_type<std::string,std::set<unsigned int>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::set<unsigned int>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::set<unsigned int>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::set<unsigned int>>>>::__construct_node_hash<std::pair<std::string const,std::set<unsigned int>> const&>(a1, v9, a3, (uint64_t)v25);
  v16 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v17 = *(float *)(a1 + 32);
  if (!v10 || (float)(v17 * (float)v10) < v16)
  {
    v18 = 1;
    if (v10 >= 3)
      v18 = (v10 & (v10 - 1)) != 0;
    v19 = v18 | (2 * v10);
    v20 = vcvtps_u32_f32(v16 / v17);
    if (v19 <= v20)
      v21 = v20;
    else
      v21 = v19;
    std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationAnchorAppearance>>>::__rehash<true>(a1, v21);
    v10 = *(_QWORD *)(a1 + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v9 >= v10)
        v3 = v9 % v10;
      else
        v3 = v9;
    }
    else
    {
      v3 = (v10 - 1) & v9;
    }
  }
  v22 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v3);
  if (v22)
  {
    *(_QWORD *)v25[0] = *v22;
    *v22 = v25[0];
  }
  else
  {
    *(_QWORD *)v25[0] = *(_QWORD *)(a1 + 16);
    *(_QWORD *)(a1 + 16) = v25[0];
    *(_QWORD *)(*(_QWORD *)a1 + 8 * v3) = a1 + 16;
    if (*(_QWORD *)v25[0])
    {
      v23 = *(_QWORD *)(*(_QWORD *)v25[0] + 8);
      if ((v10 & (v10 - 1)) != 0)
      {
        if (v23 >= v10)
          v23 %= v10;
      }
      else
      {
        v23 &= v10 - 1;
      }
      *(_QWORD *)(*(_QWORD *)a1 + 8 * v23) = v25[0];
    }
  }
  i = (unsigned __int8 *)v25[0];
  v25[0] = 0;
  ++*v7;
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::set<unsigned int>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::set<unsigned int>>,void *>>>>::reset[abi:ne180100]((uint64_t)v25, 0);
  return i;
}

void sub_241A3D930(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::set<unsigned int>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::set<unsigned int>>,void *>>>>::reset[abi:ne180100]((uint64_t)va, 0);
  _Unwind_Resume(a1);
}

std::string *std::__hash_table<std::__hash_value_type<std::string,std::set<unsigned int>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::set<unsigned int>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::set<unsigned int>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::set<unsigned int>>>>::__construct_node_hash<std::pair<std::string const,std::set<unsigned int>> const&>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, __int128 *a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v7;
  char *v8;
  std::string *result;

  v7 = a1 + 16;
  v8 = (char *)operator new(0x40uLL);
  *(_QWORD *)a4 = v8;
  *(_QWORD *)(a4 + 8) = v7;
  *(_BYTE *)(a4 + 16) = 0;
  *(_QWORD *)v8 = 0;
  *((_QWORD *)v8 + 1) = a2;
  result = std::pair<std::string const,std::set<unsigned int>>::pair[abi:ne180100]((std::string *)(v8 + 16), a3);
  *(_BYTE *)(a4 + 16) = 1;
  return result;
}

void sub_241A3D9A4(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::set<unsigned int>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::set<unsigned int>>,void *>>>>::reset[abi:ne180100](v1, 0);
  _Unwind_Resume(a1);
}

std::string *std::pair<std::string const,std::set<unsigned int>>::pair[abi:ne180100](std::string *this, __int128 *a2)
{
  __int128 v4;

  if (*((char *)a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(this, *(const std::string::value_type **)a2, *((_QWORD *)a2 + 1));
  }
  else
  {
    v4 = *a2;
    this->__r_.__value_.__r.__words[2] = *((_QWORD *)a2 + 2);
    *(_OWORD *)&this->__r_.__value_.__l.__data_ = v4;
  }
  std::set<unsigned int>::set[abi:ne180100]((uint64_t *)&this[1], (uint64_t)a2 + 24);
  return this;
}

void sub_241A3DA14(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (*(char *)(v1 + 23) < 0)
    operator delete(*(void **)v1);
  _Unwind_Resume(exception_object);
}

void std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::set<unsigned int>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::set<unsigned int>>,void *>>>>::reset[abi:ne180100](uint64_t a1, uint64_t a2)
{
  void *v2;

  v2 = *(void **)a1;
  *(_QWORD *)a1 = a2;
  if (v2)
  {
    if (*(_BYTE *)(a1 + 16))
      std::__destroy_at[abi:ne180100]<std::pair<std::string const,std::set<unsigned int>>,0>((uint64_t)v2 + 16);
    operator delete(v2);
  }
}

void std::__destroy_at[abi:ne180100]<std::pair<std::string const,std::set<unsigned int>>,0>(uint64_t a1)
{
  std::__tree<std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>,std::__map_value_compare<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>,std::less<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes>,true>,std::allocator<std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>>>::destroy(a1 + 24, *(_QWORD **)(a1 + 32));
  if (*(char *)(a1 + 23) < 0)
    operator delete(*(void **)a1);
}

uint64_t std::__hash_table<std::__hash_value_type<std::string,std::set<unsigned int>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::set<unsigned int>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::set<unsigned int>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::set<unsigned int>>>>::~__hash_table(uint64_t a1)
{
  void *v2;

  std::__hash_table<std::__hash_value_type<std::string,std::set<unsigned int>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::set<unsigned int>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::set<unsigned int>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::set<unsigned int>>>>::__deallocate_node(a1, *(_QWORD **)(a1 + 16));
  v2 = *(void **)a1;
  *(_QWORD *)a1 = 0;
  if (v2)
    operator delete(v2);
  return a1;
}

void std::__hash_table<std::__hash_value_type<std::string,std::set<unsigned int>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::set<unsigned int>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::set<unsigned int>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::set<unsigned int>>>>::__deallocate_node(uint64_t a1, _QWORD *a2)
{
  _QWORD *v2;
  _QWORD *v3;

  if (a2)
  {
    v2 = a2;
    do
    {
      v3 = (_QWORD *)*v2;
      std::__destroy_at[abi:ne180100]<std::pair<std::string const,std::set<unsigned int>>,0>((uint64_t)(v2 + 2));
      operator delete(v2);
      v2 = v3;
    }
    while (v3);
  }
}

unsigned __int8 *std::__hash_table<std::__hash_value_type<std::string,std::set<unsigned int>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::set<unsigned int>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::set<unsigned int>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::set<unsigned int>>>>::find<std::string>(_QWORD *a1, unsigned __int8 *a2)
{
  unint64_t v4;
  int8x8_t v5;
  unint64_t v6;
  uint8x8_t v7;
  unint64_t v8;
  unint64_t v9;
  unsigned __int8 **v10;
  unsigned __int8 *v11;
  uint64_t v12;
  unint64_t v13;

  v4 = std::__string_hash<char>::operator()[abi:ne180100]((uint64_t)(a1 + 3), (uint64_t)a2);
  v5 = (int8x8_t)a1[1];
  if (!*(_QWORD *)&v5)
    return 0;
  v6 = v4;
  v7 = (uint8x8_t)vcnt_s8(v5);
  v7.i16[0] = vaddlv_u8(v7);
  v8 = v7.u32[0];
  if (v7.u32[0] > 1uLL)
  {
    v9 = v4;
    if (v4 >= *(_QWORD *)&v5)
      v9 = v4 % *(_QWORD *)&v5;
  }
  else
  {
    v9 = (*(_QWORD *)&v5 - 1) & v4;
  }
  v10 = *(unsigned __int8 ***)(*a1 + 8 * v9);
  if (!v10)
    return 0;
  v11 = *v10;
  if (*v10)
  {
    v12 = (uint64_t)(a1 + 4);
    do
    {
      v13 = *((_QWORD *)v11 + 1);
      if (v6 == v13)
      {
        if ((std::equal_to<std::string>::operator()[abi:ne180100](v12, v11 + 16, a2) & 1) != 0)
          return v11;
      }
      else
      {
        if (v8 > 1)
        {
          if (v13 >= *(_QWORD *)&v5)
            v13 %= *(_QWORD *)&v5;
        }
        else
        {
          v13 &= *(_QWORD *)&v5 - 1;
        }
        if (v13 != v9)
          return 0;
      }
      v11 = *(unsigned __int8 **)v11;
    }
    while (v11);
  }
  return v11;
}

uint64_t *std::set<unsigned int>::set[abi:ne180100](uint64_t *a1, uint64_t a2)
{
  a1[2] = 0;
  a1[1] = 0;
  *a1 = (uint64_t)(a1 + 1);
  std::set<unsigned int>::insert[abi:ne180100]<std::__tree_const_iterator<unsigned int,std::__tree_node<unsigned int,void *> *,long>>(a1, *(unsigned int **)a2, (unsigned int *)(a2 + 8));
  return a1;
}

void sub_241A3DC64(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::__tree<std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>,std::__map_value_compare<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>,std::less<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes>,true>,std::allocator<std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>>>::destroy(v1, *(_QWORD **)(v1 + 8));
  _Unwind_Resume(a1);
}

uint64_t *std::set<unsigned int>::insert[abi:ne180100]<std::__tree_const_iterator<unsigned int,std::__tree_node<unsigned int,void *> *,long>>(uint64_t *result, unsigned int *a2, unsigned int *a3)
{
  unsigned int *v4;
  uint64_t **v5;
  uint64_t *v6;
  unsigned int *v7;
  unsigned int *v8;
  BOOL v9;

  if (a2 != a3)
  {
    v4 = a2;
    v5 = (uint64_t **)result;
    v6 = result + 1;
    do
    {
      result = std::__tree<unsigned int>::__emplace_hint_unique_key_args<unsigned int,unsigned int const&>(v5, v6, v4 + 7, v4 + 7);
      v7 = (unsigned int *)*((_QWORD *)v4 + 1);
      if (v7)
      {
        do
        {
          v8 = v7;
          v7 = *(unsigned int **)v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          v8 = (unsigned int *)*((_QWORD *)v4 + 2);
          v9 = *(_QWORD *)v8 == (_QWORD)v4;
          v4 = v8;
        }
        while (!v9);
      }
      v4 = v8;
    }
    while (v8 != a3);
  }
  return result;
}

void sub_241A3E300(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_241A3EAC4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  uint64_t v10;
  va_list va;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  va_list va1;

  va_start(va1, a9);
  va_start(va, a9);
  v10 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__6(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__6(uint64_t a1)
{

}

uint64_t CLMicroLocationRapportTable::Entry::Entry(uint64_t a1, __int128 *a2, CLMicroLocationProto::RapportDevice *a3, _OWORD *a4, _QWORD *a5)
{
  __int128 v7;

  *(_QWORD *)a1 = *a5;
  v7 = *a2;
  *(_QWORD *)(a1 + 24) = *((_QWORD *)a2 + 2);
  *(_OWORD *)(a1 + 8) = v7;
  *((_QWORD *)a2 + 1) = 0;
  *((_QWORD *)a2 + 2) = 0;
  *(_QWORD *)a2 = 0;
  CLMicroLocationProto::RapportDevice::RapportDevice((CLMicroLocationProto::RapportDevice *)(a1 + 32), a3);
  *(_OWORD *)(a1 + 64) = *a4;
  return a1;
}

void sub_241A3EE58(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void **v2;

  if (*(char *)(v1 + 31) < 0)
    operator delete(*v2);
  _Unwind_Resume(exception_object);
}

uint64_t ULSettings::get<ULSettings::LogOdometryAnalyticsEnabled>()
{
  void *v0;
  void *v1;
  void *v2;
  void *v3;
  uint64_t v4;
  uint64_t v5;

  +[ULDefaultsSingleton shared](ULDefaultsSingleton, "shared");
  v0 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v0, "defaultsDictionary");
  v1 = (void *)objc_claimAutoreleasedReturnValue();

  objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "ULLogOdometryAnalyticsEnabled");
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v1, "objectForKey:", v2);
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  if (v3 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
    v4 = objc_msgSend(v3, "BOOLValue");
  else
    v4 = objc_msgSend(MEMORY[0x24BDBD1C8], "BOOLValue");
  v5 = v4;

  return v5;
}

void sub_241A3EFCC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_241A3F0B8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_241A3F170(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_241A3F2B4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  void *v9;
  void *v10;

  v10 = v9;
  a9.receiver = v10;
  a9.super_class = (Class)ULHomeSlamAnalytics;
  -[_Unwind_Exception dealloc](&a9, sel_dealloc);
  _Unwind_Resume(a1);
}

void sub_241A3F434(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  void *v11;

  if (__p)
    operator delete(__p);

  _Unwind_Resume(a1);
}

void sub_241A3F54C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
  void *v14;
  void *v15;
  void *v16;
  id *v17;
  void *v18;
  id *v19;

  v19 = v17;
  objc_destroyWeak(v19);

  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_241A3F5F0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

void sub_241A3F65C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

void sub_241A3F7C8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_241A3F9EC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void ___ZL45_CLLogObjectForCategory_MicroLocation_Defaultv_block_invoke_26()
{
  os_log_t v0;
  void *v1;

  v0 = os_log_create("com.apple.MicroLocation", "MicroLocation");
  v1 = (void *)logObject_MicroLocation_Default;
  logObject_MicroLocation_Default = (uint64_t)v0;

}

uint64_t CLMiLoLoiTable::Entry::Entry(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, __int128 *a6, double a7)
{
  std::string *v8;
  __int128 v9;

  *(double *)a1 = a7;
  *(_QWORD *)(a1 + 8) = a2;
  *(_QWORD *)(a1 + 16) = a3;
  *(_QWORD *)(a1 + 24) = a4;
  *(_QWORD *)(a1 + 32) = a5;
  v8 = (std::string *)(a1 + 40);
  if (*((char *)a6 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v8, *(const std::string::value_type **)a6, *((_QWORD *)a6 + 1));
  }
  else
  {
    v9 = *a6;
    v8->__r_.__value_.__r.__words[2] = *((_QWORD *)a6 + 2);
    *(_OWORD *)&v8->__r_.__value_.__l.__data_ = v9;
  }
  return a1;
}

void sub_241A3FBD8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

uint64_t ULDBUtils::insertEntries<CLMicroLocationConfigurationTable,ULConfigurationMO>(void *a1, uint64_t a2)
{
  id v3;
  void *v4;
  id v5;
  uint64_t v6;
  _QWORD v8[4];
  id v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  char v15;

  v3 = a1;
  v12 = 0;
  v13 = &v12;
  v14 = 0x2020000000;
  v15 = 0;
  objc_msgSend(v3, "managedObjectContext");
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  v8[0] = MEMORY[0x24BDAC760];
  v8[1] = 3221225472;
  v8[2] = ___ZN9ULDBUtils13insertEntriesI33CLMicroLocationConfigurationTable17ULConfigurationMOEEbP7ULStoreRKNSt3__16vectorINT_5EntryENS5_9allocatorIS8_EEEE_block_invoke;
  v8[3] = &unk_2511D22D0;
  v11 = a2;
  v5 = v3;
  v9 = v5;
  v10 = &v12;
  objc_msgSend(v4, "performBlockAndWait:", v8);

  v6 = *((unsigned __int8 *)v13 + 24);
  _Block_object_dispose(&v12, 8);

  return v6;
}

void sub_241A3FCFC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, void *a7, uint64_t a8, uint64_t a9, ...)
{
  void *v9;
  void *v10;
  va_list va;

  va_start(va, a9);

  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void ULDBUtils::fetchEntries<CLMicroLocationConfigurationTable,ULConfigurationMO>(void *a1@<X0>, void *a2@<X1>, void *a3@<X2>, uint64_t a4@<X3>, _QWORD *a5@<X8>)
{
  id v9;
  id v10;
  id v11;
  void *v12;
  id v13;
  id v14;
  id v15;
  uint64_t *v16;
  _QWORD v17[4];
  id v18;
  id v19;
  id v20;
  uint64_t *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t *v24;
  uint64_t v25;
  __n128 (*v26)(__n128 *, __n128 *);
  void (*v27)(uint64_t);
  void *v28;
  _QWORD v29[3];
  void **v30;

  v9 = a1;
  v10 = a2;
  v11 = a3;
  v23 = 0;
  v24 = &v23;
  v25 = 0x4812000000;
  v26 = __Block_byref_object_copy__7;
  v27 = __Block_byref_object_dispose__7;
  v28 = &unk_241BEBD1D;
  memset(v29, 0, sizeof(v29));
  objc_msgSend(v9, "managedObjectContext");
  v12 = (void *)objc_claimAutoreleasedReturnValue();
  v17[0] = MEMORY[0x24BDAC760];
  v17[1] = 3221225472;
  v17[2] = ___ZN9ULDBUtils12fetchEntriesI33CLMicroLocationConfigurationTable17ULConfigurationMOEENSt3__16vectorINT_5EntryENS3_9allocatorIS6_EEEEP7ULStoreP7NSArrayIP11NSPredicateEPSC_IP16NSSortDescriptorEm_block_invoke;
  v17[3] = &unk_2511D22F8;
  v13 = v10;
  v18 = v13;
  v14 = v11;
  v19 = v14;
  v22 = a4;
  v15 = v9;
  v20 = v15;
  v21 = &v23;
  objc_msgSend(v12, "performBlockAndWait:", v17);

  v16 = v24;
  a5[1] = 0;
  a5[2] = 0;
  *a5 = 0;
  std::vector<CLMicroLocationConfigurationTable::Entry>::__init_with_size[abi:ne180100]<CLMicroLocationConfigurationTable::Entry*,CLMicroLocationConfigurationTable::Entry*>(a5, v16[6], v16[7], 0x6DB6DB6DB6DB6DB7 * ((v16[7] - v16[6]) >> 4));

  _Block_object_dispose(&v23, 8);
  v30 = (void **)v29;
  std::vector<CLMicroLocationConfigurationTable::Entry>::__destroy_vector::operator()[abi:ne180100](&v30);

}

void sub_241A3FEC4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, void *a6, void *a7, void *a8, uint64_t a9, uint64_t a10, ...)
{
  void *v10;
  void *v11;
  void *v12;
  uint64_t v13;
  uint64_t v14;
  va_list va;

  va_start(va, a10);

  _Block_object_dispose(va, 8);
  *(_QWORD *)(v14 - 96) = v13;
  std::vector<CLMicroLocationConfigurationTable::Entry>::__destroy_vector::operator()[abi:ne180100]((void ***)(v14 - 96));

  _Unwind_Resume(a1);
}

void ULDBUtils::fetchAllWithLimit<CLMicroLocationConfigurationTable,ULConfigurationMO>(void *a1@<X0>, unsigned int a2@<W1>, _QWORD *a3@<X8>)
{
  id v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;
  _QWORD v10[2];

  v10[1] = *MEMORY[0x24BDAC8D0];
  v5 = a1;
  v6 = (void *)MEMORY[0x24BDD17C0];
  objc_msgSend((id)objc_opt_class(), "defaultSortProperty");
  v7 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v6, "sortDescriptorWithKey:ascending:", v7, 0);
  v8 = (void *)objc_claimAutoreleasedReturnValue();

  v10[0] = v8;
  objc_msgSend(MEMORY[0x24BDBCE30], "arrayWithObjects:count:", v10, 1);
  v9 = (void *)objc_claimAutoreleasedReturnValue();
  ULDBUtils::fetchEntries<CLMicroLocationConfigurationTable,ULConfigurationMO>(v5, 0, v9, a2, a3);

}

void sub_241A40024(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_241A40328(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, void **a16)
{
  void *v16;
  void *v17;

  a16 = (void **)&a13;
  std::vector<CLMicroLocationConfigurationTable::Entry>::__destroy_vector::operator()[abi:ne180100](&a16);

  _Unwind_Resume(a1);
}

void sub_241A4046C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15)
{
  if (a15)
  {
    if (a14 < 0)
      operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_241A40528(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16)
{
  if (a16)
  {
    if (a15 < 0)
      operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_241A406C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, void **a14)
{
  void *v14;
  void *v15;
  void *v16;

  a14 = (void **)&a11;
  std::vector<CLMicroLocationConfigurationTable::Entry>::__destroy_vector::operator()[abi:ne180100](&a14);

  _Unwind_Resume(a1);
}

void sub_241A40840(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, char a19)
{
  _BYTE *v19;

  if (a19)
  {
    if (a18 < 0)
      operator delete(__p);
  }
  -[ULConfigurationStore fetchMostRecentClusterAnchorValueStatisticsForLOIType:].cold.1(v19, (uint64_t)&a9);
  _Unwind_Resume(a1);
}

void sub_241A40910(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16)
{
  if (a16)
  {
    if (a15 < 0)
      operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_241A40A54(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, void *a7, void *a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  void *v11;
  void *v12;
  void *v13;
  va_list va;

  va_start(va, a11);

  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_241A40B60(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_241A40E58(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5, void *a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, void *a13, void *a14, uint64_t a15, uint64_t a16, ...)
{
  void *v16;
  uint64_t v17;
  void *v18;
  uint64_t v19;
  va_list va;

  va_start(va, a16);

  _Block_object_dispose(va, 8);
  *(_QWORD *)(v19 - 112) = v17;
  std::vector<CLMicroLocationConfigurationTable::Entry>::__destroy_vector::operator()[abi:ne180100]((void ***)(v19 - 112));

  _Unwind_Resume(a1);
}

__n128 __Block_byref_object_copy__7(__n128 *a1, __n128 *a2)
{
  __n128 result;

  a1[3].n128_u64[0] = 0;
  a1[3].n128_u64[1] = 0;
  a1[4].n128_u64[0] = 0;
  result = a2[3];
  a1[3] = result;
  a1[4].n128_u64[0] = a2[4].n128_u64[0];
  a2[3].n128_u64[0] = 0;
  a2[3].n128_u64[1] = 0;
  a2[4].n128_u64[0] = 0;
  return result;
}

void __Block_byref_object_dispose__7(uint64_t a1)
{
  void **v1;

  v1 = (void **)(a1 + 48);
  std::vector<CLMicroLocationConfigurationTable::Entry>::__destroy_vector::operator()[abi:ne180100](&v1);
}

void sub_241A41104(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void ULDBUtils::convertManagedObjectsToEntries<CLMicroLocationConfigurationTable,ULConfigurationMO>(void *a1@<X0>, uint64_t *a2@<X8>)
{
  id v3;
  id v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t i;
  id v8;
  void *v9;
  unint64_t v10;
  uint64_t v11;
  NSObject *v12;
  void *v13;
  void *v14;
  NSObject *v15;
  void *v16;
  void *v17;
  uint64_t j;
  uint64_t v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  uint8_t buf[4];
  int v25;
  __int16 v26;
  const char *v27;
  __int16 v28;
  void *v29;
  _OWORD v30[7];
  uint64_t v31;
  _BYTE v32[128];
  uint64_t v33;

  v33 = *MEMORY[0x24BDAC8D0];
  v3 = a1;
  a2[1] = 0;
  a2[2] = 0;
  *a2 = 0;
  std::vector<CLMicroLocationConfigurationTable::Entry>::reserve(a2, objc_msgSend(v3, "count"));
  v22 = 0u;
  v23 = 0u;
  v20 = 0u;
  v21 = 0u;
  v4 = v3;
  v5 = objc_msgSend(v4, "countByEnumeratingWithState:objects:count:", &v20, v32, 16);
  if (v5)
  {
    v6 = *(_QWORD *)v21;
    while (2)
    {
      for (i = 0; i != v5; ++i)
      {
        if (*(_QWORD *)v21 != v6)
          objc_enumerationMutation(v4);
        v8 = *(id *)(*((_QWORD *)&v20 + 1) + 8 * i);
        v9 = v8;
        if (!v8)
        {
          v31 = 0;
          memset(v30, 0, sizeof(v30));
LABEL_16:
          if (onceToken_MicroLocation_Default != -1)
            dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_34);
          v12 = (id)logObject_MicroLocation_Default;
          if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
          {
            objc_msgSend(v9, "entity");
            v13 = (void *)objc_claimAutoreleasedReturnValue();
            objc_msgSend(v13, "name");
            v14 = (void *)objc_claimAutoreleasedReturnValue();
            *(_DWORD *)buf = 68289283;
            v25 = 0;
            v26 = 2082;
            v27 = "";
            v28 = 2113;
            v29 = v14;
            _os_log_impl(&dword_2419D9000, v12, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"Failed to convert MO to entry\", \"MO\":%{private, location:escape_only}@}", buf, 0x1Cu);

          }
          if (onceToken_MicroLocation_Default != -1)
            dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_34);
          v15 = (id)logObject_MicroLocation_Default;
          if (os_signpost_enabled(v15))
          {
            objc_msgSend(v9, "entity");
            v16 = (void *)objc_claimAutoreleasedReturnValue();
            objc_msgSend(v16, "name");
            v17 = (void *)objc_claimAutoreleasedReturnValue();
            *(_DWORD *)buf = 68289283;
            v25 = 0;
            v26 = 2082;
            v27 = "";
            v28 = 2113;
            v29 = v17;
            _os_signpost_emit_with_name_impl(&dword_2419D9000, v15, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Failed to convert MO to entry", "{\"msg%{public}.0s\":\"Failed to convert MO to entry\", \"MO\":%{private, location:escape_only}@}", buf, 0x1Cu);

          }
          std::__optional_destruct_base<CLMicroLocationConfigurationTable::Entry,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)v30);

          v19 = *a2;
          for (j = a2[1];
                j != v19;
                std::allocator<CLMicroLocationConfigurationTable::Entry>::destroy[abi:ne180100]((uint64_t)(a2 + 2), j))
          {
            j -= 112;
          }
          a2[1] = v19;
          goto LABEL_28;
        }
        objc_msgSend(v8, "convertToEntry", (_QWORD)v20);
        if (!(_BYTE)v31)
          goto LABEL_16;
        v10 = a2[1];
        if (v10 >= a2[2])
        {
          v11 = std::vector<CLMicroLocationConfigurationTable::Entry>::__push_back_slow_path<CLMicroLocationConfigurationTable::Entry>(a2, (uint64_t)v30);
        }
        else
        {
          std::allocator<CLMicroLocationConfigurationTable::Entry>::construct[abi:ne180100]<CLMicroLocationConfigurationTable::Entry,CLMicroLocationConfigurationTable::Entry>((uint64_t)(a2 + 2), a2[1], (uint64_t)v30);
          v11 = v10 + 112;
          a2[1] = v10 + 112;
        }
        a2[1] = v11;
        std::__optional_destruct_base<CLMicroLocationConfigurationTable::Entry,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)v30);

      }
      v5 = objc_msgSend(v4, "countByEnumeratingWithState:objects:count:", &v20, v32, 16);
      if (v5)
        continue;
      break;
    }
  }

LABEL_28:
}

void sub_241A414BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  void *v13;
  void *v14;
  void *v15;
  void *v16;
  void *v17;
  va_list va;

  va_start(va, a13);

  std::__optional_destruct_base<CLMicroLocationConfigurationTable::Entry,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)va);
  std::vector<CLMicroLocationConfigurationTable::Entry>::__destroy_vector::operator()[abi:ne180100]((void ***)va);

  _Unwind_Resume(a1);
}

void sub_241A41700(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

uint64_t std::__optional_destruct_base<CLMicroLocationConfigurationTable::Entry,false>::__optional_destruct_base[abi:ne180100]<CLMicroLocationConfigurationTable::Entry>(uint64_t a1, uint64_t a2)
{
  __int128 v3;
  __int128 v4;

  *(_QWORD *)a1 = *(_QWORD *)a2;
  v3 = *(_OWORD *)(a2 + 8);
  *(_QWORD *)(a1 + 24) = *(_QWORD *)(a2 + 24);
  *(_OWORD *)(a1 + 8) = v3;
  *(_QWORD *)(a2 + 16) = 0;
  *(_QWORD *)(a2 + 24) = 0;
  *(_QWORD *)(a2 + 8) = 0;
  v4 = *(_OWORD *)(a2 + 32);
  *(_DWORD *)(a1 + 48) = *(_DWORD *)(a2 + 48);
  *(_OWORD *)(a1 + 32) = v4;
  CLMicroLocationProto::Configuration::Configuration((CLMicroLocationProto::Configuration *)(a1 + 56), (const CLMicroLocationProto::Configuration *)(a2 + 56));
  *(_BYTE *)(a1 + 112) = 1;
  return a1;
}

void sub_241A417DC(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void **v2;

  if (*(char *)(v1 + 31) < 0)
    operator delete(*v2);
  _Unwind_Resume(exception_object);
}

void ___ZN9ULDBUtils13insertEntriesI33CLMicroLocationConfigurationTable17ULConfigurationMOEEbP7ULStoreRKNSt3__16vectorINT_5EntryENS5_9allocatorIS8_EEEE_block_invoke(uint64_t a1)
{
  uint64_t *v2;
  uint64_t v3;
  uint64_t v4;
  void *v5;
  void *v6;
  NSObject *v7;
  void *v8;
  void *v9;
  NSObject *v10;
  void *v11;
  void *v12;
  void *v13;
  int v14;
  int v15;
  __int16 v16;
  const char *v17;
  __int16 v18;
  void *v19;
  uint64_t v20;

  v20 = *MEMORY[0x24BDAC8D0];
  v2 = *(uint64_t **)(a1 + 48);
  v3 = *v2;
  v4 = v2[1];
  if (*v2 == v4)
  {
LABEL_4:
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = objc_msgSend(*(id *)(a1 + 32), "commitChangesToStore");
    objc_msgSend(*(id *)(a1 + 32), "deleteOldestRecordsIfFull");
  }
  else
  {
    while (1)
    {
      objc_msgSend(*(id *)(a1 + 32), "managedObjectContext");
      v5 = (void *)objc_claimAutoreleasedReturnValue();
      +[ULConfigurationMO createFromEntry:inManagedObjectContext:](ULConfigurationMO, "createFromEntry:inManagedObjectContext:", v3, v5);
      v6 = (void *)objc_claimAutoreleasedReturnValue();

      if (!v6)
        break;

      v3 += 112;
      if (v3 == v4)
        goto LABEL_4;
    }
    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_34);
    v7 = (id)logObject_MicroLocation_Default;
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      +[ULConfigurationMO entity](ULConfigurationMO, "entity");
      v8 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v8, "name");
      v9 = (void *)objc_claimAutoreleasedReturnValue();
      v14 = 68289283;
      v15 = 0;
      v16 = 2082;
      v17 = "";
      v18 = 2113;
      v19 = v9;
      _os_log_impl(&dword_2419D9000, v7, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"Failed to create entry from MO\", \"MO\":%{private, location:escape_only}@}", (uint8_t *)&v14, 0x1Cu);

    }
    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_34);
    v10 = (id)logObject_MicroLocation_Default;
    if (os_signpost_enabled(v10))
    {
      +[ULConfigurationMO entity](ULConfigurationMO, "entity");
      v11 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v11, "name");
      v12 = (void *)objc_claimAutoreleasedReturnValue();
      v14 = 68289283;
      v15 = 0;
      v16 = 2082;
      v17 = "";
      v18 = 2113;
      v19 = v12;
      _os_signpost_emit_with_name_impl(&dword_2419D9000, v10, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Failed to create entry from MO", "{\"msg%{public}.0s\":\"Failed to create entry from MO\", \"MO\":%{private, location:escape_only}@}", (uint8_t *)&v14, 0x1Cu);

    }
    objc_msgSend(*(id *)(a1 + 32), "managedObjectContext");
    v13 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v13, "reset");

  }
}

void sub_241A41AA4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void ___ZL45_CLLogObjectForCategory_MicroLocation_Defaultv_block_invoke_27()
{
  os_log_t v0;
  void *v1;

  v0 = os_log_create("com.apple.MicroLocation", "MicroLocation");
  v1 = (void *)logObject_MicroLocation_Default;
  logObject_MicroLocation_Default = (uint64_t)v0;

}

void ___ZN9ULDBUtils12fetchEntriesI33CLMicroLocationConfigurationTable17ULConfigurationMOEENSt3__16vectorINT_5EntryENS3_9allocatorIS6_EEEEP7ULStoreP7NSArrayIP11NSPredicateEPSC_IP16NSSortDescriptorEm_block_invoke(uint64_t a1)
{
  void *v2;
  objc_class *v3;
  void *v4;
  void *v5;
  uint64_t v6;
  void *v7;
  __int128 v8;
  uint64_t v9;
  void **v10;

  v2 = *(void **)(a1 + 48);
  v3 = (objc_class *)objc_opt_class();
  NSStringFromClass(v3);
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v2, "fetchManagedObjectsWithEntityName:byAndPredicates:sortDescriptors:andLimit:", v4, *(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 64));
  v5 = (void *)objc_claimAutoreleasedReturnValue();

  ULDBUtils::convertManagedObjectsToEntries<CLMicroLocationConfigurationTable,ULConfigurationMO>(v5, (uint64_t *)&v8);
  v6 = *(_QWORD *)(*(_QWORD *)(a1 + 56) + 8);
  std::vector<CLMicroLocationConfigurationTable::Entry>::__vdeallocate((void **)(v6 + 48));
  *(_OWORD *)(v6 + 48) = v8;
  *(_QWORD *)(v6 + 64) = v9;
  v9 = 0;
  v8 = 0uLL;
  v10 = (void **)&v8;
  std::vector<CLMicroLocationConfigurationTable::Entry>::__destroy_vector::operator()[abi:ne180100](&v10);
  objc_msgSend(*(id *)(a1 + 48), "managedObjectContext");
  v7 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v7, "reset");

}

void sub_241A41BF0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void std::vector<CLMicroLocationConfigurationTable::Entry>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v1;
  void *v2;
  uint64_t v4;
  void *v5;

  v1 = *a1;
  v2 = **a1;
  if (v2)
  {
    v4 = (uint64_t)v1[1];
    v5 = **a1;
    if ((void *)v4 != v2)
    {
      do
      {
        v4 -= 112;
        std::allocator<CLMicroLocationConfigurationTable::Entry>::destroy[abi:ne180100]((uint64_t)(v1 + 2), v4);
      }
      while ((void *)v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void std::allocator<CLMicroLocationConfigurationTable::Entry>::destroy[abi:ne180100](uint64_t a1, uint64_t a2)
{
  CLMicroLocationProto::Configuration::~Configuration((CLMicroLocationProto::Configuration *)(a2 + 56));
  if (*(char *)(a2 + 31) < 0)
    operator delete(*(void **)(a2 + 8));
}

void **std::vector<CLMicroLocationConfigurationTable::Entry>::reserve(uint64_t *a1, unint64_t a2)
{
  void **result;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  void *v7[5];

  v4 = a1[2];
  result = (void **)(a1 + 2);
  if (0x6DB6DB6DB6DB6DB7 * ((v4 - *a1) >> 4) < a2)
  {
    if (a2 >= 0x24924924924924ALL)
      std::vector<CLMicroLocationProto::ConfidenceReason>::__throw_length_error[abi:ne180100]();
    v5 = a1[1] - *a1;
    v7[4] = result;
    v7[0] = std::__allocate_at_least[abi:ne180100]<std::allocator<CLMicroLocationConfigurationTable::Entry>>((uint64_t)result, a2);
    v7[1] = (char *)v7[0] + v5;
    v7[2] = (char *)v7[0] + v5;
    v7[3] = (char *)v7[0] + 112 * v6;
    std::vector<CLMicroLocationConfigurationTable::Entry>::__swap_out_circular_buffer(a1, v7);
    return std::__split_buffer<CLMicroLocationConfigurationTable::Entry>::~__split_buffer(v7);
  }
  return result;
}

void sub_241A41D84(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__split_buffer<CLMicroLocationConfigurationTable::Entry>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

uint64_t std::vector<CLMicroLocationConfigurationTable::Entry>::__swap_out_circular_buffer(uint64_t *a1, _QWORD *a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<CLMicroLocationConfigurationTable::Entry>,std::reverse_iterator<CLMicroLocationConfigurationTable::Entry*>,std::reverse_iterator<CLMicroLocationConfigurationTable::Entry*>,std::reverse_iterator<CLMicroLocationConfigurationTable::Entry*>>((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<CLMicroLocationConfigurationTable::Entry>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x24924924924924ALL)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(112 * a2);
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<CLMicroLocationConfigurationTable::Entry>,std::reverse_iterator<CLMicroLocationConfigurationTable::Entry*>,std::reverse_iterator<CLMicroLocationConfigurationTable::Entry*>,std::reverse_iterator<CLMicroLocationConfigurationTable::Entry*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7;
  uint64_t v9;
  uint64_t v11;
  _QWORD v13[3];
  char v14;
  __int128 v15;
  __int128 v16;

  v7 = a7;
  *(_QWORD *)&v16 = a6;
  *((_QWORD *)&v16 + 1) = a7;
  v15 = v16;
  v13[0] = a1;
  v13[1] = &v15;
  v13[2] = &v16;
  v14 = 0;
  if (a3 == a5)
  {
    v11 = a6;
  }
  else
  {
    v9 = a3;
    do
    {
      v9 -= 112;
      std::allocator<CLMicroLocationConfigurationTable::Entry>::construct[abi:ne180100]<CLMicroLocationConfigurationTable::Entry,CLMicroLocationConfigurationTable::Entry const&>(a1, v7 - 112, v9);
      v7 = *((_QWORD *)&v16 + 1) - 112;
      *((_QWORD *)&v16 + 1) -= 112;
    }
    while (v9 != a5);
    v11 = v16;
  }
  v14 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<CLMicroLocationConfigurationTable::Entry>,std::reverse_iterator<CLMicroLocationConfigurationTable::Entry*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v13);
  return v11;
}

void sub_241A41F08(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<CLMicroLocationConfigurationTable::Entry>,std::reverse_iterator<CLMicroLocationConfigurationTable::Entry*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t std::allocator<CLMicroLocationConfigurationTable::Entry>::construct[abi:ne180100]<CLMicroLocationConfigurationTable::Entry,CLMicroLocationConfigurationTable::Entry const&>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  std::string *v5;
  __int128 v6;
  __int128 v7;

  *(_QWORD *)a2 = *(_QWORD *)a3;
  v5 = (std::string *)(a2 + 8);
  if (*(char *)(a3 + 31) < 0)
  {
    std::string::__init_copy_ctor_external(v5, *(const std::string::value_type **)(a3 + 8), *(_QWORD *)(a3 + 16));
  }
  else
  {
    v6 = *(_OWORD *)(a3 + 8);
    *(_QWORD *)(a2 + 24) = *(_QWORD *)(a3 + 24);
    *(_OWORD *)&v5->__r_.__value_.__l.__data_ = v6;
  }
  v7 = *(_OWORD *)(a3 + 32);
  *(_DWORD *)(a2 + 48) = *(_DWORD *)(a3 + 48);
  *(_OWORD *)(a2 + 32) = v7;
  return CLMicroLocationProto::Configuration::Configuration((CLMicroLocationProto::Configuration *)(a2 + 56), (const CLMicroLocationProto::Configuration *)(a3 + 56));
}

void sub_241A41F98(_Unwind_Exception *exception_object)
{
  void **v1;
  uint64_t v2;

  if (*(char *)(v2 + 31) < 0)
    operator delete(*v1);
  _Unwind_Resume(exception_object);
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<CLMicroLocationConfigurationTable::Entry>,std::reverse_iterator<CLMicroLocationConfigurationTable::Entry*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24))
    std::_AllocatorDestroyRangeReverse<std::allocator<CLMicroLocationConfigurationTable::Entry>,std::reverse_iterator<CLMicroLocationConfigurationTable::Entry*>>::operator()[abi:ne180100]((uint64_t *)a1);
  return a1;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<CLMicroLocationConfigurationTable::Entry>,std::reverse_iterator<CLMicroLocationConfigurationTable::Entry*>>::operator()[abi:ne180100](uint64_t *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;

  v1 = *(_QWORD *)(a1[2] + 8);
  v2 = *(_QWORD *)(a1[1] + 8);
  if (v1 != v2)
  {
    v3 = *a1;
    do
    {
      std::allocator<CLMicroLocationConfigurationTable::Entry>::destroy[abi:ne180100](v3, v1);
      v1 += 112;
    }
    while (v1 != v2);
  }
}

void **std::__split_buffer<CLMicroLocationConfigurationTable::Entry>::~__split_buffer(void **a1)
{
  std::__split_buffer<CLMicroLocationConfigurationTable::Entry>::clear[abi:ne180100](a1);
  if (*a1)
    operator delete(*a1);
  return a1;
}

void std::__split_buffer<CLMicroLocationConfigurationTable::Entry>::clear[abi:ne180100](_QWORD *a1)
{
  uint64_t i;
  uint64_t v2;
  uint64_t v4;

  v2 = a1[1];
  for (i = a1[2]; i != v2; i = a1[2])
  {
    v4 = a1[4];
    a1[2] = i - 112;
    std::allocator<CLMicroLocationConfigurationTable::Entry>::destroy[abi:ne180100](v4, i - 112);
  }
}

uint64_t std::vector<CLMicroLocationConfigurationTable::Entry>::__push_back_slow_path<CLMicroLocationConfigurationTable::Entry>(uint64_t *a1, uint64_t a2)
{
  uint64_t v3;
  unint64_t v4;
  unint64_t v6;
  char *v7;
  uint64_t v8;
  void *v10;
  char *v11;
  char *v12;
  char *v13;
  uint64_t *v14;

  v3 = 0x6DB6DB6DB6DB6DB7 * ((a1[1] - *a1) >> 4);
  v4 = v3 + 1;
  if ((unint64_t)(v3 + 1) > 0x249249249249249)
    std::vector<CLMicroLocationProto::ConfidenceReason>::__throw_length_error[abi:ne180100]();
  if (0xDB6DB6DB6DB6DB6ELL * ((a1[2] - *a1) >> 4) > v4)
    v4 = 0xDB6DB6DB6DB6DB6ELL * ((a1[2] - *a1) >> 4);
  if ((unint64_t)(0x6DB6DB6DB6DB6DB7 * ((a1[2] - *a1) >> 4)) >= 0x124924924924924)
    v6 = 0x249249249249249;
  else
    v6 = v4;
  v14 = a1 + 2;
  if (v6)
    v7 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<CLMicroLocationConfigurationTable::Entry>>((uint64_t)(a1 + 2), v6);
  else
    v7 = 0;
  v10 = v7;
  v11 = &v7[112 * v3];
  v13 = &v7[112 * v6];
  std::allocator<CLMicroLocationConfigurationTable::Entry>::construct[abi:ne180100]<CLMicroLocationConfigurationTable::Entry,CLMicroLocationConfigurationTable::Entry>((uint64_t)(a1 + 2), (uint64_t)v11, a2);
  v12 = v11 + 112;
  std::vector<CLMicroLocationConfigurationTable::Entry>::__swap_out_circular_buffer(a1, &v10);
  v8 = a1[1];
  std::__split_buffer<CLMicroLocationConfigurationTable::Entry>::~__split_buffer(&v10);
  return v8;
}

void sub_241A421BC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__split_buffer<CLMicroLocationConfigurationTable::Entry>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

uint64_t std::allocator<CLMicroLocationConfigurationTable::Entry>::construct[abi:ne180100]<CLMicroLocationConfigurationTable::Entry,CLMicroLocationConfigurationTable::Entry>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  __int128 v3;
  __int128 v4;

  *(_QWORD *)a2 = *(_QWORD *)a3;
  v3 = *(_OWORD *)(a3 + 8);
  *(_QWORD *)(a2 + 24) = *(_QWORD *)(a3 + 24);
  *(_OWORD *)(a2 + 8) = v3;
  *(_QWORD *)(a3 + 16) = 0;
  *(_QWORD *)(a3 + 24) = 0;
  *(_QWORD *)(a3 + 8) = 0;
  v4 = *(_OWORD *)(a3 + 32);
  *(_DWORD *)(a2 + 48) = *(_DWORD *)(a3 + 48);
  *(_OWORD *)(a2 + 32) = v4;
  return CLMicroLocationProto::Configuration::Configuration((CLMicroLocationProto::Configuration *)(a2 + 56), (const CLMicroLocationProto::Configuration *)(a3 + 56));
}

void sub_241A42234(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void **v2;

  if (*(char *)(v1 + 31) < 0)
    operator delete(*v2);
  _Unwind_Resume(exception_object);
}

void std::vector<CLMicroLocationConfigurationTable::Entry>::__vdeallocate(void **a1)
{
  void *v1;
  uint64_t v3;
  void *v4;

  v1 = *a1;
  if (*a1)
  {
    v3 = (uint64_t)a1[1];
    v4 = *a1;
    if ((void *)v3 != v1)
    {
      do
      {
        v3 -= 112;
        std::allocator<CLMicroLocationConfigurationTable::Entry>::destroy[abi:ne180100]((uint64_t)(a1 + 2), v3);
      }
      while ((void *)v3 != v1);
      v4 = *a1;
    }
    a1[1] = v1;
    operator delete(v4);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

_QWORD *std::vector<CLMicroLocationConfigurationTable::Entry>::__init_with_size[abi:ne180100]<CLMicroLocationConfigurationTable::Entry*,CLMicroLocationConfigurationTable::Entry*>(_QWORD *result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  _QWORD *v6;

  if (a4)
  {
    v6 = result;
    std::vector<CLMicroLocationConfigurationTable::Entry>::__vallocate[abi:ne180100](result, a4);
    result = (_QWORD *)std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<CLMicroLocationConfigurationTable::Entry>,CLMicroLocationConfigurationTable::Entry*,CLMicroLocationConfigurationTable::Entry*,CLMicroLocationConfigurationTable::Entry*>((uint64_t)(v6 + 2), a2, a3, v6[1]);
    v6[1] = result;
  }
  return result;
}

void sub_241A42320(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  uint64_t v9;
  uint64_t v10;

  *(_QWORD *)(v9 + 8) = v10;
  std::vector<CLMicroLocationConfigurationTable::Entry>::__destroy_vector::operator()[abi:ne180100](&a9);
  _Unwind_Resume(a1);
}

char *std::vector<CLMicroLocationConfigurationTable::Entry>::__vallocate[abi:ne180100](_QWORD *a1, unint64_t a2)
{
  char *result;
  uint64_t v4;

  if (a2 >= 0x24924924924924ALL)
    std::vector<CLMicroLocationProto::ConfidenceReason>::__throw_length_error[abi:ne180100]();
  result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<CLMicroLocationConfigurationTable::Entry>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[112 * v4];
  return result;
}

uint64_t std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<CLMicroLocationConfigurationTable::Entry>,CLMicroLocationConfigurationTable::Entry*,CLMicroLocationConfigurationTable::Entry*,CLMicroLocationConfigurationTable::Entry*>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  uint64_t v6;
  _QWORD v9[3];
  char v10;
  uint64_t v11;
  uint64_t v12;

  v4 = a4;
  v11 = a4;
  v12 = a4;
  v9[0] = a1;
  v9[1] = &v11;
  v9[2] = &v12;
  v10 = 0;
  if (a2 != a3)
  {
    v6 = a2;
    do
    {
      std::allocator<CLMicroLocationConfigurationTable::Entry>::construct[abi:ne180100]<CLMicroLocationConfigurationTable::Entry,CLMicroLocationConfigurationTable::Entry&>(a1, v4, v6);
      v6 += 112;
      v4 = v12 + 112;
      v12 += 112;
    }
    while (v6 != a3);
  }
  v10 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<CLMicroLocationConfigurationTable::Entry>,CLMicroLocationConfigurationTable::Entry*>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v9);
  return v4;
}

void sub_241A42428(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<CLMicroLocationConfigurationTable::Entry>,CLMicroLocationConfigurationTable::Entry*>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t std::allocator<CLMicroLocationConfigurationTable::Entry>::construct[abi:ne180100]<CLMicroLocationConfigurationTable::Entry,CLMicroLocationConfigurationTable::Entry&>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  std::string *v5;
  __int128 v6;
  __int128 v7;

  *(_QWORD *)a2 = *(_QWORD *)a3;
  v5 = (std::string *)(a2 + 8);
  if (*(char *)(a3 + 31) < 0)
  {
    std::string::__init_copy_ctor_external(v5, *(const std::string::value_type **)(a3 + 8), *(_QWORD *)(a3 + 16));
  }
  else
  {
    v6 = *(_OWORD *)(a3 + 8);
    *(_QWORD *)(a2 + 24) = *(_QWORD *)(a3 + 24);
    *(_OWORD *)&v5->__r_.__value_.__l.__data_ = v6;
  }
  v7 = *(_OWORD *)(a3 + 32);
  *(_DWORD *)(a2 + 48) = *(_DWORD *)(a3 + 48);
  *(_OWORD *)(a2 + 32) = v7;
  return CLMicroLocationProto::Configuration::Configuration((CLMicroLocationProto::Configuration *)(a2 + 56), (const CLMicroLocationProto::Configuration *)(a3 + 56));
}

void sub_241A424B8(_Unwind_Exception *exception_object)
{
  void **v1;
  uint64_t v2;

  if (*(char *)(v2 + 31) < 0)
    operator delete(*v1);
  _Unwind_Resume(exception_object);
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<CLMicroLocationConfigurationTable::Entry>,CLMicroLocationConfigurationTable::Entry*>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24))
    std::_AllocatorDestroyRangeReverse<std::allocator<CLMicroLocationConfigurationTable::Entry>,CLMicroLocationConfigurationTable::Entry*>::operator()[abi:ne180100]((uint64_t *)a1);
  return a1;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<CLMicroLocationConfigurationTable::Entry>,CLMicroLocationConfigurationTable::Entry*>::operator()[abi:ne180100](uint64_t *a1)
{
  uint64_t *v1;
  uint64_t *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  v2 = (uint64_t *)a1[1];
  v1 = (uint64_t *)a1[2];
  v3 = *v1;
  v4 = *v2;
  if (*v1 != *v2)
  {
    v5 = *a1;
    do
    {
      v3 -= 112;
      std::allocator<CLMicroLocationConfigurationTable::Entry>::destroy[abi:ne180100](v5, v3);
    }
    while (v3 != v4);
  }
}

void sub_241A425C0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_241A4268C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, CLMacAddress *a9, uint64_t a10)
{
  uint64_t v11;

  std::unique_ptr<ULMiloSqliteDatabase>::reset[abi:ne180100](&a9, 0);
  v11 = a10;
  a10 = 0;
  if (v11)
    (*(void (**)(uint64_t))(*(_QWORD *)v11 + 8))(v11);
  _Unwind_Resume(a1);
}

void sub_241A42920(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  void *v22;
  _QWORD *v23;
  uint64_t v24;
  void *v25;
  void *v26;
  void *v27;

  v27 = v25;

  *v23 = 0;
  (*(void (**)(uint64_t))(*(_QWORD *)v24 + 8))(v24);
  if (a16 < 0)
    operator delete(__p);
  if (a22 < 0)
    operator delete(a17);

  _Unwind_Resume(a1);
}

void sub_241A42C5C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_241A43160(_Unwind_Exception *exception_object)
{
  _Unwind_Resume(exception_object);
}

uint64_t ULRecordingEventTable::migrationLimit(ULRecordingEventTable *this)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  uint64_t v5;
  uint64_t v6;

  +[ULDefaultsSingleton shared](ULDefaultsSingleton, "shared");
  v1 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v1, "defaultsDictionary");
  v2 = (void *)objc_claimAutoreleasedReturnValue();

  objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "ULRecordingEventTableMigrationLimit");
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v2, "objectForKey:", v3);
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  if (v4 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
    v5 = objc_msgSend(v4, "unsignedIntValue");
  else
    v5 = objc_msgSend(&unk_2511ED708, "unsignedIntValue");
  v6 = v5;

  return v6;
}

void sub_241A432B0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

uint64_t ULRecordingEventTable::pageSize(ULRecordingEventTable *this)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  uint64_t v5;
  uint64_t v6;

  +[ULDefaultsSingleton shared](ULDefaultsSingleton, "shared");
  v1 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v1, "defaultsDictionary");
  v2 = (void *)objc_claimAutoreleasedReturnValue();

  objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "ULRecordingEventTableMigrationPageSize");
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v2, "objectForKey:", v3);
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  if (v4 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
    v5 = objc_msgSend(v4, "unsignedIntValue");
  else
    v5 = objc_msgSend(&unk_2511ED6C0, "unsignedIntValue");
  v6 = v5;

  return v6;
}

void sub_241A433AC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_241A43458(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void **a12)
{
  a12 = (void **)&a9;
  std::vector<CLMicroLocationRecordingEventsTable::Entry>::__destroy_vector::operator()[abi:ne180100](&a12);
  _Unwind_Resume(a1);
}

uint64_t ULMeasurementTable::migrationLimit(ULMeasurementTable *this)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  uint64_t v5;
  uint64_t v6;

  +[ULDefaultsSingleton shared](ULDefaultsSingleton, "shared");
  v1 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v1, "defaultsDictionary");
  v2 = (void *)objc_claimAutoreleasedReturnValue();

  objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "ULMeasurementTableMigrationLimit");
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v2, "objectForKey:", v3);
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  if (v4 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
    v5 = objc_msgSend(v4, "unsignedIntValue");
  else
    v5 = objc_msgSend(&unk_2511ED720, "unsignedIntValue");
  v6 = v5;

  return v6;
}

void sub_241A43538(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

uint64_t ULMeasurementTable::pageSize(ULMeasurementTable *this)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  uint64_t v5;
  uint64_t v6;

  +[ULDefaultsSingleton shared](ULDefaultsSingleton, "shared");
  v1 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v1, "defaultsDictionary");
  v2 = (void *)objc_claimAutoreleasedReturnValue();

  objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "ULMeasurementTableMigrationPageSize");
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v2, "objectForKey:", v3);
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  if (v4 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
    v5 = objc_msgSend(v4, "unsignedIntValue");
  else
    v5 = objc_msgSend(&unk_2511ED6C0, "unsignedIntValue");
  v6 = v5;

  return v6;
}

void sub_241A43634(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_241A436E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void **a12)
{
  a12 = (void **)&a9;
  std::vector<CLMicroLocationMeasurementTable::Entry>::__destroy_vector::operator()[abi:ne180100](&a12);
  _Unwind_Resume(a1);
}

uint64_t ULLabelTable::migrationLimit(ULLabelTable *this)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  uint64_t v5;
  uint64_t v6;

  +[ULDefaultsSingleton shared](ULDefaultsSingleton, "shared");
  v1 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v1, "defaultsDictionary");
  v2 = (void *)objc_claimAutoreleasedReturnValue();

  objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "ULLabelTableMigrationLimit");
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v2, "objectForKey:", v3);
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  if (v4 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
    v5 = objc_msgSend(v4, "unsignedIntValue");
  else
    v5 = objc_msgSend(&unk_2511ED738, "unsignedIntValue");
  v6 = v5;

  return v6;
}

void sub_241A437C0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

uint64_t ULLabelTable::pageSize(ULLabelTable *this)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  uint64_t v5;
  uint64_t v6;

  +[ULDefaultsSingleton shared](ULDefaultsSingleton, "shared");
  v1 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v1, "defaultsDictionary");
  v2 = (void *)objc_claimAutoreleasedReturnValue();

  objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "ULLabelTableMigrationPageSize");
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v2, "objectForKey:", v3);
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  if (v4 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
    v5 = objc_msgSend(v4, "unsignedIntValue");
  else
    v5 = objc_msgSend(&unk_2511ED6C0, "unsignedIntValue");
  v6 = v5;

  return v6;
}

void sub_241A438BC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_241A43968(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void **a12)
{
  a12 = (void **)&a9;
  std::vector<CLMicroLocationRecordingLabelsTable::Entry>::__destroy_vector::operator()[abi:ne180100](&a12);
  _Unwind_Resume(a1);
}

uint64_t ULServiceTable::migrationLimit(ULServiceTable *this)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  uint64_t v5;
  uint64_t v6;

  +[ULDefaultsSingleton shared](ULDefaultsSingleton, "shared");
  v1 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v1, "defaultsDictionary");
  v2 = (void *)objc_claimAutoreleasedReturnValue();

  objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "ULServiceTableMigrationLimit");
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v2, "objectForKey:", v3);
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  if (v4 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
    v5 = objc_msgSend(v4, "unsignedIntValue");
  else
    v5 = objc_msgSend(&unk_2511ED6C0, "unsignedIntValue");
  v6 = v5;

  return v6;
}

void sub_241A43A48(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

uint64_t ULServiceTable::pageSize(ULServiceTable *this)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  uint64_t v5;
  uint64_t v6;

  +[ULDefaultsSingleton shared](ULDefaultsSingleton, "shared");
  v1 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v1, "defaultsDictionary");
  v2 = (void *)objc_claimAutoreleasedReturnValue();

  objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "ULServiceTableMigrationPageSize");
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v2, "objectForKey:", v3);
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  if (v4 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
    v5 = objc_msgSend(v4, "unsignedIntValue");
  else
    v5 = objc_msgSend(&unk_2511ED6C0, "unsignedIntValue");
  v6 = v5;

  return v6;
}

void sub_241A43B44(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_241A43BF0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void **a12)
{
  a12 = (void **)&a9;
  std::vector<CLMiLoServiceTable::Entry>::__destroy_vector::operator()[abi:ne180100](&a12);
  _Unwind_Resume(a1);
}

uint64_t ULLoiTable::migrationLimit(ULLoiTable *this)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  uint64_t v5;
  uint64_t v6;

  +[ULDefaultsSingleton shared](ULDefaultsSingleton, "shared");
  v1 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v1, "defaultsDictionary");
  v2 = (void *)objc_claimAutoreleasedReturnValue();

  objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "ULLoiTableMigrationLimit");
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v2, "objectForKey:", v3);
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  if (v4 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
    v5 = objc_msgSend(v4, "unsignedIntValue");
  else
    v5 = objc_msgSend(&unk_2511ED6C0, "unsignedIntValue");
  v6 = v5;

  return v6;
}

void sub_241A43CD0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

uint64_t ULLoiTable::pageSize(ULLoiTable *this)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  uint64_t v5;
  uint64_t v6;

  +[ULDefaultsSingleton shared](ULDefaultsSingleton, "shared");
  v1 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v1, "defaultsDictionary");
  v2 = (void *)objc_claimAutoreleasedReturnValue();

  objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "ULLoiTableMigrationPageSize");
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v2, "objectForKey:", v3);
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  if (v4 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
    v5 = objc_msgSend(v4, "unsignedIntValue");
  else
    v5 = objc_msgSend(&unk_2511ED6C0, "unsignedIntValue");
  v6 = v5;

  return v6;
}

void sub_241A43DCC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_241A43E78(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void **a12)
{
  a12 = (void **)&a9;
  std::vector<CLMiLoLoiTable::Entry>::__destroy_vector::operator()[abi:ne180100](&a12);
  _Unwind_Resume(a1);
}

uint64_t ULRapportTable::migrationLimit(ULRapportTable *this)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  uint64_t v5;
  uint64_t v6;

  +[ULDefaultsSingleton shared](ULDefaultsSingleton, "shared");
  v1 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v1, "defaultsDictionary");
  v2 = (void *)objc_claimAutoreleasedReturnValue();

  objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "ULRapportTableMigrationLimit");
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v2, "objectForKey:", v3);
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  if (v4 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
    v5 = objc_msgSend(v4, "unsignedIntValue");
  else
    v5 = objc_msgSend(&unk_2511ED6C0, "unsignedIntValue");
  v6 = v5;

  return v6;
}

void sub_241A43F58(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

uint64_t ULRapportTable::pageSize(ULRapportTable *this)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  uint64_t v5;
  uint64_t v6;

  +[ULDefaultsSingleton shared](ULDefaultsSingleton, "shared");
  v1 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v1, "defaultsDictionary");
  v2 = (void *)objc_claimAutoreleasedReturnValue();

  objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "ULRapportTableMigrationPageSize");
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v2, "objectForKey:", v3);
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  if (v4 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
    v5 = objc_msgSend(v4, "unsignedIntValue");
  else
    v5 = objc_msgSend(&unk_2511ED6C0, "unsignedIntValue");
  v6 = v5;

  return v6;
}

void sub_241A44054(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_241A44100(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void **a12)
{
  a12 = (void **)&a9;
  std::vector<CLMicroLocationRapportTable::Entry>::__destroy_vector::operator()[abi:ne180100](&a12);
  _Unwind_Resume(a1);
}

uint64_t ULAssociatedStateTable::migrationLimit(ULAssociatedStateTable *this)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  uint64_t v5;
  uint64_t v6;

  +[ULDefaultsSingleton shared](ULDefaultsSingleton, "shared");
  v1 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v1, "defaultsDictionary");
  v2 = (void *)objc_claimAutoreleasedReturnValue();

  objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "ULAssociatedStateTableMigrationLimit");
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v2, "objectForKey:", v3);
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  if (v4 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
    v5 = objc_msgSend(v4, "unsignedIntValue");
  else
    v5 = objc_msgSend(&unk_2511ED6C0, "unsignedIntValue");
  v6 = v5;

  return v6;
}

void sub_241A441E0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

uint64_t ULAssociatedStateTable::pageSize(ULAssociatedStateTable *this)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  uint64_t v5;
  uint64_t v6;

  +[ULDefaultsSingleton shared](ULDefaultsSingleton, "shared");
  v1 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v1, "defaultsDictionary");
  v2 = (void *)objc_claimAutoreleasedReturnValue();

  objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "ULAssociatedStateTableMigrationPageSize");
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v2, "objectForKey:", v3);
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  if (v4 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
    v5 = objc_msgSend(v4, "unsignedIntValue");
  else
    v5 = objc_msgSend(&unk_2511ED6C0, "unsignedIntValue");
  v6 = v5;

  return v6;
}

void sub_241A442DC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_241A44388(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void **a12)
{
  a12 = (void **)&a9;
  std::vector<CLMicroLocationAssociatedStateTable::Entry>::__destroy_vector::operator()[abi:ne180100](&a12);
  _Unwind_Resume(a1);
}

uint64_t ULBlueToothIdentityTable::migrationLimit(ULBlueToothIdentityTable *this)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  uint64_t v5;
  uint64_t v6;

  +[ULDefaultsSingleton shared](ULDefaultsSingleton, "shared");
  v1 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v1, "defaultsDictionary");
  v2 = (void *)objc_claimAutoreleasedReturnValue();

  objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "ULBluetoothIdentityTableMigrationLimit");
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v2, "objectForKey:", v3);
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  if (v4 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
    v5 = objc_msgSend(v4, "unsignedIntValue");
  else
    v5 = objc_msgSend(&unk_2511ED6C0, "unsignedIntValue");
  v6 = v5;

  return v6;
}

void sub_241A44468(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

uint64_t ULBlueToothIdentityTable::pageSize(ULBlueToothIdentityTable *this)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  uint64_t v5;
  uint64_t v6;

  +[ULDefaultsSingleton shared](ULDefaultsSingleton, "shared");
  v1 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v1, "defaultsDictionary");
  v2 = (void *)objc_claimAutoreleasedReturnValue();

  objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "ULBluetoothIdentityTableMigrationPageSize");
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v2, "objectForKey:", v3);
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  if (v4 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
    v5 = objc_msgSend(v4, "unsignedIntValue");
  else
    v5 = objc_msgSend(&unk_2511ED6C0, "unsignedIntValue");
  v6 = v5;

  return v6;
}

void sub_241A44564(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_241A44610(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void **a12)
{
  a12 = (void **)&a9;
  std::vector<CLMicroLocationBluetoothIdentityTable::Entry>::__destroy_vector::operator()[abi:ne180100](&a12);
  _Unwind_Resume(a1);
}

uint64_t ULConfigurationTable::migrationLimit(ULConfigurationTable *this)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  uint64_t v5;
  uint64_t v6;

  +[ULDefaultsSingleton shared](ULDefaultsSingleton, "shared");
  v1 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v1, "defaultsDictionary");
  v2 = (void *)objc_claimAutoreleasedReturnValue();

  objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "ULConfigurationTableMigrationLimit");
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v2, "objectForKey:", v3);
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  if (v4 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
    v5 = objc_msgSend(v4, "unsignedIntValue");
  else
    v5 = objc_msgSend(&unk_2511ED750, "unsignedIntValue");
  v6 = v5;

  return v6;
}

void sub_241A446F0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

uint64_t ULConfigurationTable::pageSize(ULConfigurationTable *this)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  uint64_t v5;
  uint64_t v6;

  +[ULDefaultsSingleton shared](ULDefaultsSingleton, "shared");
  v1 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v1, "defaultsDictionary");
  v2 = (void *)objc_claimAutoreleasedReturnValue();

  objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "ULConfigurationTableMigrationPageSize");
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v2, "objectForKey:", v3);
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  if (v4 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
    v5 = objc_msgSend(v4, "unsignedIntValue");
  else
    v5 = objc_msgSend(&unk_2511ED750, "unsignedIntValue");
  v6 = v5;

  return v6;
}

void sub_241A447EC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_241A44898(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void **a12)
{
  a12 = (void **)&a9;
  std::vector<CLMicroLocationConfigurationTable::Entry>::__destroy_vector::operator()[abi:ne180100](&a12);
  _Unwind_Resume(a1);
}

uint64_t ULModelTable::migrationLimit(ULModelTable *this)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  uint64_t v5;
  uint64_t v6;

  +[ULDefaultsSingleton shared](ULDefaultsSingleton, "shared");
  v1 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v1, "defaultsDictionary");
  v2 = (void *)objc_claimAutoreleasedReturnValue();

  objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "ULModelTableMigrationLimit");
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v2, "objectForKey:", v3);
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  if (v4 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
    v5 = objc_msgSend(v4, "unsignedIntValue");
  else
    v5 = objc_msgSend(&unk_2511ED6F0, "unsignedIntValue");
  v6 = v5;

  return v6;
}

void sub_241A44978(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

uint64_t ULModelTable::pageSize(ULModelTable *this)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  uint64_t v5;
  uint64_t v6;

  +[ULDefaultsSingleton shared](ULDefaultsSingleton, "shared");
  v1 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v1, "defaultsDictionary");
  v2 = (void *)objc_claimAutoreleasedReturnValue();

  objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "ULModelTableMigrationPageSize");
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v2, "objectForKey:", v3);
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  if (v4 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
    v5 = objc_msgSend(v4, "unsignedIntValue");
  else
    v5 = objc_msgSend(&unk_2511ED6D8, "unsignedIntValue");
  v6 = v5;

  return v6;
}

void sub_241A44A74(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_241A44B20(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void **a12)
{
  a12 = (void **)&a9;
  std::vector<CLMicroLocationModelTable::Entry>::__destroy_vector::operator()[abi:ne180100](&a12);
  _Unwind_Resume(a1);
}

uint64_t ULCustomLoiTable::migrationLimit(ULCustomLoiTable *this)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  uint64_t v5;
  uint64_t v6;

  +[ULDefaultsSingleton shared](ULDefaultsSingleton, "shared");
  v1 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v1, "defaultsDictionary");
  v2 = (void *)objc_claimAutoreleasedReturnValue();

  objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "ULCustomLoiTableMigrationLimit");
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v2, "objectForKey:", v3);
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  if (v4 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
    v5 = objc_msgSend(v4, "unsignedIntValue");
  else
    v5 = objc_msgSend(&unk_2511ED6C0, "unsignedIntValue");
  v6 = v5;

  return v6;
}

void sub_241A44C00(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

uint64_t ULCustomLoiTable::pageSize(ULCustomLoiTable *this)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  uint64_t v5;
  uint64_t v6;

  +[ULDefaultsSingleton shared](ULDefaultsSingleton, "shared");
  v1 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v1, "defaultsDictionary");
  v2 = (void *)objc_claimAutoreleasedReturnValue();

  objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "ULCustomLoiTableMigrationPageSize");
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v2, "objectForKey:", v3);
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  if (v4 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
    v5 = objc_msgSend(v4, "unsignedIntValue");
  else
    v5 = objc_msgSend(&unk_2511ED6C0, "unsignedIntValue");
  v6 = v5;

  return v6;
}

void sub_241A44CFC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_241A44DAC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t ULLoggedEventTable::migrationLimit(ULLoggedEventTable *this)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  uint64_t v5;
  uint64_t v6;

  +[ULDefaultsSingleton shared](ULDefaultsSingleton, "shared");
  v1 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v1, "defaultsDictionary");
  v2 = (void *)objc_claimAutoreleasedReturnValue();

  objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "ULLoggedEventsTableMigrationLimit");
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v2, "objectForKey:", v3);
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  if (v4 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
    v5 = objc_msgSend(v4, "unsignedIntValue");
  else
    v5 = objc_msgSend(&unk_2511ED768, "unsignedIntValue");
  v6 = v5;

  return v6;
}

void sub_241A44E8C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

uint64_t ULLoggedEventTable::pageSize(ULLoggedEventTable *this)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  uint64_t v5;
  uint64_t v6;

  +[ULDefaultsSingleton shared](ULDefaultsSingleton, "shared");
  v1 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v1, "defaultsDictionary");
  v2 = (void *)objc_claimAutoreleasedReturnValue();

  objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "ULLoggedEventsTableMigrationPageSize");
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v2, "objectForKey:", v3);
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  if (v4 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
    v5 = objc_msgSend(v4, "unsignedIntValue");
  else
    v5 = objc_msgSend(&unk_2511ED6C0, "unsignedIntValue");
  v6 = v5;

  return v6;
}

void sub_241A44F88(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_241A45034(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void **a12)
{
  a12 = (void **)&a9;
  std::vector<CLMicroLocationLoggedEventsTable::Entry>::__destroy_vector::operator()[abi:ne180100](&a12);
  _Unwind_Resume(a1);
}

void sub_241A452B0(_Unwind_Exception *exception_object)
{
  _Unwind_Resume(exception_object);
}

void sub_241A455F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, void *a12, void *a13, void *a14, void *a15, void *a16, void *a17, void *a18, void *a19, void *a20)
{
  void *v20;
  void *v21;
  void *v22;

  _Unwind_Resume(a1);
}

void ___ZL45_CLLogObjectForCategory_MicroLocation_Defaultv_block_invoke_28()
{
  os_log_t v0;
  void *v1;

  v0 = os_log_create("com.apple.MicroLocation", "MicroLocation");
  v1 = (void *)logObject_MicroLocation_Default;
  logObject_MicroLocation_Default = (uint64_t)v0;

}

CLMacAddress *std::unique_ptr<ULMiloSqliteDatabase>::reset[abi:ne180100](CLMacAddress **a1, unint64_t a2)
{
  CLMacAddress *result;

  result = *a1;
  *a1 = (CLMacAddress *)a2;
  if (result)
  {
    CLMacAddress::newFromUint64(result, a2);
    JUMPOUT(0x2426A04D4);
  }
  return result;
}

void std::vector<CLMicroLocationRecordingEventsTable::Entry>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v1;
  void *v2;
  uint64_t v4;
  void *v5;

  v1 = *a1;
  v2 = **a1;
  if (v2)
  {
    v4 = (uint64_t)v1[1];
    v5 = **a1;
    if ((void *)v4 != v2)
    {
      do
      {
        v4 -= 248;
        std::allocator<CLMicroLocationRecordingEventsTable::Entry>::destroy[abi:ne180100]((uint64_t)(v1 + 2), v4);
      }
      while ((void *)v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void std::allocator<CLMicroLocationRecordingEventsTable::Entry>::destroy[abi:ne180100](uint64_t a1, uint64_t a2)
{
  CLMicroLocationProto::RecordingEvent::~RecordingEvent((CLMicroLocationProto::RecordingEvent *)(a2 + 80));
  if (*(char *)(a2 + 47) < 0)
    operator delete(*(void **)(a2 + 24));
}

void std::vector<CLMicroLocationRapportTable::Entry>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v1;
  void *v2;
  uint64_t v4;
  void *v5;

  v1 = *a1;
  v2 = **a1;
  if (v2)
  {
    v4 = (uint64_t)v1[1];
    v5 = **a1;
    if ((void *)v4 != v2)
    {
      do
      {
        v4 -= 80;
        std::allocator<CLMicroLocationRapportTable::Entry>::destroy[abi:ne180100]((uint64_t)(v1 + 2), v4);
      }
      while ((void *)v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void std::allocator<CLMicroLocationRapportTable::Entry>::destroy[abi:ne180100](uint64_t a1, uint64_t a2)
{
  CLMicroLocationProto::RapportDevice::~RapportDevice((CLMicroLocationProto::RapportDevice *)(a2 + 32));
  if (*(char *)(a2 + 31) < 0)
    operator delete(*(void **)(a2 + 8));
}

void std::vector<CLMicroLocationBluetoothIdentityTable::Entry>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v1;
  void *v2;
  uint64_t v4;
  void *v5;

  v1 = *a1;
  v2 = **a1;
  if (v2)
  {
    v4 = (uint64_t)v1[1];
    v5 = **a1;
    if ((void *)v4 != v2)
    {
      do
      {
        v4 -= 72;
        std::allocator<CLMicroLocationRapportMonitor::Item>::destroy[abi:ne180100]((uint64_t)(v1 + 2), v4);
      }
      while ((void *)v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void sub_241A45C84(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location)
{
  id *v16;

  objc_destroyWeak(v16);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_241A45D90(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_241A45DE4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  void *v9;
  void *v10;

  v10 = v9;
  a9.receiver = v10;
  a9.super_class = (Class)ULDataContainer;
  -[_Unwind_Exception dealloc](&a9, sel_dealloc);
  _Unwind_Resume(a1);
}

void sub_241A45F0C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_241A461E4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_241A46418(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void ___ZL45_CLLogObjectForCategory_MicroLocation_Defaultv_block_invoke_29()
{
  os_log_t v0;
  void *v1;

  v0 = os_log_create("com.apple.MicroLocation", "MicroLocation");
  v1 = (void *)logObject_MicroLocation_Default;
  logObject_MicroLocation_Default = (uint64_t)v0;

}

void CLSqliteDatabaseManager::create(CLSqliteDatabaseManager *this)
{
  CLSqliteDatabaseManager *v1;

  v1 = (CLSqliteDatabaseManager *)operator new();
  CLSqliteDatabaseManager::CLSqliteDatabaseManager(v1);
  CLSqliteDatabaseManager::fInstance = (uint64_t)v1;
}

void sub_241A464B0(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x2426A04D4](v1, 0x10A0C40FCC610CCLL);
  _Unwind_Resume(a1);
}

uint64_t CLSqliteDatabaseManager::instance(CLSqliteDatabaseManager *this)
{
  if (CLSqliteDatabaseManager::instance(void)::pred != -1)
    dispatch_once(&CLSqliteDatabaseManager::instance(void)::pred, &__block_literal_global_37);
  return CLSqliteDatabaseManager::fInstance;
}

void CLSqliteDatabaseManager::CLSqliteDatabaseManager(CLSqliteDatabaseManager *this)
{
  int v2;
  NSObject *v3;
  int v4;
  NSObject *v5;
  uint8_t buf[4];
  int v7;
  uint64_t v8;

  v8 = *MEMORY[0x24BDAC8D0];
  *((_QWORD *)this + 2) = 0;
  *((_QWORD *)this + 1) = 0;
  *(_QWORD *)this = (char *)this + 8;
  BasicMutex::BasicMutex((CLSqliteDatabaseManager *)((char *)this + 24), "SqliteDatabaseManager", 1, 1);
  *((_WORD *)this + 20) = 256;
  v2 = sqlite3_shutdown();
  if (v2)
  {
    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_16);
    v3 = logObject_MicroLocation_Default;
    if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 67109120;
      v7 = v2;
      _os_log_impl(&dword_2419D9000, v3, OS_LOG_TYPE_ERROR, "sqlite3_shutdown failed. sqlite_rc: %d", buf, 8u);
    }
  }
  v4 = sqlite3_config(13, 512, 125);
  if (v4)
  {
    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_16);
    v5 = logObject_MicroLocation_Default;
    if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 67109120;
      v7 = v4;
      _os_log_impl(&dword_2419D9000, v5, OS_LOG_TYPE_ERROR, "Can't set the sqlite lookaside buffers size to 64K. sqlite_rc: %d", buf, 8u);
    }
  }
}

void sub_241A466B8(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::__tree<std::__value_type<std::string,CLSqliteDatabaseManager::ConnectionState>,std::__map_value_compare<std::string,std::__value_type<std::string,CLSqliteDatabaseManager::ConnectionState>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,CLSqliteDatabaseManager::ConnectionState>>>::destroy(v1, *(_QWORD **)(v1 + 8));
  _Unwind_Resume(a1);
}

uint64_t CLSqliteDatabaseManager::openDatabase(unsigned __int8 *a1, int *a2, const char *a3, sqlite3 **a4)
{
  int v4;
  __objc2_class *v5;
  __objc2_class *v6;
  int v10;
  NSObject *vtable;
  int v12;
  int v13;
  const char *v14;
  uint64_t v15;
  NSObject *v16;
  const char *v17;
  NSObject *v18;
  NSObject *v19;
  char v20;
  int v21;
  _QWORD *v22;
  void **v23;
  NSObject *v24;
  sqlite3 *v25;
  NSObject *v26;
  NSObject *v27;
  const char *v28;
  NSObject *v29;
  int v30;
  NSObject *v31;
  NSObject *v32;
  NSObject *v33;
  NSObject *v34;
  int v35;
  int v36;
  NSObject *v37;
  NSObject *v38;
  int v39;
  int v40;
  int v41;
  NSObject *v42;
  int v43;
  int v44;
  NSObject *v45;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  char v51;
  int *v53;
  void *__p[2];
  char v55;
  uint8_t v56[4];
  int v57;
  __int16 v58;
  int v59;
  uint8_t buf[8];
  __int16 v61;
  _BYTE v62[22];
  void *v63;
  char v64;
  _QWORD v65[22];

  v65[20] = *MEMORY[0x24BDAC8D0];
  if (!BasicMutex::__assertOwned((BasicMutex *)(a1 + 24)))
  {
    CLSqliteDatabaseManager::openDatabase();
    __break(1u);
    goto LABEL_115;
  }
  if (*((_BYTE *)a2 + 8))
    v4 = 1;
  else
    v4 = 6;
  v10 = *a2;
  v6 = ULRapportMonitor;
  v5 = ULRapportMonitor;
  v53 = a2;
  if (*a2 == 3)
  {
    v51 = 0;
    v12 = 3145728;
  }
  else if (v10 == 2)
  {
    v51 = 0;
    v12 = 0x200000;
  }
  else
  {
    if (v10 == 1)
    {
      if (onceToken_MicroLocation_Default == -1)
      {
LABEL_9:
        vtable = v5[96].vtable;
        if (os_log_type_enabled(vtable, OS_LOG_TYPE_FAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl(&dword_2419D9000, vtable, OS_LOG_TYPE_FAULT, "Attempted to open an encrypted database", buf, 2u);
        }
        v51 = 0;
        v12 = 0x100000;
        goto LABEL_15;
      }
LABEL_115:
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_16);
      goto LABEL_9;
    }
    v51 = 1;
    v12 = 0x400000;
  }
LABEL_15:
  v13 = v4 | v12 | 0x20000;
  v50 = *MEMORY[0x24BEDB7F0];
  v48 = *(_QWORD *)(MEMORY[0x24BEDB7F0] + 72);
  v49 = *(_QWORD *)(MEMORY[0x24BEDB7F0] + 64);
  v47 = MEMORY[0x24BEDB848] + 16;
  while (1)
  {
    while (1)
    {
      if (a3[23] >= 0)
        v14 = a3;
      else
        v14 = *(const char **)a3;
      v15 = sqlite3_open_v2(v14, a4, v13, 0);
      if (v6[97].isa != (__objc2_class *)-1)
        dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_16);
      v16 = v5[96].vtable;
      if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
      {
        if (a3[23] >= 0)
          v17 = a3;
        else
          v17 = *(const char **)a3;
        *(_DWORD *)buf = 67109378;
        *(_DWORD *)&buf[4] = v15;
        v61 = 2080;
        *(_QWORD *)v62 = v17;
        _os_log_impl(&dword_2419D9000, v16, OS_LOG_TYPE_DEFAULT, "openDatabase. sqlite_rc: %d, path: %s", buf, 0x12u);
      }
      if (!(_DWORD)v15)
      {
        if (!*((_BYTE *)v53 + 8))
          CLSqliteDatabase::setIncrementalVacuumEnabled((CLSqliteDatabase *)*a4, (sqlite3 *)a1[41]);
        v15 = sqlite3_exec(*a4, "pragma page_size = 4096;", 0, 0, 0);
        if (v6[97].isa != (__objc2_class *)-1)
          dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_16);
        v18 = v5[96].vtable;
        if (os_log_type_enabled(v18, OS_LOG_TYPE_INFO))
        {
          *(_DWORD *)buf = 67109120;
          *(_DWORD *)&buf[4] = v15;
          _os_log_impl(&dword_2419D9000, v18, OS_LOG_TYPE_INFO, "pragma page_size = 4096. sqlite_rc: %d", buf, 8u);
        }
        if (!(_DWORD)v15)
        {
          if (*((_BYTE *)v53 + 8))
          {
            v15 = 0;
          }
          else
          {
            v15 = sqlite3_exec(*a4, "pragma journal_mode=WAL;", 0, 0, 0);
            if (v6[97].isa != (__objc2_class *)-1)
              dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_16);
            v19 = v5[96].vtable;
            if (os_log_type_enabled(v19, OS_LOG_TYPE_INFO))
            {
              *(_DWORD *)buf = 67109120;
              *(_DWORD *)&buf[4] = v15;
              _os_log_impl(&dword_2419D9000, v19, OS_LOG_TYPE_INFO, "pragma journal_mode=WAL. sqlite_rc: %d", buf, 8u);
            }
          }
          v20 = v51;
          if ((_DWORD)v15)
            v20 = 1;
          if ((v20 & 1) == 0)
          {
            std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)buf);
            v21 = a1[40];
            std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v62[6], (uint64_t)"pragma secure_delete = ", 23);
            v22 = (_QWORD *)std::ostream::operator<<();
            std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v22, (uint64_t)";", 1);
            std::stringbuf::str();
            if (v55 >= 0)
              v23 = __p;
            else
              v23 = (void **)__p[0];
            v15 = sqlite3_exec(*a4, (const char *)v23, 0, 0, 0);
            if (v6[97].isa != (__objc2_class *)-1)
              dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_16);
            v24 = v5[96].vtable;
            if (os_log_type_enabled(v24, OS_LOG_TYPE_INFO))
            {
              *(_DWORD *)v56 = 67109376;
              v57 = v21;
              v58 = 1024;
              v59 = v15;
              _os_log_impl(&dword_2419D9000, v24, OS_LOG_TYPE_INFO, "pragma secure_delete. useSecureDelete: %d, sqlite_rc: %d", v56, 0xEu);
            }
            if (v55 < 0)
              operator delete(__p[0]);
            *(_QWORD *)buf = v50;
            *(_QWORD *)&buf[*(_QWORD *)(v50 - 24)] = v49;
            *(_QWORD *)&v62[6] = v48;
            *(_QWORD *)&v62[14] = v47;
            if (v64 < 0)
              operator delete(v63);
            std::streambuf::~streambuf();
            std::iostream::~basic_iostream();
            MEMORY[0x2426A0444](v65);
          }
          if (!(_DWORD)v15)
          {
            v25 = *a4;
            if (*((_BYTE *)v53 + 8))
            {
              v15 = sqlite3_exec(v25, "pragma cache_size = 5;", 0, 0, 0);
              if (v6[97].isa != (__objc2_class *)-1)
                dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_16);
              v26 = v5[96].vtable;
              if (os_log_type_enabled(v26, OS_LOG_TYPE_INFO))
              {
                *(_DWORD *)buf = 67109120;
                *(_DWORD *)&buf[4] = v15;
                v27 = v26;
                v28 = "pragma cache_size = 5. sqlite_rc: %d";
LABEL_61:
                _os_log_impl(&dword_2419D9000, v27, OS_LOG_TYPE_INFO, v28, buf, 8u);
                goto LABEL_62;
              }
              goto LABEL_62;
            }
            v15 = sqlite3_exec(v25, "pragma cache_size = 50;", 0, 0, 0);
            if (v6[97].isa != (__objc2_class *)-1)
              dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_16);
            v33 = v5[96].vtable;
            if (os_log_type_enabled(v33, OS_LOG_TYPE_INFO))
            {
              *(_DWORD *)buf = 67109120;
              *(_DWORD *)&buf[4] = v15;
              _os_log_impl(&dword_2419D9000, v33, OS_LOG_TYPE_INFO, "pragma cache_size = 50. sqlite_rc: %d", buf, 8u);
            }
            if (!(_DWORD)v15)
              break;
          }
        }
      }
LABEL_83:
      if (v6[97].isa != (__objc2_class *)-1)
        dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_16);
      v34 = v5[96].vtable;
      if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
      {
        v35 = *__error();
        *(_DWORD *)buf = 67109376;
        *(_DWORD *)&buf[4] = v35;
        v61 = 1024;
        *(_DWORD *)v62 = v15;
        _os_log_impl(&dword_2419D9000, v34, OS_LOG_TYPE_DEFAULT, "failed to obtain database handle. errno: %d, sqlite_rc: %d", buf, 0xEu);
      }

      v36 = sqlite3_close(*a4);
      if (v36)
      {
        if (v6[97].isa != (__objc2_class *)-1)
          dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_16);
        v37 = v5[96].vtable;
        if (os_log_type_enabled(v37, OS_LOG_TYPE_FAULT))
        {
          *(_DWORD *)buf = 67109120;
          *(_DWORD *)&buf[4] = v36;
          _os_log_impl(&dword_2419D9000, v37, OS_LOG_TYPE_FAULT, "Failed to close partially opened database. sqlite_rc: %d", buf, 8u);
        }
      }
      *a4 = 0;
      if ((_DWORD)v15 != 10 && (_DWORD)v15 != 13)
        return v15;
      sleepAfterSqliteReadOnlyMismatch();
    }
    v15 = sqlite3_exec(*a4, "pragma cache_spill = 500;", 0, 0, 0);
    if (v6[97].isa != (__objc2_class *)-1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_16);
    v38 = v5[96].vtable;
    if (os_log_type_enabled(v38, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 67109120;
      *(_DWORD *)&buf[4] = v15;
      v27 = v38;
      v28 = "pragma cache_spill = 500. sqlite_rc: %d";
      goto LABEL_61;
    }
LABEL_62:
    if ((_DWORD)v15)
      goto LABEL_83;
    v15 = sqlite3_exec(*a4, "pragma recursive_triggers = true;", 0, 0, 0);
    if (v6[97].isa != (__objc2_class *)-1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_16);
    v29 = v5[96].vtable;
    if (os_log_type_enabled(v29, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 67109120;
      *(_DWORD *)&buf[4] = v15;
      _os_log_impl(&dword_2419D9000, v29, OS_LOG_TYPE_INFO, "pragma recursive_triggers = true. sqlite_rc: %d", buf, 8u);
    }
    if ((_DWORD)v15)
      goto LABEL_83;
    sqlite3_limit(*a4, 10, 10);
    v30 = sqlite3_limit(*a4, 10, -1);
    if (v30 != 10)
    {
      if (v6[97].isa != (__objc2_class *)-1)
        dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_16);
      v31 = v5[96].vtable;
      if (os_log_type_enabled(v31, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)buf = 67109376;
        *(_DWORD *)&buf[4] = 10;
        v61 = 1024;
        *(_DWORD *)v62 = v30;
        _os_log_impl(&dword_2419D9000, v31, OS_LOG_TYPE_FAULT, "Trigger depth. expected: %d, actual: %d", buf, 0xEu);
      }
    }
    v15 = sqlite3_extended_result_codes(*a4, 1);
    if ((_DWORD)v15)
    {
      if (v6[97].isa != (__objc2_class *)-1)
        dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_16);
      v32 = v5[96].vtable;
      if (os_log_type_enabled(v32, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)buf = 67109120;
        *(_DWORD *)&buf[4] = v15;
        _os_log_impl(&dword_2419D9000, v32, OS_LOG_TYPE_FAULT, "Failed to enable extended result codes. sqlite_rc: %d", buf, 8u);
      }
      goto LABEL_83;
    }
    LODWORD(__p[0]) = -1;
    v39 = sqlite3_file_control(*a4, "main", 4, __p);
    v40 = sqlite3_db_readonly(*a4, "main");
    if (*((_BYTE *)v53 + 8))
      return 0;
    v41 = v40;
    if (v40 <= 0)
      return 0;
    if (v6[97].isa != (__objc2_class *)-1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_16);
    v42 = v5[96].vtable;
    if (os_log_type_enabled(v42, OS_LOG_TYPE_FAULT))
    {
      v43 = *((unsigned __int8 *)v53 + 8);
      *(_DWORD *)buf = 67109888;
      *(_DWORD *)&buf[4] = v43;
      v61 = 1024;
      *(_DWORD *)v62 = v41;
      *(_WORD *)&v62[4] = 1024;
      *(_DWORD *)&v62[6] = __p[0];
      *(_WORD *)&v62[10] = 1024;
      *(_DWORD *)&v62[12] = v39;
      _os_log_impl(&dword_2419D9000, v42, OS_LOG_TYPE_FAULT, "Database opened with read/write access was found to be read-only. properties.readOnly: %d, sqlite3_db_readonly: %d, last POSIX errNo: %d, File control rc: %d", buf, 0x1Au);
    }
    v44 = sqlite3_close(*a4);
    if (v44)
    {
      if (v6[97].isa != (__objc2_class *)-1)
        dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_16);
      v45 = v5[96].vtable;
      if (os_log_type_enabled(v45, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)buf = 67109120;
        *(_DWORD *)&buf[4] = v44;
        _os_log_impl(&dword_2419D9000, v45, OS_LOG_TYPE_FAULT, "Failed to close partially opened database. sqlite_rc: %d", buf, 8u);
      }
    }
    *a4 = 0;
    sleepAfterSqliteReadOnlyMismatch();
  }
}

void sub_241A471E4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,void *__p,uint64_t a27,int a28,__int16 a29,char a30,char a31,uint64_t a32,uint64_t a33,char a34)
{
  if (a31 < 0)
    operator delete(__p);
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream((uint64_t)&a34);
  _Unwind_Resume(a1);
}

uint64_t CLSqliteDatabaseManager::useIncrementalVacuum(CLSqliteDatabaseManager *this)
{
  return *((unsigned __int8 *)this + 41);
}

uint64_t sleepAfterSqliteReadOnlyMismatch(void)
{
  return sleep(5u);
}

uint64_t CLSqliteDatabaseManager::openDatabase(uint64_t a1, uint64_t *a2, const void **a3, uint64_t a4)
{
  uint64_t v8;
  NSObject *v9;
  std::string::size_type v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  NSObject *v15;
  BasicMutex *v16;
  BasicMutex *v17;
  const char *v18;
  __int128 v19;
  NSObject *v20;
  std::string::size_type v21;
  int v22;
  uint64_t v24;
  __int16 v25;
  std::string __p;
  __int128 v27;
  _BYTE *v28;
  std::string v29;
  int v30;
  std::string v31;
  uint64_t v32;
  pthread_mutex_t *v33;
  __int16 v34;
  std::string buf[2];
  void *v36;
  char v37;
  void *v38;
  char v39;
  uint64_t v40;

  v40 = *MEMORY[0x24BDAC8D0];
  v8 = *(_QWORD *)(a1 + 24);
  v32 = a1 + 24;
  (*(void (**)(void))(v8 + 16))();
  v34 = 256;
  if (onceToken_MicroLocation_Default != -1)
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_16);
  v9 = logObject_MicroLocation_Default;
  if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_INFO))
  {
    if (*((char *)a3 + 23) >= 0)
      v10 = (std::string::size_type)a3;
    else
      v10 = (std::string::size_type)*a3;
    LODWORD(buf[0].__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)buf[0].__r_.__value_.__r.__words + 4) = v10;
    _os_log_impl(&dword_2419D9000, v9, OS_LOG_TYPE_INFO, "Opening database. path: %s", (uint8_t *)buf, 0xCu);
  }
  v11 = std::__tree<std::__value_type<std::string,CLSqliteDatabaseManager::ConnectionState>,std::__map_value_compare<std::string,std::__value_type<std::string,CLSqliteDatabaseManager::ConnectionState>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,CLSqliteDatabaseManager::ConnectionState>>>::find<std::string>(a1, a3);
  v12 = a1 + 8;
  if (a1 + 8 != v11)
  {
    v13 = 0;
    goto LABEL_34;
  }
  memset(&v31, 0, sizeof(v31));
  memset(&v29, 0, sizeof(v29));
  v30 = 0;
  std::string::operator=(&v31, (const std::string *)a3);
  *(_QWORD *)&v27 = 0;
  v24 = *a2;
  v25 = *((_WORD *)a2 + 4);
  if (*((char *)a2 + 39) < 0)
    std::string::__init_copy_ctor_external(&__p, (const std::string::value_type *)a2[2], a2[3]);
  else
    __p = *(std::string *)(a2 + 2);
  v14 = CLSqliteDatabaseManager::openDatabase((unsigned __int8 *)a1, (int *)&v24, (const char *)a3, (sqlite3 **)&v27);
  v13 = v14;
  if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if ((_DWORD)v14)
      goto LABEL_15;
LABEL_21:
    v16 = (BasicMutex *)operator new();
    v17 = v16;
    if (*((char *)a3 + 23) >= 0)
      v18 = (const char *)a3;
    else
      v18 = (const char *)*a3;
    BasicMutex::BasicMutex(v16, v18, 1, 1);
    *((_QWORD *)&v27 + 1) = v17;
    v28 = (_BYTE *)operator new();
    *v28 = 0;
    std::string::operator=(&v29, (const std::string *)a3);
    std::pair<std::string,CLSqliteDatabaseManager::ConnectionState>::pair[abi:ne180100]<std::string const&,CLSqliteDatabaseManager::ConnectionState&,0>(buf, (__int128 *)a3, &v27);
    v11 = (uint64_t)std::__tree<std::__value_type<std::string,CLSqliteDatabaseManager::ConnectionState>,std::__map_value_compare<std::string,std::__value_type<std::string,CLSqliteDatabaseManager::ConnectionState>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,CLSqliteDatabaseManager::ConnectionState>>>::__emplace_unique_key_args<std::string,std::pair<std::string,CLSqliteDatabaseManager::ConnectionState>>((uint64_t **)a1, (const void **)&buf[0].__r_.__value_.__l.__data_, (uint64_t)buf);
    if (v39 < 0)
      operator delete(v38);
    if (v37 < 0)
      operator delete(v36);
    if (SHIBYTE(buf[0].__r_.__value_.__r.__words[2]) < 0)
      operator delete(buf[0].__r_.__value_.__l.__data_);
    goto LABEL_30;
  }
  operator delete(__p.__r_.__value_.__l.__data_);
  if (!(_DWORD)v13)
    goto LABEL_21;
LABEL_15:
  if ((_QWORD)v27)
  {
    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_16);
    v15 = logObject_MicroLocation_Default;
    if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_FAULT))
    {
      LOWORD(buf[0].__r_.__value_.__l.__data_) = 0;
      _os_log_impl(&dword_2419D9000, v15, OS_LOG_TYPE_FAULT, "openDatabase failed to open a connection and then to clean up after itself", (uint8_t *)buf, 2u);
    }
  }
LABEL_30:
  if (SHIBYTE(v31.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v31.__r_.__value_.__l.__data_);
  if (SHIBYTE(v29.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v29.__r_.__value_.__l.__data_);
LABEL_34:
  if (v11 == v12)
    goto LABEL_43;
  v19 = *(_OWORD *)(v11 + 56);
  *(_QWORD *)(a4 + 16) = *(_QWORD *)(v11 + 72);
  *(_OWORD *)a4 = v19;
  std::string::operator=((std::string *)(a4 + 24), (const std::string *)(v11 + 80));
  ++*(_DWORD *)(v11 + 104);
  if (onceToken_MicroLocation_Default != -1)
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_16);
  v20 = logObject_MicroLocation_Default;
  if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_INFO))
  {
    if (*((char *)a3 + 23) >= 0)
      v21 = (std::string::size_type)a3;
    else
      v21 = (std::string::size_type)*a3;
    v22 = *(_DWORD *)(v11 + 104);
    LODWORD(buf[0].__r_.__value_.__l.__data_) = 136315394;
    *(std::string::size_type *)((char *)buf[0].__r_.__value_.__r.__words + 4) = v21;
    WORD2(buf[0].__r_.__value_.__r.__words[1]) = 1024;
    *(_DWORD *)((char *)&buf[0].__r_.__value_.__r.__words[1] + 6) = v22;
    _os_log_impl(&dword_2419D9000, v20, OS_LOG_TYPE_INFO, "Reference count increased. path: %s, referenceCount: %d", (uint8_t *)buf, 0x12u);
  }
  if (HIBYTE(v34))
  {
LABEL_43:
    if ((_BYTE)v34)
      pthread_mutex_unlock(v33);
    else
      (*(void (**)(uint64_t))(*(_QWORD *)v32 + 24))(v32);
  }
  return v13;
}

void sub_241A47658(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, void *a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,pthread_mutex_t *a27,uint64_t a28,uint64_t a29,char a30)
{
  std::pair<std::string,CLSqliteDatabaseManager::ConnectionState>::~pair((uint64_t)&a30);
  CLSqliteDatabaseManager::ConnectionState::~ConnectionState(&a17);
  AutoLocker::~AutoLocker(&a27);
  _Unwind_Resume(a1);
}

uint64_t std::pair<std::string,CLSqliteDatabaseManager::ConnectionState>::~pair(uint64_t a1)
{
  if (*(char *)(a1 + 103) < 0)
    operator delete(*(void **)(a1 + 80));
  if (*(char *)(a1 + 71) < 0)
    operator delete(*(void **)(a1 + 48));
  if (*(char *)(a1 + 23) < 0)
    operator delete(*(void **)a1);
  return a1;
}

void CLSqliteDatabaseManager::ConnectionState::~ConnectionState(void **this)
{
  if (*((char *)this + 79) < 0)
    operator delete(this[7]);
  if (*((char *)this + 47) < 0)
    operator delete(this[3]);
}

void AutoLocker::~AutoLocker(pthread_mutex_t **this)
{
  if (*((_BYTE *)this + 17))
  {
    if (*((_BYTE *)this + 16))
      pthread_mutex_unlock(this[1]);
    else
      (*(void (**)(void))((*this)->__sig + 24))();
    *((_BYTE *)this + 17) = 0;
  }
}

void CLSqliteDatabaseManager::closeDatabase(CLSqliteDatabaseManager *this, sqlite3 *a2)
{
  CLSqliteDatabaseManager *v4;
  CLSqliteDatabaseManager *v5;
  CLSqliteDatabaseManager *v6;
  BOOL v7;
  NSObject *v8;
  _QWORD *v9;
  int v10;
  NSObject *v11;
  _QWORD *v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  uint8_t buf[4];
  _QWORD *v17;
  __int16 v18;
  int v19;
  uint64_t v20;

  v20 = *MEMORY[0x24BDAC8D0];
  v15 = (char *)this + 24;
  (*(void (**)(void))(*((_QWORD *)this + 3) + 16))();
  v4 = *(CLSqliteDatabaseManager **)this;
  if (*(CLSqliteDatabaseManager **)this != (CLSqliteDatabaseManager *)((char *)this + 8))
  {
    while (*((sqlite3 **)v4 + 7) != a2)
    {
      v5 = (CLSqliteDatabaseManager *)*((_QWORD *)v4 + 1);
      if (v5)
      {
        do
        {
          v6 = v5;
          v5 = *(CLSqliteDatabaseManager **)v5;
        }
        while (v5);
      }
      else
      {
        do
        {
          v6 = (CLSqliteDatabaseManager *)*((_QWORD *)v4 + 2);
          v7 = *(_QWORD *)v6 == (_QWORD)v4;
          v4 = v6;
        }
        while (!v7);
      }
      v4 = v6;
      if (v6 == (CLSqliteDatabaseManager *)((char *)this + 8))
        goto LABEL_28;
    }
    --*((_DWORD *)v4 + 26);
    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_16);
    v8 = logObject_MicroLocation_Default;
    if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_INFO))
    {
      v9 = (_QWORD *)((char *)v4 + 112);
      if (*((char *)v4 + 135) < 0)
        v9 = (_QWORD *)*v9;
      v10 = *((_DWORD *)v4 + 26);
      *(_DWORD *)buf = 136315394;
      v17 = v9;
      v18 = 1024;
      v19 = v10;
      _os_log_impl(&dword_2419D9000, v8, OS_LOG_TYPE_INFO, "Reference count decreased. path: %s, referenceCount: %d", buf, 0x12u);
    }
    if (!*((_DWORD *)v4 + 26))
    {
      if (onceToken_MicroLocation_Default != -1)
        dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_16);
      v11 = logObject_MicroLocation_Default;
      if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT))
      {
        v12 = (_QWORD *)((char *)v4 + 112);
        if (*((char *)v4 + 135) < 0)
          v12 = (_QWORD *)*v12;
        *(_DWORD *)buf = 136315138;
        v17 = v12;
        _os_log_impl(&dword_2419D9000, v11, OS_LOG_TYPE_DEFAULT, "Destroying database. path: %s", buf, 0xCu);
      }
      sqlite3_close(a2);
      v13 = *((_QWORD *)v4 + 8);
      if (v13)
        (*(void (**)(uint64_t))(*(_QWORD *)v13 + 8))(v13);
      v14 = *((_QWORD *)v4 + 9);
      if (v14)
        MEMORY[0x2426A04D4](v14, 0x1000C4077774924);
      std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::__remove_node_pointer((uint64_t **)this, (uint64_t *)v4);
      std::__destroy_at[abi:ne180100]<std::pair<std::string const,CLSqliteDatabaseManager::ConnectionState>,0>((uint64_t)v4 + 32);
      operator delete(v4);
    }
  }
LABEL_28:
  (*(void (**)(char *))(*(_QWORD *)v15 + 24))(v15);
}

void sub_241A47A3C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  AutoLocker::~AutoLocker((pthread_mutex_t **)va);
  _Unwind_Resume(a1);
}

void ___ZL45_CLLogObjectForCategory_MicroLocation_Defaultv_block_invoke_30()
{
  os_log_t v0;
  void *v1;

  v0 = os_log_create("com.apple.MicroLocation", "MicroLocation");
  v1 = (void *)logObject_MicroLocation_Default;
  logObject_MicroLocation_Default = (uint64_t)v0;

}

std::string *std::pair<std::string,CLSqliteDatabaseManager::ConnectionState>::pair[abi:ne180100]<std::string const&,CLSqliteDatabaseManager::ConnectionState&,0>(std::string *this, __int128 *a2, __int128 *a3)
{
  __int128 v5;
  __int128 v6;
  __int128 v7;
  std::string *v8;
  __int128 v9;

  if (*((char *)a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(this, *(const std::string::value_type **)a2, *((_QWORD *)a2 + 1));
  }
  else
  {
    v5 = *a2;
    this->__r_.__value_.__r.__words[2] = *((_QWORD *)a2 + 2);
    *(_OWORD *)&this->__r_.__value_.__l.__data_ = v5;
  }
  v6 = *a3;
  this[1].__r_.__value_.__r.__words[2] = *((_QWORD *)a3 + 2);
  *(_OWORD *)&this[1].__r_.__value_.__l.__data_ = v6;
  if (*((char *)a3 + 47) < 0)
  {
    std::string::__init_copy_ctor_external(this + 2, *((const std::string::value_type **)a3 + 3), *((_QWORD *)a3 + 4));
  }
  else
  {
    v7 = *(__int128 *)((char *)a3 + 24);
    this[2].__r_.__value_.__r.__words[2] = *((_QWORD *)a3 + 5);
    *(_OWORD *)&this[2].__r_.__value_.__l.__data_ = v7;
  }
  LODWORD(this[3].__r_.__value_.__l.__data_) = *((_DWORD *)a3 + 12);
  v8 = (std::string *)((char *)this + 80);
  if (*((char *)a3 + 79) < 0)
  {
    std::string::__init_copy_ctor_external(v8, *((const std::string::value_type **)a3 + 7), *((_QWORD *)a3 + 8));
  }
  else
  {
    v9 = *(__int128 *)((char *)a3 + 56);
    this[4].__r_.__value_.__r.__words[0] = *((_QWORD *)a3 + 9);
    *(_OWORD *)&v8->__r_.__value_.__l.__data_ = v9;
  }
  return this;
}

void sub_241A47B60(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void **v2;

  if (*(char *)(v1 + 71) < 0)
    operator delete(*v2);
  if (*(char *)(v1 + 23) < 0)
    operator delete(*(void **)v1);
  _Unwind_Resume(exception_object);
}

void std::__tree<std::__value_type<std::string,CLSqliteDatabaseManager::ConnectionState>,std::__map_value_compare<std::string,std::__value_type<std::string,CLSqliteDatabaseManager::ConnectionState>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,CLSqliteDatabaseManager::ConnectionState>>>::destroy(uint64_t a1, _QWORD *a2)
{
  if (a2)
  {
    std::__tree<std::__value_type<std::string,CLSqliteDatabaseManager::ConnectionState>,std::__map_value_compare<std::string,std::__value_type<std::string,CLSqliteDatabaseManager::ConnectionState>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,CLSqliteDatabaseManager::ConnectionState>>>::destroy(a1, *a2);
    std::__tree<std::__value_type<std::string,CLSqliteDatabaseManager::ConnectionState>,std::__map_value_compare<std::string,std::__value_type<std::string,CLSqliteDatabaseManager::ConnectionState>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,CLSqliteDatabaseManager::ConnectionState>>>::destroy(a1, a2[1]);
    std::__destroy_at[abi:ne180100]<std::pair<std::string const,CLSqliteDatabaseManager::ConnectionState>,0>((uint64_t)(a2 + 4));
    operator delete(a2);
  }
}

void std::__destroy_at[abi:ne180100]<std::pair<std::string const,CLSqliteDatabaseManager::ConnectionState>,0>(uint64_t a1)
{
  if (*(char *)(a1 + 103) < 0)
    operator delete(*(void **)(a1 + 80));
  if (*(char *)(a1 + 71) < 0)
    operator delete(*(void **)(a1 + 48));
  if (*(char *)(a1 + 23) < 0)
    operator delete(*(void **)a1);
}

uint64_t std::__tree<std::__value_type<std::string,CLSqliteDatabaseManager::ConnectionState>,std::__map_value_compare<std::string,std::__value_type<std::string,CLSqliteDatabaseManager::ConnectionState>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,CLSqliteDatabaseManager::ConnectionState>>>::find<std::string>(uint64_t a1, const void **a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v5;
  uint64_t v6;
  _BOOL4 v7;
  uint64_t *v8;

  v2 = a1 + 8;
  v3 = *(_QWORD *)(a1 + 8);
  if (!v3)
    return v2;
  v5 = a1 + 16;
  v6 = a1 + 8;
  do
  {
    v7 = std::less<std::string>::operator()[abi:ne180100](v5, (const void **)(v3 + 32), a2);
    v8 = (uint64_t *)(v3 + 8);
    if (!v7)
    {
      v8 = (uint64_t *)v3;
      v6 = v3;
    }
    v3 = *v8;
  }
  while (*v8);
  if (v6 == v2 || std::less<std::string>::operator()[abi:ne180100](v5, a2, (const void **)(v6 + 32)))
    return v2;
  return v6;
}

BOOL std::less<std::string>::operator()[abi:ne180100](uint64_t a1, const void **a2, const void **a3)
{
  int v3;
  int v4;
  size_t v5;
  const void *v6;
  size_t v7;
  const void *v8;
  size_t v9;
  int v10;

  v3 = *((char *)a3 + 23);
  v4 = *((char *)a2 + 23);
  if (v4 >= 0)
    v5 = *((unsigned __int8 *)a2 + 23);
  else
    v5 = (size_t)a2[1];
  if (v4 >= 0)
    v6 = a2;
  else
    v6 = *a2;
  if (v3 >= 0)
    v7 = *((unsigned __int8 *)a3 + 23);
  else
    v7 = (size_t)a3[1];
  if (v3 >= 0)
    v8 = a3;
  else
    v8 = *a3;
  if (v7 >= v5)
    v9 = v5;
  else
    v9 = v7;
  v10 = memcmp(v6, v8, v9);
  if (v10)
    return v10 < 0;
  else
    return v5 < v7;
}

_OWORD *std::__tree<std::__value_type<std::string,CLSqliteDatabaseManager::ConnectionState>,std::__map_value_compare<std::string,std::__value_type<std::string,CLSqliteDatabaseManager::ConnectionState>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,CLSqliteDatabaseManager::ConnectionState>>>::__emplace_unique_key_args<std::string,std::pair<std::string,CLSqliteDatabaseManager::ConnectionState>>(uint64_t **a1, const void **a2, uint64_t a3)
{
  void **v5;
  _OWORD *v6;
  uint64_t **v7;
  __int128 v8;
  _QWORD v10[2];
  char v11;
  uint64_t v12;

  v5 = (void **)std::__tree<std::__value_type<std::string,CLSqliteDatabaseManager::ConnectionState>,std::__map_value_compare<std::string,std::__value_type<std::string,CLSqliteDatabaseManager::ConnectionState>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,CLSqliteDatabaseManager::ConnectionState>>>::__find_equal<std::string>((uint64_t)a1, &v12, a2);
  v6 = *v5;
  if (!*v5)
  {
    v7 = (uint64_t **)v5;
    v6 = operator new(0x88uLL);
    v10[1] = a1 + 1;
    v6[2] = *(_OWORD *)a3;
    *((_QWORD *)v6 + 6) = *(_QWORD *)(a3 + 16);
    *(_QWORD *)a3 = 0;
    *(_QWORD *)(a3 + 8) = 0;
    *(_QWORD *)(a3 + 16) = 0;
    *(_OWORD *)((char *)v6 + 56) = *(_OWORD *)(a3 + 24);
    *((_QWORD *)v6 + 9) = *(_QWORD *)(a3 + 40);
    *((_QWORD *)v6 + 12) = *(_QWORD *)(a3 + 64);
    v6[5] = *(_OWORD *)(a3 + 48);
    *(_QWORD *)(a3 + 56) = 0;
    *(_QWORD *)(a3 + 64) = 0;
    *(_QWORD *)(a3 + 48) = 0;
    *((_DWORD *)v6 + 26) = *(_DWORD *)(a3 + 72);
    v8 = *(_OWORD *)(a3 + 80);
    *((_QWORD *)v6 + 16) = *(_QWORD *)(a3 + 96);
    v6[7] = v8;
    *(_QWORD *)(a3 + 80) = 0;
    *(_QWORD *)(a3 + 88) = 0;
    *(_QWORD *)(a3 + 96) = 0;
    v11 = 1;
    std::__tree<CLMicroLocationRecordingCompletionMetaInformation::RecordingError>::__insert_node_at(a1, v12, v7, (uint64_t *)v6);
    v10[0] = 0;
    std::unique_ptr<std::__tree_node<std::__value_type<std::string,CLSqliteDatabaseManager::ConnectionState>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::string,CLSqliteDatabaseManager::ConnectionState>,void *>>>>::reset[abi:ne180100]((uint64_t)v10, 0);
  }
  return v6;
}

_QWORD *std::__tree<std::__value_type<std::string,CLSqliteDatabaseManager::ConnectionState>,std::__map_value_compare<std::string,std::__value_type<std::string,CLSqliteDatabaseManager::ConnectionState>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,CLSqliteDatabaseManager::ConnectionState>>>::__find_equal<std::string>(uint64_t a1, _QWORD *a2, const void **a3)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v7;
  _QWORD *v8;
  const void **v9;

  v5 = (_QWORD *)(a1 + 8);
  v4 = *(_QWORD *)(a1 + 8);
  if (v4)
  {
    v7 = a1 + 16;
    do
    {
      while (1)
      {
        v8 = (_QWORD *)v4;
        v9 = (const void **)(v4 + 32);
        if (!std::less<std::string>::operator()[abi:ne180100](v7, a3, (const void **)(v4 + 32)))
          break;
        v4 = *v8;
        v5 = v8;
        if (!*v8)
          goto LABEL_10;
      }
      if (!std::less<std::string>::operator()[abi:ne180100](v7, v9, a3))
        break;
      v5 = v8 + 1;
      v4 = v8[1];
    }
    while (v4);
  }
  else
  {
    v8 = (_QWORD *)(a1 + 8);
  }
LABEL_10:
  *a2 = v8;
  return v5;
}

void std::unique_ptr<std::__tree_node<std::__value_type<std::string,CLSqliteDatabaseManager::ConnectionState>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::string,CLSqliteDatabaseManager::ConnectionState>,void *>>>>::reset[abi:ne180100](uint64_t a1, uint64_t a2)
{
  void *v2;

  v2 = *(void **)a1;
  *(_QWORD *)a1 = a2;
  if (v2)
  {
    if (*(_BYTE *)(a1 + 16))
      std::__destroy_at[abi:ne180100]<std::pair<std::string const,CLSqliteDatabaseManager::ConnectionState>,0>((uint64_t)v2 + 32);
    operator delete(v2);
  }
}

void sub_241A481FC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_241A484D4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28,void *a29,uint64_t a30,int a31,__int16 a32,char a33,char a34)
{
  CLMicroLocationProto::Configuration::~Configuration((CLMicroLocationProto::Configuration *)&a16);
  if (a28 < 0)
    operator delete(__p);
  _Unwind_Resume(a1);
}

void CLMicroLocationConfigurationTable::Entry::~Entry(void **this)
{
  CLMicroLocationProto::Configuration::~Configuration((CLMicroLocationProto::Configuration *)(this + 7));
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

void ___ZL45_CLLogObjectForCategory_MicroLocation_Defaultv_block_invoke_31()
{
  os_log_t v0;
  void *v1;

  v0 = os_log_create("com.apple.MicroLocation", "MicroLocation");
  v1 = (void *)logObject_MicroLocation_Default;
  logObject_MicroLocation_Default = (uint64_t)v0;

}

void CLMicroLocationLegacyEventLocalizationRequest::handleEvent(const std::string *a1@<X1>, double *a2@<X2>, char *a3@<X8>)
{
  std::string *v6;
  int v7;
  unint64_t v8;
  unint64_t v9;
  int v10;
  uint64_t v11;
  _BYTE v12[144];
  char v13;
  _BYTE v14[144];
  _BYTE v15[12];
  int v16;
  std::string *v17;
  int v18;

  CLMicroLocationProto::ReceivedEventAction::ReceivedEventAction((CLMicroLocationProto::ReceivedEventAction *)v15);
  v18 |= 4u;
  v6 = v17;
  if (v17 == (std::string *)MEMORY[0x24BEDD958])
  {
    v6 = (std::string *)operator new();
    v6->__r_.__value_.__r.__words[0] = 0;
    v6->__r_.__value_.__l.__size_ = 0;
    v6->__r_.__value_.__r.__words[2] = 0;
    v17 = v6;
  }
  std::string::operator=(v6, a1);
  v7 = SHIBYTE(a1->__r_.__value_.__r.__words[2]);
  if (v7 < 0)
  {
    if (a1->__r_.__value_.__l.__size_ != 18)
    {
LABEL_12:
      v11 = 1;
      goto LABEL_19;
    }
    a1 = (const std::string *)a1->__r_.__value_.__r.__words[0];
  }
  else if (v7 != 18)
  {
    goto LABEL_12;
  }
  v8 = 0x4E6F746966696361;
  v9 = bswap64(a1->__r_.__value_.__r.__words[0]);
  if (v9 == 0x4E6F746966696361
    && (v8 = 0x74696F6E43656E74, v9 = bswap64(a1->__r_.__value_.__l.__size_), v9 == 0x74696F6E43656E74)
    && (v9 = bswap32(LOWORD(a1->__r_.__value_.__r.__words[2])) >> 16, v8 = 25970, (_DWORD)v9 == 25970))
  {
    v10 = 0;
  }
  else if (v9 < v8)
  {
    v10 = -1;
  }
  else
  {
    v10 = 1;
  }
  if (v10)
    v11 = 1;
  else
    v11 = 3;
LABEL_19:
  if (!CLMicroLocationProto::ReceivedEventActionType_IsValid((CLMicroLocationProto *)v11))
    __assert_rtn("set_receivedeventactiontype", "microlocation.pb.h", 13294, "::CLMicroLocationProto::ReceivedEventActionType_IsValid(value)");
  v18 |= 2u;
  v16 = v11;
  CLMicroLocationProtobufHelper::createRecordingEvent<CLMicroLocationProto::ReceivedEventAction>((CLMicroLocationProto::RecordingEvent *)v15, 0, 0, 0, (CLMicroLocationProto *)3, (uint64_t)v12, *a2);
  v13 = 1;
  CLMicroLocationProto::RecordingEvent::RecordingEvent((CLMicroLocationProto::RecordingEvent *)v14, (const CLMicroLocationProto::RecordingEvent *)v12);
  *a3 = v13;
  CLMicroLocationProto::RecordingEvent::RecordingEvent((CLMicroLocationProto::RecordingEvent *)(a3 + 8), (const CLMicroLocationProto::RecordingEvent *)v14);
  CLMicroLocationProto::RecordingEvent::~RecordingEvent((CLMicroLocationProto::RecordingEvent *)v14);
  CLMicroLocationProto::RecordingEvent::~RecordingEvent((CLMicroLocationProto::RecordingEvent *)v12);
  CLMicroLocationProto::ReceivedEventAction::~ReceivedEventAction((CLMicroLocationProto::ReceivedEventAction *)v15);
}

void sub_241A48910(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  CLMicroLocationProto::RecordingEvent *v10;
  uint64_t v11;

  CLMicroLocationProto::RecordingEvent::~RecordingEvent(v10);
  CLMicroLocationProto::RecordingEvent::~RecordingEvent((CLMicroLocationProto::RecordingEvent *)&a10);
  CLMicroLocationProto::ReceivedEventAction::~ReceivedEventAction((CLMicroLocationProto::ReceivedEventAction *)(v11 - 80));
  _Unwind_Resume(a1);
}

uint64_t CLMicroLocationLegacyClient::CLMicroLocationLegacyClient(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_BYTE *)(result + 2) = 0;
  *(_BYTE *)(result + 8) = 0;
  *(_BYTE *)(result + 16) = 0;
  *(_BYTE *)(result + 24) = 0;
  *(_BYTE *)(result + 32) = 0;
  *(_BYTE *)(result + 40) = 0;
  *(_WORD *)(result + 56) = 0;
  *(_BYTE *)(result + 73) = 0;
  *(_QWORD *)(result + 80) = a2;
  *(_QWORD *)(result + 88) = a3;
  *(_WORD *)(result + 96) = 0;
  *(_BYTE *)(result + 98) = 0;
  *(_DWORD *)(result + 100) = 255;
  *(_WORD *)(result + 104) = 0;
  return result;
}

void CLMicroLocationLegacyClient::onBatteryState(CLMicroLocationLegacyClient *a1, char a2, double *a3)
{
  CLMicroLocationEventLogger *v5;
  CLMicroLocationProto::RecordingEvent *v6;
  uint64_t v7;
  double v8;
  int *v9;
  int v10;
  _BYTE v11[8];
  _BYTE v12[40];
  int *v13;
  __int128 v14;
  Entry v15;
  _QWORD v16[39];

  v16[38] = *MEMORY[0x24BDAC8D0];
  CLMicroLocationLegacyEventBatteryState::handleEvent(a2, a3, v11);
  if (v11[0])
  {
    v5 = (CLMicroLocationEventLogger *)*((_QWORD *)a1 + 11);
    v10 = 0;
    boost::uuids::detail::random_provider_base::random_provider_base((boost::uuids::detail::random_provider_base *)&v10);
    v6 = (CLMicroLocationProto::RecordingEvent *)boost::uuids::random_generator_pure::operator()((uint64_t)&v10);
    *(_QWORD *)&v14 = v6;
    *((_QWORD *)&v14 + 1) = v7;
    v8 = *a3;
    v9 = v13;
    if (!v13)
      v9 = *(int **)(CLMicroLocationProto::RecordingEvent::default_instance(v6) + 40);
    CLMicroLocationProtobufHelper::createLoggedEvent<CLMicroLocationProto::BatteryChargerConnected>(&v14, v9, (uint64_t)&v15, v8);
    CLMicroLocationEventLogger::logEvent(v5, &v15);
    CLMicroLocationProto::ReceivedEvent::~ReceivedEvent((CLMicroLocationProto::ReceivedEvent *)v16);
    boost::uuids::detail::random_provider_base::destroy((boost::uuids::detail::random_provider_base *)&v10);
    CLMicroLocationLegacyClient::requestLocalizationOrRecordingIfPossible(a1, (const CLMicroLocationProto::RecordingEvent *)v12);
  }
  CLMicroLocationProto::RecordingEvent::~RecordingEvent((CLMicroLocationProto::RecordingEvent *)v12);
}

void sub_241A48A80(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, int a10, char a11)
{
  CLMicroLocationProto::RecordingEvent *v11;

  CLMicroLocationProto::RecordingEvent::~RecordingEvent(v11);
  _Unwind_Resume(a1);
}

void CLMicroLocationProtobufHelper::createLoggedEvent<CLMicroLocationProto::BatteryChargerConnected>(_OWORD *a1@<X0>, int *a2@<X1>, uint64_t a3@<X8>, double a4@<D0>)
{
  const CLMicroLocationProto::BatteryChargerConnected *v8;
  _BYTE v9[304];

  CLMicroLocationProto::ReceivedEvent::ReceivedEvent((CLMicroLocationProto::ReceivedEvent *)v9);
  CLMicroLocationProtobufHelper::setSpecificLoggedEvent((CLMicroLocationProtobufHelper *)v9, (CLMicroLocationProto::ReceivedEvent *)a2, v8);
  CLMicroLocationLoggedEventsTable::Entry::Entry(a3, a1, a2[2], (CLMicroLocationProto::ReceivedEvent *)v9, a4);
  CLMicroLocationProto::ReceivedEvent::~ReceivedEvent((CLMicroLocationProto::ReceivedEvent *)v9);
}

void sub_241A48B34(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  CLMicroLocationProto::ReceivedEvent::~ReceivedEvent((CLMicroLocationProto::ReceivedEvent *)&a9);
  _Unwind_Resume(a1);
}

void CLMicroLocationLegacyClient::onDisplayState(uint64_t a1, char a2, double *a3)
{
  CLMicroLocationEventLogger *v5;
  CLMicroLocationProto::RecordingEvent *v6;
  uint64_t v7;
  double v8;
  int *v9;
  int v10;
  _BYTE v11[8];
  _BYTE v12[32];
  int *v13;
  __int128 v14;
  Entry v15;
  _QWORD v16[39];

  v16[38] = *MEMORY[0x24BDAC8D0];
  CLMicroLocationLegacyEventDisplayState::handleEvent((_BYTE *)(a1 + 2), a2, a3, v11);
  if (v11[0])
  {
    v5 = *(CLMicroLocationEventLogger **)(a1 + 88);
    v10 = 0;
    boost::uuids::detail::random_provider_base::random_provider_base((boost::uuids::detail::random_provider_base *)&v10);
    v6 = (CLMicroLocationProto::RecordingEvent *)boost::uuids::random_generator_pure::operator()((uint64_t)&v10);
    *(_QWORD *)&v14 = v6;
    *((_QWORD *)&v14 + 1) = v7;
    v8 = *a3;
    v9 = v13;
    if (!v13)
      v9 = *(int **)(CLMicroLocationProto::RecordingEvent::default_instance(v6) + 32);
    CLMicroLocationProtobufHelper::createLoggedEvent<CLMicroLocationProto::BacklightOn>(&v14, v9, (uint64_t)&v15, v8);
    CLMicroLocationEventLogger::logEvent(v5, &v15);
    CLMicroLocationProto::ReceivedEvent::~ReceivedEvent((CLMicroLocationProto::ReceivedEvent *)v16);
    boost::uuids::detail::random_provider_base::destroy((boost::uuids::detail::random_provider_base *)&v10);
    CLMicroLocationLegacyClient::requestLocalizationOrRecordingIfPossible((CLMicroLocationLegacyClient *)a1, (const CLMicroLocationProto::RecordingEvent *)v12);
  }
  CLMicroLocationProto::RecordingEvent::~RecordingEvent((CLMicroLocationProto::RecordingEvent *)v12);
}

void sub_241A48C48(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, int a10, char a11)
{
  CLMicroLocationProto::RecordingEvent *v11;

  CLMicroLocationProto::RecordingEvent::~RecordingEvent(v11);
  _Unwind_Resume(a1);
}

void CLMicroLocationProtobufHelper::createLoggedEvent<CLMicroLocationProto::BacklightOn>(_OWORD *a1@<X0>, int *a2@<X1>, uint64_t a3@<X8>, double a4@<D0>)
{
  const CLMicroLocationProto::BacklightOn *v8;
  _BYTE v9[304];

  CLMicroLocationProto::ReceivedEvent::ReceivedEvent((CLMicroLocationProto::ReceivedEvent *)v9);
  CLMicroLocationProtobufHelper::setSpecificLoggedEvent((CLMicroLocationProtobufHelper *)v9, (CLMicroLocationProto::ReceivedEvent *)a2, v8);
  CLMicroLocationLoggedEventsTable::Entry::Entry(a3, a1, a2[4], (CLMicroLocationProto::ReceivedEvent *)v9, a4);
  CLMicroLocationProto::ReceivedEvent::~ReceivedEvent((CLMicroLocationProto::ReceivedEvent *)v9);
}

void sub_241A48CFC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  CLMicroLocationProto::ReceivedEvent::~ReceivedEvent((CLMicroLocationProto::ReceivedEvent *)&a9);
  _Unwind_Resume(a1);
}

uint64_t CLMicroLocationLegacyClient::onHomeKit(CLMicroLocationLegacyClient *a1, void *a2, double *a3)
{
  CLMicroLocationEventLogger *v5;
  CLMicroLocationProto::RecordingEvent *v6;
  uint64_t v7;
  double v8;
  int *v9;
  uint64_t v10;
  CLMicroLocationEventLogger *v11;
  CLMicroLocationProto::RecordingEvent *v12;
  uint64_t v13;
  double v14;
  int *v15;
  int v17;
  _BYTE v18[8];
  _BYTE v19[56];
  int *v20;
  int *v21;
  int v22;
  __int128 v23;
  Entry v24;
  _QWORD v25[39];

  v25[38] = *MEMORY[0x24BDAC8D0];
  CLMicroLocationLegacyEventHomeKit::handleEvent(a2, a3, v18);
  if (v18[0])
  {
    if (v22 == 9)
    {
      v11 = (CLMicroLocationEventLogger *)*((_QWORD *)a1 + 11);
      v17 = 0;
      boost::uuids::detail::random_provider_base::random_provider_base((boost::uuids::detail::random_provider_base *)&v17);
      v12 = (CLMicroLocationProto::RecordingEvent *)boost::uuids::random_generator_pure::operator()((uint64_t)&v17);
      *(_QWORD *)&v23 = v12;
      *((_QWORD *)&v23 + 1) = v13;
      v14 = *a3;
      v15 = v20;
      if (!v20)
        v15 = *(int **)(CLMicroLocationProto::RecordingEvent::default_instance(v12) + 56);
      CLMicroLocationProtobufHelper::createLoggedEvent<CLMicroLocationProto::HomeKitAccessory>(&v23, v15, (uint64_t)&v24, v14);
      CLMicroLocationEventLogger::logEvent(v11, &v24);
    }
    else
    {
      if (v22 != 10)
      {
LABEL_12:
        v10 = CLMicroLocationLegacyClient::requestLocalizationOrRecordingIfPossible(a1, (const CLMicroLocationProto::RecordingEvent *)v19);
        goto LABEL_13;
      }
      v5 = (CLMicroLocationEventLogger *)*((_QWORD *)a1 + 11);
      v17 = 0;
      boost::uuids::detail::random_provider_base::random_provider_base((boost::uuids::detail::random_provider_base *)&v17);
      v6 = (CLMicroLocationProto::RecordingEvent *)boost::uuids::random_generator_pure::operator()((uint64_t)&v17);
      *(_QWORD *)&v23 = v6;
      *((_QWORD *)&v23 + 1) = v7;
      v8 = *a3;
      v9 = v21;
      if (!v21)
        v9 = *(int **)(CLMicroLocationProto::RecordingEvent::default_instance(v6) + 64);
      CLMicroLocationProtobufHelper::createLoggedEvent<CLMicroLocationProto::HomeKitScene>(&v23, v9, (uint64_t)&v24, v8);
      CLMicroLocationEventLogger::logEvent(v5, &v24);
    }
    CLMicroLocationProto::ReceivedEvent::~ReceivedEvent((CLMicroLocationProto::ReceivedEvent *)v25);
    boost::uuids::detail::random_provider_base::destroy((boost::uuids::detail::random_provider_base *)&v17);
    goto LABEL_12;
  }
  v10 = 0;
LABEL_13:
  CLMicroLocationProto::RecordingEvent::~RecordingEvent((CLMicroLocationProto::RecordingEvent *)v19);
  return v10;
}

void sub_241A48E88(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, char a11)
{
  CLMicroLocationProto::RecordingEvent *v11;
  uint64_t v12;

  CLMicroLocationProto::ReceivedEvent::~ReceivedEvent((CLMicroLocationProto::ReceivedEvent *)(v12 + 32));
  boost::uuids::detail::random_provider_base::destroy((boost::uuids::detail::random_provider_base *)&a11);
  CLMicroLocationProto::RecordingEvent::~RecordingEvent(v11);
  _Unwind_Resume(a1);
}

void CLMicroLocationProtobufHelper::createLoggedEvent<CLMicroLocationProto::HomeKitScene>(_OWORD *a1@<X0>, int *a2@<X1>, uint64_t a3@<X8>, double a4@<D0>)
{
  const CLMicroLocationProto::HomeKitScene *v8;
  _BYTE v9[304];

  CLMicroLocationProto::ReceivedEvent::ReceivedEvent((CLMicroLocationProto::ReceivedEvent *)v9);
  CLMicroLocationProtobufHelper::setSpecificLoggedEvent((CLMicroLocationProtobufHelper *)v9, (CLMicroLocationProto::ReceivedEvent *)a2, v8);
  CLMicroLocationLoggedEventsTable::Entry::Entry(a3, a1, a2[12], (CLMicroLocationProto::ReceivedEvent *)v9, a4);
  CLMicroLocationProto::ReceivedEvent::~ReceivedEvent((CLMicroLocationProto::ReceivedEvent *)v9);
}

void sub_241A48F48(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  CLMicroLocationProto::ReceivedEvent::~ReceivedEvent((CLMicroLocationProto::ReceivedEvent *)&a9);
  _Unwind_Resume(a1);
}

void CLMicroLocationProtobufHelper::createLoggedEvent<CLMicroLocationProto::HomeKitAccessory>(_OWORD *a1@<X0>, int *a2@<X1>, uint64_t a3@<X8>, double a4@<D0>)
{
  const CLMicroLocationProto::HomeKitAccessory *v8;
  _BYTE v9[304];

  CLMicroLocationProto::ReceivedEvent::ReceivedEvent((CLMicroLocationProto::ReceivedEvent *)v9);
  CLMicroLocationProtobufHelper::setSpecificLoggedEvent((CLMicroLocationProtobufHelper *)v9, (CLMicroLocationProto::ReceivedEvent *)a2, v8);
  CLMicroLocationLoggedEventsTable::Entry::Entry(a3, a1, a2[16], (CLMicroLocationProto::ReceivedEvent *)v9, a4);
  CLMicroLocationProto::ReceivedEvent::~ReceivedEvent((CLMicroLocationProto::ReceivedEvent *)v9);
}

void sub_241A48FD0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  CLMicroLocationProto::ReceivedEvent::~ReceivedEvent((CLMicroLocationProto::ReceivedEvent *)&a9);
  _Unwind_Resume(a1);
}

void CLMicroLocationLegacyClient::onForcedRecording(CLMicroLocationLegacyClient *a1, double *a2)
{
  CLMicroLocationEventLogger *v4;
  CLMicroLocationProto::RecordingEvent *v5;
  uint64_t v6;
  double v7;
  int *v8;
  int v9;
  char v10[8];
  _BYTE v11[48];
  int *v12;
  __int128 v13;
  Entry v14;
  _QWORD v15[39];

  v15[38] = *MEMORY[0x24BDAC8D0];
  CLMicroLocationLegacyEventForcedRecording::handleEvent(a2, v10);
  if (v10[0])
  {
    v4 = (CLMicroLocationEventLogger *)*((_QWORD *)a1 + 11);
    v9 = 0;
    boost::uuids::detail::random_provider_base::random_provider_base((boost::uuids::detail::random_provider_base *)&v9);
    v5 = (CLMicroLocationProto::RecordingEvent *)boost::uuids::random_generator_pure::operator()((uint64_t)&v9);
    *(_QWORD *)&v13 = v5;
    *((_QWORD *)&v13 + 1) = v6;
    v7 = *a2;
    v8 = v12;
    if (!v12)
      v8 = *(int **)(CLMicroLocationProto::RecordingEvent::default_instance(v5) + 48);
    CLMicroLocationProtobufHelper::createLoggedEvent<CLMicroLocationProto::ForcedRecording>(&v13, v8, (uint64_t)&v14, v7);
    CLMicroLocationEventLogger::logEvent(v4, &v14);
    CLMicroLocationProto::ReceivedEvent::~ReceivedEvent((CLMicroLocationProto::ReceivedEvent *)v15);
    boost::uuids::detail::random_provider_base::destroy((boost::uuids::detail::random_provider_base *)&v9);
    CLMicroLocationLegacyClient::requestLocalizationOrRecordingIfPossible(a1, (const CLMicroLocationProto::RecordingEvent *)v11);
  }
  CLMicroLocationProto::RecordingEvent::~RecordingEvent((CLMicroLocationProto::RecordingEvent *)v11);
}

void sub_241A490E4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, int a10, char a11)
{
  CLMicroLocationProto::RecordingEvent *v11;

  CLMicroLocationProto::RecordingEvent::~RecordingEvent(v11);
  _Unwind_Resume(a1);
}

void CLMicroLocationProtobufHelper::createLoggedEvent<CLMicroLocationProto::ForcedRecording>(_OWORD *a1@<X0>, int *a2@<X1>, uint64_t a3@<X8>, double a4@<D0>)
{
  const CLMicroLocationProto::ForcedRecording *v8;
  _BYTE v9[304];

  CLMicroLocationProto::ReceivedEvent::ReceivedEvent((CLMicroLocationProto::ReceivedEvent *)v9);
  CLMicroLocationProtobufHelper::setSpecificLoggedEvent((CLMicroLocationProtobufHelper *)v9, (CLMicroLocationProto::ReceivedEvent *)a2, v8);
  CLMicroLocationLoggedEventsTable::Entry::Entry(a3, a1, a2[2], (CLMicroLocationProto::ReceivedEvent *)v9, a4);
  CLMicroLocationProto::ReceivedEvent::~ReceivedEvent((CLMicroLocationProto::ReceivedEvent *)v9);
}

void sub_241A49198(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  CLMicroLocationProto::ReceivedEvent::~ReceivedEvent((CLMicroLocationProto::ReceivedEvent *)&a9);
  _Unwind_Resume(a1);
}

uint64_t CLMicroLocationLegacyClient::onRecordingRequest(CLMicroLocationLegacyClient *a1, uint64_t a2, void *a3, double *a4)
{
  CLMicroLocationEventLogger *v6;
  CLMicroLocationProto::RecordingEvent *v7;
  uint64_t v8;
  double v9;
  int *v10;
  uint64_t v11;
  int v13;
  char v14[8];
  _BYTE v15[88];
  int *v16;
  __int128 v17;
  Entry v18;
  _QWORD v19[39];

  v19[38] = *MEMORY[0x24BDAC8D0];
  CLMicroLocationLegacyEventRecordingRequest::handleEvent(a2, a3, a4, v14);
  if (v14[0])
  {
    v6 = (CLMicroLocationEventLogger *)*((_QWORD *)a1 + 11);
    v13 = 0;
    boost::uuids::detail::random_provider_base::random_provider_base((boost::uuids::detail::random_provider_base *)&v13);
    v7 = (CLMicroLocationProto::RecordingEvent *)boost::uuids::random_generator_pure::operator()((uint64_t)&v13);
    *(_QWORD *)&v17 = v7;
    *((_QWORD *)&v17 + 1) = v8;
    v9 = *a4;
    v10 = v16;
    if (!v16)
      v10 = *(int **)(CLMicroLocationProto::RecordingEvent::default_instance(v7) + 88);
    CLMicroLocationProtobufHelper::createLoggedEvent<CLMicroLocationProto::RecordingRequest>(&v17, v10, (uint64_t)&v18, v9);
    CLMicroLocationEventLogger::logEvent(v6, &v18);
    CLMicroLocationProto::ReceivedEvent::~ReceivedEvent((CLMicroLocationProto::ReceivedEvent *)v19);
    boost::uuids::detail::random_provider_base::destroy((boost::uuids::detail::random_provider_base *)&v13);
    v11 = CLMicroLocationLegacyClient::requestLocalizationOrRecordingIfPossible(a1, (const CLMicroLocationProto::RecordingEvent *)v15);
  }
  else
  {
    v11 = 0;
  }
  CLMicroLocationProto::RecordingEvent::~RecordingEvent((CLMicroLocationProto::RecordingEvent *)v15);
  return v11;
}

void sub_241A492BC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, int a10, char a11)
{
  CLMicroLocationProto::RecordingEvent *v11;

  CLMicroLocationProto::RecordingEvent::~RecordingEvent(v11);
  _Unwind_Resume(a1);
}

uint64_t CLMicroLocationLegacyClient::onLocalizationRequest(CLMicroLocationLegacyClient *a1, const std::string *a2, double *a3)
{
  CLMicroLocationEventLogger *v5;
  CLMicroLocationProto::RecordingEvent *v6;
  uint64_t v7;
  double v8;
  int *v9;
  uint64_t v10;
  int v12;
  char v13[8];
  _BYTE v14[16];
  int *v15;
  __int128 v16;
  Entry v17;
  _QWORD v18[39];

  v18[38] = *MEMORY[0x24BDAC8D0];
  CLMicroLocationLegacyEventLocalizationRequest::handleEvent(a2, a3, v13);
  if (v13[0])
  {
    v5 = (CLMicroLocationEventLogger *)*((_QWORD *)a1 + 11);
    v12 = 0;
    boost::uuids::detail::random_provider_base::random_provider_base((boost::uuids::detail::random_provider_base *)&v12);
    v6 = (CLMicroLocationProto::RecordingEvent *)boost::uuids::random_generator_pure::operator()((uint64_t)&v12);
    *(_QWORD *)&v16 = v6;
    *((_QWORD *)&v16 + 1) = v7;
    v8 = *a3;
    v9 = v15;
    if (!v15)
      v9 = *(int **)(CLMicroLocationProto::RecordingEvent::default_instance(v6) + 16);
    CLMicroLocationProtobufHelper::createLoggedEvent<CLMicroLocationProto::ReceivedEventAction>(&v16, v9, (uint64_t)&v17, v8);
    CLMicroLocationEventLogger::logEvent(v5, &v17);
    CLMicroLocationProto::ReceivedEvent::~ReceivedEvent((CLMicroLocationProto::ReceivedEvent *)v18);
    boost::uuids::detail::random_provider_base::destroy((boost::uuids::detail::random_provider_base *)&v12);
    v10 = CLMicroLocationLegacyClient::requestLocalizationOrRecordingIfPossible(a1, (const CLMicroLocationProto::RecordingEvent *)v14);
  }
  else
  {
    v10 = 0;
  }
  CLMicroLocationProto::RecordingEvent::~RecordingEvent((CLMicroLocationProto::RecordingEvent *)v14);
  return v10;
}

void sub_241A4940C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, int a10, char a11)
{
  CLMicroLocationProto::RecordingEvent *v11;

  CLMicroLocationProto::RecordingEvent::~RecordingEvent(v11);
  _Unwind_Resume(a1);
}

uint64_t CLMicroLocationLegacyClient::donateTruthTagLabel(uint64_t a1, uint64_t a2, _QWORD *a3, _QWORD *a4)
{
  int v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  NSObject *v12;
  _QWORD *v13;
  void *v14;
  int v16;
  void *v17;
  uint64_t v18;

  v18 = *MEMORY[0x24BDAC8D0];
  v5 = *(char *)(a2 + 23);
  if (v5 < 0)
  {
    if (*(_QWORD *)(a2 + 8) != 23)
    {
LABEL_13:
      if (onceToken_MicroLocation_Default != -1)
        dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_39);
      v12 = (id)logObject_MicroLocation_Default;
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
      {
        if (*(char *)(a2 + 23) >= 0)
          v13 = (_QWORD *)a2;
        else
          v13 = *(_QWORD **)a2;
        objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", v13);
        v14 = (void *)objc_claimAutoreleasedReturnValue();
        v16 = 138412290;
        v17 = v14;
        _os_log_impl(&dword_2419D9000, v12, OS_LOG_TYPE_ERROR, "Unsupport labels form any other client than focus-mode ClientReceived: %@", (uint8_t *)&v16, 0xCu);

      }
      return 0;
    }
    v6 = *(uint64_t **)a2;
  }
  else
  {
    v6 = (uint64_t *)a2;
    if (v5 != 23)
      goto LABEL_13;
  }
  v7 = *v6;
  v8 = v6[1];
  v9 = *(uint64_t *)((char *)v6 + 15);
  if (v7 != 0x6C7070612E6D6F63 || v8 != 0x7865746E6F632E65 || v9 != 0x6465726F74737478)
    goto LABEL_13;
  if (!*(_BYTE *)(a1 + 73))
    return 0;
  return (*(uint64_t (**)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD))(**(_QWORD **)(a1 + 80)
                                                                                           + 64))(*(_QWORD *)(a1 + 80), *(_QWORD *)(a1 + 57), *(_QWORD *)(a1 + 65), *a4, a4[1], *a3, a3[1]);
}

void sub_241A4960C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t CLMicroLocationLegacyClient::donateTruthTagLabelForRecordingEventsBetweenDates(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, void *a5)
{
  id v9;
  id v10;
  int v11;
  uint64_t *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  NSObject *v18;
  _QWORD *v19;
  void *v20;
  uint64_t v21;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  int v27;
  __int128 buf;
  uint64_t v29;

  v29 = *MEMORY[0x24BDAC8D0];
  v9 = a4;
  v10 = a5;
  v11 = *(char *)(a2 + 23);
  if (v11 < 0)
  {
    if (*(_QWORD *)(a2 + 8) != 23)
    {
LABEL_13:
      if (onceToken_MicroLocation_Default != -1)
        dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_39);
      v18 = (id)logObject_MicroLocation_Default;
      if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
      {
        if (*(char *)(a2 + 23) >= 0)
          v19 = (_QWORD *)a2;
        else
          v19 = *(_QWORD **)a2;
        objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", v19);
        v20 = (void *)objc_claimAutoreleasedReturnValue();
        LODWORD(buf) = 138412290;
        *(_QWORD *)((char *)&buf + 4) = v20;
        _os_log_impl(&dword_2419D9000, v18, OS_LOG_TYPE_ERROR, "Unsupport labels form any other client than focus-mode ClientReceived: %@", (uint8_t *)&buf, 0xCu);

      }
      goto LABEL_21;
    }
    v12 = *(uint64_t **)a2;
  }
  else
  {
    v12 = (uint64_t *)a2;
    if (v11 != 23)
      goto LABEL_13;
  }
  v13 = *v12;
  v14 = v12[1];
  v15 = *(uint64_t *)((char *)v12 + 15);
  if (v13 != 0x6C7070612E6D6F63 || v14 != 0x7865746E6F632E65 || v15 != 0x6465726F74737478)
    goto LABEL_13;
  if (*(_BYTE *)(a1 + 73))
  {
    v23 = *(_QWORD *)(a1 + 80);
    v24 = *(_QWORD *)(a1 + 57);
    v25 = *(_QWORD *)(a1 + 65);
    v27 = 0;
    boost::uuids::detail::random_provider_base::random_provider_base((boost::uuids::detail::random_provider_base *)&v27);
    *(_QWORD *)&buf = boost::uuids::random_generator_pure::operator()((uint64_t)&v27);
    *((_QWORD *)&buf + 1) = v26;
    v21 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, __int128 *, uint64_t, id, id))(*(_QWORD *)v23 + 80))(v23, v24, v25, &buf, a3, v9, v10);
    boost::uuids::detail::random_provider_base::destroy((boost::uuids::detail::random_provider_base *)&v27);
    goto LABEL_22;
  }
LABEL_21:
  v21 = 0;
LABEL_22:

  return v21;
}

void sub_241A49868(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

uint64_t CLMicroLocationLegacyClient::setLowPowerMode(uint64_t this, char a2)
{
  *(_BYTE *)(this + 96) = a2;
  return this;
}

uint64_t CLMicroLocationLegacyClient::setAirplaneMode(uint64_t this, char a2)
{
  *(_BYTE *)(this + 97) = a2;
  return this;
}

uint64_t CLMicroLocationLegacyClient::setBuddyComplete(uint64_t this, char a2)
{
  *(_BYTE *)(this + 98) = a2;
  return this;
}

BOOL CLMicroLocationLegacyClient::isHomeKitRequest(CLMicroLocationLegacyClient *this, NSDictionary *a2)
{
  return CLMicroLocationLegacyEventHomeKit::isHomeControlSuggestionRequest((CLMicroLocationLegacyClient *)((char *)this + 3), a2);
}

void CLMicroLocationLegacyClient::databaseAvailable(CLMicroLocationLegacyClient *this)
{
  void *__p[2];
  char v3;
  void *v4[2];
  char v5;
  uint64_t v6;
  uint64_t v7;
  char v8;
  __int128 v9;
  char v10;
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  if (!*((_BYTE *)this + 56))
  {
    std::string::basic_string[abi:ne180100]<0>(v4, "milo-internal-legacy-client-name-unsupervised");
    std::string::basic_string[abi:ne180100]<0>(__p, (char *)objc_msgSend(CFSTR("00000000-0000-0000-0000-000000000016"), "UTF8String"));
    CLMicroLocationProtobufHelper::uuidFromStdString((uint64_t)__p, (uint64_t)&v6);
    if (!v8)
      std::__throw_bad_optional_access[abi:ne180100]();
    CLMicroLocationLegacyClient::tryCreateServiceAndConnect((uint64_t)this, (uint64_t *)v4, v6, v7, (uint64_t)&v9);
    *(_OWORD *)((char *)this + 40) = v9;
    *((_BYTE *)this + 56) = v10;
    if (v3 < 0)
      operator delete(__p[0]);
    if (v5 < 0)
      operator delete(v4[0]);
  }
  if (!*((_BYTE *)this + 73))
  {
    std::string::basic_string[abi:ne180100]<0>(v4, "focus-mode");
    std::string::basic_string[abi:ne180100]<0>(__p, (char *)objc_msgSend(CFSTR("00000000-0000-0000-0000-000000000017"), "UTF8String"));
    CLMicroLocationProtobufHelper::uuidFromStdString((uint64_t)__p, (uint64_t)&v6);
    if (!v8)
      std::__throw_bad_optional_access[abi:ne180100]();
    CLMicroLocationLegacyClient::tryCreateServiceAndConnect((uint64_t)this, (uint64_t *)v4, v6, v7, (uint64_t)&v9);
    *(_OWORD *)((char *)this + 57) = v9;
    *((_BYTE *)this + 73) = v10;
    if (v3 < 0)
      operator delete(__p[0]);
    if (v5 < 0)
      operator delete(v4[0]);
  }
}

void sub_241A49A50(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  if (a16 < 0)
    operator delete(__p);
  if (a22 < 0)
    operator delete(a17);
  _Unwind_Resume(exception_object);
}

void CLMicroLocationLegacyClient::tryCreateServiceAndConnect(uint64_t a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  NSObject *v10;
  uint64_t *v11;
  void *v12;
  void *v13;
  uint64_t v14;
  char v15;
  char v16;
  uint64_t v17;
  uint64_t v18;
  NSObject *v19;
  void *v20;
  char v21;
  char v22;
  _BYTE v23[15];
  char v24;
  _QWORD v25[2];
  _BYTE __p[12];
  char v27;
  _BYTE buf[22];
  uint64_t v29;

  v29 = *MEMORY[0x24BDAC8D0];
  if (onceToken_MicroLocation_Default != -1)
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_39);
  v10 = (id)logObject_MicroLocation_Default;
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    if (*((char *)a2 + 23) >= 0)
      v11 = a2;
    else
      v11 = (uint64_t *)*a2;
    objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", v11);
    v12 = (void *)objc_claimAutoreleasedReturnValue();
    ULServiceTypeToString();
    v13 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 138412546;
    *(_QWORD *)&buf[4] = v12;
    *(_WORD *)&buf[12] = 2112;
    *(_QWORD *)&buf[14] = v13;
    _os_log_impl(&dword_2419D9000, v10, OS_LOG_TYPE_DEFAULT, "tryCreateServiceAndConnect: clientName: %@, serviceType: %@", buf, 0x16u);

  }
  v14 = *(_QWORD *)(a1 + 80);
  std::string::basic_string[abi:ne180100]<0>(__p, "");
  (*(void (**)(_BYTE *__return_ptr, uint64_t, uint64_t *, _BYTE *))(*(_QWORD *)v14 + 24))(buf, v14, a2, __p);
  if (v27 < 0)
    operator delete(*(void **)__p);
  if (*(_QWORD *)buf == *(_QWORD *)&buf[8])
  {
    v16 = 0;
    v15 = 0;
  }
  else
  {
    v15 = **(_BYTE **)buf;
    v25[0] = *(_QWORD *)(*(_QWORD *)buf + 1);
    *(_QWORD *)((char *)v25 + 7) = *(_QWORD *)(*(_QWORD *)buf + 8);
    v16 = 1;
  }
  v17 = *(_QWORD *)(a1 + 80);
  v22 = v15;
  *(_QWORD *)v23 = v25[0];
  *(_QWORD *)&v23[7] = *(_QWORD *)((char *)v25 + 7);
  v24 = v16;
  std::string::basic_string[abi:ne180100]<0>(__p, "");
  v18 = (*(uint64_t (**)(uint64_t, uint64_t *, uint64_t, uint64_t, char *, uint64_t, uint64_t, _BYTE *))(*(_QWORD *)v17 + 32))(v17, a2, a3, a4, &v22, a3, a4, __p);
  if (v27 < 0)
    operator delete(*(void **)__p);
  if (v18 == -1)
  {
    *(_QWORD *)a5 = a3;
    *(_QWORD *)(a5 + 8) = a4;
    v21 = 1;
  }
  else
  {
    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_39);
    v19 = (id)logObject_MicroLocation_Default;
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
    {
      objc_msgSend(MEMORY[0x24BDD16E0], "numberWithInteger:", v18);
      v20 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)__p = 138412290;
      *(_QWORD *)&__p[4] = v20;
      _os_log_impl(&dword_2419D9000, v19, OS_LOG_TYPE_DEFAULT, "tryCreateServiceAndConnect: failed to connect, errorId: %@", __p, 0xCu);

    }
    v21 = 0;
    *(_BYTE *)a5 = 0;
  }
  *(_BYTE *)(a5 + 16) = v21;
  if (*(_QWORD *)buf)
  {
    *(_QWORD *)&buf[8] = *(_QWORD *)buf;
    operator delete(*(void **)buf);
  }
}

void sub_241A49D80(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,void *__p,uint64_t a23)
{
  void *v23;

  if (__p)
    operator delete(__p);
  _Unwind_Resume(a1);
}

void CLMicroLocationLegacyClient::publishResultsToBiomeAndCoreDuet(CLMicroLocationLegacyClient *this, const CLMiLoService::ServiceDescriptor *a2, const CLMicroLocationResultToPublish *a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  _BOOL8 v10;
  BOOL v11;
  uint64_t v12;
  uint64_t v13;
  NSObject *v14;
  void *v15;
  void *v16;
  NSObject *v18;
  _BOOL8 v19;
  NSObject *v21;
  _BOOL8 v22;
  CFAbsoluteTime v23;
  uint64_t *v24;
  _QWORD *v25;
  uint64_t v26;
  _BYTE buf[48];
  void *v28;
  char v29;
  char v30;
  _BYTE v31[40];
  char v32;
  void *__p;
  void *v34;
  uint64_t v35;

  v35 = *MEMORY[0x24BDAC8D0];
  v7 = *((_QWORD *)a3 + 18);
  v6 = *((_QWORD *)a3 + 19);
  if (v7 == v6)
  {
    v10 = 1;
  }
  else
  {
    v8 = v7 + 4;
    do
    {
      v9 = *(_DWORD *)(v8 - 4);
      v10 = v9 != 3;
      v11 = v9 == 3 || v8 == v6;
      v8 += 4;
    }
    while (!v11);
  }
  v13 = *(_QWORD *)a3;
  v12 = *((_QWORD *)a3 + 1);
  if (onceToken_MicroLocation_Default != -1)
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_39);
  v14 = (id)logObject_MicroLocation_Default;
  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
  {
    objc_msgSend(MEMORY[0x24BDD16E0], "numberWithBool:", v10);
    v15 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(MEMORY[0x24BDD16E0], "numberWithBool:", v13 != v12);
    v16 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 138412546;
    *(_QWORD *)&buf[4] = v15;
    *(_WORD *)&buf[12] = 2112;
    *(_QWORD *)&buf[14] = v16;
    _os_log_impl(&dword_2419D9000, v14, OS_LOG_TYPE_DEFAULT, "Trying to publish results, fingerprintValid: %@, probabilityVectorValid: %@", buf, 0x16u);

  }
  if (v10 && v13 != v12)
  {
    if (*((_BYTE *)this + 56))
    {
      if (*((_QWORD *)this + 5) == *(_QWORD *)a2 && *((_QWORD *)this + 6) == *((_QWORD *)a2 + 1))
      {
        v25 = 0;
        v26 = 0;
        v24 = (uint64_t *)&v25;
        v23 = cl::chrono::CFAbsoluteTimeClock::now();
        *(_QWORD *)buf = "com.apple.magicalmoments";
        CLMicroLocationResultToPublish::CLMicroLocationResultToPublish((CLMicroLocationResultToPublish *)&buf[8], a3);
        std::__tree<std::__value_type<std::string,CLMicroLocationResultToPublish>,std::__map_value_compare<std::string,std::__value_type<std::string,CLMicroLocationResultToPublish>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,CLMicroLocationResultToPublish>>>::__emplace_multi<std::pair<char const*,CLMicroLocationResultToPublish>>(&v24, (uint64_t)buf);
        if (__p)
        {
          v34 = __p;
          operator delete(__p);
        }
        if (v32)
          std::__hash_table<std::__hash_value_type<std::string,AnchorValueStatistics>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,AnchorValueStatistics>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,AnchorValueStatistics>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,AnchorValueStatistics>>>::~__hash_table((uint64_t)v31);
        if (v30 && v29 < 0)
          operator delete(v28);
        if (*(_QWORD *)&buf[8])
        {
          *(_QWORD *)&buf[16] = *(_QWORD *)&buf[8];
          operator delete(*(void **)&buf[8]);
        }
        if (onceToken_MicroLocation_Default != -1)
          dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_39);
        v18 = logObject_MicroLocation_Default;
        v19 = os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT);
        if (v19)
        {
          *(_WORD *)buf = 0;
          _os_log_impl(&dword_2419D9000, v18, OS_LOG_TYPE_DEFAULT, "Publishing unsupervised localization results to Biome", buf, 2u);
        }
        CLMicroLocationLegacyClient::publishResults(v19, &v23);
        std::__tree<std::__value_type<std::string,CLMicroLocationResultToPublish>,std::__map_value_compare<std::string,std::__value_type<std::string,CLMicroLocationResultToPublish>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,CLMicroLocationResultToPublish>>>::destroy((uint64_t)&v24, v25);
      }
    }
    if (*((_BYTE *)this + 73))
    {
      if (*(_QWORD *)((char *)this + 57) == *(_QWORD *)a2 && *(_QWORD *)((char *)this + 65) == *((_QWORD *)a2 + 1))
      {
        v25 = 0;
        v26 = 0;
        v23 = 0.0;
        v24 = (uint64_t *)&v25;
        v23 = cl::chrono::CFAbsoluteTimeClock::now();
        *(_QWORD *)buf = "com.apple.microlocation.semisupervised";
        CLMicroLocationResultToPublish::CLMicroLocationResultToPublish((CLMicroLocationResultToPublish *)&buf[8], a3);
        std::__tree<std::__value_type<std::string,CLMicroLocationResultToPublish>,std::__map_value_compare<std::string,std::__value_type<std::string,CLMicroLocationResultToPublish>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,CLMicroLocationResultToPublish>>>::__emplace_multi<std::pair<char const*,CLMicroLocationResultToPublish>>(&v24, (uint64_t)buf);
        if (__p)
        {
          v34 = __p;
          operator delete(__p);
        }
        if (v32)
          std::__hash_table<std::__hash_value_type<std::string,AnchorValueStatistics>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,AnchorValueStatistics>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,AnchorValueStatistics>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,AnchorValueStatistics>>>::~__hash_table((uint64_t)v31);
        if (v30 && v29 < 0)
          operator delete(v28);
        if (*(_QWORD *)&buf[8])
        {
          *(_QWORD *)&buf[16] = *(_QWORD *)&buf[8];
          operator delete(*(void **)&buf[8]);
        }
        if (onceToken_MicroLocation_Default != -1)
          dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_39);
        v21 = logObject_MicroLocation_Default;
        v22 = os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT);
        if (v22)
        {
          *(_WORD *)buf = 0;
          _os_log_impl(&dword_2419D9000, v21, OS_LOG_TYPE_DEFAULT, "Publishing focusMode localization results to Biome", buf, 2u);
        }
        CLMicroLocationLegacyClient::publishResults(v22, &v23);
        std::__tree<std::__value_type<std::string,CLMicroLocationResultToPublish>,std::__map_value_compare<std::string,std::__value_type<std::string,CLMicroLocationResultToPublish>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,CLMicroLocationResultToPublish>>>::destroy((uint64_t)&v24, v25);
      }
    }
  }
}

void sub_241A4A1C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, _QWORD *a11)
{
  uint64_t v11;

  std::__tree<std::__value_type<std::string,CLMicroLocationResultToPublish>,std::__map_value_compare<std::string,std::__value_type<std::string,CLMicroLocationResultToPublish>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,CLMicroLocationResultToPublish>>>::destroy(v11, a11);
  _Unwind_Resume(a1);
}

uint64_t std::pair<char const*,CLMicroLocationResultToPublish>::~pair(uint64_t a1)
{
  void *v2;
  void *v3;

  v2 = *(void **)(a1 + 152);
  if (v2)
  {
    *(_QWORD *)(a1 + 160) = v2;
    operator delete(v2);
  }
  if (*(_BYTE *)(a1 + 136))
    std::__hash_table<std::__hash_value_type<std::string,AnchorValueStatistics>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,AnchorValueStatistics>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,AnchorValueStatistics>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,AnchorValueStatistics>>>::~__hash_table(a1 + 96);
  if (*(_BYTE *)(a1 + 88) && *(char *)(a1 + 87) < 0)
    operator delete(*(void **)(a1 + 64));
  v3 = *(void **)(a1 + 8);
  if (v3)
  {
    *(_QWORD *)(a1 + 16) = v3;
    operator delete(v3);
  }
  return a1;
}

void CLMicroLocationLegacyClient::publishResults(uint64_t a1, double *a2)
{
  id v3;
  id v4;
  id v5;

  if ((objc_msgSend(MEMORY[0x24BE669E0], "isMac") & 1) == 0)
  {
    CLMicroLocationPublishHelper::duetEventsFromLocalizationResultMeasurement((uint64_t)a2);
    v3 = (id)objc_claimAutoreleasedReturnValue();
    +[ULCoreDuetPublisher saveEventsToDuetStream:](ULCoreDuetPublisher, "saveEventsToDuetStream:");

    CLMicroLocationPublishHelper::biomeRestrictedEventsFromLocalizationResultMeasurement(a2);
    v4 = (id)objc_claimAutoreleasedReturnValue();
    +[ULBiomePublisher saveMicroLocationLocalizationEvents:](ULBiomePublisher, "saveMicroLocationLocalizationEvents:");

    CLMicroLocationPublishHelper::biomePublicEventsFromLocalizationResultMeasurement((uint64_t)a2);
    v5 = (id)objc_claimAutoreleasedReturnValue();
    +[ULBiomePublisher saveMicroLocationVisitEvents:](ULBiomePublisher, "saveMicroLocationVisitEvents:");

  }
}

void sub_241A4A370(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{

  _Unwind_Resume(a1);
}

void CLMicroLocationLegacyClient::updateStatus(CLMicroLocationLegacyClient *this, const CLMiLoService::ServiceStatus *a2)
{
  _QWORD *v5;
  _QWORD *v6;
  _QWORD *v7;
  _BOOL4 v8;
  void *v9;
  void *v10;
  void *v11;
  void *v12;
  unsigned int v13;
  unsigned int v14;
  BOOL v15;
  NSObject *v16;
  id v17;
  uint64_t v18;
  int v19;
  int v20;
  int v21;
  unsigned int v22;
  uint64_t v23;
  CLMicroLocationEventLogger *v24;
  uint64_t v25;
  double v26;
  unsigned int v27;
  uint64_t v28;
  int v29;
  int v30[6];
  int v31;
  __int128 v32;
  uint8_t buf[4];
  int v34;
  __int16 v35;
  const char *v36;
  __int16 v37;
  _BOOL4 v38;
  __int16 v39;
  _BOOL4 v40;
  __int16 v41;
  _BOOL4 v42;
  __int16 v43;
  _BOOL4 v44;
  __int16 v45;
  uint64_t v46;
  __int16 v47;
  int v48;
  __int16 v49;
  int v50;
  uint64_t v51;

  v51 = *MEMORY[0x24BDAC8D0];
  if (*((_BYTE *)this + 56))
  {
    if (*((_QWORD *)this + 5) == *((_QWORD *)a2 + 4) && *((_QWORD *)this + 6) == *((_QWORD *)a2 + 5))
    {
      v6 = (_QWORD *)*((_QWORD *)a2 + 1);
      v5 = (_QWORD *)*((_QWORD *)a2 + 2);
      if (v6 == v5)
      {
        v8 = 0;
      }
      else
      {
        v7 = (_QWORD *)*((_QWORD *)a2 + 1);
        while (*v7 != 1)
        {
          if (++v7 == v5)
          {
            v7 = (_QWORD *)*((_QWORD *)a2 + 2);
            break;
          }
        }
        v8 = v7 != v5;
        while (*v6)
        {
          if (++v6 == v5)
          {
            v6 = (_QWORD *)*((_QWORD *)a2 + 2);
            break;
          }
        }
      }
      v28 = *(_QWORD *)a2;
      v27 = *((_DWORD *)a2 + 42);
      +[ULDefaultsSingleton shared](ULDefaultsSingleton, "shared");
      v9 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v9, "defaultsDictionary");
      v10 = (void *)objc_claimAutoreleasedReturnValue();

      objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "ULNumFingerprintsThresholdForExpeditedRecordings");
      v11 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v10, "objectForKey:", v11);
      v12 = (void *)objc_claimAutoreleasedReturnValue();
      if (v12 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
        v13 = objc_msgSend(v12, "unsignedIntValue");
      else
        v13 = objc_msgSend(&unk_2511ED780, "unsignedIntValue");
      v14 = v13;

      *((_BYTE *)this + 105) = v28 != 1;
      v15 = v6 == v5 || v28 != 1;
      *((_BYTE *)this + 104) = v15;
      if (onceToken_MicroLocation_Default != -1)
        dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_39);
      v16 = (id)logObject_MicroLocation_Default;
      if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
      {
        ULServiceQualityToString();
        v17 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
        v18 = objc_msgSend(v17, "UTF8String");
        v19 = *((unsigned __int8 *)this + 105);
        v20 = *((unsigned __int8 *)this + 104);
        *(_DWORD *)buf = 68290818;
        v34 = 0;
        v35 = 2082;
        v36 = "";
        v37 = 1026;
        v38 = v28 == 1;
        v39 = 1026;
        v40 = v8;
        v41 = 1026;
        v42 = v6 != v5;
        v43 = 1026;
        v44 = v27 < v14;
        v45 = 2082;
        v46 = v18;
        v47 = 1026;
        v48 = v19;
        v49 = 1026;
        v50 = v20;
        _os_log_impl(&dword_2419D9000, v16, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"Service Status update\", \"isSuspended\":%{public}hhd, \"isReasonModelUnavailable\":%{public}hhd, \"isReasonLocationNotSupported\":%{public}hhd, \"isLowNumberOfValidObservations\":%{public}hhd, \"quality\":%{public, location:escape_only}s, \"Localization Allowed\":%{public}hhd, \"Recording Allowed\":%{public}hhd}", buf, 0x40u);

      }
      v21 = v28 == 1 && v8 || v27 < v14;
      if (v21 != 1)
      {
        if (*(_QWORD *)a2)
          v21 = 255;
        else
          v21 = 2;
      }
      *((_DWORD *)this + 25) = v21;
      CLMicroLocationProto::LegacyClientStatusUpdate::LegacyClientStatusUpdate((CLMicroLocationProto::LegacyClientStatusUpdate *)v30);
      v22 = *((_DWORD *)this + 25);
      if (!CLMicroLocationProto::NumberOfObservationsStates_IsValid((CLMicroLocationProto *)v22))
        __assert_rtn("set_numberofobservationsstate", "microlocation.pb.h", 21378, "::CLMicroLocationProto::NumberOfObservationsStates_IsValid(value)");
      v23 = *((_QWORD *)a2 + 9);
      v31 |= 6u;
      v30[3] = v22;
      v30[4] = v23;
      v24 = (CLMicroLocationEventLogger *)*((_QWORD *)this + 11);
      v29 = 0;
      boost::uuids::detail::random_provider_base::random_provider_base((boost::uuids::detail::random_provider_base *)&v29);
      *(_QWORD *)&v32 = boost::uuids::random_generator_pure::operator()((uint64_t)&v29);
      *((_QWORD *)&v32 + 1) = v25;
      v26 = cl::chrono::CFAbsoluteTimeClock::now();
      CLMicroLocationProtobufHelper::createLoggedEvent<CLMicroLocationProto::LegacyClientStatusUpdate>(&v32, v30, (uint64_t)buf, v26);
      CLMicroLocationEventLogger::logEvent(v24, (Entry *)buf);
      CLMicroLocationProto::ReceivedEvent::~ReceivedEvent((CLMicroLocationProto::ReceivedEvent *)&v42);
      boost::uuids::detail::random_provider_base::destroy((boost::uuids::detail::random_provider_base *)&v29);
      CLMicroLocationProto::LegacyClientStatusUpdate::~LegacyClientStatusUpdate((CLMicroLocationProto::LegacyClientStatusUpdate *)v30);
    }
  }
}

void sub_241A4A730(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void CLMicroLocationProtobufHelper::createLoggedEvent<CLMicroLocationProto::LegacyClientStatusUpdate>(_OWORD *a1@<X0>, int *a2@<X1>, uint64_t a3@<X8>, double a4@<D0>)
{
  const CLMicroLocationProto::LegacyClientStatusUpdate *v8;
  _BYTE v9[304];

  CLMicroLocationProto::ReceivedEvent::ReceivedEvent((CLMicroLocationProto::ReceivedEvent *)v9);
  CLMicroLocationProtobufHelper::setSpecificLoggedEvent((CLMicroLocationProtobufHelper *)v9, (CLMicroLocationProto::ReceivedEvent *)a2, v8);
  CLMicroLocationLoggedEventsTable::Entry::Entry(a3, a1, a2[2], (CLMicroLocationProto::ReceivedEvent *)v9, a4);
  CLMicroLocationProto::ReceivedEvent::~ReceivedEvent((CLMicroLocationProto::ReceivedEvent *)v9);
}

void sub_241A4A824(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  CLMicroLocationProto::ReceivedEvent::~ReceivedEvent((CLMicroLocationProto::ReceivedEvent *)&a9);
  _Unwind_Resume(a1);
}

uint64_t CLMicroLocationLegacyClient::requestLocalizationIfPossible(CLMicroLocationLegacyClient *this, const CLMicroLocationProto::RecordingEvent *a2)
{
  CLMicroLocationLegacyThrottle *v4;
  int Parameters;
  double v6;
  uint64_t LocalizationTime;
  char v8;
  char v9;
  void *v10;
  void *v11;
  void *v12;
  void *v13;
  int v14;
  int v15;
  NSObject *v16;
  _QWORD *v17;
  CLMicroLocationEventLogger *v18;
  uint64_t v19;
  double v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  _BYTE *v24;
  uint64_t v25;
  NSObject *v26;
  const CLMicroLocationProto::RecordingEvent *v27;
  uint64_t v28;
  void *v29;
  const __CFString *v30;
  int v32;
  int v33;
  _QWORD *v34;
  int v35;
  double v36;
  __int128 v37;
  _BYTE buf[22];
  _QWORD v39[40];

  v39[38] = *MEMORY[0x24BDAC8D0];
  v4 = (CLMicroLocationLegacyClient *)((char *)this + 8);
  Parameters = CLMicroLocationLegacyThrottle::getParameters((CLMicroLocationLegacyClient *)((char *)this + 8), a2);
  v6 = *((double *)a2 + 1);
  v36 = v6;
  if (!Parameters)
    return 0;
  LocalizationTime = CLMicroLocationLegacyThrottle::getLocalizationTime(v4);
  v9 = v8;
  +[ULDefaultsSingleton shared](ULDefaultsSingleton, "shared");
  v10 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v10, "defaultsDictionary");
  v11 = (void *)objc_claimAutoreleasedReturnValue();

  objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "ULLocalizingThrottleDuration");
  v12 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v11, "objectForKey:", v12);
  v13 = (void *)objc_claimAutoreleasedReturnValue();
  if (v13 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
    v14 = objc_msgSend(v13, "intValue");
  else
    v14 = objc_msgSend(&unk_2511ED7B0, "intValue");
  v15 = v14;

  if (CLMicroLocationLegacyThrottle::isThrottle(v6, (double)v15, (uint64_t)v4, Parameters, LocalizationTime, v9))
  {
    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_39);
    v16 = logObject_MicroLocation_Default;
    if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_2419D9000, v16, OS_LOG_TYPE_DEBUG, "Throttled request", buf, 2u);
    }
    CLMicroLocationProto::LegacyThrottle::LegacyThrottle((CLMicroLocationProto::LegacyThrottle *)&v33);
    v35 |= 2u;
    if (v34 == (_QWORD *)MEMORY[0x24BEDD958])
    {
      v17 = (_QWORD *)operator new();
      *v17 = 0;
      v17[1] = 0;
      v17[2] = 0;
      v34 = v17;
    }
    MEMORY[0x2426A02C4]();
    v18 = (CLMicroLocationEventLogger *)*((_QWORD *)this + 11);
    v32 = 0;
    boost::uuids::detail::random_provider_base::random_provider_base((boost::uuids::detail::random_provider_base *)&v32);
    *(_QWORD *)&v37 = boost::uuids::random_generator_pure::operator()((uint64_t)&v32);
    *((_QWORD *)&v37 + 1) = v19;
    v20 = cl::chrono::CFAbsoluteTimeClock::now();
    CLMicroLocationProtobufHelper::createLoggedEvent<CLMicroLocationProto::LegacyThrottle>(&v37, &v33, (uint64_t)buf, v20);
    CLMicroLocationEventLogger::logEvent(v18, (Entry *)buf);
    CLMicroLocationProto::ReceivedEvent::~ReceivedEvent((CLMicroLocationProto::ReceivedEvent *)v39);
    boost::uuids::detail::random_provider_base::destroy((boost::uuids::detail::random_provider_base *)&v32);
    CLMicroLocationProto::LegacyThrottle::~LegacyThrottle((CLMicroLocationProto::LegacyThrottle *)&v33);
    return 0;
  }
  if (*((_BYTE *)this + 56))
  {
    v33 = 0;
    boost::uuids::detail::random_provider_base::random_provider_base((boost::uuids::detail::random_provider_base *)&v33);
    *(_QWORD *)buf = boost::uuids::random_generator_pure::operator()((uint64_t)&v33);
    *(_QWORD *)&buf[8] = v22;
    boost::uuids::detail::random_provider_base::destroy((boost::uuids::detail::random_provider_base *)&v33);
    if (!*((_BYTE *)this + 56))
      std::__throw_bad_optional_access[abi:ne180100]();
    v23 = (*(uint64_t (**)(_QWORD, _QWORD, _QWORD, _BYTE *, double *, BOOL))(**((_QWORD **)this + 10) + 48))(*((_QWORD *)this + 10), *((_QWORD *)this + 5), *((_QWORD *)this + 6), buf, &v36, Parameters == 1);
    v21 = v23;
    v24 = (char *)this + 73;
    if (!*((_BYTE *)this + 73))
    {
      if (!(_DWORD)v23)
        goto LABEL_25;
LABEL_23:
      CLMicroLocationLegacyThrottle::setLocalizationTime((uint64_t)v4, (uint64_t *)&v36);
      v21 = 1;
      goto LABEL_25;
    }
LABEL_21:
    v33 = 0;
    boost::uuids::detail::random_provider_base::random_provider_base((boost::uuids::detail::random_provider_base *)&v33);
    *(_QWORD *)buf = boost::uuids::random_generator_pure::operator()((uint64_t)&v33);
    *(_QWORD *)&buf[8] = v25;
    boost::uuids::detail::random_provider_base::destroy((boost::uuids::detail::random_provider_base *)&v33);
    if (!*v24)
      std::__throw_bad_optional_access[abi:ne180100]();
    if (((v21 | (*(unsigned int (**)(_QWORD, _QWORD, _QWORD, _BYTE *, double *, BOOL))(**((_QWORD **)this + 10) + 48))(*((_QWORD *)this + 10), *(_QWORD *)((char *)this + 57), *(_QWORD *)((char *)this + 65), buf, &v36, Parameters == 1)) & 1) == 0)
    {
      v21 = 0;
      goto LABEL_25;
    }
    goto LABEL_23;
  }
  v21 = 0;
  v24 = (char *)this + 73;
  if (*((_BYTE *)this + 73))
    goto LABEL_21;
LABEL_25:
  if (onceToken_MicroLocation_Default != -1)
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_39);
  v26 = (id)logObject_MicroLocation_Default;
  if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
  {
    CLMicroLocationProtobufHelper::getRecordingTriggerString(a2, v27);
    v28 = objc_claimAutoreleasedReturnValue();
    v29 = (void *)v28;
    v30 = CFSTR("NO");
    if ((_DWORD)v21)
      v30 = CFSTR("YES");
    *(_DWORD *)buf = 138412546;
    *(_QWORD *)&buf[4] = v28;
    *(_WORD *)&buf[12] = 2112;
    *(_QWORD *)&buf[14] = v30;
    _os_log_impl(&dword_2419D9000, v26, OS_LOG_TYPE_DEFAULT, "Localization requested, type: %@, success: %@", buf, 0x16u);

  }
  return v21;
}

void sub_241A4AC70(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t CLMicroLocationLegacyClient::requestRecordingIfPossible(CLMicroLocationLegacyClient *this, const CLMicroLocationProto::RecordingEvent *a2)
{
  CLMicroLocationLegacyThrottle *v4;
  unint64_t Parameters;
  double v6;
  unint64_t v7;
  BOOL v8;
  uint64_t v9;
  void *v11;
  void *v12;
  void *v13;
  void *v14;
  int v15;
  int v16;
  uint64_t v17;
  uint64_t RecordingTime;
  char v19;
  uint64_t isThrottle;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  int v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  NSObject *v35;
  const CLMicroLocationProto::RecordingEvent *v36;
  uint64_t v37;
  void *v38;
  const __CFString *v39;
  double v40;
  _BYTE buf[22];
  _BYTE v42[17];
  _BYTE v43[17];
  uint64_t v44;

  v44 = *MEMORY[0x24BDAC8D0];
  v4 = (CLMicroLocationLegacyClient *)((char *)this + 8);
  Parameters = CLMicroLocationLegacyThrottle::getParameters((CLMicroLocationLegacyClient *)((char *)this + 8), a2);
  v6 = *((double *)a2 + 1);
  v40 = v6;
  if (!*((_BYTE *)this + 56))
    return 0;
  v7 = HIDWORD(Parameters);
  v8 = !*((_BYTE *)this + 73) || HIDWORD(Parameters) == 0;
  if (v8 || *((_BYTE *)this + 96) || *((_BYTE *)this + 97) || !*((_BYTE *)this + 98))
    return 0;
  +[ULDefaultsSingleton shared](ULDefaultsSingleton, "shared");
  v11 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v11, "defaultsDictionary");
  v12 = (void *)objc_claimAutoreleasedReturnValue();

  objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "ULRecordingThrottleDuration");
  v13 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v12, "objectForKey:", v13);
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  if (!v14)
    goto LABEL_14;
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0)
    v15 = objc_msgSend(v14, "intValue");
  else
LABEL_14:
    v15 = objc_msgSend(&unk_2511ED7C8, "intValue");
  v16 = v15;

  v17 = *((_DWORD *)this + 25) == 1 ? ULSettings::get<ULSettings::RecordingThrottleDurationUnstableModel>() : v16;
  RecordingTime = CLMicroLocationLegacyThrottle::getRecordingTime(v4);
  isThrottle = CLMicroLocationLegacyThrottle::isThrottle(v6, (double)v17, (uint64_t)v4, v7, RecordingTime, v19);
  if ((isThrottle & 1) != 0)
    return 0;
  if ((*((_BYTE *)a2 + 141) & 4) == 0)
    goto LABEL_27;
  v21 = *((_QWORD *)a2 + 11);
  if (!v21)
  {
    isThrottle = CLMicroLocationProto::RecordingEvent::default_instance((CLMicroLocationProto::RecordingEvent *)isThrottle);
    v21 = *(_QWORD *)(isThrottle + 88);
  }
  if ((*(_BYTE *)(v21 + 44) & 8) == 0)
    goto LABEL_27;
  v22 = *((_QWORD *)a2 + 11);
  if (!v22)
    v22 = *(_QWORD *)(CLMicroLocationProto::RecordingEvent::default_instance((CLMicroLocationProto::RecordingEvent *)isThrottle)
                    + 88);
  CLMicroLocationProtobufHelper::uuidFromProtobuf(*(uint64_t ***)(v22 + 24), buf);
  if (buf[16])
  {
    v23 = *(_QWORD *)buf;
    v24 = *(_QWORD *)&buf[8];
  }
  else
  {
LABEL_27:
    *(_DWORD *)buf = 0;
    boost::uuids::detail::random_provider_base::random_provider_base((boost::uuids::detail::random_provider_base *)buf);
    v23 = boost::uuids::random_generator_pure::operator()((uint64_t)buf);
    v24 = v25;
    boost::uuids::detail::random_provider_base::destroy((boost::uuids::detail::random_provider_base *)buf);
  }
  if (!*((_BYTE *)this + 56))
  {
    v31 = 0;
    v9 = 0;
    if (!*((_BYTE *)this + 73))
      goto LABEL_35;
LABEL_33:
    v32 = *((_QWORD *)this + 10);
    v33 = *(_QWORD *)((char *)this + 57);
    v34 = *(_QWORD *)((char *)this + 65);
    v42[0] = 0;
    v42[16] = 0;
    if (((v31 | (*(unsigned int (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, _BYTE *, double *))(*(_QWORD *)v32 + 56))(v32, v33, v34, v23, v24, v42, &v40)) & 1) == 0)goto LABEL_31;
LABEL_34:
    CLMicroLocationLegacyThrottle::setRecordingTime((uint64_t)v4, (uint64_t *)&v40);
    v9 = 1;
    goto LABEL_35;
  }
  v26 = *((_QWORD *)this + 10);
  v27 = *((_QWORD *)this + 5);
  v28 = *((_QWORD *)this + 6);
  *(_DWORD *)buf = 0;
  boost::uuids::detail::random_provider_base::random_provider_base((boost::uuids::detail::random_provider_base *)buf);
  v29 = boost::uuids::random_generator_pure::operator()((uint64_t)buf);
  v43[0] = 0;
  v43[16] = 0;
  v31 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, _BYTE *, double *))(*(_QWORD *)v26 + 56))(v26, v27, v28, v29, v30, v43, &v40);
  boost::uuids::detail::random_provider_base::destroy((boost::uuids::detail::random_provider_base *)buf);
  if (*((_BYTE *)this + 73))
    goto LABEL_33;
  if (v31)
    goto LABEL_34;
LABEL_31:
  v9 = 0;
LABEL_35:
  _CLLogObjectForCategory_MicroLocation_Default();
  v35 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
  {
    CLMicroLocationProtobufHelper::getRecordingTriggerString(a2, v36);
    v37 = objc_claimAutoreleasedReturnValue();
    v38 = (void *)v37;
    v39 = CFSTR("NO");
    if ((_DWORD)v9)
      v39 = CFSTR("YES");
    *(_DWORD *)buf = 138412546;
    *(_QWORD *)&buf[4] = v37;
    *(_WORD *)&buf[12] = 2112;
    *(_QWORD *)&buf[14] = v39;
    _os_log_impl(&dword_2419D9000, v35, OS_LOG_TYPE_DEFAULT, "Recording requested, type: %@, success: %@", buf, 0x16u);

  }
  return v9;
}

void sub_241A4B074(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void CLMicroLocationProtobufHelper::createLoggedEvent<CLMicroLocationProto::LegacyThrottle>(_OWORD *a1@<X0>, int *a2@<X1>, uint64_t a3@<X8>, double a4@<D0>)
{
  const CLMicroLocationProto::LegacyThrottle *v8;
  _BYTE v9[304];

  CLMicroLocationProto::ReceivedEvent::ReceivedEvent((CLMicroLocationProto::ReceivedEvent *)v9);
  CLMicroLocationProtobufHelper::setSpecificLoggedEvent((CLMicroLocationProtobufHelper *)v9, (CLMicroLocationProto::ReceivedEvent *)a2, v8);
  CLMicroLocationLoggedEventsTable::Entry::Entry(a3, a1, a2[4], (CLMicroLocationProto::ReceivedEvent *)v9, a4);
  CLMicroLocationProto::ReceivedEvent::~ReceivedEvent((CLMicroLocationProto::ReceivedEvent *)v9);
}

void sub_241A4B14C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  CLMicroLocationProto::ReceivedEvent::~ReceivedEvent((CLMicroLocationProto::ReceivedEvent *)&a9);
  _Unwind_Resume(a1);
}

uint64_t ULSettings::get<ULSettings::RecordingThrottleDurationUnstableModel>()
{
  void *v0;
  void *v1;
  void *v2;
  void *v3;
  int v4;
  uint64_t v5;

  +[ULDefaultsSingleton shared](ULDefaultsSingleton, "shared");
  v0 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v0, "defaultsDictionary");
  v1 = (void *)objc_claimAutoreleasedReturnValue();

  objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "ULRecordingThrottleDurationUnstableModel");
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v1, "objectForKey:", v2);
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  if (v3 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
    v4 = objc_msgSend(v3, "intValue");
  else
    v4 = objc_msgSend(&unk_2511ED798, "intValue");
  v5 = v4;

  return v5;
}

void sub_241A4B220(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void ___ZL45_CLLogObjectForCategory_MicroLocation_Defaultv_block_invoke_32()
{
  os_log_t v0;
  void *v1;

  v0 = os_log_create("com.apple.MicroLocation", "MicroLocation");
  v1 = (void *)logObject_MicroLocation_Default;
  logObject_MicroLocation_Default = (uint64_t)v0;

}

void CLMicroLocationResultToPublish::CLMicroLocationResultToPublish(CLMicroLocationResultToPublish *this, const CLMicroLocationResultToPublish *a2)
{
  __int128 v4;
  int v5;

  *(_QWORD *)this = 0;
  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 2) = 0;
  std::vector<CLMicroLocationResultInternal>::__init_with_size[abi:ne180100]<CLMicroLocationResultInternal*,CLMicroLocationResultInternal*>(this, *(const void **)a2, *((_QWORD *)a2 + 1), (uint64_t)(*((_QWORD *)a2 + 1) - *(_QWORD *)a2) >> 5);
  v4 = *(_OWORD *)((char *)a2 + 24);
  *(_OWORD *)((char *)this + 33) = *(_OWORD *)((char *)a2 + 33);
  *(_OWORD *)((char *)this + 24) = v4;
  std::__optional_copy_base<std::string,false>::__optional_copy_base[abi:ne180100]((std::string *)((char *)this + 56), (__int128 *)((char *)a2 + 56));
  std::__optional_copy_base<std::unordered_map<std::string,AnchorValueStatistics>,false>::__optional_copy_base[abi:ne180100]((_BYTE *)this + 88, (uint64_t)a2 + 88);
  v5 = *((_DWORD *)a2 + 34);
  *((_QWORD *)this + 18) = 0;
  *((_DWORD *)this + 34) = v5;
  *((_QWORD *)this + 19) = 0;
  *((_QWORD *)this + 20) = 0;
  std::vector<CLMicroLocationProto::ConfidenceReason>::__init_with_size[abi:ne180100]<CLMicroLocationProto::ConfidenceReason*,CLMicroLocationProto::ConfidenceReason*>((_QWORD *)this + 18, *((const void **)a2 + 18), *((_QWORD *)a2 + 19), (uint64_t)(*((_QWORD *)a2 + 19) - *((_QWORD *)a2 + 18)) >> 2);
}

void sub_241A4B328(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void **v2;
  uint64_t v3;
  void *v5;

  if (*(_BYTE *)(v1 + 128))
    std::__hash_table<std::__hash_value_type<std::string,AnchorValueStatistics>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,AnchorValueStatistics>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,AnchorValueStatistics>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,AnchorValueStatistics>>>::~__hash_table(v3);
  if (*(_BYTE *)(v1 + 80) && *(char *)(v1 + 79) < 0)
    operator delete(*v2);
  v5 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v5;
    operator delete(v5);
  }
  _Unwind_Resume(exception_object);
}

_QWORD *std::vector<CLMicroLocationResultInternal>::__init_with_size[abi:ne180100]<CLMicroLocationResultInternal*,CLMicroLocationResultInternal*>(_QWORD *result, const void *a2, uint64_t a3, unint64_t a4)
{
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;

  if (a4)
  {
    v6 = result;
    result = std::vector<CLMiLoOdometryTable::Entry>::__vallocate[abi:ne180100](result, a4);
    v7 = v6[1];
    v8 = a3 - (_QWORD)a2;
    if (v8)
      result = memmove((void *)v6[1], a2, v8 - 4);
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_241A4B3D8(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

_BYTE *std::__optional_copy_base<std::unordered_map<std::string,AnchorValueStatistics>,false>::__optional_copy_base[abi:ne180100](_BYTE *a1, uint64_t a2)
{
  *a1 = 0;
  a1[40] = 0;
  if (*(_BYTE *)(a2 + 40))
  {
    std::unordered_map<std::string,AnchorValueStatistics>::unordered_map((uint64_t)a1, a2);
    a1[40] = 1;
  }
  return a1;
}

void sub_241A4B434(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (*(_BYTE *)(v1 + 40))
    std::__hash_table<std::__hash_value_type<std::string,AnchorValueStatistics>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,AnchorValueStatistics>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,AnchorValueStatistics>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,AnchorValueStatistics>>>::~__hash_table(v1);
  _Unwind_Resume(exception_object);
}

void std::__tree<std::__value_type<std::string,CLMicroLocationResultToPublish>,std::__map_value_compare<std::string,std::__value_type<std::string,CLMicroLocationResultToPublish>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,CLMicroLocationResultToPublish>>>::destroy(uint64_t a1, _QWORD *a2)
{
  if (a2)
  {
    std::__tree<std::__value_type<std::string,CLMicroLocationResultToPublish>,std::__map_value_compare<std::string,std::__value_type<std::string,CLMicroLocationResultToPublish>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,CLMicroLocationResultToPublish>>>::destroy(a1, *a2);
    std::__tree<std::__value_type<std::string,CLMicroLocationResultToPublish>,std::__map_value_compare<std::string,std::__value_type<std::string,CLMicroLocationResultToPublish>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,CLMicroLocationResultToPublish>>>::destroy(a1, a2[1]);
    std::__destroy_at[abi:ne180100]<std::pair<std::string const,CLMicroLocationResultToPublish>,0>((uint64_t)(a2 + 4));
    operator delete(a2);
  }
}

void std::__destroy_at[abi:ne180100]<std::pair<std::string const,CLMicroLocationResultToPublish>,0>(uint64_t a1)
{
  void *v2;
  void *v3;

  v2 = *(void **)(a1 + 168);
  if (v2)
  {
    *(_QWORD *)(a1 + 176) = v2;
    operator delete(v2);
  }
  if (*(_BYTE *)(a1 + 152))
    std::__hash_table<std::__hash_value_type<std::string,AnchorValueStatistics>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,AnchorValueStatistics>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,AnchorValueStatistics>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,AnchorValueStatistics>>>::~__hash_table(a1 + 112);
  if (*(_BYTE *)(a1 + 104) && *(char *)(a1 + 103) < 0)
    operator delete(*(void **)(a1 + 80));
  v3 = *(void **)(a1 + 24);
  if (v3)
  {
    *(_QWORD *)(a1 + 32) = v3;
    operator delete(v3);
  }
  if (*(char *)(a1 + 23) < 0)
    operator delete(*(void **)a1);
}

uint64_t *std::__tree<std::__value_type<std::string,CLMicroLocationResultToPublish>,std::__map_value_compare<std::string,std::__value_type<std::string,CLMicroLocationResultToPublish>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,CLMicroLocationResultToPublish>>>::__emplace_multi<std::pair<char const*,CLMicroLocationResultToPublish>>(uint64_t **a1, uint64_t a2)
{
  uint64_t **leaf_high;
  uint64_t *v4;
  uint64_t v6;
  uint64_t *v7[3];

  std::__tree<std::__value_type<std::string,CLMicroLocationResultToPublish>,std::__map_value_compare<std::string,std::__value_type<std::string,CLMicroLocationResultToPublish>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,CLMicroLocationResultToPublish>>>::__construct_node<std::pair<char const*,CLMicroLocationResultToPublish>>((uint64_t)a1, a2, (uint64_t)v7);
  leaf_high = (uint64_t **)std::__tree<std::__value_type<std::string,CLMicroLocationResultToPublish>,std::__map_value_compare<std::string,std::__value_type<std::string,CLMicroLocationResultToPublish>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,CLMicroLocationResultToPublish>>>::__find_leaf_high((uint64_t)a1, &v6, (const void **)v7[0] + 4);
  std::__tree<CLMicroLocationRecordingCompletionMetaInformation::RecordingError>::__insert_node_at(a1, v6, leaf_high, v7[0]);
  v4 = v7[0];
  v7[0] = 0;
  std::unique_ptr<std::__tree_node<std::__value_type<std::string,CLMicroLocationResultToPublish>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::string,CLMicroLocationResultToPublish>,void *>>>>::reset[abi:ne180100]((uint64_t)v7, 0);
  return v4;
}

void sub_241A4B57C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::unique_ptr<std::__tree_node<std::__value_type<std::string,CLMicroLocationResultToPublish>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::string,CLMicroLocationResultToPublish>,void *>>>>::reset[abi:ne180100]((uint64_t)va, 0);
  _Unwind_Resume(a1);
}

uint64_t std::__tree<std::__value_type<std::string,CLMicroLocationResultToPublish>,std::__map_value_compare<std::string,std::__value_type<std::string,CLMicroLocationResultToPublish>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,CLMicroLocationResultToPublish>>>::__construct_node<std::pair<char const*,CLMicroLocationResultToPublish>>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v5;
  void *v6;
  uint64_t result;

  v5 = a1 + 8;
  v6 = operator new(0xE0uLL);
  *(_QWORD *)a3 = v6;
  *(_QWORD *)(a3 + 8) = v5;
  *(_BYTE *)(a3 + 16) = 0;
  result = std::pair<std::string const,CLMicroLocationResultToPublish>::pair[abi:ne180100]<char const*,CLMicroLocationResultToPublish,0>((uint64_t)v6 + 32, a2);
  *(_BYTE *)(a3 + 16) = 1;
  return result;
}

void sub_241A4B5E4(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::unique_ptr<std::__tree_node<std::__value_type<std::string,CLMicroLocationResultToPublish>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::string,CLMicroLocationResultToPublish>,void *>>>>::reset[abi:ne180100](v1, 0);
  _Unwind_Resume(a1);
}

_QWORD *std::__tree<std::__value_type<std::string,CLMicroLocationResultToPublish>,std::__map_value_compare<std::string,std::__value_type<std::string,CLMicroLocationResultToPublish>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,CLMicroLocationResultToPublish>>>::__find_leaf_high(uint64_t a1, _QWORD *a2, const void **a3)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v7;
  _QWORD *result;

  v5 = (_QWORD *)(a1 + 8);
  v4 = *(_QWORD *)(a1 + 8);
  if (v4)
  {
    v7 = a1 + 16;
    do
    {
      while (1)
      {
        v5 = (_QWORD *)v4;
        if (!std::less<std::string>::operator()[abi:ne180100](v7, a3, (const void **)(v4 + 32)))
          break;
        v4 = *v5;
        result = v5;
        if (!*v5)
          goto LABEL_9;
      }
      v4 = v5[1];
    }
    while (v4);
    result = v5 + 1;
  }
  else
  {
    result = (_QWORD *)(a1 + 8);
  }
LABEL_9:
  *a2 = v5;
  return result;
}

uint64_t std::pair<std::string const,CLMicroLocationResultToPublish>::pair[abi:ne180100]<char const*,CLMicroLocationResultToPublish,0>(uint64_t a1, uint64_t a2)
{
  _QWORD *v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;

  v4 = std::string::basic_string[abi:ne180100]<0>((_QWORD *)a1, *(char **)a2);
  v4[3] = 0;
  v4[4] = 0;
  v4[5] = 0;
  *(_OWORD *)(v4 + 3) = *(_OWORD *)(a2 + 8);
  v4[5] = *(_QWORD *)(a2 + 24);
  *(_QWORD *)(a2 + 8) = 0;
  *(_QWORD *)(a2 + 16) = 0;
  *(_QWORD *)(a2 + 24) = 0;
  v5 = *(_OWORD *)(a2 + 32);
  v6 = *(_OWORD *)(a2 + 41);
  *((_BYTE *)v4 + 80) = 0;
  *(_OWORD *)((char *)v4 + 57) = v6;
  *((_OWORD *)v4 + 3) = v5;
  *((_BYTE *)v4 + 104) = 0;
  if (*(_BYTE *)(a2 + 88))
  {
    v7 = *(_OWORD *)(a2 + 64);
    v4[12] = *(_QWORD *)(a2 + 80);
    *((_OWORD *)v4 + 5) = v7;
    *(_QWORD *)(a2 + 72) = 0;
    *(_QWORD *)(a2 + 80) = 0;
    *(_QWORD *)(a2 + 64) = 0;
    *(_BYTE *)(a1 + 104) = 1;
  }
  *(_BYTE *)(a1 + 112) = 0;
  *(_BYTE *)(a1 + 152) = 0;
  if (*(_BYTE *)(a2 + 136))
  {
    std::__hash_table<CLMicroLocationFingerprint::Measurement,CLMicroLocationFingerprint::Measurement::HashMeasurement,CLMicroLocationFingerprint::Measurement::PredicateMeasurement,std::allocator<CLMicroLocationFingerprint::Measurement>>::__hash_table(a1 + 112, (uint64_t *)(a2 + 96));
    *(_BYTE *)(a1 + 152) = 1;
  }
  *(_DWORD *)(a1 + 160) = *(_DWORD *)(a2 + 144);
  *(_QWORD *)(a1 + 176) = 0;
  *(_QWORD *)(a1 + 184) = 0;
  *(_QWORD *)(a1 + 168) = 0;
  *(_OWORD *)(a1 + 168) = *(_OWORD *)(a2 + 152);
  *(_QWORD *)(a1 + 184) = *(_QWORD *)(a2 + 168);
  *(_QWORD *)(a2 + 152) = 0;
  *(_QWORD *)(a2 + 160) = 0;
  *(_QWORD *)(a2 + 168) = 0;
  return a1;
}

void std::unique_ptr<std::__tree_node<std::__value_type<std::string,CLMicroLocationResultToPublish>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::string,CLMicroLocationResultToPublish>,void *>>>>::reset[abi:ne180100](uint64_t a1, uint64_t a2)
{
  void *v2;

  v2 = *(void **)a1;
  *(_QWORD *)a1 = a2;
  if (v2)
  {
    if (*(_BYTE *)(a1 + 16))
      std::__destroy_at[abi:ne180100]<std::pair<std::string const,CLMicroLocationResultToPublish>,0>((uint64_t)v2 + 32);
    operator delete(v2);
  }
}

_QWORD *CLMicroLocationCoreAnalyticsPublishHelper::generationAlgorithmToString@<X0>(int a1@<W0>, _QWORD *a2@<X8>)
{
  return std::string::basic_string[abi:ne180100]<0>(a2, off_2511D4938[a1]);
}

id CLMicroLocationCoreAnalyticsPublishHelper::initializeModelLearningEventMetricsDict(int a1, int a2, const std::string *a3)
{
  void *v5;
  void *v6;
  std::string *p_p;
  void *v8;
  void *v9;
  std::string *v10;
  void *v11;
  std::string __p;

  if (a1)
  {
    objc_msgSend(MEMORY[0x24BDBCED8], "dictionary");
    v5 = (void *)objc_claimAutoreleasedReturnValue();
    v6 = (void *)MEMORY[0x24BDD17C8];
    CLMicroLocationProtobufHelper::ModelTypeToDomain(a2, &__p);
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      p_p = &__p;
    else
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    objc_msgSend(v6, "stringWithUTF8String:", p_p);
    v8 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v5, "setObject:forKeyedSubscript:", v8, CFSTR("domain"));

    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p.__r_.__value_.__l.__data_);
    objc_msgSend(v5, "setObject:forKeyedSubscript:", MEMORY[0x24BDBD1C8], CFSTR("cancelled"));
    objc_msgSend(v5, "setObject:forKeyedSubscript:", MEMORY[0x24BDBD1C0], CFSTR("valid"));
    if (a3[1].__r_.__value_.__s.__data_[0])
    {
      v9 = (void *)MEMORY[0x24BDD17C8];
      CLMicroLocationClientUtils::getClientIdFromClientIdAndServiceUuid(a3, &__p);
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v10 = &__p;
      else
        v10 = (std::string *)__p.__r_.__value_.__r.__words[0];
      objc_msgSend(v9, "stringWithUTF8String:", v10);
      v11 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v5, "setObject:forKeyedSubscript:", v11, CFSTR("clientIdentifier"));

      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__p.__r_.__value_.__l.__data_);
    }
  }
  else
  {
    v5 = 0;
  }
  return v5;
}

void sub_241A4B8F8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  void *v15;
  void *v16;

  if (a15 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

void CLMicroLocationCoreAnalyticsPublishHelper::updateModelRfCharacteristics(void *a1, CLMicroLocationFingerprintVector *a2, CLMicroLocationFingerprintVector *a3, unsigned __int8 a4, double a5)
{
  id v8;
  unint64_t v9;
  uint64_t v10;
  void *v11;
  unint64_t v12;
  void *v13;
  void *v14;
  void *v15;
  void *v16;
  void *v17;
  void *v18;
  double v19;
  void *v20;
  void *v21;
  void *v22;
  void *v23;
  _QWORD *v24;
  int *v25;
  int *v26;
  int *v27;
  int *v28;
  int v29;
  void *v30;
  void *v31;
  void *v32;
  int *v33;
  int *v34;
  int *v35;
  int *v36;
  int v37;
  void *v38;
  void *v39;
  void *v40;
  _QWORD **v41;
  _QWORD *v42;
  _QWORD **v43;
  int v44;
  _QWORD *v45;
  int *v46;
  void *v47;
  void *v48;
  void *v49;
  uint64_t *v50;
  uint64_t v51;
  void *v52;
  uint64_t v53;
  void *v54;
  uint64_t *v55;
  uint64_t v56;
  void *v57;
  uint64_t v58;
  void *v59;
  uint64_t *v60;
  uint64_t v61;
  void *v62;
  uint64_t v63;
  void *v64;
  int v65;
  _QWORD v66[13];
  unint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t *v70;
  _QWORD *v71[2];
  uint64_t *v72;
  _QWORD *v73[2];
  uint64_t *v74;
  _QWORD *v75[2];
  double v76;
  double v77;
  double v78;
  double v79;
  double v80;
  __int128 v81;
  __int128 v82;
  int v83;
  double v84;
  int *v85;

  v84 = a5;
  v8 = a1;
  if (v8)
  {
    v81 = 0u;
    v82 = 0u;
    v83 = 1065353216;
    v9 = CLMicroLocationFingerprintVector::size(a2);
    v10 = a4;
    if (a4)
      v9 += CLMicroLocationFingerprintVector::size(a3);
    objc_msgSend(MEMORY[0x24BDD16E0], "numberWithUnsignedLong:", v9);
    v11 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v8, "setObject:forKeyedSubscript:", v11, CFSTR("numFingerprints"));

    if (5 * (v9 / 5) >= 0x1F4)
      v12 = 500;
    else
      v12 = 5 * (v9 / 5);
    objc_msgSend(MEMORY[0x24BDD16E0], "numberWithUnsignedLong:", v12);
    v13 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v8, "setObject:forKeyedSubscript:", v13, CFSTR("numFingerprintsBounded"));

    if (v9)
    {
      v79 = 1.79769313e308;
      v80 = -1.79769313e308;
      v77 = 1.79769313e308;
      v78 = -1.79769313e308;
      v75[1] = 0;
      v76 = 0.0;
      v74 = (uint64_t *)v75;
      v75[0] = 0;
      v73[0] = 0;
      v73[1] = 0;
      v71[1] = 0;
      v72 = (uint64_t *)v73;
      v70 = (uint64_t *)v71;
      v71[0] = 0;
      v68 = -1;
      v69 = 0;
      v67 = 0;
      v66[0] = &v84;
      v66[1] = &v81;
      v66[2] = &v80;
      v66[3] = &v79;
      v66[4] = &v78;
      v66[5] = &v77;
      v66[6] = &v76;
      v66[7] = &v74;
      v66[8] = &v72;
      v66[9] = &v70;
      v66[10] = &v69;
      v66[11] = &v68;
      v66[12] = &v67;
      CLMicroLocationCoreAnalyticsPublishHelper::updateModelRfCharacteristics(NSMutableDictionary *,std::chrono::time_point<cl::chrono::CFAbsoluteTimeClock,std::chrono::duration<long double,std::ratio<1l,1l>>>,CLMicroLocationFingerprintVector const&,std::optional<std::reference_wrapper<CLMicroLocationFingerprintVector const>>)::$_0::operator()((uint64_t)v66, a2);
      if (v10)
        CLMicroLocationCoreAnalyticsPublishHelper::updateModelRfCharacteristics(NSMutableDictionary *,std::chrono::time_point<cl::chrono::CFAbsoluteTimeClock,std::chrono::duration<long double,std::ratio<1l,1l>>>,CLMicroLocationFingerprintVector const&,std::optional<std::reference_wrapper<CLMicroLocationFingerprintVector const>>)::$_0::operator()((uint64_t)v66, a3);
      objc_msgSend(MEMORY[0x24BDD16E0], "numberWithDouble:", v80);
      v14 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v8, "setObject:forKeyedSubscript:", v14, CFSTR("ageOfOldestFingerprint"));

      objc_msgSend(MEMORY[0x24BDD16E0], "numberWithInt:", (int)v80);
      v15 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v8, "setObject:forKeyedSubscript:", v15, CFSTR("ageOfOldestFingerprintBounded"));

      objc_msgSend(MEMORY[0x24BDD16E0], "numberWithDouble:", v79);
      v16 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v8, "setObject:forKeyedSubscript:", v16, CFSTR("ageOfNewestFingerprint"));

      objc_msgSend(MEMORY[0x24BDD16E0], "numberWithDouble:", v78);
      v17 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v8, "setObject:forKeyedSubscript:", v17, CFSTR("maxFingerprintDuration"));

      objc_msgSend(MEMORY[0x24BDD16E0], "numberWithDouble:", v77);
      v18 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v8, "setObject:forKeyedSubscript:", v18, CFSTR("minFingerprintDuration"));

      v19 = (double)v9;
      objc_msgSend(MEMORY[0x24BDD16E0], "numberWithDouble:", v76 / (double)v9);
      v20 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v8, "setObject:forKeyedSubscript:", v20, CFSTR("avgFingerprintDuration"));

      objc_msgSend(MEMORY[0x24BDD16E0], "numberWithUnsignedLong:", v69);
      v21 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v8, "setObject:forKeyedSubscript:", v21, CFSTR("maxFingerprintSize"));

      objc_msgSend(MEMORY[0x24BDD16E0], "numberWithUnsignedLong:", v68);
      v22 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v8, "setObject:forKeyedSubscript:", v22, CFSTR("minFingerprintSize"));

      objc_msgSend(MEMORY[0x24BDD16E0], "numberWithDouble:", (double)v67 / (double)v9);
      v23 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v8, "setObject:forKeyedSubscript:", v23, CFSTR("avgFingerprintSize"));

      v24 = v71[0];
      if (v71[0])
      {
        v25 = (int *)v71;
        v26 = (int *)v71[0];
        do
        {
          v27 = v26;
          v28 = v25;
          v29 = v26[8];
          if (v29 >= 1)
            v25 = v26;
          else
            v26 += 2;
          v26 = *(int **)v26;
        }
        while (v26);
        if (v25 != (int *)v71)
        {
          if (v29 < 1)
            v27 = v28;
          if (v27[8] <= 1)
          {
            v65 = 1;
            v85 = &v65;
            objc_msgSend(MEMORY[0x24BDD16E0], "numberWithUnsignedLong:", std::__tree<std::__value_type<CLMicroLocationProto::DataType,unsigned long>,std::__map_value_compare<CLMicroLocationProto::DataType,std::__value_type<CLMicroLocationProto::DataType,unsigned long>,std::less<CLMicroLocationProto::DataType>,true>,std::allocator<std::__value_type<CLMicroLocationProto::DataType,unsigned long>>>::__emplace_unique_key_args<CLMicroLocationProto::DataType,std::piecewise_construct_t const&,std::tuple<CLMicroLocationProto::DataType const&>,std::tuple<>>(&v74, &v65, (uint64_t)&std::piecewise_construct, &v85)[5]);
            v30 = (void *)objc_claimAutoreleasedReturnValue();
            objc_msgSend(v8, "setObject:forKeyedSubscript:", v30, CFSTR("maxWifiFingerprintSize"));

            v65 = 1;
            v85 = &v65;
            objc_msgSend(MEMORY[0x24BDD16E0], "numberWithUnsignedLong:", std::__tree<std::__value_type<CLMicroLocationProto::DataType,unsigned long>,std::__map_value_compare<CLMicroLocationProto::DataType,std::__value_type<CLMicroLocationProto::DataType,unsigned long>,std::less<CLMicroLocationProto::DataType>,true>,std::allocator<std::__value_type<CLMicroLocationProto::DataType,unsigned long>>>::__emplace_unique_key_args<CLMicroLocationProto::DataType,std::piecewise_construct_t const&,std::tuple<CLMicroLocationProto::DataType const&>,std::tuple<>>(&v72, &v65, (uint64_t)&std::piecewise_construct, &v85)[5]);
            v31 = (void *)objc_claimAutoreleasedReturnValue();
            objc_msgSend(v8, "setObject:forKeyedSubscript:", v31, CFSTR("minWifiFingerprintSize"));

            v65 = 1;
            v85 = &v65;
            objc_msgSend(MEMORY[0x24BDD16E0], "numberWithDouble:", (double)(unint64_t)std::__tree<std::__value_type<CLMicroLocationProto::DataType,unsigned long>,std::__map_value_compare<CLMicroLocationProto::DataType,std::__value_type<CLMicroLocationProto::DataType,unsigned long>,std::less<CLMicroLocationProto::DataType>,true>,std::allocator<std::__value_type<CLMicroLocationProto::DataType,unsigned long>>>::__emplace_unique_key_args<CLMicroLocationProto::DataType,std::piecewise_construct_t const&,std::tuple<CLMicroLocationProto::DataType const&>,std::tuple<>>(&v70, &v65, (uint64_t)&std::piecewise_construct, &v85)[5]/ v19);
            v32 = (void *)objc_claimAutoreleasedReturnValue();
            objc_msgSend(v8, "setObject:forKeyedSubscript:", v32, CFSTR("avgWifiFingerprintSize"));

            v24 = v71[0];
          }
        }
        if (v24)
        {
          v33 = (int *)v71;
          v34 = (int *)v24;
          do
          {
            v35 = v34;
            v36 = v33;
            v37 = v34[8];
            if (v37 >= 5)
              v33 = v34;
            else
              v34 += 2;
            v34 = *(int **)v34;
          }
          while (v34);
          if (v33 != (int *)v71)
          {
            if (v37 < 5)
              v35 = v36;
            if (v35[8] <= 5)
            {
              v65 = 5;
              v85 = &v65;
              objc_msgSend(MEMORY[0x24BDD16E0], "numberWithUnsignedLong:", std::__tree<std::__value_type<CLMicroLocationProto::DataType,unsigned long>,std::__map_value_compare<CLMicroLocationProto::DataType,std::__value_type<CLMicroLocationProto::DataType,unsigned long>,std::less<CLMicroLocationProto::DataType>,true>,std::allocator<std::__value_type<CLMicroLocationProto::DataType,unsigned long>>>::__emplace_unique_key_args<CLMicroLocationProto::DataType,std::piecewise_construct_t const&,std::tuple<CLMicroLocationProto::DataType const&>,std::tuple<>>(&v74, &v65, (uint64_t)&std::piecewise_construct, &v85)[5]);
              v38 = (void *)objc_claimAutoreleasedReturnValue();
              objc_msgSend(v8, "setObject:forKeyedSubscript:", v38, CFSTR("maxBleFingerprintSize"));

              v65 = 5;
              v85 = &v65;
              objc_msgSend(MEMORY[0x24BDD16E0], "numberWithUnsignedLong:", std::__tree<std::__value_type<CLMicroLocationProto::DataType,unsigned long>,std::__map_value_compare<CLMicroLocationProto::DataType,std::__value_type<CLMicroLocationProto::DataType,unsigned long>,std::less<CLMicroLocationProto::DataType>,true>,std::allocator<std::__value_type<CLMicroLocationProto::DataType,unsigned long>>>::__emplace_unique_key_args<CLMicroLocationProto::DataType,std::piecewise_construct_t const&,std::tuple<CLMicroLocationProto::DataType const&>,std::tuple<>>(&v72, &v65, (uint64_t)&std::piecewise_construct, &v85)[5]);
              v39 = (void *)objc_claimAutoreleasedReturnValue();
              objc_msgSend(v8, "setObject:forKeyedSubscript:", v39, CFSTR("minBleFingerprintSize"));

              v65 = 5;
              v85 = &v65;
              objc_msgSend(MEMORY[0x24BDD16E0], "numberWithDouble:", (double)(unint64_t)std::__tree<std::__value_type<CLMicroLocationProto::DataType,unsigned long>,std::__map_value_compare<CLMicroLocationProto::DataType,std::__value_type<CLMicroLocationProto::DataType,unsigned long>,std::less<CLMicroLocationProto::DataType>,true>,std::allocator<std::__value_type<CLMicroLocationProto::DataType,unsigned long>>>::__emplace_unique_key_args<CLMicroLocationProto::DataType,std::piecewise_construct_t const&,std::tuple<CLMicroLocationProto::DataType const&>,std::tuple<>>(&v70, &v65, (uint64_t)&std::piecewise_construct, &v85)[5]/ v19);
              v40 = (void *)objc_claimAutoreleasedReturnValue();
              objc_msgSend(v8, "setObject:forKeyedSubscript:", v40, CFSTR("avgBleFingerprintSize"));

              v24 = v71[0];
            }
          }
          if (v24)
          {
            v41 = v71;
            do
            {
              v42 = v24;
              v43 = v41;
              v44 = *((_DWORD *)v24 + 8);
              v45 = v24 + 1;
              if (v44 >= 6)
              {
                v45 = v42;
                v41 = (_QWORD **)v42;
              }
              v24 = (_QWORD *)*v45;
            }
            while (v24);
            if (v41 != v71)
            {
              v46 = (int *)(v44 >= 6 ? v42 : v43);
              if (v46[8] <= 6)
              {
                v65 = 6;
                v85 = &v65;
                objc_msgSend(MEMORY[0x24BDD16E0], "numberWithUnsignedLong:", std::__tree<std::__value_type<CLMicroLocationProto::DataType,unsigned long>,std::__map_value_compare<CLMicroLocationProto::DataType,std::__value_type<CLMicroLocationProto::DataType,unsigned long>,std::less<CLMicroLocationProto::DataType>,true>,std::allocator<std::__value_type<CLMicroLocationProto::DataType,unsigned long>>>::__emplace_unique_key_args<CLMicroLocationProto::DataType,std::piecewise_construct_t const&,std::tuple<CLMicroLocationProto::DataType const&>,std::tuple<>>(&v74, &v65, (uint64_t)&std::piecewise_construct, &v85)[5]);
                v47 = (void *)objc_claimAutoreleasedReturnValue();
                objc_msgSend(v8, "setObject:forKeyedSubscript:", v47, CFSTR("maxUwbFingerprintSize"));

                v65 = 6;
                v85 = &v65;
                objc_msgSend(MEMORY[0x24BDD16E0], "numberWithUnsignedLong:", std::__tree<std::__value_type<CLMicroLocationProto::DataType,unsigned long>,std::__map_value_compare<CLMicroLocationProto::DataType,std::__value_type<CLMicroLocationProto::DataType,unsigned long>,std::less<CLMicroLocationProto::DataType>,true>,std::allocator<std::__value_type<CLMicroLocationProto::DataType,unsigned long>>>::__emplace_unique_key_args<CLMicroLocationProto::DataType,std::piecewise_construct_t const&,std::tuple<CLMicroLocationProto::DataType const&>,std::tuple<>>(&v72, &v65, (uint64_t)&std::piecewise_construct, &v85)[5]);
                v48 = (void *)objc_claimAutoreleasedReturnValue();
                objc_msgSend(v8, "setObject:forKeyedSubscript:", v48, CFSTR("minUwbFingerprintSize"));

                v65 = 6;
                v85 = &v65;
                objc_msgSend(MEMORY[0x24BDD16E0], "numberWithDouble:", (double)(unint64_t)std::__tree<std::__value_type<CLMicroLocationProto::DataType,unsigned long>,std::__map_value_compare<CLMicroLocationProto::DataType,std::__value_type<CLMicroLocationProto::DataType,unsigned long>,std::less<CLMicroLocationProto::DataType>,true>,std::allocator<std::__value_type<CLMicroLocationProto::DataType,unsigned long>>>::__emplace_unique_key_args<CLMicroLocationProto::DataType,std::piecewise_construct_t const&,std::tuple<CLMicroLocationProto::DataType const&>,std::tuple<>>(&v70, &v65, (uint64_t)&std::piecewise_construct, &v85)[5]/ v19);
                v49 = (void *)objc_claimAutoreleasedReturnValue();
                objc_msgSend(v8, "setObject:forKeyedSubscript:", v49, CFSTR("avgUwbFingerprintSize"));

              }
            }
          }
        }
      }
      v50 = (uint64_t *)v82;
      if ((_QWORD)v82)
      {
        v51 = 0;
        do
        {
          if (*((_DWORD *)v50 + 6) == 1)
            ++v51;
          v50 = (uint64_t *)*v50;
        }
        while (v50);
      }
      else
      {
        v51 = 0;
      }
      objc_msgSend(MEMORY[0x24BDD16E0], "numberWithLong:", v51);
      v52 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v8, "setObject:forKeyedSubscript:", v52, CFSTR("numSourcesWifi"));

      if (5 * (v51 / 5) >= 100)
        v53 = 100;
      else
        v53 = 5 * (v51 / 5);
      objc_msgSend(MEMORY[0x24BDD16E0], "numberWithLong:", v53);
      v54 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v8, "setObject:forKeyedSubscript:", v54, CFSTR("numSourcesWifiBounded"));

      v55 = (uint64_t *)v82;
      if ((_QWORD)v82)
      {
        v56 = 0;
        do
        {
          if (*((_DWORD *)v55 + 6) == 5)
            ++v56;
          v55 = (uint64_t *)*v55;
        }
        while (v55);
      }
      else
      {
        v56 = 0;
      }
      objc_msgSend(MEMORY[0x24BDD16E0], "numberWithLong:", v56);
      v57 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v8, "setObject:forKeyedSubscript:", v57, CFSTR("numSourcesBle"));

      if (v56 >= 15)
        v58 = 15;
      else
        v58 = v56;
      objc_msgSend(MEMORY[0x24BDD16E0], "numberWithLong:", v58);
      v59 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v8, "setObject:forKeyedSubscript:", v59, CFSTR("numSourcesBleBounded"));

      v60 = (uint64_t *)v82;
      if ((_QWORD)v82)
      {
        v61 = 0;
        do
        {
          if (*((_DWORD *)v60 + 6) == 6)
            ++v61;
          v60 = (uint64_t *)*v60;
        }
        while (v60);
      }
      else
      {
        v61 = 0;
      }
      objc_msgSend(MEMORY[0x24BDD16E0], "numberWithLong:", v61);
      v62 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v8, "setObject:forKeyedSubscript:", v62, CFSTR("numSourcesUwb"));

      if (v61 >= 15)
        v63 = 15;
      else
        v63 = v61;
      objc_msgSend(MEMORY[0x24BDD16E0], "numberWithLong:", v63);
      v64 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v8, "setObject:forKeyedSubscript:", v64, CFSTR("numSourcesUwbBounded"));

      std::__tree<std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>,std::__map_value_compare<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>,std::less<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes>,true>,std::allocator<std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>>>::destroy((uint64_t)&v70, v71[0]);
      std::__tree<std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>,std::__map_value_compare<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>,std::less<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes>,true>,std::allocator<std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>>>::destroy((uint64_t)&v72, v73[0]);
      std::__tree<std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>,std::__map_value_compare<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>,std::less<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes>,true>,std::allocator<std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>>>::destroy((uint64_t)&v74, v75[0]);
    }
    std::__hash_table<CLMicroLocationFingerprint::Measurement,CLMicroLocationFingerprint::Measurement::HashMeasurement,CLMicroLocationFingerprint::Measurement::PredicateMeasurement,std::allocator<CLMicroLocationFingerprint::Measurement>>::~__hash_table((uint64_t)&v81);
  }

}

void sub_241A4C2BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27,uint64_t a28,uint64_t a29,char a30,uint64_t a31,uint64_t a32,char a33)
{
  void *v33;
  void *v34;
  _QWORD **v35;
  uint64_t v36;

  std::__tree<std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>,std::__map_value_compare<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>,std::less<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes>,true>,std::allocator<std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>>>::destroy((uint64_t)&a27, v35[1]);
  std::__tree<std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>,std::__map_value_compare<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>,std::less<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes>,true>,std::allocator<std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>>>::destroy((uint64_t)&a30, v35[4]);
  std::__tree<std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>,std::__map_value_compare<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>,std::less<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes>,true>,std::allocator<std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>>>::destroy((uint64_t)&a33, v35[7]);
  std::__hash_table<CLMicroLocationFingerprint::Measurement,CLMicroLocationFingerprint::Measurement::HashMeasurement,CLMicroLocationFingerprint::Measurement::PredicateMeasurement,std::allocator<CLMicroLocationFingerprint::Measurement>>::~__hash_table(v36 - 160);

  _Unwind_Resume(a1);
}

BOOL CLMicroLocationCoreAnalyticsPublishHelper::updateModelRfCharacteristics(NSMutableDictionary *,std::chrono::time_point<cl::chrono::CFAbsoluteTimeClock,std::chrono::duration<long double,std::ratio<1l,1l>>>,CLMicroLocationFingerprintVector const&,std::optional<std::reference_wrapper<CLMicroLocationFingerprintVector const>>)::$_0::operator()(uint64_t a1, CLMicroLocationFingerprintVector *this)
{
  uint64_t v4;
  uint64_t v5;
  _BOOL8 result;
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  double *v10;
  double *v11;
  double v12;
  double *v13;
  double v14;
  double *v15;
  uint64_t *v16;
  double v17;
  double v18;
  double *v19;
  uint64_t *v20;
  double v21;
  uint64_t *v22;
  double v23;
  unint64_t *v24;
  unint64_t v25;
  unint64_t *v26;
  unint64_t v27;
  int *i;
  int *v29;
  uint64_t v30;
  uint64_t v31;
  int v32;
  uint64_t v33;
  int v34;
  BOOL v35;
  uint64_t *v36;
  uint64_t **v37;
  uint64_t *v38;
  uint64_t *v39;
  uint64_t *v40;
  uint64_t **v41;
  uint64_t v42;
  uint64_t v43;
  int v44;
  uint64_t v45;
  int v46;
  BOOL v47;
  uint64_t *v48;
  uint64_t **v49;
  uint64_t *v50;
  uint64_t *v51;
  uint64_t *v52;
  uint64_t **v53;
  uint64_t v54;
  uint64_t v55;
  int v56;
  uint64_t v57;
  int v58;
  BOOL v59;
  uint64_t *v60;
  uint64_t *v61;
  uint64_t v62;
  uint64_t **v63;
  uint64_t **v64;
  _QWORD v65[2];
  _QWORD v66[2];
  _DWORD *v67;

  v66[0] = CLMicroLocationFingerprintVector::begin(this);
  v66[1] = v4;
  v65[0] = CLMicroLocationFingerprintVector::end(this);
  v65[1] = v5;
  for (result = CLMicroLocationFingerprintVector::Iterator::operator!=(v66, v65);
        result;
        result = CLMicroLocationFingerprintVector::Iterator::operator!=(v66, v65))
  {
    v7 = CLMicroLocationFingerprintVector::Iterator::operator*(v66);
    v8 = *(uint64_t **)(v7 + 16);
    if (v8)
    {
      v9 = *(_QWORD *)(a1 + 8);
      do
      {
        std::__hash_table<CLMicroLocationFingerprint::Measurement,CLMicroLocationFingerprint::Measurement::HashMeasurement,CLMicroLocationFingerprint::Measurement::PredicateMeasurement,std::allocator<CLMicroLocationFingerprint::Measurement>>::__emplace_unique_key_args<CLMicroLocationFingerprint::Measurement,CLMicroLocationFingerprint::Measurement const&>(v9, (uint64_t)(v8 + 2), (_OWORD *)v8 + 1);
        v8 = (uint64_t *)*v8;
      }
      while (v8);
    }
    v10 = *(double **)(a1 + 16);
    v11 = *(double **)a1;
    v12 = **(double **)a1 - *(double *)(v7 + 144);
    if (*v10 >= v12)
      v12 = *v10;
    *v10 = v12;
    v13 = *(double **)(a1 + 24);
    v14 = *v11 - *(double *)(v7 + 144);
    if (v14 >= *v13)
      v14 = *v13;
    *v13 = v14;
    v15 = *(double **)(a1 + 32);
    LODWORD(v67) = 1;
    v16 = std::__hash_table<std::__hash_value_type<unsigned int,unsigned int>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,unsigned int>>>::find<unsigned int>((_QWORD *)(v7 + 104), (unsigned int *)&v67);
    v17 = 0.0;
    v18 = 0.0;
    if (v16)
      v18 = *((double *)v16 + 4) - *((double *)v16 + 3);
    if (*v15 >= v18)
      v18 = *v15;
    **(double **)(a1 + 32) = v18;
    v19 = *(double **)(a1 + 40);
    LODWORD(v67) = 1;
    v20 = std::__hash_table<std::__hash_value_type<unsigned int,unsigned int>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,unsigned int>>>::find<unsigned int>((_QWORD *)(v7 + 104), (unsigned int *)&v67);
    if (v20)
      v17 = *((double *)v20 + 4) - *((double *)v20 + 3);
    v21 = *v19;
    if (v17 < *v19)
      v21 = v17;
    **(double **)(a1 + 40) = v21;
    LODWORD(v67) = 1;
    v22 = std::__hash_table<std::__hash_value_type<unsigned int,unsigned int>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,unsigned int>>>::find<unsigned int>((_QWORD *)(v7 + 104), (unsigned int *)&v67);
    if (v22)
      v23 = *((double *)v22 + 4) - *((double *)v22 + 3);
    else
      v23 = 0.0;
    **(double **)(a1 + 48) = v23 + **(double **)(a1 + 48);
    v24 = *(unint64_t **)(a1 + 80);
    v25 = *(_QWORD *)(v7 + 24);
    if (*v24 > v25)
      v25 = *v24;
    *v24 = v25;
    v26 = *(unint64_t **)(a1 + 88);
    v27 = *(_QWORD *)(v7 + 24);
    if (v27 >= *v26)
      v27 = *v26;
    *v26 = v27;
    **(_QWORD **)(a1 + 96) += *(_QWORD *)(v7 + 24);
    for (i = *(int **)(v7 + 80); i; i = *(int **)i)
    {
      v29 = i + 4;
      v30 = *(_QWORD *)(a1 + 56);
      v31 = *(_QWORD *)(v30 + 8);
      if (!v31)
        goto LABEL_35;
      v32 = *v29;
      v33 = v30 + 8;
      do
      {
        v34 = *(_DWORD *)(v31 + 32);
        v35 = v34 < v32;
        if (v34 >= v32)
          v36 = (uint64_t *)v31;
        else
          v36 = (uint64_t *)(v31 + 8);
        if (!v35)
          v33 = v31;
        v31 = *v36;
      }
      while (*v36);
      if (v33 == v30 + 8 || v32 < *(_DWORD *)(v33 + 32))
      {
LABEL_35:
        v67 = i + 4;
        std::__tree<std::__value_type<CLMicroLocationProto::DataType,unsigned long>,std::__map_value_compare<CLMicroLocationProto::DataType,std::__value_type<CLMicroLocationProto::DataType,unsigned long>,std::less<CLMicroLocationProto::DataType>,true>,std::allocator<std::__value_type<CLMicroLocationProto::DataType,unsigned long>>>::__emplace_unique_key_args<CLMicroLocationProto::DataType,std::piecewise_construct_t const&,std::tuple<CLMicroLocationProto::DataType const&>,std::tuple<>>((uint64_t **)v30, i + 4, (uint64_t)&std::piecewise_construct, &v67)[5] = 0;
        v30 = *(_QWORD *)(a1 + 56);
      }
      v67 = i + 4;
      v37 = std::__tree<std::__value_type<CLMicroLocationProto::DataType,unsigned long>,std::__map_value_compare<CLMicroLocationProto::DataType,std::__value_type<CLMicroLocationProto::DataType,unsigned long>,std::less<CLMicroLocationProto::DataType>,true>,std::allocator<std::__value_type<CLMicroLocationProto::DataType,unsigned long>>>::__emplace_unique_key_args<CLMicroLocationProto::DataType,std::piecewise_construct_t const&,std::tuple<CLMicroLocationProto::DataType const&>,std::tuple<>>((uint64_t **)v30, i + 4, (uint64_t)&std::piecewise_construct, &v67);
      v38 = *(uint64_t **)(v7 + 16);
      if (v38)
      {
        v39 = 0;
        do
        {
          if (*((_DWORD *)v38 + 6) == *v29)
            v39 = (uint64_t *)((char *)v39 + 1);
          v38 = (uint64_t *)*v38;
        }
        while (v38);
      }
      else
      {
        v39 = 0;
      }
      if (v37[5] <= v39)
        v40 = v39;
      else
        v40 = v37[5];
      v41 = *(uint64_t ***)(a1 + 56);
      v67 = i + 4;
      std::__tree<std::__value_type<CLMicroLocationProto::DataType,unsigned long>,std::__map_value_compare<CLMicroLocationProto::DataType,std::__value_type<CLMicroLocationProto::DataType,unsigned long>,std::less<CLMicroLocationProto::DataType>,true>,std::allocator<std::__value_type<CLMicroLocationProto::DataType,unsigned long>>>::__emplace_unique_key_args<CLMicroLocationProto::DataType,std::piecewise_construct_t const&,std::tuple<CLMicroLocationProto::DataType const&>,std::tuple<>>(v41, i + 4, (uint64_t)&std::piecewise_construct, &v67)[5] = v40;
      v42 = *(_QWORD *)(a1 + 64);
      v43 = *(_QWORD *)(v42 + 8);
      if (!v43)
        goto LABEL_56;
      v44 = *v29;
      v45 = v42 + 8;
      do
      {
        v46 = *(_DWORD *)(v43 + 32);
        v47 = v46 < v44;
        if (v46 >= v44)
          v48 = (uint64_t *)v43;
        else
          v48 = (uint64_t *)(v43 + 8);
        if (!v47)
          v45 = v43;
        v43 = *v48;
      }
      while (*v48);
      if (v45 == v42 + 8 || v44 < *(_DWORD *)(v45 + 32))
LABEL_56:
        v45 = v42 + 8;
      if (v45 == *(_QWORD *)(a1 + 56) + 8)
      {
        v67 = i + 4;
        std::__tree<std::__value_type<CLMicroLocationProto::DataType,unsigned long>,std::__map_value_compare<CLMicroLocationProto::DataType,std::__value_type<CLMicroLocationProto::DataType,unsigned long>,std::less<CLMicroLocationProto::DataType>,true>,std::allocator<std::__value_type<CLMicroLocationProto::DataType,unsigned long>>>::__emplace_unique_key_args<CLMicroLocationProto::DataType,std::piecewise_construct_t const&,std::tuple<CLMicroLocationProto::DataType const&>,std::tuple<>>((uint64_t **)v42, i + 4, (uint64_t)&std::piecewise_construct, &v67)[5] = (uint64_t *)-1;
        v42 = *(_QWORD *)(a1 + 64);
      }
      v67 = i + 4;
      v49 = std::__tree<std::__value_type<CLMicroLocationProto::DataType,unsigned long>,std::__map_value_compare<CLMicroLocationProto::DataType,std::__value_type<CLMicroLocationProto::DataType,unsigned long>,std::less<CLMicroLocationProto::DataType>,true>,std::allocator<std::__value_type<CLMicroLocationProto::DataType,unsigned long>>>::__emplace_unique_key_args<CLMicroLocationProto::DataType,std::piecewise_construct_t const&,std::tuple<CLMicroLocationProto::DataType const&>,std::tuple<>>((uint64_t **)v42, i + 4, (uint64_t)&std::piecewise_construct, &v67);
      v50 = *(uint64_t **)(v7 + 16);
      if (v50)
      {
        v51 = 0;
        do
        {
          if (*((_DWORD *)v50 + 6) == *v29)
            v51 = (uint64_t *)((char *)v51 + 1);
          v50 = (uint64_t *)*v50;
        }
        while (v50);
      }
      else
      {
        v51 = 0;
      }
      if (v51 >= v49[5])
        v52 = v49[5];
      else
        v52 = v51;
      v53 = *(uint64_t ***)(a1 + 64);
      v67 = i + 4;
      std::__tree<std::__value_type<CLMicroLocationProto::DataType,unsigned long>,std::__map_value_compare<CLMicroLocationProto::DataType,std::__value_type<CLMicroLocationProto::DataType,unsigned long>,std::less<CLMicroLocationProto::DataType>,true>,std::allocator<std::__value_type<CLMicroLocationProto::DataType,unsigned long>>>::__emplace_unique_key_args<CLMicroLocationProto::DataType,std::piecewise_construct_t const&,std::tuple<CLMicroLocationProto::DataType const&>,std::tuple<>>(v53, i + 4, (uint64_t)&std::piecewise_construct, &v67)[5] = v52;
      v54 = *(_QWORD *)(a1 + 72);
      v55 = *(_QWORD *)(v54 + 8);
      if (!v55)
        goto LABEL_79;
      v56 = *v29;
      v57 = v54 + 8;
      do
      {
        v58 = *(_DWORD *)(v55 + 32);
        v59 = v58 < v56;
        if (v58 >= v56)
          v60 = (uint64_t *)v55;
        else
          v60 = (uint64_t *)(v55 + 8);
        if (!v59)
          v57 = v55;
        v55 = *v60;
      }
      while (*v60);
      if (v57 == v54 + 8 || v56 < *(_DWORD *)(v57 + 32))
      {
LABEL_79:
        v67 = i + 4;
        std::__tree<std::__value_type<CLMicroLocationProto::DataType,unsigned long>,std::__map_value_compare<CLMicroLocationProto::DataType,std::__value_type<CLMicroLocationProto::DataType,unsigned long>,std::less<CLMicroLocationProto::DataType>,true>,std::allocator<std::__value_type<CLMicroLocationProto::DataType,unsigned long>>>::__emplace_unique_key_args<CLMicroLocationProto::DataType,std::piecewise_construct_t const&,std::tuple<CLMicroLocationProto::DataType const&>,std::tuple<>>((uint64_t **)v54, i + 4, (uint64_t)&std::piecewise_construct, &v67)[5] = 0;
        v56 = *v29;
      }
      v61 = *(uint64_t **)(v7 + 16);
      if (v61)
      {
        v62 = 0;
        do
        {
          if (*((_DWORD *)v61 + 6) == v56)
            ++v62;
          v61 = (uint64_t *)*v61;
        }
        while (v61);
      }
      else
      {
        v62 = 0;
      }
      v63 = *(uint64_t ***)(a1 + 72);
      v67 = i + 4;
      v64 = std::__tree<std::__value_type<CLMicroLocationProto::DataType,unsigned long>,std::__map_value_compare<CLMicroLocationProto::DataType,std::__value_type<CLMicroLocationProto::DataType,unsigned long>,std::less<CLMicroLocationProto::DataType>,true>,std::allocator<std::__value_type<CLMicroLocationProto::DataType,unsigned long>>>::__emplace_unique_key_args<CLMicroLocationProto::DataType,std::piecewise_construct_t const&,std::tuple<CLMicroLocationProto::DataType const&>,std::tuple<>>(v63, i + 4, (uint64_t)&std::piecewise_construct, &v67);
      v64[5] = (uint64_t *)((char *)v64[5] + v62);
    }
    CLMicroLocationFingerprintVector::Iterator::operator++((uint64_t)v66);
  }
  return result;
}

void CLMicroLocationCoreAnalyticsPublishHelper::updateClusterRfDistanceCharacteristics(CLMicroLocationCoreAnalyticsPublishHelper *this, NSMutableDictionary *a2, const CLMicroLocationModel *a3)
{
  CLMicroLocationCoreAnalyticsPublishHelper *v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  char v9;
  char v10;
  uint64_t v11;
  _QWORD *v12;
  double v13;
  void *v14;
  void *v15;
  double v16;
  void *v17;
  void *v18;
  double v19;
  void *v20;
  void *v21;
  NSObject *v22;
  uint64_t v23;
  double v24;
  void *v25;
  void *v26;
  double v27;
  void *v28;
  void *v29;
  double v30;
  void *v31;
  void *v32;
  NSObject *v33;
  uint64_t v34;
  uint64_t i;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint8_t buf[4];
  uint64_t v40;
  __int16 v41;
  double v42;
  __int16 v43;
  double v44;
  __int16 v45;
  double v46;
  _QWORD v47[2];
  char v48;
  const __CFString *v49;
  uint64_t EnabledTechnologies;
  char v51;
  const __CFString *v52;
  uint64_t v53;
  char v54;
  const __CFString *v55;
  uint64_t v56;
  char v57;
  uint64_t v58;

  v58 = *MEMORY[0x24BDAC8D0];
  v4 = this;
  +[ULDefaultsSingleton shared](ULDefaultsSingleton, "shared");
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v5, "defaultsDictionary");
  v6 = (void *)objc_claimAutoreleasedReturnValue();

  objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "ULAdaptiveSensorsEnable");
  v7 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v6, "objectForKey:", v7);
  v8 = (void *)objc_claimAutoreleasedReturnValue();
  if (v8 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
    v9 = objc_msgSend(v8, "BOOLValue");
  else
    v9 = objc_msgSend(MEMORY[0x24BDBD1C8], "BOOLValue");
  v10 = v9;

  v47[0] = &stru_2511DC120;
  v47[1] = CLMicroLocationUtils::createEnabledTechnologies((CLMicroLocationUtils *)1, 1, 1);
  v48 = v10;
  v49 = CFSTR("Wifi");
  EnabledTechnologies = CLMicroLocationUtils::createEnabledTechnologies((CLMicroLocationUtils *)1, 0, 0);
  v51 = v10;
  v52 = CFSTR("Ble");
  v53 = CLMicroLocationUtils::createEnabledTechnologies(0, 1, 0);
  v54 = v10;
  v55 = CFSTR("Uwb");
  v11 = 0;
  v56 = CLMicroLocationUtils::createEnabledTechnologies(0, 0, 1);
  v57 = v10;
  do
  {
    v12 = &v47[v11];
    v36 = 0;
    v37 = 0;
    v38 = 0;
    CLMicroLocationClusterRFDistance::evaluateRFClusterDistances((uint64_t)a2, (float *)&v36);
    LODWORD(v13) = v36;
    objc_msgSend(MEMORY[0x24BDD16E0], "numberWithFloat:", v13);
    v14 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(MEMORY[0x24BDD17C8], "stringWithFormat:", CFSTR("%@%@"), CFSTR("minClusterRfSize"), v47[v11]);
    v15 = (void *)objc_claimAutoreleasedReturnValue();
    -[CLMicroLocationCoreAnalyticsPublishHelper setObject:forKeyedSubscript:](v4, "setObject:forKeyedSubscript:", v14, v15);

    LODWORD(v16) = HIDWORD(v36);
    objc_msgSend(MEMORY[0x24BDD16E0], "numberWithFloat:", v16);
    v17 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(MEMORY[0x24BDD17C8], "stringWithFormat:", CFSTR("%@%@"), CFSTR("maxClusterRfSize"), v47[v11]);
    v18 = (void *)objc_claimAutoreleasedReturnValue();
    -[CLMicroLocationCoreAnalyticsPublishHelper setObject:forKeyedSubscript:](v4, "setObject:forKeyedSubscript:", v17, v18);

    LODWORD(v19) = v37;
    objc_msgSend(MEMORY[0x24BDD16E0], "numberWithFloat:", v19);
    v20 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(MEMORY[0x24BDD17C8], "stringWithFormat:", CFSTR("%@%@"), CFSTR("avgClusterRfSize"), v47[v11]);
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    -[CLMicroLocationCoreAnalyticsPublishHelper setObject:forKeyedSubscript:](v4, "setObject:forKeyedSubscript:", v20, v21);

    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_40);
    v22 = logObject_MicroLocation_Default;
    if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEBUG))
    {
      v23 = *v12;
      *(_DWORD *)buf = 138413058;
      v40 = v23;
      v41 = 2048;
      v42 = *(float *)&v36;
      v43 = 2048;
      v44 = *((float *)&v36 + 1);
      v45 = 2048;
      v46 = *(float *)&v37;
      _os_log_impl(&dword_2419D9000, v22, OS_LOG_TYPE_DEBUG, "Model cluster RF sizes %@: %f (min), %f(max), %f (mean)", buf, 0x2Au);
    }
    if ((unint64_t)CLMicroLocationModel::numClusters((CLMicroLocationModel *)a2) >= 2)
    {
      LODWORD(v24) = HIDWORD(v37);
      objc_msgSend(MEMORY[0x24BDD16E0], "numberWithFloat:", v24);
      v25 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(MEMORY[0x24BDD17C8], "stringWithFormat:", CFSTR("%@%@"), CFSTR("minClusterRfDistance"), *v12);
      v26 = (void *)objc_claimAutoreleasedReturnValue();
      -[CLMicroLocationCoreAnalyticsPublishHelper setObject:forKeyedSubscript:](v4, "setObject:forKeyedSubscript:", v25, v26);

      LODWORD(v27) = v38;
      objc_msgSend(MEMORY[0x24BDD16E0], "numberWithFloat:", v27);
      v28 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(MEMORY[0x24BDD17C8], "stringWithFormat:", CFSTR("%@%@"), CFSTR("maxClusterRfDistance"), *v12);
      v29 = (void *)objc_claimAutoreleasedReturnValue();
      -[CLMicroLocationCoreAnalyticsPublishHelper setObject:forKeyedSubscript:](v4, "setObject:forKeyedSubscript:", v28, v29);

      LODWORD(v30) = HIDWORD(v38);
      objc_msgSend(MEMORY[0x24BDD16E0], "numberWithFloat:", v30);
      v31 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(MEMORY[0x24BDD17C8], "stringWithFormat:", CFSTR("%@%@"), CFSTR("avgClusterRfDistance"), *v12);
      v32 = (void *)objc_claimAutoreleasedReturnValue();
      -[CLMicroLocationCoreAnalyticsPublishHelper setObject:forKeyedSubscript:](v4, "setObject:forKeyedSubscript:", v31, v32);

      if (onceToken_MicroLocation_Default != -1)
        dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_40);
      v33 = logObject_MicroLocation_Default;
      if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEBUG))
      {
        v34 = *v12;
        *(_DWORD *)buf = 138413058;
        v40 = v34;
        v41 = 2048;
        v42 = *((float *)&v37 + 1);
        v43 = 2048;
        v44 = *(float *)&v38;
        v45 = 2048;
        v46 = *((float *)&v38 + 1);
        _os_log_impl(&dword_2419D9000, v33, OS_LOG_TYPE_DEBUG, "Model cluster RF distances %@: %f (min), %f(max), %f (mean)", buf, 0x2Au);
      }
    }
    v11 += 3;
  }
  while (v11 != 12);
  for (i = 9; i != -3; i -= 3)

}

void sub_241A4CD8C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void CLMicroLocationCoreAnalyticsPublishHelper::updateLearnEventSummary(void *a1, CLMicroLocationModel *a2, const CLMicroLocationModel *a3, double a4)
{
  id v7;
  void *v8;
  uint64_t v9;
  uint64_t v10;
  void *v11;
  void *v12;
  uint64_t v13;
  uint64_t v14;
  void *v15;
  void *v16;
  const CLMicroLocationProto::Model *v17;
  const CLMicroLocationModel *v18;
  void *v19;
  _QWORD *v20;
  unint64_t *v21;
  uint64_t v22;
  unint64_t *v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;
  unint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t *v30;
  unint64_t *v31;
  uint64_t v32;
  unint64_t *v33;
  unint64_t v34;
  uint64_t v35;
  void *v36;
  void *v37;
  void *v38;
  void *v39;
  uint64_t v40;
  unint64_t v41;
  unint64_t *v42;
  _QWORD *v43;
  unint64_t v44;
  uint64_t v45;
  void *v46;
  void *v47;
  void *v48;
  void *v49;
  void **v50;
  void *v51;
  const CLMicroLocationModel *v52;
  void *v53[2];
  char v54;
  void *__p;
  unint64_t *v56;
  unint64_t v57;

  v7 = a1;
  v8 = v7;
  if (v7)
  {
    v9 = MEMORY[0x24BDBD1C0];
    objc_msgSend(v7, "setObject:forKeyedSubscript:", MEMORY[0x24BDBD1C0], CFSTR("cancelled"));
    if (CLMicroLocationModel::isValid(a2))
      v10 = MEMORY[0x24BDBD1C8];
    else
      v10 = v9;
    objc_msgSend(v8, "setObject:forKeyedSubscript:", v10, CFSTR("valid"));
    objc_msgSend(MEMORY[0x24BDD16E0], "numberWithDouble:", cl::chrono::CFAbsoluteTimeClock::now() - a4);
    v11 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v8, "setObject:forKeyedSubscript:", v11, CFSTR("runTime"));

    objc_msgSend(v8, "objectForKeyedSubscript:", CFSTR("learnCounter"));
    v12 = (void *)objc_claimAutoreleasedReturnValue();
    v13 = objc_msgSend(v12, "integerValue");

    if (v13)
    {
      if (v13 >= 100)
        v14 = 100;
      else
        v14 = v13;
      objc_msgSend(MEMORY[0x24BDD16E0], "numberWithInteger:", v14);
      v15 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v8, "setObject:forKeyedSubscript:", v15, CFSTR("learnCounter"));

    }
    if (CLMicroLocationModel::isValid(a2))
    {
      objc_msgSend(MEMORY[0x24BDD16E0], "numberWithUnsignedLong:", CLMicroLocationModel::numClusters(a2));
      v16 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v8, "setObject:forKeyedSubscript:", v16, CFSTR("numClusters"));

      CLMicroLocationCoreAnalyticsPublishHelper::updateModelSizeMetrics((CLMicroLocationCoreAnalyticsPublishHelper *)v8, (NSMutableDictionary *)a2, a3, v17);
      CLMicroLocationCoreAnalyticsPublishHelper::updateClusterRfDistanceCharacteristics((CLMicroLocationCoreAnalyticsPublishHelper *)v8, (NSMutableDictionary *)a2, v18);
      objc_msgSend(MEMORY[0x24BDD16E0], "numberWithDouble:", CLMicroLocationModel::representativeFPsRatio(a2));
      v19 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v8, "setObject:forKeyedSubscript:", v19, CFSTR("representativeFPsRatio"));

      __p = 0;
      v56 = 0;
      v57 = 0;
      v20 = (_QWORD *)*((_QWORD *)a2 + 46);
      if (v20)
      {
        v21 = 0;
        do
        {
          v22 = (uint64_t)(v20[5] - v20[4]) >> 4;
          if ((unint64_t)v21 >= v57)
          {
            v23 = (unint64_t *)__p;
            v24 = ((char *)v21 - (_BYTE *)__p) >> 3;
            v25 = v24 + 1;
            if ((unint64_t)(v24 + 1) >> 61)
              std::vector<CLMicroLocationProto::ConfidenceReason>::__throw_length_error[abi:ne180100]();
            v26 = v57 - (_QWORD)__p;
            if ((uint64_t)(v57 - (_QWORD)__p) >> 2 > v25)
              v25 = v26 >> 2;
            if ((unint64_t)v26 >= 0x7FFFFFFFFFFFFFF8)
              v27 = 0x1FFFFFFFFFFFFFFFLL;
            else
              v27 = v25;
            if (v27)
            {
              v27 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<CLMicroLocationWiFiChannelHistogram>>((uint64_t)&v57, v27);
              v29 = v28;
              v23 = (unint64_t *)__p;
              v21 = v56;
            }
            else
            {
              v29 = 0;
            }
            v30 = (uint64_t *)(v27 + 8 * v24);
            *v30 = v22;
            v31 = (unint64_t *)(v30 + 1);
            while (v21 != v23)
            {
              v32 = *--v21;
              *--v30 = v32;
            }
            __p = v30;
            v56 = v31;
            v57 = v27 + 8 * v29;
            if (v23)
              operator delete(v23);
            v21 = v31;
          }
          else
          {
            *v21++ = v22;
          }
          v56 = v21;
          v20 = (_QWORD *)*v20;
        }
        while (v20);
        v33 = (unint64_t *)__p;
      }
      else
      {
        v21 = 0;
        v33 = 0;
      }
      v34 = 126 - 2 * __clz(v21 - v33);
      if (v21 == v33)
        v35 = 0;
      else
        v35 = v34;
      std::__introsort<std::_ClassicAlgPolicy,std::greater<unsigned long> &,unsigned long *,false>(v33, v21, (uint64_t)v53, v35, 1);
      +[ULDefaultsSingleton shared](ULDefaultsSingleton, "shared");
      v36 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v36, "defaultsDictionary");
      v37 = (void *)objc_claimAutoreleasedReturnValue();

      objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "ULMaximumNumberOfClustersForLearningAnalytics");
      v38 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v37, "objectForKey:", v38);
      v39 = (void *)objc_claimAutoreleasedReturnValue();
      if (v39 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
        v40 = objc_msgSend(v39, "unsignedLongValue");
      else
        v40 = objc_msgSend(&unk_2511ED7F8, "unsignedLongValue");
      v41 = v40;

      v43 = __p;
      v42 = v56;
      if (v56 != __p)
      {
        v44 = 0;
        v45 = 0;
        do
        {
          if (v44 >= v41)
          {
            v45 += v43[v44];
          }
          else
          {
            objc_msgSend(MEMORY[0x24BDD16E0], "numberWithUnsignedLong:", v43[v44]);
            v46 = (void *)objc_claimAutoreleasedReturnValue();
            objc_msgSend(MEMORY[0x24BDD17C8], "stringWithFormat:", CFSTR("numFingerprintsInCluster%zu"), v44);
            v47 = (void *)objc_claimAutoreleasedReturnValue();
            objc_msgSend(v8, "setObject:forKeyedSubscript:", v46, v47);

            v43 = __p;
            v42 = v56;
          }
          ++v44;
        }
        while (v44 < v42 - v43);
        if (v45)
        {
          objc_msgSend(MEMORY[0x24BDD16E0], "numberWithUnsignedLong:", v45);
          v48 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(v8, "setObject:forKeyedSubscript:", v48, CFSTR("numFingerprintsInRemainingClusters"));

          v42 = v56;
        }
      }
      objc_msgSend(MEMORY[0x24BDD16E0], "numberWithUnsignedLong:", *(v42 - 1));
      v49 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v8, "setObject:forKeyedSubscript:", v49, CFSTR("numFingerprintsInSmallestCluster"));

      CLMicroLocationCoreAnalyticsPublishHelper::generationAlgorithmToString(*(_DWORD *)a2, v53);
      if (v54 >= 0)
        v50 = v53;
      else
        v50 = (void **)v53[0];
      objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", v50);
      v51 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v8, "setObject:forKeyedSubscript:", v51, CFSTR("generationAlgorithm"));

      CLMicroLocationCoreAnalyticsPublishHelper::updateModelQualityMetrics((CLMicroLocationCoreAnalyticsPublishHelper *)v8, (NSMutableDictionary *)a2, v52);
      if (v54 < 0)
        operator delete(v53[0]);
      if (__p)
      {
        v56 = (unint64_t *)__p;
        operator delete(__p);
      }
    }
  }

}

void sub_241A4D3B4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, void *__p, uint64_t a18)
{
  void *v18;
  void *v19;
  void *v20;
  void *v21;

  if (__p)
    operator delete(__p);

  _Unwind_Resume(a1);
}

void CLMicroLocationCoreAnalyticsPublishHelper::updateModelSizeMetrics(CLMicroLocationCoreAnalyticsPublishHelper *this, NSMutableDictionary *a2, const CLMicroLocationModel *a3, const CLMicroLocationProto::Model *a4)
{
  Class v6;
  Class isa;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  void *v17;
  void *v18;
  void *v19;
  void *v20;
  void *v21;
  void *v22;
  CLMicroLocationCoreAnalyticsPublishHelper *v23;

  v23 = this;
  if (v23)
  {
    isa = a2[41].super.super.isa;
    v6 = a2[42].super.super.isa;
    v8 = (v6 - isa) >> 5;
    if (v6 == isa)
    {
      v12 = 0;
      v11 = 0;
      v10 = 0;
      v9 = 0;
    }
    else
    {
      v9 = 0;
      v10 = 0;
      v11 = 0;
      v12 = 0;
      do
      {
        v13 = *(uint64_t **)(*(_QWORD *)isa + 16);
        if (v13)
        {
          v14 = 0;
          v15 = *(_QWORD *)(*(_QWORD *)isa + 16);
          do
          {
            if (*(_DWORD *)(v15 + 24) == 1)
              ++v14;
            v15 = *(_QWORD *)v15;
          }
          while (v15);
          v16 = *(_QWORD *)(*(_QWORD *)isa + 16);
          do
          {
            if (*(_DWORD *)(v16 + 24) == 5)
              ++v15;
            v16 = *(_QWORD *)v16;
          }
          while (v16);
          do
          {
            if (*((_DWORD *)v13 + 6) == 6)
              ++v16;
            v13 = (uint64_t *)*v13;
          }
          while (v13);
          v12 += v14;
        }
        else
        {
          v15 = 0;
          v16 = 0;
        }
        v9 += *(_QWORD *)(*(_QWORD *)isa + 24);
        v11 += v15;
        v10 += v16;
        isa = (Class)((char *)isa + 32);
      }
      while (isa != v6);
    }
    objc_msgSend(MEMORY[0x24BDD16E0], "numberWithUnsignedLong:", v8);
    v17 = (void *)objc_claimAutoreleasedReturnValue();
    -[CLMicroLocationCoreAnalyticsPublishHelper setObject:forKeyedSubscript:](v23, "setObject:forKeyedSubscript:", v17, CFSTR("modelSizeNumFingerprints"));

    objc_msgSend(MEMORY[0x24BDD16E0], "numberWithUnsignedLong:", v9);
    v18 = (void *)objc_claimAutoreleasedReturnValue();
    -[CLMicroLocationCoreAnalyticsPublishHelper setObject:forKeyedSubscript:](v23, "setObject:forKeyedSubscript:", v18, CFSTR("modelSizeNumMeasurements"));

    objc_msgSend(MEMORY[0x24BDD16E0], "numberWithUnsignedLong:", v12);
    v19 = (void *)objc_claimAutoreleasedReturnValue();
    -[CLMicroLocationCoreAnalyticsPublishHelper setObject:forKeyedSubscript:](v23, "setObject:forKeyedSubscript:", v19, CFSTR("modelSizeNumWiFiMeasurements"));

    objc_msgSend(MEMORY[0x24BDD16E0], "numberWithUnsignedLong:", v11);
    v20 = (void *)objc_claimAutoreleasedReturnValue();
    -[CLMicroLocationCoreAnalyticsPublishHelper setObject:forKeyedSubscript:](v23, "setObject:forKeyedSubscript:", v20, CFSTR("modelSizeNumBleMeasurements"));

    objc_msgSend(MEMORY[0x24BDD16E0], "numberWithUnsignedLong:", v10);
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    -[CLMicroLocationCoreAnalyticsPublishHelper setObject:forKeyedSubscript:](v23, "setObject:forKeyedSubscript:", v21, CFSTR("modelSizeNumUwbMeasurements"));

    objc_msgSend(MEMORY[0x24BDD16E0], "numberWithInt:", (*(uint64_t (**)(const CLMicroLocationModel *))(*(_QWORD *)a3 + 72))(a3));
    v22 = (void *)objc_claimAutoreleasedReturnValue();
    -[CLMicroLocationCoreAnalyticsPublishHelper setObject:forKeyedSubscript:](v23, "setObject:forKeyedSubscript:", v22, CFSTR("modelLoadedByteSize"));

  }
}

void sub_241A4D6B8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

void CLMicroLocationCoreAnalyticsPublishHelper::updateModelQualityMetrics(CLMicroLocationCoreAnalyticsPublishHelper *this, NSMutableDictionary *a2, const CLMicroLocationModel *a3)
{
  CLMicroLocationCoreAnalyticsPublishHelper *v4;
  void *v5;
  void *v6;
  void *v7;
  uint64_t CandidateQualityReasons;
  unint64_t v9;
  uint64_t v10;
  int *v11;
  char *v12;
  void **v13;
  void *v14;
  uint64_t v15[3];
  void *v16;
  char *v17;
  uint64_t v18;
  void *__p[2];
  char v20;
  std::vector<std::string> *v21;

  v4 = this;
  objc_msgSend(MEMORY[0x24BDD16E0], "numberWithUnsignedInt:", CLMicroLocationModel::getQualityIndicator((CLMicroLocationModel *)a2));
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  -[CLMicroLocationCoreAnalyticsPublishHelper setObject:forKeyedSubscript:](v4, "setObject:forKeyedSubscript:", v5, CFSTR("modelQuality"));

  objc_msgSend(MEMORY[0x24BDD16E0], "numberWithUnsignedInt:", CLMicroLocationModel::getQualityIndicator((CLMicroLocationModel *)a2));
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  -[CLMicroLocationCoreAnalyticsPublishHelper setObject:forKeyedSubscript:](v4, "setObject:forKeyedSubscript:", v6, CFSTR("modelQualityBounded"));

  objc_msgSend(MEMORY[0x24BDD16E0], "numberWithUnsignedInt:", CLMicroLocationModel::getCandidateQualityIndicator((CLMicroLocationModel *)a2));
  v7 = (void *)objc_claimAutoreleasedReturnValue();
  -[CLMicroLocationCoreAnalyticsPublishHelper setObject:forKeyedSubscript:](v4, "setObject:forKeyedSubscript:", v7, CFSTR("candidateModelQuality"));

  CandidateQualityReasons = CLMicroLocationModel::getCandidateQualityReasons((CLMicroLocationModel *)a2);
  v16 = 0;
  v17 = 0;
  v18 = 0;
  std::vector<CLMicroLocationProto::ServiceQualityReasonEnum>::__init_with_size[abi:ne180100]<CLMicroLocationProto::ServiceQualityReasonEnum*,CLMicroLocationProto::ServiceQualityReasonEnum*>(&v16, *(const void **)CandidateQualityReasons, *(_QWORD *)(CandidateQualityReasons + 8), (uint64_t)(*(_QWORD *)(CandidateQualityReasons + 8) - *(_QWORD *)CandidateQualityReasons) >> 2);
  v9 = 126 - 2 * __clz((v17 - (_BYTE *)v16) >> 2);
  if (v17 == v16)
    v10 = 0;
  else
    v10 = v9;
  std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,CLMicroLocationProto::ServiceQualityReasonEnum *,false>((uint64_t)v16, (int *)v17, (uint64_t)__p, v10, 1);
  memset(v15, 0, sizeof(v15));
  v11 = (int *)v16;
  v12 = v17;
  v21 = (std::vector<std::string> *)v15;
  while (v11 != (int *)v12)
  {
    CLMicroLocationProtobufHelper::serviceQualityReasonToString(*v11, __p);
    std::back_insert_iterator<std::vector<std::string>>::operator=[abi:ne180100](&v21, (__int128 *)__p);
    if (v20 < 0)
      operator delete(__p[0]);
    ++v11;
  }
  boost::algorithm::join<std::vector<std::string>,char [2]>(" ", v15, (uint64_t)__p);
  if (v20 >= 0)
    v13 = __p;
  else
    v13 = (void **)__p[0];
  objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", v13);
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  -[CLMicroLocationCoreAnalyticsPublishHelper setObject:forKeyedSubscript:](v4, "setObject:forKeyedSubscript:", v14, CFSTR("qualityReasons"));

  if (v20 < 0)
    operator delete(__p[0]);
  __p[0] = v15;
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)__p);
  if (v16)
  {
    v17 = (char *)v16;
    operator delete(v16);
  }

}

void sub_241A4D910(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  void *v21;
  void *v22;
  uint64_t v23;

  if (a21 < 0)
    operator delete(__p);
  *(_QWORD *)(v23 - 40) = &a10;
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)(v23 - 40));
  if (a13)
  {
    a14 = (uint64_t)a13;
    operator delete(a13);
  }

  _Unwind_Resume(a1);
}

void CLMicroLocationCoreAnalyticsPublishHelper::updateMagicalMomentOldModelMetrics(void *a1, CLMicroLocationModel *a2, CLMicroLocationModel *a3, uint64_t a4, char a5, double a6)
{
  id v11;
  void *v12;
  void *v13;
  void *v14;
  int v15;
  void *v16;
  _QWORD *v17;
  unint64_t v18;
  void *v19;
  void *v20;
  double v21;
  void *v22;
  _QWORD v23[5];
  _BYTE v24[16];
  _QWORD *v25;

  v11 = a1;
  if (v11)
  {
    if (a5)
    {
      objc_msgSend(MEMORY[0x24BDD16E0], "numberWithDouble:", a6 - *(double *)&a4);
      v12 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v11, "setObject:forKeyedSubscript:", v12, CFSTR("ageOfOldModel"));

    }
    if (CLMicroLocationModel::isValid(a2))
    {
      objc_msgSend(MEMORY[0x24BDD16E0], "numberWithUnsignedLong:", CLMicroLocationModel::numClusters(a3));
      v13 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v11, "setObject:forKeyedSubscript:", v13, CFSTR("numOldClusters"));

      v14 = (void *)MEMORY[0x24BDD16E0];
      v15 = CLMicroLocationModel::numClusters(a2);
      objc_msgSend(v14, "numberWithInt:", v15 - CLMicroLocationModel::numClusters(a3));
      v16 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v11, "setObject:forKeyedSubscript:", v16, CFSTR("numClustersDiff"));

      CLMicroLocationModel::getIdentifiers(a2, (uint64_t)v24);
      CLMicroLocationModel::getIdentifiers(a3, (uint64_t)v23);
      v17 = v25;
      if (v25)
      {
        v18 = 0;
        do
        {
          if (std::__hash_table<std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>>>::find<boost::uuids::uuid>(v23, v17 + 2))
          {
            ++v18;
          }
          v17 = (_QWORD *)*v17;
        }
        while (v17);
      }
      else
      {
        v18 = 0;
      }
      objc_msgSend(MEMORY[0x24BDD16E0], "numberWithUnsignedLong:", v18);
      v19 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v11, "setObject:forKeyedSubscript:", v19, CFSTR("numMatchingClustersInt"));

      if (CLMicroLocationModel::numClusters(a3))
      {
        v20 = (void *)MEMORY[0x24BDD16E0];
        *(float *)&v21 = (float)v18 / (float)(unint64_t)CLMicroLocationModel::numClusters(a3);
        objc_msgSend(v20, "numberWithFloat:", v21);
        v22 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v11, "setObject:forKeyedSubscript:", v22, CFSTR("portionMatchingClusters"));

      }
      else
      {
        objc_msgSend(v11, "setObject:forKeyedSubscript:", &unk_2511ECDC8, CFSTR("portionMatchingClusters"));
      }
      std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>>>::~__hash_table((uint64_t)v23);
      std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>>>::~__hash_table((uint64_t)v24);
    }
  }

}

void sub_241A4DBA0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14)
{
  void *v14;
  void *v15;

  std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>>>::~__hash_table((uint64_t)&a9);
  std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>>>::~__hash_table((uint64_t)&a14);

  _Unwind_Resume(a1);
}

void CLMicroLocationCoreAnalyticsPublishHelper::updateMagicalMomentsNumPrunedFingerprints(void *a1, uint64_t *a2, unsigned int a3)
{
  id v5;
  unint64_t v6;
  NSObject *v7;
  uint64_t v8;
  NSObject *v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  void *v13;
  void *v14;
  double v15;
  uint64_t v16;
  unint64_t v17;
  unint64_t v18;
  void *v19;
  void *v20;
  uint8_t buf[4];
  int v22;
  __int16 v23;
  const char *v24;
  __int16 v25;
  uint64_t v26;
  __int16 v27;
  uint64_t v28;
  uint64_t v29;

  v29 = *MEMORY[0x24BDAC8D0];
  v5 = a1;
  if (v5)
  {
    if (a3)
    {
      v6 = (a2[1] - *a2) >> 3;
      if (v6 >= a3)
      {
        v11 = a3;
        if (v6 > a3)
        {
          v12 = a3 - 1;
          objc_msgSend(MEMORY[0x24BDD16E0], "numberWithUnsignedLong:", *(_QWORD *)(*a2 + 8 * v12) - *(_QWORD *)(*a2 + 8 * a3));
          v13 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(MEMORY[0x24BDD17C8], "stringWithFormat:", CFSTR("numFingerprintsPrunedInIteration%u"), v12);
          v14 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(v5, "setObject:forKeyedSubscript:", v13, v14);

          v16 = *a2;
          v17 = (a2[1] - *a2) >> 3;
          if (v17 > v12)
          {
            v18 = *(_QWORD *)(v16 + 8 * v12);
            if (!v18)
              goto LABEL_17;
            if (v17 > v11)
            {
              *(float *)&v15 = 1.0 - (float)((float)*(unint64_t *)(v16 + 8 * v11) / (float)v18);
              objc_msgSend(MEMORY[0x24BDD16E0], "numberWithFloat:", v15);
              v19 = (void *)objc_claimAutoreleasedReturnValue();
              objc_msgSend(MEMORY[0x24BDD17C8], "stringWithFormat:", CFSTR("portionFingerprintsPrunedInIteration%u"), v12);
              v20 = (void *)objc_claimAutoreleasedReturnValue();
              objc_msgSend(v5, "setObject:forKeyedSubscript:", v19, v20);

              goto LABEL_17;
            }
          }
        }
        std::vector<unsigned long>::__throw_out_of_range[abi:ne180100]();
      }
    }
    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_40);
    v7 = logObject_MicroLocation_Default;
    if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_ERROR))
    {
      v8 = (a2[1] - *a2) >> 3;
      *(_DWORD *)buf = 68289538;
      v22 = 0;
      v23 = 2082;
      v24 = "";
      v25 = 2050;
      v26 = a3;
      v27 = 2050;
      v28 = v8;
      _os_log_impl(&dword_2419D9000, v7, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"updateMagicalMomentsNumPrunedFingerprints called incorrectly\", \"iteration\":%{public}lu, \"numFingerprintsPerIteration size\":%{public}lu}", buf, 0x26u);
    }
    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_40);
    v9 = logObject_MicroLocation_Default;
    if (os_signpost_enabled((os_log_t)logObject_MicroLocation_Default))
    {
      v10 = (a2[1] - *a2) >> 3;
      *(_DWORD *)buf = 68289538;
      v22 = 0;
      v23 = 2082;
      v24 = "";
      v25 = 2050;
      v26 = a3;
      v27 = 2050;
      v28 = v10;
      _os_signpost_emit_with_name_impl(&dword_2419D9000, v9, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "updateMagicalMomentsNumPrunedFingerprints called incorrectly", "{\"msg%{public}.0s\":\"updateMagicalMomentsNumPrunedFingerprints called incorrectly\", \"iteration\":%{public}lu, \"numFingerprintsPerIteration size\":%{public}lu}", buf, 0x26u);
    }
  }
LABEL_17:

}

void sub_241A4DEF0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void CLMicroLocationCoreAnalyticsPublishHelper::updateMagicalMomentsNumPrunedClusters(CLMicroLocationCoreAnalyticsPublishHelper *this, NSMutableDictionary *a2, const CLMicroLocationModel *a3, uint64_t a4)
{
  void *v7;
  void *v8;
  void *v9;
  double v10;
  void *v11;
  void *v12;
  CLMicroLocationCoreAnalyticsPublishHelper *v13;

  v13 = this;
  objc_msgSend(MEMORY[0x24BDD16E0], "numberWithUnsignedLong:", (char *)a3 - CLMicroLocationModel::numClusters((CLMicroLocationModel *)a2));
  v7 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x24BDD17C8], "stringWithFormat:", CFSTR("numClustersPrunedIteration%u"), a4);
  v8 = (void *)objc_claimAutoreleasedReturnValue();
  -[CLMicroLocationCoreAnalyticsPublishHelper setObject:forKeyedSubscript:](v13, "setObject:forKeyedSubscript:", v7, v8);

  if (a3)
  {
    v9 = (void *)MEMORY[0x24BDD16E0];
    *(float *)&v10 = 1.0
                   - (float)((float)(unint64_t)CLMicroLocationModel::numClusters((CLMicroLocationModel *)a2)
                           / (float)(unint64_t)a3);
    objc_msgSend(v9, "numberWithFloat:", v10);
    v11 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(MEMORY[0x24BDD17C8], "stringWithFormat:", CFSTR("portionClustersPrunedIteration%u"), a4);
    v12 = (void *)objc_claimAutoreleasedReturnValue();
    -[CLMicroLocationCoreAnalyticsPublishHelper setObject:forKeyedSubscript:](v13, "setObject:forKeyedSubscript:", v11, v12);

  }
}

void sub_241A4E03C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;
  void *v11;

  _Unwind_Resume(a1);
}

void CLMicroLocationCoreAnalyticsPublishHelper::updateSemiSupervisedLabeledAndUnlabeledFingerprints(CLMicroLocationCoreAnalyticsPublishHelper *this, NSMutableDictionary *a2, const CLMicroLocationFingerprintVector *a3, const CLMicroLocationFingerprintVector *a4)
{
  unint64_t v6;
  unint64_t v7;
  void *v8;
  void *v9;
  unint64_t v10;
  void *v11;
  unint64_t v12;
  uint64_t v13;
  void *v14;
  CLMicroLocationCoreAnalyticsPublishHelper *v15;

  v15 = this;
  if (v15)
  {
    v6 = CLMicroLocationFingerprintVector::size((CLMicroLocationFingerprintVector *)a2);
    v7 = CLMicroLocationFingerprintVector::size(a3);
    objc_msgSend(MEMORY[0x24BDD16E0], "numberWithUnsignedLong:", v6);
    v8 = (void *)objc_claimAutoreleasedReturnValue();
    -[CLMicroLocationCoreAnalyticsPublishHelper setObject:forKeyedSubscript:](v15, "setObject:forKeyedSubscript:", v8, CFSTR("numUnlabeledFingerprints"));

    objc_msgSend(MEMORY[0x24BDD16E0], "numberWithUnsignedLong:", v7);
    v9 = (void *)objc_claimAutoreleasedReturnValue();
    -[CLMicroLocationCoreAnalyticsPublishHelper setObject:forKeyedSubscript:](v15, "setObject:forKeyedSubscript:", v9, CFSTR("numLabeledFingerprints"));

    if (5 * (v6 / 5) >= 0x1F4)
      v10 = 500;
    else
      v10 = 5 * (v6 / 5);
    objc_msgSend(MEMORY[0x24BDD16E0], "numberWithUnsignedLong:", v10);
    v11 = (void *)objc_claimAutoreleasedReturnValue();
    -[CLMicroLocationCoreAnalyticsPublishHelper setObject:forKeyedSubscript:](v15, "setObject:forKeyedSubscript:", v11, CFSTR("numUnlabeledFingerprintsBounded"));
    v12 = 5 * (v7 / 5);

    if (v12 >= 0x1F4)
      v13 = 500;
    else
      v13 = v12;
    objc_msgSend(MEMORY[0x24BDD16E0], "numberWithUnsignedLong:", v13);
    v14 = (void *)objc_claimAutoreleasedReturnValue();
    -[CLMicroLocationCoreAnalyticsPublishHelper setObject:forKeyedSubscript:](v15, "setObject:forKeyedSubscript:", v14, CFSTR("numLabeledFingerprintsBounded"));

  }
}

void sub_241A4E1C4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

void CLMicroLocationCoreAnalyticsPublishHelper::updateModelStabilityMetrics(void *a1, unsigned int *a2, _BYTE *a3)
{
  void *v5;
  void *v6;
  void *v7;
  BOOL v8;
  uint64_t v9;
  void *v10;
  id v11;

  v11 = a1;
  objc_msgSend(MEMORY[0x24BDD16E0], "numberWithUnsignedInt:", a2[3]);
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v11, "setObject:forKeyedSubscript:", v5, CFSTR("DaysWithRecordings"));

  objc_msgSend(MEMORY[0x24BDD16E0], "numberWithBool:", CLMicroLocationModel::getQualityIndicator((CLMicroLocationModel *)a2) == 3);
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v11, "setObject:forKeyedSubscript:", v6, CFSTR("IsHighQualityModel"));

  objc_msgSend(MEMORY[0x24BDD16E0], "numberWithBool:", CLMicroLocationModel::isStable((CLMicroLocationModel *)a2));
  v7 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v11, "setObject:forKeyedSubscript:", v7, CFSTR("WasInHighQualityBefore"));

  if (a3[1])
  {
    if (CLMicroLocationModel::isStable((CLMicroLocationModel *)a2))
    {
      if (a3[1])
        v8 = *a3 == 0;
      else
        v8 = 0;
      v9 = v8;
    }
    else
    {
      v9 = 0;
    }
    objc_msgSend(MEMORY[0x24BDD16E0], "numberWithBool:", v9);
    v10 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v11, "setObject:forKeyedSubscript:", v10, CFSTR("IsBecomingHighQualityModelForTheFirstTime"));
  }
  else
  {
    objc_msgSend(MEMORY[0x24BDD16E0], "numberWithBool:", CLMicroLocationModel::isStable((CLMicroLocationModel *)a2));
    v10 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v11, "setObject:forKeyedSubscript:", v10, CFSTR("IsBecomingHighQualityModelForTheFirstTime"));
  }

}

void sub_241A4E370(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

uint64_t *boost::algorithm::join<std::vector<std::string>,char [2]>@<X0>(char *__s@<X1>, uint64_t *result@<X0>, uint64_t a3@<X8>)
{
  uint64_t v5;
  uint64_t v6;
  int v7;
  char *v8;
  std::string::size_type v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  size_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  char *v18;
  std::string::size_type v19;

  v5 = *result;
  v6 = result[1];
  *(_QWORD *)(a3 + 8) = 0;
  *(_QWORD *)(a3 + 16) = 0;
  *(_QWORD *)a3 = 0;
  if (v5 == v6)
    goto LABEL_10;
  v7 = *(char *)(v5 + 23);
  if (v7 >= 0)
    v8 = (char *)v5;
  else
    v8 = *(char **)v5;
  if (v7 >= 0)
    v9 = *(unsigned __int8 *)(v5 + 23);
  else
    v9 = *(_QWORD *)(v5 + 8);
  for (result = (uint64_t *)std::string::__insert_with_size<std::__wrap_iter<char const*>,std::__wrap_iter<char const*>>((std::string *)a3, a3, v8, &v8[v9], v9);
        ;
        result = (uint64_t *)std::string::__insert_with_size<std::__wrap_iter<char const*>,std::__wrap_iter<char const*>>((std::string *)a3, v16, v18, &v18[v19], v19))
  {
    v5 += 24;
LABEL_10:
    if (v5 == v6)
      break;
    v10 = *(unsigned __int8 *)(a3 + 23);
    if ((v10 & 0x80u) == 0)
      v11 = a3;
    else
      v11 = *(_QWORD *)a3;
    if ((v10 & 0x80u) != 0)
      v10 = *(_QWORD *)(a3 + 8);
    v12 = v11 + v10;
    v13 = strlen(__s);
    std::string::__insert_with_size<char const*,char const*>((std::string *)a3, v12, __s, &__s[v13], v13);
    v14 = *(unsigned __int8 *)(a3 + 23);
    if ((v14 & 0x80u) == 0)
      v15 = a3;
    else
      v15 = *(_QWORD *)a3;
    if ((v14 & 0x80u) != 0)
      v14 = *(_QWORD *)(a3 + 8);
    v16 = v15 + v14;
    v17 = *(char *)(v5 + 23);
    if (v17 >= 0)
      v18 = (char *)v5;
    else
      v18 = *(char **)v5;
    if (v17 >= 0)
      v19 = *(unsigned __int8 *)(v5 + 23);
    else
      v19 = *(_QWORD *)(v5 + 8);
  }
  return result;
}

void sub_241A4E4AC(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 + 23) < 0)
    operator delete(*(void **)v1);
  _Unwind_Resume(a1);
}

void CLMicroLocationCoreAnalyticsPublishHelper::sendCommonTriggerEvent(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, void *a7)
{
  id v7;
  id v8;

  v7 = a7;
  if (ULSettings::get<ULSettings::AnalyticsSendEventEnabled>())
  {
    v8 = v7;
    AnalyticsSendEventLazy();

  }
}

void sub_241A4E598(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *a15)
{
  void *v15;

  _Unwind_Resume(a1);
}

uint64_t ULSettings::get<ULSettings::AnalyticsSendEventEnabled>()
{
  void *v0;
  void *v1;
  void *v2;
  void *v3;
  uint64_t v4;
  uint64_t v5;

  +[ULDefaultsSingleton shared](ULDefaultsSingleton, "shared");
  v0 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v0, "defaultsDictionary");
  v1 = (void *)objc_claimAutoreleasedReturnValue();

  objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "ULAnalyticsSendEventEnabled");
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v1, "objectForKey:", v2);
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  if (v3 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
    v4 = objc_msgSend(v3, "BOOLValue");
  else
    v4 = objc_msgSend(MEMORY[0x24BDBD1C8], "BOOLValue");
  v5 = v4;

  return v5;
}

{
  void *v0;
  void *v1;
  void *v2;
  void *v3;
  uint64_t v4;
  uint64_t v5;

  +[ULDefaultsSingleton shared](ULDefaultsSingleton, "shared");
  v0 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v0, "defaultsDictionary");
  v1 = (void *)objc_claimAutoreleasedReturnValue();

  objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "ULAnalyticsSendEventEnabled");
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v1, "objectForKey:", v2);
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  if (v3 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
    v4 = objc_msgSend(v3, "BOOLValue");
  else
    v4 = objc_msgSend(MEMORY[0x24BDBD1C8], "BOOLValue");
  v5 = v4;

  return v5;
}

{
  void *v0;
  void *v1;
  void *v2;
  void *v3;
  uint64_t v4;
  uint64_t v5;

  +[ULDefaultsSingleton shared](ULDefaultsSingleton, "shared");
  v0 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v0, "defaultsDictionary");
  v1 = (void *)objc_claimAutoreleasedReturnValue();

  objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "ULAnalyticsSendEventEnabled");
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v1, "objectForKey:", v2);
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  if (v3 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
    v4 = objc_msgSend(v3, "BOOLValue");
  else
    v4 = objc_msgSend(MEMORY[0x24BDBD1C8], "BOOLValue");
  v5 = v4;

  return v5;
}

{
  void *v0;
  void *v1;
  void *v2;
  void *v3;
  uint64_t v4;
  uint64_t v5;

  +[ULDefaultsSingleton shared](ULDefaultsSingleton, "shared");
  v0 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v0, "defaultsDictionary");
  v1 = (void *)objc_claimAutoreleasedReturnValue();

  objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "ULAnalyticsSendEventEnabled");
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v1, "objectForKey:", v2);
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  if (v3 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
    v4 = objc_msgSend(v3, "BOOLValue");
  else
    v4 = objc_msgSend(MEMORY[0x24BDBD1C8], "BOOLValue");
  v5 = v4;

  return v5;
}

void sub_241A4E680(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

id ___ZN41CLMicroLocationCoreAnalyticsPublishHelper22sendCommonTriggerEventERKN20CLMicroLocationProto14RecordingEventERKNSt3__112basic_stringIcNS4_11char_traitsIcEENS4_9allocatorIcEEEESC_SC_bbP19NSMutableDictionary_block_invoke(uint64_t a1)
{
  void *v2;
  const CLMicroLocationProto::RecordingEvent *v3;
  void *v4;
  void *v5;
  const void **v6;
  size_t v7;
  _BYTE *v8;
  const void *v9;
  _BYTE *v10;
  void *v11;
  void *v12;
  const void **v13;
  size_t v14;
  _BYTE *v15;
  const void *v16;
  _BYTE *v17;
  void *v18;
  void *v19;
  _BYTE *v20;
  void *v21;
  uint64_t *v22;
  void *v23;
  const char *v24;
  void *v25;
  void *v26;
  id v27;
  uint64_t v28;
  __int128 v29;
  uint64_t v30;
  uint64_t v31;
  void *v32;
  void *v33;
  void *v34;
  _BOOL4 v35;
  NSObject *v36;
  uint64_t v37;
  NSObject *v38;
  uint64_t v39;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  _BYTE __p[18];
  __int16 v47;
  uint64_t v48;
  __int16 v49;
  void *v50;
  _BYTE v51[128];
  uint64_t v52;

  v52 = *MEMORY[0x24BDAC8D0];
  objc_msgSend(MEMORY[0x24BDBCED8], "dictionary");
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  CLMicroLocationProtobufHelper::getRecordingTriggerString(*(CLMicroLocationProtobufHelper **)(a1 + 56), v3);
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  v5 = (void *)MEMORY[0x24BDD17C8];
  v6 = *(const void ***)(a1 + 48);
  if (*((char *)v6 + 23) >= 0)
    v7 = *((unsigned __int8 *)v6 + 23);
  else
    v7 = (size_t)v6[1];
  v8 = __p;
  std::string::basic_string[abi:ne180100]((uint64_t)__p, v7 + 12);
  if ((v48 & 0x80000000) != 0)
    v8 = *(_BYTE **)__p;
  if (v7)
  {
    if (*((char *)v6 + 23) >= 0)
      v9 = v6;
    else
      v9 = *v6;
    memmove(v8, v9, v7);
  }
  strcpy(&v8[v7], "TriggerEvent");
  if ((v48 & 0x80000000) == 0)
    v10 = __p;
  else
    v10 = *(_BYTE **)__p;
  objc_msgSend(v5, "stringWithUTF8String:", v10);
  v11 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v2, "setObject:forKeyedSubscript:", v4, v11);

  if (SBYTE3(v48) < 0)
    operator delete(*(void **)__p);

  v12 = (void *)MEMORY[0x24BDD17C8];
  v13 = *(const void ***)(a1 + 48);
  if (*((char *)v13 + 23) >= 0)
    v14 = *((unsigned __int8 *)v13 + 23);
  else
    v14 = (size_t)v13[1];
  v15 = __p;
  std::string::basic_string[abi:ne180100]((uint64_t)__p, v14 + 17);
  if ((v48 & 0x80000000) != 0)
    v15 = *(_BYTE **)__p;
  if (v14)
  {
    if (*((char *)v13 + 23) >= 0)
      v16 = v13;
    else
      v16 = *v13;
    memmove(v15, v16, v14);
  }
  strcpy(&v15[v14], "TriggerEventCount");
  if ((v48 & 0x80000000) == 0)
    v17 = __p;
  else
    v17 = *(_BYTE **)__p;
  objc_msgSend(v12, "stringWithUTF8String:", v17);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v2, "setObject:forKeyedSubscript:", &unk_2511ED7E0, v18);

  if (SBYTE3(v48) < 0)
    operator delete(*(void **)__p);
  v19 = (void *)MEMORY[0x24BDD17C8];
  CLMicroLocationClientUtils::getClientIdFromClientIdAndServiceUuid(*(const std::string **)(a1 + 64), (std::string *)__p);
  if ((v48 & 0x80000000) == 0)
    v20 = __p;
  else
    v20 = *(_BYTE **)__p;
  objc_msgSend(v19, "stringWithUTF8String:", v20);
  v21 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v2, "setObject:forKeyedSubscript:", v21, CFSTR("clientId"));

  if (SBYTE3(v48) < 0)
    operator delete(*(void **)__p);
  v22 = *(uint64_t **)(a1 + 72);
  if (*((char *)v22 + 23) < 0)
    v22 = (uint64_t *)*v22;
  objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", v22);
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v2, "setObject:forKeyedSubscript:", v23, CFSTR("requestStatus"));

  if (*(_BYTE *)(a1 + 80))
    v24 = "On";
  else
    v24 = "Off";
  objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", v24);
  v25 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v2, "setObject:forKeyedSubscript:", v25, CFSTR("displayState"));

  objc_msgSend(MEMORY[0x24BDD16E0], "numberWithBool:", *(unsigned __int8 *)(a1 + 81));
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v2, "setObject:forKeyedSubscript:", v26, CFSTR("lowLatencySession"));

  v44 = 0u;
  v45 = 0u;
  v42 = 0u;
  v43 = 0u;
  v27 = *(id *)(a1 + 32);
  v28 = objc_msgSend(v27, "countByEnumeratingWithState:objects:count:", &v42, v51, 16);
  if (v28)
  {
    v30 = *(_QWORD *)v43;
    *(_QWORD *)&v29 = 136315138;
    v41 = v29;
    do
    {
      v31 = 0;
      do
      {
        if (*(_QWORD *)v43 != v30)
          objc_enumerationMutation(v27);
        v32 = *(void **)(*((_QWORD *)&v42 + 1) + 8 * v31);
        objc_msgSend(*(id *)(a1 + 32), "objectForKey:", v32, v41, (_QWORD)v42);
        v33 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v2, "objectForKey:", v32);
        v34 = (void *)objc_claimAutoreleasedReturnValue();
        v35 = v34 == 0;

        if (v35)
        {
          objc_msgSend(v2, "setObject:forKeyedSubscript:", v33, v32);
        }
        else
        {
          if (onceToken_MicroLocation_Default != -1)
            dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_40);
          v36 = (id)logObject_MicroLocation_Default;
          if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
          {
            v37 = objc_msgSend(objc_retainAutorelease(v32), "UTF8String");
            *(_DWORD *)__p = v41;
            *(_QWORD *)&__p[4] = v37;
            _os_log_impl(&dword_2419D9000, v36, OS_LOG_TYPE_ERROR, "Trigger event already have %s. Ignoring.", __p, 0xCu);
          }

        }
        ++v31;
      }
      while (v28 != v31);
      v28 = objc_msgSend(v27, "countByEnumeratingWithState:objects:count:", &v42, v51, 16);
    }
    while (v28);
  }

  if (onceToken_MicroLocation_Default != -1)
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_40);
  v38 = (id)logObject_MicroLocation_Default;
  if (os_log_type_enabled(v38, OS_LOG_TYPE_DEBUG))
  {
    v39 = objc_msgSend(objc_retainAutorelease(*(id *)(a1 + 40)), "UTF8String");
    *(_QWORD *)__p = 68289539;
    *(_WORD *)&__p[8] = 2082;
    *(_QWORD *)&__p[10] = "";
    v47 = 2081;
    v48 = v39;
    v49 = 2113;
    v50 = v2;
    _os_log_impl(&dword_2419D9000, v38, OS_LOG_TYPE_DEBUG, "{\"msg%{public}.0s\":\"Sending CA event.\", \"name\":%{private, location:escape_only}s, \"event\":%{private, location:escape_only}@}", __p, 0x26u);
  }

  return v2;
}

void sub_241A4EC10(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  void *v26;
  void *v27;

  _Unwind_Resume(a1);
}

void CLMicroLocationCoreAnalyticsPublishHelper::sendTriggerEvent()
{
  void *v0;
  std::string *v1;
  __int128 v2;
  uint8_t *v3;
  void *v4;
  NSObject *v5;
  std::string v6;
  uint8_t buf[16];
  int64_t v8;

  if (ULSettings::get<ULSettings::AnalyticsSendEventEnabled>())
  {
    v0 = (void *)MEMORY[0x24BDD17C8];
    std::operator+<char>();
    v1 = std::string::append(&v6, ".triggers");
    v2 = *(_OWORD *)&v1->__r_.__value_.__l.__data_;
    v8 = v1->__r_.__value_.__r.__words[2];
    *(_OWORD *)buf = v2;
    v1->__r_.__value_.__l.__size_ = 0;
    v1->__r_.__value_.__r.__words[2] = 0;
    v1->__r_.__value_.__r.__words[0] = 0;
    if (v8 >= 0)
      v3 = buf;
    else
      v3 = *(uint8_t **)buf;
    objc_msgSend(v0, "stringWithUTF8String:", v3);
    v4 = (void *)objc_claimAutoreleasedReturnValue();
    AnalyticsSendEventLazy();

    if (SHIBYTE(v8) < 0)
      operator delete(*(void **)buf);
    if (SHIBYTE(v6.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v6.__r_.__value_.__l.__data_);
  }
  else
  {
    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_40);
    v5 = logObject_MicroLocation_Default;
    if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_2419D9000, v5, OS_LOG_TYPE_DEFAULT, "CLMicroLocationCoreAnalyticsPublishHelper, sendTriggerEvent, not sending event because sending to CoreAnalytics is disabled", buf, 2u);
    }
  }
}

void sub_241A4EE88(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  void *v25;
  uint64_t v26;

  if (*(char *)(v26 - 73) < 0)
    operator delete(*(void **)(v26 - 96));
  if (a25 < 0)
    operator delete(__p);
  _Unwind_Resume(a1);
}

id ___ZN41CLMicroLocationCoreAnalyticsPublishHelper16sendTriggerEventERKN20CLMicroLocationProto14RecordingEventERKNSt3__112basic_stringIcNS4_11char_traitsIcEENS4_9allocatorIcEEEESC_SC_SC_b_block_invoke(uint64_t a1)
{
  void *v2;
  uint64_t *v3;
  void *v4;
  const CLMicroLocationProto::RecordingEvent *v5;
  void *v6;
  void *v7;
  const void **v8;
  size_t v9;
  std::string *p_p;
  const void *v11;
  std::string *v12;
  void *v13;
  void *v14;
  const void **v15;
  size_t v16;
  std::string *v17;
  const void *v18;
  std::string *v19;
  void *v20;
  uint64_t *v21;
  void *v22;
  void *v23;
  const void **v24;
  size_t v25;
  std::string *v26;
  const void *v27;
  std::string *v28;
  void *v29;
  void *v30;
  std::string *v31;
  void *v32;
  const char *v33;
  void *v34;
  std::string __p;

  objc_msgSend(MEMORY[0x24BDBCED8], "dictionary");
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  v3 = *(uint64_t **)(a1 + 32);
  if (*((char *)v3 + 23) < 0)
    v3 = (uint64_t *)*v3;
  objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", v3);
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v2, "setObject:forKeyedSubscript:", v4, CFSTR("loiType"));

  CLMicroLocationProtobufHelper::getRecordingTriggerString(*(CLMicroLocationProtobufHelper **)(a1 + 48), v5);
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  v7 = (void *)MEMORY[0x24BDD17C8];
  v8 = *(const void ***)(a1 + 40);
  if (*((char *)v8 + 23) >= 0)
    v9 = *((unsigned __int8 *)v8 + 23);
  else
    v9 = (size_t)v8[1];
  p_p = &__p;
  std::string::basic_string[abi:ne180100]((uint64_t)&__p, v9 + 12);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  if (v9)
  {
    if (*((char *)v8 + 23) >= 0)
      v11 = v8;
    else
      v11 = *v8;
    memmove(p_p, v11, v9);
  }
  strcpy((char *)p_p + v9, "TriggerEvent");
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v12 = &__p;
  else
    v12 = (std::string *)__p.__r_.__value_.__r.__words[0];
  objc_msgSend(v7, "stringWithUTF8String:", v12);
  v13 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v2, "setObject:forKeyedSubscript:", v6, v13);

  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);

  v14 = (void *)MEMORY[0x24BDD17C8];
  v15 = *(const void ***)(a1 + 40);
  if (*((char *)v15 + 23) >= 0)
    v16 = *((unsigned __int8 *)v15 + 23);
  else
    v16 = (size_t)v15[1];
  v17 = &__p;
  std::string::basic_string[abi:ne180100]((uint64_t)&__p, v16 + 17);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
    v17 = (std::string *)__p.__r_.__value_.__r.__words[0];
  if (v16)
  {
    if (*((char *)v15 + 23) >= 0)
      v18 = v15;
    else
      v18 = *v15;
    memmove(v17, v18, v16);
  }
  strcpy((char *)v17 + v16, "TriggerEventCount");
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v19 = &__p;
  else
    v19 = (std::string *)__p.__r_.__value_.__r.__words[0];
  objc_msgSend(v14, "stringWithUTF8String:", v19);
  v20 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v2, "setObject:forKeyedSubscript:", &unk_2511ED7E0, v20);

  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  v21 = *(uint64_t **)(a1 + 56);
  if (*((char *)v21 + 23) < 0)
    v21 = (uint64_t *)*v21;
  objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", v21);
  v22 = (void *)objc_claimAutoreleasedReturnValue();
  v23 = (void *)MEMORY[0x24BDD17C8];
  v24 = *(const void ***)(a1 + 40);
  if (*((char *)v24 + 23) >= 0)
    v25 = *((unsigned __int8 *)v24 + 23);
  else
    v25 = (size_t)v24[1];
  v26 = &__p;
  std::string::basic_string[abi:ne180100]((uint64_t)&__p, v25 + 7);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
    v26 = (std::string *)__p.__r_.__value_.__r.__words[0];
  if (v25)
  {
    if (*((char *)v24 + 23) >= 0)
      v27 = v24;
    else
      v27 = *v24;
    memmove(v26, v27, v25);
  }
  strcpy((char *)v26 + v25, "Verdict");
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v28 = &__p;
  else
    v28 = (std::string *)__p.__r_.__value_.__r.__words[0];
  objc_msgSend(v23, "stringWithUTF8String:", v28);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v2, "setObject:forKeyedSubscript:", v22, v29);

  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);

  v30 = (void *)MEMORY[0x24BDD17C8];
  CLMicroLocationClientUtils::getClientIdFromClientIdAndServiceUuid(*(const std::string **)(a1 + 64), &__p);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v31 = &__p;
  else
    v31 = (std::string *)__p.__r_.__value_.__r.__words[0];
  objc_msgSend(v30, "stringWithUTF8String:", v31);
  v32 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v2, "setObject:forKeyedSubscript:", v32, CFSTR("clientId"));

  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  if (*(_BYTE *)(a1 + 72))
    v33 = "On";
  else
    v33 = "Off";
  objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", v33);
  v34 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v2, "setObject:forKeyedSubscript:", v34, CFSTR("displayState"));

  return v2;
}

void sub_241A4F28C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  void *v14;
  void *v15;

  _Unwind_Resume(a1);
}

uint64_t **std::__tree<std::__value_type<CLMicroLocationProto::DataType,unsigned long>,std::__map_value_compare<CLMicroLocationProto::DataType,std::__value_type<CLMicroLocationProto::DataType,unsigned long>,std::less<CLMicroLocationProto::DataType>,true>,std::allocator<std::__value_type<CLMicroLocationProto::DataType,unsigned long>>>::__emplace_unique_key_args<CLMicroLocationProto::DataType,std::piecewise_construct_t const&,std::tuple<CLMicroLocationProto::DataType const&>,std::tuple<>>(uint64_t **a1, int *a2, uint64_t a3, _DWORD **a4)
{
  uint64_t *v6;
  uint64_t **v7;
  int v8;
  uint64_t **v9;
  int v10;
  _DWORD *v11;

  v7 = a1 + 1;
  v6 = a1[1];
  if (v6)
  {
    v8 = *a2;
    while (1)
    {
      while (1)
      {
        v9 = (uint64_t **)v6;
        v10 = *((_DWORD *)v6 + 8);
        if (v8 >= v10)
          break;
        v6 = *v9;
        v7 = v9;
        if (!*v9)
          goto LABEL_10;
      }
      if (v10 >= v8)
        break;
      v6 = v9[1];
      if (!v6)
      {
        v7 = v9 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    v9 = a1 + 1;
LABEL_10:
    v11 = operator new(0x30uLL);
    v11[8] = **a4;
    *((_QWORD *)v11 + 5) = 0;
    std::__tree<CLMicroLocationRecordingCompletionMetaInformation::RecordingError>::__insert_node_at(a1, (uint64_t)v9, v7, (uint64_t *)v11);
    return (uint64_t **)v11;
  }
  return v9;
}

void ___ZL45_CLLogObjectForCategory_MicroLocation_Defaultv_block_invoke_33()
{
  os_log_t v0;
  void *v1;

  v0 = os_log_create("com.apple.MicroLocation", "MicroLocation");
  v1 = (void *)logObject_MicroLocation_Default;
  logObject_MicroLocation_Default = (uint64_t)v0;

}

unint64_t *std::__introsort<std::_ClassicAlgPolicy,std::greater<unsigned long> &,unsigned long *,false>(unint64_t *result, unint64_t *a2, uint64_t a3, uint64_t a4, char a5)
{
  unint64_t *v8;
  unint64_t *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t *v15;
  unint64_t v16;
  unint64_t *v17;
  char v18;
  BOOL v19;
  unint64_t v20;
  unint64_t v21;
  unint64_t v22;
  unint64_t v23;
  unint64_t v24;
  unint64_t v25;
  unint64_t v26;
  unint64_t v27;
  unint64_t v28;
  unint64_t v29;
  unint64_t v30;
  unint64_t v31;
  unint64_t v32;
  unint64_t v33;
  unint64_t v34;
  unint64_t v35;
  unint64_t v36;
  unint64_t v37;
  unint64_t v38;
  unint64_t v39;
  unint64_t v40;
  unint64_t v41;
  unint64_t v42;
  unint64_t v43;
  unint64_t v44;
  unint64_t v45;
  unint64_t v46;
  unint64_t v47;
  unint64_t v48;
  unint64_t v49;
  unint64_t v50;
  unint64_t v51;
  unint64_t v52;
  unint64_t v53;
  unint64_t v54;
  unint64_t v55;
  unint64_t v56;
  unint64_t v57;
  unint64_t v58;
  unint64_t v59;
  unint64_t v60;
  unint64_t *v61;
  BOOL v63;
  uint64_t v64;
  unint64_t *v65;
  unint64_t v66;
  unint64_t v67;
  uint64_t v68;
  unint64_t *v69;
  unint64_t v70;
  unint64_t v71;

  v8 = result;
LABEL_2:
  v9 = v8;
LABEL_3:
  v10 = 1 - a4;
  while (2)
  {
    v8 = v9;
    v11 = v10;
    v12 = (char *)a2 - (char *)v9;
    v13 = a2 - v9;
    switch(v13)
    {
      case 0uLL:
      case 1uLL:
        return result;
      case 2uLL:
        v20 = *(a2 - 1);
        v21 = *v9;
        if (v20 > *v9)
        {
          *v9 = v20;
          *(a2 - 1) = v21;
        }
        return result;
      case 3uLL:
        v22 = v9[1];
        v23 = *(a2 - 1);
        if (v22 <= v23)
          v24 = *(a2 - 1);
        else
          v24 = v9[1];
        if (v22 >= v23)
          v22 = *(a2 - 1);
        *(a2 - 1) = v22;
        v9[1] = v24;
        v25 = *(a2 - 1);
        if (v25 <= *v9)
          v26 = *v9;
        else
          v26 = *(a2 - 1);
        if (v25 >= *v9)
          v25 = *v9;
        *(a2 - 1) = v25;
        v28 = *v9;
        v27 = v9[1];
        if (v26 <= v27)
          v28 = v9[1];
        if (v26 < v27)
          v27 = v26;
        *v9 = v28;
        v9[1] = v27;
        return result;
      case 4uLL:
        v30 = v9[1];
        v29 = v9[2];
        if (*v9 <= v29)
          v31 = v9[2];
        else
          v31 = *v9;
        if (*v9 < v29)
          v29 = *v9;
        v9[2] = v29;
        *v9 = v31;
        v32 = *(a2 - 1);
        if (v30 <= v32)
          v33 = *(a2 - 1);
        else
          v33 = v30;
        if (v30 < v32)
          v32 = v30;
        *(a2 - 1) = v32;
        v34 = *v9;
        if (*v9 <= v33)
          v35 = v33;
        else
          v35 = *v9;
        if (*v9 >= v33)
          v34 = v33;
        *v9 = v35;
        v9[1] = v34;
        v36 = v9[2];
        v37 = *(a2 - 1);
        if (v36 <= v37)
          v38 = *(a2 - 1);
        else
          v38 = v9[2];
        if (v36 >= v37)
          v36 = *(a2 - 1);
        *(a2 - 1) = v36;
        v39 = v9[1];
        if (v39 <= v38)
          v40 = v38;
        else
          v40 = v9[1];
        if (v39 >= v38)
          v39 = v38;
        v9[1] = v40;
        v9[2] = v39;
        return result;
      case 5uLL:
        v41 = *v9;
        v42 = v9[1];
        if (*v9 <= v42)
          v43 = v9[1];
        else
          v43 = *v9;
        if (*v9 >= v42)
          v41 = v9[1];
        *v9 = v43;
        v9[1] = v41;
        v44 = v9[3];
        v45 = *(a2 - 1);
        if (v44 <= v45)
          v46 = *(a2 - 1);
        else
          v46 = v9[3];
        if (v44 >= v45)
          v44 = *(a2 - 1);
        *(a2 - 1) = v44;
        v9[3] = v46;
        v47 = *(a2 - 1);
        v48 = v9[2];
        if (v47 <= v48)
          v49 = v9[2];
        else
          v49 = *(a2 - 1);
        if (v47 >= v48)
          v47 = v9[2];
        *(a2 - 1) = v47;
        v51 = v9[2];
        v50 = v9[3];
        v52 = v9[1];
        if (v49 <= v50)
          v51 = v9[3];
        if (v49 < v50)
          v50 = v49;
        v9[2] = v51;
        v9[3] = v50;
        v53 = *(a2 - 1);
        if (v52 <= v53)
          v54 = *(a2 - 1);
        else
          v54 = v52;
        if (v52 < v53)
          v53 = v52;
        *(a2 - 1) = v53;
        v55 = *v9;
        v57 = v9[2];
        v56 = v9[3];
        if (v56 <= *v9)
          v58 = *v9;
        else
          v58 = v9[3];
        if (v56 >= *v9)
          v56 = *v9;
        if (v58 <= v57)
          v55 = v9[2];
        if (v58 < v57)
          v57 = v58;
        if (v56 <= v54)
          v59 = v54;
        else
          v59 = v56;
        if (v56 >= v54)
          v56 = v54;
        if (v59 <= v57)
          v54 = v57;
        *v9 = v55;
        v9[1] = v54;
        if (v59 >= v57)
          v60 = v57;
        else
          v60 = v59;
        v9[2] = v60;
        v9[3] = v56;
        return result;
      default:
        if (v12 > 191)
        {
          if (v11 == 1)
          {
            if (v9 != a2)
              return std::__partial_sort_impl[abi:ne180100]<std::_ClassicAlgPolicy,std::greater<unsigned long> &,unsigned long *,unsigned long *>(v9, a2, a2, a3);
            return result;
          }
          v14 = v13 >> 1;
          v15 = &v9[v13 >> 1];
          if ((unint64_t)v12 < 0x401)
          {
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::greater<unsigned long> &,unsigned long *>(&v9[v13 >> 1], v9, a2 - 1);
            if ((a5 & 1) != 0)
              goto LABEL_12;
          }
          else
          {
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::greater<unsigned long> &,unsigned long *>(v9, &v9[v13 >> 1], a2 - 1);
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::greater<unsigned long> &,unsigned long *>(v9 + 1, v15 - 1, a2 - 2);
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::greater<unsigned long> &,unsigned long *>(v9 + 2, &v9[v14 + 1], a2 - 3);
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::greater<unsigned long> &,unsigned long *>(v15 - 1, v15, &v9[v14 + 1]);
            v16 = *v9;
            *v9 = *v15;
            *v15 = v16;
            if ((a5 & 1) != 0)
              goto LABEL_12;
          }
          if (*(v9 - 1) <= *v9)
          {
            result = std::__partition_with_equals_on_left[abi:ne180100]<std::_ClassicAlgPolicy,unsigned long *,std::greater<unsigned long> &>(v9, (uint64_t *)a2);
            v9 = result;
            goto LABEL_17;
          }
LABEL_12:
          v17 = std::__partition_with_equals_on_right[abi:ne180100]<std::_ClassicAlgPolicy,unsigned long *,std::greater<unsigned long> &>(v9, a2);
          if ((v18 & 1) == 0)
            goto LABEL_15;
          v19 = std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,std::greater<unsigned long> &,unsigned long *>(v9, v17);
          v9 = v17 + 1;
          result = (unint64_t *)std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,std::greater<unsigned long> &,unsigned long *>(v17 + 1, a2);
          if (!(_DWORD)result)
          {
            v10 = v11 + 1;
            if (v19)
              continue;
LABEL_15:
            result = (unint64_t *)std::__introsort<std::_ClassicAlgPolicy,std::greater<unsigned long> &,unsigned long *,false>(v8, v17, a3, -v11, a5 & 1);
            v9 = v17 + 1;
LABEL_17:
            a5 = 0;
            a4 = -v11;
            goto LABEL_3;
          }
          a4 = -v11;
          a2 = v17;
          if (v19)
            return result;
          goto LABEL_2;
        }
        v61 = v9 + 1;
        v63 = v9 == a2 || v61 == a2;
        if ((a5 & 1) != 0)
        {
          if (!v63)
          {
            v64 = 0;
            v65 = v9;
            do
            {
              v67 = *v65;
              v66 = v65[1];
              v65 = v61;
              if (v66 > v67)
              {
                v68 = v64;
                while (1)
                {
                  *(unint64_t *)((char *)v9 + v68 + 8) = v67;
                  if (!v68)
                    break;
                  v67 = *(unint64_t *)((char *)v9 + v68 - 8);
                  v68 -= 8;
                  if (v66 <= v67)
                  {
                    v69 = (unint64_t *)((char *)v9 + v68 + 8);
                    goto LABEL_123;
                  }
                }
                v69 = v9;
LABEL_123:
                *v69 = v66;
              }
              v61 = v65 + 1;
              v64 += 8;
            }
            while (v65 + 1 != a2);
          }
        }
        else if (!v63)
        {
          do
          {
            v71 = *v8;
            v70 = v8[1];
            v8 = v61;
            if (v70 > v71)
            {
              do
              {
                *v61 = v71;
                v71 = *(v61 - 2);
                --v61;
              }
              while (v70 > v71);
              *v61 = v70;
            }
            v61 = v8 + 1;
          }
          while (v8 + 1 != a2);
        }
        return result;
    }
  }
}

uint64_t std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::greater<unsigned long> &,unsigned long *>(unint64_t *a1, unint64_t *a2, unint64_t *a3)
{
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;

  v3 = *a2;
  v4 = *a1;
  v5 = *a3;
  if (*a2 > *a1)
  {
    if (v5 > v3)
    {
      *a1 = v5;
      *a3 = v4;
      return 1;
    }
    *a1 = v3;
    *a2 = v4;
    if (*a3 <= v4)
      return 1;
    *a2 = *a3;
    *a3 = v4;
    return 2;
  }
  if (v5 > v3)
  {
    *a2 = v5;
    *a3 = v3;
    v6 = *a1;
    if (*a2 <= *a1)
      return 1;
    *a1 = *a2;
    *a2 = v6;
    return 2;
  }
  return 0;
}

unint64_t *std::__partition_with_equals_on_left[abi:ne180100]<std::_ClassicAlgPolicy,unsigned long *,std::greater<unsigned long> &>(unint64_t *a1, uint64_t *a2)
{
  unint64_t v2;
  unint64_t *v3;
  unint64_t v4;
  uint64_t *v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;

  v2 = *a1;
  if (*a1 <= *(a2 - 1))
  {
    v5 = (uint64_t *)(a1 + 1);
    do
    {
      v3 = (unint64_t *)v5;
      if (v5 >= a2)
        break;
      ++v5;
    }
    while (v2 <= *v3);
  }
  else
  {
    v3 = a1;
    do
    {
      v4 = v3[1];
      ++v3;
    }
    while (v2 <= v4);
  }
  if (v3 < (unint64_t *)a2)
  {
    do
      v6 = *--a2;
    while (v2 > v6);
  }
  if (v3 < (unint64_t *)a2)
  {
    v7 = *v3;
    v8 = *a2;
    do
    {
      *v3 = v8;
      *a2 = v7;
      do
      {
        v9 = v3[1];
        ++v3;
        v7 = v9;
      }
      while (v2 <= v9);
      do
      {
        v10 = *--a2;
        v8 = v10;
      }
      while (v2 > v10);
    }
    while (v3 < (unint64_t *)a2);
  }
  if (v3 - 1 != a1)
    *a1 = *(v3 - 1);
  *(v3 - 1) = v2;
  return v3;
}

unint64_t *std::__partition_with_equals_on_right[abi:ne180100]<std::_ClassicAlgPolicy,unsigned long *,std::greater<unsigned long> &>(unint64_t *a1, unint64_t *a2)
{
  uint64_t v2;
  unint64_t v3;
  unint64_t v4;
  unint64_t *v5;
  unint64_t *v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t *v10;
  unint64_t *v11;
  unint64_t v12;
  unint64_t v13;

  v2 = 0;
  v3 = *a1;
  do
    v4 = a1[++v2];
  while (v4 > v3);
  v5 = &a1[v2];
  v6 = &a1[v2 - 1];
  if (v2 == 1)
  {
    do
    {
      if (v5 >= a2)
        break;
      v8 = *--a2;
    }
    while (v8 <= v3);
  }
  else
  {
    do
      v7 = *--a2;
    while (v7 <= v3);
  }
  if (v5 < a2)
  {
    v9 = *a2;
    v10 = &a1[v2];
    v11 = a2;
    do
    {
      *v10 = v9;
      *v11 = v4;
      do
      {
        v12 = v10[1];
        ++v10;
        v4 = v12;
      }
      while (v12 > v3);
      do
      {
        v13 = *--v11;
        v9 = v13;
      }
      while (v13 <= v3);
    }
    while (v10 < v11);
    v6 = v10 - 1;
  }
  if (v6 != a1)
    *a1 = *v6;
  *v6 = v3;
  return v6;
}

BOOL std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,std::greater<unsigned long> &,unsigned long *>(unint64_t *a1, unint64_t *a2)
{
  uint64_t v2;
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  unint64_t *v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t *v12;
  int v13;
  uint64_t v14;
  unint64_t v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t *v19;
  unint64_t v20;
  unint64_t v21;
  unint64_t v22;
  unint64_t v23;
  unint64_t v24;
  unint64_t v25;
  unint64_t v26;
  unint64_t v27;
  unint64_t v28;
  unint64_t v29;
  unint64_t v30;
  unint64_t v31;
  unint64_t v32;
  unint64_t v33;
  unint64_t v34;
  unint64_t v35;
  unint64_t v36;
  unint64_t v37;
  unint64_t v38;
  unint64_t v39;
  unint64_t v40;
  unint64_t v41;
  unint64_t v42;
  unint64_t v43;
  unint64_t v44;
  unint64_t v45;
  unint64_t v46;
  unint64_t v47;
  unint64_t v48;
  unint64_t v49;
  unint64_t v50;
  unint64_t v51;
  unint64_t v52;
  unint64_t v53;
  unint64_t v54;
  unint64_t v55;
  unint64_t v56;
  unint64_t v57;
  unint64_t v58;

  v2 = 1;
  switch(a2 - a1)
  {
    case 0:
    case 1:
      return v2;
    case 2:
      v3 = *(a2 - 1);
      v4 = *a1;
      if (v3 > *a1)
      {
        *a1 = v3;
        *(a2 - 1) = v4;
      }
      return 1;
    case 3:
      v20 = a1[1];
      v21 = *(a2 - 1);
      if (v20 <= v21)
        v22 = *(a2 - 1);
      else
        v22 = a1[1];
      if (v20 >= v21)
        v20 = *(a2 - 1);
      *(a2 - 1) = v20;
      a1[1] = v22;
      v23 = *(a2 - 1);
      if (v23 <= *a1)
        v24 = *a1;
      else
        v24 = *(a2 - 1);
      if (v23 >= *a1)
        v23 = *a1;
      *(a2 - 1) = v23;
      v26 = *a1;
      v25 = a1[1];
      if (v24 <= v25)
        v26 = a1[1];
      if (v24 < v25)
        v25 = v24;
      *a1 = v26;
      a1[1] = v25;
      return 1;
    case 4:
      v48 = a1[1];
      v47 = a1[2];
      if (*a1 <= v47)
        v49 = a1[2];
      else
        v49 = *a1;
      if (*a1 < v47)
        v47 = *a1;
      a1[2] = v47;
      *a1 = v49;
      v50 = *(a2 - 1);
      if (v48 <= v50)
        v51 = *(a2 - 1);
      else
        v51 = v48;
      if (v48 < v50)
        v50 = v48;
      *(a2 - 1) = v50;
      v52 = *a1;
      if (*a1 <= v51)
        v53 = v51;
      else
        v53 = *a1;
      if (*a1 >= v51)
        v52 = v51;
      *a1 = v53;
      a1[1] = v52;
      v54 = a1[2];
      v55 = *(a2 - 1);
      if (v54 <= v55)
        v56 = *(a2 - 1);
      else
        v56 = a1[2];
      if (v54 >= v55)
        v54 = *(a2 - 1);
      *(a2 - 1) = v54;
      v57 = a1[1];
      if (v57 <= v56)
        v58 = v56;
      else
        v58 = a1[1];
      if (v57 >= v56)
        v57 = v56;
      a1[1] = v58;
      a1[2] = v57;
      return 1;
    case 5:
      v27 = *a1;
      v28 = a1[1];
      if (*a1 <= v28)
        v29 = a1[1];
      else
        v29 = *a1;
      if (*a1 >= v28)
        v27 = a1[1];
      *a1 = v29;
      a1[1] = v27;
      v30 = a1[3];
      v31 = *(a2 - 1);
      if (v30 <= v31)
        v32 = *(a2 - 1);
      else
        v32 = a1[3];
      if (v30 >= v31)
        v30 = *(a2 - 1);
      *(a2 - 1) = v30;
      a1[3] = v32;
      v33 = *(a2 - 1);
      v34 = a1[2];
      if (v33 <= v34)
        v35 = a1[2];
      else
        v35 = *(a2 - 1);
      if (v33 >= v34)
        v33 = a1[2];
      *(a2 - 1) = v33;
      v37 = a1[2];
      v36 = a1[3];
      v38 = a1[1];
      if (v35 <= v36)
        v37 = a1[3];
      if (v35 < v36)
        v36 = v35;
      a1[2] = v37;
      a1[3] = v36;
      v39 = *(a2 - 1);
      if (v38 <= v39)
        v40 = *(a2 - 1);
      else
        v40 = v38;
      if (v38 < v39)
        v39 = v38;
      *(a2 - 1) = v39;
      v41 = *a1;
      v43 = a1[2];
      v42 = a1[3];
      if (v42 <= *a1)
        v44 = *a1;
      else
        v44 = a1[3];
      if (v42 >= *a1)
        v42 = *a1;
      if (v44 <= v43)
        v41 = a1[2];
      if (v44 < v43)
        v43 = v44;
      if (v42 <= v40)
        v45 = v40;
      else
        v45 = v42;
      if (v42 >= v40)
        v42 = v40;
      if (v45 <= v43)
        v40 = v43;
      *a1 = v41;
      a1[1] = v40;
      if (v45 >= v43)
        v46 = v43;
      else
        v46 = v45;
      a1[2] = v46;
      a1[3] = v42;
      return 1;
    default:
      v6 = a1 + 2;
      v5 = a1[2];
      v8 = *a1;
      v7 = a1[1];
      if (v7 <= v5)
        v9 = a1[2];
      else
        v9 = a1[1];
      if (v7 < v5)
        v5 = a1[1];
      if (v5 <= v8)
        v10 = *a1;
      else
        v10 = v5;
      if (v5 >= v8)
        v5 = *a1;
      *v6 = v5;
      if (v10 <= v9)
        v11 = v9;
      else
        v11 = v8;
      if (v10 >= v9)
        v10 = v9;
      *a1 = v11;
      a1[1] = v10;
      v12 = a1 + 3;
      if (a1 + 3 == a2)
        return 1;
      v13 = 0;
      v14 = 24;
      break;
  }
  while (1)
  {
    v15 = *v12;
    v16 = *v6;
    if (*v12 > v16)
    {
      v17 = v14;
      while (1)
      {
        *(unint64_t *)((char *)a1 + v17) = v16;
        v18 = v17 - 8;
        if (v17 == 8)
          break;
        v16 = *(unint64_t *)((char *)a1 + v17 - 16);
        v17 -= 8;
        if (v15 <= v16)
        {
          v19 = (unint64_t *)((char *)a1 + v18);
          goto LABEL_27;
        }
      }
      v19 = a1;
LABEL_27:
      *v19 = v15;
      if (++v13 == 8)
        return v12 + 1 == a2;
    }
    v6 = v12;
    v14 += 8;
    if (++v12 == a2)
      return 1;
  }
}

unint64_t *std::__partial_sort_impl[abi:ne180100]<std::_ClassicAlgPolicy,std::greater<unsigned long> &,unsigned long *,unsigned long *>(unint64_t *a1, unint64_t *a2, unint64_t *a3, uint64_t a4)
{
  unint64_t *v6;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t *v12;
  unint64_t *v13;
  unint64_t *v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  unint64_t *v19;
  unint64_t *v20;
  uint64_t v21;
  unint64_t v22;
  unint64_t v23;
  uint64_t v24;
  unint64_t v25;
  unint64_t *v26;
  unint64_t v27;
  unint64_t v28;

  if (a1 != a2)
  {
    v6 = a2;
    v8 = (char *)a2 - (char *)a1;
    v9 = a2 - a1;
    if ((char *)a2 - (char *)a1 >= 9)
    {
      v10 = (unint64_t)(v9 - 2) >> 1;
      v11 = v10 + 1;
      v12 = &a1[v10];
      do
      {
        std::__sift_down[abi:ne180100]<std::_ClassicAlgPolicy,std::greater<unsigned long> &,unsigned long *>((uint64_t)a1, a4, v9, v12--);
        --v11;
      }
      while (v11);
    }
    v13 = v6;
    if (v6 != a3)
    {
      v14 = v6;
      do
      {
        v15 = *v14;
        if (*v14 > *a1)
        {
          *v14 = *a1;
          *a1 = v15;
          std::__sift_down[abi:ne180100]<std::_ClassicAlgPolicy,std::greater<unsigned long> &,unsigned long *>((uint64_t)a1, a4, v9, a1);
        }
        ++v14;
      }
      while (v14 != a3);
      v13 = a3;
    }
    if (v8 >= 9)
    {
      v16 = (unint64_t)v8 >> 3;
      do
      {
        v17 = 0;
        v18 = *a1;
        v19 = a1;
        do
        {
          v20 = &v19[v17 + 1];
          v21 = (2 * v17) | 1;
          v17 = 2 * v17 + 2;
          if (v17 >= v16)
          {
            v22 = *v20;
            v17 = v21;
          }
          else
          {
            v22 = *v20;
            v23 = v20[1];
            if (*v20 >= v23)
              v22 = v20[1];
            if (*v20 <= v23)
              v17 = v21;
            else
              ++v20;
          }
          *v19 = v22;
          v19 = v20;
        }
        while (v17 <= (uint64_t)((unint64_t)(v16 - 2) >> 1));
        if (v20 == --v6)
        {
          *v20 = v18;
        }
        else
        {
          *v20 = *v6;
          *v6 = v18;
          v24 = (char *)v20 - (char *)a1 + 8;
          if (v24 >= 9)
          {
            v25 = (((unint64_t)v24 >> 3) - 2) >> 1;
            v26 = &a1[v25];
            v27 = *v26;
            v28 = *v20;
            if (*v26 > *v20)
            {
              do
              {
                *v20 = v27;
                v20 = v26;
                if (!v25)
                  break;
                v25 = (v25 - 1) >> 1;
                v26 = &a1[v25];
                v27 = *v26;
              }
              while (*v26 > v28);
              *v20 = v28;
            }
          }
        }
      }
      while (v16-- > 2);
    }
    return v13;
  }
  return a3;
}

uint64_t std::__sift_down[abi:ne180100]<std::_ClassicAlgPolicy,std::greater<unsigned long> &,unsigned long *>(uint64_t result, uint64_t a2, uint64_t a3, unint64_t *a4)
{
  uint64_t v4;
  int64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t *v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  uint64_t v13;
  unint64_t v14;

  if (a3 >= 2)
  {
    v4 = (uint64_t)a4 - result;
    v5 = (unint64_t)(a3 - 2) >> 1;
    if (v5 >= ((uint64_t)a4 - result) >> 3)
    {
      v6 = v4 >> 2;
      v7 = (v4 >> 2) + 1;
      v8 = (unint64_t *)(result + 8 * v7);
      v9 = v6 + 2;
      if (v9 >= a3)
      {
        v10 = *v8;
      }
      else
      {
        v10 = *v8;
        v11 = v8[1];
        if (*v8 >= v11)
          v10 = v8[1];
        if (*v8 > v11)
        {
          ++v8;
          v7 = v9;
        }
      }
      v12 = *a4;
      if (v10 <= *a4)
      {
        do
        {
          *a4 = v10;
          a4 = v8;
          if (v5 < v7)
            break;
          v13 = (2 * v7) | 1;
          v8 = (unint64_t *)(result + 8 * v13);
          v7 = 2 * v7 + 2;
          if (v7 >= a3)
          {
            v10 = *v8;
            v7 = v13;
          }
          else
          {
            v10 = *v8;
            v14 = v8[1];
            if (*v8 >= v14)
              v10 = v8[1];
            if (*v8 <= v14)
              v7 = v13;
            else
              ++v8;
          }
        }
        while (v10 <= v12);
        *a4 = v12;
      }
    }
  }
  return result;
}

void std::vector<unsigned long>::__throw_out_of_range[abi:ne180100]()
{
  std::__throw_out_of_range[abi:ne180100]("vector");
}

uint64_t std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,CLMicroLocationProto::ServiceQualityReasonEnum *,false>(uint64_t result, int *a2, uint64_t a3, uint64_t a4, char a5)
{
  int *v8;
  int *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  unint64_t v14;
  int *v15;
  int v16;
  int *v17;
  char v18;
  BOOL v19;
  int v20;
  int v21;
  int *v22;
  BOOL v24;
  uint64_t v25;
  int *v26;
  int v27;
  int v28;
  uint64_t v29;
  int *v30;
  int v31;
  int v32;

  v8 = (int *)result;
LABEL_2:
  v9 = v8;
LABEL_3:
  v10 = 1 - a4;
  while (2)
  {
    v8 = v9;
    v11 = v10;
    v12 = (char *)a2 - (char *)v9;
    v13 = a2 - v9;
    switch(v13)
    {
      case 0uLL:
      case 1uLL:
        return result;
      case 2uLL:
        v20 = *(a2 - 1);
        v21 = *v9;
        if (v20 < *v9)
        {
          *v9 = v20;
          *(a2 - 1) = v21;
        }
        return result;
      case 3uLL:
        return std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,CLMicroLocationProto::ServiceQualityReasonEnum *>(v9, v9 + 1, a2 - 1);
      case 4uLL:
        return std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,CLMicroLocationProto::ServiceQualityReasonEnum *>(v9, v9 + 1, v9 + 2, a2 - 1);
      case 5uLL:
        return std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,CLMicroLocationProto::ServiceQualityReasonEnum *>(v9, v9 + 1, v9 + 2, v9 + 3, a2 - 1);
      default:
        if (v12 > 95)
        {
          if (v11 == 1)
          {
            if (v9 != a2)
              return (uint64_t)std::__partial_sort_impl[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,CLMicroLocationProto::ServiceQualityReasonEnum *,CLMicroLocationProto::ServiceQualityReasonEnum *>(v9, a2, a2, a3);
            return result;
          }
          v14 = v13 >> 1;
          v15 = &v9[v13 >> 1];
          if ((unint64_t)v12 < 0x201)
          {
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,CLMicroLocationProto::ServiceQualityReasonEnum *>(&v9[v13 >> 1], v9, a2 - 1);
            if ((a5 & 1) != 0)
              goto LABEL_12;
          }
          else
          {
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,CLMicroLocationProto::ServiceQualityReasonEnum *>(v9, &v9[v13 >> 1], a2 - 1);
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,CLMicroLocationProto::ServiceQualityReasonEnum *>(v9 + 1, v15 - 1, a2 - 2);
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,CLMicroLocationProto::ServiceQualityReasonEnum *>(v9 + 2, &v9[v14 + 1], a2 - 3);
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,CLMicroLocationProto::ServiceQualityReasonEnum *>(v15 - 1, v15, &v9[v14 + 1]);
            v16 = *v9;
            *v9 = *v15;
            *v15 = v16;
            if ((a5 & 1) != 0)
              goto LABEL_12;
          }
          if (*(v9 - 1) >= *v9)
          {
            result = (uint64_t)std::__partition_with_equals_on_left[abi:ne180100]<std::_ClassicAlgPolicy,CLMicroLocationProto::ServiceQualityReasonEnum *,std::__less<void,void> &>(v9, a2);
            v9 = (int *)result;
            goto LABEL_17;
          }
LABEL_12:
          v17 = std::__partition_with_equals_on_right[abi:ne180100]<std::_ClassicAlgPolicy,CLMicroLocationProto::ServiceQualityReasonEnum *,std::__less<void,void> &>(v9, a2);
          if ((v18 & 1) == 0)
            goto LABEL_15;
          v19 = std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,CLMicroLocationProto::ServiceQualityReasonEnum *>(v9, v17);
          v9 = v17 + 1;
          result = std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,CLMicroLocationProto::ServiceQualityReasonEnum *>(v17 + 1, a2);
          if (!(_DWORD)result)
          {
            v10 = v11 + 1;
            if (v19)
              continue;
LABEL_15:
            result = std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,CLMicroLocationProto::ServiceQualityReasonEnum *,false>(v8, v17, a3, -v11, a5 & 1);
            v9 = v17 + 1;
LABEL_17:
            a5 = 0;
            a4 = -v11;
            goto LABEL_3;
          }
          a4 = -v11;
          a2 = v17;
          if (v19)
            return result;
          goto LABEL_2;
        }
        v22 = v9 + 1;
        v24 = v9 == a2 || v22 == a2;
        if ((a5 & 1) != 0)
        {
          if (!v24)
          {
            v25 = 0;
            v26 = v9;
            do
            {
              v28 = *v26;
              v27 = v26[1];
              v26 = v22;
              if (v27 < v28)
              {
                v29 = v25;
                while (1)
                {
                  *(int *)((char *)v9 + v29 + 4) = v28;
                  if (!v29)
                    break;
                  v28 = *(int *)((char *)v9 + v29 - 4);
                  v29 -= 4;
                  if (v27 >= v28)
                  {
                    v30 = (int *)((char *)v9 + v29 + 4);
                    goto LABEL_42;
                  }
                }
                v30 = v9;
LABEL_42:
                *v30 = v27;
              }
              v22 = v26 + 1;
              v25 += 4;
            }
            while (v26 + 1 != a2);
          }
        }
        else if (!v24)
        {
          do
          {
            v32 = *v8;
            v31 = v8[1];
            v8 = v22;
            if (v31 < v32)
            {
              do
              {
                *v22 = v32;
                v32 = *(v22 - 2);
                --v22;
              }
              while (v31 < v32);
              *v22 = v31;
            }
            v22 = v8 + 1;
          }
          while (v8 + 1 != a2);
        }
        return result;
    }
  }
}

uint64_t std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,CLMicroLocationProto::ServiceQualityReasonEnum *>(int *a1, int *a2, int *a3)
{
  int v3;
  int v4;
  int v5;
  int v6;

  v3 = *a2;
  v4 = *a1;
  v5 = *a3;
  if (*a2 < *a1)
  {
    if (v5 < v3)
    {
      *a1 = v5;
      *a3 = v4;
      return 1;
    }
    *a1 = v3;
    *a2 = v4;
    if (*a3 >= v4)
      return 1;
    *a2 = *a3;
    *a3 = v4;
    return 2;
  }
  if (v5 < v3)
  {
    *a2 = v5;
    *a3 = v3;
    v6 = *a1;
    if (*a2 >= *a1)
      return 1;
    *a1 = *a2;
    *a2 = v6;
    return 2;
  }
  return 0;
}

int *std::__partition_with_equals_on_left[abi:ne180100]<std::_ClassicAlgPolicy,CLMicroLocationProto::ServiceQualityReasonEnum *,std::__less<void,void> &>(int *a1, int *a2)
{
  int v2;
  int *v3;
  int v4;
  int *v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;

  v2 = *a1;
  if (*a1 >= *(a2 - 1))
  {
    v5 = a1 + 1;
    do
    {
      v3 = v5;
      if (v5 >= a2)
        break;
      ++v5;
    }
    while (v2 >= *v3);
  }
  else
  {
    v3 = a1;
    do
    {
      v4 = v3[1];
      ++v3;
    }
    while (v2 >= v4);
  }
  if (v3 < a2)
  {
    do
      v6 = *--a2;
    while (v2 < v6);
  }
  if (v3 < a2)
  {
    v7 = *v3;
    v8 = *a2;
    do
    {
      *v3 = v8;
      *a2 = v7;
      do
      {
        v9 = v3[1];
        ++v3;
        v7 = v9;
      }
      while (v2 >= v9);
      do
      {
        v10 = *--a2;
        v8 = v10;
      }
      while (v2 < v10);
    }
    while (v3 < a2);
  }
  if (v3 - 1 != a1)
    *a1 = *(v3 - 1);
  *(v3 - 1) = v2;
  return v3;
}

int *std::__partition_with_equals_on_right[abi:ne180100]<std::_ClassicAlgPolicy,CLMicroLocationProto::ServiceQualityReasonEnum *,std::__less<void,void> &>(int *a1, int *a2)
{
  uint64_t v2;
  int v3;
  int v4;
  int *v5;
  int *v6;
  int v7;
  int v8;
  int v9;
  int *v10;
  int *v11;
  int v12;
  int v13;

  v2 = 0;
  v3 = *a1;
  do
    v4 = a1[++v2];
  while (v4 < v3);
  v5 = &a1[v2];
  v6 = &a1[v2 - 1];
  if (v2 == 1)
  {
    do
    {
      if (v5 >= a2)
        break;
      v8 = *--a2;
    }
    while (v8 >= v3);
  }
  else
  {
    do
      v7 = *--a2;
    while (v7 >= v3);
  }
  if (v5 < a2)
  {
    v9 = *a2;
    v10 = &a1[v2];
    v11 = a2;
    do
    {
      *v10 = v9;
      *v11 = v4;
      do
      {
        v12 = v10[1];
        ++v10;
        v4 = v12;
      }
      while (v12 < v3);
      do
      {
        v13 = *--v11;
        v9 = v13;
      }
      while (v13 >= v3);
    }
    while (v10 < v11);
    v6 = v10 - 1;
  }
  if (v6 != a1)
    *a1 = *v6;
  *v6 = v3;
  return v6;
}

BOOL std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,CLMicroLocationProto::ServiceQualityReasonEnum *>(int *a1, int *a2)
{
  uint64_t v4;
  _BOOL8 result;
  int v6;
  int v7;
  int *v8;
  int *v9;
  int v10;
  uint64_t v11;
  int v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  int *v16;

  v4 = a2 - a1;
  result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      v6 = *(a2 - 1);
      v7 = *a1;
      if (v6 < *a1)
      {
        *a1 = v6;
        *(a2 - 1) = v7;
      }
      return result;
    case 3:
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,CLMicroLocationProto::ServiceQualityReasonEnum *>(a1, a1 + 1, a2 - 1);
      return 1;
    case 4:
      std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,CLMicroLocationProto::ServiceQualityReasonEnum *>(a1, a1 + 1, a1 + 2, a2 - 1);
      return 1;
    case 5:
      std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,CLMicroLocationProto::ServiceQualityReasonEnum *>(a1, a1 + 1, a1 + 2, a1 + 3, a2 - 1);
      return 1;
    default:
      v8 = a1 + 2;
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,CLMicroLocationProto::ServiceQualityReasonEnum *>(a1, a1 + 1, a1 + 2);
      v9 = a1 + 3;
      if (a1 + 3 == a2)
        return 1;
      v10 = 0;
      v11 = 12;
      break;
  }
  while (1)
  {
    v12 = *v9;
    v13 = *v8;
    if (*v9 < *v8)
    {
      v14 = v11;
      while (1)
      {
        *(int *)((char *)a1 + v14) = v13;
        v15 = v14 - 4;
        if (v14 == 4)
          break;
        v13 = *(int *)((char *)a1 + v14 - 8);
        v14 -= 4;
        if (v12 >= v13)
        {
          v16 = (int *)((char *)a1 + v15);
          goto LABEL_12;
        }
      }
      v16 = a1;
LABEL_12:
      *v16 = v12;
      if (++v10 == 8)
        return v9 + 1 == a2;
    }
    v8 = v9;
    v11 += 4;
    if (++v9 == a2)
      return 1;
  }
}

uint64_t std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,CLMicroLocationProto::ServiceQualityReasonEnum *>(int *a1, int *a2, int *a3, int *a4)
{
  uint64_t result;
  int v9;
  int v10;
  int v11;

  result = std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,CLMicroLocationProto::ServiceQualityReasonEnum *>(a1, a2, a3);
  v9 = *a3;
  if (*a4 < *a3)
  {
    *a3 = *a4;
    *a4 = v9;
    v10 = *a2;
    if (*a3 < *a2)
    {
      *a2 = *a3;
      *a3 = v10;
      v11 = *a1;
      if (*a2 < *a1)
      {
        *a1 = *a2;
        *a2 = v11;
      }
    }
  }
  return result;
}

uint64_t std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,CLMicroLocationProto::ServiceQualityReasonEnum *>(int *a1, int *a2, int *a3, int *a4, int *a5)
{
  uint64_t result;
  int v11;
  int v12;
  int v13;
  int v14;

  result = std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,CLMicroLocationProto::ServiceQualityReasonEnum *>(a1, a2, a3, a4);
  v11 = *a4;
  if (*a5 < *a4)
  {
    *a4 = *a5;
    *a5 = v11;
    v12 = *a3;
    if (*a4 < *a3)
    {
      *a3 = *a4;
      *a4 = v12;
      v13 = *a2;
      if (*a3 < *a2)
      {
        *a2 = *a3;
        *a3 = v13;
        v14 = *a1;
        if (*a2 < *a1)
        {
          *a1 = *a2;
          *a2 = v14;
        }
      }
    }
  }
  return result;
}

int *std::__partial_sort_impl[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,CLMicroLocationProto::ServiceQualityReasonEnum *,CLMicroLocationProto::ServiceQualityReasonEnum *>(int *a1, int *a2, int *a3, uint64_t a4)
{
  int *v6;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  int *v12;
  int *v13;
  int *v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  int *v19;
  int *v20;
  uint64_t v21;
  int v22;
  int v23;
  uint64_t v24;
  unint64_t v25;
  int *v26;
  int v27;
  int v28;

  if (a1 != a2)
  {
    v6 = a2;
    v8 = (char *)a2 - (char *)a1;
    v9 = a2 - a1;
    if ((char *)a2 - (char *)a1 >= 5)
    {
      v10 = (unint64_t)(v9 - 2) >> 1;
      v11 = v10 + 1;
      v12 = &a1[v10];
      do
      {
        std::__sift_down[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,CLMicroLocationProto::ServiceQualityReasonEnum *>((uint64_t)a1, a4, v9, v12--);
        --v11;
      }
      while (v11);
    }
    v13 = v6;
    if (v6 != a3)
    {
      v14 = v6;
      do
      {
        v15 = *v14;
        if (*v14 < *a1)
        {
          *v14 = *a1;
          *a1 = v15;
          std::__sift_down[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,CLMicroLocationProto::ServiceQualityReasonEnum *>((uint64_t)a1, a4, v9, a1);
        }
        ++v14;
      }
      while (v14 != a3);
      v13 = a3;
    }
    if (v8 >= 5)
    {
      v16 = (unint64_t)v8 >> 2;
      do
      {
        v17 = 0;
        v18 = *a1;
        v19 = a1;
        do
        {
          v20 = &v19[v17 + 1];
          v21 = (2 * v17) | 1;
          v17 = 2 * v17 + 2;
          if (v17 >= v16)
          {
            v22 = *v20;
            v17 = v21;
          }
          else
          {
            v22 = *v20;
            v23 = v20[1];
            if (*v20 <= v23)
              v22 = v20[1];
            if (*v20 >= v23)
              v17 = v21;
            else
              ++v20;
          }
          *v19 = v22;
          v19 = v20;
        }
        while (v17 <= (uint64_t)((unint64_t)(v16 - 2) >> 1));
        if (v20 == --v6)
        {
          *v20 = v18;
        }
        else
        {
          *v20 = *v6;
          *v6 = v18;
          v24 = (char *)v20 - (char *)a1 + 4;
          if (v24 >= 5)
          {
            v25 = (((unint64_t)v24 >> 2) - 2) >> 1;
            v26 = &a1[v25];
            v27 = *v26;
            v28 = *v20;
            if (*v26 < *v20)
            {
              do
              {
                *v20 = v27;
                v20 = v26;
                if (!v25)
                  break;
                v25 = (v25 - 1) >> 1;
                v26 = &a1[v25];
                v27 = *v26;
              }
              while (*v26 < v28);
              *v20 = v28;
            }
          }
        }
      }
      while (v16-- > 2);
    }
    return v13;
  }
  return a3;
}

uint64_t std::__sift_down[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,CLMicroLocationProto::ServiceQualityReasonEnum *>(uint64_t result, uint64_t a2, uint64_t a3, int *a4)
{
  uint64_t v4;
  int64_t v5;
  uint64_t v6;
  uint64_t v7;
  int *v8;
  uint64_t v9;
  int v10;
  int v11;
  int v12;
  uint64_t v13;
  int v14;

  if (a3 >= 2)
  {
    v4 = (uint64_t)a4 - result;
    v5 = (unint64_t)(a3 - 2) >> 1;
    if (v5 >= ((uint64_t)a4 - result) >> 2)
    {
      v6 = v4 >> 1;
      v7 = (v4 >> 1) + 1;
      v8 = (int *)(result + 4 * v7);
      v9 = v6 + 2;
      if (v9 >= a3)
      {
        v10 = *v8;
      }
      else
      {
        v10 = *v8;
        v11 = v8[1];
        if (*v8 <= v11)
          v10 = v8[1];
        if (*v8 < v11)
        {
          ++v8;
          v7 = v9;
        }
      }
      v12 = *a4;
      if (v10 >= *a4)
      {
        do
        {
          *a4 = v10;
          a4 = v8;
          if (v5 < v7)
            break;
          v13 = (2 * v7) | 1;
          v8 = (int *)(result + 4 * v13);
          v7 = 2 * v7 + 2;
          if (v7 >= a3)
          {
            v10 = *v8;
            v7 = v13;
          }
          else
          {
            v10 = *v8;
            v14 = v8[1];
            if (*v8 <= v14)
              v10 = v8[1];
            if (*v8 >= v14)
              v7 = v13;
            else
              ++v8;
          }
        }
        while (v10 >= v12);
        *a4 = v12;
      }
    }
  }
  return result;
}

std::vector<std::string> **std::back_insert_iterator<std::vector<std::string>>::operator=[abi:ne180100](std::vector<std::string> **a1, __int128 *a2)
{
  std::vector<std::string> *v4;
  std::vector<std::string>::pointer end;
  std::vector<std::string> *v6;
  std::allocator<std::string> *p_end_cap;
  std::string *v8;
  std::string *value;
  __int128 v10;
  std::string *v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  std::string *v16;
  std::string *v17;
  __int128 v18;
  std::__split_buffer<std::string> __v;

  v4 = *a1;
  end = (*a1)->__end_;
  v6 = *a1;
  value = v6->__end_cap_.__value_;
  p_end_cap = (std::allocator<std::string> *)&v6->__end_cap_;
  v8 = value;
  if (end >= value)
  {
    v12 = 0xAAAAAAAAAAAAAAABLL * (((char *)end - (char *)v4->__begin_) >> 3);
    v13 = v12 + 1;
    if (v12 + 1 > 0xAAAAAAAAAAAAAAALL)
      std::vector<CLMicroLocationProto::ConfidenceReason>::__throw_length_error[abi:ne180100]();
    v14 = 0xAAAAAAAAAAAAAAABLL * (((char *)v8 - (char *)v4->__begin_) >> 3);
    if (2 * v14 > v13)
      v13 = 2 * v14;
    if (v14 >= 0x555555555555555)
      v15 = 0xAAAAAAAAAAAAAAALL;
    else
      v15 = v13;
    __v.__end_cap_.__value_ = p_end_cap;
    if (v15)
      v16 = (std::string *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::string>>((uint64_t)p_end_cap, v15);
    else
      v16 = 0;
    v17 = v16 + v12;
    __v.__first_ = v16;
    __v.__begin_ = v17;
    __v.__end_cap_.__value_ = &v16[v15];
    v18 = *a2;
    v17->__r_.__value_.__r.__words[2] = *((_QWORD *)a2 + 2);
    *(_OWORD *)&v17->__r_.__value_.__l.__data_ = v18;
    *((_QWORD *)a2 + 1) = 0;
    *((_QWORD *)a2 + 2) = 0;
    *(_QWORD *)a2 = 0;
    __v.__end_ = v17 + 1;
    std::vector<std::string>::__swap_out_circular_buffer(v4, &__v);
    v11 = v4->__end_;
    std::__split_buffer<std::string>::~__split_buffer(&__v);
  }
  else
  {
    v10 = *a2;
    end->__r_.__value_.__r.__words[2] = *((_QWORD *)a2 + 2);
    *(_OWORD *)&end->__r_.__value_.__l.__data_ = v10;
    *((_QWORD *)a2 + 1) = 0;
    *((_QWORD *)a2 + 2) = 0;
    *(_QWORD *)a2 = 0;
    v11 = end + 1;
    v4->__end_ = end + 1;
  }
  v4->__end_ = v11;
  return a1;
}

void sub_241A50B88(_Unwind_Exception *a1, std::__split_buffer<std::string> *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  std::__split_buffer<std::string>::~__split_buffer((std::__split_buffer<std::string> *)&a10);
  _Unwind_Resume(a1);
}

uint64_t std::string::__insert_with_size<std::__wrap_iter<char const*>,std::__wrap_iter<char const*>>(std::string *this, uint64_t a2, char *a3, char *a4, std::string::size_type __n_add)
{
  std::string *v6;
  std::string::size_type v7;
  std::string::size_type size;
  std::string *v9;
  std::string::size_type v10;
  std::string *p_p;
  uint64_t v12;
  std::string __p;

  v6 = this;
  if ((SHIBYTE(this->__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    v7 = a2 - (_QWORD)this;
    if (__n_add)
    {
      size = HIBYTE(this->__r_.__value_.__r.__words[2]);
      v9 = this;
      goto LABEL_6;
    }
    return (uint64_t)v6 + v7;
  }
  v9 = (std::string *)this->__r_.__value_.__r.__words[0];
  v7 = a2 - this->__r_.__value_.__r.__words[0];
  if (!__n_add)
  {
    v6 = (std::string *)this->__r_.__value_.__r.__words[0];
    return (uint64_t)v6 + v7;
  }
  size = this->__r_.__value_.__l.__size_;
LABEL_6:
  if (v9 > (std::string *)a3 || (char *)&v9->__r_.__value_.__l.__data_ + size + 1 <= a3)
    return std::string::__insert_from_safe_copy[abi:ne180100]<std::__wrap_iter<char const*>,std::__wrap_iter<char const*>>(this, __n_add, v7, a3, a4);
  std::string::__init_with_sentinel[abi:ne180100]<std::__wrap_iter<char const*>,std::__wrap_iter<char const*>>(&__p, a3, a4);
  v10 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    p_p = &__p;
  else
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
    v10 = __p.__r_.__value_.__l.__size_;
  v12 = std::string::__insert_from_safe_copy[abi:ne180100]<std::__wrap_iter<char const*>,std::__wrap_iter<char const*>>(v6, __n_add, v7, (char *)p_p, (char *)p_p + v10);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  return v12;
}

void sub_241A50C9C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t std::string::__insert_from_safe_copy[abi:ne180100]<std::__wrap_iter<char const*>,std::__wrap_iter<char const*>>(std::string *this, std::string::size_type __n_add, std::string::size_type __n_copy, char *a4, char *a5)
{
  std::string *v9;
  std::string::size_type size;
  std::string::size_type v11;
  std::string *v12;
  size_t v13;
  std::string::size_type v14;
  _BYTE *v15;
  char v16;

  v9 = this;
  if (SHIBYTE(this->__r_.__value_.__r.__words[2]) < 0)
  {
    size = this->__r_.__value_.__l.__size_;
    v11 = (this->__r_.__value_.__r.__words[2] & 0x7FFFFFFFFFFFFFFFLL) - 1;
    if (v11 - size >= __n_add)
    {
      v12 = (std::string *)this->__r_.__value_.__r.__words[0];
      goto LABEL_7;
    }
  }
  else
  {
    size = HIBYTE(this->__r_.__value_.__r.__words[2]);
    v11 = 22;
    v12 = this;
    if (22 - size >= __n_add)
    {
LABEL_7:
      v13 = size - __n_copy;
      if (size == __n_copy)
        size = __n_copy;
      else
        memmove((char *)v12 + __n_copy + __n_add, (char *)v12 + __n_copy, v13);
      goto LABEL_10;
    }
  }
  std::string::__grow_by(this, v11, size + __n_add - v11, size, __n_copy, 0, __n_add);
  v9->__r_.__value_.__l.__size_ = size + __n_add;
  v12 = (std::string *)v9->__r_.__value_.__r.__words[0];
LABEL_10:
  v14 = size + __n_add;
  if (SHIBYTE(v9->__r_.__value_.__r.__words[2]) < 0)
    v9->__r_.__value_.__l.__size_ = v14;
  else
    *((_BYTE *)&v9->__r_.__value_.__s + 23) = v14 & 0x7F;
  v12->__r_.__value_.__s.__data_[v14] = 0;
  if (a4 != a5)
  {
    v15 = (char *)v12 + __n_copy;
    do
    {
      v16 = *a4++;
      *v15++ = v16;
    }
    while (a4 != a5);
  }
  if (SHIBYTE(v9->__r_.__value_.__r.__words[2]) < 0)
    v9 = (std::string *)v9->__r_.__value_.__r.__words[0];
  return (uint64_t)v9 + __n_copy;
}

void std::string::__init_with_sentinel[abi:ne180100]<std::__wrap_iter<char const*>,std::__wrap_iter<char const*>>(std::string *this, std::string::value_type *a2, std::string::value_type *a3)
{
  std::string::value_type *v4;

  *(_OWORD *)&this->__r_.__value_.__l.__data_ = 0uLL;
  this->__r_.__value_.__r.__words[2] = 0;
  if (a2 != a3)
  {
    v4 = a2;
    do
      std::string::push_back(this, *v4++);
    while (v4 != a3);
  }
}

void sub_241A50E24(void *a1)
{
  uint64_t v1;

  __cxa_begin_catch(a1);
  if (*(char *)(v1 + 23) < 0)
    operator delete(*(void **)v1);
  __cxa_rethrow();
}

void sub_241A50E40(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

uint64_t std::string::__insert_with_size<char const*,char const*>(std::string *this, uint64_t a2, char *a3, char *a4, std::string::size_type __n_add)
{
  std::string *v6;
  std::string::size_type v7;
  std::string::size_type size;
  std::string *v9;
  std::string::size_type v10;
  std::string *p_p;
  uint64_t v12;
  std::string __p;

  v6 = this;
  if ((SHIBYTE(this->__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    v7 = a2 - (_QWORD)this;
    if (__n_add)
    {
      size = HIBYTE(this->__r_.__value_.__r.__words[2]);
      v9 = this;
      goto LABEL_6;
    }
    return (uint64_t)v6 + v7;
  }
  v9 = (std::string *)this->__r_.__value_.__r.__words[0];
  v7 = a2 - this->__r_.__value_.__r.__words[0];
  if (!__n_add)
  {
    v6 = (std::string *)this->__r_.__value_.__r.__words[0];
    return (uint64_t)v6 + v7;
  }
  size = this->__r_.__value_.__l.__size_;
LABEL_6:
  if (v9 > (std::string *)a3 || (char *)&v9->__r_.__value_.__l.__data_ + size + 1 <= a3)
    return std::string::__insert_from_safe_copy[abi:ne180100]<std::__wrap_iter<char const*>,std::__wrap_iter<char const*>>(this, __n_add, v7, a3, a4);
  std::string::__init_with_sentinel[abi:ne180100]<char const*,char const*>(&__p, a3, a4);
  v10 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    p_p = &__p;
  else
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
    v10 = __p.__r_.__value_.__l.__size_;
  v12 = std::string::__insert_from_safe_copy[abi:ne180100]<std::__wrap_iter<char const*>,std::__wrap_iter<char const*>>(v6, __n_add, v7, (char *)p_p, (char *)p_p + v10);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  return v12;
}

void sub_241A50F54(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void std::string::__init_with_sentinel[abi:ne180100]<char const*,char const*>(std::string *this, std::string::value_type *a2, std::string::value_type *a3)
{
  std::string::value_type *v4;

  *(_OWORD *)&this->__r_.__value_.__l.__data_ = 0uLL;
  this->__r_.__value_.__r.__words[2] = 0;
  if (a2 != a3)
  {
    v4 = a2;
    do
      std::string::push_back(this, *v4++);
    while (v4 != a3);
  }
}

void sub_241A50FC4(void *a1)
{
  uint64_t v1;

  __cxa_begin_catch(a1);
  if (*(char *)(v1 + 23) < 0)
    operator delete(*(void **)v1);
  __cxa_rethrow();
}

void sub_241A50FE0(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

uint64_t std::string::basic_string[abi:ne180100](uint64_t a1, unint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  void *v6;

  if (a2 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  if (a2 > 0x16)
  {
    v4 = (a2 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((a2 | 7) != 0x17)
      v4 = a2 | 7;
    v5 = v4 + 1;
    v6 = operator new(v4 + 1);
    *(_QWORD *)(a1 + 8) = a2;
    *(_QWORD *)(a1 + 16) = v5 | 0x8000000000000000;
    *(_QWORD *)a1 = v6;
  }
  else
  {
    *(_QWORD *)(a1 + 8) = 0;
    *(_QWORD *)(a1 + 16) = 0;
    *(_QWORD *)a1 = 0;
    *(_BYTE *)(a1 + 23) = a2;
  }
  return a1;
}

void CLMicroLocationLegacyEventForcedRecording::handleEvent(double *a1@<X1>, char *a2@<X8>)
{
  double v3;
  _BYTE v4[24];
  _BYTE v5[144];
  char v6;
  _BYTE v7[144];

  v3 = *a1;
  CLMicroLocationProto::ForcedRecording::ForcedRecording((CLMicroLocationProto::ForcedRecording *)v4);
  CLMicroLocationProtobufHelper::createRecordingEvent<CLMicroLocationProto::ForcedRecording>((CLMicroLocationProto::RecordingEvent *)v4, 0, 0, 0, (CLMicroLocationProto *)3, (uint64_t)v5, v3);
  v6 = 1;
  CLMicroLocationProto::RecordingEvent::RecordingEvent((CLMicroLocationProto::RecordingEvent *)v7, (const CLMicroLocationProto::RecordingEvent *)v5);
  *a2 = v6;
  CLMicroLocationProto::RecordingEvent::RecordingEvent((CLMicroLocationProto::RecordingEvent *)(a2 + 8), (const CLMicroLocationProto::RecordingEvent *)v7);
  CLMicroLocationProto::RecordingEvent::~RecordingEvent((CLMicroLocationProto::RecordingEvent *)v7);
  CLMicroLocationProto::RecordingEvent::~RecordingEvent((CLMicroLocationProto::RecordingEvent *)v5);
  CLMicroLocationProto::ForcedRecording::~ForcedRecording((CLMicroLocationProto::ForcedRecording *)v4);
}

void sub_241A5116C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12)
{
  CLMicroLocationProto::RecordingEvent *v12;

  CLMicroLocationProto::RecordingEvent::~RecordingEvent(v12);
  CLMicroLocationProto::RecordingEvent::~RecordingEvent((CLMicroLocationProto::RecordingEvent *)&a12);
  CLMicroLocationProto::ForcedRecording::~ForcedRecording((CLMicroLocationProto::ForcedRecording *)&a9);
  _Unwind_Resume(a1);
}

void CLMicroLocationProtobufHelper::createRecordingEvent<CLMicroLocationProto::ForcedRecording>(CLMicroLocationProto::RecordingEvent *a1@<X0>, CLMicroLocationProto *a2@<X1>, char a3@<W2>, char a4@<W3>, CLMicroLocationProto *a5@<X4>, uint64_t a6@<X8>, double a7@<D0>)
{
  unsigned int v14;
  int v15;
  const CLMicroLocationProto::ForcedRecording *v16;
  const char *v17;
  int v18;
  const char *v19;

  CLMicroLocationProto::RecordingEvent::RecordingEvent((CLMicroLocationProto::RecordingEvent *)a6);
  v14 = *((_DWORD *)a1 + 2);
  if (!CLMicroLocationProto::EventType_IsValid((CLMicroLocationProto *)v14))
  {
    v17 = "::CLMicroLocationProto::EventType_IsValid(value)";
    v18 = 20192;
    v19 = "set_eventtype";
    goto LABEL_10;
  }
  v15 = *(_DWORD *)(a6 + 140);
  *(_DWORD *)(a6 + 72) = v14;
  *(double *)(a6 + 8) = a7;
  *(_BYTE *)(a6 + 77) = a3;
  *(_DWORD *)(a6 + 140) = v15 | 0x2803;
  *(_BYTE *)(a6 + 76) = a4;
  if (!CLMicroLocationProto::ConfidenceLevel_IsValid(a5))
  {
    v17 = "::CLMicroLocationProto::ConfidenceLevel_IsValid(value)";
    v18 = 20701;
    v19 = "set_confidencelevel";
    goto LABEL_10;
  }
  *(_DWORD *)(a6 + 140) |= 0x4000u;
  *(_DWORD *)(a6 + 120) = (_DWORD)a5;
  if (((unint64_t)a2 & 0xFF00000000) != 0)
  {
    if (CLMicroLocationProto::MotionState_IsValid(a2))
    {
      *(_DWORD *)(a6 + 140) |= 0x20000u;
      *(_DWORD *)(a6 + 124) = (_DWORD)a2;
      goto LABEL_6;
    }
    v17 = "::CLMicroLocationProto::MotionState_IsValid(value)";
    v18 = 20793;
    v19 = "set_motionstate";
LABEL_10:
    __assert_rtn(v19, "microlocation.pb.h", v18, v17);
  }
LABEL_6:
  CLMicroLocationProtobufHelper::setSpecificRecordingEvent((CLMicroLocationProtobufHelper *)a6, a1, v16);
}

void sub_241A512CC(_Unwind_Exception *a1)
{
  CLMicroLocationProto::RecordingEvent *v1;

  CLMicroLocationProto::RecordingEvent::~RecordingEvent(v1);
  _Unwind_Resume(a1);
}

CLMicroLocationStateMachine::StateMachineBase *CLMiLoCustomLoiRecordingManager::CLMiLoCustomLoiRecordingManager(CLMicroLocationStateMachine::StateMachineBase *a1, uint64_t a2)
{
  CLMicroLocationStateMachine::StateMachineBase *v4;
  void *__p[2];
  char v7;

  v4 = CLMicroLocationStateMachine::StateMachineBase::StateMachineBase(a1);
  *((_QWORD *)v4 + 7) = &off_2511D49D0;
  *((_QWORD *)v4 + 8) = &off_2511D4A48;
  *(_QWORD *)v4 = &off_2511D4978;
  *((_QWORD *)v4 + 9) = &off_2511D4AA0;
  *((_QWORD *)v4 + 20) = 0;
  *((_QWORD *)v4 + 21) = 0;
  *((_QWORD *)v4 + 10) = &off_2511D4AF8;
  *((_WORD *)v4 + 72) = 0;
  *((_QWORD *)v4 + 11) = &off_2511D4B50;
  *((_DWORD *)v4 + 44) = 0;
  *((_QWORD *)v4 + 12) = &off_2511D4BA8;
  *((_QWORD *)v4 + 13) = &off_2511D4C00;
  *((_QWORD *)v4 + 19) = 0;
  *((_QWORD *)v4 + 14) = &off_2511D4C58;
  *((_QWORD *)v4 + 24) = 0;
  *((_QWORD *)v4 + 25) = 0;
  *((_QWORD *)v4 + 15) = &off_2511D4CB0;
  *((_QWORD *)v4 + 16) = off_2511D4D00;
  *((_QWORD *)v4 + 23) = a2;
  *((_QWORD *)v4 + 17) = &off_2511D4D40;
  CLMiLoCustomLoiRecordingManager::setupIdleState(v4);
  CLMiLoCustomLoiRecordingManager::setupRecordingState(a1);
  CLMiLoCustomLoiRecordingManager::setupRecordingThrottledState(a1);
  CLMiLoCustomLoiRecordingManager::setupRecordingPendingState(a1);
  std::string::basic_string[abi:ne180100]<0>(__p, "IdleState");
  CLMicroLocationStateMachine::StateMachineBase::setInitialState(a1, (uint64_t *)__p);
  if (v7 < 0)
    operator delete(__p[0]);
  return a1;
}

void sub_241A51454(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, CLMacAddress *a9, CLMacAddress *a10, CLMacAddress *a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  id *v17;
  CLMacAddress *v18;
  CLMacAddress *v19;
  CLMacAddress *v20;
  CLMacAddress *v21;
  CLMacAddress *v22;
  CLMacAddress *v23;
  CLMacAddress *v24;
  CLMacAddress *v25;
  unint64_t v27;
  unint64_t v28;
  unint64_t v29;
  unint64_t v30;
  unint64_t v31;
  unint64_t v32;
  unint64_t v33;
  unint64_t v34;
  unint64_t v35;
  unint64_t v36;
  unint64_t v37;

  if (a17 < 0)
    operator delete(__p);

  CLMacAddress::newFromUint64(v19, v27);
  CLMacAddress::newFromUint64(v18, v28);
  CLMacAddress::newFromUint64(v25, v29);
  CLMacAddress::newFromUint64(v24, v30);
  CLMacAddress::newFromUint64(v23, v31);
  CLMacAddress::newFromUint64(v22, v32);
  CLMacAddress::newFromUint64(v21, v33);
  CLMacAddress::newFromUint64(v20, v34);
  CLMacAddress::newFromUint64(a9, v35);
  CLMacAddress::newFromUint64(a10, v36);
  CLMacAddress::newFromUint64(a11, v37);
  CLMicroLocationStateMachine::StateMachineBase::~StateMachineBase((CLMicroLocationStateMachine::StateMachineBase *)v17);
  _Unwind_Resume(a1);
}

_QWORD *CLMiLoCustomLoiRecordingManager::StartRecordingSession@<X0>(CFAbsoluteTime *this@<X0>, uint64_t a2@<X8>)
{
  char *v5;
  _QWORD *result;

  this[20] = cl::chrono::CFAbsoluteTimeClock::now();
  (*(void (**)(_QWORD))(**((_QWORD **)this + 23) + 8))(*((_QWORD *)this + 23));
  CLMiLoCustomLoiRecordingManager::startRecordingTimer((id *)this);
  if (*((_BYTE *)this + 144))
    v5 = "RecordingState";
  else
    v5 = "RecordingPendingState";
  result = std::string::basic_string[abi:ne180100]<0>((_QWORD *)a2, v5);
  *(_BYTE *)(a2 + 24) = 1;
  return result;
}

void CLMiLoCustomLoiRecordingManager::DeviceReadyHandler(CLMiLoCustomLoiRecordingManager *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v5;
  __int128 v6;
  BOOL v7;
  _BOOL4 v11;
  uint64_t v12;
  __int128 v13;
  std::string v14;

  v5 = *((_QWORD *)this + 1);
  if (*(char *)(v5 + 31) < 0)
  {
    std::string::__init_copy_ctor_external(&v14, *(const std::string::value_type **)(v5 + 8), *(_QWORD *)(v5 + 16));
  }
  else
  {
    v6 = *(_OWORD *)(v5 + 8);
    v14.__r_.__value_.__r.__words[2] = *(_QWORD *)(v5 + 24);
    *(_OWORD *)&v14.__r_.__value_.__l.__data_ = v6;
  }
  if ((SHIBYTE(v14.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if (SHIBYTE(v14.__r_.__value_.__r.__words[2]) != 21)
      goto LABEL_28;
    v7 = v14.__r_.__value_.__r.__words[0] == 0x6E6964726F636552
      && v14.__r_.__value_.__l.__size_ == 0x676E69646E655067;
    if (!v7 || *(std::string::size_type *)((char *)&v14.__r_.__value_.__r.__words[1] + 5) != 0x6574617453676E69)
      goto LABEL_28;
LABEL_26:
    std::string::basic_string[abi:ne180100]<0>((_QWORD *)a2, "RecordingState");
    goto LABEL_32;
  }
  if (v14.__r_.__value_.__l.__size_ == 21)
  {
    v11 = *(_QWORD *)v14.__r_.__value_.__l.__data_ != 0x6E6964726F636552
       || *(_QWORD *)(v14.__r_.__value_.__r.__words[0] + 8) != 0x676E69646E655067
       || *(_QWORD *)(v14.__r_.__value_.__r.__words[0] + 13) != 0x6574617453676E69;
    operator delete(v14.__r_.__value_.__l.__data_);
    if (v11)
      goto LABEL_28;
    goto LABEL_26;
  }
  operator delete(v14.__r_.__value_.__l.__data_);
LABEL_28:
  v12 = *((_QWORD *)this + 1);
  if (*(char *)(v12 + 31) < 0)
  {
    std::string::__init_copy_ctor_external(&v14, *(const std::string::value_type **)(v12 + 8), *(_QWORD *)(v12 + 16));
  }
  else
  {
    v13 = *(_OWORD *)(v12 + 8);
    v14.__r_.__value_.__r.__words[2] = *(_QWORD *)(v12 + 24);
    *(_OWORD *)&v14.__r_.__value_.__l.__data_ = v13;
  }
  *(std::string *)a2 = v14;
LABEL_32:
  *(_BYTE *)(a2 + 24) = 1;
}

double CLMiLoCustomLoiRecordingManager::DeviceNotReadyHandler@<D0>(uint64_t a1@<X0>, std::string *a2@<X8>)
{
  uint64_t v3;
  __int128 v4;
  double result;
  std::string v6;

  v3 = *(_QWORD *)(a1 + 8);
  if (*(char *)(v3 + 31) < 0)
  {
    std::string::__init_copy_ctor_external(&v6, *(const std::string::value_type **)(v3 + 8), *(_QWORD *)(v3 + 16));
  }
  else
  {
    v4 = *(_OWORD *)(v3 + 8);
    v6.__r_.__value_.__r.__words[2] = *(_QWORD *)(v3 + 24);
    *(_OWORD *)&v6.__r_.__value_.__l.__data_ = v4;
  }
  result = *(double *)&v6.__r_.__value_.__l.__data_;
  *a2 = v6;
  a2[1].__r_.__value_.__s.__data_[0] = 1;
  return result;
}

_QWORD *CLMiLoCustomLoiRecordingManager::RecordingComplete@<X0>(CLMiLoCustomLoiRecordingManager *this@<X0>, uint64_t a2@<X8>)
{
  NSObject *v5;
  int v6;
  unsigned int v7;
  void *v8;
  void *v9;
  void *v10;
  void *v11;
  unsigned int v12;
  unsigned int v13;
  char *v14;
  void *v15;
  _QWORD *result;
  _DWORD v17[2];
  __int16 v18;
  const char *v19;
  __int16 v20;
  int v21;
  uint64_t v22;

  v22 = *MEMORY[0x24BDAC8D0];
  ++*((_DWORD *)this + 44);
  if (onceToken_MicroLocation_Default != -1)
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_41);
  v5 = logObject_MicroLocation_Default;
  if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT))
  {
    v6 = *((_DWORD *)this + 44);
    v17[0] = 68289283;
    v17[1] = 0;
    v18 = 2082;
    v19 = "";
    v20 = 1025;
    v21 = v6;
    _os_log_impl(&dword_2419D9000, v5, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"#LoiRecordingManager: Completed Recordings\", \"Recordings completed\":%{private}u}", (uint8_t *)v17, 0x18u);
  }
  v7 = *((_DWORD *)this + 44);
  +[ULDefaultsSingleton shared](ULDefaultsSingleton, "shared");
  v8 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v8, "defaultsDictionary");
  v9 = (void *)objc_claimAutoreleasedReturnValue();

  objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "ULCustomLoiMaxRecordings");
  v10 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v9, "objectForKey:", v10);
  v11 = (void *)objc_claimAutoreleasedReturnValue();
  if (v11 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
    v12 = objc_msgSend(v11, "unsignedIntValue");
  else
    v12 = objc_msgSend(&unk_2511ED828, "unsignedIntValue");
  v13 = v12;

  if (v7 >= v13)
  {
    (*(void (**)(_QWORD))(**((_QWORD **)this + 23) + 24))(*((_QWORD *)this + 23));
    v15 = (void *)*((_QWORD *)this + 19);
    *((_QWORD *)this + 19) = CFSTR("maxRecordingsReached");

    v14 = "IdleState";
  }
  else
  {
    v14 = "RecordingThrottledState";
  }
  result = std::string::basic_string[abi:ne180100]<0>((_QWORD *)a2, v14);
  *(_BYTE *)(a2 + 24) = 1;
  return result;
}

void sub_241A51934(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

uint64_t CLMiLoCustomLoiRecordingManager::entryFunctionIdleState(uint64_t this)
{
  CLMiLoCustomLoiRecordingManager *v1;

  if (*(_QWORD *)(this + 40))
  {
    v1 = (CLMiLoCustomLoiRecordingManager *)this;
    *(CFAbsoluteTime *)(this + 168) = cl::chrono::CFAbsoluteTimeClock::now();
    CLMiLoCustomLoiRecordingManager::sendCoreAnalytics(v1);
    return CLMiLoCustomLoiRecordingManager::resetState(v1);
  }
  return this;
}

void CLMiLoCustomLoiRecordingManager::setupIdleState(CLMiLoCustomLoiRecordingManager *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  void *v5[2];
  char v6;
  void *__p[2];
  char v8;
  void **v9;

  v2 = operator new();
  CLMicroLocationStateMachine::StateBase::StateBase((CLMicroLocationStateMachine::StateBase *)v2, 0);
  MEMORY[0x2426A02C4](v2 + 8, "IdleState");
  *(_QWORD *)(v2 + 40) = (char *)this + 120;
  std::string::basic_string[abi:ne180100]<0>(__p, "StartRecordingSessionEvent");
  v9 = __p;
  *((_QWORD *)std::__tree<std::__value_type<std::string,CLMicroLocationStateMachine::EventHandlerWrapperBase *>,std::__map_value_compare<std::string,std::__value_type<std::string,CLMicroLocationStateMachine::EventHandlerWrapperBase *>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,CLMicroLocationStateMachine::EventHandlerWrapperBase *>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t **)(v2 + 48), (const void **)__p, (uint64_t)&std::piecewise_construct, (_OWORD **)&v9)+ 7) = (char *)this + 56;
  if (v8 < 0)
    operator delete(__p[0]);
  std::string::basic_string[abi:ne180100]<0>(v5, "IdleState");
  v4 = v2;
  CLMicroLocationStateMachine::StateMachineBase::addStateToStateMap((uint64_t)this, (__int128 *)v5, &v4);
  v3 = v4;
  v4 = 0;
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  if (v6 < 0)
    operator delete(v5[0]);
}

void sub_241A51AC0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  if (a10)
    (*(void (**)(uint64_t))(*(_QWORD *)a10 + 8))(a10);
  if (a16 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void CLMiLoCustomLoiRecordingManager::setupRecordingState(CLMiLoCustomLoiRecordingManager *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  void *v5[2];
  char v6;
  void *__p[2];
  char v8;
  void **v9;

  v2 = operator new();
  CLMicroLocationStateMachine::StateBase::StateBase((CLMicroLocationStateMachine::StateBase *)v2, 0);
  MEMORY[0x2426A02C4](v2 + 8, "RecordingState");
  *(_QWORD *)(v2 + 40) = (char *)this + 128;
  std::string::basic_string[abi:ne180100]<0>(__p, "StopRecordingSessionEvent");
  v9 = __p;
  *((_QWORD *)std::__tree<std::__value_type<std::string,CLMicroLocationStateMachine::EventHandlerWrapperBase *>,std::__map_value_compare<std::string,std::__value_type<std::string,CLMicroLocationStateMachine::EventHandlerWrapperBase *>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,CLMicroLocationStateMachine::EventHandlerWrapperBase *>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t **)(v2 + 48), (const void **)__p, (uint64_t)&std::piecewise_construct, (_OWORD **)&v9)+ 7) = (char *)this + 64;
  if (v8 < 0)
    operator delete(__p[0]);
  std::string::basic_string[abi:ne180100]<0>(__p, "MaxRecordingTimerFiredEvent");
  v9 = __p;
  *((_QWORD *)std::__tree<std::__value_type<std::string,CLMicroLocationStateMachine::EventHandlerWrapperBase *>,std::__map_value_compare<std::string,std::__value_type<std::string,CLMicroLocationStateMachine::EventHandlerWrapperBase *>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,CLMicroLocationStateMachine::EventHandlerWrapperBase *>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t **)(v2 + 48), (const void **)__p, (uint64_t)&std::piecewise_construct, (_OWORD **)&v9)+ 7) = (char *)this + 88;
  if (v8 < 0)
    operator delete(__p[0]);
  std::string::basic_string[abi:ne180100]<0>(__p, "RecordingFenceBreachedEvent");
  v9 = __p;
  *((_QWORD *)std::__tree<std::__value_type<std::string,CLMicroLocationStateMachine::EventHandlerWrapperBase *>,std::__map_value_compare<std::string,std::__value_type<std::string,CLMicroLocationStateMachine::EventHandlerWrapperBase *>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,CLMicroLocationStateMachine::EventHandlerWrapperBase *>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t **)(v2 + 48), (const void **)__p, (uint64_t)&std::piecewise_construct, (_OWORD **)&v9)+ 7) = (char *)this + 104;
  if (v8 < 0)
    operator delete(__p[0]);
  std::string::basic_string[abi:ne180100]<0>(__p, "RecordingCompletedEvent");
  v9 = __p;
  *((_QWORD *)std::__tree<std::__value_type<std::string,CLMicroLocationStateMachine::EventHandlerWrapperBase *>,std::__map_value_compare<std::string,std::__value_type<std::string,CLMicroLocationStateMachine::EventHandlerWrapperBase *>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,CLMicroLocationStateMachine::EventHandlerWrapperBase *>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t **)(v2 + 48), (const void **)__p, (uint64_t)&std::piecewise_construct, (_OWORD **)&v9)+ 7) = (char *)this + 112;
  if (v8 < 0)
    operator delete(__p[0]);
  std::string::basic_string[abi:ne180100]<0>(v5, "RecordingState");
  v4 = v2;
  CLMicroLocationStateMachine::StateMachineBase::addStateToStateMap((uint64_t)this, (__int128 *)v5, &v4);
  v3 = v4;
  v4 = 0;
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  if (v6 < 0)
    operator delete(v5[0]);
}

void sub_241A51D10(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  if (a10)
    (*(void (**)(uint64_t))(*(_QWORD *)a10 + 8))(a10);
  if (a16 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void CLMiLoCustomLoiRecordingManager::setupRecordingThrottledState(CLMiLoCustomLoiRecordingManager *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  void *v5[2];
  char v6;
  void *__p[2];
  char v8;
  void **v9;

  v2 = operator new();
  CLMicroLocationStateMachine::StateBase::StateBase((CLMicroLocationStateMachine::StateBase *)v2, 0);
  MEMORY[0x2426A02C4](v2 + 8, "RecordingThrottledState");
  *(_QWORD *)(v2 + 40) = (char *)this + 136;
  std::string::basic_string[abi:ne180100]<0>(__p, "StopRecordingSessionEvent");
  v9 = __p;
  *((_QWORD *)std::__tree<std::__value_type<std::string,CLMicroLocationStateMachine::EventHandlerWrapperBase *>,std::__map_value_compare<std::string,std::__value_type<std::string,CLMicroLocationStateMachine::EventHandlerWrapperBase *>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,CLMicroLocationStateMachine::EventHandlerWrapperBase *>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t **)(v2 + 48), (const void **)__p, (uint64_t)&std::piecewise_construct, (_OWORD **)&v9)+ 7) = (char *)this + 64;
  if (v8 < 0)
    operator delete(__p[0]);
  std::string::basic_string[abi:ne180100]<0>(__p, "MaxRecordingTimerFiredEvent");
  v9 = __p;
  *((_QWORD *)std::__tree<std::__value_type<std::string,CLMicroLocationStateMachine::EventHandlerWrapperBase *>,std::__map_value_compare<std::string,std::__value_type<std::string,CLMicroLocationStateMachine::EventHandlerWrapperBase *>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,CLMicroLocationStateMachine::EventHandlerWrapperBase *>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t **)(v2 + 48), (const void **)__p, (uint64_t)&std::piecewise_construct, (_OWORD **)&v9)+ 7) = (char *)this + 88;
  if (v8 < 0)
    operator delete(__p[0]);
  std::string::basic_string[abi:ne180100]<0>(__p, "ThrottleTimerFiredEvent");
  v9 = __p;
  *((_QWORD *)std::__tree<std::__value_type<std::string,CLMicroLocationStateMachine::EventHandlerWrapperBase *>,std::__map_value_compare<std::string,std::__value_type<std::string,CLMicroLocationStateMachine::EventHandlerWrapperBase *>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,CLMicroLocationStateMachine::EventHandlerWrapperBase *>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t **)(v2 + 48), (const void **)__p, (uint64_t)&std::piecewise_construct, (_OWORD **)&v9)+ 7) = (char *)this + 96;
  if (v8 < 0)
    operator delete(__p[0]);
  std::string::basic_string[abi:ne180100]<0>(__p, "RecordingFenceBreachedEvent");
  v9 = __p;
  *((_QWORD *)std::__tree<std::__value_type<std::string,CLMicroLocationStateMachine::EventHandlerWrapperBase *>,std::__map_value_compare<std::string,std::__value_type<std::string,CLMicroLocationStateMachine::EventHandlerWrapperBase *>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,CLMicroLocationStateMachine::EventHandlerWrapperBase *>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t **)(v2 + 48), (const void **)__p, (uint64_t)&std::piecewise_construct, (_OWORD **)&v9)+ 7) = (char *)this + 104;
  if (v8 < 0)
    operator delete(__p[0]);
  std::string::basic_string[abi:ne180100]<0>(v5, "RecordingThrottledState");
  v4 = v2;
  CLMicroLocationStateMachine::StateMachineBase::addStateToStateMap((uint64_t)this, (__int128 *)v5, &v4);
  v3 = v4;
  v4 = 0;
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  if (v6 < 0)
    operator delete(v5[0]);
}

void sub_241A51F6C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  if (a10)
    (*(void (**)(uint64_t))(*(_QWORD *)a10 + 8))(a10);
  if (a16 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void CLMiLoCustomLoiRecordingManager::setupRecordingPendingState(CLMiLoCustomLoiRecordingManager *this)
{
  uint64_t **v2;
  uint64_t v3;
  uint64_t **v4;
  void *v5[2];
  char v6;
  void *__p[2];
  char v8;
  void **v9;

  v2 = (uint64_t **)operator new();
  CLMicroLocationStateMachine::StateBase::StateBase((CLMicroLocationStateMachine::StateBase *)v2, 0);
  MEMORY[0x2426A02C4](v2 + 1, "RecordingPendingState");
  std::string::basic_string[abi:ne180100]<0>(__p, "StopRecordingSessionEvent");
  v9 = __p;
  *((_QWORD *)std::__tree<std::__value_type<std::string,CLMicroLocationStateMachine::EventHandlerWrapperBase *>,std::__map_value_compare<std::string,std::__value_type<std::string,CLMicroLocationStateMachine::EventHandlerWrapperBase *>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,CLMicroLocationStateMachine::EventHandlerWrapperBase *>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(v2 + 6, (const void **)__p, (uint64_t)&std::piecewise_construct, (_OWORD **)&v9)+ 7) = (char *)this + 64;
  if (v8 < 0)
    operator delete(__p[0]);
  std::string::basic_string[abi:ne180100]<0>(__p, "DeviceReadyEvent");
  v9 = __p;
  *((_QWORD *)std::__tree<std::__value_type<std::string,CLMicroLocationStateMachine::EventHandlerWrapperBase *>,std::__map_value_compare<std::string,std::__value_type<std::string,CLMicroLocationStateMachine::EventHandlerWrapperBase *>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,CLMicroLocationStateMachine::EventHandlerWrapperBase *>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(v2 + 6, (const void **)__p, (uint64_t)&std::piecewise_construct, (_OWORD **)&v9)+ 7) = (char *)this + 72;
  if (v8 < 0)
    operator delete(__p[0]);
  std::string::basic_string[abi:ne180100]<0>(__p, "MaxRecordingTimerFiredEvent");
  v9 = __p;
  *((_QWORD *)std::__tree<std::__value_type<std::string,CLMicroLocationStateMachine::EventHandlerWrapperBase *>,std::__map_value_compare<std::string,std::__value_type<std::string,CLMicroLocationStateMachine::EventHandlerWrapperBase *>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,CLMicroLocationStateMachine::EventHandlerWrapperBase *>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(v2 + 6, (const void **)__p, (uint64_t)&std::piecewise_construct, (_OWORD **)&v9)+ 7) = (char *)this + 88;
  if (v8 < 0)
    operator delete(__p[0]);
  std::string::basic_string[abi:ne180100]<0>(__p, "RecordingFenceBreachedEvent");
  v9 = __p;
  *((_QWORD *)std::__tree<std::__value_type<std::string,CLMicroLocationStateMachine::EventHandlerWrapperBase *>,std::__map_value_compare<std::string,std::__value_type<std::string,CLMicroLocationStateMachine::EventHandlerWrapperBase *>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,CLMicroLocationStateMachine::EventHandlerWrapperBase *>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(v2 + 6, (const void **)__p, (uint64_t)&std::piecewise_construct, (_OWORD **)&v9)+ 7) = (char *)this + 104;
  if (v8 < 0)
    operator delete(__p[0]);
  std::string::basic_string[abi:ne180100]<0>(v5, "RecordingPendingState");
  v4 = v2;
  CLMicroLocationStateMachine::StateMachineBase::addStateToStateMap((uint64_t)this, (__int128 *)v5, (uint64_t *)&v4);
  v3 = (uint64_t)v4;
  v4 = 0;
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  if (v6 < 0)
    operator delete(v5[0]);
}

void sub_241A521C0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  if (a10)
    (*(void (**)(uint64_t))(*(_QWORD *)a10 + 8))(a10);
  if (a16 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void CLMiLoCustomLoiRecordingManager::~CLMiLoCustomLoiRecordingManager(CLMiLoCustomLoiRecordingManager *this)
{
  unint64_t v2;
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;

  *(_QWORD *)this = &off_2511D4978;
  CLMiLoCustomLoiRecordingManager::resetState(this);

  CLMacAddress::newFromUint64((CLMacAddress *)this + 17, v2);
  CLMacAddress::newFromUint64((CLMacAddress *)this + 16, v3);
  CLMacAddress::newFromUint64((CLMacAddress *)this + 15, v4);
  CLMacAddress::newFromUint64((CLMacAddress *)this + 14, v5);
  CLMacAddress::newFromUint64((CLMacAddress *)this + 13, v6);
  CLMacAddress::newFromUint64((CLMacAddress *)this + 12, v7);
  CLMacAddress::newFromUint64((CLMacAddress *)this + 11, v8);
  CLMacAddress::newFromUint64((CLMacAddress *)this + 10, v9);
  CLMacAddress::newFromUint64((CLMacAddress *)this + 9, v10);
  CLMacAddress::newFromUint64((CLMacAddress *)this + 8, v11);
  CLMacAddress::newFromUint64((CLMacAddress *)this + 7, v12);
  CLMicroLocationStateMachine::StateMachineBase::~StateMachineBase(this);
}

{
  CLMiLoCustomLoiRecordingManager::~CLMiLoCustomLoiRecordingManager(this);
  JUMPOUT(0x2426A04D4);
}

uint64_t CLMiLoCustomLoiRecordingManager::resetState(CLMiLoCustomLoiRecordingManager *this)
{
  void *v2;
  void *v3;

  *((_DWORD *)this + 44) = 0;
  objc_msgSend(*((id *)this + 25), "invalidate");
  v2 = (void *)*((_QWORD *)this + 25);
  *((_QWORD *)this + 25) = 0;

  objc_msgSend(*((id *)this + 24), "invalidate");
  v3 = (void *)*((_QWORD *)this + 24);
  *((_QWORD *)this + 24) = 0;

  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 23) + 16))(*((_QWORD *)this + 23));
}

void CLMiLoCustomLoiRecordingManager::startRecordingSession(CLMiLoCustomLoiRecordingManager *this)
{
  _QWORD v2[3];
  char v3;

  CLMiLoStartRecordingSessionEvent::CLMiLoStartRecordingSessionEvent((CLMiLoStartRecordingSessionEvent *)v2);
  CLMicroLocationStateMachine::StateMachineBase::handleEvent(this, (CLMicroLocationStateMachine::EventBase *)v2);
  v2[0] = off_2511D4DA0;
  if (v3 < 0)
    operator delete((void *)v2[1]);
}

void sub_241A523D8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void CLMiLoStartRecordingSessionEvent::~CLMiLoStartRecordingSessionEvent(void **this)
{
  *this = off_2511D4DA0;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = off_2511D4DA0;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x2426A04D4);
}

void CLMiLoCustomLoiRecordingManager::stopRecordingSession(CLMiLoCustomLoiRecordingManager *this)
{
  _QWORD v2[3];
  char v3;

  CLMiLoStopRecordingSessionEvent::CLMiLoStopRecordingSessionEvent((CLMiLoStopRecordingSessionEvent *)v2);
  CLMicroLocationStateMachine::StateMachineBase::handleEvent(this, (CLMicroLocationStateMachine::EventBase *)v2);
  v2[0] = off_2511D4DA0;
  if (v3 < 0)
    operator delete((void *)v2[1]);
}

void sub_241A52490(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void CLMiLoStopRecordingSessionEvent::~CLMiLoStopRecordingSessionEvent(void **this)
{
  *this = off_2511D4DA0;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = off_2511D4DA0;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x2426A04D4);
}

void CLMiLoCustomLoiRecordingManager::recordingCompleted(CLMiLoCustomLoiRecordingManager *this)
{
  _QWORD v2[3];
  char v3;

  CLMiLoRecordingCompletedEvent::CLMiLoRecordingCompletedEvent((CLMiLoRecordingCompletedEvent *)v2);
  CLMicroLocationStateMachine::StateMachineBase::handleEvent(this, (CLMicroLocationStateMachine::EventBase *)v2);
  v2[0] = off_2511D4DA0;
  if (v3 < 0)
    operator delete((void *)v2[1]);
}

void sub_241A52548(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void CLMiLoRecordingCompletedEvent::~CLMiLoRecordingCompletedEvent(void **this)
{
  *this = off_2511D4DA0;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = off_2511D4DA0;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x2426A04D4);
}

void CLMiLoCustomLoiRecordingManager::recordingFenceBreached(CLMiLoCustomLoiRecordingManager *this)
{
  _QWORD v2[3];
  char v3;

  CLMiLoRecordingFenceBreachedEvent::CLMiLoRecordingFenceBreachedEvent((CLMiLoRecordingFenceBreachedEvent *)v2);
  CLMicroLocationStateMachine::StateMachineBase::handleEvent(this, (CLMicroLocationStateMachine::EventBase *)v2);
  v2[0] = off_2511D4DA0;
  if (v3 < 0)
    operator delete((void *)v2[1]);
}

void sub_241A52600(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void CLMiLoRecordingFenceBreachedEvent::~CLMiLoRecordingFenceBreachedEvent(void **this)
{
  *this = off_2511D4DA0;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = off_2511D4DA0;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x2426A04D4);
}

void CLMiLoCustomLoiRecordingManager::deviceScreenState(CLMiLoCustomLoiRecordingManager *this, char a2)
{
  *((_BYTE *)this + 144) = a2;
  CLMiLoCustomLoiRecordingManager::generateDeviceStateEvent(this);
}

void CLMiLoCustomLoiRecordingManager::generateDeviceStateEvent(CLMiLoCustomLoiRecordingManager *this)
{
  _QWORD v2[3];
  char v3;

  if (*((_BYTE *)this + 144))
    CLMiLoDeviceReadyEvent::CLMiLoDeviceReadyEvent((CLMiLoDeviceReadyEvent *)v2);
  else
    CLMiLoDeviceNotReadyEvent::CLMiLoDeviceNotReadyEvent((CLMiLoDeviceNotReadyEvent *)v2);
  CLMicroLocationStateMachine::StateMachineBase::handleEvent(this, (CLMicroLocationStateMachine::EventBase *)v2);
  v2[0] = off_2511D4DA0;
  if (v3 < 0)
    operator delete((void *)v2[1]);
}

void sub_241A526E0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void CLMiLoCustomLoiRecordingManager::deviceStaticState(CLMiLoCustomLoiRecordingManager *this, char a2)
{
  *((_BYTE *)this + 145) = a2;
  CLMiLoCustomLoiRecordingManager::generateDeviceStateEvent(this);
}

void CLMiLoCustomLoiRecordingManager::startRecordingTimer(id *this)
{
  id v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  double v7;
  double v8;
  uint64_t v9;
  id v10;
  _QWORD v11[5];

  objc_msgSend(this[24], "invalidate");
  v2 = this[24];
  this[24] = 0;

  +[ULDefaultsSingleton shared](ULDefaultsSingleton, "shared");
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v3, "defaultsDictionary");
  v4 = (void *)objc_claimAutoreleasedReturnValue();

  objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "ULCustomLoiMaxRecordingWindow");
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v4, "objectForKey:", v5);
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  if (v6 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
    objc_msgSend(v6, "doubleValue");
  else
    objc_msgSend(&unk_2511ECDD8, "doubleValue");
  v8 = v7;

  v11[0] = MEMORY[0x24BDAC760];
  v11[1] = 3221225472;
  v11[2] = ___ZN31CLMiLoCustomLoiRecordingManager19startRecordingTimerEv_block_invoke;
  v11[3] = &__block_descriptor_40_e5_v8__0l;
  v11[4] = this;
  +[ULTimerFactory timerOnPrimaryQueueWithInterval:repeats:block:](ULTimerFactory, "timerOnPrimaryQueueWithInterval:repeats:block:", 0, v11, v8);
  v9 = objc_claimAutoreleasedReturnValue();
  v10 = this[24];
  this[24] = (id)v9;

}

void sub_241A5285C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void ___ZN31CLMiLoCustomLoiRecordingManager19startRecordingTimerEv_block_invoke(uint64_t a1)
{
  id *v1;
  id v2;
  _QWORD v3[3];
  char v4;

  v1 = *(id **)(a1 + 32);
  CLMiLoMaxRecordingTimerFiredEvent::CLMiLoMaxRecordingTimerFiredEvent((CLMiLoMaxRecordingTimerFiredEvent *)v3);
  CLMicroLocationStateMachine::StateMachineBase::handleEvent((CLMicroLocationStateMachine::StateMachineBase *)v1, (CLMicroLocationStateMachine::EventBase *)v3);
  objc_msgSend(v1[24], "invalidate");
  v2 = v1[24];
  v1[24] = 0;

  v3[0] = off_2511D4DA0;
  if (v4 < 0)
    operator delete((void *)v3[1]);
}

void sub_241A52900(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void CLMiLoMaxRecordingTimerFiredEvent::~CLMiLoMaxRecordingTimerFiredEvent(void **this)
{
  *this = off_2511D4DA0;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = off_2511D4DA0;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x2426A04D4);
}

void CLMiLoCustomLoiRecordingManager::startThrottleTimer(id *this)
{
  id v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  double v7;
  double v8;
  uint64_t v9;
  id v10;
  _QWORD v11[5];

  objc_msgSend(this[25], "invalidate");
  v2 = this[25];
  this[25] = 0;

  +[ULDefaultsSingleton shared](ULDefaultsSingleton, "shared");
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v3, "defaultsDictionary");
  v4 = (void *)objc_claimAutoreleasedReturnValue();

  objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "ULCustomLoiWaitBetweenRecordings");
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v4, "objectForKey:", v5);
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  if (v6 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
    objc_msgSend(v6, "doubleValue");
  else
    objc_msgSend(&unk_2511ECDE8, "doubleValue");
  v8 = v7;

  v11[0] = MEMORY[0x24BDAC760];
  v11[1] = 3221225472;
  v11[2] = ___ZN31CLMiLoCustomLoiRecordingManager18startThrottleTimerEv_block_invoke;
  v11[3] = &__block_descriptor_40_e5_v8__0l;
  v11[4] = this;
  +[ULTimerFactory timerOnPrimaryQueueWithInterval:repeats:block:](ULTimerFactory, "timerOnPrimaryQueueWithInterval:repeats:block:", 0, v11, v8);
  v9 = objc_claimAutoreleasedReturnValue();
  v10 = this[25];
  this[25] = (id)v9;

}

void sub_241A52AAC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void ___ZN31CLMiLoCustomLoiRecordingManager18startThrottleTimerEv_block_invoke(uint64_t a1)
{
  id *v1;
  id v2;
  _QWORD v3[3];
  char v4;

  v1 = *(id **)(a1 + 32);
  objc_msgSend(v1[25], "invalidate");
  v2 = v1[25];
  v1[25] = 0;

  CLMiLoThrottleTimerFiredEvent::CLMiLoThrottleTimerFiredEvent((CLMiLoThrottleTimerFiredEvent *)v3);
  CLMicroLocationStateMachine::StateMachineBase::handleEvent((CLMicroLocationStateMachine::StateMachineBase *)v1, (CLMicroLocationStateMachine::EventBase *)v3);
  v3[0] = off_2511D4DA0;
  if (v4 < 0)
    operator delete((void *)v3[1]);
}

void sub_241A52B50(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void CLMiLoThrottleTimerFiredEvent::~CLMiLoThrottleTimerFiredEvent(void **this)
{
  *this = off_2511D4DA0;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = off_2511D4DA0;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x2426A04D4);
}

void CLMiLoDeviceReadyEvent::~CLMiLoDeviceReadyEvent(void **this)
{
  *this = off_2511D4DA0;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = off_2511D4DA0;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x2426A04D4);
}

void CLMiLoDeviceNotReadyEvent::~CLMiLoDeviceNotReadyEvent(void **this)
{
  *this = off_2511D4DA0;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = off_2511D4DA0;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x2426A04D4);
}

void CLMiLoCustomLoiRecordingManager::sendCoreAnalytics(CLMiLoCustomLoiRecordingManager *this)
{
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  int v6;
  int v7;
  double v8;
  void *v9;
  void *v10;
  uint64_t v11;
  void *v12;
  NSObject *v13;
  NSObject *v14;
  _DWORD v15[2];
  __int16 v16;
  const char *v17;
  __int16 v18;
  uint64_t v19;
  __int16 v20;
  void *v21;
  _QWORD v22[4];
  _QWORD v23[5];

  v23[4] = *MEMORY[0x24BDAC8D0];
  +[ULDefaultsSingleton shared](ULDefaultsSingleton, "shared");
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v2, "defaultsDictionary");
  v3 = (void *)objc_claimAutoreleasedReturnValue();

  objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "ULAnalyticsSendEventEnabled");
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v3, "objectForKey:", v4);
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  if (v5 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
    v6 = objc_msgSend(v5, "BOOLValue");
  else
    v6 = objc_msgSend(MEMORY[0x24BDBD1C8], "BOOLValue");
  v7 = v6;

  if (v7)
  {
    v8 = *((double *)this + 21) - *((double *)this + 20);
    v23[0] = &unk_2511ED810;
    v22[0] = CFSTR("recordingSessionOccurred");
    v22[1] = CFSTR("recordingSessionDuration");
    objc_msgSend(MEMORY[0x24BDD16E0], "numberWithDouble:", v8);
    v9 = (void *)objc_claimAutoreleasedReturnValue();
    v23[1] = v9;
    v22[2] = CFSTR("numberOfCompletedRecordings");
    objc_msgSend(MEMORY[0x24BDD16E0], "numberWithUnsignedInt:", *((unsigned int *)this + 44));
    v10 = (void *)objc_claimAutoreleasedReturnValue();
    v22[3] = CFSTR("recordingSessionEndingReason");
    v11 = *((_QWORD *)this + 19);
    v23[2] = v10;
    v23[3] = v11;
    objc_msgSend(MEMORY[0x24BDBCE70], "dictionaryWithObjects:forKeys:count:", v23, v22, 4);
    v12 = (void *)objc_claimAutoreleasedReturnValue();

    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_41);
    v13 = (id)logObject_MicroLocation_Default;
    if (os_log_type_enabled(v13, OS_LOG_TYPE_INFO))
    {
      v15[0] = 68289539;
      v15[1] = 0;
      v16 = 2082;
      v17 = "";
      v18 = 2081;
      v19 = objc_msgSend(CFSTR("com.apple.MicroLocation.CustomLoiRecordingSession"), "UTF8String");
      v20 = 2113;
      v21 = v12;
      _os_log_impl(&dword_2419D9000, v13, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"#LoiRecordingManager, sending core analytics\", \"event\":%{private, location:escape_only}s, \"eventFields\":%{private, location:escape_only}@}", (uint8_t *)v15, 0x26u);
    }

    +[ULSendEvent sendEvent:withEventName:](ULSendEvent, "sendEvent:withEventName:", v12, CFSTR("com.apple.MicroLocation.CustomLoiRecordingSession"));
  }
  else
  {
    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_41);
    v14 = logObject_MicroLocation_Default;
    if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v15[0]) = 0;
      _os_log_impl(&dword_2419D9000, v14, OS_LOG_TYPE_DEFAULT, "#MiLoLearner, CoreAnalytics Disabled", (uint8_t *)v15, 2u);
    }
  }
}

void sub_241A52F04(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

_QWORD *CLMicroLocationStateMachine::EventHandlerWrapper<CLMiLoCustomLoiRecordingManager,CLMiLoStartRecordingSessionEvent,&CLMiLoCustomLoiRecordingManager::StartRecordingSession>::stateFunction@<X0>(void *lpsrc@<X2>, CFAbsoluteTime *a2@<X1>, uint64_t a3@<X8>)
{
  _QWORD *result;
  CFAbsoluteTime *v7;
  NSObject *v8;
  uint64_t v9;
  __int128 v10;
  int v11;
  std::string::size_type v12;
  std::string *v13;
  std::string *p_p;
  NSObject *v15;
  uint64_t v16;
  __int128 v17;
  int v18;
  std::string::size_type v19;
  std::string *v20;
  std::string *v21;
  NSObject *v22;
  uint64_t v23;
  __int128 v24;
  int v25;
  std::string::size_type v26;
  std::string *v27;
  std::string *v28;
  CLMicroLocationStateMachine::EventBase *v29;
  std::string __p;
  std::string v31;
  uint8_t buf[4];
  int v33;
  __int16 v34;
  const char *v35;
  __int16 v36;
  std::string *v37;
  __int16 v38;
  std::string *v39;
  __int16 v40;
  const char *v41;
  __int16 v42;
  const char *v43;
  uint64_t v44;

  v44 = *MEMORY[0x24BDAC8D0];
  if (lpsrc
  {
    return CLMiLoCustomLoiRecordingManager::StartRecordingSession(a2, a3);
  }
  v7 = a2;
  v29 = (CLMicroLocationStateMachine::EventBase *)lpsrc;
  _CLLogObjectForCategory_MicroLocation_Default();
  v8 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v8, OS_LOG_TYPE_FAULT))
  {
    v9 = *((_QWORD *)v7 + 1);
    if (*(char *)(v9 + 31) < 0)
    {
      std::string::__init_copy_ctor_external(&v31, *(const std::string::value_type **)(v9 + 8), *(_QWORD *)(v9 + 16));
    }
    else
    {
      v10 = *(_OWORD *)(v9 + 8);
      v31.__r_.__value_.__r.__words[2] = *(_QWORD *)(v9 + 24);
      *(_OWORD *)&v31.__r_.__value_.__l.__data_ = v10;
    }
    v11 = SHIBYTE(v31.__r_.__value_.__r.__words[2]);
    v12 = v31.__r_.__value_.__r.__words[0];
    CLMicroLocationStateMachine::EventBase::getEventName((CLMicroLocationStateMachine::EventBase *)lpsrc, &__p);
    v13 = &v31;
    if (v11 < 0)
      v13 = (std::string *)v12;
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      p_p = &__p;
    else
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    *(_DWORD *)buf = 68290051;
    v33 = 0;
    v34 = 2082;
    v35 = "";
    v36 = 2081;
    v37 = v13;
    v38 = 2081;
    v39 = p_p;
    v40 = 2082;
    v41 = "assert";
    v42 = 2081;
    v43 = "derivedEventData != __null";
    _os_log_impl(&dword_2419D9000, v8, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p.__r_.__value_.__l.__data_);
    if (SHIBYTE(v31.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v31.__r_.__value_.__l.__data_);
  }

  _CLLogObjectForCategory_MicroLocation_Default();
  v15 = objc_claimAutoreleasedReturnValue();
  if (os_signpost_enabled(v15))
  {
    v16 = *((_QWORD *)v7 + 1);
    if (*(char *)(v16 + 31) < 0)
    {
      std::string::__init_copy_ctor_external(&v31, *(const std::string::value_type **)(v16 + 8), *(_QWORD *)(v16 + 16));
    }
    else
    {
      v17 = *(_OWORD *)(v16 + 8);
      v31.__r_.__value_.__r.__words[2] = *(_QWORD *)(v16 + 24);
      *(_OWORD *)&v31.__r_.__value_.__l.__data_ = v17;
    }
    v18 = SHIBYTE(v31.__r_.__value_.__r.__words[2]);
    v19 = v31.__r_.__value_.__r.__words[0];
    CLMicroLocationStateMachine::EventBase::getEventName((CLMicroLocationStateMachine::EventBase *)lpsrc, &__p);
    v20 = &v31;
    if (v18 < 0)
      v20 = (std::string *)v19;
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v21 = &__p;
    else
      v21 = (std::string *)__p.__r_.__value_.__r.__words[0];
    *(_DWORD *)buf = 68290051;
    v33 = 0;
    v34 = 2082;
    v35 = "";
    v36 = 2081;
    v37 = v20;
    v38 = 2081;
    v39 = v21;
    v40 = 2082;
    v41 = "assert";
    v42 = 2081;
    v43 = "derivedEventData != __null";
    _os_signpost_emit_with_name_impl(&dword_2419D9000, v15, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Received unsupported event in state event handler", "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p.__r_.__value_.__l.__data_);
    if (SHIBYTE(v31.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v31.__r_.__value_.__l.__data_);
  }

  _CLLogObjectForCategory_MicroLocation_Default();
  v22 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v22, OS_LOG_TYPE_INFO))
  {
    v23 = *((_QWORD *)v7 + 1);
    if (*(char *)(v23 + 31) < 0)
    {
      std::string::__init_copy_ctor_external(&v31, *(const std::string::value_type **)(v23 + 8), *(_QWORD *)(v23 + 16));
    }
    else
    {
      v24 = *(_OWORD *)(v23 + 8);
      v31.__r_.__value_.__r.__words[2] = *(_QWORD *)(v23 + 24);
      *(_OWORD *)&v31.__r_.__value_.__l.__data_ = v24;
    }
    v25 = SHIBYTE(v31.__r_.__value_.__r.__words[2]);
    v26 = v31.__r_.__value_.__r.__words[0];
    CLMicroLocationStateMachine::EventBase::getEventName(v29, &__p);
    v27 = &v31;
    if (v25 < 0)
      v27 = (std::string *)v26;
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v28 = &__p;
    else
      v28 = (std::string *)__p.__r_.__value_.__r.__words[0];
    *(_DWORD *)buf = 68290051;
    v33 = 0;
    v34 = 2082;
    v35 = "";
    v36 = 2081;
    v37 = v27;
    v38 = 2081;
    v39 = v28;
    v40 = 2082;
    v41 = "assert";
    v42 = 2081;
    v43 = "derivedEventData != __null";
    _os_log_impl(&dword_2419D9000, v22, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p.__r_.__value_.__l.__data_);
    if (SHIBYTE(v31.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v31.__r_.__value_.__l.__data_);
  }

  result = (_QWORD *)abort_report_np();
  __break(1u);
  return result;
}

void sub_241A533D8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  void *v22;

  _Unwind_Resume(a1);
}

void CLMicroLocationStateMachine::EventHandlerWrapper<CLMiLoCustomLoiRecordingManager,CLMiLoStartRecordingSessionEvent,&CLMiLoCustomLoiRecordingManager::StartRecordingSession>::~EventHandlerWrapper(CLMacAddress *a1, unint64_t a2)
{
  CLMacAddress::newFromUint64(a1, a2);
  JUMPOUT(0x2426A04D4);
}

uint64_t CLMicroLocationStateMachine::EventHandlerWrapper<CLMiLoCustomLoiRecordingManager,CLMiLoStopRecordingSessionEvent,&CLMiLoCustomLoiRecordingManager::StopRecordingSession>::stateFunction@<X0>(CLMicroLocationStateMachine::EventBase *lpsrc@<X2>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  void *v6;
  uint64_t result;
  NSObject *v8;
  uint64_t v9;
  __int128 v10;
  int v11;
  std::string::size_type v12;
  std::string *v13;
  std::string *p_p;
  NSObject *v15;
  uint64_t v16;
  __int128 v17;
  int v18;
  std::string::size_type v19;
  std::string *v20;
  std::string *v21;
  NSObject *v22;
  uint64_t v23;
  __int128 v24;
  int v25;
  std::string::size_type v26;
  std::string *v27;
  std::string *v28;
  CLMicroLocationStateMachine::EventBase *v29;
  std::string __p;
  std::string v31;
  uint8_t buf[4];
  int v33;
  __int16 v34;
  const char *v35;
  __int16 v36;
  std::string *v37;
  __int16 v38;
  std::string *v39;
  __int16 v40;
  const char *v41;
  __int16 v42;
  const char *v43;
  uint64_t v44;

  v44 = *MEMORY[0x24BDAC8D0];
  if (lpsrc
  {
    (*(void (**)(_QWORD))(**(_QWORD **)(a2 + 184) + 24))(*(_QWORD *)(a2 + 184));
    v6 = *(void **)(a2 + 152);
    *(_QWORD *)(a2 + 152) = CFSTR("recordingSessionStopped");

    result = (uint64_t)std::string::basic_string[abi:ne180100]<0>((_QWORD *)a3, "IdleState");
    *(_BYTE *)(a3 + 24) = 1;
  }
  else
  {
    v29 = lpsrc;
    _CLLogObjectForCategory_MicroLocation_Default();
    v8 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_FAULT))
    {
      v9 = *(_QWORD *)(a2 + 8);
      if (*(char *)(v9 + 31) < 0)
      {
        std::string::__init_copy_ctor_external(&v31, *(const std::string::value_type **)(v9 + 8), *(_QWORD *)(v9 + 16));
      }
      else
      {
        v10 = *(_OWORD *)(v9 + 8);
        v31.__r_.__value_.__r.__words[2] = *(_QWORD *)(v9 + 24);
        *(_OWORD *)&v31.__r_.__value_.__l.__data_ = v10;
      }
      v11 = SHIBYTE(v31.__r_.__value_.__r.__words[2]);
      v12 = v31.__r_.__value_.__r.__words[0];
      CLMicroLocationStateMachine::EventBase::getEventName(lpsrc, &__p);
      v13 = &v31;
      if (v11 < 0)
        v13 = (std::string *)v12;
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        p_p = &__p;
      else
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      *(_DWORD *)buf = 68290051;
      v33 = 0;
      v34 = 2082;
      v35 = "";
      v36 = 2081;
      v37 = v13;
      v38 = 2081;
      v39 = p_p;
      v40 = 2082;
      v41 = "assert";
      v42 = 2081;
      v43 = "derivedEventData != __null";
      _os_log_impl(&dword_2419D9000, v8, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__p.__r_.__value_.__l.__data_);
      if (SHIBYTE(v31.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v31.__r_.__value_.__l.__data_);
    }

    _CLLogObjectForCategory_MicroLocation_Default();
    v15 = objc_claimAutoreleasedReturnValue();
    if (os_signpost_enabled(v15))
    {
      v16 = *(_QWORD *)(a2 + 8);
      if (*(char *)(v16 + 31) < 0)
      {
        std::string::__init_copy_ctor_external(&v31, *(const std::string::value_type **)(v16 + 8), *(_QWORD *)(v16 + 16));
      }
      else
      {
        v17 = *(_OWORD *)(v16 + 8);
        v31.__r_.__value_.__r.__words[2] = *(_QWORD *)(v16 + 24);
        *(_OWORD *)&v31.__r_.__value_.__l.__data_ = v17;
      }
      v18 = SHIBYTE(v31.__r_.__value_.__r.__words[2]);
      v19 = v31.__r_.__value_.__r.__words[0];
      CLMicroLocationStateMachine::EventBase::getEventName(lpsrc, &__p);
      v20 = &v31;
      if (v18 < 0)
        v20 = (std::string *)v19;
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v21 = &__p;
      else
        v21 = (std::string *)__p.__r_.__value_.__r.__words[0];
      *(_DWORD *)buf = 68290051;
      v33 = 0;
      v34 = 2082;
      v35 = "";
      v36 = 2081;
      v37 = v20;
      v38 = 2081;
      v39 = v21;
      v40 = 2082;
      v41 = "assert";
      v42 = 2081;
      v43 = "derivedEventData != __null";
      _os_signpost_emit_with_name_impl(&dword_2419D9000, v15, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Received unsupported event in state event handler", "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__p.__r_.__value_.__l.__data_);
      if (SHIBYTE(v31.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v31.__r_.__value_.__l.__data_);
    }

    _CLLogObjectForCategory_MicroLocation_Default();
    v22 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v22, OS_LOG_TYPE_INFO))
    {
      v23 = *(_QWORD *)(a2 + 8);
      if (*(char *)(v23 + 31) < 0)
      {
        std::string::__init_copy_ctor_external(&v31, *(const std::string::value_type **)(v23 + 8), *(_QWORD *)(v23 + 16));
      }
      else
      {
        v24 = *(_OWORD *)(v23 + 8);
        v31.__r_.__value_.__r.__words[2] = *(_QWORD *)(v23 + 24);
        *(_OWORD *)&v31.__r_.__value_.__l.__data_ = v24;
      }
      v25 = SHIBYTE(v31.__r_.__value_.__r.__words[2]);
      v26 = v31.__r_.__value_.__r.__words[0];
      CLMicroLocationStateMachine::EventBase::getEventName(v29, &__p);
      v27 = &v31;
      if (v25 < 0)
        v27 = (std::string *)v26;
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v28 = &__p;
      else
        v28 = (std::string *)__p.__r_.__value_.__r.__words[0];
      *(_DWORD *)buf = 68290051;
      v33 = 0;
      v34 = 2082;
      v35 = "";
      v36 = 2081;
      v37 = v27;
      v38 = 2081;
      v39 = v28;
      v40 = 2082;
      v41 = "assert";
      v42 = 2081;
      v43 = "derivedEventData != __null";
      _os_log_impl(&dword_2419D9000, v22, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__p.__r_.__value_.__l.__data_);
      if (SHIBYTE(v31.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v31.__r_.__value_.__l.__data_);
    }

    result = abort_report_np();
    __break(1u);
  }
  return result;
}

void sub_241A5388C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  void *v22;

  _Unwind_Resume(a1);
}

void CLMicroLocationStateMachine::EventHandlerWrapper<CLMiLoCustomLoiRecordingManager,CLMiLoStopRecordingSessionEvent,&CLMiLoCustomLoiRecordingManager::StopRecordingSession>::~EventHandlerWrapper(CLMacAddress *a1, unint64_t a2)
{
  CLMacAddress::newFromUint64(a1, a2);
  JUMPOUT(0x2426A04D4);
}

void CLMicroLocationStateMachine::EventHandlerWrapper<CLMiLoCustomLoiRecordingManager,CLMiLoDeviceReadyEvent,&CLMiLoCustomLoiRecordingManager::DeviceReadyHandler>::stateFunction(CLMicroLocationStateMachine::EventBase *lpsrc@<X2>, CLMiLoCustomLoiRecordingManager *a2@<X1>, uint64_t a3@<X8>)
{
  CLMiLoCustomLoiRecordingManager *v6;
  NSObject *v7;
  uint64_t v8;
  __int128 v9;
  int v10;
  std::string::size_type v11;
  std::string *v12;
  std::string *p_p;
  NSObject *v14;
  uint64_t v15;
  __int128 v16;
  int v17;
  std::string::size_type v18;
  std::string *v19;
  std::string *v20;
  NSObject *v21;
  uint64_t v22;
  __int128 v23;
  int v24;
  std::string::size_type v25;
  std::string *v26;
  std::string *v27;
  CLMicroLocationStateMachine::EventBase *v28;
  std::string __p;
  std::string v30;
  uint8_t buf[4];
  int v32;
  __int16 v33;
  const char *v34;
  __int16 v35;
  std::string *v36;
  __int16 v37;
  std::string *v38;
  __int16 v39;
  const char *v40;
  __int16 v41;
  const char *v42;
  uint64_t v43;

  v43 = *MEMORY[0x24BDAC8D0];
  if (lpsrc
  {
    CLMiLoCustomLoiRecordingManager::DeviceReadyHandler(a2, a3);
  }
  else
  {
    v6 = a2;
    v28 = lpsrc;
    _CLLogObjectForCategory_MicroLocation_Default();
    v7 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_FAULT))
    {
      v8 = *((_QWORD *)v6 + 1);
      if (*(char *)(v8 + 31) < 0)
      {
        std::string::__init_copy_ctor_external(&v30, *(const std::string::value_type **)(v8 + 8), *(_QWORD *)(v8 + 16));
      }
      else
      {
        v9 = *(_OWORD *)(v8 + 8);
        v30.__r_.__value_.__r.__words[2] = *(_QWORD *)(v8 + 24);
        *(_OWORD *)&v30.__r_.__value_.__l.__data_ = v9;
      }
      v10 = SHIBYTE(v30.__r_.__value_.__r.__words[2]);
      v11 = v30.__r_.__value_.__r.__words[0];
      CLMicroLocationStateMachine::EventBase::getEventName(lpsrc, &__p);
      v12 = &v30;
      if (v10 < 0)
        v12 = (std::string *)v11;
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        p_p = &__p;
      else
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      *(_DWORD *)buf = 68290051;
      v32 = 0;
      v33 = 2082;
      v34 = "";
      v35 = 2081;
      v36 = v12;
      v37 = 2081;
      v38 = p_p;
      v39 = 2082;
      v40 = "assert";
      v41 = 2081;
      v42 = "derivedEventData != __null";
      _os_log_impl(&dword_2419D9000, v7, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__p.__r_.__value_.__l.__data_);
      if (SHIBYTE(v30.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v30.__r_.__value_.__l.__data_);
    }

    _CLLogObjectForCategory_MicroLocation_Default();
    v14 = objc_claimAutoreleasedReturnValue();
    if (os_signpost_enabled(v14))
    {
      v15 = *((_QWORD *)v6 + 1);
      if (*(char *)(v15 + 31) < 0)
      {
        std::string::__init_copy_ctor_external(&v30, *(const std::string::value_type **)(v15 + 8), *(_QWORD *)(v15 + 16));
      }
      else
      {
        v16 = *(_OWORD *)(v15 + 8);
        v30.__r_.__value_.__r.__words[2] = *(_QWORD *)(v15 + 24);
        *(_OWORD *)&v30.__r_.__value_.__l.__data_ = v16;
      }
      v17 = SHIBYTE(v30.__r_.__value_.__r.__words[2]);
      v18 = v30.__r_.__value_.__r.__words[0];
      CLMicroLocationStateMachine::EventBase::getEventName(lpsrc, &__p);
      v19 = &v30;
      if (v17 < 0)
        v19 = (std::string *)v18;
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v20 = &__p;
      else
        v20 = (std::string *)__p.__r_.__value_.__r.__words[0];
      *(_DWORD *)buf = 68290051;
      v32 = 0;
      v33 = 2082;
      v34 = "";
      v35 = 2081;
      v36 = v19;
      v37 = 2081;
      v38 = v20;
      v39 = 2082;
      v40 = "assert";
      v41 = 2081;
      v42 = "derivedEventData != __null";
      _os_signpost_emit_with_name_impl(&dword_2419D9000, v14, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Received unsupported event in state event handler", "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__p.__r_.__value_.__l.__data_);
      if (SHIBYTE(v30.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v30.__r_.__value_.__l.__data_);
    }

    _CLLogObjectForCategory_MicroLocation_Default();
    v21 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v21, OS_LOG_TYPE_INFO))
    {
      v22 = *((_QWORD *)v6 + 1);
      if (*(char *)(v22 + 31) < 0)
      {
        std::string::__init_copy_ctor_external(&v30, *(const std::string::value_type **)(v22 + 8), *(_QWORD *)(v22 + 16));
      }
      else
      {
        v23 = *(_OWORD *)(v22 + 8);
        v30.__r_.__value_.__r.__words[2] = *(_QWORD *)(v22 + 24);
        *(_OWORD *)&v30.__r_.__value_.__l.__data_ = v23;
      }
      v24 = SHIBYTE(v30.__r_.__value_.__r.__words[2]);
      v25 = v30.__r_.__value_.__r.__words[0];
      CLMicroLocationStateMachine::EventBase::getEventName(v28, &__p);
      v26 = &v30;
      if (v24 < 0)
        v26 = (std::string *)v25;
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v27 = &__p;
      else
        v27 = (std::string *)__p.__r_.__value_.__r.__words[0];
      *(_DWORD *)buf = 68290051;
      v32 = 0;
      v33 = 2082;
      v34 = "";
      v35 = 2081;
      v36 = v26;
      v37 = 2081;
      v38 = v27;
      v39 = 2082;
      v40 = "assert";
      v41 = 2081;
      v42 = "derivedEventData != __null";
      _os_log_impl(&dword_2419D9000, v21, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__p.__r_.__value_.__l.__data_);
      if (SHIBYTE(v30.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v30.__r_.__value_.__l.__data_);
    }

    abort_report_np();
    __break(1u);
  }
}

void sub_241A53D10(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  void *v22;

  _Unwind_Resume(a1);
}

void CLMicroLocationStateMachine::EventHandlerWrapper<CLMiLoCustomLoiRecordingManager,CLMiLoDeviceReadyEvent,&CLMiLoCustomLoiRecordingManager::DeviceReadyHandler>::~EventHandlerWrapper(CLMacAddress *a1, unint64_t a2)
{
  CLMacAddress::newFromUint64(a1, a2);
  JUMPOUT(0x2426A04D4);
}

void CLMicroLocationStateMachine::EventHandlerWrapper<CLMiLoCustomLoiRecordingManager,CLMiLoDeviceNotReadyEvent,&CLMiLoCustomLoiRecordingManager::DeviceNotReadyHandler>::stateFunction(CLMicroLocationStateMachine::EventBase *lpsrc@<X2>, uint64_t a2@<X1>, std::string *a3@<X8>)
{
  uint64_t v6;
  NSObject *v7;
  uint64_t v8;
  __int128 v9;
  int v10;
  std::string::size_type v11;
  std::string *v12;
  std::string *p_p;
  NSObject *v14;
  uint64_t v15;
  __int128 v16;
  int v17;
  std::string::size_type v18;
  std::string *v19;
  std::string *v20;
  NSObject *v21;
  uint64_t v22;
  __int128 v23;
  int v24;
  std::string::size_type v25;
  std::string *v26;
  std::string *v27;
  CLMicroLocationStateMachine::EventBase *v28;
  std::string __p;
  std::string v30;
  uint8_t buf[4];
  int v32;
  __int16 v33;
  const char *v34;
  __int16 v35;
  std::string *v36;
  __int16 v37;
  std::string *v38;
  __int16 v39;
  const char *v40;
  __int16 v41;
  const char *v42;
  uint64_t v43;

  v43 = *MEMORY[0x24BDAC8D0];
  if (lpsrc
  {
    CLMiLoCustomLoiRecordingManager::DeviceNotReadyHandler(a2, a3);
  }
  else
  {
    v6 = a2;
    v28 = lpsrc;
    _CLLogObjectForCategory_MicroLocation_Default();
    v7 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_FAULT))
    {
      v8 = *(_QWORD *)(v6 + 8);
      if (*(char *)(v8 + 31) < 0)
      {
        std::string::__init_copy_ctor_external(&v30, *(const std::string::value_type **)(v8 + 8), *(_QWORD *)(v8 + 16));
      }
      else
      {
        v9 = *(_OWORD *)(v8 + 8);
        v30.__r_.__value_.__r.__words[2] = *(_QWORD *)(v8 + 24);
        *(_OWORD *)&v30.__r_.__value_.__l.__data_ = v9;
      }
      v10 = SHIBYTE(v30.__r_.__value_.__r.__words[2]);
      v11 = v30.__r_.__value_.__r.__words[0];
      CLMicroLocationStateMachine::EventBase::getEventName(lpsrc, &__p);
      v12 = &v30;
      if (v10 < 0)
        v12 = (std::string *)v11;
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        p_p = &__p;
      else
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      *(_DWORD *)buf = 68290051;
      v32 = 0;
      v33 = 2082;
      v34 = "";
      v35 = 2081;
      v36 = v12;
      v37 = 2081;
      v38 = p_p;
      v39 = 2082;
      v40 = "assert";
      v41 = 2081;
      v42 = "derivedEventData != __null";
      _os_log_impl(&dword_2419D9000, v7, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__p.__r_.__value_.__l.__data_);
      if (SHIBYTE(v30.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v30.__r_.__value_.__l.__data_);
    }

    _CLLogObjectForCategory_MicroLocation_Default();
    v14 = objc_claimAutoreleasedReturnValue();
    if (os_signpost_enabled(v14))
    {
      v15 = *(_QWORD *)(v6 + 8);
      if (*(char *)(v15 + 31) < 0)
      {
        std::string::__init_copy_ctor_external(&v30, *(const std::string::value_type **)(v15 + 8), *(_QWORD *)(v15 + 16));
      }
      else
      {
        v16 = *(_OWORD *)(v15 + 8);
        v30.__r_.__value_.__r.__words[2] = *(_QWORD *)(v15 + 24);
        *(_OWORD *)&v30.__r_.__value_.__l.__data_ = v16;
      }
      v17 = SHIBYTE(v30.__r_.__value_.__r.__words[2]);
      v18 = v30.__r_.__value_.__r.__words[0];
      CLMicroLocationStateMachine::EventBase::getEventName(lpsrc, &__p);
      v19 = &v30;
      if (v17 < 0)
        v19 = (std::string *)v18;
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v20 = &__p;
      else
        v20 = (std::string *)__p.__r_.__value_.__r.__words[0];
      *(_DWORD *)buf = 68290051;
      v32 = 0;
      v33 = 2082;
      v34 = "";
      v35 = 2081;
      v36 = v19;
      v37 = 2081;
      v38 = v20;
      v39 = 2082;
      v40 = "assert";
      v41 = 2081;
      v42 = "derivedEventData != __null";
      _os_signpost_emit_with_name_impl(&dword_2419D9000, v14, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Received unsupported event in state event handler", "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__p.__r_.__value_.__l.__data_);
      if (SHIBYTE(v30.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v30.__r_.__value_.__l.__data_);
    }

    _CLLogObjectForCategory_MicroLocation_Default();
    v21 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v21, OS_LOG_TYPE_INFO))
    {
      v22 = *(_QWORD *)(v6 + 8);
      if (*(char *)(v22 + 31) < 0)
      {
        std::string::__init_copy_ctor_external(&v30, *(const std::string::value_type **)(v22 + 8), *(_QWORD *)(v22 + 16));
      }
      else
      {
        v23 = *(_OWORD *)(v22 + 8);
        v30.__r_.__value_.__r.__words[2] = *(_QWORD *)(v22 + 24);
        *(_OWORD *)&v30.__r_.__value_.__l.__data_ = v23;
      }
      v24 = SHIBYTE(v30.__r_.__value_.__r.__words[2]);
      v25 = v30.__r_.__value_.__r.__words[0];
      CLMicroLocationStateMachine::EventBase::getEventName(v28, &__p);
      v26 = &v30;
      if (v24 < 0)
        v26 = (std::string *)v25;
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v27 = &__p;
      else
        v27 = (std::string *)__p.__r_.__value_.__r.__words[0];
      *(_DWORD *)buf = 68290051;
      v32 = 0;
      v33 = 2082;
      v34 = "";
      v35 = 2081;
      v36 = v26;
      v37 = 2081;
      v38 = v27;
      v39 = 2082;
      v40 = "assert";
      v41 = 2081;
      v42 = "derivedEventData != __null";
      _os_log_impl(&dword_2419D9000, v21, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__p.__r_.__value_.__l.__data_);
      if (SHIBYTE(v30.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v30.__r_.__value_.__l.__data_);
    }

    abort_report_np();
    __break(1u);
  }
}

void sub_241A54194(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  void *v22;

  _Unwind_Resume(a1);
}

void CLMicroLocationStateMachine::EventHandlerWrapper<CLMiLoCustomLoiRecordingManager,CLMiLoDeviceNotReadyEvent,&CLMiLoCustomLoiRecordingManager::DeviceNotReadyHandler>::~EventHandlerWrapper(CLMacAddress *a1, unint64_t a2)
{
  CLMacAddress::newFromUint64(a1, a2);
  JUMPOUT(0x2426A04D4);
}

uint64_t CLMicroLocationStateMachine::EventHandlerWrapper<CLMiLoCustomLoiRecordingManager,CLMiLoMaxRecordingTimerFiredEvent,&CLMiLoCustomLoiRecordingManager::MaxRecordingTimeReached>::stateFunction@<X0>(CLMicroLocationStateMachine::EventBase *lpsrc@<X2>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  void *v6;
  uint64_t result;
  NSObject *v8;
  uint64_t v9;
  __int128 v10;
  int v11;
  std::string::size_type v12;
  std::string *v13;
  std::string *p_p;
  NSObject *v15;
  uint64_t v16;
  __int128 v17;
  int v18;
  std::string::size_type v19;
  std::string *v20;
  std::string *v21;
  NSObject *v22;
  uint64_t v23;
  __int128 v24;
  int v25;
  std::string::size_type v26;
  std::string *v27;
  std::string *v28;
  CLMicroLocationStateMachine::EventBase *v29;
  std::string __p;
  std::string v31;
  uint8_t buf[4];
  int v33;
  __int16 v34;
  const char *v35;
  __int16 v36;
  std::string *v37;
  __int16 v38;
  std::string *v39;
  __int16 v40;
  const char *v41;
  __int16 v42;
  const char *v43;
  uint64_t v44;

  v44 = *MEMORY[0x24BDAC8D0];
  if (lpsrc
  {
    (*(void (**)(_QWORD))(**(_QWORD **)(a2 + 184) + 24))(*(_QWORD *)(a2 + 184));
    v6 = *(void **)(a2 + 152);
    *(_QWORD *)(a2 + 152) = CFSTR("recordingSessionTimeout");

    result = (uint64_t)std::string::basic_string[abi:ne180100]<0>((_QWORD *)a3, "IdleState");
    *(_BYTE *)(a3 + 24) = 1;
  }
  else
  {
    v29 = lpsrc;
    _CLLogObjectForCategory_MicroLocation_Default();
    v8 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_FAULT))
    {
      v9 = *(_QWORD *)(a2 + 8);
      if (*(char *)(v9 + 31) < 0)
      {
        std::string::__init_copy_ctor_external(&v31, *(const std::string::value_type **)(v9 + 8), *(_QWORD *)(v9 + 16));
      }
      else
      {
        v10 = *(_OWORD *)(v9 + 8);
        v31.__r_.__value_.__r.__words[2] = *(_QWORD *)(v9 + 24);
        *(_OWORD *)&v31.__r_.__value_.__l.__data_ = v10;
      }
      v11 = SHIBYTE(v31.__r_.__value_.__r.__words[2]);
      v12 = v31.__r_.__value_.__r.__words[0];
      CLMicroLocationStateMachine::EventBase::getEventName(lpsrc, &__p);
      v13 = &v31;
      if (v11 < 0)
        v13 = (std::string *)v12;
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        p_p = &__p;
      else
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      *(_DWORD *)buf = 68290051;
      v33 = 0;
      v34 = 2082;
      v35 = "";
      v36 = 2081;
      v37 = v13;
      v38 = 2081;
      v39 = p_p;
      v40 = 2082;
      v41 = "assert";
      v42 = 2081;
      v43 = "derivedEventData != __null";
      _os_log_impl(&dword_2419D9000, v8, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__p.__r_.__value_.__l.__data_);
      if (SHIBYTE(v31.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v31.__r_.__value_.__l.__data_);
    }

    _CLLogObjectForCategory_MicroLocation_Default();
    v15 = objc_claimAutoreleasedReturnValue();
    if (os_signpost_enabled(v15))
    {
      v16 = *(_QWORD *)(a2 + 8);
      if (*(char *)(v16 + 31) < 0)
      {
        std::string::__init_copy_ctor_external(&v31, *(const std::string::value_type **)(v16 + 8), *(_QWORD *)(v16 + 16));
      }
      else
      {
        v17 = *(_OWORD *)(v16 + 8);
        v31.__r_.__value_.__r.__words[2] = *(_QWORD *)(v16 + 24);
        *(_OWORD *)&v31.__r_.__value_.__l.__data_ = v17;
      }
      v18 = SHIBYTE(v31.__r_.__value_.__r.__words[2]);
      v19 = v31.__r_.__value_.__r.__words[0];
      CLMicroLocationStateMachine::EventBase::getEventName(lpsrc, &__p);
      v20 = &v31;
      if (v18 < 0)
        v20 = (std::string *)v19;
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v21 = &__p;
      else
        v21 = (std::string *)__p.__r_.__value_.__r.__words[0];
      *(_DWORD *)buf = 68290051;
      v33 = 0;
      v34 = 2082;
      v35 = "";
      v36 = 2081;
      v37 = v20;
      v38 = 2081;
      v39 = v21;
      v40 = 2082;
      v41 = "assert";
      v42 = 2081;
      v43 = "derivedEventData != __null";
      _os_signpost_emit_with_name_impl(&dword_2419D9000, v15, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Received unsupported event in state event handler", "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__p.__r_.__value_.__l.__data_);
      if (SHIBYTE(v31.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v31.__r_.__value_.__l.__data_);
    }

    _CLLogObjectForCategory_MicroLocation_Default();
    v22 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v22, OS_LOG_TYPE_INFO))
    {
      v23 = *(_QWORD *)(a2 + 8);
      if (*(char *)(v23 + 31) < 0)
      {
        std::string::__init_copy_ctor_external(&v31, *(const std::string::value_type **)(v23 + 8), *(_QWORD *)(v23 + 16));
      }
      else
      {
        v24 = *(_OWORD *)(v23 + 8);
        v31.__r_.__value_.__r.__words[2] = *(_QWORD *)(v23 + 24);
        *(_OWORD *)&v31.__r_.__value_.__l.__data_ = v24;
      }
      v25 = SHIBYTE(v31.__r_.__value_.__r.__words[2]);
      v26 = v31.__r_.__value_.__r.__words[0];
      CLMicroLocationStateMachine::EventBase::getEventName(v29, &__p);
      v27 = &v31;
      if (v25 < 0)
        v27 = (std::string *)v26;
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v28 = &__p;
      else
        v28 = (std::string *)__p.__r_.__value_.__r.__words[0];
      *(_DWORD *)buf = 68290051;
      v33 = 0;
      v34 = 2082;
      v35 = "";
      v36 = 2081;
      v37 = v27;
      v38 = 2081;
      v39 = v28;
      v40 = 2082;
      v41 = "assert";
      v42 = 2081;
      v43 = "derivedEventData != __null";
      _os_log_impl(&dword_2419D9000, v22, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__p.__r_.__value_.__l.__data_);
      if (SHIBYTE(v31.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v31.__r_.__value_.__l.__data_);
    }

    result = abort_report_np();
    __break(1u);
  }
  return result;
}

void sub_241A54648(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  void *v22;

  _Unwind_Resume(a1);
}

void CLMicroLocationStateMachine::EventHandlerWrapper<CLMiLoCustomLoiRecordingManager,CLMiLoMaxRecordingTimerFiredEvent,&CLMiLoCustomLoiRecordingManager::MaxRecordingTimeReached>::~EventHandlerWrapper(CLMacAddress *a1, unint64_t a2)
{
  CLMacAddress::newFromUint64(a1, a2);
  JUMPOUT(0x2426A04D4);
}

uint64_t CLMicroLocationStateMachine::EventHandlerWrapper<CLMiLoCustomLoiRecordingManager,CLMiLoThrottleTimerFiredEvent,&CLMiLoCustomLoiRecordingManager::ThrottleTimerFired>::stateFunction@<X0>(CLMicroLocationStateMachine::EventBase *lpsrc@<X2>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  char *v6;
  uint64_t result;
  NSObject *v8;
  uint64_t v9;
  __int128 v10;
  int v11;
  std::string::size_type v12;
  std::string *v13;
  std::string *p_p;
  NSObject *v15;
  uint64_t v16;
  __int128 v17;
  int v18;
  std::string::size_type v19;
  std::string *v20;
  std::string *v21;
  NSObject *v22;
  uint64_t v23;
  __int128 v24;
  int v25;
  std::string::size_type v26;
  std::string *v27;
  std::string *v28;
  std::string __p;
  std::string v30;
  uint8_t buf[4];
  int v32;
  __int16 v33;
  const char *v34;
  __int16 v35;
  std::string *v36;
  __int16 v37;
  std::string *v38;
  __int16 v39;
  const char *v40;
  __int16 v41;
  const char *v42;
  uint64_t v43;

  v43 = *MEMORY[0x24BDAC8D0];
  if (lpsrc
  {
    if (*(_BYTE *)(a2 + 144))
      v6 = "RecordingState";
    else
      v6 = "RecordingPendingState";
    result = (uint64_t)std::string::basic_string[abi:ne180100]<0>((_QWORD *)a3, v6);
    *(_BYTE *)(a3 + 24) = 1;
  }
  else
  {
    _CLLogObjectForCategory_MicroLocation_Default();
    v8 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_FAULT))
    {
      v9 = *(_QWORD *)(a2 + 8);
      if (*(char *)(v9 + 31) < 0)
      {
        std::string::__init_copy_ctor_external(&v30, *(const std::string::value_type **)(v9 + 8), *(_QWORD *)(v9 + 16));
      }
      else
      {
        v10 = *(_OWORD *)(v9 + 8);
        v30.__r_.__value_.__r.__words[2] = *(_QWORD *)(v9 + 24);
        *(_OWORD *)&v30.__r_.__value_.__l.__data_ = v10;
      }
      v11 = SHIBYTE(v30.__r_.__value_.__r.__words[2]);
      v12 = v30.__r_.__value_.__r.__words[0];
      CLMicroLocationStateMachine::EventBase::getEventName(lpsrc, &__p);
      v13 = &v30;
      if (v11 < 0)
        v13 = (std::string *)v12;
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        p_p = &__p;
      else
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      *(_DWORD *)buf = 68290051;
      v32 = 0;
      v33 = 2082;
      v34 = "";
      v35 = 2081;
      v36 = v13;
      v37 = 2081;
      v38 = p_p;
      v39 = 2082;
      v40 = "assert";
      v41 = 2081;
      v42 = "derivedEventData != __null";
      _os_log_impl(&dword_2419D9000, v8, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__p.__r_.__value_.__l.__data_);
      if (SHIBYTE(v30.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v30.__r_.__value_.__l.__data_);
    }

    _CLLogObjectForCategory_MicroLocation_Default();
    v15 = objc_claimAutoreleasedReturnValue();
    if (os_signpost_enabled(v15))
    {
      v16 = *(_QWORD *)(a2 + 8);
      if (*(char *)(v16 + 31) < 0)
      {
        std::string::__init_copy_ctor_external(&v30, *(const std::string::value_type **)(v16 + 8), *(_QWORD *)(v16 + 16));
      }
      else
      {
        v17 = *(_OWORD *)(v16 + 8);
        v30.__r_.__value_.__r.__words[2] = *(_QWORD *)(v16 + 24);
        *(_OWORD *)&v30.__r_.__value_.__l.__data_ = v17;
      }
      v18 = SHIBYTE(v30.__r_.__value_.__r.__words[2]);
      v19 = v30.__r_.__value_.__r.__words[0];
      CLMicroLocationStateMachine::EventBase::getEventName(lpsrc, &__p);
      v20 = &v30;
      if (v18 < 0)
        v20 = (std::string *)v19;
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v21 = &__p;
      else
        v21 = (std::string *)__p.__r_.__value_.__r.__words[0];
      *(_DWORD *)buf = 68290051;
      v32 = 0;
      v33 = 2082;
      v34 = "";
      v35 = 2081;
      v36 = v20;
      v37 = 2081;
      v38 = v21;
      v39 = 2082;
      v40 = "assert";
      v41 = 2081;
      v42 = "derivedEventData != __null";
      _os_signpost_emit_with_name_impl(&dword_2419D9000, v15, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Received unsupported event in state event handler", "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__p.__r_.__value_.__l.__data_);
      if (SHIBYTE(v30.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v30.__r_.__value_.__l.__data_);
    }

    _CLLogObjectForCategory_MicroLocation_Default();
    v22 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v22, OS_LOG_TYPE_INFO))
    {
      v23 = *(_QWORD *)(a2 + 8);
      if (*(char *)(v23 + 31) < 0)
      {
        std::string::__init_copy_ctor_external(&v30, *(const std::string::value_type **)(v23 + 8), *(_QWORD *)(v23 + 16));
      }
      else
      {
        v24 = *(_OWORD *)(v23 + 8);
        v30.__r_.__value_.__r.__words[2] = *(_QWORD *)(v23 + 24);
        *(_OWORD *)&v30.__r_.__value_.__l.__data_ = v24;
      }
      v25 = SHIBYTE(v30.__r_.__value_.__r.__words[2]);
      v26 = v30.__r_.__value_.__r.__words[0];
      CLMicroLocationStateMachine::EventBase::getEventName(lpsrc, &__p);
      v27 = &v30;
      if (v25 < 0)
        v27 = (std::string *)v26;
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v28 = &__p;
      else
        v28 = (std::string *)__p.__r_.__value_.__r.__words[0];
      *(_DWORD *)buf = 68290051;
      v32 = 0;
      v33 = 2082;
      v34 = "";
      v35 = 2081;
      v36 = v27;
      v37 = 2081;
      v38 = v28;
      v39 = 2082;
      v40 = "assert";
      v41 = 2081;
      v42 = "derivedEventData != __null";
      _os_log_impl(&dword_2419D9000, v22, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__p.__r_.__value_.__l.__data_);
      if (SHIBYTE(v30.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v30.__r_.__value_.__l.__data_);
    }

    result = abort_report_np();
    __break(1u);
  }
  return result;
}

void sub_241A54AEC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  void *v22;

  _Unwind_Resume(a1);
}

void CLMicroLocationStateMachine::EventHandlerWrapper<CLMiLoCustomLoiRecordingManager,CLMiLoThrottleTimerFiredEvent,&CLMiLoCustomLoiRecordingManager::ThrottleTimerFired>::~EventHandlerWrapper(CLMacAddress *a1, unint64_t a2)
{
  CLMacAddress::newFromUint64(a1, a2);
  JUMPOUT(0x2426A04D4);
}

uint64_t CLMicroLocationStateMachine::EventHandlerWrapper<CLMiLoCustomLoiRecordingManager,CLMiLoRecordingFenceBreachedEvent,&CLMiLoCustomLoiRecordingManager::RecordingFenceBreach>::stateFunction@<X0>(CLMicroLocationStateMachine::EventBase *lpsrc@<X2>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  void *v6;
  uint64_t result;
  NSObject *v8;
  uint64_t v9;
  __int128 v10;
  int v11;
  std::string::size_type v12;
  std::string *v13;
  std::string *p_p;
  NSObject *v15;
  uint64_t v16;
  __int128 v17;
  int v18;
  std::string::size_type v19;
  std::string *v20;
  std::string *v21;
  NSObject *v22;
  uint64_t v23;
  __int128 v24;
  int v25;
  std::string::size_type v26;
  std::string *v27;
  std::string *v28;
  CLMicroLocationStateMachine::EventBase *v29;
  std::string __p;
  std::string v31;
  uint8_t buf[4];
  int v33;
  __int16 v34;
  const char *v35;
  __int16 v36;
  std::string *v37;
  __int16 v38;
  std::string *v39;
  __int16 v40;
  const char *v41;
  __int16 v42;
  const char *v43;
  uint64_t v44;

  v44 = *MEMORY[0x24BDAC8D0];
  if (lpsrc
  {
    (*(void (**)(_QWORD))(**(_QWORD **)(a2 + 184) + 24))(*(_QWORD *)(a2 + 184));
    v6 = *(void **)(a2 + 152);
    *(_QWORD *)(a2 + 152) = CFSTR("recordingFenceBreached");

    result = (uint64_t)std::string::basic_string[abi:ne180100]<0>((_QWORD *)a3, "IdleState");
    *(_BYTE *)(a3 + 24) = 1;
  }
  else
  {
    v29 = lpsrc;
    _CLLogObjectForCategory_MicroLocation_Default();
    v8 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_FAULT))
    {
      v9 = *(_QWORD *)(a2 + 8);
      if (*(char *)(v9 + 31) < 0)
      {
        std::string::__init_copy_ctor_external(&v31, *(const std::string::value_type **)(v9 + 8), *(_QWORD *)(v9 + 16));
      }
      else
      {
        v10 = *(_OWORD *)(v9 + 8);
        v31.__r_.__value_.__r.__words[2] = *(_QWORD *)(v9 + 24);
        *(_OWORD *)&v31.__r_.__value_.__l.__data_ = v10;
      }
      v11 = SHIBYTE(v31.__r_.__value_.__r.__words[2]);
      v12 = v31.__r_.__value_.__r.__words[0];
      CLMicroLocationStateMachine::EventBase::getEventName(lpsrc, &__p);
      v13 = &v31;
      if (v11 < 0)
        v13 = (std::string *)v12;
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        p_p = &__p;
      else
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      *(_DWORD *)buf = 68290051;
      v33 = 0;
      v34 = 2082;
      v35 = "";
      v36 = 2081;
      v37 = v13;
      v38 = 2081;
      v39 = p_p;
      v40 = 2082;
      v41 = "assert";
      v42 = 2081;
      v43 = "derivedEventData != __null";
      _os_log_impl(&dword_2419D9000, v8, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__p.__r_.__value_.__l.__data_);
      if (SHIBYTE(v31.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v31.__r_.__value_.__l.__data_);
    }

    _CLLogObjectForCategory_MicroLocation_Default();
    v15 = objc_claimAutoreleasedReturnValue();
    if (os_signpost_enabled(v15))
    {
      v16 = *(_QWORD *)(a2 + 8);
      if (*(char *)(v16 + 31) < 0)
      {
        std::string::__init_copy_ctor_external(&v31, *(const std::string::value_type **)(v16 + 8), *(_QWORD *)(v16 + 16));
      }
      else
      {
        v17 = *(_OWORD *)(v16 + 8);
        v31.__r_.__value_.__r.__words[2] = *(_QWORD *)(v16 + 24);
        *(_OWORD *)&v31.__r_.__value_.__l.__data_ = v17;
      }
      v18 = SHIBYTE(v31.__r_.__value_.__r.__words[2]);
      v19 = v31.__r_.__value_.__r.__words[0];
      CLMicroLocationStateMachine::EventBase::getEventName(lpsrc, &__p);
      v20 = &v31;
      if (v18 < 0)
        v20 = (std::string *)v19;
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v21 = &__p;
      else
        v21 = (std::string *)__p.__r_.__value_.__r.__words[0];
      *(_DWORD *)buf = 68290051;
      v33 = 0;
      v34 = 2082;
      v35 = "";
      v36 = 2081;
      v37 = v20;
      v38 = 2081;
      v39 = v21;
      v40 = 2082;
      v41 = "assert";
      v42 = 2081;
      v43 = "derivedEventData != __null";
      _os_signpost_emit_with_name_impl(&dword_2419D9000, v15, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Received unsupported event in state event handler", "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__p.__r_.__value_.__l.__data_);
      if (SHIBYTE(v31.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v31.__r_.__value_.__l.__data_);
    }

    _CLLogObjectForCategory_MicroLocation_Default();
    v22 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v22, OS_LOG_TYPE_INFO))
    {
      v23 = *(_QWORD *)(a2 + 8);
      if (*(char *)(v23 + 31) < 0)
      {
        std::string::__init_copy_ctor_external(&v31, *(const std::string::value_type **)(v23 + 8), *(_QWORD *)(v23 + 16));
      }
      else
      {
        v24 = *(_OWORD *)(v23 + 8);
        v31.__r_.__value_.__r.__words[2] = *(_QWORD *)(v23 + 24);
        *(_OWORD *)&v31.__r_.__value_.__l.__data_ = v24;
      }
      v25 = SHIBYTE(v31.__r_.__value_.__r.__words[2]);
      v26 = v31.__r_.__value_.__r.__words[0];
      CLMicroLocationStateMachine::EventBase::getEventName(v29, &__p);
      v27 = &v31;
      if (v25 < 0)
        v27 = (std::string *)v26;
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v28 = &__p;
      else
        v28 = (std::string *)__p.__r_.__value_.__r.__words[0];
      *(_DWORD *)buf = 68290051;
      v33 = 0;
      v34 = 2082;
      v35 = "";
      v36 = 2081;
      v37 = v27;
      v38 = 2081;
      v39 = v28;
      v40 = 2082;
      v41 = "assert";
      v42 = 2081;
      v43 = "derivedEventData != __null";
      _os_log_impl(&dword_2419D9000, v22, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__p.__r_.__value_.__l.__data_);
      if (SHIBYTE(v31.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v31.__r_.__value_.__l.__data_);
    }

    result = abort_report_np();
    __break(1u);
  }
  return result;
}

void sub_241A54FA0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  void *v22;

  _Unwind_Resume(a1);
}

void CLMicroLocationStateMachine::EventHandlerWrapper<CLMiLoCustomLoiRecordingManager,CLMiLoRecordingFenceBreachedEvent,&CLMiLoCustomLoiRecordingManager::RecordingFenceBreach>::~EventHandlerWrapper(CLMacAddress *a1, unint64_t a2)
{
  CLMacAddress::newFromUint64(a1, a2);
  JUMPOUT(0x2426A04D4);
}

_QWORD *CLMicroLocationStateMachine::EventHandlerWrapper<CLMiLoCustomLoiRecordingManager,CLMiLoRecordingCompletedEvent,&CLMiLoCustomLoiRecordingManager::RecordingComplete>::stateFunction@<X0>(void *lpsrc@<X2>, CLMiLoCustomLoiRecordingManager *a2@<X1>, uint64_t a3@<X8>)
{
  _QWORD *result;
  CLMiLoCustomLoiRecordingManager *v7;
  NSObject *v8;
  uint64_t v9;
  __int128 v10;
  int v11;
  std::string::size_type v12;
  std::string *v13;
  std::string *p_p;
  NSObject *v15;
  uint64_t v16;
  __int128 v17;
  int v18;
  std::string::size_type v19;
  std::string *v20;
  std::string *v21;
  NSObject *v22;
  uint64_t v23;
  __int128 v24;
  int v25;
  std::string::size_type v26;
  std::string *v27;
  std::string *v28;
  CLMicroLocationStateMachine::EventBase *v29;
  std::string __p;
  std::string v31;
  uint8_t buf[4];
  int v33;
  __int16 v34;
  const char *v35;
  __int16 v36;
  std::string *v37;
  __int16 v38;
  std::string *v39;
  __int16 v40;
  const char *v41;
  __int16 v42;
  const char *v43;
  uint64_t v44;

  v44 = *MEMORY[0x24BDAC8D0];
  if (lpsrc
  {
    return CLMiLoCustomLoiRecordingManager::RecordingComplete(a2, a3);
  }
  v7 = a2;
  v29 = (CLMicroLocationStateMachine::EventBase *)lpsrc;
  _CLLogObjectForCategory_MicroLocation_Default();
  v8 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v8, OS_LOG_TYPE_FAULT))
  {
    v9 = *((_QWORD *)v7 + 1);
    if (*(char *)(v9 + 31) < 0)
    {
      std::string::__init_copy_ctor_external(&v31, *(const std::string::value_type **)(v9 + 8), *(_QWORD *)(v9 + 16));
    }
    else
    {
      v10 = *(_OWORD *)(v9 + 8);
      v31.__r_.__value_.__r.__words[2] = *(_QWORD *)(v9 + 24);
      *(_OWORD *)&v31.__r_.__value_.__l.__data_ = v10;
    }
    v11 = SHIBYTE(v31.__r_.__value_.__r.__words[2]);
    v12 = v31.__r_.__value_.__r.__words[0];
    CLMicroLocationStateMachine::EventBase::getEventName((CLMicroLocationStateMachine::EventBase *)lpsrc, &__p);
    v13 = &v31;
    if (v11 < 0)
      v13 = (std::string *)v12;
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      p_p = &__p;
    else
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    *(_DWORD *)buf = 68290051;
    v33 = 0;
    v34 = 2082;
    v35 = "";
    v36 = 2081;
    v37 = v13;
    v38 = 2081;
    v39 = p_p;
    v40 = 2082;
    v41 = "assert";
    v42 = 2081;
    v43 = "derivedEventData != __null";
    _os_log_impl(&dword_2419D9000, v8, OS_LOG_TYPE_FAULT, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p.__r_.__value_.__l.__data_);
    if (SHIBYTE(v31.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v31.__r_.__value_.__l.__data_);
  }

  _CLLogObjectForCategory_MicroLocation_Default();
  v15 = objc_claimAutoreleasedReturnValue();
  if (os_signpost_enabled(v15))
  {
    v16 = *((_QWORD *)v7 + 1);
    if (*(char *)(v16 + 31) < 0)
    {
      std::string::__init_copy_ctor_external(&v31, *(const std::string::value_type **)(v16 + 8), *(_QWORD *)(v16 + 16));
    }
    else
    {
      v17 = *(_OWORD *)(v16 + 8);
      v31.__r_.__value_.__r.__words[2] = *(_QWORD *)(v16 + 24);
      *(_OWORD *)&v31.__r_.__value_.__l.__data_ = v17;
    }
    v18 = SHIBYTE(v31.__r_.__value_.__r.__words[2]);
    v19 = v31.__r_.__value_.__r.__words[0];
    CLMicroLocationStateMachine::EventBase::getEventName((CLMicroLocationStateMachine::EventBase *)lpsrc, &__p);
    v20 = &v31;
    if (v18 < 0)
      v20 = (std::string *)v19;
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v21 = &__p;
    else
      v21 = (std::string *)__p.__r_.__value_.__r.__words[0];
    *(_DWORD *)buf = 68290051;
    v33 = 0;
    v34 = 2082;
    v35 = "";
    v36 = 2081;
    v37 = v20;
    v38 = 2081;
    v39 = v21;
    v40 = 2082;
    v41 = "assert";
    v42 = 2081;
    v43 = "derivedEventData != __null";
    _os_signpost_emit_with_name_impl(&dword_2419D9000, v15, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Received unsupported event in state event handler", "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p.__r_.__value_.__l.__data_);
    if (SHIBYTE(v31.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v31.__r_.__value_.__l.__data_);
  }

  _CLLogObjectForCategory_MicroLocation_Default();
  v22 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v22, OS_LOG_TYPE_INFO))
  {
    v23 = *((_QWORD *)v7 + 1);
    if (*(char *)(v23 + 31) < 0)
    {
      std::string::__init_copy_ctor_external(&v31, *(const std::string::value_type **)(v23 + 8), *(_QWORD *)(v23 + 16));
    }
    else
    {
      v24 = *(_OWORD *)(v23 + 8);
      v31.__r_.__value_.__r.__words[2] = *(_QWORD *)(v23 + 24);
      *(_OWORD *)&v31.__r_.__value_.__l.__data_ = v24;
    }
    v25 = SHIBYTE(v31.__r_.__value_.__r.__words[2]);
    v26 = v31.__r_.__value_.__r.__words[0];
    CLMicroLocationStateMachine::EventBase::getEventName(v29, &__p);
    v27 = &v31;
    if (v25 < 0)
      v27 = (std::string *)v26;
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v28 = &__p;
    else
      v28 = (std::string *)__p.__r_.__value_.__r.__words[0];
    *(_DWORD *)buf = 68290051;
    v33 = 0;
    v34 = 2082;
    v35 = "";
    v36 = 2081;
    v37 = v27;
    v38 = 2081;
    v39 = v28;
    v40 = 2082;
    v41 = "assert";
    v42 = 2081;
    v43 = "derivedEventData != __null";
    _os_log_impl(&dword_2419D9000, v22, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"Received unsupported event in state event handler\", \"State\":%{private, location:escape_only}s, \"Received Event\":%{private, location:escape_only}s, \"event\":%{public, location:escape_only}s, \"condition\":%{private, location:escape_only}s}", buf, 0x3Au);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p.__r_.__value_.__l.__data_);
    if (SHIBYTE(v31.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v31.__r_.__value_.__l.__data_);
  }

  result = (_QWORD *)abort_report_np();
  __break(1u);
  return result;
}

void sub_241A55424(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  void *v22;

  _Unwind_Resume(a1);
}

void CLMicroLocationStateMachine::EventHandlerWrapper<CLMiLoCustomLoiRecordingManager,CLMiLoRecordingCompletedEvent,&CLMiLoCustomLoiRecordingManager::RecordingComplete>::~EventHandlerWrapper(CLMacAddress *a1, unint64_t a2)
{
  CLMacAddress::newFromUint64(a1, a2);
  JUMPOUT(0x2426A04D4);
}

uint64_t CLMicroLocationStateMachine::EventHandlerWrapperWithNoData<CLMiLoCustomLoiRecordingManager,&CLMiLoCustomLoiRecordingManager::entryFunctionIdleState>::stateFunction(int a1, CLMiLoCustomLoiRecordingManager *this)
{
  return CLMiLoCustomLoiRecordingManager::entryFunctionIdleState((uint64_t)this);
}

void CLMicroLocationStateMachine::EventHandlerWrapperWithNoData<CLMiLoCustomLoiRecordingManager,&CLMiLoCustomLoiRecordingManager::entryFunctionIdleState>::~EventHandlerWrapperWithNoData(CLMacAddress *a1, unint64_t a2)
{
  CLMacAddress::newFromUint64(a1, a2);
  JUMPOUT(0x2426A04D4);
}

uint64_t CLMicroLocationStateMachine::EventHandlerWrapperWithNoData<CLMiLoCustomLoiRecordingManager,&CLMiLoCustomLoiRecordingManager::entryFunctionRecordingState>::stateFunction(uint64_t a1, uint64_t a2)
{
  return (***(uint64_t (****)(_QWORD))(a2 + 184))(*(_QWORD *)(a2 + 184));
}

void CLMicroLocationStateMachine::EventHandlerWrapperWithNoData<CLMiLoCustomLoiRecordingManager,&CLMiLoCustomLoiRecordingManager::entryFunctionRecordingState>::~EventHandlerWrapperWithNoData(CLMacAddress *a1, unint64_t a2)
{
  CLMacAddress::newFromUint64(a1, a2);
  JUMPOUT(0x2426A04D4);
}

void CLMicroLocationStateMachine::EventHandlerWrapperWithNoData<CLMiLoCustomLoiRecordingManager,&CLMiLoCustomLoiRecordingManager::entryFunctionRecordingThrottledState>::stateFunction(int a1, id *this)
{
  CLMiLoCustomLoiRecordingManager::startThrottleTimer(this);
}

void CLMicroLocationStateMachine::EventHandlerWrapperWithNoData<CLMiLoCustomLoiRecordingManager,&CLMiLoCustomLoiRecordingManager::entryFunctionRecordingThrottledState>::~EventHandlerWrapperWithNoData(CLMacAddress *a1, unint64_t a2)
{
  CLMacAddress::newFromUint64(a1, a2);
  JUMPOUT(0x2426A04D4);
}

void CLMiLoStartRecordingSessionEvent::CLMiLoStartRecordingSessionEvent(CLMiLoStartRecordingSessionEvent *this)
{
  _QWORD *v2;

  *(_QWORD *)this = off_2511D4DA0;
  v2 = std::string::basic_string[abi:ne180100]<0>((_QWORD *)this + 1, "No Name Given");
  *(_QWORD *)this = off_2511D4D80;
  MEMORY[0x2426A02C4](v2, "StartRecordingSessionEvent");
}

void sub_241A55574(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void **v2;
  uint64_t v3;
  uint64_t v4;

  v4 = v3;
  *(_QWORD *)v1 = v4;
  if (*(char *)(v1 + 31) < 0)
    operator delete(*v2);
  _Unwind_Resume(exception_object);
}

void CLMicroLocationStateMachine::EventBase::~EventBase(void **this)
{
  *this = off_2511D4DA0;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
}

{
  *this = off_2511D4DA0;
  if (*((char *)this + 31) < 0)
    operator delete(this[1]);
  JUMPOUT(0x2426A04D4);
}

void CLMiLoStopRecordingSessionEvent::CLMiLoStopRecordingSessionEvent(CLMiLoStopRecordingSessionEvent *this)
{
  _QWORD *v2;

  *(_QWORD *)this = off_2511D4DA0;
  v2 = std::string::basic_string[abi:ne180100]<0>((_QWORD *)this + 1, "No Name Given");
  *(_QWORD *)this = off_2511D4DC0;
  MEMORY[0x2426A02C4](v2, "StopRecordingSessionEvent");
}

void sub_241A556CC(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void **v2;
  uint64_t v3;
  uint64_t v4;

  v4 = v3;
  *(_QWORD *)v1 = v4;
  if (*(char *)(v1 + 31) < 0)
    operator delete(*v2);
  _Unwind_Resume(exception_object);
}

void CLMiLoRecordingCompletedEvent::CLMiLoRecordingCompletedEvent(CLMiLoRecordingCompletedEvent *this)
{
  _QWORD *v2;

  *(_QWORD *)this = off_2511D4DA0;
  v2 = std::string::basic_string[abi:ne180100]<0>((_QWORD *)this + 1, "No Name Given");
  *(_QWORD *)this = off_2511D4DE0;
  MEMORY[0x2426A02C4](v2, "RecordingCompletedEvent");
}

void sub_241A5579C(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void **v2;
  uint64_t v3;
  uint64_t v4;

  v4 = v3;
  *(_QWORD *)v1 = v4;
  if (*(char *)(v1 + 31) < 0)
    operator delete(*v2);
  _Unwind_Resume(exception_object);
}

void CLMiLoRecordingFenceBreachedEvent::CLMiLoRecordingFenceBreachedEvent(CLMiLoRecordingFenceBreachedEvent *this)
{
  _QWORD *v2;

  *(_QWORD *)this = off_2511D4DA0;
  v2 = std::string::basic_string[abi:ne180100]<0>((_QWORD *)this + 1, "No Name Given");
  *(_QWORD *)this = off_2511D4E00;
  MEMORY[0x2426A02C4](v2, "RecordingFenceBreachedEvent");
}

void sub_241A5586C(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void **v2;
  uint64_t v3;
  uint64_t v4;

  v4 = v3;
  *(_QWORD *)v1 = v4;
  if (*(char *)(v1 + 31) < 0)
    operator delete(*v2);
  _Unwind_Resume(exception_object);
}

void CLMiLoMaxRecordingTimerFiredEvent::CLMiLoMaxRecordingTimerFiredEvent(CLMiLoMaxRecordingTimerFiredEvent *this)
{
  _QWORD *v2;

  *(_QWORD *)this = off_2511D4DA0;
  v2 = std::string::basic_string[abi:ne180100]<0>((_QWORD *)this + 1, "No Name Given");
  *(_QWORD *)this = off_2511D4E20;
  MEMORY[0x2426A02C4](v2, "MaxRecordingTimerFiredEvent");
}

void sub_241A5593C(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void **v2;
  uint64_t v3;
  uint64_t v4;

  v4 = v3;
  *(_QWORD *)v1 = v4;
  if (*(char *)(v1 + 31) < 0)
    operator delete(*v2);
  _Unwind_Resume(exception_object);
}

void CLMiLoThrottleTimerFiredEvent::CLMiLoThrottleTimerFiredEvent(CLMiLoThrottleTimerFiredEvent *this)
{
  _QWORD *v2;

  *(_QWORD *)this = off_2511D4DA0;
  v2 = std::string::basic_string[abi:ne180100]<0>((_QWORD *)this + 1, "No Name Given");
  *(_QWORD *)this = off_2511D4E40;
  MEMORY[0x2426A02C4](v2, "ThrottleTimerFiredEvent");
}

void sub_241A55A0C(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void **v2;
  uint64_t v3;
  uint64_t v4;

  v4 = v3;
  *(_QWORD *)v1 = v4;
  if (*(char *)(v1 + 31) < 0)
    operator delete(*v2);
  _Unwind_Resume(exception_object);
}

void CLMiLoDeviceReadyEvent::CLMiLoDeviceReadyEvent(CLMiLoDeviceReadyEvent *this)
{
  _QWORD *v2;

  *(_QWORD *)this = off_2511D4DA0;
  v2 = std::string::basic_string[abi:ne180100]<0>((_QWORD *)this + 1, "No Name Given");
  *(_QWORD *)this = off_2511D4E60;
  MEMORY[0x2426A02C4](v2, "DeviceReadyEvent");
}

void sub_241A55ADC(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void **v2;
  uint64_t v3;
  uint64_t v4;

  v4 = v3;
  *(_QWORD *)v1 = v4;
  if (*(char *)(v1 + 31) < 0)
    operator delete(*v2);
  _Unwind_Resume(exception_object);
}

void CLMiLoDeviceNotReadyEvent::CLMiLoDeviceNotReadyEvent(CLMiLoDeviceNotReadyEvent *this)
{
  _QWORD *v2;

  *(_QWORD *)this = off_2511D4DA0;
  v2 = std::string::basic_string[abi:ne180100]<0>((_QWORD *)this + 1, "No Name Given");
  *(_QWORD *)this = off_2511D4E80;
  MEMORY[0x2426A02C4](v2, "DeviceNotReadyEvent");
}

void sub_241A55BAC(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void **v2;
  uint64_t v3;
  uint64_t v4;

  v4 = v3;
  *(_QWORD *)v1 = v4;
  if (*(char *)(v1 + 31) < 0)
    operator delete(*v2);
  _Unwind_Resume(exception_object);
}

void ___ZL45_CLLogObjectForCategory_MicroLocation_Defaultv_block_invoke_34()
{
  os_log_t v0;
  void *v1;

  v0 = os_log_create("com.apple.MicroLocation", "MicroLocation");
  v1 = (void *)logObject_MicroLocation_Default;
  logObject_MicroLocation_Default = (uint64_t)v0;

}

_OWORD *std::__tree<std::__value_type<std::string,CLMicroLocationStateMachine::EventHandlerWrapperBase *>,std::__map_value_compare<std::string,std::__value_type<std::string,CLMicroLocationStateMachine::EventHandlerWrapperBase *>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,CLMicroLocationStateMachine::EventHandlerWrapperBase *>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(uint64_t **a1, const void **a2, uint64_t a3, _OWORD **a4)
{
  void **v6;
  _OWORD *v7;
  uint64_t **v8;
  _QWORD *v9;
  uint64_t v10;
  uint64_t v12;

  v6 = (void **)std::__tree<std::__value_type<std::string,CLSqliteDatabaseManager::ConnectionState>,std::__map_value_compare<std::string,std::__value_type<std::string,CLSqliteDatabaseManager::ConnectionState>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,CLSqliteDatabaseManager::ConnectionState>>>::__find_equal<std::string>((uint64_t)a1, &v12, a2);
  v7 = *v6;
  if (!*v6)
  {
    v8 = (uint64_t **)v6;
    v7 = operator new(0x40uLL);
    v9 = *a4;
    v10 = *((_QWORD *)*a4 + 2);
    v7[2] = **a4;
    *((_QWORD *)v7 + 6) = v10;
    v9[1] = 0;
    v9[2] = 0;
    *v9 = 0;
    *((_QWORD *)v7 + 7) = 0;
    std::__tree<CLMicroLocationRecordingCompletionMetaInformation::RecordingError>::__insert_node_at(a1, v12, v8, (uint64_t *)v7);
  }
  return v7;
}

void sub_241A55DDC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  _Unwind_Resume(a1);
}

void sub_241A55FF4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  _Unwind_Resume(a1);
}

void sub_241A5608C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{

  _Unwind_Resume(a1);
}

void sub_241A56104(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{

  _Unwind_Resume(a1);
}

void sub_241A561A4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_241A56368(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;

  v7 = v2;

  _Unwind_Resume(a1);
}

void sub_241A5653C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;
  void *v11;
  void *v12;

  _Unwind_Resume(a1);
}

void sub_241A56584()
{
  JUMPOUT(0x241A56574);
}

void sub_241A565F0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_241A56A24(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;

  _Unwind_Resume(a1);
}

void ___ZL45_CLLogObjectForCategory_MicroLocation_Defaultv_block_invoke_35()
{
  os_log_t v0;
  void *v1;

  v0 = os_log_create("com.apple.MicroLocation", "MicroLocation");
  v1 = (void *)logObject_MicroLocation_Default;
  logObject_MicroLocation_Default = (uint64_t)v0;

}

_QWORD *CLMicroLocationUwbBridgeWrapper::CLMicroLocationUwbBridgeWrapper(_QWORD *a1, void *a2, uint64_t a3)
{
  id v5;
  id v6;
  CLHomeNearbyRangeBridge *v7;
  void *v8;

  v5 = a2;
  *a1 = &off_2511D4EE0;
  a1[1] = 0;
  v6 = v5;
  a1[2] = v6;
  a1[3] = a3;
  v7 = -[CLHomeNearbyRangeBridge initWithDelegate:withQueue:]([CLHomeNearbyRangeBridge alloc], "initWithDelegate:withQueue:", a1, v6);
  v8 = (void *)a1[1];
  a1[1] = v7;

  return a1;
}

void sub_241A56CA8(_Unwind_Exception *a1)
{
  uint64_t v1;
  void *v2;

  _Unwind_Resume(a1);
}

void CLMicroLocationUwbBridgeWrapper::~CLMicroLocationUwbBridgeWrapper(CLMicroLocationUwbBridgeWrapper *this)
{
  id var1;

  this->var0 = (void **)&off_2511D4EE0;
  objc_msgSend(this->var1, "stopRanging");
  var1 = this->var1;
  this->var1 = 0;

}

{
  CLMicroLocationUwbBridgeWrapper::~CLMicroLocationUwbBridgeWrapper(this);
  JUMPOUT(0x2426A04D4);
}

uint64_t CLMicroLocationUwbBridgeWrapper::startRanging(CLMicroLocationUwbBridgeWrapper *this)
{
  return objc_msgSend(this->var1, "startRanging");
}

uint64_t CLMicroLocationUwbBridgeWrapper::stopRanging(CLMicroLocationUwbBridgeWrapper *this)
{
  return objc_msgSend(this->var1, "stopRanging");
}

uint64_t CLMicroLocationUwbBridgeWrapper::setRangingRate(uint64_t a1, uint64_t a2)
{
  return objc_msgSend(*(id *)(a1 + 8), "setRangingRateWithConfiguration:", a2);
}

uint64_t CLMicroLocationUwbBridgeWrapper::resetRangingRate(CLMicroLocationUwbBridgeWrapper *this)
{
  return objc_msgSend(this->var1, "resetRangingRate");
}

uint64_t CLMicroLocationUwbBridgeWrapper::onHomeNearbySessionCreated(CLMicroLocationUwbBridgeWrapper *this)
{
  return (*(uint64_t (**)(IUwbClientDelegate *))(*(_QWORD *)this->var3 + 32))(this->var3);
}

uint64_t CLMicroLocationUwbBridgeWrapper::onHomeNearbySessionStopped(CLMicroLocationUwbBridgeWrapper *this)
{
  return (*(uint64_t (**)(IUwbClientDelegate *))(*(_QWORD *)this->var3 + 24))(this->var3);
}

uint64_t CLMicroLocationUwbBridgeWrapper::onHomeNearbySessionSuspended(CLMicroLocationUwbBridgeWrapper *this)
{
  return (*(uint64_t (**)(IUwbClientDelegate *))(*(_QWORD *)this->var3 + 40))(this->var3);
}

uint64_t CLMicroLocationUwbBridgeWrapper::onHomeNearbySessionResumed(CLMicroLocationUwbBridgeWrapper *this)
{
  return (*(uint64_t (**)(IUwbClientDelegate *))(*(_QWORD *)this->var3 + 48))(this->var3);
}

void CLMicroLocationUwbBridgeWrapper::onHomeNearbyObjects(uint64_t a1, CLMicroLocationProtobufHelper **a2)
{
  CFAbsoluteTime v4;
  _BYTE v5[24];
  void **v6;

  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 16));
  CLMicroLocationProtobufHelper::protobufsFromNativeData<CLHomeNearbyObjectInternal>(a2, (uint64_t)v5);
  v4 = cl::chrono::CFAbsoluteTimeClock::now();
  (*(void (**)(_QWORD, _BYTE *, CFAbsoluteTime))(**(_QWORD **)(a1 + 24) + 16))(*(_QWORD *)(a1 + 24), v5, v4);
  v6 = (void **)v5;
  std::vector<CLMicroLocationProto::UwbRange>::__destroy_vector::operator()[abi:ne180100](&v6);
}

void sub_241A56E1C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_list va;

  va_start(va, a4);
  std::vector<CLMicroLocationProto::UwbRange>::__destroy_vector::operator()[abi:ne180100]((void ***)va);
  _Unwind_Resume(a1);
}

void CLMicroLocationProtobufHelper::protobufsFromNativeData<CLHomeNearbyObjectInternal>(CLMicroLocationProtobufHelper **a1@<X0>, uint64_t a2@<X8>)
{
  __int128 v3;
  CLMicroLocationProtobufHelper *v4;
  CLMicroLocationProtobufHelper *v5;
  uint64_t v6;
  void **v7[8];
  char v8;
  __int128 v9;
  uint64_t v10;

  v10 = 0;
  v3 = 0uLL;
  v9 = 0u;
  v4 = *a1;
  v5 = a1[1];
  if (*a1 == v5)
  {
    v6 = 0;
  }
  else
  {
    do
    {
      CLMicroLocationProtobufHelper::protobufFromNative(v4, (CLMicroLocationProto::UwbRange *)v7);
      if (v8)
      {
        std::vector<CLMicroLocationProto::UwbRange>::push_back[abi:ne180100]((uint64_t *)&v9, (CLMicroLocationProto::UwbRange *)v7);
        if (v8)
          CLMicroLocationProto::UwbRange::~UwbRange((CLMicroLocationProto::UwbRange *)v7);
      }
      v4 = (CLMicroLocationProtobufHelper *)((char *)v4 + 80);
    }
    while (v4 != v5);
    v3 = v9;
    v6 = v10;
  }
  *(_OWORD *)a2 = v3;
  *(_QWORD *)(a2 + 16) = v6;
  v10 = 0;
  v9 = 0uLL;
  v7[0] = (void **)&v9;
  std::vector<CLMicroLocationProto::UwbRange>::__destroy_vector::operator()[abi:ne180100](v7);
}

void sub_241A56EE4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void **a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18)
{
  uint64_t v18;

  if (a18)
    CLMicroLocationProto::UwbRange::~UwbRange((CLMicroLocationProto::UwbRange *)&a10);
  a10 = (void **)(v18 - 64);
  std::vector<CLMicroLocationProto::UwbRange>::__destroy_vector::operator()[abi:ne180100](&a10);
  _Unwind_Resume(a1);
}

uint64_t std::vector<CLMicroLocationProto::UwbRange>::push_back[abi:ne180100](uint64_t *a1, CLMicroLocationProto::UwbRange *a2)
{
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  uint64_t result;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  char *v14;
  char *v15;
  CLMicroLocationProto::UwbRange *v16;
  char *v17;
  char *v18;
  uint64_t v19;

  v6 = a1[2];
  v4 = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(_QWORD *)(v4 - 8);
  if (v7 >= v6)
  {
    v10 = (uint64_t)(v7 - *a1) >> 6;
    if ((unint64_t)(v10 + 1) >> 58)
      std::vector<CLMicroLocationProto::ConfidenceReason>::__throw_length_error[abi:ne180100]();
    v11 = v5 - *a1;
    v12 = v11 >> 5;
    if (v11 >> 5 <= (unint64_t)(v10 + 1))
      v12 = v10 + 1;
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFC0)
      v13 = 0x3FFFFFFFFFFFFFFLL;
    else
      v13 = v12;
    v19 = v4;
    if (v13)
      v14 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<CLMicroLocationRecordingLabelsTable::Entry>>(v4, v13);
    else
      v14 = 0;
    v15 = v14;
    v16 = (CLMicroLocationProto::UwbRange *)&v14[64 * v10];
    v18 = &v14[64 * v13];
    CLMicroLocationProto::UwbRange::UwbRange(v16, a2);
    v17 = (char *)v16 + 64;
    std::vector<CLMicroLocationProto::UwbRange>::__swap_out_circular_buffer(a1, &v15);
    v9 = a1[1];
    result = std::__split_buffer<CLMicroLocationProto::UwbRange>::~__split_buffer((uint64_t)&v15);
  }
  else
  {
    result = CLMicroLocationProto::UwbRange::UwbRange(*(CLMicroLocationProto::UwbRange **)(v4 - 8), a2);
    v9 = v7 + 64;
    a1[1] = v7 + 64;
  }
  a1[1] = v9;
  return result;
}

void sub_241A57008(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  uint64_t v10;
  uint64_t v11;

  *(_QWORD *)(v10 + 8) = v11;
  _Unwind_Resume(exception_object);
}

uint64_t std::vector<CLMicroLocationProto::UwbRange>::__swap_out_circular_buffer(uint64_t *a1, _QWORD *a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<CLMicroLocationProto::UwbRange>,std::reverse_iterator<CLMicroLocationProto::UwbRange*>,std::reverse_iterator<CLMicroLocationProto::UwbRange*>,std::reverse_iterator<CLMicroLocationProto::UwbRange*>>((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<CLMicroLocationProto::UwbRange>,std::reverse_iterator<CLMicroLocationProto::UwbRange*>,std::reverse_iterator<CLMicroLocationProto::UwbRange*>,std::reverse_iterator<CLMicroLocationProto::UwbRange*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10;
  uint64_t v11;
  CLMicroLocationProto::UwbRange *v12;

  v10 = 0;
  v11 = a7 - 64;
  while (a3 + v10 != a5)
  {
    v12 = (CLMicroLocationProto::UwbRange *)(v11 + v10);
    v10 -= 64;
    CLMicroLocationProto::UwbRange::UwbRange(v12, (const CLMicroLocationProto::UwbRange *)(v10 + a3));
  }
  return a6;
}

uint64_t std::__split_buffer<CLMicroLocationProto::UwbRange>::~__split_buffer(uint64_t a1)
{
  uint64_t i;
  uint64_t v3;
  void (**v4)(void);

  v3 = *(_QWORD *)(a1 + 8);
  for (i = *(_QWORD *)(a1 + 16); i != v3; i = *(_QWORD *)(a1 + 16))
  {
    v4 = *(void (***)(void))(i - 64);
    *(_QWORD *)(a1 + 16) = i - 64;
    (*v4)();
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

void std::vector<CLMicroLocationProto::UwbRange>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v1;
  char *v2;
  char *v4;
  void *v5;
  char *v6;
  char *v7;
  void (**v8)(char *);
  BOOL v9;

  v1 = *a1;
  v2 = (char *)**a1;
  if (v2)
  {
    v4 = (char *)v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      v6 = v4 - 64;
      v7 = v4 - 64;
      do
      {
        v8 = *(void (***)(char *))v7;
        v7 -= 64;
        (*v8)(v6);
        v9 = v6 == v2;
        v6 = v7;
      }
      while (!v9);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t CLMicroLocationUtils::createEnabledTechnologies(CLMicroLocationUtils *this, int a2, int a3)
{
  uint64_t v3;

  v3 = 2;
  if (!(_DWORD)this)
    v3 = 0;
  if (a2)
    v3 |= 0x20uLL;
  if (a3)
    return v3 | 0x40;
  else
    return v3;
}

uint64_t CLMicroLocationUtils::ProbabilityMatrix::setValue(CLMicroLocationUtils::ProbabilityMatrix *this, int a2, int a3, double a4)
{
  uint64_t v4;
  int v5;

  v4 = 0;
  if ((a2 & 0x80000000) == 0 && (a3 & 0x80000000) == 0)
  {
    v5 = *((_DWORD *)this + 3);
    if (v5 > a2)
    {
      if (*((_DWORD *)this + 4) <= a3)
      {
        return 0;
      }
      else
      {
        *(double *)(*(_QWORD *)this + 8 * (a2 + v5 * a3)) = a4;
        *((_BYTE *)this + 8) = 0;
        return 1;
      }
    }
  }
  return v4;
}

CLMicroLocationUtils::ProbabilityMatrix *CLMicroLocationUtils::ProbabilityMatrix::ProbabilityMatrix(CLMicroLocationUtils::ProbabilityMatrix *this, int a2, int a3)
{
  void *v4;
  uint64_t v5;

  *(_QWORD *)this = 0;
  *((_WORD *)this + 4) = 0;
  *((_DWORD *)this + 3) = a2;
  *((_DWORD *)this + 4) = a3;
  v4 = (void *)operator new[]();
  v5 = *(_QWORD *)this;
  *(_QWORD *)this = v4;
  if (v5)
  {
    MEMORY[0x2426A04BC](v5, 0x1000C8000313F17);
    v4 = *(void **)this;
  }
  bzero(v4, 8 * *((_DWORD *)this + 4) * *((_DWORD *)this + 3));
  return this;
}

void sub_241A57308(_Unwind_Exception *exception_object)
{
  uint64_t *v1;
  uint64_t v3;

  v3 = *v1;
  *v1 = 0;
  if (v3)
    MEMORY[0x2426A04BC](v3, 0x1000C8000313F17);
  _Unwind_Resume(exception_object);
}

CLMicroLocationUtils::ProbabilityMatrix *CLMicroLocationUtils::ProbabilityMatrix::ProbabilityMatrix(CLMicroLocationUtils::ProbabilityMatrix *this, const CLMicroLocationUtils::ProbabilityMatrix *a2)
{
  size_t v4;
  void *v5;
  uint64_t v6;

  *(_QWORD *)this = 0;
  v4 = 8 * *((_DWORD *)a2 + 4) * *((_DWORD *)a2 + 3);
  v5 = (void *)operator new[]();
  memcpy(v5, *(const void **)a2, v4);
  v6 = *(_QWORD *)this;
  *(_QWORD *)this = v5;
  if (v6)
    MEMORY[0x2426A04BC](v6, 0x1000C8000313F17);
  *((_WORD *)this + 4) = *((_WORD *)a2 + 4);
  *(_QWORD *)((char *)this + 12) = *(_QWORD *)((char *)a2 + 12);
  return this;
}

void sub_241A573D0(_Unwind_Exception *exception_object)
{
  uint64_t *v1;
  uint64_t v3;

  v3 = *v1;
  *v1 = 0;
  if (v3)
    MEMORY[0x2426A04BC](v3, 0x1000C8000313F17);
  _Unwind_Resume(exception_object);
}

uint64_t CLMicroLocationUtils::ProbabilityMatrix::ProbabilityMatrix(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;
  uint64_t v5;

  v4 = *a2;
  *a2 = 0;
  *(_QWORD *)a1 = v4;
  *(_WORD *)(a1 + 8) = *((_WORD *)a2 + 4);
  *(_QWORD *)(a1 + 12) = *(uint64_t *)((char *)a2 + 12);
  v5 = *a2;
  *a2 = 0;
  if (v5)
    MEMORY[0x2426A04BC](v5, 0x1000C8000313F17);
  *((_WORD *)a2 + 4) = 0;
  *((_DWORD *)a2 + 3) = 0;
  *((_DWORD *)a2 + 4) = 0;
  return a1;
}

uint64_t *CLMicroLocationUtils::ProbabilityMatrix::operator=(uint64_t *a1, uint64_t a2)
{
  size_t v4;
  void *v5;
  uint64_t v6;

  if (a1 != (uint64_t *)a2)
  {
    v4 = 8 * *(_DWORD *)(a2 + 16) * *(_DWORD *)(a2 + 12);
    v5 = (void *)operator new[]();
    memcpy(v5, *(const void **)a2, v4);
    v6 = *a1;
    *a1 = (uint64_t)v5;
    if (v6)
      MEMORY[0x2426A04BC](v6, 0x1000C8000313F17);
    *((_WORD *)a1 + 4) = *(_WORD *)(a2 + 8);
    *(uint64_t *)((char *)a1 + 12) = *(_QWORD *)(a2 + 12);
  }
  return a1;
}

uint64_t *CLMicroLocationUtils::ProbabilityMatrix::operator=(uint64_t *a1, uint64_t *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  if (a1 != a2)
  {
    v4 = *a1;
    *a1 = 0;
    if (v4)
      MEMORY[0x2426A04BC](v4, 0x1000C8000313F17);
    v5 = *a2;
    *a2 = 0;
    v6 = *a1;
    *a1 = v5;
    if (v6)
      MEMORY[0x2426A04BC](v6, 0x1000C8000313F17);
    *((_WORD *)a1 + 4) = *((_WORD *)a2 + 4);
    *(uint64_t *)((char *)a1 + 12) = *(uint64_t *)((char *)a2 + 12);
    v7 = *a2;
    *a2 = 0;
    if (v7)
      MEMORY[0x2426A04BC](v7, 0x1000C8000313F17);
    *((_WORD *)a2 + 4) = 0;
    *((_DWORD *)a2 + 3) = 0;
    *((_DWORD *)a2 + 4) = 0;
  }
  return a1;
}

_DWORD *CLMicroLocationUtils::ProbabilityMatrix::removeFirstCols@<X0>(_DWORD *this@<X0>, unsigned int a2@<W1>, uint64_t a3@<X8>)
{
  unsigned int v4;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8[3];

  *(_BYTE *)a3 = 0;
  *(_BYTE *)(a3 + 24) = 0;
  v4 = this[4];
  if (v4 > a2)
  {
    v6 = (uint64_t)this;
    CLMicroLocationUtils::ProbabilityMatrix::ProbabilityMatrix((CLMicroLocationUtils::ProbabilityMatrix *)v8, this[3], v4 - a2);
    std::optional<CLMicroLocationUtils::ProbabilityMatrix>::operator=[abi:ne180100]<CLMicroLocationUtils::ProbabilityMatrix,void>(a3, v8);
    v7 = v8[0];
    v8[0] = 0;
    if (v7)
      MEMORY[0x2426A04BC](v7, 0x1000C8000313F17);
    this = memcpy(*(void **)a3, (const void *)(*(_QWORD *)v6 + 8 * *(_DWORD *)(v6 + 12) * a2), 8 * *(_DWORD *)(a3 + 16) * *(_DWORD *)(a3 + 12));
    *(_BYTE *)(a3 + 8) = 0;
  }
  return this;
}

void sub_241A5765C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  uint64_t *v10;
  uint64_t v12;

  if (a10)
    MEMORY[0x2426A04BC](a10, 0x1000C8000313F17);
  if (*((_BYTE *)v10 + 24))
  {
    v12 = *v10;
    *v10 = 0;
    if (v12)
      MEMORY[0x2426A04BC](v12, 0x1000C8000313F17);
  }
  _Unwind_Resume(exception_object);
}

uint64_t *std::optional<CLMicroLocationUtils::ProbabilityMatrix>::operator=[abi:ne180100]<CLMicroLocationUtils::ProbabilityMatrix,void>(uint64_t a1, uint64_t *a2)
{
  uint64_t *result;

  if (*(_BYTE *)(a1 + 24))
    return CLMicroLocationUtils::ProbabilityMatrix::operator=((uint64_t *)a1, a2);
  result = (uint64_t *)CLMicroLocationUtils::ProbabilityMatrix::ProbabilityMatrix(a1, a2);
  *((_BYTE *)result + 24) = 1;
  return result;
}

uint64_t CLMicroLocationUtils::ProbabilityMatrix::getValue(CLMicroLocationUtils::ProbabilityMatrix *this, int a2, int a3, double *a4)
{
  uint64_t result;
  int v6;

  if (a2 < 0)
    return 0;
  result = 0;
  if ((a3 & 0x80000000) == 0)
  {
    v6 = *((_DWORD *)this + 3);
    if (v6 > a2)
    {
      if (*((_DWORD *)this + 4) > a3)
      {
        *a4 = *(double *)(*(_QWORD *)this + 8 * (a2 + v6 * a3));
        return 1;
      }
      return 0;
    }
  }
  return result;
}

uint64_t CLMicroLocationUtils::ProbabilityMatrix::normalizeRows(CLMicroLocationUtils::ProbabilityMatrix *this)
{
  uint64_t result;
  uint64_t v3;
  int v4;
  _QWORD *v5;
  uint64_t v6;
  char v7;
  uint64_t v8;
  uint64_t v9;
  double v10;
  NSObject *v11;
  NSObject *v12;
  uint8_t buf[4];
  int v14;
  __int16 v15;
  const char *v16;
  __int16 v17;
  int v18;
  uint64_t v19;

  v19 = *MEMORY[0x24BDAC8D0];
  if (*((_BYTE *)this + 8))
    return 1;
  v3 = *((unsigned int *)this + 3);
  if (!(_DWORD)v3)
    goto LABEL_27;
  v4 = *((_DWORD *)this + 4);
  if (!v4)
    return 0;
  if (v4 == 1)
  {
    if ((int)v3 >= 1)
    {
      v5 = *(_QWORD **)this;
      do
      {
        *v5++ = 0x3FF0000000000000;
        --v3;
      }
      while (v3);
    }
    goto LABEL_27;
  }
  if ((int)v3 < 1)
  {
LABEL_27:
    result = 1;
    *((_BYTE *)this + 8) = 1;
    return result;
  }
  v6 = 0;
  v7 = 1;
  LODWORD(v8) = *((_DWORD *)this + 3);
  while (2)
  {
    v9 = 8 * v6;
    while (1)
    {
      v10 = cblas_dnrm2(*((_DWORD *)this + 4), (const double *)(*(_QWORD *)this + v9), v8);
      if (v10 == 0.0)
        break;
      cblas_dscal(*((_DWORD *)this + 4), 1.0 / v10, (double *)(*(_QWORD *)this + v9), *((_DWORD *)this + 3));
      ++v6;
      v8 = *((int *)this + 3);
      v9 += 8;
      if (v6 >= v8)
      {
        if ((v7 & 1) == 0)
          return 0;
        goto LABEL_27;
      }
    }
    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_43);
    v11 = logObject_MicroLocation_Default;
    if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 68289282;
      v14 = 0;
      v15 = 2082;
      v16 = "";
      v17 = 1026;
      v18 = v6;
      _os_log_impl(&dword_2419D9000, v11, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"ProbabilityMatrix::normalizeRows, row with zero norm!\", \"RowIndex\":%{public}d}", buf, 0x18u);
    }
    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_43);
    v12 = logObject_MicroLocation_Default;
    if (os_signpost_enabled((os_log_t)logObject_MicroLocation_Default))
    {
      *(_DWORD *)buf = 68289282;
      v14 = 0;
      v15 = 2082;
      v16 = "";
      v17 = 1026;
      v18 = v6;
      _os_signpost_emit_with_name_impl(&dword_2419D9000, v12, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "ProbabilityMatrix::normalizeRows, row with zero norm!", "{\"msg%{public}.0s\":\"ProbabilityMatrix::normalizeRows, row with zero norm!\", \"RowIndex\":%{public}d}", buf, 0x18u);
    }
    v7 = 0;
    result = 0;
    ++v6;
    v8 = *((int *)this + 3);
    if (v6 < v8)
      continue;
    return result;
  }
}

double CLMicroLocationUtils::ProbabilityMatrix::multByVec@<D0>(CLMicroLocationUtils::ProbabilityMatrix *this@<X0>, const CLMicroLocationUtils::ProbabilityMatrix *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v4;
  int v5;
  int v6;
  int v7;
  uint64_t v11;
  int v12;
  BOOL v13;
  CBLAS_TRANSPOSE v15;
  uint64_t v16;
  uint64_t v17;
  double result;
  double *__Y;
  __int16 v20;
  double v21;

  v4 = 12;
  if (!*((_BYTE *)this + 9))
    v4 = 16;
  v5 = *(_DWORD *)((char *)this + v4);
  if (*((_BYTE *)a2 + 9))
    v6 = *((_DWORD *)a2 + 4);
  else
    v6 = *((_DWORD *)a2 + 3);
  if (v5 != v6)
    goto LABEL_25;
  v7 = *((_BYTE *)a2 + 9) ? *((_DWORD *)a2 + 3) : *((_DWORD *)a2 + 4);
  if (v5 != 1 && v7 != 1)
    goto LABEL_25;
  v11 = 16;
  if (!*((_BYTE *)this + 9))
    v11 = 12;
  v12 = *(_DWORD *)((char *)this + v11);
  v13 = !v5 || v12 == 0;
  if (!v13 && v7 != 0)
  {
    CLMicroLocationUtils::ProbabilityMatrix::ProbabilityMatrix((CLMicroLocationUtils::ProbabilityMatrix *)&__Y, v12, v7);
    if (*((_BYTE *)this + 9))
      v15 = CblasTrans;
    else
      v15 = CblasNoTrans;
    v16 = 16;
    if (*((_BYTE *)this + 9))
      v17 = 16;
    else
      v17 = 12;
    if (*((_BYTE *)this + 9))
      v16 = 12;
    cblas_dgemv(CblasColMajor, v15, *(_DWORD *)((char *)this + v17), *(_DWORD *)((char *)this + v16), 1.0, *(const double **)this, *(_DWORD *)((char *)this + v17), *(const double **)a2, 1, 1.0, __Y, 1);
    *(_QWORD *)a3 = __Y;
    *(_WORD *)(a3 + 8) = v20;
    result = v21;
    *(double *)(a3 + 12) = v21;
    *(_BYTE *)(a3 + 24) = 1;
  }
  else
  {
LABEL_25:
    *(_BYTE *)a3 = 0;
    *(_BYTE *)(a3 + 24) = 0;
  }
  return result;
}

void sub_241A57AD4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  if (a12)
    MEMORY[0x2426A04BC](a12, 0x1000C8000313F17);
  _Unwind_Resume(exception_object);
}

uint64_t CLMicroLocationUtils::ProbabilityMatrix::appendRows(CLMicroLocationUtils::ProbabilityMatrix *this, const CLMicroLocationUtils::ProbabilityMatrix *a2, unsigned int a3)
{
  unsigned int v6;
  unsigned int v7;
  uint64_t v8;
  _BOOL4 v9;
  uint64_t result;
  unsigned int v11;
  const char *v12;
  NSObject *v13;
  uint64_t v14;
  _BOOL4 v15;
  unsigned int v16;
  unsigned int v17;
  NSObject *v18;
  unsigned int v19;
  unsigned int v20;
  unsigned int v21;
  unsigned int v22;
  NSObject *v23;
  unsigned int v24;
  int v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  unsigned int v29;
  unsigned int v30;
  unsigned int v31;
  uint64_t v32;
  size_t v33;
  CLMicroLocationUtils::ProbabilityMatrix *v34;
  const CLMicroLocationUtils::ProbabilityMatrix *v35;
  int v36;
  uint64_t v37;
  uint8_t buf[4];
  int v39;
  __int16 v40;
  const char *v41;
  __int16 v42;
  unsigned int v43;
  __int16 v44;
  unsigned int v45;
  __int16 v46;
  int v47;
  uint64_t v48;

  v48 = *MEMORY[0x24BDAC8D0];
  if (*((_DWORD *)a2 + 4) == *((_DWORD *)this + 4))
  {
    v6 = *((_DWORD *)a2 + 3);
    v7 = a3 - v6;
    if (a3 >= v6)
    {
      if (a3 == v6)
      {
        if (onceToken_MicroLocation_Default != -1)
          dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_43);
        v18 = logObject_MicroLocation_Default;
        if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT))
        {
          v19 = *((_DWORD *)a2 + 4);
          *(_DWORD *)buf = 68289538;
          v39 = 0;
          v40 = 2082;
          v41 = "";
          v42 = 1026;
          v43 = a3;
          v44 = 1026;
          v45 = v19;
          _os_log_impl(&dword_2419D9000, v18, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"rows to append are max length - copy\", \"MaxNumRows\":%{public}d, \"NumRowsToAppend\":%{public}d}", buf, 0x1Eu);
        }
        CLMicroLocationUtils::ProbabilityMatrix::operator=((uint64_t *)this, (uint64_t)a2);
      }
      else
      {
        v20 = *((_DWORD *)this + 3) + v6;
        if (v20 <= a3)
          v21 = *((_DWORD *)this + 3);
        else
          v21 = v7;
        if (v20 >= a3)
          v22 = a3;
        else
          v22 = v20;
        if (onceToken_MicroLocation_Default != -1)
          dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_43);
        v23 = logObject_MicroLocation_Default;
        if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT))
        {
          v24 = *((_DWORD *)this + 3);
          v25 = *((_DWORD *)a2 + 4);
          *(_DWORD *)buf = 68289794;
          v39 = 0;
          v40 = 2082;
          v41 = "";
          v42 = 1026;
          v43 = v24;
          v44 = 1026;
          v45 = v21;
          v46 = 1026;
          v47 = v25;
          _os_log_impl(&dword_2419D9000, v23, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"appending rows\", \"NumOldRows\":%{public}d, \"NumOldRowsToKeep\":%{public}d, \"NumRowsToAppend\":%{public}d}", buf, 0x24u);
        }
        v35 = a2;
        v26 = *((unsigned int *)this + 4);
        v27 = operator new[]();
        v34 = this;
        v28 = *(_QWORD *)this;
        if ((_DWORD)v26)
        {
          v29 = 0;
          v30 = 0;
          v31 = 0;
          v32 = *((int *)v35 + 3);
          v37 = *(_QWORD *)v35;
          v36 = *((_DWORD *)v34 + 3);
          v33 = 8 * v21;
          do
          {
            memcpy((void *)(v27 + 8 * v29), (const void *)(v37 + 8 * v30), 8 * v32);
            memcpy((void *)(v27 + 8 * v29 + 8 * v32), (const void *)(v28 + 8 * v31), v33);
            v31 += v36;
            v30 += v32;
            v29 += v22;
            --v26;
          }
          while (v26);
        }
        *(_QWORD *)v34 = v27;
        if (!*((_BYTE *)v35 + 8))
          *((_BYTE *)v34 + 8) = 0;
        *((_DWORD *)v34 + 3) = v22;
        if (v28)
          MEMORY[0x2426A04BC](v28, 0x1000C8000313F17);
      }
      return 1;
    }
    else
    {
      if (onceToken_MicroLocation_Default != -1)
        dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_43);
      v8 = logObject_MicroLocation_Default;
      v9 = os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT);
      result = 0;
      if (v9)
      {
        v11 = *((_DWORD *)a2 + 4);
        *(_DWORD *)buf = 68289538;
        v39 = 0;
        v40 = 2082;
        v41 = "";
        v42 = 1026;
        v43 = a3;
        v44 = 1026;
        v45 = v11;
        v12 = "{\"msg%{public}.0s\":\"cannot append rows more rows than allowed\", \"MaxNumRows\":%{public}d, \"NumRowsTo"
              "Append\":%{public}d}";
        v13 = v8;
LABEL_11:
        _os_log_impl(&dword_2419D9000, v13, OS_LOG_TYPE_DEFAULT, v12, buf, 0x1Eu);
        return 0;
      }
    }
  }
  else
  {
    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_43);
    v14 = logObject_MicroLocation_Default;
    v15 = os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT);
    result = 0;
    if (v15)
    {
      v16 = *((_DWORD *)this + 4);
      v17 = *((_DWORD *)a2 + 4);
      *(_DWORD *)buf = 68289538;
      v39 = 0;
      v40 = 2082;
      v41 = "";
      v42 = 1026;
      v43 = v16;
      v44 = 1026;
      v45 = v17;
      v12 = "{\"msg%{public}.0s\":\"cannot append rows with incompatible number of columns\", \"NumColumns\":%{public}d, "
            "\"OtherNumColumns\":%{public}d}";
      v13 = v14;
      goto LABEL_11;
    }
  }
  return result;
}

_QWORD *CLMicroLocationUtils::scanActivityToString@<X0>(char a1@<W0>, _QWORD *a2@<X8>)
{
  return std::string::basic_string[abi:ne180100]<0>(a2, off_2511D4F58[a1]);
}

uint64_t CLMicroLocationUtils::BleScanConfiguration::BleScanConfiguration(uint64_t a1, char a2, char a3, char a4, id obj, uint64_t a6, double a7)
{
  *(double *)a1 = a7;
  *(_BYTE *)(a1 + 8) = a2;
  *(_BYTE *)(a1 + 9) = a3;
  *(_BYTE *)(a1 + 10) = a4;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)a6;
  *(_QWORD *)(a1 + 40) = *(_QWORD *)(a6 + 16);
  *(_QWORD *)a6 = 0;
  *(_QWORD *)(a6 + 8) = 0;
  *(_QWORD *)(a6 + 16) = 0;
  objc_storeStrong((id *)(a1 + 16), obj);
  return a1;
}

_QWORD *CLMicroLocationUtils::placeConfidenceReasonToString@<X0>(int a1@<W0>, _QWORD *a2@<X8>)
{
  return std::string::basic_string[abi:ne180100]<0>(a2, off_2511D4F70[a1]);
}

unint64_t CLMicroLocationUtils::BleIdentityItem::HashItem::operator()(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  unint64_t result;

  v2 = 0;
  result = 0;
  do
    result ^= (result << 6) + (result >> 2) + 2654435769u + *(unsigned __int8 *)(a2 + v2++);
  while (v2 != 16);
  return result;
}

uint64_t CLMicroLocationUtils::BleIdentityItem::PredicateItem::operator()(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_QWORD *)a2 == *(_QWORD *)a3 && *(_QWORD *)(a2 + 8) == *(_QWORD *)(a3 + 8))
    return std::operator==[abi:ne180100]<std::string,std::string>((unsigned __int8 *)(a2 + 16), (unsigned __int8 *)(a3 + 16));
  else
    return 0;
}

uint64_t std::operator==[abi:ne180100]<std::string,std::string>(unsigned __int8 *a1, unsigned __int8 *a2)
{
  BOOL v2;
  _BOOL8 v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  uint64_t v8;
  int v9;
  int v10;
  int v11;
  int v12;
  BOOL v14;

  if (a1[24])
    v2 = a2[24] == 0;
  else
    v2 = 1;
  if (v2)
    return (a1[24] != 0) == (a2[24] != 0);
  v4 = a1[23];
  if ((v4 & 0x80u) == 0)
    v5 = a1[23];
  else
    v5 = *((_QWORD *)a1 + 1);
  v6 = a2[23];
  v7 = (char)v6;
  if ((v6 & 0x80u) != 0)
    v6 = *((_QWORD *)a2 + 1);
  if (v5 != v6)
    return 0;
  if (v7 < 0)
    a2 = *(unsigned __int8 **)a2;
  if ((v4 & 0x80) != 0)
    return memcmp(*(const void **)a1, a2, *((_QWORD *)a1 + 1)) == 0;
  if (!a1[23])
    return 1;
  v8 = v4 - 1;
  do
  {
    v10 = *a1++;
    v9 = v10;
    v12 = *a2++;
    v11 = v12;
    v14 = v8-- != 0;
    v2 = v9 == v11;
    v3 = v9 == v11;
  }
  while (v2 && v14);
  return v3;
}

uint64_t CLMicroLocationUtils::stopReasonToConfidenceReason(int a1)
{
  if ((a1 - 1) > 3)
    return 0;
  else
    return qword_241BB4E78[a1 - 1] | 0x100000000;
}

BOOL CLMicroLocationUtils::stopReasonIndicatesMiLoDisabled(int a1)
{
  return a1 == 1;
}

void ___ZL45_CLLogObjectForCategory_MicroLocation_Defaultv_block_invoke_36()
{
  os_log_t v0;
  void *v1;

  v0 = os_log_create("com.apple.MicroLocation", "MicroLocation");
  v1 = (void *)logObject_MicroLocation_Default;
  logObject_MicroLocation_Default = (uint64_t)v0;

}

void sub_241A58220(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

uint64_t ULDBUtils::insertEntries<CLMiLoServiceTable,ULServiceMO>(void *a1, uint64_t a2)
{
  id v3;
  void *v4;
  id v5;
  uint64_t v6;
  _QWORD v8[4];
  id v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  char v15;

  v3 = a1;
  v12 = 0;
  v13 = &v12;
  v14 = 0x2020000000;
  v15 = 0;
  objc_msgSend(v3, "managedObjectContext");
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  v8[0] = MEMORY[0x24BDAC760];
  v8[1] = 3221225472;
  v8[2] = ___ZN9ULDBUtils13insertEntriesI18CLMiLoServiceTable11ULServiceMOEEbP7ULStoreRKNSt3__16vectorINT_5EntryENS5_9allocatorIS8_EEEE_block_invoke;
  v8[3] = &unk_2511D22D0;
  v11 = a2;
  v5 = v3;
  v9 = v5;
  v10 = &v12;
  objc_msgSend(v4, "performBlockAndWait:", v8);

  v6 = *((unsigned __int8 *)v13 + 24);
  _Block_object_dispose(&v12, 8);

  return v6;
}

void sub_241A58344(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, void *a7, uint64_t a8, uint64_t a9, ...)
{
  void *v9;
  void *v10;
  va_list va;

  va_start(va, a9);

  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void ULDBUtils::fetchEntries<CLMiLoServiceTable,ULServiceMO>(void *a1@<X0>, void *a2@<X1>, void *a3@<X2>, uint64_t a4@<X3>, _QWORD *a5@<X8>)
{
  id v9;
  id v10;
  id v11;
  void *v12;
  id v13;
  id v14;
  id v15;
  uint64_t *v16;
  _QWORD v17[4];
  id v18;
  id v19;
  id v20;
  uint64_t *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t *v24;
  uint64_t v25;
  __n128 (*v26)(__n128 *, __n128 *);
  void (*v27)(uint64_t);
  void *v28;
  _QWORD v29[3];
  void **v30;

  v9 = a1;
  v10 = a2;
  v11 = a3;
  v23 = 0;
  v24 = &v23;
  v25 = 0x4812000000;
  v26 = __Block_byref_object_copy__8;
  v27 = __Block_byref_object_dispose__8;
  v28 = &unk_241BEBD1D;
  memset(v29, 0, sizeof(v29));
  objc_msgSend(v9, "managedObjectContext");
  v12 = (void *)objc_claimAutoreleasedReturnValue();
  v17[0] = MEMORY[0x24BDAC760];
  v17[1] = 3221225472;
  v17[2] = ___ZN9ULDBUtils12fetchEntriesI18CLMiLoServiceTable11ULServiceMOEENSt3__16vectorINT_5EntryENS3_9allocatorIS6_EEEEP7ULStoreP7NSArrayIP11NSPredicateEPSC_IP16NSSortDescriptorEm_block_invoke;
  v17[3] = &unk_2511D22F8;
  v13 = v10;
  v18 = v13;
  v14 = v11;
  v19 = v14;
  v22 = a4;
  v15 = v9;
  v20 = v15;
  v21 = &v23;
  objc_msgSend(v12, "performBlockAndWait:", v17);

  v16 = v24;
  a5[1] = 0;
  a5[2] = 0;
  *a5 = 0;
  std::vector<CLMiLoServiceTable::Entry>::__init_with_size[abi:ne180100]<CLMiLoServiceTable::Entry*,CLMiLoServiceTable::Entry*>(a5, v16[6], v16[7], 0x2E8BA2E8BA2E8BA3 * ((v16[7] - v16[6]) >> 3));

  _Block_object_dispose(&v23, 8);
  v30 = (void **)v29;
  std::vector<CLMiLoServiceTable::Entry>::__destroy_vector::operator()[abi:ne180100](&v30);

}

void sub_241A5850C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, void *a6, void *a7, void *a8, uint64_t a9, uint64_t a10, ...)
{
  void *v10;
  void *v11;
  void *v12;
  uint64_t v13;
  uint64_t v14;
  va_list va;

  va_start(va, a10);

  _Block_object_dispose(va, 8);
  *(_QWORD *)(v14 - 96) = v13;
  std::vector<CLMiLoServiceTable::Entry>::__destroy_vector::operator()[abi:ne180100]((void ***)(v14 - 96));

  _Unwind_Resume(a1);
}

void ULDBUtils::fetchAllWithLimit<CLMiLoServiceTable,ULServiceMO>(void *a1@<X0>, unsigned int a2@<W1>, _QWORD *a3@<X8>)
{
  id v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;
  _QWORD v10[2];

  v10[1] = *MEMORY[0x24BDAC8D0];
  v5 = a1;
  v6 = (void *)MEMORY[0x24BDD17C0];
  objc_msgSend((id)objc_opt_class(), "defaultSortProperty");
  v7 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v6, "sortDescriptorWithKey:ascending:", v7, 0);
  v8 = (void *)objc_claimAutoreleasedReturnValue();

  v10[0] = v8;
  objc_msgSend(MEMORY[0x24BDBCE30], "arrayWithObjects:count:", v10, 1);
  v9 = (void *)objc_claimAutoreleasedReturnValue();
  ULDBUtils::fetchEntries<CLMiLoServiceTable,ULServiceMO>(v5, 0, v9, a2, a3);

}

void sub_241A5866C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_241A587BC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_241A58950(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_241A58AA8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_241A58BFC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_241A58CFC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_241A58EF4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_241A59104(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_241A592E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, ...)
{
  void *v12;
  void *v13;
  void *v14;
  va_list va;

  va_start(va, a12);

  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_241A594C0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_241A59688(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, ...)
{
  void *v12;
  void *v13;
  void *v14;
  va_list va;

  va_start(va, a12);

  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_241A59860(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_241A59970(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_241A59A08(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_241A5A43C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21,uint64_t a22,void *a23,uint64_t a24,uint64_t a25,char a26,_QWORD *a27,uint64_t a28,char a29,_QWORD *a30,uint64_t a31,char a32)
{
  uint64_t v32;

  if (__p)
    operator delete(__p);
  if (a23)
    operator delete(a23);
  std::__tree<std::__value_type<std::pair<std::string,unsigned long long>,std::vector<CLMiLoServiceTable::Entry>>,std::__map_value_compare<std::pair<std::string,unsigned long long>,std::__value_type<std::pair<std::string,unsigned long long>,std::vector<CLMiLoServiceTable::Entry>>,std::less<std::pair<std::string,unsigned long long>>,true>,std::allocator<std::__value_type<std::pair<std::string,unsigned long long>,std::vector<CLMiLoServiceTable::Entry>>>>::destroy((uint64_t)&a26, a27);
  std::__tree<std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>,std::__map_value_compare<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>,std::less<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes>,true>,std::allocator<std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>>>::destroy((uint64_t)&a29, a30);
  *(_QWORD *)(v32 - 160) = &a32;
  std::vector<CLMiLoServiceTable::Entry>::__destroy_vector::operator()[abi:ne180100]((void ***)(v32 - 160));
  _Unwind_Resume(a1);
}

void sub_241A5A714(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  _Unwind_Resume(a1);
}

void sub_241A5A8AC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  _Unwind_Resume(a1);
}

void ___ZL45_CLLogObjectForCategory_MicroLocation_Defaultv_block_invoke_37()
{
  os_log_t v0;
  void *v1;

  v0 = os_log_create("com.apple.MicroLocation", "MicroLocation");
  v1 = (void *)logObject_MicroLocation_Default;
  logObject_MicroLocation_Default = (uint64_t)v0;

}

void ___ZN9ULDBUtils13insertEntriesI18CLMiLoServiceTable11ULServiceMOEEbP7ULStoreRKNSt3__16vectorINT_5EntryENS5_9allocatorIS8_EEEE_block_invoke(uint64_t a1)
{
  uint64_t *v2;
  uint64_t v3;
  uint64_t v4;
  void *v5;
  void *v6;
  NSObject *v7;
  void *v8;
  void *v9;
  NSObject *v10;
  void *v11;
  void *v12;
  void *v13;
  int v14;
  int v15;
  __int16 v16;
  const char *v17;
  __int16 v18;
  void *v19;
  uint64_t v20;

  v20 = *MEMORY[0x24BDAC8D0];
  v2 = *(uint64_t **)(a1 + 48);
  v3 = *v2;
  v4 = v2[1];
  if (*v2 == v4)
  {
LABEL_4:
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = objc_msgSend(*(id *)(a1 + 32), "commitChangesToStore");
    objc_msgSend(*(id *)(a1 + 32), "deleteOldestRecordsIfFull");
  }
  else
  {
    while (1)
    {
      objc_msgSend(*(id *)(a1 + 32), "managedObjectContext");
      v5 = (void *)objc_claimAutoreleasedReturnValue();
      +[ULServiceMO createFromEntry:inManagedObjectContext:](ULServiceMO, "createFromEntry:inManagedObjectContext:", v3, v5);
      v6 = (void *)objc_claimAutoreleasedReturnValue();

      if (!v6)
        break;

      v3 += 88;
      if (v3 == v4)
        goto LABEL_4;
    }
    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_44);
    v7 = (id)logObject_MicroLocation_Default;
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      +[ULServiceMO entity](ULServiceMO, "entity");
      v8 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v8, "name");
      v9 = (void *)objc_claimAutoreleasedReturnValue();
      v14 = 68289283;
      v15 = 0;
      v16 = 2082;
      v17 = "";
      v18 = 2113;
      v19 = v9;
      _os_log_impl(&dword_2419D9000, v7, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"Failed to create entry from MO\", \"MO\":%{private, location:escape_only}@}", (uint8_t *)&v14, 0x1Cu);

    }
    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_44);
    v10 = (id)logObject_MicroLocation_Default;
    if (os_signpost_enabled(v10))
    {
      +[ULServiceMO entity](ULServiceMO, "entity");
      v11 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v11, "name");
      v12 = (void *)objc_claimAutoreleasedReturnValue();
      v14 = 68289283;
      v15 = 0;
      v16 = 2082;
      v17 = "";
      v18 = 2113;
      v19 = v12;
      _os_signpost_emit_with_name_impl(&dword_2419D9000, v10, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Failed to create entry from MO", "{\"msg%{public}.0s\":\"Failed to create entry from MO\", \"MO\":%{private, location:escape_only}@}", (uint8_t *)&v14, 0x1Cu);

    }
    objc_msgSend(*(id *)(a1 + 32), "managedObjectContext");
    v13 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v13, "reset");

  }
}

void sub_241A5ABD0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

__n128 __Block_byref_object_copy__8(__n128 *a1, __n128 *a2)
{
  __n128 result;

  a1[3].n128_u64[0] = 0;
  a1[3].n128_u64[1] = 0;
  a1[4].n128_u64[0] = 0;
  result = a2[3];
  a1[3] = result;
  a1[4].n128_u64[0] = a2[4].n128_u64[0];
  a2[3].n128_u64[0] = 0;
  a2[3].n128_u64[1] = 0;
  a2[4].n128_u64[0] = 0;
  return result;
}

void __Block_byref_object_dispose__8(uint64_t a1)
{
  void **v1;

  v1 = (void **)(a1 + 48);
  std::vector<CLMiLoServiceTable::Entry>::__destroy_vector::operator()[abi:ne180100](&v1);
}

void ___ZN9ULDBUtils12fetchEntriesI18CLMiLoServiceTable11ULServiceMOEENSt3__16vectorINT_5EntryENS3_9allocatorIS6_EEEEP7ULStoreP7NSArrayIP11NSPredicateEPSC_IP16NSSortDescriptorEm_block_invoke(uint64_t a1)
{
  void *v2;
  objc_class *v3;
  void *v4;
  void *v5;
  uint64_t v6;
  void *v7;
  __int128 v8;
  uint64_t v9;
  void **v10;

  v2 = *(void **)(a1 + 48);
  v3 = (objc_class *)objc_opt_class();
  NSStringFromClass(v3);
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v2, "fetchManagedObjectsWithEntityName:byAndPredicates:sortDescriptors:andLimit:", v4, *(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 64));
  v5 = (void *)objc_claimAutoreleasedReturnValue();

  ULDBUtils::convertManagedObjectsToEntries<CLMiLoServiceTable,ULServiceMO>(v5, (uint64_t *)&v8);
  v6 = *(_QWORD *)(*(_QWORD *)(a1 + 56) + 8);
  std::vector<CLMiLoServiceTable::Entry>::__vdeallocate((void **)(v6 + 48));
  *(_OWORD *)(v6 + 48) = v8;
  *(_QWORD *)(v6 + 64) = v9;
  v9 = 0;
  v8 = 0uLL;
  v10 = (void **)&v8;
  std::vector<CLMiLoServiceTable::Entry>::__destroy_vector::operator()[abi:ne180100](&v10);
  objc_msgSend(*(id *)(a1 + 48), "managedObjectContext");
  v7 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v7, "reset");

}

void sub_241A5AD38(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void ULDBUtils::convertManagedObjectsToEntries<CLMiLoServiceTable,ULServiceMO>(void *a1@<X0>, uint64_t *a2@<X8>)
{
  id v3;
  id v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t i;
  id v8;
  void *v9;
  unint64_t v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  uint64_t v14;
  NSObject *v15;
  void *v16;
  void *v17;
  NSObject *v18;
  void *v19;
  void *v20;
  uint64_t j;
  uint64_t v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  uint8_t buf[4];
  int v28;
  __int16 v29;
  const char *v30;
  __int16 v31;
  void *v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  _BYTE v39[128];
  uint64_t v40;

  v40 = *MEMORY[0x24BDAC8D0];
  v3 = a1;
  a2[1] = 0;
  a2[2] = 0;
  *a2 = 0;
  std::vector<CLMiLoServiceTable::Entry>::reserve(a2, objc_msgSend(v3, "count"));
  v25 = 0u;
  v26 = 0u;
  v23 = 0u;
  v24 = 0u;
  v4 = v3;
  v5 = objc_msgSend(v4, "countByEnumeratingWithState:objects:count:", &v23, v39, 16);
  if (v5)
  {
    v6 = *(_QWORD *)v24;
    while (2)
    {
      for (i = 0; i != v5; ++i)
      {
        if (*(_QWORD *)v24 != v6)
          objc_enumerationMutation(v4);
        v8 = *(id *)(*((_QWORD *)&v23 + 1) + 8 * i);
        v9 = v8;
        if (!v8)
        {
          v37 = 0u;
          v38 = 0u;
          v35 = 0u;
          v36 = 0u;
          v33 = 0u;
          v34 = 0u;
LABEL_16:
          if (onceToken_MicroLocation_Default != -1)
            dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_44);
          v15 = (id)logObject_MicroLocation_Default;
          if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
          {
            objc_msgSend(v9, "entity");
            v16 = (void *)objc_claimAutoreleasedReturnValue();
            objc_msgSend(v16, "name");
            v17 = (void *)objc_claimAutoreleasedReturnValue();
            *(_DWORD *)buf = 68289283;
            v28 = 0;
            v29 = 2082;
            v30 = "";
            v31 = 2113;
            v32 = v17;
            _os_log_impl(&dword_2419D9000, v15, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"Failed to convert MO to entry\", \"MO\":%{private, location:escape_only}@}", buf, 0x1Cu);

          }
          if (onceToken_MicroLocation_Default != -1)
            dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_44);
          v18 = (id)logObject_MicroLocation_Default;
          if (os_signpost_enabled(v18))
          {
            objc_msgSend(v9, "entity");
            v19 = (void *)objc_claimAutoreleasedReturnValue();
            objc_msgSend(v19, "name");
            v20 = (void *)objc_claimAutoreleasedReturnValue();
            *(_DWORD *)buf = 68289283;
            v28 = 0;
            v29 = 2082;
            v30 = "";
            v31 = 2113;
            v32 = v20;
            _os_signpost_emit_with_name_impl(&dword_2419D9000, v18, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Failed to convert MO to entry", "{\"msg%{public}.0s\":\"Failed to convert MO to entry\", \"MO\":%{private, location:escape_only}@}", buf, 0x1Cu);

          }
          std::__optional_destruct_base<CLMiLoServiceTable::Entry,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)&v33);

          v22 = *a2;
          for (j = a2[1]; j != v22; std::allocator<CLMiLoServiceTable::Entry>::destroy[abi:ne180100]((uint64_t)(a2 + 2), j))j -= 88;
          a2[1] = v22;
          goto LABEL_28;
        }
        objc_msgSend(v8, "convertToEntry", (_QWORD)v23);
        if (!BYTE8(v38))
          goto LABEL_16;
        v10 = a2[1];
        if (v10 >= a2[2])
        {
          v14 = std::vector<CLMiLoServiceTable::Entry>::__push_back_slow_path<CLMiLoServiceTable::Entry>(a2, (uint64_t)&v33);
        }
        else
        {
          v11 = v34;
          *(_OWORD *)v10 = v33;
          *(_OWORD *)(v10 + 16) = v11;
          v12 = v35;
          *(_QWORD *)(v10 + 48) = v36;
          *(_OWORD *)(v10 + 32) = v12;
          *(_QWORD *)&v36 = 0;
          v35 = 0uLL;
          *(_QWORD *)(v10 + 56) = *((_QWORD *)&v36 + 1);
          v13 = v37;
          *(_QWORD *)(v10 + 80) = v38;
          *(_OWORD *)(v10 + 64) = v13;
          *(_QWORD *)&v38 = 0;
          v37 = 0uLL;
          v14 = v10 + 88;
        }
        a2[1] = v14;
        std::__optional_destruct_base<CLMiLoServiceTable::Entry,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)&v33);

      }
      v5 = objc_msgSend(v4, "countByEnumeratingWithState:objects:count:", &v23, v39, 16);
      if (v5)
        continue;
      break;
    }
  }

LABEL_28:
}

void sub_241A5B0F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  void *v13;
  void *v14;
  void *v15;
  void *v16;
  void *v17;
  va_list va;

  va_start(va, a13);

  std::__optional_destruct_base<CLMiLoServiceTable::Entry,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)va);
  std::vector<CLMiLoServiceTable::Entry>::__destroy_vector::operator()[abi:ne180100]((void ***)va);

  _Unwind_Resume(a1);
}

uint64_t std::vector<CLMiLoServiceTable::Entry>::__push_back_slow_path<CLMiLoServiceTable::Entry>(uint64_t *a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  char *v10;
  char *v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  uint64_t v15;
  void *v17[5];

  v3 = *a1;
  v4 = 0x2E8BA2E8BA2E8BA3 * ((a1[1] - *a1) >> 3);
  v5 = v4 + 1;
  if ((unint64_t)(v4 + 1) > 0x2E8BA2E8BA2E8BALL)
    std::vector<CLMicroLocationProto::ConfidenceReason>::__throw_length_error[abi:ne180100]();
  v7 = (uint64_t)(a1 + 2);
  v8 = 0x2E8BA2E8BA2E8BA3 * ((a1[2] - v3) >> 3);
  if (2 * v8 > v5)
    v5 = 2 * v8;
  if (v8 >= 0x1745D1745D1745DLL)
    v9 = 0x2E8BA2E8BA2E8BALL;
  else
    v9 = v5;
  v17[4] = a1 + 2;
  if (v9)
    v10 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<CLMiLoServiceTable::Entry>>(v7, v9);
  else
    v10 = 0;
  v11 = &v10[88 * v4];
  v17[0] = v10;
  v17[1] = v11;
  v17[3] = &v10[88 * v9];
  v12 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)v11 = *(_OWORD *)a2;
  *((_OWORD *)v11 + 1) = v12;
  v13 = *(_OWORD *)(a2 + 32);
  *((_QWORD *)v11 + 6) = *(_QWORD *)(a2 + 48);
  *((_OWORD *)v11 + 2) = v13;
  *(_QWORD *)(a2 + 40) = 0;
  *(_QWORD *)(a2 + 48) = 0;
  *(_QWORD *)(a2 + 32) = 0;
  *((_QWORD *)v11 + 7) = *(_QWORD *)(a2 + 56);
  v14 = *(_OWORD *)(a2 + 64);
  *((_QWORD *)v11 + 10) = *(_QWORD *)(a2 + 80);
  *((_OWORD *)v11 + 4) = v14;
  *(_QWORD *)(a2 + 72) = 0;
  *(_QWORD *)(a2 + 80) = 0;
  *(_QWORD *)(a2 + 64) = 0;
  v17[2] = v11 + 88;
  std::vector<CLMiLoServiceTable::Entry>::__swap_out_circular_buffer(a1, v17);
  v15 = a1[1];
  std::__split_buffer<CLMiLoServiceTable::Entry>::~__split_buffer(v17);
  return v15;
}

void sub_241A5B2B0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__split_buffer<CLMiLoServiceTable::Entry>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

void std::vector<CLMiLoServiceTable::Entry>::__vdeallocate(void **a1)
{
  void *v1;
  uint64_t v3;
  void *v4;

  v1 = *a1;
  if (*a1)
  {
    v3 = (uint64_t)a1[1];
    v4 = *a1;
    if ((void *)v3 != v1)
    {
      do
      {
        v3 -= 88;
        std::allocator<CLMiLoServiceTable::Entry>::destroy[abi:ne180100]((uint64_t)(a1 + 2), v3);
      }
      while ((void *)v3 != v1);
      v4 = *a1;
    }
    a1[1] = v1;
    operator delete(v4);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

_QWORD *std::vector<CLMiLoServiceTable::Entry>::__init_with_size[abi:ne180100]<CLMiLoServiceTable::Entry*,CLMiLoServiceTable::Entry*>(_QWORD *result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  _QWORD *v6;

  if (a4)
  {
    v6 = result;
    std::vector<CLMiLoServiceTable::Entry>::__vallocate[abi:ne180100](result, a4);
    result = (_QWORD *)std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<CLMiLoServiceTable::Entry>,CLMiLoServiceTable::Entry*,CLMiLoServiceTable::Entry*,CLMiLoServiceTable::Entry*>((uint64_t)(v6 + 2), a2, a3, v6[1]);
    v6[1] = result;
  }
  return result;
}

void sub_241A5B394(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  uint64_t v9;
  uint64_t v10;

  *(_QWORD *)(v9 + 8) = v10;
  std::vector<CLMiLoServiceTable::Entry>::__destroy_vector::operator()[abi:ne180100](&a9);
  _Unwind_Resume(a1);
}

char *std::vector<CLMiLoServiceTable::Entry>::__vallocate[abi:ne180100](_QWORD *a1, unint64_t a2)
{
  char *result;
  uint64_t v4;

  if (a2 >= 0x2E8BA2E8BA2E8BBLL)
    std::vector<CLMicroLocationProto::ConfidenceReason>::__throw_length_error[abi:ne180100]();
  result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<CLMiLoServiceTable::Entry>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[88 * v4];
  return result;
}

uint64_t *std::__tree<std::__value_type<unsigned long long,unsigned long>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,unsigned long>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,unsigned long>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>(uint64_t **a1, unint64_t *a2, uint64_t a3, uint64_t **a4)
{
  uint64_t *v6;
  uint64_t **v7;
  unint64_t v8;
  uint64_t **v9;
  unint64_t v10;
  uint64_t *v11;

  v7 = a1 + 1;
  v6 = a1[1];
  if (v6)
  {
    v8 = *a2;
    while (1)
    {
      while (1)
      {
        v9 = (uint64_t **)v6;
        v10 = v6[4];
        if (v8 >= v10)
          break;
        v6 = *v9;
        v7 = v9;
        if (!*v9)
          goto LABEL_10;
      }
      if (v10 >= v8)
        break;
      v6 = v9[1];
      if (!v6)
      {
        v7 = v9 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    v9 = a1 + 1;
LABEL_10:
    v11 = (uint64_t *)operator new(0x30uLL);
    v11[4] = **a4;
    v11[5] = 0;
    std::__tree<CLMicroLocationRecordingCompletionMetaInformation::RecordingError>::__insert_node_at(a1, (uint64_t)v9, v7, v11);
    return v11;
  }
  return (uint64_t *)v9;
}

void std::__tree<std::__value_type<std::pair<std::string,unsigned long long>,std::vector<CLMiLoServiceTable::Entry>>,std::__map_value_compare<std::pair<std::string,unsigned long long>,std::__value_type<std::pair<std::string,unsigned long long>,std::vector<CLMiLoServiceTable::Entry>>,std::less<std::pair<std::string,unsigned long long>>,true>,std::allocator<std::__value_type<std::pair<std::string,unsigned long long>,std::vector<CLMiLoServiceTable::Entry>>>>::destroy(uint64_t a1, _QWORD *a2)
{
  if (a2)
  {
    std::__tree<std::__value_type<std::pair<std::string,unsigned long long>,std::vector<CLMiLoServiceTable::Entry>>,std::__map_value_compare<std::pair<std::string,unsigned long long>,std::__value_type<std::pair<std::string,unsigned long long>,std::vector<CLMiLoServiceTable::Entry>>,std::less<std::pair<std::string,unsigned long long>>,true>,std::allocator<std::__value_type<std::pair<std::string,unsigned long long>,std::vector<CLMiLoServiceTable::Entry>>>>::destroy(a1, *a2);
    std::__tree<std::__value_type<std::pair<std::string,unsigned long long>,std::vector<CLMiLoServiceTable::Entry>>,std::__map_value_compare<std::pair<std::string,unsigned long long>,std::__value_type<std::pair<std::string,unsigned long long>,std::vector<CLMiLoServiceTable::Entry>>,std::less<std::pair<std::string,unsigned long long>>,true>,std::allocator<std::__value_type<std::pair<std::string,unsigned long long>,std::vector<CLMiLoServiceTable::Entry>>>>::destroy(a1, a2[1]);
    std::__destroy_at[abi:ne180100]<std::pair<std::pair<std::string,unsigned long long> const,std::vector<CLMiLoServiceTable::Entry>>,0>((uint64_t)(a2 + 4));
    operator delete(a2);
  }
}

void std::__destroy_at[abi:ne180100]<std::pair<std::pair<std::string,unsigned long long> const,std::vector<CLMiLoServiceTable::Entry>>,0>(uint64_t a1)
{
  void **v2;

  v2 = (void **)(a1 + 32);
  std::vector<CLMiLoServiceTable::Entry>::__destroy_vector::operator()[abi:ne180100](&v2);
  if (*(char *)(a1 + 23) < 0)
    operator delete(*(void **)a1);
}

_QWORD *std::__tree<std::__value_type<std::pair<std::string,unsigned long long>,std::vector<CLMiLoServiceTable::Entry>>,std::__map_value_compare<std::pair<std::string,unsigned long long>,std::__value_type<std::pair<std::string,unsigned long long>,std::vector<CLMiLoServiceTable::Entry>>,std::less<std::pair<std::string,unsigned long long>>,true>,std::allocator<std::__value_type<std::pair<std::string,unsigned long long>,std::vector<CLMiLoServiceTable::Entry>>>>::__emplace_unique_key_args<std::pair<std::string,unsigned long long>,std::piecewise_construct_t const&,std::tuple<std::pair<std::string,unsigned long long>&&>,std::tuple<>>(uint64_t **a1, const void **a2, uint64_t a3, __int128 **a4)
{
  void **v6;
  _QWORD *v7;
  uint64_t **v8;
  __int128 *v9;
  __int128 v10;
  _QWORD v12[2];
  char v13;
  uint64_t v14;

  v6 = (void **)std::__tree<std::__value_type<std::pair<std::string,unsigned long long>,std::vector<CLMiLoServiceTable::Entry>>,std::__map_value_compare<std::pair<std::string,unsigned long long>,std::__value_type<std::pair<std::string,unsigned long long>,std::vector<CLMiLoServiceTable::Entry>>,std::less<std::pair<std::string,unsigned long long>>,true>,std::allocator<std::__value_type<std::pair<std::string,unsigned long long>,std::vector<CLMiLoServiceTable::Entry>>>>::__find_equal<std::pair<std::string,unsigned long long>>((uint64_t)a1, &v14, a2);
  v7 = *v6;
  if (!*v6)
  {
    v8 = (uint64_t **)v6;
    v7 = operator new(0x58uLL);
    v12[1] = a1 + 1;
    v9 = *a4;
    v10 = **a4;
    v7[6] = *((_QWORD *)*a4 + 2);
    *((_OWORD *)v7 + 2) = v10;
    *((_QWORD *)v9 + 1) = 0;
    *((_QWORD *)v9 + 2) = 0;
    *(_QWORD *)v9 = 0;
    v7[7] = *((_QWORD *)v9 + 3);
    v7[8] = 0;
    v7[9] = 0;
    v7[10] = 0;
    v13 = 1;
    std::__tree<CLMicroLocationRecordingCompletionMetaInformation::RecordingError>::__insert_node_at(a1, v14, v8, v7);
    v12[0] = 0;
    std::unique_ptr<std::__tree_node<std::__value_type<std::pair<std::string,unsigned long long>,std::vector<CLMiLoServiceTable::Entry>>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::pair<std::string,unsigned long long>,std::vector<CLMiLoServiceTable::Entry>>,void *>>>>::reset[abi:ne180100]((uint64_t)v12, 0);
  }
  return v7;
}

_QWORD *std::__tree<std::__value_type<std::pair<std::string,unsigned long long>,std::vector<CLMiLoServiceTable::Entry>>,std::__map_value_compare<std::pair<std::string,unsigned long long>,std::__value_type<std::pair<std::string,unsigned long long>,std::vector<CLMiLoServiceTable::Entry>>,std::less<std::pair<std::string,unsigned long long>>,true>,std::allocator<std::__value_type<std::pair<std::string,unsigned long long>,std::vector<CLMiLoServiceTable::Entry>>>>::__find_equal<std::pair<std::string,unsigned long long>>(uint64_t a1, _QWORD *a2, const void **a3)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v7;
  _QWORD *v8;
  const void **v9;

  v5 = (_QWORD *)(a1 + 8);
  v4 = *(_QWORD *)(a1 + 8);
  if (v4)
  {
    v7 = a1 + 16;
    do
    {
      while (1)
      {
        v8 = (_QWORD *)v4;
        v9 = (const void **)(v4 + 32);
        if (!std::less<std::pair<std::string,unsigned long long>>::operator()[abi:ne180100](v7, a3, (const void **)(v4 + 32)))break;
        v4 = *v8;
        v5 = v8;
        if (!*v8)
          goto LABEL_10;
      }
      if (!std::less<std::pair<std::string,unsigned long long>>::operator()[abi:ne180100](v7, v9, a3))
        break;
      v5 = v8 + 1;
      v4 = v8[1];
    }
    while (v4);
  }
  else
  {
    v8 = (_QWORD *)(a1 + 8);
  }
LABEL_10:
  *a2 = v8;
  return v5;
}

BOOL std::less<std::pair<std::string,unsigned long long>>::operator()[abi:ne180100](uint64_t a1, const void **a2, const void **a3)
{
  int v5;
  int v6;
  size_t v7;
  const void *v8;
  size_t v9;
  const void *v10;
  size_t v11;
  int v12;
  BOOL v13;
  int v15;
  BOOL v16;

  v5 = *((char *)a3 + 23);
  v6 = *((char *)a2 + 23);
  if (v6 >= 0)
    v7 = *((unsigned __int8 *)a2 + 23);
  else
    v7 = (size_t)a2[1];
  if (v6 >= 0)
    v8 = a2;
  else
    v8 = *a2;
  if (v5 >= 0)
    v9 = *((unsigned __int8 *)a3 + 23);
  else
    v9 = (size_t)a3[1];
  if (v5 >= 0)
    v10 = a3;
  else
    v10 = *a3;
  if (v9 >= v7)
    v11 = v7;
  else
    v11 = v9;
  v12 = memcmp(v8, v10, v11);
  v13 = v7 < v9;
  if (v12)
    v13 = v12 < 0;
  if (v13)
    return 1;
  v15 = memcmp(v10, v8, v11);
  v16 = v9 < v7;
  if (v15)
    v16 = v15 < 0;
  return !v16 && a2[3] < a3[3];
}

void std::unique_ptr<std::__tree_node<std::__value_type<std::pair<std::string,unsigned long long>,std::vector<CLMiLoServiceTable::Entry>>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::pair<std::string,unsigned long long>,std::vector<CLMiLoServiceTable::Entry>>,void *>>>>::reset[abi:ne180100](uint64_t a1, uint64_t a2)
{
  void *v2;

  v2 = *(void **)a1;
  *(_QWORD *)a1 = a2;
  if (v2)
  {
    if (*(_BYTE *)(a1 + 16))
      std::__destroy_at[abi:ne180100]<std::pair<std::pair<std::string,unsigned long long> const,std::vector<CLMiLoServiceTable::Entry>>,0>((uint64_t)v2 + 32);
    operator delete(v2);
  }
}

uint64_t std::vector<CLMiLoServiceTable::Entry>::__emplace_back_slow_path<CLMiLoServiceTable::Entry const&>(uint64_t *a1, uint64_t a2)
{
  uint64_t v3;
  unint64_t v4;
  unint64_t v6;
  char *v7;
  uint64_t v8;
  void *v10;
  char *v11;
  char *v12;
  char *v13;
  uint64_t *v14;

  v3 = 0x2E8BA2E8BA2E8BA3 * ((a1[1] - *a1) >> 3);
  v4 = v3 + 1;
  if ((unint64_t)(v3 + 1) > 0x2E8BA2E8BA2E8BALL)
    std::vector<CLMicroLocationProto::ConfidenceReason>::__throw_length_error[abi:ne180100]();
  if (0x5D1745D1745D1746 * ((a1[2] - *a1) >> 3) > v4)
    v4 = 0x5D1745D1745D1746 * ((a1[2] - *a1) >> 3);
  if ((unint64_t)(0x2E8BA2E8BA2E8BA3 * ((a1[2] - *a1) >> 3)) >= 0x1745D1745D1745DLL)
    v6 = 0x2E8BA2E8BA2E8BALL;
  else
    v6 = v4;
  v14 = a1 + 2;
  if (v6)
    v7 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<CLMiLoServiceTable::Entry>>((uint64_t)(a1 + 2), v6);
  else
    v7 = 0;
  v10 = v7;
  v11 = &v7[88 * v3];
  v13 = &v7[88 * v6];
  std::allocator<CLMiLoServiceTable::Entry>::construct[abi:ne180100]<CLMiLoServiceTable::Entry,CLMiLoServiceTable::Entry const&>((uint64_t)(a1 + 2), (uint64_t)v11, a2);
  v12 = v11 + 88;
  std::vector<CLMiLoServiceTable::Entry>::__swap_out_circular_buffer(a1, &v10);
  v8 = a1[1];
  std::__split_buffer<CLMiLoServiceTable::Entry>::~__split_buffer(&v10);
  return v8;
}

void sub_241A5B8E8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__split_buffer<CLMiLoServiceTable::Entry>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

void std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:ne180100]<CLMiLoServiceTable::Entry *&,CLMiLoServiceTable::Entry *&>(__int128 **a1, uint64_t *a2)
{
  __int128 *v2;
  uint64_t v3;
  uint64_t v4;
  char v5;
  uint64_t v6;
  uint64_t v7;
  _OWORD *v8;
  char v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  int v13;
  _BYTE v14[15];
  _BYTE v15[15];
  __int128 v16;
  __int128 v17;

  v2 = *a1;
  v3 = *a2;
  v16 = **a1;
  v17 = (*a1)[1];
  v4 = *((_QWORD *)*a1 + 4);
  *(_QWORD *)v15 = *((_QWORD *)*a1 + 5);
  *(_QWORD *)&v15[7] = *(_QWORD *)((char *)*a1 + 47);
  v5 = *((_BYTE *)*a1 + 55);
  *((_QWORD *)v2 + 5) = 0;
  *((_QWORD *)v2 + 6) = 0;
  *((_QWORD *)v2 + 4) = 0;
  v6 = *((_QWORD *)v2 + 7);
  v8 = v2 + 4;
  v7 = *((_QWORD *)v2 + 8);
  *(_QWORD *)&v14[7] = *(_QWORD *)((char *)v2 + 79);
  *(_QWORD *)v14 = *((_QWORD *)v2 + 9);
  v9 = *((_BYTE *)v2 + 87);
  *((_QWORD *)v2 + 8) = 0;
  *((_QWORD *)v2 + 9) = 0;
  *((_QWORD *)v2 + 10) = 0;
  v10 = *(_OWORD *)(v3 + 16);
  *v2 = *(_OWORD *)v3;
  v2[1] = v10;
  v11 = *(_OWORD *)(v3 + 32);
  *((_QWORD *)v2 + 6) = *(_QWORD *)(v3 + 48);
  v2[2] = v11;
  *(_BYTE *)(v3 + 55) = 0;
  *(_BYTE *)(v3 + 32) = 0;
  *((_QWORD *)v2 + 7) = *(_QWORD *)(v3 + 56);
  if (*((char *)v2 + 87) < 0)
    operator delete(*(void **)v8);
  v12 = *(_OWORD *)(v3 + 64);
  *((_QWORD *)v8 + 2) = *(_QWORD *)(v3 + 80);
  *v8 = v12;
  *(_BYTE *)(v3 + 87) = 0;
  *(_BYTE *)(v3 + 64) = 0;
  *(_OWORD *)v3 = v16;
  *(_OWORD *)(v3 + 16) = v17;
  if (*(char *)(v3 + 55) < 0)
  {
    operator delete(*(void **)(v3 + 32));
    v13 = *(char *)(v3 + 87);
    *(_QWORD *)(v3 + 32) = v4;
    *(_QWORD *)(v3 + 40) = *(_QWORD *)v15;
    *(_QWORD *)(v3 + 47) = *(_QWORD *)&v15[7];
    *(_BYTE *)(v3 + 55) = v5;
    *(_QWORD *)(v3 + 56) = v6;
    if (v13 < 0)
      operator delete(*(void **)(v3 + 64));
  }
  else
  {
    *(_QWORD *)(v3 + 32) = v4;
    *(_QWORD *)(v3 + 40) = *(_QWORD *)v15;
    *(_QWORD *)(v3 + 47) = *(_QWORD *)&v15[7];
    *(_BYTE *)(v3 + 55) = v5;
    *(_QWORD *)(v3 + 56) = v6;
  }
  *(_QWORD *)(v3 + 64) = v7;
  *(_QWORD *)(v3 + 72) = *(_QWORD *)v14;
  *(_QWORD *)(v3 + 79) = *(_QWORD *)&v14[7];
  *(_BYTE *)(v3 + 87) = v9;
}

void std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,-[ULServiceStore deleteOldestsServicesPerClientAboveMaxCount]::$_0 &,CLMiLoServiceTable::Entry *>(double *a1, double *a2, uint64_t a3)
{
  double v3;
  double v4;
  double **v5;
  uint64_t *v6;
  uint64_t v7;
  double *v8;
  double *v9;

  v9 = a1;
  v7 = a3;
  v8 = a2;
  v3 = a2[3];
  v4 = *(double *)(a3 + 24);
  if (v3 < a1[3])
  {
    v5 = &v9;
    if (v4 >= v3)
    {
      std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:ne180100]<CLMiLoServiceTable::Entry *&,CLMiLoServiceTable::Entry *&>((__int128 **)&v9, (uint64_t *)&v8);
      if (*(double *)(v7 + 24) >= v8[3])
        return;
      v5 = &v8;
    }
    v6 = &v7;
    goto LABEL_9;
  }
  if (v4 < v3)
  {
    std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:ne180100]<CLMiLoServiceTable::Entry *&,CLMiLoServiceTable::Entry *&>((__int128 **)&v8, &v7);
    if (v8[3] < v9[3])
    {
      v5 = &v9;
      v6 = (uint64_t *)&v8;
LABEL_9:
      std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:ne180100]<CLMiLoServiceTable::Entry *&,CLMiLoServiceTable::Entry *&>((__int128 **)v5, v6);
    }
  }
}

BOOL std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,-[ULServiceStore deleteOldestsServicesPerClientAboveMaxCount]::$_0 &,CLMiLoServiceTable::Entry *>(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  _BOOL8 result;
  __int128 **v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  double v12;
  char v13;
  uint64_t v14;
  char v15;
  __int128 v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  _OWORD *v20;
  __int128 v21;
  void **v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  char v28;
  char v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  double *v33;
  _BYTE v34[22];
  _BYTE v35[15];
  __int128 v36;
  uint64_t v37;
  uint64_t v38;

  v38 = *MEMORY[0x24BDAC8D0];
  v31 = a1;
  v4 = 0x2E8BA2E8BA2E8BA3 * ((a2 - a1) >> 3);
  result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      v30 = a2 - 88;
      if (*(double *)(a2 - 64) < *(double *)(a1 + 24))
      {
        v6 = (__int128 **)&v31;
        v7 = &v30;
        goto LABEL_4;
      }
      return result;
    case 3:
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,-[ULServiceStore deleteOldestsServicesPerClientAboveMaxCount]::$_0 &,CLMiLoServiceTable::Entry *>((double *)a1, (double *)(a1 + 88), a2 - 88);
      return 1;
    case 4:
      std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,-[ULServiceStore deleteOldestsServicesPerClientAboveMaxCount]::$_0 &,CLMiLoServiceTable::Entry *>(a1, (double *)(a1 + 88), a1 + 176, a2 - 88);
      return 1;
    case 5:
      *(_QWORD *)&v36 = a1;
      v33 = (double *)(a1 + 264);
      *(_QWORD *)v34 = a1 + 88;
      *(_QWORD *)v35 = a1 + 176;
      v32 = a2 - 88;
      std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,-[ULServiceStore deleteOldestsServicesPerClientAboveMaxCount]::$_0 &,CLMiLoServiceTable::Entry *>(a1, (double *)(a1 + 88), a1 + 176, a1 + 264);
      if (*(double *)(a2 - 64) < *(double *)(a1 + 288))
      {
        std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:ne180100]<CLMiLoServiceTable::Entry *&,CLMiLoServiceTable::Entry *&>((__int128 **)&v33, &v32);
        if (v33[3] < *(double *)(a1 + 200))
        {
          std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:ne180100]<CLMiLoServiceTable::Entry *&,CLMiLoServiceTable::Entry *&>((__int128 **)v35, (uint64_t *)&v33);
          if (*(double *)(*(_QWORD *)v35 + 24) < *(double *)(a1 + 112))
          {
            std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:ne180100]<CLMiLoServiceTable::Entry *&,CLMiLoServiceTable::Entry *&>((__int128 **)v34, (uint64_t *)v35);
            if (*(double *)(*(_QWORD *)v34 + 24) < *(double *)(a1 + 24))
            {
              v6 = (__int128 **)&v36;
              v7 = (uint64_t *)v34;
LABEL_4:
              std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:ne180100]<CLMiLoServiceTable::Entry *&,CLMiLoServiceTable::Entry *&>(v6, v7);
            }
          }
        }
      }
      return 1;
    default:
      v8 = a1 + 176;
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,-[ULServiceStore deleteOldestsServicesPerClientAboveMaxCount]::$_0 &,CLMiLoServiceTable::Entry *>((double *)a1, (double *)(a1 + 88), a1 + 176);
      v9 = a1 + 264;
      if (a1 + 264 == a2)
        return 1;
      v10 = 0;
      v11 = 0;
      break;
  }
  while (1)
  {
    v12 = *(double *)(v9 + 24);
    if (v12 < *(double *)(v8 + 24))
    {
      v36 = *(_OWORD *)v9;
      v37 = *(_QWORD *)(v9 + 16);
      v27 = *(_QWORD *)(v9 + 32);
      *(_QWORD *)v35 = *(_QWORD *)(v9 + 40);
      *(_QWORD *)&v35[7] = *(_QWORD *)(v9 + 47);
      v13 = *(_BYTE *)(v9 + 55);
      *(_QWORD *)(v9 + 40) = 0;
      *(_QWORD *)(v9 + 48) = 0;
      *(_QWORD *)(v9 + 32) = 0;
      v14 = *(_QWORD *)(v9 + 56);
      v15 = *(_BYTE *)(v9 + 64);
      v16 = *(_OWORD *)(v9 + 65);
      *(_QWORD *)&v34[14] = *(_QWORD *)(v9 + 79);
      *(_OWORD *)v34 = v16;
      v28 = *(_BYTE *)(v9 + 87);
      v29 = v15;
      *(_QWORD *)(v9 + 64) = 0;
      *(_QWORD *)(v9 + 72) = 0;
      v17 = v10;
      *(_QWORD *)(v9 + 80) = 0;
      while (1)
      {
        v18 = v17;
        v19 = a1 + v17;
        v20 = (_OWORD *)(a1 + v17 + 264);
        v21 = *(_OWORD *)(v19 + 192);
        *v20 = *(_OWORD *)(v19 + 176);
        v20[1] = v21;
        v22 = (void **)(v19 + 296);
        if (*(char *)(v19 + 319) < 0)
          operator delete(*v22);
        *(_OWORD *)v22 = *(_OWORD *)(v19 + 208);
        *(_QWORD *)(v19 + 312) = *(_QWORD *)(v19 + 224);
        *(_BYTE *)(v19 + 231) = 0;
        *(_BYTE *)(v19 + 208) = 0;
        *(_QWORD *)(v19 + 320) = *(_QWORD *)(v19 + 232);
        v23 = v19 + 328;
        if (*(char *)(v19 + 351) < 0)
          operator delete(*(void **)v23);
        v24 = a1 + v18;
        *(_OWORD *)v23 = *(_OWORD *)(a1 + v18 + 240);
        *(_QWORD *)(v23 + 16) = *(_QWORD *)(a1 + v18 + 256);
        *(_BYTE *)(v24 + 263) = 0;
        *(_BYTE *)(v24 + 240) = 0;
        if (v18 == -176)
          break;
        v17 = v18 - 88;
        if (v12 >= *(double *)(v24 + 112))
        {
          v25 = a1 + v17 + 264;
          goto LABEL_17;
        }
      }
      v25 = a1;
LABEL_17:
      *(_OWORD *)v25 = v36;
      *(_QWORD *)(v25 + 16) = v37;
      *(double *)(v25 + 24) = v12;
      if (*(char *)(v25 + 55) < 0)
        operator delete(*(void **)(v24 + 208));
      *(_QWORD *)(v24 + 208) = v27;
      v26 = a1 + v18;
      *(_QWORD *)(v26 + 216) = *(_QWORD *)v35;
      *(_QWORD *)(v26 + 223) = *(_QWORD *)&v35[7];
      *(_BYTE *)(v24 + 231) = v13;
      *(_QWORD *)(v25 + 56) = v14;
      if (*(char *)(v25 + 87) < 0)
        operator delete(*(void **)(v24 + 240));
      *(_BYTE *)(v24 + 240) = v29;
      *(_OWORD *)(v26 + 241) = *(_OWORD *)v34;
      *(_QWORD *)(v26 + 255) = *(_QWORD *)&v34[14];
      *(_BYTE *)(v24 + 263) = v28;
      if (++v11 == 8)
        return v9 + 88 == a2;
    }
    v8 = v9;
    v10 += 88;
    v9 += 88;
    if (v9 == a2)
      return 1;
  }
}

void std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,-[ULServiceStore deleteOldestsServicesPerClientAboveMaxCount]::$_0 &,CLMiLoServiceTable::Entry *>(uint64_t a1, double *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8;
  double *v9;
  double *v10;
  __int128 *v11;

  v10 = a2;
  v11 = (__int128 *)a1;
  v8 = a4;
  v9 = (double *)a3;
  std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,-[ULServiceStore deleteOldestsServicesPerClientAboveMaxCount]::$_0 &,CLMiLoServiceTable::Entry *>((double *)a1, a2, a3);
  if (*(double *)(a4 + 24) < *(double *)(a3 + 24))
  {
    std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:ne180100]<CLMiLoServiceTable::Entry *&,CLMiLoServiceTable::Entry *&>((__int128 **)&v9, &v8);
    if (v9[3] < a2[3])
    {
      std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:ne180100]<CLMiLoServiceTable::Entry *&,CLMiLoServiceTable::Entry *&>((__int128 **)&v10, (uint64_t *)&v9);
      if (v10[3] < *(double *)(a1 + 24))
        std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:ne180100]<CLMiLoServiceTable::Entry *&,CLMiLoServiceTable::Entry *&>(&v11, (uint64_t *)&v10);
    }
  }
}

void CLMicroLocationTimeUtils::getTimeDeltaDaysAgo(CLMicroLocationTimeUtils *this, NSDate *a2)
{
  int v2;
  CLMicroLocationTimeUtils *v3;
  void *v4;
  id v5;
  void *v6;
  void *v7;

  v2 = (int)a2;
  v3 = this;
  if (v2 >= 1)
  {
    CLMicroLocationTimeUtils::getTimeDeltaDaysAgo();

    abort_report_np();
    __break(1u);
  }
  else
  {
    objc_msgSend(MEMORY[0x24BDBCE48], "currentCalendar");
    v4 = (void *)objc_claimAutoreleasedReturnValue();
    v5 = objc_alloc_init(MEMORY[0x24BDBCE68]);
    objc_msgSend(v5, "setDay:", v2);
    objc_msgSend(v4, "dateByAddingComponents:toDate:options:", v5, v3, 0);
    v6 = (void *)objc_claimAutoreleasedReturnValue();
    MEMORY[0x24269FF04]();

  }
}

void sub_241A5D280(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  v5 = v4;

  _Unwind_Resume(a1);
}

void ___ZL45_CLLogObjectForCategory_MicroLocation_Defaultv_block_invoke_38()
{
  os_log_t v0;
  void *v1;

  v0 = os_log_create("com.apple.MicroLocation", "MicroLocation");
  v1 = (void *)logObject_MicroLocation_Default;
  logObject_MicroLocation_Default = (uint64_t)v0;

}

CLMicroLocationLocalizationController::LocalizationRequest *CLMicroLocationLocalizationController::LocalizationRequest::LocalizationRequest(CLMicroLocationLocalizationController::LocalizationRequest *this, const CLMicroLocationProto::RecordingEvent *a2, uuid a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v6;
  CLMicroLocationTimeUtils::TimeProfile **v7;
  CLMicroLocationTimeUtils::TimeProfile *v8;
  void *__p[2];
  char v11;

  v3 = *(_QWORD *)&a3.var0[8];
  v4 = *(_QWORD *)a3.var0;
  v6 = CLMicroLocationProto::RecordingEvent::RecordingEvent(this, a2);
  *(_OWORD *)(v6 + 160) = 0u;
  *(_QWORD *)(v6 + 144) = v4;
  *(_QWORD *)(v6 + 152) = v3;
  v7 = (CLMicroLocationTimeUtils::TimeProfile **)(v6 + 168);
  *(_OWORD *)(v6 + 176) = 0u;
  *(_QWORD *)(v6 + 192) = 0;
  *(CFAbsoluteTime *)(v6 + 160) = cl::chrono::CFAbsoluteTimeClock::now();
  v8 = (CLMicroLocationTimeUtils::TimeProfile *)operator new();
  std::string::basic_string[abi:ne180100]<0>(__p, "LocalizationRequest");
  CLMicroLocationTimeUtils::TimeProfile::TimeProfile((uint64_t)v8, (__int128 *)__p);
  std::unique_ptr<CLMicroLocationTimeUtils::TimeProfile>::reset[abi:ne180100](v7, v8);
  if (v11 < 0)
    operator delete(__p[0]);
  return this;
}

void sub_241A5D7F8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  CLMicroLocationProto::RecordingEvent *v15;
  CLMicroLocationTimeUtils::TimeProfile **v16;
  uint64_t v17;
  void *v19;

  if (a15 < 0)
    operator delete(__p);
  MEMORY[0x2426A04D4](v17, 0x1012C4092066FB6);
  v19 = (void *)*((_QWORD *)v15 + 22);
  if (v19)
  {
    *((_QWORD *)v15 + 23) = v19;
    operator delete(v19);
  }
  std::unique_ptr<CLMicroLocationTimeUtils::TimeProfile>::reset[abi:ne180100](v16, 0);
  CLMicroLocationProto::RecordingEvent::~RecordingEvent(v15);
  _Unwind_Resume(a1);
}

CLMicroLocationTimeUtils::TimeProfile *std::unique_ptr<CLMicroLocationTimeUtils::TimeProfile>::reset[abi:ne180100](CLMicroLocationTimeUtils::TimeProfile **a1, CLMicroLocationTimeUtils::TimeProfile *a2)
{
  CLMicroLocationTimeUtils::TimeProfile *result;

  result = *a1;
  *a1 = a2;
  if (result)
  {
    CLMicroLocationTimeUtils::TimeProfile::~TimeProfile(result);
    JUMPOUT(0x2426A04D4);
  }
  return result;
}

void CLMicroLocationLocalizationController::LocalizationRequest::~LocalizationRequest(CLMicroLocationLocalizationController::LocalizationRequest *this)
{
  void *v2;

  v2 = (void *)*((_QWORD *)this + 22);
  if (v2)
  {
    *((_QWORD *)this + 23) = v2;
    operator delete(v2);
  }
  std::unique_ptr<CLMicroLocationTimeUtils::TimeProfile>::reset[abi:ne180100]((CLMicroLocationTimeUtils::TimeProfile **)this + 21, 0);
  CLMicroLocationProto::RecordingEvent::~RecordingEvent(this);
}

void CLMicroLocationLocalizationController::LocalizationRequest::setConfidenceAndReasons(_QWORD *a1, uint64_t *a2, _QWORD *a3)
{
  unint64_t v6;
  char **v7;
  char v8;
  _QWORD *v9;
  _QWORD *v10;
  void *p_p;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t *v16;
  _QWORD *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  char *v22;
  char *v23;
  char *v24;
  char *v25;
  uint64_t v26;
  NSObject *v27;
  char *v28;
  const char *v29;
  NSObject *v30;
  uint64_t v31;
  uint64_t v32;
  NSObject *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  void *v39;
  char v40;
  void *__p;
  _BYTE v42[10];
  __int16 v43;
  char *v44;
  __int16 v45;
  const char *v46;
  uint8_t buf[8];
  __int16 v48;
  _BYTE v49[56];
  void *v50;
  char v51;
  _QWORD v52[22];

  v52[20] = *MEMORY[0x24BDAC8D0];
  if (a2[1] - *a2 == a3[1] - *a3)
  {
    std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)buf);
    v37 = *a2;
    v38 = a2[1];
    if (v38 != *a2)
    {
      v6 = 0;
      v7 = (char **)(a1 + 22);
      v8 = 1;
      do
      {
        if ((v8 & 1) == 0)
          std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v49[6], (uint64_t)",", 1);
        std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v49[6], (uint64_t)"ConfidenceLevel:", 16);
        v9 = (_QWORD *)std::ostream::operator<<();
        v10 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v9, (uint64_t)"ConfidenceReason:", 17);
        CLMicroLocationUtils::placeConfidenceReasonToString(*(_DWORD *)(*a3 + 4 * v6), &__p);
        if (SBYTE3(v44) >= 0)
          p_p = &__p;
        else
          p_p = __p;
        if (SBYTE3(v44) >= 0)
          v12 = BYTE3(v44);
        else
          v12 = *(_QWORD *)v42;
        std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v10, (uint64_t)p_p, v12);
        if (SBYTE3(v44) < 0)
          operator delete(__p);
        v13 = *(unsigned int *)(*a2 + 4 * v6);
        v14 = *(unsigned int *)(*a3 + 4 * v6);
        v16 = (uint64_t *)a1[23];
        v15 = a1[24];
        if ((unint64_t)v16 >= v15)
        {
          v18 = ((char *)v16 - *v7) >> 3;
          if ((unint64_t)(v18 + 1) >> 61)
            std::vector<CLMicroLocationProto::ConfidenceReason>::__throw_length_error[abi:ne180100]();
          v19 = v15 - (_QWORD)*v7;
          v20 = v19 >> 2;
          if (v19 >> 2 <= (unint64_t)(v18 + 1))
            v20 = v18 + 1;
          if ((unint64_t)v19 >= 0x7FFFFFFFFFFFFFF8)
            v21 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v21 = v20;
          if (v21)
            v22 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<CLMicroLocationWiFiChannelHistogram>>((uint64_t)(a1 + 24), v21);
          else
            v22 = 0;
          v23 = &v22[8 * v18];
          *(_QWORD *)v23 = v13 | (v14 << 32);
          v17 = v23 + 8;
          v25 = (char *)a1[22];
          v24 = (char *)a1[23];
          if (v24 != v25)
          {
            do
            {
              v26 = *((_QWORD *)v24 - 1);
              v24 -= 8;
              *((_QWORD *)v23 - 1) = v26;
              v23 -= 8;
            }
            while (v24 != v25);
            v24 = *v7;
          }
          a1[22] = v23;
          a1[23] = v17;
          a1[24] = &v22[8 * v21];
          if (v24)
            operator delete(v24);
        }
        else
        {
          *v16 = v13 | (v14 << 32);
          v17 = v16 + 1;
        }
        v8 = 0;
        a1[23] = v17;
        ++v6;
      }
      while (v6 < (a2[1] - *a2) >> 2);
    }
    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_46);
    v27 = (id)logObject_MicroLocation_Default;
    if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
    {
      v28 = (char *)operator new(0x28uLL);
      *(_QWORD *)(v28 + 29) = 0;
      *(_OWORD *)v28 = 0u;
      *((_OWORD *)v28 + 1) = 0u;
      boost::uuids::to_chars<char *>((uint64_t)(a1 + 18), v28);
      if (v38 == v37)
      {
        __p = (void *)68289538;
        *(_WORD *)v42 = 2082;
        *(_QWORD *)&v42[2] = "";
        v43 = 2082;
        v44 = v28;
        v45 = 2082;
        v46 = "";
        _os_log_impl(&dword_2419D9000, v27, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"LocalizationRequest::setConfidenceAndReasons\", \"RequestID\":%{public, location:escape_only}s, \"Confidence Levels and Reasons\":%{public, location:escape_only}s}", (uint8_t *)&__p, 0x26u);
      }
      else
      {
        std::stringbuf::str();
        if (v40 >= 0)
          v29 = (const char *)&v39;
        else
          v29 = (const char *)v39;
        __p = (void *)68289538;
        *(_WORD *)v42 = 2082;
        *(_QWORD *)&v42[2] = "";
        v43 = 2082;
        v44 = v28;
        v45 = 2082;
        v46 = v29;
        _os_log_impl(&dword_2419D9000, v27, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"LocalizationRequest::setConfidenceAndReasons\", \"RequestID\":%{public, location:escape_only}s, \"Confidence Levels and Reasons\":%{public, location:escape_only}s}", (uint8_t *)&__p, 0x26u);
        if (v40 < 0)
          operator delete(v39);
      }
      operator delete(v28);
    }

    *(_QWORD *)buf = *MEMORY[0x24BEDB7F0];
    v36 = *(_QWORD *)(MEMORY[0x24BEDB7F0] + 72);
    *(_QWORD *)&buf[*(_QWORD *)(*(_QWORD *)buf - 24)] = *(_QWORD *)(MEMORY[0x24BEDB7F0] + 64);
    *(_QWORD *)&v49[6] = v36;
    *(_QWORD *)&v49[14] = MEMORY[0x24BEDB848] + 16;
    if (v51 < 0)
      operator delete(v50);
    std::streambuf::~streambuf();
    std::iostream::~basic_iostream();
    MEMORY[0x2426A0444](v52);
  }
  else
  {
    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_46);
    v30 = logObject_MicroLocation_Default;
    if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_ERROR))
    {
      v31 = (a2[1] - *a2) >> 2;
      v32 = (uint64_t)(a3[1] - *a3) >> 2;
      *(_DWORD *)buf = 68289538;
      *(_DWORD *)&buf[4] = 0;
      v48 = 2082;
      *(_QWORD *)v49 = "";
      *(_WORD *)&v49[8] = 2050;
      *(_QWORD *)&v49[10] = v31;
      *(_WORD *)&v49[18] = 2050;
      *(_QWORD *)&v49[20] = v32;
      _os_log_impl(&dword_2419D9000, v30, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"LocalizationRequest::setConfidenceAndReasons, invalid arguments\", \"confidenceLevelsSize\":%{public}lu, \"confidenceReasonsSize\":%{public}lu}", buf, 0x26u);
    }
    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_46);
    v33 = logObject_MicroLocation_Default;
    if (os_signpost_enabled((os_log_t)logObject_MicroLocation_Default))
    {
      v34 = (a2[1] - *a2) >> 2;
      v35 = (uint64_t)(a3[1] - *a3) >> 2;
      *(_DWORD *)buf = 68289538;
      *(_DWORD *)&buf[4] = 0;
      v48 = 2082;
      *(_QWORD *)v49 = "";
      *(_WORD *)&v49[8] = 2050;
      *(_QWORD *)&v49[10] = v34;
      *(_WORD *)&v49[18] = 2050;
      *(_QWORD *)&v49[20] = v35;
      _os_signpost_emit_with_name_impl(&dword_2419D9000, v33, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "LocalizationRequest::setConfidenceAndReasons, invalid arguments", "{\"msg%{public}.0s\":\"LocalizationRequest::setConfidenceAndReasons, invalid arguments\", \"confidenceLevelsSize\":%{public}lu, \"confidenceReasonsSize\":%{public}lu}", buf, 0x26u);
    }
  }
}

void sub_241A5DE54(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,uint64_t a22,uint64_t a23,char a24)
{
  void *v24;
  void *v25;

  operator delete(v25);

  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream((uint64_t)&a24);
  _Unwind_Resume(a1);
}

uint64_t CLMicroLocationLocalizationController::LocalizationRequest::removeConfidenceReason(uint64_t result, int a2)
{
  _QWORD *v2;
  _QWORD *v3;
  _QWORD *i;
  _QWORD *v6;

  v3 = *(_QWORD **)(result + 176);
  v2 = *(_QWORD **)(result + 184);
  if (v3 != v2)
  {
    for (i = v3 + 1; *((_DWORD *)i - 1) != a2; ++i)
    {
      if (i == v2)
        return result;
    }
    v6 = i - 1;
    if (i - 1 != v2 && i != v2)
    {
      do
      {
        if (*((_DWORD *)i + 1) != a2)
          *v6++ = *i;
        ++i;
      }
      while (i != v2);
      v2 = *(_QWORD **)(result + 184);
    }
    if (v6 != v2)
      *(_QWORD *)(result + 184) = v6;
  }
  return result;
}

void CLMicroLocationLocalizationController::LocalizationRequest::finalizeTriggerConfidence(CLMicroLocationLocalizationController::LocalizationRequest *this)
{
  unsigned int *v2;
  unsigned int *v3;
  unsigned int *v4;
  signed int v5;
  unsigned int *v6;
  signed int v7;
  signed int v8;
  uint64_t v9;
  unsigned int *v10;
  unsigned int *v11;
  unsigned int v12;
  int v13;
  uint64_t v14;
  unsigned int *v15;
  unsigned int *v16;

  v2 = (unsigned int *)*((_QWORD *)this + 22);
  v3 = (unsigned int *)*((_QWORD *)this + 23);
  if (v2 == v3)
  {
    v9 = 3;
  }
  else
  {
    v4 = v2 + 2;
    if (v2 + 2 != v3)
    {
      v5 = *v2;
      v6 = v2 + 2;
      do
      {
        v8 = *v6;
        v6 += 2;
        v7 = v8;
        if (v8 > v5)
        {
          v5 = v7;
          v2 = v4;
        }
        v4 = v6;
      }
      while (v6 != v3);
    }
    v9 = *v2;
  }
  if ((CLMicroLocationProto::ConfidenceLevel_IsValid((CLMicroLocationProto *)v9) & 1) == 0)
    CLMicroLocationLocalizationController::LocalizationRequest::finalizeTriggerConfidence();
  *((_DWORD *)this + 35) |= 0x4000u;
  *((_DWORD *)this + 30) = v9;
  CLMicroLocationLocalizationController::LocalizationRequest::getConfidenceReasons(this, &v15);
  *((_DWORD *)this + 28) = 0;
  v10 = v15;
  v11 = v16;
  if (v15 != v16)
  {
    do
    {
      v12 = *v10;
      if (!CLMicroLocationProto::ConfidenceReason_IsValid((CLMicroLocationProto *)*v10))
        __assert_rtn("add_confidencereasons", "microlocation.pb.h", 20721, "::CLMicroLocationProto::ConfidenceReason_IsValid(value)");
      v13 = *((_DWORD *)this + 28);
      if (v13 == *((_DWORD *)this + 29))
      {
        wireless_diagnostics::google::protobuf::RepeatedField<int>::Reserve((_DWORD *)this + 26, v13 + 1);
        v13 = *((_DWORD *)this + 28);
      }
      v14 = *((_QWORD *)this + 13);
      *((_DWORD *)this + 28) = v13 + 1;
      *(_DWORD *)(v14 + 4 * v13) = v12;
      ++v10;
    }
    while (v10 != v11);
    v10 = v15;
  }
  if (v10)
  {
    v16 = v10;
    operator delete(v10);
  }
}

void sub_241A5E0E8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void CLMicroLocationLocalizationController::LocalizationRequest::getConfidenceReasons(CLMicroLocationLocalizationController::LocalizationRequest *this@<X0>, _QWORD *a2@<X8>)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t *v5;
  uint64_t *v6;
  _QWORD *v7[2];

  v7[0] = 0;
  v7[1] = 0;
  v6 = (uint64_t *)v7;
  v3 = *((_QWORD *)this + 22);
  v4 = *((_QWORD *)this + 23);
  v5 = (uint64_t *)v7;
  if (v3 != v4)
  {
    do
    {
      std::__tree<CLMicroLocationRecordingCompletionMetaInformation::RecordingError>::__emplace_unique_key_args<CLMicroLocationRecordingCompletionMetaInformation::RecordingError,CLMicroLocationRecordingCompletionMetaInformation::RecordingError>(&v6, (int *)(v3 + 4), (_DWORD *)(v3 + 4));
      v3 += 8;
    }
    while (v3 != v4);
    v5 = v6;
  }
  std::vector<CLMicroLocationProto::ConfidenceReason>::vector<std::__tree_const_iterator<CLMicroLocationProto::ConfidenceReason,std::__tree_node<CLMicroLocationProto::ConfidenceReason,void *> *,long>,0>(a2, v5, v7);
  std::__tree<std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>,std::__map_value_compare<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>,std::less<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes>,true>,std::allocator<std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>>>::destroy((uint64_t)&v6, v7[0]);
}

void sub_241A5E18C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, _QWORD *a11)
{
  std::__tree<std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>,std::__map_value_compare<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>,std::less<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes>,true>,std::allocator<std::__value_type<CLMicroLocationLocalizationSettings::LocalizerSettingsTypes,double>>>::destroy((uint64_t)&a10, a11);
  _Unwind_Resume(a1);
}

void CLMicroLocationLocalizationController::start(CLMicroLocationLocalizationController *this, const CLMicroLocationProto::RecordingEvent *a2, uuid a3)
{
  NSObject *v5;
  char *v6;
  uint64_t v7;
  uint64_t *v8;
  unint64_t v9;
  uint64_t v10;
  _DWORD v11[2];
  __int16 v12;
  const char *v13;
  __int16 v14;
  char *v15;
  __int16 v16;
  uint64_t v17;
  _BYTE v18[200];
  uuid v19;
  uint64_t v20;

  v20 = *MEMORY[0x24BDAC8D0];
  v19 = a3;
  CLMicroLocationLocalizationController::LocalizationRequest::LocalizationRequest((CLMicroLocationLocalizationController::LocalizationRequest *)v18, a2, a3);
  if (onceToken_MicroLocation_Default != -1)
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_46);
  v5 = (id)logObject_MicroLocation_Default;
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    v6 = (char *)operator new(0x28uLL);
    *(_QWORD *)(v6 + 29) = 0;
    *(_OWORD *)v6 = 0u;
    *((_OWORD *)v6 + 1) = 0u;
    boost::uuids::to_chars<char *>((uint64_t)&v19, v6);
    v7 = *((unsigned int *)a2 + 18);
    v11[0] = 68289538;
    v11[1] = 0;
    v12 = 2082;
    v13 = "";
    v14 = 2082;
    v15 = v6;
    v16 = 2050;
    v17 = v7;
    _os_log_impl(&dword_2419D9000, v5, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"LocalizationController, start localization request\", \"Request ID\":%{public, location:escape_only}s, \"Event Type\":%{public}lu}", (uint8_t *)v11, 0x26u);
    operator delete(v6);
  }

  v8 = (uint64_t *)((char *)this + 64);
  v9 = *((_QWORD *)this + 9);
  if (v9 >= *((_QWORD *)this + 10))
  {
    v10 = std::vector<CLMicroLocationLocalizationController::LocalizationRequest>::__push_back_slow_path<CLMicroLocationLocalizationController::LocalizationRequest>(v8, (uint64_t)v18);
  }
  else
  {
    std::vector<CLMicroLocationLocalizationController::LocalizationRequest>::__construct_one_at_end[abi:ne180100]<CLMicroLocationLocalizationController::LocalizationRequest>((uint64_t)v8, (uint64_t)v18);
    v10 = v9 + 200;
  }
  *((_QWORD *)this + 9) = v10;
  CLMicroLocationLocalizationController::LocalizationRequest::~LocalizationRequest((CLMicroLocationLocalizationController::LocalizationRequest *)v18);
}

void sub_241A5E320(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15)
{
  void *v15;
  void *v16;

  operator delete(v16);

  CLMicroLocationLocalizationController::LocalizationRequest::~LocalizationRequest((CLMicroLocationLocalizationController::LocalizationRequest *)&a15);
  _Unwind_Resume(a1);
}

CLMicroLocationProto::Measurement *CLMicroLocationLocalizationController::update(CLMicroLocationProto::Measurement *result, uint64_t a2)
{
  if (*((_QWORD *)result + 8) != *((_QWORD *)result + 9))
    return std::vector<CLMiLoProtobufWrapper::Measurement>::__insert_with_size[abi:ne180100]<std::__wrap_iter<CLMiLoProtobufWrapper::Measurement const*>,std::__wrap_iter<CLMiLoProtobufWrapper::Measurement const*>>((uint64_t *)result + 5, *((CLMicroLocationProto::Measurement **)result + 6), *(CLMicroLocationProto::Measurement **)a2, *(_QWORD *)(a2 + 8), 0x2E8BA2E8BA2E8BA3 * ((uint64_t)(*(_QWORD *)(a2 + 8) - *(_QWORD *)a2) >> 3));
  return result;
}

uint64_t CLMicroLocationLocalizationController::doHaveValidMeasurements(CLMicroLocationLocalizationController *this, const CLMicroLocationLocalizationController::LocalizationRequest *a2)
{
  NSObject *v4;
  _BOOL8 v5;
  int v6;
  int v7;
  char DataTypeValidForLocalization;
  const CLMicroLocationProto::Measurement *v9;
  const CLMicroLocationProto::Measurement *v10;
  uint64_t v11;
  const CLMicroLocationProto::Measurement *v13;
  const CLMicroLocationProto::Measurement *v14;
  uint64_t v15;
  uint8_t buf[8];
  __int16 v17;
  const char *v18;
  __int16 v19;
  int v20;
  __int16 v21;
  int v22;
  int v23;
  uint64_t v24;

  v24 = *MEMORY[0x24BDAC8D0];
  if (onceToken_MicroLocation_Default != -1)
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_46);
  v4 = logObject_MicroLocation_Default;
  v5 = os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEBUG);
  if (v5)
  {
    v6 = *((unsigned __int8 *)a2 + 77);
    v7 = *((unsigned __int8 *)a2 + 76);
    *(_DWORD *)buf = 68289538;
    *(_DWORD *)&buf[4] = 0;
    v17 = 2082;
    v18 = "";
    v19 = 1026;
    v20 = v6;
    v21 = 1026;
    v22 = v7;
    _os_log_impl(&dword_2419D9000, v4, OS_LOG_TYPE_DEBUG, "{\"msg%{public}.0s\":\"LocalizationController: ignored sensors\", \"isBleIgnore\":%{public}d, \"isNiIgnore\":%{public}d}", buf, 0x1Eu);
  }
  DataTypeValidForLocalization = CLMicroLocationAlgorithms::getDataTypeValidForLocalization((CLMicroLocationAlgorithms *)v5);
  v13 = 0;
  v14 = 0;
  v15 = 0;
  std::vector<CLMiLoProtobufWrapper::Measurement>::__init_with_size[abi:ne180100]<CLMiLoProtobufWrapper::Measurement*,CLMiLoProtobufWrapper::Measurement*>(&v13, *((_QWORD *)this + 5), *((_QWORD *)this + 6), 0x2E8BA2E8BA2E8BA3 * ((uint64_t)(*((_QWORD *)this + 6) - *((_QWORD *)this + 5)) >> 3));
  v9 = v13;
  v10 = v14;
  while (1)
  {
    if (v9 == v10)
    {
      v11 = 0;
      goto LABEL_20;
    }
    CLMicroLocationProto::Measurement::Measurement((CLMicroLocationProto::Measurement *)buf, v9);
    if (v23 != 6)
      break;
    CLMicroLocationProto::Measurement::~Measurement((CLMicroLocationProto::Measurement *)buf);
    if ((DataTypeValidForLocalization & 0x40) != 0)
      goto LABEL_19;
LABEL_16:
    v9 = (const CLMicroLocationProto::Measurement *)((char *)v9 + 88);
  }
  if (v23 == 5)
  {
    if ((DataTypeValidForLocalization & 0x20) != 0)
      goto LABEL_18;
    goto LABEL_15;
  }
  if (v23 != 1 || (DataTypeValidForLocalization & 2) == 0)
  {
LABEL_15:
    CLMicroLocationProto::Measurement::~Measurement((CLMicroLocationProto::Measurement *)buf);
    goto LABEL_16;
  }
LABEL_18:
  CLMicroLocationProto::Measurement::~Measurement((CLMicroLocationProto::Measurement *)buf);
LABEL_19:
  v11 = 1;
LABEL_20:
  *(_QWORD *)buf = &v13;
  std::vector<CLMiLoProtobufWrapper::Measurement>::__destroy_vector::operator()[abi:ne180100]((void ***)buf);
  return v11;
}

void sub_241A5E55C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  _Unwind_Resume(exception_object);
}

void CLMicroLocationLocalizationController::localizationRequestResultsPerModelInternal(const CLMicroLocationProto::AssociatedAccessPointInfo *a1, uint64_t a2, uint64_t **a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7)
{
  uint64_t v9;
  char *v10;
  uint64_t *v11;
  uint64_t v12;
  const std::string::value_type *v13;
  std::string::size_type v14;
  NSObject *v15;
  uint64_t v16;
  _OWORD *v17;
  void **v18;
  uint64_t v19;
  std::string *v20;
  std::string *p_p;
  uint64_t v22;
  char *v23;
  _BYTE *v24;
  int v25;
  NSObject *v26;
  uint64_t *v27;
  uint64_t v28;
  uint64_t *v29;
  uint64_t v30;
  uint64_t *v31;
  uint64_t v32;
  NSObject *v33;
  uint64_t v34;
  char v35;
  int v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t *v39;
  double v40;
  double v41;
  int v42;
  _BYTE *v43;
  uint64_t *v44;
  uint64_t v45;
  uint64_t *v46;
  uint64_t v47;
  uint64_t *v48;
  uint64_t v49;
  int v50;
  int *v51;
  int *v52;
  _DWORD *v53;
  int v54;
  _DWORD *v55;
  _DWORD *v56;
  _DWORD *v57;
  uint64_t v58;
  unint64_t v59;
  uint64_t v60;
  unint64_t v61;
  char *v62;
  char *v63;
  int v64;
  char isStable;
  int v66;
  void *v67;
  CLMicroLocationProtobufHelper *v68;
  _QWORD *v69;
  uint64_t v72;
  uint64_t *v73;
  uint64_t v74;
  _QWORD *v75;
  void *v76;
  void *v77;
  uint64_t v78;
  std::string v79;
  char v80;
  __int128 v81;
  uint64_t v82;
  void *v83;
  void *v84;
  uint64_t v85;
  void *v86;
  void *v87;
  uint64_t v88;
  std::string v89;
  char v90;
  __int128 v91;
  uint64_t v92;
  void *v93;
  void *v94;
  uint64_t v95;
  std::string __p;
  char v97;
  void *v98[3];
  int v99;
  void *v100[2];
  uint64_t v101;
  void *v102[3];
  char v103;
  std::string v104;
  uint64_t v105;
  uint64_t v106;
  _BYTE v107[28];
  __int16 v108;
  _BYTE v109[18];
  _BYTE v110[30];
  __int16 v111;
  int v112;
  __int16 v113;
  _DWORD v114[10];
  char v115;
  void *v116;
  void *v117;
  _BYTE v118[24];
  uint64_t v119;

  v9 = a2;
  v119 = *MEMORY[0x24BDAC8D0];
  v105 = a5;
  v106 = a6;
  *(_DWORD *)(a4 + 24) = *(_DWORD *)(a2 + 16);
  v10 = (char *)(a4 + 32);
  if (a4 + 32 != a2 + 24)
    std::vector<CLMicroLocationProto::ConfidenceLevel>::__assign_with_size[abi:ne180100]<CLMicroLocationProto::ConfidenceLevel*,CLMicroLocationProto::ConfidenceLevel*>(v10, *(char **)(a2 + 24), *(_QWORD *)(a2 + 32), (uint64_t)(*(_QWORD *)(a2 + 32) - *(_QWORD *)(a2 + 24)) >> 2);
  v11 = *a3;
  v73 = a3[1];
  if (*a3 != v73)
  {
    v72 = v9 + 48;
    v69 = (_QWORD *)(v9 + 152);
    v75 = (_QWORD *)(a4 + 48);
    v68 = (CLMicroLocationProtobufHelper *)(v9 + 248);
    v74 = v9;
    do
    {
      if (*(_DWORD *)(*v11 + 4) == 1 && !*(_BYTE *)(*v11 + 488))
      {
        CLMicroLocationLocalizationController::localizationRequestResultsPerModelInternal();
        __break(1u);
      }
      std::string::basic_string[abi:ne180100]<0>(&v104, "");
      v12 = *v11;
      if (*(_DWORD *)(*v11 + 4) == 2 && *(_BYTE *)(v12 + 192))
      {
        std::to_string((std::string *)v107, (uint64_t)(*(_QWORD *)(v12 + 104) - *(_QWORD *)(v12 + 96)) >> 4);
        v13 = v107[23] >= 0 ? v107 : *(const std::string::value_type **)v107;
        v14 = v107[23] >= 0 ? v107[23] : *(_QWORD *)&v107[8];
        std::string::append(&v104, v13, v14);
        if ((v107[23] & 0x80000000) != 0)
          operator delete(*(void **)v107);
      }
      if (onceToken_MicroLocation_Default != -1)
        dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_46);
      v15 = (id)logObject_MicroLocation_Default;
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
      {
        v16 = *v11;
        v17 = operator new(0x28uLL);
        v98[0] = v17;
        *(_OWORD *)&v98[1] = xmmword_241BB2320;
        *v17 = 0u;
        v17[1] = 0u;
        *(_QWORD *)((char *)v17 + 29) = 0;
        boost::uuids::to_chars<char *>(v16 + 448, v17);
        if (SHIBYTE(v98[2]) >= 0)
          v18 = v98;
        else
          v18 = (void **)v98[0];
        v19 = *(unsigned int *)(*v11 + 4);
        if ((v104.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v20 = &v104;
        else
          v20 = (std::string *)v104.__r_.__value_.__r.__words[0];
        std::optional<std::string>::value_or[abi:ne180100]<char const(&)[1]>(*v11 + 464, "", &__p);
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          p_p = &__p;
        else
          p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
        v22 = *v11;
        v23 = (char *)operator new(0x28uLL);
        *(_QWORD *)v118 = v23;
        *(_OWORD *)&v118[8] = xmmword_241BB2320;
        *(_OWORD *)v23 = 0u;
        *((_OWORD *)v23 + 1) = 0u;
        *(_QWORD *)(v23 + 29) = 0;
        boost::uuids::to_chars<char *>(v22 + 512, v23);
        v24 = v118;
        if (v118[23] < 0)
          v24 = *(_BYTE **)v118;
        v25 = *(unsigned __int8 *)(*v11 + 640);
        *(_QWORD *)v107 = 68290563;
        *(_WORD *)&v107[8] = 2082;
        *(_QWORD *)&v107[10] = "";
        *(_WORD *)&v107[18] = 2082;
        *(_QWORD *)&v107[20] = v18;
        v108 = 2050;
        *(_QWORD *)v109 = v19;
        *(_WORD *)&v109[8] = 2081;
        *(_QWORD *)&v109[10] = v20;
        *(_WORD *)v110 = 2081;
        *(_QWORD *)&v110[2] = p_p;
        *(_WORD *)&v110[10] = 2082;
        *(_QWORD *)&v110[12] = v24;
        *(_WORD *)&v110[20] = 1026;
        *(_DWORD *)&v110[22] = v25;
        _os_log_impl(&dword_2419D9000, v15, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"localizationRequestResultsPerModel\", \"ModelUUID\":%{public, location:escape_only}s, \"ModelType\":%{public}lu, \"SimilarityListLengthIfApplicable\":%{private, location:escape_only}s, \"ClientID\":%{private, location:escape_only}s, \"LoiGroupId\":%{public, location:escape_only}s, \"hasAnchorStatistics\":%{public}hhd}", v107, 0x4Au);
        if ((v118[23] & 0x80000000) != 0)
          operator delete(*(void **)v118);
        v9 = v74;
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
          operator delete(__p.__r_.__value_.__l.__data_);
        if (SHIBYTE(v98[2]) < 0)
          operator delete(v98[0]);
      }

      memset(v98, 0, sizeof(v98));
      v99 = 3;
      v103 = 0;
      v100[1] = 0;
      v101 = 0;
      v100[0] = 0;
      LOBYTE(v102[0]) = 0;
      if (*(_BYTE *)(v9 + 240))
      {
        if (onceToken_MicroLocation_Default != -1)
          dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_46);
        v26 = (id)logObject_MicroLocation_Default;
        if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
        {
          v27 = *(uint64_t **)(v9 + 64);
          if (v27)
          {
            v28 = 0;
            v29 = *(uint64_t **)(v9 + 64);
            do
            {
              if (*((_DWORD *)v29 + 6) == 1)
                ++v28;
              v29 = (uint64_t *)*v29;
            }
            while (v29);
            v30 = 0;
            v31 = *(uint64_t **)(v9 + 64);
            do
            {
              if (*((_DWORD *)v31 + 6) == 5)
                ++v30;
              v31 = (uint64_t *)*v31;
            }
            while (v31);
            v32 = 0;
            do
            {
              if (*((_DWORD *)v27 + 6) == 6)
                ++v32;
              v27 = (uint64_t *)*v27;
            }
            while (v27);
          }
          else
          {
            v30 = 0;
            v28 = 0;
            v32 = 0;
          }
          v37 = *(unsigned int *)(*v11 + 4);
          v38 = *(_QWORD *)(v9 + 72);
          LODWORD(__p.__r_.__value_.__l.__data_) = 1;
          v39 = std::__hash_table<std::__hash_value_type<unsigned int,unsigned int>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,unsigned int>>>::find<unsigned int>(v69, (unsigned int *)&__p);
          if (v39)
            v40 = *((double *)v39 + 4) - *((double *)v39 + 3);
          else
            v40 = 0.0;
          v41 = *(double *)(v74 + 200);
          v42 = (int)*(double *)(v74 + 192);
          *(_QWORD *)v107 = 68291075;
          *(_WORD *)&v107[8] = 2082;
          *(_QWORD *)&v107[10] = "";
          *(_WORD *)&v107[18] = 2049;
          *(_QWORD *)&v107[20] = v37;
          v108 = 2049;
          *(_QWORD *)v109 = v38;
          v9 = v74;
          *(_WORD *)&v109[8] = 2049;
          *(_QWORD *)&v109[10] = v28;
          *(_WORD *)v110 = 2049;
          *(_QWORD *)&v110[2] = v30;
          *(_WORD *)&v110[10] = 2049;
          *(_QWORD *)&v110[12] = v32;
          *(_WORD *)&v110[20] = 2049;
          *(double *)&v110[22] = v40;
          v111 = 1025;
          v112 = v42;
          v113 = 1025;
          v114[0] = (int)v41;
          _os_log_impl(&dword_2419D9000, v26, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"testFingerprint\", \"ModelType\":%{private}lu, \"size\":%{private}lu, \"NumWiFiMeasurements\":%{private}lu, \"NumBLEMeasurements\":%{private}lu, \"NumUWBMeasurements\":%{private}lu, \"WiFi RSSI duration_s\":\"%{private}.09f\", \"start\":%{private}d, \"end\":%{private}d}", v107, 0x5Au);
        }

        v118[0] = 0;
        v118[16] = 0;
        if (*(_BYTE *)(*v11 + 640))
          v43 = v118;
        else
          v43 = 0;
        CLMicroLocationLocalizer::localize(a1, *v11, v72, (CLMicroLocationLocalizationSettings *)(*v11 + 528), (uint64_t)v43, 1, (uint64_t)v107);
        if (v98[0])
        {
          v98[1] = v98[0];
          operator delete(v98[0]);
        }
        *(_OWORD *)v98 = *(_OWORD *)v107;
        v98[2] = *(void **)&v107[16];
        memset(v107, 0, 24);
        v99 = *(_DWORD *)&v107[24];
        if (v100[0])
        {
          v100[1] = v100[0];
          operator delete(v100[0]);
        }
        *(_OWORD *)v100 = *(_OWORD *)&v109[2];
        v101 = *(_QWORD *)v110;
        *(_QWORD *)&v109[10] = 0;
        *(_QWORD *)v110 = 0;
        *(_QWORD *)&v109[2] = 0;
        std::__optional_storage_base<std::vector<CLMicroLocationResultInternal>,false>::__assign_from[abi:ne180100]<std::__optional_move_assign_base<std::vector<CLMicroLocationResultInternal>,false>>((uint64_t)v102, (__n128 *)&v110[8]);
        if ((_BYTE)v112 && *(_QWORD *)&v110[8])
        {
          *(_QWORD *)&v110[16] = *(_QWORD *)&v110[8];
          operator delete(*(void **)&v110[8]);
        }
        if (*(_QWORD *)&v109[2])
        {
          *(_QWORD *)&v109[10] = *(_QWORD *)&v109[2];
          operator delete(*(void **)&v109[2]);
        }
        if (*(_QWORD *)v107)
        {
          *(_QWORD *)&v107[8] = *(_QWORD *)v107;
          operator delete(*(void **)v107);
        }
        __p.__r_.__value_.__s.__data_[0] = 0;
        v97 = 0;
        if (*(_BYTE *)(*v11 + 640))
        {
          if (v118[16])
          {
            CLMicroLocationAnchorValueStatisticsMap::at((CLMicroLocationAnchorValueStatisticsMap *)(*v11 + 600), (uuid *)v118, v107);
            std::__optional_storage_base<std::unordered_map<std::string,AnchorValueStatistics>,false>::__assign_from[abi:ne180100]<std::__optional_move_assign_base<std::unordered_map<std::string,AnchorValueStatistics>,false>>((uint64_t)&__p, (uint64_t)v107);
            if (v109[10])
              std::__hash_table<std::__hash_value_type<std::string,AnchorValueStatistics>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,AnchorValueStatistics>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,AnchorValueStatistics>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,AnchorValueStatistics>>>::~__hash_table((uint64_t)v107);
          }
        }
        v44 = *(uint64_t **)(v9 + 64);
        if (v44)
        {
          v45 = 0;
          v46 = *(uint64_t **)(v9 + 64);
          do
          {
            if (*((_DWORD *)v46 + 6) == 1)
              ++v45;
            v46 = (uint64_t *)*v46;
          }
          while (v46);
          v47 = 0;
          v48 = *(uint64_t **)(v9 + 64);
          do
          {
            if (*((_DWORD *)v48 + 6) == 5)
              ++v47;
            v48 = (uint64_t *)*v48;
          }
          while (v48);
          v49 = 0;
          do
          {
            if (*((_DWORD *)v44 + 6) == 6)
              ++v49;
            v44 = (uint64_t *)*v44;
          }
          while (v44);
        }
        else
        {
          v47 = 0;
          v45 = 0;
          v49 = 0;
        }
        v50 = v99;
        if (v99 >= *(_DWORD *)(a4 + 24))
          v50 = *(_DWORD *)(a4 + 24);
        *(_DWORD *)(a4 + 24) = v50;
        v52 = (int *)v100[0];
        v51 = (int *)v100[1];
        if (v100[0] != v100[1])
        {
          v53 = *(_DWORD **)(a4 + 40);
          do
          {
            v54 = *v52;
            v55 = *(_DWORD **)v10;
            v56 = v53;
            if (*(_DWORD **)v10 != v53)
            {
              v56 = *(_DWORD **)v10;
              while (*v56 != v54)
              {
                if (++v56 == v53)
                {
                  v56 = v53;
                  break;
                }
              }
            }
            if (v56 == v53)
            {
              if ((unint64_t)v53 >= *v75)
              {
                v58 = v53 - v55;
                v59 = v58 + 1;
                if ((unint64_t)(v58 + 1) >> 62)
                  std::vector<CLMicroLocationProto::ConfidenceReason>::__throw_length_error[abi:ne180100]();
                v60 = *v75 - (_QWORD)v55;
                if (v60 >> 1 > v59)
                  v59 = v60 >> 1;
                if ((unint64_t)v60 >= 0x7FFFFFFFFFFFFFFCLL)
                  v61 = 0x3FFFFFFFFFFFFFFFLL;
                else
                  v61 = v59;
                if (v61)
                {
                  v62 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<CLMicroLocationProto::ConfidenceReason>>((uint64_t)v75, v61);
                  v55 = *(_DWORD **)(a4 + 32);
                  v53 = *(_DWORD **)(a4 + 40);
                }
                else
                {
                  v62 = 0;
                }
                v63 = &v62[4 * v58];
                *(_DWORD *)v63 = v54;
                v57 = v63 + 4;
                while (v53 != v55)
                {
                  v64 = *--v53;
                  *((_DWORD *)v63 - 1) = v64;
                  v63 -= 4;
                }
                *(_QWORD *)(a4 + 32) = v63;
                *(_QWORD *)(a4 + 40) = v57;
                *(_QWORD *)(a4 + 48) = &v62[4 * v61];
                if (v55)
                  operator delete(v55);
              }
              else
              {
                *v53 = v54;
                v57 = v53 + 1;
              }
              *(_QWORD *)(a4 + 40) = v57;
              v53 = v57;
            }
            ++v52;
          }
          while (v52 != v51);
        }
        v94 = 0;
        v95 = 0;
        v93 = 0;
        std::vector<CLMicroLocationResultInternal>::__init_with_size[abi:ne180100]<CLMicroLocationResultInternal*,CLMicroLocationResultInternal*>(&v93, v98[0], (uint64_t)v98[1], ((char *)v98[1] - (char *)v98[0]) >> 5);
        *(_QWORD *)&v91 = v45;
        *((_QWORD *)&v91 + 1) = v47;
        v92 = v49;
        isStable = CLMicroLocationModel::isStable((CLMicroLocationModel *)*v11);
        std::__optional_copy_base<std::string,false>::__optional_copy_base[abi:ne180100](&v89, (__int128 *)(*v11 + 464));
        v66 = *(_DWORD *)(a4 + 24);
        v87 = 0;
        v88 = 0;
        v86 = 0;
        std::vector<CLMicroLocationProto::ConfidenceReason>::__init_with_size[abi:ne180100]<CLMicroLocationProto::ConfidenceReason*,CLMicroLocationProto::ConfidenceReason*>(&v86, *(const void **)(a4 + 32), *(_QWORD *)(a4 + 40), (uint64_t)(*(_QWORD *)(a4 + 40) - *(_QWORD *)(a4 + 32)) >> 2);
        v9 = v74;
        CLMicroLocationResultToPublish::CLMicroLocationResultToPublish((uint64_t)v107, (uint64_t)&v93, &v91, isStable, (__int128 *)&v89, (uint64_t)&__p, v66, (uint64_t)&v86);
        std::vector<CLMiLoServiceManager::LocalizationResultsPerModel>::emplace_back<CLMicroLocationResultToPublish,boost::uuids::uuid &,std::optional<std::vector<CLMicroLocationResultInternal>> &>((uint64_t *)a4, (uint64_t)v107, (__int128 *)(*v11 + 448), (uint64_t)v102);
        if (v116)
        {
          v117 = v116;
          operator delete(v116);
        }
        if (v115)
          std::__hash_table<std::__hash_value_type<std::string,AnchorValueStatistics>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,AnchorValueStatistics>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,AnchorValueStatistics>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,AnchorValueStatistics>>>::~__hash_table((uint64_t)v114 + 2);
        if ((_BYTE)v112 && SHIBYTE(v111) < 0)
          operator delete(*(void **)&v110[8]);
        if (*(_QWORD *)v107)
        {
          *(_QWORD *)&v107[8] = *(_QWORD *)v107;
          operator delete(*(void **)v107);
        }
        if (v86)
        {
          v87 = v86;
          operator delete(v86);
        }
        if (v90 && SHIBYTE(v89.__r_.__value_.__r.__words[2]) < 0)
          operator delete(v89.__r_.__value_.__l.__data_);
        v67 = v93;
        if (v93)
        {
          v94 = v93;
          operator delete(v93);
        }
        if (a7)
          CLMicroLocationLocalizationController::sendLocalizationCoreAnalyticsEvent((uint64_t)v67, (_DWORD *)*v11, (const void **)v98, (uint64_t)v102, v72, v68);
        if (v97)
          std::__hash_table<std::__hash_value_type<std::string,AnchorValueStatistics>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,AnchorValueStatistics>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,AnchorValueStatistics>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,AnchorValueStatistics>>>::~__hash_table((uint64_t)&__p);
      }
      else
      {
        if (onceToken_MicroLocation_Default != -1)
          dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_46);
        v33 = logObject_MicroLocation_Default;
        if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT))
        {
          v34 = *(unsigned int *)(*v11 + 4);
          *(_QWORD *)v107 = 68289282;
          *(_WORD *)&v107[8] = 2082;
          *(_QWORD *)&v107[10] = "";
          *(_WORD *)&v107[18] = 2050;
          *(_QWORD *)&v107[20] = v34;
          _os_log_impl(&dword_2419D9000, v33, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"LocalizationController test fingerprint was not created\", \"ModelType\":%{public}lu}", v107, 0x1Cu);
        }
        v84 = 0;
        v85 = 0;
        v83 = 0;
        std::vector<CLMicroLocationResultInternal>::__init_with_size[abi:ne180100]<CLMicroLocationResultInternal*,CLMicroLocationResultInternal*>(&v83, v98[0], (uint64_t)v98[1], ((char *)v98[1] - (char *)v98[0]) >> 5);
        v81 = 0uLL;
        v82 = 0;
        v35 = CLMicroLocationModel::isStable((CLMicroLocationModel *)*v11);
        std::__optional_copy_base<std::string,false>::__optional_copy_base[abi:ne180100](&v79, (__int128 *)(*v11 + 464));
        __p.__r_.__value_.__s.__data_[0] = 0;
        v97 = 0;
        v36 = *(_DWORD *)(a4 + 24);
        v77 = 0;
        v78 = 0;
        v76 = 0;
        std::vector<CLMicroLocationProto::ConfidenceReason>::__init_with_size[abi:ne180100]<CLMicroLocationProto::ConfidenceReason*,CLMicroLocationProto::ConfidenceReason*>(&v76, *(const void **)(a4 + 32), *(_QWORD *)(a4 + 40), (uint64_t)(*(_QWORD *)(a4 + 40) - *(_QWORD *)(a4 + 32)) >> 2);
        CLMicroLocationResultToPublish::CLMicroLocationResultToPublish((uint64_t)v107, (uint64_t)&v83, &v81, v35, (__int128 *)&v79, (uint64_t)&__p, v36, (uint64_t)&v76);
        std::vector<CLMiLoServiceManager::LocalizationResultsPerModel>::emplace_back<CLMicroLocationResultToPublish,boost::uuids::uuid &,std::optional<std::vector<CLMicroLocationResultInternal>> &>((uint64_t *)a4, (uint64_t)v107, (__int128 *)(*v11 + 448), (uint64_t)v102);
        if (v116)
        {
          v117 = v116;
          operator delete(v116);
        }
        if (v115)
          std::__hash_table<std::__hash_value_type<std::string,AnchorValueStatistics>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,AnchorValueStatistics>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,AnchorValueStatistics>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,AnchorValueStatistics>>>::~__hash_table((uint64_t)v114 + 2);
        if ((_BYTE)v112 && SHIBYTE(v111) < 0)
          operator delete(*(void **)&v110[8]);
        if (*(_QWORD *)v107)
        {
          *(_QWORD *)&v107[8] = *(_QWORD *)v107;
          operator delete(*(void **)v107);
        }
        if (v76)
        {
          v77 = v76;
          operator delete(v76);
        }
        if (v97)
          std::__hash_table<std::__hash_value_type<std::string,AnchorValueStatistics>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,AnchorValueStatistics>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,AnchorValueStatistics>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,AnchorValueStatistics>>>::~__hash_table((uint64_t)&__p);
        if (v80 && SHIBYTE(v79.__r_.__value_.__r.__words[2]) < 0)
          operator delete(v79.__r_.__value_.__l.__data_);
        if (v83)
        {
          v84 = v83;
          operator delete(v83);
        }
      }
      if (v103 && v102[0])
      {
        v102[1] = v102[0];
        operator delete(v102[0]);
      }
      if (v100[0])
      {
        v100[1] = v100[0];
        operator delete(v100[0]);
      }
      if (v98[0])
      {
        v98[1] = v98[0];
        operator delete(v98[0]);
      }
      if (SHIBYTE(v104.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v104.__r_.__value_.__l.__data_);
      v11 += 2;
    }
    while (v11 != v73);
  }
}

void sub_241A5F0FC(_Unwind_Exception *a1)
{
  if (SLOBYTE(STACK[0x22F]) < 0)
    operator delete((void *)STACK[0x218]);
  _Unwind_Resume(a1);
}

void std::optional<std::string>::value_or[abi:ne180100]<char const(&)[1]>(uint64_t a1@<X0>, char *a2@<X1>, std::string *a3@<X8>)
{
  if (*(_BYTE *)(a1 + 24))
  {
    if (*(char *)(a1 + 23) < 0)
    {
      std::string::__init_copy_ctor_external(a3, *(const std::string::value_type **)a1, *(_QWORD *)(a1 + 8));
    }
    else
    {
      *(_OWORD *)&a3->__r_.__value_.__l.__data_ = *(_OWORD *)a1;
      a3->__r_.__value_.__r.__words[2] = *(_QWORD *)(a1 + 16);
    }
  }
  else
  {
    std::string::basic_string[abi:ne180100]<0>(a3, a2);
  }
}

_QWORD *CLMicroLocationAnchorValueStatisticsMap::at@<X0>(CLMicroLocationAnchorValueStatisticsMap *this@<X0>, uuid *a2@<X1>, _BYTE *a3@<X8>)
{
  _QWORD *result;

  *a3 = 0;
  a3[40] = 0;
  result = std::__hash_table<std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,std::vector<boost::uuids::uuid>>>>::find<boost::uuids::uuid>(this, a2);
  if (result)
    return (_QWORD *)std::optional<std::unordered_map<std::string,AnchorValueStatistics>>::emplace[abi:ne180100]<std::unordered_map<std::string,AnchorValueStatistics> const&,void>((uint64_t)a3, (uint64_t)(result + 4));
  return result;
}

void sub_241A5F31C(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (*(_BYTE *)(v1 + 40))
    std::__hash_table<std::__hash_value_type<std::string,AnchorValueStatistics>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,AnchorValueStatistics>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,AnchorValueStatistics>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,AnchorValueStatistics>>>::~__hash_table(v1);
  _Unwind_Resume(exception_object);
}

uint64_t std::vector<CLMiLoServiceManager::LocalizationResultsPerModel>::emplace_back<CLMicroLocationResultToPublish,boost::uuids::uuid &,std::optional<std::vector<CLMicroLocationResultInternal>> &>(uint64_t *a1, uint64_t a2, __int128 *a3, uint64_t a4)
{
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;
  unint64_t v16;
  char *v17;
  void *v19;
  char *v20;
  char *v21;
  char *v22;
  uint64_t v23;

  v10 = a1[2];
  v8 = (uint64_t)(a1 + 2);
  v9 = v10;
  v11 = *(_QWORD *)(v8 - 8);
  if (v11 >= v10)
  {
    v13 = 0x84BDA12F684BDA13 * ((uint64_t)(v11 - *a1) >> 3);
    if (v13 + 1 > 0x12F684BDA12F684)
      std::vector<CLMicroLocationProto::ConfidenceReason>::__throw_length_error[abi:ne180100]();
    v14 = 0x84BDA12F684BDA13 * ((uint64_t)(v9 - *a1) >> 3);
    v15 = 2 * v14;
    if (2 * v14 <= v13 + 1)
      v15 = v13 + 1;
    if (v14 >= 0x97B425ED097B42)
      v16 = 0x12F684BDA12F684;
    else
      v16 = v15;
    v23 = v8;
    if (v16)
      v17 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<CLMiLoServiceManager::LocalizationResultsPerModel>>(v8, v16);
    else
      v17 = 0;
    v19 = v17;
    v20 = &v17[216 * v13];
    v22 = &v17[216 * v16];
    CLMiLoServiceManager::LocalizationResultsPerModel::LocalizationResultsPerModel((uint64_t)v20, a2, a3, a4);
    v21 = v20 + 216;
    std::vector<CLMiLoServiceManager::LocalizationResultsPerModel>::__swap_out_circular_buffer(a1, &v19);
    v12 = a1[1];
    std::__split_buffer<CLMiLoServiceManager::LocalizationResultsPerModel>::~__split_buffer(&v19);
  }
  else
  {
    CLMiLoServiceManager::LocalizationResultsPerModel::LocalizationResultsPerModel(*(_QWORD *)(v8 - 8), a2, a3, a4);
    v12 = v11 + 216;
    a1[1] = v11 + 216;
  }
  a1[1] = v12;
  return v12 - 216;
}

void sub_241A5F480(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__split_buffer<CLMiLoServiceManager::LocalizationResultsPerModel>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

void CLMicroLocationResultToPublish::~CLMicroLocationResultToPublish(CLMicroLocationResultToPublish *this)
{
  void *v2;
  void *v3;

  v2 = (void *)*((_QWORD *)this + 18);
  if (v2)
  {
    *((_QWORD *)this + 19) = v2;
    operator delete(v2);
  }
  if (*((_BYTE *)this + 128))
    std::__hash_table<std::__hash_value_type<std::string,AnchorValueStatistics>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,AnchorValueStatistics>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,AnchorValueStatistics>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,AnchorValueStatistics>>>::~__hash_table((uint64_t)this + 88);
  if (*((_BYTE *)this + 80) && *((char *)this + 79) < 0)
    operator delete(*((void **)this + 7));
  v3 = *(void **)this;
  if (*(_QWORD *)this)
  {
    *((_QWORD *)this + 1) = v3;
    operator delete(v3);
  }
}

void CLMicroLocationLocalizationController::sendLocalizationCoreAnalyticsEvent(uint64_t a1, _DWORD *a2, const void **a3, uint64_t a4, uint64_t a5, CLMicroLocationProtobufHelper *a6)
{
  void *v11;
  void *v12;
  void *v13;
  void *v14;
  int v15;
  int v16;
  const CLMicroLocationProto::RecordingEvent *v17;
  void *v18;
  uint64_t *v19;
  uint64_t v20;
  uint64_t *v21;
  uint64_t v22;
  uint64_t *v23;
  uint64_t v24;
  NSObject *v25;
  double *v26;
  double v27;
  double v28;
  void *v29;
  id v30;
  id v31;
  uint8_t buf[8];
  double *v33;

  +[ULDefaultsSingleton shared](ULDefaultsSingleton, "shared");
  v11 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v11, "defaultsDictionary");
  v12 = (void *)objc_claimAutoreleasedReturnValue();

  objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", "ULAnalyticsSendEventEnabled");
  v13 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v12, "objectForKey:", v13);
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  if (v14 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
    v15 = objc_msgSend(v14, "BOOLValue");
  else
    v15 = objc_msgSend(MEMORY[0x24BDBD1C8], "BOOLValue");
  v16 = v15;

  if (v16)
  {
    CLMicroLocationProtobufHelper::getRecordingTriggerString(a6, v17);
    v18 = (void *)objc_claimAutoreleasedReturnValue();
    v19 = *(uint64_t **)(a5 + 16);
    if (v19)
    {
      v20 = 0;
      v21 = v19;
      do
      {
        if (*((_DWORD *)v21 + 6) == 1)
          ++v20;
        v21 = (uint64_t *)*v21;
      }
      while (v21);
      v22 = 0;
      v23 = v19;
      do
      {
        if (*((_DWORD *)v23 + 6) == 5)
          ++v22;
        v23 = (uint64_t *)*v23;
      }
      while (v23);
      v24 = 0;
      do
      {
        if (*((_DWORD *)v19 + 6) == 6)
          ++v24;
        v19 = (uint64_t *)*v19;
      }
      while (v19);
    }
    std::optional<std::vector<CLMicroLocationResultInternal>>::value_or[abi:ne180100]<std::vector<CLMicroLocationResultInternal> const&>(a4, a3, buf);
    v26 = *(double **)buf;
    if (*(double **)buf == v33)
    {
      v28 = 0.0;
    }
    else
    {
      v27 = 0.0;
      do
      {
        v28 = v26[2];
        if (*(_OWORD *)v26 == 0 || v28 <= v27)
          v28 = v27;
        v26 += 4;
        v27 = v28;
      }
      while (v26 != v33);
    }
    cl::chrono::CFAbsoluteTimeClock::now();
    if (*a2 == 4)
    {
      objc_msgSend(MEMORY[0x24BDD16E0], "numberWithDouble:", v28);
      v29 = (void *)objc_claimAutoreleasedReturnValue();
    }
    else
    {
      v29 = 0;
    }
    v30 = v18;
    v31 = v29;
    AnalyticsSendEventLazy();

    if (*(_QWORD *)buf)
    {
      v33 = *(double **)buf;
      operator delete(*(void **)buf);
    }

  }
  else
  {
    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_46);
    v25 = logObject_MicroLocation_Default;
    if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_2419D9000, v25, OS_LOG_TYPE_DEFAULT, "CLMicroLocationLocalizationController, sendLocalizationCoreAnalyticsEvent, not sending event because sending to CoreAnalytics is disabled", buf, 2u);
    }
  }
}

void sub_241A5F820(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,void *__p,uint64_t a26)
{
  void *v26;

  if (__p)
    operator delete(__p);

  _Unwind_Resume(a1);
}

BOOL CLMicroLocationLocalizationController::calculateLocalizationResultsOnLastInputs(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4)
{
  int v4;
  uint64_t v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t *v11;
  unint64_t v12;
  uint64_t *v13;
  unint64_t *v14;
  unint64_t v15;
  uint64_t *v17;
  uint64_t *v18;
  uint64_t *v19;
  void **v20;
  char v21;
  _QWORD v22[3];

  v22[2] = *MEMORY[0x24BDAC8D0];
  v4 = *(unsigned __int8 *)(a1 + 488);
  if (*(_BYTE *)(a1 + 488))
  {
    v7 = a1 + 88;
    v8 = *(unsigned __int8 *)(a3 + 16);
    *(_OWORD *)a3 = *(_OWORD *)(a1 + 88);
    if (!v8)
      *(_BYTE *)(a3 + 16) = 1;
    v10 = *a2;
    v9 = a2[1];
    v22[0] = *a2;
    v22[1] = v9;
    if (v9)
    {
      v11 = (unint64_t *)(v9 + 8);
      do
        v12 = __ldxr(v11);
      while (__stxr(v12 + 1, v11));
    }
    v17 = 0;
    v18 = 0;
    v19 = 0;
    v20 = (void **)&v17;
    v21 = 0;
    v13 = (uint64_t *)operator new(0x10uLL);
    v17 = v13;
    v19 = v13 + 2;
    *v13 = v10;
    v13[1] = v9;
    if (v9)
    {
      v14 = (unint64_t *)(v9 + 8);
      do
        v15 = __ldxr(v14);
      while (__stxr(v15 + 1, v14));
    }
    v18 = v13 + 2;
    std::shared_ptr<CLMiLoService::ModelAndConf>::~shared_ptr[abi:ne180100]((uint64_t)v22);
    if (!*(_BYTE *)(a1 + 488))
      std::__throw_bad_optional_access[abi:ne180100]();
    CLMicroLocationLocalizationController::localizationRequestResultsPerModelInternal((const CLMicroLocationProto::AssociatedAccessPointInfo *)a1, v7, &v17, a4, 0, 0, 0);
    v20 = (void **)&v17;
    std::vector<std::shared_ptr<CLMiLoService::ModelAndConf>>::__destroy_vector::operator()[abi:ne180100](&v20);
  }
  return v4 != 0;
}

void sub_241A5F9D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  void **v5;
  va_list va;
  uint64_t v7;
  va_list va1;

  va_start(va1, a4);
  va_start(va, a4);
  v5 = va_arg(va1, void **);
  v7 = va_arg(va1, _QWORD);
  std::vector<std::shared_ptr<CLMiLoService::ModelAndConf>>::__destroy_vector::operator()[abi:ne180100]((void ***)va);
  std::shared_ptr<CLMiLoService::ModelAndConf>::~shared_ptr[abi:ne180100]((uint64_t)va1);
  _Unwind_Resume(a1);
}

uint64_t CLMicroLocationLocalizationController::localizationRequestResultsPerModel(uint64_t a1, uint64_t a2, uint64_t **a3, uint64_t a4)
{
  int HaveValidMeasurements;
  NSObject *v9;
  int v10;
  int v11;
  char *v12;
  void *v13;
  char *v14;
  int64_t v15;
  unint64_t v16;
  uint64_t v17;
  unint64_t v18;
  char *v19;
  char *v20;
  char *v21;
  int v22;
  void *v23;
  _QWORD *v24;
  CLMicroLocationProto::RecordingEvent *v25;
  uint64_t v26;
  const CLMicroLocationProto::Measurement *v27;
  const CLMicroLocationProto::Measurement *v28;
  char v29;
  uint64_t v30;
  float v31;
  CLMicroLocationProto::Measurement *v32;
  uint64_t v33;
  uint64_t v34;
  NSObject *v35;
  _BYTE v37[32];
  void *__p[2];
  char *v39;
  unint64_t v40[2];
  uint64_t v41;
  uint8_t buf[32];
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  _OWORD v56[9];
  __int128 v57;
  _BYTE v58[17];
  _BYTE v59[160];
  int v60;
  void *__src;
  uint64_t v62;
  char v63;
  uint64_t v64;

  v64 = *MEMORY[0x24BDAC8D0];
  HaveValidMeasurements = CLMicroLocationLocalizationController::doHaveValidMeasurements((CLMicroLocationLocalizationController *)a1, (const CLMicroLocationLocalizationController::LocalizationRequest *)a2);
  if ((HaveValidMeasurements & 1) == 0)
  {
    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_46);
    v9 = logObject_MicroLocation_Default;
    if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_2419D9000, v9, OS_LOG_TYPE_DEFAULT, "LocalizationController doesn't have any valid measurements to use, reporting empty results.", buf, 2u);
    }
  }
  CLMicroLocationFingerprintConfiguration::getLocalizingConfigurationFromSettings((uint64_t)v40);
  CLMicroLocationLocalizationController::LocalizationRequest::getConfidenceReasons((CLMicroLocationLocalizationController::LocalizationRequest *)a2, __p);
  CLMicroLocationProto::RecordingEvent::RecordingEvent((CLMicroLocationProto::RecordingEvent *)buf, (const CLMicroLocationProto::RecordingEvent *)a2);
  LOBYTE(v50) = 1;
  v58[0] = 0;
  v58[16] = 0;
  CLMicroLocationFingerprint::create(a1 + 40, (uint64_t)buf, (uint64_t)v58, v40, v59);
  if ((_BYTE)v50)
    CLMicroLocationProto::RecordingEvent::~RecordingEvent((CLMicroLocationProto::RecordingEvent *)buf);
  if (v63)
    v10 = HaveValidMeasurements;
  else
    v10 = 0;
  if (v10 == 1)
  {
    v11 = v60;
    std::vector<CLMicroLocationProto::ConfidenceLevel>::__assign_with_size[abi:ne180100]<CLMicroLocationProto::ConfidenceLevel*,CLMicroLocationProto::ConfidenceLevel*>((char *)__p, (char *)__src, v62, (v62 - (uint64_t)__src) >> 2);
  }
  else
  {
    v12 = (char *)__p[1];
    if (__p[1] >= v39)
    {
      v14 = (char *)__p[0];
      v15 = ((char *)__p[1] - (char *)__p[0]) >> 2;
      v16 = v15 + 1;
      if ((unint64_t)(v15 + 1) >> 62)
        std::vector<CLMicroLocationProto::ConfidenceReason>::__throw_length_error[abi:ne180100]();
      v17 = v39 - (char *)__p[0];
      if ((v39 - (char *)__p[0]) >> 1 > v16)
        v16 = v17 >> 1;
      if ((unint64_t)v17 >= 0x7FFFFFFFFFFFFFFCLL)
        v18 = 0x3FFFFFFFFFFFFFFFLL;
      else
        v18 = v16;
      if (v18)
      {
        v19 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<CLMicroLocationProto::ConfidenceReason>>((uint64_t)&v39, v18);
        v14 = (char *)__p[0];
        v12 = (char *)__p[1];
      }
      else
      {
        v19 = 0;
      }
      v20 = &v19[4 * v15];
      v21 = &v19[4 * v18];
      *(_DWORD *)v20 = 3;
      v13 = v20 + 4;
      while (v12 != v14)
      {
        v22 = *((_DWORD *)v12 - 1);
        v12 -= 4;
        *((_DWORD *)v20 - 1) = v22;
        v20 -= 4;
      }
      __p[0] = v20;
      __p[1] = v13;
      v39 = v21;
      if (v14)
        operator delete(v14);
    }
    else
    {
      *(_DWORD *)__p[1] = 3;
      v13 = v12 + 4;
    }
    v11 = 0;
    __p[1] = v13;
  }
  std::__optional_destruct_base<CLMicroLocationLocalizationController::LocalizationInput,false>::reset[abi:ne180100](a1 + 88);
  v57 = 0u;
  memset(v56, 0, sizeof(v56));
  v54 = 0u;
  v55 = 0u;
  v52 = 0u;
  v53 = 0u;
  v50 = 0u;
  v51 = 0u;
  v48 = 0u;
  v49 = 0u;
  v46 = 0u;
  v47 = 0u;
  v44 = 0u;
  v45 = 0u;
  v43 = 0u;
  memset(buf, 0, sizeof(buf));
  CLMicroLocationProto::RecordingEvent::RecordingEvent((CLMicroLocationProto::RecordingEvent *)((char *)v56 + 8));
  BYTE8(v57) = 0;
  BYTE12(v57) = 0;
  std::optional<CLMicroLocationLocalizationController::LocalizationInput>::operator=[abi:ne180100]<CLMicroLocationLocalizationController::LocalizationInput,void>(a1 + 88, (uint64_t)buf);
  CLMicroLocationProto::RecordingEvent::~RecordingEvent((CLMicroLocationProto::RecordingEvent *)((char *)v56 + 8));
  std::__optional_destruct_base<CLMicroLocationFingerprint,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)&v44);
  if (*(_QWORD *)&buf[24])
  {
    *(_QWORD *)&v43 = *(_QWORD *)&buf[24];
    operator delete(*(void **)&buf[24]);
  }
  v24 = (_QWORD *)(a1 + 112);
  v23 = *(void **)(a1 + 112);
  *(_OWORD *)(a1 + 88) = *(_OWORD *)(a2 + 144);
  *(_DWORD *)(a1 + 104) = v11;
  if (v23)
  {
    *(_QWORD *)(a1 + 120) = v23;
    operator delete(v23);
    *v24 = 0;
    *(_QWORD *)(a1 + 120) = 0;
    *(_QWORD *)(a1 + 128) = 0;
  }
  *(_OWORD *)(a1 + 112) = *(_OWORD *)__p;
  *(_QWORD *)(a1 + 128) = v39;
  __p[1] = 0;
  v39 = 0;
  __p[0] = 0;
  std::__optional_storage_base<CLMicroLocationFingerprint,false>::__assign_from[abi:ne180100]<std::__optional_move_assign_base<CLMicroLocationFingerprint,false>>(a1 + 136, (uint64_t)v59);
  CLMicroLocationProto::RecordingEvent::CopyFrom((CLMicroLocationProto::RecordingEvent *)(a1 + 336), (const CLMicroLocationProto::RecordingEvent *)a2);
  if ((*(_BYTE *)(a2 + 142) & 1) != 0)
  {
    v26 = *(_QWORD *)(a2 + 128);
    if (!v26)
      v26 = *(_QWORD *)(CLMicroLocationProto::RecordingEvent::default_instance(v25) + 128);
    v27 = *(const CLMicroLocationProto::Measurement **)(a1 + 40);
    v28 = *(const CLMicroLocationProto::Measurement **)(a1 + 48);
    if (v27 != v28)
    {
      v29 = 0;
      v30 = *(_QWORD *)(v26 + 8);
      v31 = -3.4028e38;
      do
      {
        v32 = (CLMicroLocationProto::Measurement *)CLMicroLocationProto::Measurement::Measurement((CLMicroLocationProto::Measurement *)buf, v27);
        if ((_DWORD)v45 == 1 && (BYTE8(v45) & 4) != 0)
        {
          v33 = *(_QWORD *)&buf[16];
          if (!*(_QWORD *)&buf[16])
          {
            v32 = (CLMicroLocationProto::Measurement *)CLMicroLocationProto::Measurement::default_instance(v32);
            v33 = *((_QWORD *)v32 + 2);
          }
          if (*(_QWORD *)(v33 + 24) == v30)
          {
            v34 = *(_QWORD *)&buf[16];
            if (!*(_QWORD *)&buf[16])
              v34 = *(_QWORD *)(CLMicroLocationProto::Measurement::default_instance(v32) + 16);
            if (v31 < *(float *)(v34 + 20))
              v31 = *(float *)(v34 + 20);
            v29 = 1;
          }
        }
        CLMicroLocationProto::Measurement::~Measurement((CLMicroLocationProto::Measurement *)buf);
        v27 = (const CLMicroLocationProto::Measurement *)((char *)v27 + 88);
      }
      while (v27 != v28);
      if ((v29 & 1) != 0)
      {
        if (onceToken_MicroLocation_Default != -1)
          dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_46);
        v35 = logObject_MicroLocation_Default;
        if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 68289282;
          *(_DWORD *)&buf[4] = 0;
          *(_WORD *)&buf[8] = 2082;
          *(_QWORD *)&buf[10] = "";
          *(_WORD *)&buf[18] = 2050;
          *(double *)&buf[20] = v31;
          _os_log_impl(&dword_2419D9000, v35, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"LocalizationController, setting associated AP's RSSI based on scan data\", \"RSSI\":\"%{public}f\"}", buf, 0x1Cu);
        }
        CLMicroLocationProto::AssociatedAccessPointInfo::AssociatedAccessPointInfo((uint64_t)buf);
        *(float *)&buf[16] = v31;
        *(_DWORD *)&buf[24] |= 3u;
        *(_QWORD *)&buf[8] = v30;
        CLMicroLocationProto::AssociatedAccessPointInfo::AssociatedAccessPointInfo((CLMicroLocationProto::AssociatedAccessPointInfo *)v37, (const CLMicroLocationProto::AssociatedAccessPointInfo *)buf);
        std::optional<CLMicroLocationProto::AssociatedAccessPointInfo>::operator=[abi:ne180100]<CLMicroLocationProto::AssociatedAccessPointInfo&,void>((CLMicroLocationProto::AssociatedAccessPointInfo *)a1, (const CLMicroLocationProto::AssociatedAccessPointInfo *)v37);
        CLMicroLocationProto::AssociatedAccessPointInfo::~AssociatedAccessPointInfo((CLMicroLocationProto::AssociatedAccessPointInfo *)v37);
        CLMicroLocationProto::AssociatedAccessPointInfo::~AssociatedAccessPointInfo((CLMicroLocationProto::AssociatedAccessPointInfo *)buf);
      }
    }
  }
  if (!*(_BYTE *)(a1 + 488))
    std::__throw_bad_optional_access[abi:ne180100]();
  CLMicroLocationLocalizationController::localizationRequestResultsPerModelInternal((const CLMicroLocationProto::AssociatedAccessPointInfo *)a1, a1 + 88, a3, a4, *(_QWORD *)(a2 + 160), 1, 1);
  *(_DWORD *)(a1 + 104) = *(_DWORD *)(a4 + 24);
  if (v24 != (_QWORD *)(a4 + 32))
    std::vector<CLMicroLocationProto::ConfidenceLevel>::__assign_with_size[abi:ne180100]<CLMicroLocationProto::ConfidenceLevel*,CLMicroLocationProto::ConfidenceLevel*>((char *)(a1 + 112), *(char **)(a4 + 32), *(_QWORD *)(a4 + 40), (uint64_t)(*(_QWORD *)(a4 + 40) - *(_QWORD *)(a4 + 32)) >> 2);
  std::__optional_destruct_base<CLMicroLocationFingerprint,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)v59);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  return std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>>>::~__hash_table((uint64_t)&v41);
}

void sub_241A5FF30(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23)
{
  CLMicroLocationProto::AssociatedAccessPointInfo::~AssociatedAccessPointInfo((CLMicroLocationProto::AssociatedAccessPointInfo *)&a9);
  CLMicroLocationProto::AssociatedAccessPointInfo::~AssociatedAccessPointInfo((CLMicroLocationProto::AssociatedAccessPointInfo *)&a23);
  std::__optional_destruct_base<CLMicroLocationFingerprint,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)&STACK[0x218]);
  if (__p)
  {
    a14 = (uint64_t)__p;
    operator delete(__p);
  }
  std::__hash_table<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::__unordered_map_hasher<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,true>,std::__unordered_map_equal<boost::uuids::uuid,std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>,std::equal_to<boost::uuids::uuid>,std::hash<boost::uuids::uuid>,true>,std::allocator<std::__hash_value_type<boost::uuids::uuid,CLMicroLocationTriggerManager::Policy>>>::~__hash_table((uint64_t)&a18);
  _Unwind_Resume(a1);
}

void std::__optional_destruct_base<CLMicroLocationLocalizationController::LocalizationInput,false>::reset[abi:ne180100](uint64_t a1)
{
  void *v2;

  if (*(_BYTE *)(a1 + 400))
  {
    CLMicroLocationProto::RecordingEvent::~RecordingEvent((CLMicroLocationProto::RecordingEvent *)(a1 + 248));
    std::__optional_destruct_base<CLMicroLocationFingerprint,false>::~__optional_destruct_base[abi:ne180100](a1 + 48);
    v2 = *(void **)(a1 + 24);
    if (v2)
    {
      *(_QWORD *)(a1 + 32) = v2;
      operator delete(v2);
    }
    *(_BYTE *)(a1 + 400) = 0;
  }
}

uint64_t std::optional<CLMicroLocationLocalizationController::LocalizationInput>::operator=[abi:ne180100]<CLMicroLocationLocalizationController::LocalizationInput,void>(uint64_t a1, uint64_t a2)
{
  __int128 v4;
  int v5;

  if (*(_BYTE *)(a1 + 400))
  {
    v4 = *(_OWORD *)a2;
    *(_DWORD *)(a1 + 16) = *(_DWORD *)(a2 + 16);
    *(_OWORD *)a1 = v4;
    std::vector<CLMicroLocationResultInternal>::__move_assign(a1 + 24, (__n128 *)(a2 + 24));
    std::__optional_storage_base<CLMicroLocationFingerprint,false>::__assign_from[abi:ne180100]<std::__optional_move_assign_base<CLMicroLocationFingerprint,false>>(a1 + 48, a2 + 48);
    CLMicroLocationProto::RecordingEvent::CopyFrom((CLMicroLocationProto::RecordingEvent *)(a1 + 248), (const CLMicroLocationProto::RecordingEvent *)(a2 + 248));
    v5 = *(_DWORD *)(a2 + 392);
    *(_BYTE *)(a1 + 396) = *(_BYTE *)(a2 + 396);
    *(_DWORD *)(a1 + 392) = v5;
  }
  else
  {
    std::__construct_at[abi:ne180100]<CLMicroLocationLocalizationController::LocalizationInput,CLMicroLocationLocalizationController::LocalizationInput,CLMicroLocationLocalizationController::LocalizationInput*>(a1, (__int128 *)a2);
    *(_BYTE *)(a1 + 400) = 1;
  }
  return a1;
}

void CLMicroLocationLocalizationController::LocalizationInput::~LocalizationInput(CLMicroLocationLocalizationController::LocalizationInput *this)
{
  void *v2;

  CLMicroLocationProto::RecordingEvent::~RecordingEvent((CLMicroLocationLocalizationController::LocalizationInput *)((char *)this + 248));
  std::__optional_destruct_base<CLMicroLocationFingerprint,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)this + 48);
  v2 = (void *)*((_QWORD *)this + 3);
  if (v2)
  {
    *((_QWORD *)this + 4) = v2;
    operator delete(v2);
  }
}

void CLMicroLocationLocalizationController::stop(_QWORD *a1, _QWORD *a2, uint64_t **a3, uint64_t a4)
{
  uint64_t v8;
  uint64_t v9;
  NSObject *v11;
  char *v12;
  uint64_t i;
  uint64_t v14;
  NSObject *v15;
  char *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t j;
  _BYTE v21[18];
  __int16 v22;
  char *v23;
  uint64_t v24;

  v24 = *MEMORY[0x24BDAC8D0];
  v9 = a1[8];
  v8 = a1[9];
  if (v9 != v8)
  {
    while (1)
    {
      *(_OWORD *)v21 = *(_OWORD *)(v9 + 144);
      if (*(_QWORD *)v21 == *a2 && *(_QWORD *)&v21[8] == a2[1])
        break;
      v9 += 200;
      if (v9 == v8)
        goto LABEL_16;
    }
  }
  if (v9 == v8)
  {
LABEL_16:
    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_46);
    v15 = (id)logObject_MicroLocation_Default;
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      v16 = (char *)operator new(0x28uLL);
      *(_QWORD *)(v16 + 29) = 0;
      *(_OWORD *)v16 = 0u;
      *((_OWORD *)v16 + 1) = 0u;
      boost::uuids::to_chars<char *>((uint64_t)a2, v16);
      *(_QWORD *)v21 = 68289282;
      *(_WORD *)&v21[8] = 2082;
      *(_QWORD *)&v21[10] = "";
      v22 = 2082;
      v23 = v16;
      _os_log_impl(&dword_2419D9000, v15, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"LocalizationController, Requested stop for non-existent localization request\", \"Request ID\":%{public, location:escape_only}s}", v21, 0x1Cu);
      operator delete(v16);
    }

  }
  else
  {
    std::unique_ptr<CLMicroLocationTimeUtils::TimeProfile>::reset[abi:ne180100]((CLMicroLocationTimeUtils::TimeProfile **)(v9 + 168), 0);
    CLMicroLocationLocalizationController::LocalizationRequest::finalizeTriggerConfidence((CLMicroLocationLocalizationController::LocalizationRequest *)v9);
    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_46);
    v11 = (id)logObject_MicroLocation_Default;
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      v12 = (char *)operator new(0x28uLL);
      *(_QWORD *)(v12 + 29) = 0;
      *(_OWORD *)v12 = 0u;
      *((_OWORD *)v12 + 1) = 0u;
      boost::uuids::to_chars<char *>((uint64_t)a2, v12);
      *(_QWORD *)v21 = 68289282;
      *(_WORD *)&v21[8] = 2082;
      *(_QWORD *)&v21[10] = "";
      v22 = 2082;
      v23 = v12;
      _os_log_impl(&dword_2419D9000, v11, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"LocalizationController, Requested stop for localization request\", \"Request ID\":%{public, location:escape_only}s}", v21, 0x1Cu);
      operator delete(v12);
    }

    CLMicroLocationLocalizationController::localizationRequestResultsPerModel((uint64_t)a1, v9, a3, a4);
    v14 = a1[5];
    for (i = a1[6];
          i != v14;
    v17 = a1[9];
    a1[6] = v14;
    std::__unwrap_and_dispatch[abi:ne180100]<std::__overload<std::__move_loop<std::_ClassicAlgPolicy>,std::__move_trivial>,CLMicroLocationLocalizationController::LocalizationRequest *,CLMicroLocationLocalizationController::LocalizationRequest *,CLMicroLocationLocalizationController::LocalizationRequest *,0>(v9 + 200, v17, v9);
    v19 = v18;
    for (j = a1[9];
          j != v19;
    a1[9] = v19;
  }
}

void sub_241A603E4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  operator delete(v2);

  _Unwind_Resume(a1);
}

void CLMicroLocationLocalizationController::setIgnoreBleRssiMeasurements(CLMicroLocationLocalizationController *this, const uuid *a2)
{
  uint64_t v3;
  uint64_t v4;
  NSObject *v6;
  char *v7;
  _BYTE v8[18];
  __int16 v9;
  char *v10;
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  v3 = *((_QWORD *)this + 8);
  v4 = *((_QWORD *)this + 9);
  if (v3 != v4)
  {
    while (1)
    {
      *(_OWORD *)v8 = *(_OWORD *)(v3 + 144);
      if (*(_QWORD *)v8 == *(_QWORD *)a2->var0 && *(_QWORD *)&v8[8] == *(_QWORD *)&a2->var0[8])
        break;
      v3 += 200;
      if (v3 == v4)
        goto LABEL_10;
    }
  }
  if (v3 == v4)
  {
LABEL_10:
    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_46);
    v6 = (id)logObject_MicroLocation_Default;
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      v7 = (char *)operator new(0x28uLL);
      *(_QWORD *)(v7 + 29) = 0;
      *(_OWORD *)v7 = 0u;
      *((_OWORD *)v7 + 1) = 0u;
      boost::uuids::to_chars<char *>((uint64_t)a2, v7);
      *(_QWORD *)v8 = 68289282;
      *(_WORD *)&v8[8] = 2082;
      *(_QWORD *)&v8[10] = "";
      v9 = 2082;
      v10 = v7;
      _os_log_impl(&dword_2419D9000, v6, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"Requested set Ignore Ble Rssi Measurements for non-existent localization request\", \"Request ID\":%{public, location:escape_only}s}", v8, 0x1Cu);
      operator delete(v7);
    }

  }
  else
  {
    *(_DWORD *)(v3 + 140) |= 0x2000u;
    *(_BYTE *)(v3 + 77) = 1;
  }
}

void sub_241A60590(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  operator delete(v2);

  _Unwind_Resume(a1);
}

void CLMicroLocationLocalizationController::setIgnoreUwbRangeMeasurements(CLMicroLocationLocalizationController *this, const uuid *a2)
{
  uint64_t v3;
  uint64_t v4;
  NSObject *v6;
  char *v7;
  _BYTE v8[18];
  __int16 v9;
  char *v10;
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  v3 = *((_QWORD *)this + 8);
  v4 = *((_QWORD *)this + 9);
  if (v3 != v4)
  {
    while (1)
    {
      *(_OWORD *)v8 = *(_OWORD *)(v3 + 144);
      if (*(_QWORD *)v8 == *(_QWORD *)a2->var0 && *(_QWORD *)&v8[8] == *(_QWORD *)&a2->var0[8])
        break;
      v3 += 200;
      if (v3 == v4)
        goto LABEL_10;
    }
  }
  if (v3 == v4)
  {
LABEL_10:
    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_46);
    v6 = (id)logObject_MicroLocation_Default;
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      v7 = (char *)operator new(0x28uLL);
      *(_QWORD *)(v7 + 29) = 0;
      *(_OWORD *)v7 = 0u;
      *((_OWORD *)v7 + 1) = 0u;
      boost::uuids::to_chars<char *>((uint64_t)a2, v7);
      *(_QWORD *)v8 = 68289282;
      *(_WORD *)&v8[8] = 2082;
      *(_QWORD *)&v8[10] = "";
      v9 = 2082;
      v10 = v7;
      _os_log_impl(&dword_2419D9000, v6, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"Requested set Ignore Uwb Range Measurements for non-existent localization request\", \"Request ID\":%{public, location:escape_only}s}", v8, 0x1Cu);
      operator delete(v7);
    }

  }
  else
  {
    *(_DWORD *)(v3 + 140) |= 0x800u;
    *(_BYTE *)(v3 + 76) = 1;
  }
}

void sub_241A6072C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  operator delete(v2);

  _Unwind_Resume(a1);
}

void CLMicroLocationLocalizationController::setConfidenceAndReasons(uint64_t a1, _QWORD *a2, uint64_t *a3, _QWORD *a4)
{
  uint64_t v6;
  uint64_t v7;
  NSObject *v9;
  char *v10;
  NSObject *v11;
  char *v12;
  _BYTE v13[18];
  __int16 v14;
  char *v15;
  uint64_t v16;

  v16 = *MEMORY[0x24BDAC8D0];
  v6 = *(_QWORD *)(a1 + 64);
  v7 = *(_QWORD *)(a1 + 72);
  if (v6 != v7)
  {
    while (1)
    {
      *(_OWORD *)v13 = *(_OWORD *)(v6 + 144);
      if (*(_QWORD *)v13 == *a2 && *(_QWORD *)&v13[8] == a2[1])
        break;
      v6 += 200;
      if (v6 == v7)
        goto LABEL_13;
    }
  }
  if (v6 == v7)
  {
LABEL_13:
    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_46);
    v11 = (id)logObject_MicroLocation_Default;
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      v12 = (char *)operator new(0x28uLL);
      *(_QWORD *)(v12 + 29) = 0;
      *(_OWORD *)v12 = 0u;
      *((_OWORD *)v12 + 1) = 0u;
      boost::uuids::to_chars<char *>((uint64_t)a2, v12);
      *(_QWORD *)v13 = 68289282;
      *(_WORD *)&v13[8] = 2082;
      *(_QWORD *)&v13[10] = "";
      v14 = 2082;
      v15 = v12;
      _os_log_impl(&dword_2419D9000, v11, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"try to set confidence for non-existent localization request\", \"Request ID\":%{public, location:escape_only}s}", v13, 0x1Cu);
      operator delete(v12);
    }

    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_46);
    v9 = (id)logObject_MicroLocation_Default;
    if (os_signpost_enabled(v9))
    {
      v10 = (char *)operator new(0x28uLL);
      *(_QWORD *)(v10 + 29) = 0;
      *(_OWORD *)v10 = 0u;
      *((_OWORD *)v10 + 1) = 0u;
      boost::uuids::to_chars<char *>((uint64_t)a2, v10);
      *(_QWORD *)v13 = 68289282;
      *(_WORD *)&v13[8] = 2082;
      *(_QWORD *)&v13[10] = "";
      v14 = 2082;
      v15 = v10;
      _os_signpost_emit_with_name_impl(&dword_2419D9000, v9, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "try to set confidence for non-existent localization request", "{\"msg%{public}.0s\":\"try to set confidence for non-existent localization request\", \"Request ID\":%{public, location:escape_only}s}", v13, 0x1Cu);
      goto LABEL_21;
    }
  }
  else
  {
    CLMicroLocationLocalizationController::LocalizationRequest::setConfidenceAndReasons((_QWORD *)v6, a3, a4);
    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_46);
    v9 = (id)logObject_MicroLocation_Default;
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      v10 = (char *)operator new(0x28uLL);
      *(_QWORD *)(v10 + 29) = 0;
      *(_OWORD *)v10 = 0u;
      *((_OWORD *)v10 + 1) = 0u;
      boost::uuids::to_chars<char *>((uint64_t)a2, v10);
      *(_QWORD *)v13 = 68289282;
      *(_WORD *)&v13[8] = 2082;
      *(_QWORD *)&v13[10] = "";
      v14 = 2082;
      v15 = v10;
      _os_log_impl(&dword_2419D9000, v9, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"setting confidence in current Localization\", \"Request ID\":%{public, location:escape_only}s}", v13, 0x1Cu);
LABEL_21:
      operator delete(v10);
    }
  }

}

void sub_241A60A54(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  operator delete(v2);

  _Unwind_Resume(a1);
}

void CLMicroLocationLocalizationController::invalidateCachedLocalizationInput(CLMicroLocationLocalizationController *this)
{
  char *v1;
  NSObject *v2;
  _DWORD v3[2];
  __int16 v4;
  const char *v5;
  uint64_t v6;

  v6 = *MEMORY[0x24BDAC8D0];
  v1 = (char *)this + 88;
  std::__optional_destruct_base<CLMicroLocationLocalizationController::LocalizationInput,false>::reset[abi:ne180100]((uint64_t)this + 88);
  std::__optional_destruct_base<CLMicroLocationLocalizationController::LocalizationInput,false>::reset[abi:ne180100]((uint64_t)v1);
  if (onceToken_MicroLocation_Default != -1)
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_46);
  v2 = logObject_MicroLocation_Default;
  if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT))
  {
    v3[0] = 68289026;
    v3[1] = 0;
    v4 = 2082;
    v5 = "";
    _os_log_impl(&dword_2419D9000, v2, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"CLMicroLocationLocalizationController, invalidateCache\"}", (uint8_t *)v3, 0x12u);
  }
}

void CLMicroLocationLocalizationController::onStopMotion(CLMicroLocationLocalizationController *this, uuid *a2)
{
  uint64_t v3;
  uint64_t v4;
  NSObject *v6;
  char *v7;
  NSObject *v8;
  char *v9;
  _BYTE v10[18];
  __int16 v11;
  char *v12;
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  v3 = *((_QWORD *)this + 8);
  v4 = *((_QWORD *)this + 9);
  if (v3 != v4)
  {
    while (1)
    {
      *(_OWORD *)v10 = *(_OWORD *)(v3 + 144);
      if (*(_QWORD *)v10 == *(_QWORD *)a2->var0 && *(_QWORD *)&v10[8] == *(_QWORD *)&a2->var0[8])
        break;
      v3 += 200;
      if (v3 == v4)
        goto LABEL_10;
    }
  }
  if (v3 == v4)
  {
LABEL_10:
    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_46);
    v6 = (id)logObject_MicroLocation_Default;
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      v7 = (char *)operator new(0x28uLL);
      *(_QWORD *)(v7 + 29) = 0;
      *(_OWORD *)v7 = 0u;
      *((_OWORD *)v7 + 1) = 0u;
      boost::uuids::to_chars<char *>((uint64_t)a2, v7);
      *(_QWORD *)v10 = 68289282;
      *(_WORD *)&v10[8] = 2082;
      *(_QWORD *)&v10[10] = "";
      v11 = 2082;
      v12 = v7;
      _os_log_impl(&dword_2419D9000, v6, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"Requested to remove confidence reason for motion for non-existent localization request\", \"Request ID\":%{public, location:escape_only}s}", v10, 0x1Cu);
      operator delete(v7);
    }

    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_46);
    v8 = (id)logObject_MicroLocation_Default;
    if (os_signpost_enabled(v8))
    {
      v9 = (char *)operator new(0x28uLL);
      *(_QWORD *)(v9 + 29) = 0;
      *(_OWORD *)v9 = 0u;
      *((_OWORD *)v9 + 1) = 0u;
      boost::uuids::to_chars<char *>((uint64_t)a2, v9);
      *(_QWORD *)v10 = 68289282;
      *(_WORD *)&v10[8] = 2082;
      *(_QWORD *)&v10[10] = "";
      v11 = 2082;
      v12 = v9;
      _os_signpost_emit_with_name_impl(&dword_2419D9000, v8, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Requested to remove confidence reason for motion for non-existent localization request", "{\"msg%{public}.0s\":\"Requested to remove confidence reason for motion for non-existent localization request\", \"Request ID\":%{public, location:escape_only}s}", v10, 0x1Cu);
      operator delete(v9);
    }

  }
  else
  {
    CLMicroLocationLocalizationController::removeConfidenceReason((uint64_t)this, a2, 1u);
  }
}

void sub_241A60DF0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  operator delete(v2);

  _Unwind_Resume(a1);
}

void CLMicroLocationLocalizationController::removeConfidenceReason(uint64_t a1, _QWORD *a2, unsigned int a3)
{
  uint64_t v6;
  uint64_t v7;
  NSObject *v9;
  char *v10;
  void *v11;
  NSObject *v12;
  char *v13;
  char *v14;
  _BYTE v15[18];
  __int16 v16;
  char *v17;
  __int16 v18;
  uint64_t v19;
  uint64_t v20;

  v20 = *MEMORY[0x24BDAC8D0];
  v6 = *(_QWORD *)(a1 + 64);
  v7 = *(_QWORD *)(a1 + 72);
  if (v6 != v7)
  {
    while (1)
    {
      *(_OWORD *)v15 = *(_OWORD *)(v6 + 144);
      if (*(_QWORD *)v15 == *a2 && *(_QWORD *)&v15[8] == a2[1])
        break;
      v6 += 200;
      if (v6 == v7)
        goto LABEL_13;
    }
  }
  if (v6 == v7)
  {
LABEL_13:
    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_46);
    v12 = (id)logObject_MicroLocation_Default;
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      v13 = (char *)operator new(0x28uLL);
      *(_QWORD *)(v13 + 29) = 0;
      *(_OWORD *)v13 = 0u;
      *((_OWORD *)v13 + 1) = 0u;
      boost::uuids::to_chars<char *>((uint64_t)a2, v13);
      *(_QWORD *)v15 = 68289282;
      *(_WORD *)&v15[8] = 2082;
      *(_QWORD *)&v15[10] = "";
      v16 = 2082;
      v17 = v13;
      _os_log_impl(&dword_2419D9000, v12, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"Requested remove confidence reason for non-existent localization request\", \"Request ID\":%{public, location:escape_only}s}", v15, 0x1Cu);
      operator delete(v13);
    }

    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_46);
    v9 = (id)logObject_MicroLocation_Default;
    if (os_signpost_enabled(v9))
    {
      v14 = (char *)operator new(0x28uLL);
      *(_QWORD *)(v14 + 29) = 0;
      *(_OWORD *)v14 = 0u;
      *((_OWORD *)v14 + 1) = 0u;
      boost::uuids::to_chars<char *>((uint64_t)a2, v14);
      *(_QWORD *)v15 = 68289282;
      *(_WORD *)&v15[8] = 2082;
      *(_QWORD *)&v15[10] = "";
      v16 = 2082;
      v17 = v14;
      _os_signpost_emit_with_name_impl(&dword_2419D9000, v9, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Requested remove confidence reason for non-existent localization request", "{\"msg%{public}.0s\":\"Requested remove confidence reason for non-existent localization request\", \"Request ID\":%{public, location:escape_only}s}", v15, 0x1Cu);
      v11 = v14;
      goto LABEL_21;
    }
  }
  else
  {
    CLMicroLocationLocalizationController::LocalizationRequest::removeConfidenceReason(v6, a3);
    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_46);
    v9 = (id)logObject_MicroLocation_Default;
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      v10 = (char *)operator new(0x28uLL);
      *(_QWORD *)(v10 + 29) = 0;
      *(_OWORD *)v10 = 0u;
      *((_OWORD *)v10 + 1) = 0u;
      boost::uuids::to_chars<char *>((uint64_t)a2, v10);
      *(_QWORD *)v15 = 68289538;
      *(_WORD *)&v15[8] = 2082;
      *(_QWORD *)&v15[10] = "";
      v16 = 2082;
      v17 = v10;
      v18 = 2050;
      v19 = a3;
      _os_log_impl(&dword_2419D9000, v9, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"removing confidence reason\", \"Request ID\":%{public, location:escape_only}s, \"confidence reason\":%{public}lu}", v15, 0x26u);
      v11 = v10;
LABEL_21:
      operator delete(v11);
    }
  }

}

void sub_241A61148(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  operator delete(v2);

  _Unwind_Resume(a1);
}

_QWORD *std::optional<std::vector<CLMicroLocationResultInternal>>::value_or[abi:ne180100]<std::vector<CLMicroLocationResultInternal> const&>@<X0>(uint64_t a1@<X0>, const void **a2@<X1>, _QWORD *a3@<X8>)
{
  int v5;
  const void *v6;
  uint64_t v7;
  unint64_t v8;

  v5 = *(unsigned __int8 *)(a1 + 24);
  a3[1] = 0;
  a3[2] = 0;
  *a3 = 0;
  if (v5)
  {
    v6 = *(const void **)a1;
    v7 = *(_QWORD *)(a1 + 8);
    v8 = (v7 - *(_QWORD *)a1) >> 5;
  }
  else
  {
    v7 = (uint64_t)a2[1];
    v8 = (v7 - (uint64_t)*a2) >> 5;
    v6 = *a2;
  }
  return std::vector<CLMicroLocationResultInternal>::__init_with_size[abi:ne180100]<CLMicroLocationResultInternal*,CLMicroLocationResultInternal*>(a3, v6, v7, v8);
}

id ___ZNK37CLMicroLocationLocalizationController34sendLocalizationCoreAnalyticsEventERKN13CLMiLoService12ModelAndConfERKNSt3__16vectorI29CLMicroLocationResultInternalNS4_9allocatorIS6_EEEERKNS4_8optionalIS9_EERK26CLMicroLocationFingerprintRKN20CLMicroLocationProto14RecordingEventERKNSC_INS4_6chrono10time_pointIN2cl6chrono19CFAbsoluteTimeClockENSN_8durationIeNS4_5ratioILl1ELl1EEEEEEEEE_block_invoke(uint64_t a1)
{
  void *v2;
  void *v3;
  uint64_t v4;
  void *v5;
  void *v6;
  uint64_t v7;
  void *v8;
  void *v9;
  uint64_t *v10;
  void *v11;
  void *v12;
  void *v13;
  uint64_t v14;
  void *v15;
  uint64_t v16;
  void *v17;
  const std::string *v18;
  void *v19;
  std::string *v20;
  void *v21;
  uint64_t v22;
  void *v23;
  void *v24;
  std::string __p;

  objc_msgSend(MEMORY[0x24BDBCED8], "dictionary");
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x24BDD16E0], "numberWithUnsignedLong:", *(_QWORD *)(a1 + 48));
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v2, "setObject:forKeyedSubscript:", v3, CFSTR("bleFingerprintSize"));

  if (*(_QWORD *)(a1 + 48) >= 0x19uLL)
    v4 = 25;
  else
    v4 = *(_QWORD *)(a1 + 48);
  objc_msgSend(MEMORY[0x24BDD16E0], "numberWithUnsignedLong:", v4);
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v2, "setObject:forKeyedSubscript:", v5, CFSTR("bleFingerprintSizeBounded"));

  objc_msgSend(MEMORY[0x24BDD16E0], "numberWithUnsignedLong:", *(_QWORD *)(a1 + 56));
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v2, "setObject:forKeyedSubscript:", v6, CFSTR("uwbFingerprintSize"));

  if (*(_QWORD *)(a1 + 56) >= 0x19uLL)
    v7 = 25;
  else
    v7 = *(_QWORD *)(a1 + 56);
  objc_msgSend(MEMORY[0x24BDD16E0], "numberWithUnsignedLong:", v7);
  v8 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v2, "setObject:forKeyedSubscript:", v8, CFSTR("uwbFingerprintSizeBounded"));

  objc_msgSend(MEMORY[0x24BDD16E0], "numberWithDouble:", *(double *)(a1 + 64));
  v9 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v2, "setObject:forKeyedSubscript:", v9, CFSTR("maxClusterProbability"));

  v10 = *(uint64_t **)(a1 + 72);
  if (*((char *)v10 + 23) < 0)
    v10 = (uint64_t *)*v10;
  objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", v10);
  v11 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v2, "setObject:forKeyedSubscript:", v11, CFSTR("modelType"));

  objc_msgSend(MEMORY[0x24BDD16E0], "numberWithDouble:", *(double *)(a1 + 80));
  v12 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v2, "setObject:forKeyedSubscript:", v12, CFSTR("nullspaceClusterProbability"));

  objc_msgSend(MEMORY[0x24BDD16E0], "numberWithUnsignedLong:", *(_QWORD *)(a1 + 88));
  v13 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v2, "setObject:forKeyedSubscript:", v13, CFSTR("wifiFingerprintSize"));

  if (*(_QWORD *)(a1 + 88) >= 0x64uLL)
    v14 = 100;
  else
    v14 = *(_QWORD *)(a1 + 88);
  objc_msgSend(MEMORY[0x24BDD16E0], "numberWithUnsignedLong:", v14);
  v15 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v2, "setObject:forKeyedSubscript:", v15, CFSTR("wifiFingerprintSizeBounded"));

  objc_msgSend(v2, "setObject:forKeyedSubscript:", *(_QWORD *)(a1 + 32), CFSTR("localizationTriggerEvent"));
  objc_msgSend(v2, "setObject:forKeyedSubscript:", &unk_2511ED8B8, CFSTR("localizationTriggerEventCount"));
  v16 = *(_QWORD *)(a1 + 96);
  if (*(_BYTE *)(v16 + 8))
  {
    objc_msgSend(MEMORY[0x24BDD16E0], "numberWithDouble:", *(double *)(a1 + 104) - *(double *)v16);
    v17 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v2, "setObject:forKeyedSubscript:", v17, CFSTR("localizationRunTime"));

  }
  v18 = *(const std::string **)(a1 + 112);
  if (v18[1].__r_.__value_.__s.__data_[0])
  {
    v19 = (void *)MEMORY[0x24BDD17C8];
    CLMicroLocationClientUtils::getClientIdFromClientIdAndServiceUuid(v18, &__p);
    v20 = (__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
        ? &__p
        : (std::string *)__p.__r_.__value_.__r.__words[0];
    objc_msgSend(v19, "stringWithUTF8String:", v20);
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v2, "setObject:forKeyedSubscript:", v21, CFSTR("clientId"));

    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p.__r_.__value_.__l.__data_);
  }
  v22 = *(_QWORD *)(a1 + 40);
  if (v22)
    objc_msgSend(v2, "setObject:forKeyedSubscript:", v22, CFSTR("roiProbability"));
  objc_msgSend(MEMORY[0x24BDD16E0], "numberWithBool:", *(unsigned __int8 *)(*(_QWORD *)(a1 + 120) + 77));
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v2, "setObject:forKeyedSubscript:", v23, CFSTR("bleRssiSamplesIgnore"));

  objc_msgSend(MEMORY[0x24BDD16E0], "numberWithBool:", *(unsigned __int8 *)(*(_QWORD *)(a1 + 120) + 76));
  v24 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v2, "setObject:forKeyedSubscript:", v24, CFSTR("uwbRangeSamplesIgnore"));

  return v2;
}

void sub_241A61530(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  void *v15;
  void *v16;

  if (a15 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

uint64_t CLMicroLocationTimeUtils::TimeProfile::TimeProfile(uint64_t a1, __int128 *a2)
{
  __int128 v3;

  v3 = *a2;
  *(_QWORD *)(a1 + 16) = *((_QWORD *)a2 + 2);
  *(_OWORD *)a1 = v3;
  *((_QWORD *)a2 + 1) = 0;
  *((_QWORD *)a2 + 2) = 0;
  *(_QWORD *)a2 = 0;
  *(double *)(a1 + 24) = CLCommonGetMachContinuousTime();
  return a1;
}

void sub_241A615E4(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (*(char *)(v1 + 23) < 0)
    operator delete(*(void **)v1);
  _Unwind_Resume(exception_object);
}

void ___ZL45_CLLogObjectForCategory_MicroLocation_Defaultv_block_invoke_39()
{
  os_log_t v0;
  void *v1;

  v0 = os_log_create("com.apple.MicroLocation", "MicroLocation");
  v1 = (void *)logObject_MicroLocation_Default;
  logObject_MicroLocation_Default = (uint64_t)v0;

}

_QWORD *std::vector<CLMicroLocationProto::ConfidenceReason>::vector<std::__tree_const_iterator<CLMicroLocationProto::ConfidenceReason,std::__tree_node<CLMicroLocationProto::ConfidenceReason,void *> *,long>,0>(_QWORD *a1, _QWORD *a2, _QWORD *a3)
{
  unint64_t v4;
  _QWORD *v5;
  _QWORD *v6;
  _QWORD *v7;
  BOOL v8;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2 == a3)
  {
    v4 = 0;
  }
  else
  {
    v4 = 0;
    v5 = a2;
    do
    {
      v6 = (_QWORD *)v5[1];
      if (v6)
      {
        do
        {
          v7 = v6;
          v6 = (_QWORD *)*v6;
        }
        while (v6);
      }
      else
      {
        do
        {
          v7 = (_QWORD *)v5[2];
          v8 = *v7 == (_QWORD)v5;
          v5 = v7;
        }
        while (!v8);
      }
      ++v4;
      v5 = v7;
    }
    while (v7 != a3);
  }
  std::vector<CLMicroLocationProto::ConfidenceReason>::__init_with_size[abi:ne180100]<std::__tree_const_iterator<CLMicroLocationProto::ConfidenceReason,std::__tree_node<CLMicroLocationProto::ConfidenceReason,void *> *,long>,std::__tree_const_iterator<CLMicroLocationProto::ConfidenceReason,std::__tree_node<CLMicroLocationProto::ConfidenceReason,void *> *,long>>(a1, a2, a3, v4);
  return a1;
}

_QWORD *std::vector<CLMicroLocationProto::ConfidenceReason>::__init_with_size[abi:ne180100]<std::__tree_const_iterator<CLMicroLocationProto::ConfidenceReason,std::__tree_node<CLMicroLocationProto::ConfidenceReason,void *> *,long>,std::__tree_const_iterator<CLMicroLocationProto::ConfidenceReason,std::__tree_node<CLMicroLocationProto::ConfidenceReason,void *> *,long>>(_QWORD *result, _QWORD *a2, _QWORD *a3, unint64_t a4)
{
  uint64_t v6;

  if (a4)
  {
    v6 = (uint64_t)result;
    std::vector<CLMicroLocationProto::ConfidenceLevel>::__vallocate[abi:ne180100](result, a4);
    return (_QWORD *)std::vector<CLMicroLocationProto::ConfidenceReason>::__construct_at_end<std::__tree_const_iterator<CLMicroLocationProto::ConfidenceReason,std::__tree_node<CLMicroLocationProto::ConfidenceReason,void *> *,long>,std::__tree_const_iterator<CLMicroLocationProto::ConfidenceReason,std::__tree_node<CLMicroLocationProto::ConfidenceReason,void *> *,long>>(v6, a2, a3);
  }
  return result;
}

void sub_241A61704(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::vector<CLMicroLocationProto::ConfidenceReason>::__construct_at_end<std::__tree_const_iterator<CLMicroLocationProto::ConfidenceReason,std::__tree_node<CLMicroLocationProto::ConfidenceReason,void *> *,long>,std::__tree_const_iterator<CLMicroLocationProto::ConfidenceReason,std::__tree_node<CLMicroLocationProto::ConfidenceReason,void *> *,long>>(uint64_t result, _QWORD *a2, _QWORD *a3)
{
  _DWORD *v3;
  _QWORD *v4;
  _QWORD *v5;
  BOOL v6;

  v3 = *(_DWORD **)(result + 8);
  if (a2 != a3)
  {
    do
    {
      *v3 = *((_DWORD *)a2 + 7);
      v4 = (_QWORD *)a2[1];
      if (v4)
      {
        do
        {
          v5 = v4;
          v4 = (_QWORD *)*v4;
        }
        while (v4);
      }
      else
      {
        do
        {
          v5 = (_QWORD *)a2[2];
          v6 = *v5 == (_QWORD)a2;
          a2 = v5;
        }
        while (!v6);
      }
      ++v3;
      a2 = v5;
    }
    while (v5 != a3);
  }
  *(_QWORD *)(result + 8) = v3;
  return result;
}

__n128 std::__optional_storage_base<std::vector<CLMicroLocationResultInternal>,false>::__assign_from[abi:ne180100]<std::__optional_move_assign_base<std::vector<CLMicroLocationResultInternal>,false>>(uint64_t a1, __n128 *a2)
{
  __n128 result;
  void *v4;

  if (*(unsigned __int8 *)(a1 + 24) == a2[1].n128_u8[8])
  {
    if (*(_BYTE *)(a1 + 24))
      result.n128_u64[0] = std::vector<CLMicroLocationResultInternal>::__move_assign(a1, a2).n128_u64[0];
  }
  else if (*(_BYTE *)(a1 + 24))
  {
    v4 = *(void **)a1;
    if (*(_QWORD *)a1)
    {
      *(_QWORD *)(a1 + 8) = v4;
      operator delete(v4);
    }
    *(_BYTE *)(a1 + 24) = 0;
  }
  else
  {
    *(_QWORD *)a1 = 0;
    *(_QWORD *)(a1 + 8) = 0;
    *(_QWORD *)(a1 + 16) = 0;
    result = *a2;
    *(__n128 *)a1 = *a2;
    *(_QWORD *)(a1 + 16) = a2[1].n128_u64[0];
    a2->n128_u64[0] = 0;
    a2->n128_u64[1] = 0;
    a2[1].n128_u64[0] = 0;
    *(_BYTE *)(a1 + 24) = 1;
  }
  return result;
}

uint64_t std::optional<std::unordered_map<std::string,AnchorValueStatistics>>::emplace[abi:ne180100]<std::unordered_map<std::string,AnchorValueStatistics> const&,void>(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  if (*(_BYTE *)(a1 + 40))
  {
    a1 = std::__hash_table<std::__hash_value_type<std::string,AnchorValueStatistics>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,AnchorValueStatistics>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,AnchorValueStatistics>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,AnchorValueStatistics>>>::~__hash_table(a1);
    *(_BYTE *)(a1 + 40) = 0;
  }
  result = std::unordered_map<std::string,AnchorValueStatistics>::unordered_map(a1, a2);
  *(_BYTE *)(result + 40) = 1;
  return result;
}

void std::__optional_storage_base<std::unordered_map<std::string,AnchorValueStatistics>,false>::__assign_from[abi:ne180100]<std::__optional_move_assign_base<std::unordered_map<std::string,AnchorValueStatistics>,false>>(uint64_t a1, uint64_t a2)
{
  if (*(unsigned __int8 *)(a1 + 40) == *(unsigned __int8 *)(a2 + 40))
  {
    if (*(_BYTE *)(a1 + 40))
      std::__hash_table<std::__hash_value_type<std::string,AnchorValueStatistics>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,AnchorValueStatistics>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,AnchorValueStatistics>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,AnchorValueStatistics>>>::__move_assign(a1, (uint64_t *)a2);
  }
  else if (*(_BYTE *)(a1 + 40))
  {
    *(_BYTE *)(std::__hash_table<std::__hash_value_type<std::string,AnchorValueStatistics>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,AnchorValueStatistics>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,AnchorValueStatistics>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,AnchorValueStatistics>>>::~__hash_table(a1)
             + 40) = 0;
  }
  else
  {
    *(_BYTE *)(std::__hash_table<CLMicroLocationFingerprint::Measurement,CLMicroLocationFingerprint::Measurement::HashMeasurement,CLMicroLocationFingerprint::Measurement::PredicateMeasurement,std::allocator<CLMicroLocationFingerprint::Measurement>>::__hash_table(a1, (uint64_t *)a2)+ 40) = 1;
  }
}

void std::__hash_table<std::__hash_value_type<std::string,AnchorValueStatistics>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,AnchorValueStatistics>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,AnchorValueStatistics>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,AnchorValueStatistics>>>::__move_assign(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;
  void *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;

  std::__hash_table<std::__hash_value_type<std::string,AnchorValueStatistics>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,AnchorValueStatistics>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,AnchorValueStatistics>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,AnchorValueStatistics>>>::clear(a1);
  v4 = *a2;
  *a2 = 0;
  v5 = *(void **)a1;
  *(_QWORD *)a1 = v4;
  if (v5)
    operator delete(v5);
  v8 = a2[2];
  v7 = a2 + 2;
  v6 = v8;
  v9 = *(v7 - 1);
  *(_QWORD *)(a1 + 16) = v8;
  *(_QWORD *)(a1 + 8) = v9;
  *(v7 - 1) = 0;
  v10 = v7[1];
  *(_QWORD *)(a1 + 24) = v10;
  *(_DWORD *)(a1 + 32) = *((_DWORD *)v7 + 4);
  if (v10)
  {
    v11 = *(_QWORD *)(v6 + 8);
    v12 = *(_QWORD *)(a1 + 8);
    if ((v12 & (v12 - 1)) != 0)
    {
      if (v11 >= v12)
        v11 %= v12;
    }
    else
    {
      v11 &= v12 - 1;
    }
    *(_QWORD *)(*(_QWORD *)a1 + 8 * v11) = a1 + 16;
    *v7 = 0;
    v7[1] = 0;
  }
}

void std::__hash_table<std::__hash_value_type<std::string,AnchorValueStatistics>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,AnchorValueStatistics>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,AnchorValueStatistics>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,AnchorValueStatistics>>>::clear(uint64_t a1)
{
  uint64_t v2;
  uint64_t i;

  if (*(_QWORD *)(a1 + 24))
  {
    std::__hash_table<std::__hash_value_type<std::string,AnchorValueStatistics>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,AnchorValueStatistics>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,AnchorValueStatistics>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,AnchorValueStatistics>>>::__deallocate_node(a1, *(void ***)(a1 + 16));
    *(_QWORD *)(a1 + 16) = 0;
    v2 = *(_QWORD *)(a1 + 8);
    if (v2)
    {
      for (i = 0; i != v2; ++i)
        *(_QWORD *)(*(_QWORD *)a1 + 8 * i) = 0;
    }
    *(_QWORD *)(a1 + 24) = 0;
  }
}

uint64_t CLMicroLocationResultToPublish::CLMicroLocationResultToPublish(uint64_t a1, uint64_t a2, __int128 *a3, char a4, __int128 *a5, uint64_t a6, int a7, uint64_t a8)
{
  __int128 v11;
  uint64_t v12;
  __int128 v13;
  uint64_t v14;

  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(_QWORD *)(a1 + 16) = *(_QWORD *)(a2 + 16);
  *(_QWORD *)a2 = 0;
  *(_QWORD *)(a2 + 8) = 0;
  *(_QWORD *)(a2 + 16) = 0;
  v11 = *a3;
  v12 = *((_QWORD *)a3 + 2);
  *(_BYTE *)(a1 + 56) = 0;
  *(_QWORD *)(a1 + 40) = v12;
  *(_OWORD *)(a1 + 24) = v11;
  *(_BYTE *)(a1 + 48) = a4;
  *(_BYTE *)(a1 + 80) = 0;
  if (*((_BYTE *)a5 + 24))
  {
    v13 = *a5;
    *(_QWORD *)(a1 + 72) = *((_QWORD *)a5 + 2);
    *(_OWORD *)(a1 + 56) = v13;
    *((_QWORD *)a5 + 1) = 0;
    *((_QWORD *)a5 + 2) = 0;
    *(_QWORD *)a5 = 0;
    *(_BYTE *)(a1 + 80) = 1;
  }
  *(_BYTE *)(a1 + 88) = 0;
  v14 = a1 + 88;
  *(_BYTE *)(a1 + 128) = 0;
  if (*(_BYTE *)(a6 + 40))
  {
    std::__hash_table<CLMicroLocationFingerprint::Measurement,CLMicroLocationFingerprint::Measurement::HashMeasurement,CLMicroLocationFingerprint::Measurement::PredicateMeasurement,std::allocator<CLMicroLocationFingerprint::Measurement>>::__hash_table(v14, (uint64_t *)a6);
    *(_BYTE *)(a1 + 128) = 1;
  }
  *(_DWORD *)(a1 + 136) = a7;
  *(_QWORD *)(a1 + 152) = 0;
  *(_QWORD *)(a1 + 160) = 0;
  *(_QWORD *)(a1 + 144) = 0;
  *(_OWORD *)(a1 + 144) = *(_OWORD *)a8;
  *(_QWORD *)(a1 + 160) = *(_QWORD *)(a8 + 16);
  *(_QWORD *)a8 = 0;
  *(_QWORD *)(a8 + 8) = 0;
  *(_QWORD *)(a8 + 16) = 0;
  return a1;
}

void std::__optional_storage_base<CLMicroLocationFingerprint,false>::__assign_from[abi:ne180100]<std::__optional_move_assign_base<CLMicroLocationFingerprint,false>>(uint64_t a1, uint64_t a2)
{
  __int128 v4;
  __int128 v5;

  if (*(unsigned __int8 *)(a1 + 192) == *(unsigned __int8 *)(a2 + 192))
  {
    if (*(_BYTE *)(a1 + 192))
    {
      std::__hash_table<CLMicroLocationFingerprint::Measurement,CLMicroLocationFingerprint::Measurement::HashMeasurement,CLMicroLocationFingerprint::Measurement::PredicateMeasurement,std::allocator<CLMicroLocationFingerprint::Measurement>>::__move_assign(a1, (uint64_t *)a2);
      v4 = *(_OWORD *)(a2 + 40);
      *(_QWORD *)(a1 + 56) = *(_QWORD *)(a2 + 56);
      *(_OWORD *)(a1 + 40) = v4;
      std::__hash_table<CLMicroLocationProto::DataType,std::hash<CLMicroLocationProto::DataType>,std::equal_to<CLMicroLocationProto::DataType>,std::allocator<CLMicroLocationProto::DataType>>::__move_assign(a1 + 64, (uint64_t *)(a2 + 64));
      std::__hash_table<CLMicroLocationProto::DataType,std::hash<CLMicroLocationProto::DataType>,std::equal_to<CLMicroLocationProto::DataType>,std::allocator<CLMicroLocationProto::DataType>>::__move_assign(a1 + 104, (uint64_t *)(a2 + 104));
      v5 = *(_OWORD *)(a2 + 144);
      *(_DWORD *)(a1 + 160) = *(_DWORD *)(a2 + 160);
      *(_OWORD *)(a1 + 144) = v5;
      std::vector<CLMicroLocationResultInternal>::__move_assign(a1 + 168, (__n128 *)(a2 + 168));
    }
  }
  else if (*(_BYTE *)(a1 + 192))
  {
    std::__optional_destruct_base<CLMicroLocationFingerprint,false>::reset[abi:ne180100](a1);
  }
  else
  {
    std::__construct_at[abi:ne180100]<CLMicroLocationFingerprint,CLMicroLocationFingerprint,CLMicroLocationFingerprint*>(a1, a2);
    *(_BYTE *)(a1 + 192) = 1;
  }
}

void std::__hash_table<CLMicroLocationFingerprint::Measurement,CLMicroLocationFingerprint::Measurement::HashMeasurement,CLMicroLocationFingerprint::Measurement::PredicateMeasurement,std::allocator<CLMicroLocationFingerprint::Measurement>>::__move_assign(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;
  void *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;

  std::__hash_table<CLMicroLocationFingerprint::Measurement,CLMicroLocationFingerprint::Measurement::HashMeasurement,CLMicroLocationFingerprint::Measurement::PredicateMeasurement,std::allocator<CLMicroLocationFingerprint::Measurement>>::clear(a1);
  v4 = *a2;
  *a2 = 0;
  v5 = *(void **)a1;
  *(_QWORD *)a1 = v4;
  if (v5)
    operator delete(v5);
  v8 = a2[2];
  v7 = a2 + 2;
  v6 = v8;
  v9 = *(v7 - 1);
  *(_QWORD *)(a1 + 16) = v8;
  *(_QWORD *)(a1 + 8) = v9;
  *(v7 - 1) = 0;
  v10 = v7[1];
  *(_QWORD *)(a1 + 24) = v10;
  *(_DWORD *)(a1 + 32) = *((_DWORD *)v7 + 4);
  if (v10)
  {
    v11 = *(_QWORD *)(v6 + 8);
    v12 = *(_QWORD *)(a1 + 8);
    if ((v12 & (v12 - 1)) != 0)
    {
      if (v11 >= v12)
        v11 %= v12;
    }
    else
    {
      v11 &= v12 - 1;
    }
    *(_QWORD *)(*(_QWORD *)a1 + 8 * v11) = a1 + 16;
    *v7 = 0;
    v7[1] = 0;
  }
}

void std::__hash_table<CLMicroLocationFingerprint::Measurement,CLMicroLocationFingerprint::Measurement::HashMeasurement,CLMicroLocationFingerprint::Measurement::PredicateMeasurement,std::allocator<CLMicroLocationFingerprint::Measurement>>::clear(uint64_t a1)
{
  uint64_t v2;
  uint64_t i;

  if (*(_QWORD *)(a1 + 24))
  {
    std::__hash_table<CLMicroLocationFingerprint::Measurement,CLMicroLocationFingerprint::Measurement::HashMeasurement,CLMicroLocationFingerprint::Measurement::PredicateMeasurement,std::allocator<CLMicroLocationFingerprint::Measurement>>::__deallocate_node(a1, *(_QWORD **)(a1 + 16));
    *(_QWORD *)(a1 + 16) = 0;
    v2 = *(_QWORD *)(a1 + 8);
    if (v2)
    {
      for (i = 0; i != v2; ++i)
        *(_QWORD *)(*(_QWORD *)a1 + 8 * i) = 0;
    }
    *(_QWORD *)(a1 + 24) = 0;
  }
}

void std::__hash_table<CLMicroLocationProto::DataType,std::hash<CLMicroLocationProto::DataType>,std::equal_to<CLMicroLocationProto::DataType>,std::allocator<CLMicroLocationProto::DataType>>::__move_assign(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;
  void *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;

  std::__hash_table<boost::uuids::uuid,std::hash<boost::uuids::uuid>,std::equal_to<boost::uuids::uuid>,std::allocator<boost::uuids::uuid>>::clear((_QWORD *)a1);
  v4 = *a2;
  *a2 = 0;
  v5 = *(void **)a1;
  *(_QWORD *)a1 = v4;
  if (v5)
    operator delete(v5);
  v8 = a2[2];
  v7 = a2 + 2;
  v6 = v8;
  v9 = *(v7 - 1);
  *(_QWORD *)(a1 + 16) = v8;
  *(_QWORD *)(a1 + 8) = v9;
  *(v7 - 1) = 0;
  v10 = v7[1];
  *(_QWORD *)(a1 + 24) = v10;
  *(_DWORD *)(a1 + 32) = *((_DWORD *)v7 + 4);
  if (v10)
  {
    v11 = *(_QWORD *)(v6 + 8);
    v12 = *(_QWORD *)(a1 + 8);
    if ((v12 & (v12 - 1)) != 0)
    {
      if (v11 >= v12)
        v11 %= v12;
    }
    else
    {
      v11 &= v12 - 1;
    }
    *(_QWORD *)(*(_QWORD *)a1 + 8 * v11) = a1 + 16;
    *v7 = 0;
    v7[1] = 0;
  }
}

uint64_t std::__construct_at[abi:ne180100]<CLMicroLocationFingerprint,CLMicroLocationFingerprint,CLMicroLocationFingerprint*>(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  __int128 v5;
  __int128 v6;

  v4 = std::__hash_table<CLMicroLocationFingerprint::Measurement,CLMicroLocationFingerprint::Measurement::HashMeasurement,CLMicroLocationFingerprint::Measurement::PredicateMeasurement,std::allocator<CLMicroLocationFingerprint::Measurement>>::__hash_table(a1, (uint64_t *)a2);
  v5 = *(_OWORD *)(a2 + 40);
  *(_QWORD *)(v4 + 56) = *(_QWORD *)(a2 + 56);
  *(_OWORD *)(v4 + 40) = v5;
  std::__hash_table<CLMicroLocationFingerprint::Measurement,CLMicroLocationFingerprint::Measurement::HashMeasurement,CLMicroLocationFingerprint::Measurement::PredicateMeasurement,std::allocator<CLMicroLocationFingerprint::Measurement>>::__hash_table(v4 + 64, (uint64_t *)(a2 + 64));
  std::__hash_table<CLMicroLocationFingerprint::Measurement,CLMicroLocationFingerprint::Measurement::HashMeasurement,CLMicroLocationFingerprint::Measurement::PredicateMeasurement,std::allocator<CLMicroLocationFingerprint::Measurement>>::__hash_table(a1 + 104, (uint64_t *)(a2 + 104));
  v6 = *(_OWORD *)(a2 + 144);
  *(_DWORD *)(a1 + 160) = *(_DWORD *)(a2 + 160);
  *(_OWORD *)(a1 + 144) = v6;
  *(_QWORD *)(a1 + 176) = 0;
  *(_QWORD *)(a1 + 184) = 0;
  *(_QWORD *)(a1 + 168) = 0;
  *(_OWORD *)(a1 + 168) = *(_OWORD *)(a2 + 168);
  *(_QWORD *)(a1 + 184) = *(_QWORD *)(a2 + 184);
  *(_QWORD *)(a2 + 168) = 0;
  *(_QWORD *)(a2 + 176) = 0;
  *(_QWORD *)(a2 + 184) = 0;
  return a1;
}

CLMicroLocationProto::AssociatedAccessPointInfo *std::optional<CLMicroLocationProto::AssociatedAccessPointInfo>::operator=[abi:ne180100]<CLMicroLocationProto::AssociatedAccessPointInfo&,void>(CLMicroLocationProto::AssociatedAccessPointInfo *this, const CLMicroLocationProto::AssociatedAccessPointInfo *a2)
{
  if (*((_BYTE *)this + 32))
  {
    CLMicroLocationProto::AssociatedAccessPointInfo::CopyFrom(this, a2);
  }
  else
  {
    CLMicroLocationProto::AssociatedAccessPointInfo::AssociatedAccessPointInfo(this, a2);
    *((_BYTE *)this + 32) = 1;
  }
  return this;
}

void CLMicroLocationTimeUtils::TimeProfile::~TimeProfile(CLMicroLocationTimeUtils::TimeProfile *this)
{
  double MachContinuousTime;
  double v3;
  NSObject *v4;
  CLMicroLocationTimeUtils::TimeProfile *v5;
  _DWORD v6[2];
  __int16 v7;
  const char *v8;
  __int16 v9;
  CLMicroLocationTimeUtils::TimeProfile *v10;
  __int16 v11;
  double v12;
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  MachContinuousTime = CLCommonGetMachContinuousTime();
  v3 = *((double *)this + 3);
  if (onceToken_MicroLocation_Default != -1)
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_46);
  v4 = logObject_MicroLocation_Default;
  if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEBUG))
  {
    v5 = this;
    if (*((char *)this + 23) < 0)
      v5 = *(CLMicroLocationTimeUtils::TimeProfile **)this;
    v6[0] = 68289538;
    v6[1] = 0;
    v7 = 2082;
    v8 = "";
    v9 = 2082;
    v10 = v5;
    v11 = 2050;
    v12 = MachContinuousTime - v3;
    _os_log_impl(&dword_2419D9000, v4, OS_LOG_TYPE_DEBUG, "{\"msg%{public}.0s\":\"TimeProfile\", \"action\":%{public, location:escape_only}s, \"durationSecs\":\"%{public}f\"}", (uint8_t *)v6, 0x26u);
  }
  if (*((char *)this + 23) < 0)
    operator delete(*(void **)this);
}

void sub_241A61E88(_Unwind_Exception *a1, int a2)
{
  if (!a2)
    _Unwind_Resume(a1);
  __clang_call_terminate(a1);
}

__n128 std::vector<CLMicroLocationLocalizationController::LocalizationRequest>::__construct_one_at_end[abi:ne180100]<CLMicroLocationLocalizationController::LocalizationRequest>(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  __int128 v5;
  uint64_t v6;
  __n128 result;

  v4 = *(_QWORD *)(a1 + 8);
  CLMicroLocationProto::RecordingEvent::RecordingEvent((CLMicroLocationProto::RecordingEvent *)v4, (const CLMicroLocationProto::RecordingEvent *)a2);
  v5 = *(_OWORD *)(a2 + 144);
  *(_QWORD *)(v4 + 160) = *(_QWORD *)(a2 + 160);
  *(_OWORD *)(v4 + 144) = v5;
  v6 = *(_QWORD *)(a2 + 168);
  *(_QWORD *)(a2 + 168) = 0;
  *(_QWORD *)(v4 + 168) = v6;
  *(_QWORD *)(v4 + 176) = 0;
  *(_QWORD *)(v4 + 184) = 0;
  *(_QWORD *)(v4 + 192) = 0;
  result = *(__n128 *)(a2 + 176);
  *(__n128 *)(v4 + 176) = result;
  *(_QWORD *)(v4 + 192) = *(_QWORD *)(a2 + 192);
  *(_QWORD *)(a2 + 176) = 0;
  *(_QWORD *)(a2 + 184) = 0;
  *(_QWORD *)(a2 + 192) = 0;
  *(_QWORD *)(a1 + 8) = v4 + 200;
  return result;
}

void sub_241A61F08(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  *(_QWORD *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

uint64_t std::vector<CLMicroLocationLocalizationController::LocalizationRequest>::__push_back_slow_path<CLMicroLocationLocalizationController::LocalizationRequest>(uint64_t *a1, uint64_t a2)
{
  uint64_t v3;
  unint64_t v4;
  unint64_t v5;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  char *v10;
  CLMicroLocationProto::RecordingEvent *v11;
  __int128 v12;
  uint64_t v13;
  uint64_t v14;
  char *v16;
  CLMicroLocationProto::RecordingEvent *v17;
  CLMicroLocationProto::RecordingEvent *v18;
  char *v19;
  uint64_t *v20;

  v3 = *a1;
  v4 = 0x8F5C28F5C28F5C29 * ((a1[1] - *a1) >> 3);
  v5 = v4 + 1;
  if (v4 + 1 > 0x147AE147AE147AELL)
    std::vector<CLMicroLocationProto::ConfidenceReason>::__throw_length_error[abi:ne180100]();
  v7 = (uint64_t)(a1 + 2);
  v8 = 0x8F5C28F5C28F5C29 * ((a1[2] - v3) >> 3);
  if (2 * v8 > v5)
    v5 = 2 * v8;
  if (v8 >= 0xA3D70A3D70A3D7)
    v9 = 0x147AE147AE147AELL;
  else
    v9 = v5;
  v20 = a1 + 2;
  if (v9)
    v10 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<CLMicroLocationLocalizationController::LocalizationRequest>>(v7, v9);
  else
    v10 = 0;
  v16 = v10;
  v17 = (CLMicroLocationProto::RecordingEvent *)&v10[200 * v4];
  v18 = v17;
  v19 = &v10[200 * v9];
  CLMicroLocationProto::RecordingEvent::RecordingEvent(v17, (const CLMicroLocationProto::RecordingEvent *)a2);
  v11 = v17;
  v12 = *(_OWORD *)(a2 + 144);
  *((_QWORD *)v17 + 20) = *(_QWORD *)(a2 + 160);
  *((_OWORD *)v11 + 9) = v12;
  v13 = *(_QWORD *)(a2 + 168);
  *(_QWORD *)(a2 + 168) = 0;
  *((_QWORD *)v11 + 21) = v13;
  *((_QWORD *)v11 + 22) = 0;
  *((_QWORD *)v11 + 23) = 0;
  *((_QWORD *)v11 + 24) = 0;
  *((_OWORD *)v11 + 11) = *(_OWORD *)(a2 + 176);
  *((_QWORD *)v11 + 24) = *(_QWORD *)(a2 + 192);
  *(_QWORD *)(a2 + 176) = 0;
  *(_QWORD *)(a2 + 184) = 0;
  *(_QWORD *)(a2 + 192) = 0;
  v18 = (CLMicroLocationProto::RecordingEvent *)((char *)v18 + 200);
  std::vector<CLMicroLocationLocalizationController::LocalizationRequest>::__swap_out_circular_buffer(a1, &v16);
  v14 = a1[1];
  std::__split_buffer<CLMicroLocationLocalizationController::LocalizationRequest>::~__split_buffer((uint64_t)&v16);
  return v14;
}

void sub_241A62058(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__split_buffer<CLMicroLocationLocalizationController::LocalizationRequest>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t std::vector<CLMicroLocationLocalizationController::LocalizationRequest>::__swap_out_circular_buffer(uint64_t *a1, _QWORD *a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<CLMicroLocationLocalizationController::LocalizationRequest>,std::reverse_iterator<CLMicroLocationLocalizationController::LocalizationRequest*>,std::reverse_iterator<CLMicroLocationLocalizationController::LocalizationRequest*>,std::reverse_iterator<CLMicroLocationLocalizationController::LocalizationRequest*>>((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<CLMicroLocationLocalizationController::LocalizationRequest>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x147AE147AE147AFLL)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(200 * a2);
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<CLMicroLocationLocalizationController::LocalizationRequest>,std::reverse_iterator<CLMicroLocationLocalizationController::LocalizationRequest*>,std::reverse_iterator<CLMicroLocationLocalizationController::LocalizationRequest*>,std::reverse_iterator<CLMicroLocationLocalizationController::LocalizationRequest*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  __int128 v14;
  uint64_t v15;

  if (a3 != a5)
  {
    v11 = 0;
    do
    {
      v12 = a7 + v11;
      v13 = a3 + v11;
      CLMicroLocationProto::RecordingEvent::RecordingEvent((CLMicroLocationProto::RecordingEvent *)(a7 + v11 - 200), (const CLMicroLocationProto::RecordingEvent *)(a3 + v11 - 200));
      v14 = *(_OWORD *)(a3 + v11 - 56);
      *(_QWORD *)(v12 - 40) = *(_QWORD *)(a3 + v11 - 40);
      *(_OWORD *)(v12 - 56) = v14;
      v15 = *(_QWORD *)(a3 + v11 - 32);
      *(_QWORD *)(v13 - 32) = 0;
      *(_QWORD *)(v12 - 32) = v15;
      *(_QWORD *)(v12 - 24) = 0;
      *(_QWORD *)(v12 - 16) = 0;
      *(_QWORD *)(v12 - 8) = 0;
      *(_OWORD *)(v12 - 24) = *(_OWORD *)(a3 + v11 - 24);
      *(_QWORD *)(v12 - 8) = *(_QWORD *)(a3 + v11 - 8);
      *(_QWORD *)(v13 - 24) = 0;
      *(_QWORD *)(v13 - 16) = 0;
      *(_QWORD *)(v13 - 8) = 0;
      v11 -= 200;
    }
    while (a3 + v11 != a5);
  }
  return a6;
}

void sub_241A621DC(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  uint64_t v2;

  for (; v2; v2 += 200)
    CLMicroLocationLocalizationController::LocalizationRequest::~LocalizationRequest((CLMicroLocationLocalizationController::LocalizationRequest *)(v1 + v2));
  _Unwind_Resume(exception_object);
}

uint64_t std::__split_buffer<CLMicroLocationLocalizationController::LocalizationRequest>::~__split_buffer(uint64_t a1)
{
  uint64_t i;
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 8);
  for (i = *(_QWORD *)(a1 + 16); i != v3; i = *(_QWORD *)(a1 + 16))
  {
    *(_QWORD *)(a1 + 16) = i - 200;
    CLMicroLocationLocalizationController::LocalizationRequest::~LocalizationRequest((CLMicroLocationLocalizationController::LocalizationRequest *)(i - 200));
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

CLMicroLocationProto::Measurement *std::vector<CLMiLoProtobufWrapper::Measurement>::__insert_with_size[abi:ne180100]<std::__wrap_iter<CLMiLoProtobufWrapper::Measurement const*>,std::__wrap_iter<CLMiLoProtobufWrapper::Measurement const*>>(uint64_t *a1, CLMicroLocationProto::Measurement *a2, CLMicroLocationProto::Measurement *a3, uint64_t a4, uint64_t a5)
{
  CLMicroLocationProto::Measurement *v5;
  CLMicroLocationProto::Measurement *v7;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;
  unint64_t v18;
  char *v19;
  uint64_t v20;
  CLMicroLocationProto::Measurement *v21;
  CLMicroLocationProto::Measurement *v22;
  uint64_t v23;
  CLMicroLocationProto::Measurement *v24;
  _QWORD v26[2];
  CLMicroLocationProto::Measurement *v27;
  char *v28;
  uint64_t v29;

  v5 = a2;
  if (a5 >= 1)
  {
    v7 = a3;
    v11 = a1[2];
    v9 = (uint64_t)(a1 + 2);
    v10 = v11;
    v12 = *(_QWORD *)(v9 - 8);
    if (0x2E8BA2E8BA2E8BA3 * ((uint64_t)(v11 - v12) >> 3) >= a5)
    {
      v20 = v12 - (_QWORD)a2;
      if (0x2E8BA2E8BA2E8BA3 * ((uint64_t)(v12 - (_QWORD)a2) >> 3) >= a5)
      {
        v21 = (CLMicroLocationProto::Measurement *)((char *)a3 + 88 * a5);
      }
      else
      {
        v21 = (CLMicroLocationProto::Measurement *)((char *)a3 + 8 * ((uint64_t)(v12 - (_QWORD)a2) >> 3));
        a1[1] = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<CLMiLoProtobufWrapper::Measurement>,CLMiLoProtobufWrapper::Measurement const*,CLMiLoProtobufWrapper::Measurement const*,CLMiLoProtobufWrapper::Measurement*>(v9, (uint64_t)v21, a4, *(_QWORD *)(v9 - 8));
        if (v20 < 1)
          return v5;
      }
      std::vector<CLMiLoProtobufWrapper::Measurement>::__move_range((uint64_t)a1, (uint64_t)v5, v12, (uint64_t)v5 + 88 * a5);
      std::__unwrap_and_dispatch[abi:ne180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,std::__wrap_iter<CLMiLoProtobufWrapper::Measurement const*>,std::__wrap_iter<CLMiLoProtobufWrapper::Measurement const*>,CLMiLoProtobufWrapper::Measurement*,0>(v7, v21, v5);
    }
    else
    {
      v13 = *a1;
      v14 = a5 + 0x2E8BA2E8BA2E8BA3 * ((uint64_t)(v12 - *a1) >> 3);
      if (v14 > 0x2E8BA2E8BA2E8BALL)
        std::vector<CLMicroLocationProto::ConfidenceReason>::__throw_length_error[abi:ne180100]();
      v15 = 0x2E8BA2E8BA2E8BA3 * (((uint64_t)a2 - v13) >> 3);
      v16 = 0x2E8BA2E8BA2E8BA3 * ((v10 - v13) >> 3);
      v17 = 2 * v16;
      if (2 * v16 <= v14)
        v17 = v14;
      if (v16 >= 0x1745D1745D1745DLL)
        v18 = 0x2E8BA2E8BA2E8BALL;
      else
        v18 = v17;
      v29 = v9;
      if (v18)
        v19 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<CLMiLoServiceTable::Entry>>(v9, v18);
      else
        v19 = 0;
      v22 = (CLMicroLocationProto::Measurement *)&v19[88 * v15];
      v26[0] = v19;
      v26[1] = v22;
      v27 = v22;
      v28 = &v19[88 * v18];
      v23 = 88 * a5;
      v24 = (CLMicroLocationProto::Measurement *)((char *)v22 + 88 * a5);
      do
      {
        CLMicroLocationProto::Measurement::Measurement(v22, v7);
        *((_DWORD *)v22 + 20) = *((_DWORD *)v7 + 20);
        v22 = (CLMicroLocationProto::Measurement *)((char *)v22 + 88);
        v7 = (CLMicroLocationProto::Measurement *)((char *)v7 + 88);
        v23 -= 88;
      }
      while (v23);
      v27 = v24;
      v5 = (CLMicroLocationProto::Measurement *)std::vector<CLMiLoProtobufWrapper::Measurement>::__swap_out_circular_buffer(a1, v26, (uint64_t)v5);
      std::__split_buffer<CLMiLoProtobufWrapper::Measurement>::~__split_buffer((uint64_t)v26);
    }
  }
  return v5;
}

void sub_241A62428(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12)
{
  uint64_t v12;
  uint64_t v13;

  *(_QWORD *)(v12 + 8) = v13;
  _Unwind_Resume(exception_object);
}

uint64_t std::vector<CLMiLoProtobufWrapper::Measurement>::__move_range(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  uint64_t v6;
  unint64_t v7;
  CLMicroLocationProto::Measurement *v8;
  const CLMicroLocationProto::Measurement *v10;

  v6 = *(_QWORD *)(a1 + 8);
  v7 = a2 + v6 - a4;
  v8 = (CLMicroLocationProto::Measurement *)v6;
  if (v7 < a3)
  {
    v10 = (const CLMicroLocationProto::Measurement *)(a2 + v6 - a4);
    v8 = *(CLMicroLocationProto::Measurement **)(a1 + 8);
    do
    {
      CLMicroLocationProto::Measurement::Measurement(v8, v10);
      *((_DWORD *)v8 + 20) = *((_DWORD *)v10 + 20);
      v10 = (const CLMicroLocationProto::Measurement *)((char *)v10 + 88);
      v8 = (CLMicroLocationProto::Measurement *)((char *)v8 + 88);
    }
    while ((unint64_t)v10 < a3);
  }
  *(_QWORD *)(a1 + 8) = v8;
  return std::__unwrap_and_dispatch[abi:ne180100]<std::__overload<std::__move_backward_loop<std::_ClassicAlgPolicy>,std::__move_backward_trivial>,CLMiLoProtobufWrapper::Measurement *,CLMiLoProtobufWrapper::Measurement *,CLMiLoProtobufWrapper::Measurement *,0>(a2, v7, v6);
}

void sub_241A624E4(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  *(_QWORD *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

uint64_t std::vector<CLMiLoProtobufWrapper::Measurement>::__swap_out_circular_buffer(uint64_t *a1, _QWORD *a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v6 = a2[1];
  v7 = (uint64_t)(a1 + 2);
  std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<CLMiLoProtobufWrapper::Measurement>,std::reverse_iterator<CLMiLoProtobufWrapper::Measurement*>,std::reverse_iterator<CLMiLoProtobufWrapper::Measurement*>,std::reverse_iterator<CLMiLoProtobufWrapper::Measurement*>>((uint64_t)(a1 + 2), a3, a3, *a1, *a1, v6, v6);
  a2[1] = v8;
  a2[2] = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<CLMiLoProtobufWrapper::Measurement>,CLMiLoProtobufWrapper::Measurement*,CLMiLoProtobufWrapper::Measurement*,CLMiLoProtobufWrapper::Measurement*>(v7, a3, a1[1], a2[2]);
  v9 = *a1;
  *a1 = a2[1];
  a2[1] = v9;
  v10 = a1[1];
  a1[1] = a2[2];
  a2[2] = v10;
  v11 = a1[2];
  a1[2] = a2[3];
  a2[3] = v11;
  *a2 = a2[1];
  return v6;
}

uint64_t std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<CLMiLoProtobufWrapper::Measurement>,CLMiLoProtobufWrapper::Measurement const*,CLMiLoProtobufWrapper::Measurement const*,CLMiLoProtobufWrapper::Measurement*>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7;

  if (a2 != a3)
  {
    v7 = 0;
    do
    {
      *(_DWORD *)(CLMicroLocationProto::Measurement::Measurement((CLMicroLocationProto::Measurement *)(a4 + v7), (const CLMicroLocationProto::Measurement *)(a2 + v7))+ 80) = *(_DWORD *)(a2 + v7 + 80);
      v7 += 88;
    }
    while (a2 + v7 != a3);
    a4 += v7;
  }
  return a4;
}

void sub_241A6260C(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v4;

  if (v2)
  {
    v4 = v1 - 88;
    do
    {
      CLMicroLocationProto::Measurement::~Measurement((CLMicroLocationProto::Measurement *)(v4 + v2));
      v2 -= 88;
    }
    while (v2);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::__unwrap_and_dispatch[abi:ne180100]<std::__overload<std::__move_backward_loop<std::_ClassicAlgPolicy>,std::__move_backward_trivial>,CLMiLoProtobufWrapper::Measurement *,CLMiLoProtobufWrapper::Measurement *,CLMiLoProtobufWrapper::Measurement *,0>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;

  if (a2 != a1)
  {
    v6 = a2;
    do
    {
      CLMicroLocationProto::Measurement::CopyFrom((CLMicroLocationProto::Measurement *)(a3 - 88), (const CLMicroLocationProto::Measurement *)(v6 - 88));
      *(_DWORD *)(a3 - 8) = *(_DWORD *)(v6 - 8);
      a3 -= 88;
      v6 -= 88;
    }
    while (v6 != a1);
  }
  return a2;
}

CLMicroLocationProto::Measurement *std::__unwrap_and_dispatch[abi:ne180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,std::__wrap_iter<CLMiLoProtobufWrapper::Measurement const*>,std::__wrap_iter<CLMiLoProtobufWrapper::Measurement const*>,CLMiLoProtobufWrapper::Measurement*,0>(CLMicroLocationProto::Measurement *a1, CLMicroLocationProto::Measurement *a2, CLMicroLocationProto::Measurement *this)
{
  CLMicroLocationProto::Measurement *v4;
  CLMicroLocationProto::Measurement *v5;

  v4 = a1;
  if (a1 == a2)
    return a1;
  v5 = a2;
  do
  {
    CLMicroLocationProto::Measurement::CopyFrom(this, v4);
    *((_DWORD *)this + 20) = *((_DWORD *)v4 + 20);
    this = (CLMicroLocationProto::Measurement *)((char *)this + 88);
    v4 = (CLMicroLocationProto::Measurement *)((char *)v4 + 88);
  }
  while (v4 != v5);
  return v5;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<CLMiLoProtobufWrapper::Measurement>,std::reverse_iterator<CLMiLoProtobufWrapper::Measurement*>,std::reverse_iterator<CLMiLoProtobufWrapper::Measurement*>,std::reverse_iterator<CLMiLoProtobufWrapper::Measurement*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v11;

  if (a3 != a5)
  {
    v11 = 0;
    do
    {
      CLMicroLocationProto::Measurement::Measurement((CLMicroLocationProto::Measurement *)(a7 + v11 - 88), (const CLMicroLocationProto::Measurement *)(a3 + v11 - 88));
      *(_DWORD *)(a7 + v11 - 8) = *(_DWORD *)(a3 + v11 - 8);
      v11 -= 88;
    }
    while (a3 + v11 != a5);
  }
  return a6;
}

void sub_241A62798(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  uint64_t v2;

  for (; v2; v2 += 88)
    CLMicroLocationProto::Measurement::~Measurement((CLMicroLocationProto::Measurement *)(v1 + v2));
  _Unwind_Resume(exception_object);
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<CLMiLoProtobufWrapper::Measurement>,CLMiLoProtobufWrapper::Measurement*,CLMiLoProtobufWrapper::Measurement*,CLMiLoProtobufWrapper::Measurement*>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7;

  if (a2 != a3)
  {
    v7 = 0;
    do
    {
      *(_DWORD *)(CLMicroLocationProto::Measurement::Measurement((CLMicroLocationProto::Measurement *)(a4 + v7), (const CLMicroLocationProto::Measurement *)(a2 + v7))+ 80) = *(_DWORD *)(a2 + v7 + 80);
      v7 += 88;
    }
    while (a2 + v7 != a3);
    a4 += v7;
  }
  return a4;
}

void sub_241A62828(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v4;

  if (v2)
  {
    v4 = v1 - 88;
    do
    {
      CLMicroLocationProto::Measurement::~Measurement((CLMicroLocationProto::Measurement *)(v4 + v2));
      v2 -= 88;
    }
    while (v2);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::__split_buffer<CLMiLoProtobufWrapper::Measurement>::~__split_buffer(uint64_t a1)
{
  uint64_t i;
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 8);
  for (i = *(_QWORD *)(a1 + 16); i != v3; i = *(_QWORD *)(a1 + 16))
  {
    *(_QWORD *)(a1 + 16) = i - 88;
    CLMicroLocationProto::Measurement::~Measurement((CLMicroLocationProto::Measurement *)(i - 88));
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

_QWORD *std::vector<CLMiLoProtobufWrapper::Measurement>::__init_with_size[abi:ne180100]<CLMiLoProtobufWrapper::Measurement*,CLMiLoProtobufWrapper::Measurement*>(_QWORD *result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  _QWORD *v6;

  if (a4)
  {
    v6 = result;
    std::vector<CLMiLoServiceTable::Entry>::__vallocate[abi:ne180100](result, a4);
    result = (_QWORD *)std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<CLMiLoProtobufWrapper::Measurement>,CLMiLoProtobufWrapper::Measurement*,CLMiLoProtobufWrapper::Measurement*,CLMiLoProtobufWrapper::Measurement*>((uint64_t)(v6 + 2), a2, a3, v6[1]);
    v6[1] = result;
  }
  return result;
}

void sub_241A628FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  uint64_t v9;
  uint64_t v10;

  *(_QWORD *)(v9 + 8) = v10;
  std::vector<CLMiLoProtobufWrapper::Measurement>::__destroy_vector::operator()[abi:ne180100](&a9);
  _Unwind_Resume(a1);
}

uint64_t std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<CLMiLoProtobufWrapper::Measurement>,CLMiLoProtobufWrapper::Measurement*,CLMiLoProtobufWrapper::Measurement*,CLMiLoProtobufWrapper::Measurement*>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7;

  if (a2 != a3)
  {
    v7 = 0;
    do
    {
      *(_DWORD *)(CLMicroLocationProto::Measurement::Measurement((CLMicroLocationProto::Measurement *)(a4 + v7), (const CLMicroLocationProto::Measurement *)(a2 + v7))+ 80) = *(_DWORD *)(a2 + v7 + 80);
      v7 += 88;
    }
    while (a2 + v7 != a3);
    a4 += v7;
  }
  return a4;
}

void sub_241A6298C(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v4;

  if (v2)
  {
    v4 = v1 - 88;
    do
    {
      CLMicroLocationProto::Measurement::~Measurement((CLMicroLocationProto::Measurement *)(v4 + v2));
      v2 -= 88;
    }
    while (v2);
  }
  _Unwind_Resume(exception_object);
}

uint64_t CLMiLoServiceManager::LocalizationResultsPerModel::LocalizationResultsPerModel(uint64_t a1, uint64_t a2, __int128 *a3, uint64_t a4)
{
  __int128 v8;
  __int128 v9;
  __int128 v10;
  uint64_t v11;
  __int128 v12;

  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(_QWORD *)(a1 + 16) = *(_QWORD *)(a2 + 16);
  *(_QWORD *)a2 = 0;
  *(_QWORD *)(a2 + 8) = 0;
  *(_QWORD *)(a2 + 16) = 0;
  v8 = *(_OWORD *)(a2 + 24);
  v9 = *(_OWORD *)(a2 + 33);
  *(_BYTE *)(a1 + 56) = 0;
  *(_OWORD *)(a1 + 33) = v9;
  *(_OWORD *)(a1 + 24) = v8;
  *(_BYTE *)(a1 + 80) = 0;
  if (*(_BYTE *)(a2 + 80))
  {
    v10 = *(_OWORD *)(a2 + 56);
    *(_QWORD *)(a1 + 72) = *(_QWORD *)(a2 + 72);
    *(_OWORD *)(a1 + 56) = v10;
    *(_QWORD *)(a2 + 64) = 0;
    *(_QWORD *)(a2 + 72) = 0;
    *(_QWORD *)(a2 + 56) = 0;
    *(_BYTE *)(a1 + 80) = 1;
  }
  *(_BYTE *)(a1 + 88) = 0;
  v11 = a1 + 88;
  *(_BYTE *)(a1 + 128) = 0;
  if (*(_BYTE *)(a2 + 128))
  {
    std::__hash_table<CLMicroLocationFingerprint::Measurement,CLMicroLocationFingerprint::Measurement::HashMeasurement,CLMicroLocationFingerprint::Measurement::PredicateMeasurement,std::allocator<CLMicroLocationFingerprint::Measurement>>::__hash_table(v11, (uint64_t *)(a2 + 88));
    *(_BYTE *)(a1 + 128) = 1;
  }
  *(_DWORD *)(a1 + 136) = *(_DWORD *)(a2 + 136);
  *(_QWORD *)(a1 + 152) = 0;
  *(_QWORD *)(a1 + 160) = 0;
  *(_QWORD *)(a1 + 144) = 0;
  *(_OWORD *)(a1 + 144) = *(_OWORD *)(a2 + 144);
  *(_QWORD *)(a1 + 160) = *(_QWORD *)(a2 + 160);
  *(_QWORD *)(a2 + 144) = 0;
  *(_QWORD *)(a2 + 152) = 0;
  *(_QWORD *)(a2 + 160) = 0;
  v12 = *a3;
  *(_BYTE *)(a1 + 184) = 0;
  *(_OWORD *)(a1 + 168) = v12;
  *(_BYTE *)(a1 + 208) = 0;
  if (*(_BYTE *)(a4 + 24))
  {
    *(_QWORD *)(a1 + 184) = 0;
    *(_QWORD *)(a1 + 192) = 0;
    *(_QWORD *)(a1 + 200) = 0;
    *(_OWORD *)(a1 + 184) = *(_OWORD *)a4;
    *(_QWORD *)(a1 + 200) = *(_QWORD *)(a4 + 16);
    *(_QWORD *)a4 = 0;
    *(_QWORD *)(a4 + 8) = 0;
    *(_QWORD *)(a4 + 16) = 0;
    *(_BYTE *)(a1 + 208) = 1;
  }
  return a1;
}

uint64_t std::vector<CLMiLoServiceManager::LocalizationResultsPerModel>::__swap_out_circular_buffer(uint64_t *a1, _QWORD *a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<CLMiLoServiceManager::LocalizationResultsPerModel>,std::reverse_iterator<CLMiLoServiceManager::LocalizationResultsPerModel*>,std::reverse_iterator<CLMiLoServiceManager::LocalizationResultsPerModel*>,std::reverse_iterator<CLMiLoServiceManager::LocalizationResultsPerModel*>>((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<CLMiLoServiceManager::LocalizationResultsPerModel>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x12F684BDA12F685)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(216 * a2);
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<CLMiLoServiceManager::LocalizationResultsPerModel>,std::reverse_iterator<CLMiLoServiceManager::LocalizationResultsPerModel*>,std::reverse_iterator<CLMiLoServiceManager::LocalizationResultsPerModel*>,std::reverse_iterator<CLMiLoServiceManager::LocalizationResultsPerModel*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7;
  uint64_t v9;
  uint64_t v11;
  _QWORD v13[3];
  char v14;
  __int128 v15;
  __int128 v16;

  v7 = a7;
  *(_QWORD *)&v16 = a6;
  *((_QWORD *)&v16 + 1) = a7;
  v15 = v16;
  v13[0] = a1;
  v13[1] = &v15;
  v13[2] = &v16;
  v14 = 0;
  if (a3 == a5)
  {
    v11 = a6;
  }
  else
  {
    v9 = a3;
    do
    {
      v9 -= 216;
      std::allocator<CLMiLoServiceManager::LocalizationResultsPerModel>::construct[abi:ne180100]<CLMiLoServiceManager::LocalizationResultsPerModel,CLMiLoServiceManager::LocalizationResultsPerModel>(a1, v7 - 216, v9);
      v7 = *((_QWORD *)&v16 + 1) - 216;
      *((_QWORD *)&v16 + 1) -= 216;
    }
    while (v9 != a5);
    v11 = v16;
  }
  v14 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<CLMiLoServiceManager::LocalizationResultsPerModel>,std::reverse_iterator<CLMiLoServiceManager::LocalizationResultsPerModel*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v13);
  return v11;
}

__n128 std::allocator<CLMiLoServiceManager::LocalizationResultsPerModel>::construct[abi:ne180100]<CLMiLoServiceManager::LocalizationResultsPerModel,CLMiLoServiceManager::LocalizationResultsPerModel>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __n128 result;

  *(_QWORD *)a2 = 0;
  *(_QWORD *)(a2 + 8) = 0;
  *(_QWORD *)(a2 + 16) = 0;
  *(_OWORD *)a2 = *(_OWORD *)a3;
  *(_QWORD *)(a2 + 16) = *(_QWORD *)(a3 + 16);
  *(_QWORD *)a3 = 0;
  *(_QWORD *)(a3 + 8) = 0;
  *(_QWORD *)(a3 + 16) = 0;
  v5 = *(_OWORD *)(a3 + 24);
  v6 = *(_OWORD *)(a3 + 33);
  *(_BYTE *)(a2 + 56) = 0;
  *(_OWORD *)(a2 + 33) = v6;
  *(_OWORD *)(a2 + 24) = v5;
  *(_BYTE *)(a2 + 80) = 0;
  if (*(_BYTE *)(a3 + 80))
  {
    v7 = *(_OWORD *)(a3 + 56);
    *(_QWORD *)(a2 + 72) = *(_QWORD *)(a3 + 72);
    *(_OWORD *)(a2 + 56) = v7;
    *(_QWORD *)(a3 + 64) = 0;
    *(_QWORD *)(a3 + 72) = 0;
    *(_QWORD *)(a3 + 56) = 0;
    *(_BYTE *)(a2 + 80) = 1;
  }
  *(_BYTE *)(a2 + 88) = 0;
  *(_BYTE *)(a2 + 128) = 0;
  if (*(_BYTE *)(a3 + 128))
  {
    std::__hash_table<CLMicroLocationFingerprint::Measurement,CLMicroLocationFingerprint::Measurement::HashMeasurement,CLMicroLocationFingerprint::Measurement::PredicateMeasurement,std::allocator<CLMicroLocationFingerprint::Measurement>>::__hash_table(a2 + 88, (uint64_t *)(a3 + 88));
    *(_BYTE *)(a2 + 128) = 1;
  }
  *(_DWORD *)(a2 + 136) = *(_DWORD *)(a3 + 136);
  *(_QWORD *)(a2 + 152) = 0;
  *(_QWORD *)(a2 + 160) = 0;
  *(_QWORD *)(a2 + 144) = 0;
  *(_OWORD *)(a2 + 144) = *(_OWORD *)(a3 + 144);
  *(_QWORD *)(a2 + 160) = *(_QWORD *)(a3 + 160);
  *(_QWORD *)(a3 + 152) = 0;
  *(_QWORD *)(a3 + 160) = 0;
  *(_QWORD *)(a3 + 144) = 0;
  result = *(__n128 *)(a3 + 168);
  *(_BYTE *)(a2 + 184) = 0;
  *(__n128 *)(a2 + 168) = result;
  *(_BYTE *)(a2 + 208) = 0;
  if (*(_BYTE *)(a3 + 208))
  {
    *(_QWORD *)(a2 + 184) = 0;
    *(_QWORD *)(a2 + 192) = 0;
    *(_QWORD *)(a2 + 200) = 0;
    result = *(__n128 *)(a3 + 184);
    *(__n128 *)(a2 + 184) = result;
    *(_QWORD *)(a2 + 200) = *(_QWORD *)(a3 + 200);
    *(_QWORD *)(a3 + 184) = 0;
    *(_QWORD *)(a3 + 192) = 0;
    *(_QWORD *)(a3 + 200) = 0;
    *(_BYTE *)(a2 + 208) = 1;
  }
  return result;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<CLMiLoServiceManager::LocalizationResultsPerModel>,std::reverse_iterator<CLMiLoServiceManager::LocalizationResultsPerModel*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24))
    std::_AllocatorDestroyRangeReverse<std::allocator<CLMiLoServiceManager::LocalizationResultsPerModel>,std::reverse_iterator<CLMiLoServiceManager::LocalizationResultsPerModel*>>::operator()[abi:ne180100]((uint64_t *)a1);
  return a1;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<CLMiLoServiceManager::LocalizationResultsPerModel>,std::reverse_iterator<CLMiLoServiceManager::LocalizationResultsPerModel*>>::operator()[abi:ne180100](uint64_t *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;

  v1 = *(_QWORD *)(a1[2] + 8);
  v2 = *(_QWORD *)(a1[1] + 8);
  if (v1 != v2)
  {
    v3 = *a1;
    do
    {
      std::allocator<CLMiLoServiceManager::LocalizationResultsPerModel>::destroy[abi:ne180100](v3, v1);
      v1 += 216;
    }
    while (v1 != v2);
  }
}

void **std::__split_buffer<CLMiLoServiceManager::LocalizationResultsPerModel>::~__split_buffer(void **a1)
{
  std::__split_buffer<CLMiLoServiceManager::LocalizationResultsPerModel>::clear[abi:ne180100](a1);
  if (*a1)
    operator delete(*a1);
  return a1;
}

void std::__split_buffer<CLMiLoServiceManager::LocalizationResultsPerModel>::clear[abi:ne180100](_QWORD *a1)
{
  uint64_t i;
  uint64_t v2;
  uint64_t v4;

  v2 = a1[1];
  for (i = a1[2]; i != v2; i = a1[2])
  {
    v4 = a1[4];
    a1[2] = i - 216;
    std::allocator<CLMiLoServiceManager::LocalizationResultsPerModel>::destroy[abi:ne180100](v4, i - 216);
  }
}

uint64_t std::__construct_at[abi:ne180100]<CLMicroLocationLocalizationController::LocalizationInput,CLMicroLocationLocalizationController::LocalizationInput,CLMicroLocationLocalizationController::LocalizationInput*>(uint64_t a1, __int128 *a2)
{
  __int128 v4;

  v4 = *a2;
  *(_DWORD *)(a1 + 16) = *((_DWORD *)a2 + 4);
  *(_OWORD *)a1 = v4;
  *(_QWORD *)(a1 + 24) = 0;
  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 40) = 0;
  *(_OWORD *)(a1 + 24) = *(__int128 *)((char *)a2 + 24);
  *(_QWORD *)(a1 + 40) = *((_QWORD *)a2 + 5);
  *((_QWORD *)a2 + 3) = 0;
  *((_QWORD *)a2 + 4) = 0;
  *((_QWORD *)a2 + 5) = 0;
  *(_BYTE *)(a1 + 48) = 0;
  *(_BYTE *)(a1 + 240) = 0;
  if (*((_BYTE *)a2 + 240))
  {
    std::__construct_at[abi:ne180100]<CLMicroLocationFingerprint,CLMicroLocationFingerprint,CLMicroLocationFingerprint*>(a1 + 48, (uint64_t)(a2 + 3));
    *(_BYTE *)(a1 + 240) = 1;
  }
  CLMicroLocationProto::RecordingEvent::RecordingEvent((CLMicroLocationProto::RecordingEvent *)(a1 + 248), (const CLMicroLocationProto::RecordingEvent *)((char *)a2 + 248));
  *(_QWORD *)(a1 + 392) = *((_QWORD *)a2 + 49);
  return a1;
}

void sub_241A62EF0(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;
  void **v3;
  void *v5;

  std::__optional_destruct_base<CLMicroLocationFingerprint,false>::~__optional_destruct_base[abi:ne180100](v2);
  v5 = *v3;
  if (*v3)
  {
    *(_QWORD *)(v1 + 32) = v5;
    operator delete(v5);
  }
  _Unwind_Resume(a1);
}

uint64_t std::__unwrap_and_dispatch[abi:ne180100]<std::__overload<std::__move_loop<std::_ClassicAlgPolicy>,std::__move_trivial>,CLMicroLocationLocalizationController::LocalizationRequest *,CLMicroLocationLocalizationController::LocalizationRequest *,CLMicroLocationLocalizationController::LocalizationRequest *,0>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;

  v4 = a1;
  if (a1 != a2)
  {
    do
    {
      CLMicroLocationLocalizationController::LocalizationRequest::operator=(a3, v4);
      v4 += 200;
      a3 += 200;
    }
    while (v4 != a2);
    return a2;
  }
  return v4;
}

uint64_t CLMicroLocationLocalizationController::LocalizationRequest::operator=(uint64_t a1, uint64_t a2)
{
  __int128 v4;
  CLMicroLocationTimeUtils::TimeProfile *v5;

  CLMicroLocationProto::RecordingEvent::CopyFrom((CLMicroLocationProto::RecordingEvent *)a1, (const CLMicroLocationProto::RecordingEvent *)a2);
  v4 = *(_OWORD *)(a2 + 144);
  *(_QWORD *)(a1 + 160) = *(_QWORD *)(a2 + 160);
  *(_OWORD *)(a1 + 144) = v4;
  v5 = *(CLMicroLocationTimeUtils::TimeProfile **)(a2 + 168);
  *(_QWORD *)(a2 + 168) = 0;
  std::unique_ptr<CLMicroLocationTimeUtils::TimeProfile>::reset[abi:ne180100]((CLMicroLocationTimeUtils::TimeProfile **)(a1 + 168), v5);
  std::vector<CLMicroLocationResultInternal>::__move_assign(a1 + 176, (__n128 *)(a2 + 176));
  return a1;
}

uint64_t CLMicroLocationRecordingLabelsTable::Entry::Entry(uint64_t result, uint64_t a2, uint64_t a3, __int128 *a4, uint64_t a5, uint64_t a6, double a7)
{
  __int128 v7;

  *(_QWORD *)result = a2;
  *(_QWORD *)(result + 8) = a3;
  v7 = *a4;
  *(_QWORD *)(result + 32) = *((_QWORD *)a4 + 2);
  *(_OWORD *)(result + 16) = v7;
  *((_QWORD *)a4 + 1) = 0;
  *((_QWORD *)a4 + 2) = 0;
  *(_QWORD *)a4 = 0;
  *(_QWORD *)(result + 40) = a5;
  *(_QWORD *)(result + 48) = a6;
  *(double *)(result + 56) = a7;
  return result;
}

uint64_t CLMicroLocationRecordingLabelsTable::Entry::Entry(uint64_t a1, uint64_t a2, uint64_t a3, __int128 *a4, uint64_t a5, double a6)
{
  __int128 v7;
  int32x2_t v8;
  int64x2_t v9;
  int8x16_t v11;
  char v12;
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = a3;
  v7 = *a4;
  *(_QWORD *)(a1 + 32) = *((_QWORD *)a4 + 2);
  *(_OWORD *)(a1 + 16) = v7;
  *((_QWORD *)a4 + 1) = 0;
  *((_QWORD *)a4 + 2) = 0;
  *(_QWORD *)a4 = 0;
  *(double *)(a1 + 56) = a6;
  CLMicroLocationProtobufHelper::uuidFromStdString(a5, (uint64_t)&v11);
  v8 = vdup_n_s32(v12 == 0);
  v9.i64[0] = v8.u32[0];
  v9.i64[1] = v8.u32[1];
  *(int8x16_t *)(a1 + 40) = vandq_s8(v11, (int8x16_t)vcgezq_s64(vshlq_n_s64(v9, 0x3FuLL)));
  return a1;
}

void sub_241A630A0(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void **v2;

  if (*(char *)(v1 + 39) < 0)
    operator delete(*v2);
  _Unwind_Resume(exception_object);
}

void sub_241A63180(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

uint64_t ULDBUtils::insertEntries<CLMicroLocationMeasurementTable,ULMeasurementMO>(void *a1, uint64_t a2)
{
  id v3;
  void *v4;
  id v5;
  uint64_t v6;
  _QWORD v8[4];
  id v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  char v15;

  v3 = a1;
  v12 = 0;
  v13 = &v12;
  v14 = 0x2020000000;
  v15 = 0;
  objc_msgSend(v3, "managedObjectContext");
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  v8[0] = MEMORY[0x24BDAC760];
  v8[1] = 3221225472;
  v8[2] = ___ZN9ULDBUtils13insertEntriesI31CLMicroLocationMeasurementTable15ULMeasurementMOEEbP7ULStoreRKNSt3__16vectorINT_5EntryENS5_9allocatorIS8_EEEE_block_invoke;
  v8[3] = &unk_2511D22D0;
  v11 = a2;
  v5 = v3;
  v9 = v5;
  v10 = &v12;
  objc_msgSend(v4, "performBlockAndWait:", v8);

  v6 = *((unsigned __int8 *)v13 + 24);
  _Block_object_dispose(&v12, 8);

  return v6;
}

void sub_241A632A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, void *a7, uint64_t a8, uint64_t a9, ...)
{
  void *v9;
  void *v10;
  va_list va;

  va_start(va, a9);

  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void ULDBUtils::fetchEntries<CLMicroLocationMeasurementTable,ULMeasurementMO>(void *a1@<X0>, void *a2@<X1>, void *a3@<X2>, uint64_t a4@<X3>, _QWORD *a5@<X8>)
{
  id v9;
  id v10;
  id v11;
  void *v12;
  id v13;
  id v14;
  id v15;
  uint64_t *v16;
  _QWORD v17[4];
  id v18;
  id v19;
  id v20;
  uint64_t *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t *v24;
  uint64_t v25;
  __n128 (*v26)(__n128 *, __n128 *);
  void (*v27)(uint64_t);
  void *v28;
  _QWORD v29[3];
  void **v30;

  v9 = a1;
  v10 = a2;
  v11 = a3;
  v23 = 0;
  v24 = &v23;
  v25 = 0x4812000000;
  v26 = __Block_byref_object_copy__9;
  v27 = __Block_byref_object_dispose__9;
  v28 = &unk_241BEBD1D;
  memset(v29, 0, sizeof(v29));
  objc_msgSend(v9, "managedObjectContext");
  v12 = (void *)objc_claimAutoreleasedReturnValue();
  v17[0] = MEMORY[0x24BDAC760];
  v17[1] = 3221225472;
  v17[2] = ___ZN9ULDBUtils12fetchEntriesI31CLMicroLocationMeasurementTable15ULMeasurementMOEENSt3__16vectorINT_5EntryENS3_9allocatorIS6_EEEEP7ULStoreP7NSArrayIP11NSPredicateEPSC_IP16NSSortDescriptorEm_block_invoke;
  v17[3] = &unk_2511D22F8;
  v13 = v10;
  v18 = v13;
  v14 = v11;
  v19 = v14;
  v22 = a4;
  v15 = v9;
  v20 = v15;
  v21 = &v23;
  objc_msgSend(v12, "performBlockAndWait:", v17);

  v16 = v24;
  a5[1] = 0;
  a5[2] = 0;
  *a5 = 0;
  std::vector<CLMicroLocationMeasurementTable::Entry>::__init_with_size[abi:ne180100]<CLMicroLocationMeasurementTable::Entry*,CLMicroLocationMeasurementTable::Entry*>(a5, v16[6], v16[7], 0xEEEEEEEEEEEEEEEFLL * ((v16[7] - v16[6]) >> 3));

  _Block_object_dispose(&v23, 8);
  v30 = (void **)v29;
  std::vector<CLMicroLocationMeasurementTable::Entry>::__destroy_vector::operator()[abi:ne180100](&v30);

}

void sub_241A63464(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, void *a6, void *a7, void *a8, uint64_t a9, uint64_t a10, ...)
{
  void *v10;
  void *v11;
  void *v12;
  uint64_t v13;
  uint64_t v14;
  va_list va;

  va_start(va, a10);

  _Block_object_dispose(va, 8);
  *(_QWORD *)(v14 - 96) = v13;
  std::vector<CLMicroLocationMeasurementTable::Entry>::__destroy_vector::operator()[abi:ne180100]((void ***)(v14 - 96));

  _Unwind_Resume(a1);
}

void ULDBUtils::fetchAllWithLimit<CLMicroLocationMeasurementTable,ULMeasurementMO>(void *a1@<X0>, unsigned int a2@<W1>, _QWORD *a3@<X8>)
{
  id v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;
  _QWORD v10[2];

  v10[1] = *MEMORY[0x24BDAC8D0];
  v5 = a1;
  v6 = (void *)MEMORY[0x24BDD17C0];
  objc_msgSend((id)objc_opt_class(), "defaultSortProperty");
  v7 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v6, "sortDescriptorWithKey:ascending:", v7, 0);
  v8 = (void *)objc_claimAutoreleasedReturnValue();

  v10[0] = v8;
  objc_msgSend(MEMORY[0x24BDBCE30], "arrayWithObjects:count:", v10, 1);
  v9 = (void *)objc_claimAutoreleasedReturnValue();
  ULDBUtils::fetchEntries<CLMicroLocationMeasurementTable,ULMeasurementMO>(v5, 0, v9, a2, a3);

}

void sub_241A635C4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_241A63900(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;

  _Unwind_Resume(a1);
}

void sub_241A63B1C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_241A63C88(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_241A63D94(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_241A63F4C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_241A640E8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_241A642E0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_241A644E0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_241A64704(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  uint64_t v5;

  _Block_object_dispose((const void *)(v5 - 96), 8);
  _Unwind_Resume(a1);
}

void sub_241A6476C()
{
  JUMPOUT(0x241A64754);
}

void sub_241A64844(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void ___ZL45_CLLogObjectForCategory_MicroLocation_Defaultv_block_invoke_40()
{
  os_log_t v0;
  void *v1;

  v0 = os_log_create("com.apple.MicroLocation", "MicroLocation");
  v1 = (void *)logObject_MicroLocation_Default;
  logObject_MicroLocation_Default = (uint64_t)v0;

}

void ___ZN9ULDBUtils13insertEntriesI31CLMicroLocationMeasurementTable15ULMeasurementMOEEbP7ULStoreRKNSt3__16vectorINT_5EntryENS5_9allocatorIS8_EEEE_block_invoke(uint64_t a1)
{
  uint64_t *v2;
  uint64_t v3;
  uint64_t v4;
  void *v5;
  void *v6;
  NSObject *v7;
  void *v8;
  void *v9;
  NSObject *v10;
  void *v11;
  void *v12;
  void *v13;
  int v14;
  int v15;
  __int16 v16;
  const char *v17;
  __int16 v18;
  void *v19;
  uint64_t v20;

  v20 = *MEMORY[0x24BDAC8D0];
  v2 = *(uint64_t **)(a1 + 48);
  v3 = *v2;
  v4 = v2[1];
  if (*v2 == v4)
  {
LABEL_4:
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = objc_msgSend(*(id *)(a1 + 32), "commitChangesToStore");
    objc_msgSend(*(id *)(a1 + 32), "deleteOldestRecordsIfFull");
  }
  else
  {
    while (1)
    {
      objc_msgSend(*(id *)(a1 + 32), "managedObjectContext");
      v5 = (void *)objc_claimAutoreleasedReturnValue();
      +[ULMeasurementMO createFromEntry:inManagedObjectContext:](ULMeasurementMO, "createFromEntry:inManagedObjectContext:", v3, v5);
      v6 = (void *)objc_claimAutoreleasedReturnValue();

      if (!v6)
        break;

      v3 += 120;
      if (v3 == v4)
        goto LABEL_4;
    }
    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_47);
    v7 = (id)logObject_MicroLocation_Default;
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      +[ULMeasurementMO entity](ULMeasurementMO, "entity");
      v8 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v8, "name");
      v9 = (void *)objc_claimAutoreleasedReturnValue();
      v14 = 68289283;
      v15 = 0;
      v16 = 2082;
      v17 = "";
      v18 = 2113;
      v19 = v9;
      _os_log_impl(&dword_2419D9000, v7, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"Failed to create entry from MO\", \"MO\":%{private, location:escape_only}@}", (uint8_t *)&v14, 0x1Cu);

    }
    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_47);
    v10 = (id)logObject_MicroLocation_Default;
    if (os_signpost_enabled(v10))
    {
      +[ULMeasurementMO entity](ULMeasurementMO, "entity");
      v11 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v11, "name");
      v12 = (void *)objc_claimAutoreleasedReturnValue();
      v14 = 68289283;
      v15 = 0;
      v16 = 2082;
      v17 = "";
      v18 = 2113;
      v19 = v12;
      _os_signpost_emit_with_name_impl(&dword_2419D9000, v10, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Failed to create entry from MO", "{\"msg%{public}.0s\":\"Failed to create entry from MO\", \"MO\":%{private, location:escape_only}@}", (uint8_t *)&v14, 0x1Cu);

    }
    objc_msgSend(*(id *)(a1 + 32), "managedObjectContext");
    v13 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v13, "reset");

  }
}

void sub_241A64B44(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

__n128 __Block_byref_object_copy__9(__n128 *a1, __n128 *a2)
{
  __n128 result;

  a1[3].n128_u64[0] = 0;
  a1[3].n128_u64[1] = 0;
  a1[4].n128_u64[0] = 0;
  result = a2[3];
  a1[3] = result;
  a1[4].n128_u64[0] = a2[4].n128_u64[0];
  a2[3].n128_u64[0] = 0;
  a2[3].n128_u64[1] = 0;
  a2[4].n128_u64[0] = 0;
  return result;
}

void __Block_byref_object_dispose__9(uint64_t a1)
{
  void **v1;

  v1 = (void **)(a1 + 48);
  std::vector<CLMicroLocationMeasurementTable::Entry>::__destroy_vector::operator()[abi:ne180100](&v1);
}

void ___ZN9ULDBUtils12fetchEntriesI31CLMicroLocationMeasurementTable15ULMeasurementMOEENSt3__16vectorINT_5EntryENS3_9allocatorIS6_EEEEP7ULStoreP7NSArrayIP11NSPredicateEPSC_IP16NSSortDescriptorEm_block_invoke(uint64_t a1)
{
  void *v2;
  objc_class *v3;
  void *v4;
  void *v5;
  uint64_t v6;
  void *v7;
  __int128 v8;
  uint64_t v9;
  void **v10;

  v2 = *(void **)(a1 + 48);
  v3 = (objc_class *)objc_opt_class();
  NSStringFromClass(v3);
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v2, "fetchManagedObjectsWithEntityName:byAndPredicates:sortDescriptors:andLimit:", v4, *(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 64));
  v5 = (void *)objc_claimAutoreleasedReturnValue();

  ULDBUtils::convertManagedObjectsToEntries<CLMicroLocationMeasurementTable,ULMeasurementMO>(v5, (uint64_t *)&v8);
  v6 = *(_QWORD *)(*(_QWORD *)(a1 + 56) + 8);
  std::vector<CLMicroLocationMeasurementTable::Entry>::__vdeallocate((void **)(v6 + 48));
  *(_OWORD *)(v6 + 48) = v8;
  *(_QWORD *)(v6 + 64) = v9;
  v9 = 0;
  v8 = 0uLL;
  v10 = (void **)&v8;
  std::vector<CLMicroLocationMeasurementTable::Entry>::__destroy_vector::operator()[abi:ne180100](&v10);
  objc_msgSend(*(id *)(a1 + 48), "managedObjectContext");
  v7 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v7, "reset");

}

void sub_241A64CAC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void ULDBUtils::convertManagedObjectsToEntries<CLMicroLocationMeasurementTable,ULMeasurementMO>(void *a1@<X0>, uint64_t *a2@<X8>)
{
  id v3;
  uint64_t v4;
  char v5;
  uint64_t v6;
  uint64_t v7;
  id v8;
  void *v9;
  unint64_t v10;
  uint64_t v11;
  NSObject *v12;
  void *v13;
  void *v14;
  NSObject *v15;
  void *v16;
  void *v17;
  char v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  id obj;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  uint8_t buf[4];
  int v28;
  __int16 v29;
  const char *v30;
  __int16 v31;
  void *v32;
  _OWORD v33[2];
  _OWORD v34[5];
  __int128 v35;
  _BYTE v36[128];
  uint64_t v37;

  v37 = *MEMORY[0x24BDAC8D0];
  v3 = a1;
  a2[1] = 0;
  a2[2] = 0;
  *a2 = 0;
  std::vector<CLMicroLocationMeasurementTable::Entry>::reserve(a2, objc_msgSend(v3, "count"));
  v25 = 0u;
  v26 = 0u;
  v23 = 0u;
  v24 = 0u;
  obj = v3;
  v4 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v23, v36, 16);
  if (!v4)
  {

    goto LABEL_32;
  }
  v5 = 0;
  v6 = *(_QWORD *)v24;
  do
  {
    v7 = 0;
    do
    {
      if (*(_QWORD *)v24 != v6)
        objc_enumerationMutation(obj);
      v8 = *(id *)(*((_QWORD *)&v23 + 1) + 8 * v7);
      v9 = v8;
      if (v8)
      {
        objc_msgSend(v8, "convertToEntry");
        if (BYTE8(v35))
        {
          v10 = a2[1];
          if (v10 >= a2[2])
          {
            v11 = std::vector<CLMicroLocationMeasurementTable::Entry>::__push_back_slow_path<CLMicroLocationMeasurementTable::Entry>(a2, (uint64_t)v33);
          }
          else
          {
            CLMicroLocationMeasurementTable::Entry::Entry(a2[1], v33);
            v11 = v10 + 120;
            a2[1] = v10 + 120;
          }
          v18 = 0;
          a2[1] = v11;
          goto LABEL_22;
        }
      }
      else
      {
        v35 = 0u;
        memset(v34, 0, sizeof(v34));
        memset(v33, 0, sizeof(v33));
      }
      if (onceToken_MicroLocation_Default != -1)
        dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_47);
      v12 = (id)logObject_MicroLocation_Default;
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
      {
        objc_msgSend(v9, "entity");
        v13 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v13, "name");
        v14 = (void *)objc_claimAutoreleasedReturnValue();
        *(_DWORD *)buf = 68289283;
        v28 = 0;
        v29 = 2082;
        v30 = "";
        v31 = 2113;
        v32 = v14;
        _os_log_impl(&dword_2419D9000, v12, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"Failed to convert MO to entry\", \"MO\":%{private, location:escape_only}@}", buf, 0x1Cu);

      }
      if (onceToken_MicroLocation_Default != -1)
        dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_47);
      v15 = (id)logObject_MicroLocation_Default;
      if (os_signpost_enabled(v15))
      {
        objc_msgSend(v9, "entity");
        v16 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v16, "name");
        v17 = (void *)objc_claimAutoreleasedReturnValue();
        *(_DWORD *)buf = 68289283;
        v28 = 0;
        v29 = 2082;
        v30 = "";
        v31 = 2113;
        v32 = v17;
        _os_signpost_emit_with_name_impl(&dword_2419D9000, v15, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "Failed to convert MO to entry", "{\"msg%{public}.0s\":\"Failed to convert MO to entry\", \"MO\":%{private, location:escape_only}@}", buf, 0x1Cu);

      }
      v18 = 1;
      v5 = 1;
LABEL_22:
      if (BYTE8(v35))
        CLMicroLocationProto::Measurement::~Measurement((CLMicroLocationProto::Measurement *)v34);

      if ((v18 & 1) != 0)
        goto LABEL_27;
      ++v7;
    }
    while (v4 != v7);
    v4 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v23, v36, 16);
  }
  while (v4);
LABEL_27:

  if ((v5 & 1) != 0)
  {
    v20 = *a2;
    v19 = a2[1];
    if (v19 != *a2)
    {
      do
      {
        v21 = v19 - 120;
        CLMicroLocationProto::Measurement::~Measurement((CLMicroLocationProto::Measurement *)(v19 - 88));
        v19 = v21;
      }
      while (v21 != v20);
    }
    a2[1] = v20;
  }
LABEL_32:

}

void sub_241A65064(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, CLMicroLocationProto::Measurement *a13, void *a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,char a42)
{

  std::vector<CLMicroLocationMeasurementTable::Entry>::__destroy_vector::operator()[abi:ne180100]((void ***)&a27);
  _Unwind_Resume(a1);
}

uint64_t std::vector<CLMicroLocationMeasurementTable::Entry>::reserve(uint64_t *a1, unint64_t a2)
{
  uint64_t result;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  _QWORD v7[5];

  v4 = a1[2];
  result = (uint64_t)(a1 + 2);
  if (0xEEEEEEEEEEEEEEEFLL * ((v4 - *a1) >> 3) < a2)
  {
    if (a2 >= 0x222222222222223)
      std::vector<CLMicroLocationProto::ConfidenceReason>::__throw_length_error[abi:ne180100]();
    v5 = a1[1] - *a1;
    v7[4] = result;
    v7[0] = std::__allocate_at_least[abi:ne180100]<std::allocator<CLMicroLocationMeasurementTable::Entry>>(result, a2);
    v7[1] = v7[0] + v5;
    v7[2] = v7[0] + v5;
    v7[3] = v7[0] + 120 * v6;
    std::vector<CLMicroLocationMeasurementTable::Entry>::__swap_out_circular_buffer(a1, v7);
    return std::__split_buffer<CLMicroLocationMeasurementTable::Entry>::~__split_buffer((uint64_t)v7);
  }
  return result;
}

void sub_241A651A8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__split_buffer<CLMicroLocationMeasurementTable::Entry>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t std::vector<CLMicroLocationMeasurementTable::Entry>::__swap_out_circular_buffer(uint64_t *a1, _QWORD *a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<CLMicroLocationMeasurementTable::Entry>,std::reverse_iterator<CLMicroLocationMeasurementTable::Entry*>,std::reverse_iterator<CLMicroLocationMeasurementTable::Entry*>,std::reverse_iterator<CLMicroLocationMeasurementTable::Entry*>>((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<CLMicroLocationMeasurementTable::Entry>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x222222222222223)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(120 * a2);
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<CLMicroLocationMeasurementTable::Entry>,std::reverse_iterator<CLMicroLocationMeasurementTable::Entry*>,std::reverse_iterator<CLMicroLocationMeasurementTable::Entry*>,std::reverse_iterator<CLMicroLocationMeasurementTable::Entry*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v11;
  uint64_t v12;
  __int128 v13;

  if (a3 != a5)
  {
    v11 = 0;
    do
    {
      v12 = a7 + v11;
      v13 = *(_OWORD *)(a3 + v11 - 120);
      *(_OWORD *)(v12 - 104) = *(_OWORD *)(a3 + v11 - 104);
      *(_OWORD *)(v12 - 120) = v13;
      CLMicroLocationProto::Measurement::Measurement((CLMicroLocationProto::Measurement *)(a7 + v11 - 88), (const CLMicroLocationProto::Measurement *)(a3 + v11 - 88));
      *(_DWORD *)(v12 - 8) = *(_DWORD *)(a3 + v11 - 8);
      v11 -= 120;
    }
    while (a3 + v11 != a5);
  }
  return a6;
}

void sub_241A65308(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v4;

  if (v2)
  {
    v4 = v1 + 32;
    do
    {
      CLMicroLocationProto::Measurement::~Measurement((CLMicroLocationProto::Measurement *)(v4 + v2));
      v2 += 120;
    }
    while (v2);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::__split_buffer<CLMicroLocationMeasurementTable::Entry>::~__split_buffer(uint64_t a1)
{
  uint64_t i;
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 8);
  for (i = *(_QWORD *)(a1 + 16); i != v3; i = *(_QWORD *)(a1 + 16))
  {
    *(_QWORD *)(a1 + 16) = i - 120;
    CLMicroLocationProto::Measurement::~Measurement((CLMicroLocationProto::Measurement *)(i - 88));
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

uint64_t std::vector<CLMicroLocationMeasurementTable::Entry>::__push_back_slow_path<CLMicroLocationMeasurementTable::Entry>(uint64_t *a1, uint64_t a2)
{
  uint64_t v3;
  unint64_t v4;
  unint64_t v5;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  char *v10;
  uint64_t v11;
  char *v13;
  char *v14;
  char *v15;
  char *v16;
  uint64_t *v17;

  v3 = *a1;
  v4 = 0xEEEEEEEEEEEEEEEFLL * ((a1[1] - *a1) >> 3);
  v5 = v4 + 1;
  if (v4 + 1 > 0x222222222222222)
    std::vector<CLMicroLocationProto::ConfidenceReason>::__throw_length_error[abi:ne180100]();
  v7 = (uint64_t)(a1 + 2);
  v8 = 0xEEEEEEEEEEEEEEEFLL * ((a1[2] - v3) >> 3);
  if (2 * v8 > v5)
    v5 = 2 * v8;
  if (v8 >= 0x111111111111111)
    v9 = 0x222222222222222;
  else
    v9 = v5;
  v17 = a1 + 2;
  if (v9)
    v10 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<CLMicroLocationMeasurementTable::Entry>>(v7, v9);
  else
    v10 = 0;
  v13 = v10;
  v14 = &v10[120 * v4];
  v16 = &v10[120 * v9];
  CLMicroLocationMeasurementTable::Entry::Entry(v14, a2);
  v15 = v14 + 120;
  std::vector<CLMicroLocationMeasurementTable::Entry>::__swap_out_circular_buffer(a1, &v13);
  v11 = a1[1];
  std::__split_buffer<CLMicroLocationMeasurementTable::Entry>::~__split_buffer((uint64_t)&v13);
  return v11;
}

void sub_241A6546C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__split_buffer<CLMicroLocationMeasurementTable::Entry>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

void std::vector<CLMicroLocationMeasurementTable::Entry>::__vdeallocate(void **a1)
{
  char *v1;
  char *v3;
  void *v4;
  char *v5;

  v1 = (char *)*a1;
  if (*a1)
  {
    v3 = (char *)a1[1];
    v4 = *a1;
    if (v3 != v1)
    {
      do
      {
        v5 = v3 - 120;
        CLMicroLocationProto::Measurement::~Measurement((CLMicroLocationProto::Measurement *)(v3 - 88));
        v3 = v5;
      }
      while (v5 != v1);
      v4 = *a1;
    }
    a1[1] = v1;
    operator delete(v4);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

_QWORD *std::vector<CLMicroLocationMeasurementTable::Entry>::__init_with_size[abi:ne180100]<CLMicroLocationMeasurementTable::Entry*,CLMicroLocationMeasurementTable::Entry*>(_QWORD *result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  _QWORD *v6;

  if (a4)
  {
    v6 = result;
    std::vector<CLMicroLocationMeasurementTable::Entry>::__vallocate[abi:ne180100](result, a4);
    result = (_QWORD *)std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<CLMicroLocationMeasurementTable::Entry>,CLMicroLocationMeasurementTable::Entry*,CLMicroLocationMeasurementTable::Entry*,CLMicroLocationMeasurementTable::Entry*>((uint64_t)(v6 + 2), a2, a3, v6[1]);
    v6[1] = result;
  }
  return result;
}

void sub_241A6554C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  uint64_t v9;
  uint64_t v10;

  *(_QWORD *)(v9 + 8) = v10;
  std::vector<CLMicroLocationMeasurementTable::Entry>::__destroy_vector::operator()[abi:ne180100](&a9);
  _Unwind_Resume(a1);
}

char *std::vector<CLMicroLocationMeasurementTable::Entry>::__vallocate[abi:ne180100](_QWORD *a1, unint64_t a2)
{
  char *result;
  uint64_t v4;

  if (a2 >= 0x222222222222223)
    std::vector<CLMicroLocationProto::ConfidenceReason>::__throw_length_error[abi:ne180100]();
  result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<CLMicroLocationMeasurementTable::Entry>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[120 * v4];
  return result;
}

uint64_t std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<CLMicroLocationMeasurementTable::Entry>,CLMicroLocationMeasurementTable::Entry*,CLMicroLocationMeasurementTable::Entry*,CLMicroLocationMeasurementTable::Entry*>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  __int128 v10;

  if (a2 != a3)
  {
    v7 = 0;
    do
    {
      v8 = a4 + v7;
      v9 = a2 + v7;
      v10 = *(_OWORD *)(a2 + v7 + 16);
      *(_OWORD *)v8 = *(_OWORD *)(a2 + v7);
      *(_OWORD *)(v8 + 16) = v10;
      CLMicroLocationProto::Measurement::Measurement((CLMicroLocationProto::Measurement *)(a4 + v7 + 32), (const CLMicroLocationProto::Measurement *)(a2 + v7 + 32));
      *(_DWORD *)(v8 + 112) = *(_DWORD *)(a2 + v7 + 112);
      v7 += 120;
    }
    while (v9 + 120 != a3);
    a4 += v7;
  }
  return a4;
}

void sub_241A65638(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v4;

  if (v2)
  {
    v4 = v1 - 88;
    do
    {
      CLMicroLocationProto::Measurement::~Measurement((CLMicroLocationProto::Measurement *)(v4 + v2));
      v2 -= 120;
    }
    while (v2);
  }
  _Unwind_Resume(exception_object);
}

uint64_t CLMicroLocationLoiManager::CLMicroLocationLoiManager(uint64_t a1, uint64_t a2, uint64_t a3)
{
  void *v6;
  CLMicroLocationStateMachine::StateMachineBase *v8;
  void *v9[2];
  char v10;

  *(_QWORD *)a1 = &unk_2511D5190;
  v8 = (CLMicroLocationStateMachine::StateMachineBase *)(a1 + 8);
  CLMicroLocationStateMachine::StateMachineBase::StateMachineBase((CLMicroLocationStateMachine::StateMachineBase *)(a1 + 8));
  *(_QWORD *)(a1 + 64) = &off_2511D5200;
  *(_QWORD *)(a1 + 72) = &off_2511D5258;
  *(_QWORD *)(a1 + 80) = &off_2511D52B0;
  *(_QWORD *)(a1 + 88) = &off_2511D5308;
  *(_QWORD *)a1 = &off_2511D50B8;
  *(_QWORD *)(a1 + 8) = &unk_2511D5128;
  *(_QWORD *)(a1 + 96) = &off_2511D5360;
  *(_QWORD *)(a1 + 104) = &off_2511D53B8;
  *(_QWORD *)(a1 + 256) = off_2511D5968;
  *(_QWORD *)(a1 + 264) = &off_2511D59A8;
  *(_QWORD *)(a1 + 272) = &off_2511D59E8;
  *(_QWORD *)(a1 + 280) = &off_2511D5A28;
  *(_QWORD *)(a1 + 288) = &off_2511D5A80;
  *(_QWORD *)(a1 + 296) = &off_2511D5AD8;
  *(_QWORD *)(a1 + 304) = &off_2511D5B30;
  *(_QWORD *)(a1 + 312) = &off_2511D5B88;
  *(_QWORD *)(a1 + 112) = &off_2511D5410;
  *(_QWORD *)(a1 + 320) = off_2511D5BE0;
  *(_QWORD *)(a1 + 328) = a3;
  *(_QWORD *)(a1 + 120) = &off_2511D5468;
  *(_QWORD *)(a1 + 128) = &off_2511D54C0;
  *(_QWORD *)(a1 + 336) = 0;
  *(_QWORD *)(a1 + 344) = a2;
  *(_QWORD *)(a1 + 136) = &off_2511D5500;
  *(_BYTE *)(a1 + 488) = 0;
  *(_QWORD *)(a1 + 144) = &off_2511D5540;
  *(_BYTE *)(a1 + 496) = 0;
  *(_QWORD *)(a1 + 152) = &off_2511D5580;
  *(_BYTE *)(a1 + 500) = 0;
  *(_QWORD *)(a1 + 160) = &off_2511D55D8;
  *(_OWORD *)(a1 + 352) = 0u;
  *(_QWORD *)(a1 + 168) = &off_2511D5618;
  *(_QWORD *)(a1 + 176) = &off_2511D5658;
  *(_OWORD *)(a1 + 384) = 0u;
  *(_OWORD *)(a1 + 400) = 0u;
  *(_QWORD *)(a1 + 184) = off_2511D5698;
  *(_QWORD *)(a1 + 192) = &off_2511D56D8;
  *(_OWORD *)(a1 + 416) = 0u;
  *(_OWORD *)(a1 + 432) = 0u;
  *(_QWORD *)(a1 + 200) = &off_2511D5718;
  *(_QWORD *)(a1 + 208) = &off_2511D5758;
  *(_OWORD *)(a1 + 448) = 0u;
  *(_OWORD *)(a1 + 464) = 0u;
  *(_QWORD *)(a1 + 216) = &off_2511D57B0;
  *(_BYTE *)(a1 + 480) = 0;
  *(_QWORD *)(a1 + 224) = &off_2511D5808;
  *(_DWORD *)(a1 + 504) = 0;
  *(_QWORD *)(a1 + 232) = &off_2511D5860;
  *(_QWORD *)(a1 + 528) = 0;
  *(_QWORD *)(a1 + 240) = &off_2511D58B8;
  *(_OWORD *)(a1 + 512) = 0u;
  *(_QWORD *)(a1 + 248) = &off_2511D5910;
  CLMicroLocationLoiManager::setupWhenNotInAnActiveLocationState((CLMicroLocationLoiManager *)a1);
  CLMicroLocationLoiManager::setupWhenInAHomeLoiState((CLMicroLocationLoiManager *)a1);
  CLMicroLocationLoiManager::setupInCustomLoiState((CLMicroLocationLoiManager *)a1);
  CLMicroLocationLoiManager::setupEnteringHomeLoiState((CLMicroLocationLoiManager *)a1);
  CLMicroLocationLoiManager::setupEnteringCustomLoiState((CLMicroLocationLoiManager *)a1);
  std::string::basic_string[abi:ne180100]<0>(v9, "Not in Active Location State");
  CLMicroLocationStateMachine::StateMachineBase::setInitialState(v8, (uint64_t *)v9);
  if (v10 < 0)
    operator delete(v9[0]);
  v6 = *(void **)(a1 + 336);
  *(_QWORD *)(a1 + 336) = 0;

  return a1;
}

void sub_241A6598C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, CLMacAddress *a9, CLMacAddress *a10, CLMacAddress *a11, CLMacAddress *a12, CLMacAddress *a13, CLMacAddress *a14, CLMacAddress *a15, CLMacAddress *a16, CLMacAddress *a17, _Unwind_Exception *exception_object, CLMacAddress *a19, CLMacAddress *a20,CLMacAddress *a21,CLMacAddress *a22,CLMacAddress *a23,CLMacAddress *a24,CLMacAddress *a25,CLMacAddress *a26,CLMacAddress *a27,CLMacAddress *a28,CLMacAddress *a29)
{
  CLMacAddress *v29;
  CLMacAddress *v30;
  CLMacAddress *v31;
  CLMacAddress *v32;
  CLMacAddress *v33;
  CLMacAddress *v34;
  CLMacAddress *v35;
  CLMacAddress *v36;
  uint64_t v37;
  CLMacAddress *v38;
  uint64_t v39;
  void *v40;
  unint64_t v41;
  unint64_t v42;
  unint64_t v43;
  unint64_t v44;
  unint64_t v45;
  unint64_t v46;
  unint64_t v47;
  unint64_t v48;
  unint64_t v49;
  unint64_t v50;
  unint64_t v51;
  unint64_t v52;
  unint64_t v53;
  unint64_t v54;
  unint64_t v55;
  unint64_t v56;
  unint64_t v57;
  unint64_t v58;
  unint64_t v59;
  unint64_t v60;
  unint64_t v61;
  unint64_t v62;
  unint64_t v63;
  unint64_t v64;
  unint64_t v65;
  unint64_t v66;
  unint64_t v67;
  unint64_t v68;
  unint64_t v69;
  unint64_t v70;
  unint64_t v71;
  unint64_t v72;
  unint64_t v73;

  if (*(char *)(v39 - 89) < 0)
    operator delete(*(void **)(v39 - 112));

  v40 = *(void **)(v37 + 456);
  if (v40)
  {
    *(_QWORD *)(v37 + 464) = v40;
    operator delete(v40);
  }
  if (*(char *)(v37 + 407) < 0)
    operator delete(*(void **)(v37 + 384));

  CLMacAddress::newFromUint64((CLMacAddress *)(v37 + 320), v41);
  CLMacAddress::newFromUint64((CLMacAddress *)(v37 + 312), v42);
  CLMacAddress::newFromUint64((CLMacAddress *)(v37 + 304), v43);
  CLMacAddress::newFromUint64((CLMacAddress *)(v37 + 296), v44);
  CLMacAddress::newFromUint64((CLMacAddress *)(v37 + 288), v45);
  CLMacAddress::newFromUint64((CLMacAddress *)(v37 + 280), v46);
  CLMacAddress::newFromUint64((CLMacAddress *)(v37 + 272), v47);
  CLMacAddress::newFromUint64((CLMacAddress *)(v37 + 264), v48);
  CLMacAddress::newFromUint64((CLMacAddress *)(v37 + 256), v49);
  CLMacAddress::newFromUint64(v35, v50);
  CLMacAddress::newFromUint64(v34, v51);
  CLMacAddress::newFromUint64(v33, v52);
  CLMacAddress::newFromUint64(v32, v53);
  CLMacAddress::newFromUint64(v31, v54);
  CLMacAddress::newFromUint64(v30, v55);
  CLMacAddress::newFromUint64(v29, v56);
  CLMacAddress::newFromUint64(v38, v57);
  CLMacAddress::newFromUint64(v36, v58);
  CLMacAddress::newFromUint64(a19, v59);
  CLMacAddress::newFromUint64(a20, v60);
  CLMacAddress::newFromUint64(a21, v61);
  CLMacAddress::newFromUint64(a22, v62);
  CLMacAddress::newFromUint64(a23, v63);
  CLMacAddress::newFromUint64(a24, v64);
  CLMacAddress::newFromUint64(a25, v65);
  CLMacAddress::newFromUint64(a26, v66);
  CLMacAddress::newFromUint64(a27, v67);
  CLMacAddress::newFromUint64(a28, v68);
  CLMacAddress::newFromUint64(a29, v69);
  CLMacAddress::newFromUint64(*(CLMacAddress **)(v39 - 152), v70);
  CLMacAddress::newFromUint64(*(CLMacAddress **)(v39 - 144), v71);
  CLMacAddress::newFromUint64(*(CLMacAddress **)(v39 - 136), v72);
  CLMacAddress::newFromUint64(*(CLMacAddress **)(v39 - 128), v73);
  CLMicroLocationStateMachine::StateMachineBase::~StateMachineBase(*(CLMicroLocationStateMachine::StateMachineBase **)(v39 - 120));
  _Unwind_Resume(a1);
}

_QWORD *CLMicroLocationLoiManager::VisitEntry@<X0>(CLMicroLocationLoiManager *this@<X0>, id *a2@<X1>, std::string *a3@<X8>)
{
  NSObject *v6;
  double v7;
  double v8;
  double v9;
  NSObject *v10;
  uint64_t v11;
  __int128 v12;
  NSObject *v13;
  NSObject *v14;
  _QWORD *result;
  BOOL v16;
  _BOOL4 v20;
  std::string v21;
  uint64_t v22;

  v22 = *MEMORY[0x24BDAC8D0];
  if (onceToken_MicroLocation_Default != -1)
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_48);
  v6 = logObject_MicroLocation_Default;
  if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT))
  {
    v21.__r_.__value_.__r.__words[0] = 68289026;
    LOWORD(v21.__r_.__value_.__r.__words[1]) = 2082;
    *(std::string::size_type *)((char *)&v21.__r_.__value_.__r.__words[1] + 2) = (std::string::size_type)"";
    _os_log_impl(&dword_2419D9000, v6, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"LOI Manager: handleVisitEntry\"}", (uint8_t *)&v21, 0x12u);
  }
  objc_msgSend(a2[4], "coordinate");
  v8 = v7;
  objc_msgSend(a2[4], "coordinate");
  if (CLMicroLocationLoiManager::refreshRoutineStateAtLocation((ULDatabase **)this, v8, v9))
  {
    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_48);
    v10 = logObject_MicroLocation_Default;
    if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v21.__r_.__value_.__l.__data_) = 0;
      _os_log_impl(&dword_2419D9000, v10, OS_LOG_TYPE_DEFAULT, "LOI Manager, requested LOI for current visit location", (uint8_t *)&v21, 2u);
    }
    v11 = *((_QWORD *)this + 2);
    if (*(char *)(v11 + 31) < 0)
    {
      std::string::__init_copy_ctor_external(&v21, *(const std::string::value_type **)(v11 + 8), *(_QWORD *)(v11 + 16));
    }
    else
    {
      v12 = *(_OWORD *)(v11 + 8);
      v21.__r_.__value_.__r.__words[2] = *(_QWORD *)(v11 + 24);
      *(_OWORD *)&v21.__r_.__value_.__l.__data_ = v12;
    }
    if (SHIBYTE(v21.__r_.__value_.__r.__words[2]) < 0)
    {
      if (v21.__r_.__value_.__l.__size_ != 17)
      {
        operator delete(v21.__r_.__value_.__l.__data_);
        goto LABEL_46;
      }
      v20 = *(_QWORD *)v21.__r_.__value_.__l.__data_ != 0x20656D6F48206E49
         || *(_QWORD *)(v21.__r_.__value_.__r.__words[0] + 8) != 0x7461745320494F4CLL
         || *(_BYTE *)(v21.__r_.__value_.__r.__words[0] + 16) != 101;
      operator delete(v21.__r_.__value_.__l.__data_);
      if (v20)
        goto LABEL_46;
    }
    else
    {
      if (SHIBYTE(v21.__r_.__value_.__r.__words[2]) != 17)
        goto LABEL_46;
      v16 = v21.__r_.__value_.__r.__words[0] == 0x20656D6F48206E49
         && v21.__r_.__value_.__l.__size_ == 0x7461745320494F4CLL;
      if (!v16 || v21.__r_.__value_.__s.__data_[16] != 101)
        goto LABEL_46;
    }
    CLMicroLocationLoiManager::exitCurrentLoi((uint64_t)this, 1);
LABEL_46:
    result = std::string::basic_string[abi:ne180100]<0>(&v21, "In the process of entering Home LOI");
    goto LABEL_47;
  }
  if (onceToken_MicroLocation_Default != -1)
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_48);
  v13 = logObject_MicroLocation_Default;
  if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_ERROR))
  {
    v21.__r_.__value_.__r.__words[0] = 68289026;
    LOWORD(v21.__r_.__value_.__r.__words[1]) = 2082;
    *(std::string::size_type *)((char *)&v21.__r_.__value_.__r.__words[1] + 2) = (std::string::size_type)"";
    _os_log_impl(&dword_2419D9000, v13, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"LOI Manager, Failed To request LOI for current visit location\"}", (uint8_t *)&v21, 0x12u);
  }
  if (onceToken_MicroLocation_Default != -1)
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_48);
  v14 = logObject_MicroLocation_Default;
  if (os_signpost_enabled((os_log_t)logObject_MicroLocation_Default))
  {
    v21.__r_.__value_.__r.__words[0] = 68289026;
    LOWORD(v21.__r_.__value_.__r.__words[1]) = 2082;
    *(std::string::size_type *)((char *)&v21.__r_.__value_.__r.__words[1] + 2) = (std::string::size_type)"";
    _os_signpost_emit_with_name_impl(&dword_2419D9000, v14, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "LOI Manager, Failed To request LOI for current visit location", "{\"msg%{public}.0s\":\"LOI Manager, Failed To request LOI for current visit location\"}", (uint8_t *)&v21, 0x12u);
  }
  CLMicroLocationLoiManager::resetLoiVariables(this);
  result = std::string::basic_string[abi:ne180100]<0>(&v21, "Not in Active Location State");
LABEL_47:
  *a3 = v21;
  a3[1].__r_.__value_.__s.__data_[0] = 1;
  return result;
}

double CLMicroLocationLoiManager::CustomLoiVisitEntry@<D0>(CLMicroLocationLoiManager *this@<X0>, uuid *a2@<X1>, uint64_t a3@<X8>)
{
  uuid *v6;
  NSObject *v7;
  std::string *p_p;
  NSObject *v9;
  std::string *v10;
  uint64_t v11;
  __int128 v12;
  double result;
  std::string __p;
  std::bad_cast v15;
  void *v16;
  void *v17;
  _BYTE buf[28];
  uint64_t v19;

  v19 = *MEMORY[0x24BDAC8D0];
  v6 = a2 + 2;
  if ((CLMicroLocationLoiManager::isValidGeofence(this, a2[2]) & 1) != 0)
  {
    CLMicroLocationLoiManager::handleCustomLoiVisitEntry(this, a2[2], buf);
  }
  else
  {
    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_48);
    v7 = (id)logObject_MicroLocation_Default;
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      memset(&__p, 0, sizeof(__p));
      if ((boost::conversion::detail::try_lexical_convert<std::string,boost::uuids::uuid>((uint64_t)v6, &__p) & 1) == 0)
      {
        std::bad_cast::bad_cast(&v15);
        v15.__vftable = (std::bad_cast_vtbl *)&unk_2511D2C18;
        boost::throw_exception<boost::bad_lexical_cast>((uint64_t)&v15);
      }
      p_p = &__p;
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      *(_DWORD *)buf = 68289283;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(_QWORD *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2081;
      *(_QWORD *)&buf[20] = p_p;
      _os_log_impl(&dword_2419D9000, v7, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"#LOI Manager, received geofence entry for an invalid fence, this should never happen... ignoring\", \"LOI ID\":%{private, location:escape_only}s}", buf, 0x1Cu);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__p.__r_.__value_.__l.__data_);
    }

    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_48);
    v9 = (id)logObject_MicroLocation_Default;
    if (os_signpost_enabled(v9))
    {
      memset(&__p, 0, sizeof(__p));
      if ((boost::conversion::detail::try_lexical_convert<std::string,boost::uuids::uuid>((uint64_t)v6, &__p) & 1) == 0)
      {
        std::bad_cast::bad_cast(&v15);
        v15.__vftable = (std::bad_cast_vtbl *)&unk_2511D2C18;
        boost::throw_exception<boost::bad_lexical_cast>((uint64_t)&v15);
      }
      v10 = &__p;
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
        v10 = (std::string *)__p.__r_.__value_.__r.__words[0];
      *(_DWORD *)buf = 68289283;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(_QWORD *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2081;
      *(_QWORD *)&buf[20] = v10;
      _os_signpost_emit_with_name_impl(&dword_2419D9000, v9, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "#LOI Manager, received geofence entry for an invalid fence, this should never happen... ignoring", "{\"msg%{public}.0s\":\"#LOI Manager, received geofence entry for an invalid fence, this should never happen... ignoring\", \"LOI ID\":%{private, location:escape_only}s}", buf, 0x1Cu);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__p.__r_.__value_.__l.__data_);
    }

    CLMicroLocationLoiManager::sendLoiRelatedErrorEvent(this, CFSTR("Generic Failure"), CFSTR("Invalid Geofence Entry"));
    v11 = *((_QWORD *)this + 2);
    if (*(char *)(v11 + 31) < 0)
    {
      std::string::__init_copy_ctor_external((std::string *)buf, *(const std::string::value_type **)(v11 + 8), *(_QWORD *)(v11 + 16));
    }
    else
    {
      v12 = *(_OWORD *)(v11 + 8);
      *(_QWORD *)&buf[16] = *(_QWORD *)(v11 + 24);
      *(_OWORD *)buf = v12;
    }
  }
  result = *(double *)buf;
  *(_OWORD *)a3 = *(_OWORD *)buf;
  *(_QWORD *)(a3 + 16) = *(_QWORD *)&buf[16];
  *(_BYTE *)(a3 + 24) = 1;
  return result;
}

void sub_241A661F8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, std::exception a15)
{
  void *v15;

  std::exception::~exception(&a15);
  if (a14 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

_QWORD *CLMicroLocationLoiManager::HandleLeechedLocation@<X0>(ULDatabase **this@<X0>, id *a2@<X1>, uint64_t a3@<X8>)
{
  NSObject *v6;
  double v7;
  double v8;
  double v9;
  NSObject *v10;
  _QWORD *result;
  NSObject *v12;
  NSObject *v13;
  _BYTE v14[24];
  uint64_t v15;

  v15 = *MEMORY[0x24BDAC8D0];
  if (onceToken_MicroLocation_Default != -1)
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_48);
  v6 = logObject_MicroLocation_Default;
  if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT))
  {
    *(_QWORD *)v14 = 68289026;
    *(_WORD *)&v14[8] = 2082;
    *(_QWORD *)&v14[10] = "";
    _os_log_impl(&dword_2419D9000, v6, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"LOI Manager: handle leeched location notification\"}", v14, 0x12u);
  }
  objc_msgSend(a2[4], "coordinate");
  v8 = v7;
  objc_msgSend(a2[4], "coordinate");
  if (CLMicroLocationLoiManager::refreshRoutineStateAtLocation(this, v8, v9))
  {
    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_48);
    v10 = logObject_MicroLocation_Default;
    if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)v14 = 0;
      _os_log_impl(&dword_2419D9000, v10, OS_LOG_TYPE_DEFAULT, "LOI Manager, requested LOI for current visit location", v14, 2u);
    }
    result = std::string::basic_string[abi:ne180100]<0>(v14, "In the process of entering Home LOI");
  }
  else
  {
    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_48);
    v12 = logObject_MicroLocation_Default;
    if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_ERROR))
    {
      *(_QWORD *)v14 = 68289026;
      *(_WORD *)&v14[8] = 2082;
      *(_QWORD *)&v14[10] = "";
      _os_log_impl(&dword_2419D9000, v12, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"LOI Manager, Failed To request LOI for current visit location\"}", v14, 0x12u);
    }
    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_48);
    v13 = logObject_MicroLocation_Default;
    if (os_signpost_enabled((os_log_t)logObject_MicroLocation_Default))
    {
      *(_QWORD *)v14 = 68289026;
      *(_WORD *)&v14[8] = 2082;
      *(_QWORD *)&v14[10] = "";
      _os_signpost_emit_with_name_impl(&dword_2419D9000, v13, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "LOI Manager, Failed To request LOI for current visit location", "{\"msg%{public}.0s\":\"LOI Manager, Failed To request LOI for current visit location\"}", v14, 0x12u);
    }
    result = std::string::basic_string[abi:ne180100]<0>(v14, "Not in Active Location State");
  }
  *(_OWORD *)a3 = *(_OWORD *)v14;
  *(_QWORD *)(a3 + 16) = *(_QWORD *)&v14[16];
  *(_BYTE *)(a3 + 24) = 1;
  return result;
}

double CLMicroLocationLoiManager::RefreshLocationOnInterval@<D0>(CLMicroLocationLoiManager *this@<X0>, std::string *a2@<X8>)
{
  NSObject *v5;
  NSObject *v6;
  uint64_t v7;
  __int128 v8;
  double result;
  std::string v10;
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  if (*((_BYTE *)this + 488))
  {
    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_48);
    v5 = logObject_MicroLocation_Default;
    if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_INFO))
    {
      v10.__r_.__value_.__r.__words[0] = 68289026;
      LOWORD(v10.__r_.__value_.__r.__words[1]) = 2082;
      *(std::string::size_type *)((char *)&v10.__r_.__value_.__r.__words[1] + 2) = (std::string::size_type)"";
      _os_log_impl(&dword_2419D9000, v5, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"LOI Manager, refreshing location on XPC trigger\"}", (uint8_t *)&v10, 0x12u);
    }
    *((_DWORD *)this + 124) = 5;
    *((_BYTE *)this + 500) = 1;
    CLMicroLocationLoiManager::refreshRoutineStateAtLocation((ULDatabase **)this, *((double *)this + 44), *((double *)this + 45));
    std::string::basic_string[abi:ne180100]<0>(&v10, "In the process of entering Home LOI");
  }
  else
  {
    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_48);
    v6 = logObject_MicroLocation_Default;
    if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_INFO))
    {
      v10.__r_.__value_.__r.__words[0] = 68289026;
      LOWORD(v10.__r_.__value_.__r.__words[1]) = 2082;
      *(std::string::size_type *)((char *)&v10.__r_.__value_.__r.__words[1] + 2) = (std::string::size_type)"";
      _os_log_impl(&dword_2419D9000, v6, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"refreshRoutineStateAtLastLocation, won't run, last location not set\"}", (uint8_t *)&v10, 0x12u);
    }
    v7 = *((_QWORD *)this + 2);
    if (*(char *)(v7 + 31) < 0)
    {
      std::string::__init_copy_ctor_external(&v10, *(const std::string::value_type **)(v7 + 8), *(_QWORD *)(v7 + 16));
    }
    else
    {
      v8 = *(_OWORD *)(v7 + 8);
      v10.__r_.__value_.__r.__words[2] = *(_QWORD *)(v7 + 24);
      *(_OWORD *)&v10.__r_.__value_.__l.__data_ = v8;
    }
  }
  result = *(double *)&v10.__r_.__value_.__l.__data_;
  *a2 = v10;
  a2[1].__r_.__value_.__s.__data_[0] = 1;
  return result;
}

double CLMicroLocationLoiManager::FetchPlaceInference@<D0>(CLMicroLocationLoiManager *this@<X0>, const CLMiLoLoiManagerFetchPlaceInferenceForReason *a2@<X1>, std::string *a3@<X8>)
{
  double result;
  uint64_t v6;
  __int128 v7;
  std::string v8;

  *((_DWORD *)this + 124) = *((_DWORD *)a2 + 8);
  *((_BYTE *)this + 500) = 1;
  if (CLMicroLocationLoiManager::fetchPlaceInference(this))
  {
    std::string::basic_string[abi:ne180100]<0>(&v8, "In the process of entering Home LOI");
    result = *(double *)&v8.__r_.__value_.__l.__data_;
    *a3 = v8;
    a3[1].__r_.__value_.__s.__data_[0] = 1;
  }
  else
  {
    if (*((_BYTE *)this + 500))
      *((_BYTE *)this + 500) = 0;
    v6 = *((_QWORD *)this + 2);
    if (*(char *)(v6 + 31) < 0)
    {
      std::string::__init_copy_ctor_external(&v8, *(const std::string::value_type **)(v6 + 8), *(_QWORD *)(v6 + 16));
    }
    else
    {
      v7 = *(_OWORD *)(v6 + 8);
      v8.__r_.__value_.__r.__words[2] = *(_QWORD *)(v6 + 24);
      *(_OWORD *)&v8.__r_.__value_.__l.__data_ = v7;
    }
    result = *(double *)&v8.__r_.__value_.__l.__data_;
    *a3 = v8;
    a3[1].__r_.__value_.__s.__data_[0] = 1;
  }
  return result;
}

double CLMicroLocationLoiManager::VisitExit@<D0>(CLMicroLocationLoiManager *this@<X0>, const CLMiLoLoiManagerLoiVisitExitEvent *a2@<X1>, uint64_t a3@<X8>)
{
  NSObject *v6;
  std::string *p_p;
  double result;
  std::string __p;
  _BYTE buf[28];
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  if (onceToken_MicroLocation_Default != -1)
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_48);
  v6 = (id)logObject_MicroLocation_Default;
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    CLMicroLocationStateMachine::EventBase::getEventName(a2, &__p);
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      p_p = &__p;
    else
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    *(_DWORD *)buf = 68289282;
    *(_DWORD *)&buf[4] = 0;
    *(_WORD *)&buf[8] = 2082;
    *(_QWORD *)&buf[10] = "";
    *(_WORD *)&buf[18] = 2082;
    *(_QWORD *)&buf[20] = p_p;
    _os_log_impl(&dword_2419D9000, v6, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"LOI Manager:\", \"Handling Event\":%{public, location:escape_only}s}", buf, 0x1Cu);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p.__r_.__value_.__l.__data_);
  }

  CLMicroLocationLoiManager::exitCurrentLoi((uint64_t)this, 2);
  std::string::basic_string[abi:ne180100]<0>(buf, "Not in Active Location State");
  result = *(double *)buf;
  *(_OWORD *)a3 = *(_OWORD *)buf;
  *(_QWORD *)(a3 + 16) = *(_QWORD *)&buf[16];
  *(_BYTE *)(a3 + 24) = 1;
  return result;
}

void sub_241A668F4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

double CLMicroLocationLoiManager::EnableCustomLoiWhileInHomeLoi@<D0>(id *this@<X0>, uuid *a2@<X1>, uint64_t a3@<X8>)
{
  NSObject *v6;
  double result;
  __int128 v8;
  uint64_t v9;

  if (onceToken_MicroLocation_Default != -1)
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_48);
  v6 = logObject_MicroLocation_Default;
  if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v8) = 0;
    _os_log_impl(&dword_2419D9000, v6, OS_LOG_TYPE_DEFAULT, "#LOI Manager, In Home LOI, exit it before creating custom LOI process", (uint8_t *)&v8, 2u);
  }
  CLMicroLocationLoiManager::exitCurrentLoi((uint64_t)this, 9);
  CLMicroLocationLoiManager::handleEnableCustomLoi(this, a2[2], &v8);
  result = *(double *)&v8;
  *(_OWORD *)a3 = v8;
  *(_QWORD *)(a3 + 16) = v9;
  *(_BYTE *)(a3 + 24) = 1;
  return result;
}

double CLMicroLocationLoiManager::CustomLoiVisitEntryWhileInHomeLoi@<D0>(CLMicroLocationLoiManager *this@<X0>, uuid *a2@<X1>, uint64_t a3@<X8>)
{
  uuid *v6;
  NSObject *v7;
  std::string *p_p;
  NSObject *v9;
  std::string *v10;
  uint64_t v11;
  __int128 v12;
  double result;
  std::string __p;
  std::bad_cast v15;
  void *v16;
  void *v17;
  _BYTE buf[28];
  uint64_t v19;

  v19 = *MEMORY[0x24BDAC8D0];
  v6 = a2 + 2;
  if ((CLMicroLocationLoiManager::isValidGeofence(this, a2[2]) & 1) != 0)
  {
    CLMicroLocationLoiManager::exitCurrentLoi((uint64_t)this, 10);
    CLMicroLocationLoiManager::handleCustomLoiVisitEntry(this, a2[2], buf);
  }
  else
  {
    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_48);
    v7 = (id)logObject_MicroLocation_Default;
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      memset(&__p, 0, sizeof(__p));
      if ((boost::conversion::detail::try_lexical_convert<std::string,boost::uuids::uuid>((uint64_t)v6, &__p) & 1) == 0)
      {
        std::bad_cast::bad_cast(&v15);
        v15.__vftable = (std::bad_cast_vtbl *)&unk_2511D2C18;
        boost::throw_exception<boost::bad_lexical_cast>((uint64_t)&v15);
      }
      p_p = &__p;
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      *(_DWORD *)buf = 68289283;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(_QWORD *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2081;
      *(_QWORD *)&buf[20] = p_p;
      _os_log_impl(&dword_2419D9000, v7, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"#LOI Manager, received geofence entry for an invalid fence, this should never happen... ignoring\", \"LOI ID\":%{private, location:escape_only}s}", buf, 0x1Cu);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__p.__r_.__value_.__l.__data_);
    }

    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_48);
    v9 = (id)logObject_MicroLocation_Default;
    if (os_signpost_enabled(v9))
    {
      memset(&__p, 0, sizeof(__p));
      if ((boost::conversion::detail::try_lexical_convert<std::string,boost::uuids::uuid>((uint64_t)v6, &__p) & 1) == 0)
      {
        std::bad_cast::bad_cast(&v15);
        v15.__vftable = (std::bad_cast_vtbl *)&unk_2511D2C18;
        boost::throw_exception<boost::bad_lexical_cast>((uint64_t)&v15);
      }
      v10 = &__p;
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
        v10 = (std::string *)__p.__r_.__value_.__r.__words[0];
      *(_DWORD *)buf = 68289283;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(_QWORD *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2081;
      *(_QWORD *)&buf[20] = v10;
      _os_signpost_emit_with_name_impl(&dword_2419D9000, v9, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "#LOI Manager, received geofence entry for an invalid fence, this should never happen... ignoring", "{\"msg%{public}.0s\":\"#LOI Manager, received geofence entry for an invalid fence, this should never happen... ignoring\", \"LOI ID\":%{private, location:escape_only}s}", buf, 0x1Cu);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__p.__r_.__value_.__l.__data_);
    }

    CLMicroLocationLoiManager::sendLoiRelatedErrorEvent(this, CFSTR("Generic Failure"), CFSTR("Invalid Geofence Entry"));
    v11 = *((_QWORD *)this + 2);
    if (*(char *)(v11 + 31) < 0)
    {
      std::string::__init_copy_ctor_external((std::string *)buf, *(const std::string::value_type **)(v11 + 8), *(_QWORD *)(v11 + 16));
    }
    else
    {
      v12 = *(_OWORD *)(v11 + 8);
      *(_QWORD *)&buf[16] = *(_QWORD *)(v11 + 24);
      *(_OWORD *)buf = v12;
    }
  }
  result = *(double *)buf;
  *(_OWORD *)a3 = *(_OWORD *)buf;
  *(_QWORD *)(a3 + 16) = *(_QWORD *)&buf[16];
  *(_BYTE *)(a3 + 24) = 1;
  return result;
}

void sub_241A66CF8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, std::exception a15)
{
  void *v15;

  std::exception::~exception(&a15);
  if (a14 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

double CLMicroLocationLoiManager::FetchPlaceInferenceWhileInHomeLoi@<D0>(CLMicroLocationLoiManager *this@<X0>, const CLMiLoLoiManagerFetchPlaceInferenceForReason *a2@<X1>, std::string *a3@<X8>)
{
  int v5;
  double result;
  uint64_t v8;
  __int128 v9;
  std::string v10;

  v5 = *((_DWORD *)a2 + 8);
  if (v5 == 12 || v5 == 3)
  {
    *((_DWORD *)this + 124) = v5;
    *((_BYTE *)this + 500) = 1;
    if (CLMicroLocationLoiManager::fetchPlaceInference(this))
    {
      std::string::basic_string[abi:ne180100]<0>(&v10, "In the process of entering Home LOI");
      result = *(double *)&v10.__r_.__value_.__l.__data_;
      *a3 = v10;
      a3[1].__r_.__value_.__s.__data_[0] = 1;
      return result;
    }
    if (*((_BYTE *)this + 500))
      *((_BYTE *)this + 500) = 0;
  }
  v8 = *((_QWORD *)this + 2);
  if (*(char *)(v8 + 31) < 0)
  {
    std::string::__init_copy_ctor_external(&v10, *(const std::string::value_type **)(v8 + 8), *(_QWORD *)(v8 + 16));
  }
  else
  {
    v9 = *(_OWORD *)(v8 + 8);
    v10.__r_.__value_.__r.__words[2] = *(_QWORD *)(v8 + 24);
    *(_OWORD *)&v10.__r_.__value_.__l.__data_ = v9;
  }
  result = *(double *)&v10.__r_.__value_.__l.__data_;
  *a3 = v10;
  a3[1].__r_.__value_.__s.__data_[0] = 1;
  return result;
}

double CLMicroLocationLoiManager::CustomLoiVisitExit@<D0>(CLMicroLocationLoiManager *this@<X0>, const CLMiLoLoiManagerGeofenceExitEvent *a2@<X1>, uint64_t a3@<X8>)
{
  NSObject *v6;
  std::string *v7;
  NSObject *v8;
  std::string *v9;
  uint64_t v10;
  NSObject *v11;
  std::string *p_p;
  NSObject *v13;
  std::string *v14;
  __int128 v15;
  NSObject *v16;
  std::string *v17;
  double result;
  std::string __p;
  std::bad_cast v20;
  void *v21;
  void *v22;
  _BYTE buf[28];
  uuid v24;
  uint64_t v25;

  v25 = *MEMORY[0x24BDAC8D0];
  v24 = (uuid)*((_OWORD *)a2 + 2);
  if ((CLMicroLocationLoiManager::isValidGeofence(this, v24) & 1) == 0)
  {
    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_48);
    v11 = (id)logObject_MicroLocation_Default;
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      memset(&__p, 0, sizeof(__p));
      if ((boost::conversion::detail::try_lexical_convert<std::string,boost::uuids::uuid>((uint64_t)&v24, &__p) & 1) == 0)
      {
        std::bad_cast::bad_cast(&v20);
        v20.__vftable = (std::bad_cast_vtbl *)&unk_2511D2C18;
        boost::throw_exception<boost::bad_lexical_cast>((uint64_t)&v20);
      }
      p_p = &__p;
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      *(_DWORD *)buf = 68289283;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(_QWORD *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2081;
      *(_QWORD *)&buf[20] = p_p;
      _os_log_impl(&dword_2419D9000, v11, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"#LOI Manager, received geofence entry for an invalid fence, this should never happen... ignoring\", \"LOI ID\":%{private, location:escape_only}s}", buf, 0x1Cu);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__p.__r_.__value_.__l.__data_);
    }

    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_48);
    v13 = (id)logObject_MicroLocation_Default;
    if (os_signpost_enabled(v13))
    {
      memset(&__p, 0, sizeof(__p));
      if ((boost::conversion::detail::try_lexical_convert<std::string,boost::uuids::uuid>((uint64_t)&v24, &__p) & 1) == 0)
      {
        std::bad_cast::bad_cast(&v20);
        v20.__vftable = (std::bad_cast_vtbl *)&unk_2511D2C18;
        boost::throw_exception<boost::bad_lexical_cast>((uint64_t)&v20);
      }
      v14 = &__p;
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
        v14 = (std::string *)__p.__r_.__value_.__r.__words[0];
      *(_DWORD *)buf = 68289283;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(_QWORD *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2081;
      *(_QWORD *)&buf[20] = v14;
      _os_signpost_emit_with_name_impl(&dword_2419D9000, v13, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "#LOI Manager, received geofence entry for an invalid fence, this should never happen... ignoring", "{\"msg%{public}.0s\":\"#LOI Manager, received geofence entry for an invalid fence, this should never happen... ignoring\", \"LOI ID\":%{private, location:escape_only}s}", buf, 0x1Cu);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__p.__r_.__value_.__l.__data_);
    }

    CLMicroLocationLoiManager::sendLoiRelatedErrorEvent(this, CFSTR("Generic Failure"), CFSTR("Invalid Geofence Exit"));
    v10 = *((_QWORD *)this + 2);
    if (*(char *)(v10 + 31) < 0)
      goto LABEL_51;
LABEL_41:
    v15 = *(_OWORD *)(v10 + 8);
    *(_QWORD *)&buf[16] = *(_QWORD *)(v10 + 24);
    *(_OWORD *)buf = v15;
    goto LABEL_52;
  }
  if (*((_QWORD *)this + 51) != *(_QWORD *)v24.var0 || *((_QWORD *)this + 52) != *(_QWORD *)&v24.var0[8])
  {
    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_48);
    v6 = (id)logObject_MicroLocation_Default;
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      memset(&__p, 0, sizeof(__p));
      if ((boost::conversion::detail::try_lexical_convert<std::string,boost::uuids::uuid>((uint64_t)&v24, &__p) & 1) == 0)
      {
        std::bad_cast::bad_cast(&v20);
        v20.__vftable = (std::bad_cast_vtbl *)&unk_2511D2C18;
        boost::throw_exception<boost::bad_lexical_cast>((uint64_t)&v20);
      }
      v7 = &__p;
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
        v7 = (std::string *)__p.__r_.__value_.__r.__words[0];
      *(_DWORD *)buf = 68289283;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(_QWORD *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2081;
      *(_QWORD *)&buf[20] = v7;
      _os_log_impl(&dword_2419D9000, v6, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"#LOI Manager, got geofence exit for an LOI which is not the currently the active LOI, this may happen if we jumped from one geofence to another and the entry for the new geofence arrived first\", \"regionID\":%{private, location:escape_only}s}", buf, 0x1Cu);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__p.__r_.__value_.__l.__data_);
    }

    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_48);
    v8 = (id)logObject_MicroLocation_Default;
    if (os_signpost_enabled(v8))
    {
      memset(&__p, 0, sizeof(__p));
      if ((boost::conversion::detail::try_lexical_convert<std::string,boost::uuids::uuid>((uint64_t)&v24, &__p) & 1) == 0)
      {
        std::bad_cast::bad_cast(&v20);
        v20.__vftable = (std::bad_cast_vtbl *)&unk_2511D2C18;
        boost::throw_exception<boost::bad_lexical_cast>((uint64_t)&v20);
      }
      v9 = &__p;
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
        v9 = (std::string *)__p.__r_.__value_.__r.__words[0];
      *(_DWORD *)buf = 68289283;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(_QWORD *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2081;
      *(_QWORD *)&buf[20] = v9;
      _os_signpost_emit_with_name_impl(&dword_2419D9000, v8, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "#LOI Manager, got geofence exit for an LOI which is not the currently the active LOI, this may happen if we jumped from one geofence to another and the entry for the new geofence arrived first", "{\"msg%{public}.0s\":\"#LOI Manager, got geofence exit for an LOI which is not the currently the active LOI, this may happen if we jumped from one geofence to another and the entry for the new geofence arrived first\", \"regionID\":%{private, location:escape_only}s}", buf, 0x1Cu);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__p.__r_.__value_.__l.__data_);
    }

    v10 = *((_QWORD *)this + 2);
    if (*(char *)(v10 + 31) < 0)
    {
LABEL_51:
      std::string::__init_copy_ctor_external((std::string *)buf, *(const std::string::value_type **)(v10 + 8), *(_QWORD *)(v10 + 16));
      goto LABEL_52;
    }
    goto LABEL_41;
  }
  if (onceToken_MicroLocation_Default != -1)
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_48);
  v16 = (id)logObject_MicroLocation_Default;
  if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
  {
    memset(&__p, 0, sizeof(__p));
    if ((boost::conversion::detail::try_lexical_convert<std::string,boost::uuids::uuid>((uint64_t)&v24, &__p) & 1) == 0)
    {
      std::bad_cast::bad_cast(&v20);
      v20.__vftable = (std::bad_cast_vtbl *)&unk_2511D2C18;
      boost::throw_exception<boost::bad_lexical_cast>((uint64_t)&v20);
    }
    v17 = &__p;
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
      v17 = (std::string *)__p.__r_.__value_.__r.__words[0];
    *(_DWORD *)buf = 68289283;
    *(_DWORD *)&buf[4] = 0;
    *(_WORD *)&buf[8] = 2082;
    *(_QWORD *)&buf[10] = "";
    *(_WORD *)&buf[18] = 2081;
    *(_QWORD *)&buf[20] = v17;
    _os_log_impl(&dword_2419D9000, v16, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"#LOI Manager, got geofence exit for active LOI\", \"regionID\":%{private, location:escape_only}s}", buf, 0x1Cu);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p.__r_.__value_.__l.__data_);
  }

  CLMicroLocationLoiManager::exitCurrentLoi((uint64_t)this, 11);
  std::string::basic_string[abi:ne180100]<0>(buf, "Not in Active Location State");
LABEL_52:
  result = *(double *)buf;
  *(_OWORD *)a3 = *(_OWORD *)buf;
  *(_QWORD *)(a3 + 16) = *(_QWORD *)&buf[16];
  *(_BYTE *)(a3 + 24) = 1;
  return result;
}

void sub_241A67484(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, std::exception a15)
{
  void *v15;

  std::exception::~exception(&a15);
  if (a14 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

double CLMicroLocationLoiManager::CustomLoiVisitEntryWhileInCustomLoi@<D0>(CLMicroLocationLoiManager *this@<X0>, const CLMiLoLoiManagerGeofenceEntryEvent *a2@<X1>, uint64_t a3@<X8>)
{
  NSObject *v5;
  std::string *p_p;
  NSObject *v7;
  std::string *v8;
  NSObject *v10;
  std::string *v11;
  NSObject *v12;
  std::string *v13;
  NSObject *v14;
  std::string *v15;
  uint64_t v16;
  __int128 v17;
  double result;
  std::string __p;
  std::bad_cast v20;
  void *v21;
  void *v22;
  _BYTE buf[28];
  uuid v24;
  uint64_t v25;

  v25 = *MEMORY[0x24BDAC8D0];
  v24 = (uuid)*((_OWORD *)a2 + 2);
  if ((CLMicroLocationLoiManager::isValidGeofence(this, v24) & 1) == 0)
  {
    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_48);
    v5 = (id)logObject_MicroLocation_Default;
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      memset(&__p, 0, sizeof(__p));
      if ((boost::conversion::detail::try_lexical_convert<std::string,boost::uuids::uuid>((uint64_t)&v24, &__p) & 1) == 0)
      {
        std::bad_cast::bad_cast(&v20);
        v20.__vftable = (std::bad_cast_vtbl *)&unk_2511D2C18;
        boost::throw_exception<boost::bad_lexical_cast>((uint64_t)&v20);
      }
      p_p = &__p;
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      *(_DWORD *)buf = 68289283;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(_QWORD *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2081;
      *(_QWORD *)&buf[20] = p_p;
      _os_log_impl(&dword_2419D9000, v5, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"#LOI Manager, received geofence entry for an invalid fence, this should never happen... ignoring\", \"LOI ID\":%{private, location:escape_only}s}", buf, 0x1Cu);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__p.__r_.__value_.__l.__data_);
    }

    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_48);
    v7 = (id)logObject_MicroLocation_Default;
    if (os_signpost_enabled(v7))
    {
      memset(&__p, 0, sizeof(__p));
      if ((boost::conversion::detail::try_lexical_convert<std::string,boost::uuids::uuid>((uint64_t)&v24, &__p) & 1) == 0)
      {
        std::bad_cast::bad_cast(&v20);
        v20.__vftable = (std::bad_cast_vtbl *)&unk_2511D2C18;
        boost::throw_exception<boost::bad_lexical_cast>((uint64_t)&v20);
      }
      v8 = &__p;
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
        v8 = (std::string *)__p.__r_.__value_.__r.__words[0];
      *(_DWORD *)buf = 68289283;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(_QWORD *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2081;
      *(_QWORD *)&buf[20] = v8;
      _os_signpost_emit_with_name_impl(&dword_2419D9000, v7, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "#LOI Manager, received geofence entry for an invalid fence, this should never happen... ignoring", "{\"msg%{public}.0s\":\"#LOI Manager, received geofence entry for an invalid fence, this should never happen... ignoring\", \"LOI ID\":%{private, location:escape_only}s}", buf, 0x1Cu);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__p.__r_.__value_.__l.__data_);
    }

    CLMicroLocationLoiManager::sendLoiRelatedErrorEvent(this, CFSTR("Generic Failure"), CFSTR("Invalid Geofence Entry"));
  }
  if (*((_QWORD *)this + 51) == *(_QWORD *)v24.var0 && *((_QWORD *)this + 52) == *(_QWORD *)&v24.var0[8])
  {
    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_48);
    v12 = (id)logObject_MicroLocation_Default;
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      memset(&__p, 0, sizeof(__p));
      if ((boost::conversion::detail::try_lexical_convert<std::string,boost::uuids::uuid>((uint64_t)&v24, &__p) & 1) == 0)
      {
        std::bad_cast::bad_cast(&v20);
        v20.__vftable = (std::bad_cast_vtbl *)&unk_2511D2C18;
        boost::throw_exception<boost::bad_lexical_cast>((uint64_t)&v20);
      }
      v13 = &__p;
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
        v13 = (std::string *)__p.__r_.__value_.__r.__words[0];
      *(_DWORD *)buf = 68289283;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(_QWORD *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2081;
      *(_QWORD *)&buf[20] = v13;
      _os_log_impl(&dword_2419D9000, v12, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"#LOI Manager, got geofence entry for the current active LOI which shouldn't happen... ignoring\", \"LOI ID\":%{private, location:escape_only}s}", buf, 0x1Cu);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__p.__r_.__value_.__l.__data_);
    }

    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_48);
    v14 = (id)logObject_MicroLocation_Default;
    if (os_signpost_enabled(v14))
    {
      memset(&__p, 0, sizeof(__p));
      if ((boost::conversion::detail::try_lexical_convert<std::string,boost::uuids::uuid>((uint64_t)&v24, &__p) & 1) == 0)
      {
        std::bad_cast::bad_cast(&v20);
        v20.__vftable = (std::bad_cast_vtbl *)&unk_2511D2C18;
        boost::throw_exception<boost::bad_lexical_cast>((uint64_t)&v20);
      }
      v15 = &__p;
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
        v15 = (std::string *)__p.__r_.__value_.__r.__words[0];
      *(_DWORD *)buf = 68289283;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(_QWORD *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2081;
      *(_QWORD *)&buf[20] = v15;
      _os_signpost_emit_with_name_impl(&dword_2419D9000, v14, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "#LOI Manager, got geofence entry for the current active LOI which shouldn't happen... ignoring", "{\"msg%{public}.0s\":\"#LOI Manager, got geofence entry for the current active LOI which shouldn't happen... ignoring\", \"LOI ID\":%{private, location:escape_only}s}", buf, 0x1Cu);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__p.__r_.__value_.__l.__data_);
    }

  }
  else
  {
    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_48);
    v10 = (id)logObject_MicroLocation_Default;
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      memset(&__p, 0, sizeof(__p));
      if ((boost::conversion::detail::try_lexical_convert<std::string,boost::uuids::uuid>((uint64_t)&v24, &__p) & 1) == 0)
      {
        std::bad_cast::bad_cast(&v20);
        v20.__vftable = (std::bad_cast_vtbl *)&unk_2511D2C18;
        boost::throw_exception<boost::bad_lexical_cast>((uint64_t)&v20);
      }
      v11 = &__p;
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
        v11 = (std::string *)__p.__r_.__value_.__r.__words[0];
      *(_DWORD *)buf = 68289283;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(_QWORD *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2081;
      *(_QWORD *)&buf[20] = v11;
      _os_log_impl(&dword_2419D9000, v10, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"#LOI Manager, got geofence entry for different valid LOI, entering it\", \"LOI ID\":%{private, location:escape_only}s}", buf, 0x1Cu);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__p.__r_.__value_.__l.__data_);
    }

    CLMicroLocationLoiManager::exitCurrentLoi((uint64_t)this, 11);
    CLMicroLocationLoiManager::enterCustomLoi(this, *(uint64_t *)v24.var0, *(uint64_t *)&v24.var0[8], 10);
  }
  v16 = *((_QWORD *)this + 2);
  if (*(char *)(v16 + 31) < 0)
  {
    std::string::__init_copy_ctor_external((std::string *)buf, *(const std::string::value_type **)(v16 + 8), *(_QWORD *)(v16 + 16));
  }
  else
  {
    v17 = *(_OWORD *)(v16 + 8);
    *(_QWORD *)&buf[16] = *(_QWORD *)(v16 + 24);
    *(_OWORD *)buf = v17;
  }
  result = *(double *)buf;
  *(_OWORD *)a3 = *(_OWORD *)buf;
  *(_QWORD *)(a3 + 16) = *(_QWORD *)&buf[16];
  *(_BYTE *)(a3 + 24) = 1;
  return result;
}

void sub_241A67B30(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, std::exception a15)
{
  void *v15;

  std::exception::~exception(&a15);
  if (a14 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

double CLMicroLocationLoiManager::EnableCustomLoiWhileInCustomLoi@<D0>(CLMicroLocationLoiManager *this@<X0>, uuid *a2@<X1>, uint64_t a3@<X8>)
{
  NSObject *v6;
  double result;
  _BYTE v8[24];
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  CLMicroLocationLoiManager::handleDisableCustomLoiForAllServices(this, *(uuid *)((char *)this + 408));
  if (CLMicroLocationLoiManager::noMoreServicesMonitoringThisLoi(this, *(uuid *)((char *)this + 408)))
  {
    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_48);
    v6 = logObject_MicroLocation_Default;
    if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT))
    {
      *(_QWORD *)v8 = 68289026;
      *(_WORD *)&v8[8] = 2082;
      *(_QWORD *)&v8[10] = "";
      _os_log_impl(&dword_2419D9000, v6, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"#LOI Manager, No more services interested in this active LOI, exiting\"}", v8, 0x12u);
    }
    CLMicroLocationLoiManager::exitCurrentLoi((uint64_t)this, 9);
  }
  CLMicroLocationLoiManager::handleEnableCustomLoi((id *)this, a2[2], v8);
  result = *(double *)v8;
  *(_OWORD *)a3 = *(_OWORD *)v8;
  *(_QWORD *)(a3 + 16) = *(_QWORD *)&v8[16];
  *(_BYTE *)(a3 + 24) = 1;
  return result;
}

double CLMicroLocationLoiManager::CustomLoiDisableWhileInCustomLoi@<D0>(id *this@<X0>, uuid *a2@<X1>, std::string *a3@<X8>)
{
  BOOL v6;
  NSObject *v7;
  char *v8;
  __int128 v9;
  double result;
  std::string __p;
  std::string buf;
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  CLMicroLocationLoiManager::handleDisableCustomLoi(this, a2[2], a2[3], &__p);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  v6 = this[51] == *(id *)a2[2].var0 && this[52] == *(id *)&a2[2].var0[8];
  if (v6 && CLMicroLocationLoiManager::noMoreServicesMonitoringThisLoi((CLMicroLocationLoiManager *)this, a2[2]))
  {
    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_48);
    v7 = logObject_MicroLocation_Default;
    if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT))
    {
      buf.__r_.__value_.__r.__words[0] = 68289026;
      LOWORD(buf.__r_.__value_.__r.__words[1]) = 2082;
      *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 2) = (std::string::size_type)"";
      _os_log_impl(&dword_2419D9000, v7, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"#LOI Manager, Since we are in the LOI exit LOI\"}", (uint8_t *)&buf, 0x12u);
    }
    CLMicroLocationLoiManager::exitCurrentLoi((uint64_t)this, 9);
    std::string::basic_string[abi:ne180100]<0>(&buf, "Not in Active Location State");
  }
  else
  {
    v8 = (char *)this[2];
    if (v8[31] < 0)
    {
      std::string::__init_copy_ctor_external(&buf, *((const std::string::value_type **)v8 + 1), *((_QWORD *)v8 + 2));
    }
    else
    {
      v9 = *(_OWORD *)(v8 + 8);
      buf.__r_.__value_.__r.__words[2] = *((_QWORD *)v8 + 3);
      *(_OWORD *)&buf.__r_.__value_.__l.__data_ = v9;
    }
  }
  result = *(double *)&buf.__r_.__value_.__l.__data_;
  *a3 = buf;
  a3[1].__r_.__value_.__s.__data_[0] = 1;
  return result;
}

double CLMicroLocationLoiManager::LoiForGivenLocation@<D0>(CLMicroLocationLoiManager *this@<X0>, const CLMiLoLoiManagerReceivedLoiForLocationEvent *a2@<X1>, uint64_t a3@<X8>)
{
  void *v6;
  void *v7;
  void **v8;
  int v9;
  _DWORD *v10;
  NSObject *v11;
  uint64_t v12;
  __int128 v13;
  uint64_t v14;
  const char *v15;
  NSObject *v16;
  os_log_type_t v17;
  uint64_t v18;
  std::string::size_type v19;
  uint64_t v20;
  double result;
  std::string::size_type size;
  void *v23;
  id v24;
  char *v25;
  size_t v26;
  uint64_t v27;
  NSObject *v28;
  void *v29;
  uint64_t v30;
  void *v31;
  std::string *v32;
  int v33;
  uint64_t v34;
  const char *v35;
  NSObject *v36;
  os_log_type_t v37;
  NSObject *v38;
  int v39;
  std::string::size_type v40;
  std::string *p_str;
  std::string *p_p;
  NSObject *v43;
  uint64_t v44;
  __int128 v45;
  int v46;
  std::string::size_type v47;
  std::string *v48;
  std::string *v49;
  uint64_t v50;
  __int128 v51;
  NSObject *v52;
  NSUUID *v53;
  BOOL LoiIdsForLoi;
  uint64_t v55;
  __int128 v56;
  uint64_t v57;
  std::string __p;
  std::string __str;
  _BYTE buf[28];
  __int16 v61;
  std::string *v62;
  uint64_t v63;

  v63 = *MEMORY[0x24BDAC8D0];
  if (*((_BYTE *)this + 504))
  {
    ULSettings::get<ULSettings::OverrideCurrentRTLOIType>((uint64_t)&__str);
    v6 = (void *)*((_QWORD *)a2 + 4);
    if (v6)
    {
      objc_msgSend(v6, "loiIdentifier");
      v7 = (void *)objc_claimAutoreleasedReturnValue();

      if (v7)
      {
        CLMicroLocationLoiManager::convertRTLocationOfInterestTypeToString(objc_msgSend(*((id *)a2 + 4), "type"), buf);
        v8 = (void **)((char *)this + 384);
        if (*((char *)this + 407) < 0)
          operator delete(*v8);
        *(_OWORD *)v8 = *(_OWORD *)buf;
        *((_QWORD *)this + 50) = *(_QWORD *)&buf[16];
        v9 = *((char *)this + 407);
        if (v9 < 0)
        {
          if (*((_QWORD *)this + 49) != 4)
          {
LABEL_31:
            size = HIBYTE(__str.__r_.__value_.__r.__words[2]);
            if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
              size = __str.__r_.__value_.__l.__size_;
            if (size)
              std::string::operator=((std::string *)this + 16, &__str);
LABEL_35:
            objc_msgSend(*((id *)a2 + 4), "loiIdentifier");
            v23 = (void *)objc_claimAutoreleasedReturnValue();
            objc_msgSend(v23, "UUIDString");
            v24 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
            v25 = (char *)objc_msgSend(v24, "UTF8String");
            v26 = strlen(v25);
            *((_QWORD *)this + 53) = boost::uuids::string_generator::operator()<char const*>((boost::uuids::string_generator *)buf, (unsigned __int8 *)v25, (unsigned __int8 *)&v25[v26]);
            *((_QWORD *)this + 54) = v27;

            if (onceToken_MicroLocation_Default != -1)
              dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_48);
            v28 = (id)logObject_MicroLocation_Default;
            if (os_log_type_enabled(v28, OS_LOG_TYPE_INFO))
            {
              objc_msgSend(*((id *)a2 + 4), "loiIdentifier");
              v29 = (void *)objc_claimAutoreleasedReturnValue();
              objc_msgSend(v29, "description");
              v30 = objc_claimAutoreleasedReturnValue();
              v31 = (void *)v30;
              v32 = (std::string *)((char *)this + 384);
              if (*((char *)this + 407) < 0)
                v32 = (std::string *)*v8;
              *(_DWORD *)buf = 68289539;
              *(_DWORD *)&buf[4] = 0;
              *(_WORD *)&buf[8] = 2082;
              *(_QWORD *)&buf[10] = "";
              *(_WORD *)&buf[18] = 2113;
              *(_QWORD *)&buf[20] = v30;
              v61 = 2081;
              v62 = v32;
              _os_log_impl(&dword_2419D9000, v28, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"LOI Manager, Retrieved location of interest\", \"LOI ID\":%{private, location:escape_only}@, \"LOI TYPE\":%{private, location:escape_only}s}", buf, 0x26u);

            }
            v33 = *((char *)this + 407);
            if (v33 < 0)
            {
              if (*((_QWORD *)this + 49) != 4)
                goto LABEL_47;
              v8 = (void **)*v8;
            }
            else if (v33 != 4)
            {
              goto LABEL_47;
            }
            if (*(_DWORD *)v8 == 1701670760)
            {
              if (onceToken_MicroLocation_Default != -1)
                dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_48);
              v52 = logObject_MicroLocation_Default;
              if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_INFO))
              {
                *(_WORD *)buf = 0;
                _os_log_impl(&dword_2419D9000, v52, OS_LOG_TYPE_INFO, "LOI Manager, fetching related LOIs for LOI", buf, 2u);
              }
              objc_msgSend(*((id *)a2 + 4), "loiIdentifier");
              v53 = (NSUUID *)objc_claimAutoreleasedReturnValue();
              LoiIdsForLoi = CLMicroLocationLoiManager::fetchLoiIdsForLoi(this, v53);

              if (LoiIdsForLoi)
              {
                *((_WORD *)this + 252) = 256;
                v55 = *((_QWORD *)this + 2);
                if (*(char *)(v55 + 31) < 0)
                {
                  std::string::__init_copy_ctor_external((std::string *)buf, *(const std::string::value_type **)(v55 + 8), *(_QWORD *)(v55 + 16));
                }
                else
                {
                  v56 = *(_OWORD *)(v55 + 8);
                  *(_QWORD *)&buf[16] = *(_QWORD *)(v55 + 24);
                  *(_OWORD *)buf = v56;
                }
LABEL_57:
                result = *(double *)buf;
                *(_OWORD *)a3 = *(_OWORD *)buf;
                *(_QWORD *)(a3 + 16) = *(_QWORD *)&buf[16];
                *(_BYTE *)(a3 + 24) = 1;
LABEL_58:
                if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
                  operator delete(__str.__r_.__value_.__l.__data_);
                return result;
              }
              if (onceToken_MicroLocation_Default != -1)
                dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_48);
              v57 = logObject_MicroLocation_Default;
              if (!os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_ERROR))
              {
LABEL_52:
                if (onceToken_MicroLocation_Default != -1)
                  dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_48);
                v38 = logObject_MicroLocation_Default;
                if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_INFO))
                {
                  *(_WORD *)buf = 0;
                  _os_log_impl(&dword_2419D9000, v38, OS_LOG_TYPE_INFO, "LOI Manager, Returning to Inactive Location State", buf, 2u);
                }
                CLMicroLocationLoiManager::resetLoiVariables(this);
                std::string::basic_string[abi:ne180100]<0>(buf, "Not in Active Location State");
                goto LABEL_57;
              }
              *(_WORD *)buf = 0;
              v35 = "LOI Manager, Failed To request related LOIs";
              v36 = v57;
              v37 = OS_LOG_TYPE_ERROR;
LABEL_51:
              _os_log_impl(&dword_2419D9000, v36, v37, v35, buf, 2u);
              goto LABEL_52;
            }
LABEL_47:
            if (onceToken_MicroLocation_Default != -1)
              dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_48);
            v34 = logObject_MicroLocation_Default;
            if (!os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_INFO))
              goto LABEL_52;
            *(_WORD *)buf = 0;
            v35 = "LOI Manager, Not a Home LOI";
            v36 = v34;
            v37 = OS_LOG_TYPE_INFO;
            goto LABEL_51;
          }
          v10 = *v8;
        }
        else
        {
          v10 = (_DWORD *)((char *)this + 384);
          if (v9 != 4)
            goto LABEL_31;
        }
        if (*v10 == 1701670760)
          goto LABEL_35;
        goto LABEL_31;
      }
      if (onceToken_MicroLocation_Default != -1)
        dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_48);
      v18 = logObject_MicroLocation_Default;
      if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        v15 = "LOI Manager, got nil LOI for current Location.. perhaps not in an LOI";
        v16 = v18;
        v17 = OS_LOG_TYPE_DEFAULT;
        goto LABEL_22;
      }
    }
    else
    {
      if (onceToken_MicroLocation_Default != -1)
        dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_48);
      v14 = logObject_MicroLocation_Default;
      if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)buf = 0;
        v15 = "#LOIManager, Received nil object in eventData, this shouldn't happen";
        v16 = v14;
        v17 = OS_LOG_TYPE_ERROR;
LABEL_22:
        _os_log_impl(&dword_2419D9000, v16, v17, v15, buf, 2u);
      }
    }
    v19 = HIBYTE(__str.__r_.__value_.__r.__words[2]);
    if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
      v19 = __str.__r_.__value_.__l.__size_;
    if (v19)
    {
      std::string::operator=((std::string *)this + 16, &__str);
      *((_QWORD *)this + 53) = boost::uuids::string_generator::operator()<char const*>((boost::uuids::string_generator *)buf, "{FFFFFFFF-AAAA-1111-EEEE-DDDDDDDDDDDD}", (unsigned __int8 *)"");
      *((_QWORD *)this + 54) = v20;
      *((_BYTE *)this + 504) = 0;
      memset(buf, 0, 24);
      CLMicroLocationLoiManager::tryToEnterHomeLoi((uint64_t)this, (uint64_t)this + 384, (__int128 *)((char *)this + 424), (uint64_t)buf, &__p);
      result = *(double *)&__p.__r_.__value_.__l.__data_;
      *(std::string *)a3 = __p;
      *(_BYTE *)(a3 + 24) = 1;
      if (*(_QWORD *)buf)
      {
        *(_QWORD *)&buf[8] = *(_QWORD *)buf;
        operator delete(*(void **)buf);
      }
      goto LABEL_58;
    }
    goto LABEL_52;
  }
  if (onceToken_MicroLocation_Default != -1)
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_48);
  v11 = (id)logObject_MicroLocation_Default;
  if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
  {
    v12 = *((_QWORD *)this + 2);
    if (*(char *)(v12 + 31) < 0)
    {
      std::string::__init_copy_ctor_external(&__str, *(const std::string::value_type **)(v12 + 8), *(_QWORD *)(v12 + 16));
    }
    else
    {
      v13 = *(_OWORD *)(v12 + 8);
      __str.__r_.__value_.__r.__words[2] = *(_QWORD *)(v12 + 24);
      *(_OWORD *)&__str.__r_.__value_.__l.__data_ = v13;
    }
    v39 = SHIBYTE(__str.__r_.__value_.__r.__words[2]);
    v40 = __str.__r_.__value_.__r.__words[0];
    CLMicroLocationStateMachine::EventBase::getEventName(a2, &__p);
    p_str = &__str;
    if (v39 < 0)
      p_str = (std::string *)v40;
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      p_p = &__p;
    else
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    *(_DWORD *)buf = 68289539;
    *(_DWORD *)&buf[4] = 0;
    *(_WORD *)&buf[8] = 2082;
    *(_QWORD *)&buf[10] = "";
    *(_WORD *)&buf[18] = 2081;
    *(_QWORD *)&buf[20] = p_str;
    v61 = 2081;
    v62 = p_p;
    _os_log_impl(&dword_2419D9000, v11, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"LOI Manager, Got event when not expecting it\", \"State\":%{private, location:escape_only}s, \"Event\":%{private, location:escape_only}s}", buf, 0x26u);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p.__r_.__value_.__l.__data_);
    if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__str.__r_.__value_.__l.__data_);
  }

  if (onceToken_MicroLocation_Default != -1)
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_48);
  v43 = (id)logObject_MicroLocation_Default;
  if (os_signpost_enabled(v43))
  {
    v44 = *((_QWORD *)this + 2);
    if (*(char *)(v44 + 31) < 0)
    {
      std::string::__init_copy_ctor_external(&__str, *(const std::string::value_type **)(v44 + 8), *(_QWORD *)(v44 + 16));
    }
    else
    {
      v45 = *(_OWORD *)(v44 + 8);
      __str.__r_.__value_.__r.__words[2] = *(_QWORD *)(v44 + 24);
      *(_OWORD *)&__str.__r_.__value_.__l.__data_ = v45;
    }
    v46 = SHIBYTE(__str.__r_.__value_.__r.__words[2]);
    v47 = __str.__r_.__value_.__r.__words[0];
    CLMicroLocationStateMachine::EventBase::getEventName(a2, &__p);
    v48 = &__str;
    if (v46 < 0)
      v48 = (std::string *)v47;
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v49 = &__p;
    else
      v49 = (std::string *)__p.__r_.__value_.__r.__words[0];
    *(_DWORD *)buf = 68289539;
    *(_DWORD *)&buf[4] = 0;
    *(_WORD *)&buf[8] = 2082;
    *(_QWORD *)&buf[10] = "";
    *(_WORD *)&buf[18] = 2081;
    *(_QWORD *)&buf[20] = v48;
    v61 = 2081;
    v62 = v49;
    _os_signpost_emit_with_name_impl(&dword_2419D9000, v43, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "LOI Manager, Got event when not expecting it", "{\"msg%{public}.0s\":\"LOI Manager, Got event when not expecting it\", \"State\":%{private, location:escape_only}s, \"Event\":%{private, location:escape_only}s}", buf, 0x26u);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p.__r_.__value_.__l.__data_);
    if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__str.__r_.__value_.__l.__data_);
  }

  v50 = *((_QWORD *)this + 2);
  if (*(char *)(v50 + 31) < 0)
  {
    std::string::__init_copy_ctor_external((std::string *)buf, *(const std::string::value_type **)(v50 + 8), *(_QWORD *)(v50 + 16));
  }
  else
  {
    v51 = *(_OWORD *)(v50 + 8);
    *(_QWORD *)&buf[16] = *(_QWORD *)(v50 + 24);
    *(_OWORD *)buf = v51;
  }
  result = *(double *)buf;
  *(_OWORD *)a3 = *(_OWORD *)buf;
  *(_QWORD *)(a3 + 16) = *(_QWORD *)&buf[16];
  *(_BYTE *)(a3 + 24) = 1;
  return result;
}

void sub_241A68708(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, void *a20,uint64_t a21)
{
  if (a18 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

double CLMicroLocationLoiManager::LoiFetchFailure@<D0>(CLMicroLocationLoiManager *this@<X0>, const CLMiLoLoiManagerFailedToFetchLoiForLocationEvent *a2@<X1>, uint64_t a3@<X8>)
{
  NSObject *v6;
  uint64_t v7;
  __int128 v8;
  int v9;
  std::string::size_type v10;
  std::string *v11;
  std::string *p_p;
  NSObject *v13;
  uint64_t v14;
  __int128 v15;
  int v16;
  std::string::size_type v17;
  std::string *v18;
  std::string *v19;
  uint64_t v20;
  __int128 v21;
  double result;
  std::string __p;
  std::string v24;
  _BYTE buf[28];
  __int16 v26;
  std::string *v27;
  uint64_t v28;

  v28 = *MEMORY[0x24BDAC8D0];
  if (*((_BYTE *)this + 504))
  {
    CLMicroLocationLoiManager::sendLoiRelatedErrorEvent(this, CFSTR("Home LOI Entry Failure"), CFSTR("LOI Fetch Failure"));
    CLMicroLocationLoiManager::resetLoiVariables(this);
    std::string::basic_string[abi:ne180100]<0>(buf, "Not in Active Location State");
  }
  else
  {
    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_48);
    v6 = (id)logObject_MicroLocation_Default;
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      v7 = *((_QWORD *)this + 2);
      if (*(char *)(v7 + 31) < 0)
      {
        std::string::__init_copy_ctor_external(&v24, *(const std::string::value_type **)(v7 + 8), *(_QWORD *)(v7 + 16));
      }
      else
      {
        v8 = *(_OWORD *)(v7 + 8);
        v24.__r_.__value_.__r.__words[2] = *(_QWORD *)(v7 + 24);
        *(_OWORD *)&v24.__r_.__value_.__l.__data_ = v8;
      }
      v9 = SHIBYTE(v24.__r_.__value_.__r.__words[2]);
      v10 = v24.__r_.__value_.__r.__words[0];
      CLMicroLocationStateMachine::EventBase::getEventName(a2, &__p);
      v11 = &v24;
      if (v9 < 0)
        v11 = (std::string *)v10;
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        p_p = &__p;
      else
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      *(_DWORD *)buf = 68289539;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(_QWORD *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2081;
      *(_QWORD *)&buf[20] = v11;
      v26 = 2081;
      v27 = p_p;
      _os_log_impl(&dword_2419D9000, v6, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"LOI Manager, Got event when not expecting it\", \"State\":%{private, location:escape_only}s, \"Event\":%{private, location:escape_only}s}", buf, 0x26u);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__p.__r_.__value_.__l.__data_);
      if (SHIBYTE(v24.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v24.__r_.__value_.__l.__data_);
    }

    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_48);
    v13 = (id)logObject_MicroLocation_Default;
    if (os_signpost_enabled(v13))
    {
      v14 = *((_QWORD *)this + 2);
      if (*(char *)(v14 + 31) < 0)
      {
        std::string::__init_copy_ctor_external(&v24, *(const std::string::value_type **)(v14 + 8), *(_QWORD *)(v14 + 16));
      }
      else
      {
        v15 = *(_OWORD *)(v14 + 8);
        v24.__r_.__value_.__r.__words[2] = *(_QWORD *)(v14 + 24);
        *(_OWORD *)&v24.__r_.__value_.__l.__data_ = v15;
      }
      v16 = SHIBYTE(v24.__r_.__value_.__r.__words[2]);
      v17 = v24.__r_.__value_.__r.__words[0];
      CLMicroLocationStateMachine::EventBase::getEventName(a2, &__p);
      v18 = &v24;
      if (v16 < 0)
        v18 = (std::string *)v17;
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v19 = &__p;
      else
        v19 = (std::string *)__p.__r_.__value_.__r.__words[0];
      *(_DWORD *)buf = 68289539;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(_QWORD *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2081;
      *(_QWORD *)&buf[20] = v18;
      v26 = 2081;
      v27 = v19;
      _os_signpost_emit_with_name_impl(&dword_2419D9000, v13, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "LOI Manager, Got event when not expecting it", "{\"msg%{public}.0s\":\"LOI Manager, Got event when not expecting it\", \"State\":%{private, location:escape_only}s, \"Event\":%{private, location:escape_only}s}", buf, 0x26u);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__p.__r_.__value_.__l.__data_);
      if (SHIBYTE(v24.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v24.__r_.__value_.__l.__data_);
    }

    v20 = *((_QWORD *)this + 2);
    if (*(char *)(v20 + 31) < 0)
    {
      std::string::__init_copy_ctor_external((std::string *)buf, *(const std::string::value_type **)(v20 + 8), *(_QWORD *)(v20 + 16));
    }
    else
    {
      v21 = *(_OWORD *)(v20 + 8);
      *(_QWORD *)&buf[16] = *(_QWORD *)(v20 + 24);
      *(_OWORD *)buf = v21;
    }
  }
  result = *(double *)buf;
  *(_OWORD *)a3 = *(_OWORD *)buf;
  *(_QWORD *)(a3 + 16) = *(_QWORD *)&buf[16];
  *(_BYTE *)(a3 + 24) = 1;
  return result;
}

void sub_241A68B24(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  void *v18;

  _Unwind_Resume(a1);
}

void CLMicroLocationLoiManager::SuccessfullyFetchedPlaceInference(std::string *this@<X0>, id *a2@<X1>, uint64_t a3@<X8>)
{
  void *v6;
  void *v7;
  double v8;
  double v9;
  void *v10;
  double v11;
  void **p_data;
  void *v13;
  id v14;
  char *v15;
  size_t v16;
  std::string::size_type v17;
  NSObject *v18;
  void *v19;
  id v20;
  uint64_t v21;
  std::string *v22;
  int v23;
  std::string *v24;
  NSObject *v25;
  std::string::size_type v26;
  __int128 v27;
  NSObject *v28;
  NSObject *v29;
  std::string::size_type size;
  NSObject *v31;
  std::string *v32;
  uint64_t v33;
  const char *v34;
  NSObject *v35;
  os_log_type_t v36;
  NSObject *v37;
  NSObject *v38;
  NSUUID *v39;
  BOOL LoiIdsForLoi;
  std::string::size_type v41;
  __int128 v42;
  int v43;
  std::string::size_type v44;
  std::string *p_str;
  std::string *p_p;
  NSObject *v47;
  std::string::size_type v48;
  __int128 v49;
  int v50;
  std::string::size_type v51;
  std::string *v52;
  std::string *v53;
  std::string::size_type v54;
  __int128 v55;
  uint64_t v56;
  std::string __p;
  std::string __str;
  _BYTE buf[28];
  __int16 v60;
  std::string *v61;
  uint64_t v62;

  v62 = *MEMORY[0x24BDAC8D0];
  if (!this[21].__r_.__value_.__s.__data_[0])
  {
    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_48);
    v25 = (id)logObject_MicroLocation_Default;
    if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
    {
      v26 = this->__r_.__value_.__r.__words[2];
      if (*(char *)(v26 + 31) < 0)
      {
        std::string::__init_copy_ctor_external(&__str, *(const std::string::value_type **)(v26 + 8), *(_QWORD *)(v26 + 16));
      }
      else
      {
        v27 = *(_OWORD *)(v26 + 8);
        __str.__r_.__value_.__r.__words[2] = *(_QWORD *)(v26 + 24);
        *(_OWORD *)&__str.__r_.__value_.__l.__data_ = v27;
      }
      v43 = SHIBYTE(__str.__r_.__value_.__r.__words[2]);
      v44 = __str.__r_.__value_.__r.__words[0];
      CLMicroLocationStateMachine::EventBase::getEventName((CLMicroLocationStateMachine::EventBase *)a2, &__p);
      p_str = &__str;
      if (v43 < 0)
        p_str = (std::string *)v44;
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        p_p = &__p;
      else
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      *(_DWORD *)buf = 68289539;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(_QWORD *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2081;
      *(_QWORD *)&buf[20] = p_str;
      v60 = 2081;
      v61 = p_p;
      _os_log_impl(&dword_2419D9000, v25, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"LOI Manager, Got event when not expecting it\", \"State\":%{private, location:escape_only}s, \"Event\":%{private, location:escape_only}s}", buf, 0x26u);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__p.__r_.__value_.__l.__data_);
      if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__str.__r_.__value_.__l.__data_);
    }

    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_48);
    v47 = (id)logObject_MicroLocation_Default;
    if (os_signpost_enabled(v47))
    {
      v48 = this->__r_.__value_.__r.__words[2];
      if (*(char *)(v48 + 31) < 0)
      {
        std::string::__init_copy_ctor_external(&__str, *(const std::string::value_type **)(v48 + 8), *(_QWORD *)(v48 + 16));
      }
      else
      {
        v49 = *(_OWORD *)(v48 + 8);
        __str.__r_.__value_.__r.__words[2] = *(_QWORD *)(v48 + 24);
        *(_OWORD *)&__str.__r_.__value_.__l.__data_ = v49;
      }
      v50 = SHIBYTE(__str.__r_.__value_.__r.__words[2]);
      v51 = __str.__r_.__value_.__r.__words[0];
      CLMicroLocationStateMachine::EventBase::getEventName((CLMicroLocationStateMachine::EventBase *)a2, &__p);
      v52 = &__str;
      if (v50 < 0)
        v52 = (std::string *)v51;
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v53 = &__p;
      else
        v53 = (std::string *)__p.__r_.__value_.__r.__words[0];
      *(_DWORD *)buf = 68289539;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(_QWORD *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2081;
      *(_QWORD *)&buf[20] = v52;
      v60 = 2081;
      v61 = v53;
      _os_signpost_emit_with_name_impl(&dword_2419D9000, v47, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "LOI Manager, Got event when not expecting it", "{\"msg%{public}.0s\":\"LOI Manager, Got event when not expecting it\", \"State\":%{private, location:escape_only}s, \"Event\":%{private, location:escape_only}s}", buf, 0x26u);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__p.__r_.__value_.__l.__data_);
      if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__str.__r_.__value_.__l.__data_);
    }

    v54 = this->__r_.__value_.__r.__words[2];
    if (*(char *)(v54 + 31) < 0)
    {
      std::string::__init_copy_ctor_external((std::string *)buf, *(const std::string::value_type **)(v54 + 8), *(_QWORD *)(v54 + 16));
    }
    else
    {
      v55 = *(_OWORD *)(v54 + 8);
      *(_QWORD *)&buf[16] = *(_QWORD *)(v54 + 24);
      *(_OWORD *)buf = v55;
    }
    goto LABEL_94;
  }
  objc_msgSend(a2[4], "_loiIdentifier");
  v6 = (void *)objc_claimAutoreleasedReturnValue();

  if (!v6)
  {
    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_48);
    v28 = logObject_MicroLocation_Default;
    if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 68289026;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(_QWORD *)&buf[10] = "";
      _os_log_impl(&dword_2419D9000, v28, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"LOI Manager, received nil LOI Identifier from place inference, possibly because there is no active user on macOS, we will start leeching and wait for next location update\"}", buf, 0x12u);
    }
    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_48);
    v29 = logObject_MicroLocation_Default;
    if (os_signpost_enabled((os_log_t)logObject_MicroLocation_Default))
    {
      *(_DWORD *)buf = 68289026;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(_QWORD *)&buf[10] = "";
      _os_signpost_emit_with_name_impl(&dword_2419D9000, v29, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "LOI Manager, received nil LOI Identifier from place inference, possibly because there is no active user on macOS, we will start leeching and wait for next location update", "{\"msg%{public}.0s\":\"LOI Manager, received nil LOI Identifier from place inference, possibly because there is no active user on macOS, we will start leeching and wait for next location update\"}", buf, 0x12u);
    }
    CLMicroLocationLoiManager::resetLoiVariables((CLMicroLocationLoiManager *)this);
    objc_msgSend(this[14].__r_.__value_.__l.__data_, "startLeechingLocationUpdates");
    std::string::basic_string[abi:ne180100]<0>(buf, "Not in Active Location State");
LABEL_94:
    *(_OWORD *)a3 = *(_OWORD *)buf;
    *(_QWORD *)(a3 + 16) = *(_QWORD *)&buf[16];
    *(_BYTE *)(a3 + 24) = 1;
    return;
  }
  objc_msgSend(a2[4], "referenceLocation");
  v7 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v7, "coordinate");
  v9 = v8;
  objc_msgSend(a2[4], "referenceLocation");
  v10 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v10, "coordinate");
  CLMicroLocationLoiManager::initializeStateAtLocation((CLMicroLocationLoiManager *)this, v9, v11);

  CLMicroLocationLoiManager::convertPlaceInferenceUserPlaceTypeToString(objc_msgSend(a2[4], "userType"), buf);
  p_data = (void **)&this[16].__r_.__value_.__l.__data_;
  if (SHIBYTE(this[16].__r_.__value_.__r.__words[2]) < 0)
    operator delete(*p_data);
  *(_OWORD *)p_data = *(_OWORD *)buf;
  this[16].__r_.__value_.__r.__words[2] = *(_QWORD *)&buf[16];
  objc_msgSend(a2[4], "_loiIdentifier");
  v13 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v13, "UUIDString");
  v14 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
  v15 = (char *)objc_msgSend(v14, "UTF8String");
  v16 = strlen(v15);
  this[17].__r_.__value_.__r.__words[2] = boost::uuids::string_generator::operator()<char const*>((boost::uuids::string_generator *)buf, (unsigned __int8 *)v15, (unsigned __int8 *)&v15[v16]);
  this[18].__r_.__value_.__r.__words[0] = v17;

  if (onceToken_MicroLocation_Default != -1)
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_48);
  v18 = (id)logObject_MicroLocation_Default;
  if (os_log_type_enabled(v18, OS_LOG_TYPE_INFO))
  {
    objc_msgSend(a2[4], "_loiIdentifier");
    v19 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v19, "UUIDString");
    v20 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
    v21 = objc_msgSend(v20, "UTF8String");
    v22 = this + 16;
    if (SHIBYTE(this[16].__r_.__value_.__r.__words[2]) < 0)
      v22 = (std::string *)*p_data;
    *(_DWORD *)buf = 68289539;
    *(_DWORD *)&buf[4] = 0;
    *(_WORD *)&buf[8] = 2082;
    *(_QWORD *)&buf[10] = "";
    *(_WORD *)&buf[18] = 2081;
    *(_QWORD *)&buf[20] = v21;
    v60 = 2081;
    v61 = v22;
    _os_log_impl(&dword_2419D9000, v18, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"LOI Manager, Retrieved place infernce\", \"LOI ID\":%{private, location:escape_only}s, \"LOI TYPE\":%{private, location:escape_only}s}", buf, 0x26u);

  }
  ULSettings::get<ULSettings::OverrideCurrentRTLOIType>((uint64_t)&__str);
  v23 = HIBYTE(this[16].__r_.__value_.__r.__words[2]);
  if ((SHIBYTE(this[16].__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    v24 = this + 16;
    if (v23 != 4)
      goto LABEL_31;
LABEL_30:
    if (LODWORD(v24->__r_.__value_.__l.__data_) == 1701670760)
      goto LABEL_41;
    goto LABEL_31;
  }
  if (this[16].__r_.__value_.__l.__size_ == 4)
  {
    v24 = (std::string *)*p_data;
    goto LABEL_30;
  }
LABEL_31:
  size = HIBYTE(__str.__r_.__value_.__r.__words[2]);
  if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
    size = __str.__r_.__value_.__l.__size_;
  if (size)
  {
    std::string::operator=(this + 16, &__str);
    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_48);
    v31 = logObject_MicroLocation_Default;
    if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_INFO))
    {
      v32 = &__str;
      if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
        v32 = (std::string *)__str.__r_.__value_.__r.__words[0];
      *(_DWORD *)buf = 68289283;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(_QWORD *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2081;
      *(_QWORD *)&buf[20] = v32;
      _os_log_impl(&dword_2419D9000, v31, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"LOI Manager, forcing LOI type\", \"LOI Override\":%{private, location:escape_only}s}", buf, 0x1Cu);
    }
    v23 = HIBYTE(this[16].__r_.__value_.__r.__words[2]);
  }
LABEL_41:
  if ((v23 & 0x80) != 0)
  {
    if (this[16].__r_.__value_.__l.__size_ != 4)
    {
LABEL_47:
      if (onceToken_MicroLocation_Default != -1)
        dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_48);
      v33 = logObject_MicroLocation_Default;
      if (!os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_INFO))
        goto LABEL_52;
      *(_WORD *)buf = 0;
      v34 = "LOI Manager, Not a Home LOI";
      v35 = v33;
      v36 = OS_LOG_TYPE_INFO;
LABEL_51:
      _os_log_impl(&dword_2419D9000, v35, v36, v34, buf, 2u);
LABEL_52:
      if (onceToken_MicroLocation_Default != -1)
        dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_48);
      v37 = logObject_MicroLocation_Default;
      if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_INFO))
      {
        *(_WORD *)buf = 0;
        _os_log_impl(&dword_2419D9000, v37, OS_LOG_TYPE_INFO, "LOI Manager, Returning to Inactive Location State and starting leeching", buf, 2u);
      }
      CLMicroLocationLoiManager::resetLoiVariables((CLMicroLocationLoiManager *)this);
      objc_msgSend(this[14].__r_.__value_.__l.__data_, "startLeechingLocationUpdates");
      std::string::basic_string[abi:ne180100]<0>(buf, "Not in Active Location State");
      goto LABEL_57;
    }
    p_data = (void **)*p_data;
  }
  else if (v23 != 4)
  {
    goto LABEL_47;
  }
  if (*(_DWORD *)p_data != 1701670760)
    goto LABEL_47;
  if (onceToken_MicroLocation_Default != -1)
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_48);
  v38 = logObject_MicroLocation_Default;
  if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_2419D9000, v38, OS_LOG_TYPE_INFO, "LOI Manager, fetching related LOIs for LOI", buf, 2u);
  }
  objc_msgSend(a2[4], "_loiIdentifier");
  v39 = (NSUUID *)objc_claimAutoreleasedReturnValue();
  LoiIdsForLoi = CLMicroLocationLoiManager::fetchLoiIdsForLoi((CLMicroLocationLoiManager *)this, v39);

  if (!LoiIdsForLoi)
  {
    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_48);
    v56 = logObject_MicroLocation_Default;
    if (!os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_ERROR))
      goto LABEL_52;
    *(_WORD *)buf = 0;
    v34 = "LOI Manager, Failed To request related LOIs";
    v35 = v56;
    v36 = OS_LOG_TYPE_ERROR;
    goto LABEL_51;
  }
  LOWORD(this[21].__r_.__value_.__l.__data_) = 256;
  v41 = this->__r_.__value_.__r.__words[2];
  if (*(char *)(v41 + 31) < 0)
  {
    std::string::__init_copy_ctor_external((std::string *)buf, *(const std::string::value_type **)(v41 + 8), *(_QWORD *)(v41 + 16));
  }
  else
  {
    v42 = *(_OWORD *)(v41 + 8);
    *(_QWORD *)&buf[16] = *(_QWORD *)(v41 + 24);
    *(_OWORD *)buf = v42;
  }
LABEL_57:
  *(_OWORD *)a3 = *(_OWORD *)buf;
  *(_QWORD *)(a3 + 16) = *(_QWORD *)&buf[16];
  *(_BYTE *)(a3 + 24) = 1;
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__str.__r_.__value_.__l.__data_);
}

void sub_241A694D8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

double CLMicroLocationLoiManager::FailedToFetchedPlaceInference@<D0>(CLMicroLocationLoiManager *this@<X0>, const CLMiLoLoiManagerFailedToFetchPlaceInference *a2@<X1>, std::string *a3@<X8>)
{
  NSObject *v6;
  uint64_t v7;
  char v8;
  uint64_t v9;
  double result;
  void *v11;
  NSObject *v12;
  uint64_t v13;
  __int128 v14;
  int v15;
  std::string::size_type v16;
  std::string *v17;
  std::string *p_p;
  NSObject *v19;
  uint64_t v20;
  __int128 v21;
  int v22;
  std::string::size_type v23;
  std::string *v24;
  std::string *v25;
  uint64_t v26;
  __int128 v27;
  std::string __p;
  std::string v29;
  _BYTE buf[28];
  __int16 v31;
  std::string *v32;
  uint64_t v33;

  v33 = *MEMORY[0x24BDAC8D0];
  if (onceToken_MicroLocation_Default != -1)
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_48);
  v6 = logObject_MicroLocation_Default;
  if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_2419D9000, v6, OS_LOG_TYPE_INFO, "LOI Manager, Failed To fetch place inferences, starting leeching", buf, 2u);
  }
  if (*((_BYTE *)this + 504))
  {
    ULSettings::get<ULSettings::OverrideCurrentRTLOIType>((uint64_t)buf);
    v7 = buf[23];
    v8 = buf[23];
    if (buf[23] < 0)
      v7 = *(_QWORD *)&buf[8];
    if (!v7)
    {
      CLMicroLocationLoiManager::sendLoiRelatedErrorEvent(this, CFSTR("Home LOI Entry Failure"), CFSTR("Place Inference Fetch Failure"));
      CLMicroLocationLoiManager::resetLoiVariables(this);
      objc_msgSend(*((id *)this + 42), "startLeechingLocationUpdates");
      std::string::basic_string[abi:ne180100]<0>(&v29, "Not in Active Location State");
      result = *(double *)&v29.__r_.__value_.__l.__data_;
      *a3 = v29;
      a3[1].__r_.__value_.__s.__data_[0] = 1;
      if ((v8 & 0x80) == 0)
        return result;
      goto LABEL_19;
    }
    std::string::operator=((std::string *)this + 16, (const std::string *)buf);
    *((_QWORD *)this + 53) = boost::uuids::string_generator::operator()<char const*>((boost::uuids::string_generator *)&v29, "{FFFFFFFF-AAAA-1111-EEEE-DDDDDDDDDDDD}", (unsigned __int8 *)"");
    *((_QWORD *)this + 54) = v9;
    *((_BYTE *)this + 504) = 0;
    memset(&v29, 0, sizeof(v29));
    CLMicroLocationLoiManager::tryToEnterHomeLoi((uint64_t)this, (uint64_t)this + 384, (__int128 *)((char *)this + 424), (uint64_t)&v29, &__p);
    result = *(double *)&__p.__r_.__value_.__l.__data_;
    *(_OWORD *)&a3->__r_.__value_.__l.__data_ = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
    v11 = (void *)v29.__r_.__value_.__r.__words[0];
    a3->__r_.__value_.__r.__words[2] = __p.__r_.__value_.__r.__words[2];
    a3[1].__r_.__value_.__s.__data_[0] = 1;
    if (v11)
    {
      v29.__r_.__value_.__l.__size_ = (std::string::size_type)v11;
      operator delete(v11);
    }
    if ((buf[23] & 0x80) != 0)
LABEL_19:
      operator delete(*(void **)buf);
  }
  else
  {
    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_48);
    v12 = (id)logObject_MicroLocation_Default;
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      v13 = *((_QWORD *)this + 2);
      if (*(char *)(v13 + 31) < 0)
      {
        std::string::__init_copy_ctor_external(&v29, *(const std::string::value_type **)(v13 + 8), *(_QWORD *)(v13 + 16));
      }
      else
      {
        v14 = *(_OWORD *)(v13 + 8);
        v29.__r_.__value_.__r.__words[2] = *(_QWORD *)(v13 + 24);
        *(_OWORD *)&v29.__r_.__value_.__l.__data_ = v14;
      }
      v15 = SHIBYTE(v29.__r_.__value_.__r.__words[2]);
      v16 = v29.__r_.__value_.__r.__words[0];
      CLMicroLocationStateMachine::EventBase::getEventName(a2, &__p);
      v17 = &v29;
      if (v15 < 0)
        v17 = (std::string *)v16;
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        p_p = &__p;
      else
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      *(_DWORD *)buf = 68289539;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(_QWORD *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2081;
      *(_QWORD *)&buf[20] = v17;
      v31 = 2081;
      v32 = p_p;
      _os_log_impl(&dword_2419D9000, v12, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"LOI Manager, Got event when not expecting it\", \"State\":%{private, location:escape_only}s, \"Event\":%{private, location:escape_only}s}", buf, 0x26u);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__p.__r_.__value_.__l.__data_);
      if (SHIBYTE(v29.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v29.__r_.__value_.__l.__data_);
    }

    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_48);
    v19 = (id)logObject_MicroLocation_Default;
    if (os_signpost_enabled(v19))
    {
      v20 = *((_QWORD *)this + 2);
      if (*(char *)(v20 + 31) < 0)
      {
        std::string::__init_copy_ctor_external(&v29, *(const std::string::value_type **)(v20 + 8), *(_QWORD *)(v20 + 16));
      }
      else
      {
        v21 = *(_OWORD *)(v20 + 8);
        v29.__r_.__value_.__r.__words[2] = *(_QWORD *)(v20 + 24);
        *(_OWORD *)&v29.__r_.__value_.__l.__data_ = v21;
      }
      v22 = SHIBYTE(v29.__r_.__value_.__r.__words[2]);
      v23 = v29.__r_.__value_.__r.__words[0];
      CLMicroLocationStateMachine::EventBase::getEventName(a2, &__p);
      v24 = &v29;
      if (v22 < 0)
        v24 = (std::string *)v23;
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v25 = &__p;
      else
        v25 = (std::string *)__p.__r_.__value_.__r.__words[0];
      *(_DWORD *)buf = 68289539;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(_QWORD *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2081;
      *(_QWORD *)&buf[20] = v24;
      v31 = 2081;
      v32 = v25;
      _os_signpost_emit_with_name_impl(&dword_2419D9000, v19, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "LOI Manager, Got event when not expecting it", "{\"msg%{public}.0s\":\"LOI Manager, Got event when not expecting it\", \"State\":%{private, location:escape_only}s, \"Event\":%{private, location:escape_only}s}", buf, 0x26u);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__p.__r_.__value_.__l.__data_);
      if (SHIBYTE(v29.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v29.__r_.__value_.__l.__data_);
    }

    v26 = *((_QWORD *)this + 2);
    if (*(char *)(v26 + 31) < 0)
    {
      std::string::__init_copy_ctor_external((std::string *)buf, *(const std::string::value_type **)(v26 + 8), *(_QWORD *)(v26 + 16));
    }
    else
    {
      v27 = *(_OWORD *)(v26 + 8);
      *(_QWORD *)&buf[16] = *(_QWORD *)(v26 + 24);
      *(_OWORD *)buf = v27;
    }
    result = *(double *)buf;
    *(_OWORD *)&a3->__r_.__value_.__l.__data_ = *(_OWORD *)buf;
    a3->__r_.__value_.__r.__words[2] = *(_QWORD *)&buf[16];
    a3[1].__r_.__value_.__s.__data_[0] = 1;
  }
  return result;
}

void sub_241A69A24(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  void *v25;

  _Unwind_Resume(a1);
}

double CLMicroLocationLoiManager::RelatedLois@<D0>(CLMicroLocationLoiManager *this@<X0>, const CLMiLoLoiManagerReceivedRelatedLoisEvent *a2@<X1>, uint64_t a3@<X8>)
{
  NSObject *v6;
  uint64_t v7;
  __int128 v8;
  int v9;
  std::string::size_type v10;
  std::string *v11;
  std::string *p_p;
  NSObject *v13;
  uint64_t v14;
  __int128 v15;
  int v16;
  std::string::size_type v17;
  std::string *v18;
  std::string *v19;
  uint64_t v20;
  __int128 v21;
  double result;
  std::string __p;
  std::string v24;
  _BYTE buf[28];
  __int16 v26;
  std::string *v27;
  uint64_t v28;

  v28 = *MEMORY[0x24BDAC8D0];
  if (*((_BYTE *)this + 505))
  {
    CLMicroLocationLoiManager::tryToEnterHomeLoi((uint64_t)this, (uint64_t)this + 384, (__int128 *)((char *)this + 424), (uint64_t)a2 + 32, buf);
  }
  else
  {
    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_48);
    v6 = (id)logObject_MicroLocation_Default;
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      v7 = *((_QWORD *)this + 2);
      if (*(char *)(v7 + 31) < 0)
      {
        std::string::__init_copy_ctor_external(&v24, *(const std::string::value_type **)(v7 + 8), *(_QWORD *)(v7 + 16));
      }
      else
      {
        v8 = *(_OWORD *)(v7 + 8);
        v24.__r_.__value_.__r.__words[2] = *(_QWORD *)(v7 + 24);
        *(_OWORD *)&v24.__r_.__value_.__l.__data_ = v8;
      }
      v9 = SHIBYTE(v24.__r_.__value_.__r.__words[2]);
      v10 = v24.__r_.__value_.__r.__words[0];
      CLMicroLocationStateMachine::EventBase::getEventName(a2, &__p);
      v11 = &v24;
      if (v9 < 0)
        v11 = (std::string *)v10;
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        p_p = &__p;
      else
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      *(_DWORD *)buf = 68289539;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(_QWORD *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2081;
      *(_QWORD *)&buf[20] = v11;
      v26 = 2081;
      v27 = p_p;
      _os_log_impl(&dword_2419D9000, v6, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"LOI Manager, Got event when not expecting it\", \"State\":%{private, location:escape_only}s, \"Event\":%{private, location:escape_only}s}", buf, 0x26u);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__p.__r_.__value_.__l.__data_);
      if (SHIBYTE(v24.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v24.__r_.__value_.__l.__data_);
    }

    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_48);
    v13 = (id)logObject_MicroLocation_Default;
    if (os_signpost_enabled(v13))
    {
      v14 = *((_QWORD *)this + 2);
      if (*(char *)(v14 + 31) < 0)
      {
        std::string::__init_copy_ctor_external(&v24, *(const std::string::value_type **)(v14 + 8), *(_QWORD *)(v14 + 16));
      }
      else
      {
        v15 = *(_OWORD *)(v14 + 8);
        v24.__r_.__value_.__r.__words[2] = *(_QWORD *)(v14 + 24);
        *(_OWORD *)&v24.__r_.__value_.__l.__data_ = v15;
      }
      v16 = SHIBYTE(v24.__r_.__value_.__r.__words[2]);
      v17 = v24.__r_.__value_.__r.__words[0];
      CLMicroLocationStateMachine::EventBase::getEventName(a2, &__p);
      v18 = &v24;
      if (v16 < 0)
        v18 = (std::string *)v17;
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v19 = &__p;
      else
        v19 = (std::string *)__p.__r_.__value_.__r.__words[0];
      *(_DWORD *)buf = 68289539;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(_QWORD *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2081;
      *(_QWORD *)&buf[20] = v18;
      v26 = 2081;
      v27 = v19;
      _os_signpost_emit_with_name_impl(&dword_2419D9000, v13, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "LOI Manager, Got event when not expecting it", "{\"msg%{public}.0s\":\"LOI Manager, Got event when not expecting it\", \"State\":%{private, location:escape_only}s, \"Event\":%{private, location:escape_only}s}", buf, 0x26u);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__p.__r_.__value_.__l.__data_);
      if (SHIBYTE(v24.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v24.__r_.__value_.__l.__data_);
    }

    v20 = *((_QWORD *)this + 2);
    if (*(char *)(v20 + 31) < 0)
    {
      std::string::__init_copy_ctor_external((std::string *)buf, *(const std::string::value_type **)(v20 + 8), *(_QWORD *)(v20 + 16));
    }
    else
    {
      v21 = *(_OWORD *)(v20 + 8);
      *(_QWORD *)&buf[16] = *(_QWORD *)(v20 + 24);
      *(_OWORD *)buf = v21;
    }
  }
  result = *(double *)buf;
  *(_OWORD *)a3 = *(_OWORD *)buf;
  *(_QWORD *)(a3 + 16) = *(_QWORD *)&buf[16];
  *(_BYTE *)(a3 + 24) = 1;
  return result;
}

void sub_241A69DE0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  void *v18;

  _Unwind_Resume(a1);
}

double CLMicroLocationLoiManager::FailureToFetchRelatedLois@<D0>(CLMicroLocationLoiManager *this@<X0>, const CLMiLoLoiManagerFailedToFetchRelatedLois *a2@<X1>, uint64_t a3@<X8>)
{
  NSObject *v6;
  uint64_t v7;
  __int128 v8;
  int v9;
  std::string::size_type v10;
  std::string *v11;
  std::string *p_p;
  NSObject *v13;
  uint64_t v14;
  __int128 v15;
  int v16;
  std::string::size_type v17;
  std::string *v18;
  std::string *v19;
  uint64_t v20;
  __int128 v21;
  double result;
  std::string __p;
  std::string v24;
  _BYTE buf[28];
  __int16 v26;
  std::string *v27;
  uint64_t v28;

  v28 = *MEMORY[0x24BDAC8D0];
  if (*((_BYTE *)this + 505))
  {
    CLMicroLocationLoiManager::sendLoiRelatedErrorEvent(this, CFSTR("Home LOI Entry Failure"), CFSTR("Related LOI Fetch Failure"));
    CLMicroLocationLoiManager::resetLoiVariables(this);
    std::string::basic_string[abi:ne180100]<0>(buf, "Not in Active Location State");
  }
  else
  {
    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_48);
    v6 = (id)logObject_MicroLocation_Default;
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      v7 = *((_QWORD *)this + 2);
      if (*(char *)(v7 + 31) < 0)
      {
        std::string::__init_copy_ctor_external(&v24, *(const std::string::value_type **)(v7 + 8), *(_QWORD *)(v7 + 16));
      }
      else
      {
        v8 = *(_OWORD *)(v7 + 8);
        v24.__r_.__value_.__r.__words[2] = *(_QWORD *)(v7 + 24);
        *(_OWORD *)&v24.__r_.__value_.__l.__data_ = v8;
      }
      v9 = SHIBYTE(v24.__r_.__value_.__r.__words[2]);
      v10 = v24.__r_.__value_.__r.__words[0];
      CLMicroLocationStateMachine::EventBase::getEventName(a2, &__p);
      v11 = &v24;
      if (v9 < 0)
        v11 = (std::string *)v10;
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        p_p = &__p;
      else
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      *(_DWORD *)buf = 68289539;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(_QWORD *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2081;
      *(_QWORD *)&buf[20] = v11;
      v26 = 2081;
      v27 = p_p;
      _os_log_impl(&dword_2419D9000, v6, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"LOI Manager, Got event when not expecting it\", \"State\":%{private, location:escape_only}s, \"Event\":%{private, location:escape_only}s}", buf, 0x26u);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__p.__r_.__value_.__l.__data_);
      if (SHIBYTE(v24.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v24.__r_.__value_.__l.__data_);
    }

    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_48);
    v13 = (id)logObject_MicroLocation_Default;
    if (os_signpost_enabled(v13))
    {
      v14 = *((_QWORD *)this + 2);
      if (*(char *)(v14 + 31) < 0)
      {
        std::string::__init_copy_ctor_external(&v24, *(const std::string::value_type **)(v14 + 8), *(_QWORD *)(v14 + 16));
      }
      else
      {
        v15 = *(_OWORD *)(v14 + 8);
        v24.__r_.__value_.__r.__words[2] = *(_QWORD *)(v14 + 24);
        *(_OWORD *)&v24.__r_.__value_.__l.__data_ = v15;
      }
      v16 = SHIBYTE(v24.__r_.__value_.__r.__words[2]);
      v17 = v24.__r_.__value_.__r.__words[0];
      CLMicroLocationStateMachine::EventBase::getEventName(a2, &__p);
      v18 = &v24;
      if (v16 < 0)
        v18 = (std::string *)v17;
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v19 = &__p;
      else
        v19 = (std::string *)__p.__r_.__value_.__r.__words[0];
      *(_DWORD *)buf = 68289539;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(_QWORD *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2081;
      *(_QWORD *)&buf[20] = v18;
      v26 = 2081;
      v27 = v19;
      _os_signpost_emit_with_name_impl(&dword_2419D9000, v13, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "LOI Manager, Got event when not expecting it", "{\"msg%{public}.0s\":\"LOI Manager, Got event when not expecting it\", \"State\":%{private, location:escape_only}s, \"Event\":%{private, location:escape_only}s}", buf, 0x26u);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__p.__r_.__value_.__l.__data_);
      if (SHIBYTE(v24.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v24.__r_.__value_.__l.__data_);
    }

    v20 = *((_QWORD *)this + 2);
    if (*(char *)(v20 + 31) < 0)
    {
      std::string::__init_copy_ctor_external((std::string *)buf, *(const std::string::value_type **)(v20 + 8), *(_QWORD *)(v20 + 16));
    }
    else
    {
      v21 = *(_OWORD *)(v20 + 8);
      *(_QWORD *)&buf[16] = *(_QWORD *)(v20 + 24);
      *(_OWORD *)buf = v21;
    }
  }
  result = *(double *)buf;
  *(_OWORD *)a3 = *(_OWORD *)buf;
  *(_QWORD *)(a3 + 16) = *(_QWORD *)&buf[16];
  *(_BYTE *)(a3 + 24) = 1;
  return result;
}

void sub_241A6A160(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  void *v18;

  _Unwind_Resume(a1);
}

double CLMicroLocationLoiManager::EnableCustomLoiWhileEnabling@<D0>(CLMicroLocationLoiManager *this@<X0>, const CLMiLoLoiManagerEnableCustomLoiEvent *a2@<X1>, uint64_t a3@<X8>)
{
  __int128 *v6;
  __int128 *v7;
  _QWORD *v8;
  NSObject *v10;
  std::string *p_p;
  _OWORD *v12;
  unint64_t v13;
  _OWORD *v14;
  _OWORD *v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  unint64_t v20;
  char *v21;
  NSObject *v22;
  std::string *v23;
  NSObject *v24;
  std::string *v25;
  uint64_t v26;
  char *v27;
  char *v28;
  char *v29;
  char *v30;
  __int128 v31;
  double result;
  std::string __p;
  std::bad_cast v34;
  void *v35;
  void *v36;
  _BYTE buf[28];
  __int128 v38;
  uint64_t v39;

  v39 = *MEMORY[0x24BDAC8D0];
  v6 = (__int128 *)*((_QWORD *)this + 57);
  v7 = (__int128 *)*((_QWORD *)this + 58);
  if (v6 == v7)
  {
LABEL_8:
    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_48);
    v10 = (id)logObject_MicroLocation_Default;
    if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
    {
      memset(&__p, 0, sizeof(__p));
      if ((boost::conversion::detail::try_lexical_convert<std::string,boost::uuids::uuid>((uint64_t)a2 + 32, &__p) & 1) == 0)
      {
        std::bad_cast::bad_cast(&v34);
        v34.__vftable = (std::bad_cast_vtbl *)&unk_2511D2C18;
        boost::throw_exception<boost::bad_lexical_cast>((uint64_t)&v34);
      }
      p_p = &__p;
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      *(_DWORD *)buf = 68289283;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(_QWORD *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2081;
      *(_QWORD *)&buf[20] = p_p;
      _os_log_impl(&dword_2419D9000, v10, OS_LOG_TYPE_INFO, "{\"msg%{public}.0s\":\"LOI Manager, Adding new service to list of servies that have requested to enable custom LOI\", \"LOI ID\":%{private, location:escape_only}s}", buf, 0x1Cu);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__p.__r_.__value_.__l.__data_);
    }

    v12 = (_OWORD *)((char *)a2 + 32);
    v14 = (_OWORD *)*((_QWORD *)this + 58);
    v13 = *((_QWORD *)this + 59);
    if ((unint64_t)v14 >= v13)
    {
      v16 = *((_QWORD *)this + 57);
      v17 = ((uint64_t)v14 - v16) >> 4;
      v18 = v17 + 1;
      if ((unint64_t)(v17 + 1) >> 60)
        std::vector<CLMicroLocationProto::ConfidenceReason>::__throw_length_error[abi:ne180100]();
      v19 = v13 - v16;
      if (v19 >> 3 > v18)
        v18 = v19 >> 3;
      if ((unint64_t)v19 >= 0x7FFFFFFFFFFFFFF0)
        v20 = 0xFFFFFFFFFFFFFFFLL;
      else
        v20 = v18;
      if (v20)
        v21 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<boost::uuids::uuid>>((uint64_t)this + 472, v20);
      else
        v21 = 0;
      v27 = &v21[16 * v17];
      v28 = &v21[16 * v20];
      *(_OWORD *)v27 = *v12;
      v15 = v27 + 16;
      v30 = (char *)*((_QWORD *)this + 57);
      v29 = (char *)*((_QWORD *)this + 58);
      if (v29 != v30)
      {
        do
        {
          *((_OWORD *)v27 - 1) = *((_OWORD *)v29 - 1);
          v27 -= 16;
          v29 -= 16;
        }
        while (v29 != v30);
        v29 = (char *)*((_QWORD *)this + 57);
      }
      *((_QWORD *)this + 57) = v27;
      *((_QWORD *)this + 58) = v15;
      *((_QWORD *)this + 59) = v28;
      if (v29)
        operator delete(v29);
    }
    else
    {
      *v14 = *v12;
      v15 = v14 + 1;
    }
    *((_QWORD *)this + 58) = v15;
    v26 = *((_QWORD *)this + 2);
    if (*(char *)(v26 + 31) < 0)
    {
LABEL_52:
      std::string::__init_copy_ctor_external((std::string *)buf, *(const std::string::value_type **)(v26 + 8), *(_QWORD *)(v26 + 16));
      goto LABEL_53;
    }
  }
  else
  {
    v8 = (_QWORD *)((char *)a2 + 32);
    while (1)
    {
      v38 = *v6;
      if ((_QWORD)v38 == *v8 && *((_QWORD *)&v38 + 1) == *((_QWORD *)a2 + 5))
        break;
      if (++v6 == v7)
        goto LABEL_8;
    }
    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_48);
    v22 = (id)logObject_MicroLocation_Default;
    if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
    {
      memset(&__p, 0, sizeof(__p));
      if ((boost::conversion::detail::try_lexical_convert<std::string,boost::uuids::uuid>((uint64_t)v8, &__p) & 1) == 0)
      {
        std::bad_cast::bad_cast(&v34);
        v34.__vftable = (std::bad_cast_vtbl *)&unk_2511D2C18;
        boost::throw_exception<boost::bad_lexical_cast>((uint64_t)&v34);
      }
      v23 = &__p;
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
        v23 = (std::string *)__p.__r_.__value_.__r.__words[0];
      *(_DWORD *)buf = 68289283;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(_QWORD *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2081;
      *(_QWORD *)&buf[20] = v23;
      _os_log_impl(&dword_2419D9000, v22, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"#LOI Manager, got enable custom LOI request from the same service, ignoring\", \"LOI ID\":%{private, location:escape_only}s}", buf, 0x1Cu);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__p.__r_.__value_.__l.__data_);
    }

    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_48);
    v24 = (id)logObject_MicroLocation_Default;
    if (os_signpost_enabled(v24))
    {
      memset(&__p, 0, sizeof(__p));
      if ((boost::conversion::detail::try_lexical_convert<std::string,boost::uuids::uuid>((uint64_t)v8, &__p) & 1) == 0)
      {
        std::bad_cast::bad_cast(&v34);
        v34.__vftable = (std::bad_cast_vtbl *)&unk_2511D2C18;
        boost::throw_exception<boost::bad_lexical_cast>((uint64_t)&v34);
      }
      v25 = &__p;
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
        v25 = (std::string *)__p.__r_.__value_.__r.__words[0];
      *(_DWORD *)buf = 68289283;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(_QWORD *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2081;
      *(_QWORD *)&buf[20] = v25;
      _os_signpost_emit_with_name_impl(&dword_2419D9000, v24, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "#LOI Manager, got enable custom LOI request from the same service, ignoring", "{\"msg%{public}.0s\":\"#LOI Manager, got enable custom LOI request from the same service, ignoring\", \"LOI ID\":%{private, location:escape_only}s}", buf, 0x1Cu);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__p.__r_.__value_.__l.__data_);
    }

    v26 = *((_QWORD *)this + 2);
    if (*(char *)(v26 + 31) < 0)
      goto LABEL_52;
  }
  v31 = *(_OWORD *)(v26 + 8);
  *(_QWORD *)&buf[16] = *(_QWORD *)(v26 + 24);
  *(_OWORD *)buf = v31;
LABEL_53:
  result = *(double *)buf;
  *(_OWORD *)a3 = *(_OWORD *)buf;
  *(_QWORD *)(a3 + 16) = *(_QWORD *)&buf[16];
  *(_BYTE *)(a3 + 24) = 1;
  return result;
}

void sub_241A6A6A0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, std::exception a15)
{
  void *v15;

  std::exception::~exception(&a15);
  if (a14 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

double CLMicroLocationLoiManager::CustomLoiEntryWhileEnabling@<D0>(id *this@<X0>, const CLMiLoLoiManagerGeofenceEntryEvent *a2@<X1>, uint64_t a3@<X8>)
{
  char *v6;
  std::string *p_p;
  void *v8;
  void *v9;
  NSObject *v10;
  std::string *v11;
  NSObject *v12;
  std::string *v13;
  _OWORD *v14;
  _OWORD *v15;
  uint64_t v16;
  unint64_t v17;
  unint64_t v18;
  NSObject *v20;
  NSObject *v21;
  double result;
  std::string v23;
  std::string __p;
  _BYTE buf[28];
  id v26[3];
  uint64_t v27;

  v27 = *MEMORY[0x24BDAC8D0];
  *(_OWORD *)v26 = *((_OWORD *)a2 + 2);
  if (v26[0] == this[53] && v26[1] == this[54])
  {
    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_48);
    v12 = (id)logObject_MicroLocation_Default;
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      memset(&v23, 0, sizeof(v23));
      if ((boost::conversion::detail::try_lexical_convert<std::string,boost::uuids::uuid>((uint64_t)v26, &v23) & 1) == 0)
      {
        std::bad_cast::bad_cast((std::bad_cast *)&__p);
        __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&unk_2511D2C18;
        boost::throw_exception<boost::bad_lexical_cast>((uint64_t)&__p);
      }
      v13 = &v23;
      if ((v23.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
        v13 = (std::string *)v23.__r_.__value_.__r.__words[0];
      *(_DWORD *)buf = 68289283;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(_QWORD *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2081;
      *(_QWORD *)&buf[20] = v13;
      _os_log_impl(&dword_2419D9000, v12, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"#LOI Manager, got geofence entry for LOI\", \"LOI ID\":%{private, location:escape_only}s}", buf, 0x1Cu);
      if (SHIBYTE(v23.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v23.__r_.__value_.__l.__data_);
    }

    CLMicroLocationLoiManager::sendCustomLoiCreationEvent((CLMicroLocationLoiManager *)this);
    v14 = this[57];
    v15 = this[58];
    while (v14 != v15)
    {
      *(_OWORD *)buf = *v14;
      CLMicroLocationLoiManager::addLoiAndServiceMapping((CLMicroLocationLoiManager *)this, *(uuid *)v26, (const uuid *)buf);
      ++v14;
    }
    v16 = -1;
  }
  else
  {
    v6 = (char *)(this + 53);
    if (*((_BYTE *)this + 424))
    {
LABEL_6:
      memset(&__p, 0, sizeof(__p));
      if ((boost::conversion::detail::try_lexical_convert<std::string,boost::uuids::uuid>((uint64_t)v6, &__p) & 1) == 0)
      {
        std::bad_cast::bad_cast((std::bad_cast *)buf);
        *(_QWORD *)buf = &unk_2511D2C18;
        boost::throw_exception<boost::bad_lexical_cast>((uint64_t)buf);
      }
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        p_p = &__p;
      else
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", p_p);
      v8 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v8, "uppercaseString");
      v9 = (void *)objc_claimAutoreleasedReturnValue();

      if (onceToken_MicroLocation_Default != -1)
        dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_48);
      v10 = logObject_MicroLocation_Default;
      if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT))
      {
        v11 = &__p;
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
          v11 = (std::string *)__p.__r_.__value_.__r.__words[0];
        *(_DWORD *)buf = 68289283;
        *(_DWORD *)&buf[4] = 0;
        *(_WORD *)&buf[8] = 2082;
        *(_QWORD *)&buf[10] = "";
        *(_WORD *)&buf[18] = 2081;
        *(_QWORD *)&buf[20] = v11;
        _os_log_impl(&dword_2419D9000, v10, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"#LOI Manager, Disabling geofence that we were trying to enable for custom LOI since we are failing the request\", \"loiID\":%{private, location:escape_only}s}", buf, 0x1Cu);
      }
      objc_msgSend(this[42], "removeGeofenceWithRegionId:", v9);

      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__p.__r_.__value_.__l.__data_);
    }
    else
    {
      v17 = 0;
      while (v17 != 15)
      {
        v18 = v17;
        if (*((unsigned __int8 *)this + v17++ + 425))
        {
          if (v18 <= 0xE)
            goto LABEL_6;
          break;
        }
      }
    }
    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_48);
    v20 = logObject_MicroLocation_Default;
    if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 68289026;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(_QWORD *)&buf[10] = "";
      _os_log_impl(&dword_2419D9000, v20, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"#LOI Manager, Error: tried to enable custom LOI at an active custom LOI\"}", buf, 0x12u);
    }
    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_48);
    v21 = logObject_MicroLocation_Default;
    if (os_signpost_enabled((os_log_t)logObject_MicroLocation_Default))
    {
      *(_DWORD *)buf = 68289026;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(_QWORD *)&buf[10] = "";
      _os_signpost_emit_with_name_impl(&dword_2419D9000, v21, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "#LOI Manager, Error: tried to enable custom LOI at an active custom LOI", "{\"msg%{public}.0s\":\"#LOI Manager, Error: tried to enable custom LOI at an active custom LOI\"}", buf, 0x12u);
    }
    v16 = 34;
  }
  CLMicroLocationLoiManager::resetLoiVariables((CLMicroLocationLoiManager *)this);
  CLMicroLocationLoiManager::enterCustomLoi((CLMicroLocationLoiManager *)this, (uint64_t)v26[0], (uint64_t)v26[1], 10);
  (**(void (***)(id, uint64_t))this[43])(this[43], v16);
  std::string::basic_string[abi:ne180100]<0>(buf, "In Custom LOI State");
  result = *(double *)buf;
  *(_OWORD *)a3 = *(_OWORD *)buf;
  *(_QWORD *)(a3 + 16) = *(_QWORD *)&buf[16];
  *(_BYTE *)(a3 + 24) = 1;
  return result;
}

void sub_241A6ABC0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, std::exception a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,std::exception a21)
{
  void *v21;

  std::exception::~exception(&a15);
  if (a14 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

double CLMicroLocationLoiManager::LocationUpdate@<D0>(uint64_t a1@<X0>, id *a2@<X1>, uint64_t a3@<X8>)
{
  id v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  NSObject *v11;
  uint64_t v12;
  std::string *v13;
  uint64_t v14;
  __int128 v15;
  NSObject *v16;
  uint64_t v17;
  __int128 v18;
  double result;
  int v20;
  std::string::size_type v21;
  std::string *v22;
  std::string *p_p;
  NSObject *v24;
  uint64_t v25;
  __int128 v26;
  int v27;
  std::string::size_type v28;
  std::string *v29;
  std::string *v30;
  uint64_t v31;
  __int128 v32;
  std::string __p;
  std::string v34;
  _BYTE buf[28];
  __int16 v36;
  std::string *v37;
  uint64_t v38;

  v38 = *MEMORY[0x24BDAC8D0];
  if (*(_BYTE *)(a1 + 506))
  {
    v6 = a2[4];
    objc_msgSend(v6, "coordinate");
    *(_QWORD *)(a1 + 352) = v7;
    objc_msgSend(v6, "coordinate");
    *(_QWORD *)(a1 + 360) = v8;
    objc_msgSend(*(id *)(a1 + 336), "removeGeofencesNearLocationWithLatitude:andLongitude:", *(double *)(a1 + 352));
    objc_msgSend(v6, "horizontalAccuracy");
    *(_QWORD *)(a1 + 368) = v9;
    objc_msgSend(v6, "verticalAccuracy");
    *(_QWORD *)(a1 + 376) = v10;
    *(_QWORD *)(a1 + 424) = 0;
    *(_QWORD *)(a1 + 432) = 0;
    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_48);
    v11 = logObject_MicroLocation_Default;
    if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_DEFAULT))
    {
      v12 = *(_QWORD *)(a1 + 352);
      v13 = *(std::string **)(a1 + 360);
      *(_DWORD *)buf = 68289539;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(_QWORD *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2049;
      *(_QWORD *)&buf[20] = v12;
      v36 = 2049;
      v37 = v13;
      _os_log_impl(&dword_2419D9000, v11, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"#LOI Manager, got location update to enable custom geofence\", \"latitude\":\"%{private}7f\", \"longitude\":\"%{private}7f\"}", buf, 0x26u);
    }
    objc_msgSend(*(id *)(a1 + 336), "setGeofenceAtLocation:", v6);
    *(_WORD *)(a1 + 506) = 256;
    v14 = *(_QWORD *)(a1 + 16);
    if (*(char *)(v14 + 31) < 0)
    {
      std::string::__init_copy_ctor_external((std::string *)buf, *(const std::string::value_type **)(v14 + 8), *(_QWORD *)(v14 + 16));
    }
    else
    {
      v15 = *(_OWORD *)(v14 + 8);
      *(_QWORD *)&buf[16] = *(_QWORD *)(v14 + 24);
      *(_OWORD *)buf = v15;
    }
    *(_OWORD *)a3 = *(_OWORD *)buf;
    *(_QWORD *)(a3 + 16) = *(_QWORD *)&buf[16];
    *(_BYTE *)(a3 + 24) = 1;

  }
  else
  {
    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_48);
    v16 = (id)logObject_MicroLocation_Default;
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
      v17 = *(_QWORD *)(a1 + 16);
      if (*(char *)(v17 + 31) < 0)
      {
        std::string::__init_copy_ctor_external(&v34, *(const std::string::value_type **)(v17 + 8), *(_QWORD *)(v17 + 16));
      }
      else
      {
        v18 = *(_OWORD *)(v17 + 8);
        v34.__r_.__value_.__r.__words[2] = *(_QWORD *)(v17 + 24);
        *(_OWORD *)&v34.__r_.__value_.__l.__data_ = v18;
      }
      v20 = SHIBYTE(v34.__r_.__value_.__r.__words[2]);
      v21 = v34.__r_.__value_.__r.__words[0];
      CLMicroLocationStateMachine::EventBase::getEventName((CLMicroLocationStateMachine::EventBase *)a2, &__p);
      v22 = &v34;
      if (v20 < 0)
        v22 = (std::string *)v21;
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        p_p = &__p;
      else
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      *(_DWORD *)buf = 68289539;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(_QWORD *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2081;
      *(_QWORD *)&buf[20] = v22;
      v36 = 2081;
      v37 = p_p;
      _os_log_impl(&dword_2419D9000, v16, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"LOI Manager, Got event when not expecting it\", \"State\":%{private, location:escape_only}s, \"Event\":%{private, location:escape_only}s}", buf, 0x26u);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__p.__r_.__value_.__l.__data_);
      if (SHIBYTE(v34.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v34.__r_.__value_.__l.__data_);
    }

    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_48);
    v24 = (id)logObject_MicroLocation_Default;
    if (os_signpost_enabled(v24))
    {
      v25 = *(_QWORD *)(a1 + 16);
      if (*(char *)(v25 + 31) < 0)
      {
        std::string::__init_copy_ctor_external(&v34, *(const std::string::value_type **)(v25 + 8), *(_QWORD *)(v25 + 16));
      }
      else
      {
        v26 = *(_OWORD *)(v25 + 8);
        v34.__r_.__value_.__r.__words[2] = *(_QWORD *)(v25 + 24);
        *(_OWORD *)&v34.__r_.__value_.__l.__data_ = v26;
      }
      v27 = SHIBYTE(v34.__r_.__value_.__r.__words[2]);
      v28 = v34.__r_.__value_.__r.__words[0];
      CLMicroLocationStateMachine::EventBase::getEventName((CLMicroLocationStateMachine::EventBase *)a2, &__p);
      v29 = &v34;
      if (v27 < 0)
        v29 = (std::string *)v28;
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v30 = &__p;
      else
        v30 = (std::string *)__p.__r_.__value_.__r.__words[0];
      *(_DWORD *)buf = 68289539;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(_QWORD *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2081;
      *(_QWORD *)&buf[20] = v29;
      v36 = 2081;
      v37 = v30;
      _os_signpost_emit_with_name_impl(&dword_2419D9000, v24, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "LOI Manager, Got event when not expecting it", "{\"msg%{public}.0s\":\"LOI Manager, Got event when not expecting it\", \"State\":%{private, location:escape_only}s, \"Event\":%{private, location:escape_only}s}", buf, 0x26u);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__p.__r_.__value_.__l.__data_);
      if (SHIBYTE(v34.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v34.__r_.__value_.__l.__data_);
    }

    v31 = *(_QWORD *)(a1 + 16);
    if (*(char *)(v31 + 31) < 0)
    {
      std::string::__init_copy_ctor_external((std::string *)buf, *(const std::string::value_type **)(v31 + 8), *(_QWORD *)(v31 + 16));
    }
    else
    {
      v32 = *(_OWORD *)(v31 + 8);
      *(_QWORD *)&buf[16] = *(_QWORD *)(v31 + 24);
      *(_OWORD *)buf = v32;
    }
    result = *(double *)buf;
    *(_OWORD *)a3 = *(_OWORD *)buf;
    *(_QWORD *)(a3 + 16) = *(_QWORD *)&buf[16];
    *(_BYTE *)(a3 + 24) = 1;
  }
  return result;
}

void sub_241A6B098(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  void *v18;

  _Unwind_Resume(a1);
}

double CLMicroLocationLoiManager::FailureToGetLocationUpdate@<D0>(CLMicroLocationLoiManager *this@<X0>, const CLMiLoLoiManagerFailedToGetLocationUpdateEvent *a2@<X1>, uint64_t a3@<X8>)
{
  NSObject *v6;
  NSObject *v7;
  NSObject *v8;
  uint64_t v9;
  __int128 v10;
  int v11;
  std::string::size_type v12;
  std::string *v13;
  std::string *p_p;
  NSObject *v15;
  uint64_t v16;
  __int128 v17;
  int v18;
  std::string::size_type v19;
  std::string *v20;
  std::string *v21;
  uint64_t v22;
  __int128 v23;
  double result;
  std::string __p;
  std::string v26;
  _BYTE buf[28];
  __int16 v28;
  std::string *v29;
  uint64_t v30;

  v30 = *MEMORY[0x24BDAC8D0];
  if (onceToken_MicroLocation_Default != -1)
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_48);
  v6 = logObject_MicroLocation_Default;
  if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 68289026;
    *(_DWORD *)&buf[4] = 0;
    *(_WORD *)&buf[8] = 2082;
    *(_QWORD *)&buf[10] = "";
    _os_log_impl(&dword_2419D9000, v6, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"#LOI Manager, failed to get current location to enable MiLo... aborting request\"}", buf, 0x12u);
  }
  if (onceToken_MicroLocation_Default != -1)
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_48);
  v7 = logObject_MicroLocation_Default;
  if (os_signpost_enabled((os_log_t)logObject_MicroLocation_Default))
  {
    *(_DWORD *)buf = 68289026;
    *(_DWORD *)&buf[4] = 0;
    *(_WORD *)&buf[8] = 2082;
    *(_QWORD *)&buf[10] = "";
    _os_signpost_emit_with_name_impl(&dword_2419D9000, v7, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "#LOI Manager, failed to get current location to enable MiLo... aborting request", "{\"msg%{public}.0s\":\"#LOI Manager, failed to get current location to enable MiLo... aborting request\"}", buf, 0x12u);
  }
  if (*((_BYTE *)this + 506))
  {
    CLMicroLocationLoiManager::sendLoiRelatedErrorEvent(this, CFSTR("Custom LOI Entry Failure"), CFSTR("Failed to get current Location"));
    (***((void (****)(_QWORD, uint64_t))this + 43))(*((_QWORD *)this + 43), 34);
    CLMicroLocationLoiManager::resetLoiVariables(this);
    std::string::basic_string[abi:ne180100]<0>(buf, "Not in Active Location State");
  }
  else
  {
    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_48);
    v8 = (id)logObject_MicroLocation_Default;
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      v9 = *((_QWORD *)this + 2);
      if (*(char *)(v9 + 31) < 0)
      {
        std::string::__init_copy_ctor_external(&v26, *(const std::string::value_type **)(v9 + 8), *(_QWORD *)(v9 + 16));
      }
      else
      {
        v10 = *(_OWORD *)(v9 + 8);
        v26.__r_.__value_.__r.__words[2] = *(_QWORD *)(v9 + 24);
        *(_OWORD *)&v26.__r_.__value_.__l.__data_ = v10;
      }
      v11 = SHIBYTE(v26.__r_.__value_.__r.__words[2]);
      v12 = v26.__r_.__value_.__r.__words[0];
      CLMicroLocationStateMachine::EventBase::getEventName(a2, &__p);
      v13 = &v26;
      if (v11 < 0)
        v13 = (std::string *)v12;
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        p_p = &__p;
      else
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      *(_DWORD *)buf = 68289539;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(_QWORD *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2081;
      *(_QWORD *)&buf[20] = v13;
      v28 = 2081;
      v29 = p_p;
      _os_log_impl(&dword_2419D9000, v8, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"LOI Manager, Got event when not expecting it\", \"State\":%{private, location:escape_only}s, \"Event\":%{private, location:escape_only}s}", buf, 0x26u);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__p.__r_.__value_.__l.__data_);
      if (SHIBYTE(v26.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v26.__r_.__value_.__l.__data_);
    }

    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_48);
    v15 = (id)logObject_MicroLocation_Default;
    if (os_signpost_enabled(v15))
    {
      v16 = *((_QWORD *)this + 2);
      if (*(char *)(v16 + 31) < 0)
      {
        std::string::__init_copy_ctor_external(&v26, *(const std::string::value_type **)(v16 + 8), *(_QWORD *)(v16 + 16));
      }
      else
      {
        v17 = *(_OWORD *)(v16 + 8);
        v26.__r_.__value_.__r.__words[2] = *(_QWORD *)(v16 + 24);
        *(_OWORD *)&v26.__r_.__value_.__l.__data_ = v17;
      }
      v18 = SHIBYTE(v26.__r_.__value_.__r.__words[2]);
      v19 = v26.__r_.__value_.__r.__words[0];
      CLMicroLocationStateMachine::EventBase::getEventName(a2, &__p);
      v20 = &v26;
      if (v18 < 0)
        v20 = (std::string *)v19;
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v21 = &__p;
      else
        v21 = (std::string *)__p.__r_.__value_.__r.__words[0];
      *(_DWORD *)buf = 68289539;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(_QWORD *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2081;
      *(_QWORD *)&buf[20] = v20;
      v28 = 2081;
      v29 = v21;
      _os_signpost_emit_with_name_impl(&dword_2419D9000, v15, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "LOI Manager, Got event when not expecting it", "{\"msg%{public}.0s\":\"LOI Manager, Got event when not expecting it\", \"State\":%{private, location:escape_only}s, \"Event\":%{private, location:escape_only}s}", buf, 0x26u);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__p.__r_.__value_.__l.__data_);
      if (SHIBYTE(v26.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v26.__r_.__value_.__l.__data_);
    }

    v22 = *((_QWORD *)this + 2);
    if (*(char *)(v22 + 31) < 0)
    {
      std::string::__init_copy_ctor_external((std::string *)buf, *(const std::string::value_type **)(v22 + 8), *(_QWORD *)(v22 + 16));
    }
    else
    {
      v23 = *(_OWORD *)(v22 + 8);
      *(_QWORD *)&buf[16] = *(_QWORD *)(v22 + 24);
      *(_OWORD *)buf = v23;
    }
  }
  result = *(double *)buf;
  *(_OWORD *)a3 = *(_OWORD *)buf;
  *(_QWORD *)(a3 + 16) = *(_QWORD *)&buf[16];
  *(_BYTE *)(a3 + 24) = 1;
  return result;
}

void sub_241A6B54C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  void *v18;

  _Unwind_Resume(a1);
}

double CLMicroLocationLoiManager::GeofenceActivationStarted@<D0>(CLMicroLocationLoiManager *this@<X0>, const CLMiLoLoiManagerStartedActivatingGeofenceEvent *a2@<X1>, uint64_t a3@<X8>)
{
  NSObject *v6;
  std::string *v7;
  uint64_t v8;
  NSObject *v9;
  uint64_t v10;
  __int128 v11;
  int v12;
  std::string::size_type v13;
  std::string *v14;
  std::string *p_p;
  NSObject *v16;
  uint64_t v17;
  __int128 v18;
  int v19;
  std::string::size_type v20;
  std::string *v21;
  std::string *v22;
  __int128 v23;
  double result;
  std::string __p;
  std::string v26;
  _BYTE buf[28];
  __int16 v28;
  std::string *v29;
  uint64_t v30;

  v30 = *MEMORY[0x24BDAC8D0];
  if (!*((_BYTE *)this + 507))
  {
    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_48);
    v9 = (id)logObject_MicroLocation_Default;
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      v10 = *((_QWORD *)this + 2);
      if (*(char *)(v10 + 31) < 0)
      {
        std::string::__init_copy_ctor_external(&v26, *(const std::string::value_type **)(v10 + 8), *(_QWORD *)(v10 + 16));
      }
      else
      {
        v11 = *(_OWORD *)(v10 + 8);
        v26.__r_.__value_.__r.__words[2] = *(_QWORD *)(v10 + 24);
        *(_OWORD *)&v26.__r_.__value_.__l.__data_ = v11;
      }
      v12 = SHIBYTE(v26.__r_.__value_.__r.__words[2]);
      v13 = v26.__r_.__value_.__r.__words[0];
      CLMicroLocationStateMachine::EventBase::getEventName(a2, &__p);
      v14 = &v26;
      if (v12 < 0)
        v14 = (std::string *)v13;
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        p_p = &__p;
      else
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      *(_DWORD *)buf = 68289539;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(_QWORD *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2081;
      *(_QWORD *)&buf[20] = v14;
      v28 = 2081;
      v29 = p_p;
      _os_log_impl(&dword_2419D9000, v9, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"LOI Manager, Got event when not expecting it\", \"State\":%{private, location:escape_only}s, \"Event\":%{private, location:escape_only}s}", buf, 0x26u);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__p.__r_.__value_.__l.__data_);
      if (SHIBYTE(v26.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v26.__r_.__value_.__l.__data_);
    }

    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_48);
    v16 = (id)logObject_MicroLocation_Default;
    if (os_signpost_enabled(v16))
    {
      v17 = *((_QWORD *)this + 2);
      if (*(char *)(v17 + 31) < 0)
      {
        std::string::__init_copy_ctor_external(&v26, *(const std::string::value_type **)(v17 + 8), *(_QWORD *)(v17 + 16));
      }
      else
      {
        v18 = *(_OWORD *)(v17 + 8);
        v26.__r_.__value_.__r.__words[2] = *(_QWORD *)(v17 + 24);
        *(_OWORD *)&v26.__r_.__value_.__l.__data_ = v18;
      }
      v19 = SHIBYTE(v26.__r_.__value_.__r.__words[2]);
      v20 = v26.__r_.__value_.__r.__words[0];
      CLMicroLocationStateMachine::EventBase::getEventName(a2, &__p);
      v21 = &v26;
      if (v19 < 0)
        v21 = (std::string *)v20;
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v22 = &__p;
      else
        v22 = (std::string *)__p.__r_.__value_.__r.__words[0];
      *(_DWORD *)buf = 68289539;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(_QWORD *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2081;
      *(_QWORD *)&buf[20] = v21;
      v28 = 2081;
      v29 = v22;
      _os_signpost_emit_with_name_impl(&dword_2419D9000, v16, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "LOI Manager, Got event when not expecting it", "{\"msg%{public}.0s\":\"LOI Manager, Got event when not expecting it\", \"State\":%{private, location:escape_only}s, \"Event\":%{private, location:escape_only}s}", buf, 0x26u);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__p.__r_.__value_.__l.__data_);
      if (SHIBYTE(v26.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v26.__r_.__value_.__l.__data_);
    }

    v8 = *((_QWORD *)this + 2);
    if (*(char *)(v8 + 31) < 0)
      goto LABEL_11;
LABEL_43:
    v23 = *(_OWORD *)(v8 + 8);
    *(_QWORD *)&buf[16] = *(_QWORD *)(v8 + 24);
    *(_OWORD *)buf = v23;
    goto LABEL_44;
  }
  *(_OWORD *)((char *)this + 424) = *((_OWORD *)a2 + 2);
  if (onceToken_MicroLocation_Default != -1)
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_48);
  v6 = (id)logObject_MicroLocation_Default;
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    memset(&__p, 0, sizeof(__p));
    if ((boost::conversion::detail::try_lexical_convert<std::string,boost::uuids::uuid>((uint64_t)this + 424, &__p) & 1) == 0)
    {
      std::bad_cast::bad_cast((std::bad_cast *)&v26);
      v26.__r_.__value_.__r.__words[0] = (std::string::size_type)&unk_2511D2C18;
      boost::throw_exception<boost::bad_lexical_cast>((uint64_t)&v26);
    }
    v7 = &__p;
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
      v7 = (std::string *)__p.__r_.__value_.__r.__words[0];
    *(_DWORD *)buf = 68289283;
    *(_DWORD *)&buf[4] = 0;
    *(_WORD *)&buf[8] = 2082;
    *(_QWORD *)&buf[10] = "";
    *(_WORD *)&buf[18] = 2081;
    *(_QWORD *)&buf[20] = v7;
    _os_log_impl(&dword_2419D9000, v6, OS_LOG_TYPE_DEFAULT, "{\"msg%{public}.0s\":\"#LOI Manager, successfully set geofence, now waiting on fence entry update\", \"geofenceId\":%{private, location:escape_only}s}", buf, 0x1Cu);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p.__r_.__value_.__l.__data_);
  }

  v8 = *((_QWORD *)this + 2);
  if ((*(char *)(v8 + 31) & 0x80000000) == 0)
    goto LABEL_43;
LABEL_11:
  std::string::__init_copy_ctor_external((std::string *)buf, *(const std::string::value_type **)(v8 + 8), *(_QWORD *)(v8 + 16));
LABEL_44:
  result = *(double *)buf;
  *(_OWORD *)a3 = *(_OWORD *)buf;
  *(_QWORD *)(a3 + 16) = *(_QWORD *)&buf[16];
  *(_BYTE *)(a3 + 24) = 1;
  return result;
}

void sub_241A6B9D0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  void *v21;

  _Unwind_Resume(a1);
}

double CLMicroLocationLoiManager::FailureToActivateGeofenceAtCurrentLocation@<D0>(CLMicroLocationLoiManager *this@<X0>, const CLMiLoLoiManagerFailedToSetGeofenceEvent *a2@<X1>, uint64_t a3@<X8>)
{
  NSObject *v6;
  NSObject *v7;
  NSObject *v8;
  uint64_t v9;
  __int128 v10;
  int v11;
  std::string::size_type v12;
  std::string *v13;
  std::string *p_p;
  NSObject *v15;
  uint64_t v16;
  __int128 v17;
  int v18;
  std::string::size_type v19;
  std::string *v20;
  std::string *v21;
  uint64_t v22;
  __int128 v23;
  double result;
  std::string __p;
  std::string v26;
  _BYTE buf[28];
  __int16 v28;
  std::string *v29;
  uint64_t v30;

  v30 = *MEMORY[0x24BDAC8D0];
  if (onceToken_MicroLocation_Default != -1)
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_48);
  v6 = logObject_MicroLocation_Default;
  if (os_log_type_enabled((os_log_t)logObject_MicroLocation_Default, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 68289026;
    *(_DWORD *)&buf[4] = 0;
    *(_WORD *)&buf[8] = 2082;
    *(_QWORD *)&buf[10] = "";
    _os_log_impl(&dword_2419D9000, v6, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"#LOI Manager, failed to set geofence at current location to enable MiLo, failing custom loi request\"}", buf, 0x12u);
  }
  if (onceToken_MicroLocation_Default != -1)
    dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_48);
  v7 = logObject_MicroLocation_Default;
  if (os_signpost_enabled((os_log_t)logObject_MicroLocation_Default))
  {
    *(_DWORD *)buf = 68289026;
    *(_DWORD *)&buf[4] = 0;
    *(_WORD *)&buf[8] = 2082;
    *(_QWORD *)&buf[10] = "";
    _os_signpost_emit_with_name_impl(&dword_2419D9000, v7, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "#LOI Manager, failed to set geofence at current location to enable MiLo, failing custom loi request", "{\"msg%{public}.0s\":\"#LOI Manager, failed to set geofence at current location to enable MiLo, failing custom loi request\"}", buf, 0x12u);
  }
  if (*((_BYTE *)this + 507))
  {
    CLMicroLocationLoiManager::sendLoiRelatedErrorEvent(this, CFSTR("Custom LOI Entry Failure"), CFSTR("Failed to set geofence"));
    (***((void (****)(_QWORD, uint64_t))this + 43))(*((_QWORD *)this + 43), 34);
    CLMicroLocationLoiManager::resetLoiVariables(this);
    std::string::basic_string[abi:ne180100]<0>(buf, "Not in Active Location State");
  }
  else
  {
    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_48);
    v8 = (id)logObject_MicroLocation_Default;
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      v9 = *((_QWORD *)this + 2);
      if (*(char *)(v9 + 31) < 0)
      {
        std::string::__init_copy_ctor_external(&v26, *(const std::string::value_type **)(v9 + 8), *(_QWORD *)(v9 + 16));
      }
      else
      {
        v10 = *(_OWORD *)(v9 + 8);
        v26.__r_.__value_.__r.__words[2] = *(_QWORD *)(v9 + 24);
        *(_OWORD *)&v26.__r_.__value_.__l.__data_ = v10;
      }
      v11 = SHIBYTE(v26.__r_.__value_.__r.__words[2]);
      v12 = v26.__r_.__value_.__r.__words[0];
      CLMicroLocationStateMachine::EventBase::getEventName(a2, &__p);
      v13 = &v26;
      if (v11 < 0)
        v13 = (std::string *)v12;
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        p_p = &__p;
      else
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      *(_DWORD *)buf = 68289539;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(_QWORD *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2081;
      *(_QWORD *)&buf[20] = v13;
      v28 = 2081;
      v29 = p_p;
      _os_log_impl(&dword_2419D9000, v8, OS_LOG_TYPE_ERROR, "{\"msg%{public}.0s\":\"LOI Manager, Got event when not expecting it\", \"State\":%{private, location:escape_only}s, \"Event\":%{private, location:escape_only}s}", buf, 0x26u);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__p.__r_.__value_.__l.__data_);
      if (SHIBYTE(v26.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v26.__r_.__value_.__l.__data_);
    }

    if (onceToken_MicroLocation_Default != -1)
      dispatch_once(&onceToken_MicroLocation_Default, &__block_literal_global_48);
    v15 = (id)logObject_MicroLocation_Default;
    if (os_signpost_enabled(v15))
    {
      v16 = *((_QWORD *)this + 2);
      if (*(char *)(v16 + 31) < 0)
      {
        std::string::__init_copy_ctor_external(&v26, *(const std::string::value_type **)(v16 + 8), *(_QWORD *)(v16 + 16));
      }
      else
      {
        v17 = *(_OWORD *)(v16 + 8);
        v26.__r_.__value_.__r.__words[2] = *(_QWORD *)(v16 + 24);
        *(_OWORD *)&v26.__r_.__value_.__l.__data_ = v17;
      }
      v18 = SHIBYTE(v26.__r_.__value_.__r.__words[2]);
      v19 = v26.__r_.__value_.__r.__words[0];
      CLMicroLocationStateMachine::EventBase::getEventName(a2, &__p);
      v20 = &v26;
      if (v18 < 0)
        v20 = (std::string *)v19;
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v21 = &__p;
      else
        v21 = (std::string *)__p.__r_.__value_.__r.__words[0];
      *(_DWORD *)buf = 68289539;
      *(_DWORD *)&buf[4] = 0;
      *(_WORD *)&buf[8] = 2082;
      *(_QWORD *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2081;
      *(_QWORD *)&buf[20] = v20;
      v28 = 2081;
      v29 = v21;
      _os_signpost_emit_with_name_impl(&dword_2419D9000, v15, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "LOI Manager, Got event when not expecting it", "{\"msg%{public}.0s\":\"LOI Manager, Got event when not expecting it\", \"State\":%{private, location:escape_only}s, \"Event\":%{private, location:escape_only}s}", buf, 0x26u);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__p.__r_.__value_.__l.__data_);
      if (SHIBYTE(v26.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v26.__r_.__value_.__l.__data_);
    }

    v22 = *((_QWORD *)this + 2);
    if (*(char *)(v22 + 31) < 0)
    {
      std::string::__init_copy_ctor_external((std::string *)buf, *(const std::string::value_type **)(v22 + 8), *(_QWORD *)(v22 + 16));
    }
    else
    {
      v23 = *(_OWORD *)(v22 + 8);
      *(_QWORD *)&buf[16] = *(_QWORD *)(v22 + 24);
      *(_OWORD *)buf = v23;
    }
  }
  result = *(double *)buf;
  *(_OWORD *)a3 = *(_OWORD *)buf;
  *(_QWORD *)(a3 + 16) = *(_QWORD *)&buf[16];
  *(_BYTE *)(a3 + 24) = 1;
  return result;
}

void sub_241A6BE98(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  void *v18;

  _Unwind_Resume(a1);
}

double CLMicroLocationLoiManager::EnteringCustomLoiTimeoutHandler@<D0>(CLMicroLocationLoiManager *this@<X0>, uint64_t a2@<X8>)
{
  double result;
  __int128 v6;
  uint64_t v7;

  CLMicroLocationLoiManager::sendLoiRelatedErrorEvent(this, CFSTR("Custom LOI Entry Failure"), CFSTR("Custom LOI Entry Timeout"));
  (***((void (****)(_QWORD, uint64_t))this + 43))(*((_QWORD *)this + 43), 34);
  CLMicroLocationLoiManager::resetLoiVariables(this);
  std::string::basic_string[abi:ne180100]<0>(&v6, "Not in Active Location State");
  result = *(double *)&v6;
  *(_OWORD *)a2 = v6;
  *(_QWORD *)(a2 + 16) = v7;
  *(_BYTE *)(a2 + 24) = 1;
  return result;
}

void CLMicroLocationLoiManager::setupWhenNotInAnActiveLocationState(CLMicroLocationLoiManager *this)
{
  uint64_t **v2;
  uint64_t v3;
  uint64_t **v4;
  void *v5[2];
  char v6;
  void *__p[2];
  char v8;
  void **v9;

  v2 = (uint64_t **)operator new();
  CLMicroLocationStateMachine::StateBase::StateBase((CLMicroLocationStateMachine::StateBase *)v2, 0);
  MEMORY[0x2426A02C4](v2 + 1, "Not in Active Location State");
  std::string::basic_string[abi:ne180100]<0>(__p, "LOI Visit Entry");
  v9 = __p;
  *((_QWORD *)std::__tree<std::__value_type<std::string,CLMicroLocationStateMachine::EventHandlerWrapperBase *>,std::__map_value_compare<std::string,std::__value_type<std::string,CLMicroLocationStateMachine::EventHandlerWrapperBase *>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,CLMicroLocationStateMachine::EventHandlerWrapperBase *>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(v2 + 6, (const void **)__p, (uint64_t)&std::piecewise_construct, (_OWORD **)&v9)+ 7) = (char *)this + 64;
  if (v8 < 0)
    operator delete(__p[0]);
  std::string::basic_string[abi:ne180100]<0>(__p, "Enable Custom LOI");
  v9 = __p;
  *((_QWORD *)std::__tree<std::__value_type<std::string,CLMicroLocationStateMachine::EventHandlerWrapperBase *>,std::__map_value_compare<std::string,std::__value_type<std::string,CLMicroLocationStateMachine::EventHandlerWrapperBase *>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,CLMicroLocationStateMachine::EventHandlerWrapperBase *>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(v2 + 6, (const void **)__p, (uint64_t)&std::piecewise_construct, (_OWORD **)&v9)+ 7) = (char *)this + 72;
  if (v8 < 0)
    operator delete(__p[0]);
  std::string::basic_string[abi:ne180100]<0>(__p, "Disable Custom LOI");
  v9 = __p;
  *((_QWORD *)std::__tree<std::__value_type<std::string,CLMicroLocationStateMachine::EventHandlerWrapperBase *>,std::__map_value_compare<std::string,std::__value_type<std::string,CLMicroLocationStateMachine::EventHandlerWrapperBase *>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,CLMicroLocationStateMachine::EventHandlerWrapperBase *>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(v2 + 6, (const void **)__p, (uint64_t)&std::piecewise_construct, (_OWORD **)&v9)+ 7) = (char *)this + 80;
  if (v8 < 0)
    operator delete(__p[0]);
  std::string::basic_string[abi:ne180100]<0>(__p, "Geofence Entry");
  v9 = __p;
  *((_QWORD *)std::__tree<std::__value_type<std::string,CLMicroLocationStateMachine::EventHandlerWrapperBase *>,std::__map_value_compare<std::string,std::__value_type<std::string,CLMicroLocationStateMachine::EventHandlerWrapperBase *>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,CLMicroLocationStateMachine::EventHandlerWrapperBase *>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(v2 + 6, (const void **)__p, (uint64_t)&std::piecewise_construct, (_OWORD **)&v9)+ 7) = (char *)this + 88;
  if (v8 < 0)
    operator delete(__p[0]);
  std::string::basic_string[abi:ne180100]<0>(__p, "Fetch Place Inference For Reason");
  v9 = __p;
  *((_QWORD *)std::__tree<std::__value_type<std::string,CLMicroLocationStateMachine::EventHandlerWrapperBase *>,std::__map_value_compare<std::string,std::__value_type<std::string,CLMicroLocationStateMachine::EventHandlerWrapperBase *>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,CLMicroLocationStateMachine::EventHandlerWrapperBase *>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(v2 + 6, (const void **)__p, (uint64_t)&std::piecewise_construct, (_OWORD **)&v9)+ 7) = (char *)this + 112;
  if (v8 < 0)
    operator delete(__p[0]);
  std::string::basic_string[abi:ne180100]<0>(__p, "Leeched Location Update");
  v9 = __p;
  *((_QWORD *)std::__tree<std::__value_type<std::string,CLMicroLocationStateMachine::EventHandlerWrapperBase *>,std::__map_value_compare<std::string,std::__value_type<std::string,CLMicroLocationStateMachine::EventHandlerWrapperBase *>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,CLMicroLocationStateMachine::EventHandlerWrapperBase *>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(v2 + 6, (const void **)__p, (uint64_t)&std::piecewise_construct, (_OWORD **)&v9)+ 7) = (char *)this + 96;
  if (v8 < 0)
    operator delete(__p[0]);
  std::string::basic_string[abi:ne180100]<0>(__p, "Refresh Location on regular interval");
  v9 = __p;
  *((_QWORD *)std::__tree<std::__value_type<std::string,CLMicroLocationStateMachine::EventHandlerWrapperBase *>,std::__map_value_compare<std::string,std::__value_type<std::string,CLMicroLocationStateMachine::EventHandlerWrapperBase *>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,CLMicroLocationStateMachine::EventHandlerWrapperBase *>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(v2 + 6, (const void **)__p, (uint64_t)&std::piecewise_construct, (_OWORD **)&v9)+ 7) = (char *)this + 104;
  if (v8 < 0)
    operator delete(__p[0]);
  std::string::basic_string[abi:ne180100]<0>(v5, "Not in Active Location State");
  v4 = v2;
  CLMicroLocationStateMachine::StateMachineBase::addStateToStateMap((uint64_t)this + 8, (__int128 *)v5, (uint64_t *)&v4);
  v3 = (uint64_t)v4;
  v4 = 0;
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  if (v6 < 0)
    operator delete(v5[0]);
}

void sub_241A6C218(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  if (a10)
    (*(void (**)(uint64_t))(*(_QWORD *)a10 + 8))(a10);
  if (a16 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void CLMicroLocationLoiManager::setupWhenInAHomeLoiState(CLMicroLocationLoiManager *this)
{
  uint64_t **v2;
  uint64_t v3;
  uint64_t **v4;
  void *v5[2];
  char v6;
  void *__p[2];
  char v8;
  void **v9;

  v2 = (uint64_t **)operator new();
  CLMicroLocationStateMachine::StateBase::StateBase((CLMicroLocationStateMachine::StateBase *)v2, 0);
  MEMORY[0x2426A02C4](v2 + 1, "In Home LOI State");
  std::string::basic_string[abi:ne180100]<0>(__p, "LOI Visit Entry");
  v9 = __p;
  *((_QWORD *)std::__tree<std::__value_type<std::string,CLMicroLocationStateMachine::EventHandlerWrapperBase *>,std::__map_value_compare<std::string,std::__value_type<std::string,CLMicroLocationStateMachine::EventHandlerWrapperBase *>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,CLMicroLocationStateMachine::EventHandlerWrapperBase *>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(v2 + 6, (const void **)__p, (uint64_t)&std::piecewise_construct, (_OWORD **)&v9)+ 7) = (char *)this + 64;
  if (v8 < 0)
    operator delete(__p[0]);
  std::string::basic_string[abi:ne180100]<0>(__p, "LOI Visit Exit");
  v9 = __p;
  *((_QWORD *)std::__tree<std::__value_type<std::string,CLMicroLocationStateMachine::EventHandlerWrapperBase *>,std::__map_value_compare<std::string,std::__value_type<std::string,CLMicroLocationStateMachine::EventHandlerWrapperBase *>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,CLMicroLocationStateMachine::EventHandlerWrapperBase *>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(v2 + 6, (const void **)__p, (uint64_t)&std::piecewise_construct, (_OWORD **)&v9)+ 7) = (char *)this + 120;
  if (v8 < 0)
    operator delete(__p[0]);
  std::string::basic_string[abi:ne180100]<0>(__p, "Enable Custom LOI");
  v9 = __p;
  *((_QWORD *)std::__tree<std::__value_type<std::string,CLMicroLocationStateMachine::EventHandlerWrapperBase *>,std::__map_value_compare<std::string,std::__value_type<std::string,CLMicroLocationStateMachine::EventHandlerWrapperBase *>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,CLMicroLocationStateMachine::EventHandlerWrapperBase *>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(v2 + 6, (const void **)__p, (uint64_t)&std::piecewise_construct, (_OWORD **)&v9)+ 7) = (char *)this + 128;
  if (v8 < 0)
    operator delete(__p[0]);
  std::string::basic_string[abi:ne180100]<0>(__p, "Disable Custom LOI");
  v9 = __p;
  *((_QWORD *)std::__tree<std::__value_type<std::string,CLMicroLocationStateMachine::EventHandlerWrapperBase *>,std::__map_value_compare<std::string,std::__value_type<std::string,CLMicroLocationStateMachine::EventHandlerWrapperBase *>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,CLMicroLocationStateMachine::EventHandlerWrapperBase *>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(v2 + 6, (const void **)__p, (uint64_t)&std::piecewise_construct, (_OWORD **)&v9)+ 7) = (char *)this + 80;
  if (v8 < 0)
    operator delete(__p[0]);
  std::string::basic_string[abi:ne180100]<0>(__p, "Geofence Entry");
  v9 = __p;
  *((_QWORD *)std::__tree<std::__value_type<std::string,CLMicroLocationStateMachine::EventHandlerWrapperBase *>,std::__map_value_compare<std::string,std::__value_type<std::string,CLMicroLocationStateMachine::EventHandlerWrapperBase *>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,CLMicroLocationStateMachine::EventHandlerWrapperBase *>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(v2 + 6, (const void **)__p, (uint64_t)&std::piecewise_construct, (_OWORD **)&v9)+ 7) = (char *)this + 136;
  if (v8 < 0)
    operator delete(__p[0]);
  std::string::basic_string[abi:ne180100]<0>(__p, "Fetch Place Inference For Reason");
  v9 = __p;
  *((_QWORD *)std::__tree<std::__value_type<std::string,CLMicroLocationStateMachine::EventHandlerWrapperBase *>,std::__map_value_compare<std::string,std::__value_type<std::string,CLMicroLocationStateMachine::EventHandlerWrapperBase *>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,CLMicroLocationStateMachine::EventHandlerWrapperBase *>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(v2 + 6, (const void **)__p, (uint64_t)&std::piecewise_construct, (_OWORD **)&v9)+ 7) = (char *)this + 144;
  if (v8 < 0)
    operator delete(__p[0]);
  std::string::basic_string[abi:ne180100]<0>(__p, "Refresh Location on regular interval");
  v9 = __p;
  *((_QWORD *)std::__tree<std::__value_type<std::string,CLMicroLocationStateMachine::EventHandlerWrapperBase *>,std::__map_value_compare<std::string,std::__value_type<std::string,CLMicroLocationStateMachine::EventHandlerWrapperBase *>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,CLMicroLocationStateMachine::EventHandlerWrapperBase *>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(v2 + 6, (const void **)__p, (uint64_t)&std::piecewise_construct, (_OWORD **)&v9)+ 7) = (char *)this + 104;
  if (v8 < 0)
    operator delete(__p[0]);
  std::string::basic_string[abi:ne180100]<0>(v5, "In Home LOI State");
  v4 = v2;
  CLMicroLocationStateMachine::StateMachineBase::addStateToStateMap((uint64_t)this + 8, (__int128 *)v5, (uint64_t *)&v4);
  v3 = (uint64_t)v4;
  v4 = 0;
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  if (v6 < 0)
    operator delete(v5[0]);
}

