uint64_t PKPhysicsShape::createAsCircle(PKPhysicsShape *this, float a2, const CGPoint *a3)
{
  uint64_t v6;
  double x;
  float v8;
  double y;
  float v10;
  uint64_t result;

  v6 = operator new();
  *(_QWORD *)(v6 + 8) = 0;
  *(_QWORD *)(v6 + 16) = 0;
  *(_QWORD *)v6 = &off_24C0E8038;
  *(float *)(v6 + 12) = PKGet_INV_PTM_RATIO() * a2;
  x = a3->x;
  v8 = x * PKGet_INV_PTM_RATIO();
  *(float *)(v6 + 16) = v8;
  y = a3->y;
  v10 = y * PKGet_INV_PTM_RATIO();
  *(float *)(v6 + 20) = v10;
  result = b2CircleShape::isValidShape((b2CircleShape *)v6);
  if ((result & 1) == 0)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v6 + 8))(v6);
  this->var0.var0 = (b2Shape *)v6;
  return result;
}

id valueWithCGPoint(CGPoint a1)
{
  CGPoint v2;

  v2 = a1;
  objc_msgSend(MEMORY[0x24BDD1968], "valueWithBytes:objCType:", &v2, "{CGPoint=dd}");
  return (id)objc_claimAutoreleasedReturnValue();
}

void sub_208F98A54(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

uint64_t b2ChainShape::GetVertex(b2ChainShape *this, int a2)
{
  uint64_t v2;

  if (a2 < 0 || (v2 = *((_QWORD *)this + 2), (int)((unint64_t)(*((_QWORD *)this + 3) - v2) >> 3) <= a2))
    b2ChainShape::GetVertex();
  return v2 + 8 * a2;
}

_QWORD *QuadTree::visitLeaves(_BYTE **a1, uint64_t a2)
{
  _BYTE *v2;
  _QWORD *result;
  uint64_t v4;
  _BYTE v5[24];
  _BYTE *v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v2 = *a1;
  std::__function::__value_func<void ()(float,float,int)>::__value_func[abi:ne180100]((uint64_t)v5, a2);
  QuadTreeNode::visitLeaves(v2, (uint64_t)v5);
  result = v6;
  if (v6 == v5)
  {
    v4 = 4;
    result = v5;
  }
  else
  {
    if (!v6)
      return result;
    v4 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v4))();
}

void sub_208F98BAC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13)
{
  char *v13;
  char *v15;
  uint64_t v16;

  v15 = a13;
  if (a13 == v13)
  {
    v16 = 4;
    v15 = &a10;
  }
  else
  {
    if (!a13)
      goto LABEL_6;
    v16 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v15 + 8 * v16))();
LABEL_6:
  _Unwind_Resume(exception_object);
}

_QWORD *std::shared_ptr<PKPath>::operator=[abi:ne180100](_QWORD *a1, uint64_t *a2)
{
  uint64_t v3;
  uint64_t v4;
  unint64_t *v5;
  unint64_t v6;
  std::__shared_weak_count *v7;
  unint64_t *p_shared_owners;
  unint64_t v9;

  v4 = *a2;
  v3 = a2[1];
  if (v3)
  {
    v5 = (unint64_t *)(v3 + 8);
    do
      v6 = __ldxr(v5);
    while (__stxr(v6 + 1, v5));
  }
  v7 = (std::__shared_weak_count *)a1[1];
  *a1 = v4;
  a1[1] = v3;
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      v9 = __ldaxr(p_shared_owners);
    while (__stlxr(v9 - 1, p_shared_owners));
    if (!v9)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }
  return a1;
}

void sub_208F9921C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void std::vector<b2Vec2>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v2;

  v2 = (uint64_t)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 3;
  if (a2 <= v2)
  {
    if (a2 < v2)
      *(_QWORD *)(a1 + 8) = *(_QWORD *)a1 + 8 * a2;
  }
  else
  {
    std::vector<b2Vec2>::__append((char **)a1, a2 - v2);
  }
}

void std::vector<PKPoint>::reserve(void **a1, unint64_t a2)
{
  uint64_t v3;
  _BYTE *v4;
  int64_t v5;
  char *v6;
  char *v7;
  uint64_t v8;
  char *v9;
  char *v10;
  char *v11;
  char *v12;
  uint64_t v13;

  v4 = a1[2];
  v3 = (uint64_t)(a1 + 2);
  if (a2 > (v4 - (_BYTE *)*a1) >> 3)
  {
    if (a2 >> 61)
      std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
    v5 = (_BYTE *)a1[1] - (_BYTE *)*a1;
    v6 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKPoint>>(v3, a2);
    v7 = &v6[v5 & 0xFFFFFFFFFFFFFFF8];
    v9 = &v6[8 * v8];
    v11 = (char *)*a1;
    v10 = (char *)a1[1];
    v12 = v7;
    if (v10 != *a1)
    {
      do
      {
        v13 = *((_QWORD *)v10 - 1);
        v10 -= 8;
        *((_QWORD *)v12 - 1) = v13;
        v12 -= 8;
      }
      while (v10 != v11);
      v10 = (char *)*a1;
    }
    *a1 = v12;
    a1[1] = v7;
    a1[2] = v9;
    if (v10)
      operator delete(v10);
  }
}

void sub_208F997B4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, uint64_t a20,void *a21,uint64_t a22)
{
  void *v22;
  void *v23;

  std::shared_ptr<QuadTree>::~shared_ptr[abi:ne180100]((uint64_t)&a13);
  std::shared_ptr<QuadTree>::~shared_ptr[abi:ne180100]((uint64_t)&a15);

  if (__p)
  {
    a19 = (uint64_t)__p;
    operator delete(__p);
  }
  if (a21)
  {
    a22 = (uint64_t)a21;
    operator delete(a21);
  }
  _Unwind_Resume(a1);
}

void sub_208F99E0C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_208F9A9E0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void addCircleBody(PKPhysicsBody *a1, float a2, const CGPoint *a3)
{
  uint64_t v5;
  PKPhysicsBody *v6;
  PKPhysicsShape **value;
  _QWORD *end;
  PKPhysicsShape **v9;
  PKPhysicsShape **begin;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  char *v15;
  uint64_t *v16;
  PKPhysicsShape **v17;
  PKPhysicsShape **v18;
  PKPhysicsShape **v19;
  uint64_t v20;
  PKPhysicsBody *v21;

  v21 = a1;
  v5 = operator new();
  *(_QWORD *)v5 = 0;
  *(_QWORD *)(v5 + 8) = 0;
  *(_DWORD *)(v5 + 32) = 1065353216;
  *(_QWORD *)(v5 + 40) = 0;
  *(_OWORD *)(v5 + 16) = xmmword_208FD6020;
  v6 = v21;
  value = v21->_shapes.__end_cap_.__value_;
  end = v21->_shapes.__end_;
  if (end >= value)
  {
    begin = v21->_shapes.__begin_;
    v11 = (PKPhysicsShape **)end - begin;
    if ((unint64_t)(v11 + 1) >> 61)
      std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
    v12 = (char *)value - (char *)begin;
    v13 = v12 >> 2;
    if (v12 >> 2 <= (unint64_t)(v11 + 1))
      v13 = v11 + 1;
    if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF8)
      v14 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v14 = v13;
    if (v14)
      v15 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKPoint>>((uint64_t)&v21->_shapes.__end_cap_, v14);
    else
      v15 = 0;
    v16 = (uint64_t *)&v15[8 * v11];
    v17 = (PKPhysicsShape **)&v15[8 * v14];
    *v16 = v5;
    v9 = (PKPhysicsShape **)(v16 + 1);
    v19 = v21->_shapes.__begin_;
    v18 = v21->_shapes.__end_;
    if (v18 != v19)
    {
      do
      {
        v20 = (uint64_t)*--v18;
        *--v16 = v20;
      }
      while (v18 != v19);
      v18 = v21->_shapes.__begin_;
    }
    v6 = v21;
    v21->_shapes.__begin_ = (PKPhysicsShape **)v16;
    v21->_shapes.__end_ = v9;
    v21->_shapes.__end_cap_.__value_ = v17;
    if (v18)
    {
      operator delete(v18);
      v6 = v21;
    }
  }
  else
  {
    *end = v5;
    v9 = (PKPhysicsShape **)(end + 1);
  }
  v6->_shapes.__end_ = v9;
  PKPhysicsShape::createAsCircle(*(v9 - 1), a2, a3);
  v21->_shapeType = 1;
  v21->_radius = a2;
  v21->_p0 = *a3;

}

void sub_208F9AD0C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void addEdge(PKPhysicsBody *a1, const CGPoint *a2, const CGPoint *a3)
{
  PKPhysicsBody *v5;
  uint64_t v6;
  float edgeRadius;
  double x;
  float v9;
  double y;
  float v11;
  double v12;
  float v13;
  double v14;
  float v15;
  uint64_t v16;
  PKPhysicsShape **value;
  _QWORD *end;
  PKPhysicsShape **v19;
  PKPhysicsShape **begin;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v24;
  char *v25;
  uint64_t *v26;
  PKPhysicsShape **v27;
  PKPhysicsShape **v28;
  PKPhysicsShape **v29;
  uint64_t v30;
  b2Vec2 v31;
  b2Vec2 v32;

  v5 = a1;
  v5->_dynamicType = 1;
  v5->_bodyDef.type = 1;
  v6 = operator new();
  edgeRadius = v5->_edgeRadius;
  *(_QWORD *)v6 = &off_24C0E7CC8;
  *(_DWORD *)(v6 + 8) = 1;
  *(float *)(v6 + 12) = edgeRadius;
  *(_QWORD *)(v6 + 32) = 0;
  *(_QWORD *)(v6 + 40) = 0;
  *(_WORD *)(v6 + 48) = 0;
  x = a2->x;
  v9 = x * PKGet_INV_PTM_RATIO();
  v32.x = v9;
  y = a2->y;
  v11 = y * PKGet_INV_PTM_RATIO();
  v32.y = v11;
  v12 = a3->x;
  v13 = v12 * PKGet_INV_PTM_RATIO();
  v31.x = v13;
  v14 = a3->y;
  v15 = v14 * PKGet_INV_PTM_RATIO();
  v31.y = v15;
  b2EdgeShape::Set(v6, &v32, &v31);
  v16 = operator new();
  *(_QWORD *)v16 = 0;
  *(_QWORD *)(v16 + 8) = 0;
  *(_DWORD *)(v16 + 32) = 1065353216;
  *(_QWORD *)(v16 + 40) = 0;
  *(_OWORD *)(v16 + 16) = xmmword_208FD6020;
  value = v5->_shapes.__end_cap_.__value_;
  end = v5->_shapes.__end_;
  if (end >= value)
  {
    begin = v5->_shapes.__begin_;
    v21 = (PKPhysicsShape **)end - begin;
    if ((unint64_t)(v21 + 1) >> 61)
      std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
    v22 = (char *)value - (char *)begin;
    v23 = v22 >> 2;
    if (v22 >> 2 <= (unint64_t)(v21 + 1))
      v23 = v21 + 1;
    if ((unint64_t)v22 >= 0x7FFFFFFFFFFFFFF8)
      v24 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v24 = v23;
    if (v24)
      v25 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKPoint>>((uint64_t)&v5->_shapes.__end_cap_, v24);
    else
      v25 = 0;
    v26 = (uint64_t *)&v25[8 * v21];
    v27 = (PKPhysicsShape **)&v25[8 * v24];
    *v26 = v16;
    v19 = (PKPhysicsShape **)(v26 + 1);
    v29 = v5->_shapes.__begin_;
    v28 = v5->_shapes.__end_;
    if (v28 != v29)
    {
      do
      {
        v30 = (uint64_t)*--v28;
        *--v26 = v30;
      }
      while (v28 != v29);
      v28 = v5->_shapes.__begin_;
    }
    v5->_shapes.__begin_ = (PKPhysicsShape **)v26;
    v5->_shapes.__end_ = v19;
    v5->_shapes.__end_cap_.__value_ = v27;
    if (v28)
      operator delete(v28);
  }
  else
  {
    *end = v16;
    v19 = (PKPhysicsShape **)(end + 1);
  }
  v5->_shapes.__end_ = v19;
  (*(v19 - 1))->var0.var0 = (b2Shape *)v6;
  v5->_shapeType = 4;
  v5->_p0 = *a2;
  v5->_p1 = *a3;

}

void sub_208F9AF48(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t addPolygonFromPath(void *a1, uint64_t *a2)
{
  float v2;
  float v3;
  double *v5;
  unint64_t v6;
  b2Vec2 *v7;
  int v8;
  uint64_t v9;
  float *v10;
  float v11;
  float v12;
  float v13;
  float v14;
  float v15;
  float v16;
  float *v17;
  float x;
  float y;
  unint64_t v20;
  float v21;
  uint64_t v22;
  uint64_t v24;
  int v25;
  b2Vec2 *v26;
  b2Vec2 v27;
  uint64_t v28;
  float v29;
  _BOOL4 v30;
  uint64_t v31;
  unint64_t v32;
  uint64_t *v33;
  _QWORD *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  unint64_t v39;
  char *v40;
  uint64_t *v41;
  char *v42;
  char *v43;
  char *v44;
  uint64_t v45;

  v5 = a1;
  v6 = *(_QWORD *)(*a2 + 16) - *(_QWORD *)(*a2 + 8);
  v7 = (b2Vec2 *)malloc_type_malloc((uint64_t)(v6 << 29) >> 29, 0x100004000313F17uLL);
  if ((int)(v6 >> 3) < 1)
    goto LABEL_13;
  v8 = 0;
  v9 = (v6 >> 3);
  v10 = (float *)(*(_QWORD *)(*a2 + 8) + 4);
  do
  {
    v11 = *(v10 - 1);
    v12 = *v10;
    v13 = PKGet_INV_PTM_RATIO();
    v14 = PKGet_INV_PTM_RATIO();
    v15 = v11 * v13;
    v16 = v12 * v14;
    if (v8 < 1
      || (float)((float)((float)(v16 - v2) * (float)(v16 - v2)) + (float)((float)(v15 - v3) * (float)(v15 - v3))) > 1.4211e-14)
    {
      v17 = (float *)&v7[v8];
      *v17 = v15;
      v17[1] = v16;
      ++v8;
      v2 = v16;
      v3 = v11 * v13;
    }
    v10 += 2;
    --v9;
  }
  while (v9);
  if (v8 <= 1)
    goto LABEL_13;
  x = v7->x;
  y = v7->y;
  if ((float)((float)((float)(v7[v8 - 1].y - y) * (float)(v7[v8 - 1].y - y))
             + (float)((float)(v7[v8 - 1].x - v7->x) * (float)(v7[v8 - 1].x - v7->x))) <= 1.4211e-14)
  {
    v20 = v8;
    do
    {
      v8 = v20 - 1;
      if (v20 < 3)
        break;
      v21 = (float)((float)(v7[(v20 - 2)].y - y) * (float)(v7[(v20 - 2)].y - y))
          + (float)((float)(v7[(v20 - 2)].x - x) * (float)(v7[(v20 - 2)].x - x));
      --v20;
    }
    while (v21 <= 1.4211e-14);
  }
  if (v8 <= 2)
  {
LABEL_13:
    free(v7);
LABEL_14:
    v22 = 0;
    goto LABEL_15;
  }
  if ((float)((float)((float)(v7[1].x - x) * (float)(v7[2].y - v7[1].y))
             - (float)((float)(v7[1].y - y) * (float)(v7[2].x - v7[1].x))) < 0.0)
  {
    v24 = v8 >> 1;
    v25 = v8 - 1;
    v26 = v7;
    do
    {
      v27 = *v26;
      *v26++ = v7[v25];
      v7[v25--] = v27;
      --v24;
    }
    while (v24);
  }
  v28 = operator new();
  v29 = v5[32];
  *(_QWORD *)v28 = &off_24C0E81C0;
  *(_OWORD *)(v28 + 16) = 0u;
  *(_OWORD *)(v28 + 32) = 0u;
  *(_OWORD *)(v28 + 48) = 0u;
  *(_DWORD *)(v28 + 8) = 2;
  *(float *)(v28 + 12) = v29;
  *(_QWORD *)(v28 + 64) = 0;
  v30 = b2PolygonShape::Set((b2PolygonShape *)v28, v7, v8);
  free(v7);
  if (!v30 || !b2PolygonShape::isValidShape((b2PolygonShape *)v28))
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v28 + 8))(v28);
    std::shared_ptr<QuadTree>::reset[abi:ne180100]((_QWORD *)v5 + 21);
    goto LABEL_14;
  }
  v31 = operator new();
  *(_QWORD *)v31 = 0;
  *(_QWORD *)(v31 + 8) = 0;
  *(_DWORD *)(v31 + 32) = 1065353216;
  *(_QWORD *)(v31 + 40) = 0;
  *(_OWORD *)(v31 + 16) = xmmword_208FD6020;
  v32 = *((_QWORD *)v5 + 17);
  v33 = (uint64_t *)*((_QWORD *)v5 + 16);
  if ((unint64_t)v33 >= v32)
  {
    v35 = *((_QWORD *)v5 + 15);
    v36 = ((uint64_t)v33 - v35) >> 3;
    if ((unint64_t)(v36 + 1) >> 61)
      std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
    v37 = v32 - v35;
    v38 = v37 >> 2;
    if (v37 >> 2 <= (unint64_t)(v36 + 1))
      v38 = v36 + 1;
    if ((unint64_t)v37 >= 0x7FFFFFFFFFFFFFF8)
      v39 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v39 = v38;
    if (v39)
      v40 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKPoint>>((uint64_t)(v5 + 17), v39);
    else
      v40 = 0;
    v41 = (uint64_t *)&v40[8 * v36];
    v42 = &v40[8 * v39];
    *v41 = v31;
    v34 = v41 + 1;
    v44 = (char *)*((_QWORD *)v5 + 15);
    v43 = (char *)*((_QWORD *)v5 + 16);
    if (v43 != v44)
    {
      do
      {
        v45 = *((_QWORD *)v43 - 1);
        v43 -= 8;
        *--v41 = v45;
      }
      while (v43 != v44);
      v43 = (char *)*((_QWORD *)v5 + 15);
    }
    *((_QWORD *)v5 + 15) = v41;
    *((_QWORD *)v5 + 16) = v34;
    *((_QWORD *)v5 + 17) = v42;
    if (v43)
      operator delete(v43);
  }
  else
  {
    *v33 = v31;
    v34 = v33 + 1;
  }
  *((_QWORD *)v5 + 16) = v34;
  *(_QWORD *)*(v34 - 1) = v28;
  *((_DWORD *)v5 + 41) = 3;
  std::shared_ptr<PKPath>::operator=[abi:ne180100]((_QWORD *)v5 + 21, a2);
  v22 = 1;
LABEL_15:

  return v22;
}

void sub_208F9B2E0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void addEdgeChain(void *a1, uint64_t *a2)
{
  float v2;
  float v3;
  unint64_t v5;
  b2Vec2 *v6;
  int v7;
  uint64_t v8;
  float *v9;
  float v10;
  float v11;
  float v12;
  float v13;
  float v14;
  float v15;
  float *v16;
  float y;
  unint64_t v18;
  float v19;
  uint64_t v20;
  float v21;
  uint64_t v22;
  _QWORD *v23;
  unint64_t v24;
  uint64_t *v25;
  _QWORD *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t v31;
  char *v32;
  uint64_t *v33;
  char *v34;
  char *v35;
  char *v36;
  uint64_t v37;
  _QWORD *v38;

  v38 = a1;
  std::shared_ptr<PKPath>::operator=[abi:ne180100](v38 + 21, a2);
  *((_DWORD *)v38 + 28) = 1;
  *((_DWORD *)v38 + 9) = 1;
  v5 = *(_QWORD *)(*a2 + 16) - *(_QWORD *)(*a2 + 8);
  v6 = (b2Vec2 *)malloc_type_malloc((uint64_t)(v5 << 29) >> 29, 0x100004000313F17uLL);
  if ((int)(v5 >> 3) < 1)
  {
    v7 = 0;
  }
  else
  {
    v7 = 0;
    v8 = (v5 >> 3);
    v9 = (float *)(*(_QWORD *)(*a2 + 8) + 4);
    do
    {
      v10 = *(v9 - 1);
      v11 = *v9;
      v12 = PKGet_INV_PTM_RATIO();
      v13 = PKGet_INV_PTM_RATIO();
      v14 = v10 * v12;
      v15 = v11 * v13;
      if (v7 < 1
        || (float)((float)((float)(v15 - v2) * (float)(v15 - v2)) + (float)((float)(v14 - v3) * (float)(v14 - v3))) > 1.4211e-14)
      {
        v16 = (float *)&v6[v7];
        *v16 = v14;
        v16[1] = v15;
        ++v7;
        v2 = v15;
        v3 = v10 * v12;
      }
      v9 += 2;
      --v8;
    }
    while (v8);
    if (v7 > 1)
    {
      y = v6->y;
      if ((float)((float)((float)(v6[v7 - 1].y - y) * (float)(v6[v7 - 1].y - y))
                 + (float)((float)(v6[v7 - 1].x - v6->x) * (float)(v6[v7 - 1].x - v6->x))) <= 1.4211e-14)
      {
        v18 = v7;
        do
        {
          v7 = v18 - 1;
          if (v18 < 3)
            break;
          v19 = (float)((float)(v6[(v18 - 2)].y - y) * (float)(v6[(v18 - 2)].y - y))
              + (float)((float)(v6[(v18 - 2)].x - v6->x) * (float)(v6[(v18 - 2)].x - v6->x));
          --v18;
        }
        while (v19 <= 1.4211e-14);
      }
    }
  }
  v20 = operator new();
  v21 = *((double *)v38 + 32);
  *(_QWORD *)v20 = &off_24C0E7ED8;
  *(_QWORD *)(v20 + 24) = 0;
  *(_QWORD *)(v20 + 32) = 0;
  *(_QWORD *)(v20 + 16) = 0;
  *(_DWORD *)(v20 + 8) = 3;
  *(float *)(v20 + 12) = v21;
  *(_WORD *)(v20 + 56) = 0;
  b2ChainShape::CreateChain((void **)v20, v6, v7);
  v22 = operator new();
  *(_QWORD *)v22 = 0;
  *(_QWORD *)(v22 + 8) = 0;
  *(_DWORD *)(v22 + 32) = 1065353216;
  *(_QWORD *)(v22 + 40) = 0;
  *(_OWORD *)(v22 + 16) = xmmword_208FD6020;
  v23 = v38;
  v24 = v38[17];
  v25 = (uint64_t *)v38[16];
  if ((unint64_t)v25 >= v24)
  {
    v27 = v38[15];
    v28 = ((uint64_t)v25 - v27) >> 3;
    if ((unint64_t)(v28 + 1) >> 61)
      std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
    v29 = v24 - v27;
    v30 = v29 >> 2;
    if (v29 >> 2 <= (unint64_t)(v28 + 1))
      v30 = v28 + 1;
    if ((unint64_t)v29 >= 0x7FFFFFFFFFFFFFF8)
      v31 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v31 = v30;
    if (v31)
      v32 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKPoint>>((uint64_t)(v38 + 17), v31);
    else
      v32 = 0;
    v33 = (uint64_t *)&v32[8 * v28];
    v34 = &v32[8 * v31];
    *v33 = v22;
    v26 = v33 + 1;
    v36 = (char *)v38[15];
    v35 = (char *)v38[16];
    if (v35 != v36)
    {
      do
      {
        v37 = *((_QWORD *)v35 - 1);
        v35 -= 8;
        *--v33 = v37;
      }
      while (v35 != v36);
      v35 = (char *)v38[15];
    }
    v23 = v38;
    v38[15] = v33;
    v38[16] = v26;
    v38[17] = v34;
    if (v35)
    {
      operator delete(v35);
      v23 = v38;
    }
  }
  else
  {
    *v25 = v22;
    v26 = v25 + 1;
  }
  v23[16] = v26;
  *(_QWORD *)*(v26 - 1) = v20;
  *((_DWORD *)v23 + 41) = 5;
  std::shared_ptr<PKPath>::operator=[abi:ne180100](v38 + 21, a2);
  free(v6);

}

void sub_208F9B624(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_208F9B8C0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_208F9B9D4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void std::shared_ptr<QuadTree>::reset[abi:ne180100](_QWORD *a1)
{
  std::__shared_weak_count *v1;
  unint64_t *p_shared_owners;
  unint64_t v3;

  v1 = (std::__shared_weak_count *)a1[1];
  *a1 = 0;
  a1[1] = 0;
  if (v1)
  {
    p_shared_owners = (unint64_t *)&v1->__shared_owners_;
    do
      v3 = __ldaxr(p_shared_owners);
    while (__stlxr(v3 - 1, p_shared_owners));
    if (!v3)
    {
      ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
      std::__shared_weak_count::__release_weak(v1);
    }
  }
}

void sub_208F9BD28(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, void *a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

void sub_208F9BDD8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_208F9BE70(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

BOOL addRectangle(PKPhysicsBody *a1, const CGSize *a2, const CGPoint *a3, float a4)
{
  PKPhysicsBody *v7;
  double width;
  double height;
  uint64_t v10;
  float v11;
  float v12;
  double x;
  float v14;
  double y;
  float v16;
  float v17;
  float v18;
  float v19;
  float v20;
  _BOOL8 isValidShape;
  uint64_t v22;
  PKPhysicsShape **value;
  _QWORD *end;
  PKPhysicsShape **v25;
  PKPhysicsShape **begin;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t v30;
  char *v31;
  uint64_t *v32;
  PKPhysicsShape **v33;
  PKPhysicsShape **v34;
  PKPhysicsShape **v35;
  uint64_t v36;
  b2Vec2 v38;

  v7 = a1;
  v7->_edgeRadius = a4;
  width = a2->width;
  height = a2->height;
  v10 = operator new();
  *(_QWORD *)v10 = &off_24C0E81C0;
  *(_OWORD *)(v10 + 16) = 0u;
  *(_OWORD *)(v10 + 32) = 0u;
  *(_OWORD *)(v10 + 48) = 0u;
  *(_DWORD *)(v10 + 8) = 2;
  *(float *)(v10 + 12) = a4;
  *(_QWORD *)(v10 + 64) = 0;
  v11 = PKGet_INV_PTM_RATIO();
  v12 = PKGet_INV_PTM_RATIO();
  x = a3->x;
  v14 = PKGet_INV_PTM_RATIO();
  y = a3->y;
  v16 = PKGet_INV_PTM_RATIO();
  v17 = width * 0.5 * v11;
  v18 = height * 0.5 * v12;
  v19 = x * v14;
  v20 = y * v16;
  v38.x = v19;
  v38.y = v20;
  b2PolygonShape::SetAsBox((b2PolygonShape *)v10, v17, v18, &v38, 0.0);
  isValidShape = b2PolygonShape::isValidShape((b2PolygonShape *)v10);
  if (isValidShape)
  {
    v22 = operator new();
    *(_QWORD *)v22 = 0;
    *(_QWORD *)(v22 + 8) = 0;
    *(_DWORD *)(v22 + 32) = 1065353216;
    *(_QWORD *)(v22 + 40) = 0;
    *(_OWORD *)(v22 + 16) = xmmword_208FD6020;
    value = v7->_shapes.__end_cap_.__value_;
    end = v7->_shapes.__end_;
    if (end >= value)
    {
      begin = v7->_shapes.__begin_;
      v27 = (PKPhysicsShape **)end - begin;
      if ((unint64_t)(v27 + 1) >> 61)
        std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
      v28 = (char *)value - (char *)begin;
      v29 = v28 >> 2;
      if (v28 >> 2 <= (unint64_t)(v27 + 1))
        v29 = v27 + 1;
      if ((unint64_t)v28 >= 0x7FFFFFFFFFFFFFF8)
        v30 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v30 = v29;
      if (v30)
        v31 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKPoint>>((uint64_t)&v7->_shapes.__end_cap_, v30);
      else
        v31 = 0;
      v32 = (uint64_t *)&v31[8 * v27];
      v33 = (PKPhysicsShape **)&v31[8 * v30];
      *v32 = v22;
      v25 = (PKPhysicsShape **)(v32 + 1);
      v35 = v7->_shapes.__begin_;
      v34 = v7->_shapes.__end_;
      if (v34 != v35)
      {
        do
        {
          v36 = (uint64_t)*--v34;
          *--v32 = v36;
        }
        while (v34 != v35);
        v34 = v7->_shapes.__begin_;
      }
      v7->_shapes.__begin_ = (PKPhysicsShape **)v32;
      v7->_shapes.__end_ = v25;
      v7->_shapes.__end_cap_.__value_ = v33;
      if (v34)
        operator delete(v34);
    }
    else
    {
      *end = v22;
      v25 = (PKPhysicsShape **)(end + 1);
    }
    v7->_shapes.__end_ = v25;
    (*(v25 - 1))->var0.var0 = (b2Shape *)v10;
    v7->_shapeType = 2;
    v7->_size = *a2;
    v7->_p0 = *a3;
  }
  else
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v10 + 8))(v10);
  }

  return isValidShape;
}

void sub_208F9C0F4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_208F9C154(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_208F9C220(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  void *v9;

  std::shared_ptr<QuadTree>::~shared_ptr[abi:ne180100]((uint64_t)&a9);

  _Unwind_Resume(a1);
}

void sub_208F9C2E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  void *v9;

  std::shared_ptr<QuadTree>::~shared_ptr[abi:ne180100]((uint64_t)&a9);

  _Unwind_Resume(a1);
}

void sub_208F9C3B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  void *v9;

  std::shared_ptr<QuadTree>::~shared_ptr[abi:ne180100]((uint64_t)&a9);

  _Unwind_Resume(a1);
}

void addEdgeLoop(void *a1, uint64_t *a2)
{
  float v2;
  float v3;
  _DWORD *v5;
  unint64_t v6;
  b2Vec2 *v7;
  int v8;
  uint64_t v9;
  float *v10;
  float v11;
  float v12;
  float v13;
  float v14;
  float v15;
  float v16;
  float *v17;
  float y;
  unint64_t v19;
  float v20;
  uint64_t v21;
  float v22;
  uint64_t v23;
  double *v24;
  unint64_t v25;
  uint64_t *v26;
  _QWORD *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  unint64_t v32;
  char *v33;
  uint64_t *v34;
  char *v35;
  char *v36;
  char *v37;
  uint64_t v38;
  double *v39;

  v5 = a1;
  v5[28] = 1;
  v39 = (double *)v5;
  v5[9] = 1;
  v6 = *(_QWORD *)(*a2 + 16) - *(_QWORD *)(*a2 + 8);
  v7 = (b2Vec2 *)malloc_type_malloc((uint64_t)(v6 << 29) >> 29, 0x100004000313F17uLL);
  if ((int)(v6 >> 3) < 1)
  {
    v8 = 0;
  }
  else
  {
    v8 = 0;
    v9 = (v6 >> 3);
    v10 = (float *)(*(_QWORD *)(*a2 + 8) + 4);
    do
    {
      v11 = *(v10 - 1);
      v12 = *v10;
      v13 = PKGet_INV_PTM_RATIO();
      v14 = PKGet_INV_PTM_RATIO();
      v15 = v11 * v13;
      v16 = v12 * v14;
      if (v8 < 1
        || (float)((float)((float)(v16 - v2) * (float)(v16 - v2)) + (float)((float)(v15 - v3) * (float)(v15 - v3))) > 1.4211e-14)
      {
        v17 = (float *)&v7[v8];
        *v17 = v15;
        v17[1] = v16;
        ++v8;
        v2 = v16;
        v3 = v11 * v13;
      }
      v10 += 2;
      --v9;
    }
    while (v9);
    if (v8 > 1)
    {
      y = v7->y;
      if ((float)((float)((float)(v7[v8 - 1].y - y) * (float)(v7[v8 - 1].y - y))
                 + (float)((float)(v7[v8 - 1].x - v7->x) * (float)(v7[v8 - 1].x - v7->x))) <= 1.4211e-14)
      {
        v19 = v8;
        do
        {
          v8 = v19 - 1;
          if (v19 < 3)
            break;
          v20 = (float)((float)(v7[(v19 - 2)].y - y) * (float)(v7[(v19 - 2)].y - y))
              + (float)((float)(v7[(v19 - 2)].x - v7->x) * (float)(v7[(v19 - 2)].x - v7->x));
          --v19;
        }
        while (v20 <= 1.4211e-14);
      }
    }
  }
  v21 = operator new();
  v22 = v39[32];
  *(_QWORD *)v21 = &off_24C0E7ED8;
  *(_QWORD *)(v21 + 24) = 0;
  *(_QWORD *)(v21 + 32) = 0;
  *(_QWORD *)(v21 + 16) = 0;
  *(_DWORD *)(v21 + 8) = 3;
  *(float *)(v21 + 12) = v22;
  *(_WORD *)(v21 + 56) = 0;
  b2ChainShape::CreateLoop((void **)v21, v7, v8);
  v23 = operator new();
  *(_QWORD *)v23 = 0;
  *(_QWORD *)(v23 + 8) = 0;
  *(_DWORD *)(v23 + 32) = 1065353216;
  *(_QWORD *)(v23 + 40) = 0;
  *(_OWORD *)(v23 + 16) = xmmword_208FD6020;
  v24 = v39;
  v25 = *((_QWORD *)v39 + 17);
  v26 = (uint64_t *)*((_QWORD *)v39 + 16);
  if ((unint64_t)v26 >= v25)
  {
    v28 = *((_QWORD *)v39 + 15);
    v29 = ((uint64_t)v26 - v28) >> 3;
    if ((unint64_t)(v29 + 1) >> 61)
      std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
    v30 = v25 - v28;
    v31 = v30 >> 2;
    if (v30 >> 2 <= (unint64_t)(v29 + 1))
      v31 = v29 + 1;
    if ((unint64_t)v30 >= 0x7FFFFFFFFFFFFFF8)
      v32 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v32 = v31;
    if (v32)
      v33 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKPoint>>((uint64_t)(v39 + 17), v32);
    else
      v33 = 0;
    v34 = (uint64_t *)&v33[8 * v29];
    v35 = &v33[8 * v32];
    *v34 = v23;
    v27 = v34 + 1;
    v37 = (char *)*((_QWORD *)v39 + 15);
    v36 = (char *)*((_QWORD *)v39 + 16);
    if (v36 != v37)
    {
      do
      {
        v38 = *((_QWORD *)v36 - 1);
        v36 -= 8;
        *--v34 = v38;
      }
      while (v36 != v37);
      v36 = (char *)*((_QWORD *)v39 + 15);
    }
    v24 = v39;
    *((_QWORD *)v39 + 15) = v34;
    *((_QWORD *)v39 + 16) = v27;
    *((_QWORD *)v39 + 17) = v35;
    if (v36)
    {
      operator delete(v36);
      v24 = v39;
    }
  }
  else
  {
    *v26 = v23;
    v27 = v26 + 1;
  }
  *((_QWORD *)v24 + 16) = v27;
  *(_QWORD *)*(v27 - 1) = v21;
  *((_DWORD *)v24 + 41) = 6;
  std::shared_ptr<PKPath>::operator=[abi:ne180100]((_QWORD *)v24 + 21, a2);
  free(v7);

}

void sub_208F9C6DC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_208F9C8E4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_208F9C980(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_208F9CCBC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<QuadTree>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void sub_208F9DBB4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_208F9E7AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  void *v11;
  va_list va;

  va_start(va, a11);
  std::shared_ptr<QuadTree>::~shared_ptr[abi:ne180100]((uint64_t)va);

  _Unwind_Resume(a1);
}

void sub_208F9E974(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_208F9EA28(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_208F9EBCC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t std::__function::__value_func<void ()(float,float,int)>::__value_func[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  v3 = *(_QWORD *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(_QWORD *)(a1 + 24) = a1;
      (*(void (**)(_QWORD, uint64_t))(**(_QWORD **)(a2 + 24) + 24))(*(_QWORD *)(a2 + 24), a1);
    }
    else
    {
      *(_QWORD *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v3 + 16))(v3);
    }
  }
  else
  {
    *(_QWORD *)(a1 + 24) = 0;
  }
  return a1;
}

void __clang_call_terminate(void *a1)
{
  __cxa_begin_catch(a1);
  std::terminate();
}

_QWORD *std::vector<PKPoint>::vector(_QWORD *a1, unint64_t a2)
{
  char *v4;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<PKPoint>::__vallocate[abi:ne180100](a1, a2);
    v4 = (char *)a1[1];
    bzero(v4, 8 * a2);
    a1[1] = &v4[8 * a2];
  }
  return a1;
}

void sub_208F9ED70(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *std::vector<PKPoint>::__vallocate[abi:ne180100](_QWORD *a1, unint64_t a2)
{
  char *result;
  uint64_t v4;

  if (a2 >> 61)
    std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
  result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKPoint>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[8 * v4];
  return result;
}

void std::vector<PKPoint>::__throw_length_error[abi:ne180100]()
{
  std::__throw_length_error[abi:ne180100]("vector");
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<PKPoint>>(uint64_t a1, unint64_t a2)
{
  if (a2 >> 61)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(8 * a2);
}

void std::__throw_length_error[abi:ne180100](const char *a1)
{
  std::logic_error *exception;

  exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
  std::length_error::length_error[abi:ne180100](exception, a1);
  __cxa_throw(exception, (struct type_info *)off_24C0E7348, MEMORY[0x24BEDAAF0]);
}

void sub_208F9EE50(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

std::logic_error *std::length_error::length_error[abi:ne180100](std::logic_error *a1, const char *a2)
{
  std::logic_error *result;

  result = std::logic_error::logic_error(a1, a2);
  result->__vftable = (std::logic_error_vtbl *)(MEMORY[0x24BEDB8B8] + 16);
  return result;
}

void std::__throw_bad_array_new_length[abi:ne180100]()
{
  std::bad_array_new_length *exception;
  std::bad_array_new_length *v1;

  exception = (std::bad_array_new_length *)__cxa_allocate_exception(8uLL);
  v1 = std::bad_array_new_length::bad_array_new_length(exception);
  __cxa_throw(v1, MEMORY[0x24BEDB748], MEMORY[0x24BEDABB8]);
}

uint64_t std::shared_ptr<QuadTree>::~shared_ptr[abi:ne180100](uint64_t a1)
{
  std::__shared_weak_count *v2;
  unint64_t *p_shared_owners;
  unint64_t v4;

  v2 = *(std::__shared_weak_count **)(a1 + 8);
  if (v2)
  {
    p_shared_owners = (unint64_t *)&v2->__shared_owners_;
    do
      v4 = __ldaxr(p_shared_owners);
    while (__stlxr(v4 - 1, p_shared_owners));
    if (!v4)
    {
      ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
      std::__shared_weak_count::__release_weak(v2);
    }
  }
  return a1;
}

void sub_208F9F07C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

BOOL std::type_info::operator==[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;

  v2 = *(_QWORD *)(a1 + 8);
  v3 = *(_QWORD *)(a2 + 8);
  if (v2 == v3)
    return 1;
  if ((v3 & v2) < 0 != __OFSUB__(v2, v3))
    return strcmp((const char *)(v2 & 0x7FFFFFFFFFFFFFFFLL), (const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL)) == 0;
  return 0;
}

void std::vector<b2Vec2>::__append(char **a1, unint64_t a2)
{
  uint64_t v4;
  char *v5;
  char *v6;
  char *v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char *v13;
  char *v14;
  char *v15;
  char *v16;
  uint64_t v17;

  v4 = (uint64_t)(a1 + 2);
  v5 = a1[2];
  v6 = a1[1];
  if (a2 <= (v5 - v6) >> 3)
  {
    a1[1] = &v6[8 * a2];
  }
  else
  {
    v7 = *a1;
    v8 = v6 - *a1;
    v9 = a2 + (v8 >> 3);
    if (v9 >> 61)
      std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
    v10 = v8 >> 3;
    v11 = v5 - v7;
    if (v11 >> 2 > v9)
      v9 = v11 >> 2;
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF8)
      v12 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v12 = v9;
    if (v12)
    {
      v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKPoint>>(v4, v12);
      v7 = *a1;
      v6 = a1[1];
    }
    else
    {
      v13 = 0;
    }
    v14 = &v13[8 * v10];
    v15 = &v13[8 * v12];
    v16 = &v14[8 * a2];
    if (v6 != v7)
    {
      do
      {
        v17 = *((_QWORD *)v6 - 1);
        v6 -= 8;
        *((_QWORD *)v14 - 1) = v17;
        v14 -= 8;
      }
      while (v6 != v7);
      v7 = *a1;
    }
    *a1 = v14;
    a1[1] = v16;
    a1[2] = v15;
    if (v7)
      operator delete(v7);
  }
}

uint64_t std::allocate_shared[abi:ne180100]<PKPath,std::allocator<PKPath>,PKPath&,void>@<X0>(uint64_t a1@<X1>, _QWORD *a2@<X8>)
{
  char *v4;
  uint64_t result;

  v4 = (char *)operator new(0x40uLL);
  result = std::__shared_ptr_emplace<PKPath>::__shared_ptr_emplace[abi:ne180100]<PKPath&,std::allocator<PKPath>,0>((uint64_t)v4, a1);
  *a2 = v4 + 24;
  a2[1] = v4;
  return result;
}

void sub_208F9F254(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t std::__shared_ptr_emplace<PKPath>::__shared_ptr_emplace[abi:ne180100]<PKPath&,std::allocator<PKPath>,0>(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)(a1 + 8) = 0u;
  *(_QWORD *)a1 = &unk_24C0E8D28;
  *(_DWORD *)(a1 + 24) = *(_DWORD *)a2;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_QWORD *)(a1 + 32) = 0;
  std::vector<PKPoint>::__init_with_size[abi:ne180100]<PKPoint*,PKPoint*>((_QWORD *)(a1 + 32), *(const void **)(a2 + 8), *(_QWORD *)(a2 + 16), (uint64_t)(*(_QWORD *)(a2 + 16) - *(_QWORD *)(a2 + 8)) >> 3);
  *(_QWORD *)(a1 + 56) = 0;
  return a1;
}

void sub_208F9F2C8(_Unwind_Exception *a1)
{
  std::__shared_weak_count *v1;

  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<PKPath>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_24C0E8D28;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<PKPath>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_24C0E8D28;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x20BD0BA58);
}

void std::__shared_ptr_emplace<PKPath>::__on_zero_shared(uint64_t a1)
{
  PKPath::~PKPath((PKPath *)(a1 + 24));
}

_QWORD *std::vector<PKPoint>::__init_with_size[abi:ne180100]<PKPoint*,PKPoint*>(_QWORD *result, const void *a2, uint64_t a3, unint64_t a4)
{
  _QWORD *v6;
  uint64_t v7;
  size_t v8;

  if (a4)
  {
    v6 = result;
    result = std::vector<PKPoint>::__vallocate[abi:ne180100](result, a4);
    v7 = v6[1];
    v8 = a3 - (_QWORD)a2;
    if (v8)
      result = memmove((void *)v6[1], a2, v8);
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_208F9F38C(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void PKPath::~PKPath(PKPath *this)
{
  const CGPath *v2;
  void *v3;

  v2 = (const CGPath *)*((_QWORD *)this + 4);
  if (v2)
    CGPathRelease(v2);
  v3 = (void *)*((_QWORD *)this + 1);
  if (v3)
  {
    *((_QWORD *)this + 2) = v3;
    operator delete(v3);
  }
}

_QWORD *std::shared_ptr<PKPath>::shared_ptr[abi:ne180100]<PKPath,void>(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;

  *a1 = a2;
  v4 = (_QWORD *)operator new();
  *v4 = &unk_24C0E8DD0;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  a1[1] = v4;
  return a1;
}

void sub_208F9F44C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::unique_ptr<PKPath>::reset[abi:ne180100]((PKPath **)va, 0);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_pointer<PKPath *,std::shared_ptr<PKPath>::__shared_ptr_default_delete<PKPath,PKPath>,std::allocator<PKPath>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x20BD0BA58);
}

PKPath *std::__shared_ptr_pointer<PKPath *,std::shared_ptr<PKPath>::__shared_ptr_default_delete<PKPath,PKPath>,std::allocator<PKPath>>::__on_zero_shared(uint64_t a1)
{
  PKPath *result;

  result = *(PKPath **)(a1 + 24);
  if (result)
  {
    PKPath::~PKPath(result);
    JUMPOUT(0x20BD0BA58);
  }
  return result;
}

uint64_t std::__shared_ptr_pointer<PKPath *,std::shared_ptr<PKPath>::__shared_ptr_default_delete<PKPath,PKPath>,std::allocator<PKPath>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

PKPath *std::unique_ptr<PKPath>::reset[abi:ne180100](PKPath **a1, PKPath *a2)
{
  PKPath *result;

  result = *a1;
  *a1 = a2;
  if (result)
  {
    PKPath::~PKPath(result);
    JUMPOUT(0x20BD0BA58);
  }
  return result;
}

char *std::vector<PKPoint>::__assign_with_size[abi:ne180100]<PKPoint*,PKPoint*>(char *result, char *__src, uint64_t a3, unint64_t a4)
{
  _QWORD *v7;
  uint64_t v8;
  char *v9;
  uint64_t v10;
  unint64_t v11;
  void **v12;
  char *v13;
  _BYTE *v14;
  unint64_t v15;
  char *v16;
  size_t v17;
  void *v18;
  char *v19;

  v7 = result;
  v8 = *((_QWORD *)result + 2);
  v9 = *(char **)result;
  if (a4 > (v8 - *(_QWORD *)result) >> 3)
  {
    if (v9)
    {
      *((_QWORD *)result + 1) = v9;
      operator delete(v9);
      v8 = 0;
      *v7 = 0;
      v7[1] = 0;
      v7[2] = 0;
    }
    if (a4 >> 61)
      std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
    v10 = v8 >> 2;
    if (v8 >> 2 <= a4)
      v10 = a4;
    if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF8)
      v11 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v11 = v10;
    result = std::vector<PKPoint>::__vallocate[abi:ne180100](v7, v11);
    v13 = (char *)v7[1];
    v12 = (void **)(v7 + 1);
    v9 = v13;
LABEL_16:
    v17 = a3 - (_QWORD)__src;
    if (v17)
    {
      v18 = v9;
      v19 = __src;
      goto LABEL_18;
    }
    goto LABEL_19;
  }
  v12 = (void **)(result + 8);
  v14 = (_BYTE *)*((_QWORD *)result + 1);
  v15 = (v14 - v9) >> 3;
  if (v15 >= a4)
    goto LABEL_16;
  v16 = &__src[8 * v15];
  if (v14 != v9)
  {
    result = (char *)memmove(*(void **)result, __src, v14 - v9);
    v9 = (char *)*v12;
  }
  v17 = a3 - (_QWORD)v16;
  if (v17)
  {
    v18 = v9;
    v19 = v16;
LABEL_18:
    result = (char *)memmove(v18, v19, v17);
  }
LABEL_19:
  *v12 = &v9[v17];
  return result;
}

void sub_208F9F708(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

__n128 math::transpose@<Q0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  __int128 v2;
  __int128 v3;
  __int128 v4;
  __int128 v5;
  __n128 result;

  result = *(__n128 *)a1;
  v2 = *(_OWORD *)(a1 + 4);
  v3 = *(_OWORD *)(a1 + 8);
  v4 = *(_OWORD *)(a1 + 12);
  v5 = *(_OWORD *)(a1 + 40);
  result.n128_u32[1] = HIDWORD(*(_QWORD *)(a1 + 12));
  DWORD1(v2) = *(_QWORD *)(a1 + 20);
  DWORD1(v3) = HIDWORD(v4);
  DWORD1(v4) = *(_DWORD *)(a1 + 28);
  result.n128_u32[2] = *(_DWORD *)(a1 + 32);
  DWORD2(v2) = *(_DWORD *)(a1 + 36);
  DWORD2(v4) = HIDWORD(*(_QWORD *)(a1 + 40));
  result.n128_u32[3] = *(_DWORD *)(a1 + 48);
  HIDWORD(v2) = *(_DWORD *)(a1 + 52);
  *(__n128 *)a2 = result;
  *(_OWORD *)(a2 + 16) = v2;
  *((_QWORD *)&v3 + 1) = v5;
  HIDWORD(v4) = *(_DWORD *)(a1 + 60);
  *(_OWORD *)(a2 + 32) = v3;
  *(_OWORD *)(a2 + 48) = v4;
  return result;
}

__n128 math::invert@<Q0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  float v2;
  float v3;
  float v4;
  BOOL v5;
  __int128 v6;
  __n128 result;
  __int128 v8;
  float v9;
  float v10;
  float v11;
  float v12;
  float v13;
  float v14;
  unsigned int v15;
  float v16;
  unsigned int v17;
  float v18;
  float v19;
  float v20;
  unsigned int v21;
  unsigned int v22;
  unsigned int v23;
  unsigned int v24;
  unsigned int v25;
  float v26;
  __int128 v27;
  unsigned int v28;
  __n128 v29;
  __int128 v30;
  float v31;
  float v32;
  uint64_t v33;
  float v34;
  __int128 *v35;
  uint64_t v36;
  float v37;
  __int128 *v38;
  uint64_t i;
  __int128 vars0;
  __n128 v41;
  __int128 v42;

  v2 = *(float *)(a1 + 12);
  if (v2 != 0.0
    || (v3 = *(float *)(a1 + 28), v3 != 0.0)
    || ((v4 = *(float *)(a1 + 44), v4 == 0.0) ? (v5 = *(float *)(a1 + 60) == 1.0) : (v5 = 0), !v5))
  {
LABEL_7:
    v6 = *(_OWORD *)(a1 + 16);
    *(_OWORD *)a2 = *(_OWORD *)a1;
    *(_OWORD *)(a2 + 16) = v6;
    result = *(__n128 *)(a1 + 32);
    v8 = *(_OWORD *)(a1 + 48);
    *(__n128 *)(a2 + 32) = result;
    *(_OWORD *)(a2 + 48) = v8;
    return result;
  }
  v10 = *(float *)(a1 + 36);
  v9 = *(float *)(a1 + 40);
  v12 = *(float *)(a1 + 20);
  v11 = *(float *)(a1 + 24);
  v13 = *(float *)(a1 + 32);
  v14 = *(float *)(a1 + 16);
  *(float *)&v15 = (float)(v12 * v9) - (float)(v11 * v10);
  v16 = (float)(v11 * v13) - (float)(v14 * v9);
  *(float *)&v17 = (float)(v14 * v10) - (float)(v12 * v13);
  v19 = *(float *)(a1 + 4);
  v18 = *(float *)(a1 + 8);
  v20 = *(float *)a1;
  *(float *)&v21 = (float)(v18 * v10) - (float)(v19 * v9);
  *(float *)&v22 = (float)(*(float *)a1 * v9) - (float)(v18 * v13);
  *(float *)&v23 = (float)(v19 * v13) - (float)(*(float *)a1 * v10);
  *(float *)&v24 = (float)(v19 * v11) - (float)(v18 * v12);
  *(float *)&v25 = (float)(v18 * v14) - (float)(*(float *)a1 * v11);
  v26 = -(float)(v19 * v14);
  *(_QWORD *)&v27 = __PAIR64__(v21, v15);
  *(float *)&v28 = v26 + (float)(*(float *)a1 * v12);
  *((_QWORD *)&v27 + 1) = v24;
  v29.n128_u64[0] = __PAIR64__(v22, LODWORD(v16));
  v29.n128_u64[1] = v25;
  *(_QWORD *)&v30 = __PAIR64__(v23, v17);
  vars0 = v27;
  v41 = v29;
  *((_QWORD *)&v30 + 1) = v28;
  v42 = v30;
  v31 = (float)((float)(v14 * *(float *)&v21) + (float)(v20 * *(float *)&v15)) + (float)(v13 * *(float *)&v24);
  v32 = fabsf(v31);
  v33 = 0;
  if (v32 < 1.0)
  {
    v34 = v32 * 8.5071e37;
    v35 = &vars0;
LABEL_10:
    v36 = 0;
    while (1)
    {
      v37 = *(float *)((char *)v35 + v36);
      if (v34 <= fabsf(v37))
        goto LABEL_7;
      *(float *)((char *)v35 + v36) = v37 / v31;
      v36 += 4;
      if (v36 == 12)
      {
        ++v33;
        ++v35;
        if (v33 != 3)
          goto LABEL_10;
        goto LABEL_19;
      }
    }
  }
  v38 = &vars0;
  do
  {
    for (i = 0; i != 12; i += 4)
      *(float *)((char *)v38 + i) = *(float *)((char *)v38 + i) / v31;
    ++v33;
    ++v38;
  }
  while (v33 != 3);
LABEL_19:
  *((float *)&vars0 + 3) = (float)((float)-(float)(v3 * *((float *)&vars0 + 1)) - (float)(v2 * *(float *)&vars0))
                         - (float)(v4 * *((float *)&vars0 + 2));
  v41.n128_f32[3] = (float)((float)-(float)(v3 * v29.n128_f32[1]) - (float)(v2 * v16)) - (float)(v4 * v29.n128_f32[2]);
  *((float *)&v42 + 3) = (float)((float)-(float)(v3 * *((float *)&v42 + 1)) - (float)(v2 * *(float *)&v42))
                       - (float)(v4 * *((float *)&v42 + 2));
  result = v41;
  *(_OWORD *)(a2 + 32) = v42;
  *(_OWORD *)(a2 + 48) = xmmword_208FD6030;
  *(_OWORD *)a2 = vars0;
  *(__n128 *)(a2 + 16) = v41;
  return result;
}

void sub_208F9FA78(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

void sub_208F9FB90(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  v4 = v3;

  _Unwind_Resume(a1);
}

void sub_208F9FD08(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_208F9FEE8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_208F9FF80(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_208FA0070(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_208FA01C4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_208FA02A4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_208FA05B0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_208FA06F4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_208FA07A4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_208FA098C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_208FA0A54(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_208FA0B28(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_208FA0C70(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  v4 = v3;

  _Unwind_Resume(a1);
}

void sub_208FA0D08(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_208FA0EA0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_208FA10F4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_208FA118C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_208FA1218(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_208FA12FC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  v4 = v3;

  _Unwind_Resume(a1);
}

void sub_208FA1488(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_208FA1584(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_208FA1634(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_208FA172C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_208FA1890(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  v4 = v3;

  _Unwind_Resume(a1);
}

void sub_208FA1958(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_208FA1C48(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_208FA1E70(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_208FA1F20(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_208FA1FE4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_208FA2114(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  v4 = v3;

  _Unwind_Resume(a1);
}

void sub_208FA219C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_208FA2344(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_208FA2474(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_208FA24C8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

#error "208FA2648: call analysis failed (funcsize=19)"

#error "208FA26B4: call analysis failed (funcsize=26)"

#error "208FA272C: call analysis failed (funcsize=29)"

void sub_208FA288C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_208FA2960(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_208FA2A48(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  void *v3;
  va_list va;

  va_start(va, a3);
  std::shared_ptr<QuadTree>::~shared_ptr[abi:ne180100]((uint64_t)va);

  _Unwind_Resume(a1);
}

void sub_208FA2B70(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_208FA2C78(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_208FA2CD4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_208FA2DC0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_208FA2E1C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t PKPhysicsFieldUserInvokeBatchBlockWith(uint64_t result)
{
  if (result)
  {
    result = *(_QWORD *)(result + 80);
    if (result)
      return (*(uint64_t (**)(void))(result + 16))();
  }
  return result;
}

void PKPhysicsFieldUserInvokeBlockWith(void *a1, uint64_t a2, uint64_t a3)
{
  id v4;
  __n128 v5;
  __n128 v6;
  void *v7;
  uint64_t v8;
  uint64_t v9;
  __n128 v10;
  uint64_t v11;
  void *v12;

  v4 = a1;
  v7 = v4;
  if (v4)
  {
    v8 = *((_QWORD *)v4 + 11);
    if (v8)
    {
      v12 = v7;
      v5.n128_u64[0] = **(_QWORD **)a3;
      v5.n128_u32[2] = *(_DWORD *)(*(_QWORD *)a3 + 8);
      v9 = *(_QWORD *)(a3 + 16);
      v6.n128_u64[0] = *(_QWORD *)v9;
      v6.n128_u32[2] = *(_DWORD *)(v9 + 8);
      v10 = ((__n128 (*)(__n128, __n128, float, float, double))*(_QWORD *)(v8 + 16))(v5, v6, **(float **)(a3 + 32), **(float **)(a3 + 48), *(double *)(a3 + 64));
      v11 = *(_QWORD *)(a3 + 72);
      *(_QWORD *)v11 = v10.n128_u64[0];
      *(_DWORD *)(v11 + 8) = v10.n128_u32[2];
      v7 = v12;
    }
  }

}

void sub_208FA2F2C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_208FA305C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  void *v7;
  void *v8;
  va_list va;

  va_start(va, a7);
  std::shared_ptr<QuadTree>::~shared_ptr[abi:ne180100]((uint64_t)va);

  _Unwind_Resume(a1);
}

void sub_208FA312C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_208FA318C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_208FA3244(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_208FA33F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  uint64_t v4;
  va_list va;
  uint64_t v6;
  va_list va1;

  va_start(va1, a3);
  va_start(va, a3);
  v4 = va_arg(va1, _QWORD);
  v6 = va_arg(va1, _QWORD);
  std::shared_ptr<QuadTree>::~shared_ptr[abi:ne180100]((uint64_t)va1);
  std::shared_ptr<QuadTree>::~shared_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_208FA34DC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_208FA35B0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_208FA3684(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

_QWORD *_ZNSt3__115allocate_sharedB8ne180100I12PKCFieldDragNS_9allocatorIS1_EEJEvEENS_10shared_ptrIT_EERKT0_DpOT1_@<X0>(_QWORD *a1@<X8>)
{
  _QWORD *v2;
  _QWORD *result;

  v2 = operator new(0x140uLL);
  result = _ZNSt3__120__shared_ptr_emplaceI12PKCFieldDragNS_9allocatorIS1_EEEC2B8ne180100IJES3_Li0EEES3_DpOT_(v2);
  *a1 = v2 + 8;
  a1[1] = v2;
  return result;
}

void sub_208FA36E4(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

_QWORD *_ZNSt3__120__shared_ptr_emplaceI12PKCFieldDragNS_9allocatorIS1_EEEC2B8ne180100IJES3_Li0EEES3_DpOT_(_QWORD *a1)
{
  a1[2] = 0;
  *a1 = &unk_24C0E8A88;
  a1[1] = 0;
  PKCFieldDrag::PKCFieldDrag((PKCFieldDrag *)(a1 + 8));
  return a1;
}

void sub_208FA3730(_Unwind_Exception *a1)
{
  std::__shared_weak_count *v1;

  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<PKCFieldDrag>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_24C0E8A88;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<PKCFieldDrag>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_24C0E8A88;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x20BD0BA58);
}

uint64_t std::__shared_ptr_emplace<PKCFieldDrag>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 64))(a1 + 64);
}

_QWORD *_ZNSt3__115allocate_sharedB8ne180100I14PKCFieldVortexNS_9allocatorIS1_EEJEvEENS_10shared_ptrIT_EERKT0_DpOT1_@<X0>(_QWORD *a1@<X8>)
{
  _QWORD *v2;
  _QWORD *result;

  v2 = operator new(0x140uLL);
  result = _ZNSt3__120__shared_ptr_emplaceI14PKCFieldVortexNS_9allocatorIS1_EEEC2B8ne180100IJES3_Li0EEES3_DpOT_(v2);
  *a1 = v2 + 8;
  a1[1] = v2;
  return result;
}

void sub_208FA37D0(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

_QWORD *_ZNSt3__120__shared_ptr_emplaceI14PKCFieldVortexNS_9allocatorIS1_EEEC2B8ne180100IJES3_Li0EEES3_DpOT_(_QWORD *a1)
{
  a1[2] = 0;
  *a1 = &unk_24C0E8BA0;
  a1[1] = 0;
  PKCFieldVortex::PKCFieldVortex((PKCFieldVortex *)(a1 + 8));
  return a1;
}

void sub_208FA381C(_Unwind_Exception *a1)
{
  std::__shared_weak_count *v1;

  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<PKCFieldVortex>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_24C0E8BA0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<PKCFieldVortex>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_24C0E8BA0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x20BD0BA58);
}

uint64_t std::__shared_ptr_emplace<PKCFieldVortex>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 64))(a1 + 64);
}

_QWORD *_ZNSt3__115allocate_sharedB8ne180100I21PKCFieldLinearGravityNS_9allocatorIS1_EEJEvEENS_10shared_ptrIT_EERKT0_DpOT1_@<X0>(_QWORD *a1@<X8>)
{
  _QWORD *v2;
  _QWORD *result;

  v2 = operator new(0x180uLL);
  result = _ZNSt3__120__shared_ptr_emplaceI21PKCFieldLinearGravityNS_9allocatorIS1_EEEC2B8ne180100IJES3_Li0EEES3_DpOT_(v2);
  *a1 = v2 + 8;
  a1[1] = v2;
  return result;
}

void sub_208FA38BC(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

_QWORD *_ZNSt3__120__shared_ptr_emplaceI21PKCFieldLinearGravityNS_9allocatorIS1_EEEC2B8ne180100IJES3_Li0EEES3_DpOT_(_QWORD *a1)
{
  a1[2] = 0;
  *a1 = &unk_24C0E8CB8;
  a1[1] = 0;
  PKCFieldLinearGravity::PKCFieldLinearGravity((PKCFieldLinearGravity *)(a1 + 8));
  return a1;
}

void sub_208FA3908(_Unwind_Exception *a1)
{
  std::__shared_weak_count *v1;

  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<PKCFieldLinearGravity>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_24C0E8CB8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<PKCFieldLinearGravity>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_24C0E8CB8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x20BD0BA58);
}

uint64_t std::__shared_ptr_emplace<PKCFieldLinearGravity>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 64))(a1 + 64);
}

_QWORD *_ZNSt3__115allocate_sharedB8ne180100I21PKCFieldRadialGravityNS_9allocatorIS1_EEJEvEENS_10shared_ptrIT_EERKT0_DpOT1_@<X0>(_QWORD *a1@<X8>)
{
  _QWORD *v2;
  _QWORD *result;

  v2 = operator new(0x140uLL);
  result = _ZNSt3__120__shared_ptr_emplaceI21PKCFieldRadialGravityNS_9allocatorIS1_EEEC2B8ne180100IJES3_Li0EEES3_DpOT_(v2);
  *a1 = v2 + 8;
  a1[1] = v2;
  return result;
}

void sub_208FA39A8(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

_QWORD *_ZNSt3__120__shared_ptr_emplaceI21PKCFieldRadialGravityNS_9allocatorIS1_EEEC2B8ne180100IJES3_Li0EEES3_DpOT_(_QWORD *a1)
{
  a1[2] = 0;
  *a1 = &unk_24C0E8CF0;
  a1[1] = 0;
  PKCFieldRadialGravity::PKCFieldRadialGravity((PKCFieldRadialGravity *)(a1 + 8));
  return a1;
}

void sub_208FA39F4(_Unwind_Exception *a1)
{
  std::__shared_weak_count *v1;

  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<PKCFieldRadialGravity>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_24C0E8CF0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<PKCFieldRadialGravity>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_24C0E8CF0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x20BD0BA58);
}

uint64_t std::__shared_ptr_emplace<PKCFieldRadialGravity>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 64))(a1 + 64);
}

_QWORD *std::allocate_shared[abi:ne180100]<PKCFieldUser,std::allocator<PKCFieldUser>,void *,void>@<X0>(void **a1@<X1>, _QWORD *a2@<X8>)
{
  _QWORD *v4;
  _QWORD *result;

  v4 = operator new(0x140uLL);
  result = std::__shared_ptr_emplace<PKCFieldUser>::__shared_ptr_emplace[abi:ne180100]<void *,std::allocator<PKCFieldUser>,0>(v4, a1);
  *a2 = v4 + 8;
  a2[1] = v4;
  return result;
}

void sub_208FA3AA4(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

_QWORD *std::__shared_ptr_emplace<PKCFieldUser>::__shared_ptr_emplace[abi:ne180100]<void *,std::allocator<PKCFieldUser>,0>(_QWORD *a1, void **a2)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = &unk_24C0E8AC0;
  PKCFieldUser::PKCFieldUser((PKCFieldUser *)(a1 + 8), *a2);
  return a1;
}

void sub_208FA3AF4(_Unwind_Exception *a1)
{
  std::__shared_weak_count *v1;

  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<PKCFieldUser>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_24C0E8AC0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<PKCFieldUser>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_24C0E8AC0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x20BD0BA58);
}

uint64_t std::__shared_ptr_emplace<PKCFieldUser>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 64))(a1 + 64);
}

_QWORD *_ZNSt3__115allocate_sharedB8ne180100I16PKCFieldVelocityNS_9allocatorIS1_EEJEvEENS_10shared_ptrIT_EERKT0_DpOT1_@<X0>(_QWORD *a1@<X8>)
{
  _QWORD *v2;
  _QWORD *result;

  v2 = operator new(0x180uLL);
  result = _ZNSt3__120__shared_ptr_emplaceI16PKCFieldVelocityNS_9allocatorIS1_EEEC2B8ne180100IJES3_Li0EEES3_DpOT_(v2);
  *a1 = v2 + 8;
  a1[1] = v2;
  return result;
}

void sub_208FA3B94(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

_QWORD *_ZNSt3__120__shared_ptr_emplaceI16PKCFieldVelocityNS_9allocatorIS1_EEEC2B8ne180100IJES3_Li0EEES3_DpOT_(_QWORD *a1)
{
  a1[2] = 0;
  *a1 = &unk_24C0E8C48;
  a1[1] = 0;
  PKCFieldVelocity::PKCFieldVelocity((PKCFieldVelocity *)(a1 + 8));
  return a1;
}

void sub_208FA3BE0(_Unwind_Exception *a1)
{
  std::__shared_weak_count *v1;

  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<PKCFieldVelocity>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_24C0E8C48;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<PKCFieldVelocity>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_24C0E8C48;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x20BD0BA58);
}

uint64_t std::__shared_ptr_emplace<PKCFieldVelocity>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 64))(a1 + 64);
}

_QWORD *_ZNSt3__115allocate_sharedB8ne180100I13PKCFieldNoiseNS_9allocatorIS1_EEJEvEENS_10shared_ptrIT_EERKT0_DpOT1_@<X0>(_QWORD *a1@<X8>)
{
  _QWORD *v2;
  _QWORD *result;

  v2 = operator new(0x140uLL);
  result = _ZNSt3__120__shared_ptr_emplaceI13PKCFieldNoiseNS_9allocatorIS1_EEEC2B8ne180100IJES3_Li0EEES3_DpOT_(v2);
  *a1 = v2 + 8;
  a1[1] = v2;
  return result;
}

void sub_208FA3C80(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

_QWORD *_ZNSt3__120__shared_ptr_emplaceI13PKCFieldNoiseNS_9allocatorIS1_EEEC2B8ne180100IJES3_Li0EEES3_DpOT_(_QWORD *a1)
{
  a1[2] = 0;
  *a1 = &unk_24C0E8AF8;
  a1[1] = 0;
  PKCFieldNoise::PKCFieldNoise((PKCFieldNoise *)(a1 + 8));
  return a1;
}

void sub_208FA3CCC(_Unwind_Exception *a1)
{
  std::__shared_weak_count *v1;

  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<PKCFieldNoise>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_24C0E8AF8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<PKCFieldNoise>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_24C0E8AF8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x20BD0BA58);
}

uint64_t std::__shared_ptr_emplace<PKCFieldNoise>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 64))(a1 + 64);
}

_QWORD *_ZNSt3__115allocate_sharedB8ne180100I18PKCFieldTurbulenceNS_9allocatorIS1_EEJEvEENS_10shared_ptrIT_EERKT0_DpOT1_@<X0>(_QWORD *a1@<X8>)
{
  _QWORD *v2;
  _QWORD *result;

  v2 = operator new(0x140uLL);
  result = _ZNSt3__120__shared_ptr_emplaceI18PKCFieldTurbulenceNS_9allocatorIS1_EEEC2B8ne180100IJES3_Li0EEES3_DpOT_(v2);
  *a1 = v2 + 8;
  a1[1] = v2;
  return result;
}

void sub_208FA3D6C(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

_QWORD *_ZNSt3__120__shared_ptr_emplaceI18PKCFieldTurbulenceNS_9allocatorIS1_EEEC2B8ne180100IJES3_Li0EEES3_DpOT_(_QWORD *a1)
{
  a1[2] = 0;
  *a1 = &unk_24C0E8C80;
  a1[1] = 0;
  PKCFieldTurbulence::PKCFieldTurbulence((PKCFieldTurbulence *)(a1 + 8));
  return a1;
}

void sub_208FA3DB8(_Unwind_Exception *a1)
{
  std::__shared_weak_count *v1;

  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<PKCFieldTurbulence>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_24C0E8C80;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<PKCFieldTurbulence>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_24C0E8C80;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x20BD0BA58);
}

uint64_t std::__shared_ptr_emplace<PKCFieldTurbulence>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 64))(a1 + 64);
}

_QWORD *_ZNSt3__115allocate_sharedB8ne180100I14PKCFieldSpringNS_9allocatorIS1_EEJEvEENS_10shared_ptrIT_EERKT0_DpOT1_@<X0>(_QWORD *a1@<X8>)
{
  _QWORD *v2;
  _QWORD *result;

  v2 = operator new(0x140uLL);
  result = _ZNSt3__120__shared_ptr_emplaceI14PKCFieldSpringNS_9allocatorIS1_EEEC2B8ne180100IJES3_Li0EEES3_DpOT_(v2);
  *a1 = v2 + 8;
  a1[1] = v2;
  return result;
}

void sub_208FA3E58(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

_QWORD *_ZNSt3__120__shared_ptr_emplaceI14PKCFieldSpringNS_9allocatorIS1_EEEC2B8ne180100IJES3_Li0EEES3_DpOT_(_QWORD *a1)
{
  a1[2] = 0;
  *a1 = &unk_24C0E8B68;
  a1[1] = 0;
  PKCFieldSpring::PKCFieldSpring((PKCFieldSpring *)(a1 + 8));
  return a1;
}

void sub_208FA3EA4(_Unwind_Exception *a1)
{
  std::__shared_weak_count *v1;

  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<PKCFieldSpring>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_24C0E8B68;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<PKCFieldSpring>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_24C0E8B68;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x20BD0BA58);
}

uint64_t std::__shared_ptr_emplace<PKCFieldSpring>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 64))(a1 + 64);
}

_QWORD *_ZNSt3__115allocate_sharedB8ne180100I16PKCFieldMagneticNS_9allocatorIS1_EEJEvEENS_10shared_ptrIT_EERKT0_DpOT1_@<X0>(_QWORD *a1@<X8>)
{
  _QWORD *v2;
  _QWORD *result;

  v2 = operator new(0x140uLL);
  result = _ZNSt3__120__shared_ptr_emplaceI16PKCFieldMagneticNS_9allocatorIS1_EEEC2B8ne180100IJES3_Li0EEES3_DpOT_(v2);
  *a1 = v2 + 8;
  a1[1] = v2;
  return result;
}

void sub_208FA3F44(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

_QWORD *_ZNSt3__120__shared_ptr_emplaceI16PKCFieldMagneticNS_9allocatorIS1_EEEC2B8ne180100IJES3_Li0EEES3_DpOT_(_QWORD *a1)
{
  a1[2] = 0;
  *a1 = &unk_24C0E8C10;
  a1[1] = 0;
  PKCFieldMagnetic::PKCFieldMagnetic((PKCFieldMagnetic *)(a1 + 8));
  return a1;
}

void sub_208FA3F90(_Unwind_Exception *a1)
{
  std::__shared_weak_count *v1;

  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<PKCFieldMagnetic>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_24C0E8C10;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<PKCFieldMagnetic>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_24C0E8C10;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x20BD0BA58);
}

uint64_t std::__shared_ptr_emplace<PKCFieldMagnetic>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 64))(a1 + 64);
}

_QWORD *_ZNSt3__115allocate_sharedB8ne180100I16PKCFieldElectricNS_9allocatorIS1_EEJEvEENS_10shared_ptrIT_EERKT0_DpOT1_@<X0>(_QWORD *a1@<X8>)
{
  _QWORD *v2;
  _QWORD *result;

  v2 = operator new(0x140uLL);
  result = _ZNSt3__120__shared_ptr_emplaceI16PKCFieldElectricNS_9allocatorIS1_EEEC2B8ne180100IJES3_Li0EEES3_DpOT_(v2);
  *a1 = v2 + 8;
  a1[1] = v2;
  return result;
}

void sub_208FA4030(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

_QWORD *_ZNSt3__120__shared_ptr_emplaceI16PKCFieldElectricNS_9allocatorIS1_EEEC2B8ne180100IJES3_Li0EEES3_DpOT_(_QWORD *a1)
{
  a1[2] = 0;
  *a1 = &unk_24C0E8BD8;
  a1[1] = 0;
  PKCFieldElectric::PKCFieldElectric((PKCFieldElectric *)(a1 + 8));
  return a1;
}

void sub_208FA407C(_Unwind_Exception *a1)
{
  std::__shared_weak_count *v1;

  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<PKCFieldElectric>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_24C0E8BD8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<PKCFieldElectric>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_24C0E8BD8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x20BD0BA58);
}

uint64_t std::__shared_ptr_emplace<PKCFieldElectric>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 64))(a1 + 64);
}

PKDebugDrawPacket *PKDebugDrawPacket::clear(PKDebugDrawPacket *this)
{
  this->_linePoints.__end_ = this->_linePoints.__begin_;
  this->_colors.__end_ = this->_colors.__begin_;
  return this;
}

void sub_208FA4278(_Unwind_Exception *a1, uint64_t a2, ...)
{
  void *v2;
  va_list va;

  va_start(va, a2);
  PKQueryHandler::~PKQueryHandler((id *)va);

  _Unwind_Resume(a1);
}

void PKQueryHandler::~PKQueryHandler(id *this)
{
  *this = &off_24C0E8198;

  std::__hash_table<void *,std::hash<void *>,std::equal_to<void *>,std::allocator<void *>>::~__hash_table((uint64_t)(this + 3));
}

{
  *this = &off_24C0E8198;

  std::__hash_table<void *,std::hash<void *>,std::equal_to<void *>,std::allocator<void *>>::~__hash_table((uint64_t)(this + 3));
  JUMPOUT(0x20BD0BA58);
}

void sub_208FA4450(_Unwind_Exception *a1, uint64_t a2, ...)
{
  void *v2;
  va_list va;

  va_start(va, a2);
  PKQueryHandler::~PKQueryHandler((id *)va);

  _Unwind_Resume(a1);
}

void sub_208FA4598(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  void *v9;

  PKRayCastHandler::~PKRayCastHandler((PKRayCastHandler *)&a9);

  _Unwind_Resume(a1);
}

void PKRayCastHandler::issueCallbacks(PKRayCastHandler *this)
{
  char *v2;
  uint64_t i;
  id v4;
  BOOL (*v5)(uint64_t, uint64_t);

  v2 = (char *)this + 16;
  v5 = PKRayCastItemSortInline;
  std::list<PKRayCastItem>::__sort<BOOL (*)(PKRayCastItem,PKRayCastItem)>(*((_QWORD *)this + 3), (uint64_t)this + 16, *((_QWORD *)this + 4), (unsigned int (**)(id *, id *))&v5);
  for (i = *((_QWORD *)this + 3); (char *)i != v2; i = *(_QWORD *)(i + 8))
  {
    v4 = *(id *)(i + 16);
    (*(void (**)(double, double, double, double))(*((_QWORD *)this + 1) + 16))(*(double *)(i + 24), *(double *)(i + 32), *(double *)(i + 40), *(double *)(i + 48));

  }
}

void sub_208FA4660(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void PKRayCastHandler::~PKRayCastHandler(PKRayCastHandler *this)
{
  *(_QWORD *)this = &off_24C0E84A8;
  std::__list_imp<PKRayCastItem>::clear((uint64_t *)this + 2);

}

{
  *(_QWORD *)this = &off_24C0E84A8;
  std::__list_imp<PKRayCastItem>::clear((uint64_t *)this + 2);

  JUMPOUT(0x20BD0BA58);
}

void sub_208FA4754(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, id a20)
{
  _Block_object_dispose(&a15, 8);

  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy_(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose_(uint64_t a1)
{

}

void sub_208FA486C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, id a20)
{
  _Block_object_dispose(&a15, 8);

  _Unwind_Resume(a1);
}

void sub_208FA496C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, id a20)
{
  _Block_object_dispose(&a15, 8);

  _Unwind_Resume(a1);
}

void sub_208FA4B68(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BD0BA58](v1, 0x10B0C40B6F99122);
  _Unwind_Resume(a1);
}

void sub_208FA4BE4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_208FA4C78(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_208FA4F9C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_208FA50B0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  a9.super_class = (Class)PKPhysicsWorld;
  -[_Unwind_Exception dealloc](&a9, sel_dealloc);
  _Unwind_Resume(a1);
}

void sub_208FA5150(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_208FA5410(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_208FA54F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16)
{
  void *v16;

  _Unwind_Resume(a1);
}

void sub_208FA5630(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_208FA5810(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,id a31)
{
  void *v31;
  void *v32;

  _Block_object_dispose(&a26, 8);
  _Unwind_Resume(a1);
}

void sub_208FA5B14(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9)
{

  _Unwind_Resume(a1);
}

void sub_208FA5C70(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15)
{
  void *v15;

  _Unwind_Resume(a1);
}

void sub_208FA5DA8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

void sub_208FA5EFC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_208FA6160(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_208FA6258(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  void *v14;

  _Unwind_Resume(a1);
}

void sub_208FA6334(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12)
    std::__shared_weak_count::__release_weak(a12);
  std::shared_ptr<QuadTree>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void sub_208FA6414(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  void *v12;

  if (a12)
    std::__shared_weak_count::__release_weak(a12);
  std::shared_ptr<QuadTree>::~shared_ptr[abi:ne180100]((uint64_t)&a9);

  _Unwind_Resume(a1);
}

void sub_208FA6614(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  PKCAether::Evaluator::~Evaluator((PKCAether::Evaluator *)&a9);
  _Unwind_Resume(a1);
}

void PKCAether::Evaluator::~Evaluator(PKCAether::Evaluator *this)
{
  void *v2;
  void **v3;

  v2 = (void *)*((_QWORD *)this + 3);
  if (v2)
  {
    *((_QWORD *)this + 4) = v2;
    operator delete(v2);
  }
  v3 = (void **)this;
  std::vector<std::shared_ptr<PKCField>>::__destroy_vector::operator()[abi:ne180100](&v3);
}

void sub_208FA676C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  PKCAether::Evaluator::~Evaluator((PKCAether::Evaluator *)va);
  _Unwind_Resume(a1);
}

void sub_208FA6868(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  PKCAether::Evaluator::~Evaluator((PKCAether::Evaluator *)va);
  _Unwind_Resume(a1);
}

void sub_208FA6B40(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_208FA7130(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19)
{

  _Unwind_Resume(a1);
}

void PKDebugDraw::DrawSolidPolygon(uint64_t a1, int *a2, int a3, int *a4)
{
  unint64_t v8;
  int v9;
  int v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  _QWORD *v16;
  unint64_t v17;
  _QWORD *v18;
  _QWORD *v19;
  uint64_t v20;
  unint64_t v21;
  uint64_t v22;
  unint64_t v23;
  char *v24;
  char *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  _QWORD *v29;
  unint64_t v30;
  _QWORD *v31;
  _QWORD *v32;
  uint64_t v33;
  unint64_t v34;
  uint64_t v35;
  unint64_t v36;
  char *v37;
  char *v38;
  uint64_t v39;
  _QWORD *v40;
  char *v41;
  unint64_t v42;
  _DWORD *v43;
  char *v44;
  uint64_t v45;
  unint64_t v46;
  uint64_t v47;
  unint64_t v48;
  char *v49;
  char *v50;
  char *v51;
  _QWORD *v52;
  char *v53;
  unint64_t v54;
  _DWORD *v55;
  char *v56;
  uint64_t v57;
  unint64_t v58;
  uint64_t v59;
  unint64_t v60;
  char *v61;
  char *v62;
  char *v63;
  uint64_t v64;
  uint64_t v65;
  _QWORD *v66;
  unint64_t v67;
  _QWORD *v68;
  _QWORD *v69;
  uint64_t v70;
  unint64_t v71;
  uint64_t v72;
  unint64_t v73;
  char *v74;
  char *v75;
  char *v76;
  uint64_t v77;
  int v78;
  int v79;
  uint64_t v80;
  _DWORD *v81;
  unint64_t v82;
  _DWORD *v83;
  _DWORD *v84;
  uint64_t v85;
  unint64_t v86;
  uint64_t v87;
  unint64_t v88;
  char *v89;
  char *v90;
  char *v91;
  uint64_t v92;
  _QWORD *v93;
  char *v94;
  unint64_t v95;
  _DWORD *v96;
  char *v97;
  uint64_t v98;
  unint64_t v99;
  uint64_t v100;
  unint64_t v101;
  char *v102;
  char *v103;
  char *v104;
  _QWORD *v105;
  char *v106;
  unint64_t v107;
  _DWORD *v108;
  char *v109;
  uint64_t v110;
  unint64_t v111;
  uint64_t v112;
  unint64_t v113;
  char *v114;
  char *v115;
  char *v116;

  v8 = 2 * a3;
  std::vector<PKPoint>::reserve(*(void ***)(a1 + 16), v8);
  std::vector<PKDebugDrawPacket::color4>::reserve((void **)(*(_QWORD *)(a1 + 16) + 24), v8);
  v10 = *a4;
  v9 = a4[1];
  v11 = (a3 - 1);
  v12 = a4[2];
  if (a3 >= 2)
  {
    v13 = 0;
    do
    {
      v14 = *(_QWORD *)&a2[2 * v13];
      v15 = *(_QWORD *)(a1 + 16);
      v16 = *(_QWORD **)(v15 + 8);
      v17 = *(_QWORD *)(v15 + 16);
      if ((unint64_t)v16 >= v17)
      {
        v19 = *(_QWORD **)v15;
        v20 = ((uint64_t)v16 - *(_QWORD *)v15) >> 3;
        v21 = v20 + 1;
        if ((unint64_t)(v20 + 1) >> 61)
          goto LABEL_133;
        v22 = v17 - (_QWORD)v19;
        if (v22 >> 2 > v21)
          v21 = v22 >> 2;
        if ((unint64_t)v22 >= 0x7FFFFFFFFFFFFFF8)
          v23 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v23 = v21;
        if (v23)
        {
          v24 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKPoint>>(v15 + 16, v23);
          v19 = *(_QWORD **)v15;
          v16 = *(_QWORD **)(v15 + 8);
        }
        else
        {
          v24 = 0;
        }
        v25 = &v24[8 * v20];
        *(_QWORD *)v25 = v14;
        v18 = v25 + 8;
        if (v16 != v19)
        {
          do
          {
            v26 = *--v16;
            *((_QWORD *)v25 - 1) = v26;
            v25 -= 8;
          }
          while (v16 != v19);
          v19 = *(_QWORD **)v15;
        }
        *(_QWORD *)v15 = v25;
        *(_QWORD *)(v15 + 8) = v18;
        *(_QWORD *)(v15 + 16) = &v24[8 * v23];
        if (v19)
          operator delete(v19);
      }
      else
      {
        *v16 = v14;
        v18 = v16 + 1;
      }
      *(_QWORD *)(v15 + 8) = v18;
      ++v13;
      v27 = *(_QWORD *)&a2[2 * v13];
      v28 = *(_QWORD *)(a1 + 16);
      v29 = *(_QWORD **)(v28 + 8);
      v30 = *(_QWORD *)(v28 + 16);
      if ((unint64_t)v29 >= v30)
      {
        v32 = *(_QWORD **)v28;
        v33 = ((uint64_t)v29 - *(_QWORD *)v28) >> 3;
        v34 = v33 + 1;
        if ((unint64_t)(v33 + 1) >> 61)
          goto LABEL_133;
        v35 = v30 - (_QWORD)v32;
        if (v35 >> 2 > v34)
          v34 = v35 >> 2;
        if ((unint64_t)v35 >= 0x7FFFFFFFFFFFFFF8)
          v36 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v36 = v34;
        if (v36)
        {
          v37 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKPoint>>(v28 + 16, v36);
          v32 = *(_QWORD **)v28;
          v29 = *(_QWORD **)(v28 + 8);
        }
        else
        {
          v37 = 0;
        }
        v38 = &v37[8 * v33];
        *(_QWORD *)v38 = v27;
        v31 = v38 + 8;
        if (v29 != v32)
        {
          do
          {
            v39 = *--v29;
            *((_QWORD *)v38 - 1) = v39;
            v38 -= 8;
          }
          while (v29 != v32);
          v32 = *(_QWORD **)v28;
        }
        *(_QWORD *)v28 = v38;
        *(_QWORD *)(v28 + 8) = v31;
        *(_QWORD *)(v28 + 16) = &v37[8 * v36];
        if (v32)
          operator delete(v32);
      }
      else
      {
        *v29 = v27;
        v31 = v29 + 1;
      }
      *(_QWORD *)(v28 + 8) = v31;
      v40 = *(_QWORD **)(a1 + 16);
      v41 = (char *)v40[4];
      v42 = v40[5];
      if ((unint64_t)v41 >= v42)
      {
        v44 = (char *)v40[3];
        v45 = (v41 - v44) >> 4;
        v46 = v45 + 1;
        if ((unint64_t)(v45 + 1) >> 60)
          goto LABEL_134;
        v47 = v42 - (_QWORD)v44;
        if (v47 >> 3 > v46)
          v46 = v47 >> 3;
        if ((unint64_t)v47 >= 0x7FFFFFFFFFFFFFF0)
          v48 = 0xFFFFFFFFFFFFFFFLL;
        else
          v48 = v46;
        if (v48)
        {
          v49 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKDebugDrawPacket::color4>>((uint64_t)(v40 + 5), v48);
          v44 = (char *)v40[3];
          v41 = (char *)v40[4];
        }
        else
        {
          v49 = 0;
        }
        v50 = &v49[16 * v45];
        *(_DWORD *)v50 = v10;
        *((_DWORD *)v50 + 1) = v9;
        *((_DWORD *)v50 + 2) = v12;
        *((_DWORD *)v50 + 3) = 1065353216;
        v51 = v50;
        if (v41 != v44)
        {
          do
          {
            *((_OWORD *)v51 - 1) = *((_OWORD *)v41 - 1);
            v51 -= 16;
            v41 -= 16;
          }
          while (v41 != v44);
          v44 = (char *)v40[3];
        }
        v43 = v50 + 16;
        v40[3] = v51;
        v40[4] = v50 + 16;
        v40[5] = &v49[16 * v48];
        if (v44)
          operator delete(v44);
      }
      else
      {
        *(_DWORD *)v41 = v10;
        *((_DWORD *)v41 + 1) = v9;
        *((_DWORD *)v41 + 2) = v12;
        v43 = v41 + 16;
        *((_DWORD *)v41 + 3) = 1065353216;
      }
      v40[4] = v43;
      v52 = *(_QWORD **)(a1 + 16);
      v53 = (char *)v52[4];
      v54 = v52[5];
      if ((unint64_t)v53 >= v54)
      {
        v56 = (char *)v52[3];
        v57 = (v53 - v56) >> 4;
        v58 = v57 + 1;
        if ((unint64_t)(v57 + 1) >> 60)
LABEL_134:
          std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
        v59 = v54 - (_QWORD)v56;
        if (v59 >> 3 > v58)
          v58 = v59 >> 3;
        if ((unint64_t)v59 >= 0x7FFFFFFFFFFFFFF0)
          v60 = 0xFFFFFFFFFFFFFFFLL;
        else
          v60 = v58;
        if (v60)
        {
          v61 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKDebugDrawPacket::color4>>((uint64_t)(v52 + 5), v60);
          v56 = (char *)v52[3];
          v53 = (char *)v52[4];
        }
        else
        {
          v61 = 0;
        }
        v62 = &v61[16 * v57];
        *(_DWORD *)v62 = v10;
        *((_DWORD *)v62 + 1) = v9;
        *((_DWORD *)v62 + 2) = v12;
        *((_DWORD *)v62 + 3) = 1065353216;
        v63 = v62;
        if (v53 != v56)
        {
          do
          {
            *((_OWORD *)v63 - 1) = *((_OWORD *)v53 - 1);
            v63 -= 16;
            v53 -= 16;
          }
          while (v53 != v56);
          v56 = (char *)v52[3];
        }
        v55 = v62 + 16;
        v52[3] = v63;
        v52[4] = v62 + 16;
        v52[5] = &v61[16 * v60];
        if (v56)
          operator delete(v56);
      }
      else
      {
        *(_DWORD *)v53 = v10;
        *((_DWORD *)v53 + 1) = v9;
        *((_DWORD *)v53 + 2) = v12;
        v55 = v53 + 16;
        *((_DWORD *)v53 + 3) = 1065353216;
      }
      v52[4] = v55;
    }
    while (v13 != v11);
  }
  v64 = *(_QWORD *)&a2[2 * (int)v11];
  v65 = *(_QWORD *)(a1 + 16);
  v66 = *(_QWORD **)(v65 + 8);
  v67 = *(_QWORD *)(v65 + 16);
  if ((unint64_t)v66 >= v67)
  {
    v69 = *(_QWORD **)v65;
    v70 = ((uint64_t)v66 - *(_QWORD *)v65) >> 3;
    v71 = v70 + 1;
    if ((unint64_t)(v70 + 1) >> 61)
LABEL_133:
      std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
    v72 = v67 - (_QWORD)v69;
    if (v72 >> 2 > v71)
      v71 = v72 >> 2;
    if ((unint64_t)v72 >= 0x7FFFFFFFFFFFFFF8)
      v73 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v73 = v71;
    if (v73)
    {
      v74 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKPoint>>(v65 + 16, v73);
      v69 = *(_QWORD **)v65;
      v66 = *(_QWORD **)(v65 + 8);
    }
    else
    {
      v74 = 0;
    }
    v75 = &v74[8 * v70];
    v76 = &v74[8 * v73];
    *(_QWORD *)v75 = v64;
    v68 = v75 + 8;
    if (v66 != v69)
    {
      do
      {
        v77 = *--v66;
        *((_QWORD *)v75 - 1) = v77;
        v75 -= 8;
      }
      while (v66 != v69);
      v69 = *(_QWORD **)v65;
    }
    *(_QWORD *)v65 = v75;
    *(_QWORD *)(v65 + 8) = v68;
    *(_QWORD *)(v65 + 16) = v76;
    if (v69)
      operator delete(v69);
  }
  else
  {
    *v66 = v64;
    v68 = v66 + 1;
  }
  *(_QWORD *)(v65 + 8) = v68;
  v79 = *a2;
  v78 = a2[1];
  v80 = *(_QWORD *)(a1 + 16);
  v81 = *(_DWORD **)(v80 + 8);
  v82 = *(_QWORD *)(v80 + 16);
  if ((unint64_t)v81 >= v82)
  {
    v84 = *(_DWORD **)v80;
    v85 = ((uint64_t)v81 - *(_QWORD *)v80) >> 3;
    v86 = v85 + 1;
    if ((unint64_t)(v85 + 1) >> 61)
      std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
    v87 = v82 - (_QWORD)v84;
    if (v87 >> 2 > v86)
      v86 = v87 >> 2;
    if ((unint64_t)v87 >= 0x7FFFFFFFFFFFFFF8)
      v88 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v88 = v86;
    if (v88)
    {
      v89 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKPoint>>(v80 + 16, v88);
      v84 = *(_DWORD **)v80;
      v81 = *(_DWORD **)(v80 + 8);
    }
    else
    {
      v89 = 0;
    }
    v90 = &v89[8 * v85];
    v91 = &v89[8 * v88];
    *(_DWORD *)v90 = v79;
    *((_DWORD *)v90 + 1) = v78;
    v83 = v90 + 8;
    if (v81 != v84)
    {
      do
      {
        v92 = *((_QWORD *)v81 - 1);
        v81 -= 2;
        *((_QWORD *)v90 - 1) = v92;
        v90 -= 8;
      }
      while (v81 != v84);
      v84 = *(_DWORD **)v80;
    }
    *(_QWORD *)v80 = v90;
    *(_QWORD *)(v80 + 8) = v83;
    *(_QWORD *)(v80 + 16) = v91;
    if (v84)
      operator delete(v84);
  }
  else
  {
    *v81 = v79;
    v81[1] = v78;
    v83 = v81 + 2;
  }
  *(_QWORD *)(v80 + 8) = v83;
  v93 = *(_QWORD **)(a1 + 16);
  v94 = (char *)v93[4];
  v95 = v93[5];
  if ((unint64_t)v94 >= v95)
  {
    v97 = (char *)v93[3];
    v98 = (v94 - v97) >> 4;
    v99 = v98 + 1;
    if ((unint64_t)(v98 + 1) >> 60)
      std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
    v100 = v95 - (_QWORD)v97;
    if (v100 >> 3 > v99)
      v99 = v100 >> 3;
    if ((unint64_t)v100 >= 0x7FFFFFFFFFFFFFF0)
      v101 = 0xFFFFFFFFFFFFFFFLL;
    else
      v101 = v99;
    if (v101)
    {
      v102 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKDebugDrawPacket::color4>>((uint64_t)(v93 + 5), v101);
      v97 = (char *)v93[3];
      v94 = (char *)v93[4];
    }
    else
    {
      v102 = 0;
    }
    v103 = &v102[16 * v98];
    v104 = &v102[16 * v101];
    *(_DWORD *)v103 = v10;
    *((_DWORD *)v103 + 1) = v9;
    *((_DWORD *)v103 + 2) = v12;
    *((_DWORD *)v103 + 3) = 1065353216;
    v96 = v103 + 16;
    if (v94 != v97)
    {
      do
      {
        *((_OWORD *)v103 - 1) = *((_OWORD *)v94 - 1);
        v103 -= 16;
        v94 -= 16;
      }
      while (v94 != v97);
      v97 = (char *)v93[3];
    }
    v93[3] = v103;
    v93[4] = v96;
    v93[5] = v104;
    if (v97)
      operator delete(v97);
  }
  else
  {
    *(_DWORD *)v94 = v10;
    *((_DWORD *)v94 + 1) = v9;
    *((_DWORD *)v94 + 2) = v12;
    *((_DWORD *)v94 + 3) = 1065353216;
    v96 = v94 + 16;
  }
  v93[4] = v96;
  v105 = *(_QWORD **)(a1 + 16);
  v106 = (char *)v105[4];
  v107 = v105[5];
  if ((unint64_t)v106 >= v107)
  {
    v109 = (char *)v105[3];
    v110 = (v106 - v109) >> 4;
    v111 = v110 + 1;
    if ((unint64_t)(v110 + 1) >> 60)
      std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
    v112 = v107 - (_QWORD)v109;
    if (v112 >> 3 > v111)
      v111 = v112 >> 3;
    if ((unint64_t)v112 >= 0x7FFFFFFFFFFFFFF0)
      v113 = 0xFFFFFFFFFFFFFFFLL;
    else
      v113 = v111;
    if (v113)
    {
      v114 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKDebugDrawPacket::color4>>((uint64_t)(v105 + 5), v113);
      v109 = (char *)v105[3];
      v106 = (char *)v105[4];
    }
    else
    {
      v114 = 0;
    }
    v115 = &v114[16 * v110];
    v116 = &v114[16 * v113];
    *(_DWORD *)v115 = v10;
    *((_DWORD *)v115 + 1) = v9;
    *((_DWORD *)v115 + 2) = v12;
    *((_DWORD *)v115 + 3) = 1065353216;
    v108 = v115 + 16;
    if (v106 != v109)
    {
      do
      {
        *((_OWORD *)v115 - 1) = *((_OWORD *)v106 - 1);
        v115 -= 16;
        v106 -= 16;
      }
      while (v106 != v109);
      v109 = (char *)v105[3];
    }
    v105[3] = v115;
    v105[4] = v108;
    v105[5] = v116;
    if (v109)
      operator delete(v109);
  }
  else
  {
    *(_DWORD *)v106 = v10;
    *((_DWORD *)v106 + 1) = v9;
    *((_DWORD *)v106 + 2) = v12;
    *((_DWORD *)v106 + 3) = 1065353216;
    v108 = v106 + 16;
  }
  v105[4] = v108;
}

void sub_208FA7A78(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_208FA7B28(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

BOOL PKQueryHandler::ReportFixture(PKQueryHandler *this, id *a2)
{
  id v4;
  id v5;
  int v6;
  id v8;
  unsigned __int8 v9;

  v9 = 0;
  if (*((_BYTE *)this + 16)
    && !(*(unsigned int (**)(id, uint64_t, char *))(*(_QWORD *)a2[4] + 32))(a2[4], (uint64_t)a2[3] + 32, (char *)this + 8))
  {
    v6 = 0;
  }
  else
  {
    v4 = a2[9];
    if (v4 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
    {
      v5 = v4;
      v8 = v5;
      if (!std::__hash_table<void *,std::hash<void *>,std::equal_to<void *>,std::allocator<void *>>::find<void *>((_QWORD *)this + 3, &v8))
      {
        v8 = v5;
        std::__hash_table<void *,std::hash<void *>,std::equal_to<void *>,std::allocator<void *>>::__emplace_unique_key_args<void *,void *>((uint64_t)this + 24, &v8, &v8);
        (*(void (**)(void))(*((_QWORD *)this + 8) + 16))();
      }

      v6 = v9;
    }
    else
    {
      v6 = 0;
    }

  }
  return v6 == 0;
}

void sub_208FA7CB8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

_QWORD *std::__hash_table<void *,std::hash<void *>,std::equal_to<void *>,std::allocator<void *>>::find<void *>(_QWORD *a1, _QWORD *a2)
{
  int8x8_t v2;
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  uint8x8_t v6;
  unint64_t v7;
  _QWORD *v8;
  _QWORD *result;
  unint64_t v10;

  v2 = (int8x8_t)a1[1];
  if (!*(_QWORD *)&v2)
    return 0;
  v3 = 0x9DDFEA08EB382D69 * ((8 * *a2 + 8) ^ HIDWORD(*a2));
  v4 = 0x9DDFEA08EB382D69 * (HIDWORD(*a2) ^ (v3 >> 47) ^ v3);
  v5 = 0x9DDFEA08EB382D69 * (v4 ^ (v4 >> 47));
  v6 = (uint8x8_t)vcnt_s8(v2);
  v6.i16[0] = vaddlv_u8(v6);
  if (v6.u32[0] > 1uLL)
  {
    v7 = v5;
    if (v5 >= *(_QWORD *)&v2)
      v7 = v5 % *(_QWORD *)&v2;
  }
  else
  {
    v7 = v5 & (*(_QWORD *)&v2 - 1);
  }
  v8 = *(_QWORD **)(*a1 + 8 * v7);
  if (!v8)
    return 0;
  result = (_QWORD *)*v8;
  if (*v8)
  {
    do
    {
      v10 = result[1];
      if (v10 == v5)
      {
        if (result[2] == *a2)
          return result;
      }
      else
      {
        if (v6.u32[0] > 1uLL)
        {
          if (v10 >= *(_QWORD *)&v2)
            v10 %= *(_QWORD *)&v2;
        }
        else
        {
          v10 &= *(_QWORD *)&v2 - 1;
        }
        if (v10 != v7)
          return 0;
      }
      result = (_QWORD *)*result;
    }
    while (result);
  }
  return result;
}

_QWORD *std::__hash_table<void *,std::hash<void *>,std::equal_to<void *>,std::allocator<void *>>::__emplace_unique_key_args<void *,void *>(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  unint64_t v3;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint8x8_t v10;
  _QWORD **v11;
  _QWORD *i;
  unint64_t v13;
  float v14;
  float v15;
  _BOOL8 v16;
  unint64_t v17;
  unint64_t v18;
  size_t v19;
  uint64_t v20;
  _QWORD *v21;
  unint64_t v22;

  v6 = 0x9DDFEA08EB382D69 * ((8 * *a2 + 8) ^ HIDWORD(*a2));
  v7 = 0x9DDFEA08EB382D69 * (HIDWORD(*a2) ^ (v6 >> 47) ^ v6);
  v8 = 0x9DDFEA08EB382D69 * (v7 ^ (v7 >> 47));
  v9 = *(_QWORD *)(a1 + 8);
  if (v9)
  {
    v10 = (uint8x8_t)vcnt_s8((int8x8_t)v9);
    v10.i16[0] = vaddlv_u8(v10);
    if (v10.u32[0] > 1uLL)
    {
      v3 = 0x9DDFEA08EB382D69 * (v7 ^ (v7 >> 47));
      if (v8 >= v9)
        v3 = v8 % v9;
    }
    else
    {
      v3 = v8 & (v9 - 1);
    }
    v11 = *(_QWORD ***)(*(_QWORD *)a1 + 8 * v3);
    if (v11)
    {
      for (i = *v11; i; i = (_QWORD *)*i)
      {
        v13 = i[1];
        if (v13 == v8)
        {
          if (i[2] == *a2)
            return i;
        }
        else
        {
          if (v10.u32[0] > 1uLL)
          {
            if (v13 >= v9)
              v13 %= v9;
          }
          else
          {
            v13 &= v9 - 1;
          }
          if (v13 != v3)
            break;
        }
      }
    }
  }
  i = operator new(0x18uLL);
  *i = 0;
  i[1] = v8;
  i[2] = *a3;
  v14 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v15 = *(float *)(a1 + 32);
  if (!v9 || (float)(v15 * (float)v9) < v14)
  {
    v16 = 1;
    if (v9 >= 3)
      v16 = (v9 & (v9 - 1)) != 0;
    v17 = v16 | (2 * v9);
    v18 = vcvtps_u32_f32(v14 / v15);
    if (v17 <= v18)
      v19 = v18;
    else
      v19 = v17;
    std::__hash_table<void *,std::hash<void *>,std::equal_to<void *>,std::allocator<void *>>::__rehash<true>(a1, v19);
    v9 = *(_QWORD *)(a1 + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v8 >= v9)
        v3 = v8 % v9;
      else
        v3 = v8;
    }
    else
    {
      v3 = (v9 - 1) & v8;
    }
  }
  v20 = *(_QWORD *)a1;
  v21 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v3);
  if (v21)
  {
    *i = *v21;
LABEL_38:
    *v21 = i;
    goto LABEL_39;
  }
  *i = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = i;
  *(_QWORD *)(v20 + 8 * v3) = a1 + 16;
  if (*i)
  {
    v22 = *(_QWORD *)(*i + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v22 >= v9)
        v22 %= v9;
    }
    else
    {
      v22 &= v9 - 1;
    }
    v21 = (_QWORD *)(*(_QWORD *)a1 + 8 * v22);
    goto LABEL_38;
  }
LABEL_39:
  ++*(_QWORD *)(a1 + 24);
  return i;
}

void sub_208FA8004(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

void std::__hash_table<void *,std::hash<void *>,std::equal_to<void *>,std::allocator<void *>>::__rehash<true>(uint64_t a1, size_t __n)
{
  size_t prime;
  int8x8_t v4;
  unint64_t v5;
  uint8x8_t v6;
  uint64_t v7;

  if (__n == 1)
  {
    prime = 2;
  }
  else
  {
    prime = __n;
    if ((__n & (__n - 1)) != 0)
      prime = std::__next_prime(__n);
  }
  v4 = *(int8x8_t *)(a1 + 8);
  if (prime > *(_QWORD *)&v4)
    goto LABEL_16;
  if (prime < *(_QWORD *)&v4)
  {
    v5 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
    if (*(_QWORD *)&v4 < 3uLL || (v6 = (uint8x8_t)vcnt_s8(v4), v6.i16[0] = vaddlv_u8(v6), v6.u32[0] > 1uLL))
    {
      v5 = std::__next_prime(v5);
    }
    else
    {
      v7 = 1 << -(char)__clz(v5 - 1);
      if (v5 >= 2)
        v5 = v7;
    }
    if (prime <= v5)
      prime = v5;
    if (prime < *(_QWORD *)&v4)
LABEL_16:
      std::__hash_table<void *,std::hash<void *>,std::equal_to<void *>,std::allocator<void *>>::__do_rehash<true>(a1, prime);
  }
}

void std::__hash_table<void *,std::hash<void *>,std::equal_to<void *>,std::allocator<void *>>::__do_rehash<true>(uint64_t a1, unint64_t a2)
{
  void *v4;
  void *v5;
  uint64_t v6;
  _QWORD *v7;
  unint64_t v8;
  uint8x8_t v9;
  void *v10;
  _QWORD *v11;
  unint64_t v12;

  if (a2)
  {
    if (a2 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v4 = operator new(8 * a2);
    v5 = *(void **)a1;
    *(_QWORD *)a1 = v4;
    if (v5)
      operator delete(v5);
    v6 = 0;
    *(_QWORD *)(a1 + 8) = a2;
    do
      *(_QWORD *)(*(_QWORD *)a1 + 8 * v6++) = 0;
    while (a2 != v6);
    v7 = *(_QWORD **)(a1 + 16);
    if (v7)
    {
      v8 = v7[1];
      v9 = (uint8x8_t)vcnt_s8((int8x8_t)a2);
      v9.i16[0] = vaddlv_u8(v9);
      if (v9.u32[0] > 1uLL)
      {
        if (v8 >= a2)
          v8 %= a2;
      }
      else
      {
        v8 &= a2 - 1;
      }
      *(_QWORD *)(*(_QWORD *)a1 + 8 * v8) = a1 + 16;
      v11 = (_QWORD *)*v7;
      if (*v7)
      {
        do
        {
          v12 = v11[1];
          if (v9.u32[0] > 1uLL)
          {
            if (v12 >= a2)
              v12 %= a2;
          }
          else
          {
            v12 &= a2 - 1;
          }
          if (v12 != v8)
          {
            if (!*(_QWORD *)(*(_QWORD *)a1 + 8 * v12))
            {
              *(_QWORD *)(*(_QWORD *)a1 + 8 * v12) = v7;
              goto LABEL_24;
            }
            *v7 = *v11;
            *v11 = **(_QWORD **)(*(_QWORD *)a1 + 8 * v12);
            **(_QWORD **)(*(_QWORD *)a1 + 8 * v12) = v11;
            v11 = v7;
          }
          v12 = v8;
LABEL_24:
          v7 = v11;
          v11 = (_QWORD *)*v11;
          v8 = v12;
        }
        while (v11);
      }
    }
  }
  else
  {
    v10 = *(void **)a1;
    *(_QWORD *)a1 = 0;
    if (v10)
      operator delete(v10);
    *(_QWORD *)(a1 + 8) = 0;
  }
}

uint64_t std::__hash_table<void *,std::hash<void *>,std::equal_to<void *>,std::allocator<void *>>::~__hash_table(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  void *v4;

  v2 = *(_QWORD **)(a1 + 16);
  if (v2)
  {
    do
    {
      v3 = (_QWORD *)*v2;
      operator delete(v2);
      v2 = v3;
    }
    while (v3);
  }
  v4 = *(void **)a1;
  *(_QWORD *)a1 = 0;
  if (v4)
    operator delete(v4);
  return a1;
}

float PKRayCastHandler::ReportFixture(PKRayCastHandler *this, id *a2, const b2Vec2 *a3, const b2Vec2 *a4, float a5)
{
  id v8;
  id v9;
  float x;
  float v11;
  float y;
  float v13;
  float v14;
  float v15;
  float v16;
  float v17;
  float v18;
  double v19;
  float v20;
  double v21;
  double v22;
  double v23;
  id v24;
  id v26[6];

  v8 = a2[9];
  if (v8)
  {
    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) != 0)
    {
      v9 = v8;
      x = a3->x;
      v11 = PKGet_PTM_RATIO();
      y = a3->y;
      v13 = PKGet_PTM_RATIO();
      v14 = a4->x;
      v15 = PKGet_PTM_RATIO();
      v16 = a4->y;
      v17 = PKGet_PTM_RATIO();
      v18 = x * v11;
      v19 = (float)(x * v11);
      v20 = y * v13;
      v21 = (float)(y * v13);
      v22 = (float)(v16 * v17);
      v23 = (float)((float)((float)(v20 - *((float *)this + 11)) * (float)(v20 - *((float *)this + 11)))
                  + (float)((float)(v18 - *((float *)this + 10)) * (float)(v18 - *((float *)this + 10))));
      v24 = v9;
      v26[0] = v24;
      v26[1] = *(id *)&v19;
      v26[2] = *(id *)&v21;
      *(double *)&v26[3] = (float)(v14 * v15);
      v26[4] = *(id *)&v22;
      v26[5] = *(id *)&v23;
      std::list<PKRayCastItem>::push_back((uint64_t *)this + 2, (uint64_t)v26);

    }
  }

  return 1.0;
}

void sub_208FA8408(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9)
{
  void *v9;
  void *v10;

  _Unwind_Resume(a1);
}

__n128 std::list<PKRayCastItem>::push_back(uint64_t *a1, uint64_t a2)
{
  char *v4;
  id v5;
  __n128 result;
  uint64_t v7;

  v4 = (char *)operator new(0x40uLL);
  v5 = *(id *)a2;
  *((_QWORD *)v4 + 1) = a1;
  *((_QWORD *)v4 + 2) = v5;
  *(_OWORD *)(v4 + 24) = *(_OWORD *)(a2 + 8);
  result = *(__n128 *)(a2 + 24);
  *(__n128 *)(v4 + 40) = result;
  *((_QWORD *)v4 + 7) = *(_QWORD *)(a2 + 40);
  v7 = *a1;
  *(_QWORD *)v4 = *a1;
  *(_QWORD *)(v7 + 8) = v4;
  *a1 = (uint64_t)v4;
  ++a1[2];
  return result;
}

BOOL PKRayCastItemSortInline(uint64_t a1, uint64_t a2)
{
  _BOOL8 v3;

  v3 = *(double *)(a1 + 40) <= *(double *)(a2 + 40);

  return v3;
}

uint64_t std::list<PKRayCastItem>::__sort<BOOL (*)(PKRayCastItem,PKRayCastItem)>(uint64_t a1, uint64_t a2, unint64_t a3, unsigned int (**a4)(id *, id *))
{
  uint64_t v4;
  unsigned int (*v8)(id *, id *);
  uint64_t *v9;
  id v10;
  __int128 v11;
  uint64_t v12;
  id v13;
  __int128 v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v19;
  unint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unsigned int (*v23)(id *, id *);
  id v24;
  __int128 v25;
  uint64_t v26;
  id v27;
  __int128 v28;
  uint64_t v29;
  uint64_t v30;
  unsigned int (*v31)(id *, id *);
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t *v39;
  uint64_t v40;
  unsigned int (*v41)(id *, id *);
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  uint64_t v46;
  unsigned int (*v47)(id *, id *);
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t *v54;
  uint64_t v55;
  uint64_t v56;
  id v57;
  __int128 v58;
  __int128 v59;
  uint64_t v60;
  id v61;
  __int128 v62;
  __int128 v63;
  uint64_t v64;
  id v65;
  __int128 v66;
  __int128 v67;
  uint64_t v68;
  id v69;
  __int128 v70;
  __int128 v71;
  uint64_t v72;
  id v73;
  __int128 v74;
  __int128 v75;
  uint64_t v76;
  id v77;
  __int128 v78;
  __int128 v79;
  uint64_t v80;
  id v81;
  __int128 v82;
  __int128 v83;
  uint64_t v84;
  id v85;
  __int128 v86;
  __int128 v87;
  uint64_t v88;
  id v89;
  __int128 v90;
  __int128 v91;
  uint64_t v92;
  id v93;
  __int128 v94;
  __int128 v95;
  uint64_t v96;

  v4 = a1;
  if (a3 >= 2)
  {
    if (a3 == 2)
    {
      v8 = *a4;
      v9 = *(uint64_t **)a2;
      v10 = *(id *)(*(_QWORD *)a2 + 16);
      v11 = *(_OWORD *)(v9 + 3);
      v95 = *(_OWORD *)(v9 + 5);
      v12 = v9[7];
      v93 = v10;
      v96 = v12;
      v94 = v11;
      v13 = *(id *)(v4 + 16);
      v14 = *(_OWORD *)(v4 + 24);
      v91 = *(_OWORD *)(v4 + 40);
      v15 = *(_QWORD *)(v4 + 56);
      v89 = v13;
      v92 = v15;
      v90 = v14;
      if (v8(&v93, &v89))
      {
        v16 = *v9;
        *(_QWORD *)(v16 + 8) = v9[1];
        *(_QWORD *)v9[1] = v16;
        v17 = *(_QWORD *)v4;
        *(_QWORD *)(v17 + 8) = v9;
        *v9 = v17;
        *(_QWORD *)v4 = v9;
        v9[1] = v4;
        return (uint64_t)v9;
      }
    }
    else
    {
      v19 = a3 >> 1;
      v20 = (a3 >> 1) + 1;
      v21 = a1;
      do
      {
        v21 = *(_QWORD *)(v21 + 8);
        --v20;
      }
      while (v20 > 1);
      v22 = std::list<PKRayCastItem>::__sort<BOOL (*)(PKRayCastItem,PKRayCastItem)>(a1, v21, a3 >> 1, a4);
      v4 = std::list<PKRayCastItem>::__sort<BOOL (*)(PKRayCastItem,PKRayCastItem)>(v21, a2, a3 - v19, a4);
      v23 = *a4;
      v24 = *(id *)(v4 + 16);
      v25 = *(_OWORD *)(v4 + 24);
      v87 = *(_OWORD *)(v4 + 40);
      v26 = *(_QWORD *)(v4 + 56);
      v85 = v24;
      v88 = v26;
      v86 = v25;
      v27 = *(id *)(v22 + 16);
      v28 = *(_OWORD *)(v22 + 24);
      v83 = *(_OWORD *)(v22 + 40);
      v29 = *(_QWORD *)(v22 + 56);
      v81 = v27;
      v84 = v29;
      v82 = v28;
      if (v23(&v85, &v81))
      {
        v30 = *(_QWORD *)(v4 + 8);
        if (v30 == a2)
        {
LABEL_12:
          v30 = a2;
        }
        else
        {
          while (1)
          {
            v31 = *a4;
            v77 = *(id *)(v30 + 16);
            v32 = *(_OWORD *)(v30 + 24);
            v33 = *(_OWORD *)(v30 + 40);
            v80 = *(_QWORD *)(v30 + 56);
            v78 = v32;
            v79 = v33;
            v73 = *(id *)(v22 + 16);
            v34 = *(_OWORD *)(v22 + 24);
            v35 = *(_OWORD *)(v22 + 40);
            v76 = *(_QWORD *)(v22 + 56);
            v74 = v34;
            v75 = v35;
            if (!v31(&v77, &v73))
              break;
            v30 = *(_QWORD *)(v30 + 8);
            if (v30 == a2)
              goto LABEL_12;
          }
        }
        v36 = *(_QWORD *)v30;
        v37 = *(_QWORD *)v4;
        *(_QWORD *)(v37 + 8) = *(_QWORD *)(*(_QWORD *)v30 + 8);
        **(_QWORD **)(v36 + 8) = v37;
        v38 = *(_QWORD *)v22;
        v39 = *(uint64_t **)(v22 + 8);
        *(_QWORD *)(v38 + 8) = v4;
        *(_QWORD *)v4 = v38;
        *(_QWORD *)v22 = v36;
        *(_QWORD *)(v36 + 8) = v22;
      }
      else
      {
        v39 = *(uint64_t **)(v22 + 8);
        v30 = v4;
        v4 = v22;
      }
      if (v39 != (uint64_t *)v30 && v30 != a2)
      {
        v40 = v30;
        do
        {
          v56 = v40;
          v41 = *a4;
          v69 = *(id *)(v30 + 16);
          v42 = *(_OWORD *)(v30 + 24);
          v43 = *(_OWORD *)(v30 + 40);
          v72 = *(_QWORD *)(v30 + 56);
          v70 = v42;
          v71 = v43;
          v65 = (id)v39[2];
          v44 = *(_OWORD *)(v39 + 3);
          v45 = *(_OWORD *)(v39 + 5);
          v68 = v39[7];
          v66 = v44;
          v67 = v45;
          if (v41(&v69, &v65))
          {
            v46 = *(_QWORD *)(v30 + 8);
            if (v46 == a2)
            {
              v46 = a2;
            }
            else
            {
              while (1)
              {
                v47 = *a4;
                v61 = *(id *)(v46 + 16);
                v48 = *(_OWORD *)(v46 + 24);
                v49 = *(_OWORD *)(v46 + 40);
                v64 = *(_QWORD *)(v46 + 56);
                v62 = v48;
                v63 = v49;
                v57 = (id)v39[2];
                v50 = *(_OWORD *)(v39 + 3);
                v51 = *(_OWORD *)(v39 + 5);
                v60 = v39[7];
                v58 = v50;
                v59 = v51;
                if (!v47(&v61, &v57))
                  break;
                v46 = *(_QWORD *)(v46 + 8);
                if (v46 == a2)
                {
                  v46 = a2;
                  break;
                }
              }
            }
            v52 = *(_QWORD *)v46;
            v53 = *(_QWORD *)v30;
            *(_QWORD *)(v53 + 8) = *(_QWORD *)(*(_QWORD *)v46 + 8);
            **(_QWORD **)(v52 + 8) = v53;
            v40 = v56;
            if (v56 == v30)
              v40 = v46;
            v55 = *v39;
            v54 = (uint64_t *)v39[1];
            *(_QWORD *)(v55 + 8) = v30;
            *(_QWORD *)v30 = v55;
            *v39 = v52;
            *(_QWORD *)(v52 + 8) = v39;
            v39 = v54;
            v30 = v46;
          }
          else
          {
            v39 = (uint64_t *)v39[1];
            v40 = v56;
          }
        }
        while (v39 != (uint64_t *)v40 && v30 != a2);
      }
    }
  }
  return v4;
}

void std::__list_imp<PKRayCastItem>::clear(uint64_t *a1)
{
  uint64_t v2;
  uint64_t *v3;
  uint64_t v4;
  uint64_t *v5;

  if (a1[2])
  {
    v2 = *a1;
    v3 = (uint64_t *)a1[1];
    v4 = *v3;
    *(_QWORD *)(v4 + 8) = *(_QWORD *)(*a1 + 8);
    **(_QWORD **)(v2 + 8) = v4;
    a1[2] = 0;
    if (v3 != a1)
    {
      do
      {
        v5 = (uint64_t *)v3[1];

        operator delete(v3);
        v3 = v5;
      }
      while (v5 != a1);
    }
  }
}

void std::vector<std::shared_ptr<PKCField>>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v1;
  void *v2;
  uint64_t v4;
  void *v5;

  v1 = *a1;
  v2 = **a1;
  if (v2)
  {
    v4 = (uint64_t)v1[1];
    v5 = v2;
    if ((void *)v4 != v2)
    {
      do
        v4 = std::shared_ptr<QuadTree>::~shared_ptr[abi:ne180100](v4 - 16);
      while ((void *)v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void PKContactListener::~PKContactListener(PKContactListener *this)
{
  PKPhysicsContactDelegate **p_contactDelegate;
  NSMutableDictionary *contacts;

  this->_vptr$b2ContactListener = (void **)&off_24C0E8550;
  p_contactDelegate = &this->_contactDelegate;
  objc_storeWeak((id *)&this->_contactDelegate, 0);
  contacts = this->_contacts;
  this->_contacts = 0;

  objc_destroyWeak((id *)p_contactDelegate);
}

{
  PKContactListener::~PKContactListener(this);
  JUMPOUT(0x20BD0BA58);
}

void PKContactListener::BeginContact(PKContactListener *this, b2Contact *a2)
{
  PKContactListener::reportContact((uint64_t)this, (uint64_t)a2, 0);
}

void PKContactListener::EndContact(PKContactListener *this, b2Contact *a2)
{
  PKContactListener::reportContact((uint64_t)this, (uint64_t)a2, 0);
}

uint64_t PKContactListener::flushContacts(PKContactListener *this)
{
  void *v1;
  uint64_t v2;
  uint64_t v3;
  PKPhysicsContactDelegate **p_contactDelegate;
  uint64_t i;
  void *v6;
  id WeakRetained;
  char v8;
  id v9;
  id v10;
  char v11;
  id v12;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  _BYTE v19[128];
  uint64_t v20;

  v20 = *MEMORY[0x24BDAC8D0];
  v15 = 0u;
  v16 = 0u;
  v17 = 0u;
  v18 = 0u;
  -[NSMutableDictionary allValues](this->_contacts, "allValues");
  v1 = (void *)objc_claimAutoreleasedReturnValue();
  v2 = objc_msgSend(v1, "countByEnumeratingWithState:objects:count:", &v15, v19, 16);
  if (v2)
  {
    v3 = *(_QWORD *)v16;
    p_contactDelegate = &this->_contactDelegate;
    do
    {
      for (i = 0; i != v2; ++i)
      {
        if (*(_QWORD *)v16 != v3)
          objc_enumerationMutation(v1);
        v6 = *(void **)(*((_QWORD *)&v15 + 1) + 8 * i);
        if (objc_msgSend(v6, "didBegin"))
        {
          WeakRetained = objc_loadWeakRetained((id *)p_contactDelegate);
          v8 = objc_opt_respondsToSelector();

          if ((v8 & 1) != 0)
          {
            v9 = objc_loadWeakRetained((id *)p_contactDelegate);
            objc_msgSend(v9, "didBeginContact:", v6);

          }
        }
        if (objc_msgSend(v6, "didEnd"))
        {
          v10 = objc_loadWeakRetained((id *)p_contactDelegate);
          v11 = objc_opt_respondsToSelector();

          if ((v11 & 1) != 0)
          {
            v12 = objc_loadWeakRetained((id *)p_contactDelegate);
            objc_msgSend(v12, "didEndContact:", v6);

          }
        }
      }
      v2 = objc_msgSend(v1, "countByEnumeratingWithState:objects:count:", &v15, v19, 16);
    }
    while (v2);
  }

  return -[NSMutableDictionary removeAllObjects](this->_contacts, "removeAllObjects");
}

void sub_208FA8BD0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void PKContactListener::reportContact(uint64_t a1, uint64_t a2, float *a3)
{
  id WeakRetained;
  uint64_t v7;
  id v8;
  id v9;
  void *v10;
  void *v11;
  PKPhysicsContact *v12;
  void *v13;
  void *v14;
  double v15;
  uint64_t v16;
  double v17;
  float v18;
  float v19;
  float v20;
  float *v21;
  float v22;
  float v23[3];
  float v24;

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 16));

  if (a2 && WeakRetained && (*(_BYTE *)(a2 + 9) || a3 || *(_BYTE *)(a2 + 8)))
  {
    v7 = *(_QWORD *)(a2 + 88);
    v8 = *(id *)(*(_QWORD *)(a2 + 80) + 72);
    v9 = *(id *)(v7 + 72);
    v10 = *(void **)(a1 + 8);
    objc_msgSend(MEMORY[0x24BDD16E0], "numberWithUnsignedLong:", a2);
    v11 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v10, "objectForKey:", v11);
    v12 = (PKPhysicsContact *)objc_claimAutoreleasedReturnValue();

    if (!v12)
    {
      v12 = objc_alloc_init(PKPhysicsContact);
      -[PKPhysicsContact setBodyA:](v12, "setBodyA:", v8);
      -[PKPhysicsContact setBodyB:](v12, "setBodyB:", v9);
      -[PKPhysicsContact setCollisionImpulse:](v12, "setCollisionImpulse:", 0.0);
      v13 = *(void **)(a1 + 8);
      objc_msgSend(MEMORY[0x24BDD16E0], "numberWithUnsignedLong:", a2);
      v14 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v13, "setObject:forKey:", v12, v14);

    }
    *(float *)&v15 = b2WorldManifold::Initialize((uint64_t)v23, a2 + 104, (float *)(*(_QWORD *)(*(_QWORD *)(a2 + 80) + 24) + 32), (float *)(*(_QWORD *)(*(_QWORD *)(a2 + 88) + 24) + 32), *(float *)(*(_QWORD *)(*(_QWORD *)(a2 + 80) + 32) + 12), *(float *)(*(_QWORD *)(*(_QWORD *)(a2 + 88) + 32) + 12));
    v16 = *(unsigned int *)(a2 + 164);
    if ((int)v16 >= 1)
    {
      -[PKPhysicsContact collisionImpulse](v12, "collisionImpulse", v15);
      v18 = v17 * PKGet_INV_PTM_RATIO();
      v19 = v23[2];
      v20 = v24;
      if (a3)
      {
        v21 = &v24;
        do
        {
          if (*a3 > v18)
          {
            v19 = *(v21 - 1);
            v20 = *v21;
            v18 = *a3;
          }
          ++a3;
          v21 += 2;
          --v16;
        }
        while (v16);
      }
      -[PKPhysicsContact setCollisionImpulse:](v12, "setCollisionImpulse:", (float)(v18 * PKGet_PTM_RATIO()));
      -[PKPhysicsContact setContactNormal:](v12, "setContactNormal:", v23[0], v23[1]);
      v22 = PKGet_PTM_RATIO();
      -[PKPhysicsContact setContactPoint:](v12, "setContactPoint:", (float)(v19 * v22), (float)(v20 * PKGet_PTM_RATIO()));
    }
    if (*(_BYTE *)(a2 + 8))
      -[PKPhysicsContact setDidBegin:](v12, "setDidBegin:", 1);
    if (*(_BYTE *)(a2 + 9))
      -[PKPhysicsContact setDidEnd:](v12, "setDidEnd:", 1);
    *(_WORD *)(a2 + 8) = 0;

  }
}

void sub_208FA8E7C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void PKContactListener::PKContactListener(PKContactListener *this)
{
  NSMutableDictionary *v2;
  NSMutableDictionary *contacts;

  this->_vptr$b2ContactListener = (void **)&off_24C0E8550;
  this->_contacts = 0;
  this->_contactDelegate = 0;
  objc_storeWeak((id *)&this->_contactDelegate, 0);
  objc_msgSend(MEMORY[0x24BDBCED8], "dictionaryWithCapacity:", 0);
  v2 = (NSMutableDictionary *)objc_claimAutoreleasedReturnValue();
  contacts = this->_contacts;
  this->_contacts = v2;

}

void sub_208FA8F34(_Unwind_Exception *a1)
{
  uint64_t v1;
  id *v2;

  objc_destroyWeak(v2);

  _Unwind_Resume(a1);
}

void PKDebugDraw::~PKDebugDraw(PKDebugDraw *this)
{
  JUMPOUT(0x20BD0BA58);
}

void PKDebugDraw::DrawPolygon(uint64_t a1, int *a2, int a3, int *a4)
{
  unint64_t v8;
  int v9;
  int v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  _QWORD *v16;
  unint64_t v17;
  _QWORD *v18;
  _QWORD *v19;
  uint64_t v20;
  unint64_t v21;
  uint64_t v22;
  unint64_t v23;
  char *v24;
  char *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  _QWORD *v29;
  unint64_t v30;
  _QWORD *v31;
  _QWORD *v32;
  uint64_t v33;
  unint64_t v34;
  uint64_t v35;
  unint64_t v36;
  char *v37;
  char *v38;
  uint64_t v39;
  _QWORD *v40;
  char *v41;
  unint64_t v42;
  _DWORD *v43;
  char *v44;
  uint64_t v45;
  unint64_t v46;
  uint64_t v47;
  unint64_t v48;
  char *v49;
  char *v50;
  char *v51;
  _QWORD *v52;
  char *v53;
  unint64_t v54;
  _DWORD *v55;
  char *v56;
  uint64_t v57;
  unint64_t v58;
  uint64_t v59;
  unint64_t v60;
  char *v61;
  char *v62;
  char *v63;
  uint64_t v64;
  uint64_t v65;
  _QWORD *v66;
  unint64_t v67;
  _QWORD *v68;
  _QWORD *v69;
  uint64_t v70;
  unint64_t v71;
  uint64_t v72;
  unint64_t v73;
  char *v74;
  char *v75;
  char *v76;
  uint64_t v77;
  int v78;
  int v79;
  uint64_t v80;
  _DWORD *v81;
  unint64_t v82;
  _DWORD *v83;
  _DWORD *v84;
  uint64_t v85;
  unint64_t v86;
  uint64_t v87;
  unint64_t v88;
  char *v89;
  char *v90;
  char *v91;
  uint64_t v92;
  _QWORD *v93;
  char *v94;
  unint64_t v95;
  _DWORD *v96;
  char *v97;
  uint64_t v98;
  unint64_t v99;
  uint64_t v100;
  unint64_t v101;
  char *v102;
  char *v103;
  char *v104;
  _QWORD *v105;
  char *v106;
  unint64_t v107;
  _DWORD *v108;
  char *v109;
  uint64_t v110;
  unint64_t v111;
  uint64_t v112;
  unint64_t v113;
  char *v114;
  char *v115;
  char *v116;

  v8 = 2 * a3;
  std::vector<PKPoint>::reserve(*(void ***)(a1 + 16), v8);
  std::vector<PKDebugDrawPacket::color4>::reserve((void **)(*(_QWORD *)(a1 + 16) + 24), v8);
  v10 = *a4;
  v9 = a4[1];
  v11 = (a3 - 1);
  v12 = a4[2];
  if (a3 >= 2)
  {
    v13 = 0;
    do
    {
      v14 = *(_QWORD *)&a2[2 * v13];
      v15 = *(_QWORD *)(a1 + 16);
      v16 = *(_QWORD **)(v15 + 8);
      v17 = *(_QWORD *)(v15 + 16);
      if ((unint64_t)v16 >= v17)
      {
        v19 = *(_QWORD **)v15;
        v20 = ((uint64_t)v16 - *(_QWORD *)v15) >> 3;
        v21 = v20 + 1;
        if ((unint64_t)(v20 + 1) >> 61)
          goto LABEL_133;
        v22 = v17 - (_QWORD)v19;
        if (v22 >> 2 > v21)
          v21 = v22 >> 2;
        if ((unint64_t)v22 >= 0x7FFFFFFFFFFFFFF8)
          v23 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v23 = v21;
        if (v23)
        {
          v24 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKPoint>>(v15 + 16, v23);
          v19 = *(_QWORD **)v15;
          v16 = *(_QWORD **)(v15 + 8);
        }
        else
        {
          v24 = 0;
        }
        v25 = &v24[8 * v20];
        *(_QWORD *)v25 = v14;
        v18 = v25 + 8;
        if (v16 != v19)
        {
          do
          {
            v26 = *--v16;
            *((_QWORD *)v25 - 1) = v26;
            v25 -= 8;
          }
          while (v16 != v19);
          v19 = *(_QWORD **)v15;
        }
        *(_QWORD *)v15 = v25;
        *(_QWORD *)(v15 + 8) = v18;
        *(_QWORD *)(v15 + 16) = &v24[8 * v23];
        if (v19)
          operator delete(v19);
      }
      else
      {
        *v16 = v14;
        v18 = v16 + 1;
      }
      *(_QWORD *)(v15 + 8) = v18;
      ++v13;
      v27 = *(_QWORD *)&a2[2 * v13];
      v28 = *(_QWORD *)(a1 + 16);
      v29 = *(_QWORD **)(v28 + 8);
      v30 = *(_QWORD *)(v28 + 16);
      if ((unint64_t)v29 >= v30)
      {
        v32 = *(_QWORD **)v28;
        v33 = ((uint64_t)v29 - *(_QWORD *)v28) >> 3;
        v34 = v33 + 1;
        if ((unint64_t)(v33 + 1) >> 61)
          goto LABEL_133;
        v35 = v30 - (_QWORD)v32;
        if (v35 >> 2 > v34)
          v34 = v35 >> 2;
        if ((unint64_t)v35 >= 0x7FFFFFFFFFFFFFF8)
          v36 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v36 = v34;
        if (v36)
        {
          v37 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKPoint>>(v28 + 16, v36);
          v32 = *(_QWORD **)v28;
          v29 = *(_QWORD **)(v28 + 8);
        }
        else
        {
          v37 = 0;
        }
        v38 = &v37[8 * v33];
        *(_QWORD *)v38 = v27;
        v31 = v38 + 8;
        if (v29 != v32)
        {
          do
          {
            v39 = *--v29;
            *((_QWORD *)v38 - 1) = v39;
            v38 -= 8;
          }
          while (v29 != v32);
          v32 = *(_QWORD **)v28;
        }
        *(_QWORD *)v28 = v38;
        *(_QWORD *)(v28 + 8) = v31;
        *(_QWORD *)(v28 + 16) = &v37[8 * v36];
        if (v32)
          operator delete(v32);
      }
      else
      {
        *v29 = v27;
        v31 = v29 + 1;
      }
      *(_QWORD *)(v28 + 8) = v31;
      v40 = *(_QWORD **)(a1 + 16);
      v41 = (char *)v40[4];
      v42 = v40[5];
      if ((unint64_t)v41 >= v42)
      {
        v44 = (char *)v40[3];
        v45 = (v41 - v44) >> 4;
        v46 = v45 + 1;
        if ((unint64_t)(v45 + 1) >> 60)
          goto LABEL_134;
        v47 = v42 - (_QWORD)v44;
        if (v47 >> 3 > v46)
          v46 = v47 >> 3;
        if ((unint64_t)v47 >= 0x7FFFFFFFFFFFFFF0)
          v48 = 0xFFFFFFFFFFFFFFFLL;
        else
          v48 = v46;
        if (v48)
        {
          v49 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKDebugDrawPacket::color4>>((uint64_t)(v40 + 5), v48);
          v44 = (char *)v40[3];
          v41 = (char *)v40[4];
        }
        else
        {
          v49 = 0;
        }
        v50 = &v49[16 * v45];
        *(_DWORD *)v50 = v10;
        *((_DWORD *)v50 + 1) = v9;
        *((_DWORD *)v50 + 2) = v12;
        *((_DWORD *)v50 + 3) = 1065353216;
        v51 = v50;
        if (v41 != v44)
        {
          do
          {
            *((_OWORD *)v51 - 1) = *((_OWORD *)v41 - 1);
            v51 -= 16;
            v41 -= 16;
          }
          while (v41 != v44);
          v44 = (char *)v40[3];
        }
        v43 = v50 + 16;
        v40[3] = v51;
        v40[4] = v50 + 16;
        v40[5] = &v49[16 * v48];
        if (v44)
          operator delete(v44);
      }
      else
      {
        *(_DWORD *)v41 = v10;
        *((_DWORD *)v41 + 1) = v9;
        *((_DWORD *)v41 + 2) = v12;
        v43 = v41 + 16;
        *((_DWORD *)v41 + 3) = 1065353216;
      }
      v40[4] = v43;
      v52 = *(_QWORD **)(a1 + 16);
      v53 = (char *)v52[4];
      v54 = v52[5];
      if ((unint64_t)v53 >= v54)
      {
        v56 = (char *)v52[3];
        v57 = (v53 - v56) >> 4;
        v58 = v57 + 1;
        if ((unint64_t)(v57 + 1) >> 60)
LABEL_134:
          std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
        v59 = v54 - (_QWORD)v56;
        if (v59 >> 3 > v58)
          v58 = v59 >> 3;
        if ((unint64_t)v59 >= 0x7FFFFFFFFFFFFFF0)
          v60 = 0xFFFFFFFFFFFFFFFLL;
        else
          v60 = v58;
        if (v60)
        {
          v61 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKDebugDrawPacket::color4>>((uint64_t)(v52 + 5), v60);
          v56 = (char *)v52[3];
          v53 = (char *)v52[4];
        }
        else
        {
          v61 = 0;
        }
        v62 = &v61[16 * v57];
        *(_DWORD *)v62 = v10;
        *((_DWORD *)v62 + 1) = v9;
        *((_DWORD *)v62 + 2) = v12;
        *((_DWORD *)v62 + 3) = 1065353216;
        v63 = v62;
        if (v53 != v56)
        {
          do
          {
            *((_OWORD *)v63 - 1) = *((_OWORD *)v53 - 1);
            v63 -= 16;
            v53 -= 16;
          }
          while (v53 != v56);
          v56 = (char *)v52[3];
        }
        v55 = v62 + 16;
        v52[3] = v63;
        v52[4] = v62 + 16;
        v52[5] = &v61[16 * v60];
        if (v56)
          operator delete(v56);
      }
      else
      {
        *(_DWORD *)v53 = v10;
        *((_DWORD *)v53 + 1) = v9;
        *((_DWORD *)v53 + 2) = v12;
        v55 = v53 + 16;
        *((_DWORD *)v53 + 3) = 1065353216;
      }
      v52[4] = v55;
    }
    while (v13 != v11);
  }
  v64 = *(_QWORD *)&a2[2 * (int)v11];
  v65 = *(_QWORD *)(a1 + 16);
  v66 = *(_QWORD **)(v65 + 8);
  v67 = *(_QWORD *)(v65 + 16);
  if ((unint64_t)v66 >= v67)
  {
    v69 = *(_QWORD **)v65;
    v70 = ((uint64_t)v66 - *(_QWORD *)v65) >> 3;
    v71 = v70 + 1;
    if ((unint64_t)(v70 + 1) >> 61)
LABEL_133:
      std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
    v72 = v67 - (_QWORD)v69;
    if (v72 >> 2 > v71)
      v71 = v72 >> 2;
    if ((unint64_t)v72 >= 0x7FFFFFFFFFFFFFF8)
      v73 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v73 = v71;
    if (v73)
    {
      v74 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKPoint>>(v65 + 16, v73);
      v69 = *(_QWORD **)v65;
      v66 = *(_QWORD **)(v65 + 8);
    }
    else
    {
      v74 = 0;
    }
    v75 = &v74[8 * v70];
    v76 = &v74[8 * v73];
    *(_QWORD *)v75 = v64;
    v68 = v75 + 8;
    if (v66 != v69)
    {
      do
      {
        v77 = *--v66;
        *((_QWORD *)v75 - 1) = v77;
        v75 -= 8;
      }
      while (v66 != v69);
      v69 = *(_QWORD **)v65;
    }
    *(_QWORD *)v65 = v75;
    *(_QWORD *)(v65 + 8) = v68;
    *(_QWORD *)(v65 + 16) = v76;
    if (v69)
      operator delete(v69);
  }
  else
  {
    *v66 = v64;
    v68 = v66 + 1;
  }
  *(_QWORD *)(v65 + 8) = v68;
  v79 = *a2;
  v78 = a2[1];
  v80 = *(_QWORD *)(a1 + 16);
  v81 = *(_DWORD **)(v80 + 8);
  v82 = *(_QWORD *)(v80 + 16);
  if ((unint64_t)v81 >= v82)
  {
    v84 = *(_DWORD **)v80;
    v85 = ((uint64_t)v81 - *(_QWORD *)v80) >> 3;
    v86 = v85 + 1;
    if ((unint64_t)(v85 + 1) >> 61)
      std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
    v87 = v82 - (_QWORD)v84;
    if (v87 >> 2 > v86)
      v86 = v87 >> 2;
    if ((unint64_t)v87 >= 0x7FFFFFFFFFFFFFF8)
      v88 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v88 = v86;
    if (v88)
    {
      v89 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKPoint>>(v80 + 16, v88);
      v84 = *(_DWORD **)v80;
      v81 = *(_DWORD **)(v80 + 8);
    }
    else
    {
      v89 = 0;
    }
    v90 = &v89[8 * v85];
    v91 = &v89[8 * v88];
    *(_DWORD *)v90 = v79;
    *((_DWORD *)v90 + 1) = v78;
    v83 = v90 + 8;
    if (v81 != v84)
    {
      do
      {
        v92 = *((_QWORD *)v81 - 1);
        v81 -= 2;
        *((_QWORD *)v90 - 1) = v92;
        v90 -= 8;
      }
      while (v81 != v84);
      v84 = *(_DWORD **)v80;
    }
    *(_QWORD *)v80 = v90;
    *(_QWORD *)(v80 + 8) = v83;
    *(_QWORD *)(v80 + 16) = v91;
    if (v84)
      operator delete(v84);
  }
  else
  {
    *v81 = v79;
    v81[1] = v78;
    v83 = v81 + 2;
  }
  *(_QWORD *)(v80 + 8) = v83;
  v93 = *(_QWORD **)(a1 + 16);
  v94 = (char *)v93[4];
  v95 = v93[5];
  if ((unint64_t)v94 >= v95)
  {
    v97 = (char *)v93[3];
    v98 = (v94 - v97) >> 4;
    v99 = v98 + 1;
    if ((unint64_t)(v98 + 1) >> 60)
      std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
    v100 = v95 - (_QWORD)v97;
    if (v100 >> 3 > v99)
      v99 = v100 >> 3;
    if ((unint64_t)v100 >= 0x7FFFFFFFFFFFFFF0)
      v101 = 0xFFFFFFFFFFFFFFFLL;
    else
      v101 = v99;
    if (v101)
    {
      v102 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKDebugDrawPacket::color4>>((uint64_t)(v93 + 5), v101);
      v97 = (char *)v93[3];
      v94 = (char *)v93[4];
    }
    else
    {
      v102 = 0;
    }
    v103 = &v102[16 * v98];
    v104 = &v102[16 * v101];
    *(_DWORD *)v103 = v10;
    *((_DWORD *)v103 + 1) = v9;
    *((_DWORD *)v103 + 2) = v12;
    *((_DWORD *)v103 + 3) = 1065353216;
    v96 = v103 + 16;
    if (v94 != v97)
    {
      do
      {
        *((_OWORD *)v103 - 1) = *((_OWORD *)v94 - 1);
        v103 -= 16;
        v94 -= 16;
      }
      while (v94 != v97);
      v97 = (char *)v93[3];
    }
    v93[3] = v103;
    v93[4] = v96;
    v93[5] = v104;
    if (v97)
      operator delete(v97);
  }
  else
  {
    *(_DWORD *)v94 = v10;
    *((_DWORD *)v94 + 1) = v9;
    *((_DWORD *)v94 + 2) = v12;
    *((_DWORD *)v94 + 3) = 1065353216;
    v96 = v94 + 16;
  }
  v93[4] = v96;
  v105 = *(_QWORD **)(a1 + 16);
  v106 = (char *)v105[4];
  v107 = v105[5];
  if ((unint64_t)v106 >= v107)
  {
    v109 = (char *)v105[3];
    v110 = (v106 - v109) >> 4;
    v111 = v110 + 1;
    if ((unint64_t)(v110 + 1) >> 60)
      std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
    v112 = v107 - (_QWORD)v109;
    if (v112 >> 3 > v111)
      v111 = v112 >> 3;
    if ((unint64_t)v112 >= 0x7FFFFFFFFFFFFFF0)
      v113 = 0xFFFFFFFFFFFFFFFLL;
    else
      v113 = v111;
    if (v113)
    {
      v114 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKDebugDrawPacket::color4>>((uint64_t)(v105 + 5), v113);
      v109 = (char *)v105[3];
      v106 = (char *)v105[4];
    }
    else
    {
      v114 = 0;
    }
    v115 = &v114[16 * v110];
    v116 = &v114[16 * v113];
    *(_DWORD *)v115 = v10;
    *((_DWORD *)v115 + 1) = v9;
    *((_DWORD *)v115 + 2) = v12;
    *((_DWORD *)v115 + 3) = 1065353216;
    v108 = v115 + 16;
    if (v106 != v109)
    {
      do
      {
        *((_OWORD *)v115 - 1) = *((_OWORD *)v106 - 1);
        v115 -= 16;
        v106 -= 16;
      }
      while (v106 != v109);
      v109 = (char *)v105[3];
    }
    v105[3] = v115;
    v105[4] = v108;
    v105[5] = v116;
    if (v109)
      operator delete(v109);
  }
  else
  {
    *(_DWORD *)v106 = v10;
    *((_DWORD *)v106 + 1) = v9;
    *((_DWORD *)v106 + 2) = v12;
    *((_DWORD *)v106 + 3) = 1065353216;
    v108 = v106 + 16;
  }
  v105[4] = v108;
}

void PKDebugDraw::DrawCircle(uint64_t a1, float *a2, int *a3, float a4)
{
  int v7;
  int v8;
  int v9;
  float v10;
  __float2 v11;
  float v12;
  float v13;
  float v14;
  float v15;
  float v16;
  __float2 v17;
  uint64_t v18;
  float *v19;
  unint64_t v20;
  float *v21;
  float *v22;
  uint64_t v23;
  unint64_t v24;
  uint64_t v25;
  unint64_t v26;
  char *v27;
  float *v28;
  float *v29;
  uint64_t v30;
  float v31;
  float v32;
  uint64_t v33;
  float *v34;
  unint64_t v35;
  float *v36;
  int v37;
  int v38;
  int v39;
  float *v40;
  uint64_t v41;
  unint64_t v42;
  uint64_t v43;
  unint64_t v44;
  char *v45;
  float *v46;
  float *v47;
  uint64_t v48;
  _QWORD *v49;
  char *v50;
  unint64_t v51;
  _DWORD *v52;
  char *v53;
  uint64_t v54;
  unint64_t v55;
  uint64_t v56;
  unint64_t v57;
  char *v58;
  char *v59;
  char *v60;
  _QWORD *v61;
  char *v62;
  unint64_t v63;
  _DWORD *v64;
  char *v65;
  uint64_t v66;
  unint64_t v67;
  uint64_t v68;
  unint64_t v69;
  char *v70;
  char *v71;
  char *v72;
  int v73;
  int v74;
  int v75;

  v7 = *a3;
  v8 = a3[1];
  v9 = a3[2];
  std::vector<PKPoint>::reserve(*(void ***)(a1 + 16), 0x20uLL);
  std::vector<PKDebugDrawPacket::color4>::reserve((void **)(*(_QWORD *)(a1 + 16) + 24), 0x20uLL);
  v10 = 0.0;
  v74 = v8;
  v75 = v7;
  v73 = v9;
  do
  {
    v11 = __sincosf_stret(v10);
    v13 = *a2;
    v12 = a2[1];
    v14 = *a2 + (float)(a4 * v11.__cosval);
    v15 = a4;
    v16 = v12 + (float)(a4 * v11.__sinval);
    v10 = v10 + 0.3927;
    v17 = __sincosf_stret(v10);
    v18 = *(_QWORD *)(a1 + 16);
    v19 = *(float **)(v18 + 8);
    v20 = *(_QWORD *)(v18 + 16);
    if ((unint64_t)v19 >= v20)
    {
      v22 = *(float **)v18;
      v23 = ((uint64_t)v19 - *(_QWORD *)v18) >> 3;
      v24 = v23 + 1;
      if ((unint64_t)(v23 + 1) >> 61)
        goto LABEL_70;
      v25 = v20 - (_QWORD)v22;
      if (v25 >> 2 > v24)
        v24 = v25 >> 2;
      if ((unint64_t)v25 >= 0x7FFFFFFFFFFFFFF8)
        v26 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v26 = v24;
      if (v26)
      {
        v27 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKPoint>>(v18 + 16, v26);
        v22 = *(float **)v18;
        v19 = *(float **)(v18 + 8);
      }
      else
      {
        v27 = 0;
      }
      v28 = (float *)&v27[8 * v23];
      *v28 = v14;
      v28[1] = v16;
      v29 = v28;
      a4 = v15;
      if (v19 != v22)
      {
        do
        {
          v30 = *((_QWORD *)v19 - 1);
          v19 -= 2;
          *((_QWORD *)v29 - 1) = v30;
          v29 -= 2;
        }
        while (v19 != v22);
        v22 = *(float **)v18;
      }
      v21 = v28 + 2;
      *(_QWORD *)v18 = v29;
      *(_QWORD *)(v18 + 8) = v28 + 2;
      *(_QWORD *)(v18 + 16) = &v27[8 * v26];
      if (v22)
        operator delete(v22);
    }
    else
    {
      *v19 = v14;
      v19[1] = v16;
      v21 = v19 + 2;
      a4 = v15;
    }
    v31 = v13 + (float)(a4 * v17.__cosval);
    v32 = v12 + (float)(a4 * v17.__sinval);
    *(_QWORD *)(v18 + 8) = v21;
    v33 = *(_QWORD *)(a1 + 16);
    v34 = *(float **)(v33 + 8);
    v35 = *(_QWORD *)(v33 + 16);
    if ((unint64_t)v34 >= v35)
    {
      v40 = *(float **)v33;
      v41 = ((uint64_t)v34 - *(_QWORD *)v33) >> 3;
      v42 = v41 + 1;
      if ((unint64_t)(v41 + 1) >> 61)
LABEL_70:
        std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
      v43 = v35 - (_QWORD)v40;
      if (v43 >> 2 > v42)
        v42 = v43 >> 2;
      if ((unint64_t)v43 >= 0x7FFFFFFFFFFFFFF8)
        v44 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v44 = v42;
      if (v44)
      {
        v45 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKPoint>>(v33 + 16, v44);
        v40 = *(float **)v33;
        v34 = *(float **)(v33 + 8);
      }
      else
      {
        v45 = 0;
      }
      v46 = (float *)&v45[8 * v41];
      *v46 = v31;
      v46[1] = v32;
      v47 = v46;
      if (v34 == v40)
      {
        v38 = v74;
        v37 = v75;
        v39 = v73;
      }
      else
      {
        v38 = v74;
        v37 = v75;
        v39 = v73;
        do
        {
          v48 = *((_QWORD *)v34 - 1);
          v34 -= 2;
          *((_QWORD *)v47 - 1) = v48;
          v47 -= 2;
        }
        while (v34 != v40);
        v40 = *(float **)v33;
      }
      v36 = v46 + 2;
      *(_QWORD *)v33 = v47;
      *(_QWORD *)(v33 + 8) = v46 + 2;
      *(_QWORD *)(v33 + 16) = &v45[8 * v44];
      if (v40)
        operator delete(v40);
    }
    else
    {
      *v34 = v31;
      v34[1] = v32;
      v36 = v34 + 2;
      v38 = v74;
      v37 = v75;
      v39 = v73;
    }
    *(_QWORD *)(v33 + 8) = v36;
    v49 = *(_QWORD **)(a1 + 16);
    v50 = (char *)v49[4];
    v51 = v49[5];
    if ((unint64_t)v50 >= v51)
    {
      v53 = (char *)v49[3];
      v54 = (v50 - v53) >> 4;
      v55 = v54 + 1;
      if ((unint64_t)(v54 + 1) >> 60)
        goto LABEL_71;
      v56 = v51 - (_QWORD)v53;
      if (v56 >> 3 > v55)
        v55 = v56 >> 3;
      if ((unint64_t)v56 >= 0x7FFFFFFFFFFFFFF0)
        v57 = 0xFFFFFFFFFFFFFFFLL;
      else
        v57 = v55;
      if (v57)
      {
        v58 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKDebugDrawPacket::color4>>((uint64_t)(v49 + 5), v57);
        v53 = (char *)v49[3];
        v50 = (char *)v49[4];
      }
      else
      {
        v58 = 0;
      }
      v59 = &v58[16 * v54];
      *(_DWORD *)v59 = v37;
      *((_DWORD *)v59 + 1) = v38;
      *((_DWORD *)v59 + 2) = v39;
      *((_DWORD *)v59 + 3) = 1065353216;
      v60 = v59;
      if (v50 != v53)
      {
        do
        {
          *((_OWORD *)v60 - 1) = *((_OWORD *)v50 - 1);
          v60 -= 16;
          v50 -= 16;
        }
        while (v50 != v53);
        v53 = (char *)v49[3];
      }
      v52 = v59 + 16;
      v49[3] = v60;
      v49[4] = v59 + 16;
      v49[5] = &v58[16 * v57];
      if (v53)
        operator delete(v53);
    }
    else
    {
      *(_DWORD *)v50 = v37;
      *((_DWORD *)v50 + 1) = v38;
      *((_DWORD *)v50 + 2) = v39;
      v52 = v50 + 16;
      *((_DWORD *)v50 + 3) = 1065353216;
    }
    v49[4] = v52;
    v61 = *(_QWORD **)(a1 + 16);
    v62 = (char *)v61[4];
    v63 = v61[5];
    if ((unint64_t)v62 >= v63)
    {
      v65 = (char *)v61[3];
      v66 = (v62 - v65) >> 4;
      v67 = v66 + 1;
      if ((unint64_t)(v66 + 1) >> 60)
LABEL_71:
        std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
      v68 = v63 - (_QWORD)v65;
      if (v68 >> 3 > v67)
        v67 = v68 >> 3;
      if ((unint64_t)v68 >= 0x7FFFFFFFFFFFFFF0)
        v69 = 0xFFFFFFFFFFFFFFFLL;
      else
        v69 = v67;
      if (v69)
      {
        v70 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKDebugDrawPacket::color4>>((uint64_t)(v61 + 5), v69);
        v65 = (char *)v61[3];
        v62 = (char *)v61[4];
      }
      else
      {
        v70 = 0;
      }
      v71 = &v70[16 * v66];
      *(_DWORD *)v71 = v37;
      *((_DWORD *)v71 + 1) = v38;
      *((_DWORD *)v71 + 2) = v39;
      *((_DWORD *)v71 + 3) = 1065353216;
      v72 = v71;
      if (v62 != v65)
      {
        do
        {
          *((_OWORD *)v72 - 1) = *((_OWORD *)v62 - 1);
          v72 -= 16;
          v62 -= 16;
        }
        while (v62 != v65);
        v65 = (char *)v61[3];
      }
      v64 = v71 + 16;
      v61[3] = v72;
      v61[4] = v71 + 16;
      v61[5] = &v70[16 * v69];
      if (v65)
        operator delete(v65);
    }
    else
    {
      *(_DWORD *)v62 = v37;
      *((_DWORD *)v62 + 1) = v38;
      *((_DWORD *)v62 + 2) = v39;
      v64 = v62 + 16;
      *((_DWORD *)v62 + 3) = 1065353216;
    }
    v61[4] = v64;
  }
  while (v10 < 6.6758844);
}

void PKDebugDraw::DrawSolidCircle(uint64_t a1, float *a2, float a3, uint64_t a4, int *a5)
{
  int v8;
  int v9;
  int v10;
  float v11;
  __float2 v12;
  float v13;
  float v14;
  float v15;
  float v16;
  float v17;
  __float2 v18;
  uint64_t v19;
  float *v20;
  unint64_t v21;
  float *v22;
  float *v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;
  unint64_t v27;
  char *v28;
  float *v29;
  float *v30;
  uint64_t v31;
  float v32;
  float v33;
  uint64_t v34;
  float *v35;
  unint64_t v36;
  float *v37;
  int v38;
  int v39;
  int v40;
  float *v41;
  uint64_t v42;
  unint64_t v43;
  uint64_t v44;
  unint64_t v45;
  char *v46;
  float *v47;
  float *v48;
  uint64_t v49;
  _QWORD *v50;
  char *v51;
  unint64_t v52;
  _DWORD *v53;
  char *v54;
  uint64_t v55;
  unint64_t v56;
  uint64_t v57;
  unint64_t v58;
  char *v59;
  char *v60;
  char *v61;
  _QWORD *v62;
  char *v63;
  unint64_t v64;
  _DWORD *v65;
  char *v66;
  uint64_t v67;
  unint64_t v68;
  uint64_t v69;
  unint64_t v70;
  char *v71;
  char *v72;
  char *v73;
  int v74;
  int v75;
  int v76;

  v8 = *a5;
  v9 = a5[1];
  v10 = a5[2];
  std::vector<PKPoint>::reserve(*(void ***)(a1 + 16), 0x20uLL);
  std::vector<PKDebugDrawPacket::color4>::reserve((void **)(*(_QWORD *)(a1 + 16) + 24), 0x20uLL);
  v11 = 0.0;
  v75 = v9;
  v76 = v8;
  v74 = v10;
  do
  {
    v12 = __sincosf_stret(v11);
    v14 = *a2;
    v13 = a2[1];
    v15 = *a2 + (float)(a3 * v12.__cosval);
    v16 = a3;
    v17 = v13 + (float)(a3 * v12.__sinval);
    v11 = v11 + 0.3927;
    v18 = __sincosf_stret(v11);
    v19 = *(_QWORD *)(a1 + 16);
    v20 = *(float **)(v19 + 8);
    v21 = *(_QWORD *)(v19 + 16);
    if ((unint64_t)v20 >= v21)
    {
      v23 = *(float **)v19;
      v24 = ((uint64_t)v20 - *(_QWORD *)v19) >> 3;
      v25 = v24 + 1;
      if ((unint64_t)(v24 + 1) >> 61)
        goto LABEL_70;
      v26 = v21 - (_QWORD)v23;
      if (v26 >> 2 > v25)
        v25 = v26 >> 2;
      if ((unint64_t)v26 >= 0x7FFFFFFFFFFFFFF8)
        v27 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v27 = v25;
      if (v27)
      {
        v28 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKPoint>>(v19 + 16, v27);
        v23 = *(float **)v19;
        v20 = *(float **)(v19 + 8);
      }
      else
      {
        v28 = 0;
      }
      v29 = (float *)&v28[8 * v24];
      *v29 = v15;
      v29[1] = v17;
      v30 = v29;
      a3 = v16;
      if (v20 != v23)
      {
        do
        {
          v31 = *((_QWORD *)v20 - 1);
          v20 -= 2;
          *((_QWORD *)v30 - 1) = v31;
          v30 -= 2;
        }
        while (v20 != v23);
        v23 = *(float **)v19;
      }
      v22 = v29 + 2;
      *(_QWORD *)v19 = v30;
      *(_QWORD *)(v19 + 8) = v29 + 2;
      *(_QWORD *)(v19 + 16) = &v28[8 * v27];
      if (v23)
        operator delete(v23);
    }
    else
    {
      *v20 = v15;
      v20[1] = v17;
      v22 = v20 + 2;
      a3 = v16;
    }
    v32 = v14 + (float)(a3 * v18.__cosval);
    v33 = v13 + (float)(a3 * v18.__sinval);
    *(_QWORD *)(v19 + 8) = v22;
    v34 = *(_QWORD *)(a1 + 16);
    v35 = *(float **)(v34 + 8);
    v36 = *(_QWORD *)(v34 + 16);
    if ((unint64_t)v35 >= v36)
    {
      v41 = *(float **)v34;
      v42 = ((uint64_t)v35 - *(_QWORD *)v34) >> 3;
      v43 = v42 + 1;
      if ((unint64_t)(v42 + 1) >> 61)
LABEL_70:
        std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
      v44 = v36 - (_QWORD)v41;
      if (v44 >> 2 > v43)
        v43 = v44 >> 2;
      if ((unint64_t)v44 >= 0x7FFFFFFFFFFFFFF8)
        v45 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v45 = v43;
      if (v45)
      {
        v46 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKPoint>>(v34 + 16, v45);
        v41 = *(float **)v34;
        v35 = *(float **)(v34 + 8);
      }
      else
      {
        v46 = 0;
      }
      v47 = (float *)&v46[8 * v42];
      *v47 = v32;
      v47[1] = v33;
      v48 = v47;
      if (v35 == v41)
      {
        v39 = v75;
        v38 = v76;
        v40 = v74;
      }
      else
      {
        v39 = v75;
        v38 = v76;
        v40 = v74;
        do
        {
          v49 = *((_QWORD *)v35 - 1);
          v35 -= 2;
          *((_QWORD *)v48 - 1) = v49;
          v48 -= 2;
        }
        while (v35 != v41);
        v41 = *(float **)v34;
      }
      v37 = v47 + 2;
      *(_QWORD *)v34 = v48;
      *(_QWORD *)(v34 + 8) = v47 + 2;
      *(_QWORD *)(v34 + 16) = &v46[8 * v45];
      if (v41)
        operator delete(v41);
    }
    else
    {
      *v35 = v32;
      v35[1] = v33;
      v37 = v35 + 2;
      v39 = v75;
      v38 = v76;
      v40 = v74;
    }
    *(_QWORD *)(v34 + 8) = v37;
    v50 = *(_QWORD **)(a1 + 16);
    v51 = (char *)v50[4];
    v52 = v50[5];
    if ((unint64_t)v51 >= v52)
    {
      v54 = (char *)v50[3];
      v55 = (v51 - v54) >> 4;
      v56 = v55 + 1;
      if ((unint64_t)(v55 + 1) >> 60)
        goto LABEL_71;
      v57 = v52 - (_QWORD)v54;
      if (v57 >> 3 > v56)
        v56 = v57 >> 3;
      if ((unint64_t)v57 >= 0x7FFFFFFFFFFFFFF0)
        v58 = 0xFFFFFFFFFFFFFFFLL;
      else
        v58 = v56;
      if (v58)
      {
        v59 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKDebugDrawPacket::color4>>((uint64_t)(v50 + 5), v58);
        v54 = (char *)v50[3];
        v51 = (char *)v50[4];
      }
      else
      {
        v59 = 0;
      }
      v60 = &v59[16 * v55];
      *(_DWORD *)v60 = v38;
      *((_DWORD *)v60 + 1) = v39;
      *((_DWORD *)v60 + 2) = v40;
      *((_DWORD *)v60 + 3) = 1065353216;
      v61 = v60;
      if (v51 != v54)
      {
        do
        {
          *((_OWORD *)v61 - 1) = *((_OWORD *)v51 - 1);
          v61 -= 16;
          v51 -= 16;
        }
        while (v51 != v54);
        v54 = (char *)v50[3];
      }
      v53 = v60 + 16;
      v50[3] = v61;
      v50[4] = v60 + 16;
      v50[5] = &v59[16 * v58];
      if (v54)
        operator delete(v54);
    }
    else
    {
      *(_DWORD *)v51 = v38;
      *((_DWORD *)v51 + 1) = v39;
      *((_DWORD *)v51 + 2) = v40;
      v53 = v51 + 16;
      *((_DWORD *)v51 + 3) = 1065353216;
    }
    v50[4] = v53;
    v62 = *(_QWORD **)(a1 + 16);
    v63 = (char *)v62[4];
    v64 = v62[5];
    if ((unint64_t)v63 >= v64)
    {
      v66 = (char *)v62[3];
      v67 = (v63 - v66) >> 4;
      v68 = v67 + 1;
      if ((unint64_t)(v67 + 1) >> 60)
LABEL_71:
        std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
      v69 = v64 - (_QWORD)v66;
      if (v69 >> 3 > v68)
        v68 = v69 >> 3;
      if ((unint64_t)v69 >= 0x7FFFFFFFFFFFFFF0)
        v70 = 0xFFFFFFFFFFFFFFFLL;
      else
        v70 = v68;
      if (v70)
      {
        v71 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKDebugDrawPacket::color4>>((uint64_t)(v62 + 5), v70);
        v66 = (char *)v62[3];
        v63 = (char *)v62[4];
      }
      else
      {
        v71 = 0;
      }
      v72 = &v71[16 * v67];
      *(_DWORD *)v72 = v38;
      *((_DWORD *)v72 + 1) = v39;
      *((_DWORD *)v72 + 2) = v40;
      *((_DWORD *)v72 + 3) = 1065353216;
      v73 = v72;
      if (v63 != v66)
      {
        do
        {
          *((_OWORD *)v73 - 1) = *((_OWORD *)v63 - 1);
          v73 -= 16;
          v63 -= 16;
        }
        while (v63 != v66);
        v66 = (char *)v62[3];
      }
      v65 = v72 + 16;
      v62[3] = v73;
      v62[4] = v72 + 16;
      v62[5] = &v71[16 * v70];
      if (v66)
        operator delete(v66);
    }
    else
    {
      *(_DWORD *)v63 = v38;
      *((_DWORD *)v63 + 1) = v39;
      *((_DWORD *)v63 + 2) = v40;
      v65 = v63 + 16;
      *((_DWORD *)v63 + 3) = 1065353216;
    }
    v62[4] = v65;
  }
  while (v11 < 6.6758844);
}

void PKDebugDraw::DrawSegment(uint64_t a1, int *a2, int *a3, int *a4)
{
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  uint64_t v12;
  _DWORD *v13;
  unint64_t v14;
  _DWORD *v15;
  _DWORD *v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  unint64_t v20;
  char *v21;
  char *v22;
  char *v23;
  uint64_t v24;
  uint64_t v25;
  _DWORD *v26;
  unint64_t v27;
  _DWORD *v28;
  _DWORD *v29;
  uint64_t v30;
  unint64_t v31;
  uint64_t v32;
  unint64_t v33;
  char *v34;
  char *v35;
  char *v36;
  uint64_t v37;
  _QWORD *v38;
  char *v39;
  unint64_t v40;
  _DWORD *v41;
  char *v42;
  uint64_t v43;
  unint64_t v44;
  uint64_t v45;
  unint64_t v46;
  char *v47;
  char *v48;
  char *v49;
  _QWORD *v50;
  char *v51;
  unint64_t v52;
  _DWORD *v53;
  char *v54;
  uint64_t v55;
  unint64_t v56;
  uint64_t v57;
  unint64_t v58;
  char *v59;
  char *v60;
  char *v61;

  v6 = *a4;
  v5 = a4[1];
  v7 = a4[2];
  v9 = *a2;
  v8 = a2[1];
  v11 = *a3;
  v10 = a3[1];
  v12 = *(_QWORD *)(a1 + 16);
  v13 = *(_DWORD **)(v12 + 8);
  v14 = *(_QWORD *)(v12 + 16);
  if ((unint64_t)v13 >= v14)
  {
    v16 = *(_DWORD **)v12;
    v17 = ((uint64_t)v13 - *(_QWORD *)v12) >> 3;
    v18 = v17 + 1;
    if ((unint64_t)(v17 + 1) >> 61)
      goto LABEL_66;
    v19 = v14 - (_QWORD)v16;
    if (v19 >> 2 > v18)
      v18 = v19 >> 2;
    if ((unint64_t)v19 >= 0x7FFFFFFFFFFFFFF8)
      v20 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v20 = v18;
    if (v20)
    {
      v21 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKPoint>>(v12 + 16, v20);
      v16 = *(_DWORD **)v12;
      v13 = *(_DWORD **)(v12 + 8);
    }
    else
    {
      v21 = 0;
    }
    v22 = &v21[8 * v17];
    v23 = &v21[8 * v20];
    *(_DWORD *)v22 = v9;
    *((_DWORD *)v22 + 1) = v8;
    v15 = v22 + 8;
    if (v13 != v16)
    {
      do
      {
        v24 = *((_QWORD *)v13 - 1);
        v13 -= 2;
        *((_QWORD *)v22 - 1) = v24;
        v22 -= 8;
      }
      while (v13 != v16);
      v16 = *(_DWORD **)v12;
    }
    *(_QWORD *)v12 = v22;
    *(_QWORD *)(v12 + 8) = v15;
    *(_QWORD *)(v12 + 16) = v23;
    if (v16)
      operator delete(v16);
  }
  else
  {
    *v13 = v9;
    v13[1] = v8;
    v15 = v13 + 2;
  }
  *(_QWORD *)(v12 + 8) = v15;
  v25 = *(_QWORD *)(a1 + 16);
  v26 = *(_DWORD **)(v25 + 8);
  v27 = *(_QWORD *)(v25 + 16);
  if ((unint64_t)v26 < v27)
  {
    *v26 = v11;
    v26[1] = v10;
    v28 = v26 + 2;
    goto LABEL_33;
  }
  v29 = *(_DWORD **)v25;
  v30 = ((uint64_t)v26 - *(_QWORD *)v25) >> 3;
  v31 = v30 + 1;
  if ((unint64_t)(v30 + 1) >> 61)
LABEL_66:
    std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
  v32 = v27 - (_QWORD)v29;
  if (v32 >> 2 > v31)
    v31 = v32 >> 2;
  if ((unint64_t)v32 >= 0x7FFFFFFFFFFFFFF8)
    v33 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v33 = v31;
  if (v33)
  {
    v34 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKPoint>>(v25 + 16, v33);
    v29 = *(_DWORD **)v25;
    v26 = *(_DWORD **)(v25 + 8);
  }
  else
  {
    v34 = 0;
  }
  v35 = &v34[8 * v30];
  v36 = &v34[8 * v33];
  *(_DWORD *)v35 = v11;
  *((_DWORD *)v35 + 1) = v10;
  v28 = v35 + 8;
  if (v26 != v29)
  {
    do
    {
      v37 = *((_QWORD *)v26 - 1);
      v26 -= 2;
      *((_QWORD *)v35 - 1) = v37;
      v35 -= 8;
    }
    while (v26 != v29);
    v29 = *(_DWORD **)v25;
  }
  *(_QWORD *)v25 = v35;
  *(_QWORD *)(v25 + 8) = v28;
  *(_QWORD *)(v25 + 16) = v36;
  if (v29)
    operator delete(v29);
LABEL_33:
  *(_QWORD *)(v25 + 8) = v28;
  v38 = *(_QWORD **)(a1 + 16);
  v39 = (char *)v38[4];
  v40 = v38[5];
  if ((unint64_t)v39 >= v40)
  {
    v42 = (char *)v38[3];
    v43 = (v39 - v42) >> 4;
    v44 = v43 + 1;
    if ((unint64_t)(v43 + 1) >> 60)
      std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
    v45 = v40 - (_QWORD)v42;
    if (v45 >> 3 > v44)
      v44 = v45 >> 3;
    if ((unint64_t)v45 >= 0x7FFFFFFFFFFFFFF0)
      v46 = 0xFFFFFFFFFFFFFFFLL;
    else
      v46 = v44;
    if (v46)
    {
      v47 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKDebugDrawPacket::color4>>((uint64_t)(v38 + 5), v46);
      v42 = (char *)v38[3];
      v39 = (char *)v38[4];
    }
    else
    {
      v47 = 0;
    }
    v48 = &v47[16 * v43];
    v49 = &v47[16 * v46];
    *(_DWORD *)v48 = v6;
    *((_DWORD *)v48 + 1) = v5;
    *((_DWORD *)v48 + 2) = v7;
    *((_DWORD *)v48 + 3) = 1065353216;
    v41 = v48 + 16;
    if (v39 != v42)
    {
      do
      {
        *((_OWORD *)v48 - 1) = *((_OWORD *)v39 - 1);
        v48 -= 16;
        v39 -= 16;
      }
      while (v39 != v42);
      v42 = (char *)v38[3];
    }
    v38[3] = v48;
    v38[4] = v41;
    v38[5] = v49;
    if (v42)
      operator delete(v42);
  }
  else
  {
    *(_DWORD *)v39 = v6;
    *((_DWORD *)v39 + 1) = v5;
    *((_DWORD *)v39 + 2) = v7;
    *((_DWORD *)v39 + 3) = 1065353216;
    v41 = v39 + 16;
  }
  v38[4] = v41;
  v50 = *(_QWORD **)(a1 + 16);
  v51 = (char *)v50[4];
  v52 = v50[5];
  if ((unint64_t)v51 >= v52)
  {
    v54 = (char *)v50[3];
    v55 = (v51 - v54) >> 4;
    v56 = v55 + 1;
    if ((unint64_t)(v55 + 1) >> 60)
      std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
    v57 = v52 - (_QWORD)v54;
    if (v57 >> 3 > v56)
      v56 = v57 >> 3;
    if ((unint64_t)v57 >= 0x7FFFFFFFFFFFFFF0)
      v58 = 0xFFFFFFFFFFFFFFFLL;
    else
      v58 = v56;
    if (v58)
    {
      v59 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKDebugDrawPacket::color4>>((uint64_t)(v50 + 5), v58);
      v54 = (char *)v50[3];
      v51 = (char *)v50[4];
    }
    else
    {
      v59 = 0;
    }
    v60 = &v59[16 * v55];
    v61 = &v59[16 * v58];
    *(_DWORD *)v60 = v6;
    *((_DWORD *)v60 + 1) = v5;
    *((_DWORD *)v60 + 2) = v7;
    *((_DWORD *)v60 + 3) = 1065353216;
    v53 = v60 + 16;
    if (v51 != v54)
    {
      do
      {
        *((_OWORD *)v60 - 1) = *((_OWORD *)v51 - 1);
        v60 -= 16;
        v51 -= 16;
      }
      while (v51 != v54);
      v54 = (char *)v50[3];
    }
    v50[3] = v60;
    v50[4] = v53;
    v50[5] = v61;
    if (v54)
      operator delete(v54);
  }
  else
  {
    *(_DWORD *)v51 = v6;
    *((_DWORD *)v51 + 1) = v5;
    *((_DWORD *)v51 + 2) = v7;
    *((_DWORD *)v51 + 3) = 1065353216;
    v53 = v51 + 16;
  }
  v50[4] = v53;
}

double PKDebugDraw::FieldRegion(PKDebugDraw *this, b2Vec2 *a2, b2Vec2 *a3, int *a4)
{
  double result;

  __asm { FMOV            V0.2S, #-1.0 }
  *a2 = _D0;
  __asm { FMOV            V0.2S, #20.0 }
  *(double *)a3 = result;
  *a4 = 120;
  return result;
}

void PKDebugDraw::DrawFieldSample(uint64_t a1, float *a2, float *a3, int *a4)
{
  float v8;
  float v9;
  float v13;
  float v14;
  float v15;
  int v16;
  int v17;
  int v18;
  uint64_t v19;
  float *v20;
  unint64_t v21;
  float *v22;
  float *v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;
  unint64_t v27;
  char *v28;
  float *v29;
  char *v30;
  uint64_t v31;
  float v32;
  float v33;
  uint64_t v34;
  float *v35;
  unint64_t v36;
  float *v37;
  float *v38;
  uint64_t v39;
  unint64_t v40;
  uint64_t v41;
  unint64_t v42;
  char *v43;
  float *v44;
  char *v45;
  uint64_t v46;
  _QWORD *v47;
  char *v48;
  unint64_t v49;
  _DWORD *v50;
  char *v51;
  uint64_t v52;
  unint64_t v53;
  uint64_t v54;
  unint64_t v55;
  char *v56;
  char *v57;
  char *v58;
  _QWORD *v59;
  char *v60;
  unint64_t v61;
  _DWORD *v62;
  char *v63;
  uint64_t v64;
  unint64_t v65;
  uint64_t v66;
  unint64_t v67;
  char *v68;
  char *v69;
  char *v70;

  std::vector<PKPoint>::reserve(*(void ***)(a1 + 16), 0x1000uLL);
  std::vector<PKDebugDrawPacket::color4>::reserve((void **)(*(_QWORD *)(a1 + 16) + 24), 0x1000uLL);
  v8 = *a3;
  v9 = a3[1];
  if (*a3 > 4.0 || v8 < -4.0 || v9 > 4.0 || v9 < -4.0)
  {
    v13 = sqrtf((float)(v9 * v9) + (float)(v8 * v8));
    v8 = (float)(v8 * 4.0) / v13;
    v9 = (float)(v9 * 4.0) / v13;
  }
  v14 = *a2;
  v15 = a2[1];
  v17 = *a4;
  v16 = a4[1];
  v18 = a4[2];
  v19 = *(_QWORD *)(a1 + 16);
  v20 = *(float **)(v19 + 8);
  v21 = *(_QWORD *)(v19 + 16);
  if ((unint64_t)v20 >= v21)
  {
    v23 = *(float **)v19;
    v24 = ((uint64_t)v20 - *(_QWORD *)v19) >> 3;
    v25 = v24 + 1;
    if ((unint64_t)(v24 + 1) >> 61)
      goto LABEL_78;
    v26 = v21 - (_QWORD)v23;
    if (v26 >> 2 > v25)
      v25 = v26 >> 2;
    if ((unint64_t)v26 >= 0x7FFFFFFFFFFFFFF8)
      v27 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v27 = v25;
    if (v27)
    {
      v28 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKPoint>>(v19 + 16, v27);
      v23 = *(float **)v19;
      v20 = *(float **)(v19 + 8);
    }
    else
    {
      v28 = 0;
    }
    v29 = (float *)&v28[8 * v24];
    v30 = &v28[8 * v27];
    *v29 = v14;
    v29[1] = v15;
    v22 = v29 + 2;
    if (v20 != v23)
    {
      do
      {
        v31 = *((_QWORD *)v20 - 1);
        v20 -= 2;
        *((_QWORD *)v29 - 1) = v31;
        v29 -= 2;
      }
      while (v20 != v23);
      v23 = *(float **)v19;
    }
    *(_QWORD *)v19 = v29;
    *(_QWORD *)(v19 + 8) = v22;
    *(_QWORD *)(v19 + 16) = v30;
    if (v23)
      operator delete(v23);
  }
  else
  {
    *v20 = v14;
    v20[1] = v15;
    v22 = v20 + 2;
  }
  v32 = v14 + (float)(v8 * 0.05);
  v33 = v15 + (float)(v9 * 0.05);
  *(_QWORD *)(v19 + 8) = v22;
  v34 = *(_QWORD *)(a1 + 16);
  v35 = *(float **)(v34 + 8);
  v36 = *(_QWORD *)(v34 + 16);
  if ((unint64_t)v35 < v36)
  {
    *v35 = v32;
    v35[1] = v33;
    v37 = v35 + 2;
    goto LABEL_45;
  }
  v38 = *(float **)v34;
  v39 = ((uint64_t)v35 - *(_QWORD *)v34) >> 3;
  v40 = v39 + 1;
  if ((unint64_t)(v39 + 1) >> 61)
LABEL_78:
    std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
  v41 = v36 - (_QWORD)v38;
  if (v41 >> 2 > v40)
    v40 = v41 >> 2;
  if ((unint64_t)v41 >= 0x7FFFFFFFFFFFFFF8)
    v42 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v42 = v40;
  if (v42)
  {
    v43 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKPoint>>(v34 + 16, v42);
    v38 = *(float **)v34;
    v35 = *(float **)(v34 + 8);
  }
  else
  {
    v43 = 0;
  }
  v44 = (float *)&v43[8 * v39];
  v45 = &v43[8 * v42];
  *v44 = v32;
  v44[1] = v33;
  v37 = v44 + 2;
  if (v35 != v38)
  {
    do
    {
      v46 = *((_QWORD *)v35 - 1);
      v35 -= 2;
      *((_QWORD *)v44 - 1) = v46;
      v44 -= 2;
    }
    while (v35 != v38);
    v38 = *(float **)v34;
  }
  *(_QWORD *)v34 = v44;
  *(_QWORD *)(v34 + 8) = v37;
  *(_QWORD *)(v34 + 16) = v45;
  if (v38)
    operator delete(v38);
LABEL_45:
  *(_QWORD *)(v34 + 8) = v37;
  v47 = *(_QWORD **)(a1 + 16);
  v48 = (char *)v47[4];
  v49 = v47[5];
  if ((unint64_t)v48 >= v49)
  {
    v51 = (char *)v47[3];
    v52 = (v48 - v51) >> 4;
    v53 = v52 + 1;
    if ((unint64_t)(v52 + 1) >> 60)
      std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
    v54 = v49 - (_QWORD)v51;
    if (v54 >> 3 > v53)
      v53 = v54 >> 3;
    if ((unint64_t)v54 >= 0x7FFFFFFFFFFFFFF0)
      v55 = 0xFFFFFFFFFFFFFFFLL;
    else
      v55 = v53;
    if (v55)
    {
      v56 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKDebugDrawPacket::color4>>((uint64_t)(v47 + 5), v55);
      v51 = (char *)v47[3];
      v48 = (char *)v47[4];
    }
    else
    {
      v56 = 0;
    }
    v57 = &v56[16 * v52];
    v58 = &v56[16 * v55];
    *(_DWORD *)v57 = v17;
    *((_DWORD *)v57 + 1) = v16;
    *((_DWORD *)v57 + 2) = v18;
    *((_DWORD *)v57 + 3) = 1065353216;
    v50 = v57 + 16;
    if (v48 != v51)
    {
      do
      {
        *((_OWORD *)v57 - 1) = *((_OWORD *)v48 - 1);
        v57 -= 16;
        v48 -= 16;
      }
      while (v48 != v51);
      v51 = (char *)v47[3];
    }
    v47[3] = v57;
    v47[4] = v50;
    v47[5] = v58;
    if (v51)
      operator delete(v51);
  }
  else
  {
    *(_DWORD *)v48 = v17;
    *((_DWORD *)v48 + 1) = v16;
    *((_DWORD *)v48 + 2) = v18;
    *((_DWORD *)v48 + 3) = 1065353216;
    v50 = v48 + 16;
  }
  v47[4] = v50;
  v59 = *(_QWORD **)(a1 + 16);
  v60 = (char *)v59[4];
  v61 = v59[5];
  if ((unint64_t)v60 >= v61)
  {
    v63 = (char *)v59[3];
    v64 = (v60 - v63) >> 4;
    v65 = v64 + 1;
    if ((unint64_t)(v64 + 1) >> 60)
      std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
    v66 = v61 - (_QWORD)v63;
    if (v66 >> 3 > v65)
      v65 = v66 >> 3;
    if ((unint64_t)v66 >= 0x7FFFFFFFFFFFFFF0)
      v67 = 0xFFFFFFFFFFFFFFFLL;
    else
      v67 = v65;
    if (v67)
    {
      v68 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKDebugDrawPacket::color4>>((uint64_t)(v59 + 5), v67);
      v63 = (char *)v59[3];
      v60 = (char *)v59[4];
    }
    else
    {
      v68 = 0;
    }
    v69 = &v68[16 * v64];
    v70 = &v68[16 * v67];
    *(_DWORD *)v69 = v17;
    *((_DWORD *)v69 + 1) = v16;
    *((_DWORD *)v69 + 2) = v18;
    *((_DWORD *)v69 + 3) = 1065353216;
    v62 = v69 + 16;
    if (v60 != v63)
    {
      do
      {
        *((_OWORD *)v69 - 1) = *((_OWORD *)v60 - 1);
        v69 -= 16;
        v60 -= 16;
      }
      while (v60 != v63);
      v63 = (char *)v59[3];
    }
    v59[3] = v69;
    v59[4] = v62;
    v59[5] = v70;
    if (v63)
      operator delete(v63);
  }
  else
  {
    *(_DWORD *)v60 = v17;
    *((_DWORD *)v60 + 1) = v16;
    *((_DWORD *)v60 + 2) = v18;
    *((_DWORD *)v60 + 3) = 1065353216;
    v62 = v60 + 16;
  }
  v59[4] = v62;
}

void std::vector<PKDebugDrawPacket::color4>::reserve(void **a1, unint64_t a2)
{
  uint64_t v3;
  _BYTE *v4;
  int64_t v5;
  char *v6;
  char *v7;
  uint64_t v8;
  char *v9;
  char *v10;
  char *v11;
  char *v12;

  v4 = a1[2];
  v3 = (uint64_t)(a1 + 2);
  if (a2 > (v4 - (_BYTE *)*a1) >> 4)
  {
    if (a2 >> 60)
      std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
    v5 = (_BYTE *)a1[1] - (_BYTE *)*a1;
    v6 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKDebugDrawPacket::color4>>(v3, a2);
    v7 = &v6[v5 & 0xFFFFFFFFFFFFFFF0];
    v9 = &v6[16 * v8];
    v11 = (char *)*a1;
    v10 = (char *)a1[1];
    v12 = v7;
    if (v10 != *a1)
    {
      do
      {
        *((_OWORD *)v12 - 1) = *((_OWORD *)v10 - 1);
        v12 -= 16;
        v10 -= 16;
      }
      while (v10 != v11);
      v10 = (char *)*a1;
    }
    *a1 = v12;
    a1[1] = v7;
    a1[2] = v9;
    if (v10)
      operator delete(v10);
  }
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<PKDebugDrawPacket::color4>>(uint64_t a1, unint64_t a2)
{
  if (a2 >> 60)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(16 * a2);
}

float snoise1(float a1, double a2, int8x8_t a3)
{
  int v3;
  float32x2_t v4;
  int8x8_t v10;
  float32x2_t v11;
  float32x2_t v12;
  float32x2_t v13;

  v3 = (int)a1 - (a1 <= 0.0);
  v4.f32[0] = a1 - (float)v3;
  v4.f32[1] = v4.f32[0] + -1.0;
  __asm { FMOV            V1.2S, #1.0 }
  a3.i8[0] = perm[v3];
  a3.i8[4] = perm[(v3 + 1)];
  v10 = vand_s8(a3, (int8x8_t)0xFF000000FFLL);
  v11 = vadd_f32(vcvt_f32_s32((int32x2_t)(*(_QWORD *)&v10 & 0xFFFFFF07FFFFFF07)), _D1);
  v12 = vmls_f32(_D1, v4, v4);
  v13 = vmul_f32(v12, v12);
  return vaddv_f32(vmul_f32(vmul_f32(v13, v13), vmul_f32(v4, (float32x2_t)vbsl_s8((int8x8_t)vceqz_s32((int32x2_t)(*(_QWORD *)&v10 & 0xFFFFFF08FFFFFF08)), (int8x8_t)v11, (int8x8_t)vneg_f32(v11)))))* 0.25;
}

float snoise2(float a1, float a2)
{
  float v2;
  int v3;
  int v4;
  float v5;
  float v6;
  float v7;
  _BOOL4 v8;
  _BOOL4 v9;
  float v10;
  float v11;
  float v12;
  float v13;
  float v14;
  double v15;
  double v16;
  float v17;
  float v18;
  float v19;
  float v20;
  float v21;
  float v22;
  float v23;
  float v24;
  float v25;
  float v26;
  char v27;
  float v28;
  float v29;
  float v30;
  float v31;
  float v32;
  float v33;
  char v34;
  float v35;
  float v36;

  v2 = (float)(a1 + a2) * 0.366025403;
  v3 = (int)(float)(v2 + a1) - ((float)(v2 + a1) <= 0.0);
  v4 = (int)(float)(v2 + a2) - ((float)(v2 + a2) <= 0.0);
  v5 = (float)(v3 + v4) * 0.211324865;
  v6 = a1 - (float)((float)v3 - v5);
  v7 = a2 - (float)((float)v4 - v5);
  v8 = v6 > v7;
  v9 = v6 <= v7;
  v10 = 0.0;
  v11 = 1.0;
  if (v6 <= v7)
    v12 = 0.0;
  else
    v12 = 1.0;
  v13 = (float)(v6 - v12) + 0.211324865;
  if (v6 > v7)
    v11 = 0.0;
  v14 = (float)(v7 - v11) + 0.211324865;
  v15 = (float)(v6 + -1.0) + 0.42264973;
  v16 = (float)(v7 + -1.0) + 0.42264973;
  v17 = (float)(0.5 - (float)(v6 * v6)) - (float)(v7 * v7);
  v18 = 0.0;
  if (v17 >= 0.0)
  {
    v19 = (float)(v17 * v17) * (float)(v17 * v17);
    if ((perm[perm[v4] + (unint64_t)v3] & 4) != 0)
      v20 = v7;
    else
      v20 = v6;
    if ((perm[perm[v4] + (unint64_t)v3] & 4) == 0)
      v6 = v7;
    v21 = -v20;
    if ((perm[perm[v4] + (unint64_t)v3] & 1) == 0)
      v21 = v20;
    v22 = -2.0;
    if ((perm[perm[v4] + (unint64_t)v3] & 2) == 0)
      v22 = 2.0;
    v18 = v19 * (float)(v21 + (float)(v6 * v22));
  }
  v23 = v15;
  v25 = (float)(0.5 - (float)(v13 * v13)) - (float)(v14 * v14);
  if (v25 >= 0.0)
  {
    v26 = (float)(v25 * v25) * (float)(v25 * v25);
    v27 = perm[v3
             + v8
             + (unint64_t)perm[v4 + (unint64_t)v9]];
    if ((v27 & 4) != 0)
      v28 = v14;
    else
      v28 = v13;
    if ((v27 & 4) == 0)
      v13 = v14;
    v29 = -v28;
    if ((v27 & 1) == 0)
      v29 = v28;
    v30 = -2.0;
    if ((v27 & 2) == 0)
      v30 = 2.0;
    v10 = v26 * (float)(v29 + (float)(v13 * v30));
  }
  v24 = v16;
  v31 = (float)(0.5 - (float)(v23 * v23)) - (float)(v24 * v24);
  v32 = 0.0;
  if (v31 >= 0.0)
  {
    v33 = (float)(v31 * v31) * (float)(v31 * v31);
    v34 = perm[v3 + 1 + (unint64_t)perm[v4 + 1]];
    if ((v34 & 4) != 0)
      v35 = v16;
    else
      v35 = v23;
    if ((v34 & 4) == 0)
      v23 = v16;
    if ((v34 & 1) != 0)
      v35 = -v35;
    v36 = -2.0;
    if ((v34 & 2) == 0)
      v36 = 2.0;
    v32 = v33 * (float)(v35 + (float)(v23 * v36));
  }
  return (float)((float)(v18 + v10) + v32) * 40.0;
}

float snoise3(float a1, float a2, float a3)
{
  float v3;
  int v4;
  int v5;
  int v6;
  float v7;
  float v8;
  float v9;
  float v10;
  _BOOL4 v11;
  int v12;
  _BOOL4 v13;
  _BOOL4 v14;
  int v15;
  _BOOL4 v16;
  float v17;
  float v18;
  float v19;
  double v20;
  double v21;
  double v22;
  double v23;
  double v24;
  double v25;
  uint64_t v26;
  float v27;
  float v28;
  float v29;
  float v30;
  double v31;
  double v32;
  double v33;
  float v34;
  float v35;
  float v36;
  float v37;
  char v38;
  float v39;
  float v40;
  float v41;
  float v42;
  float v43;
  float v44;
  float v45;
  char v46;
  float v47;
  float v48;
  float v49;
  float v50;
  float v51;

  v3 = (float)((float)(a1 + a2) + a3) * 0.333333333;
  v4 = (int)(float)(v3 + a1) - ((float)(v3 + a1) <= 0.0);
  v5 = (int)(float)(v3 + a2) - ((float)(v3 + a2) <= 0.0);
  v6 = (int)(float)(v3 + a3) - ((float)(v3 + a3) <= 0.0);
  v7 = (float)(v4 + v5 + v6) * 0.166666667;
  v8 = a1 - (float)((float)v4 - v7);
  v9 = a2 - (float)((float)v5 - v7);
  v10 = a3 - (float)((float)v6 - v7);
  if (v8 >= v9)
  {
    v12 = 0;
    if (v9 < v10)
    {
      v15 = 0;
      v11 = v8 >= v10;
      v14 = v8 < v10;
      v13 = 1;
      goto LABEL_6;
    }
    v14 = 0;
    v16 = 0;
    v11 = 1;
    v13 = 1;
  }
  else
  {
    v11 = 0;
    if (v9 < v10)
    {
      v12 = 0;
      v13 = 0;
      v14 = 1;
      v15 = 1;
LABEL_6:
      v16 = 1;
      goto LABEL_10;
    }
    v14 = 0;
    v13 = v8 >= v10;
    v16 = v8 < v10;
    v12 = 1;
  }
  v15 = 1;
LABEL_10:
  v17 = (float)(v8 - (float)v11) + 0.166666667;
  v18 = (float)(v9 - (float)v12) + 0.166666667;
  v19 = (float)(v10 - (float)v14) + 0.166666667;
  v20 = (float)(v8 - (float)v13) + 0.333333334;
  v21 = (float)(v9 - (float)v15) + 0.333333334;
  v22 = (float)(v10 - (float)v16) + 0.333333334;
  v23 = (float)(v8 + -1.0);
  v24 = (float)(v9 + -1.0);
  v25 = (float)(v10 + -1.0);
  v26 = ((int)(float)(v3 + a3) - ((float)(v3 + a3) <= 0.0));
  v27 = (float)((float)(0.6 - (float)(v8 * v8)) - (float)(v9 * v9)) - (float)(v10 * v10);
  v28 = 0.0;
  v29 = 0.0;
  if (v27 >= 0.0)
  {
    if ((perm[perm[perm[v26] + (unint64_t)v5]
             + (unint64_t)v4] & 0xD) == 0xC)
      v10 = v8;
    if ((perm[perm[perm[v26] + (unint64_t)v5]
             + (unint64_t)v4] & 0xC) == 0)
      v10 = v9;
    if ((perm[perm[perm[v26] + (unint64_t)v5]
             + (unint64_t)v4] & 8) != 0)
      v8 = v9;
    if ((perm[perm[perm[v26] + (unint64_t)v5]
             + (unint64_t)v4] & 1) != 0)
      v8 = -v8;
    v30 = -v10;
    if ((perm[perm[perm[v26] + (unint64_t)v5]
             + (unint64_t)v4] & 2) == 0)
      v30 = v10;
    v29 = (float)((float)(v27 * v27) * (float)(v27 * v27)) * (float)(v8 + v30);
  }
  v31 = v23 + 0.500000001;
  v32 = v24 + 0.500000001;
  v33 = v25 + 0.500000001;
  v34 = v20;
  v35 = v21;
  v36 = v22;
  v37 = (float)((float)(0.6 - (float)(v17 * v17)) - (float)(v18 * v18)) - (float)(v19 * v19);
  if (v37 >= 0.0)
  {
    v38 = perm[v11
             + v4
             + (unint64_t)perm[v12
                                                     + v5
                                                     + (unint64_t)perm[v14
                                                                                             + (unint64_t)v26]]];
    if ((v38 & 0xD) == 0xC)
      v19 = v17;
    if ((v38 & 0xC) == 0)
      v19 = v18;
    if ((v38 & 8) != 0)
      v17 = v18;
    if ((v38 & 1) != 0)
      v17 = -v17;
    v39 = -v19;
    if ((v38 & 2) == 0)
      v39 = v19;
    v28 = (float)((float)(v37 * v37) * (float)(v37 * v37)) * (float)(v17 + v39);
  }
  v43 = (float)((float)(0.6 - (float)(v34 * v34)) - (float)(v35 * v35)) - (float)(v36 * v36);
  v44 = 0.0;
  v45 = 0.0;
  if (v43 >= 0.0)
  {
    v46 = perm[v13
             + v4
             + (unint64_t)perm[v15
                                                     + v5
                                                     + (unint64_t)perm[v16
                                                                                             + (unint64_t)v26]]];
    if ((v46 & 0xD) == 0xC)
      v36 = v34;
    if ((v46 & 0xC) == 0)
      v36 = v35;
    if ((v46 & 8) != 0)
      v34 = v35;
    if ((v46 & 1) != 0)
      v34 = -v34;
    v47 = -v36;
    if ((v46 & 2) == 0)
      v47 = v36;
    v45 = (float)((float)(v43 * v43) * (float)(v43 * v43)) * (float)(v34 + v47);
  }
  v40 = v31;
  v41 = v32;
  v42 = v33;
  v48 = (float)((float)(0.6 - (float)(v40 * v40)) - (float)(v41 * v41)) - (float)(v42 * v42);
  if (v48 >= 0.0)
  {
    v49 = (float)(v48 * v48) * (float)(v48 * v48);
    if ((perm[v4
             + 1
             + (unint64_t)perm[v5
                                                     + 1
                                                     + (unint64_t)perm[v26 + 1]]] & 0xD) == 0xC)
      v50 = v31;
    else
      v50 = v33;
    if ((perm[v4
             + 1
             + (unint64_t)perm[v5
                                                     + 1
                                                     + (unint64_t)perm[v26 + 1]]] & 0xC) == 0)
      v50 = v32;
    if ((perm[v4
             + 1
             + (unint64_t)perm[v5
                                                     + 1
                                                     + (unint64_t)perm[v26 + 1]]] & 8) != 0)
      v51 = v32;
    else
      v51 = v31;
    if ((perm[v4
             + 1
             + (unint64_t)perm[v5
                                                     + 1
                                                     + (unint64_t)perm[v26 + 1]]] & 1) != 0)
      v51 = -v51;
    if ((perm[v4
             + 1
             + (unint64_t)perm[v5
                                                     + 1
                                                     + (unint64_t)perm[v26 + 1]]] & 2) != 0)
      v50 = -v50;
    v44 = v49 * (float)(v51 + v50);
  }
  return (float)((float)((float)(v29 + v28) + v45) + v44) * 32.0;
}

float snoise4(float a1, float a2, float a3, float a4)
{
  float v4;
  int v5;
  int v6;
  int v7;
  int v8;
  float v9;
  float v10;
  float v11;
  float v12;
  float v13;
  float v14;
  float v15;
  _BOOL8 v16;
  float v17;
  uint64_t v18;
  unsigned int v19;
  _BOOL4 v20;
  unint64_t v21;
  unint64_t v22;
  unint64_t v23;
  float v24;
  float v25;
  float v26;
  _BOOL4 v27;
  unint64_t v28;
  unint64_t v29;
  unint64_t v30;
  float v31;
  _BOOL4 v32;
  float v33;
  _BOOL4 v34;
  float v35;
  _BOOL4 v36;
  unint64_t v37;
  float v38;
  BOOL v39;
  float v40;
  float v41;
  float v42;
  float v43;
  double v44;
  double v45;
  double v46;
  double v47;
  double v48;
  double v49;
  double v50;
  double v51;
  float v52;
  float v53;
  float v54;
  float v55;
  float v56;
  float v57;
  float v58;
  double v59;
  double v60;
  double v61;
  double v62;
  float v63;
  float v64;
  float v65;
  float v66;
  float v67;
  char v68;
  float v69;
  float v70;
  double v71;
  double v72;
  double v73;
  double v74;
  float v75;
  float v76;
  float v77;
  float v78;
  float v79;
  float v80;
  float v81;
  char v82;
  float v83;
  float v84;
  float v85;
  float v86;
  float v87;
  float v88;
  float v89;
  char v90;
  float v91;
  float v92;
  float v93;
  float v94;
  float v95;
  float v96;
  float v97;

  v4 = (float)((float)((float)(a1 + a2) + a3) + a4) * 0.309016994;
  v5 = (int)(float)(v4 + a1) - ((float)(v4 + a1) <= 0.0);
  v6 = (int)(float)(v4 + a2) - ((float)(v4 + a2) <= 0.0);
  v7 = (int)(float)(v4 + a3) - ((float)(v4 + a3) <= 0.0);
  v8 = (int)(float)(v4 + a4) - ((float)(v4 + a4) <= 0.0);
  v9 = (double)(v5 + v6 + v7 + v8) * 0.138196601;
  v10 = (float)v6 - v9;
  v11 = (float)v7 - v9;
  v12 = (float)v8 - v9;
  v13 = a1 - (float)((float)v5 - v9);
  v14 = a4 - v12;
  v15 = a2 - v10;
  v16 = v13 > (float)(a2 - v10);
  v17 = a3 - v11;
  v18 = (16 * (v13 > (float)(a3 - v11))) | (32 * v16) | (8 * (v15 > v17)) | (4 * (v13 > v14)) | (2 * (v15 > v14)) | (v17 > v14);
  v19 = simplex[4 * v18];
  v20 = v19 > 2;
  v21 = (0xC4008C00uLL >> v18) & 1;
  v22 = (0xA20000008AuLL >> v18) & 1;
  v23 = (0x101000101000101uLL >> v18) & 1;
  v24 = 0.0;
  v25 = 1.0;
  if (v19 <= 2)
    v26 = 0.0;
  else
    v26 = 1.0;
  v27 = v19 > 1;
  v28 = (0xC0000000C5008D88 >> v18) & 1;
  v29 = (0xA000A30000888BuLL >> v18) & 1;
  v30 = (0x1111000305000503uLL >> v18) & 1;
  if (v19 <= 1)
    v31 = 0.0;
  else
    v31 = 1.0;
  v39 = v19 == 0;
  v32 = v19 != 0;
  if (v39)
    v33 = 0.0;
  else
    v33 = 1.0;
  v39 = ((0x2E7FFF7F3AFF7274uLL >> v18) & 1) == 0;
  v34 = v39;
  if (v39)
    v35 = 1.0;
  else
    v35 = 0.0;
  v39 = ((0x7F4EFF5C7FFF7274uLL >> v18) & 1) == 0;
  v36 = v39;
  v37 = 0xAECEFFDCBAFFF2F4 >> v18;
  if (v39)
    v38 = 1.0;
  else
    v38 = 0.0;
  v39 = (v37 & 1) == 0;
  v40 = (float)(v13 - v26) + 0.138196601;
  v41 = (float)(v15 - (float)(int)v21) + 0.138196601;
  v42 = (float)(v17 - (float)(int)v22) + 0.138196601;
  v43 = (float)(v14 - (float)(int)v23) + 0.138196601;
  v44 = (float)(v13 - v31) + 0.276393202;
  v45 = (float)(v15 - (float)(int)v28) + 0.276393202;
  v46 = (float)(v17 - (float)(int)v29) + 0.276393202;
  v47 = (float)(v14 - (float)(int)v30) + 0.276393202;
  v48 = (float)(v13 - v33);
  v49 = (float)(v15 - v35);
  v50 = (float)(v17 - v38);
  if (!v39)
    v25 = 0.0;
  v51 = (float)(v14 - v25);
  v52 = v13 + -1.0;
  v53 = v15 + -1.0;
  v54 = v17 + -1.0;
  v55 = v14 + -1.0;
  v56 = (float)((float)((float)(0.6 - (float)(v13 * v13)) - (float)(v15 * v15)) - (float)(v17 * v17))
      - (float)(v14 * v14);
  v57 = 0.0;
  if (v56 >= 0.0)
  {
    if ((perm[perm[perm[perm[v8]
                                                         + (unint64_t)v7]
                                   + (unint64_t)v6]
             + (unint64_t)v5] & 0x1Fu) >= 0x18)
      v13 = v15;
    if ((perm[perm[perm[perm[v8]
                                                         + (unint64_t)v7]
                                   + (unint64_t)v6]
             + (unint64_t)v5] & 0x10) != 0)
      v15 = v17;
    if ((perm[perm[perm[perm[v8]
                                                         + (unint64_t)v7]
                                   + (unint64_t)v6]
             + (unint64_t)v5] & 0x18) == 0)
      v14 = v17;
    if ((perm[perm[perm[perm[v8]
                                                         + (unint64_t)v7]
                                   + (unint64_t)v6]
             + (unint64_t)v5] & 1) != 0)
      v13 = -v13;
    if ((perm[perm[perm[perm[v8]
                                                         + (unint64_t)v7]
                                   + (unint64_t)v6]
             + (unint64_t)v5] & 2) != 0)
      v15 = -v15;
    v58 = v13 + v15;
    if ((perm[perm[perm[perm[v8]
                                                         + (unint64_t)v7]
                                   + (unint64_t)v6]
             + (unint64_t)v5] & 4) != 0)
      v14 = -v14;
    v57 = (float)((float)(v56 * v56) * (float)(v56 * v56)) * (float)(v14 + v58);
  }
  v59 = v48 + 0.414589803;
  v60 = v49 + 0.414589803;
  v61 = v50 + 0.414589803;
  v62 = v51 + 0.414589803;
  v63 = v44;
  v64 = v45;
  v65 = v46;
  v66 = v47;
  v67 = (float)((float)((float)(0.6 - (float)(v40 * v40)) - (float)(v41 * v41)) - (float)(v42 * v42))
      - (float)(v43 * v43);
  if (v67 >= 0.0)
  {
    v68 = perm[v5
             + v20
             + (unint64_t)perm[v21
                                                     + v6
                                                     + (unint64_t)perm[v22
                                                                                             + v7
                                                                                             + (unint64_t)perm[v23 + v8]]]];
    if ((v68 & 0x1Fu) >= 0x18)
      v40 = v41;
    if ((v68 & 0x10) != 0)
      v41 = v42;
    if ((v68 & 0x18) != 0)
      v42 = v43;
    if ((v68 & 1) != 0)
      v40 = -v40;
    if ((v68 & 2) != 0)
      v41 = -v41;
    v69 = v40 + v41;
    v70 = -v42;
    if ((v68 & 4) == 0)
      v70 = v42;
    v24 = (float)((float)(v67 * v67) * (float)(v67 * v67)) * (float)(v70 + v69);
  }
  v71 = v52 + 0.552786404;
  v72 = v53 + 0.552786404;
  v73 = v54 + 0.552786404;
  v74 = v55 + 0.552786404;
  v75 = v59;
  v76 = v60;
  v77 = v61;
  v79 = (float)((float)((float)(0.6 - (float)(v63 * v63)) - (float)(v64 * v64)) - (float)(v65 * v65))
      - (float)(v66 * v66);
  v80 = 0.0;
  v81 = 0.0;
  if (v79 >= 0.0)
  {
    v82 = perm[v5
             + v27
             + (unint64_t)perm[v28
                                                     + v6
                                                     + (unint64_t)perm[v29
                                                                                             + v7
                                                                                             + (unint64_t)perm[v30 + v8]]]];
    if ((v82 & 0x1Fu) >= 0x18)
      v63 = v64;
    if ((v82 & 0x10) != 0)
      v64 = v65;
    if ((v82 & 0x18) != 0)
      v65 = v66;
    v83 = -v63;
    if ((v82 & 1) == 0)
      v83 = v63;
    if ((v82 & 2) != 0)
      v64 = -v64;
    v84 = v83 + v64;
    if ((v82 & 4) != 0)
      v65 = -v65;
    v81 = (float)((float)(v79 * v79) * (float)(v79 * v79)) * (float)(v65 + v84);
  }
  v85 = v71;
  v86 = v72;
  v87 = v73;
  v78 = v62;
  v89 = (float)((float)((float)(0.6 - (float)(v75 * v75)) - (float)(v76 * v76)) - (float)(v77 * v77))
      - (float)(v78 * v78);
  if (v89 >= 0.0)
  {
    v90 = perm[v5
             + v32
             + (unint64_t)perm[v6
                                                     + v34
                                                     + (unint64_t)perm[v7
                                                                                             + v36
                                                                                             + (unint64_t)perm[v8 + (unint64_t)v39]]]];
    if ((v90 & 0x1Fu) >= 0x18)
      v75 = v60;
    if ((v90 & 0x10) != 0)
      v76 = v61;
    if ((v90 & 0x18) != 0)
      v77 = v62;
    v91 = -v75;
    if ((v90 & 1) == 0)
      v91 = v75;
    if ((v90 & 2) != 0)
      v76 = -v76;
    v92 = v91 + v76;
    if ((v90 & 4) != 0)
      v77 = -v77;
    v80 = (float)((float)(v89 * v89) * (float)(v89 * v89)) * (float)(v77 + v92);
  }
  v88 = v74;
  v93 = (float)((float)((float)(0.6 - (float)(v85 * v85)) - (float)(v86 * v86)) - (float)(v87 * v87))
      - (float)(v88 * v88);
  v94 = 0.0;
  if (v93 >= 0.0)
  {
    v95 = (float)(v93 * v93) * (float)(v93 * v93);
    if ((perm[v5
             + 1
             + (unint64_t)perm[v6
                                                     + 1
                                                     + (unint64_t)perm[v7
                                                                                             + 1
                                                                                             + (unint64_t)perm[v8 + 1]]]] & 0x1Fu) >= 0x18)
      v96 = v72;
    else
      v96 = v85;
    if ((perm[v5
             + 1
             + (unint64_t)perm[v6
                                                     + 1
                                                     + (unint64_t)perm[v7
                                                                                             + 1
                                                                                             + (unint64_t)perm[v8 + 1]]]] & 0x10) != 0)
      v86 = v73;
    if ((perm[v5
             + 1
             + (unint64_t)perm[v6
                                                     + 1
                                                     + (unint64_t)perm[v7
                                                                                             + 1
                                                                                             + (unint64_t)perm[v8 + 1]]]] & 0x18) != 0)
      v87 = v74;
    if ((perm[v5
             + 1
             + (unint64_t)perm[v6
                                                     + 1
                                                     + (unint64_t)perm[v7
                                                                                             + 1
                                                                                             + (unint64_t)perm[v8 + 1]]]] & 1) != 0)
      v96 = -v96;
    if ((perm[v5
             + 1
             + (unint64_t)perm[v6
                                                     + 1
                                                     + (unint64_t)perm[v7
                                                                                             + 1
                                                                                             + (unint64_t)perm[v8 + 1]]]] & 2) != 0)
      v86 = -v86;
    v97 = v96 + v86;
    if ((perm[v5
             + 1
             + (unint64_t)perm[v6
                                                     + 1
                                                     + (unint64_t)perm[v7
                                                                                             + 1
                                                                                             + (unint64_t)perm[v8 + 1]]]] & 4) != 0)
      v87 = -v87;
    v94 = v95 * (float)(v87 + v97);
  }
  return (float)((float)((float)((float)(v57 + v24) + v81) + v80) + v94) * 27.0;
}

uint64_t b2CollideCircles(uint64_t result, float *a2, float *a3, float *a4, float *a5)
{
  float v5;
  float v6;
  float v7;
  float v8;
  float v9;
  float v10;
  float v11;
  float v12;
  float v13;
  float v14;
  float v15;
  float v16;
  uint64_t v17;

  v6 = a3[2];
  v5 = a3[3];
  v8 = a2[4];
  v7 = a2[5];
  v9 = a2[3];
  v10 = *a3 + (float)((float)(v5 * v8) - (float)(v6 * v7));
  v11 = (float)((float)(v5 * v7) + (float)(v6 * v8)) + a3[1];
  v13 = a5[2];
  v12 = a5[3];
  v15 = a4[4];
  v14 = a4[5];
  v16 = a4[3];
  *(_DWORD *)(result + 60) = 0;
  if ((float)((float)((float)((float)((float)((float)(v12 * v14) + (float)(v13 * v15)) + a5[1]) - v11)
                     * (float)((float)((float)((float)(v12 * v14) + (float)(v13 * v15)) + a5[1]) - v11))
             + (float)((float)((float)(*a5 + (float)((float)(v12 * v15) - (float)(v13 * v14))) - v10)
                     * (float)((float)(*a5 + (float)((float)(v12 * v15) - (float)(v13 * v14))) - v10))) <= (float)((float)(v9 + v16) * (float)(v9 + v16)))
  {
    *(_DWORD *)(result + 56) = 0;
    v17 = *((_QWORD *)a2 + 2);
    *(_QWORD *)(result + 40) = 0;
    *(_QWORD *)(result + 48) = v17;
    *(_DWORD *)(result + 60) = 1;
    *(_QWORD *)result = *((_QWORD *)a4 + 2);
    *(_DWORD *)(result + 16) = 0;
  }
  return result;
}

float b2CollidePolygonAndCircle(uint64_t a1, uint64_t a2, float *a3, float *a4, float *a5)
{
  float v5;
  float v6;
  float v7;
  float v8;
  float v9;
  float v10;
  float v11;
  float v12;
  float v13;
  float v14;
  float v15;
  float v16;
  float v17;
  float result;
  uint64_t v19;
  unint64_t v20;
  unint64_t v21;
  uint64_t v22;
  uint64_t v23;
  int v24;
  uint64_t v25;
  float *v26;
  float *v27;
  float v28;
  float v29;
  _BOOL4 v30;
  int v31;
  uint64_t v32;
  float *v33;
  float v34;
  float v35;
  float v36;
  float *v37;
  float v38;
  float v39;
  float v40;
  float v41;
  float v42;
  float v43;
  float v44;
  float *v45;
  float v46;
  float v47;
  float v48;
  float v49;
  float v50;
  float v51;

  v6 = a5[2];
  v5 = a5[3];
  v8 = a4[4];
  v7 = a4[5];
  v9 = a4[3];
  v10 = a5[1];
  v11 = *a5 + (float)((float)(v5 * v8) - (float)(v6 * v7));
  *(_DWORD *)(a1 + 60) = 0;
  v12 = v11 - *a3;
  v13 = (float)((float)((float)(v5 * v7) + (float)(v6 * v8)) + v10) - a3[1];
  v15 = a3[2];
  v14 = a3[3];
  v16 = (float)(v13 * v15) + (float)(v14 * v12);
  v17 = (float)(v14 * v13) - (float)(v15 * v12);
  result = *(float *)(a2 + 12) + v9;
  v19 = *(_QWORD *)(a2 + 16);
  v20 = *(_QWORD *)(a2 + 24) - v19;
  v21 = v20 >> 3;
  v22 = *(_QWORD *)(a2 + 40);
  if ((int)(v20 >> 3) < 1)
  {
    v24 = 0;
    v30 = 1;
LABEL_9:
    if (v24 + 1 < (int)v21)
      v31 = v24 + 1;
    else
      v31 = 0;
    v32 = v24;
    v33 = (float *)(v19 + 8 * v24);
    v34 = *v33;
    v35 = v33[1];
    v36 = *v33;
    v37 = (float *)(v19 + 8 * v31);
    v38 = *v37;
    v39 = v37[1];
    if (v30)
    {
      *(_QWORD *)(a1 + 56) = 0x100000001;
      *(_QWORD *)(a1 + 40) = *(_QWORD *)(v22 + 8 * v32);
      result = (float)(v36 + v38) * 0.5;
      *(float *)(a1 + 48) = result;
      *(float *)(a1 + 52) = (float)(v35 + v39) * 0.5;
    }
    else
    {
      v40 = v16 - v36;
      v41 = v17 - v35;
      if ((float)((float)((float)(v17 - v35) * (float)(v39 - v35)) + (float)((float)(v16 - v36) * (float)(v38 - v36))) <= 0.0)
      {
        v46 = (float)(v41 * v41) + (float)(v40 * v40);
        result = result * result;
        if (v46 > result)
          return result;
        *(_QWORD *)(a1 + 56) = 0x100000001;
        *(float *)(a1 + 40) = v40;
        *(float *)(a1 + 44) = v41;
        result = sqrtf(v46);
        if (result >= 0.00000011921)
        {
          v47 = 1.0 / result;
          v48 = v40 * v47;
          result = v41 * v47;
          *(float *)(a1 + 40) = v48;
          *(float *)(a1 + 44) = result;
        }
        *(float *)(a1 + 48) = v34;
        *(float *)(a1 + 52) = v35;
      }
      else
      {
        v42 = v16 - v38;
        v43 = v17 - v39;
        if ((float)((float)((float)(v17 - v39) * (float)(v35 - v39)) + (float)((float)(v16 - v38) * (float)(v36 - v38))) <= 0.0)
        {
          v49 = (float)(v43 * v43) + (float)(v42 * v42);
          result = result * result;
          if (v49 > result)
            return result;
          *(_QWORD *)(a1 + 56) = 0x100000001;
          *(float *)(a1 + 40) = v42;
          *(float *)(a1 + 44) = v43;
          result = sqrtf(v49);
          if (result >= 0.00000011921)
          {
            v50 = 1.0 / result;
            v51 = v42 * v50;
            result = v43 * v50;
            *(float *)(a1 + 40) = v51;
            *(float *)(a1 + 44) = result;
          }
          *(float *)(a1 + 48) = v38;
          *(float *)(a1 + 52) = v39;
        }
        else
        {
          v44 = (float)(v36 + v38) * 0.5;
          v45 = (float *)(v22 + 8 * v32);
          if ((float)((float)((float)(v17 - (float)((float)(v35 + v39) * 0.5)) * v45[1])
                     + (float)((float)(v16 - v44) * *v45)) > result)
            return result;
          LODWORD(result) = 1;
          *(_QWORD *)(a1 + 56) = 0x100000001;
          *(_QWORD *)(a1 + 40) = *(_QWORD *)v45;
          *(float *)(a1 + 48) = v44;
          *(float *)(a1 + 52) = (float)(v35 + v39) * 0.5;
        }
      }
    }
    *(_QWORD *)a1 = *((_QWORD *)a4 + 2);
    *(_DWORD *)(a1 + 16) = 0;
    return result;
  }
  v23 = 0;
  v24 = 0;
  v25 = (v20 >> 3);
  v26 = (float *)(v19 + 4);
  v27 = (float *)(v22 + 4);
  v28 = -3.4028e38;
  while (1)
  {
    v29 = (float)((float)(v17 - *v26) * *v27) + (float)(*(v27 - 1) * (float)(v16 - *(v26 - 1)));
    if (v29 > result)
      return result;
    if (v29 > v28)
    {
      v24 = v23;
      v28 = (float)((float)(v17 - *v26) * *v27) + (float)(*(v27 - 1) * (float)(v16 - *(v26 - 1)));
    }
    ++v23;
    v26 += 2;
    v27 += 2;
    if (v25 == v23)
    {
      v30 = v28 < 0.00000011921;
      goto LABEL_9;
    }
  }
}

uint64_t b2CollideEdgeAndCircle(uint64_t result, uint64_t a2, float *a3, float *a4, float *a5)
{
  float v5;
  float v6;
  float v7;
  float v8;
  float v9;
  float v10;
  float v11;
  float v12;
  float v13;
  float v14;
  float v15;
  float v16;
  float v17;
  float v18;
  float v19;
  float v20;
  float v21;
  float v22;
  float v23;
  float v24;
  float v25;
  float v26;
  float v27;
  float v28;
  float v29;
  float v30;
  float v31;
  float v32;
  uint64_t v33;
  float v34;
  int v35;
  float v36;
  float v37;

  *(_DWORD *)(result + 60) = 0;
  v6 = a5[2];
  v5 = a5[3];
  v8 = a4[4];
  v7 = a4[5];
  v9 = *a5 + (float)((float)(v5 * v8) - (float)(v6 * v7));
  v10 = (float)((float)(v5 * v7) + (float)(v6 * v8)) + a5[1];
  v11 = v9 - *a3;
  v12 = v10 - a3[1];
  v14 = a3[2];
  v13 = a3[3];
  v15 = (float)(v12 * v14) + (float)(v13 * v11);
  v16 = (float)(v13 * v12) - (float)(v14 * v11);
  v17 = *(float *)(a2 + 20);
  v18 = *(float *)(a2 + 24);
  v19 = *(float *)(a2 + 28);
  v20 = *(float *)(a2 + 16);
  v21 = v18 - v20;
  v22 = v19 - v17;
  v23 = v15 - v20;
  v24 = v16 - v17;
  v25 = (float)((float)(v16 - v17) * (float)(v19 - v17)) + (float)((float)(v18 - v20) * (float)(v15 - v20));
  v26 = *(float *)(a2 + 12) + a4[3];
  if (v25 <= 0.0)
  {
    if ((float)((float)(v24 * v24) + (float)(v23 * v23)) > (float)(v26 * v26))
      return result;
    v33 = *(unsigned int *)(a2 + 20);
    v22 = 0.0;
    if (*(_BYTE *)(a2 + 48))
    {
      if ((float)((float)((float)(v17 - v16) * (float)(v17 - *(float *)(a2 + 36)))
                 + (float)((float)(v20 - *(float *)(a2 + 32)) * (float)(v20 - v15))) > 0.0)
        return result;
    }
    v35 = 0;
    v31 = 0.0;
LABEL_19:
    *(_DWORD *)(result + 60) = 1;
    *(float *)(result + 40) = v22;
    *(float *)(result + 44) = v31;
    *(float *)(result + 48) = v20;
    *(_QWORD *)(result + 52) = v33;
    *(_DWORD *)(result + 16) = v35;
    *(_QWORD *)result = *((_QWORD *)a4 + 2);
    return result;
  }
  v27 = (float)(v22 * (float)(v19 - v16)) + (float)(v21 * (float)(v18 - v15));
  if (v27 <= 0.0)
  {
    v36 = v15 - v18;
    v37 = v16 - v19;
    if ((float)((float)(v37 * v37) + (float)(v36 * v36)) > (float)(v26 * v26))
      return result;
    v33 = *(unsigned int *)(a2 + 28);
    v22 = 0.0;
    if (*(_BYTE *)(a2 + 49))
    {
      if ((float)((float)(v37 * (float)(*(float *)(a2 + 44) - v19)) + (float)((float)(*(float *)(a2 + 40) - v18) * v36)) > 0.0)
        return result;
    }
    v35 = 1;
    v31 = 0.0;
    v20 = *(float *)(a2 + 24);
    goto LABEL_19;
  }
  v28 = (float)(v22 * v22) + (float)(v21 * v21);
  if (v28 <= 0.0)
    b2CollideEdgeAndCircle();
  v29 = 1.0 / v28;
  v30 = v15 - (float)(v29 * (float)((float)(v27 * v20) + (float)(v25 * v18)));
  if ((float)((float)((float)(v16 - (float)(v29 * (float)((float)(v27 * v17) + (float)(v25 * v19))))
                     * (float)(v16 - (float)(v29 * (float)((float)(v27 * v17) + (float)(v25 * v19)))))
             + (float)(v30 * v30)) <= (float)(v26 * v26))
  {
    if ((float)((float)(v24 * v21) - (float)(v22 * v23)) < 0.0)
    {
      v31 = -v21;
    }
    else
    {
      v22 = -v22;
      v31 = v21;
    }
    v32 = sqrtf((float)(v31 * v31) + (float)(v22 * v22));
    HIDWORD(v33) = 1;
    LODWORD(v33) = *(_DWORD *)(a2 + 20);
    if (v32 >= 0.00000011921)
    {
      v34 = 1.0 / v32;
      v22 = v22 * v34;
      v31 = v31 * v34;
    }
    v35 = 0x10000;
    goto LABEL_19;
  }
  return result;
}

uint64_t b2EPCollider::Collide(float32x2_t *a1, float32x2_t *a2, float32x2_t *a3, float *a4, uint64_t a5, float *a6)
{
  float v9;
  float v10;
  float v11;
  float v12;
  float32_t v13;
  float32_t v14;
  float v15;
  float v16;
  float32_t v17;
  float32_t v18;
  float v19;
  float v20;
  float v21;
  float v22;
  float32x2_t v23;
  float32x2_t v24;
  float32x2_t v25;
  float32x2_t v26;
  uint64_t v27;
  float v28;
  uint64_t v29;
  float v30;
  int v31;
  float v32;
  float v33;
  float v34;
  float v35;
  float v36;
  int v37;
  float v38;
  float v39;
  float v40;
  float v41;
  float v42;
  float v43;
  float v44;
  float v45;
  _BOOL4 v46;
  float32x2_t v47;
  float32x2_t v48;
  float v49;
  float v50;
  float v51;
  float v52;
  float v53;
  float v54;
  float v55;
  __int32 v56;
  _BOOL4 v57;
  float32x2_t v58;
  float32x2_t v59;
  _BOOL4 v60;
  BOOL v61;
  uint64_t v62;
  float32x4_t v63;
  float32x4_t v64;
  _BOOL4 v65;
  float32x2_t v66;
  float32x2_t v67;
  float32x2_t v68;
  BOOL v69;
  _BOOL4 v70;
  _BOOL4 v71;
  uint64_t v72;
  uint64_t v73;
  unint64_t v74;
  float32x2_t *v75;
  uint64_t v76;
  float *v77;
  float *v78;
  float *v79;
  float32x2_t v80;
  float32x2_t v81;
  float v82;
  float v83;
  float v84;
  float v85;
  uint64_t result;
  float v87;
  uint64_t v88;
  float v89;
  float v90;
  float v91;
  uint64_t v92;
  float *v93;
  uint64_t v94;
  unint64_t v95;
  int v96;
  float v97;
  float v98;
  float *v99;
  float v100;
  float v101;
  float v102;
  uint64_t v103;
  uint64_t i;
  float v105;
  unint64_t v106;
  float32x2_t v107;
  int v108;
  uint64_t v109;
  float32x2_t v110;
  float32x2_t v111;
  float32x2_t v112;
  int v113;
  float32x2_t v114;
  float v115;
  float v116;
  uint8x8_t v117;
  float32x2_t v118;
  uint64_t v119;
  int v120;
  char v121;
  char v122;
  float *v123;
  float v124;
  float *v125;
  float v126;
  float v127;
  float v128;
  float v129;
  int16x8_t v130;
  uint64_t v131;
  float32x2_t v132;
  float32x2_t v133;
  float v134[2];
  float v135;
  float v136[2];
  float v137;
  _DWORD v138[6];
  uint64_t v139[3];
  float32x2_t v140;
  char v141;
  char v142;
  __int16 v143;
  float32x2_t v144;
  char v145;
  char v146;
  __int16 v147;
  uint64_t v148;

  v148 = *MEMORY[0x24BDAC8D0];
  v10 = a4[2];
  v9 = a4[3];
  v11 = a6[2];
  v12 = a6[3];
  v13 = (float)(v9 * v11) - (float)(v10 * v12);
  v14 = (float)(v11 * v10) + (float)(v9 * v12);
  v15 = *a6 - *a4;
  v16 = a6[1] - a4[1];
  v17 = (float)(v10 * v16) + (float)(v9 * v15);
  v18 = (float)(v9 * v16) - (float)(v10 * v15);
  a1[6].f32[0] = v17;
  a1[6].f32[1] = v18;
  a1[7].f32[0] = v13;
  a1[7].f32[1] = v14;
  v19 = *(float *)(a5 + 64);
  v20 = *(float *)(a5 + 68);
  v21 = v17 + (float)((float)(v14 * v19) - (float)(v13 * v20));
  v22 = v18 + (float)((float)(v14 * v20) + (float)(v13 * v19));
  a1[8].f32[0] = v21;
  a1[8].f32[1] = v22;
  v23 = a3[4];
  a1[9] = v23;
  v24 = a3[2];
  a1[10] = v24;
  v25 = a3[3];
  a1[11] = v25;
  v26 = a3[5];
  a1[12] = v26;
  v27 = HIDWORD(*(_QWORD *)&v25);
  v28 = v25.f32[0];
  v29 = HIDWORD(*(_QWORD *)&v24);
  v30 = v24.f32[0];
  v31 = a3[6].u8[0];
  v32 = v28 - v30;
  v33 = *(float *)&v29;
  v34 = *(float *)&v27 - *(float *)&v29;
  v35 = sqrtf((float)(v34 * v34) + (float)(v32 * v32));
  if (v35 >= 0.00000011921)
  {
    v36 = 1.0 / v35;
    v32 = v32 * v36;
    v34 = v34 * v36;
  }
  v37 = a3[6].u8[1];
  a1[14].f32[0] = v34;
  a1[14].f32[1] = -v32;
  v38 = (float)(v34 * (float)(v21 - v30)) - (float)(v32 * (float)(v22 - v33));
  if (!v31)
  {
    if (!v37)
    {
      a1[20].i8[4] = v38 >= 0.0;
      if (v38 >= 0.0)
      {
        v62 = (uint64_t)a1[14];
        a1[16] = (float32x2_t)v62;
        v63.i64[0] = v62;
        v63.i64[1] = v62;
        v64 = vnegq_f32(v63);
        goto LABEL_78;
      }
      a1[16].f32[0] = -v34;
      a1[16].f32[1] = v32;
      v59 = a1[14];
LABEL_71:
      a1[18] = v59;
      goto LABEL_75;
    }
    v23.i32[0] = 0;
    v45 = 0.0;
LABEL_14:
    v49 = v26.f32[0] - v28;
    v50 = v26.f32[1] - *(float *)&v27;
    v51 = sqrtf((float)(v50 * v50) + (float)(v49 * v49));
    if (v51 >= 0.00000011921)
    {
      v52 = 1.0 / v51;
      v49 = v49 * v52;
      v50 = v50 * v52;
    }
    a1[15].f32[0] = v50;
    a1[15].f32[1] = -v49;
    v53 = -v34;
    v54 = (float)(v32 * v50) - (float)(v34 * v49);
    v55 = (float)(v50 * (float)(v21 - v28)) - (float)(v49 * (float)(v22 - *(float *)&v27));
    if (!v31)
    {
      if (v54 <= 0.0)
      {
        v70 = v38 >= 0.0;
        if (v55 < 0.0)
          v70 = 0;
        a1[20].i8[4] = v70;
        if (v70)
        {
          v59 = a1[14];
          a1[16] = v59;
          a1[18].i32[0] = v59.i32[0] ^ 0x80000000;
          a1[18].i32[1] = v59.i32[1] ^ 0x80000000;
LABEL_75:
          a1[19] = v59;
          goto LABEL_79;
        }
        a1[16].f32[0] = v53;
        a1[16].f32[1] = v32;
        a1[18].f32[0] = -v50;
        a1[18].f32[1] = v49;
      }
      else
      {
        v65 = v38 >= 0.0;
        if (v55 >= 0.0)
          v65 = 1;
        a1[20].i8[4] = v65;
        if (v65)
        {
          v66 = a1[14];
          v67 = a1[15];
          a1[16] = v66;
          a1[18].i32[0] = v66.i32[0] ^ 0x80000000;
          a1[18].i32[1] = v66.i32[1] ^ 0x80000000;
          a1[19] = v67;
          goto LABEL_79;
        }
        a1[16].f32[0] = v53;
        a1[16].f32[1] = v32;
        a1[18].f32[0] = v53;
        a1[18].f32[1] = v32;
      }
      v59 = a1[14];
      goto LABEL_75;
    }
    if (v54 > 0.0)
      v56 = v23.i32[0];
    else
      v56 = 0;
    if (v56 == 1)
    {
      v57 = v45 >= 0.0;
      if (v38 >= 0.0)
        v57 = 1;
      if (v55 >= 0.0)
        v57 = 1;
      a1[20].i8[4] = v57;
      if (v57)
      {
        v58 = a1[13];
        a1[16] = a1[14];
        v59 = a1[15];
LABEL_64:
        a1[18] = v58;
        goto LABEL_75;
      }
      a1[16].f32[0] = v53;
      a1[16].f32[1] = v32;
      a1[18].f32[0] = v53;
      a1[18].f32[1] = v32;
LABEL_50:
      a1[19].f32[0] = v53;
      a1[19].f32[1] = v32;
      goto LABEL_79;
    }
    if (v23.i32[0])
    {
      if (v45 >= 0.0)
      {
        a1[20].i8[4] = 1;
      }
      else
      {
        v61 = v38 >= 0.0;
        if (v55 < 0.0)
          v61 = 0;
        a1[20].i8[4] = v61;
        if (!v61)
        {
          a1[16].f32[0] = v53;
          a1[16].f32[1] = v32;
          a1[18].f32[0] = -v50;
          a1[18].f32[1] = v49;
          goto LABEL_50;
        }
      }
      v58 = a1[13];
      v59 = a1[14];
      a1[16] = v59;
      goto LABEL_64;
    }
    if (v54 > 0.0)
    {
      if (v55 >= 0.0)
      {
        a1[20].i8[4] = 1;
      }
      else
      {
        v69 = v45 >= 0.0;
        if (v38 < 0.0)
          v69 = 0;
        a1[20].i8[4] = v69;
        if (!v69)
        {
          a1[16].f32[0] = v53;
          a1[16].f32[1] = v32;
          a1[18].f32[0] = v53;
          a1[18].f32[1] = v32;
LABEL_48:
          a1[19] = vneg_f32(a1[13]);
          goto LABEL_79;
        }
      }
      v64 = *(float32x4_t *)a1[14].f32;
      a1[16] = *(float32x2_t *)v64.f32;
LABEL_78:
      *(float32x4_t *)a1[18].f32 = v64;
      goto LABEL_79;
    }
    v71 = v45 >= 0.0;
    if (v38 < 0.0)
      v71 = 0;
    if (v55 < 0.0)
      v71 = 0;
    a1[20].i8[4] = v71;
    if (!v71)
    {
      a1[16].f32[0] = v53;
      a1[16].f32[1] = v32;
      a1[18].f32[0] = -v50;
      a1[18].f32[1] = v49;
      goto LABEL_48;
    }
    v59 = a1[14];
    a1[16] = v59;
    goto LABEL_71;
  }
  v39 = v23.f32[0];
  v40 = v30 - v23.f32[0];
  v41 = v33 - v23.f32[1];
  v42 = sqrtf((float)(v41 * v41) + (float)(v40 * v40));
  if (v42 >= 0.00000011921)
  {
    v43 = 1.0 / v42;
    v40 = v40 * v43;
    v41 = v41 * v43;
  }
  a1[13].f32[0] = v41;
  a1[13].f32[1] = -v40;
  v44 = (float)(v40 * v34) - (float)(v41 * v32);
  v23.i32[0] = v44 >= 0.0;
  v45 = (float)(v41 * (float)(v21 - v39)) - (float)(v40 * (float)(v22 - v23.f32[1]));
  if (v37)
    goto LABEL_14;
  if (v44 < 0.0)
  {
    v60 = v45 >= 0.0;
    if (v38 < 0.0)
      v60 = 0;
    a1[20].i8[4] = v60;
    if (v60)
    {
      v47 = a1[14];
      a1[16] = v47;
      a1[18] = v47;
      goto LABEL_32;
    }
    a1[16].f32[0] = -v34;
    a1[16].f32[1] = v32;
    a1[18] = a1[14];
    goto LABEL_48;
  }
  v46 = v45 >= 0.0;
  if (v38 >= 0.0)
    v46 = 1;
  a1[20].i8[4] = v46;
  if (v46)
  {
    v48 = a1[13];
    v47 = a1[14];
    a1[16] = v47;
    a1[18] = v48;
LABEL_32:
    a1[19].i32[0] = v47.i32[0] ^ 0x80000000;
    a1[19].i32[1] = v47.i32[1] ^ 0x80000000;
    goto LABEL_79;
  }
  a1[16].f32[0] = -v34;
  a1[16].f32[1] = v32;
  v68 = a1[14];
  a1[18] = v68;
  a1[19].i32[0] = v68.i32[0] ^ 0x80000000;
  a1[19].f32[1] = v32;
LABEL_79:
  v72 = *(_QWORD *)(a5 + 24) - *(_QWORD *)(a5 + 16);
  std::vector<b2Vec2>::resize((uint64_t)a1, (int)(v72 >> 3));
  std::vector<b2Vec2>::resize((uint64_t)&a1[3], (int)(v72 >> 3));
  v73 = *(_QWORD *)(a5 + 16);
  v74 = *(_QWORD *)(a5 + 24) - v73;
  if ((int)(v74 >> 3) >= 1)
  {
    v75 = (float32x2_t *)*a1;
    v76 = (v74 >> 3);
    v77 = (float *)(v73 + 4);
    v78 = (float *)(*(_QWORD *)(a5 + 40) + 4);
    v79 = (float *)(*(_QWORD *)&a1[3] + 4);
    do
    {
      v80 = a1[7];
      v81 = (float32x2_t)vrev64_s32((int32x2_t)v80);
      v80.f32[0] = -v80.f32[0];
      *v75++ = vadd_f32(a1[6], vmla_n_f32(vmul_n_f32(v80, *v77), v81, *(v77 - 1)));
      v82 = *(v78 - 1);
      v83 = a1[7].f32[0];
      v80.i32[0] = a1[7].i32[1];
      v84 = (float)(v80.f32[0] * v82) - (float)(v83 * *v78);
      v85 = (float)(v80.f32[0] * *v78) + (float)(v83 * v82);
      *(v79 - 1) = v84;
      *v79 = v85;
      v77 += 2;
      v78 += 2;
      v79 += 2;
      --v76;
    }
    while (v76);
  }
  a1[20].i32[0] = 1016296636;
  a2[7].i32[1] = 0;
  result = b2EPCollider::ComputeEdgeSeparation((b2EPCollider *)a1);
  v88 = result;
  if ((_DWORD)result)
  {
    v89 = v87;
    if (v87 <= 0.018)
    {
      result = b2EPCollider::ComputePolygonSeparation((b2EPCollider *)a1);
      if ((_DWORD)result)
      {
        if (v90 > 0.018)
          return result;
        v91 = (float)(v89 * 0.98) + 0.001;
        if (v91 >= v90)
          v92 = v88;
        else
          v92 = result;
        if (v91 < v90)
          LODWORD(v88) = result;
      }
      else
      {
        v92 = v88;
      }
      if ((_DWORD)v88 == 1)
      {
        a2[7].i32[0] = 1;
        v93 = (float *)a1[3];
        v94 = *(_QWORD *)&a1[4] - (_QWORD)v93;
        v95 = v94 >> 3;
        if ((unint64_t)v94 < 9)
        {
          v96 = 0;
        }
        else
        {
          v96 = 0;
          v97 = a1[16].f32[0];
          v98 = a1[16].f32[1];
          v100 = *v93;
          v101 = v93[1];
          v99 = v93 + 3;
          v102 = (float)(v98 * v101) + (float)(v97 * v100);
          v103 = 2;
          if (v95 > 2)
            v103 = v95;
          for (i = 1; i != v103; ++i)
          {
            v105 = v98 * *v99;
            if ((float)(v105 + (float)(v97 * *(v99 - 1))) < v102)
            {
              v96 = i;
              v102 = v105 + (float)(v97 * *(v99 - 1));
            }
            v99 += 2;
          }
        }
        if (v95 > v96 + 1)
          v113 = v96 + 1;
        else
          v113 = 0;
        v114 = *a1;
        v140 = *(float32x2_t *)(*(_QWORD *)a1 + 8 * v96);
        v141 = 0;
        v142 = v96;
        v143 = 1;
        v144 = *(float32x2_t *)(*(_QWORD *)&v114 + 8 * v113);
        v145 = 0;
        v146 = v113;
        v147 = 1;
        if (!a1[20].i8[4])
        {
          v131 = 1;
          v111 = a1[10];
          v110 = a1[11];
          v132 = v110;
          v116 = -a1[14].f32[0];
          v115 = -a1[14].f32[1];
          v133.f32[0] = v116;
          v133.f32[1] = v115;
          LOBYTE(v106) = 1;
          goto LABEL_113;
        }
        LOBYTE(v106) = 0;
        v131 = 0x100000000;
        v110 = a1[10];
        v111 = a1[11];
        v132 = v110;
        v112 = a1[14];
      }
      else
      {
        v106 = HIDWORD(v92);
        a2[7].i32[0] = 2;
        v107 = a1[11];
        v140 = a1[10];
        v141 = 0;
        v142 = BYTE4(v92);
        v143 = 256;
        v144 = v107;
        v145 = 0;
        v146 = BYTE4(v92);
        v147 = 256;
        if (HIDWORD(v92) + 1 < (int)((unint64_t)v72 >> 3))
          v108 = HIDWORD(v92) + 1;
        else
          v108 = 0;
        LODWORD(v131) = HIDWORD(v92);
        BYTE4(v131) = v108;
        v109 = v92 >> 32;
        v110 = *(float32x2_t *)(*(_QWORD *)a1 + 8 * (v92 >> 32));
        v132 = v110;
        v111 = *(float32x2_t *)(*(_QWORD *)a1 + 8 * v108);
        v112 = *(float32x2_t *)(*(_QWORD *)&a1[3] + 8 * v109);
      }
      v133 = v112;
      v115 = v112.f32[1];
      v116 = v112.f32[0];
LABEL_113:
      v134[0] = v115;
      v134[1] = -v116;
      v135 = (float)(v115 * v110.f32[0]) - (float)(v116 * v110.f32[1]);
      v136[0] = -v115;
      v136[1] = v116;
      v137 = (float)(v116 * v111.f32[1]) - (float)(v115 * v111.f32[0]);
      result = b2ClipSegmentToLine((uint64_t)v139, (uint64_t *)&v140, v134, v106, v135);
      if ((int)result >= 2)
      {
        result = b2ClipSegmentToLine((uint64_t)v138, v139, v136, SBYTE4(v131), v137);
        if ((int)result >= 2)
        {
          if ((_DWORD)v88 == 1)
          {
            v118 = v132;
            a2[5] = v133;
          }
          else
          {
            a2[5] = *(float32x2_t *)(*(_QWORD *)(a5 + 40) + 8 * (int)v131);
            v118 = *(float32x2_t *)(*(_QWORD *)(a5 + 16) + 8 * (int)v131);
          }
          v119 = 0;
          v120 = 0;
          a2[6] = v118;
          v121 = 1;
          do
          {
            v122 = v121;
            v123 = (float *)&v138[3 * v119];
            v124 = v123[1];
            if ((float)((float)((float)(v124 - v132.f32[1]) * v133.f32[1])
                       + (float)(v133.f32[0] * (float)(*v123 - v132.f32[0]))) <= a1[20].f32[0])
            {
              v125 = (float *)a2 + 5 * v120;
              if ((_DWORD)v88 == 1)
              {
                v126 = *v123 - a1[6].f32[0];
                v127 = v124 - a1[6].f32[1];
                v129 = a1[7].f32[0];
                v128 = a1[7].f32[1];
                *v125 = (float)(v127 * v129) + (float)(v128 * v126);
                v125[1] = (float)(v128 * v127) - (float)(v129 * v126);
                a2[2].i32[5 * v120] = v138[3 * v119 + 2];
              }
              else
              {
                *(_QWORD *)v125 = *(_QWORD *)v123;
                v117.i32[0] = v138[3 * v119 + 2];
                v130 = (int16x8_t)vmovl_u8(v117);
                *(int16x4_t *)v130.i8 = vrev32_s16(*(int16x4_t *)v130.i8);
                v117 = (uint8x8_t)vmovn_s16(v130);
                a2[2].i32[5 * v120] = v117.i32[0];
              }
              ++v120;
            }
            v121 = 0;
            v119 = 1;
          }
          while ((v122 & 1) != 0);
          a2[7].i32[1] = v120;
        }
      }
    }
  }
  return result;
}

uint64_t b2EPCollider::ComputeEdgeSeparation(b2EPCollider *this)
{
  uint64_t v1;
  unint64_t v2;
  float v3;
  float v4;
  float *v5;
  float v6;
  float v7;

  v1 = *((_QWORD *)this + 1) - *(_QWORD *)this;
  if (v1)
  {
    v2 = v1 >> 3;
    v3 = *((float *)this + 20);
    v4 = *((float *)this + 32);
    if (v2 <= 1)
      v2 = 1;
    v5 = (float *)(*(_QWORD *)this + 4);
    v6 = 3.4028e38;
    do
    {
      v7 = (float)(*v5 - *((float *)this + 21)) * *((float *)this + 33);
      if ((float)(v7 + (float)(v4 * (float)(*(v5 - 1) - v3))) < v6)
        v6 = v7 + (float)(v4 * (float)(*(v5 - 1) - v3));
      v5 += 2;
      --v2;
    }
    while (v2);
  }
  if (*((_BYTE *)this + 164))
    return 1;
  else
    return 0x100000001;
}

unint64_t b2EPCollider::ComputePolygonSeparation(b2EPCollider *this)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  unsigned int v4;
  float v5;
  float v6;
  unint64_t v7;
  float *v8;
  float *v9;
  uint64_t v10;
  float v11;
  float v12;
  float v13;
  float v14;
  float v15;
  float v16;
  float v17;
  float v18;
  float v19;

  v1 = *((_QWORD *)this + 1);
  v2 = v1 - *(_QWORD *)this;
  if (v1 == *(_QWORD *)this)
  {
    v4 = 0;
    v10 = 0xFFFFFFFFLL;
  }
  else
  {
    v3 = 0;
    v4 = 0;
    v6 = *((float *)this + 32);
    v5 = *((float *)this + 33);
    v7 = v2 >> 3;
    if (v7 <= 1)
      v7 = 1;
    v8 = (float *)(*(_QWORD *)this + 4);
    v9 = (float *)(*((_QWORD *)this + 3) + 4);
    v10 = 0xFFFFFFFFLL;
    v11 = -3.4028e38;
    while (1)
    {
      v12 = *(v9 - 1);
      v13 = *(v8 - 1);
      v14 = (float)-(float)(*v9 * (float)(*v8 - *((float *)this + 21)))
          - (float)(v12 * (float)(v13 - *((float *)this + 20)));
      v15 = (float)-(float)(*v9 * (float)(*v8 - *((float *)this + 23)))
          - (float)(v12 * (float)(v13 - *((float *)this + 22)));
      if (v14 < v15)
        v15 = v14;
      if (v15 > *((float *)this + 40))
        break;
      v16 = -v12;
      v17 = -*v9;
      if ((float)((float)(v6 * v17) + (float)(v12 * v5)) >= 0.0)
      {
        v18 = *((float *)this + 38);
        v19 = *((float *)this + 39);
      }
      else
      {
        v18 = *((float *)this + 36);
        v19 = *((float *)this + 37);
      }
      if ((float)((float)((float)(v17 - v19) * v5) + (float)((float)(v16 - v18) * v6)) >= -0.034907)
      {
        if (v15 <= v11)
        {
          v10 = v10;
        }
        else
        {
          v4 = 2;
          v10 = v3;
        }
        if (v15 > v11)
          v11 = v15;
      }
      ++v3;
      v8 += 2;
      v9 += 2;
      if (v7 == v3)
        return v4 | (unint64_t)(v10 << 32);
    }
    v4 = 2;
    v10 = v3;
  }
  return v4 | (unint64_t)(v10 << 32);
}

void b2CollideEdgeAndPolygon(float32x2_t *a1, float32x2_t *a2, float *a3, uint64_t a4, float *a5)
{
  void *v5[2];
  void *__p[2];
  __int128 v7;

  *(_OWORD *)__p = 0u;
  v7 = 0u;
  *(_OWORD *)v5 = 0u;
  b2EPCollider::Collide((float32x2_t *)v5, a1, a2, a3, a4, a5);
  if (__p[1])
  {
    *(void **)&v7 = __p[1];
    operator delete(__p[1]);
  }
  if (v5[0])
  {
    v5[1] = v5[0];
    operator delete(v5[0]);
  }
}

void sub_208FAC57C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  b2EPCollider::~b2EPCollider((b2EPCollider *)&a9);
  _Unwind_Resume(a1);
}

void b2EPCollider::~b2EPCollider(b2EPCollider *this)
{
  void *v2;
  void *v3;

  v2 = (void *)*((_QWORD *)this + 3);
  if (v2)
  {
    *((_QWORD *)this + 4) = v2;
    operator delete(v2);
  }
  v3 = *(void **)this;
  if (*(_QWORD *)this)
  {
    *((_QWORD *)this + 1) = v3;
    operator delete(v3);
  }
}

void b2CollidePolygons(float32x2_t *a1, float *a2, const b2Transform *a3, float *a4, const b2Transform *a5)
{
  const b2Transform *v5;
  float *v6;
  float v10;
  float MaxSeparation;
  float v12;
  float v13;
  float v14;
  float v15;
  int *v16;
  int v17;
  float *p_var0;
  float *v19;
  uint64_t v20;
  float var1;
  float var0;
  float x;
  float y;
  float v25;
  float v26;
  float v27;
  float v28;
  uint64_t v29;
  unint64_t v30;
  uint64_t v31;
  unint64_t v32;
  unint64_t v33;
  float v34;
  uint64_t v35;
  int v36;
  float *v37;
  float v38;
  float v39;
  float v40;
  float v41;
  float v42;
  float v43;
  uint64_t v44;
  uint64_t v45;
  float *v46;
  float v47;
  int v48;
  float *v49;
  float v50;
  float v51;
  float *v52;
  float v53;
  float v54;
  int v55;
  float32x2_t v56;
  float32x2_t v57;
  float v58;
  float v59;
  float v60;
  float v61;
  float v62;
  float v63;
  float v64;
  uint64_t v65;
  __int32 v66;
  char v67;
  char v68;
  float *v69;
  float v70;
  float v71;
  char *v72;
  float v73;
  float v74;
  float v75;
  _BYTE *v76;
  float v77;
  float v78;
  float32x2_t v79;
  float32x2_t v80;
  float v81;
  float v82;
  float v83;
  float v84;
  float v85;
  float v86;
  float v87;
  float v88;
  float32x2_t v89;
  float v90[2];
  int v91;
  int v92;
  float v93[6];
  uint64_t v94[3];
  uint64_t v95;
  char v96;
  char v97;
  __int16 v98;
  float v99;
  float v100;
  char v101;
  char v102;
  __int16 v103;
  uint64_t v104;

  v5 = a5;
  v6 = a4;
  v104 = *MEMORY[0x24BDAC8D0];
  a1[7].i32[1] = 0;
  v10 = a2[3] + a4[3];
  v92 = 0;
  MaxSeparation = b2FindMaxSeparation(&v92, (const b2PolygonShape *)a2, a3, (const b2PolygonShape *)a4, a5);
  if (MaxSeparation <= v10)
  {
    v12 = MaxSeparation;
    v91 = 0;
    v13 = b2FindMaxSeparation(&v91, (const b2PolygonShape *)v6, v5, (const b2PolygonShape *)a2, a3);
    if (v13 <= v10)
    {
      v14 = v13;
      v15 = (float)(v12 * 0.98) + 0.001;
      if (v13 > v15)
      {
        v16 = &v91;
        v17 = 2;
        p_var0 = (float *)&a3->var0;
        v19 = a2;
      }
      else
      {
        v16 = &v92;
        v17 = 1;
        p_var0 = (float *)&v5->var0;
        v5 = a3;
        v19 = v6;
        v6 = a2;
      }
      v20 = *v16;
      var0 = v5->var1.var0;
      var1 = v5->var1.var1;
      x = v5->var0.x;
      y = v5->var0.y;
      v25 = *p_var0;
      v26 = p_var0[1];
      v28 = p_var0[2];
      v27 = p_var0[3];
      a1[7].i32[0] = v17;
      if ((v20 & 0x80000000) != 0
        || (v29 = *((_QWORD *)v6 + 2), v30 = (unint64_t)(*((_QWORD *)v6 + 3) - v29) >> 3, (int)v20 >= (int)v30))
      {
        b2CollidePolygons();
      }
      v31 = *((_QWORD *)v19 + 2);
      v32 = *((_QWORD *)v19 + 3) - v31;
      v33 = v32 >> 3;
      v34 = -v28;
      if ((int)(v32 >> 3) < 1)
      {
        v36 = 0;
      }
      else
      {
        v35 = 0;
        v36 = 0;
        v37 = (float *)(*((_QWORD *)v6 + 5) + 8 * v20);
        v38 = v37[1];
        v39 = (float)(var1 * *v37) - (float)(var0 * v38);
        v40 = (float)(var1 * v38) + (float)(var0 * *v37);
        v41 = (float)(v28 * v40) + (float)(v27 * v39);
        v42 = (float)(v27 * v40) - (float)(v28 * v39);
        v43 = 3.4028e38;
        v44 = *((_QWORD *)v19 + 5);
        v45 = (v32 >> 3);
        v46 = (float *)(v44 + 4);
        do
        {
          if ((float)((float)(v42 * *v46) + (float)(v41 * *(v46 - 1))) < v43)
          {
            v43 = (float)(v42 * *v46) + (float)(v41 * *(v46 - 1));
            v36 = v35;
          }
          ++v35;
          v46 += 2;
        }
        while (v45 != v35);
      }
      v47 = -var0;
      if (v36 + 1 < (int)v33)
        v48 = v36 + 1;
      else
        v48 = 0;
      v49 = (float *)(v31 + 8 * v36);
      v50 = v49[1];
      v51 = v26 + (float)((float)(v27 * v50) + (float)(v28 * *v49));
      *(float *)&v95 = v25 + (float)((float)(v50 * v34) + (float)(v27 * *v49));
      *((float *)&v95 + 1) = v51;
      v96 = v20;
      v97 = v36;
      v98 = 1;
      v52 = (float *)(v31 + 8 * v48);
      v53 = v52[1];
      v54 = v26 + (float)((float)(v27 * v53) + (float)(v28 * *v52));
      v99 = v25 + (float)((float)(v53 * v34) + (float)(v27 * *v52));
      v100 = v54;
      v101 = v20;
      v102 = v48;
      v103 = 1;
      if ((int)v20 + 1 < (int)v30)
        v55 = v20 + 1;
      else
        v55 = 0;
      v56 = *(float32x2_t *)(v29 + 8 * (int)v20);
      v89 = *(float32x2_t *)(v29 + 8 * v55);
      v57 = vsub_f32(v89, v56);
      v58 = sqrtf(vmlas_n_f32(COERCE_FLOAT(vmul_f32(v57, v57).i32[1]), v57.f32[0], v57.f32[0]));
      v85 = v15;
      v86 = v14;
      v83 = v26;
      v84 = v25;
      v81 = -v28;
      v82 = v28;
      if (v58 >= 0.00000011921)
        v57 = vmul_n_f32(v57, 1.0 / v58);
      v59 = vmuls_lane_f32(v47, v57, 1);
      v60 = -(float)(v59 + (float)(var1 * v57.f32[0]));
      v61 = vmlas_n_f32(v59, var1, v57.f32[0]);
      v62 = vmuls_lane_f32(var1, v57, 1);
      v63 = -(float)(v62 + (float)(var0 * v57.f32[0]));
      v79 = *(float32x2_t *)(v29 + 8 * (int)v20);
      v80 = v57;
      v64 = vmlas_n_f32(v62, var0, v57.f32[0]);
      v90[0] = v61;
      v90[1] = v64;
      v77 = y + vmlas_n_f32(vmuls_lane_f32(var1, v56, 1), var0, v56.f32[0]);
      v78 = x + vmlas_n_f32(vmuls_lane_f32(v47, v56, 1), var1, v56.f32[0]);
      v93[0] = v60;
      v93[1] = v63;
      v87 = var0;
      v88 = y;
      if ((int)b2ClipSegmentToLine((uint64_t)v94, &v95, v93, v20, v10 - (float)((float)(v77 * v64) + (float)(v61 * v78))) >= 2&& (int)b2ClipSegmentToLine((uint64_t)v93, v94, v90, v55, v10+ (float)((float)((float)(v88 + vmlas_n_f32(vmuls_lane_f32(var1, v89, 1), v87, v89.f32[0])) * v64)+ (float)(v61 * (float)(x + vmlas_n_f32(vmuls_lane_f32(v47, v89, 1), var1, v89.f32[0]))))) >= 2)
      {
        v65 = 0;
        v66 = 0;
        a1[5].i32[0] = v80.i32[1];
        a1[5].f32[1] = -v80.f32[0];
        a1[6] = vmul_f32(vadd_f32(v79, v89), (float32x2_t)0x3F0000003F000000);
        v67 = 1;
        do
        {
          v68 = v67;
          v69 = &v93[3 * v65];
          v70 = *v69;
          v71 = v69[1];
          if ((float)((float)((float)(v71 * v60) + (float)(v64 * *v69))
                     - (float)((float)(v64 * v78) - (float)(v61 * v77))) <= v10)
          {
            v72 = (char *)a1 + 20 * v66;
            v73 = v70 - v84;
            v74 = v71 - v83;
            *(float *)v72 = (float)(v82 * v74) + (float)(v27 * v73);
            *((float *)v72 + 1) = (float)(v27 * v74) + (float)(v81 * v73);
            v75 = v93[3 * v65 + 2];
            *((float *)v72 + 4) = v75;
            v76 = v72 + 16;
            if (v86 > v85)
            {
              *v76 = BYTE1(v75);
              v76[1] = LOBYTE(v75);
              v76[2] = HIBYTE(v75);
              v76[3] = BYTE2(v75);
            }
            ++v66;
          }
          v67 = 0;
          v65 = 1;
        }
        while ((v68 & 1) != 0);
        a1[7].i32[1] = v66;
      }
    }
  }
}

float b2FindMaxSeparation(int *a1, const b2PolygonShape *a2, const b2Transform *a3, const b2PolygonShape *a4, const b2Transform *a5)
{
  unint64_t v9;
  unint64_t v10;
  signed int v11;
  uint64_t v12;
  signed int v13;
  float var1;
  float var0;
  float v16;
  float v17;
  float v18;
  float v19;
  float v20;
  float v21;
  float v22;
  float v23;
  float v24;
  float v25;
  float v26;
  float v27;
  float v28;
  float v29;
  float v30;
  uint64_t v31;
  float *v32;
  float v33;
  float v34;
  signed int v35;
  float v36;
  unsigned int v37;
  float v38;
  _BOOL4 v39;

  v9 = *((_QWORD *)a2 + 3) - *((_QWORD *)a2 + 2);
  v10 = v9 >> 3;
  v11 = (v9 >> 3) - 1;
  if ((int)(v9 >> 3) < 1)
  {
    v13 = 0;
  }
  else
  {
    v12 = 0;
    v13 = 0;
    var0 = a5->var1.var0;
    var1 = a5->var1.var1;
    v16 = *((float *)a4 + 16);
    v17 = *((float *)a4 + 17);
    v18 = a5->var0.x + (float)((float)(var1 * v16) - (float)(var0 * v17));
    v19 = (float)((float)(var1 * v17) + (float)(var0 * v16)) + a5->var0.y;
    v21 = a3->var1.var0;
    v20 = a3->var1.var1;
    v22 = *((float *)a2 + 16);
    v23 = *((float *)a2 + 17);
    v24 = a3->var0.x + (float)((float)(v20 * v22) - (float)(v21 * v23));
    v25 = (float)(v20 * v23) + (float)(v21 * v22);
    v26 = -3.4028e38;
    v27 = v18 - v24;
    v28 = v19 - (float)(v25 + a3->var0.y);
    v29 = (float)(v21 * v28) + (float)(v20 * v27);
    v30 = (float)(v20 * v28) - (float)(v21 * v27);
    v31 = (v9 >> 3);
    v32 = (float *)(*((_QWORD *)a2 + 5) + 4);
    do
    {
      v33 = v30 * *v32;
      if ((float)(v33 + (float)(*(v32 - 1) * v29)) > v26)
      {
        v13 = v12;
        v26 = v33 + (float)(*(v32 - 1) * v29);
      }
      ++v12;
      v32 += 2;
    }
    while (v31 != v12);
  }
  v34 = b2EdgeSeparation(a2, a3, v13, a4, a5);
  if (v13 <= 0)
    v35 = v11;
  else
    v35 = v13 - 1;
  v36 = b2EdgeSeparation(a2, a3, v35, a4, a5);
  if (v13 + 1 < (int)v10)
    v37 = v13 + 1;
  else
    v37 = 0;
  v38 = b2EdgeSeparation(a2, a3, v37, a4, a5);
  v39 = v36 > v38 && v36 > v34;
  if (!v39)
  {
    if (v38 <= v34)
      goto LABEL_28;
    v35 = v37;
    v36 = v38;
  }
  do
  {
    v34 = v36;
    v13 = v35;
    if (v39)
    {
      if (v35 <= 0)
        v35 = v11;
      else
        --v35;
    }
    else if (v35 + 1 < (int)v10)
    {
      ++v35;
    }
    else
    {
      v35 = 0;
    }
    v36 = b2EdgeSeparation(a2, a3, v35, a4, a5);
  }
  while (v36 > v34);
LABEL_28:
  *a1 = v13;
  return v34;
}

float b2EdgeSeparation(const b2PolygonShape *a1, const b2Transform *a2, unsigned int a3, const b2PolygonShape *a4, const b2Transform *a5)
{
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  float *v8;
  float var1;
  float var0;
  float v11;
  float v12;
  float v13;
  float v14;
  float v15;
  uint64_t v16;
  uint64_t v17;
  float v18;
  uint64_t v19;
  float *v20;
  float v21;
  float v22;
  float *v23;

  if ((a3 & 0x80000000) != 0
    || (v5 = *((_QWORD *)a1 + 2), (int)((unint64_t)(*((_QWORD *)a1 + 3) - v5) >> 3) <= (int)a3))
  {
    b2EdgeSeparation();
  }
  v6 = *((_QWORD *)a4 + 2);
  v7 = *((_QWORD *)a4 + 3) - v6;
  v8 = (float *)(*((_QWORD *)a1 + 5) + 8 * a3);
  var0 = a2->var1.var0;
  var1 = a2->var1.var1;
  v11 = v8[1];
  v12 = (float)(var1 * *v8) - (float)(var0 * v11);
  v13 = (float)(var1 * v11) + (float)(var0 * *v8);
  v15 = a5->var1.var0;
  v14 = a5->var1.var1;
  if ((int)(v7 >> 3) < 1)
  {
    v17 = 0;
  }
  else
  {
    v16 = 0;
    LODWORD(v17) = 0;
    v18 = (float)(v15 * v13) + (float)(v14 * v12);
    v19 = (v7 >> 3);
    v20 = (float *)(v6 + 4);
    v21 = 3.4028e38;
    do
    {
      v22 = (float)((float)(v14 * v13) - (float)(v15 * v12)) * *v20;
      if ((float)(v22 + (float)(*(v20 - 1) * v18)) < v21)
      {
        LODWORD(v17) = v16;
        v21 = v22 + (float)(*(v20 - 1) * v18);
      }
      ++v16;
      v20 += 2;
    }
    while (v19 != v16);
    v17 = (int)v17;
  }
  v23 = (float *)(v5 + 8 * a3);
  return (float)(v13
               * (float)((float)((float)((float)(v14 * *(float *)(v6 + 8 * v17 + 4))
                                       + (float)(v15 * *(float *)(v6 + 8 * v17)))
                               + a5->var0.y)
                       - (float)((float)((float)(var1 * v23[1]) + (float)(var0 * *v23)) + a2->var0.y)))
       + (float)((float)((float)(a5->var0.x
                               + (float)((float)(*(float *)(v6 + 8 * v17 + 4) * (float)-v15)
                                       + (float)(v14 * *(float *)(v6 + 8 * v17))))
                       - (float)(a2->var0.x + (float)((float)(v23[1] * (float)-var0) + (float)(var1 * *v23))))
               * v12);
}

float b2WorldManifold::Initialize(uint64_t a1, uint64_t a2, float *a3, float *a4, float result, float a6)
{
  uint64_t v6;
  float v7;
  float v8;
  float v9;
  float v10;
  float v11;
  float v12;
  float v13;
  float v14;
  float v15;
  float v16;
  float v17;
  float v18;
  float v19;
  float v20;
  float v21;
  float v22;
  float v23;
  float v24;
  float v25;
  float v26;
  float v27;
  float v28;
  float v29;
  float v30;
  float v31;
  float v32;
  float v33;
  float v34;
  float v35;
  float *v36;
  float *v37;
  float *v38;
  float v39;
  float v40;
  float v41;
  float v42;
  float v43;
  float v44;
  float v45;
  float v46;
  float v47;
  float v48;
  float v49;
  float v50;
  float v51;
  float v52;
  float v53;
  float v54;
  float v55;
  float v56;
  float v57;
  float v58;
  float v59;
  float v60;
  float v61;
  float *v62;
  float *v63;
  float *v64;
  float v65;
  float v66;
  float v67;
  float v68;
  float v69;
  float v70;
  float v71;
  float v72;
  float v73;
  float v74;
  float v75;
  float v76;
  float v77;

  v6 = *(unsigned int *)(a2 + 60);
  if ((_DWORD)v6)
  {
    switch(*(_DWORD *)(a2 + 56))
    {
      case 0:
      case 3:
        *(_QWORD *)a1 = 0x3F80000000000000;
        v8 = a3[2];
        v7 = a3[3];
        v9 = *(float *)(a2 + 48);
        v10 = *(float *)(a2 + 52);
        v11 = *a3 + (float)((float)(v7 * v9) - (float)(v8 * v10));
        v12 = (float)((float)(v7 * v10) + (float)(v8 * v9)) + a3[1];
        v14 = a4[2];
        v13 = a4[3];
        v15 = *(float *)(a2 + 4);
        v16 = *a4 + (float)((float)(v13 * *(float *)a2) - (float)(v14 * v15));
        v17 = (float)((float)(v13 * v15) + (float)(v14 * *(float *)a2)) + a4[1];
        if ((float)((float)((float)(v12 - v17) * (float)(v12 - v17)) + (float)((float)(v11 - v16) * (float)(v11 - v16))) <= 1.4211e-14)
        {
          v18 = 0.0;
          v19 = 1.0;
        }
        else
        {
          v18 = v16 - v11;
          v19 = v17 - v12;
          *(float *)a1 = v16 - v11;
          *(float *)(a1 + 4) = v17 - v12;
          v20 = sqrtf((float)(v19 * v19) + (float)(v18 * v18));
          if (v20 >= 0.00000011921)
          {
            v21 = 1.0 / v20;
            v18 = v18 * v21;
            v19 = v19 * v21;
            *(float *)a1 = v18;
            *(float *)(a1 + 4) = v19;
          }
        }
        v74 = v11 + (float)(v18 * result);
        v75 = v12 + (float)(v19 * result);
        v76 = v16 - (float)(v18 * a6);
        v77 = v17 - (float)(v19 * a6);
        *(float *)(a1 + 8) = (float)(v74 + v76) * 0.5;
        *(float *)(a1 + 12) = (float)(v75 + v77) * 0.5;
        result = (float)(v19 * (float)(v77 - v75)) + (float)((float)(v76 - v74) * v18);
        *(float *)(a1 + 24) = result;
        break;
      case 1:
        v23 = a3[2];
        v22 = a3[3];
        v24 = *(float *)(a2 + 40);
        v25 = *(float *)(a2 + 44);
        v26 = (float)(v22 * v24) - (float)(v23 * v25);
        v27 = (float)(v22 * v25) + (float)(v23 * v24);
        *(float *)a1 = v26;
        *(float *)(a1 + 4) = v27;
        if ((int)v6 >= 1)
        {
          v29 = a3[2];
          v28 = a3[3];
          v30 = *(float *)(a2 + 48);
          v31 = *(float *)(a2 + 52);
          v32 = *a3 + (float)((float)(v28 * v30) - (float)(v29 * v31));
          v33 = (float)((float)(v28 * v31) + (float)(v29 * v30)) + a3[1];
          v34 = v26 * a6;
          v35 = v27 * a6;
          v36 = (float *)(a2 + 4);
          v37 = (float *)(a1 + 24);
          v38 = (float *)(a1 + 12);
          do
          {
            v39 = *(v36 - 1);
            v41 = a4[2];
            v40 = a4[3];
            v42 = *a4 + (float)((float)(v40 * v39) - (float)(v41 * *v36));
            v43 = (float)((float)(v40 * *v36) + (float)(v41 * v39)) + a4[1];
            v44 = result - (float)((float)(v27 * (float)(v43 - v33)) + (float)((float)(v42 - v32) * v26));
            v45 = v42 + (float)(v26 * v44);
            v46 = v43 + (float)(v27 * v44);
            v47 = v43 - v35;
            *(v38 - 1) = (float)((float)(v42 - v34) + v45) * 0.5;
            *v38 = (float)(v47 + v46) * 0.5;
            *v37++ = (float)(v27 * (float)(v47 - v46)) + (float)((float)((float)(v42 - v34) - v45) * v26);
            v36 += 5;
            v38 += 2;
            --v6;
          }
          while (v6);
        }
        break;
      case 2:
        v49 = a4[2];
        v48 = a4[3];
        v50 = *(float *)(a2 + 40);
        v51 = *(float *)(a2 + 44);
        v52 = (float)(v48 * v50) - (float)(v49 * v51);
        v53 = (float)(v48 * v51) + (float)(v49 * v50);
        *(float *)a1 = v52;
        *(float *)(a1 + 4) = v53;
        if ((int)v6 >= 1)
        {
          v55 = a4[2];
          v54 = a4[3];
          v56 = *(float *)(a2 + 48);
          v57 = *(float *)(a2 + 52);
          v58 = *a4 + (float)((float)(v54 * v56) - (float)(v55 * v57));
          v59 = (float)((float)(v54 * v57) + (float)(v55 * v56)) + a4[1];
          v60 = v52 * result;
          v61 = v53 * result;
          v62 = (float *)(a2 + 4);
          v63 = (float *)(a1 + 24);
          v64 = (float *)(a1 + 12);
          do
          {
            v65 = *(v62 - 1);
            v67 = a3[2];
            v66 = a3[3];
            v68 = *a3 + (float)((float)(v66 * v65) - (float)(v67 * *v62));
            v69 = (float)((float)(v66 * *v62) + (float)(v67 * v65)) + a3[1];
            v70 = a6 - (float)((float)(v53 * (float)(v69 - v59)) + (float)((float)(v68 - v58) * v52));
            v71 = v68 + (float)(v52 * v70);
            v72 = v69 + (float)(v53 * v70);
            v73 = v69 - v61;
            *(v64 - 1) = (float)((float)(v68 - v60) + v71) * 0.5;
            *v64 = (float)(v73 + v72) * 0.5;
            *v63++ = (float)(v53 * (float)(v73 - v72)) + (float)((float)((float)(v68 - v60) - v71) * v52);
            v62 += 5;
            v64 += 2;
            --v6;
          }
          while (v6);
        }
        result = -v52;
        *(float *)a1 = -v52;
        *(float *)(a1 + 4) = -v53;
        break;
      default:
        return result;
    }
  }
  return result;
}

unint64_t b2GetPointStates(unint64_t result, _DWORD *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t i;
  int v7;
  uint64_t v8;
  int *v9;
  int v10;
  uint64_t j;
  int v12;
  uint64_t v13;
  unsigned int *v14;
  unsigned int v15;

  *(_DWORD *)result = 0;
  *a2 = 0;
  *(_DWORD *)(result + 4) = 0;
  a2[1] = 0;
  v4 = *(unsigned int *)(a3 + 60);
  v5 = *(unsigned int *)(a4 + 60);
  if ((int)v4 >= 1)
  {
    for (i = 0; i != v4; ++i)
    {
      v7 = *(_DWORD *)(a3 + 20 * i + 16);
      *(_DWORD *)(result + 4 * i) = 3;
      v8 = v5;
      v9 = (int *)(a4 + 16);
      if ((int)v5 >= 1)
      {
        while (1)
        {
          v10 = *v9;
          v9 += 5;
          if (v10 == v7)
            break;
          if (!--v8)
            goto LABEL_8;
        }
        *(_DWORD *)(result + 4 * i) = 2;
      }
LABEL_8:
      ;
    }
  }
  if ((int)v5 >= 1)
  {
    for (j = 0; j != v5; ++j)
    {
      v12 = *(_DWORD *)(a4 + 20 * j + 16);
      a2[j] = 1;
      v13 = v4;
      v14 = (unsigned int *)(a3 + 16);
      if ((int)v4 >= 1)
      {
        while (1)
        {
          v15 = *v14;
          v14 += 5;
          result = v15;
          if (v15 == v12)
            break;
          if (!--v13)
            goto LABEL_16;
        }
        a2[j] = 2;
      }
LABEL_16:
      ;
    }
  }
  return result;
}

uint64_t b2AABB::RayCast(uint64_t a1, uint64_t a2, float32x2_t *a3)
{
  uint64_t v3;
  uint64_t v4;
  char v5;
  float v6;
  float v7;
  char v8;
  float v9;
  float v10;
  float v11;
  float v12;
  float v13;
  float v14;
  BOOL v15;
  float v16;
  float v17;
  float v18;
  uint64_t result;
  uint64_t v20;
  int8x8_t v21;
  float32x2_t v22;
  float32x2_t v23;

  v3 = 0;
  v23 = *a3;
  v22 = vsub_f32(a3[1], v23);
  v4 = a1 + 8;
  v5 = 1;
  v21 = vbsl_s8((int8x8_t)vcgtz_f32(v22), (int8x8_t)v22, (int8x8_t)vneg_f32(v22));
  v6 = -3.4028e38;
  v7 = 3.4028e38;
  do
  {
    v8 = v5;
    if (*(float *)&v21.i32[v3] >= 0.00000011921)
    {
      v10 = 1.0 / v22.f32[v3];
      v11 = v23.f32[v3];
      v12 = v10 * (float)(*(float *)(a1 + 4 * v3) - v11);
      v13 = *(float *)(v4 + 4 * v3) - v11;
      v14 = v10 * v13;
      v15 = v12 <= (float)(v10 * v13);
      if (v12 <= (float)(v10 * v13))
        v16 = v12;
      else
        v16 = v10 * v13;
      if (v15)
        v17 = v14;
      else
        v17 = v12;
      if (v16 > v6)
      {
        if (v12 <= v14)
          v18 = -1.0;
        else
          v18 = 1.0;
        v20 = 0;
        *((float *)&v20 + v3) = v18;
        v6 = v16;
      }
      if (v7 >= v17)
        v7 = v17;
      if (v6 > v7)
        return 0;
    }
    else
    {
      v9 = v23.f32[v3];
      if (v9 < *(float *)(a1 + 4 * v3) || *(float *)(v4 + 4 * v3) < v9)
        return 0;
    }
    v5 = 0;
    v3 = 1;
  }
  while ((v8 & 1) != 0);
  result = 0;
  if (v6 >= 0.0 && a3[2].f32[0] >= v6)
  {
    *(float *)(a2 + 8) = v6;
    *(_QWORD *)a2 = v20;
    return 1;
  }
  return result;
}

uint64_t b2ClipSegmentToLine(uint64_t a1, uint64_t *a2, float *a3, __int8 a4, float a5)
{
  float v5;
  float v6;
  float v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  float32x2_t *v12;

  v5 = a3[1];
  v6 = (float)((float)(v5 * *((float *)a2 + 1)) + (float)(*a3 * *(float *)a2)) - a5;
  v7 = (float)((float)(v5 * *((float *)a2 + 4)) + (float)(*a3 * *((float *)a2 + 3))) - a5;
  if (v6 <= 0.0)
  {
    v9 = *a2;
    *(_DWORD *)(a1 + 8) = *((_DWORD *)a2 + 2);
    *(_QWORD *)a1 = v9;
    v8 = 1;
  }
  else
  {
    v8 = 0;
  }
  if (v7 <= 0.0)
  {
    v10 = a1 + 12 * v8;
    v11 = *(uint64_t *)((char *)a2 + 12);
    v8 = (v8 + 1);
    *(_DWORD *)(v10 + 8) = *((_DWORD *)a2 + 5);
    *(_QWORD *)v10 = v11;
  }
  if ((float)(v6 * v7) < 0.0)
  {
    v12 = (float32x2_t *)(a1 + 12 * v8);
    *v12 = vadd_f32(*(float32x2_t *)a2, vmul_n_f32(vsub_f32(*(float32x2_t *)((char *)a2 + 12), *(float32x2_t *)a2), v6 / (float)(v6 - v7)));
    v12[1].i8[0] = a4;
    v12[1].i8[1] = *((_BYTE *)a2 + 9);
    v12[1].i16[1] = 256;
    return (v8 + 1);
  }
  return v8;
}

BOOL b2TestOverlap(b2Shape *a1, int a2, b2Shape *a3, int a4, const b2Transform *a5, const b2Transform *a6)
{
  __int128 v10;
  _BYTE v12[16];
  float v13;
  _BYTE v14[4];
  __int16 v15;
  _BYTE v16[16];
  uint64_t v17;
  uint64_t v18;
  _QWORD v19[4];
  __int128 v20;
  __int128 v21;
  char v22;

  v17 = 0;
  v18 = 0;
  v19[2] = 0;
  v19[3] = 0;
  b2DistanceProxy::Set((b2DistanceProxy *)v16, a1, a2);
  b2DistanceProxy::Set((b2DistanceProxy *)v19, a3, a4);
  v10 = (__int128)*a6;
  v20 = (__int128)*a5;
  v21 = v10;
  v22 = 1;
  v15 = 0;
  b2Distance((uint64_t)v12, (uint64_t)v14, (uint64_t)v16);
  return v13 < 0.0000011921;
}

float b2DistanceProxy::Set(b2DistanceProxy *this, b2Shape *a2, int a3)
{
  uint64_t v5;
  uint64_t v6;
  float result;
  _QWORD *Vertex;
  uint64_t v10;
  unsigned __int8 v11;
  int v12;

  switch(*((_DWORD *)a2 + 2))
  {
    case 0:
      *((_QWORD *)this + 2) = (char *)a2 + 16;
      goto LABEL_11;
    case 1:
      *((_QWORD *)this + 2) = (char *)a2 + 16;
      goto LABEL_14;
    case 2:
      v5 = *((_QWORD *)a2 + 2);
      v6 = *((_QWORD *)a2 + 3);
      *((_QWORD *)this + 2) = v5;
      result = *((float *)a2 + 3);
      *((float *)this + 7) = result;
      *((_DWORD *)this + 6) = (unint64_t)(v6 - v5) >> 3;
      return result;
    case 3:
      if (a3 < 0 || (int)((*((_QWORD *)a2 + 3) - *((_QWORD *)a2 + 2)) >> 3) <= a3)
        b2DistanceProxy::Set();
      *(_QWORD *)this = *(_QWORD *)b2ChainShape::GetVertex((b2ChainShape *)a2, a3);
      Vertex = (_QWORD *)*((_QWORD *)a2 + 2);
      v10 = (*((_QWORD *)a2 + 3) - (_QWORD)Vertex) >> 3;
      if (a3 + 1 >= (int)v10)
      {
        if ((int)v10 <= 0)
          b2ChainShape::GetVertex();
      }
      else
      {
        Vertex = (_QWORD *)b2ChainShape::GetVertex((b2ChainShape *)a2, a3 + 1);
      }
      *((_QWORD *)this + 1) = *Vertex;
      *((_QWORD *)this + 2) = this;
LABEL_14:
      v12 = 2;
      break;
    case 4:
      {
        b2DistanceProxy::Set(b2Shape const*,int)::dummy = 0;
      }
      *((_QWORD *)this + 2) = &b2DistanceProxy::Set(b2Shape const*,int)::dummy;
LABEL_11:
      v12 = 1;
      break;
    default:
      b2DistanceProxy::Set();
  }
  *((_DWORD *)this + 6) = v12;
  result = *((float *)a2 + 3);
  *((float *)this + 7) = result;
  return result;
}

__n128 b2Simplex::Solve2(__n128 *this)
{
  float v1;
  float v2;
  __n128 *v3;
  float v4;
  float v5;
  float v6;
  float v7;
  float v8;
  float v9;
  float v10;
  float v11;
  float v12;
  __n128 result;
  __n128 v14;
  __n128 v15;

  v1 = this[1].n128_f32[0];
  v2 = this[1].n128_f32[1];
  v3 = (__n128 *)((char *)this + 36);
  v4 = this[3].n128_f32[1];
  v5 = this[3].n128_f32[2];
  v6 = v4 - v1;
  v7 = v5 - v2;
  v8 = v2 * (float)(v5 - v2);
  v9 = v8 + (float)(v1 * (float)(v4 - v1));
  if (v9 >= 0.0)
  {
    this[1].n128_u32[2] = 1065353216;
    this[6].n128_u32[3] = 1;
    this[4].n128_u32[1] = this[2].n128_u32[0];
    result = *this;
    v14 = this[1];
    *v3 = *this;
    *(__n128 *)((char *)this + 52) = v14;
  }
  else
  {
    v10 = (float)(v5 * v7) + (float)(v4 * v6);
    if (v10 <= 0.0)
    {
      this[3].n128_u32[3] = 1065353216;
      this[6].n128_u32[3] = 1;
      result = *v3;
      v15 = *(__n128 *)((char *)this + 52);
      *this = *v3;
      this[1] = v15;
      this[2].n128_u32[0] = this[4].n128_u32[1];
    }
    else
    {
      v11 = -(float)(v8 + (float)(v1 * v6));
      v12 = 1.0 / (float)(v10 - v9);
      this[1].n128_f32[2] = v10 * v12;
      result.n128_f32[0] = v12 * v11;
      this[3].n128_u32[3] = result.n128_u32[0];
      this[6].n128_u32[3] = 2;
    }
  }
  return result;
}

uint64_t b2Simplex::Solve3(uint64_t this)
{
  float v1;
  float v2;
  float v3;
  float v4;
  float v5;
  float v6;
  float v7;
  float v8;
  float v9;
  float v10;
  float v11;
  float v12;
  float v13;
  float v14;
  int v15;
  float v16;
  float v17;
  float v18;
  float v19;
  _OWORD *v20;
  _OWORD *v21;
  float v22;
  float v23;
  float v24;
  __int128 v25;
  float v26;
  float v27;
  float v28;
  __int128 v29;
  int v30;
  float v31;
  int v32;
  float v33;
  float v34;
  __int128 v35;
  float v36;

  v1 = *(float *)(this + 16);
  v2 = *(float *)(this + 20);
  v3 = *(float *)(this + 52);
  v4 = *(float *)(this + 56);
  v5 = *(float *)(this + 88);
  v6 = *(float *)(this + 92);
  v7 = v3 - v1;
  v8 = v4 - v2;
  v9 = v2 * (float)(v4 - v2);
  v10 = v9 + (float)(v1 * (float)(v3 - v1));
  v11 = v5 - v1;
  v12 = v6 - v2;
  v13 = v2 * (float)(v6 - v2);
  v14 = v13 + (float)(v1 * (float)(v5 - v1));
  if (v10 >= 0.0 && v14 >= 0.0)
  {
    *(_DWORD *)(this + 24) = 1065353216;
    v15 = 1;
LABEL_8:
    *(_DWORD *)(this + 108) = v15;
    return this;
  }
  v16 = (float)(v4 * v8) + (float)(v3 * v7);
  v17 = (float)(v7 * v12) - (float)(v8 * v11);
  v18 = (float)((float)(v1 * v4) - (float)(v2 * v3)) * v17;
  if (v16 > 0.0 && v10 < 0.0 && v18 <= 0.0)
  {
    v19 = 1.0 / (float)(v16 - v10);
    *(float *)(this + 24) = v16 * v19;
    *(float *)(this + 60) = v19 * (float)-(float)(v9 + (float)(v1 * v7));
    v15 = 2;
    goto LABEL_8;
  }
  v20 = (_OWORD *)(this + 36);
  v21 = (_OWORD *)(this + 72);
  v22 = (float)(v6 * v12) + (float)(v5 * v11);
  v23 = v17 * (float)((float)(v5 * v2) - (float)(v6 * v1));
  if (v22 <= 0.0 || v14 >= 0.0 || v23 > 0.0)
  {
    v26 = v5 - v3;
    v27 = v4 * (float)(v6 - v4);
    v28 = v27 + (float)(v3 * (float)(v5 - v3));
    if (v16 > 0.0 || v28 < 0.0)
    {
      v31 = (float)(v6 * (float)(v6 - v4)) + (float)(v5 * v26);
      if (v22 > 0.0 || v31 > 0.0)
      {
        v33 = (float)((float)(v3 * v6) - (float)(v4 * v5)) * v17;
        if (v31 <= 0.0 || v28 >= 0.0 || v33 > 0.0)
        {
          v36 = 1.0 / (float)(v18 + (float)(v33 + v23));
          *(float *)(this + 24) = v33 * v36;
          *(float *)(this + 60) = v23 * v36;
          *(float *)(this + 96) = v18 * v36;
          v15 = 3;
          goto LABEL_8;
        }
        v34 = 1.0 / (float)(v31 - v28);
        *(float *)(this + 60) = v31 * v34;
        *(float *)(this + 96) = v34 * (float)-(float)(v27 + (float)(v3 * v26));
        v32 = 2;
      }
      else
      {
        *(_DWORD *)(this + 96) = 1065353216;
        v32 = 1;
      }
      *(_DWORD *)(this + 108) = v32;
      v35 = *(_OWORD *)(this + 88);
      *(_OWORD *)this = *v21;
      *(_OWORD *)(this + 16) = v35;
      v30 = *(_DWORD *)(this + 104);
    }
    else
    {
      *(_DWORD *)(this + 60) = 1065353216;
      *(_DWORD *)(this + 108) = 1;
      v29 = *(_OWORD *)(this + 52);
      *(_OWORD *)this = *v20;
      *(_OWORD *)(this + 16) = v29;
      v30 = *(_DWORD *)(this + 68);
    }
    *(_DWORD *)(this + 32) = v30;
  }
  else
  {
    v24 = 1.0 / (float)(v22 - v14);
    *(float *)(this + 24) = v22 * v24;
    *(float *)(this + 96) = v24 * (float)-(float)(v13 + (float)(v1 * v11));
    *(_DWORD *)(this + 108) = 2;
    v25 = *(_OWORD *)(this + 88);
    *v20 = *v21;
    *(_OWORD *)(this + 52) = v25;
    *(_DWORD *)(this + 68) = *(_DWORD *)(this + 104);
  }
  return this;
}

int32x4_t b2Distance(uint64_t a1, uint64_t a2, uint64_t a3)
{
  __int128 v6;
  int v7;
  int v8;
  uint64_t v9;
  _DWORD *v10;
  _DWORD *v11;
  uint64_t v12;
  int *v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  float SearchDirection;
  float v19;
  int v20;
  uint64_t v21;
  float *v22;
  uint64_t v23;
  int v24;
  float v25;
  float v26;
  float v27;
  float *v28;
  uint64_t i;
  float *v30;
  float v31;
  float v32;
  float v33;
  float *v34;
  float v35;
  uint64_t v36;
  float *v37;
  uint64_t v38;
  int v39;
  float v40;
  float v41;
  float v42;
  float *v43;
  uint64_t j;
  float *v45;
  float v46;
  float v47;
  float v48;
  float *v49;
  _DWORD *v50;
  int *v51;
  int v52;
  int v53;
  int32x4_t result;
  float v55;
  float v56;
  float32x4_t v58;
  float32x4_t v59;
  float v60;
  float32x4_t v61;
  __int128 v62;
  __n128 v63[2];
  uint64_t v64;
  int v65;
  __int128 v66;
  __int128 v67;
  _BYTE v68[12];
  _BYTE v69[12];
  uint64_t v70;

  v70 = *MEMORY[0x24BDAC8D0];
  ++b2_gjkCalls;
  v6 = *(_OWORD *)(a3 + 64);
  v66 = *(_OWORD *)(a3 + 80);
  v67 = v6;
  b2Simplex::ReadCache((b2Simplex *)v63, a2, a3, (float *)&v67, a3 + 32, (float *)&v66);
  b2Simplex::GetClosestPoint((b2Simplex *)v63);
  v7 = 0;
  v8 = v65;
  do
  {
    v9 = v8;
    if (v8 >= 1)
    {
      v10 = v68;
      v11 = v69;
      v12 = v8;
      v13 = (int *)&v64;
      do
      {
        *v11++ = *(v13 - 1);
        v14 = *v13;
        v13 += 9;
        *v10++ = v14;
        --v12;
      }
      while (v12);
    }
    if (v8 != 1)
    {
      if (v8 == 2)
      {
        b2Simplex::Solve2(v63);
      }
      else
      {
        if (v8 != 3)
          b2Distance();
        b2Simplex::Solve3((uint64_t)v63);
      }
    }
    if (v65 == 3)
      break;
    b2Simplex::GetClosestPoint((b2Simplex *)v63);
    SearchDirection = b2Simplex::GetSearchDirection((b2Simplex *)v63);
    if ((float)((float)(v19 * v19) + (float)(SearchDirection * SearchDirection)) < 1.4211e-14)
      break;
    v20 = v65;
    v21 = *((_QWORD *)&v67 + 1);
    v22 = *(float **)(a3 + 16);
    v23 = *(unsigned int *)(a3 + 24);
    if ((int)v23 <= 1)
    {
      v24 = 0;
      v63[1].n128_u32[9 * v65 + 3] = 0;
    }
    else
    {
      v24 = 0;
      v25 = (float)-(float)(v19 * *((float *)&v67 + 2)) - (float)(*((float *)&v67 + 3) * SearchDirection);
      v26 = (float)(*((float *)&v67 + 2) * SearchDirection) - (float)(v19 * *((float *)&v67 + 3));
      v27 = (float)(v26 * v22[1]) + (float)(*v22 * v25);
      v28 = v22 + 3;
      for (i = 1; i != v23; ++i)
      {
        if ((float)((float)(v26 * *v28) + (float)(*(v28 - 1) * v25)) > v27)
        {
          v24 = i;
          v27 = (float)(v26 * *v28) + (float)(*(v28 - 1) * v25);
        }
        v28 += 2;
      }
      v63[1].n128_u32[9 * v65 + 3] = v24;
      if (v24 < 0)
LABEL_48:
        b2Distance(v15, v16, v17);
    }
    if ((int)v23 <= v24)
      goto LABEL_48;
    v30 = &v22[2 * v24];
    v31 = *v30;
    v32 = v30[1];
    v33 = *(float *)&v67 + (float)((float)(v32 * (float)-*(float *)&v21) + (float)(*((float *)&v21 + 1) * *v30));
    v34 = (float *)v63 + 9 * v20;
    v35 = (float)((float)(*((float *)&v21 + 1) * v32) + (float)(*(float *)&v21 * v31)) + *((float *)&v67 + 1);
    *v34 = v33;
    v34[1] = v35;
    v36 = *((_QWORD *)&v66 + 1);
    v37 = *(float **)(a3 + 48);
    v38 = *(unsigned int *)(a3 + 56);
    if ((int)v38 <= 1)
    {
      v39 = 0;
      v63[2].n128_u32[9 * v20] = 0;
    }
    else
    {
      v39 = 0;
      v40 = (float)(v19 * *((float *)&v66 + 2)) + (float)(*((float *)&v66 + 3) * SearchDirection);
      v41 = (float)(v19 * *((float *)&v66 + 3)) - (float)(*((float *)&v66 + 2) * SearchDirection);
      v42 = (float)(v41 * v37[1]) + (float)(*v37 * v40);
      v43 = v37 + 3;
      for (j = 1; j != v38; ++j)
      {
        if ((float)((float)(v41 * *v43) + (float)(*(v43 - 1) * v40)) > v42)
        {
          v39 = j;
          v42 = (float)(v41 * *v43) + (float)(*(v43 - 1) * v40);
        }
        v43 += 2;
      }
      v63[2].n128_u32[9 * v20] = v39;
      if (v39 < 0)
LABEL_49:
        b2Distance(v15, v16, v17);
    }
    if ((int)v38 <= v39)
      goto LABEL_49;
    v45 = &v37[2 * v39];
    v46 = v45[1];
    v47 = *(float *)&v66 + (float)((float)(v46 * (float)-*(float *)&v36) + (float)(*((float *)&v36 + 1) * *v45));
    v48 = (float)((float)(*((float *)&v36 + 1) * v46) + (float)(*(float *)&v36 * *v45)) + *((float *)&v66 + 1);
    v49 = (float *)v63 + 9 * v20;
    v49[2] = v47;
    v49[3] = v48;
    v49[4] = v47 - v33;
    v49[5] = v48 - v35;
    ++v7;
    ++b2_gjkIters;
    v50 = v68;
    v51 = (int *)v69;
    do
    {
      v52 = *v51++;
      if (v24 == v52 && v39 == *v50)
        goto LABEL_35;
      ++v50;
      --v9;
    }
    while (v9);
    v8 = v20 + 1;
    v65 = v20 + 1;
  }
  while (v7 != 20);
LABEL_35:
  v53 = b2_gjkMaxIters;
  if (b2_gjkMaxIters <= v7)
    v53 = v7;
  b2_gjkMaxIters = v53;
  b2Simplex::GetWitnessPoints((uint64_t)v63, (b2Vec2 *)a1, (b2Vec2 *)(a1 + 8));
  *(float *)(a1 + 16) = sqrtf((float)((float)(*(float *)(a1 + 4) - *(float *)(a1 + 12))* (float)(*(float *)(a1 + 4) - *(float *)(a1 + 12)))+ (float)((float)(*(float *)a1 - *(float *)(a1 + 8)) * (float)(*(float *)a1 - *(float *)(a1 + 8))));
  *(_DWORD *)(a1 + 20) = v7;
  b2Simplex::WriteCache((int *)v63, a2);
  if (*(_BYTE *)(a3 + 96))
  {
    result.i32[0] = *(_DWORD *)(a3 + 28);
    v55 = *(float *)(a3 + 60);
    v56 = *(float *)(a1 + 16);
    if (v56 <= (float)(*(float *)result.i32 + v55) || v56 <= 0.00000011921)
    {
      *(float32x2_t *)result.i8 = vmul_f32(vadd_f32(*(float32x2_t *)a1, *(float32x2_t *)(a1 + 8)), (float32x2_t)0x3F0000003F000000);
      result.i64[1] = result.i64[0];
      *(int32x4_t *)a1 = result;
      *(_DWORD *)(a1 + 16) = 0;
    }
    else
    {
      *(float *)(a1 + 16) = v56 - (float)(*(float *)result.i32 + v55);
      v58 = *(float32x4_t *)a1;
      *(float32x2_t *)v59.f32 = vsub_f32((float32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v58, (int8x16_t)v58, 8uLL), *(float32x2_t *)a1);
      v60 = sqrtf(vmlas_n_f32(COERCE_FLOAT(vmul_f32(*(float32x2_t *)&v59, *(float32x2_t *)&v59).i32[1]), v59.f32[0], v59.f32[0]));
      if (v60 >= 0.00000011921)
        *(float32x2_t *)v59.f32 = vmul_n_f32(*(float32x2_t *)v59.f32, 1.0 / v60);
      v59.i64[1] = v59.i64[0];
      *(float *)&result.i32[1] = v55;
      v61 = vmulq_f32((float32x4_t)vzip1q_s32(result, result), v59);
      *(_QWORD *)&v62 = vaddq_f32(v58, v61).u64[0];
      result = (int32x4_t)vsubq_f32(v58, v61);
      *((_QWORD *)&v62 + 1) = result.i64[1];
      *(_OWORD *)a1 = v62;
    }
  }
  return result;
}

void b2Simplex::ReadCache(b2Simplex *this, uint64_t a2, uint64_t a3, float *a4, uint64_t a5, float *a6)
{
  uint64_t v6;
  uint64_t v12;
  int v13;
  char *v14;
  uint64_t v15;
  unsigned int v16;
  float *v17;
  float v18;
  float *v19;
  float v20;
  float v21;
  float v22;
  float v23;
  float v24;
  float v25;
  float v26;
  float v27;
  float v28;
  float v29;
  float v30;
  float Metric;
  float *v32;
  float v33;
  float v34;
  float *v35;
  float v36;
  float v37;
  float v38;
  float v39;
  float v40;
  float v41;
  float v42;
  float v43;
  float v44;
  float v45;

  v6 = *(unsigned __int16 *)(a2 + 4);
  if (v6 >= 4)
    b2Simplex::ReadCache();
  *((_DWORD *)this + 27) = v6;
  if (!(_DWORD)v6)
  {
LABEL_10:
    *((_DWORD *)this + 7) = 0;
    *((_DWORD *)this + 8) = 0;
    if (*(int *)(a3 + 24) <= 0)
      b2Distance((uint64_t)this, a2, a3);
    if (*(int *)(a5 + 24) <= 0)
      b2Distance((uint64_t)this, a2, a3);
    v32 = *(float **)(a3 + 16);
    v34 = *v32;
    v33 = v32[1];
    v35 = *(float **)(a5 + 16);
    v36 = *v35;
    v37 = v35[1];
    v39 = a4[2];
    v38 = a4[3];
    v40 = *a4 + (float)((float)(v38 * v34) - (float)(v39 * v33));
    v41 = (float)((float)(v33 * v38) + (float)(v39 * v34)) + a4[1];
    *(float *)this = v40;
    *((float *)this + 1) = v41;
    v43 = a6[2];
    v42 = a6[3];
    v44 = *a6 + (float)((float)(v42 * v36) - (float)(v43 * v37));
    v45 = (float)((float)(v37 * v42) + (float)(v43 * v36)) + a6[1];
    *((float *)this + 2) = v44;
    *((float *)this + 3) = v45;
    *((float *)this + 4) = v44 - v40;
    *((float *)this + 5) = v45 - v41;
    *((_DWORD *)this + 6) = 1065353216;
    *((_DWORD *)this + 27) = 1;
    return;
  }
  v12 = 0;
  v13 = *(_DWORD *)(a3 + 24);
  v14 = (char *)this + 16;
  do
  {
    v15 = *(unsigned __int8 *)(a2 + v12 + 6);
    *((_DWORD *)v14 + 3) = v15;
    v16 = *(unsigned __int8 *)(a2 + v12 + 9);
    *((_DWORD *)v14 + 4) = v16;
    if (v13 <= (int)v15)
      b2Distance((uint64_t)this, a2, a3);
    if (*(_DWORD *)(a5 + 24) <= (signed int)v16)
      b2Distance((uint64_t)this, a2, a3);
    v17 = (float *)(*(_QWORD *)(a3 + 16) + 8 * v15);
    v18 = v17[1];
    v19 = (float *)(*(_QWORD *)(a5 + 16) + 8 * v16);
    v20 = *v19;
    v21 = v19[1];
    v23 = a4[2];
    v22 = a4[3];
    v24 = *a4 + (float)((float)(v22 * *v17) - (float)(v23 * v18));
    v25 = (float)((float)(v18 * v22) + (float)(v23 * *v17)) + a4[1];
    *((float *)v14 - 4) = v24;
    *((float *)v14 - 3) = v25;
    v27 = a6[2];
    v26 = a6[3];
    v28 = *a6 + (float)((float)(v26 * v20) - (float)(v27 * v21));
    v29 = (float)((float)(v21 * v26) + (float)(v27 * v20)) + a6[1];
    *((float *)v14 - 2) = v28;
    *((float *)v14 - 1) = v29;
    *(float *)v14 = v28 - v24;
    *((float *)v14 + 1) = v29 - v25;
    *((_DWORD *)v14 + 2) = 0;
    ++v12;
    v14 += 36;
  }
  while (v6 != v12);
  if (v6 > 1)
  {
    v30 = *(float *)a2;
    Metric = b2Simplex::GetMetric(this);
    if (Metric < (float)(v30 * 0.5) || (float)(v30 + v30) < Metric || Metric < 0.00000011921)
    {
      *((_DWORD *)this + 27) = 0;
    }
    else if (*((_DWORD *)this + 27))
    {
      return;
    }
    goto LABEL_10;
  }
}

float32x2_t b2Simplex::GetClosestPoint(b2Simplex *this)
{
  float32x2_t result;
  unsigned __int8 v2;

  switch(*((_DWORD *)this + 27))
  {
    case 0:
      b2Simplex::GetClosestPoint();
    case 1:
      result = *(float32x2_t *)((char *)this + 16);
      break;
    case 2:
      result = vadd_f32(vmul_n_f32(*(float32x2_t *)((char *)this + 16), *((float *)this + 6)), vmul_n_f32(*(float32x2_t *)((char *)this + 52), *((float *)this + 15)));
      break;
    case 3:
      if ((v2 & 1) == 0)
      {
        {
          b2Vec2_zero_fn(void)::b2Vec2_zero_init = 0;
        }
      }
      result = (float32x2_t)b2Vec2_zero_fn(void)::b2Vec2_zero_init;
      break;
    default:
      b2Simplex::GetClosestPoint();
  }
  return result;
}

float b2Simplex::GetSearchDirection(b2Simplex *this)
{
  int v1;
  float result;
  float v3;

  v1 = *((_DWORD *)this + 27);
  if (v1 == 2)
  {
    v3 = *((float *)this + 5);
    result = *((float *)this + 14) - v3;
    if ((float)((float)(*((float *)this + 4) * result)
               - (float)((float)(*((float *)this + 13) - *((float *)this + 4)) * v3)) > 0.0)
      return -result;
  }
  else
  {
    if (v1 != 1)
      b2Simplex::GetSearchDirection();
    return -*((float *)this + 4);
  }
  return result;
}

uint64_t b2Simplex::GetWitnessPoints(uint64_t this, b2Vec2 *a2, b2Vec2 *a3)
{
  b2Vec2 v3;

  switch(*(_DWORD *)(this + 108))
  {
    case 0:
      b2Simplex::GetWitnessPoints();
    case 1:
      *a2 = *(b2Vec2 *)this;
      *a3 = *(b2Vec2 *)(this + 8);
      return this;
    case 2:
      *a2 = (b2Vec2)vadd_f32(vmul_n_f32(*(float32x2_t *)this, *(float *)(this + 24)), vmul_n_f32(*(float32x2_t *)(this + 36), *(float *)(this + 60)));
      v3 = (b2Vec2)vadd_f32(vmul_n_f32(*(float32x2_t *)(this + 8), *(float *)(this + 24)), vmul_n_f32(*(float32x2_t *)(this + 44), *(float *)(this + 60)));
      goto LABEL_5;
    case 3:
      v3 = (b2Vec2)vadd_f32(vadd_f32(vmul_n_f32(*(float32x2_t *)this, *(float *)(this + 24)), vmul_n_f32(*(float32x2_t *)(this + 36), *(float *)(this + 60))), vmul_n_f32(*(float32x2_t *)(this + 72), *(float *)(this + 96)));
      *a2 = v3;
LABEL_5:
      *a3 = v3;
      return this;
    default:
      b2Simplex::GetWitnessPoints();
  }
}

void b2Simplex::WriteCache(int *a1, uint64_t a2)
{
  int v4;
  uint64_t v5;
  int *v6;
  uint64_t v7;
  int v8;

  *(float *)a2 = b2Simplex::GetMetric((b2Simplex *)a1);
  v4 = a1[27];
  *(_WORD *)(a2 + 4) = v4;
  if (v4 >= 1)
  {
    v5 = 0;
    v6 = a1 + 8;
    do
    {
      v7 = a2 + v5;
      *(_BYTE *)(v7 + 6) = *(v6 - 1);
      v8 = *v6;
      v6 += 9;
      *(_BYTE *)(v7 + 9) = v8;
      ++v5;
    }
    while (v5 < a1[27]);
  }
}

float b2Simplex::GetMetric(b2Simplex *this)
{
  float result;

  switch(*((_DWORD *)this + 27))
  {
    case 0:
      b2Simplex::GetMetric();
    case 1:
      result = 0.0;
      break;
    case 2:
      result = sqrtf((float)((float)(*((float *)this + 5) - *((float *)this + 14))* (float)(*((float *)this + 5) - *((float *)this + 14)))+ (float)((float)(*((float *)this + 4) - *((float *)this + 13))* (float)(*((float *)this + 4) - *((float *)this + 13))));
      break;
    case 3:
      result = (float)((float)(*((float *)this + 13) - *((float *)this + 4))
                     * (float)(*((float *)this + 23) - *((float *)this + 5)))
             - (float)((float)(*((float *)this + 14) - *((float *)this + 5))
                     * (float)(*((float *)this + 22) - *((float *)this + 4)));
      break;
    default:
      b2Simplex::GetMetric();
  }
  return result;
}

void OUTLINED_FUNCTION_0(const char *a1, const char *a2, uint64_t a3, const char *a4)
{
  __assert_rtn(a1, a2, 104, a4);
}

void QuadTree::QuadTree(QuadTree *this, float a2, float a3, float a4, float a5, float a6)
{
  uint64_t v12;

  v12 = operator new();
  *(float *)(v12 + 32) = a2;
  *(float *)(v12 + 36) = a3;
  *(float *)(v12 + 40) = a4;
  *(float *)(v12 + 44) = a5;
  *(float *)(v12 + 48) = a6;
  *(_BYTE *)(v12 + 52) = -1;
  *(_OWORD *)v12 = 0u;
  *(_OWORD *)(v12 + 16) = 0u;
  *(_QWORD *)this = v12;
}

{
  uint64_t v12;

  v12 = operator new();
  *(float *)(v12 + 32) = a2;
  *(float *)(v12 + 36) = a3;
  *(float *)(v12 + 40) = a4;
  *(float *)(v12 + 44) = a5;
  *(float *)(v12 + 48) = a6;
  *(_BYTE *)(v12 + 52) = -1;
  *(_OWORD *)v12 = 0u;
  *(_OWORD *)(v12 + 16) = 0u;
  *(_QWORD *)this = v12;
}

void QuadTreeNode::QuadTreeNode(QuadTreeNode *this, float a2, float a3, float a4, float a5, float a6)
{
  *((float *)this + 8) = a2;
  *((float *)this + 9) = a3;
  *((float *)this + 10) = a4;
  *((float *)this + 11) = a5;
  *((float *)this + 12) = a6;
  *((_BYTE *)this + 52) = -1;
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
}

{
  *((float *)this + 8) = a2;
  *((float *)this + 9) = a3;
  *((float *)this + 10) = a4;
  *((float *)this + 11) = a5;
  *((float *)this + 12) = a6;
  *((_BYTE *)this + 52) = -1;
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
}

void QuadTree::~QuadTree(QuadTree *this)
{
  QuadTreeNode **v1;

  v1 = *(QuadTreeNode ***)this;
  if (v1)
  {
    QuadTreeNode::~QuadTreeNode(v1);
    MEMORY[0x20BD0BA58]();
  }
}

uint64_t QuadTree::add(QuadTree *this, float a2, float a3, char a4)
{
  return QuadTreeNode::add(*(_QWORD *)this, a2, a3, a4);
}

uint64_t QuadTreeNode::add(uint64_t this, float a2, float a3, char a4)
{
  uint64_t v6;
  float v7;
  float v8;
  unsigned int v9;
  uint64_t v10;
  float v11;
  float v12;
  BOOL v13;

  v6 = this;
  v7 = *(float *)(this + 32);
  v8 = *(float *)(this + 36) - v7;
  if (v8 > *(float *)(this + 48))
  {
    do
    {
      if ((float)(v7 + (float)(v8 * 0.5)) <= a2)
        v9 = 3;
      else
        v9 = 2;
      if ((float)(*(float *)(v6 + 40) + (float)((float)(*(float *)(v6 + 44) - *(float *)(v6 + 40)) * 0.5)) <= a3)
        v10 = (float)(v7 + (float)(v8 * 0.5)) > a2;
      else
        v10 = v9;
      this = *(_QWORD *)(v6 + 8 * v10);
      if (!this)
        __asm { BR              X8 }
      v12 = *(float *)(this + 32);
      v11 = *(float *)(this + 36);
      v8 = v11 - v12;
      v13 = (float)(v11 - v12) > *(float *)(this + 48);
      v7 = *(float *)(this + 32);
      v6 = *(_QWORD *)(v6 + 8 * v10);
    }
    while (v13);
  }
  *(_BYTE *)(this + 52) = a4;
  return this;
}

uint64_t QuadTree::addLine(QuadTree *this, float a2, float a3, float a4, float a5, signed __int8 a6)
{
  return QuadTreeNode::addLine(*(_QWORD *)this, a2, a3, a4, a5, a6);
}

uint64_t QuadTreeNode::addLine(uint64_t this, float a2, float a3, float a4, float a5, signed __int8 a6)
{
  float v7;
  uint64_t v10;
  float *v11;
  float v12;
  float *v13;
  float v14;
  float v15;
  float *v16;
  float v17;
  float v18;
  float v19;
  float v20;
  float v21;
  float v22;
  float v23;
  float v24;
  float v25;
  float v26;
  float v27;
  float v28;
  float v29;
  float v30;
  BOOL v31;
  float v32;
  float v33;
  float v34;
  float v35;
  float v37;
  float v38;
  float v39;
  float v40;
  float v41;
  float v42;
  float v43;
  uint64_t v44;
  float v45;
  float v46;
  float v47;
  float v48;
  float v49;
  float v50;
  float v52;
  float v53;
  float v54;
  float v55;
  float v56;
  float v58;
  float v59;
  float v60;
  float v61;
  float v62;
  float v63;
  float v64;
  float v65;
  uint64_t v66;
  float v67;
  float v68;
  float v69;
  float v70;
  float v71;
  float v72;
  float v73;
  float v74;
  float v75;
  float v77;
  float v78;
  float v79;
  float v80;
  float v81;
  float v82;
  float v83;
  float v84;
  float v85;
  float v86;
  float v87;
  float v88;
  uint64_t v89;
  float v90;
  float v91;
  float v92;
  float v93;
  float v94;
  float v95;
  float v96;
  float v97;
  float v98;
  float v99;
  float v100;
  float v101;
  float v102;
  float v103;
  float v104;
  float v105;
  float v106;
  float v107;
  float v108;
  float v109;
  float *v110;
  float v111;
  float v112;
  float v114;
  float v115;
  float v116;
  float v117;
  float v118;
  float v119;
  float v120;
  float v121;

  v7 = a4;
  v10 = this;
  v11 = (float *)(this + 36);
  v12 = *(float *)(this + 36);
  v13 = (float *)(this + 32);
  v14 = *(float *)(this + 32);
  v15 = v12 - v14;
  v16 = (float *)(this + 48);
  if ((float)(v12 - v14) <= *(float *)(this + 48))
  {
LABEL_95:
    *(_BYTE *)(v10 + 52) = a6;
  }
  else
  {
    v17 = a5;
    v120 = a5 - a3;
    v121 = a4 - a2;
    v18 = -(float)(a4 - a2);
    v119 = -(float)(a5 - a3);
    v19 = 1.0;
    while (1)
    {
      v20 = v15 * 0.5;
      v21 = *(float *)(v10 + 40);
      v22 = *(float *)(v10 + 44);
      v115 = (float)(v22 - v21) * 0.5;
      v116 = v20;
      v23 = v14 + v20;
      v24 = v21 + v115;
      v25 = v23 - v23;
      v26 = (float)(v21 + v115) - v22;
      v27 = v22 - a3;
      v117 = v120 * (float)(v23 - v23);
      v118 = (float)(v14 + v20) - a2;
      v28 = v117 + (float)(v18 * v26);
      v114 = v118 * v119;
      v29 = (float)(v118 * v119) + (float)(v121 * (float)(v22 - a3));
      if ((float)(v29 / v28) <= v19 && (float)(v29 / v28) >= 0.0)
      {
        v30 = (float)((float)(v25 * v27) - (float)(v26 * v118)) / v28;
        v31 = v30 < 0.0 || v30 > v19;
        if (!v31)
          goto LABEL_25;
      }
      v32 = -v26;
      v33 = (float)(v120 * (float)(v12 - v12)) + (float)(v18 * v26);
      v34 = (float)((float)((float)(v12 - a2) * v119) + (float)(v121 * v27)) / v33;
      if (v34 <= v19 && v34 >= 0.0)
      {
        v35 = (float)((float)((float)(v12 - v12) * v27) + (float)(v32 * (float)(v12 - a2))) / v33;
        if (v35 >= 0.0 && v35 <= v19)
          goto LABEL_25;
      }
      if ((v37 = v12 - v23, v38 = (float)(v120 * v37) + (float)(v18 * (float)(v22 - v22)), v39 = v29 / v38, v39 <= v19)
        && v39 >= 0.0
        && (v40 = (float)((float)(v37 * v27) - (float)((float)(v22 - v22) * v118)) / v38, v40 >= 0.0)
        && v40 <= v19
        || (v41 = (float)(v120 * v37) + (float)(v18 * (float)(v24 - v24)),
            v42 = (float)(v114 + (float)(v121 * (float)(v24 - a3))) / v41,
            v42 <= v19)
        && v42 >= 0.0
        && (v43 = (float)((float)(v37 * (float)(v24 - a3)) - (float)((float)(v24 - v24) * v118)) / v41, v43 >= 0.0)
        && v43 <= v19)
      {
LABEL_25:
        v44 = *(_QWORD *)v10;
        if (!*(_QWORD *)v10)
        {
          v44 = operator new();
          v45 = *v16;
          *(float *)(v44 + 32) = v23;
          *(float *)(v44 + 36) = v116 + v23;
          *(float *)(v44 + 40) = v24;
          *(float *)(v44 + 44) = v115 + v24;
          *(float *)(v44 + 48) = v45;
          *(_BYTE *)(v44 + 52) = -1;
          *(_OWORD *)v44 = 0u;
          *(_OWORD *)(v44 + 16) = 0u;
          *(_QWORD *)v10 = v44;
        }
        this = QuadTreeNode::addLine((QuadTreeNode *)v44, a2, a3, v7, v17, a6);
        v14 = *v13;
        v22 = *(float *)(v10 + 44);
        v26 = v24 - v22;
        v32 = -(float)(v24 - v22);
        v27 = v22 - a3;
        v19 = 1.0;
      }
      v46 = v14 - a2;
      v47 = (float)(v120 * (float)(v14 - v14)) + (float)(v18 * v26);
      v48 = (float)(v14 - a2) * v119;
      v49 = v48 + (float)(v121 * v27);
      if ((float)(v49 / v47) <= v19 && (float)(v49 / v47) >= 0.0)
      {
        v50 = (float)((float)((float)(v14 - v14) * v27) + (float)(v32 * v46)) / v47;
        if (v50 >= 0.0 && v50 <= v19)
          goto LABEL_50;
      }
      v52 = *v11 - *v11;
      v53 = *v11 - a2;
      v54 = (float)(v120 * v52) + (float)(v18 * v26);
      v55 = (float)((float)(v53 * v119) + (float)(v121 * v27)) / v54;
      if (v55 <= v19 && v55 >= 0.0)
      {
        v56 = (float)((float)(v27 * v52) + (float)(v32 * v53)) / v54;
        if (v56 >= 0.0 && v56 <= v19)
          goto LABEL_50;
      }
      v58 = v23 - v14;
      v59 = (float)(v120 * v58) + (float)(v18 * (float)(v22 - v22));
      v60 = v49 / v59;
      if (v60 <= v19 && v60 >= 0.0)
      {
        v61 = (float)((float)(v58 * v27) - (float)((float)(v22 - v22) * v46)) / v59;
        if (v61 >= 0.0 && v61 <= v19)
          goto LABEL_50;
      }
      v62 = v24 - a3;
      v63 = (float)(v120 * v58) + (float)(v18 * (float)(v24 - v24));
      v64 = (float)(v48 + (float)(v121 * (float)(v24 - a3))) / v63;
      if (v64 <= v19 && v64 >= 0.0)
      {
        v65 = (float)((float)(v62 * v58) - (float)((float)(v24 - v24) * v46)) / v63;
        if (v65 >= 0.0 && v65 <= v19)
        {
LABEL_50:
          v66 = *(_QWORD *)(v10 + 8);
          if (!v66)
          {
            v66 = operator new();
            v67 = v116 + *v13;
            v68 = *v16;
            *(float *)(v66 + 32) = *v13;
            *(float *)(v66 + 36) = v67;
            *(float *)(v66 + 40) = v24;
            *(float *)(v66 + 44) = v115 + v24;
            *(float *)(v66 + 48) = v68;
            *(_BYTE *)(v66 + 52) = -1;
            *(_OWORD *)v66 = 0u;
            *(_OWORD *)(v66 + 16) = 0u;
            *(_QWORD *)(v10 + 8) = v66;
          }
          this = QuadTreeNode::addLine((QuadTreeNode *)v66, a2, a3, v7, v17, a6);
          v62 = v24 - a3;
          v19 = 1.0;
        }
      }
      v69 = v17;
      v70 = *(float *)(v10 + 40);
      v71 = v70 - v24;
      v72 = v25 * v62;
      v73 = v117 + (float)(v18 * (float)(v70 - v24));
      v74 = v114 + (float)(v121 * v62);
      if ((float)(v74 / v73) <= v19 && (float)(v74 / v73) >= 0.0)
      {
        v75 = (float)(v72 - (float)(v71 * v118)) / v73;
        if (v75 >= 0.0 && v75 <= v19)
          goto LABEL_72;
      }
      v77 = *v11;
      v78 = *v11 - a2;
      v79 = (float)(v120 * (float)(v77 - v77)) + (float)(v18 * v71);
      v80 = (float)((float)(v78 * v119) + (float)(v121 * v62)) / v79;
      if (v80 <= v19 && v80 >= 0.0)
      {
        v81 = (float)((float)(v62 * (float)(v77 - v77)) + (float)((float)-v71 * v78)) / v79;
        if (v81 >= 0.0 && v81 <= v19)
          goto LABEL_72;
      }
      if ((v82 = v77 - v23,
            v83 = v120 * (float)(v77 - v23),
            v84 = v83 + (float)(v18 * (float)(v24 - v24)),
            (float)(v74 / v84) <= v19)
        && (float)(v74 / v84) >= 0.0
        && (v85 = (float)((float)(v62 * v82) - (float)((float)(v24 - v24) * v118)) / v84, v85 >= 0.0)
        && v85 <= v19
        || (v86 = v83 + (float)(v18 * (float)(v70 - v70)),
            v87 = (float)(v114 + (float)(v121 * (float)(v70 - a3))) / v86,
            v87 <= v19)
        && v87 >= 0.0
        && (v88 = (float)((float)((float)(v70 - a3) * v82) - (float)((float)(v70 - v70) * v118)) / v86, v88 >= 0.0)
        && v88 <= v19)
      {
LABEL_72:
        v89 = *(_QWORD *)(v10 + 16);
        if (!v89)
        {
          v89 = operator new();
          v90 = v116 + *v13;
          v91 = *(float *)(v10 + 40);
          v92 = *v16;
          *(float *)(v89 + 32) = *v13;
          *(float *)(v89 + 36) = v90;
          *(float *)(v89 + 40) = v91;
          *(float *)(v89 + 44) = v115 + v91;
          *(float *)(v89 + 48) = v92;
          *(_BYTE *)(v89 + 52) = -1;
          *(_OWORD *)v89 = 0u;
          *(_OWORD *)(v89 + 16) = 0u;
          *(_QWORD *)(v10 + 16) = v89;
        }
        this = QuadTreeNode::addLine((QuadTreeNode *)v89, a2, a3, a4, v69, a6);
        v70 = *(float *)(v10 + 40);
        v19 = 1.0;
      }
      v93 = *v13;
      v94 = *v13 - a2;
      v95 = v23 - a3;
      v96 = (float)(v120 * (float)(v93 - v93)) + (float)(v18 * (float)(v70 - v23));
      v97 = (float)(v94 * v119) + (float)(v121 * (float)(v23 - a3));
      if ((float)(v97 / v96) > v19
        || (float)(v97 / v96) < 0.0
        || (v98 = (float)((float)(v95 * (float)(v93 - v93)) - (float)((float)(v70 - v23) * v94)) / v96, v98 < 0.0)
        || v98 > v19)
      {
        v99 = v117 + (float)(v18 * (float)(v70 - v24));
        if ((float)(v74 / v99) > v19
          || (float)(v74 / v99) < 0.0
          || (v100 = (float)(v72 - (float)((float)(v70 - v24) * v118)) / v99, v100 < 0.0)
          || v100 > v19)
        {
          v101 = v23 - v93;
          v102 = (float)(v120 * v101) + (float)(v18 * (float)(v24 - v23));
          v103 = v97 / v102;
          if (v103 > v19
            || v103 < 0.0
            || (v104 = (float)((float)(v95 * v101) - (float)((float)(v24 - v23) * v94)) / v102, v104 < 0.0)
            || v104 > v19)
          {
            v105 = v70 - v70;
            v106 = v70 - a3;
            v107 = (float)(v120 * v101) + (float)(v18 * (float)(v70 - v70));
            v108 = (float)((float)(v94 * v119) + (float)(v121 * v106)) / v107;
            if (v108 > v19)
              break;
            if (v108 < 0.0)
              break;
            v109 = (float)((float)(v101 * v106) - (float)(v105 * v94)) / v107;
            if (v109 < 0.0 || v109 > v19)
              break;
          }
        }
      }
      v110 = *(float **)(v10 + 24);
      if (v110)
      {
        v23 = v110[8];
        v12 = v110[9];
        v10 = *(_QWORD *)(v10 + 24);
        v111 = v110[12];
      }
      else
      {
        this = operator new();
        v19 = 1.0;
        v112 = *(float *)(v10 + 40);
        v12 = v116 + v23;
        v111 = *v16;
        *(float *)(this + 32) = v23;
        *(float *)(this + 36) = v116 + v23;
        *(float *)(this + 40) = v112;
        *(float *)(this + 44) = v115 + v112;
        *(float *)(this + 48) = v111;
        *(_BYTE *)(this + 52) = -1;
        *(_OWORD *)this = 0u;
        *(_OWORD *)(this + 16) = 0u;
        *(_QWORD *)(v10 + 24) = this;
        v10 = this;
      }
      v17 = v69;
      v7 = a4;
      v11 = (float *)(v10 + 36);
      v13 = (float *)(v10 + 32);
      v15 = v12 - v23;
      v16 = (float *)(v10 + 48);
      v31 = (float)(v12 - v23) > v111;
      v14 = v23;
      if (!v31)
        goto LABEL_95;
    }
  }
  return this;
}

uint64_t QuadTree::find(QuadTree *this, float a2, float a3, QuadTreeNode ***a4)
{
  return QuadTreeNode::find(*(QuadTreeNode ***)this, a2, a3, a4);
}

uint64_t QuadTreeNode::find(QuadTreeNode **this, float a2, float a3, QuadTreeNode ***a4)
{
  QuadTreeNode *v9;
  QuadTreeNode *v10;
  QuadTreeNode *v11;
  QuadTreeNode *v12;

  *a4 = this;
  if (*((float *)this + 8) > a2
    || *((float *)this + 9) < a2
    || *((float *)this + 10) > a3
    || *((float *)this + 11) < a3)
  {
    return 0;
  }
  v9 = *this;
  if (!*this)
  {
    v10 = this[1];
    if (!v10)
    {
      if (!this[2] && !this[3])
        return 1;
      goto LABEL_15;
    }
LABEL_11:
    if ((QuadTreeNode::find(v10, a2, a3, (QuadTreeNode **)a4) & 1) != 0)
      return 1;
    goto LABEL_15;
  }
  if ((QuadTreeNode::find(v9, a2, a3, (QuadTreeNode **)a4) & 1) != 0)
    return 1;
  v10 = this[1];
  if (v10)
    goto LABEL_11;
LABEL_15:
  v11 = this[2];
  if (!v11 || (QuadTreeNode::find(v11, a2, a3, (QuadTreeNode **)a4) & 1) == 0)
  {
    v12 = this[3];
    if (!v12 || (QuadTreeNode::find(v12, a2, a3, (QuadTreeNode **)a4) & 1) == 0)
      return 0;
  }
  return 1;
}

BOOL QuadTree::intersectPoint(QuadTree *this, float a2, float a3, QuadTreeNode **a4)
{
  QuadTreeNode **v5;
  QuadTreeNode **v6;
  QuadTreeNode **v8;
  QuadTreeNode **v9;
  uint64_t v10;

  v8 = 0;
  v9 = 0;
  v10 = 0;
  QuadTree::intersectBox((uint64_t *)this, (uint64_t)&v8, a2, a3, a2, a3);
  v5 = v8;
  v6 = v9;
  if (v9 != v8)
  {
    *a4 = *v8;
LABEL_4:
    v9 = v5;
    operator delete(v5);
    return v6 != v5;
  }
  if (v9)
    goto LABEL_4;
  return v6 != v5;
}

void sub_208FAECB4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

BOOL QuadTree::intersectBox(uint64_t *a1, uint64_t a2, float a3, float a4, float a5, float a6)
{
  void *v7;
  void *v8;

  QuadTreeNode::intersectBox(*a1, (void **)a2, a3, a4, a5, a6);
  v7 = *(void **)(a2 + 8);
  if (v7 == *(void **)a2)
  {
    v8 = *(void **)(a2 + 8);
  }
  else
  {
    printf("--- %lu\n", ((uint64_t)v7 - *(_QWORD *)a2) >> 3);
    v7 = *(void **)a2;
    v8 = *(void **)(a2 + 8);
  }
  return v8 != v7;
}

uint64_t QuadTreeNode::intersectBox(uint64_t a1, void **a2, float a3, float a4, float a5, float a6)
{
  int v7;
  int v8;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  _QWORD *v18;
  _QWORD *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;
  char *v24;
  char *v25;
  char *v26;
  char *v27;
  char *v28;
  uint64_t v29;

  if (*(float *)(a1 + 32) <= a5)
  {
    v14 = a1;
    v7 = 0;
    while (1)
    {
      if (*(float *)(v14 + 36) < a3 || *(float *)(v14 + 40) > a6 || *(float *)(v14 + 44) < a4)
        goto LABEL_3;
      if (*(_QWORD *)v14)
        break;
      v15 = *(_QWORD *)(v14 + 8);
      if (v15)
        goto LABEL_13;
      if (!*(_QWORD *)(v14 + 16) && !*(_QWORD *)(v14 + 24))
      {
        v17 = (unint64_t)a2[2];
        v18 = a2[1];
        if ((unint64_t)v18 >= v17)
        {
          v20 = ((char *)v18 - (_BYTE *)*a2) >> 3;
          if ((unint64_t)(v20 + 1) >> 61)
            std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
          v21 = v17 - (_QWORD)*a2;
          v22 = v21 >> 2;
          if (v21 >> 2 <= (unint64_t)(v20 + 1))
            v22 = v20 + 1;
          if ((unint64_t)v21 >= 0x7FFFFFFFFFFFFFF8)
            v23 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v23 = v22;
          if (v23)
            v24 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKPoint>>((uint64_t)(a2 + 2), v23);
          else
            v24 = 0;
          v25 = &v24[8 * v20];
          v26 = &v24[8 * v23];
          *(_QWORD *)v25 = v14;
          v19 = v25 + 8;
          v28 = (char *)*a2;
          v27 = (char *)a2[1];
          if (v27 != *a2)
          {
            do
            {
              v29 = *((_QWORD *)v27 - 1);
              v27 -= 8;
              *((_QWORD *)v25 - 1) = v29;
              v25 -= 8;
            }
            while (v27 != v28);
            v27 = (char *)*a2;
          }
          *a2 = v25;
          a2[1] = v19;
          a2[2] = v26;
          if (v27)
            operator delete(v27);
        }
        else
        {
          *v18 = v14;
          v19 = v18 + 1;
        }
        a2[1] = v19;
        v8 = 1;
        return v8 & (v7 ^ 1u);
      }
LABEL_14:
      v16 = *(_QWORD *)(v14 + 16);
      if (v16)
        QuadTreeNode::intersectBox(v16, a2, a3, a4, a5, a6);
      v14 = *(_QWORD *)(v14 + 24);
      if (v14)
      {
        v7 = 1;
        if (*(float *)(v14 + 32) <= a5)
          continue;
      }
      goto LABEL_3;
    }
    QuadTreeNode::intersectBox(*(_QWORD *)v14, a2, a3, a4, a5, a6);
    v15 = *(_QWORD *)(v14 + 8);
    if (!v15)
      goto LABEL_14;
LABEL_13:
    QuadTreeNode::intersectBox(v15, a2, a3, a4, a5, a6);
    goto LABEL_14;
  }
  v7 = 0;
LABEL_3:
  v8 = 0;
  return v8 & (v7 ^ 1u);
}

BOOL QuadTree::intersectRay(QuadTree *this, float a2, float a3, float a4, float a5, QuadTreeNode **a6)
{
  return QuadTree::intersectVector(this, a2, a3, a4 - a2, a5 - a3, a6);
}

BOOL QuadTree::intersectVector(QuadTree *this, float a2, float a3, float a4, float a5, QuadTreeNode **a6)
{
  _BOOL8 v9;
  _BYTE *v10;
  QuadTreeNode *v11;
  uint64_t v12;
  float **v13;
  uint64_t v14;
  float *v15;
  float *v16;
  float v17;
  float v18;
  void *__p;
  _BYTE *v21;
  uint64_t v22;

  __p = 0;
  v21 = 0;
  v22 = 0;
  v9 = QuadTreeNode::intersectVector(*(QuadTreeNode **)this, &__p, a2, a3, a4, a5);
  v10 = __p;
  if (v9 && (unint64_t)(v21 - (_BYTE *)__p) >= 9)
  {
    v11 = 0;
    v12 = 2;
    if ((unint64_t)((v21 - (_BYTE *)__p) >> 3) > 2)
      v12 = (v21 - (_BYTE *)__p) >> 3;
    v13 = (float **)((char *)__p + 8);
    v14 = v12 - 1;
    do
    {
      v16 = *v13++;
      v15 = v16;
      v17 = a2 - (float)((float)(v16[8] + v16[9]) * 0.5);
      v18 = a3 - (float)((float)(v16[10] + v16[11]) * 0.5);
      if ((float)((float)(v18 * v18) + (float)(v17 * v17)) < 3.4028e38)
        v11 = (QuadTreeNode *)v15;
      --v14;
    }
    while (v14);
    *a6 = v11;
    goto LABEL_11;
  }
  *a6 = 0;
  if (v10)
  {
LABEL_11:
    v21 = v10;
    operator delete(v10);
  }
  return v9;
}

void sub_208FAEFF4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

BOOL QuadTreeNode::intersectVector(QuadTreeNode *a1, void **a2, float a3, float a4, float a5, float a6)
{
  _BOOL8 result;
  QuadTreeNode *v13;
  QuadTreeNode *v14;
  QuadTreeNode *v15;
  unint64_t v16;
  QuadTreeNode **v17;
  _QWORD *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  char *v23;
  QuadTreeNode **v24;
  char *v25;
  char *v26;
  char *v27;
  QuadTreeNode *v28;

  result = QuadTreeNode::intersectVectorSelf(a1, a3, a4, a5, a6);
  if (!result)
    return result;
  if (*(_QWORD *)a1)
  {
    if (QuadTreeNode::intersectVectorSelf(*(QuadTreeNode **)a1, a3, a4, a5, a6))
      return 1;
    v13 = (QuadTreeNode *)*((_QWORD *)a1 + 1);
    if (!v13)
      goto LABEL_11;
  }
  else
  {
    v13 = (QuadTreeNode *)*((_QWORD *)a1 + 1);
    if (!v13)
    {
      if (!*((_QWORD *)a1 + 2) && !*((_QWORD *)a1 + 3))
      {
        v16 = (unint64_t)a2[2];
        v17 = (QuadTreeNode **)a2[1];
        if ((unint64_t)v17 >= v16)
        {
          v19 = ((char *)v17 - (_BYTE *)*a2) >> 3;
          if ((unint64_t)(v19 + 1) >> 61)
            std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
          v20 = v16 - (_QWORD)*a2;
          v21 = v20 >> 2;
          if (v20 >> 2 <= (unint64_t)(v19 + 1))
            v21 = v19 + 1;
          if ((unint64_t)v20 >= 0x7FFFFFFFFFFFFFF8)
            v22 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v22 = v21;
          if (v22)
            v23 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKPoint>>((uint64_t)(a2 + 2), v22);
          else
            v23 = 0;
          v24 = (QuadTreeNode **)&v23[8 * v19];
          v25 = &v23[8 * v22];
          *v24 = a1;
          v18 = v24 + 1;
          v27 = (char *)*a2;
          v26 = (char *)a2[1];
          if (v26 != *a2)
          {
            do
            {
              v28 = (QuadTreeNode *)*((_QWORD *)v26 - 1);
              v26 -= 8;
              *--v24 = v28;
            }
            while (v26 != v27);
            v26 = (char *)*a2;
          }
          *a2 = v24;
          a2[1] = v18;
          a2[2] = v25;
          if (v26)
            operator delete(v26);
        }
        else
        {
          *v17 = a1;
          v18 = v17 + 1;
        }
        a2[1] = v18;
        return 1;
      }
      goto LABEL_11;
    }
  }
  if (QuadTreeNode::intersectVectorSelf(v13, a3, a4, a5, a6))
    return 1;
LABEL_11:
  v14 = (QuadTreeNode *)*((_QWORD *)a1 + 2);
  if (v14 && QuadTreeNode::intersectVectorSelf(v14, a3, a4, a5, a6))
    return 1;
  v15 = (QuadTreeNode *)*((_QWORD *)a1 + 3);
  if (v15)
  {
    if (QuadTreeNode::intersectVectorSelf(v15, a3, a4, a5, a6))
      return 1;
  }
  return 0;
}

float QuadTree::bounds(QuadTree *this, float *a2, float *a3, float *a4, float *a5)
{
  float *v5;
  float result;

  v5 = *(float **)this;
  *a2 = *(float *)(*(_QWORD *)this + 32);
  *a3 = v5[10];
  *a4 = v5[9];
  result = v5[11];
  *a5 = result;
  return result;
}

uint64_t QuadTree::leafCount(QuadTree *this)
{
  return 0;
}

uint64_t QuadTreeNode::leafCount(QuadTreeNode *this)
{
  return 0;
}

void QuadTreeNode::~QuadTreeNode(QuadTreeNode **this)
{
  QuadTreeNode *v2;
  QuadTreeNode *v3;
  QuadTreeNode *v4;
  QuadTreeNode *v5;

  v2 = *this;
  if (v2)
  {
    QuadTreeNode::~QuadTreeNode(v2);
    MEMORY[0x20BD0BA58]();
  }
  v3 = this[1];
  if (v3)
  {
    QuadTreeNode::~QuadTreeNode(v3);
    MEMORY[0x20BD0BA58]();
  }
  v4 = this[2];
  if (v4)
  {
    QuadTreeNode::~QuadTreeNode(v4);
    MEMORY[0x20BD0BA58]();
  }
  v5 = this[3];
  if (v5)
  {
    QuadTreeNode::~QuadTreeNode(v5);
    MEMORY[0x20BD0BA58]();
  }
}

uint64_t get_line_intersection(float a1, float a2, float a3, float a4, float a5, float a6, float a7, float a8, float *a9, float *a10)
{
  uint64_t result;
  float v12;
  float v13;
  float v14;
  float v15;
  float v16;
  float v17;
  float v18;
  float v19;
  float v20;

  result = 0;
  v12 = a3 - a1;
  v13 = a4 - a2;
  v14 = a7 - a5;
  v15 = a8 - a6;
  v16 = a1 - a5;
  v17 = a2 - a6;
  v18 = (float)(v12 * v15) - (float)(v14 * v13);
  v19 = (float)((float)(v14 * v17) - (float)(v15 * v16)) / v18;
  if (v19 <= 1.0 && v19 >= 0.0)
  {
    v20 = (float)((float)(v12 * v17) - (float)(v13 * v16)) / v18;
    if (v20 >= 0.0 && v20 <= 1.0)
    {
      if (a9)
        *a9 = a1 + (float)(v19 * v12);
      if (a10)
        *a10 = a2 + (float)(v19 * v13);
      return 1;
    }
  }
  return result;
}

_BYTE *QuadTreeNode::visitLeaves(_BYTE *result, uint64_t a2)
{
  _QWORD *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _BYTE v12[24];
  _BYTE *v13;
  _BYTE v14[24];
  _BYTE *v15;
  _BYTE v16[24];
  _BYTE *v17;
  _BYTE v18[24];
  _BYTE *v19;
  uint64_t v20;

  v3 = result;
  v20 = *MEMORY[0x24BDAC8D0];
  v4 = *(_QWORD *)result;
  if (*(_QWORD *)result)
  {
    std::__function::__value_func<void ()(float,float,int)>::__value_func[abi:ne180100]((uint64_t)v18, a2);
    QuadTreeNode::visitLeaves(v4, v18);
    result = v19;
    if (v19 == v18)
    {
      v5 = 4;
      result = v18;
    }
    else
    {
      if (!v19)
        goto LABEL_11;
      v5 = 5;
    }
    result = (_BYTE *)(*(uint64_t (**)(void))(*(_QWORD *)result + 8 * v5))();
  }
  else if (!*((_QWORD *)result + 1) && !*((_QWORD *)result + 2) && !*((_QWORD *)result + 3))
  {
    return (_BYTE *)std::function<void ()(float,float,int)>::operator()(a2, (char)result[52], *((float *)result + 8) + (float)((float)(*((float *)result + 9) - *((float *)result + 8)) * 0.5), *((float *)result + 10)+ (float)((float)(*((float *)result + 11) - *((float *)result + 10)) * 0.5));
  }
LABEL_11:
  v6 = v3[1];
  if (!v6)
    goto LABEL_17;
  std::__function::__value_func<void ()(float,float,int)>::__value_func[abi:ne180100]((uint64_t)v16, a2);
  QuadTreeNode::visitLeaves(v6, v16);
  result = v17;
  if (v17 == v16)
  {
    v7 = 4;
    result = v16;
  }
  else
  {
    if (!v17)
      goto LABEL_17;
    v7 = 5;
  }
  result = (_BYTE *)(*(uint64_t (**)(void))(*(_QWORD *)result + 8 * v7))();
LABEL_17:
  v8 = v3[2];
  if (!v8)
    goto LABEL_23;
  std::__function::__value_func<void ()(float,float,int)>::__value_func[abi:ne180100]((uint64_t)v14, a2);
  QuadTreeNode::visitLeaves(v8, v14);
  result = v15;
  if (v15 == v14)
  {
    v9 = 4;
    result = v14;
  }
  else
  {
    if (!v15)
      goto LABEL_23;
    v9 = 5;
  }
  result = (_BYTE *)(*(uint64_t (**)(void))(*(_QWORD *)result + 8 * v9))();
LABEL_23:
  v10 = v3[3];
  if (!v10)
    return result;
  std::__function::__value_func<void ()(float,float,int)>::__value_func[abi:ne180100]((uint64_t)v12, a2);
  QuadTreeNode::visitLeaves(v10, v12);
  result = v13;
  if (v13 == v12)
  {
    v11 = 4;
    result = v12;
  }
  else
  {
    if (!v13)
      return result;
    v11 = 5;
  }
  return (_BYTE *)(*(uint64_t (**)(void))(*(_QWORD *)result + 8 * v11))();
}

void sub_208FAF548(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21)
{
  char *v21;
  char *v23;
  uint64_t v24;

  v23 = a13;
  if (a13 == v21)
  {
    v24 = 4;
    v23 = &a10;
  }
  else
  {
    if (!a13)
      goto LABEL_6;
    v24 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v23 + 8 * v24))();
LABEL_6:
  _Unwind_Resume(exception_object);
}

uint64_t std::function<void ()(float,float,int)>::operator()(uint64_t a1, int a2, float a3, float a4)
{
  uint64_t v4;
  int v6;
  float v7;
  float v8;

  v8 = a3;
  v7 = a4;
  v6 = a2;
  v4 = *(_QWORD *)(a1 + 24);
  if (!v4)
    std::__throw_bad_function_call[abi:ne180100]();
  return (*(uint64_t (**)(uint64_t, float *, float *, int *))(*(_QWORD *)v4 + 48))(v4, &v8, &v7, &v6);
}

BOOL QuadTreeNode::intersectVectorSelf(QuadTreeNode *this, float a2, float a3, float a4, float a5)
{
  float v5;
  float v6;
  float v7;
  float v8;
  float v10;
  float v11;
  _BOOL8 result;
  float v13;
  float v14;
  float v15;
  float v17;
  float v18;
  float v19;

  v6 = *((float *)this + 8);
  v5 = *((float *)this + 9);
  v8 = *((float *)this + 10);
  v7 = *((float *)this + 11);
  if (fabsf(a4) >= 0.00000011921)
  {
    result = 0;
    v13 = (float)(v6 - a2) / a4;
    v14 = (float)(v5 - a2) / a4;
    if (v14 >= v13)
      v15 = v13;
    else
      v15 = v14;
    if (v13 >= v14)
      v14 = v13;
    v11 = fmaxf(v15, -3.4028e38);
    v10 = fminf(v14, 3.4028e38);
    if (v11 > v10 || v10 < 0.0)
      return result;
  }
  else
  {
    if (v6 > a2 || v5 < a2)
      return 0;
    v10 = 3.4028e38;
    v11 = -3.4028e38;
  }
  if (fabsf(a5) < 0.00000011921)
    return v8 <= a3 && v7 >= a3;
  result = 0;
  v17 = (float)(v8 - a3) / a5;
  v18 = (float)(v7 - a3) / a5;
  if (v18 >= v17)
    v19 = v17;
  else
    v19 = v18;
  if (v17 >= v18)
    v18 = v17;
  if (v19 > v11)
    v11 = v19;
  if (v18 < v10)
    v10 = v18;
  if (v11 <= v10 && v10 >= 0.0)
    return 1;
  return result;
}

void std::__throw_bad_function_call[abi:ne180100]()
{
  _QWORD *exception;

  exception = __cxa_allocate_exception(8uLL);
}

void std::bad_function_call::~bad_function_call(std::bad_function_call *this)
{
  std::exception::~exception(this);
  JUMPOUT(0x20BD0BA58);
}

void b2DynamicTree::b2DynamicTree(b2DynamicTree *this)
{
  void *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  *(_DWORD *)this = -1;
  *((_QWORD *)this + 2) = 0x1000000000;
  v2 = b2Alloc(768);
  *((_QWORD *)this + 1) = v2;
  bzero(v2, 48 * *((int *)this + 5));
  v3 = *((int *)this + 5);
  v4 = *((_QWORD *)this + 1);
  if ((int)v3 < 2)
  {
    v7 = v3 - 1;
  }
  else
  {
    v5 = 0;
    v6 = 0;
    do
    {
      *(_DWORD *)(v4 + v5 + 32) = ++v6;
      v4 = *((_QWORD *)this + 1);
      *(_DWORD *)(v4 + v5 + 44) = -1;
      v7 = *((int *)this + 5) - 1;
      v5 += 48;
    }
    while (v6 < v7);
  }
  *(_DWORD *)(v4 + 48 * v7 + 32) = -1;
  *(_DWORD *)(*((_QWORD *)this + 1) + 48 * *((int *)this + 5) - 4) = -1;
  *((_QWORD *)this + 3) = 0;
  *((_DWORD *)this + 8) = 0;
}

void b2DynamicTree::~b2DynamicTree(void **this)
{
  b2Free(this[1]);
}

{
  b2Free(this[1]);
}

double b2DynamicTree::AllocateNode(b2DynamicTree *this)
{
  int v2;
  uint64_t v3;
  int v4;
  void *v5;
  void *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  double result;

  v2 = *((_DWORD *)this + 6);
  if (v2 == -1)
  {
    v4 = *((_DWORD *)this + 4);
    if (v4 != *((_DWORD *)this + 5))
      b2DynamicTree::AllocateNode();
    v5 = (void *)*((_QWORD *)this + 1);
    *((_DWORD *)this + 5) = 2 * v4;
    v6 = b2Alloc(96 * v4);
    *((_QWORD *)this + 1) = v6;
    memcpy(v6, v5, 48 * *((int *)this + 4));
    b2Free(v5);
    v7 = *((int *)this + 4);
    v8 = *((int *)this + 5) - 1;
    v9 = *((_QWORD *)this + 1);
    if ((int)v7 < (int)v8)
    {
      v10 = 48 * v7;
      v11 = v7 + 1;
      do
      {
        ++v7;
        *(_DWORD *)(v9 + v10 + 32) = v11;
        v9 = *((_QWORD *)this + 1);
        *(_DWORD *)(v9 + v10 + 44) = -1;
        v8 = *((int *)this + 5) - 1;
        v10 += 48;
        ++v11;
      }
      while (v7 < v8);
    }
    *(_DWORD *)(v9 + 48 * v8 + 32) = -1;
    v3 = *((_QWORD *)this + 1);
    v2 = *((_DWORD *)this + 4);
    *(_DWORD *)(v3 + 48 * *((int *)this + 5) - 4) = -1;
    *((_DWORD *)this + 6) = v2;
  }
  else
  {
    v3 = *((_QWORD *)this + 1);
  }
  v12 = v3 + 48 * v2;
  *((_DWORD *)this + 6) = *(_DWORD *)(v12 + 32);
  *(_DWORD *)(v12 + 32) = -1;
  v13 = *((_QWORD *)this + 1) + 48 * v2;
  result = NAN;
  *(_QWORD *)(v13 + 36) = -1;
  *(_DWORD *)(v13 + 44) = 0;
  *(_QWORD *)(v13 + 16) = 0;
  *(_QWORD *)(v13 + 24) = 0;
  ++*((_DWORD *)this + 4);
  return result;
}

uint64_t b2DynamicTree::FreeNode(uint64_t this, unsigned int a2)
{
  if ((a2 & 0x80000000) != 0 || *(_DWORD *)(this + 20) <= (signed int)a2)
    b2DynamicTree::FreeNode();
  if (*(int *)(this + 16) <= 0)
    b2DynamicTree::FreeNode();
  *(_DWORD *)(*(_QWORD *)(this + 8) + 48 * a2 + 32) = *(_DWORD *)(this + 24);
  *(_DWORD *)(*(_QWORD *)(this + 8) + 48 * a2 + 44) = -1;
  *(_DWORD *)(this + 24) = a2;
  --*(_DWORD *)(this + 16);
  return this;
}

uint64_t b2DynamicTree::CreateProxyId(b2DynamicTree *a1, float32x2_t *a2)
{
  uint64_t v4;
  uint64_t v5;
  float32x2_t *v6;
  float32x2_t v7;

  b2DynamicTree::AllocateNode(a1);
  v5 = v4;
  v6 = (float32x2_t *)(*((_QWORD *)a1 + 1) + 48 * (int)v4);
  *v6 = vadd_f32(*a2, (float32x2_t)vdup_n_s32(0xBDCCCCCD));
  v6[1] = vadd_f32(a2[1], (float32x2_t)vdup_n_s32(0x3DCCCCCDu));
  v7 = *(float32x2_t *)(*(_QWORD *)&a2[2] + 24);
  v6[2] = (float32x2_t)a2;
  v6[3] = v7;
  v6[5].i32[1] = 0;
  b2DynamicTree::InsertLeaf(a1, v4);
  return v5;
}

void b2DynamicTree::InsertLeaf(b2DynamicTree *this, int a2)
{
  int v4;
  uint64_t v5;
  uint64_t v7;
  int8x16_t v8;
  float v9;
  float v10;
  float32x2_t v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  float v16;
  float v17;
  float v18;
  float v19;
  float v20;
  float v21;
  float v22;
  float v23;
  uint64_t v24;
  float v25;
  float v26;
  float v27;
  float v28;
  float v29;
  float v30;
  float v31;
  float v32;
  float v33;
  float32x2_t *v34;
  float32x2_t v35;
  float32x2_t v36;
  float32x2_t v37;
  float32x2_t v38;
  float32x2_t v39;
  float v40;
  float v41;
  float v42;
  int v44;
  int v45;
  uint64_t v46;
  int8x16_t *v47;
  int8x16_t *v48;
  float32x4_t v49;
  float32x4_t v50;
  uint64_t v51;
  _DWORD *v52;
  int v53;
  uint64_t v54;
  b2DynamicTree *v55;
  uint64_t v56;
  int8x16_t *i;
  uint64_t v58;
  int v59;
  uint64_t v60;
  uint64_t v61;
  int v62;
  int v63;
  int8x16_t *v64;
  __int32 v65;
  int8x16_t *v66;
  int8x16_t v67;
  int8x16_t v68;
  float32x4_t v69;
  float32x4_t v70;
  int8x16_t v71;

  ++*((_DWORD *)this + 8);
  v4 = *(_DWORD *)this;
  if (*(_DWORD *)this == -1)
  {
    *(_DWORD *)this = a2;
    *(_DWORD *)(*((_QWORD *)this + 1) + 48 * a2 + 32) = -1;
  }
  else
  {
    v5 = *((_QWORD *)this + 1);
    v7 = 48 * a2;
    v8 = *(int8x16_t *)(v5 + v7);
    LODWORD(v9) = HIDWORD(*(_QWORD *)(v5 + v7));
    LODWORD(v10) = *(_QWORD *)(v5 + v7 + 8);
    v11 = (float32x2_t)vextq_s8(v8, v8, 8uLL).u64[0];
    do
    {
      v12 = v4;
      v13 = v4;
      v4 = *(_DWORD *)(v5 + 48 * v4 + 36);
      if (v4 == -1)
        break;
      v14 = v5 + 48 * (int)v13;
      v15 = *(_DWORD *)(v14 + 40);
      v16 = *(float *)(v14 + 8);
      v17 = *(float *)(v14 + 12);
      v18 = *(float *)v14;
      v19 = *(float *)(v14 + 4);
      v20 = (float)((float)(v16 - *(float *)v14) + (float)(v17 - v19))
          + (float)((float)(v16 - *(float *)v14) + (float)(v17 - v19));
      if (*(float *)v14 >= *(float *)v8.i32)
        v18 = *(float *)v8.i32;
      if (v19 >= v9)
        v19 = v9;
      if (v16 <= v10)
        v16 = v10;
      if (v17 <= *(float *)&v8.i32[3])
        v17 = *(float *)&v8.i32[3];
      v21 = (float)((float)(v16 - v18) + (float)(v17 - v19)) + (float)((float)(v16 - v18) + (float)(v17 - v19));
      v22 = v21 + v21;
      v23 = (float)(v21 - v20) + (float)(v21 - v20);
      v24 = v5 + 48 * v4;
      v25 = *(float *)(v24 + 4);
      if (*(float *)v8.i32 >= *(float *)v24)
        v26 = *(float *)v24;
      else
        v26 = *(float *)v8.i32;
      if (v9 >= v25)
        v27 = *(float *)(v24 + 4);
      else
        v27 = v9;
      v28 = *(float *)(v24 + 8);
      v29 = *(float *)(v24 + 12);
      if (v10 <= v28)
        v30 = *(float *)(v24 + 8);
      else
        v30 = v10;
      if (*(float *)&v8.i32[3] <= v29)
        v31 = *(float *)(v24 + 12);
      else
        v31 = *(float *)&v8.i32[3];
      v32 = (float)((float)((float)(v30 - v26) + (float)(v31 - v27)) + (float)((float)(v30 - v26) + (float)(v31 - v27)))
          - (float)((float)((float)(v28 - *(float *)v24) + (float)(v29 - v25))
                  + (float)((float)(v28 - *(float *)v24) + (float)(v29 - v25)));
      if (*(_DWORD *)(v24 + 36) == -1)
        v32 = (float)((float)(v30 - v26) + (float)(v31 - v27)) + (float)((float)(v30 - v26) + (float)(v31 - v27));
      v33 = v23 + v32;
      v34 = (float32x2_t *)(v5 + 48 * v15);
      v35 = v34[1];
      v36 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(*v34, *(float32x2_t *)v8.i8), *(int8x8_t *)v8.i8, (int8x8_t)*v34);
      v37 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v11, v35), (int8x8_t)v11, (int8x8_t)v35);
      v38 = vadd_f32(vsub_f32((float32x2_t)vzip1_s32((int32x2_t)v37, (int32x2_t)v35), (float32x2_t)vzip1_s32((int32x2_t)v36, (int32x2_t)*v34)), vsub_f32((float32x2_t)vzip2_s32((int32x2_t)v37, (int32x2_t)v35), (float32x2_t)vzip2_s32((int32x2_t)v36, (int32x2_t)*v34)));
      v39 = vadd_f32(v38, v38);
      LODWORD(v40) = vsub_f32(v39, (float32x2_t)vdup_lane_s32((int32x2_t)v39, 1)).u32[0];
      v35.f32[0] = vaddv_f32(vsub_f32(v37, v36));
      v41 = v35.f32[0] + v35.f32[0];
      if (v34[4].i32[1] == -1)
        v40 = v41;
      v42 = v23 + v40;
      if (v33 >= v42)
        v4 = v15;
    }
    while (v22 >= v33 || v22 >= v42);
    v44 = *(_DWORD *)(v5 + 48 * v13 + 32);
    v71 = v8;
    b2DynamicTree::AllocateNode(this);
    *(_DWORD *)(*((_QWORD *)this + 1) + 48 * v45 + 32) = v44;
    v46 = *((_QWORD *)this + 1);
    v47 = (int8x16_t *)(v46 + 48 * v45);
    v48 = (int8x16_t *)(v46 + 48 * v13);
    v47[1].i64[0] = 0;
    v47[1].i64[1] = 0;
    v49.i64[0] = v71.i64[0];
    v49.i64[1] = v48->i64[1];
    v50.i64[0] = v48->i64[0];
    v50.i64[1] = v71.i64[1];
    *v47 = vbslq_s8((int8x16_t)vcgtq_f32(v50, v49), v71, *v48);
    v47[2].i32[3] = v48[2].i32[3] + 1;
    if (v44 == -1)
    {
      v54 = v46 + 48 * v45;
      *(_DWORD *)(v54 + 36) = v12;
      *(_DWORD *)(v54 + 40) = a2;
      *(_DWORD *)(v46 + 48 * (int)v13 + 32) = v45;
      *(_DWORD *)(*((_QWORD *)this + 1) + 48 * a2 + 32) = v45;
      v55 = this;
    }
    else
    {
      v51 = v46 + 48 * v44;
      v53 = *(_DWORD *)(v51 + 36);
      v52 = (_DWORD *)(v51 + 36);
      if (v53 == v12)
        *v52 = v45;
      else
        *(_DWORD *)(v46 + 48 * v44 + 40) = v45;
      v56 = v46 + 48 * v45;
      *(_DWORD *)(v56 + 36) = v12;
      *(_DWORD *)(v56 + 40) = a2;
      *(_DWORD *)(v46 + 48 * (int)v13 + 32) = v45;
      v55 = (b2DynamicTree *)(*((_QWORD *)this + 1) + 48 * a2 + 32);
    }
    *(_DWORD *)v55 = v45;
    for (i = (int8x16_t *)(*((_QWORD *)this + 1) + 48 * a2); ; *i = vbslq_s8((int8x16_t)vcgtq_f32(v70, v69), v67, v68))
    {
      v58 = i[2].u32[0];
      if ((_DWORD)v58 == -1)
        break;
      v59 = b2DynamicTree::Balance(this, v58);
      v60 = *((_QWORD *)this + 1);
      v61 = v60 + 48 * v59;
      v62 = *(_DWORD *)(v61 + 36);
      if (v62 == -1)
        b2DynamicTree::InsertLeaf();
      v63 = *(_DWORD *)(v61 + 40);
      if (v63 == -1)
        b2DynamicTree::InsertLeaf();
      v64 = (int8x16_t *)(v60 + 48 * v62);
      v65 = v64[2].i32[3];
      v66 = (int8x16_t *)(v60 + 48 * v63);
      if (v65 <= v66[2].i32[3])
        v65 = v66[2].i32[3];
      i = (int8x16_t *)(v60 + 48 * v59);
      v67 = *v64;
      v68 = *v66;
      v69.i64[0] = v64->i64[0];
      v69.i64[1] = v66->i64[1];
      v70.i64[0] = v66->i64[0];
      v70.i64[1] = v64->i64[1];
      i[2].i32[3] = v65 + 1;
    }
  }
}

uint64_t b2DynamicTree::DestroyProxy(b2DynamicTree *this, unsigned int a2)
{
  if ((a2 & 0x80000000) != 0 || *((_DWORD *)this + 5) <= (signed int)a2)
    b2DynamicTree::DestroyProxy();
  if (*(_DWORD *)(*((_QWORD *)this + 1) + 48 * a2 + 36) != -1)
    b2DynamicTree::DestroyProxy();
  b2DynamicTree::RemoveLeaf(this, a2);
  return b2DynamicTree::FreeNode((uint64_t)this, a2);
}

b2DynamicTree *b2DynamicTree::RemoveLeaf(b2DynamicTree *this, int a2)
{
  b2DynamicTree *v2;
  uint64_t v4;
  signed int v5;
  uint64_t v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  _DWORD *v10;
  int v11;
  uint64_t v12;
  int8x16_t *v13;
  int8x16_t *v14;
  int8x16_t *v15;
  float32x4_t v16;
  float32x4_t v17;
  __int32 v18;

  v2 = this;
  if (*(_DWORD *)this == a2)
  {
    *(_DWORD *)this = -1;
  }
  else
  {
    v4 = *((_QWORD *)this + 1);
    v5 = *(_DWORD *)(v4 + 48 * a2 + 32);
    v6 = v4 + 48 * v5;
    v8 = *(unsigned int *)(v6 + 32);
    v7 = *(_DWORD *)(v6 + 36);
    if (v7 == a2)
      v7 = *(_DWORD *)(v4 + 48 * v5 + 40);
    if ((_DWORD)v8 == -1)
    {
      *(_DWORD *)this = v7;
      *(_DWORD *)(v4 + 48 * v7 + 32) = -1;
      return (b2DynamicTree *)b2DynamicTree::FreeNode((uint64_t)this, v5);
    }
    else
    {
      v9 = v4 + 48 * (int)v8;
      v11 = *(_DWORD *)(v9 + 36);
      v10 = (_DWORD *)(v9 + 36);
      if (v11 == v5)
        *v10 = v7;
      else
        *(_DWORD *)(v4 + 48 * (int)v8 + 40) = v7;
      *(_DWORD *)(v4 + 48 * v7 + 32) = v8;
      b2DynamicTree::FreeNode((uint64_t)this, v5);
      do
      {
        this = (b2DynamicTree *)b2DynamicTree::Balance(v2, v8);
        v12 = *((_QWORD *)v2 + 1);
        v13 = (int8x16_t *)(v12 + 48 * (int)this);
        v8 = v13[2].u32[0];
        v14 = (int8x16_t *)(v12 + 48 * v13[2].i32[1]);
        v15 = (int8x16_t *)(v12 + 48 * v13[2].i32[2]);
        v16.i64[0] = v14->i64[0];
        v16.i64[1] = v15->i64[1];
        v17.i64[0] = v15->i64[0];
        v17.i64[1] = v14->i64[1];
        *v13 = vbslq_s8((int8x16_t)vcgtq_f32(v17, v16), *v14, *v15);
        v18 = v15[2].i32[3];
        if (v14[2].i32[3] > v18)
          v18 = v14[2].i32[3];
        v13[2].i32[3] = v18 + 1;
      }
      while ((_DWORD)v8 != -1);
    }
  }
  return this;
}

uint64_t b2DynamicTree::MoveProxy(b2DynamicTree *this, unsigned int a2, float32x4_t *a3, float32x2_t *a4)
{
  uint64_t v6;
  float32x2_t v10;
  int16x4_t v11;
  int8x16_t v12;
  int8x16_t v13;

  if ((a2 & 0x80000000) != 0 || *((_DWORD *)this + 5) <= (signed int)a2)
    b2DynamicTree::MoveProxy();
  v6 = *((_QWORD *)this + 1) + 48 * a2;
  if (*(_DWORD *)(v6 + 36) != -1)
    b2DynamicTree::MoveProxy();
  if (*(float *)v6 <= a3->f32[0]
    && *(float *)(v6 + 4) <= a3->f32[1]
    && a3->f32[2] <= *(float *)(v6 + 8)
    && a3->f32[3] <= *(float *)(v6 + 12))
  {
    return 0;
  }
  b2DynamicTree::RemoveLeaf(this, a2);
  v10 = vadd_f32(*a4, *a4);
  v11 = (int16x4_t)vcltz_f32(v10);
  v12.i64[0] = 0x8000000080000000;
  *(float32x2_t *)v13.i8 = v10;
  v13.i64[1] = 0x8000000080000000;
  v12.u64[1] = (unint64_t)v10;
  *(float32x4_t *)(*((_QWORD *)this + 1) + 48 * a2) = vaddq_f32(vaddq_f32(*a3, (float32x4_t)xmmword_208FD6820), (float32x4_t)vbslq_s8((int8x16_t)vmovl_s16(vuzp1_s16(v11, v11)), v13, v12));
  b2DynamicTree::InsertLeaf(this, a2);
  return 1;
}

uint64_t b2DynamicTree::Balance(b2DynamicTree *this, uint64_t a2)
{
  uint64_t v2;
  float32x2_t *v3;
  uint64_t v4;
  int *v5;
  uint64_t v6;
  _DWORD *v7;
  int v8;
  int v9;
  uint64_t v10;
  int *v11;
  uint64_t v12;
  unsigned int v13;
  float32x2_t *v14;
  __int32 v15;
  _DWORD *v16;
  float32x2_t *v17;
  __int32 v18;
  uint64_t v19;
  _DWORD *v20;
  int v21;
  int v22;
  int *v23;
  int v24;
  uint64_t v25;
  uint64_t v26;
  int v27;
  uint64_t v28;
  uint64_t v29;
  _DWORD *v30;
  int v31;
  uint64_t v32;
  _DWORD *v33;
  int v34;
  int v35;
  int v36;
  int *v37;
  uint64_t v38;
  uint64_t v39;
  int v40;
  uint64_t v41;
  uint64_t v42;
  _DWORD *v43;
  int v44;
  uint64_t v45;
  int v46;
  float32x2_t *v47;
  float32x2_t *v48;
  __int32 *v49;
  __int32 v50;
  __int32 v51;
  float32x2_t v52;
  float32x2_t v53;
  float32x2_t v54;
  int8x8_t v55;
  int8x8_t v56;
  float32x2_t v57;
  float32x2_t v58;
  float32x2_t v59;
  int8x8_t v60;
  __int32 v61;
  uint64_t v62;
  int v63;
  float32x2_t *v64;
  float32x2_t *v65;
  __int32 v66;
  __int32 v67;
  float32x2_t v68;
  float32x2_t v69;
  float32x2_t v70;
  int8x8_t v71;
  float32x2_t v72;
  float32x2_t v73;
  float32x2_t v74;
  int8x8_t v75;
  __int32 v76;

  if ((_DWORD)a2 == -1)
    b2DynamicTree::Balance();
  v2 = *((_QWORD *)this + 1);
  v3 = (float32x2_t *)(v2 + 48 * (int)a2);
  v5 = (int *)&v3[4] + 1;
  v4 = v3[4].u32[1];
  if (v3[4].i32[1] != -1)
  {
    v6 = v2 + 48 * (int)a2;
    v8 = *(_DWORD *)(v6 + 44);
    v7 = (_DWORD *)(v6 + 44);
    if (v8 >= 2)
    {
      if ((v4 & 0x80000000) != 0 || (v9 = *((_DWORD *)this + 5), (int)v4 >= v9))
        b2DynamicTree::Balance();
      v10 = v2 + 48 * (int)a2;
      v13 = *(_DWORD *)(v10 + 40);
      v11 = (int *)(v10 + 40);
      v12 = v13;
      if ((v13 & 0x80000000) != 0 || (int)v12 >= v9)
        b2DynamicTree::Balance();
      v14 = (float32x2_t *)(v2 + 48 * v12);
      v16 = (_DWORD *)&v14[5] + 1;
      v15 = v14[5].i32[1];
      v17 = (float32x2_t *)(v2 + 48 * v4);
      v18 = v17[5].i32[1];
      if (v15 - v18 >= 2)
      {
        v19 = v2 + 48 * v12;
        v22 = *(_DWORD *)(v19 + 36);
        v20 = (_DWORD *)(v19 + 36);
        v21 = v22;
        if (v22 < 0 || v21 >= v9)
          b2DynamicTree::Balance();
        v23 = v20 + 1;
        v24 = v20[1];
        if (v24 < 0 || v24 >= v9)
          b2DynamicTree::Balance();
        *v20 = a2;
        v25 = v2 + 48 * (int)a2;
        v26 = v2 + 48 * v12;
        *(_DWORD *)(v26 + 32) = *(_DWORD *)(v25 + 32);
        *(_DWORD *)(v25 + 32) = v12;
        v27 = *(_DWORD *)(v26 + 32);
        if (v27 != -1)
        {
          v28 = *((_QWORD *)this + 1);
          v29 = v28 + 48 * v27;
          v31 = *(_DWORD *)(v29 + 36);
          v30 = (_DWORD *)(v29 + 36);
          if (v31 == (_DWORD)a2)
          {
            *v30 = v12;
LABEL_26:
            v47 = (float32x2_t *)(v2 + 48 * v21);
            v48 = (float32x2_t *)(v2 + 48 * v24);
            v49 = (__int32 *)&v47[5] + 1;
            v50 = v47[5].i32[1];
            v51 = v48[5].i32[1];
            if (v50 <= v51)
            {
              v57 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(*v47, *v17), (int8x8_t)*v17, (int8x8_t)*v47);
              v58 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v17[1], v47[1]), (int8x8_t)v17[1], (int8x8_t)v47[1]);
              *v3 = v57;
              v3[1] = v58;
              v59 = v48[1];
              v60 = vbsl_s8((int8x8_t)vcgt_f32(*v48, v57), (int8x8_t)v57, (int8x8_t)*v48);
              *v23 = v24;
              *v11 = v21;
              *(_DWORD *)(v2 + 48 * v21 + 32) = a2;
              *v14 = (float32x2_t)v60;
              v56 = vbsl_s8((int8x8_t)vcgt_f32(v58, v59), (int8x8_t)v58, (int8x8_t)v59);
              v51 = v50;
              v49 = (__int32 *)&v48[5] + 1;
            }
            else
            {
              v52 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(*v48, *v17), (int8x8_t)*v17, (int8x8_t)*v48);
              v53 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v17[1], v48[1]), (int8x8_t)v17[1], (int8x8_t)v48[1]);
              *v3 = v52;
              v3[1] = v53;
              v54 = v47[1];
              v55 = vbsl_s8((int8x8_t)vcgt_f32(*v47, v52), (int8x8_t)v52, (int8x8_t)*v47);
              *v23 = v21;
              *v11 = v24;
              *(_DWORD *)(v2 + 48 * v24 + 32) = a2;
              *v14 = (float32x2_t)v55;
              v56 = vbsl_s8((int8x8_t)vcgt_f32(v53, v54), (int8x8_t)v53, (int8x8_t)v54);
            }
            v14[1].i32[0] = v56.i32[0];
            if (v18 <= v51)
              v61 = v51;
            else
              v61 = v18;
            v4 = v12;
            goto LABEL_42;
          }
          v45 = v28 + 48 * v27;
          v46 = *(_DWORD *)(v45 + 40);
          this = (b2DynamicTree *)(v45 + 40);
          if (v46 != (_DWORD)a2)
            b2DynamicTree::Balance();
        }
        *(_DWORD *)this = v12;
        goto LABEL_26;
      }
      if (v15 - v18 > -2)
        return a2;
      v32 = v2 + 48 * v4;
      v35 = *(_DWORD *)(v32 + 36);
      v33 = (_DWORD *)(v32 + 36);
      v34 = v35;
      if (v35 < 0 || v34 >= v9)
        b2DynamicTree::Balance();
      v37 = v33 + 1;
      v36 = v33[1];
      if (v36 < 0 || v36 >= v9)
        b2DynamicTree::Balance();
      *v33 = a2;
      v38 = v2 + 48 * (int)a2;
      v39 = v2 + 48 * v4;
      *(_DWORD *)(v39 + 32) = *(_DWORD *)(v38 + 32);
      *(_DWORD *)(v38 + 32) = v4;
      v40 = *(_DWORD *)(v39 + 32);
      if (v40 != -1)
      {
        v41 = *((_QWORD *)this + 1);
        v42 = v41 + 48 * v40;
        v44 = *(_DWORD *)(v42 + 36);
        v43 = (_DWORD *)(v42 + 36);
        if (v44 == (_DWORD)a2)
        {
          *v43 = v4;
LABEL_35:
          v64 = (float32x2_t *)(v2 + 48 * v34);
          v65 = (float32x2_t *)(v2 + 48 * v36);
          v49 = (__int32 *)&v64[5] + 1;
          v66 = v64[5].i32[1];
          v67 = v65[5].i32[1];
          if (v66 <= v67)
          {
            v72 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(*v64, *v14), (int8x8_t)*v14, (int8x8_t)*v64);
            v73 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v14[1], v64[1]), (int8x8_t)v14[1], (int8x8_t)v64[1]);
            *v3 = v72;
            v3[1] = v73;
            v74 = v65[1];
            v75 = vbsl_s8((int8x8_t)vcgt_f32(*v65, v72), (int8x8_t)v72, (int8x8_t)*v65);
            *v37 = v36;
            *v5 = v34;
            *(_DWORD *)(v2 + 48 * v34 + 32) = a2;
            *v17 = (float32x2_t)v75;
            v56 = vbsl_s8((int8x8_t)vcgt_f32(v73, v74), (int8x8_t)v73, (int8x8_t)v74);
            v67 = v66;
            v49 = (__int32 *)&v65[5] + 1;
          }
          else
          {
            v68 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(*v65, *v14), (int8x8_t)*v14, (int8x8_t)*v65);
            v69 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v14[1], v65[1]), (int8x8_t)v14[1], (int8x8_t)v65[1]);
            *v3 = v68;
            v3[1] = v69;
            v70 = v64[1];
            v71 = vbsl_s8((int8x8_t)vcgt_f32(*v64, v68), (int8x8_t)v68, (int8x8_t)*v64);
            *v37 = v34;
            *v5 = v36;
            *(_DWORD *)(v2 + 48 * v36 + 32) = a2;
            *v17 = (float32x2_t)v71;
            v56 = vbsl_s8((int8x8_t)vcgt_f32(v69, v70), (int8x8_t)v69, (int8x8_t)v70);
          }
          v17[1].i32[0] = v56.i32[0];
          if (v15 <= v67)
            v61 = v67;
          else
            v61 = v15;
          LODWORD(v12) = v4;
          v16 = (_DWORD *)&v17[5] + 1;
LABEL_42:
          *v7 = v61 + 1;
          v76 = *v49;
          if (v61 + 1 > *v49)
            v76 = v61 + 1;
          *(_DWORD *)(v2 + 48 * v12 + 12) = v56.i32[1];
          *v16 = v76 + 1;
          return v4;
        }
        v62 = v41 + 48 * v40;
        v63 = *(_DWORD *)(v62 + 40);
        this = (b2DynamicTree *)(v62 + 40);
        if (v63 != (_DWORD)a2)
          b2DynamicTree::Balance();
      }
      *(_DWORD *)this = v4;
      goto LABEL_35;
    }
  }
  return a2;
}

uint64_t b2DynamicTree::GetHeight(b2DynamicTree *this)
{
  if (*(_DWORD *)this == -1)
    return 0;
  else
    return *(unsigned int *)(*((_QWORD *)this + 1) + 48 * *(int *)this + 44);
}

float b2DynamicTree::GetAreaRatio(b2DynamicTree *this)
{
  uint64_t v1;
  float v2;
  float v3;
  uint64_t v4;
  float v5;
  float v6;

  if (*(_DWORD *)this == -1)
    return 0.0;
  v1 = *((_QWORD *)this + 1);
  v2 = (float)(*(float *)(v1 + 48 * *(int *)this + 8) - *(float *)(v1 + 48 * *(int *)this))
     + (float)(*(float *)(v1 + 48 * *(int *)this + 12) - *(float *)(v1 + 48 * *(int *)this + 4));
  v3 = v2 + v2;
  v4 = *((unsigned int *)this + 5);
  v5 = 0.0;
  if ((int)v4 >= 1)
  {
    do
    {
      if ((*(_DWORD *)(v1 + 44) & 0x80000000) == 0)
      {
        v6 = (float)(*(float *)(v1 + 8) - *(float *)v1) + (float)(*(float *)(v1 + 12) - *(float *)(v1 + 4));
        v5 = v5 + (float)(v6 + v6);
      }
      v1 += 48;
      --v4;
    }
    while (v4);
  }
  return v5 / v3;
}

uint64_t b2DynamicTree::ComputeHeight(b2DynamicTree *this, unsigned int a2)
{
  uint64_t v3;
  int v5;
  int v6;
  int v7;

  if ((a2 & 0x80000000) != 0 || *((_DWORD *)this + 5) <= (signed int)a2)
    b2DynamicTree::ComputeHeight();
  v3 = *((_QWORD *)this + 1);
  if (*(_DWORD *)(v3 + 48 * a2 + 36) == -1)
    return 0;
  v5 = b2DynamicTree::ComputeHeight(this, *(_DWORD *)(v3 + 48 * a2 + 36));
  v6 = b2DynamicTree::ComputeHeight(this, *(_DWORD *)(v3 + 48 * a2 + 40));
  if (v5 <= v6)
    v7 = v6;
  else
    v7 = v5;
  return (v7 + 1);
}

uint64_t b2DynamicTree::ComputeHeight(b2DynamicTree *this)
{
  return b2DynamicTree::ComputeHeight(this, *(_DWORD *)this);
}

uint64_t b2DynamicTree::ValidateStructure(uint64_t this, int a2)
{
  int v2;
  uint64_t i;
  uint64_t v4;
  int v5;
  uint64_t v6;
  int v7;
  int v8;

  if (a2 != -1)
  {
    v2 = a2;
    for (i = this; ; this = b2DynamicTree::ValidateStructure((b2DynamicTree *)i, v7))
    {
      v4 = *(_QWORD *)(i + 8);
      v5 = v2;
      if (*(_DWORD *)i == v2 && *(_DWORD *)(v4 + 48 * v2 + 32) != -1)
        b2DynamicTree::ValidateStructure();
      v6 = v4 + 48 * v2;
      v7 = *(_DWORD *)(v6 + 36);
      v2 = *(_DWORD *)(v6 + 40);
      if (v7 == -1)
        break;
      if (v7 < 0 || (v8 = *(_DWORD *)(i + 20), v7 >= v8))
        b2DynamicTree::ValidateStructure();
      if (v2 < 0 || v2 >= v8)
        b2DynamicTree::ValidateStructure();
      if (*(_DWORD *)(v4 + 48 * v7 + 32) != v5)
        b2DynamicTree::ValidateStructure();
      if (*(_DWORD *)(v4 + 48 * v2 + 32) != v5)
        b2DynamicTree::ValidateStructure();
    }
    if (v2 != -1)
      b2DynamicTree::ValidateStructure();
    if (*(_DWORD *)(v4 + 48 * v5 + 44))
      b2DynamicTree::ValidateStructure();
  }
  return this;
}

uint64_t b2DynamicTree::ValidateMetrics(uint64_t this, int a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  unsigned int v6;
  __int32 v7;
  float32x2_t *v8;
  signed int v9;
  int v10;
  float32x2_t *v11;
  float32x2_t *v12;
  int32x2_t v13;
  int32x2_t v14;

  if (a2 != -1)
  {
    v2 = this;
    v3 = *(_QWORD *)(this + 8);
    v4 = a2;
    v5 = v3 + 48 * a2;
    v6 = *(_DWORD *)(v5 + 36);
    v7 = *(_DWORD *)(v5 + 40);
    if (v6 != -1)
    {
      v8 = (float32x2_t *)(v3 + 48 * (int)v4);
      do
      {
        if ((v6 & 0x80000000) != 0 || (v9 = *(_DWORD *)(v2 + 20), (int)v6 >= v9))
          b2DynamicTree::ValidateMetrics();
        if (v7 < 0 || v7 >= v9)
          b2DynamicTree::ValidateMetrics();
        v10 = *(_DWORD *)(v3 + 48 * v6 + 44);
        if (v10 <= *(_DWORD *)(v3 + 48 * v7 + 44))
          v10 = *(_DWORD *)(v3 + 48 * v7 + 44);
        if (*(_DWORD *)(v3 + 48 * v4 + 44) != v10 + 1)
          b2DynamicTree::ValidateMetrics();
        v11 = (float32x2_t *)(v3 + 48 * v6);
        v12 = (float32x2_t *)(v3 + 48 * v7);
        v13 = vceq_f32((float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(*v12, *v11), (int8x8_t)*v11, (int8x8_t)*v12), *v8);
        if ((v13.i32[0] & v13.i32[1] & 1) == 0)
          b2DynamicTree::ValidateMetrics();
        v14 = vceq_f32((float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v11[1], v12[1]), (int8x8_t)v11[1], (int8x8_t)v12[1]), v8[1]);
        if ((v14.i32[0] & v14.i32[1] & 1) == 0)
          b2DynamicTree::ValidateMetrics();
        this = b2DynamicTree::ValidateMetrics((b2DynamicTree *)v2, v6);
        v3 = *(_QWORD *)(v2 + 8);
        v4 = v7;
        v8 = (float32x2_t *)(v3 + 48 * v7);
        v6 = v8[4].u32[1];
        v7 = v8[5].i32[0];
      }
      while (v6 != -1);
    }
    if (v7 != -1)
      b2DynamicTree::ValidateMetrics();
    if (*(_DWORD *)(v3 + 48 * (int)v4 + 44))
      b2DynamicTree::ValidateMetrics();
  }
  return this;
}

uint64_t b2DynamicTree::Validate(b2DynamicTree *this)
{
  uint64_t v2;
  int v3;
  signed int v4;
  int v5;
  uint64_t result;

  b2DynamicTree::ValidateStructure((uint64_t)this, *(_DWORD *)this);
  b2DynamicTree::ValidateMetrics((uint64_t)this, *(_DWORD *)this);
  v2 = *((unsigned int *)this + 6);
  if ((_DWORD)v2 == -1)
  {
    v3 = 0;
  }
  else
  {
    v3 = 0;
    do
    {
      if ((v2 & 0x80000000) != 0 || (int)v2 >= *((_DWORD *)this + 5))
        b2DynamicTree::Validate();
      ++v3;
      LODWORD(v2) = *(_DWORD *)(*((_QWORD *)this + 1) + 48 * v2 + 32);
    }
    while ((_DWORD)v2 != -1);
  }
  v4 = *(_DWORD *)this;
  if (*(_DWORD *)this == -1)
    v5 = 0;
  else
    v5 = *(_DWORD *)(*((_QWORD *)this + 1) + 48 * v4 + 44);
  result = b2DynamicTree::ComputeHeight(this, v4);
  if (v5 != (_DWORD)result)
    b2DynamicTree::Validate();
  if (*((_DWORD *)this + 4) + v3 != *((_DWORD *)this + 5))
    b2DynamicTree::Validate();
  return result;
}

uint64_t b2DynamicTree::GetMaxBalance(b2DynamicTree *this)
{
  uint64_t v1;
  uint64_t result;
  uint64_t v4;
  int *v5;
  int *v6;
  int v7;
  int v8;
  int v9;

  v1 = *((unsigned int *)this + 5);
  if ((int)v1 < 1)
    return 0;
  result = 0;
  v4 = *((_QWORD *)this + 1);
  v5 = (int *)(v4 + 44);
  v6 = (int *)(v4 + 44);
  do
  {
    v7 = *v6;
    v6 += 12;
    if (v7 >= 2)
    {
      v8 = *(v5 - 2);
      if (v8 == -1)
        b2DynamicTree::GetMaxBalance();
      v9 = *(_DWORD *)(v4 + 48 * *(v5 - 1) + 44) - *(_DWORD *)(v4 + 48 * v8 + 44);
      if (v9 < 0)
        v9 = -v9;
      if ((int)result <= v9)
        result = v9;
      else
        result = result;
    }
    v5 = v6;
    --v1;
  }
  while (v1);
  return result;
}

uint64_t b2DynamicTree::RebuildBottomUp(b2DynamicTree *this)
{
  _DWORD *v2;
  b2DynamicTree *v3;
  _DWORD *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  float v13;
  uint64_t v14;
  int v15;
  float32x2_t *v16;
  float32x2_t v17;
  float32x2_t v18;
  uint64_t v19;
  uint64_t v20;
  float32x2_t *v21;
  float v22;
  float v23;
  BOOL v24;
  __int32 v25;
  __int32 v26;
  float32x2_t *v27;
  float32x2_t *v28;
  __int32 v29;
  __int32 v30;
  int8x8_t *v31;
  b2DynamicTree *v32;
  b2DynamicTree *v34;

  v2 = b2Alloc(4 * *((_DWORD *)this + 4));
  v3 = this;
  v4 = v2;
  if (*((int *)this + 5) >= 1)
  {
    v5 = 0;
    v6 = 0;
    LODWORD(v7) = 0;
    v34 = this;
    do
    {
      v8 = *((_QWORD *)v3 + 1);
      if ((*(_DWORD *)(v8 + v5 + 44) & 0x80000000) == 0)
      {
        if (*(_DWORD *)(v8 + v5 + 36) == -1)
        {
          *(_DWORD *)(v8 + v5 + 32) = -1;
          v4[(int)v7] = v6;
          LODWORD(v7) = v7 + 1;
        }
        else
        {
          b2DynamicTree::FreeNode((uint64_t)v3, v6);
          v3 = this;
        }
      }
      ++v6;
      v5 += 48;
    }
    while (v6 < *((int *)v3 + 5));
    if ((int)v7 >= 2)
    {
      v7 = v7;
      do
      {
        v9 = 0;
        v10 = *((_QWORD *)v3 + 1);
        v11 = -1;
        v12 = 0x200000000;
        v13 = 3.4028e38;
        v14 = 1;
        v15 = -1;
        while (v9 + 1 < v7)
        {
          v16 = (float32x2_t *)(v10 + 48 * (int)v4[v9]);
          v17 = *v16;
          v18 = v16[1];
          v19 = v12;
          v20 = v14;
          do
          {
            v21 = (float32x2_t *)(v10 + 48 * (int)v4[v20]);
            v22 = vaddv_f32(vsub_f32((float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v18, v21[1]), (int8x8_t)v18, (int8x8_t)v21[1]), (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(*v21, v17), (int8x8_t)v17, (int8x8_t)*v21)));
            v23 = v22 + v22;
            if (v23 < v13)
            {
              v15 = v20;
              v11 = v9;
              v13 = v23;
            }
            ++v20;
            v24 = v7 <= v19 >> 32;
            v19 += 0x100000000;
          }
          while (!v24);
          ++v14;
          v12 += 0x100000000;
          ++v9;
        }
        v25 = v4[v11];
        v26 = v4[v15];
        v27 = (float32x2_t *)(v10 + 48 * v25);
        v28 = (float32x2_t *)(v10 + 48 * v26);
        b2DynamicTree::AllocateNode(v3);
        v3 = v34;
        v30 = v27[5].i32[1];
        if (v30 <= v28[5].i32[1])
          v30 = v28[5].i32[1];
        v31 = (int8x8_t *)(*((_QWORD *)v34 + 1) + 48 * v29);
        v31[5].i32[0] = v26;
        v31[5].i32[1] = v30 + 1;
        *v31 = vbsl_s8((int8x8_t)vcgt_f32(*v28, *v27), (int8x8_t)*v27, (int8x8_t)*v28);
        v31[1] = vbsl_s8((int8x8_t)vcgt_f32(v27[1], v28[1]), (int8x8_t)v27[1], (int8x8_t)v28[1]);
        v31[4].i32[0] = -1;
        v31[4].i32[1] = v25;
        v27[4].i32[0] = v29;
        v28[4].i32[0] = v29;
        v4[v15] = v4[v7 - 1];
        v4[v11] = v29;
        v24 = v7-- <= 2;
      }
      while (!v24);
    }
  }
  *(_DWORD *)v3 = *v4;
  v32 = v3;
  b2Free(v4);
  return b2DynamicTree::Validate(v32);
}

void b2TimeOfImpact(int *a1, uint64_t a2)
{
  float v2;
  float32x4_t v3;
  __int128 v4;
  float32x4_t v5;
  __int128 v6;
  float v7;
  float v8;
  float v9;
  int v12;
  uint64_t v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  float v17;
  __float2 v18;
  float v19;
  float v20;
  __float2 v21;
  float v22;
  int v23;
  float v24;
  float v25;
  float v26;
  int v27;
  float v28;
  float v29;
  float v30;
  float v31;
  float v32;
  int v33;
  int v34;
  int v35;
  int v36;
  float32x4_t v37;
  float v38;
  float v39;
  float v40;
  float v41;
  float32x4_t v42;
  float v43;
  __int128 v44;
  int v45[2];
  _BYTE v46[16];
  float v47;
  _OWORD v48[4];
  float v49;
  float v50;
  __float2 v51;
  float v52;
  float v53;
  __float2 v54;
  char v55;
  _BYTE v56[4];
  __int16 v57;
  float32x4_t v58[11];
  float32x4_t v59;
  float32x4_t v60;
  float32x4_t v61;
  __int128 v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  __int128 v66;
  uint64_t v67;

  v67 = *MEMORY[0x24BDAC8D0];
  ++b2_toiCalls;
  *a1 = 0;
  v2 = *(float *)(a2 + 192);
  *((float *)a1 + 1) = v2;
  v3 = *(float32x4_t *)(a2 + 80);
  v63 = *(float32x4_t *)(a2 + 64);
  v64 = v3;
  v4 = *(_OWORD *)(a2 + 112);
  v65 = *(float32x4_t *)(a2 + 96);
  v66 = v4;
  v5 = *(float32x4_t *)(a2 + 144);
  v59 = *(float32x4_t *)(a2 + 128);
  v60 = v5;
  v6 = *(_OWORD *)(a2 + 176);
  v61 = *(float32x4_t *)(a2 + 160);
  v62 = v6;
  v7 = floorf(v64.f32[3] / 6.2832) * 6.2832;
  v64.f32[3] = v64.f32[3] - v7;
  v65.f32[3] = v65.f32[3] - v7;
  v8 = floorf(v5.f32[3] / 6.2832);
  v60.f32[3] = v5.f32[3] - (float)(v8 * 6.2832);
  v61.f32[3] = v61.f32[3] - (float)(v8 * 6.2832);
  if ((float)((float)(*(float *)(a2 + 28) + *(float *)(a2 + 60)) + -0.0135) >= 0.0045)
    v9 = (float)(*(float *)(a2 + 28) + *(float *)(a2 + 60)) + -0.0135;
  else
    v9 = 0.0045;
  if (v9 <= 0.001125)
    b2TimeOfImpact();
  v38 = v2;
  v12 = 0;
  v13 = a2 + 32;
  v57 = 0;
  v14 = *(_OWORD *)(a2 + 16);
  v48[0] = *(_OWORD *)a2;
  v48[1] = v14;
  v16 = *(_OWORD *)(a2 + 32);
  v15 = *(_OWORD *)(a2 + 48);
  v48[2] = v16;
  v48[3] = v15;
  v55 = 0;
  v40 = v9 + 0.001125;
  v39 = v9 + -0.001125;
  LODWORD(v16) = 0;
  v17 = 1.0;
  while (2)
  {
    v41 = v17 - *(float *)&v16;
    v44 = v16;
    v37 = vmlaq_n_f32(vmulq_n_f32(v65, *(float *)&v16), v64, v17 - *(float *)&v16);
    v18 = __sincosf_stret(v37.f32[3]);
    v19 = v37.f32[0] - (float)((float)(v18.__cosval * v63.f32[0]) - (float)(v18.__sinval * v63.f32[1]));
    v20 = v37.f32[1] - (float)((float)(v63.f32[1] * v18.__cosval) + (float)(v18.__sinval * v63.f32[0]));
    v42 = vmlaq_n_f32(vmulq_n_f32(v61, *(float *)&v44), v60, v41);
    v21 = __sincosf_stret(v42.f32[3]);
    v49 = v19;
    v50 = v20;
    v51 = v18;
    v52 = v42.f32[0] - (float)((float)(v21.__cosval * v59.f32[0]) - (float)(v21.__sinval * v59.f32[1]));
    v53 = v42.f32[1] - (float)((float)(v59.f32[1] * v21.__cosval) + (float)(v21.__sinval * v59.f32[0]));
    v54 = v21;
    b2Distance((uint64_t)v46, (uint64_t)v56, (uint64_t)v48);
    if (v47 <= 0.0)
    {
      LODWORD(v16) = 0;
      v34 = 2;
LABEL_46:
      *a1 = v34;
      a1[1] = v16;
      goto LABEL_41;
    }
    if (v47 < v40)
    {
      v34 = 3;
      LODWORD(v16) = v44;
      goto LABEL_46;
    }
    b2SeparationFunction::Initialize(v58, (uint64_t)v56, a2, &v63, v13, &v59, *(float *)&v44);
    *(_QWORD *)v45 = 0;
    b2SeparationFunction::FindMinSeparation((b2SeparationFunction *)v58, &v45[1], v45, v38);
    v22 = *(float *)&v16;
    if (*(float *)&v16 <= v40)
    {
      v23 = 0;
      v43 = v38;
      while (1)
      {
        if (v22 > v39)
        {
          *(float *)&v16 = v43;
          goto LABEL_35;
        }
        b2SeparationFunction::Evaluate((b2SeparationFunction *)v58, v45[1], v45[0], *(float *)&v44);
        v25 = v24;
        if (v24 < v39)
        {
          v35 = 1;
          v26 = *(float *)&v44;
          goto LABEL_40;
        }
        v26 = *(float *)&v44;
        if (v25 <= v40)
        {
          v35 = 3;
          goto LABEL_40;
        }
        v27 = 0;
        v28 = *(float *)&v44;
        v29 = v43;
        while (1)
        {
          if ((v27 & 1) != 0)
            v30 = v28 + (float)((float)((float)(v9 - v25) * (float)(v29 - v28)) / (float)(v22 - v25));
          else
            v30 = (float)(v28 + v29) * 0.5;
          b2SeparationFunction::Evaluate((b2SeparationFunction *)v58, v45[1], v45[0], v30);
          v32 = v31 - v9;
          if ((float)(v31 - v9) <= 0.0)
            v32 = -(float)(v31 - v9);
          if (v32 < 0.001125)
            break;
          if (v31 > v9)
          {
            v25 = v31;
            v28 = v30;
          }
          else
          {
            v22 = v31;
          }
          if (v31 <= v9)
            v29 = v30;
          ++v27;
          ++b2_toiRootIters;
          if (v27 == 50)
            goto LABEL_28;
        }
        v43 = v30;
LABEL_28:
        v33 = b2_toiMaxRootIters;
        if (b2_toiMaxRootIters <= v27)
          v33 = v27;
        b2_toiMaxRootIters = v33;
        if (v23 == 11)
          break;
        *(_QWORD *)v45 = 0;
        b2SeparationFunction::FindMinSeparation((b2SeparationFunction *)v58, &v45[1], v45, v43);
        v22 = *(float *)&v16;
        ++v23;
        if (*(float *)&v16 > v40)
          goto LABEL_37;
      }
      v16 = v44;
LABEL_35:
      ++v12;
      ++b2_toiIters;
      v17 = 1.0;
      if (v12 != 20)
        continue;
      v34 = 1;
      goto LABEL_46;
    }
    break;
  }
LABEL_37:
  v35 = 4;
  v26 = v38;
LABEL_40:
  *a1 = v35;
  *((float *)a1 + 1) = v26;
  ++v12;
  ++b2_toiIters;
LABEL_41:
  v36 = b2_toiMaxIters;
  if (b2_toiMaxIters <= v12)
    v36 = v12;
  b2_toiMaxIters = v36;
}

void b2SeparationFunction::Initialize(float32x4_t *a1, uint64_t a2, uint64_t a3, float32x4_t *a4, uint64_t a5, float32x4_t *a6, float a7)
{
  int v7;
  float32x4_t v13;
  float32x4_t v14;
  float32x4_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  float v19;
  float cosval;
  __float2 v21;
  float v22;
  float v23;
  float v24;
  float v25;
  float v26;
  __float2 v27;
  __float2 v28;
  __float2 v29;
  __float2 v30;
  float v31;
  float v32;
  float v33;
  float v34;
  float v35;
  float v36;
  float v37;
  uint64_t v38;
  uint64_t v39;
  float *v40;
  float v41;
  float v42;
  float *v43;
  float v44;
  float v45;
  float v46;
  float v47;
  uint64_t v48;
  int v49;
  uint64_t v50;
  uint64_t v51;
  float *v52;
  float v53;
  float v54;
  float *v55;
  float v56;
  float v57;
  float v58;
  float v59;
  float v60;
  float v61;
  float v62;
  float v63;
  float v64;
  uint64_t v65;
  float *v66;
  float v67;
  uint64_t v68;
  int v69;
  uint64_t v70;
  uint64_t v71;
  float *v72;
  float v73;
  float v74;
  float *v75;
  float v76;
  float v77;
  float v78;
  float v79;
  float v80;
  float v81;
  float v82;
  uint64_t v83;
  float *v84;
  float32x4_t v85;
  float v86;
  float v87;
  float32x4_t v88;

  a1->i64[0] = a3;
  a1->i64[1] = a5;
  v7 = *(unsigned __int16 *)(a2 + 4);
  if ((v7 - 3) <= 0xFFFFFFFD)
    b2SeparationFunction::Initialize();
  v13 = *a4;
  v14 = a4[1];
  v15 = a4[2];
  a1[4].i32[0] = a4[3].i32[0];
  a1[2] = v14;
  a1[3] = v15;
  a1[1] = v13;
  v16 = *a6;
  v17 = a6[1];
  v18 = a6[2];
  a1[8].i32[0] = a6[3].i32[0];
  a1[6] = v17;
  a1[7] = v18;
  a1[5] = v16;
  v86 = a7;
  v87 = 1.0 - a7;
  v85 = vmlaq_n_f32(vmulq_n_f32(a1[3], a7), a1[2], 1.0 - a7);
  v21 = __sincosf_stret(v85.f32[3]);
  cosval = v21.__cosval;
  LODWORD(v19) = *(_QWORD *)&v21;
  v22 = a1[1].f32[0];
  v23 = a1[1].f32[1];
  v24 = -v19;
  v25 = v85.f32[0] - (float)((float)(cosval * v22) - (float)(v19 * v23));
  v26 = v85.f32[1] - (float)((float)(v23 * cosval) + (float)(v19 * v22));
  v88 = vmlaq_n_f32(vmulq_n_f32(a1[7], v86), a1[6], v87);
  v30 = __sincosf_stret(v88.f32[3]);
  v31 = a1[5].f32[0];
  v32 = a1[5].f32[1];
  v33 = -v30.__sinval;
  v34 = (float)(v30.__cosval * v31) - (float)(v30.__sinval * v32);
  v35 = (float)(v32 * v30.__cosval) + (float)(v30.__sinval * v31);
  v36 = v88.f32[0] - v34;
  v37 = v88.f32[1] - v35;
  if (v7 == 1)
  {
    a1[9].i32[0] = 0;
    v38 = *(unsigned __int8 *)(a2 + 6);
    if (*(_DWORD *)(a3 + 24) <= (int)v38)
      b2Distance(*(_QWORD *)&v27, *(_QWORD *)&v28, *(_QWORD *)&v29);
    v39 = *(unsigned __int8 *)(a2 + 9);
    if (*(_DWORD *)(a5 + 24) <= (int)v39)
      b2Distance(*(_QWORD *)&v27, *(_QWORD *)&v28, *(_QWORD *)&v29);
    v40 = (float *)(*(_QWORD *)(a3 + 16) + 8 * v38);
    v42 = *v40;
    v41 = v40[1];
    v43 = (float *)(*(_QWORD *)(a5 + 16) + 8 * v39);
    v44 = v43[1];
    v45 = (float)(v36 + (float)((float)(v44 * v33) + (float)(v30.__cosval * *v43)))
        - (float)(v25 + (float)((float)(v41 * v24) + (float)(cosval * v42)));
    v46 = (float)(v37 + (float)((float)(v30.__cosval * v44) + (float)(v30.__sinval * *v43)))
        - (float)(v26 + (float)((float)(cosval * v41) + (float)(v19 * v42)));
    a1[9].f32[3] = v45;
    a1[10].f32[0] = v46;
    v47 = sqrtf((float)(v46 * v46) + (float)(v45 * v45));
    if (v47 >= 0.00000011921)
    {
      a1[9].f32[3] = v45 * (float)(1.0 / v47);
      a1[10].f32[0] = v46 * (float)(1.0 / v47);
    }
  }
  else
  {
    if (*(unsigned __int8 *)(a2 + 6) == *(unsigned __int8 *)(a2 + 7))
    {
      a1[9].i32[0] = 2;
      v48 = *(unsigned __int8 *)(a2 + 9);
      v49 = *(_DWORD *)(a5 + 24);
      if (v49 <= (int)v48)
        b2Distance(*(_QWORD *)&v27, *(_QWORD *)&v28, *(_QWORD *)&v29);
      v50 = *(unsigned __int8 *)(a2 + 10);
      if (v49 <= (int)v50)
        b2Distance(*(_QWORD *)&v27, *(_QWORD *)&v28, *(_QWORD *)&v29);
      v51 = *(_QWORD *)(a5 + 16);
      v52 = (float *)(v51 + 8 * v48);
      v53 = *v52;
      v54 = v52[1];
      v55 = (float *)(v51 + 8 * v50);
      v56 = *v55;
      v57 = v55[1];
      v58 = *v55 - v53;
      v59 = v57 - v54;
      v60 = -v58;
      a1[9].f32[3] = v57 - v54;
      a1[10].f32[0] = -v58;
      v61 = sqrtf((float)(v58 * v58) + (float)(v59 * v59));
      if (v61 >= 0.00000011921)
      {
        v62 = 1.0 / v61;
        v59 = v59 * v62;
        v60 = v62 * v60;
        a1[9].f32[3] = v59;
        a1[10].f32[0] = v60;
      }
      v63 = (float)(v53 + v56) * 0.5;
      v64 = (float)(v54 + v57) * 0.5;
      a1[9].f32[1] = v63;
      a1[9].f32[2] = v64;
      v65 = *(unsigned __int8 *)(a2 + 6);
      if (*(_DWORD *)(a3 + 24) <= (int)v65)
        b2Distance(*(_QWORD *)&v27, *(_QWORD *)&v28, *(_QWORD *)&v29);
      v66 = (float *)(*(_QWORD *)(a3 + 16) + 8 * v65);
      v67 = (float)((float)((float)(v30.__cosval * v60) + (float)(v30.__sinval * v59))
                  * (float)((float)(v26 + (float)((float)(cosval * v66[1]) + (float)(v19 * *v66)))
                          - (float)(v37 + (float)((float)(v30.__cosval * v64) + (float)(v30.__sinval * v63)))))
          + (float)((float)((float)(v25 + (float)((float)(v66[1] * v24) + (float)(cosval * *v66)))
                          - (float)(v36 + (float)((float)(v64 * v33) + (float)(v30.__cosval * v63))))
                  * (float)((float)(v60 * v33) + (float)(v30.__cosval * v59)));
    }
    else
    {
      a1[9].i32[0] = 1;
      v68 = *(unsigned __int8 *)(a2 + 6);
      v69 = *(_DWORD *)(a3 + 24);
      if (v69 <= (int)v68)
        b2Distance(*(_QWORD *)&v27, *(_QWORD *)&v28, *(_QWORD *)&v29);
      v70 = *(unsigned __int8 *)(a2 + 7);
      if (v69 <= (int)v70)
        b2Distance(*(_QWORD *)&v27, *(_QWORD *)&v28, *(_QWORD *)&v29);
      v71 = *(_QWORD *)(a3 + 16);
      v72 = (float *)(v71 + 8 * v68);
      v73 = *v72;
      v74 = v72[1];
      v75 = (float *)(v71 + 8 * v70);
      v76 = *v75;
      v77 = v75[1];
      v78 = *v75 - v73;
      v59 = v77 - v74;
      v60 = -v78;
      a1[9].f32[3] = v77 - v74;
      a1[10].f32[0] = -v78;
      v79 = sqrtf((float)(v78 * v78) + (float)(v59 * v59));
      if (v79 >= 0.00000011921)
      {
        v80 = 1.0 / v79;
        v59 = v59 * v80;
        v60 = v80 * v60;
        a1[9].f32[3] = v59;
        a1[10].f32[0] = v60;
      }
      v81 = (float)(v73 + v76) * 0.5;
      v82 = (float)(v74 + v77) * 0.5;
      a1[9].f32[1] = v81;
      a1[9].f32[2] = v82;
      v83 = *(unsigned __int8 *)(a2 + 9);
      if (*(_DWORD *)(a5 + 24) <= (int)v83)
        b2Distance(*(_QWORD *)&v27, *(_QWORD *)&v28, *(_QWORD *)&v29);
      v84 = (float *)(*(_QWORD *)(a5 + 16) + 8 * v83);
      v67 = (float)((float)((float)(cosval * v60) + (float)(v19 * v59))
                  * (float)((float)(v37 + (float)((float)(v30.__cosval * v84[1]) + (float)(v30.__sinval * *v84)))
                          - (float)(v26 + (float)((float)(cosval * v82) + (float)(v19 * v81)))))
          + (float)((float)((float)(v36 + (float)((float)(v84[1] * v33) + (float)(v30.__cosval * *v84)))
                          - (float)(v25 + (float)((float)(v82 * v24) + (float)(cosval * v81))))
                  * (float)((float)(v60 * v24) + (float)(cosval * v59)));
    }
    if (v67 < 0.0)
    {
      a1[9].f32[3] = -v59;
      a1[10].f32[0] = -v60;
    }
  }
}

void b2SeparationFunction::FindMinSeparation(b2SeparationFunction *this, int *a2, int *a3, float a4)
{
  __float2 v7;
  float v8;
  __float2 v9;
  __float2 v10;
  __float2 v11;
  __float2 v12;
  int v13;
  float v14;
  float v15;
  uint64_t v16;
  float *v17;
  uint64_t v18;
  int v19;
  float v20;
  float v21;
  float v22;
  float *v23;
  uint64_t k;
  float v25;
  float v26;
  float v27;
  float v28;
  uint64_t v29;
  float *v30;
  uint64_t v31;
  int v32;
  float v33;
  float v34;
  float v35;
  float *v36;
  uint64_t i;
  float v38;
  float v39;
  float v40;
  float v41;
  uint64_t v42;
  float *v43;
  uint64_t v44;
  int v45;
  float v46;
  float v47;
  float v48;
  float *v49;
  uint64_t j;
  uint64_t v51;
  float *v52;
  uint64_t v53;
  int v54;
  float v55;
  float v56;
  float v57;
  float *v58;
  uint64_t m;
  float v60;

  v60 = 1.0 - a4;
  v7 = __sincosf_stret(COERCE_FLOAT(vmlaq_n_f32(vmulq_n_f32(*(float32x4_t *)(this + 48), a4), *(float32x4_t *)(this + 32), 1.0 - a4).i32[3]));
  v8 = -v7.__sinval;
  v12 = __sincosf_stret(COERCE_FLOAT(vmlaq_n_f32(vmulq_n_f32(*(float32x4_t *)(this + 112), a4), *(float32x4_t *)(this + 96), v60).i32[3]));
  v13 = *((_DWORD *)this + 36);
  if (v13 == 2)
  {
    v25 = *((float *)this + 39);
    v26 = *((float *)this + 40);
    v27 = (float)(v26 * (float)-v12.__sinval) + (float)(v12.__cosval * v25);
    v28 = (float)(v12.__cosval * v26) + (float)(v12.__sinval * v25);
    *a3 = -1;
    v29 = *(_QWORD *)this;
    v30 = *(float **)(*(_QWORD *)this + 16);
    v31 = *(unsigned int *)(*(_QWORD *)this + 24);
    if ((int)v31 <= 1)
    {
      v32 = 0;
      *a2 = 0;
    }
    else
    {
      v32 = 0;
      v33 = (float)-(float)(v28 * v7.__sinval) - (float)(v7.__cosval * v27);
      v34 = (float)(v7.__sinval * v27) - (float)(v28 * v7.__cosval);
      v35 = (float)(v34 * v30[1]) + (float)(*v30 * v33);
      v36 = v30 + 3;
      for (i = 1; i != v31; ++i)
      {
        if ((float)((float)(v34 * *v36) + (float)(*(v36 - 1) * v33)) > v35)
        {
          v32 = i;
          v35 = (float)(v34 * *v36) + (float)(*(v36 - 1) * v33);
        }
        v36 += 2;
      }
      *a2 = v32;
      if (v32 < 0)
        goto LABEL_43;
    }
    if (*(_DWORD *)(v29 + 24) > v32)
      return;
LABEL_43:
    b2Distance(*(_QWORD *)&v9, *(_QWORD *)&v10, *(_QWORD *)&v11);
  }
  if (v13 == 1)
  {
    v38 = *((float *)this + 39);
    v39 = *((float *)this + 40);
    v40 = (float)(v39 * v8) + (float)(v7.__cosval * v38);
    v41 = (float)(v7.__cosval * v39) + (float)(v7.__sinval * v38);
    *a2 = -1;
    v42 = *((_QWORD *)this + 1);
    v43 = *(float **)(v42 + 16);
    v44 = *(unsigned int *)(v42 + 24);
    if ((int)v44 <= 1)
    {
      v45 = 0;
      *a3 = 0;
    }
    else
    {
      v45 = 0;
      v46 = (float)-(float)(v41 * v12.__sinval) - (float)(v12.__cosval * v40);
      v47 = (float)(v12.__sinval * v40) - (float)(v41 * v12.__cosval);
      v48 = (float)(v47 * v43[1]) + (float)(*v43 * v46);
      v49 = v43 + 3;
      for (j = 1; j != v44; ++j)
      {
        if ((float)((float)(v47 * *v49) + (float)(*(v49 - 1) * v46)) > v48)
        {
          v45 = j;
          v48 = (float)(v47 * *v49) + (float)(*(v49 - 1) * v46);
        }
        v49 += 2;
      }
      *a3 = v45;
      if (v45 < 0)
        goto LABEL_44;
    }
    if (*(_DWORD *)(v42 + 24) > v45)
      return;
LABEL_44:
    b2Distance(*(_QWORD *)&v9, *(_QWORD *)&v10, *(_QWORD *)&v11);
  }
  if (v13)
    b2SeparationFunction::FindMinSeparation();
  v14 = *((float *)this + 39);
  v15 = *((float *)this + 40);
  v16 = *(_QWORD *)this;
  v17 = *(float **)(*(_QWORD *)this + 16);
  v18 = *(unsigned int *)(*(_QWORD *)this + 24);
  if ((int)v18 < 2)
  {
    v19 = 0;
  }
  else
  {
    v19 = 0;
    v20 = (float)(v7.__sinval * v15) + (float)(v7.__cosval * v14);
    v21 = (float)(v7.__cosval * v15) + (float)(v8 * v14);
    v22 = (float)(v21 * v17[1]) + (float)(*v17 * v20);
    v23 = v17 + 3;
    for (k = 1; k != v18; ++k)
    {
      if ((float)((float)(v21 * *v23) + (float)(*(v23 - 1) * v20)) > v22)
      {
        v19 = k;
        v22 = (float)(v21 * *v23) + (float)(*(v23 - 1) * v20);
      }
      v23 += 2;
    }
  }
  *a2 = v19;
  v51 = *((_QWORD *)this + 1);
  v52 = *(float **)(v51 + 16);
  v53 = *(unsigned int *)(v51 + 24);
  if ((int)v53 < 2)
  {
    v54 = 0;
  }
  else
  {
    v54 = 0;
    v55 = (float)-(float)(v15 * v12.__sinval) - (float)(v12.__cosval * v14);
    v56 = (float)(v12.__sinval * v14) - (float)(v15 * v12.__cosval);
    v57 = (float)(v56 * v52[1]) + (float)(*v52 * v55);
    v58 = v52 + 3;
    for (m = 1; m != v53; ++m)
    {
      if ((float)((float)(v56 * *v58) + (float)(*(v58 - 1) * v55)) > v57)
      {
        v54 = m;
        v57 = (float)(v56 * *v58) + (float)(*(v58 - 1) * v55);
      }
      v58 += 2;
    }
  }
  *a3 = v54;
  if (*a2 < 0 || *(_DWORD *)(v16 + 24) <= *a2)
    b2Distance(*(_QWORD *)&v9, *(_QWORD *)&v10, *(_QWORD *)&v11);
  if (v54 < 0 || *(_DWORD *)(v51 + 24) <= v54)
    b2Distance(*(_QWORD *)&v9, *(_QWORD *)&v10, *(_QWORD *)&v11);
}

void b2SeparationFunction::Evaluate(b2SeparationFunction *this, int a2, int a3, float a4)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  float v11;

  v11 = 1.0 - a4;
  __sincosf_stret(COERCE_FLOAT(vmlaq_n_f32(vmulq_n_f32(*(float32x4_t *)(this + 48), a4), *(float32x4_t *)(this + 32), 1.0 - a4).i32[3]));
  __sincosf_stret(COERCE_FLOAT(vmlaq_n_f32(vmulq_n_f32(*(float32x4_t *)(this + 112), a4), *(float32x4_t *)(this + 96), v11).i32[3]));
  v10 = *((_DWORD *)this + 36);
  if (v10 == 2)
  {
    if (a2 < 0 || *(_DWORD *)(*(_QWORD *)this + 24) <= a2)
      b2Distance(v7, v8, v9);
  }
  else if (v10 == 1)
  {
    if (a3 < 0 || *(_DWORD *)(*((_QWORD *)this + 1) + 24) <= a3)
      b2Distance(v7, v8, v9);
  }
  else
  {
    if (v10)
      b2SeparationFunction::Evaluate();
    if (a2 < 0 || *(_DWORD *)(*(_QWORD *)this + 24) <= a2)
      b2Distance(v7, v8, v9);
    if (a3 < 0 || *(_DWORD *)(*((_QWORD *)this + 1) + 24) <= a3)
      b2Distance(v7, v8, v9);
  }
}

uint64_t b2QuadtreeShape::Clone(b2QuadtreeShape *this)
{
  uint64_t v2;

  v2 = operator new();
  *(_QWORD *)v2 = &off_24C0E82F0;
  *(_QWORD *)(v2 + 16) = 0;
  *(_QWORD *)(v2 + 24) = 0;
  *(_DWORD *)(v2 + 8) = *((_DWORD *)this + 2);
  *(_DWORD *)(v2 + 12) = *((_DWORD *)this + 3);
  std::shared_ptr<PKPath>::operator=[abi:ne180100]((_QWORD *)(v2 + 16), (uint64_t *)this + 2);
  return v2;
}

uint64_t b2QuadtreeShape::GetChildCount(b2QuadtreeShape *this)
{
  return 1;
}

QuadTree *b2QuadtreeShape::TestPoint(b2QuadtreeShape *this, const b2Transform *a2, const b2Vec2 *a3)
{
  QuadTree *result;
  float v4;
  float v5;
  float var1;
  float var0;
  QuadTreeNode *v8;

  result = (QuadTree *)*((_QWORD *)this + 2);
  if (result)
  {
    v4 = a3->x - a2->var0.x;
    v5 = a3->y - a2->var0.y;
    var0 = a2->var1.var0;
    var1 = a2->var1.var1;
    v8 = 0;
    return (QuadTree *)QuadTree::intersectPoint(result, (float)(v5 * var0) + (float)(var1 * v4), (float)(var1 * v5) - (float)(var0 * v4), &v8);
  }
  return result;
}

QuadTree *b2QuadtreeShape::ComputeDistance(b2QuadtreeShape *this, const b2Transform *a2, const b2Vec2 *a3, float *a4, b2Vec2 *a5)
{
  float v8;
  float v9;
  float var1;
  float var0;
  float v12;
  float v13;
  QuadTree *result;
  float v15;
  float v16;
  float v17;
  float v18;
  float v19;
  float x;
  float y;
  float v22;
  float v23;
  float v24;
  float v25;
  QuadTreeNode *v26;

  v8 = a3->x - a2->var0.x;
  v9 = a3->y - a2->var0.y;
  var0 = a2->var1.var0;
  var1 = a2->var1.var1;
  v12 = (float)(v9 * var0) + (float)(var1 * v8);
  v13 = (float)(var1 * v9) - (float)(var0 * v8);
  result = (QuadTree *)*((_QWORD *)this + 2);
  if (result
    && (v26 = 0,
        result = (QuadTree *)QuadTree::find(result, (float)(v9 * var0) + (float)(var1 * v8), v13, (QuadTreeNode ***)&v26), v26))
  {
    v15 = v12 - (float)((float)(*((float *)v26 + 8) + *((float *)v26 + 9)) * 0.5);
    v16 = v13 - (float)((float)(*((float *)v26 + 10) + *((float *)v26 + 11)) * 0.5);
    v17 = sqrtf((float)(v16 * v16) + (float)(v15 * v15));
    v19 = a2->var1.var0;
    v18 = a2->var1.var1;
    if (v17 <= 0.00000011921)
    {
      v16 = v13;
      v15 = v12;
    }
    a5->x = (float)(v18 * v15) - (float)(v19 * v16);
    a5->y = (float)(v16 * v18) + (float)(v19 * v15);
    *a4 = v17;
    x = a5->x;
    y = a5->y;
  }
  else
  {
    *a4 = -3.4028e38;
    v23 = a2->var1.var0;
    v22 = a2->var1.var1;
    x = (float)(v22 * v12) - (float)(v23 * v13);
    y = (float)(v13 * v22) + (float)(v23 * v12);
    a5->x = x;
    a5->y = y;
  }
  v24 = sqrtf((float)(y * y) + (float)(x * x));
  if (v24 >= 0.00000011921)
  {
    v25 = 1.0 / v24;
    a5->x = x * v25;
    a5->y = y * v25;
  }
  return result;
}

uint64_t b2QuadtreeShape::RayCast(uint64_t a1, float *a2, float *a3, float *a4)
{
  float v5;
  float v6;
  float v7;
  float v8;
  float v9;
  float v10;
  float v11;
  float v12;
  float v13;
  float v14;
  float v15;
  float v16;
  float v17;
  float v18;
  float v19;
  float v20;
  QuadTreeNode *v22;

  v5 = a4[1];
  v6 = *a3 - *a4;
  v7 = a3[1] - v5;
  v9 = a4[2];
  v8 = a4[3];
  v10 = (float)(v7 * v9) + (float)(v8 * v6);
  v11 = (float)(v8 * v7) - (float)(v9 * v6);
  v12 = a3[2] - *a4;
  v13 = a3[3] - v5;
  v14 = (float)(v9 * v13) + (float)(v8 * v12);
  v15 = (float)(v8 * v13) - (float)(v9 * v12);
  v22 = 0;
  QuadTree::intersectRay(*(QuadTree **)(a1 + 16), v10, v11, v14, v15, &v22);
  v16 = v14 - v10;
  v17 = v15 - v11;
  *a2 = v14 - v10;
  a2[1] = v15 - v11;
  v18 = sqrtf((float)(v17 * v17) + (float)(v16 * v16));
  if (v18 >= 0.00000011921)
  {
    *a2 = v16 * (float)(1.0 / v18);
    a2[1] = v17 * (float)(1.0 / v18);
  }
  v19 = *((float *)v22 + 10) + *((float *)v22 + 11);
  v20 = v14 - (float)((float)(*((float *)v22 + 8) + *((float *)v22 + 9)) * 0.5);
  a2[2] = v18
        - sqrtf((float)((float)(v15 - (float)(v19 * 0.5)) * (float)(v15 - (float)(v19 * 0.5))) + (float)(v20 * v20));
  return 0;
}

float b2QuadtreeShape::ComputeAABB(uint64_t a1, float *a2, float *a3)
{
  QuadTree *v3;
  float v6;
  float v7;
  float v8;
  float v9;
  float v10;
  float result;
  uint64_t v12;
  uint64_t v13;

  v3 = *(QuadTree **)(a1 + 16);
  if (v3)
  {
    v12 = 0;
    v13 = 0;
    QuadTree::bounds(v3, (float *)&v13 + 1, (float *)&v13, (float *)&v12 + 1, (float *)&v12);
    v7 = a3[2];
    v6 = a3[3];
    v8 = (float)((float)(*(float *)&v13 * v6) + (float)(v7 * *((float *)&v13 + 1))) + a3[1];
    *a2 = *a3 + (float)((float)(v6 * *((float *)&v13 + 1)) - (float)(v7 * *(float *)&v13));
    a2[1] = v8;
    v10 = a3[2];
    v9 = a3[3];
    result = (float)((float)(*(float *)&v12 * v9) + (float)(v10 * *((float *)&v12 + 1))) + a3[1];
    a2[2] = *a3 + (float)((float)(v9 * *((float *)&v12 + 1)) - (float)(v10 * *(float *)&v12));
    a2[3] = result;
  }
  return result;
}

uint64_t b2QuadtreeShape::ComputeMass(uint64_t a1, _QWORD *a2)
{
  uint64_t result;

  result = puts("E");
  *a2 = 0;
  a2[1] = 0;
  return result;
}

void b2QuadtreeShape::~b2QuadtreeShape(b2QuadtreeShape *this)
{
  *(_QWORD *)this = &off_24C0E82F0;
  std::shared_ptr<QuadTree>::~shared_ptr[abi:ne180100]((uint64_t)this + 16);
}

{
  *(_QWORD *)this = &off_24C0E82F0;
  std::shared_ptr<QuadTree>::~shared_ptr[abi:ne180100]((uint64_t)this + 16);
  JUMPOUT(0x20BD0BA58);
}

void setRegionOnField(uint64_t a1, void *a2)
{
  objc_storeStrong(*(id **)(a1 + 8), a2);
}

id getRegionOnField(uint64_t a1)
{
  return **(id **)(a1 + 8);
}

id setRepresentedObjectOnField(uint64_t a1, void *a2)
{
  return objc_storeWeak(*(id **)(a1 + 16), a2);
}

id fieldRepresentedObject(uint64_t a1)
{
  return objc_loadWeakRetained(*(id **)(a1 + 16));
}

void PKCField::PKCField(PKCField *this)
{
  _QWORD *v2;
  _QWORD *v3;

  *(_QWORD *)this = off_24C0E8968;
  v2 = (_QWORD *)operator new();
  *v2 = 0;
  *((_QWORD *)this + 1) = v2;
  v3 = (_QWORD *)operator new();
  *v3 = 0;
  *((_QWORD *)this + 2) = v3;
  *((_OWORD *)this + 8) = xmmword_208FD6860;
  *((_OWORD *)this + 9) = xmmword_208FD6060;
  *((_OWORD *)this + 10) = xmmword_208FD6870;
  *((_OWORD *)this + 11) = xmmword_208FD6030;
  *((_DWORD *)this + 49) = 1065353216;
  *((_BYTE *)this + 200) = 0;
  *(_QWORD *)((char *)this + 204) = 0x3800000000000000;
  *((_DWORD *)this + 60) = -1;
  *((_WORD *)this + 122) = 1;
  *((_OWORD *)this + 14) = 0u;
  ++fieldCount;
}

void PKCField::PKCField(PKCField *this, const PKCField *a2)
{
  _QWORD *v4;
  id *v5;
  id WeakRetained;
  __int128 v7;
  __int128 v8;
  __int128 v9;

  *(_QWORD *)this = off_24C0E8968;
  v4 = (_QWORD *)operator new();
  *v4 = **((id **)a2 + 1);
  *((_QWORD *)this + 1) = v4;
  v5 = (id *)operator new();
  WeakRetained = objc_loadWeakRetained(*((id **)a2 + 2));
  objc_initWeak(v5, WeakRetained);

  *((_QWORD *)this + 2) = v5;
  v7 = *((_OWORD *)a2 + 8);
  v8 = *((_OWORD *)a2 + 9);
  v9 = *((_OWORD *)a2 + 11);
  *((_OWORD *)this + 10) = *((_OWORD *)a2 + 10);
  *((_OWORD *)this + 11) = v9;
  *((_OWORD *)this + 8) = v7;
  *((_OWORD *)this + 9) = v8;
  *((_DWORD *)this + 48) = 1065353216;
  *((_DWORD *)this + 49) = *((_DWORD *)a2 + 49);
  *((_BYTE *)this + 200) = *((_BYTE *)a2 + 200);
  *(_QWORD *)((char *)this + 204) = *(_QWORD *)((char *)a2 + 204);
  *((_OWORD *)this + 14) = *((_OWORD *)a2 + 14);
  *((_DWORD *)this + 60) = *((_DWORD *)a2 + 60);
  *((_WORD *)this + 122) = *((_WORD *)a2 + 122);
  ++fieldCount;
}

void PKCField::~PKCField(PKCField *this)
{
  id *v2;
  uint64_t v3;

  *(_QWORD *)this = off_24C0E8968;
  --fieldCount;
  v2 = (id *)*((_QWORD *)this + 1);
  if (v2)
  {

    MEMORY[0x20BD0BA58](v2, 0x80C40B8603338);
  }
  v3 = *((_QWORD *)this + 2);
  if (v3)
  {
    objc_destroyWeak(*((id **)this + 2));
    MEMORY[0x20BD0BA58](v3, 0x80C40B8603338);
  }
}

void PKCField::setTransform(uint64_t a1, uint64_t a2, float *a3, float32x4_t *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, __int128 a9, __int128 a10, __int128 a11, __int128 a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20)
{
  __int128 v23;
  __int128 v24;
  __int128 v25;
  float32x4_t v26;
  float v27;
  float v28;
  __float2 v29;
  __float2 v30;
  __float2 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  float v37;
  float v38;
  float v39;
  float v40;
  float32x4_t v41;
  float v42;
  float v43;
  float v44;
  float v45;
  float v46;
  float v47;
  float v48;
  unint64_t v49;
  __int128 v50;
  float32x4_t v51;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  float32x4_t v55;
  float32x4_t v56;
  __int128 v57;
  float32x4_t v58;
  __int128 v59;
  int32x4_t v60;
  int32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  __int128 v64;
  _OWORD v65[2];
  __int128 v66;
  __int128 v67;
  __int128 v68;
  __int128 vars0;

  a20 = *MEMORY[0x24BDAC8D0];
  *(_OWORD *)(a1 + 32) = *(_OWORD *)a2;
  if (*(_BYTE *)(a1 + 245))
  {
    LODWORD(v23) = 1065353216;
    LODWORD(v24) = 0;
    *(_OWORD *)(a1 + 64) = xmmword_208FD6860;
    *(_OWORD *)(a1 + 80) = xmmword_208FD6060;
    LODWORD(v25) = 0;
    v26 = (float32x4_t)xmmword_208FD6030;
    *(_OWORD *)(a1 + 96) = xmmword_208FD6870;
    *(_OWORD *)(a1 + 112) = xmmword_208FD6030;
  }
  else
  {
    v27 = *a3;
    v28 = a3[2];
    v29 = __sincosf_stret(a3[1]);
    v30 = __sincosf_stret(v27);
    v31 = __sincosf_stret(v28);
    HIDWORD(v32) = 0;
    *(_QWORD *)&v32 = __PAIR64__((float)(v31.__cosval * (float)(v29.__sinval * v30.__sinval))- (float)(v29.__cosval * v31.__sinval), (float)(v31.__sinval * (float)(v29.__sinval * v30.__sinval))+ (float)(v29.__cosval * v31.__cosval));
    *((float *)&v32 + 2) = v29.__sinval * v30.__cosval;
    HIDWORD(v33) = 0;
    *(_QWORD *)&v33 = __PAIR64__(v31.__cosval * v30.__cosval, v31.__sinval * v30.__cosval);
    *((float *)&v33 + 2) = -v30.__sinval;
    HIDWORD(v34) = 0;
    *(_QWORD *)&v34 = __PAIR64__((float)(v31.__cosval * (float)(v29.__cosval * v30.__sinval))+ (float)(v31.__sinval * v29.__sinval), (float)(v31.__sinval * (float)(v29.__cosval * v30.__sinval))- (float)(v29.__sinval * v31.__cosval));
    v66 = v32;
    v67 = v33;
    *((float *)&v34 + 2) = v29.__cosval * v30.__cosval;
    v68 = v34;
    vars0 = xmmword_208FD6030;
    math::transpose((uint64_t)&v66, (uint64_t)&a9);
    v35 = a10;
    *(_OWORD *)(a1 + 64) = a9;
    *(_OWORD *)(a1 + 80) = v35;
    v36 = a12;
    *(_OWORD *)(a1 + 96) = a11;
    *(_OWORD *)(a1 + 112) = v36;
    v23 = *(_OWORD *)(a1 + 64);
    v24 = *(_OWORD *)(a1 + 80);
    v25 = *(_OWORD *)(a1 + 96);
    v26 = *(float32x4_t *)(a1 + 112);
  }
  v37 = -*(float *)a2;
  v38 = -*(float *)(a2 + 4);
  v39 = -*(float *)(a2 + 8);
  v66 = xmmword_208FD6860;
  v67 = xmmword_208FD6060;
  v40 = a4->f32[1];
  v41.i32[0] = 1.0;
  if (fabsf(a4->f32[0]) <= 0.000030518)
    v42 = 1.0;
  else
    v42 = 1.0 / a4->f32[0];
  v43 = fabsf(v40);
  v44 = 1.0 / v40;
  if (v43 <= 0.000030518)
    v44 = 1.0;
  v45 = a4->f32[2];
  v46 = fabsf(v45);
  v47 = 1.0 / v45;
  if (v46 <= 0.000030518)
    v48 = 1.0;
  else
    v48 = v47;
  LODWORD(v49) = 0;
  *((float *)&v49 + 1) = v44;
  a9 = LODWORD(v42);
  a10 = v49;
  *(_QWORD *)&v50 = 0;
  *((_QWORD *)&v50 + 1) = LODWORD(v48);
  v41.i32[1] = 0;
  v41.i32[2] = 0;
  v41.f32[3] = v37;
  v51 = (float32x4_t)xmmword_208FD6060;
  v51.i32[0] = DWORD1(v66);
  a11 = v50;
  a12 = xmmword_208FD6030;
  v51.f32[3] = v38;
  v52 = (float32x4_t)xmmword_208FD6870;
  v52.i32[0] = DWORD2(v66);
  v52.f32[3] = v39;
  v53 = (float32x4_t)xmmword_208FD6030;
  v53.i32[0] = *(_DWORD *)((unint64_t)&v66 | 0xC);
  v54 = vmlaq_n_f32(vmlaq_n_f32(vmlaq_n_f32(vmulq_n_f32(v41, *(float *)&v23), v51, *(float *)&v24), v52, *(float *)&v25), v53, v26.f32[0]);
  v55 = vmlaq_n_f32(vmlaq_n_f32(vmlaq_n_f32(vmulq_n_f32(v41, COERCE_FLOAT(*(_OWORD *)(a1 + 68))), v51, COERCE_FLOAT(*(_OWORD *)(a1 + 84))), v52, COERCE_FLOAT(*(_OWORD *)(a1 + 100))), v53, *(float *)vshrq_n_u64((uint64x2_t)v26, 0x20uLL).i32);
  v56 = vmlaq_laneq_f32(vmlaq_n_f32(vmlaq_n_f32(vmulq_n_f32(v41, COERCE_FLOAT(*(_OWORD *)(a1 + 72))), v51, COERCE_FLOAT(*(_OWORD *)(a1 + 88))), v52, COERCE_FLOAT(*(_OWORD *)(a1 + 104))), v53, v26, 2);
  LODWORD(v57) = vdupq_lane_s32(*(int32x2_t *)v54.f32, 1).u32[0];
  v58 = vmlaq_laneq_f32(vmlaq_n_f32(vmlaq_n_f32(vmulq_n_f32(v41, COERCE_FLOAT(*(_OWORD *)(a1 + 76))), v51, COERCE_FLOAT(*(_OWORD *)(a1 + 92))), v52, COERCE_FLOAT(*(_OWORD *)(a1 + 108))), v53, v26, 3);
  *(_QWORD *)&v59 = vzip1q_s32((int32x4_t)v54, (int32x4_t)v55).u64[0];
  DWORD1(v57) = v55.i32[1];
  *((_QWORD *)&v59 + 1) = __PAIR64__(v58.u32[0], v56.u32[0]);
  *((_QWORD *)&v57 + 1) = __PAIR64__(v58.u32[1], v56.u32[1]);
  v65[0] = v59;
  v65[1] = v57;
  v55.i32[0] = DWORD1(v59);
  v54.i32[0] = v59;
  v58.i32[0] = *(_DWORD *)((unint64_t)v65 | 0xC);
  v60 = (int32x4_t)vmlaq_f32(vmlaq_f32(vmlaq_f32(vmulq_n_f32(v54, v42), (float32x4_t)0, v55), (float32x4_t)0, v56), (float32x4_t)0, v58);
  v61 = (int32x4_t)vmlaq_f32(vmlaq_n_f32(vmlaq_n_f32(vmulq_n_f32(v54, *((float *)&a9 + 1)), v55, *((float *)&v49 + 1)), v56, *((float *)&a11 + 1)), (float32x4_t)0, v58);
  v62 = vmlaq_f32(vmlaq_n_f32(vmlaq_n_f32(vmulq_n_f32(v54, *((float *)&a9 + 2)), v55, 0.0), v56, *((float *)&a11 + 2)), (float32x4_t)0, v58);
  v63 = vaddq_f32(v58, vmlaq_n_f32(vmlaq_n_f32(vmulq_n_f32(v54, *((float *)&a9 + 3)), v55, COERCE_FLOAT((unsigned __int128)v49 >> 96)), v56, *((float *)&a11 + 3)));
  *(_QWORD *)&v57 = vzip1q_s32(v60, v61).u64[0];
  *(_QWORD *)&v64 = vtrn2q_s32(v60, v61).u64[0];
  v58.i64[0] = vzip2q_s32(v60, v61).u64[0];
  v61.i64[0] = vuzp2q_s32(vuzp2q_s32(v60, v61), v60).u64[0];
  *((_QWORD *)&v57 + 1) = __PAIR64__(v63.u32[0], v62.u32[0]);
  *((_QWORD *)&v64 + 1) = __PAIR64__(v63.u32[1], v62.u32[1]);
  v58.i64[1] = __PAIR64__(v63.u32[2], v62.u32[2]);
  v61.i64[1] = __PAIR64__(v63.u32[3], v62.u32[3]);
  *(_OWORD *)(a1 + 128) = v57;
  *(_OWORD *)(a1 + 144) = v64;
  *(float32x4_t *)(a1 + 160) = v58;
  *(int32x4_t *)(a1 + 176) = v61;
  *(float *)(a1 + 192) = sqrtf(fabsf(vmulq_lane_f32(*a4, *(float32x2_t *)a4->f32, 1).f32[0]));
}

void *PKCField::hasFiniteRegion(PKCField *this)
{
  void *result;

  result = (void *)**((_QWORD **)this + 1);
  if (result)
    return (void *)(objc_msgSend(result, "isInfinite") ^ 1);
  return result;
}

void *PKCField::hasEmptyRegion(PKCField *this)
{
  void *result;

  result = (void *)**((_QWORD **)this + 1);
  if (result)
    return (void *)objc_msgSend(result, "isEmpty");
  return result;
}

uint64_t PKCField::contains(uint64_t a1, float32x4_t *a2)
{
  void *v3;
  id v5;
  float v6;
  float v7;
  float32x2_t v8;
  uint64_t v9;
  float32x4_t v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  float32x4_t v15;

  if (!*(_BYTE *)(a1 + 244))
    return 0;
  v3 = **(void ***)(a1 + 8);
  if (!v3)
    return 1;
  v5 = v3;
  v12 = *(float32x4_t *)(a1 + 144);
  v13 = *(float32x4_t *)(a1 + 128);
  v11 = *(float32x4_t *)(a1 + 160);
  v14 = *(float32x4_t *)(a1 + 176);
  v15 = *a2;
  v6 = PKGet_PTM_RATIO();
  v7 = PKGet_PTM_RATIO();
  v8 = (float32x2_t)vaddq_f32(vaddq_f32(vmulq_n_f32(v13, v15.f32[0]), vmulq_lane_f32(v12, *(float32x2_t *)v15.f32, 1)), vaddq_f32(vmulq_laneq_f32(v11, v15, 2), v14)).u64[0];
  v9 = objc_msgSend(v5, "containsPoint:", (float)(v6 * v8.f32[0]), vmuls_lane_f32(v7, v8, 1));

  return v9;
}

void sub_208FB26B8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

float PKCField::calculatedFalloff(float32x4_t *a1, float32x4_t a2)
{
  float v2;
  float32x4_t v4;
  float32x4_t v5;
  float v6;

  v2 = a1[12].f32[3];
  if (fabsf(v2) < 0.000030518)
    return 1.0;
  v4 = vaddq_f32(vaddq_f32(vmulq_n_f32(a1[8], a2.f32[0]), vmulq_lane_f32(a1[9], *(float32x2_t *)a2.f32, 1)), vaddq_f32(vmulq_laneq_f32(a1[10], a2, 2), a1[11]));
  v5 = vmulq_f32(v4, v4);
  v6 = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v5, 2), vaddq_f32(v5, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v5.f32, 1))).f32[0]);
  if (v6 < a1[13].f32[0])
    v6 = a1[13].f32[0];
  return powf(v6, -v2);
}

float PKCField::calculatedLocalFalloff(uint64_t a1, float32x4_t a2)
{
  float v2;
  float32x4_t v4;
  float v5;

  v2 = *(float *)(a1 + 204);
  if (fabsf(v2) < 0.000030518)
    return 1.0;
  v4 = vmulq_f32(a2, a2);
  v5 = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v4, 2), vaddq_f32(v4, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v4.f32, 1))).f32[0]);
  if (v5 < *(float *)(a1 + 208))
    v5 = *(float *)(a1 + 208);
  return powf(v5, -v2);
}

void PKCField::evalForceVec2(uint64_t a1, uint64_t a2, uint64_t a3, int a4, int a5, float32x4_t a6)
{
  int v7;
  float32x2_t *v10;
  double v11;
  float32x2_t v12;
  void *v13;
  float v14;
  int v15;
  float v16;
  _BYTE *v17;
  uint64_t v18;
  _DWORD *v19;
  uint64_t v20;
  BOOL v21;
  float v22;
  float32x2_t v23;
  double v24;
  BOOL v25;
  int v26;
  char v27;
  uint64_t v28;
  float32x4_t v29;
  uint64_t v30;
  int v31;
  uint64_t v32;
  int32x2_t v34;
  uint64_t v35;
  uint64_t v36;
  float32x4_t v37[2];

  v7 = a3;
  if ((a4 & 1) == 0 && (a5 & 1) == 0)
  {
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a1 + 16))(a1, a2, a3);
    return;
  }
  v10 = *(float32x2_t **)(a2 + 168);
  v32 = *(_QWORD *)(a2 + 8);
  v35 = *(_QWORD *)(a2 + 16);
  v36 = *(_QWORD *)(a2 + 176);
  v28 = *(_QWORD *)(a2 + 40);
  a6.i32[0] = *(_DWORD *)(a2 + 272);
  v34 = *(int32x2_t *)a6.f32;
  v11 = *(double *)(a2 + 256);
  v12 = *(float32x2_t *)(a2 + 264);
  v13 = **(void ***)(a1 + 8);
  if (v13)
    v31 = objc_msgSend(v13, "isInfinite") ^ 1;
  else
    v31 = 0;
  if (*(_BYTE *)(a2 + 88))
    v14 = *(float *)(a2 + 64);
  else
    v14 = 1.0;
  v15 = a5;
  if (*(_BYTE *)(a2 + 120))
  {
    v16 = *(float *)(a2 + 96);
    if (a4)
      goto LABEL_12;
LABEL_15:
    v18 = 0;
    v17 = 0;
    if (!a5)
      goto LABEL_13;
    goto LABEL_16;
  }
  v16 = 0.0;
  if (!a4)
    goto LABEL_15;
LABEL_12:
  v17 = *(_BYTE **)(a2 + 200);
  v18 = *(_QWORD *)(a2 + 208);
  if (!a5)
  {
LABEL_13:
    v19 = 0;
    v30 = 0;
    goto LABEL_17;
  }
LABEL_16:
  v19 = *(_DWORD **)(a2 + 136);
  v30 = *(_QWORD *)(a2 + 144);
LABEL_17:
  if (v7 >= 1)
  {
    v20 = 0;
    v21 = 0;
    v22 = v11;
    v27 = *(_BYTE *)(a1 + 200);
    v23 = (float32x2_t)vdup_lane_s32(v34, 0);
    v24 = v22;
    v25 = 1;
    do
    {
      if (a4)
        v21 = *v17 != 0;
      if (v15)
      {
        v25 = (*(_DWORD *)(a1 + 240) & *v19) != 0;
        v19 = (_DWORD *)((char *)v19 + v30);
      }
      if (!v21 && v25)
      {
        *(float32x2_t *)a6.f32 = vmul_n_f32(vadd_f32(v12, *(float32x2_t *)(v32 + v20)), *(float *)v34.i32);
        v37[0] = a6;
        if (!v31 || (v29 = a6, v26 = PKCField::contains(a1, v37), a6 = v29, v26))
        {
          *v10 = vadd_f32(*v10, vdiv_f32(COERCE_FLOAT32X2_T((*(double (**)(uint64_t, float32x4_t, double, float, float, double))(*(_QWORD *)a1 + 40))(a1, a6, COERCE_DOUBLE(vmul_n_f32(*(float32x2_t *)(v28 + v20), *(float *)v34.i32)), v14, v16, v24)), v23));
          if (a4)
            *v17 = v27;
        }
        v15 = a5;
      }
      v10 = (float32x2_t *)((char *)v10 + v36);
      v17 += v18;
      v20 += v35;
      --v7;
    }
    while (v7);
  }
}

void PKCField::evalForceVec2(_QWORD **a1, uint64_t a2, int a3, double a4, int32x2_t a5, float32x4_t a6)
{
  void *v9;
  int v10;
  float v11;
  float v12;
  uint64_t v13;
  uint64_t v14;
  float32x2_t *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  float32x2_t v19;
  float v20;
  float32x2_t v21;
  double v22;
  float32x2_t v23;
  int v24;
  float32x4_t v25;
  float v26;
  float32x4_t v27;

  v9 = (void *)*a1[1];
  if (v9)
    v10 = objc_msgSend(v9, "isInfinite") ^ 1;
  else
    v10 = 0;
  if (*(_BYTE *)(a2 + 88))
    v11 = *(float *)(a2 + 64);
  else
    v11 = 1.0;
  if (*(_BYTE *)(a2 + 120))
    v12 = *(float *)(a2 + 96);
  else
    v12 = 0.0;
  if (a3 >= 1)
  {
    v13 = 0;
    v14 = *(_QWORD *)(a2 + 40);
    v15 = *(float32x2_t **)(a2 + 168);
    v16 = *(_QWORD *)(a2 + 176);
    v17 = *(_QWORD *)(a2 + 8);
    v18 = *(_QWORD *)(a2 + 16);
    v19 = *(float32x2_t *)(a2 + 264);
    a5.i32[0] = *(_DWORD *)(a2 + 272);
    v20 = *(double *)(a2 + 256);
    v26 = *(float *)a5.i32;
    v21 = (float32x2_t)vdup_lane_s32(a5, 0);
    v22 = v20;
    do
    {
      *(float32x2_t *)a6.f32 = vmul_n_f32(vadd_f32(v19, *(float32x2_t *)(v17 + v13)), v26);
      v23 = *(float32x2_t *)(v14 + v13);
      v27 = a6;
      if (!v10 || (v25 = a6, v24 = PKCField::contains((uint64_t)a1, &v27), a6 = v25, v24))
        *v15 = vadd_f32(*v15, vdiv_f32(COERCE_FLOAT32X2_T(((double (*)(_QWORD **, float32x4_t, double, float, float, double))(*a1)[5])(a1, a6, COERCE_DOUBLE(vmul_n_f32(v23, v26)), v11, v12, v22)), v21));
      v15 = (float32x2_t *)((char *)v15 + v16);
      v13 += v18;
      --a3;
    }
    while (a3);
  }
}

void PKCFieldLinearGravity::PKCFieldLinearGravity(PKCFieldLinearGravity *this)
{
  uint64_t v1;

  PKCField::PKCField((PKCField *)this);
  *(_QWORD *)v1 = &off_24C0E8648;
  *(_OWORD *)(v1 + 256) = 0u;
  *(_DWORD *)(v1 + 204) = 0;
}

{
  uint64_t v1;

  PKCField::PKCField((PKCField *)this);
  *(_QWORD *)v1 = &off_24C0E8648;
  *(_OWORD *)(v1 + 256) = 0u;
  *(_DWORD *)(v1 + 204) = 0;
}

double PKCFieldLinearGravity::evalForce(uint64_t a1, float32x4_t a2, double a3, float a4)
{
  float v4;
  double v5;

  v4 = *(float *)(a1 + 196) * *(float *)(a1 + 192);
  v5 = 0.0;
  if (fabsf(v4 * a4) >= 0.000030518)
    *(_QWORD *)&v5 = vmulq_n_f32(vmulq_n_f32(vmulq_n_f32(vaddq_f32(vaddq_f32(vmulq_n_f32(*(float32x4_t *)(a1 + 64), COERCE_FLOAT(*(_OWORD *)(a1 + 256))), vmulq_lane_f32(*(float32x4_t *)(a1 + 80), *(float32x2_t *)(a1 + 256), 1)), vaddq_f32(vmulq_laneq_f32(*(float32x4_t *)(a1 + 96), *(float32x4_t *)(a1 + 256), 2), vmulq_f32(*(float32x4_t *)(a1 + 112), (float32x4_t)0))), v4), a4), PKCField::calculatedFalloff((float32x4_t *)a1, a2)).u64[0];
  return v5;
}

__n128 PKCFieldLinearGravity::setGravity(__n128 *a1, __n128 *a2)
{
  __n128 result;

  result = *a2;
  a1[16] = *a2;
  return result;
}

void PKCFieldRadialGravity::PKCFieldRadialGravity(PKCFieldRadialGravity *this)
{
  uint64_t v1;

  PKCField::PKCField((PKCField *)this);
  *(_QWORD *)v1 = &off_24C0E86A0;
  *(_DWORD *)(v1 + 196) = 1065353216;
  *(_BYTE *)(v1 + 245) = 1;
  *(_DWORD *)(v1 + 204) = 0x40000000;
}

{
  uint64_t v1;

  PKCField::PKCField((PKCField *)this);
  *(_QWORD *)v1 = &off_24C0E86A0;
  *(_DWORD *)(v1 + 196) = 1065353216;
  *(_BYTE *)(v1 + 245) = 1;
  *(_DWORD *)(v1 + 204) = 0x40000000;
}

void PKCFieldRadialGravity::evalForce(float32x4_t *a1, float32x4_t a2, double a3, float a4)
{
  float32x4_t v4;
  float32x4_t v5;
  float v6;
  float v7;
  float v8;
  float v9;

  if (fabsf((float)(a1[12].f32[1] * a1[12].f32[0]) * a4) >= 0.000030518)
  {
    v4 = vaddq_f32(vaddq_f32(vmulq_n_f32(a1[8], a2.f32[0]), vmulq_lane_f32(a1[9], *(float32x2_t *)a2.f32, 1)), vaddq_f32(vmulq_laneq_f32(a1[10], a2, 2), a1[11]));
    v5 = vmulq_f32(v4, v4);
    v6 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v5, 2), vaddq_f32(v5, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v5.f32, 1))).f32[0];
    if (v6 >= 0.00001)
    {
      v7 = sqrtf(v6);
      v8 = a1[12].f32[3];
      if (fabsf(v8) >= 0.000030518)
      {
        v9 = a1[13].f32[0];
        if (v7 >= v9)
          v9 = v7;
        powf(v9, -v8);
      }
    }
  }
}

void PKCFieldSpring::PKCFieldSpring(PKCFieldSpring *this)
{
  uint64_t v1;

  PKCField::PKCField((PKCField *)this);
  *(_DWORD *)(v1 + 196) = 1065353216;
  *(_QWORD *)v1 = &off_24C0E80E8;
  *(_BYTE *)(v1 + 245) = 1;
  *(_DWORD *)(v1 + 204) = -1082130432;
}

{
  uint64_t v1;

  PKCField::PKCField((PKCField *)this);
  *(_DWORD *)(v1 + 196) = 1065353216;
  *(_QWORD *)v1 = &off_24C0E80E8;
  *(_BYTE *)(v1 + 245) = 1;
  *(_DWORD *)(v1 + 204) = -1082130432;
}

void PKCFieldSpring::evalForce(float32x4_t *a1, float32x4_t a2)
{
  float32x4_t v2;
  float32x4_t v3;
  float v4;
  float v5;
  float v6;

  if (fabsf(a1[12].f32[1] * a1[12].f32[0]) >= 0.000030518)
  {
    v2 = vaddq_f32(vaddq_f32(vmulq_n_f32(a1[8], a2.f32[0]), vmulq_lane_f32(a1[9], *(float32x2_t *)a2.f32, 1)), vaddq_f32(vmulq_laneq_f32(a1[10], a2, 2), a1[11]));
    v3 = vmulq_f32(v2, v2);
    v4 = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v3, 2), vaddq_f32(v3, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v3.f32, 1))).f32[0]);
    if (v4 >= 0.00001)
    {
      v5 = a1[12].f32[3];
      if (fabsf(v5) >= 0.000030518)
      {
        v6 = a1[13].f32[0];
        if (v4 >= v6)
          v6 = v4;
        powf(v6, -v5);
      }
    }
  }
}

void PKCFieldElectric::PKCFieldElectric(PKCFieldElectric *this)
{
  uint64_t v1;

  PKCField::PKCField((PKCField *)this);
  *(_DWORD *)(v1 + 196) = 1065353216;
  *(_QWORD *)v1 = &off_24C0E83A0;
  *(_BYTE *)(v1 + 245) = 1;
  *(_DWORD *)(v1 + 204) = 1065353216;
}

{
  uint64_t v1;

  PKCField::PKCField((PKCField *)this);
  *(_DWORD *)(v1 + 196) = 1065353216;
  *(_QWORD *)v1 = &off_24C0E83A0;
  *(_BYTE *)(v1 + 245) = 1;
  *(_DWORD *)(v1 + 204) = 1065353216;
}

double PKCFieldElectric::evalForce(float32x4_t *a1, float32x4_t a2, double a3, double a4, float a5)
{
  float v5;
  double v6;
  float32x4_t v7;
  float32x4_t v8;
  int32x2_t v9;
  float32x4_t v10;
  float v11;
  float v12;
  float v13;
  float32x4_t v15;

  v5 = (float)(a1[12].f32[1] * a1[12].f32[0]) * a5;
  v6 = 0.0;
  if (fabsf(v5) >= 0.000030518)
  {
    v7 = vaddq_f32(vaddq_f32(vmulq_n_f32(a1[8], a2.f32[0]), vmulq_lane_f32(a1[9], *(float32x2_t *)a2.f32, 1)), vaddq_f32(vmulq_laneq_f32(a1[10], a2, 2), a1[11]));
    v8 = vmulq_f32(v7, v7);
    v9 = (int32x2_t)vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v8, 2), vaddq_f32(v8, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v8.f32, 1))).u64[0];
    *(float *)v9.i32 = sqrtf(*(float *)v9.i32);
    v10 = vdivq_f32(v7, (float32x4_t)vdupq_lane_s32(v9, 0));
    v11 = a1[12].f32[3];
    v12 = 1.0;
    if (fabsf(v11) >= 0.000030518)
    {
      v13 = a1[13].f32[0];
      if (*(float *)v9.i32 >= v13)
        v13 = *(float *)v9.i32;
      v15 = v10;
      v12 = powf(v13, -v11);
      v10 = v15;
    }
    *(_QWORD *)&v6 = vmulq_n_f32(v10, v5 * v12).u64[0];
  }
  return v6;
}

void PKCFieldMagnetic::PKCFieldMagnetic(PKCFieldMagnetic *this)
{
  uint64_t v1;

  PKCField::PKCField((PKCField *)this);
  *(_DWORD *)(v1 + 196) = 1065353216;
  *(_QWORD *)v1 = &off_24C0E83F8;
  *(_BYTE *)(v1 + 245) = 1;
  *(_DWORD *)(v1 + 204) = 1065353216;
}

{
  uint64_t v1;

  PKCField::PKCField((PKCField *)this);
  *(_DWORD *)(v1 + 196) = 1065353216;
  *(_QWORD *)v1 = &off_24C0E83F8;
  *(_BYTE *)(v1 + 245) = 1;
  *(_DWORD *)(v1 + 204) = 1065353216;
}

double PKCFieldMagnetic::evalForce(float32x4_t *a1, float32x4_t a2, float32x4_t a3, double a4, float a5)
{
  float v5;
  double v6;
  float32x4_t v7;
  float32x4_t v8;
  float32x4_t v9;
  float32x4_t v10;
  float32x4_t v11;
  int8x16_t v12;
  int8x16_t v13;
  float32x2_t v14;

  v5 = a1[12].f32[1] * a1[12].f32[0];
  v6 = 0.0;
  if (fabsf(v5 * a5) >= 0.000030518)
  {
    v7 = a1[4];
    v8 = a1[5];
    v9 = a1[6];
    v10 = a1[7];
    v11 = vmulq_lane_f32(v8, *(float32x2_t *)a3.f32, 1);
    v12 = (int8x16_t)vaddq_f32(vaddq_f32(vmulq_n_f32(v7, a3.f32[0]), v11), vaddq_f32(vmulq_laneq_f32(v9, a3, 2), vmulq_f32(v10, (float32x4_t)0)));
    v13 = (int8x16_t)vaddq_f32(vaddq_f32(vmulq_f32(v7, (float32x4_t)0), vmulq_f32(v8, (float32x4_t)0)), vaddq_f32(v9, v10));
    v10.i32[0] = vextq_s8(v12, v12, 8uLL).u32[0];
    v10.i32[1] = v12.i32[0];
    v14.i32[0] = vextq_s8(v13, v13, 8uLL).u32[0];
    v14.i32[1] = v13.i32[0];
    *(float32x2_t *)v11.f32 = vmla_f32(vmul_f32((float32x2_t)*(_OWORD *)&vextq_s8(v13, v13, 4uLL), vneg_f32(*(float32x2_t *)v10.f32)), v14, (float32x2_t)*(_OWORD *)&vextq_s8(v12, v12, 4uLL));
    v11.i32[2] = vmlas_n_f32((float)-*(float *)&v12.i32[1] * *(float *)v13.i32, *(float *)&v13.i32[1], *(float *)v12.i32);
    *(_QWORD *)&v6 = vmulq_n_f32(v11, v5 * PKCField::calculatedFalloff(a1, a2)).u64[0];
  }
  return v6;
}

void PKCFieldDrag::PKCFieldDrag(PKCFieldDrag *this)
{
  uint64_t v1;

  PKCField::PKCField((PKCField *)this);
  *(_QWORD *)v1 = &off_24C0E7E28;
  *(_DWORD *)(v1 + 204) = 0;
  *(_BYTE *)(v1 + 245) = 0;
}

{
  uint64_t v1;

  PKCField::PKCField((PKCField *)this);
  *(_QWORD *)v1 = &off_24C0E7E28;
  *(_DWORD *)(v1 + 204) = 0;
  *(_BYTE *)(v1 + 245) = 0;
}

double PKCFieldDrag::evalForce(uint64_t a1, float32x4_t a2, float32x4_t a3)
{
  float v3;
  float v4;
  double v5;
  float32x4_t v6;
  float32x4_t v7;
  float v8;

  v3 = *(float *)(a1 + 192);
  v4 = *(float *)(a1 + 196);
  v5 = 0.0;
  if (fabsf(v4 * v3) >= 0.000030518)
  {
    v5 = 0.0;
    v6 = vsubq_f32(a3, vaddq_f32(vaddq_f32(vmulq_n_f32(*(float32x4_t *)(a1 + 64), COERCE_FLOAT(*(_OWORD *)(a1 + 224))), vmulq_lane_f32(*(float32x4_t *)(a1 + 80), *(float32x2_t *)(a1 + 224), 1)), vaddq_f32(vmulq_f32(*(float32x4_t *)(a1 + 112), (float32x4_t)0), vmulq_laneq_f32(*(float32x4_t *)(a1 + 96), *(float32x4_t *)(a1 + 224), 2))));
    v7 = vmulq_f32(v6, v6);
    v8 = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v7, 2), vaddq_f32(v7, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v7.f32, 1))).f32[0]);
    if (v8 > 0.000030518)
      *(_QWORD *)&v5 = vmulq_n_f32(vmulq_n_f32(vmulq_n_f32(vmulq_n_f32(v6, v8), -v4), v3), PKCField::calculatedFalloff((float32x4_t *)a1, a2)).u64[0];
  }
  return v5;
}

void PKCFieldVortex::PKCFieldVortex(PKCFieldVortex *this)
{
  uint64_t v1;

  PKCField::PKCField((PKCField *)this);
  *(_QWORD *)v1 = &off_24C0E8140;
  *(_BYTE *)(v1 + 245) = 1;
  *(_DWORD *)(v1 + 204) = 0;
}

{
  uint64_t v1;

  PKCField::PKCField((PKCField *)this);
  *(_QWORD *)v1 = &off_24C0E8140;
  *(_BYTE *)(v1 + 245) = 1;
  *(_DWORD *)(v1 + 204) = 0;
}

double PKCFieldVortex::evalForce(float32x4_t *a1, float32x4_t a2, double a3, double a4)
{
  float v4;
  float v5;
  double v6;
  float32x4_t v7;
  float32x4_t v8;
  int32x2_t v9;
  float32x4_t v10;
  float v11;
  float v12;
  float v13;
  float v14;
  int32x4_t v15;
  float32x4_t v17;
  double v18;

  v4 = a1[12].f32[0];
  v5 = a1[12].f32[1];
  v6 = 0.0;
  if (fabsf((float)(v5 * v4) * *(float *)&a4) >= 0.000030518)
  {
    v7 = vaddq_f32(vaddq_f32(vmulq_n_f32(a1[8], a2.f32[0]), vmulq_lane_f32(a1[9], *(float32x2_t *)a2.f32, 1)), vaddq_f32(vmulq_laneq_f32(a1[10], a2, 2), a1[11]));
    v8 = vmulq_f32(v7, v7);
    v9 = (int32x2_t)vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v8, 2), vaddq_f32(v8, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v8.f32, 1))).u64[0];
    *(float *)v9.i32 = sqrtf(*(float *)v9.i32);
    v10 = vdivq_f32(v7, (float32x4_t)vdupq_lane_s32(v9, 0));
    v11 = -(float)(v5 * v4);
    v12 = a1[12].f32[3];
    v13 = 1.0;
    if (fabsf(v12) >= 0.000030518)
    {
      v14 = a1[13].f32[0];
      if (*(float *)v9.i32 >= v14)
        v14 = *(float *)v9.i32;
      v17 = v10;
      v18 = a4;
      v13 = powf(v14, -v12);
      v10 = v17;
      a4 = v18;
    }
    v15 = (int32x4_t)vmlaq_f32(vmulq_f32(v10, (float32x4_t)xmmword_208FD6880), (float32x4_t)xmmword_208FD6890, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v10, (int32x4_t)v10), (int8x16_t)v10, 0xCuLL));
    *(_QWORD *)&v6 = vdivq_f32(vmulq_n_f32(vnegq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v15, v15), (int8x16_t)v15, 0xCuLL)), v11 * v13), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a4, 0)).u64[0];
  }
  return v6;
}

void PKCFieldTurbulence::PKCFieldTurbulence(PKCFieldTurbulence *this)
{
  uint64_t v1;

  PKCField::PKCField((PKCField *)this);
  *(_QWORD *)(v1 + 248) = 1056964608;
  *(_QWORD *)v1 = &off_24C0E85F0;
  *(_DWORD *)(v1 + 204) = 0;
}

{
  uint64_t v1;

  PKCField::PKCField((PKCField *)this);
  *(_QWORD *)(v1 + 248) = 1056964608;
  *(_QWORD *)v1 = &off_24C0E85F0;
  *(_DWORD *)(v1 + 204) = 0;
}

void PKCFieldNoise::PKCFieldNoise(PKCFieldNoise *this)
{
  uint64_t v1;

  PKCField::PKCField((PKCField *)this);
  *(_QWORD *)v1 = &off_24C0E7FE0;
  *(_QWORD *)(v1 + 248) = 1056964608;
  *(_DWORD *)(v1 + 204) = 0;
}

{
  uint64_t v1;

  PKCField::PKCField((PKCField *)this);
  *(_QWORD *)v1 = &off_24C0E7FE0;
  *(_QWORD *)(v1 + 248) = 1056964608;
  *(_DWORD *)(v1 + 204) = 0;
}

double PKCFieldTurbulence::evalForce(float32x4_t *a1, float32x4_t a2, float32x4_t a3, double a4, double a5, double a6)
{
  double v6;
  float32x4_t v7;
  float32x4_t v8;
  float v11;

  v6 = 0.0;
  if (fabsf(a1[12].f32[1] * a1[12].f32[0]) >= 0.000030518)
  {
    v11 = *(float *)&a4;
    PKCFieldNoise::evalForce(a1, a2, *(double *)a3.i64, a4, 5.87747298e-39, a6);
    v7 = vmulq_f32(a3, a3);
    v7.f32[0] = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v7, 2), vaddq_f32(v7, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v7.f32, 1))).f32[0]);
    *(_QWORD *)&v6 = vmulq_n_f32(vmulq_n_f32(vmulq_n_f32(v8, v11), v7.f32[0]), v7.f32[0]).u64[0];
  }
  return v6;
}

void PKCFieldNoise::evalForce(float32x4_t *a1, float32x4_t a2, double a3, double a4, double a5, double a6)
{
  float v8;
  float v9;
  float32x4_t v10;
  float v11;
  BOOL v12;
  float v13;
  float v14;
  float v15;
  float v16;
  __float2 v17;
  float32x4_t v18;
  int v19;
  uint64_t v20;

  if (fabsf(a1[12].f32[1] * a1[12].f32[0]) >= 0.000030518)
  {
    v8 = a1[15].f32[2];
    v9 = a1[15].f32[3] * a6;
    v18 = a2;
    v10 = vaddq_f32(vaddq_f32(vmulq_n_f32(a1[8], a2.f32[0] + v9), vmulq_n_f32(a1[9], a2.f32[1] + v9)), vaddq_f32(a1[11], vmulq_n_f32(a1[10], a2.f32[2] + v9)));
    v11 = (float)(1.25 / (float)(v8 + 0.083333)) + -1.0;
    v12 = v8 <= 0.0;
    v13 = 14.0;
    if (!v12)
      v13 = v11;
    v20 = 0;
    v19 = 0;
    v14 = v13 * v10.f32[0];
    v15 = vmuls_lane_f32(v13, *(float32x2_t *)v10.f32, 1);
    v16 = vmuls_lane_f32(v13, v10, 2);
    v17 = __sincosf_stret(v9);
    srdnoise3_sincos((float *)&v20 + 1, (float *)&v20, (float *)&v19, v14, v15, v16, v17.__sinval, v17.__cosval);
    PKCField::calculatedFalloff(a1, v18);
  }
}

void PKCFieldNoise::evalForceVec2(uint64_t a1, uint64_t a2, int a3, __n128 a4)
{
  float v4;
  float32x2_t *v8;
  uint64_t v9;
  float32x2_t v10;
  float v11;
  float v12;
  float v13;
  float cosval;
  __float2 v15;
  float v16;
  float v17;
  BOOL v18;
  float v19;
  uint64_t v20;
  float32x2_t *v21;
  void *v22;
  int v23;
  float32x4_t v24;
  float32x4_t v25;
  int v26;
  float32x4_t v27;
  float v28;
  int v29;
  float32x4_t v30;
  float32x2_t v31;
  float32x2_t v32;
  float v33;
  float v34;
  __n128 v35;
  uint64_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;

  v4 = *(float *)(a1 + 196) * *(float *)(a1 + 192);
  if (fabsf(v4) >= 0.000030518)
  {
    v8 = *(float32x2_t **)(a2 + 168);
    v9 = *(_QWORD *)(a2 + 176);
    a4.n128_u32[0] = *(_DWORD *)(a2 + 272);
    v35 = a4;
    v10 = *(float32x2_t *)(a2 + 264);
    v11 = *(double *)(a2 + 256);
    v12 = *(float *)(a1 + 252) * v11;
    v15 = __sincosf_stret(v12);
    cosval = v15.__cosval;
    LODWORD(v13) = *(_QWORD *)&v15;
    v16 = *(float *)(a1 + 248);
    v17 = (float)(1.25 / (float)(v16 + 0.083333)) + -1.0;
    v18 = v16 <= 0.0;
    v19 = 14.0;
    if (!v18)
      v19 = v17;
    v34 = v19;
    v21 = *(float32x2_t **)(a2 + 8);
    v20 = *(_QWORD *)(a2 + 16);
    v22 = **(void ***)(a1 + 8);
    if (v22)
      v23 = objc_msgSend(v22, "isInfinite") ^ 1;
    else
      v23 = 0;
    v39 = 0uLL;
    v24 = (float32x4_t)v35;
    v24.f32[0] = v4 / v35.n128_f32[0];
    if (fabsf(*(float *)(a1 + 204)) >= 0.000030518)
    {
      if (a3 >= 1)
      {
        v31 = (float32x2_t)vdupq_lane_s32(*(int32x2_t *)v24.f32, 0).u64[0];
        do
        {
          *(float32x2_t *)v24.f32 = vmul_n_f32(vadd_f32(v10, *v21), v35.n128_f32[0]);
          v37 = v24;
          v38 = v24;
          if (!v23 || (v29 = PKCField::contains(a1, &v38), v24 = v37, v29))
          {
            v30 = vaddq_f32(vaddq_f32(vmulq_n_f32(*(float32x4_t *)(a1 + 128), v12 + v24.f32[0]), vmulq_n_f32(*(float32x4_t *)(a1 + 144), v12 + v24.f32[1])), vaddq_f32(*(float32x4_t *)(a1 + 176), vmulq_n_f32(*(float32x4_t *)(a1 + 160), v12 + 0.0)));
            v30.i32[3] = 0;
            v33 = srdnoise3_sincos_vector(&v39, vmulq_n_f32(v30, v34), v13, cosval);
            *v8 = vadd_f32(*v8, vmul_n_f32(vmul_f32(v31, vmul_n_f32(*(float32x2_t *)v39.f32, v33)), PKCField::calculatedFalloff((float32x4_t *)a1, v37)));
          }
          v8 = (float32x2_t *)((char *)v8 + v9);
          v21 = (float32x2_t *)((char *)v21 + v20);
          --a3;
        }
        while (a3);
      }
    }
    else if (a3 >= 1)
    {
      v32 = (float32x2_t)vdupq_lane_s32(*(int32x2_t *)v24.f32, 0).u64[0];
      do
      {
        v25.i64[1] = v35.n128_i64[1];
        *(float32x2_t *)v25.f32 = vmul_n_f32(vadd_f32(v10, *v21), v35.n128_f32[0]);
        v38 = v25;
        if (!v23 || (v36 = v25.i64[0], v26 = PKCField::contains(a1, &v38), v25.i64[0] = v36, v26))
        {
          v27 = vaddq_f32(vaddq_f32(vmulq_n_f32(*(float32x4_t *)(a1 + 128), v12 + v25.f32[0]), vmulq_n_f32(*(float32x4_t *)(a1 + 144), v12 + v25.f32[1])), vaddq_f32(*(float32x4_t *)(a1 + 176), vmulq_n_f32(*(float32x4_t *)(a1 + 160), v12 + 0.0)));
          v27.i32[3] = 0;
          v28 = srdnoise3_sincos_vector(&v39, vmulq_n_f32(v27, v34), v13, cosval);
          *v8 = vadd_f32(*v8, vmul_f32(v32, vmul_n_f32(*(float32x2_t *)v39.f32, v28)));
        }
        v8 = (float32x2_t *)((char *)v8 + v9);
        v21 = (float32x2_t *)((char *)v21 + v20);
        --a3;
      }
      while (a3);
    }
  }
}

void PKCFieldNoise::evalForceVec2(uint64_t a1, uint64_t a2, int a3, int a4, int a5, __n128 a6)
{
  int v7;
  float v10;
  float32x2_t *v11;
  float32x2_t v12;
  float v13;
  float v14;
  __float2 v15;
  float v16;
  float v17;
  BOOL v18;
  float v19;
  float32x2_t *v20;
  void *v21;
  int v22;
  uint64_t v23;
  _BYTE *v24;
  _DWORD *v25;
  BOOL v26;
  int32x2_t v27;
  float v28;
  BOOL v29;
  float32x4_t v30;
  int v31;
  float32x4_t v32;
  float v33;
  float32x2_t v34;
  char v35;
  float32x2_t v36;
  float v37;
  uint64_t v38;
  int v39;
  __n128 v40;
  float32x4_t v42;
  uint64_t v43;
  uint64_t v44;
  float32x4_t v45;
  float32x4_t v46;

  v7 = a3;
  if ((a4 & 1) == 0 && (a5 & 1) == 0)
  {
    PKCFieldNoise::evalForceVec2(a1, a2, a3, a6);
    return;
  }
  v10 = *(float *)(a1 + 196) * *(float *)(a1 + 192);
  if (fabsf(v10) >= 0.000030518)
  {
    v11 = *(float32x2_t **)(a2 + 168);
    v44 = *(_QWORD *)(a2 + 176);
    a6.n128_u32[0] = *(_DWORD *)(a2 + 272);
    v40 = a6;
    v12 = *(float32x2_t *)(a2 + 264);
    v13 = *(double *)(a2 + 256);
    v14 = *(float *)(a1 + 252) * v13;
    v15 = __sincosf_stret(v14);
    v16 = *(float *)(a1 + 248);
    v17 = (float)(1.25 / (float)(v16 + 0.083333)) + -1.0;
    v18 = v16 <= 0.0;
    v19 = 14.0;
    if (!v18)
      v19 = v17;
    v37 = v19;
    v20 = *(float32x2_t **)(a2 + 8);
    v43 = *(_QWORD *)(a2 + 16);
    v21 = **(void ***)(a1 + 8);
    if (v21)
      v39 = objc_msgSend(v21, "isInfinite") ^ 1;
    else
      v39 = 0;
    v46 = 0uLL;
    v22 = a5;
    if (a4)
    {
      v24 = *(_BYTE **)(a2 + 200);
      v23 = *(_QWORD *)(a2 + 208);
      if (!a5)
      {
LABEL_12:
        v25 = 0;
        v38 = 0;
        goto LABEL_15;
      }
    }
    else
    {
      v23 = 0;
      v24 = 0;
      if (!a5)
        goto LABEL_12;
    }
    v25 = *(_DWORD **)(a2 + 136);
    v38 = *(_QWORD *)(a2 + 144);
LABEL_15:
    if (v7 >= 1)
    {
      v26 = 0;
      v27.i32[1] = v40.n128_i32[1];
      *(float *)v27.i32 = v10 / v40.n128_f32[0];
      v28 = fabsf(*(float *)(a1 + 204));
      v35 = *(_BYTE *)(a1 + 200);
      v36 = (float32x2_t)vdupq_lane_s32(v27, 0).u64[0];
      v29 = 1;
      do
      {
        if (a4)
          v26 = *v24 != 0;
        if (v22)
        {
          v29 = (*(_DWORD *)(a1 + 240) & *v25) != 0;
          v25 = (_DWORD *)((char *)v25 + v38);
        }
        if (!v26 && v29)
        {
          v30.i64[1] = v40.n128_i64[1];
          *(float32x2_t *)v30.f32 = vmul_n_f32(vadd_f32(v12, *v20), v40.n128_f32[0]);
          v45 = v30;
          v42 = v30;
          if (!v39 || (v31 = PKCField::contains(a1, &v45), v30.i64[0] = v42.i64[0], v22 = a5, v31))
          {
            v32 = vaddq_f32(vaddq_f32(vmulq_n_f32(*(float32x4_t *)(a1 + 128), v14 + v30.f32[0]), vmulq_n_f32(*(float32x4_t *)(a1 + 144), v14 + v30.f32[1])), vaddq_f32(*(float32x4_t *)(a1 + 176), vmulq_n_f32(*(float32x4_t *)(a1 + 160), v14 + 0.0)));
            v32.i32[3] = 0;
            v33 = srdnoise3_sincos_vector(&v46, vmulq_n_f32(v32, v37), v15.__sinval, v15.__cosval);
            v34 = vmul_f32(v36, vmul_n_f32(*(float32x2_t *)v46.f32, v33));
            if (v28 < 0.000030518)
              v34 = vmul_n_f32(v34, PKCField::calculatedFalloff((float32x4_t *)a1, v42));
            v22 = a5;
            if (a4)
              *v24 = v35;
            *v11 = vadd_f32(v34, *v11);
          }
        }
        v24 += v23;
        v11 = (float32x2_t *)((char *)v11 + v44);
        v20 = (float32x2_t *)((char *)v20 + v43);
        --v7;
      }
      while (v7);
    }
  }
}

void PKCFieldUser::PKCFieldUser(PKCFieldUser *this, void *a2)
{
  _QWORD *v3;

  PKCField::PKCField((PKCField *)this);
  *v3 = &off_24C0E7E80;
  v3[31] = a2;
}

{
  _QWORD *v3;

  PKCField::PKCField((PKCField *)this);
  *v3 = &off_24C0E7E80;
  v3[31] = a2;
}

double PKCFieldUser::evalForce(float32x4_t *a1, float32x4_t a2, float32x4_t a3, float a4, float a5, double a6)
{
  double v6;
  float32x4_t v8;
  float32x4_t v9;
  float v11;
  float v12;
  _QWORD v13[11];
  double v14;
  int v15;
  uint64_t v16;
  __int32 v17;
  uint64_t v18;
  __int32 v19;
  uint64_t v20;

  v20 = *MEMORY[0x24BDAC8D0];
  v6 = 0.0;
  if (fabsf(a1[12].f32[1] * a1[12].f32[0]) >= 0.000030518)
  {
    v8 = vaddq_f32(vaddq_f32(vmulq_n_f32(a1[8], a2.f32[0]), vmulq_lane_f32(a1[9], *(float32x2_t *)a2.f32, 1)), vaddq_f32(vmulq_laneq_f32(a1[10], a2, 2), a1[11]));
    v18 = v8.i64[0];
    v19 = v8.i32[2];
    v13[0] = &v18;
    v13[1] = 0;
    v9 = vaddq_f32(vaddq_f32(vmulq_n_f32(a1[4], a3.f32[0]), vmulq_lane_f32(a1[5], *(float32x2_t *)a3.f32, 1)), vaddq_f32(vmulq_laneq_f32(a1[6], a3, 2), vmulq_f32(a1[7], (float32x4_t)0)));
    v17 = v9.i32[2];
    v16 = v9.i64[0];
    v13[2] = &v16;
    v13[3] = 0;
    v11 = a4;
    v12 = a5;
    v13[6] = &v12;
    v13[7] = 0;
    v13[4] = &v11;
    v13[5] = 0;
    *(double *)&v13[8] = a6;
    v15 = 0;
    v14 = 0.0;
    v13[9] = &v14;
    v13[10] = 0;
    PKPhysicsFieldUserInvokeBatchBlockWith(a1[15].i64[1]);
    PKPhysicsFieldUserInvokeBlockWith((void *)a1[15].i64[1], 1, (uint64_t)v13);
    return v14;
  }
  return v6;
}

void PKCFieldVelocity::PKCFieldVelocity(PKCFieldVelocity *this)
{
  int32x4_t *v1;

  PKCField::PKCField((PKCField *)this);
  v1->i64[0] = (uint64_t)&off_24C0E8450;
  v1[15].i64[1] = 0;
  v1[16].i64[0] = 0;
  v1[14] = vdupq_n_s32(0x7F7FFFFFu);
  v1[12].i32[3] = 0;
}

{
  int32x4_t *v1;

  PKCField::PKCField((PKCField *)this);
  v1->i64[0] = (uint64_t)&off_24C0E8450;
  v1[15].i64[1] = 0;
  v1[16].i64[0] = 0;
  v1[14] = vdupq_n_s32(0x7F7FFFFFu);
  v1[12].i32[3] = 0;
}

double PKCFieldVelocity::evalForce()
{
  return 0.0;
}

__n128 PKCFieldVelocity::evalVelocity(uint64_t a1, float32x4_t a2, float32x4_t a3)
{
  uint64_t v3;
  float32x4_t v4;
  int v6;
  int v7;
  int v8;
  int v15;
  int v16;
  BOOL v17;
  float32x4_t v18;
  __n128 result;

  v3 = *(_QWORD *)(a1 + 248);
  if (v3)
  {
    v4 = 0uLL;
    _D1 = vaddq_f32(vaddq_f32(vmulq_n_f32(*(float32x4_t *)(a1 + 64), a3.f32[0]), vmulq_lane_f32(*(float32x4_t *)(a1 + 80), *(float32x2_t *)a3.f32, 1)), vaddq_f32(vmulq_laneq_f32(*(float32x4_t *)(a1 + 96), a3, 2), vmulq_f32(*(float32x4_t *)(a1 + 112), (float32x4_t)0))).u64[0];
    v6 = *(_DWORD *)v3;
    v7 = *(_DWORD *)(v3 + 4);
    if (*(int *)v3 >= 0)
      v8 = *(_DWORD *)v3;
    else
      v8 = v6 + 1;
    _S4 = (float)v7;
    __asm { FMLA            S2, S4, V1.S[1] }
    v15 = (int)vmlas_n_f32((float)(v8 >> 1), (float)v6, *(float *)&_D1);
    v16 = (int)_S2;
    if ((((int)_S2 | v15) & 0x80000000) == 0)
    {
      v17 = v6 <= v15 || v7 <= v16;
      if (!v17 && *(int *)(v3 + 8) >= 1)
        v4 = *(float32x4_t *)(*(_QWORD *)(v3 + 64) + 16 * (v15 + v6 * v16));
    }
    v18 = vmulq_n_f32(vmulq_n_f32(vmulq_n_f32(v4, PKCField::calculatedFalloff((float32x4_t *)a1, a2)), *(float *)(a1 + 196)), *(float *)(a1 + 192));
    result.n128_u64[0] = (unint64_t)vmul_laneq_f32(*(float32x2_t *)v18.f32, v18, 3);
  }
  else
  {
    return *(__n128 *)(a1 + 224);
  }
  return result;
}

void PKCFieldVelocity::evalVelocityVec2(_DWORD *a1, _QWORD *a2, int a3, int a4, int a5)
{
  _BYTE *v8;
  _DWORD *v9;
  uint64_t v10;
  _BOOL4 v11;
  uint64_t v12;
  float32x2_t *v13;
  uint64_t v14;
  float32x2_t v15;
  const float *v16;
  BOOL v17;
  float32x2_t v18;
  float32x2_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  _BOOL4 v24;
  int v25;

  if (a4)
  {
    v8 = (_BYTE *)a2[25];
    v23 = a2[26];
    if (!a5)
    {
LABEL_3:
      v9 = 0;
      v22 = 0;
      goto LABEL_6;
    }
  }
  else
  {
    v8 = 0;
    v23 = 0;
    if (!a5)
      goto LABEL_3;
  }
  v9 = (_DWORD *)a2[17];
  v22 = a2[18];
LABEL_6:
  if (a3 >= 1)
  {
    v10 = 0;
    v11 = 0;
    v13 = (float32x2_t *)a2[29];
    v12 = a2[30];
    v14 = a2[2];
    v20 = a2[1];
    v21 = a2[5];
    v15 = (float32x2_t)a2[33];
    v16 = (const float *)(a2 + 34);
    v17 = 1;
    v18 = vld1_dup_f32(v16);
    do
    {
      if (a4)
        v11 = *v8 != 0;
      if (a5)
      {
        v17 = (a1[60] & *v9) != 0;
        v9 = (_DWORD *)((char *)v9 + v22);
      }
      if (!v11 && v17)
      {
        v24 = v11;
        v25 = a3;
        *(double *)&v19 = (*(double (**)(_DWORD *, double, double, float, float, double))(*(_QWORD *)a1 + 48))(a1, COERCE_DOUBLE(vmul_f32(v18, vadd_f32(v15, *(float32x2_t *)(v20 + v10)))), COERCE_DOUBLE(vmul_f32(v18, *(float32x2_t *)(v21 + v10))), 1.0, 0.0, 0.0);
        v11 = v24;
        a3 = v25;
        *v13 = vdiv_f32(v19, v18);
      }
      if (a4)
      {
        *v8 = 1;
        v8 += v23;
      }
      v13 = (float32x2_t *)((char *)v13 + v12);
      v10 += v14;
      --a3;
    }
    while (a3);
  }
}

_QWORD *PKCFieldVelocity::setGrid(uint64_t a1, uint64_t *a2)
{
  return std::shared_ptr<PKPath>::operator=[abi:ne180100]((_QWORD *)(a1 + 248), a2);
}

void PKCAether::PKCAether(PKCAether *this)
{
  *((_QWORD *)this + 4) = 0;
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
}

{
  *((_QWORD *)this + 4) = 0;
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
}

void PKCAether::~PKCAether(PKCAether *this)
{
  void **v1;

  v1 = (void **)((char *)this + 16);
  std::vector<std::weak_ptr<PKCField>>::__destroy_vector::operator()[abi:ne180100](&v1);
}

{
  void **v1;

  v1 = (void **)((char *)this + 16);
  std::vector<std::weak_ptr<PKCField>>::__destroy_vector::operator()[abi:ne180100](&v1);
}

PKCAether::Evaluator *PKCAether::Evaluator::Evaluator(PKCAether::Evaluator *this, uint64_t **a2)
{
  __int128 v3;
  char **v5;
  unint64_t v6;
  uint64_t *v7;
  uint64_t *v8;
  std::__shared_weak_count *v9;
  uint64_t v10;
  unint64_t *p_shared_weak_owners;
  unint64_t v12;
  std::__shared_weak_count *v13;
  unint64_t *p_shared_owners;
  unint64_t v15;
  uint64_t *v16;
  uint64_t *v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t *v20;
  unint64_t v21;
  unint64_t v22;
  _QWORD *v23;
  _QWORD *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  unint64_t v28;
  char *v29;
  char *v30;
  char *v31;
  char *v32;
  uint64_t v33;
  std::__shared_weak_count *v34;
  unint64_t *v35;
  unint64_t v36;
  __int128 v38;

  v3 = 0uLL;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *(_OWORD *)this = 0u;
  if (!a2)
    goto LABEL_46;
  v5 = (char **)((char *)this + 24);
  v6 = PKCAether::fieldCount((PKCAether *)a2);
  std::vector<PKPoint>::reserve((void **)this + 3, v6);
  v7 = a2[2];
  v8 = a2[3];
  while (v7 != v8)
  {
    v9 = (std::__shared_weak_count *)v7[1];
    if (!v9)
      goto LABEL_18;
    v10 = *v7;
    p_shared_weak_owners = (unint64_t *)&v9->__shared_weak_owners_;
    do
      v12 = __ldxr(p_shared_weak_owners);
    while (__stxr(v12 + 1, p_shared_weak_owners));
    *(_QWORD *)&v38 = 0;
    v13 = std::__shared_weak_count::lock(v9);
    *((_QWORD *)&v38 + 1) = v13;
    if (v13)
    {
      *(_QWORD *)&v38 = v10;
      if (!v10)
        goto LABEL_12;
LABEL_11:
      std::vector<std::shared_ptr<PKCField>>::push_back[abi:ne180100]((char **)this, &v38);
      v13 = (std::__shared_weak_count *)*((_QWORD *)&v38 + 1);
      goto LABEL_12;
    }
    if ((_QWORD)v38)
      goto LABEL_11;
LABEL_12:
    if (v13)
    {
      p_shared_owners = (unint64_t *)&v13->__shared_owners_;
      do
        v15 = __ldaxr(p_shared_owners);
      while (__stlxr(v15 - 1, p_shared_owners));
      if (!v15)
      {
        ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
        std::__shared_weak_count::__release_weak(v13);
      }
    }
    std::__shared_weak_count::__release_weak(v9);
LABEL_18:
    v7 += 2;
  }
  v16 = *(uint64_t **)this;
  v17 = (uint64_t *)*((_QWORD *)this + 1);
  if (*(uint64_t **)this != v17)
  {
    do
    {
      v19 = *v16;
      v18 = v16[1];
      *(_QWORD *)&v38 = *v16;
      *((_QWORD *)&v38 + 1) = v18;
      if (v18)
      {
        v20 = (unint64_t *)(v18 + 8);
        do
          v21 = __ldxr(v20);
        while (__stxr(v21 + 1, v20));
      }
      v23 = (_QWORD *)*((_QWORD *)this + 4);
      v22 = *((_QWORD *)this + 5);
      if ((unint64_t)v23 >= v22)
      {
        v25 = ((char *)v23 - *v5) >> 3;
        if ((unint64_t)(v25 + 1) >> 61)
          std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
        v26 = v22 - (_QWORD)*v5;
        v27 = v26 >> 2;
        if (v26 >> 2 <= (unint64_t)(v25 + 1))
          v27 = v25 + 1;
        if ((unint64_t)v26 >= 0x7FFFFFFFFFFFFFF8)
          v28 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v28 = v27;
        if (v28)
          v29 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKPoint>>((uint64_t)this + 40, v28);
        else
          v29 = 0;
        v30 = &v29[8 * v25];
        *(_QWORD *)v30 = v19;
        v24 = v30 + 8;
        v32 = (char *)*((_QWORD *)this + 3);
        v31 = (char *)*((_QWORD *)this + 4);
        if (v31 != v32)
        {
          do
          {
            v33 = *((_QWORD *)v31 - 1);
            v31 -= 8;
            *((_QWORD *)v30 - 1) = v33;
            v30 -= 8;
          }
          while (v31 != v32);
          v31 = *v5;
        }
        *((_QWORD *)this + 3) = v30;
        *((_QWORD *)this + 4) = v24;
        *((_QWORD *)this + 5) = &v29[8 * v28];
        if (v31)
          operator delete(v31);
      }
      else
      {
        *v23 = v19;
        v24 = v23 + 1;
      }
      *((_QWORD *)this + 4) = v24;
      v34 = (std::__shared_weak_count *)*((_QWORD *)&v38 + 1);
      if (*((_QWORD *)&v38 + 1))
      {
        v35 = (unint64_t *)(*((_QWORD *)&v38 + 1) + 8);
        do
          v36 = __ldaxr(v35);
        while (__stlxr(v36 - 1, v35));
        if (!v36)
        {
          ((void (*)(std::__shared_weak_count *))v34->__on_zero_shared)(v34);
          std::__shared_weak_count::__release_weak(v34);
        }
      }
      v16 += 2;
    }
    while (v16 != v17);
  }
  v3 = *(_OWORD *)a2;
LABEL_46:
  *((_OWORD *)this + 3) = v3;
  return this;
}

void sub_208FB4278(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  uint64_t v9;
  void **v10;
  void *v12;

  v12 = *v10;
  if (*v10)
  {
    *(_QWORD *)(v9 + 32) = v12;
    operator delete(v12);
  }
  a9 = (void **)v9;
  std::vector<std::shared_ptr<PKCField>>::__destroy_vector::operator()[abi:ne180100](&a9);
  _Unwind_Resume(a1);
}

uint64_t PKCAether::fieldCount(PKCAether *this)
{
  uint64_t v1;
  __int128 *v2;
  uint64_t v4;
  __int128 *v5;
  __int128 *v6;
  std::__shared_weak_count *v7;
  char v9;

  v1 = *((_QWORD *)this + 2);
  v2 = (__int128 *)*((_QWORD *)this + 3);
  if ((__int128 *)v1 == v2)
  {
    v2 = (__int128 *)*((_QWORD *)this + 2);
  }
  else
  {
    do
    {
      v4 = *(_QWORD *)(v1 + 8);
      if (!v4 || *(_QWORD *)(v4 + 8) == -1)
      {
        std::__move_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<std::weak_ptr<PKCField> *,std::weak_ptr<PKCField> *,std::weak_ptr<PKCField> *>((uint64_t)&v9, (__int128 *)(v1 + 16), v2, v1);
        v2 = v5;
        v6 = (__int128 *)*((_QWORD *)this + 3);
        if (v6 != v5)
        {
          do
          {
            v7 = (std::__shared_weak_count *)*((_QWORD *)v6 - 1);
            if (v7)
              std::__shared_weak_count::__release_weak(v7);
            --v6;
          }
          while (v6 != v2);
        }
        *((_QWORD *)this + 3) = v2;
      }
      else
      {
        v1 += 16;
      }
    }
    while ((__int128 *)v1 != v2);
    v1 = *((_QWORD *)this + 2);
  }
  return ((uint64_t)v2 - v1) >> 4;
}

uint64_t std::vector<std::shared_ptr<PKCField>>::push_back[abi:ne180100](char **a1, __int128 *a2)
{
  uint64_t result;
  unint64_t v5;
  unint64_t v6;
  char *v7;
  uint64_t v8;
  unint64_t *v9;
  unint64_t v10;
  char *v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  unint64_t v15;
  char *v16;
  uint64_t v17;
  char *v18;
  __int128 v19;
  unint64_t *v20;
  unint64_t v21;
  char *v22;
  char *v23;
  char *v24;
  __int128 v25;
  int64x2_t v26;
  char *v27;
  uint64_t v28;
  int64x2_t v29;
  char *v30;
  uint64_t v31;

  v6 = (unint64_t)a1[2];
  result = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(char **)(result - 8);
  if ((unint64_t)v7 >= v6)
  {
    v12 = (v7 - *a1) >> 4;
    v13 = v12 + 1;
    if ((unint64_t)(v12 + 1) >> 60)
      std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
    v14 = v5 - (_QWORD)*a1;
    if (v14 >> 3 > v13)
      v13 = v14 >> 3;
    if ((unint64_t)v14 >= 0x7FFFFFFFFFFFFFF0)
      v15 = 0xFFFFFFFFFFFFFFFLL;
    else
      v15 = v13;
    v31 = result;
    v16 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKDebugDrawPacket::color4>>(result, v15);
    v18 = &v16[16 * v12];
    v19 = *a2;
    *(_OWORD *)v18 = *a2;
    if (*((_QWORD *)&v19 + 1))
    {
      v20 = (unint64_t *)(*((_QWORD *)&v19 + 1) + 8);
      do
        v21 = __ldxr(v20);
      while (__stxr(v21 + 1, v20));
    }
    v23 = *a1;
    v22 = a1[1];
    if (v22 == *a1)
    {
      v26 = vdupq_n_s64((unint64_t)v22);
      v24 = &v16[16 * v12];
    }
    else
    {
      v24 = &v16[16 * v12];
      do
      {
        v25 = *((_OWORD *)v22 - 1);
        v22 -= 16;
        *((_OWORD *)v24 - 1) = v25;
        v24 -= 16;
        *(_QWORD *)v22 = 0;
        *((_QWORD *)v22 + 1) = 0;
      }
      while (v22 != v23);
      v26 = *(int64x2_t *)a1;
    }
    v11 = v18 + 16;
    *a1 = v24;
    a1[1] = v18 + 16;
    v29 = v26;
    v27 = a1[2];
    a1[2] = &v16[16 * v17];
    v30 = v27;
    v28 = v26.i64[0];
    result = std::__split_buffer<std::shared_ptr<PKCField>>::~__split_buffer((uint64_t)&v28);
  }
  else
  {
    *(_QWORD *)v7 = *(_QWORD *)a2;
    v8 = *((_QWORD *)a2 + 1);
    *((_QWORD *)v7 + 1) = v8;
    if (v8)
    {
      v9 = (unint64_t *)(v8 + 8);
      do
        v10 = __ldxr(v9);
      while (__stxr(v10 + 1, v9));
    }
    v11 = v7 + 16;
  }
  a1[1] = v11;
  return result;
}

uint64_t PKCAether::Evaluator::evalVelocity(uint64_t result, int a2, float32x4_t a3, __n128 a4, float a5, float a6, double a7)
{
  uint64_t *v7;
  uint64_t *v8;
  uint64_t v13;
  uint64_t v14;
  uint64_t *v15;
  uint64_t *v16;
  float32x4_t v19;

  v19 = a3;
  v7 = *(uint64_t **)(result + 24);
  v8 = *(uint64_t **)(result + 32);
  if (v7 != v8)
  {
    v13 = result;
    do
    {
      v14 = *v7;
      if (*(_BYTE *)(*v7 + 244))
      {
        result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v14 + 56))(*v7);
        if ((_DWORD)result)
        {
          if ((*(_DWORD *)(v14 + 240) & a2) != 0)
          {
            if (*(_BYTE *)(v14 + 200))
            {
              result = PKCField::contains(v14, &v19);
              if ((result & 1) != 0)
                return (*(uint64_t (**)(uint64_t, float32x4_t, __n128, float, float, double))(*(_QWORD *)v14 + 48))(v14, a3, a4, a5, a6, a7);
            }
          }
        }
      }
      ++v7;
    }
    while (v7 != v8);
    v16 = *(uint64_t **)(v13 + 24);
    v15 = *(uint64_t **)(v13 + 32);
    while (v16 != v15)
    {
      v14 = *v16;
      if (*(_BYTE *)(*v16 + 244))
      {
        result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v14 + 56))(*v16);
        if ((_DWORD)result)
        {
          if ((*(_DWORD *)(v14 + 240) & a2) != 0)
          {
            result = PKCField::contains(v14, &v19);
            if ((result & 1) != 0)
              return (*(uint64_t (**)(uint64_t, float32x4_t, __n128, float, float, double))(*(_QWORD *)v14 + 48))(v14, a3, a4, a5, a6, a7);
          }
        }
      }
      ++v16;
    }
  }
  return result;
}

void PKCAether::Evaluator::evalForce(float32x4_t *a1, int a2, float a3, float32x4_t a4, __n128 a5, double a6, float a7, double a8)
{
  uint64_t *v12;
  uint64_t *v13;
  uint64_t v14;
  uint64_t *v15;
  _DWORD *v16;
  float32x4_t v17;
  __n128 v20;
  float32x4_t v22;
  float32x4_t v23;

  v20.n128_f64[0] = a6;
  v23 = a4;
  v12 = (uint64_t *)a1[1].i64[1];
  v13 = (uint64_t *)a1[2].i64[0];
  if (v12 == v13)
  {
    v15 = (uint64_t *)a1[1].i64[1];
LABEL_10:
    v22 = vmulq_n_f32(vmulq_n_f32(a1[3], v20.n128_f32[0]), a3);
    while (v15 != v12)
    {
      v16 = (_DWORD *)*v15;
      if (*(_BYTE *)(*v15 + 244)
        && ((*(uint64_t (**)(uint64_t))(*(_QWORD *)v16 + 56))(*v15) & 1) == 0
        && (v16[60] & a2) != 0)
      {
        if (PKCField::contains((uint64_t)v16, &v23))
        {
          *(double *)v17.i64 = (*(double (**)(_DWORD *, float32x4_t, __n128, __n128, float, double))(*(_QWORD *)v16 + 40))(v16, a4, a5, v20, a7, a8);
          v22 = vaddq_f32(v22, v17);
        }
      }
      ++v15;
    }
  }
  else
  {
    while (1)
    {
      v14 = *v12;
      if (*(_BYTE *)(*v12 + 244))
      {
        if (((*(uint64_t (**)(uint64_t))(*(_QWORD *)v14 + 56))(*v12) & 1) == 0
          && (*(_DWORD *)(v14 + 240) & a2) != 0
          && *(_BYTE *)(v14 + 200)
          && (PKCField::contains(v14, &v23) & 1) != 0)
        {
          break;
        }
      }
      if (++v12 == v13)
      {
        v15 = (uint64_t *)a1[1].i64[1];
        v12 = (uint64_t *)a1[2].i64[0];
        goto LABEL_10;
      }
    }
    (*(void (**)(uint64_t, float32x4_t, __n128, __n128, float, double))(*(_QWORD *)v14 + 40))(v14, a4, a5, v20, a7, a8);
  }
}

void PKCAether::Evaluator::evalFieldsVec2(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v5;
  int v6;
  uint64_t *v7;
  uint64_t *i;
  uint64_t v9;
  void *v10;
  void *v11;
  int v12;
  void *v13;
  int v14;
  int v15;
  char *v16;
  _QWORD *v17;
  uint64_t v18;
  unint64_t v19;
  unint64_t v20;
  char *v21;
  char *v22;
  char *v23;
  uint64_t v24;
  unint64_t v25;
  unint64_t v26;
  char *v27;
  uint64_t v28;
  unint64_t v29;
  unint64_t v30;
  char *v31;
  _QWORD *v32;
  char *v33;
  char *v34;
  char *v35;
  uint64_t v36;
  uint64_t v37;
  unint64_t v38;
  char *v39;
  char *v40;
  uint64_t v41;
  char *v42;
  char *v43;
  char *v44;
  uint64_t v45;
  char *v46;
  uint64_t v47;
  uint64_t v48;
  _QWORD *v49;
  int v50;
  _QWORD *v51;
  _QWORD *v52;
  uint64_t v53;
  _BYTE *v54;
  int v55;
  char *v56;
  char *v57;
  char *v58;
  char *v59;
  char *v60;
  char *v61;
  void *__p;
  char *v63;
  char *v64;
  void *v65;
  _QWORD *v66;
  char *v67;

  v5 = *(unsigned __int8 *)(a2 + 152);
  if (*(_BYTE *)(a2 + 152))
  {
    v6 = *(_DWORD *)(a2 + 128);
    if (!v6)
      return;
  }
  else
  {
    v6 = -1;
  }
  v65 = 0;
  v66 = 0;
  v67 = 0;
  __p = 0;
  v63 = 0;
  v64 = 0;
  v59 = 0;
  v60 = 0;
  v61 = 0;
  v7 = *(uint64_t **)(a1 + 24);
  for (i = *(uint64_t **)(a1 + 32); v7 != i; ++v7)
  {
    v9 = *v7;
    if (!*(_BYTE *)(*v7 + 244))
      continue;
    if ((*(_DWORD *)(v9 + 240) & v6) == 0)
      continue;
    v10 = **(void ***)(v9 + 8);
    if (v10)
    {
      if ((objc_msgSend(v10, "isEmpty") & 1) != 0)
        continue;
    }
    if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v9 + 56))(v9))
    {
      v11 = **(void ***)(v9 + 8);
      if (*(_BYTE *)(v9 + 200))
      {
        if (v11)
        {
          v12 = objc_msgSend(v11, "isInfinite") ^ 1;
          if (!v5)
            goto LABEL_26;
        }
        else
        {
          v12 = 0;
          if (!v5)
            goto LABEL_26;
        }
        if (!v12)
          break;
LABEL_26:
        v17 = v66;
        if (v66 < (_QWORD *)v67)
          goto LABEL_58;
        v18 = ((char *)v66 - (_BYTE *)v65) >> 3;
        if ((unint64_t)(v18 + 1) >> 61)
          goto LABEL_120;
        v19 = (v67 - (_BYTE *)v65) >> 2;
        if (v19 <= v18 + 1)
          v19 = v18 + 1;
        if ((unint64_t)(v67 - (_BYTE *)v65) >= 0x7FFFFFFFFFFFFFF8)
          v20 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v20 = v19;
        if (v20)
          v21 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKPoint>>((uint64_t)&v67, v20);
        else
          v21 = 0;
        v33 = &v21[8 * v18];
        *(_QWORD *)v33 = v9;
        v32 = v33 + 8;
        v35 = (char *)v65;
        v34 = (char *)v66;
        if (v66 != v65)
        {
          do
          {
            v36 = *((_QWORD *)v34 - 1);
            v34 -= 8;
            *((_QWORD *)v33 - 1) = v36;
            v33 -= 8;
          }
          while (v34 != v35);
          goto LABEL_88;
        }
        goto LABEL_89;
      }
      if (v11)
      {
        v15 = objc_msgSend(v11, "isInfinite") ^ 1;
        if (!v5)
          goto LABEL_57;
      }
      else
      {
        v15 = 0;
        if (!v5)
          goto LABEL_57;
      }
      if (v15)
      {
LABEL_57:
        v17 = v66;
        if (v66 < (_QWORD *)v67)
        {
LABEL_58:
          *v17 = v9;
          v32 = v17 + 1;
LABEL_91:
          v66 = v32;
          continue;
        }
        v37 = ((char *)v66 - (_BYTE *)v65) >> 3;
        if ((unint64_t)(v37 + 1) >> 61)
LABEL_120:
          std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
        v38 = (v67 - (_BYTE *)v65) >> 2;
        if (v38 <= v37 + 1)
          v38 = v37 + 1;
        if ((unint64_t)(v67 - (_BYTE *)v65) >= 0x7FFFFFFFFFFFFFF8)
          v20 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v20 = v38;
        if (v20)
          v21 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKPoint>>((uint64_t)&v67, v20);
        else
          v21 = 0;
        v33 = &v21[8 * v37];
        *(_QWORD *)v33 = v9;
        v32 = v33 + 8;
        v46 = (char *)v65;
        v34 = (char *)v66;
        if (v66 != v65)
        {
          do
          {
            v47 = *((_QWORD *)v34 - 1);
            v34 -= 8;
            *((_QWORD *)v33 - 1) = v47;
            v33 -= 8;
          }
          while (v34 != v46);
LABEL_88:
          v34 = (char *)v65;
        }
LABEL_89:
        v65 = v33;
        v66 = v32;
        v67 = &v21[8 * v20];
        if (v34)
          operator delete(v34);
        goto LABEL_91;
      }
    }
    else if (*(_BYTE *)(v9 + 200))
    {
      v13 = **(void ***)(v9 + 8);
      if (v13)
      {
        v14 = objc_msgSend(v13, "isInfinite") ^ 1;
        if (!v5)
          goto LABEL_37;
      }
      else
      {
        v14 = 0;
        if (!v5)
          goto LABEL_37;
      }
      if (v14)
      {
LABEL_37:
        v22 = v63;
        if (v63 >= v64)
        {
          v28 = (v63 - (_BYTE *)__p) >> 3;
          if ((unint64_t)(v28 + 1) >> 61)
            goto LABEL_120;
          v29 = (v64 - (_BYTE *)__p) >> 2;
          if (v29 <= v28 + 1)
            v29 = v28 + 1;
          if ((unint64_t)(v64 - (_BYTE *)__p) >= 0x7FFFFFFFFFFFFFF8)
            v30 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v30 = v29;
          if (v30)
            v31 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKPoint>>((uint64_t)&v64, v30);
          else
            v31 = 0;
          v42 = &v31[8 * v28];
          *(_QWORD *)v42 = v9;
          v23 = v42 + 8;
          v44 = (char *)__p;
          v43 = v63;
          if (v63 != __p)
          {
            do
            {
              v45 = *((_QWORD *)v43 - 1);
              v43 -= 8;
              *((_QWORD *)v42 - 1) = v45;
              v42 -= 8;
            }
            while (v43 != v44);
            v43 = (char *)__p;
          }
          __p = v42;
          v63 = v23;
          v64 = &v31[8 * v30];
          if (v43)
            operator delete(v43);
        }
        else
        {
          *(_QWORD *)v63 = v9;
          v23 = v22 + 8;
        }
        v63 = v23;
      }
    }
    else
    {
      if (v60 >= v61)
      {
        v24 = (v60 - v59) >> 3;
        if ((unint64_t)(v24 + 1) >> 61)
          goto LABEL_120;
        v25 = (v61 - v59) >> 2;
        if (v25 <= v24 + 1)
          v25 = v24 + 1;
        if ((unint64_t)(v61 - v59) >= 0x7FFFFFFFFFFFFFF8)
          v26 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v26 = v25;
        if (v26)
          v27 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKPoint>>((uint64_t)&v61, v26);
        else
          v27 = 0;
        v39 = &v27[8 * v24];
        *(_QWORD *)v39 = v9;
        v16 = v39 + 8;
        v40 = v60;
        if (v60 != v59)
        {
          do
          {
            v41 = *((_QWORD *)v40 - 1);
            v40 -= 8;
            *((_QWORD *)v39 - 1) = v41;
            v39 -= 8;
          }
          while (v40 != v59);
          v40 = v59;
        }
        v59 = v39;
        v61 = &v27[8 * v26];
        if (v40)
          operator delete(v40);
      }
      else
      {
        *(_QWORD *)v60 = v9;
        v16 = v60 + 8;
      }
      v60 = v16;
    }
  }
  if ((int)a3 >= 1)
  {
    v49 = *(_QWORD **)(a2 + 168);
    v48 = *(_QWORD *)(a2 + 176);
    v50 = a3;
    do
    {
      *v49 = 0;
      v49 = (_QWORD *)((char *)v49 + v48);
      --v50;
    }
    while (v50);
  }
  v52 = v65;
  v51 = v66;
  if (v65 == v66 && __p == v63)
  {
    v58 = v59;
    if (v59 == v60)
      goto LABEL_110;
    do
    {
      (*(void (**)(_QWORD, uint64_t, uint64_t, _QWORD, BOOL))(**(_QWORD **)v58 + 24))(*(_QWORD *)v58, a2, a3, 0, v5 == 0);
      v58 += 8;
    }
    while (v58 != v60);
  }
  else
  {
    if ((int)a3 >= 1)
    {
      v54 = *(_BYTE **)(a2 + 200);
      v53 = *(_QWORD *)(a2 + 208);
      v55 = a3;
      do
      {
        *v54 = 0;
        v54 += v53;
        --v55;
      }
      while (v55);
      v52 = v65;
    }
    while (v52 != v51)
    {
      (*(void (**)(_QWORD, uint64_t, uint64_t, uint64_t, BOOL))(*(_QWORD *)*v52 + 32))(*v52, a2, a3, 1, v5 == 0);
      ++v52;
    }
    v56 = (char *)__p;
    v57 = v63;
    while (v56 != v57)
    {
      (*(void (**)(_QWORD, uint64_t, uint64_t, uint64_t, BOOL))(**(_QWORD **)v56 + 24))(*(_QWORD *)v56, a2, a3, 1, v5 == 0);
      v56 += 8;
    }
    v58 = v59;
    if (v59 == v60)
      goto LABEL_110;
    do
    {
      (*(void (**)(_QWORD, uint64_t, uint64_t, uint64_t, BOOL))(**(_QWORD **)v58 + 24))(*(_QWORD *)v58, a2, a3, 1, v5 == 0);
      v58 += 8;
    }
    while (v58 != v60);
  }
  v58 = v59;
LABEL_110:
  if (v58)
    operator delete(v58);
  if (__p)
  {
    v63 = (char *)__p;
    operator delete(__p);
  }
  if (v65)
  {
    v66 = v65;
    operator delete(v65);
  }
}

void sub_208FB4D0C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19)
{
  if (__p)
    operator delete(__p);
  if (a15)
    operator delete(a15);
  if (a18)
    operator delete(a18);
  _Unwind_Resume(exception_object);
}

void PKCAether::addField(uint64_t a1, __int128 *a2)
{
  std::__shared_weak_count *v4;
  uint64_t *v5;
  uint64_t *v6;
  uint64_t *v7;
  std::__shared_weak_count *v8;
  uint64_t v9;
  unint64_t *p_shared_weak_owners;
  unint64_t v11;
  std::__shared_weak_count *v12;
  std::__shared_weak_count *v13;
  unint64_t *p_shared_owners;
  unint64_t v15;
  unint64_t *v16;
  unint64_t v17;
  uint64_t v18;
  std::__shared_weak_count *v19;

  v18 = 0;
  v19 = 0;
  v4 = (std::__shared_weak_count *)*((_QWORD *)a2 + 1);
  if (v4)
  {
    v19 = std::__shared_weak_count::lock(v4);
    if (v19)
      v18 = *(_QWORD *)a2;
  }
  v6 = *(uint64_t **)(a1 + 16);
  v7 = *(uint64_t **)(a1 + 24);
  v5 = (uint64_t *)(a1 + 16);
  while (v6 != v7)
  {
    v8 = (std::__shared_weak_count *)v6[1];
    if (v8)
    {
      v9 = *v6;
      p_shared_weak_owners = (unint64_t *)&v8->__shared_weak_owners_;
      do
        v11 = __ldxr(p_shared_weak_owners);
      while (__stxr(v11 + 1, p_shared_weak_owners));
      v12 = std::__shared_weak_count::lock(v8);
      if (v12)
      {
        v13 = v12;
        p_shared_owners = (unint64_t *)&v12->__shared_owners_;
        do
          v15 = __ldaxr(p_shared_owners);
        while (__stlxr(v15 - 1, p_shared_owners));
        if (!v15)
        {
          ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
          std::__shared_weak_count::__release_weak(v13);
        }
        std::__shared_weak_count::__release_weak(v8);
        if (v9 == v18)
          goto LABEL_21;
      }
      else
      {
        std::__shared_weak_count::__release_weak(v8);
        if (!v18)
          goto LABEL_21;
      }
    }
    else if (!v18)
    {
      goto LABEL_21;
    }
    v6 += 2;
  }
  std::vector<std::weak_ptr<PKCField>>::push_back[abi:ne180100](v5, a2);
LABEL_21:
  if (v19)
  {
    v16 = (unint64_t *)&v19->__shared_owners_;
    do
      v17 = __ldaxr(v16);
    while (__stlxr(v17 - 1, v16));
    if (!v17)
    {
      ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
      std::__shared_weak_count::__release_weak(v19);
    }
  }
}

void sub_208FB4EBC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<QuadTree>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void **std::vector<std::weak_ptr<PKCField>>::push_back[abi:ne180100](uint64_t *a1, __int128 *a2)
{
  void **result;
  unint64_t v5;
  unint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  unint64_t *v9;
  unint64_t v10;
  _QWORD *v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  unint64_t v15;
  char *v16;
  char *v17;
  uint64_t v18;
  __int128 v19;
  unint64_t *v20;
  unint64_t v21;
  void *v22[5];

  v6 = a1[2];
  result = (void **)(a1 + 2);
  v5 = v6;
  v7 = *(result - 1);
  if ((unint64_t)v7 >= v6)
  {
    v12 = ((uint64_t)v7 - *a1) >> 4;
    v13 = v12 + 1;
    if ((unint64_t)(v12 + 1) >> 60)
      std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
    v14 = v5 - *a1;
    if (v14 >> 3 > v13)
      v13 = v14 >> 3;
    if ((unint64_t)v14 >= 0x7FFFFFFFFFFFFFF0)
      v15 = 0xFFFFFFFFFFFFFFFLL;
    else
      v15 = v13;
    v22[4] = result;
    v16 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKDebugDrawPacket::color4>>((uint64_t)result, v15);
    v17 = &v16[16 * v12];
    v22[0] = v16;
    v22[1] = v17;
    v22[3] = &v16[16 * v18];
    v19 = *a2;
    *(_OWORD *)v17 = *a2;
    if (*((_QWORD *)&v19 + 1))
    {
      v20 = (unint64_t *)(*((_QWORD *)&v19 + 1) + 16);
      do
        v21 = __ldxr(v20);
      while (__stxr(v21 + 1, v20));
    }
    v22[2] = v17 + 16;
    std::vector<std::weak_ptr<PKCField>>::__swap_out_circular_buffer(a1, v22);
    v11 = (_QWORD *)a1[1];
    result = std::__split_buffer<std::weak_ptr<PKCField>>::~__split_buffer(v22);
  }
  else
  {
    *v7 = *(_QWORD *)a2;
    v8 = *((_QWORD *)a2 + 1);
    v7[1] = v8;
    if (v8)
    {
      v9 = (unint64_t *)(v8 + 16);
      do
        v10 = __ldxr(v9);
      while (__stxr(v10 + 1, v9));
    }
    v11 = v7 + 2;
    a1[1] = (uint64_t)(v7 + 2);
  }
  a1[1] = (uint64_t)v11;
  return result;
}

void sub_208FB4FE4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__split_buffer<std::weak_ptr<PKCField>>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

void PKCAether::removeField(uint64_t a1, uint64_t *a2)
{
  std::__shared_weak_count *v4;
  std::__shared_weak_count *v5;
  uint64_t v6;
  std::__shared_weak_count *v7;
  std::__shared_weak_count *v8;
  uint64_t v9;
  std::__shared_weak_count *v10;
  uint64_t v11;
  unint64_t *p_shared_owners;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t i;
  std::__shared_weak_count *v17;
  unint64_t *v18;
  unint64_t v19;
  uint64_t v20;
  std::__shared_weak_count *v21;
  char v22;

  PKCAether::fieldCount((PKCAether *)a1);
  v20 = 0;
  v21 = 0;
  v4 = (std::__shared_weak_count *)a2[1];
  if (v4)
  {
    v5 = std::__shared_weak_count::lock(v4);
    v21 = v5;
    if (v5)
      v20 = *a2;
  }
  else
  {
    v5 = 0;
  }
  v6 = *(_QWORD *)(a1 + 16);
  if (v6 != *(_QWORD *)(a1 + 24))
  {
    while (1)
    {
      v7 = *(std::__shared_weak_count **)(v6 + 8);
      if (!v7)
        break;
      v8 = std::__shared_weak_count::lock(v7);
      v9 = v20;
      if (!v8)
        goto LABEL_19;
      v10 = v8;
      v11 = *(_QWORD *)v6;
      p_shared_owners = (unint64_t *)&v8->__shared_owners_;
      do
        v13 = __ldaxr(p_shared_owners);
      while (__stlxr(v13 - 1, p_shared_owners));
      if (!v13)
      {
        ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
        std::__shared_weak_count::__release_weak(v10);
      }
      if (v11 == v20)
      {
LABEL_13:
        std::__move_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<std::weak_ptr<PKCField> *,std::weak_ptr<PKCField> *,std::weak_ptr<PKCField> *>((uint64_t)&v22, (__int128 *)(v6 + 16), *(__int128 **)(a1 + 24), v6);
        v15 = v14;
        for (i = *(_QWORD *)(a1 + 24); i != v15; i -= 16)
        {
          v17 = *(std::__shared_weak_count **)(i - 8);
          if (v17)
            std::__shared_weak_count::__release_weak(v17);
        }
        *(_QWORD *)(a1 + 24) = v15;
        goto LABEL_22;
      }
LABEL_20:
      v6 += 16;
      v15 = *(_QWORD *)(a1 + 24);
LABEL_22:
      if (v6 == v15)
      {
        v5 = v21;
        goto LABEL_24;
      }
    }
    v9 = v20;
LABEL_19:
    if (!v9)
      goto LABEL_13;
    goto LABEL_20;
  }
LABEL_24:
  if (v5)
  {
    v18 = (unint64_t *)&v5->__shared_owners_;
    do
      v19 = __ldaxr(v18);
    while (__stlxr(v19 - 1, v18));
    if (!v19)
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }
}

void sub_208FB5150(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::shared_ptr<QuadTree>::~shared_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void PKCAether::removeAllFields(PKCAether *this)
{
  std::vector<std::weak_ptr<PKCField>>::__clear[abi:ne180100]((uint64_t *)this + 2);
}

double PKCField::evalVelocity()
{
  return 0.0;
}

uint64_t PKCField::isVelocity(PKCField *this)
{
  return 0;
}

void PKCFieldLinearGravity::~PKCFieldLinearGravity(PKCField *this)
{
  PKCField::~PKCField(this);
  JUMPOUT(0x20BD0BA58);
}

uint64_t PKCFieldLinearGravity::type(PKCFieldLinearGravity *this)
{
  return 1;
}

void PKCFieldRadialGravity::~PKCFieldRadialGravity(PKCField *this)
{
  PKCField::~PKCField(this);
  JUMPOUT(0x20BD0BA58);
}

uint64_t PKCFieldRadialGravity::type(PKCFieldRadialGravity *this)
{
  return 2;
}

void PKCFieldSpring::~PKCFieldSpring(PKCField *this)
{
  PKCField::~PKCField(this);
  JUMPOUT(0x20BD0BA58);
}

uint64_t PKCFieldSpring::type(PKCFieldSpring *this)
{
  return 3;
}

void PKCFieldElectric::~PKCFieldElectric(PKCField *this)
{
  PKCField::~PKCField(this);
  JUMPOUT(0x20BD0BA58);
}

uint64_t PKCFieldElectric::type(PKCFieldElectric *this)
{
  return 5;
}

void PKCFieldMagnetic::~PKCFieldMagnetic(PKCField *this)
{
  PKCField::~PKCField(this);
  JUMPOUT(0x20BD0BA58);
}

uint64_t PKCFieldMagnetic::type(PKCFieldMagnetic *this)
{
  return 4;
}

void PKCFieldDrag::~PKCFieldDrag(PKCField *this)
{
  PKCField::~PKCField(this);
  JUMPOUT(0x20BD0BA58);
}

uint64_t PKCFieldDrag::type(PKCFieldDrag *this)
{
  return 6;
}

void PKCFieldVortex::~PKCFieldVortex(PKCField *this)
{
  PKCField::~PKCField(this);
  JUMPOUT(0x20BD0BA58);
}

uint64_t PKCFieldVortex::type(PKCFieldVortex *this)
{
  return 7;
}

void PKCFieldNoise::~PKCFieldNoise(PKCField *this)
{
  PKCField::~PKCField(this);
  JUMPOUT(0x20BD0BA58);
}

uint64_t PKCFieldNoise::type(PKCFieldNoise *this)
{
  return 10;
}

void PKCFieldTurbulence::~PKCFieldTurbulence(PKCField *this)
{
  PKCField::~PKCField(this);
  JUMPOUT(0x20BD0BA58);
}

uint64_t PKCFieldTurbulence::type(PKCFieldTurbulence *this)
{
  return 9;
}

void PKCFieldUser::~PKCFieldUser(PKCField *this)
{
  PKCField::~PKCField(this);
  JUMPOUT(0x20BD0BA58);
}

uint64_t PKCFieldUser::type(PKCFieldUser *this)
{
  return 11;
}

void PKCFieldVelocity::~PKCFieldVelocity(PKCField *this)
{
  *(_QWORD *)this = &off_24C0E8450;
  std::shared_ptr<QuadTree>::~shared_ptr[abi:ne180100]((uint64_t)this + 248);
  PKCField::~PKCField(this);
}

{
  *(_QWORD *)this = &off_24C0E8450;
  std::shared_ptr<QuadTree>::~shared_ptr[abi:ne180100]((uint64_t)this + 248);
  PKCField::~PKCField(this);
  JUMPOUT(0x20BD0BA58);
}

uint64_t PKCFieldVelocity::isVelocity(PKCFieldVelocity *this)
{
  return 1;
}

uint64_t PKCFieldVelocity::type(PKCFieldVelocity *this)
{
  return 8;
}

void std::vector<std::weak_ptr<PKCField>>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v2;

  v2 = *a1;
  if (*v2)
  {
    std::vector<std::weak_ptr<PKCField>>::__clear[abi:ne180100]((uint64_t *)v2);
    operator delete(**a1);
  }
}

void std::vector<std::weak_ptr<PKCField>>::__clear[abi:ne180100](uint64_t *a1)
{
  uint64_t v2;
  uint64_t i;
  std::__shared_weak_count *v4;

  v2 = *a1;
  for (i = a1[1]; i != v2; i -= 16)
  {
    v4 = *(std::__shared_weak_count **)(i - 8);
    if (v4)
      std::__shared_weak_count::__release_weak(v4);
  }
  a1[1] = v2;
}

uint64_t std::__split_buffer<std::shared_ptr<PKCField>>::~__split_buffer(uint64_t a1)
{
  uint64_t i;
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 8);
  for (i = *(_QWORD *)(a1 + 16); i != v3; i = *(_QWORD *)(a1 + 16))
  {
    *(_QWORD *)(a1 + 16) = i - 16;
    std::shared_ptr<QuadTree>::~shared_ptr[abi:ne180100](i - 16);
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

uint64_t std::vector<std::weak_ptr<PKCField>>::__swap_out_circular_buffer(uint64_t *a1, _QWORD *a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::weak_ptr<PKCField>>,std::reverse_iterator<std::weak_ptr<PKCField>*>,std::reverse_iterator<std::weak_ptr<PKCField>*>,std::reverse_iterator<std::weak_ptr<PKCField>*>>((uint64_t)(a1 + 2), a1[1], (_QWORD *)a1[1], *a1, (_QWORD *)*a1, a2[1], a2[1]);
  a2[1] = v5;
  v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::weak_ptr<PKCField>>,std::reverse_iterator<std::weak_ptr<PKCField>*>,std::reverse_iterator<std::weak_ptr<PKCField>*>,std::reverse_iterator<std::weak_ptr<PKCField>*>>(uint64_t a1, uint64_t a2, _QWORD *a3, uint64_t a4, _QWORD *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7;
  _OWORD *v8;
  __int128 v9;
  uint64_t v10;
  _QWORD v12[3];
  char v13;
  __int128 v14;
  __int128 v15;

  v7 = a7;
  *(_QWORD *)&v15 = a6;
  *((_QWORD *)&v15 + 1) = a7;
  v14 = v15;
  v12[0] = a1;
  v12[1] = &v14;
  v12[2] = &v15;
  if (a3 == a5)
  {
    v10 = a6;
  }
  else
  {
    v8 = (_OWORD *)(a7 - 16);
    do
    {
      v9 = *((_OWORD *)a3 - 1);
      a3 -= 2;
      *v8 = v9;
      *a3 = 0;
      a3[1] = 0;
      *((_QWORD *)&v15 + 1) = v8;
      v7 -= 16;
      --v8;
    }
    while (a3 != a5);
    v10 = v15;
  }
  v13 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::weak_ptr<PKCField>>,std::reverse_iterator<std::weak_ptr<PKCField>*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v12);
  return v10;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::weak_ptr<PKCField>>,std::reverse_iterator<std::weak_ptr<PKCField>*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24))
    std::_AllocatorDestroyRangeReverse<std::allocator<std::weak_ptr<PKCField>>,std::reverse_iterator<std::weak_ptr<PKCField>*>>::operator()[abi:ne180100](a1);
  return a1;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<std::weak_ptr<PKCField>>,std::reverse_iterator<std::weak_ptr<PKCField>*>>::operator()[abi:ne180100](uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  std::__shared_weak_count *v3;

  v1 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 8);
  v2 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8);
  while (v1 != v2)
  {
    v3 = *(std::__shared_weak_count **)(v1 + 8);
    if (v3)
      std::__shared_weak_count::__release_weak(v3);
    v1 += 16;
  }
}

void **std::__split_buffer<std::weak_ptr<PKCField>>::~__split_buffer(void **a1)
{
  std::__split_buffer<std::weak_ptr<PKCField>>::clear[abi:ne180100]((uint64_t)a1);
  if (*a1)
    operator delete(*a1);
  return a1;
}

void std::__split_buffer<std::weak_ptr<PKCField>>::clear[abi:ne180100](uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  std::__shared_weak_count *v4;

  v2 = *(_QWORD *)(a1 + 8);
  v1 = *(_QWORD *)(a1 + 16);
  while (v1 != v2)
  {
    *(_QWORD *)(a1 + 16) = v1 - 16;
    v4 = *(std::__shared_weak_count **)(v1 - 8);
    if (v4)
    {
      std::__shared_weak_count::__release_weak(v4);
      v1 = *(_QWORD *)(a1 + 16);
    }
    else
    {
      v1 -= 16;
    }
  }
}

__int128 *std::__move_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<std::weak_ptr<PKCField> *,std::weak_ptr<PKCField> *,std::weak_ptr<PKCField> *>(uint64_t a1, __int128 *a2, __int128 *a3, uint64_t a4)
{
  __int128 *v5;
  __int128 v7;
  std::__shared_weak_count *v8;

  v5 = a2;
  if (a2 != a3)
  {
    do
    {
      v7 = *v5;
      *(_QWORD *)v5 = 0;
      *((_QWORD *)v5 + 1) = 0;
      v8 = *(std::__shared_weak_count **)(a4 + 8);
      *(_OWORD *)a4 = v7;
      if (v8)
        std::__shared_weak_count::__release_weak(v8);
      ++v5;
      a4 += 16;
    }
    while (v5 != a3);
    return a3;
  }
  return v5;
}

void b2ChainShape::~b2ChainShape(b2ChainShape *this)
{
  void *v2;

  *(_QWORD *)this = &off_24C0E7ED8;
  v2 = (void *)*((_QWORD *)this + 2);
  *((_QWORD *)this + 3) = v2;
  if (v2)
    operator delete(v2);
}

{
  void *v2;

  *(_QWORD *)this = &off_24C0E7ED8;
  v2 = (void *)*((_QWORD *)this + 2);
  *((_QWORD *)this + 3) = v2;
  if (v2)
    operator delete(v2);
}

{
  void *v2;

  *(_QWORD *)this = &off_24C0E7ED8;
  v2 = (void *)*((_QWORD *)this + 2);
  *((_QWORD *)this + 3) = v2;
  if (v2)
    operator delete(v2);
  JUMPOUT(0x20BD0BA58);
}

void *b2ChainShape::CreateLoop(void **this, const b2Vec2 *a2, int a3)
{
  void *result;
  _QWORD *v7;

  std::vector<b2Vec2>::resize((uint64_t)(this + 2), a3 + 1);
  result = memcpy(this[2], a2, 8 * a3);
  *((_QWORD *)this[2] + a3) = *(_QWORD *)this[2];
  v7 = this[2];
  this[5] = (void *)v7[a3 - 1];
  this[6] = (void *)v7[1];
  *((_WORD *)this + 28) = 257;
  return result;
}

void *b2ChainShape::CreateChain(void **this, const b2Vec2 *a2, int a3)
{
  void *result;

  if (a3 <= 1)
    b2ChainShape::CreateChain();
  std::vector<b2Vec2>::resize((uint64_t)(this + 2), a3);
  result = memcpy(this[2], a2, 8 * a3);
  *((_WORD *)this + 28) = 0;
  return result;
}

uint64_t b2ChainShape::SetPrevVertex(uint64_t this, const b2Vec2 *a2)
{
  *(b2Vec2 *)(this + 40) = *a2;
  *(_BYTE *)(this + 56) = 1;
  return this;
}

uint64_t b2ChainShape::SetNextVertex(uint64_t this, const b2Vec2 *a2)
{
  *(b2Vec2 *)(this + 48) = *a2;
  *(_BYTE *)(this + 57) = 1;
  return this;
}

uint64_t b2ChainShape::Clone(b2ChainShape *this)
{
  uint64_t v2;

  v2 = operator new();
  *(_QWORD *)(v2 + 24) = 0;
  *(_QWORD *)(v2 + 32) = 0;
  *(_QWORD *)v2 = &off_24C0E7ED8;
  *(_QWORD *)(v2 + 8) = 0x3C1374BC00000003;
  *(_QWORD *)(v2 + 16) = 0;
  *(_WORD *)(v2 + 56) = 0;
  b2ChainShape::CreateChain((void **)v2, *((const b2Vec2 **)this + 2), (*((_QWORD *)this + 3) - *((_QWORD *)this + 2)) >> 3);
  *(_OWORD *)(v2 + 40) = *(_OWORD *)((char *)this + 40);
  *(_WORD *)(v2 + 56) = *((_WORD *)this + 28);
  return v2;
}

uint64_t b2ChainShape::GetChildCount(b2ChainShape *this)
{
  return ((*((_QWORD *)this + 3) - *((_QWORD *)this + 2)) >> 3) - 1;
}

uint64_t b2ChainShape::GetChildEdge(uint64_t this, b2EdgeShape *a2, signed int a3)
{
  uint64_t v3;
  char v4;
  uint64_t v5;
  char v6;

  if (a3 < 0 || (v3 = *(_QWORD *)(this + 16), (int)(((unint64_t)(*(_QWORD *)(this + 24) - v3) >> 3) - 1) <= a3))
    b2ChainShape::GetChildEdge();
  *((_DWORD *)a2 + 2) = 1;
  *((_DWORD *)a2 + 3) = *(_DWORD *)(this + 12);
  *((_QWORD *)a2 + 2) = *(_QWORD *)(v3 + 8 * a3);
  *((_QWORD *)a2 + 3) = *(_QWORD *)(*(_QWORD *)(this + 16) + 8 * (a3 + 1));
  if (a3)
  {
    *((_QWORD *)a2 + 4) = *(_QWORD *)(*(_QWORD *)(this + 16) + 8 * (a3 - 1));
    v4 = 1;
  }
  else
  {
    *((_QWORD *)a2 + 4) = *(_QWORD *)(this + 40);
    v4 = *(_BYTE *)(this + 56);
  }
  *((_BYTE *)a2 + 48) = v4;
  v5 = *(_QWORD *)(this + 16);
  if ((int)(((unint64_t)(*(_QWORD *)(this + 24) - v5) >> 3) - 2) <= a3)
  {
    *((_QWORD *)a2 + 5) = *(_QWORD *)(this + 48);
    v6 = *(_BYTE *)(this + 57);
  }
  else
  {
    *((_QWORD *)a2 + 5) = *(_QWORD *)(v5 + 8 * (a3 + 2));
    v6 = 1;
  }
  *((_BYTE *)a2 + 49) = v6;
  return this;
}

uint64_t b2ChainShape::TestPoint(b2ChainShape *this, const b2Transform *a2, const b2Vec2 *a3)
{
  return 0;
}

void b2ChainShape::ComputeDistance(b2ChainShape *this, const b2Transform *a2, float32x2_t *a3, float *a4, b2Vec2 *a5, signed int a6)
{
  _QWORD v10[6];
  __int16 v11;

  v10[0] = &off_24C0E7CC8;
  v10[1] = 0x3C1374BC00000001;
  v10[4] = 0;
  v10[5] = 0;
  v11 = 0;
  b2ChainShape::GetChildEdge((uint64_t)this, (b2EdgeShape *)v10, a6);
  b2EdgeShape::ComputeDistance((b2EdgeShape *)v10, a2, a3, a4, a5);
}

uint64_t b2ChainShape::RayCast(uint64_t a1, float *a2, float *a3, float *a4, int a5)
{
  uint64_t v5;
  unint64_t v6;
  int v7;
  _QWORD v9[6];
  __int16 v10;

  v5 = *(_QWORD *)(a1 + 16);
  v6 = (unint64_t)(*(_QWORD *)(a1 + 24) - v5) >> 3;
  if ((int)v6 <= a5)
    b2ChainShape::RayCast();
  v9[0] = &off_24C0E7CC8;
  v9[1] = 0x3C1374BC00000001;
  v9[4] = 0;
  v9[5] = 0;
  v10 = 0;
  if (a5 + 1 == (_DWORD)v6)
    v7 = 0;
  else
    v7 = a5 + 1;
  v9[2] = *(_QWORD *)(v5 + 8 * a5);
  v9[3] = *(_QWORD *)(v5 + 8 * v7);
  return b2EdgeShape::RayCast((float *)v9, a2, a3, a4);
}

uint64_t b2ChainShape::ComputeAABB(uint64_t result, float *a2, float *a3, int a4)
{
  uint64_t v4;
  unint64_t v5;
  int v6;
  float *v7;
  float v8;
  float v9;
  float v10;
  float v11;
  float v12;
  float v13;
  float *v14;
  float v15;
  float v16;
  float v17;
  float v18;
  float v19;
  float v20;
  float v21;

  v4 = *(_QWORD *)(result + 16);
  v5 = (unint64_t)(*(_QWORD *)(result + 24) - v4) >> 3;
  if ((int)v5 <= a4)
    b2ChainShape::ComputeAABB();
  if (a4 + 1 == (_DWORD)v5)
    v6 = 0;
  else
    v6 = a4 + 1;
  v7 = (float *)(v4 + 8 * a4);
  v9 = a3[2];
  v8 = a3[3];
  v10 = v7[1];
  v11 = a3[1];
  v12 = *a3 + (float)((float)(v8 * *v7) - (float)(v9 * v10));
  v13 = (float)((float)(v8 * v10) + (float)(v9 * *v7)) + v11;
  v14 = (float *)(v4 + 8 * v6);
  v15 = v14[1];
  v16 = (float)(v8 * *v14) - (float)(v9 * v15);
  v17 = *a3 + v16;
  v18 = v11 + (float)((float)(v8 * v15) + (float)(v9 * *v14));
  if (v12 >= v17)
    v19 = *a3 + v16;
  else
    v19 = v12;
  if (v12 <= v17)
    v20 = *a3 + v16;
  else
    v20 = v12;
  if (v13 >= v18)
    v21 = v18;
  else
    v21 = v13;
  *a2 = v19;
  a2[1] = v21;
  if (v13 > v18)
    v18 = v13;
  a2[2] = v20;
  a2[3] = v18;
  return result;
}

void b2ChainShape::ComputeMass(uint64_t a1, _QWORD *a2)
{
  *a2 = 0;
  a2[1] = 0;
}

__n128 b2CircleShape::Clone(b2CircleShape *this)
{
  uint64_t v2;
  __n128 result;

  v2 = operator new();
  *(_QWORD *)v2 = &off_24C0E8038;
  result = *(__n128 *)((char *)this + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

uint64_t b2CircleShape::GetChildCount(b2CircleShape *this)
{
  return 1;
}

BOOL b2CircleShape::TestPoint(b2CircleShape *this, const b2Transform *a2, const b2Vec2 *a3)
{
  float var1;
  float var0;
  float v5;
  float v6;

  var0 = a2->var1.var0;
  var1 = a2->var1.var1;
  v6 = *((float *)this + 4);
  v5 = *((float *)this + 5);
  return (float)((float)((float)(a3->y - (float)(a2->var0.y + (float)((float)(var1 * v5) + (float)(var0 * v6))))
                       * (float)(a3->y - (float)(a2->var0.y + (float)((float)(var1 * v5) + (float)(var0 * v6)))))
               + (float)((float)(a3->x - (float)(a2->var0.x + (float)((float)(var1 * v6) - (float)(var0 * v5))))
                       * (float)(a3->x - (float)(a2->var0.x + (float)((float)(var1 * v6) - (float)(var0 * v5)))))) <= (float)(*((float *)this + 3) * *((float *)this + 3));
}

float b2CircleShape::ComputeDistance(b2CircleShape *this, const b2Transform *a2, const b2Vec2 *a3, float *a4, b2Vec2 *a5)
{
  float var1;
  float var0;
  float v7;
  float v8;
  float v9;
  float v10;
  float v11;
  float v12;
  float v13;
  float v14;
  float result;

  var0 = a2->var1.var0;
  var1 = a2->var1.var1;
  v8 = *((float *)this + 4);
  v7 = *((float *)this + 5);
  v9 = (float)(var1 * v8) - (float)(var0 * v7);
  v10 = (float)(var1 * v7) + (float)(var0 * v8);
  v11 = a3->x - (float)(a2->var0.x + v9);
  v12 = a3->y - (float)(a2->var0.y + v10);
  v13 = sqrtf((float)(v12 * v12) + (float)(v11 * v11));
  *a4 = v13 - *((float *)this + 3);
  v14 = 1.0 / v13;
  result = v12 * v14;
  a5->x = v11 * v14;
  a5->y = result;
  return result;
}

uint64_t b2CircleShape::RayCast(float *a1, float *a2, float *a3, float *a4)
{
  float v4;
  float v5;
  float v6;
  float v7;
  float v8;
  float v9;
  float v10;
  float v11;
  float v12;
  float v13;
  float v14;
  float v15;
  float v16;
  float v17;
  float v19;
  float v20;
  float v22;
  float v23;
  float v24;
  float v25;
  float v26;

  v5 = a4[2];
  v4 = a4[3];
  v7 = a1[4];
  v6 = a1[5];
  v8 = (float)(v4 * v7) - (float)(v5 * v6);
  v9 = (float)(v4 * v6) + (float)(v5 * v7);
  v10 = a3[1];
  v11 = *a3 - (float)(*a4 + v8);
  v12 = v10 - (float)(a4[1] + v9);
  v13 = a3[2] - *a3;
  v14 = a3[3] - v10;
  v15 = (float)(v12 * v14) + (float)(v11 * v13);
  v16 = (float)(v14 * v14) + (float)(v13 * v13);
  v17 = (float)(v15 * v15)
      - (float)(v16 * (float)((float)((float)(v12 * v12) + (float)(v11 * v11)) - (float)(a1[3] * a1[3])));
  if (v17 < 0.0 || v16 < 0.00000011921)
    return 0;
  v19 = v15 + sqrtf(v17);
  if (v19 > 0.0)
    return 0;
  v20 = -v19;
  if ((float)(v16 * a3[4]) < v20)
    return 0;
  v22 = v20 / v16;
  v23 = v11 + (float)(v13 * v22);
  v24 = v12 + (float)(v14 * v22);
  *a2 = v23;
  a2[1] = v24;
  a2[2] = v22;
  v25 = sqrtf((float)(v24 * v24) + (float)(v23 * v23));
  if (v25 >= 0.00000011921)
  {
    v26 = 1.0 / v25;
    *a2 = v23 * v26;
    a2[1] = v24 * v26;
  }
  return 1;
}

BOOL b2CircleShape::isValidShape(b2CircleShape *this)
{
  return (float)(*((float *)this + 3) * *((float *)this + 3)) > 0.00000011921;
}

float b2CircleShape::ComputeAABB(float *a1, float *a2, float *a3)
{
  float v3;
  float v4;
  float v5;
  float v6;
  float v7;
  float v8;
  float v9;
  float v10;
  float v11;
  float result;

  v4 = a3[2];
  v3 = a3[3];
  v6 = a1[4];
  v5 = a1[5];
  v7 = a1[3];
  v8 = (float)(v3 * v6) - (float)(v4 * v5);
  v9 = (float)(v3 * v5) + (float)(v4 * v6);
  v10 = *a3 + v8;
  v11 = a3[1] + v9;
  *a2 = v10 - v7;
  a2[1] = v11 - v7;
  result = v11 + v7;
  a2[2] = v10 + v7;
  a2[3] = result;
  return result;
}

float b2CircleShape::ComputeMass(uint64_t a1, uint64_t a2, float a3)
{
  float v3;
  float result;

  v3 = *(float *)(a1 + 12) * (float)((float)(a3 * 3.1416) * *(float *)(a1 + 12));
  *(float *)a2 = v3;
  *(_QWORD *)(a2 + 4) = *(_QWORD *)(a1 + 16);
  result = v3
         * (float)((float)((float)(*(float *)(a1 + 20) * *(float *)(a1 + 20))
                         + (float)(*(float *)(a1 + 16) * *(float *)(a1 + 16)))
                 + (float)((float)(*(float *)(a1 + 12) * 0.5) * *(float *)(a1 + 12)));
  *(float *)(a2 + 12) = result;
  return result;
}

void b2CircleShape::~b2CircleShape(b2CircleShape *this)
{
  JUMPOUT(0x20BD0BA58);
}

uint64_t b2EdgeShape::Set(uint64_t this, const b2Vec2 *a2, const b2Vec2 *a3)
{
  *(b2Vec2 *)(this + 16) = *a2;
  *(b2Vec2 *)(this + 24) = *a3;
  *(_WORD *)(this + 48) = 0;
  return this;
}

__n128 b2EdgeShape::Clone(__n128 *this)
{
  uint64_t v2;
  unint64_t v3;
  __n128 result;
  __n128 v5;

  v2 = operator new();
  v3 = this->n128_u64[1];
  *(_QWORD *)v2 = &off_24C0E7CC8;
  *(_QWORD *)(v2 + 8) = v3;
  result = this[1];
  v5 = this[2];
  *(__n128 *)(v2 + 16) = result;
  *(__n128 *)(v2 + 32) = v5;
  *(_WORD *)(v2 + 48) = this[3].n128_u16[0];
  return result;
}

uint64_t b2EdgeShape::GetChildCount(b2EdgeShape *this)
{
  return 1;
}

uint64_t b2EdgeShape::TestPoint(b2EdgeShape *this, const b2Transform *a2, const b2Vec2 *a3)
{
  return 0;
}

void b2EdgeShape::ComputeDistance(b2EdgeShape *this, const b2Transform *a2, float32x2_t *a3, float *a4, b2Vec2 *a5)
{
  b2Rot var1;
  float32x2_t v6;
  float32x2_t v7;
  float32x2_t v8;
  float32x2_t v9;
  float32x2_t v10;
  float v11;
  float v12;
  float v13;
  b2Vec2 v14;
  unsigned __int8 v15;
  int v16;
  b2Vec2 *v17;

  var1 = a2->var1;
  v6 = (float32x2_t)vrev64_s32((int32x2_t)var1);
  var1.var0 = -var1.var0;
  v7 = vadd_f32((float32x2_t)a2->var0, vmla_n_f32(vmul_n_f32((float32x2_t)var1, *((float *)this + 5)), v6, *((float *)this + 4)));
  v8 = vadd_f32((float32x2_t)a2->var0, vmla_n_f32(vmul_n_f32((float32x2_t)var1, *((float *)this + 7)), v6, *((float *)this + 6)));
  v9 = vsub_f32(*a3, v7);
  v10 = vsub_f32(v8, v7);
  v11 = vmlas_n_f32(COERCE_FLOAT(vmul_f32(v9, v10).i32[1]), v10.f32[0], v9.f32[0]);
  if (v11 > 0.0)
  {
    v12 = vmuls_lane_f32(v10.f32[1], v10, 1) + (float)(v10.f32[0] * v10.f32[0]);
    if (v11 <= v12)
      v9 = vsub_f32(v9, vmul_n_f32(v10, v11 / v12));
    else
      v9 = vsub_f32(*a3, v8);
  }
  v13 = sqrtf(vmlas_n_f32(COERCE_FLOAT(vmul_f32(v9, v9).i32[1]), v9.f32[0], v9.f32[0]));
  *a4 = v13;
  if (v13 <= 0.0)
  {
    if ((v15 & 1) == 0)
    {
      v17 = a5;
      a5 = v17;
      if (v16)
      {
        b2Vec2_zero_fn(void)::b2Vec2_zero_init = 0;
        a5 = v17;
      }
    }
    v14 = (b2Vec2)b2Vec2_zero_fn(void)::b2Vec2_zero_init;
  }
  else
  {
    v14 = (b2Vec2)vmul_n_f32(v9, 1.0 / v13);
  }
  *a5 = v14;
}

uint64_t b2EdgeShape::RayCast(float *a1, float *a2, float *a3, float *a4)
{
  float v4;
  float v5;
  float v6;
  float v7;
  float v8;
  float v9;
  float v10;
  float v11;
  float v12;
  float v13;
  float v14;
  float v15;
  float v16;
  float v17;
  float v18;
  float v19;
  float v20;
  float v21;
  float v22;
  float v23;
  float v24;
  float v25;
  float v26;
  float v27;
  float v29;
  float v30;
  float v33;

  v4 = a4[1];
  v5 = *a3 - *a4;
  v6 = a3[1] - v4;
  v8 = a4[2];
  v7 = a4[3];
  v9 = (float)(v6 * v8) + (float)(v7 * v5);
  v10 = (float)(v7 * v6) - (float)(v8 * v5);
  v11 = a3[2] - *a4;
  v12 = a3[3] - v4;
  v13 = (float)(v8 * v12) + (float)(v7 * v11);
  v14 = (float)(v7 * v12) - (float)(v8 * v11);
  v15 = v13 - v9;
  v16 = v14 - v10;
  v17 = a1[4];
  v18 = a1[5];
  v19 = a1[6] - v17;
  v20 = a1[7] - v18;
  v21 = -v19;
  v22 = sqrtf((float)(v19 * v19) + (float)(v20 * v20));
  if (v22 >= 0.00000011921)
  {
    v24 = 1.0 / v22;
    v23 = v20 * (float)(1.0 / v22);
    v21 = v24 * v21;
  }
  else
  {
    v23 = a1[7] - v18;
  }
  v25 = (float)(v16 * v21) + (float)(v23 * v15);
  if (v25 == 0.0)
    return 0;
  v26 = (float)((float)(v18 - v10) * v21) + (float)(v23 * (float)(v17 - v9));
  v27 = v26 / v25;
  if (v27 < 0.0 || a3[4] < v27)
    return 0;
  v29 = (float)(v20 * v20) + (float)(v19 * v19);
  if (v29 == 0.0)
    return 0;
  v30 = (float)((float)(v20 * (float)((float)(v10 + (float)(v16 * v27)) - v18))
              + (float)((float)((float)(v9 + (float)(v15 * v27)) - v17) * v19))
      / v29;
  if (v30 < 0.0 || v30 > 1.0)
    return 0;
  v33 = -v23;
  if (v26 > 0.0)
    v21 = -v21;
  else
    v33 = v23;
  *a2 = v33;
  a2[1] = v21;
  a2[2] = v27;
  return 1;
}

float32x4_t b2EdgeShape::ComputeAABB(_DWORD *a1, _OWORD *a2, uint64_t *a3, int32x4_t a4, int32x4_t a5)
{
  const float *v5;
  float32x4_t v6;
  float32x4_t v7;
  int32x4_t v8;
  float32x4_t v9;
  float32x4_t v10;
  float32x4_t v11;
  __int128 v12;
  float32x4_t result;

  a4.i32[0] = a1[4];
  a5.i32[0] = a1[5];
  v5 = (const float *)(a1 + 3);
  v7.i64[0] = *a3;
  v6.i64[0] = a3[1];
  v8.i64[0] = v6.i64[0];
  v8.i64[1] = v6.i64[0];
  v7.i64[1] = *a3;
  v6.f32[0] = -v6.f32[0];
  v6.i64[1] = v6.i64[0];
  a5.i32[1] = a1[7];
  a4.i32[1] = a1[6];
  v9 = vaddq_f32(vmlaq_f32(vmulq_f32(v6, (float32x4_t)vzip1q_s32(a5, a5)), (float32x4_t)vzip1q_s32(a4, a4), (float32x4_t)vrev64q_s32(v8)), v7);
  v10 = vld1q_dup_f32(v5);
  v11 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vextq_s8((int8x16_t)v9, (int8x16_t)v9, 8uLL), v9), (int8x16_t)vdupq_lane_s64(v9.i64[0], 0), (int8x16_t)vdupq_laneq_s64((int64x2_t)v9, 1));
  *(_QWORD *)&v12 = vsubq_f32(v11, v10).u64[0];
  result = vaddq_f32(v11, v10);
  *((_QWORD *)&v12 + 1) = result.i64[1];
  *a2 = v12;
  return result;
}

float32x2_t b2EdgeShape::ComputeMass(float32x2_t *a1, uint64_t a2)
{
  float32x2_t result;

  *(_DWORD *)a2 = 0;
  result = vmul_f32(vadd_f32(a1[2], a1[3]), (float32x2_t)0x3F0000003F000000);
  *(float32x2_t *)(a2 + 4) = result;
  *(_DWORD *)(a2 + 12) = 0;
  return result;
}

void b2EdgeShape::~b2EdgeShape(b2EdgeShape *this)
{
  JUMPOUT(0x20BD0BA58);
}

uint64_t b2PolygonShape::Clone(b2PolygonShape *this)
{
  uint64_t v2;
  uint64_t v3;

  v2 = operator new();
  *(_OWORD *)(v2 + 16) = 0u;
  *(_OWORD *)(v2 + 32) = 0u;
  *(_OWORD *)(v2 + 48) = 0u;
  *(_QWORD *)(v2 + 64) = 0;
  v3 = *((_QWORD *)this + 1);
  *(_QWORD *)v2 = &off_24C0E81C0;
  *(_QWORD *)(v2 + 8) = v3;
  if ((b2PolygonShape *)v2 != this)
  {
    std::vector<PKPoint>::__assign_with_size[abi:ne180100]<PKPoint*,PKPoint*>((char *)(v2 + 16), *((char **)this + 2), *((_QWORD *)this + 3), (uint64_t)(*((_QWORD *)this + 3) - *((_QWORD *)this + 2)) >> 3);
    std::vector<PKPoint>::__assign_with_size[abi:ne180100]<PKPoint*,PKPoint*>((char *)(v2 + 40), *((char **)this + 5), *((_QWORD *)this + 6), (uint64_t)(*((_QWORD *)this + 6) - *((_QWORD *)this + 5)) >> 3);
  }
  *(_QWORD *)(v2 + 64) = *((_QWORD *)this + 8);
  return v2;
}

double b2PolygonShape::SetAsBox(b2PolygonShape *this, float a2, float a3)
{
  float *v6;
  _OWORD *v7;
  double result;

  std::vector<b2Vec2>::resize((uint64_t)this + 16, 4uLL);
  std::vector<b2Vec2>::resize((uint64_t)this + 40, 4uLL);
  v6 = (float *)*((_QWORD *)this + 2);
  *v6 = -a2;
  v6[1] = -a3;
  v6[2] = a2;
  v6[3] = -a3;
  v6[4] = a2;
  v6[5] = a3;
  v6[6] = -a2;
  v6[7] = a3;
  v7 = (_OWORD *)*((_QWORD *)this + 5);
  result = -0.0078125;
  *v7 = xmmword_208FD69E0;
  v7[1] = xmmword_208FD69F0;
  *((_QWORD *)this + 8) = 0;
  return result;
}

void b2PolygonShape::SetAsBox(b2PolygonShape *this, float a2, float a3, const b2Vec2 *a4, float a5)
{
  float *v10;
  _OWORD *v11;
  float x;
  float y;
  __float2 v14;
  unint64_t v15;
  float v16;
  uint64_t v17;
  float *v18;
  float *v19;
  float v20;
  float v21;
  float v22;
  float v23;
  float v24;
  float v25;

  std::vector<b2Vec2>::resize((uint64_t)this + 16, 4uLL);
  std::vector<b2Vec2>::resize((uint64_t)this + 40, 4uLL);
  v10 = (float *)*((_QWORD *)this + 2);
  *v10 = -a2;
  v10[1] = -a3;
  v10[2] = a2;
  v10[3] = -a3;
  v10[4] = a2;
  v10[5] = a3;
  v10[6] = -a2;
  v10[7] = a3;
  v11 = (_OWORD *)*((_QWORD *)this + 5);
  *v11 = xmmword_208FD69E0;
  v11[1] = xmmword_208FD69F0;
  *((b2Vec2 *)this + 8) = *a4;
  x = a4->x;
  y = a4->y;
  v14 = __sincosf_stret(a5);
  v15 = *((_QWORD *)this + 3) - (_QWORD)v10;
  if ((int)(v15 >> 3) >= 1)
  {
    v16 = -v14.__sinval;
    v17 = (v15 >> 3);
    v18 = v10 + 1;
    v19 = (float *)v11 + 1;
    do
    {
      v20 = *(v18 - 1);
      v21 = x + (float)((float)(*v18 * v16) + (float)(v14.__cosval * v20));
      v22 = y + (float)((float)(v14.__cosval * *v18) + (float)(v14.__sinval * v20));
      *(v18 - 1) = v21;
      *v18 = v22;
      v23 = *(v19 - 1);
      v24 = (float)(*v19 * v16) + (float)(v14.__cosval * v23);
      v25 = (float)(v14.__cosval * *v19) + (float)(v14.__sinval * v23);
      *(v19 - 1) = v24;
      *v19 = v25;
      v18 += 2;
      v19 += 2;
      --v17;
    }
    while (v17);
  }
}

uint64_t b2PolygonShape::GetChildCount(b2PolygonShape *this)
{
  return 1;
}

BOOL b2PolygonShape::isValidShape(b2PolygonShape *this)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  float *v7;
  float v8;
  uint64_t v9;
  uint64_t v10;

  v1 = *((_QWORD *)this + 2);
  v2 = *((_QWORD *)this + 3) - v1;
  if ((int)((unint64_t)v2 >> 3) < 3)
    return 0;
  v4 = 0;
  v5 = (int)(v2 >> 3);
  v6 = ((unint64_t)v2 >> 3);
  v7 = (float *)(v1 + 4);
  v8 = 0.0;
  do
  {
    v9 = v4 + 1;
    if (v4 + 1 < v5)
      v10 = v4 + 1;
    else
      v10 = 0;
    v8 = v8
       + (float)((float)((float)(*(v7 - 1) * *(float *)(v1 + 8 * v10 + 4)) - (float)(*v7 * *(float *)(v1 + 8 * v10)))
               * 0.5);
    v7 += 2;
    v4 = v9;
  }
  while (v6 != v9);
  return fabsf(v8) > 0.00000011921;
}

BOOL b2PolygonShape::Set(b2PolygonShape *this, const b2Vec2 *a2, int a3)
{
  int64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  __int128 v10;
  __int128 v11;
  int64_t v12;
  BOOL v13;
  uint64_t v14;
  float *v15;
  int64_t v16;
  uint64_t v17;
  float *v18;
  float v19;
  float32x2_t v20;
  float v21;
  float v22;
  __int128 v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t v26;
  float v27;
  float32x2_t v28;
  uint64_t v29;
  uint64_t v30;
  float32x2_t v31;
  float32x2_t v32;
  float v33;
  void *v34;
  __int128 v36;
  uint64_t v37;
  _BYTE __p[24];

  v6 = a3;
  std::vector<b2Vec2>::vector(__p, a3);
  std::vector<b2Vec2>::vector(&v36, v6);
  if (a3 >= 1)
  {
    v7 = 0;
    do
    {
      *(b2Vec2 *)(*(_QWORD *)__p + v7 * 8) = a2[v7];
      ++v7;
    }
    while (a3 != v7);
  }
  v8 = *(_QWORD *)__p;
  v9 = *((_QWORD *)this + 4);
  v10 = *(_OWORD *)&__p[8];
  v11 = *((_OWORD *)this + 1);
  *((_QWORD *)this + 2) = *(_QWORD *)__p;
  *(_OWORD *)__p = v11;
  *(_OWORD *)((char *)this + 24) = v10;
  *(_QWORD *)&__p[16] = v9;
  if (a3 >= 1)
  {
    v12 = 0;
    v13 = 0;
    v14 = v36;
    v15 = (float *)(v8 + 4);
    while (1)
    {
      v16 = v12 + 1;
      v17 = v12 + 1 < v6 ? v12 + 1 : 0;
      v18 = (float *)(v8 + 8 * v17);
      v19 = *v18 - *(v15 - 1);
      v20.f32[0] = v18[1] - *v15;
      if ((float)((float)(v20.f32[0] * v20.f32[0]) + (float)(v19 * v19)) < 1.4211e-14)
        break;
      v21 = -v19;
      *(_DWORD *)v14 = v20.i32[0];
      *(float *)(v14 + 4) = -v19;
      v22 = sqrtf((float)(v19 * v19) + (float)(v20.f32[0] * v20.f32[0]));
      if (v22 >= 0.00000011921)
      {
        v20.f32[1] = v21;
        *(float32x2_t *)v14 = vmul_n_f32(v20, 1.0 / v22);
      }
      v13 = v16 >= v6;
      v15 += 2;
      v14 += 8;
      v12 = v16;
      if (a3 == v16)
        goto LABEL_15;
    }
    *((_QWORD *)this + 3) = v8;
    v34 = (void *)v36;
    if (!(_QWORD)v36)
      goto LABEL_23;
LABEL_22:
    *((_QWORD *)&v36 + 1) = v34;
    operator delete(v34);
    goto LABEL_23;
  }
  v13 = 1;
LABEL_15:
  v23 = *(_OWORD *)((char *)this + 40);
  *(_OWORD *)((char *)this + 40) = v36;
  v36 = v23;
  v24 = *((_QWORD *)this + 7);
  *((_QWORD *)this + 7) = v37;
  v37 = v24;
  if ((int)((unint64_t)(v10 - v8) >> 3) < 3)
    __assert_rtn("ComputeCentroid", "b2PolygonShape.cpp", 83, "count >= 3");
  v25 = 0;
  v26 = ((unint64_t)(v10 - v8) >> 3);
  v27 = 0.0;
  v28 = 0;
  do
  {
    v29 = v25 + 1;
    if (v25 + 1 < v26)
      v30 = v25 + 1;
    else
      v30 = 0;
    v31 = *(float32x2_t *)(v8 + 8 * v25);
    v32 = *(float32x2_t *)(v8 + 8 * v30);
    v33 = vmlas_n_f32((float)-v31.f32[1] * v32.f32[0], v32.f32[1], v31.f32[0]) * 0.5;
    v27 = v27 + v33;
    v28 = vadd_f32(v28, vmul_n_f32(vadd_f32(vadd_f32(v31, 0), v32), v33 * 0.33333));
    ++v25;
  }
  while (v26 != v29);
  *((float32x2_t *)this + 8) = vmul_n_f32(v28, 1.0 / v27);
  v34 = (void *)v23;
  if ((_QWORD)v23)
    goto LABEL_22;
LABEL_23:
  if (*(_QWORD *)__p)
  {
    *(_QWORD *)&__p[8] = *(_QWORD *)__p;
    operator delete(*(void **)__p);
  }
  return v13;
}

void sub_208FB66F4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

BOOL b2PolygonShape::TestPoint(b2PolygonShape *this, const b2Transform *a2, const b2Vec2 *a3)
{
  float *v3;
  uint64_t v4;
  float v5;
  float v6;
  float var1;
  float var0;
  float v9;
  float v10;
  float *v11;
  uint64_t v12;
  uint64_t v13;
  float *v14;
  float *v15;
  uint64_t v16;
  uint64_t v17;
  float v18;

  v3 = (float *)*((_QWORD *)this + 2);
  v4 = *((_QWORD *)this + 3) - (_QWORD)v3;
  if ((int)((unint64_t)v4 >> 3) < 1)
    return 1;
  v5 = a3->x - a2->var0.x;
  v6 = a3->y - a2->var0.y;
  var0 = a2->var1.var0;
  var1 = a2->var1.var1;
  v9 = (float)(v6 * var0) + (float)(var1 * v5);
  v10 = (float)(var1 * v6) - (float)(var0 * v5);
  v11 = (float *)*((_QWORD *)this + 5);
  if ((float)((float)((float)(v10 - v3[1]) * v11[1]) + (float)(*v11 * (float)(v9 - *v3))) > 0.0)
    return 0;
  v12 = (int)(v4 >> 3);
  v13 = ((unint64_t)v4 >> 3);
  v14 = v11 + 3;
  v15 = v3 + 3;
  v16 = 1;
  do
  {
    v17 = v16;
    if (v13 == v16)
      break;
    v18 = (float)((float)(v10 - *v15) * *v14) + (float)(*(v14 - 1) * (float)(v9 - *(v15 - 1)));
    ++v16;
    v14 += 2;
    v15 += 2;
  }
  while (v18 <= 0.0);
  return v17 >= v12;
}

float b2PolygonShape::ComputeDistance(b2PolygonShape *this, const b2Transform *a2, const b2Vec2 *a3, float *a4, b2Vec2 *a5)
{
  float v5;
  float v6;
  float var1;
  float var0;
  float v9;
  float v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  float *v14;
  float *v15;
  float v16;
  uint64_t v17;
  float v18;
  float v19;
  float v20;
  float v21;
  float v22;
  float *v23;
  float v24;
  float v25;
  float v26;
  float v27;
  float result;
  float v29;
  float v30;
  float v31;
  float v32;
  float v33;
  float v34;
  float v35;
  float v36;

  v5 = a3->x - a2->var0.x;
  v6 = a3->y - a2->var0.y;
  var0 = a2->var1.var0;
  var1 = a2->var1.var1;
  v9 = (float)(v6 * var0) + (float)(var1 * v5);
  v10 = (float)(var1 * v6) - (float)(var0 * v5);
  v11 = *((_QWORD *)this + 2);
  v12 = *((_QWORD *)this + 3) - v11;
  if ((int)(v12 >> 3) < 1)
  {
    v16 = -3.4028e38;
  }
  else
  {
    v13 = (v12 >> 3);
    v14 = (float *)(*((_QWORD *)this + 5) + 4);
    v15 = (float *)(v11 + 4);
    v16 = -3.4028e38;
    v17 = v13;
    v18 = v10;
    v19 = v9;
    do
    {
      v20 = *(v14 - 1);
      v21 = (float)(v10 - *v15) * *v14;
      if ((float)(v21 + (float)(v20 * (float)(v9 - *(v15 - 1)))) > v16)
      {
        v19 = *(v14 - 1);
        v18 = *v14;
        v16 = v21 + (float)(v20 * (float)(v9 - *(v15 - 1)));
      }
      v14 += 2;
      v15 += 2;
      --v17;
    }
    while (v17);
    if (v16 > 0.0)
    {
      v22 = v16 * v16;
      v23 = (float *)(v11 + 4);
      do
      {
        v24 = v9 - *(v23 - 1);
        v25 = v10 - *v23;
        if (v22 > (float)((float)(v25 * v25) + (float)(v24 * v24)))
        {
          v18 = v10 - *v23;
          v19 = v9 - *(v23 - 1);
          v22 = (float)(v25 * v25) + (float)(v24 * v24);
        }
        v23 += 2;
        --v13;
      }
      while (v13);
      *a4 = sqrtf(v22);
      v27 = a2->var1.var0;
      v26 = a2->var1.var1;
      result = (float)(v26 * v19) - (float)(v27 * v18);
      v29 = (float)(v18 * v26) + (float)(v27 * v19);
      a5->x = result;
      a5->y = v29;
      v30 = sqrtf((float)(v29 * v29) + (float)(result * result));
      if (v30 >= 0.00000011921)
      {
        v31 = 1.0 / v30;
        result = result * v31;
        a5->x = result;
        a5->y = v29 * v31;
      }
      return result;
    }
    v10 = v18;
    v9 = v19;
  }
  *a4 = v16;
  v33 = a2->var1.var0;
  v32 = a2->var1.var1;
  v34 = (float)(v32 * v9) - (float)(v33 * v10);
  result = (float)(v10 * v32) + (float)(v33 * v9);
  a5->x = v34;
  a5->y = result;
  v35 = sqrtf((float)(result * result) + (float)(v34 * v34));
  if (v35 >= 0.00000011921)
  {
    v36 = 1.0 / v35;
    result = result * v36;
    a5->x = v34 * v36;
    a5->y = result;
  }
  return result;
}

uint64_t b2PolygonShape::RayCast(_QWORD *a1, float *a2, float *a3, float *a4)
{
  float v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  float v8;
  float v9;
  float v10;
  float v11;
  float v12;
  float v13;
  float v14;
  float v15;
  float v16;
  float v17;
  float v18;
  float v19;
  float v20;
  uint64_t v21;
  float *v22;
  float *v23;
  unsigned int v24;
  float v25;
  float v26;
  float v27;
  float v28;
  float v29;
  float *v32;
  float v33;
  float v34;

  v4 = a3[4];
  v5 = a1[2];
  v6 = a1[3] - v5;
  if ((int)(v6 >> 3) < 1)
  {
    if (v4 >= 0.0)
      return 0;
LABEL_26:
    b2PolygonShape::RayCast();
  }
  v7 = 0;
  v8 = a4[1];
  v9 = *a3 - *a4;
  v10 = a3[1] - v8;
  v12 = a4[2];
  v11 = a4[3];
  v13 = (float)(v10 * v12) + (float)(v11 * v9);
  v14 = (float)(v11 * v10) - (float)(v12 * v9);
  v15 = a3[2] - *a4;
  v16 = a3[3] - v8;
  v17 = (float)(v12 * v16) + (float)(v11 * v15);
  v18 = (float)(v11 * v16) - (float)(v12 * v15);
  v19 = v17 - v13;
  v20 = v18 - v14;
  v21 = (v6 >> 3);
  v22 = (float *)(a1[5] + 4);
  v23 = (float *)(v5 + 4);
  v24 = -1;
  v25 = 0.0;
  v26 = a3[4];
  do
  {
    v27 = *(v22 - 1);
    v28 = (float)((float)(*v23 - v14) * *v22) + (float)(v27 * (float)(*(v23 - 1) - v13));
    v29 = (float)(v20 * *v22) + (float)(v27 * v19);
    if (v29 == 0.0)
    {
      if (v28 < 0.0)
        return 0;
    }
    else if (v29 < 0.0 && v28 < (float)(v25 * v29))
    {
      v24 = v7;
      v25 = v28 / v29;
    }
    else if (v29 > 0.0 && v28 < (float)(v26 * v29))
    {
      v26 = v28 / v29;
    }
    if (v26 < v25)
      return 0;
    ++v7;
    v22 += 2;
    v23 += 2;
  }
  while (v21 != v7);
  if (v25 < 0.0 || v25 > v4)
    goto LABEL_26;
  if ((v24 & 0x80000000) == 0)
  {
    a2[2] = v25;
    v32 = (float *)(a1[5] + 8 * v24);
    v33 = v32[1];
    v34 = (float)(v11 * v33) + (float)(v12 * *v32);
    *a2 = (float)(v33 * (float)-v12) + (float)(v11 * *v32);
    a2[1] = v34;
    return 1;
  }
  return 0;
}

float32x4_t b2PolygonShape::ComputeAABB(uint64_t a1, _OWORD *a2, float32x2_t *a3)
{
  float32x2_t v3;
  float32x2_t v4;
  float *v5;
  float32x4_t v6;
  unint64_t v7;
  float *v8;
  uint64_t v9;
  float32x4_t v10;
  int16x4_t v11;
  const float *v12;
  float32x4_t v13;
  __int128 v14;
  float32x4_t result;

  v4 = a3[1];
  v3 = (float32x2_t)vrev64_s32((int32x2_t)v4);
  v4.f32[0] = -v4.f32[0];
  v5 = *(float **)(a1 + 16);
  *(float32x2_t *)v6.f32 = vadd_f32(*a3, vmla_n_f32(vmul_n_f32(v4, v5[1]), v3, *v5));
  v6.i64[1] = v6.i64[0];
  v7 = *(_QWORD *)(a1 + 24) - (_QWORD)v5;
  if ((int)(v7 >> 3) >= 2)
  {
    v8 = v5 + 3;
    v9 = (v7 >> 3) - 1;
    do
    {
      *(float32x2_t *)v10.f32 = vadd_f32(*a3, vmla_n_f32(vmul_n_f32(v4, *v8), v3, *(v8 - 1)));
      v10.i64[1] = v10.i64[0];
      v11.i32[0] = vmovn_s32(vcgtq_f32(v10, v6)).u32[0];
      v11.i32[1] = vmovn_s32(vcgtq_f32(v6, v10)).i32[1];
      v6 = (float32x4_t)vbslq_s8((int8x16_t)vmovl_s16(v11), (int8x16_t)v6, (int8x16_t)v10);
      v8 += 2;
      --v9;
    }
    while (v9);
  }
  v12 = (const float *)(a1 + 12);
  v13 = vld1q_dup_f32(v12);
  *(_QWORD *)&v14 = vsubq_f32(v6, v13).u64[0];
  result = vaddq_f32(v6, v13);
  *((_QWORD *)&v14 + 1) = result.i64[1];
  *a2 = v14;
  return result;
}

float b2PolygonShape::ComputeMass(uint64_t a1, uint64_t a2, float a3)
{
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;
  float32x2_t v6;
  uint64_t v7;
  float32x2_t *v8;
  float32x2_t v9;
  float32x2_t v10;
  uint64_t v11;
  float32x2_t v12;
  float v13;
  float v14;
  uint64_t v15;
  float32x2_t v16;
  uint64_t v17;
  float32x2_t v18;
  float32x2_t v19;
  float v20;
  float v21;
  float32x2_t v22;
  float32x2_t v23;
  float result;

  v3 = *(_QWORD *)(a1 + 16);
  v4 = *(_QWORD *)(a1 + 24) - v3;
  if ((int)(v4 >> 3) < 3)
    b2PolygonShape::ComputeMass();
  v5 = (v4 >> 3);
  v6 = 0;
  v7 = v5;
  v8 = *(float32x2_t **)(a1 + 16);
  do
  {
    v9 = *v8++;
    v6 = vadd_f32(v6, v9);
    --v7;
  }
  while (v7);
  v10 = vmul_n_f32(v6, 1.0 / (float)(int)(v4 >> 3));
  v11 = (int)((uint64_t)v4 >> 3);
  v12 = 0;
  v13 = 0.0;
  v14 = 0.0;
  do
  {
    v15 = v7 + 1;
    v16 = *(float32x2_t *)(v3 + 8 * v7);
    if (v7 + 1 < v11)
      v17 = v7 + 1;
    else
      v17 = 0;
    v18 = vsub_f32(v16, v10);
    v19 = vsub_f32(*(float32x2_t *)(v3 + 8 * v17), v10);
    v20 = vmlas_n_f32((float)-v18.f32[1] * v19.f32[0], v19.f32[1], v18.f32[0]);
    v13 = v13 + (float)(v20 * 0.5);
    v12 = vadd_f32(v12, vmul_n_f32(vadd_f32(v18, v19), (float)(v20 * 0.5) * 0.33333));
    v14 = v14 + (float)((float)(v20 * 0.083333) * vaddv_f32(vmla_f32(vmla_f32(vmul_f32(v18, v19), v18, v18), v19, v19)));
    v7 = v15;
  }
  while (v5 != v15);
  v21 = fabsf(v13 * a3);
  *(float *)a2 = v21;
  v22 = vmul_n_f32(v12, 1.0 / v13);
  v23 = vadd_f32(v10, v22);
  *(float32x2_t *)(a2 + 4) = v23;
  result = (float)(v14 * a3)
         + (float)(v21
                 * (float)(vmlas_n_f32(COERCE_FLOAT(vmul_f32(v23, v23).i32[1]), v23.f32[0], v23.f32[0])
                         - vmlas_n_f32(COERCE_FLOAT(vmul_f32(v22, v22).i32[1]), v22.f32[0], v22.f32[0])));
  *(float *)(a2 + 12) = result;
  return result;
}

void b2PolygonShape::~b2PolygonShape(b2PolygonShape *this)
{
  void *v2;
  void *v3;

  *(_QWORD *)this = &off_24C0E81C0;
  v2 = (void *)*((_QWORD *)this + 5);
  if (v2)
  {
    *((_QWORD *)this + 6) = v2;
    operator delete(v2);
  }
  v3 = (void *)*((_QWORD *)this + 2);
  if (v3)
  {
    *((_QWORD *)this + 3) = v3;
    operator delete(v3);
  }
}

{
  void *v2;
  void *v3;

  *(_QWORD *)this = &off_24C0E81C0;
  v2 = (void *)*((_QWORD *)this + 5);
  if (v2)
  {
    *((_QWORD *)this + 6) = v2;
    operator delete(v2);
  }
  v3 = (void *)*((_QWORD *)this + 2);
  if (v3)
  {
    *((_QWORD *)this + 3) = v3;
    operator delete(v3);
  }
  JUMPOUT(0x20BD0BA58);
}

_QWORD *std::vector<b2Vec2>::vector(_QWORD *a1, unint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<PKPoint>::__vallocate[abi:ne180100](a1, a2);
    a1[1] += 8 * a2;
  }
  return a1;
}

void sub_208FB6D88(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void b2Draw::b2Draw(b2Draw *this)
{
  *(_QWORD *)this = off_24C0E88B0;
  *((_DWORD *)this + 2) = 0;
}

uint64_t b2Draw::SetFlags(uint64_t this, int a2)
{
  *(_DWORD *)(this + 8) = a2;
  return this;
}

uint64_t b2Draw::GetFlags(b2Draw *this)
{
  return *((unsigned int *)this + 2);
}

uint64_t b2Draw::AppendFlags(uint64_t this, int a2)
{
  *(_DWORD *)(this + 8) |= a2;
  return this;
}

uint64_t b2Draw::ClearFlags(uint64_t this, int a2)
{
  *(_DWORD *)(this + 8) &= ~a2;
  return this;
}

float b2Mat33::Solve33(b2Mat33 *this, const b2Vec3 *a2)
{
  float var2;
  float var1;
  float v4;
  float v5;
  float var0;
  float v7;
  float v8;
  float v9;
  float v10;
  float v11;

  var1 = this->var2.var1;
  var2 = this->var2.var2;
  v4 = this->var1.var1;
  v5 = this->var1.var2;
  var0 = this->var2.var0;
  v7 = (float)(v4 * var2) - (float)(v5 * var1);
  v8 = this->var1.var0;
  v9 = (float)(v5 * var0) - (float)(v8 * var2);
  v10 = (float)(v8 * var1) - (float)(v4 * var0);
  v11 = (float)((float)(this->var0.var1 * v9) + (float)(this->var0.var0 * v7)) + (float)(this->var0.var2 * v10);
  if (v11 != 0.0)
    v11 = 1.0 / v11;
  return v11 * (float)((float)((float)(v9 * a2->var1) + (float)(a2->var0 * v7)) + (float)(a2->var2 * v10));
}

float b2Mat33::Solve22(b2Mat33 *this, const b2Vec2 *a2)
{
  float var0;
  float var1;
  float v4;

  var0 = this->var1.var0;
  var1 = this->var1.var1;
  v4 = (float)(this->var0.var0 * var1) - (float)(var0 * this->var0.var1);
  if (v4 != 0.0)
    v4 = 1.0 / v4;
  return v4 * (float)((float)(var1 * a2->x) - (float)(var0 * a2->y));
}

float b2Mat33::GetInverse22(b2Mat33 *this, b2Mat33 *a2)
{
  float var0;
  float var1;
  float v4;
  float v5;
  float v6;
  float result;

  var0 = this->var0.var0;
  var1 = this->var0.var1;
  v4 = this->var1.var0;
  v5 = this->var1.var1;
  v6 = (float)(this->var0.var0 * v5) - (float)(v4 * var1);
  if (v6 != 0.0)
    v6 = 1.0 / v6;
  a2->var0.var2 = 0.0;
  a2->var0.var0 = v5 * v6;
  a2->var0.var1 = -(float)(v6 * var1);
  result = var0 * v6;
  a2->var1.var0 = -(float)(v6 * v4);
  a2->var1.var1 = result;
  *(_QWORD *)&a2->var2.var1 = 0;
  *(_QWORD *)&a2->var1.var2 = 0;
  return result;
}

float b2Mat33::GetSymInverse33(b2Mat33 *this, b2Mat33 *a2)
{
  float var2;
  float var1;
  float v4;
  float var0;
  float v6;
  float v7;
  float v8;
  float v9;
  float v10;
  float v11;
  float result;

  var1 = this->var2.var1;
  var2 = this->var2.var2;
  v4 = this->var1.var1;
  var0 = this->var2.var0;
  v6 = this->var1.var0;
  v7 = this->var0.var0;
  v8 = (float)((float)(this->var0.var1 * (float)((float)(this->var1.var2 * var0) - (float)(v6 * var2)))
             + (float)(this->var0.var0 * (float)((float)(v4 * var2) - (float)(this->var1.var2 * var1))))
     + (float)(this->var0.var2 * (float)((float)(v6 * var1) - (float)(v4 * var0)));
  if (v8 != 0.0)
    v8 = 1.0 / v8;
  v9 = v8 * (float)((float)(var0 * var1) - (float)(v6 * var2));
  a2->var0.var0 = v8 * (float)((float)(v4 * var2) - (float)(var1 * var1));
  a2->var0.var1 = v9;
  v10 = (float)((float)(v6 * var1) - (float)(var0 * v4)) * v8;
  a2->var0.var2 = v10;
  a2->var1.var0 = v9;
  v11 = v8 * (float)((float)(var0 * v6) - (float)(v7 * var1));
  a2->var1.var1 = v8 * (float)((float)(v7 * var2) - (float)(var0 * var0));
  a2->var1.var2 = v11;
  a2->var2.var0 = v10;
  a2->var2.var1 = v11;
  result = (float)((float)(v7 * v4) - (float)(v6 * v6)) * v8;
  a2->var2.var2 = result;
  return result;
}

uint64_t PKCMechanics::Solve(uint64_t result, __int128 *a2)
{
  QuadTree **v2;
  QuadTree **v3;
  uint64_t *v5;
  QuadTree *v6;
  _QWORD v7[2];
  __int128 v8;
  uint64_t v9;
  QuadTree *v10;
  float v11;
  float v12;
  float v13;
  float v14;

  v2 = *(QuadTree ***)(result + 8);
  v3 = *(QuadTree ***)(result + 16);
  if (v2 != v3)
  {
    v5 = (uint64_t *)result;
    do
    {
      v6 = *v2++;
      QuadTree::bounds(v6, &v11, &v12, &v13, &v14);
      v7[0] = &off_24C0E8810;
      v7[1] = v5;
      v8 = *a2;
      v9 = *((_QWORD *)a2 + 2);
      v10 = v6;
      result = b2World::QueryAABB(*v5, (uint64_t)v7, &v11);
    }
    while (v2 != v3);
  }
  return result;
}

void PKCMechanics::addQuadTree(PKCMechanics *this, QuadTree *a2)
{
  char *v4;
  unint64_t v5;
  unint64_t v6;
  _QWORD *v7;
  _QWORD *v8;
  void **v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  char *v15;
  char *v16;
  char *v17;
  char *v18;
  char *v19;
  uint64_t v20;

  v6 = *((_QWORD *)this + 3);
  v4 = (char *)this + 24;
  v5 = v6;
  v7 = (_QWORD *)*((_QWORD *)v4 - 1);
  if ((unint64_t)v7 >= v6)
  {
    v9 = (void **)(v4 - 16);
    v10 = *((_QWORD *)v4 - 2);
    v11 = ((uint64_t)v7 - v10) >> 3;
    if ((unint64_t)(v11 + 1) >> 61)
      std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
    v12 = v5 - v10;
    v13 = v12 >> 2;
    if (v12 >> 2 <= (unint64_t)(v11 + 1))
      v13 = v11 + 1;
    if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF8)
      v14 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v14 = v13;
    if (v14)
      v15 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKPoint>>((uint64_t)v4, v14);
    else
      v15 = 0;
    v16 = &v15[8 * v11];
    v17 = &v15[8 * v14];
    *(_QWORD *)v16 = a2;
    v8 = v16 + 8;
    v19 = (char *)*((_QWORD *)this + 1);
    v18 = (char *)*((_QWORD *)this + 2);
    if (v18 != v19)
    {
      do
      {
        v20 = *((_QWORD *)v18 - 1);
        v18 -= 8;
        *((_QWORD *)v16 - 1) = v20;
        v16 -= 8;
      }
      while (v18 != v19);
      v18 = (char *)*v9;
    }
    *((_QWORD *)this + 1) = v16;
    *((_QWORD *)this + 2) = v8;
    *((_QWORD *)this + 3) = v17;
    if (v18)
      operator delete(v18);
  }
  else
  {
    *v7 = a2;
    v8 = v7 + 1;
  }
  *((_QWORD *)this + 2) = v8;
}

void MechanicsCollisionCallback::~MechanicsCollisionCallback(MechanicsCollisionCallback *this)
{
  JUMPOUT(0x20BD0BA58);
}

uint64_t MechanicsCollisionCallback::ReportFixture(MechanicsCollisionCallback *this, b2Fixture *a2)
{
  uint64_t v4;
  int v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  float32x2_t v9;
  uint64_t v10;
  float *v11;
  float v12;
  float v13;
  float v14;
  float v15;
  uint64_t *v16;
  uint64_t v17;
  float32x2_t v18;
  float32x2_t v19;
  float32x2_t v20;
  void *v21;
  float32x2_t v22;
  float32x2_t v23;
  float32x2_t v24;
  float v25;
  float32x2_t v26;
  float v27;
  BOOL v28;
  float32x2_t v30;
  float32x2_t v31;
  float32x2_t v32;
  float v33;
  void *__p;
  float32x2_t v35;
  uint64_t v36;

  v4 = *((_QWORD *)a2 + 3);
  v5 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)a2 + 4) + 24))(*((_QWORD *)a2 + 4));
  if (v5 >= 1)
  {
    v6 = 0;
    v7 = 8;
    v8 = v5;
    v9 = (float32x2_t)vdup_n_s32(0x3B9374BCu);
    do
    {
      v10 = *((_QWORD *)a2 + 6);
      if (v6 >= (*((_QWORD *)a2 + 7) - v10) >> 5)
        MechanicsCollisionCallback::ReportFixture();
      v11 = (float *)(v10 + v7);
      v12 = *(v11 - 2);
      v13 = *(v11 - 1);
      v14 = *v11;
      v15 = v11[1];
      v16 = (uint64_t *)*((_QWORD *)this + 5);
      __p = 0;
      v35 = 0;
      v36 = 0;
      if (QuadTree::intersectBox(v16, (uint64_t)&__p, v12, v13, v14, v15))
      {
        v17 = *(_QWORD *)__p;
        v35 = (float32x2_t)__p;
        operator delete(__p);
        v18.i32[0] = *(_DWORD *)(v17 + 32);
        v18.i32[1] = *(_DWORD *)(v17 + 44);
        v19 = vmul_f32(vadd_f32(*(float32x2_t *)(v17 + 36), v18), (float32x2_t)0x3F0000003F000000);
        v20 = *(float32x2_t *)(v4 + 32);
        v21 = (void *)vadd_f32(vsub_f32(v19, *(float32x2_t *)(v4 + 48)), v20);
        v20.f32[0] = *((float *)this + 4) * 0.0;
        __p = v21;
        v35 = vadd_f32(v19, (float32x2_t)vdup_lane_s32((int32x2_t)v20, 0));
        LODWORD(v36) = 1065353216;
        if ((*(unsigned int (**)(_QWORD, float32x2_t *, void **, uint64_t, unint64_t))(**((_QWORD **)a2 + 4) + 48))(*((_QWORD *)a2 + 4), &v32, &__p, *((_QWORD *)a2 + 3) + 32, v6))
        {
          v22 = vadd_f32(vadd_f32(vmul_n_f32((float32x2_t)__p, 1.0 - v33), vmul_n_f32(v35, v33)), vmul_f32(v32, v9));
          v23 = vmul_n_f32(vsub_f32(v22, v19), *((float *)this + 5));
          v24 = vneg_f32(v23);
          v25 = sqrtf(vmlas_n_f32(vmuls_lane_f32(v23.f32[1], v23, 1), v23.f32[0], v23.f32[0]));
          if (v25 >= 0.00000011921)
            v24 = vmul_n_f32(v24, 1.0 / v25);
          v26 = vmul_n_f32(v24, vmlas_n_f32(vmuls_lane_f32((float)(0.0 - v23.f32[1]) * *((float *)this + 4), v24, 1), (float)(0.0 - v23.f32[0]) * *((float *)this + 4), v24.f32[0]));
          v27 = v26.f32[1];
          v28 = (v26.i32[0] & 0x7FFFFFFFu) <= 0x7F7FFFFF && (v26.i32[1] & 0x7FFFFFFFu) <= 0x7F7FFFFF;
          if (v28 && *(_DWORD *)(v4 + 20) == 2)
          {
            v30 = v26;
            v31 = v22;
            if ((b2Body::IsAwake((b2Body *)v4) & 1) == 0)
              b2Body::SetAwake((b2Body *)v4, 1);
            *(float32x2_t *)(v4 + 128) = vadd_f32(vmul_n_f32(v30, *(float *)(v4 + 212)), *(float32x2_t *)(v4 + 128));
            *(float *)(v4 + 136) = *(float *)(v4 + 136)
                                 + (float)(*(float *)(v4 + 224)
                                         * (float)((float)((float)(v31.f32[0] - *(float *)(v4 + 96)) * v27)
                                                 - (float)((float)(v31.f32[1] - *(float *)(v4 + 100)) * v30.f32[0])));
          }
        }
      }
      else if (__p)
      {
        v35 = (float32x2_t)__p;
        operator delete(__p);
      }
      ++v6;
      v7 += 32;
    }
    while (v8 != v6);
  }
  return 1;
}

void sub_208FB73F4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void *b2Alloc(int a1)
{
  return malloc_type_malloc(a1, 0x14466031uLL);
}

void b2StackAllocator::b2StackAllocator(b2StackAllocator *this)
{
  *((_QWORD *)this + 12800) = 0;
  *((_DWORD *)this + 25602) = 0;
  *((_DWORD *)this + 25732) = 0;
}

void b2StackAllocator::~b2StackAllocator(b2StackAllocator *this)
{
  const char *v1;
  int v2;

  if (*((_DWORD *)this + 25600))
  {
    v1 = "m_index == 0";
    v2 = 32;
    goto LABEL_6;
  }
  if (*((_DWORD *)this + 25732))
  {
    v1 = "m_entryCount == 0";
    v2 = 33;
LABEL_6:
    __assert_rtn("~b2StackAllocator", "b2StackAllocator.cpp", v2, v1);
  }
}

char *b2StackAllocator::Allocate(b2StackAllocator *this, int a2)
{
  int *v2;
  uint64_t v3;
  char *v5;
  uint64_t v6;
  char *result;
  char v8;
  char *v9;
  int v10;
  int v11;

  v2 = (int *)((char *)this + 102400);
  v3 = *((int *)this + 25732);
  if ((int)v3 >= 32)
    b2StackAllocator::Allocate();
  v5 = (char *)this + 102416;
  *((_DWORD *)this + 4 * v3 + 25606) = a2;
  v6 = *v2;
  if ((int)v6 + a2 <= 102400)
  {
    v8 = 0;
    result = (char *)this + v6;
    *v2 = v6 + a2;
  }
  else
  {
    result = (char *)b2Alloc(a2);
    v8 = 1;
  }
  v9 = &v5[16 * v3];
  *(_QWORD *)v9 = result;
  v9[12] = v8;
  v10 = v2[2];
  v11 = v2[1] + a2;
  if (v10 <= v11)
    v10 = v2[1] + a2;
  v2[1] = v11;
  v2[2] = v10;
  ++v2[132];
  return result;
}

void b2StackAllocator::Free(void **this, void *a2)
{
  _DWORD *v2;
  uint64_t v3;
  void **v4;
  int v5;

  v2 = this + 12800;
  v3 = *((unsigned int *)this + 25732);
  if ((int)v3 <= 0)
    b2StackAllocator::Free();
  v4 = &this[2 * v3 + 12802];
  if (this[2 * v3 + 12800] != a2)
    b2StackAllocator::Free();
  if (BYTE4(this[2 * v3 + 12801]))
  {
    b2Free(a2);
    v5 = *((_DWORD *)v4 - 2);
    LODWORD(v3) = v2[132];
  }
  else
  {
    v5 = (int)this[2 * v3 + 12801];
    *v2 -= v5;
  }
  v2[1] -= v5;
  v2[132] = v3 - 1;
}

uint64_t b2StackAllocator::GetMaxAllocation(b2StackAllocator *this)
{
  return *((unsigned int *)this + 25602);
}

void b2Timer::b2Timer(b2Timer *this)
{
  float v2;
  timeval v3;

  gettimeofday(&v3, 0);
  v2 = (float)v3.tv_usec * 0.001;
  *(_QWORD *)this = v3.tv_sec;
  *((_QWORD *)this + 1) = (unint64_t)v2;
}

float b2Timer::Reset(b2Timer *this)
{
  float result;
  timeval v3;

  gettimeofday(&v3, 0);
  result = (float)v3.tv_usec * 0.001;
  *(_QWORD *)this = v3.tv_sec;
  *((_QWORD *)this + 1) = (unint64_t)result;
  return result;
}

float b2Timer::GetMilliseconds(b2Timer *this)
{
  timeval v3;

  gettimeofday(&v3, 0);
  return (float)((float)(unint64_t)(1000 * (v3.tv_sec - *(_QWORD *)this)) + (float)((float)v3.tv_usec * 0.001))
       - (float)*((unint64_t *)this + 1);
}

void b2BodyDef::b2BodyDef(b2BodyDef *this)
{
  this->userData = 0;
  *(_OWORD *)&this->position.x = 0u;
  *(_OWORD *)&this->linearVelocity.y = 0u;
  *(_QWORD *)((char *)&this->linearDamping + 1) = 0;
  this->type = 0;
  *(_DWORD *)&this->awake = 16777217;
  this->_sk_affectedByGravity = 1;
  *(_OWORD *)&this->_sk_fieldCategoryBitMask = xmmword_208FD6A50;
}

void b2Body::b2Body(b2Body *this, const b2BodyDef *a2, b2Body *a3)
{
  float x;
  BOOL v4;
  float y;
  BOOL v7;
  float v8;
  BOOL v9;
  float v10;
  float angle;
  float angularVelocity;
  float angularDamping;
  float linearDamping;
  unsigned __int16 v16;
  b2Vec2 position;
  float charge;
  int type;
  float v20;

  x = a2->position.x;
  v4 = x > -INFINITY && x < INFINITY;
  if (!v4 || ((y = a2->position.y, y > -INFINITY) ? (v7 = y < INFINITY) : (v7 = 0), !v7))
    b2Body::b2Body();
  v8 = a2->linearVelocity.x;
  v9 = v8 > -INFINITY && v8 < INFINITY;
  if (!v9 || (v10 = a2->linearVelocity.y, v10 <= -INFINITY) || v10 >= INFINITY)
    b2Body::b2Body();
  angle = a2->angle;
  if (angle <= -INFINITY || angle >= INFINITY)
    b2Body::b2Body();
  angularVelocity = a2->angularVelocity;
  if (angularVelocity <= -INFINITY || angularVelocity >= INFINITY)
    b2Body::b2Body();
  angularDamping = a2->angularDamping;
  if (angularDamping < 0.0 || angularDamping <= -INFINITY || angularDamping >= INFINITY)
    b2Body::b2Body();
  linearDamping = a2->linearDamping;
  if (linearDamping < 0.0 || linearDamping <= -INFINITY || linearDamping >= INFINITY)
    b2Body::b2Body();
  this->var0 = a2->_sk_affectedByGravity;
  *(_OWORD *)&this->var1 = *(_OWORD *)&a2->_sk_fieldCategoryBitMask;
  v16 = 8 * a2->bullet;
  this->var6 = 8 * a2->bullet;
  if (a2->fixedRotation)
  {
    v16 |= 0x10u;
    this->var6 = v16;
  }
  if (a2->allowSleep)
  {
    v16 |= 4u;
    this->var6 = v16;
  }
  if (a2->awake)
  {
    v16 |= 2u;
    this->var6 = v16;
  }
  if (a2->active)
    this->var6 = v16 | 0x20;
  this->var17 = a3;
  position = a2->position;
  this->var8.var0 = position;
  this->var8.var1 = (b2Rot)__sincosf_stret(a2->angle);
  this->var9 = this->var8;
  this->var10.var0 = 0;
  *(b2Vec2 *)&this->var10.var1.var0.var1 = position;
  *(b2Vec2 *)&this->var10.var2.var0.var1 = position;
  this->var10.var2.var0.var0.y = a2->angle;
  this->var11.x = a2->angle;
  this->var11.y = 0.0;
  this->var18 = 0;
  *(_QWORD *)&this->var19 = 0;
  *(_QWORD *)&this->var22 = 0;
  *(_QWORD *)&this->var24 = 0;
  *(b2Vec2 *)&this->var14 = a2->linearVelocity;
  *(float *)&this->var15 = a2->angularVelocity;
  *(void **)((char *)&this->var30 + 4) = *(void **)&a2->linearDamping;
  charge = a2->charge;
  *(b2World **)((char *)&this->var15 + 4) = 0;
  HIDWORD(this->var16) = 0;
  this[1].var1 = 0;
  type = a2->type;
  this->var5 = type;
  v20 = 0.0;
  if (type == 2)
    v20 = 1.0;
  this->var26 = v20;
  this->var27 = v20;
  *(_QWORD *)&this->var29 = 0;
  this->var28 = charge;
  *(_QWORD *)&this[1].var2 = a2->userData;
  this->var20 = 0;
  LODWORD(this->var21) = 0;
}

void b2Body::SetCategoryBitMask(b2Body *this, unsigned int a2)
{
  this->var2 = a2;
  b2Body::SynchronizeFixtures(this);
}

void b2Body::SynchronizeFixtures(b2Body *this)
{
  float x;
  float y;
  float v4;
  b2JointEdge *i;
  b2Transform v6;

  v6.var1 = (b2Rot)__sincosf_stret(this->var10.var2.var0.var0.y);
  x = this->var10.var0.x;
  y = this->var10.var0.y;
  v4 = this->var10.var1.var0.var2 - (float)((float)(v6.var1.var1 * y) + (float)(v6.var1.var0 * x));
  v6.var0.x = this->var10.var1.var0.var1 - (float)((float)(v6.var1.var1 * x) - (float)(v6.var1.var0 * y));
  v6.var0.y = v4;
  for (i = this->var20; i; i = i->var2)
    b2Fixture::Synchronize((b2Fixture *)i, (b2ContactManager *)&this->var17[443].var19, &v6, &this->var8);
}

void b2Body::SetCollisionBitMask(b2Body *this, unsigned int a2)
{
  this->var3 = a2;
  b2Body::SynchronizeFixtures(this);
}

void b2Body::SetIntersectionCallbackBitMask(b2Body *this, unsigned int a2)
{
  this->var4 = a2;
  b2Body::SynchronizeFixtures(this);
}

void b2Body::SetType(b2Body *this, int a2)
{
  unsigned __int16 var6;
  uint64_t v4;
  uint64_t v5;
  b2JointEdge *i;
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;

  if (((uint64_t)this->var17[443].var18 & 2) != 0)
    b2Body::SetType();
  if (this->var5 != a2)
  {
    this->var5 = a2;
    b2Body::ResetMassData(this);
    if (!this->var5)
    {
      *(_QWORD *)&this->var14 = 0;
      LODWORD(this->var15) = 0;
      *(_OWORD *)&this->var10.var1.var0.var1 = *(_OWORD *)&this->var10.var2.var0.var1;
      b2Body::SynchronizeFixtures(this);
    }
    var6 = this->var6;
    if ((var6 & 2) == 0)
    {
      this->var6 = var6 | 2;
      this[1].var1 = 0;
    }
    this->var16 = 0;
    HIDWORD(this->var15) = 0;
    v4 = *(_QWORD *)&this->var24;
    if (v4)
    {
      do
      {
        v5 = *(_QWORD *)(v4 + 24);
        b2ContactManager::DestroyContact((b2ContactManager *)&this->var17[443].var19, *(b2Contact **)(v4 + 8));
        v4 = v5;
      }
      while (v5);
    }
    *(_QWORD *)&this->var24 = 0;
    for (i = this->var20; i; i = i->var2)
    {
      b2Fixture::Refilter((b2Fixture *)i);
      v7 = (char *)i[1].var3 - (char *)i[1].var2;
      if ((int)(v7 >> 5) >= 1)
      {
        v8 = 0;
        v9 = v7 & 0x1FFFFFFFE0;
        do
        {
          b2ContactManager::TouchProxy((b2ContactManager *)&this->var17[443].var19, (int)i[1].var2[v8 / 0x20].var3);
          v8 += 32;
        }
        while (v9 != v8);
      }
    }
  }
}

void b2Body::ResetMassData(b2Body *this)
{
  b2Vec2 v2;
  unsigned __int8 v3;
  float v4;
  float v5;
  b2JointEdge *i;
  float v7;
  float v8;
  float var26;
  float v10;
  float var29;
  float v12;
  float v13;
  float var1;
  float var0;
  float y;
  float v17;
  float v18;
  float v19;
  float32x2_t v20;
  uint64_t v21;
  float32x2_t v22;
  float32x2_t v23;
  uint64_t v24;
  float v25[4];

  *(_QWORD *)&this->var26 = 0;
  *(_QWORD *)&this->var29 = 0;
  this->var10.var0 = 0;
  if (this->var5 > 1u)
  {
    {
      b2Vec2_zero_fn(void)::b2Vec2_zero_init = 0;
    }
    v5 = *((float *)&b2Vec2_zero_fn(void)::b2Vec2_zero_init + 1);
    v4 = *(float *)&b2Vec2_zero_fn(void)::b2Vec2_zero_init;
    for (i = this->var20; i; i = i->var2)
    {
      if (*(float *)&i->var1 != 0.0)
      {
        (*(void (**)(b2Body *, float *))(*(_QWORD *)i[1].var0 + 64))(i[1].var0, v25);
        v7 = v25[0];
        v8 = v25[1];
        this->var26 = v25[0] + this->var26;
        v4 = v4 + (float)(v7 * v8);
        v5 = v5 + (float)(v7 * v25[2]);
        this->var29 = v25[3] + this->var29;
      }
    }
    var26 = this->var26;
    if (var26 <= 0.0)
    {
      this->var26 = 1.0;
      var26 = 1.0;
      v10 = 1.0;
    }
    else
    {
      v10 = 1.0 / var26;
      v4 = v4 * (float)(1.0 / var26);
      v5 = v5 * (float)(1.0 / var26);
    }
    this->var27 = v10;
    var29 = this->var29;
    if (var29 <= 0.0 || (this->var6 & 0x10) != 0)
    {
      this->var29 = 0.0;
      v13 = 0.0;
    }
    else
    {
      v12 = var29 - (float)(var26 * (float)((float)(v5 * v5) + (float)(v4 * v4)));
      if (v12 <= 0.00001)
        v12 = 0.00001;
      this->var29 = v12;
      v13 = 1.0 / v12;
    }
    *(float *)&this->var30 = v13;
    var0 = this->var8.var1.var0;
    var1 = this->var8.var1.var1;
    y = this->var8.var0.y;
    v17 = this->var8.var0.x + (float)((float)(var1 * v4) - (float)(var0 * v5));
    this->var10.var0.x = v4;
    this->var10.var0.y = v5;
    v18 = (float)((float)(var1 * v5) + (float)(var0 * v4)) + y;
    v19 = *(float *)&this->var15;
    v20 = (float32x2_t)vrev64_s32(*(int32x2_t *)&this->var10.var2.var0.var1);
    this->var10.var2.var0.var1 = v17;
    this->var10.var2.var0.var2 = v18;
    v21 = *(_QWORD *)&this->var10.var2.var0.var1;
    *(_QWORD *)&this->var10.var1.var0.var1 = v21;
    v22 = vmul_n_f32(vsub_f32((float32x2_t)__PAIR64__(v21, HIDWORD(v21)), v20), v19);
    v23 = *(float32x2_t *)&this->var14;
    LODWORD(v24) = vsub_f32(v23, v22).u32[0];
    HIDWORD(v24) = vadd_f32(v23, v22).i32[1];
    *(_QWORD *)&this->var14 = v24;
  }
  else
  {
    v2 = this->var8.var0;
    *(b2Vec2 *)&this->var10.var1.var0.var1 = v2;
    *(b2Vec2 *)&this->var10.var2.var0.var1 = v2;
    this->var10.var2.var0.var0.y = this->var11.x;
  }
}

b2Body *b2Body::SetAwake(b2Body *this, int a2)
{
  unsigned __int16 var6;

  var6 = this->var6;
  if (a2)
  {
    if ((var6 & 2) == 0)
    {
      this->var6 = var6 | 2;
      this[1].var1 = 0;
    }
  }
  else
  {
    this->var6 = var6 & 0xFFFD;
    this[1].var1 = 0;
    this->var15 = 0;
    this->var16 = 0;
    *(_QWORD *)&this->var14 = 0;
  }
  return this;
}

uint64_t b2Body::CreateFixture(b2Body *this, const b2FixtureDef *a2)
{
  uint64_t v4;
  b2JointEdge *var20;

  if (((uint64_t)this->var17[443].var18 & 2) != 0)
    b2Body::CreateFixture();
  v4 = operator new();
  b2Fixture::b2Fixture((b2Fixture *)v4);
  b2Fixture::Create((b2Fixture *)v4, this, a2);
  if ((this->var6 & 0x20) != 0)
    b2Fixture::CreateProxies((b2Fixture *)v4, (b2ContactManager *)&this->var17[443].var19, &this->var8);
  var20 = this->var20;
  this->var20 = (b2JointEdge *)v4;
  ++LODWORD(this->var21);
  *(_QWORD *)(v4 + 16) = var20;
  *(_QWORD *)(v4 + 24) = this;
  if (*(float *)(v4 + 8) > 0.0)
    b2Body::ResetMassData(this);
  LODWORD(this->var17[443].var18) |= 1u;
  return v4;
}

void sub_208FB7E88(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BD0BA58](v1, 0x10A1C409E444955);
  _Unwind_Resume(a1);
}

uint64_t b2Body::CreateFixture(b2Body *this, b2Shape *a2, float a3)
{
  b2FixtureDef v9;

  *(_QWORD *)&v9.var2 = 1045220557;
  __asm { FMOV            V1.2S, #1.0 }
  *(_QWORD *)&v9.var5 = _D1;
  v9.var0 = a2;
  v9.var1 = 0;
  v9.var4 = a3;
  return b2Body::CreateFixture(this, &v9);
}

void b2Body::DestroyFixture(b2Body *this, b2Fixture *a2)
{
  b2JointEdge *var20;
  b2JointEdge **p_var20;
  b2JointEdge *v6;
  uint64_t v7;
  uint64_t v8;

  if (((uint64_t)this->var17[443].var18 & 2) != 0)
    b2Body::DestroyFixture();
  if (*((b2Body **)a2 + 3) != this)
    b2Body::DestroyFixture();
  if (SLODWORD(this->var21) <= 0)
    b2Body::DestroyFixture();
  p_var20 = &this->var20;
  var20 = this->var20;
  if (!var20)
LABEL_23:
    b2Body::DestroyFixture();
  if (var20 != (b2JointEdge *)a2)
  {
    do
    {
      v6 = var20;
      var20 = var20->var2;
      if (!var20)
        goto LABEL_23;
    }
    while (var20 != (b2JointEdge *)a2);
    p_var20 = &v6->var2;
  }
  *p_var20 = (b2JointEdge *)*((_QWORD *)a2 + 2);
  v7 = *(_QWORD *)&this->var24;
  while (v7)
  {
    v8 = *(_QWORD *)(v7 + 8);
    v7 = *(_QWORD *)(v7 + 24);
    if (*(b2Fixture **)(v8 + 80) == a2 || *(_QWORD *)(v8 + 88) == (_QWORD)a2)
      b2ContactManager::DestroyContact((b2ContactManager *)&this->var17[443].var19, (b2Contact *)v8);
  }
  if ((this->var6 & 0x20) != 0)
    b2Fixture::DestroyProxies(a2, (b2ContactManager *)&this->var17[443].var19);
  (*(void (**)(b2Fixture *))(*(_QWORD *)a2 + 8))(a2);
  --LODWORD(this->var21);
  b2Body::ResetMassData(this);
}

float32x2_t b2Body::SetMassData(uint64_t a1, float *a2, float32x2_t result)
{
  float v3;
  float v4;
  float v5;
  uint64_t v6;
  float v7;
  float v8;
  float v9;
  float v10;
  float v11;
  float32x2_t v12;
  uint64_t v13;
  float32x2_t v14;
  float32x2_t v15;

  if ((*(_BYTE *)(*(_QWORD *)(a1 + 152) + 102936) & 2) != 0)
    b2Body::SetMassData();
  if (*(_DWORD *)(a1 + 20) == 2)
  {
    *(_DWORD *)(a1 + 220) = 0;
    *(_DWORD *)(a1 + 224) = 0;
    v3 = *a2;
    if (*a2 <= 0.0)
      v3 = 1.0;
    *(float *)(a1 + 208) = v3;
    *(float *)(a1 + 212) = 1.0 / v3;
    v4 = a2[3];
    if (v4 > 0.0 && (*(_WORD *)(a1 + 24) & 0x10) == 0)
    {
      v5 = v4 - (float)(v3 * (float)((float)(a2[2] * a2[2]) + (float)(a2[1] * a2[1])));
      *(float *)(a1 + 220) = v5;
      if (v5 <= 0.0)
        b2Body::SetMassData();
      *(float *)(a1 + 224) = 1.0 / v5;
    }
    v6 = *(_QWORD *)(a2 + 1);
    *(_QWORD *)(a1 + 64) = v6;
    v8 = *(float *)(a1 + 40);
    v7 = *(float *)(a1 + 44);
    v9 = *(float *)(a1 + 32) + (float)((float)(v7 * *(float *)&v6) - (float)(v8 * *((float *)&v6 + 1)));
    v10 = (float)((float)(v7 * *((float *)&v6 + 1)) + (float)(v8 * *(float *)&v6)) + *(float *)(a1 + 36);
    v11 = *(float *)(a1 + 136);
    v12 = (float32x2_t)vrev64_s32(*(int32x2_t *)(a1 + 96));
    *(float *)(a1 + 96) = v9;
    *(float *)(a1 + 100) = v10;
    v13 = *(_QWORD *)(a1 + 96);
    *(_QWORD *)(a1 + 80) = v13;
    v14 = vmul_n_f32(vsub_f32((float32x2_t)__PAIR64__(v13, HIDWORD(v13)), v12), v11);
    v15 = *(float32x2_t *)(a1 + 128);
    v12.i32[0] = vsub_f32(v15, v14).u32[0];
    result = vadd_f32(v15, v14);
    v12.i32[1] = result.i32[1];
    *(float32x2_t *)(a1 + 128) = v12;
  }
  return result;
}

float b2Body::GetCharge(b2Body *this)
{
  return this->var28;
}

b2Body *b2Body::SetCharge(b2Body *this, float a2)
{
  this->var28 = a2;
  return this;
}

b2Body *b2Body::SetBullet(b2Body *this, int a2)
{
  __int16 v2;

  if (a2)
    v2 = 8;
  else
    v2 = 0;
  this->var6 = this->var6 & 0xFFF7 | v2;
  return this;
}

uint64_t b2Body::IsBullet(b2Body *this)
{
  return (this->var6 >> 3) & 1;
}

uint64_t b2Body::IsAwake(b2Body *this)
{
  return (this->var6 >> 1) & 1;
}

uint64_t b2Body::IsActive(b2Body *this)
{
  return (this->var6 >> 5) & 1;
}

void b2Body::SetFixedRotation(b2Body *this, int a2)
{
  __int16 v2;

  if (a2)
    v2 = 16;
  else
    v2 = 0;
  this->var6 = this->var6 & 0xFFEF | v2;
  b2Body::ResetMassData(this);
}

uint64_t b2Body::IsFixedRotation(b2Body *this)
{
  return (this->var6 >> 4) & 1;
}

b2Body *b2Body::SetSleepingAllowed(b2Body *this, int a2)
{
  unsigned __int16 var6;

  var6 = this->var6;
  if (a2)
  {
    this->var6 = var6 | 4;
  }
  else
  {
    this->var6 = var6 & 0xFFFB;
    if ((var6 & 2) == 0)
    {
      this->var6 = var6 & 0xFFF9 | 2;
      this[1].var1 = 0;
    }
  }
  return this;
}

uint64_t b2Body::IsSleepingAllowed(b2Body *this)
{
  return (this->var6 >> 2) & 1;
}

uint64_t b2Body::ShouldCollide(b2Body *this, const b2Body *a2)
{
  unsigned int var2;
  unsigned int v3;
  uint64_t v4;

  var2 = a2->var2;
  if ((var2 & this->var3) != 0
    || (v3 = this->var2, (v3 & a2->var3) != 0)
    || (this->var4 & var2) != 0
    || (a2->var4 & v3) != 0)
  {
    if (this->var5 == 2 || a2->var5 == 2)
    {
      v4 = *(_QWORD *)&this->var22;
      if (!v4)
        return 1;
      while (*(const b2Body **)v4 != a2 || *(_BYTE *)(*(_QWORD *)(v4 + 8) + 113))
      {
        v4 = *(_QWORD *)(v4 + 24);
        if (!v4)
          return 1;
      }
    }
  }
  return 0;
}

void b2Body::SetTransform(b2Body *this, const b2Vec2 *a2, float a3)
{
  __float2 v6;
  b2Transform *p_var8;
  b2Vec2 v8;
  float x;
  float y;
  b2JointEdge *i;

  if (((uint64_t)this->var17[443].var18 & 2) != 0)
    b2Body::SetTransform();
  v6 = __sincosf_stret(a3);
  p_var8 = &this->var8;
  if (v6.__cosval != this->var8.var1.var1
    || v6.__sinval != this->var8.var1.var0
    || a2->x != p_var8->var0.x
    || a2->y != this->var8.var0.y)
  {
    this->var8.var1 = (b2Rot)v6;
    v8 = *a2;
    this->var8.var0 = *a2;
    this->var9 = *p_var8;
    x = this->var10.var0.x;
    y = this->var10.var0.y;
    this->var10.var2.var0.var1 = (float)((float)(v6.__cosval * x) - (float)(v6.__sinval * y)) + v8.x;
    this->var10.var2.var0.var2 = (float)((float)(v6.__cosval * y) + (float)(v6.__sinval * x)) + v8.y;
    this->var11.x = a3;
    *(_OWORD *)&this->var10.var1.var0.var1 = *(_OWORD *)&this->var10.var2.var0.var1;
    for (i = this->var20; i; i = i->var2)
      b2Fixture::Synchronize((b2Fixture *)i, (b2ContactManager *)&this->var17[443].var19, &this->var8, &this->var8);
  }
}

void b2Body::SetActive(b2Body *this, int a2)
{
  unsigned __int16 var6;
  b2JointEdge *i;
  b2JointEdge *j;
  uint64_t v6;
  uint64_t v7;

  if (((uint64_t)this->var17[443].var18 & 2) != 0)
    b2Body::SetActive();
  var6 = this->var6;
  if (a2 != (var6 & 0x20) >> 5)
  {
    if (a2)
    {
      this->var6 = var6 | 0x20;
      for (i = this->var20; i; i = i->var2)
        b2Fixture::CreateProxies((b2Fixture *)i, (b2ContactManager *)&this->var17[443].var19, &this->var8);
    }
    else
    {
      this->var6 = var6 & 0xFFDF;
      for (j = this->var20; j; j = j->var2)
        b2Fixture::DestroyProxies((b2Fixture *)j, (b2ContactManager *)&this->var17[443].var19);
      v6 = *(_QWORD *)&this->var24;
      if (v6)
      {
        do
        {
          v7 = *(_QWORD *)(v6 + 24);
          b2ContactManager::DestroyContact((b2ContactManager *)&this->var17[443].var19, *(b2Contact **)(v6 + 8));
          v6 = v7;
        }
        while (v7);
      }
      *(_QWORD *)&this->var24 = 0;
    }
  }
}

void b2ContactManager::b2ContactManager(b2ContactManager *this)
{
  b2DynamicTree::b2DynamicTree((b2ContactManager *)((char *)this + 16));
  *(_OWORD *)((char *)this + 72) = 0u;
  *(_OWORD *)((char *)this + 56) = 0u;
  *((_DWORD *)this + 22) = 1065353216;
  *((_OWORD *)this + 6) = 0u;
  *((_OWORD *)this + 7) = 0u;
  *((_DWORD *)this + 32) = 1065353216;
  *(_OWORD *)((char *)this + 136) = 0u;
  *(_OWORD *)((char *)this + 152) = 0u;
  *((_DWORD *)this + 42) = 1065353216;
  *(_QWORD *)this = &b2ContactManager::b2ContactManager(void)::b2_defaultListener;
  *((_DWORD *)this + 2) = 0;
}

void b2ContactManager::~b2ContactManager(void **this)
{
  std::__hash_table<void *,std::hash<void *>,std::equal_to<void *>,std::allocator<void *>>::~__hash_table((uint64_t)(this + 17));
  std::__hash_table<void *,std::hash<void *>,std::equal_to<void *>,std::allocator<void *>>::~__hash_table((uint64_t)(this + 12));
  std::__hash_table<void *,std::hash<void *>,std::equal_to<void *>,std::allocator<void *>>::~__hash_table((uint64_t)(this + 7));
  b2DynamicTree::~b2DynamicTree(this + 2);
}

uint64_t *b2ContactManager::UnBufferMove(b2ContactManager *this, int a2)
{
  _QWORD *v2;
  uint64_t *result;
  int v4;

  v4 = a2;
  v2 = (_QWORD *)((char *)this + 56);
  result = std::__hash_table<int,std::hash<int>,std::equal_to<int>,std::allocator<int>>::find<int>((_QWORD *)this + 7, &v4);
  if (result)
    return (uint64_t *)std::__hash_table<int,std::hash<int>,std::equal_to<int>,std::allocator<int>>::erase(v2, result);
  return result;
}

_QWORD *b2ContactManager::MoveProxy(uint64_t a1, unsigned int a2, float32x4_t *a3, float32x2_t *a4)
{
  _QWORD *result;
  unsigned int v6;

  v6 = a2;
  result = (_QWORD *)b2DynamicTree::MoveProxy((b2DynamicTree *)(a1 + 16), a2, a3, a4);
  if ((_DWORD)result)
    return std::__hash_table<int,std::hash<int>,std::equal_to<int>,std::allocator<int>>::__emplace_unique_key_args<int,int const&>(a1 + 56, (int *)&v6, &v6);
  return result;
}

_QWORD *b2ContactManager::TouchProxy(b2ContactManager *this, int a2)
{
  int v3;

  v3 = a2;
  return std::__hash_table<int,std::hash<int>,std::equal_to<int>,std::allocator<int>>::__emplace_unique_key_args<int,int const&>((uint64_t)this + 56, &v3, &v3);
}

uint64_t b2ContactManager::CreateProxyId(uint64_t a1, float32x2_t *a2)
{
  unsigned int ProxyId;

  ProxyId = b2DynamicTree::CreateProxyId((b2DynamicTree *)(a1 + 16), a2);
  ++*(_DWORD *)(a1 + 8);
  std::__hash_table<int,std::hash<int>,std::equal_to<int>,std::allocator<int>>::__emplace_unique_key_args<int,int const&>(a1 + 56, (int *)&ProxyId, &ProxyId);
  return ProxyId;
}

uint64_t b2ContactManager::DestroyProxy(b2ContactManager *this, unsigned int a2)
{
  b2ContactManager::UnBufferMove(this, a2);
  --*((_DWORD *)this + 2);
  return b2DynamicTree::DestroyProxy((b2ContactManager *)((char *)this + 16), a2);
}

uint64_t b2ContactManager::DestroyContact(b2ContactManager *this, b2Contact *a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  _QWORD *v6;
  uint64_t *v7;
  b2Contact *v8;
  b2Contact *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  b2Contact *v15;

  v15 = a2;
  v3 = *(_QWORD *)(*((_QWORD *)a2 + 10) + 24);
  v4 = *(_QWORD *)(*((_QWORD *)a2 + 11) + 24);
  v5 = *(_QWORD *)this;
  if (v5 && (*((_BYTE *)a2 + 12) & 2) != 0)
    (*(void (**)(uint64_t))(*(_QWORD *)v5 + 32))(v5);
  v6 = (_QWORD *)((char *)this + 136);
  v7 = std::__hash_table<void *,std::hash<void *>,std::equal_to<void *>,std::allocator<void *>>::find<void *>(v6, &v15);
  if (v7)
    std::__hash_table<int,std::hash<int>,std::equal_to<int>,std::allocator<int>>::erase(v6, v7);
  v9 = v15;
  v10 = *((_QWORD *)v15 + 4);
  if (v10)
    *(_QWORD *)(v10 + 24) = *((_QWORD *)v15 + 5);
  v11 = *((_QWORD *)v9 + 5);
  if (v11)
    *(_QWORD *)(v11 + 16) = v10;
  if ((b2Contact *)((char *)v9 + 16) == *(b2Contact **)(v3 + 200))
    *(_QWORD *)(v3 + 200) = v11;
  v12 = *((_QWORD *)v9 + 8);
  if (v12)
    *(_QWORD *)(v12 + 24) = *((_QWORD *)v9 + 9);
  v13 = *((_QWORD *)v9 + 9);
  if (v13)
    *(_QWORD *)(v13 + 16) = v12;
  if ((b2Contact *)((char *)v9 + 48) == *(b2Contact **)(v4 + 200))
    *(_QWORD *)(v4 + 200) = v13;
  return b2Contact::Destroy(v9, v8);
}

void b2ContactManager::Collide(b2ContactManager *this)
{
  _QWORD *v1;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  const b2Body *v6;
  b2Body *v7;
  unsigned int v8;
  int v9;
  unsigned int v10;
  uint64_t v11;
  float *v12;
  float *v13;
  b2Contact **v14;
  uint64_t v15;
  unint64_t v16;
  unint64_t v17;
  char *v18;
  uint64_t v19;
  unint64_t v20;
  b2Contact **v21;
  char *v22;
  char *v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t v26;
  uint64_t v27;
  uint64_t v28;
  void *v29;
  b2Contact **v30;
  char *v31;
  b2Contact **v32;
  char *v33;

  v31 = 0;
  v32 = 0;
  v33 = 0;
  v1 = (_QWORD *)*((_QWORD *)this + 19);
  if (!v1)
    return;
  do
  {
    v3 = v1[2];
    v5 = *(_QWORD *)(v3 + 80);
    v4 = *(_QWORD *)(v3 + 88);
    v6 = *(const b2Body **)(v5 + 24);
    v7 = *(b2Body **)(v4 + 24);
    if (v6->var5 | v7->var5)
    {
      if ((b2Body::ShouldCollide(v7, v6) & 1) != 0)
      {
        v8 = *(_DWORD *)(*(_QWORD *)(v5 + 48) + 32 * *(int *)(v3 + 96) + 24);
        if ((v8 & 0x80000000) != 0
          || (v9 = *((_DWORD *)this + 9), v9 <= (int)v8)
          || (v10 = *(_DWORD *)(*(_QWORD *)(v4 + 48) + 32 * *(int *)(v3 + 100) + 24), (v10 & 0x80000000) != 0)
          || v9 <= (int)v10)
        {
          __assert_rtn("GetFatAABB", "b2DynamicTree.h", 168, "0 <= proxyId && proxyId < m_nodeCapacity");
        }
        v11 = *((_QWORD *)this + 3);
        v12 = (float *)(v11 + 48 * v8);
        v13 = (float *)(v11 + 48 * v10);
        if ((float)(*v13 - v12[2]) <= 0.0
          && (float)(v13[1] - v12[3]) <= 0.0
          && (float)(*v12 - v13[2]) <= 0.0
          && (float)(v12[1] - v13[3]) <= 0.0)
        {
          b2Contact::Update((b2Contact *)v3, *(b2ContactListener **)this);
          goto LABEL_56;
        }
        v14 = v32;
        if (v32 < (b2Contact **)v33)
          goto LABEL_32;
        v25 = ((char *)v32 - v31) >> 3;
        if ((unint64_t)(v25 + 1) >> 61)
          std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
        v26 = (v33 - v31) >> 2;
        if (v26 <= v25 + 1)
          v26 = v25 + 1;
        if ((unint64_t)(v33 - v31) >= 0x7FFFFFFFFFFFFFF8)
          v17 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v17 = v26;
        if (v17)
          v18 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKPoint>>((uint64_t)&v33, v17);
        else
          v18 = 0;
        v22 = &v18[8 * v25];
        *(_QWORD *)v22 = v3;
        v21 = (b2Contact **)(v22 + 8);
        v23 = (char *)v32;
        if (v32 == (b2Contact **)v31)
        {
LABEL_53:
          v31 = v22;
          v33 = &v18[8 * v17];
          if (v23)
            operator delete(v23);
          goto LABEL_55;
        }
        do
        {
          v28 = *((_QWORD *)v23 - 1);
          v23 -= 8;
          *((_QWORD *)v22 - 1) = v28;
          v22 -= 8;
        }
        while (v23 != v31);
LABEL_52:
        v23 = v31;
        goto LABEL_53;
      }
      v14 = v32;
      if (v32 >= (b2Contact **)v33)
      {
        v19 = ((char *)v32 - v31) >> 3;
        if ((unint64_t)(v19 + 1) >> 61)
LABEL_64:
          std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
        v20 = (v33 - v31) >> 2;
        if (v20 <= v19 + 1)
          v20 = v19 + 1;
        if ((unint64_t)(v33 - v31) >= 0x7FFFFFFFFFFFFFF8)
          v17 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v17 = v20;
        if (v17)
          v18 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKPoint>>((uint64_t)&v33, v17);
        else
          v18 = 0;
        v22 = &v18[8 * v19];
        *(_QWORD *)v22 = v3;
        v21 = (b2Contact **)(v22 + 8);
        v23 = (char *)v32;
        if (v32 == (b2Contact **)v31)
          goto LABEL_53;
        do
        {
          v27 = *((_QWORD *)v23 - 1);
          v23 -= 8;
          *((_QWORD *)v22 - 1) = v27;
          v22 -= 8;
        }
        while (v23 != v31);
        goto LABEL_52;
      }
    }
    else
    {
      v14 = v32;
      if (v32 >= (b2Contact **)v33)
      {
        v15 = ((char *)v32 - v31) >> 3;
        if ((unint64_t)(v15 + 1) >> 61)
          goto LABEL_64;
        v16 = (v33 - v31) >> 2;
        if (v16 <= v15 + 1)
          v16 = v15 + 1;
        if ((unint64_t)(v33 - v31) >= 0x7FFFFFFFFFFFFFF8)
          v17 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v17 = v16;
        if (v17)
          v18 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKPoint>>((uint64_t)&v33, v17);
        else
          v18 = 0;
        v22 = &v18[8 * v15];
        *(_QWORD *)v22 = v3;
        v21 = (b2Contact **)(v22 + 8);
        v23 = (char *)v32;
        if (v32 == (b2Contact **)v31)
          goto LABEL_53;
        do
        {
          v24 = *((_QWORD *)v23 - 1);
          v23 -= 8;
          *((_QWORD *)v22 - 1) = v24;
          v22 -= 8;
        }
        while (v23 != v31);
        goto LABEL_52;
      }
    }
LABEL_32:
    *v14 = (b2Contact *)v3;
    v21 = v14 + 1;
LABEL_55:
    v32 = v21;
LABEL_56:
    v1 = (_QWORD *)*v1;
  }
  while (v1);
  v30 = (b2Contact **)v31;
  v29 = v32;
  if (v31 != (char *)v32)
  {
    do
      b2ContactManager::DestroyContact(this, *v30++);
    while (v30 != v32);
    v29 = v31;
  }
  if (v29)
    operator delete(v29);
}

void sub_208FB8A3C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

b2Body *b2ContactManager::AddPair(b2Body *result, uint64_t a2, uint64_t a3)
{
  b2Body **v3;
  const b2Body **v4;
  b2Body *v5;
  const b2Body *v6;
  b2Body *v9;
  b2Fixture *v10;
  b2Fixture *v11;
  b2Body **v12;
  b2Body *v13;
  b2Body **v14;
  void *var0;
  float var1;
  float var2;
  BOOL v18;
  BOOL v19;
  BOOL v21;
  BOOL v22;
  b2Vec2 v24;
  uint64_t v25;
  b2Body *v26;
  b2Body *v27;
  unsigned int *p_var4;
  b2Rot v29;
  b2Transform *p_var9;
  b2Vec2 v31;
  b2Body *v32;

  v3 = *(b2Body ***)(a2 + 16);
  v4 = *(const b2Body ***)(a3 + 16);
  v5 = v3[3];
  v6 = v4[3];
  if (v5 != v6)
  {
    v9 = result;
    result = (b2Body *)b2Body::ShouldCollide(v3[3], v4[3]);
    if ((_DWORD)result)
    {
      v10 = (b2Fixture *)*(unsigned int *)(a2 + 28);
      v11 = (b2Fixture *)*(unsigned int *)(a3 + 28);
      v12 = *(b2Body ***)&v6->var24;
      if (v12)
      {
        while (1)
        {
          if (*v12 == v5)
          {
            v13 = v12[1];
            v14 = *(b2Body ***)&v13->var10.var1.var0.var1;
            var0 = (void *)v13->var10.var2.var0.var0;
            var1 = v13->var10.var2.var0.var1;
            var2 = v13->var10.var2.var0.var2;
            v18 = v14 == v3 && var0 == v4;
            v19 = v18 && LODWORD(var1) == (_DWORD)v10;
            if (v19 && LODWORD(var2) == (_DWORD)v11)
              break;
            v21 = v14 == (b2Body **)v4 && var0 == v3;
            v22 = v21 && LODWORD(var1) == (_DWORD)v11;
            if (v22 && LODWORD(var2) == (_DWORD)v10)
              break;
          }
          v12 = (b2Body **)v12[3];
          if (!v12)
            goto LABEL_26;
        }
      }
      else
      {
LABEL_26:
        result = (b2Body *)b2Contact::Create((b2Contact *)v3, v10, (b2Contact *)v4, v11);
        v32 = result;
        if (result)
        {
          v24 = *(b2Vec2 *)(*(_QWORD *)&result->var10.var1.var0.var1 + 24);
          v25 = *(_QWORD *)(*(_QWORD *)&result->var10.var2.var0.var0 + 24);
          std::__hash_table<b2Contact *,std::hash<b2Contact *>,std::equal_to<b2Contact *>,std::allocator<b2Contact *>>::__emplace_unique_key_args<b2Contact *,b2Contact * const&>((uint64_t)&v9->var15, &v32, &v32);
          v26 = v32;
          v27 = v32;
          *(_QWORD *)&v32->var4 = v25;
          p_var4 = &v27->var4;
          *(_QWORD *)&v26->var6 = v26;
          v26->var8.var0 = 0;
          v29 = *(b2Rot *)(*(_QWORD *)&v24 + 200);
          v26->var8.var1 = v29;
          if (v29)
            *(_QWORD *)(*(_QWORD *)&v29 + 16) = p_var4;
          *(_QWORD *)(*(_QWORD *)&v24 + 200) = p_var4;
          v26->var9.var0 = v24;
          p_var9 = &v26->var9;
          v26->var9.var1 = (b2Rot)v26;
          v26->var10.var0 = 0;
          v31 = *(b2Vec2 *)(v25 + 200);
          v26->var10.var1.var0.var0 = v31;
          if (v31)
            *(_QWORD *)(*(_QWORD *)&v31 + 16) = p_var9;
          *(_QWORD *)(v25 + 200) = p_var9;
          b2Body::SetAwake(*(b2Body **)&v24, 1);
          return b2Body::SetAwake((b2Body *)v25, 1);
        }
      }
    }
  }
  return result;
}

uint64_t b2ContactManager::ClearContactIslandFlags(uint64_t this)
{
  _QWORD *i;

  for (i = *(_QWORD **)(this + 152); i; i = (_QWORD *)*i)
    *(_DWORD *)(i[2] + 12) &= ~1u;
  return this;
}

uint64_t b2ContactManager::InvalidateContacts(uint64_t this)
{
  _QWORD *i;
  uint64_t v2;

  for (i = *(_QWORD **)(this + 152); i; i = (_QWORD *)*i)
  {
    v2 = i[2];
    *(_DWORD *)(v2 + 12) &= 0xFFFFFFDE;
    *(_QWORD *)(v2 + 168) = 0x3F80000000000000;
  }
  return this;
}

uint64_t b2ContactManager::QueryCallback(b2ContactManager *this, int a2)
{
  uint64_t v2;
  int v3;
  uint64_t v4;
  _DWORD *v5;
  _DWORD *v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  BOOL v14;
  char *v17;
  uint64_t v18;
  uint64_t v20;

  LODWORD(v2) = *((_DWORD *)this + 44);
  if ((_DWORD)v2 != a2)
  {
    if (a2 < 0 || (v3 = *((_DWORD *)this + 9), v3 <= a2))
      b2ContactManager::QueryCallback();
    if ((v2 & 0x80000000) != 0 || v3 <= (int)v2)
      b2ContactManager::QueryCallback();
    v4 = *((_QWORD *)this + 3);
    v5 = *(_DWORD **)(v4 + 48 * a2 + 24);
    v6 = *(_DWORD **)(v4 + 48 * v2 + 24);
    v7 = v6[2];
    v8 = v5[2];
    v9 = v5[3];
    v10 = v6[3] & v8;
    v11 = v6[4] & v8;
    v12 = v5[4] & v7;
    v13 = v9 & v7;
    if (v10)
      v14 = 0;
    else
      v14 = v13 == 0;
    if (!v14 || v11 != 0 || v12 != 0)
    {
      v17 = (char *)this + 96;
      if (a2 >= (int)v2)
        v18 = v2;
      else
        v18 = a2;
      if (a2 <= (int)v2)
        v2 = v2;
      else
        v2 = a2;
      v20 = v2 | (v18 << 32);
      std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__emplace_unique_key_args<unsigned long long,unsigned long long>((uint64_t)v17, (unint64_t *)&v20, &v20);
    }
  }
  return 1;
}

void b2ContactManager::FindMinimumTOI(b2ContactManager *this, b2Contact **a2, float *a3)
{
  _QWORD *i;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  int v11;
  int v12;
  _BOOL4 v13;
  float v14;
  _BOOL4 v15;
  _BOOL4 v16;
  float v18;
  float v19;
  float v20;
  float v21;
  int v22;
  int v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  int v31[2];
  _BYTE v32[16];
  uint64_t v33;
  uint64_t v34;
  _QWORD v35[4];
  __int128 v36;
  __int128 v37;
  __int128 v38;
  int v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  int v43;
  int v44;
  uint64_t v45;

  v45 = *MEMORY[0x24BDAC8D0];
  for (i = (_QWORD *)*((_QWORD *)this + 19); i; i = (_QWORD *)*i)
  {
    v5 = i[2];
    v6 = *(_QWORD *)(v5 + 80);
    v7 = *(_QWORD *)(v5 + 88);
    v8 = *(_QWORD *)(v6 + 24);
    v9 = *(_QWORD *)(v7 + 24);
    v10 = *(_DWORD *)(v9 + 8);
    if ((v10 & *(_DWORD *)(v8 + 12)) == 0)
    {
      v11 = *(_DWORD *)(v8 + 8);
      if ((v11 & *(_DWORD *)(v9 + 12)) == 0 && (*(_DWORD *)(v8 + 16) & v10) == 0 && (*(_DWORD *)(v9 + 16) & v11) == 0)
        continue;
    }
    v12 = *(_DWORD *)(v5 + 12);
    if ((v12 & 4) == 0 || *(int *)(v5 + 168) > 8)
      continue;
    if ((v12 & 0x20) != 0)
    {
      v14 = *(float *)(v5 + 172);
    }
    else
    {
      if (*(_DWORD *)(v8 + 20) != 2 && *(_DWORD *)(v9 + 20) != 2)
        continue;
      v13 = b2Body::IsAwake(*(b2Body **)(v6 + 24)) && *(_DWORD *)(v8 + 20) != 0;
      v15 = b2Body::IsAwake((b2Body *)v9) && *(_DWORD *)(v9 + 20) != 0;
      if (!v13 && !v15)
        continue;
      v16 = (b2Body::IsBullet((b2Body *)v8) & 1) != 0 || *(_DWORD *)(v8 + 20) != 2;
      if ((b2Body::IsBullet((b2Body *)v9) & 1) == 0 && *(_DWORD *)(v9 + 20) == 2 && !v16)
        continue;
      v18 = *(float *)(v8 + 112);
      v19 = *(float *)(v9 + 112);
      if (v18 >= v19)
      {
        if (v19 < v18)
        {
          if (v18 <= 1.0)
            v21 = *(float *)(v8 + 112);
          else
            v21 = 1.0;
          *(float32x4_t *)(v9 + 80) = vmlaq_n_f32(*(float32x4_t *)(v9 + 80), vsubq_f32(*(float32x4_t *)(v9 + 96), *(float32x4_t *)(v9 + 80)), (float)(v21 - v19) / (float)(1.0 - v19));
          *(float *)(v9 + 112) = v21;
        }
        v19 = v18;
      }
      else
      {
        if (v19 <= 1.0)
          v20 = *(float *)(v9 + 112);
        else
          v20 = 1.0;
        *(float32x4_t *)(v8 + 80) = vmlaq_n_f32(*(float32x4_t *)(v8 + 80), vsubq_f32(*(float32x4_t *)(v8 + 96), *(float32x4_t *)(v8 + 80)), (float)(v20 - v18) / (float)(1.0 - v18));
        *(float *)(v8 + 112) = v20;
      }
      if (v19 >= 1.0)
        b2ContactManager::FindMinimumTOI();
      v22 = *(_DWORD *)(v5 + 96);
      v23 = *(_DWORD *)(v5 + 100);
      v33 = 0;
      v34 = 0;
      v35[2] = 0;
      v35[3] = 0;
      b2DistanceProxy::Set((b2DistanceProxy *)v32, *(b2Shape **)(v6 + 32), v22);
      b2DistanceProxy::Set((b2DistanceProxy *)v35, *(b2Shape **)(v7 + 32), v23);
      v24 = *(_OWORD *)(v8 + 64);
      v25 = *(_OWORD *)(v8 + 80);
      v26 = *(_OWORD *)(v8 + 96);
      v39 = *(_DWORD *)(v8 + 112);
      v37 = v25;
      v38 = v26;
      v36 = v24;
      v27 = *(_OWORD *)(v9 + 64);
      v28 = *(_OWORD *)(v9 + 80);
      v29 = *(_OWORD *)(v9 + 96);
      v43 = *(_DWORD *)(v9 + 112);
      v41 = v28;
      v42 = v29;
      v40 = v27;
      v44 = 1065353216;
      b2TimeOfImpact(v31, (uint64_t)v32);
      v14 = 1.0;
      if (v31[0] == 3)
        v14 = fminf(v19 + (float)((float)(1.0 - v19) * *(float *)&v31[1]), 1.0);
      *(float *)(v5 + 172) = v14;
      *(_DWORD *)(v5 + 12) |= 0x20u;
    }
    if (v14 < *a3)
    {
      *a2 = (b2Contact *)v5;
      *a3 = v14;
    }
  }
}

void *b2ContactManager::FindNewContacts(b2Body *this)
{
  b2Vec2 i;
  unsigned int v3;
  void *result;
  _QWORD *j;
  uint64_t v6;
  int y_low;

  std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::clear(&this->var10.var2.var0.var1);
  for (i = this->var10.var1.var0.var0; i; i = **(b2Vec2 **)&i)
  {
    v3 = *(_DWORD *)(*(_QWORD *)&i + 16);
    LODWORD(this->var20) = v3;
    if (v3 != -1)
    {
      if ((v3 & 0x80000000) != 0 || SLODWORD(this->var8.var0.y) <= (signed int)v3)
        b2ContactManager::FindNewContacts();
      b2DynamicTree::Query<b2ContactManager>((int *)&this->var4, (b2ContactManager *)this, (float *)(*(_QWORD *)&this->var6 + 48 * v3));
    }
  }
  result = std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::clear(&this->var9.var1);
  for (j = *(_QWORD **)&this->var11.y; j; j = (_QWORD *)*j)
  {
    v6 = j[2];
    if (v6 < 0 || (y_low = LODWORD(this->var8.var0.y), y_low <= SHIDWORD(v6)))
      b2ContactManager::FindNewContacts();
    if ((v6 & 0x80000000) != 0 || y_low <= (int)v6)
      b2ContactManager::FindNewContacts();
    result = b2ContactManager::AddPair(this, *(_QWORD *)(*(_QWORD *)&this->var6 + 48 * HIDWORD(v6) + 16), *(_QWORD *)(*(_QWORD *)&this->var6 + 48 * v6 + 16));
  }
  return result;
}

void **b2DynamicTree::Query<b2ContactManager>(int *a1, b2ContactManager *this, float *a3)
{
  int v6;
  int v7;
  uint64_t v8;
  _DWORD *v9;
  int v10;
  uint64_t v11;
  float *v12;
  uint64_t v13;
  int v14;
  _DWORD *v15;
  int v16;
  int v17;
  int v18;
  int v19;
  _DWORD *v21;
  _DWORD v22[256];
  int v23;
  int v24;

  v21 = v22;
  v6 = *a1;
  v24 = 256;
  v22[0] = v6;
  v7 = 1;
  do
  {
    v8 = (v7 - 1);
    v23 = v8;
    v9 = v21;
    v10 = v21[v8];
    if (v10 != -1)
    {
      v11 = *((_QWORD *)a1 + 1);
      v12 = (float *)(v11 + 48 * v10);
      if ((float)(*a3 - v12[2]) <= 0.0
        && (float)(a3[1] - v12[3]) <= 0.0
        && (float)(*v12 - a3[2]) <= 0.0
        && (float)(v12[1] - a3[3]) <= 0.0)
      {
        v13 = v11 + 48 * v10;
        v16 = *(_DWORD *)(v13 + 36);
        v15 = (_DWORD *)(v13 + 36);
        v14 = v16;
        if (v16 == -1)
        {
          b2ContactManager::QueryCallback(this, v21[v8]);
          LODWORD(v8) = v23;
        }
        else
        {
          v17 = v24;
          if (v7 <= v24)
          {
            v21[v8] = v14;
          }
          else
          {
            v24 *= 2;
            v21 = b2Alloc(8 * v17);
            memcpy(v21, v9, 4 * v23);
            if (v9 != v22)
              b2Free(v9);
            v9 = v21;
            v21[v23] = *v15;
          }
          v18 = v23 + 1;
          v23 = v18;
          v19 = v24;
          if (v18 >= v24)
          {
            v24 *= 2;
            v21 = b2Alloc(8 * v19);
            memcpy(v21, v9, 4 * v23);
            if (v9 != v22)
              b2Free(v9);
            v9 = v21;
            v18 = v23;
          }
          v9[v18] = *(_DWORD *)(v11 + 48 * v10 + 40);
          LODWORD(v8) = ++v23;
        }
      }
    }
    v7 = v8;
  }
  while ((int)v8 > 0);
  return b2GrowableStack<int,256>::~b2GrowableStack((void **)&v21);
}

void sub_208FB9290(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9)
{
  b2GrowableStack<int,256>::~b2GrowableStack(&a9);
  _Unwind_Resume(a1);
}

void b2ContactListener::~b2ContactListener(b2ContactListener *this)
{
  JUMPOUT(0x20BD0BA58);
}

uint64_t *std::__hash_table<int,std::hash<int>,std::equal_to<int>,std::allocator<int>>::find<int>(_QWORD *a1, int *a2)
{
  int8x8_t v2;
  unint64_t v3;
  uint8x8_t v4;
  unint64_t v5;
  uint64_t **v6;
  uint64_t *result;
  unint64_t v8;

  v2 = (int8x8_t)a1[1];
  if (!*(_QWORD *)&v2)
    return 0;
  v3 = *a2;
  v4 = (uint8x8_t)vcnt_s8(v2);
  v4.i16[0] = vaddlv_u8(v4);
  if (v4.u32[0] > 1uLL)
  {
    v5 = *a2;
    if (*(_QWORD *)&v2 <= v3)
      v5 = v3 % *(_QWORD *)&v2;
  }
  else
  {
    v5 = (*(_QWORD *)&v2 - 1) & v3;
  }
  v6 = *(uint64_t ***)(*a1 + 8 * v5);
  if (!v6)
    return 0;
  for (result = *v6; result; result = (uint64_t *)*result)
  {
    v8 = result[1];
    if (v8 == v3)
    {
      if (*((_DWORD *)result + 4) == (_DWORD)v3)
        return result;
    }
    else
    {
      if (v4.u32[0] > 1uLL)
      {
        if (v8 >= *(_QWORD *)&v2)
          v8 %= *(_QWORD *)&v2;
      }
      else
      {
        v8 &= *(_QWORD *)&v2 - 1;
      }
      if (v8 != v5)
        return 0;
    }
  }
  return result;
}

uint64_t std::__hash_table<int,std::hash<int>,std::equal_to<int>,std::allocator<int>>::erase(_QWORD *a1, uint64_t *a2)
{
  uint64_t v2;
  void *v3;
  void *__p;

  v2 = *a2;
  std::__hash_table<int,std::hash<int>,std::equal_to<int>,std::allocator<int>>::remove(a1, a2, (uint64_t)&__p);
  v3 = __p;
  __p = 0;
  if (v3)
    operator delete(v3);
  return v2;
}

_QWORD *std::__hash_table<int,std::hash<int>,std::equal_to<int>,std::allocator<int>>::remove@<X0>(_QWORD *result@<X0>, _QWORD *a2@<X1>, uint64_t a3@<X8>)
{
  int8x8_t v3;
  unint64_t v4;
  uint8x8_t v5;
  _QWORD *v6;
  _QWORD *v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;

  v3 = (int8x8_t)result[1];
  v4 = a2[1];
  v5 = (uint8x8_t)vcnt_s8(v3);
  v5.i16[0] = vaddlv_u8(v5);
  if (v5.u32[0] > 1uLL)
  {
    if (v4 >= *(_QWORD *)&v3)
      v4 %= *(_QWORD *)&v3;
  }
  else
  {
    v4 &= *(_QWORD *)&v3 - 1;
  }
  v6 = *(_QWORD **)(*result + 8 * v4);
  do
  {
    v7 = v6;
    v6 = (_QWORD *)*v6;
  }
  while (v6 != a2);
  if (v7 == result + 2)
    goto LABEL_18;
  v8 = v7[1];
  if (v5.u32[0] > 1uLL)
  {
    if (v8 >= *(_QWORD *)&v3)
      v8 %= *(_QWORD *)&v3;
  }
  else
  {
    v8 &= *(_QWORD *)&v3 - 1;
  }
  if (v8 != v4)
  {
LABEL_18:
    if (!*a2)
      goto LABEL_19;
    v9 = *(_QWORD *)(*a2 + 8);
    if (v5.u32[0] > 1uLL)
    {
      if (v9 >= *(_QWORD *)&v3)
        v9 %= *(_QWORD *)&v3;
    }
    else
    {
      v9 &= *(_QWORD *)&v3 - 1;
    }
    if (v9 != v4)
LABEL_19:
      *(_QWORD *)(*result + 8 * v4) = 0;
  }
  v10 = *a2;
  if (*a2)
  {
    v11 = *(_QWORD *)(v10 + 8);
    if (v5.u32[0] > 1uLL)
    {
      if (v11 >= *(_QWORD *)&v3)
        v11 %= *(_QWORD *)&v3;
    }
    else
    {
      v11 &= *(_QWORD *)&v3 - 1;
    }
    if (v11 != v4)
    {
      *(_QWORD *)(*result + 8 * v11) = v7;
      v10 = *a2;
    }
  }
  *v7 = v10;
  *a2 = 0;
  --result[3];
  *(_QWORD *)a3 = a2;
  *(_QWORD *)(a3 + 8) = result + 2;
  *(_BYTE *)(a3 + 16) = 1;
  return result;
}

_QWORD *std::__hash_table<int,std::hash<int>,std::equal_to<int>,std::allocator<int>>::__emplace_unique_key_args<int,int const&>(uint64_t a1, int *a2, _DWORD *a3)
{
  unint64_t v3;
  unint64_t v6;
  unint64_t v7;
  uint8x8_t v8;
  void **v9;
  _QWORD *v10;
  unint64_t v11;
  float v12;
  float v13;
  _BOOL8 v14;
  unint64_t v15;
  unint64_t v16;
  size_t v17;
  uint64_t v18;
  _QWORD *v19;
  unint64_t v20;

  v6 = *a2;
  v7 = *(_QWORD *)(a1 + 8);
  if (v7)
  {
    v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      v3 = *a2;
      if (v7 <= v6)
        v3 = v6 % v7;
    }
    else
    {
      v3 = (v7 - 1) & v6;
    }
    v9 = *(void ***)(*(_QWORD *)a1 + 8 * v3);
    if (v9)
    {
      v10 = *v9;
      if (*v9)
      {
        do
        {
          v11 = v10[1];
          if (v11 == v6)
          {
            if (*((_DWORD *)v10 + 4) == (_DWORD)v6)
              return v10;
          }
          else
          {
            if (v8.u32[0] > 1uLL)
            {
              if (v11 >= v7)
                v11 %= v7;
            }
            else
            {
              v11 &= v7 - 1;
            }
            if (v11 != v3)
              break;
          }
          v10 = (_QWORD *)*v10;
        }
        while (v10);
      }
    }
  }
  v10 = operator new(0x18uLL);
  *v10 = 0;
  v10[1] = v6;
  *((_DWORD *)v10 + 4) = *a3;
  v12 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v13 = *(float *)(a1 + 32);
  if (!v7 || (float)(v13 * (float)v7) < v12)
  {
    v14 = 1;
    if (v7 >= 3)
      v14 = (v7 & (v7 - 1)) != 0;
    v15 = v14 | (2 * v7);
    v16 = vcvtps_u32_f32(v12 / v13);
    if (v15 <= v16)
      v17 = v16;
    else
      v17 = v15;
    std::__hash_table<void *,std::hash<void *>,std::equal_to<void *>,std::allocator<void *>>::__rehash<true>(a1, v17);
    v7 = *(_QWORD *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= v6)
        v3 = v6 % v7;
      else
        v3 = v6;
    }
    else
    {
      v3 = (v7 - 1) & v6;
    }
  }
  v18 = *(_QWORD *)a1;
  v19 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v3);
  if (v19)
  {
    *v10 = *v19;
LABEL_38:
    *v19 = v10;
    goto LABEL_39;
  }
  *v10 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = v10;
  *(_QWORD *)(v18 + 8 * v3) = a1 + 16;
  if (*v10)
  {
    v20 = *(_QWORD *)(*v10 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v20 >= v7)
        v20 %= v7;
    }
    else
    {
      v20 &= v7 - 1;
    }
    v19 = (_QWORD *)(*(_QWORD *)a1 + 8 * v20);
    goto LABEL_38;
  }
LABEL_39:
  ++*(_QWORD *)(a1 + 24);
  return v10;
}

void sub_208FB9700(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

_QWORD *std::__hash_table<b2Contact *,std::hash<b2Contact *>,std::equal_to<b2Contact *>,std::allocator<b2Contact *>>::__emplace_unique_key_args<b2Contact *,b2Contact * const&>(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  unint64_t v3;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint8x8_t v10;
  _QWORD **v11;
  _QWORD *i;
  unint64_t v13;
  float v14;
  float v15;
  _BOOL8 v16;
  unint64_t v17;
  unint64_t v18;
  size_t v19;
  uint64_t v20;
  _QWORD *v21;
  unint64_t v22;

  v6 = 0x9DDFEA08EB382D69 * ((8 * *a2 + 8) ^ HIDWORD(*a2));
  v7 = 0x9DDFEA08EB382D69 * (HIDWORD(*a2) ^ (v6 >> 47) ^ v6);
  v8 = 0x9DDFEA08EB382D69 * (v7 ^ (v7 >> 47));
  v9 = *(_QWORD *)(a1 + 8);
  if (v9)
  {
    v10 = (uint8x8_t)vcnt_s8((int8x8_t)v9);
    v10.i16[0] = vaddlv_u8(v10);
    if (v10.u32[0] > 1uLL)
    {
      v3 = 0x9DDFEA08EB382D69 * (v7 ^ (v7 >> 47));
      if (v8 >= v9)
        v3 = v8 % v9;
    }
    else
    {
      v3 = v8 & (v9 - 1);
    }
    v11 = *(_QWORD ***)(*(_QWORD *)a1 + 8 * v3);
    if (v11)
    {
      for (i = *v11; i; i = (_QWORD *)*i)
      {
        v13 = i[1];
        if (v13 == v8)
        {
          if (i[2] == *a2)
            return i;
        }
        else
        {
          if (v10.u32[0] > 1uLL)
          {
            if (v13 >= v9)
              v13 %= v9;
          }
          else
          {
            v13 &= v9 - 1;
          }
          if (v13 != v3)
            break;
        }
      }
    }
  }
  i = operator new(0x18uLL);
  *i = 0;
  i[1] = v8;
  i[2] = *a3;
  v14 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v15 = *(float *)(a1 + 32);
  if (!v9 || (float)(v15 * (float)v9) < v14)
  {
    v16 = 1;
    if (v9 >= 3)
      v16 = (v9 & (v9 - 1)) != 0;
    v17 = v16 | (2 * v9);
    v18 = vcvtps_u32_f32(v14 / v15);
    if (v17 <= v18)
      v19 = v18;
    else
      v19 = v17;
    std::__hash_table<void *,std::hash<void *>,std::equal_to<void *>,std::allocator<void *>>::__rehash<true>(a1, v19);
    v9 = *(_QWORD *)(a1 + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v8 >= v9)
        v3 = v8 % v9;
      else
        v3 = v8;
    }
    else
    {
      v3 = (v9 - 1) & v8;
    }
  }
  v20 = *(_QWORD *)a1;
  v21 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v3);
  if (v21)
  {
    *i = *v21;
LABEL_38:
    *v21 = i;
    goto LABEL_39;
  }
  *i = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = i;
  *(_QWORD *)(v20 + 8 * v3) = a1 + 16;
  if (*i)
  {
    v22 = *(_QWORD *)(*i + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v22 >= v9)
        v22 %= v9;
    }
    else
    {
      v22 &= v9 - 1;
    }
    v21 = (_QWORD *)(*(_QWORD *)a1 + 8 * v22);
    goto LABEL_38;
  }
LABEL_39:
  ++*(_QWORD *)(a1 + 24);
  return i;
}

void sub_208FB9950(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

_QWORD *std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__emplace_unique_key_args<unsigned long long,unsigned long long>(uint64_t a1, unint64_t *a2, _QWORD *a3)
{
  unint64_t v3;
  unint64_t v6;
  unint64_t v7;
  uint8x8_t v8;
  _QWORD **v9;
  _QWORD *i;
  unint64_t v11;
  float v12;
  float v13;
  _BOOL8 v14;
  unint64_t v15;
  unint64_t v16;
  size_t v17;
  uint64_t v18;
  _QWORD *v19;
  unint64_t v20;

  v6 = *a2;
  v7 = *(_QWORD *)(a1 + 8);
  if (v7)
  {
    v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      v3 = *a2;
      if (v6 >= v7)
        v3 = v6 % v7;
    }
    else
    {
      v3 = (v7 - 1) & v6;
    }
    v9 = *(_QWORD ***)(*(_QWORD *)a1 + 8 * v3);
    if (v9)
    {
      for (i = *v9; i; i = (_QWORD *)*i)
      {
        v11 = i[1];
        if (v11 == v6)
        {
          if (i[2] == v6)
            return i;
        }
        else
        {
          if (v8.u32[0] > 1uLL)
          {
            if (v11 >= v7)
              v11 %= v7;
          }
          else
          {
            v11 &= v7 - 1;
          }
          if (v11 != v3)
            break;
        }
      }
    }
  }
  i = operator new(0x18uLL);
  *i = 0;
  i[1] = v6;
  i[2] = *a3;
  v12 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v13 = *(float *)(a1 + 32);
  if (!v7 || (float)(v13 * (float)v7) < v12)
  {
    v14 = 1;
    if (v7 >= 3)
      v14 = (v7 & (v7 - 1)) != 0;
    v15 = v14 | (2 * v7);
    v16 = vcvtps_u32_f32(v12 / v13);
    if (v15 <= v16)
      v17 = v16;
    else
      v17 = v15;
    std::__hash_table<void *,std::hash<void *>,std::equal_to<void *>,std::allocator<void *>>::__rehash<true>(a1, v17);
    v7 = *(_QWORD *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v6 >= v7)
        v3 = v6 % v7;
      else
        v3 = v6;
    }
    else
    {
      v3 = (v7 - 1) & v6;
    }
  }
  v18 = *(_QWORD *)a1;
  v19 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v3);
  if (v19)
  {
    *i = *v19;
LABEL_38:
    *v19 = i;
    goto LABEL_39;
  }
  *i = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = i;
  *(_QWORD *)(v18 + 8 * v3) = a1 + 16;
  if (*i)
  {
    v20 = *(_QWORD *)(*i + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v20 >= v7)
        v20 %= v7;
    }
    else
    {
      v20 &= v7 - 1;
    }
    v19 = (_QWORD *)(*(_QWORD *)a1 + 8 * v20);
    goto LABEL_38;
  }
LABEL_39:
  ++*(_QWORD *)(a1 + 24);
  return i;
}

void sub_208FB9B68(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

_QWORD *std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::clear(_QWORD *result)
{
  _QWORD *v1;
  _QWORD *v2;
  uint64_t v3;
  uint64_t i;

  if (result[3])
  {
    v1 = result;
    result = (_QWORD *)result[2];
    if (result)
    {
      do
      {
        v2 = (_QWORD *)*result;
        operator delete(result);
        result = v2;
      }
      while (v2);
    }
    v1[2] = 0;
    v3 = v1[1];
    if (v3)
    {
      for (i = 0; i != v3; ++i)
        *(_QWORD *)(*v1 + 8 * i) = 0;
    }
    v1[3] = 0;
  }
  return result;
}

void **b2GrowableStack<int,256>::~b2GrowableStack(void **a1)
{
  void **v2;
  void **v3;

  v3 = a1 + 1;
  v2 = (void **)*a1;
  if (v2 != v3)
  {
    b2Free(v2);
    *a1 = 0;
  }
  return a1;
}

void b2Fixture::b2Fixture(b2Fixture *this)
{
  *(_QWORD *)this = &off_24C0E89E8;
  *((_DWORD *)this + 2) = 0;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
}

void b2Fixture::~b2Fixture(b2Fixture *this)
{
  uint64_t v2;
  void *v3;

  *(_QWORD *)this = &off_24C0E89E8;
  v2 = *((_QWORD *)this + 4);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  v3 = (void *)*((_QWORD *)this + 6);
  if (v3)
  {
    *((_QWORD *)this + 7) = v3;
    operator delete(v3);
  }
}

{
  b2Fixture::~b2Fixture(this);
  JUMPOUT(0x20BD0BA58);
}

float b2Fixture::Create(b2Fixture *this, b2Body *a2, const b2FixtureDef *a3)
{
  b2Shape *var0;
  float result;

  var0 = a3->var0;
  *((_QWORD *)this + 9) = a3->var1;
  *((_QWORD *)this + 5) = *(_QWORD *)&a3->var2;
  *((_QWORD *)this + 2) = 0;
  *((_QWORD *)this + 3) = a2;
  *((_QWORD *)this + 4) = (*(uint64_t (**)(b2Shape *))(*(_QWORD *)var0 + 16))(var0);
  result = a3->var4;
  *((float *)this + 2) = result;
  return result;
}

void b2Fixture::CreateProxies(b2Fixture *this, b2ContactManager *a2, const b2Transform *a3)
{
  int v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  float32x2_t *v10;

  v6 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 4) + 24))(*((_QWORD *)this + 4));
  std::vector<b2FixtureProxy>::resize((uint64_t)this + 48, v6);
  if (v6 >= 1)
  {
    v7 = 0;
    v8 = 0;
    v9 = 32 * v6;
    do
    {
      v10 = (float32x2_t *)(*((_QWORD *)this + 6) + v7);
      v10[3].i32[1] = v8;
      (*(void (**)(_QWORD, float32x2_t *, const b2Transform *, uint64_t))(**((_QWORD **)this + 4) + 56))(*((_QWORD *)this + 4), v10, a3, v8);
      v10[2] = (float32x2_t)this;
      v10[3].i32[0] = b2ContactManager::CreateProxyId((uint64_t)a2, v10);
      v8 = (v8 + 1);
      v7 += 32;
    }
    while (v9 != v7);
  }
}

void std::vector<b2FixtureProxy>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v2;

  v2 = (uint64_t)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 5;
  if (a2 <= v2)
  {
    if (a2 < v2)
      *(_QWORD *)(a1 + 8) = *(_QWORD *)a1 + 32 * a2;
  }
  else
  {
    std::vector<b2FixtureProxy>::__append((void **)a1, a2 - v2);
  }
}

b2Fixture *b2Fixture::DestroyProxies(b2Fixture *this, b2ContactManager *a2)
{
  b2Fixture *v2;
  uint64_t v3;
  uint64_t v4;

  v2 = this;
  v3 = *((_QWORD *)this + 6);
  v4 = *((_QWORD *)this + 7);
  if (v3 != v4)
  {
    do
    {
      this = (b2Fixture *)b2ContactManager::DestroyProxy(a2, *(_DWORD *)(v3 + 24));
      *(_DWORD *)(v3 + 24) = -1;
      v3 += 32;
    }
    while (v3 != v4);
    v3 = *((_QWORD *)v2 + 6);
  }
  *((_QWORD *)v2 + 7) = v3;
  return this;
}

b2Fixture *b2Fixture::Synchronize(b2Fixture *this, b2ContactManager *a2, const b2Transform *a3, const b2Transform *a4)
{
  unint64_t v4;
  b2Fixture *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  float32x2_t v13;
  float32x2_t v14;
  float32x2_t v15;
  float32x2_t v16;
  float32x2_t v17;

  v4 = *((_QWORD *)this + 7) - *((_QWORD *)this + 6);
  if (v4 && (int)(v4 >> 5) >= 1)
  {
    v8 = this;
    v9 = 0;
    v10 = 0;
    v11 = v4 & 0x1FFFFFFFE0;
    do
    {
      v12 = *((_QWORD *)v8 + 6) + v9;
      (*(void (**)(_QWORD, float32x2_t *, const b2Transform *, uint64_t))(**((_QWORD **)v8 + 4) + 56))(*((_QWORD *)v8 + 4), &v16, a3, v10);
      (*(void (**)(_QWORD, float32x2_t *, const b2Transform *, uint64_t))(**((_QWORD **)v8 + 4) + 56))(*((_QWORD *)v8 + 4), &v14, a4, v10);
      *(int8x8_t *)v12 = vbsl_s8((int8x8_t)vcgt_f32(v14, v16), (int8x8_t)v16, (int8x8_t)v14);
      *(int8x8_t *)(v12 + 8) = vbsl_s8((int8x8_t)vcgt_f32(v17, v15), (int8x8_t)v17, (int8x8_t)v15);
      v13 = vsub_f32((float32x2_t)a4->var0, (float32x2_t)a3->var0);
      this = (b2Fixture *)b2ContactManager::MoveProxy((uint64_t)a2, *(_DWORD *)(v12 + 24), (float32x4_t *)v12, &v13);
      v10 = (v10 + 1);
      v9 += 32;
    }
    while (v11 != v9);
  }
  return this;
}

b2Fixture *b2Fixture::Refilter(b2Fixture *this)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  b2ContactManager *v5;

  v1 = *((_QWORD *)this + 3);
  if (v1)
  {
    v2 = *(_QWORD *)(v1 + 152);
    if (v2)
    {
      v3 = *((_QWORD *)this + 6);
      v4 = *((_QWORD *)this + 7);
      if (v3 != v4)
      {
        v5 = (b2ContactManager *)(v2 + 102944);
        do
        {
          this = (b2Fixture *)b2ContactManager::TouchProxy(v5, *(_DWORD *)(v3 + 24));
          v3 += 32;
        }
        while (v3 != v4);
      }
    }
  }
  return this;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<b2FixtureProxy>>(uint64_t a1, unint64_t a2)
{
  if (a2 >> 59)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(32 * a2);
}

void std::vector<b2FixtureProxy>::__append(void **a1, unint64_t a2)
{
  uint64_t v4;
  _BYTE *v5;
  _BYTE *v6;
  char *v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char *v13;
  char *v14;
  char *v15;
  char *v16;
  char *v17;
  char *v18;
  __int128 v19;

  v6 = a1[2];
  v4 = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(char **)(v4 - 8);
  if (a2 <= (v6 - v7) >> 5)
  {
    if (a2)
    {
      bzero(*(void **)(v4 - 8), 32 * a2);
      v7 += 32 * a2;
    }
    a1[1] = v7;
  }
  else
  {
    v8 = v7 - (_BYTE *)*a1;
    v9 = a2 + (v8 >> 5);
    if (v9 >> 59)
      std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
    v10 = v8 >> 5;
    v11 = v5 - (_BYTE *)*a1;
    if (v11 >> 4 > v9)
      v9 = v11 >> 4;
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFE0)
      v12 = 0x7FFFFFFFFFFFFFFLL;
    else
      v12 = v9;
    if (v12)
      v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<b2FixtureProxy>>(v4, v12);
    else
      v13 = 0;
    v14 = &v13[32 * v10];
    v15 = &v13[32 * v12];
    bzero(v14, 32 * a2);
    v16 = &v14[32 * a2];
    v18 = (char *)*a1;
    v17 = (char *)a1[1];
    if (v17 != *a1)
    {
      do
      {
        v19 = *((_OWORD *)v17 - 1);
        *((_OWORD *)v14 - 2) = *((_OWORD *)v17 - 2);
        *((_OWORD *)v14 - 1) = v19;
        v14 -= 32;
        v17 -= 32;
      }
      while (v17 != v18);
      v17 = (char *)*a1;
    }
    *a1 = v14;
    a1[1] = v16;
    a1[2] = v15;
    if (v17)
      operator delete(v17);
  }
}

uint64_t PKGetLinkedOnOrAfter()
{
  dyld_get_active_platform();
  return dyld_program_sdk_at_least();
}

void b2Island::b2Island(b2Island *this, int a2, int a3, int a4, b2StackAllocator *a5, b2ContactListener *a6)
{
  void **v12;
  void **v13;

  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 4) = 0u;
  v12 = (void **)((char *)this + 64);
  *((_QWORD *)this + 10) = 0;
  v13 = (void **)((char *)this + 40);
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  std::vector<PKPoint>::reserve((void **)this + 2, a2);
  std::vector<PKPoint>::reserve(v13, a3);
  std::vector<PKPoint>::reserve(v12, a4);
  *(_QWORD *)this = a5;
  *((_QWORD *)this + 1) = a6;
  *((_QWORD *)this + 12) = b2StackAllocator::Allocate(a5, 16 * a2);
  *((_QWORD *)this + 11) = b2StackAllocator::Allocate(*(b2StackAllocator **)this, 16 * a2);
}

void sub_208FBA1D8(_Unwind_Exception *a1)
{
  uint64_t v1;
  void **v2;
  void **v3;
  void **v4;
  void *v6;

  v6 = *v4;
  if (*v4)
  {
    *(_QWORD *)(v1 + 72) = v6;
    operator delete(v6);
  }
  b2Island::b2Island(v3, v2, v1);
  _Unwind_Resume(a1);
}

void b2Island::~b2Island(b2Island *this)
{
  void *v2;
  void *v3;
  void *v4;

  b2StackAllocator::Free(*(void ***)this, *((void **)this + 11));
  b2StackAllocator::Free(*(void ***)this, *((void **)this + 12));
  v2 = (void *)*((_QWORD *)this + 8);
  if (v2)
  {
    *((_QWORD *)this + 9) = v2;
    operator delete(v2);
  }
  v3 = (void *)*((_QWORD *)this + 5);
  if (v3)
  {
    *((_QWORD *)this + 6) = v3;
    operator delete(v3);
  }
  v4 = (void *)*((_QWORD *)this + 2);
  if (v4)
  {
    *((_QWORD *)this + 3) = v4;
    operator delete(v4);
  }
}

void b2Island::Solve(uint64_t *a1, int a2, __int128 *a3, PKCAether *a4, double a5, float a6, float a7, float a8, float a9, int a10, char *a11)
{
  float32x4_t v20;
  __n128 v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;
  __int128 v27;
  float v28;
  __n128 v29;
  double v30;
  float v31;
  float v32;
  float v33;
  float v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  _QWORD *v38;
  _QWORD *v39;
  int v40;
  _QWORD *v41;
  _QWORD *v42;
  uint64_t v43;
  unint64_t v44;
  float32x4_t v45;
  float v46;
  float32x2_t v47;
  float v48;
  unint64_t v49;
  float v50;
  uint64_t v51;
  int v52;
  _BOOL4 v53;
  _QWORD *v54;
  _QWORD *v55;
  int v56;
  char v57;
  uint64_t v58;
  unint64_t v59;
  uint64_t v60;
  __float2 v61;
  float v62;
  float v63;
  float v64;
  b2Body **v65;
  b2Body **v66;
  float v67;
  float v68;
  b2Body **v69;
  b2Body *v70;
  float v71;
  char v72;
  char v73;
  char v74;
  __n128 v75;
  __n128 v76;
  float32x4_t v77;
  __int128 v78;
  void **v79[11];
  __int128 v80;
  uint64_t v81;
  int v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  float v86;
  __int128 v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  float32x4_t v91;
  void *v92;
  void *v93;

  PKCAether::Evaluator::Evaluator((PKCAether::Evaluator *)&v91, a4);
  v22 = a1[2];
  if (a1[3] != v22)
  {
    v23 = 0;
    v24 = 0;
    v25 = 0;
    do
    {
      v26 = *(_QWORD *)(v22 + v24);
      v27 = *(_OWORD *)(v26 + 96);
      v21.n128_u64[0] = *(_QWORD *)(v26 + 128);
      v28 = *(float *)(v26 + 136);
      *(_OWORD *)(v26 + 80) = v27;
      if (*(_DWORD *)(v26 + 20) == 2)
      {
        v78 = v27;
        v20.i64[0] = *(_QWORD *)(v26 + 32);
        v29 = v21;
        v29.n128_u32[2] = 0;
        v77 = v20;
        v75 = v21;
        v76 = v29;
        PKCAether::Evaluator::evalVelocity((uint64_t)&v91, *(_DWORD *)(v26 + 4), v20, v29, *(float *)(v26 + 208), *(float *)(v26 + 216), a5);
        if (v20.f32[0] >= 3.4028e38)
        {
          if (*(_BYTE *)v26)
            v32 = 1.0;
          else
            v32 = 0.0;
          LODWORD(v30) = *(_DWORD *)(v26 + 208);
          PKCAether::Evaluator::evalForce(&v91, *(_DWORD *)(v26 + 4), v32, v77, v76, v30, *(float *)(v26 + 216), a5);
          v31 = *(float *)a3;
          v21.n128_u64[1] = v75.n128_u64[1];
          v21.n128_u64[0] = (unint64_t)vadd_f32((float32x2_t)v75.n128_u64[0], vmul_n_f32(vadd_f32(*(float32x2_t *)v20.f32, *(float32x2_t *)(v26 + 140)), *(float *)a3 * *(float *)(v26 + 212)));
        }
        else
        {
          v31 = *(float *)a3;
          v21.n128_u64[0] = v20.i64[0];
        }
        v27 = v78;
        v33 = *(float *)(v26 + 228);
        if ((LODWORD(v33) & 0x60000000) != 0)
          v21.n128_u64[0] = (unint64_t)vmul_n_f32((float32x2_t)v21.n128_u64[0], 1.0 / (float)((float)(v31 * v33) + 1.0));
        v28 = v28 + (float)((float)(v31 * *(float *)(v26 + 224)) * *(float *)(v26 + 148));
        v34 = *(float *)(v26 + 232);
        if ((LODWORD(v34) & 0x60000000) != 0)
          v28 = v28 * (float)(1.0 / (float)((float)(v31 * v34) + 1.0));
      }
      *(_OWORD *)(a1[11] + v23) = v27;
      v35 = a1[12] + v23;
      *(_QWORD *)v35 = v21.n128_u64[0];
      *(float *)(v35 + 12) = v28;
      ++v25;
      v22 = a1[2];
      v24 += 8;
      v23 += 16;
    }
    while (v25 < (a1[3] - v22) >> 3);
  }
  v87 = *a3;
  v36 = a1[11];
  v37 = a1[12];
  v88 = *((_QWORD *)a3 + 2);
  v89 = v36;
  v90 = v37;
  v80 = *a3;
  v81 = *((_QWORD *)a3 + 2);
  v82 = (unint64_t)(a1[6] - a1[5]) >> 3;
  v83 = v36;
  v84 = v37;
  v85 = *a1;
  v86 = a6;
  b2ContactSolver::b2ContactSolver(v79, &v80, a1 + 2, a1 + 5);
  b2ContactSolver::InitializeVelocityConstraints((b2ContactSolver *)v79);
  if (*((_BYTE *)a3 + 20))
    b2ContactSolver::WarmStart((uint64_t)v79);
  v38 = (_QWORD *)a1[8];
  v39 = (_QWORD *)a1[9];
  while (v38 != v39)
  {
    (*(void (**)(_QWORD, __int128 *))(*(_QWORD *)*v38 + 48))(*v38, &v87);
    ++v38;
  }
  if (*((int *)a3 + 3) >= 1)
  {
    v40 = 0;
    do
    {
      v41 = (_QWORD *)a1[8];
      v42 = (_QWORD *)a1[9];
      while (v41 != v42)
      {
        (*(void (**)(_QWORD, __int128 *))(*(_QWORD *)*v41 + 56))(*v41, &v87);
        ++v41;
      }
      b2ContactSolver::SolveVelocityConstraints((uint64_t)v79);
      ++v40;
    }
    while (v40 < *((_DWORD *)a3 + 3));
  }
  b2ContactSolver::StoreImpulses((uint64_t)v79);
  v43 = a1[3];
  if (v43 == a1[2])
  {
    v51 = a1[3];
  }
  else
  {
    v44 = 0;
    do
    {
      v45 = *(float32x4_t *)(a1[12] + 16 * v44);
      v46 = *(float *)a3;
      v47 = (float32x2_t)vmulq_f32(v45, v45).u64[0];
      v48 = vmlas_n_f32(vmuls_lane_f32(v46 * v46, v47, 1), v46 * v46, v47.f32[0]);
      if (v48 > 4.0)
      {
        v49 = vextq_s8((int8x16_t)v45, (int8x16_t)v45, 8uLL).u64[0];
        *(float32x2_t *)v45.f32 = vmul_n_f32(*(float32x2_t *)v45.f32, 2.0 / sqrtf(v48));
        v45.i64[1] = v49;
      }
      v50 = vmuls_lane_f32(v46, v45, 3);
      if ((float)(v50 * v50) > 2.4674)
      {
        if (v50 <= 0.0)
          v50 = -v50;
        v45.f32[3] = v45.f32[3] * (float)(1.5708 / v50);
      }
      *(float32x4_t *)(a1[11] + 16 * v44) = vmlaq_n_f32(*(float32x4_t *)(a1[11] + 16 * v44), v45, v46);
      *(float32x4_t *)(a1[12] + 16 * v44++) = v45;
      v43 = a1[2];
      v51 = a1[3];
    }
    while (v44 < (v51 - v43) >> 3);
  }
  if (*((int *)a3 + 4) < 1)
  {
    v57 = 1;
  }
  else
  {
    v52 = 0;
    do
    {
      v53 = b2ContactSolver::SolvePositionConstraints((b2ContactSolver *)v79);
      v54 = (_QWORD *)a1[8];
      v55 = (_QWORD *)a1[9];
      v56 = 1;
      while (v54 != v55)
      {
        v56 &= (*(uint64_t (**)(_QWORD, __int128 *))(*(_QWORD *)*v54 + 64))(*v54, &v87);
        ++v54;
      }
      if ((v53 & v56 & 1) != 0)
        break;
      ++v52;
    }
    while (v52 < *((_DWORD *)a3 + 4));
    v57 = v53 & v56 ^ 1;
    v43 = a1[2];
    v51 = a1[3];
  }
  if (v51 != v43)
  {
    v58 = 0;
    v59 = 0;
    do
    {
      v60 = *(_QWORD *)(v43 + 8 * v59);
      *(_OWORD *)(v60 + 96) = *(_OWORD *)(a1[11] + v58);
      *(_QWORD *)(v60 + 128) = *(_QWORD *)(a1[12] + v58);
      *(_DWORD *)(v60 + 136) = *(_DWORD *)(a1[12] + v58 + 12);
      v61 = __sincosf_stret(*(float *)(v60 + 108));
      *(__float2 *)(v60 + 40) = v61;
      v62 = *(float *)(v60 + 64);
      v63 = *(float *)(v60 + 68);
      v64 = *(float *)(v60 + 100) - (float)((float)(v61.__cosval * v63) + (float)(v61.__sinval * v62));
      *(float *)(v60 + 32) = *(float *)(v60 + 96) - (float)((float)(v61.__cosval * v62) - (float)(v61.__sinval * v63));
      *(float *)(v60 + 36) = v64;
      ++v59;
      v43 = a1[2];
      v58 += 16;
    }
    while (v59 < (a1[3] - v43) >> 3);
  }
  b2Island::Report(a1, (uint64_t)v79[9]);
  if (a10)
  {
    v66 = (b2Body **)a1[2];
    v65 = (b2Body **)a1[3];
    if (v66 == v65)
    {
      v68 = 3.4028e38;
      if (a9 > 3.4028e38)
        v73 = 1;
      else
        v73 = v57;
      if ((v73 & 1) == 0)
        goto LABEL_73;
    }
    else
    {
      v67 = *(float *)a3;
      v68 = 3.4028e38;
      v69 = v66;
      do
      {
        v70 = *v69;
        if ((*v69)->var5)
        {
          if ((v70->var6 & 4) != 0
            && (float)(*(float *)&v70->var15 * *(float *)&v70->var15) <= (float)(a8 * a8)
            && (float)((float)(*(&v70->var14 + 1) * *(&v70->var14 + 1)) + (float)(v70->var14 * v70->var14)) <= (float)(a7 * a7))
          {
            v71 = v67 + *(float *)&v70[1].var1;
            *(float *)&v70[1].var1 = v71;
            if (v68 >= v71)
              v68 = v71;
          }
          else
          {
            v70[1].var1 = 0;
            v68 = 0.0;
          }
        }
        ++v69;
      }
      while (v69 != v65);
      if (v68 < a9)
        v72 = 1;
      else
        v72 = v57;
      if ((v72 & 1) == 0)
      {
        do
          b2Body::SetAwake(*v66++, 0);
        while (v66 != v65);
LABEL_73:
        v74 = 1;
        goto LABEL_74;
      }
    }
    v74 = (v68 > 0.0) & ~v57;
LABEL_74:
    *a11 = v74;
  }
  b2ContactSolver::~b2ContactSolver((b2ContactSolver *)v79);
  if (v92)
  {
    v93 = v92;
    operator delete(v92);
  }
  v79[0] = (void **)&v91;
  std::vector<std::shared_ptr<PKCField>>::__destroy_vector::operator()[abi:ne180100](v79);
}

void sub_208FBA830(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  uint64_t v10;
  va_list va;

  va_start(va, a10);
  b2ContactSolver::~b2ContactSolver((b2ContactSolver *)va);
  PKCAether::Evaluator::~Evaluator((PKCAether::Evaluator *)(v10 - 224));
  _Unwind_Resume(a1);
}

_QWORD *b2Island::Report(_QWORD *result, uint64_t a2)
{
  _QWORD *v2;
  uint64_t v3;
  uint64_t v4;
  unint64_t v6;
  int *v7;
  uint64_t v8;
  uint64_t v9;
  int *v10;
  _DWORD *v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  _DWORD v15[3];

  if (result[1])
  {
    v2 = result;
    v4 = result[5];
    v3 = result[6];
    if (v3 != v4)
    {
      v6 = 0;
      v7 = (int *)(a2 + 20);
      do
      {
        v8 = *(_QWORD *)(v4 + 8 * v6);
        v9 = *(unsigned int *)(a2 + 152 * v6 + 144);
        v15[2] = v9;
        v10 = v7;
        v11 = v15;
        if ((int)v9 >= 1)
        {
          do
          {
            *(v11 - 2) = *(v10 - 1);
            v12 = *v10;
            v10 += 9;
            *v11++ = v12;
            --v9;
          }
          while (v9);
        }
        v13 = *(_QWORD *)(*(_QWORD *)(v8 + 80) + 24);
        v14 = *(_QWORD *)(*(_QWORD *)(v8 + 88) + 24);
        if ((*(_DWORD *)(v14 + 8) & *(_DWORD *)(v13 + 16)) != 0 || (*(_DWORD *)(v13 + 8) & *(_DWORD *)(v14 + 16)) != 0)
        {
          result = (_QWORD *)(*(uint64_t (**)(_QWORD))(*(_QWORD *)v2[1] + 48))(v2[1]);
          v4 = v2[5];
          v3 = v2[6];
        }
        ++v6;
        v7 += 38;
      }
      while (v6 < (v3 - v4) >> 3);
    }
  }
  return result;
}

void b2Island::SolveTOI(_QWORD *a1, __int128 *a2, int a3, int a4, float a5)
{
  unint64_t v6;
  unint64_t v7;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  int32x2_t v15;
  int v16;
  uint64_t v17;
  float v18;
  float32x4_t v19;
  float32x2_t v20;
  float v21;
  unint64_t v22;
  float v23;
  float v24;
  uint64_t v25;
  uint64_t v26;
  __float2 v27;
  float v28;
  float v29;
  float32x4_t v30;
  float v31;
  float32x4_t v32;
  _BYTE v33[72];
  uint64_t v34;
  __int128 v35;
  uint64_t v36;
  int v37;
  __int128 v38;
  uint64_t v39;
  float v40;

  v6 = a1[3] - a1[2];
  v7 = v6 >> 3;
  if ((int)(v6 >> 3) <= a3)
    b2Island::SolveTOI();
  if ((int)v7 <= a4)
    b2Island::SolveTOI();
  if ((int)v7 >= 1)
  {
    v11 = 0;
    v12 = 12;
    do
    {
      v13 = *(_QWORD *)(a1[2] + v11);
      *(_OWORD *)(a1[11] + v12 - 12) = *(_OWORD *)(v13 + 96);
      *(_QWORD *)(a1[12] + v12 - 12) = *(_QWORD *)(v13 + 128);
      *(_DWORD *)(a1[12] + v12) = *(_DWORD *)(v13 + 136);
      v12 += 16;
      v11 += 8;
    }
    while ((v6 & 0x7FFFFFFF8) != v11);
  }
  v37 = (a1[6] - a1[5]) >> 3;
  v39 = *a1;
  v35 = *a2;
  v36 = *((_QWORD *)a2 + 2);
  v38 = *(_OWORD *)(a1 + 11);
  v40 = a5;
  b2ContactSolver::b2ContactSolver(v33, &v35, a1 + 2, a1 + 5);
  if (*((int *)a2 + 4) >= 1)
  {
    v14 = 0;
    do
    {
      if (b2ContactSolver::SolveTOIPositionConstraints((b2ContactSolver *)v33, a3, a4))
        break;
      ++v14;
    }
    while (v14 < *((_DWORD *)a2 + 4));
  }
  *(_OWORD *)(*(_QWORD *)(a1[2] + 8 * a3) + 80) = *(_OWORD *)(a1[11] + 16 * a3);
  *(_OWORD *)(*(_QWORD *)(a1[2] + 8 * a4) + 80) = *(_OWORD *)(a1[11] + 16 * a4);
  b2ContactSolver::InitializeVelocityConstraints((b2ContactSolver *)v33);
  if (*((int *)a2 + 3) >= 1)
  {
    v16 = 0;
    do
    {
      b2ContactSolver::SolveVelocityConstraints((uint64_t)v33);
      ++v16;
    }
    while (v16 < *((_DWORD *)a2 + 3));
  }
  if ((int)v7 >= 1)
  {
    v17 = 0;
    v15.i32[0] = *(_DWORD *)a2;
    v18 = *(float *)v15.i32 * *(float *)v15.i32;
    v31 = *(float *)a2;
    v30 = (float32x4_t)vdupq_lane_s32(v15, 0);
    do
    {
      v19 = *(float32x4_t *)(a1[12] + 16 * v17);
      v20 = (float32x2_t)vmulq_f32(v19, v19).u64[0];
      v21 = vmlas_n_f32(vmuls_lane_f32(v18, v20, 1), v18, v20.f32[0]);
      if (v21 > 4.0)
      {
        v22 = vextq_s8((int8x16_t)v19, (int8x16_t)v19, 8uLL).u64[0];
        *(float32x2_t *)v19.f32 = vmul_n_f32(*(float32x2_t *)v19.f32, 2.0 / sqrtf(v21));
        v19.i64[1] = v22;
      }
      v23 = v19.f32[3];
      v24 = vmuls_lane_f32(v31, v19, 3);
      if ((float)(v24 * v24) > 2.4674)
      {
        if (v24 <= 0.0)
          v24 = -v24;
        v23 = v19.f32[3] * (float)(1.5708 / v24);
        v19.f32[3] = v23;
      }
      v25 = a1[11];
      v32 = vmlaq_f32(*(float32x4_t *)(v25 + 16 * v17), v19, v30);
      *(float32x4_t *)(v25 + 16 * v17) = v32;
      *(float32x4_t *)(a1[12] + 16 * v17) = v19;
      v26 = *(_QWORD *)(a1[2] + 8 * v17);
      *(float32x4_t *)(v26 + 96) = v32;
      *(_QWORD *)(v26 + 128) = v19.i64[0];
      *(float *)(v26 + 136) = v23;
      v27 = __sincosf_stret(v32.f32[3]);
      *(__float2 *)(v26 + 40) = v27;
      v28 = *(float *)(v26 + 64);
      v29 = *(float *)(v26 + 68);
      *(float *)(v26 + 32) = v32.f32[0] - (float)((float)(v27.__cosval * v28) - (float)(v27.__sinval * v29));
      *(float *)(v26 + 36) = v32.f32[1] - (float)((float)(v27.__cosval * v29) + (float)(v27.__sinval * v28));
      ++v17;
    }
    while ((v6 >> 3) != v17);
  }
  b2Island::Report(a1, v34);
  b2ContactSolver::~b2ContactSolver((b2ContactSolver *)v33);
}

void sub_208FBAC40(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_list va;

  va_start(va, a8);
  b2ContactSolver::~b2ContactSolver((b2ContactSolver *)va);
  _Unwind_Resume(a1);
}

uint64_t b2Island::ClearIslandFlags(uint64_t this)
{
  uint64_t v1;
  uint64_t v2;

  v1 = *(_QWORD *)(this + 16);
  v2 = *(_QWORD *)(this + 24);
  while (v1 != v2)
  {
    if (!*(_DWORD *)(*(_QWORD *)v1 + 20))
      *(_WORD *)(*(_QWORD *)v1 + 24) &= ~1u;
    v1 += 8;
  }
  return this;
}

void b2Island::SynchronizeBodiesAndContacts(b2Island *this)
{
  b2Body **v1;
  b2Body **i;
  b2Body *v3;
  uint64_t j;

  v1 = (b2Body **)*((_QWORD *)this + 2);
  for (i = (b2Body **)*((_QWORD *)this + 3); v1 != i; ++v1)
  {
    v3 = *v1;
    if ((*v1)->var5 == 2)
    {
      b2Body::SynchronizeFixtures(*v1);
      for (j = *(_QWORD *)&v3->var24; j; j = *(_QWORD *)(j + 24))
        *(_DWORD *)(*(_QWORD *)(j + 8) + 12) &= 0xFFFFFFDE;
    }
  }
}

void b2World::b2World(b2World *this, const b2Vec2 *a2, char a3)
{
  uint64_t v6;
  PKCAether *v7;
  __int128 v8;

  b2StackAllocator::b2StackAllocator((b2StackAllocator *)this);
  b2ContactManager::b2ContactManager((b2ContactManager *)(v6 + 102944));
  *((_QWORD *)this + 12899) = 0;
  *((_QWORD *)this + 12904) = 0;
  *(_OWORD *)((char *)this + 103240) = 0u;
  *((_QWORD *)this + 12891) = 0;
  *((_OWORD *)this + 6446) = 0u;
  *((_OWORD *)this + 6448) = 0u;
  *((_DWORD *)this + 25797) = 16777473;
  *((_BYTE *)this + 103160) = a3;
  v7 = (PKCAether *)operator new();
  PKCAether::PKCAether(v7);
  *((_QWORD *)this + 12894) = v7;
  *(b2Vec2 *)&v8 = *a2;
  DWORD2(v8) = 0;
  *(_OWORD *)v7 = v8;
  *((_DWORD *)this + 25734) = 4;
  *((_DWORD *)this + 25796) = 0;
  *((_DWORD *)this + 25800) = 1065353216;
  *((_BYTE *)this + 103204) = 0;
  *((_QWORD *)this + 12901) = 0x3D0EFA363C23D70ALL;
  *((_DWORD *)this + 25804) = 1056964608;
  *((_QWORD *)this + 12903) = this;
}

void sub_208FBADFC(_Unwind_Exception *a1)
{
  b2StackAllocator *v1;
  b2ContactManager *v2;
  uint64_t v3;
  uint64_t v4;
  void *v6;

  MEMORY[0x20BD0BA58](v3, 0x1020C4075D858B6);
  v6 = *(void **)v4;
  if (*(_QWORD *)v4)
  {
    *(_QWORD *)(v4 + 8) = v6;
    operator delete(v6);
  }
  b2ContactManager::~b2ContactManager(v2);
  b2StackAllocator::~b2StackAllocator(v1);
  _Unwind_Resume(a1);
}

void b2World::~b2World(b2World *this)
{
  _QWORD *v2;
  uint64_t v3;
  _QWORD *v4;
  uint64_t v5;
  _QWORD *v6;
  PKCAether *v7;
  void *v8;

  v2 = (_QWORD *)((char *)this + 103128);
  v3 = *((_QWORD *)this + 12891);
  while (v3)
  {
    v5 = v3 + 168;
    v3 = *(_QWORD *)(v3 + 168);
    v4 = *(_QWORD **)(v5 + 8);
    if (v4)
    {
      do
      {
        v6 = (_QWORD *)v4[2];
        (*(void (**)(_QWORD *))(*v4 + 8))(v4);
        v4 = v6;
      }
      while (v6);
    }
  }
  v7 = (PKCAether *)v2[3];
  if (v7)
  {
    PKCAether::~PKCAether(v7);
    MEMORY[0x20BD0BA58]();
  }
  v8 = (void *)v2[13];
  if (v8)
  {
    v2[14] = v8;
    operator delete(v8);
  }
  b2ContactManager::~b2ContactManager((b2ContactManager *)((char *)this + 102944));
  b2StackAllocator::~b2StackAllocator((b2StackAllocator *)this);
}

__n128 b2World::SetGravity(b2World *this, const b2Vec2 *a2, __n128 a3)
{
  __n128 result;

  a3.n128_u64[0] = (unint64_t)*a2;
  a3.n128_u32[2] = 0;
  *(__n128 *)*((_QWORD *)this + 12894) = a3;
  result.n128_u64[0] = a3.n128_u64[0];
  result.n128_u32[2] = a3.n128_u32[2];
  return result;
}

__n128 b2World::GetGravity(b2World *this)
{
  return *(__n128 *)*((_QWORD *)this + 12894);
}

b2World *b2World::SetVelocityThreshold(b2World *this, float a2)
{
  *((float *)this + 25800) = a2;
  return this;
}

float b2World::GetVelocityThreshold(b2World *this)
{
  return *((float *)this + 25800);
}

uint64_t b2World::IsSettling(b2World *this)
{
  return *((unsigned __int8 *)this + 103204);
}

b2World *b2World::SetSettlingLinearVelocityThreshold(b2World *this, float a2)
{
  *((float *)this + 25802) = a2;
  return this;
}

float b2World::GetSettlingLinearVelocityThreshold(b2World *this)
{
  return *((float *)this + 25802);
}

b2World *b2World::SetSettlingAngularVelocityThreshold(b2World *this, float a2)
{
  *((float *)this + 25803) = a2;
  return this;
}

float b2World::GetSettlingAngularVelocityThreshold(b2World *this)
{
  return *((float *)this + 25803);
}

b2World *b2World::SetSettlingDuration(b2World *this, float a2)
{
  *((float *)this + 25804) = a2;
  return this;
}

float b2World::GetSettlingDuration(b2World *this)
{
  return *((float *)this + 25804);
}

uint64_t b2World::SetDestructionListener(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 103168) = a2;
  return result;
}

b2World *b2World::SetContactListener(b2World *this, b2ContactListener *a2)
{
  *((_QWORD *)this + 12868) = a2;
  return this;
}

b2World *b2World::SetDebugDraw(b2World *this, b2Draw *a2)
{
  *((_QWORD *)this + 12897) = a2;
  return this;
}

uint64_t b2World::CreateBody(b2World *this, const b2BodyDef *a2)
{
  char *v2;
  uint64_t v5;
  uint64_t v6;

  v2 = (char *)this + 102936;
  if ((*((_BYTE *)this + 102936) & 2) != 0)
    b2World::CreateBody();
  v5 = operator new();
  b2Body::b2Body((b2Body *)v5, a2, this);
  v6 = *((_QWORD *)v2 + 24);
  *(_QWORD *)(v5 + 160) = 0;
  *(_QWORD *)(v5 + 168) = v6;
  if (v6)
    *(_QWORD *)(v6 + 160) = v5;
  *((_QWORD *)v2 + 24) = v5;
  ++*((_DWORD *)v2 + 52);
  return v5;
}

void sub_208FBB06C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BD0BA58](v1, 0x10A0C40E00B488BLL);
  _Unwind_Resume(a1);
}

void b2World::DestroyBody(b2World *this, b2Body *a2, uint64_t a3)
{
  char *v3;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  b2JointEdge *var20;
  b2ContactManager *v12;
  b2JointEdge *var2;
  uint64_t v14;
  b2Fixture *var18;
  uint64_t v16;

  v3 = (char *)this + 102936;
  if (*((int *)this + 25786) > 0)
  {
    if ((*v3 & 2) == 0)
    {
      v6 = *(_QWORD *)&a2->var22;
      if (v6)
      {
        do
        {
          v7 = *(_QWORD *)(v6 + 24);
          v8 = *((_QWORD *)v3 + 29);
          if (v8)
            (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v8 + 16))(v8, *(_QWORD *)(v6 + 8));
          b2World::DestroyJoint(this, *(b2Joint **)(v6 + 8));
          *(_QWORD *)&a2->var22 = v7;
          v6 = v7;
        }
        while (v7);
      }
      *(_QWORD *)&a2->var22 = 0;
      v9 = *(_QWORD *)&a2->var24;
      if (v9)
      {
        do
        {
          v10 = *(_QWORD *)(v9 + 24);
          b2ContactManager::DestroyContact((b2ContactManager *)((char *)this + 102944), *(b2Contact **)(v9 + 8));
          v9 = v10;
        }
        while (v10);
      }
      *(_QWORD *)&a2->var24 = 0;
      var20 = a2->var20;
      if (var20)
      {
        v12 = (b2ContactManager *)((char *)this + 102944);
        do
        {
          var2 = var20->var2;
          v14 = *((_QWORD *)v3 + 29);
          if (v14)
            (*(void (**)(uint64_t, b2JointEdge *))(*(_QWORD *)v14 + 24))(v14, var20);
          b2Fixture::DestroyProxies((b2Fixture *)var20, v12);
          (*(void (**)(b2JointEdge *))&var20->var0->var2)(var20);
          a2->var20 = var2;
          --LODWORD(a2->var21);
          var20 = var2;
        }
        while (var2);
      }
      a2->var20 = 0;
      LODWORD(a2->var21) = 0;
      var18 = a2->var18;
      if (var18)
        *((_QWORD *)var18 + 21) = *(_QWORD *)&a2->var19;
      v16 = *(_QWORD *)&a2->var19;
      if (v16)
        *(_QWORD *)(v16 + 160) = var18;
      if (*((b2Body **)v3 + 24) == a2)
        *((_QWORD *)v3 + 24) = v16;
      --*((_DWORD *)v3 + 52);
      PKCMechanics::QueryAABB(a2, a2, a3);
      JUMPOUT(0x20BD0BA58);
    }
    b2World::DestroyBody();
  }
  b2World::DestroyBody();
}

b2Joint *b2World::DestroyJoint(b2World *this, b2Joint *a2)
{
  char *v2;
  b2Joint *var2;
  b2Joint *var3;
  b2Body *var7;
  b2Body *var6;
  b2Joint *v8;
  b2JointEdge *v9;
  b2JointEdge *v10;
  b2JointEdge *v11;
  b2JointEdge *v12;
  b2Joint *result;
  int v14;

  v2 = (char *)this + 102936;
  if ((*((_BYTE *)this + 102936) & 2) != 0)
    b2World::DestroyJoint();
  var2 = a2->var2;
  if (var2)
    var2->var3 = a2->var3;
  var3 = a2->var3;
  if (var3)
    var3->var2 = var2;
  if (*((b2Joint **)this + 12892) == a2)
    *((_QWORD *)this + 12892) = var3;
  var6 = a2->var6;
  var7 = a2->var7;
  b2Body::SetAwake(var6, 1);
  b2Body::SetAwake(var7, 1);
  v9 = a2->var4.var2;
  if (v9)
    v9->var3 = a2->var4.var3;
  v10 = a2->var4.var3;
  if (v10)
    v10->var2 = v9;
  if (&a2->var4 == (b2JointEdge *)*(b2Joint **)&var6->var22)
    *(_QWORD *)&var6->var22 = v10;
  v11 = a2->var5.var2;
  a2->var4.var2 = 0;
  a2->var4.var3 = 0;
  if (v11)
    v11->var3 = a2->var5.var3;
  v12 = a2->var5.var3;
  if (v12)
    v12->var2 = v11;
  if (&a2->var5 == (b2JointEdge *)*(b2Joint **)&var7->var22)
    *(_QWORD *)&var7->var22 = v12;
  a2->var5.var2 = 0;
  a2->var5.var3 = 0;
  result = b2Joint::Destroy(a2, v8);
  v14 = *((_DWORD *)v2 + 53);
  if (v14 <= 0)
    b2World::DestroyJoint();
  *((_DWORD *)v2 + 53) = v14 - 1;
  return result;
}

b2RevoluteJoint *b2World::CreateJoint(b2World *this, b2Joint *a2)
{
  char *v2;
  b2RevoluteJoint *result;
  b2Joint *v4;
  b2Body *var7;
  b2Body *var6;
  b2JointEdge *p_var4;
  b2JointEdge *v8;
  b2JointEdge *p_var5;
  b2JointEdge *v10;

  v2 = (char *)this + 102936;
  if ((*((_BYTE *)this + 102936) & 2) != 0)
    b2World::CreateJoint();
  result = b2Joint::Create(a2, (const b2JointDef *)a2);
  v4 = (b2Joint *)*((_QWORD *)v2 + 25);
  result->var2 = 0;
  result->var3 = v4;
  if (v4)
    v4->var2 = (b2Joint *)result;
  *((_QWORD *)v2 + 25) = result;
  ++*((_DWORD *)v2 + 53);
  var6 = result->var6;
  var7 = result->var7;
  result->var4.var0 = var7;
  p_var4 = &result->var4;
  result->var4.var1 = (b2Joint *)result;
  result->var4.var2 = 0;
  v8 = *(b2JointEdge **)&var6->var22;
  result->var4.var3 = v8;
  if (v8)
    v8->var2 = p_var4;
  *(_QWORD *)&var6->var22 = p_var4;
  result->var5.var0 = var6;
  p_var5 = &result->var5;
  result->var5.var1 = (b2Joint *)result;
  result->var5.var2 = 0;
  v10 = *(b2JointEdge **)&var7->var22;
  result->var5.var3 = v10;
  if (v10)
    v10->var2 = p_var5;
  *(_QWORD *)&var7->var22 = p_var5;
  return result;
}

void b2World::Solve(b2StackAllocator *a1, __int128 *a2)
{
  char *v2;
  uint64_t i;
  uint64_t j;
  uint64_t k;
  uint64_t v6;
  char *v7;
  b2Body **v8;
  unint64_t v9;
  unint64_t v10;
  _QWORD *v11;
  uint64_t v12;
  char *v13;
  char *v14;
  char *v15;
  uint64_t v16;
  b2Body **v17;
  uint64_t v18;
  char *v19;
  char *v20;
  uint64_t v21;
  char *v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  char *v26;
  char *v27;
  char *v28;
  char *v29;
  uint64_t v30;
  b2Body **m;
  b2Body *v32;
  uint64_t v33;
  uint64_t v34;
  char *v35;
  char *v36;
  uint64_t v37;
  unint64_t v38;
  unint64_t v39;
  char *v40;
  char *v41;
  char *v42;
  char *v43;
  uint64_t v44;
  b2Body *v45;
  b2Body **v46;
  b2Body **v47;
  uint64_t v48;
  unint64_t v49;
  unint64_t v50;
  char *v51;
  char *v52;
  char *v53;
  char *v54;
  uint64_t v55;
  uint64_t n;
  b2Body *v57;
  uint64_t v58;
  char *v59;
  char *v60;
  uint64_t v61;
  unint64_t v62;
  unint64_t v63;
  char *v64;
  char *v65;
  char *v66;
  char *v67;
  uint64_t v68;
  b2Body **v69;
  b2Body **v70;
  uint64_t v71;
  unint64_t v72;
  unint64_t v73;
  char *v74;
  b2Body **v75;
  char *v76;
  char *v77;
  b2Body *v78;
  int v79;
  uint64_t v80;
  char *v81;
  char v83;
  char v84;
  unsigned __int8 v85;
  void *__p;
  b2Body **v87;
  unint64_t v88;
  uint64_t v89[2];
  char *v90;
  char *v91;
  char *v92;
  char *v93;
  char *v94;
  char *v95;
  char *v96;
  char *v97;
  char *v98;

  v2 = (char *)a1 + 102944;
  for (i = *((_QWORD *)a1 + 12891); i; i = *(_QWORD *)(i + 168))
    *(_OWORD *)(i + 48) = *(_OWORD *)(i + 32);
  b2Island::b2Island((b2Island *)v89, *((_DWORD *)a1 + 25786), *((_DWORD *)a1 + 25776), *((_DWORD *)a1 + 25787), a1, *(b2ContactListener **)v2);
  for (j = *((_QWORD *)v2 + 23); j; j = *(_QWORD *)(j + 168))
    *(_WORD *)(j + 24) &= ~1u;
  b2ContactManager::ClearContactIslandFlags((uint64_t)v2);
  for (k = *((_QWORD *)v2 + 24); k; k = *(_QWORD *)(k + 24))
    *(_BYTE *)(k + 112) = 0;
  __p = 0;
  v87 = 0;
  v88 = 0;
  std::vector<PKPoint>::reserve(&__p, *((int *)v2 + 50));
  v6 = *((_QWORD *)v2 + 23);
  if (v6)
  {
    v81 = v2;
    v83 = 1;
    do
    {
      if ((*(_WORD *)(v6 + 24) & 1) == 0
        && b2Body::IsAwake((b2Body *)v6)
        && (b2Body::IsActive((b2Body *)v6) & 1) != 0
        && *(_DWORD *)(v6 + 20))
      {
        v91 = v90;
        v94 = v93;
        v97 = v96;
        v7 = (char *)__p;
        v87 = (b2Body **)__p;
        if ((unint64_t)__p >= v88)
        {
          v9 = (uint64_t)(v88 - (_QWORD)__p) >> 2;
          if (v9 <= 1)
            v9 = 1;
          if (v88 - (unint64_t)__p >= 0x7FFFFFFFFFFFFFF8)
            v10 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v10 = v9;
          v11 = std::__allocate_at_least[abi:ne180100]<std::allocator<PKPoint>>((uint64_t)&v88, v10);
          *v11 = v6;
          v8 = (b2Body **)(v11 + 1);
          v14 = (char *)__p;
          v13 = (char *)v87;
          v15 = (char *)v11;
          if (v87 != __p)
          {
            do
            {
              v16 = *((_QWORD *)v13 - 1);
              v13 -= 8;
              *((_QWORD *)v15 - 1) = v16;
              v15 -= 8;
            }
            while (v13 != v14);
            v13 = (char *)__p;
          }
          __p = v15;
          v87 = (b2Body **)(v11 + 1);
          v88 = (unint64_t)&v11[v12];
          if (v13)
            operator delete(v13);
        }
        else
        {
          *(_QWORD *)__p = v6;
          v8 = (b2Body **)(v7 + 8);
        }
        v87 = v8;
        *(_WORD *)(v6 + 24) |= 1u;
        v17 = (b2Body **)__p;
        while (v17 != v8)
        {
          v18 = (uint64_t)*(v8 - 1);
          v87 = v8 - 1;
          v19 = v90;
          v20 = v91;
          v21 = (v91 - v90) >> 3;
          *(_DWORD *)(v18 + 28) = v21;
          if (v20 >= v92)
          {
            if ((unint64_t)(v21 + 1) >> 61)
              std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
            v23 = v92 - v19;
            v24 = v23 >> 2;
            if (v23 >> 2 <= (unint64_t)(v21 + 1))
              v24 = v21 + 1;
            if ((unint64_t)v23 >= 0x7FFFFFFFFFFFFFF8)
              v25 = 0x1FFFFFFFFFFFFFFFLL;
            else
              v25 = v24;
            if (v25)
              v26 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKPoint>>((uint64_t)&v92, v25);
            else
              v26 = 0;
            v27 = &v26[8 * v21];
            *(_QWORD *)v27 = v18;
            v22 = v27 + 8;
            v29 = v90;
            v28 = v91;
            if (v91 != v90)
            {
              do
              {
                v30 = *((_QWORD *)v28 - 1);
                v28 -= 8;
                *((_QWORD *)v27 - 1) = v30;
                v27 -= 8;
              }
              while (v28 != v29);
              v28 = v90;
            }
            v90 = v27;
            v91 = v22;
            v92 = &v26[8 * v25];
            if (v28)
              operator delete(v28);
          }
          else
          {
            *(_QWORD *)v20 = v18;
            v22 = v20 + 8;
          }
          v91 = v22;
          b2Body::SetAwake((b2Body *)v18, 1);
          if (*(_DWORD *)(v18 + 20))
          {
            for (m = *(b2Body ***)(v18 + 200); m; m = (b2Body **)m[3])
            {
              v32 = m[1];
              if ((v32->var3 & 7) == 6)
              {
                v33 = *(_QWORD *)(*(_QWORD *)&v32->var10.var1.var0.var1 + 24);
                v34 = *(_QWORD *)(*(_QWORD *)&v32->var10.var2.var0.var0 + 24);
                if ((*(_DWORD *)(v34 + 8) & *(_DWORD *)(v33 + 12)) != 0
                  || (*(_DWORD *)(v33 + 8) & *(_DWORD *)(v34 + 12)) != 0)
                {
                  v35 = v94;
                  if (v94 >= v95)
                  {
                    v37 = (v94 - v93) >> 3;
                    if ((unint64_t)(v37 + 1) >> 61)
                      std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
                    v38 = (v95 - v93) >> 2;
                    if (v38 <= v37 + 1)
                      v38 = v37 + 1;
                    if ((unint64_t)(v95 - v93) >= 0x7FFFFFFFFFFFFFF8)
                      v39 = 0x1FFFFFFFFFFFFFFFLL;
                    else
                      v39 = v38;
                    if (v39)
                      v40 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKPoint>>((uint64_t)&v95, v39);
                    else
                      v40 = 0;
                    v41 = &v40[8 * v37];
                    *(_QWORD *)v41 = v32;
                    v36 = v41 + 8;
                    v43 = v93;
                    v42 = v94;
                    if (v94 != v93)
                    {
                      do
                      {
                        v44 = *((_QWORD *)v42 - 1);
                        v42 -= 8;
                        *((_QWORD *)v41 - 1) = v44;
                        v41 -= 8;
                      }
                      while (v42 != v43);
                      v42 = v93;
                    }
                    v93 = v41;
                    v94 = v36;
                    v95 = &v40[8 * v39];
                    if (v42)
                      operator delete(v42);
                  }
                  else
                  {
                    *(_QWORD *)v94 = v32;
                    v36 = v35 + 8;
                  }
                  v94 = v36;
                  v32->var3 |= 1u;
                  v45 = *m;
                  if (((*m)->var6 & 1) == 0)
                  {
                    v46 = v87;
                    if ((unint64_t)v87 >= v88)
                    {
                      v48 = ((char *)v87 - (_BYTE *)__p) >> 3;
                      if ((unint64_t)(v48 + 1) >> 61)
                        std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
                      v49 = (uint64_t)(v88 - (_QWORD)__p) >> 2;
                      if (v49 <= v48 + 1)
                        v49 = v48 + 1;
                      if (v88 - (unint64_t)__p >= 0x7FFFFFFFFFFFFFF8)
                        v50 = 0x1FFFFFFFFFFFFFFFLL;
                      else
                        v50 = v49;
                      if (v50)
                        v51 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKPoint>>((uint64_t)&v88, v50);
                      else
                        v51 = 0;
                      v52 = &v51[8 * v48];
                      *(_QWORD *)v52 = v45;
                      v47 = (b2Body **)(v52 + 8);
                      v54 = (char *)__p;
                      v53 = (char *)v87;
                      if (v87 != __p)
                      {
                        do
                        {
                          v55 = *((_QWORD *)v53 - 1);
                          v53 -= 8;
                          *((_QWORD *)v52 - 1) = v55;
                          v52 -= 8;
                        }
                        while (v53 != v54);
                        v53 = (char *)__p;
                      }
                      __p = v52;
                      v87 = v47;
                      v88 = (unint64_t)&v51[8 * v50];
                      if (v53)
                        operator delete(v53);
                    }
                    else
                    {
                      *v87 = v45;
                      v47 = v46 + 1;
                    }
                    v87 = v47;
                    v45->var6 |= 1u;
                  }
                }
              }
            }
            for (n = *(_QWORD *)(v18 + 192); n; n = *(_QWORD *)(n + 24))
            {
              if (!*(_BYTE *)(*(_QWORD *)(n + 8) + 112))
              {
                v57 = *(b2Body **)n;
                if ((b2Body::IsActive(*(b2Body **)n) & 1) != 0)
                {
                  v58 = *(_QWORD *)(n + 8);
                  v59 = v97;
                  if (v97 >= v98)
                  {
                    v61 = (v97 - v96) >> 3;
                    if ((unint64_t)(v61 + 1) >> 61)
                      std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
                    v62 = (v98 - v96) >> 2;
                    if (v62 <= v61 + 1)
                      v62 = v61 + 1;
                    if ((unint64_t)(v98 - v96) >= 0x7FFFFFFFFFFFFFF8)
                      v63 = 0x1FFFFFFFFFFFFFFFLL;
                    else
                      v63 = v62;
                    if (v63)
                      v64 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKPoint>>((uint64_t)&v98, v63);
                    else
                      v64 = 0;
                    v65 = &v64[8 * v61];
                    *(_QWORD *)v65 = v58;
                    v60 = v65 + 8;
                    v66 = v97;
                    v67 = v96;
                    if (v97 != v96)
                    {
                      do
                      {
                        v68 = *((_QWORD *)v66 - 1);
                        v66 -= 8;
                        *((_QWORD *)v65 - 1) = v68;
                        v65 -= 8;
                      }
                      while (v66 != v67);
                      v66 = v96;
                    }
                    v96 = v65;
                    v97 = v60;
                    v98 = &v64[8 * v63];
                    if (v66)
                      operator delete(v66);
                  }
                  else
                  {
                    *(_QWORD *)v97 = v58;
                    v60 = v59 + 8;
                  }
                  v97 = v60;
                  *(_BYTE *)(*(_QWORD *)(n + 8) + 112) = 1;
                  if ((v57->var6 & 1) == 0)
                  {
                    v69 = v87;
                    if ((unint64_t)v87 >= v88)
                    {
                      v71 = ((char *)v87 - (_BYTE *)__p) >> 3;
                      if ((unint64_t)(v71 + 1) >> 61)
                        std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
                      v72 = (uint64_t)(v88 - (_QWORD)__p) >> 2;
                      if (v72 <= v71 + 1)
                        v72 = v71 + 1;
                      if (v88 - (unint64_t)__p >= 0x7FFFFFFFFFFFFFF8)
                        v73 = 0x1FFFFFFFFFFFFFFFLL;
                      else
                        v73 = v72;
                      if (v73)
                        v74 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKPoint>>((uint64_t)&v88, v73);
                      else
                        v74 = 0;
                      v75 = (b2Body **)&v74[8 * v71];
                      *v75 = v57;
                      v70 = v75 + 1;
                      v77 = (char *)__p;
                      v76 = (char *)v87;
                      if (v87 != __p)
                      {
                        do
                        {
                          v78 = (b2Body *)*((_QWORD *)v76 - 1);
                          v76 -= 8;
                          *--v75 = v78;
                        }
                        while (v76 != v77);
                        v76 = (char *)__p;
                      }
                      __p = v75;
                      v87 = v70;
                      v88 = (unint64_t)&v74[8 * v73];
                      if (v76)
                        operator delete(v76);
                    }
                    else
                    {
                      *v87 = v57;
                      v70 = v69 + 1;
                    }
                    v87 = v70;
                    v57->var6 |= 1u;
                  }
                }
              }
            }
          }
          v17 = (b2Body **)__p;
          v8 = v87;
        }
        v85 = 0;
        v2 = v81;
        b2Island::Solve(v89, (int)&v84, a2, *((PKCAether **)v81 + 26), *((double *)v81 + 31), *((float *)v81 + 64), *((float *)v81 + 66), *((float *)v81 + 67), *((float *)v81 + 68), v81[216], (char *)&v85);
        v79 = v85;
        b2Island::ClearIslandFlags((uint64_t)v89);
        v83 &= v79 != 0;
      }
      v6 = *(_QWORD *)(v6 + 168);
    }
    while (v6);
    v80 = *((_QWORD *)v2 + 23);
    for (v2[260] = v83 & 1; v80; v80 = *(_QWORD *)(v80 + 168))
    {
      if ((*(_WORD *)(v80 + 24) & 1) != 0 && *(_DWORD *)(v80 + 20))
        b2Body::SynchronizeFixtures((b2Body *)v80);
    }
  }
  else
  {
    v2[260] = 1;
  }
  b2ContactManager::FindNewContacts((b2Body *)v2);
  if (__p)
  {
    v87 = (b2Body **)__p;
    operator delete(__p);
  }
  b2Island::~b2Island((b2Island *)v89);
}

void sub_208FBBAA8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,uint64_t a24,char a25)
{
  b2Island::~b2Island((b2Island *)&a25);
  _Unwind_Resume(a1);
}

void b2World::SolveTOI(b2ContactListener **a1, uint64_t a2)
{
  char *v2;
  uint64_t i;
  char v4;
  char v5;
  b2Contact *v6;
  uint64_t v7;
  uint64_t v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  float v13;
  __float2 v14;
  float v15;
  float v16;
  __float2 v17;
  float v18;
  float v19;
  b2Contact *v20;
  int v21;
  char *v22;
  char *v23;
  __int128 v24;
  __int128 v25;
  __float2 v26;
  float v27;
  float v28;
  float v29;
  float v30;
  float v31;
  __float2 v32;
  float v33;
  float v34;
  float v35;
  unint64_t v36;
  unint64_t v37;
  char *v38;
  uint64_t v39;
  char *v40;
  char *v41;
  char *v42;
  uint64_t v43;
  char *v44;
  uint64_t v45;
  char *v46;
  uint64_t v47;
  uint64_t v48;
  unint64_t v49;
  char *v50;
  char *v51;
  char *v52;
  char *v53;
  uint64_t v54;
  b2Contact *v55;
  b2Contact **v56;
  b2Contact **v57;
  uint64_t v58;
  unint64_t v59;
  unint64_t v60;
  char *v61;
  b2Contact **v62;
  b2Contact **v63;
  b2Contact **v64;
  b2Contact *v65;
  uint64_t v66;
  char v67;
  char v68;
  uint64_t v69;
  _QWORD *j;
  uint64_t v71;
  uint64_t v72;
  _DWORD *v73;
  _DWORD *v74;
  int v75;
  int v76;
  __int128 v77;
  __int128 v78;
  __int128 v79;
  float v80;
  __float2 v81;
  float v82;
  float v83;
  int v84;
  __int128 v85;
  __float2 v86;
  float v87;
  float v88;
  float v89;
  b2Contact **v90;
  b2Contact **v91;
  uint64_t v92;
  unint64_t v93;
  unint64_t v94;
  char *v95;
  char *v96;
  b2Contact **v97;
  b2Contact **v98;
  uint64_t v99;
  __int16 v100;
  char *v101;
  char *v102;
  uint64_t v103;
  char *v104;
  uint64_t v105;
  uint64_t v106;
  unint64_t v107;
  char *v108;
  char *v109;
  char *v110;
  char *v111;
  uint64_t v112;
  float v113;
  int v114;
  char *v115;
  char *v116;
  uint64_t v117;
  uint64_t k;
  char v120;
  uint64_t v121;
  float32x4_t v122;
  float32x4_t v123;
  float32x4_t v124;
  float v125;
  b2Contact *v126;
  _QWORD v127[2];
  char *v128;
  char *v129;
  char *v130;
  b2Contact **v131;
  b2Contact **v132;
  _QWORD v133[6];
  __int128 v134;
  __int128 v135;
  __int128 v136;
  __int128 v137;
  _QWORD v138[2];
  __int128 v139;
  __int128 v140;
  __int128 v141;
  __int128 v142;
  __int128 v143;
  __int128 v144;
  __int128 v145;
  __int128 v146;
  uint64_t v147;

  v147 = *MEMORY[0x24BDAC8D0];
  v2 = (char *)(a1 + 12868);
  b2Island::b2Island((b2Island *)v127, 64, 32, 0, (b2StackAllocator *)a1, a1[12868]);
  if (v2[247])
  {
    for (i = *((_QWORD *)v2 + 23); i; i = *(_QWORD *)(i + 168))
    {
      *(_WORD *)(i + 24) &= ~1u;
      *(_DWORD *)(i + 112) = 0;
    }
    b2ContactManager::InvalidateContacts((uint64_t)v2);
  }
  v4 = 1;
  while (1)
  {
    v5 = v4;
    v126 = 0;
    v125 = 1.0;
    b2ContactManager::FindMinimumTOI((b2ContactManager *)v2, &v126, &v125);
    v6 = v126;
    if (!v126 || v125 > 1.0)
    {
      v2[247] = 1;
      goto LABEL_128;
    }
    v7 = *(_QWORD *)(*((_QWORD *)v126 + 10) + 24);
    v8 = *(_QWORD *)(*((_QWORD *)v126 + 11) + 24);
    v9 = *(_OWORD *)(v7 + 80);
    v143 = *(_OWORD *)(v7 + 64);
    v144 = v9;
    v10 = *(_OWORD *)(v7 + 112);
    v145 = *(_OWORD *)(v7 + 96);
    v146 = v10;
    v11 = *(_OWORD *)(v8 + 80);
    v139 = *(_OWORD *)(v8 + 64);
    v140 = v11;
    v12 = *(_OWORD *)(v8 + 112);
    v141 = *(_OWORD *)(v8 + 96);
    v142 = v12;
    if ((LODWORD(v125) & 0x7FFFFFFFu) <= 0x7F7FFFFF)
    {
      if (v125 <= 1.0)
        v13 = v125;
      else
        v13 = 1.0;
      v122 = vmlaq_n_f32(*(float32x4_t *)(v7 + 80), vsubq_f32(*(float32x4_t *)(v7 + 96), *(float32x4_t *)(v7 + 80)), (float)(v13 - *(float *)(v7 + 112)) / (float)(1.0 - *(float *)(v7 + 112)));
      *(float *)(v7 + 112) = v13;
      *(float32x4_t *)(v7 + 80) = v122;
      *(float32x4_t *)(v7 + 96) = v122;
      v14 = __sincosf_stret(v122.f32[3]);
      *(__float2 *)(v7 + 40) = v14;
      v15 = *(float *)(v7 + 64);
      v16 = *(float *)(v7 + 68);
      *(float *)(v7 + 32) = v122.f32[0] - (float)((float)(v14.__cosval * v15) - (float)(v14.__sinval * v16));
      *(float *)(v7 + 36) = v122.f32[1] - (float)((float)(v14.__cosval * v16) + (float)(v14.__sinval * v15));
      v123 = vmlaq_n_f32(*(float32x4_t *)(v8 + 80), vsubq_f32(*(float32x4_t *)(v8 + 96), *(float32x4_t *)(v8 + 80)), (float)(v13 - *(float *)(v8 + 112)) / (float)(1.0 - *(float *)(v8 + 112)));
      *(float *)(v8 + 112) = v13;
      *(float32x4_t *)(v8 + 80) = v123;
      *(float32x4_t *)(v8 + 96) = v123;
      v17 = __sincosf_stret(v123.f32[3]);
      *(__float2 *)(v8 + 40) = v17;
      v18 = *(float *)(v8 + 64);
      v19 = *(float *)(v8 + 68);
      *(float *)(v8 + 32) = v123.f32[0] - (float)((float)(v17.__cosval * v18) - (float)(v17.__sinval * v19));
      *(float *)(v8 + 36) = v123.f32[1] - (float)((float)(v17.__cosval * v19) + (float)(v17.__sinval * v18));
    }
    b2Contact::Update(v6, *(b2ContactListener **)v2);
    v20 = v126;
    v21 = *((_DWORD *)v126 + 3);
    *((_DWORD *)v126 + 3) = v21 & 0xFFFFFFDF;
    ++*((_DWORD *)v20 + 42);
    if ((~v21 & 6) == 0)
      break;
    *((_DWORD *)v20 + 3) = v21 & 0xFFFFFFDB;
    v24 = v144;
    *(_OWORD *)(v7 + 64) = v143;
    *(_OWORD *)(v7 + 80) = v24;
    *(_OWORD *)(v7 + 96) = v145;
    *(_DWORD *)(v7 + 112) = v146;
    v25 = v140;
    *(_OWORD *)(v8 + 64) = v139;
    *(_OWORD *)(v8 + 80) = v25;
    *(_OWORD *)(v8 + 96) = v141;
    *(_DWORD *)(v8 + 112) = v142;
    v26 = __sincosf_stret(*(float *)(v7 + 108));
    *(__float2 *)(v7 + 40) = v26;
    v27 = *(float *)(v7 + 64);
    v28 = *(float *)(v7 + 68);
    v29 = (float)(v26.__cosval * v27) - (float)(v26.__sinval * v28);
    v30 = (float)(v26.__cosval * v28) + (float)(v26.__sinval * v27);
    v31 = *(float *)(v7 + 100);
    *(float *)(v7 + 32) = *(float *)(v7 + 96) - v29;
    *(float *)(v7 + 36) = v31 - v30;
    v32 = __sincosf_stret(*(float *)(v8 + 108));
    *(__float2 *)(v8 + 40) = v32;
    v33 = *(float *)(v8 + 64);
    v34 = *(float *)(v8 + 68);
    v35 = *(float *)(v8 + 100) - (float)((float)(v32.__cosval * v34) + (float)(v32.__sinval * v33));
    *(float *)(v8 + 32) = *(float *)(v8 + 96) - (float)((float)(v32.__cosval * v33) - (float)(v32.__sinval * v34));
    *(float *)(v8 + 36) = v35;
LABEL_124:
    v4 = 0;
    if ((v5 & 1) == 0)
      goto LABEL_128;
  }
  b2Body::SetAwake((b2Body *)v7, 1);
  b2Body::SetAwake((b2Body *)v8, 1);
  v22 = v128;
  v129 = v128;
  v132 = v131;
  v133[2] = v133[1];
  *(_DWORD *)(v7 + 28) = 0;
  if (v22 >= v130)
  {
    v36 = (v130 - v22) >> 2;
    if (v36 <= 1)
      v36 = 1;
    if ((unint64_t)(v130 - v22) >= 0x7FFFFFFFFFFFFFF8)
      v37 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v37 = v36;
    v38 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKPoint>>((uint64_t)&v130, v37);
    *(_QWORD *)v38 = v7;
    v23 = v38 + 8;
    v41 = v128;
    v40 = v129;
    v42 = v38;
    if (v129 != v128)
    {
      do
      {
        v43 = *((_QWORD *)v40 - 1);
        v40 -= 8;
        *((_QWORD *)v42 - 1) = v43;
        v42 -= 8;
      }
      while (v40 != v41);
      v40 = v128;
    }
    v128 = v42;
    v129 = v38 + 8;
    v130 = &v38[8 * v39];
    if (v40)
      operator delete(v40);
  }
  else
  {
    *(_QWORD *)v22 = v7;
    v23 = v22 + 8;
  }
  v129 = v23;
  v44 = v128;
  v45 = (v23 - v128) >> 3;
  *(_DWORD *)(v8 + 28) = v45;
  if (v23 >= v130)
  {
    if ((unint64_t)(v45 + 1) >> 61)
      std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
    v47 = v130 - v44;
    v48 = v47 >> 2;
    if (v47 >> 2 <= (unint64_t)(v45 + 1))
      v48 = v45 + 1;
    if ((unint64_t)v47 >= 0x7FFFFFFFFFFFFFF8)
      v49 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v49 = v48;
    if (v49)
      v50 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKPoint>>((uint64_t)&v130, v49);
    else
      v50 = 0;
    v51 = &v50[8 * v45];
    *(_QWORD *)v51 = v8;
    v46 = v51 + 8;
    v53 = v128;
    v52 = v129;
    if (v129 != v128)
    {
      do
      {
        v54 = *((_QWORD *)v52 - 1);
        v52 -= 8;
        *((_QWORD *)v51 - 1) = v54;
        v51 -= 8;
      }
      while (v52 != v53);
      v52 = v128;
    }
    v128 = v51;
    v129 = v46;
    v130 = &v50[8 * v49];
    if (v52)
      operator delete(v52);
  }
  else
  {
    *(_QWORD *)v23 = v8;
    v46 = v23 + 8;
  }
  v129 = v46;
  v55 = v126;
  v56 = v132;
  v120 = v5;
  if ((unint64_t)v132 >= v133[0])
  {
    v58 = v132 - v131;
    if ((unint64_t)(v58 + 1) >> 61)
      std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
    v59 = (uint64_t)(v133[0] - (_QWORD)v131) >> 2;
    if (v59 <= v58 + 1)
      v59 = v58 + 1;
    if (v133[0] - (_QWORD)v131 >= 0x7FFFFFFFFFFFFFF8uLL)
      v60 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v60 = v59;
    if (v60)
      v61 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKPoint>>((uint64_t)v133, v60);
    else
      v61 = 0;
    v62 = (b2Contact **)&v61[8 * v58];
    *v62 = v55;
    v57 = v62 + 1;
    v64 = v131;
    v63 = v132;
    if (v132 != v131)
    {
      do
      {
        v65 = *--v63;
        *--v62 = v65;
      }
      while (v63 != v64);
      v63 = v131;
    }
    v131 = v62;
    v132 = v57;
    v133[0] = &v61[8 * v60];
    if (v63)
      operator delete(v63);
  }
  else
  {
    *v132 = v126;
    v57 = v56 + 1;
  }
  v66 = 0;
  v132 = v57;
  *(_WORD *)(v7 + 24) |= 1u;
  *(_WORD *)(v8 + 24) |= 1u;
  *((_DWORD *)v126 + 3) |= 1u;
  v138[0] = v7;
  v138[1] = v8;
  v121 = v8;
  v67 = 1;
  do
  {
    v68 = v67;
    v69 = v138[v66];
    if (*(_DWORD *)(v69 + 20) == 2)
    {
      for (j = *(_QWORD **)(v69 + 200); j; j = (_QWORD *)j[3])
      {
        v71 = j[1];
        if ((*(_BYTE *)(v71 + 12) & 1) == 0)
        {
          v72 = *j;
          if (*(_DWORD *)(*j + 20) != 2
            || (b2Body::IsBullet((b2Body *)v69) & 1) != 0
            || (b2Body::IsBullet((b2Body *)v72) & 1) != 0)
          {
            v73 = *(_DWORD **)(*(_QWORD *)(v71 + 80) + 24);
            v74 = *(_DWORD **)(*(_QWORD *)(v71 + 88) + 24);
            v75 = v74[2];
            if ((v75 & v73[3]) != 0
              || (v76 = v73[2], (v76 & v74[3]) != 0)
              || (v73[4] & v75) != 0
              || (v74[4] & v76) != 0)
            {
              v77 = *(_OWORD *)(v72 + 80);
              v134 = *(_OWORD *)(v72 + 64);
              v78 = *(_OWORD *)(v72 + 96);
              v79 = *(_OWORD *)(v72 + 112);
              v135 = v77;
              v136 = v78;
              v137 = v79;
              if ((*(_BYTE *)(v72 + 24) & 1) == 0)
              {
                v80 = v125;
                if ((LODWORD(v125) & 0x7FFFFFFFu) <= 0x7F7FFFFF)
                {
                  if (v125 > 1.0)
                    v80 = 1.0;
                  v124 = vmlaq_n_f32(*(float32x4_t *)(v72 + 80), vsubq_f32(*(float32x4_t *)(v72 + 96), *(float32x4_t *)(v72 + 80)), (float)(v80 - *(float *)(v72 + 112)) / (float)(1.0 - *(float *)(v72 + 112)));
                  *(float *)(v72 + 112) = v80;
                  *(float32x4_t *)(v72 + 80) = v124;
                  *(float32x4_t *)(v72 + 96) = v124;
                  v81 = __sincosf_stret(v124.f32[3]);
                  *(__float2 *)(v72 + 40) = v81;
                  v82 = *(float *)(v72 + 64);
                  v83 = *(float *)(v72 + 68);
                  *(float *)(v72 + 32) = v124.f32[0]
                                       - (float)((float)(v81.__cosval * v82) - (float)(v81.__sinval * v83));
                  *(float *)(v72 + 36) = v124.f32[1]
                                       - (float)((float)(v81.__cosval * v83) + (float)(v81.__sinval * v82));
                }
              }
              b2Contact::Update((b2Contact *)v71, *(b2ContactListener **)v2);
              v84 = *(_DWORD *)(v71 + 12);
              if ((v84 & 4) != 0 && (v84 & 2) != 0)
              {
                *(_DWORD *)(v71 + 12) = v84 | 1;
                v90 = v132;
                if ((unint64_t)v132 >= v133[0])
                {
                  v92 = v132 - v131;
                  if ((unint64_t)(v92 + 1) >> 61)
                    std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
                  v93 = (uint64_t)(v133[0] - (_QWORD)v131) >> 2;
                  if (v93 <= v92 + 1)
                    v93 = v92 + 1;
                  if (v133[0] - (_QWORD)v131 >= 0x7FFFFFFFFFFFFFF8uLL)
                    v94 = 0x1FFFFFFFFFFFFFFFLL;
                  else
                    v94 = v93;
                  if (v94)
                    v95 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKPoint>>((uint64_t)v133, v94);
                  else
                    v95 = 0;
                  v96 = &v95[8 * v92];
                  *(_QWORD *)v96 = v71;
                  v91 = (b2Contact **)(v96 + 8);
                  v98 = v131;
                  v97 = v132;
                  if (v132 != v131)
                  {
                    do
                    {
                      v99 = (uint64_t)*--v97;
                      *((_QWORD *)v96 - 1) = v99;
                      v96 -= 8;
                    }
                    while (v97 != v98);
                    v97 = v131;
                  }
                  v131 = (b2Contact **)v96;
                  v132 = v91;
                  v133[0] = &v95[8 * v94];
                  if (v97)
                    operator delete(v97);
                }
                else
                {
                  *v132 = (b2Contact *)v71;
                  v91 = v90 + 1;
                }
                v132 = v91;
                v100 = *(_WORD *)(v72 + 24);
                if ((v100 & 1) == 0)
                {
                  *(_WORD *)(v72 + 24) = v100 | 1;
                  if (*(_DWORD *)(v72 + 20))
                    b2Body::SetAwake((b2Body *)v72, 1);
                  v101 = v128;
                  v102 = v129;
                  v103 = (v129 - v128) >> 3;
                  *(_DWORD *)(v72 + 28) = v103;
                  if (v102 >= v130)
                  {
                    if ((unint64_t)(v103 + 1) >> 61)
                      std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
                    v105 = v130 - v101;
                    v106 = v105 >> 2;
                    if (v105 >> 2 <= (unint64_t)(v103 + 1))
                      v106 = v103 + 1;
                    if ((unint64_t)v105 >= 0x7FFFFFFFFFFFFFF8)
                      v107 = 0x1FFFFFFFFFFFFFFFLL;
                    else
                      v107 = v106;
                    if (v107)
                      v108 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKPoint>>((uint64_t)&v130, v107);
                    else
                      v108 = 0;
                    v109 = &v108[8 * v103];
                    *(_QWORD *)v109 = v72;
                    v104 = v109 + 8;
                    v111 = v128;
                    v110 = v129;
                    if (v129 != v128)
                    {
                      do
                      {
                        v112 = *((_QWORD *)v110 - 1);
                        v110 -= 8;
                        *((_QWORD *)v109 - 1) = v112;
                        v109 -= 8;
                      }
                      while (v110 != v111);
                      v110 = v128;
                    }
                    v128 = v109;
                    v129 = v104;
                    v130 = &v108[8 * v107];
                    if (v110)
                      operator delete(v110);
                  }
                  else
                  {
                    *(_QWORD *)v102 = v72;
                    v104 = v102 + 8;
                  }
                  v129 = v104;
                }
              }
              else
              {
                *(_DWORD *)(v72 + 112) = v137;
                v85 = v136;
                *(_OWORD *)(v72 + 80) = v135;
                *(_OWORD *)(v72 + 96) = v85;
                *(_OWORD *)(v72 + 64) = v134;
                v86 = __sincosf_stret(*(float *)(v72 + 108));
                *(__float2 *)(v72 + 40) = v86;
                v87 = *(float *)(v72 + 64);
                v88 = *(float *)(v72 + 68);
                v89 = *(float *)(v72 + 100) - (float)((float)(v86.__cosval * v88) + (float)(v86.__sinval * v87));
                *(float *)(v72 + 32) = *(float *)(v72 + 96)
                                     - (float)((float)(v86.__cosval * v87) - (float)(v86.__sinval * v88));
                *(float *)(v72 + 36) = v89;
              }
            }
          }
        }
      }
    }
    v67 = 0;
    v66 = 1;
  }
  while ((v68 & 1) != 0);
  v113 = 1.0 / (float)((float)(1.0 - v125) * *(float *)a2);
  *(float *)&v134 = (float)(1.0 - v125) * *(float *)a2;
  *((float *)&v134 + 1) = v113;
  v114 = *(_DWORD *)(a2 + 12);
  DWORD2(v134) = 1065353216;
  HIDWORD(v134) = v114;
  LODWORD(v135) = 20;
  BYTE4(v135) = 0;
  b2Island::SolveTOI(v127, &v134, *(_DWORD *)(v7 + 28), *(_DWORD *)(v121 + 28), *((float *)v2 + 64));
  v115 = v128;
  v116 = v129;
  while (v115 != v116)
  {
    v117 = *(_QWORD *)v115;
    *(_WORD *)(v117 + 24) = *(_WORD *)(*(_QWORD *)v115 + 24) & 0xFFFE;
    if (*(_DWORD *)(v117 + 20) == 2)
    {
      b2Body::SynchronizeFixtures((b2Body *)v117);
      for (k = *(_QWORD *)(v117 + 200); k; k = *(_QWORD *)(k + 24))
        *(_DWORD *)(*(_QWORD *)(k + 8) + 12) &= 0xFFFFFFDE;
    }
    v115 += 8;
  }
  b2ContactManager::FindNewContacts((b2Body *)v2);
  v5 = v120;
  if (!v2[246])
    goto LABEL_124;
  v2[247] = 0;
LABEL_128:
  b2Island::~b2Island((b2Island *)v127);
}

void sub_208FBC4A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, ...)
{
  va_list va;

  va_start(va, a14);
  b2Island::~b2Island((b2Island *)va);
  _Unwind_Resume(a1);
}

void b2World::Step(b2World *this, float a2, int a3, int a4)
{
  float v6;
  float *v8;
  unsigned int v9;
  float v10;
  int v11;
  uint64_t i;
  __int128 v13;
  int v14;
  char v15;

  v6 = a2;
  v8 = (float *)((char *)this + 102936);
  *((double *)this + 12899) = *((double *)this + 12899) + a2;
  v9 = *((_DWORD *)this + 25734);
  if ((v9 & 1) != 0)
  {
    b2ContactManager::FindNewContacts((b2Body *)((char *)this + 102944));
    v9 = *(_DWORD *)v8 & 0xFFFFFFFE;
  }
  *(_DWORD *)v8 = v9 | 2;
  HIDWORD(v13) = a3;
  v14 = a4;
  v10 = 1.0 / v6;
  if (v6 <= 0.0)
    v10 = 0.0;
  *(_QWORD *)&v13 = __PAIR64__(LODWORD(v10), LODWORD(v6));
  *((float *)&v13 + 2) = v8[62] * v6;
  v15 = *((_BYTE *)v8 + 252);
  b2ContactManager::Collide((b2ContactManager *)((char *)this + 102944));
  if (*((_BYTE *)v8 + 255) && v6 > 0.0)
  {
    PKCMechanics::Solve((uint64_t)this + 103224, &v13);
    b2World::Solve((b2StackAllocator *)this, &v13);
    LODWORD(v6) = v13;
  }
  if (*((_BYTE *)v8 + 253) && v6 > 0.0)
  {
    b2World::SolveTOI((b2ContactListener **)this, (uint64_t)&v13);
    LODWORD(v6) = v13;
  }
  if (v6 > 0.0)
    v8[62] = *((float *)&v13 + 1);
  v11 = *(_DWORD *)v8;
  if ((*(_DWORD *)v8 & 4) != 0)
  {
    for (i = *((_QWORD *)v8 + 24); i; i = *(_QWORD *)(i + 168))
    {
      *(_QWORD *)(i + 144) = 0;
      *(_DWORD *)(i + 140) = 0;
    }
  }
  *(_DWORD *)v8 = v11 & 0xFFFFFFFD;
}

b2World *b2World::ClearForces(b2World *this)
{
  uint64_t i;

  for (i = *((_QWORD *)this + 12891); i; i = *(_QWORD *)(i + 168))
  {
    *(_QWORD *)(i + 144) = 0;
    *(_DWORD *)(i + 140) = 0;
  }
  return this;
}

uint64_t b2World::QueryAABB(uint64_t a1, uint64_t a2, float *a3)
{
  _QWORD v7[2];

  v7[0] = a1 + 102944;
  v7[1] = a2;
  b2DynamicTree::Query<b2WorldQueryWrapper>((int *)(a1 + 102960), (uint64_t)v7, a3);
  return PKCMechanics::QueryAABB(a1 + 103224, a2, a3);
}

uint64_t b2World::RayCast(uint64_t a1, uint64_t a2, _QWORD *a3, uint64_t *a4)
{
  uint64_t v7;
  _QWORD v9[2];
  int v10;
  _QWORD v11[2];

  v11[0] = a1 + 102944;
  v11[1] = a2;
  v10 = 1065353216;
  v7 = *a4;
  v9[0] = *a3;
  v9[1] = v7;
  b2DynamicTree::RayCast<b2WorldRayCastWrapper>((int *)(a1 + 102960), (uint64_t)v11, (float *)v9);
  return PKCMechanics::QueryAABB(a1 + 103224, a2, a3);
}

void b2World::DrawShape(uint64_t a1, uint64_t a2, b2Transform *a3, QuadTreeNode *a4)
{
  uint64_t v4;
  float var1;
  float var0;
  float v10;
  float v11;
  float v12;
  float y;
  float v14;
  float v15;
  float v16;
  float v17;
  float x;
  float v19;
  float v20;
  float v21;
  uint64_t v22;
  void *v23;
  uint64_t v24;
  float *v25;
  float32x2_t *v26;
  b2Rot v27;
  float32x2_t v28;
  float *v29;
  unint64_t v30;
  _QWORD *v31;
  float *v32;
  uint64_t v33;
  void *__p;
  void *v35;
  uint64_t v36;
  void *v37;

  v4 = *(_QWORD *)(a2 + 32);
  switch(*(_DWORD *)(v4 + 8))
  {
    case 0:
      var0 = a3->var1.var0;
      var1 = a3->var1.var1;
      v11 = *(float *)(v4 + 16);
      v10 = *(float *)(v4 + 20);
      v12 = *(float *)(v4 + 12);
      y = a3->var0.y;
      *(float *)&__p = a3->var0.x + (float)((float)(var1 * v11) - (float)(var0 * v10));
      *((float *)&__p + 1) = (float)((float)(var1 * v10) + (float)(var0 * v11)) + y;
      *(float *)&v37 = var1 - (float)(var0 * 0.0);
      *((float *)&v37 + 1) = var0 + (float)(var1 * 0.0);
      (*(void (**)(_QWORD, void **, void **, QuadTreeNode *, float))(**(_QWORD **)(a1 + 103176) + 40))(*(_QWORD *)(a1 + 103176), &__p, &v37, a4, v12);
      break;
    case 1:
      v15 = a3->var1.var0;
      v14 = a3->var1.var1;
      v16 = *(float *)(v4 + 16);
      v17 = *(float *)(v4 + 20);
      x = a3->var0.x;
      v19 = a3->var0.y;
      *(float *)&__p = a3->var0.x + (float)((float)(v14 * v16) - (float)(v15 * v17));
      *((float *)&__p + 1) = (float)((float)(v14 * v17) + (float)(v15 * v16)) + v19;
      v20 = *(float *)(v4 + 24);
      v21 = *(float *)(v4 + 28);
      *(float *)&v37 = x + (float)((float)(v14 * v20) - (float)(v15 * v21));
      *((float *)&v37 + 1) = v19 + (float)((float)(v14 * v21) + (float)(v15 * v20));
      (*(void (**)(_QWORD, void **, void **, QuadTreeNode *))(**(_QWORD **)(a1 + 103176) + 48))(*(_QWORD *)(a1 + 103176), &__p, &v37, a4);
      break;
    case 2:
      v22 = *(_QWORD *)(v4 + 24) - *(_QWORD *)(v4 + 16);
      __p = 0;
      v35 = 0;
      v36 = 0;
      std::vector<b2Vec2>::resize((uint64_t)&__p, (int)(v22 >> 3));
      v23 = __p;
      if ((int)((unint64_t)v22 >> 3) >= 1)
      {
        v24 = ((unint64_t)v22 >> 3);
        v25 = (float *)(*(_QWORD *)(v4 + 16) + 4);
        v26 = (float32x2_t *)__p;
        do
        {
          v27 = a3->var1;
          v28 = (float32x2_t)vrev64_s32((int32x2_t)v27);
          v27.var0 = -v27.var0;
          *v26++ = vadd_f32((float32x2_t)a3->var0, vmla_n_f32(vmul_n_f32((float32x2_t)v27, *v25), v28, *(v25 - 1)));
          v25 += 2;
          --v24;
        }
        while (v24);
      }
      (*(void (**)(_QWORD, void *))(**(_QWORD **)(a1 + 103176) + 24))(*(_QWORD *)(a1 + 103176), v23);
      if (__p)
      {
        v35 = __p;
        operator delete(__p);
      }
      break;
    case 3:
      v29 = *(float **)(v4 + 16);
      v30 = *(_QWORD *)(v4 + 24) - (_QWORD)v29;
      __p = (void *)__PAIR64__((float)((float)(a3->var1.var1 * v29[1]) + (float)(a3->var1.var0 * *v29)) + a3->var0.y, a3->var0.x + (float)((float)(a3->var1.var1 * *v29) - (float)(a3->var1.var0 * v29[1])));
      if ((int)(v30 >> 3) >= 2)
      {
        v31 = (_QWORD *)(a1 + 103176);
        v32 = v29 + 3;
        v33 = (v30 >> 3) - 1;
        do
        {
          v37 = (void *)__PAIR64__((float)((float)(a3->var1.var1 * *v32) + (float)(a3->var1.var0 * *(v32 - 1))) + a3->var0.y, a3->var0.x + (float)((float)(a3->var1.var1 * *(v32 - 1)) - (float)(a3->var1.var0 * *v32)));
          (*(void (**)(_QWORD, void **, void **, QuadTreeNode *))(*(_QWORD *)*v31 + 48))(*v31, &__p, &v37, a4);
          __p = v37;
          v32 += 2;
          --v33;
        }
        while (v33);
      }
      break;
    case 4:
      drawQuadtree((float *)&a3->var0, *(b2Draw **)(a1 + 103176), **(QuadTree ***)(v4 + 16), a4);
      break;
    default:
      return;
  }
}

void sub_208FBC9E4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

float *drawQuadtree(float *result, b2Draw *a2, QuadTree *a3, QuadTreeNode *a4)
{
  const b2Transform *v6;
  QuadTree *v7;
  float v8;
  float v9;
  float v10;
  float v11;
  float v12;
  float v13;
  float v14;
  float v15;
  float v16;
  float v17;
  QuadTree *v18;
  QuadTree *v19;
  QuadTree *v20;
  uint64_t v21;
  int v22;
  float v23[2];
  float v24[2];

  v6 = (const b2Transform *)result;
  v7 = *(QuadTree **)a3;
  if (v7)
    goto LABEL_2;
  if (!*((_QWORD *)a3 + 1) && !*((_QWORD *)a3 + 2) && !*((_QWORD *)a3 + 3))
  {
    v9 = result[2];
    v8 = result[3];
    v10 = *((float *)a3 + 10);
    v11 = *((float *)a3 + 11);
    v12 = *((float *)a3 + 8);
    v13 = *((float *)a3 + 9);
    v14 = (float)(v8 * v12) - (float)(v9 * v10);
    v15 = (float)(v10 * v8) + (float)(v9 * v12);
    v16 = *result;
    v17 = result[1];
    v24[0] = *result + v14;
    v24[1] = v15 + v17;
    v23[0] = v16 + (float)((float)(v8 * v13) - (float)(v9 * v11));
    v23[1] = v17 + (float)((float)(v8 * v11) + (float)(v9 * v13));
    v21 = 0x3F80000000000000;
    v22 = 0;
    result = (float *)(*(uint64_t (**)(b2Draw *, float *, float *, uint64_t *))(*(_QWORD *)a2 + 48))(a2, v24, v23, &v21);
    v7 = *(QuadTree **)a3;
    if (*(_QWORD *)a3)
LABEL_2:
      result = (float *)drawQuadtree(v6, a2, v7, a4);
  }
  v18 = (QuadTree *)*((_QWORD *)a3 + 1);
  if (v18)
    result = (float *)drawQuadtree(v6, a2, v18, a4);
  v19 = (QuadTree *)*((_QWORD *)a3 + 2);
  if (v19)
    result = (float *)drawQuadtree(v6, a2, v19, a4);
  v20 = (QuadTree *)*((_QWORD *)a3 + 3);
  if (v20)
    return (float *)drawQuadtree(v6, a2, v20, a4);
  return result;
}

void b2World::DrawJoint(b2World *this, b2Joint *a2)
{
  b2Vec2 var0;
  int v5;
  int v6;
  int var1;
  int v8;
  int v9;
  void (*v10)(void);
  _DWORD v11[2];
  _DWORD v12[2];
  uint64_t v13;
  int v14;
  _DWORD v15[2];
  _DWORD v16[2];
  b2Vec2 v17;
  b2Vec2 v18;

  var0 = a2->var6->var8.var0;
  v17 = a2->var7->var8.var0;
  v18 = var0;
  v16[0] = ((float (*)(b2Joint *))*a2->var0)(a2);
  v16[1] = v5;
  v15[0] = (*((float (**)(b2Joint *))a2->var0 + 1))(a2);
  v15[1] = v6;
  v13 = 0x3F4CCCCD3F000000;
  v14 = 1061997773;
  var1 = a2->var1;
  if (var1 != 5)
  {
    if (var1 == 4)
    {
      v12[0] = b2PulleyJoint::GetGroundAnchorA((b2PulleyJoint *)a2);
      v12[1] = v8;
      v11[0] = b2PulleyJoint::GetGroundAnchorB((b2PulleyJoint *)a2);
      v11[1] = v9;
      (*(void (**)(_QWORD, _DWORD *, _DWORD *, uint64_t *))(**((_QWORD **)this + 12897) + 48))(*((_QWORD *)this + 12897), v12, v16, &v13);
      (*(void (**)(_QWORD, _DWORD *, _DWORD *, uint64_t *))(**((_QWORD **)this + 12897) + 48))(*((_QWORD *)this + 12897), v11, v15, &v13);
      v10 = *(void (**)(void))(**((_QWORD **)this + 12897) + 48);
    }
    else
    {
      if (var1 != 3)
      {
        (*(void (**)(_QWORD, b2Vec2 *, _DWORD *, uint64_t *))(**((_QWORD **)this + 12897) + 48))(*((_QWORD *)this + 12897), &v18, v16, &v13);
        (*(void (**)(_QWORD, _DWORD *, _DWORD *, uint64_t *))(**((_QWORD **)this + 12897) + 48))(*((_QWORD *)this + 12897), v16, v15, &v13);
      }
      v10 = *(void (**)(void))(**((_QWORD **)this + 12897) + 48);
    }
    v10();
  }
}

void b2World::DrawDebugData(b2World *this)
{
  char *v2;
  b2Draw *v3;
  char Flags;
  b2Joint *i;
  uint64_t j;
  _QWORD *k;
  uint64_t v8;
  uint64_t v9;
  unsigned int v10;
  uint64_t v11;
  unsigned int v12;
  __int128 v13;
  uint64_t m;
  float32x4_t v15;
  double v16;
  float v17;
  float v18;
  float v19;
  uint64_t v20;
  uint64_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  uint64_t v25;
  uint64_t v26;
  int v27;
  float v28[2];
  float32x2_t v29;
  uint64_t v30;
  int v31;
  _BYTE v32[20];
  unsigned int v33;
  void *__p;
  void *v35;
  uint64_t v36;

  v36 = *MEMORY[0x24BDAC8D0];
  v2 = (char *)this + 102968;
  v3 = (b2Draw *)*((_QWORD *)this + 12897);
  if (v3)
  {
    Flags = b2Draw::GetFlags(v3);
    if ((Flags & 2) != 0)
    {
      for (i = (b2Joint *)*((_QWORD *)v2 + 21); i; i = i->var3)
        b2World::DrawJoint(this, i);
    }
    if ((Flags & 4) != 0)
    {
      v30 = 0x3E99999A3F666666;
      v31 = 1063675494;
      for (j = *((_QWORD *)v2 + 20); j; j = *(_QWORD *)(j + 168))
      {
        if (b2Body::IsActive((b2Body *)j))
        {
          for (k = *(_QWORD **)(j + 176); k; k = (_QWORD *)k[2])
          {
            v8 = k[6];
            v9 = k[7];
            while (v8 != v9)
            {
              v10 = *(_DWORD *)(v8 + 24);
              if ((v10 & 0x80000000) != 0 || *((_DWORD *)v2 + 3) <= (signed int)v10)
                b2ContactManager::FindNewContacts();
              v11 = *(_QWORD *)v2 + 48 * v10;
              v12 = *(_DWORD *)(v11 + 12);
              *(_QWORD *)&v13 = *(_QWORD *)(v11 + 4);
              *((_QWORD *)&v13 + 1) = v13;
              *(_DWORD *)v32 = *(_DWORD *)v11;
              *(_OWORD *)&v32[4] = v13;
              v33 = v12;
              __p = (void *)__PAIR64__(v12, *(unsigned int *)v32);
              (*(void (**)(_QWORD, _BYTE *, uint64_t, uint64_t *))(**((_QWORD **)v2 + 26) + 16))(*((_QWORD *)v2 + 26), v32, 4, &v30);
              v8 += 32;
            }
          }
        }
      }
    }
    if ((Flags & 0x10) != 0)
    {
      for (m = *((_QWORD *)v2 + 20); m; m = *(_QWORD *)(m + 168))
      {
        *(_OWORD *)v32 = *(_OWORD *)(m + 32);
        *(_QWORD *)v32 = *(_QWORD *)(m + 96);
        (*(void (**)(_QWORD, _BYTE *))(**((_QWORD **)v2 + 26) + 56))(*((_QWORD *)v2 + 26), v32);
      }
    }
    if ((Flags & 0x20) != 0)
    {
      v27 = 0;
      (*(void (**)(_QWORD, float32x2_t *, float *, int *))(**((_QWORD **)v2 + 26) + 64))(*((_QWORD *)v2 + 26), &v29, v28, &v27);
      if (v27 >= 1)
      {
        PKCAether::Evaluator::Evaluator((PKCAether::Evaluator *)v32, *((const PKCAether **)v2 + 23));
        v30 = 0x3E99999A3F666666;
        v31 = 1050253722;
        v17 = v28[0] - v29.f32[0];
        if ((float)(v28[0] - v29.f32[0]) > 0.0)
        {
          v18 = v28[1] - v29.f32[1];
          v15.i32[0] = 0;
          v23 = v15;
          v19 = v17 / (float)v27;
          do
          {
            if (v18 > 0.0)
            {
              v15.i32[0] = 0;
              do
              {
                v24 = v15;
                *(float32x2_t *)v15.f32 = vadd_f32((float32x2_t)__PAIR64__(v15.u32[0], v23.u32[0]), v29);
                v26 = v15.i64[0];
                v15.i32[2] = 0;
                LODWORD(v16) = 1.0;
                PKCAether::Evaluator::evalForce((float32x4_t *)v32, -1, 0.0, v15, (__n128)0, v16, 0.0, *((double *)v2 + 28));
                v20 = *((_QWORD *)v2 + 26);
                v25 = v21;
                (*(void (**)(uint64_t, uint64_t *, uint64_t *, uint64_t *))(*(_QWORD *)v20 + 72))(v20, &v26, &v25, &v30);
                v15 = v24;
                v15.f32[0] = v19 + v24.f32[0];
              }
              while ((float)(v19 + v24.f32[0]) < v18);
            }
            v22 = v23;
            v22.f32[0] = v19 + v23.f32[0];
            v23 = v22;
          }
          while (v22.f32[0] < v17);
        }
        if (__p)
        {
          v35 = __p;
          operator delete(__p);
        }
        v30 = (uint64_t)v32;
        std::vector<std::shared_ptr<PKCField>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v30);
      }
    }
  }
}

void sub_208FBCF74(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_list va;

  va_start(va, a13);
  PKCAether::Evaluator::~Evaluator((PKCAether::Evaluator *)va);
  _Unwind_Resume(a1);
}

void **b2DynamicTree::Query<b2WorldQueryWrapper>(int *a1, uint64_t a2, float *a3)
{
  int v6;
  int v7;
  _DWORD *i;
  uint64_t v9;
  int v10;
  uint64_t v11;
  float *v12;
  uint64_t v13;
  int v14;
  _DWORD *v15;
  int v16;
  int v17;
  uint64_t FixtureProxy;
  int v19;
  int v20;
  int v21;
  int v22;
  _DWORD *v24;
  _DWORD v25[256];
  int v26;
  int v27;

  v24 = v25;
  v6 = *a1;
  v27 = 256;
  v25[0] = v6;
  v7 = 1;
  for (i = v25; ; i = v24)
  {
    while (1)
    {
      v9 = (v7 - 1);
      v26 = v9;
      v10 = i[v9];
      if (v10 != -1)
      {
        v11 = *((_QWORD *)a1 + 1);
        v12 = (float *)(v11 + 48 * v10);
        if ((float)(*a3 - v12[2]) <= 0.0
          && (float)(a3[1] - v12[3]) <= 0.0
          && (float)(*v12 - a3[2]) <= 0.0
          && (float)(v12[1] - a3[3]) <= 0.0)
        {
          break;
        }
      }
LABEL_23:
      v7 = v9;
      if ((int)v9 < 1)
        return b2GrowableStack<int,256>::~b2GrowableStack((void **)&v24);
    }
    v13 = v11 + 48 * v10;
    v16 = *(_DWORD *)(v13 + 36);
    v15 = (_DWORD *)(v13 + 36);
    v14 = v16;
    if (v16 != -1)
    {
      v17 = v27;
      if (v7 <= v27)
      {
        i[v9] = v14;
      }
      else
      {
        v27 *= 2;
        v24 = b2Alloc(8 * v17);
        memcpy(v24, i, 4 * v26);
        if (i != v25)
          b2Free(i);
        i = v24;
        v24[v26] = *v15;
      }
      v21 = v26 + 1;
      v26 = v21;
      v22 = v27;
      if (v21 >= v27)
      {
        v27 *= 2;
        v24 = b2Alloc(8 * v22);
        memcpy(v24, i, 4 * v26);
        if (i != v25)
          b2Free(i);
        i = v24;
        v21 = v26;
      }
      i[v21] = *(_DWORD *)(v11 + 48 * v10 + 40);
      LODWORD(v9) = ++v26;
      goto LABEL_23;
    }
    FixtureProxy = b2ContactManager::GetFixtureProxy(*(b2ContactManager **)a2, i[v9]);
    v19 = (*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)(a2 + 8) + 16))(*(_QWORD *)(a2 + 8), *(_QWORD *)(FixtureProxy + 16));
    v7 = v26;
    v20 = v26 > 0 ? v19 : 0;
    if (v20 != 1)
      break;
  }
  return b2GrowableStack<int,256>::~b2GrowableStack((void **)&v24);
}

void sub_208FBD1A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9)
{
  b2GrowableStack<int,256>::~b2GrowableStack(&a9);
  _Unwind_Resume(a1);
}

uint64_t b2ContactManager::GetFixtureProxy(b2ContactManager *this, unsigned int a2)
{
  if ((a2 & 0x80000000) != 0 || *((_DWORD *)this + 9) <= (signed int)a2)
    b2ContactManager::FindNewContacts();
  return *(_QWORD *)(*((_QWORD *)this + 3) + 48 * a2 + 16);
}

void **b2DynamicTree::RayCast<b2WorldRayCastWrapper>(int *a1, uint64_t a2, float *a3)
{
  float v3;
  float v4;
  float v5;
  float v6;
  float v7;
  float v11;
  float v12;
  float v13;
  float v14;
  float v15;
  float v16;
  float v17;
  float v18;
  float v19;
  float v20;
  float v21;
  float v22;
  int v23;
  int v24;
  uint64_t v25;
  _DWORD *v26;
  signed int v27;
  uint64_t v28;
  float *v29;
  float v30;
  float v31;
  float v32;
  float v33;
  float v34;
  float v35;
  float v36;
  float v37;
  float v38;
  float v39;
  uint64_t v40;
  int v41;
  _DWORD *v42;
  int v43;
  int v44;
  float v45;
  float v46;
  float v47;
  int v48;
  int v49;
  float v51;
  float v52;
  float v53;
  float v54;
  float v55;
  float v56;
  __int128 v57;
  float v58;
  _DWORD *v59;
  _DWORD v60[256];
  int v61;
  int v62;

  v3 = *a3;
  v4 = a3[1];
  v5 = a3[2] - *a3;
  v6 = a3[3] - v4;
  v7 = (float)(v6 * v6) + (float)(v5 * v5);
  if (v7 <= 0.0)
    b2DynamicTree::RayCast<b2WorldRayCastWrapper>();
  v11 = sqrtf(v7);
  v12 = a3[2] - *a3;
  v13 = a3[3] - v4;
  if (v11 >= 0.00000011921)
  {
    v12 = v5 * (float)(1.0 / v11);
    v13 = v6 * (float)(1.0 / v11);
  }
  v14 = -v13;
  if (v13 >= 0.0)
    v15 = v13;
  else
    v15 = -v13;
  if (v12 <= 0.0)
    v16 = -v12;
  else
    v16 = v12;
  v51 = a3[3] - v4;
  v52 = a3[2] - *a3;
  v53 = a3[4];
  v17 = v3 + (float)(v5 * v53);
  v18 = v4 + (float)(v6 * v53);
  if (v3 >= v17)
    v19 = v3 + (float)(v5 * v53);
  else
    v19 = *a3;
  if (v3 <= v17)
    v20 = v3 + (float)(v5 * v53);
  else
    v20 = *a3;
  if (v4 >= v18)
    v21 = v4 + (float)(v6 * v53);
  else
    v21 = a3[1];
  if (v4 <= v18)
    v22 = v4 + (float)(v6 * v53);
  else
    v22 = a3[1];
  v59 = v60;
  v23 = *a1;
  v62 = 256;
  v60[0] = v23;
  v24 = 1;
  v55 = v15;
  v56 = v12;
  v54 = v16;
  do
  {
    v25 = (v24 - 1);
    v61 = v25;
    v26 = v59;
    v27 = v59[v25];
    if (v27 == -1)
      goto LABEL_58;
    v28 = *((_QWORD *)a1 + 1);
    v29 = (float *)(v28 + 48 * v27);
    v30 = v29[2];
    if ((float)(v19 - v30) > 0.0)
      goto LABEL_58;
    v31 = v29[3];
    if ((float)(v21 - v31) > 0.0)
      goto LABEL_58;
    v32 = *v29;
    if ((float)(*v29 - v20) > 0.0)
      goto LABEL_58;
    v33 = v29[1];
    if ((float)(v33 - v22) > 0.0)
      goto LABEL_58;
    v34 = (float)(v30 + v32) * 0.5;
    v35 = (float)(v31 + v33) * 0.5;
    v36 = (float)(v30 - v32) * 0.5;
    v37 = (float)(v31 - v33) * 0.5;
    v38 = (float)(v12 * (float)(v4 - v35)) + (float)(v14 * (float)(v3 - v34));
    v39 = -v38;
    if (v38 > 0.0)
      v39 = v38;
    if ((float)(v39 - (float)((float)(v16 * v37) + (float)(v15 * v36))) > 0.0)
      goto LABEL_58;
    v40 = v28 + 48 * v27;
    v43 = *(_DWORD *)(v40 + 36);
    v42 = (_DWORD *)(v40 + 36);
    v41 = v43;
    if (v43 != -1)
    {
      v44 = v62;
      if (v24 <= v62)
      {
        v59[v25] = v41;
      }
      else
      {
        v62 *= 2;
        v59 = b2Alloc(8 * v44);
        memcpy(v59, v26, 4 * v61);
        if (v26 != v60)
          b2Free(v26);
        v26 = v59;
        v59[v61] = *v42;
        v15 = v55;
        v12 = v56;
        v16 = v54;
      }
      v48 = v61 + 1;
      v61 = v48;
      v49 = v62;
      if (v48 >= v62)
      {
        v62 *= 2;
        v59 = b2Alloc(8 * v49);
        memcpy(v59, v26, 4 * v61);
        if (v26 != v60)
          b2Free(v26);
        v26 = v59;
        v48 = v61;
        v15 = v55;
        v12 = v56;
        v16 = v54;
      }
      v26[v48] = *(_DWORD *)(v28 + 48 * v27 + 40);
      LODWORD(v25) = ++v61;
      goto LABEL_58;
    }
    v57 = *(_OWORD *)a3;
    v58 = v53;
    v45 = b2WorldRayCastWrapper::RayCastCallback(a2, (float32x2_t *)&v57, v27);
    v15 = v55;
    v12 = v56;
    v16 = v54;
    if (v45 > 0.0)
    {
      v46 = v3 + (float)(v52 * v45);
      v47 = v4 + (float)(v51 * v45);
      if (v3 >= v46)
        v19 = v3 + (float)(v52 * v45);
      else
        v19 = v3;
      if (v3 <= v46)
        v20 = v3 + (float)(v52 * v45);
      else
        v20 = v3;
      if (v4 >= v47)
        v21 = v4 + (float)(v51 * v45);
      else
        v21 = v4;
      if (v4 <= v47)
        v22 = v4 + (float)(v51 * v45);
      else
        v22 = v4;
      v53 = v45;
    }
    if (v45 == 0.0)
      break;
    LODWORD(v25) = v61;
LABEL_58:
    v24 = v25;
  }
  while ((int)v25 >= 1);
  return b2GrowableStack<int,256>::~b2GrowableStack((void **)&v59);
}

void sub_208FBD53C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  b2GrowableStack<int,256>::~b2GrowableStack((void **)va);
  _Unwind_Resume(a1);
}

float32_t b2WorldRayCastWrapper::RayCastCallback(uint64_t a1, float32x2_t *a2, unsigned int a3)
{
  uint64_t FixtureProxy;
  uint64_t v6;
  float32_t result;
  float32x2_t v8;
  _BYTE v9[8];
  float v10;

  FixtureProxy = b2ContactManager::GetFixtureProxy(*(b2ContactManager **)a1, a3);
  v6 = *(_QWORD *)(FixtureProxy + 16);
  if (!(*(unsigned int (**)(_QWORD, _BYTE *, float32x2_t *, uint64_t, _QWORD))(**(_QWORD **)(v6 + 32) + 48))(*(_QWORD *)(v6 + 32), v9, a2, *(_QWORD *)(v6 + 24) + 32, *(unsigned int *)(FixtureProxy + 28)))return a2[2].f32[0];
  v8 = vadd_f32(vmul_n_f32(*a2, 1.0 - v10), vmul_n_f32(a2[1], v10));
  (*(void (**)(_QWORD, uint64_t, float32x2_t *, _BYTE *))(**(_QWORD **)(a1 + 8) + 16))(*(_QWORD *)(a1 + 8), v6, &v8, v9);
  return result;
}

void PKCLineSeg::updateRelativeTheta(PKCLineSeg *this, double a2, double a3)
{
  float v6;
  float v7;
  double v8;
  float v9;
  float v10;
  double v11;
  float v12;
  float v13;

  v7 = *(float *)this;
  v6 = *((float *)this + 1);
  v8 = atan2(v6 - a3, *(float *)this - a2) + 6.28318531;
  *((double *)this + 2) = v8;
  v10 = *((float *)this + 2);
  v9 = *((float *)this + 3);
  v11 = atan2(v9 - a3, v10 - a2) + 6.28318531;
  *((double *)this + 3) = v11;
  v12 = a2;
  v13 = a3;
  if ((float)((float)((float)(v7 - v12) * (float)(v9 - v13)) - (float)((float)(v6 - v13) * (float)(v10 - v12))) > 0.0)
  {
    *((double *)this + 2) = v11;
    *((double *)this + 3) = v8;
    *(float *)this = v10;
    *((float *)this + 1) = v9;
    *((float *)this + 2) = v7;
    *((float *)this + 3) = v6;
  }
}

float *PKCLineSeg::mergeColinear(float *this, const PKCLineSeg *a2)
{
  float v2;
  float v3;
  int v4;
  float v5;
  int v6;

  v2 = *(float *)a2;
  if (vabds_f32(*this, *(float *)a2) < 0.00011921 && vabds_f32(this[1], *((float *)a2 + 1)) < 0.00011921)
  {
    *(_QWORD *)this = *((_QWORD *)a2 + 1);
    return this;
  }
  v3 = *((float *)a2 + 2);
  if (vabds_f32(*this, v3) < 0.00011921 && vabds_f32(this[1], *((float *)a2 + 3)) < 0.00011921)
  {
    v4 = *((_DWORD *)a2 + 1);
    *this = v2;
    *((_DWORD *)this + 1) = v4;
    return this;
  }
  if (vabds_f32(this[2], v2) >= 0.00011921)
  {
    v5 = *((float *)a2 + 1);
  }
  else
  {
    v5 = *((float *)a2 + 1);
    if (vabds_f32(this[3], v5) < 0.00011921)
    {
      v6 = *((_DWORD *)a2 + 3);
      this[2] = v3;
      *((_DWORD *)this + 3) = v6;
      return this;
    }
  }
  this[2] = v2;
  this[3] = v5;
  return this;
}

uint64_t PKCLineSeg::intersect(PKCLineSeg *this, const PKCLineSeg *a2)
{
  double v3;
  double v4;

  return lineIntersection(*(float *)this, *((float *)this + 1), *((float *)this + 2), *((float *)this + 3), *(float *)a2, *((float *)a2 + 1), *((float *)a2 + 2), *((float *)a2 + 3), &v4, &v3);
}

uint64_t lineIntersection(double a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double *a9, double *a10)
{
  double v10;
  double v11;
  double v12;
  double v13;
  double v14;
  double v15;
  double v16;
  double v17;
  double v18;
  double v19;
  double v20;
  double v21;

  if (vabdd_f64(a1, a3) < 0.00011920929 && vabdd_f64(a2, a4) < 0.00011920929)
    return 0;
  if (vabdd_f64(a5, a7) < 0.00011920929 && vabdd_f64(a6, a8) < 0.00011920929)
    return 0;
  if (vabdd_f64(a1, a5) < 0.00011920929 && vabdd_f64(a2, a6) < 0.00011920929)
    return 0;
  if (vabdd_f64(a3, a5) < 0.00011920929 && vabdd_f64(a4, a6) < 0.00011920929)
    return 0;
  if (vabdd_f64(a1, a7) < 0.00011920929 && vabdd_f64(a2, a8) < 0.00011920929)
    return 0;
  if (vabdd_f64(a3, a7) < 0.00011920929 && vabdd_f64(a4, a8) < 0.00011920929)
    return 0;
  v10 = a3 - a1;
  v11 = a4 - a2;
  v12 = a5 - a1;
  v13 = a6 - a2;
  v14 = a7 - a1;
  v15 = a8 - a2;
  v16 = sqrt(v11 * v11 + v10 * v10);
  v17 = v10 / v16;
  v18 = v11 / v16;
  v19 = v13 * v17 - v12 * (v11 / v16);
  v20 = v15 * v17 - v14 * (v11 / v16);
  if (v19 < 0.0 && v20 < 0.0)
    return 0;
  if (v19 >= 0.0 && v20 >= 0.0)
    return 0;
  v21 = v15 * v18 + v14 * v17 + v20 * (v13 * v18 + v12 * v17 - (v15 * v18 + v14 * v17)) / (v20 - v19);
  if (v21 < 0.00011920929 || v21 + 0.00011920929 > v16)
    return 0;
  *a9 = a1 + v21 * v17;
  *a10 = a2 + v21 * v18;
  return 1;
}

float PKCLineSeg::clipAgainst(PKCLineSeg *this, const PKCLineSeg *a2)
{
  float result;
  float v4;
  double v5;
  double v6;

  v5 = 0.0;
  v6 = 0.0;
  if (lineIntersection(*(float *)this, *((float *)this + 1), *((float *)this + 2), *((float *)this + 3), *(float *)a2, *((float *)a2 + 1), *((float *)a2 + 2), *((float *)a2 + 3), &v6, &v5))
  {
    result = v6;
    v4 = v5;
    *((float *)this + 2) = result;
    *((float *)this + 3) = v4;
  }
  return result;
}

uint64_t PKCLineSeg::split(PKCLineSeg *this, PKCLineSeg *a2, PKCLineSeg **a3, PKCLineSeg **a4)
{
  uint64_t v8;
  uint64_t v9;
  float v10;
  float v11;
  uint64_t v12;
  double v14;
  double v15;

  v14 = 0.0;
  v15 = 0.0;
  v8 = lineIntersection(*(float *)this, *((float *)this + 1), *((float *)this + 2), *((float *)this + 3), *(float *)a2, *((float *)a2 + 1), *((float *)a2 + 2), *((float *)a2 + 3), &v15, &v14);
  if ((v8 & 1) != 0)
  {
    v9 = operator new();
    v10 = v15;
    v11 = v14;
    *(float *)v9 = v10;
    *(float *)(v9 + 4) = v11;
    *(_QWORD *)(v9 + 8) = *((_QWORD *)this + 1);
    *a3 = (PKCLineSeg *)v9;
    v12 = operator new();
    *(float *)v12 = v10;
    *(float *)(v12 + 4) = v11;
    *(_QWORD *)(v12 + 8) = *((_QWORD *)a2 + 1);
    *((float *)this + 2) = v10;
    *((float *)this + 3) = v11;
    *((float *)a2 + 2) = v10;
    *((float *)a2 + 3) = v11;
  }
  else
  {
    v12 = 0;
    *a3 = 0;
  }
  *a4 = (PKCLineSeg *)v12;
  return v8;
}

b2ChainAndCircleContact *b2ChainAndCircleContact::Create(b2Fixture *this, b2Fixture *a2, b2Fixture *a3, b2Fixture *a4)
{
  int v4;
  int v6;
  b2ChainAndCircleContact *v8;

  v4 = (int)a4;
  v6 = (int)a2;
  v8 = (b2ChainAndCircleContact *)operator new();
  b2ChainAndCircleContact::b2ChainAndCircleContact(v8, this, v6, a3, v4);
  return v8;
}

void sub_208FBDB00(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BD0BA58](v1, 0x10A1C40CDD50D3ELL);
  _Unwind_Resume(a1);
}

uint64_t b2ChainAndCircleContact::Destroy(uint64_t result)
{
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 16))(result);
  return result;
}

void b2ChainAndCircleContact::b2ChainAndCircleContact(b2ChainAndCircleContact *this, b2Fixture *a2, int a3, b2Fixture *a4, int a5)
{
  _QWORD *v5;

  b2Contact::b2Contact(this, a2, a3, a4, a5);
  *v5 = &off_24C0E8720;
  if (*(_DWORD *)(*(_QWORD *)(v5[10] + 32) + 8) != 3)
    b2ChainAndCircleContact::b2ChainAndCircleContact();
  if (*(_DWORD *)(*(_QWORD *)(v5[11] + 32) + 8))
    b2ChainAndCircleContact::b2ChainAndCircleContact();
}

uint64_t b2ChainAndCircleContact::Evaluate(uint64_t a1, uint64_t a2, float *a3, float *a4)
{
  uint64_t v8;
  _QWORD v10[6];
  __int16 v11;

  v8 = *(_QWORD *)(*(_QWORD *)(a1 + 80) + 32);
  v10[0] = &off_24C0E7CC8;
  v10[1] = 0x3C1374BC00000001;
  v10[4] = 0;
  v10[5] = 0;
  v11 = 0;
  b2ChainShape::GetChildEdge(v8, (b2EdgeShape *)v10, *(_DWORD *)(a1 + 96));
  return b2CollideEdgeAndCircle(a2, (uint64_t)v10, a3, *(float **)(*(_QWORD *)(a1 + 88) + 32), a4);
}

void b2ChainAndCircleContact::~b2ChainAndCircleContact(b2ChainAndCircleContact *this)
{
  JUMPOUT(0x20BD0BA58);
}

b2ChainAndPolygonContact *b2ChainAndPolygonContact::Create(b2Fixture *this, b2Fixture *a2, b2Fixture *a3, b2Fixture *a4)
{
  int v4;
  int v6;
  b2ChainAndPolygonContact *v8;

  v4 = (int)a4;
  v6 = (int)a2;
  v8 = (b2ChainAndPolygonContact *)operator new();
  b2ChainAndPolygonContact::b2ChainAndPolygonContact(v8, this, v6, a3, v4);
  return v8;
}

void sub_208FBDC98(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BD0BA58](v1, 0x10A1C40CDD50D3ELL);
  _Unwind_Resume(a1);
}

void b2ChainAndPolygonContact::b2ChainAndPolygonContact(b2ChainAndPolygonContact *this, b2Fixture *a2, int a3, b2Fixture *a4, int a5)
{
  _QWORD *v5;

  b2Contact::b2Contact(this, a2, a3, a4, a5);
  *v5 = &off_24C0E8770;
  if (*(_DWORD *)(*(_QWORD *)(v5[10] + 32) + 8) != 3)
    b2ChainAndPolygonContact::b2ChainAndPolygonContact();
  if (*(_DWORD *)(*(_QWORD *)(v5[11] + 32) + 8) != 2)
    b2ChainAndPolygonContact::b2ChainAndPolygonContact();
}

void b2ChainAndPolygonContact::Evaluate(uint64_t a1, float32x2_t *a2, float *a3, float *a4)
{
  uint64_t v8;
  float32x2_t v9[6];
  __int16 v10;

  v8 = *(_QWORD *)(*(_QWORD *)(a1 + 80) + 32);
  v9[0] = (float32x2_t)&off_24C0E7CC8;
  v9[1] = (float32x2_t)0x3C1374BC00000001;
  v9[4] = 0;
  v9[5] = 0;
  v10 = 0;
  b2ChainShape::GetChildEdge(v8, (b2EdgeShape *)v9, *(_DWORD *)(a1 + 96));
  b2CollideEdgeAndPolygon(a2, v9, a3, *(_QWORD *)(*(_QWORD *)(a1 + 88) + 32), a4);
}

void b2ChainAndPolygonContact::~b2ChainAndPolygonContact(b2ChainAndPolygonContact *this)
{
  JUMPOUT(0x20BD0BA58);
}

b2CircleContact *b2CircleContact::Create(b2Fixture *this, b2Fixture *a2, b2Fixture *a3, b2Fixture *a4)
{
  b2CircleContact *v6;

  v6 = (b2CircleContact *)operator new();
  b2CircleContact::b2CircleContact(v6, this, a3);
  return v6;
}

void sub_208FBDE08(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BD0BA58](v1, 0x10A1C40CDD50D3ELL);
  _Unwind_Resume(a1);
}

void b2CircleContact::b2CircleContact(b2CircleContact *this, b2Fixture *a2, b2Fixture *a3)
{
  _QWORD *v3;

  b2Contact::b2Contact(this, a2, 0, a3, 0);
  *v3 = &off_24C0E8218;
  if (*(_DWORD *)(*(_QWORD *)(v3[10] + 32) + 8))
    b2CircleContact::b2CircleContact();
  if (*(_DWORD *)(*(_QWORD *)(v3[11] + 32) + 8))
    b2CircleContact::b2CircleContact();
}

uint64_t b2CircleContact::Evaluate(uint64_t a1, uint64_t a2, float *a3, float *a4)
{
  return b2CollideCircles(a2, *(float **)(*(_QWORD *)(a1 + 80) + 32), a3, *(float **)(*(_QWORD *)(a1 + 88) + 32), a4);
}

void b2CircleContact::~b2CircleContact(b2CircleContact *this)
{
  JUMPOUT(0x20BD0BA58);
}

void b2Contact::InitializeRegisters(b2Contact *this)
{
  b2Contact::s_registers = (uint64_t)b2CircleContact::Create;
  byte_254592320 = 1;
  qword_2545923B8 = (uint64_t)b2PolygonAndCircleContact::Create;
  byte_2545923C0 = 1;
  qword_254592338 = (uint64_t)b2PolygonAndCircleContact::Create;
  byte_254592340 = 0;
  qword_2545923D8 = (uint64_t)b2PolygonContact::Create;
  byte_2545923E0 = 1;
  qword_254592368 = (uint64_t)b2EdgeAndCircleContact::Create;
  byte_254592370 = 1;
  qword_254592328 = (uint64_t)b2EdgeAndCircleContact::Create;
  byte_254592330 = 0;
  qword_254592388 = (uint64_t)b2EdgeAndPolygonContact::Create;
  byte_254592390 = 1;
  qword_2545923C8 = (uint64_t)b2EdgeAndPolygonContact::Create;
  byte_2545923D0 = 0;
  qword_254592408 = (uint64_t)b2ChainAndCircleContact::Create;
  byte_254592410 = 1;
  qword_254592348 = (uint64_t)b2ChainAndCircleContact::Create;
  byte_254592350 = 0;
  qword_254592428 = (uint64_t)b2ChainAndPolygonContact::Create;
  byte_254592430 = 1;
  qword_2545923E8 = (uint64_t)b2ChainAndPolygonContact::Create;
  byte_2545923F0 = 0;
  qword_254592488 = (uint64_t)b2QuadtreeAndChainContact::Create;
  byte_254592490 = 1;
  qword_254592448 = (uint64_t)b2QuadtreeAndChainContact::Create;
  byte_254592450 = 0;
  qword_254592358 = (uint64_t)b2QuadtreeAndCircleContact::Create;
  byte_254592360 = 1;
  qword_254592458 = (uint64_t)b2QuadtreeAndCircleContact::Create;
  byte_254592460 = 0;
  qword_254592468 = (uint64_t)b2QuadtreeAndEdgeContact::Create;
  byte_254592470 = 1;
  qword_2545923A8 = (uint64_t)b2QuadtreeAndEdgeContact::Create;
  byte_2545923B0 = 0;
  qword_254592478 = (uint64_t)b2QuadtreeAndPolygonContact::Create;
  byte_254592480 = 1;
  qword_2545923F8 = (uint64_t)b2QuadtreeAndPolygonContact::Create;
  byte_254592400 = 0;
  qword_254592498 = (uint64_t)b2QuadtreeAndQuadtreeContact::Create;
  byte_2545924A0 = 1;
}

uint64_t b2Contact::AddType(uint64_t result, unsigned int a2, unsigned int a3)
{
  uint64_t *v3;
  uint64_t *v4;

  if (a2 >= 5)
    b2Contact::AddType();
  if (a3 >= 5)
    b2Contact::AddType();
  v3 = &b2Contact::s_registers[10 * a2 + 2 * a3];
  *v3 = result;
  *((_BYTE *)v3 + 8) = 1;
  if (a2 != a3)
  {
    v4 = &b2Contact::s_registers[10 * a3 + 2 * a2];
    *v4 = result;
    *((_BYTE *)v4 + 8) = 0;
  }
  return result;
}

uint64_t b2Contact::Create(b2Contact *this, b2Fixture *a2, b2Contact *a3, b2Fixture *a4)
{
  unsigned int v8;
  uint64_t v9;
  uint64_t (*v10)(b2Contact *, b2Fixture *, b2Contact *, b2Fixture *);
  b2Contact *v11;
  b2Fixture *v12;
  b2Contact *v13;
  b2Fixture *v14;
  uint64_t result;

  if (!b2Contact::s_initialized)
  {
    b2Contact::InitializeRegisters(this);
    b2Contact::s_initialized = 1;
  }
  v8 = *(_DWORD *)(*((_QWORD *)this + 4) + 8);
  if (v8 >= 5)
    b2Contact::Create();
  v9 = *(unsigned int *)(*((_QWORD *)a3 + 4) + 8);
  if (v9 >= 5)
    b2Contact::Create();
  v10 = (uint64_t (*)(b2Contact *, b2Fixture *, b2Contact *, b2Fixture *))b2Contact::s_registers[10 * v8 + 2 * v9];
  if (!v10)
    return 0;
  if (LOBYTE(b2Contact::s_registers[10 * v8 + 1 + 2 * v9]))
  {
    v11 = this;
    v12 = a2;
    v13 = a3;
    v14 = a4;
  }
  else
  {
    v11 = a3;
    v12 = a4;
    v13 = this;
    v14 = a2;
  }
  result = v10(v11, v12, v13, v14);
  if (result)
    *(_WORD *)(result + 8) = 0;
  return result;
}

uint64_t b2Contact::Destroy(b2Contact *this, b2Contact *a2)
{
  if (!b2Contact::s_initialized)
    b2Contact::Destroy();
  if (*((int *)this + 41) >= 1)
  {
    b2Body::SetAwake(*(b2Body **)(*((_QWORD *)this + 10) + 24), 1);
    b2Body::SetAwake(*(b2Body **)(*((_QWORD *)this + 11) + 24), 1);
  }
  return (*(uint64_t (**)(b2Contact *))(*(_QWORD *)this + 16))(this);
}

void b2Contact::b2Contact(b2Contact *this, b2Fixture *a2, int a3, b2Fixture *a4, int a5)
{
  float v5;
  float v6;

  *((_DWORD *)this + 41) = 0;
  *((_DWORD *)this + 42) = 0;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  v5 = *((float *)a2 + 11);
  v6 = *((float *)a2 + 10) * *((float *)a4 + 10);
  if (v5 <= *((float *)a4 + 11))
    v5 = *((float *)a4 + 11);
  *(_QWORD *)this = &unk_24C0E89C0;
  *((_DWORD *)this + 3) = 4;
  *((_QWORD *)this + 10) = a2;
  *((_QWORD *)this + 11) = a4;
  *((_DWORD *)this + 24) = a3;
  *((_DWORD *)this + 25) = a5;
  *((float *)this + 44) = sqrtf(v6);
  *((float *)this + 45) = v5;
}

b2Body *b2Contact::Update(b2Contact *this, b2ContactListener *a2)
{
  char *v4;
  __int128 v5;
  __int128 v6;
  int v7;
  unsigned int v8;
  b2Body *v9;
  b2Body *v10;
  b2Body *result;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  char *v16;
  uint64_t v17;
  _DWORD *v18;
  uint64_t v19;
  __int128 v20;
  _OWORD v21[2];
  __int128 v22;

  v4 = (char *)this + 104;
  v5 = *(_OWORD *)((char *)this + 120);
  v20 = *(_OWORD *)((char *)this + 104);
  v21[0] = v5;
  v6 = *(_OWORD *)((char *)this + 152);
  v21[1] = *(_OWORD *)((char *)this + 136);
  v22 = v6;
  v7 = *((_DWORD *)this + 3);
  *((_DWORD *)this + 3) = v7 | 4;
  v8 = v7 & 2;
  v9 = *(b2Body **)(*((_QWORD *)this + 10) + 24);
  v10 = *(b2Body **)(*((_QWORD *)this + 11) + 24);
  result = (b2Body *)(**(uint64_t (***)(b2Contact *, char *, uint64_t, uint64_t))this)(this, (char *)this + 104, (uint64_t)&v9->var8, (uint64_t)&v10->var8);
  v12 = *((unsigned int *)this + 41);
  if ((int)v12 >= 1)
  {
    v13 = 0;
    v14 = HIDWORD(v22);
    do
    {
      v15 = &v4[20 * v13];
      *((_DWORD *)v15 + 2) = 0;
      *((_DWORD *)v15 + 3) = 0;
      v16 = v15 + 8;
      if ((int)v14 >= 1)
      {
        v17 = v14;
        v18 = v21;
        while (*v18 != *((_DWORD *)v16 + 2))
        {
          v18 += 5;
          if (!--v17)
            goto LABEL_9;
        }
        *(_QWORD *)v16 = *((_QWORD *)v18 - 1);
      }
LABEL_9:
      ++v13;
    }
    while (v13 != v12);
  }
  if ((int)v12 > 0 != v8 >> 1)
  {
    b2Body::SetAwake(v9, 1);
    result = b2Body::SetAwake(v10, 1);
  }
  *((_DWORD *)this + 3) = *((_DWORD *)this + 3) & 0xFFFFFFFD | (2 * ((int)v12 > 0));
  if ((v10->var2 & v9->var4) != 0 || (v9->var2 & v10->var4) != 0)
  {
    if (!v8 && a2 && (int)v12 >= 1)
    {
      *((_BYTE *)this + 8) = 1;
      v19 = 2;
      return (b2Body *)(*(uint64_t (**)(b2ContactListener *, b2Contact *))(*(_QWORD *)a2 + 8 * v19))(a2, this);
    }
    if (v8 && a2 && (int)v12 <= 0)
    {
      *((_BYTE *)this + 9) = 1;
      v19 = 4;
      return (b2Body *)(*(uint64_t (**)(b2ContactListener *, b2Contact *))(*(_QWORD *)a2 + 8 * v19))(a2, this);
    }
  }
  return result;
}

uint64_t b2ContactSolver::b2ContactSolver(uint64_t a1, __int128 *a2, uint64_t a3, uint64_t a4)
{
  __int128 v6;
  b2StackAllocator *v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  float32x2_t *v12;
  uint64_t v13;
  uint64_t v14;
  float32x2_t v15;
  float32x2_t v16;
  float32x2_t *v17;
  __int32 v18;
  float32x2_t *v19;
  __int32 v20;
  uint64_t v21;
  float32x2_t v22;
  uint64_t v23;
  int v24;
  int v25;
  __int128 v26;
  uint64_t v27;
  float32x2_t *v28;
  __int32 v29;
  uint64_t v30;
  _QWORD *v31;
  float32x2_t *v32;
  uint64_t v33;
  float32x2_t v34;
  float32x2_t *v35;

  *(_QWORD *)(a1 + 24) = a3;
  *(_QWORD *)(a1 + 32) = a4;
  v6 = *a2;
  *(_QWORD *)(a1 + 16) = *((_QWORD *)a2 + 2);
  *(_OWORD *)a1 = v6;
  v7 = (b2StackAllocator *)*((_QWORD *)a2 + 6);
  *(_QWORD *)(a1 + 56) = v7;
  v8 = *((_DWORD *)a2 + 6);
  *(_DWORD *)(a1 + 80) = v8;
  *(_QWORD *)(a1 + 64) = b2StackAllocator::Allocate(v7, 88 * v8);
  *(_QWORD *)(a1 + 72) = b2StackAllocator::Allocate(*(b2StackAllocator **)(a1 + 56), 152 * *(_DWORD *)(a1 + 80));
  *(_OWORD *)(a1 + 40) = a2[2];
  *(_DWORD *)(a1 + 84) = *((_DWORD *)a2 + 14);
  if (*(int *)(a1 + 80) >= 1)
  {
    v9 = 0;
    v10 = 0;
    v11 = 0;
    do
    {
      v12 = *(float32x2_t **)(**(_QWORD **)(a1 + 32) + 8 * v11);
      v13 = v12[20].u32[1];
      if ((int)v13 <= 0)
        b2ContactSolver::b2ContactSolver();
      v14 = 0;
      v16 = v12[10];
      v15 = v12[11];
      v17 = *(float32x2_t **)(*(_QWORD *)&v15 + 24);
      v18 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)&v15 + 32) + 12);
      v19 = *(float32x2_t **)(*(_QWORD *)&v16 + 24);
      v20 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)&v16 + 32) + 12);
      v21 = *(_QWORD *)(a1 + 72);
      v22 = v12[22];
      v23 = v21 + 152 * v11;
      v24 = v17[3].i32[1];
      *(_DWORD *)(v23 + 112) = v19[3].i32[1];
      *(_DWORD *)(v23 + 116) = v24;
      v25 = v17[26].i32[1];
      *(_DWORD *)(v23 + 120) = v19[26].i32[1];
      *(_DWORD *)(v23 + 124) = v25;
      LODWORD(v26) = v19[28].i32[0];
      DWORD1(v26) = v17[28].i32[0];
      *((float32x2_t *)&v26 + 1) = v22;
      *(_OWORD *)(v23 + 128) = v26;
      *(_DWORD *)(v23 + 144) = v13;
      *(_DWORD *)(v23 + 148) = v11;
      *(_OWORD *)(v23 + 80) = 0uLL;
      *(_OWORD *)(v23 + 96) = 0uLL;
      v27 = *(_QWORD *)(a1 + 64);
      v28 = (float32x2_t *)(v27 + 88 * v11);
      v29 = v17[3].i32[1];
      v28[4].i32[0] = v19[3].i32[1];
      v28[4].i32[1] = v29;
      LODWORD(v26) = v17[26].i32[1];
      v28[5].i32[0] = v19[26].i32[1];
      v28[5].i32[1] = v26;
      v28[6] = v19[8];
      v28[7] = v17[8];
      LODWORD(v26) = v17[28].i32[0];
      v28[8].i32[0] = v19[28].i32[0];
      v28[8].i32[1] = v26;
      v28[2] = v12[18];
      v28[3] = v12[19];
      v28[10].i32[1] = v13;
      v28[9].i32[1] = v20;
      v28[10].i32[0] = v18;
      v28[9].i32[0] = v12[20].i32[0];
      v30 = v21 + v10;
      v31 = (_QWORD *)(v27 + v9);
      v32 = v12 + 14;
      v33 = 36 * v13;
      do
      {
        if (*(_BYTE *)(a1 + 20))
          v34 = vmul_n_f32(*v32, *(float *)(a1 + 8));
        else
          v34 = 0;
        v35 = (float32x2_t *)(v30 + v14);
        v35[2] = v34;
        v35[3] = 0;
        v35[4].i32[0] = 0;
        *v35 = 0;
        v35[1] = 0;
        *v31++ = v32[-1];
        v14 += 36;
        v32 = (float32x2_t *)((char *)v32 + 20);
      }
      while (v33 != v14);
      ++v11;
      v10 += 152;
      v9 += 88;
    }
    while (v11 < *(int *)(a1 + 80));
  }
  return a1;
}

void b2ContactSolver::~b2ContactSolver(b2ContactSolver *this)
{
  b2StackAllocator::Free(*((void ***)this + 7), *((void **)this + 9));
  b2StackAllocator::Free(*((void ***)this + 7), *((void **)this + 8));
}

void b2ContactSolver::InitializeVelocityConstraints(b2ContactSolver *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  float *v16;
  float v17;
  float v18;
  float *v19;
  float v20;
  float *v21;
  float v22;
  float v23;
  float *v24;
  float v25;
  float v26;
  float v27;
  uint64_t v28;
  uint64_t v29;
  __float2 v30;
  int32x2_t v31;
  int32x2_t *v32;
  int32x2_t *v33;
  int v34;
  uint64_t v35;
  float *v36;
  float *v37;
  float32x2_t v38;
  float *v39;
  float *v40;
  uint64_t v41;
  float v42;
  float v43;
  float v44;
  float v45;
  float32x2_t v46;
  float32x2_t v47;
  float32x2_t v48;
  float32x2_t v49;
  float32x2_t v50;
  float v51;
  float v52;
  float v53;
  float v54;
  float v55;
  float v56;
  float v57;
  float v58;
  uint64_t v59;
  float v60;
  float32x2_t v61;
  float v62;
  float v63;
  float v64;
  float v65;
  float v66;
  float v67;
  float v68;
  float v69;
  float v70;
  float v71;
  float v72;
  float v73;
  float v74;
  int32x2_t v75;
  int v76;
  float v77[2];
  __float2 v78;
  float v79[2];
  __float2 v80;

  if (*((int *)this + 20) >= 1)
  {
    v2 = 0;
    v3 = 32;
    __asm { FMOV            V19.2S, #1.0 }
    v61 = _D19;
    do
    {
      v9 = *((_QWORD *)this + 9);
      v10 = v9 + 152 * v2;
      v11 = *(_QWORD *)(**((_QWORD **)this + 4) + 8 * *(int *)(v10 + 148));
      if (*(int *)(v11 + 164) <= 0)
        b2ContactSolver::InitializeVelocityConstraints();
      v12 = *(int *)(v10 + 112);
      v13 = *(int *)(v10 + 116);
      v62 = *(float *)(v10 + 124);
      v63 = *(float *)(v10 + 120);
      v74 = *(float *)(v10 + 128);
      v73 = *(float *)(v10 + 132);
      v14 = *((_QWORD *)this + 5);
      v15 = *((_QWORD *)this + 6);
      v16 = (float *)(v14 + 16 * v12);
      v18 = *v16;
      v17 = v16[1];
      v19 = (float *)(v15 + 16 * v12);
      v64 = v19[1];
      v65 = *v19;
      v20 = v19[3];
      v21 = (float *)(v14 + 16 * v13);
      v23 = *v21;
      v22 = v21[1];
      v24 = (float *)(v15 + 16 * v13);
      v25 = *v24;
      v26 = v24[1];
      v27 = v24[3];
      v28 = v11 + 104;
      v29 = *((_QWORD *)this + 8) + 88 * v2;
      v69 = *(float *)(v29 + 56);
      v70 = *(float *)(v29 + 60);
      v68 = *(float *)(v29 + 52);
      v66 = v21[3];
      v67 = *(float *)(v29 + 48);
      v71 = *(float *)(v29 + 76);
      v72 = *(float *)(v29 + 80);
      v30 = __sincosf_stret(v16[3]);
      v80 = v30;
      v78 = __sincosf_stret(v66);
      v79[0] = v18 - (float)((float)(v30.__cosval * v67) - (float)(v30.__sinval * v68));
      v79[1] = v17 - (float)((float)(v30.__cosval * v68) + (float)(v30.__sinval * v67));
      v77[0] = v23 - (float)((float)(v78.__cosval * v69) - (float)(v78.__sinval * v70));
      v77[1] = v22 - (float)((float)(v78.__cosval * v70) + (float)(v78.__sinval * v69));
      b2WorldManifold::Initialize((uint64_t)&v75, v28, v79, v77, v71, v72);
      v32 = (int32x2_t *)(v9 + 152 * v2);
      v32[9] = v75;
      v33 = v32 + 9;
      v34 = v33[9].i32[0];
      if (v34 >= 1)
      {
        v35 = v9 + 152 * v2;
        v36 = (float *)(v35 + 76);
        *(float *)v31.i32 = v63 + v62;
        v37 = (float *)(v35 + 140);
        v38 = (float32x2_t)vdup_lane_s32(v31, 0);
        v39 = (float *)(v9 + v3);
        v40 = (float *)&v76;
        v41 = v33[9].u32[0];
        do
        {
          v42 = *(v40 - 1) - v18;
          v43 = *v40 - v17;
          *(v39 - 8) = v42;
          *(v39 - 7) = v43;
          v44 = *(v40 - 1) - v23;
          v45 = *v40 - v22;
          *(v39 - 6) = v44;
          *(v39 - 5) = v45;
          v46 = (float32x2_t)*v33;
          v47.i32[0] = vdup_lane_s32(*v33, 1).u32[0];
          v47.f32[1] = -COERCE_FLOAT(*v33);
          v48 = vmla_n_f32(vmul_n_f32((float32x2_t)*v33, -v43), v47, v42);
          v49 = vmla_n_f32(vmul_n_f32((float32x2_t)*v33, -v45), v47, v44);
          v50 = vmla_f32(vmla_f32(v38, v48, vmul_n_f32(v48, v74)), v49, vmul_n_f32(v49, v73));
          *((int8x8_t *)v39 - 1) = vand_s8((int8x8_t)vdiv_f32(v61, v50), (int8x8_t)vcgtz_f32(v50));
          *v39 = 0.0;
          v51 = vmlas_n_f32(vmuls_lane_f32((float)((float)(v26 + (float)(v27 * v44)) - v64) - (float)(v20 * v42), v46, 1), (float)(v20 * v43) + (float)((float)(v25 - (float)(v27 * v45)) - v65), v46.f32[0]);
          if (v51 < (float)-*((float *)this + 21))
            *v39 = -(float)(*v37 * v51);
          v40 += 2;
          v39 += 9;
          --v41;
        }
        while (v41);
        if (v34 == 2)
        {
          v52 = (float)(*(float *)v10 * *v36) - (float)(*(float *)(v10 + 4) * v46.f32[0]);
          v53 = (float)(*(float *)(v10 + 8) * *v36) - (float)(*(float *)(v10 + 12) * v46.f32[0]);
          v54 = (float)(*(float *)(v10 + 36) * *v36) - (float)(*(float *)(v10 + 40) * v46.f32[0]);
          v55 = (float)(*(float *)(v10 + 44) * *v36) - (float)(*(float *)(v10 + 48) * v46.f32[0]);
          v56 = (float)(*(float *)v31.i32 + (float)((float)(v74 * v52) * v52)) + (float)((float)(v73 * v53) * v53);
          v57 = (float)(*(float *)v31.i32 + (float)((float)(v74 * v54) * v54)) + (float)((float)(v73 * v55) * v55);
          *(float *)v31.i32 = (float)(*(float *)v31.i32 + (float)((float)(v74 * v52) * v54))
                            + (float)((float)(v73 * v53) * v55);
          v58 = (float)(v56 * v57) - (float)(*(float *)v31.i32 * *(float *)v31.i32);
          if ((float)(v56 * v56) >= (float)(v58 * 1000.0))
          {
            v33[9].i32[0] = 1;
          }
          else
          {
            v59 = v9 + 152 * v2;
            *(float *)(v59 + 96) = v56;
            *(int32x2_t *)(v59 + 100) = vdup_lane_s32(v31, 0);
            *(float *)(v59 + 108) = v57;
            if (v58 != 0.0)
              v58 = 1.0 / v58;
            v60 = -(float)(v58 * *(float *)v31.i32);
            *(float *)(v59 + 80) = v57 * v58;
            *(float *)(v59 + 84) = v60;
            *(float *)(v59 + 88) = v60;
            *(float *)(v59 + 92) = v56 * v58;
          }
        }
      }
      ++v2;
      v3 += 152;
    }
    while (v2 < *((int *)this + 20));
  }
}

uint64_t b2ContactSolver::WarmStart(uint64_t this)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  int v11;
  int v12;
  float32x2_t *v13;
  uint64_t v14;
  uint64_t v15;
  float32x2_t *v16;
  float32x2_t v17;
  float v18;
  float32x2_t *v19;
  float v20;
  float32x2_t v21;
  float v22;
  float32x2_t v23;
  uint64_t v24;
  const float *v25;
  const float *v26;
  float32x2_t v27;
  float32x2_t v28;
  uint64_t v29;
  float32x2_t v33;
  uint64_t v40;

  if (*(int *)(this + 80) >= 1)
  {
    v1 = 0;
    v2 = 12;
    do
    {
      v3 = *(_QWORD *)(this + 72);
      v4 = v3 + 152 * v1;
      v6 = *(int *)(v4 + 112);
      v5 = *(int *)(v4 + 116);
      v7 = **(_QWORD **)(this + 24);
      v8 = *(_QWORD *)(v7 + 8 * v6);
      v9 = *(_QWORD *)(v7 + 8 * v5);
      v10 = *(_DWORD *)(v8 + 8);
      v11 = *(_DWORD *)(v9 + 8) & *(_DWORD *)(v8 + 12);
      v12 = v10 & *(_DWORD *)(v9 + 12);
      if (v11 | v12)
      {
        v13 = (float32x2_t *)(v3 + 152 * v1);
        v14 = v13[18].u32[0];
        v15 = *(_QWORD *)(this + 48);
        v16 = (float32x2_t *)(v15 + 16 * v6);
        v17 = *v16;
        v18 = v16[1].f32[1];
        v19 = (float32x2_t *)(v15 + 16 * v5);
        v20 = v19[1].f32[1];
        v21 = *v19;
        if ((int)v14 >= 1)
        {
          v22 = v13[16].f32[1];
          v23 = v13[9];
          v24 = v3 + 152 * v1;
          v25 = (const float *)(v24 + 124);
          v26 = (const float *)(v24 + 120);
          v27 = vld1_dup_f32(v25);
          v28 = vld1_dup_f32(v26);
          v29 = v3 + v2;
          do
          {
            _S18 = *(_DWORD *)(v29 - 12);
            _S20 = *(_DWORD *)(v29 - 4);
            _D21 = vmul_n_f32(v23, *(float *)(v29 + 4));
            v33 = (float32x2_t)vrev64_s32((int32x2_t)vmul_n_f32(v23, *(float *)(v29 + 8)));
            _D23.i32[0] = vadd_f32(_D21, v33).u32[0];
            _D23.i32[1] = vsub_f32(_D21, v33).i32[1];
            __asm { FMLA            S19, S18, V17.S[1] }
            v18 = v18 + (float)((float)-*(float *)(v24 + 128) * _S19);
            v17 = vsub_f32(v17, vmul_f32(v28, _D23));
            __asm { FMLA            S21, S20, V17.S[1] }
            v20 = v20 + (float)(v22 * _D21.f32[0]);
            v21 = vadd_f32(v21, vmul_f32(v27, _D23));
            v29 += 36;
            --v14;
          }
          while (v14);
        }
        if (v11)
        {
          *v16 = v17;
          v16[1].f32[1] = v18;
        }
        if (v12)
        {
          v40 = *(_QWORD *)(this + 48) + 16 * v5;
          *(float32x2_t *)v40 = v21;
          *(float *)(v40 + 12) = v20;
        }
      }
      ++v1;
      v2 += 152;
    }
    while (v1 < *(int *)(this + 80));
  }
  return this;
}

uint64_t b2ContactSolver::SolveVelocityConstraints(uint64_t this)
{
  uint64_t v1;
  uint64_t i;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  int v11;
  int v12;
  uint64_t v13;
  float v14;
  float v15;
  float v16;
  float v17;
  uint64_t v18;
  uint64_t v19;
  float *v20;
  float v21;
  float v22;
  float v23;
  float *v24;
  float v25;
  float v26;
  float v27;
  float v28;
  float v29;
  float v30;
  float v31;
  float v32;
  float *v33;
  uint64_t v34;
  float v35;
  float v36;
  float v37;
  float v38;
  float v39;
  float v40;
  float v41;
  float v42;
  float v43;
  float v44;
  float v45;
  float v46;
  float v47;
  float v48;
  float v49;
  float v50;
  float v51;
  float v52;
  float v53;
  float v54;
  float v55;
  float v56;
  float v57;
  float v58;
  float v59;
  float v60;
  float v61;
  float *v62;
  float v63;
  float v64;
  float v65;
  float v66;
  float v67;
  float v68;
  float v69;
  float v70;
  float v71;
  float v72;
  float v73;
  float v74;
  float v75;
  float v76;
  float v77;
  float v78;
  float v79;
  float v80;
  float v81;
  float v82;
  float v83;
  float v84;
  float v85;
  float v86;
  float v87;
  float v88;
  float *v89;
  float v90;
  float v91;
  float v92;
  float v93;
  float v94;
  float v95;

  if (*(int *)(this + 80) >= 1)
  {
    v1 = 0;
    for (i = 16; ; i += 152)
    {
      v3 = *(_QWORD *)(this + 72);
      v4 = v3 + 152 * v1;
      v6 = *(int *)(v4 + 112);
      v5 = *(int *)(v4 + 116);
      v7 = **(_QWORD **)(this + 24);
      v8 = *(_QWORD *)(v7 + 8 * v6);
      v9 = *(_QWORD *)(v7 + 8 * v5);
      v10 = *(_DWORD *)(v8 + 8);
      v11 = *(_DWORD *)(v9 + 8) & *(_DWORD *)(v8 + 12);
      v12 = v10 & *(_DWORD *)(v9 + 12);
      if (v11 | v12)
        break;
LABEL_36:
      if (++v1 >= *(int *)(this + 80))
        return this;
    }
    v13 = v3 + 152 * v1;
    v15 = *(float *)(v13 + 120);
    v14 = *(float *)(v13 + 124);
    v17 = *(float *)(v13 + 128);
    v16 = *(float *)(v13 + 132);
    v18 = *(unsigned int *)(v13 + 144);
    v19 = *(_QWORD *)(this + 48);
    v20 = (float *)(v19 + 16 * v6);
    v21 = *v20;
    v22 = v20[1];
    v23 = v20[3];
    v24 = (float *)(v19 + 16 * v5);
    v26 = *v24;
    v25 = v24[1];
    v27 = v24[3];
    v29 = *(float *)(v13 + 72);
    v28 = *(float *)(v13 + 76);
    if ((int)v18 >= 1)
    {
      v30 = -v29;
      v31 = *(float *)(v13 + 136);
      v32 = -v17;
      v33 = (float *)(v3 + i);
      v34 = v18;
      do
      {
        v36 = *(v33 - 2);
        v35 = *(v33 - 1);
        v38 = *(v33 - 4);
        v37 = *(v33 - 3);
        v39 = v33[1];
        v40 = v39
            - (float)(v33[3]
                    * (float)((float)((float)((float)((float)(v25 + (float)(v27 * v36)) - v22) - (float)(v23 * v38))
                                    * v30)
                            + (float)((float)((float)((float)(v26 - (float)(v27 * v35)) - v21) + (float)(v23 * v37))
                                    * v28)));
        if (v40 >= (float)(v31 * *v33))
          v40 = v31 * *v33;
        if (v40 < (float)-(float)(v31 * *v33))
          v40 = -(float)(v31 * *v33);
        v41 = v40 - v39;
        v33[1] = v40;
        v42 = v28 * (float)(v40 - v39);
        v43 = v41 * v30;
        if (v11)
        {
          v21 = v21 - (float)(v15 * v42);
          v22 = v22 - (float)(v15 * v43);
          v23 = v23 + (float)(v32 * (float)((float)(v38 * v43) - (float)(v37 * v42)));
        }
        if (v12)
        {
          v26 = v26 + (float)(v14 * v42);
          v25 = v25 + (float)(v14 * v43);
          v27 = v27 + (float)(v16 * (float)((float)(v36 * v43) - (float)(v35 * v42)));
        }
        v33 += 9;
        --v34;
      }
      while (v34);
      if ((_DWORD)v18 == 1)
      {
        v45 = *(float *)(v4 + 8);
        v44 = *(float *)(v4 + 12);
        v47 = *(float *)v4;
        v46 = *(float *)(v4 + 4);
        v48 = *(float *)(v4 + 16);
        v49 = fmaxf(v48- (float)(*(float *)(v4 + 24)* (float)((float)((float)(v28* (float)((float)((float)(v25 + (float)(v27 * v45)) - v22)- (float)(v23 * *(float *)v4)))+ (float)((float)((float)((float)(v26 - (float)(v27 * v44)) - v21)+ (float)(v23 * v46))* v29))- *(float *)(v4 + 32))), 0.0);
        *(float *)(v4 + 16) = v49;
        v50 = v29 * (float)(v49 - v48);
        v51 = v28 * (float)(v49 - v48);
        if (v11)
        {
          v21 = v21 - (float)(v15 * v50);
          v22 = v22 - (float)(v15 * v51);
          v23 = v23 + (float)(v32 * (float)((float)(v47 * v51) - (float)(v46 * v50)));
        }
        if (v12)
        {
          v26 = v26 + (float)(v14 * v50);
          v25 = v25 + (float)(v14 * v51);
          v27 = v27 + (float)(v16 * (float)((float)(v45 * v51) - (float)(v44 * v50)));
        }
        goto LABEL_32;
      }
    }
    v52 = *(float *)(v4 + 16);
    if (v52 < 0.0 || (v53 = *(float *)(v4 + 52), v53 < 0.0))
      b2ContactSolver::SolveVelocityConstraints();
    v54 = *(float *)(v4 + 8);
    v55 = *(float *)(v4 + 12);
    v56 = *(float *)v4;
    v57 = *(float *)(v4 + 4);
    v58 = *(float *)(v4 + 44);
    v59 = *(float *)(v4 + 48);
    v60 = *(float *)(v4 + 36);
    v61 = *(float *)(v4 + 40);
    v62 = (float *)(v3 + 152 * v1);
    v63 = v62[26];
    v64 = v62[25];
    v65 = (float)((float)((float)(v28
                                * (float)((float)((float)(v25 + (float)(v27 * v54)) - v22) - (float)(v23 * *(float *)v4)))
                        + (float)((float)((float)((float)(v26 - (float)(v27 * v55)) - v21) + (float)(v23 * v57)) * v29))
                - *(float *)(v4 + 32))
        - (float)((float)(v53 * v63) + (float)(v62[24] * v52));
    v66 = (float)((float)((float)(v28 * (float)((float)((float)(v25 + (float)(v27 * v58)) - v22) - (float)(v23 * v60)))
                        + (float)((float)((float)((float)(v26 - (float)(v27 * v59)) - v21) + (float)(v23 * v61)) * v29))
                - *(float *)(v4 + 68))
        - (float)((float)(v53 * v62[27]) + (float)(v64 * v52));
    v67 = (float)(v62[22] * v66) + (float)(v62[20] * v65);
    if (v67 > 0.0 || (v68 = (float)(v66 * v62[23]) + (float)(v62[21] * v65), v68 > 0.0))
    {
      v75 = -(float)(*(float *)(v4 + 24) * v65);
      if (v75 < 0.0 || (float)(v66 + (float)(v64 * v75)) < 0.0)
      {
        v82 = -(float)(*(float *)(v4 + 60) * v66);
        if (v82 >= 0.0 && (float)(v65 + (float)(v63 * v82)) >= 0.0)
        {
          v83 = 0.0 - v52;
          v84 = v82 - v53;
          v85 = v29 * v83;
          v86 = v28 * v83;
          v87 = v29 * v84;
          v88 = v28 * v84;
          v21 = v21 - (float)(v15 * (float)(v85 + v87));
          v22 = v22 - (float)(v15 * (float)(v86 + v88));
          v23 = v23
              - (float)(v17
                      * (float)((float)((float)(v56 * v86) - (float)(v57 * v85))
                              + (float)((float)(v60 * v88) - (float)(v61 * v87))));
          v26 = v26 + (float)(v14 * (float)(v85 + v87));
          v25 = v25 + (float)(v14 * (float)(v86 + v88));
          v27 = v27
              + (float)(v16
                      * (float)((float)((float)(v54 * v86) - (float)(v55 * v85))
                              + (float)((float)(v58 * v88) - (float)(v59 * v87))));
          *(_DWORD *)(v4 + 16) = 0;
          *(float *)(v4 + 52) = v82;
          goto LABEL_32;
        }
        if (v65 < 0.0 || v66 < 0.0)
          goto LABEL_32;
        v90 = 0.0 - v52;
        v91 = 0.0 - v53;
        v92 = v29 * v90;
        v93 = v28 * v90;
        v94 = v29 * v91;
        v95 = v28 * v91;
        v21 = v21 - (float)(v15 * (float)(v92 + v94));
        v22 = v22 - (float)(v15 * (float)(v93 + v95));
        v23 = v23
            - (float)(v17
                    * (float)((float)((float)(v56 * v93) - (float)(v57 * v92))
                            + (float)((float)(v60 * v95) - (float)(v61 * v94))));
        v26 = v26 + (float)(v14 * (float)(v92 + v94));
        v25 = v25 + (float)(v14 * (float)(v93 + v95));
        v27 = v27
            + (float)(v16
                    * (float)((float)((float)(v54 * v93) - (float)(v55 * v92))
                            + (float)((float)(v58 * v95) - (float)(v59 * v94))));
        *(_DWORD *)(v4 + 16) = 0;
      }
      else
      {
        v76 = v75 - v52;
        v77 = 0.0 - v53;
        v78 = v29 * v76;
        v79 = v28 * v76;
        v80 = v29 * v77;
        v81 = v28 * v77;
        v21 = v21 - (float)(v15 * (float)(v80 + v78));
        v22 = v22 - (float)(v15 * (float)(v81 + v79));
        v23 = v23
            - (float)(v17
                    * (float)((float)((float)(v60 * v81) - (float)(v61 * v80))
                            + (float)((float)(v56 * v79) - (float)(v57 * v78))));
        v26 = v26 + (float)(v14 * (float)(v80 + v78));
        v25 = v25 + (float)(v14 * (float)(v81 + v79));
        v27 = v27
            + (float)(v16
                    * (float)((float)((float)(v58 * v81) - (float)(v59 * v80))
                            + (float)((float)(v54 * v79) - (float)(v55 * v78))));
        *(float *)(v4 + 16) = v75;
      }
      *(_DWORD *)(v4 + 52) = 0;
    }
    else
    {
      v69 = (float)-v67 - v52;
      v70 = (float)-v68 - v53;
      v71 = v29 * v69;
      v72 = v28 * v69;
      v73 = v29 * v70;
      v74 = v28 * v70;
      v21 = v21 - (float)(v15 * (float)(v71 + v73));
      v22 = v22 - (float)(v15 * (float)(v72 + v74));
      v23 = v23
          - (float)(v17
                  * (float)((float)((float)(v56 * v72) - (float)(v57 * v71))
                          + (float)((float)(v60 * v74) - (float)(v61 * v73))));
      v26 = v26 + (float)(v14 * (float)(v71 + v73));
      v25 = v25 + (float)(v14 * (float)(v72 + v74));
      v27 = v27
          + (float)(v16
                  * (float)((float)((float)(v54 * v72) - (float)(v55 * v71))
                          + (float)((float)(v58 * v74) - (float)(v59 * v73))));
      *(float *)(v4 + 16) = -v67;
      *(float *)(v4 + 52) = -v68;
    }
LABEL_32:
    if (v11)
    {
      *v20 = v21;
      v20[1] = v22;
      v20[3] = v23;
    }
    if (v12)
    {
      v89 = (float *)(*(_QWORD *)(this + 48) + 16 * v5);
      *v89 = v26;
      v89[1] = v25;
      v89[3] = v27;
    }
    goto LABEL_36;
  }
  return this;
}

uint64_t b2ContactSolver::StoreImpulses(uint64_t this)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  uint64_t *v9;
  uint64_t v10;

  v1 = *(unsigned int *)(this + 80);
  if ((int)v1 >= 1)
  {
    v2 = 0;
    v3 = *(_QWORD *)(this + 72);
    v4 = **(_QWORD **)(this + 32);
    v5 = (uint64_t *)(v3 + 16);
    do
    {
      v6 = v3 + 152 * v2;
      v7 = *(unsigned int *)(v6 + 144);
      if ((int)v7 >= 1)
      {
        v8 = (_QWORD *)(*(_QWORD *)(v4 + 8 * *(int *)(v6 + 148)) + 112);
        v9 = v5;
        do
        {
          v10 = *v9;
          v9 = (uint64_t *)((char *)v9 + 36);
          *v8 = v10;
          v8 = (_QWORD *)((char *)v8 + 20);
          --v7;
        }
        while (v7);
      }
      ++v2;
      v5 += 19;
    }
    while (v2 != v1);
  }
  return this;
}

BOOL b2ContactSolver::SolvePositionConstraints(b2ContactSolver *this)
{
  uint64_t v2;
  float v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  uint64_t v8;
  float *v9;
  float v10;
  float v11;
  float v12;
  float *v13;
  float v14;
  float v15;
  int v16;
  float v17;
  __float2 v18;
  float v19;
  float v20;
  float v21;
  float v22;
  float v23;
  float v24;
  float v25;
  float v26;
  uint64_t *v27;
  uint64_t v28;
  float v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  float *v34;
  uint64_t v35;
  float *v36;
  float v38;
  float v39;
  float v40;
  float v41;
  float v42;
  float v43;
  float v44;
  float v45;
  float v46;
  float v47;
  float v48;
  float v49;
  float v50;
  float v51;
  float v52;
  float v53;
  __float2 v54;
  float v55[2];
  __float2 v56;

  if (*((int *)this + 20) < 1)
  {
    v3 = 0.0;
  }
  else
  {
    v2 = 0;
    v3 = 0.0;
    do
    {
      v4 = *((_QWORD *)this + 8) + 88 * v2;
      v6 = *(int *)(v4 + 32);
      v5 = *(int *)(v4 + 36);
      v7 = *(_DWORD *)(v4 + 84);
      v8 = *((_QWORD *)this + 5);
      v9 = (float *)(v8 + 16 * v6);
      v10 = *v9;
      v11 = v9[1];
      v12 = v9[3];
      v13 = (float *)(v8 + 16 * v5);
      v15 = *v13;
      v14 = v13[1];
      v46 = v13[3];
      if (v7 <= 0)
      {
        v27 = (uint64_t *)*((_QWORD *)this + 3);
      }
      else
      {
        v16 = 0;
        v43 = *(float *)(v4 + 52);
        v44 = *(float *)(v4 + 48);
        v41 = *(float *)(v4 + 60);
        v42 = *(float *)(v4 + 56);
        v45 = *(float *)(v4 + 68);
        v38 = *(float *)(v4 + 44);
        v39 = *(float *)(v4 + 40);
        v40 = *(float *)(v4 + 64);
        do
        {
          v17 = v12;
          v18 = __sincosf_stret(v12);
          v56 = v18;
          v54 = __sincosf_stret(v46);
          v55[0] = v10 - (float)((float)(v18.__cosval * v44) - (float)(v18.__sinval * v43));
          v55[1] = v11 - (float)((float)(v43 * v18.__cosval) + (float)(v18.__sinval * v44));
          v52 = v15 - (float)((float)(v54.__cosval * v42) - (float)(v54.__sinval * v41));
          v53 = v14 - (float)((float)(v41 * v54.__cosval) + (float)(v54.__sinval * v42));
          b2PositionSolverManifold::Initialize(&v47, v4, v55, &v52, v16, v53);
          v19 = v49 - v10;
          v20 = v50 - v11;
          v21 = v49 - v15;
          v22 = v50 - v14;
          if (v3 >= v51)
            v3 = v51;
          v23 = (float)((float)(v39 + v38)
                      + (float)((float)(v40 * (float)((float)(v19 * v48) - (float)(v20 * v47)))
                              * (float)((float)(v19 * v48) - (float)(v20 * v47))))
              + (float)((float)(v45 * (float)((float)(v21 * v48) - (float)(v22 * v47)))
                      * (float)((float)(v21 * v48) - (float)(v22 * v47)));
          v24 = 0.0;
          if (v23 > 0.0)
          {
            v25 = fminf((float)(v51 + 0.0045) * 0.2, 0.0);
            if (v25 < -0.2)
              v25 = -0.2;
            v24 = (float)-v25 / v23;
          }
          v26 = v47 * v24;
          v27 = (uint64_t *)*((_QWORD *)this + 3);
          v28 = *(_QWORD *)(*v27 + 8 * v6);
          v29 = v48 * v24;
          v30 = *(_QWORD *)(*v27 + 8 * v5);
          if ((*(_DWORD *)(v30 + 8) & *(_DWORD *)(v28 + 12)) != 0)
          {
            v10 = v10 - (float)(v39 * v26);
            v11 = v11 - (float)(v39 * v29);
            v12 = v17 + (float)((float)-v40 * (float)((float)(v26 * (float)-v20) + (float)(v19 * v29)));
          }
          else
          {
            v12 = v17;
          }
          if ((*(_DWORD *)(v28 + 8) & *(_DWORD *)(v30 + 12)) != 0)
          {
            v15 = v15 + (float)(v38 * v26);
            v14 = v14 + (float)(v38 * v29);
            v46 = v46 + (float)(v45 * (float)((float)(v26 * (float)-v22) + (float)(v21 * v29)));
          }
          ++v16;
        }
        while (v7 != v16);
      }
      v31 = *v27;
      v32 = *(_QWORD *)(*v27 + 8 * v6);
      v33 = *(_QWORD *)(v31 + 8 * v5);
      if ((*(_DWORD *)(v33 + 8) & *(_DWORD *)(v32 + 12)) != 0)
      {
        v34 = (float *)(*((_QWORD *)this + 5) + 16 * v6);
        *v34 = v10;
        v34[1] = v11;
        v34[3] = v12;
        v35 = **((_QWORD **)this + 3);
        v33 = *(_QWORD *)(v35 + 8 * v5);
        v32 = *(_QWORD *)(v35 + 8 * v6);
      }
      if ((*(_DWORD *)(v32 + 8) & *(_DWORD *)(v33 + 12)) != 0)
      {
        v36 = (float *)(*((_QWORD *)this + 5) + 16 * v5);
        *v36 = v15;
        v36[1] = v14;
        v36[3] = v46;
      }
      ++v2;
    }
    while (v2 < *((int *)this + 20));
  }
  return v3 >= -0.0135;
}

float b2PositionSolverManifold::Initialize(float *a1, uint64_t a2, float *a3, float *a4, int a5, float result)
{
  float v6;
  float v7;
  float v8;
  float v9;
  float v10;
  float v11;
  float v12;
  float v13;
  float v14;
  float v15;
  float v16;
  float v17;
  float v18;
  float v19;
  float v20;
  float v21;
  float v22;
  float v23;
  float v24;
  float v25;
  float v26;
  float v27;
  float v28;
  float v29;
  float v30;
  float v31;
  float v32;
  float v33;
  float v34;
  float v35;
  float *v36;
  float v37;
  float v38;
  float v39;
  float v40;
  float v41;
  float v42;
  float v43;
  float v44;
  float v45;
  float v46;
  float v47;
  float v48;
  float v49;
  float v50;
  float v51;
  float v52;
  float v53;
  float *v54;
  float v55;
  float v56;
  float v57;
  float v58;
  float v59;
  float v60;

  if (*(int *)(a2 + 84) <= 0)
    b2PositionSolverManifold::Initialize();
  switch(*(_DWORD *)(a2 + 72))
  {
    case 0:
    case 3:
      v7 = a3[2];
      v6 = a3[3];
      v8 = *(float *)(a2 + 24);
      v9 = *(float *)(a2 + 28);
      v10 = *a3 + (float)((float)(v6 * v8) - (float)(v7 * v9));
      v11 = (float)((float)(v6 * v9) + (float)(v7 * v8)) + a3[1];
      v13 = a4[2];
      v12 = a4[3];
      v14 = *(float *)(a2 + 4);
      v15 = *a4 + (float)((float)(v12 * *(float *)a2) - (float)(v13 * v14));
      v16 = (float)((float)(v12 * v14) + (float)(v13 * *(float *)a2)) + a4[1];
      v17 = v15 - v10;
      v18 = v16 - v11;
      *a1 = v15 - v10;
      a1[1] = v16 - v11;
      v19 = (float)(v18 * v18) + (float)(v17 * v17);
      v20 = sqrtf(v19);
      if (v20 >= 0.00000011921)
      {
        v21 = 1.0 / v20;
        v22 = v17 * (float)(1.0 / v20);
        v23 = v18 * v21;
        *a1 = v22;
        a1[1] = v23;
        v19 = (float)(v18 * v23) + (float)(v17 * v22);
      }
      a1[2] = (float)(v10 + v15) * 0.5;
      a1[3] = (float)(v11 + v16) * 0.5;
      result = (float)(v19 - *(float *)(a2 + 76)) - *(float *)(a2 + 80);
      a1[4] = result;
      break;
    case 1:
      v25 = a3[2];
      v24 = a3[3];
      v26 = *(float *)(a2 + 16);
      v27 = *(float *)(a2 + 20);
      v28 = (float)(v24 * v26) - (float)(v25 * v27);
      v29 = (float)(v24 * v27) + (float)(v25 * v26);
      *a1 = v28;
      a1[1] = v29;
      v31 = a3[2];
      v30 = a3[3];
      v32 = *(float *)(a2 + 24);
      v33 = *(float *)(a2 + 28);
      v34 = *a3 + (float)((float)(v30 * v32) - (float)(v31 * v33));
      v35 = (float)((float)(v30 * v33) + (float)(v31 * v32)) + a3[1];
      v36 = (float *)(a2 + 8 * a5);
      v38 = a4[2];
      v37 = a4[3];
      v39 = v36[1];
      v40 = *a4 + (float)((float)(v37 * *v36) - (float)(v38 * v39));
      v41 = (float)((float)(v37 * v39) + (float)(v38 * *v36)) + a4[1];
      result = (float)((float)((float)(v29 * (float)(v41 - v35)) + (float)((float)(v40 - v34) * v28))
                     - *(float *)(a2 + 76))
             - *(float *)(a2 + 80);
      a1[3] = v41;
      a1[4] = result;
      a1[2] = v40;
      break;
    case 2:
      v43 = a4[2];
      v42 = a4[3];
      v44 = *(float *)(a2 + 16);
      v45 = *(float *)(a2 + 20);
      v46 = (float)(v42 * v44) - (float)(v43 * v45);
      v47 = (float)(v42 * v45) + (float)(v43 * v44);
      *a1 = v46;
      a1[1] = v47;
      v49 = a4[2];
      v48 = a4[3];
      v50 = *(float *)(a2 + 24);
      v51 = *(float *)(a2 + 28);
      v52 = *a4 + (float)((float)(v48 * v50) - (float)(v49 * v51));
      v53 = (float)((float)(v48 * v51) + (float)(v49 * v50)) + a4[1];
      v54 = (float *)(a2 + 8 * a5);
      v56 = a3[2];
      v55 = a3[3];
      v57 = v54[1];
      v58 = *a3 + (float)((float)(v55 * *v54) - (float)(v56 * v57));
      v59 = (float)((float)(v55 * v57) + (float)(v56 * *v54)) + a3[1];
      v60 = (float)((float)((float)(v47 * (float)(v59 - v53)) + (float)((float)(v58 - v52) * v46)) - *(float *)(a2 + 76))
          - *(float *)(a2 + 80);
      a1[3] = v59;
      a1[4] = v60;
      result = -(float)((float)(v42 * v44) - (float)(v43 * v45));
      *a1 = result;
      a1[1] = -v47;
      a1[2] = v58;
      break;
    default:
      return result;
  }
  return result;
}

BOOL b2ContactSolver::SolveTOIPositionConstraints(b2ContactSolver *this, int a2, int a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  BOOL v9;
  uint64_t v10;
  uint64_t v11;
  BOOL v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  float *v17;
  float v18;
  float v19;
  float v20;
  float *v21;
  float v22;
  float v23;
  int v24;
  float v25;
  float v26;
  __float2 v27;
  float v28;
  float v29;
  float v30;
  float v31;
  float v32;
  float v33;
  float v34;
  float v35;
  float v36;
  uint64_t *v37;
  uint64_t v38;
  float v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  float *v44;
  uint64_t v45;
  float *v46;
  int v48;
  float v49;
  float v50;
  float v51;
  float v52;
  float v53;
  float v54;
  float v55;
  float v56;
  float v57;
  float v58;
  float v59;
  float v60;
  float v61;
  float v62;
  float v63;
  float v64;
  __float2 v65;
  float v66[2];
  __float2 v67;

  if (*((int *)this + 20) < 1)
  {
    v56 = 0.0;
  }
  else
  {
    v5 = 0;
    v56 = 0.0;
    v48 = a3;
    do
    {
      v6 = *((_QWORD *)this + 8);
      v7 = v6 + 88 * v5;
      v8 = *(_DWORD *)(v7 + 32);
      v9 = v8 == a2 || v8 == a3;
      v50 = 0.0;
      v54 = 0.0;
      if (v9)
      {
        v10 = v6 + 88 * v5;
        v50 = *(float *)(v10 + 40);
        v54 = *(float *)(v10 + 64);
      }
      v11 = *(int *)(v7 + 36);
      v49 = 0.0;
      v12 = (_DWORD)v11 == a2 || (_DWORD)v11 == a3;
      v55 = 0.0;
      if (v12)
      {
        v13 = v6 + 88 * v5;
        v49 = *(float *)(v13 + 44);
        v55 = *(float *)(v13 + 68);
      }
      v14 = v8;
      v15 = *(_DWORD *)(v7 + 84);
      v16 = *((_QWORD *)this + 5);
      v17 = (float *)(v16 + 16 * v14);
      v18 = *v17;
      v19 = v17[1];
      v20 = v17[3];
      v21 = (float *)(v16 + 16 * v11);
      v22 = *v21;
      v23 = v21[1];
      v57 = v21[3];
      if (v15 <= 0)
      {
        v37 = (uint64_t *)*((_QWORD *)this + 3);
      }
      else
      {
        v24 = 0;
        v52 = *(float *)(v7 + 52);
        v53 = *(float *)(v7 + 48);
        v25 = *(float *)(v7 + 60);
        v51 = *(float *)(v7 + 56);
        do
        {
          v26 = v20;
          v27 = __sincosf_stret(v20);
          v67 = v27;
          v65 = __sincosf_stret(v57);
          v66[0] = v18 - (float)((float)(v27.__cosval * v53) - (float)(v27.__sinval * v52));
          v66[1] = v19 - (float)((float)(v52 * v27.__cosval) + (float)(v27.__sinval * v53));
          v63 = v22 - (float)((float)(v65.__cosval * v51) - (float)(v65.__sinval * v25));
          v64 = v23 - (float)((float)(v25 * v65.__cosval) + (float)(v65.__sinval * v51));
          b2PositionSolverManifold::Initialize(&v58, v7, v66, &v63, v24, v64);
          v28 = v60 - v18;
          v29 = v61 - v19;
          v30 = v60 - v22;
          v31 = v61 - v23;
          v32 = v56;
          if (v56 >= v62)
            v32 = v62;
          v56 = v32;
          v33 = (float)((float)(v50 + v49)
                      + (float)((float)(v54 * (float)((float)(v28 * v59) - (float)(v29 * v58)))
                              * (float)((float)(v28 * v59) - (float)(v29 * v58))))
              + (float)((float)(v55 * (float)((float)(v30 * v59) - (float)(v31 * v58)))
                      * (float)((float)(v30 * v59) - (float)(v31 * v58)));
          v34 = 0.0;
          if (v33 > 0.0)
          {
            v35 = fminf((float)(v62 + 0.0045) * 0.75, 0.0);
            if (v35 < -0.2)
              v35 = -0.2;
            v34 = (float)-v35 / v33;
          }
          v36 = v58 * v34;
          v37 = (uint64_t *)*((_QWORD *)this + 3);
          v38 = *(_QWORD *)(*v37 + 8 * v14);
          v39 = v59 * v34;
          v40 = *(_QWORD *)(*v37 + 8 * v11);
          if ((*(_DWORD *)(v40 + 8) & *(_DWORD *)(v38 + 12)) != 0)
          {
            v18 = v18 - (float)(v50 * v36);
            v19 = v19 - (float)(v50 * v39);
            v20 = v26 + (float)((float)-v54 * (float)((float)(v36 * (float)-v29) + (float)(v28 * v39)));
          }
          else
          {
            v20 = v26;
          }
          if ((*(_DWORD *)(v38 + 8) & *(_DWORD *)(v40 + 12)) != 0)
          {
            v22 = v22 + (float)(v49 * v36);
            v23 = v23 + (float)(v49 * v39);
            v57 = v57 + (float)(v55 * (float)((float)(v36 * (float)-v31) + (float)(v30 * v39)));
          }
          ++v24;
        }
        while (v15 != v24);
      }
      v41 = *v37;
      v42 = *(_QWORD *)(*v37 + 8 * v14);
      v43 = *(_QWORD *)(v41 + 8 * v11);
      if ((*(_DWORD *)(v43 + 8) & *(_DWORD *)(v42 + 12)) != 0)
      {
        v44 = (float *)(*((_QWORD *)this + 5) + 16 * v14);
        *v44 = v18;
        v44[1] = v19;
        v44[3] = v20;
        v45 = **((_QWORD **)this + 3);
        v43 = *(_QWORD *)(v45 + 8 * v11);
        v42 = *(_QWORD *)(v45 + 8 * v14);
      }
      a3 = v48;
      if ((*(_DWORD *)(v42 + 8) & *(_DWORD *)(v43 + 12)) != 0)
      {
        v46 = (float *)(*((_QWORD *)this + 5) + 16 * v11);
        *v46 = v22;
        v46[1] = v23;
        v46[3] = v57;
      }
      ++v5;
    }
    while (v5 < *((int *)this + 20));
  }
  return v56 >= -0.00675;
}

b2EdgeAndCircleContact *b2EdgeAndCircleContact::Create(b2Fixture *this, b2Fixture *a2, b2Fixture *a3, b2Fixture *a4)
{
  b2EdgeAndCircleContact *v6;

  v6 = (b2EdgeAndCircleContact *)operator new();
  b2EdgeAndCircleContact::b2EdgeAndCircleContact(v6, this, a3);
  return v6;
}

void sub_208FBF9E8(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BD0BA58](v1, 0x10A1C40CDD50D3ELL);
  _Unwind_Resume(a1);
}

void b2EdgeAndCircleContact::b2EdgeAndCircleContact(b2EdgeAndCircleContact *this, b2Fixture *a2, b2Fixture *a3)
{
  _QWORD *v3;

  b2Contact::b2Contact(this, a2, 0, a3, 0);
  *v3 = &off_24C0E86F8;
  if (*(_DWORD *)(*(_QWORD *)(v3[10] + 32) + 8) != 1)
    b2EdgeAndCircleContact::b2EdgeAndCircleContact();
  if (*(_DWORD *)(*(_QWORD *)(v3[11] + 32) + 8))
    b2EdgeAndCircleContact::b2EdgeAndCircleContact();
}

uint64_t b2EdgeAndCircleContact::Evaluate(uint64_t a1, uint64_t a2, float *a3, float *a4)
{
  return b2CollideEdgeAndCircle(a2, *(_QWORD *)(*(_QWORD *)(a1 + 80) + 32), a3, *(float **)(*(_QWORD *)(a1 + 88) + 32), a4);
}

void b2EdgeAndCircleContact::~b2EdgeAndCircleContact(b2EdgeAndCircleContact *this)
{
  JUMPOUT(0x20BD0BA58);
}

b2EdgeAndPolygonContact *b2EdgeAndPolygonContact::Create(b2Fixture *this, b2Fixture *a2, b2Fixture *a3, b2Fixture *a4)
{
  b2EdgeAndPolygonContact *v6;

  v6 = (b2EdgeAndPolygonContact *)operator new();
  b2EdgeAndPolygonContact::b2EdgeAndPolygonContact(v6, this, a3);
  return v6;
}

void sub_208FBFAF0(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BD0BA58](v1, 0x10A1C40CDD50D3ELL);
  _Unwind_Resume(a1);
}

void b2EdgeAndPolygonContact::b2EdgeAndPolygonContact(b2EdgeAndPolygonContact *this, b2Fixture *a2, b2Fixture *a3)
{
  _QWORD *v3;

  b2Contact::b2Contact(this, a2, 0, a3, 0);
  *v3 = &off_24C0E8748;
  if (*(_DWORD *)(*(_QWORD *)(v3[10] + 32) + 8) != 1)
    b2EdgeAndPolygonContact::b2EdgeAndPolygonContact();
  if (*(_DWORD *)(*(_QWORD *)(v3[11] + 32) + 8) != 2)
    b2EdgeAndPolygonContact::b2EdgeAndPolygonContact();
}

void b2EdgeAndPolygonContact::Evaluate(uint64_t a1, float32x2_t *a2, float *a3, float *a4)
{
  b2CollideEdgeAndPolygon(a2, *(float32x2_t **)(*(_QWORD *)(a1 + 80) + 32), a3, *(_QWORD *)(*(_QWORD *)(a1 + 88) + 32), a4);
}

void b2EdgeAndPolygonContact::~b2EdgeAndPolygonContact(b2EdgeAndPolygonContact *this)
{
  JUMPOUT(0x20BD0BA58);
}

b2PolygonAndCircleContact *b2PolygonAndCircleContact::Create(b2Fixture *this, b2Fixture *a2, b2Fixture *a3, b2Fixture *a4)
{
  b2PolygonAndCircleContact *v6;

  v6 = (b2PolygonAndCircleContact *)operator new();
  b2PolygonAndCircleContact::b2PolygonAndCircleContact(v6, this, a3);
  return v6;
}

void sub_208FBFBFC(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BD0BA58](v1, 0x10A1C40CDD50D3ELL);
  _Unwind_Resume(a1);
}

void b2PolygonAndCircleContact::b2PolygonAndCircleContact(b2PolygonAndCircleContact *this, b2Fixture *a2, b2Fixture *a3)
{
  _QWORD *v3;

  b2Contact::b2Contact(this, a2, 0, a3, 0);
  *v3 = &off_24C0E87C0;
  if (*(_DWORD *)(*(_QWORD *)(v3[10] + 32) + 8) != 2)
    b2PolygonAndCircleContact::b2PolygonAndCircleContact();
  if (*(_DWORD *)(*(_QWORD *)(v3[11] + 32) + 8))
    b2PolygonAndCircleContact::b2PolygonAndCircleContact();
}

float b2PolygonAndCircleContact::Evaluate(uint64_t a1, uint64_t a2, float *a3, float *a4)
{
  return b2CollidePolygonAndCircle(a2, *(_QWORD *)(*(_QWORD *)(a1 + 80) + 32), a3, *(float **)(*(_QWORD *)(a1 + 88) + 32), a4);
}

void b2PolygonAndCircleContact::~b2PolygonAndCircleContact(b2PolygonAndCircleContact *this)
{
  JUMPOUT(0x20BD0BA58);
}

b2PolygonContact *b2PolygonContact::Create(b2Fixture *this, b2Fixture *a2, b2Fixture *a3, b2Fixture *a4)
{
  b2PolygonContact *v6;

  v6 = (b2PolygonContact *)operator new();
  b2PolygonContact::b2PolygonContact(v6, this, a3);
  return v6;
}

void sub_208FBFD04(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BD0BA58](v1, 0x10A1C40CDD50D3ELL);
  _Unwind_Resume(a1);
}

void b2PolygonContact::b2PolygonContact(b2PolygonContact *this, b2Fixture *a2, b2Fixture *a3)
{
  _QWORD *v3;

  b2Contact::b2Contact(this, a2, 0, a3, 0);
  *v3 = &off_24C0E84D0;
  if (*(_DWORD *)(*(_QWORD *)(v3[10] + 32) + 8) != 2)
    b2PolygonContact::b2PolygonContact();
  if (*(_DWORD *)(*(_QWORD *)(v3[11] + 32) + 8) != 2)
    b2PolygonContact::b2PolygonContact();
}

void b2PolygonContact::Evaluate(uint64_t a1, float32x2_t *a2, const b2Transform *a3, const b2Transform *a4)
{
  b2CollidePolygons(a2, *(float **)(*(_QWORD *)(a1 + 80) + 32), a3, *(float **)(*(_QWORD *)(a1 + 88) + 32), a4);
}

void b2PolygonContact::~b2PolygonContact(b2PolygonContact *this)
{
  JUMPOUT(0x20BD0BA58);
}

void sub_208FBFE94(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t std::shared_ptr<PKCGrid>::operator=[abi:ne180100](uint64_t a1, __int128 *a2)
{
  __int128 v3;
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;

  v3 = *a2;
  *(_QWORD *)a2 = 0;
  *((_QWORD *)a2 + 1) = 0;
  v4 = *(std::__shared_weak_count **)(a1 + 8);
  *(_OWORD *)a1 = v3;
  if (v4)
  {
    p_shared_owners = (unint64_t *)&v4->__shared_owners_;
    do
      v6 = __ldaxr(p_shared_owners);
    while (__stlxr(v6 - 1, p_shared_owners));
    if (!v6)
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
  return a1;
}

void sub_208FBFFFC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_208FC00DC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t _ZNSt3__115allocate_sharedB8ne180100I7PKCGridNS_9allocatorIS1_EEJEvEENS_10shared_ptrIT_EERKT0_DpOT1_@<X0>(_QWORD *a1@<X8>)
{
  char *v2;
  uint64_t result;

  v2 = (char *)operator new(0xA0uLL);
  result = _ZNSt3__120__shared_ptr_emplaceI7PKCGridNS_9allocatorIS1_EEEC2B8ne180100IJES3_Li0EEES3_DpOT_((uint64_t)v2);
  *a1 = v2 + 24;
  a1[1] = v2;
  return result;
}

void sub_208FC0254(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t _ZNSt3__120__shared_ptr_emplaceI7PKCGridNS_9allocatorIS1_EEEC2B8ne180100IJES3_Li0EEES3_DpOT_(uint64_t a1)
{
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)a1 = &unk_24C0E8D60;
  *(_QWORD *)(a1 + 8) = 0;
  PKCGrid::PKCGrid((PKCGrid *)(a1 + 24));
  return a1;
}

void sub_208FC02A0(_Unwind_Exception *a1)
{
  std::__shared_weak_count *v1;

  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<PKCGrid>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_24C0E8D60;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<PKCGrid>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_24C0E8D60;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x20BD0BA58);
}

void std::__shared_ptr_emplace<PKCGrid>::__on_zero_shared(uint64_t a1)
{
  PKCGrid::~PKCGrid((PKCGrid *)(a1 + 24));
}

void PKCGrid::~PKCGrid(PKCGrid *this)
{
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  v2 = (void *)*((_QWORD *)this + 14);
  if (v2)
  {
    *((_QWORD *)this + 15) = v2;
    operator delete(v2);
  }
  v3 = (void *)*((_QWORD *)this + 11);
  if (v3)
  {
    *((_QWORD *)this + 12) = v3;
    operator delete(v3);
  }
  v4 = (void *)*((_QWORD *)this + 8);
  if (v4)
  {
    *((_QWORD *)this + 9) = v4;
    operator delete(v4);
  }
  v5 = (void *)*((_QWORD *)this + 5);
  if (v5)
  {
    *((_QWORD *)this + 6) = v5;
    operator delete(v5);
  }
}

float noise1(float a1)
{
  int v1;
  float v2;
  float v3;
  uint64_t v4;
  float v5;
  float v6;
  float v7;
  float v8;

  v1 = (int)a1 - (a1 <= 0.0);
  v2 = a1 - (float)v1;
  v3 = v2 + -1.0;
  v4 = (v1 + 1);
  v5 = (float)(v2 * (float)(v2 * v2)) * (float)((float)(v2 * (float)((float)(v2 * 6.0) + -15.0)) + 10.0);
  LOBYTE(v1) = perm_0[v1];
  v6 = (float)((v1 & 7) + 1);
  if ((v1 & 8) != 0)
    v6 = -v6;
  v7 = v2 * v6;
  v8 = (float)((perm_0[v4] & 7) + 1);
  if ((perm_0[v4] & 8) != 0)
    v8 = -v8;
  return (float)(v7 + (float)(v5 * (float)((float)(v3 * v8) - v7))) * 0.188;
}

float pnoise1(int a1, float a2)
{
  int v2;
  float v3;
  float v4;
  uint64_t v5;
  float v6;
  float v7;
  float v8;
  float v9;

  v2 = (int)a2 - (a2 <= 0.0);
  v3 = a2 - (float)v2;
  v4 = v3 + -1.0;
  v5 = ((v2 + 1) % a1);
  v6 = (float)(v3 * (float)(v3 * v3)) * (float)((float)(v3 * (float)((float)(v3 * 6.0) + -15.0)) + 10.0);
  LOBYTE(v2) = perm_0[(v2 % a1)];
  v7 = (float)((v2 & 7) + 1);
  if ((v2 & 8) != 0)
    v7 = -v7;
  v8 = v3 * v7;
  v9 = (float)((perm_0[v5] & 7) + 1);
  if ((perm_0[v5] & 8) != 0)
    v9 = -v9;
  return (float)(v8 + (float)(v6 * (float)((float)(v4 * v9) - v8))) * 0.188;
}

float noise2(float a1, float a2, double a3, double a4, double a5, double a6, double a7)
{
  int v7;
  int v8;
  __int32 v9;
  int8x8_t v10;
  uint64_t v11;
  uint64_t v12;
  float v13;
  float v14;
  uint64_t v15;
  _BYTE *v16;
  uint64_t v17;
  _BYTE *v18;
  int8x8_t v19;
  int8x8_t v20;
  int8x8_t v21;
  int32x2_t v22;
  int8x16_t v23;
  float64x2_t v30;
  float32x2_t v31;
  int8x8_t v32;
  float32x2_t v33;
  int8x8_t v34;
  int8x8_t v35;
  int8x8_t v36;
  float64x2_t v37;
  float32x2_t v38;
  float32x2_t v39;

  v7 = (int)a1 - (a1 <= 0.0);
  v8 = (int)a2 - (a2 <= 0.0);
  *(float *)&v9 = a1 - (float)v7;
  *(float *)&a6 = a2 - (float)v8;
  *(float *)v10.i32 = *(float *)&v9 + -1.0;
  *(float *)&a4 = *(float *)&a6 + -1.0;
  v11 = (v7 + 1);
  v12 = (v8 + 1);
  v13 = (float)(*(float *)&a6 * (float)(*(float *)&a6 * *(float *)&a6))
      * (float)((float)(*(float *)&a6 * (float)((float)(*(float *)&a6 * 6.0) + -15.0)) + 10.0);
  *(float *)&a7 = (float)(*(float *)&v9 * (float)((float)(*(float *)&v9 * 6.0) + -15.0)) + 10.0;
  v14 = (float)(*(float *)&v9 * (float)(*(float *)&v9 * *(float *)&v9)) * *(float *)&a7;
  v15 = perm_0[v8];
  v16 = &perm_0[v7];
  v17 = perm_0[v12];
  v18 = &perm_0[v11];
  LOBYTE(a7) = v18[v15];
  BYTE4(a7) = v16[v15];
  v19 = vand_s8(*(int8x8_t *)&a7, (int8x8_t)0xFF000000FFLL);
  v20 = (int8x8_t)vdup_lane_s32(*(int32x2_t *)&a6, 0);
  v10.i32[1] = v9;
  v21 = (int8x8_t)vceqz_s32((int32x2_t)(*(_QWORD *)&v19 & 0xFFFFFF04FFFFFF04));
  v22 = vceqz_s32((int32x2_t)(*(_QWORD *)&v19 & 0xFFFFFF02FFFFFF02));
  v23.i64[0] = v22.i32[0];
  v23.i64[1] = v22.i32[1];
  __asm
  {
    FMOV            V18.2D, #-2.0
    FMOV            V19.2D, #2.0
  }
  v30 = vmulq_f64((float64x2_t)vbslq_s8(v23, _Q19, _Q18), vcvtq_f64_f32((float32x2_t)vbsl_s8(v21, v20, v10)));
  v31 = (float32x2_t)vbsl_s8(v21, v10, v20);
  v32 = (int8x8_t)vneg_f32(v31);
  v33 = vcvt_f32_f64(vaddq_f64(v30, vcvtq_f64_f32((float32x2_t)vbsl_s8((int8x8_t)vceqz_s32((int32x2_t)(*(_QWORD *)&v19 & 0xFFFFFF01FFFFFF01)), (int8x8_t)v31, v32))));
  v32.i8[0] = v18[v17];
  v32.i8[4] = v16[v17];
  v34 = vand_s8(v32, (int8x8_t)0xFF000000FFLL);
  v35 = (int8x8_t)vceqz_s32((int32x2_t)(*(_QWORD *)&v34 & 0xFFFFFF04FFFFFF04));
  v36 = (int8x8_t)vdup_lane_s32(*(int32x2_t *)&a4, 0);
  *(int32x2_t *)&v30.f64[0] = vceqz_s32((int32x2_t)(*(_QWORD *)&v34 & 0xFFFFFF02FFFFFF02));
  v23.i64[0] = SLODWORD(v30.f64[0]);
  v23.i64[1] = SHIDWORD(v30.f64[0]);
  v37 = vmulq_f64((float64x2_t)vbslq_s8(v23, _Q19, _Q18), vcvtq_f64_f32((float32x2_t)vbsl_s8(v35, v36, v10)));
  v38 = (float32x2_t)vbsl_s8(v35, v10, v36);
  v39 = vmla_n_f32(v33, vsub_f32(vcvt_f32_f64(vaddq_f64(v37, vcvtq_f64_f32((float32x2_t)vbsl_s8((int8x8_t)vceqz_s32((int32x2_t)(*(_QWORD *)&v34 & 0xFFFFFF01FFFFFF01)), (int8x8_t)v38, (int8x8_t)vneg_f32(v38))))), v33), v13);
  return (float)(v39.f32[1] + (float)(v14 * (float)(v39.f32[0] - v39.f32[1]))) * 0.507;
}

float pnoise2(int a1, int a2, float a3, double a4, double a5, double a6, double a7, double a8, double a9)
{
  int v9;
  int v10;
  __int32 v11;
  int8x8_t v12;
  uint64_t v13;
  uint64_t v14;
  float v15;
  float v16;
  uint64_t v17;
  _BYTE *v18;
  uint64_t v19;
  _BYTE *v20;
  int8x8_t v21;
  int8x8_t v22;
  int8x8_t v23;
  int32x2_t v24;
  int8x16_t v25;
  float64x2_t v32;
  float32x2_t v33;
  int8x8_t v34;
  float32x2_t v35;
  int8x8_t v36;
  int8x8_t v37;
  int8x8_t v38;
  float64x2_t v39;
  float32x2_t v40;
  float32x2_t v41;

  v9 = (int)a3 - (a3 <= 0.0);
  v10 = (int)*(float *)&a4 - (*(float *)&a4 <= 0.0);
  *(float *)&v11 = a3 - (float)v9;
  *(float *)&a8 = *(float *)&a4 - (float)v10;
  *(float *)v12.i32 = *(float *)&v11 + -1.0;
  *(float *)&a4 = *(float *)&a8 + -1.0;
  v13 = ((v9 + 1) % a1);
  v14 = ((v10 + 1) % a2);
  v15 = (float)(*(float *)&a8 * (float)(*(float *)&a8 * *(float *)&a8))
      * (float)((float)(*(float *)&a8 * (float)((float)(*(float *)&a8 * 6.0) + -15.0)) + 10.0);
  *(float *)&a9 = (float)(*(float *)&v11 * (float)((float)(*(float *)&v11 * 6.0) + -15.0)) + 10.0;
  v16 = (float)(*(float *)&v11 * (float)(*(float *)&v11 * *(float *)&v11)) * *(float *)&a9;
  v17 = perm_0[(v10 % a2)];
  v18 = &perm_0[(v9 % a1)];
  v19 = perm_0[v14];
  v20 = &perm_0[v13];
  LOBYTE(a9) = v20[v17];
  BYTE4(a9) = v18[v17];
  v21 = vand_s8(*(int8x8_t *)&a9, (int8x8_t)0xFF000000FFLL);
  v22 = (int8x8_t)vdup_lane_s32(*(int32x2_t *)&a8, 0);
  v12.i32[1] = v11;
  v23 = (int8x8_t)vceqz_s32((int32x2_t)(*(_QWORD *)&v21 & 0xFFFFFF04FFFFFF04));
  v24 = vceqz_s32((int32x2_t)(*(_QWORD *)&v21 & 0xFFFFFF02FFFFFF02));
  v25.i64[0] = v24.i32[0];
  v25.i64[1] = v24.i32[1];
  __asm
  {
    FMOV            V18.2D, #-2.0
    FMOV            V19.2D, #2.0
  }
  v32 = vmulq_f64((float64x2_t)vbslq_s8(v25, _Q19, _Q18), vcvtq_f64_f32((float32x2_t)vbsl_s8(v23, v22, v12)));
  v33 = (float32x2_t)vbsl_s8(v23, v12, v22);
  v34 = (int8x8_t)vneg_f32(v33);
  v35 = vcvt_f32_f64(vaddq_f64(v32, vcvtq_f64_f32((float32x2_t)vbsl_s8((int8x8_t)vceqz_s32((int32x2_t)(*(_QWORD *)&v21 & 0xFFFFFF01FFFFFF01)), (int8x8_t)v33, v34))));
  v34.i8[0] = v20[v19];
  v34.i8[4] = v18[v19];
  v36 = vand_s8(v34, (int8x8_t)0xFF000000FFLL);
  v37 = (int8x8_t)vceqz_s32((int32x2_t)(*(_QWORD *)&v36 & 0xFFFFFF04FFFFFF04));
  v38 = (int8x8_t)vdup_lane_s32(*(int32x2_t *)&a4, 0);
  *(int32x2_t *)&v32.f64[0] = vceqz_s32((int32x2_t)(*(_QWORD *)&v36 & 0xFFFFFF02FFFFFF02));
  v25.i64[0] = SLODWORD(v32.f64[0]);
  v25.i64[1] = SHIDWORD(v32.f64[0]);
  v39 = vmulq_f64((float64x2_t)vbslq_s8(v25, _Q19, _Q18), vcvtq_f64_f32((float32x2_t)vbsl_s8(v37, v38, v12)));
  v40 = (float32x2_t)vbsl_s8(v37, v12, v38);
  v41 = vmla_n_f32(v35, vsub_f32(vcvt_f32_f64(vaddq_f64(v39, vcvtq_f64_f32((float32x2_t)vbsl_s8((int8x8_t)vceqz_s32((int32x2_t)(*(_QWORD *)&v36 & 0xFFFFFF01FFFFFF01)), (int8x8_t)v40, (int8x8_t)vneg_f32(v40))))), v35), v15);
  return (float)(v41.f32[1] + (float)(v16 * (float)(v41.f32[0] - v41.f32[1]))) * 0.507;
}

float noise3(float a1, float a2, float a3, double a4, double a5, double a6, double a7, int8x8_t a8)
{
  int32x2_t v8;
  int32x2_t v9;
  int v10;
  int v11;
  int v12;
  __int32 v13;
  int8x8_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  float v19;
  float v20;
  uint64_t v21;
  uint64_t v22;
  _BYTE *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  int8x8_t v28;
  int8x8_t v29;
  int8x8_t v30;
  float32x2_t v31;
  float32x2_t v32;
  float32x2_t v33;
  int8x8_t v34;
  float32x2_t v35;
  int8x8_t v36;
  int8x8_t v37;
  float32x2_t v38;
  float32x2_t v39;
  float32x2_t v40;
  float32x2_t v41;
  float32x2_t v42;
  int8x8_t v43;
  int8x8_t v44;
  float32x2_t v45;
  float32x2_t v46;
  float32x2_t v47;
  int8x8_t v48;
  float32x2_t v49;
  int8x8_t v50;
  float32x2_t v51;
  float32x2_t v52;
  float32x2_t v53;

  v10 = (int)a1 - (a1 <= 0.0);
  v11 = (int)a2 - (a2 <= 0.0);
  v12 = (int)a3 - (a3 <= 0.0);
  *(float *)&v13 = a1 - (float)v10;
  *(float *)v8.i32 = a2 - (float)v11;
  *(float *)v9.i32 = a3 - (float)v12;
  *(float *)v14.i32 = *(float *)&v13 + -1.0;
  *(float *)&a5 = *(float *)v8.i32 + -1.0;
  *(float *)&a6 = *(float *)v9.i32 + -1.0;
  v15 = (v10 + 1);
  v16 = (v11 + 1);
  v17 = (v12 + 1);
  v18 = ((int)a2 - (a2 <= 0.0));
  a8.i32[0] = 10.0;
  v19 = (float)(*(float *)v9.i32 * (float)(*(float *)v9.i32 * *(float *)v9.i32))
      * (float)((float)(*(float *)v9.i32 * (float)((float)(*(float *)v9.i32 * 6.0) + -15.0)) + 10.0);
  v20 = (float)(*(float *)v8.i32 * (float)(*(float *)v8.i32 * *(float *)v8.i32))
      * (float)((float)(*(float *)v8.i32 * (float)((float)(*(float *)v8.i32 * 6.0) + -15.0)) + 10.0);
  v21 = perm_0[((int)a3 - (a3 <= 0.0))];
  v22 = perm_0[v18 + v21];
  v23 = &perm_0[v10];
  v24 = perm_0[v17];
  v25 = perm_0[v18 + v24];
  v26 = perm_0[v16 + v21];
  v27 = perm_0[v16 + v24];
  a8.i8[0] = perm_0[v15 + v22];
  a8.i8[4] = v23[v22];
  v28 = vand_s8(a8, (int8x8_t)0xFF000000FFLL);
  v14.i32[1] = v13;
  v29 = (int8x8_t)vdup_lane_s32(v9, 0);
  v30 = (int8x8_t)vdup_lane_s32(v8, 0);
  v31 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x400000004, (uint32x2_t)(*(_QWORD *)&v28 & 0xFFFFFF0FFFFFFF0FLL)), v30, vbsl_s8((int8x8_t)vceq_s32((int32x2_t)(*(_QWORD *)&v28 & 0xFFFFFF0DFFFFFF0DLL), (int32x2_t)0xC0000000CLL), v14, v29));
  v32 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x800000008, (uint32x2_t)(*(_QWORD *)&v28 & 0xFFFFFF0FFFFFFF0FLL)), v14, v30);
  v33 = (float32x2_t)vbsl_s8((int8x8_t)vceqz_s32((int32x2_t)(*(_QWORD *)&v28 & 0xFFFFFF01FFFFFF01)), (int8x8_t)v32, (int8x8_t)vneg_f32(v32));
  v34 = (int8x8_t)vceqz_s32((int32x2_t)(*(_QWORD *)&v28 & 0xFFFFFF02FFFFFF02));
  v35 = vadd_f32(v33, (float32x2_t)vbsl_s8(v34, (int8x8_t)v31, (int8x8_t)vneg_f32(v31)));
  v34.i8[0] = perm_0[v15 + v25];
  v34.i8[4] = v23[v25];
  v36 = vand_s8(v34, (int8x8_t)0xFF000000FFLL);
  v37 = (int8x8_t)vdup_lane_s32(*(int32x2_t *)&a6, 0);
  v38 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x400000004, (uint32x2_t)(*(_QWORD *)&v36 & 0xFFFFFF0FFFFFFF0FLL)), v30, vbsl_s8((int8x8_t)vceq_s32((int32x2_t)(*(_QWORD *)&v36 & 0xFFFFFF0DFFFFFF0DLL), (int32x2_t)0xC0000000CLL), v14, v37));
  v39 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x800000008, (uint32x2_t)(*(_QWORD *)&v36 & 0xFFFFFF0FFFFFFF0FLL)), v14, v30);
  v40 = (float32x2_t)vbsl_s8((int8x8_t)vceqz_s32((int32x2_t)(*(_QWORD *)&v36 & 0xFFFFFF01FFFFFF01)), (int8x8_t)v39, (int8x8_t)vneg_f32(v39));
  v41 = vsub_f32(vadd_f32(v40, (float32x2_t)vbsl_s8((int8x8_t)vceqz_s32((int32x2_t)(*(_QWORD *)&v36 & 0xFFFFFF02FFFFFF02)), (int8x8_t)v38, (int8x8_t)vneg_f32(v38))), v35);
  v40.i8[0] = perm_0[v15 + v26];
  v40.i8[4] = v23[v26];
  v42 = vmla_n_f32(v35, v41, v19);
  v43 = vand_s8((int8x8_t)v40, (int8x8_t)0xFF000000FFLL);
  v44 = (int8x8_t)vdup_lane_s32(*(int32x2_t *)&a5, 0);
  v45 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x400000004, (uint32x2_t)(*(_QWORD *)&v43 & 0xFFFFFF0FFFFFFF0FLL)), v44, vbsl_s8((int8x8_t)vceq_s32((int32x2_t)(*(_QWORD *)&v43 & 0xFFFFFF0DFFFFFF0DLL), (int32x2_t)0xC0000000CLL), v14, v29));
  v46 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x800000008, (uint32x2_t)(*(_QWORD *)&v43 & 0xFFFFFF0FFFFFFF0FLL)), v14, v44);
  v47 = (float32x2_t)vbsl_s8((int8x8_t)vceqz_s32((int32x2_t)(*(_QWORD *)&v43 & 0xFFFFFF01FFFFFF01)), (int8x8_t)v46, (int8x8_t)vneg_f32(v46));
  v48 = (int8x8_t)vceqz_s32((int32x2_t)(*(_QWORD *)&v43 & 0xFFFFFF02FFFFFF02));
  v49 = vadd_f32(v47, (float32x2_t)vbsl_s8(v48, (int8x8_t)v45, (int8x8_t)vneg_f32(v45)));
  v48.i8[0] = perm_0[v15 + v27];
  v48.i8[4] = v23[v27];
  v50 = vand_s8(v48, (int8x8_t)0xFF000000FFLL);
  v51 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x400000004, (uint32x2_t)(*(_QWORD *)&v50 & 0xFFFFFF0FFFFFFF0FLL)), v44, vbsl_s8((int8x8_t)vceq_s32((int32x2_t)(*(_QWORD *)&v50 & 0xFFFFFF0DFFFFFF0DLL), (int32x2_t)0xC0000000CLL), v14, v37));
  v52 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x800000008, (uint32x2_t)(*(_QWORD *)&v50 & 0xFFFFFF0FFFFFFF0FLL)), v14, v44);
  v53 = vmla_n_f32(v42, vsub_f32(vmla_n_f32(v49, vsub_f32(vadd_f32((float32x2_t)vbsl_s8((int8x8_t)vceqz_s32((int32x2_t)(*(_QWORD *)&v50 & 0xFFFFFF01FFFFFF01)), (int8x8_t)v52, (int8x8_t)vneg_f32(v52)), (float32x2_t)vbsl_s8((int8x8_t)vceqz_s32((int32x2_t)(*(_QWORD *)&v50 & 0xFFFFFF02FFFFFF02)), (int8x8_t)v51, (int8x8_t)vneg_f32(v51))), v49), v19), v42), v20);
  return (float)(v53.f32[1]
               + (float)((float)((float)(*(float *)&v13 * (float)(*(float *)&v13 * *(float *)&v13))
                               * (float)((float)(*(float *)&v13 * (float)((float)(*(float *)&v13 * 6.0) + -15.0)) + 10.0))
                       * (float)(v53.f32[0] - v53.f32[1])))
       * 0.936;
}

float pnoise3(int a1, int a2, int a3, float a4, float a5, float a6, double a7, double a8, double a9, double a10, int8x8_t a11)
{
  int32x2_t v11;
  int32x2_t v12;
  int v13;
  int v14;
  int v15;
  __int32 v16;
  int8x8_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  float v22;
  float v23;
  uint64_t v24;
  uint64_t v25;
  _BYTE *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  _BYTE *v31;
  int8x8_t v32;
  int8x8_t v33;
  int8x8_t v34;
  float32x2_t v35;
  float32x2_t v36;
  float32x2_t v37;
  int8x8_t v38;
  float32x2_t v39;
  int8x8_t v40;
  int8x8_t v41;
  float32x2_t v42;
  float32x2_t v43;
  float32x2_t v44;
  float32x2_t v45;
  float32x2_t v46;
  int8x8_t v47;
  int8x8_t v48;
  float32x2_t v49;
  float32x2_t v50;
  float32x2_t v51;
  int8x8_t v52;
  float32x2_t v53;
  int8x8_t v54;
  float32x2_t v55;
  float32x2_t v56;
  float32x2_t v57;

  v13 = (int)a4 - (a4 <= 0.0);
  v14 = (int)a5 - (a5 <= 0.0);
  v15 = (int)a6 - (a6 <= 0.0);
  *(float *)&v16 = a4 - (float)v13;
  *(float *)v11.i32 = a5 - (float)v14;
  *(float *)v12.i32 = a6 - (float)v15;
  *(float *)v17.i32 = *(float *)&v16 + -1.0;
  *(float *)&a8 = *(float *)v11.i32 + -1.0;
  *(float *)&a9 = *(float *)v12.i32 + -1.0;
  v18 = ((v13 + 1) % a1);
  v19 = ((v14 + 1) % a2);
  v20 = ((v15 + 1) % a3);
  v21 = (v14 % a2);
  a11.i32[0] = 10.0;
  v22 = (float)(*(float *)v12.i32 * (float)(*(float *)v12.i32 * *(float *)v12.i32))
      * (float)((float)(*(float *)v12.i32 * (float)((float)(*(float *)v12.i32 * 6.0) + -15.0)) + 10.0);
  v23 = (float)(*(float *)v11.i32 * (float)(*(float *)v11.i32 * *(float *)v11.i32))
      * (float)((float)(*(float *)v11.i32 * (float)((float)(*(float *)v11.i32 * 6.0) + -15.0)) + 10.0);
  v24 = perm_0[(v15 % a3)];
  v25 = perm_0[v21 + v24];
  v26 = &perm_0[(v13 % a1)];
  v27 = perm_0[v20];
  v28 = perm_0[v21 + v27];
  v29 = perm_0[v19 + v24];
  v30 = perm_0[v19 + v27];
  v31 = &perm_0[v18];
  a11.i8[0] = v31[v25];
  a11.i8[4] = v26[v25];
  v32 = vand_s8(a11, (int8x8_t)0xFF000000FFLL);
  v17.i32[1] = v16;
  v33 = (int8x8_t)vdup_lane_s32(v12, 0);
  v34 = (int8x8_t)vdup_lane_s32(v11, 0);
  v35 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x400000004, (uint32x2_t)(*(_QWORD *)&v32 & 0xFFFFFF0FFFFFFF0FLL)), v34, vbsl_s8((int8x8_t)vceq_s32((int32x2_t)(*(_QWORD *)&v32 & 0xFFFFFF0DFFFFFF0DLL), (int32x2_t)0xC0000000CLL), v17, v33));
  v36 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x800000008, (uint32x2_t)(*(_QWORD *)&v32 & 0xFFFFFF0FFFFFFF0FLL)), v17, v34);
  v37 = (float32x2_t)vbsl_s8((int8x8_t)vceqz_s32((int32x2_t)(*(_QWORD *)&v32 & 0xFFFFFF01FFFFFF01)), (int8x8_t)v36, (int8x8_t)vneg_f32(v36));
  v38 = (int8x8_t)vceqz_s32((int32x2_t)(*(_QWORD *)&v32 & 0xFFFFFF02FFFFFF02));
  v39 = vadd_f32(v37, (float32x2_t)vbsl_s8(v38, (int8x8_t)v35, (int8x8_t)vneg_f32(v35)));
  v38.i8[0] = v31[v28];
  v38.i8[4] = v26[v28];
  v40 = vand_s8(v38, (int8x8_t)0xFF000000FFLL);
  v41 = (int8x8_t)vdup_lane_s32(*(int32x2_t *)&a9, 0);
  v42 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x400000004, (uint32x2_t)(*(_QWORD *)&v40 & 0xFFFFFF0FFFFFFF0FLL)), v34, vbsl_s8((int8x8_t)vceq_s32((int32x2_t)(*(_QWORD *)&v40 & 0xFFFFFF0DFFFFFF0DLL), (int32x2_t)0xC0000000CLL), v17, v41));
  v43 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x800000008, (uint32x2_t)(*(_QWORD *)&v40 & 0xFFFFFF0FFFFFFF0FLL)), v17, v34);
  v44 = (float32x2_t)vbsl_s8((int8x8_t)vceqz_s32((int32x2_t)(*(_QWORD *)&v40 & 0xFFFFFF01FFFFFF01)), (int8x8_t)v43, (int8x8_t)vneg_f32(v43));
  v45 = vsub_f32(vadd_f32(v44, (float32x2_t)vbsl_s8((int8x8_t)vceqz_s32((int32x2_t)(*(_QWORD *)&v40 & 0xFFFFFF02FFFFFF02)), (int8x8_t)v42, (int8x8_t)vneg_f32(v42))), v39);
  v44.i8[0] = v31[v29];
  v44.i8[4] = v26[v29];
  v46 = vmla_n_f32(v39, v45, v22);
  v47 = vand_s8((int8x8_t)v44, (int8x8_t)0xFF000000FFLL);
  v48 = (int8x8_t)vdup_lane_s32(*(int32x2_t *)&a8, 0);
  v49 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x400000004, (uint32x2_t)(*(_QWORD *)&v47 & 0xFFFFFF0FFFFFFF0FLL)), v48, vbsl_s8((int8x8_t)vceq_s32((int32x2_t)(*(_QWORD *)&v47 & 0xFFFFFF0DFFFFFF0DLL), (int32x2_t)0xC0000000CLL), v17, v33));
  v50 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x800000008, (uint32x2_t)(*(_QWORD *)&v47 & 0xFFFFFF0FFFFFFF0FLL)), v17, v48);
  v51 = (float32x2_t)vbsl_s8((int8x8_t)vceqz_s32((int32x2_t)(*(_QWORD *)&v47 & 0xFFFFFF01FFFFFF01)), (int8x8_t)v50, (int8x8_t)vneg_f32(v50));
  v52 = (int8x8_t)vceqz_s32((int32x2_t)(*(_QWORD *)&v47 & 0xFFFFFF02FFFFFF02));
  v53 = vadd_f32(v51, (float32x2_t)vbsl_s8(v52, (int8x8_t)v49, (int8x8_t)vneg_f32(v49)));
  v52.i8[0] = v31[v30];
  v52.i8[4] = v26[v30];
  v54 = vand_s8(v52, (int8x8_t)0xFF000000FFLL);
  v55 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x400000004, (uint32x2_t)(*(_QWORD *)&v54 & 0xFFFFFF0FFFFFFF0FLL)), v48, vbsl_s8((int8x8_t)vceq_s32((int32x2_t)(*(_QWORD *)&v54 & 0xFFFFFF0DFFFFFF0DLL), (int32x2_t)0xC0000000CLL), v17, v41));
  v56 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x800000008, (uint32x2_t)(*(_QWORD *)&v54 & 0xFFFFFF0FFFFFFF0FLL)), v17, v48);
  v57 = vmla_n_f32(v46, vsub_f32(vmla_n_f32(v53, vsub_f32(vadd_f32((float32x2_t)vbsl_s8((int8x8_t)vceqz_s32((int32x2_t)(*(_QWORD *)&v54 & 0xFFFFFF01FFFFFF01)), (int8x8_t)v56, (int8x8_t)vneg_f32(v56)), (float32x2_t)vbsl_s8((int8x8_t)vceqz_s32((int32x2_t)(*(_QWORD *)&v54 & 0xFFFFFF02FFFFFF02)), (int8x8_t)v55, (int8x8_t)vneg_f32(v55))), v53), v22), v46), v23);
  return (float)(v57.f32[1]
               + (float)((float)((float)(*(float *)&v16 * (float)(*(float *)&v16 * *(float *)&v16))
                               * (float)((float)(*(float *)&v16 * (float)((float)(*(float *)&v16 * 6.0) + -15.0)) + 10.0))
                       * (float)(v57.f32[0] - v57.f32[1])))
       * 0.936;
}

float noise4(float a1, float a2, float a3, float a4, double a5, double a6, double a7, int8x8_t a8)
{
  int32x2_t v8;
  int32x2_t v9;
  int32x2_t v10;
  int32x2_t v11;
  int32x2_t v12;
  int v13;
  int v14;
  int v15;
  int v16;
  __int32 v17;
  int8x8_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  float v26;
  float v27;
  float v28;
  float v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  _BYTE *v44;
  int8x8_t v45;
  int8x8_t v46;
  float32x2_t v47;
  int8x8_t v48;
  float32x2_t v49;
  int8x8_t v50;
  float32x2_t v51;
  float32x2_t v52;
  int8x8_t v53;
  float32x2_t v54;
  int8x8_t v55;
  float32x2_t v56;
  float32x2_t v57;
  int8x8_t v58;
  float32x2_t v59;
  float32x2_t v60;
  float32x2_t v61;
  int8x8_t v62;
  float32x2_t v63;
  int8x8_t v64;
  float32x2_t v65;
  float32x2_t v66;
  float32x2_t v67;
  int8x8_t v68;
  float32x2_t v69;
  float32x2_t v70;
  float32x2_t v71;
  float32x2_t v72;
  float32x2_t v73;
  float32x2_t v74;
  int8x8_t v75;
  int8x8_t v76;
  float32x2_t v77;
  float32x2_t v78;
  float32x2_t v79;
  float32x2_t v80;
  float32x2_t v81;
  float32x2_t v82;
  int8x8_t v83;
  float32x2_t v84;
  float32x2_t v85;
  float32x2_t v86;
  float32x2_t v87;
  float32x2_t v88;
  int8x8_t v89;
  float32x2_t v90;
  float32x2_t v91;
  float32x2_t v92;
  float32x2_t v93;
  int8x8_t v94;
  float32x2_t v95;
  int8x8_t v96;
  float32x2_t v97;
  float32x2_t v98;
  float32x2_t v99;
  float32x2_t v100;

  v13 = (int)a1 - (a1 <= 0.0);
  v14 = (int)a2 - (a2 <= 0.0);
  v15 = (int)a3 - (a3 <= 0.0);
  v16 = (int)a4 - (a4 <= 0.0);
  *(float *)&v17 = a1 - (float)v13;
  *(float *)v9.i32 = a2 - (float)v14;
  *(float *)v10.i32 = a3 - (float)v15;
  *(float *)v8.i32 = a4 - (float)v16;
  *(float *)v18.i32 = *(float *)&v17 + -1.0;
  *(float *)&a6 = *(float *)v9.i32 + -1.0;
  *(float *)v12.i32 = *(float *)v10.i32 + -1.0;
  *(float *)v11.i32 = *(float *)v8.i32 + -1.0;
  v19 = (v13 + 1);
  v20 = (v14 + 1);
  v21 = (v15 + 1);
  v22 = (v16 + 1);
  v23 = v13;
  v24 = ((int)a2 - (a2 <= 0.0));
  v25 = ((int)a3 - (a3 <= 0.0));
  a8.i32[0] = 10.0;
  v26 = (float)(*(float *)v8.i32 * (float)(*(float *)v8.i32 * *(float *)v8.i32))
      * (float)((float)(*(float *)v8.i32 * (float)((float)(*(float *)v8.i32 * 6.0) + -15.0)) + 10.0);
  v27 = (float)(*(float *)v10.i32 * (float)(*(float *)v10.i32 * *(float *)v10.i32))
      * (float)((float)(*(float *)v10.i32 * (float)((float)(*(float *)v10.i32 * 6.0) + -15.0)) + 10.0);
  v28 = (float)(*(float *)v9.i32 * (float)(*(float *)v9.i32 * *(float *)v9.i32))
      * (float)((float)(*(float *)v9.i32 * (float)((float)(*(float *)v9.i32 * 6.0) + -15.0)) + 10.0);
  v29 = (float)(*(float *)&v17 * (float)(*(float *)&v17 * *(float *)&v17))
      * (float)((float)(*(float *)&v17 * (float)((float)(*(float *)&v17 * 6.0) + -15.0)) + 10.0);
  v30 = perm_0[v16];
  v31 = perm_0[v25 + v30];
  v32 = perm_0[v24 + v31];
  v33 = perm_0[v22];
  v34 = perm_0[v25 + v33];
  v35 = perm_0[v24 + v34];
  v36 = perm_0[v21 + v30];
  v37 = perm_0[v24 + v36];
  v38 = perm_0[v21 + v33];
  v39 = perm_0[v24 + v38];
  v40 = perm_0[v20 + v31];
  v41 = perm_0[v20 + v34];
  v42 = perm_0[v20 + v36];
  v43 = perm_0[v20 + v38];
  v44 = &perm_0[v19];
  a8.i8[0] = v44[v32];
  a8.i8[4] = perm_0[v23 + v32];
  v45 = vand_s8(a8, (int8x8_t)0xFF000000FFLL);
  v18.i32[1] = v17;
  v46 = (int8x8_t)vdup_lane_s32(v9, 0);
  v47 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x1800000018, (uint32x2_t)(*(_QWORD *)&v45 & 0xFFFFFF1FFFFFFF1FLL)), v18, v46);
  v48 = (int8x8_t)vdup_lane_s32(v10, 0);
  v49 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x1000000010, (uint32x2_t)(*(_QWORD *)&v45 & 0xFFFFFF1FFFFFFF1FLL)), v46, v48);
  v50 = (int8x8_t)vdup_lane_s32(v8, 0);
  v51 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x800000008, (uint32x2_t)(*(_QWORD *)&v45 & 0xFFFFFF1FFFFFFF1FLL)), v48, v50);
  v52 = vadd_f32((float32x2_t)vbsl_s8((int8x8_t)vceqz_s32((int32x2_t)(*(_QWORD *)&v45 & 0xFFFFFF01FFFFFF01)), (int8x8_t)v47, (int8x8_t)vneg_f32(v47)), (float32x2_t)vbsl_s8((int8x8_t)vceqz_s32((int32x2_t)(*(_QWORD *)&v45 & 0xFFFFFF02FFFFFF02)), (int8x8_t)v49, (int8x8_t)vneg_f32(v49)));
  v53 = (int8x8_t)vceqz_s32((int32x2_t)(*(_QWORD *)&v45 & 0xFFFFFF04FFFFFF04));
  v54 = vadd_f32((float32x2_t)vbsl_s8(v53, (int8x8_t)v51, (int8x8_t)vneg_f32(v51)), v52);
  v53.i8[0] = v44[v35];
  v53.i8[4] = perm_0[v23 + v35];
  v55 = vand_s8(v53, (int8x8_t)0xFF000000FFLL);
  v56 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x1800000018, (uint32x2_t)(*(_QWORD *)&v55 & 0xFFFFFF1FFFFFFF1FLL)), v18, v46);
  v57 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x1000000010, (uint32x2_t)(*(_QWORD *)&v55 & 0xFFFFFF1FFFFFFF1FLL)), v46, v48);
  v58 = (int8x8_t)vdup_lane_s32(v11, 0);
  v59 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x800000008, (uint32x2_t)(*(_QWORD *)&v55 & 0xFFFFFF1FFFFFFF1FLL)), v48, v58);
  v60 = vsub_f32(vadd_f32((float32x2_t)vbsl_s8((int8x8_t)vceqz_s32((int32x2_t)(*(_QWORD *)&v55 & 0xFFFFFF04FFFFFF04)), (int8x8_t)v59, (int8x8_t)vneg_f32(v59)), vadd_f32((float32x2_t)vbsl_s8((int8x8_t)vceqz_s32((int32x2_t)(*(_QWORD *)&v55 & 0xFFFFFF01FFFFFF01)), (int8x8_t)v56, (int8x8_t)vneg_f32(v56)), (float32x2_t)vbsl_s8((int8x8_t)vceqz_s32((int32x2_t)(*(_QWORD *)&v55 & 0xFFFFFF02FFFFFF02)), (int8x8_t)v57, (int8x8_t)vneg_f32(v57)))), v54);
  v61 = vmla_n_f32(v54, v60, v26);
  v60.i8[0] = v44[v37];
  v60.i8[4] = perm_0[v23 + v37];
  v62 = vand_s8((int8x8_t)v60, (int8x8_t)0xFF000000FFLL);
  v63 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x1800000018, (uint32x2_t)(*(_QWORD *)&v62 & 0xFFFFFF1FFFFFFF1FLL)), v18, v46);
  v64 = (int8x8_t)vdup_lane_s32(v12, 0);
  v65 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x1000000010, (uint32x2_t)(*(_QWORD *)&v62 & 0xFFFFFF1FFFFFFF1FLL)), v46, v64);
  v66 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x800000008, (uint32x2_t)(*(_QWORD *)&v62 & 0xFFFFFF1FFFFFFF1FLL)), v64, v50);
  v67 = vadd_f32((float32x2_t)vbsl_s8((int8x8_t)vceqz_s32((int32x2_t)(*(_QWORD *)&v62 & 0xFFFFFF04FFFFFF04)), (int8x8_t)v66, (int8x8_t)vneg_f32(v66)), vadd_f32((float32x2_t)vbsl_s8((int8x8_t)vceqz_s32((int32x2_t)(*(_QWORD *)&v62 & 0xFFFFFF01FFFFFF01)), (int8x8_t)v63, (int8x8_t)vneg_f32(v63)), (float32x2_t)vbsl_s8((int8x8_t)vceqz_s32((int32x2_t)(*(_QWORD *)&v62 & 0xFFFFFF02FFFFFF02)), (int8x8_t)v65, (int8x8_t)vneg_f32(v65))));
  v66.i8[0] = v44[v39];
  v66.i8[4] = perm_0[v23 + v39];
  v68 = vand_s8((int8x8_t)v66, (int8x8_t)0xFF000000FFLL);
  v69 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x1800000018, (uint32x2_t)(*(_QWORD *)&v68 & 0xFFFFFF1FFFFFFF1FLL)), v18, v46);
  v70 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x1000000010, (uint32x2_t)(*(_QWORD *)&v68 & 0xFFFFFF1FFFFFFF1FLL)), v46, v64);
  v71 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x800000008, (uint32x2_t)(*(_QWORD *)&v68 & 0xFFFFFF1FFFFFFF1FLL)), v64, v58);
  v72 = vmla_n_f32(v67, vsub_f32(vadd_f32((float32x2_t)vbsl_s8((int8x8_t)vceqz_s32((int32x2_t)(*(_QWORD *)&v68 & 0xFFFFFF04FFFFFF04)), (int8x8_t)v71, (int8x8_t)vneg_f32(v71)), vadd_f32((float32x2_t)vbsl_s8((int8x8_t)vceqz_s32((int32x2_t)(*(_QWORD *)&v68 & 0xFFFFFF01FFFFFF01)), (int8x8_t)v69, (int8x8_t)vneg_f32(v69)), (float32x2_t)vbsl_s8((int8x8_t)vceqz_s32((int32x2_t)(*(_QWORD *)&v68 & 0xFFFFFF02FFFFFF02)), (int8x8_t)v70, (int8x8_t)vneg_f32(v70)))), v67), v26);
  v73 = vsub_f32(v72, v61);
  v72.i8[0] = v44[v40];
  v74 = vmla_n_f32(v61, v73, v27);
  v72.i8[4] = perm_0[v23 + v40];
  v75 = vand_s8((int8x8_t)v72, (int8x8_t)0xFF000000FFLL);
  v76 = (int8x8_t)vdup_lane_s32(*(int32x2_t *)&a6, 0);
  v77 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x1800000018, (uint32x2_t)(*(_QWORD *)&v75 & 0xFFFFFF1FFFFFFF1FLL)), v18, v76);
  v78 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x1000000010, (uint32x2_t)(*(_QWORD *)&v75 & 0xFFFFFF1FFFFFFF1FLL)), v76, v48);
  v79 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x800000008, (uint32x2_t)(*(_QWORD *)&v75 & 0xFFFFFF1FFFFFFF1FLL)), v48, v50);
  v80 = vadd_f32((float32x2_t)vbsl_s8((int8x8_t)vceqz_s32((int32x2_t)(*(_QWORD *)&v75 & 0xFFFFFF01FFFFFF01)), (int8x8_t)v77, (int8x8_t)vneg_f32(v77)), (float32x2_t)vbsl_s8((int8x8_t)vceqz_s32((int32x2_t)(*(_QWORD *)&v75 & 0xFFFFFF02FFFFFF02)), (int8x8_t)v78, (int8x8_t)vneg_f32(v78)));
  v81 = (float32x2_t)vbsl_s8((int8x8_t)vceqz_s32((int32x2_t)(*(_QWORD *)&v75 & 0xFFFFFF04FFFFFF04)), (int8x8_t)v79, (int8x8_t)vneg_f32(v79));
  v82 = vadd_f32(v81, v80);
  v81.i8[0] = v44[v41];
  v81.i8[4] = perm_0[v23 + v41];
  v83 = vand_s8((int8x8_t)v81, (int8x8_t)0xFF000000FFLL);
  v84 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x1800000018, (uint32x2_t)(*(_QWORD *)&v83 & 0xFFFFFF1FFFFFFF1FLL)), v18, v76);
  v85 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x1000000010, (uint32x2_t)(*(_QWORD *)&v83 & 0xFFFFFF1FFFFFFF1FLL)), v76, v48);
  v86 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x800000008, (uint32x2_t)(*(_QWORD *)&v83 & 0xFFFFFF1FFFFFFF1FLL)), v48, v58);
  v87 = vsub_f32(vadd_f32((float32x2_t)vbsl_s8((int8x8_t)vceqz_s32((int32x2_t)(*(_QWORD *)&v83 & 0xFFFFFF04FFFFFF04)), (int8x8_t)v86, (int8x8_t)vneg_f32(v86)), vadd_f32((float32x2_t)vbsl_s8((int8x8_t)vceqz_s32((int32x2_t)(*(_QWORD *)&v83 & 0xFFFFFF01FFFFFF01)), (int8x8_t)v84, (int8x8_t)vneg_f32(v84)), (float32x2_t)vbsl_s8((int8x8_t)vceqz_s32((int32x2_t)(*(_QWORD *)&v83 & 0xFFFFFF02FFFFFF02)), (int8x8_t)v85, (int8x8_t)vneg_f32(v85)))), v82);
  v88 = vmla_n_f32(v82, v87, v26);
  v87.i8[0] = v44[v42];
  v87.i8[4] = perm_0[v23 + v42];
  v89 = vand_s8((int8x8_t)v87, (int8x8_t)0xFF000000FFLL);
  v90 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x1800000018, (uint32x2_t)(*(_QWORD *)&v89 & 0xFFFFFF1FFFFFFF1FLL)), v18, v76);
  v91 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x1000000010, (uint32x2_t)(*(_QWORD *)&v89 & 0xFFFFFF1FFFFFFF1FLL)), v76, v64);
  v92 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x800000008, (uint32x2_t)(*(_QWORD *)&v89 & 0xFFFFFF1FFFFFFF1FLL)), v64, v50);
  v93 = vadd_f32((float32x2_t)vbsl_s8((int8x8_t)vceqz_s32((int32x2_t)(*(_QWORD *)&v89 & 0xFFFFFF01FFFFFF01)), (int8x8_t)v90, (int8x8_t)vneg_f32(v90)), (float32x2_t)vbsl_s8((int8x8_t)vceqz_s32((int32x2_t)(*(_QWORD *)&v89 & 0xFFFFFF02FFFFFF02)), (int8x8_t)v91, (int8x8_t)vneg_f32(v91)));
  v94 = (int8x8_t)vceqz_s32((int32x2_t)(*(_QWORD *)&v89 & 0xFFFFFF04FFFFFF04));
  v95 = vadd_f32((float32x2_t)vbsl_s8(v94, (int8x8_t)v92, (int8x8_t)vneg_f32(v92)), v93);
  v94.i8[0] = v44[v43];
  v94.i8[4] = perm_0[v23 + v43];
  v96 = vand_s8(v94, (int8x8_t)0xFF000000FFLL);
  v97 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x1800000018, (uint32x2_t)(*(_QWORD *)&v96 & 0xFFFFFF1FFFFFFF1FLL)), v18, v76);
  v98 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x1000000010, (uint32x2_t)(*(_QWORD *)&v96 & 0xFFFFFF1FFFFFFF1FLL)), v76, v64);
  v99 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x800000008, (uint32x2_t)(*(_QWORD *)&v96 & 0xFFFFFF1FFFFFFF1FLL)), v64, v58);
  v100 = vmla_n_f32(v74, vsub_f32(vmla_n_f32(v88, vsub_f32(vmla_n_f32(v95, vsub_f32(vadd_f32((float32x2_t)vbsl_s8((int8x8_t)vceqz_s32((int32x2_t)(*(_QWORD *)&v96 & 0xFFFFFF04FFFFFF04)), (int8x8_t)v99, (int8x8_t)vneg_f32(v99)), vadd_f32((float32x2_t)vbsl_s8((int8x8_t)vceqz_s32((int32x2_t)(*(_QWORD *)&v96 & 0xFFFFFF01FFFFFF01)), (int8x8_t)v97, (int8x8_t)vneg_f32(v97)), (float32x2_t)vbsl_s8(
                                        (int8x8_t)vceqz_s32((int32x2_t)(*(_QWORD *)&v96 & 0xFFFFFF02FFFFFF02)),
                                        (int8x8_t)v98,
                                        (int8x8_t)vneg_f32(v98)))),
                     v95),
                   v26),
                 v88),
               v27),
             v74),
           v28);
  return (float)(v100.f32[1] + (float)(v29 * (float)(v100.f32[0] - v100.f32[1]))) * 0.87;
}

float pnoise4(int a1, int a2, int a3, int a4, float a5, float a6, float a7, float a8, double a9, double a10, double a11, int8x8_t a12)
{
  int32x2_t v12;
  int32x2_t v13;
  int32x2_t v14;
  int32x2_t v15;
  int32x2_t v16;
  int v17;
  int v18;
  int v19;
  int v20;
  __int32 v21;
  int8x8_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  float v30;
  float v31;
  float v32;
  float v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  _BYTE *v48;
  int8x8_t v49;
  int8x8_t v50;
  float32x2_t v51;
  int8x8_t v52;
  float32x2_t v53;
  int8x8_t v54;
  float32x2_t v55;
  float32x2_t v56;
  int8x8_t v57;
  float32x2_t v58;
  int8x8_t v59;
  float32x2_t v60;
  float32x2_t v61;
  int8x8_t v62;
  float32x2_t v63;
  float32x2_t v64;
  float32x2_t v65;
  int8x8_t v66;
  float32x2_t v67;
  int8x8_t v68;
  float32x2_t v69;
  float32x2_t v70;
  float32x2_t v71;
  int8x8_t v72;
  float32x2_t v73;
  float32x2_t v74;
  float32x2_t v75;
  float32x2_t v76;
  float32x2_t v77;
  float32x2_t v78;
  int8x8_t v79;
  int8x8_t v80;
  float32x2_t v81;
  float32x2_t v82;
  float32x2_t v83;
  float32x2_t v84;
  float32x2_t v85;
  float32x2_t v86;
  int8x8_t v87;
  float32x2_t v88;
  float32x2_t v89;
  float32x2_t v90;
  float32x2_t v91;
  float32x2_t v92;
  int8x8_t v93;
  float32x2_t v94;
  float32x2_t v95;
  float32x2_t v96;
  float32x2_t v97;
  int8x8_t v98;
  float32x2_t v99;
  int8x8_t v100;
  float32x2_t v101;
  float32x2_t v102;
  float32x2_t v103;
  float32x2_t v104;

  v17 = (int)a5 - (a5 <= 0.0);
  v18 = (int)a6 - (a6 <= 0.0);
  v19 = (int)a7 - (a7 <= 0.0);
  v20 = (int)a8 - (a8 <= 0.0);
  *(float *)&v21 = a5 - (float)v17;
  *(float *)v13.i32 = a6 - (float)v18;
  *(float *)v14.i32 = a7 - (float)v19;
  *(float *)v12.i32 = a8 - (float)v20;
  *(float *)v22.i32 = *(float *)&v21 + -1.0;
  *(float *)&a10 = *(float *)v13.i32 + -1.0;
  *(float *)v15.i32 = *(float *)v14.i32 + -1.0;
  *(float *)v16.i32 = *(float *)v12.i32 + -1.0;
  v23 = ((v17 + 1) % a1);
  v24 = ((v18 + 1) % a2);
  v25 = ((v19 + 1) % a3);
  v26 = ((v20 + 1) % a4);
  v27 = (v17 % a1);
  v28 = (v18 % a2);
  v29 = (v19 % a3);
  a12.i32[0] = 10.0;
  v30 = (float)(*(float *)v12.i32 * (float)(*(float *)v12.i32 * *(float *)v12.i32))
      * (float)((float)(*(float *)v12.i32 * (float)((float)(*(float *)v12.i32 * 6.0) + -15.0)) + 10.0);
  v31 = (float)(*(float *)v14.i32 * (float)(*(float *)v14.i32 * *(float *)v14.i32))
      * (float)((float)(*(float *)v14.i32 * (float)((float)(*(float *)v14.i32 * 6.0) + -15.0)) + 10.0);
  v32 = (float)(*(float *)v13.i32 * (float)(*(float *)v13.i32 * *(float *)v13.i32))
      * (float)((float)(*(float *)v13.i32 * (float)((float)(*(float *)v13.i32 * 6.0) + -15.0)) + 10.0);
  v33 = (float)(*(float *)&v21 * (float)(*(float *)&v21 * *(float *)&v21))
      * (float)((float)(*(float *)&v21 * (float)((float)(*(float *)&v21 * 6.0) + -15.0)) + 10.0);
  v34 = perm_0[(v20 % a4)];
  v35 = perm_0[v29 + v34];
  v36 = perm_0[v28 + v35];
  v37 = perm_0[v26];
  v38 = perm_0[v29 + v37];
  v39 = perm_0[v28 + v38];
  v40 = perm_0[v25 + v34];
  v41 = perm_0[v28 + v40];
  v42 = perm_0[v25 + v37];
  v43 = perm_0[v28 + v42];
  v44 = perm_0[v24 + v35];
  v45 = perm_0[v24 + v38];
  v46 = perm_0[v24 + v40];
  v47 = perm_0[v24 + v42];
  v48 = &perm_0[v23];
  a12.i8[0] = v48[v36];
  a12.i8[4] = perm_0[v27 + v36];
  v49 = vand_s8(a12, (int8x8_t)0xFF000000FFLL);
  v22.i32[1] = v21;
  v50 = (int8x8_t)vdup_lane_s32(v13, 0);
  v51 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x1800000018, (uint32x2_t)(*(_QWORD *)&v49 & 0xFFFFFF1FFFFFFF1FLL)), v22, v50);
  v52 = (int8x8_t)vdup_lane_s32(v14, 0);
  v53 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x1000000010, (uint32x2_t)(*(_QWORD *)&v49 & 0xFFFFFF1FFFFFFF1FLL)), v50, v52);
  v54 = (int8x8_t)vdup_lane_s32(v12, 0);
  v55 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x800000008, (uint32x2_t)(*(_QWORD *)&v49 & 0xFFFFFF1FFFFFFF1FLL)), v52, v54);
  v56 = vadd_f32((float32x2_t)vbsl_s8((int8x8_t)vceqz_s32((int32x2_t)(*(_QWORD *)&v49 & 0xFFFFFF01FFFFFF01)), (int8x8_t)v51, (int8x8_t)vneg_f32(v51)), (float32x2_t)vbsl_s8((int8x8_t)vceqz_s32((int32x2_t)(*(_QWORD *)&v49 & 0xFFFFFF02FFFFFF02)), (int8x8_t)v53, (int8x8_t)vneg_f32(v53)));
  v57 = (int8x8_t)vceqz_s32((int32x2_t)(*(_QWORD *)&v49 & 0xFFFFFF04FFFFFF04));
  v58 = vadd_f32((float32x2_t)vbsl_s8(v57, (int8x8_t)v55, (int8x8_t)vneg_f32(v55)), v56);
  v57.i8[0] = v48[v39];
  v57.i8[4] = perm_0[v27 + v39];
  v59 = vand_s8(v57, (int8x8_t)0xFF000000FFLL);
  v60 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x1800000018, (uint32x2_t)(*(_QWORD *)&v59 & 0xFFFFFF1FFFFFFF1FLL)), v22, v50);
  v61 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x1000000010, (uint32x2_t)(*(_QWORD *)&v59 & 0xFFFFFF1FFFFFFF1FLL)), v50, v52);
  v62 = (int8x8_t)vdup_lane_s32(v16, 0);
  v63 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x800000008, (uint32x2_t)(*(_QWORD *)&v59 & 0xFFFFFF1FFFFFFF1FLL)), v52, v62);
  v64 = vsub_f32(vadd_f32((float32x2_t)vbsl_s8((int8x8_t)vceqz_s32((int32x2_t)(*(_QWORD *)&v59 & 0xFFFFFF04FFFFFF04)), (int8x8_t)v63, (int8x8_t)vneg_f32(v63)), vadd_f32((float32x2_t)vbsl_s8((int8x8_t)vceqz_s32((int32x2_t)(*(_QWORD *)&v59 & 0xFFFFFF01FFFFFF01)), (int8x8_t)v60, (int8x8_t)vneg_f32(v60)), (float32x2_t)vbsl_s8((int8x8_t)vceqz_s32((int32x2_t)(*(_QWORD *)&v59 & 0xFFFFFF02FFFFFF02)), (int8x8_t)v61, (int8x8_t)vneg_f32(v61)))), v58);
  v65 = vmla_n_f32(v58, v64, v30);
  v64.i8[0] = v48[v41];
  v64.i8[4] = perm_0[v27 + v41];
  v66 = vand_s8((int8x8_t)v64, (int8x8_t)0xFF000000FFLL);
  v67 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x1800000018, (uint32x2_t)(*(_QWORD *)&v66 & 0xFFFFFF1FFFFFFF1FLL)), v22, v50);
  v68 = (int8x8_t)vdup_lane_s32(v15, 0);
  v69 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x1000000010, (uint32x2_t)(*(_QWORD *)&v66 & 0xFFFFFF1FFFFFFF1FLL)), v50, v68);
  v70 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x800000008, (uint32x2_t)(*(_QWORD *)&v66 & 0xFFFFFF1FFFFFFF1FLL)), v68, v54);
  v71 = vadd_f32((float32x2_t)vbsl_s8((int8x8_t)vceqz_s32((int32x2_t)(*(_QWORD *)&v66 & 0xFFFFFF04FFFFFF04)), (int8x8_t)v70, (int8x8_t)vneg_f32(v70)), vadd_f32((float32x2_t)vbsl_s8((int8x8_t)vceqz_s32((int32x2_t)(*(_QWORD *)&v66 & 0xFFFFFF01FFFFFF01)), (int8x8_t)v67, (int8x8_t)vneg_f32(v67)), (float32x2_t)vbsl_s8((int8x8_t)vceqz_s32((int32x2_t)(*(_QWORD *)&v66 & 0xFFFFFF02FFFFFF02)), (int8x8_t)v69, (int8x8_t)vneg_f32(v69))));
  v70.i8[0] = v48[v43];
  v70.i8[4] = perm_0[v27 + v43];
  v72 = vand_s8((int8x8_t)v70, (int8x8_t)0xFF000000FFLL);
  v73 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x1800000018, (uint32x2_t)(*(_QWORD *)&v72 & 0xFFFFFF1FFFFFFF1FLL)), v22, v50);
  v74 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x1000000010, (uint32x2_t)(*(_QWORD *)&v72 & 0xFFFFFF1FFFFFFF1FLL)), v50, v68);
  v75 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x800000008, (uint32x2_t)(*(_QWORD *)&v72 & 0xFFFFFF1FFFFFFF1FLL)), v68, v62);
  v76 = vmla_n_f32(v71, vsub_f32(vadd_f32((float32x2_t)vbsl_s8((int8x8_t)vceqz_s32((int32x2_t)(*(_QWORD *)&v72 & 0xFFFFFF04FFFFFF04)), (int8x8_t)v75, (int8x8_t)vneg_f32(v75)), vadd_f32((float32x2_t)vbsl_s8((int8x8_t)vceqz_s32((int32x2_t)(*(_QWORD *)&v72 & 0xFFFFFF01FFFFFF01)), (int8x8_t)v73, (int8x8_t)vneg_f32(v73)), (float32x2_t)vbsl_s8((int8x8_t)vceqz_s32((int32x2_t)(*(_QWORD *)&v72 & 0xFFFFFF02FFFFFF02)), (int8x8_t)v74, (int8x8_t)vneg_f32(v74)))), v71), v30);
  v77 = vsub_f32(v76, v65);
  v76.i8[0] = v48[v44];
  v78 = vmla_n_f32(v65, v77, v31);
  v76.i8[4] = perm_0[v27 + v44];
  v79 = vand_s8((int8x8_t)v76, (int8x8_t)0xFF000000FFLL);
  v80 = (int8x8_t)vdup_lane_s32(*(int32x2_t *)&a10, 0);
  v81 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x1800000018, (uint32x2_t)(*(_QWORD *)&v79 & 0xFFFFFF1FFFFFFF1FLL)), v22, v80);
  v82 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x1000000010, (uint32x2_t)(*(_QWORD *)&v79 & 0xFFFFFF1FFFFFFF1FLL)), v80, v52);
  v83 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x800000008, (uint32x2_t)(*(_QWORD *)&v79 & 0xFFFFFF1FFFFFFF1FLL)), v52, v54);
  v84 = vadd_f32((float32x2_t)vbsl_s8((int8x8_t)vceqz_s32((int32x2_t)(*(_QWORD *)&v79 & 0xFFFFFF01FFFFFF01)), (int8x8_t)v81, (int8x8_t)vneg_f32(v81)), (float32x2_t)vbsl_s8((int8x8_t)vceqz_s32((int32x2_t)(*(_QWORD *)&v79 & 0xFFFFFF02FFFFFF02)), (int8x8_t)v82, (int8x8_t)vneg_f32(v82)));
  v85 = (float32x2_t)vbsl_s8((int8x8_t)vceqz_s32((int32x2_t)(*(_QWORD *)&v79 & 0xFFFFFF04FFFFFF04)), (int8x8_t)v83, (int8x8_t)vneg_f32(v83));
  v86 = vadd_f32(v85, v84);
  v85.i8[0] = v48[v45];
  v85.i8[4] = perm_0[v27 + v45];
  v87 = vand_s8((int8x8_t)v85, (int8x8_t)0xFF000000FFLL);
  v88 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x1800000018, (uint32x2_t)(*(_QWORD *)&v87 & 0xFFFFFF1FFFFFFF1FLL)), v22, v80);
  v89 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x1000000010, (uint32x2_t)(*(_QWORD *)&v87 & 0xFFFFFF1FFFFFFF1FLL)), v80, v52);
  v90 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x800000008, (uint32x2_t)(*(_QWORD *)&v87 & 0xFFFFFF1FFFFFFF1FLL)), v52, v62);
  v91 = vsub_f32(vadd_f32((float32x2_t)vbsl_s8((int8x8_t)vceqz_s32((int32x2_t)(*(_QWORD *)&v87 & 0xFFFFFF04FFFFFF04)), (int8x8_t)v90, (int8x8_t)vneg_f32(v90)), vadd_f32((float32x2_t)vbsl_s8((int8x8_t)vceqz_s32((int32x2_t)(*(_QWORD *)&v87 & 0xFFFFFF01FFFFFF01)), (int8x8_t)v88, (int8x8_t)vneg_f32(v88)), (float32x2_t)vbsl_s8((int8x8_t)vceqz_s32((int32x2_t)(*(_QWORD *)&v87 & 0xFFFFFF02FFFFFF02)), (int8x8_t)v89, (int8x8_t)vneg_f32(v89)))), v86);
  v92 = vmla_n_f32(v86, v91, v30);
  v91.i8[0] = v48[v46];
  v91.i8[4] = perm_0[v27 + v46];
  v93 = vand_s8((int8x8_t)v91, (int8x8_t)0xFF000000FFLL);
  v94 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x1800000018, (uint32x2_t)(*(_QWORD *)&v93 & 0xFFFFFF1FFFFFFF1FLL)), v22, v80);
  v95 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x1000000010, (uint32x2_t)(*(_QWORD *)&v93 & 0xFFFFFF1FFFFFFF1FLL)), v80, v68);
  v96 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x800000008, (uint32x2_t)(*(_QWORD *)&v93 & 0xFFFFFF1FFFFFFF1FLL)), v68, v54);
  v97 = vadd_f32((float32x2_t)vbsl_s8((int8x8_t)vceqz_s32((int32x2_t)(*(_QWORD *)&v93 & 0xFFFFFF01FFFFFF01)), (int8x8_t)v94, (int8x8_t)vneg_f32(v94)), (float32x2_t)vbsl_s8((int8x8_t)vceqz_s32((int32x2_t)(*(_QWORD *)&v93 & 0xFFFFFF02FFFFFF02)), (int8x8_t)v95, (int8x8_t)vneg_f32(v95)));
  v98 = (int8x8_t)vceqz_s32((int32x2_t)(*(_QWORD *)&v93 & 0xFFFFFF04FFFFFF04));
  v99 = vadd_f32((float32x2_t)vbsl_s8(v98, (int8x8_t)v96, (int8x8_t)vneg_f32(v96)), v97);
  v98.i8[0] = v48[v47];
  v98.i8[4] = perm_0[v27 + v47];
  v100 = vand_s8(v98, (int8x8_t)0xFF000000FFLL);
  v101 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x1800000018, (uint32x2_t)(*(_QWORD *)&v100 & 0xFFFFFF1FFFFFFF1FLL)), v22, v80);
  v102 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x1000000010, (uint32x2_t)(*(_QWORD *)&v100 & 0xFFFFFF1FFFFFFF1FLL)), v80, v68);
  v103 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x800000008, (uint32x2_t)(*(_QWORD *)&v100 & 0xFFFFFF1FFFFFFF1FLL)), v68, v62);
  v104 = vmla_n_f32(v78, vsub_f32(vmla_n_f32(v92, vsub_f32(vmla_n_f32(v99, vsub_f32(vadd_f32((float32x2_t)vbsl_s8((int8x8_t)vceqz_s32((int32x2_t)(*(_QWORD *)&v100 & 0xFFFFFF04FFFFFF04)), (int8x8_t)v103, (int8x8_t)vneg_f32(v103)), vadd_f32((float32x2_t)vbsl_s8((int8x8_t)vceqz_s32((int32x2_t)(*(_QWORD *)&v100 & 0xFFFFFF01FFFFFF01)), (int8x8_t)v101, (int8x8_t)vneg_f32(v101)), (float32x2_t)vbsl_s8(
                                        (int8x8_t)vceqz_s32((int32x2_t)(*(_QWORD *)&v100 & 0xFFFFFF02FFFFFF02)),
                                        (int8x8_t)v102,
                                        (int8x8_t)vneg_f32(v102)))),
                     v99),
                   v30),
                 v92),
               v31),
             v78),
           v32);
  return (float)(v104.f32[1] + (float)(v33 * (float)(v104.f32[0] - v104.f32[1]))) * 0.87;
}

void sub_208FC1B68(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_208FC2154(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

uint64_t stringToShape(NSString *a1)
{
  NSString *v1;
  NSString *v2;
  uint64_t v3;

  v1 = a1;
  v2 = v1;
  if (!v1)
    goto LABEL_5;
  if (-[NSString isEqualToString:](v1, "isEqualToString:", CFSTR("empty")))
  {
    v3 = 0;
    goto LABEL_6;
  }
  if (-[NSString isEqualToString:](v2, "isEqualToString:", CFSTR("infinite")))
  {
LABEL_5:
    v3 = 1;
    goto LABEL_6;
  }
  if (-[NSString isEqualToString:](v2, "isEqualToString:", CFSTR("ellipsoidal")))
  {
    v3 = 2;
  }
  else if (-[NSString isEqualToString:](v2, "isEqualToString:", CFSTR("box")))
  {
    v3 = 3;
  }
  else if (-[NSString isEqualToString:](v2, "isEqualToString:", CFSTR("cgpath")))
  {
    v3 = 4;
  }
  else if (-[NSString isEqualToString:](v2, "isEqualToString:", CFSTR("convexhull")))
  {
    v3 = 5;
  }
  else
  {
    v3 = 1;
  }
LABEL_6:

  return v3;
}

void sub_208FC22DC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_208FC24AC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

void sub_208FC25C8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_208FC26C4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_208FC27E4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_208FC2890(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_208FC2908(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_208FC2974(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<PKCPathHolder>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_24C0E8B30;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<PKCPathHolder>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_24C0E8B30;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x20BD0BA58);
}

void std::__shared_ptr_emplace<PKCPathHolder>::__on_zero_shared(uint64_t a1)
{
  PKCPathHolder::~PKCPathHolder((PKCPathHolder *)(a1 + 24));
}

void PKCPathHolder::~PKCPathHolder(PKCPathHolder *this)
{
  const CGPath *v1;

  v1 = *(const CGPath **)this;
  if (v1)
    CGPathRelease(v1);
}

float b2DistanceJointDef::Initialize(b2DistanceJointDef *this, b2Body *a2, b2Body *a3, const b2Vec2 *a4, const b2Vec2 *a5)
{
  float v5;
  float v6;
  float var1;
  float var0;
  float v9;
  float v10;
  float v11;
  float v12;
  float result;

  this->bodyA = a2;
  this->bodyB = a3;
  v5 = a4->x - a2->var8.var0.x;
  v6 = a4->y - a2->var8.var0.y;
  var0 = a2->var8.var1.var0;
  var1 = a2->var8.var1.var1;
  this->localAnchorA.x = (float)(v6 * var0) + (float)(var1 * v5);
  this->localAnchorA.y = (float)(var1 * v6) - (float)(var0 * v5);
  v9 = a5->x - a3->var8.var0.x;
  v10 = a5->y - a3->var8.var0.y;
  v12 = a3->var8.var1.var0;
  v11 = a3->var8.var1.var1;
  this->localAnchorB.x = (float)(v10 * v12) + (float)(v11 * v9);
  this->localAnchorB.y = (float)(v11 * v10) - (float)(v12 * v9);
  result = sqrtf((float)((float)(a5->y - a4->y) * (float)(a5->y - a4->y))+ (float)((float)(a5->x - a4->x) * (float)(a5->x - a4->x)));
  this->length = result;
  return result;
}

void b2DistanceJoint::b2DistanceJoint(b2DistanceJoint *this, const b2JointDef *a2)
{
  uint64_t v3;

  b2Joint::b2Joint((b2Joint *)this, a2);
  *(_QWORD *)v3 = off_24C0E8240;
  *(_QWORD *)(v3 + 140) = *(_QWORD *)(&a2->var4 + 4);
  *(_QWORD *)(v3 + 148) = *(_QWORD *)(&a2[1].var0 + 1);
  *(_DWORD *)(v3 + 164) = HIDWORD(a2[1].var1);
  *(_QWORD *)(v3 + 128) = a2[1].var2;
  *(_DWORD *)(v3 + 156) = 0;
  *(_DWORD *)(v3 + 160) = 0;
  *(_DWORD *)(v3 + 136) = 0;
}

void b2DistanceJoint::InitVelocityConstraints(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  float v10;
  float v11;
  float v12;
  float v13;
  uint64_t v14;
  uint64_t v15;
  float *v16;
  float *v17;
  float *v18;
  float v19;
  float v20;
  float *v21;
  __float2 v22;
  __float2 v23;
  float v24;
  float v25;
  float v26;
  float v27;
  float v28;
  float v29;
  float v30;
  float v31;
  float v32;
  float v33;
  float v34;
  float v35;
  float v36;
  float v37;
  float v38;
  float v39;
  float v40;
  float v41;
  float v42;
  float v43;
  float v44;
  float v45;
  float v46;
  float v47;
  float v48;
  float v49;
  float v50;
  float v51;
  float v52;
  float v53;
  float v54;
  float v55;
  float v56;
  float v57;
  float *v58;
  float v59;
  float v60;
  float v61;
  float v62;
  float v63;
  float v64;
  float v65;
  float v66;
  float v67;

  v4 = *(_QWORD *)(a1 + 96);
  v5 = *(_QWORD *)(a1 + 104);
  v6 = *(int *)(v4 + 28);
  v7 = *(int *)(v5 + 28);
  *(_DWORD *)(a1 + 168) = v6;
  *(_DWORD *)(a1 + 172) = v7;
  v8 = *(_QWORD *)(v4 + 64);
  *(_QWORD *)(a1 + 200) = v8;
  v9 = *(_QWORD *)(v5 + 64);
  *(_QWORD *)(a1 + 208) = v9;
  v10 = *(float *)(v4 + 212);
  v11 = *(float *)(v5 + 212);
  *(float *)(a1 + 216) = v10;
  *(float *)(a1 + 220) = v11;
  v12 = *(float *)(v4 + 224);
  v13 = *(float *)(v5 + 224);
  *(float *)(a1 + 224) = v12;
  *(float *)(a1 + 228) = v13;
  v14 = *(_QWORD *)(a2 + 24);
  v15 = *(_QWORD *)(a2 + 32);
  v16 = (float *)(v14 + 16 * v6);
  v60 = *v16;
  v61 = v16[1];
  v17 = (float *)(v15 + 16 * v6);
  v67 = v17[1];
  v65 = *v17;
  v66 = v17[3];
  v18 = (float *)(v14 + 16 * v7);
  v19 = v18[1];
  v59 = *v18;
  v20 = v18[3];
  v21 = (float *)(v15 + 16 * v7);
  v63 = v21[1];
  v64 = *v21;
  v62 = v21[3];
  v22 = __sincosf_stret(v16[3]);
  v23 = __sincosf_stret(v20);
  v24 = *(float *)(a1 + 140) - *(float *)&v8;
  v25 = *(float *)(a1 + 144) - *((float *)&v8 + 1);
  v26 = (float)(v22.__cosval * v24) - (float)(v22.__sinval * v25);
  v27 = (float)(v22.__cosval * v25) + (float)(v22.__sinval * v24);
  *(float *)(a1 + 184) = v26;
  *(float *)(a1 + 188) = v27;
  v28 = *(float *)(a1 + 148) - *(float *)&v9;
  v29 = *(float *)(a1 + 152) - *((float *)&v9 + 1);
  v30 = (float)(v23.__cosval * v28) - (float)(v23.__sinval * v29);
  v31 = (float)(v23.__cosval * v29) + (float)(v23.__sinval * v28);
  *(float *)(a1 + 192) = v30;
  *(float *)(a1 + 196) = v31;
  v32 = (float)((float)(v59 + v30) - v60) - v26;
  v33 = (float)((float)(v19 + v31) - v61) - v27;
  v34 = sqrtf((float)(v33 * v33) + (float)(v32 * v32));
  v35 = 0.0;
  v36 = 0.0;
  v37 = 0.0;
  if (v34 > 0.0045)
  {
    v36 = v32 * (float)(1.0 / v34);
    v37 = v33 * (float)(1.0 / v34);
  }
  *(float *)(a1 + 176) = v36;
  *(float *)(a1 + 180) = v37;
  v38 = (float)(v11
              + (float)(v10
                      + (float)((float)(v12 * (float)((float)(v26 * v37) - (float)(v27 * v36)))
                              * (float)((float)(v26 * v37) - (float)(v27 * v36)))))
      + (float)((float)(v13 * (float)((float)(v30 * v37) - (float)(v31 * v36)))
              * (float)((float)(v30 * v37) - (float)(v31 * v36)));
  v39 = 1.0 / v38;
  if (v38 == 0.0)
    v39 = 0.0;
  *(float *)(a1 + 232) = v39;
  v40 = *(float *)(a1 + 128);
  v41 = 0.0;
  if (v40 > 0.0)
  {
    v42 = v34 - *(float *)(a1 + 164);
    v43 = (float)(v40 * 6.2832) * (float)((float)(v39 + v39) * *(float *)(a1 + 132));
    v44 = (float)(v40 * 6.2832) * (float)((float)(v40 * 6.2832) * v39);
    v45 = *(float *)a2 * (float)(v43 + (float)(*(float *)a2 * v44));
    if (v45 == 0.0)
      v35 = 0.0;
    else
      v35 = 1.0 / v45;
    v41 = (float)(v44 * (float)(v42 * *(float *)a2)) * v35;
    v46 = v38 + v35;
    v47 = 1.0 / (float)(v38 + v35);
    if (v46 == 0.0)
      v48 = 0.0;
    else
      v48 = v47;
    *(float *)(a1 + 232) = v48;
  }
  *(float *)(a1 + 156) = v35;
  *(float *)(a1 + 136) = v41;
  if (*(_BYTE *)(a2 + 20))
  {
    v49 = *(float *)(a2 + 8) * *(float *)(a1 + 160);
    *(float *)(a1 + 160) = v49;
    v50 = v36 * v49;
    v51 = v37 * v49;
    v52 = v65 - (float)(v10 * v50);
    v53 = v67 - (float)(v10 * v51);
    v54 = v66 - (float)(v12 * (float)((float)(v50 * (float)-v27) + (float)(v26 * v51)));
    v55 = v64 + (float)(v11 * v50);
    v56 = v63 + (float)(v11 * v51);
    v57 = v62 + (float)(v13 * (float)((float)(v50 * (float)-v31) + (float)(v30 * v51)));
  }
  else
  {
    *(_DWORD *)(a1 + 160) = 0;
    v54 = v66;
    v53 = v67;
    v55 = v64;
    v52 = v65;
    v57 = v62;
    v56 = v63;
  }
  *v17 = v52;
  v17[1] = v53;
  v17[3] = v54;
  v58 = (float *)(*(_QWORD *)(a2 + 32) + 16 * *(int *)(a1 + 172));
  *v58 = v55;
  v58[1] = v56;
  v58[3] = v57;
}

float b2DistanceJoint::SolveVelocityConstraints(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  float *v3;
  float v4;
  float v5;
  float v6;
  float *v7;
  float v8;
  float v9;
  float v10;
  float v11;
  float v12;
  float v13;
  float v14;
  float v15;
  float v16;
  float v17;
  float v18;
  float v19;
  float v20;
  float v21;
  float v22;
  float result;
  float v24;
  float v25;
  float *v26;

  v2 = *(_QWORD *)(a2 + 32);
  v3 = (float *)(v2 + 16 * *(int *)(a1 + 168));
  v4 = *v3;
  v5 = v3[1];
  v6 = v3[3];
  v7 = (float *)(v2 + 16 * *(int *)(a1 + 172));
  v8 = *v7;
  v9 = v7[1];
  v10 = v7[3];
  v12 = *(float *)(a1 + 184);
  v11 = *(float *)(a1 + 188);
  v14 = *(float *)(a1 + 192);
  v13 = *(float *)(a1 + 196);
  v15 = *(float *)(a1 + 176);
  v16 = *(float *)(a1 + 180);
  v17 = *(float *)(a1 + 160);
  v18 = -(float)(*(float *)(a1 + 232)
               * (float)((float)(*(float *)(a1 + 136)
                               + (float)((float)(v16
                                               * (float)((float)(v9 + (float)(v10 * v14))
                                                       - (float)(v5 + (float)(v6 * v12))))
                                       + (float)(v15
                                               * (float)((float)(*v7 - (float)(v10 * v13))
                                                       - (float)(*v3 - (float)(v6 * v11))))))
                       + (float)(*(float *)(a1 + 156) * v17)));
  *(float *)(a1 + 160) = v17
                       - (float)(*(float *)(a1 + 232)
                               * (float)((float)(*(float *)(a1 + 136)
                                               + (float)((float)(v16
                                                               * (float)((float)(v9 + (float)(v10 * v14))
                                                                       - (float)(v5 + (float)(v6 * v12))))
                                                       + (float)(v15
                                                               * (float)((float)(*v7 - (float)(v10 * v13))
                                                                       - (float)(*v3 - (float)(v6 * v11))))))
                                       + (float)(*(float *)(a1 + 156) * v17)));
  v19 = v15 * v18;
  v20 = v16 * v18;
  v21 = *(float *)(a1 + 216);
  v22 = *(float *)(a1 + 220);
  result = v4 - (float)(v21 * v19);
  v24 = v6 - (float)(*(float *)(a1 + 224) * (float)((float)(v12 * v20) - (float)(v11 * v19)));
  v25 = v10 + (float)(*(float *)(a1 + 228) * (float)((float)(v14 * v20) - (float)(v13 * v19)));
  *v3 = result;
  v3[1] = v5 - (float)(v21 * v20);
  v3[3] = v24;
  v26 = (float *)(*(_QWORD *)(a2 + 32) + 16 * *(int *)(a1 + 172));
  *v26 = v8 + (float)(v19 * v22);
  v26[1] = v9 + (float)(v20 * v22);
  v26[3] = v25;
  return result;
}

BOOL b2DistanceJoint::SolvePositionConstraints(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  float *v6;
  float v7;
  float v8;
  float v9;
  float *v10;
  float v11;
  float v12;
  float v13;
  __float2 v14;
  __float2 v15;
  float v16;
  float v17;
  float v18;
  float v19;
  float v20;
  float v21;
  float v22;
  float v23;
  float v24;
  float v25;
  float v26;
  float v27;
  float v28;
  float v29;
  float v30;
  float v31;
  float v32;
  float v33;
  float v34;
  float *v35;
  float v36;

  if (*(float *)(a1 + 128) > 0.0)
    return 1;
  v5 = *(_QWORD *)(a2 + 24);
  v6 = (float *)(v5 + 16 * *(int *)(a1 + 168));
  v8 = *v6;
  v7 = v6[1];
  v9 = v6[3];
  v10 = (float *)(v5 + 16 * *(int *)(a1 + 172));
  v11 = *v10;
  v12 = v10[1];
  v13 = v10[3];
  v14 = __sincosf_stret(v9);
  v15 = __sincosf_stret(v13);
  v16 = *(float *)(a1 + 140) - *(float *)(a1 + 200);
  v17 = *(float *)(a1 + 144) - *(float *)(a1 + 204);
  v18 = (float)(v14.__cosval * v16) - (float)(v14.__sinval * v17);
  v19 = (float)(v14.__cosval * v17) + (float)(v14.__sinval * v16);
  v20 = *(float *)(a1 + 148) - *(float *)(a1 + 208);
  v21 = *(float *)(a1 + 152) - *(float *)(a1 + 212);
  v22 = (float)(v15.__cosval * v20) - (float)(v15.__sinval * v21);
  v23 = (float)(v15.__cosval * v21) + (float)(v15.__sinval * v20);
  v24 = (float)((float)(v11 + v22) - v8) - v18;
  v25 = (float)((float)(v12 + v23) - v7) - v19;
  v26 = sqrtf((float)(v25 * v25) + (float)(v24 * v24));
  if (v26 >= 0.00000011921)
  {
    v24 = v24 * (float)(1.0 / v26);
    v25 = v25 * (float)(1.0 / v26);
  }
  else
  {
    v26 = 0.0;
  }
  v27 = fminf(v26 - *(float *)(a1 + 164), 0.2);
  if (v27 < -0.2)
    v27 = -0.2;
  v28 = *(float *)(a1 + 228);
  v29 = -(float)(*(float *)(a1 + 232) * v27);
  v30 = v24 * v29;
  v31 = v25 * v29;
  v32 = *(float *)(a1 + 216);
  v33 = *(float *)(a1 + 220);
  v34 = v9 - (float)(*(float *)(a1 + 224) * (float)((float)(v18 * v31) - (float)(v19 * v30)));
  *v6 = v8 - (float)(v32 * v30);
  v6[1] = v7 - (float)(v32 * v31);
  v6[3] = v34;
  v35 = (float *)(*(_QWORD *)(a2 + 24) + 16 * *(int *)(a1 + 172));
  *v35 = v11 + (float)(v33 * v30);
  v35[1] = v12 + (float)(v33 * v31);
  v35[3] = v13 + (float)(v28 * (float)((float)(v22 * v31) - (float)(v23 * v30)));
  v36 = -v27;
  if (v27 > 0.0)
    v36 = v27;
  return v36 < 0.0045;
}

float b2DistanceJoint::GetAnchorA(b2DistanceJoint *this)
{
  return this->var6->var8.var0.x
       + (float)((float)(this->var6->var8.var1.var1 * this->var14.x)
               - (float)(this->var6->var8.var1.var0 * this->var14.y));
}

float b2DistanceJoint::GetAnchorB(b2DistanceJoint *this)
{
  return this->var7->var8.var0.x
       + (float)((float)(this->var7->var8.var1.var1 * this->var15.x)
               - (float)(this->var7->var8.var1.var0 * this->var15.y));
}

float b2DistanceJoint::GetReactionForce(b2DistanceJoint *this, float a2)
{
  return this->var21.x * (float)(this->var17 * a2);
}

float b2DistanceJoint::GetReactionTorque(b2DistanceJoint *this, float a2)
{
  return 0.0;
}

void b2DistanceJoint::~b2DistanceJoint(b2DistanceJoint *this)
{
  JUMPOUT(0x20BD0BA58);
}

float b2FrictionJointDef::Initialize(b2FrictionJointDef *this, b2Body *a2, b2Body *a3, const b2Vec2 *a4)
{
  float v4;
  float v5;
  float var1;
  float var0;
  float v8;
  float v9;
  float v10;
  float v11;
  float v12;
  float result;

  *((_QWORD *)this + 2) = a2;
  *((_QWORD *)this + 3) = a3;
  v4 = a4->x - a2->var8.var0.x;
  v5 = a4->y - a2->var8.var0.y;
  var0 = a2->var8.var1.var0;
  var1 = a2->var8.var1.var1;
  *((float *)this + 9) = (float)(v5 * var0) + (float)(var1 * v4);
  *((float *)this + 10) = (float)(var1 * v5) - (float)(var0 * v4);
  v8 = a4->x - a3->var8.var0.x;
  v9 = a4->y - a3->var8.var0.y;
  v11 = a3->var8.var1.var0;
  v10 = a3->var8.var1.var1;
  v12 = (float)(v9 * v11) + (float)(v10 * v8);
  result = (float)(v10 * v9) - (float)(v11 * v8);
  *((float *)this + 11) = v12;
  *((float *)this + 12) = result;
  return result;
}

void b2FrictionJoint::b2FrictionJoint(b2FrictionJoint *this, const b2FrictionJointDef *a2)
{
  uint64_t v3;

  b2Joint::b2Joint((b2Joint *)this, (const b2JointDef *)a2);
  *(_QWORD *)v3 = off_24C0E8298;
  *(_QWORD *)(v3 + 128) = *(_QWORD *)((char *)a2 + 36);
  *(_QWORD *)(v3 + 136) = *(_QWORD *)((char *)a2 + 44);
  *(_QWORD *)(v3 + 144) = 0;
  *(_DWORD *)(v3 + 152) = 0;
  *(_QWORD *)(v3 + 156) = *(_QWORD *)((char *)a2 + 52);
}

void b2FrictionJoint::InitVelocityConstraints(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  float v10;
  float v11;
  uint64_t v12;
  uint64_t v13;
  float v14;
  float32x2_t *v15;
  float32x2_t v16;
  float v17;
  float v18;
  float32x2_t *v19;
  float v20;
  __float2 v21;
  __float2 v22;
  float v23;
  float v24;
  float v26;
  float v27;
  float v28;
  float v30;
  float v31;
  float v32;
  float v33;
  float v34;
  float v35;
  float v36;
  float v37;
  float v38;
  float32x2_t v46;
  uint64_t v47;
  float v48;
  float v49;
  float32x2_t v50;

  v4 = *(_QWORD *)(a1 + 96);
  v5 = *(_QWORD *)(a1 + 104);
  v6 = *(int *)(v4 + 28);
  v7 = *(int *)(v5 + 28);
  *(_DWORD *)(a1 + 164) = v6;
  *(_DWORD *)(a1 + 168) = v7;
  v8 = *(_QWORD *)(v4 + 64);
  *(_QWORD *)(a1 + 188) = v8;
  v9 = *(_QWORD *)(v5 + 64);
  *(_QWORD *)(a1 + 196) = v9;
  v48 = *(float *)(v5 + 212);
  v49 = *(float *)(v4 + 212);
  *(float *)(a1 + 204) = v49;
  *(float *)(a1 + 208) = v48;
  v10 = *(float *)(v4 + 224);
  v11 = *(float *)(v5 + 224);
  *(float *)(a1 + 212) = v10;
  *(float *)(a1 + 216) = v11;
  v12 = *(_QWORD *)(a2 + 24);
  v13 = *(_QWORD *)(a2 + 32);
  v14 = *(float *)(v12 + 16 * v6 + 12);
  v15 = (float32x2_t *)(v13 + 16 * v6);
  v16 = *v15;
  v17 = v15[1].f32[1];
  v18 = *(float *)(v12 + 16 * v7 + 12);
  v19 = (float32x2_t *)(v13 + 16 * v7);
  v50 = *v19;
  v20 = v19[1].f32[1];
  v21 = __sincosf_stret(v14);
  v22 = __sincosf_stret(v18);
  v23 = *(float *)(a1 + 128) - *(float *)&v8;
  v24 = *(float *)(a1 + 132) - *((float *)&v8 + 1);
  _S2 = (float)(v21.__cosval * v23) - (float)(v21.__sinval * v24);
  v26 = (float)(v21.__cosval * v24) + (float)(v21.__sinval * v23);
  *(float *)(a1 + 172) = _S2;
  *(float *)(a1 + 176) = v26;
  v27 = *(float *)(a1 + 136) - *(float *)&v9;
  v28 = *(float *)(a1 + 140) - *((float *)&v9 + 1);
  _S3 = (float)(v22.__cosval * v27) - (float)(v22.__sinval * v28);
  v30 = (float)(v22.__cosval * v28) + (float)(v22.__sinval * v27);
  *(float *)(a1 + 180) = _S3;
  *(float *)(a1 + 184) = v30;
  v31 = (float)((float)(v49 + v48) + (float)((float)(v10 * v26) * v26)) + (float)((float)(v11 * v30) * v30);
  v32 = (float)(v30 * (float)-(float)(v11 * _S3)) + (float)((float)-(float)(v10 * _S2) * v26);
  v33 = (float)((float)(v49 + v48) + (float)((float)(v10 * _S2) * _S2)) + (float)((float)(v11 * _S3) * _S3);
  v34 = (float)(v31 * v33) - (float)(v32 * v32);
  if (v34 != 0.0)
    v34 = 1.0 / v34;
  v35 = -(float)(v34 * v32);
  *(float *)(a1 + 220) = v33 * v34;
  *(float *)(a1 + 224) = v35;
  *(float *)(a1 + 228) = v35;
  *(float *)(a1 + 232) = v31 * v34;
  v36 = v10 + v11;
  if ((float)(v10 + v11) > 0.0)
    v36 = 1.0 / (float)(v10 + v11);
  *(float *)(a1 + 236) = v36;
  if (*(_BYTE *)(a2 + 20))
  {
    v37 = *(float *)(a2 + 8);
    v38 = v37 * *(float *)(a1 + 152);
    *(float *)(a1 + 152) = v38;
    _D5 = vmul_n_f32(*(float32x2_t *)(a1 + 144), v37);
    *(float32x2_t *)(a1 + 144) = _D5;
    v16 = vsub_f32(v16, vmul_n_f32(_D5, v49));
    __asm { FMLA            S4, S2, V5.S[1] }
    v17 = v17 + (float)((float)-v10 * (float)(v38 + _S4));
    __asm { FMLA            S0, S3, V5.S[1] }
    v20 = v20 + (float)(v11 * (float)(v38 + _S0));
    v46 = vadd_f32(v50, vmul_n_f32(_D5, v48));
  }
  else
  {
    *(_QWORD *)(a1 + 144) = 0;
    *(_DWORD *)(a1 + 152) = 0;
    v46 = v50;
  }
  *v15 = v16;
  v15[1].f32[1] = v17;
  v47 = *(_QWORD *)(a2 + 32) + 16 * *(int *)(a1 + 168);
  *(float32x2_t *)v47 = v46;
  *(float *)(v47 + 12) = v20;
}

float b2FrictionJoint::SolveVelocityConstraints(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  float *v3;
  float v4;
  float v5;
  float v6;
  float *v7;
  float v8;
  float v9;
  float v10;
  float v11;
  float v12;
  float v13;
  float v14;
  float v15;
  float v16;
  float v17;
  float v18;
  float v19;
  float v20;
  float v21;
  float v22;
  float v23;
  float v24;
  float v25;
  float v26;
  float v27;
  float v28;
  float v29;
  float v30;
  float v31;
  float v32;
  float v33;
  float v34;
  float v35;
  float v36;
  float v37;
  float v38;
  float v39;
  float result;
  float *v41;

  v2 = *(_QWORD *)(a2 + 32);
  v3 = (float *)(v2 + 16 * *(int *)(a1 + 164));
  v5 = *v3;
  v4 = v3[1];
  v6 = v3[3];
  v7 = (float *)(v2 + 16 * *(int *)(a1 + 168));
  v9 = *v7;
  v8 = v7[1];
  v10 = v7[3];
  v12 = *(float *)(a1 + 212);
  v11 = *(float *)(a1 + 216);
  v13 = *(float *)a2;
  v14 = *(float *)(a1 + 156);
  v15 = *(float *)a2 * *(float *)(a1 + 160);
  v16 = *(float *)(a1 + 152);
  v17 = v16 - (float)((float)(v10 - v6) * *(float *)(a1 + 236));
  if (v17 >= v15)
    v17 = *(float *)a2 * *(float *)(a1 + 160);
  if (v17 < (float)-v15)
    v17 = -v15;
  *(float *)(a1 + 152) = v17;
  v18 = v17 - v16;
  v19 = v6 - (float)(v12 * v18);
  v20 = v10 + (float)(v11 * v18);
  v21 = *(float *)(a1 + 180);
  v22 = *(float *)(a1 + 184);
  v23 = *(float *)(a1 + 172);
  v24 = *(float *)(a1 + 176);
  v25 = (float)(v24 * v19) + (float)((float)(v9 - (float)(v22 * v20)) - v5);
  v26 = (float)((float)(v8 + (float)(v21 * v20)) - v4) - (float)(v23 * v19);
  v27 = (float)(*(float *)(a1 + 228) * v26) + (float)(*(float *)(a1 + 220) * v25);
  v29 = *(float *)(a1 + 204);
  v28 = *(float *)(a1 + 208);
  v30 = -v12;
  v31 = (float)(*(float *)(a1 + 232) * v26) + (float)(*(float *)(a1 + 224) * v25);
  v32 = *(float *)(a1 + 144);
  v33 = *(float *)(a1 + 148);
  v34 = v32 - v27;
  v35 = v33 - v31;
  *(float *)(a1 + 144) = v32 - v27;
  *(float *)(a1 + 148) = v35;
  v36 = v13 * v14;
  v37 = (float)(v35 * v35) + (float)(v34 * v34);
  if (v37 > (float)(v36 * v36))
  {
    v38 = sqrtf(v37);
    if (v38 >= 0.00000011921)
    {
      v39 = 1.0 / v38;
      v34 = v34 * v39;
      v35 = v35 * v39;
    }
    v34 = v36 * v34;
    v35 = v36 * v35;
    *(float *)(a1 + 144) = v34;
    *(float *)(a1 + 148) = v35;
  }
  result = v8 + (float)(v28 * (float)(v35 - v33));
  *v3 = v5 - (float)(v29 * (float)(v34 - v32));
  v3[1] = v4 - (float)(v29 * (float)(v35 - v33));
  v3[3] = v19 + (float)(v30 * (float)((float)(v23 * (float)(v35 - v33)) - (float)(v24 * (float)(v34 - v32))));
  v41 = (float *)(*(_QWORD *)(a2 + 32) + 16 * *(int *)(a1 + 168));
  *v41 = v9 + (float)(v28 * (float)(v34 - v32));
  v41[1] = result;
  v41[3] = v20 + (float)(v11 * (float)((float)(v21 * (float)(v35 - v33)) - (float)(v22 * (float)(v34 - v32))));
  return result;
}

uint64_t b2FrictionJoint::SolvePositionConstraints()
{
  return 1;
}

float b2FrictionJoint::GetAnchorA(b2FrictionJoint *this)
{
  return *(float *)(*((_QWORD *)this + 12) + 32)
       + (float)((float)(*(float *)(*((_QWORD *)this + 12) + 44) * *((float *)this + 32))
               - (float)(*(float *)(*((_QWORD *)this + 12) + 40) * *((float *)this + 33)));
}

float b2FrictionJoint::GetAnchorB(b2FrictionJoint *this)
{
  return *(float *)(*((_QWORD *)this + 13) + 32)
       + (float)((float)(*(float *)(*((_QWORD *)this + 13) + 44) * *((float *)this + 34))
               - (float)(*(float *)(*((_QWORD *)this + 13) + 40) * *((float *)this + 35)));
}

float b2FrictionJoint::GetReactionForce(b2FrictionJoint *this, float a2)
{
  return *((float *)this + 36) * a2;
}

float b2FrictionJoint::GetReactionTorque(b2FrictionJoint *this, float a2)
{
  return *((float *)this + 38) * a2;
}

uint64_t b2FrictionJoint::SetMaxForce(uint64_t this, float a2)
{
  BOOL v2;
  BOOL v3;

  if (a2 >= 0.0)
  {
    v2 = a2 == -INFINITY;
    v3 = a2 < -INFINITY;
  }
  else
  {
    v2 = 1;
    v3 = 0;
  }
  if (v3 || v2 || a2 >= INFINITY)
    b2FrictionJoint::SetMaxForce();
  *(float *)(this + 156) = a2;
  return this;
}

float b2FrictionJoint::GetMaxForce(b2FrictionJoint *this)
{
  return *((float *)this + 39);
}

uint64_t b2FrictionJoint::SetMaxTorque(uint64_t this, float a2)
{
  BOOL v2;
  BOOL v3;

  if (a2 >= 0.0)
  {
    v2 = a2 == -INFINITY;
    v3 = a2 < -INFINITY;
  }
  else
  {
    v2 = 1;
    v3 = 0;
  }
  if (v3 || v2 || a2 >= INFINITY)
    b2FrictionJoint::SetMaxTorque();
  *(float *)(this + 160) = a2;
  return this;
}

float b2FrictionJoint::GetMaxTorque(b2FrictionJoint *this)
{
  return *((float *)this + 40);
}

void b2FrictionJoint::~b2FrictionJoint(b2FrictionJoint *this)
{
  JUMPOUT(0x20BD0BA58);
}

float b2GearJoint::b2GearJoint(b2Joint *a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  int v5;
  int v6;
  float *v7;
  float *v8;
  float v9;
  float v10;
  float v11;
  float v12;
  float v13;
  float v14;
  float v15;
  float v16;
  float v17;
  float v18;
  float v19;
  float v20;
  unint64_t v21;
  unint64_t v22;
  float v23;
  uint64_t v24;
  uint64_t v25;
  float v26;
  float v27;
  uint64_t v28;
  float *v29;
  float *v30;
  float v31;
  float v32;
  float v33;
  float v34;
  float v35;
  float v36;
  float v37;
  float v38;
  float v39;
  float v40;
  float v41;
  float v42;
  unint64_t v43;
  unint64_t v44;
  float v45;
  uint64_t v46;
  uint64_t v47;
  float v48;
  float v49;
  float v50;
  float result;

  b2Joint::b2Joint(a1, (const b2JointDef *)a2);
  *(_QWORD *)v3 = off_24C0E7D20;
  v4 = *(_QWORD *)(a2 + 40);
  v5 = *(_DWORD *)(v4 + 8);
  v6 = *(_DWORD *)(*(_QWORD *)(a2 + 48) + 8);
  *(_DWORD *)(v3 + 128) = v5;
  *(_DWORD *)(v3 + 132) = v6;
  if ((v5 - 1) >= 2)
    b2GearJoint::b2GearJoint();
  if ((v6 - 1) >= 2)
    b2GearJoint::b2GearJoint();
  v7 = *(float **)(v4 + 96);
  v8 = *(float **)(v4 + 104);
  *(_QWORD *)(v3 + 136) = v7;
  *(_QWORD *)(v3 + 96) = v8;
  if (v5 == 1)
  {
    v9 = v8[27];
    v10 = v7[27];
    *(_QWORD *)(v3 + 168) = *(_QWORD *)(v4 + 128);
    *(_QWORD *)(v3 + 152) = *(_QWORD *)(v4 + 136);
    v11 = *(float *)(v4 + 176);
    *(float *)(v3 + 200) = v11;
    *(_QWORD *)(v3 + 184) = 0;
    v12 = (float)(v9 - v10) - v11;
  }
  else
  {
    v14 = v7[10];
    v13 = v7[11];
    v16 = v7[8];
    v15 = v7[9];
    v18 = v8[10];
    v17 = v8[11];
    v20 = v8[8];
    v19 = v8[9];
    v21 = *(_QWORD *)(v4 + 128);
    *(_QWORD *)(v3 + 168) = v21;
    v22 = HIDWORD(v21);
    v23 = *(float *)&v21;
    v24 = *(_QWORD *)(v4 + 136);
    *(_QWORD *)(v3 + 152) = v24;
    *(_DWORD *)(v3 + 200) = *(_DWORD *)(v4 + 160);
    v25 = *(_QWORD *)(v4 + 144);
    *(_QWORD *)(v3 + 184) = v25;
    v26 = (float)(v20 - v16) + (float)((float)(v17 * *(float *)&v24) - (float)(v18 * *((float *)&v24 + 1)));
    v27 = (float)(v19 - v15) + (float)((float)(v17 * *((float *)&v24 + 1)) + (float)(v18 * *(float *)&v24));
    v12 = (float)((float)((float)((float)(v13 * v27) - (float)(v14 * v26)) - *(float *)&v22) * *((float *)&v25 + 1))
        + (float)((float)((float)((float)(v14 * v27) + (float)(v13 * v26)) - v23) * *(float *)&v25);
  }
  v28 = *(_QWORD *)(a2 + 48);
  v29 = *(float **)(v28 + 96);
  v30 = *(float **)(v28 + 104);
  *(_QWORD *)(v3 + 144) = v29;
  *(_QWORD *)(v3 + 104) = v30;
  if (v6 == 1)
  {
    v31 = v30[27];
    v32 = v29[27];
    *(_QWORD *)(v3 + 176) = *(_QWORD *)(v28 + 128);
    *(_QWORD *)(v3 + 160) = *(_QWORD *)(v28 + 136);
    v33 = *(float *)(v28 + 176);
    *(float *)(v3 + 204) = v33;
    *(_QWORD *)(v3 + 192) = 0;
    v34 = (float)(v31 - v32) - v33;
  }
  else
  {
    v36 = v29[10];
    v35 = v29[11];
    v38 = v29[8];
    v37 = v29[9];
    v40 = v30[10];
    v39 = v30[11];
    v42 = v30[8];
    v41 = v30[9];
    v43 = *(_QWORD *)(v28 + 128);
    *(_QWORD *)(v3 + 176) = v43;
    v44 = HIDWORD(v43);
    v45 = *(float *)&v43;
    v46 = *(_QWORD *)(v28 + 136);
    *(_QWORD *)(v3 + 160) = v46;
    *(_DWORD *)(v3 + 204) = *(_DWORD *)(v28 + 160);
    v47 = *(_QWORD *)(v28 + 144);
    *(_QWORD *)(v3 + 192) = v47;
    v48 = (float)(v42 - v38) + (float)((float)(v39 * *(float *)&v46) - (float)(v40 * *((float *)&v46 + 1)));
    v49 = (float)(v41 - v37) + (float)((float)(v39 * *((float *)&v46 + 1)) + (float)(v40 * *(float *)&v46));
    v34 = (float)((float)((float)((float)(v35 * v49) - (float)(v36 * v48)) - *(float *)&v44) * *((float *)&v47 + 1))
        + (float)((float)((float)((float)(v36 * v49) + (float)(v35 * v48)) - v45) * *(float *)&v47);
  }
  v50 = *(float *)(a2 + 56);
  result = v12 + (float)(v50 * v34);
  *(float *)(v3 + 208) = result;
  *(float *)(v3 + 212) = v50;
  *(_DWORD *)(v3 + 216) = 0;
  return result;
}

float b2GearJoint::InitVelocityConstraints(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  float v14;
  float v15;
  float v16;
  float v17;
  float v18;
  uint64_t v19;
  uint64_t v20;
  float *v21;
  float *v22;
  float v23;
  float v24;
  float *v25;
  float v26;
  float v27;
  float *v28;
  __float2 v29;
  __float2 v30;
  float cosval;
  float v32;
  float v33;
  float v34;
  float v35;
  float v36;
  float v37;
  float v38;
  float v39;
  float v40;
  float v41;
  float v42;
  __float2 v43;
  float v44;
  __float2 v45;
  float v46;
  float v47;
  float v48;
  float v49;
  float v50;
  float v51;
  float v52;
  float v53;
  float v54;
  float v55;
  float v56;
  float v57;
  float v58;
  float v59;
  float v60;
  float v61;
  float v62;
  float v63;
  float v64;
  float v65;
  float v66;
  float v67;
  float v68;
  float v69;
  float v70;
  float v71;
  float v72;
  float v73;
  float v74;
  float v75;
  float v76;
  BOOL v77;
  float v78;
  float v79;
  float *v80;
  float *v81;
  float *v82;
  float result;
  float v84;
  float v85;
  float v86;
  float v87;
  float v88;
  float v89;
  float v90;
  float v91;
  float v92;
  float v93;
  float v94;
  float v95;
  float v96;
  float v97;

  v4 = *(_QWORD *)(a1 + 96);
  v5 = *(_QWORD *)(a1 + 104);
  v6 = *(int *)(v4 + 28);
  v7 = *(int *)(v5 + 28);
  *(_DWORD *)(a1 + 220) = v6;
  *(_DWORD *)(a1 + 224) = v7;
  v8 = *(_QWORD *)(a1 + 136);
  v9 = *(_QWORD *)(a1 + 144);
  v10 = *(int *)(v8 + 28);
  v11 = *(int *)(v9 + 28);
  *(_DWORD *)(a1 + 228) = v10;
  *(_DWORD *)(a1 + 232) = v11;
  *(_QWORD *)(a1 + 236) = *(_QWORD *)(v4 + 64);
  *(_QWORD *)(a1 + 244) = *(_QWORD *)(v5 + 64);
  v12 = *(_QWORD *)(v8 + 64);
  *(_QWORD *)(a1 + 252) = v12;
  v13 = *(_QWORD *)(v9 + 64);
  *(_QWORD *)(a1 + 260) = v13;
  v85 = *(float *)(v4 + 212);
  *(float *)(a1 + 268) = v85;
  v14 = *(float *)(v5 + 212);
  *(float *)(a1 + 272) = v14;
  v15 = *(float *)(v8 + 212);
  *(float *)(a1 + 276) = v15;
  v87 = *(float *)(v9 + 212);
  *(float *)(a1 + 280) = v87;
  v16 = *(float *)(v4 + 224);
  *(float *)(a1 + 284) = v16;
  v17 = *(float *)(v5 + 224);
  *(float *)(a1 + 288) = v17;
  v18 = *(float *)(v8 + 224);
  *(float *)(a1 + 292) = v18;
  v86 = *(float *)(v9 + 224);
  *(float *)(a1 + 296) = v86;
  v20 = *(_QWORD *)(a2 + 24);
  v19 = *(_QWORD *)(a2 + 32);
  v21 = (float *)(v19 + 16 * v6);
  v90 = v21[1];
  v91 = *v21;
  v22 = (float *)(v19 + 16 * v7);
  v24 = *v22;
  v23 = v22[1];
  v88 = v21[3];
  v89 = v22[3];
  v25 = (float *)(v19 + 16 * v10);
  v92 = v23;
  v93 = v25[1];
  v26 = v25[3];
  v27 = *(float *)(v20 + 16 * v11 + 12);
  v28 = (float *)(v19 + 16 * v11);
  v96 = v28[1];
  v97 = *v28;
  v94 = *v25;
  v95 = v28[3];
  v29 = __sincosf_stret(*(float *)(v20 + 16 * v7 + 12));
  v30 = __sincosf_stret(v27);
  cosval = v30.__cosval;
  if (*(_DWORD *)(a1 + 128) == 1)
  {
    v32 = v16 + v18;
    v33 = 1.0;
    v34 = 0.0;
    v35 = 0.0;
    v36 = 1.0;
    v38 = v86;
    v37 = v87;
    v39 = v15;
    v40 = v85;
  }
  else
  {
    v84 = v17;
    v41 = v14;
    v42 = *(float *)(v20 + 16 * v6 + 12);
    v43 = __sincosf_stret(*(float *)(v20 + 16 * v10 + 12));
    v44 = v42;
    v14 = v41;
    v17 = v84;
    v45 = __sincosf_stret(v44);
    cosval = v30.__cosval;
    v46 = *(float *)(a1 + 184);
    v47 = *(float *)(a1 + 188);
    v34 = (float)(v43.__cosval * v46) - (float)(v43.__sinval * v47);
    v35 = (float)(v43.__cosval * v47) + (float)(v43.__sinval * v46);
    v48 = *(float *)(a1 + 168) - *(float *)&v12;
    v49 = *(float *)(a1 + 172) - *((float *)&v12 + 1);
    v50 = (float)(v43.__cosval * v48) - (float)(v43.__sinval * v49);
    v51 = (float)(v43.__cosval * v49) + (float)(v43.__sinval * v48);
    v52 = *(float *)(a1 + 152) - *(float *)(a1 + 236);
    v53 = *(float *)(a1 + 156) - *(float *)(a1 + 240);
    v36 = (float)(v50 * v35) - (float)(v51 * v34);
    v33 = (float)((float)((float)(v45.__cosval * v52) - (float)(v45.__sinval * v53)) * v35)
        - (float)((float)((float)(v45.__cosval * v53) + (float)(v45.__sinval * v52)) * v34);
    v40 = v85;
    v38 = v86;
    v39 = v15;
    v32 = (float)((float)(v85 + v15) + (float)((float)(v18 * v36) * v36)) + (float)((float)(v16 * v33) * v33);
    v37 = v87;
  }
  *(float *)(a1 + 300) = v34;
  *(float *)(a1 + 304) = v35;
  *(float *)(a1 + 316) = v33;
  *(float *)(a1 + 324) = v36;
  v54 = 0.0;
  v55 = v32 + 0.0;
  if (*(_DWORD *)(a1 + 132) == 1)
  {
    *(_DWORD *)(a1 + 308) = 0;
    v56 = *(float *)(a1 + 212);
    v57 = v55 + (float)((float)(v56 * v56) * (float)(v17 + v38));
    v58 = 0.0;
    v59 = v56;
  }
  else
  {
    v60 = *(float *)(a1 + 192);
    v61 = *(float *)(a1 + 196);
    v62 = (float)(cosval * v60) - (float)(v30.__sinval * v61);
    v63 = (float)(cosval * v61) + (float)(v30.__sinval * v60);
    v64 = *(float *)(a1 + 176) - *(float *)&v13;
    v65 = *(float *)(a1 + 180) - *((float *)&v13 + 1);
    v66 = (float)(cosval * v64) - (float)(v30.__sinval * v65);
    v67 = (float)(cosval * v65) + (float)(v30.__sinval * v64);
    v68 = *(float *)(a1 + 160) - *(float *)(a1 + 244);
    v69 = *(float *)(a1 + 164) - *(float *)(a1 + 248);
    v70 = (float)(v29.__cosval * v68) - (float)(v29.__sinval * v69);
    v71 = (float)(v29.__cosval * v69) + (float)(v29.__sinval * v68);
    v72 = *(float *)(a1 + 212);
    v54 = v62 * v72;
    v58 = v63 * v72;
    *(float *)(a1 + 308) = v62 * v72;
    v59 = v72 * (float)((float)(v66 * v63) - (float)(v67 * v62));
    v56 = v72 * (float)((float)(v70 * v63) - (float)(v71 * v62));
    v57 = v55
        + (float)((float)((float)(v59 * (float)(v38 * v59)) + (float)((float)(v72 * v72) * (float)(v14 + v37)))
                + (float)((float)(v17 * v56) * v56));
  }
  v74 = v89;
  v73 = v90;
  v75 = v88;
  *(float *)(a1 + 312) = v58;
  *(float *)(a1 + 320) = v56;
  *(float *)(a1 + 328) = v59;
  v76 = 1.0 / v57;
  v77 = v57 <= 0.0;
  v78 = 0.0;
  if (!v77)
    v78 = v76;
  *(float *)(a1 + 332) = v78;
  if (*(_BYTE *)(a2 + 20))
  {
    v79 = *(float *)(a1 + 216);
    v73 = v90 + (float)((float)(v40 * v79) * v35);
    v75 = v88 + (float)((float)(v16 * v79) * v33);
    v24 = v24 + (float)((float)(v14 * v79) * v54);
    v91 = v91 + (float)(v34 * (float)(v40 * v79));
    v92 = v92 + (float)((float)(v14 * v79) * v58);
    v74 = v89 + (float)((float)(v17 * v79) * v56);
    v93 = v93 - (float)((float)(v39 * v79) * v35);
    v94 = v94 - (float)(v34 * (float)(v39 * v79));
    v26 = v26 + (float)((float)-(float)(v18 * v79) * v36);
    v96 = v96 - (float)((float)(v37 * v79) * v58);
    v97 = v97 - (float)((float)(v37 * v79) * v54);
    v95 = v95 + (float)((float)-(float)(v38 * v79) * v59);
  }
  else
  {
    *(_DWORD *)(a1 + 216) = 0;
  }
  *v21 = v91;
  v21[1] = v73;
  v21[3] = v75;
  v80 = (float *)(*(_QWORD *)(a2 + 32) + 16 * *(int *)(a1 + 224));
  *v80 = v24;
  v80[1] = v92;
  v80[3] = v74;
  v81 = (float *)(*(_QWORD *)(a2 + 32) + 16 * *(int *)(a1 + 228));
  *v81 = v94;
  v81[1] = v93;
  v81[3] = v26;
  v82 = (float *)(*(_QWORD *)(a2 + 32) + 16 * *(int *)(a1 + 232));
  *v82 = v97;
  v82[1] = v96;
  result = v95;
  v82[3] = v95;
  return result;
}

float b2GearJoint::SolveVelocityConstraints(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  float *v3;
  float v4;
  float v5;
  float v6;
  float *v7;
  float v8;
  float v9;
  float v10;
  float *v11;
  float v12;
  float v13;
  float v14;
  float *v15;
  float v16;
  float v17;
  float v18;
  float v19;
  float v20;
  float v21;
  float v22;
  float v23;
  float v24;
  float v25;
  float v26;
  float v27;
  float v28;
  float v29;
  float v30;
  float result;
  float v32;
  float v33;
  float v34;
  float v35;
  float v36;
  float v37;
  float v38;
  float v39;
  float *v40;
  float *v41;
  float *v42;

  v2 = *(_QWORD *)(a2 + 32);
  v3 = (float *)(v2 + 16 * *(int *)(a1 + 224));
  v4 = *v3;
  v5 = v3[1];
  v6 = v3[3];
  v7 = (float *)(v2 + 16 * *(int *)(a1 + 228));
  v8 = *v7;
  v9 = v7[1];
  v10 = v7[3];
  v11 = (float *)(v2 + 16 * *(int *)(a1 + 220));
  v12 = *v11;
  v13 = v11[1];
  v14 = v11[3];
  v15 = (float *)(v2 + 16 * *(int *)(a1 + 232));
  v16 = *v15;
  v17 = v15[1];
  v18 = v15[3];
  v19 = *(float *)(a1 + 300);
  v20 = *(float *)(a1 + 304);
  v21 = *(float *)(a1 + 308);
  v22 = *(float *)(a1 + 312);
  v23 = *(float *)(a1 + 316);
  v24 = *(float *)(a1 + 324);
  v25 = *(float *)(a1 + 320);
  v26 = *(float *)(a1 + 328);
  v27 = -(float)(*(float *)(a1 + 332)
               * (float)((float)((float)((float)((float)(v13 - v9) * v20) + (float)(v19 * (float)(*v11 - *v7)))
                               + (float)((float)((float)(v5 - v17) * v22) + (float)(v21 * (float)(v4 - *v15))))
                       + (float)((float)((float)(v23 * v14) - (float)(v24 * v10))
                               + (float)((float)(v25 * v6) - (float)(v26 * v18)))));
  *(float *)(a1 + 216) = *(float *)(a1 + 216)
                       - (float)(*(float *)(a1 + 332)
                               * (float)((float)((float)((float)((float)(v13 - v9) * v20)
                                                       + (float)(v19 * (float)(*v11 - *v7)))
                                               + (float)((float)((float)(v5 - v17) * v22)
                                                       + (float)(v21 * (float)(v4 - *v15))))
                                       + (float)((float)((float)(v23 * v14) - (float)(v24 * v10))
                                               + (float)((float)(v25 * v6) - (float)(v26 * v18)))));
  v28 = *(float *)(a1 + 268) * v27;
  v29 = v14 + (float)((float)(*(float *)(a1 + 284) * v27) * v23);
  v30 = v27 * *(float *)(a1 + 272);
  result = v4 + (float)(v21 * v30);
  v32 = v5 + (float)(v22 * v30);
  v33 = v6 + (float)((float)(v27 * *(float *)(a1 + 288)) * v25);
  v34 = v27 * *(float *)(a1 + 276);
  v35 = v8 - (float)(v19 * v34);
  v36 = v9 - (float)(v20 * v34);
  v37 = v10 + (float)((float)-(float)(*(float *)(a1 + 292) * v27) * v24);
  v38 = v27 * *(float *)(a1 + 280);
  v39 = v18 + (float)((float)-(float)(*(float *)(a1 + 296) * v27) * v26);
  *v11 = v12 + (float)(v19 * v28);
  v11[1] = v13 + (float)(v20 * v28);
  v11[3] = v29;
  v40 = (float *)(*(_QWORD *)(a2 + 32) + 16 * *(int *)(a1 + 224));
  *v40 = result;
  v40[1] = v32;
  v40[3] = v33;
  v41 = (float *)(*(_QWORD *)(a2 + 32) + 16 * *(int *)(a1 + 228));
  *v41 = v35;
  v41[1] = v36;
  v41[3] = v37;
  v42 = (float *)(*(_QWORD *)(a2 + 32) + 16 * *(int *)(a1 + 232));
  *v42 = v16 - (float)(v21 * v38);
  v42[1] = v17 - (float)(v22 * v38);
  v42[3] = v39;
  return result;
}

uint64_t b2GearJoint::SolvePositionConstraints(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  float *v5;
  float v6;
  float *v7;
  float v8;
  float v9;
  float v10;
  float *v11;
  float v12;
  float *v13;
  float v14;
  __float2 v15;
  __float2 v16;
  float v17;
  float v18;
  float v19;
  float v20;
  float v21;
  float v22;
  float v23;
  float v24;
  float v25;
  float v26;
  __float2 v27;
  __float2 v28;
  float v29;
  float v30;
  float v31;
  float v32;
  float v33;
  float v34;
  float v35;
  float v36;
  float v37;
  float v38;
  float v39;
  float v40;
  float v41;
  float v42;
  float v43;
  float v44;
  float v45;
  float v46;
  float v47;
  float v48;
  float v49;
  float v50;
  float v51;
  float v52;
  float v53;
  float v54;
  float v55;
  float v56;
  float v57;
  float v58;
  float v59;
  float v60;
  float v61;
  float v62;
  float v63;
  float v64;
  float v65;
  float v66;
  float v67;
  float v68;
  float v69;
  float v70;
  float v71;
  float v72;
  float *v73;
  float *v74;
  float *v75;
  float v77;
  float v78;
  float v79;
  float v80;
  float v81;
  float v82;
  float v83;
  float v84;

  v4 = *(_QWORD *)(a2 + 24);
  v5 = (float *)(v4 + 16 * *(int *)(a1 + 224));
  v81 = v5[1];
  v82 = *v5;
  v6 = v5[3];
  v7 = (float *)(v4 + 16 * *(int *)(a1 + 228));
  v9 = *v7;
  v8 = v7[1];
  v10 = v7[3];
  v11 = (float *)(v4 + 16 * *(int *)(a1 + 220));
  v77 = v11[1];
  v78 = *v11;
  v12 = v11[3];
  v13 = (float *)(v4 + 16 * *(int *)(a1 + 232));
  v83 = v13[1];
  v84 = *v13;
  v14 = v13[3];
  v15 = __sincosf_stret(v6);
  v16 = __sincosf_stret(v14);
  v80 = v12;
  if (*(_DWORD *)(a1 + 128) == 1)
  {
    v17 = *(float *)(a1 + 284);
    v18 = *(float *)(a1 + 292);
    v19 = v17 + v18;
    v20 = (float)(v12 - v10) - *(float *)(a1 + 200);
    v21 = 1.0;
    v22 = 0.0;
    v23 = 0.0;
    v24 = 1.0;
    v26 = v77;
    v25 = v78;
  }
  else
  {
    v27 = __sincosf_stret(v10);
    v28 = __sincosf_stret(v12);
    v29 = *(float *)(a1 + 184);
    v30 = *(float *)(a1 + 188);
    v22 = (float)(v27.__cosval * v29) - (float)(v27.__sinval * v30);
    v23 = (float)(v27.__cosval * v30) + (float)(v27.__sinval * v29);
    v31 = *(float *)(a1 + 168) - *(float *)(a1 + 252);
    v32 = *(float *)(a1 + 172) - *(float *)(a1 + 256);
    v33 = *(float *)(a1 + 152) - *(float *)(a1 + 236);
    v34 = *(float *)(a1 + 156) - *(float *)(a1 + 240);
    v35 = (float)(v28.__cosval * v33) - (float)(v28.__sinval * v34);
    v36 = (float)(v28.__cosval * v34) + (float)(v28.__sinval * v33);
    v24 = (float)((float)((float)(v27.__cosval * v31) - (float)(v27.__sinval * v32)) * v23)
        - (float)((float)((float)(v27.__cosval * v32) + (float)(v27.__sinval * v31)) * v22);
    v21 = (float)(v35 * v23) - (float)(v36 * v22);
    v18 = *(float *)(a1 + 292);
    v17 = *(float *)(a1 + 284);
    v19 = (float)((float)(*(float *)(a1 + 276) + *(float *)(a1 + 268)) + (float)((float)(v24 * v18) * v24))
        + (float)((float)(v17 * v21) * v21);
    v26 = v77;
    v25 = v78;
    v20 = (float)(v30
                * (float)((float)((float)(v27.__cosval * (float)((float)(v77 - v8) + v36))
                                - (float)(v27.__sinval * (float)((float)(v78 - v9) + v35)))
                        - v32))
        + (float)((float)((float)((float)(v27.__sinval * (float)((float)(v77 - v8) + v36))
                                + (float)(v27.__cosval * (float)((float)(v78 - v9) + v35)))
                        - v31)
                * v29);
  }
  v37 = 0.0;
  v38 = v19 + 0.0;
  if (*(_DWORD *)(a1 + 132) == 1)
  {
    v39 = *(float *)(a1 + 212);
    v40 = *(float *)(a1 + 288);
    v41 = *(float *)(a1 + 296);
    v42 = v38 + (float)((float)(v39 * v39) * (float)(v40 + v41));
    v43 = (float)(v6 - v14) - *(float *)(a1 + 204);
    v44 = 0.0;
    v45 = v39;
    v46 = v39;
  }
  else
  {
    v47 = *(float *)(a1 + 192);
    v48 = *(float *)(a1 + 196);
    v49 = (float)(v16.__cosval * v47) - (float)(v16.__sinval * v48);
    v50 = (float)(v16.__cosval * v48) + (float)(v16.__sinval * v47);
    v79 = v8;
    v51 = *(float *)(a1 + 176) - *(float *)(a1 + 260);
    v52 = v20;
    v53 = v25;
    v54 = *(float *)(a1 + 180) - *(float *)(a1 + 264);
    v55 = v18;
    v56 = v26;
    v57 = *(float *)(a1 + 160) - *(float *)(a1 + 244);
    v58 = *(float *)(a1 + 164) - *(float *)(a1 + 248);
    v59 = (float)(v15.__cosval * v57) - (float)(v15.__sinval * v58);
    v60 = (float)(v15.__cosval * v58) + (float)(v15.__sinval * v57);
    v39 = *(float *)(a1 + 212);
    v37 = v49 * v39;
    v44 = v50 * v39;
    v46 = v39
        * (float)((float)((float)((float)(v16.__cosval * v51) - (float)(v16.__sinval * v54)) * v50)
                - (float)((float)((float)(v16.__cosval * v54) + (float)(v16.__sinval * v51)) * v49));
    v45 = v39 * (float)((float)(v59 * v50) - (float)(v60 * v49));
    v41 = *(float *)(a1 + 296);
    v40 = *(float *)(a1 + 288);
    v42 = v38
        + (float)((float)((float)(v46 * (float)(v46 * v41))
                        + (float)((float)(v39 * v39) * (float)(*(float *)(a1 + 280) + *(float *)(a1 + 272))))
                + (float)((float)(v40 * v45) * v45));
    v61 = (float)(v82 - v84) + v59;
    v62 = (float)(v81 - v83) + v60;
    v63 = (float)(v16.__sinval * v62) + (float)(v16.__cosval * v61);
    v64 = (float)((float)(v16.__cosval * v62) - (float)(v16.__sinval * v61)) - v54;
    v26 = v56;
    v18 = v55;
    v65 = v48 * v64;
    v25 = v53;
    v20 = v52;
    v43 = v65 + (float)((float)(v63 - v51) * v47);
    v8 = v79;
  }
  v66 = 0.0;
  if (v42 > 0.0)
    v66 = (float)-(float)((float)(v20 + (float)(v39 * v43)) - *(float *)(a1 + 208)) / v42;
  v67 = v66 * *(float *)(a1 + 268);
  v68 = v80 + (float)((float)(v66 * v17) * v21);
  v69 = v66 * *(float *)(a1 + 272);
  v70 = v6 + (float)((float)(v66 * v40) * v45);
  v71 = v66 * *(float *)(a1 + 276);
  v72 = v66 * *(float *)(a1 + 280);
  *v11 = v25 + (float)(v22 * v67);
  v11[1] = v26 + (float)(v23 * v67);
  v11[3] = v68;
  v73 = (float *)(*(_QWORD *)(a2 + 24) + 16 * *(int *)(a1 + 224));
  *v73 = v82 + (float)(v37 * v69);
  v73[1] = v81 + (float)(v44 * v69);
  v73[3] = v70;
  v74 = (float *)(*(_QWORD *)(a2 + 24) + 16 * *(int *)(a1 + 228));
  *v74 = v9 - (float)(v22 * v71);
  v74[1] = v8 - (float)(v23 * v71);
  v74[3] = v10 + (float)((float)-(float)(v18 * v66) * v24);
  v75 = (float *)(*(_QWORD *)(a2 + 24) + 16 * *(int *)(a1 + 232));
  *v75 = v84 - (float)(v37 * v72);
  v75[1] = v83 - (float)(v44 * v72);
  v75[3] = v14 + (float)((float)-(float)(v41 * v66) * v46);
  return 1;
}

float b2GearJoint::GetAnchorA(b2GearJoint *this)
{
  return *(float *)(*((_QWORD *)this + 12) + 32)
       + (float)((float)(*(float *)(*((_QWORD *)this + 12) + 44) * *((float *)this + 38))
               - (float)(*(float *)(*((_QWORD *)this + 12) + 40) * *((float *)this + 39)));
}

float b2GearJoint::GetAnchorB(b2GearJoint *this)
{
  return *(float *)(*((_QWORD *)this + 13) + 32)
       + (float)((float)(*(float *)(*((_QWORD *)this + 13) + 44) * *((float *)this + 40))
               - (float)(*(float *)(*((_QWORD *)this + 13) + 40) * *((float *)this + 41)));
}

float b2GearJoint::GetReactionForce(b2GearJoint *this, float a2)
{
  return (float)(*((float *)this + 54) * *((float *)this + 75)) * a2;
}

float b2GearJoint::GetReactionTorque(b2GearJoint *this, float a2)
{
  return (float)(*((float *)this + 54) * *((float *)this + 79)) * a2;
}

uint64_t b2GearJoint::SetRatio(uint64_t this, float a2)
{
  if (a2 <= -INFINITY || a2 >= INFINITY)
    b2GearJoint::SetRatio();
  *(float *)(this + 212) = a2;
  return this;
}

float b2GearJoint::GetRatio(b2GearJoint *this)
{
  return *((float *)this + 53);
}

void b2GearJoint::~b2GearJoint(b2GearJoint *this)
{
  JUMPOUT(0x20BD0BA58);
}

b2QuadtreeAndChainContact *b2QuadtreeAndChainContact::Create(b2Fixture *this, b2Fixture *a2, b2Fixture *a3, b2Fixture *a4)
{
  int v4;
  int v6;
  b2QuadtreeAndChainContact *v8;

  v4 = (int)a4;
  v6 = (int)a2;
  v8 = (b2QuadtreeAndChainContact *)operator new();
  b2QuadtreeAndChainContact::b2QuadtreeAndChainContact(v8, this, v6, a3, v4);
  return v8;
}

void sub_208FC49F4(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BD0BA58](v1, 0x10A1C40CDD50D3ELL);
  _Unwind_Resume(a1);
}

void b2QuadtreeAndChainContact::b2QuadtreeAndChainContact(b2QuadtreeAndChainContact *this, b2Fixture *a2, int a3, b2Fixture *a4, int a5)
{
  _QWORD *v5;

  b2Contact::b2Contact(this, a2, a3, a4, a5);
  *v5 = &off_24C0E87E8;
  if (*(_DWORD *)(*(_QWORD *)(v5[10] + 32) + 8) != 4)
    b2QuadtreeAndChainContact::b2QuadtreeAndChainContact();
  if (*(_DWORD *)(*(_QWORD *)(v5[11] + 32) + 8) != 3)
    b2QuadtreeAndChainContact::b2QuadtreeAndChainContact();
}

uint64_t b2QuadtreeAndChainContact::Evaluate()
{
  return puts("b2QuadtreeAndChainContact");
}

b2QuadtreeAndCircleContact *b2QuadtreeAndCircleContact::Create(b2Fixture *this, b2Fixture *a2, b2Fixture *a3, b2Fixture *a4)
{
  int v4;
  int v6;
  b2QuadtreeAndCircleContact *v8;

  v4 = (int)a4;
  v6 = (int)a2;
  v8 = (b2QuadtreeAndCircleContact *)operator new();
  b2QuadtreeAndCircleContact::b2QuadtreeAndCircleContact(v8, this, v6, a3, v4);
  return v8;
}

void sub_208FC4AE4(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BD0BA58](v1, 0x10A1C40CDD50D3ELL);
  _Unwind_Resume(a1);
}

void b2QuadtreeAndCircleContact::b2QuadtreeAndCircleContact(b2QuadtreeAndCircleContact *this, b2Fixture *a2, int a3, b2Fixture *a4, int a5)
{
  _QWORD *v5;

  b2Contact::b2Contact(this, a2, a3, a4, a5);
  *v5 = &off_24C0E8838;
  if (*(_DWORD *)(*(_QWORD *)(v5[10] + 32) + 8))
    b2QuadtreeAndCircleContact::b2QuadtreeAndCircleContact();
  if (*(_DWORD *)(*(_QWORD *)(v5[11] + 32) + 8) != 4)
    b2QuadtreeAndCircleContact::b2QuadtreeAndCircleContact();
}

void b2QuadtreeAndCircleContact::Evaluate(uint64_t a1, float32x2_t *a2, float *a3, float *a4)
{
  uint64_t v5;
  float v6;
  float v7;
  float v8;
  float v9;
  float v10;
  uint64_t v11;
  float v12;
  float v13;
  float v14;
  float v15;
  float v16;
  float v17;
  float v18;
  double v19;
  float v20;
  double v21;
  float v22;
  float v23;
  BOOL v24;
  char *v25;
  uint64_t v26;
  float32x2_t *v27;
  char *v28;
  uint64_t v29;
  float32x2_t v30;
  void *__p;
  char *v32;
  uint64_t v33;

  a2[7].i32[1] = 0;
  v5 = *(_QWORD *)(*(_QWORD *)(a1 + 80) + 32);
  v7 = a3[2];
  v6 = a3[3];
  v8 = *(float *)(v5 + 16);
  v9 = *(float *)(v5 + 20);
  v10 = *a3 + (float)((float)(v6 * v8) - (float)(v7 * v9));
  v11 = *(_QWORD *)(*(_QWORD *)(a1 + 88) + 32);
  v12 = (float)((float)(v6 * v9) + (float)(v7 * v8)) + a3[1];
  v13 = v10 - *a4;
  v14 = v12 - a4[1];
  v16 = a4[2];
  v15 = a4[3];
  v17 = (float)(v14 * v16) + (float)(v15 * v13);
  v18 = (float)(v15 * v14) - (float)(v16 * v13);
  v32 = 0;
  v33 = 0;
  __p = 0;
  v19 = v17;
  v20 = v17 + -0.1;
  v21 = v18;
  v22 = v18 + -0.1;
  *(float *)&v19 = v19 + 0.1;
  v23 = v21 + 0.1;
  v24 = QuadTree::intersectBox(*(uint64_t **)(v11 + 16), (uint64_t)&__p, v20, v22, *(float *)&v19, v23);
  v25 = (char *)__p;
  if (v24)
  {
    a2[7].i32[0] = 3;
    a2[6] = *(float32x2_t *)(v5 + 16);
    if ((unint64_t)(v32 - v25) <= 0x10)
      v26 = ((unint64_t)(v32 - v25) >> 3);
    else
      v26 = 2;
    a2[7].i32[1] = v26;
    if ((int)v26 >= 1)
    {
      v27 = a2 + 2;
      v28 = v25;
      do
      {
        v29 = *(_QWORD *)v28;
        v28 += 8;
        v30.i32[0] = *(_DWORD *)(v29 + 32);
        v30.i32[1] = *(_DWORD *)(v29 + 44);
        v27[-2] = vmul_f32(vadd_f32(*(float32x2_t *)(v29 + 36), v30), (float32x2_t)0x3F0000003F000000);
        v27->i32[0] = 0;
        v27 = (float32x2_t *)((char *)v27 + 20);
        --v26;
      }
      while (v26);
    }
    a2[5] = 0;
  }
  if (v25)
  {
    v32 = v25;
    operator delete(v25);
  }
}

void sub_208FC4CA4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

b2QuadtreeAndEdgeContact *b2QuadtreeAndEdgeContact::Create(b2Fixture *this, b2Fixture *a2, b2Fixture *a3, b2Fixture *a4)
{
  int v4;
  int v6;
  b2QuadtreeAndEdgeContact *v8;

  v4 = (int)a4;
  v6 = (int)a2;
  v8 = (b2QuadtreeAndEdgeContact *)operator new();
  b2QuadtreeAndEdgeContact::b2QuadtreeAndEdgeContact(v8, this, v6, a3, v4);
  return v8;
}

void sub_208FC4D2C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BD0BA58](v1, 0x10A1C40CDD50D3ELL);
  _Unwind_Resume(a1);
}

void b2QuadtreeAndEdgeContact::b2QuadtreeAndEdgeContact(b2QuadtreeAndEdgeContact *this, b2Fixture *a2, int a3, b2Fixture *a4, int a5)
{
  _QWORD *v5;

  b2Contact::b2Contact(this, a2, a3, a4, a5);
  *v5 = &off_24C0E8798;
  if (*(_DWORD *)(*(_QWORD *)(v5[10] + 32) + 8) != 4)
    b2QuadtreeAndEdgeContact::b2QuadtreeAndEdgeContact();
  if (*(_DWORD *)(*(_QWORD *)(v5[11] + 32) + 8) != 1)
    b2QuadtreeAndEdgeContact::b2QuadtreeAndEdgeContact();
}

uint64_t b2QuadtreeAndEdgeContact::Evaluate()
{
  return puts("b2QuadtreeAndEdgeContact");
}

b2QuadtreeAndPolygonContact *b2QuadtreeAndPolygonContact::Create(b2Fixture *this, b2Fixture *a2, b2Fixture *a3, b2Fixture *a4)
{
  int v4;
  int v6;
  b2QuadtreeAndPolygonContact *v8;

  v4 = (int)a4;
  v6 = (int)a2;
  v8 = (b2QuadtreeAndPolygonContact *)operator new();
  b2QuadtreeAndPolygonContact::b2QuadtreeAndPolygonContact(v8, this, v6, a3, v4);
  return v8;
}

void sub_208FC4E1C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BD0BA58](v1, 0x10A1C40CDD50D3ELL);
  _Unwind_Resume(a1);
}

void b2QuadtreeAndPolygonContact::b2QuadtreeAndPolygonContact(b2QuadtreeAndPolygonContact *this, b2Fixture *a2, int a3, b2Fixture *a4, int a5)
{
  _QWORD *v5;

  b2Contact::b2Contact(this, a2, a3, a4, a5);
  *v5 = &off_24C0E8860;
  if (*(_DWORD *)(*(_QWORD *)(v5[10] + 32) + 8) != 4)
    b2QuadtreeAndPolygonContact::b2QuadtreeAndPolygonContact();
  if (*(_DWORD *)(*(_QWORD *)(v5[11] + 32) + 8) != 2)
    b2QuadtreeAndPolygonContact::b2QuadtreeAndPolygonContact();
}

uint64_t b2QuadtreeAndPolygonContact::Evaluate()
{
  return puts("b2QuadtreeAndPolygonContact");
}

b2QuadtreeAndQuadtreeContact *b2QuadtreeAndQuadtreeContact::Create(b2Fixture *this, b2Fixture *a2, b2Fixture *a3, b2Fixture *a4)
{
  int v4;
  int v6;
  b2QuadtreeAndQuadtreeContact *v8;

  v4 = (int)a4;
  v6 = (int)a2;
  v8 = (b2QuadtreeAndQuadtreeContact *)operator new();
  b2QuadtreeAndQuadtreeContact::b2QuadtreeAndQuadtreeContact(v8, this, v6, a3, v4);
  return v8;
}

void sub_208FC4F0C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BD0BA58](v1, 0x10A1C40CDD50D3ELL);
  _Unwind_Resume(a1);
}

void b2QuadtreeAndQuadtreeContact::b2QuadtreeAndQuadtreeContact(b2QuadtreeAndQuadtreeContact *this, b2Fixture *a2, int a3, b2Fixture *a4, int a5)
{
  _QWORD *v5;

  b2Contact::b2Contact(this, a2, a3, a4, a5);
  *v5 = &off_24C0E8888;
  if (*(_DWORD *)(*(_QWORD *)(v5[10] + 32) + 8) != 4)
    b2QuadtreeAndQuadtreeContact::b2QuadtreeAndQuadtreeContact();
  if (*(_DWORD *)(*(_QWORD *)(v5[11] + 32) + 8) != 4)
    b2QuadtreeAndQuadtreeContact::b2QuadtreeAndQuadtreeContact();
}

uint64_t b2QuadtreeAndQuadtreeContact::Evaluate()
{
  return puts("b2QuadtreeAndQuadtreeContact");
}

void b2QuadtreeAndChainContact::~b2QuadtreeAndChainContact(b2QuadtreeAndChainContact *this)
{
  JUMPOUT(0x20BD0BA58);
}

void b2QuadtreeAndCircleContact::~b2QuadtreeAndCircleContact(b2QuadtreeAndCircleContact *this)
{
  JUMPOUT(0x20BD0BA58);
}

void b2QuadtreeAndEdgeContact::~b2QuadtreeAndEdgeContact(b2QuadtreeAndEdgeContact *this)
{
  JUMPOUT(0x20BD0BA58);
}

void b2QuadtreeAndPolygonContact::~b2QuadtreeAndPolygonContact(b2QuadtreeAndPolygonContact *this)
{
  JUMPOUT(0x20BD0BA58);
}

void b2QuadtreeAndQuadtreeContact::~b2QuadtreeAndQuadtreeContact(b2QuadtreeAndQuadtreeContact *this)
{
  JUMPOUT(0x20BD0BA58);
}

b2RevoluteJoint *b2Joint::Create(b2Joint *this, const b2JointDef *a2)
{
  b2RevoluteJoint *v3;

  switch(LODWORD(this->var0))
  {
    case 1:
      v3 = (b2RevoluteJoint *)operator new();
      b2RevoluteJoint::b2RevoluteJoint(v3, (const b2RevoluteJointDef *)this);
      break;
    case 2:
      v3 = (b2RevoluteJoint *)operator new();
      b2PrismaticJoint::b2PrismaticJoint((b2PrismaticJoint *)v3, (const b2PrismaticJointDef *)this);
      break;
    case 3:
      v3 = (b2RevoluteJoint *)operator new();
      b2DistanceJoint::b2DistanceJoint((b2DistanceJoint *)v3, (const b2JointDef *)this);
      break;
    case 4:
      v3 = (b2RevoluteJoint *)operator new();
      b2PulleyJoint::b2PulleyJoint((b2PulleyJoint *)v3, (const b2PulleyJointDef *)this);
      break;
    case 5:
      v3 = (b2RevoluteJoint *)operator new();
      b2MouseJoint::b2MouseJoint(v3, this);
      break;
    case 6:
      v3 = (b2RevoluteJoint *)operator new();
      b2GearJoint::b2GearJoint(v3, this);
      break;
    case 7:
      v3 = (b2RevoluteJoint *)operator new();
      b2WheelJoint::b2WheelJoint((b2WheelJoint *)v3, (const b2WheelJointDef *)this);
      break;
    case 8:
      v3 = (b2RevoluteJoint *)operator new();
      b2WeldJoint::b2WeldJoint((b2WeldJoint *)v3, (const b2JointDef *)this);
      break;
    case 9:
      v3 = (b2RevoluteJoint *)operator new();
      b2FrictionJoint::b2FrictionJoint((b2FrictionJoint *)v3, (const b2FrictionJointDef *)this);
      break;
    case 0xA:
      v3 = (b2RevoluteJoint *)operator new();
      b2RopeJoint::b2RopeJoint((b2RopeJoint *)v3, (const b2JointDef *)this);
      break;
    default:
      b2Joint::Create();
  }
  return v3;
}

void sub_208FC51E0(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BD0BA58](v1, 0x10A1C406679337BLL);
  _Unwind_Resume(a1);
}

b2Joint *b2Joint::Destroy(b2Joint *this, b2Joint *a2)
{
  if (this)
    return (b2Joint *)(*((uint64_t (**)(b2Joint *))this->var0 + 5))(this);
  return this;
}

void b2Joint::b2Joint(b2Joint *this, const b2JointDef *a2)
{
  b2Body *var2;
  b2Body *var3;

  this->var0 = (void **)&unk_24C0E8910;
  var2 = a2->var2;
  var3 = a2->var3;
  if (var2 == var3)
    b2Joint::b2Joint();
  this->var1 = a2->var0;
  this->var2 = 0;
  this->var3 = 0;
  this->var6 = var2;
  this->var7 = var3;
  this->var9 = a2->var4;
  this->var8 = 0;
  this->var10 = a2->var1;
  *(_OWORD *)&this->var4.var0 = 0u;
  *(_OWORD *)&this->var4.var2 = 0u;
  *(_OWORD *)&this->var5.var0 = 0u;
  *(_OWORD *)&this->var5.var2 = 0u;
}

uint64_t b2Joint::IsActive(b2Joint *this)
{
  uint64_t result;

  result = b2Body::IsActive(this->var6);
  if ((_DWORD)result)
    return b2Body::IsActive(this->var7);
  return result;
}

b2Joint *b2Joint::SetCollideConnected(b2Joint *this, _BOOL4 a2)
{
  b2Joint *v2;
  b2Body *var6;
  uint64_t v4;
  b2ContactManager *p_var19;
  b2Body *var7;
  uint64_t v7;
  b2ContactManager *v8;

  if (this->var9 != a2)
  {
    v2 = this;
    this->var9 = a2;
    if (!a2)
    {
      var6 = this->var6;
      if (var6)
      {
        v4 = *(_QWORD *)&var6->var24;
        if (v4)
        {
          p_var19 = (b2ContactManager *)&var6->var17[443].var19;
          do
          {
            this = (b2Joint *)b2ContactManager::DestroyContact(p_var19, *(b2Contact **)(v4 + 8));
            v4 = *(_QWORD *)&v2->var6->var24;
          }
          while (v4);
        }
      }
      var7 = v2->var7;
      if (var7)
      {
        v7 = *(_QWORD *)&var7->var24;
        if (v7)
        {
          v8 = (b2ContactManager *)&var7->var17[443].var19;
          do
          {
            this = (b2Joint *)b2ContactManager::DestroyContact(v8, *(b2Contact **)(v7 + 8));
            v7 = *(_QWORD *)&v2->var7->var24;
          }
          while (v7);
        }
      }
    }
  }
  return this;
}

double b2MouseJoint::b2MouseJoint(b2Joint *a1, uint64_t a2)
{
  uint64_t v3;
  float v4;
  BOOL v5;
  float v6;
  BOOL v7;
  float v8;
  float v9;
  float v10;
  unint64_t v11;
  unint64_t v12;
  float v13;
  float *v14;
  float v15;
  float v16;
  float v17;
  float v18;
  double result;

  b2Joint::b2Joint(a1, (const b2JointDef *)a2);
  *(_QWORD *)v3 = off_24C0E7F30;
  v4 = *(float *)(a2 + 36);
  v5 = v4 > -INFINITY && v4 < INFINITY;
  if (!v5 || ((v6 = *(float *)(a2 + 40), v6 > -INFINITY) ? (v7 = v6 < INFINITY) : (v7 = 0), !v7))
    b2MouseJoint::b2MouseJoint();
  v8 = *(float *)(a2 + 44);
  if (v8 < 0.0 || v8 <= -INFINITY || v8 >= INFINITY)
    b2MouseJoint::b2MouseJoint();
  v9 = *(float *)(a2 + 48);
  if (v9 < 0.0 || v9 <= -INFINITY || v9 >= INFINITY)
    b2MouseJoint::b2MouseJoint();
  v10 = *(float *)(a2 + 52);
  if (v10 < 0.0 || v10 <= -INFINITY || v10 >= INFINITY)
    b2MouseJoint::b2MouseJoint();
  v11 = *(_QWORD *)(a2 + 36);
  *(_QWORD *)(v3 + 136) = v11;
  v12 = HIDWORD(v11);
  v13 = *(float *)&v11;
  v14 = *(float **)(v3 + 104);
  v15 = v13 - v14[8];
  v16 = *(float *)&v12 - v14[9];
  v18 = v14[10];
  v17 = v14[11];
  *(float *)(v3 + 128) = (float)(v16 * v18) + (float)(v17 * v15);
  *(float *)(v3 + 132) = (float)(v17 * v16) - (float)(v18 * v15);
  *(_DWORD *)(v3 + 164) = *(_DWORD *)(a2 + 44);
  *(_DWORD *)(v3 + 160) = 0;
  result = *(double *)(a2 + 48);
  *(double *)(v3 + 144) = result;
  *(_QWORD *)(v3 + 152) = 0;
  *(_DWORD *)(v3 + 168) = 0;
  return result;
}

uint64_t b2MouseJoint::SetTarget(b2Body **this, b2Body **a2)
{
  uint64_t result;

  result = b2Body::IsAwake(this[13]);
  if ((result & 1) == 0)
    result = (uint64_t)b2Body::SetAwake(this[13], 1);
  this[17] = *a2;
  return result;
}

uint64_t b2MouseJoint::GetTarget(b2MouseJoint *this)
{
  return (uint64_t)this + 136;
}

uint64_t b2MouseJoint::SetMaxForce(uint64_t this, float a2)
{
  *(float *)(this + 164) = a2;
  return this;
}

float b2MouseJoint::GetMaxForce(b2MouseJoint *this)
{
  return *((float *)this + 41);
}

uint64_t b2MouseJoint::SetFrequency(uint64_t this, float a2)
{
  *(float *)(this + 144) = a2;
  return this;
}

float b2MouseJoint::GetFrequency(b2MouseJoint *this)
{
  return *((float *)this + 36);
}

uint64_t b2MouseJoint::SetDampingRatio(uint64_t this, float a2)
{
  *(float *)(this + 148) = a2;
  return this;
}

float b2MouseJoint::GetDampingRatio(b2MouseJoint *this)
{
  return *((float *)this + 37);
}

void b2MouseJoint::InitVelocityConstraints(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  float v5;
  float v6;
  float v7;
  float v8;
  float v9;
  float v10;
  float v11;
  uint64_t v14;
  float32x2_t v15;
  float v16;
  float v17;
  float *v18;
  __float2 v19;
  float v20;
  float v21;
  float v22;
  float v23;
  float v24;
  float v25;
  float v26;
  float v28;
  float v29;
  float v30;
  float v31;
  float v32;
  float v33;
  float v34;
  float v35;
  float v36;
  float v43;

  v2 = *(_QWORD *)(a1 + 104);
  v3 = *(int *)(v2 + 28);
  *(_DWORD *)(a1 + 176) = v3;
  v4 = *(_QWORD *)(v2 + 64);
  *(_QWORD *)(a1 + 188) = v4;
  v5 = *(float *)(v2 + 224);
  v6 = *(float *)(v2 + 208);
  v7 = *(float *)(v2 + 212);
  *(float *)(a1 + 196) = v7;
  *(float *)(a1 + 200) = v5;
  v8 = *(float *)(a1 + 144) * 6.2832;
  v9 = v6 * (float)(v8 * v8);
  v10 = *(float *)a2;
  v11 = (float)(v8 * (float)((float)(v6 + v6) * *(float *)(a1 + 148))) + (float)(*(float *)a2 * v9);
  if (v11 <= 0.00000011921)
    b2MouseJoint::InitVelocityConstraints();
  v14 = *(_QWORD *)(a2 + 32) + 16 * v3;
  v15 = *(float32x2_t *)v14;
  v16 = *((float *)&v4 + 1);
  v17 = *(float *)&v4;
  v18 = (float *)(*(_QWORD *)(a2 + 24) + 16 * v3);
  v43 = v7;
  v19 = __sincosf_stret(v18[3]);
  v20 = *(float *)(v14 + 12);
  v22 = *v18;
  v21 = v18[1];
  v23 = 1.0 / (float)(v10 * v11);
  if ((float)(v10 * v11) == 0.0)
    v23 = v10 * v11;
  *(float *)(a1 + 168) = v23;
  v24 = (float)(v10 * v9) * v23;
  *(float *)(a1 + 152) = v24;
  v25 = *(float *)(a1 + 128) - v17;
  v26 = *(float *)(a1 + 132) - v16;
  _S2 = (float)(v19.__cosval * v25) - (float)(v19.__sinval * v26);
  v28 = (float)(v19.__cosval * v26) + (float)(v19.__sinval * v25);
  *(float *)(a1 + 180) = _S2;
  *(float *)(a1 + 184) = v28;
  v29 = v23 + (float)(v43 + (float)((float)(v5 * v28) * v28));
  v30 = v28 * (float)-(float)(v5 * _S2);
  v31 = v23 + (float)(v43 + (float)((float)(v5 * _S2) * _S2));
  v32 = (float)(v29 * v31) - (float)(v30 * v30);
  v33 = 1.0 / v32;
  if (v32 == 0.0)
    v33 = (float)(v29 * v31) - (float)(v30 * v30);
  v34 = -(float)(v33 * v30);
  *(float *)(a1 + 204) = v31 * v33;
  *(float *)(a1 + 208) = v34;
  *(float *)(a1 + 212) = v34;
  *(float *)(a1 + 216) = v29 * v33;
  v35 = v24 * (float)((float)(v21 + v28) - *(float *)(a1 + 140));
  *(float *)(a1 + 220) = v24 * (float)((float)(v22 + _S2) - *(float *)(a1 + 136));
  *(float *)(a1 + 224) = v35;
  v36 = v20 * 0.98;
  if (*(_BYTE *)(a2 + 20))
  {
    _D3 = vmul_n_f32(*(float32x2_t *)(a1 + 156), COERCE_FLOAT(*(_QWORD *)(a2 + 8)));
    *(float32x2_t *)(a1 + 156) = _D3;
    v15 = vadd_f32(v15, vmul_n_f32(_D3, v43));
    __asm { FMLA            S0, S2, V3.S[1] }
    v36 = v36 + (float)(v5 * _S0);
  }
  else
  {
    *(_DWORD *)(a1 + 156) = 0;
    *(_DWORD *)(a1 + 160) = 0;
  }
  *(float32x2_t *)v14 = v15;
  *(float *)(v14 + 12) = v36;
}

float b2MouseJoint::SolveVelocityConstraints(uint64_t a1, uint64_t a2)
{
  float *v2;
  float v3;
  float v4;
  float v5;
  float v6;
  float v7;
  float v8;
  float v9;
  float v10;
  float v11;
  float v12;
  float v13;
  float v14;
  float v15;
  float v16;
  float v17;
  float v18;
  float v19;
  float v20;
  float v21;
  float v22;
  float v23;
  float result;
  float v25;

  v2 = (float *)(*(_QWORD *)(a2 + 32) + 16 * *(int *)(a1 + 176));
  v3 = *v2;
  v4 = v2[1];
  v5 = v2[3];
  v7 = *(float *)(a1 + 180);
  v6 = *(float *)(a1 + 184);
  v8 = *(float *)(a1 + 156);
  v9 = *(float *)(a1 + 160);
  v11 = *(float *)(a1 + 164);
  v10 = *(float *)(a1 + 168);
  v12 = (float)((float)(*v2 - (float)(v5 * v6)) + *(float *)(a1 + 220)) + (float)(v10 * v8);
  v13 = (float)((float)(v4 + (float)(v5 * v7)) + *(float *)(a1 + 224)) + (float)(v10 * v9);
  v14 = (float)-(float)(v13 * *(float *)(a1 + 212)) - (float)(*(float *)(a1 + 204) * v12);
  v15 = (float)-(float)(v13 * *(float *)(a1 + 216)) - (float)(*(float *)(a1 + 208) * v12);
  v16 = v14 + v8;
  v17 = v9 + v15;
  *(float *)(a1 + 156) = v14 + v8;
  *(float *)(a1 + 160) = v17;
  v18 = *(float *)a2 * v11;
  v19 = (float)(v17 * v17) + (float)(v16 * v16);
  if (v19 > (float)(v18 * v18))
  {
    v20 = v18 / sqrtf(v19);
    v16 = v16 * v20;
    v17 = v17 * v20;
    *(float *)(a1 + 156) = v16;
    *(float *)(a1 + 160) = v17;
  }
  v21 = v16 - v8;
  v22 = v17 - v9;
  v23 = *(float *)(a1 + 196);
  result = v3 + (float)(v21 * v23);
  v25 = v5 + (float)(*(float *)(a1 + 200) * (float)((float)(v7 * v22) - (float)(v6 * v21)));
  *v2 = result;
  v2[1] = v4 + (float)(v22 * v23);
  v2[3] = v25;
  return result;
}

uint64_t b2MouseJoint::SolvePositionConstraints()
{
  return 1;
}

float b2MouseJoint::GetAnchorA(b2MouseJoint *this)
{
  return *((float *)this + 34);
}

float b2MouseJoint::GetAnchorB(b2MouseJoint *this)
{
  return *(float *)(*((_QWORD *)this + 13) + 32)
       + (float)((float)(*(float *)(*((_QWORD *)this + 13) + 44) * *((float *)this + 32))
               - (float)(*(float *)(*((_QWORD *)this + 13) + 40) * *((float *)this + 33)));
}

float b2MouseJoint::GetReactionForce(b2MouseJoint *this, float a2)
{
  return *((float *)this + 39) * a2;
}

float b2MouseJoint::GetReactionTorque(b2MouseJoint *this, float a2)
{
  return a2 * 0.0;
}

void b2MouseJoint::~b2MouseJoint(b2MouseJoint *this)
{
  JUMPOUT(0x20BD0BA58);
}

void PKCGrid::PKCGrid(PKCGrid *this)
{
  *(_QWORD *)this = 0;
  *(_OWORD *)((char *)this + 40) = 0u;
  *(_OWORD *)((char *)this + 56) = 0u;
  *(_OWORD *)((char *)this + 72) = 0u;
  *(_OWORD *)((char *)this + 88) = 0u;
  *(_OWORD *)((char *)this + 104) = 0u;
  *(_OWORD *)((char *)this + 120) = 0u;
}

{
  *(_QWORD *)this = 0;
  *(_OWORD *)((char *)this + 40) = 0u;
  *(_OWORD *)((char *)this + 56) = 0u;
  *(_OWORD *)((char *)this + 72) = 0u;
  *(_OWORD *)((char *)this + 88) = 0u;
  *(_OWORD *)((char *)this + 104) = 0u;
  *(_OWORD *)((char *)this + 120) = 0u;
}

void PKCGrid::setGridSize(PKCGrid *this, int a2, int a3, int a4)
{
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  unint64_t v7;
  char v8;

  *(_DWORD *)this = a2;
  *((_DWORD *)this + 1) = a3;
  *((_DWORD *)this + 2) = a4;
  v4 = *((_QWORD *)this + 5);
  v5 = *((_QWORD *)this + 6);
  v6 = a3 * a2;
  v8 = 0;
  v7 = v5 - v4;
  if (v6 <= v7)
  {
    if (v6 < v7)
      *((_QWORD *)this + 6) = v4 + v6;
  }
  else
  {
    std::vector<unsigned char>::__append((_QWORD *)this + 5, v6 - v7, &v8);
  }
}

void PKCGrid::setData(PKCGrid *this, const unsigned __int8 *a2, int a3, unsigned int a4)
{
  uint64_t v7;
  _QWORD *v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;

  v7 = *((_QWORD *)this + 5);
  v8 = (_QWORD *)((char *)this + 40);
  v9 = a4;
  v10 = *((_QWORD *)this + 6) - v7;
  if (a4 <= v10)
  {
    if (a4 < v10)
      *((_QWORD *)this + 6) = v7 + a4;
  }
  else
  {
    std::vector<unsigned char>::__append((unint64_t *)this + 5, a4 - v10);
  }
  if (a4)
  {
    v11 = 0;
    do
    {
      *(_BYTE *)(*v8 + v11) = *a2;
      a2 += a3;
      ++v11;
    }
    while (v9 != v11);
  }
}

void PKCGrid::setVectorData(PKCGrid *this, const unsigned __int8 *a2, int a3, int a4)
{
  _QWORD *v7;
  __int128 v8;
  float32x2_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  float32x2_t v13;
  float32x2_t v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  unsigned int v23;
  uint64_t v24;

  if (a3)
  {
    if (a4)
    {
      *(_DWORD *)this = a3;
      *((_DWORD *)this + 1) = a4;
      v7 = (_QWORD *)((char *)this + 64);
      _ZNSt3__16vectorIDv4_fNS_9allocatorIS1_EEE6resizeEm((uint64_t)this + 64, a4 * a3);
      if (a4 >= 1)
      {
        v10 = 0;
        v11 = 0;
        v12 = 3;
        v13 = (float32x2_t)vdup_n_s32(0x42FE0000u);
        __asm { FMOV            V2.2S, #-1.0 }
        v19 = (float32x2_t)vdup_n_s32(0x437F0000u);
        do
        {
          v20 = a3;
          v21 = v10;
          v22 = v12;
          if (a3 >= 1)
          {
            do
            {
              LOBYTE(v8) = a2[v22 - 3];
              BYTE4(v8) = a2[v22 - 2];
              v9.i8[0] = a2[v22 - 1];
              v23 = 1123942400;
              v9.f32[0] = (float)v9.u32[0] / 127.0;
              LOBYTE(v23) = a2[v22];
              LODWORD(v24) = vadd_f32(v9, _D2).u32[0];
              v9.f32[1] = (float)v23;
              *(float32x2_t *)&v8 = vadd_f32(vdiv_f32(vcvt_f32_u32((uint32x2_t)vand_s8(*(int8x8_t *)&v8, (int8x8_t)0xFF000000FFLL)), v13), _D2);
              v9 = vdiv_f32(v9, v19);
              HIDWORD(v24) = v9.i32[1];
              *((_QWORD *)&v8 + 1) = v24;
              *(_OWORD *)(*v7 + v21) = v8;
              v22 += 4;
              v21 += 16;
              --v20;
            }
            while (v20);
          }
          ++v11;
          v12 += 4 * a3;
          v10 += 16 * a3;
        }
        while (v11 != a4);
      }
    }
  }
}

void _ZNSt3__16vectorIDv4_fNS_9allocatorIS1_EEE6resizeEm(uint64_t a1, unint64_t a2)
{
  unint64_t v2;

  v2 = (uint64_t)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 4;
  if (a2 <= v2)
  {
    if (a2 < v2)
      *(_QWORD *)(a1 + 8) = *(_QWORD *)a1 + 16 * a2;
  }
  else
  {
    _ZNSt3__16vectorIDv4_fNS_9allocatorIS1_EEE8__appendEm((void **)a1, a2 - v2);
  }
}

PKCGrid *PKCGrid::tagPixelData(PKCGrid *this, float a2, const unsigned __int8 *a3, int a4, int a5)
{
  int v5;
  int v6;
  int v8;
  uint64_t v9;
  int v10;

  v5 = *(_DWORD *)this;
  if (*(_DWORD *)this)
  {
    v6 = *((_DWORD *)this + 1);
    if (v6 && v6 >= 1)
    {
      v8 = 0;
      do
      {
        if (v5 >= 1)
        {
          v9 = 0;
          v10 = (~(int)(float)((float)((float)a5 * (float)v8) / (float)v6) + a5) * a4;
          do
          {
            *(_BYTE *)(*((_QWORD *)this + 5) + v8 * v5 + v9) = a3[4 * v10
                                                                + 3
                                                                + 4
                                                                * (int)(float)((float)((float)a4 * (float)(int)v9)
                                                                             / (float)v5)] > (int)(float)(a2 * 255.0);
            v5 = *(_DWORD *)this;
            ++v9;
          }
          while ((int)v9 < *(_DWORD *)this);
          v6 = *((_DWORD *)this + 1);
        }
        ++v8;
      }
      while (v8 < v6);
    }
  }
  return this;
}

uint64_t PKCGrid::traverse(PKCGrid *this, int *a2, int *a3)
{
  uint64_t v3;
  int v4;
  int v5;
  int v6;
  int v7;
  int v8;
  uint64_t v9;
  int v10;
  int v11;
  uint64_t i;
  int v13;
  uint64_t v14;
  _BYTE v16[8];
  uint64_t v17;

  v3 = 0;
  v17 = *MEMORY[0x24BDAC8D0];
  v4 = *a2;
  v5 = *a3;
  v6 = *(_DWORD *)this;
  do
  {
    v7 = dword_208FD6F2C[v3] + v4 + v6 * (dword_208FD6F4C[v3] + v5);
    if (v7 < 1)
      v8 = 0;
    else
      v8 = *(unsigned __int8 *)(*((_QWORD *)this + 5) + v7);
    v16[v3++] = v8 != 0;
  }
  while (v3 != 8);
  v9 = 0;
  v10 = 0;
  do
  {
    v11 = v16[v9++];
    if (v11 != v16[v9 & 7])
      ++v10;
  }
  while (v9 != 8);
  if (v10 == 2)
  {
    for (i = 0; i != 8; ++i)
    {
      if (!v16[i])
        break;
    }
    v13 = 0;
    while (1)
    {
      v14 = ((_BYTE)i + (_BYTE)v13) & 7;
      if (v16[v14])
        break;
      if (++v13 == 8)
      {
        v14 = 0;
        break;
      }
    }
    *a2 = v4 + dword_208FD6F2C[v14];
    *a3 += dword_208FD6F4C[v14];
  }
  return 0;
}

void rdpReduce(uint64_t a1@<X0>, double **a2@<X8>, float a3@<S0>)
{
  uint64_t v4;
  double *v5;
  uint64_t v6;
  unint64_t v7;
  double v10;
  double v11;
  double v12;
  double v13;
  float v14;
  double v15;
  double v16;
  double *v17;
  float v18;
  int v19;
  uint64_t v20;
  double v21;
  double v22;
  float v23;
  double *v24;
  double *v25;
  double *v26;
  uint64_t v27;
  double *v28;
  double *v29;
  double *v30;
  double *v31;
  double *v32;
  uint64_t v33;
  unint64_t v34;
  uint64_t v35;
  unint64_t v36;
  char *v37;
  double *v38;
  double *v39;
  char *__p;
  char *v41;
  void *v42;
  void *v43;
  uint64_t v44;
  void *v45;
  void *v46;
  uint64_t v47;

  v5 = *(double **)a1;
  v4 = *(_QWORD *)(a1 + 8);
  v6 = v4 - *(_QWORD *)a1;
  v7 = v6 >> 4;
  if ((unint64_t)v6 > 0x2F)
  {
    v10 = *v5;
    v11 = v5[1];
    v13 = *(double *)(v4 - 16);
    v12 = *(double *)(v4 - 8);
    if (v7 - 1 < 2)
    {
      v19 = -1;
      v18 = 0.0;
    }
    else
    {
      v14 = v13 - v10;
      v15 = (v12 - v11) / v14;
      v16 = sqrt(v15 * v15 + 1.0);
      v17 = v5 + 3;
      v18 = 0.0;
      v19 = -1;
      v20 = 2;
      do
      {
        v21 = *(v17 - 1);
        if (v10 == v13)
          v22 = vabdd_f64(v21, v10);
        else
          v22 = fabs(v11 - v15 * v10 - (*v17 - v15 * v21)) / v16;
        v23 = v22;
        if (v18 < v23)
        {
          v18 = v23;
          v19 = v20 - 1;
        }
        v17 += 2;
        ++v20;
      }
      while (v7 != v20);
    }
    if (v18 <= a3)
    {
      *a2 = 0;
      a2[1] = 0;
      a2[2] = 0;
      v24 = (double *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKDebugDrawPacket::color4>>((uint64_t)(a2 + 2), 1uLL);
      v25 = *a2;
      v26 = a2[1];
      v28 = &v24[2 * v27];
      *v24 = v10;
      v24[1] = v11;
      v29 = v24 + 2;
      v30 = v24;
      if (v26 != v25)
      {
        do
        {
          *((_OWORD *)v30 - 1) = *((_OWORD *)v26 - 1);
          v30 -= 2;
          v26 -= 2;
        }
        while (v26 != v25);
        v25 = *a2;
      }
      *a2 = v30;
      a2[1] = v29;
      a2[2] = v28;
      if (v25)
      {
        operator delete(v25);
        v28 = a2[2];
      }
      a2[1] = v29;
      if (v29 >= v28)
      {
        v32 = *a2;
        v33 = ((char *)v29 - (char *)*a2) >> 4;
        v34 = v33 + 1;
        if ((unint64_t)(v33 + 1) >> 60)
          std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
        v35 = (char *)v28 - (char *)v32;
        if (v35 >> 3 > v34)
          v34 = v35 >> 3;
        if ((unint64_t)v35 >= 0x7FFFFFFFFFFFFFF0)
          v36 = 0xFFFFFFFFFFFFFFFLL;
        else
          v36 = v34;
        if (v36)
        {
          v37 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKDebugDrawPacket::color4>>((uint64_t)(a2 + 2), v36);
          v32 = *a2;
          v29 = a2[1];
        }
        else
        {
          v37 = 0;
        }
        v38 = (double *)&v37[16 * v33];
        v39 = (double *)&v37[16 * v36];
        *v38 = v13;
        v38[1] = v12;
        v31 = v38 + 2;
        if (v29 != v32)
        {
          do
          {
            *((_OWORD *)v38 - 1) = *((_OWORD *)v29 - 1);
            v38 -= 2;
            v29 -= 2;
          }
          while (v29 != v32);
          v32 = *a2;
        }
        *a2 = v38;
        a2[1] = v31;
        a2[2] = v39;
        if (v32)
          operator delete(v32);
      }
      else
      {
        v24[2] = v13;
        v24[3] = v12;
        v31 = v24 + 4;
      }
      a2[1] = v31;
    }
    else
    {
      v45 = 0;
      v46 = 0;
      v47 = 0;
      std::vector<CGPoint>::__insert_with_size[abi:ne180100]<std::__wrap_iter<CGPoint const*>,std::__wrap_iter<CGPoint const*>>((uint64_t)&v45, 0, (char *)v5, (char *)&v5[2 * v19 + 2], (16 * v19 + 16) >> 4);
      v42 = 0;
      v43 = 0;
      v44 = 0;
      std::vector<CGPoint>::__insert_with_size[abi:ne180100]<std::__wrap_iter<CGPoint const*>,std::__wrap_iter<CGPoint const*>>((uint64_t)&v42, 0, (char *)(*(_QWORD *)a1 + 16 * v19), *(char **)(a1 + 8), (*(_QWORD *)(a1 + 8) - (*(_QWORD *)a1 + 16 * v19)) >> 4);
      rdpReduce(&v45, a3);
      rdpReduce(&v42, a3);
      std::vector<CGPoint>::__insert_with_size[abi:ne180100]<std::__wrap_iter<CGPoint*>,std::__wrap_iter<CGPoint*>>((uint64_t)a2, (uint64_t)a2[1], __p + 16, v41, (v41 - (__p + 16)) >> 4);
      if (__p)
        operator delete(__p);
      if (v42)
      {
        v43 = v42;
        operator delete(v42);
      }
      if (v45)
      {
        v46 = v45;
        operator delete(v45);
      }
    }
  }
  else
  {
    *a2 = 0;
    a2[1] = 0;
    a2[2] = 0;
    std::vector<CGPoint>::__init_with_size[abi:ne180100]<CGPoint*,CGPoint*>(a2, v5, v4, v7);
  }
}

void sub_208FC60A8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, uint64_t a15, void *a16, uint64_t a17)
{
  uint64_t v17;
  void *v19;

  if (__p)
    operator delete(__p);
  v19 = *(void **)v17;
  if (*(_QWORD *)v17)
  {
    *(_QWORD *)(v17 + 8) = v19;
    operator delete(v19);
  }
  if (a13)
    operator delete(a13);
  if (a16)
    operator delete(a16);
  _Unwind_Resume(exception_object);
}

void mooreNeighborTracing(uint64_t a1, int a2, int a3, uint64_t a4)
{
  int v8;
  uint64_t v9;
  size_t v10;
  _BYTE *v11;
  _BYTE *v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  _BYTE *v16;
  uint64_t v17;
  char *v18;
  _BYTE *v19;
  char v20;
  void *v21;
  BOOL v22;
  int v23;
  int v24;
  int v25;
  int v26;
  int v27;
  uint64_t v28;
  BOOL v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  int v33;
  int v34;
  int v35;
  int v36;
  uint64_t v37;
  uint64_t v38;
  int v39;
  double v41;
  double v42;
  unint64_t v43;
  double *v44;
  double *v45;
  double *v46;
  uint64_t v47;
  unint64_t v48;
  uint64_t v49;
  unint64_t v50;
  char *v51;
  double *v52;
  double *v53;
  uint64_t v54;
  int v55;
  int v56;
  int v57;
  int v58;
  int v59;
  _BYTE v60[12];
  uint64_t v61;
  int v62;
  uint64_t v63;
  int v64;
  int v65;
  int v66;
  int v67;
  int v68;
  uint64_t v69;
  int v70;
  int v71;
  int v72;
  int v73;
  int v74;
  int v75;
  int v76;
  uint64_t v77;

  v77 = *MEMORY[0x24BDAC8D0];
  v8 = a3 + 2;
  v9 = (a2 + 2);
  v10 = (a3 + 2) * (int)v9;
  v11 = malloc_type_malloc(v10, 0xF7ACFA6uLL);
  v12 = v11;
  v55 = a2;
  if (a2 >= -1)
  {
    v13 = 0;
    if (v8 <= 1)
      v14 = 1;
    else
      v14 = v8;
    v15 = (char *)(~(uint64_t)a2 + a1);
    v16 = v11;
    do
    {
      if (a3 >= -1)
      {
        v17 = 0;
        v18 = v15;
        v19 = v16;
        do
        {
          v20 = 0;
          if (v13 && v17 && v13 != a2 + 1 && a3 + 1 != v17)
            v20 = *v18;
          *v19 = v20;
          ++v17;
          v19 += v9;
          v18 += a2;
        }
        while (v14 != v17);
      }
      ++v13;
      ++v16;
      ++v15;
    }
    while (v13 != v9);
  }
  v21 = malloc_type_malloc(v10, 0xC9BDD9EFuLL);
  bzero(v21, v10);
  if (a3 >= -1)
  {
    *(_DWORD *)&v60[8] = 0;
    v22 = 0;
    v23 = -3 - a2;
    v24 = -2 - a2;
    v25 = ~a2;
    v26 = a2 + 3;
    v27 = a2 + 1;
    v28 = (int)v9;
    v54 = v8;
    v59 = -2 - a2;
    *(_QWORD *)v60 = (-3 - a2);
    v57 = a2 + 3;
    v58 = ~a2;
    v56 = a2 + 1;
    while (v55 < -1)
    {
      v29 = 0;
LABEL_20:
      if (!v29)
      {
        ++*(_QWORD *)&v60[4];
        if (*(uint64_t *)&v60[4] < v54)
          continue;
      }
      goto LABEL_16;
    }
    v30 = 0;
    v31 = *(_QWORD *)&v60[4] * v28;
    v61 = *(_QWORD *)&v60[4] * v28;
LABEL_24:
    v32 = v30 + v31;
    if (*((_BYTE *)v21 + v30 + v31) == 1 && !v22)
      goto LABEL_16;
    if (v12[v32] != 1 || v22)
    {
      v29 = 0;
      goto LABEL_62;
    }
    v33 = 0;
    v34 = 1;
    *((_BYTE *)v21 + v32) = 1;
    v63 = 0x7FFFFFFFFLL;
    v64 = v23;
    v65 = 7;
    v66 = v24;
    v67 = 1;
    v68 = v25;
    v69 = 0x100000001;
    v70 = 3;
    v71 = v26;
    v72 = 3;
    v73 = v9;
    v74 = 5;
    v75 = v27;
    v35 = v30 + v31;
    v76 = 5;
    while (1)
    {
      v36 = -1;
      while (1)
      {
        v37 = v34 - 1;
        v38 = *((int *)&v63 + 2 * v37) + (uint64_t)v35;
        v22 = v12[v38] == 1;
        if (v12[v38] == 1)
          break;
        if (v34 <= 0)
          v39 = -(-v34 & 7);
        else
          v39 = v34 & 7;
        v34 = v39 + 1;
        if (++v36 >= 9)
          goto LABEL_61;
      }
      v35 += *((_DWORD *)&v63 + 2 * v37);
      v34 = *((_DWORD *)&v63 + 2 * v37 + 1);
      if ((_DWORD)v38 == (_DWORD)v32)
      {
        if (v34 == 1 || v33 > 1)
        {
LABEL_61:
          v29 = v22;
          if (v22)
            goto LABEL_20;
LABEL_62:
          if (++v30 >= v28)
            goto LABEL_20;
          goto LABEL_24;
        }
        ++v33;
      }
      *((_BYTE *)v21 + v38) = 1;
      v41 = (double)(~((int)v38 / (int)v9 * (int)v9) + (int)v38);
      v42 = (double)((int)v38 / (int)v9 - 1);
      v44 = *(double **)(a4 + 8);
      v43 = *(_QWORD *)(a4 + 16);
      if ((unint64_t)v44 >= v43)
      {
        v46 = *(double **)a4;
        v47 = ((uint64_t)v44 - *(_QWORD *)a4) >> 4;
        v48 = v47 + 1;
        if ((unint64_t)(v47 + 1) >> 60)
          std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
        v62 = v33;
        v49 = v43 - (_QWORD)v46;
        if (v49 >> 3 > v48)
          v48 = v49 >> 3;
        if ((unint64_t)v49 >= 0x7FFFFFFFFFFFFFF0)
          v50 = 0xFFFFFFFFFFFFFFFLL;
        else
          v50 = v48;
        if (v50)
        {
          v51 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKDebugDrawPacket::color4>>(a4 + 16, v50);
          v46 = *(double **)a4;
          v44 = *(double **)(a4 + 8);
        }
        else
        {
          v51 = 0;
        }
        v52 = (double *)&v51[16 * v47];
        *v52 = v41;
        v52[1] = v42;
        v53 = v52;
        if (v44 != v46)
        {
          do
          {
            *((_OWORD *)v53 - 1) = *((_OWORD *)v44 - 1);
            v53 -= 2;
            v44 -= 2;
          }
          while (v44 != v46);
          v46 = *(double **)a4;
        }
        v45 = v52 + 2;
        *(_QWORD *)a4 = v53;
        *(_QWORD *)(a4 + 8) = v52 + 2;
        *(_QWORD *)(a4 + 16) = &v51[16 * v50];
        if (v46)
          operator delete(v46);
        v24 = v59;
        v23 = *(_DWORD *)v60;
        v26 = v57;
        v25 = v58;
        v27 = v56;
        v28 = (int)v9;
        v31 = v61;
        v33 = v62;
      }
      else
      {
        *v44 = v41;
        v44[1] = v42;
        v45 = v44 + 2;
      }
      *(_QWORD *)(a4 + 8) = v45;
    }
  }
LABEL_16:
  free(v21);
  free(v12);
}

void PKCGrid::traceOutline(int *a1, char **a2, float a3)
{
  void *v6;
  void *v7;
  unsigned __int8 *v8;
  unsigned __int8 *v9;
  BOOL *v10;
  int v11;
  double *v12;
  char *v13;
  uint64_t v14;
  unint64_t v15;
  unint64_t v16;
  char *v17;
  char *v18;
  char *v19;
  char *v20;
  char *v21;
  char *v22;
  char *v23;
  char *v24;
  char *v25;
  char *v26;
  char *v27;
  double *v28;
  double *v29;

  a2[1] = *a2;
  v6 = malloc_type_malloc(a1[1] * (uint64_t)*a1, 0x21AD04B8uLL);
  v7 = v6;
  v8 = (unsigned __int8 *)*((_QWORD *)a1 + 5);
  v9 = (unsigned __int8 *)*((_QWORD *)a1 + 6);
  if (v8 != v9)
  {
    v10 = (BOOL *)v6;
    do
    {
      v11 = *v8++;
      *v10++ = v11 != 0;
    }
    while (v8 != v9);
  }
  mooreNeighborTracing((uint64_t)v6, *a1, a1[1], (uint64_t)a2);
  free(v7);
  if (a2[1] != *a2 && a1[1] + *a1 >= 67)
  {
    rdpReduce((uint64_t)a2, &v28, a3);
    v25 = 0;
    v26 = 0;
    v27 = 0;
    v12 = v29;
    if (v29 == v28)
    {
      v22 = 0;
      v13 = 0;
      v21 = 0;
    }
    else
    {
      v13 = 0;
      do
      {
        v12 -= 2;
        if (v13 >= v27)
        {
          v14 = (v13 - v25) >> 4;
          if ((unint64_t)(v14 + 1) >> 60)
            std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
          v15 = (v27 - v25) >> 3;
          if (v15 <= v14 + 1)
            v15 = v14 + 1;
          if ((unint64_t)(v27 - v25) >= 0x7FFFFFFFFFFFFFF0)
            v16 = 0xFFFFFFFFFFFFFFFLL;
          else
            v16 = v15;
          if (v16)
            v17 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKDebugDrawPacket::color4>>((uint64_t)&v27, v16);
          else
            v17 = 0;
          v18 = &v17[16 * v14];
          *(_OWORD *)v18 = *(_OWORD *)v12;
          v19 = v26;
          v20 = v18;
          if (v26 != v25)
          {
            do
            {
              *((_OWORD *)v20 - 1) = *((_OWORD *)v19 - 1);
              v20 -= 16;
              v19 -= 16;
            }
            while (v19 != v25);
            v19 = v25;
          }
          v13 = v18 + 16;
          v25 = v20;
          v27 = &v17[16 * v16];
          if (v19)
            operator delete(v19);
        }
        else
        {
          *(_OWORD *)v13 = *(_OWORD *)v12;
          v13 += 16;
        }
        v26 = v13;
      }
      while (v12 != v28);
      v21 = v25;
      v22 = v27;
    }
    v23 = *a2;
    *a2 = v21;
    a2[1] = v13;
    v24 = a2[2];
    a2[2] = v22;
    v27 = v24;
    if (v23)
    {
      operator delete(v23);
      v12 = v28;
    }
    if (v12)
    {
      v29 = v12;
      operator delete(v12);
    }
  }
}

void sub_208FC6760(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, void *a12, uint64_t a13)
{
  if (__p)
    operator delete(__p);
  if (a12)
    operator delete(a12);
  _Unwind_Resume(exception_object);
}

void PKCGrid::labelGrid(PKCGrid *this)
{
  uint64_t v2;
  _QWORD *v3;
  _BYTE *v4;
  _BYTE *v5;
  unint64_t v6;
  void **v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  BOOL v11;
  BOOL v12;
  uint64_t v13;
  unint64_t v14;
  char *v15;
  _DWORD *v16;
  char *v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  unint64_t v21;
  char *v22;
  char *v23;
  int v24;

  v3 = (_QWORD *)((char *)this + 112);
  v2 = *((_QWORD *)this + 14);
  v4 = (_BYTE *)*((_QWORD *)this + 5);
  v5 = (_BYTE *)*((_QWORD *)this + 6);
  v6 = *((_QWORD *)this + 15) - v2;
  if (v5 - v4 <= v6)
  {
    if (v5 - v4 < v6)
      *((_QWORD *)this + 15) = v2 + v5 - v4;
  }
  else
  {
    std::vector<unsigned char>::__append((unint64_t *)this + 14, v5 - v4 - v6);
    v4 = (_BYTE *)*((_QWORD *)this + 5);
    v5 = (_BYTE *)*((_QWORD *)this + 6);
  }
  v7 = (void **)((char *)this + 88);
  *((_QWORD *)this + 12) = *((_QWORD *)this + 11);
  if (v4 != v5)
  {
    v8 = 0;
    do
    {
      if (*v4)
      {
        v9 = *(_DWORD *)this;
        v10 = (int)v8 / (int)v9;
        if ((int)v8 % (int)v9)
          v11 = (int)v8 % (int)v9 == (_DWORD)v9 - 1;
        else
          v11 = 1;
        v12 = v11 || v10 == 0;
        if (!v12
          && v10 != *((_DWORD *)this + 1) - 1
          && (v13 = *((_QWORD *)this + 5), *(_BYTE *)(v13 + (v8 + 1)))
          && *(_BYTE *)(v8 + v13 - 1)
          && *(_BYTE *)(v13 + v8 + v9)
          && *(_BYTE *)(v13 + v8 - v9))
        {
          *(_BYTE *)(*v3 + v8) = -3;
        }
        else
        {
          *(_BYTE *)(*((_QWORD *)this + 14) + v8) = 0;
          v15 = (char *)*((_QWORD *)this + 12);
          v14 = *((_QWORD *)this + 13);
          if ((unint64_t)v15 >= v14)
          {
            v17 = (char *)*v7;
            v18 = (v15 - (_BYTE *)*v7) >> 2;
            v19 = v18 + 1;
            if ((unint64_t)(v18 + 1) >> 62)
              std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
            v20 = v14 - (_QWORD)v17;
            if (v20 >> 1 > v19)
              v19 = v20 >> 1;
            if ((unint64_t)v20 >= 0x7FFFFFFFFFFFFFFCLL)
              v21 = 0x3FFFFFFFFFFFFFFFLL;
            else
              v21 = v19;
            if (v21)
            {
              v22 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<int>>((uint64_t)this + 104, v21);
              v17 = (char *)*((_QWORD *)this + 11);
              v15 = (char *)*((_QWORD *)this + 12);
            }
            else
            {
              v22 = 0;
            }
            v23 = &v22[4 * v18];
            *(_DWORD *)v23 = v8;
            v16 = v23 + 4;
            while (v15 != v17)
            {
              v24 = *((_DWORD *)v15 - 1);
              v15 -= 4;
              *((_DWORD *)v23 - 1) = v24;
              v23 -= 4;
            }
            *((_QWORD *)this + 11) = v23;
            *((_QWORD *)this + 12) = v16;
            *((_QWORD *)this + 13) = &v22[4 * v21];
            if (v17)
              operator delete(v17);
          }
          else
          {
            *(_DWORD *)v15 = v8;
            v16 = v15 + 4;
          }
          *((_QWORD *)this + 12) = v16;
        }
      }
      else
      {
        *(_BYTE *)(*v3 + v8) = 3;
      }
      ++v8;
      ++v4;
    }
    while (v4 != v5);
  }
}

void PKCGrid::calcQuadTree(PKCGrid *this@<X0>, const CGRect *a2@<X1>, QuadTree **a3@<X8>)
{
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;
  int *v8;
  int *i;
  uint64_t v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  char *v15;
  char *v16;
  char *v17;
  char *v18;
  char *v19;
  uint64_t v20;
  unint64_t v21;
  uint64_t v22;
  unint64_t v23;
  char *v24;
  char *v25;
  uint64_t v26;
  unint64_t v27;
  uint64_t v28;
  unint64_t v29;
  char *v30;
  char *v31;
  int v32;
  char *v33;
  int v34;
  uint64_t v35;
  uint64_t v36;
  int v37;
  char *v38;
  char *v39;
  char *v40;
  char *v41;
  char *v42;
  uint64_t v43;
  unint64_t v44;
  uint64_t v45;
  unint64_t v46;
  char *v47;
  char *v48;
  uint64_t v49;
  unint64_t v50;
  uint64_t v51;
  unint64_t v52;
  char *v53;
  char *v54;
  int v55;
  char *v56;
  int v57;
  int v58;
  uint64_t v59;
  uint64_t v60;
  int v61;
  int v62;
  char *v63;
  char *v64;
  int v65;
  char *v66;
  char *v67;
  char *v68;
  uint64_t v69;
  unint64_t v70;
  uint64_t v71;
  unint64_t v72;
  char *v73;
  char *v74;
  uint64_t v75;
  unint64_t v76;
  uint64_t v77;
  unint64_t v78;
  char *v79;
  char *v80;
  int v81;
  char *v82;
  int v83;
  uint64_t v84;
  uint64_t v85;
  int v86;
  int v87;
  char *v88;
  char *v89;
  int v90;
  char *v91;
  char *v92;
  char *v93;
  uint64_t v94;
  unint64_t v95;
  uint64_t v96;
  unint64_t v97;
  char *v98;
  char *v99;
  uint64_t v100;
  unint64_t v101;
  uint64_t v102;
  unint64_t v103;
  char *v104;
  char *v105;
  int v106;
  char *v107;
  int v108;
  double x;
  float v110;
  double width;
  float v112;
  double y;
  float v114;
  double height;
  float v116;
  float v117;
  float v118;
  float v119;
  float v120;
  float v121;
  float v122;
  float v123;
  float v124;
  _DWORD *v125;
  _DWORD *v126;
  float v128;
  float v129;
  float v130;
  float v131;
  float v132;
  void *v133;
  char *v134;
  char *v135;
  void *__p;
  char *v137;
  char *v138;

  v5 = (uint64_t *)((char *)this + 112);
  *((_QWORD *)this + 15) = *((_QWORD *)this + 14);
  v7 = *((_QWORD *)this + 5);
  v6 = *((_QWORD *)this + 6);
  if (v6 != v7)
    std::vector<unsigned char>::__append((unint64_t *)this + 14, v6 - v7);
  __p = 0;
  v137 = 0;
  v138 = 0;
  v133 = 0;
  v134 = 0;
  v135 = 0;
  PKCGrid::labelGrid(this);
  v8 = (int *)*((_QWORD *)this + 11);
  for (i = (int *)*((_QWORD *)this + 12); v8 != i; ++v8)
  {
    v10 = *v8;
    v11 = (int)v10 % *(_DWORD *)this;
    if (v11 < *(_DWORD *)this - 2)
    {
      v12 = v10 + 1;
      v13 = *v5;
      v14 = *(unsigned __int8 *)(*v5 + v10 + 1);
      if (v14 == 3)
      {
        *(_BYTE *)(v13 + v12) = 1;
        v17 = v134;
        if (v134 >= v135)
        {
          v25 = (char *)v133;
          v26 = (v134 - (_BYTE *)v133) >> 2;
          v27 = v26 + 1;
          if ((unint64_t)(v26 + 1) >> 62)
            std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
          v28 = v135 - (_BYTE *)v133;
          if ((v135 - (_BYTE *)v133) >> 1 > v27)
            v27 = v28 >> 1;
          if ((unint64_t)v28 >= 0x7FFFFFFFFFFFFFFCLL)
            v29 = 0x3FFFFFFFFFFFFFFFLL;
          else
            v29 = v27;
          if (v29)
          {
            v30 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<int>>((uint64_t)&v135, v29);
            v25 = (char *)v133;
            v17 = v134;
          }
          else
          {
            v30 = 0;
          }
          v33 = &v30[4 * v26];
          *(_DWORD *)v33 = v12;
          v18 = v33 + 4;
          while (v17 != v25)
          {
            v34 = *((_DWORD *)v17 - 1);
            v17 -= 4;
            *((_DWORD *)v33 - 1) = v34;
            v33 -= 4;
          }
          v133 = v33;
          v134 = v18;
          v135 = &v30[4 * v29];
          if (v25)
            operator delete(v25);
        }
        else
        {
          *(_DWORD *)v134 = v12;
          v18 = v17 + 4;
        }
        v134 = v18;
      }
      else if (v14 == 253)
      {
        *(_BYTE *)(v13 + v12) = -1;
        v15 = v137;
        if (v137 >= v138)
        {
          v19 = (char *)__p;
          v20 = (v137 - (_BYTE *)__p) >> 2;
          v21 = v20 + 1;
          if ((unint64_t)(v20 + 1) >> 62)
            std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
          v22 = v138 - (_BYTE *)__p;
          if ((v138 - (_BYTE *)__p) >> 1 > v21)
            v21 = v22 >> 1;
          if ((unint64_t)v22 >= 0x7FFFFFFFFFFFFFFCLL)
            v23 = 0x3FFFFFFFFFFFFFFFLL;
          else
            v23 = v21;
          if (v23)
          {
            v24 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<int>>((uint64_t)&v138, v23);
            v19 = (char *)__p;
            v15 = v137;
          }
          else
          {
            v24 = 0;
          }
          v31 = &v24[4 * v20];
          *(_DWORD *)v31 = v12;
          v16 = v31 + 4;
          while (v15 != v19)
          {
            v32 = *((_DWORD *)v15 - 1);
            v15 -= 4;
            *((_DWORD *)v31 - 1) = v32;
            v31 -= 4;
          }
          __p = v31;
          v137 = v16;
          v138 = &v24[4 * v23];
          if (v19)
            operator delete(v19);
        }
        else
        {
          *(_DWORD *)v137 = v12;
          v16 = v15 + 4;
        }
        v137 = v16;
      }
    }
    if (v11 >= 1)
    {
      v35 = v10 - 1;
      v36 = *v5;
      v37 = *(unsigned __int8 *)(*v5 + v10 - 1);
      if (v37 == 3)
      {
        *(_BYTE *)(v36 + v35) = 1;
        v40 = v134;
        if (v134 >= v135)
        {
          v48 = (char *)v133;
          v49 = (v134 - (_BYTE *)v133) >> 2;
          v50 = v49 + 1;
          if ((unint64_t)(v49 + 1) >> 62)
            std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
          v51 = v135 - (_BYTE *)v133;
          if ((v135 - (_BYTE *)v133) >> 1 > v50)
            v50 = v51 >> 1;
          if ((unint64_t)v51 >= 0x7FFFFFFFFFFFFFFCLL)
            v52 = 0x3FFFFFFFFFFFFFFFLL;
          else
            v52 = v50;
          if (v52)
          {
            v53 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<int>>((uint64_t)&v135, v52);
            v48 = (char *)v133;
            v40 = v134;
          }
          else
          {
            v53 = 0;
          }
          v56 = &v53[4 * v49];
          *(_DWORD *)v56 = v35;
          v41 = v56 + 4;
          while (v40 != v48)
          {
            v57 = *((_DWORD *)v40 - 1);
            v40 -= 4;
            *((_DWORD *)v56 - 1) = v57;
            v56 -= 4;
          }
          v133 = v56;
          v134 = v41;
          v135 = &v53[4 * v52];
          if (v48)
            operator delete(v48);
        }
        else
        {
          *(_DWORD *)v134 = v35;
          v41 = v40 + 4;
        }
        v134 = v41;
      }
      else if (v37 == 253)
      {
        *(_BYTE *)(v36 + v35) = -1;
        v38 = v137;
        if (v137 >= v138)
        {
          v42 = (char *)__p;
          v43 = (v137 - (_BYTE *)__p) >> 2;
          v44 = v43 + 1;
          if ((unint64_t)(v43 + 1) >> 62)
            std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
          v45 = v138 - (_BYTE *)__p;
          if ((v138 - (_BYTE *)__p) >> 1 > v44)
            v44 = v45 >> 1;
          if ((unint64_t)v45 >= 0x7FFFFFFFFFFFFFFCLL)
            v46 = 0x3FFFFFFFFFFFFFFFLL;
          else
            v46 = v44;
          if (v46)
          {
            v47 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<int>>((uint64_t)&v138, v46);
            v42 = (char *)__p;
            v38 = v137;
          }
          else
          {
            v47 = 0;
          }
          v54 = &v47[4 * v43];
          *(_DWORD *)v54 = v35;
          v39 = v54 + 4;
          while (v38 != v42)
          {
            v55 = *((_DWORD *)v38 - 1);
            v38 -= 4;
            *((_DWORD *)v54 - 1) = v55;
            v54 -= 4;
          }
          __p = v54;
          v137 = v39;
          v138 = &v47[4 * v46];
          if (v42)
            operator delete(v42);
        }
        else
        {
          *(_DWORD *)v137 = v35;
          v39 = v38 + 4;
        }
        v137 = v39;
      }
    }
    v58 = (int)v10 / *(_DWORD *)this;
    if (v58 < *((_DWORD *)this + 1) - 2)
    {
      v59 = *(_DWORD *)this + (int)v10;
      v60 = *v5;
      v61 = *(unsigned __int8 *)(*v5 + v59);
      if (v61 == 3)
      {
        *(_BYTE *)(v60 + v59) = 1;
        v65 = *(_DWORD *)this + v10;
        v66 = v134;
        if (v134 >= v135)
        {
          v74 = (char *)v133;
          v75 = (v134 - (_BYTE *)v133) >> 2;
          v76 = v75 + 1;
          if ((unint64_t)(v75 + 1) >> 62)
            std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
          v77 = v135 - (_BYTE *)v133;
          if ((v135 - (_BYTE *)v133) >> 1 > v76)
            v76 = v77 >> 1;
          if ((unint64_t)v77 >= 0x7FFFFFFFFFFFFFFCLL)
            v78 = 0x3FFFFFFFFFFFFFFFLL;
          else
            v78 = v76;
          if (v78)
          {
            v79 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<int>>((uint64_t)&v135, v78);
            v74 = (char *)v133;
            v66 = v134;
          }
          else
          {
            v79 = 0;
          }
          v82 = &v79[4 * v75];
          *(_DWORD *)v82 = v65;
          v67 = v82 + 4;
          while (v66 != v74)
          {
            v83 = *((_DWORD *)v66 - 1);
            v66 -= 4;
            *((_DWORD *)v82 - 1) = v83;
            v82 -= 4;
          }
          v133 = v82;
          v134 = v67;
          v135 = &v79[4 * v78];
          if (v74)
            operator delete(v74);
        }
        else
        {
          *(_DWORD *)v134 = v65;
          v67 = v66 + 4;
        }
        v134 = v67;
      }
      else if (v61 == 253)
      {
        *(_BYTE *)(v60 + v59) = -1;
        v62 = *(_DWORD *)this + v10;
        v63 = v137;
        if (v137 >= v138)
        {
          v68 = (char *)__p;
          v69 = (v137 - (_BYTE *)__p) >> 2;
          v70 = v69 + 1;
          if ((unint64_t)(v69 + 1) >> 62)
            std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
          v71 = v138 - (_BYTE *)__p;
          if ((v138 - (_BYTE *)__p) >> 1 > v70)
            v70 = v71 >> 1;
          if ((unint64_t)v71 >= 0x7FFFFFFFFFFFFFFCLL)
            v72 = 0x3FFFFFFFFFFFFFFFLL;
          else
            v72 = v70;
          if (v72)
          {
            v73 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<int>>((uint64_t)&v138, v72);
            v68 = (char *)__p;
            v63 = v137;
          }
          else
          {
            v73 = 0;
          }
          v80 = &v73[4 * v69];
          *(_DWORD *)v80 = v62;
          v64 = v80 + 4;
          while (v63 != v68)
          {
            v81 = *((_DWORD *)v63 - 1);
            v63 -= 4;
            *((_DWORD *)v80 - 1) = v81;
            v80 -= 4;
          }
          __p = v80;
          v137 = v64;
          v138 = &v73[4 * v72];
          if (v68)
            operator delete(v68);
        }
        else
        {
          *(_DWORD *)v137 = v62;
          v64 = v63 + 4;
        }
        v137 = v64;
      }
    }
    if (v58 >= 1)
    {
      v84 = v10 - *(_DWORD *)this;
      v85 = *((_QWORD *)this + 14);
      v86 = *(unsigned __int8 *)(v85 + v84);
      if (v86 == 3)
      {
        *(_BYTE *)(v85 + v84) = 1;
        v90 = v10 - *(_DWORD *)this;
        v91 = v134;
        if (v134 >= v135)
        {
          v99 = (char *)v133;
          v100 = (v134 - (_BYTE *)v133) >> 2;
          v101 = v100 + 1;
          if ((unint64_t)(v100 + 1) >> 62)
            std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
          v102 = v135 - (_BYTE *)v133;
          if ((v135 - (_BYTE *)v133) >> 1 > v101)
            v101 = v102 >> 1;
          if ((unint64_t)v102 >= 0x7FFFFFFFFFFFFFFCLL)
            v103 = 0x3FFFFFFFFFFFFFFFLL;
          else
            v103 = v101;
          if (v103)
          {
            v104 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<int>>((uint64_t)&v135, v103);
            v99 = (char *)v133;
            v91 = v134;
          }
          else
          {
            v104 = 0;
          }
          v107 = &v104[4 * v100];
          *(_DWORD *)v107 = v90;
          v92 = v107 + 4;
          while (v91 != v99)
          {
            v108 = *((_DWORD *)v91 - 1);
            v91 -= 4;
            *((_DWORD *)v107 - 1) = v108;
            v107 -= 4;
          }
          v133 = v107;
          v134 = v92;
          v135 = &v104[4 * v103];
          if (v99)
            operator delete(v99);
        }
        else
        {
          *(_DWORD *)v134 = v90;
          v92 = v91 + 4;
        }
        v134 = v92;
      }
      else if (v86 == 253)
      {
        *(_BYTE *)(v85 + v84) = -1;
        v87 = v10 - *(_DWORD *)this;
        v88 = v137;
        if (v137 >= v138)
        {
          v93 = (char *)__p;
          v94 = (v137 - (_BYTE *)__p) >> 2;
          v95 = v94 + 1;
          if ((unint64_t)(v94 + 1) >> 62)
            std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
          v96 = v138 - (_BYTE *)__p;
          if ((v138 - (_BYTE *)__p) >> 1 > v95)
            v95 = v96 >> 1;
          if ((unint64_t)v96 >= 0x7FFFFFFFFFFFFFFCLL)
            v97 = 0x3FFFFFFFFFFFFFFFLL;
          else
            v97 = v95;
          if (v97)
          {
            v98 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<int>>((uint64_t)&v138, v97);
            v93 = (char *)__p;
            v88 = v137;
          }
          else
          {
            v98 = 0;
          }
          v105 = &v98[4 * v94];
          *(_DWORD *)v105 = v87;
          v89 = v105 + 4;
          while (v88 != v93)
          {
            v106 = *((_DWORD *)v88 - 1);
            v88 -= 4;
            *((_DWORD *)v105 - 1) = v106;
            v105 -= 4;
          }
          __p = v105;
          v137 = v89;
          v138 = &v98[4 * v97];
          if (v93)
            operator delete(v93);
        }
        else
        {
          *(_DWORD *)v137 = v87;
          v89 = v88 + 4;
        }
        v137 = v89;
      }
    }
  }
  x = a2->origin.x;
  v110 = PKGet_INV_PTM_RATIO();
  width = a2->size.width;
  v112 = PKGet_INV_PTM_RATIO();
  y = a2->origin.y;
  v114 = PKGet_INV_PTM_RATIO();
  height = a2->size.height;
  v116 = PKGet_INV_PTM_RATIO();
  v117 = x * v110;
  v118 = v117 + width * v112;
  v119 = y * v114;
  v120 = v119 + height * v116;
  v121 = v118 - v117;
  v122 = (float)(v118 - v117) * 0.5;
  v123 = v120 - v119;
  v124 = (float)(v120 - v119) * 0.5;
  v131 = v118 - v122;
  v132 = v117 - v122;
  v129 = v120 - v124;
  v130 = v119 - v124;
  v128 = 1.0 / (float)*(_DWORD *)this;
  std::allocate_shared[abi:ne180100]<QuadTree,std::allocator<QuadTree>,float,float,float,float,float,void>(&v132, &v131, &v130, &v129, &v128, a3);
  v125 = (_DWORD *)*((_QWORD *)this + 11);
  v126 = (_DWORD *)*((_QWORD *)this + 12);
  while (v125 != v126)
  {
    QuadTree::add(*a3, (float)(v117 + (float)((float)((float)(*v125 % *(_DWORD *)this) / (float)*(_DWORD *)this) * v121)) - v122, (float)(v119 + (float)((float)((float)(*v125 / *(_DWORD *)this) / (float)*((int *)this + 1)) * v123)) - v124, 1);
    ++v125;
  }
  if (v133)
  {
    v134 = (char *)v133;
    operator delete(v133);
  }
  if (__p)
  {
    v137 = (char *)__p;
    operator delete(__p);
  }
}

void sub_208FC7224(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, uint64_t a17, void *a18, uint64_t a19)
{
  if (__p)
    operator delete(__p);
  if (a18)
    operator delete(a18);
  _Unwind_Resume(exception_object);
}

void PKCGrid::calcLevelSet(PKCGrid *this, int a2)
{
  int *v4;
  int *v5;
  uint64_t v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  char *v11;
  char *v12;
  char *v13;
  char *v14;
  char *v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  unint64_t v19;
  char *v20;
  char *v21;
  uint64_t v22;
  unint64_t v23;
  uint64_t v24;
  unint64_t v25;
  char *v26;
  char *v27;
  int v28;
  char *v29;
  int v30;
  uint64_t v31;
  uint64_t v32;
  int v33;
  char *v34;
  char *v35;
  char *v36;
  char *v37;
  char *v38;
  uint64_t v39;
  unint64_t v40;
  uint64_t v41;
  unint64_t v42;
  char *v43;
  char *v44;
  uint64_t v45;
  unint64_t v46;
  uint64_t v47;
  unint64_t v48;
  char *v49;
  char *v50;
  int v51;
  char *v52;
  int v53;
  int v54;
  uint64_t v55;
  uint64_t v56;
  int v57;
  int v58;
  char *v59;
  char *v60;
  int v61;
  char *v62;
  char *v63;
  char *v64;
  uint64_t v65;
  unint64_t v66;
  uint64_t v67;
  unint64_t v68;
  char *v69;
  char *v70;
  uint64_t v71;
  unint64_t v72;
  uint64_t v73;
  unint64_t v74;
  char *v75;
  char *v76;
  int v77;
  char *v78;
  int v79;
  uint64_t v80;
  uint64_t v81;
  int v82;
  int v83;
  char *v84;
  char *v85;
  int v86;
  char *v87;
  char *v88;
  char *v89;
  uint64_t v90;
  unint64_t v91;
  uint64_t v92;
  unint64_t v93;
  char *v94;
  char *v95;
  uint64_t v96;
  unint64_t v97;
  uint64_t v98;
  unint64_t v99;
  char *v100;
  char *v101;
  int v102;
  char *v103;
  int v104;
  int *v105;
  int *v106;
  uint64_t v107;
  int v108;
  uint64_t v109;
  uint64_t v110;
  char *v111;
  char *v112;
  char *v113;
  uint64_t v114;
  unint64_t v115;
  uint64_t v116;
  unint64_t v117;
  char *v118;
  char *v119;
  int v120;
  uint64_t v121;
  uint64_t v122;
  char *v123;
  char *v124;
  char *v125;
  uint64_t v126;
  unint64_t v127;
  uint64_t v128;
  unint64_t v129;
  char *v130;
  char *v131;
  int v132;
  int v133;
  int v134;
  uint64_t v135;
  int v136;
  char *v137;
  char *v138;
  char *v139;
  uint64_t v140;
  unint64_t v141;
  uint64_t v142;
  unint64_t v143;
  char *v144;
  char *v145;
  int v146;
  uint64_t v147;
  uint64_t v148;
  int v149;
  char *v150;
  char *v151;
  char *v152;
  uint64_t v153;
  unint64_t v154;
  uint64_t v155;
  unint64_t v156;
  char *v157;
  char *v158;
  int v159;
  int *v160;
  uint64_t v161;
  int v162;
  uint64_t v163;
  uint64_t v164;
  char *v165;
  char *v166;
  char *v167;
  uint64_t v168;
  unint64_t v169;
  uint64_t v170;
  unint64_t v171;
  char *v172;
  char *v173;
  int v174;
  uint64_t v175;
  uint64_t v176;
  char *v177;
  char *v178;
  char *v179;
  uint64_t v180;
  unint64_t v181;
  uint64_t v182;
  unint64_t v183;
  char *v184;
  char *v185;
  int v186;
  int v187;
  int v188;
  uint64_t v189;
  int v190;
  char *v191;
  char *v192;
  char *v193;
  uint64_t v194;
  unint64_t v195;
  uint64_t v196;
  unint64_t v197;
  char *v198;
  char *v199;
  int v200;
  uint64_t v201;
  uint64_t v202;
  int v203;
  char *v204;
  char *v205;
  char *v206;
  uint64_t v207;
  unint64_t v208;
  uint64_t v209;
  unint64_t v210;
  char *v211;
  char *v212;
  int v213;
  char *v214;
  char *v215;
  char *v216;
  void *v217;
  char *v218;
  char *v219;
  void *v220;
  char *v221;
  char *v222;
  void *__p;
  char *v224;
  char *v225;

  PKCGrid::labelGrid(this);
  if (a2)
  {
    __p = 0;
    v224 = 0;
    v225 = 0;
    v220 = 0;
    v221 = 0;
    v222 = 0;
    v217 = 0;
    v218 = 0;
    v219 = 0;
    v214 = 0;
    v215 = 0;
    v216 = 0;
    v4 = (int *)*((_QWORD *)this + 11);
    v5 = (int *)*((_QWORD *)this + 12);
    if (v4 == v5)
    {
      v105 = 0;
    }
    else
    {
      do
      {
        v6 = *v4;
        v7 = (int)v6 % *(_DWORD *)this;
        if (v7 < *(_DWORD *)this - 2)
        {
          v8 = v6 + 1;
          v9 = *((_QWORD *)this + 14);
          v10 = *(unsigned __int8 *)(v9 + v6 + 1);
          if (v10 == 3)
          {
            *(_BYTE *)(v9 + v8) = 1;
            v13 = v221;
            if (v221 >= v222)
            {
              v21 = (char *)v220;
              v22 = (v221 - (_BYTE *)v220) >> 2;
              v23 = v22 + 1;
              if ((unint64_t)(v22 + 1) >> 62)
                std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
              v24 = v222 - (_BYTE *)v220;
              if ((v222 - (_BYTE *)v220) >> 1 > v23)
                v23 = v24 >> 1;
              if ((unint64_t)v24 >= 0x7FFFFFFFFFFFFFFCLL)
                v25 = 0x3FFFFFFFFFFFFFFFLL;
              else
                v25 = v23;
              if (v25)
              {
                v26 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<int>>((uint64_t)&v222, v25);
                v21 = (char *)v220;
                v13 = v221;
              }
              else
              {
                v26 = 0;
              }
              v29 = &v26[4 * v22];
              *(_DWORD *)v29 = v8;
              v14 = v29 + 4;
              while (v13 != v21)
              {
                v30 = *((_DWORD *)v13 - 1);
                v13 -= 4;
                *((_DWORD *)v29 - 1) = v30;
                v29 -= 4;
              }
              v220 = v29;
              v221 = v14;
              v222 = &v26[4 * v25];
              if (v21)
                operator delete(v21);
            }
            else
            {
              *(_DWORD *)v221 = v8;
              v14 = v13 + 4;
            }
            v221 = v14;
          }
          else if (v10 == 253)
          {
            *(_BYTE *)(v9 + v8) = -1;
            v11 = v224;
            if (v224 >= v225)
            {
              v15 = (char *)__p;
              v16 = (v224 - (_BYTE *)__p) >> 2;
              v17 = v16 + 1;
              if ((unint64_t)(v16 + 1) >> 62)
                std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
              v18 = v225 - (_BYTE *)__p;
              if ((v225 - (_BYTE *)__p) >> 1 > v17)
                v17 = v18 >> 1;
              if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFFCLL)
                v19 = 0x3FFFFFFFFFFFFFFFLL;
              else
                v19 = v17;
              if (v19)
              {
                v20 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<int>>((uint64_t)&v225, v19);
                v15 = (char *)__p;
                v11 = v224;
              }
              else
              {
                v20 = 0;
              }
              v27 = &v20[4 * v16];
              *(_DWORD *)v27 = v8;
              v12 = v27 + 4;
              while (v11 != v15)
              {
                v28 = *((_DWORD *)v11 - 1);
                v11 -= 4;
                *((_DWORD *)v27 - 1) = v28;
                v27 -= 4;
              }
              __p = v27;
              v224 = v12;
              v225 = &v20[4 * v19];
              if (v15)
                operator delete(v15);
            }
            else
            {
              *(_DWORD *)v224 = v8;
              v12 = v11 + 4;
            }
            v224 = v12;
          }
        }
        if (v7 >= 1)
        {
          v31 = v6 - 1;
          v32 = *((_QWORD *)this + 14);
          v33 = *(unsigned __int8 *)(v32 + v6 - 1);
          if (v33 == 3)
          {
            *(_BYTE *)(v32 + v31) = 1;
            v36 = v221;
            if (v221 >= v222)
            {
              v44 = (char *)v220;
              v45 = (v221 - (_BYTE *)v220) >> 2;
              v46 = v45 + 1;
              if ((unint64_t)(v45 + 1) >> 62)
                std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
              v47 = v222 - (_BYTE *)v220;
              if ((v222 - (_BYTE *)v220) >> 1 > v46)
                v46 = v47 >> 1;
              if ((unint64_t)v47 >= 0x7FFFFFFFFFFFFFFCLL)
                v48 = 0x3FFFFFFFFFFFFFFFLL;
              else
                v48 = v46;
              if (v48)
              {
                v49 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<int>>((uint64_t)&v222, v48);
                v44 = (char *)v220;
                v36 = v221;
              }
              else
              {
                v49 = 0;
              }
              v52 = &v49[4 * v45];
              *(_DWORD *)v52 = v31;
              v37 = v52 + 4;
              while (v36 != v44)
              {
                v53 = *((_DWORD *)v36 - 1);
                v36 -= 4;
                *((_DWORD *)v52 - 1) = v53;
                v52 -= 4;
              }
              v220 = v52;
              v221 = v37;
              v222 = &v49[4 * v48];
              if (v44)
                operator delete(v44);
            }
            else
            {
              *(_DWORD *)v221 = v31;
              v37 = v36 + 4;
            }
            v221 = v37;
          }
          else if (v33 == 253)
          {
            *(_BYTE *)(v32 + v31) = -1;
            v34 = v224;
            if (v224 >= v225)
            {
              v38 = (char *)__p;
              v39 = (v224 - (_BYTE *)__p) >> 2;
              v40 = v39 + 1;
              if ((unint64_t)(v39 + 1) >> 62)
                std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
              v41 = v225 - (_BYTE *)__p;
              if ((v225 - (_BYTE *)__p) >> 1 > v40)
                v40 = v41 >> 1;
              if ((unint64_t)v41 >= 0x7FFFFFFFFFFFFFFCLL)
                v42 = 0x3FFFFFFFFFFFFFFFLL;
              else
                v42 = v40;
              if (v42)
              {
                v43 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<int>>((uint64_t)&v225, v42);
                v38 = (char *)__p;
                v34 = v224;
              }
              else
              {
                v43 = 0;
              }
              v50 = &v43[4 * v39];
              *(_DWORD *)v50 = v31;
              v35 = v50 + 4;
              while (v34 != v38)
              {
                v51 = *((_DWORD *)v34 - 1);
                v34 -= 4;
                *((_DWORD *)v50 - 1) = v51;
                v50 -= 4;
              }
              __p = v50;
              v224 = v35;
              v225 = &v43[4 * v42];
              if (v38)
                operator delete(v38);
            }
            else
            {
              *(_DWORD *)v224 = v31;
              v35 = v34 + 4;
            }
            v224 = v35;
          }
        }
        v54 = (int)v6 / *(_DWORD *)this;
        if (v54 < *((_DWORD *)this + 1) - 2)
        {
          v55 = *(_DWORD *)this + (int)v6;
          v56 = *((_QWORD *)this + 14);
          v57 = *(unsigned __int8 *)(v56 + v55);
          if (v57 == 3)
          {
            *(_BYTE *)(v56 + v55) = 1;
            v61 = *(_DWORD *)this + v6;
            v62 = v221;
            if (v221 >= v222)
            {
              v70 = (char *)v220;
              v71 = (v221 - (_BYTE *)v220) >> 2;
              v72 = v71 + 1;
              if ((unint64_t)(v71 + 1) >> 62)
                std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
              v73 = v222 - (_BYTE *)v220;
              if ((v222 - (_BYTE *)v220) >> 1 > v72)
                v72 = v73 >> 1;
              if ((unint64_t)v73 >= 0x7FFFFFFFFFFFFFFCLL)
                v74 = 0x3FFFFFFFFFFFFFFFLL;
              else
                v74 = v72;
              if (v74)
              {
                v75 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<int>>((uint64_t)&v222, v74);
                v70 = (char *)v220;
                v62 = v221;
              }
              else
              {
                v75 = 0;
              }
              v78 = &v75[4 * v71];
              *(_DWORD *)v78 = v61;
              v63 = v78 + 4;
              while (v62 != v70)
              {
                v79 = *((_DWORD *)v62 - 1);
                v62 -= 4;
                *((_DWORD *)v78 - 1) = v79;
                v78 -= 4;
              }
              v220 = v78;
              v221 = v63;
              v222 = &v75[4 * v74];
              if (v70)
                operator delete(v70);
            }
            else
            {
              *(_DWORD *)v221 = v61;
              v63 = v62 + 4;
            }
            v221 = v63;
          }
          else if (v57 == 253)
          {
            *(_BYTE *)(v56 + v55) = -1;
            v58 = *(_DWORD *)this + v6;
            v59 = v224;
            if (v224 >= v225)
            {
              v64 = (char *)__p;
              v65 = (v224 - (_BYTE *)__p) >> 2;
              v66 = v65 + 1;
              if ((unint64_t)(v65 + 1) >> 62)
                std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
              v67 = v225 - (_BYTE *)__p;
              if ((v225 - (_BYTE *)__p) >> 1 > v66)
                v66 = v67 >> 1;
              if ((unint64_t)v67 >= 0x7FFFFFFFFFFFFFFCLL)
                v68 = 0x3FFFFFFFFFFFFFFFLL;
              else
                v68 = v66;
              if (v68)
              {
                v69 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<int>>((uint64_t)&v225, v68);
                v64 = (char *)__p;
                v59 = v224;
              }
              else
              {
                v69 = 0;
              }
              v76 = &v69[4 * v65];
              *(_DWORD *)v76 = v58;
              v60 = v76 + 4;
              while (v59 != v64)
              {
                v77 = *((_DWORD *)v59 - 1);
                v59 -= 4;
                *((_DWORD *)v76 - 1) = v77;
                v76 -= 4;
              }
              __p = v76;
              v224 = v60;
              v225 = &v69[4 * v68];
              if (v64)
                operator delete(v64);
            }
            else
            {
              *(_DWORD *)v224 = v58;
              v60 = v59 + 4;
            }
            v224 = v60;
          }
        }
        if (v54 >= 1)
        {
          v80 = v6 - *(_DWORD *)this;
          v81 = *((_QWORD *)this + 14);
          v82 = *(unsigned __int8 *)(v81 + v80);
          if (v82 == 3)
          {
            *(_BYTE *)(v81 + v80) = 1;
            v86 = v6 - *(_DWORD *)this;
            v87 = v221;
            if (v221 >= v222)
            {
              v95 = (char *)v220;
              v96 = (v221 - (_BYTE *)v220) >> 2;
              v97 = v96 + 1;
              if ((unint64_t)(v96 + 1) >> 62)
                std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
              v98 = v222 - (_BYTE *)v220;
              if ((v222 - (_BYTE *)v220) >> 1 > v97)
                v97 = v98 >> 1;
              if ((unint64_t)v98 >= 0x7FFFFFFFFFFFFFFCLL)
                v99 = 0x3FFFFFFFFFFFFFFFLL;
              else
                v99 = v97;
              if (v99)
              {
                v100 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<int>>((uint64_t)&v222, v99);
                v95 = (char *)v220;
                v87 = v221;
              }
              else
              {
                v100 = 0;
              }
              v103 = &v100[4 * v96];
              *(_DWORD *)v103 = v86;
              v88 = v103 + 4;
              while (v87 != v95)
              {
                v104 = *((_DWORD *)v87 - 1);
                v87 -= 4;
                *((_DWORD *)v103 - 1) = v104;
                v103 -= 4;
              }
              v220 = v103;
              v221 = v88;
              v222 = &v100[4 * v99];
              if (v95)
                operator delete(v95);
            }
            else
            {
              *(_DWORD *)v221 = v86;
              v88 = v87 + 4;
            }
            v221 = v88;
          }
          else if (v82 == 253)
          {
            *(_BYTE *)(v81 + v80) = -1;
            v83 = v6 - *(_DWORD *)this;
            v84 = v224;
            if (v224 >= v225)
            {
              v89 = (char *)__p;
              v90 = (v224 - (_BYTE *)__p) >> 2;
              v91 = v90 + 1;
              if ((unint64_t)(v90 + 1) >> 62)
                std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
              v92 = v225 - (_BYTE *)__p;
              if ((v225 - (_BYTE *)__p) >> 1 > v91)
                v91 = v92 >> 1;
              if ((unint64_t)v92 >= 0x7FFFFFFFFFFFFFFCLL)
                v93 = 0x3FFFFFFFFFFFFFFFLL;
              else
                v93 = v91;
              if (v93)
              {
                v94 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<int>>((uint64_t)&v225, v93);
                v89 = (char *)__p;
                v84 = v224;
              }
              else
              {
                v94 = 0;
              }
              v101 = &v94[4 * v90];
              *(_DWORD *)v101 = v83;
              v85 = v101 + 4;
              while (v84 != v89)
              {
                v102 = *((_DWORD *)v84 - 1);
                v84 -= 4;
                *((_DWORD *)v101 - 1) = v102;
                v101 -= 4;
              }
              __p = v101;
              v224 = v85;
              v225 = &v94[4 * v93];
              if (v89)
                operator delete(v89);
            }
            else
            {
              *(_DWORD *)v224 = v83;
              v85 = v84 + 4;
            }
            v224 = v85;
          }
        }
        ++v4;
      }
      while (v4 != v5);
      v106 = (int *)__p;
      v105 = (int *)v224;
      if (__p != v224)
      {
        do
        {
          v107 = *v106;
          v108 = (int)v107 % *(_DWORD *)this;
          if (v108 < *(_DWORD *)this - 2)
          {
            v109 = v107 + 1;
            v110 = *((_QWORD *)this + 14);
            if (*(unsigned __int8 *)(v110 + v107 + 1) == 253)
            {
              *(_BYTE *)(v110 + v109) = -2;
              v111 = v218;
              if (v218 >= v219)
              {
                v113 = (char *)v217;
                v114 = (v218 - (_BYTE *)v217) >> 2;
                v115 = v114 + 1;
                if ((unint64_t)(v114 + 1) >> 62)
                  std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
                v116 = v219 - (_BYTE *)v217;
                if ((v219 - (_BYTE *)v217) >> 1 > v115)
                  v115 = v116 >> 1;
                if ((unint64_t)v116 >= 0x7FFFFFFFFFFFFFFCLL)
                  v117 = 0x3FFFFFFFFFFFFFFFLL;
                else
                  v117 = v115;
                if (v117)
                {
                  v118 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<int>>((uint64_t)&v219, v117);
                  v113 = (char *)v217;
                  v111 = v218;
                }
                else
                {
                  v118 = 0;
                }
                v119 = &v118[4 * v114];
                *(_DWORD *)v119 = v109;
                v112 = v119 + 4;
                while (v111 != v113)
                {
                  v120 = *((_DWORD *)v111 - 1);
                  v111 -= 4;
                  *((_DWORD *)v119 - 1) = v120;
                  v119 -= 4;
                }
                v217 = v119;
                v218 = v112;
                v219 = &v118[4 * v117];
                if (v113)
                  operator delete(v113);
              }
              else
              {
                *(_DWORD *)v218 = v109;
                v112 = v111 + 4;
              }
              v218 = v112;
            }
          }
          if (v108 >= 1)
          {
            v121 = v107 - 1;
            v122 = *((_QWORD *)this + 14);
            if (*(unsigned __int8 *)(v122 + v107 - 1) == 253)
            {
              *(_BYTE *)(v122 + v121) = -2;
              v123 = v218;
              if (v218 >= v219)
              {
                v125 = (char *)v217;
                v126 = (v218 - (_BYTE *)v217) >> 2;
                v127 = v126 + 1;
                if ((unint64_t)(v126 + 1) >> 62)
                  std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
                v128 = v219 - (_BYTE *)v217;
                if ((v219 - (_BYTE *)v217) >> 1 > v127)
                  v127 = v128 >> 1;
                if ((unint64_t)v128 >= 0x7FFFFFFFFFFFFFFCLL)
                  v129 = 0x3FFFFFFFFFFFFFFFLL;
                else
                  v129 = v127;
                if (v129)
                {
                  v130 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<int>>((uint64_t)&v219, v129);
                  v125 = (char *)v217;
                  v123 = v218;
                }
                else
                {
                  v130 = 0;
                }
                v131 = &v130[4 * v126];
                *(_DWORD *)v131 = v121;
                v124 = v131 + 4;
                while (v123 != v125)
                {
                  v132 = *((_DWORD *)v123 - 1);
                  v123 -= 4;
                  *((_DWORD *)v131 - 1) = v132;
                  v131 -= 4;
                }
                v217 = v131;
                v218 = v124;
                v219 = &v130[4 * v129];
                if (v125)
                  operator delete(v125);
              }
              else
              {
                *(_DWORD *)v218 = v121;
                v124 = v123 + 4;
              }
              v218 = v124;
            }
          }
          v133 = (int)v107 / *(_DWORD *)this;
          if (v133 < *((_DWORD *)this + 1) - 2)
          {
            v134 = *(_DWORD *)this + v107;
            v135 = *((_QWORD *)this + 14);
            if (*(unsigned __int8 *)(v135 + v134) == 253)
            {
              *(_BYTE *)(v135 + v134) = -2;
              v136 = *(_DWORD *)this + v107;
              v137 = v218;
              if (v218 >= v219)
              {
                v139 = (char *)v217;
                v140 = (v218 - (_BYTE *)v217) >> 2;
                v141 = v140 + 1;
                if ((unint64_t)(v140 + 1) >> 62)
                  std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
                v142 = v219 - (_BYTE *)v217;
                if ((v219 - (_BYTE *)v217) >> 1 > v141)
                  v141 = v142 >> 1;
                if ((unint64_t)v142 >= 0x7FFFFFFFFFFFFFFCLL)
                  v143 = 0x3FFFFFFFFFFFFFFFLL;
                else
                  v143 = v141;
                if (v143)
                {
                  v144 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<int>>((uint64_t)&v219, v143);
                  v139 = (char *)v217;
                  v137 = v218;
                }
                else
                {
                  v144 = 0;
                }
                v145 = &v144[4 * v140];
                *(_DWORD *)v145 = v136;
                v138 = v145 + 4;
                while (v137 != v139)
                {
                  v146 = *((_DWORD *)v137 - 1);
                  v137 -= 4;
                  *((_DWORD *)v145 - 1) = v146;
                  v145 -= 4;
                }
                v217 = v145;
                v218 = v138;
                v219 = &v144[4 * v143];
                if (v139)
                  operator delete(v139);
              }
              else
              {
                *(_DWORD *)v218 = v136;
                v138 = v137 + 4;
              }
              v218 = v138;
            }
          }
          if (v133 >= 1)
          {
            v147 = v107 - *(_DWORD *)this;
            v148 = *((_QWORD *)this + 14);
            if (*(unsigned __int8 *)(v148 + v147) == 253)
            {
              *(_BYTE *)(v148 + v147) = -2;
              v149 = v107 - *(_DWORD *)this;
              v150 = v218;
              if (v218 >= v219)
              {
                v152 = (char *)v217;
                v153 = (v218 - (_BYTE *)v217) >> 2;
                v154 = v153 + 1;
                if ((unint64_t)(v153 + 1) >> 62)
                  std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
                v155 = v219 - (_BYTE *)v217;
                if ((v219 - (_BYTE *)v217) >> 1 > v154)
                  v154 = v155 >> 1;
                if ((unint64_t)v155 >= 0x7FFFFFFFFFFFFFFCLL)
                  v156 = 0x3FFFFFFFFFFFFFFFLL;
                else
                  v156 = v154;
                if (v156)
                {
                  v157 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<int>>((uint64_t)&v219, v156);
                  v152 = (char *)v217;
                  v150 = v218;
                }
                else
                {
                  v157 = 0;
                }
                v158 = &v157[4 * v153];
                *(_DWORD *)v158 = v149;
                v151 = v158 + 4;
                while (v150 != v152)
                {
                  v159 = *((_DWORD *)v150 - 1);
                  v150 -= 4;
                  *((_DWORD *)v158 - 1) = v159;
                  v158 -= 4;
                }
                v217 = v158;
                v218 = v151;
                v219 = &v157[4 * v156];
                if (v152)
                  operator delete(v152);
              }
              else
              {
                *(_DWORD *)v218 = v149;
                v151 = v150 + 4;
              }
              v218 = v151;
            }
          }
          ++v106;
        }
        while (v106 != v105);
        v105 = (int *)__p;
      }
    }
    v160 = (int *)v224;
    if (v105 != (int *)v224)
    {
      do
      {
        v161 = *v105;
        v162 = (int)v161 % *(_DWORD *)this;
        if (v162 < *(_DWORD *)this - 2)
        {
          v163 = v161 + 1;
          v164 = *((_QWORD *)this + 14);
          if (*(_BYTE *)(v164 + v161 + 1) == 3)
          {
            *(_BYTE *)(v164 + v163) = 2;
            v165 = v215;
            if (v215 >= v216)
            {
              v167 = v214;
              v168 = (v215 - v214) >> 2;
              v169 = v168 + 1;
              if ((unint64_t)(v168 + 1) >> 62)
                std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
              v170 = v216 - v214;
              if ((v216 - v214) >> 1 > v169)
                v169 = v170 >> 1;
              if ((unint64_t)v170 >= 0x7FFFFFFFFFFFFFFCLL)
                v171 = 0x3FFFFFFFFFFFFFFFLL;
              else
                v171 = v169;
              if (v171)
              {
                v172 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<int>>((uint64_t)&v216, v171);
                v167 = v214;
                v165 = v215;
              }
              else
              {
                v172 = 0;
              }
              v173 = &v172[4 * v168];
              *(_DWORD *)v173 = v163;
              v166 = v173 + 4;
              while (v165 != v167)
              {
                v174 = *((_DWORD *)v165 - 1);
                v165 -= 4;
                *((_DWORD *)v173 - 1) = v174;
                v173 -= 4;
              }
              v214 = v173;
              v216 = &v172[4 * v171];
              if (v167)
                operator delete(v167);
            }
            else
            {
              *(_DWORD *)v215 = v163;
              v166 = v215 + 4;
            }
            v215 = v166;
          }
        }
        if (v162 >= 1)
        {
          v175 = v161 - 1;
          v176 = *((_QWORD *)this + 14);
          if (*(_BYTE *)(v176 + v161 - 1) == 3)
          {
            *(_BYTE *)(v176 + v175) = 2;
            v177 = v215;
            if (v215 >= v216)
            {
              v179 = v214;
              v180 = (v215 - v214) >> 2;
              v181 = v180 + 1;
              if ((unint64_t)(v180 + 1) >> 62)
                std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
              v182 = v216 - v214;
              if ((v216 - v214) >> 1 > v181)
                v181 = v182 >> 1;
              if ((unint64_t)v182 >= 0x7FFFFFFFFFFFFFFCLL)
                v183 = 0x3FFFFFFFFFFFFFFFLL;
              else
                v183 = v181;
              if (v183)
              {
                v184 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<int>>((uint64_t)&v216, v183);
                v179 = v214;
                v177 = v215;
              }
              else
              {
                v184 = 0;
              }
              v185 = &v184[4 * v180];
              *(_DWORD *)v185 = v175;
              v178 = v185 + 4;
              while (v177 != v179)
              {
                v186 = *((_DWORD *)v177 - 1);
                v177 -= 4;
                *((_DWORD *)v185 - 1) = v186;
                v185 -= 4;
              }
              v214 = v185;
              v216 = &v184[4 * v183];
              if (v179)
                operator delete(v179);
            }
            else
            {
              *(_DWORD *)v215 = v175;
              v178 = v215 + 4;
            }
            v215 = v178;
          }
        }
        v187 = (int)v161 / *(_DWORD *)this;
        if (v187 < *((_DWORD *)this + 1) - 2)
        {
          v188 = *(_DWORD *)this + v161;
          v189 = *((_QWORD *)this + 14);
          if (*(_BYTE *)(v189 + v188) == 3)
          {
            *(_BYTE *)(v189 + v188) = 2;
            v190 = *(_DWORD *)this + v161;
            v191 = v215;
            if (v215 >= v216)
            {
              v193 = v214;
              v194 = (v215 - v214) >> 2;
              v195 = v194 + 1;
              if ((unint64_t)(v194 + 1) >> 62)
                std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
              v196 = v216 - v214;
              if ((v216 - v214) >> 1 > v195)
                v195 = v196 >> 1;
              if ((unint64_t)v196 >= 0x7FFFFFFFFFFFFFFCLL)
                v197 = 0x3FFFFFFFFFFFFFFFLL;
              else
                v197 = v195;
              if (v197)
              {
                v198 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<int>>((uint64_t)&v216, v197);
                v193 = v214;
                v191 = v215;
              }
              else
              {
                v198 = 0;
              }
              v199 = &v198[4 * v194];
              *(_DWORD *)v199 = v190;
              v192 = v199 + 4;
              while (v191 != v193)
              {
                v200 = *((_DWORD *)v191 - 1);
                v191 -= 4;
                *((_DWORD *)v199 - 1) = v200;
                v199 -= 4;
              }
              v214 = v199;
              v216 = &v198[4 * v197];
              if (v193)
                operator delete(v193);
            }
            else
            {
              *(_DWORD *)v215 = v190;
              v192 = v215 + 4;
            }
            v215 = v192;
          }
        }
        if (v187 >= 1)
        {
          v201 = v161 - *(_DWORD *)this;
          v202 = *((_QWORD *)this + 14);
          if (*(_BYTE *)(v202 + v201) == 3)
          {
            *(_BYTE *)(v202 + v201) = 2;
            v203 = v161 - *(_DWORD *)this;
            v204 = v215;
            if (v215 >= v216)
            {
              v206 = v214;
              v207 = (v215 - v214) >> 2;
              v208 = v207 + 1;
              if ((unint64_t)(v207 + 1) >> 62)
                std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
              v209 = v216 - v214;
              if ((v216 - v214) >> 1 > v208)
                v208 = v209 >> 1;
              if ((unint64_t)v209 >= 0x7FFFFFFFFFFFFFFCLL)
                v210 = 0x3FFFFFFFFFFFFFFFLL;
              else
                v210 = v208;
              if (v210)
              {
                v211 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<int>>((uint64_t)&v216, v210);
                v206 = v214;
                v204 = v215;
              }
              else
              {
                v211 = 0;
              }
              v212 = &v211[4 * v207];
              *(_DWORD *)v212 = v203;
              v205 = v212 + 4;
              while (v204 != v206)
              {
                v213 = *((_DWORD *)v204 - 1);
                v204 -= 4;
                *((_DWORD *)v212 - 1) = v213;
                v212 -= 4;
              }
              v214 = v212;
              v216 = &v211[4 * v210];
              if (v206)
                operator delete(v206);
            }
            else
            {
              *(_DWORD *)v215 = v203;
              v205 = v215 + 4;
            }
            v215 = v205;
          }
        }
        ++v105;
      }
      while (v105 != v160);
    }
    if (v214)
      operator delete(v214);
    if (v217)
    {
      v218 = (char *)v217;
      operator delete(v217);
    }
    if (v220)
    {
      v221 = (char *)v220;
      operator delete(v220);
    }
    if (__p)
    {
      v224 = (char *)__p;
      operator delete(__p);
    }
  }
}

void sub_208FC8120(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, uint64_t a19, void *a20,uint64_t a21)
{
  if (__p)
    operator delete(__p);
  if (a14)
    operator delete(a14);
  if (a17)
    operator delete(a17);
  if (a20)
    operator delete(a20);
  _Unwind_Resume(exception_object);
}

uint64_t PKCGrid::printGrid(PKCGrid *this)
{
  int v2;
  int v3;
  uint64_t v4;
  const char *v5;

  puts("\n");
  if (*((int *)this + 1) >= 1)
  {
    v2 = 0;
    do
    {
      v3 = *(_DWORD *)this;
      if (*(_DWORD *)this >= 1)
      {
        v4 = 0;
        do
        {
          if (*(char *)(*((_QWORD *)this + 14) + v2 * v3 + v4) >= 1)
            v5 = " ";
          else
            v5 = "*";
          printf("%s", v5);
          v3 = *(_DWORD *)this;
          ++v4;
        }
        while ((int)v4 < *(_DWORD *)this);
      }
      putchar(10);
      ++v2;
    }
    while (v2 < *((_DWORD *)this + 1));
  }
  return puts("\n");
}

BOOL PKCGrid::isGridRegionOccupied(PKCGrid *this, float a2, float a3, float a4, float a5)
{
  float v5;
  int v6;
  int v7;
  uint64_t v8;
  int v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  BOOL v13;
  unsigned __int8 *v14;
  int v15;

  v5 = (float)*((int *)this + 1);
  v6 = (int)(float)((float)(1.0 - a3) * v5);
  v7 = (int)(float)((float)(1.0 - (float)(a3 + a5)) * v5);
  if (v7 >= v6)
  {
    return 0;
  }
  else
  {
    v8 = *(_DWORD *)this;
    v9 = (int)(float)((float)(a2 + a4) * (float)(int)v8);
    v10 = (int)(float)((float)(int)v8 * a2);
    v11 = v7;
    v12 = v10 + (int)v8 * (uint64_t)v7;
    v13 = 1;
    while (v9 <= v10)
    {
LABEL_7:
      v13 = ++v11 < v6;
      v12 += v8;
      if ((_DWORD)v11 == v6)
        return v13;
    }
    v14 = (unsigned __int8 *)(*((_QWORD *)this + 5) + v12);
    v15 = v9 - v10;
    while (!*v14++)
    {
      if (!--v15)
        goto LABEL_7;
    }
  }
  return v13;
}

id PKCGrid::physicsBodyFromSmoothedOutline(PKCGrid *this, float a2, float64x2_t *a3)
{
  _QWORD *v5;
  char *v6;
  float64x2_t *v7;
  float64x2_t v8;
  float32x2_t v9;
  _QWORD *v10;
  float32x2_t *v11;
  unint64_t v12;
  float32x2_t *v13;
  void **v14;
  float32x2_t *v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  unint64_t v19;
  char *v20;
  float32x2_t *v21;
  float32x2_t v22;
  double v23;
  double v24;
  unint64_t *v25;
  unint64_t v26;
  void *v27;
  std::__shared_weak_count *v28;
  unint64_t *p_shared_owners;
  unint64_t v30;
  std::__shared_weak_count *v31;
  unint64_t *v32;
  unint64_t v33;
  char *v35;
  std::__shared_weak_count *v36;
  _QWORD *v37;
  std::__shared_weak_count *v38;
  void *__p;
  float64x2_t *v40;
  uint64_t v41;

  __p = 0;
  v40 = 0;
  v41 = 0;
  PKCGrid::traceOutline((int *)this, (char **)&__p, a2);
  v5 = operator new(0x40uLL);
  v5[2] = 0;
  *v5 = &unk_24C0E8D28;
  v5[1] = 0;
  v6 = (char *)(v5 + 3);
  *((_OWORD *)v5 + 2) = 0u;
  *((_OWORD *)v5 + 3) = 0u;
  v37 = v5 + 3;
  v38 = (std::__shared_weak_count *)v5;
  v7 = v40;
  if (v40 != __p)
  {
    do
    {
      v8 = v7[-1];
      --v7;
      v9 = vcvt_f32_f64(vmulq_f64(*a3, vdivq_f64(v8, vcvtq_f64_f32(vcvt_f32_s32(*(int32x2_t *)this)))));
      v10 = v37;
      v11 = (float32x2_t *)v37[2];
      v12 = v37[3];
      if ((unint64_t)v11 >= v12)
      {
        v14 = (void **)(v37 + 1);
        v15 = (float32x2_t *)v37[1];
        v16 = v11 - v15;
        v17 = v16 + 1;
        if ((unint64_t)(v16 + 1) >> 61)
          std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
        v18 = v12 - (_QWORD)v15;
        if (v18 >> 2 > v17)
          v17 = v18 >> 2;
        if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFF8)
          v19 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v19 = v17;
        if (v19)
        {
          v20 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKPoint>>((uint64_t)(v37 + 3), v19);
          v15 = (float32x2_t *)v37[1];
          v11 = (float32x2_t *)v37[2];
        }
        else
        {
          v20 = 0;
        }
        v21 = (float32x2_t *)&v20[8 * v16];
        *v21 = v9;
        v13 = v21 + 1;
        if (v11 != v15)
        {
          do
          {
            v22 = v11[-1];
            --v11;
            v21[-1] = v22;
            --v21;
          }
          while (v11 != v15);
          v15 = (float32x2_t *)*v14;
        }
        v10[1] = v21;
        v10[2] = v13;
        v10[3] = &v20[8 * v19];
        if (v15)
          operator delete(v15);
      }
      else
      {
        *v11 = v9;
        v13 = v11 + 1;
      }
      v10[2] = v13;
    }
    while (v7 != __p);
    v6 = (char *)v37;
    v5 = &v38->__vftable;
  }
  v23 = a3->f64[0] * 0.5;
  v24 = a3->f64[1] * 0.5;
  v35 = v6;
  v36 = (std::__shared_weak_count *)v5;
  if (v5)
  {
    v25 = v5 + 1;
    do
      v26 = __ldxr(v25);
    while (__stxr(v26 + 1, v25));
  }
  +[PKPhysicsBody bodyWithOutline:offset:](PKPhysicsBody, "bodyWithOutline:offset:", &v35, v23, v24);
  v27 = (void *)objc_claimAutoreleasedReturnValue();
  v28 = v36;
  if (v36)
  {
    p_shared_owners = (unint64_t *)&v36->__shared_owners_;
    do
      v30 = __ldaxr(p_shared_owners);
    while (__stlxr(v30 - 1, p_shared_owners));
    if (!v30)
    {
      ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
      std::__shared_weak_count::__release_weak(v28);
    }
  }
  v31 = v38;
  if (v38)
  {
    v32 = (unint64_t *)&v38->__shared_owners_;
    do
      v33 = __ldaxr(v32);
    while (__stlxr(v33 - 1, v32));
    if (!v33)
    {
      ((void (*)(std::__shared_weak_count *))v31->__on_zero_shared)(v31);
      std::__shared_weak_count::__release_weak(v31);
    }
  }
  if (__p)
  {
    v40 = (float64x2_t *)__p;
    operator delete(__p);
  }
  return v27;
}

void sub_208FC85B8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, char a12, uint64_t a13, void *__p, uint64_t a15)
{
  std::shared_ptr<QuadTree>::~shared_ptr[abi:ne180100]((uint64_t)&a10);
  std::shared_ptr<QuadTree>::~shared_ptr[abi:ne180100]((uint64_t)&a12);
  if (__p)
  {
    a15 = (uint64_t)__p;
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void PKCGrid::pathFromOutlineWithSmoothingThreshold(PKCGrid *this@<X0>, float a2@<S0>, unsigned int a3@<S1>, unsigned int a4@<S2>, unsigned int a5@<S3>, unsigned int a6@<S4>, _QWORD *a7@<X8>)
{
  _QWORD *v9;
  char *v10;
  float32x2_t v11;
  float64x2_t v12;
  float32x2_t v13;
  _QWORD *v14;
  float32x2_t *v15;
  unint64_t v16;
  float32x2_t *v17;
  float32x2_t *v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t v21;
  unint64_t v22;
  char *v23;
  float32x2_t *v24;
  float32x2_t v25;
  float64x2_t v29;
  float32x2_t v31;
  char *v32;
  char *v33;
  uint64_t v34;

  v32 = 0;
  v33 = 0;
  v34 = 0;
  PKCGrid::traceOutline((int *)this, &v32, a2);
  v9 = operator new(0x40uLL);
  v9[2] = 0;
  *v9 = &unk_24C0E8D28;
  v9[1] = 0;
  *((_OWORD *)v9 + 2) = 0u;
  *((_OWORD *)v9 + 3) = 0u;
  *a7 = v9 + 3;
  a7[1] = v9;
  v10 = v33;
  if (v33 == v32)
  {
    if (!v33)
      return;
  }
  else
  {
    v11 = vmla_f32((float32x2_t)__PAIR64__(a4, a3), (float32x2_t)0xBF000000BF000000, (float32x2_t)__PAIR64__(a6, a5));
    v29 = vcvtq_f64_f32((float32x2_t)__PAIR64__(a6, a5));
    v31 = v11;
    do
    {
      v12 = *((float64x2_t *)v10 - 1);
      v10 -= 16;
      v13 = vadd_f32(v31, vcvt_f32_f64(vmulq_f64(vdivq_f64(v12, vcvtq_f64_f32(vcvt_f32_s32(*(int32x2_t *)this))), v29)));
      v14 = (_QWORD *)*a7;
      v15 = *(float32x2_t **)(*a7 + 16);
      v16 = *(_QWORD *)(*a7 + 24);
      if ((unint64_t)v15 >= v16)
      {
        v18 = (float32x2_t *)v14[1];
        v19 = v15 - v18;
        v20 = v19 + 1;
        if ((unint64_t)(v19 + 1) >> 61)
          std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
        v21 = v16 - (_QWORD)v18;
        if (v21 >> 2 > v20)
          v20 = v21 >> 2;
        if ((unint64_t)v21 >= 0x7FFFFFFFFFFFFFF8)
          v22 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v22 = v20;
        if (v22)
        {
          v23 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKPoint>>(*a7 + 24, v22);
          v18 = (float32x2_t *)v14[1];
          v15 = (float32x2_t *)v14[2];
        }
        else
        {
          v23 = 0;
        }
        v24 = (float32x2_t *)&v23[8 * v19];
        *v24 = v13;
        v17 = v24 + 1;
        if (v15 != v18)
        {
          do
          {
            v25 = v15[-1];
            --v15;
            v24[-1] = v25;
            --v24;
          }
          while (v15 != v18);
          v18 = (float32x2_t *)v14[1];
        }
        v14[1] = v24;
        v14[2] = v17;
        v14[3] = &v23[8 * v22];
        if (v18)
          operator delete(v18);
      }
      else
      {
        *v15 = v13;
        v17 = v15 + 1;
      }
      v14[2] = v17;
    }
    while (v10 != v32);
  }
  v33 = v10;
  operator delete(v10);
}

void sub_208FC87D0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

PKPhysicsBody *PKCGrid::physicsBodyFromMarchingCubes(PKCGrid *this, const CGRect *a2)
{
  _BYTE *v4;
  int v5;
  int v6;
  int v11;
  int v12;
  int v13;
  uint64_t v14;
  int v15;
  int *v16;
  unsigned int v17;
  int v18;
  int v19;
  int v20;
  CGFloat v21;
  float32x2_t v22;
  int v23;
  int v24;
  unsigned int v25;
  int v27;
  int v28;
  uint64_t v29;
  int v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  int v35;
  float v36;
  uint64_t v37;
  float v38;
  char *v39;
  uint64_t v40;
  uint64_t i;
  float32x2_t v42;
  _QWORD *v43;
  float32x2_t *v44;
  unint64_t v45;
  float32x2_t *v46;
  void **v47;
  float32x2_t *v48;
  uint64_t v49;
  unint64_t v50;
  uint64_t v51;
  unint64_t v52;
  char *v53;
  float32x2_t *v54;
  float32x2_t v55;
  uint64_t v56;
  float *v57;
  float *v58;
  float v59;
  float v60;
  uint64_t v61;
  float v62;
  float v63;
  float v64;
  float v65;
  unint64_t *p_shared_owners;
  unint64_t v67;
  std::__shared_weak_count *v68;
  unint64_t *v69;
  unint64_t v70;
  std::__shared_weak_count *v71;
  unint64_t *v72;
  unint64_t v73;
  PKPhysicsBody *v75;
  int v76;
  int v77;
  float64x2_t v78;
  CGSize size;
  float v80;
  uint64_t v81;
  std::__shared_weak_count *v82;
  char *v83;
  std::__shared_weak_count *v84;
  _DWORD v85[2];
  int v86;
  int v87;
  int v88;
  int v89;
  int v90;
  int v91;
  int v92;
  _DWORD v93[15];
  uint64_t v94;

  v94 = *MEMORY[0x24BDAC8D0];
  size = a2->size;
  v75 = objc_alloc_init(PKPhysicsBody);
  PKCGrid::labelGrid(this);
  v4 = malloc_type_malloc(*((int *)this + 1) * (uint64_t)*(_DWORD *)this, 0xEB51B0A9uLL);
  v5 = *((_DWORD *)this + 1);
  if (v5 >= 1)
  {
    v6 = 0;
    __asm { FMOV            V0.2D, #0.5 }
    v78 = vmulq_f64((float64x2_t)size, _Q0);
    v11 = *(_DWORD *)this;
    do
    {
      v12 = v6 + 1;
      if (v11 >= 2)
      {
        v13 = 0;
        do
        {
          v14 = 0;
          v92 = v13;
          v93[0] = v6;
          v15 = v13 + 1;
          v93[1] = v13 + 1;
          v93[2] = v6;
          v93[3] = v13 + 1;
          v93[4] = v6 + 1;
          v16 = v93;
          v93[5] = v13;
          v93[6] = v6 + 1;
          do
          {
            v17 = 0;
            v18 = *(v16 - 1);
            if (v11 > v18)
            {
              v19 = *v16;
              if (((*v16 | v18) & 0x80000000) == 0)
              {
                if (*((_DWORD *)this + 1) <= v19 || *((int *)this + 2) < 1)
                  v17 = 0;
                else
                  v17 = *(unsigned __int8 *)(*((_QWORD *)this + 14) + v18 + v19 * v11);
              }
            }
            v16 += 2;
            *((_BYTE *)v85 + v14++) = v17 >> 7;
          }
          while (v14 != 4);
          v4[v13 + v11 * v6] = LOBYTE(v85[0]) | (2 * BYTE1(v85[0])) | (4 * BYTE2(v85[0])) | (8 * HIBYTE(v85[0]));
          v11 = *(_DWORD *)this;
          ++v13;
        }
        while (v15 < *(_DWORD *)this - 1);
        v5 = *((_DWORD *)this + 1);
      }
      ++v6;
    }
    while (v12 < v5);
    if (v5 >= 1)
    {
      v20 = 0;
      v21 = a2->size.width / (double)v11;
      *(float *)&v21 = v21;
      v80 = *(float *)&v21;
      v22 = (float32x2_t)vdup_lane_s32(*(int32x2_t *)&v21, 0);
      do
      {
        v23 = v20 + 1;
        if (v11 >= 2)
        {
          v24 = 0;
          v76 = v20 + 1;
          v77 = v20;
          do
          {
            v25 = v4[v11 * v20 + (uint64_t)v24];
            if (v4[v11 * v20 + (uint64_t)v24])
              _ZF = v25 == 15;
            else
              _ZF = 1;
            if (!_ZF)
            {
              v85[0] = v24;
              v85[1] = v20;
              v27 = v24 + 1;
              v86 = v24 + 1;
              v87 = v20;
              v88 = v24 + 1;
              v89 = v23;
              v90 = v24;
              v91 = v23;
              switch(v25)
              {
                case 3u:
                  if (v27 < v11)
                  {
                    v28 = v11 - 1;
                    v29 = v11 - (uint64_t)v27;
                    do
                    {
                      if (v4[v20 * v11 + 1 + v24] != 3)
                        goto LABEL_43;
                      ++v24;
                      --v29;
                    }
                    while (v29);
                    goto LABEL_42;
                  }
                  break;
                case 6u:
                  v30 = v23;
                  if (v23 < *((_DWORD *)this + 1))
                  {
                    do
                    {
                      v32 = v24 + *(_DWORD *)this * (uint64_t)v30;
                      if (v4[v32] != 6)
                        break;
                      v4[v32] = 0;
                      ++v30;
                    }
                    while (v30 < *((_DWORD *)this + 1));
                    goto LABEL_37;
                  }
                  break;
                case 9u:
                  v30 = v23;
                  if (v23 < *((_DWORD *)this + 1))
                  {
                    do
                    {
                      v31 = v24 + *(_DWORD *)this * (uint64_t)v30;
                      if (v4[v31] != 9)
                        break;
                      v4[v31] = 0;
                      ++v30;
                    }
                    while (v30 < *((_DWORD *)this + 1));
LABEL_37:
                    v89 = v30;
                    v91 = v30;
                  }
                  break;
                case 0xCu:
                  if (v27 < v11)
                  {
                    v28 = v11 - 1;
                    v33 = v11 - (uint64_t)v27;
                    while (v4[v20 * v11 + 1 + v24] == 12)
                    {
                      ++v24;
                      if (!--v33)
                      {
LABEL_42:
                        v86 = v11;
                        v88 = v11;
                        v24 = v28;
                        goto LABEL_44;
                      }
                    }
LABEL_43:
                    v86 = v24 + 1;
                    v88 = v24 + 1;
                  }
                  break;
                default:
                  break;
              }
LABEL_44:
              v34 = 0;
              v35 = 0;
              do
              {
                if (((v25 >> v34) & 1) != 0)
                {
                  *(float32x2_t *)&v93[2 * v35++ - 1] = vmul_n_f32(vcvt_f32_s32(*(int32x2_t *)&v85[2 * v34]), v80);
                  v36 = 1.0;
                }
                else
                {
                  v36 = 0.0;
                }
                v37 = v34 + 1;
                if (((v25 >> ((v34 + 1) & 3)) & 1) != 0)
                  v38 = 1.0;
                else
                  v38 = 0.0;
                if (v36 != v38)
                  *(float32x2_t *)&v93[2 * v35++ - 1] = vmla_n_f32(vmul_n_f32(vmul_n_f32(vcvt_f32_s32(*(int32x2_t *)&v85[2 * (v37 & 3)]), v80), v36 / (float)(v36 - v38)), vmul_n_f32(vcvt_f32_s32(*(int32x2_t *)&v85[2 * v34]), v80), 1.0 - (float)(v36 / (float)(v36 - v38)));
                ++v34;
              }
              while (v37 != 4);
              if (v35 > 2)
              {
                v39 = (char *)operator new(0x40uLL);
                *((_QWORD *)v39 + 1) = 0;
                *((_QWORD *)v39 + 2) = 0;
                *(_QWORD *)v39 = &unk_24C0E8D28;
                *((_OWORD *)v39 + 3) = 0u;
                *((_OWORD *)v39 + 2) = 0u;
                v40 = v35;
                v83 = v39 + 24;
                v84 = (std::__shared_weak_count *)v39;
                std::vector<PKPoint>::reserve((void **)v39 + 4, v35);
                for (i = 0; i != v40; ++i)
                {
                  v42 = vcvt_f32_f64(vsubq_f64(vcvtq_f64_f32(vmla_f32(*(float32x2_t *)&v93[2 * i - 1], (float32x2_t)0x3F0000003F000000, v22)), v78));
                  v43 = v83;
                  v44 = (float32x2_t *)*((_QWORD *)v83 + 2);
                  v45 = *((_QWORD *)v83 + 3);
                  if ((unint64_t)v44 >= v45)
                  {
                    v47 = (void **)(v83 + 8);
                    v48 = (float32x2_t *)*((_QWORD *)v83 + 1);
                    v49 = v44 - v48;
                    v50 = v49 + 1;
                    if ((unint64_t)(v49 + 1) >> 61)
                      std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
                    v51 = v45 - (_QWORD)v48;
                    if (v51 >> 2 > v50)
                      v50 = v51 >> 2;
                    if ((unint64_t)v51 >= 0x7FFFFFFFFFFFFFF8)
                      v52 = 0x1FFFFFFFFFFFFFFFLL;
                    else
                      v52 = v50;
                    if (v52)
                    {
                      v53 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKPoint>>((uint64_t)(v83 + 24), v52);
                      v48 = (float32x2_t *)v43[1];
                      v44 = (float32x2_t *)v43[2];
                    }
                    else
                    {
                      v53 = 0;
                    }
                    v54 = (float32x2_t *)&v53[8 * v49];
                    *v54 = v42;
                    v46 = v54 + 1;
                    if (v44 != v48)
                    {
                      do
                      {
                        v55 = v44[-1];
                        --v44;
                        v54[-1] = v55;
                        --v54;
                      }
                      while (v44 != v48);
                      v48 = (float32x2_t *)*v47;
                    }
                    v43[1] = v54;
                    v43[2] = v46;
                    v43[3] = &v53[8 * v52];
                    if (v48)
                      operator delete(v48);
                  }
                  else
                  {
                    *v44 = v42;
                    v46 = v44 + 1;
                  }
                  v43[2] = v46;
                }
                v56 = (uint64_t)v83;
                v57 = (float *)*((_QWORD *)v83 + 1);
                v59 = *v57;
                v58 = v57 + 3;
                v60 = v59;
                v61 = v40 - 1;
                v62 = 0.0;
                do
                {
                  v63 = *(v58 - 2);
                  v64 = *(v58 - 1);
                  v65 = *v58;
                  v58 += 2;
                  v62 = v62
                      + sqrtf((float)((float)(v65 - v63) * (float)(v65 - v63))+ (float)((float)(v64 - v60) * (float)(v64 - v60)));
                  v60 = v64;
                  --v61;
                }
                while (v61);
                *(float *)v83 = v62;
                v81 = v56;
                v82 = v84;
                v23 = v76;
                v20 = v77;
                if (v84)
                {
                  p_shared_owners = (unint64_t *)&v84->__shared_owners_;
                  do
                    v67 = __ldxr(p_shared_owners);
                  while (__stxr(v67 + 1, p_shared_owners));
                }
                addPolygonFromPath(v75, &v81);
                v68 = v82;
                if (v82)
                {
                  v69 = (unint64_t *)&v82->__shared_owners_;
                  do
                    v70 = __ldaxr(v69);
                  while (__stlxr(v70 - 1, v69));
                  if (!v70)
                  {
                    ((void (*)(std::__shared_weak_count *))v68->__on_zero_shared)(v68);
                    std::__shared_weak_count::__release_weak(v68);
                  }
                }
                v71 = v84;
                if (v84)
                {
                  v72 = (unint64_t *)&v84->__shared_owners_;
                  do
                    v73 = __ldaxr(v72);
                  while (__stlxr(v73 - 1, v72));
                  if (!v73)
                  {
                    ((void (*)(std::__shared_weak_count *))v71->__on_zero_shared)(v71);
                    std::__shared_weak_count::__release_weak(v71);
                  }
                }
              }
              v11 = *(_DWORD *)this;
            }
            ++v24;
          }
          while (v24 < v11 - 1);
          v5 = *((_DWORD *)this + 1);
        }
        v20 = v23;
      }
      while (v23 < v5);
    }
  }
  free(v4);
  v75->_shapeType = 7;
  -[PKPhysicsBody set_allowSleep:](v75, "set_allowSleep:", 1);
  return v75;
}

void sub_208FC8E90(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11)
{

  _Unwind_Resume(a1);
}

void std::vector<unsigned char>::__append(_QWORD *a1, unint64_t a2, _BYTE *a3)
{
  unint64_t v4;
  uint64_t v6;
  _BYTE *v7;
  _BYTE *v8;
  unint64_t v9;
  unint64_t v10;
  size_t v11;
  void *v12;
  _BYTE *v13;
  char *v14;
  char *v15;
  _BYTE *v16;
  _BYTE *v17;
  char v18;

  v4 = a2;
  v7 = (_BYTE *)a1[1];
  v6 = a1[2];
  if (v6 - (uint64_t)v7 >= a2)
  {
    if (a2)
    {
      v13 = &v7[a2];
      do
      {
        *v7++ = *a3;
        --v4;
      }
      while (v4);
      v7 = v13;
    }
    a1[1] = v7;
  }
  else
  {
    v8 = &v7[-*a1];
    v9 = (unint64_t)&v8[a2];
    if ((uint64_t)&v8[a2] < 0)
      std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
    v10 = v6 - *a1;
    if (2 * v10 > v9)
      v9 = 2 * v10;
    if (v10 >= 0x3FFFFFFFFFFFFFFFLL)
      v11 = 0x7FFFFFFFFFFFFFFFLL;
    else
      v11 = v9;
    if (v11)
      v12 = operator new(v11);
    else
      v12 = 0;
    v14 = &v8[(_QWORD)v12];
    v15 = &v8[(_QWORD)v12 + v4];
    v16 = &v8[(_QWORD)v12];
    do
    {
      *v16++ = *a3;
      --v4;
    }
    while (v4);
    v17 = (_BYTE *)*a1;
    if (v7 != (_BYTE *)*a1)
    {
      do
      {
        v18 = *--v7;
        *--v14 = v18;
      }
      while (v7 != v17);
      v7 = (_BYTE *)*a1;
    }
    *a1 = v14;
    a1[1] = v15;
    a1[2] = (char *)v12 + v11;
    if (v7)
      operator delete(v7);
  }
}

void std::vector<unsigned char>::__append(unint64_t *a1, size_t a2)
{
  char *v4;
  char *v5;
  unint64_t v6;
  char *v7;
  unint64_t v8;
  unint64_t v9;
  size_t v10;
  unint64_t v11;
  char *v12;
  char *v13;
  char *v14;
  char v15;

  v5 = (char *)a1[1];
  v4 = (char *)a1[2];
  if (v4 - v5 >= a2)
  {
    if (a2)
    {
      bzero((void *)a1[1], a2);
      v5 += a2;
    }
    a1[1] = (unint64_t)v5;
  }
  else
  {
    v6 = *a1;
    v7 = &v5[-*a1];
    v8 = (unint64_t)&v7[a2];
    if ((uint64_t)&v7[a2] < 0)
      std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
    v9 = (unint64_t)&v4[-v6];
    if (2 * v9 > v8)
      v8 = 2 * v9;
    if (v9 >= 0x3FFFFFFFFFFFFFFFLL)
      v10 = 0x7FFFFFFFFFFFFFFFLL;
    else
      v10 = v8;
    if (v10)
      v11 = (unint64_t)operator new(v10);
    else
      v11 = 0;
    v12 = &v7[v11];
    v13 = (char *)(v11 + v10);
    bzero(v12, a2);
    if (v5 == (char *)v6)
    {
      v11 = (unint64_t)v12;
    }
    else
    {
      v14 = &v5[~v6];
      do
      {
        v15 = *--v5;
        (v14--)[v11] = v15;
      }
      while (v5 != (char *)v6);
      v5 = (char *)*a1;
    }
    *a1 = v11;
    a1[1] = (unint64_t)&v12[a2];
    a1[2] = (unint64_t)v13;
    if (v5)
      operator delete(v5);
  }
}

void _ZNSt3__16vectorIDv4_fNS_9allocatorIS1_EEE8__appendEm(void **a1, unint64_t a2)
{
  uint64_t v4;
  _BYTE *v5;
  _BYTE *v6;
  char *v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char *v13;
  char *v14;
  char *v15;
  char *v16;
  char *v17;
  char *v18;
  __int128 v19;

  v6 = a1[2];
  v4 = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(char **)(v4 - 8);
  if (a2 <= (v6 - v7) >> 4)
  {
    if (a2)
    {
      bzero(*(void **)(v4 - 8), 16 * a2);
      v7 += 16 * a2;
    }
    a1[1] = v7;
  }
  else
  {
    v8 = v7 - (_BYTE *)*a1;
    v9 = a2 + (v8 >> 4);
    if (v9 >> 60)
      std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
    v10 = v8 >> 4;
    v11 = v5 - (_BYTE *)*a1;
    if (v11 >> 3 > v9)
      v9 = v11 >> 3;
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF0)
      v12 = 0xFFFFFFFFFFFFFFFLL;
    else
      v12 = v9;
    if (v12)
      v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKDebugDrawPacket::color4>>(v4, v12);
    else
      v13 = 0;
    v14 = &v13[16 * v10];
    v15 = &v13[16 * v12];
    bzero(v14, 16 * a2);
    v16 = &v14[16 * a2];
    v18 = (char *)*a1;
    v17 = (char *)a1[1];
    if (v17 != *a1)
    {
      do
      {
        v19 = *((_OWORD *)v17 - 1);
        v17 -= 16;
        *((_OWORD *)v14 - 1) = v19;
        v14 -= 16;
      }
      while (v17 != v18);
      v17 = (char *)*a1;
    }
    *a1 = v14;
    a1[1] = v16;
    a1[2] = v15;
    if (v17)
      operator delete(v17);
  }
}

_QWORD *std::vector<CGPoint>::__init_with_size[abi:ne180100]<CGPoint*,CGPoint*>(_QWORD *result, const void *a2, uint64_t a3, unint64_t a4)
{
  _QWORD *v6;
  uint64_t v7;
  size_t v8;

  if (a4)
  {
    v6 = result;
    result = std::vector<CGPoint>::__vallocate[abi:ne180100](result, a4);
    v7 = v6[1];
    v8 = a3 - (_QWORD)a2;
    if (v8)
      result = memmove((void *)v6[1], a2, v8);
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_208FC927C(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *std::vector<CGPoint>::__vallocate[abi:ne180100](_QWORD *a1, unint64_t a2)
{
  char *result;
  uint64_t v4;

  if (a2 >> 60)
    std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
  result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKDebugDrawPacket::color4>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[16 * v4];
  return result;
}

char *std::vector<CGPoint>::__insert_with_size[abi:ne180100]<std::__wrap_iter<CGPoint const*>,std::__wrap_iter<CGPoint const*>>(uint64_t a1, uint64_t __dst, char *__src, char *a4, uint64_t a5)
{
  char *v5;
  char *v7;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  void *v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  char *v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  int64_t v22;
  char *v23;
  char *v24;
  char *v25;
  char *v26;
  __int128 v27;
  char *v28;
  uint64_t v29;
  char *v30;
  __int128 v31;
  void *__p;
  char *v34;
  char *v35;
  char *v36;
  uint64_t v37;

  v5 = (char *)__dst;
  if (a5 < 1)
    return v5;
  v7 = __src;
  v11 = *(_QWORD *)(a1 + 16);
  v9 = a1 + 16;
  v10 = v11;
  v12 = *(_QWORD *)(v9 - 8);
  if (a5 > (uint64_t)(v11 - v12) >> 4)
  {
    v13 = *(void **)a1;
    v14 = a5 + ((uint64_t)(v12 - *(_QWORD *)a1) >> 4);
    if (v14 >> 60)
      std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
    v15 = (__dst - (uint64_t)v13) >> 4;
    v16 = v10 - (_QWORD)v13;
    if (v16 >> 3 > v14)
      v14 = v16 >> 3;
    if ((unint64_t)v16 >= 0x7FFFFFFFFFFFFFF0)
      v17 = 0xFFFFFFFFFFFFFFFLL;
    else
      v17 = v14;
    v37 = v9;
    if (v17)
      v18 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKDebugDrawPacket::color4>>(v9, v17);
    else
      v18 = 0;
    v28 = &v18[16 * v15];
    __p = v18;
    v34 = v28;
    v36 = &v18[16 * v17];
    v29 = 16 * a5;
    v30 = &v28[16 * a5];
    do
    {
      v31 = *(_OWORD *)v7;
      v7 += 16;
      *(_OWORD *)v28 = v31;
      v28 += 16;
      v29 -= 16;
    }
    while (v29);
    v35 = v30;
    v5 = (char *)std::vector<CGPoint>::__swap_out_circular_buffer((void **)a1, (uint64_t)&__p, v5);
    if (v35 != v34)
      v35 += (v34 - v35 + 15) & 0xFFFFFFFFFFFFFFF0;
    if (__p)
      operator delete(__p);
    return v5;
  }
  v19 = v12 - __dst;
  v20 = (uint64_t)(v12 - __dst) >> 4;
  if (v20 >= a5)
  {
    v21 = &__src[16 * a5];
    v23 = *(char **)(v9 - 8);
LABEL_17:
    v24 = &v5[16 * a5];
    v25 = &v23[-16 * a5];
    v26 = v23;
    if ((unint64_t)v25 < v12)
    {
      v26 = v23;
      do
      {
        v27 = *(_OWORD *)v25;
        v25 += 16;
        *(_OWORD *)v26 = v27;
        v26 += 16;
      }
      while ((unint64_t)v25 < v12);
    }
    *(_QWORD *)(a1 + 8) = v26;
    if (v23 != v24)
      memmove(&v23[-16 * ((v23 - v24) >> 4)], v5, v23 - v24);
    if (v21 != v7)
      memmove(v5, v7, v21 - v7);
    return v5;
  }
  v21 = &__src[16 * v20];
  v22 = a4 - v21;
  if (a4 != v21)
    memmove(*(void **)(v9 - 8), &__src[16 * v20], a4 - v21);
  v23 = (char *)(v12 + v22);
  *(_QWORD *)(a1 + 8) = v12 + v22;
  if (v19 >= 1)
    goto LABEL_17;
  return v5;
}

void sub_208FC94AC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void *std::vector<CGPoint>::__swap_out_circular_buffer(void **a1, uint64_t a2, char *__src)
{
  void *v5;
  char *v6;
  void *v7;
  char *v8;
  uint64_t v9;
  _BYTE *v10;
  uint64_t v11;
  int64_t v12;
  char *v13;
  void *v14;
  void *v15;

  v5 = *(void **)(a2 + 8);
  v6 = (char *)*a1;
  v7 = v5;
  if (*a1 != __src)
  {
    v8 = __src;
    v9 = *(_QWORD *)(a2 + 8);
    do
    {
      v7 = (void *)(v9 - 16);
      *(_OWORD *)(v9 - 16) = *((_OWORD *)v8 - 1);
      v8 -= 16;
      v9 -= 16;
    }
    while (v8 != v6);
  }
  *(_QWORD *)(a2 + 8) = v7;
  v10 = a1[1];
  v11 = *(_QWORD *)(a2 + 16);
  v12 = v10 - __src;
  if (v10 != __src)
  {
    memmove(*(void **)(a2 + 16), __src, v10 - __src);
    v7 = *(void **)(a2 + 8);
  }
  *(_QWORD *)(a2 + 16) = v11 + v12;
  v13 = (char *)*a1;
  *a1 = v7;
  *(_QWORD *)(a2 + 8) = v13;
  v14 = a1[1];
  a1[1] = *(void **)(a2 + 16);
  *(_QWORD *)(a2 + 16) = v14;
  v15 = a1[2];
  a1[2] = *(void **)(a2 + 24);
  *(_QWORD *)(a2 + 24) = v15;
  *(_QWORD *)a2 = *(_QWORD *)(a2 + 8);
  return v5;
}

char *std::vector<CGPoint>::__insert_with_size[abi:ne180100]<std::__wrap_iter<CGPoint*>,std::__wrap_iter<CGPoint*>>(uint64_t a1, uint64_t __dst, char *__src, char *a4, uint64_t a5)
{
  char *v5;
  char *v7;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  void *v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  char *v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  int64_t v22;
  char *v23;
  char *v24;
  char *v25;
  char *v26;
  __int128 v27;
  char *v28;
  uint64_t v29;
  char *v30;
  __int128 v31;
  void *__p;
  char *v34;
  char *v35;
  char *v36;
  uint64_t v37;

  v5 = (char *)__dst;
  if (a5 < 1)
    return v5;
  v7 = __src;
  v11 = *(_QWORD *)(a1 + 16);
  v9 = a1 + 16;
  v10 = v11;
  v12 = *(_QWORD *)(v9 - 8);
  if (a5 > (uint64_t)(v11 - v12) >> 4)
  {
    v13 = *(void **)a1;
    v14 = a5 + ((uint64_t)(v12 - *(_QWORD *)a1) >> 4);
    if (v14 >> 60)
      std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
    v15 = (__dst - (uint64_t)v13) >> 4;
    v16 = v10 - (_QWORD)v13;
    if (v16 >> 3 > v14)
      v14 = v16 >> 3;
    if ((unint64_t)v16 >= 0x7FFFFFFFFFFFFFF0)
      v17 = 0xFFFFFFFFFFFFFFFLL;
    else
      v17 = v14;
    v37 = v9;
    if (v17)
      v18 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKDebugDrawPacket::color4>>(v9, v17);
    else
      v18 = 0;
    v28 = &v18[16 * v15];
    __p = v18;
    v34 = v28;
    v36 = &v18[16 * v17];
    v29 = 16 * a5;
    v30 = &v28[16 * a5];
    do
    {
      v31 = *(_OWORD *)v7;
      v7 += 16;
      *(_OWORD *)v28 = v31;
      v28 += 16;
      v29 -= 16;
    }
    while (v29);
    v35 = v30;
    v5 = (char *)std::vector<CGPoint>::__swap_out_circular_buffer((void **)a1, (uint64_t)&__p, v5);
    if (v35 != v34)
      v35 += (v34 - v35 + 15) & 0xFFFFFFFFFFFFFFF0;
    if (__p)
      operator delete(__p);
    return v5;
  }
  v19 = v12 - __dst;
  v20 = (uint64_t)(v12 - __dst) >> 4;
  if (v20 >= a5)
  {
    v21 = &__src[16 * a5];
    v23 = *(char **)(v9 - 8);
LABEL_17:
    v24 = &v5[16 * a5];
    v25 = &v23[-16 * a5];
    v26 = v23;
    if ((unint64_t)v25 < v12)
    {
      v26 = v23;
      do
      {
        v27 = *(_OWORD *)v25;
        v25 += 16;
        *(_OWORD *)v26 = v27;
        v26 += 16;
      }
      while ((unint64_t)v25 < v12);
    }
    *(_QWORD *)(a1 + 8) = v26;
    if (v23 != v24)
      memmove(&v23[-16 * ((v23 - v24) >> 4)], v5, v23 - v24);
    if (v21 != v7)
      memmove(v5, v7, v21 - v7);
    return v5;
  }
  v21 = &__src[16 * v20];
  v22 = a4 - v21;
  if (a4 != v21)
    memmove(*(void **)(v9 - 8), &__src[16 * v20], a4 - v21);
  v23 = (char *)(v12 + v22);
  *(_QWORD *)(a1 + 8) = v12 + v22;
  if (v19 >= 1)
    goto LABEL_17;
  return v5;
}

void sub_208FC978C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<int>>(uint64_t a1, unint64_t a2)
{
  if (a2 >> 62)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(4 * a2);
}

uint64_t std::allocate_shared[abi:ne180100]<QuadTree,std::allocator<QuadTree>,float,float,float,float,float,void>@<X0>(float *a1@<X1>, float *a2@<X2>, float *a3@<X3>, float *a4@<X4>, float *a5@<X5>, _QWORD *a6@<X8>)
{
  char *v12;
  uint64_t result;

  v12 = (char *)operator new(0x20uLL);
  result = std::__shared_ptr_emplace<QuadTree>::__shared_ptr_emplace[abi:ne180100]<float,float,float,float,float,std::allocator<QuadTree>,0>((uint64_t)v12, a1, a2, a3, a4, a5);
  *a6 = v12 + 24;
  a6[1] = v12;
  return result;
}

void sub_208FC986C(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t std::__shared_ptr_emplace<QuadTree>::__shared_ptr_emplace[abi:ne180100]<float,float,float,float,float,std::allocator<QuadTree>,0>(uint64_t a1, float *a2, float *a3, float *a4, float *a5, float *a6)
{
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)a1 = &unk_24C0E8D98;
  *(_QWORD *)(a1 + 8) = 0;
  QuadTree::QuadTree((QuadTree *)(a1 + 24), *a2, *a3, *a4, *a5, *a6);
  return a1;
}

void sub_208FC98CC(_Unwind_Exception *a1)
{
  std::__shared_weak_count *v1;

  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<QuadTree>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_24C0E8D98;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<QuadTree>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_24C0E8D98;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x20BD0BA58);
}

void std::__shared_ptr_emplace<QuadTree>::__on_zero_shared(uint64_t a1)
{
  QuadTree::~QuadTree((QuadTree *)(a1 + 24));
}

float b2PrismaticJointDef::Initialize(b2PrismaticJointDef *this, b2Body *a2, b2Body *a3, const b2Vec2 *a4, const b2Vec2 *a5)
{
  float v7;
  float v8;
  float var1;
  float var0;
  float v11;
  float v12;
  float v13;
  float v14;
  float v15;
  float v16;
  float y;
  float v18;
  float v19;
  float v20;
  float result;

  this->bodyA = a2;
  this->bodyB = a3;
  v7 = a4->x - a2->var8.var0.x;
  v8 = a4->y - a2->var8.var0.y;
  var0 = a2->var8.var1.var0;
  var1 = a2->var8.var1.var1;
  this->localAnchorA.x = (float)(v8 * var0) + (float)(var1 * v7);
  this->localAnchorA.y = (float)(var1 * v8) - (float)(var0 * v7);
  v11 = a4->x - a3->var8.var0.x;
  v12 = a4->y - a3->var8.var0.y;
  v14 = a3->var8.var1.var0;
  v13 = a3->var8.var1.var1;
  this->localAnchorB.x = (float)(v12 * v14) + (float)(v13 * v11);
  this->localAnchorB.y = (float)(v13 * v12) - (float)(v14 * v11);
  v16 = a2->var8.var1.var0;
  v15 = a2->var8.var1.var1;
  y = a5->y;
  v18 = (float)(v16 * y) + (float)(v15 * a5->x);
  v19 = (float)(v15 * y) - (float)(v16 * a5->x);
  this->localAxisA.x = v18;
  this->localAxisA.y = v19;
  v20 = atan2f(a3->var8.var1.var0, a3->var8.var1.var1);
  result = v20 - atan2f(a2->var8.var1.var0, a2->var8.var1.var1);
  this->referenceAngle = result;
  return result;
}

void b2PrismaticJoint::b2PrismaticJoint(b2PrismaticJoint *this, const b2JointDef *a2)
{
  uint64_t v3;
  b2Vec2 v4;
  float x;
  float y;
  float v7;
  float v8;
  __int128 v9;

  b2Joint::b2Joint((b2Joint *)this, a2);
  *(_QWORD *)v3 = off_24C0E84F8;
  *(_QWORD *)(v3 + 128) = *(_QWORD *)(&a2->var4 + 4);
  *(_QWORD *)(v3 + 136) = *(_QWORD *)(&a2[1].var0 + 1);
  v4 = *(b2Vec2 *)((char *)&a2[1].var1 + 4);
  *(b2Vec2 *)(v3 + 144) = v4;
  y = v4.y;
  x = v4.x;
  v7 = sqrtf((float)(v4.y * v4.y) + (float)(v4.x * v4.x));
  if (v7 >= 0.00000011921)
  {
    v8 = 1.0 / v7;
    x = v8 * v4.x;
    y = v8 * v4.y;
    *(float *)(v3 + 144) = v8 * v4.x;
    *(float *)(v3 + 148) = v8 * v4.y;
  }
  *(float *)(v3 + 152) = -y;
  *(float *)(v3 + 156) = x;
  *(_DWORD *)(v3 + 160) = HIDWORD(a2[1].var2);
  *(_DWORD *)(v3 + 312) = 0;
  *(_QWORD *)(v3 + 172) = 0;
  *(_QWORD *)(v3 + 164) = 0;
  *(_QWORD *)&v9 = *(b2Body **)((char *)&a2[1].var3 + 4);
  *((_QWORD *)&v9 + 1) = *(_QWORD *)&a2[2].var0;
  *(_OWORD *)(v3 + 180) = v9;
  *(_BYTE *)(v3 + 196) = a2[1].var3;
  *(_BYTE *)(v3 + 197) = *(&a2[1].var4 + 4);
  *(_DWORD *)(v3 + 200) = 0;
  *(_QWORD *)(v3 + 252) = 0;
  *(_QWORD *)(v3 + 244) = 0;
}

void b2PrismaticJoint::InitVelocityConstraints(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  float v10;
  float v11;
  float v12;
  float v13;
  uint64_t v14;
  uint64_t v15;
  float *v16;
  float *v17;
  float *v18;
  float v19;
  float v20;
  float *v21;
  float v22;
  float cosval;
  __float2 v24;
  __float2 v25;
  float v26;
  float v27;
  float v28;
  float v29;
  float v30;
  float v31;
  float v32;
  float v33;
  float v34;
  float v35;
  float v36;
  float v37;
  float v38;
  float v39;
  float v40;
  float v41;
  float v44;
  float v45;
  float v46;
  float v47;
  float v48;
  float v49;
  float v50;
  float v51;
  float v52;
  float v53;
  float v54;
  float v55;
  float v56;
  float v57;
  float v58;
  float v59;
  float v60;
  float v61;
  float v62;
  float v63;
  float v64;
  float v65;
  float32x4_t v66;
  float v68;
  float v69;
  float *v76;
  float *v77;
  int v78;
  float v79;
  float v80;
  float v81;
  float v82;
  float v83;
  float v84;
  float v85;
  float v86;
  float v87;

  v4 = *(_QWORD *)(a1 + 96);
  v5 = *(_QWORD *)(a1 + 104);
  v6 = *(int *)(v4 + 28);
  v7 = *(int *)(v5 + 28);
  *(_DWORD *)(a1 + 204) = v6;
  *(_DWORD *)(a1 + 208) = v7;
  v8 = *(_QWORD *)(v4 + 64);
  *(_QWORD *)(a1 + 212) = v8;
  v9 = *(_QWORD *)(v5 + 64);
  *(_QWORD *)(a1 + 220) = v9;
  v10 = *(float *)(v4 + 212);
  v11 = *(float *)(v5 + 212);
  *(float *)(a1 + 228) = v10;
  *(float *)(a1 + 232) = v11;
  v12 = *(float *)(v4 + 224);
  v13 = *(float *)(v5 + 224);
  *(float *)(a1 + 236) = v12;
  *(float *)(a1 + 240) = v13;
  v14 = *(_QWORD *)(a2 + 24);
  v15 = *(_QWORD *)(a2 + 32);
  v16 = (float *)(v14 + 16 * v6);
  v86 = *v16;
  v87 = v16[1];
  v17 = (float *)(v15 + 16 * v6);
  v82 = *v17;
  v83 = v17[3];
  v18 = (float *)(v14 + 16 * v7);
  v19 = v18[1];
  v84 = v17[1];
  v85 = *v18;
  v20 = v18[3];
  v21 = (float *)(v15 + 16 * v7);
  v80 = v21[1];
  v81 = *v21;
  v79 = v21[3];
  v24 = __sincosf_stret(v16[3]);
  cosval = v24.__cosval;
  LODWORD(v22) = *(_QWORD *)&v24;
  v25 = __sincosf_stret(v20);
  v26 = *(float *)(a1 + 128) - *(float *)&v8;
  v27 = *(float *)(a1 + 132) - *((float *)&v8 + 1);
  v28 = (float)(cosval * v26) - (float)(v22 * v27);
  v29 = (float)(cosval * v27) + (float)(v22 * v26);
  v30 = *(float *)(a1 + 136) - *(float *)&v9;
  v31 = *(float *)(a1 + 140) - *((float *)&v9 + 1);
  v32 = (float)(v25.__cosval * v30) - (float)(v25.__sinval * v31);
  v33 = (float)(v25.__cosval * v31) + (float)(v25.__sinval * v30);
  v34 = (float)((float)(v85 - v86) + v32) - v28;
  v35 = (float)((float)(v19 - v87) + v33) - v29;
  v36 = *(float *)(a1 + 144);
  v37 = *(float *)(a1 + 148);
  v38 = (float)(cosval * v36) - (float)(v22 * v37);
  v39 = (float)(cosval * v37) + (float)(v22 * v36);
  *(float *)(a1 + 244) = v38;
  *(float *)(a1 + 248) = v39;
  v40 = v28 + v34;
  v41 = v29 + v35;
  _S2 = (float)(v40 * v39) - (float)((float)(v29 + v35) * v38);
  *(float *)(a1 + 268) = _S2;
  _S0 = (float)(v32 * v39) - (float)(v33 * v38);
  *(float *)(a1 + 272) = _S0;
  v44 = (float)((float)(v10 + v11) + (float)((float)(v12 * _S2) * _S2)) + (float)((float)(v13 * _S0) * _S0);
  v45 = 1.0 / v44;
  if (v44 <= 0.0)
    v45 = (float)((float)(v10 + v11) + (float)((float)(v12 * _S2) * _S2)) + (float)((float)(v13 * _S0) * _S0);
  *(float *)(a1 + 312) = v45;
  v46 = *(float *)(a1 + 152);
  v47 = *(float *)(a1 + 156);
  v48 = (float)(cosval * v46) - (float)(v22 * v47);
  v49 = (float)(cosval * v47) + (float)(v22 * v46);
  *(float *)(a1 + 252) = v48;
  *(float *)(a1 + 256) = v49;
  v50 = (float)(v40 * v49) - (float)(v41 * v48);
  *(float *)(a1 + 260) = v50;
  v51 = (float)(v32 * v49) - (float)(v33 * v48);
  *(float *)(a1 + 264) = v51;
  v52 = (float)(v13 * v51) + (float)(v12 * v50);
  v53 = (float)(_S0 * (float)(v13 * v51)) + (float)((float)(v12 * v50) * _S2);
  v54 = v12 + v13;
  if ((float)(v12 + v13) == 0.0)
    v54 = 1.0;
  v55 = (float)(v13 * _S0) + (float)(v12 * _S2);
  *(float *)(a1 + 276) = (float)((float)(v10 + v11) + (float)((float)(v12 * v50) * v50))
                       + (float)((float)(v13 * v51) * v51);
  *(float *)(a1 + 280) = v52;
  *(float *)(a1 + 284) = v53;
  *(float *)(a1 + 288) = v52;
  *(float *)(a1 + 292) = v54;
  *(float *)(a1 + 296) = v55;
  *(float *)(a1 + 300) = v53;
  *(float *)(a1 + 304) = v55;
  *(float *)(a1 + 308) = v44;
  if (!*(_BYTE *)(a1 + 196))
    goto LABEL_12;
  v57 = *(float *)(a1 + 180);
  v56 = *(float *)(a1 + 184);
  v58 = v56 - v57;
  if ((float)(v56 - v57) <= 0.0)
    v58 = -(float)(v56 - v57);
  if (v58 < 0.009)
  {
    *(_DWORD *)(a1 + 200) = 3;
LABEL_13:
    v61 = v83;
    v60 = v84;
    v63 = v81;
    v62 = v82;
    v65 = v79;
    v64 = v80;
    goto LABEL_14;
  }
  v59 = (float)(v39 * v35) + (float)(v38 * v34);
  if (v59 <= v57)
  {
    v61 = v83;
    v60 = v84;
    v63 = v81;
    v62 = v82;
    v65 = v79;
    v64 = v80;
    if (*(_DWORD *)(a1 + 200) == 1)
      goto LABEL_14;
    v78 = 1;
    goto LABEL_24;
  }
  if (v59 < v56)
  {
LABEL_12:
    *(_DWORD *)(a1 + 200) = 0;
    *(_DWORD *)(a1 + 172) = 0;
    goto LABEL_13;
  }
  v61 = v83;
  v60 = v84;
  v63 = v81;
  v62 = v82;
  v65 = v79;
  v64 = v80;
  if (*(_DWORD *)(a1 + 200) != 2)
  {
    v78 = 2;
LABEL_24:
    *(_DWORD *)(a1 + 200) = v78;
    *(_DWORD *)(a1 + 172) = 0;
  }
LABEL_14:
  if (!*(_BYTE *)(a1 + 197))
    *(_DWORD *)(a1 + 176) = 0;
  if (*(_BYTE *)(a2 + 20))
  {
    v66 = vmulq_n_f32(*(float32x4_t *)(a1 + 164), COERCE_FLOAT(*(_OWORD *)(a2 + 8)));
    *(float32x4_t *)(a1 + 164) = v66;
    _Q17 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v66, 3), v66);
    v68 = (float)(v48 * v66.f32[0]) + vmuls_lane_f32(v38, _Q17, 2);
    v69 = (float)(v49 * v66.f32[0]) + vmuls_lane_f32(v39, _Q17, 2);
    __asm
    {
      FMLA            S7, S2, V17.S[2]
      FMLA            S6, S0, V17.S[2]
    }
    v62 = v62 - (float)(v10 * v68);
    v60 = v60 - (float)(v10 * v69);
    v61 = v61 - (float)(v12 * _S7);
    v63 = v63 + (float)(v11 * v68);
    v64 = v64 + (float)(v11 * v69);
    v65 = v65 + (float)(v13 * _S6);
  }
  else
  {
    *(_QWORD *)(a1 + 172) = 0;
    *(_QWORD *)(a1 + 164) = 0;
  }
  v76 = (float *)(*(_QWORD *)(a2 + 32) + 16 * *(int *)(a1 + 204));
  *v76 = v62;
  v76[1] = v60;
  v76[3] = v61;
  v77 = (float *)(*(_QWORD *)(a2 + 32) + 16 * *(int *)(a1 + 208));
  *v77 = v63;
  v77[1] = v64;
  v77[3] = v65;
}

void b2PrismaticJoint::SolveVelocityConstraints(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  float *v5;
  float v6;
  float v7;
  float v8;
  float *v9;
  float v10;
  float v11;
  float v12;
  float v13;
  float v14;
  float v15;
  float v16;
  float v17;
  float v18;
  float v19;
  float v20;
  float v21;
  float v22;
  float v23;
  float v24;
  float v25;
  float v26;
  float v27;
  float v28;
  float v29;
  float v30;
  float v31;
  float v32;
  float v33;
  float v34;
  float v35;
  float v36;
  float v37;
  float v38;
  int v39;
  _BOOL4 v40;
  float v41;
  float v42;
  float v43;
  float32x2_t v44;
  float v45;
  float v46;
  float v47;
  float v48;
  float v49;
  float v50;
  float v51;
  float v52;
  float v53;
  float v54;
  float v55;
  float v56;
  float v57;
  float v58;
  float v59;
  float *v60;
  float *v61;
  float v62;
  float v63;
  float v64;
  float v65;
  float v66;
  float v67;
  float v68;
  b2Vec3 v69;

  v4 = *(_QWORD *)(a2 + 32);
  v5 = (float *)(v4 + 16 * *(int *)(a1 + 204));
  v6 = *v5;
  v7 = v5[1];
  v8 = v5[3];
  v9 = (float *)(v4 + 16 * *(int *)(a1 + 208));
  v10 = *v9;
  v11 = v9[1];
  v12 = v9[3];
  v14 = *(float *)(a1 + 228);
  v13 = *(float *)(a1 + 232);
  v16 = *(float *)(a1 + 236);
  v15 = *(float *)(a1 + 240);
  if (*(_BYTE *)(a1 + 197) && *(_DWORD *)(a1 + 200) != 3)
  {
    v17 = *(float *)(a1 + 244);
    v18 = *(float *)(a1 + 248);
    v19 = *(float *)(a1 + 272);
    v20 = *(float *)(a1 + 268);
    v21 = *(float *)(a1 + 188);
    v22 = *(float *)(a1 + 176);
    v23 = *(float *)a2 * v21;
    v24 = v22
        + (float)(*(float *)(a1 + 312)
                * (float)(*(float *)(a1 + 192)
                        - (float)((float)((float)((float)((float)(v11 - v7) * v18) + (float)(v17 * (float)(v10 - v6)))
                                        + (float)(v19 * v12))
                                - (float)(v20 * v8))));
    if (v24 >= v23)
      v24 = *(float *)a2 * v21;
    if (v24 < (float)-v23)
      v24 = -v23;
    *(float *)(a1 + 176) = v24;
    v25 = v24 - v22;
    v26 = v17 * v25;
    v27 = v18 * v25;
    v6 = v6 - (float)(v14 * v26);
    v7 = v7 - (float)(v14 * v27);
    v8 = v8 - (float)(v16 * (float)(v20 * v25));
    v10 = v10 + (float)(v13 * v26);
    v11 = v11 + (float)(v13 * v27);
    v12 = v12 + (float)(v15 * (float)(v19 * v25));
  }
  v67 = v16;
  v68 = v15;
  v28 = (float)((float)((float)((float)(v11 - v7) * *(float *)(a1 + 256))
                      + (float)(*(float *)(a1 + 252) * (float)(v10 - v6)))
              + (float)(*(float *)(a1 + 264) * v12))
      - (float)(*(float *)(a1 + 260) * v8);
  v29 = v12 - v8;
  if (*(_BYTE *)(a1 + 196) && *(_DWORD *)(a1 + 200))
  {
    v65 = v14;
    v66 = v13;
    v30 = (float)((float)((float)(v11 - v7) * *(float *)(a1 + 248)) + (float)(*(float *)(a1 + 244) * (float)(v10 - v6)))
        + (float)(*(float *)(a1 + 272) * v12);
    v31 = -*(float *)(a1 + 268);
    v62 = *(float *)(a1 + 168);
    v63 = *(float *)(a1 + 164);
    v64 = *(float *)(a1 + 172);
    v32 = -v28;
    v33 = -v29;
    v69.var0 = -v28;
    v69.var1 = -v29;
    v69.var2 = -(float)(v30 + (float)(v31 * v8));
    v34 = b2Mat33::Solve33((b2Mat33 *)(a1 + 276), &v69);
    v35 = *(float *)(a1 + 168);
    *(float *)(a1 + 164) = v34 + *(float *)(a1 + 164);
    *(float *)(a1 + 168) = v36 + v35;
    v38 = v37 + *(float *)(a1 + 172);
    *(float *)(a1 + 172) = v38;
    v39 = *(_DWORD *)(a1 + 200);
    if (v39 == 2)
    {
      v40 = v38 < 0.0;
    }
    else
    {
      if (v39 != 1)
      {
LABEL_18:
        v49 = v38 - v64;
        v50 = v32 - (float)(*(float *)(a1 + 300) * v49);
        v51 = v33 - (float)(v49 * *(float *)(a1 + 304));
        v69.var0 = v50;
        v69.var1 = v51;
        v52 = v63 + b2Mat33::Solve22((b2Mat33 *)(a1 + 276), (const b2Vec2 *)&v69);
        v54 = v62 + v53;
        *(float *)(a1 + 164) = v52;
        *(float *)(a1 + 168) = v54;
        v55 = v52 - v63;
        v56 = v54 - v62;
        v57 = *(float *)(a1 + 172) - v64;
        v44 = vadd_f32(vmul_n_f32(*(float32x2_t *)(a1 + 252), v55), vmul_n_f32(*(float32x2_t *)(a1 + 244), v57));
        v58 = (float)(v56 + (float)(v55 * *(float *)(a1 + 260))) + (float)(v57 * *(float *)(a1 + 268));
        v59 = (float)(v56 + (float)(v55 * *(float *)(a1 + 264))) + (float)(v57 * *(float *)(a1 + 272));
        v47 = v8 - (float)(v67 * v58);
        v48 = v12 + (float)(v68 * v59);
        v14 = v65;
        v13 = v66;
        goto LABEL_19;
      }
      v40 = v38 > 0.0;
    }
    if (!v40)
      v38 = 0.0;
    *(float *)(a1 + 172) = v38;
    goto LABEL_18;
  }
  v69.var0 = -v28;
  v69.var1 = -v29;
  v41 = b2Mat33::Solve22((b2Mat33 *)(a1 + 276), (const b2Vec2 *)&v69);
  v43 = v42 + *(float *)(a1 + 168);
  *(float *)(a1 + 164) = v41 + *(float *)(a1 + 164);
  *(float *)(a1 + 168) = v43;
  v44 = vmul_n_f32(*(float32x2_t *)(a1 + 252), v41);
  v45 = v42 + (float)(v41 * *(float *)(a1 + 260));
  v46 = v42 + (float)(v41 * *(float *)(a1 + 264));
  v47 = v8 - (float)(v67 * v45);
  v48 = v12 + (float)(v68 * v46);
LABEL_19:
  v60 = (float *)(*(_QWORD *)(a2 + 32) + 16 * *(int *)(a1 + 204));
  *v60 = v6 - (float)(v14 * v44.f32[0]);
  v60[1] = v7 - vmuls_lane_f32(v14, v44, 1);
  v60[3] = v47;
  v61 = (float *)(*(_QWORD *)(a2 + 32) + 16 * *(int *)(a1 + 208));
  *v61 = v10 + (float)(v13 * v44.f32[0]);
  v61[1] = v11 + vmuls_lane_f32(v13, v44, 1);
  v61[3] = v48;
}

BOOL b2PrismaticJoint::SolvePositionConstraints(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  float *v5;
  float v6;
  float v7;
  float v8;
  float *v9;
  float v10;
  float v11;
  float v12;
  __float2 v13;
  __float2 v14;
  float v15;
  float v16;
  float v17;
  float v18;
  float v19;
  float v20;
  float v21;
  float v22;
  float v23;
  float v24;
  float v25;
  float v26;
  float v27;
  float v28;
  float v29;
  float v30;
  float v31;
  float v32;
  float v33;
  float v34;
  float v35;
  float v36;
  float v37;
  float v38;
  float v39;
  float v40;
  float v41;
  float v42;
  float v43;
  float v44;
  float v45;
  float v46;
  float v47;
  float v48;
  float v49;
  float v50;
  float v51;
  float v52;
  float v53;
  float v54;
  float v55;
  float v56;
  float v57;
  float v58;
  float v59;
  float v60;
  float v61;
  float v62;
  float v63;
  float v64;
  float v65;
  float v66;
  float v67;
  float v68;
  float v69;
  float v70;
  float v71;
  float v72;
  float v73;
  float v74;
  float v75;
  float v76;
  float v77;
  float v78;
  float v79;
  float v80;
  float v81;
  float v82;
  float v83;
  float v84;
  float v85;
  float v86;
  float v87;
  float v88;
  float v89;
  float v90;
  float v91;
  float v92;
  float v93;
  float v94;
  float v95;
  float v96;
  float v97;
  float v98;
  float *v99;
  float *v100;
  float v102;
  float v103;
  float v104;
  float v105;
  float v106;
  float v107;
  float v108;
  float v109;
  float v110;
  float v111;
  float v112;
  float v113;
  float v114;
  float v115;
  float v116;
  float v117;
  float v118;
  float v119;
  float v120;
  b2Vec3 v121;

  v4 = *(_QWORD *)(a2 + 24);
  v5 = (float *)(v4 + 16 * *(int *)(a1 + 204));
  v6 = *v5;
  v7 = v5[1];
  v8 = v5[3];
  v115 = v8;
  v9 = (float *)(v4 + 16 * *(int *)(a1 + 208));
  v11 = *v9;
  v10 = v9[1];
  v12 = v9[3];
  v13 = __sincosf_stret(v8);
  v14 = __sincosf_stret(v12);
  v16 = *(float *)(a1 + 228);
  v15 = *(float *)(a1 + 232);
  v18 = *(float *)(a1 + 236);
  v17 = *(float *)(a1 + 240);
  v19 = *(float *)(a1 + 128) - *(float *)(a1 + 212);
  v20 = *(float *)(a1 + 132) - *(float *)(a1 + 216);
  v21 = (float)(v13.__cosval * v19) - (float)(v13.__sinval * v20);
  v22 = (float)(v13.__cosval * v20) + (float)(v13.__sinval * v19);
  v23 = *(float *)(a1 + 136) - *(float *)(a1 + 220);
  v24 = *(float *)(a1 + 140) - *(float *)(a1 + 224);
  v25 = (float)(v14.__cosval * v23) - (float)(v14.__sinval * v24);
  v26 = (float)(v14.__cosval * v24) + (float)(v14.__sinval * v23);
  v117 = v7;
  v118 = v11;
  v27 = v11 + v25;
  v28 = v22;
  v120 = v10;
  v29 = v10 + v26;
  v30 = v26;
  v116 = v6;
  v31 = (float)(v27 - v6) - v21;
  v32 = (float)(v29 - v7) - v22;
  v33 = *(float *)(a1 + 144);
  v34 = *(float *)(a1 + 148);
  v35 = (float)(v13.__cosval * v33) - (float)(v13.__sinval * v34);
  v36 = (float)(v13.__cosval * v34) + (float)(v13.__sinval * v33);
  v37 = *(float *)(a1 + 152);
  v38 = *(float *)(a1 + 156);
  v39 = (float)(v13.__cosval * v37) - (float)(v13.__sinval * v38);
  v40 = (float)(v13.__cosval * v38) + (float)(v13.__sinval * v37);
  v41 = (float)(v40 * v32) + (float)(v39 * v31);
  v119 = v12;
  v42 = (float)(v12 - v8) - *(float *)(a1 + 160);
  v43 = -v41;
  if (v41 <= 0.0)
    v44 = -v41;
  else
    v44 = (float)(v40 * v32) + (float)(v39 * v31);
  v45 = -v42;
  v113 = v36;
  v114 = v21;
  v111 = v40;
  v112 = v32;
  if (*(_BYTE *)(a1 + 196))
  {
    v46 = (float)(v36 * v32) + (float)(v35 * v31);
    v48 = *(float *)(a1 + 180);
    v47 = *(float *)(a1 + 184);
    v49 = v47 - v48;
    if ((float)(v47 - v48) <= 0.0)
      v49 = -(float)(v47 - v48);
    if (v49 < 0.009)
    {
      v103 = (float)(v12 - v8) - *(float *)(a1 + 160);
      v105 = v39;
      v107 = v31;
      v109 = v25;
      v102 = v35;
      v50 = fminf(v46, 0.2);
      if (v50 < -0.2)
        v50 = -0.2;
      if (v46 <= 0.0)
        v46 = -v46;
LABEL_23:
      if (v44 <= v46)
        v44 = v46;
      v76 = *(float *)(a1 + 260);
      v77 = v18 * v76;
      v78 = *(float *)(a1 + 264);
      v79 = v17 * v78;
      v80 = (float)((float)(v16 + v15) + (float)((float)(v18 * v76) * v76)) + (float)((float)(v17 * v78) * v78);
      v81 = (float)(v17 * v78) + (float)(v18 * v76);
      v82 = *(float *)(a1 + 268);
      v83 = *(float *)(a1 + 272);
      v84 = (float)(v79 * v83) + (float)(v77 * v82);
      v85 = v18 + v17;
      if ((float)(v18 + v17) == 0.0)
        v85 = 1.0;
      v86 = (float)(v17 * v83) + (float)(v18 * v82);
      *(float *)(a1 + 276) = v80;
      *(float *)(a1 + 280) = v81;
      *(float *)(a1 + 284) = v84;
      *(float *)(a1 + 288) = v81;
      *(float *)(a1 + 292) = v85;
      *(float *)(a1 + 296) = v86;
      *(float *)(a1 + 300) = v84;
      *(float *)(a1 + 304) = v86;
      *(float *)(a1 + 308) = (float)((float)(v16 + v15) + (float)((float)(v18 * v82) * v82))
                           + (float)((float)(v17 * v83) * v83);
      v121.var0 = v43;
      v121.var1 = -v42;
      v121.var2 = -v50;
      v87 = v17;
      v88 = v15;
      v57 = v18;
      v73 = v16;
      v89 = v45;
      v62 = b2Mat33::Solve33((b2Mat33 *)(a1 + 276), &v121);
      v64 = v89;
      v65 = v88;
      v74 = v87;
      v71 = v113;
      v70 = v114;
      v69 = v107;
      v72 = v109;
      v59 = v102;
      v42 = v103;
      v67 = v111;
      v66 = v112;
      v68 = v105;
      goto LABEL_28;
    }
    if (v46 <= v48)
    {
      v103 = (float)(v12 - v8) - *(float *)(a1 + 160);
      v105 = v39;
      v107 = v31;
      v109 = v25;
      v102 = v35;
      v50 = fminf((float)(v46 - v48) + 0.0045, 0.0);
      if (v50 < -0.2)
        v50 = -0.2;
      v46 = v48 - v46;
      goto LABEL_23;
    }
    if (v46 >= v47)
    {
      v103 = (float)(v12 - v8) - *(float *)(a1 + 160);
      v105 = v39;
      v107 = v31;
      v109 = v25;
      v102 = v35;
      v46 = v46 - v47;
      v50 = fminf(v46 + -0.0045, 0.2);
      if (v50 < 0.0)
        v50 = 0.0;
      goto LABEL_23;
    }
  }
  v51 = *(float *)(a1 + 260);
  v52 = *(float *)(a1 + 264);
  v53 = (float)((float)(v16 + v15) + (float)((float)(v18 * v51) * v51)) + (float)((float)(v17 * v52) * v52);
  v54 = (float)(v17 * v52) + (float)(v18 * v51);
  *(float *)(a1 + 276) = v53;
  *(float *)(a1 + 280) = v54;
  v55 = 1.0;
  *(_DWORD *)(a1 + 284) = 0;
  *(float *)(a1 + 288) = v54;
  if ((float)(v18 + v17) != 0.0)
    v55 = v18 + v17;
  *(float *)(a1 + 292) = v55;
  *(_DWORD *)(a1 + 296) = 0;
  v121.var0 = v43;
  v121.var1 = -v42;
  v56 = v17;
  v104 = v15;
  v106 = v16;
  v57 = v18;
  v108 = v28;
  v110 = v30;
  v58 = v25;
  v59 = v35;
  v60 = v31;
  v61 = v39;
  v62 = b2Mat33::Solve22((b2Mat33 *)(a1 + 276), (const b2Vec2 *)&v121);
  v64 = -v42;
  v65 = v104;
  v67 = v111;
  v66 = v112;
  v68 = v61;
  v69 = v60;
  v71 = v113;
  v70 = v114;
  v72 = v58;
  v28 = v108;
  v30 = v110;
  v73 = v106;
  v74 = v56;
  v75 = 0.0;
LABEL_28:
  if (v42 <= 0.0)
    v90 = v64;
  else
    v90 = v42;
  v91 = (float)(v72 * v67) - (float)(v30 * v68);
  v92 = v70 + v69;
  v93 = v28 + v66;
  v94 = (float)(v92 * v67) - (float)((float)(v28 + v66) * v68);
  v95 = (float)(v72 * v71) - (float)(v30 * v59);
  v96 = (float)(v92 * v71) - (float)(v93 * v59);
  v97 = (float)(v68 * v62) + (float)(v59 * v75);
  v98 = (float)(v67 * v62) + (float)(v71 * v75);
  v99 = (float *)(*(_QWORD *)(a2 + 24) + 16 * *(int *)(a1 + 204));
  *v99 = v116 - (float)(v73 * v97);
  v99[1] = v117 - (float)(v73 * v98);
  v99[3] = v115 - (float)(v57 * (float)((float)(v63 + (float)(v62 * v94)) + (float)(v75 * v96)));
  v100 = (float *)(*(_QWORD *)(a2 + 24) + 16 * *(int *)(a1 + 208));
  *v100 = v118 + (float)(v65 * v97);
  v100[1] = v120 + (float)(v65 * v98);
  v100[3] = v119 + (float)(v74 * (float)((float)(v63 + (float)(v62 * v91)) + (float)(v75 * v95)));
  return v90 <= 0.034907 && v44 <= 0.0045;
}

float b2PrismaticJoint::GetAnchorA(b2PrismaticJoint *this)
{
  return this->var6->var8.var0.x
       + (float)((float)(this->var6->var8.var1.var1 * this->var11.x)
               - (float)(this->var6->var8.var1.var0 * this->var11.y));
}

float b2PrismaticJoint::GetAnchorB(b2PrismaticJoint *this)
{
  return this->var7->var8.var0.x
       + (float)((float)(this->var7->var8.var1.var1 * this->var12.x)
               - (float)(this->var7->var8.var1.var0 * this->var12.y));
}

float32x2_t b2PrismaticJoint::GetReactionForce(b2PrismaticJoint *this, float a2)
{
  return vmul_n_f32(vadd_f32(vmul_n_f32((float32x2_t)this->var34, this->var16.var0), vmul_n_f32((float32x2_t)this->var33, this->var17 + this->var16.var2)), a2);
}

float b2PrismaticJoint::GetReactionTorque(b2PrismaticJoint *this, float a2)
{
  return this->var16.var1 * a2;
}

float b2PrismaticJoint::GetJointTranslation(b2PrismaticJoint *this)
{
  b2Body *var6;
  b2Body *var7;
  float var1;
  float var0;
  float x;

  var6 = this->var6;
  var7 = this->var7;
  var0 = var6->var8.var1.var0;
  var1 = var6->var8.var1.var1;
  x = this->var11.x;
  return (float)((float)((float)((float)((float)(var7->var8.var1.var1 * this->var12.y)
                                       + (float)(var7->var8.var1.var0 * this->var12.x))
                               + var7->var8.var0.y)
                       - (float)((float)((float)(var1 * this->var11.y) + (float)(var0 * x)) + var6->var8.var0.y))
               * (float)((float)(var1 * this->var13.y) + (float)(var0 * this->var13.x)))
       + (float)((float)((float)(var7->var8.var0.x
                               + (float)((float)(var7->var8.var1.var1 * this->var12.x)
                                       - (float)(var7->var8.var1.var0 * this->var12.y)))
                       - (float)(var6->var8.var0.x + (float)((float)(var1 * x) - (float)(var0 * this->var11.y))))
               * (float)((float)(var1 * this->var13.x) - (float)(var0 * this->var13.y)));
}

float b2PrismaticJoint::GetJointSpeed(b2PrismaticJoint *this)
{
  float *p_var0;
  float *v2;
  float v3;
  float v4;
  float v5;
  float v6;
  float v7;
  float v8;
  float v9;
  float v10;
  float v11;
  float v12;
  float v13;
  float v14;
  float x;
  float y;
  float v17;

  p_var0 = (float *)&this->var6->var0;
  v2 = (float *)&this->var7->var0;
  v3 = this->var11.x - p_var0[16];
  v4 = this->var11.y - p_var0[17];
  v6 = p_var0[10];
  v5 = p_var0[11];
  v7 = (float)(v5 * v3) - (float)(v6 * v4);
  v8 = (float)(v5 * v4) + (float)(v6 * v3);
  v9 = this->var12.x - v2[16];
  v10 = this->var12.y - v2[17];
  v12 = v2[10];
  v11 = v2[11];
  v13 = (float)(v11 * v9) - (float)(v12 * v10);
  v14 = (float)(v11 * v10) + (float)(v12 * v9);
  x = this->var13.x;
  y = this->var13.y;
  v17 = p_var0[34];
  return (float)((float)((float)((float)(v14 + v2[25]) - (float)(v8 + p_var0[25]))
                       * (float)((float)((float)(v5 * x) - (float)(v6 * y)) * v17))
               + (float)((float)((float)(v13 + v2[24]) - (float)(v7 + p_var0[24]))
                       * (float)-(float)(v17 * (float)((float)(v5 * y) + (float)(v6 * x)))))
       + (float)((float)((float)((float)(v5 * y) + (float)(v6 * x))
                       * (float)((float)((float)(v2[33] + (float)(v13 * v2[34])) - p_var0[33]) - (float)(v7 * v17)))
               + (float)((float)((float)(v5 * x) - (float)(v6 * y))
                       * (float)((float)(v8 * v17) + (float)((float)(v2[32] - (float)(v14 * v2[34])) - p_var0[32]))));
}

BOOL b2PrismaticJoint::IsLimitEnabled(b2PrismaticJoint *this)
{
  return this->var22;
}

b2PrismaticJoint *b2PrismaticJoint::EnableLimit(b2PrismaticJoint *this, _BOOL4 a2)
{
  BOOL v2;
  b2PrismaticJoint *v3;

  if (this->var22 != a2)
  {
    v2 = a2;
    v3 = this;
    b2Body::SetAwake(this->var6, 1);
    this = (b2PrismaticJoint *)b2Body::SetAwake(v3->var7, 1);
    v3->var22 = v2;
    v3->var16.var2 = 0.0;
  }
  return this;
}

float b2PrismaticJoint::GetLowerLimit(b2PrismaticJoint *this)
{
  return this->var18;
}

float b2PrismaticJoint::GetUpperLimit(b2PrismaticJoint *this)
{
  return this->var19;
}

b2PrismaticJoint *b2PrismaticJoint::SetLimits(b2PrismaticJoint *this, float a2, float a3)
{
  b2PrismaticJoint *v5;

  if (a2 > a3)
    b2PrismaticJoint::SetLimits();
  v5 = this;
  if (this->var18 != a2 || this->var19 != a3)
  {
    b2Body::SetAwake(this->var6, 1);
    this = (b2PrismaticJoint *)b2Body::SetAwake(v5->var7, 1);
    v5->var18 = a2;
    v5->var19 = a3;
    v5->var16.var2 = 0.0;
  }
  return this;
}

BOOL b2PrismaticJoint::IsMotorEnabled(b2PrismaticJoint *this)
{
  return this->var23;
}

b2Body *b2PrismaticJoint::EnableMotor(b2PrismaticJoint *this, BOOL a2)
{
  b2Body *result;

  b2Body::SetAwake(this->var6, 1);
  result = b2Body::SetAwake(this->var7, 1);
  this->var23 = a2;
  return result;
}

b2Body *b2PrismaticJoint::SetMotorSpeed(b2PrismaticJoint *this, float a2)
{
  b2Body *result;

  b2Body::SetAwake(this->var6, 1);
  result = b2Body::SetAwake(this->var7, 1);
  this->var21 = a2;
  return result;
}

b2Body *b2PrismaticJoint::SetMaxMotorForce(b2PrismaticJoint *this, float a2)
{
  b2Body *result;

  b2Body::SetAwake(this->var6, 1);
  result = b2Body::SetAwake(this->var7, 1);
  this->var20 = a2;
  return result;
}

float b2PrismaticJoint::GetMotorForce(b2PrismaticJoint *this, float a2)
{
  return this->var17 * a2;
}

void b2PrismaticJoint::~b2PrismaticJoint(b2PrismaticJoint *this)
{
  JUMPOUT(0x20BD0BA58);
}

uint64_t b2PulleyJointDef::Initialize(uint64_t this, b2Body *a2, b2Body *a3, const b2Vec2 *a4, const b2Vec2 *a5, const b2Vec2 *a6, const b2Vec2 *a7, float a8)
{
  float v8;
  float v9;
  float var1;
  float var0;
  float v12;
  float v13;
  float v14;
  float v15;
  float v16;
  float v17;
  float v18;

  *(_QWORD *)(this + 16) = a2;
  *(_QWORD *)(this + 24) = a3;
  *(b2Vec2 *)(this + 36) = *a4;
  *(b2Vec2 *)(this + 44) = *a5;
  v8 = a6->x - a2->var8.var0.x;
  v9 = a6->y - a2->var8.var0.y;
  var0 = a2->var8.var1.var0;
  var1 = a2->var8.var1.var1;
  *(float *)(this + 52) = (float)(v9 * var0) + (float)(var1 * v8);
  *(float *)(this + 56) = (float)(var1 * v9) - (float)(var0 * v8);
  v12 = a7->x - a3->var8.var0.x;
  v13 = a7->y - a3->var8.var0.y;
  v15 = a3->var8.var1.var0;
  v14 = a3->var8.var1.var1;
  *(float *)(this + 60) = (float)(v13 * v15) + (float)(v14 * v12);
  *(float *)(this + 64) = (float)(v14 * v13) - (float)(v15 * v12);
  v16 = a6->y - a4->y;
  v17 = sqrtf((float)(v16 * v16) + (float)((float)(a6->x - a4->x) * (float)(a6->x - a4->x)));
  v18 = sqrtf((float)((float)(a7->y - a5->y) * (float)(a7->y - a5->y))+ (float)((float)(a7->x - a5->x) * (float)(a7->x - a5->x)));
  *(float *)(this + 68) = v17;
  *(float *)(this + 72) = v18;
  *(float *)(this + 76) = a8;
  if (a8 <= 0.00000011921)
    b2PulleyJointDef::Initialize();
  return this;
}

void b2PulleyJoint::b2PulleyJoint(b2PulleyJoint *this, const b2PulleyJointDef *a2)
{
  uint64_t v3;
  float v4;

  b2Joint::b2Joint((b2Joint *)this, (const b2JointDef *)a2);
  *(_QWORD *)v3 = off_24C0E8090;
  *(_QWORD *)(v3 + 128) = *(_QWORD *)((char *)a2 + 36);
  *(_QWORD *)(v3 + 136) = *(_QWORD *)((char *)a2 + 44);
  *(_QWORD *)(v3 + 144) = *(_QWORD *)((char *)a2 + 52);
  *(_QWORD *)(v3 + 152) = *(_QWORD *)((char *)a2 + 60);
  v4 = *((float *)a2 + 19);
  if (v4 == 0.0)
    b2PulleyJoint::b2PulleyJoint();
  *(float *)(v3 + 160) = *((float *)a2 + 17) + (float)(v4 * *((float *)a2 + 18));
  *(float *)(v3 + 164) = v4;
  *(_DWORD *)(v3 + 168) = 0;
}

void b2PulleyJoint::InitVelocityConstraints(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  float v10;
  float v11;
  float v12;
  uint64_t v13;
  uint64_t v14;
  float *v15;
  float v16;
  float v17;
  float *v18;
  float *v19;
  float v20;
  float v21;
  float v22;
  float *v23;
  __float2 v24;
  __float2 v25;
  float v26;
  float v27;
  float v28;
  float v29;
  float v30;
  float v31;
  float v32;
  float v33;
  float v34;
  float v35;
  float v36;
  float v37;
  float v38;
  float v39;
  float v40;
  float v41;
  float v42;
  float v43;
  float v44;
  float v45;
  float v46;
  float v47;
  float v48;
  float v49;
  float v50;
  float v51;
  float v52;
  float v53;
  float v54;
  float v55;
  float v56;
  float v57;
  float *v58;
  float v59;
  float v60;
  float v61;
  float v62;
  float v63;
  float v64;
  float v65;
  float v66;
  float v67;

  v4 = *(_QWORD *)(a1 + 96);
  v5 = *(_QWORD *)(a1 + 104);
  v6 = *(int *)(v4 + 28);
  v7 = *(int *)(v5 + 28);
  *(_DWORD *)(a1 + 172) = v6;
  *(_DWORD *)(a1 + 176) = v7;
  v8 = *(_QWORD *)(v4 + 64);
  *(_QWORD *)(a1 + 212) = v8;
  v9 = *(_QWORD *)(v5 + 64);
  *(_QWORD *)(a1 + 220) = v9;
  v10 = *(float *)(v4 + 212);
  v11 = *(float *)(v5 + 212);
  *(float *)(a1 + 228) = v10;
  *(float *)(a1 + 232) = v11;
  v60 = v11;
  v12 = *(float *)(v5 + 224);
  v59 = *(float *)(v4 + 224);
  *(float *)(a1 + 236) = v59;
  *(float *)(a1 + 240) = v12;
  v61 = v12;
  v13 = *(_QWORD *)(a2 + 24);
  v14 = *(_QWORD *)(a2 + 32);
  v15 = (float *)(v13 + 16 * v6);
  v17 = *v15;
  v16 = v15[1];
  v18 = (float *)(v14 + 16 * v6);
  v67 = v18[1];
  v65 = *v18;
  v66 = v18[3];
  v19 = (float *)(v13 + 16 * v7);
  v20 = *v19;
  v21 = v19[1];
  v22 = v19[3];
  v23 = (float *)(v14 + 16 * v7);
  v63 = v23[1];
  v64 = *v23;
  v62 = v23[3];
  v24 = __sincosf_stret(v15[3]);
  v25 = __sincosf_stret(v22);
  v26 = *(float *)(a1 + 144) - *(float *)&v8;
  v27 = *(float *)(a1 + 148) - *((float *)&v8 + 1);
  v28 = (float)(v24.__cosval * v26) - (float)(v24.__sinval * v27);
  v29 = (float)(v24.__cosval * v27) + (float)(v24.__sinval * v26);
  *(float *)(a1 + 196) = v28;
  *(float *)(a1 + 200) = v29;
  v30 = *(float *)(a1 + 152) - *(float *)&v9;
  v31 = *(float *)(a1 + 156) - *((float *)&v9 + 1);
  v32 = (float)(v25.__cosval * v30) - (float)(v25.__sinval * v31);
  v33 = (float)(v25.__cosval * v31) + (float)(v25.__sinval * v30);
  *(float *)(a1 + 204) = v32;
  *(float *)(a1 + 208) = v33;
  v34 = (float)(v17 + v28) - *(float *)(a1 + 128);
  v35 = (float)(v16 + v29) - *(float *)(a1 + 132);
  v36 = (float)(v20 + v32) - *(float *)(a1 + 136);
  v37 = (float)(v21 + v33) - *(float *)(a1 + 140);
  v38 = sqrtf((float)(v35 * v35) + (float)(v34 * v34));
  v39 = sqrtf((float)(v37 * v37) + (float)(v36 * v36));
  v40 = 0.0;
  v41 = 0.0;
  v42 = 0.0;
  if (v38 > 0.045)
  {
    v41 = v34 * (float)(1.0 / v38);
    v42 = v35 * (float)(1.0 / v38);
  }
  *(float *)(a1 + 180) = v41;
  *(float *)(a1 + 184) = v42;
  v43 = 0.0;
  if (v39 > 0.045)
  {
    v40 = v36 * (float)(1.0 / v39);
    v43 = v37 * (float)(1.0 / v39);
  }
  *(float *)(a1 + 188) = v40;
  *(float *)(a1 + 192) = v43;
  v44 = *(float *)(a1 + 164);
  v45 = (float)(v10
              + (float)((float)(v59 * (float)((float)(v28 * v42) - (float)(v29 * v41)))
                      * (float)((float)(v28 * v42) - (float)(v29 * v41))))
      + (float)((float)(v44 * v44)
              * (float)(v60
                      + (float)((float)(v61 * (float)((float)(v32 * v43) - (float)(v33 * v40)))
                              * (float)((float)(v32 * v43) - (float)(v33 * v40)))));
  if (v45 > 0.0)
    v45 = 1.0 / v45;
  *(float *)(a1 + 244) = v45;
  if (*(_BYTE *)(a2 + 20))
  {
    v46 = *(float *)(a2 + 8) * *(float *)(a1 + 168);
    *(float *)(a1 + 168) = v46;
    v47 = -(float)(v46 * v41);
    v48 = -(float)(v46 * v42);
    v49 = -(float)(v44 * v46);
    v50 = v40 * v49;
    v51 = v43 * v49;
    v52 = v65 + (float)(v10 * v47);
    v53 = v67 + (float)(v10 * v48);
    v54 = v66 + (float)(v59 * (float)((float)(v47 * (float)-v29) + (float)(v28 * v48)));
    v55 = v64 + (float)(v60 * v50);
    v56 = v63 + (float)(v60 * v51);
    v57 = v62 + (float)(v61 * (float)((float)(v50 * (float)-v33) + (float)(v32 * v51)));
  }
  else
  {
    *(_DWORD *)(a1 + 168) = 0;
    v54 = v66;
    v53 = v67;
    v55 = v64;
    v52 = v65;
    v57 = v62;
    v56 = v63;
  }
  *v18 = v52;
  v18[1] = v53;
  v18[3] = v54;
  v58 = (float *)(*(_QWORD *)(a2 + 32) + 16 * *(int *)(a1 + 176));
  *v58 = v55;
  v58[1] = v56;
  v58[3] = v57;
}

float b2PulleyJoint::SolveVelocityConstraints(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  float *v3;
  float v4;
  float v5;
  float v6;
  float *v7;
  float v8;
  float v9;
  float v10;
  float v11;
  float v12;
  float v13;
  float v14;
  float v15;
  float v16;
  float v17;
  float v18;
  float v19;
  float v20;
  float v21;
  float v22;
  float v23;
  float v24;
  float v25;
  float v26;
  float v27;
  float result;
  float v29;
  float v30;
  float *v31;

  v2 = *(_QWORD *)(a2 + 32);
  v3 = (float *)(v2 + 16 * *(int *)(a1 + 172));
  v4 = *v3;
  v5 = v3[1];
  v6 = v3[3];
  v7 = (float *)(v2 + 16 * *(int *)(a1 + 176));
  v8 = *v7;
  v9 = v7[1];
  v10 = v7[3];
  v12 = *(float *)(a1 + 196);
  v11 = *(float *)(a1 + 200);
  v14 = *(float *)(a1 + 204);
  v13 = *(float *)(a1 + 208);
  v15 = *(float *)(a1 + 180);
  v16 = *(float *)(a1 + 184);
  v17 = *(float *)(a1 + 188);
  v18 = *(float *)(a1 + 192);
  v19 = *(float *)(a1 + 164);
  v20 = -(float)(*(float *)(a1 + 244)
               * (float)-(float)((float)((float)((float)(v5 + (float)(v6 * v12)) * v16)
                                       + (float)(v15 * (float)(*v3 - (float)(v6 * v11))))
                               + (float)(v19
                                       * (float)((float)((float)(v9 + (float)(v10 * v14)) * v18)
                                               + (float)(v17 * (float)(*v7 - (float)(v10 * v13)))))));
  *(float *)(a1 + 168) = *(float *)(a1 + 168)
                       - (float)(*(float *)(a1 + 244)
                               * (float)-(float)((float)((float)((float)(v5 + (float)(v6 * v12)) * v16)
                                                       + (float)(v15 * (float)(*v3 - (float)(v6 * v11))))
                                               + (float)(v19
                                                       * (float)((float)((float)(v9 + (float)(v10 * v14)) * v18)
                                                               + (float)(v17 * (float)(*v7 - (float)(v10 * v13)))))));
  v21 = -(float)(v20 * v15);
  v22 = -(float)(v20 * v16);
  v23 = -(float)(v19 * v20);
  v24 = v17 * v23;
  v25 = v18 * v23;
  v26 = *(float *)(a1 + 228);
  v27 = *(float *)(a1 + 232);
  result = v4 + (float)(v26 * v21);
  v29 = v6 + (float)(*(float *)(a1 + 236) * (float)((float)(v12 * v22) - (float)(v11 * v21)));
  v30 = v10 + (float)(*(float *)(a1 + 240) * (float)((float)(v14 * v25) - (float)(v13 * v24)));
  *v3 = result;
  v3[1] = v5 + (float)(v26 * v22);
  v3[3] = v29;
  v31 = (float *)(*(_QWORD *)(a2 + 32) + 16 * *(int *)(a1 + 176));
  *v31 = v8 + (float)(v24 * v27);
  v31[1] = v9 + (float)(v25 * v27);
  v31[3] = v30;
  return result;
}

BOOL b2PulleyJoint::SolvePositionConstraints(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  float *v5;
  float v6;
  float v7;
  float v8;
  float *v9;
  float v10;
  float v11;
  float v12;
  __float2 v13;
  __float2 v14;
  float v15;
  float v16;
  float v17;
  float v18;
  float v19;
  float v20;
  float v21;
  float v22;
  float v23;
  float v24;
  float v25;
  float v26;
  float v27;
  float v28;
  float v29;
  float v30;
  float v31;
  float v32;
  float v33;
  float v34;
  float v35;
  float v36;
  float v37;
  float v38;
  float v39;
  float v40;
  float v41;
  float v42;
  float v43;
  float v44;
  float v45;
  float v46;
  float v47;
  float *v48;

  v4 = *(_QWORD *)(a2 + 24);
  v5 = (float *)(v4 + 16 * *(int *)(a1 + 172));
  v7 = *v5;
  v6 = v5[1];
  v8 = v5[3];
  v9 = (float *)(v4 + 16 * *(int *)(a1 + 176));
  v11 = *v9;
  v10 = v9[1];
  v12 = v9[3];
  v13 = __sincosf_stret(v8);
  v14 = __sincosf_stret(v12);
  v15 = *(float *)(a1 + 144) - *(float *)(a1 + 212);
  v16 = *(float *)(a1 + 148) - *(float *)(a1 + 216);
  v17 = (float)(v13.__cosval * v15) - (float)(v13.__sinval * v16);
  v18 = (float)(v13.__cosval * v16) + (float)(v13.__sinval * v15);
  v19 = *(float *)(a1 + 152) - *(float *)(a1 + 220);
  v20 = *(float *)(a1 + 156) - *(float *)(a1 + 224);
  v21 = (float)(v14.__cosval * v19) - (float)(v14.__sinval * v20);
  v22 = (float)(v14.__cosval * v20) + (float)(v14.__sinval * v19);
  v23 = (float)(v7 + v17) - *(float *)(a1 + 128);
  v24 = (float)(v6 + v18) - *(float *)(a1 + 132);
  v25 = (float)(v11 + v21) - *(float *)(a1 + 136);
  v26 = (float)(v10 + v22) - *(float *)(a1 + 140);
  v27 = sqrtf((float)(v24 * v24) + (float)(v23 * v23));
  v28 = sqrtf((float)(v26 * v26) + (float)(v25 * v25));
  v29 = 0.0;
  v30 = 0.0;
  v31 = 0.0;
  if (v27 > 0.045)
  {
    v30 = v23 * (float)(1.0 / v27);
    v31 = v24 * (float)(1.0 / v27);
  }
  v32 = 0.0;
  if (v28 > 0.045)
  {
    v29 = v25 * (float)(1.0 / v28);
    v32 = v26 * (float)(1.0 / v28);
  }
  v33 = *(float *)(a1 + 236);
  v34 = *(float *)(a1 + 240);
  v35 = *(float *)(a1 + 228);
  v36 = *(float *)(a1 + 232);
  v37 = *(float *)(a1 + 164);
  v38 = (float)(v35
              + (float)((float)((float)((float)(v17 * v31) - (float)(v18 * v30)) * v33)
                      * (float)((float)(v17 * v31) - (float)(v18 * v30))))
      + (float)((float)(v37 * v37)
              * (float)(v36
                      + (float)((float)((float)((float)(v21 * v32) - (float)(v22 * v29)) * v34)
                              * (float)((float)(v21 * v32) - (float)(v22 * v29)))));
  if (v38 > 0.0)
    v38 = 1.0 / v38;
  v39 = *(float *)(a1 + 160) - v27;
  v40 = v39 - (float)(v37 * v28);
  v41 = -(float)(v39 + (float)((float)-v37 * v28));
  if (v40 > 0.0)
    v41 = v40;
  v42 = -(float)(v38 * v40);
  v43 = -(float)(v42 * v30);
  v44 = -(float)(v42 * v31);
  v45 = -(float)(v37 * v42);
  v46 = v29 * v45;
  v47 = v32 * v45;
  *v5 = v7 + (float)(v35 * v43);
  v5[1] = v6 + (float)(v35 * v44);
  v5[3] = v8 + (float)(v33 * (float)((float)(v17 * v44) - (float)(v18 * v43)));
  v48 = (float *)(*(_QWORD *)(a2 + 24) + 16 * *(int *)(a1 + 176));
  *v48 = v11 + (float)(v36 * v46);
  v48[1] = v10 + (float)(v36 * v47);
  v48[3] = v12 + (float)(v34 * (float)((float)(v21 * v47) - (float)(v22 * v46)));
  return v41 < 0.0045;
}

float b2PulleyJoint::GetAnchorA(b2PulleyJoint *this)
{
  return *(float *)(*((_QWORD *)this + 12) + 32)
       + (float)((float)(*(float *)(*((_QWORD *)this + 12) + 44) * *((float *)this + 36))
               - (float)(*(float *)(*((_QWORD *)this + 12) + 40) * *((float *)this + 37)));
}

float b2PulleyJoint::GetAnchorB(b2PulleyJoint *this)
{
  return *(float *)(*((_QWORD *)this + 13) + 32)
       + (float)((float)(*(float *)(*((_QWORD *)this + 13) + 44) * *((float *)this + 38))
               - (float)(*(float *)(*((_QWORD *)this + 13) + 40) * *((float *)this + 39)));
}

float b2PulleyJoint::GetReactionForce(b2PulleyJoint *this, float a2)
{
  return (float)(*((float *)this + 42) * *((float *)this + 47)) * a2;
}

float b2PulleyJoint::GetReactionTorque(b2PulleyJoint *this, float a2)
{
  return 0.0;
}

float b2PulleyJoint::GetGroundAnchorA(b2PulleyJoint *this)
{
  return *((float *)this + 32);
}

float b2PulleyJoint::GetGroundAnchorB(b2PulleyJoint *this)
{
  return *((float *)this + 34);
}

float b2PulleyJoint::GetLengthA(b2PulleyJoint *this)
{
  float *v1;
  float v2;
  float v3;
  float v4;
  float v5;
  float v6;
  float v7;

  v1 = (float *)*((_QWORD *)this + 12);
  v3 = v1[10];
  v2 = v1[11];
  v4 = *((float *)this + 36);
  v5 = *((float *)this + 37);
  v6 = v1[8] + (float)((float)(v2 * v4) - (float)(v3 * v5));
  v7 = (float)((float)(v2 * v5) + (float)(v3 * v4)) + v1[9];
  return sqrtf((float)((float)(v7 - *((float *)this + 33)) * (float)(v7 - *((float *)this + 33)))+ (float)((float)(v6 - *((float *)this + 32)) * (float)(v6 - *((float *)this + 32))));
}

float b2PulleyJoint::GetLengthB(b2PulleyJoint *this)
{
  float *v1;
  float v2;
  float v3;
  float v4;
  float v5;
  float v6;
  float v7;

  v1 = (float *)*((_QWORD *)this + 13);
  v3 = v1[10];
  v2 = v1[11];
  v4 = *((float *)this + 38);
  v5 = *((float *)this + 39);
  v6 = v1[8] + (float)((float)(v2 * v4) - (float)(v3 * v5));
  v7 = (float)((float)(v2 * v5) + (float)(v3 * v4)) + v1[9];
  return sqrtf((float)((float)(v7 - *((float *)this + 35)) * (float)(v7 - *((float *)this + 35)))+ (float)((float)(v6 - *((float *)this + 34)) * (float)(v6 - *((float *)this + 34))));
}

void b2PulleyJoint::~b2PulleyJoint(b2PulleyJoint *this)
{
  JUMPOUT(0x20BD0BA58);
}

float b2RevoluteJointDef::Initialize(b2RevoluteJointDef *this, b2Body *a2, b2Body *a3, const b2Vec2 *a4)
{
  float v6;
  float v7;
  float var1;
  float var0;
  float v10;
  float v11;
  float v12;
  float v13;
  float v14;
  float result;

  this->bodyA = a2;
  this->bodyB = a3;
  v6 = a4->x - a2->var8.var0.x;
  v7 = a4->y - a2->var8.var0.y;
  var0 = a2->var8.var1.var0;
  var1 = a2->var8.var1.var1;
  this->localAnchorA.x = (float)(v7 * var0) + (float)(var1 * v6);
  this->localAnchorA.y = (float)(var1 * v7) - (float)(var0 * v6);
  v10 = a4->x - a3->var8.var0.x;
  v11 = a4->y - a3->var8.var0.y;
  v13 = a3->var8.var1.var0;
  v12 = a3->var8.var1.var1;
  this->localAnchorB.x = (float)(v11 * v13) + (float)(v12 * v10);
  this->localAnchorB.y = (float)(v12 * v11) - (float)(v13 * v10);
  v14 = atan2f(a3->var8.var1.var0, a3->var8.var1.var1);
  result = v14 - atan2f(a2->var8.var1.var0, a2->var8.var1.var1);
  this->referenceAngle = result;
  return result;
}

void b2RevoluteJoint::b2RevoluteJoint(b2RevoluteJoint *this, const b2JointDef *a2)
{
  uint64_t v3;

  b2Joint::b2Joint((b2Joint *)this, a2);
  *(_QWORD *)v3 = off_24C0E8348;
  *(_QWORD *)(v3 + 128) = *(_QWORD *)(&a2->var4 + 4);
  *(_QWORD *)(v3 + 136) = *(_QWORD *)(&a2[1].var0 + 1);
  *(_DWORD *)(v3 + 176) = HIDWORD(a2[1].var1);
  *(_QWORD *)(v3 + 144) = 0;
  *(_QWORD *)(v3 + 152) = 0;
  *(_QWORD *)(v3 + 180) = *(b2Body **)((char *)&a2[1].var2 + 4);
  *(int32x2_t *)(v3 + 164) = vrev64_s32(*(int32x2_t *)&a2[1].var4);
  *(_BYTE *)(v3 + 172) = a2[1].var2;
  *(_BYTE *)(v3 + 160) = BYTE4(a2[1].var3);
  *(_DWORD *)(v3 + 284) = 0;
}

float normalizeAngle(float result)
{
  for (; result <= -3.1416; result = result + 6.2832)
    ;
  for (; result > 3.1416; result = result + -6.2832)
    ;
  return result;
}

void b2RevoluteJoint::InitVelocityConstraints(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  float v10;
  float v11;
  uint64_t v12;
  uint64_t v13;
  float v14;
  float32x2_t *v15;
  float32x2_t v16;
  float v17;
  float32x2_t *v18;
  float32x2_t v19;
  __float2 v20;
  __float2 v21;
  float v22;
  float v23;
  float v25;
  float v26;
  float v27;
  float v29;
  float v30;
  float v31;
  float v32;
  float v33;
  float v34;
  float v35;
  float i;
  float v37;
  float v38;
  float v39;
  float v40;
  float v41;
  float v42;
  float v43;
  float v44;
  uint64_t v52;
  int v53;
  float v54;
  float v55;
  float v56;
  float v57;

  v4 = *(_QWORD *)(a1 + 96);
  v5 = *(_QWORD *)(a1 + 104);
  v6 = *(int *)(v4 + 28);
  v7 = *(int *)(v5 + 28);
  *(_DWORD *)(a1 + 188) = v6;
  *(_DWORD *)(a1 + 192) = v7;
  v8 = *(_QWORD *)(v4 + 64);
  *(_QWORD *)(a1 + 212) = v8;
  v9 = *(_QWORD *)(v5 + 64);
  *(_QWORD *)(a1 + 220) = v9;
  v56 = *(float *)(v5 + 212);
  v57 = *(float *)(v4 + 212);
  *(float *)(a1 + 228) = v57;
  *(float *)(a1 + 232) = v56;
  v10 = *(float *)(v4 + 224);
  v11 = *(float *)(v5 + 224);
  *(float *)(a1 + 236) = v10;
  *(float *)(a1 + 240) = v11;
  v12 = *(_QWORD *)(a2 + 24);
  v13 = *(_QWORD *)(a2 + 32);
  v14 = *(float *)(v12 + 16 * v6 + 12);
  v15 = (float32x2_t *)(v13 + 16 * v6);
  v16 = *v15;
  v17 = *(float *)(v12 + 16 * v7 + 12);
  v18 = (float32x2_t *)(v13 + 16 * v7);
  v19 = *v18;
  v54 = v15[1].f32[1];
  v55 = v18[1].f32[1];
  v20 = __sincosf_stret(v14);
  v21 = __sincosf_stret(v17);
  v22 = *(float *)(a1 + 128) - *(float *)&v8;
  v23 = *(float *)(a1 + 132) - *((float *)&v8 + 1);
  _S2 = (float)(v20.__cosval * v22) - (float)(v20.__sinval * v23);
  v25 = (float)(v20.__cosval * v23) + (float)(v20.__sinval * v22);
  *(float *)(a1 + 196) = _S2;
  *(float *)(a1 + 200) = v25;
  v26 = *(float *)(a1 + 136) - *(float *)&v9;
  v27 = *(float *)(a1 + 140) - *((float *)&v9 + 1);
  _S3 = (float)(v21.__cosval * v26) - (float)(v21.__sinval * v27);
  v29 = (float)(v21.__cosval * v27) + (float)(v21.__sinval * v26);
  *(float *)(a1 + 204) = _S3;
  *(float *)(a1 + 208) = v29;
  v30 = (float)((float)(v57 + v56) + (float)((float)(v25 * v25) * v10)) + (float)((float)(v29 * v29) * v11);
  v31 = (float)(v11 * (float)-(float)(v29 * _S3)) + (float)((float)-(float)(v25 * _S2) * v10);
  v32 = v10 + v11;
  v33 = (float)-(float)(v29 * v11) - (float)(v25 * v10);
  *(float *)(a1 + 268) = v33;
  *(float *)(a1 + 244) = v30;
  *(float *)(a1 + 248) = v31;
  *(float *)(a1 + 260) = (float)((float)(v57 + v56) + (float)((float)(_S2 * _S2) * v10))
                       + (float)((float)(_S3 * _S3) * v11);
  v34 = (float)(v11 * _S3) + (float)(_S2 * v10);
  *(float *)(a1 + 272) = v34;
  *(float *)(a1 + 252) = v33;
  *(float *)(a1 + 256) = v31;
  *(float *)(a1 + 264) = v34;
  *(float *)(a1 + 276) = v10 + v11;
  v35 = 1.0 / (float)(v10 + v11);
  if ((float)(v10 + v11) <= 0.0)
    v35 = v10 + v11;
  *(float *)(a1 + 280) = v35;
  if (!*(_BYTE *)(a1 + 160) || v32 == 0.0)
    *(_DWORD *)(a1 + 156) = 0;
  if (!*(_BYTE *)(a1 + 172) || v32 == 0.0)
  {
    *(_DWORD *)(a1 + 284) = 0;
    goto LABEL_17;
  }
  for (i = (float)(v17 - v14) - *(float *)(a1 + 176); i <= -3.1416; i = i + 6.2832)
    ;
  for (; i > 3.1416; i = i + -6.2832)
    ;
  v38 = *(float *)(a1 + 180);
  v37 = *(float *)(a1 + 184);
  v39 = v37 - v38;
  if ((float)(v37 - v38) <= 0.0)
    v39 = -(float)(v37 - v38);
  if (v39 < 0.069813)
  {
    *(_DWORD *)(a1 + 284) = 3;
LABEL_17:
    v41 = v54;
    v40 = v55;
    goto LABEL_18;
  }
  if (i <= v38)
  {
    v41 = v54;
    v40 = v55;
    if (*(_DWORD *)(a1 + 284) != 1)
      *(_DWORD *)(a1 + 152) = 0;
    v53 = 1;
  }
  else
  {
    _NF = i < v37;
    v41 = v54;
    v40 = v55;
    if (_NF)
    {
      *(_DWORD *)(a1 + 284) = 0;
      *(_DWORD *)(a1 + 152) = 0;
      goto LABEL_18;
    }
    if (*(_DWORD *)(a1 + 284) != 2)
      *(_DWORD *)(a1 + 152) = 0;
    v53 = 2;
  }
  *(_DWORD *)(a1 + 284) = v53;
LABEL_18:
  if (*(_BYTE *)(a2 + 20))
  {
    v42 = *(float *)(a2 + 8);
    v43 = v42 * *(float *)(a1 + 152);
    v44 = v42 * *(float *)(a1 + 156);
    *(float *)(a1 + 152) = v43;
    *(float *)(a1 + 156) = v44;
    _D1 = vmul_n_f32(*(float32x2_t *)(a1 + 144), v42);
    *(float32x2_t *)(a1 + 144) = _D1;
    v16 = vsub_f32(v16, vmul_n_f32(_D1, v57));
    __asm { FMLA            S4, S2, V1.S[1] }
    v41 = v41 - (float)(v10 * (float)(v43 + (float)(v44 + _S4)));
    v19 = vadd_f32(v19, vmul_n_f32(_D1, v56));
    __asm { FMLA            S0, S3, V1.S[1] }
    v40 = v40 + (float)(v11 * (float)(v43 + (float)(v44 + _S0)));
  }
  else
  {
    *(_QWORD *)(a1 + 144) = 0;
    *(_QWORD *)(a1 + 152) = 0;
  }
  *v15 = v16;
  v15[1].f32[1] = v41;
  v52 = *(_QWORD *)(a2 + 32) + 16 * *(int *)(a1 + 192);
  *(float32x2_t *)v52 = v19;
  *(float *)(v52 + 12) = v40;
}

float b2RevoluteJoint::SolveVelocityConstraints(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  float *v5;
  float v6;
  float v7;
  float v8;
  float *v9;
  float v10;
  float v11;
  float v12;
  float v13;
  float v14;
  float v15;
  float v16;
  float v17;
  float v18;
  float v19;
  float v20;
  float v21;
  float v22;
  float v23;
  float v24;
  float v25;
  float v26;
  float v27;
  float v28;
  float v29;
  int v30;
  float v31;
  float v32;
  float v33;
  float v34;
  float v35;
  float v36;
  float v37;
  float v38;
  float v39;
  float v40;
  float v41;
  float v42;
  float v43;
  float v44;
  float v45;
  float v46;
  float result;
  float *v48;
  float *v49;
  float v50;
  float v51;
  float v52;
  float v53;
  float v54;
  b2Vec2 v55;
  b2Vec3 v56;

  v4 = *(_QWORD *)(a2 + 32);
  v5 = (float *)(v4 + 16 * *(int *)(a1 + 188));
  v7 = *v5;
  v6 = v5[1];
  v8 = v5[3];
  v9 = (float *)(v4 + 16 * *(int *)(a1 + 192));
  v11 = *v9;
  v10 = v9[1];
  v12 = v9[3];
  v14 = *(float *)(a1 + 236);
  v13 = *(float *)(a1 + 240);
  v15 = v14 + v13;
  if (*(_BYTE *)(a1 + 160) && *(_DWORD *)(a1 + 284) != 3 && v15 != 0.0)
  {
    v16 = *(float *)(a1 + 156);
    v17 = *(float *)a2 * *(float *)(a1 + 164);
    v18 = v16 - (float)(*(float *)(a1 + 280) * (float)((float)(v12 - v8) - *(float *)(a1 + 168)));
    if (v18 >= v17)
      v18 = *(float *)a2 * *(float *)(a1 + 164);
    if (v18 < (float)-v17)
      v18 = -v17;
    *(float *)(a1 + 156) = v18;
    v19 = v18 - v16;
    v8 = v8 - (float)(v14 * v19);
    v12 = v12 + (float)(v13 * v19);
  }
  v20 = *(float *)(a1 + 232);
  v54 = *(float *)(a1 + 228);
  if (*(_BYTE *)(a1 + 172) && *(_DWORD *)(a1 + 284) && v15 != 0.0)
  {
    v51 = v7;
    v52 = v11;
    v50 = v10;
    v21 = (float)((float)(v11 - (float)(v12 * *(float *)(a1 + 208))) - v7) + (float)(v8 * *(float *)(a1 + 200));
    v22 = (float)((float)(v10 + (float)(v12 * *(float *)(a1 + 204))) - v6) - (float)(v8 * *(float *)(a1 + 196));
    v56.var0 = v21;
    v56.var1 = v22;
    v56.var2 = v12 - v8;
    v24 = b2Mat33::Solve33((b2Mat33 *)(a1 + 244), &v56);
    v26 = v25;
    v27 = -v24;
    v28 = -v25;
    v29 = -v23;
    v30 = *(_DWORD *)(a1 + 284);
    if (v30 == 1)
    {
      v42 = *(float *)(a1 + 152);
      v32 = v42 - v23;
      if (v32 >= 0.0)
        goto LABEL_20;
    }
    else
    {
      if (v30 != 2)
      {
        if (v30 == 3)
        {
          v31 = *(float *)(a1 + 148);
          *(float *)(a1 + 144) = *(float *)(a1 + 144) - v24;
          *(float *)(a1 + 148) = v31 - v26;
          v32 = *(float *)(a1 + 152) - v23;
LABEL_21:
          *(float *)(a1 + 152) = v32;
        }
LABEL_22:
        v7 = v51;
        v11 = v52;
        v37 = v50;
        v41 = v54;
        v39 = v8
            - (float)(v14
                    * (float)(v29 + (float)((float)(*(float *)(a1 + 196) * v28) - (float)(*(float *)(a1 + 200) * v27))));
        v40 = v12
            + (float)(v13
                    * (float)(v29 + (float)((float)(*(float *)(a1 + 204) * v28) - (float)(*(float *)(a1 + 208) * v27))));
        goto LABEL_23;
      }
      v42 = *(float *)(a1 + 152);
      v32 = v42 - v23;
      if (v32 <= 0.0)
      {
LABEL_20:
        v45 = *(float *)(a1 + 148) - v26;
        *(float *)(a1 + 144) = *(float *)(a1 + 144) - v24;
        *(float *)(a1 + 148) = v45;
        goto LABEL_21;
      }
    }
    v43 = (float)(v42 * *(float *)(a1 + 272)) - v22;
    v55.x = (float)(v42 * *(float *)(a1 + 268)) - v21;
    v55.y = v43;
    v27 = b2Mat33::Solve22((b2Mat33 *)(a1 + 244), &v55);
    v29 = -*(float *)(a1 + 152);
    v44 = v28 + *(float *)(a1 + 148);
    *(float *)(a1 + 144) = v27 + *(float *)(a1 + 144);
    *(float *)(a1 + 148) = v44;
    *(_DWORD *)(a1 + 152) = 0;
    goto LABEL_22;
  }
  v33 = -(float)((float)((float)(v10 + (float)(v12 * *(float *)(a1 + 204))) - v6) - (float)(v8 * *(float *)(a1 + 196)));
  v56.var0 = -(float)((float)((float)(v11 - (float)(v12 * *(float *)(a1 + 208))) - v7)
                    + (float)(v8 * *(float *)(a1 + 200)));
  v56.var1 = v33;
  v53 = v20;
  v34 = v13;
  v35 = v6;
  v36 = v10;
  v27 = b2Mat33::Solve22((b2Mat33 *)(a1 + 244), (const b2Vec2 *)&v56);
  v37 = v36;
  v6 = v35;
  v38 = v28 + *(float *)(a1 + 148);
  *(float *)(a1 + 144) = v27 + *(float *)(a1 + 144);
  *(float *)(a1 + 148) = v38;
  v39 = v8 - (float)(v14 * (float)((float)(*(float *)(a1 + 196) * v28) - (float)(*(float *)(a1 + 200) * v27)));
  v40 = v12 + (float)(v34 * (float)((float)(*(float *)(a1 + 204) * v28) - (float)(*(float *)(a1 + 208) * v27)));
  v20 = v53;
  v41 = v54;
LABEL_23:
  v46 = v7 - (float)(v41 * v27);
  result = v11 + (float)(v20 * v27);
  v48 = (float *)(*(_QWORD *)(a2 + 32) + 16 * *(int *)(a1 + 188));
  *v48 = v46;
  v48[1] = v6 - (float)(v41 * v28);
  v48[3] = v39;
  v49 = (float *)(*(_QWORD *)(a2 + 32) + 16 * *(int *)(a1 + 192));
  *v49 = result;
  v49[1] = v37 + (float)(v20 * v28);
  v49[3] = v40;
  return result;
}

BOOL b2RevoluteJoint::SolvePositionConstraints(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  float *v5;
  float v6;
  float v7;
  float *v8;
  float v9;
  float v10;
  float v11;
  float v12;
  int v13;
  float i;
  float v15;
  float v16;
  float v17;
  float v18;
  float v19;
  BOOL v20;
  __float2 v21;
  __float2 v22;
  float v23;
  float v24;
  float v25;
  float v26;
  float v27;
  float v28;
  float v29;
  float v30;
  float v31;
  float v32;
  float v33;
  float v34;
  float v35;
  float v36;
  float v37;
  float v38;
  float v39;
  float v40;
  float v41;
  float v42;
  float v43;
  float *v44;
  float v46;
  float v47;
  float v48;

  v4 = *(_QWORD *)(a2 + 24);
  v5 = (float *)(v4 + 16 * *(int *)(a1 + 188));
  v6 = *v5;
  v7 = v5[3];
  v8 = (float *)(v4 + 16 * *(int *)(a1 + 192));
  v46 = v5[1];
  v47 = *v8;
  v48 = v8[1];
  v9 = v8[3];
  v11 = *(float *)(a1 + 236);
  v10 = *(float *)(a1 + 240);
  v12 = 0.0;
  if (*(_BYTE *)(a1 + 172))
  {
    v13 = *(_DWORD *)(a1 + 284);
    if (v13)
    {
      if ((float)(v11 + v10) != 0.0)
      {
        for (i = (float)(v9 - v7) - *(float *)(a1 + 176); i <= -3.1416; i = i + 6.2832)
          ;
        for (; i > 3.1416; i = i + -6.2832)
          ;
        if (v13 == 1)
        {
          v17 = i - *(float *)(a1 + 180);
          v12 = -v17;
          v18 = fminf(v17 + 0.034907, 0.0);
          v19 = -0.13963;
          v20 = v18 < -0.13963;
        }
        else
        {
          if (v13 != 2)
          {
            v15 = 0.0;
            v12 = 0.0;
            if (v13 == 3)
            {
              v16 = fminf(i - *(float *)(a1 + 180), 0.13963);
              if (v16 < -0.13963)
                v16 = -0.13963;
              v15 = -(float)(*(float *)(a1 + 280) * v16);
              if (v16 <= 0.0)
                v12 = -v16;
              else
                v12 = v16;
            }
LABEL_21:
            v7 = v7 - (float)(v11 * v15);
            v9 = v9 + (float)(v10 * v15);
            goto LABEL_22;
          }
          v12 = i - *(float *)(a1 + 184);
          v18 = fminf(v12 + -0.034907, 0.13963);
          v20 = v18 < 0.0;
          v19 = 0.0;
        }
        if (v20)
          v18 = v19;
        v15 = -(float)(*(float *)(a1 + 280) * v18);
        goto LABEL_21;
      }
    }
  }
LABEL_22:
  v21 = __sincosf_stret(v7);
  v22 = __sincosf_stret(v9);
  v23 = *(float *)(a1 + 128) - *(float *)(a1 + 212);
  v24 = *(float *)(a1 + 132) - *(float *)(a1 + 216);
  v25 = (float)(v21.__cosval * v23) - (float)(v21.__sinval * v24);
  v26 = (float)(v21.__cosval * v24) + (float)(v21.__sinval * v23);
  v27 = *(float *)(a1 + 136) - *(float *)(a1 + 220);
  v28 = *(float *)(a1 + 140) - *(float *)(a1 + 224);
  v29 = (float)(v22.__cosval * v27) - (float)(v22.__sinval * v28);
  v30 = (float)(v22.__cosval * v28) + (float)(v22.__sinval * v27);
  v31 = (float)((float)(v47 + v29) - v6) - v25;
  v32 = (float)((float)(v48 + v30) - v46) - v26;
  v33 = sqrtf((float)(v32 * v32) + (float)(v31 * v31));
  v34 = *(float *)(a1 + 228);
  v35 = *(float *)(a1 + 232);
  v36 = (float)((float)(v34 + v35) + (float)((float)(v11 * v26) * v26)) + (float)((float)(v10 * v30) * v30);
  v37 = (float)(v30 * (float)-(float)(v10 * v29)) + (float)((float)-(float)(v11 * v25) * v26);
  v38 = (float)((float)(v34 + v35) + (float)((float)(v11 * v25) * v25)) + (float)((float)(v10 * v29) * v29);
  v39 = (float)(v36 * v38) - (float)(v37 * v37);
  if (v39 != 0.0)
    v39 = 1.0 / v39;
  v40 = (float)(v38 * v31) - (float)(v37 * v32);
  v41 = (float)(v36 * v32) - (float)(v37 * v31);
  v42 = -(float)(v39 * v40);
  v43 = -(float)(v39 * v41);
  *v5 = v6 - (float)(v34 * v42);
  v5[1] = v46 - (float)(v34 * v43);
  v5[3] = v7 - (float)(v11 * (float)((float)(v25 * v43) - (float)(v26 * v42)));
  v44 = (float *)(*(_QWORD *)(a2 + 24) + 16 * *(int *)(a1 + 192));
  *v44 = v47 + (float)(v35 * v42);
  v44[1] = v48 + (float)(v35 * v43);
  v44[3] = v9 + (float)(v10 * (float)((float)(v29 * v43) - (float)(v30 * v42)));
  return v12 <= 0.034907 && v33 <= 0.0045;
}

float b2RevoluteJoint::GetAnchorA(b2RevoluteJoint *this)
{
  return this->var6->var8.var0.x
       + (float)((float)(this->var6->var8.var1.var1 * this->var11.x)
               - (float)(this->var6->var8.var1.var0 * this->var11.y));
}

float b2RevoluteJoint::GetAnchorB(b2RevoluteJoint *this)
{
  return this->var7->var8.var0.x
       + (float)((float)(this->var7->var8.var1.var1 * this->var12.x)
               - (float)(this->var7->var8.var1.var0 * this->var12.y));
}

float b2RevoluteJoint::GetReactionForce(b2RevoluteJoint *this, float a2)
{
  return this->var13.var0 * a2;
}

float b2RevoluteJoint::GetReactionTorque(b2RevoluteJoint *this, float a2)
{
  return this->var13.var2 * a2;
}

float b2RevoluteJoint::GetJointAngle(b2RevoluteJoint *this)
{
  return (float)(this->var7->var11.x - this->var6->var11.x) - this->var19;
}

float b2RevoluteJoint::GetJointSpeed(b2RevoluteJoint *this)
{
  return *(float *)&this->var7->var15 - *(float *)&this->var6->var15;
}

BOOL b2RevoluteJoint::IsMotorEnabled(b2RevoluteJoint *this)
{
  return this->var15;
}

b2Body *b2RevoluteJoint::EnableMotor(b2RevoluteJoint *this, BOOL a2)
{
  b2Body *result;

  b2Body::SetAwake(this->var6, 1);
  result = b2Body::SetAwake(this->var7, 1);
  this->var15 = a2;
  return result;
}

float b2RevoluteJoint::GetMotorTorque(b2RevoluteJoint *this, float a2)
{
  return this->var14 * a2;
}

b2Body *b2RevoluteJoint::SetMotorSpeed(b2RevoluteJoint *this, float a2)
{
  b2Body *result;

  b2Body::SetAwake(this->var6, 1);
  result = b2Body::SetAwake(this->var7, 1);
  this->var17 = a2;
  return result;
}

b2Body *b2RevoluteJoint::SetMaxMotorTorque(b2RevoluteJoint *this, float a2)
{
  b2Body *result;

  b2Body::SetAwake(this->var6, 1);
  result = b2Body::SetAwake(this->var7, 1);
  this->var16 = a2;
  return result;
}

BOOL b2RevoluteJoint::IsLimitEnabled(b2RevoluteJoint *this)
{
  return this->var18;
}

b2RevoluteJoint *b2RevoluteJoint::EnableLimit(b2RevoluteJoint *this, _BOOL4 a2)
{
  BOOL v2;
  b2RevoluteJoint *v3;

  if (this->var18 != a2)
  {
    v2 = a2;
    v3 = this;
    b2Body::SetAwake(this->var6, 1);
    this = (b2RevoluteJoint *)b2Body::SetAwake(v3->var7, 1);
    v3->var18 = v2;
    v3->var13.var2 = 0.0;
  }
  return this;
}

b2RevoluteJoint *b2RevoluteJoint::SetLimits(b2RevoluteJoint *this, float a2, float a3)
{
  b2RevoluteJoint *v5;

  if (a2 > a3)
    b2RevoluteJoint::SetLimits();
  v5 = this;
  if (this->var20 != a2 || this->var21 != a3)
  {
    b2Body::SetAwake(this->var6, 1);
    this = (b2RevoluteJoint *)b2Body::SetAwake(v5->var7, 1);
    v5->var13.var2 = 0.0;
    v5->var20 = a2;
    v5->var21 = a3;
  }
  return this;
}

void b2RevoluteJoint::~b2RevoluteJoint(b2RevoluteJoint *this)
{
  JUMPOUT(0x20BD0BA58);
}

uint64_t Worley(float64x2_t *a1, uint64_t a2, double *__b, uint64_t a4, uint64_t a5)
{
  double *v7;
  uint64_t v8;
  uint64_t v10;
  float64x2_t v11;
  unint64_t v12;
  uint64_t v13;
  double v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t result;
  double v18;
  double v19;
  double v20;
  double v21;
  double v22;
  double v23;
  double v24;
  double v25;
  double v26;
  double v27;
  double v28;
  double v29;
  double v30;
  double v31;
  double v32;
  double v33;
  double *v34;
  float64x2_t v35;
  double v36;
  double v37;
  float64x2_t v38;
  double v39;
  uint64_t v40;

  v7 = __b;
  v8 = a2;
  v40 = *MEMORY[0x24BDAC8D0];
  v10 = a2 - 1;
  if (a2 >= 1)
    memset_pattern16(__b, &unk_208FD7420, 8 * a2);
  v11 = vmulq_f64(*a1, (float64x2_t)vdupq_n_s64(0x3FD97B4A2339C0ECuLL));
  v36 = v11.f64[0];
  v38 = v11;
  v39 = a1[1].f64[0] * 0.39815;
  *(double *)&v12 = v39;
  v13 = (__PAIR128__((uint64_t)v11.f64[0], *(unint64_t *)&v11.f64[0]) - COERCE_UNSIGNED_INT64(0.0)) >> 64;
  v14 = v11.f64[1];
  v15 = (__PAIR128__((uint64_t)v11.f64[1], *(unint64_t *)&v11.f64[1]) - COERCE_UNSIGNED_INT64(0.0)) >> 64;
  v16 = (__PAIR128__((uint64_t)*(double *)&v12, v12) - COERCE_UNSIGNED_INT64(0.0)) >> 64;
  result = AddSamples(v13, v15, v16, v8, &v38, (uint64_t)v7, a4, a5);
  v18 = v36 - (double)v13;
  v19 = v14 - (double)v15;
  v20 = *(double *)&v12 - (double)v16;
  v21 = v18 * v18;
  v22 = v19 * v19;
  v23 = v7[v10];
  if (v18 * v18 < v23)
  {
    result = AddSamples(v13 - 1, v15, v16, v8, &v38, (uint64_t)v7, a4, a5);
    v23 = v7[v10];
  }
  v24 = 1.0 - v18;
  v25 = v20 * v20;
  if (v22 < v23)
  {
    result = AddSamples(v13, v15 - 1, v16, v8, &v38, (uint64_t)v7, a4, a5);
    v23 = v7[v10];
  }
  v26 = 1.0 - v19;
  v27 = v24 * v24;
  if (v25 < v23)
  {
    result = AddSamples(v13, v15, v16 - 1, v8, &v38, (uint64_t)v7, a4, a5);
    v23 = v7[v10];
  }
  v28 = 1.0 - v20;
  v29 = v26 * v26;
  if (v27 < v23)
  {
    result = AddSamples(v13 + 1, v15, v16, v8, &v38, (uint64_t)v7, a4, a5);
    v23 = v7[v10];
  }
  v30 = v28 * v28;
  if (v29 < v23)
  {
    result = AddSamples(v13, v15 + 1, v16, v8, &v38, (uint64_t)v7, a4, a5);
    v23 = v7[v10];
  }
  if (v30 < v23)
  {
    result = AddSamples(v13, v15, v16 + 1, v8, &v38, (uint64_t)v7, a4, a5);
    v23 = v7[v10];
  }
  v31 = v21 + v22;
  if (v21 + v22 < v23)
  {
    result = AddSamples(v13 - 1, v15 - 1, v16, v8, &v38, (uint64_t)v7, a4, a5);
    v23 = v7[v10];
  }
  if (v21 + v25 < v23)
  {
    result = AddSamples(v13 - 1, v15, v16 - 1, v8, &v38, (uint64_t)v7, a4, a5);
    v23 = v7[v10];
  }
  if (v22 + v25 < v23)
  {
    result = AddSamples(v13, v15 - 1, v16 - 1, v8, &v38, (uint64_t)v7, a4, a5);
    v23 = v7[v10];
  }
  v37 = v27 + v29;
  if (v27 + v29 < v23)
  {
    result = AddSamples(v13 + 1, v15 + 1, v16, v8, &v38, (uint64_t)v7, a4, a5);
    v23 = v7[v10];
  }
  if (v27 + v30 < v23)
  {
    result = AddSamples(v13 + 1, v15, v16 + 1, v8, &v38, (uint64_t)v7, a4, a5);
    v23 = v7[v10];
  }
  if (v29 + v30 < v23)
  {
    result = AddSamples(v13, v15 + 1, v16 + 1, v8, &v38, (uint64_t)v7, a4, a5);
    v23 = v7[v10];
  }
  v32 = v21 + v29;
  if (v21 + v29 < v23)
  {
    result = AddSamples(v13 - 1, v15 + 1, v16, v8, &v38, (uint64_t)v7, a4, a5);
    v23 = v7[v10];
  }
  if (v21 + v30 < v23)
  {
    result = AddSamples(v13 - 1, v15, v16 + 1, v8, &v38, (uint64_t)v7, a4, a5);
    v23 = v7[v10];
  }
  if (v22 + v30 < v23)
  {
    result = AddSamples(v13, v15 - 1, v16 + 1, v8, &v38, (uint64_t)v7, a4, a5);
    v23 = v7[v10];
  }
  v33 = v27 + v22;
  if (v33 < v23)
  {
    result = AddSamples(v13 + 1, v15 - 1, v16, v8, &v38, (uint64_t)v7, a4, a5);
    v23 = v7[v10];
  }
  if (v27 + v25 < v23)
  {
    result = AddSamples(v13 + 1, v15, v16 - 1, v8, &v38, (uint64_t)v7, a4, a5);
    v23 = v7[v10];
  }
  if (v29 + v25 < v23)
  {
    result = AddSamples(v13, v15 + 1, v16 - 1, v8, &v38, (uint64_t)v7, a4, a5);
    v23 = v7[v10];
  }
  if (v31 + v25 < v23)
  {
    result = AddSamples(v13 - 1, v15 - 1, v16 - 1, v8, &v38, (uint64_t)v7, a4, a5);
    v23 = v7[v10];
  }
  if (v31 + v30 < v23)
  {
    result = AddSamples(v13 - 1, v15 - 1, v16 + 1, v8, &v38, (uint64_t)v7, a4, a5);
    v23 = v7[v10];
  }
  if (v32 + v25 < v23)
  {
    result = AddSamples(v13 - 1, v15 + 1, v16 - 1, v8, &v38, (uint64_t)v7, a4, a5);
    v23 = v7[v10];
  }
  if (v32 + v30 < v23)
  {
    result = AddSamples(v13 - 1, v15 + 1, v16 + 1, v8, &v38, (uint64_t)v7, a4, a5);
    v23 = v7[v10];
  }
  if (v33 + v25 < v23)
  {
    result = AddSamples(v13 + 1, v15 - 1, v16 - 1, v8, &v38, (uint64_t)v7, a4, a5);
    v23 = v7[v10];
  }
  if (v33 + v30 < v23)
  {
    result = AddSamples(v13 + 1, v15 - 1, v16 + 1, v8, &v38, (uint64_t)v7, a4, a5);
    v23 = v7[v10];
  }
  if (v37 + v25 < v23)
  {
    result = AddSamples(v13 + 1, v15 + 1, v16 - 1, v8, &v38, (uint64_t)v7, a4, a5);
    v23 = v7[v10];
  }
  if (v37 + v30 < v23)
    result = AddSamples(v13 + 1, v15 + 1, v16 + 1, v8, &v38, (uint64_t)v7, a4, a5);
  if (v8 >= 1)
  {
    v34 = (double *)(a4 + 16);
    v35 = (float64x2_t)vdupq_n_s64(0x400417CA3F5539E6uLL);
    do
    {
      *v7 = sqrt(*v7) * 2.51161623;
      ++v7;
      *((float64x2_t *)v34 - 1) = vmulq_f64(*(float64x2_t *)(v34 - 2), v35);
      *v34 = *v34 * 2.51161623;
      v34 += 3;
      --v8;
    }
    while (v8);
  }
  return result;
}

uint64_t AddSamples(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, float64x2_t *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int64x2_t v11;
  float64x2_t v12;
  double v13;
  uint64_t v14;
  _QWORD *v15;
  _QWORD *v16;
  float64x2_t v22;
  uint64_t v23;
  uint64x2_t v24;
  float64x2_t v25;
  double v26;
  double v27;
  uint64_t v28;
  uint64_t v29;
  double v30;
  uint64_t v31;
  _QWORD *v32;
  _QWORD *v33;
  uint64_t v34;
  uint64_t v35;
  _QWORD *v36;
  _QWORD *v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  __int128 v42;
  float64x2_t *v43;

  v8 = 702395077 * result + 915488749 * a2 + 2120969693 * a3;
  v9 = *(int *)((char *)&Poisson_count + ((v8 >> 22) & 0x3FFFFFFFFFCLL));
  if ((int)v9 >= 1)
  {
    v10 = 0;
    v11.i64[0] = result;
    v11.i64[1] = a2;
    v12 = vcvtq_f64_s64(v11);
    v13 = (double)a3;
    result = a7 + 24 * a4 - 24;
    v14 = 8 * a4 - 8;
    v15 = (_QWORD *)(a6 + v14);
    v16 = (_QWORD *)(a8 + v14);
    __asm { FMOV            V2.2D, #0.5 }
    v22 = (float64x2_t)vdupq_n_s64(0x3DF0000000000000uLL);
    do
    {
      v23 = 1402024253 * v8 + 586950981;
      v24.i64[0] = 1402024253 * v23 + 586950981;
      v24.i64[1] = 1402024253 * v24.i64[0] + 586950981;
      v8 = 1402024253 * v24.i64[1] + 586950981;
      v25 = vsubq_f64(vaddq_f64(vmulq_f64(vaddq_f64(vcvtq_f64_u64(v24), _Q2), v22), v12), *a5);
      v26 = ((double)v8 + 0.5) * 2.32830644e-10 + v13 - a5[1].f64[0];
      v27 = vmlad_n_f64(COERCE_DOUBLE(*(_QWORD *)&vmulq_f64(v25, v25).f64[1]), v25.f64[0], v25.f64[0]) + v26 * v26;
      if (v27 < *(double *)(a6 + 8 * (a4 - 1)))
      {
        v28 = a4;
        while (1)
        {
          v29 = v28 - 1;
          if (v28 < 1)
            break;
          v30 = *(double *)(a6 - 8 + 8 * v28--);
          if (v27 >= v30)
          {
            v31 = v29 + 1;
            goto LABEL_9;
          }
        }
        v31 = a4 & (a4 >> 63);
LABEL_9:
        if (a4 - 2 >= v31)
        {
          v32 = v16;
          v33 = v15;
          v34 = a7 + 24 * a4 - 24;
          v35 = a4 - 1;
          v36 = v15;
          v37 = v16;
          v38 = v34;
          do
          {
            v39 = *--v36;
            v40 = v39;
            v41 = *--v37;
            *v33 = v40;
            *v32 = v41;
            v42 = *(_OWORD *)(v38 - 24);
            v38 -= 24;
            *(_OWORD *)v34 = v42;
            --v35;
            *(_QWORD *)(v34 + 16) = *(_QWORD *)(v34 - 8);
            v32 = v37;
            v33 = v36;
            v34 = v38;
          }
          while (v35 > v31);
        }
        *(double *)(a6 + 8 * v31) = v27;
        *(_QWORD *)(a8 + 8 * v31) = v23;
        v43 = (float64x2_t *)(a7 + 24 * v31);
        *v43 = v25;
        v43[1].f64[0] = v26;
      }
      ++v10;
    }
    while (v10 != v9);
  }
  return result;
}

void b2RopeJoint::b2RopeJoint(b2RopeJoint *this, const b2JointDef *a2)
{
  uint64_t v3;

  b2Joint::b2Joint((b2Joint *)this, a2);
  *(_QWORD *)v3 = off_24C0E7D78;
  *(_QWORD *)(v3 + 128) = *(_QWORD *)(&a2->var4 + 4);
  *(_QWORD *)(v3 + 136) = *(_QWORD *)(&a2[1].var0 + 1);
  *(_DWORD *)(v3 + 144) = HIDWORD(a2[1].var1);
  *(_QWORD *)(v3 + 220) = 0;
  *(_DWORD *)(v3 + 148) = 0;
  *(_DWORD *)(v3 + 152) = 0;
}

void b2RopeJoint::InitVelocityConstraints(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  float v10;
  float v11;
  float v12;
  uint64_t v13;
  uint64_t v14;
  float *v15;
  float v16;
  float v17;
  float *v18;
  float *v19;
  float v20;
  float v21;
  float v22;
  float *v23;
  __float2 v24;
  __float2 v25;
  float v26;
  float v27;
  float v28;
  float v29;
  float v30;
  float v31;
  float v32;
  float v33;
  float v34;
  float v35;
  float v36;
  float v37;
  float v38;
  float v39;
  float v40;
  float v41;
  BOOL v42;
  float v43;
  float v44;
  float v45;
  float v46;
  float v47;
  float v48;
  float v49;
  float v50;
  float v51;
  float v52;
  float *v53;
  float v54;
  float v55;
  float v56;
  float v57;
  float v58;
  float v59;
  float v60;
  float v61;
  float v62;

  v4 = *(_QWORD *)(a1 + 96);
  v5 = *(_QWORD *)(a1 + 104);
  v6 = *(int *)(v4 + 28);
  v7 = *(int *)(v5 + 28);
  *(_DWORD *)(a1 + 156) = v6;
  *(_DWORD *)(a1 + 160) = v7;
  v8 = *(_QWORD *)(v4 + 64);
  *(_QWORD *)(a1 + 188) = v8;
  v9 = *(_QWORD *)(v5 + 64);
  *(_QWORD *)(a1 + 196) = v9;
  v10 = *(float *)(v4 + 212);
  v11 = *(float *)(v5 + 212);
  *(float *)(a1 + 204) = v10;
  *(float *)(a1 + 208) = v11;
  v55 = v11;
  v12 = *(float *)(v5 + 224);
  v54 = *(float *)(v4 + 224);
  *(float *)(a1 + 212) = v54;
  *(float *)(a1 + 216) = v12;
  v56 = v12;
  v13 = *(_QWORD *)(a2 + 24);
  v14 = *(_QWORD *)(a2 + 32);
  v15 = (float *)(v13 + 16 * v6);
  v17 = *v15;
  v16 = v15[1];
  v18 = (float *)(v14 + 16 * v6);
  v62 = v18[1];
  v60 = *v18;
  v61 = v18[3];
  v19 = (float *)(v13 + 16 * v7);
  v20 = *v19;
  v21 = v19[1];
  v22 = v19[3];
  v23 = (float *)(v14 + 16 * v7);
  v58 = v23[1];
  v59 = *v23;
  v57 = v23[3];
  v24 = __sincosf_stret(v15[3]);
  v25 = __sincosf_stret(v22);
  v26 = *(float *)(a1 + 128) - *(float *)&v8;
  v27 = *(float *)(a1 + 132) - *((float *)&v8 + 1);
  v28 = (float)(v24.__cosval * v26) - (float)(v24.__sinval * v27);
  v29 = (float)(v24.__cosval * v27) + (float)(v24.__sinval * v26);
  *(float *)(a1 + 172) = v28;
  *(float *)(a1 + 176) = v29;
  v30 = *(float *)(a1 + 136) - *(float *)&v9;
  v31 = *(float *)(a1 + 140) - *((float *)&v9 + 1);
  v32 = (float)(v25.__cosval * v30) - (float)(v25.__sinval * v31);
  v33 = (float)(v25.__cosval * v31) + (float)(v25.__sinval * v30);
  *(float *)(a1 + 180) = v32;
  *(float *)(a1 + 184) = v33;
  v34 = (float)((float)(v20 + v32) - v17) - v28;
  v35 = (float)((float)(v21 + v33) - v16) - v29;
  v36 = sqrtf((float)(v35 * v35) + (float)(v34 * v34));
  *(float *)(a1 + 148) = v36;
  *(_DWORD *)(a1 + 224) = 2 * ((float)(v36 - *(float *)(a1 + 144)) > 0.0);
  if (v36 <= 0.0045)
  {
    *(_DWORD *)(a1 + 164) = 0;
    *(_DWORD *)(a1 + 168) = 0;
    *(_DWORD *)(a1 + 220) = 0;
    *(_DWORD *)(a1 + 152) = 0;
  }
  else
  {
    v37 = 1.0 / v36;
    v38 = v34 * v37;
    v39 = v35 * v37;
    *(float *)(a1 + 164) = v38;
    *(float *)(a1 + 168) = v39;
    v40 = (float)(v55
                + (float)(v10
                        + (float)((float)(v54 * (float)((float)(v28 * v39) - (float)(v29 * v38)))
                                * (float)((float)(v28 * v39) - (float)(v29 * v38)))))
        + (float)((float)(v56 * (float)((float)(v32 * v39) - (float)(v33 * v38)))
                * (float)((float)(v32 * v39) - (float)(v33 * v38)));
    v41 = 1.0 / v40;
    v42 = v40 == 0.0;
    v43 = 0.0;
    if (!v42)
      v43 = v41;
    *(float *)(a1 + 220) = v43;
    if (*(_BYTE *)(a2 + 20))
    {
      v44 = *(float *)(a2 + 8) * *(float *)(a1 + 152);
      *(float *)(a1 + 152) = v44;
      v45 = v38 * v44;
      v46 = v39 * v44;
      v47 = v60 - (float)(v10 * v45);
      v48 = v62 - (float)(v10 * v46);
      v49 = v61 - (float)(v54 * (float)((float)(v45 * (float)-v29) + (float)(v28 * v46)));
      v50 = v59 + (float)(v55 * v45);
      v51 = v58 + (float)(v55 * v46);
      v52 = v57 + (float)(v56 * (float)((float)(v45 * (float)-v33) + (float)(v32 * v46)));
    }
    else
    {
      *(_DWORD *)(a1 + 152) = 0;
      v49 = v61;
      v48 = v62;
      v50 = v59;
      v47 = v60;
      v52 = v57;
      v51 = v58;
    }
    *v18 = v47;
    v18[1] = v48;
    v18[3] = v49;
    v53 = (float *)(*(_QWORD *)(a2 + 32) + 16 * *(int *)(a1 + 160));
    *v53 = v50;
    v53[1] = v51;
    v53[3] = v52;
  }
}

float b2RopeJoint::SolveVelocityConstraints(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  float *v3;
  float v4;
  float v5;
  float v6;
  float *v7;
  float v8;
  float v9;
  float v10;
  float v11;
  float v12;
  float v13;
  float v14;
  float v15;
  float v16;
  float v17;
  float v18;
  float v19;
  float v20;
  float v21;
  float v22;
  float v23;
  float v24;
  float v25;
  float result;
  float v27;
  float v28;
  float *v29;

  v2 = *(_QWORD *)(a2 + 32);
  v3 = (float *)(v2 + 16 * *(int *)(a1 + 156));
  v4 = *v3;
  v5 = v3[1];
  v6 = v3[3];
  v7 = (float *)(v2 + 16 * *(int *)(a1 + 160));
  v8 = *v7;
  v9 = v7[1];
  v10 = v7[3];
  v12 = *(float *)(a1 + 172);
  v11 = *(float *)(a1 + 176);
  v14 = *(float *)(a1 + 180);
  v13 = *(float *)(a1 + 184);
  v15 = *(float *)(a1 + 148) - *(float *)(a1 + 144);
  v16 = *(float *)(a1 + 164);
  v17 = *(float *)(a1 + 168);
  v18 = (float)((float)((float)(v9 + (float)(v10 * v14)) - (float)(v5 + (float)(v6 * v12))) * v17)
      + (float)(v16 * (float)((float)(*v7 - (float)(v10 * v13)) - (float)(*v3 - (float)(v6 * v11))));
  if (v15 < 0.0)
    v18 = v18 + (float)(*(float *)(a2 + 4) * v15);
  v19 = *(float *)(a1 + 152);
  v20 = v19 - (float)(*(float *)(a1 + 220) * v18);
  if (v20 > 0.0)
    v20 = 0.0;
  *(float *)(a1 + 152) = v20;
  v21 = v20 - v19;
  v22 = v16 * v21;
  v23 = v17 * v21;
  v24 = *(float *)(a1 + 204);
  v25 = *(float *)(a1 + 208);
  result = v4 - (float)(v24 * v22);
  v27 = v6 - (float)(*(float *)(a1 + 212) * (float)((float)(v12 * v23) - (float)(v11 * v22)));
  v28 = v10 + (float)(*(float *)(a1 + 216) * (float)((float)(v14 * v23) - (float)(v13 * v22)));
  *v3 = result;
  v3[1] = v5 - (float)(v24 * v23);
  v3[3] = v27;
  v29 = (float *)(*(_QWORD *)(a2 + 32) + 16 * *(int *)(a1 + 160));
  *v29 = v8 + (float)(v25 * v22);
  v29[1] = v9 + (float)(v25 * v23);
  v29[3] = v28;
  return result;
}

BOOL b2RopeJoint::SolvePositionConstraints(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  float *v5;
  float v6;
  float v7;
  float v8;
  float *v9;
  float v10;
  float v11;
  float v12;
  __float2 v13;
  __float2 v14;
  float v15;
  float v16;
  float v17;
  float v18;
  float v19;
  float v20;
  float v21;
  float v22;
  float v23;
  float v24;
  float v25;
  float v26;
  float v27;
  float v28;
  float v29;
  float v30;
  float v31;
  float v32;
  float v33;
  float v34;
  float *v35;

  v4 = *(_QWORD *)(a2 + 24);
  v5 = (float *)(v4 + 16 * *(int *)(a1 + 156));
  v6 = *v5;
  v7 = v5[1];
  v8 = v5[3];
  v9 = (float *)(v4 + 16 * *(int *)(a1 + 160));
  v10 = *v9;
  v11 = v9[1];
  v12 = v9[3];
  v13 = __sincosf_stret(v8);
  v14 = __sincosf_stret(v12);
  v15 = *(float *)(a1 + 128) - *(float *)(a1 + 188);
  v16 = *(float *)(a1 + 132) - *(float *)(a1 + 192);
  v17 = (float)(v13.__cosval * v15) - (float)(v13.__sinval * v16);
  v18 = (float)(v13.__cosval * v16) + (float)(v13.__sinval * v15);
  v19 = *(float *)(a1 + 136) - *(float *)(a1 + 196);
  v20 = *(float *)(a1 + 140) - *(float *)(a1 + 200);
  v21 = (float)(v14.__cosval * v19) - (float)(v14.__sinval * v20);
  v22 = (float)(v14.__cosval * v20) + (float)(v14.__sinval * v19);
  v23 = (float)((float)(v10 + v21) - v6) - v17;
  v24 = (float)((float)(v11 + v22) - v7) - v18;
  v25 = sqrtf((float)(v24 * v24) + (float)(v23 * v23));
  v26 = 0.0;
  if (v25 >= 0.00000011921)
  {
    v23 = v23 * (float)(1.0 / v25);
    v24 = v24 * (float)(1.0 / v25);
  }
  else
  {
    v25 = 0.0;
  }
  v27 = fminf(v25 - *(float *)(a1 + 144), 0.2);
  if (v27 >= 0.0)
    v26 = v27;
  v28 = *(float *)(a1 + 216);
  v29 = -(float)(*(float *)(a1 + 220) * v26);
  v30 = v23 * v29;
  v31 = v24 * v29;
  v32 = *(float *)(a1 + 204);
  v33 = *(float *)(a1 + 208);
  v34 = v8 - (float)(*(float *)(a1 + 212) * (float)((float)(v17 * v31) - (float)(v18 * v30)));
  *v5 = v6 - (float)(v32 * v30);
  v5[1] = v7 - (float)(v32 * v31);
  v5[3] = v34;
  v35 = (float *)(*(_QWORD *)(a2 + 24) + 16 * *(int *)(a1 + 160));
  *v35 = v10 + (float)(v33 * v30);
  v35[1] = v11 + (float)(v33 * v31);
  v35[3] = v12 + (float)(v28 * (float)((float)(v21 * v31) - (float)(v22 * v30)));
  return (float)(v25 - *(float *)(a1 + 144)) < 0.0045;
}

float b2RopeJoint::GetAnchorA(b2RopeJoint *this)
{
  return this->var6->var8.var0.x
       + (float)((float)(this->var6->var8.var1.var1 * this->var11.x)
               - (float)(this->var6->var8.var1.var0 * this->var11.y));
}

float b2RopeJoint::GetAnchorB(b2RopeJoint *this)
{
  return this->var7->var8.var0.x
       + (float)((float)(this->var7->var8.var1.var1 * this->var12.x)
               - (float)(this->var7->var8.var1.var0 * this->var12.y));
}

float b2RopeJoint::GetReactionForce(b2RopeJoint *this, float a2)
{
  return this->var18.x * (float)(this->var15 * a2);
}

float b2RopeJoint::GetReactionTorque(b2RopeJoint *this, float a2)
{
  return 0.0;
}

uint64_t b2RopeJoint::GetLimitState(b2RopeJoint *this)
{
  return this->var28;
}

void b2RopeJoint::~b2RopeJoint(b2RopeJoint *this)
{
  JUMPOUT(0x20BD0BA58);
}

void b2WeldJoint::b2WeldJoint(b2WeldJoint *this, const b2JointDef *a2)
{
  uint64_t v3;

  b2Joint::b2Joint((b2Joint *)this, a2);
  *(_QWORD *)v3 = off_24C0E7DD0;
  *(_QWORD *)(v3 + 128) = *(_QWORD *)(&a2->var4 + 4);
  *(_QWORD *)(v3 + 136) = *(_QWORD *)(&a2[1].var0 + 1);
  *(_DWORD *)(v3 + 144) = HIDWORD(a2[1].var1);
  *(_QWORD *)(v3 + 152) = 0;
  *(_DWORD *)(v3 + 148) = 0;
}

void b2WeldJoint::InitVelocityConstraints(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  float v10;
  float v11;
  uint64_t v12;
  uint64_t v13;
  float v14;
  float32x2_t *v15;
  float32x2_t v16;
  float v17;
  float v18;
  float32x2_t *v19;
  float v20;
  __float2 v21;
  __float2 v22;
  float v23;
  float v24;
  float v26;
  float v27;
  float v28;
  float v30;
  float v31;
  float v32;
  float v33;
  float v34;
  float v35;
  float v36;
  float32x2_t v44;
  uint64_t v45;
  float v46;
  float v47;
  float32x2_t v48;

  v4 = *(_QWORD *)(a1 + 96);
  v5 = *(_QWORD *)(a1 + 104);
  v6 = *(int *)(v4 + 28);
  v7 = *(int *)(v5 + 28);
  *(_DWORD *)(a1 + 160) = v6;
  *(_DWORD *)(a1 + 164) = v7;
  v8 = *(_QWORD *)(v4 + 64);
  *(_QWORD *)(a1 + 184) = v8;
  v9 = *(_QWORD *)(v5 + 64);
  *(_QWORD *)(a1 + 192) = v9;
  v46 = *(float *)(v5 + 212);
  v47 = *(float *)(v4 + 212);
  *(float *)(a1 + 200) = v47;
  *(float *)(a1 + 204) = v46;
  v10 = *(float *)(v4 + 224);
  v11 = *(float *)(v5 + 224);
  *(float *)(a1 + 208) = v10;
  *(float *)(a1 + 212) = v11;
  v12 = *(_QWORD *)(a2 + 24);
  v13 = *(_QWORD *)(a2 + 32);
  v14 = *(float *)(v12 + 16 * v6 + 12);
  v15 = (float32x2_t *)(v13 + 16 * v6);
  v16 = *v15;
  v17 = v15[1].f32[1];
  v18 = *(float *)(v12 + 16 * v7 + 12);
  v19 = (float32x2_t *)(v13 + 16 * v7);
  v48 = *v19;
  v20 = v19[1].f32[1];
  v21 = __sincosf_stret(v14);
  v22 = __sincosf_stret(v18);
  v23 = *(float *)(a1 + 128) - *(float *)&v8;
  v24 = *(float *)(a1 + 132) - *((float *)&v8 + 1);
  _S2 = (float)(v21.__cosval * v23) - (float)(v21.__sinval * v24);
  v26 = (float)(v21.__cosval * v24) + (float)(v21.__sinval * v23);
  v27 = *(float *)(a1 + 136) - *(float *)&v9;
  v28 = *(float *)(a1 + 140) - *((float *)&v9 + 1);
  _S3 = (float)(v22.__cosval * v27) - (float)(v22.__sinval * v28);
  v30 = (float)(v22.__cosval * v28) + (float)(v22.__sinval * v27);
  v31 = (float)((float)(v47 + v46) + (float)((float)(v26 * v26) * v10)) + (float)((float)(v30 * v30) * v11);
  v32 = (float)(v11 * (float)-(float)(v30 * _S3)) + (float)((float)-(float)(v26 * _S2) * v10);
  *(float *)(a1 + 168) = _S2;
  *(float *)(a1 + 172) = v26;
  *(float *)(a1 + 176) = _S3;
  *(float *)(a1 + 180) = v30;
  v33 = (float)-(float)(v30 * v11) - (float)(v26 * v10);
  *(float *)(a1 + 216) = v31;
  *(float *)(a1 + 220) = v32;
  v34 = (float)(v11 * _S3) + (float)(_S2 * v10);
  *(float *)(a1 + 240) = v33;
  *(float *)(a1 + 244) = v34;
  *(float *)(a1 + 224) = v33;
  *(float *)(a1 + 228) = v32;
  *(float *)(a1 + 232) = (float)((float)(v47 + v46) + (float)((float)(_S2 * _S2) * v10))
                       + (float)((float)(_S3 * _S3) * v11);
  *(float *)(a1 + 236) = v34;
  *(float *)(a1 + 248) = v10 + v11;
  if (*(_BYTE *)(a2 + 20))
  {
    v35 = *(float *)(a2 + 8);
    v36 = v35 * *(float *)(a1 + 156);
    *(float *)(a1 + 156) = v36;
    _D1 = vmul_n_f32(*(float32x2_t *)(a1 + 148), v35);
    *(float32x2_t *)(a1 + 148) = _D1;
    v16 = vsub_f32(v16, vmul_n_f32(_D1, v47));
    __asm { FMLA            S4, S2, V1.S[1] }
    v17 = v17 - (float)(v10 * (float)(v36 + _S4));
    __asm { FMLA            S0, S3, V1.S[1] }
    v20 = v20 + (float)(v11 * (float)(v36 + _S0));
    v44 = vadd_f32(v48, vmul_n_f32(_D1, v46));
  }
  else
  {
    *(_QWORD *)(a1 + 152) = 0;
    *(_DWORD *)(a1 + 148) = 0;
    v44 = v48;
  }
  *v15 = v16;
  v15[1].f32[1] = v17;
  v45 = *(_QWORD *)(a2 + 32) + 16 * *(int *)(a1 + 164);
  *(float32x2_t *)v45 = v44;
  *(float *)(v45 + 12) = v20;
}

float b2WeldJoint::SolveVelocityConstraints(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  float *v5;
  float v6;
  float v7;
  float v8;
  float *v9;
  float v10;
  float v11;
  float v12;
  float v13;
  float v14;
  float v15;
  float v16;
  float v17;
  float v18;
  float v19;
  float v20;
  float v21;
  float v22;
  float result;
  float *v24;
  float *v25;
  float v26;
  float v27;
  b2Vec3 v28;

  v4 = *(_QWORD *)(a2 + 32);
  v5 = (float *)(v4 + 16 * *(int *)(a1 + 160));
  v6 = *v5;
  v7 = v5[1];
  v8 = v5[3];
  v9 = (float *)(v4 + 16 * *(int *)(a1 + 164));
  v10 = *v9;
  v11 = v9[1];
  v12 = v9[3];
  v13 = *(float *)(a1 + 200);
  v14 = *(float *)(a1 + 204);
  v26 = *(float *)(a1 + 208);
  v27 = *(float *)(a1 + 212);
  v15 = (float)((float)(v11 + (float)(v12 * *(float *)(a1 + 176))) - v7) - (float)(v8 * *(float *)(a1 + 168));
  v28.var0 = (float)((float)(*v9 - (float)(v12 * *(float *)(a1 + 180))) - *v5) + (float)(v8 * *(float *)(a1 + 172));
  v28.var1 = v15;
  v28.var2 = v12 - v8;
  v16 = b2Mat33::Solve33((b2Mat33 *)(a1 + 216), &v28);
  v18 = *(float *)(a1 + 152) - v17;
  *(float *)(a1 + 148) = *(float *)(a1 + 148) - v16;
  *(float *)(a1 + 152) = v18;
  *(float *)(a1 + 156) = *(float *)(a1 + 156) - v19;
  v20 = v6 + (float)(v13 * v16);
  v21 = v8
      - (float)(v26 * (float)((float)((float)(v16 * *(float *)(a1 + 172)) - (float)(*(float *)(a1 + 168) * v17)) - v19));
  v22 = v10 - (float)(v14 * v16);
  result = v12
         + (float)(v27
                 * (float)((float)((float)(v16 * *(float *)(a1 + 180)) - (float)(*(float *)(a1 + 176) * v17)) - v19));
  v24 = (float *)(*(_QWORD *)(a2 + 32) + 16 * *(int *)(a1 + 160));
  *v24 = v20;
  v24[1] = v7 + (float)(v13 * v17);
  v24[3] = v21;
  v25 = (float *)(*(_QWORD *)(a2 + 32) + 16 * *(int *)(a1 + 164));
  *v25 = v22;
  v25[1] = v11 - (float)(v14 * v17);
  v25[3] = result;
  return result;
}

BOOL b2WeldJoint::SolvePositionConstraints(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  float *v5;
  float *v6;
  float v7;
  float v8;
  __float2 v9;
  __float2 v10;
  float v11;
  float v12;
  float v13;
  float v14;
  float v15;
  float v16;
  float v17;
  float v18;
  float v19;
  float v20;
  float v21;
  float v22;
  float v23;
  float v24;
  float v25;
  float v26;
  float v27;
  float v28;
  float v29;
  float v30;
  float *v31;
  float *v32;
  float v34;
  float v35;
  float v36;
  float v37;
  float v38;
  float v39;
  float v40;
  float v41;
  float v42;
  b2Vec3 v43;

  v4 = *(_QWORD *)(a2 + 24);
  v5 = (float *)(v4 + 16 * *(int *)(a1 + 160));
  v34 = v5[1];
  v40 = v5[3];
  v41 = *v5;
  v6 = (float *)(v4 + 16 * *(int *)(a1 + 164));
  v7 = *v6;
  v38 = *v6;
  v42 = v6[1];
  v8 = v6[3];
  v9 = __sincosf_stret(v40);
  v37 = v8;
  v10 = __sincosf_stret(v8);
  v11 = *(float *)(a1 + 200);
  v36 = *(float *)(a1 + 204);
  v13 = *(float *)(a1 + 208);
  v12 = *(float *)(a1 + 212);
  v14 = *(float *)(a1 + 128) - *(float *)(a1 + 184);
  v15 = *(float *)(a1 + 132) - *(float *)(a1 + 188);
  v16 = (float)(v9.__cosval * v14) - (float)(v9.__sinval * v15);
  v17 = (float)(v9.__cosval * v15) + (float)(v9.__sinval * v14);
  v18 = *(float *)(a1 + 136) - *(float *)(a1 + 192);
  v19 = *(float *)(a1 + 140) - *(float *)(a1 + 196);
  v20 = (float)(v10.__cosval * v18) - (float)(v10.__sinval * v19);
  v21 = (float)(v10.__cosval * v19) + (float)(v10.__sinval * v18);
  v22 = (float)(v8 - v40) - *(float *)(a1 + 144);
  v39 = sqrtf((float)((float)((float)((float)(v42 + v21) - v34) - v17) * (float)((float)((float)(v42 + v21) - v34) - v17))+ (float)((float)((float)((float)(v7 + v20) - v41) - v16) * (float)((float)((float)(v7 + v20) - v41) - v16)));
  v23 = -v22;
  v24 = v11;
  *(float *)(a1 + 216) = (float)((float)(v11 + v36) + (float)((float)(v17 * v17) * v13))
                       + (float)((float)(v21 * v21) * v12);
  v25 = (float)(v12 * (float)-(float)(v21 * v20)) + (float)((float)-(float)(v17 * v16) * v13);
  v26 = (float)-(float)(v21 * v12) - (float)(v17 * v13);
  *(float *)(a1 + 228) = v25;
  *(float *)(a1 + 232) = (float)((float)(v11 + v36) + (float)((float)(v16 * v16) * v13))
                       + (float)((float)(v20 * v20) * v12);
  v27 = (float)(v12 * v20) + (float)(v16 * v13);
  *(float *)(a1 + 220) = v25;
  *(float *)(a1 + 224) = v26;
  *(float *)(a1 + 236) = v27;
  *(float *)(a1 + 240) = v26;
  *(float *)(a1 + 244) = v27;
  *(float *)(a1 + 248) = v13 + v12;
  if (v22 > 0.0)
    v23 = v22;
  v35 = v23;
  v43.var0 = (float)((float)(v7 + v20) - v41) - v16;
  v43.var1 = (float)((float)(v42 + v21) - v34) - v17;
  v43.var2 = v22;
  v28 = b2Mat33::Solve33((b2Mat33 *)(a1 + 216), &v43);
  v31 = (float *)(*(_QWORD *)(a2 + 24) + 16 * *(int *)(a1 + 160));
  *v31 = v41 + (float)(v24 * v28);
  v31[1] = v34 + (float)(v24 * v29);
  v31[3] = v40 - (float)(v13 * (float)((float)((float)(v17 * v28) - (float)(v16 * v29)) - v30));
  v32 = (float *)(*(_QWORD *)(a2 + 24) + 16 * *(int *)(a1 + 164));
  *v32 = v38 - (float)(v36 * v28);
  v32[1] = v42 - (float)(v36 * v29);
  v32[3] = v37 + (float)(v12 * (float)((float)((float)(v21 * v28) - (float)(v20 * v29)) - v30));
  return v35 <= 0.034907 && v39 <= 0.0045;
}

float b2WeldJoint::GetAnchorA(b2WeldJoint *this)
{
  return this->var6->var8.var0.x
       + (float)((float)(this->var6->var8.var1.var1 * this->var11.x)
               - (float)(this->var6->var8.var1.var0 * this->var11.y));
}

float b2WeldJoint::GetAnchorB(b2WeldJoint *this)
{
  return this->var7->var8.var0.x
       + (float)((float)(this->var7->var8.var1.var1 * this->var12.x)
               - (float)(this->var7->var8.var1.var0 * this->var12.y));
}

float b2WeldJoint::GetReactionForce(b2WeldJoint *this, float a2)
{
  return this->var14.var0 * a2;
}

float b2WeldJoint::GetReactionTorque(b2WeldJoint *this, float a2)
{
  return this->var14.var2 * a2;
}

void b2WeldJoint::~b2WeldJoint(b2WeldJoint *this)
{
  JUMPOUT(0x20BD0BA58);
}

float b2WheelJointDef::Initialize(b2WheelJointDef *this, b2Body *a2, b2Body *a3, const b2Vec2 *a4, const b2Vec2 *a5)
{
  float v5;
  float v6;
  float var1;
  float var0;
  float v9;
  float v10;
  float v11;
  float v12;
  float v13;
  float v14;
  float y;
  float v16;
  float result;

  *((_QWORD *)this + 2) = a2;
  *((_QWORD *)this + 3) = a3;
  v5 = a4->x - a2->var8.var0.x;
  v6 = a4->y - a2->var8.var0.y;
  var0 = a2->var8.var1.var0;
  var1 = a2->var8.var1.var1;
  *((float *)this + 9) = (float)(v6 * var0) + (float)(var1 * v5);
  *((float *)this + 10) = (float)(var1 * v6) - (float)(var0 * v5);
  v9 = a4->x - a3->var8.var0.x;
  v10 = a4->y - a3->var8.var0.y;
  v12 = a3->var8.var1.var0;
  v11 = a3->var8.var1.var1;
  *((float *)this + 11) = (float)(v10 * v12) + (float)(v11 * v9);
  *((float *)this + 12) = (float)(v11 * v10) - (float)(v12 * v9);
  v14 = a2->var8.var1.var0;
  v13 = a2->var8.var1.var1;
  y = a5->y;
  v16 = (float)(v14 * y) + (float)(v13 * a5->x);
  result = (float)(v13 * y) - (float)(v14 * a5->x);
  *((float *)this + 13) = v16;
  *((float *)this + 14) = result;
  return result;
}

void b2WheelJoint::b2WheelJoint(b2WheelJoint *this, const b2WheelJointDef *a2)
{
  uint64_t v3;
  uint64_t v4;

  b2Joint::b2Joint((b2Joint *)this, (const b2JointDef *)a2);
  *(_QWORD *)v3 = off_24C0E7F88;
  *(_QWORD *)(v3 + 136) = *(_QWORD *)((char *)a2 + 36);
  *(_QWORD *)(v3 + 144) = *(_QWORD *)((char *)a2 + 44);
  v4 = *(_QWORD *)((char *)a2 + 52);
  *(_QWORD *)(v3 + 152) = v4;
  *(_DWORD *)(v3 + 160) = HIDWORD(v4) ^ 0x80000000;
  *(_DWORD *)(v3 + 164) = v4;
  *(_QWORD *)(v3 + 168) = 0;
  *(_DWORD *)(v3 + 176) = 0;
  *(_QWORD *)(v3 + 180) = *((_QWORD *)a2 + 8);
  *(_BYTE *)(v3 + 188) = *((_BYTE *)a2 + 60);
  *(_QWORD *)(v3 + 128) = *((_QWORD *)a2 + 9);
  *(_QWORD *)(v3 + 264) = 0;
  *(_QWORD *)(v3 + 272) = 0;
  *(_DWORD *)(v3 + 280) = 0;
  *(_QWORD *)(v3 + 232) = 0;
  *(_QWORD *)(v3 + 240) = 0;
}

void b2WheelJoint::InitVelocityConstraints(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  float v10;
  float v11;
  float v12;
  float v13;
  uint64_t v14;
  uint64_t v15;
  float *v16;
  float *v17;
  float *v18;
  float v19;
  float v20;
  float *v21;
  float v22;
  float cosval;
  __float2 v24;
  __float2 v25;
  float v26;
  float v27;
  float v28;
  float v29;
  float v30;
  float v31;
  float v32;
  float v33;
  float v34;
  float v35;
  float v36;
  float v37;
  float v38;
  float v39;
  float v40;
  float v41;
  float v42;
  float v43;
  float v44;
  float v45;
  float v46;
  float v47;
  float v48;
  float v49;
  float v50;
  float v51;
  float v52;
  float v53;
  float v54;
  float v55;
  float v56;
  float v57;
  float v58;
  float v59;
  float v60;
  float v61;
  float v62;
  float v63;
  float v64;
  float v65;
  float v66;
  float v67;
  float v68;
  float v69;
  float v70;
  float v71;
  float v72;
  float v73;
  float *v74;
  float v75;
  float v76;
  float v77;
  float v78;
  float v79;
  float v80;
  float v81;
  float v82;
  float v83;

  v4 = *(_QWORD *)(a1 + 96);
  v5 = *(_QWORD *)(a1 + 104);
  v6 = *(int *)(v4 + 28);
  v7 = *(int *)(v5 + 28);
  *(_DWORD *)(a1 + 192) = v6;
  *(_DWORD *)(a1 + 196) = v7;
  v8 = *(_QWORD *)(v4 + 64);
  *(_QWORD *)(a1 + 200) = v8;
  v9 = *(_QWORD *)(v5 + 64);
  *(_QWORD *)(a1 + 208) = v9;
  v10 = *(float *)(v4 + 212);
  v11 = *(float *)(v5 + 212);
  *(float *)(a1 + 216) = v10;
  *(float *)(a1 + 220) = v11;
  v12 = *(float *)(v4 + 224);
  v13 = *(float *)(v5 + 224);
  *(float *)(a1 + 224) = v12;
  *(float *)(a1 + 228) = v13;
  v14 = *(_QWORD *)(a2 + 24);
  v15 = *(_QWORD *)(a2 + 32);
  v16 = (float *)(v14 + 16 * v6);
  v82 = *v16;
  v83 = v16[1];
  v17 = (float *)(v15 + 16 * v6);
  v78 = *v17;
  v79 = v17[3];
  v18 = (float *)(v14 + 16 * v7);
  v19 = v18[1];
  v80 = v17[1];
  v81 = *v18;
  v20 = v18[3];
  v21 = (float *)(v15 + 16 * v7);
  v76 = v21[1];
  v77 = *v21;
  v75 = v21[3];
  v24 = __sincosf_stret(v16[3]);
  cosval = v24.__cosval;
  LODWORD(v22) = *(_QWORD *)&v24;
  v25 = __sincosf_stret(v20);
  v26 = *(float *)(a1 + 136) - *(float *)&v8;
  v27 = *(float *)(a1 + 140) - *((float *)&v8 + 1);
  v28 = (float)(cosval * v26) - (float)(v22 * v27);
  v29 = (float)(cosval * v27) + (float)(v22 * v26);
  v30 = *(float *)(a1 + 144) - *(float *)&v9;
  v31 = *(float *)(a1 + 148) - *((float *)&v9 + 1);
  v32 = (float)(v25.__cosval * v30) - (float)(v25.__sinval * v31);
  v33 = v25.__cosval * v31;
  v34 = (float)(v25.__cosval * v31) + (float)(v25.__sinval * v30);
  v35 = (float)((float)(v81 + v32) - v82) - v28;
  v36 = (float)((float)(v19 + v34) - v83) - v29;
  v37 = *(float *)(a1 + 160);
  v38 = *(float *)(a1 + 164);
  v39 = (float)(cosval * v37) - (float)(v22 * v38);
  v40 = (float)(cosval * v38) + (float)(v22 * v37);
  *(float *)(a1 + 240) = v39;
  *(float *)(a1 + 244) = v40;
  v41 = v28 + v35;
  v42 = v29 + v36;
  v43 = (float)(v41 * v40) - (float)((float)(v29 + v36) * v39);
  *(float *)(a1 + 256) = v43;
  v44 = (float)(v32 * v40) - (float)(v34 * v39);
  *(float *)(a1 + 260) = v44;
  v45 = (float)((float)(v10 + v11) + (float)((float)(v12 * v43) * v43)) + (float)((float)(v13 * v44) * v44);
  if (v45 > 0.0)
    v45 = 1.0 / v45;
  *(float *)(a1 + 264) = v45;
  *(_QWORD *)(a1 + 272) = 0;
  *(_DWORD *)(a1 + 280) = 0;
  v46 = *(float *)(a1 + 128);
  if (v46 <= 0.0)
  {
    *(_DWORD *)(a1 + 176) = 0;
  }
  else
  {
    v47 = -(float)(v33 + (float)(v25.__sinval * v30));
    v48 = *(float *)(a1 + 152);
    v49 = *(float *)(a1 + 156);
    v50 = (float)(v49 * (float)-v22) + (float)(cosval * v48);
    v51 = (float)(cosval * v49) + (float)(v22 * v48);
    *(float *)(a1 + 232) = v50;
    *(float *)(a1 + 236) = v51;
    v52 = (float)(v50 * (float)-v42) + (float)(v41 * v51);
    v53 = (float)(v50 * v47) + (float)(v32 * v51);
    *(float *)(a1 + 248) = v52;
    *(float *)(a1 + 252) = v53;
    v54 = (float)((float)(v10 + v11) + (float)((float)(v12 * v52) * v52)) + (float)((float)(v13 * v53) * v53);
    if (v54 > 0.0)
    {
      v55 = (float)(v36 * v51) + (float)(v35 * v50);
      v56 = (float)(v46 * 6.2832) * (float)((float)(v46 * 6.2832) * (float)(1.0 / v54));
      v57 = *(float *)a2;
      v58 = *(float *)a2
          * (float)((float)((float)(v46 * 6.2832)
                          * (float)((float)((float)(1.0 / v54) + (float)(1.0 / v54)) * *(float *)(a1 + 132)))
                  + (float)(*(float *)a2 * v56));
      if (v58 > 0.0)
        v58 = 1.0 / v58;
      *(float *)(a1 + 280) = v58;
      *(float *)(a1 + 276) = (float)(v56 * (float)(v55 * v57)) * v58;
      v59 = v54 + v58;
      if (v59 > 0.0)
        v59 = 1.0 / v59;
      *(float *)(a1 + 272) = v59;
    }
  }
  if (*(_BYTE *)(a1 + 188))
  {
    *(float *)(a1 + 268) = v12 + v13;
    if ((float)(v12 + v13) > 0.0)
      *(float *)(a1 + 268) = 1.0 / (float)(v12 + v13);
  }
  else
  {
    *(_DWORD *)(a1 + 268) = 0;
    *(_DWORD *)(a1 + 172) = 0;
  }
  if (*(_BYTE *)(a2 + 20))
  {
    v60 = *(float *)(a2 + 8);
    v61 = v60 * *(float *)(a1 + 168);
    v62 = v60 * *(float *)(a1 + 176);
    v63 = v60 * *(float *)(a1 + 172);
    *(float *)(a1 + 168) = v61;
    *(float *)(a1 + 172) = v63;
    *(float *)(a1 + 176) = v62;
    v64 = (float)(v39 * v61) + (float)(v62 * *(float *)(a1 + 232));
    v65 = (float)(v40 * v61) + (float)(v62 * *(float *)(a1 + 236));
    v66 = v63 + (float)((float)(v62 * *(float *)(a1 + 248)) + (float)(v61 * v43));
    v67 = v63 + (float)((float)(v62 * *(float *)(a1 + 252)) + (float)(v61 * v44));
    v68 = v78 - (float)(v10 * v64);
    v69 = v80 - (float)(v10 * v65);
    v70 = v79 - (float)(v12 * v66);
    v71 = v77 + (float)(v11 * v64);
    v72 = v76 + (float)(v11 * v65);
    v73 = v75 + (float)(v13 * v67);
  }
  else
  {
    *(_DWORD *)(a1 + 176) = 0;
    *(_QWORD *)(a1 + 168) = 0;
    v70 = v79;
    v69 = v80;
    v71 = v77;
    v68 = v78;
    v73 = v75;
    v72 = v76;
  }
  *v17 = v68;
  v17[1] = v69;
  v17[3] = v70;
  v74 = (float *)(*(_QWORD *)(a2 + 32) + 16 * *(int *)(a1 + 196));
  *v74 = v71;
  v74[1] = v72;
  v74[3] = v73;
}

float b2WheelJoint::SolveVelocityConstraints(uint64_t a1, uint64_t a2)
{
  float v2;
  float v3;
  float v4;
  float v5;
  uint64_t v6;
  float *v7;
  float v8;
  float v9;
  float v10;
  float *v11;
  float v12;
  float v13;
  float v14;
  float v15;
  float v16;
  float v17;
  float v18;
  float v19;
  float v20;
  float v21;
  float v22;
  float v23;
  float v24;
  float v25;
  float v26;
  float v27;
  float v28;
  float v29;
  float v30;
  float v31;
  float v32;
  float v33;
  float v34;
  float v35;
  float v36;
  float v37;
  float v38;
  float v39;
  float v40;
  float v41;
  float v42;
  float v43;
  float v44;
  float result;
  float *v46;

  v3 = *(float *)(a1 + 216);
  v2 = *(float *)(a1 + 220);
  v5 = *(float *)(a1 + 224);
  v4 = *(float *)(a1 + 228);
  v6 = *(_QWORD *)(a2 + 32);
  v7 = (float *)(v6 + 16 * *(int *)(a1 + 192));
  v8 = *v7;
  v9 = v7[1];
  v10 = v7[3];
  v11 = (float *)(v6 + 16 * *(int *)(a1 + 196));
  v12 = *v11;
  v13 = v11[1];
  v14 = v11[3];
  v15 = *(float *)(a1 + 232);
  v16 = *(float *)(a1 + 236);
  v18 = *(float *)(a1 + 248);
  v17 = *(float *)(a1 + 252);
  v19 = *(float *)(a1 + 176);
  v20 = *(float *)(a1 + 180);
  v21 = -(float)(*(float *)(a1 + 272)
               * (float)((float)((float)((float)((float)((float)((float)(v13 - v9) * v16)
                                                       + (float)(v15 * (float)(*v11 - *v7)))
                                               + (float)(v17 * v14))
                                       - (float)(v18 * v10))
                               + *(float *)(a1 + 276))
                       + (float)(*(float *)(a1 + 280) * v19)));
  *(float *)(a1 + 176) = v19
                       - (float)(*(float *)(a1 + 272)
                               * (float)((float)((float)((float)((float)((float)((float)(v13 - v9) * v16)
                                                                       + (float)(v15 * (float)(*v11 - *v7)))
                                                               + (float)(v17 * v14))
                                                       - (float)(v18 * v10))
                                               + *(float *)(a1 + 276))
                                       + (float)(*(float *)(a1 + 280) * v19)));
  v22 = v15 * v21;
  v23 = v16 * v21;
  v24 = v8 - (float)(v3 * v22);
  v25 = v9 - (float)(v3 * v23);
  v26 = v10 - (float)(v5 * (float)(v18 * v21));
  v27 = v12 + (float)(v2 * v22);
  v28 = v13 + (float)(v2 * v23);
  v29 = v14 + (float)(v4 * (float)(v17 * v21));
  v30 = *(float *)a2 * v20;
  v31 = *(float *)(a1 + 172);
  v32 = v31 - (float)(*(float *)(a1 + 268) * (float)((float)(v29 - v26) - *(float *)(a1 + 184)));
  if (v32 >= v30)
    v32 = *(float *)a2 * v20;
  if (v32 < (float)-v30)
    v32 = -v30;
  v33 = v32 - v31;
  v34 = v26 - (float)(v5 * v33);
  v35 = v29 + (float)(v4 * v33);
  v36 = *(float *)(a1 + 240);
  v37 = *(float *)(a1 + 244);
  v38 = *(float *)(a1 + 260);
  v39 = *(float *)(a1 + 256);
  v40 = *(float *)(a1 + 264);
  v41 = -(float)(v40
               * (float)((float)((float)((float)((float)(v28 - v25) * v37) + (float)(v36 * (float)(v27 - v24)))
                               + (float)(v38 * v35))
                       - (float)(v39 * v34)));
  *(float *)(a1 + 168) = *(float *)(a1 + 168)
                       - (float)(v40
                               * (float)((float)((float)((float)((float)(v28 - v25) * v37)
                                                       + (float)(v36 * (float)(v27 - v24)))
                                               + (float)(v38 * v35))
                                       - (float)(v39 * v34)));
  *(float *)(a1 + 172) = v32;
  v42 = v24 - (float)(v3 * (float)(v36 * v41));
  v43 = v25 - (float)(v3 * (float)(v37 * v41));
  v44 = v27 + (float)(v2 * (float)(v36 * v41));
  result = v28 + (float)(v2 * (float)(v37 * v41));
  *v7 = v42;
  v7[1] = v43;
  v7[3] = v34 - (float)(v5 * (float)(v39 * v41));
  v46 = (float *)(*(_QWORD *)(a2 + 32) + 16 * *(int *)(a1 + 196));
  *v46 = v44;
  v46[1] = result;
  v46[3] = v35 + (float)(v4 * (float)(v38 * v41));
  return result;
}

BOOL b2WheelJoint::SolvePositionConstraints(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  float *v5;
  float v6;
  float v7;
  float v8;
  float *v9;
  float v10;
  float v11;
  float v12;
  __float2 v13;
  __float2 v14;
  float v15;
  float v16;
  float v17;
  float v18;
  float v19;
  float v20;
  float v21;
  float v22;
  float v23;
  float v24;
  float v25;
  float v26;
  float v27;
  float v28;
  float v29;
  float v30;
  float v31;
  float v32;
  float v33;
  float v34;
  float v35;
  BOOL v36;
  float v37;
  float *v38;
  float v39;

  v4 = *(_QWORD *)(a2 + 24);
  v5 = (float *)(v4 + 16 * *(int *)(a1 + 192));
  v7 = *v5;
  v6 = v5[1];
  v8 = v5[3];
  v9 = (float *)(v4 + 16 * *(int *)(a1 + 196));
  v11 = *v9;
  v10 = v9[1];
  v12 = v9[3];
  v13 = __sincosf_stret(v8);
  v14 = __sincosf_stret(v12);
  v15 = *(float *)(a1 + 136) - *(float *)(a1 + 200);
  v16 = *(float *)(a1 + 140) - *(float *)(a1 + 204);
  v17 = (float)(v13.__cosval * v15) - (float)(v13.__sinval * v16);
  v18 = (float)(v13.__cosval * v16) + (float)(v13.__sinval * v15);
  v19 = *(float *)(a1 + 144) - *(float *)(a1 + 208);
  v20 = *(float *)(a1 + 148) - *(float *)(a1 + 212);
  v21 = (float)(v14.__cosval * v19) - (float)(v14.__sinval * v20);
  v22 = (float)(v14.__cosval * v20) + (float)(v14.__sinval * v19);
  v23 = (float)((float)(v11 - v7) + v21) - v17;
  v24 = (float)((float)(v10 - v6) + v22) - v18;
  v25 = *(float *)(a1 + 160);
  v26 = *(float *)(a1 + 164);
  v27 = (float)(v13.__cosval * v25) - (float)(v13.__sinval * v26);
  v28 = (float)(v13.__cosval * v26) + (float)(v13.__sinval * v25);
  v29 = (float)(v28 * v24) + (float)(v23 * v27);
  v30 = *(float *)(a1 + 216);
  v31 = *(float *)(a1 + 220);
  v32 = *(float *)(a1 + 224);
  v33 = *(float *)(a1 + 228);
  v34 = (float)((float)(v30 + v31) + (float)((float)(v32 * *(float *)(a1 + 256)) * *(float *)(a1 + 256)))
      + (float)((float)(v33 * *(float *)(a1 + 260)) * *(float *)(a1 + 260));
  v35 = (float)-v29 / v34;
  v36 = v34 == 0.0;
  v37 = 0.0;
  if (!v36)
    v37 = v35;
  *v5 = v7 - (float)(v30 * (float)(v27 * v37));
  v5[1] = v6 - (float)(v30 * (float)(v28 * v37));
  v5[3] = v8
        - (float)(v32 * (float)((float)((float)((float)(v17 + v23) * v28) - (float)((float)(v18 + v24) * v27)) * v37));
  v38 = (float *)(*(_QWORD *)(a2 + 24) + 16 * *(int *)(a1 + 196));
  *v38 = v11 + (float)(v31 * (float)(v27 * v37));
  v38[1] = v10 + (float)(v31 * (float)(v28 * v37));
  v38[3] = v12 + (float)(v33 * (float)((float)((float)(v21 * v28) - (float)(v22 * v27)) * v37));
  if (v29 <= 0.0)
    v39 = -v29;
  else
    v39 = (float)(v28 * v24) + (float)(v23 * v27);
  return v39 <= 0.0045;
}

float b2WheelJoint::GetAnchorA(b2WheelJoint *this)
{
  return *(float *)(*((_QWORD *)this + 12) + 32)
       + (float)((float)(*(float *)(*((_QWORD *)this + 12) + 44) * *((float *)this + 34))
               - (float)(*(float *)(*((_QWORD *)this + 12) + 40) * *((float *)this + 35)));
}

float b2WheelJoint::GetAnchorB(b2WheelJoint *this)
{
  return *(float *)(*((_QWORD *)this + 13) + 32)
       + (float)((float)(*(float *)(*((_QWORD *)this + 13) + 44) * *((float *)this + 36))
               - (float)(*(float *)(*((_QWORD *)this + 13) + 40) * *((float *)this + 37)));
}

float32x2_t b2WheelJoint::GetReactionForce(float32x2_t *this, float a2)
{
  return vmul_n_f32(vadd_f32(vmul_n_f32(this[30], this[21].f32[0]), vmul_n_f32(this[29], this[22].f32[0])), a2);
}

float b2WheelJoint::GetReactionTorque(b2WheelJoint *this, float a2)
{
  return *((float *)this + 43) * a2;
}

float b2WheelJoint::GetJointTranslation(b2WheelJoint *this)
{
  float *v1;
  float *v2;
  float v3;
  float v4;
  float v5;

  v1 = (float *)*((_QWORD *)this + 12);
  v2 = (float *)*((_QWORD *)this + 13);
  v4 = v1[10];
  v3 = v1[11];
  v5 = *((float *)this + 34);
  return (float)((float)((float)((float)((float)(v2[11] * *((float *)this + 37))
                                       + (float)(v2[10] * *((float *)this + 36)))
                               + v2[9])
                       - (float)((float)((float)(v3 * *((float *)this + 35)) + (float)(v4 * v5)) + v1[9]))
               * (float)((float)(v3 * *((float *)this + 39)) + (float)(v4 * *((float *)this + 38))))
       + (float)((float)((float)(v2[8]
                               + (float)((float)(v2[11] * *((float *)this + 36))
                                       - (float)(v2[10] * *((float *)this + 37))))
                       - (float)(v1[8] + (float)((float)(v3 * v5) - (float)(v4 * *((float *)this + 35)))))
               * (float)((float)(v3 * *((float *)this + 38)) - (float)(v4 * *((float *)this + 39))));
}

float b2WheelJoint::GetJointSpeed(b2WheelJoint *this)
{
  return *(float *)(*((_QWORD *)this + 13) + 136) - *(float *)(*((_QWORD *)this + 12) + 136);
}

uint64_t b2WheelJoint::IsMotorEnabled(b2WheelJoint *this)
{
  return *((unsigned __int8 *)this + 188);
}

b2Body *b2WheelJoint::EnableMotor(b2Body **this, char a2)
{
  b2Body *result;

  b2Body::SetAwake(this[12], 1);
  result = b2Body::SetAwake(this[13], 1);
  *((_BYTE *)this + 188) = a2;
  return result;
}

b2Body *b2WheelJoint::SetMotorSpeed(b2Body **this, float a2)
{
  b2Body *result;

  b2Body::SetAwake(this[12], 1);
  result = b2Body::SetAwake(this[13], 1);
  *((float *)this + 46) = a2;
  return result;
}

b2Body *b2WheelJoint::SetMaxMotorTorque(b2Body **this, float a2)
{
  b2Body *result;

  b2Body::SetAwake(this[12], 1);
  result = b2Body::SetAwake(this[13], 1);
  *((float *)this + 45) = a2;
  return result;
}

float b2WheelJoint::GetMotorTorque(b2WheelJoint *this, float a2)
{
  return *((float *)this + 43) * a2;
}

void b2WheelJoint::~b2WheelJoint(b2WheelJoint *this)
{
  JUMPOUT(0x20BD0BA58);
}

void b2Rope::b2Rope(b2Rope *this)
{
  *(_DWORD *)this = 0;
  *(_OWORD *)((char *)this + 8) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 40) = 0u;
  *((_QWORD *)this + 7) = 0;
  *(_QWORD *)((char *)this + 68) = 0x3DCCCCCD3F800000;
}

void b2Rope::~b2Rope(void **this)
{
  b2Free(this[1]);
  b2Free(this[2]);
  b2Free(this[3]);
  b2Free(this[4]);
  b2Free(this[5]);
  b2Free(this[6]);
}

float b2Rope::Initialize(int *a1, uint64_t a2)
{
  int v2;
  uint64_t v5;
  uint64_t v6;
  float v7;
  float v8;
  uint64_t v9;
  float *v10;
  uint64_t v11;
  float *v12;
  float *v13;
  float *v14;
  float v15;
  float v16;
  float v17;
  float v18;
  float *v19;
  float v20;
  float v21;
  float v22;
  float v23;
  float v24;
  float v25;
  float result;

  v2 = *(_DWORD *)(a2 + 8);
  if (v2 <= 2)
    b2Rope::Initialize();
  *a1 = v2;
  *((_QWORD *)a1 + 1) = b2Alloc(8 * v2);
  *((_QWORD *)a1 + 2) = b2Alloc(8 * *a1);
  *((_QWORD *)a1 + 3) = b2Alloc(8 * *a1);
  *((_QWORD *)a1 + 4) = b2Alloc(4 * *a1);
  LODWORD(v5) = *a1;
  if (*a1 >= 1)
  {
    v6 = 0;
    do
    {
      *(_QWORD *)(*((_QWORD *)a1 + 1) + 8 * v6) = *(_QWORD *)(*(_QWORD *)a2 + 8 * v6);
      *(_QWORD *)(*((_QWORD *)a1 + 2) + 8 * v6) = *(_QWORD *)(*(_QWORD *)a2 + 8 * v6);
      *(_QWORD *)(*((_QWORD *)a1 + 3) + 8 * v6) = 0;
      v7 = *(float *)(*(_QWORD *)(a2 + 16) + 4 * v6);
      if (v7 <= 0.0)
        v8 = 0.0;
      else
        v8 = 1.0 / v7;
      *(float *)(*((_QWORD *)a1 + 4) + 4 * v6++) = v8;
      v5 = *a1;
    }
    while (v6 < v5);
  }
  v9 = (v5 - 1);
  *((_QWORD *)a1 + 5) = b2Alloc(4 * (int)v9);
  v10 = (float *)b2Alloc(4 * ((int)v5 - 2));
  *((_QWORD *)a1 + 6) = v10;
  v11 = (v5 - 2);
  if ((int)v5 >= 2)
  {
    v12 = v10;
    v13 = (float *)*((_QWORD *)a1 + 5);
    v14 = (float *)(*((_QWORD *)a1 + 1) + 8);
    do
    {
      v15 = *(v14 - 2);
      v16 = *(v14 - 1);
      v17 = *v14;
      v18 = v14[1];
      v14 += 2;
      *v13++ = sqrtf((float)((float)(v16 - v18) * (float)(v16 - v18)) + (float)((float)(v15 - v17) * (float)(v15 - v17)));
      --v9;
    }
    while (v9);
    if ((int)v5 >= 3)
    {
      v19 = (float *)(*((_QWORD *)a1 + 1) + 12);
      do
      {
        v20 = *(v19 - 3);
        v21 = *(v19 - 2);
        v22 = *(v19 - 1);
        v23 = *v19;
        v24 = v19[1];
        v25 = v19[2];
        v19 += 2;
        *v12++ = atan2f((float)((float)(v22 - v20) * (float)(v25 - v23)) - (float)((float)(v23 - v21) * (float)(v24 - v22)), (float)((float)(v23 - v21) * (float)(v25 - v23)) + (float)((float)(v22 - v20) * (float)(v24 - v22)));
        --v11;
      }
      while (v11);
    }
  }
  *((_QWORD *)a1 + 7) = *(_QWORD *)(a2 + 24);
  *((_QWORD *)a1 + 8) = *(_QWORD *)(a2 + 32);
  result = *(float *)(a2 + 40);
  *((float *)a1 + 18) = result;
  return result;
}

void b2Rope::Step(float32x2_t *this, double a2, int a3, double a4, double a5, double a6, double a7, int32x4_t a8)
{
  uint64_t v10;
  uint64_t v11;
  float32x2_t v12;
  float32x2_t v13;
  float32x2_t v14;
  float32x2_t v15;
  double v16;
  double v17;
  double v18;
  double v19;
  double v20;
  int32x4_t v21;
  float32x2_t *v22;
  float32x2_t *v23;
  float32x2_t *v24;
  float32x2_t v25;
  float32x2_t v26;
  float32x2_t v27;
  double v28;

  if (*(float *)&a2 != 0.0)
  {
    LODWORD(a6) = LODWORD(a2);
    LODWORD(v10) = this->i32[0];
    v28 = a6;
    if (this->i32[0] >= 1)
    {
      *(float *)&a2 = expf(-(float)(*(float *)&a2 * this[8].f32[0]));
      a6 = v28;
      v11 = 0;
      v12 = this[1];
      do
      {
        *(_QWORD *)(*(_QWORD *)&this[2] + 8 * v11) = *(_QWORD *)(*(_QWORD *)&v12 + 8 * v11);
        v13 = this[3];
        if (*(float *)(*(_QWORD *)&this[4] + 4 * v11) <= 0.0)
          v14 = *(float32x2_t *)(*(_QWORD *)&v13 + 8 * v11);
        else
          v14 = vadd_f32(vmul_n_f32(this[7], *(float *)&v28), *(float32x2_t *)(*(_QWORD *)&v13 + 8 * v11));
        v15 = vmul_n_f32(v14, *(float *)&a2);
        *(float32x2_t *)(*(_QWORD *)&v13 + 8 * v11) = v15;
        v12 = this[1];
        a5 = *(double *)(*(_QWORD *)&v12 + 8 * v11);
        a4 = COERCE_DOUBLE(vadd_f32(vmul_n_f32(v15, *(float *)&v28), *(float32x2_t *)&a5));
        *(double *)(*(_QWORD *)&v12 + 8 * v11++) = a4;
        v10 = this->i32[0];
      }
      while (v11 < v10);
    }
    if (a3 >= 1)
    {
      do
      {
        b2Rope::SolveC2((uint64_t)this, a2, a4, a5, a6, a7, a8);
        b2Rope::SolveC3((b2Rope *)this);
        b2Rope::SolveC2((uint64_t)this, v16, v17, v18, v19, v20, v21);
        --a3;
      }
      while (a3);
      LODWORD(v10) = this->i32[0];
      LODWORD(a6) = LODWORD(v28);
    }
    if ((int)v10 >= 1)
    {
      v22 = (float32x2_t *)this[1];
      v23 = (float32x2_t *)this[2];
      v24 = (float32x2_t *)this[3];
      v10 = v10;
      do
      {
        v25 = *v22++;
        v26 = v25;
        v27 = *v23++;
        *v24++ = vmul_n_f32(vsub_f32(v26, v27), 1.0 / *(float *)&a6);
        --v10;
      }
      while (v10);
    }
  }
}

uint64_t b2Rope::SolveC2(uint64_t this, double a2, double a3, double a4, double a5, double a6, int32x4_t a7)
{
  uint64_t v7;
  float32x2_t *v8;
  uint64_t v9;
  float32x2_t *v10;
  uint64_t v11;
  float32x4_t v12;
  uint64_t v13;
  unint64_t v14;
  float32x4_t v15;
  float32x2_t v16;
  float32x4_t v17;
  int8x16_t v18;

  if (*(int *)this >= 2)
  {
    v7 = 0;
    v8 = *(float32x2_t **)(this + 8);
    v9 = *(_QWORD *)(this + 32);
    v11 = (uint64_t)*v8;
    v10 = v8 + 1;
    v12.i64[0] = v11;
    v13 = 4 * (*(_DWORD *)this - 1);
    do
    {
      v14 = (unint64_t)*v10;
      *(float32x2_t *)v15.f32 = vsub_f32(*v10, *(float32x2_t *)v12.f32);
      *(float *)a7.i32 = sqrtf(vmlas_n_f32(COERCE_FLOAT(vmul_f32(*(float32x2_t *)&v15, *(float32x2_t *)&v15).i32[1]), v15.f32[0], v15.f32[0]));
      if (*(float *)a7.i32 >= 0.00000011921)
        *(float32x2_t *)v15.f32 = vmul_n_f32(*(float32x2_t *)v15.f32, 1.0 / *(float *)a7.i32);
      else
        a7.i32[0] = 0;
      v16 = *(float32x2_t *)(v9 + v7);
      if (vaddv_f32(v16) != 0.0)
      {
        v15.i64[1] = v15.i64[0];
        *(float32x2_t *)a7.i8 = vmul_n_f32(vmul_n_f32(vdiv_f32(v16, (float32x2_t)vdup_lane_s32((int32x2_t)vadd_f32(v16, (float32x2_t)vdup_lane_s32((int32x2_t)v16, 1)), 0)), *(float *)(this + 68)), *(float *)(*(_QWORD *)(this + 40) + v7) - *(float *)a7.i32);
        a7 = vzip1q_s32(a7, a7);
        v17 = vmulq_f32(v15, (float32x4_t)a7);
        *(float32x2_t *)&v12.u32[2] = *v10;
        v18.i64[0] = vsubq_f32(v12, v17).u64[0];
        v18.i64[1] = vaddq_f32(v12, v17).i64[1];
        *(int8x16_t *)v10[-1].f32 = v18;
        v14 = vextq_s8(v18, v18, 8uLL).u64[0];
      }
      v7 += 4;
      ++v10;
      v12.i64[0] = v14;
    }
    while (v13 != v7);
  }
  return this;
}

void b2Rope::SolveC3(b2Rope *this)
{
  uint64_t v2;
  uint64_t v3;
  float *v4;
  uint64_t v5;
  float v6;
  float v7;
  float v8;
  float v9;
  float v10;
  float v11;
  uint64_t v12;
  float *v13;
  float v14;
  float v15;
  float v16;
  float v17;
  float v18;
  float v19;
  float v20;
  float v21;
  float v22;
  float v23;
  float v24;
  float v25;
  float v26;
  float v27;
  float v28;
  float v29;
  float v30;
  float v31;
  float v32;
  float v33;
  float v34;
  float i;
  float *v36;
  float *v37;
  float v38;
  float v39;
  float v40;
  float v41;
  float v42;
  float v43;
  float v44;
  float v45;
  float v46;
  float v47;
  float v48;
  float v49;

  if (*(int *)this >= 3)
  {
    v2 = 0;
    v3 = (*(_DWORD *)this - 2);
    v4 = (float *)*((_QWORD *)this + 1);
    v5 = *((_QWORD *)this + 4);
    v7 = *v4;
    v6 = v4[1];
    v9 = v4[2];
    v8 = v4[3];
    v10 = -1.0;
    v11 = 1.0;
    do
    {
      v12 = v2 + 1;
      v13 = &v4[2 * v2 + 4];
      v14 = *v13;
      v15 = v13[1];
      v16 = v9 - v7;
      v17 = v8 - v6;
      v18 = *v13 - v9;
      v19 = v15 - v8;
      v20 = (float)(v17 * v17) + (float)(v16 * v16);
      v21 = (float)(v19 * v19) + (float)(v18 * v18);
      if ((float)(v20 * v21) != 0.0)
      {
        v22 = *(float *)(v5 + 4 * v2);
        v23 = *(float *)(v5 + 4 * v12);
        v24 = *(float *)(v5 + 4 * (v2 + 2));
        v25 = v10 / v20;
        v26 = -(float)(v17 * v25);
        v27 = v16 * v25;
        v28 = v11 / v21;
        v29 = -(float)(v19 * v28);
        v30 = v26 - v29;
        v31 = (float)(v16 * v25) - (float)(v18 * v28);
        v32 = (float)((float)(v18 * v28) * (float)(v18 * v28)) + (float)(v29 * v29);
        if ((float)((float)((float)(v23 * (float)((float)(v31 * v31) + (float)(v30 * v30)))
                           + (float)(v22 * (float)((float)(v27 * v27) + (float)(v26 * v26))))
                   + (float)(v24 * v32)) != 0.0)
        {
          v42 = (float)((float)(v23 * (float)((float)(v31 * v31) + (float)(v30 * v30)))
                      + (float)(v22 * (float)((float)(v27 * v27) + (float)(v26 * v26))))
              + (float)(v24 * v32);
          v43 = v31;
          v44 = v26 - v29;
          v45 = *(float *)(v5 + 4 * v2);
          v46 = v18 * v28;
          v47 = -(float)(v19 * v28);
          v48 = *(float *)(v5 + 4 * v12);
          v49 = *(float *)(v5 + 4 * (v2 + 2));
          v33 = atan2f((float)(v18 * (float)-v17) + (float)(v16 * v19), (float)(v17 * v19) + (float)(v16 * v18));
          v34 = *(float *)(*((_QWORD *)this + 6) + 4 * v2);
          for (i = v33 - v34; i > 3.1416; i = v33 - v34)
            v33 = v33 + -6.2832;
          v11 = 1.0;
          if (i < -3.1416)
          {
            do
            {
              v33 = v33 + 6.2832;
              i = v33 - v34;
            }
            while ((float)(v33 - v34) < -3.1416);
          }
          v36 = &v4[2 * v2];
          v37 = &v4[2 * v12];
          v38 = i * (float)-(float)(*((float *)this + 18) * (float)(1.0 / v42));
          v39 = v7 - (float)(v26 * (float)(v45 * v38));
          v40 = v6 - (float)(v27 * (float)(v45 * v38));
          v9 = v9 + (float)(v44 * (float)(v48 * v38));
          v8 = v8 + (float)(v43 * (float)(v48 * v38));
          v41 = v49 * v38;
          v14 = v14 + (float)(v47 * v41);
          *v36 = v39;
          v36[1] = v40;
          *v37 = v9;
          v37[1] = v8;
          v15 = v15 + (float)(v46 * v41);
          *v13 = v14;
          v13[1] = v15;
          v10 = -1.0;
        }
      }
      v7 = v9;
      v6 = v8;
      v8 = v15;
      v9 = v14;
      ++v2;
    }
    while (v12 != v3);
  }
}

uint64_t b2Rope::SetAngle(uint64_t this, float a2)
{
  uint64_t v2;
  float *v3;

  if (*(int *)this >= 3)
  {
    v2 = (*(_DWORD *)this - 2);
    v3 = *(float **)(this + 48);
    do
    {
      *v3++ = a2;
      --v2;
    }
    while (v2);
  }
  return this;
}

int *b2Rope::Draw(int *this, b2Draw *a2)
{
  int *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int v7;

  v6 = 0x3F0000003ECCCCCDLL;
  v7 = 1060320051;
  if (*this >= 2)
  {
    v3 = this;
    v4 = 0;
    v5 = 0;
    do
    {
      ++v5;
      this = (int *)(*(uint64_t (**)(b2Draw *, uint64_t, uint64_t, uint64_t *))(*(_QWORD *)a2 + 48))(a2, *((_QWORD *)v3 + 1) + v4, *((_QWORD *)v3 + 1) + v4 + 8, &v6);
      v4 += 8;
    }
    while (v5 < *v3 - 1);
  }
  return this;
}

BOOL triangleDoesNotContainOtherPoints(_QWORD *a1, float32x2_t a2, float32x2_t a3, float32x2_t a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  BOOL v7;
  unint64_t v8;
  uint64_t v12;
  float32x2_t v13;
  float32x2_t v14;
  float32x2_t v15;
  float32x2_t v16;
  _BOOL4 v24;

  v4 = a1[1];
  v5 = v4 - *a1;
  if (v4 == *a1)
  {
    return 1;
  }
  else
  {
    v6 = 0;
    v7 = 0;
    v8 = v5 >> 3;
    _S3 = vsub_f32(a3, a2).u32[0];
    _S5 = vsub_f32(a4, a2).u32[0];
    _S7 = vsub_f32(a4, a3).u32[0];
    if (v8 <= 1)
      v12 = 1;
    else
      v12 = v8;
    do
    {
      v13 = *(float32x2_t *)(*a1 + 8 * v6);
      v14 = vsub_f32(a2, v13);
      if (fabsf(v14.f32[0]) > 0.0001 || fabsf(v14.f32[1]) > 0.0001)
      {
        v15 = vsub_f32(a3, v13);
        if (fabsf(v15.f32[0]) > 0.0001 || fabsf(v15.f32[1]) > 0.0001)
        {
          v16 = vsub_f32(a4, v13);
          if (fabsf(v16.f32[0]) > 0.0001 || fabsf(v16.f32[1]) > 0.0001)
          {
            _D20 = vsub_f32(v13, a2);
            __asm
            {
              FMLA            S19, S3, V20.S[1]
              FMLA            S21, S5, V20.S[1]
            }
            if (_S19 > 0.0 == _S21 <= 0.0)
            {
              v24 = _S19 > 0.0;
              _D18 = vsub_f32(v13, a3);
              __asm { FMLA            S19, S7, V18.S[1] }
              if (((v24 ^ (_S19 <= 0.0)) & 1) != 0)
                break;
            }
          }
        }
      }
      v7 = v8 <= ++v6;
    }
    while (v12 != v6);
  }
  return v7;
}

BOOL validConvexPolygon(int a1, int a2, uint64_t *a3, _QWORD *a4)
{
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  int v7;
  int v8;
  int v11;
  unint64_t v12;
  uint64_t v13;
  float32x2_t v14;
  float32x2_t v15;
  float32x2_t v16;
  unint64_t v17;
  float32x2_t v18;
  float32x2_t v19;
  float32x2_t v20;
  uint64_t v21;
  float32x2_t v22;
  float32x2_t v23;
  float32x2_t v25;
  float32x2_t v26;
  float32x2_t v27;
  float32x2_t v28;
  float32x2_t v29;

  v4 = *a3;
  v5 = (a3[1] - *a3) >> 3;
  v6 = ((int)v5 + a1) % v5;
  v7 = ((int)v5 + a2) % v5;
  if ((int)v6 <= v7)
    v8 = ((int)v5 + a2) % v5;
  else
    v8 = v5 + v7;
  if (v8 - (int)v6 + 1 < 3)
    return 0;
  v11 = v6 + 1;
  if ((int)v6 + 1 < v8)
  {
    v12 = v11;
    do
    {
      v13 = (v12 % v5) + v5;
      v14 = *(float32x2_t *)(v4 + ((uint64_t)((v12 % v5) << 32) >> 29));
      v15 = vsub_f32(*(float32x2_t *)(v4 + 8 * (int)((((v13 << 32) - 0x100000000) >> 32) % v5)), v14);
      v16 = vsub_f32(*(float32x2_t *)(v4 + 8 * (int)((((v13 << 32) + 0x100000000) >> 32) % v5)), v14);
      if (vmlas_n_f32((float)-v15.f32[1] * v16.f32[0], v16.f32[1], v15.f32[0]) >= 0.0)
        return 0;
    }
    while ((uint64_t)++v12 < v8);
  }
  if ((int)v6 + 2 <= v8)
  {
    v18 = *(float32x2_t *)(v4 + 8 * (int)v6);
    v19 = *(float32x2_t *)(v4 + 8 * (int)(v11 % v5));
    v20 = vsub_f32(v19, v18);
    v21 = (int)v6 + 2;
    v17 = v8;
    while (1)
    {
      v22 = *(float32x2_t *)(v4 + 8 * (int)(v21 % v5));
      v23 = vsub_f32(v22, v18);
      if (vmlas_n_f32(-(float)(v23.f32[1] * v20.f32[0]), v20.f32[1], v23.f32[0]) >= 0.0
        || !triangleDoesNotContainOtherPoints(a4, v19, v18, v22))
      {
        return 0;
      }
      if (v21++ >= v8)
        goto LABEL_16;
    }
  }
  v17 = v8;
LABEL_16:
  v25 = *(float32x2_t *)(v4 + 8 * (int)(v17 % v5));
  v26 = *(float32x2_t *)(v4 + 8 * (int)(((int)v5 + v8 - 1) % v5));
  v27 = *(float32x2_t *)(v4 + 8 * (int)(((int)v5 + (int)v6) % v5));
  v28 = vsub_f32(v26, v25);
  v29 = vsub_f32(v27, v25);
  if (vmlas_n_f32((float)-v28.f32[1] * v29.f32[0], v29.f32[1], v28.f32[0]) >= 0.0)
    return 0;
  return triangleDoesNotContainOtherPoints(a4, v26, v25, v27);
}

uint64_t trisFromCCWFaces(uint64_t a1, char **a2, void **a3)
{
  char *v6;
  _BYTE *v7;
  _QWORD *v8;
  unint64_t v9;
  char *v10;
  unint64_t v11;
  float32x2_t v12;
  float32x2_t v13;
  float32x2_t v14;
  char *v15;
  char *v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  unint64_t v20;
  char *v21;
  char *v22;
  int v23;
  uint64_t v24;
  unint64_t v25;
  unint64_t v26;
  unint64_t v27;
  _DWORD *v28;
  _DWORD *v29;
  int v30;
  uint64_t v31;
  uint64_t v32;
  int v33;
  uint64_t v34;
  int v35;
  uint64_t v36;
  _BOOL4 valid;
  unint64_t v38;
  int v39;
  unint64_t v40;
  uint64_t v41;
  int v42;
  int v43;
  uint64_t v44;
  int v45;
  int v46;
  int v47;
  _DWORD *v49;
  uint64_t v50;
  unint64_t v51;
  uint64_t v52;
  unint64_t v53;
  char *v54;
  char *v55;
  int v56;
  uint64_t v57;
  char *v58;
  uint64_t v59;
  _QWORD *v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  unint64_t v64;
  char *v65;
  char *v66;
  char *v67;
  char *v68;
  uint64_t v69;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  char *__p;
  char *v77;
  char *v78;
  void *v79;
  char *v80;
  uint64_t v81;

  v79 = 0;
  v80 = 0;
  v81 = 0;
  _ZNSt3__16vectorIDv2_fNS_9allocatorIS1_EEE16__init_with_sizeB8ne180100IPS1_S6_EEvT_T0_m(&v79, *(const void **)a1, *(_QWORD *)(a1 + 8), (uint64_t)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 3);
  v6 = (char *)v79;
  v7 = v80;
  if ((unint64_t)(v80 - (_BYTE *)v79) >= 0x11)
  {
    v73 = (uint64_t)(a3 + 2);
    v8 = a2 + 2;
    v75 = (uint64_t)a3;
    while (1)
    {
      __p = 0;
      v77 = 0;
      v78 = 0;
      v9 = (v7 - v6) >> 3;
      if (v7 == v6)
        break;
      v10 = 0;
      v11 = 0;
      do
      {
        v12 = *(float32x2_t *)&v6[8 * v11];
        v13 = vsub_f32(*(float32x2_t *)&v6[8 * (int)(((int)v11 + (int)v9 - 1) % v9)], v12);
        v14 = vsub_f32(*(float32x2_t *)&v6[8 * (int)(((int)v11 + (int)v9 + 1) % v9)], v12);
        if (vmlas_n_f32((float)-v13.f32[1] * v14.f32[0], v14.f32[1], v13.f32[0]) >= 0.0)
        {
          if (v10 >= v78)
          {
            v16 = __p;
            v17 = (v10 - __p) >> 2;
            v18 = v17 + 1;
            if ((unint64_t)(v17 + 1) >> 62)
              std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
            v19 = v78 - __p;
            if ((v78 - __p) >> 1 > v18)
              v18 = v19 >> 1;
            if ((unint64_t)v19 >= 0x7FFFFFFFFFFFFFFCLL)
              v20 = 0x3FFFFFFFFFFFFFFFLL;
            else
              v20 = v18;
            if (v20)
            {
              v21 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<int>>((uint64_t)&v78, v20);
              v16 = __p;
              v10 = v77;
            }
            else
            {
              v21 = 0;
            }
            v22 = &v21[4 * v17];
            *(_DWORD *)v22 = v11;
            v15 = v22 + 4;
            while (v10 != v16)
            {
              v23 = *((_DWORD *)v10 - 1);
              v10 -= 4;
              *((_DWORD *)v22 - 1) = v23;
              v22 -= 4;
            }
            __p = v22;
            v78 = &v21[4 * v20];
            if (v16)
              operator delete(v16);
          }
          else
          {
            *(_DWORD *)v10 = v11;
            v15 = v10 + 4;
          }
          v77 = v15;
          v10 = v15;
          v6 = (char *)v79;
          v7 = v80;
        }
        ++v11;
        v9 = (v7 - v6) >> 3;
      }
      while (v9 > v11);
      v24 = v10 - __p;
      if (v10 == __p)
        break;
      v25 = v24 >> 2;
      if (v24 >> 2 == v9)
      {
        v26 = (unint64_t)(a2[1] - *a2) >> 3;
        v28 = a3[1];
        v27 = (unint64_t)a3[2];
        if ((unint64_t)v28 >= v27)
        {
          v49 = *a3;
          v50 = ((char *)v28 - (_BYTE *)*a3) >> 2;
          v51 = v50 + 1;
          if ((unint64_t)(v50 + 1) >> 62)
            std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
          v52 = v27 - (_QWORD)v49;
          if (v52 >> 1 > v51)
            v51 = v52 >> 1;
          if ((unint64_t)v52 >= 0x7FFFFFFFFFFFFFFCLL)
            v53 = 0x3FFFFFFFFFFFFFFFLL;
          else
            v53 = v51;
          if (v53)
          {
            v54 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<int>>(v73, v53);
            v49 = *a3;
            v28 = a3[1];
          }
          else
          {
            v54 = 0;
          }
          v55 = &v54[4 * v50];
          *(_DWORD *)v55 = v26;
          v29 = v55 + 4;
          while (v28 != v49)
          {
            v56 = *--v28;
            *((_DWORD *)v55 - 1) = v56;
            v55 -= 4;
          }
          *a3 = v55;
          a3[1] = v29;
          a3[2] = &v54[4 * v53];
          if (v49)
            operator delete(v49);
        }
        else
        {
          *v28 = v26;
          v29 = v28 + 1;
        }
        a3[1] = v29;
        if ((int)((unint64_t)(v80 - (_BYTE *)v79) >> 3) < 1)
          goto LABEL_29;
        v57 = ((unint64_t)(v80 - (_BYTE *)v79) >> 3);
        v58 = a2[1];
        do
        {
          v59 = (v57 - 1);
          v60 = v79;
          if ((unint64_t)v58 >= *v8)
          {
            v61 = (v58 - *a2) >> 3;
            if ((unint64_t)(v61 + 1) >> 61)
              std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
            v62 = *v8 - (_QWORD)*a2;
            v63 = v62 >> 2;
            if (v62 >> 2 <= (unint64_t)(v61 + 1))
              v63 = v61 + 1;
            if ((unint64_t)v62 >= 0x7FFFFFFFFFFFFFF8)
              v64 = 0x1FFFFFFFFFFFFFFFLL;
            else
              v64 = v63;
            if (v64)
              v65 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKPoint>>((uint64_t)(a2 + 2), v64);
            else
              v65 = 0;
            v66 = &v65[8 * v61];
            *(_QWORD *)v66 = v60[v59];
            v58 = v66 + 8;
            v68 = *a2;
            v67 = a2[1];
            if (v67 != *a2)
            {
              do
              {
                v69 = *((_QWORD *)v67 - 1);
                v67 -= 8;
                *((_QWORD *)v66 - 1) = v69;
                v66 -= 8;
              }
              while (v67 != v68);
              v67 = *a2;
            }
            *a2 = v66;
            a2[1] = v58;
            a2[2] = &v65[8 * v64];
            if (v67)
              operator delete(v67);
          }
          else
          {
            *(_QWORD *)v58 = *((_QWORD *)v79 + v59);
            v58 += 8;
          }
          a2[1] = v58;
        }
        while (v57-- > 1);
        v30 = 1;
LABEL_94:
        a3 = (void **)v75;
      }
      else
      {
        if ((unint64_t)v24 >= 5)
        {
          v31 = 0;
          while (1)
          {
            if (v25 == v31)
              goto LABEL_36;
            v32 = v31 + 1;
            v33 = *(_DWORD *)&__p[4 * v31];
            v34 = v33;
            v35 = *(_DWORD *)&__p[4 * ((v31 + 1) % v25)];
            v36 = v35;
            if (validConvexPolygon(v33, v35, (uint64_t *)&v79, (_QWORD *)a1))
              break;
            valid = validConvexPolygon(v36, v34, (uint64_t *)&v79, (_QWORD *)a1);
            v31 = v32;
            if (valid)
            {
              emitConvexBodyInclusive(v36, v34, (uint64_t *)&v79, a2, v75);
              v38 = ((v36 + 1) % (unint64_t)((v80 - (_BYTE *)v79) >> 3));
              v39 = v34 - 1;
LABEL_93:
              erasePointsInclusive((void *)v38, v39, (char **)&v79);
              v30 = 2;
              goto LABEL_94;
            }
          }
          emitConvexBodyInclusive(v34, v36, (uint64_t *)&v79, a2, v75);
          v38 = ((v34 + 1) % (unint64_t)((v80 - (_BYTE *)v79) >> 3));
          v39 = v36 - 1;
          goto LABEL_93;
        }
LABEL_36:
        v40 = 0;
        if (v25 <= 1)
          v41 = 1;
        else
          v41 = v25;
        v74 = v41;
        do
        {
          v42 = *(_DWORD *)&__p[4 * v40++];
          if (*(int *)&__p[4 * (v40 % v25)] <= 3)
            v43 = 3;
          else
            v43 = *(_DWORD *)&__p[4 * (v40 % v25)];
          while (v43 >= 3)
          {
            if (validConvexPolygon(v42, --v43 + v42, (uint64_t *)&v79, (_QWORD *)a1))
            {
              a3 = (void **)v75;
              emitConvexBodyInclusive(v42, v42 + v43, (uint64_t *)&v79, a2, v75);
              erasePointsInclusive((void *)((int)(((v80 - (_BYTE *)v79) >> 3) + v42 + 1)% (unint64_t)((v80 - (_BYTE *)v79) >> 3)), (int)(((v80 - (_BYTE *)v79) >> 3) + v42 + v43 - 1) % (unint64_t)((v80 - (_BYTE *)v79) >> 3), (char **)&v79);
              v30 = 2;
              goto LABEL_95;
            }
          }
        }
        while (v40 != v74);
        v44 = 0;
        do
        {
          v45 = *(_DWORD *)&__p[4 * v44];
          v72 = v44;
          if (*(int *)&__p[4 * ((v44 - 1) % v25)] <= 3)
            v46 = 3;
          else
            v46 = *(_DWORD *)&__p[4 * ((v44 - 1) % v25)];
          v47 = 1 - v46;
          while (v46 >= 3)
          {
            --v46;
            if (validConvexPolygon(v45 + v47++, v45, (uint64_t *)&v79, (_QWORD *)a1))
            {
              a3 = (void **)v75;
              emitConvexBodyInclusive(v45 - v46, v45, (uint64_t *)&v79, a2, v75);
              erasePointsInclusive((void *)((int)(((v80 - (_BYTE *)v79) >> 3) + v45 - v46 + 1)% (unint64_t)((v80 - (_BYTE *)v79) >> 3)), (int)(((v80 - (_BYTE *)v79) >> 3) + v45 - 1) % (unint64_t)((v80 - (_BYTE *)v79) >> 3), (char **)&v79);
              v30 = 0;
              goto LABEL_95;
            }
          }
          v44 = v72 + 1;
          v30 = 3;
          a3 = (void **)v75;
        }
        while (v72 + 1 != v74);
      }
LABEL_95:
      if (__p)
        operator delete(__p);
      if ((v30 | 2) != 2)
      {
        v6 = (char *)v79;
        goto LABEL_101;
      }
      v6 = (char *)v79;
      v7 = v80;
      if ((unint64_t)(v80 - (_BYTE *)v79) <= 0x10)
        goto LABEL_101;
    }
    emitConvexBodyInclusive(0, v9 - 1, (uint64_t *)&v79, a2, (uint64_t)a3);
LABEL_29:
    v30 = 1;
    goto LABEL_95;
  }
LABEL_101:
  if (v6)
  {
    v80 = v6;
    operator delete(v6);
  }
  return 1;
}

void sub_208FCEFF8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, uint64_t a15, void *a16, uint64_t a17)
{
  if (__p)
    operator delete(__p);
  if (a16)
    operator delete(a16);
  _Unwind_Resume(exception_object);
}

void emitConvexBodyInclusive(int a1, int a2, uint64_t *a3, char **a4, uint64_t a5)
{
  unint64_t v10;
  unint64_t v11;
  _DWORD *v12;
  _DWORD *v13;
  _DWORD *v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;
  unint64_t v18;
  char *v19;
  char *v20;
  char *v21;
  int v22;
  unint64_t v23;
  unint64_t v24;
  int v25;
  int v26;
  _QWORD *v27;
  uint64_t v28;
  uint64_t v29;
  char *v30;
  uint64_t v31;
  unint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  unint64_t v36;
  char *v37;
  char *v38;
  char *v39;
  char *v40;
  uint64_t v41;

  v10 = (unint64_t)(a4[1] - *a4) >> 3;
  v11 = *(_QWORD *)(a5 + 16);
  v12 = *(_DWORD **)(a5 + 8);
  if ((unint64_t)v12 >= v11)
  {
    v14 = *(_DWORD **)a5;
    v15 = ((uint64_t)v12 - *(_QWORD *)a5) >> 2;
    v16 = v15 + 1;
    if ((unint64_t)(v15 + 1) >> 62)
      std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
    v17 = v11 - (_QWORD)v14;
    if (v17 >> 1 > v16)
      v16 = v17 >> 1;
    if ((unint64_t)v17 >= 0x7FFFFFFFFFFFFFFCLL)
      v18 = 0x3FFFFFFFFFFFFFFFLL;
    else
      v18 = v16;
    if (v18)
    {
      v19 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<int>>(a5 + 16, v18);
      v14 = *(_DWORD **)a5;
      v12 = *(_DWORD **)(a5 + 8);
    }
    else
    {
      v19 = 0;
    }
    v20 = &v19[4 * v15];
    v21 = &v19[4 * v18];
    *(_DWORD *)v20 = v10;
    v13 = v20 + 4;
    while (v12 != v14)
    {
      v22 = *--v12;
      *((_DWORD *)v20 - 1) = v22;
      v20 -= 4;
    }
    *(_QWORD *)a5 = v20;
    *(_QWORD *)(a5 + 8) = v13;
    *(_QWORD *)(a5 + 16) = v21;
    if (v14)
      operator delete(v14);
  }
  else
  {
    *v12 = v10;
    v13 = v12 + 1;
  }
  *(_QWORD *)(a5 + 8) = v13;
  v23 = (a3[1] - *a3) >> 3;
  v24 = ((int)v23 + a1) % v23;
  v25 = ((int)v23 + a2) % v23;
  if ((int)v24 <= v25)
    LODWORD(v23) = 0;
  v26 = v23 + v25;
  if (v26 >= (int)v24)
  {
    v27 = a4 + 2;
    v28 = (int)v24;
    v29 = v26;
    v30 = a4[1];
    do
    {
      v31 = *a3;
      v32 = v28 % (unint64_t)((a3[1] - *a3) >> 3);
      if ((unint64_t)v30 >= *v27)
      {
        v33 = (v30 - *a4) >> 3;
        if ((unint64_t)(v33 + 1) >> 61)
          std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
        v34 = *v27 - (_QWORD)*a4;
        v35 = v34 >> 2;
        if (v34 >> 2 <= (unint64_t)(v33 + 1))
          v35 = v33 + 1;
        if ((unint64_t)v34 >= 0x7FFFFFFFFFFFFFF8)
          v36 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v36 = v35;
        if (v36)
          v37 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKPoint>>((uint64_t)(a4 + 2), v36);
        else
          v37 = 0;
        v38 = &v37[8 * v33];
        *(_QWORD *)v38 = *(_QWORD *)(v31 + 8 * v32);
        v30 = v38 + 8;
        v40 = *a4;
        v39 = a4[1];
        if (v39 != *a4)
        {
          do
          {
            v41 = *((_QWORD *)v39 - 1);
            v39 -= 8;
            *((_QWORD *)v38 - 1) = v41;
            v38 -= 8;
          }
          while (v39 != v40);
          v39 = *a4;
        }
        *a4 = v38;
        a4[1] = v30;
        a4[2] = &v37[8 * v36];
        if (v39)
          operator delete(v39);
      }
      else
      {
        *(_QWORD *)v30 = *(_QWORD *)(v31 + 8 * v32);
        v30 += 8;
      }
      a4[1] = v30;
    }
    while (v28++ < v29);
  }
}

void *erasePointsInclusive(void *result, int a2, char **a3)
{
  char *v4;
  char *v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;
  char *v10;
  uint64_t v11;
  char *v12;

  v5 = *a3;
  v4 = a3[1];
  v6 = (v4 - *a3) >> 3;
  v7 = ((int)v6 + (int)result) % v6;
  v8 = ((int)v6 + a2) % v6;
  v9 = (uint64_t)&(*a3)[8 * (int)v7];
  if ((int)v7 <= (int)v8)
  {
    v10 = &v5[8 * (int)v8 + 8];
    if ((char *)v9 == v10)
      return result;
    v11 = v4 - v10;
    if (v4 != v10)
      result = memmove(&(*a3)[8 * (int)v7], v10, v4 - v10);
    goto LABEL_12;
  }
  if ((char *)v9 == v4)
    v9 = (uint64_t)a3[1];
  else
    a3[1] = (char *)v9;
  v12 = &v5[8 * (int)v8 + 8];
  if (v5 != v12)
  {
    v11 = v9 - (_QWORD)v12;
    if ((char *)v9 != v12)
      result = memmove(v5, v12, v9 - (_QWORD)v12);
    v9 = (uint64_t)v5;
LABEL_12:
    a3[1] = (char *)(v9 + v11);
  }
  return result;
}

_QWORD *_ZNSt3__16vectorIDv2_fNS_9allocatorIS1_EEE16__init_with_sizeB8ne180100IPS1_S6_EEvT_T0_m(_QWORD *result, const void *a2, uint64_t a3, unint64_t a4)
{
  _QWORD *v6;
  uint64_t v7;
  size_t v8;

  if (a4)
  {
    v6 = result;
    result = std::vector<PKPoint>::__vallocate[abi:ne180100](result, a4);
    v7 = v6[1];
    v8 = a3 - (_QWORD)a2;
    if (v8)
      result = memmove((void *)v6[1], a2, v8);
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_208FCF3BC(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void PKPath::PKPath(PKPath *this, const CGPath *a2)
{
  const CGPath *v3;
  _BYTE info[4];
  uint64_t v5;
  PKPath *v6;

  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 2) = 0;
  *((_QWORD *)this + 3) = 0;
  v3 = (const CGPath *)MEMORY[0x20BD0B914](a2);
  *((_QWORD *)this + 4) = v3;
  v6 = this;
  info[0] = 0;
  v5 = 0x3F8000000000000FLL;
  CGPathApply(v3, info, (CGPathApplierFunction)PKPathApplyCGPath);
}

void sub_208FCF4A0(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void **v2;
  void *v4;

  v4 = *v2;
  if (*v2)
  {
    *(_QWORD *)(v1 + 16) = v4;
    operator delete(v4);
  }
  _Unwind_Resume(exception_object);
}

void PKPathApplyCGPath(_QWORD *a1, const CGPathElement *a2, float32x2_t a3)
{
  uint64_t v5;
  float *v6;
  void **v7;
  float *v8;
  CGPathElementType type;
  BOOL v10;
  uint64_t v11;
  float v12;
  float v13;
  int v14;
  int v15;
  float v16;
  int v17;
  float v18;
  float v19;
  float v20;
  float v21;
  int v22;
  int v23;
  float32x2_t v24;
  float v25;
  unsigned __int32 v26;
  float v27;
  float v28;
  float v29;
  unint64_t v30;
  float *v31;
  uint64_t v32;
  unint64_t v33;
  uint64_t v34;
  unint64_t v35;
  char *v36;
  float *v37;
  float *v38;
  uint64_t v39;
  CGPoint *points;
  float x;
  float y;
  unint64_t v43;
  float *v44;
  uint64_t v45;
  uint64_t v46;
  unint64_t v47;
  float *v48;
  char *v49;
  char *v50;
  uint64_t v51;
  float *v52;
  uint64_t v53;
  float v54;
  float v55;
  unint64_t v56;
  float *v57;
  float32x2_t v58;
  unint64_t v59;
  float *v60;
  unint64_t v61;
  uint64_t v62;
  unint64_t v63;
  char *v64;
  unint64_t v65;
  uint64_t v66;
  unint64_t v67;
  char *v68;
  float *v69;
  uint64_t v70;
  float32x2_t *v71;
  float32x2_t v72;
  float32x2_t v73;

  if (!a1 || *(_BYTE *)a1)
    return;
  v5 = a1[2];
  v7 = (void **)(v5 + 8);
  v6 = *(float **)(v5 + 8);
  v8 = *(float **)(v5 + 16);
  type = a2->type;
  v10 = v6 == v8 && type == kCGPathElementMoveToPoint;
  if (v10)
  {
    points = a2->points;
    x = points->x;
    y = points->y;
    v43 = *(_QWORD *)(v5 + 24);
    if ((unint64_t)v6 >= v43)
    {
      v45 = v43 - (_QWORD)v6;
      v46 = v45 >> 2;
      if ((unint64_t)(v45 >> 2) <= 1)
        v46 = 1;
      if ((unint64_t)v45 >= 0x7FFFFFFFFFFFFFF8)
        v47 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v47 = v46;
      v48 = (float *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKPoint>>(v5 + 24, v47);
      v49 = *(char **)(v5 + 8);
      v50 = *(char **)(v5 + 16);
      v52 = &v48[2 * v51];
      *v48 = x;
      v48[1] = y;
      v44 = v48 + 2;
      if (v50 != v49)
      {
        do
        {
          v53 = *((_QWORD *)v50 - 1);
          v50 -= 8;
          *((_QWORD *)v48 - 1) = v53;
          v48 -= 2;
        }
        while (v50 != v49);
        v49 = (char *)*v7;
      }
      *(_QWORD *)(v5 + 8) = v48;
      *(_QWORD *)(v5 + 16) = v44;
      *(_QWORD *)(v5 + 24) = v52;
      if (v49)
        operator delete(v49);
    }
    else
    {
      *v6 = x;
      v6[1] = y;
      v44 = v6 + 2;
    }
    *(_QWORD *)(v5 + 16) = v44;
    *(_DWORD *)a1[2] = 0;
    return;
  }
  v11 = ((char *)v8 - (char *)v6) >> 3;
  v13 = *(v8 - 2);
  v12 = *(v8 - 1);
  switch(type)
  {
    case kCGPathElementCloseSubpath:
      v54 = *v6;
      v55 = v6[1];
      v56 = *(_QWORD *)(v5 + 24);
      if ((unint64_t)v8 >= v56)
      {
        v61 = v11 + 1;
        if ((unint64_t)(v11 + 1) >> 61)
          goto LABEL_85;
        v62 = v56 - (_QWORD)v6;
        if (v62 >> 2 > v61)
          v61 = v62 >> 2;
        if ((unint64_t)v62 >= 0x7FFFFFFFFFFFFFF8)
          v63 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v63 = v61;
        if (v63)
        {
          v64 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKPoint>>(v5 + 24, v63);
          v6 = *(float **)(v5 + 8);
          v8 = *(float **)(v5 + 16);
        }
        else
        {
          v64 = 0;
        }
        v69 = (float *)&v64[8 * v11];
        *v69 = v54;
        v69[1] = v55;
        v57 = v69 + 2;
        if (v8 != v6)
        {
          do
          {
            v70 = *((_QWORD *)v8 - 1);
            v8 -= 2;
            *((_QWORD *)v69 - 1) = v70;
            v69 -= 2;
          }
          while (v8 != v6);
          v6 = (float *)*v7;
        }
        *(_QWORD *)(v5 + 8) = v69;
        *(_QWORD *)(v5 + 16) = v57;
        *(_QWORD *)(v5 + 24) = &v64[8 * v63];
        if (v6)
          operator delete(v6);
      }
      else
      {
        *v8 = v54;
        v8[1] = v55;
        v57 = v8 + 2;
      }
      *(_QWORD *)(v5 + 16) = v57;
      *(float *)a1[2] = sqrtf((float)((float)(v55 - v12) * (float)(v55 - v12))+ (float)((float)(v54 - v13) * (float)(v54 - v13)))+ *(float *)a1[2];
      goto LABEL_76;
    case kCGPathElementAddLineToPoint:
      v58 = vcvt_f32_f64(*(float64x2_t *)a2->points);
      v59 = *(_QWORD *)(v5 + 24);
      if ((unint64_t)v8 < v59)
      {
        *(float32x2_t *)v8 = v58;
        v60 = v8 + 2;
LABEL_83:
        *(_QWORD *)(v5 + 16) = v60;
        *(float *)a1[2] = sqrtf((float)((float)(v58.f32[1] - v12) * (float)(v58.f32[1] - v12))+ (float)((float)(v58.f32[0] - v13) * (float)(v58.f32[0] - v13)))+ *(float *)a1[2];
        return;
      }
      v65 = v11 + 1;
      if (!((unint64_t)(v11 + 1) >> 61))
      {
        v66 = v59 - (_QWORD)v6;
        if (v66 >> 2 > v65)
          v65 = v66 >> 2;
        if ((unint64_t)v66 >= 0x7FFFFFFFFFFFFFF8)
          v67 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v67 = v65;
        v73 = v58;
        if (v67)
        {
          v68 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKPoint>>(v5 + 24, v67);
          v58 = v73;
          v6 = *(float **)(v5 + 8);
          v8 = *(float **)(v5 + 16);
        }
        else
        {
          v68 = 0;
        }
        v71 = (float32x2_t *)&v68[8 * v11];
        *v71 = v58;
        v60 = (float *)&v71[1];
        if (v8 != v6)
        {
          do
          {
            v72 = *(float32x2_t *)(v8 - 2);
            v8 -= 2;
            v71[-1] = v72;
            --v71;
          }
          while (v8 != v6);
          v6 = (float *)*v7;
        }
        *(_QWORD *)(v5 + 8) = v71;
        *(_QWORD *)(v5 + 16) = v60;
        *(_QWORD *)(v5 + 24) = &v68[8 * v67];
        if (v6)
        {
          operator delete(v6);
          v58 = v73;
        }
        goto LABEL_83;
      }
LABEL_85:
      std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
    case kCGPathElementMoveToPoint:
LABEL_76:
      *(_BYTE *)a1 = 1;
      return;
  }
  v14 = 0;
  v15 = *((_DWORD *)a1 + 1);
  if (v15 <= 1)
    v15 = 1;
  v16 = (float)v15;
  v17 = v15 + 1;
  v18 = 0.0;
  v19 = *(v8 - 1);
  v20 = *(v8 - 2);
  do
  {
    a3.f32[0] = v20;
    a3 = pointOnPath((uint64_t)a2, a3, v19, (float)v14 / v16);
    v18 = v18
        + sqrtf((float)((float)(v21 - v19) * (float)(v21 - v19))+ (float)((float)(a3.f32[0] - v20) * (float)(a3.f32[0] - v20)));
    ++v14;
    v19 = v21;
    v20 = a3.f32[0];
  }
  while (v17 != v14);
  v22 = 0;
  if ((int)(float)(v18 / *((float *)a1 + 2)) <= 1)
    v23 = 1;
  else
    v23 = (int)(float)(v18 / *((float *)a1 + 2));
  do
  {
    *(double *)&v24 = (double)v22 / (double)v23;
    v25 = *(double *)&v24;
    v24.f32[0] = v13;
    v26 = pointOnPath((uint64_t)a2, v24, v12, v25).u32[0];
    v28 = *(float *)&v26;
    v29 = v27;
    v30 = *(_QWORD *)(v5 + 24);
    if ((unint64_t)v8 >= v30)
    {
      v32 = ((char *)v8 - (char *)v6) >> 3;
      v33 = v32 + 1;
      if ((unint64_t)(v32 + 1) >> 61)
        goto LABEL_85;
      v34 = v30 - (_QWORD)v6;
      if (v34 >> 2 > v33)
        v33 = v34 >> 2;
      if ((unint64_t)v34 >= 0x7FFFFFFFFFFFFFF8)
        v35 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v35 = v33;
      if (v35)
      {
        v36 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKPoint>>(v5 + 24, v35);
        v6 = *(float **)(v5 + 8);
        v8 = *(float **)(v5 + 16);
      }
      else
      {
        v36 = 0;
      }
      v37 = (float *)&v36[8 * v32];
      *v37 = v28;
      v37[1] = v29;
      v38 = v37;
      if (v8 != v6)
      {
        do
        {
          v39 = *((_QWORD *)v8 - 1);
          v8 -= 2;
          *((_QWORD *)v38 - 1) = v39;
          v38 -= 2;
        }
        while (v8 != v6);
        v6 = *(float **)(v5 + 8);
      }
      v31 = v37 + 2;
      *(_QWORD *)(v5 + 8) = v38;
      *(_QWORD *)(v5 + 16) = v37 + 2;
      *(_QWORD *)(v5 + 24) = &v36[8 * v35];
      if (v6)
        operator delete(v6);
    }
    else
    {
      *v8 = *(float *)&v26;
      v8[1] = v27;
      v31 = v8 + 2;
    }
    *(_QWORD *)(v5 + 16) = v31;
    v5 = a1[2];
    v6 = *(float **)(v5 + 8);
    v8 = *(float **)(v5 + 16);
    *(float *)v5 = *(float *)v5
                 + sqrtf((float)((float)(v29 - *(v8 - 3)) * (float)(v29 - *(v8 - 3)))+ (float)((float)(v28 - *(v8 - 4)) * (float)(v28 - *(v8 - 4))));
    v10 = v22++ == v23;
  }
  while (!v10);
}

void printPKPath(void *a1, const CGPathElement *a2)
{
  CGPoint *points;
  CGFloat x;
  CGFloat y;
  const __CFString *v5;
  CGPoint *v6;
  CGPoint *v7;

  switch(a2->type)
  {
    case kCGPathElementMoveToPoint:
      points = a2->points;
      x = points->x;
      y = points->y;
      v5 = CFSTR("moveto");
      goto LABEL_4;
    case kCGPathElementAddLineToPoint:
      v6 = a2->points;
      x = v6->x;
      y = v6->y;
      v5 = CFSTR("lineto");
LABEL_4:
      NSLog(CFSTR("%f %f %@"), *(_QWORD *)&x, *(_QWORD *)&y, v5);
      break;
    case kCGPathElementAddQuadCurveToPoint:
      NSLog(CFSTR("%f %f %f %f %@"), *(_QWORD *)&a2->points->x, *(_QWORD *)&a2->points->y, *(_QWORD *)&a2->points[1].x, *(_QWORD *)&a2->points[1].y, CFSTR("quadcurveto"));
      break;
    case kCGPathElementAddCurveToPoint:
      v7 = a2->points;
      NSLog(CFSTR("%f %f %f %f %f %f %@"), *(_QWORD *)&v7->x, *(_QWORD *)&v7->y, *(_QWORD *)&v7[1].x, *(_QWORD *)&v7[1].y, *(_QWORD *)&v7[2].x, *(_QWORD *)&v7[2].y, CFSTR("curveto"));
      break;
    case kCGPathElementCloseSubpath:
      NSLog(CFSTR("closepath"));
      break;
    default:
      return;
  }
}

BOOL PKPath::isEqualToPath(PKPath *this, PKPath *a2)
{
  const CGPath *v2;
  const CGPath *v3;
  _BOOL8 result;

  v2 = (const CGPath *)*((_QWORD *)this + 4);
  v3 = (const CGPath *)*((_QWORD *)a2 + 4);
  if (!v2)
    return !v3;
  if (!v3)
    return 0;
  result = CGPathEqualToPath(v2, v3);
  if ((_DWORD)result)
    return 1;
  return result;
}

float PKPath::computeLength(PKPath *this, float result)
{
  float *v2;
  uint64_t v3;
  unint64_t v4;
  float *v5;
  float v6;
  float v7;
  unint64_t v8;
  float v9;
  float v10;

  *(_DWORD *)this = 0;
  v2 = (float *)*((_QWORD *)this + 1);
  v3 = *((_QWORD *)this + 2) - (_QWORD)v2;
  if ((unint64_t)v3 >= 9)
  {
    v4 = v3 >> 3;
    v7 = *v2;
    v6 = v2[1];
    v5 = v2 + 3;
    if (v4 <= 2)
      v4 = 2;
    v8 = v4 - 1;
    result = 0.0;
    do
    {
      v9 = *(v5 - 1);
      v10 = *v5;
      result = result
             + sqrtf((float)((float)(*v5 - v6) * (float)(*v5 - v6)) + (float)((float)(v9 - v7) * (float)(v9 - v7)));
      *(float *)this = result;
      v5 += 2;
      v6 = v10;
      v7 = v9;
      --v8;
    }
    while (v8);
  }
  return result;
}

void PKPath::createPath(PKPath *this)
{
  const CGPath *v2;
  CGPath *Mutable;
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;

  v2 = (const CGPath *)*((_QWORD *)this + 4);
  if (v2)
    CGPathRelease(v2);
  if (*((_QWORD *)this + 2) == *((_QWORD *)this + 1))
  {
    *((_QWORD *)this + 4) = 0;
  }
  else
  {
    Mutable = CGPathCreateMutable();
    CGPathMoveToPoint(Mutable, 0, **((float **)this + 1), *(float *)(*((_QWORD *)this + 1) + 4));
    v4 = *((_QWORD *)this + 1);
    if ((unint64_t)(*((_QWORD *)this + 2) - v4) >= 9)
    {
      v5 = 0;
      v6 = 1;
      do
      {
        CGPathAddLineToPoint(Mutable, 0, *(float *)(v4 + v5 + 8), *(float *)(v4 + v5 + 12));
        ++v6;
        v4 = *((_QWORD *)this + 1);
        v5 += 8;
      }
      while (v6 < (*((_QWORD *)this + 2) - v4) >> 3);
    }
    CGPathCloseSubpath(Mutable);
    *((_QWORD *)this + 4) = MEMORY[0x20BD0B914](Mutable);
    CGPathRelease(Mutable);
  }
}

PKPath *PKPathCreateFromCGPath(const CGPath *a1)
{
  PKPath *v2;

  v2 = (PKPath *)operator new();
  PKPath::PKPath(v2, a1);
  return v2;
}

void sub_208FCFBFC(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BD0BA58](v1, 0x1060C402159C14DLL);
  _Unwind_Resume(a1);
}

uint64_t PKPathCreateFromCGPathWithOptions(const CGPath *a1, int a2, float a3)
{
  uint64_t v6;
  char info[4];
  int v9;
  float v10;
  uint64_t v11;

  v6 = operator new();
  *(_OWORD *)(v6 + 8) = 0u;
  *(_OWORD *)(v6 + 24) = 0u;
  v11 = v6;
  *(_QWORD *)(v6 + 32) = MEMORY[0x20BD0B914](a1);
  info[0] = 0;
  v9 = a2;
  v10 = a3;
  CGPathApply(a1, info, (CGPathApplierFunction)PKPathApplyCGPath);
  return v11;
}

void rdpReduce(uint64_t a1@<X0>, float **a2@<X8>, float a3@<S0>)
{
  uint64_t v4;
  float *v5;
  uint64_t v6;
  unint64_t v7;
  float v10;
  float v11;
  float v12;
  float v13;
  double v14;
  double v15;
  float *v16;
  float v17;
  int v18;
  uint64_t v19;
  float v20;
  float v21;
  float *v22;
  float *v23;
  float *v24;
  uint64_t v25;
  float *v26;
  float *v27;
  float *v28;
  uint64_t v29;
  float *v30;
  float *v31;
  uint64_t v32;
  unint64_t v33;
  uint64_t v34;
  unint64_t v35;
  char *v36;
  float *v37;
  float *v38;
  uint64_t v39;
  char *__p;
  char *v41;
  void *v42;
  void *v43;
  uint64_t v44;
  void *v45;
  void *v46;
  uint64_t v47;

  v5 = *(float **)a1;
  v4 = *(_QWORD *)(a1 + 8);
  v6 = v4 - *(_QWORD *)a1;
  v7 = v6 >> 3;
  if ((unint64_t)v6 > 0x17)
  {
    v10 = *v5;
    v11 = v5[1];
    v13 = *(float *)(v4 - 8);
    v12 = *(float *)(v4 - 4);
    if (v7 - 1 < 2)
    {
      v18 = -1;
      v17 = 0.0;
    }
    else
    {
      v14 = (float)((float)(v12 - v11) / (float)(v13 - v10));
      v15 = sqrt(v14 * v14 + 1.0);
      v16 = v5 + 3;
      v17 = 0.0;
      v18 = -1;
      v19 = 2;
      do
      {
        v20 = *(v16 - 1);
        if (v10 == v13)
          v21 = vabds_f32(v20, v10);
        else
          v21 = fabs(v11 - v14 * v10 - (*v16 - v14 * v20)) / v15;
        if (v21 > v17)
        {
          v17 = v21;
          v18 = v19 - 1;
        }
        v16 += 2;
        ++v19;
      }
      while (v7 != v19);
    }
    if (v17 <= a3)
    {
      *a2 = 0;
      a2[1] = 0;
      a2[2] = 0;
      v22 = (float *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKPoint>>((uint64_t)(a2 + 2), 1uLL);
      v23 = *a2;
      v24 = a2[1];
      v26 = &v22[2 * v25];
      *v22 = v10;
      v22[1] = v11;
      v27 = v22 + 2;
      v28 = v22;
      if (v24 != v23)
      {
        do
        {
          v29 = *((_QWORD *)v24 - 1);
          v24 -= 2;
          *((_QWORD *)v28 - 1) = v29;
          v28 -= 2;
        }
        while (v24 != v23);
        v23 = *a2;
      }
      *a2 = v28;
      a2[1] = v27;
      a2[2] = v26;
      if (v23)
      {
        operator delete(v23);
        v26 = a2[2];
      }
      a2[1] = v27;
      if (v27 >= v26)
      {
        v31 = *a2;
        v32 = ((char *)v27 - (char *)*a2) >> 3;
        v33 = v32 + 1;
        if ((unint64_t)(v32 + 1) >> 61)
          std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
        v34 = (char *)v26 - (char *)v31;
        if (v34 >> 2 > v33)
          v33 = v34 >> 2;
        if ((unint64_t)v34 >= 0x7FFFFFFFFFFFFFF8)
          v35 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v35 = v33;
        if (v35)
        {
          v36 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKPoint>>((uint64_t)(a2 + 2), v35);
          v31 = *a2;
          v27 = a2[1];
        }
        else
        {
          v36 = 0;
        }
        v37 = (float *)&v36[8 * v32];
        v38 = (float *)&v36[8 * v35];
        *v37 = v13;
        v37[1] = v12;
        v30 = v37 + 2;
        if (v27 != v31)
        {
          do
          {
            v39 = *((_QWORD *)v27 - 1);
            v27 -= 2;
            *((_QWORD *)v37 - 1) = v39;
            v37 -= 2;
          }
          while (v27 != v31);
          v31 = *a2;
        }
        *a2 = v37;
        a2[1] = v30;
        a2[2] = v38;
        if (v31)
          operator delete(v31);
      }
      else
      {
        v22[2] = v13;
        v22[3] = v12;
        v30 = v22 + 4;
      }
      a2[1] = v30;
    }
    else
    {
      v45 = 0;
      v46 = 0;
      v47 = 0;
      std::vector<PKPoint>::__insert_with_size[abi:ne180100]<std::__wrap_iter<PKPoint const*>,std::__wrap_iter<PKPoint const*>>((uint64_t)&v45, 0, (char *)v5, (char *)&v5[2 * v18 + 2], (8 * v18 + 8) >> 3);
      v42 = 0;
      v43 = 0;
      v44 = 0;
      std::vector<PKPoint>::__insert_with_size[abi:ne180100]<std::__wrap_iter<PKPoint const*>,std::__wrap_iter<PKPoint const*>>((uint64_t)&v42, 0, (char *)(*(_QWORD *)a1 + 8 * v18), *(char **)(a1 + 8), (*(_QWORD *)(a1 + 8) - (*(_QWORD *)a1 + 8 * v18)) >> 3);
      rdpReduce(&v45, a3);
      rdpReduce(&v42, a3);
      std::vector<PKPoint>::__insert_with_size[abi:ne180100]<std::__wrap_iter<PKPoint*>,std::__wrap_iter<PKPoint*>>((uint64_t)a2, (uint64_t)a2[1], __p + 8, v41, (v41 - (__p + 8)) >> 3);
      if (__p)
        operator delete(__p);
      if (v42)
      {
        v43 = v42;
        operator delete(v42);
      }
      if (v45)
      {
        v46 = v45;
        operator delete(v45);
      }
    }
  }
  else
  {
    *a2 = 0;
    a2[1] = 0;
    a2[2] = 0;
    std::vector<PKPoint>::__init_with_size[abi:ne180100]<PKPoint*,PKPoint*>(a2, v5, v4, v7);
  }
}

void sub_208FCFFE4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, uint64_t a15, void *a16, uint64_t a17)
{
  uint64_t v17;
  void *v19;

  if (__p)
    operator delete(__p);
  v19 = *(void **)v17;
  if (*(_QWORD *)v17)
  {
    *(_QWORD *)(v17 + 8) = v19;
    operator delete(v19);
  }
  if (a13)
    operator delete(a13);
  if (a16)
    operator delete(a16);
  _Unwind_Resume(exception_object);
}

double PKPathCreateFromSimplifiedCGPath(const CGPath *a1)
{
  uint64_t v2;
  uint64_t v3;
  void *v4;
  _QWORD *v5;
  double result;
  __int128 v7;
  uint64_t v8;
  char info[4];
  uint64_t v10;
  uint64_t v11;

  v2 = operator new();
  *(_OWORD *)(v2 + 8) = 0u;
  *(_OWORD *)(v2 + 24) = 0u;
  v11 = v2;
  *(_QWORD *)(v2 + 32) = MEMORY[0x20BD0B914](a1);
  info[0] = 0;
  v10 = 0x3F8000000000000FLL;
  CGPathApply(a1, info, (CGPathApplierFunction)PKPathApplyCGPath);
  rdpReduce(v11 + 8, (float **)&v7, 1.0);
  v3 = v11;
  v5 = (_QWORD *)(v11 + 8);
  v4 = *(void **)(v11 + 8);
  if (v4)
  {
    *(_QWORD *)(v11 + 16) = v4;
    operator delete(v4);
    *v5 = 0;
    v5[1] = 0;
    v5[2] = 0;
  }
  result = *(double *)&v7;
  *(_OWORD *)(v3 + 8) = v7;
  *(_QWORD *)(v3 + 24) = v8;
  return result;
}

uint64_t PKSplitBracesAndComma(CFStringRef theString, CFStringRef *a2, CFStringRef *a3)
{
  CFIndex Length;
  CFIndex v6;
  uint64_t v7;
  CFIndex v8;
  int v9;
  CFIndex *v10;
  CFIndex location;
  CFIndex v12;
  int CharacterAtIndex;
  uint64_t v15;
  CFIndex v16;
  CFIndex v17;
  CFIndex v19;
  CFRange result;
  CFRange v21;
  CFRange v22;
  CFRange v23;

  v19 = -1;
  if (!ParseBracesAndCommas(__CFString const*,long *,long *,long *,long *)::__braceCharacters)
    ParseBracesAndCommas(__CFString const*,long *,long *,long *,long *)::__braceCharacters = (uint64_t)CFCharacterSetCreateWithCharactersInString(0, CFSTR("{[,]}"));
  Length = CFStringGetLength(theString);
  if (Length >= 1)
  {
    v6 = Length;
    v7 = 0;
    v8 = 0;
    v9 = 0;
    v10 = &v19;
    location = -1;
    v12 = Length;
    while (1)
    {
      v21.location = v8;
      v21.length = v12;
      if (!CFStringFindCharacterFromSet(theString, (CFCharacterSetRef)ParseBracesAndCommas(__CFString const*,long *,long *,long *,long *)::__braceCharacters, v21, 0, &result))break;
      if (result.location >= v6 || result.length != 1)
        break;
      CharacterAtIndex = CFStringGetCharacterAtIndex(theString, result.location);
      if ((CharacterAtIndex & 0xFFFFFFDF) == 0x5B)
      {
        if (!v9)
          location = result.location;
        ++v9;
      }
      else if (CharacterAtIndex == 44)
      {
        if (v9 == 1)
        {
          if (v7 <= 0)
          {
            *v10++ = result.location;
            ++v7;
          }
          v9 = 1;
        }
      }
      else if ((CharacterAtIndex & 0xFFFFFFDF) == 0x5D && !--v9)
      {
        v15 = 0;
        if (location != -1)
        {
          v16 = result.location;
          if (result.location != -1 && location < result.location)
          {
            v15 = 0;
            v17 = v19;
            if (v19 > location + 1 && v19 < result.location - 1)
            {
              v22.length = v19 + ~location;
              v22.location = location + 1;
              *a2 = CFStringCreateWithSubstring(0, theString, v22);
              v23.location = v17 + 1;
              v23.length = v16 + ~v17;
              *a3 = CFStringCreateWithSubstring(0, theString, v23);
              return 1;
            }
          }
        }
        return v15;
      }
      if (result.location + 1 < v6)
      {
        v12 += v8 + ~result.location;
        v8 = result.location + 1;
        if (v12 > 0)
          continue;
      }
      return 0;
    }
  }
  return 0;
}

double PKCGPointFromString(void *a1)
{
  __CFString *v1;
  double DoubleValue;
  CFStringRef v3;
  CFStringRef v4;
  CFStringRef v6;
  CFStringRef str;

  v1 = a1;
  DoubleValue = *MEMORY[0x24BDBEFB0];
  if ((unint64_t)-[__CFString length](v1, "length") >= 5)
  {
    v6 = 0;
    str = 0;
    if (PKSplitBracesAndComma(v1, &str, &v6))
    {
      v3 = str;
      DoubleValue = CFStringGetDoubleValue(str);
      v4 = v6;
      CFStringGetDoubleValue(v6);
      CFRelease(v3);
      CFRelease(v4);
    }
  }

  return DoubleValue;
}

void sub_208FD03B0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_208FD0434(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, id a12)
{
  void *v12;

  _Unwind_Resume(a1);
}

void sub_208FD04C8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, id a12)
{
  void *v12;

  _Unwind_Resume(a1);
}

void sub_208FD055C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, id a12)
{
  void *v12;

  _Unwind_Resume(a1);
}

void sub_208FD0614(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_208FD0720(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_208FD0838(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

CGPath *PKCGPathCreateFromArray(void *a1, int a2)
{
  float v3;
  CGPath *Mutable;
  uint64_t v5;
  uint64_t v6;
  double v7;
  uint64_t i;
  void *v9;
  void *v10;
  int v11;
  void *v12;
  void *v13;
  void *v14;
  double v15;
  double v16;
  double v17;
  double v18;
  void *v19;
  double v20;
  double v21;
  double v22;
  double v23;
  void *v24;
  double v25;
  double v26;
  double v27;
  double v28;
  void *v29;
  double v30;
  double v31;
  double v32;
  double v33;
  void *v34;
  double v35;
  double v36;
  double v37;
  double v38;
  void *v39;
  double v40;
  double v41;
  double v42;
  double v43;
  void *v44;
  double v45;
  double v46;
  double v47;
  double v48;
  id v50;
  id obj;
  __int128 v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  _BYTE v56[128];
  uint64_t v57;

  v57 = *MEMORY[0x24BDAC8D0];
  v50 = a1;
  if (v50)
  {
    v3 = 1.0;
    if (a2)
      v3 = PKGet_PTM_RATIO();
    Mutable = CGPathCreateMutable();
    v54 = 0u;
    v55 = 0u;
    v52 = 0u;
    v53 = 0u;
    obj = v50;
    v5 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v52, v56, 16);
    if (v5)
    {
      v6 = *(_QWORD *)v53;
      v7 = v3;
      do
      {
        for (i = 0; i != v5; ++i)
        {
          if (*(_QWORD *)v53 != v6)
            objc_enumerationMutation(obj);
          v9 = *(void **)(*((_QWORD *)&v52 + 1) + 8 * i);
          objc_msgSend(v9, "objectForKey:", CFSTR("type"), v50);
          v10 = (void *)objc_claimAutoreleasedReturnValue();
          v11 = objc_msgSend(v10, "intValue");

          objc_msgSend(v9, "objectForKey:", CFSTR("points"));
          v12 = (void *)objc_claimAutoreleasedReturnValue();
          v13 = v12;
          switch(v11)
          {
            case 0:
              objc_msgSend(v12, "objectAtIndex:", 0);
              v14 = (void *)objc_claimAutoreleasedReturnValue();
              objc_msgSend(v14, "CGPointValue");
              v16 = v15;
              v18 = v17;

              CGPathMoveToPoint(Mutable, 0, v16 * v7, v18 * v7);
              break;
            case 1:
              objc_msgSend(v12, "objectAtIndex:", 0);
              v29 = (void *)objc_claimAutoreleasedReturnValue();
              objc_msgSend(v29, "CGPointValue");
              v31 = v30;
              v33 = v32;

              CGPathAddLineToPoint(Mutable, 0, v31 * v7, v33 * v7);
              break;
            case 2:
              objc_msgSend(v12, "objectAtIndex:", 0);
              v19 = (void *)objc_claimAutoreleasedReturnValue();
              objc_msgSend(v19, "CGPointValue");
              v21 = v20;
              v23 = v22;

              objc_msgSend(v13, "objectAtIndex:", 1);
              v24 = (void *)objc_claimAutoreleasedReturnValue();
              objc_msgSend(v24, "CGPointValue");
              v26 = v25;
              v28 = v27;

              CGPathAddQuadCurveToPoint(Mutable, 0, v21 * v7, v23 * v7, v26 * v7, v28 * v7);
              break;
            case 3:
              objc_msgSend(v12, "objectAtIndex:", 0);
              v34 = (void *)objc_claimAutoreleasedReturnValue();
              objc_msgSend(v34, "CGPointValue");
              v36 = v35;
              v38 = v37;

              objc_msgSend(v13, "objectAtIndex:", 1);
              v39 = (void *)objc_claimAutoreleasedReturnValue();
              objc_msgSend(v39, "CGPointValue");
              v41 = v40;
              v43 = v42;

              objc_msgSend(v13, "objectAtIndex:", 2);
              v44 = (void *)objc_claimAutoreleasedReturnValue();
              objc_msgSend(v44, "CGPointValue");
              v46 = v45;
              v48 = v47;

              CGPathAddCurveToPoint(Mutable, 0, v36 * v7, v38 * v7, v41 * v7, v43 * v7, v46 * v7, v48 * v7);
              break;
            case 4:
              CGPathCloseSubpath(Mutable);
              break;
            default:
              break;
          }

        }
        v5 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v52, v56, 16);
      }
      while (v5);
    }

  }
  else
  {
    Mutable = 0;
  }

  return Mutable;
}

void sub_208FD0B98(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9)
{

  _Unwind_Resume(a1);
}

id PKArrayFromPKPath(uint64_t a1)
{
  void *v2;
  float *v3;
  float *v4;
  char v5;
  float v6;
  float v7;
  void *v8;
  void *v9;
  void *v10;
  void *v11;

  if (a1)
  {
    objc_msgSend(MEMORY[0x24BDBCEB8], "array");
    v2 = (void *)objc_claimAutoreleasedReturnValue();
    v3 = *(float **)(a1 + 8);
    v4 = *(float **)(a1 + 16);
    if (v3 != v4)
    {
      v5 = 1;
      do
      {
        v6 = *v3;
        v7 = v3[1];
        objc_msgSend(MEMORY[0x24BDBCED8], "dictionary");
        v8 = (void *)objc_claimAutoreleasedReturnValue();
        if ((v5 & 1) != 0)
          objc_msgSend(MEMORY[0x24BDD16E0], "numberWithInt:", 0);
        else
          objc_msgSend(MEMORY[0x24BDD16E0], "numberWithInt:", 1);
        v9 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v8, "setValue:forKey:", v9, CFSTR("type"));

        objc_msgSend(MEMORY[0x24BDBCEB8], "array");
        v10 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(MEMORY[0x24BDD1968], "valueWithCGPoint:", v6, v7);
        v11 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v10, "addObject:", v11);

        objc_msgSend(v8, "setValue:forKey:", v10, CFSTR("points"));
        objc_msgSend(v2, "addObject:", v8);

        v5 = 0;
        v3 += 2;
      }
      while (v3 != v4);
    }
  }
  else
  {
    v2 = 0;
  }
  return v2;
}

void sub_208FD0DC8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

id PKArrayFromB2PolygonShape(uint64_t a1)
{
  void *v2;
  float *v3;
  float *v4;
  char v5;
  float v6;
  float v7;
  void *v8;
  void *v9;
  void *v10;
  void *v11;

  if (a1)
  {
    objc_msgSend(MEMORY[0x24BDBCEB8], "array");
    v2 = (void *)objc_claimAutoreleasedReturnValue();
    v3 = *(float **)(a1 + 16);
    v4 = *(float **)(a1 + 24);
    if (v3 != v4)
    {
      v5 = 1;
      do
      {
        v6 = *v3;
        v7 = v3[1];
        objc_msgSend(MEMORY[0x24BDBCED8], "dictionary");
        v8 = (void *)objc_claimAutoreleasedReturnValue();
        if ((v5 & 1) != 0)
          objc_msgSend(MEMORY[0x24BDD16E0], "numberWithInt:", 0);
        else
          objc_msgSend(MEMORY[0x24BDD16E0], "numberWithInt:", 1);
        v9 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v8, "setValue:forKey:", v9, CFSTR("type"));

        objc_msgSend(MEMORY[0x24BDBCEB8], "array");
        v10 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(MEMORY[0x24BDD1968], "valueWithCGPoint:", v6, v7);
        v11 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v10, "addObject:", v11);

        objc_msgSend(v8, "setValue:forKey:", v10, CFSTR("points"));
        objc_msgSend(v2, "addObject:", v8);

        v5 = 0;
        v3 += 2;
      }
      while (v3 != v4);
    }
  }
  else
  {
    v2 = 0;
  }
  return v2;
}

void sub_208FD0F70(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

id PKArrayFromB2ChainShape(uint64_t a1)
{
  void *v2;
  float *v3;
  float *v4;
  char v5;
  float v6;
  float v7;
  void *v8;
  void *v9;
  void *v10;
  void *v11;

  if (a1)
  {
    objc_msgSend(MEMORY[0x24BDBCEB8], "array");
    v2 = (void *)objc_claimAutoreleasedReturnValue();
    v3 = *(float **)(a1 + 16);
    v4 = *(float **)(a1 + 24);
    if (v3 != v4)
    {
      v5 = 1;
      do
      {
        v6 = *v3;
        v7 = v3[1];
        objc_msgSend(MEMORY[0x24BDBCED8], "dictionary");
        v8 = (void *)objc_claimAutoreleasedReturnValue();
        if ((v5 & 1) != 0)
          objc_msgSend(MEMORY[0x24BDD16E0], "numberWithInt:", 0);
        else
          objc_msgSend(MEMORY[0x24BDD16E0], "numberWithInt:", 1);
        v9 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v8, "setValue:forKey:", v9, CFSTR("type"));

        objc_msgSend(MEMORY[0x24BDBCEB8], "array");
        v10 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(MEMORY[0x24BDD1968], "valueWithCGPoint:", v6, v7);
        v11 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v10, "addObject:", v11);

        objc_msgSend(v8, "setValue:forKey:", v10, CFSTR("points"));
        objc_msgSend(v2, "addObject:", v8);

        v5 = 0;
        v3 += 2;
      }
      while (v3 != v4);
    }
  }
  else
  {
    v2 = 0;
  }
  return v2;
}

void sub_208FD1118(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

const CGPath *PKArrayFromCGPath(const CGPath *a1, int a2)
{
  const CGPath *v2;
  float v4;
  id v6;
  float v7;

  v2 = a1;
  if (a1)
  {
    objc_msgSend(MEMORY[0x24BDBCEB8], "array", 0);
    v6 = (id)objc_claimAutoreleasedReturnValue();
    v4 = 1.0;
    if (a2)
      v4 = PKGet_INV_PTM_RATIO();
    v7 = v4;
    CGPathApply(v2, &v6, (CGPathApplierFunction)PKArrayFromCGPathApply);
    v2 = (const CGPath *)v6;

  }
  return v2;
}

void sub_208FD11D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9)
{

  _Unwind_Resume(a1);
}

void PKArrayFromCGPathApply(id *a1, const CGPathElement *a2)
{
  void *v3;
  CGPathElementType type;
  void *v5;
  CGPoint *points;
  void *v7;
  void *v8;
  void *v9;
  void *v10;
  void *v11;
  id v12;

  v12 = *a1;
  objc_msgSend(MEMORY[0x24BDBCED8], "dictionary");
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  type = a2->type;
  objc_msgSend(MEMORY[0x24BDD16E0], "numberWithInt:", a2->type);
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v3, "setValue:forKey:", v5, CFSTR("type"));

  points = a2->points;
  objc_msgSend(MEMORY[0x24BDBCEB8], "array");
  v7 = (void *)objc_claimAutoreleasedReturnValue();
  switch(type)
  {
    case kCGPathElementMoveToPoint:
    case kCGPathElementAddLineToPoint:
      objc_msgSend(MEMORY[0x24BDD1968], "valueWithCGPoint:", points->x, points->y);
      v9 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v7, "addObject:", v9);
      goto LABEL_5;
    case kCGPathElementAddQuadCurveToPoint:
      objc_msgSend(MEMORY[0x24BDD1968], "valueWithCGPoint:", points->x, points->y);
      v8 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v7, "addObject:", v8);

      objc_msgSend(MEMORY[0x24BDD1968], "valueWithCGPoint:", points[1].x, points[1].y);
      v9 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v7, "addObject:", v9);
      goto LABEL_5;
    case kCGPathElementAddCurveToPoint:
      objc_msgSend(MEMORY[0x24BDD1968], "valueWithCGPoint:", points->x, points->y);
      v10 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v7, "addObject:", v10);

      objc_msgSend(MEMORY[0x24BDD1968], "valueWithCGPoint:", points[1].x, points[1].y);
      v11 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v7, "addObject:", v11);

      objc_msgSend(MEMORY[0x24BDD1968], "valueWithCGPoint:", points[2].x, points[2].y);
      v9 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v7, "addObject:", v9);
LABEL_5:

      break;
    default:
      break;
  }
  objc_msgSend(v3, "setValue:forKey:", v7, CFSTR("points"));
  objc_msgSend(v12, "addObject:", v3);

}

void sub_208FD13E0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;
  void *v11;
  void *v12;
  void *v13;

  v13 = v12;

  _Unwind_Resume(a1);
}

float32x2_t pointOnPath(uint64_t a1, float32x2_t result, float32_t a3, float a4)
{
  float64x2_t *v4;
  float v5;
  float32x2_t v6;
  float32x2_t v7;
  float32x2_t v8;
  float32x2_t v9;
  float64x2_t *v10;
  float v11;
  float v12;
  float32x2_t v13;
  float32x2_t v14;

  if (a4 > 1.0)
    a4 = 1.0;
  if (a4 < 0.0)
    a4 = 0.0;
  result.f32[1] = a3;
  switch(*(_DWORD *)a1)
  {
    case 0:
      if (a4 >= 1.0)
        result = vcvt_f32_f64(*(float64x2_t *)*(_QWORD *)(a1 + 8));
      break;
    case 1:
      result = vadd_f32(result, vmul_n_f32(vsub_f32(vcvt_f32_f64(*(float64x2_t *)*(_QWORD *)(a1 + 8)), result), a4));
      break;
    case 2:
      v4 = *(float64x2_t **)(a1 + 8);
      v5 = 1.0 - a4;
      v6 = vmul_n_f32(result, v5 * v5);
      v7 = vmul_n_f32(vcvt_f32_f64(*v4), a4 * (float)(v5 + v5));
      v8 = vmul_n_f32(vcvt_f32_f64(v4[1]), a4 * a4);
      v9 = vadd_f32(v6, v7);
      goto LABEL_10;
    case 3:
      v10 = *(float64x2_t **)(a1 + 8);
      v11 = (float)(1.0 - a4) * 3.0;
      v12 = a4 * (float)((float)(1.0 - a4) * v11);
      v13 = vmul_n_f32(result, (float)(1.0 - a4) * (float)((float)(1.0 - a4) * (float)(1.0 - a4)));
      v14 = vmul_n_f32(vcvt_f32_f64(v10[1]), a4 * (float)(a4 * v11));
      v8 = vmul_n_f32(vcvt_f32_f64(v10[2]), a4 * (float)(a4 * a4));
      v9 = vadd_f32(vadd_f32(v13, vmul_n_f32(vcvt_f32_f64(*v10), v12)), v14);
LABEL_10:
      result = vadd_f32(v9, v8);
      break;
    default:
      return result;
  }
  return result;
}

char *std::vector<PKPoint>::__insert_with_size[abi:ne180100]<std::__wrap_iter<PKPoint const*>,std::__wrap_iter<PKPoint const*>>(uint64_t a1, uint64_t __dst, char *__src, char *a4, uint64_t a5)
{
  char *v5;
  char *v7;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  void *v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  char *v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  int64_t v22;
  char *v23;
  char *v24;
  char *v25;
  char *v26;
  uint64_t v27;
  char *v28;
  uint64_t v29;
  char *v30;
  uint64_t v31;
  void *__p;
  char *v34;
  char *v35;
  char *v36;
  uint64_t v37;

  v5 = (char *)__dst;
  if (a5 < 1)
    return v5;
  v7 = __src;
  v11 = *(_QWORD *)(a1 + 16);
  v9 = a1 + 16;
  v10 = v11;
  v12 = *(_QWORD *)(v9 - 8);
  if (a5 > (uint64_t)(v11 - v12) >> 3)
  {
    v13 = *(void **)a1;
    v14 = a5 + ((uint64_t)(v12 - *(_QWORD *)a1) >> 3);
    if (v14 >> 61)
      std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
    v15 = (__dst - (uint64_t)v13) >> 3;
    v16 = v10 - (_QWORD)v13;
    if (v16 >> 2 > v14)
      v14 = v16 >> 2;
    if ((unint64_t)v16 >= 0x7FFFFFFFFFFFFFF8)
      v17 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v17 = v14;
    v37 = v9;
    if (v17)
      v18 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKPoint>>(v9, v17);
    else
      v18 = 0;
    v28 = &v18[8 * v15];
    __p = v18;
    v34 = v28;
    v36 = &v18[8 * v17];
    v29 = 8 * a5;
    v30 = &v28[8 * a5];
    do
    {
      v31 = *(_QWORD *)v7;
      v7 += 8;
      *(_QWORD *)v28 = v31;
      v28 += 8;
      v29 -= 8;
    }
    while (v29);
    v35 = v30;
    v5 = std::vector<PKPoint>::__swap_out_circular_buffer((void **)a1, (uint64_t)&__p, v5);
    if (v35 != v34)
      v35 += (v34 - v35 + 7) & 0xFFFFFFFFFFFFFFF8;
    if (__p)
      operator delete(__p);
    return v5;
  }
  v19 = v12 - __dst;
  v20 = (uint64_t)(v12 - __dst) >> 3;
  if (v20 >= a5)
  {
    v21 = &__src[8 * a5];
    v23 = *(char **)(v9 - 8);
LABEL_17:
    v24 = &v5[8 * a5];
    v25 = &v23[-8 * a5];
    v26 = v23;
    if ((unint64_t)v25 < v12)
    {
      v26 = v23;
      do
      {
        v27 = *(_QWORD *)v25;
        v25 += 8;
        *(_QWORD *)v26 = v27;
        v26 += 8;
      }
      while ((unint64_t)v25 < v12);
    }
    *(_QWORD *)(a1 + 8) = v26;
    if (v23 != v24)
      memmove(&v23[-8 * ((v23 - v24) >> 3)], v5, v23 - v24);
    if (v21 != v7)
      memmove(v5, v7, v21 - v7);
    return v5;
  }
  v21 = &__src[8 * v20];
  v22 = a4 - v21;
  if (a4 != v21)
    memmove(*(void **)(v9 - 8), &__src[8 * v20], a4 - v21);
  v23 = (char *)(v12 + v22);
  *(_QWORD *)(a1 + 8) = v12 + v22;
  if (v19 >= 1)
    goto LABEL_17;
  return v5;
}

void sub_208FD1740(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

char *std::vector<PKPoint>::__swap_out_circular_buffer(void **a1, uint64_t a2, char *__src)
{
  char *v5;
  char *v6;
  char *v7;
  char *v8;
  uint64_t v9;
  _BYTE *v10;
  uint64_t v11;
  int64_t v12;
  char *v13;
  void *v14;
  void *v15;

  v5 = *(char **)(a2 + 8);
  v6 = (char *)*a1;
  v7 = v5;
  if (*a1 != __src)
  {
    v8 = __src;
    v7 = *(char **)(a2 + 8);
    do
    {
      v9 = *((_QWORD *)v8 - 1);
      v8 -= 8;
      *((_QWORD *)v7 - 1) = v9;
      v7 -= 8;
    }
    while (v8 != v6);
  }
  *(_QWORD *)(a2 + 8) = v7;
  v10 = a1[1];
  v11 = *(_QWORD *)(a2 + 16);
  v12 = v10 - __src;
  if (v10 != __src)
  {
    memmove(*(void **)(a2 + 16), __src, v10 - __src);
    v7 = *(char **)(a2 + 8);
  }
  *(_QWORD *)(a2 + 16) = v11 + v12;
  v13 = (char *)*a1;
  *a1 = v7;
  *(_QWORD *)(a2 + 8) = v13;
  v14 = a1[1];
  a1[1] = *(void **)(a2 + 16);
  *(_QWORD *)(a2 + 16) = v14;
  v15 = a1[2];
  a1[2] = *(void **)(a2 + 24);
  *(_QWORD *)(a2 + 24) = v15;
  *(_QWORD *)a2 = *(_QWORD *)(a2 + 8);
  return v5;
}

char *std::vector<PKPoint>::__insert_with_size[abi:ne180100]<std::__wrap_iter<PKPoint*>,std::__wrap_iter<PKPoint*>>(uint64_t a1, uint64_t __dst, char *__src, char *a4, uint64_t a5)
{
  char *v5;
  char *v7;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  void *v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  char *v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  int64_t v22;
  char *v23;
  char *v24;
  char *v25;
  char *v26;
  uint64_t v27;
  char *v28;
  uint64_t v29;
  char *v30;
  uint64_t v31;
  void *__p;
  char *v34;
  char *v35;
  char *v36;
  uint64_t v37;

  v5 = (char *)__dst;
  if (a5 < 1)
    return v5;
  v7 = __src;
  v11 = *(_QWORD *)(a1 + 16);
  v9 = a1 + 16;
  v10 = v11;
  v12 = *(_QWORD *)(v9 - 8);
  if (a5 > (uint64_t)(v11 - v12) >> 3)
  {
    v13 = *(void **)a1;
    v14 = a5 + ((uint64_t)(v12 - *(_QWORD *)a1) >> 3);
    if (v14 >> 61)
      std::vector<PKPoint>::__throw_length_error[abi:ne180100]();
    v15 = (__dst - (uint64_t)v13) >> 3;
    v16 = v10 - (_QWORD)v13;
    if (v16 >> 2 > v14)
      v14 = v16 >> 2;
    if ((unint64_t)v16 >= 0x7FFFFFFFFFFFFFF8)
      v17 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v17 = v14;
    v37 = v9;
    if (v17)
      v18 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<PKPoint>>(v9, v17);
    else
      v18 = 0;
    v28 = &v18[8 * v15];
    __p = v18;
    v34 = v28;
    v36 = &v18[8 * v17];
    v29 = 8 * a5;
    v30 = &v28[8 * a5];
    do
    {
      v31 = *(_QWORD *)v7;
      v7 += 8;
      *(_QWORD *)v28 = v31;
      v28 += 8;
      v29 -= 8;
    }
    while (v29);
    v35 = v30;
    v5 = std::vector<PKPoint>::__swap_out_circular_buffer((void **)a1, (uint64_t)&__p, v5);
    if (v35 != v34)
      v35 += (v34 - v35 + 7) & 0xFFFFFFFFFFFFFFF8;
    if (__p)
      operator delete(__p);
    return v5;
  }
  v19 = v12 - __dst;
  v20 = (uint64_t)(v12 - __dst) >> 3;
  if (v20 >= a5)
  {
    v21 = &__src[8 * a5];
    v23 = *(char **)(v9 - 8);
LABEL_17:
    v24 = &v5[8 * a5];
    v25 = &v23[-8 * a5];
    v26 = v23;
    if ((unint64_t)v25 < v12)
    {
      v26 = v23;
      do
      {
        v27 = *(_QWORD *)v25;
        v25 += 8;
        *(_QWORD *)v26 = v27;
        v26 += 8;
      }
      while ((unint64_t)v25 < v12);
    }
    *(_QWORD *)(a1 + 8) = v26;
    if (v23 != v24)
      memmove(&v23[-8 * ((v23 - v24) >> 3)], v5, v23 - v24);
    if (v21 != v7)
      memmove(v5, v7, v21 - v7);
    return v5;
  }
  v21 = &__src[8 * v20];
  v22 = a4 - v21;
  if (a4 != v21)
    memmove(*(void **)(v9 - 8), &__src[8 * v20], a4 - v21);
  v23 = (char *)(v12 + v22);
  *(_QWORD *)(a1 + 8) = v12 + v22;
  if (v19 >= 1)
    goto LABEL_17;
  return v5;
}

void sub_208FD1A10(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

float gradrot2(char a1, float *a2, float *a3, float a4, float a5)
{
  float *v5;
  float v6;
  float v7;
  float result;

  v5 = (float *)((char *)&grad2 + 8 * (a1 & 7));
  v6 = *v5;
  v7 = v5[1];
  *a2 = (float)(a5 * *v5) - (float)(v7 * a4);
  result = (float)(v7 * a5) + (float)(a4 * v6);
  *a3 = result;
  return result;
}

float gradrot3(char a1, float *a2, float *a3, float *a4, float a5, float a6)
{
  float *v6;
  float v7;
  float v8;
  float *v9;
  float v10;
  float v11;
  float result;

  v6 = (float *)((char *)&grad3u + 12 * (a1 & 0xF));
  v7 = v6[1];
  v8 = v6[2];
  v9 = (float *)((char *)&grad3v + 12 * (a1 & 0xF));
  v10 = v9[1];
  v11 = v9[2];
  *a2 = (float)(*v9 * a5) + (float)(a6 * *v6);
  *a3 = (float)(v10 * a5) + (float)(a6 * v7);
  result = (float)(v11 * a5) + (float)(a6 * v8);
  *a4 = result;
  return result;
}

float graddotp2(float a1, float a2, float a3, float a4)
{
  return (float)(a2 * a4) + (float)(a1 * a3);
}

float graddotp3(float a1, float a2, float a3, float a4, float a5, float a6)
{
  return (float)((float)(a2 * a5) + (float)(a1 * a4)) + (float)(a3 * a6);
}

float srdnoise2(float *a1, float *a2, float a3, float a4, float a5)
{
  __float2 v9;

  v9 = __sincosf_stret(a5);
  return srdnoise2_sincos(a1, a2, a3, a4, v9.__sinval, v9.__cosval);
}

float srdnoise2_sincos(float *a1, float *a2, float a3, float a4, float a5, float a6)
{
  float v6;
  int v7;
  int v8;
  float v9;
  float v10;
  float v11;
  float v12;
  float v13;
  float v14;
  float v15;
  float v16;
  float v17;
  int v18;
  int v19;
  int v20;
  int v21;
  int v22;
  float v23;
  float v24;
  float v25;
  float v26;
  float v27;
  float v28;
  float v29;
  float *v30;
  float v31;
  float v32;
  float v33;
  float v34;
  float v35;
  float v36;
  float v37;
  float v38;
  float v39;
  float *v40;
  float v41;
  float v42;
  float v43;
  float v44;
  float v45;
  float v46;
  float v47;
  float v48;
  float *v49;
  float v50;
  float v51;
  float v52;
  float v53;

  v6 = (float)(a3 + a4) * 0.366025403;
  v7 = (int)(float)(v6 + a3) - ((float)(v6 + a3) <= 0.0);
  v8 = (int)(float)(v6 + a4) - ((float)(v6 + a4) <= 0.0);
  v9 = (float)(v7 + v8) * 0.211324865;
  v10 = (float)v8 - v9;
  v11 = a3 - (float)((float)v7 - v9);
  v12 = a4 - v10;
  v13 = 0.0;
  v14 = 1.0;
  if (v11 <= v12)
    v15 = 0.0;
  else
    v15 = 1.0;
  v16 = (float)(v11 - v15) + 0.211324865;
  if (v11 > v12)
    v14 = 0.0;
  v17 = (float)(v12 - v14) + 0.211324865;
  v18 = v7;
  v19 = -v7;
  if (v19 >= 0)
    v20 = -v19;
  else
    v20 = v18;
  v21 = v8;
  v22 = -v8;
  if (v22 >= 0)
    v21 = -v22;
  v23 = (float)(0.5 - (float)(v11 * v11)) - (float)(v12 * v12);
  v24 = 0.0;
  v25 = 0.0;
  v26 = 0.0;
  v27 = 0.0;
  v28 = 0.0;
  v29 = 0.0;
  if (v23 >= 0.0)
  {
    v30 = (float *)((char *)&grad2 + 8 * (perm_1[perm_1[v21] + (uint64_t)v20] & 7));
    v31 = v30[1];
    v24 = (float)(a6 * *v30) - (float)(v31 * a5);
    v25 = (float)(v31 * a6) + (float)(a5 * *v30);
    v27 = v23 * v23;
    v28 = v27 * v27;
    v29 = (float)(v27 * v27) * (float)((float)(v12 * v25) + (float)(v24 * v11));
    v26 = (float)(0.5 - (float)(v11 * v11)) - (float)(v12 * v12);
  }
  v32 = (float)(v11 + -1.0) + 0.42264973;
  v33 = (float)(v12 + -1.0) + 0.42264973;
  v34 = (float)(0.5 - (float)(v16 * v16)) - (float)(v17 * v17);
  v35 = 0.0;
  v36 = 0.0;
  v37 = 0.0;
  v38 = 0.0;
  v39 = 0.0;
  if (v34 >= 0.0)
  {
    v40 = (float *)((char *)&grad2
                  + 8 * (perm_1[perm_1[v21 + (unint64_t)(v11 <= v12)] + (uint64_t)(v20 + (v11 > v12))] & 7));
    v41 = v40[1];
    v13 = (float)(a6 * *v40) - (float)(v41 * a5);
    v35 = (float)(v41 * a6) + (float)(a5 * *v40);
    v37 = v34 * v34;
    v38 = v37 * v37;
    v39 = (float)(v37 * v37) * (float)((float)(v35 * v17) + (float)(v13 * v16));
    v36 = (float)(0.5 - (float)(v16 * v16)) - (float)(v17 * v17);
  }
  v42 = (float)(0.5 - (float)(v32 * v32)) - (float)(v33 * v33);
  v43 = 0.0;
  v44 = 0.0;
  v45 = 0.0;
  v46 = 0.0;
  v47 = 0.0;
  v48 = 0.0;
  if (v42 >= 0.0)
  {
    v49 = (float *)((char *)&grad2 + 8 * (perm_1[perm_1[v21 + 1] + 1 + (uint64_t)v20] & 7));
    v50 = v49[1];
    v43 = (float)(a6 * *v49) - (float)(v50 * a5);
    v44 = (float)(v50 * a6) + (float)(a5 * *v49);
    v46 = v42 * v42;
    v47 = v46 * v46;
    v48 = (float)(v46 * v46) * (float)((float)(v44 * v33) + (float)(v43 * v32));
    v45 = (float)(0.5 - (float)(v32 * v32)) - (float)(v33 * v33);
  }
  if (a1 && a2)
  {
    v51 = (float)((float)(v12 * v25) + (float)(v24 * v11)) * (float)(v26 * v27);
    *a1 = v11 * v51;
    *a2 = v12 * v51;
    v52 = (float)((float)(v35 * v17) + (float)(v13 * v16)) * (float)(v36 * v37);
    *a1 = *a1 + (float)(v52 * v16);
    *a2 = *a2 + (float)(v52 * v17);
    v53 = (float)((float)(v44 * v33) + (float)(v43 * v32)) * (float)(v45 * v46);
    *a1 = *a1 + (float)(v53 * v32);
    *a2 = *a2 + (float)(v53 * v33);
    *a1 = *a1 * -8.0;
    *a2 = *a2 * -8.0;
    *a1 = (float)((float)((float)(v13 * v38) + (float)(v28 * v24)) + (float)(v47 * v43)) + *a1;
    *a2 = (float)((float)((float)(v35 * v38) + (float)(v28 * v25)) + (float)(v47 * v44)) + *a2;
    *a1 = *a1 * 40.0;
    *a2 = *a2 * 40.0;
  }
  return (float)((float)(v29 + v39) + v48) * 40.0;
}

float srdnoise3(float *a1, float *a2, float *a3, float a4, float a5, float a6, float a7)
{
  __float2 v13;

  v13 = __sincosf_stret(a7);
  return srdnoise3_sincos(a1, a2, a3, a4, a5, a6, v13.__sinval, v13.__cosval);
}

float srdnoise3_sincos(float *a1, float *a2, float *a3, float a4, float a5, float a6, float a7, float a8)
{
  float v8;
  int v9;
  int v10;
  int v11;
  float v12;
  float v13;
  float v14;
  float v15;
  float v16;
  float v17;
  _BOOL4 v18;
  int v19;
  _BOOL4 v20;
  _BOOL4 v21;
  int v22;
  _BOOL4 v23;
  float v24;
  float v25;
  float v26;
  BOOL v27;
  int v28;
  int v29;
  int v30;
  int v31;
  float v32;
  float v33;
  float v34;
  float v35;
  float v36;
  float v37;
  float v38;
  float v39;
  float v40;
  float *v41;
  float *v42;
  float v43;
  float v44;
  float v45;
  float v46;
  float v47;
  float v48;
  float v49;
  float v50;
  float v51;
  float v52;
  uint64_t v53;
  float *v54;
  float *v55;
  float v56;
  float v57;
  float v58;
  float v59;
  float v60;
  float v61;
  float v62;
  float v63;
  float v64;
  float v65;
  float v66;
  float v67;
  uint64_t v68;
  float *v69;
  float *v70;
  float v71;
  float v72;
  float v73;
  float v74;
  float v75;
  float v76;
  float v77;
  uint64_t v78;
  float *v79;
  float *v80;
  float v81;
  float v82;
  float v83;
  float v84;
  float v86;
  float v87;
  float v88;
  float v89;
  float v90;
  float v91;
  float v92;
  float v93;
  float v94;
  float v95;
  float v96;

  v8 = (float)((float)(a4 + a5) + a6) * 0.33333;
  v9 = (int)(float)(v8 + a4) - ((float)(v8 + a4) <= 0.0);
  v10 = (int)(float)(v8 + a5) - ((float)(v8 + a5) <= 0.0);
  v11 = (int)(float)(v8 + a6) - ((float)(v8 + a6) <= 0.0);
  v12 = (float)(v9 + v10 + v11) * 0.16667;
  v13 = (float)v10 - v12;
  v14 = (float)v11 - v12;
  v15 = a4 - (float)((float)v9 - v12);
  v16 = a5 - v13;
  v17 = a6 - v14;
  if (v15 >= v16)
  {
    v19 = 0;
    if (v16 < v17)
    {
      v22 = 0;
      v18 = v15 >= v17;
      v21 = v15 < v17;
      v20 = 1;
      goto LABEL_6;
    }
    v21 = 0;
    v23 = 0;
    v18 = 1;
    v20 = 1;
  }
  else
  {
    v18 = 0;
    if (v16 < v17)
    {
      v19 = 0;
      v20 = 0;
      v21 = 1;
      v22 = 1;
LABEL_6:
      v23 = 1;
      goto LABEL_10;
    }
    v21 = 0;
    v20 = v15 >= v17;
    v23 = v15 < v17;
    v19 = 1;
  }
  v22 = 1;
LABEL_10:
  v24 = (float)(v15 - (float)v18) + 0.16667;
  v25 = (float)(v16 - (float)v19) + 0.16667;
  v26 = (float)(v17 - (float)v21) + 0.16667;
  v28 = v9 + 512;
  v27 = -v28 < 0;
  v28 = v28;
  if (!v27)
    v28 = --(char)v28;
  v29 = v10 + 512;
  v27 = -v29 < 0;
  v29 = v29;
  if (!v27)
    v29 = --(char)v29;
  v30 = v11 + 512;
  if (v30 <= 0)
    v31 = --(char)v30;
  else
    v31 = v30;
  v32 = (float)((float)(0.6 - (float)(v15 * v15)) - (float)(v16 * v16)) - (float)(v17 * v17);
  v33 = 0.0;
  v34 = 0.0;
  v35 = 0.0;
  v36 = 0.0;
  v37 = 0.0;
  v38 = 0.0;
  v39 = 0.0;
  v40 = 0.0;
  if (v32 >= 0.0)
  {
    v41 = (float *)((char *)&grad3u + 12 * (perm_1[perm_1[perm_1[v31] + (uint64_t)v29] + (uint64_t)v28] & 0xF));
    v42 = (float *)((char *)&grad3v + 12 * (perm_1[perm_1[perm_1[v31] + (uint64_t)v29] + (uint64_t)v28] & 0xF));
    v34 = (float)(*v42 * a7) + (float)(a8 * *v41);
    v35 = (float)(v42[1] * a7) + (float)(a8 * v41[1]);
    v36 = (float)(v42[2] * a7) + (float)(a8 * v41[2]);
    v38 = v32 * v32;
    v39 = v38 * v38;
    v40 = (float)(v38 * v38) * (float)((float)((float)(v16 * v35) + (float)(v34 * v15)) + (float)(v36 * v17));
    v37 = (float)((float)(0.6 - (float)(v15 * v15)) - (float)(v16 * v16)) - (float)(v17 * v17);
  }
  v86 = v37;
  v87 = v38;
  v89 = v34;
  v90 = v35;
  v91 = v36;
  v96 = v40;
  v43 = (float)(v15 - (float)v20) + 0.33333;
  v44 = (float)(v16 - (float)v22) + 0.33333;
  v45 = (float)(v17 - (float)v23) + 0.33333;
  v46 = (float)((float)(0.6 - (float)(v24 * v24)) - (float)(v25 * v25)) - (float)(v26 * v26);
  v47 = 0.0;
  v48 = 0.0;
  v49 = 0.0;
  v50 = 0.0;
  v51 = 0.0;
  v52 = 0.0;
  if (v46 >= 0.0)
  {
    v53 = 3 * (perm_1[perm_1[perm_1[v21 + (uint64_t)v31] + (uint64_t)(v19 + v29)] + (uint64_t)(v18 + v28)] & 0xF);
    v54 = (float *)((char *)&grad3u + 4 * v53);
    v55 = (float *)((char *)&grad3v + 4 * v53);
    v33 = (float)(*v55 * a7) + (float)(a8 * *v54);
    v47 = (float)(v55[1] * a7) + (float)(a8 * v54[1]);
    v48 = (float)(v55[2] * a7) + (float)(a8 * v54[2]);
    v50 = v46 * v46;
    v51 = v50 * v50;
    v52 = (float)(v50 * v50) * (float)((float)((float)(v25 * v47) + (float)(v33 * v24)) + (float)(v48 * v26));
    v49 = (float)((float)(0.6 - (float)(v24 * v24)) - (float)(v25 * v25)) - (float)(v26 * v26);
  }
  v94 = (float)(v15 - (float)v18) + 0.16667;
  v95 = v52;
  v88 = v33;
  v92 = v25;
  v93 = v26;
  v56 = (float)(v15 + -1.0) + 0.5;
  v57 = (float)(v16 + -1.0) + 0.5;
  v58 = (float)(v17 + -1.0) + 0.5;
  v59 = (float)((float)(0.6 - (float)(v43 * v43)) - (float)(v44 * v44)) - (float)(v45 * v45);
  v60 = 0.0;
  v61 = 0.0;
  v62 = 0.0;
  v63 = 0.0;
  v64 = 0.0;
  v65 = 0.0;
  v66 = 0.0;
  v67 = 0.0;
  if (v59 >= 0.0)
  {
    v68 = 3 * (perm_1[perm_1[perm_1[v23 + (uint64_t)v31] + (uint64_t)(v22 + v29)] + (uint64_t)(v20 + v28)] & 0xF);
    v69 = (float *)((char *)&grad3u + 4 * v68);
    v70 = (float *)((char *)&grad3v + 4 * v68);
    v61 = (float)(*v70 * a7) + (float)(a8 * *v69);
    v62 = (float)(v70[1] * a7) + (float)(a8 * v69[1]);
    v63 = (float)(v70[2] * a7) + (float)(a8 * v69[2]);
    v65 = v59 * v59;
    v66 = v65 * v65;
    v67 = (float)(v65 * v65) * (float)((float)((float)(v44 * v62) + (float)(v61 * v43)) + (float)(v63 * v45));
    v64 = (float)((float)(0.6 - (float)(v43 * v43)) - (float)(v44 * v44)) - (float)(v45 * v45);
  }
  v71 = (float)((float)(0.6 - (float)(v56 * v56)) - (float)(v57 * v57)) - (float)(v58 * v58);
  v72 = 0.0;
  v73 = 0.0;
  v74 = 0.0;
  v75 = 0.0;
  v76 = 0.0;
  v77 = 0.0;
  if (v71 >= 0.0)
  {
    v78 = 3 * (perm_1[perm_1[perm_1[v31 + 1] + 1 + (uint64_t)v29] + 1 + (uint64_t)v28] & 0xF);
    v79 = (float *)((char *)&grad3u + 4 * v78);
    v80 = (float *)((char *)&grad3v + 4 * v78);
    v60 = (float)(*v80 * a7) + (float)(a8 * *v79);
    v72 = (float)(v80[1] * a7) + (float)(a8 * v79[1]);
    v73 = (float)(v80[2] * a7) + (float)(a8 * v79[2]);
    v75 = v71 * v71;
    v76 = v75 * v75;
    v77 = (float)(v75 * v75) * (float)((float)((float)(v57 * v72) + (float)(v60 * v56)) + (float)(v73 * v58));
    v74 = (float)((float)(0.6 - (float)(v56 * v56)) - (float)(v57 * v57)) - (float)(v58 * v58);
  }
  if (a1 && a2 && a3)
  {
    v81 = (float)((float)((float)(v16 * v90) + (float)(v89 * v15)) + (float)(v91 * v17)) * (float)(v86 * v87);
    *a1 = v15 * v81;
    *a2 = v16 * v81;
    *a3 = v17 * v81;
    v82 = (float)((float)((float)(v92 * v47) + (float)(v88 * v94)) + (float)(v48 * v93)) * (float)(v49 * v50);
    *a1 = *a1 + (float)(v82 * v94);
    *a2 = *a2 + (float)(v82 * v92);
    *a3 = *a3 + (float)(v82 * v93);
    v83 = (float)((float)((float)(v44 * v62) + (float)(v61 * v43)) + (float)(v63 * v45)) * (float)(v64 * v65);
    *a1 = *a1 + (float)(v83 * v43);
    *a2 = *a2 + (float)(v83 * v44);
    *a3 = *a3 + (float)(v83 * v45);
    v84 = (float)((float)((float)(v57 * v72) + (float)(v60 * v56)) + (float)(v73 * v58)) * (float)(v74 * v75);
    *a1 = *a1 + (float)(v84 * v56);
    *a2 = *a2 + (float)(v84 * v57);
    *a3 = *a3 + (float)(v84 * v58);
    *a1 = *a1 * -8.0;
    *a2 = *a2 * -8.0;
    *a3 = *a3 * -8.0;
    *a1 = (float)((float)((float)((float)(v88 * v51) + (float)(v39 * v89)) + (float)(v66 * v61)) + (float)(v76 * v60))
        + *a1;
    *a2 = (float)((float)((float)((float)(v47 * v51) + (float)(v39 * v90)) + (float)(v66 * v62)) + (float)(v76 * v72))
        + *a2;
    *a3 = (float)((float)((float)((float)(v48 * v51) + (float)(v39 * v91)) + (float)(v66 * v63)) + (float)(v76 * v73))
        + *a3;
    *a1 = *a1 * 28.0;
    *a2 = *a2 * 28.0;
    *a3 = *a3 * 28.0;
  }
  return (float)((float)((float)(v96 + v95) + v67) + v77) * 28.0;
}

float srdnoise3_sincos_vector(float32x4_t *a1, float32x4_t a2, float a3, float a4)
{
  int8x16_t v4;
  float32x4_t v5;
  int8x16_t v6;
  float32x4_t v7;
  float32x4_t v8;
  float32x4_t v14;
  float32x4_t v15;
  float v16;
  float v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  int16x4_t v25;
  unsigned __int8 *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  float32x4_t v31;
  int8x16_t v32;
  int8x16_t v33;
  int8x16_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  int8x16_t v38;
  int32x2_t v39;
  float32x4_t v40;
  int8x16_t v41;
  float32x4_t v42;
  int8x16_t v43;
  float32x4_t v44;
  int8x16_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v52;
  float32x4_t v53;
  float32x4_t v54;
  int8x16_t v55;

  v4 = (int8x16_t)vmulq_f32(a2, (float32x4_t)xmmword_208FD7490);
  *(float32x2_t *)v4.i8 = vadd_f32(*(float32x2_t *)v4.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v4, v4, 8uLL));
  v5 = vrndmq_f32(vaddq_f32((float32x4_t)vdupq_lane_s32((int32x2_t)vadd_f32(*(float32x2_t *)v4.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v4.i8, 1)), 0), a2));
  v6 = (int8x16_t)vmulq_f32(v5, (float32x4_t)xmmword_208FD74A0);
  *(float32x2_t *)v6.i8 = vadd_f32(*(float32x2_t *)v6.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v6, v6, 8uLL));
  v7 = vsubq_f32(a2, vsubq_f32(v5, (float32x4_t)vdupq_lane_s32((int32x2_t)vadd_f32(*(float32x2_t *)v6.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v6.i8, 1)), 0)));
  v8 = v7;
  v8.i32[3] = 0;
  __asm { FMOV            V5.4S, #1.0 }
  v14 = (float32x4_t)vbslq_s8((int8x16_t)vcgeq_f32(v8, (float32x4_t)vzip2q_s32(vzip1q_s32((int32x4_t)v8, (int32x4_t)vextq_s8((int8x16_t)v8, (int8x16_t)v8, 0xCuLL)), (int32x4_t)v8)), _Q5, (int8x16_t)0);
  v15 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v8, (float32x4_t)vuzp2q_s32((int32x4_t)vextq_s8((int8x16_t)v8, (int8x16_t)v8, 4uLL), (int32x4_t)v8)), _Q5, (int8x16_t)0);
  if (v7.f32[2] <= v7.f32[0])
    v16 = 0.0;
  else
    v16 = 1.0;
  v14.f32[2] = v16;
  if (v7.f32[0] < v7.f32[2])
    v17 = 0.0;
  else
    v17 = 1.0;
  v15.f32[0] = v17;
  v18 = vminnmq_f32(v14, v15);
  v19 = vmaxnmq_f32(v14, v15);
  v22 = vaddq_f32(vsubq_f32(v7, v18), (float32x4_t)vdupq_n_s32(0x3E2AAAABu));
  v23 = vaddq_f32(vsubq_f32(v7, v19), (float32x4_t)vdupq_n_s32(0x3EAAAAABu));
  __asm { FMOV            V18.4S, #-1.0 }
  v21 = vaddq_f32(v7, _Q18);
  _Q18.i64[0] = 0x3F0000003F000000;
  _Q18.i64[1] = 0x3F0000003F000000;
  v24 = vaddq_f32(v21, _Q18);
  v22.i32[3] = 0;
  v23.i32[3] = 0;
  v24.i32[3] = 0;
  v25 = vmovn_s32(vcvtq_s32_f32(v5));
  v26 = &perm_1[v25.u8[4]];
  v27 = perm_1[perm_1[*v26 + (unint64_t)v25.u8[2]] + (unint64_t)v25.u8[0]] & 0xF;
  v28 = perm_1[perm_1[perm_1[(int)v18.f32[2] + (unint64_t)v25.u8[4]] + (uint64_t)((int)v18.f32[1] + v25.u8[2])]
             + (uint64_t)((int)v18.f32[0] + v25.u8[0])] & 0xF;
  v29 = perm_1[perm_1[perm_1[(int)v19.f32[2] + (unint64_t)v25.u8[4]] + (uint64_t)((int)v19.f32[1] + v25.u8[2])]
             + (uint64_t)((int)v19.f32[0] + v25.u8[0])] & 0xF;
  v30 = perm_1[v25.u8[0]
             + 1
             + (unint64_t)perm_1[v25.u8[2] + 1 + (unint64_t)v26[1]]] & 0xF;
  v31 = vmulq_f32(v8, v8);
  *(float32x2_t *)v31.f32 = vadd_f32(*(float32x2_t *)v31.f32, (float32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v31, (int8x16_t)v31, 8uLL));
  v32 = (int8x16_t)vmulq_f32(v22, v22);
  *(float32x2_t *)v32.i8 = vadd_f32(*(float32x2_t *)v32.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v32, v32, 8uLL));
  v33 = (int8x16_t)vmulq_f32(v23, v23);
  *(float32x2_t *)v33.i8 = vadd_f32(*(float32x2_t *)v33.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v33, v33, 8uLL));
  v34 = (int8x16_t)vmulq_f32(v24, v24);
  *(int32x2_t *)v35.f32 = vzip1_s32(*(int32x2_t *)v31.f32, *(int32x2_t *)v32.i8);
  v35.i32[2] = v33.i32[0];
  *(float32x2_t *)v34.i8 = vadd_f32(*(float32x2_t *)v34.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v34, v34, 8uLL));
  v35.i32[3] = v34.i32[0];
  *(int32x2_t *)v31.f32 = vzip2_s32(*(int32x2_t *)v31.f32, *(int32x2_t *)v32.i8);
  v31.i64[1] = __PAIR64__(v34.u32[1], vdup_lane_s32(*(int32x2_t *)v33.i8, 1).u32[0]);
  v36 = vaddq_f32(v35, v31);
  v37 = vmlaq_n_f32(vmulq_n_f32(grad3v_vector[v27], a3), grad3u_vector[v27], a4);
  v38 = (int8x16_t)vmulq_f32(v8, v37);
  v39 = (int32x2_t)vadd_f32(*(float32x2_t *)v38.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v38, v38, 8uLL));
  v40 = vmlaq_n_f32(vmulq_n_f32(grad3v_vector[v28], a3), grad3u_vector[v28], a4);
  v41 = (int8x16_t)vmulq_f32(v22, v40);
  *(float32x2_t *)v35.f32 = vadd_f32(*(float32x2_t *)v41.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v41, v41, 8uLL));
  v42 = vmlaq_n_f32(vmulq_n_f32(grad3v_vector[v29], a3), grad3u_vector[v29], a4);
  v43 = (int8x16_t)vmulq_f32(v23, v42);
  *(float32x2_t *)v43.i8 = vadd_f32(*(float32x2_t *)v43.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v43, v43, 8uLL));
  v44 = vmlaq_n_f32(vmulq_n_f32(grad3v_vector[v30], a3), grad3u_vector[v30], a4);
  v45 = (int8x16_t)vmulq_f32(v24, v44);
  *(float32x2_t *)v45.i8 = vadd_f32(*(float32x2_t *)v45.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v45, v45, 8uLL));
  *(int32x2_t *)v46.f32 = vzip1_s32(v39, *(int32x2_t *)v35.f32);
  v46.i64[1] = __PAIR64__(v45.u32[0], v43.u32[0]);
  *(int32x2_t *)v35.f32 = vzip2_s32(v39, *(int32x2_t *)v35.f32);
  v35.i64[1] = __PAIR64__(v45.u32[1], vdup_lane_s32(*(int32x2_t *)v43.i8, 1).u32[0]);
  v47 = vaddq_f32(v46, v35);
  v48 = vmaxnmq_f32(vsubq_f32((float32x4_t)vdupq_n_s32(0x3F19999Au), v36), (float32x4_t)0);
  v49 = vmulq_f32(v48, v48);
  v50 = vmulq_f32(v49, v49);
  __asm { FMOV            V18.4S, #28.0 }
  if (a1)
  {
    v52 = vmulq_f32(vmulq_f32(v48, v49), v47);
    v53 = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_n_f32(vmulq_lane_f32(v22, *(float32x2_t *)v52.f32, 1), v8, v52.f32[0]), v23, v52, 2), v24, v52, 3);
    v54.i64[0] = 0xC1000000C1000000;
    v54.i64[1] = 0xC1000000C1000000;
    *a1 = vmulq_f32(vaddq_f32(vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_n_f32(vmulq_lane_f32(v40, *(float32x2_t *)v50.f32, 1), v37, v50.f32[0]), v42, v50, 2), v44, v50, 3), vmulq_f32(v53, v54)), _Q18);
  }
  v55 = (int8x16_t)vmulq_f32(vmulq_f32(v50, v47), _Q18);
  return vaddv_f32(vadd_f32(*(float32x2_t *)v55.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v55, v55, 8uLL)));
}

float PKGet_PTM_RATIO()
{
  return *(float *)&_PK_PTM_RATIO;
}

float PKGet_INV_PTM_RATIO()
{
  return *(float *)&_PK_PKGet_INV_PTM_RATIO;
}

float PKSet_PTM_Ratio(float a1)
{
  float result;

  _PK_PTM_RATIO = LODWORD(a1);
  result = 1.0 / a1;
  _PK_PKGet_INV_PTM_RATIO = LODWORD(result);
  return result;
}

float32_t PKPhysicsReapplyScaleOnFixture(b2FixtureDef *a1, b2Fixture *a2, float a3, float a4)
{
  float32x2_t *v4;
  float v5;
  b2Shape *var0;
  b2Shape *v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  float32x2_t *v11;
  float32x2_t *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  float32x2_t v17;
  uint64_t v18;
  float *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  float *v23;
  float v24;
  float32x2_t v25;
  float v26;
  float *v27;
  float v28;
  float32x2_t *v29;
  unint64_t v30;
  unint64_t v31;
  float32x2_t *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  float32x2_t *v36;
  uint64_t v37;
  float32x2_t v38;
  float v39;
  float32_t result;

  v4 = (float32x2_t *)*((_QWORD *)a2 + 4);
  v5 = a3 * a4;
  switch(v4[1].i32[0])
  {
    case 0:
      v4[2] = vmul_f32(vabs_f32((float32x2_t)__PAIR64__(LODWORD(a4), LODWORD(a3))), *(float32x2_t *)((char *)a1->var0 + 16));
      break;
    case 1:
      var0 = a1->var0;
      if (*((_BYTE *)a1->var0 + 48))
        v4[4] = vmul_f32(*(float32x2_t *)((char *)var0 + 32), (float32x2_t)__PAIR64__(LODWORD(a4), LODWORD(a3)));
      *(float32x4_t *)v4[2].f32 = vmulq_f32(*((float32x4_t *)var0 + 1), (float32x4_t)vdupq_lane_s64(__SPAIR64__(LODWORD(a4), LODWORD(a3)), 0));
      if (*((_BYTE *)var0 + 49))
        v4[5] = vmul_f32(*(float32x2_t *)((char *)var0 + 40), (float32x2_t)__PAIR64__(LODWORD(a4), LODWORD(a3)));
      break;
    case 2:
      v7 = a1->var0;
      v8 = *((_QWORD *)a1->var0 + 2);
      v9 = *((_QWORD *)a1->var0 + 3) - v8;
      v10 = (unint64_t)v9 >> 3;
      v11 = (float32x2_t *)*((_QWORD *)a2 + 4);
      if (v5 >= 0.0)
      {
        if ((int)v10 >= 1)
        {
          v35 = 0;
          do
          {
            *(float32x2_t *)(*(_QWORD *)&v4[2] + v35) = vmul_f32(*(float32x2_t *)(*((_QWORD *)v7 + 2) + v35), (float32x2_t)__PAIR64__(LODWORD(a4), LODWORD(a3)));
            *(_QWORD *)(*(_QWORD *)&v4[5] + v35) = *(_QWORD *)(*((_QWORD *)v7 + 5) + v35);
            v35 += 8;
          }
          while ((v9 & 0x7FFFFFFF8) != v35);
          v11 = (float32x2_t *)*((_QWORD *)a2 + 4);
        }
      }
      else if ((int)v10 >= 1)
      {
        v12 = (float32x2_t *)v4[2];
        v13 = ((unint64_t)v9 >> 3);
        v14 = (v10 << 32) - 0x100000000;
        v15 = v13;
        do
        {
          *v12++ = vmul_f32(*(float32x2_t *)(v8 + (v14 >> 29)), (float32x2_t)__PAIR64__(LODWORD(a4), LODWORD(a3)));
          v14 -= 0x100000000;
          --v15;
        }
        while (v15);
        v16 = 0;
        v17 = v4[2];
        v18 = (int)(v9 >> 3);
        v19 = (float *)(*(_QWORD *)&v17 + 4);
        v20 = 4;
        do
        {
          v21 = v16 + 1;
          if (v16 + 1 < v18)
            v22 = v16 + 1;
          else
            v22 = 0;
          v23 = (float *)(*(_QWORD *)&v17 + 8 * v22);
          v24 = *v23 - *(v19 - 1);
          v25.f32[0] = v23[1] - *v19;
          if ((float)((float)(v25.f32[0] * v25.f32[0]) + (float)(v24 * v24)) >= 1.4211e-14)
          {
            v26 = -v24;
            v27 = (float *)(*(_QWORD *)&v4[5] + v20);
            *(v27 - 1) = v25.f32[0];
            *v27 = -v24;
            v28 = sqrtf((float)(v24 * v24) + (float)(v25.f32[0] * v25.f32[0]));
            if (v28 >= 0.00000011921)
            {
              v25.f32[1] = v26;
              *(float32x2_t *)(v27 - 1) = vmul_n_f32(v25, 1.0 / v28);
            }
          }
          else
          {
            *(_QWORD *)(*(_QWORD *)&v4[5] + 8 * v16) = 0x3F80000000000000;
          }
          v19 += 2;
          v20 += 8;
          v16 = v21;
        }
        while (v13 != v21);
        v11 = v4;
      }
      v4[8] = vmul_f32(*(float32x2_t *)((char *)v7 + 64), (float32x2_t)__PAIR64__(LODWORD(a4), LODWORD(a3)));
      v4 = v11;
      break;
    case 3:
      v29 = (float32x2_t *)*((_QWORD *)a1->var0 + 2);
      v30 = *((_QWORD *)a1->var0 + 3) - (_QWORD)v29;
      v31 = v30 >> 3;
      if (v5 >= 0.0)
      {
        if ((int)v31 >= 1)
        {
          v36 = (float32x2_t *)v4[2];
          v37 = (v30 >> 3);
          do
          {
            v38 = *v29++;
            *v36++ = vmul_f32(v38, (float32x2_t)__PAIR64__(LODWORD(a4), LODWORD(a3)));
            --v37;
          }
          while (v37);
        }
      }
      else if ((int)v31 >= 1)
      {
        v32 = (float32x2_t *)v4[2];
        v33 = (v30 >> 3);
        v34 = (v31 << 32) - 0x100000000;
        do
        {
          *v32++ = vmul_f32(*(float32x2_t *)((char *)v29 + (v34 >> 29)), (float32x2_t)__PAIR64__(LODWORD(a4), LODWORD(a3)));
          v34 -= 0x100000000;
          --v33;
        }
        while (v33);
      }
      break;
    default:
      break;
  }
  v39 = *((float *)a1->var0 + 3);
  result = (float)(v39 * hypotf(a3, a4)) / 1.4142;
  v4[1].f32[1] = result;
  return result;
}

void b2ChainShape::GetVertex()
{
  __assert_rtn("GetVertex", "b2ChainShape.h", 94, "0 <= index && index < GetVertexCount()");
}

void b2CollideEdgeAndCircle()
{
  __assert_rtn("b2CollideEdgeAndCircle", "b2CollideEdge.cpp", 127, "den > 0.0f");
}

void b2CollidePolygons()
{
  __assert_rtn("b2FindIncidentEdge", "b2CollidePolygon.cpp", 151, "0 <= edge1 && edge1 < poly1->GetVertexCount()");
}

void b2EdgeSeparation()
{
  __assert_rtn("b2EdgeSeparation", "b2CollidePolygon.cpp", 32, "0 <= edge1 && edge1 < poly1->GetVertexCount()");
}

void b2DistanceProxy::Set()
{
  __assert_rtn("Set", "b2Distance.cpp", 90, "false");
}

{
  __assert_rtn("Set", "b2Distance.cpp", 53, "0 <= index && index < chain->GetVertexCount()");
}

void b2Distance()
{
  __assert_rtn("b2Distance", "b2Distance.cpp", 513, "false");
}

void b2Distance(uint64_t a1, uint64_t a2, uint64_t a3)
{
  OUTLINED_FUNCTION_0("GetVertex", "b2Distance.h", a3, "0 <= index && index < GetVertexCount()");
}

void b2Simplex::ReadCache()
{
  __assert_rtn("ReadCache", "b2Distance.cpp", 111, "cache->count <= 3");
}

void b2Simplex::GetClosestPoint()
{
  __assert_rtn("GetClosestPoint", "b2Distance.cpp", 217, "false");
}

{
  __assert_rtn("GetClosestPoint", "b2Distance.cpp", 204, "false");
}

void b2Simplex::GetSearchDirection()
{
  __assert_rtn("GetSearchDirection", "b2Distance.cpp", 194, "false");
}

void b2Simplex::GetWitnessPoints()
{
  __assert_rtn("GetWitnessPoints", "b2Distance.cpp", 246, "false");
}

{
  __assert_rtn("GetWitnessPoints", "b2Distance.cpp", 227, "false");
}

void b2Simplex::GetMetric()
{
  __assert_rtn("GetMetric", "b2Distance.cpp", 269, "false");
}

{
  __assert_rtn("GetMetric", "b2Distance.cpp", 256, "false");
}

void b2DynamicTree::AllocateNode()
{
  __assert_rtn("AllocateNode", "b2DynamicTree.cpp", 62, "m_nodeCount == m_nodeCapacity");
}

void b2DynamicTree::FreeNode()
{
  __assert_rtn("FreeNode", "b2DynamicTree.cpp", 100, "0 < m_nodeCount");
}

{
  __assert_rtn("FreeNode", "b2DynamicTree.cpp", 99, "0 <= nodeId && nodeId < m_nodeCapacity");
}

void b2DynamicTree::InsertLeaf()
{
  __assert_rtn("InsertLeaf", "b2DynamicTree.cpp", 311, "child1 != (-1)");
}

{
  __assert_rtn("InsertLeaf", "b2DynamicTree.cpp", 312, "child2 != (-1)");
}

void b2DynamicTree::DestroyProxy()
{
  __assert_rtn("DestroyProxy", "b2DynamicTree.cpp", 130, "m_nodes[proxyId].IsLeaf()");
}

{
  __assert_rtn("DestroyProxy", "b2DynamicTree.cpp", 129, "0 <= proxyId && proxyId < m_nodeCapacity");
}

void b2DynamicTree::MoveProxy()
{
  __assert_rtn("MoveProxy", "b2DynamicTree.cpp", 140, "m_nodes[proxyId].IsLeaf()");
}

{
  __assert_rtn("MoveProxy", "b2DynamicTree.cpp", 138, "0 <= proxyId && proxyId < m_nodeCapacity");
}

void b2DynamicTree::Balance()
{
  __assert_rtn("Balance", "b2DynamicTree.cpp", 386, "iA != (-1)");
}

{
  __assert_rtn("Balance", "b2DynamicTree.cpp", 411, "0 <= iF && iF < m_nodeCapacity");
}

{
  __assert_rtn("Balance", "b2DynamicTree.cpp", 412, "0 <= iG && iG < m_nodeCapacity");
}

{
  __assert_rtn("Balance", "b2DynamicTree.cpp", 428, "m_nodes[C->parent].child2 == iA");
}

{
  __assert_rtn("Balance", "b2DynamicTree.cpp", 471, "0 <= iD && iD < m_nodeCapacity");
}

{
  __assert_rtn("Balance", "b2DynamicTree.cpp", 472, "0 <= iE && iE < m_nodeCapacity");
}

{
  __assert_rtn("Balance", "b2DynamicTree.cpp", 488, "m_nodes[B->parent].child2 == iA");
}

{
  __assert_rtn("Balance", "b2DynamicTree.cpp", 397, "0 <= iC && iC < m_nodeCapacity");
}

{
  __assert_rtn("Balance", "b2DynamicTree.cpp", 396, "0 <= iB && iB < m_nodeCapacity");
}

void b2DynamicTree::ComputeHeight()
{
  __assert_rtn("ComputeHeight", "b2DynamicTree.cpp", 567, "0 <= nodeId && nodeId < m_nodeCapacity");
}

void b2DynamicTree::ValidateStructure()
{
  __assert_rtn("ValidateStructure", "b2DynamicTree.cpp", 607, "node->height == 0");
}

{
  __assert_rtn("ValidateStructure", "b2DynamicTree.cpp", 606, "child2 == (-1)");
}

{
  __assert_rtn("ValidateStructure", "b2DynamicTree.cpp", 612, "0 <= child2 && child2 < m_nodeCapacity");
}

{
  __assert_rtn("ValidateStructure", "b2DynamicTree.cpp", 615, "m_nodes[child2].parent == index");
}

{
  __assert_rtn("ValidateStructure", "b2DynamicTree.cpp", 614, "m_nodes[child1].parent == index");
}

{
  __assert_rtn("ValidateStructure", "b2DynamicTree.cpp", 611, "0 <= child1 && child1 < m_nodeCapacity");
}

{
  __assert_rtn("ValidateStructure", "b2DynamicTree.cpp", 595, "m_nodes[index].parent == (-1)");
}

void b2DynamicTree::ValidateMetrics()
{
  __assert_rtn("ValidateMetrics", "b2DynamicTree.cpp", 637, "node->height == 0");
}

{
  __assert_rtn("ValidateMetrics", "b2DynamicTree.cpp", 636, "child2 == (-1)");
}

{
  __assert_rtn("ValidateMetrics", "b2DynamicTree.cpp", 642, "0 <= child2 && child2 < m_nodeCapacity");
}

{
  __assert_rtn("ValidateMetrics", "b2DynamicTree.cpp", 654, "aabb.upperBound == node->aabb.upperBound");
}

{
  __assert_rtn("ValidateMetrics", "b2DynamicTree.cpp", 653, "aabb.lowerBound == node->aabb.lowerBound");
}

{
  __assert_rtn("ValidateMetrics", "b2DynamicTree.cpp", 648, "node->height == height");
}

{
  __assert_rtn("ValidateMetrics", "b2DynamicTree.cpp", 641, "0 <= child1 && child1 < m_nodeCapacity");
}

void b2DynamicTree::Validate()
{
  __assert_rtn("Validate", "b2DynamicTree.cpp", 676, "m_nodeCount + freeCount == m_nodeCapacity");
}

{
  __assert_rtn("Validate", "b2DynamicTree.cpp", 674, "GetHeight() == ComputeHeight()");
}

{
  __assert_rtn("Validate", "b2DynamicTree.cpp", 669, "0 <= freeIndex && freeIndex < m_nodeCapacity");
}

void b2DynamicTree::GetMaxBalance()
{
  __assert_rtn("GetMaxBalance", "b2DynamicTree.cpp", 690, "node->IsLeaf() == false");
}

void b2TimeOfImpact()
{
  __assert_rtn("b2TimeOfImpact", "b2TimeOfImpact.cpp", 273, "target > tolerance");
}

void b2SeparationFunction::Initialize()
{
  __assert_rtn("Initialize", "b2TimeOfImpact.cpp", 50, "0 < count && count < 3");
}

void b2SeparationFunction::FindMinSeparation()
{
  __assert_rtn("FindMinSeparation", "b2TimeOfImpact.cpp", 183, "false");
}

void b2SeparationFunction::Evaluate()
{
  __assert_rtn("Evaluate", "b2TimeOfImpact.cpp", 235, "false");
}

void b2ChainShape::CreateChain()
{
  __assert_rtn("CreateChain", "b2ChainShape.cpp", 45, "count >= 2");
}

void b2ChainShape::GetChildEdge()
{
  __assert_rtn("GetChildEdge", "b2ChainShape.cpp", 85, "0 <= index && index < GetVertexCount() - 1");
}

void b2ChainShape::RayCast()
{
  __assert_rtn("RayCast", "b2ChainShape.cpp", 132, "childIndex < GetVertexCount()");
}

void b2ChainShape::ComputeAABB()
{
  __assert_rtn("ComputeAABB", "b2ChainShape.cpp", 151, "childIndex < GetVertexCount()");
}

void b2PolygonShape::RayCast()
{
  __assert_rtn("RayCast", "b2PolygonShape.cpp", 349, "0.0f <= lower && lower <= input.maxFraction");
}

void b2PolygonShape::ComputeMass()
{
  __assert_rtn("ComputeMass", "b2PolygonShape.cpp", 406, "GetVertexCount() >= 3");
}

void MechanicsCollisionCallback::ReportFixture()
{
  __assert_rtn("GetAABB", "b2Fixture.h", 295, "0 <= childIndex && childIndex < m_proxies.size()");
}

void b2StackAllocator::Allocate()
{
  __assert_rtn("Allocate", "b2StackAllocator.cpp", 38, "m_entryCount < b2_maxStackEntries");
}

void b2StackAllocator::Free()
{
  __assert_rtn("Free", "b2StackAllocator.cpp", 63, "m_entryCount > 0");
}

{
  __assert_rtn("Free", "b2StackAllocator.cpp", 65, "p == entry->data");
}

void b2Body::b2Body()
{
  __assert_rtn("b2Body", "b2Body.mm", 56, "bd->position.IsValid()");
}

{
  __assert_rtn("b2Body", "b2Body.mm", 57, "bd->linearVelocity.IsValid()");
}

{
  __assert_rtn("b2Body", "b2Body.mm", 58, "b2IsValid(bd->angle)");
}

{
  __assert_rtn("b2Body", "b2Body.mm", 59, "b2IsValid(bd->angularVelocity)");
}

{
  __assert_rtn("b2Body", "b2Body.mm", 60, "b2IsValid(bd->angularDamping) && bd->angularDamping >= 0.0f");
}

{
  __assert_rtn("b2Body", "b2Body.mm", 61, "b2IsValid(bd->linearDamping) && bd->linearDamping >= 0.0f");
}

void b2Body::SetType()
{
  __assert_rtn("SetType", "b2Body.mm", 169, "m_world->IsLocked() == false");
}

void b2Body::CreateFixture()
{
  __assert_rtn("CreateFixture", "b2Body.mm", 221, "m_world->IsLocked() == false");
}

void b2Body::DestroyFixture()
{
  __assert_rtn("DestroyFixture", "b2Body.mm", 274, "m_fixtureCount > 0");
}

{
  __assert_rtn("DestroyFixture", "b2Body.mm", 290, "found");
}

{
  __assert_rtn("DestroyFixture", "b2Body.mm", 271, "fixture->m_body == this");
}

{
  __assert_rtn("DestroyFixture", "b2Body.mm", 265, "m_world->IsLocked() == false");
}

void b2Body::SetMassData()
{
  __assert_rtn("SetMassData", "b2Body.mm", 423, "m_I > 0.0f");
}

{
  __assert_rtn("SetMassData", "b2Body.mm", 397, "m_world->IsLocked() == false");
}

void b2Body::SetTransform()
{
  __assert_rtn("SetTransform", "b2Body.mm", 561, "m_world->IsLocked() == false");
}

void b2Body::SetActive()
{
  __assert_rtn("SetActive", "b2Body.mm", 602, "m_world->IsLocked() == false");
}

void b2ContactManager::QueryCallback()
{
  __assert_rtn("GetCollisionBits", "b2DynamicTree.h", 177, "0 <= proxyId && proxyId < m_nodeCapacity");
}

{
  __assert_rtn("GetCategoryBits", "b2DynamicTree.h", 173, "0 <= proxyId && proxyId < m_nodeCapacity");
}

void b2ContactManager::FindMinimumTOI()
{
  __assert_rtn("FindMinimumTOI", "b2ContactManager.cpp", 378, "alpha0 < 1.0f");
}

void b2ContactManager::FindNewContacts()
{
  __assert_rtn("GetFixtureProxy", "b2DynamicTree.h", 162, "0 <= proxyId && proxyId < m_nodeCapacity");
}

{
  __assert_rtn("GetFatAABB", "b2DynamicTree.h", 168, "0 <= proxyId && proxyId < m_nodeCapacity");
}

void b2Island::b2Island(void **a1, void **a2, uint64_t a3)
{
  void *v5;
  void *v6;

  v5 = *a1;
  if (v5)
  {
    *(_QWORD *)(a3 + 48) = v5;
    operator delete(v5);
  }
  v6 = *a2;
  if (*a2)
  {
    *(_QWORD *)(a3 + 24) = v6;
    operator delete(v6);
  }
}

void b2Island::SolveTOI()
{
  __assert_rtn("SolveTOI", "b2Island.mm", 405, "toiIndexB < bodyCount");
}

{
  __assert_rtn("SolveTOI", "b2Island.mm", 404, "toiIndexA < bodyCount");
}

void b2World::CreateBody()
{
  __assert_rtn("CreateBody", "b2World.mm", 186, "IsLocked() == false");
}

void b2World::DestroyBody()
{
  __assert_rtn("DestroyBody", "b2World.mm", 209, "m_bodyCount > 0");
}

{
  __assert_rtn("DestroyBody", "b2World.mm", 210, "IsLocked() == false");
}

void b2World::DestroyJoint()
{
  __assert_rtn("DestroyJoint", "b2World.mm", 396, "m_jointCount > 0");
}

{
  __assert_rtn("DestroyJoint", "b2World.mm", 326, "IsLocked() == false");
}

void b2World::CreateJoint()
{
  __assert_rtn("CreateJoint", "b2World.mm", 287, "IsLocked() == false");
}

void b2DynamicTree::RayCast<b2WorldRayCastWrapper>()
{
  __assert_rtn("RayCast", "b2DynamicTree.h", 227, "r.LengthSquared() > 0.0f");
}

void b2ChainAndCircleContact::b2ChainAndCircleContact()
{
  __assert_rtn("b2ChainAndCircleContact", "b2ChainAndCircleContact.cpp", 40, "m_fixtureB->GetType() == b2Shape::e_circle");
}

{
  __assert_rtn("b2ChainAndCircleContact", "b2ChainAndCircleContact.cpp", 39, "m_fixtureA->GetType() == b2Shape::e_chain");
}

void b2ChainAndPolygonContact::b2ChainAndPolygonContact()
{
  __assert_rtn("b2ChainAndPolygonContact", "b2ChainAndPolygonContact.cpp", 40, "m_fixtureB->GetType() == b2Shape::e_polygon");
}

{
  __assert_rtn("b2ChainAndPolygonContact", "b2ChainAndPolygonContact.cpp", 39, "m_fixtureA->GetType() == b2Shape::e_chain");
}

void b2CircleContact::b2CircleContact()
{
  __assert_rtn("b2CircleContact", "b2CircleContact.cpp", 41, "m_fixtureB->GetType() == b2Shape::e_circle");
}

{
  __assert_rtn("b2CircleContact", "b2CircleContact.cpp", 40, "m_fixtureA->GetType() == b2Shape::e_circle");
}

void b2Contact::AddType()
{
  __assert_rtn("AddType", "b2Contact.cpp", 63, "0 <= type1 && type1 < b2Shape::e_typeCount");
}

{
  __assert_rtn("AddType", "b2Contact.cpp", 64, "0 <= type2 && type2 < b2Shape::e_typeCount");
}

void b2Contact::Create()
{
  __assert_rtn("Create", "b2Contact.cpp", 87, "0 <= type1 && type1 < b2Shape::e_typeCount");
}

{
  __assert_rtn("Create", "b2Contact.cpp", 88, "0 <= type2 && type2 < b2Shape::e_typeCount");
}

void b2Contact::Destroy()
{
  __assert_rtn("Destroy", "b2Contact.cpp", 116, "s_initialized == true");
}

void b2ContactSolver::b2ContactSolver()
{
  __assert_rtn("b2ContactSolver", "b2ContactSolver.cpp", 73, "pointCount > 0");
}

void b2ContactSolver::InitializeVelocityConstraints()
{
  __assert_rtn("InitializeVelocityConstraints", "b2ContactSolver.cpp", 170, "manifold->pointCount > 0");
}

void b2ContactSolver::SolveVelocityConstraints()
{
  __assert_rtn("SolveVelocityConstraints", "b2ContactSolver.cpp", 436, "a.x >= 0.0f && a.y >= 0.0f");
}

void b2PositionSolverManifold::Initialize()
{
  __assert_rtn("Initialize", "b2ContactSolver.cpp", 655, "pc->pointCount > 0");
}

void b2EdgeAndCircleContact::b2EdgeAndCircleContact()
{
  __assert_rtn("b2EdgeAndCircleContact", "b2EdgeAndCircleContact.cpp", 39, "m_fixtureB->GetType() == b2Shape::e_circle");
}

{
  __assert_rtn("b2EdgeAndCircleContact", "b2EdgeAndCircleContact.cpp", 38, "m_fixtureA->GetType() == b2Shape::e_edge");
}

void b2EdgeAndPolygonContact::b2EdgeAndPolygonContact()
{
  __assert_rtn("b2EdgeAndPolygonContact", "b2EdgeAndPolygonContact.cpp", 39, "m_fixtureB->GetType() == b2Shape::e_polygon");
}

{
  __assert_rtn("b2EdgeAndPolygonContact", "b2EdgeAndPolygonContact.cpp", 38, "m_fixtureA->GetType() == b2Shape::e_edge");
}

void b2PolygonAndCircleContact::b2PolygonAndCircleContact()
{
  __assert_rtn("b2PolygonAndCircleContact", "b2PolygonAndCircleContact.cpp", 39, "m_fixtureB->GetType() == b2Shape::e_circle");
}

{
  __assert_rtn("b2PolygonAndCircleContact", "b2PolygonAndCircleContact.cpp", 38, "m_fixtureA->GetType() == b2Shape::e_polygon");
}

void b2PolygonContact::b2PolygonContact()
{
  __assert_rtn("b2PolygonContact", "b2PolygonContact.cpp", 42, "m_fixtureB->GetType() == b2Shape::e_polygon");
}

{
  __assert_rtn("b2PolygonContact", "b2PolygonContact.cpp", 41, "m_fixtureA->GetType() == b2Shape::e_polygon");
}

void b2FrictionJoint::SetMaxForce()
{
  __assert_rtn("SetMaxForce", "b2FrictionJoint.cpp", 217, "b2IsValid(force) && force >= 0.0f");
}

void b2FrictionJoint::SetMaxTorque()
{
  __assert_rtn("SetMaxTorque", "b2FrictionJoint.cpp", 228, "b2IsValid(torque) && torque >= 0.0f");
}

void b2GearJoint::b2GearJoint()
{
  __assert_rtn("b2GearJoint", "b2GearJoint.cpp", 51, "m_typeB == e_revoluteJoint || m_typeB == e_prismaticJoint");
}

{
  __assert_rtn("b2GearJoint", "b2GearJoint.cpp", 50, "m_typeA == e_revoluteJoint || m_typeA == e_prismaticJoint");
}

void b2GearJoint::SetRatio()
{
  __assert_rtn("SetRatio", "b2GearJoint.cpp", 389, "b2IsValid(ratio)");
}

void b2QuadtreeAndChainContact::b2QuadtreeAndChainContact()
{
  __assert_rtn("b2QuadtreeAndChainContact", "b2QuadtreeAndOtherContact.cpp", 26, "m_fixtureB->GetType() == b2Shape::e_chain");
}

{
  __assert_rtn("b2QuadtreeAndChainContact", "b2QuadtreeAndOtherContact.cpp", 25, "m_fixtureA->GetType() == b2Shape::e_quadtree");
}

void b2QuadtreeAndCircleContact::b2QuadtreeAndCircleContact()
{
  __assert_rtn("b2QuadtreeAndCircleContact", "b2QuadtreeAndOtherContact.cpp", 48, "m_fixtureB->GetType() == b2Shape::e_quadtree");
}

{
  __assert_rtn("b2QuadtreeAndCircleContact", "b2QuadtreeAndOtherContact.cpp", 47, "m_fixtureA->GetType() == b2Shape::e_circle");
}

void b2QuadtreeAndEdgeContact::b2QuadtreeAndEdgeContact()
{
  __assert_rtn("b2QuadtreeAndEdgeContact", "b2QuadtreeAndOtherContact.cpp", 117, "m_fixtureB->GetType() == b2Shape::e_edge");
}

{
  __assert_rtn("b2QuadtreeAndEdgeContact", "b2QuadtreeAndOtherContact.cpp", 116, "m_fixtureA->GetType() == b2Shape::e_quadtree");
}

void b2QuadtreeAndPolygonContact::b2QuadtreeAndPolygonContact()
{
  __assert_rtn("b2QuadtreeAndPolygonContact", "b2QuadtreeAndOtherContact.cpp", 140, "m_fixtureB->GetType() == b2Shape::e_polygon");
}

{
  __assert_rtn("b2QuadtreeAndPolygonContact", "b2QuadtreeAndOtherContact.cpp", 139, "m_fixtureA->GetType() == b2Shape::e_quadtree");
}

void b2QuadtreeAndQuadtreeContact::b2QuadtreeAndQuadtreeContact()
{
  __assert_rtn("b2QuadtreeAndQuadtreeContact", "b2QuadtreeAndOtherContact.cpp", 164, "m_fixtureB->GetType() == b2Shape::e_quadtree");
}

{
  __assert_rtn("b2QuadtreeAndQuadtreeContact", "b2QuadtreeAndOtherContact.cpp", 163, "m_fixtureA->GetType() == b2Shape::e_quadtree");
}

void b2Joint::Create()
{
  __assert_rtn("Create", "b2Joint.cpp", 102, "false");
}

void b2Joint::b2Joint()
{
  __assert_rtn("b2Joint", "b2Joint.cpp", 116, "def->bodyA != def->bodyB");
}

void b2MouseJoint::b2MouseJoint()
{
  __assert_rtn("b2MouseJoint", "b2MouseJoint.cpp", 34, "def->target.IsValid()");
}

{
  __assert_rtn("b2MouseJoint", "b2MouseJoint.cpp", 35, "b2IsValid(def->maxForce) && def->maxForce >= 0.0f");
}

{
  __assert_rtn("b2MouseJoint", "b2MouseJoint.cpp", 36, "b2IsValid(def->frequencyHz) && def->frequencyHz >= 0.0f");
}

{
  __assert_rtn("b2MouseJoint", "b2MouseJoint.cpp", 37, "b2IsValid(def->dampingRatio) && def->dampingRatio >= 0.0f");
}

void b2MouseJoint::InitVelocityConstraints()
{
  __assert_rtn("InitVelocityConstraints", "b2MouseJoint.cpp", 125, "d + h * k > 1.19209290e-7F");
}

void b2PrismaticJoint::SetLimits()
{
  __assert_rtn("SetLimits", "b2PrismaticJoint.cpp", 562, "lower <= upper");
}

void b2PulleyJointDef::Initialize()
{
  __assert_rtn("Initialize", "b2PulleyJoint.cpp", 51, "ratio > 1.19209290e-7F");
}

void b2PulleyJoint::b2PulleyJoint()
{
  __assert_rtn("b2PulleyJoint", "b2PulleyJoint.cpp", 62, "def->ratio != 0.0f");
}

void b2RevoluteJoint::SetLimits()
{
  __assert_rtn("SetLimits", "b2RevoluteJoint.cpp", 485, "lower <= upper");
}

void b2Rope::Initialize()
{
  __assert_rtn("Initialize", "b2Rope.cpp", 48, "def->count >= 3");
}

CFCharacterSetRef CFCharacterSetCreateWithCharactersInString(CFAllocatorRef alloc, CFStringRef theString)
{
  return (CFCharacterSetRef)MEMORY[0x24BDBBC18](alloc, theString);
}

void CFRelease(CFTypeRef cf)
{
  MEMORY[0x24BDBC298](cf);
}

CFStringRef CFStringCreateWithFormat(CFAllocatorRef alloc, CFDictionaryRef formatOptions, CFStringRef format, ...)
{
  return (CFStringRef)MEMORY[0x24BDBC598](alloc, formatOptions, format);
}

CFStringRef CFStringCreateWithSubstring(CFAllocatorRef alloc, CFStringRef str, CFRange range)
{
  return (CFStringRef)MEMORY[0x24BDBC5B0](alloc, str, range.location, range.length);
}

Boolean CFStringFindCharacterFromSet(CFStringRef theString, CFCharacterSetRef theSet, CFRange rangeToSearch, CFStringCompareFlags searchOptions, CFRange *result)
{
  return MEMORY[0x24BDBC5E0](theString, theSet, rangeToSearch.location, rangeToSearch.length, searchOptions, result);
}

UniChar CFStringGetCharacterAtIndex(CFStringRef theString, CFIndex idx)
{
  return MEMORY[0x24BDBC618](theString, idx);
}

double CFStringGetDoubleValue(CFStringRef str)
{
  double result;

  MEMORY[0x24BDBC630](str);
  return result;
}

CFIndex CFStringGetLength(CFStringRef theString)
{
  return MEMORY[0x24BDBC658](theString);
}

CGAffineTransform *__cdecl CGAffineTransformMakeScale(CGAffineTransform *__return_ptr retstr, CGFloat sx, CGFloat sy)
{
  return (CGAffineTransform *)MEMORY[0x24BDBD8E0](retstr, sx, sy);
}

void CGPathAddCurveToPoint(CGMutablePathRef path, const CGAffineTransform *m, CGFloat cp1x, CGFloat cp1y, CGFloat cp2x, CGFloat cp2y, CGFloat x, CGFloat y)
{
  MEMORY[0x24BDBEDB8](path, m, cp1x, cp1y, cp2x, cp2y, x, y);
}

void CGPathAddLineToPoint(CGMutablePathRef path, const CGAffineTransform *m, CGFloat x, CGFloat y)
{
  MEMORY[0x24BDBEDC8](path, m, x, y);
}

void CGPathAddQuadCurveToPoint(CGMutablePathRef path, const CGAffineTransform *m, CGFloat cpx, CGFloat cpy, CGFloat x, CGFloat y)
{
  MEMORY[0x24BDBEDE0](path, m, cpx, cpy, x, y);
}

void CGPathApply(CGPathRef path, void *info, CGPathApplierFunction function)
{
  MEMORY[0x24BDBEE08](path, info, function);
}

void CGPathCloseSubpath(CGMutablePathRef path)
{
  MEMORY[0x24BDBEE20](path);
}

BOOL CGPathContainsPoint(CGPathRef path, const CGAffineTransform *m, CGPoint point, BOOL eoFill)
{
  return MEMORY[0x24BDBEE28](path, m, eoFill, (__n128)point, *(__n128 *)&point.y);
}

CGPathRef CGPathCreateCopy(CGPathRef path)
{
  return (CGPathRef)MEMORY[0x24BDBEE30](path);
}

CGPathRef CGPathCreateCopyByTransformingPath(CGPathRef path, const CGAffineTransform *transform)
{
  return (CGPathRef)MEMORY[0x24BDBEE60](path, transform);
}

CGMutablePathRef CGPathCreateMutable(void)
{
  return (CGMutablePathRef)MEMORY[0x24BDBEE80]();
}

CGPathRef CGPathCreateWithEllipseInRect(CGRect rect, const CGAffineTransform *transform)
{
  return (CGPathRef)MEMORY[0x24BDBEEA0](transform, (__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
}

CGPathRef CGPathCreateWithRect(CGRect rect, const CGAffineTransform *transform)
{
  return (CGPathRef)MEMORY[0x24BDBEEA8](transform, (__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
}

BOOL CGPathEqualToPath(CGPathRef path1, CGPathRef path2)
{
  return MEMORY[0x24BDBEEB8](path1, path2);
}

uint64_t CGPathIsEllipse()
{
  return MEMORY[0x24BDBEF00]();
}

void CGPathMoveToPoint(CGMutablePathRef path, const CGAffineTransform *m, CGFloat x, CGFloat y)
{
  MEMORY[0x24BDBEF40](path, m, x, y);
}

void CGPathRelease(CGPathRef path)
{
  MEMORY[0x24BDBEF48](path);
}

CGFloat CGRectGetMidX(CGRect rect)
{
  CGFloat result;

  MEMORY[0x24BDBF000]((__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
  return result;
}

CGFloat CGRectGetMidY(CGRect rect)
{
  CGFloat result;

  MEMORY[0x24BDBF008]((__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
  return result;
}

BOOL CGRectIsEmpty(CGRect rect)
{
  return MEMORY[0x24BDBF050]((__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
}

BOOL CGRectIsInfinite(CGRect rect)
{
  return MEMORY[0x24BDBF058]((__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
}

BOOL CGRectIsNull(CGRect rect)
{
  return MEMORY[0x24BDBF060]((__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
}

NSZone *NSDefaultMallocZone(void)
{
  return (NSZone *)MEMORY[0x24BDD0BC8]();
}

void NSLog(NSString *format, ...)
{
  MEMORY[0x24BDD1000](format);
}

void _Block_object_dispose(const void *a1, const int a2)
{
  MEMORY[0x24BDAC730](a1, *(_QWORD *)&a2);
}

void _Unwind_Resume(_Unwind_Exception *exception_object)
{
  MEMORY[0x24BDAC780](exception_object);
}

std::logic_error *__cdecl std::logic_error::logic_error(std::logic_error *this, const char *a2)
{
  return (std::logic_error *)MEMORY[0x24BEDAAA8](this, a2);
}

std::bad_array_new_length *__cdecl std::bad_array_new_length::bad_array_new_length(std::bad_array_new_length *this)
{
  return (std::bad_array_new_length *)MEMORY[0x24BEDABB0](this);
}

size_t std::__next_prime(size_t __n)
{
  return MEMORY[0x24BEDABE8](__n);
}

void std::__shared_weak_count::__release_weak(std::__shared_weak_count *this)
{
  MEMORY[0x24BEDB180](this);
}

std::__shared_weak_count *__cdecl std::__shared_weak_count::lock(std::__shared_weak_count *this)
{
  return (std::__shared_weak_count *)MEMORY[0x24BEDB188](this);
}

void std::__shared_weak_count::~__shared_weak_count(std::__shared_weak_count *this)
{
  MEMORY[0x24BEDB190](this);
}

void std::exception::~exception(std::exception *this)
{
  MEMORY[0x24BEDB688](this);
}

void std::terminate(void)
{
  MEMORY[0x24BEDB6C0]();
}

void operator delete(void *__p)
{
  off_24C0E7360(__p);
}

uint64_t operator delete()
{
  return off_24C0E7368();
}

void *__cdecl operator new(size_t __sz)
{
  return (void *)off_24C0E7370(__sz);
}

uint64_t operator new()
{
  return off_24C0E7378();
}

void __assert_rtn(const char *a1, const char *a2, int a3, const char *a4)
{
  MEMORY[0x24BDAC7A0](a1, a2, *(_QWORD *)&a3, a4);
}

void *__cxa_allocate_exception(size_t thrown_size)
{
  return (void *)MEMORY[0x24BEDB8F8](thrown_size);
}

void *__cxa_begin_catch(void *a1)
{
  return (void *)MEMORY[0x24BEDB910](a1);
}

void __cxa_free_exception(void *a1)
{
  MEMORY[0x24BEDB930](a1);
}

int __cxa_guard_acquire(__guard *a1)
{
  return MEMORY[0x24BEDB948](a1);
}

void __cxa_guard_release(__guard *a1)
{
  MEMORY[0x24BEDB950](a1);
}

void __cxa_throw(void *a1, struct type_info *lptinfo, void (*a3)(void *))
{
  MEMORY[0x24BEDB960](a1, lptinfo, a3);
}

__float2 __sincosf_stret(float a1)
{
  float v1;
  float v2;
  __float2 result;

  MEMORY[0x24BDAC898](a1);
  result.__cosval = v2;
  result.__sinval = v1;
  return result;
}

long double atan2(long double __y, long double __x)
{
  long double result;

  MEMORY[0x24BDAD220](__y, __x);
  return result;
}

float atan2f(float a1, float a2)
{
  float result;

  MEMORY[0x24BDAD228](a1, a2);
  return result;
}

void bzero(void *a1, size_t a2)
{
  MEMORY[0x24BDAD320](a1, a2);
}

uint64_t dyld_get_active_platform()
{
  return MEMORY[0x24BDAE0D0]();
}

uint64_t dyld_program_sdk_at_least()
{
  return MEMORY[0x24BDAE148]();
}

float expf(float a1)
{
  float result;

  MEMORY[0x24BDAE288](a1);
  return result;
}

void free(void *a1)
{
  MEMORY[0x24BDAE450](a1);
}

int gettimeofday(timeval *a1, void *a2)
{
  return MEMORY[0x24BDAE780](a1, a2);
}

float hypotf(float a1, float a2)
{
  float result;

  MEMORY[0x24BDAE840](a1, a2);
  return result;
}

void *__cdecl malloc_type_malloc(size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x24BDAED78](size, type_id);
}

void *__cdecl memcpy(void *__dst, const void *__src, size_t __n)
{
  return (void *)MEMORY[0x24BDAEE80](__dst, __src, __n);
}

void *__cdecl memmove(void *__dst, const void *__src, size_t __len)
{
  return (void *)MEMORY[0x24BDAEE98](__dst, __src, __len);
}

void memset_pattern16(void *__b, const void *__pattern16, size_t __len)
{
  MEMORY[0x24BDAEEB0](__b, __pattern16, __len);
}

id objc_alloc(Class a1)
{
  return (id)MEMORY[0x24BEDCF68](a1);
}

uint64_t objc_alloc_init()
{
  return MEMORY[0x24BEDCF88]();
}

id objc_autoreleaseReturnValue(id a1)
{
  return (id)MEMORY[0x24BEDCFD0](a1);
}

uint64_t objc_claimAutoreleasedReturnValue()
{
  return MEMORY[0x24BEDCFE8]();
}

void objc_copyStruct(void *dest, const void *src, ptrdiff_t size, BOOL atomic, BOOL hasStrong)
{
  MEMORY[0x24BEDD020](dest, src, size, atomic, hasStrong);
}

void objc_destroyWeak(id *location)
{
  MEMORY[0x24BEDD038](location);
}

void objc_enumerationMutation(id obj)
{
  MEMORY[0x24BEDD068](obj);
}

id objc_initWeak(id *location, id val)
{
  return (id)MEMORY[0x24BEDD0C0](location, val);
}

id objc_loadWeakRetained(id *location)
{
  return (id)MEMORY[0x24BEDD0E8](location);
}

id objc_msgSendSuper2(objc_super *a1, SEL a2, ...)
{
  return (id)MEMORY[0x24BEDD120](a1, a2);
}

uint64_t objc_opt_class()
{
  return MEMORY[0x24BEDD130]();
}

uint64_t objc_opt_isKindOfClass()
{
  return MEMORY[0x24BEDD138]();
}

uint64_t objc_opt_new()
{
  return MEMORY[0x24BEDD148]();
}

uint64_t objc_opt_respondsToSelector()
{
  return MEMORY[0x24BEDD160]();
}

void objc_release(id a1)
{
  MEMORY[0x24BEDD188](a1);
}

id objc_retain(id a1)
{
  return (id)MEMORY[0x24BEDD2A0](a1);
}

id objc_retainAutorelease(id a1)
{
  return (id)MEMORY[0x24BEDD2A8](a1);
}

id objc_retainAutoreleaseReturnValue(id a1)
{
  return (id)MEMORY[0x24BEDD2B0](a1);
}

id objc_retainBlock(id a1)
{
  return (id)MEMORY[0x24BEDD2C0](a1);
}

void objc_setProperty_nonatomic_copy(id self, SEL _cmd, id newValue, ptrdiff_t offset)
{
  MEMORY[0x24BEDD408](self, _cmd, newValue, offset);
}

void objc_storeStrong(id *location, id obj)
{
  MEMORY[0x24BEDD410](location, obj);
}

id objc_storeWeak(id *location, id obj)
{
  return (id)MEMORY[0x24BEDD420](location, obj);
}

float powf(float a1, float a2)
{
  float result;

  MEMORY[0x24BDAF690](a1, a2);
  return result;
}

int printf(const char *a1, ...)
{
  return MEMORY[0x24BDAF6A8](a1);
}

int putchar(int a1)
{
  return MEMORY[0x24BDAF9F0](*(_QWORD *)&a1);
}

int puts(const char *a1)
{
  return MEMORY[0x24BDAF9F8](a1);
}

int strcmp(const char *__s1, const char *__s2)
{
  return MEMORY[0x24BDAFEF0](__s1, __s2);
}

